{
  "module_name": "be_main.c",
  "hash_id": "aa899e6e906a1c6a73a69b2aa6e54b735a353d8dbc88c72ade3b56786ddc8700",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/be2iscsi/be_main.c",
  "human_readable_source": " \n\n#include <linux/reboot.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/pci.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/semaphore.h>\n#include <linux/iscsi_boot_sysfs.h>\n#include <linux/module.h>\n#include <linux/bsg-lib.h>\n#include <linux/irq_poll.h>\n\n#include <scsi/libiscsi.h>\n#include <scsi/scsi_bsg_iscsi.h>\n#include <scsi/scsi_netlink.h>\n#include <scsi/scsi_transport_iscsi.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi.h>\n#include \"be_main.h\"\n#include \"be_iscsi.h\"\n#include \"be_mgmt.h\"\n#include \"be_cmds.h\"\n\nstatic unsigned int be_iopoll_budget = 10;\nstatic unsigned int be_max_phys_size = 64;\nstatic unsigned int enable_msix = 1;\n\nMODULE_DESCRIPTION(DRV_DESC \" \" BUILD_STR);\nMODULE_VERSION(BUILD_STR);\nMODULE_AUTHOR(\"Emulex Corporation\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(be_iopoll_budget, int, 0);\nmodule_param(enable_msix, int, 0);\nmodule_param(be_max_phys_size, uint, S_IRUGO);\nMODULE_PARM_DESC(be_max_phys_size,\n\t\t\"Maximum Size (In Kilobytes) of physically contiguous \"\n\t\t\"memory that can be allocated. Range is 16 - 128\");\n\n#define beiscsi_disp_param(_name)\\\nstatic ssize_t\t\\\nbeiscsi_##_name##_disp(struct device *dev,\\\n\t\t\tstruct device_attribute *attrib, char *buf)\t\\\n{\t\\\n\tstruct Scsi_Host *shost = class_to_shost(dev);\\\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost); \\\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\\\n\t\t\tphba->attr_##_name);\\\n}\n\n#define beiscsi_change_param(_name, _minval, _maxval, _defaval)\\\nstatic int \\\nbeiscsi_##_name##_change(struct beiscsi_hba *phba, uint32_t val)\\\n{\\\n\tif (val >= _minval && val <= _maxval) {\\\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\\\n\t\t\t    \"BA_%d : beiscsi_\"#_name\" updated \"\\\n\t\t\t    \"from 0x%x ==> 0x%x\\n\",\\\n\t\t\t    phba->attr_##_name, val); \\\n\t\tphba->attr_##_name = val;\\\n\t\treturn 0;\\\n\t} \\\n\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT, \\\n\t\t    \"BA_%d beiscsi_\"#_name\" attribute \"\\\n\t\t    \"cannot be updated to 0x%x, \"\\\n\t\t    \"range allowed is [\"#_minval\" - \"#_maxval\"]\\n\", val);\\\n\t\treturn -EINVAL;\\\n}\n\n#define beiscsi_store_param(_name)  \\\nstatic ssize_t \\\nbeiscsi_##_name##_store(struct device *dev,\\\n\t\t\t struct device_attribute *attr, const char *buf,\\\n\t\t\t size_t count) \\\n{ \\\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\\\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost);\\\n\tuint32_t param_val = 0;\\\n\tif (!isdigit(buf[0]))\\\n\t\treturn -EINVAL;\\\n\tif (sscanf(buf, \"%i\", &param_val) != 1)\\\n\t\treturn -EINVAL;\\\n\tif (beiscsi_##_name##_change(phba, param_val) == 0) \\\n\t\treturn strlen(buf);\\\n\telse \\\n\t\treturn -EINVAL;\\\n}\n\n#define beiscsi_init_param(_name, _minval, _maxval, _defval) \\\nstatic int \\\nbeiscsi_##_name##_init(struct beiscsi_hba *phba, uint32_t val) \\\n{ \\\n\tif (val >= _minval && val <= _maxval) {\\\n\t\tphba->attr_##_name = val;\\\n\t\treturn 0;\\\n\t} \\\n\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\\\n\t\t    \"BA_%d beiscsi_\"#_name\" attribute \" \\\n\t\t    \"cannot be updated to 0x%x, \"\\\n\t\t    \"range allowed is [\"#_minval\" - \"#_maxval\"]\\n\", val);\\\n\tphba->attr_##_name = _defval;\\\n\treturn -EINVAL;\\\n}\n\n#define BEISCSI_RW_ATTR(_name, _minval, _maxval, _defval, _descp) \\\nstatic uint beiscsi_##_name = _defval;\\\nmodule_param(beiscsi_##_name, uint, S_IRUGO);\\\nMODULE_PARM_DESC(beiscsi_##_name, _descp);\\\nbeiscsi_disp_param(_name)\\\nbeiscsi_change_param(_name, _minval, _maxval, _defval)\\\nbeiscsi_store_param(_name)\\\nbeiscsi_init_param(_name, _minval, _maxval, _defval)\\\nstatic DEVICE_ATTR(beiscsi_##_name, S_IRUGO | S_IWUSR,\\\n\t      beiscsi_##_name##_disp, beiscsi_##_name##_store)\n\n \nBEISCSI_RW_ATTR(log_enable, 0x00,\n\t\t0xFF, 0x00, \"Enable logging Bit Mask\\n\"\n\t\t\"\\t\\t\\t\\tInitialization Events\t: 0x01\\n\"\n\t\t\"\\t\\t\\t\\tMailbox Events\t\t: 0x02\\n\"\n\t\t\"\\t\\t\\t\\tMiscellaneous Events\t: 0x04\\n\"\n\t\t\"\\t\\t\\t\\tError Handling\t\t: 0x08\\n\"\n\t\t\"\\t\\t\\t\\tIO Path Events\t\t: 0x10\\n\"\n\t\t\"\\t\\t\\t\\tConfiguration Path\t: 0x20\\n\"\n\t\t\"\\t\\t\\t\\tiSCSI Protocol\t\t: 0x40\\n\");\n\nstatic DEVICE_ATTR(beiscsi_drvr_ver, S_IRUGO, beiscsi_drvr_ver_disp, NULL);\nstatic DEVICE_ATTR(beiscsi_adapter_family, S_IRUGO, beiscsi_adap_family_disp, NULL);\nstatic DEVICE_ATTR(beiscsi_fw_ver, S_IRUGO, beiscsi_fw_ver_disp, NULL);\nstatic DEVICE_ATTR(beiscsi_phys_port, S_IRUGO, beiscsi_phys_port_disp, NULL);\nstatic DEVICE_ATTR(beiscsi_active_session_count, S_IRUGO,\n\t\t   beiscsi_active_session_disp, NULL);\nstatic DEVICE_ATTR(beiscsi_free_session_count, S_IRUGO,\n\t\t   beiscsi_free_session_disp, NULL);\n\nstatic struct attribute *beiscsi_attrs[] = {\n\t&dev_attr_beiscsi_log_enable.attr,\n\t&dev_attr_beiscsi_drvr_ver.attr,\n\t&dev_attr_beiscsi_adapter_family.attr,\n\t&dev_attr_beiscsi_fw_ver.attr,\n\t&dev_attr_beiscsi_active_session_count.attr,\n\t&dev_attr_beiscsi_free_session_count.attr,\n\t&dev_attr_beiscsi_phys_port.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(beiscsi);\n\nstatic char const *cqe_desc[] = {\n\t\"RESERVED_DESC\",\n\t\"SOL_CMD_COMPLETE\",\n\t\"SOL_CMD_KILLED_DATA_DIGEST_ERR\",\n\t\"CXN_KILLED_PDU_SIZE_EXCEEDS_DSL\",\n\t\"CXN_KILLED_BURST_LEN_MISMATCH\",\n\t\"CXN_KILLED_AHS_RCVD\",\n\t\"CXN_KILLED_HDR_DIGEST_ERR\",\n\t\"CXN_KILLED_UNKNOWN_HDR\",\n\t\"CXN_KILLED_STALE_ITT_TTT_RCVD\",\n\t\"CXN_KILLED_INVALID_ITT_TTT_RCVD\",\n\t\"CXN_KILLED_RST_RCVD\",\n\t\"CXN_KILLED_TIMED_OUT\",\n\t\"CXN_KILLED_RST_SENT\",\n\t\"CXN_KILLED_FIN_RCVD\",\n\t\"CXN_KILLED_BAD_UNSOL_PDU_RCVD\",\n\t\"CXN_KILLED_BAD_WRB_INDEX_ERROR\",\n\t\"CXN_KILLED_OVER_RUN_RESIDUAL\",\n\t\"CXN_KILLED_UNDER_RUN_RESIDUAL\",\n\t\"CMD_KILLED_INVALID_STATSN_RCVD\",\n\t\"CMD_KILLED_INVALID_R2T_RCVD\",\n\t\"CMD_CXN_KILLED_LUN_INVALID\",\n\t\"CMD_CXN_KILLED_ICD_INVALID\",\n\t\"CMD_CXN_KILLED_ITT_INVALID\",\n\t\"CMD_CXN_KILLED_SEQ_OUTOFORDER\",\n\t\"CMD_CXN_KILLED_INVALID_DATASN_RCVD\",\n\t\"CXN_INVALIDATE_NOTIFY\",\n\t\"CXN_INVALIDATE_INDEX_NOTIFY\",\n\t\"CMD_INVALIDATED_NOTIFY\",\n\t\"UNSOL_HDR_NOTIFY\",\n\t\"UNSOL_DATA_NOTIFY\",\n\t\"UNSOL_DATA_DIGEST_ERROR_NOTIFY\",\n\t\"DRIVERMSG_NOTIFY\",\n\t\"CXN_KILLED_CMND_DATA_NOT_ON_SAME_CONN\",\n\t\"SOL_CMD_KILLED_DIF_ERR\",\n\t\"CXN_KILLED_SYN_RCVD\",\n\t\"CXN_KILLED_IMM_DATA_RCVD\"\n};\n\nstatic int beiscsi_eh_abort(struct scsi_cmnd *sc)\n{\n\tstruct iscsi_task *abrt_task = iscsi_cmd(sc)->task;\n\tstruct iscsi_cls_session *cls_session;\n\tstruct beiscsi_io_task *abrt_io_task;\n\tstruct beiscsi_conn *beiscsi_conn;\n\tstruct iscsi_session *session;\n\tstruct invldt_cmd_tbl inv_tbl;\n\tstruct beiscsi_hba *phba;\n\tstruct iscsi_conn *conn;\n\tint rc;\n\n\tcls_session = starget_to_session(scsi_target(sc->device));\n\tsession = cls_session->dd_data;\n\ncompletion_check:\n\t \n\tspin_lock_bh(&session->back_lock);\n\tif (!abrt_task || !abrt_task->sc) {\n\t\tspin_unlock_bh(&session->back_lock);\n\t\treturn SUCCESS;\n\t}\n\t \n\tif (!iscsi_get_task(abrt_task)) {\n\t\tspin_unlock(&session->back_lock);\n\t\t \n\t\tudelay(5);\n\t\tgoto completion_check;\n\t}\n\n\tabrt_io_task = abrt_task->dd_data;\n\tconn = abrt_task->conn;\n\tbeiscsi_conn = conn->dd_data;\n\tphba = beiscsi_conn->phba;\n\t \n\tif (is_chip_be2_be3r(phba)) {\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, invld,\n\t\t\t      abrt_io_task->pwrb_handle->pwrb, 1);\n\t} else {\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, invld,\n\t\t\t      abrt_io_task->pwrb_handle->pwrb, 1);\n\t}\n\tinv_tbl.cid = beiscsi_conn->beiscsi_conn_cid;\n\tinv_tbl.icd = abrt_io_task->psgl_handle->sgl_index;\n\tspin_unlock_bh(&session->back_lock);\n\n\trc = beiscsi_mgmt_invalidate_icds(phba, &inv_tbl, 1);\n\tiscsi_put_task(abrt_task);\n\tif (rc) {\n\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_EH,\n\t\t\t    \"BM_%d : sc %p invalidation failed %d\\n\",\n\t\t\t    sc, rc);\n\t\treturn FAILED;\n\t}\n\n\treturn iscsi_eh_abort(sc);\n}\n\nstatic int beiscsi_eh_device_reset(struct scsi_cmnd *sc)\n{\n\tstruct beiscsi_invldt_cmd_tbl {\n\t\tstruct invldt_cmd_tbl tbl[BE_INVLDT_CMD_TBL_SZ];\n\t\tstruct iscsi_task *task[BE_INVLDT_CMD_TBL_SZ];\n\t} *inv_tbl;\n\tstruct iscsi_cls_session *cls_session;\n\tstruct beiscsi_conn *beiscsi_conn;\n\tstruct beiscsi_io_task *io_task;\n\tstruct iscsi_session *session;\n\tstruct beiscsi_hba *phba;\n\tstruct iscsi_conn *conn;\n\tstruct iscsi_task *task;\n\tunsigned int i, nents;\n\tint rc, more = 0;\n\n\tcls_session = starget_to_session(scsi_target(sc->device));\n\tsession = cls_session->dd_data;\n\n\tspin_lock_bh(&session->frwd_lock);\n\tif (!session->leadconn || session->state != ISCSI_STATE_LOGGED_IN) {\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\treturn FAILED;\n\t}\n\n\tconn = session->leadconn;\n\tbeiscsi_conn = conn->dd_data;\n\tphba = beiscsi_conn->phba;\n\n\tinv_tbl = kzalloc(sizeof(*inv_tbl), GFP_ATOMIC);\n\tif (!inv_tbl) {\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_EH,\n\t\t\t    \"BM_%d : invldt_cmd_tbl alloc failed\\n\");\n\t\treturn FAILED;\n\t}\n\tnents = 0;\n\t \n\tspin_lock(&session->back_lock);\n\tfor (i = 0; i < conn->session->cmds_max; i++) {\n\t\ttask = conn->session->cmds[i];\n\t\tif (!task->sc)\n\t\t\tcontinue;\n\n\t\tif (sc->device->lun != task->sc->device->lun)\n\t\t\tcontinue;\n\t\t \n\t\tif (nents == BE_INVLDT_CMD_TBL_SZ) {\n\t\t\tmore = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!iscsi_get_task(task)) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tio_task = task->dd_data;\n\t\t \n\t\tif (is_chip_be2_be3r(phba)) {\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, invld,\n\t\t\t\t      io_task->pwrb_handle->pwrb, 1);\n\t\t} else {\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, invld,\n\t\t\t\t      io_task->pwrb_handle->pwrb, 1);\n\t\t}\n\n\t\tinv_tbl->tbl[nents].cid = beiscsi_conn->beiscsi_conn_cid;\n\t\tinv_tbl->tbl[nents].icd = io_task->psgl_handle->sgl_index;\n\t\tinv_tbl->task[nents] = task;\n\t\tnents++;\n\t}\n\tspin_unlock(&session->back_lock);\n\tspin_unlock_bh(&session->frwd_lock);\n\n\trc = SUCCESS;\n\tif (!nents)\n\t\tgoto end_reset;\n\n\tif (more) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_EH,\n\t\t\t    \"BM_%d : number of cmds exceeds size of invalidation table\\n\");\n\t\trc = FAILED;\n\t\tgoto end_reset;\n\t}\n\n\tif (beiscsi_mgmt_invalidate_icds(phba, &inv_tbl->tbl[0], nents)) {\n\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_EH,\n\t\t\t    \"BM_%d : cid %u scmds invalidation failed\\n\",\n\t\t\t    beiscsi_conn->beiscsi_conn_cid);\n\t\trc = FAILED;\n\t}\n\nend_reset:\n\tfor (i = 0; i < nents; i++)\n\t\tiscsi_put_task(inv_tbl->task[i]);\n\tkfree(inv_tbl);\n\n\tif (rc == SUCCESS)\n\t\trc = iscsi_eh_device_reset(sc);\n\treturn rc;\n}\n\n \nstatic const struct pci_device_id beiscsi_pci_id_table[] = {\n\t{ PCI_DEVICE(BE_VENDOR_ID, BE_DEVICE_ID1) },\n\t{ PCI_DEVICE(BE_VENDOR_ID, BE_DEVICE_ID2) },\n\t{ PCI_DEVICE(BE_VENDOR_ID, OC_DEVICE_ID1) },\n\t{ PCI_DEVICE(BE_VENDOR_ID, OC_DEVICE_ID2) },\n\t{ PCI_DEVICE(BE_VENDOR_ID, OC_DEVICE_ID3) },\n\t{ PCI_DEVICE(ELX_VENDOR_ID, OC_SKH_ID1) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, beiscsi_pci_id_table);\n\n\nstatic const struct scsi_host_template beiscsi_sht = {\n\t.module = THIS_MODULE,\n\t.name = \"Emulex 10Gbe open-iscsi Initiator Driver\",\n\t.proc_name = DRV_NAME,\n\t.queuecommand = iscsi_queuecommand,\n\t.change_queue_depth = scsi_change_queue_depth,\n\t.target_alloc = iscsi_target_alloc,\n\t.eh_timed_out = iscsi_eh_cmd_timed_out,\n\t.eh_abort_handler = beiscsi_eh_abort,\n\t.eh_device_reset_handler = beiscsi_eh_device_reset,\n\t.eh_target_reset_handler = iscsi_eh_session_reset,\n\t.shost_groups = beiscsi_groups,\n\t.sg_tablesize = BEISCSI_SGLIST_ELEMENTS,\n\t.can_queue = BE2_IO_DEPTH,\n\t.this_id = -1,\n\t.max_sectors = BEISCSI_MAX_SECTORS,\n\t.max_segment_size = 65536,\n\t.cmd_per_lun = BEISCSI_CMD_PER_LUN,\n\t.vendor_id = SCSI_NL_VID_TYPE_PCI | BE_VENDOR_ID,\n\t.track_queue_depth = 1,\n\t.cmd_size = sizeof(struct iscsi_cmd),\n};\n\nstatic struct scsi_transport_template *beiscsi_scsi_transport;\n\nstatic struct beiscsi_hba *beiscsi_hba_alloc(struct pci_dev *pcidev)\n{\n\tstruct beiscsi_hba *phba;\n\tstruct Scsi_Host *shost;\n\n\tshost = iscsi_host_alloc(&beiscsi_sht, sizeof(*phba), 0);\n\tif (!shost) {\n\t\tdev_err(&pcidev->dev,\n\t\t\t\"beiscsi_hba_alloc - iscsi_host_alloc failed\\n\");\n\t\treturn NULL;\n\t}\n\tshost->max_id = BE2_MAX_SESSIONS - 1;\n\tshost->max_channel = 0;\n\tshost->max_cmd_len = BEISCSI_MAX_CMD_LEN;\n\tshost->max_lun = BEISCSI_NUM_MAX_LUN;\n\tshost->transportt = beiscsi_scsi_transport;\n\tphba = iscsi_host_priv(shost);\n\tmemset(phba, 0, sizeof(*phba));\n\tphba->shost = shost;\n\tphba->pcidev = pci_dev_get(pcidev);\n\tpci_set_drvdata(pcidev, phba);\n\tphba->interface_handle = 0xFFFFFFFF;\n\n\treturn phba;\n}\n\nstatic void beiscsi_unmap_pci_function(struct beiscsi_hba *phba)\n{\n\tif (phba->csr_va) {\n\t\tiounmap(phba->csr_va);\n\t\tphba->csr_va = NULL;\n\t}\n\tif (phba->db_va) {\n\t\tiounmap(phba->db_va);\n\t\tphba->db_va = NULL;\n\t}\n\tif (phba->pci_va) {\n\t\tiounmap(phba->pci_va);\n\t\tphba->pci_va = NULL;\n\t}\n}\n\nstatic int beiscsi_map_pci_bars(struct beiscsi_hba *phba,\n\t\t\t\tstruct pci_dev *pcidev)\n{\n\tu8 __iomem *addr;\n\tint pcicfg_reg;\n\n\taddr = ioremap(pci_resource_start(pcidev, 2),\n\t\t\t       pci_resource_len(pcidev, 2));\n\tif (addr == NULL)\n\t\treturn -ENOMEM;\n\tphba->ctrl.csr = addr;\n\tphba->csr_va = addr;\n\n\taddr = ioremap(pci_resource_start(pcidev, 4), 128 * 1024);\n\tif (addr == NULL)\n\t\tgoto pci_map_err;\n\tphba->ctrl.db = addr;\n\tphba->db_va = addr;\n\n\tif (phba->generation == BE_GEN2)\n\t\tpcicfg_reg = 1;\n\telse\n\t\tpcicfg_reg = 0;\n\n\taddr = ioremap(pci_resource_start(pcidev, pcicfg_reg),\n\t\t\t       pci_resource_len(pcidev, pcicfg_reg));\n\n\tif (addr == NULL)\n\t\tgoto pci_map_err;\n\tphba->ctrl.pcicfg = addr;\n\tphba->pci_va = addr;\n\treturn 0;\n\npci_map_err:\n\tbeiscsi_unmap_pci_function(phba);\n\treturn -ENOMEM;\n}\n\nstatic int beiscsi_enable_pci(struct pci_dev *pcidev)\n{\n\tint ret;\n\n\tret = pci_enable_device(pcidev);\n\tif (ret) {\n\t\tdev_err(&pcidev->dev,\n\t\t\t\"beiscsi_enable_pci - enable device failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pci_request_regions(pcidev, DRV_NAME);\n\tif (ret) {\n\t\tdev_err(&pcidev->dev,\n\t\t\t\t\"beiscsi_enable_pci - request region failed\\n\");\n\t\tgoto pci_dev_disable;\n\t}\n\n\tpci_set_master(pcidev);\n\tret = dma_set_mask_and_coherent(&pcidev->dev, DMA_BIT_MASK(64));\n\tif (ret) {\n\t\tret = dma_set_mask_and_coherent(&pcidev->dev, DMA_BIT_MASK(32));\n\t\tif (ret) {\n\t\t\tdev_err(&pcidev->dev, \"Could not set PCI DMA Mask\\n\");\n\t\t\tgoto pci_region_release;\n\t\t}\n\t}\n\treturn 0;\n\npci_region_release:\n\tpci_release_regions(pcidev);\npci_dev_disable:\n\tpci_disable_device(pcidev);\n\n\treturn ret;\n}\n\nstatic int be_ctrl_init(struct beiscsi_hba *phba, struct pci_dev *pdev)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct be_dma_mem *mbox_mem_alloc = &ctrl->mbox_mem_alloced;\n\tstruct be_dma_mem *mbox_mem_align = &ctrl->mbox_mem;\n\tint status = 0;\n\n\tctrl->pdev = pdev;\n\tstatus = beiscsi_map_pci_bars(phba, pdev);\n\tif (status)\n\t\treturn status;\n\tmbox_mem_alloc->size = sizeof(struct be_mcc_mailbox) + 16;\n\tmbox_mem_alloc->va = dma_alloc_coherent(&pdev->dev,\n\t\t\tmbox_mem_alloc->size, &mbox_mem_alloc->dma, GFP_KERNEL);\n\tif (!mbox_mem_alloc->va) {\n\t\tbeiscsi_unmap_pci_function(phba);\n\t\treturn -ENOMEM;\n\t}\n\n\tmbox_mem_align->size = sizeof(struct be_mcc_mailbox);\n\tmbox_mem_align->va = PTR_ALIGN(mbox_mem_alloc->va, 16);\n\tmbox_mem_align->dma = PTR_ALIGN(mbox_mem_alloc->dma, 16);\n\tmemset(mbox_mem_align->va, 0, sizeof(struct be_mcc_mailbox));\n\tmutex_init(&ctrl->mbox_lock);\n\tspin_lock_init(&phba->ctrl.mcc_lock);\n\n\treturn status;\n}\n\n \nstatic void beiscsi_get_params(struct beiscsi_hba *phba)\n{\n\tuint32_t total_cid_count = 0;\n\tuint32_t total_icd_count = 0;\n\tuint8_t ulp_num = 0;\n\n\ttotal_cid_count = BEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP0) +\n\t\t\t  BEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP1);\n\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\n\t\tuint32_t align_mask = 0;\n\t\tuint32_t icd_post_per_page = 0;\n\t\tuint32_t icd_count_unavailable = 0;\n\t\tuint32_t icd_start = 0, icd_count = 0;\n\t\tuint32_t icd_start_align = 0, icd_count_align = 0;\n\n\t\tif (test_bit(ulp_num, &phba->fw_config.ulp_supported)) {\n\t\t\ticd_start = phba->fw_config.iscsi_icd_start[ulp_num];\n\t\t\ticd_count = phba->fw_config.iscsi_icd_count[ulp_num];\n\n\t\t\t \n\t\t\ticd_post_per_page = (PAGE_SIZE / (BE2_SGE *\n\t\t\t\t\t     sizeof(struct iscsi_sge)));\n\t\t\talign_mask = (icd_post_per_page - 1);\n\n\t\t\t \n\t\t\tif (icd_start % icd_post_per_page) {\n\t\t\t\ticd_start_align = ((icd_start +\n\t\t\t\t\t\t    icd_post_per_page) &\n\t\t\t\t\t\t    ~(align_mask));\n\t\t\t\tphba->fw_config.\n\t\t\t\t\tiscsi_icd_start[ulp_num] =\n\t\t\t\t\ticd_start_align;\n\t\t\t}\n\n\t\t\ticd_count_align = (icd_count & ~align_mask);\n\n\t\t\t \n\t\t\tif (icd_start_align)\n\t\t\t\ticd_count_unavailable = ((icd_start_align -\n\t\t\t\t\t\t\t  icd_start) +\n\t\t\t\t\t\t\t (icd_count -\n\t\t\t\t\t\t\t  icd_count_align));\n\n\t\t\t \n\t\t\tphba->fw_config.iscsi_icd_count[ulp_num] = (icd_count -\n\t\t\t\t\ticd_count_unavailable);\n\n\t\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t\t\t\"BM_%d : Aligned ICD values\\n\"\n\t\t\t\t\t\"\\t ICD Start : %d\\n\"\n\t\t\t\t\t\"\\t ICD Count : %d\\n\"\n\t\t\t\t\t\"\\t ICD Discarded : %d\\n\",\n\t\t\t\t\tphba->fw_config.\n\t\t\t\t\tiscsi_icd_start[ulp_num],\n\t\t\t\t\tphba->fw_config.\n\t\t\t\t\tiscsi_icd_count[ulp_num],\n\t\t\t\t\ticd_count_unavailable);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttotal_icd_count = phba->fw_config.iscsi_icd_count[ulp_num];\n\tphba->params.ios_per_ctrl = (total_icd_count -\n\t\t\t\t    (total_cid_count +\n\t\t\t\t     BE2_TMFS + BE2_NOPOUT_REQ));\n\tphba->params.cxns_per_ctrl = total_cid_count;\n\tphba->params.icds_per_ctrl = total_icd_count;\n\tphba->params.num_sge_per_io = BE2_SGE;\n\tphba->params.defpdu_hdr_sz = BE2_DEFPDU_HDR_SZ;\n\tphba->params.defpdu_data_sz = BE2_DEFPDU_DATA_SZ;\n\tphba->params.num_eq_entries = 1024;\n\tphba->params.num_cq_entries = 1024;\n\tphba->params.wrbs_per_cxn = 256;\n}\n\nstatic void hwi_ring_eq_db(struct beiscsi_hba *phba,\n\t\t\t   unsigned int id, unsigned int clr_interrupt,\n\t\t\t   unsigned int num_processed,\n\t\t\t   unsigned char rearm, unsigned char event)\n{\n\tu32 val = 0;\n\n\tif (rearm)\n\t\tval |= 1 << DB_EQ_REARM_SHIFT;\n\tif (clr_interrupt)\n\t\tval |= 1 << DB_EQ_CLR_SHIFT;\n\tif (event)\n\t\tval |= 1 << DB_EQ_EVNT_SHIFT;\n\n\tval |= num_processed << DB_EQ_NUM_POPPED_SHIFT;\n\t \n\tval |= (id & DB_EQ_RING_ID_LOW_MASK);\n\n\t \n\tval |= (((id >> DB_EQ_HIGH_FEILD_SHIFT) &\n\t\t  DB_EQ_RING_ID_HIGH_MASK)\n\t\t  << DB_EQ_HIGH_SET_SHIFT);\n\n\tiowrite32(val, phba->db_va + DB_EQ_OFFSET);\n}\n\n \nstatic irqreturn_t be_isr_mcc(int irq, void *dev_id)\n{\n\tstruct beiscsi_hba *phba;\n\tstruct be_eq_entry *eqe;\n\tstruct be_queue_info *eq;\n\tstruct be_queue_info *mcc;\n\tunsigned int mcc_events;\n\tstruct be_eq_obj *pbe_eq;\n\n\tpbe_eq = dev_id;\n\teq = &pbe_eq->q;\n\tphba =  pbe_eq->phba;\n\tmcc = &phba->ctrl.mcc_obj.cq;\n\teqe = queue_tail_node(eq);\n\n\tmcc_events = 0;\n\twhile (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]\n\t\t\t\t& EQE_VALID_MASK) {\n\t\tif (((eqe->dw[offsetof(struct amap_eq_entry,\n\t\t     resource_id) / 32] &\n\t\t     EQE_RESID_MASK) >> 16) == mcc->id) {\n\t\t\tmcc_events++;\n\t\t}\n\t\tAMAP_SET_BITS(struct amap_eq_entry, valid, eqe, 0);\n\t\tqueue_tail_inc(eq);\n\t\teqe = queue_tail_node(eq);\n\t}\n\n\tif (mcc_events) {\n\t\tqueue_work(phba->wq, &pbe_eq->mcc_work);\n\t\thwi_ring_eq_db(phba, eq->id, 1,\tmcc_events, 1, 1);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t be_isr_msix(int irq, void *dev_id)\n{\n\tstruct beiscsi_hba *phba;\n\tstruct be_queue_info *eq;\n\tstruct be_eq_obj *pbe_eq;\n\n\tpbe_eq = dev_id;\n\teq = &pbe_eq->q;\n\n\tphba = pbe_eq->phba;\n\t \n\thwi_ring_eq_db(phba, eq->id, 1,\t0, 0, 1);\n\tirq_poll_sched(&pbe_eq->iopoll);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t be_isr(int irq, void *dev_id)\n{\n\tstruct beiscsi_hba *phba;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct hwi_context_memory *phwi_context;\n\tstruct be_eq_entry *eqe;\n\tstruct be_queue_info *eq;\n\tstruct be_queue_info *mcc;\n\tunsigned int mcc_events, io_events;\n\tstruct be_ctrl_info *ctrl;\n\tstruct be_eq_obj *pbe_eq;\n\tint isr, rearm;\n\n\tphba = dev_id;\n\tctrl = &phba->ctrl;\n\tisr = ioread32(ctrl->csr + CEV_ISR0_OFFSET +\n\t\t       (PCI_FUNC(ctrl->pdev->devfn) * CEV_ISR_SIZE));\n\tif (!isr)\n\t\treturn IRQ_NONE;\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tphwi_context = phwi_ctrlr->phwi_ctxt;\n\tpbe_eq = &phwi_context->be_eq[0];\n\n\teq = &phwi_context->be_eq[0].q;\n\tmcc = &phba->ctrl.mcc_obj.cq;\n\teqe = queue_tail_node(eq);\n\n\tio_events = 0;\n\tmcc_events = 0;\n\twhile (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]\n\t\t\t\t& EQE_VALID_MASK) {\n\t\tif (((eqe->dw[offsetof(struct amap_eq_entry,\n\t\t      resource_id) / 32] & EQE_RESID_MASK) >> 16) == mcc->id)\n\t\t\tmcc_events++;\n\t\telse\n\t\t\tio_events++;\n\t\tAMAP_SET_BITS(struct amap_eq_entry, valid, eqe, 0);\n\t\tqueue_tail_inc(eq);\n\t\teqe = queue_tail_node(eq);\n\t}\n\tif (!io_events && !mcc_events)\n\t\treturn IRQ_NONE;\n\n\t \n\trearm = 0;\n\tif (mcc_events) {\n\t\tqueue_work(phba->wq, &pbe_eq->mcc_work);\n\t\t \n\t\trearm = 1;\n\t}\n\tif (io_events)\n\t\tirq_poll_sched(&pbe_eq->iopoll);\n\thwi_ring_eq_db(phba, eq->id, 0, (io_events + mcc_events), rearm, 1);\n\treturn IRQ_HANDLED;\n}\n\nstatic void beiscsi_free_irqs(struct beiscsi_hba *phba)\n{\n\tstruct hwi_context_memory *phwi_context;\n\tint i;\n\n\tif (!phba->pcidev->msix_enabled) {\n\t\tif (phba->pcidev->irq)\n\t\t\tfree_irq(phba->pcidev->irq, phba);\n\t\treturn;\n\t}\n\n\tphwi_context = phba->phwi_ctrlr->phwi_ctxt;\n\tfor (i = 0; i <= phba->num_cpus; i++) {\n\t\tfree_irq(pci_irq_vector(phba->pcidev, i),\n\t\t\t &phwi_context->be_eq[i]);\n\t\tkfree(phba->msi_name[i]);\n\t}\n}\n\nstatic int beiscsi_init_irqs(struct beiscsi_hba *phba)\n{\n\tstruct pci_dev *pcidev = phba->pcidev;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct hwi_context_memory *phwi_context;\n\tint ret, i, j;\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tphwi_context = phwi_ctrlr->phwi_ctxt;\n\n\tif (pcidev->msix_enabled) {\n\t\tfor (i = 0; i < phba->num_cpus; i++) {\n\t\t\tphba->msi_name[i] = kasprintf(GFP_KERNEL,\n\t\t\t\t\t\t      \"beiscsi_%02x_%02x\",\n\t\t\t\t\t\t      phba->shost->host_no, i);\n\t\t\tif (!phba->msi_name[i]) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_msix_irqs;\n\t\t\t}\n\n\t\t\tret = request_irq(pci_irq_vector(pcidev, i),\n\t\t\t\t\t  be_isr_msix, 0, phba->msi_name[i],\n\t\t\t\t\t  &phwi_context->be_eq[i]);\n\t\t\tif (ret) {\n\t\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t\t    \"BM_%d : %s-Failed to register msix for i = %d\\n\",\n\t\t\t\t\t    __func__, i);\n\t\t\t\tkfree(phba->msi_name[i]);\n\t\t\t\tgoto free_msix_irqs;\n\t\t\t}\n\t\t}\n\t\tphba->msi_name[i] = kasprintf(GFP_KERNEL, \"beiscsi_mcc_%02x\",\n\t\t\t\t\t      phba->shost->host_no);\n\t\tif (!phba->msi_name[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_msix_irqs;\n\t\t}\n\t\tret = request_irq(pci_irq_vector(pcidev, i), be_isr_mcc, 0,\n\t\t\t\t  phba->msi_name[i], &phwi_context->be_eq[i]);\n\t\tif (ret) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BM_%d : %s-Failed to register beiscsi_msix_mcc\\n\",\n\t\t\t\t    __func__);\n\t\t\tkfree(phba->msi_name[i]);\n\t\t\tgoto free_msix_irqs;\n\t\t}\n\n\t} else {\n\t\tret = request_irq(pcidev->irq, be_isr, IRQF_SHARED,\n\t\t\t\t  \"beiscsi\", phba);\n\t\tif (ret) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BM_%d : %s-Failed to register irq\\n\",\n\t\t\t\t    __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\nfree_msix_irqs:\n\tfor (j = i - 1; j >= 0; j--) {\n\t\tfree_irq(pci_irq_vector(pcidev, i), &phwi_context->be_eq[j]);\n\t\tkfree(phba->msi_name[j]);\n\t}\n\treturn ret;\n}\n\nvoid hwi_ring_cq_db(struct beiscsi_hba *phba,\n\t\t\t   unsigned int id, unsigned int num_processed,\n\t\t\t   unsigned char rearm)\n{\n\tu32 val = 0;\n\n\tif (rearm)\n\t\tval |= 1 << DB_CQ_REARM_SHIFT;\n\n\tval |= num_processed << DB_CQ_NUM_POPPED_SHIFT;\n\n\t \n\tval |= (id & DB_CQ_RING_ID_LOW_MASK);\n\n\t \n\tval |= (((id >> DB_CQ_HIGH_FEILD_SHIFT) &\n\t\t  DB_CQ_RING_ID_HIGH_MASK)\n\t\t  << DB_CQ_HIGH_SET_SHIFT);\n\n\tiowrite32(val, phba->db_va + DB_CQ_OFFSET);\n}\n\nstatic struct sgl_handle *alloc_io_sgl_handle(struct beiscsi_hba *phba)\n{\n\tstruct sgl_handle *psgl_handle;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&phba->io_sgl_lock, flags);\n\tif (phba->io_sgl_hndl_avbl) {\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_IO,\n\t\t\t    \"BM_%d : In alloc_io_sgl_handle,\"\n\t\t\t    \" io_sgl_alloc_index=%d\\n\",\n\t\t\t    phba->io_sgl_alloc_index);\n\n\t\tpsgl_handle = phba->io_sgl_hndl_base[phba->\n\t\t\t\t\t\tio_sgl_alloc_index];\n\t\tphba->io_sgl_hndl_base[phba->io_sgl_alloc_index] = NULL;\n\t\tphba->io_sgl_hndl_avbl--;\n\t\tif (phba->io_sgl_alloc_index == (phba->params.\n\t\t\t\t\t\t ios_per_ctrl - 1))\n\t\t\tphba->io_sgl_alloc_index = 0;\n\t\telse\n\t\t\tphba->io_sgl_alloc_index++;\n\t} else\n\t\tpsgl_handle = NULL;\n\tspin_unlock_irqrestore(&phba->io_sgl_lock, flags);\n\treturn psgl_handle;\n}\n\nstatic void\nfree_io_sgl_handle(struct beiscsi_hba *phba, struct sgl_handle *psgl_handle)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&phba->io_sgl_lock, flags);\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_IO,\n\t\t    \"BM_%d : In free_,io_sgl_free_index=%d\\n\",\n\t\t    phba->io_sgl_free_index);\n\n\tif (phba->io_sgl_hndl_base[phba->io_sgl_free_index]) {\n\t\t \n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_IO,\n\t\t\t    \"BM_%d : Double Free in IO SGL io_sgl_free_index=%d, value there=%p\\n\",\n\t\t\t    phba->io_sgl_free_index,\n\t\t\t    phba->io_sgl_hndl_base[phba->io_sgl_free_index]);\n\t\tspin_unlock_irqrestore(&phba->io_sgl_lock, flags);\n\t\treturn;\n\t}\n\tphba->io_sgl_hndl_base[phba->io_sgl_free_index] = psgl_handle;\n\tphba->io_sgl_hndl_avbl++;\n\tif (phba->io_sgl_free_index == (phba->params.ios_per_ctrl - 1))\n\t\tphba->io_sgl_free_index = 0;\n\telse\n\t\tphba->io_sgl_free_index++;\n\tspin_unlock_irqrestore(&phba->io_sgl_lock, flags);\n}\n\nstatic inline struct wrb_handle *\nbeiscsi_get_wrb_handle(struct hwi_wrb_context *pwrb_context,\n\t\t       unsigned int wrbs_per_cxn)\n{\n\tstruct wrb_handle *pwrb_handle;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pwrb_context->wrb_lock, flags);\n\tif (!pwrb_context->wrb_handles_available) {\n\t\tspin_unlock_irqrestore(&pwrb_context->wrb_lock, flags);\n\t\treturn NULL;\n\t}\n\tpwrb_handle = pwrb_context->pwrb_handle_base[pwrb_context->alloc_index];\n\tpwrb_context->wrb_handles_available--;\n\tif (pwrb_context->alloc_index == (wrbs_per_cxn - 1))\n\t\tpwrb_context->alloc_index = 0;\n\telse\n\t\tpwrb_context->alloc_index++;\n\tspin_unlock_irqrestore(&pwrb_context->wrb_lock, flags);\n\n\tif (pwrb_handle)\n\t\tmemset(pwrb_handle->pwrb, 0, sizeof(*pwrb_handle->pwrb));\n\n\treturn pwrb_handle;\n}\n\n \nstruct wrb_handle *alloc_wrb_handle(struct beiscsi_hba *phba, unsigned int cid,\n\t\t\t\t    struct hwi_wrb_context **pcontext)\n{\n\tstruct hwi_wrb_context *pwrb_context;\n\tstruct hwi_controller *phwi_ctrlr;\n\tuint16_t cri_index = BE_GET_CRI_FROM_CID(cid);\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tpwrb_context = &phwi_ctrlr->wrb_context[cri_index];\n\t \n\t*pcontext = pwrb_context;\n\treturn beiscsi_get_wrb_handle(pwrb_context, phba->params.wrbs_per_cxn);\n}\n\nstatic inline void\nbeiscsi_put_wrb_handle(struct hwi_wrb_context *pwrb_context,\n\t\t       struct wrb_handle *pwrb_handle,\n\t\t       unsigned int wrbs_per_cxn)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pwrb_context->wrb_lock, flags);\n\tpwrb_context->pwrb_handle_base[pwrb_context->free_index] = pwrb_handle;\n\tpwrb_context->wrb_handles_available++;\n\tif (pwrb_context->free_index == (wrbs_per_cxn - 1))\n\t\tpwrb_context->free_index = 0;\n\telse\n\t\tpwrb_context->free_index++;\n\tpwrb_handle->pio_handle = NULL;\n\tspin_unlock_irqrestore(&pwrb_context->wrb_lock, flags);\n}\n\n \nstatic void\nfree_wrb_handle(struct beiscsi_hba *phba, struct hwi_wrb_context *pwrb_context,\n\t\tstruct wrb_handle *pwrb_handle)\n{\n\tbeiscsi_put_wrb_handle(pwrb_context,\n\t\t\t       pwrb_handle,\n\t\t\t       phba->params.wrbs_per_cxn);\n\tbeiscsi_log(phba, KERN_INFO,\n\t\t    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,\n\t\t    \"BM_%d : FREE WRB: pwrb_handle=%p free_index=0x%x \"\n\t\t    \"wrb_handles_available=%d\\n\",\n\t\t    pwrb_handle, pwrb_context->free_index,\n\t\t    pwrb_context->wrb_handles_available);\n}\n\nstatic struct sgl_handle *alloc_mgmt_sgl_handle(struct beiscsi_hba *phba)\n{\n\tstruct sgl_handle *psgl_handle;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&phba->mgmt_sgl_lock, flags);\n\tif (phba->eh_sgl_hndl_avbl) {\n\t\tpsgl_handle = phba->eh_sgl_hndl_base[phba->eh_sgl_alloc_index];\n\t\tphba->eh_sgl_hndl_base[phba->eh_sgl_alloc_index] = NULL;\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BM_%d : mgmt_sgl_alloc_index=%d=0x%x\\n\",\n\t\t\t    phba->eh_sgl_alloc_index,\n\t\t\t    phba->eh_sgl_alloc_index);\n\n\t\tphba->eh_sgl_hndl_avbl--;\n\t\tif (phba->eh_sgl_alloc_index ==\n\t\t    (phba->params.icds_per_ctrl - phba->params.ios_per_ctrl -\n\t\t     1))\n\t\t\tphba->eh_sgl_alloc_index = 0;\n\t\telse\n\t\t\tphba->eh_sgl_alloc_index++;\n\t} else\n\t\tpsgl_handle = NULL;\n\tspin_unlock_irqrestore(&phba->mgmt_sgl_lock, flags);\n\treturn psgl_handle;\n}\n\nvoid\nfree_mgmt_sgl_handle(struct beiscsi_hba *phba, struct sgl_handle *psgl_handle)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&phba->mgmt_sgl_lock, flags);\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t    \"BM_%d : In  free_mgmt_sgl_handle,\"\n\t\t    \"eh_sgl_free_index=%d\\n\",\n\t\t    phba->eh_sgl_free_index);\n\n\tif (phba->eh_sgl_hndl_base[phba->eh_sgl_free_index]) {\n\t\t \n\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BM_%d : Double Free in eh SGL ,\"\n\t\t\t    \"eh_sgl_free_index=%d\\n\",\n\t\t\t    phba->eh_sgl_free_index);\n\t\tspin_unlock_irqrestore(&phba->mgmt_sgl_lock, flags);\n\t\treturn;\n\t}\n\tphba->eh_sgl_hndl_base[phba->eh_sgl_free_index] = psgl_handle;\n\tphba->eh_sgl_hndl_avbl++;\n\tif (phba->eh_sgl_free_index ==\n\t    (phba->params.icds_per_ctrl - phba->params.ios_per_ctrl - 1))\n\t\tphba->eh_sgl_free_index = 0;\n\telse\n\t\tphba->eh_sgl_free_index++;\n\tspin_unlock_irqrestore(&phba->mgmt_sgl_lock, flags);\n}\n\nstatic void\nbe_complete_io(struct beiscsi_conn *beiscsi_conn,\n\t\tstruct iscsi_task *task,\n\t\tstruct common_sol_cqe *csol_cqe)\n{\n\tstruct beiscsi_io_task *io_task = task->dd_data;\n\tstruct be_status_bhs *sts_bhs =\n\t\t\t\t(struct be_status_bhs *)io_task->cmd_bhs;\n\tstruct iscsi_conn *conn = beiscsi_conn->conn;\n\tunsigned char *sense;\n\tu32 resid = 0, exp_cmdsn, max_cmdsn;\n\tu8 rsp, status, flags;\n\n\texp_cmdsn = csol_cqe->exp_cmdsn;\n\tmax_cmdsn = (csol_cqe->exp_cmdsn +\n\t\t     csol_cqe->cmd_wnd - 1);\n\trsp = csol_cqe->i_resp;\n\tstatus = csol_cqe->i_sts;\n\tflags = csol_cqe->i_flags;\n\tresid = csol_cqe->res_cnt;\n\n\tif (!task->sc) {\n\t\tif (io_task->scsi_cmnd) {\n\t\t\tscsi_dma_unmap(io_task->scsi_cmnd);\n\t\t\tio_task->scsi_cmnd = NULL;\n\t\t}\n\n\t\treturn;\n\t}\n\ttask->sc->result = (DID_OK << 16) | status;\n\tif (rsp != ISCSI_STATUS_CMD_COMPLETED) {\n\t\ttask->sc->result = DID_ERROR << 16;\n\t\tgoto unmap;\n\t}\n\n\t \n\tif (flags & (ISCSI_FLAG_CMD_UNDERFLOW | ISCSI_FLAG_CMD_OVERFLOW)) {\n\t\tif (!status && (flags & ISCSI_FLAG_CMD_OVERFLOW))\n\t\t\ttask->sc->result = DID_ERROR << 16;\n\n\t\tif (flags & ISCSI_FLAG_CMD_UNDERFLOW) {\n\t\t\tscsi_set_resid(task->sc, resid);\n\t\t\tif (!status && (scsi_bufflen(task->sc) - resid <\n\t\t\t    task->sc->underflow))\n\t\t\t\ttask->sc->result = DID_ERROR << 16;\n\t\t}\n\t}\n\n\tif (status == SAM_STAT_CHECK_CONDITION) {\n\t\tu16 sense_len;\n\t\tunsigned short *slen = (unsigned short *)sts_bhs->sense_info;\n\n\t\tsense = sts_bhs->sense_info + sizeof(unsigned short);\n\t\tsense_len = be16_to_cpu(*slen);\n\t\tmemcpy(task->sc->sense_buffer, sense,\n\t\t       min_t(u16, sense_len, SCSI_SENSE_BUFFERSIZE));\n\t}\n\n\tif (io_task->cmd_bhs->iscsi_hdr.flags & ISCSI_FLAG_CMD_READ)\n\t\tconn->rxdata_octets += resid;\nunmap:\n\tif (io_task->scsi_cmnd) {\n\t\tscsi_dma_unmap(io_task->scsi_cmnd);\n\t\tio_task->scsi_cmnd = NULL;\n\t}\n\tiscsi_complete_scsi_task(task, exp_cmdsn, max_cmdsn);\n}\n\nstatic void\nbe_complete_logout(struct beiscsi_conn *beiscsi_conn,\n\t\t    struct iscsi_task *task,\n\t\t    struct common_sol_cqe *csol_cqe)\n{\n\tstruct iscsi_logout_rsp *hdr;\n\tstruct beiscsi_io_task *io_task = task->dd_data;\n\tstruct iscsi_conn *conn = beiscsi_conn->conn;\n\n\thdr = (struct iscsi_logout_rsp *)task->hdr;\n\thdr->opcode = ISCSI_OP_LOGOUT_RSP;\n\thdr->t2wait = 5;\n\thdr->t2retain = 0;\n\thdr->flags = csol_cqe->i_flags;\n\thdr->response = csol_cqe->i_resp;\n\thdr->exp_cmdsn = cpu_to_be32(csol_cqe->exp_cmdsn);\n\thdr->max_cmdsn = cpu_to_be32(csol_cqe->exp_cmdsn +\n\t\t\t\t     csol_cqe->cmd_wnd - 1);\n\n\thdr->dlength[0] = 0;\n\thdr->dlength[1] = 0;\n\thdr->dlength[2] = 0;\n\thdr->hlength = 0;\n\thdr->itt = io_task->libiscsi_itt;\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)hdr, NULL, 0);\n}\n\nstatic void\nbe_complete_tmf(struct beiscsi_conn *beiscsi_conn,\n\t\t struct iscsi_task *task,\n\t\t struct common_sol_cqe *csol_cqe)\n{\n\tstruct iscsi_tm_rsp *hdr;\n\tstruct iscsi_conn *conn = beiscsi_conn->conn;\n\tstruct beiscsi_io_task *io_task = task->dd_data;\n\n\thdr = (struct iscsi_tm_rsp *)task->hdr;\n\thdr->opcode = ISCSI_OP_SCSI_TMFUNC_RSP;\n\thdr->flags = csol_cqe->i_flags;\n\thdr->response = csol_cqe->i_resp;\n\thdr->exp_cmdsn = cpu_to_be32(csol_cqe->exp_cmdsn);\n\thdr->max_cmdsn = cpu_to_be32(csol_cqe->exp_cmdsn +\n\t\t\t\t     csol_cqe->cmd_wnd - 1);\n\n\thdr->itt = io_task->libiscsi_itt;\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)hdr, NULL, 0);\n}\n\nstatic void\nhwi_complete_drvr_msgs(struct beiscsi_conn *beiscsi_conn,\n\t\t       struct beiscsi_hba *phba, struct sol_cqe *psol)\n{\n\tstruct hwi_wrb_context *pwrb_context;\n\tuint16_t wrb_index, cid, cri_index;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct wrb_handle *pwrb_handle;\n\tstruct iscsi_session *session;\n\tstruct iscsi_task *task;\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tif (is_chip_be2_be3r(phba)) {\n\t\twrb_index = AMAP_GET_BITS(struct amap_it_dmsg_cqe,\n\t\t\t\t\t  wrb_idx, psol);\n\t\tcid = AMAP_GET_BITS(struct amap_it_dmsg_cqe,\n\t\t\t\t    cid, psol);\n\t} else {\n\t\twrb_index = AMAP_GET_BITS(struct amap_it_dmsg_cqe_v2,\n\t\t\t\t\t  wrb_idx, psol);\n\t\tcid = AMAP_GET_BITS(struct amap_it_dmsg_cqe_v2,\n\t\t\t\t    cid, psol);\n\t}\n\n\tcri_index = BE_GET_CRI_FROM_CID(cid);\n\tpwrb_context = &phwi_ctrlr->wrb_context[cri_index];\n\tpwrb_handle = pwrb_context->pwrb_handle_basestd[wrb_index];\n\tsession = beiscsi_conn->conn->session;\n\tspin_lock_bh(&session->back_lock);\n\ttask = pwrb_handle->pio_handle;\n\tif (task)\n\t\t__iscsi_put_task(task);\n\tspin_unlock_bh(&session->back_lock);\n}\n\nstatic void\nbe_complete_nopin_resp(struct beiscsi_conn *beiscsi_conn,\n\t\t\tstruct iscsi_task *task,\n\t\t\tstruct common_sol_cqe *csol_cqe)\n{\n\tstruct iscsi_nopin *hdr;\n\tstruct iscsi_conn *conn = beiscsi_conn->conn;\n\tstruct beiscsi_io_task *io_task = task->dd_data;\n\n\thdr = (struct iscsi_nopin *)task->hdr;\n\thdr->flags = csol_cqe->i_flags;\n\thdr->exp_cmdsn = cpu_to_be32(csol_cqe->exp_cmdsn);\n\thdr->max_cmdsn = cpu_to_be32(csol_cqe->exp_cmdsn +\n\t\t\t\t     csol_cqe->cmd_wnd - 1);\n\n\thdr->opcode = ISCSI_OP_NOOP_IN;\n\thdr->itt = io_task->libiscsi_itt;\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)hdr, NULL, 0);\n}\n\nstatic void adapter_get_sol_cqe(struct beiscsi_hba *phba,\n\t\tstruct sol_cqe *psol,\n\t\tstruct common_sol_cqe *csol_cqe)\n{\n\tif (is_chip_be2_be3r(phba)) {\n\t\tcsol_cqe->exp_cmdsn = AMAP_GET_BITS(struct amap_sol_cqe,\n\t\t\t\t\t\t    i_exp_cmd_sn, psol);\n\t\tcsol_cqe->res_cnt = AMAP_GET_BITS(struct amap_sol_cqe,\n\t\t\t\t\t\t  i_res_cnt, psol);\n\t\tcsol_cqe->cmd_wnd = AMAP_GET_BITS(struct amap_sol_cqe,\n\t\t\t\t\t\t  i_cmd_wnd, psol);\n\t\tcsol_cqe->wrb_index = AMAP_GET_BITS(struct amap_sol_cqe,\n\t\t\t\t\t\t    wrb_index, psol);\n\t\tcsol_cqe->cid = AMAP_GET_BITS(struct amap_sol_cqe,\n\t\t\t\t\t      cid, psol);\n\t\tcsol_cqe->hw_sts = AMAP_GET_BITS(struct amap_sol_cqe,\n\t\t\t\t\t\t hw_sts, psol);\n\t\tcsol_cqe->i_resp = AMAP_GET_BITS(struct amap_sol_cqe,\n\t\t\t\t\t\t i_resp, psol);\n\t\tcsol_cqe->i_sts = AMAP_GET_BITS(struct amap_sol_cqe,\n\t\t\t\t\t\ti_sts, psol);\n\t\tcsol_cqe->i_flags = AMAP_GET_BITS(struct amap_sol_cqe,\n\t\t\t\t\t\t  i_flags, psol);\n\t} else {\n\t\tcsol_cqe->exp_cmdsn = AMAP_GET_BITS(struct amap_sol_cqe_v2,\n\t\t\t\t\t\t    i_exp_cmd_sn, psol);\n\t\tcsol_cqe->res_cnt = AMAP_GET_BITS(struct amap_sol_cqe_v2,\n\t\t\t\t\t\t  i_res_cnt, psol);\n\t\tcsol_cqe->wrb_index = AMAP_GET_BITS(struct amap_sol_cqe_v2,\n\t\t\t\t\t\t    wrb_index, psol);\n\t\tcsol_cqe->cid = AMAP_GET_BITS(struct amap_sol_cqe_v2,\n\t\t\t\t\t      cid, psol);\n\t\tcsol_cqe->hw_sts = AMAP_GET_BITS(struct amap_sol_cqe_v2,\n\t\t\t\t\t\t hw_sts, psol);\n\t\tcsol_cqe->cmd_wnd = AMAP_GET_BITS(struct amap_sol_cqe_v2,\n\t\t\t\t\t\t  i_cmd_wnd, psol);\n\t\tif (AMAP_GET_BITS(struct amap_sol_cqe_v2,\n\t\t\t\t  cmd_cmpl, psol))\n\t\t\tcsol_cqe->i_sts = AMAP_GET_BITS(struct amap_sol_cqe_v2,\n\t\t\t\t\t\t\ti_sts, psol);\n\t\telse\n\t\t\tcsol_cqe->i_resp = AMAP_GET_BITS(struct amap_sol_cqe_v2,\n\t\t\t\t\t\t\t i_sts, psol);\n\t\tif (AMAP_GET_BITS(struct amap_sol_cqe_v2,\n\t\t\t\t  u, psol))\n\t\t\tcsol_cqe->i_flags = ISCSI_FLAG_CMD_UNDERFLOW;\n\n\t\tif (AMAP_GET_BITS(struct amap_sol_cqe_v2,\n\t\t\t\t  o, psol))\n\t\t\tcsol_cqe->i_flags |= ISCSI_FLAG_CMD_OVERFLOW;\n\t}\n}\n\n\nstatic void hwi_complete_cmd(struct beiscsi_conn *beiscsi_conn,\n\t\t\t     struct beiscsi_hba *phba, struct sol_cqe *psol)\n{\n\tstruct iscsi_conn *conn = beiscsi_conn->conn;\n\tstruct iscsi_session *session = conn->session;\n\tstruct common_sol_cqe csol_cqe = {0};\n\tstruct hwi_wrb_context *pwrb_context;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct wrb_handle *pwrb_handle;\n\tstruct iscsi_task *task;\n\tuint16_t cri_index = 0;\n\tuint8_t type;\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\n\t \n\tadapter_get_sol_cqe(phba, psol, &csol_cqe);\n\n\tcri_index = BE_GET_CRI_FROM_CID(csol_cqe.cid);\n\tpwrb_context = &phwi_ctrlr->wrb_context[cri_index];\n\n\tpwrb_handle = pwrb_context->pwrb_handle_basestd[\n\t\t      csol_cqe.wrb_index];\n\n\tspin_lock_bh(&session->back_lock);\n\ttask = pwrb_handle->pio_handle;\n\tif (!task) {\n\t\tspin_unlock_bh(&session->back_lock);\n\t\treturn;\n\t}\n\ttype = ((struct beiscsi_io_task *)task->dd_data)->wrb_type;\n\n\tswitch (type) {\n\tcase HWH_TYPE_IO:\n\tcase HWH_TYPE_IO_RD:\n\t\tif ((task->hdr->opcode & ISCSI_OPCODE_MASK) ==\n\t\t     ISCSI_OP_NOOP_OUT)\n\t\t\tbe_complete_nopin_resp(beiscsi_conn, task, &csol_cqe);\n\t\telse\n\t\t\tbe_complete_io(beiscsi_conn, task, &csol_cqe);\n\t\tbreak;\n\n\tcase HWH_TYPE_LOGOUT:\n\t\tif ((task->hdr->opcode & ISCSI_OPCODE_MASK) == ISCSI_OP_LOGOUT)\n\t\t\tbe_complete_logout(beiscsi_conn, task, &csol_cqe);\n\t\telse\n\t\t\tbe_complete_tmf(beiscsi_conn, task, &csol_cqe);\n\t\tbreak;\n\n\tcase HWH_TYPE_LOGIN:\n\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t    BEISCSI_LOG_CONFIG | BEISCSI_LOG_IO,\n\t\t\t    \"BM_%d :\\t\\t No HWH_TYPE_LOGIN Expected in\"\n\t\t\t    \" %s- Solicited path\\n\", __func__);\n\t\tbreak;\n\n\tcase HWH_TYPE_NOP:\n\t\tbe_complete_nopin_resp(beiscsi_conn, task, &csol_cqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbeiscsi_log(phba, KERN_WARNING,\n\t\t\t    BEISCSI_LOG_CONFIG | BEISCSI_LOG_IO,\n\t\t\t    \"BM_%d : In %s, unknown type = %d \"\n\t\t\t    \"wrb_index 0x%x CID 0x%x\\n\", __func__, type,\n\t\t\t    csol_cqe.wrb_index,\n\t\t\t    csol_cqe.cid);\n\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&session->back_lock);\n}\n\n \nstatic unsigned int\nbeiscsi_complete_pdu(struct beiscsi_conn *beiscsi_conn,\n\t\tstruct pdu_base *phdr, void *pdata, unsigned int dlen)\n{\n\tstruct beiscsi_hba *phba = beiscsi_conn->phba;\n\tstruct iscsi_conn *conn = beiscsi_conn->conn;\n\tstruct beiscsi_io_task *io_task;\n\tstruct iscsi_hdr *login_hdr;\n\tstruct iscsi_task *task;\n\tu8 code;\n\n\tcode = AMAP_GET_BITS(struct amap_pdu_base, opcode, phdr);\n\tswitch (code) {\n\tcase ISCSI_OP_NOOP_IN:\n\t\tpdata = NULL;\n\t\tdlen = 0;\n\t\tbreak;\n\tcase ISCSI_OP_ASYNC_EVENT:\n\t\tbreak;\n\tcase ISCSI_OP_REJECT:\n\t\tWARN_ON(!pdata);\n\t\tWARN_ON(!(dlen == 48));\n\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t    BEISCSI_LOG_CONFIG | BEISCSI_LOG_IO,\n\t\t\t    \"BM_%d : In ISCSI_OP_REJECT\\n\");\n\t\tbreak;\n\tcase ISCSI_OP_LOGIN_RSP:\n\tcase ISCSI_OP_TEXT_RSP:\n\t\ttask = conn->login_task;\n\t\tio_task = task->dd_data;\n\t\tlogin_hdr = (struct iscsi_hdr *)phdr;\n\t\tlogin_hdr->itt = io_task->libiscsi_itt;\n\t\tbreak;\n\tdefault:\n\t\tbeiscsi_log(phba, KERN_WARNING,\n\t\t\t    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,\n\t\t\t    \"BM_%d : unrecognized async PDU opcode 0x%x\\n\",\n\t\t\t    code);\n\t\treturn 1;\n\t}\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)phdr, pdata, dlen);\n\treturn 0;\n}\n\nstatic inline void\nbeiscsi_hdl_put_handle(struct hd_async_context *pasync_ctx,\n\t\t\t struct hd_async_handle *pasync_handle)\n{\n\tpasync_handle->is_final = 0;\n\tpasync_handle->buffer_len = 0;\n\tpasync_handle->in_use = 0;\n\tlist_del_init(&pasync_handle->link);\n}\n\nstatic void\nbeiscsi_hdl_purge_handles(struct beiscsi_hba *phba,\n\t\t\t  struct hd_async_context *pasync_ctx,\n\t\t\t  u16 cri)\n{\n\tstruct hd_async_handle *pasync_handle, *tmp_handle;\n\tstruct list_head *plist;\n\n\tplist  = &pasync_ctx->async_entry[cri].wq.list;\n\tlist_for_each_entry_safe(pasync_handle, tmp_handle, plist, link)\n\t\tbeiscsi_hdl_put_handle(pasync_ctx, pasync_handle);\n\n\tINIT_LIST_HEAD(&pasync_ctx->async_entry[cri].wq.list);\n\tpasync_ctx->async_entry[cri].wq.hdr_len = 0;\n\tpasync_ctx->async_entry[cri].wq.bytes_received = 0;\n\tpasync_ctx->async_entry[cri].wq.bytes_needed = 0;\n}\n\nstatic struct hd_async_handle *\nbeiscsi_hdl_get_handle(struct beiscsi_conn *beiscsi_conn,\n\t\t       struct hd_async_context *pasync_ctx,\n\t\t       struct i_t_dpdu_cqe *pdpdu_cqe,\n\t\t       u8 *header)\n{\n\tstruct beiscsi_hba *phba = beiscsi_conn->phba;\n\tstruct hd_async_handle *pasync_handle;\n\tstruct be_bus_address phys_addr;\n\tu16 cid, code, ci, cri;\n\tu8 final, error = 0;\n\tu32 dpl;\n\n\tcid = beiscsi_conn->beiscsi_conn_cid;\n\tcri = BE_GET_ASYNC_CRI_FROM_CID(cid);\n\t \n\tif (is_chip_be2_be3r(phba)) {\n\t\tdpl = AMAP_GET_BITS(struct amap_i_t_dpdu_cqe,\n\t\t\t\t    dpl, pdpdu_cqe);\n\t\tci = AMAP_GET_BITS(struct amap_i_t_dpdu_cqe,\n\t\t\t\t      index, pdpdu_cqe);\n\t\tfinal = AMAP_GET_BITS(struct amap_i_t_dpdu_cqe,\n\t\t\t\t      final, pdpdu_cqe);\n\t} else {\n\t\tdpl = AMAP_GET_BITS(struct amap_i_t_dpdu_cqe_v2,\n\t\t\t\t    dpl, pdpdu_cqe);\n\t\tci = AMAP_GET_BITS(struct amap_i_t_dpdu_cqe_v2,\n\t\t\t\t      index, pdpdu_cqe);\n\t\tfinal = AMAP_GET_BITS(struct amap_i_t_dpdu_cqe_v2,\n\t\t\t\t      final, pdpdu_cqe);\n\t}\n\n\t \n\tphys_addr.u.a32.address_lo = AMAP_GET_BITS(struct amap_i_t_dpdu_cqe,\n\t\t\t\t\t\t   db_addr_lo, pdpdu_cqe);\n\tphys_addr.u.a32.address_lo -= dpl;\n\tphys_addr.u.a32.address_hi = AMAP_GET_BITS(struct amap_i_t_dpdu_cqe,\n\t\t\t\t\t\t   db_addr_hi, pdpdu_cqe);\n\n\tcode = AMAP_GET_BITS(struct amap_i_t_dpdu_cqe, code, pdpdu_cqe);\n\tswitch (code) {\n\tcase UNSOL_HDR_NOTIFY:\n\t\tpasync_handle = pasync_ctx->async_entry[ci].header;\n\t\t*header = 1;\n\t\tbreak;\n\tcase UNSOL_DATA_DIGEST_ERROR_NOTIFY:\n\t\terror = 1;\n\t\tfallthrough;\n\tcase UNSOL_DATA_NOTIFY:\n\t\tpasync_handle = pasync_ctx->async_entry[ci].data;\n\t\tbreak;\n\t \n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tif (pasync_handle->pa.u.a64.address != phys_addr.u.a64.address ||\n\t    pasync_handle->index != ci) {\n\t\t \n\t\terror = 1;\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_ISCSI,\n\t\t\t    \"BM_%d : cid %u async PDU handle mismatch - addr in %cQE %llx at %u:addr in CQE %llx ci %u\\n\",\n\t\t\t    cid, pasync_handle->is_header ? 'H' : 'D',\n\t\t\t    pasync_handle->pa.u.a64.address,\n\t\t\t    pasync_handle->index,\n\t\t\t    phys_addr.u.a64.address, ci);\n\t\t \n\t}\n\n\t \n\tif (error) {\n\t\tbeiscsi_hdl_put_handle(pasync_ctx, pasync_handle);\n\t\treturn NULL;\n\t}\n\n\tif (pasync_handle->in_use || !list_empty(&pasync_handle->link)) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_ISCSI,\n\t\t\t    \"BM_%d : cid %d async PDU handle in use - code %d ci %d addr %llx\\n\",\n\t\t\t    cid, code, ci, phys_addr.u.a64.address);\n\t\tbeiscsi_hdl_purge_handles(phba, pasync_ctx, cri);\n\t}\n\n\tlist_del_init(&pasync_handle->link);\n\t \n\tpasync_handle->cri = cri;\n\tpasync_handle->is_final = final;\n\tpasync_handle->buffer_len = dpl;\n\tpasync_handle->in_use = 1;\n\n\treturn pasync_handle;\n}\n\nstatic unsigned int\nbeiscsi_hdl_fwd_pdu(struct beiscsi_conn *beiscsi_conn,\n\t\t    struct hd_async_context *pasync_ctx,\n\t\t    u16 cri)\n{\n\tstruct iscsi_session *session = beiscsi_conn->conn->session;\n\tstruct hd_async_handle *pasync_handle, *plast_handle;\n\tstruct beiscsi_hba *phba = beiscsi_conn->phba;\n\tvoid *phdr = NULL, *pdata = NULL;\n\tu32 dlen = 0, status = 0;\n\tstruct list_head *plist;\n\n\tplist = &pasync_ctx->async_entry[cri].wq.list;\n\tplast_handle = NULL;\n\tlist_for_each_entry(pasync_handle, plist, link) {\n\t\tplast_handle = pasync_handle;\n\t\t \n\t\tif (!phdr) {\n\t\t\tphdr = pasync_handle->pbuffer;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (!pdata) {\n\t\t\tpdata = pasync_handle->pbuffer;\n\t\t\tdlen = pasync_handle->buffer_len;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!pasync_handle->buffer_len ||\n\t\t    (dlen + pasync_handle->buffer_len) >\n\t\t    pasync_ctx->async_data.buffer_size)\n\t\t\tbreak;\n\t\tmemcpy(pdata + dlen, pasync_handle->pbuffer,\n\t\t       pasync_handle->buffer_len);\n\t\tdlen += pasync_handle->buffer_len;\n\t}\n\n\tif (!plast_handle->is_final) {\n\t\t \n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_ISCSI,\n\t\t\t    \"BM_%d : cid %u %p fwd async PDU opcode %x with last handle missing - HL%u:DN%u:DR%u\\n\",\n\t\t\t    beiscsi_conn->beiscsi_conn_cid, plast_handle,\n\t\t\t    AMAP_GET_BITS(struct amap_pdu_base, opcode, phdr),\n\t\t\t    pasync_ctx->async_entry[cri].wq.hdr_len,\n\t\t\t    pasync_ctx->async_entry[cri].wq.bytes_needed,\n\t\t\t    pasync_ctx->async_entry[cri].wq.bytes_received);\n\t}\n\tspin_lock_bh(&session->back_lock);\n\tstatus = beiscsi_complete_pdu(beiscsi_conn, phdr, pdata, dlen);\n\tspin_unlock_bh(&session->back_lock);\n\tbeiscsi_hdl_purge_handles(phba, pasync_ctx, cri);\n\treturn status;\n}\n\nstatic unsigned int\nbeiscsi_hdl_gather_pdu(struct beiscsi_conn *beiscsi_conn,\n\t\t       struct hd_async_context *pasync_ctx,\n\t\t       struct hd_async_handle *pasync_handle)\n{\n\tunsigned int bytes_needed = 0, status = 0;\n\tu16 cri = pasync_handle->cri;\n\tstruct cri_wait_queue *wq;\n\tstruct beiscsi_hba *phba;\n\tstruct pdu_base *ppdu;\n\tchar *err = \"\";\n\n\tphba = beiscsi_conn->phba;\n\twq = &pasync_ctx->async_entry[cri].wq;\n\tif (pasync_handle->is_header) {\n\t\t \n\t\tif (wq->hdr_len) {\n\t\t\terr = \"incomplete\";\n\t\t\tgoto drop_pdu;\n\t\t}\n\t\tppdu = pasync_handle->pbuffer;\n\t\tbytes_needed = AMAP_GET_BITS(struct amap_pdu_base,\n\t\t\t\t\t     data_len_hi, ppdu);\n\t\tbytes_needed <<= 16;\n\t\tbytes_needed |= be16_to_cpu(AMAP_GET_BITS(struct amap_pdu_base,\n\t\t\t\t\t\t\t  data_len_lo, ppdu));\n\t\twq->hdr_len = pasync_handle->buffer_len;\n\t\twq->bytes_received = 0;\n\t\twq->bytes_needed = bytes_needed;\n\t\tlist_add_tail(&pasync_handle->link, &wq->list);\n\t\tif (!bytes_needed)\n\t\t\tstatus = beiscsi_hdl_fwd_pdu(beiscsi_conn,\n\t\t\t\t\t\t     pasync_ctx, cri);\n\t} else {\n\t\t \n\t\tif (!wq->hdr_len || !wq->bytes_needed) {\n\t\t\terr = \"header less\";\n\t\t\tgoto drop_pdu;\n\t\t}\n\t\twq->bytes_received += pasync_handle->buffer_len;\n\t\t \n\t\tif (wq->bytes_received > wq->bytes_needed) {\n\t\t\terr = \"overflow\";\n\t\t\tgoto drop_pdu;\n\t\t}\n\t\tlist_add_tail(&pasync_handle->link, &wq->list);\n\t\tif (wq->bytes_received == wq->bytes_needed)\n\t\t\tstatus = beiscsi_hdl_fwd_pdu(beiscsi_conn,\n\t\t\t\t\t\t     pasync_ctx, cri);\n\t}\n\treturn status;\n\ndrop_pdu:\n\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_ISCSI,\n\t\t    \"BM_%d : cid %u async PDU %s - def-%c:HL%u:DN%u:DR%u\\n\",\n\t\t    beiscsi_conn->beiscsi_conn_cid, err,\n\t\t    pasync_handle->is_header ? 'H' : 'D',\n\t\t    wq->hdr_len, wq->bytes_needed,\n\t\t    pasync_handle->buffer_len);\n\t \n\tbeiscsi_hdl_put_handle(pasync_ctx, pasync_handle);\n\t \n\tbeiscsi_hdl_purge_handles(phba, pasync_ctx, cri);\n\t \n\treturn status;\n}\n\nstatic void\nbeiscsi_hdq_post_handles(struct beiscsi_hba *phba,\n\t\t\t u8 header, u8 ulp_num, u16 nbuf)\n{\n\tstruct hd_async_handle *pasync_handle;\n\tstruct hd_async_context *pasync_ctx;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct phys_addr *pasync_sge;\n\tu32 ring_id, doorbell = 0;\n\tu32 doorbell_offset;\n\tu16 prod, pi;\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tpasync_ctx = HWI_GET_ASYNC_PDU_CTX(phwi_ctrlr, ulp_num);\n\tif (header) {\n\t\tpasync_sge = pasync_ctx->async_header.ring_base;\n\t\tpi = pasync_ctx->async_header.pi;\n\t\tring_id = phwi_ctrlr->default_pdu_hdr[ulp_num].id;\n\t\tdoorbell_offset = phwi_ctrlr->default_pdu_hdr[ulp_num].\n\t\t\t\t\tdoorbell_offset;\n\t} else {\n\t\tpasync_sge = pasync_ctx->async_data.ring_base;\n\t\tpi = pasync_ctx->async_data.pi;\n\t\tring_id = phwi_ctrlr->default_pdu_data[ulp_num].id;\n\t\tdoorbell_offset = phwi_ctrlr->default_pdu_data[ulp_num].\n\t\t\t\t\tdoorbell_offset;\n\t}\n\n\tfor (prod = 0; prod < nbuf; prod++) {\n\t\tif (header)\n\t\t\tpasync_handle = pasync_ctx->async_entry[pi].header;\n\t\telse\n\t\t\tpasync_handle = pasync_ctx->async_entry[pi].data;\n\t\tWARN_ON(pasync_handle->is_header != header);\n\t\tWARN_ON(pasync_handle->index != pi);\n\t\t \n\t\tif (nbuf == pasync_ctx->num_entries) {\n\t\t\t \n\t\t\tpasync_sge[pi].hi = pasync_handle->pa.u.a32.address_lo;\n\t\t\tpasync_sge[pi].lo = pasync_handle->pa.u.a32.address_hi;\n\t\t}\n\t\tif (++pi == pasync_ctx->num_entries)\n\t\t\tpi = 0;\n\t}\n\n\tif (header)\n\t\tpasync_ctx->async_header.pi = pi;\n\telse\n\t\tpasync_ctx->async_data.pi = pi;\n\n\tdoorbell |= ring_id & DB_DEF_PDU_RING_ID_MASK;\n\tdoorbell |= 1 << DB_DEF_PDU_REARM_SHIFT;\n\tdoorbell |= 0 << DB_DEF_PDU_EVENT_SHIFT;\n\tdoorbell |= (prod & DB_DEF_PDU_CQPROC_MASK) << DB_DEF_PDU_CQPROC_SHIFT;\n\tiowrite32(doorbell, phba->db_va + doorbell_offset);\n}\n\nstatic void\nbeiscsi_hdq_process_compl(struct beiscsi_conn *beiscsi_conn,\n\t\t\t  struct i_t_dpdu_cqe *pdpdu_cqe)\n{\n\tstruct beiscsi_hba *phba = beiscsi_conn->phba;\n\tstruct hd_async_handle *pasync_handle = NULL;\n\tstruct hd_async_context *pasync_ctx;\n\tstruct hwi_controller *phwi_ctrlr;\n\tu8 ulp_num, consumed, header = 0;\n\tu16 cid_cri;\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tcid_cri = BE_GET_CRI_FROM_CID(beiscsi_conn->beiscsi_conn_cid);\n\tulp_num = BEISCSI_GET_ULP_FROM_CRI(phwi_ctrlr, cid_cri);\n\tpasync_ctx = HWI_GET_ASYNC_PDU_CTX(phwi_ctrlr, ulp_num);\n\tpasync_handle = beiscsi_hdl_get_handle(beiscsi_conn, pasync_ctx,\n\t\t\t\t\t       pdpdu_cqe, &header);\n\tif (is_chip_be2_be3r(phba))\n\t\tconsumed = AMAP_GET_BITS(struct amap_i_t_dpdu_cqe,\n\t\t\t\t\t num_cons, pdpdu_cqe);\n\telse\n\t\tconsumed = AMAP_GET_BITS(struct amap_i_t_dpdu_cqe_v2,\n\t\t\t\t\t num_cons, pdpdu_cqe);\n\tif (pasync_handle)\n\t\tbeiscsi_hdl_gather_pdu(beiscsi_conn, pasync_ctx, pasync_handle);\n\t \n\tif (consumed)\n\t\tbeiscsi_hdq_post_handles(phba, header, ulp_num, 8 * consumed);\n}\n\nvoid beiscsi_process_mcc_cq(struct beiscsi_hba *phba)\n{\n\tstruct be_queue_info *mcc_cq;\n\tstruct  be_mcc_compl *mcc_compl;\n\tunsigned int num_processed = 0;\n\n\tmcc_cq = &phba->ctrl.mcc_obj.cq;\n\tmcc_compl = queue_tail_node(mcc_cq);\n\tmcc_compl->flags = le32_to_cpu(mcc_compl->flags);\n\twhile (mcc_compl->flags & CQE_FLAGS_VALID_MASK) {\n\t\tif (beiscsi_hba_in_error(phba))\n\t\t\treturn;\n\n\t\tif (num_processed >= 32) {\n\t\t\thwi_ring_cq_db(phba, mcc_cq->id,\n\t\t\t\t\tnum_processed, 0);\n\t\t\tnum_processed = 0;\n\t\t}\n\t\tif (mcc_compl->flags & CQE_FLAGS_ASYNC_MASK) {\n\t\t\tbeiscsi_process_async_event(phba, mcc_compl);\n\t\t} else if (mcc_compl->flags & CQE_FLAGS_COMPLETED_MASK) {\n\t\t\tbeiscsi_process_mcc_compl(&phba->ctrl, mcc_compl);\n\t\t}\n\n\t\tmcc_compl->flags = 0;\n\t\tqueue_tail_inc(mcc_cq);\n\t\tmcc_compl = queue_tail_node(mcc_cq);\n\t\tmcc_compl->flags = le32_to_cpu(mcc_compl->flags);\n\t\tnum_processed++;\n\t}\n\n\tif (num_processed > 0)\n\t\thwi_ring_cq_db(phba, mcc_cq->id, num_processed, 1);\n}\n\nstatic void beiscsi_mcc_work(struct work_struct *work)\n{\n\tstruct be_eq_obj *pbe_eq;\n\tstruct beiscsi_hba *phba;\n\n\tpbe_eq = container_of(work, struct be_eq_obj, mcc_work);\n\tphba = pbe_eq->phba;\n\tbeiscsi_process_mcc_cq(phba);\n\t \n\tif (!beiscsi_hba_in_error(phba))\n\t\thwi_ring_eq_db(phba, pbe_eq->q.id, 0, 0, 1, 1);\n}\n\n \nunsigned int beiscsi_process_cq(struct be_eq_obj *pbe_eq, int budget)\n{\n\tstruct be_queue_info *cq;\n\tstruct sol_cqe *sol;\n\tunsigned int total = 0;\n\tunsigned int num_processed = 0;\n\tunsigned short code = 0, cid = 0;\n\tuint16_t cri_index = 0;\n\tstruct beiscsi_conn *beiscsi_conn;\n\tstruct beiscsi_endpoint *beiscsi_ep;\n\tstruct iscsi_endpoint *ep;\n\tstruct beiscsi_hba *phba;\n\n\tcq = pbe_eq->cq;\n\tsol = queue_tail_node(cq);\n\tphba = pbe_eq->phba;\n\n\twhile (sol->dw[offsetof(struct amap_sol_cqe, valid) / 32] &\n\t       CQE_VALID_MASK) {\n\t\tif (beiscsi_hba_in_error(phba))\n\t\t\treturn 0;\n\n\t\tbe_dws_le_to_cpu(sol, sizeof(struct sol_cqe));\n\n\t\tcode = (sol->dw[offsetof(struct amap_sol_cqe, code) / 32] &\n\t\t\t\tCQE_CODE_MASK);\n\n\t\t  \n\t\tif (is_chip_be2_be3r(phba)) {\n\t\t\tcid = AMAP_GET_BITS(struct amap_sol_cqe, cid, sol);\n\t\t} else {\n\t\t\tif ((code == DRIVERMSG_NOTIFY) ||\n\t\t\t    (code == UNSOL_HDR_NOTIFY) ||\n\t\t\t    (code == UNSOL_DATA_NOTIFY))\n\t\t\t\tcid = AMAP_GET_BITS(\n\t\t\t\t\t\t    struct amap_i_t_dpdu_cqe_v2,\n\t\t\t\t\t\t    cid, sol);\n\t\t\telse\n\t\t\t\tcid = AMAP_GET_BITS(struct amap_sol_cqe_v2,\n\t\t\t\t\t\t    cid, sol);\n\t\t}\n\n\t\tcri_index = BE_GET_CRI_FROM_CID(cid);\n\t\tep = phba->ep_array[cri_index];\n\n\t\tif (ep == NULL) {\n\t\t\t \n\t\t\tbeiscsi_log(phba, KERN_WARNING,\n\t\t\t\t    BEISCSI_LOG_INIT,\n\t\t\t\t    \"BM_%d : proc cqe of disconn ep: cid %d\\n\",\n\t\t\t\t    cid);\n\t\t\tgoto proc_next_cqe;\n\t\t}\n\n\t\tbeiscsi_ep = ep->dd_data;\n\t\tbeiscsi_conn = beiscsi_ep->conn;\n\n\t\t \n\t\tif (num_processed == 32) {\n\t\t\thwi_ring_cq_db(phba, cq->id, 32, 0);\n\t\t\tnum_processed = 0;\n\t\t}\n\t\ttotal++;\n\n\t\tswitch (code) {\n\t\tcase SOL_CMD_COMPLETE:\n\t\t\thwi_complete_cmd(beiscsi_conn, phba, sol);\n\t\t\tbreak;\n\t\tcase DRIVERMSG_NOTIFY:\n\t\t\tbeiscsi_log(phba, KERN_INFO,\n\t\t\t\t    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BM_%d : Received %s[%d] on CID : %d\\n\",\n\t\t\t\t    cqe_desc[code], code, cid);\n\n\t\t\thwi_complete_drvr_msgs(beiscsi_conn, phba, sol);\n\t\t\tbreak;\n\t\tcase UNSOL_HDR_NOTIFY:\n\t\t\tbeiscsi_log(phba, KERN_INFO,\n\t\t\t\t    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BM_%d : Received %s[%d] on CID : %d\\n\",\n\t\t\t\t    cqe_desc[code], code, cid);\n\n\t\t\tspin_lock_bh(&phba->async_pdu_lock);\n\t\t\tbeiscsi_hdq_process_compl(beiscsi_conn,\n\t\t\t\t\t\t  (struct i_t_dpdu_cqe *)sol);\n\t\t\tspin_unlock_bh(&phba->async_pdu_lock);\n\t\t\tbreak;\n\t\tcase UNSOL_DATA_NOTIFY:\n\t\t\tbeiscsi_log(phba, KERN_INFO,\n\t\t\t\t    BEISCSI_LOG_CONFIG | BEISCSI_LOG_IO,\n\t\t\t\t    \"BM_%d : Received %s[%d] on CID : %d\\n\",\n\t\t\t\t    cqe_desc[code], code, cid);\n\n\t\t\tspin_lock_bh(&phba->async_pdu_lock);\n\t\t\tbeiscsi_hdq_process_compl(beiscsi_conn,\n\t\t\t\t\t\t  (struct i_t_dpdu_cqe *)sol);\n\t\t\tspin_unlock_bh(&phba->async_pdu_lock);\n\t\t\tbreak;\n\t\tcase CXN_INVALIDATE_INDEX_NOTIFY:\n\t\tcase CMD_INVALIDATED_NOTIFY:\n\t\tcase CXN_INVALIDATE_NOTIFY:\n\t\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t\t    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BM_%d : Ignoring %s[%d] on CID : %d\\n\",\n\t\t\t\t    cqe_desc[code], code, cid);\n\t\t\tbreak;\n\t\tcase CXN_KILLED_HDR_DIGEST_ERR:\n\t\tcase SOL_CMD_KILLED_DATA_DIGEST_ERR:\n\t\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t\t    BEISCSI_LOG_CONFIG | BEISCSI_LOG_IO,\n\t\t\t\t    \"BM_%d : Cmd Notification %s[%d] on CID : %d\\n\",\n\t\t\t\t    cqe_desc[code], code,  cid);\n\t\t\tbreak;\n\t\tcase CMD_KILLED_INVALID_STATSN_RCVD:\n\t\tcase CMD_KILLED_INVALID_R2T_RCVD:\n\t\tcase CMD_CXN_KILLED_LUN_INVALID:\n\t\tcase CMD_CXN_KILLED_ICD_INVALID:\n\t\tcase CMD_CXN_KILLED_ITT_INVALID:\n\t\tcase CMD_CXN_KILLED_SEQ_OUTOFORDER:\n\t\tcase CMD_CXN_KILLED_INVALID_DATASN_RCVD:\n\t\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t\t    BEISCSI_LOG_CONFIG | BEISCSI_LOG_IO,\n\t\t\t\t    \"BM_%d : Cmd Notification %s[%d] on CID : %d\\n\",\n\t\t\t\t    cqe_desc[code], code,  cid);\n\t\t\tbreak;\n\t\tcase UNSOL_DATA_DIGEST_ERROR_NOTIFY:\n\t\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t\t    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BM_%d :  Dropping %s[%d] on DPDU ring on CID : %d\\n\",\n\t\t\t\t    cqe_desc[code], code, cid);\n\t\t\tspin_lock_bh(&phba->async_pdu_lock);\n\t\t\t \n\t\t\tbeiscsi_hdq_process_compl(beiscsi_conn,\n\t\t\t\t\t\t  (struct i_t_dpdu_cqe *)sol);\n\t\t\tspin_unlock_bh(&phba->async_pdu_lock);\n\t\t\tbreak;\n\t\tcase CXN_KILLED_PDU_SIZE_EXCEEDS_DSL:\n\t\tcase CXN_KILLED_BURST_LEN_MISMATCH:\n\t\tcase CXN_KILLED_AHS_RCVD:\n\t\tcase CXN_KILLED_UNKNOWN_HDR:\n\t\tcase CXN_KILLED_STALE_ITT_TTT_RCVD:\n\t\tcase CXN_KILLED_INVALID_ITT_TTT_RCVD:\n\t\tcase CXN_KILLED_TIMED_OUT:\n\t\tcase CXN_KILLED_FIN_RCVD:\n\t\tcase CXN_KILLED_RST_SENT:\n\t\tcase CXN_KILLED_RST_RCVD:\n\t\tcase CXN_KILLED_BAD_UNSOL_PDU_RCVD:\n\t\tcase CXN_KILLED_BAD_WRB_INDEX_ERROR:\n\t\tcase CXN_KILLED_OVER_RUN_RESIDUAL:\n\t\tcase CXN_KILLED_UNDER_RUN_RESIDUAL:\n\t\tcase CXN_KILLED_CMND_DATA_NOT_ON_SAME_CONN:\n\t\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t\t    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BM_%d : Event %s[%d] received on CID : %d\\n\",\n\t\t\t\t    cqe_desc[code], code, cid);\n\t\t\tif (beiscsi_conn)\n\t\t\t\tiscsi_conn_failure(beiscsi_conn->conn,\n\t\t\t\t\t\t   ISCSI_ERR_CONN_FAILED);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t\t    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BM_%d : Invalid CQE Event Received Code : %d CID 0x%x...\\n\",\n\t\t\t\t    code, cid);\n\t\t\tbreak;\n\t\t}\n\nproc_next_cqe:\n\t\tAMAP_SET_BITS(struct amap_sol_cqe, valid, sol, 0);\n\t\tqueue_tail_inc(cq);\n\t\tsol = queue_tail_node(cq);\n\t\tnum_processed++;\n\t\tif (total == budget)\n\t\t\tbreak;\n\t}\n\n\thwi_ring_cq_db(phba, cq->id, num_processed, 1);\n\treturn total;\n}\n\nstatic int be_iopoll(struct irq_poll *iop, int budget)\n{\n\tunsigned int ret, io_events;\n\tstruct beiscsi_hba *phba;\n\tstruct be_eq_obj *pbe_eq;\n\tstruct be_eq_entry *eqe = NULL;\n\tstruct be_queue_info *eq;\n\n\tpbe_eq = container_of(iop, struct be_eq_obj, iopoll);\n\tphba = pbe_eq->phba;\n\tif (beiscsi_hba_in_error(phba)) {\n\t\tirq_poll_complete(iop);\n\t\treturn 0;\n\t}\n\n\tio_events = 0;\n\teq = &pbe_eq->q;\n\teqe = queue_tail_node(eq);\n\twhile (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32] &\n\t\t\tEQE_VALID_MASK) {\n\t\tAMAP_SET_BITS(struct amap_eq_entry, valid, eqe, 0);\n\t\tqueue_tail_inc(eq);\n\t\teqe = queue_tail_node(eq);\n\t\tio_events++;\n\t}\n\thwi_ring_eq_db(phba, eq->id, 1, io_events, 0, 1);\n\n\tret = beiscsi_process_cq(pbe_eq, budget);\n\tpbe_eq->cq_count += ret;\n\tif (ret < budget) {\n\t\tirq_poll_complete(iop);\n\t\tbeiscsi_log(phba, KERN_INFO,\n\t\t\t    BEISCSI_LOG_CONFIG | BEISCSI_LOG_IO,\n\t\t\t    \"BM_%d : rearm pbe_eq->q.id =%d ret %d\\n\",\n\t\t\t    pbe_eq->q.id, ret);\n\t\tif (!beiscsi_hba_in_error(phba))\n\t\t\thwi_ring_eq_db(phba, pbe_eq->q.id, 0, 0, 1, 1);\n\t}\n\treturn ret;\n}\n\nstatic void\nhwi_write_sgl_v2(struct iscsi_wrb *pwrb, struct scatterlist *sg,\n\t\t  unsigned int num_sg, struct beiscsi_io_task *io_task)\n{\n\tstruct iscsi_sge *psgl;\n\tunsigned int sg_len, index;\n\tunsigned int sge_len = 0;\n\tunsigned long long addr;\n\tstruct scatterlist *l_sg;\n\tunsigned int offset;\n\n\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, iscsi_bhs_addr_lo, pwrb,\n\t\t      io_task->bhs_pa.u.a32.address_lo);\n\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, iscsi_bhs_addr_hi, pwrb,\n\t\t      io_task->bhs_pa.u.a32.address_hi);\n\n\tl_sg = sg;\n\tfor (index = 0; (index < num_sg) && (index < 2); index++,\n\t\t\tsg = sg_next(sg)) {\n\t\tif (index == 0) {\n\t\t\tsg_len = sg_dma_len(sg);\n\t\t\taddr = (u64) sg_dma_address(sg);\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2,\n\t\t\t\t      sge0_addr_lo, pwrb,\n\t\t\t\t      lower_32_bits(addr));\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2,\n\t\t\t\t      sge0_addr_hi, pwrb,\n\t\t\t\t      upper_32_bits(addr));\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2,\n\t\t\t\t      sge0_len, pwrb,\n\t\t\t\t      sg_len);\n\t\t\tsge_len = sg_len;\n\t\t} else {\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, sge1_r2t_offset,\n\t\t\t\t      pwrb, sge_len);\n\t\t\tsg_len = sg_dma_len(sg);\n\t\t\taddr = (u64) sg_dma_address(sg);\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2,\n\t\t\t\t      sge1_addr_lo, pwrb,\n\t\t\t\t      lower_32_bits(addr));\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2,\n\t\t\t\t      sge1_addr_hi, pwrb,\n\t\t\t\t      upper_32_bits(addr));\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2,\n\t\t\t\t      sge1_len, pwrb,\n\t\t\t\t      sg_len);\n\t\t}\n\t}\n\tpsgl = (struct iscsi_sge *)io_task->psgl_handle->pfrag;\n\tmemset(psgl, 0, sizeof(*psgl) * BE2_SGE);\n\n\tAMAP_SET_BITS(struct amap_iscsi_sge, len, psgl, io_task->bhs_len - 2);\n\n\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_hi, psgl,\n\t\t      io_task->bhs_pa.u.a32.address_hi);\n\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_lo, psgl,\n\t\t      io_task->bhs_pa.u.a32.address_lo);\n\n\tif (num_sg == 1) {\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, sge0_last, pwrb,\n\t\t\t      1);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, sge1_last, pwrb,\n\t\t\t      0);\n\t} else if (num_sg == 2) {\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, sge0_last, pwrb,\n\t\t\t      0);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, sge1_last, pwrb,\n\t\t\t      1);\n\t} else {\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, sge0_last, pwrb,\n\t\t\t      0);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, sge1_last, pwrb,\n\t\t\t      0);\n\t}\n\n\tsg = l_sg;\n\tpsgl++;\n\tpsgl++;\n\toffset = 0;\n\tfor (index = 0; index < num_sg; index++, sg = sg_next(sg), psgl++) {\n\t\tsg_len = sg_dma_len(sg);\n\t\taddr = (u64) sg_dma_address(sg);\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_lo, psgl,\n\t\t\t      lower_32_bits(addr));\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_hi, psgl,\n\t\t\t      upper_32_bits(addr));\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, len, psgl, sg_len);\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, sge_offset, psgl, offset);\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, last_sge, psgl, 0);\n\t\toffset += sg_len;\n\t}\n\tpsgl--;\n\tAMAP_SET_BITS(struct amap_iscsi_sge, last_sge, psgl, 1);\n}\n\nstatic void\nhwi_write_sgl(struct iscsi_wrb *pwrb, struct scatterlist *sg,\n\t      unsigned int num_sg, struct beiscsi_io_task *io_task)\n{\n\tstruct iscsi_sge *psgl;\n\tunsigned int sg_len, index;\n\tunsigned int sge_len = 0;\n\tunsigned long long addr;\n\tstruct scatterlist *l_sg;\n\tunsigned int offset;\n\n\tAMAP_SET_BITS(struct amap_iscsi_wrb, iscsi_bhs_addr_lo, pwrb,\n\t\t\t\t      io_task->bhs_pa.u.a32.address_lo);\n\tAMAP_SET_BITS(struct amap_iscsi_wrb, iscsi_bhs_addr_hi, pwrb,\n\t\t\t\t      io_task->bhs_pa.u.a32.address_hi);\n\n\tl_sg = sg;\n\tfor (index = 0; (index < num_sg) && (index < 2); index++,\n\t\t\t\t\t\t\t sg = sg_next(sg)) {\n\t\tif (index == 0) {\n\t\t\tsg_len = sg_dma_len(sg);\n\t\t\taddr = (u64) sg_dma_address(sg);\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge0_addr_lo, pwrb,\n\t\t\t\t\t\t((u32)(addr & 0xFFFFFFFF)));\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge0_addr_hi, pwrb,\n\t\t\t\t\t\t\t((u32)(addr >> 32)));\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge0_len, pwrb,\n\t\t\t\t\t\t\tsg_len);\n\t\t\tsge_len = sg_len;\n\t\t} else {\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge1_r2t_offset,\n\t\t\t\t\t\t\tpwrb, sge_len);\n\t\t\tsg_len = sg_dma_len(sg);\n\t\t\taddr = (u64) sg_dma_address(sg);\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge1_addr_lo, pwrb,\n\t\t\t\t\t\t((u32)(addr & 0xFFFFFFFF)));\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge1_addr_hi, pwrb,\n\t\t\t\t\t\t\t((u32)(addr >> 32)));\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge1_len, pwrb,\n\t\t\t\t\t\t\tsg_len);\n\t\t}\n\t}\n\tpsgl = (struct iscsi_sge *)io_task->psgl_handle->pfrag;\n\tmemset(psgl, 0, sizeof(*psgl) * BE2_SGE);\n\n\tAMAP_SET_BITS(struct amap_iscsi_sge, len, psgl, io_task->bhs_len - 2);\n\n\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_hi, psgl,\n\t\t\tio_task->bhs_pa.u.a32.address_hi);\n\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_lo, psgl,\n\t\t\tio_task->bhs_pa.u.a32.address_lo);\n\n\tif (num_sg == 1) {\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge0_last, pwrb,\n\t\t\t\t\t\t\t\t1);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge1_last, pwrb,\n\t\t\t\t\t\t\t\t0);\n\t} else if (num_sg == 2) {\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge0_last, pwrb,\n\t\t\t\t\t\t\t\t0);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge1_last, pwrb,\n\t\t\t\t\t\t\t\t1);\n\t} else {\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge0_last, pwrb,\n\t\t\t\t\t\t\t\t0);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge1_last, pwrb,\n\t\t\t\t\t\t\t\t0);\n\t}\n\tsg = l_sg;\n\tpsgl++;\n\tpsgl++;\n\toffset = 0;\n\tfor (index = 0; index < num_sg; index++, sg = sg_next(sg), psgl++) {\n\t\tsg_len = sg_dma_len(sg);\n\t\taddr = (u64) sg_dma_address(sg);\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_lo, psgl,\n\t\t\t\t\t\t(addr & 0xFFFFFFFF));\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_hi, psgl,\n\t\t\t\t\t\t(addr >> 32));\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, len, psgl, sg_len);\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, sge_offset, psgl, offset);\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, last_sge, psgl, 0);\n\t\toffset += sg_len;\n\t}\n\tpsgl--;\n\tAMAP_SET_BITS(struct amap_iscsi_sge, last_sge, psgl, 1);\n}\n\n \nstatic int hwi_write_buffer(struct iscsi_wrb *pwrb, struct iscsi_task *task)\n{\n\tstruct iscsi_sge *psgl;\n\tstruct beiscsi_io_task *io_task = task->dd_data;\n\tstruct beiscsi_conn *beiscsi_conn = io_task->conn;\n\tstruct beiscsi_hba *phba = beiscsi_conn->phba;\n\tuint8_t dsp_value = 0;\n\n\tio_task->bhs_len = sizeof(struct be_nonio_bhs) - 2;\n\tAMAP_SET_BITS(struct amap_iscsi_wrb, iscsi_bhs_addr_lo, pwrb,\n\t\t\t\tio_task->bhs_pa.u.a32.address_lo);\n\tAMAP_SET_BITS(struct amap_iscsi_wrb, iscsi_bhs_addr_hi, pwrb,\n\t\t\t\tio_task->bhs_pa.u.a32.address_hi);\n\n\tif (task->data) {\n\n\t\t \n\t\tdsp_value = (task->data_count) ? 1 : 0;\n\n\t\tif (is_chip_be2_be3r(phba))\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, dsp,\n\t\t\t\t      pwrb, dsp_value);\n\t\telse\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, dsp,\n\t\t\t\t      pwrb, dsp_value);\n\n\t\t \n\t\tif (dsp_value) {\n\t\t\tio_task->mtask_addr = dma_map_single(&phba->pcidev->dev,\n\t\t\t\t\t\t\t     task->data,\n\t\t\t\t\t\t\t     task->data_count,\n\t\t\t\t\t\t\t     DMA_TO_DEVICE);\n\t\t\tif (dma_mapping_error(&phba->pcidev->dev,\n\t\t\t\t\t\t  io_task->mtask_addr))\n\t\t\t\treturn -ENOMEM;\n\t\t\tio_task->mtask_data_count = task->data_count;\n\t\t} else\n\t\t\tio_task->mtask_addr = 0;\n\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge0_addr_lo, pwrb,\n\t\t\t      lower_32_bits(io_task->mtask_addr));\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge0_addr_hi, pwrb,\n\t\t\t      upper_32_bits(io_task->mtask_addr));\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge0_len, pwrb,\n\t\t\t\t\t\ttask->data_count);\n\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sge0_last, pwrb, 1);\n\t} else {\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, dsp, pwrb, 0);\n\t\tio_task->mtask_addr = 0;\n\t}\n\n\tpsgl = (struct iscsi_sge *)io_task->psgl_handle->pfrag;\n\n\tAMAP_SET_BITS(struct amap_iscsi_sge, len, psgl, io_task->bhs_len);\n\n\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_hi, psgl,\n\t\t      io_task->bhs_pa.u.a32.address_hi);\n\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_lo, psgl,\n\t\t      io_task->bhs_pa.u.a32.address_lo);\n\tif (task->data) {\n\t\tpsgl++;\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_hi, psgl, 0);\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_lo, psgl, 0);\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, len, psgl, 0);\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, sge_offset, psgl, 0);\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, rsvd0, psgl, 0);\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, last_sge, psgl, 0);\n\n\t\tpsgl++;\n\t\tif (task->data) {\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_lo, psgl,\n\t\t\t\t      lower_32_bits(io_task->mtask_addr));\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_hi, psgl,\n\t\t\t\t      upper_32_bits(io_task->mtask_addr));\n\t\t}\n\t\tAMAP_SET_BITS(struct amap_iscsi_sge, len, psgl, 0x106);\n\t}\n\tAMAP_SET_BITS(struct amap_iscsi_sge, last_sge, psgl, 1);\n\treturn 0;\n}\n\n \nstatic void beiscsi_find_mem_req(struct beiscsi_hba *phba)\n{\n\tuint8_t mem_descr_index, ulp_num;\n\tunsigned int num_async_pdu_buf_pages;\n\tunsigned int num_async_pdu_data_pages, wrb_sz_per_cxn;\n\tunsigned int num_async_pdu_buf_sgl_pages, num_async_pdu_data_sgl_pages;\n\n\tphba->params.hwi_ws_sz = sizeof(struct hwi_controller);\n\n\tphba->mem_req[ISCSI_MEM_GLOBAL_HEADER] = 2 *\n\t\t\t\t\t\t BE_ISCSI_PDU_HEADER_SIZE;\n\tphba->mem_req[HWI_MEM_ADDN_CONTEXT] =\n\t\t\t\t\t    sizeof(struct hwi_context_memory);\n\n\n\tphba->mem_req[HWI_MEM_WRB] = sizeof(struct iscsi_wrb)\n\t    * (phba->params.wrbs_per_cxn)\n\t    * phba->params.cxns_per_ctrl;\n\twrb_sz_per_cxn =  sizeof(struct wrb_handle) *\n\t\t\t\t (phba->params.wrbs_per_cxn);\n\tphba->mem_req[HWI_MEM_WRBH] = roundup_pow_of_two((wrb_sz_per_cxn) *\n\t\t\t\tphba->params.cxns_per_ctrl);\n\n\tphba->mem_req[HWI_MEM_SGLH] = sizeof(struct sgl_handle) *\n\t\tphba->params.icds_per_ctrl;\n\tphba->mem_req[HWI_MEM_SGE] = sizeof(struct iscsi_sge) *\n\t\tphba->params.num_sge_per_io * phba->params.icds_per_ctrl;\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\n\t\tif (test_bit(ulp_num, &phba->fw_config.ulp_supported)) {\n\n\t\t\tnum_async_pdu_buf_sgl_pages =\n\t\t\t\tPAGES_REQUIRED(BEISCSI_ASYNC_HDQ_SIZE(\n\t\t\t\t\t       phba, ulp_num) *\n\t\t\t\t\t       sizeof(struct phys_addr));\n\n\t\t\tnum_async_pdu_buf_pages =\n\t\t\t\tPAGES_REQUIRED(BEISCSI_ASYNC_HDQ_SIZE(\n\t\t\t\t\t       phba, ulp_num) *\n\t\t\t\t\t       phba->params.defpdu_hdr_sz);\n\n\t\t\tnum_async_pdu_data_pages =\n\t\t\t\tPAGES_REQUIRED(BEISCSI_ASYNC_HDQ_SIZE(\n\t\t\t\t\t       phba, ulp_num) *\n\t\t\t\t\t       phba->params.defpdu_data_sz);\n\n\t\t\tnum_async_pdu_data_sgl_pages =\n\t\t\t\tPAGES_REQUIRED(BEISCSI_ASYNC_HDQ_SIZE(\n\t\t\t\t\t       phba, ulp_num) *\n\t\t\t\t\t       sizeof(struct phys_addr));\n\n\t\t\tmem_descr_index = (HWI_MEM_TEMPLATE_HDR_ULP0 +\n\t\t\t\t\t  (ulp_num * MEM_DESCR_OFFSET));\n\t\t\tphba->mem_req[mem_descr_index] =\n\t\t\t\t\tBEISCSI_GET_CID_COUNT(phba, ulp_num) *\n\t\t\t\t\tBEISCSI_TEMPLATE_HDR_PER_CXN_SIZE;\n\n\t\t\tmem_descr_index = (HWI_MEM_ASYNC_HEADER_BUF_ULP0 +\n\t\t\t\t\t  (ulp_num * MEM_DESCR_OFFSET));\n\t\t\tphba->mem_req[mem_descr_index] =\n\t\t\t\t\t  num_async_pdu_buf_pages *\n\t\t\t\t\t  PAGE_SIZE;\n\n\t\t\tmem_descr_index = (HWI_MEM_ASYNC_DATA_BUF_ULP0 +\n\t\t\t\t\t  (ulp_num * MEM_DESCR_OFFSET));\n\t\t\tphba->mem_req[mem_descr_index] =\n\t\t\t\t\t  num_async_pdu_data_pages *\n\t\t\t\t\t  PAGE_SIZE;\n\n\t\t\tmem_descr_index = (HWI_MEM_ASYNC_HEADER_RING_ULP0 +\n\t\t\t\t\t  (ulp_num * MEM_DESCR_OFFSET));\n\t\t\tphba->mem_req[mem_descr_index] =\n\t\t\t\t\t  num_async_pdu_buf_sgl_pages *\n\t\t\t\t\t  PAGE_SIZE;\n\n\t\t\tmem_descr_index = (HWI_MEM_ASYNC_DATA_RING_ULP0 +\n\t\t\t\t\t  (ulp_num * MEM_DESCR_OFFSET));\n\t\t\tphba->mem_req[mem_descr_index] =\n\t\t\t\t\t  num_async_pdu_data_sgl_pages *\n\t\t\t\t\t  PAGE_SIZE;\n\n\t\t\tmem_descr_index = (HWI_MEM_ASYNC_HEADER_HANDLE_ULP0 +\n\t\t\t\t\t  (ulp_num * MEM_DESCR_OFFSET));\n\t\t\tphba->mem_req[mem_descr_index] =\n\t\t\t\tBEISCSI_ASYNC_HDQ_SIZE(phba, ulp_num) *\n\t\t\t\tsizeof(struct hd_async_handle);\n\n\t\t\tmem_descr_index = (HWI_MEM_ASYNC_DATA_HANDLE_ULP0 +\n\t\t\t\t\t  (ulp_num * MEM_DESCR_OFFSET));\n\t\t\tphba->mem_req[mem_descr_index] =\n\t\t\t\tBEISCSI_ASYNC_HDQ_SIZE(phba, ulp_num) *\n\t\t\t\tsizeof(struct hd_async_handle);\n\n\t\t\tmem_descr_index = (HWI_MEM_ASYNC_PDU_CONTEXT_ULP0 +\n\t\t\t\t\t  (ulp_num * MEM_DESCR_OFFSET));\n\t\t\tphba->mem_req[mem_descr_index] =\n\t\t\t\tsizeof(struct hd_async_context) +\n\t\t\t\t(BEISCSI_ASYNC_HDQ_SIZE(phba, ulp_num) *\n\t\t\t\t sizeof(struct hd_async_entry));\n\t\t}\n\t}\n}\n\nstatic int beiscsi_alloc_mem(struct beiscsi_hba *phba)\n{\n\tdma_addr_t bus_add;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct be_mem_descriptor *mem_descr;\n\tstruct mem_array *mem_arr, *mem_arr_orig;\n\tunsigned int i, j, alloc_size, curr_alloc_size;\n\n\tphba->phwi_ctrlr = kzalloc(phba->params.hwi_ws_sz, GFP_KERNEL);\n\tif (!phba->phwi_ctrlr)\n\t\treturn -ENOMEM;\n\n\t \n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tphwi_ctrlr->wrb_context = kcalloc(phba->params.cxns_per_ctrl,\n\t\t\t\t\t  sizeof(struct hwi_wrb_context),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!phwi_ctrlr->wrb_context) {\n\t\tkfree(phba->phwi_ctrlr);\n\t\treturn -ENOMEM;\n\t}\n\n\tphba->init_mem = kcalloc(SE_MEM_MAX, sizeof(*mem_descr),\n\t\t\t\t GFP_KERNEL);\n\tif (!phba->init_mem) {\n\t\tkfree(phwi_ctrlr->wrb_context);\n\t\tkfree(phba->phwi_ctrlr);\n\t\treturn -ENOMEM;\n\t}\n\n\tmem_arr_orig = kmalloc_array(BEISCSI_MAX_FRAGS_INIT,\n\t\t\t\t     sizeof(*mem_arr_orig),\n\t\t\t\t     GFP_KERNEL);\n\tif (!mem_arr_orig) {\n\t\tkfree(phba->init_mem);\n\t\tkfree(phwi_ctrlr->wrb_context);\n\t\tkfree(phba->phwi_ctrlr);\n\t\treturn -ENOMEM;\n\t}\n\n\tmem_descr = phba->init_mem;\n\tfor (i = 0; i < SE_MEM_MAX; i++) {\n\t\tif (!phba->mem_req[i]) {\n\t\t\tmem_descr->mem_array = NULL;\n\t\t\tmem_descr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tj = 0;\n\t\tmem_arr = mem_arr_orig;\n\t\talloc_size = phba->mem_req[i];\n\t\tmemset(mem_arr, 0, sizeof(struct mem_array) *\n\t\t       BEISCSI_MAX_FRAGS_INIT);\n\t\tcurr_alloc_size = min(be_max_phys_size * 1024, alloc_size);\n\t\tdo {\n\t\t\tmem_arr->virtual_address =\n\t\t\t\tdma_alloc_coherent(&phba->pcidev->dev,\n\t\t\t\t\tcurr_alloc_size, &bus_add, GFP_KERNEL);\n\t\t\tif (!mem_arr->virtual_address) {\n\t\t\t\tif (curr_alloc_size <= BE_MIN_MEM_SIZE)\n\t\t\t\t\tgoto free_mem;\n\t\t\t\tif (curr_alloc_size -\n\t\t\t\t\trounddown_pow_of_two(curr_alloc_size))\n\t\t\t\t\tcurr_alloc_size = rounddown_pow_of_two\n\t\t\t\t\t\t\t     (curr_alloc_size);\n\t\t\t\telse\n\t\t\t\t\tcurr_alloc_size = curr_alloc_size / 2;\n\t\t\t} else {\n\t\t\t\tmem_arr->bus_address.u.\n\t\t\t\t    a64.address = (__u64) bus_add;\n\t\t\t\tmem_arr->size = curr_alloc_size;\n\t\t\t\talloc_size -= curr_alloc_size;\n\t\t\t\tcurr_alloc_size = min(be_max_phys_size *\n\t\t\t\t\t\t      1024, alloc_size);\n\t\t\t\tj++;\n\t\t\t\tmem_arr++;\n\t\t\t}\n\t\t} while (alloc_size);\n\t\tmem_descr->num_elements = j;\n\t\tmem_descr->size_in_bytes = phba->mem_req[i];\n\t\tmem_descr->mem_array = kmalloc_array(j, sizeof(*mem_arr),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!mem_descr->mem_array)\n\t\t\tgoto free_mem;\n\n\t\tmemcpy(mem_descr->mem_array, mem_arr_orig,\n\t\t       sizeof(struct mem_array) * j);\n\t\tmem_descr++;\n\t}\n\tkfree(mem_arr_orig);\n\treturn 0;\nfree_mem:\n\tmem_descr->num_elements = j;\n\twhile ((i) || (j)) {\n\t\tfor (j = mem_descr->num_elements; j > 0; j--) {\n\t\t\tdma_free_coherent(&phba->pcidev->dev,\n\t\t\t\t\t    mem_descr->mem_array[j - 1].size,\n\t\t\t\t\t    mem_descr->mem_array[j - 1].\n\t\t\t\t\t    virtual_address,\n\t\t\t\t\t    (unsigned long)mem_descr->\n\t\t\t\t\t    mem_array[j - 1].\n\t\t\t\t\t    bus_address.u.a64.address);\n\t\t}\n\t\tif (i) {\n\t\t\ti--;\n\t\t\tkfree(mem_descr->mem_array);\n\t\t\tmem_descr--;\n\t\t}\n\t}\n\tkfree(mem_arr_orig);\n\tkfree(phba->init_mem);\n\tkfree(phba->phwi_ctrlr->wrb_context);\n\tkfree(phba->phwi_ctrlr);\n\treturn -ENOMEM;\n}\n\nstatic int beiscsi_get_memory(struct beiscsi_hba *phba)\n{\n\tbeiscsi_find_mem_req(phba);\n\treturn beiscsi_alloc_mem(phba);\n}\n\nstatic void iscsi_init_global_templates(struct beiscsi_hba *phba)\n{\n\tstruct pdu_data_out *pdata_out;\n\tstruct pdu_nop_out *pnop_out;\n\tstruct be_mem_descriptor *mem_descr;\n\n\tmem_descr = phba->init_mem;\n\tmem_descr += ISCSI_MEM_GLOBAL_HEADER;\n\tpdata_out =\n\t    (struct pdu_data_out *)mem_descr->mem_array[0].virtual_address;\n\tmemset(pdata_out, 0, BE_ISCSI_PDU_HEADER_SIZE);\n\n\tAMAP_SET_BITS(struct amap_pdu_data_out, opcode, pdata_out,\n\t\t      IIOC_SCSI_DATA);\n\n\tpnop_out =\n\t    (struct pdu_nop_out *)((unsigned char *)mem_descr->mem_array[0].\n\t\t\t\t   virtual_address + BE_ISCSI_PDU_HEADER_SIZE);\n\n\tmemset(pnop_out, 0, BE_ISCSI_PDU_HEADER_SIZE);\n\tAMAP_SET_BITS(struct amap_pdu_nop_out, ttt, pnop_out, 0xFFFFFFFF);\n\tAMAP_SET_BITS(struct amap_pdu_nop_out, f_bit, pnop_out, 1);\n\tAMAP_SET_BITS(struct amap_pdu_nop_out, i_bit, pnop_out, 0);\n}\n\nstatic int beiscsi_init_wrb_handle(struct beiscsi_hba *phba)\n{\n\tstruct be_mem_descriptor *mem_descr_wrbh, *mem_descr_wrb;\n\tstruct hwi_context_memory *phwi_ctxt;\n\tstruct wrb_handle *pwrb_handle = NULL;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct hwi_wrb_context *pwrb_context;\n\tstruct iscsi_wrb *pwrb = NULL;\n\tunsigned int num_cxn_wrbh = 0;\n\tunsigned int num_cxn_wrb = 0, j, idx = 0, index;\n\n\tmem_descr_wrbh = phba->init_mem;\n\tmem_descr_wrbh += HWI_MEM_WRBH;\n\n\tmem_descr_wrb = phba->init_mem;\n\tmem_descr_wrb += HWI_MEM_WRB;\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\n\t \n\tphwi_ctxt = phwi_ctrlr->phwi_ctxt;\n\tphwi_ctxt->be_wrbq = kcalloc(phba->params.cxns_per_ctrl,\n\t\t\t\t     sizeof(struct be_queue_info),\n\t\t\t\t     GFP_KERNEL);\n\tif (!phwi_ctxt->be_wrbq) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : WRBQ Mem Alloc Failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (index = 0; index < phba->params.cxns_per_ctrl; index++) {\n\t\tpwrb_context = &phwi_ctrlr->wrb_context[index];\n\t\tpwrb_context->pwrb_handle_base =\n\t\t\t\tkcalloc(phba->params.wrbs_per_cxn,\n\t\t\t\t\tsizeof(struct wrb_handle *),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!pwrb_context->pwrb_handle_base) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BM_%d : Mem Alloc Failed. Failing to load\\n\");\n\t\t\tgoto init_wrb_hndl_failed;\n\t\t}\n\t\tpwrb_context->pwrb_handle_basestd =\n\t\t\t\tkcalloc(phba->params.wrbs_per_cxn,\n\t\t\t\t\tsizeof(struct wrb_handle *),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!pwrb_context->pwrb_handle_basestd) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BM_%d : Mem Alloc Failed. Failing to load\\n\");\n\t\t\tgoto init_wrb_hndl_failed;\n\t\t}\n\t\tif (!num_cxn_wrbh) {\n\t\t\tpwrb_handle =\n\t\t\t\tmem_descr_wrbh->mem_array[idx].virtual_address;\n\t\t\tnum_cxn_wrbh = ((mem_descr_wrbh->mem_array[idx].size) /\n\t\t\t\t\t((sizeof(struct wrb_handle)) *\n\t\t\t\t\t phba->params.wrbs_per_cxn));\n\t\t\tidx++;\n\t\t}\n\t\tpwrb_context->alloc_index = 0;\n\t\tpwrb_context->wrb_handles_available = 0;\n\t\tpwrb_context->free_index = 0;\n\n\t\tif (num_cxn_wrbh) {\n\t\t\tfor (j = 0; j < phba->params.wrbs_per_cxn; j++) {\n\t\t\t\tpwrb_context->pwrb_handle_base[j] = pwrb_handle;\n\t\t\t\tpwrb_context->pwrb_handle_basestd[j] =\n\t\t\t\t\t\t\t\tpwrb_handle;\n\t\t\t\tpwrb_context->wrb_handles_available++;\n\t\t\t\tpwrb_handle->wrb_index = j;\n\t\t\t\tpwrb_handle++;\n\t\t\t}\n\t\t\tnum_cxn_wrbh--;\n\t\t}\n\t\tspin_lock_init(&pwrb_context->wrb_lock);\n\t}\n\tidx = 0;\n\tfor (index = 0; index < phba->params.cxns_per_ctrl; index++) {\n\t\tpwrb_context = &phwi_ctrlr->wrb_context[index];\n\t\tif (!num_cxn_wrb) {\n\t\t\tpwrb = mem_descr_wrb->mem_array[idx].virtual_address;\n\t\t\tnum_cxn_wrb = (mem_descr_wrb->mem_array[idx].size) /\n\t\t\t\t((sizeof(struct iscsi_wrb) *\n\t\t\t\t  phba->params.wrbs_per_cxn));\n\t\t\tidx++;\n\t\t}\n\n\t\tif (num_cxn_wrb) {\n\t\t\tfor (j = 0; j < phba->params.wrbs_per_cxn; j++) {\n\t\t\t\tpwrb_handle = pwrb_context->pwrb_handle_base[j];\n\t\t\t\tpwrb_handle->pwrb = pwrb;\n\t\t\t\tpwrb++;\n\t\t\t}\n\t\t\tnum_cxn_wrb--;\n\t\t}\n\t}\n\treturn 0;\ninit_wrb_hndl_failed:\n\tfor (j = index; j > 0; j--) {\n\t\tpwrb_context = &phwi_ctrlr->wrb_context[j];\n\t\tkfree(pwrb_context->pwrb_handle_base);\n\t\tkfree(pwrb_context->pwrb_handle_basestd);\n\t}\n\tkfree(phwi_ctxt->be_wrbq);\n\treturn -ENOMEM;\n}\n\nstatic int hwi_init_async_pdu_ctx(struct beiscsi_hba *phba)\n{\n\tuint8_t ulp_num;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct hba_parameters *p = &phba->params;\n\tstruct hd_async_context *pasync_ctx;\n\tstruct hd_async_handle *pasync_header_h, *pasync_data_h;\n\tunsigned int index, idx, num_per_mem, num_async_data;\n\tstruct be_mem_descriptor *mem_descr;\n\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\n\t\tif (test_bit(ulp_num, &phba->fw_config.ulp_supported)) {\n\t\t\t \n\t\t\tmem_descr = (struct be_mem_descriptor *)phba->init_mem;\n\t\t\tmem_descr += (HWI_MEM_ASYNC_PDU_CONTEXT_ULP0 +\n\t\t\t\t     (ulp_num * MEM_DESCR_OFFSET));\n\n\t\t\tphwi_ctrlr = phba->phwi_ctrlr;\n\t\t\tphwi_ctrlr->phwi_ctxt->pasync_ctx[ulp_num] =\n\t\t\t\t(struct hd_async_context *)\n\t\t\t\t mem_descr->mem_array[0].virtual_address;\n\n\t\t\tpasync_ctx = phwi_ctrlr->phwi_ctxt->pasync_ctx[ulp_num];\n\t\t\tmemset(pasync_ctx, 0, sizeof(*pasync_ctx));\n\n\t\t\tpasync_ctx->async_entry =\n\t\t\t\t\t(struct hd_async_entry *)\n\t\t\t\t\t((long unsigned int)pasync_ctx +\n\t\t\t\t\tsizeof(struct hd_async_context));\n\n\t\t\tpasync_ctx->num_entries = BEISCSI_ASYNC_HDQ_SIZE(phba,\n\t\t\t\t\t\t  ulp_num);\n\t\t\t \n\t\t\tmem_descr = (struct be_mem_descriptor *)phba->init_mem;\n\t\t\tmem_descr += HWI_MEM_ASYNC_HEADER_BUF_ULP0 +\n\t\t\t\t(ulp_num * MEM_DESCR_OFFSET);\n\t\t\tif (mem_descr->mem_array[0].virtual_address) {\n\t\t\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t\t\t    \"BM_%d : hwi_init_async_pdu_ctx\"\n\t\t\t\t\t    \" HWI_MEM_ASYNC_HEADER_BUF_ULP%d va=%p\\n\",\n\t\t\t\t\t    ulp_num,\n\t\t\t\t\t    mem_descr->mem_array[0].\n\t\t\t\t\t    virtual_address);\n\t\t\t} else\n\t\t\t\tbeiscsi_log(phba, KERN_WARNING,\n\t\t\t\t\t    BEISCSI_LOG_INIT,\n\t\t\t\t\t    \"BM_%d : No Virtual address for ULP : %d\\n\",\n\t\t\t\t\t    ulp_num);\n\n\t\t\tpasync_ctx->async_header.pi = 0;\n\t\t\tpasync_ctx->async_header.buffer_size = p->defpdu_hdr_sz;\n\t\t\tpasync_ctx->async_header.va_base =\n\t\t\t\tmem_descr->mem_array[0].virtual_address;\n\n\t\t\tpasync_ctx->async_header.pa_base.u.a64.address =\n\t\t\t\tmem_descr->mem_array[0].\n\t\t\t\tbus_address.u.a64.address;\n\n\t\t\t \n\t\t\tmem_descr = (struct be_mem_descriptor *)phba->init_mem;\n\t\t\tmem_descr += HWI_MEM_ASYNC_HEADER_RING_ULP0 +\n\t\t\t\t     (ulp_num * MEM_DESCR_OFFSET);\n\t\t\tif (mem_descr->mem_array[0].virtual_address) {\n\t\t\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t\t\t    \"BM_%d : hwi_init_async_pdu_ctx\"\n\t\t\t\t\t    \" HWI_MEM_ASYNC_HEADER_RING_ULP%d va=%p\\n\",\n\t\t\t\t\t    ulp_num,\n\t\t\t\t\t    mem_descr->mem_array[0].\n\t\t\t\t\t    virtual_address);\n\t\t\t} else\n\t\t\t\tbeiscsi_log(phba, KERN_WARNING,\n\t\t\t\t\t    BEISCSI_LOG_INIT,\n\t\t\t\t\t    \"BM_%d : No Virtual address for ULP : %d\\n\",\n\t\t\t\t\t    ulp_num);\n\n\t\t\tpasync_ctx->async_header.ring_base =\n\t\t\t\tmem_descr->mem_array[0].virtual_address;\n\n\t\t\t \n\t\t\tmem_descr = (struct be_mem_descriptor *)phba->init_mem;\n\t\t\tmem_descr += HWI_MEM_ASYNC_HEADER_HANDLE_ULP0 +\n\t\t\t\t     (ulp_num * MEM_DESCR_OFFSET);\n\t\t\tif (mem_descr->mem_array[0].virtual_address) {\n\t\t\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t\t\t    \"BM_%d : hwi_init_async_pdu_ctx\"\n\t\t\t\t\t    \" HWI_MEM_ASYNC_HEADER_HANDLE_ULP%d va=%p\\n\",\n\t\t\t\t\t    ulp_num,\n\t\t\t\t\t    mem_descr->mem_array[0].\n\t\t\t\t\t    virtual_address);\n\t\t\t} else\n\t\t\t\tbeiscsi_log(phba, KERN_WARNING,\n\t\t\t\t\t    BEISCSI_LOG_INIT,\n\t\t\t\t\t    \"BM_%d : No Virtual address for ULP : %d\\n\",\n\t\t\t\t\t    ulp_num);\n\n\t\t\tpasync_ctx->async_header.handle_base =\n\t\t\t\tmem_descr->mem_array[0].virtual_address;\n\n\t\t\t \n\t\t\tmem_descr = (struct be_mem_descriptor *)phba->init_mem;\n\t\t\tmem_descr += HWI_MEM_ASYNC_DATA_RING_ULP0 +\n\t\t\t\t     (ulp_num * MEM_DESCR_OFFSET);\n\t\t\tif (mem_descr->mem_array[0].virtual_address) {\n\t\t\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t\t\t    \"BM_%d : hwi_init_async_pdu_ctx\"\n\t\t\t\t\t    \" HWI_MEM_ASYNC_DATA_RING_ULP%d va=%p\\n\",\n\t\t\t\t\t    ulp_num,\n\t\t\t\t\t    mem_descr->mem_array[0].\n\t\t\t\t\t    virtual_address);\n\t\t\t} else\n\t\t\t\tbeiscsi_log(phba, KERN_WARNING,\n\t\t\t\t\t    BEISCSI_LOG_INIT,\n\t\t\t\t\t    \"BM_%d : No Virtual address for ULP : %d\\n\",\n\t\t\t\t\t    ulp_num);\n\n\t\t\tpasync_ctx->async_data.ring_base =\n\t\t\t\tmem_descr->mem_array[0].virtual_address;\n\n\t\t\t \n\t\t\tmem_descr = (struct be_mem_descriptor *)phba->init_mem;\n\t\t\tmem_descr += HWI_MEM_ASYNC_DATA_HANDLE_ULP0 +\n\t\t\t\t     (ulp_num * MEM_DESCR_OFFSET);\n\t\t\tif (!mem_descr->mem_array[0].virtual_address)\n\t\t\t\tbeiscsi_log(phba, KERN_WARNING,\n\t\t\t\t\t    BEISCSI_LOG_INIT,\n\t\t\t\t\t    \"BM_%d : No Virtual address for ULP : %d\\n\",\n\t\t\t\t\t    ulp_num);\n\n\t\t\tpasync_ctx->async_data.handle_base =\n\t\t\t\tmem_descr->mem_array[0].virtual_address;\n\n\t\t\tpasync_header_h =\n\t\t\t\t(struct hd_async_handle *)\n\t\t\t\tpasync_ctx->async_header.handle_base;\n\t\t\tpasync_data_h =\n\t\t\t\t(struct hd_async_handle *)\n\t\t\t\tpasync_ctx->async_data.handle_base;\n\n\t\t\t \n\t\t\tmem_descr = (struct be_mem_descriptor *)phba->init_mem;\n\t\t\tmem_descr += HWI_MEM_ASYNC_DATA_BUF_ULP0 +\n\t\t\t\t     (ulp_num * MEM_DESCR_OFFSET);\n\t\t\tif (mem_descr->mem_array[0].virtual_address) {\n\t\t\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t\t\t    \"BM_%d : hwi_init_async_pdu_ctx\"\n\t\t\t\t\t    \" HWI_MEM_ASYNC_DATA_BUF_ULP%d va=%p\\n\",\n\t\t\t\t\t    ulp_num,\n\t\t\t\t\t    mem_descr->mem_array[0].\n\t\t\t\t\t    virtual_address);\n\t\t\t} else\n\t\t\t\tbeiscsi_log(phba, KERN_WARNING,\n\t\t\t\t\t    BEISCSI_LOG_INIT,\n\t\t\t\t\t    \"BM_%d : No Virtual address for ULP : %d\\n\",\n\t\t\t\t\t    ulp_num);\n\n\t\t\tidx = 0;\n\t\t\tpasync_ctx->async_data.pi = 0;\n\t\t\tpasync_ctx->async_data.buffer_size = p->defpdu_data_sz;\n\t\t\tpasync_ctx->async_data.va_base =\n\t\t\t\tmem_descr->mem_array[idx].virtual_address;\n\t\t\tpasync_ctx->async_data.pa_base.u.a64.address =\n\t\t\t\tmem_descr->mem_array[idx].\n\t\t\t\tbus_address.u.a64.address;\n\n\t\t\tnum_async_data = ((mem_descr->mem_array[idx].size) /\n\t\t\t\t\tphba->params.defpdu_data_sz);\n\t\t\tnum_per_mem = 0;\n\n\t\t\tfor (index = 0;\tindex < BEISCSI_ASYNC_HDQ_SIZE\n\t\t\t\t\t(phba, ulp_num); index++) {\n\t\t\t\tpasync_header_h->cri = -1;\n\t\t\t\tpasync_header_h->is_header = 1;\n\t\t\t\tpasync_header_h->index = index;\n\t\t\t\tINIT_LIST_HEAD(&pasync_header_h->link);\n\t\t\t\tpasync_header_h->pbuffer =\n\t\t\t\t\t(void *)((unsigned long)\n\t\t\t\t\t\t (pasync_ctx->\n\t\t\t\t\t\t  async_header.va_base) +\n\t\t\t\t\t\t (p->defpdu_hdr_sz * index));\n\n\t\t\t\tpasync_header_h->pa.u.a64.address =\n\t\t\t\t\tpasync_ctx->async_header.pa_base.u.a64.\n\t\t\t\t\taddress + (p->defpdu_hdr_sz * index);\n\n\t\t\t\tpasync_ctx->async_entry[index].header =\n\t\t\t\t\tpasync_header_h;\n\t\t\t\tpasync_header_h++;\n\t\t\t\tINIT_LIST_HEAD(&pasync_ctx->async_entry[index].\n\t\t\t\t\t\twq.list);\n\n\t\t\t\tpasync_data_h->cri = -1;\n\t\t\t\tpasync_data_h->is_header = 0;\n\t\t\t\tpasync_data_h->index = index;\n\t\t\t\tINIT_LIST_HEAD(&pasync_data_h->link);\n\n\t\t\t\tif (!num_async_data) {\n\t\t\t\t\tnum_per_mem = 0;\n\t\t\t\t\tidx++;\n\t\t\t\t\tpasync_ctx->async_data.va_base =\n\t\t\t\t\t\tmem_descr->mem_array[idx].\n\t\t\t\t\t\tvirtual_address;\n\t\t\t\t\tpasync_ctx->async_data.pa_base.u.\n\t\t\t\t\t\ta64.address =\n\t\t\t\t\t\tmem_descr->mem_array[idx].\n\t\t\t\t\t\tbus_address.u.a64.address;\n\t\t\t\t\tnum_async_data =\n\t\t\t\t\t\t((mem_descr->mem_array[idx].\n\t\t\t\t\t\t  size) /\n\t\t\t\t\t\t phba->params.defpdu_data_sz);\n\t\t\t\t}\n\t\t\t\tpasync_data_h->pbuffer =\n\t\t\t\t\t(void *)((unsigned long)\n\t\t\t\t\t(pasync_ctx->async_data.va_base) +\n\t\t\t\t\t(p->defpdu_data_sz * num_per_mem));\n\n\t\t\t\tpasync_data_h->pa.u.a64.address =\n\t\t\t\t\tpasync_ctx->async_data.pa_base.u.a64.\n\t\t\t\t\taddress + (p->defpdu_data_sz *\n\t\t\t\t\tnum_per_mem);\n\t\t\t\tnum_per_mem++;\n\t\t\t\tnum_async_data--;\n\n\t\t\t\tpasync_ctx->async_entry[index].data =\n\t\t\t\t\tpasync_data_h;\n\t\t\t\tpasync_data_h++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbe_sgl_create_contiguous(void *virtual_address,\n\t\t\t u64 physical_address, u32 length,\n\t\t\t struct be_dma_mem *sgl)\n{\n\tWARN_ON(!virtual_address);\n\tWARN_ON(!physical_address);\n\tWARN_ON(!length);\n\tWARN_ON(!sgl);\n\n\tsgl->va = virtual_address;\n\tsgl->dma = (unsigned long)physical_address;\n\tsgl->size = length;\n\n\treturn 0;\n}\n\nstatic void be_sgl_destroy_contiguous(struct be_dma_mem *sgl)\n{\n\tmemset(sgl, 0, sizeof(*sgl));\n}\n\nstatic void\nhwi_build_be_sgl_arr(struct beiscsi_hba *phba,\n\t\t     struct mem_array *pmem, struct be_dma_mem *sgl)\n{\n\tif (sgl->va)\n\t\tbe_sgl_destroy_contiguous(sgl);\n\n\tbe_sgl_create_contiguous(pmem->virtual_address,\n\t\t\t\t pmem->bus_address.u.a64.address,\n\t\t\t\t pmem->size, sgl);\n}\n\nstatic void\nhwi_build_be_sgl_by_offset(struct beiscsi_hba *phba,\n\t\t\t   struct mem_array *pmem, struct be_dma_mem *sgl)\n{\n\tif (sgl->va)\n\t\tbe_sgl_destroy_contiguous(sgl);\n\n\tbe_sgl_create_contiguous((unsigned char *)pmem->virtual_address,\n\t\t\t\t pmem->bus_address.u.a64.address,\n\t\t\t\t pmem->size, sgl);\n}\n\nstatic int be_fill_queue(struct be_queue_info *q,\n\t\tu16 len, u16 entry_size, void *vaddress)\n{\n\tstruct be_dma_mem *mem = &q->dma_mem;\n\n\tmemset(q, 0, sizeof(*q));\n\tq->len = len;\n\tq->entry_size = entry_size;\n\tmem->size = len * entry_size;\n\tmem->va = vaddress;\n\tif (!mem->va)\n\t\treturn -ENOMEM;\n\tmemset(mem->va, 0, mem->size);\n\treturn 0;\n}\n\nstatic int beiscsi_create_eqs(struct beiscsi_hba *phba,\n\t\t\t     struct hwi_context_memory *phwi_context)\n{\n\tint ret = -ENOMEM, eq_for_mcc;\n\tunsigned int i, num_eq_pages;\n\tstruct be_queue_info *eq;\n\tstruct be_dma_mem *mem;\n\tvoid *eq_vaddress;\n\tdma_addr_t paddr;\n\n\tnum_eq_pages = PAGES_REQUIRED(phba->params.num_eq_entries *\n\t\t\t\t      sizeof(struct be_eq_entry));\n\n\tif (phba->pcidev->msix_enabled)\n\t\teq_for_mcc = 1;\n\telse\n\t\teq_for_mcc = 0;\n\tfor (i = 0; i < (phba->num_cpus + eq_for_mcc); i++) {\n\t\teq = &phwi_context->be_eq[i].q;\n\t\tmem = &eq->dma_mem;\n\t\tphwi_context->be_eq[i].phba = phba;\n\t\teq_vaddress = dma_alloc_coherent(&phba->pcidev->dev,\n\t\t\t\t\t\t   num_eq_pages * PAGE_SIZE,\n\t\t\t\t\t\t   &paddr, GFP_KERNEL);\n\t\tif (!eq_vaddress) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto create_eq_error;\n\t\t}\n\n\t\tmem->va = eq_vaddress;\n\t\tret = be_fill_queue(eq, phba->params.num_eq_entries,\n\t\t\t\t    sizeof(struct be_eq_entry), eq_vaddress);\n\t\tif (ret) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BM_%d : be_fill_queue Failed for EQ\\n\");\n\t\t\tgoto create_eq_error;\n\t\t}\n\n\t\tmem->dma = paddr;\n\t\tret = beiscsi_cmd_eq_create(&phba->ctrl, eq,\n\t\t\t\t\t    BEISCSI_EQ_DELAY_DEF);\n\t\tif (ret) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BM_%d : beiscsi_cmd_eq_create Failed for EQ\\n\");\n\t\t\tgoto create_eq_error;\n\t\t}\n\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : eqid = %d\\n\",\n\t\t\t    phwi_context->be_eq[i].q.id);\n\t}\n\treturn 0;\n\ncreate_eq_error:\n\tfor (i = 0; i < (phba->num_cpus + eq_for_mcc); i++) {\n\t\teq = &phwi_context->be_eq[i].q;\n\t\tmem = &eq->dma_mem;\n\t\tif (mem->va)\n\t\t\tdma_free_coherent(&phba->pcidev->dev, num_eq_pages\n\t\t\t\t\t    * PAGE_SIZE,\n\t\t\t\t\t    mem->va, mem->dma);\n\t}\n\treturn ret;\n}\n\nstatic int beiscsi_create_cqs(struct beiscsi_hba *phba,\n\t\t\t     struct hwi_context_memory *phwi_context)\n{\n\tunsigned int i, num_cq_pages;\n\tstruct be_queue_info *cq, *eq;\n\tstruct be_dma_mem *mem;\n\tstruct be_eq_obj *pbe_eq;\n\tvoid *cq_vaddress;\n\tint ret = -ENOMEM;\n\tdma_addr_t paddr;\n\n\tnum_cq_pages = PAGES_REQUIRED(phba->params.num_cq_entries *\n\t\t\t\t      sizeof(struct sol_cqe));\n\n\tfor (i = 0; i < phba->num_cpus; i++) {\n\t\tcq = &phwi_context->be_cq[i];\n\t\teq = &phwi_context->be_eq[i].q;\n\t\tpbe_eq = &phwi_context->be_eq[i];\n\t\tpbe_eq->cq = cq;\n\t\tpbe_eq->phba = phba;\n\t\tmem = &cq->dma_mem;\n\t\tcq_vaddress = dma_alloc_coherent(&phba->pcidev->dev,\n\t\t\t\t\t\t   num_cq_pages * PAGE_SIZE,\n\t\t\t\t\t\t   &paddr, GFP_KERNEL);\n\t\tif (!cq_vaddress) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto create_cq_error;\n\t\t}\n\n\t\tret = be_fill_queue(cq, phba->params.num_cq_entries,\n\t\t\t\t    sizeof(struct sol_cqe), cq_vaddress);\n\t\tif (ret) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BM_%d : be_fill_queue Failed for ISCSI CQ\\n\");\n\t\t\tgoto create_cq_error;\n\t\t}\n\n\t\tmem->dma = paddr;\n\t\tret = beiscsi_cmd_cq_create(&phba->ctrl, cq, eq, false,\n\t\t\t\t\t    false, 0);\n\t\tif (ret) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BM_%d : beiscsi_cmd_eq_create Failed for ISCSI CQ\\n\");\n\t\t\tgoto create_cq_error;\n\t\t}\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : iscsi cq_id is %d for eq_id %d\\n\"\n\t\t\t    \"iSCSI CQ CREATED\\n\", cq->id, eq->id);\n\t}\n\treturn 0;\n\ncreate_cq_error:\n\tfor (i = 0; i < phba->num_cpus; i++) {\n\t\tcq = &phwi_context->be_cq[i];\n\t\tmem = &cq->dma_mem;\n\t\tif (mem->va)\n\t\t\tdma_free_coherent(&phba->pcidev->dev, num_cq_pages\n\t\t\t\t\t    * PAGE_SIZE,\n\t\t\t\t\t    mem->va, mem->dma);\n\t}\n\treturn ret;\n}\n\nstatic int\nbeiscsi_create_def_hdr(struct beiscsi_hba *phba,\n\t\t       struct hwi_context_memory *phwi_context,\n\t\t       struct hwi_controller *phwi_ctrlr,\n\t\t       unsigned int def_pdu_ring_sz, uint8_t ulp_num)\n{\n\tunsigned int idx;\n\tint ret;\n\tstruct be_queue_info *dq, *cq;\n\tstruct be_dma_mem *mem;\n\tstruct be_mem_descriptor *mem_descr;\n\tvoid *dq_vaddress;\n\n\tidx = 0;\n\tdq = &phwi_context->be_def_hdrq[ulp_num];\n\tcq = &phwi_context->be_cq[0];\n\tmem = &dq->dma_mem;\n\tmem_descr = phba->init_mem;\n\tmem_descr += HWI_MEM_ASYNC_HEADER_RING_ULP0 +\n\t\t    (ulp_num * MEM_DESCR_OFFSET);\n\tdq_vaddress = mem_descr->mem_array[idx].virtual_address;\n\tret = be_fill_queue(dq, mem_descr->mem_array[0].size /\n\t\t\t    sizeof(struct phys_addr),\n\t\t\t    sizeof(struct phys_addr), dq_vaddress);\n\tif (ret) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : be_fill_queue Failed for DEF PDU HDR on ULP : %d\\n\",\n\t\t\t    ulp_num);\n\n\t\treturn ret;\n\t}\n\tmem->dma = (unsigned long)mem_descr->mem_array[idx].\n\t\t\t\t  bus_address.u.a64.address;\n\tret = be_cmd_create_default_pdu_queue(&phba->ctrl, cq, dq,\n\t\t\t\t\t      def_pdu_ring_sz,\n\t\t\t\t\t      phba->params.defpdu_hdr_sz,\n\t\t\t\t\t      BEISCSI_DEFQ_HDR, ulp_num);\n\tif (ret) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : be_cmd_create_default_pdu_queue Failed DEFHDR on ULP : %d\\n\",\n\t\t\t    ulp_num);\n\n\t\treturn ret;\n\t}\n\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t    \"BM_%d : iscsi hdr def pdu id for ULP : %d is %d\\n\",\n\t\t    ulp_num,\n\t\t    phwi_context->be_def_hdrq[ulp_num].id);\n\treturn 0;\n}\n\nstatic int\nbeiscsi_create_def_data(struct beiscsi_hba *phba,\n\t\t\tstruct hwi_context_memory *phwi_context,\n\t\t\tstruct hwi_controller *phwi_ctrlr,\n\t\t\tunsigned int def_pdu_ring_sz, uint8_t ulp_num)\n{\n\tunsigned int idx;\n\tint ret;\n\tstruct be_queue_info *dataq, *cq;\n\tstruct be_dma_mem *mem;\n\tstruct be_mem_descriptor *mem_descr;\n\tvoid *dq_vaddress;\n\n\tidx = 0;\n\tdataq = &phwi_context->be_def_dataq[ulp_num];\n\tcq = &phwi_context->be_cq[0];\n\tmem = &dataq->dma_mem;\n\tmem_descr = phba->init_mem;\n\tmem_descr += HWI_MEM_ASYNC_DATA_RING_ULP0 +\n\t\t    (ulp_num * MEM_DESCR_OFFSET);\n\tdq_vaddress = mem_descr->mem_array[idx].virtual_address;\n\tret = be_fill_queue(dataq, mem_descr->mem_array[0].size /\n\t\t\t    sizeof(struct phys_addr),\n\t\t\t    sizeof(struct phys_addr), dq_vaddress);\n\tif (ret) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : be_fill_queue Failed for DEF PDU \"\n\t\t\t    \"DATA on ULP : %d\\n\",\n\t\t\t    ulp_num);\n\n\t\treturn ret;\n\t}\n\tmem->dma = (unsigned long)mem_descr->mem_array[idx].\n\t\t\t\t  bus_address.u.a64.address;\n\tret = be_cmd_create_default_pdu_queue(&phba->ctrl, cq, dataq,\n\t\t\t\t\t      def_pdu_ring_sz,\n\t\t\t\t\t      phba->params.defpdu_data_sz,\n\t\t\t\t\t      BEISCSI_DEFQ_DATA, ulp_num);\n\tif (ret) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d be_cmd_create_default_pdu_queue\"\n\t\t\t    \" Failed for DEF PDU DATA on ULP : %d\\n\",\n\t\t\t    ulp_num);\n\t\treturn ret;\n\t}\n\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t    \"BM_%d : iscsi def data id on ULP : %d is  %d\\n\",\n\t\t    ulp_num,\n\t\t    phwi_context->be_def_dataq[ulp_num].id);\n\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t    \"BM_%d : DEFAULT PDU DATA RING CREATED on ULP : %d\\n\",\n\t\t    ulp_num);\n\treturn 0;\n}\n\n\nstatic int\nbeiscsi_post_template_hdr(struct beiscsi_hba *phba)\n{\n\tstruct be_mem_descriptor *mem_descr;\n\tstruct mem_array *pm_arr;\n\tstruct be_dma_mem sgl;\n\tint status, ulp_num;\n\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\n\t\tif (test_bit(ulp_num, &phba->fw_config.ulp_supported)) {\n\t\t\tmem_descr = (struct be_mem_descriptor *)phba->init_mem;\n\t\t\tmem_descr += HWI_MEM_TEMPLATE_HDR_ULP0 +\n\t\t\t\t    (ulp_num * MEM_DESCR_OFFSET);\n\t\t\tpm_arr = mem_descr->mem_array;\n\n\t\t\thwi_build_be_sgl_arr(phba, pm_arr, &sgl);\n\t\t\tstatus = be_cmd_iscsi_post_template_hdr(\n\t\t\t\t &phba->ctrl, &sgl);\n\n\t\t\tif (status != 0) {\n\t\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t\t    \"BM_%d : Post Template HDR Failed for \"\n\t\t\t\t\t    \"ULP_%d\\n\", ulp_num);\n\t\t\t\treturn status;\n\t\t\t}\n\n\t\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BM_%d : Template HDR Pages Posted for \"\n\t\t\t\t    \"ULP_%d\\n\", ulp_num);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nbeiscsi_post_pages(struct beiscsi_hba *phba)\n{\n\tstruct be_mem_descriptor *mem_descr;\n\tstruct mem_array *pm_arr;\n\tunsigned int page_offset, i;\n\tstruct be_dma_mem sgl;\n\tint status, ulp_num = 0;\n\n\tmem_descr = phba->init_mem;\n\tmem_descr += HWI_MEM_SGE;\n\tpm_arr = mem_descr->mem_array;\n\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++)\n\t\tif (test_bit(ulp_num, &phba->fw_config.ulp_supported))\n\t\t\tbreak;\n\n\tpage_offset = (sizeof(struct iscsi_sge) * phba->params.num_sge_per_io *\n\t\t\tphba->fw_config.iscsi_icd_start[ulp_num]) / PAGE_SIZE;\n\tfor (i = 0; i < mem_descr->num_elements; i++) {\n\t\thwi_build_be_sgl_arr(phba, pm_arr, &sgl);\n\t\tstatus = be_cmd_iscsi_post_sgl_pages(&phba->ctrl, &sgl,\n\t\t\t\t\t\tpage_offset,\n\t\t\t\t\t\t(pm_arr->size / PAGE_SIZE));\n\t\tpage_offset += pm_arr->size / PAGE_SIZE;\n\t\tif (status != 0) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BM_%d : post sgl failed.\\n\");\n\t\t\treturn status;\n\t\t}\n\t\tpm_arr++;\n\t}\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t    \"BM_%d : POSTED PAGES\\n\");\n\treturn 0;\n}\n\nstatic void be_queue_free(struct beiscsi_hba *phba, struct be_queue_info *q)\n{\n\tstruct be_dma_mem *mem = &q->dma_mem;\n\tif (mem->va) {\n\t\tdma_free_coherent(&phba->pcidev->dev, mem->size,\n\t\t\tmem->va, mem->dma);\n\t\tmem->va = NULL;\n\t}\n}\n\nstatic int be_queue_alloc(struct beiscsi_hba *phba, struct be_queue_info *q,\n\t\tu16 len, u16 entry_size)\n{\n\tstruct be_dma_mem *mem = &q->dma_mem;\n\n\tmemset(q, 0, sizeof(*q));\n\tq->len = len;\n\tq->entry_size = entry_size;\n\tmem->size = len * entry_size;\n\tmem->va = dma_alloc_coherent(&phba->pcidev->dev, mem->size, &mem->dma,\n\t\t\t\t     GFP_KERNEL);\n\tif (!mem->va)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int\nbeiscsi_create_wrb_rings(struct beiscsi_hba *phba,\n\t\t\t struct hwi_context_memory *phwi_context,\n\t\t\t struct hwi_controller *phwi_ctrlr)\n{\n\tunsigned int num_wrb_rings;\n\tu64 pa_addr_lo;\n\tunsigned int idx, num, i, ulp_num;\n\tstruct mem_array *pwrb_arr;\n\tvoid *wrb_vaddr;\n\tstruct be_dma_mem sgl;\n\tstruct be_mem_descriptor *mem_descr;\n\tstruct hwi_wrb_context *pwrb_context;\n\tint status;\n\tuint8_t ulp_count = 0, ulp_base_num = 0;\n\tuint16_t cid_count_ulp[BEISCSI_ULP_COUNT] = { 0 };\n\n\tidx = 0;\n\tmem_descr = phba->init_mem;\n\tmem_descr += HWI_MEM_WRB;\n\tpwrb_arr = kmalloc_array(phba->params.cxns_per_ctrl,\n\t\t\t\t sizeof(*pwrb_arr),\n\t\t\t\t GFP_KERNEL);\n\tif (!pwrb_arr) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : Memory alloc failed in create wrb ring.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\twrb_vaddr = mem_descr->mem_array[idx].virtual_address;\n\tpa_addr_lo = mem_descr->mem_array[idx].bus_address.u.a64.address;\n\tnum_wrb_rings = mem_descr->mem_array[idx].size /\n\t\t(phba->params.wrbs_per_cxn * sizeof(struct iscsi_wrb));\n\n\tfor (num = 0; num < phba->params.cxns_per_ctrl; num++) {\n\t\tif (num_wrb_rings) {\n\t\t\tpwrb_arr[num].virtual_address = wrb_vaddr;\n\t\t\tpwrb_arr[num].bus_address.u.a64.address\t= pa_addr_lo;\n\t\t\tpwrb_arr[num].size = phba->params.wrbs_per_cxn *\n\t\t\t\t\t    sizeof(struct iscsi_wrb);\n\t\t\twrb_vaddr += pwrb_arr[num].size;\n\t\t\tpa_addr_lo += pwrb_arr[num].size;\n\t\t\tnum_wrb_rings--;\n\t\t} else {\n\t\t\tidx++;\n\t\t\twrb_vaddr = mem_descr->mem_array[idx].virtual_address;\n\t\t\tpa_addr_lo = mem_descr->mem_array[idx].\n\t\t\t\t\tbus_address.u.a64.address;\n\t\t\tnum_wrb_rings = mem_descr->mem_array[idx].size /\n\t\t\t\t\t(phba->params.wrbs_per_cxn *\n\t\t\t\t\tsizeof(struct iscsi_wrb));\n\t\t\tpwrb_arr[num].virtual_address = wrb_vaddr;\n\t\t\tpwrb_arr[num].bus_address.u.a64.address = pa_addr_lo;\n\t\t\tpwrb_arr[num].size = phba->params.wrbs_per_cxn *\n\t\t\t\t\t\t sizeof(struct iscsi_wrb);\n\t\t\twrb_vaddr += pwrb_arr[num].size;\n\t\t\tpa_addr_lo += pwrb_arr[num].size;\n\t\t\tnum_wrb_rings--;\n\t\t}\n\t}\n\n\t \n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++)\n\t\tif (test_bit(ulp_num, &phba->fw_config.ulp_supported)) {\n\t\t\tulp_count++;\n\t\t\tulp_base_num = ulp_num;\n\t\t\tcid_count_ulp[ulp_num] =\n\t\t\t\tBEISCSI_GET_CID_COUNT(phba, ulp_num);\n\t\t}\n\n\tfor (i = 0; i < phba->params.cxns_per_ctrl; i++) {\n\t\tif (ulp_count > 1) {\n\t\t\tulp_base_num = (ulp_base_num + 1) % BEISCSI_ULP_COUNT;\n\n\t\t\tif (!cid_count_ulp[ulp_base_num])\n\t\t\t\tulp_base_num = (ulp_base_num + 1) %\n\t\t\t\t\t\tBEISCSI_ULP_COUNT;\n\n\t\t\tcid_count_ulp[ulp_base_num]--;\n\t\t}\n\n\n\t\thwi_build_be_sgl_by_offset(phba, &pwrb_arr[i], &sgl);\n\t\tstatus = be_cmd_wrbq_create(&phba->ctrl, &sgl,\n\t\t\t\t\t    &phwi_context->be_wrbq[i],\n\t\t\t\t\t    &phwi_ctrlr->wrb_context[i],\n\t\t\t\t\t    ulp_base_num);\n\t\tif (status != 0) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BM_%d : wrbq create failed.\");\n\t\t\tkfree(pwrb_arr);\n\t\t\treturn status;\n\t\t}\n\t\tpwrb_context = &phwi_ctrlr->wrb_context[i];\n\t\tBE_SET_CID_TO_CRI(i, pwrb_context->cid);\n\t}\n\tkfree(pwrb_arr);\n\treturn 0;\n}\n\nstatic void free_wrb_handles(struct beiscsi_hba *phba)\n{\n\tunsigned int index;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct hwi_wrb_context *pwrb_context;\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tfor (index = 0; index < phba->params.cxns_per_ctrl; index++) {\n\t\tpwrb_context = &phwi_ctrlr->wrb_context[index];\n\t\tkfree(pwrb_context->pwrb_handle_base);\n\t\tkfree(pwrb_context->pwrb_handle_basestd);\n\t}\n}\n\nstatic void be_mcc_queues_destroy(struct beiscsi_hba *phba)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct be_dma_mem *ptag_mem;\n\tstruct be_queue_info *q;\n\tint i, tag;\n\n\tq = &phba->ctrl.mcc_obj.q;\n\tfor (i = 0; i < MAX_MCC_CMD; i++) {\n\t\ttag = i + 1;\n\t\tif (!test_bit(MCC_TAG_STATE_RUNNING,\n\t\t\t      &ctrl->ptag_state[tag].tag_state))\n\t\t\tcontinue;\n\n\t\tif (test_bit(MCC_TAG_STATE_TIMEOUT,\n\t\t\t     &ctrl->ptag_state[tag].tag_state)) {\n\t\t\tptag_mem = &ctrl->ptag_state[tag].tag_mem_state;\n\t\t\tif (ptag_mem->size) {\n\t\t\t\tdma_free_coherent(&ctrl->pdev->dev,\n\t\t\t\t\t\t    ptag_mem->size,\n\t\t\t\t\t\t    ptag_mem->va,\n\t\t\t\t\t\t    ptag_mem->dma);\n\t\t\t\tptag_mem->size = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (waitqueue_active(&ctrl->mcc_wait[tag])) {\n\t\t\tctrl->mcc_tag_status[tag] = MCC_STATUS_FAILED;\n\t\t\tctrl->mcc_tag_status[tag] |= CQE_VALID_MASK;\n\t\t\twake_up_interruptible(&ctrl->mcc_wait[tag]);\n\t\t\t \n\t\t\twhile (test_bit(MCC_TAG_STATE_RUNNING,\n\t\t\t\t\t&ctrl->ptag_state[tag].tag_state))\n\t\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t}\n\t\t \n\t}\n\tif (q->created) {\n\t\tbeiscsi_cmd_q_destroy(ctrl, q, QTYPE_MCCQ);\n\t\tbe_queue_free(phba, q);\n\t}\n\n\tq = &phba->ctrl.mcc_obj.cq;\n\tif (q->created) {\n\t\tbeiscsi_cmd_q_destroy(ctrl, q, QTYPE_CQ);\n\t\tbe_queue_free(phba, q);\n\t}\n}\n\nstatic int be_mcc_queues_create(struct beiscsi_hba *phba,\n\t\t\t\tstruct hwi_context_memory *phwi_context)\n{\n\tstruct be_queue_info *q, *cq;\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\n\t \n\tcq = &phba->ctrl.mcc_obj.cq;\n\tif (be_queue_alloc(phba, cq, MCC_CQ_LEN,\n\t\t\tsizeof(struct be_mcc_compl)))\n\t\tgoto err;\n\t \n\tif (phba->pcidev->msix_enabled) {\n\t\tif (beiscsi_cmd_cq_create(ctrl, cq,\n\t\t\t\t\t&phwi_context->be_eq[phba->num_cpus].q,\n\t\t\t\t\tfalse, true, 0))\n\t\t\tgoto mcc_cq_free;\n\t} else {\n\t\tif (beiscsi_cmd_cq_create(ctrl, cq, &phwi_context->be_eq[0].q,\n\t\t\t\t\t  false, true, 0))\n\t\t\tgoto mcc_cq_free;\n\t}\n\n\t \n\tq = &phba->ctrl.mcc_obj.q;\n\tif (be_queue_alloc(phba, q, MCC_Q_LEN, sizeof(struct be_mcc_wrb)))\n\t\tgoto mcc_cq_destroy;\n\n\t \n\tif (beiscsi_cmd_mccq_create(phba, q, cq))\n\t\tgoto mcc_q_free;\n\n\treturn 0;\n\nmcc_q_free:\n\tbe_queue_free(phba, q);\nmcc_cq_destroy:\n\tbeiscsi_cmd_q_destroy(ctrl, cq, QTYPE_CQ);\nmcc_cq_free:\n\tbe_queue_free(phba, cq);\nerr:\n\treturn -ENOMEM;\n}\n\nstatic void be2iscsi_enable_msix(struct beiscsi_hba *phba)\n{\n\tint nvec = 1;\n\n\tswitch (phba->generation) {\n\tcase BE_GEN2:\n\tcase BE_GEN3:\n\t\tnvec = BEISCSI_MAX_NUM_CPUS + 1;\n\t\tbreak;\n\tcase BE_GEN4:\n\t\tnvec = phba->fw_config.eqid_count;\n\t\tbreak;\n\tdefault:\n\t\tnvec = 2;\n\t\tbreak;\n\t}\n\n\t \n\tif (enable_msix && nvec > 1) {\n\t\tstruct irq_affinity desc = { .post_vectors = 1 };\n\n\t\tif (pci_alloc_irq_vectors_affinity(phba->pcidev, 2, nvec,\n\t\t\t\tPCI_IRQ_MSIX | PCI_IRQ_AFFINITY, &desc) < 0) {\n\t\t\tphba->num_cpus = nvec - 1;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tphba->num_cpus = 1;\n}\n\nstatic void hwi_purge_eq(struct beiscsi_hba *phba)\n{\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct hwi_context_memory *phwi_context;\n\tstruct be_queue_info *eq;\n\tstruct be_eq_entry *eqe = NULL;\n\tint i, eq_msix;\n\tunsigned int num_processed;\n\n\tif (beiscsi_hba_in_error(phba))\n\t\treturn;\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tphwi_context = phwi_ctrlr->phwi_ctxt;\n\tif (phba->pcidev->msix_enabled)\n\t\teq_msix = 1;\n\telse\n\t\teq_msix = 0;\n\n\tfor (i = 0; i < (phba->num_cpus + eq_msix); i++) {\n\t\teq = &phwi_context->be_eq[i].q;\n\t\teqe = queue_tail_node(eq);\n\t\tnum_processed = 0;\n\t\twhile (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]\n\t\t\t\t\t& EQE_VALID_MASK) {\n\t\t\tAMAP_SET_BITS(struct amap_eq_entry, valid, eqe, 0);\n\t\t\tqueue_tail_inc(eq);\n\t\t\teqe = queue_tail_node(eq);\n\t\t\tnum_processed++;\n\t\t}\n\n\t\tif (num_processed)\n\t\t\thwi_ring_eq_db(phba, eq->id, 1,\tnum_processed, 1, 1);\n\t}\n}\n\nstatic void hwi_cleanup_port(struct beiscsi_hba *phba)\n{\n\tstruct be_queue_info *q;\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct hwi_context_memory *phwi_context;\n\tint i, eq_for_mcc, ulp_num;\n\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++)\n\t\tif (test_bit(ulp_num, &phba->fw_config.ulp_supported))\n\t\t\tbeiscsi_cmd_iscsi_cleanup(phba, ulp_num);\n\n\t \n\thwi_purge_eq(phba);\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tphwi_context = phwi_ctrlr->phwi_ctxt;\n\n\tbe_cmd_iscsi_remove_template_hdr(ctrl);\n\n\tfor (i = 0; i < phba->params.cxns_per_ctrl; i++) {\n\t\tq = &phwi_context->be_wrbq[i];\n\t\tif (q->created)\n\t\t\tbeiscsi_cmd_q_destroy(ctrl, q, QTYPE_WRBQ);\n\t}\n\tkfree(phwi_context->be_wrbq);\n\tfree_wrb_handles(phba);\n\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\n\t\tif (test_bit(ulp_num, &phba->fw_config.ulp_supported)) {\n\n\t\t\tq = &phwi_context->be_def_hdrq[ulp_num];\n\t\t\tif (q->created)\n\t\t\t\tbeiscsi_cmd_q_destroy(ctrl, q, QTYPE_DPDUQ);\n\n\t\t\tq = &phwi_context->be_def_dataq[ulp_num];\n\t\t\tif (q->created)\n\t\t\t\tbeiscsi_cmd_q_destroy(ctrl, q, QTYPE_DPDUQ);\n\t\t}\n\t}\n\n\tbeiscsi_cmd_q_destroy(ctrl, NULL, QTYPE_SGL);\n\n\tfor (i = 0; i < (phba->num_cpus); i++) {\n\t\tq = &phwi_context->be_cq[i];\n\t\tif (q->created) {\n\t\t\tbe_queue_free(phba, q);\n\t\t\tbeiscsi_cmd_q_destroy(ctrl, q, QTYPE_CQ);\n\t\t}\n\t}\n\n\tbe_mcc_queues_destroy(phba);\n\tif (phba->pcidev->msix_enabled)\n\t\teq_for_mcc = 1;\n\telse\n\t\teq_for_mcc = 0;\n\tfor (i = 0; i < (phba->num_cpus + eq_for_mcc); i++) {\n\t\tq = &phwi_context->be_eq[i].q;\n\t\tif (q->created) {\n\t\t\tbe_queue_free(phba, q);\n\t\t\tbeiscsi_cmd_q_destroy(ctrl, q, QTYPE_EQ);\n\t\t}\n\t}\n\t \n\tbeiscsi_cmd_function_reset(phba);\n\t \n\tbeiscsi_cmd_special_wrb(&phba->ctrl, 0);\n}\n\nstatic int hwi_init_port(struct beiscsi_hba *phba)\n{\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct hwi_context_memory *phwi_context;\n\tunsigned int def_pdu_ring_sz;\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tint status, ulp_num;\n\tu16 nbufs;\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tphwi_context = phwi_ctrlr->phwi_ctxt;\n\t \n\tphba->optic_state = 0xff;\n\n\tstatus = beiscsi_create_eqs(phba, phwi_context);\n\tif (status != 0) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : EQ not created\\n\");\n\t\tgoto error;\n\t}\n\n\tstatus = be_mcc_queues_create(phba, phwi_context);\n\tif (status != 0)\n\t\tgoto error;\n\n\tstatus = beiscsi_check_supported_fw(ctrl, phba);\n\tif (status != 0) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : Unsupported fw version\\n\");\n\t\tgoto error;\n\t}\n\n\tstatus = beiscsi_create_cqs(phba, phwi_context);\n\tif (status != 0) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : CQ not created\\n\");\n\t\tgoto error;\n\t}\n\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\n\t\tif (test_bit(ulp_num, &phba->fw_config.ulp_supported)) {\n\t\t\tnbufs = phwi_context->pasync_ctx[ulp_num]->num_entries;\n\t\t\tdef_pdu_ring_sz = nbufs * sizeof(struct phys_addr);\n\n\t\t\tstatus = beiscsi_create_def_hdr(phba, phwi_context,\n\t\t\t\t\t\t\tphwi_ctrlr,\n\t\t\t\t\t\t\tdef_pdu_ring_sz,\n\t\t\t\t\t\t\tulp_num);\n\t\t\tif (status != 0) {\n\t\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t\t    \"BM_%d : Default Header not created for ULP : %d\\n\",\n\t\t\t\t\t    ulp_num);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tstatus = beiscsi_create_def_data(phba, phwi_context,\n\t\t\t\t\t\t\t phwi_ctrlr,\n\t\t\t\t\t\t\t def_pdu_ring_sz,\n\t\t\t\t\t\t\t ulp_num);\n\t\t\tif (status != 0) {\n\t\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t\t    \"BM_%d : Default Data not created for ULP : %d\\n\",\n\t\t\t\t\t    ulp_num);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t \n\t\t\tbeiscsi_hdq_post_handles(phba, BEISCSI_DEFQ_HDR,\n\t\t\t\t\t\t ulp_num, nbufs);\n\t\t\tbeiscsi_hdq_post_handles(phba, BEISCSI_DEFQ_DATA,\n\t\t\t\t\t\t ulp_num, nbufs);\n\t\t}\n\t}\n\n\tstatus = beiscsi_post_pages(phba);\n\tif (status != 0) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : Post SGL Pages Failed\\n\");\n\t\tgoto error;\n\t}\n\n\tstatus = beiscsi_post_template_hdr(phba);\n\tif (status != 0) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : Template HDR Posting for CXN Failed\\n\");\n\t}\n\n\tstatus = beiscsi_create_wrb_rings(phba,\tphwi_context, phwi_ctrlr);\n\tif (status != 0) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : WRB Rings not created\\n\");\n\t\tgoto error;\n\t}\n\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\n\t\tuint16_t async_arr_idx = 0;\n\n\t\tif (test_bit(ulp_num, &phba->fw_config.ulp_supported)) {\n\t\t\tuint16_t cri = 0;\n\t\t\tstruct hd_async_context *pasync_ctx;\n\n\t\t\tpasync_ctx = HWI_GET_ASYNC_PDU_CTX(\n\t\t\t\t     phwi_ctrlr, ulp_num);\n\t\t\tfor (cri = 0; cri <\n\t\t\t     phba->params.cxns_per_ctrl; cri++) {\n\t\t\t\tif (ulp_num == BEISCSI_GET_ULP_FROM_CRI\n\t\t\t\t\t       (phwi_ctrlr, cri))\n\t\t\t\t\tpasync_ctx->cid_to_async_cri_map[\n\t\t\t\t\tphwi_ctrlr->wrb_context[cri].cid] =\n\t\t\t\t\tasync_arr_idx++;\n\t\t\t}\n\t\t}\n\t}\n\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t    \"BM_%d : hwi_init_port success\\n\");\n\treturn 0;\n\nerror:\n\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t    \"BM_%d : hwi_init_port failed\");\n\thwi_cleanup_port(phba);\n\treturn status;\n}\n\nstatic int hwi_init_controller(struct beiscsi_hba *phba)\n{\n\tstruct hwi_controller *phwi_ctrlr;\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tif (1 == phba->init_mem[HWI_MEM_ADDN_CONTEXT].num_elements) {\n\t\tphwi_ctrlr->phwi_ctxt = (struct hwi_context_memory *)phba->\n\t\t    init_mem[HWI_MEM_ADDN_CONTEXT].mem_array[0].virtual_address;\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d :  phwi_ctrlr->phwi_ctxt=%p\\n\",\n\t\t\t    phwi_ctrlr->phwi_ctxt);\n\t} else {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : HWI_MEM_ADDN_CONTEXT is more \"\n\t\t\t    \"than one element.Failing to load\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tiscsi_init_global_templates(phba);\n\tif (beiscsi_init_wrb_handle(phba))\n\t\treturn -ENOMEM;\n\n\tif (hwi_init_async_pdu_ctx(phba)) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : hwi_init_async_pdu_ctx failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (hwi_init_port(phba) != 0) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : hwi_init_controller failed\\n\");\n\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void beiscsi_free_mem(struct beiscsi_hba *phba)\n{\n\tstruct be_mem_descriptor *mem_descr;\n\tint i, j;\n\n\tmem_descr = phba->init_mem;\n\tfor (i = 0; i < SE_MEM_MAX; i++) {\n\t\tfor (j = mem_descr->num_elements; j > 0; j--) {\n\t\t\tdma_free_coherent(&phba->pcidev->dev,\n\t\t\t  mem_descr->mem_array[j - 1].size,\n\t\t\t  mem_descr->mem_array[j - 1].virtual_address,\n\t\t\t  (unsigned long)mem_descr->mem_array[j - 1].\n\t\t\t  bus_address.u.a64.address);\n\t\t}\n\n\t\tkfree(mem_descr->mem_array);\n\t\tmem_descr++;\n\t}\n\tkfree(phba->init_mem);\n\tkfree(phba->phwi_ctrlr->wrb_context);\n\tkfree(phba->phwi_ctrlr);\n}\n\nstatic int beiscsi_init_sgl_handle(struct beiscsi_hba *phba)\n{\n\tstruct be_mem_descriptor *mem_descr_sglh, *mem_descr_sg;\n\tstruct sgl_handle *psgl_handle;\n\tstruct iscsi_sge *pfrag;\n\tunsigned int arr_index, i, idx;\n\tunsigned int ulp_icd_start, ulp_num = 0;\n\n\tphba->io_sgl_hndl_avbl = 0;\n\tphba->eh_sgl_hndl_avbl = 0;\n\n\tmem_descr_sglh = phba->init_mem;\n\tmem_descr_sglh += HWI_MEM_SGLH;\n\tif (1 == mem_descr_sglh->num_elements) {\n\t\tphba->io_sgl_hndl_base = kcalloc(phba->params.ios_per_ctrl,\n\t\t\t\t\t\t sizeof(struct sgl_handle *),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!phba->io_sgl_hndl_base) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BM_%d : Mem Alloc Failed. Failing to load\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tphba->eh_sgl_hndl_base =\n\t\t\tkcalloc(phba->params.icds_per_ctrl -\n\t\t\t\t\tphba->params.ios_per_ctrl,\n\t\t\t\tsizeof(struct sgl_handle *), GFP_KERNEL);\n\t\tif (!phba->eh_sgl_hndl_base) {\n\t\t\tkfree(phba->io_sgl_hndl_base);\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BM_%d : Mem Alloc Failed. Failing to load\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : HWI_MEM_SGLH is more than one element.\"\n\t\t\t    \"Failing to load\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tarr_index = 0;\n\tidx = 0;\n\twhile (idx < mem_descr_sglh->num_elements) {\n\t\tpsgl_handle = mem_descr_sglh->mem_array[idx].virtual_address;\n\n\t\tfor (i = 0; i < (mem_descr_sglh->mem_array[idx].size /\n\t\t      sizeof(struct sgl_handle)); i++) {\n\t\t\tif (arr_index < phba->params.ios_per_ctrl) {\n\t\t\t\tphba->io_sgl_hndl_base[arr_index] = psgl_handle;\n\t\t\t\tphba->io_sgl_hndl_avbl++;\n\t\t\t\tarr_index++;\n\t\t\t} else {\n\t\t\t\tphba->eh_sgl_hndl_base[arr_index -\n\t\t\t\t\tphba->params.ios_per_ctrl] =\n\t\t\t\t\t\t\t\tpsgl_handle;\n\t\t\t\tarr_index++;\n\t\t\t\tphba->eh_sgl_hndl_avbl++;\n\t\t\t}\n\t\t\tpsgl_handle++;\n\t\t}\n\t\tidx++;\n\t}\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t    \"BM_%d : phba->io_sgl_hndl_avbl=%d \"\n\t\t    \"phba->eh_sgl_hndl_avbl=%d\\n\",\n\t\t    phba->io_sgl_hndl_avbl,\n\t\t    phba->eh_sgl_hndl_avbl);\n\n\tmem_descr_sg = phba->init_mem;\n\tmem_descr_sg += HWI_MEM_SGE;\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t    \"\\n BM_%d : mem_descr_sg->num_elements=%d\\n\",\n\t\t    mem_descr_sg->num_elements);\n\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++)\n\t\tif (test_bit(ulp_num, &phba->fw_config.ulp_supported))\n\t\t\tbreak;\n\n\tulp_icd_start = phba->fw_config.iscsi_icd_start[ulp_num];\n\n\tarr_index = 0;\n\tidx = 0;\n\twhile (idx < mem_descr_sg->num_elements) {\n\t\tpfrag = mem_descr_sg->mem_array[idx].virtual_address;\n\n\t\tfor (i = 0;\n\t\t     i < (mem_descr_sg->mem_array[idx].size) /\n\t\t     (sizeof(struct iscsi_sge) * phba->params.num_sge_per_io);\n\t\t     i++) {\n\t\t\tif (arr_index < phba->params.ios_per_ctrl)\n\t\t\t\tpsgl_handle = phba->io_sgl_hndl_base[arr_index];\n\t\t\telse\n\t\t\t\tpsgl_handle = phba->eh_sgl_hndl_base[arr_index -\n\t\t\t\t\t\tphba->params.ios_per_ctrl];\n\t\t\tpsgl_handle->pfrag = pfrag;\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_hi, pfrag, 0);\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_sge, addr_lo, pfrag, 0);\n\t\t\tpfrag += phba->params.num_sge_per_io;\n\t\t\tpsgl_handle->sgl_index = ulp_icd_start + arr_index++;\n\t\t}\n\t\tidx++;\n\t}\n\tphba->io_sgl_free_index = 0;\n\tphba->io_sgl_alloc_index = 0;\n\tphba->eh_sgl_free_index = 0;\n\tphba->eh_sgl_alloc_index = 0;\n\treturn 0;\n}\n\nstatic int hba_setup_cid_tbls(struct beiscsi_hba *phba)\n{\n\tint ret;\n\tuint16_t i, ulp_num;\n\tstruct ulp_cid_info *ptr_cid_info = NULL;\n\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\n\t\tif (test_bit(ulp_num, (void *)&phba->fw_config.ulp_supported)) {\n\t\t\tptr_cid_info = kzalloc(sizeof(struct ulp_cid_info),\n\t\t\t\t\t       GFP_KERNEL);\n\n\t\t\tif (!ptr_cid_info) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_memory;\n\t\t\t}\n\n\t\t\t \n\t\t\tptr_cid_info->cid_array =\n\t\t\t\tkcalloc(BEISCSI_GET_CID_COUNT(phba, ulp_num),\n\t\t\t\t\tsizeof(*ptr_cid_info->cid_array),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!ptr_cid_info->cid_array) {\n\t\t\t\tkfree(ptr_cid_info);\n\t\t\t\tptr_cid_info = NULL;\n\t\t\t\tret = -ENOMEM;\n\n\t\t\t\tgoto free_memory;\n\t\t\t}\n\t\t\tptr_cid_info->avlbl_cids = BEISCSI_GET_CID_COUNT(\n\t\t\t\t\t\t   phba, ulp_num);\n\n\t\t\t \n\t\t\tphba->cid_array_info[ulp_num] = ptr_cid_info;\n\t\t}\n\t}\n\tphba->ep_array = kcalloc(phba->params.cxns_per_ctrl,\n\t\t\t\t sizeof(struct iscsi_endpoint *),\n\t\t\t\t GFP_KERNEL);\n\tif (!phba->ep_array) {\n\t\tret = -ENOMEM;\n\n\t\tgoto free_memory;\n\t}\n\n\tphba->conn_table = kcalloc(phba->params.cxns_per_ctrl,\n\t\t\t\t   sizeof(struct beiscsi_conn *),\n\t\t\t\t   GFP_KERNEL);\n\tif (!phba->conn_table) {\n\t\tkfree(phba->ep_array);\n\t\tphba->ep_array = NULL;\n\t\tret = -ENOMEM;\n\n\t\tgoto free_memory;\n\t}\n\n\tfor (i = 0; i < phba->params.cxns_per_ctrl; i++) {\n\t\tulp_num = phba->phwi_ctrlr->wrb_context[i].ulp_num;\n\n\t\tptr_cid_info = phba->cid_array_info[ulp_num];\n\t\tptr_cid_info->cid_array[ptr_cid_info->cid_alloc++] =\n\t\t\tphba->phwi_ctrlr->wrb_context[i].cid;\n\n\t}\n\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\n\t\tif (test_bit(ulp_num, (void *)&phba->fw_config.ulp_supported)) {\n\t\t\tptr_cid_info = phba->cid_array_info[ulp_num];\n\n\t\t\tptr_cid_info->cid_alloc = 0;\n\t\t\tptr_cid_info->cid_free = 0;\n\t\t}\n\t}\n\treturn 0;\n\nfree_memory:\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\n\t\tif (test_bit(ulp_num, (void *)&phba->fw_config.ulp_supported)) {\n\t\t\tptr_cid_info = phba->cid_array_info[ulp_num];\n\n\t\t\tif (ptr_cid_info) {\n\t\t\t\tkfree(ptr_cid_info->cid_array);\n\t\t\t\tkfree(ptr_cid_info);\n\t\t\t\tphba->cid_array_info[ulp_num] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void hwi_enable_intr(struct beiscsi_hba *phba)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct hwi_context_memory *phwi_context;\n\tstruct be_queue_info *eq;\n\tu8 __iomem *addr;\n\tu32 reg, i;\n\tu32 enabled;\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tphwi_context = phwi_ctrlr->phwi_ctxt;\n\n\taddr = (u8 __iomem *) ((u8 __iomem *) ctrl->pcicfg +\n\t\t\tPCICFG_MEMBAR_CTRL_INT_CTRL_OFFSET);\n\treg = ioread32(addr);\n\n\tenabled = reg & MEMBAR_CTRL_INT_CTRL_HOSTINTR_MASK;\n\tif (!enabled) {\n\t\treg |= MEMBAR_CTRL_INT_CTRL_HOSTINTR_MASK;\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : reg =x%08x addr=%p\\n\", reg, addr);\n\t\tiowrite32(reg, addr);\n\t}\n\n\tif (!phba->pcidev->msix_enabled) {\n\t\teq = &phwi_context->be_eq[0].q;\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : eq->id=%d\\n\", eq->id);\n\n\t\thwi_ring_eq_db(phba, eq->id, 0, 0, 1, 1);\n\t} else {\n\t\tfor (i = 0; i <= phba->num_cpus; i++) {\n\t\t\teq = &phwi_context->be_eq[i].q;\n\t\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BM_%d : eq->id=%d\\n\", eq->id);\n\t\t\thwi_ring_eq_db(phba, eq->id, 0, 0, 1, 1);\n\t\t}\n\t}\n}\n\nstatic void hwi_disable_intr(struct beiscsi_hba *phba)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\n\tu8 __iomem *addr = ctrl->pcicfg + PCICFG_MEMBAR_CTRL_INT_CTRL_OFFSET;\n\tu32 reg = ioread32(addr);\n\n\tu32 enabled = reg & MEMBAR_CTRL_INT_CTRL_HOSTINTR_MASK;\n\tif (enabled) {\n\t\treg &= ~MEMBAR_CTRL_INT_CTRL_HOSTINTR_MASK;\n\t\tiowrite32(reg, addr);\n\t} else\n\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : In hwi_disable_intr, Already Disabled\\n\");\n}\n\nstatic int beiscsi_init_port(struct beiscsi_hba *phba)\n{\n\tint ret;\n\n\tret = hwi_init_controller(phba);\n\tif (ret < 0) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : init controller failed\\n\");\n\t\treturn ret;\n\t}\n\tret = beiscsi_init_sgl_handle(phba);\n\tif (ret < 0) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : init sgl handles failed\\n\");\n\t\tgoto cleanup_port;\n\t}\n\n\tret = hba_setup_cid_tbls(phba);\n\tif (ret < 0) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : setup CID table failed\\n\");\n\t\tkfree(phba->io_sgl_hndl_base);\n\t\tkfree(phba->eh_sgl_hndl_base);\n\t\tgoto cleanup_port;\n\t}\n\treturn ret;\n\ncleanup_port:\n\thwi_cleanup_port(phba);\n\treturn ret;\n}\n\nstatic void beiscsi_cleanup_port(struct beiscsi_hba *phba)\n{\n\tstruct ulp_cid_info *ptr_cid_info = NULL;\n\tint ulp_num;\n\n\tkfree(phba->io_sgl_hndl_base);\n\tkfree(phba->eh_sgl_hndl_base);\n\tkfree(phba->ep_array);\n\tkfree(phba->conn_table);\n\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\n\t\tif (test_bit(ulp_num, (void *)&phba->fw_config.ulp_supported)) {\n\t\t\tptr_cid_info = phba->cid_array_info[ulp_num];\n\n\t\t\tif (ptr_cid_info) {\n\t\t\t\tkfree(ptr_cid_info->cid_array);\n\t\t\t\tkfree(ptr_cid_info);\n\t\t\t\tphba->cid_array_info[ulp_num] = NULL;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid\nbeiscsi_free_mgmt_task_handles(struct beiscsi_conn *beiscsi_conn,\n\t\t\t\tstruct iscsi_task *task)\n{\n\tstruct beiscsi_io_task *io_task;\n\tstruct beiscsi_hba *phba = beiscsi_conn->phba;\n\tstruct hwi_wrb_context *pwrb_context;\n\tstruct hwi_controller *phwi_ctrlr;\n\tuint16_t cri_index = BE_GET_CRI_FROM_CID(\n\t\t\t\tbeiscsi_conn->beiscsi_conn_cid);\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tpwrb_context = &phwi_ctrlr->wrb_context[cri_index];\n\n\tio_task = task->dd_data;\n\n\tif (io_task->pwrb_handle) {\n\t\tfree_wrb_handle(phba, pwrb_context, io_task->pwrb_handle);\n\t\tio_task->pwrb_handle = NULL;\n\t}\n\n\tif (io_task->psgl_handle) {\n\t\tfree_mgmt_sgl_handle(phba, io_task->psgl_handle);\n\t\tio_task->psgl_handle = NULL;\n\t}\n\n\tif (io_task->mtask_addr) {\n\t\tdma_unmap_single(&phba->pcidev->dev,\n\t\t\t\t io_task->mtask_addr,\n\t\t\t\t io_task->mtask_data_count,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tio_task->mtask_addr = 0;\n\t}\n}\n\n \nstatic void beiscsi_cleanup_task(struct iscsi_task *task)\n{\n\tstruct beiscsi_io_task *io_task = task->dd_data;\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct beiscsi_conn *beiscsi_conn = conn->dd_data;\n\tstruct beiscsi_hba *phba = beiscsi_conn->phba;\n\tstruct beiscsi_session *beiscsi_sess = beiscsi_conn->beiscsi_sess;\n\tstruct hwi_wrb_context *pwrb_context;\n\tstruct hwi_controller *phwi_ctrlr;\n\tuint16_t cri_index = BE_GET_CRI_FROM_CID(\n\t\t\t     beiscsi_conn->beiscsi_conn_cid);\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tpwrb_context = &phwi_ctrlr->wrb_context[cri_index];\n\n\tif (io_task->cmd_bhs) {\n\t\tdma_pool_free(beiscsi_sess->bhs_pool, io_task->cmd_bhs,\n\t\t\t      io_task->bhs_pa.u.a64.address);\n\t\tio_task->cmd_bhs = NULL;\n\t\ttask->hdr = NULL;\n\t}\n\n\tif (task->sc) {\n\t\tif (io_task->pwrb_handle) {\n\t\t\tfree_wrb_handle(phba, pwrb_context,\n\t\t\t\t\tio_task->pwrb_handle);\n\t\t\tio_task->pwrb_handle = NULL;\n\t\t}\n\n\t\tif (io_task->psgl_handle) {\n\t\t\tfree_io_sgl_handle(phba, io_task->psgl_handle);\n\t\t\tio_task->psgl_handle = NULL;\n\t\t}\n\n\t\tif (io_task->scsi_cmnd) {\n\t\t\tif (io_task->num_sg)\n\t\t\t\tscsi_dma_unmap(io_task->scsi_cmnd);\n\t\t\tio_task->scsi_cmnd = NULL;\n\t\t}\n\t} else {\n\t\tif (!beiscsi_conn->login_in_progress)\n\t\t\tbeiscsi_free_mgmt_task_handles(beiscsi_conn, task);\n\t}\n}\n\nvoid\nbeiscsi_offload_connection(struct beiscsi_conn *beiscsi_conn,\n\t\t\t   struct beiscsi_offload_params *params)\n{\n\tstruct wrb_handle *pwrb_handle;\n\tstruct hwi_wrb_context *pwrb_context = NULL;\n\tstruct beiscsi_hba *phba = beiscsi_conn->phba;\n\tstruct iscsi_task *task = beiscsi_conn->task;\n\tstruct iscsi_session *session = task->conn->session;\n\tu32 doorbell = 0;\n\n\t \n\tbeiscsi_conn->login_in_progress = 0;\n\tspin_lock_bh(&session->back_lock);\n\tbeiscsi_cleanup_task(task);\n\tspin_unlock_bh(&session->back_lock);\n\n\tpwrb_handle = alloc_wrb_handle(phba, beiscsi_conn->beiscsi_conn_cid,\n\t\t\t\t       &pwrb_context);\n\n\t \n\tif (is_chip_be2_be3r(phba))\n\t\tbeiscsi_offload_cxn_v0(params, pwrb_handle,\n\t\t\t\t       phba->init_mem,\n\t\t\t\t       pwrb_context);\n\telse\n\t\tbeiscsi_offload_cxn_v2(params, pwrb_handle,\n\t\t\t\t       pwrb_context);\n\n\tbe_dws_le_to_cpu(pwrb_handle->pwrb,\n\t\t\t sizeof(struct iscsi_target_context_update_wrb));\n\n\tdoorbell |= beiscsi_conn->beiscsi_conn_cid & DB_WRB_POST_CID_MASK;\n\tdoorbell |= (pwrb_handle->wrb_index & DB_DEF_PDU_WRB_INDEX_MASK)\n\t\t\t     << DB_DEF_PDU_WRB_INDEX_SHIFT;\n\tdoorbell |= 1 << DB_DEF_PDU_NUM_POSTED_SHIFT;\n\tiowrite32(doorbell, phba->db_va +\n\t\t  beiscsi_conn->doorbell_offset);\n\n\t \n\tbeiscsi_put_wrb_handle(pwrb_context, pwrb_handle,\n\t\t\t       phba->params.wrbs_per_cxn);\n\tbeiscsi_log(phba, KERN_INFO,\n\t\t    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,\n\t\t    \"BM_%d : put CONTEXT_UPDATE pwrb_handle=%p free_index=0x%x wrb_handles_available=%d\\n\",\n\t\t    pwrb_handle, pwrb_context->free_index,\n\t\t    pwrb_context->wrb_handles_available);\n}\n\nstatic void beiscsi_parse_pdu(struct iscsi_conn *conn, itt_t itt,\n\t\t\t      int *index, int *age)\n{\n\t*index = (int)itt;\n\tif (age)\n\t\t*age = conn->session->age;\n}\n\n \nstatic int beiscsi_alloc_pdu(struct iscsi_task *task, uint8_t opcode)\n{\n\tstruct beiscsi_io_task *io_task = task->dd_data;\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct beiscsi_conn *beiscsi_conn = conn->dd_data;\n\tstruct beiscsi_hba *phba = beiscsi_conn->phba;\n\tstruct hwi_wrb_context *pwrb_context;\n\tstruct hwi_controller *phwi_ctrlr;\n\titt_t itt;\n\tuint16_t cri_index = 0;\n\tstruct beiscsi_session *beiscsi_sess = beiscsi_conn->beiscsi_sess;\n\tdma_addr_t paddr;\n\n\tio_task->cmd_bhs = dma_pool_alloc(beiscsi_sess->bhs_pool,\n\t\t\t\t\t  GFP_ATOMIC, &paddr);\n\tif (!io_task->cmd_bhs)\n\t\treturn -ENOMEM;\n\tio_task->bhs_pa.u.a64.address = paddr;\n\tio_task->libiscsi_itt = (itt_t)task->itt;\n\tio_task->conn = beiscsi_conn;\n\n\ttask->hdr = (struct iscsi_hdr *)&io_task->cmd_bhs->iscsi_hdr;\n\ttask->hdr_max = sizeof(struct be_cmd_bhs);\n\tio_task->psgl_handle = NULL;\n\tio_task->pwrb_handle = NULL;\n\n\tif (task->sc) {\n\t\tio_task->psgl_handle = alloc_io_sgl_handle(phba);\n\t\tif (!io_task->psgl_handle) {\n\t\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t\t    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BM_%d : Alloc of IO_SGL_ICD Failed \"\n\t\t\t\t    \"for the CID : %d\\n\",\n\t\t\t\t    beiscsi_conn->beiscsi_conn_cid);\n\t\t\tgoto free_hndls;\n\t\t}\n\t\tio_task->pwrb_handle = alloc_wrb_handle(phba,\n\t\t\t\t\tbeiscsi_conn->beiscsi_conn_cid,\n\t\t\t\t\t&io_task->pwrb_context);\n\t\tif (!io_task->pwrb_handle) {\n\t\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t\t    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BM_%d : Alloc of WRB_HANDLE Failed \"\n\t\t\t\t    \"for the CID : %d\\n\",\n\t\t\t\t    beiscsi_conn->beiscsi_conn_cid);\n\t\t\tgoto free_io_hndls;\n\t\t}\n\t} else {\n\t\tio_task->scsi_cmnd = NULL;\n\t\tif ((opcode & ISCSI_OPCODE_MASK) == ISCSI_OP_LOGIN) {\n\t\t\tbeiscsi_conn->task = task;\n\t\t\tif (!beiscsi_conn->login_in_progress) {\n\t\t\t\tio_task->psgl_handle = (struct sgl_handle *)\n\t\t\t\t\t\talloc_mgmt_sgl_handle(phba);\n\t\t\t\tif (!io_task->psgl_handle) {\n\t\t\t\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t\t\t\t    BEISCSI_LOG_IO |\n\t\t\t\t\t\t    BEISCSI_LOG_CONFIG,\n\t\t\t\t\t\t    \"BM_%d : Alloc of MGMT_SGL_ICD Failed \"\n\t\t\t\t\t\t    \"for the CID : %d\\n\",\n\t\t\t\t\t\t    beiscsi_conn->beiscsi_conn_cid);\n\t\t\t\t\tgoto free_hndls;\n\t\t\t\t}\n\n\t\t\t\tbeiscsi_conn->login_in_progress = 1;\n\t\t\t\tbeiscsi_conn->plogin_sgl_handle =\n\t\t\t\t\t\t\tio_task->psgl_handle;\n\t\t\t\tio_task->pwrb_handle =\n\t\t\t\t\talloc_wrb_handle(phba,\n\t\t\t\t\tbeiscsi_conn->beiscsi_conn_cid,\n\t\t\t\t\t&io_task->pwrb_context);\n\t\t\t\tif (!io_task->pwrb_handle) {\n\t\t\t\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t\t\t\t    BEISCSI_LOG_IO |\n\t\t\t\t\t\t    BEISCSI_LOG_CONFIG,\n\t\t\t\t\t\t    \"BM_%d : Alloc of WRB_HANDLE Failed \"\n\t\t\t\t\t\t    \"for the CID : %d\\n\",\n\t\t\t\t\t\t    beiscsi_conn->beiscsi_conn_cid);\n\t\t\t\t\tgoto free_mgmt_hndls;\n\t\t\t\t}\n\t\t\t\tbeiscsi_conn->plogin_wrb_handle =\n\t\t\t\t\t\t\tio_task->pwrb_handle;\n\n\t\t\t} else {\n\t\t\t\tio_task->psgl_handle =\n\t\t\t\t\t\tbeiscsi_conn->plogin_sgl_handle;\n\t\t\t\tio_task->pwrb_handle =\n\t\t\t\t\t\tbeiscsi_conn->plogin_wrb_handle;\n\t\t\t}\n\t\t} else {\n\t\t\tio_task->psgl_handle = alloc_mgmt_sgl_handle(phba);\n\t\t\tif (!io_task->psgl_handle) {\n\t\t\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t\t\t    BEISCSI_LOG_IO |\n\t\t\t\t\t    BEISCSI_LOG_CONFIG,\n\t\t\t\t\t    \"BM_%d : Alloc of MGMT_SGL_ICD Failed \"\n\t\t\t\t\t    \"for the CID : %d\\n\",\n\t\t\t\t\t    beiscsi_conn->beiscsi_conn_cid);\n\t\t\t\tgoto free_hndls;\n\t\t\t}\n\t\t\tio_task->pwrb_handle =\n\t\t\t\t\talloc_wrb_handle(phba,\n\t\t\t\t\tbeiscsi_conn->beiscsi_conn_cid,\n\t\t\t\t\t&io_task->pwrb_context);\n\t\t\tif (!io_task->pwrb_handle) {\n\t\t\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t\t\t    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,\n\t\t\t\t\t    \"BM_%d : Alloc of WRB_HANDLE Failed \"\n\t\t\t\t\t    \"for the CID : %d\\n\",\n\t\t\t\t\t    beiscsi_conn->beiscsi_conn_cid);\n\t\t\t\tgoto free_mgmt_hndls;\n\t\t\t}\n\n\t\t}\n\t}\n\titt = (itt_t) cpu_to_be32(((unsigned int)io_task->pwrb_handle->\n\t\t\t\t wrb_index << 16) | (unsigned int)\n\t\t\t\t(io_task->psgl_handle->sgl_index));\n\tio_task->pwrb_handle->pio_handle = task;\n\n\tio_task->cmd_bhs->iscsi_hdr.itt = itt;\n\treturn 0;\n\nfree_io_hndls:\n\tfree_io_sgl_handle(phba, io_task->psgl_handle);\n\tgoto free_hndls;\nfree_mgmt_hndls:\n\tfree_mgmt_sgl_handle(phba, io_task->psgl_handle);\n\tio_task->psgl_handle = NULL;\nfree_hndls:\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tcri_index = BE_GET_CRI_FROM_CID(\n\tbeiscsi_conn->beiscsi_conn_cid);\n\tpwrb_context = &phwi_ctrlr->wrb_context[cri_index];\n\tif (io_task->pwrb_handle)\n\t\tfree_wrb_handle(phba, pwrb_context, io_task->pwrb_handle);\n\tio_task->pwrb_handle = NULL;\n\tdma_pool_free(beiscsi_sess->bhs_pool, io_task->cmd_bhs,\n\t\t      io_task->bhs_pa.u.a64.address);\n\tio_task->cmd_bhs = NULL;\n\treturn -ENOMEM;\n}\nstatic int beiscsi_iotask_v2(struct iscsi_task *task, struct scatterlist *sg,\n\t\t       unsigned int num_sg, unsigned int xferlen,\n\t\t       unsigned int writedir)\n{\n\n\tstruct beiscsi_io_task *io_task = task->dd_data;\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct beiscsi_conn *beiscsi_conn = conn->dd_data;\n\tstruct beiscsi_hba *phba = beiscsi_conn->phba;\n\tstruct iscsi_wrb *pwrb = NULL;\n\tunsigned int doorbell = 0;\n\n\tpwrb = io_task->pwrb_handle->pwrb;\n\n\tio_task->bhs_len = sizeof(struct be_cmd_bhs);\n\n\tif (writedir) {\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, type, pwrb,\n\t\t\t      INI_WR_CMD);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, dsp, pwrb, 1);\n\t} else {\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, type, pwrb,\n\t\t\t      INI_RD_CMD);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, dsp, pwrb, 0);\n\t}\n\n\tio_task->wrb_type = AMAP_GET_BITS(struct amap_iscsi_wrb_v2,\n\t\t\t\t\t  type, pwrb);\n\n\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, lun, pwrb,\n\t\t      cpu_to_be16(*(unsigned short *)\n\t\t      &io_task->cmd_bhs->iscsi_hdr.lun));\n\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, r2t_exp_dtl, pwrb, xferlen);\n\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, wrb_idx, pwrb,\n\t\t      io_task->pwrb_handle->wrb_index);\n\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, cmdsn_itt, pwrb,\n\t\t      be32_to_cpu(task->cmdsn));\n\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, sgl_idx, pwrb,\n\t\t      io_task->psgl_handle->sgl_index);\n\n\thwi_write_sgl_v2(pwrb, sg, num_sg, io_task);\n\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, ptr2nextwrb, pwrb,\n\t\t      io_task->pwrb_handle->wrb_index);\n\tif (io_task->pwrb_context->plast_wrb)\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, ptr2nextwrb,\n\t\t\t      io_task->pwrb_context->plast_wrb,\n\t\t\t      io_task->pwrb_handle->wrb_index);\n\tio_task->pwrb_context->plast_wrb = pwrb;\n\n\tbe_dws_le_to_cpu(pwrb, sizeof(struct iscsi_wrb));\n\n\tdoorbell |= beiscsi_conn->beiscsi_conn_cid & DB_WRB_POST_CID_MASK;\n\tdoorbell |= (io_task->pwrb_handle->wrb_index &\n\t\t     DB_DEF_PDU_WRB_INDEX_MASK) <<\n\t\t     DB_DEF_PDU_WRB_INDEX_SHIFT;\n\tdoorbell |= 1 << DB_DEF_PDU_NUM_POSTED_SHIFT;\n\tiowrite32(doorbell, phba->db_va +\n\t\t  beiscsi_conn->doorbell_offset);\n\treturn 0;\n}\n\nstatic int beiscsi_iotask(struct iscsi_task *task, struct scatterlist *sg,\n\t\t\t  unsigned int num_sg, unsigned int xferlen,\n\t\t\t  unsigned int writedir)\n{\n\n\tstruct beiscsi_io_task *io_task = task->dd_data;\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct beiscsi_conn *beiscsi_conn = conn->dd_data;\n\tstruct beiscsi_hba *phba = beiscsi_conn->phba;\n\tstruct iscsi_wrb *pwrb = NULL;\n\tunsigned int doorbell = 0;\n\n\tpwrb = io_task->pwrb_handle->pwrb;\n\tio_task->bhs_len = sizeof(struct be_cmd_bhs);\n\n\tif (writedir) {\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, type, pwrb,\n\t\t\t      INI_WR_CMD);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, dsp, pwrb, 1);\n\t} else {\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, type, pwrb,\n\t\t\t      INI_RD_CMD);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, dsp, pwrb, 0);\n\t}\n\n\tio_task->wrb_type = AMAP_GET_BITS(struct amap_iscsi_wrb,\n\t\t\t\t\t  type, pwrb);\n\n\tAMAP_SET_BITS(struct amap_iscsi_wrb, lun, pwrb,\n\t\t      cpu_to_be16(*(unsigned short *)\n\t\t\t\t  &io_task->cmd_bhs->iscsi_hdr.lun));\n\tAMAP_SET_BITS(struct amap_iscsi_wrb, r2t_exp_dtl, pwrb, xferlen);\n\tAMAP_SET_BITS(struct amap_iscsi_wrb, wrb_idx, pwrb,\n\t\t      io_task->pwrb_handle->wrb_index);\n\tAMAP_SET_BITS(struct amap_iscsi_wrb, cmdsn_itt, pwrb,\n\t\t      be32_to_cpu(task->cmdsn));\n\tAMAP_SET_BITS(struct amap_iscsi_wrb, sgl_icd_idx, pwrb,\n\t\t      io_task->psgl_handle->sgl_index);\n\n\thwi_write_sgl(pwrb, sg, num_sg, io_task);\n\n\tAMAP_SET_BITS(struct amap_iscsi_wrb, ptr2nextwrb, pwrb,\n\t\t      io_task->pwrb_handle->wrb_index);\n\tif (io_task->pwrb_context->plast_wrb)\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, ptr2nextwrb,\n\t\t\t      io_task->pwrb_context->plast_wrb,\n\t\t\t      io_task->pwrb_handle->wrb_index);\n\tio_task->pwrb_context->plast_wrb = pwrb;\n\n\tbe_dws_le_to_cpu(pwrb, sizeof(struct iscsi_wrb));\n\n\tdoorbell |= beiscsi_conn->beiscsi_conn_cid & DB_WRB_POST_CID_MASK;\n\tdoorbell |= (io_task->pwrb_handle->wrb_index &\n\t\t     DB_DEF_PDU_WRB_INDEX_MASK) << DB_DEF_PDU_WRB_INDEX_SHIFT;\n\tdoorbell |= 1 << DB_DEF_PDU_NUM_POSTED_SHIFT;\n\n\tiowrite32(doorbell, phba->db_va +\n\t\t  beiscsi_conn->doorbell_offset);\n\treturn 0;\n}\n\nstatic int beiscsi_mtask(struct iscsi_task *task)\n{\n\tstruct beiscsi_io_task *io_task = task->dd_data;\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct beiscsi_conn *beiscsi_conn = conn->dd_data;\n\tstruct beiscsi_hba *phba = beiscsi_conn->phba;\n\tstruct iscsi_wrb *pwrb = NULL;\n\tunsigned int doorbell = 0;\n\tunsigned int cid;\n\tunsigned int pwrb_typeoffset = 0;\n\tint ret = 0;\n\n\tcid = beiscsi_conn->beiscsi_conn_cid;\n\tpwrb = io_task->pwrb_handle->pwrb;\n\n\tif (is_chip_be2_be3r(phba)) {\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, cmdsn_itt, pwrb,\n\t\t\t      be32_to_cpu(task->cmdsn));\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, wrb_idx, pwrb,\n\t\t\t      io_task->pwrb_handle->wrb_index);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, sgl_icd_idx, pwrb,\n\t\t\t      io_task->psgl_handle->sgl_index);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, r2t_exp_dtl, pwrb,\n\t\t\t      task->data_count);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, ptr2nextwrb, pwrb,\n\t\t\t      io_task->pwrb_handle->wrb_index);\n\t\tif (io_task->pwrb_context->plast_wrb)\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, ptr2nextwrb,\n\t\t\t\t      io_task->pwrb_context->plast_wrb,\n\t\t\t\t      io_task->pwrb_handle->wrb_index);\n\t\tio_task->pwrb_context->plast_wrb = pwrb;\n\n\t\tpwrb_typeoffset = BE_WRB_TYPE_OFFSET;\n\t} else {\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, cmdsn_itt, pwrb,\n\t\t\t      be32_to_cpu(task->cmdsn));\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, wrb_idx, pwrb,\n\t\t\t      io_task->pwrb_handle->wrb_index);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, sgl_idx, pwrb,\n\t\t\t      io_task->psgl_handle->sgl_index);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, r2t_exp_dtl, pwrb,\n\t\t\t      task->data_count);\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, ptr2nextwrb, pwrb,\n\t\t\t      io_task->pwrb_handle->wrb_index);\n\t\tif (io_task->pwrb_context->plast_wrb)\n\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2, ptr2nextwrb,\n\t\t\t\t      io_task->pwrb_context->plast_wrb,\n\t\t\t\t      io_task->pwrb_handle->wrb_index);\n\t\tio_task->pwrb_context->plast_wrb = pwrb;\n\n\t\tpwrb_typeoffset = SKH_WRB_TYPE_OFFSET;\n\t}\n\n\n\tswitch (task->hdr->opcode & ISCSI_OPCODE_MASK) {\n\tcase ISCSI_OP_LOGIN:\n\t\tAMAP_SET_BITS(struct amap_iscsi_wrb, cmdsn_itt, pwrb, 1);\n\t\tADAPTER_SET_WRB_TYPE(pwrb, TGT_DM_CMD, pwrb_typeoffset);\n\t\tret = hwi_write_buffer(pwrb, task);\n\t\tbreak;\n\tcase ISCSI_OP_NOOP_OUT:\n\t\tif (task->hdr->ttt != ISCSI_RESERVED_TAG) {\n\t\t\tADAPTER_SET_WRB_TYPE(pwrb, TGT_DM_CMD, pwrb_typeoffset);\n\t\t\tif (is_chip_be2_be3r(phba))\n\t\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb,\n\t\t\t\t\t      dmsg, pwrb, 1);\n\t\t\telse\n\t\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2,\n\t\t\t\t\t      dmsg, pwrb, 1);\n\t\t} else {\n\t\t\tADAPTER_SET_WRB_TYPE(pwrb, INI_RD_CMD, pwrb_typeoffset);\n\t\t\tif (is_chip_be2_be3r(phba))\n\t\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb,\n\t\t\t\t\t      dmsg, pwrb, 0);\n\t\t\telse\n\t\t\t\tAMAP_SET_BITS(struct amap_iscsi_wrb_v2,\n\t\t\t\t\t      dmsg, pwrb, 0);\n\t\t}\n\t\tret = hwi_write_buffer(pwrb, task);\n\t\tbreak;\n\tcase ISCSI_OP_TEXT:\n\t\tADAPTER_SET_WRB_TYPE(pwrb, TGT_DM_CMD, pwrb_typeoffset);\n\t\tret = hwi_write_buffer(pwrb, task);\n\t\tbreak;\n\tcase ISCSI_OP_SCSI_TMFUNC:\n\t\tADAPTER_SET_WRB_TYPE(pwrb, INI_TMF_CMD, pwrb_typeoffset);\n\t\tret = hwi_write_buffer(pwrb, task);\n\t\tbreak;\n\tcase ISCSI_OP_LOGOUT:\n\t\tADAPTER_SET_WRB_TYPE(pwrb, HWH_TYPE_LOGOUT, pwrb_typeoffset);\n\t\tret = hwi_write_buffer(pwrb, task);\n\t\tbreak;\n\n\tdefault:\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BM_%d : opcode =%d Not supported\\n\",\n\t\t\t    task->hdr->opcode & ISCSI_OPCODE_MASK);\n\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tio_task->wrb_type = (is_chip_be2_be3r(phba)) ?\n\t\tAMAP_GET_BITS(struct amap_iscsi_wrb, type, pwrb) :\n\t\tAMAP_GET_BITS(struct amap_iscsi_wrb_v2, type, pwrb);\n\n\tdoorbell |= cid & DB_WRB_POST_CID_MASK;\n\tdoorbell |= (io_task->pwrb_handle->wrb_index &\n\t\t     DB_DEF_PDU_WRB_INDEX_MASK) << DB_DEF_PDU_WRB_INDEX_SHIFT;\n\tdoorbell |= 1 << DB_DEF_PDU_NUM_POSTED_SHIFT;\n\tiowrite32(doorbell, phba->db_va +\n\t\t  beiscsi_conn->doorbell_offset);\n\treturn 0;\n}\n\nstatic int beiscsi_task_xmit(struct iscsi_task *task)\n{\n\tstruct beiscsi_io_task *io_task = task->dd_data;\n\tstruct scsi_cmnd *sc = task->sc;\n\tstruct beiscsi_hba *phba;\n\tstruct scatterlist *sg;\n\tint num_sg;\n\tunsigned int  writedir = 0, xferlen = 0;\n\n\tphba = io_task->conn->phba;\n\t \n\tif (!beiscsi_hba_is_online(phba))\n\t\treturn -EIO;\n\n\tif (!io_task->conn->login_in_progress)\n\t\ttask->hdr->exp_statsn = 0;\n\n\tif (!sc)\n\t\treturn beiscsi_mtask(task);\n\n\tio_task->scsi_cmnd = sc;\n\tio_task->num_sg = 0;\n\tnum_sg = scsi_dma_map(sc);\n\tif (num_sg < 0) {\n\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t    BEISCSI_LOG_IO | BEISCSI_LOG_ISCSI,\n\t\t\t    \"BM_%d : scsi_dma_map Failed \"\n\t\t\t    \"Driver_ITT : 0x%x ITT : 0x%x Xferlen : 0x%x\\n\",\n\t\t\t    be32_to_cpu(io_task->cmd_bhs->iscsi_hdr.itt),\n\t\t\t    io_task->libiscsi_itt, scsi_bufflen(sc));\n\n\t\treturn num_sg;\n\t}\n\t \n\tio_task->num_sg = num_sg;\n\txferlen = scsi_bufflen(sc);\n\tsg = scsi_sglist(sc);\n\tif (sc->sc_data_direction == DMA_TO_DEVICE)\n\t\twritedir = 1;\n\telse\n\t\twritedir = 0;\n\n\treturn phba->iotask_fn(task, sg, num_sg, xferlen, writedir);\n}\n\n \nstatic int beiscsi_bsg_request(struct bsg_job *job)\n{\n\tstruct Scsi_Host *shost;\n\tstruct beiscsi_hba *phba;\n\tstruct iscsi_bsg_request *bsg_req = job->request;\n\tint rc = -EINVAL;\n\tunsigned int tag;\n\tstruct be_dma_mem nonemb_cmd;\n\tstruct be_cmd_resp_hdr *resp;\n\tstruct iscsi_bsg_reply *bsg_reply = job->reply;\n\tunsigned short status, extd_status;\n\n\tshost = iscsi_job_to_shost(job);\n\tphba = iscsi_host_priv(shost);\n\n\tif (!beiscsi_hba_is_online(phba)) {\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BM_%d : HBA in error 0x%lx\\n\", phba->state);\n\t\treturn -ENXIO;\n\t}\n\n\tswitch (bsg_req->msgcode) {\n\tcase ISCSI_BSG_HST_VENDOR:\n\t\tnonemb_cmd.va = dma_alloc_coherent(&phba->ctrl.pdev->dev,\n\t\t\t\t\tjob->request_payload.payload_len,\n\t\t\t\t\t&nonemb_cmd.dma, GFP_KERNEL);\n\t\tif (nonemb_cmd.va == NULL) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BM_%d : Failed to allocate memory for \"\n\t\t\t\t    \"beiscsi_bsg_request\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\ttag = mgmt_vendor_specific_fw_cmd(&phba->ctrl, phba, job,\n\t\t\t\t\t\t  &nonemb_cmd);\n\t\tif (!tag) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BM_%d : MBX Tag Allocation Failed\\n\");\n\n\t\t\tdma_free_coherent(&phba->ctrl.pdev->dev, nonemb_cmd.size,\n\t\t\t\t\t    nonemb_cmd.va, nonemb_cmd.dma);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\trc = wait_event_interruptible_timeout(\n\t\t\t\t\tphba->ctrl.mcc_wait[tag],\n\t\t\t\t\tphba->ctrl.mcc_tag_status[tag],\n\t\t\t\t\tmsecs_to_jiffies(\n\t\t\t\t\tBEISCSI_HOST_MBX_TIMEOUT));\n\n\t\tif (!test_bit(BEISCSI_HBA_ONLINE, &phba->state)) {\n\t\t\tclear_bit(MCC_TAG_STATE_RUNNING,\n\t\t\t\t  &phba->ctrl.ptag_state[tag].tag_state);\n\t\t\tdma_free_coherent(&phba->ctrl.pdev->dev, nonemb_cmd.size,\n\t\t\t\t\t    nonemb_cmd.va, nonemb_cmd.dma);\n\t\t\treturn -EIO;\n\t\t}\n\t\textd_status = (phba->ctrl.mcc_tag_status[tag] &\n\t\t\t       CQE_STATUS_ADDL_MASK) >> CQE_STATUS_ADDL_SHIFT;\n\t\tstatus = phba->ctrl.mcc_tag_status[tag] & CQE_STATUS_MASK;\n\t\tfree_mcc_wrb(&phba->ctrl, tag);\n\t\tresp = (struct be_cmd_resp_hdr *)nonemb_cmd.va;\n\t\tsg_copy_from_buffer(job->reply_payload.sg_list,\n\t\t\t\t    job->reply_payload.sg_cnt,\n\t\t\t\t    nonemb_cmd.va, (resp->response_length\n\t\t\t\t    + sizeof(*resp)));\n\t\tbsg_reply->reply_payload_rcv_len = resp->response_length;\n\t\tbsg_reply->result = status;\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t     bsg_reply->reply_payload_rcv_len);\n\t\tdma_free_coherent(&phba->ctrl.pdev->dev, nonemb_cmd.size,\n\t\t\t\t    nonemb_cmd.va, nonemb_cmd.dma);\n\t\tif (status || extd_status) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BM_%d : MBX Cmd Failed\"\n\t\t\t\t    \" status = %d extd_status = %d\\n\",\n\t\t\t\t    status, extd_status);\n\n\t\t\treturn -EIO;\n\t\t} else {\n\t\t\trc = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t\t\"BM_%d : Unsupported bsg command: 0x%x\\n\",\n\t\t\t\tbsg_req->msgcode);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic void beiscsi_hba_attrs_init(struct beiscsi_hba *phba)\n{\n\t \n\tbeiscsi_log_enable_init(phba, beiscsi_log_enable);\n}\n\nvoid beiscsi_start_boot_work(struct beiscsi_hba *phba, unsigned int s_handle)\n{\n\tif (phba->boot_struct.boot_kset)\n\t\treturn;\n\n\t \n\tif (test_and_set_bit(BEISCSI_HBA_BOOT_WORK, &phba->state))\n\t\treturn;\n\n\tphba->boot_struct.retry = 3;\n\tphba->boot_struct.tag = 0;\n\tphba->boot_struct.s_handle = s_handle;\n\tphba->boot_struct.action = BEISCSI_BOOT_GET_SHANDLE;\n\tschedule_work(&phba->boot_work);\n}\n\n#define BEISCSI_SYSFS_ISCSI_BOOT_FLAGS\t3\n \nstatic ssize_t beiscsi_show_boot_tgt_info(void *data, int type, char *buf)\n{\n\tstruct beiscsi_hba *phba = data;\n\tstruct mgmt_session_info *boot_sess = &phba->boot_struct.boot_sess;\n\tstruct mgmt_conn_info *boot_conn = &boot_sess->conn_list[0];\n\tchar *str = buf;\n\tint rc = -EPERM;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_TGT_NAME:\n\t\trc = sprintf(buf, \"%.*s\\n\",\n\t\t\t    (int)strlen(boot_sess->target_name),\n\t\t\t    (char *)&boot_sess->target_name);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_IP_ADDR:\n\t\tif (boot_conn->dest_ipaddr.ip_type == BEISCSI_IP_TYPE_V4)\n\t\t\trc = sprintf(buf, \"%pI4\\n\",\n\t\t\t\t(char *)&boot_conn->dest_ipaddr.addr);\n\t\telse\n\t\t\trc = sprintf(str, \"%pI6\\n\",\n\t\t\t\t(char *)&boot_conn->dest_ipaddr.addr);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_PORT:\n\t\trc = sprintf(str, \"%d\\n\", boot_conn->dest_port);\n\t\tbreak;\n\n\tcase ISCSI_BOOT_TGT_CHAP_NAME:\n\t\trc = sprintf(str,  \"%.*s\\n\",\n\t\t\t     boot_conn->negotiated_login_options.auth_data.chap.\n\t\t\t     target_chap_name_length,\n\t\t\t     (char *)&boot_conn->negotiated_login_options.\n\t\t\t     auth_data.chap.target_chap_name);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_CHAP_SECRET:\n\t\trc = sprintf(str,  \"%.*s\\n\",\n\t\t\t     boot_conn->negotiated_login_options.auth_data.chap.\n\t\t\t     target_secret_length,\n\t\t\t     (char *)&boot_conn->negotiated_login_options.\n\t\t\t     auth_data.chap.target_secret);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_REV_CHAP_NAME:\n\t\trc = sprintf(str,  \"%.*s\\n\",\n\t\t\t     boot_conn->negotiated_login_options.auth_data.chap.\n\t\t\t     intr_chap_name_length,\n\t\t\t     (char *)&boot_conn->negotiated_login_options.\n\t\t\t     auth_data.chap.intr_chap_name);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_REV_CHAP_SECRET:\n\t\trc = sprintf(str,  \"%.*s\\n\",\n\t\t\t     boot_conn->negotiated_login_options.auth_data.chap.\n\t\t\t     intr_secret_length,\n\t\t\t     (char *)&boot_conn->negotiated_login_options.\n\t\t\t     auth_data.chap.intr_secret);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_FLAGS:\n\t\trc = sprintf(str, \"%d\\n\", BEISCSI_SYSFS_ISCSI_BOOT_FLAGS);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_NIC_ASSOC:\n\t\trc = sprintf(str, \"0\\n\");\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic ssize_t beiscsi_show_boot_ini_info(void *data, int type, char *buf)\n{\n\tstruct beiscsi_hba *phba = data;\n\tchar *str = buf;\n\tint rc = -EPERM;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_INI_INITIATOR_NAME:\n\t\trc = sprintf(str, \"%s\\n\",\n\t\t\t     phba->boot_struct.boot_sess.initiator_iscsiname);\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic ssize_t beiscsi_show_boot_eth_info(void *data, int type, char *buf)\n{\n\tstruct beiscsi_hba *phba = data;\n\tchar *str = buf;\n\tint rc = -EPERM;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_ETH_FLAGS:\n\t\trc = sprintf(str, \"%d\\n\", BEISCSI_SYSFS_ISCSI_BOOT_FLAGS);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_INDEX:\n\t\trc = sprintf(str, \"0\\n\");\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_MAC:\n\t\trc  = beiscsi_get_macaddr(str, phba);\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic umode_t beiscsi_tgt_get_attr_visibility(void *data, int type)\n{\n\tumode_t rc = 0;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_TGT_NAME:\n\tcase ISCSI_BOOT_TGT_IP_ADDR:\n\tcase ISCSI_BOOT_TGT_PORT:\n\tcase ISCSI_BOOT_TGT_CHAP_NAME:\n\tcase ISCSI_BOOT_TGT_CHAP_SECRET:\n\tcase ISCSI_BOOT_TGT_REV_CHAP_NAME:\n\tcase ISCSI_BOOT_TGT_REV_CHAP_SECRET:\n\tcase ISCSI_BOOT_TGT_NIC_ASSOC:\n\tcase ISCSI_BOOT_TGT_FLAGS:\n\t\trc = S_IRUGO;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic umode_t beiscsi_ini_get_attr_visibility(void *data, int type)\n{\n\tumode_t rc = 0;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_INI_INITIATOR_NAME:\n\t\trc = S_IRUGO;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic umode_t beiscsi_eth_get_attr_visibility(void *data, int type)\n{\n\tumode_t rc = 0;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_ETH_FLAGS:\n\tcase ISCSI_BOOT_ETH_MAC:\n\tcase ISCSI_BOOT_ETH_INDEX:\n\t\trc = S_IRUGO;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic void beiscsi_boot_kobj_release(void *data)\n{\n\tstruct beiscsi_hba *phba = data;\n\n\tscsi_host_put(phba->shost);\n}\n\nstatic int beiscsi_boot_create_kset(struct beiscsi_hba *phba)\n{\n\tstruct boot_struct *bs = &phba->boot_struct;\n\tstruct iscsi_boot_kobj *boot_kobj;\n\n\tif (bs->boot_kset) {\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BM_%d: boot_kset already created\\n\");\n\t\treturn 0;\n\t}\n\n\tbs->boot_kset = iscsi_boot_create_host_kset(phba->shost->host_no);\n\tif (!bs->boot_kset) {\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BM_%d: boot_kset alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (!scsi_host_get(phba->shost))\n\t\tgoto free_kset;\n\n\tboot_kobj = iscsi_boot_create_target(bs->boot_kset, 0, phba,\n\t\t\t\t\t     beiscsi_show_boot_tgt_info,\n\t\t\t\t\t     beiscsi_tgt_get_attr_visibility,\n\t\t\t\t\t     beiscsi_boot_kobj_release);\n\tif (!boot_kobj)\n\t\tgoto put_shost;\n\n\tif (!scsi_host_get(phba->shost))\n\t\tgoto free_kset;\n\n\tboot_kobj = iscsi_boot_create_initiator(bs->boot_kset, 0, phba,\n\t\t\t\t\t\tbeiscsi_show_boot_ini_info,\n\t\t\t\t\t\tbeiscsi_ini_get_attr_visibility,\n\t\t\t\t\t\tbeiscsi_boot_kobj_release);\n\tif (!boot_kobj)\n\t\tgoto put_shost;\n\n\tif (!scsi_host_get(phba->shost))\n\t\tgoto free_kset;\n\n\tboot_kobj = iscsi_boot_create_ethernet(bs->boot_kset, 0, phba,\n\t\t\t\t\t       beiscsi_show_boot_eth_info,\n\t\t\t\t\t       beiscsi_eth_get_attr_visibility,\n\t\t\t\t\t       beiscsi_boot_kobj_release);\n\tif (!boot_kobj)\n\t\tgoto put_shost;\n\n\treturn 0;\n\nput_shost:\n\tscsi_host_put(phba->shost);\nfree_kset:\n\tiscsi_boot_destroy_kset(bs->boot_kset);\n\tbs->boot_kset = NULL;\n\treturn -ENOMEM;\n}\n\nstatic void beiscsi_boot_work(struct work_struct *work)\n{\n\tstruct beiscsi_hba *phba =\n\t\tcontainer_of(work, struct beiscsi_hba, boot_work);\n\tstruct boot_struct *bs = &phba->boot_struct;\n\tunsigned int tag = 0;\n\n\tif (!beiscsi_hba_is_online(phba))\n\t\treturn;\n\n\tbeiscsi_log(phba, KERN_INFO,\n\t\t    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\n\t\t    \"BM_%d : %s action %d\\n\",\n\t\t    __func__, phba->boot_struct.action);\n\n\tswitch (phba->boot_struct.action) {\n\tcase BEISCSI_BOOT_REOPEN_SESS:\n\t\ttag = beiscsi_boot_reopen_sess(phba);\n\t\tbreak;\n\tcase BEISCSI_BOOT_GET_SHANDLE:\n\t\ttag = __beiscsi_boot_get_shandle(phba, 1);\n\t\tbreak;\n\tcase BEISCSI_BOOT_GET_SINFO:\n\t\ttag = beiscsi_boot_get_sinfo(phba);\n\t\tbreak;\n\tcase BEISCSI_BOOT_LOGOUT_SESS:\n\t\ttag = beiscsi_boot_logout_sess(phba);\n\t\tbreak;\n\tcase BEISCSI_BOOT_CREATE_KSET:\n\t\tbeiscsi_boot_create_kset(phba);\n\t\t \n\t\tmb();\n\t\tclear_bit(BEISCSI_HBA_BOOT_WORK, &phba->state);\n\t\treturn;\n\t}\n\tif (!tag) {\n\t\tif (bs->retry--)\n\t\t\tschedule_work(&phba->boot_work);\n\t\telse\n\t\t\tclear_bit(BEISCSI_HBA_BOOT_WORK, &phba->state);\n\t}\n}\n\nstatic void beiscsi_eqd_update_work(struct work_struct *work)\n{\n\tstruct hwi_context_memory *phwi_context;\n\tstruct be_set_eqd set_eqd[MAX_CPUS];\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct be_eq_obj *pbe_eq;\n\tstruct beiscsi_hba *phba;\n\tunsigned int pps, delta;\n\tstruct be_aic_obj *aic;\n\tint eqd, i, num = 0;\n\tunsigned long now;\n\n\tphba = container_of(work, struct beiscsi_hba, eqd_update.work);\n\tif (!beiscsi_hba_is_online(phba))\n\t\treturn;\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tphwi_context = phwi_ctrlr->phwi_ctxt;\n\n\tfor (i = 0; i <= phba->num_cpus; i++) {\n\t\taic = &phba->aic_obj[i];\n\t\tpbe_eq = &phwi_context->be_eq[i];\n\t\tnow = jiffies;\n\t\tif (!aic->jiffies || time_before(now, aic->jiffies) ||\n\t\t    pbe_eq->cq_count < aic->eq_prev) {\n\t\t\taic->jiffies = now;\n\t\t\taic->eq_prev = pbe_eq->cq_count;\n\t\t\tcontinue;\n\t\t}\n\t\tdelta = jiffies_to_msecs(now - aic->jiffies);\n\t\tpps = (((u32)(pbe_eq->cq_count - aic->eq_prev) * 1000) / delta);\n\t\teqd = (pps / 1500) << 2;\n\n\t\tif (eqd < 8)\n\t\t\teqd = 0;\n\t\teqd = min_t(u32, eqd, BEISCSI_EQ_DELAY_MAX);\n\t\teqd = max_t(u32, eqd, BEISCSI_EQ_DELAY_MIN);\n\n\t\taic->jiffies = now;\n\t\taic->eq_prev = pbe_eq->cq_count;\n\n\t\tif (eqd != aic->prev_eqd) {\n\t\t\tset_eqd[num].delay_multiplier = (eqd * 65)/100;\n\t\t\tset_eqd[num].eq_id = pbe_eq->q.id;\n\t\t\taic->prev_eqd = eqd;\n\t\t\tnum++;\n\t\t}\n\t}\n\tif (num)\n\t\t \n\t\tbeiscsi_modify_eq_delay(phba, set_eqd, num);\n\n\tschedule_delayed_work(&phba->eqd_update,\n\t\t\t      msecs_to_jiffies(BEISCSI_EQD_UPDATE_INTERVAL));\n}\n\nstatic void beiscsi_hw_tpe_check(struct timer_list *t)\n{\n\tstruct beiscsi_hba *phba = from_timer(phba, t, hw_check);\n\tu32 wait;\n\n\t \n\tif (!beiscsi_detect_tpe(phba))\n\t\treturn;\n\n\t \n\twait = 4000;\n\tif (phba->ue2rp > BEISCSI_UE_DETECT_INTERVAL)\n\t\twait = phba->ue2rp - BEISCSI_UE_DETECT_INTERVAL;\n\tqueue_delayed_work(phba->wq, &phba->recover_port,\n\t\t\t   msecs_to_jiffies(wait));\n}\n\nstatic void beiscsi_hw_health_check(struct timer_list *t)\n{\n\tstruct beiscsi_hba *phba = from_timer(phba, t, hw_check);\n\n\tbeiscsi_detect_ue(phba);\n\tif (beiscsi_detect_ue(phba)) {\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BM_%d : port in error: %lx\\n\", phba->state);\n\t\t \n\t\tqueue_work(phba->wq, &phba->sess_work);\n\n\t\t \n\t\tif (!test_bit(BEISCSI_HBA_UER_SUPP, &phba->state))\n\t\t\treturn;\n\t\t \n\t\tphba->hw_check.function = beiscsi_hw_tpe_check;\n\t}\n\n\tmod_timer(&phba->hw_check,\n\t\t  jiffies + msecs_to_jiffies(BEISCSI_UE_DETECT_INTERVAL));\n}\n\n \nstatic int beiscsi_enable_port(struct beiscsi_hba *phba)\n{\n\tstruct hwi_context_memory *phwi_context;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct be_eq_obj *pbe_eq;\n\tint ret, i;\n\n\tif (test_bit(BEISCSI_HBA_ONLINE, &phba->state)) {\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BM_%d : %s : port is online %lx\\n\",\n\t\t\t      __func__, phba->state);\n\t\treturn 0;\n\t}\n\n\tret = beiscsi_init_sliport(phba);\n\tif (ret)\n\t\treturn ret;\n\n\tbe2iscsi_enable_msix(phba);\n\n\tbeiscsi_get_params(phba);\n\tbeiscsi_set_host_data(phba);\n\t \n\tbeiscsi_set_uer_feature(phba);\n\n\tphba->shost->max_id = phba->params.cxns_per_ctrl - 1;\n\tphba->shost->can_queue = phba->params.ios_per_ctrl;\n\tret = beiscsi_init_port(phba);\n\tif (ret < 0) {\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BM_%d : init port failed\\n\");\n\t\tgoto disable_msix;\n\t}\n\n\tfor (i = 0; i < MAX_MCC_CMD; i++) {\n\t\tinit_waitqueue_head(&phba->ctrl.mcc_wait[i + 1]);\n\t\tphba->ctrl.mcc_tag[i] = i + 1;\n\t\tphba->ctrl.mcc_tag_status[i + 1] = 0;\n\t\tphba->ctrl.mcc_tag_available++;\n\t}\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tphwi_context = phwi_ctrlr->phwi_ctxt;\n\tfor (i = 0; i < phba->num_cpus; i++) {\n\t\tpbe_eq = &phwi_context->be_eq[i];\n\t\tirq_poll_init(&pbe_eq->iopoll, be_iopoll_budget, be_iopoll);\n\t}\n\n\ti = (phba->pcidev->msix_enabled) ? i : 0;\n\t \n\tpbe_eq = &phwi_context->be_eq[i];\n\tINIT_WORK(&pbe_eq->mcc_work, beiscsi_mcc_work);\n\n\tret = beiscsi_init_irqs(phba);\n\tif (ret < 0) {\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BM_%d : setup IRQs failed %d\\n\", ret);\n\t\tgoto cleanup_port;\n\t}\n\thwi_enable_intr(phba);\n\t \n\tset_bit(BEISCSI_HBA_ONLINE, &phba->state);\n\t__beiscsi_log(phba, KERN_INFO,\n\t\t      \"BM_%d : port online: 0x%lx\\n\", phba->state);\n\n\t \n\tschedule_delayed_work(&phba->eqd_update,\n\t\t\t      msecs_to_jiffies(BEISCSI_EQD_UPDATE_INTERVAL));\n\n\t \n\tphba->hw_check.function = beiscsi_hw_health_check;\n\tmod_timer(&phba->hw_check,\n\t\t  jiffies + msecs_to_jiffies(BEISCSI_UE_DETECT_INTERVAL));\n\treturn 0;\n\ncleanup_port:\n\tfor (i = 0; i < phba->num_cpus; i++) {\n\t\tpbe_eq = &phwi_context->be_eq[i];\n\t\tirq_poll_disable(&pbe_eq->iopoll);\n\t}\n\thwi_cleanup_port(phba);\n\ndisable_msix:\n\tpci_free_irq_vectors(phba->pcidev);\n\treturn ret;\n}\n\n \nstatic void beiscsi_disable_port(struct beiscsi_hba *phba, int unload)\n{\n\tstruct hwi_context_memory *phwi_context;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct be_eq_obj *pbe_eq;\n\tunsigned int i;\n\n\tif (!test_and_clear_bit(BEISCSI_HBA_ONLINE, &phba->state))\n\t\treturn;\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tphwi_context = phwi_ctrlr->phwi_ctxt;\n\thwi_disable_intr(phba);\n\tbeiscsi_free_irqs(phba);\n\tpci_free_irq_vectors(phba->pcidev);\n\n\tfor (i = 0; i < phba->num_cpus; i++) {\n\t\tpbe_eq = &phwi_context->be_eq[i];\n\t\tirq_poll_disable(&pbe_eq->iopoll);\n\t}\n\tcancel_delayed_work_sync(&phba->eqd_update);\n\tcancel_work_sync(&phba->boot_work);\n\t \n\tif (!unload && beiscsi_hba_in_error(phba)) {\n\t\tpbe_eq = &phwi_context->be_eq[i];\n\t\tcancel_work_sync(&pbe_eq->mcc_work);\n\t}\n\thwi_cleanup_port(phba);\n\tbeiscsi_cleanup_port(phba);\n}\n\nstatic void beiscsi_sess_work(struct work_struct *work)\n{\n\tstruct beiscsi_hba *phba;\n\n\tphba = container_of(work, struct beiscsi_hba, sess_work);\n\t \n\tiscsi_host_for_each_session(phba->shost, beiscsi_session_fail);\n}\n\nstatic void beiscsi_recover_port(struct work_struct *work)\n{\n\tstruct beiscsi_hba *phba;\n\n\tphba = container_of(work, struct beiscsi_hba, recover_port.work);\n\tbeiscsi_disable_port(phba, 0);\n\tbeiscsi_enable_port(phba);\n}\n\nstatic pci_ers_result_t beiscsi_eeh_err_detected(struct pci_dev *pdev,\n\t\tpci_channel_state_t state)\n{\n\tstruct beiscsi_hba *phba = NULL;\n\n\tphba = (struct beiscsi_hba *)pci_get_drvdata(pdev);\n\tset_bit(BEISCSI_HBA_PCI_ERR, &phba->state);\n\n\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t    \"BM_%d : EEH error detected\\n\");\n\n\t \n\tdel_timer_sync(&phba->hw_check);\n\tcancel_delayed_work_sync(&phba->recover_port);\n\n\t \n\tiscsi_host_for_each_session(phba->shost, beiscsi_session_fail);\n\tbeiscsi_disable_port(phba, 0);\n\n\tif (state == pci_channel_io_perm_failure) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : EEH : State PERM Failure\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\tpci_disable_device(pdev);\n\n\t \n\tif (pdev->devfn == 0)\n\t\tssleep(30);\n\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\nstatic pci_ers_result_t beiscsi_eeh_reset(struct pci_dev *pdev)\n{\n\tstruct beiscsi_hba *phba = NULL;\n\tint status = 0;\n\n\tphba = (struct beiscsi_hba *)pci_get_drvdata(pdev);\n\n\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t    \"BM_%d : EEH Reset\\n\");\n\n\tstatus = pci_enable_device(pdev);\n\tif (status)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tpci_set_master(pdev);\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\n\tstatus = beiscsi_check_fw_rdy(phba);\n\tif (status) {\n\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : EEH Reset Completed\\n\");\n\t} else {\n\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : EEH Reset Completion Failure\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic void beiscsi_eeh_resume(struct pci_dev *pdev)\n{\n\tstruct beiscsi_hba *phba;\n\tint ret;\n\n\tphba = (struct beiscsi_hba *)pci_get_drvdata(pdev);\n\tpci_save_state(pdev);\n\n\tret = beiscsi_enable_port(phba);\n\tif (ret)\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BM_%d : AER EEH resume failed\\n\");\n}\n\nstatic int beiscsi_dev_probe(struct pci_dev *pcidev,\n\t\t\t     const struct pci_device_id *id)\n{\n\tstruct hwi_context_memory *phwi_context;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct beiscsi_hba *phba = NULL;\n\tstruct be_eq_obj *pbe_eq;\n\tunsigned int s_handle;\n\tchar wq_name[20];\n\tint ret, i;\n\n\tret = beiscsi_enable_pci(pcidev);\n\tif (ret < 0) {\n\t\tdev_err(&pcidev->dev,\n\t\t\t\"beiscsi_dev_probe - Failed to enable pci device\\n\");\n\t\treturn ret;\n\t}\n\n\tphba = beiscsi_hba_alloc(pcidev);\n\tif (!phba) {\n\t\tdev_err(&pcidev->dev,\n\t\t\t\"beiscsi_dev_probe - Failed in beiscsi_hba_alloc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto disable_pci;\n\t}\n\n\tpci_save_state(pcidev);\n\n\t \n\tbeiscsi_hba_attrs_init(phba);\n\n\tphba->mac_addr_set = false;\n\n\tswitch (pcidev->device) {\n\tcase BE_DEVICE_ID1:\n\tcase OC_DEVICE_ID1:\n\tcase OC_DEVICE_ID2:\n\t\tphba->generation = BE_GEN2;\n\t\tphba->iotask_fn = beiscsi_iotask;\n\t\tdev_warn(&pcidev->dev,\n\t\t\t \"Obsolete/Unsupported BE2 Adapter Family\\n\");\n\t\tbreak;\n\tcase BE_DEVICE_ID2:\n\tcase OC_DEVICE_ID3:\n\t\tphba->generation = BE_GEN3;\n\t\tphba->iotask_fn = beiscsi_iotask;\n\t\tbreak;\n\tcase OC_SKH_ID1:\n\t\tphba->generation = BE_GEN4;\n\t\tphba->iotask_fn = beiscsi_iotask_v2;\n\t\tbreak;\n\tdefault:\n\t\tphba->generation = 0;\n\t}\n\n\tret = be_ctrl_init(phba, pcidev);\n\tif (ret) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : be_ctrl_init failed\\n\");\n\t\tgoto free_hba;\n\t}\n\n\tret = beiscsi_init_sliport(phba);\n\tif (ret)\n\t\tgoto free_hba;\n\n\tspin_lock_init(&phba->io_sgl_lock);\n\tspin_lock_init(&phba->mgmt_sgl_lock);\n\tspin_lock_init(&phba->async_pdu_lock);\n\tret = beiscsi_get_fw_config(&phba->ctrl, phba);\n\tif (ret != 0) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : Error getting fw config\\n\");\n\t\tgoto free_port;\n\t}\n\tbeiscsi_get_port_name(&phba->ctrl, phba);\n\tbeiscsi_get_params(phba);\n\tbeiscsi_set_host_data(phba);\n\tbeiscsi_set_uer_feature(phba);\n\n\tbe2iscsi_enable_msix(phba);\n\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t    \"BM_%d : num_cpus = %d\\n\",\n\t\t    phba->num_cpus);\n\n\tphba->shost->max_id = phba->params.cxns_per_ctrl;\n\tphba->shost->can_queue = phba->params.ios_per_ctrl;\n\tret = beiscsi_get_memory(phba);\n\tif (ret < 0) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : alloc host mem failed\\n\");\n\t\tgoto free_port;\n\t}\n\n\tret = beiscsi_init_port(phba);\n\tif (ret < 0) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : init port failed\\n\");\n\t\tbeiscsi_free_mem(phba);\n\t\tgoto free_port;\n\t}\n\n\tfor (i = 0; i < MAX_MCC_CMD; i++) {\n\t\tinit_waitqueue_head(&phba->ctrl.mcc_wait[i + 1]);\n\t\tphba->ctrl.mcc_tag[i] = i + 1;\n\t\tphba->ctrl.mcc_tag_status[i + 1] = 0;\n\t\tphba->ctrl.mcc_tag_available++;\n\t\tmemset(&phba->ctrl.ptag_state[i].tag_mem_state, 0,\n\t\t       sizeof(struct be_dma_mem));\n\t}\n\n\tphba->ctrl.mcc_alloc_index = phba->ctrl.mcc_free_index = 0;\n\n\tsnprintf(wq_name, sizeof(wq_name), \"beiscsi_%02x_wq\",\n\t\t phba->shost->host_no);\n\tphba->wq = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 1, wq_name);\n\tif (!phba->wq) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : beiscsi_dev_probe-\"\n\t\t\t    \"Failed to allocate work queue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_twq;\n\t}\n\n\tINIT_DELAYED_WORK(&phba->eqd_update, beiscsi_eqd_update_work);\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tphwi_context = phwi_ctrlr->phwi_ctxt;\n\n\tfor (i = 0; i < phba->num_cpus; i++) {\n\t\tpbe_eq = &phwi_context->be_eq[i];\n\t\tirq_poll_init(&pbe_eq->iopoll, be_iopoll_budget, be_iopoll);\n\t}\n\n\ti = (phba->pcidev->msix_enabled) ? i : 0;\n\t \n\tpbe_eq = &phwi_context->be_eq[i];\n\tINIT_WORK(&pbe_eq->mcc_work, beiscsi_mcc_work);\n\n\tret = beiscsi_init_irqs(phba);\n\tif (ret < 0) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : beiscsi_dev_probe-\"\n\t\t\t    \"Failed to beiscsi_init_irqs\\n\");\n\t\tgoto disable_iopoll;\n\t}\n\thwi_enable_intr(phba);\n\n\tret = iscsi_host_add(phba->shost, &phba->pcidev->dev);\n\tif (ret)\n\t\tgoto free_irqs;\n\n\t \n\tset_bit(BEISCSI_HBA_ONLINE, &phba->state);\n\t__beiscsi_log(phba, KERN_INFO,\n\t\t      \"BM_%d : port online: 0x%lx\\n\", phba->state);\n\n\tINIT_WORK(&phba->boot_work, beiscsi_boot_work);\n\tret = beiscsi_boot_get_shandle(phba, &s_handle);\n\tif (ret > 0) {\n\t\tbeiscsi_start_boot_work(phba, s_handle);\n\t\t \n\t\tset_bit(BEISCSI_HBA_BOOT_FOUND, &phba->state);\n\t}\n\n\tbeiscsi_iface_create_default(phba);\n\tschedule_delayed_work(&phba->eqd_update,\n\t\t\t      msecs_to_jiffies(BEISCSI_EQD_UPDATE_INTERVAL));\n\n\tINIT_WORK(&phba->sess_work, beiscsi_sess_work);\n\tINIT_DELAYED_WORK(&phba->recover_port, beiscsi_recover_port);\n\t \n\ttimer_setup(&phba->hw_check, beiscsi_hw_health_check, 0);\n\tmod_timer(&phba->hw_check,\n\t\t  jiffies + msecs_to_jiffies(BEISCSI_UE_DETECT_INTERVAL));\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t    \"\\n\\n\\n BM_%d : SUCCESS - DRIVER LOADED\\n\\n\\n\");\n\treturn 0;\n\nfree_irqs:\n\thwi_disable_intr(phba);\n\tbeiscsi_free_irqs(phba);\ndisable_iopoll:\n\tfor (i = 0; i < phba->num_cpus; i++) {\n\t\tpbe_eq = &phwi_context->be_eq[i];\n\t\tirq_poll_disable(&pbe_eq->iopoll);\n\t}\n\tdestroy_workqueue(phba->wq);\nfree_twq:\n\thwi_cleanup_port(phba);\n\tbeiscsi_cleanup_port(phba);\n\tbeiscsi_free_mem(phba);\nfree_port:\n\tdma_free_coherent(&phba->pcidev->dev,\n\t\t\t    phba->ctrl.mbox_mem_alloced.size,\n\t\t\t    phba->ctrl.mbox_mem_alloced.va,\n\t\t\t    phba->ctrl.mbox_mem_alloced.dma);\n\tbeiscsi_unmap_pci_function(phba);\nfree_hba:\n\tpci_disable_msix(phba->pcidev);\n\tpci_dev_put(phba->pcidev);\n\tiscsi_host_free(phba->shost);\n\tpci_set_drvdata(pcidev, NULL);\ndisable_pci:\n\tpci_release_regions(pcidev);\n\tpci_disable_device(pcidev);\n\treturn ret;\n}\n\nstatic void beiscsi_remove(struct pci_dev *pcidev)\n{\n\tstruct beiscsi_hba *phba = NULL;\n\n\tphba = pci_get_drvdata(pcidev);\n\tif (!phba) {\n\t\tdev_err(&pcidev->dev, \"beiscsi_remove called with no phba\\n\");\n\t\treturn;\n\t}\n\n\t \n\tdel_timer_sync(&phba->hw_check);\n\tcancel_delayed_work_sync(&phba->recover_port);\n\tcancel_work_sync(&phba->sess_work);\n\n\tbeiscsi_iface_destroy_default(phba);\n\tiscsi_host_remove(phba->shost, false);\n\tbeiscsi_disable_port(phba, 1);\n\n\t \n\tiscsi_boot_destroy_kset(phba->boot_struct.boot_kset);\n\n\t \n\tdestroy_workqueue(phba->wq);\n\tbeiscsi_free_mem(phba);\n\n\t \n\tbeiscsi_unmap_pci_function(phba);\n\tdma_free_coherent(&phba->pcidev->dev,\n\t\t\t    phba->ctrl.mbox_mem_alloced.size,\n\t\t\t    phba->ctrl.mbox_mem_alloced.va,\n\t\t\t    phba->ctrl.mbox_mem_alloced.dma);\n\n\tpci_dev_put(phba->pcidev);\n\tiscsi_host_free(phba->shost);\n\tpci_set_drvdata(pcidev, NULL);\n\tpci_release_regions(pcidev);\n\tpci_disable_device(pcidev);\n}\n\n\nstatic struct pci_error_handlers beiscsi_eeh_handlers = {\n\t.error_detected = beiscsi_eeh_err_detected,\n\t.slot_reset = beiscsi_eeh_reset,\n\t.resume = beiscsi_eeh_resume,\n};\n\nstruct iscsi_transport beiscsi_iscsi_transport = {\n\t.owner = THIS_MODULE,\n\t.name = DRV_NAME,\n\t.caps = CAP_RECOVERY_L0 | CAP_HDRDGST | CAP_TEXT_NEGO |\n\t\tCAP_MULTI_R2T | CAP_DATADGST | CAP_DATA_PATH_OFFLOAD,\n\t.create_session = beiscsi_session_create,\n\t.destroy_session = beiscsi_session_destroy,\n\t.create_conn = beiscsi_conn_create,\n\t.bind_conn = beiscsi_conn_bind,\n\t.unbind_conn = iscsi_conn_unbind,\n\t.destroy_conn = iscsi_conn_teardown,\n\t.attr_is_visible = beiscsi_attr_is_visible,\n\t.set_iface_param = beiscsi_iface_set_param,\n\t.get_iface_param = beiscsi_iface_get_param,\n\t.set_param = beiscsi_set_param,\n\t.get_conn_param = iscsi_conn_get_param,\n\t.get_session_param = iscsi_session_get_param,\n\t.get_host_param = beiscsi_get_host_param,\n\t.start_conn = beiscsi_conn_start,\n\t.stop_conn = iscsi_conn_stop,\n\t.send_pdu = iscsi_conn_send_pdu,\n\t.xmit_task = beiscsi_task_xmit,\n\t.cleanup_task = beiscsi_cleanup_task,\n\t.alloc_pdu = beiscsi_alloc_pdu,\n\t.parse_pdu_itt = beiscsi_parse_pdu,\n\t.get_stats = beiscsi_conn_get_stats,\n\t.get_ep_param = beiscsi_ep_get_param,\n\t.ep_connect = beiscsi_ep_connect,\n\t.ep_poll = beiscsi_ep_poll,\n\t.ep_disconnect = beiscsi_ep_disconnect,\n\t.session_recovery_timedout = iscsi_session_recovery_timedout,\n\t.bsg_request = beiscsi_bsg_request,\n};\n\nstatic struct pci_driver beiscsi_pci_driver = {\n\t.name = DRV_NAME,\n\t.probe = beiscsi_dev_probe,\n\t.remove = beiscsi_remove,\n\t.id_table = beiscsi_pci_id_table,\n\t.err_handler = &beiscsi_eeh_handlers\n};\n\nstatic int __init beiscsi_module_init(void)\n{\n\tint ret;\n\n\tbeiscsi_scsi_transport =\n\t\t\tiscsi_register_transport(&beiscsi_iscsi_transport);\n\tif (!beiscsi_scsi_transport) {\n\t\tprintk(KERN_ERR\n\t\t       \"beiscsi_module_init - Unable to  register beiscsi transport.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tprintk(KERN_INFO \"In beiscsi_module_init, tt=%p\\n\",\n\t       &beiscsi_iscsi_transport);\n\n\tret = pci_register_driver(&beiscsi_pci_driver);\n\tif (ret) {\n\t\tprintk(KERN_ERR\n\t\t       \"beiscsi_module_init - Unable to  register beiscsi pci driver.\\n\");\n\t\tgoto unregister_iscsi_transport;\n\t}\n\treturn 0;\n\nunregister_iscsi_transport:\n\tiscsi_unregister_transport(&beiscsi_iscsi_transport);\n\treturn ret;\n}\n\nstatic void __exit beiscsi_module_exit(void)\n{\n\tpci_unregister_driver(&beiscsi_pci_driver);\n\tiscsi_unregister_transport(&beiscsi_iscsi_transport);\n}\n\nmodule_init(beiscsi_module_init);\nmodule_exit(beiscsi_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}