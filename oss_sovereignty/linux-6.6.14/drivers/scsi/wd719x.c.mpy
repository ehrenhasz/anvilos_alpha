{
  "module_name": "wd719x.c",
  "hash_id": "f17016c026d792ec078444e3c5223e6fd05b7022e1531c586256444935121d72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/wd719x.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/firmware.h>\n#include <linux/eeprom_93cx6.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include \"wd719x.h\"\n\n \nstatic inline u8 wd719x_readb(struct wd719x *wd, u8 reg)\n{\n\treturn ioread8(wd->base + reg);\n}\n\nstatic inline u32 wd719x_readl(struct wd719x *wd, u8 reg)\n{\n\treturn ioread32(wd->base + reg);\n}\n\nstatic inline void wd719x_writeb(struct wd719x *wd, u8 reg, u8 val)\n{\n\tiowrite8(val, wd->base + reg);\n}\n\nstatic inline void wd719x_writew(struct wd719x *wd, u8 reg, u16 val)\n{\n\tiowrite16(val, wd->base + reg);\n}\n\nstatic inline void wd719x_writel(struct wd719x *wd, u8 reg, u32 val)\n{\n\tiowrite32(val, wd->base + reg);\n}\n\n \nstatic inline int wd719x_wait_ready(struct wd719x *wd)\n{\n\tint i = 0;\n\n\tdo {\n\t\tif (wd719x_readb(wd, WD719X_AMR_COMMAND) == WD719X_CMD_READY)\n\t\t\treturn 0;\n\t\tudelay(1);\n\t} while (i++ < WD719X_WAIT_FOR_CMD_READY);\n\n\tdev_err(&wd->pdev->dev, \"command register is not ready: 0x%02x\\n\",\n\t\twd719x_readb(wd, WD719X_AMR_COMMAND));\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic inline int wd719x_wait_done(struct wd719x *wd, int timeout)\n{\n\tu8 status;\n\n\twhile (timeout > 0) {\n\t\tstatus = wd719x_readb(wd, WD719X_AMR_INT_STATUS);\n\t\tif (status)\n\t\t\tbreak;\n\t\ttimeout--;\n\t\tudelay(1);\n\t}\n\n\tif (timeout <= 0) {\n\t\tdev_err(&wd->pdev->dev, \"direct command timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (status != WD719X_INT_NOERRORS) {\n\t\tu8 sue = wd719x_readb(wd, WD719X_AMR_SCB_ERROR);\n\t\t \n\t\tif (sue == WD719X_SUE_TERM)\n\t\t\treturn 0;\n\t\t \n\t\tif (sue == WD719X_SUE_RESET)\n\t\t\treturn 0;\n\t\tdev_err(&wd->pdev->dev, \"direct command failed, status 0x%02x, SUE 0x%02x\\n\",\n\t\t\tstatus, sue);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int wd719x_direct_cmd(struct wd719x *wd, u8 opcode, u8 dev, u8 lun,\n\t\t\t     u8 tag, dma_addr_t data, int timeout)\n{\n\tint ret = 0;\n\n\t \n\twd719x_writeb(wd, WD719X_AMR_INT_STATUS, WD719X_INT_NONE);\n\n\t \n\tif (wd719x_wait_ready(wd))\n\t\treturn -ETIMEDOUT;\n\n\t \n\tif (opcode != WD719X_CMD_BUSRESET && opcode != WD719X_CMD_ABORT &&\n\t    opcode != WD719X_CMD_ABORT_TAG && opcode != WD719X_CMD_RESET)\n\t\tdev |= WD719X_DISABLE_INT;\n\twd719x_writeb(wd, WD719X_AMR_CMD_PARAM, dev);\n\twd719x_writeb(wd, WD719X_AMR_CMD_PARAM_2, lun);\n\twd719x_writeb(wd, WD719X_AMR_CMD_PARAM_3, tag);\n\tif (data)\n\t\twd719x_writel(wd, WD719X_AMR_SCB_IN, data);\n\n\t \n\twd719x_writeb(wd, WD719X_AMR_INT_STATUS, WD719X_INT_NONE);\n\n\t \n\twd719x_writeb(wd, WD719X_AMR_COMMAND, opcode);\n\n\tif (timeout)\t \n\t\tret = wd719x_wait_done(wd, timeout);\n\n\t \n\tif (opcode != WD719X_CMD_READ_FIRMVER)\n\t\twd719x_writeb(wd, WD719X_AMR_INT_STATUS, WD719X_INT_NONE);\n\n\treturn ret;\n}\n\nstatic void wd719x_destroy(struct wd719x *wd)\n{\n\t \n\tif (wd719x_direct_cmd(wd, WD719X_CMD_SLEEP, 0, 0, 0, 0,\n\t\t\t      WD719X_WAIT_FOR_RISC))\n\t\tdev_warn(&wd->pdev->dev, \"RISC sleep command failed\\n\");\n\t \n\twd719x_writeb(wd, WD719X_PCI_MODE_SELECT, 0);\n\n\tWARN_ON_ONCE(!list_empty(&wd->active_scbs));\n\n\t \n\tdma_free_coherent(&wd->pdev->dev, wd->fw_size, wd->fw_virt,\n\t\t\t  wd->fw_phys);\n\twd->fw_virt = NULL;\n\tdma_free_coherent(&wd->pdev->dev, WD719X_HASH_TABLE_SIZE, wd->hash_virt,\n\t\t\t  wd->hash_phys);\n\twd->hash_virt = NULL;\n\tdma_free_coherent(&wd->pdev->dev, sizeof(struct wd719x_host_param),\n\t\t\t  wd->params, wd->params_phys);\n\twd->params = NULL;\n\tfree_irq(wd->pdev->irq, wd);\n}\n\n \nstatic void wd719x_finish_cmd(struct wd719x_scb *scb, int result)\n{\n\tstruct scsi_cmnd *cmd = scb->cmd;\n\tstruct wd719x *wd = shost_priv(cmd->device->host);\n\n\tlist_del(&scb->list);\n\n\tdma_unmap_single(&wd->pdev->dev, scb->phys,\n\t\t\tsizeof(struct wd719x_scb), DMA_BIDIRECTIONAL);\n\tscsi_dma_unmap(cmd);\n\tdma_unmap_single(&wd->pdev->dev, scb->dma_handle,\n\t\t\t SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\n\n\tcmd->result = result << 16;\n\tscsi_done(cmd);\n}\n\n \nstatic int wd719x_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)\n{\n\tint i, count_sg;\n\tunsigned long flags;\n\tstruct wd719x_scb *scb = scsi_cmd_priv(cmd);\n\tstruct wd719x *wd = shost_priv(sh);\n\n\tscb->cmd = cmd;\n\n\tscb->CDB_tag = 0;\t \n\tscb->devid = cmd->device->id;\n\tscb->lun = cmd->device->lun;\n\n\t \n\tmemcpy(scb->CDB, cmd->cmnd, cmd->cmd_len);\n\n\t \n\tscb->phys = dma_map_single(&wd->pdev->dev, scb, sizeof(*scb),\n\t\t\t\t   DMA_BIDIRECTIONAL);\n\n\tif (dma_mapping_error(&wd->pdev->dev, scb->phys))\n\t\tgoto out_error;\n\n\t \n\tscb->sense_buf_length = SCSI_SENSE_BUFFERSIZE;\n\tscb->dma_handle = dma_map_single(&wd->pdev->dev, cmd->sense_buffer,\n\t\t\t       SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&wd->pdev->dev, scb->dma_handle))\n\t\tgoto out_unmap_scb;\n\tscb->sense_buf = cpu_to_le32(scb->dma_handle);\n\n\t \n\tscb->SCB_options |= WD719X_SCB_FLAGS_AUTO_REQUEST_SENSE;\n\n\t \n\tif (cmd->sc_data_direction == DMA_TO_DEVICE)\n\t\tscb->SCB_options |= WD719X_SCB_FLAGS_CHECK_DIRECTION\n\t\t\t\t |  WD719X_SCB_FLAGS_PCI_TO_SCSI;\n\telse if (cmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\tscb->SCB_options |= WD719X_SCB_FLAGS_CHECK_DIRECTION;\n\n\t \n\tcount_sg = scsi_dma_map(cmd);\n\tif (count_sg < 0)\n\t\tgoto out_unmap_sense;\n\tBUG_ON(count_sg > WD719X_SG);\n\n\tif (count_sg) {\n\t\tstruct scatterlist *sg;\n\n\t\tscb->data_length = cpu_to_le32(count_sg *\n\t\t\t\t\t       sizeof(struct wd719x_sglist));\n\t\tscb->data_p = cpu_to_le32(scb->phys +\n\t\t\t\t\t  offsetof(struct wd719x_scb, sg_list));\n\n\t\tscsi_for_each_sg(cmd, sg, count_sg, i) {\n\t\t\tscb->sg_list[i].ptr = cpu_to_le32(sg_dma_address(sg));\n\t\t\tscb->sg_list[i].length = cpu_to_le32(sg_dma_len(sg));\n\t\t}\n\t\tscb->SCB_options |= WD719X_SCB_FLAGS_DO_SCATTER_GATHER;\n\t} else {  \n\t\tscb->data_length = 0;\n\t\tscb->data_p = 0;\n\t}\n\n\tspin_lock_irqsave(wd->sh->host_lock, flags);\n\n\t \n\tif (wd719x_readb(wd, WD719X_AMR_COMMAND) != WD719X_CMD_READY) {\n\t\tspin_unlock_irqrestore(wd->sh->host_lock, flags);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tlist_add(&scb->list, &wd->active_scbs);\n\n\t \n\twd719x_writel(wd, WD719X_AMR_SCB_IN, scb->phys);\n\t \n\twd719x_writeb(wd, WD719X_AMR_COMMAND, WD719X_CMD_PROCESS_SCB);\n\n\tspin_unlock_irqrestore(wd->sh->host_lock, flags);\n\treturn 0;\n\nout_unmap_sense:\n\tdma_unmap_single(&wd->pdev->dev, scb->dma_handle,\n\t\t\t SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\nout_unmap_scb:\n\tdma_unmap_single(&wd->pdev->dev, scb->phys, sizeof(*scb),\n\t\t\t DMA_BIDIRECTIONAL);\nout_error:\n\tcmd->result = DID_ERROR << 16;\n\tscsi_done(cmd);\n\treturn 0;\n}\n\nstatic int wd719x_chip_init(struct wd719x *wd)\n{\n\tint i, ret;\n\tu32 risc_init[3];\n\tconst struct firmware *fw_wcs, *fw_risc;\n\tconst char fwname_wcs[] = \"wd719x-wcs.bin\";\n\tconst char fwname_risc[] = \"wd719x-risc.bin\";\n\n\tmemset(wd->hash_virt, 0, WD719X_HASH_TABLE_SIZE);\n\n\t \n\tret = request_firmware(&fw_wcs, fwname_wcs, &wd->pdev->dev);\n\tif (ret) {\n\t\tdev_err(&wd->pdev->dev, \"Unable to load firmware %s: %d\\n\",\n\t\t\tfwname_wcs, ret);\n\t\treturn ret;\n\t}\n\t \n\tret = request_firmware(&fw_risc, fwname_risc, &wd->pdev->dev);\n\tif (ret) {\n\t\tdev_err(&wd->pdev->dev, \"Unable to load firmware %s: %d\\n\",\n\t\t\tfwname_risc, ret);\n\t\trelease_firmware(fw_wcs);\n\t\treturn ret;\n\t}\n\twd->fw_size = ALIGN(fw_wcs->size, 4) + fw_risc->size;\n\n\tif (!wd->fw_virt)\n\t\twd->fw_virt = dma_alloc_coherent(&wd->pdev->dev, wd->fw_size,\n\t\t\t\t\t\t &wd->fw_phys, GFP_KERNEL);\n\tif (!wd->fw_virt) {\n\t\tret = -ENOMEM;\n\t\tgoto wd719x_init_end;\n\t}\n\n\t \n\tmemcpy(wd->fw_virt, fw_wcs->data, fw_wcs->size);\n\tmemcpy(wd->fw_virt + ALIGN(fw_wcs->size, 4), fw_risc->data,\n\t\tfw_risc->size);\n\n\t \n\twd719x_writeb(wd, WD719X_PCI_PORT_RESET, WD719X_PCI_RESET);\n\tudelay(WD719X_WAIT_FOR_RISC);\n\t \n\twd719x_writeb(wd, WD719X_AMR_CMD_PARAM, 0);\n\t \n\twd719x_writeb(wd, WD719X_PCI_MODE_SELECT, 0);\n\t \n\twd719x_writeb(wd, WD719X_AMR_COMMAND, 0);\n\tif (wd719x_wait_ready(wd)) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto wd719x_init_end;\n\t}\n\n\t \n\trisc_init[0] = wd->fw_phys;\t\t\t\t \n\trisc_init[1] = wd->fw_phys + ALIGN(fw_wcs->size, 4);\t \n\trisc_init[2] = wd->hash_phys;\t\t\t\t \n\n\t \n\twd719x_writeb(wd, WD719X_PCI_CHANNEL2_3STATUS, 0);\n\n\t \n\twd719x_writel(wd, WD719X_PCI_EXTERNAL_ADDR, risc_init[1]);\n\t \n\twd719x_writew(wd, WD719X_PCI_INTERNAL_ADDR, WD719X_PRAM_BASE_ADDR);\n\t \n\twd719x_writew(wd, WD719X_PCI_DMA_TRANSFER_SIZE, 2048 * 2);\n\t \n\twd719x_writeb(wd, WD719X_PCI_CHANNEL2_3CMD, WD719X_START_CHANNEL2_3DMA);\n\n\t \n\ti = WD719X_WAIT_FOR_RISC;\n\twhile (i-- > 0) {\n\t\tu8 status = wd719x_readb(wd, WD719X_PCI_CHANNEL2_3STATUS);\n\t\tif (status == WD719X_START_CHANNEL2_3DONE)\n\t\t\tbreak;\n\t\tif (status == WD719X_START_CHANNEL2_3ABORT) {\n\t\t\tdev_warn(&wd->pdev->dev, \"RISC bootstrap failed: DMA aborted\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto wd719x_init_end;\n\t\t}\n\t\tudelay(1);\n\t}\n\tif (i < 1) {\n\t\tdev_warn(&wd->pdev->dev, \"RISC bootstrap failed: DMA timeout\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto wd719x_init_end;\n\t}\n\n\t \n\t \n\twd719x_writel(wd, WD719X_AMR_SCB_IN, risc_init[0]);\n\twd719x_writel(wd, WD719X_AMR_SCB_IN + 4, risc_init[1]);\n\twd719x_writel(wd, WD719X_AMR_SCB_IN + 8, risc_init[2]);\n\n\t \n\twd719x_writeb(wd, WD719X_AMR_CMD_PARAM, WD719X_DISABLE_INT);\n\n\t \n\twd719x_writeb(wd, WD719X_AMR_COMMAND, WD719X_CMD_INIT_RISC);\n\t \n\twd719x_writeb(wd, WD719X_PCI_MODE_SELECT, WD719X_ENABLE_ADVANCE_MODE);\n\tudelay(WD719X_WAIT_FOR_RISC);\n\n\tret = wd719x_wait_done(wd, WD719X_WAIT_FOR_RISC);\n\t \n\twd719x_writeb(wd, WD719X_AMR_INT_STATUS, WD719X_INT_NONE);\n\tif (ret) {\n\t\tdev_warn(&wd->pdev->dev, \"Unable to initialize RISC\\n\");\n\t\tgoto wd719x_init_end;\n\t}\n\t \n\n\t \n\tret = wd719x_direct_cmd(wd, WD719X_CMD_READ_FIRMVER, 0, 0, 0, 0,\n\t\t\t\tWD719X_WAIT_FOR_RISC);\n\tif (ret) {\n\t\tdev_warn(&wd->pdev->dev, \"Unable to read firmware version\\n\");\n\t\tgoto wd719x_init_end;\n\t}\n\tdev_info(&wd->pdev->dev, \"RISC initialized with firmware version %.2x.%.2x\\n\",\n\t\t\twd719x_readb(wd, WD719X_AMR_SCB_OUT + 1),\n\t\t\twd719x_readb(wd, WD719X_AMR_SCB_OUT));\n\n\t \n\tret = wd719x_direct_cmd(wd, WD719X_CMD_BUSRESET, 0, 0, 0, 0,\n\t\t\t\tWD719X_WAIT_FOR_SCSI_RESET);\n\tif (ret) {\n\t\tdev_warn(&wd->pdev->dev, \"SCSI bus reset failed\\n\");\n\t\tgoto wd719x_init_end;\n\t}\n\n\t \n\tret = wd719x_direct_cmd(wd, WD719X_CMD_SET_PARAM, 0,\n\t\t\t\tsizeof(struct wd719x_host_param), 0,\n\t\t\t\twd->params_phys, WD719X_WAIT_FOR_RISC);\n\tif (ret) {\n\t\tdev_warn(&wd->pdev->dev, \"Failed to set HOST PARAMETERS\\n\");\n\t\tgoto wd719x_init_end;\n\t}\n\n\t \n\t \n\tret = wd719x_direct_cmd(wd, WD719X_CMD_INIT_SCAM, 0, 0, 0, 0,\n\t\t\t\tWD719X_WAIT_FOR_SCSI_RESET);\n\tif (ret) {\n\t\tdev_warn(&wd->pdev->dev, \"SCAM initialization failed\\n\");\n\t\tgoto wd719x_init_end;\n\t}\n\n\t \n\twd719x_writeb(wd, WD719X_AMR_BIOS_SHARE_INT, 0);\n\nwd719x_init_end:\n\trelease_firmware(fw_wcs);\n\trelease_firmware(fw_risc);\n\n\treturn ret;\n}\n\nstatic int wd719x_abort(struct scsi_cmnd *cmd)\n{\n\tint action, result;\n\tunsigned long flags;\n\tstruct wd719x_scb *scb = scsi_cmd_priv(cmd);\n\tstruct wd719x *wd = shost_priv(cmd->device->host);\n\tstruct device *dev = &wd->pdev->dev;\n\n\tdev_info(dev, \"abort command, tag: %x\\n\", scsi_cmd_to_rq(cmd)->tag);\n\n\taction = WD719X_CMD_ABORT;\n\n\tspin_lock_irqsave(wd->sh->host_lock, flags);\n\tresult = wd719x_direct_cmd(wd, action, cmd->device->id,\n\t\t\t\t   cmd->device->lun, scsi_cmd_to_rq(cmd)->tag,\n\t\t\t\t   scb->phys, 0);\n\twd719x_finish_cmd(scb, DID_ABORT);\n\tspin_unlock_irqrestore(wd->sh->host_lock, flags);\n\tif (result)\n\t\treturn FAILED;\n\n\treturn SUCCESS;\n}\n\nstatic int wd719x_reset(struct scsi_cmnd *cmd, u8 opcode, u8 device)\n{\n\tint result;\n\tunsigned long flags;\n\tstruct wd719x *wd = shost_priv(cmd->device->host);\n\tstruct wd719x_scb *scb, *tmp;\n\n\tdev_info(&wd->pdev->dev, \"%s reset requested\\n\",\n\t\t (opcode == WD719X_CMD_BUSRESET) ? \"bus\" : \"device\");\n\n\tspin_lock_irqsave(wd->sh->host_lock, flags);\n\tresult = wd719x_direct_cmd(wd, opcode, device, 0, 0, 0,\n\t\t\t\t   WD719X_WAIT_FOR_SCSI_RESET);\n\t \n\tlist_for_each_entry_safe(scb, tmp, &wd->active_scbs, list) {\n\t\tif (opcode == WD719X_CMD_BUSRESET ||\n\t\t    scb->cmd->device->id == device)\n\t\t\twd719x_finish_cmd(scb, DID_RESET);\n\t}\n\tspin_unlock_irqrestore(wd->sh->host_lock, flags);\n\tif (result)\n\t\treturn FAILED;\n\n\treturn SUCCESS;\n}\n\nstatic int wd719x_dev_reset(struct scsi_cmnd *cmd)\n{\n\treturn wd719x_reset(cmd, WD719X_CMD_RESET, cmd->device->id);\n}\n\nstatic int wd719x_bus_reset(struct scsi_cmnd *cmd)\n{\n\treturn wd719x_reset(cmd, WD719X_CMD_BUSRESET, 0);\n}\n\nstatic int wd719x_host_reset(struct scsi_cmnd *cmd)\n{\n\tstruct wd719x *wd = shost_priv(cmd->device->host);\n\tstruct wd719x_scb *scb, *tmp;\n\tunsigned long flags;\n\n\tdev_info(&wd->pdev->dev, \"host reset requested\\n\");\n\tspin_lock_irqsave(wd->sh->host_lock, flags);\n\t \n\tif (wd719x_direct_cmd(wd, WD719X_CMD_SLEEP, 0, 0, 0, 0,\n\t\t\t      WD719X_WAIT_FOR_RISC))\n\t\tdev_warn(&wd->pdev->dev, \"RISC sleep command failed\\n\");\n\t \n\twd719x_writeb(wd, WD719X_PCI_MODE_SELECT, 0);\n\n\t \n\tlist_for_each_entry_safe(scb, tmp, &wd->active_scbs, list)\n\t\twd719x_finish_cmd(scb, DID_RESET);\n\tspin_unlock_irqrestore(wd->sh->host_lock, flags);\n\n\t \n\treturn wd719x_chip_init(wd) == 0 ? SUCCESS : FAILED;\n}\n\nstatic int wd719x_biosparam(struct scsi_device *sdev, struct block_device *bdev,\n\t\t\t    sector_t capacity, int geom[])\n{\n\tif (capacity >= 0x200000) {\n\t\tgeom[0] = 255;\t \n\t\tgeom[1] = 63;\t \n\t} else {\n\t\tgeom[0] = 64;\t \n\t\tgeom[1] = 32;\t \n\t}\n\tgeom[2] = sector_div(capacity, geom[0] * geom[1]);\t \n\n\treturn 0;\n}\n\n \nstatic inline void wd719x_interrupt_SCB(struct wd719x *wd,\n\t\t\t\t\tunion wd719x_regs regs,\n\t\t\t\t\tstruct wd719x_scb *scb)\n{\n\tint result;\n\n\t \n\tswitch (regs.bytes.SUE) {\n\tcase WD719X_SUE_NOERRORS:\n\t\tresult = DID_OK;\n\t\tbreak;\n\tcase WD719X_SUE_REJECTED:\n\t\tdev_err(&wd->pdev->dev, \"command rejected\\n\");\n\t\tresult = DID_ERROR;\n\t\tbreak;\n\tcase WD719X_SUE_SCBQFULL:\n\t\tdev_err(&wd->pdev->dev, \"SCB queue is full\\n\");\n\t\tresult = DID_ERROR;\n\t\tbreak;\n\tcase WD719X_SUE_TERM:\n\t\tdev_dbg(&wd->pdev->dev, \"SCB terminated by direct command\\n\");\n\t\tresult = DID_ABORT;\t \n\t\tbreak;\n\tcase WD719X_SUE_CHAN1ABORT:\n\tcase WD719X_SUE_CHAN23ABORT:\n\t\tresult = DID_ABORT;\n\t\tdev_err(&wd->pdev->dev, \"DMA abort\\n\");\n\t\tbreak;\n\tcase WD719X_SUE_CHAN1PAR:\n\tcase WD719X_SUE_CHAN23PAR:\n\t\tresult = DID_PARITY;\n\t\tdev_err(&wd->pdev->dev, \"DMA parity error\\n\");\n\t\tbreak;\n\tcase WD719X_SUE_TIMEOUT:\n\t\tresult = DID_TIME_OUT;\n\t\tdev_dbg(&wd->pdev->dev, \"selection timeout\\n\");\n\t\tbreak;\n\tcase WD719X_SUE_RESET:\n\t\tdev_dbg(&wd->pdev->dev, \"bus reset occurred\\n\");\n\t\tresult = DID_RESET;\n\t\tbreak;\n\tcase WD719X_SUE_BUSERROR:\n\t\tdev_dbg(&wd->pdev->dev, \"SCSI bus error\\n\");\n\t\tresult = DID_ERROR;\n\t\tbreak;\n\tcase WD719X_SUE_WRONGWAY:\n\t\tdev_err(&wd->pdev->dev, \"wrong data transfer direction\\n\");\n\t\tresult = DID_ERROR;\n\t\tbreak;\n\tcase WD719X_SUE_BADPHASE:\n\t\tdev_err(&wd->pdev->dev, \"invalid SCSI phase\\n\");\n\t\tresult = DID_ERROR;\n\t\tbreak;\n\tcase WD719X_SUE_TOOLONG:\n\t\tdev_err(&wd->pdev->dev, \"record too long\\n\");\n\t\tresult = DID_ERROR;\n\t\tbreak;\n\tcase WD719X_SUE_BUSFREE:\n\t\tdev_err(&wd->pdev->dev, \"unexpected bus free\\n\");\n\t\tresult = DID_NO_CONNECT;  \n\t\tbreak;\n\tcase WD719X_SUE_ARSDONE:\n\t\tdev_dbg(&wd->pdev->dev, \"auto request sense\\n\");\n\t\tif (regs.bytes.SCSI == 0)\n\t\t\tresult = DID_OK;\n\t\telse\n\t\t\tresult = DID_PARITY;\n\t\tbreak;\n\tcase WD719X_SUE_IGNORED:\n\t\tdev_err(&wd->pdev->dev, \"target id %d ignored command\\n\",\n\t\t\tscb->cmd->device->id);\n\t\tresult = DID_NO_CONNECT;\n\t\tbreak;\n\tcase WD719X_SUE_WRONGTAGS:\n\t\tdev_err(&wd->pdev->dev, \"reversed tags\\n\");\n\t\tresult = DID_ERROR;\n\t\tbreak;\n\tcase WD719X_SUE_BADTAGS:\n\t\tdev_err(&wd->pdev->dev, \"tag type not supported by target\\n\");\n\t\tresult = DID_ERROR;\n\t\tbreak;\n\tcase WD719X_SUE_NOSCAMID:\n\t\tdev_err(&wd->pdev->dev, \"no SCAM soft ID available\\n\");\n\t\tresult = DID_ERROR;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&wd->pdev->dev, \"unknown SUE error code: 0x%x\\n\",\n\t\t\t regs.bytes.SUE);\n\t\tresult = DID_ERROR;\n\t\tbreak;\n\t}\n\n\twd719x_finish_cmd(scb, result);\n}\n\nstatic irqreturn_t wd719x_interrupt(int irq, void *dev_id)\n{\n\tstruct wd719x *wd = dev_id;\n\tunion wd719x_regs regs;\n\tunsigned long flags;\n\tu32 SCB_out;\n\n\tspin_lock_irqsave(wd->sh->host_lock, flags);\n\t \n\tSCB_out = wd719x_readl(wd, WD719X_AMR_SCB_OUT);\n\t \n\tregs.all = cpu_to_le32(wd719x_readl(wd, WD719X_AMR_OP_CODE));\n\n\tswitch (regs.bytes.INT) {\n\tcase WD719X_INT_NONE:\n\t\tspin_unlock_irqrestore(wd->sh->host_lock, flags);\n\t\treturn IRQ_NONE;\n\tcase WD719X_INT_LINKNOSTATUS:\n\t\tdev_err(&wd->pdev->dev, \"linked command completed with no status\\n\");\n\t\tbreak;\n\tcase WD719X_INT_BADINT:\n\t\tdev_err(&wd->pdev->dev, \"unsolicited interrupt\\n\");\n\t\tbreak;\n\tcase WD719X_INT_NOERRORS:\n\tcase WD719X_INT_LINKNOERRORS:\n\tcase WD719X_INT_ERRORSLOGGED:\n\tcase WD719X_INT_SPIDERFAILED:\n\t\t \n\t\tif (regs.bytes.OPC == WD719X_CMD_PROCESS_SCB) {\n\t\t\tstruct wd719x_scb *scb;\n\t\t\tlist_for_each_entry(scb, &wd->active_scbs, list)\n\t\t\t\tif (SCB_out == scb->phys)\n\t\t\t\t\tbreak;\n\t\t\tif (SCB_out == scb->phys)\n\t\t\t\twd719x_interrupt_SCB(wd, regs, scb);\n\t\t\telse\n\t\t\t\tdev_err(&wd->pdev->dev, \"card returned invalid SCB pointer\\n\");\n\t\t} else\n\t\t\tdev_dbg(&wd->pdev->dev, \"direct command 0x%x completed\\n\",\n\t\t\t\t regs.bytes.OPC);\n\t\tbreak;\n\tcase WD719X_INT_PIOREADY:\n\t\tdev_err(&wd->pdev->dev, \"card indicates PIO data ready but we never use PIO\\n\");\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_err(&wd->pdev->dev, \"unknown interrupt reason: %d\\n\",\n\t\t\tregs.bytes.INT);\n\n\t}\n\t \n\twd719x_writeb(wd, WD719X_AMR_INT_STATUS, WD719X_INT_NONE);\n\tspin_unlock_irqrestore(wd->sh->host_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void wd719x_eeprom_reg_read(struct eeprom_93cx6 *eeprom)\n{\n\tstruct wd719x *wd = eeprom->data;\n\tu8 reg = wd719x_readb(wd, WD719X_PCI_GPIO_DATA);\n\n\teeprom->reg_data_out = reg & WD719X_EE_DO;\n}\n\nstatic void wd719x_eeprom_reg_write(struct eeprom_93cx6 *eeprom)\n{\n\tstruct wd719x *wd = eeprom->data;\n\tu8 reg = 0;\n\n\tif (eeprom->reg_data_in)\n\t\treg |= WD719X_EE_DI;\n\tif (eeprom->reg_data_clock)\n\t\treg |= WD719X_EE_CLK;\n\tif (eeprom->reg_chip_select)\n\t\treg |= WD719X_EE_CS;\n\n\twd719x_writeb(wd, WD719X_PCI_GPIO_DATA, reg);\n}\n\n \nstatic void wd719x_read_eeprom(struct wd719x *wd)\n{\n\tstruct eeprom_93cx6 eeprom;\n\tu8 gpio;\n\tstruct wd719x_eeprom_header header;\n\n\teeprom.data = wd;\n\teeprom.register_read = wd719x_eeprom_reg_read;\n\teeprom.register_write = wd719x_eeprom_reg_write;\n\teeprom.width = PCI_EEPROM_WIDTH_93C46;\n\n\t \n\twd719x_writeb(wd, WD719X_PCI_GPIO_DATA, 0);\n\t \n\tgpio = wd719x_readb(wd, WD719X_PCI_GPIO_CONTROL);\n\t \n\tgpio &= (~(WD719X_EE_CLK | WD719X_EE_DI | WD719X_EE_CS));\n\t \n\tgpio |= WD719X_EE_DO;\n\twd719x_writeb(wd, WD719X_PCI_GPIO_CONTROL, gpio);\n\n\t \n\teeprom_93cx6_multireadb(&eeprom, 0, (u8 *)&header, sizeof(header));\n\n\tif (header.sig1 == 'W' && header.sig2 == 'D')\n\t\teeprom_93cx6_multireadb(&eeprom, header.cfg_offset,\n\t\t\t\t\t(u8 *)wd->params,\n\t\t\t\t\tsizeof(struct wd719x_host_param));\n\telse {  \n\t\tdev_warn(&wd->pdev->dev, \"EEPROM signature is invalid (0x%02x 0x%02x), using default values\\n\",\n\t\t\t header.sig1, header.sig2);\n\t\twd->params->ch_1_th\t= 0x10;\t \n\t\twd->params->scsi_conf\t= 0x4c;\t \n\t\twd->params->own_scsi_id\t= 0x07;\t \n\t\twd->params->sel_timeout = 0x4d;\t \n\t\twd->params->sleep_timer\t= 0x01;\n\t\twd->params->cdb_size\t= cpu_to_le16(0x5555);\t \n\t\twd->params->scsi_pad\t= 0x1b;\n\t\tif (wd->type == WD719X_TYPE_7193)  \n\t\t\twd->params->wide = cpu_to_le32(0x00000000);\n\t\telse\t \n\t\t\twd->params->wide = cpu_to_le32(0xffffffff);\n\t\twd->params->sync\t= cpu_to_le32(0xffffffff);\n\t\twd->params->soft_mask\t= 0x00;\t \n\t\twd->params->unsol_mask\t= 0x00;\t \n\t}\n\t \n\twd->params->tag_en = cpu_to_le16(0x0000);\n}\n\n \nstatic enum wd719x_card_type wd719x_detect_type(struct wd719x *wd)\n{\n\tu8 card = wd719x_readb(wd, WD719X_PCI_GPIO_CONTROL);\n\n\tcard |= WD719X_GPIO_ID_BITS;\n\twd719x_writeb(wd, WD719X_PCI_GPIO_CONTROL, card);\n\tcard = wd719x_readb(wd, WD719X_PCI_GPIO_DATA) & WD719X_GPIO_ID_BITS;\n\tswitch (card) {\n\tcase 0x08:\n\t\treturn WD719X_TYPE_7193;\n\tcase 0x02:\n\t\treturn WD719X_TYPE_7197;\n\tcase 0x00:\n\t\treturn WD719X_TYPE_7296;\n\tdefault:\n\t\tdev_warn(&wd->pdev->dev, \"unknown card type 0x%x\\n\", card);\n\t\treturn WD719X_TYPE_UNKNOWN;\n\t}\n}\n\nstatic int wd719x_board_found(struct Scsi_Host *sh)\n{\n\tstruct wd719x *wd = shost_priv(sh);\n\tstatic const char * const card_types[] = {\n\t\t\"Unknown card\", \"WD7193\", \"WD7197\", \"WD7296\"\n\t};\n\tint ret;\n\n\tINIT_LIST_HEAD(&wd->active_scbs);\n\n\tsh->base = pci_resource_start(wd->pdev, 0);\n\n\twd->type = wd719x_detect_type(wd);\n\n\twd->sh = sh;\n\tsh->irq = wd->pdev->irq;\n\twd->fw_virt = NULL;\n\n\t \n\twd->params = dma_alloc_coherent(&wd->pdev->dev,\n\t\t\t\t\tsizeof(struct wd719x_host_param),\n\t\t\t\t\t&wd->params_phys, GFP_KERNEL);\n\tif (!wd->params) {\n\t\tdev_warn(&wd->pdev->dev, \"unable to allocate parameter buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\twd->hash_virt = dma_alloc_coherent(&wd->pdev->dev,\n\t\t\t\t\t   WD719X_HASH_TABLE_SIZE,\n\t\t\t\t\t   &wd->hash_phys, GFP_KERNEL);\n\tif (!wd->hash_virt) {\n\t\tdev_warn(&wd->pdev->dev, \"unable to allocate hash buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail_free_params;\n\t}\n\n\tret = request_irq(wd->pdev->irq, wd719x_interrupt, IRQF_SHARED,\n\t\t\t  \"wd719x\", wd);\n\tif (ret) {\n\t\tdev_warn(&wd->pdev->dev, \"unable to assign IRQ %d\\n\",\n\t\t\t wd->pdev->irq);\n\t\tgoto fail_free_hash;\n\t}\n\n\t \n\twd719x_read_eeprom(wd);\n\n\tret = wd719x_chip_init(wd);\n\tif (ret)\n\t\tgoto fail_free_irq;\n\n\tsh->this_id = wd->params->own_scsi_id & WD719X_EE_SCSI_ID_MASK;\n\n\tdev_info(&wd->pdev->dev, \"%s at I/O 0x%lx, IRQ %u, SCSI ID %d\\n\",\n\t\t card_types[wd->type], sh->base, sh->irq, sh->this_id);\n\n\treturn 0;\n\nfail_free_irq:\n\tfree_irq(wd->pdev->irq, wd);\nfail_free_hash:\n\tdma_free_coherent(&wd->pdev->dev, WD719X_HASH_TABLE_SIZE, wd->hash_virt,\n\t\t\t    wd->hash_phys);\nfail_free_params:\n\tdma_free_coherent(&wd->pdev->dev, sizeof(struct wd719x_host_param),\n\t\t\t    wd->params, wd->params_phys);\n\n\treturn ret;\n}\n\nstatic const struct scsi_host_template wd719x_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.name\t\t\t\t= \"Western Digital 719x\",\n\t.cmd_size\t\t\t= sizeof(struct wd719x_scb),\n\t.queuecommand\t\t\t= wd719x_queuecommand,\n\t.eh_abort_handler\t\t= wd719x_abort,\n\t.eh_device_reset_handler\t= wd719x_dev_reset,\n\t.eh_bus_reset_handler\t\t= wd719x_bus_reset,\n\t.eh_host_reset_handler\t\t= wd719x_host_reset,\n\t.bios_param\t\t\t= wd719x_biosparam,\n\t.proc_name\t\t\t= \"wd719x\",\n\t.can_queue\t\t\t= 255,\n\t.this_id\t\t\t= 7,\n\t.sg_tablesize\t\t\t= WD719X_SG,\n};\n\nstatic int wd719x_pci_probe(struct pci_dev *pdev, const struct pci_device_id *d)\n{\n\tint err;\n\tstruct Scsi_Host *sh;\n\tstruct wd719x *wd;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\tgoto fail;\n\n\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tdev_warn(&pdev->dev, \"Unable to set 32-bit DMA mask\\n\");\n\t\tgoto disable_device;\n\t}\n\n\terr = pci_request_regions(pdev, \"wd719x\");\n\tif (err)\n\t\tgoto disable_device;\n\tpci_set_master(pdev);\n\n\terr = -ENODEV;\n\tif (pci_resource_len(pdev, 0) == 0)\n\t\tgoto release_region;\n\n\terr = -ENOMEM;\n\tsh = scsi_host_alloc(&wd719x_template, sizeof(struct wd719x));\n\tif (!sh)\n\t\tgoto release_region;\n\n\twd = shost_priv(sh);\n\twd->base = pci_iomap(pdev, 0, 0);\n\tif (!wd->base)\n\t\tgoto free_host;\n\twd->pdev = pdev;\n\n\terr = wd719x_board_found(sh);\n\tif (err)\n\t\tgoto unmap;\n\n\terr = scsi_add_host(sh, &wd->pdev->dev);\n\tif (err)\n\t\tgoto destroy;\n\n\tscsi_scan_host(sh);\n\n\tpci_set_drvdata(pdev, sh);\n\treturn 0;\n\ndestroy:\n\twd719x_destroy(wd);\nunmap:\n\tpci_iounmap(pdev, wd->base);\nfree_host:\n\tscsi_host_put(sh);\nrelease_region:\n\tpci_release_regions(pdev);\ndisable_device:\n\tpci_disable_device(pdev);\nfail:\n\treturn err;\n}\n\n\nstatic void wd719x_pci_remove(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *sh = pci_get_drvdata(pdev);\n\tstruct wd719x *wd = shost_priv(sh);\n\n\tscsi_remove_host(sh);\n\twd719x_destroy(wd);\n\tpci_iounmap(pdev, wd->base);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\n\tscsi_host_put(sh);\n}\n\nstatic const struct pci_device_id wd719x_pci_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_WD, 0x3296) },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, wd719x_pci_table);\n\nstatic struct pci_driver wd719x_pci_driver = {\n\t.name =\t\t\"wd719x\",\n\t.id_table =\twd719x_pci_table,\n\t.probe =\twd719x_pci_probe,\n\t.remove =\twd719x_pci_remove,\n};\n\nmodule_pci_driver(wd719x_pci_driver);\n\nMODULE_DESCRIPTION(\"Western Digital WD7193/7197/7296 SCSI driver\");\nMODULE_AUTHOR(\"Ondrej Zary, Aaron Dewell, Juergen Gaertner\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"wd719x-wcs.bin\");\nMODULE_FIRMWARE(\"wd719x-risc.bin\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}