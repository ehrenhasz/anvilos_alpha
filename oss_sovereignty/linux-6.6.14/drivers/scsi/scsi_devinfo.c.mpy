{
  "module_name": "scsi_devinfo.c",
  "hash_id": "18f9df9be5d45c56c6c48188f6f9907bb8ef72da0176666b4514888a674db8d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_devinfo.c",
  "human_readable_source": "\n\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_devinfo.h>\n\n#include \"scsi_priv.h\"\n\n\n \nstruct scsi_dev_info_list {\n\tstruct list_head dev_info_list;\n\tchar vendor[8];\n\tchar model[16];\n\tblist_flags_t flags;\n\tunsigned compatible;  \n};\n\nstruct scsi_dev_info_list_table {\n\tstruct list_head node;\t \n\tstruct list_head scsi_dev_info_list;  \n\tconst char *name;\t \n\tint key;\t\t \n};\n\n\nstatic blist_flags_t scsi_default_dev_flags;\nstatic LIST_HEAD(scsi_dev_info_list);\nstatic char scsi_dev_flags[256];\n\n \nstatic struct {\n\tchar *vendor;\n\tchar *model;\n\tchar *revision;\t \n\tblist_flags_t flags;\n} scsi_static_device_list[] __initdata = {\n\t \n\t{\"Aashima\", \"IMAGERY 2400SP\", \"1.03\", BLIST_NOLUN},\t \n\t{\"CHINON\", \"CD-ROM CDS-431\", \"H42\", BLIST_NOLUN},\t \n\t{\"CHINON\", \"CD-ROM CDS-535\", \"Q14\", BLIST_NOLUN},\t \n\t{\"DENON\", \"DRD-25X\", \"V\", BLIST_NOLUN},\t\t\t \n\t{\"HITACHI\", \"DK312C\", \"CM81\", BLIST_NOLUN},\t \n\t{\"HITACHI\", \"DK314C\", \"CR21\", BLIST_NOLUN},\t \n\t{\"IBM\", \"2104-DU3\", NULL, BLIST_NOLUN},\t\t \n\t{\"IBM\", \"2104-TU3\", NULL, BLIST_NOLUN},\t\t \n\t{\"IMS\", \"CDD521/10\", \"2.06\", BLIST_NOLUN},\t \n\t{\"MAXTOR\", \"XT-3280\", \"PR02\", BLIST_NOLUN},\t \n\t{\"MAXTOR\", \"XT-4380S\", \"B3C\", BLIST_NOLUN},\t \n\t{\"MAXTOR\", \"MXT-1240S\", \"I1.2\", BLIST_NOLUN},\t \n\t{\"MAXTOR\", \"XT-4170S\", \"B5A\", BLIST_NOLUN},\t \n\t{\"MAXTOR\", \"XT-8760S\", \"B7B\", BLIST_NOLUN},\t \n\t{\"MEDIAVIS\", \"RENO CD-ROMX2A\", \"2.03\", BLIST_NOLUN},\t \n\t{\"MICROTEK\", \"ScanMakerIII\", \"2.30\", BLIST_NOLUN},\t \n\t{\"NEC\", \"CD-ROM DRIVE:841\", \"1.0\", BLIST_NOLUN}, \n\t{\"PHILIPS\", \"PCA80SC\", \"V4-2\", BLIST_NOLUN},\t \n\t{\"RODIME\", \"RO3000S\", \"2.33\", BLIST_NOLUN},\t \n\t{\"SUN\", \"SENA\", NULL, BLIST_NOLUN},\t\t \n\t \n\t{\"SANYO\", \"CRD-250S\", \"1.20\", BLIST_NOLUN},\n\t \n\t{\"SEAGATE\", \"ST157N\", \"\\004|j\", BLIST_NOLUN},\n\t{\"SEAGATE\", \"ST296\", \"921\", BLIST_NOLUN},\t \n\t{\"SEAGATE\", \"ST1581\", \"6538\", BLIST_NOLUN},\t \n\t{\"SONY\", \"CD-ROM CDU-541\", \"4.3d\", BLIST_NOLUN},\n\t{\"SONY\", \"CD-ROM CDU-55S\", \"1.0i\", BLIST_NOLUN},\n\t{\"SONY\", \"CD-ROM CDU-561\", \"1.7x\", BLIST_NOLUN},\n\t{\"SONY\", \"CD-ROM CDU-8012\", NULL, BLIST_NOLUN},\n\t{\"SONY\", \"SDT-5000\", \"3.17\", BLIST_SELECT_NO_ATN},\n\t{\"TANDBERG\", \"TDC 3600\", \"U07\", BLIST_NOLUN},\t \n\t{\"TEAC\", \"CD-R55S\", \"1.0H\", BLIST_NOLUN},\t \n\t \n\t{\"TEAC\", \"CD-ROM\", \"1.06\", BLIST_NOLUN},\n\t{\"TEAC\", \"MT-2ST/45S2-27\", \"RV M\", BLIST_NOLUN},\t \n\t \n\t{\"HP\", \"C1750A\", \"3226\", BLIST_NOLUN},\t\t \n\t{\"HP\", \"C1790A\", NULL, BLIST_NOLUN},\t\t \n\t{\"HP\", \"C2500A\", NULL, BLIST_NOLUN},\t\t \n\t{\"MEDIAVIS\", \"CDR-H93MV\", \"1.31\", BLIST_NOLUN},\t \n\t{\"MICROTEK\", \"ScanMaker II\", \"5.61\", BLIST_NOLUN},\t \n\t{\"MITSUMI\", \"CD-R CR-2201CS\", \"6119\", BLIST_NOLUN},\t \n\t{\"NEC\", \"D3856\", \"0009\", BLIST_NOLUN},\n\t{\"QUANTUM\", \"LPS525S\", \"3110\", BLIST_NOLUN},\t \n\t{\"QUANTUM\", \"PD1225S\", \"3110\", BLIST_NOLUN},\t \n\t{\"QUANTUM\", \"FIREBALL ST4.3S\", \"0F0C\", BLIST_NOLUN},\t \n\t{\"RELISYS\", \"Scorpio\", NULL, BLIST_NOLUN},\t \n\t{\"SANKYO\", \"CP525\", \"6.64\", BLIST_NOLUN},\t \n\t{\"TEXEL\", \"CD-ROM\", \"1.06\", BLIST_NOLUN | BLIST_BORKEN},\n\t{\"transtec\", \"T5008\", \"0001\", BLIST_NOREPORTLUN },\n\t{\"YAMAHA\", \"CDR100\", \"1.00\", BLIST_NOLUN},\t \n\t{\"YAMAHA\", \"CDR102\", \"1.00\", BLIST_NOLUN},\t \n\t{\"YAMAHA\", \"CRW8424S\", \"1.0\", BLIST_NOLUN},\t \n\t{\"YAMAHA\", \"CRW6416S\", \"1.0c\", BLIST_NOLUN},\t \n\t{\"\", \"Scanner\", \"1.80\", BLIST_NOLUN},\t \n\n\t \n\t{\"3PARdata\", \"VV\", NULL, BLIST_REPORTLUN2},\n\t{\"ADAPTEC\", \"AACRAID\", NULL, BLIST_FORCELUN},\n\t{\"ADAPTEC\", \"Adaptec 5400S\", NULL, BLIST_FORCELUN},\n\t{\"AIX\", \"VDASD\", NULL, BLIST_TRY_VPD_PAGES | BLIST_NO_VPD_SIZE},\n\t{\"AFT PRO\", \"-IX CF\", \"0.0>\", BLIST_FORCELUN},\n\t{\"BELKIN\", \"USB 2 HS-CF\", \"1.95\",  BLIST_FORCELUN | BLIST_INQUIRY_36},\n\t{\"BROWNIE\", \"1200U3P\", NULL, BLIST_NOREPORTLUN},\n\t{\"BROWNIE\", \"1600U3P\", NULL, BLIST_NOREPORTLUN},\n\t{\"CANON\", \"IPUBJD\", NULL, BLIST_SPARSELUN},\n\t{\"CBOX3\", \"USB Storage-SMC\", \"300A\", BLIST_FORCELUN | BLIST_INQUIRY_36},\n\t{\"CMD\", \"CRA-7280\", NULL, BLIST_SPARSELUN},\t \n\t{\"CNSI\", \"G7324\", NULL, BLIST_SPARSELUN},\t \n\t{\"CNSi\", \"G8324\", NULL, BLIST_SPARSELUN},\t \n\t{\"COMPAQ\", \"ARRAY CONTROLLER\", NULL, BLIST_SPARSELUN | BLIST_LARGELUN |\n\t\tBLIST_MAX_512 | BLIST_REPORTLUN2},\t \n\t{\"COMPAQ\", \"LOGICAL VOLUME\", NULL, BLIST_FORCELUN | BLIST_MAX_512},  \n\t{\"COMPAQ\", \"CR3500\", NULL, BLIST_FORCELUN},\n\t{\"COMPAQ\", \"MSA1000\", NULL, BLIST_SPARSELUN | BLIST_NOSTARTONADD},\n\t{\"COMPAQ\", \"MSA1000 VOLUME\", NULL, BLIST_SPARSELUN | BLIST_NOSTARTONADD},\n\t{\"COMPAQ\", \"HSV110\", NULL, BLIST_REPORTLUN2 | BLIST_NOSTARTONADD},\n\t{\"DDN\", \"SAN DataDirector\", \"*\", BLIST_SPARSELUN},\n\t{\"DEC\", \"HSG80\", NULL, BLIST_REPORTLUN2 | BLIST_NOSTARTONADD},\n\t{\"DELL\", \"PV660F\", NULL, BLIST_SPARSELUN},\n\t{\"DELL\", \"PV660F   PSEUDO\", NULL, BLIST_SPARSELUN},\n\t{\"DELL\", \"PSEUDO DEVICE .\", NULL, BLIST_SPARSELUN},\t \n\t{\"DELL\", \"PV530F\", NULL, BLIST_SPARSELUN},\n\t{\"DELL\", \"PERCRAID\", NULL, BLIST_FORCELUN},\n\t{\"DGC\", \"RAID\", NULL, BLIST_SPARSELUN},\t \n\t{\"DGC\", \"DISK\", NULL, BLIST_SPARSELUN},\t \n\t{\"EMC\",  \"Invista\", \"*\", BLIST_SPARSELUN | BLIST_LARGELUN},\n\t{\"EMC\", \"SYMMETRIX\", NULL, BLIST_SPARSELUN | BLIST_LARGELUN |\n\t BLIST_REPORTLUN2 | BLIST_RETRY_ITF},\n\t{\"EMULEX\", \"MD21/S2     ESDI\", NULL, BLIST_SINGLELUN},\n\t{\"easyRAID\", \"16P\", NULL, BLIST_NOREPORTLUN},\n\t{\"easyRAID\", \"X6P\", NULL, BLIST_NOREPORTLUN},\n\t{\"easyRAID\", \"F8\", NULL, BLIST_NOREPORTLUN},\n\t{\"FSC\", \"CentricStor\", \"*\", BLIST_SPARSELUN | BLIST_LARGELUN},\n\t{\"FUJITSU\", \"ETERNUS_DXM\", \"*\", BLIST_RETRY_ASC_C1},\n\t{\"Generic\", \"USB SD Reader\", \"1.00\", BLIST_FORCELUN | BLIST_INQUIRY_36},\n\t{\"Generic\", \"USB Storage-SMC\", NULL, BLIST_FORCELUN | BLIST_INQUIRY_36},  \n\t{\"Generic\", \"Ultra HS-SD/MMC\", \"2.09\", BLIST_IGN_MEDIA_CHANGE | BLIST_INQUIRY_36},\n\t{\"HITACHI\", \"DF400\", \"*\", BLIST_REPORTLUN2},\n\t{\"HITACHI\", \"DF500\", \"*\", BLIST_REPORTLUN2},\n\t{\"HITACHI\", \"DISK-SUBSYSTEM\", \"*\", BLIST_REPORTLUN2},\n\t{\"HITACHI\", \"HUS1530\", \"*\", BLIST_NO_DIF},\n\t{\"HITACHI\", \"OPEN-\", \"*\", BLIST_REPORTLUN2 | BLIST_TRY_VPD_PAGES},\n\t{\"HP\", \"A6189A\", NULL, BLIST_SPARSELUN | BLIST_LARGELUN},\t \n\t{\"HP\", \"OPEN-\", \"*\", BLIST_REPORTLUN2 | BLIST_TRY_VPD_PAGES},  \n\t{\"HP\", \"NetRAID-4M\", NULL, BLIST_FORCELUN},\n\t{\"HP\", \"HSV100\", NULL, BLIST_REPORTLUN2 | BLIST_NOSTARTONADD},\n\t{\"HP\", \"C1557A\", NULL, BLIST_FORCELUN},\n\t{\"HP\", \"C3323-300\", \"4269\", BLIST_NOTQ},\n\t{\"HP\", \"C5713A\", NULL, BLIST_NOREPORTLUN},\n\t{\"HP\", \"DISK-SUBSYSTEM\", \"*\", BLIST_REPORTLUN2},\n\t{\"HPE\", \"OPEN-\", \"*\", BLIST_REPORTLUN2 | BLIST_TRY_VPD_PAGES},\n\t{\"IBM\", \"AuSaV1S2\", NULL, BLIST_FORCELUN},\n\t{\"IBM\", \"ProFibre 4000R\", \"*\", BLIST_SPARSELUN | BLIST_LARGELUN},\n\t{\"IBM\", \"2076\", NULL, BLIST_NO_VPD_SIZE},\n\t{\"IBM\", \"2105\", NULL, BLIST_RETRY_HWERROR},\n\t{\"iomega\", \"jaz 1GB\", \"J.86\", BLIST_NOTQ | BLIST_NOLUN},\n\t{\"IOMEGA\", \"ZIP\", NULL, BLIST_NOTQ | BLIST_NOLUN},\n\t{\"IOMEGA\", \"Io20S         *F\", NULL, BLIST_KEY},\n\t{\"INSITE\", \"Floptical   F*8I\", NULL, BLIST_KEY},\n\t{\"INSITE\", \"I325VM\", NULL, BLIST_KEY},\n\t{\"Intel\", \"Multi-Flex\", NULL, BLIST_NO_RSOC},\n\t{\"iRiver\", \"iFP Mass Driver\", NULL, BLIST_NOT_LOCKABLE | BLIST_INQUIRY_36},\n\t{\"LASOUND\", \"CDX7405\", \"3.10\", BLIST_MAX5LUN | BLIST_SINGLELUN},\n\t{\"Marvell\", \"Console\", NULL, BLIST_SKIP_VPD_PAGES},\n\t{\"Marvell\", \"91xx Config\", \"1.01\", BLIST_SKIP_VPD_PAGES},\n\t{\"MATSHITA\", \"PD-1\", NULL, BLIST_FORCELUN | BLIST_SINGLELUN},\n\t{\"MATSHITA\", \"DMC-LC5\", NULL, BLIST_NOT_LOCKABLE | BLIST_INQUIRY_36},\n\t{\"MATSHITA\", \"DMC-LC40\", NULL, BLIST_NOT_LOCKABLE | BLIST_INQUIRY_36},\n\t{\"Medion\", \"Flash XL  MMC/SD\", \"2.6D\", BLIST_FORCELUN},\n\t{\"MegaRAID\", \"LD\", NULL, BLIST_FORCELUN},\n\t{\"MICROP\", \"4110\", NULL, BLIST_NOTQ},\n\t{\"MSFT\", \"Virtual HD\", NULL, BLIST_MAX_1024 | BLIST_NO_RSOC},\n\t{\"MYLEX\", \"DACARMRB\", \"*\", BLIST_REPORTLUN2},\n\t{\"nCipher\", \"Fastness Crypto\", NULL, BLIST_FORCELUN},\n\t{\"NAKAMICH\", \"MJ-4.8S\", NULL, BLIST_FORCELUN | BLIST_SINGLELUN},\n\t{\"NAKAMICH\", \"MJ-5.16S\", NULL, BLIST_FORCELUN | BLIST_SINGLELUN},\n\t{\"NEC\", \"PD-1 ODX654P\", NULL, BLIST_FORCELUN | BLIST_SINGLELUN},\n\t{\"NEC\", \"iStorage\", NULL, BLIST_REPORTLUN2},\n\t{\"NRC\", \"MBR-7\", NULL, BLIST_FORCELUN | BLIST_SINGLELUN},\n\t{\"NRC\", \"MBR-7.4\", NULL, BLIST_FORCELUN | BLIST_SINGLELUN},\n\t{\"PIONEER\", \"CD-ROM DRM-600\", NULL, BLIST_FORCELUN | BLIST_SINGLELUN},\n\t{\"PIONEER\", \"CD-ROM DRM-602X\", NULL, BLIST_FORCELUN | BLIST_SINGLELUN},\n\t{\"PIONEER\", \"CD-ROM DRM-604X\", NULL, BLIST_FORCELUN | BLIST_SINGLELUN},\n\t{\"PIONEER\", \"CD-ROM DRM-624X\", NULL, BLIST_FORCELUN | BLIST_SINGLELUN},\n\t{\"Promise\", \"VTrak E610f\", NULL, BLIST_SPARSELUN | BLIST_NO_RSOC},\n\t{\"Promise\", \"\", NULL, BLIST_SPARSELUN},\n\t{\"QEMU\", \"QEMU CD-ROM\", NULL, BLIST_SKIP_VPD_PAGES},\n\t{\"QNAP\", \"iSCSI Storage\", NULL, BLIST_MAX_1024},\n\t{\"SYNOLOGY\", \"iSCSI Storage\", NULL, BLIST_MAX_1024},\n\t{\"QUANTUM\", \"XP34301\", \"1071\", BLIST_NOTQ},\n\t{\"REGAL\", \"CDC-4X\", NULL, BLIST_MAX5LUN | BLIST_SINGLELUN},\n\t{\"SanDisk\", \"ImageMate CF-SD1\", NULL, BLIST_FORCELUN},\n\t{\"SEAGATE\", \"ST34555N\", \"0930\", BLIST_NOTQ},\t \n\t{\"SEAGATE\", \"ST3390N\", \"9546\", BLIST_NOTQ},\n\t{\"SEAGATE\", \"ST900MM0006\", NULL, BLIST_SKIP_VPD_PAGES},\n\t{\"SGI\", \"RAID3\", \"*\", BLIST_SPARSELUN},\n\t{\"SGI\", \"RAID5\", \"*\", BLIST_SPARSELUN},\n\t{\"SGI\", \"TP9100\", \"*\", BLIST_REPORTLUN2},\n\t{\"SGI\", \"Universal Xport\", \"*\", BLIST_NO_ULD_ATTACH},\n\t{\"SKhynix\", \"H28U74301AMR\", NULL, BLIST_SKIP_VPD_PAGES},\n\t{\"IBM\", \"Universal Xport\", \"*\", BLIST_NO_ULD_ATTACH},\n\t{\"SUN\", \"Universal Xport\", \"*\", BLIST_NO_ULD_ATTACH},\n\t{\"DELL\", \"Universal Xport\", \"*\", BLIST_NO_ULD_ATTACH},\n\t{\"STK\", \"Universal Xport\", \"*\", BLIST_NO_ULD_ATTACH},\n\t{\"NETAPP\", \"Universal Xport\", \"*\", BLIST_NO_ULD_ATTACH},\n\t{\"LSI\", \"Universal Xport\", \"*\", BLIST_NO_ULD_ATTACH},\n\t{\"ENGENIO\", \"Universal Xport\", \"*\", BLIST_NO_ULD_ATTACH},\n\t{\"LENOVO\", \"Universal Xport\", \"*\", BLIST_NO_ULD_ATTACH},\n\t{\"FUJITSU\", \"Universal Xport\", \"*\", BLIST_NO_ULD_ATTACH},\n\t{\"SanDisk\", \"Cruzer Blade\", NULL, BLIST_TRY_VPD_PAGES |\n\t\tBLIST_INQUIRY_36},\n\t{\"SMSC\", \"USB 2 HS-CF\", NULL, BLIST_SPARSELUN | BLIST_INQUIRY_36},\n\t{\"SONY\", \"CD-ROM CDU-8001\", NULL, BLIST_BORKEN},\n\t{\"SONY\", \"TSL\", NULL, BLIST_FORCELUN},\t\t \n\t{\"ST650211\", \"CF\", NULL, BLIST_RETRY_HWERROR},\n\t{\"SUN\", \"T300\", \"*\", BLIST_SPARSELUN},\n\t{\"SUN\", \"T4\", \"*\", BLIST_SPARSELUN},\n\t{\"Tornado-\", \"F4\", \"*\", BLIST_NOREPORTLUN},\n\t{\"TOSHIBA\", \"CDROM\", NULL, BLIST_ISROM},\n\t{\"TOSHIBA\", \"CD-ROM\", NULL, BLIST_ISROM},\n\t{\"Traxdata\", \"CDR4120\", NULL, BLIST_NOLUN},\t \n\t{\"USB2.0\", \"SMARTMEDIA/XD\", NULL, BLIST_FORCELUN | BLIST_INQUIRY_36},\n\t{\"WangDAT\", \"Model 2600\", \"01.7\", BLIST_SELECT_NO_ATN},\n\t{\"WangDAT\", \"Model 3200\", \"02.2\", BLIST_SELECT_NO_ATN},\n\t{\"WangDAT\", \"Model 1300\", \"02.4\", BLIST_SELECT_NO_ATN},\n\t{\"WDC WD25\", \"00JB-00FUA0\", NULL, BLIST_NOREPORTLUN},\n\t{\"XYRATEX\", \"RS\", \"*\", BLIST_SPARSELUN | BLIST_LARGELUN},\n\t{\"Zzyzx\", \"RocketStor 500S\", NULL, BLIST_SPARSELUN},\n\t{\"Zzyzx\", \"RocketStor 2000\", NULL, BLIST_SPARSELUN},\n\t{ NULL, NULL, NULL, 0 },\n};\n\nstatic struct scsi_dev_info_list_table *scsi_devinfo_lookup_by_key(int key)\n{\n\tstruct scsi_dev_info_list_table *devinfo_table;\n\tint found = 0;\n\n\tlist_for_each_entry(devinfo_table, &scsi_dev_info_list, node)\n\t\tif (devinfo_table->key == key) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\tif (!found)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn devinfo_table;\n}\n\n \nstatic void scsi_strcpy_devinfo(char *name, char *to, size_t to_length,\n\t\t\t\tchar *from, int compatible)\n{\n\tsize_t from_length;\n\n\tfrom_length = strlen(from);\n\t \n\tstrncpy(to, from, to_length);\n\tif (from_length < to_length && !compatible) {\n\t\t \n\t\tmemset(&to[from_length], ' ', to_length - from_length);\n\t}\n\tif (from_length > to_length)\n\t\t printk(KERN_WARNING \"%s: %s string '%s' is too long\\n\",\n\t\t\t__func__, name, from);\n}\n\n \nstatic int scsi_dev_info_list_add(int compatible, char *vendor, char *model,\n\t\t\t    char *strflags, blist_flags_t flags)\n{\n\treturn scsi_dev_info_list_add_keyed(compatible, vendor, model,\n\t\t\t\t\t    strflags, flags,\n\t\t\t\t\t    SCSI_DEVINFO_GLOBAL);\n}\n\n \nint scsi_dev_info_list_add_keyed(int compatible, char *vendor, char *model,\n\t\t\t\t char *strflags, blist_flags_t flags,\n\t\t\t\t enum scsi_devinfo_key key)\n{\n\tstruct scsi_dev_info_list *devinfo;\n\tstruct scsi_dev_info_list_table *devinfo_table =\n\t\tscsi_devinfo_lookup_by_key(key);\n\n\tif (IS_ERR(devinfo_table))\n\t\treturn PTR_ERR(devinfo_table);\n\n\tdevinfo = kmalloc(sizeof(*devinfo), GFP_KERNEL);\n\tif (!devinfo) {\n\t\tprintk(KERN_ERR \"%s: no memory\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tscsi_strcpy_devinfo(\"vendor\", devinfo->vendor, sizeof(devinfo->vendor),\n\t\t\t    vendor, compatible);\n\tscsi_strcpy_devinfo(\"model\", devinfo->model, sizeof(devinfo->model),\n\t\t\t    model, compatible);\n\n\tif (strflags) {\n\t\tunsigned long long val;\n\t\tint ret = kstrtoull(strflags, 0, &val);\n\n\t\tif (ret != 0) {\n\t\t\tkfree(devinfo);\n\t\t\treturn ret;\n\t\t}\n\t\tflags = (__force blist_flags_t)val;\n\t}\n\tif (flags & __BLIST_UNUSED_MASK) {\n\t\tpr_err(\"scsi_devinfo (%s:%s): unsupported flags 0x%llx\",\n\t\t       vendor, model, flags & __BLIST_UNUSED_MASK);\n\t\tkfree(devinfo);\n\t\treturn -EINVAL;\n\t}\n\tdevinfo->flags = flags;\n\tdevinfo->compatible = compatible;\n\n\tif (compatible)\n\t\tlist_add_tail(&devinfo->dev_info_list,\n\t\t\t      &devinfo_table->scsi_dev_info_list);\n\telse\n\t\tlist_add(&devinfo->dev_info_list,\n\t\t\t &devinfo_table->scsi_dev_info_list);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(scsi_dev_info_list_add_keyed);\n\n \nstatic struct scsi_dev_info_list *scsi_dev_info_list_find(const char *vendor,\n\t\tconst char *model, enum scsi_devinfo_key key)\n{\n\tstruct scsi_dev_info_list *devinfo;\n\tstruct scsi_dev_info_list_table *devinfo_table =\n\t\tscsi_devinfo_lookup_by_key(key);\n\tsize_t vmax, mmax, mlen;\n\tconst char *vskip, *mskip;\n\n\tif (IS_ERR(devinfo_table))\n\t\treturn (struct scsi_dev_info_list *) devinfo_table;\n\n\t \n\n\t \n\tvmax = sizeof(devinfo->vendor);\n\tvskip = vendor;\n\twhile (vmax > 0 && *vskip == ' ') {\n\t\tvmax--;\n\t\tvskip++;\n\t}\n\t \n\twhile (vmax > 0 && vskip[vmax - 1] == ' ')\n\t\t--vmax;\n\n\tmmax = sizeof(devinfo->model);\n\tmskip = model;\n\twhile (mmax > 0 && *mskip == ' ') {\n\t\tmmax--;\n\t\tmskip++;\n\t}\n\twhile (mmax > 0 && mskip[mmax - 1] == ' ')\n\t\t--mmax;\n\n\tlist_for_each_entry(devinfo, &devinfo_table->scsi_dev_info_list,\n\t\t\t    dev_info_list) {\n\t\tif (devinfo->compatible) {\n\t\t\t \n\t\t\tif (vmax != strnlen(devinfo->vendor,\n\t\t\t\t\t    sizeof(devinfo->vendor)) ||\n\t\t\t    memcmp(devinfo->vendor, vskip, vmax))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tmlen = strnlen(devinfo->model, sizeof(devinfo->model));\n\t\t\tif (mmax < mlen || memcmp(devinfo->model, mskip, mlen))\n\t\t\t\tcontinue;\n\t\t\treturn devinfo;\n\t\t} else {\n\t\t\tif (!memcmp(devinfo->vendor, vendor,\n\t\t\t\t    sizeof(devinfo->vendor)) &&\n\t\t\t    !memcmp(devinfo->model, model,\n\t\t\t\t    sizeof(devinfo->model)))\n\t\t\t\treturn devinfo;\n\t\t}\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\n \nint scsi_dev_info_list_del_keyed(char *vendor, char *model,\n\t\t\t\t enum scsi_devinfo_key key)\n{\n\tstruct scsi_dev_info_list *found;\n\n\tfound = scsi_dev_info_list_find(vendor, model, key);\n\tif (IS_ERR(found))\n\t\treturn PTR_ERR(found);\n\n\tlist_del(&found->dev_info_list);\n\tkfree(found);\n\treturn 0;\n}\nEXPORT_SYMBOL(scsi_dev_info_list_del_keyed);\n\n \nstatic int scsi_dev_info_list_add_str(char *dev_list)\n{\n\tchar *vendor, *model, *strflags, *next;\n\tchar *next_check;\n\tint res = 0;\n\n\tnext = dev_list;\n\tif (next && next[0] == '\"') {\n\t\t \n\t\tnext++;\n\t\tnext_check = \",\\\"\";\n\t} else {\n\t\tnext_check = \",\";\n\t}\n\n\t \n\tfor (vendor = strsep(&next, \":\"); vendor && (vendor[0] != '\\0')\n\t     && (res == 0); vendor = strsep(&next, \":\")) {\n\t\tstrflags = NULL;\n\t\tmodel = strsep(&next, \":\");\n\t\tif (model)\n\t\t\tstrflags = strsep(&next, next_check);\n\t\tif (!model || !strflags) {\n\t\t\tprintk(KERN_ERR \"%s: bad dev info string '%s' '%s'\"\n\t\t\t       \" '%s'\\n\", __func__, vendor, model,\n\t\t\t       strflags);\n\t\t\tres = -EINVAL;\n\t\t} else\n\t\t\tres = scsi_dev_info_list_add(0  , vendor,\n\t\t\t\t\t\t     model, strflags, 0);\n\t}\n\treturn res;\n}\n\n \nblist_flags_t scsi_get_device_flags(struct scsi_device *sdev,\n\t\t\t\t    const unsigned char *vendor,\n\t\t\t\t    const unsigned char *model)\n{\n\treturn scsi_get_device_flags_keyed(sdev, vendor, model,\n\t\t\t\t\t   SCSI_DEVINFO_GLOBAL);\n}\n\n\n \nblist_flags_t scsi_get_device_flags_keyed(struct scsi_device *sdev,\n\t\t\t\tconst unsigned char *vendor,\n\t\t\t\tconst unsigned char *model,\n\t\t\t\tenum scsi_devinfo_key key)\n{\n\tstruct scsi_dev_info_list *devinfo;\n\n\tdevinfo = scsi_dev_info_list_find(vendor, model, key);\n\tif (!IS_ERR(devinfo))\n\t\treturn devinfo->flags;\n\n\t \n\tif (key != SCSI_DEVINFO_GLOBAL)\n\t\treturn 0;\n\n\t \n\tif (sdev->sdev_bflags)\n\t\treturn sdev->sdev_bflags;\n\n\treturn scsi_default_dev_flags;\n}\nEXPORT_SYMBOL(scsi_get_device_flags_keyed);\n\n#ifdef CONFIG_SCSI_PROC_FS\nstruct double_list {\n\tstruct list_head *top;\n\tstruct list_head *bottom;\n};\n\nstatic int devinfo_seq_show(struct seq_file *m, void *v)\n{\n\tstruct double_list *dl = v;\n\tstruct scsi_dev_info_list_table *devinfo_table =\n\t\tlist_entry(dl->top, struct scsi_dev_info_list_table, node);\n\tstruct scsi_dev_info_list *devinfo =\n\t\tlist_entry(dl->bottom, struct scsi_dev_info_list,\n\t\t\t   dev_info_list);\n\n\tif (devinfo_table->scsi_dev_info_list.next == dl->bottom &&\n\t    devinfo_table->name)\n\t\tseq_printf(m, \"[%s]:\\n\", devinfo_table->name);\n\n\tseq_printf(m, \"'%.8s' '%.16s' 0x%llx\\n\",\n\t\t   devinfo->vendor, devinfo->model, devinfo->flags);\n\treturn 0;\n}\n\nstatic void *devinfo_seq_start(struct seq_file *m, loff_t *ppos)\n{\n\tstruct double_list *dl = kmalloc(sizeof(*dl), GFP_KERNEL);\n\tloff_t pos = *ppos;\n\n\tif (!dl)\n\t\treturn NULL;\n\n\tlist_for_each(dl->top, &scsi_dev_info_list) {\n\t\tstruct scsi_dev_info_list_table *devinfo_table =\n\t\t\tlist_entry(dl->top, struct scsi_dev_info_list_table,\n\t\t\t\t   node);\n\t\tlist_for_each(dl->bottom, &devinfo_table->scsi_dev_info_list)\n\t\t\tif (pos-- == 0)\n\t\t\t\treturn dl;\n\t}\n\n\tkfree(dl);\n\treturn NULL;\n}\n\nstatic void *devinfo_seq_next(struct seq_file *m, void *v, loff_t *ppos)\n{\n\tstruct double_list *dl = v;\n\tstruct scsi_dev_info_list_table *devinfo_table =\n\t\tlist_entry(dl->top, struct scsi_dev_info_list_table, node);\n\n\t++*ppos;\n\tdl->bottom = dl->bottom->next;\n\twhile (&devinfo_table->scsi_dev_info_list == dl->bottom) {\n\t\tdl->top = dl->top->next;\n\t\tif (dl->top == &scsi_dev_info_list) {\n\t\t\tkfree(dl);\n\t\t\treturn NULL;\n\t\t}\n\t\tdevinfo_table = list_entry(dl->top,\n\t\t\t\t\t   struct scsi_dev_info_list_table,\n\t\t\t\t\t   node);\n\t\tdl->bottom = devinfo_table->scsi_dev_info_list.next;\n\t}\n\n\treturn dl;\n}\n\nstatic void devinfo_seq_stop(struct seq_file *m, void *v)\n{\n\tkfree(v);\n}\n\nstatic const struct seq_operations scsi_devinfo_seq_ops = {\n\t.start\t= devinfo_seq_start,\n\t.next\t= devinfo_seq_next,\n\t.stop\t= devinfo_seq_stop,\n\t.show\t= devinfo_seq_show,\n};\n\nstatic int proc_scsi_devinfo_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &scsi_devinfo_seq_ops);\n}\n\n \nstatic ssize_t proc_scsi_devinfo_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t length, loff_t *ppos)\n{\n\tchar *buffer;\n\tssize_t err = length;\n\n\tif (!buf || length>PAGE_SIZE)\n\t\treturn -EINVAL;\n\tif (!(buffer = (char *) __get_free_page(GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tif (copy_from_user(buffer, buf, length)) {\n\t\terr =-EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (length < PAGE_SIZE)\n\t\tbuffer[length] = '\\0';\n\telse if (buffer[PAGE_SIZE-1]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tscsi_dev_info_list_add_str(buffer);\n\nout:\n\tfree_page((unsigned long)buffer);\n\treturn err;\n}\n\nstatic const struct proc_ops scsi_devinfo_proc_ops = {\n\t.proc_open\t= proc_scsi_devinfo_open,\n\t.proc_read\t= seq_read,\n\t.proc_write\t= proc_scsi_devinfo_write,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= seq_release,\n};\n#endif  \n\nmodule_param_string(dev_flags, scsi_dev_flags, sizeof(scsi_dev_flags), 0);\nMODULE_PARM_DESC(dev_flags,\n\t \"Given scsi_dev_flags=vendor:model:flags[,v:m:f] add black/white\"\n\t \" list entries for vendor and model with an integer value of flags\"\n\t \" to the scsi device info list\");\n\nmodule_param_named(default_dev_flags, scsi_default_dev_flags, ullong, 0644);\nMODULE_PARM_DESC(default_dev_flags,\n\t\t \"scsi default device flag uint64_t value\");\n\n \nvoid scsi_exit_devinfo(void)\n{\n#ifdef CONFIG_SCSI_PROC_FS\n\tremove_proc_entry(\"scsi/device_info\", NULL);\n#endif\n\n\tscsi_dev_info_remove_list(SCSI_DEVINFO_GLOBAL);\n}\n\n \nint scsi_dev_info_add_list(enum scsi_devinfo_key key, const char *name)\n{\n\tstruct scsi_dev_info_list_table *devinfo_table =\n\t\tscsi_devinfo_lookup_by_key(key);\n\n\tif (!IS_ERR(devinfo_table))\n\t\t \n\t\treturn -EEXIST;\n\n\tdevinfo_table = kmalloc(sizeof(*devinfo_table), GFP_KERNEL);\n\n\tif (!devinfo_table)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&devinfo_table->node);\n\tINIT_LIST_HEAD(&devinfo_table->scsi_dev_info_list);\n\tdevinfo_table->name = name;\n\tdevinfo_table->key = key;\n\tlist_add_tail(&devinfo_table->node, &scsi_dev_info_list);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(scsi_dev_info_add_list);\n\n \nint scsi_dev_info_remove_list(enum scsi_devinfo_key key)\n{\n\tstruct list_head *lh, *lh_next;\n\tstruct scsi_dev_info_list_table *devinfo_table =\n\t\tscsi_devinfo_lookup_by_key(key);\n\n\tif (IS_ERR(devinfo_table))\n\t\t \n\t\treturn -EINVAL;\n\n\t \n\tlist_del(&devinfo_table->node);\n\n\tlist_for_each_safe(lh, lh_next, &devinfo_table->scsi_dev_info_list) {\n\t\tstruct scsi_dev_info_list *devinfo;\n\n\t\tdevinfo = list_entry(lh, struct scsi_dev_info_list,\n\t\t\t\t     dev_info_list);\n\t\tkfree(devinfo);\n\t}\n\tkfree(devinfo_table);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(scsi_dev_info_remove_list);\n\n \nint __init scsi_init_devinfo(void)\n{\n#ifdef CONFIG_SCSI_PROC_FS\n\tstruct proc_dir_entry *p;\n#endif\n\tint error, i;\n\n\terror = scsi_dev_info_add_list(SCSI_DEVINFO_GLOBAL, NULL);\n\tif (error)\n\t\treturn error;\n\n\terror = scsi_dev_info_list_add_str(scsi_dev_flags);\n\tif (error)\n\t\tgoto out;\n\n\tfor (i = 0; scsi_static_device_list[i].vendor; i++) {\n\t\terror = scsi_dev_info_list_add(1  ,\n\t\t\t\tscsi_static_device_list[i].vendor,\n\t\t\t\tscsi_static_device_list[i].model,\n\t\t\t\tNULL,\n\t\t\t\tscsi_static_device_list[i].flags);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n#ifdef CONFIG_SCSI_PROC_FS\n\tp = proc_create(\"scsi/device_info\", 0, NULL, &scsi_devinfo_proc_ops);\n\tif (!p) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n#endif  \n\n out:\n\tif (error)\n\t\tscsi_exit_devinfo();\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}