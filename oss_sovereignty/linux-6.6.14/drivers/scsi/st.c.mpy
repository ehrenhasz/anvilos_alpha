{
  "module_name": "st.c",
  "hash_id": "8a00cf1a3daea2dd30d979c23f0f0dea7f9efbc6415adebb8038b21a5c956a09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/st.c",
  "human_readable_source": "\n \n\nstatic const char *verstr = \"20160209\";\n\n#include <linux/module.h>\n\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/mtio.h>\n#include <linux/major.h>\n#include <linux/cdrom.h>\n#include <linux/ioctl.h>\n#include <linux/fcntl.h>\n#include <linux/spinlock.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/cdev.h>\n#include <linux/idr.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n\n#include <linux/uaccess.h>\n#include <asm/dma.h>\n#include <asm/unaligned.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_driver.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_ioctl.h>\n#include <scsi/sg.h>\n\n\n \n#define DEBUG 1\n#define NO_DEBUG 0\n\n#define ST_DEB_MSG  KERN_NOTICE\n#if DEBUG\n \n#define DEB(a) a\n#define DEBC(a) if (debugging) { a ; }\n#else\n#define DEB(a)\n#define DEBC(a)\n#endif\n\n#define ST_KILOBYTE 1024\n\n#include \"st_options.h\"\n#include \"st.h\"\n\nstatic int buffer_kbs;\nstatic int max_sg_segs;\nstatic int try_direct_io = TRY_DIRECT_IO;\nstatic int try_rdio = 1;\nstatic int try_wdio = 1;\nstatic int debug_flag;\n\nstatic struct class st_sysfs_class;\nstatic const struct attribute_group *st_dev_groups[];\nstatic const struct attribute_group *st_drv_groups[];\n\nMODULE_AUTHOR(\"Kai Makisara\");\nMODULE_DESCRIPTION(\"SCSI tape (st) driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_CHARDEV_MAJOR(SCSI_TAPE_MAJOR);\nMODULE_ALIAS_SCSI_DEVICE(TYPE_TAPE);\n\n \nmodule_param_named(buffer_kbs, buffer_kbs, int, 0);\nMODULE_PARM_DESC(buffer_kbs, \"Default driver buffer size for fixed block mode (KB; 32)\");\nmodule_param_named(max_sg_segs, max_sg_segs, int, 0);\nMODULE_PARM_DESC(max_sg_segs, \"Maximum number of scatter/gather segments to use (256)\");\nmodule_param_named(try_direct_io, try_direct_io, int, 0);\nMODULE_PARM_DESC(try_direct_io, \"Try direct I/O between user buffer and tape drive (1)\");\nmodule_param_named(debug_flag, debug_flag, int, 0);\nMODULE_PARM_DESC(debug_flag, \"Enable DEBUG, same as setting debugging=1\");\n\n\n \nmodule_param_named(try_rdio, try_rdio, int, 0);\nMODULE_PARM_DESC(try_rdio, \"Try direct read i/o when possible\");\nmodule_param_named(try_wdio, try_wdio, int, 0);\nMODULE_PARM_DESC(try_wdio, \"Try direct write i/o when possible\");\n\n#ifndef MODULE\nstatic int write_threshold_kbs;   \nstatic struct st_dev_parm {\n\tchar *name;\n\tint *val;\n} parms[] __initdata = {\n\t{\n\t\t\"buffer_kbs\", &buffer_kbs\n\t},\n\t{        \n\t\t\"write_threshold_kbs\", &write_threshold_kbs\n\t},\n\t{\n\t\t\"max_sg_segs\", NULL\n\t},\n\t{\n\t\t\"try_direct_io\", &try_direct_io\n\t},\n\t{\n\t\t\"debug_flag\", &debug_flag\n\t}\n};\n#endif\n\n \n#if ST_NBR_MODES > 16\n#error \"Maximum number of modes is 16\"\n#endif\n \nstatic const char *st_formats[] = {\n\t\"\",  \"r\", \"k\", \"s\", \"l\", \"t\", \"o\", \"u\",\n\t\"m\", \"v\", \"p\", \"x\", \"a\", \"y\", \"q\", \"z\"}; \n\n \n\n#define ST_FIXED_BUFFER_SIZE (ST_FIXED_BUFFER_BLOCKS * ST_KILOBYTE)\n\n \n#if ST_FIXED_BUFFER_SIZE >= (2 << 24 - 1)\n#error \"Buffer size should not exceed (2 << 24 - 1) bytes!\"\n#endif\n\nstatic int debugging = DEBUG;\n\n#define MAX_RETRIES 0\n#define MAX_WRITE_RETRIES 0\n#define MAX_READY_RETRIES 0\n#define NO_TAPE  NOT_READY\n\n#define ST_TIMEOUT (900 * HZ)\n#define ST_LONG_TIMEOUT (14000 * HZ)\n\n \n#define TAPE_NR(x) ( ((iminor(x) & ~255) >> (ST_NBR_MODE_BITS + 1)) | \\\n\t(iminor(x) & ((1 << ST_MODE_SHIFT)-1)))\n#define TAPE_MODE(x) ((iminor(x) & ST_MODE_MASK) >> ST_MODE_SHIFT)\n\n \n#define TAPE_MINOR(d, m, n) (((d & ~(255 >> (ST_NBR_MODE_BITS + 1))) << (ST_NBR_MODE_BITS + 1)) | \\\n  (d & (255 >> (ST_NBR_MODE_BITS + 1))) | (m << ST_MODE_SHIFT) | ((n != 0) << 7) )\n\n \n#define SET_DENS_AND_BLK 0x10001\n\nstatic int st_fixed_buffer_size = ST_FIXED_BUFFER_SIZE;\nstatic int st_max_sg_segs = ST_MAX_SG;\n\nstatic int modes_defined;\n\nstatic int enlarge_buffer(struct st_buffer *, int);\nstatic void clear_buffer(struct st_buffer *);\nstatic void normalize_buffer(struct st_buffer *);\nstatic int append_to_buffer(const char __user *, struct st_buffer *, int);\nstatic int from_buffer(struct st_buffer *, char __user *, int);\nstatic void move_buffer_data(struct st_buffer *, int);\n\nstatic int sgl_map_user_pages(struct st_buffer *, const unsigned int,\n\t\t\t      unsigned long, size_t, int);\nstatic int sgl_unmap_user_pages(struct st_buffer *, const unsigned int, int);\n\nstatic int st_probe(struct device *);\nstatic int st_remove(struct device *);\n\nstatic struct scsi_driver st_template = {\n\t.gendrv = {\n\t\t.name\t\t= \"st\",\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.probe\t\t= st_probe,\n\t\t.remove\t\t= st_remove,\n\t\t.groups\t\t= st_drv_groups,\n\t},\n};\n\nstatic int st_compression(struct scsi_tape *, int);\n\nstatic int find_partition(struct scsi_tape *);\nstatic int switch_partition(struct scsi_tape *);\n\nstatic int st_int_ioctl(struct scsi_tape *, unsigned int, unsigned long);\n\nstatic void scsi_tape_release(struct kref *);\n\n#define to_scsi_tape(obj) container_of(obj, struct scsi_tape, kref)\n\nstatic DEFINE_MUTEX(st_ref_mutex);\nstatic DEFINE_SPINLOCK(st_index_lock);\nstatic DEFINE_SPINLOCK(st_use_lock);\nstatic DEFINE_IDR(st_index_idr);\n\n\n\f\n#ifndef SIGS_FROM_OSST\n#define SIGS_FROM_OSST \\\n\t{\"OnStream\", \"SC-\", \"\", \"osst\"}, \\\n\t{\"OnStream\", \"DI-\", \"\", \"osst\"}, \\\n\t{\"OnStream\", \"DP-\", \"\", \"osst\"}, \\\n\t{\"OnStream\", \"USB\", \"\", \"osst\"}, \\\n\t{\"OnStream\", \"FW-\", \"\", \"osst\"}\n#endif\n\nstatic struct scsi_tape *scsi_tape_get(int dev)\n{\n\tstruct scsi_tape *STp = NULL;\n\n\tmutex_lock(&st_ref_mutex);\n\tspin_lock(&st_index_lock);\n\n\tSTp = idr_find(&st_index_idr, dev);\n\tif (!STp) goto out;\n\n\tkref_get(&STp->kref);\n\n\tif (!STp->device)\n\t\tgoto out_put;\n\n\tif (scsi_device_get(STp->device))\n\t\tgoto out_put;\n\n\tgoto out;\n\nout_put:\n\tkref_put(&STp->kref, scsi_tape_release);\n\tSTp = NULL;\nout:\n\tspin_unlock(&st_index_lock);\n\tmutex_unlock(&st_ref_mutex);\n\treturn STp;\n}\n\nstatic void scsi_tape_put(struct scsi_tape *STp)\n{\n\tstruct scsi_device *sdev = STp->device;\n\n\tmutex_lock(&st_ref_mutex);\n\tkref_put(&STp->kref, scsi_tape_release);\n\tscsi_device_put(sdev);\n\tmutex_unlock(&st_ref_mutex);\n}\n\nstruct st_reject_data {\n\tchar *vendor;\n\tchar *model;\n\tchar *rev;\n\tchar *driver_hint;  \n};\n\nstatic struct st_reject_data reject_list[] = {\n\t \n\tSIGS_FROM_OSST,\n\t{NULL, }};\n\n \nstatic char * st_incompatible(struct scsi_device* SDp)\n{\n\tstruct st_reject_data *rp;\n\n\tfor (rp=&(reject_list[0]); rp->vendor != NULL; rp++)\n\t\tif (!strncmp(rp->vendor, SDp->vendor, strlen(rp->vendor)) &&\n\t\t    !strncmp(rp->model, SDp->model, strlen(rp->model)) &&\n\t\t    !strncmp(rp->rev, SDp->rev, strlen(rp->rev))) {\n\t\t\tif (rp->driver_hint)\n\t\t\t\treturn rp->driver_hint;\n\t\t\telse\n\t\t\t\treturn \"unknown\";\n\t\t}\n\treturn NULL;\n}\n\f\n\n#define st_printk(prefix, t, fmt, a...) \\\n\tsdev_prefix_printk(prefix, (t)->device, (t)->name, fmt, ##a)\n#ifdef DEBUG\n#define DEBC_printk(t, fmt, a...) \\\n\tif (debugging) { st_printk(ST_DEB_MSG, t, fmt, ##a ); }\n#else\n#define DEBC_printk(t, fmt, a...)\n#endif\n\nstatic void st_analyze_sense(struct st_request *SRpnt, struct st_cmdstatus *s)\n{\n\tconst u8 *ucp;\n\tconst u8 *sense = SRpnt->sense;\n\n\ts->have_sense = scsi_normalize_sense(SRpnt->sense,\n\t\t\t\tSCSI_SENSE_BUFFERSIZE, &s->sense_hdr);\n\ts->flags = 0;\n\n\tif (s->have_sense) {\n\t\ts->deferred = 0;\n\t\ts->remainder_valid =\n\t\t\tscsi_get_sense_info_fld(sense, SCSI_SENSE_BUFFERSIZE, &s->uremainder64);\n\t\tswitch (sense[0] & 0x7f) {\n\t\tcase 0x71:\n\t\t\ts->deferred = 1;\n\t\t\tfallthrough;\n\t\tcase 0x70:\n\t\t\ts->fixed_format = 1;\n\t\t\ts->flags = sense[2] & 0xe0;\n\t\t\tbreak;\n\t\tcase 0x73:\n\t\t\ts->deferred = 1;\n\t\t\tfallthrough;\n\t\tcase 0x72:\n\t\t\ts->fixed_format = 0;\n\t\t\tucp = scsi_sense_desc_find(sense, SCSI_SENSE_BUFFERSIZE, 4);\n\t\t\ts->flags = ucp ? (ucp[3] & 0xe0) : 0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\n \nstatic int st_chk_result(struct scsi_tape *STp, struct st_request * SRpnt)\n{\n\tint result = SRpnt->result;\n\tu8 scode;\n\tDEB(const char *stp;)\n\tchar *name = STp->name;\n\tstruct st_cmdstatus *cmdstatp;\n\n\tif (!result)\n\t\treturn 0;\n\n\tcmdstatp = &STp->buffer->cmdstat;\n\tst_analyze_sense(SRpnt, cmdstatp);\n\n\tif (cmdstatp->have_sense)\n\t\tscode = STp->buffer->cmdstat.sense_hdr.sense_key;\n\telse\n\t\tscode = 0;\n\n\tDEB(\n\tif (debugging) {\n\t\tst_printk(ST_DEB_MSG, STp,\n\t\t\t    \"Error: %x, cmd: %x %x %x %x %x %x\\n\", result,\n\t\t\t    SRpnt->cmd[0], SRpnt->cmd[1], SRpnt->cmd[2],\n\t\t\t    SRpnt->cmd[3], SRpnt->cmd[4], SRpnt->cmd[5]);\n\t\tif (cmdstatp->have_sense)\n\t\t\t__scsi_print_sense(STp->device, name,\n\t\t\t\t\t   SRpnt->sense, SCSI_SENSE_BUFFERSIZE);\n\t} )  \n\tif (!debugging) {  \n\t\tif (!cmdstatp->have_sense)\n\t\t\tst_printk(KERN_WARNING, STp,\n\t\t\t       \"Error %x (driver bt 0, host bt 0x%x).\\n\",\n\t\t\t       result, host_byte(result));\n\t\telse if (cmdstatp->have_sense &&\n\t\t\t scode != NO_SENSE &&\n\t\t\t scode != RECOVERED_ERROR &&\n\t\t\t  \n\t\t\t scode != BLANK_CHECK &&\n\t\t\t scode != VOLUME_OVERFLOW &&\n\t\t\t SRpnt->cmd[0] != MODE_SENSE &&\n\t\t\t SRpnt->cmd[0] != TEST_UNIT_READY) {\n\n\t\t\t__scsi_print_sense(STp->device, name,\n\t\t\t\t\t   SRpnt->sense, SCSI_SENSE_BUFFERSIZE);\n\t\t}\n\t}\n\n\tif (cmdstatp->fixed_format &&\n\t    STp->cln_mode >= EXTENDED_SENSE_START) {   \n\t\tif (STp->cln_sense_value)\n\t\t\tSTp->cleaning_req |= ((SRpnt->sense[STp->cln_mode] &\n\t\t\t\t\t       STp->cln_sense_mask) == STp->cln_sense_value);\n\t\telse\n\t\t\tSTp->cleaning_req |= ((SRpnt->sense[STp->cln_mode] &\n\t\t\t\t\t       STp->cln_sense_mask) != 0);\n\t}\n\tif (cmdstatp->have_sense &&\n\t    cmdstatp->sense_hdr.asc == 0 && cmdstatp->sense_hdr.ascq == 0x17)\n\t\tSTp->cleaning_req = 1;  \n\tif (cmdstatp->have_sense && scode == UNIT_ATTENTION && cmdstatp->sense_hdr.asc == 0x29)\n\t\tSTp->pos_unknown = 1;  \n\n\tSTp->pos_unknown |= STp->device->was_reset;\n\n\tif (cmdstatp->have_sense &&\n\t    scode == RECOVERED_ERROR\n#if ST_RECOVERED_WRITE_FATAL\n\t    && SRpnt->cmd[0] != WRITE_6\n\t    && SRpnt->cmd[0] != WRITE_FILEMARKS\n#endif\n\t    ) {\n\t\tSTp->recover_count++;\n\t\tSTp->recover_reg++;\n\n\t\tDEB(\n\t\tif (debugging) {\n\t\t\tif (SRpnt->cmd[0] == READ_6)\n\t\t\t\tstp = \"read\";\n\t\t\telse if (SRpnt->cmd[0] == WRITE_6)\n\t\t\t\tstp = \"write\";\n\t\t\telse\n\t\t\t\tstp = \"ioctl\";\n\t\t\tst_printk(ST_DEB_MSG, STp,\n\t\t\t\t  \"Recovered %s error (%d).\\n\",\n\t\t\t\t  stp, STp->recover_count);\n\t\t} )  \n\n\t\tif (cmdstatp->flags == 0)\n\t\t\treturn 0;\n\t}\n\treturn (-EIO);\n}\n\nstatic struct st_request *st_allocate_request(struct scsi_tape *stp)\n{\n\tstruct st_request *streq;\n\n\tstreq = kzalloc(sizeof(*streq), GFP_KERNEL);\n\tif (streq)\n\t\tstreq->stp = stp;\n\telse {\n\t\tst_printk(KERN_ERR, stp,\n\t\t\t  \"Can't get SCSI request.\\n\");\n\t\tif (signal_pending(current))\n\t\t\tstp->buffer->syscall_result = -EINTR;\n\t\telse\n\t\t\tstp->buffer->syscall_result = -EBUSY;\n\t}\n\n\treturn streq;\n}\n\nstatic void st_release_request(struct st_request *streq)\n{\n\tkfree(streq);\n}\n\nstatic void st_do_stats(struct scsi_tape *STp, struct request *req)\n{\n\tstruct scsi_cmnd *scmd = blk_mq_rq_to_pdu(req);\n\tktime_t now;\n\n\tnow = ktime_get();\n\tif (scmd->cmnd[0] == WRITE_6) {\n\t\tnow = ktime_sub(now, STp->stats->write_time);\n\t\tatomic64_add(ktime_to_ns(now), &STp->stats->tot_write_time);\n\t\tatomic64_add(ktime_to_ns(now), &STp->stats->tot_io_time);\n\t\tatomic64_inc(&STp->stats->write_cnt);\n\t\tif (scmd->result) {\n\t\t\tatomic64_add(atomic_read(&STp->stats->last_write_size)\n\t\t\t\t- STp->buffer->cmdstat.residual,\n\t\t\t\t&STp->stats->write_byte_cnt);\n\t\t\tif (STp->buffer->cmdstat.residual > 0)\n\t\t\t\tatomic64_inc(&STp->stats->resid_cnt);\n\t\t} else\n\t\t\tatomic64_add(atomic_read(&STp->stats->last_write_size),\n\t\t\t\t&STp->stats->write_byte_cnt);\n\t} else if (scmd->cmnd[0] == READ_6) {\n\t\tnow = ktime_sub(now, STp->stats->read_time);\n\t\tatomic64_add(ktime_to_ns(now), &STp->stats->tot_read_time);\n\t\tatomic64_add(ktime_to_ns(now), &STp->stats->tot_io_time);\n\t\tatomic64_inc(&STp->stats->read_cnt);\n\t\tif (scmd->result) {\n\t\t\tatomic64_add(atomic_read(&STp->stats->last_read_size)\n\t\t\t\t- STp->buffer->cmdstat.residual,\n\t\t\t\t&STp->stats->read_byte_cnt);\n\t\t\tif (STp->buffer->cmdstat.residual > 0)\n\t\t\t\tatomic64_inc(&STp->stats->resid_cnt);\n\t\t} else\n\t\t\tatomic64_add(atomic_read(&STp->stats->last_read_size),\n\t\t\t\t&STp->stats->read_byte_cnt);\n\t} else {\n\t\tnow = ktime_sub(now, STp->stats->other_time);\n\t\tatomic64_add(ktime_to_ns(now), &STp->stats->tot_io_time);\n\t\tatomic64_inc(&STp->stats->other_cnt);\n\t}\n\tatomic64_dec(&STp->stats->in_flight);\n}\n\nstatic enum rq_end_io_ret st_scsi_execute_end(struct request *req,\n\t\t\t\t\t      blk_status_t status)\n{\n\tstruct scsi_cmnd *scmd = blk_mq_rq_to_pdu(req);\n\tstruct st_request *SRpnt = req->end_io_data;\n\tstruct scsi_tape *STp = SRpnt->stp;\n\tstruct bio *tmp;\n\n\tSTp->buffer->cmdstat.midlevel_result = SRpnt->result = scmd->result;\n\tSTp->buffer->cmdstat.residual = scmd->resid_len;\n\n\tst_do_stats(STp, req);\n\n\ttmp = SRpnt->bio;\n\tif (scmd->sense_len)\n\t\tmemcpy(SRpnt->sense, scmd->sense_buffer, SCSI_SENSE_BUFFERSIZE);\n\tif (SRpnt->waiting)\n\t\tcomplete(SRpnt->waiting);\n\n\tblk_rq_unmap_user(tmp);\n\tblk_mq_free_request(req);\n\treturn RQ_END_IO_NONE;\n}\n\nstatic int st_scsi_execute(struct st_request *SRpnt, const unsigned char *cmd,\n\t\t\t   int data_direction, void *buffer, unsigned bufflen,\n\t\t\t   int timeout, int retries)\n{\n\tstruct request *req;\n\tstruct rq_map_data *mdata = &SRpnt->stp->buffer->map_data;\n\tint err = 0;\n\tstruct scsi_tape *STp = SRpnt->stp;\n\tstruct scsi_cmnd *scmd;\n\n\treq = scsi_alloc_request(SRpnt->stp->device->request_queue,\n\t\t\tdata_direction == DMA_TO_DEVICE ?\n\t\t\tREQ_OP_DRV_OUT : REQ_OP_DRV_IN, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\tscmd = blk_mq_rq_to_pdu(req);\n\treq->rq_flags |= RQF_QUIET;\n\n\tmdata->null_mapped = 1;\n\n\tif (bufflen) {\n\t\terr = blk_rq_map_user(req->q, req, mdata, NULL, bufflen,\n\t\t\t\t      GFP_KERNEL);\n\t\tif (err) {\n\t\t\tblk_mq_free_request(req);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tatomic64_inc(&STp->stats->in_flight);\n\tif (cmd[0] == WRITE_6) {\n\t\tatomic_set(&STp->stats->last_write_size, bufflen);\n\t\tSTp->stats->write_time = ktime_get();\n\t} else if (cmd[0] == READ_6) {\n\t\tatomic_set(&STp->stats->last_read_size, bufflen);\n\t\tSTp->stats->read_time = ktime_get();\n\t} else {\n\t\tSTp->stats->other_time = ktime_get();\n\t}\n\n\tSRpnt->bio = req->bio;\n\tscmd->cmd_len = COMMAND_SIZE(cmd[0]);\n\tmemcpy(scmd->cmnd, cmd, scmd->cmd_len);\n\treq->timeout = timeout;\n\tscmd->allowed = retries;\n\treq->end_io = st_scsi_execute_end;\n\treq->end_io_data = SRpnt;\n\n\tblk_execute_rq_nowait(req, true);\n\treturn 0;\n}\n\n \nstatic struct st_request *\nst_do_scsi(struct st_request * SRpnt, struct scsi_tape * STp, unsigned char *cmd,\n\t   int bytes, int direction, int timeout, int retries, int do_wait)\n{\n\tstruct completion *waiting;\n\tstruct rq_map_data *mdata = &STp->buffer->map_data;\n\tint ret;\n\n\t \n\tif (!do_wait && ((STp->buffer)->last_SRpnt)) {\n\t\tst_printk(KERN_ERR, STp,\n\t\t\t  \"Async command already active.\\n\");\n\t\tif (signal_pending(current))\n\t\t\t(STp->buffer)->syscall_result = (-EINTR);\n\t\telse\n\t\t\t(STp->buffer)->syscall_result = (-EBUSY);\n\t\treturn NULL;\n\t}\n\n\tif (!SRpnt) {\n\t\tSRpnt = st_allocate_request(STp);\n\t\tif (!SRpnt)\n\t\t\treturn NULL;\n\t}\n\n\t \n\tif (!do_wait)\n\t\t(STp->buffer)->last_SRpnt = SRpnt;\n\n\twaiting = &STp->wait;\n\tinit_completion(waiting);\n\tSRpnt->waiting = waiting;\n\n\tif (STp->buffer->do_dio) {\n\t\tmdata->page_order = 0;\n\t\tmdata->nr_entries = STp->buffer->sg_segs;\n\t\tmdata->pages = STp->buffer->mapped_pages;\n\t} else {\n\t\tmdata->page_order = STp->buffer->reserved_page_order;\n\t\tmdata->nr_entries =\n\t\t\tDIV_ROUND_UP(bytes, PAGE_SIZE << mdata->page_order);\n\t\tmdata->pages = STp->buffer->reserved_pages;\n\t\tmdata->offset = 0;\n\t}\n\n\tmemcpy(SRpnt->cmd, cmd, sizeof(SRpnt->cmd));\n\tSTp->buffer->cmdstat.have_sense = 0;\n\tSTp->buffer->syscall_result = 0;\n\n\tret = st_scsi_execute(SRpnt, cmd, direction, NULL, bytes, timeout,\n\t\t\t      retries);\n\tif (ret) {\n\t\t \n\t\t(STp->buffer)->syscall_result = (-EBUSY);\n\t\t(STp->buffer)->last_SRpnt = NULL;\n\t} else if (do_wait) {\n\t\twait_for_completion(waiting);\n\t\tSRpnt->waiting = NULL;\n\t\t(STp->buffer)->syscall_result = st_chk_result(STp, SRpnt);\n\t}\n\n\treturn SRpnt;\n}\n\n\n \nstatic int write_behind_check(struct scsi_tape * STp)\n{\n\tint retval = 0;\n\tstruct st_buffer *STbuffer;\n\tstruct st_partstat *STps;\n\tstruct st_cmdstatus *cmdstatp;\n\tstruct st_request *SRpnt;\n\n\tSTbuffer = STp->buffer;\n\tif (!STbuffer->writing)\n\t\treturn 0;\n\n\tDEB(\n\tif (STp->write_pending)\n\t\tSTp->nbr_waits++;\n\telse\n\t\tSTp->nbr_finished++;\n\t)  \n\n\twait_for_completion(&(STp->wait));\n\tSRpnt = STbuffer->last_SRpnt;\n\tSTbuffer->last_SRpnt = NULL;\n\tSRpnt->waiting = NULL;\n\n\t(STp->buffer)->syscall_result = st_chk_result(STp, SRpnt);\n\tst_release_request(SRpnt);\n\n\tSTbuffer->buffer_bytes -= STbuffer->writing;\n\tSTps = &(STp->ps[STp->partition]);\n\tif (STps->drv_block >= 0) {\n\t\tif (STp->block_size == 0)\n\t\t\tSTps->drv_block++;\n\t\telse\n\t\t\tSTps->drv_block += STbuffer->writing / STp->block_size;\n\t}\n\n\tcmdstatp = &STbuffer->cmdstat;\n\tif (STbuffer->syscall_result) {\n\t\tretval = -EIO;\n\t\tif (cmdstatp->have_sense && !cmdstatp->deferred &&\n\t\t    (cmdstatp->flags & SENSE_EOM) &&\n\t\t    (cmdstatp->sense_hdr.sense_key == NO_SENSE ||\n\t\t     cmdstatp->sense_hdr.sense_key == RECOVERED_ERROR)) {\n\t\t\t \n\t\t\tif (!cmdstatp->remainder_valid ||\n\t\t\t    cmdstatp->uremainder64 == 0)\n\t\t\t\tretval = -ENOSPC;\n\t\t}\n\t\tif (retval == -EIO)\n\t\t\tSTps->drv_block = -1;\n\t}\n\tSTbuffer->writing = 0;\n\n\tDEB(if (debugging && retval)\n\t\t    st_printk(ST_DEB_MSG, STp,\n\t\t\t\t\"Async write error %x, return value %d.\\n\",\n\t\t\t\tSTbuffer->cmdstat.midlevel_result, retval);)  \n\n\treturn retval;\n}\n\n\n \nstatic int cross_eof(struct scsi_tape * STp, int forward)\n{\n\tstruct st_request *SRpnt;\n\tunsigned char cmd[MAX_COMMAND_SIZE];\n\n\tcmd[0] = SPACE;\n\tcmd[1] = 0x01;\t\t \n\tif (forward) {\n\t\tcmd[2] = cmd[3] = 0;\n\t\tcmd[4] = 1;\n\t} else\n\t\tcmd[2] = cmd[3] = cmd[4] = 0xff;\t \n\tcmd[5] = 0;\n\n\tDEBC_printk(STp, \"Stepping over filemark %s.\\n\",\n\t\t    forward ? \"forward\" : \"backward\");\n\n\tSRpnt = st_do_scsi(NULL, STp, cmd, 0, DMA_NONE,\n\t\t\t   STp->device->request_queue->rq_timeout,\n\t\t\t   MAX_RETRIES, 1);\n\tif (!SRpnt)\n\t\treturn (STp->buffer)->syscall_result;\n\n\tst_release_request(SRpnt);\n\tSRpnt = NULL;\n\n\tif ((STp->buffer)->cmdstat.midlevel_result != 0)\n\t\tst_printk(KERN_ERR, STp,\n\t\t\t  \"Stepping over filemark %s failed.\\n\",\n\t\t\t  forward ? \"forward\" : \"backward\");\n\n\treturn (STp->buffer)->syscall_result;\n}\n\n\n \nstatic int st_flush_write_buffer(struct scsi_tape * STp)\n{\n\tint transfer, blks;\n\tint result;\n\tunsigned char cmd[MAX_COMMAND_SIZE];\n\tstruct st_request *SRpnt;\n\tstruct st_partstat *STps;\n\n\tresult = write_behind_check(STp);\n\tif (result)\n\t\treturn result;\n\n\tresult = 0;\n\tif (STp->dirty == 1) {\n\n\t\ttransfer = STp->buffer->buffer_bytes;\n\t\tDEBC_printk(STp, \"Flushing %d bytes.\\n\", transfer);\n\n\t\tmemset(cmd, 0, MAX_COMMAND_SIZE);\n\t\tcmd[0] = WRITE_6;\n\t\tcmd[1] = 1;\n\t\tblks = transfer / STp->block_size;\n\t\tcmd[2] = blks >> 16;\n\t\tcmd[3] = blks >> 8;\n\t\tcmd[4] = blks;\n\n\t\tSRpnt = st_do_scsi(NULL, STp, cmd, transfer, DMA_TO_DEVICE,\n\t\t\t\t   STp->device->request_queue->rq_timeout,\n\t\t\t\t   MAX_WRITE_RETRIES, 1);\n\t\tif (!SRpnt)\n\t\t\treturn (STp->buffer)->syscall_result;\n\n\t\tSTps = &(STp->ps[STp->partition]);\n\t\tif ((STp->buffer)->syscall_result != 0) {\n\t\t\tstruct st_cmdstatus *cmdstatp = &STp->buffer->cmdstat;\n\n\t\t\tif (cmdstatp->have_sense && !cmdstatp->deferred &&\n\t\t\t    (cmdstatp->flags & SENSE_EOM) &&\n\t\t\t    (cmdstatp->sense_hdr.sense_key == NO_SENSE ||\n\t\t\t     cmdstatp->sense_hdr.sense_key == RECOVERED_ERROR) &&\n\t\t\t    (!cmdstatp->remainder_valid ||\n\t\t\t     cmdstatp->uremainder64 == 0)) {  \n\t\t\t\tSTp->dirty = 0;\n\t\t\t\t(STp->buffer)->buffer_bytes = 0;\n\t\t\t\tif (STps->drv_block >= 0)\n\t\t\t\t\tSTps->drv_block += blks;\n\t\t\t\tresult = (-ENOSPC);\n\t\t\t} else {\n\t\t\t\tst_printk(KERN_ERR, STp, \"Error on flush.\\n\");\n\t\t\t\tSTps->drv_block = (-1);\n\t\t\t\tresult = (-EIO);\n\t\t\t}\n\t\t} else {\n\t\t\tif (STps->drv_block >= 0)\n\t\t\t\tSTps->drv_block += blks;\n\t\t\tSTp->dirty = 0;\n\t\t\t(STp->buffer)->buffer_bytes = 0;\n\t\t}\n\t\tst_release_request(SRpnt);\n\t\tSRpnt = NULL;\n\t}\n\treturn result;\n}\n\n\n \nstatic int flush_buffer(struct scsi_tape *STp, int seek_next)\n{\n\tint backspace, result;\n\tstruct st_partstat *STps;\n\n\t \n\tif (STp->pos_unknown)\n\t\treturn (-EIO);\n\n\tif (STp->ready != ST_READY)\n\t\treturn 0;\n\tSTps = &(STp->ps[STp->partition]);\n\tif (STps->rw == ST_WRITING)\t \n\t\treturn st_flush_write_buffer(STp);\n\n\tif (STp->block_size == 0)\n\t\treturn 0;\n\n\tbackspace = ((STp->buffer)->buffer_bytes +\n\t\t     (STp->buffer)->read_pointer) / STp->block_size -\n\t    ((STp->buffer)->read_pointer + STp->block_size - 1) /\n\t    STp->block_size;\n\t(STp->buffer)->buffer_bytes = 0;\n\t(STp->buffer)->read_pointer = 0;\n\tresult = 0;\n\tif (!seek_next) {\n\t\tif (STps->eof == ST_FM_HIT) {\n\t\t\tresult = cross_eof(STp, 0);\t \n\t\t\tif (!result)\n\t\t\t\tSTps->eof = ST_NOEOF;\n\t\t\telse {\n\t\t\t\tif (STps->drv_file >= 0)\n\t\t\t\t\tSTps->drv_file++;\n\t\t\t\tSTps->drv_block = 0;\n\t\t\t}\n\t\t}\n\t\tif (!result && backspace > 0)\n\t\t\tresult = st_int_ioctl(STp, MTBSR, backspace);\n\t} else if (STps->eof == ST_FM_HIT) {\n\t\tif (STps->drv_file >= 0)\n\t\t\tSTps->drv_file++;\n\t\tSTps->drv_block = 0;\n\t\tSTps->eof = ST_NOEOF;\n\t}\n\treturn result;\n\n}\n\f\n \nstatic int set_mode_densblk(struct scsi_tape * STp, struct st_modedef * STm)\n{\n\tint set_it = 0;\n\tunsigned long arg;\n\n\tif (!STp->density_changed &&\n\t    STm->default_density >= 0 &&\n\t    STm->default_density != STp->density) {\n\t\targ = STm->default_density;\n\t\tset_it = 1;\n\t} else\n\t\targ = STp->density;\n\targ <<= MT_ST_DENSITY_SHIFT;\n\tif (!STp->blksize_changed &&\n\t    STm->default_blksize >= 0 &&\n\t    STm->default_blksize != STp->block_size) {\n\t\targ |= STm->default_blksize;\n\t\tset_it = 1;\n\t} else\n\t\targ |= STp->block_size;\n\tif (set_it &&\n\t    st_int_ioctl(STp, SET_DENS_AND_BLK, arg)) {\n\t\tst_printk(KERN_WARNING, STp,\n\t\t\t  \"Can't set default block size to %d bytes \"\n\t\t\t  \"and density %x.\\n\",\n\t\t\t  STm->default_blksize, STm->default_density);\n\t\tif (modes_defined)\n\t\t\treturn (-EINVAL);\n\t}\n\treturn 0;\n}\n\n\n \nstatic int do_door_lock(struct scsi_tape * STp, int do_lock)\n{\n\tint retval;\n\n\tDEBC_printk(STp, \"%socking drive door.\\n\", do_lock ? \"L\" : \"Unl\");\n\n\tretval = scsi_set_medium_removal(STp->device,\n\t\t\tdo_lock ? SCSI_REMOVAL_PREVENT : SCSI_REMOVAL_ALLOW);\n\tif (!retval)\n\t\tSTp->door_locked = do_lock ? ST_LOCKED_EXPLICIT : ST_UNLOCKED;\n\telse\n\t\tSTp->door_locked = ST_LOCK_FAILS;\n\treturn retval;\n}\n\n\n \nstatic void reset_state(struct scsi_tape *STp)\n{\n\tint i;\n\tstruct st_partstat *STps;\n\n\tSTp->pos_unknown = 0;\n\tfor (i = 0; i < ST_NBR_PARTITIONS; i++) {\n\t\tSTps = &(STp->ps[i]);\n\t\tSTps->rw = ST_IDLE;\n\t\tSTps->eof = ST_NOEOF;\n\t\tSTps->at_sm = 0;\n\t\tSTps->last_block_valid = 0;\n\t\tSTps->drv_block = -1;\n\t\tSTps->drv_file = -1;\n\t}\n\tif (STp->can_partitions) {\n\t\tSTp->partition = find_partition(STp);\n\t\tif (STp->partition < 0)\n\t\t\tSTp->partition = 0;\n\t\tSTp->new_partition = STp->partition;\n\t}\n}\n\f\n \n#define CHKRES_READY       0\n#define CHKRES_NEW_SESSION 1\n#define CHKRES_NOT_READY   2\n#define CHKRES_NO_TAPE     3\n\n#define MAX_ATTENTIONS    10\n\nstatic int test_ready(struct scsi_tape *STp, int do_wait)\n{\n\tint attentions, waits, max_wait, scode;\n\tint retval = CHKRES_READY, new_session = 0;\n\tunsigned char cmd[MAX_COMMAND_SIZE];\n\tstruct st_request *SRpnt = NULL;\n\tstruct st_cmdstatus *cmdstatp = &STp->buffer->cmdstat;\n\n\tmax_wait = do_wait ? ST_BLOCK_SECONDS : 0;\n\n\tfor (attentions=waits=0; ; ) {\n\t\tmemset((void *) &cmd[0], 0, MAX_COMMAND_SIZE);\n\t\tcmd[0] = TEST_UNIT_READY;\n\t\tSRpnt = st_do_scsi(SRpnt, STp, cmd, 0, DMA_NONE,\n\t\t\t\t   STp->long_timeout, MAX_READY_RETRIES, 1);\n\n\t\tif (!SRpnt) {\n\t\t\tretval = (STp->buffer)->syscall_result;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmdstatp->have_sense) {\n\n\t\t\tscode = cmdstatp->sense_hdr.sense_key;\n\n\t\t\tif (scode == UNIT_ATTENTION) {  \n\t\t\t\tnew_session = 1;\n\t\t\t\tif (attentions < MAX_ATTENTIONS) {\n\t\t\t\t\tattentions++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tretval = (-EIO);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (scode == NOT_READY) {\n\t\t\t\tif (waits < max_wait) {\n\t\t\t\t\tif (msleep_interruptible(1000)) {\n\t\t\t\t\t\tretval = (-EINTR);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\twaits++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((STp->device)->scsi_level >= SCSI_2 &&\n\t\t\t\t\t    cmdstatp->sense_hdr.asc == 0x3a)\t \n\t\t\t\t\t\tretval = CHKRES_NO_TAPE;\n\t\t\t\t\telse\n\t\t\t\t\t\tretval = CHKRES_NOT_READY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tretval = (STp->buffer)->syscall_result;\n\t\tif (!retval)\n\t\t\tretval = new_session ? CHKRES_NEW_SESSION : CHKRES_READY;\n\t\tbreak;\n\t}\n\n\tif (SRpnt != NULL)\n\t\tst_release_request(SRpnt);\n\treturn retval;\n}\n\n\n \nstatic int check_tape(struct scsi_tape *STp, struct file *filp)\n{\n\tint i, retval, new_session = 0, do_wait;\n\tunsigned char cmd[MAX_COMMAND_SIZE], saved_cleaning;\n\tunsigned short st_flags = filp->f_flags;\n\tstruct st_request *SRpnt = NULL;\n\tstruct st_modedef *STm;\n\tstruct st_partstat *STps;\n\tstruct inode *inode = file_inode(filp);\n\tint mode = TAPE_MODE(inode);\n\n\tSTp->ready = ST_READY;\n\n\tif (mode != STp->current_mode) {\n\t\tDEBC_printk(STp, \"Mode change from %d to %d.\\n\",\n\t\t\t    STp->current_mode, mode);\n\t\tnew_session = 1;\n\t\tSTp->current_mode = mode;\n\t}\n\tSTm = &(STp->modes[STp->current_mode]);\n\n\tsaved_cleaning = STp->cleaning_req;\n\tSTp->cleaning_req = 0;\n\n\tdo_wait = ((filp->f_flags & O_NONBLOCK) == 0);\n\tretval = test_ready(STp, do_wait);\n\n\tif (retval < 0)\n\t    goto err_out;\n\n\tif (retval == CHKRES_NEW_SESSION) {\n\t\tSTp->pos_unknown = 0;\n\t\tSTp->partition = STp->new_partition = 0;\n\t\tif (STp->can_partitions)\n\t\t\tSTp->nbr_partitions = 1;  \n\t\tfor (i = 0; i < ST_NBR_PARTITIONS; i++) {\n\t\t\tSTps = &(STp->ps[i]);\n\t\t\tSTps->rw = ST_IDLE;\n\t\t\tSTps->eof = ST_NOEOF;\n\t\t\tSTps->at_sm = 0;\n\t\t\tSTps->last_block_valid = 0;\n\t\t\tSTps->drv_block = 0;\n\t\t\tSTps->drv_file = 0;\n\t\t}\n\t\tnew_session = 1;\n\t}\n\telse {\n\t\tSTp->cleaning_req |= saved_cleaning;\n\n\t\tif (retval == CHKRES_NOT_READY || retval == CHKRES_NO_TAPE) {\n\t\t\tif (retval == CHKRES_NO_TAPE)\n\t\t\t\tSTp->ready = ST_NO_TAPE;\n\t\t\telse\n\t\t\t\tSTp->ready = ST_NOT_READY;\n\n\t\t\tSTp->density = 0;\t \n\t\t\tSTp->write_prot = 0;\n\t\t\tSTp->block_size = 0;\n\t\t\tSTp->ps[0].drv_file = STp->ps[0].drv_block = (-1);\n\t\t\tSTp->partition = STp->new_partition = 0;\n\t\t\tSTp->door_locked = ST_UNLOCKED;\n\t\t\treturn CHKRES_NOT_READY;\n\t\t}\n\t}\n\n\tif (STp->omit_blklims)\n\t\tSTp->min_block = STp->max_block = (-1);\n\telse {\n\t\tmemset((void *) &cmd[0], 0, MAX_COMMAND_SIZE);\n\t\tcmd[0] = READ_BLOCK_LIMITS;\n\n\t\tSRpnt = st_do_scsi(SRpnt, STp, cmd, 6, DMA_FROM_DEVICE,\n\t\t\t\t   STp->device->request_queue->rq_timeout,\n\t\t\t\t   MAX_READY_RETRIES, 1);\n\t\tif (!SRpnt) {\n\t\t\tretval = (STp->buffer)->syscall_result;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (!SRpnt->result && !STp->buffer->cmdstat.have_sense) {\n\t\t\tSTp->max_block = ((STp->buffer)->b_data[1] << 16) |\n\t\t\t    ((STp->buffer)->b_data[2] << 8) | (STp->buffer)->b_data[3];\n\t\t\tSTp->min_block = ((STp->buffer)->b_data[4] << 8) |\n\t\t\t    (STp->buffer)->b_data[5];\n\t\t\tif ( DEB( debugging || ) !STp->inited)\n\t\t\t\tst_printk(KERN_INFO, STp,\n\t\t\t\t\t  \"Block limits %d - %d bytes.\\n\",\n\t\t\t\t\t  STp->min_block, STp->max_block);\n\t\t} else {\n\t\t\tSTp->min_block = STp->max_block = (-1);\n\t\t\tDEBC_printk(STp, \"Can't read block limits.\\n\");\n\t\t}\n\t}\n\n\tmemset((void *) &cmd[0], 0, MAX_COMMAND_SIZE);\n\tcmd[0] = MODE_SENSE;\n\tcmd[4] = 12;\n\n\tSRpnt = st_do_scsi(SRpnt, STp, cmd, 12, DMA_FROM_DEVICE,\n\t\t\t   STp->device->request_queue->rq_timeout,\n\t\t\t   MAX_READY_RETRIES, 1);\n\tif (!SRpnt) {\n\t\tretval = (STp->buffer)->syscall_result;\n\t\tgoto err_out;\n\t}\n\n\tif ((STp->buffer)->syscall_result != 0) {\n\t\tDEBC_printk(STp, \"No Mode Sense.\\n\");\n\t\tSTp->block_size = ST_DEFAULT_BLOCK;\t \n\t\t(STp->buffer)->syscall_result = 0;\t \n\t\tSTp->drv_write_prot = 0;\n\t} else {\n\t\tDEBC_printk(STp,\"Mode sense. Length %d, \"\n\t\t\t    \"medium %x, WBS %x, BLL %d\\n\",\n\t\t\t    (STp->buffer)->b_data[0],\n\t\t\t    (STp->buffer)->b_data[1],\n\t\t\t    (STp->buffer)->b_data[2],\n\t\t\t    (STp->buffer)->b_data[3]);\n\n\t\tif ((STp->buffer)->b_data[3] >= 8) {\n\t\t\tSTp->drv_buffer = ((STp->buffer)->b_data[2] >> 4) & 7;\n\t\t\tSTp->density = (STp->buffer)->b_data[4];\n\t\t\tSTp->block_size = (STp->buffer)->b_data[9] * 65536 +\n\t\t\t    (STp->buffer)->b_data[10] * 256 + (STp->buffer)->b_data[11];\n\t\t\tDEBC_printk(STp, \"Density %x, tape length: %x, \"\n\t\t\t\t    \"drv buffer: %d\\n\",\n\t\t\t\t    STp->density,\n\t\t\t\t    (STp->buffer)->b_data[5] * 65536 +\n\t\t\t\t    (STp->buffer)->b_data[6] * 256 +\n\t\t\t\t    (STp->buffer)->b_data[7],\n\t\t\t\t    STp->drv_buffer);\n\t\t}\n\t\tSTp->drv_write_prot = ((STp->buffer)->b_data[2] & 0x80) != 0;\n\t\tif (!STp->drv_buffer && STp->immediate_filemark) {\n\t\t\tst_printk(KERN_WARNING, STp,\n\t\t\t\t  \"non-buffered tape: disabling \"\n\t\t\t\t  \"writing immediate filemarks\\n\");\n\t\t\tSTp->immediate_filemark = 0;\n\t\t}\n\t}\n\tst_release_request(SRpnt);\n\tSRpnt = NULL;\n\tSTp->inited = 1;\n\n\tif (STp->block_size > 0)\n\t\t(STp->buffer)->buffer_blocks =\n\t\t\t(STp->buffer)->buffer_size / STp->block_size;\n\telse\n\t\t(STp->buffer)->buffer_blocks = 1;\n\t(STp->buffer)->buffer_bytes = (STp->buffer)->read_pointer = 0;\n\n\tDEBC_printk(STp, \"Block size: %d, buffer size: %d (%d blocks).\\n\",\n\t\t    STp->block_size, (STp->buffer)->buffer_size,\n\t\t    (STp->buffer)->buffer_blocks);\n\n\tif (STp->drv_write_prot) {\n\t\tSTp->write_prot = 1;\n\n\t\tDEBC_printk(STp, \"Write protected\\n\");\n\n\t\tif (do_wait &&\n\t\t    ((st_flags & O_ACCMODE) == O_WRONLY ||\n\t\t     (st_flags & O_ACCMODE) == O_RDWR)) {\n\t\t\tretval = (-EROFS);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif (STp->can_partitions && STp->nbr_partitions < 1) {\n\t\t \n\t\tDEBC_printk(STp, \"Updating partition number in status.\\n\");\n\t\tif ((STp->partition = find_partition(STp)) < 0) {\n\t\t\tretval = STp->partition;\n\t\t\tgoto err_out;\n\t\t}\n\t\tSTp->new_partition = STp->partition;\n\t\tSTp->nbr_partitions = 1;  \n\t}\n\n\tif (new_session) {\t \n\t\tSTp->density_changed = STp->blksize_changed = 0;\n\t\tSTp->compression_changed = 0;\n\t\tif (!(STm->defaults_for_writes) &&\n\t\t    (retval = set_mode_densblk(STp, STm)) < 0)\n\t\t    goto err_out;\n\n\t\tif (STp->default_drvbuffer != 0xff) {\n\t\t\tif (st_int_ioctl(STp, MTSETDRVBUFFER, STp->default_drvbuffer))\n\t\t\t\tst_printk(KERN_WARNING, STp,\n\t\t\t\t\t  \"Can't set default drive \"\n\t\t\t\t\t  \"buffering to %d.\\n\",\n\t\t\t\t\t  STp->default_drvbuffer);\n\t\t}\n\t}\n\n\treturn CHKRES_READY;\n\n err_out:\n\treturn retval;\n}\n\n\n\f \nstatic int st_open(struct inode *inode, struct file *filp)\n{\n\tint i, retval = (-EIO);\n\tint resumed = 0;\n\tstruct scsi_tape *STp;\n\tstruct st_partstat *STps;\n\tint dev = TAPE_NR(inode);\n\n\t \n\tfilp->f_mode &= ~(FMODE_PREAD | FMODE_PWRITE);\n\n\tif (!(STp = scsi_tape_get(dev))) {\n\t\treturn -ENXIO;\n\t}\n\n\tfilp->private_data = STp;\n\n\tspin_lock(&st_use_lock);\n\tif (STp->in_use) {\n\t\tspin_unlock(&st_use_lock);\n\t\tDEBC_printk(STp, \"Device already in use.\\n\");\n\t\tscsi_tape_put(STp);\n\t\treturn (-EBUSY);\n\t}\n\n\tSTp->in_use = 1;\n\tspin_unlock(&st_use_lock);\n\tSTp->rew_at_close = STp->autorew_dev = (iminor(inode) & 0x80) == 0;\n\n\tif (scsi_autopm_get_device(STp->device) < 0) {\n\t\tretval = -EIO;\n\t\tgoto err_out;\n\t}\n\tresumed = 1;\n\tif (!scsi_block_when_processing_errors(STp->device)) {\n\t\tretval = (-ENXIO);\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (!enlarge_buffer(STp->buffer, PAGE_SIZE)) {\n\t\tst_printk(KERN_WARNING, STp,\n\t\t\t  \"Can't allocate one page tape buffer.\\n\");\n\t\tretval = (-EOVERFLOW);\n\t\tgoto err_out;\n\t}\n\n\t(STp->buffer)->cleared = 0;\n\t(STp->buffer)->writing = 0;\n\t(STp->buffer)->syscall_result = 0;\n\n\tSTp->write_prot = ((filp->f_flags & O_ACCMODE) == O_RDONLY);\n\n\tSTp->dirty = 0;\n\tfor (i = 0; i < ST_NBR_PARTITIONS; i++) {\n\t\tSTps = &(STp->ps[i]);\n\t\tSTps->rw = ST_IDLE;\n\t}\n\tSTp->try_dio_now = STp->try_dio;\n\tSTp->recover_count = 0;\n\tDEB( STp->nbr_waits = STp->nbr_finished = 0;\n\t     STp->nbr_requests = STp->nbr_dio = STp->nbr_pages = 0; )\n\n\tretval = check_tape(STp, filp);\n\tif (retval < 0)\n\t\tgoto err_out;\n\tif ((filp->f_flags & O_NONBLOCK) == 0 &&\n\t    retval != CHKRES_READY) {\n\t\tif (STp->ready == NO_TAPE)\n\t\t\tretval = (-ENOMEDIUM);\n\t\telse\n\t\t\tretval = (-EIO);\n\t\tgoto err_out;\n\t}\n\treturn 0;\n\n err_out:\n\tnormalize_buffer(STp->buffer);\n\tspin_lock(&st_use_lock);\n\tSTp->in_use = 0;\n\tspin_unlock(&st_use_lock);\n\tif (resumed)\n\t\tscsi_autopm_put_device(STp->device);\n\tscsi_tape_put(STp);\n\treturn retval;\n\n}\n\f\n\n \nstatic int st_flush(struct file *filp, fl_owner_t id)\n{\n\tint result = 0, result2;\n\tunsigned char cmd[MAX_COMMAND_SIZE];\n\tstruct st_request *SRpnt;\n\tstruct scsi_tape *STp = filp->private_data;\n\tstruct st_modedef *STm = &(STp->modes[STp->current_mode]);\n\tstruct st_partstat *STps = &(STp->ps[STp->partition]);\n\n\tif (file_count(filp) > 1)\n\t\treturn 0;\n\n\tif (STps->rw == ST_WRITING && !STp->pos_unknown) {\n\t\tresult = st_flush_write_buffer(STp);\n\t\tif (result != 0 && result != (-ENOSPC))\n\t\t\tgoto out;\n\t}\n\n\tif (STp->can_partitions &&\n\t    (result2 = switch_partition(STp)) < 0) {\n\t\tDEBC_printk(STp, \"switch_partition at close failed.\\n\");\n\t\tif (result == 0)\n\t\t\tresult = result2;\n\t\tgoto out;\n\t}\n\n\tDEBC( if (STp->nbr_requests)\n\t\tst_printk(KERN_DEBUG, STp,\n\t\t\t  \"Number of r/w requests %d, dio used in %d, \"\n\t\t\t  \"pages %d.\\n\", STp->nbr_requests, STp->nbr_dio,\n\t\t\t  STp->nbr_pages));\n\n\tif (STps->rw == ST_WRITING && !STp->pos_unknown) {\n\t\tstruct st_cmdstatus *cmdstatp = &STp->buffer->cmdstat;\n\n#if DEBUG\n\t\tDEBC_printk(STp, \"Async write waits %d, finished %d.\\n\",\n\t\t\t    STp->nbr_waits, STp->nbr_finished);\n#endif\n\t\tmemset(cmd, 0, MAX_COMMAND_SIZE);\n\t\tcmd[0] = WRITE_FILEMARKS;\n\t\tif (STp->immediate_filemark)\n\t\t\tcmd[1] = 1;\n\t\tcmd[4] = 1 + STp->two_fm;\n\n\t\tSRpnt = st_do_scsi(NULL, STp, cmd, 0, DMA_NONE,\n\t\t\t\t   STp->device->request_queue->rq_timeout,\n\t\t\t\t   MAX_WRITE_RETRIES, 1);\n\t\tif (!SRpnt) {\n\t\t\tresult = (STp->buffer)->syscall_result;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (STp->buffer->syscall_result == 0 ||\n\t\t    (cmdstatp->have_sense && !cmdstatp->deferred &&\n\t\t     (cmdstatp->flags & SENSE_EOM) &&\n\t\t     (cmdstatp->sense_hdr.sense_key == NO_SENSE ||\n\t\t      cmdstatp->sense_hdr.sense_key == RECOVERED_ERROR) &&\n\t\t     (!cmdstatp->remainder_valid || cmdstatp->uremainder64 == 0))) {\n\t\t\t \n\t\t\tst_release_request(SRpnt);\n\t\t\tSRpnt = NULL;\n\t\t\tif (STps->drv_file >= 0)\n\t\t\t\tSTps->drv_file++;\n\t\t\tSTps->drv_block = 0;\n\t\t\tif (STp->two_fm)\n\t\t\t\tcross_eof(STp, 0);\n\t\t\tSTps->eof = ST_FM;\n\t\t}\n\t\telse {  \n\t\t\tst_release_request(SRpnt);\n\t\t\tSRpnt = NULL;\n\t\t\tst_printk(KERN_ERR, STp,\n\t\t\t\t  \"Error on write filemark.\\n\");\n\t\t\tif (result == 0)\n\t\t\t\tresult = (-EIO);\n\t\t}\n\n\t\tDEBC_printk(STp, \"Buffer flushed, %d EOF(s) written\\n\", cmd[4]);\n\t} else if (!STp->rew_at_close) {\n\t\tSTps = &(STp->ps[STp->partition]);\n\t\tif (!STm->sysv || STps->rw != ST_READING) {\n\t\t\tif (STp->can_bsr)\n\t\t\t\tresult = flush_buffer(STp, 0);\n\t\t\telse if (STps->eof == ST_FM_HIT) {\n\t\t\t\tresult = cross_eof(STp, 0);\n\t\t\t\tif (result) {\n\t\t\t\t\tif (STps->drv_file >= 0)\n\t\t\t\t\t\tSTps->drv_file++;\n\t\t\t\t\tSTps->drv_block = 0;\n\t\t\t\t\tSTps->eof = ST_FM;\n\t\t\t\t} else\n\t\t\t\t\tSTps->eof = ST_NOEOF;\n\t\t\t}\n\t\t} else if ((STps->eof == ST_NOEOF &&\n\t\t\t    !(result = cross_eof(STp, 1))) ||\n\t\t\t   STps->eof == ST_FM_HIT) {\n\t\t\tif (STps->drv_file >= 0)\n\t\t\t\tSTps->drv_file++;\n\t\t\tSTps->drv_block = 0;\n\t\t\tSTps->eof = ST_FM;\n\t\t}\n\t}\n\n      out:\n\tif (STp->rew_at_close) {\n\t\tresult2 = st_int_ioctl(STp, MTREW, 1);\n\t\tif (result == 0)\n\t\t\tresult = result2;\n\t}\n\treturn result;\n}\n\n\n \nstatic int st_release(struct inode *inode, struct file *filp)\n{\n\tstruct scsi_tape *STp = filp->private_data;\n\n\tif (STp->door_locked == ST_LOCKED_AUTO)\n\t\tdo_door_lock(STp, 0);\n\n\tnormalize_buffer(STp->buffer);\n\tspin_lock(&st_use_lock);\n\tSTp->in_use = 0;\n\tspin_unlock(&st_use_lock);\n\tscsi_autopm_put_device(STp->device);\n\tscsi_tape_put(STp);\n\n\treturn 0;\n}\n\n \nstatic ssize_t rw_checks(struct scsi_tape *STp, struct file *filp, size_t count)\n{\n\tssize_t retval = 0;\n\n\t \n\tif (!scsi_block_when_processing_errors(STp->device)) {\n\t\tretval = (-ENXIO);\n\t\tgoto out;\n\t}\n\n\tif (STp->ready != ST_READY) {\n\t\tif (STp->ready == ST_NO_TAPE)\n\t\t\tretval = (-ENOMEDIUM);\n\t\telse\n\t\t\tretval = (-EIO);\n\t\tgoto out;\n\t}\n\n\tif (! STp->modes[STp->current_mode].defined) {\n\t\tretval = (-ENXIO);\n\t\tgoto out;\n\t}\n\n\n\t \n\tif (STp->pos_unknown) {\n\t\tretval = (-EIO);\n\t\tgoto out;\n\t}\n\n\tif (count == 0)\n\t\tgoto out;\n\n\tDEB(\n\tif (!STp->in_use) {\n\t\tst_printk(ST_DEB_MSG, STp,\n\t\t\t  \"Incorrect device.\\n\");\n\t\tretval = (-EIO);\n\t\tgoto out;\n\t} )  \n\n\tif (STp->can_partitions &&\n\t    (retval = switch_partition(STp)) < 0)\n\t\tgoto out;\n\n\tif (STp->block_size == 0 && STp->max_block > 0 &&\n\t    (count < STp->min_block || count > STp->max_block)) {\n\t\tretval = (-EINVAL);\n\t\tgoto out;\n\t}\n\n\tif (STp->do_auto_lock && STp->door_locked == ST_UNLOCKED &&\n\t    !do_door_lock(STp, 1))\n\t\tSTp->door_locked = ST_LOCKED_AUTO;\n\n out:\n\treturn retval;\n}\n\n\nstatic int setup_buffering(struct scsi_tape *STp, const char __user *buf,\n\t\t\t   size_t count, int is_read)\n{\n\tint i, bufsize, retval = 0;\n\tstruct st_buffer *STbp = STp->buffer;\n\n\tif (is_read)\n\t\ti = STp->try_dio_now && try_rdio;\n\telse\n\t\ti = STp->try_dio_now && try_wdio;\n\n\tif (i && ((unsigned long)buf & queue_dma_alignment(\n\t\t\t\t\tSTp->device->request_queue)) == 0) {\n\t\ti = sgl_map_user_pages(STbp, STbp->use_sg, (unsigned long)buf,\n\t\t\t\t       count, (is_read ? READ : WRITE));\n\t\tif (i > 0) {\n\t\t\tSTbp->do_dio = i;\n\t\t\tSTbp->buffer_bytes = 0;    \n\t\t}\n\t\telse\n\t\t\tSTbp->do_dio = 0;   \n\t\tSTbp->sg_segs = STbp->do_dio;\n\t\tDEB(\n\t\t     if (STbp->do_dio) {\n\t\t\tSTp->nbr_dio++;\n\t\t\tSTp->nbr_pages += STbp->do_dio;\n\t\t     }\n\t\t)\n\t} else\n\t\tSTbp->do_dio = 0;\n\tDEB( STp->nbr_requests++; )\n\n\tif (!STbp->do_dio) {\n\t\tif (STp->block_size)\n\t\t\tbufsize = STp->block_size > st_fixed_buffer_size ?\n\t\t\t\tSTp->block_size : st_fixed_buffer_size;\n\t\telse {\n\t\t\tbufsize = count;\n\t\t\t \n\t\t\tif (is_read && STp->sili && !STbp->cleared)\n\t\t\t\tclear_buffer(STbp);\n\t\t}\n\n\t\tif (bufsize > STbp->buffer_size &&\n\t\t    !enlarge_buffer(STbp, bufsize)) {\n\t\t\tst_printk(KERN_WARNING, STp,\n\t\t\t\t  \"Can't allocate %d byte tape buffer.\\n\",\n\t\t\t\t  bufsize);\n\t\t\tretval = (-EOVERFLOW);\n\t\t\tgoto out;\n\t\t}\n\t\tif (STp->block_size)\n\t\t\tSTbp->buffer_blocks = bufsize / STp->block_size;\n\t}\n\n out:\n\treturn retval;\n}\n\n\n \nstatic void release_buffering(struct scsi_tape *STp, int is_read)\n{\n\tstruct st_buffer *STbp;\n\n\tSTbp = STp->buffer;\n\tif (STbp->do_dio) {\n\t\tsgl_unmap_user_pages(STbp, STbp->do_dio, is_read);\n\t\tSTbp->do_dio = 0;\n\t\tSTbp->sg_segs = 0;\n\t}\n}\n\n\n \nstatic ssize_t\nst_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)\n{\n\tssize_t total;\n\tssize_t i, do_count, blks, transfer;\n\tssize_t retval;\n\tint undone, retry_eot = 0, scode;\n\tint async_write;\n\tunsigned char cmd[MAX_COMMAND_SIZE];\n\tconst char __user *b_point;\n\tstruct st_request *SRpnt = NULL;\n\tstruct scsi_tape *STp = filp->private_data;\n\tstruct st_modedef *STm;\n\tstruct st_partstat *STps;\n\tstruct st_buffer *STbp;\n\n\tif (mutex_lock_interruptible(&STp->lock))\n\t\treturn -ERESTARTSYS;\n\n\tretval = rw_checks(STp, filp, count);\n\tif (retval || count == 0)\n\t\tgoto out;\n\n\t \n\tif (STp->block_size != 0 && (count % STp->block_size) != 0) {\n\t\tst_printk(KERN_WARNING, STp,\n\t\t\t  \"Write not multiple of tape block size.\\n\");\n\t\tretval = (-EINVAL);\n\t\tgoto out;\n\t}\n\n\tSTm = &(STp->modes[STp->current_mode]);\n\tSTps = &(STp->ps[STp->partition]);\n\n\tif (STp->write_prot) {\n\t\tretval = (-EACCES);\n\t\tgoto out;\n\t}\n\n\n\tif (STps->rw == ST_READING) {\n\t\tretval = flush_buffer(STp, 0);\n\t\tif (retval)\n\t\t\tgoto out;\n\t\tSTps->rw = ST_WRITING;\n\t} else if (STps->rw != ST_WRITING &&\n\t\t   STps->drv_file == 0 && STps->drv_block == 0) {\n\t\tif ((retval = set_mode_densblk(STp, STm)) < 0)\n\t\t\tgoto out;\n\t\tif (STm->default_compression != ST_DONT_TOUCH &&\n\t\t    !(STp->compression_changed)) {\n\t\t\tif (st_compression(STp, (STm->default_compression == ST_YES))) {\n\t\t\t\tst_printk(KERN_WARNING, STp,\n\t\t\t\t\t  \"Can't set default compression.\\n\");\n\t\t\t\tif (modes_defined) {\n\t\t\t\t\tretval = (-EINVAL);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tSTbp = STp->buffer;\n\ti = write_behind_check(STp);\n\tif (i) {\n\t\tif (i == -ENOSPC)\n\t\t\tSTps->eof = ST_EOM_OK;\n\t\telse\n\t\t\tSTps->eof = ST_EOM_ERROR;\n\t}\n\n\tif (STps->eof == ST_EOM_OK) {\n\t\tSTps->eof = ST_EOD_1;   \n\t\tretval = (-ENOSPC);\n\t\tgoto out;\n\t}\n\telse if (STps->eof == ST_EOM_ERROR) {\n\t\tretval = (-EIO);\n\t\tgoto out;\n\t}\n\n\t \n\tif (STp->block_size != 0 &&\n\t    !STbp->do_dio &&\n\t    (copy_from_user(&i, buf, 1) != 0 ||\n\t     copy_from_user(&i, buf + count - 1, 1) != 0)) {\n\t\tretval = (-EFAULT);\n\t\tgoto out;\n\t}\n\n\tretval = setup_buffering(STp, buf, count, 0);\n\tif (retval)\n\t\tgoto out;\n\n\ttotal = count;\n\n\tmemset(cmd, 0, MAX_COMMAND_SIZE);\n\tcmd[0] = WRITE_6;\n\tcmd[1] = (STp->block_size != 0);\n\n\tSTps->rw = ST_WRITING;\n\n\tb_point = buf;\n\twhile (count > 0 && !retry_eot) {\n\n\t\tif (STbp->do_dio) {\n\t\t\tdo_count = count;\n\t\t}\n\t\telse {\n\t\t\tif (STp->block_size == 0)\n\t\t\t\tdo_count = count;\n\t\t\telse {\n\t\t\t\tdo_count = STbp->buffer_blocks * STp->block_size -\n\t\t\t\t\tSTbp->buffer_bytes;\n\t\t\t\tif (do_count > count)\n\t\t\t\t\tdo_count = count;\n\t\t\t}\n\n\t\t\ti = append_to_buffer(b_point, STbp, do_count);\n\t\t\tif (i) {\n\t\t\t\tretval = i;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tcount -= do_count;\n\t\tb_point += do_count;\n\n\t\tasync_write = STp->block_size == 0 && !STbp->do_dio &&\n\t\t\tSTm->do_async_writes && STps->eof < ST_EOM_OK;\n\n\t\tif (STp->block_size != 0 && STm->do_buffer_writes &&\n\t\t    !(STp->try_dio_now && try_wdio) && STps->eof < ST_EOM_OK &&\n\t\t    STbp->buffer_bytes < STbp->buffer_size) {\n\t\t\tSTp->dirty = 1;\n\t\t\t \n\t\t\tif (!async_write && count == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\tretry_write:\n\t\tif (STp->block_size == 0)\n\t\t\tblks = transfer = do_count;\n\t\telse {\n\t\t\tif (!STbp->do_dio)\n\t\t\t\tblks = STbp->buffer_bytes;\n\t\t\telse\n\t\t\t\tblks = do_count;\n\t\t\tblks /= STp->block_size;\n\t\t\ttransfer = blks * STp->block_size;\n\t\t}\n\t\tcmd[2] = blks >> 16;\n\t\tcmd[3] = blks >> 8;\n\t\tcmd[4] = blks;\n\n\t\tSRpnt = st_do_scsi(SRpnt, STp, cmd, transfer, DMA_TO_DEVICE,\n\t\t\t\t   STp->device->request_queue->rq_timeout,\n\t\t\t\t   MAX_WRITE_RETRIES, !async_write);\n\t\tif (!SRpnt) {\n\t\t\tretval = STbp->syscall_result;\n\t\t\tgoto out;\n\t\t}\n\t\tif (async_write && !STbp->syscall_result) {\n\t\t\tSTbp->writing = transfer;\n\t\t\tSTp->dirty = !(STbp->writing ==\n\t\t\t\t       STbp->buffer_bytes);\n\t\t\tSRpnt = NULL;   \n\t\t\tDEB( STp->write_pending = 1; )\n\t\t\tbreak;\n\t\t}\n\n\t\tif (STbp->syscall_result != 0) {\n\t\t\tstruct st_cmdstatus *cmdstatp = &STp->buffer->cmdstat;\n\n\t\t\tDEBC_printk(STp, \"Error on write:\\n\");\n\t\t\tif (cmdstatp->have_sense && (cmdstatp->flags & SENSE_EOM)) {\n\t\t\t\tscode = cmdstatp->sense_hdr.sense_key;\n\t\t\t\tif (cmdstatp->remainder_valid)\n\t\t\t\t\tundone = (int)cmdstatp->uremainder64;\n\t\t\t\telse if (STp->block_size == 0 &&\n\t\t\t\t\t scode == VOLUME_OVERFLOW)\n\t\t\t\t\tundone = transfer;\n\t\t\t\telse\n\t\t\t\t\tundone = 0;\n\t\t\t\tif (STp->block_size != 0)\n\t\t\t\t\tundone *= STp->block_size;\n\t\t\t\tif (undone <= do_count) {\n\t\t\t\t\t \n\t\t\t\t\tcount += undone;\n\t\t\t\t\tb_point -= undone;\n\t\t\t\t\tdo_count -= undone;\n\t\t\t\t\tif (STp->block_size)\n\t\t\t\t\t\tblks = (transfer - undone) / STp->block_size;\n\t\t\t\t\tSTps->eof = ST_EOM_OK;\n\t\t\t\t\t \n\t\t\t\t\tif (STp->block_size == 0 ||\n\t\t\t\t\t    undone > 0 || count == 0)\n\t\t\t\t\t\tretval = (-ENOSPC);  \n\t\t\t\t\tDEBC_printk(STp, \"EOM with %d \"\n\t\t\t\t\t\t    \"bytes unwritten.\\n\",\n\t\t\t\t\t\t    (int)count);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tif (!retry_eot && !cmdstatp->deferred &&\n\t\t\t\t\t    (scode == NO_SENSE || scode == RECOVERED_ERROR)) {\n\t\t\t\t\t\tmove_buffer_data(STp->buffer, transfer - undone);\n\t\t\t\t\t\tretry_eot = 1;\n\t\t\t\t\t\tif (STps->drv_block >= 0) {\n\t\t\t\t\t\t\tSTps->drv_block += (transfer - undone) /\n\t\t\t\t\t\t\t\tSTp->block_size;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSTps->eof = ST_EOM_OK;\n\t\t\t\t\t\tDEBC_printk(STp, \"Retry \"\n\t\t\t\t\t\t\t    \"write of %d \"\n\t\t\t\t\t\t\t    \"bytes at EOM.\\n\",\n\t\t\t\t\t\t\t    STp->buffer->buffer_bytes);\n\t\t\t\t\t\tgoto retry_write;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t \n\t\t\t\t\t\tcount -= do_count;\n\t\t\t\t\t\tblks = do_count = 0;\n\t\t\t\t\t\tSTps->eof = ST_EOM_ERROR;\n\t\t\t\t\t\tSTps->drv_block = (-1);  \n\t\t\t\t\t\tretval = (-EIO);\t \n\t\t\t\t\t\tDEBC_printk(STp, \"EOM with \"\n\t\t\t\t\t\t\t    \"lost data.\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcount += do_count;\n\t\t\t\tSTps->drv_block = (-1);\t\t \n\t\t\t\tretval = STbp->syscall_result;\n\t\t\t}\n\n\t\t}\n\n\t\tif (STps->drv_block >= 0) {\n\t\t\tif (STp->block_size == 0)\n\t\t\t\tSTps->drv_block += (do_count > 0);\n\t\t\telse\n\t\t\t\tSTps->drv_block += blks;\n\t\t}\n\n\t\tSTbp->buffer_bytes = 0;\n\t\tSTp->dirty = 0;\n\n\t\tif (retval || retry_eot) {\n\t\t\tif (count < total)\n\t\t\t\tretval = total - count;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (STps->eof == ST_EOD_1)\n\t\tSTps->eof = ST_EOM_OK;\n\telse if (STps->eof != ST_EOM_OK)\n\t\tSTps->eof = ST_NOEOF;\n\tretval = total - count;\n\n out:\n\tif (SRpnt != NULL)\n\t\tst_release_request(SRpnt);\n\trelease_buffering(STp, 0);\n\tmutex_unlock(&STp->lock);\n\n\treturn retval;\n}\n\f\n \nstatic long read_tape(struct scsi_tape *STp, long count,\n\t\t      struct st_request ** aSRpnt)\n{\n\tint transfer, blks, bytes;\n\tunsigned char cmd[MAX_COMMAND_SIZE];\n\tstruct st_request *SRpnt;\n\tstruct st_modedef *STm;\n\tstruct st_partstat *STps;\n\tstruct st_buffer *STbp;\n\tint retval = 0;\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tSTm = &(STp->modes[STp->current_mode]);\n\tSTps = &(STp->ps[STp->partition]);\n\tif (STps->eof == ST_FM_HIT)\n\t\treturn 1;\n\tSTbp = STp->buffer;\n\n\tif (STp->block_size == 0)\n\t\tblks = bytes = count;\n\telse {\n\t\tif (!(STp->try_dio_now && try_rdio) && STm->do_read_ahead) {\n\t\t\tblks = (STp->buffer)->buffer_blocks;\n\t\t\tbytes = blks * STp->block_size;\n\t\t} else {\n\t\t\tbytes = count;\n\t\t\tif (!STbp->do_dio && bytes > (STp->buffer)->buffer_size)\n\t\t\t\tbytes = (STp->buffer)->buffer_size;\n\t\t\tblks = bytes / STp->block_size;\n\t\t\tbytes = blks * STp->block_size;\n\t\t}\n\t}\n\n\tmemset(cmd, 0, MAX_COMMAND_SIZE);\n\tcmd[0] = READ_6;\n\tcmd[1] = (STp->block_size != 0);\n\tif (!cmd[1] && STp->sili)\n\t\tcmd[1] |= 2;\n\tcmd[2] = blks >> 16;\n\tcmd[3] = blks >> 8;\n\tcmd[4] = blks;\n\n\tSRpnt = *aSRpnt;\n\tSRpnt = st_do_scsi(SRpnt, STp, cmd, bytes, DMA_FROM_DEVICE,\n\t\t\t   STp->device->request_queue->rq_timeout,\n\t\t\t   MAX_RETRIES, 1);\n\trelease_buffering(STp, 1);\n\t*aSRpnt = SRpnt;\n\tif (!SRpnt)\n\t\treturn STbp->syscall_result;\n\n\tSTbp->read_pointer = 0;\n\tSTps->at_sm = 0;\n\n\t \n\tif (STbp->syscall_result) {\n\t\tstruct st_cmdstatus *cmdstatp = &STp->buffer->cmdstat;\n\n\t\tretval = 1;\n\t\tDEBC_printk(STp,\n\t\t\t    \"Sense: %2x %2x %2x %2x %2x %2x %2x %2x\\n\",\n\t\t\t    SRpnt->sense[0], SRpnt->sense[1],\n\t\t\t    SRpnt->sense[2], SRpnt->sense[3],\n\t\t\t    SRpnt->sense[4], SRpnt->sense[5],\n\t\t\t    SRpnt->sense[6], SRpnt->sense[7]);\n\t\tif (cmdstatp->have_sense) {\n\n\t\t\tif (cmdstatp->sense_hdr.sense_key == BLANK_CHECK)\n\t\t\t\tcmdstatp->flags &= 0xcf;\t \n\n\t\t\tif (cmdstatp->flags != 0) {  \n\t\t\t\t \n\t\t\t\tif (cmdstatp->remainder_valid)\n\t\t\t\t\ttransfer = (int)cmdstatp->uremainder64;\n\t\t\t\telse\n\t\t\t\t\ttransfer = 0;\n\t\t\t\tif (cmdstatp->sense_hdr.sense_key == MEDIUM_ERROR) {\n\t\t\t\t\tif (STp->block_size == 0)\n\t\t\t\t\t\ttransfer = bytes;\n\t\t\t\t\t \n\t\t\t\t\tcmdstatp->flags &= ~SENSE_ILI;\n\t\t\t\t}\n\n\t\t\t\tif (cmdstatp->flags & SENSE_ILI) {\t \n\t\t\t\t\tif (STp->block_size == 0 &&\n\t\t\t\t\t    transfer < 0) {\n\t\t\t\t\t\tst_printk(KERN_NOTICE, STp,\n\t\t\t\t\t\t\t  \"Failed to read %d \"\n\t\t\t\t\t\t\t  \"byte block with %d \"\n\t\t\t\t\t\t\t  \"byte transfer.\\n\",\n\t\t\t\t\t\t\t  bytes - transfer,\n\t\t\t\t\t\t\t  bytes);\n\t\t\t\t\t\tif (STps->drv_block >= 0)\n\t\t\t\t\t\t\tSTps->drv_block += 1;\n\t\t\t\t\t\tSTbp->buffer_bytes = 0;\n\t\t\t\t\t\treturn (-ENOMEM);\n\t\t\t\t\t} else if (STp->block_size == 0) {\n\t\t\t\t\t\tSTbp->buffer_bytes = bytes - transfer;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tst_release_request(SRpnt);\n\t\t\t\t\t\tSRpnt = *aSRpnt = NULL;\n\t\t\t\t\t\tif (transfer == blks) {\t \n\t\t\t\t\t\t\tst_printk(KERN_NOTICE, STp,\n\t\t\t\t\t\t\t\t  \"Incorrect \"\n\t\t\t\t\t\t\t\t  \"block size.\\n\");\n\t\t\t\t\t\t\tif (STps->drv_block >= 0)\n\t\t\t\t\t\t\t\tSTps->drv_block += blks - transfer + 1;\n\t\t\t\t\t\t\tst_int_ioctl(STp, MTBSR, 1);\n\t\t\t\t\t\t\treturn (-EIO);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t \n\t\t\t\t\t\tSTbp->buffer_bytes = (blks - transfer) *\n\t\t\t\t\t\t    STp->block_size;\n\t\t\t\t\t\tDEBC_printk(STp, \"ILI but \"\n\t\t\t\t\t\t\t    \"enough data \"\n\t\t\t\t\t\t\t    \"received %ld \"\n\t\t\t\t\t\t\t    \"%d.\\n\", count,\n\t\t\t\t\t\t\t    STbp->buffer_bytes);\n\t\t\t\t\t\tif (STps->drv_block >= 0)\n\t\t\t\t\t\t\tSTps->drv_block += 1;\n\t\t\t\t\t\tif (st_int_ioctl(STp, MTBSR, 1))\n\t\t\t\t\t\t\treturn (-EIO);\n\t\t\t\t\t}\n\t\t\t\t} else if (cmdstatp->flags & SENSE_FMK) {\t \n\t\t\t\t\tif (STps->eof != ST_FM_HIT)\n\t\t\t\t\t\tSTps->eof = ST_FM_HIT;\n\t\t\t\t\telse\n\t\t\t\t\t\tSTps->eof = ST_EOD_2;\n\t\t\t\t\tif (STp->block_size == 0)\n\t\t\t\t\t\tSTbp->buffer_bytes = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tSTbp->buffer_bytes =\n\t\t\t\t\t\t    bytes - transfer * STp->block_size;\n\t\t\t\t\tDEBC_printk(STp, \"EOF detected (%d \"\n\t\t\t\t\t\t    \"bytes read).\\n\",\n\t\t\t\t\t\t    STbp->buffer_bytes);\n\t\t\t\t} else if (cmdstatp->flags & SENSE_EOM) {\n\t\t\t\t\tif (STps->eof == ST_FM)\n\t\t\t\t\t\tSTps->eof = ST_EOD_1;\n\t\t\t\t\telse\n\t\t\t\t\t\tSTps->eof = ST_EOM_OK;\n\t\t\t\t\tif (STp->block_size == 0)\n\t\t\t\t\t\tSTbp->buffer_bytes = bytes - transfer;\n\t\t\t\t\telse\n\t\t\t\t\t\tSTbp->buffer_bytes =\n\t\t\t\t\t\t    bytes - transfer * STp->block_size;\n\n\t\t\t\t\tDEBC_printk(STp, \"EOM detected (%d \"\n\t\t\t\t\t\t    \"bytes read).\\n\",\n\t\t\t\t\t\t    STbp->buffer_bytes);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\telse {\t \n\t\t\t\tDEBC_printk(STp, \"Tape error while reading.\\n\");\n\t\t\t\tSTps->drv_block = (-1);\n\t\t\t\tif (STps->eof == ST_FM &&\n\t\t\t\t    cmdstatp->sense_hdr.sense_key == BLANK_CHECK) {\n\t\t\t\t\tDEBC_printk(STp, \"Zero returned for \"\n\t\t\t\t\t\t    \"first BLANK CHECK \"\n\t\t\t\t\t\t    \"after EOF.\\n\");\n\t\t\t\t\tSTps->eof = ST_EOD_2;\t \n\t\t\t\t} else\t \n\t\t\t\t\tretval = (-EIO);\n\t\t\t}\n\n\t\t\tif (STbp->buffer_bytes < 0)   \n\t\t\t\tSTbp->buffer_bytes = 0;\n\t\t}\n\t\t \n\t\telse {\t\t \n\t\t\tretval = STbp->syscall_result;\n\t\t}\n\n\t}\n\t \n\telse {\t\t\t \n\t\tSTbp->buffer_bytes = bytes;\n\t\tif (STp->sili)  \n\t\t\tSTbp->buffer_bytes -= STp->buffer->cmdstat.residual;\n\t}\n\n\tif (STps->drv_block >= 0) {\n\t\tif (STp->block_size == 0)\n\t\t\tSTps->drv_block++;\n\t\telse\n\t\t\tSTps->drv_block += STbp->buffer_bytes / STp->block_size;\n\t}\n\treturn retval;\n}\n\f\n\n \nstatic ssize_t\nst_read(struct file *filp, char __user *buf, size_t count, loff_t * ppos)\n{\n\tssize_t total;\n\tssize_t retval = 0;\n\tssize_t i, transfer;\n\tint special, do_dio = 0;\n\tstruct st_request *SRpnt = NULL;\n\tstruct scsi_tape *STp = filp->private_data;\n\tstruct st_modedef *STm;\n\tstruct st_partstat *STps;\n\tstruct st_buffer *STbp = STp->buffer;\n\n\tif (mutex_lock_interruptible(&STp->lock))\n\t\treturn -ERESTARTSYS;\n\n\tretval = rw_checks(STp, filp, count);\n\tif (retval || count == 0)\n\t\tgoto out;\n\n\tSTm = &(STp->modes[STp->current_mode]);\n\tif (STp->block_size != 0 && (count % STp->block_size) != 0) {\n\t\tif (!STm->do_read_ahead) {\n\t\t\tretval = (-EINVAL);\t \n\t\t\tgoto out;\n\t\t}\n\t\tSTp->try_dio_now = 0;   \n\t}\n\n\tSTps = &(STp->ps[STp->partition]);\n\tif (STps->rw == ST_WRITING) {\n\t\tretval = flush_buffer(STp, 0);\n\t\tif (retval)\n\t\t\tgoto out;\n\t\tSTps->rw = ST_READING;\n\t}\n\tDEB(\n\tif (debugging && STps->eof != ST_NOEOF)\n\t\tst_printk(ST_DEB_MSG, STp,\n\t\t\t  \"EOF/EOM flag up (%d). Bytes %d\\n\",\n\t\t\t  STps->eof, STbp->buffer_bytes);\n\t)  \n\n\tretval = setup_buffering(STp, buf, count, 1);\n\tif (retval)\n\t\tgoto out;\n\tdo_dio = STbp->do_dio;\n\n\tif (STbp->buffer_bytes == 0 &&\n\t    STps->eof >= ST_EOD_1) {\n\t\tif (STps->eof < ST_EOD) {\n\t\t\tSTps->eof += 1;\n\t\t\tretval = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tretval = (-EIO);\t \n\t\tgoto out;\n\t}\n\n\tif (do_dio) {\n\t\t \n\t\tif (copy_from_user(&i, buf, 1) != 0 ||\n\t\t    copy_to_user(buf, &i, 1) != 0 ||\n\t\t    copy_from_user(&i, buf + count - 1, 1) != 0 ||\n\t\t    copy_to_user(buf + count - 1, &i, 1) != 0) {\n\t\t\tretval = (-EFAULT);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tSTps->rw = ST_READING;\n\n\n\t \n\tfor (total = 0, special = 0; total < count && !special;) {\n\n\t\t \n\t\tif (STbp->buffer_bytes == 0) {\n\t\t\tspecial = read_tape(STp, count - total, &SRpnt);\n\t\t\tif (special < 0) {\t \n\t\t\t\tretval = special;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (STbp->buffer_bytes > 0) {\n\t\t\tDEB(\n\t\t\tif (debugging && STps->eof != ST_NOEOF)\n\t\t\t\tst_printk(ST_DEB_MSG, STp,\n\t\t\t\t\t  \"EOF up (%d). Left %d, needed %d.\\n\",\n\t\t\t\t\t  STps->eof, STbp->buffer_bytes,\n\t\t\t\t\t  (int)(count - total));\n\t\t\t)  \n\t\t\ttransfer = STbp->buffer_bytes < count - total ?\n\t\t\t    STbp->buffer_bytes : count - total;\n\t\t\tif (!do_dio) {\n\t\t\t\ti = from_buffer(STbp, buf, transfer);\n\t\t\t\tif (i) {\n\t\t\t\t\tretval = i;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf += transfer;\n\t\t\ttotal += transfer;\n\t\t}\n\n\t\tif (STp->block_size == 0)\n\t\t\tbreak;\t \n\n\t}\t\t\t \n\n\t \n\tif (total == 0) {\n\t\tif (STps->eof == ST_FM_HIT) {\n\t\t\tSTps->eof = ST_FM;\n\t\t\tSTps->drv_block = 0;\n\t\t\tif (STps->drv_file >= 0)\n\t\t\t\tSTps->drv_file++;\n\t\t} else if (STps->eof == ST_EOD_1) {\n\t\t\tSTps->eof = ST_EOD_2;\n\t\t\tSTps->drv_block = 0;\n\t\t\tif (STps->drv_file >= 0)\n\t\t\t\tSTps->drv_file++;\n\t\t} else if (STps->eof == ST_EOD_2)\n\t\t\tSTps->eof = ST_EOD;\n\t} else if (STps->eof == ST_FM)\n\t\tSTps->eof = ST_NOEOF;\n\tretval = total;\n\n out:\n\tif (SRpnt != NULL) {\n\t\tst_release_request(SRpnt);\n\t\tSRpnt = NULL;\n\t}\n\tif (do_dio) {\n\t\trelease_buffering(STp, 1);\n\t\tSTbp->buffer_bytes = 0;\n\t}\n\tmutex_unlock(&STp->lock);\n\n\treturn retval;\n}\n\f\n\n\nDEB(\n \nstatic void st_log_options(struct scsi_tape * STp, struct st_modedef * STm)\n{\n\tif (debugging) {\n\t\tst_printk(KERN_INFO, STp,\n\t\t\t  \"Mode %d options: buffer writes: %d, \"\n\t\t\t  \"async writes: %d, read ahead: %d\\n\",\n\t\t\t  STp->current_mode, STm->do_buffer_writes,\n\t\t\t  STm->do_async_writes, STm->do_read_ahead);\n\t\tst_printk(KERN_INFO, STp,\n\t\t\t  \"    can bsr: %d, two FMs: %d, \"\n\t\t\t  \"fast mteom: %d, auto lock: %d,\\n\",\n\t\t\t  STp->can_bsr, STp->two_fm, STp->fast_mteom,\n\t\t\t  STp->do_auto_lock);\n\t\tst_printk(KERN_INFO, STp,\n\t\t\t  \"    defs for wr: %d, no block limits: %d, \"\n\t\t\t  \"partitions: %d, s2 log: %d\\n\",\n\t\t\t  STm->defaults_for_writes, STp->omit_blklims,\n\t\t\t  STp->can_partitions, STp->scsi2_logical);\n\t\tst_printk(KERN_INFO, STp,\n\t\t\t  \"    sysv: %d nowait: %d sili: %d \"\n\t\t\t  \"nowait_filemark: %d\\n\",\n\t\t\t  STm->sysv, STp->immediate, STp->sili,\n\t\t\t  STp->immediate_filemark);\n\t\tst_printk(KERN_INFO, STp, \"    debugging: %d\\n\", debugging);\n\t}\n}\n\t)\n\n\nstatic int st_set_options(struct scsi_tape *STp, long options)\n{\n\tint value;\n\tlong code;\n\tstruct st_modedef *STm;\n\tstruct cdev *cd0, *cd1;\n\tstruct device *d0, *d1;\n\n\tSTm = &(STp->modes[STp->current_mode]);\n\tif (!STm->defined) {\n\t\tcd0 = STm->cdevs[0];\n\t\tcd1 = STm->cdevs[1];\n\t\td0  = STm->devs[0];\n\t\td1  = STm->devs[1];\n\t\tmemcpy(STm, &(STp->modes[0]), sizeof(struct st_modedef));\n\t\tSTm->cdevs[0] = cd0;\n\t\tSTm->cdevs[1] = cd1;\n\t\tSTm->devs[0]  = d0;\n\t\tSTm->devs[1]  = d1;\n\t\tmodes_defined = 1;\n\t\tDEBC_printk(STp, \"Initialized mode %d definition from mode 0\\n\",\n\t\t\t    STp->current_mode);\n\t}\n\n\tcode = options & MT_ST_OPTIONS;\n\tif (code == MT_ST_BOOLEANS) {\n\t\tSTm->do_buffer_writes = (options & MT_ST_BUFFER_WRITES) != 0;\n\t\tSTm->do_async_writes = (options & MT_ST_ASYNC_WRITES) != 0;\n\t\tSTm->defaults_for_writes = (options & MT_ST_DEF_WRITES) != 0;\n\t\tSTm->do_read_ahead = (options & MT_ST_READ_AHEAD) != 0;\n\t\tSTp->two_fm = (options & MT_ST_TWO_FM) != 0;\n\t\tSTp->fast_mteom = (options & MT_ST_FAST_MTEOM) != 0;\n\t\tSTp->do_auto_lock = (options & MT_ST_AUTO_LOCK) != 0;\n\t\tSTp->can_bsr = (options & MT_ST_CAN_BSR) != 0;\n\t\tSTp->omit_blklims = (options & MT_ST_NO_BLKLIMS) != 0;\n\t\tif ((STp->device)->scsi_level >= SCSI_2)\n\t\t\tSTp->can_partitions = (options & MT_ST_CAN_PARTITIONS) != 0;\n\t\tSTp->scsi2_logical = (options & MT_ST_SCSI2LOGICAL) != 0;\n\t\tSTp->immediate = (options & MT_ST_NOWAIT) != 0;\n\t\tSTp->immediate_filemark = (options & MT_ST_NOWAIT_EOF) != 0;\n\t\tSTm->sysv = (options & MT_ST_SYSV) != 0;\n\t\tSTp->sili = (options & MT_ST_SILI) != 0;\n\t\tDEB( debugging = (options & MT_ST_DEBUGGING) != 0;\n\t\t     st_log_options(STp, STm); )\n\t} else if (code == MT_ST_SETBOOLEANS || code == MT_ST_CLEARBOOLEANS) {\n\t\tvalue = (code == MT_ST_SETBOOLEANS);\n\t\tif ((options & MT_ST_BUFFER_WRITES) != 0)\n\t\t\tSTm->do_buffer_writes = value;\n\t\tif ((options & MT_ST_ASYNC_WRITES) != 0)\n\t\t\tSTm->do_async_writes = value;\n\t\tif ((options & MT_ST_DEF_WRITES) != 0)\n\t\t\tSTm->defaults_for_writes = value;\n\t\tif ((options & MT_ST_READ_AHEAD) != 0)\n\t\t\tSTm->do_read_ahead = value;\n\t\tif ((options & MT_ST_TWO_FM) != 0)\n\t\t\tSTp->two_fm = value;\n\t\tif ((options & MT_ST_FAST_MTEOM) != 0)\n\t\t\tSTp->fast_mteom = value;\n\t\tif ((options & MT_ST_AUTO_LOCK) != 0)\n\t\t\tSTp->do_auto_lock = value;\n\t\tif ((options & MT_ST_CAN_BSR) != 0)\n\t\t\tSTp->can_bsr = value;\n\t\tif ((options & MT_ST_NO_BLKLIMS) != 0)\n\t\t\tSTp->omit_blklims = value;\n\t\tif ((STp->device)->scsi_level >= SCSI_2 &&\n\t\t    (options & MT_ST_CAN_PARTITIONS) != 0)\n\t\t\tSTp->can_partitions = value;\n\t\tif ((options & MT_ST_SCSI2LOGICAL) != 0)\n\t\t\tSTp->scsi2_logical = value;\n\t\tif ((options & MT_ST_NOWAIT) != 0)\n\t\t\tSTp->immediate = value;\n\t\tif ((options & MT_ST_NOWAIT_EOF) != 0)\n\t\t\tSTp->immediate_filemark = value;\n\t\tif ((options & MT_ST_SYSV) != 0)\n\t\t\tSTm->sysv = value;\n\t\tif ((options & MT_ST_SILI) != 0)\n\t\t\tSTp->sili = value;\n\t\tDEB(\n\t\tif ((options & MT_ST_DEBUGGING) != 0)\n\t\t\tdebugging = value;\n\t\t\tst_log_options(STp, STm); )\n\t} else if (code == MT_ST_WRITE_THRESHOLD) {\n\t\t \n\t} else if (code == MT_ST_DEF_BLKSIZE) {\n\t\tvalue = (options & ~MT_ST_OPTIONS);\n\t\tif (value == ~MT_ST_OPTIONS) {\n\t\t\tSTm->default_blksize = (-1);\n\t\t\tDEBC_printk(STp, \"Default block size disabled.\\n\");\n\t\t} else {\n\t\t\tSTm->default_blksize = value;\n\t\t\tDEBC_printk(STp,\"Default block size set to \"\n\t\t\t\t    \"%d bytes.\\n\", STm->default_blksize);\n\t\t\tif (STp->ready == ST_READY) {\n\t\t\t\tSTp->blksize_changed = 0;\n\t\t\t\tset_mode_densblk(STp, STm);\n\t\t\t}\n\t\t}\n\t} else if (code == MT_ST_TIMEOUTS) {\n\t\tvalue = (options & ~MT_ST_OPTIONS);\n\t\tif ((value & MT_ST_SET_LONG_TIMEOUT) != 0) {\n\t\t\tSTp->long_timeout = (value & ~MT_ST_SET_LONG_TIMEOUT) * HZ;\n\t\t\tDEBC_printk(STp, \"Long timeout set to %d seconds.\\n\",\n\t\t\t\t    (value & ~MT_ST_SET_LONG_TIMEOUT));\n\t\t} else {\n\t\t\tblk_queue_rq_timeout(STp->device->request_queue,\n\t\t\t\t\t     value * HZ);\n\t\t\tDEBC_printk(STp, \"Normal timeout set to %d seconds.\\n\",\n\t\t\t\t    value);\n\t\t}\n\t} else if (code == MT_ST_SET_CLN) {\n\t\tvalue = (options & ~MT_ST_OPTIONS) & 0xff;\n\t\tif (value != 0 &&\n\t\t\t(value < EXTENDED_SENSE_START ||\n\t\t\t\tvalue >= SCSI_SENSE_BUFFERSIZE))\n\t\t\treturn (-EINVAL);\n\t\tSTp->cln_mode = value;\n\t\tSTp->cln_sense_mask = (options >> 8) & 0xff;\n\t\tSTp->cln_sense_value = (options >> 16) & 0xff;\n\t\tst_printk(KERN_INFO, STp,\n\t\t\t  \"Cleaning request mode %d, mask %02x, value %02x\\n\",\n\t\t\t  value, STp->cln_sense_mask, STp->cln_sense_value);\n\t} else if (code == MT_ST_DEF_OPTIONS) {\n\t\tcode = (options & ~MT_ST_CLEAR_DEFAULT);\n\t\tvalue = (options & MT_ST_CLEAR_DEFAULT);\n\t\tif (code == MT_ST_DEF_DENSITY) {\n\t\t\tif (value == MT_ST_CLEAR_DEFAULT) {\n\t\t\t\tSTm->default_density = (-1);\n\t\t\t\tDEBC_printk(STp,\n\t\t\t\t\t    \"Density default disabled.\\n\");\n\t\t\t} else {\n\t\t\t\tSTm->default_density = value & 0xff;\n\t\t\t\tDEBC_printk(STp, \"Density default set to %x\\n\",\n\t\t\t\t\t    STm->default_density);\n\t\t\t\tif (STp->ready == ST_READY) {\n\t\t\t\t\tSTp->density_changed = 0;\n\t\t\t\t\tset_mode_densblk(STp, STm);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (code == MT_ST_DEF_DRVBUFFER) {\n\t\t\tif (value == MT_ST_CLEAR_DEFAULT) {\n\t\t\t\tSTp->default_drvbuffer = 0xff;\n\t\t\t\tDEBC_printk(STp,\n\t\t\t\t\t    \"Drive buffer default disabled.\\n\");\n\t\t\t} else {\n\t\t\t\tSTp->default_drvbuffer = value & 7;\n\t\t\t\tDEBC_printk(STp,\n\t\t\t\t\t    \"Drive buffer default set to %x\\n\",\n\t\t\t\t\t    STp->default_drvbuffer);\n\t\t\t\tif (STp->ready == ST_READY)\n\t\t\t\t\tst_int_ioctl(STp, MTSETDRVBUFFER, STp->default_drvbuffer);\n\t\t\t}\n\t\t} else if (code == MT_ST_DEF_COMPRESSION) {\n\t\t\tif (value == MT_ST_CLEAR_DEFAULT) {\n\t\t\t\tSTm->default_compression = ST_DONT_TOUCH;\n\t\t\t\tDEBC_printk(STp,\n\t\t\t\t\t    \"Compression default disabled.\\n\");\n\t\t\t} else {\n\t\t\t\tif ((value & 0xff00) != 0) {\n\t\t\t\t\tSTp->c_algo = (value & 0xff00) >> 8;\n\t\t\t\t\tDEBC_printk(STp, \"Compression \"\n\t\t\t\t\t\t    \"algorithm set to 0x%x.\\n\",\n\t\t\t\t\t\t    STp->c_algo);\n\t\t\t\t}\n\t\t\t\tif ((value & 0xff) != 0xff) {\n\t\t\t\t\tSTm->default_compression = (value & 1 ? ST_YES : ST_NO);\n\t\t\t\t\tDEBC_printk(STp, \"Compression default \"\n\t\t\t\t\t\t    \"set to %x\\n\",\n\t\t\t\t\t\t    (value & 1));\n\t\t\t\t\tif (STp->ready == ST_READY) {\n\t\t\t\t\t\tSTp->compression_changed = 0;\n\t\t\t\t\t\tst_compression(STp, (STm->default_compression == ST_YES));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else\n\t\treturn (-EIO);\n\n\treturn 0;\n}\n\f\n#define MODE_HEADER_LENGTH  4\n\n \n#define MH_OFF_DATA_LENGTH     0\n#define MH_OFF_MEDIUM_TYPE     1\n#define MH_OFF_DEV_SPECIFIC    2\n#define MH_OFF_BDESCS_LENGTH   3\n#define MP_OFF_PAGE_NBR        0\n#define MP_OFF_PAGE_LENGTH     1\n\n \n#define MH_BIT_WP              0x80\n#define MP_MSK_PAGE_NBR        0x3f\n\n \n#define MODE_SENSE_OMIT_BDESCS 0x08\n\n#define MODE_SELECT_PAGE_FORMAT 0x10\n\n \nstatic int read_mode_page(struct scsi_tape *STp, int page, int omit_block_descs)\n{\n\tunsigned char cmd[MAX_COMMAND_SIZE];\n\tstruct st_request *SRpnt;\n\n\tmemset(cmd, 0, MAX_COMMAND_SIZE);\n\tcmd[0] = MODE_SENSE;\n\tif (omit_block_descs)\n\t\tcmd[1] = MODE_SENSE_OMIT_BDESCS;\n\tcmd[2] = page;\n\tcmd[4] = 255;\n\n\tSRpnt = st_do_scsi(NULL, STp, cmd, cmd[4], DMA_FROM_DEVICE,\n\t\t\t   STp->device->request_queue->rq_timeout, 0, 1);\n\tif (SRpnt == NULL)\n\t\treturn (STp->buffer)->syscall_result;\n\n\tst_release_request(SRpnt);\n\n\treturn STp->buffer->syscall_result;\n}\n\n\n \nstatic int write_mode_page(struct scsi_tape *STp, int page, int slow)\n{\n\tint pgo;\n\tunsigned char cmd[MAX_COMMAND_SIZE];\n\tstruct st_request *SRpnt;\n\tint timeout;\n\n\tmemset(cmd, 0, MAX_COMMAND_SIZE);\n\tcmd[0] = MODE_SELECT;\n\tcmd[1] = MODE_SELECT_PAGE_FORMAT;\n\tpgo = MODE_HEADER_LENGTH + (STp->buffer)->b_data[MH_OFF_BDESCS_LENGTH];\n\tcmd[4] = pgo + (STp->buffer)->b_data[pgo + MP_OFF_PAGE_LENGTH] + 2;\n\n\t \n\t(STp->buffer)->b_data[MH_OFF_DATA_LENGTH] = 0;\n\t(STp->buffer)->b_data[MH_OFF_MEDIUM_TYPE] = 0;\n\t(STp->buffer)->b_data[MH_OFF_DEV_SPECIFIC] &= ~MH_BIT_WP;\n\t(STp->buffer)->b_data[pgo + MP_OFF_PAGE_NBR] &= MP_MSK_PAGE_NBR;\n\n\ttimeout = slow ?\n\t\tSTp->long_timeout : STp->device->request_queue->rq_timeout;\n\tSRpnt = st_do_scsi(NULL, STp, cmd, cmd[4], DMA_TO_DEVICE,\n\t\t\t   timeout, 0, 1);\n\tif (SRpnt == NULL)\n\t\treturn (STp->buffer)->syscall_result;\n\n\tst_release_request(SRpnt);\n\n\treturn STp->buffer->syscall_result;\n}\n\n\n#define COMPRESSION_PAGE        0x0f\n#define COMPRESSION_PAGE_LENGTH 16\n\n#define CP_OFF_DCE_DCC          2\n#define CP_OFF_C_ALGO           7\n\n#define DCE_MASK  0x80\n#define DCC_MASK  0x40\n#define RED_MASK  0x60\n\n\n \n\nstatic int st_compression(struct scsi_tape * STp, int state)\n{\n\tint retval;\n\tint mpoffs;   \n\tunsigned char *b_data = (STp->buffer)->b_data;\n\n\tif (STp->ready != ST_READY)\n\t\treturn (-EIO);\n\n\t \n\tretval = read_mode_page(STp, COMPRESSION_PAGE, 0);\n\tif (retval) {\n\t\tDEBC_printk(STp, \"Compression mode page not supported.\\n\");\n\t\treturn (-EIO);\n\t}\n\n\tmpoffs = MODE_HEADER_LENGTH + b_data[MH_OFF_BDESCS_LENGTH];\n\tDEBC_printk(STp, \"Compression state is %d.\\n\",\n\t\t    (b_data[mpoffs + CP_OFF_DCE_DCC] & DCE_MASK ? 1 : 0));\n\n\t \n\tif ((b_data[mpoffs + CP_OFF_DCE_DCC] & DCC_MASK) == 0) {\n\t\tDEBC_printk(STp, \"Compression not supported.\\n\");\n\t\treturn (-EIO);\n\t}\n\n\t \n\tif (state) {\n\t\tb_data[mpoffs + CP_OFF_DCE_DCC] |= DCE_MASK;\n\t\tif (STp->c_algo != 0)\n\t\t\tb_data[mpoffs + CP_OFF_C_ALGO] = STp->c_algo;\n\t}\n\telse {\n\t\tb_data[mpoffs + CP_OFF_DCE_DCC] &= ~DCE_MASK;\n\t\tif (STp->c_algo != 0)\n\t\t\tb_data[mpoffs + CP_OFF_C_ALGO] = 0;  \n\t}\n\n\tretval = write_mode_page(STp, COMPRESSION_PAGE, 0);\n\tif (retval) {\n\t\tDEBC_printk(STp, \"Compression change failed.\\n\");\n\t\treturn (-EIO);\n\t}\n\tDEBC_printk(STp, \"Compression state changed to %d.\\n\", state);\n\n\tSTp->compression_changed = 1;\n\treturn 0;\n}\n\n\n \nstatic int do_load_unload(struct scsi_tape *STp, struct file *filp, int load_code)\n{\n\tint retval = (-EIO), timeout;\n\tunsigned char cmd[MAX_COMMAND_SIZE];\n\tstruct st_partstat *STps;\n\tstruct st_request *SRpnt;\n\n\tif (STp->ready != ST_READY && !load_code) {\n\t\tif (STp->ready == ST_NO_TAPE)\n\t\t\treturn (-ENOMEDIUM);\n\t\telse\n\t\t\treturn (-EIO);\n\t}\n\n\tmemset(cmd, 0, MAX_COMMAND_SIZE);\n\tcmd[0] = START_STOP;\n\tif (load_code)\n\t\tcmd[4] |= 1;\n\t \n\tif (load_code >= 1 + MT_ST_HPLOADER_OFFSET\n\t    && load_code <= 6 + MT_ST_HPLOADER_OFFSET) {\n\t\tDEBC_printk(STp, \" Enhanced %sload slot %2d.\\n\",\n\t\t\t    (cmd[4]) ? \"\" : \"un\",\n\t\t\t    load_code - MT_ST_HPLOADER_OFFSET);\n\t\tcmd[3] = load_code - MT_ST_HPLOADER_OFFSET;  \n\t}\n\tif (STp->immediate) {\n\t\tcmd[1] = 1;\t \n\t\ttimeout = STp->device->request_queue->rq_timeout;\n\t}\n\telse\n\t\ttimeout = STp->long_timeout;\n\n\tDEBC(\n\t\tif (!load_code)\n\t\t\tst_printk(ST_DEB_MSG, STp, \"Unloading tape.\\n\");\n\t\telse\n\t\t\tst_printk(ST_DEB_MSG, STp, \"Loading tape.\\n\");\n\t\t);\n\n\tSRpnt = st_do_scsi(NULL, STp, cmd, 0, DMA_NONE,\n\t\t\t   timeout, MAX_RETRIES, 1);\n\tif (!SRpnt)\n\t\treturn (STp->buffer)->syscall_result;\n\n\tretval = (STp->buffer)->syscall_result;\n\tst_release_request(SRpnt);\n\n\tif (!retval) {\t \n\n\t\tif (!load_code) {\n\t\t\tSTp->rew_at_close = 0;\n\t\t\tSTp->ready = ST_NO_TAPE;\n\t\t}\n\t\telse {\n\t\t\tSTp->rew_at_close = STp->autorew_dev;\n\t\t\tretval = check_tape(STp, filp);\n\t\t\tif (retval > 0)\n\t\t\t\tretval = 0;\n\t\t}\n\t}\n\telse {\n\t\tSTps = &(STp->ps[STp->partition]);\n\t\tSTps->drv_file = STps->drv_block = (-1);\n\t}\n\n\treturn retval;\n}\n\f\n#if DEBUG\n#define ST_DEB_FORWARD  0\n#define ST_DEB_BACKWARD 1\nstatic void deb_space_print(struct scsi_tape *STp, int direction, char *units, unsigned char *cmd)\n{\n\ts32 sc;\n\n\tif (!debugging)\n\t\treturn;\n\n\tsc = sign_extend32(get_unaligned_be24(&cmd[2]), 23);\n\tif (direction)\n\t\tsc = -sc;\n\tst_printk(ST_DEB_MSG, STp, \"Spacing tape %s over %d %s.\\n\",\n\t\t  direction ? \"backward\" : \"forward\", sc, units);\n}\n#else\n#define ST_DEB_FORWARD  0\n#define ST_DEB_BACKWARD 1\nstatic void deb_space_print(struct scsi_tape *STp, int direction, char *units, unsigned char *cmd) {}\n#endif\n\n\n \nstatic int st_int_ioctl(struct scsi_tape *STp, unsigned int cmd_in, unsigned long arg)\n{\n\tint timeout;\n\tlong ltmp;\n\tint ioctl_result;\n\tint chg_eof = 1;\n\tunsigned char cmd[MAX_COMMAND_SIZE];\n\tstruct st_request *SRpnt;\n\tstruct st_partstat *STps;\n\tint fileno, blkno, at_sm, undone;\n\tint datalen = 0, direction = DMA_NONE;\n\n\tWARN_ON(STp->buffer->do_dio != 0);\n\tif (STp->ready != ST_READY) {\n\t\tif (STp->ready == ST_NO_TAPE)\n\t\t\treturn (-ENOMEDIUM);\n\t\telse\n\t\t\treturn (-EIO);\n\t}\n\ttimeout = STp->long_timeout;\n\tSTps = &(STp->ps[STp->partition]);\n\tfileno = STps->drv_file;\n\tblkno = STps->drv_block;\n\tat_sm = STps->at_sm;\n\n\tmemset(cmd, 0, MAX_COMMAND_SIZE);\n\tswitch (cmd_in) {\n\tcase MTFSFM:\n\t\tchg_eof = 0;\t \n\t\tfallthrough;\n\tcase MTFSF:\n\t\tcmd[0] = SPACE;\n\t\tcmd[1] = 0x01;\t \n\t\tcmd[2] = (arg >> 16);\n\t\tcmd[3] = (arg >> 8);\n\t\tcmd[4] = arg;\n\t\tdeb_space_print(STp, ST_DEB_FORWARD, \"filemarks\", cmd);\n\t\tif (fileno >= 0)\n\t\t\tfileno += arg;\n\t\tblkno = 0;\n\t\tat_sm &= (arg == 0);\n\t\tbreak;\n\tcase MTBSFM:\n\t\tchg_eof = 0;\t \n\t\tfallthrough;\n\tcase MTBSF:\n\t\tcmd[0] = SPACE;\n\t\tcmd[1] = 0x01;\t \n\t\tltmp = (-arg);\n\t\tcmd[2] = (ltmp >> 16);\n\t\tcmd[3] = (ltmp >> 8);\n\t\tcmd[4] = ltmp;\n\t\tdeb_space_print(STp, ST_DEB_BACKWARD, \"filemarks\", cmd);\n\t\tif (fileno >= 0)\n\t\t\tfileno -= arg;\n\t\tblkno = (-1);\t \n\t\tat_sm &= (arg == 0);\n\t\tbreak;\n\tcase MTFSR:\n\t\tcmd[0] = SPACE;\n\t\tcmd[1] = 0x00;\t \n\t\tcmd[2] = (arg >> 16);\n\t\tcmd[3] = (arg >> 8);\n\t\tcmd[4] = arg;\n\t\tdeb_space_print(STp, ST_DEB_FORWARD, \"blocks\", cmd);\n\t\tif (blkno >= 0)\n\t\t\tblkno += arg;\n\t\tat_sm &= (arg == 0);\n\t\tbreak;\n\tcase MTBSR:\n\t\tcmd[0] = SPACE;\n\t\tcmd[1] = 0x00;\t \n\t\tltmp = (-arg);\n\t\tcmd[2] = (ltmp >> 16);\n\t\tcmd[3] = (ltmp >> 8);\n\t\tcmd[4] = ltmp;\n\t\tdeb_space_print(STp, ST_DEB_BACKWARD, \"blocks\", cmd);\n\t\tif (blkno >= 0)\n\t\t\tblkno -= arg;\n\t\tat_sm &= (arg == 0);\n\t\tbreak;\n\tcase MTFSS:\n\t\tcmd[0] = SPACE;\n\t\tcmd[1] = 0x04;\t \n\t\tcmd[2] = (arg >> 16);\n\t\tcmd[3] = (arg >> 8);\n\t\tcmd[4] = arg;\n\t\tdeb_space_print(STp, ST_DEB_FORWARD, \"setmarks\", cmd);\n\t\tif (arg != 0) {\n\t\t\tblkno = fileno = (-1);\n\t\t\tat_sm = 1;\n\t\t}\n\t\tbreak;\n\tcase MTBSS:\n\t\tcmd[0] = SPACE;\n\t\tcmd[1] = 0x04;\t \n\t\tltmp = (-arg);\n\t\tcmd[2] = (ltmp >> 16);\n\t\tcmd[3] = (ltmp >> 8);\n\t\tcmd[4] = ltmp;\n\t\tdeb_space_print(STp, ST_DEB_BACKWARD, \"setmarks\", cmd);\n\t\tif (arg != 0) {\n\t\t\tblkno = fileno = (-1);\n\t\t\tat_sm = 1;\n\t\t}\n\t\tbreak;\n\tcase MTWEOF:\n\tcase MTWEOFI:\n\tcase MTWSM:\n\t\tif (STp->write_prot)\n\t\t\treturn (-EACCES);\n\t\tcmd[0] = WRITE_FILEMARKS;\n\t\tif (cmd_in == MTWSM)\n\t\t\tcmd[1] = 2;\n\t\tif (cmd_in == MTWEOFI ||\n\t\t    (cmd_in == MTWEOF && STp->immediate_filemark))\n\t\t\tcmd[1] |= 1;\n\t\tcmd[2] = (arg >> 16);\n\t\tcmd[3] = (arg >> 8);\n\t\tcmd[4] = arg;\n\t\ttimeout = STp->device->request_queue->rq_timeout;\n\t\tDEBC(\n\t\t\tif (cmd_in != MTWSM)\n\t\t\t\tst_printk(ST_DEB_MSG, STp,\n\t\t\t\t\t  \"Writing %d filemarks.\\n\",\n\t\t\t\t\t  cmd[2] * 65536 +\n\t\t\t\t\t  cmd[3] * 256 +\n\t\t\t\t\t  cmd[4]);\n\t\t\telse\n\t\t\t\tst_printk(ST_DEB_MSG, STp,\n\t\t\t\t\t  \"Writing %d setmarks.\\n\",\n\t\t\t\t\t  cmd[2] * 65536 +\n\t\t\t\t\t  cmd[3] * 256 +\n\t\t\t\t\t  cmd[4]);\n\t\t)\n\t\tif (fileno >= 0)\n\t\t\tfileno += arg;\n\t\tblkno = 0;\n\t\tat_sm = (cmd_in == MTWSM);\n\t\tbreak;\n\tcase MTREW:\n\t\tcmd[0] = REZERO_UNIT;\n\t\tif (STp->immediate) {\n\t\t\tcmd[1] = 1;\t \n\t\t\ttimeout = STp->device->request_queue->rq_timeout;\n\t\t}\n\t\tDEBC_printk(STp, \"Rewinding tape.\\n\");\n\t\tfileno = blkno = at_sm = 0;\n\t\tbreak;\n\tcase MTNOP:\n\t\tDEBC_printk(STp, \"No op on tape.\\n\");\n\t\treturn 0;\t \n\tcase MTRETEN:\n\t\tcmd[0] = START_STOP;\n\t\tif (STp->immediate) {\n\t\t\tcmd[1] = 1;\t \n\t\t\ttimeout = STp->device->request_queue->rq_timeout;\n\t\t}\n\t\tcmd[4] = 3;\n\t\tDEBC_printk(STp, \"Retensioning tape.\\n\");\n\t\tfileno = blkno = at_sm = 0;\n\t\tbreak;\n\tcase MTEOM:\n\t\tif (!STp->fast_mteom) {\n\t\t\t \n\t\t\tioctl_result = st_int_ioctl(STp, MTFSF, 0x7fffff);\n\t\t\tfileno = STps->drv_file;\n\t\t\tif (STps->eof >= ST_EOD_1)\n\t\t\t\treturn 0;\n\t\t\t \n\t\t} else\n\t\t\tfileno = (-1);\n\t\tcmd[0] = SPACE;\n\t\tcmd[1] = 3;\n\t\tDEBC_printk(STp, \"Spacing to end of recorded medium.\\n\");\n\t\tblkno = -1;\n\t\tat_sm = 0;\n\t\tbreak;\n\tcase MTERASE:\n\t\tif (STp->write_prot)\n\t\t\treturn (-EACCES);\n\t\tcmd[0] = ERASE;\n\t\tcmd[1] = (arg ? 1 : 0);\t \n\t\tif (STp->immediate) {\n\t\t\tcmd[1] |= 2;\t \n\t\t\ttimeout = STp->device->request_queue->rq_timeout;\n\t\t}\n\t\telse\n\t\t\ttimeout = STp->long_timeout * 8;\n\n\t\tDEBC_printk(STp, \"Erasing tape.\\n\");\n\t\tfileno = blkno = at_sm = 0;\n\t\tbreak;\n\tcase MTSETBLK:\t\t \n\tcase MTSETDENSITY:\t \n\tcase MTSETDRVBUFFER:\t \n\tcase SET_DENS_AND_BLK:\t \n\t\tchg_eof = 0;\n\t\tif (STp->dirty || (STp->buffer)->buffer_bytes != 0)\n\t\t\treturn (-EIO);\t \n\t\tif ((cmd_in == MTSETBLK || cmd_in == SET_DENS_AND_BLK) &&\n\t\t    (arg & MT_ST_BLKSIZE_MASK) != 0 &&\n\t\t    STp->max_block > 0 &&\n\t\t    ((arg & MT_ST_BLKSIZE_MASK) < STp->min_block ||\n\t\t     (arg & MT_ST_BLKSIZE_MASK) > STp->max_block)) {\n\t\t\tst_printk(KERN_WARNING, STp, \"Illegal block size.\\n\");\n\t\t\treturn (-EINVAL);\n\t\t}\n\t\tcmd[0] = MODE_SELECT;\n\t\tif ((STp->use_pf & USE_PF))\n\t\t\tcmd[1] = MODE_SELECT_PAGE_FORMAT;\n\t\tcmd[4] = datalen = 12;\n\t\tdirection = DMA_TO_DEVICE;\n\n\t\tmemset((STp->buffer)->b_data, 0, 12);\n\t\tif (cmd_in == MTSETDRVBUFFER)\n\t\t\t(STp->buffer)->b_data[2] = (arg & 7) << 4;\n\t\telse\n\t\t\t(STp->buffer)->b_data[2] =\n\t\t\t    STp->drv_buffer << 4;\n\t\t(STp->buffer)->b_data[3] = 8;\t \n\t\tif (cmd_in == MTSETDENSITY) {\n\t\t\t(STp->buffer)->b_data[4] = arg;\n\t\t\tSTp->density_changed = 1;\t \n\t\t} else if (cmd_in == SET_DENS_AND_BLK)\n\t\t\t(STp->buffer)->b_data[4] = arg >> 24;\n\t\telse\n\t\t\t(STp->buffer)->b_data[4] = STp->density;\n\t\tif (cmd_in == MTSETBLK || cmd_in == SET_DENS_AND_BLK) {\n\t\t\tltmp = arg & MT_ST_BLKSIZE_MASK;\n\t\t\tif (cmd_in == MTSETBLK)\n\t\t\t\tSTp->blksize_changed = 1;  \n\t\t} else\n\t\t\tltmp = STp->block_size;\n\t\t(STp->buffer)->b_data[9] = (ltmp >> 16);\n\t\t(STp->buffer)->b_data[10] = (ltmp >> 8);\n\t\t(STp->buffer)->b_data[11] = ltmp;\n\t\ttimeout = STp->device->request_queue->rq_timeout;\n\t\tDEBC(\n\t\t\tif (cmd_in == MTSETBLK || cmd_in == SET_DENS_AND_BLK)\n\t\t\t\tst_printk(ST_DEB_MSG, STp,\n\t\t\t\t\t  \"Setting block size to %d bytes.\\n\",\n\t\t\t\t\t  (STp->buffer)->b_data[9] * 65536 +\n\t\t\t\t\t  (STp->buffer)->b_data[10] * 256 +\n\t\t\t\t\t  (STp->buffer)->b_data[11]);\n\t\t\tif (cmd_in == MTSETDENSITY || cmd_in == SET_DENS_AND_BLK)\n\t\t\t\tst_printk(ST_DEB_MSG, STp,\n\t\t\t\t\t  \"Setting density code to %x.\\n\",\n\t\t\t\t\t  (STp->buffer)->b_data[4]);\n\t\t\tif (cmd_in == MTSETDRVBUFFER)\n\t\t\t\tst_printk(ST_DEB_MSG, STp,\n\t\t\t\t\t  \"Setting drive buffer code to %d.\\n\",\n\t\t\t\t\t  ((STp->buffer)->b_data[2] >> 4) & 7);\n\t\t)\n\t\tbreak;\n\tdefault:\n\t\treturn (-ENOSYS);\n\t}\n\n\tSRpnt = st_do_scsi(NULL, STp, cmd, datalen, direction,\n\t\t\t   timeout, MAX_RETRIES, 1);\n\tif (!SRpnt)\n\t\treturn (STp->buffer)->syscall_result;\n\n\tioctl_result = (STp->buffer)->syscall_result;\n\n\tif (!ioctl_result) {\t \n\t\tst_release_request(SRpnt);\n\t\tSRpnt = NULL;\n\t\tSTps->drv_block = blkno;\n\t\tSTps->drv_file = fileno;\n\t\tSTps->at_sm = at_sm;\n\n\t\tif (cmd_in == MTBSFM)\n\t\t\tioctl_result = st_int_ioctl(STp, MTFSF, 1);\n\t\telse if (cmd_in == MTFSFM)\n\t\t\tioctl_result = st_int_ioctl(STp, MTBSF, 1);\n\n\t\tif (cmd_in == MTSETBLK || cmd_in == SET_DENS_AND_BLK) {\n\t\t\tSTp->block_size = arg & MT_ST_BLKSIZE_MASK;\n\t\t\tif (STp->block_size != 0) {\n\t\t\t\t(STp->buffer)->buffer_blocks =\n\t\t\t\t    (STp->buffer)->buffer_size / STp->block_size;\n\t\t\t}\n\t\t\t(STp->buffer)->buffer_bytes = (STp->buffer)->read_pointer = 0;\n\t\t\tif (cmd_in == SET_DENS_AND_BLK)\n\t\t\t\tSTp->density = arg >> MT_ST_DENSITY_SHIFT;\n\t\t} else if (cmd_in == MTSETDRVBUFFER)\n\t\t\tSTp->drv_buffer = (arg & 7);\n\t\telse if (cmd_in == MTSETDENSITY)\n\t\t\tSTp->density = arg;\n\n\t\tif (cmd_in == MTEOM)\n\t\t\tSTps->eof = ST_EOD;\n\t\telse if (cmd_in == MTFSF)\n\t\t\tSTps->eof = ST_FM;\n\t\telse if (chg_eof)\n\t\t\tSTps->eof = ST_NOEOF;\n\n\t\tif (cmd_in == MTWEOF || cmd_in == MTWEOFI)\n\t\t\tSTps->rw = ST_IDLE;   \n\t} else {  \n\t\tstruct st_cmdstatus *cmdstatp = &STp->buffer->cmdstat;\n\n\t\tif (cmdstatp->flags & SENSE_EOM) {\n\t\t\tif (cmd_in != MTBSF && cmd_in != MTBSFM &&\n\t\t\t    cmd_in != MTBSR && cmd_in != MTBSS)\n\t\t\t\tSTps->eof = ST_EOM_OK;\n\t\t\tSTps->drv_block = 0;\n\t\t}\n\n\t\tif (cmdstatp->remainder_valid)\n\t\t\tundone = (int)cmdstatp->uremainder64;\n\t\telse\n\t\t\tundone = 0;\n\n\t\tif ((cmd_in == MTWEOF || cmd_in == MTWEOFI) &&\n\t\t    cmdstatp->have_sense &&\n\t\t    (cmdstatp->flags & SENSE_EOM)) {\n\t\t\tif (cmdstatp->sense_hdr.sense_key == NO_SENSE ||\n\t\t\t    cmdstatp->sense_hdr.sense_key == RECOVERED_ERROR) {\n\t\t\t\tioctl_result = 0;\t \n\t\t\t\tSTps->eof = ST_NOEOF;\n\t\t\t} else {   \n\t\t\t\tif (fileno >= 0)\n\t\t\t\t\tfileno -= undone;\n\t\t\t\tif (undone < arg)\n\t\t\t\t\tSTps->eof = ST_NOEOF;\n\t\t\t}\n\t\t\tSTps->drv_file = fileno;\n\t\t} else if ((cmd_in == MTFSF) || (cmd_in == MTFSFM)) {\n\t\t\tif (fileno >= 0)\n\t\t\t\tSTps->drv_file = fileno - undone;\n\t\t\telse\n\t\t\t\tSTps->drv_file = fileno;\n\t\t\tSTps->drv_block = -1;\n\t\t\tSTps->eof = ST_NOEOF;\n\t\t} else if ((cmd_in == MTBSF) || (cmd_in == MTBSFM)) {\n\t\t\tif (arg > 0 && undone < 0)   \n\t\t\t\tundone = (-undone);\n\t\t\tif (STps->drv_file >= 0)\n\t\t\t\tSTps->drv_file = fileno + undone;\n\t\t\tSTps->drv_block = 0;\n\t\t\tSTps->eof = ST_NOEOF;\n\t\t} else if (cmd_in == MTFSR) {\n\t\t\tif (cmdstatp->flags & SENSE_FMK) {\t \n\t\t\t\tif (STps->drv_file >= 0)\n\t\t\t\t\tSTps->drv_file++;\n\t\t\t\tSTps->drv_block = 0;\n\t\t\t\tSTps->eof = ST_FM;\n\t\t\t} else {\n\t\t\t\tif (blkno >= undone)\n\t\t\t\t\tSTps->drv_block = blkno - undone;\n\t\t\t\telse\n\t\t\t\t\tSTps->drv_block = (-1);\n\t\t\t\tSTps->eof = ST_NOEOF;\n\t\t\t}\n\t\t} else if (cmd_in == MTBSR) {\n\t\t\tif (cmdstatp->flags & SENSE_FMK) {\t \n\t\t\t\tSTps->drv_file--;\n\t\t\t\tSTps->drv_block = (-1);\n\t\t\t} else {\n\t\t\t\tif (arg > 0 && undone < 0)   \n\t\t\t\t\tundone = (-undone);\n\t\t\t\tif (STps->drv_block >= 0)\n\t\t\t\t\tSTps->drv_block = blkno + undone;\n\t\t\t}\n\t\t\tSTps->eof = ST_NOEOF;\n\t\t} else if (cmd_in == MTEOM) {\n\t\t\tSTps->drv_file = (-1);\n\t\t\tSTps->drv_block = (-1);\n\t\t\tSTps->eof = ST_EOD;\n\t\t} else if (cmd_in == MTSETBLK ||\n\t\t\t   cmd_in == MTSETDENSITY ||\n\t\t\t   cmd_in == MTSETDRVBUFFER ||\n\t\t\t   cmd_in == SET_DENS_AND_BLK) {\n\t\t\tif (cmdstatp->sense_hdr.sense_key == ILLEGAL_REQUEST &&\n\t\t\t    !(STp->use_pf & PF_TESTED)) {\n\t\t\t\t \n\t\t\t\tSTp->use_pf = (STp->use_pf ^ USE_PF) | PF_TESTED;\n\t\t\t\tst_release_request(SRpnt);\n\t\t\t\tSRpnt = NULL;\n\t\t\t\treturn st_int_ioctl(STp, cmd_in, arg);\n\t\t\t}\n\t\t} else if (chg_eof)\n\t\t\tSTps->eof = ST_NOEOF;\n\n\t\tif (cmdstatp->sense_hdr.sense_key == BLANK_CHECK)\n\t\t\tSTps->eof = ST_EOD;\n\n\t\tst_release_request(SRpnt);\n\t\tSRpnt = NULL;\n\t}\n\n\treturn ioctl_result;\n}\n\f\n\n \n\nstatic int get_location(struct scsi_tape *STp, unsigned int *block, int *partition,\n\t\t\tint logical)\n{\n\tint result;\n\tunsigned char scmd[MAX_COMMAND_SIZE];\n\tstruct st_request *SRpnt;\n\n\tif (STp->ready != ST_READY)\n\t\treturn (-EIO);\n\n\tmemset(scmd, 0, MAX_COMMAND_SIZE);\n\tif ((STp->device)->scsi_level < SCSI_2) {\n\t\tscmd[0] = QFA_REQUEST_BLOCK;\n\t\tscmd[4] = 3;\n\t} else {\n\t\tscmd[0] = READ_POSITION;\n\t\tif (!logical && !STp->scsi2_logical)\n\t\t\tscmd[1] = 1;\n\t}\n\tSRpnt = st_do_scsi(NULL, STp, scmd, 20, DMA_FROM_DEVICE,\n\t\t\t   STp->device->request_queue->rq_timeout,\n\t\t\t   MAX_READY_RETRIES, 1);\n\tif (!SRpnt)\n\t\treturn (STp->buffer)->syscall_result;\n\n\tif ((STp->buffer)->syscall_result != 0 ||\n\t    (STp->device->scsi_level >= SCSI_2 &&\n\t     ((STp->buffer)->b_data[0] & 4) != 0)) {\n\t\t*block = *partition = 0;\n\t\tDEBC_printk(STp, \" Can't read tape position.\\n\");\n\t\tresult = (-EIO);\n\t} else {\n\t\tresult = 0;\n\t\tif ((STp->device)->scsi_level < SCSI_2) {\n\t\t\t*block = ((STp->buffer)->b_data[0] << 16)\n\t\t\t    + ((STp->buffer)->b_data[1] << 8)\n\t\t\t    + (STp->buffer)->b_data[2];\n\t\t\t*partition = 0;\n\t\t} else {\n\t\t\t*block = ((STp->buffer)->b_data[4] << 24)\n\t\t\t    + ((STp->buffer)->b_data[5] << 16)\n\t\t\t    + ((STp->buffer)->b_data[6] << 8)\n\t\t\t    + (STp->buffer)->b_data[7];\n\t\t\t*partition = (STp->buffer)->b_data[1];\n\t\t\tif (((STp->buffer)->b_data[0] & 0x80) &&\n\t\t\t    (STp->buffer)->b_data[1] == 0)\t \n\t\t\t\tSTp->ps[0].drv_block = STp->ps[0].drv_file = 0;\n\t\t}\n\t\tDEBC_printk(STp, \"Got tape pos. blk %d part %d.\\n\",\n\t\t\t    *block, *partition);\n\t}\n\tst_release_request(SRpnt);\n\tSRpnt = NULL;\n\n\treturn result;\n}\n\n\n \nstatic int set_location(struct scsi_tape *STp, unsigned int block, int partition,\n\t\t\tint logical)\n{\n\tstruct st_partstat *STps;\n\tint result, p;\n\tunsigned int blk;\n\tint timeout;\n\tunsigned char scmd[MAX_COMMAND_SIZE];\n\tstruct st_request *SRpnt;\n\n\tif (STp->ready != ST_READY)\n\t\treturn (-EIO);\n\ttimeout = STp->long_timeout;\n\tSTps = &(STp->ps[STp->partition]);\n\n\tDEBC_printk(STp, \"Setting block to %d and partition to %d.\\n\",\n\t\t    block, partition);\n\tDEB(if (partition < 0)\n\t\treturn (-EIO); )\n\n\t \n\tif ((!STp->can_partitions && partition != 0) ||\n\t    partition >= ST_NBR_PARTITIONS)\n\t\treturn (-EINVAL);\n\tif (partition != STp->partition) {\n\t\tif (get_location(STp, &blk, &p, 1))\n\t\t\tSTps->last_block_valid = 0;\n\t\telse {\n\t\t\tSTps->last_block_valid = 1;\n\t\t\tSTps->last_block_visited = blk;\n\t\t\tDEBC_printk(STp, \"Visited block %d for \"\n\t\t\t\t    \"partition %d saved.\\n\",\n\t\t\t\t    blk, STp->partition);\n\t\t}\n\t}\n\n\tmemset(scmd, 0, MAX_COMMAND_SIZE);\n\tif ((STp->device)->scsi_level < SCSI_2) {\n\t\tscmd[0] = QFA_SEEK_BLOCK;\n\t\tscmd[2] = (block >> 16);\n\t\tscmd[3] = (block >> 8);\n\t\tscmd[4] = block;\n\t\tscmd[5] = 0;\n\t} else {\n\t\tscmd[0] = SEEK_10;\n\t\tscmd[3] = (block >> 24);\n\t\tscmd[4] = (block >> 16);\n\t\tscmd[5] = (block >> 8);\n\t\tscmd[6] = block;\n\t\tif (!logical && !STp->scsi2_logical)\n\t\t\tscmd[1] = 4;\n\t\tif (STp->partition != partition) {\n\t\t\tscmd[1] |= 2;\n\t\t\tscmd[8] = partition;\n\t\t\tDEBC_printk(STp, \"Trying to change partition \"\n\t\t\t\t    \"from %d to %d\\n\", STp->partition,\n\t\t\t\t    partition);\n\t\t}\n\t}\n\tif (STp->immediate) {\n\t\tscmd[1] |= 1;\t\t \n\t\ttimeout = STp->device->request_queue->rq_timeout;\n\t}\n\n\tSRpnt = st_do_scsi(NULL, STp, scmd, 0, DMA_NONE,\n\t\t\t   timeout, MAX_READY_RETRIES, 1);\n\tif (!SRpnt)\n\t\treturn (STp->buffer)->syscall_result;\n\n\tSTps->drv_block = STps->drv_file = (-1);\n\tSTps->eof = ST_NOEOF;\n\tif ((STp->buffer)->syscall_result != 0) {\n\t\tresult = (-EIO);\n\t\tif (STp->can_partitions &&\n\t\t    (STp->device)->scsi_level >= SCSI_2 &&\n\t\t    (p = find_partition(STp)) >= 0)\n\t\t\tSTp->partition = p;\n\t} else {\n\t\tif (STp->can_partitions) {\n\t\t\tSTp->partition = partition;\n\t\t\tSTps = &(STp->ps[partition]);\n\t\t\tif (!STps->last_block_valid ||\n\t\t\t    STps->last_block_visited != block) {\n\t\t\t\tSTps->at_sm = 0;\n\t\t\t\tSTps->rw = ST_IDLE;\n\t\t\t}\n\t\t} else\n\t\t\tSTps->at_sm = 0;\n\t\tif (block == 0)\n\t\t\tSTps->drv_block = STps->drv_file = 0;\n\t\tresult = 0;\n\t}\n\n\tst_release_request(SRpnt);\n\tSRpnt = NULL;\n\n\treturn result;\n}\n\n\n \nstatic int find_partition(struct scsi_tape *STp)\n{\n\tint i, partition;\n\tunsigned int block;\n\n\tif ((i = get_location(STp, &block, &partition, 1)) < 0)\n\t\treturn i;\n\tif (partition >= ST_NBR_PARTITIONS)\n\t\treturn (-EIO);\n\treturn partition;\n}\n\n\n \nstatic int switch_partition(struct scsi_tape *STp)\n{\n\tstruct st_partstat *STps;\n\n\tif (STp->partition == STp->new_partition)\n\t\treturn 0;\n\tSTps = &(STp->ps[STp->new_partition]);\n\tif (!STps->last_block_valid)\n\t\tSTps->last_block_visited = 0;\n\treturn set_location(STp, STps->last_block_visited, STp->new_partition, 1);\n}\n\f\n \n\n#define PART_PAGE   0x11\n#define PART_PAGE_FIXED_LENGTH 8\n\n#define PP_OFF_MAX_ADD_PARTS   2\n#define PP_OFF_NBR_ADD_PARTS   3\n#define PP_OFF_FLAGS           4\n#define PP_OFF_PART_UNITS      6\n#define PP_OFF_RESERVED        7\n\n#define PP_BIT_IDP             0x20\n#define PP_BIT_FDP             0x80\n#define PP_MSK_PSUM_MB         0x10\n#define PP_MSK_PSUM_UNITS      0x18\n#define PP_MSK_POFM            0x04\n\n \nstatic int nbr_partitions(struct scsi_tape *STp)\n{\n\tint result;\n\n\tif (STp->ready != ST_READY)\n\t\treturn (-EIO);\n\n\tresult = read_mode_page(STp, PART_PAGE, 1);\n\n\tif (result) {\n\t\tDEBC_printk(STp, \"Can't read medium partition page.\\n\");\n\t\tresult = (-EIO);\n\t} else {\n\t\tresult = (STp->buffer)->b_data[MODE_HEADER_LENGTH +\n\t\t\t\t\t      PP_OFF_NBR_ADD_PARTS] + 1;\n\t\tDEBC_printk(STp, \"Number of partitions %d.\\n\", result);\n\t}\n\n\treturn result;\n}\n\n\nstatic int format_medium(struct scsi_tape *STp, int format)\n{\n\tint result = 0;\n\tint timeout = STp->long_timeout;\n\tunsigned char scmd[MAX_COMMAND_SIZE];\n\tstruct st_request *SRpnt;\n\n\tmemset(scmd, 0, MAX_COMMAND_SIZE);\n\tscmd[0] = FORMAT_UNIT;\n\tscmd[2] = format;\n\tif (STp->immediate) {\n\t\tscmd[1] |= 1;\t\t \n\t\ttimeout = STp->device->request_queue->rq_timeout;\n\t}\n\tDEBC_printk(STp, \"Sending FORMAT MEDIUM\\n\");\n\tSRpnt = st_do_scsi(NULL, STp, scmd, 0, DMA_NONE,\n\t\t\t   timeout, MAX_RETRIES, 1);\n\tif (!SRpnt)\n\t\tresult = STp->buffer->syscall_result;\n\treturn result;\n}\n\n\n \nstatic int partition_tape(struct scsi_tape *STp, int size)\n{\n\tint result;\n\tint target_partition;\n\tbool scsi3 = STp->device->scsi_level >= SCSI_3, needs_format = false;\n\tint pgo, psd_cnt, psdo;\n\tint psum = PP_MSK_PSUM_MB, units = 0;\n\tunsigned char *bp;\n\n\tresult = read_mode_page(STp, PART_PAGE, 0);\n\tif (result) {\n\t\tDEBC_printk(STp, \"Can't read partition mode page.\\n\");\n\t\treturn result;\n\t}\n\ttarget_partition = 1;\n\tif (size < 0) {\n\t\ttarget_partition = 0;\n\t\tsize = -size;\n\t}\n\n\t \n\tbp = (STp->buffer)->b_data;\n\tpgo = MODE_HEADER_LENGTH + bp[MH_OFF_BDESCS_LENGTH];\n\tDEBC_printk(STp, \"Partition page length is %d bytes.\\n\",\n\t\t    bp[pgo + MP_OFF_PAGE_LENGTH] + 2);\n\n\tpsd_cnt = (bp[pgo + MP_OFF_PAGE_LENGTH] + 2 - PART_PAGE_FIXED_LENGTH) / 2;\n\n\tif (scsi3) {\n\t\tneeds_format = (bp[pgo + PP_OFF_FLAGS] & PP_MSK_POFM) != 0;\n\t\tif (needs_format && size == 0) {\n\t\t\t \n\t\t\tDEBC_printk(STp, \"Formatting tape with one partition.\\n\");\n\t\t\tresult = format_medium(STp, 0);\n\t\t\tgoto out;\n\t\t}\n\t\tif (needs_format)   \n\t\t\tpsd_cnt = 2;\n\t\tif ((bp[pgo + PP_OFF_FLAGS] & PP_MSK_PSUM_UNITS) == PP_MSK_PSUM_UNITS) {\n\t\t\t \n\t\t\tif (size >= 1000 && (size % 1000) == 0) {\n\t\t\t\tsize /= 1000;\n\t\t\t\tpsum = PP_MSK_PSUM_UNITS;\n\t\t\t\tunits = 9;  \n\t\t\t}\n\t\t}\n\t\t \n\t\tif (psum == PP_MSK_PSUM_MB && size >= 65534) {\n\t\t\tsize /= 1000;\n\t\t\tpsum = PP_MSK_PSUM_UNITS;\n\t\t\tunits = 9;   \n\t\t}\n\t}\n\n\tif (size >= 65535 ||   \n\t    (target_partition == 0 && psd_cnt < 2)) {\n\t\tresult = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpsdo = pgo + PART_PAGE_FIXED_LENGTH;\n\t \n\tif (target_partition > 0 &&\n\t    (psd_cnt > bp[pgo + PP_OFF_MAX_ADD_PARTS] ||\n\t     bp[pgo + PP_OFF_MAX_ADD_PARTS] != 1)) {\n\t\tbp[psdo] = bp[psdo + 1] = 0xff;   \n\t\tpsdo += 2;\n\t}\n\tmemset(bp + psdo, 0, bp[pgo + PP_OFF_NBR_ADD_PARTS] * 2);\n\n\tDEBC_printk(STp, \"psd_cnt %d, max.parts %d, nbr_parts %d\\n\",\n\t\t    psd_cnt, bp[pgo + PP_OFF_MAX_ADD_PARTS],\n\t\t    bp[pgo + PP_OFF_NBR_ADD_PARTS]);\n\n\tif (size == 0) {\n\t\tbp[pgo + PP_OFF_NBR_ADD_PARTS] = 0;\n\t\tif (psd_cnt <= bp[pgo + PP_OFF_MAX_ADD_PARTS])\n\t\t    bp[pgo + MP_OFF_PAGE_LENGTH] = 6;\n\t\tDEBC_printk(STp, \"Formatting tape with one partition.\\n\");\n\t} else {\n\t\tbp[psdo] = (size >> 8) & 0xff;\n\t\tbp[psdo + 1] = size & 0xff;\n\t\tif (target_partition == 0)\n\t\t\tbp[psdo + 2] = bp[psdo + 3] = 0xff;\n\t\tbp[pgo + 3] = 1;\n\t\tif (bp[pgo + MP_OFF_PAGE_LENGTH] < 8)\n\t\t    bp[pgo + MP_OFF_PAGE_LENGTH] = 8;\n\t\tDEBC_printk(STp,\n\t\t\t    \"Formatting tape with two partitions (%i = %d MB).\\n\",\n\t\t\t    target_partition, units > 0 ? size * 1000 : size);\n\t}\n\tbp[pgo + PP_OFF_PART_UNITS] = 0;\n\tbp[pgo + PP_OFF_RESERVED] = 0;\n\tif (size != 1 || units != 0) {\n\t\tbp[pgo + PP_OFF_FLAGS] = PP_BIT_IDP | psum |\n\t\t\t(bp[pgo + PP_OFF_FLAGS] & 0x07);\n\t\tbp[pgo + PP_OFF_PART_UNITS] = units;\n\t} else\n\t\tbp[pgo + PP_OFF_FLAGS] = PP_BIT_FDP |\n\t\t\t(bp[pgo + PP_OFF_FLAGS] & 0x1f);\n\tbp[pgo + MP_OFF_PAGE_LENGTH] = 6 + psd_cnt * 2;\n\n\tresult = write_mode_page(STp, PART_PAGE, 1);\n\n\tif (!result && needs_format)\n\t\tresult = format_medium(STp, 1);\n\n\tif (result) {\n\t\tst_printk(KERN_INFO, STp, \"Partitioning of tape failed.\\n\");\n\t\tresult = (-EIO);\n\t}\n\nout:\n\treturn result;\n}\n\f\n\n\n \nstatic long st_ioctl(struct file *file, unsigned int cmd_in, unsigned long arg)\n{\n\tvoid __user *p = (void __user *)arg;\n\tint i, cmd_nr, cmd_type, bt;\n\tint retval = 0;\n\tunsigned int blk;\n\tstruct scsi_tape *STp = file->private_data;\n\tstruct st_modedef *STm;\n\tstruct st_partstat *STps;\n\n\tif (mutex_lock_interruptible(&STp->lock))\n\t\treturn -ERESTARTSYS;\n\n\tDEB(\n\tif (debugging && !STp->in_use) {\n\t\tst_printk(ST_DEB_MSG, STp, \"Incorrect device.\\n\");\n\t\tretval = (-EIO);\n\t\tgoto out;\n\t} )  \n\n\tSTm = &(STp->modes[STp->current_mode]);\n\tSTps = &(STp->ps[STp->partition]);\n\n\t \n\tretval = scsi_ioctl_block_when_processing_errors(STp->device, cmd_in,\n\t\t\tfile->f_flags & O_NDELAY);\n\tif (retval)\n\t\tgoto out;\n\n\tcmd_type = _IOC_TYPE(cmd_in);\n\tcmd_nr = _IOC_NR(cmd_in);\n\n\tif (cmd_type == _IOC_TYPE(MTIOCTOP) && cmd_nr == _IOC_NR(MTIOCTOP)) {\n\t\tstruct mtop mtc;\n\n\t\tif (_IOC_SIZE(cmd_in) != sizeof(mtc)) {\n\t\t\tretval = (-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\n\t\ti = copy_from_user(&mtc, p, sizeof(struct mtop));\n\t\tif (i) {\n\t\t\tretval = (-EFAULT);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (mtc.mt_op == MTSETDRVBUFFER && !capable(CAP_SYS_ADMIN)) {\n\t\t\tst_printk(KERN_WARNING, STp,\n\t\t\t\t  \"MTSETDRVBUFFER only allowed for root.\\n\");\n\t\t\tretval = (-EPERM);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!STm->defined &&\n\t\t    (mtc.mt_op != MTSETDRVBUFFER &&\n\t\t     (mtc.mt_count & MT_ST_OPTIONS) == 0)) {\n\t\t\tretval = (-ENXIO);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!STp->pos_unknown) {\n\n\t\t\tif (STps->eof == ST_FM_HIT) {\n\t\t\t\tif (mtc.mt_op == MTFSF || mtc.mt_op == MTFSFM ||\n                                    mtc.mt_op == MTEOM) {\n\t\t\t\t\tmtc.mt_count -= 1;\n\t\t\t\t\tif (STps->drv_file >= 0)\n\t\t\t\t\t\tSTps->drv_file += 1;\n\t\t\t\t} else if (mtc.mt_op == MTBSF || mtc.mt_op == MTBSFM) {\n\t\t\t\t\tmtc.mt_count += 1;\n\t\t\t\t\tif (STps->drv_file >= 0)\n\t\t\t\t\t\tSTps->drv_file += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (mtc.mt_op == MTSEEK) {\n\t\t\t\t \n\t\t\t\ti = !STp->can_partitions ||\n\t\t\t\t    (STp->new_partition != STp->partition);\n\t\t\t} else {\n\t\t\t\ti = mtc.mt_op == MTREW || mtc.mt_op == MTOFFL ||\n\t\t\t\t    mtc.mt_op == MTRETEN || mtc.mt_op == MTEOM ||\n\t\t\t\t    mtc.mt_op == MTLOCK || mtc.mt_op == MTLOAD ||\n\t\t\t\t    mtc.mt_op == MTFSF || mtc.mt_op == MTFSFM ||\n\t\t\t\t    mtc.mt_op == MTBSF || mtc.mt_op == MTBSFM ||\n\t\t\t\t    mtc.mt_op == MTCOMPRESSION;\n\t\t\t}\n\t\t\ti = flush_buffer(STp, i);\n\t\t\tif (i < 0) {\n\t\t\t\tretval = i;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (STps->rw == ST_WRITING &&\n\t\t\t    (mtc.mt_op == MTREW || mtc.mt_op == MTOFFL ||\n\t\t\t     mtc.mt_op == MTSEEK ||\n\t\t\t     mtc.mt_op == MTBSF || mtc.mt_op == MTBSFM)) {\n\t\t\t\ti = st_int_ioctl(STp, MTWEOF, 1);\n\t\t\t\tif (i < 0) {\n\t\t\t\t\tretval = i;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (mtc.mt_op == MTBSF || mtc.mt_op == MTBSFM)\n\t\t\t\t\tmtc.mt_count++;\n\t\t\t\tSTps->rw = ST_IDLE;\n\t\t\t     }\n\n\t\t} else {\n\t\t\t \n\t\t\tif (mtc.mt_op != MTREW &&\n\t\t\t    mtc.mt_op != MTOFFL &&\n\t\t\t    mtc.mt_op != MTRETEN &&\n\t\t\t    mtc.mt_op != MTERASE &&\n\t\t\t    mtc.mt_op != MTSEEK &&\n\t\t\t    mtc.mt_op != MTEOM) {\n\t\t\t\tretval = (-EIO);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\treset_state(STp);\n\t\t\t \n\t\t\tSTp->device->was_reset = 0;\n\t\t}\n\n\t\tif (mtc.mt_op != MTNOP && mtc.mt_op != MTSETBLK &&\n\t\t    mtc.mt_op != MTSETDENSITY && mtc.mt_op != MTWSM &&\n\t\t    mtc.mt_op != MTSETDRVBUFFER && mtc.mt_op != MTSETPART)\n\t\t\tSTps->rw = ST_IDLE;\t \n\n\t\tif (mtc.mt_op == MTOFFL && STp->door_locked != ST_UNLOCKED)\n\t\t\tdo_door_lock(STp, 0);\t \n\n\t\tif (mtc.mt_op == MTSETDRVBUFFER &&\n\t\t    (mtc.mt_count & MT_ST_OPTIONS) != 0) {\n\t\t\tretval = st_set_options(STp, mtc.mt_count);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (mtc.mt_op == MTSETPART) {\n\t\t\tif (!STp->can_partitions ||\n\t\t\t    mtc.mt_count < 0 || mtc.mt_count >= ST_NBR_PARTITIONS) {\n\t\t\t\tretval = (-EINVAL);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (mtc.mt_count >= STp->nbr_partitions &&\n\t\t\t    (STp->nbr_partitions = nbr_partitions(STp)) < 0) {\n\t\t\t\tretval = (-EIO);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (mtc.mt_count >= STp->nbr_partitions) {\n\t\t\t\tretval = (-EINVAL);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tSTp->new_partition = mtc.mt_count;\n\t\t\tretval = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (mtc.mt_op == MTMKPART) {\n\t\t\tif (!STp->can_partitions) {\n\t\t\t\tretval = (-EINVAL);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ti = do_load_unload(STp, file, 1);\n\t\t\tif (i < 0) {\n\t\t\t\tretval = i;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ti = partition_tape(STp, mtc.mt_count);\n\t\t\tif (i < 0) {\n\t\t\t\tretval = i;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfor (i = 0; i < ST_NBR_PARTITIONS; i++) {\n\t\t\t\tSTp->ps[i].rw = ST_IDLE;\n\t\t\t\tSTp->ps[i].at_sm = 0;\n\t\t\t\tSTp->ps[i].last_block_valid = 0;\n\t\t\t}\n\t\t\tSTp->partition = STp->new_partition = 0;\n\t\t\tSTp->nbr_partitions = mtc.mt_count != 0 ? 2 : 1;\n\t\t\tSTps->drv_block = STps->drv_file = 0;\n\t\t\tretval = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (mtc.mt_op == MTSEEK) {\n\t\t\ti = set_location(STp, mtc.mt_count, STp->new_partition, 0);\n\t\t\tif (!STp->can_partitions)\n\t\t\t\tSTp->ps[0].rw = ST_IDLE;\n\t\t\tretval = i;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (mtc.mt_op == MTUNLOAD || mtc.mt_op == MTOFFL) {\n\t\t\tretval = do_load_unload(STp, file, 0);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (mtc.mt_op == MTLOAD) {\n\t\t\tretval = do_load_unload(STp, file, max(1, mtc.mt_count));\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (mtc.mt_op == MTLOCK || mtc.mt_op == MTUNLOCK) {\n\t\t\tretval = do_door_lock(STp, (mtc.mt_op == MTLOCK));\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (STp->can_partitions && STp->ready == ST_READY &&\n\t\t    (i = switch_partition(STp)) < 0) {\n\t\t\tretval = i;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (mtc.mt_op == MTCOMPRESSION)\n\t\t\tretval = st_compression(STp, (mtc.mt_count & 1));\n\t\telse\n\t\t\tretval = st_int_ioctl(STp, mtc.mt_op, mtc.mt_count);\n\t\tgoto out;\n\t}\n\tif (!STm->defined) {\n\t\tretval = (-ENXIO);\n\t\tgoto out;\n\t}\n\n\tif ((i = flush_buffer(STp, 0)) < 0) {\n\t\tretval = i;\n\t\tgoto out;\n\t}\n\tif (STp->can_partitions &&\n\t    (i = switch_partition(STp)) < 0) {\n\t\tretval = i;\n\t\tgoto out;\n\t}\n\n\tif (cmd_type == _IOC_TYPE(MTIOCGET) && cmd_nr == _IOC_NR(MTIOCGET)) {\n\t\tstruct mtget mt_status;\n\n\t\tif (_IOC_SIZE(cmd_in) != sizeof(struct mtget)) {\n\t\t\t retval = (-EINVAL);\n\t\t\t goto out;\n\t\t}\n\n\t\tmt_status.mt_type = STp->tape_type;\n\t\tmt_status.mt_dsreg =\n\t\t    ((STp->block_size << MT_ST_BLKSIZE_SHIFT) & MT_ST_BLKSIZE_MASK) |\n\t\t    ((STp->density << MT_ST_DENSITY_SHIFT) & MT_ST_DENSITY_MASK);\n\t\tmt_status.mt_blkno = STps->drv_block;\n\t\tmt_status.mt_fileno = STps->drv_file;\n\t\tif (STp->block_size != 0) {\n\t\t\tif (STps->rw == ST_WRITING)\n\t\t\t\tmt_status.mt_blkno +=\n\t\t\t\t    (STp->buffer)->buffer_bytes / STp->block_size;\n\t\t\telse if (STps->rw == ST_READING)\n\t\t\t\tmt_status.mt_blkno -=\n                                        ((STp->buffer)->buffer_bytes +\n                                         STp->block_size - 1) / STp->block_size;\n\t\t}\n\n\t\tmt_status.mt_gstat = 0;\n\t\tif (STp->drv_write_prot)\n\t\t\tmt_status.mt_gstat |= GMT_WR_PROT(0xffffffff);\n\t\tif (mt_status.mt_blkno == 0) {\n\t\t\tif (mt_status.mt_fileno == 0)\n\t\t\t\tmt_status.mt_gstat |= GMT_BOT(0xffffffff);\n\t\t\telse\n\t\t\t\tmt_status.mt_gstat |= GMT_EOF(0xffffffff);\n\t\t}\n\t\tmt_status.mt_erreg = (STp->recover_reg << MT_ST_SOFTERR_SHIFT);\n\t\tmt_status.mt_resid = STp->partition;\n\t\tif (STps->eof == ST_EOM_OK || STps->eof == ST_EOM_ERROR)\n\t\t\tmt_status.mt_gstat |= GMT_EOT(0xffffffff);\n\t\telse if (STps->eof >= ST_EOM_OK)\n\t\t\tmt_status.mt_gstat |= GMT_EOD(0xffffffff);\n\t\tif (STp->density == 1)\n\t\t\tmt_status.mt_gstat |= GMT_D_800(0xffffffff);\n\t\telse if (STp->density == 2)\n\t\t\tmt_status.mt_gstat |= GMT_D_1600(0xffffffff);\n\t\telse if (STp->density == 3)\n\t\t\tmt_status.mt_gstat |= GMT_D_6250(0xffffffff);\n\t\tif (STp->ready == ST_READY)\n\t\t\tmt_status.mt_gstat |= GMT_ONLINE(0xffffffff);\n\t\tif (STp->ready == ST_NO_TAPE)\n\t\t\tmt_status.mt_gstat |= GMT_DR_OPEN(0xffffffff);\n\t\tif (STps->at_sm)\n\t\t\tmt_status.mt_gstat |= GMT_SM(0xffffffff);\n\t\tif (STm->do_async_writes ||\n                    (STm->do_buffer_writes && STp->block_size != 0) ||\n\t\t    STp->drv_buffer != 0)\n\t\t\tmt_status.mt_gstat |= GMT_IM_REP_EN(0xffffffff);\n\t\tif (STp->cleaning_req)\n\t\t\tmt_status.mt_gstat |= GMT_CLN(0xffffffff);\n\n\t\tretval = put_user_mtget(p, &mt_status);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\tSTp->recover_reg = 0;\t\t \n\t\tgoto out;\n\t}\t\t\t \n\tif (cmd_type == _IOC_TYPE(MTIOCPOS) && cmd_nr == _IOC_NR(MTIOCPOS)) {\n\t\tstruct mtpos mt_pos;\n\t\tif (_IOC_SIZE(cmd_in) != sizeof(struct mtpos)) {\n\t\t\t retval = (-EINVAL);\n\t\t\t goto out;\n\t\t}\n\t\tif ((i = get_location(STp, &blk, &bt, 0)) < 0) {\n\t\t\tretval = i;\n\t\t\tgoto out;\n\t\t}\n\t\tmt_pos.mt_blkno = blk;\n\t\tretval = put_user_mtpos(p, &mt_pos);\n\t\tgoto out;\n\t}\n\tmutex_unlock(&STp->lock);\n\n\tswitch (cmd_in) {\n\tcase SG_IO:\n\tcase SCSI_IOCTL_SEND_COMMAND:\n\tcase CDROM_SEND_PACKET:\n\t\tif (!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tretval = scsi_ioctl(STp->device, file->f_mode & FMODE_WRITE, cmd_in, p);\n\tif (!retval && cmd_in == SCSI_IOCTL_STOP_UNIT) {\n\t\t \n\t\tSTp->rew_at_close = 0;\n\t\tSTp->ready = ST_NO_TAPE;\n\t}\n\treturn retval;\n\n out:\n\tmutex_unlock(&STp->lock);\n\treturn retval;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long st_compat_ioctl(struct file *file, unsigned int cmd_in, unsigned long arg)\n{\n\t \n\tswitch (cmd_in) {\n\tcase MTIOCPOS32:\n\t\tcmd_in = MTIOCPOS;\n\t\tbreak;\n\tcase MTIOCGET32:\n\t\tcmd_in = MTIOCGET;\n\t\tbreak;\n\t}\n\n\treturn st_ioctl(file, cmd_in, arg);\n}\n#endif\n\n\f\n\n \nstatic struct st_buffer *new_tape_buffer(int max_sg)\n{\n\tstruct st_buffer *tb;\n\n\ttb = kzalloc(sizeof(struct st_buffer), GFP_KERNEL);\n\tif (!tb) {\n\t\tprintk(KERN_NOTICE \"st: Can't allocate new tape buffer.\\n\");\n\t\treturn NULL;\n\t}\n\ttb->frp_segs = 0;\n\ttb->use_sg = max_sg;\n\ttb->buffer_size = 0;\n\n\ttb->reserved_pages = kcalloc(max_sg, sizeof(struct page *),\n\t\t\t\t     GFP_KERNEL);\n\tif (!tb->reserved_pages) {\n\t\tkfree(tb);\n\t\treturn NULL;\n\t}\n\n\treturn tb;\n}\n\n\n \n#define ST_MAX_ORDER 6\n\nstatic int enlarge_buffer(struct st_buffer * STbuffer, int new_size)\n{\n\tint segs, max_segs, b_size, order, got;\n\tgfp_t priority;\n\n\tif (new_size <= STbuffer->buffer_size)\n\t\treturn 1;\n\n\tif (STbuffer->buffer_size <= PAGE_SIZE)\n\t\tnormalize_buffer(STbuffer);   \n\n\tmax_segs = STbuffer->use_sg;\n\n\tpriority = GFP_KERNEL | __GFP_NOWARN;\n\n\tif (STbuffer->cleared)\n\t\tpriority |= __GFP_ZERO;\n\n\tif (STbuffer->frp_segs) {\n\t\torder = STbuffer->reserved_page_order;\n\t\tb_size = PAGE_SIZE << order;\n\t} else {\n\t\tfor (b_size = PAGE_SIZE, order = 0;\n\t\t     order < ST_MAX_ORDER &&\n\t\t\t     max_segs * (PAGE_SIZE << order) < new_size;\n\t\t     order++, b_size *= 2)\n\t\t\t;   \n\t\tSTbuffer->reserved_page_order = order;\n\t}\n\tif (max_segs * (PAGE_SIZE << order) < new_size) {\n\t\tif (order == ST_MAX_ORDER)\n\t\t\treturn 0;\n\t\tnormalize_buffer(STbuffer);\n\t\treturn enlarge_buffer(STbuffer, new_size);\n\t}\n\n\tfor (segs = STbuffer->frp_segs, got = STbuffer->buffer_size;\n\t     segs < max_segs && got < new_size;) {\n\t\tstruct page *page;\n\n\t\tpage = alloc_pages(priority, order);\n\t\tif (!page) {\n\t\t\tDEB(STbuffer->buffer_size = got);\n\t\t\tnormalize_buffer(STbuffer);\n\t\t\treturn 0;\n\t\t}\n\n\t\tSTbuffer->frp_segs += 1;\n\t\tgot += b_size;\n\t\tSTbuffer->buffer_size = got;\n\t\tSTbuffer->reserved_pages[segs] = page;\n\t\tsegs++;\n\t}\n\tSTbuffer->b_data = page_address(STbuffer->reserved_pages[0]);\n\n\treturn 1;\n}\n\n\n \nstatic void clear_buffer(struct st_buffer * st_bp)\n{\n\tint i;\n\n\tfor (i=0; i < st_bp->frp_segs; i++)\n\t\tmemset(page_address(st_bp->reserved_pages[i]), 0,\n\t\t       PAGE_SIZE << st_bp->reserved_page_order);\n\tst_bp->cleared = 1;\n}\n\n\n \nstatic void normalize_buffer(struct st_buffer * STbuffer)\n{\n\tint i, order = STbuffer->reserved_page_order;\n\n\tfor (i = 0; i < STbuffer->frp_segs; i++) {\n\t\t__free_pages(STbuffer->reserved_pages[i], order);\n\t\tSTbuffer->buffer_size -= (PAGE_SIZE << order);\n\t}\n\tSTbuffer->frp_segs = 0;\n\tSTbuffer->sg_segs = 0;\n\tSTbuffer->reserved_page_order = 0;\n\tSTbuffer->map_data.offset = 0;\n}\n\n\n \nstatic int append_to_buffer(const char __user *ubp, struct st_buffer * st_bp, int do_count)\n{\n\tint i, cnt, res, offset;\n\tint length = PAGE_SIZE << st_bp->reserved_page_order;\n\n\tfor (i = 0, offset = st_bp->buffer_bytes;\n\t     i < st_bp->frp_segs && offset >= length; i++)\n\t\toffset -= length;\n\tif (i == st_bp->frp_segs) {\t \n\t\tprintk(KERN_WARNING \"st: append_to_buffer offset overflow.\\n\");\n\t\treturn (-EIO);\n\t}\n\tfor (; i < st_bp->frp_segs && do_count > 0; i++) {\n\t\tstruct page *page = st_bp->reserved_pages[i];\n\t\tcnt = length - offset < do_count ? length - offset : do_count;\n\t\tres = copy_from_user(page_address(page) + offset, ubp, cnt);\n\t\tif (res)\n\t\t\treturn (-EFAULT);\n\t\tdo_count -= cnt;\n\t\tst_bp->buffer_bytes += cnt;\n\t\tubp += cnt;\n\t\toffset = 0;\n\t}\n\tif (do_count)  \n\t\treturn (-EIO);\n\n\treturn 0;\n}\n\n\n \nstatic int from_buffer(struct st_buffer * st_bp, char __user *ubp, int do_count)\n{\n\tint i, cnt, res, offset;\n\tint length = PAGE_SIZE << st_bp->reserved_page_order;\n\n\tfor (i = 0, offset = st_bp->read_pointer;\n\t     i < st_bp->frp_segs && offset >= length; i++)\n\t\toffset -= length;\n\tif (i == st_bp->frp_segs) {\t \n\t\tprintk(KERN_WARNING \"st: from_buffer offset overflow.\\n\");\n\t\treturn (-EIO);\n\t}\n\tfor (; i < st_bp->frp_segs && do_count > 0; i++) {\n\t\tstruct page *page = st_bp->reserved_pages[i];\n\t\tcnt = length - offset < do_count ? length - offset : do_count;\n\t\tres = copy_to_user(ubp, page_address(page) + offset, cnt);\n\t\tif (res)\n\t\t\treturn (-EFAULT);\n\t\tdo_count -= cnt;\n\t\tst_bp->buffer_bytes -= cnt;\n\t\tst_bp->read_pointer += cnt;\n\t\tubp += cnt;\n\t\toffset = 0;\n\t}\n\tif (do_count)  \n\t\treturn (-EIO);\n\n\treturn 0;\n}\n\n\n \nstatic void move_buffer_data(struct st_buffer * st_bp, int offset)\n{\n\tint src_seg, dst_seg, src_offset = 0, dst_offset;\n\tint count, total;\n\tint length = PAGE_SIZE << st_bp->reserved_page_order;\n\n\tif (offset == 0)\n\t\treturn;\n\n\ttotal=st_bp->buffer_bytes - offset;\n\tfor (src_seg=0; src_seg < st_bp->frp_segs; src_seg++) {\n\t\tsrc_offset = offset;\n\t\tif (src_offset < length)\n\t\t\tbreak;\n\t\toffset -= length;\n\t}\n\n\tst_bp->buffer_bytes = st_bp->read_pointer = total;\n\tfor (dst_seg=dst_offset=0; total > 0; ) {\n\t\tstruct page *dpage = st_bp->reserved_pages[dst_seg];\n\t\tstruct page *spage = st_bp->reserved_pages[src_seg];\n\n\t\tcount = min(length - dst_offset, length - src_offset);\n\t\tmemmove(page_address(dpage) + dst_offset,\n\t\t\tpage_address(spage) + src_offset, count);\n\t\tsrc_offset += count;\n\t\tif (src_offset >= length) {\n\t\t\tsrc_seg++;\n\t\t\tsrc_offset = 0;\n\t\t}\n\t\tdst_offset += count;\n\t\tif (dst_offset >= length) {\n\t\t\tdst_seg++;\n\t\t\tdst_offset = 0;\n\t\t}\n\t\ttotal -= count;\n\t}\n}\n\n \nstatic void validate_options(void)\n{\n\tif (buffer_kbs > 0)\n\t\tst_fixed_buffer_size = buffer_kbs * ST_KILOBYTE;\n\tif (max_sg_segs >= ST_FIRST_SG)\n\t\tst_max_sg_segs = max_sg_segs;\n}\n\n#ifndef MODULE\n \nstatic int __init st_setup(char *str)\n{\n\tint i, len, ints[5];\n\tchar *stp;\n\n\tstp = get_options(str, ARRAY_SIZE(ints), ints);\n\n\tif (ints[0] > 0) {\n\t\tfor (i = 0; i < ints[0] && i < ARRAY_SIZE(parms); i++)\n\t\t\tif (parms[i].val)\n\t\t\t\t*parms[i].val = ints[i + 1];\n\t} else {\n\t\twhile (stp != NULL) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(parms); i++) {\n\t\t\t\tlen = strlen(parms[i].name);\n\t\t\t\tif (!strncmp(stp, parms[i].name, len) &&\n\t\t\t\t    (*(stp + len) == ':' || *(stp + len) == '=')) {\n\t\t\t\t\tif (parms[i].val)\n\t\t\t\t\t\t*parms[i].val =\n\t\t\t\t\t\t\tsimple_strtoul(stp + len + 1, NULL, 0);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintk(KERN_WARNING \"st: Obsolete parameter %s\\n\",\n\t\t\t\t\t\t       parms[i].name);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i >= ARRAY_SIZE(parms))\n\t\t\t\t printk(KERN_WARNING \"st: invalid parameter in '%s'\\n\",\n\t\t\t\t\tstp);\n\t\t\tstp = strchr(stp, ',');\n\t\t\tif (stp)\n\t\t\t\tstp++;\n\t\t}\n\t}\n\n\tvalidate_options();\n\n\treturn 1;\n}\n\n__setup(\"st=\", st_setup);\n\n#endif\n\nstatic const struct file_operations st_fops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tst_read,\n\t.write =\tst_write,\n\t.unlocked_ioctl = st_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = st_compat_ioctl,\n#endif\n\t.open =\t\tst_open,\n\t.flush =\tst_flush,\n\t.release =\tst_release,\n\t.llseek =\tnoop_llseek,\n};\n\nstatic int create_one_cdev(struct scsi_tape *tape, int mode, int rew)\n{\n\tint i, error;\n\tdev_t cdev_devno;\n\tstruct cdev *cdev;\n\tstruct device *dev;\n\tstruct st_modedef *STm = &(tape->modes[mode]);\n\tchar name[10];\n\tint dev_num = tape->index;\n\n\tcdev_devno = MKDEV(SCSI_TAPE_MAJOR, TAPE_MINOR(dev_num, mode, rew));\n\n\tcdev = cdev_alloc();\n\tif (!cdev) {\n\t\tpr_err(\"st%d: out of memory. Device not attached.\\n\", dev_num);\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tcdev->owner = THIS_MODULE;\n\tcdev->ops = &st_fops;\n\tSTm->cdevs[rew] = cdev;\n\n\terror = cdev_add(cdev, cdev_devno, 1);\n\tif (error) {\n\t\tpr_err(\"st%d: Can't add %s-rewind mode %d\\n\", dev_num,\n\t\t       rew ? \"non\" : \"auto\", mode);\n\t\tpr_err(\"st%d: Device not attached.\\n\", dev_num);\n\t\tgoto out_free;\n\t}\n\n\ti = mode << (4 - ST_NBR_MODE_BITS);\n\tsnprintf(name, 10, \"%s%s%s\", rew ? \"n\" : \"\",\n\t\t tape->name, st_formats[i]);\n\n\tdev = device_create(&st_sysfs_class, &tape->device->sdev_gendev,\n\t\t\t    cdev_devno, &tape->modes[mode], \"%s\", name);\n\tif (IS_ERR(dev)) {\n\t\tpr_err(\"st%d: device_create failed\\n\", dev_num);\n\t\terror = PTR_ERR(dev);\n\t\tgoto out_free;\n\t}\n\n\tSTm->devs[rew] = dev;\n\n\treturn 0;\nout_free:\n\tcdev_del(STm->cdevs[rew]);\nout:\n\tSTm->cdevs[rew] = NULL;\n\tSTm->devs[rew] = NULL;\n\treturn error;\n}\n\nstatic int create_cdevs(struct scsi_tape *tape)\n{\n\tint mode, error;\n\tfor (mode = 0; mode < ST_NBR_MODES; ++mode) {\n\t\terror = create_one_cdev(tape, mode, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = create_one_cdev(tape, mode, 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn sysfs_create_link(&tape->device->sdev_gendev.kobj,\n\t\t\t\t &tape->modes[0].devs[0]->kobj, \"tape\");\n}\n\nstatic void remove_cdevs(struct scsi_tape *tape)\n{\n\tint mode, rew;\n\tsysfs_remove_link(&tape->device->sdev_gendev.kobj, \"tape\");\n\tfor (mode = 0; mode < ST_NBR_MODES; mode++) {\n\t\tstruct st_modedef *STm = &(tape->modes[mode]);\n\t\tfor (rew = 0; rew < 2; rew++) {\n\t\t\tif (STm->cdevs[rew])\n\t\t\t\tcdev_del(STm->cdevs[rew]);\n\t\t\tif (STm->devs[rew])\n\t\t\t\tdevice_unregister(STm->devs[rew]);\n\t\t}\n\t}\n}\n\nstatic int st_probe(struct device *dev)\n{\n\tstruct scsi_device *SDp = to_scsi_device(dev);\n\tstruct scsi_tape *tpnt = NULL;\n\tstruct st_modedef *STm;\n\tstruct st_partstat *STps;\n\tstruct st_buffer *buffer;\n\tint i, error;\n\n\tif (SDp->type != TYPE_TAPE)\n\t\treturn -ENODEV;\n\tif (st_incompatible(SDp)) {\n\t\tsdev_printk(KERN_INFO, SDp,\n\t\t\t    \"OnStream tapes are no longer supported;\\n\");\n\t\tsdev_printk(KERN_INFO, SDp,\n\t\t\t    \"please mail to linux-scsi@vger.kernel.org.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tscsi_autopm_get_device(SDp);\n\ti = queue_max_segments(SDp->request_queue);\n\tif (st_max_sg_segs < i)\n\t\ti = st_max_sg_segs;\n\tbuffer = new_tape_buffer(i);\n\tif (buffer == NULL) {\n\t\tsdev_printk(KERN_ERR, SDp,\n\t\t\t    \"st: Can't allocate new tape buffer. \"\n\t\t\t    \"Device not attached.\\n\");\n\t\tgoto out;\n\t}\n\n\ttpnt = kzalloc(sizeof(struct scsi_tape), GFP_KERNEL);\n\tif (tpnt == NULL) {\n\t\tsdev_printk(KERN_ERR, SDp,\n\t\t\t    \"st: Can't allocate device descriptor.\\n\");\n\t\tgoto out_buffer_free;\n\t}\n\tkref_init(&tpnt->kref);\n\n\ttpnt->device = SDp;\n\tif (SDp->scsi_level <= 2)\n\t\ttpnt->tape_type = MT_ISSCSI1;\n\telse\n\t\ttpnt->tape_type = MT_ISSCSI2;\n\n\ttpnt->buffer = buffer;\n\ttpnt->buffer->last_SRpnt = NULL;\n\n\ttpnt->inited = 0;\n\ttpnt->dirty = 0;\n\ttpnt->in_use = 0;\n\ttpnt->drv_buffer = 1;\t \n\ttpnt->use_pf = (SDp->scsi_level >= SCSI_2);\n\ttpnt->density = 0;\n\ttpnt->do_auto_lock = ST_AUTO_LOCK;\n\ttpnt->can_bsr = (SDp->scsi_level > 2 ? 1 : ST_IN_FILE_POS);  \n\ttpnt->can_partitions = 0;\n\ttpnt->two_fm = ST_TWO_FM;\n\ttpnt->fast_mteom = ST_FAST_MTEOM;\n\ttpnt->scsi2_logical = ST_SCSI2LOGICAL;\n\ttpnt->sili = ST_SILI;\n\ttpnt->immediate = ST_NOWAIT;\n\ttpnt->immediate_filemark = 0;\n\ttpnt->default_drvbuffer = 0xff;\t\t \n\ttpnt->partition = 0;\n\ttpnt->new_partition = 0;\n\ttpnt->nbr_partitions = 0;\n\tblk_queue_rq_timeout(tpnt->device->request_queue, ST_TIMEOUT);\n\ttpnt->long_timeout = ST_LONG_TIMEOUT;\n\ttpnt->try_dio = try_direct_io;\n\n\tfor (i = 0; i < ST_NBR_MODES; i++) {\n\t\tSTm = &(tpnt->modes[i]);\n\t\tSTm->defined = 0;\n\t\tSTm->sysv = ST_SYSV;\n\t\tSTm->defaults_for_writes = 0;\n\t\tSTm->do_async_writes = ST_ASYNC_WRITES;\n\t\tSTm->do_buffer_writes = ST_BUFFER_WRITES;\n\t\tSTm->do_read_ahead = ST_READ_AHEAD;\n\t\tSTm->default_compression = ST_DONT_TOUCH;\n\t\tSTm->default_blksize = (-1);\t \n\t\tSTm->default_density = (-1);\t \n\t\tSTm->tape = tpnt;\n\t}\n\n\tfor (i = 0; i < ST_NBR_PARTITIONS; i++) {\n\t\tSTps = &(tpnt->ps[i]);\n\t\tSTps->rw = ST_IDLE;\n\t\tSTps->eof = ST_NOEOF;\n\t\tSTps->at_sm = 0;\n\t\tSTps->last_block_valid = 0;\n\t\tSTps->drv_block = (-1);\n\t\tSTps->drv_file = (-1);\n\t}\n\n\ttpnt->current_mode = 0;\n\ttpnt->modes[0].defined = 1;\n\n\ttpnt->density_changed = tpnt->compression_changed =\n\t    tpnt->blksize_changed = 0;\n\tmutex_init(&tpnt->lock);\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&st_index_lock);\n\terror = idr_alloc(&st_index_idr, tpnt, 0, ST_MAX_TAPES + 1, GFP_NOWAIT);\n\tspin_unlock(&st_index_lock);\n\tidr_preload_end();\n\tif (error < 0) {\n\t\tpr_warn(\"st: idr allocation failed: %d\\n\", error);\n\t\tgoto out_free_tape;\n\t}\n\ttpnt->index = error;\n\tsprintf(tpnt->name, \"st%d\", tpnt->index);\n\ttpnt->stats = kzalloc(sizeof(struct scsi_tape_stats), GFP_KERNEL);\n\tif (tpnt->stats == NULL) {\n\t\tsdev_printk(KERN_ERR, SDp,\n\t\t\t    \"st: Can't allocate statistics.\\n\");\n\t\tgoto out_idr_remove;\n\t}\n\n\tdev_set_drvdata(dev, tpnt);\n\n\n\terror = create_cdevs(tpnt);\n\tif (error)\n\t\tgoto out_remove_devs;\n\tscsi_autopm_put_device(SDp);\n\n\tsdev_printk(KERN_NOTICE, SDp,\n\t\t    \"Attached scsi tape %s\\n\", tpnt->name);\n\tsdev_printk(KERN_INFO, SDp, \"%s: try direct i/o: %s (alignment %d B)\\n\",\n\t\t    tpnt->name, tpnt->try_dio ? \"yes\" : \"no\",\n\t\t    queue_dma_alignment(SDp->request_queue) + 1);\n\n\treturn 0;\n\nout_remove_devs:\n\tremove_cdevs(tpnt);\n\tkfree(tpnt->stats);\nout_idr_remove:\n\tspin_lock(&st_index_lock);\n\tidr_remove(&st_index_idr, tpnt->index);\n\tspin_unlock(&st_index_lock);\nout_free_tape:\n\tkfree(tpnt);\nout_buffer_free:\n\tkfree(buffer);\nout:\n\tscsi_autopm_put_device(SDp);\n\treturn -ENODEV;\n};\n\n\nstatic int st_remove(struct device *dev)\n{\n\tstruct scsi_tape *tpnt = dev_get_drvdata(dev);\n\tint index = tpnt->index;\n\n\tscsi_autopm_get_device(to_scsi_device(dev));\n\tremove_cdevs(tpnt);\n\n\tmutex_lock(&st_ref_mutex);\n\tkref_put(&tpnt->kref, scsi_tape_release);\n\tmutex_unlock(&st_ref_mutex);\n\tspin_lock(&st_index_lock);\n\tidr_remove(&st_index_idr, index);\n\tspin_unlock(&st_index_lock);\n\treturn 0;\n}\n\n \nstatic void scsi_tape_release(struct kref *kref)\n{\n\tstruct scsi_tape *tpnt = to_scsi_tape(kref);\n\n\ttpnt->device = NULL;\n\n\tif (tpnt->buffer) {\n\t\tnormalize_buffer(tpnt->buffer);\n\t\tkfree(tpnt->buffer->reserved_pages);\n\t\tkfree(tpnt->buffer);\n\t}\n\n\tkfree(tpnt->stats);\n\tkfree(tpnt);\n\treturn;\n}\n\nstatic struct class st_sysfs_class = {\n\t.name = \"scsi_tape\",\n\t.dev_groups = st_dev_groups,\n};\n\nstatic int __init init_st(void)\n{\n\tint err;\n\n\tvalidate_options();\n\n\tprintk(KERN_INFO \"st: Version %s, fixed bufsize %d, s/g segs %d\\n\",\n\t\tverstr, st_fixed_buffer_size, st_max_sg_segs);\n\n\tdebugging = (debug_flag > 0) ? debug_flag : NO_DEBUG;\n\tif (debugging) {\n\t\tprintk(KERN_INFO \"st: Debugging enabled debug_flag = %d\\n\",\n\t\t\tdebugging);\n\t}\n\n\terr = class_register(&st_sysfs_class);\n\tif (err) {\n\t\tpr_err(\"Unable register sysfs class for SCSI tapes\\n\");\n\t\treturn err;\n\t}\n\n\terr = register_chrdev_region(MKDEV(SCSI_TAPE_MAJOR, 0),\n\t\t\t\t     ST_MAX_TAPE_ENTRIES, \"st\");\n\tif (err) {\n\t\tprintk(KERN_ERR \"Unable to get major %d for SCSI tapes\\n\",\n\t\t       SCSI_TAPE_MAJOR);\n\t\tgoto err_class;\n\t}\n\n\terr = scsi_register_driver(&st_template.gendrv);\n\tif (err)\n\t\tgoto err_chrdev;\n\n\treturn 0;\n\nerr_chrdev:\n\tunregister_chrdev_region(MKDEV(SCSI_TAPE_MAJOR, 0),\n\t\t\t\t ST_MAX_TAPE_ENTRIES);\nerr_class:\n\tclass_unregister(&st_sysfs_class);\n\treturn err;\n}\n\nstatic void __exit exit_st(void)\n{\n\tscsi_unregister_driver(&st_template.gendrv);\n\tunregister_chrdev_region(MKDEV(SCSI_TAPE_MAJOR, 0),\n\t\t\t\t ST_MAX_TAPE_ENTRIES);\n\tclass_unregister(&st_sysfs_class);\n\tidr_destroy(&st_index_idr);\n\tprintk(KERN_INFO \"st: Unloaded.\\n\");\n}\n\nmodule_init(init_st);\nmodule_exit(exit_st);\n\n\n \nstatic ssize_t try_direct_io_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", try_direct_io);\n}\nstatic DRIVER_ATTR_RO(try_direct_io);\n\nstatic ssize_t fixed_buffer_size_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", st_fixed_buffer_size);\n}\nstatic DRIVER_ATTR_RO(fixed_buffer_size);\n\nstatic ssize_t max_sg_segs_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", st_max_sg_segs);\n}\nstatic DRIVER_ATTR_RO(max_sg_segs);\n\nstatic ssize_t version_show(struct device_driver *ddd, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"[%s]\\n\", verstr);\n}\nstatic DRIVER_ATTR_RO(version);\n\n#if DEBUG\nstatic ssize_t debug_flag_store(struct device_driver *ddp,\n\tconst char *buf, size_t count)\n{\n \n\tif (count > 0) {\n\t\tif (buf[0] == '0') {\n\t\t\tdebugging = NO_DEBUG;\n\t\t\treturn count;\n\t\t} else if (buf[0] == '1') {\n\t\t\tdebugging = 1;\n\t\t\treturn count;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic ssize_t debug_flag_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", debugging);\n}\nstatic DRIVER_ATTR_RW(debug_flag);\n#endif\n\nstatic struct attribute *st_drv_attrs[] = {\n\t&driver_attr_try_direct_io.attr,\n\t&driver_attr_fixed_buffer_size.attr,\n\t&driver_attr_max_sg_segs.attr,\n\t&driver_attr_version.attr,\n#if DEBUG\n\t&driver_attr_debug_flag.attr,\n#endif\n\tNULL,\n};\nATTRIBUTE_GROUPS(st_drv);\n\n \nstatic ssize_t\ndefined_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct st_modedef *STm = dev_get_drvdata(dev);\n\tssize_t l = 0;\n\n\tl = snprintf(buf, PAGE_SIZE, \"%d\\n\", STm->defined);\n\treturn l;\n}\nstatic DEVICE_ATTR_RO(defined);\n\nstatic ssize_t\ndefault_blksize_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct st_modedef *STm = dev_get_drvdata(dev);\n\tssize_t l = 0;\n\n\tl = snprintf(buf, PAGE_SIZE, \"%d\\n\", STm->default_blksize);\n\treturn l;\n}\nstatic DEVICE_ATTR_RO(default_blksize);\n\nstatic ssize_t\ndefault_density_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct st_modedef *STm = dev_get_drvdata(dev);\n\tssize_t l = 0;\n\tchar *fmt;\n\n\tfmt = STm->default_density >= 0 ? \"0x%02x\\n\" : \"%d\\n\";\n\tl = snprintf(buf, PAGE_SIZE, fmt, STm->default_density);\n\treturn l;\n}\nstatic DEVICE_ATTR_RO(default_density);\n\nstatic ssize_t\ndefault_compression_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct st_modedef *STm = dev_get_drvdata(dev);\n\tssize_t l = 0;\n\n\tl = snprintf(buf, PAGE_SIZE, \"%d\\n\", STm->default_compression - 1);\n\treturn l;\n}\nstatic DEVICE_ATTR_RO(default_compression);\n\nstatic ssize_t\noptions_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct st_modedef *STm = dev_get_drvdata(dev);\n\tstruct scsi_tape *STp = STm->tape;\n\tint options;\n\tssize_t l = 0;\n\n\toptions = STm->do_buffer_writes ? MT_ST_BUFFER_WRITES : 0;\n\toptions |= STm->do_async_writes ? MT_ST_ASYNC_WRITES : 0;\n\toptions |= STm->do_read_ahead ? MT_ST_READ_AHEAD : 0;\n\tDEB( options |= debugging ? MT_ST_DEBUGGING : 0 );\n\toptions |= STp->two_fm ? MT_ST_TWO_FM : 0;\n\toptions |= STp->fast_mteom ? MT_ST_FAST_MTEOM : 0;\n\toptions |= STm->defaults_for_writes ? MT_ST_DEF_WRITES : 0;\n\toptions |= STp->can_bsr ? MT_ST_CAN_BSR : 0;\n\toptions |= STp->omit_blklims ? MT_ST_NO_BLKLIMS : 0;\n\toptions |= STp->can_partitions ? MT_ST_CAN_PARTITIONS : 0;\n\toptions |= STp->scsi2_logical ? MT_ST_SCSI2LOGICAL : 0;\n\toptions |= STm->sysv ? MT_ST_SYSV : 0;\n\toptions |= STp->immediate ? MT_ST_NOWAIT : 0;\n\toptions |= STp->immediate_filemark ? MT_ST_NOWAIT_EOF : 0;\n\toptions |= STp->sili ? MT_ST_SILI : 0;\n\n\tl = snprintf(buf, PAGE_SIZE, \"0x%08x\\n\", options);\n\treturn l;\n}\nstatic DEVICE_ATTR_RO(options);\n\n \n\n \nstatic ssize_t read_cnt_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct st_modedef *STm = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%lld\",\n\t\t       (long long)atomic64_read(&STm->tape->stats->read_cnt));\n}\nstatic DEVICE_ATTR_RO(read_cnt);\n\n \nstatic ssize_t read_byte_cnt_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct st_modedef *STm = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%lld\",\n\t\t       (long long)atomic64_read(&STm->tape->stats->read_byte_cnt));\n}\nstatic DEVICE_ATTR_RO(read_byte_cnt);\n\n \nstatic ssize_t read_ns_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct st_modedef *STm = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%lld\",\n\t\t       (long long)atomic64_read(&STm->tape->stats->tot_read_time));\n}\nstatic DEVICE_ATTR_RO(read_ns);\n\n \nstatic ssize_t write_cnt_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct st_modedef *STm = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%lld\",\n\t\t       (long long)atomic64_read(&STm->tape->stats->write_cnt));\n}\nstatic DEVICE_ATTR_RO(write_cnt);\n\n \nstatic ssize_t write_byte_cnt_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct st_modedef *STm = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%lld\",\n\t\t       (long long)atomic64_read(&STm->tape->stats->write_byte_cnt));\n}\nstatic DEVICE_ATTR_RO(write_byte_cnt);\n\n \nstatic ssize_t write_ns_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct st_modedef *STm = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%lld\",\n\t\t       (long long)atomic64_read(&STm->tape->stats->tot_write_time));\n}\nstatic DEVICE_ATTR_RO(write_ns);\n\n \nstatic ssize_t in_flight_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct st_modedef *STm = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%lld\",\n\t\t       (long long)atomic64_read(&STm->tape->stats->in_flight));\n}\nstatic DEVICE_ATTR_RO(in_flight);\n\n \nstatic ssize_t io_ns_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct st_modedef *STm = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%lld\",\n\t\t       (long long)atomic64_read(&STm->tape->stats->tot_io_time));\n}\nstatic DEVICE_ATTR_RO(io_ns);\n\n \nstatic ssize_t other_cnt_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct st_modedef *STm = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%lld\",\n\t\t       (long long)atomic64_read(&STm->tape->stats->other_cnt));\n}\nstatic DEVICE_ATTR_RO(other_cnt);\n\n \nstatic ssize_t resid_cnt_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct st_modedef *STm = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%lld\",\n\t\t       (long long)atomic64_read(&STm->tape->stats->resid_cnt));\n}\nstatic DEVICE_ATTR_RO(resid_cnt);\n\nstatic struct attribute *st_dev_attrs[] = {\n\t&dev_attr_defined.attr,\n\t&dev_attr_default_blksize.attr,\n\t&dev_attr_default_density.attr,\n\t&dev_attr_default_compression.attr,\n\t&dev_attr_options.attr,\n\tNULL,\n};\n\nstatic struct attribute *st_stats_attrs[] = {\n\t&dev_attr_read_cnt.attr,\n\t&dev_attr_read_byte_cnt.attr,\n\t&dev_attr_read_ns.attr,\n\t&dev_attr_write_cnt.attr,\n\t&dev_attr_write_byte_cnt.attr,\n\t&dev_attr_write_ns.attr,\n\t&dev_attr_in_flight.attr,\n\t&dev_attr_io_ns.attr,\n\t&dev_attr_other_cnt.attr,\n\t&dev_attr_resid_cnt.attr,\n\tNULL,\n};\n\nstatic struct attribute_group stats_group = {\n\t.name = \"stats\",\n\t.attrs = st_stats_attrs,\n};\n\nstatic struct attribute_group st_group = {\n\t.attrs = st_dev_attrs,\n};\n\nstatic const struct attribute_group *st_dev_groups[] = {\n\t&st_group,\n\t&stats_group,\n\tNULL,\n};\n\n \nstatic int sgl_map_user_pages(struct st_buffer *STbp,\n\t\t\t      const unsigned int max_pages, unsigned long uaddr,\n\t\t\t      size_t count, int rw)\n{\n\tunsigned long end = (uaddr + count + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tunsigned long start = uaddr >> PAGE_SHIFT;\n\tconst int nr_pages = end - start;\n\tint res, i;\n\tstruct page **pages;\n\tstruct rq_map_data *mdata = &STbp->map_data;\n\n\t \n\tif ((uaddr + count) < uaddr)\n\t\treturn -EINVAL;\n\n\t \n        if (nr_pages > max_pages)\n\t\treturn -ENOMEM;\n\n\t \n\tif (count == 0)\n\t\treturn 0;\n\n\tpages = kmalloc_array(max_pages, sizeof(*pages), GFP_KERNEL);\n\tif (pages == NULL)\n\t\treturn -ENOMEM;\n\n         \n         \n\tres = pin_user_pages_fast(uaddr, nr_pages, rw == READ ? FOLL_WRITE : 0,\n\t\t\t\t  pages);\n\n\t \n\tif (res < nr_pages)\n\t\tgoto out_unmap;\n\n        for (i=0; i < nr_pages; i++) {\n                 \n\t\tflush_dcache_page(pages[i]);\n        }\n\n\tmdata->offset = uaddr & ~PAGE_MASK;\n\tSTbp->mapped_pages = pages;\n\n\treturn nr_pages;\n out_unmap:\n\tif (res > 0) {\n\t\tunpin_user_pages(pages, res);\n\t\tres = 0;\n\t}\n\tkfree(pages);\n\treturn res;\n}\n\n\n \nstatic int sgl_unmap_user_pages(struct st_buffer *STbp,\n\t\t\t\tconst unsigned int nr_pages, int dirtied)\n{\n\t \n\tunpin_user_pages_dirty_lock(STbp->mapped_pages, nr_pages, dirtied);\n\n\tkfree(STbp->mapped_pages);\n\tSTbp->mapped_pages = NULL;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}