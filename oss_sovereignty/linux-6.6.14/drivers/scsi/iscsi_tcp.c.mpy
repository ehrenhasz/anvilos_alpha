{
  "module_name": "iscsi_tcp.c",
  "hash_id": "2b1d1910540b8b2b47a84a524f028502cda59dec2ed3dab309f5e91528569f8e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/iscsi_tcp.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include <linux/types.h>\n#include <linux/inet.h>\n#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/kfifo.h>\n#include <linux/scatterlist.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <net/tcp.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_transport_iscsi.h>\n#include <trace/events/iscsi.h>\n#include <trace/events/sock.h>\n\n#include \"iscsi_tcp.h\"\n\nMODULE_AUTHOR(\"Mike Christie <michaelc@cs.wisc.edu>, \"\n\t      \"Dmitry Yusupov <dmitry_yus@yahoo.com>, \"\n\t      \"Alex Aizman <itn780@yahoo.com>\");\nMODULE_DESCRIPTION(\"iSCSI/TCP data-path\");\nMODULE_LICENSE(\"GPL\");\n\nstatic struct scsi_transport_template *iscsi_sw_tcp_scsi_transport;\nstatic const struct scsi_host_template iscsi_sw_tcp_sht;\nstatic struct iscsi_transport iscsi_sw_tcp_transport;\n\nstatic unsigned int iscsi_max_lun = ~0;\nmodule_param_named(max_lun, iscsi_max_lun, uint, S_IRUGO);\n\nstatic bool iscsi_recv_from_iscsi_q;\nmodule_param_named(recv_from_iscsi_q, iscsi_recv_from_iscsi_q, bool, 0644);\nMODULE_PARM_DESC(recv_from_iscsi_q, \"Set to true to read iSCSI data/headers from the iscsi_q workqueue. The default is false which will perform reads from the network softirq context.\");\n\nstatic int iscsi_sw_tcp_dbg;\nmodule_param_named(debug_iscsi_tcp, iscsi_sw_tcp_dbg, int,\n\t\t   S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug_iscsi_tcp, \"Turn on debugging for iscsi_tcp module \"\n\t\t \"Set to 1 to turn on, and zero to turn off. Default is off.\");\n\n#define ISCSI_SW_TCP_DBG(_conn, dbg_fmt, arg...)\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (iscsi_sw_tcp_dbg)\t\t\t\t\\\n\t\t\tiscsi_conn_printk(KERN_INFO, _conn,\t\\\n\t\t\t\t\t     \"%s \" dbg_fmt,\t\\\n\t\t\t\t\t     __func__, ##arg);\t\\\n\t\tiscsi_dbg_trace(trace_iscsi_dbg_sw_tcp,\t\t\\\n\t\t\t\t&(_conn)->cls_conn->dev,\t\\\n\t\t\t\t\"%s \" dbg_fmt, __func__, ##arg);\\\n\t} while (0);\n\n\n \nstatic int iscsi_sw_tcp_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,\n\t\t\t     unsigned int offset, size_t len)\n{\n\tstruct iscsi_conn *conn = rd_desc->arg.data;\n\tunsigned int consumed, total_consumed = 0;\n\tint status;\n\n\tISCSI_SW_TCP_DBG(conn, \"in %d bytes\\n\", skb->len - offset);\n\n\tdo {\n\t\tstatus = 0;\n\t\tconsumed = iscsi_tcp_recv_skb(conn, skb, offset, 0, &status);\n\t\toffset += consumed;\n\t\ttotal_consumed += consumed;\n\t} while (consumed != 0 && status != ISCSI_TCP_SKB_DONE);\n\n\tISCSI_SW_TCP_DBG(conn, \"read %d bytes status %d\\n\",\n\t\t\t skb->len - offset, status);\n\treturn total_consumed;\n}\n\n \nstatic inline int iscsi_sw_sk_state_check(struct sock *sk)\n{\n\tstruct iscsi_conn *conn = sk->sk_user_data;\n\n\tif ((sk->sk_state == TCP_CLOSE_WAIT || sk->sk_state == TCP_CLOSE) &&\n\t    (conn->session->state != ISCSI_STATE_LOGGING_OUT) &&\n\t    !atomic_read(&sk->sk_rmem_alloc)) {\n\t\tISCSI_SW_TCP_DBG(conn, \"TCP_CLOSE|TCP_CLOSE_WAIT\\n\");\n\t\tiscsi_conn_failure(conn, ISCSI_ERR_TCP_CONN_CLOSE);\n\t\treturn -ECONNRESET;\n\t}\n\treturn 0;\n}\n\nstatic void iscsi_sw_tcp_recv_data(struct iscsi_conn *conn)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\tstruct sock *sk = tcp_sw_conn->sock->sk;\n\tread_descriptor_t rd_desc;\n\n\t \n\trd_desc.arg.data = conn;\n\trd_desc.count = 1;\n\n\ttcp_read_sock(sk, &rd_desc, iscsi_sw_tcp_recv);\n\n\t \n\tiscsi_tcp_segment_unmap(&tcp_conn->in.segment);\n\n\tiscsi_sw_sk_state_check(sk);\n}\n\nstatic void iscsi_sw_tcp_recv_data_work(struct work_struct *work)\n{\n\tstruct iscsi_conn *conn = container_of(work, struct iscsi_conn,\n\t\t\t\t\t       recvwork);\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\tstruct sock *sk = tcp_sw_conn->sock->sk;\n\n\tlock_sock(sk);\n\tiscsi_sw_tcp_recv_data(conn);\n\trelease_sock(sk);\n}\n\nstatic void iscsi_sw_tcp_data_ready(struct sock *sk)\n{\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn;\n\tstruct iscsi_tcp_conn *tcp_conn;\n\tstruct iscsi_conn *conn;\n\n\ttrace_sk_data_ready(sk);\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tconn = sk->sk_user_data;\n\tif (!conn) {\n\t\tread_unlock_bh(&sk->sk_callback_lock);\n\t\treturn;\n\t}\n\ttcp_conn = conn->dd_data;\n\ttcp_sw_conn = tcp_conn->dd_data;\n\n\tif (tcp_sw_conn->queue_recv)\n\t\tiscsi_conn_queue_recv(conn);\n\telse\n\t\tiscsi_sw_tcp_recv_data(conn);\n\tread_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic void iscsi_sw_tcp_state_change(struct sock *sk)\n{\n\tstruct iscsi_tcp_conn *tcp_conn;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn;\n\tstruct iscsi_conn *conn;\n\tvoid (*old_state_change)(struct sock *);\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tconn = sk->sk_user_data;\n\tif (!conn) {\n\t\tread_unlock_bh(&sk->sk_callback_lock);\n\t\treturn;\n\t}\n\n\tiscsi_sw_sk_state_check(sk);\n\n\ttcp_conn = conn->dd_data;\n\ttcp_sw_conn = tcp_conn->dd_data;\n\told_state_change = tcp_sw_conn->old_state_change;\n\n\tread_unlock_bh(&sk->sk_callback_lock);\n\n\told_state_change(sk);\n}\n\n \nstatic void iscsi_sw_tcp_write_space(struct sock *sk)\n{\n\tstruct iscsi_conn *conn;\n\tstruct iscsi_tcp_conn *tcp_conn;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn;\n\tvoid (*old_write_space)(struct sock *);\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tconn = sk->sk_user_data;\n\tif (!conn) {\n\t\tread_unlock_bh(&sk->sk_callback_lock);\n\t\treturn;\n\t}\n\n\ttcp_conn = conn->dd_data;\n\ttcp_sw_conn = tcp_conn->dd_data;\n\told_write_space = tcp_sw_conn->old_write_space;\n\tread_unlock_bh(&sk->sk_callback_lock);\n\n\told_write_space(sk);\n\n\tISCSI_SW_TCP_DBG(conn, \"iscsi_write_space\\n\");\n\tiscsi_conn_queue_xmit(conn);\n}\n\nstatic void iscsi_sw_tcp_conn_set_callbacks(struct iscsi_conn *conn)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\tstruct sock *sk = tcp_sw_conn->sock->sk;\n\n\t \n\twrite_lock_bh(&sk->sk_callback_lock);\n\tsk->sk_user_data = conn;\n\ttcp_sw_conn->old_data_ready = sk->sk_data_ready;\n\ttcp_sw_conn->old_state_change = sk->sk_state_change;\n\ttcp_sw_conn->old_write_space = sk->sk_write_space;\n\tsk->sk_data_ready = iscsi_sw_tcp_data_ready;\n\tsk->sk_state_change = iscsi_sw_tcp_state_change;\n\tsk->sk_write_space = iscsi_sw_tcp_write_space;\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic void\niscsi_sw_tcp_conn_restore_callbacks(struct iscsi_conn *conn)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\tstruct sock *sk = tcp_sw_conn->sock->sk;\n\n\t \n\twrite_lock_bh(&sk->sk_callback_lock);\n\tsk->sk_user_data    = NULL;\n\tsk->sk_data_ready   = tcp_sw_conn->old_data_ready;\n\tsk->sk_state_change = tcp_sw_conn->old_state_change;\n\tsk->sk_write_space  = tcp_sw_conn->old_write_space;\n\tsk->sk_no_check_tx = 0;\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}\n\n \nstatic int iscsi_sw_tcp_xmit_segment(struct iscsi_tcp_conn *tcp_conn,\n\t\t\t\t     struct iscsi_segment *segment)\n{\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\tstruct socket *sk = tcp_sw_conn->sock;\n\tunsigned int copied = 0;\n\tint r = 0;\n\n\twhile (!iscsi_tcp_segment_done(tcp_conn, segment, 0, r)) {\n\t\tstruct scatterlist *sg;\n\t\tstruct msghdr msg = {};\n\t\tstruct bio_vec bv;\n\t\tunsigned int offset, copy;\n\n\t\tr = 0;\n\t\toffset = segment->copied;\n\t\tcopy = segment->size - offset;\n\n\t\tif (segment->total_copied + segment->size < segment->total_size)\n\t\t\tmsg.msg_flags |= MSG_MORE;\n\n\t\tif (tcp_sw_conn->queue_recv)\n\t\t\tmsg.msg_flags |= MSG_DONTWAIT;\n\n\t\tif (!segment->data) {\n\t\t\tif (!tcp_conn->iscsi_conn->datadgst_en)\n\t\t\t\tmsg.msg_flags |= MSG_SPLICE_PAGES;\n\t\t\tsg = segment->sg;\n\t\t\toffset += segment->sg_offset + sg->offset;\n\t\t\tbvec_set_page(&bv, sg_page(sg), copy, offset);\n\t\t} else {\n\t\t\tbvec_set_virt(&bv, segment->data + offset, copy);\n\t\t}\n\t\tiov_iter_bvec(&msg.msg_iter, ITER_SOURCE, &bv, 1, copy);\n\n\t\tr = sock_sendmsg(sk, &msg);\n\t\tif (r < 0) {\n\t\t\tiscsi_tcp_segment_unmap(segment);\n\t\t\treturn r;\n\t\t}\n\t\tcopied += r;\n\t}\n\treturn copied;\n}\n\n \nstatic int iscsi_sw_tcp_xmit(struct iscsi_conn *conn)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\tstruct iscsi_segment *segment = &tcp_sw_conn->out.segment;\n\tunsigned int consumed = 0;\n\tint rc = 0;\n\n\twhile (1) {\n\t\trc = iscsi_sw_tcp_xmit_segment(tcp_conn, segment);\n\t\t \n\t\tif (rc == -EAGAIN)\n\t\t\treturn rc;\n\t\telse if (rc < 0) {\n\t\t\trc = ISCSI_ERR_XMIT_FAILED;\n\t\t\tgoto error;\n\t\t} else if (rc == 0)\n\t\t\tbreak;\n\n\t\tconsumed += rc;\n\n\t\tif (segment->total_copied >= segment->total_size) {\n\t\t\tif (segment->done != NULL) {\n\t\t\t\trc = segment->done(tcp_conn, segment);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tISCSI_SW_TCP_DBG(conn, \"xmit %d bytes\\n\", consumed);\n\n\tconn->txdata_octets += consumed;\n\treturn consumed;\n\nerror:\n\t \n\tISCSI_SW_TCP_DBG(conn, \"Error sending PDU, errno=%d\\n\", rc);\n\tiscsi_conn_failure(conn, rc);\n\treturn -EIO;\n}\n\n \nstatic inline int iscsi_sw_tcp_xmit_qlen(struct iscsi_conn *conn)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\tstruct iscsi_segment *segment = &tcp_sw_conn->out.segment;\n\n\treturn segment->total_copied - segment->total_size;\n}\n\nstatic int iscsi_sw_tcp_pdu_xmit(struct iscsi_task *task)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tunsigned int noreclaim_flag;\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\tint rc = 0;\n\n\tif (!tcp_sw_conn->sock) {\n\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t  \"Transport not bound to socket!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\twhile (iscsi_sw_tcp_xmit_qlen(conn)) {\n\t\trc = iscsi_sw_tcp_xmit(conn);\n\t\tif (rc == 0) {\n\t\t\trc = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\trc = 0;\n\t}\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\treturn rc;\n}\n\n \nstatic int iscsi_sw_tcp_send_hdr_done(struct iscsi_tcp_conn *tcp_conn,\n\t\t\t\t      struct iscsi_segment *segment)\n{\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\n\ttcp_sw_conn->out.segment = tcp_sw_conn->out.data_segment;\n\tISCSI_SW_TCP_DBG(tcp_conn->iscsi_conn,\n\t\t\t \"Header done. Next segment size %u total_size %u\\n\",\n\t\t\t tcp_sw_conn->out.segment.size,\n\t\t\t tcp_sw_conn->out.segment.total_size);\n\treturn 0;\n}\n\nstatic void iscsi_sw_tcp_send_hdr_prep(struct iscsi_conn *conn, void *hdr,\n\t\t\t\t       size_t hdrlen)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\n\tISCSI_SW_TCP_DBG(conn, \"%s\\n\", conn->hdrdgst_en ?\n\t\t\t \"digest enabled\" : \"digest disabled\");\n\n\t \n\tmemset(&tcp_sw_conn->out.data_segment, 0,\n\t       sizeof(struct iscsi_segment));\n\n\t \n\tif (conn->hdrdgst_en) {\n\t\tiscsi_tcp_dgst_header(tcp_sw_conn->tx_hash, hdr, hdrlen,\n\t\t\t\t      hdr + hdrlen);\n\t\thdrlen += ISCSI_DIGEST_SIZE;\n\t}\n\n\t \n\ttcp_sw_conn->out.hdr = hdr;\n\n\tiscsi_segment_init_linear(&tcp_sw_conn->out.segment, hdr, hdrlen,\n\t\t\t\t  iscsi_sw_tcp_send_hdr_done, NULL);\n}\n\n \nstatic int\niscsi_sw_tcp_send_data_prep(struct iscsi_conn *conn, struct scatterlist *sg,\n\t\t\t    unsigned int count, unsigned int offset,\n\t\t\t    unsigned int len)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\tstruct ahash_request *tx_hash = NULL;\n\tunsigned int hdr_spec_len;\n\n\tISCSI_SW_TCP_DBG(conn, \"offset=%d, datalen=%d %s\\n\", offset, len,\n\t\t\t conn->datadgst_en ?\n\t\t\t \"digest enabled\" : \"digest disabled\");\n\n\t \n\thdr_spec_len = ntoh24(tcp_sw_conn->out.hdr->dlength);\n\tWARN_ON(iscsi_padded(len) != iscsi_padded(hdr_spec_len));\n\n\tif (conn->datadgst_en)\n\t\ttx_hash = tcp_sw_conn->tx_hash;\n\n\treturn iscsi_segment_seek_sg(&tcp_sw_conn->out.data_segment,\n\t\t\t\t     sg, count, offset, len,\n\t\t\t\t     NULL, tx_hash);\n}\n\nstatic void\niscsi_sw_tcp_send_linear_data_prep(struct iscsi_conn *conn, void *data,\n\t\t\t\t   size_t len)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\tstruct ahash_request *tx_hash = NULL;\n\tunsigned int hdr_spec_len;\n\n\tISCSI_SW_TCP_DBG(conn, \"datalen=%zd %s\\n\", len, conn->datadgst_en ?\n\t\t\t \"digest enabled\" : \"digest disabled\");\n\n\t \n\thdr_spec_len = ntoh24(tcp_sw_conn->out.hdr->dlength);\n\tWARN_ON(iscsi_padded(len) != iscsi_padded(hdr_spec_len));\n\n\tif (conn->datadgst_en)\n\t\ttx_hash = tcp_sw_conn->tx_hash;\n\n\tiscsi_segment_init_linear(&tcp_sw_conn->out.data_segment,\n\t\t\t\tdata, len, NULL, tx_hash);\n}\n\nstatic int iscsi_sw_tcp_pdu_init(struct iscsi_task *task,\n\t\t\t\t unsigned int offset, unsigned int count)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tint err = 0;\n\n\tiscsi_sw_tcp_send_hdr_prep(conn, task->hdr, task->hdr_len);\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (!task->sc)\n\t\tiscsi_sw_tcp_send_linear_data_prep(conn, task->data, count);\n\telse {\n\t\tstruct scsi_data_buffer *sdb = &task->sc->sdb;\n\n\t\terr = iscsi_sw_tcp_send_data_prep(conn, sdb->table.sgl,\n\t\t\t\t\t\t  sdb->table.nents, offset,\n\t\t\t\t\t\t  count);\n\t}\n\n\tif (err) {\n\t\t \n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int iscsi_sw_tcp_pdu_alloc(struct iscsi_task *task, uint8_t opcode)\n{\n\tstruct iscsi_tcp_task *tcp_task = task->dd_data;\n\n\ttask->hdr = task->dd_data + sizeof(*tcp_task);\n\ttask->hdr_max = sizeof(struct iscsi_sw_tcp_hdrbuf) - ISCSI_DIGEST_SIZE;\n\treturn 0;\n}\n\nstatic struct iscsi_cls_conn *\niscsi_sw_tcp_conn_create(struct iscsi_cls_session *cls_session,\n\t\t\t uint32_t conn_idx)\n{\n\tstruct iscsi_conn *conn;\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct iscsi_tcp_conn *tcp_conn;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn;\n\tstruct crypto_ahash *tfm;\n\n\tcls_conn = iscsi_tcp_conn_setup(cls_session, sizeof(*tcp_sw_conn),\n\t\t\t\t\tconn_idx);\n\tif (!cls_conn)\n\t\treturn NULL;\n\tconn = cls_conn->dd_data;\n\ttcp_conn = conn->dd_data;\n\ttcp_sw_conn = tcp_conn->dd_data;\n\tINIT_WORK(&conn->recvwork, iscsi_sw_tcp_recv_data_work);\n\ttcp_sw_conn->queue_recv = iscsi_recv_from_iscsi_q;\n\n\tmutex_init(&tcp_sw_conn->sock_lock);\n\n\ttfm = crypto_alloc_ahash(\"crc32c\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm))\n\t\tgoto free_conn;\n\n\ttcp_sw_conn->tx_hash = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!tcp_sw_conn->tx_hash)\n\t\tgoto free_tfm;\n\tahash_request_set_callback(tcp_sw_conn->tx_hash, 0, NULL, NULL);\n\n\ttcp_sw_conn->rx_hash = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!tcp_sw_conn->rx_hash)\n\t\tgoto free_tx_hash;\n\tahash_request_set_callback(tcp_sw_conn->rx_hash, 0, NULL, NULL);\n\n\ttcp_conn->rx_hash = tcp_sw_conn->rx_hash;\n\n\treturn cls_conn;\n\nfree_tx_hash:\n\tahash_request_free(tcp_sw_conn->tx_hash);\nfree_tfm:\n\tcrypto_free_ahash(tfm);\nfree_conn:\n\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t  \"Could not create connection due to crc32c \"\n\t\t\t  \"loading error. Make sure the crc32c \"\n\t\t\t  \"module is built as a module or into the \"\n\t\t\t  \"kernel\\n\");\n\tiscsi_tcp_conn_teardown(cls_conn);\n\treturn NULL;\n}\n\nstatic void iscsi_sw_tcp_release_conn(struct iscsi_conn *conn)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\tstruct socket *sock = tcp_sw_conn->sock;\n\n\t \n\tif (!sock)\n\t\treturn;\n\n\t \n\tkernel_sock_shutdown(sock, SHUT_RDWR);\n\n\tsock_hold(sock->sk);\n\tiscsi_sw_tcp_conn_restore_callbacks(conn);\n\tsock_put(sock->sk);\n\n\tiscsi_suspend_rx(conn);\n\n\tmutex_lock(&tcp_sw_conn->sock_lock);\n\ttcp_sw_conn->sock = NULL;\n\tmutex_unlock(&tcp_sw_conn->sock_lock);\n\tsockfd_put(sock);\n}\n\nstatic void iscsi_sw_tcp_conn_destroy(struct iscsi_cls_conn *cls_conn)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\n\tiscsi_sw_tcp_release_conn(conn);\n\n\tahash_request_free(tcp_sw_conn->rx_hash);\n\tif (tcp_sw_conn->tx_hash) {\n\t\tstruct crypto_ahash *tfm;\n\n\t\ttfm = crypto_ahash_reqtfm(tcp_sw_conn->tx_hash);\n\t\tahash_request_free(tcp_sw_conn->tx_hash);\n\t\tcrypto_free_ahash(tfm);\n\t}\n\n\tiscsi_tcp_conn_teardown(cls_conn);\n}\n\nstatic void iscsi_sw_tcp_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\tstruct socket *sock = tcp_sw_conn->sock;\n\n\t \n\tif (!sock)\n\t\treturn;\n\n\tsock->sk->sk_err = EIO;\n\twake_up_interruptible(sk_sleep(sock->sk));\n\n\t \n\tiscsi_suspend_tx(conn);\n\n\t \n\tiscsi_sw_tcp_release_conn(conn);\n\n\tiscsi_conn_stop(cls_conn, flag);\n}\n\nstatic int\niscsi_sw_tcp_conn_bind(struct iscsi_cls_session *cls_session,\n\t\t       struct iscsi_cls_conn *cls_conn, uint64_t transport_eph,\n\t\t       int is_leading)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\tstruct sock *sk;\n\tstruct socket *sock;\n\tint err;\n\n\t \n\tsock = sockfd_lookup((int)transport_eph, &err);\n\tif (!sock) {\n\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t  \"sockfd_lookup failed %d\\n\", err);\n\t\treturn -EEXIST;\n\t}\n\n\terr = -EINVAL;\n\tif (!sk_is_tcp(sock->sk))\n\t\tgoto free_socket;\n\n\terr = iscsi_conn_bind(cls_session, cls_conn, is_leading);\n\tif (err)\n\t\tgoto free_socket;\n\n\tmutex_lock(&tcp_sw_conn->sock_lock);\n\t \n\ttcp_sw_conn->sock = sock;\n\tmutex_unlock(&tcp_sw_conn->sock_lock);\n\n\t \n\tsk = sock->sk;\n\tsk->sk_reuse = SK_CAN_REUSE;\n\tsk->sk_sndtimeo = 15 * HZ;  \n\tsk->sk_allocation = GFP_ATOMIC;\n\tsk->sk_use_task_frag = false;\n\tsk_set_memalloc(sk);\n\tsock_no_linger(sk);\n\n\tiscsi_sw_tcp_conn_set_callbacks(conn);\n\t \n\tiscsi_tcp_hdr_recv_prep(tcp_conn);\n\treturn 0;\n\nfree_socket:\n\tsockfd_put(sock);\n\treturn err;\n}\n\nstatic int iscsi_sw_tcp_conn_set_param(struct iscsi_cls_conn *cls_conn,\n\t\t\t\t       enum iscsi_param param, char *buf,\n\t\t\t\t       int buflen)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\n\tswitch(param) {\n\tcase ISCSI_PARAM_HDRDGST_EN:\n\t\tiscsi_set_param(cls_conn, param, buf, buflen);\n\t\tbreak;\n\tcase ISCSI_PARAM_DATADGST_EN:\n\t\tmutex_lock(&tcp_sw_conn->sock_lock);\n\t\tif (!tcp_sw_conn->sock) {\n\t\t\tmutex_unlock(&tcp_sw_conn->sock_lock);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tiscsi_set_param(cls_conn, param, buf, buflen);\n\t\tmutex_unlock(&tcp_sw_conn->sock_lock);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_R2T:\n\t\treturn iscsi_tcp_set_max_r2t(conn, buf);\n\tdefault:\n\t\treturn iscsi_set_param(cls_conn, param, buf, buflen);\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_sw_tcp_conn_get_param(struct iscsi_cls_conn *cls_conn,\n\t\t\t\t       enum iscsi_param param, char *buf)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn;\n\tstruct iscsi_tcp_conn *tcp_conn;\n\tstruct sockaddr_in6 addr;\n\tstruct socket *sock;\n\tint rc;\n\n\tswitch(param) {\n\tcase ISCSI_PARAM_CONN_PORT:\n\tcase ISCSI_PARAM_CONN_ADDRESS:\n\tcase ISCSI_PARAM_LOCAL_PORT:\n\t\tspin_lock_bh(&conn->session->frwd_lock);\n\t\tif (!conn->session->leadconn) {\n\t\t\tspin_unlock_bh(&conn->session->frwd_lock);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\t \n\t\tiscsi_get_conn(conn->cls_conn);\n\t\tspin_unlock_bh(&conn->session->frwd_lock);\n\n\t\ttcp_conn = conn->dd_data;\n\t\ttcp_sw_conn = tcp_conn->dd_data;\n\n\t\tmutex_lock(&tcp_sw_conn->sock_lock);\n\t\tsock = tcp_sw_conn->sock;\n\t\tif (!sock) {\n\t\t\trc = -ENOTCONN;\n\t\t\tgoto sock_unlock;\n\t\t}\n\n\t\tif (param == ISCSI_PARAM_LOCAL_PORT)\n\t\t\trc = kernel_getsockname(sock,\n\t\t\t\t\t\t(struct sockaddr *)&addr);\n\t\telse\n\t\t\trc = kernel_getpeername(sock,\n\t\t\t\t\t\t(struct sockaddr *)&addr);\nsock_unlock:\n\t\tmutex_unlock(&tcp_sw_conn->sock_lock);\n\t\tiscsi_put_conn(conn->cls_conn);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\treturn iscsi_conn_get_addr_param((struct sockaddr_storage *)\n\t\t\t\t\t\t &addr, param, buf);\n\tdefault:\n\t\treturn iscsi_conn_get_param(cls_conn, param, buf);\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_sw_tcp_host_get_param(struct Scsi_Host *shost,\n\t\t\t\t       enum iscsi_host_param param, char *buf)\n{\n\tstruct iscsi_sw_tcp_host *tcp_sw_host = iscsi_host_priv(shost);\n\tstruct iscsi_session *session;\n\tstruct iscsi_conn *conn;\n\tstruct iscsi_tcp_conn *tcp_conn;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn;\n\tstruct sockaddr_in6 addr;\n\tstruct socket *sock;\n\tint rc;\n\n\tswitch (param) {\n\tcase ISCSI_HOST_PARAM_IPADDRESS:\n\t\tsession = tcp_sw_host->session;\n\t\tif (!session)\n\t\t\treturn -ENOTCONN;\n\n\t\tspin_lock_bh(&session->frwd_lock);\n\t\tconn = session->leadconn;\n\t\tif (!conn) {\n\t\t\tspin_unlock_bh(&session->frwd_lock);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\ttcp_conn = conn->dd_data;\n\t\ttcp_sw_conn = tcp_conn->dd_data;\n\t\t \n\t\tiscsi_get_conn(conn->cls_conn);\n\t\tspin_unlock_bh(&session->frwd_lock);\n\n\t\tmutex_lock(&tcp_sw_conn->sock_lock);\n\t\tsock = tcp_sw_conn->sock;\n\t\tif (!sock)\n\t\t\trc = -ENOTCONN;\n\t\telse\n\t\t\trc = kernel_getsockname(sock, (struct sockaddr *)&addr);\n\t\tmutex_unlock(&tcp_sw_conn->sock_lock);\n\t\tiscsi_put_conn(conn->cls_conn);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\treturn iscsi_conn_get_addr_param((struct sockaddr_storage *)\n\t\t\t\t\t\t &addr,\n\t\t\t\t\t\t (enum iscsi_param)param, buf);\n\tdefault:\n\t\treturn iscsi_host_get_param(shost, param, buf);\n\t}\n\n\treturn 0;\n}\n\nstatic void\niscsi_sw_tcp_conn_get_stats(struct iscsi_cls_conn *cls_conn,\n\t\t\t    struct iscsi_stats *stats)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\n\n\tstats->custom_length = 3;\n\tstrcpy(stats->custom[0].desc, \"tx_sendpage_failures\");\n\tstats->custom[0].value = tcp_sw_conn->sendpage_failures_cnt;\n\tstrcpy(stats->custom[1].desc, \"rx_discontiguous_hdr\");\n\tstats->custom[1].value = tcp_sw_conn->discontiguous_hdr_cnt;\n\tstrcpy(stats->custom[2].desc, \"eh_abort_cnt\");\n\tstats->custom[2].value = conn->eh_abort_cnt;\n\n\tiscsi_tcp_conn_get_stats(cls_conn, stats);\n}\n\nstatic struct iscsi_cls_session *\niscsi_sw_tcp_session_create(struct iscsi_endpoint *ep, uint16_t cmds_max,\n\t\t\t    uint16_t qdepth, uint32_t initial_cmdsn)\n{\n\tstruct iscsi_cls_session *cls_session;\n\tstruct iscsi_session *session;\n\tstruct iscsi_sw_tcp_host *tcp_sw_host;\n\tstruct Scsi_Host *shost;\n\tint rc;\n\n\tif (ep) {\n\t\tprintk(KERN_ERR \"iscsi_tcp: invalid ep %p.\\n\", ep);\n\t\treturn NULL;\n\t}\n\n\tshost = iscsi_host_alloc(&iscsi_sw_tcp_sht,\n\t\t\t\t sizeof(struct iscsi_sw_tcp_host), 1);\n\tif (!shost)\n\t\treturn NULL;\n\tshost->transportt = iscsi_sw_tcp_scsi_transport;\n\tshost->cmd_per_lun = qdepth;\n\tshost->max_lun = iscsi_max_lun;\n\tshost->max_id = 0;\n\tshost->max_channel = 0;\n\tshost->max_cmd_len = SCSI_MAX_VARLEN_CDB_SIZE;\n\n\trc = iscsi_host_get_max_scsi_cmds(shost, cmds_max);\n\tif (rc < 0)\n\t\tgoto free_host;\n\tshost->can_queue = rc;\n\n\tif (iscsi_host_add(shost, NULL))\n\t\tgoto free_host;\n\n\tcls_session = iscsi_session_setup(&iscsi_sw_tcp_transport, shost,\n\t\t\t\t\t  cmds_max, 0,\n\t\t\t\t\t  sizeof(struct iscsi_tcp_task) +\n\t\t\t\t\t  sizeof(struct iscsi_sw_tcp_hdrbuf),\n\t\t\t\t\t  initial_cmdsn, 0);\n\tif (!cls_session)\n\t\tgoto remove_host;\n\tsession = cls_session->dd_data;\n\n\tif (iscsi_tcp_r2tpool_alloc(session))\n\t\tgoto remove_session;\n\n\t \n\ttcp_sw_host = iscsi_host_priv(shost);\n\ttcp_sw_host->session = session;\n\treturn cls_session;\n\nremove_session:\n\tiscsi_session_teardown(cls_session);\nremove_host:\n\tiscsi_host_remove(shost, false);\nfree_host:\n\tiscsi_host_free(shost);\n\treturn NULL;\n}\n\nstatic void iscsi_sw_tcp_session_destroy(struct iscsi_cls_session *cls_session)\n{\n\tstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\n\tstruct iscsi_session *session = cls_session->dd_data;\n\n\tif (WARN_ON_ONCE(session->leadconn))\n\t\treturn;\n\n\tiscsi_session_remove(cls_session);\n\t \n\tiscsi_host_remove(shost, false);\n\n\tiscsi_tcp_r2tpool_free(cls_session->dd_data);\n\n\tiscsi_session_free(cls_session);\n\tiscsi_host_free(shost);\n}\n\nstatic umode_t iscsi_sw_tcp_attr_is_visible(int param_type, int param)\n{\n\tswitch (param_type) {\n\tcase ISCSI_HOST_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_HOST_PARAM_NETDEV_NAME:\n\t\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tcase ISCSI_HOST_PARAM_IPADDRESS:\n\t\tcase ISCSI_HOST_PARAM_INITIATOR_NAME:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase ISCSI_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_PARAM_MAX_RECV_DLENGTH:\n\t\tcase ISCSI_PARAM_MAX_XMIT_DLENGTH:\n\t\tcase ISCSI_PARAM_HDRDGST_EN:\n\t\tcase ISCSI_PARAM_DATADGST_EN:\n\t\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\tcase ISCSI_PARAM_CONN_PORT:\n\t\tcase ISCSI_PARAM_LOCAL_PORT:\n\t\tcase ISCSI_PARAM_EXP_STATSN:\n\t\tcase ISCSI_PARAM_PERSISTENT_ADDRESS:\n\t\tcase ISCSI_PARAM_PERSISTENT_PORT:\n\t\tcase ISCSI_PARAM_PING_TMO:\n\t\tcase ISCSI_PARAM_RECV_TMO:\n\t\tcase ISCSI_PARAM_INITIAL_R2T_EN:\n\t\tcase ISCSI_PARAM_MAX_R2T:\n\t\tcase ISCSI_PARAM_IMM_DATA_EN:\n\t\tcase ISCSI_PARAM_FIRST_BURST:\n\t\tcase ISCSI_PARAM_MAX_BURST:\n\t\tcase ISCSI_PARAM_PDU_INORDER_EN:\n\t\tcase ISCSI_PARAM_DATASEQ_INORDER_EN:\n\t\tcase ISCSI_PARAM_ERL:\n\t\tcase ISCSI_PARAM_TARGET_NAME:\n\t\tcase ISCSI_PARAM_TPGT:\n\t\tcase ISCSI_PARAM_USERNAME:\n\t\tcase ISCSI_PARAM_PASSWORD:\n\t\tcase ISCSI_PARAM_USERNAME_IN:\n\t\tcase ISCSI_PARAM_PASSWORD_IN:\n\t\tcase ISCSI_PARAM_FAST_ABORT:\n\t\tcase ISCSI_PARAM_ABORT_TMO:\n\t\tcase ISCSI_PARAM_LU_RESET_TMO:\n\t\tcase ISCSI_PARAM_TGT_RESET_TMO:\n\t\tcase ISCSI_PARAM_IFACE_NAME:\n\t\tcase ISCSI_PARAM_INITIATOR_NAME:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_sw_tcp_slave_configure(struct scsi_device *sdev)\n{\n\tstruct iscsi_sw_tcp_host *tcp_sw_host = iscsi_host_priv(sdev->host);\n\tstruct iscsi_session *session = tcp_sw_host->session;\n\tstruct iscsi_conn *conn = session->leadconn;\n\n\tif (conn->datadgst_en)\n\t\tblk_queue_flag_set(QUEUE_FLAG_STABLE_WRITES,\n\t\t\t\t   sdev->request_queue);\n\tblk_queue_dma_alignment(sdev->request_queue, 0);\n\treturn 0;\n}\n\nstatic const struct scsi_host_template iscsi_sw_tcp_sht = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"iSCSI Initiator over TCP/IP\",\n\t.queuecommand           = iscsi_queuecommand,\n\t.change_queue_depth\t= scsi_change_queue_depth,\n\t.can_queue\t\t= ISCSI_TOTAL_CMDS_MAX,\n\t.sg_tablesize\t\t= 4096,\n\t.max_sectors\t\t= 0xFFFF,\n\t.cmd_per_lun\t\t= ISCSI_DEF_CMD_PER_LUN,\n\t.eh_timed_out\t\t= iscsi_eh_cmd_timed_out,\n\t.eh_abort_handler       = iscsi_eh_abort,\n\t.eh_device_reset_handler= iscsi_eh_device_reset,\n\t.eh_target_reset_handler = iscsi_eh_recover_target,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n\t.slave_configure        = iscsi_sw_tcp_slave_configure,\n\t.proc_name\t\t= \"iscsi_tcp\",\n\t.this_id\t\t= -1,\n\t.track_queue_depth\t= 1,\n\t.cmd_size\t\t= sizeof(struct iscsi_cmd),\n};\n\nstatic struct iscsi_transport iscsi_sw_tcp_transport = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"tcp\",\n\t.caps\t\t\t= CAP_RECOVERY_L0 | CAP_MULTI_R2T | CAP_HDRDGST\n\t\t\t\t  | CAP_DATADGST,\n\t \n\t.create_session\t\t= iscsi_sw_tcp_session_create,\n\t.destroy_session\t= iscsi_sw_tcp_session_destroy,\n\t \n\t.create_conn\t\t= iscsi_sw_tcp_conn_create,\n\t.bind_conn\t\t= iscsi_sw_tcp_conn_bind,\n\t.destroy_conn\t\t= iscsi_sw_tcp_conn_destroy,\n\t.attr_is_visible\t= iscsi_sw_tcp_attr_is_visible,\n\t.set_param\t\t= iscsi_sw_tcp_conn_set_param,\n\t.get_conn_param\t\t= iscsi_sw_tcp_conn_get_param,\n\t.get_session_param\t= iscsi_session_get_param,\n\t.start_conn\t\t= iscsi_conn_start,\n\t.stop_conn\t\t= iscsi_sw_tcp_conn_stop,\n\t \n\t.get_host_param\t\t= iscsi_sw_tcp_host_get_param,\n\t.set_host_param\t\t= iscsi_host_set_param,\n\t \n\t.send_pdu\t\t= iscsi_conn_send_pdu,\n\t.get_stats\t\t= iscsi_sw_tcp_conn_get_stats,\n\t \n\t.init_task\t\t= iscsi_tcp_task_init,\n\t.xmit_task\t\t= iscsi_tcp_task_xmit,\n\t.cleanup_task\t\t= iscsi_tcp_cleanup_task,\n\t \n\t.xmit_pdu\t\t= iscsi_sw_tcp_pdu_xmit,\n\t.init_pdu\t\t= iscsi_sw_tcp_pdu_init,\n\t.alloc_pdu\t\t= iscsi_sw_tcp_pdu_alloc,\n\t \n\t.session_recovery_timedout = iscsi_session_recovery_timedout,\n};\n\nstatic int __init iscsi_sw_tcp_init(void)\n{\n\tif (iscsi_max_lun < 1) {\n\t\tprintk(KERN_ERR \"iscsi_tcp: Invalid max_lun value of %u\\n\",\n\t\t       iscsi_max_lun);\n\t\treturn -EINVAL;\n\t}\n\n\tiscsi_sw_tcp_scsi_transport = iscsi_register_transport(\n\t\t\t\t\t\t&iscsi_sw_tcp_transport);\n\tif (!iscsi_sw_tcp_scsi_transport)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void __exit iscsi_sw_tcp_exit(void)\n{\n\tiscsi_unregister_transport(&iscsi_sw_tcp_transport);\n}\n\nmodule_init(iscsi_sw_tcp_init);\nmodule_exit(iscsi_sw_tcp_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}