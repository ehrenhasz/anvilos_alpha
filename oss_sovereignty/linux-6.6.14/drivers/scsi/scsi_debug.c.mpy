{
  "module_name": "scsi_debug.c",
  "hash_id": "f14d5c2fe884a4e8d9ad390e6ae46afc7ed5577fa00b92934655dba9c649b534",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_debug.c",
  "human_readable_source": "\n \n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/module.h>\n#include <linux/align.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/vmalloc.h>\n#include <linux/moduleparam.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/crc-t10dif.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/atomic.h>\n#include <linux/hrtimer.h>\n#include <linux/uuid.h>\n#include <linux/t10-pi.h>\n#include <linux/msdos_partition.h>\n#include <linux/random.h>\n#include <linux/xarray.h>\n#include <linux/prefetch.h>\n\n#include <net/checksum.h>\n\n#include <asm/unaligned.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsicam.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_dbg.h>\n\n#include \"sd.h\"\n#include \"scsi_logging.h\"\n\n \n#define SDEBUG_VERSION \"0191\"\t \nstatic const char *sdebug_version_date = \"20210520\";\n\n#define MY_NAME \"scsi_debug\"\n\n \n#define NO_ADDITIONAL_SENSE 0x0\n#define LOGICAL_UNIT_NOT_READY 0x4\n#define LOGICAL_UNIT_COMMUNICATION_FAILURE 0x8\n#define UNRECOVERED_READ_ERR 0x11\n#define PARAMETER_LIST_LENGTH_ERR 0x1a\n#define INVALID_OPCODE 0x20\n#define LBA_OUT_OF_RANGE 0x21\n#define INVALID_FIELD_IN_CDB 0x24\n#define INVALID_FIELD_IN_PARAM_LIST 0x26\n#define WRITE_PROTECTED 0x27\n#define UA_RESET_ASC 0x29\n#define UA_CHANGED_ASC 0x2a\n#define TARGET_CHANGED_ASC 0x3f\n#define LUNS_CHANGED_ASCQ 0x0e\n#define INSUFF_RES_ASC 0x55\n#define INSUFF_RES_ASCQ 0x3\n#define POWER_ON_RESET_ASCQ 0x0\n#define POWER_ON_OCCURRED_ASCQ 0x1\n#define BUS_RESET_ASCQ 0x2\t \n#define MODE_CHANGED_ASCQ 0x1\t \n#define CAPACITY_CHANGED_ASCQ 0x9\n#define SAVING_PARAMS_UNSUP 0x39\n#define TRANSPORT_PROBLEM 0x4b\n#define THRESHOLD_EXCEEDED 0x5d\n#define LOW_POWER_COND_ON 0x5e\n#define MISCOMPARE_VERIFY_ASC 0x1d\n#define MICROCODE_CHANGED_ASCQ 0x1\t \n#define MICROCODE_CHANGED_WO_RESET_ASCQ 0x16\n#define WRITE_ERROR_ASC 0xc\n#define UNALIGNED_WRITE_ASCQ 0x4\n#define WRITE_BOUNDARY_ASCQ 0x5\n#define READ_INVDATA_ASCQ 0x6\n#define READ_BOUNDARY_ASCQ 0x7\n#define ATTEMPT_ACCESS_GAP 0x9\n#define INSUFF_ZONE_ASCQ 0xe\n\n \n#define ACK_NAK_TO 0x3\n\n \n#define DEF_NUM_HOST   1\n#define DEF_NUM_TGTS   1\n#define DEF_MAX_LUNS   1\n \n#define DEF_ATO 1\n#define DEF_CDB_LEN 10\n#define DEF_JDELAY   1\t\t \n#define DEF_DEV_SIZE_PRE_INIT   0\n#define DEF_DEV_SIZE_MB   8\n#define DEF_ZBC_DEV_SIZE_MB   128\n#define DEF_DIF 0\n#define DEF_DIX 0\n#define DEF_PER_HOST_STORE false\n#define DEF_D_SENSE   0\n#define DEF_EVERY_NTH   0\n#define DEF_FAKE_RW\t0\n#define DEF_GUARD 0\n#define DEF_HOST_LOCK 0\n#define DEF_LBPU 0\n#define DEF_LBPWS 0\n#define DEF_LBPWS10 0\n#define DEF_LBPRZ 1\n#define DEF_LOWEST_ALIGNED 0\n#define DEF_NDELAY   0\t\t \n#define DEF_NO_LUN_0   0\n#define DEF_NUM_PARTS   0\n#define DEF_OPTS   0\n#define DEF_OPT_BLKS 1024\n#define DEF_PHYSBLK_EXP 0\n#define DEF_OPT_XFERLEN_EXP 0\n#define DEF_PTYPE   TYPE_DISK\n#define DEF_RANDOM false\n#define DEF_REMOVABLE false\n#define DEF_SCSI_LEVEL   7     \n#define DEF_SECTOR_SIZE 512\n#define DEF_UNMAP_ALIGNMENT 0\n#define DEF_UNMAP_GRANULARITY 1\n#define DEF_UNMAP_MAX_BLOCKS 0xFFFFFFFF\n#define DEF_UNMAP_MAX_DESC 256\n#define DEF_VIRTUAL_GB   0\n#define DEF_VPD_USE_HOSTNO 1\n#define DEF_WRITESAME_LENGTH 0xFFFF\n#define DEF_STRICT 0\n#define DEF_STATISTICS false\n#define DEF_SUBMIT_QUEUES 1\n#define DEF_TUR_MS_TO_READY 0\n#define DEF_UUID_CTL 0\n#define JDELAY_OVERRIDDEN -9999\n\n \n#define DEF_ZBC_ZONE_SIZE_MB\t128\n#define DEF_ZBC_MAX_OPEN_ZONES\t8\n#define DEF_ZBC_NR_CONV_ZONES\t1\n\n#define SDEBUG_LUN_0_VAL 0\n\n \n#define SDEBUG_OPT_NOISE\t\t1\n#define SDEBUG_OPT_MEDIUM_ERR\t\t2\n#define SDEBUG_OPT_TIMEOUT\t\t4\n#define SDEBUG_OPT_RECOVERED_ERR\t8\n#define SDEBUG_OPT_TRANSPORT_ERR\t16\n#define SDEBUG_OPT_DIF_ERR\t\t32\n#define SDEBUG_OPT_DIX_ERR\t\t64\n#define SDEBUG_OPT_MAC_TIMEOUT\t\t128\n#define SDEBUG_OPT_SHORT_TRANSFER\t0x100\n#define SDEBUG_OPT_Q_NOISE\t\t0x200\n#define SDEBUG_OPT_ALL_TSF\t\t0x400\t \n#define SDEBUG_OPT_RARE_TSF\t\t0x800\n#define SDEBUG_OPT_N_WCE\t\t0x1000\n#define SDEBUG_OPT_RESET_NOISE\t\t0x2000\n#define SDEBUG_OPT_NO_CDB_NOISE\t\t0x4000\n#define SDEBUG_OPT_HOST_BUSY\t\t0x8000\n#define SDEBUG_OPT_CMD_ABORT\t\t0x10000\n#define SDEBUG_OPT_ALL_NOISE (SDEBUG_OPT_NOISE | SDEBUG_OPT_Q_NOISE | \\\n\t\t\t      SDEBUG_OPT_RESET_NOISE)\n#define SDEBUG_OPT_ALL_INJECTING (SDEBUG_OPT_RECOVERED_ERR | \\\n\t\t\t\t  SDEBUG_OPT_TRANSPORT_ERR | \\\n\t\t\t\t  SDEBUG_OPT_DIF_ERR | SDEBUG_OPT_DIX_ERR | \\\n\t\t\t\t  SDEBUG_OPT_SHORT_TRANSFER | \\\n\t\t\t\t  SDEBUG_OPT_HOST_BUSY | \\\n\t\t\t\t  SDEBUG_OPT_CMD_ABORT)\n#define SDEBUG_OPT_RECOV_DIF_DIX (SDEBUG_OPT_RECOVERED_ERR | \\\n\t\t\t\t  SDEBUG_OPT_DIF_ERR | SDEBUG_OPT_DIX_ERR)\n\n \n#define SDEBUG_UA_POR 0\t\t \n#define SDEBUG_UA_POOCCUR 1\t \n#define SDEBUG_UA_BUS_RESET 2\n#define SDEBUG_UA_MODE_CHANGED 3\n#define SDEBUG_UA_CAPACITY_CHANGED 4\n#define SDEBUG_UA_LUNS_CHANGED 5\n#define SDEBUG_UA_MICROCODE_CHANGED 6\t \n#define SDEBUG_UA_MICROCODE_CHANGED_WO_RESET 7\n#define SDEBUG_NUM_UAS 8\n\n \n#define OPT_MEDIUM_ERR_ADDR   0x1234  \n#define OPT_MEDIUM_ERR_NUM    10      \n\n \n#define SDEBUG_CANQUEUE_WORDS  3\t \n#define SDEBUG_CANQUEUE  (SDEBUG_CANQUEUE_WORDS * BITS_PER_LONG)\n#define DEF_CMD_PER_LUN  SDEBUG_CANQUEUE\n\n \n#define F_D_IN\t\t\t1\t \n#define F_D_OUT\t\t\t2\t \n#define F_D_OUT_MAYBE\t\t4\t \n#define F_D_UNKN\t\t8\n#define F_RL_WLUN_OK\t\t0x10\t \n#define F_SKIP_UA\t\t0x20\t \n#define F_DELAY_OVERR\t\t0x40\t \n#define F_SA_LOW\t\t0x80\t \n#define F_SA_HIGH\t\t0x100\t \n#define F_INV_OP\t\t0x200\t \n#define F_FAKE_RW\t\t0x400\t \n#define F_M_ACCESS\t\t0x800\t \n#define F_SSU_DELAY\t\t0x1000\t \n#define F_SYNC_DELAY\t\t0x2000\t \n\n \n#define FF_RESPOND (F_RL_WLUN_OK | F_SKIP_UA | F_DELAY_OVERR)\n#define FF_MEDIA_IO (F_M_ACCESS | F_FAKE_RW)\n#define FF_SA (F_SA_HIGH | F_SA_LOW)\n#define F_LONG_DELAY\t\t(F_SSU_DELAY | F_SYNC_DELAY)\n\n#define SDEBUG_MAX_PARTS 4\n\n#define SDEBUG_MAX_CMD_LEN 32\n\n#define SDEB_XA_NOT_IN_USE XA_MARK_1\n\nstatic struct kmem_cache *queued_cmd_cache;\n\n#define TO_QUEUED_CMD(scmd)  ((void *)(scmd)->host_scribble)\n#define ASSIGN_QUEUED_CMD(scmnd, qc) { (scmnd)->host_scribble = (void *) qc; }\n\n \nenum sdebug_z_type {\n\tZBC_ZTYPE_CNV\t= 0x1,\n\tZBC_ZTYPE_SWR\t= 0x2,\n\tZBC_ZTYPE_SWP\t= 0x3,\n\t \n\tZBC_ZTYPE_GAP\t= 0x5,\n};\n\n \nenum sdebug_z_cond {\n\tZBC_NOT_WRITE_POINTER\t= 0x0,\n\tZC1_EMPTY\t\t= 0x1,\n\tZC2_IMPLICIT_OPEN\t= 0x2,\n\tZC3_EXPLICIT_OPEN\t= 0x3,\n\tZC4_CLOSED\t\t= 0x4,\n\tZC6_READ_ONLY\t\t= 0xd,\n\tZC5_FULL\t\t= 0xe,\n\tZC7_OFFLINE\t\t= 0xf,\n};\n\nstruct sdeb_zone_state {\t \n\tenum sdebug_z_type z_type;\n\tenum sdebug_z_cond z_cond;\n\tbool z_non_seq_resource;\n\tunsigned int z_size;\n\tsector_t z_start;\n\tsector_t z_wp;\n};\n\nstruct sdebug_dev_info {\n\tstruct list_head dev_list;\n\tunsigned int channel;\n\tunsigned int target;\n\tu64 lun;\n\tuuid_t lu_name;\n\tstruct sdebug_host_info *sdbg_host;\n\tunsigned long uas_bm[1];\n\tatomic_t stopped;\t \n\tbool used;\n\n\t \n\tenum blk_zoned_model zmodel;\n\tunsigned int zcap;\n\tunsigned int zsize;\n\tunsigned int zsize_shift;\n\tunsigned int nr_zones;\n\tunsigned int nr_conv_zones;\n\tunsigned int nr_seq_zones;\n\tunsigned int nr_imp_open;\n\tunsigned int nr_exp_open;\n\tunsigned int nr_closed;\n\tunsigned int max_open;\n\tktime_t create_ts;\t \n\tstruct sdeb_zone_state *zstate;\n};\n\nstruct sdebug_host_info {\n\tstruct list_head host_list;\n\tint si_idx;\t \n\tstruct Scsi_Host *shost;\n\tstruct device dev;\n\tstruct list_head dev_info_list;\n};\n\n \nstruct sdeb_store_info {\n\trwlock_t macc_lck;\t \n\tu8 *storep;\t\t \n\tstruct t10_pi_tuple *dif_storep;  \n\tvoid *map_storep;\t \n};\n\n#define dev_to_sdebug_host(d)\t\\\n\tcontainer_of(d, struct sdebug_host_info, dev)\n\n#define shost_to_sdebug_host(shost)\t\\\n\tdev_to_sdebug_host(shost->dma_dev)\n\nenum sdeb_defer_type {SDEB_DEFER_NONE = 0, SDEB_DEFER_HRT = 1,\n\t\t      SDEB_DEFER_WQ = 2, SDEB_DEFER_POLL = 3};\n\nstruct sdebug_defer {\n\tstruct hrtimer hrt;\n\tstruct execute_work ew;\n\tktime_t cmpl_ts; \n\tint issuing_cpu;\n\tbool aborted;\t \n\tenum sdeb_defer_type defer_t;\n};\n\nstruct sdebug_queued_cmd {\n\t \n\tstruct sdebug_defer sd_dp;\n\tstruct scsi_cmnd *scmd;\n};\n\nstruct sdebug_scsi_cmd {\n\tspinlock_t   lock;\n};\n\nstatic atomic_t sdebug_cmnd_count;    \nstatic atomic_t sdebug_completions;   \nstatic atomic_t sdebug_miss_cpus;     \nstatic atomic_t sdebug_a_tsf;\t      \nstatic atomic_t sdeb_inject_pending;\nstatic atomic_t sdeb_mq_poll_count;   \n\nstruct opcode_info_t {\n\tu8 num_attached;\t \n\t\t\t\t \n\tu8 opcode;\t\t \n\tu16 sa;\t\t\t \n\tu32 flags;\t\t \n\tint (*pfp)(struct scsi_cmnd *, struct sdebug_dev_info *);\n\tconst struct opcode_info_t *arrp;   \n\tu8 len_mask[16];\t \n\t\t\t\t \n};\n\n \nenum sdeb_opcode_index {\n\tSDEB_I_INVALID_OPCODE =\t0,\n\tSDEB_I_INQUIRY = 1,\n\tSDEB_I_REPORT_LUNS = 2,\n\tSDEB_I_REQUEST_SENSE = 3,\n\tSDEB_I_TEST_UNIT_READY = 4,\n\tSDEB_I_MODE_SENSE = 5,\t\t \n\tSDEB_I_MODE_SELECT = 6,\t\t \n\tSDEB_I_LOG_SENSE = 7,\n\tSDEB_I_READ_CAPACITY = 8,\t \n\tSDEB_I_READ = 9,\t\t \n\tSDEB_I_WRITE = 10,\t\t \n\tSDEB_I_START_STOP = 11,\n\tSDEB_I_SERV_ACT_IN_16 = 12,\t \n\tSDEB_I_SERV_ACT_OUT_16 = 13,\t \n\tSDEB_I_MAINT_IN = 14,\n\tSDEB_I_MAINT_OUT = 15,\n\tSDEB_I_VERIFY = 16,\t\t \n\tSDEB_I_VARIABLE_LEN = 17,\t \n\tSDEB_I_RESERVE = 18,\t\t \n\tSDEB_I_RELEASE = 19,\t\t \n\tSDEB_I_ALLOW_REMOVAL = 20,\t \n\tSDEB_I_REZERO_UNIT = 21,\t \n\tSDEB_I_ATA_PT = 22,\t\t \n\tSDEB_I_SEND_DIAG = 23,\n\tSDEB_I_UNMAP = 24,\n\tSDEB_I_WRITE_BUFFER = 25,\n\tSDEB_I_WRITE_SAME = 26,\t\t \n\tSDEB_I_SYNC_CACHE = 27,\t\t \n\tSDEB_I_COMP_WRITE = 28,\n\tSDEB_I_PRE_FETCH = 29,\t\t \n\tSDEB_I_ZONE_OUT = 30,\t\t \n\tSDEB_I_ZONE_IN = 31,\t\t \n\tSDEB_I_LAST_ELEM_P1 = 32,\t \n};\n\n\nstatic const unsigned char opcode_ind_arr[256] = {\n \n\tSDEB_I_TEST_UNIT_READY, SDEB_I_REZERO_UNIT, 0, SDEB_I_REQUEST_SENSE,\n\t    0, 0, 0, 0,\n\tSDEB_I_READ, 0, SDEB_I_WRITE, 0, 0, 0, 0, 0,\n\t0, 0, SDEB_I_INQUIRY, 0, 0, SDEB_I_MODE_SELECT, SDEB_I_RESERVE,\n\t    SDEB_I_RELEASE,\n\t0, 0, SDEB_I_MODE_SENSE, SDEB_I_START_STOP, 0, SDEB_I_SEND_DIAG,\n\t    SDEB_I_ALLOW_REMOVAL, 0,\n \n\t0, 0, 0, 0, 0, SDEB_I_READ_CAPACITY, 0, 0,\n\tSDEB_I_READ, 0, SDEB_I_WRITE, 0, 0, 0, 0, SDEB_I_VERIFY,\n\t0, 0, 0, 0, SDEB_I_PRE_FETCH, SDEB_I_SYNC_CACHE, 0, 0,\n\t0, 0, 0, SDEB_I_WRITE_BUFFER, 0, 0, 0, 0,\n \n\t0, SDEB_I_WRITE_SAME, SDEB_I_UNMAP, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, SDEB_I_LOG_SENSE, 0, 0,\n\t0, 0, 0, 0, 0, SDEB_I_MODE_SELECT, SDEB_I_RESERVE,\n\t    SDEB_I_RELEASE,\n\t0, 0, SDEB_I_MODE_SENSE, 0, 0, 0, 0, 0,\n \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, SDEB_I_VARIABLE_LEN,\n \n\t0, 0, 0, 0, 0, SDEB_I_ATA_PT, 0, 0,\n\tSDEB_I_READ, SDEB_I_COMP_WRITE, SDEB_I_WRITE, 0,\n\t0, 0, 0, SDEB_I_VERIFY,\n\tSDEB_I_PRE_FETCH, SDEB_I_SYNC_CACHE, 0, SDEB_I_WRITE_SAME,\n\tSDEB_I_ZONE_OUT, SDEB_I_ZONE_IN, 0, 0,\n\t0, 0, 0, 0, 0, 0, SDEB_I_SERV_ACT_IN_16, SDEB_I_SERV_ACT_OUT_16,\n \n\tSDEB_I_REPORT_LUNS, SDEB_I_ATA_PT, 0, SDEB_I_MAINT_IN,\n\t     SDEB_I_MAINT_OUT, 0, 0, 0,\n\tSDEB_I_READ, 0  , SDEB_I_WRITE,\n\t     0  , 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0,\n \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\n \n#define SDEG_RES_IMMED_MASK 0x40000000\n\nstatic int resp_inquiry(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_report_luns(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_requests(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_mode_sense(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_mode_select(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_log_sense(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_readcap(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_read_dt0(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_write_dt0(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_write_scat(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_start_stop(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_readcap16(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_get_lba_status(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_report_tgtpgs(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_unmap(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_rsup_opcodes(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_rsup_tmfs(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_verify(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_write_same_10(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_write_same_16(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_comp_write(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_write_buffer(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_sync_cache(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_pre_fetch(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_report_zones(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_open_zone(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_close_zone(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_finish_zone(struct scsi_cmnd *, struct sdebug_dev_info *);\nstatic int resp_rwp_zone(struct scsi_cmnd *, struct sdebug_dev_info *);\n\nstatic int sdebug_do_add_host(bool mk_new_store);\nstatic int sdebug_add_host_helper(int per_host_idx);\nstatic void sdebug_do_remove_host(bool the_end);\nstatic int sdebug_add_store(void);\nstatic void sdebug_erase_store(int idx, struct sdeb_store_info *sip);\nstatic void sdebug_erase_all_stores(bool apart_from_first);\n\nstatic void sdebug_free_queued_cmd(struct sdebug_queued_cmd *sqcp);\n\n \nstatic const struct opcode_info_t msense_iarr[] = {\n\t{0, 0x1a, 0, F_D_IN, NULL, NULL,\n\t    {6,  0xe8, 0xff, 0xff, 0xff, 0xc7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n};\n\nstatic const struct opcode_info_t mselect_iarr[] = {\n\t{0, 0x15, 0, F_D_OUT, NULL, NULL,\n\t    {6,  0xf1, 0, 0, 0xff, 0xc7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n};\n\nstatic const struct opcode_info_t read_iarr[] = {\n\t{0, 0x28, 0, F_D_IN | FF_MEDIA_IO, resp_read_dt0, NULL, \n\t    {10,  0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xc7, 0, 0,\n\t     0, 0, 0, 0} },\n\t{0, 0x8, 0, F_D_IN | FF_MEDIA_IO, resp_read_dt0, NULL,  \n\t    {6,  0xff, 0xff, 0xff, 0xff, 0xc7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n\t{0, 0xa8, 0, F_D_IN | FF_MEDIA_IO, resp_read_dt0, NULL, \n\t    {12,  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf,\n\t     0xc7, 0, 0, 0, 0} },\n};\n\nstatic const struct opcode_info_t write_iarr[] = {\n\t{0, 0x2a, 0, F_D_OUT | FF_MEDIA_IO, resp_write_dt0,   \n\t    NULL, {10,  0xfb, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xc7,\n\t\t   0, 0, 0, 0, 0, 0} },\n\t{0, 0xa, 0, F_D_OUT | FF_MEDIA_IO, resp_write_dt0,    \n\t    NULL, {6,  0xff, 0xff, 0xff, 0xff, 0xc7, 0, 0, 0, 0, 0, 0, 0,\n\t\t   0, 0, 0} },\n\t{0, 0xaa, 0, F_D_OUT | FF_MEDIA_IO, resp_write_dt0,   \n\t    NULL, {12,  0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t   0xbf, 0xc7, 0, 0, 0, 0} },\n};\n\nstatic const struct opcode_info_t verify_iarr[] = {\n\t{0, 0x2f, 0, F_D_OUT_MAYBE | FF_MEDIA_IO, resp_verify, \n\t    NULL, {10,  0xf7, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xc7,\n\t\t   0, 0, 0, 0, 0, 0} },\n};\n\nstatic const struct opcode_info_t sa_in_16_iarr[] = {\n\t{0, 0x9e, 0x12, F_SA_LOW | F_D_IN, resp_get_lba_status, NULL,\n\t    {16,  0x12, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t     0xff, 0xff, 0xff, 0, 0xc7} },\t \n};\n\nstatic const struct opcode_info_t vl_iarr[] = {\t \n\t{0, 0x7f, 0xb, F_SA_HIGH | F_D_OUT | FF_MEDIA_IO, resp_write_dt0,\n\t    NULL, {32,  0xc7, 0, 0, 0, 0, 0x3f, 0x18, 0x0, 0xb, 0xfa,\n\t\t   0, 0xff, 0xff, 0xff, 0xff} },\t \n\t{0, 0x7f, 0x11, F_SA_HIGH | F_D_OUT | FF_MEDIA_IO, resp_write_scat,\n\t    NULL, {32,  0xc7, 0, 0, 0, 0, 0x3f, 0x18, 0x0, 0x11, 0xf8,\n\t\t   0, 0xff, 0xff, 0x0, 0x0} },\t \n};\n\nstatic const struct opcode_info_t maint_in_iarr[] = {\t \n\t{0, 0xa3, 0xc, F_SA_LOW | F_D_IN, resp_rsup_opcodes, NULL,\n\t    {12,  0xc, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0,\n\t     0xc7, 0, 0, 0, 0} },  \n\t{0, 0xa3, 0xd, F_SA_LOW | F_D_IN, resp_rsup_tmfs, NULL,\n\t    {12,  0xd, 0x80, 0, 0, 0, 0xff, 0xff, 0xff, 0xff, 0, 0xc7, 0, 0,\n\t     0, 0} },\t \n};\n\nstatic const struct opcode_info_t write_same_iarr[] = {\n\t{0, 0x93, 0, F_D_OUT_MAYBE | FF_MEDIA_IO, resp_write_same_16, NULL,\n\t    {16,  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t     0xff, 0xff, 0xff, 0x3f, 0xc7} },\t\t \n};\n\nstatic const struct opcode_info_t reserve_iarr[] = {\n\t{0, 0x16, 0, F_D_OUT, NULL, NULL,\t\t \n\t    {6,  0x1f, 0xff, 0xff, 0xff, 0xc7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n};\n\nstatic const struct opcode_info_t release_iarr[] = {\n\t{0, 0x17, 0, F_D_OUT, NULL, NULL,\t\t \n\t    {6,  0x1f, 0xff, 0, 0, 0xc7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n};\n\nstatic const struct opcode_info_t sync_cache_iarr[] = {\n\t{0, 0x91, 0, F_SYNC_DELAY | F_M_ACCESS, resp_sync_cache, NULL,\n\t    {16,  0x6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t     0xff, 0xff, 0xff, 0xff, 0x3f, 0xc7} },\t \n};\n\nstatic const struct opcode_info_t pre_fetch_iarr[] = {\n\t{0, 0x90, 0, F_SYNC_DELAY | FF_MEDIA_IO, resp_pre_fetch, NULL,\n\t    {16,  0x2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t     0xff, 0xff, 0xff, 0xff, 0x3f, 0xc7} },\t \n};\n\nstatic const struct opcode_info_t zone_out_iarr[] = {\t \n\t{0, 0x94, 0x1, F_SA_LOW | F_M_ACCESS, resp_close_zone, NULL,\n\t    {16, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t     0xff, 0, 0, 0xff, 0xff, 0x1, 0xc7} },\t \n\t{0, 0x94, 0x2, F_SA_LOW | F_M_ACCESS, resp_finish_zone, NULL,\n\t    {16, 0x2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t     0xff, 0, 0, 0xff, 0xff, 0x1, 0xc7} },\t \n\t{0, 0x94, 0x4, F_SA_LOW | F_M_ACCESS, resp_rwp_zone, NULL,\n\t    {16, 0x4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t     0xff, 0, 0, 0xff, 0xff, 0x1, 0xc7} },   \n};\n\nstatic const struct opcode_info_t zone_in_iarr[] = {\t \n\t{0, 0x95, 0x6, F_SA_LOW | F_D_IN | F_M_ACCESS, NULL, NULL,\n\t    {16, 0x6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t     0xff, 0xff, 0xff, 0xff, 0x3f, 0xc7} },  \n};\n\n\n \nstatic const struct opcode_info_t opcode_info_arr[SDEB_I_LAST_ELEM_P1 + 1] = {\n \n\t{0, 0, 0, F_INV_OP | FF_RESPOND, NULL, NULL,\t \n\t    {0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n\t{0, 0x12, 0, FF_RESPOND | F_D_IN, resp_inquiry, NULL,  \n\t    {6,  0xe3, 0xff, 0xff, 0xff, 0xc7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n\t{0, 0xa0, 0, FF_RESPOND | F_D_IN, resp_report_luns, NULL,\n\t    {12,  0xe3, 0xff, 0, 0, 0, 0xff, 0xff, 0xff, 0xff, 0, 0xc7, 0, 0,\n\t     0, 0} },\t\t\t\t\t \n\t{0, 0x3, 0, FF_RESPOND | F_D_IN, resp_requests, NULL,\n\t    {6,  0xe1, 0, 0, 0xff, 0xc7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n\t{0, 0x0, 0, F_M_ACCESS | F_RL_WLUN_OK, NULL, NULL, \n\t    {6,  0, 0, 0, 0, 0xc7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n \n\t{ARRAY_SIZE(msense_iarr), 0x5a, 0, F_D_IN,\t \n\t    resp_mode_sense, msense_iarr, {10,  0xf8, 0xff, 0xff, 0, 0, 0,\n\t\t0xff, 0xff, 0xc7, 0, 0, 0, 0, 0, 0} },\n\t{ARRAY_SIZE(mselect_iarr), 0x55, 0, F_D_OUT,\t \n\t    resp_mode_select, mselect_iarr, {10,  0xf1, 0, 0, 0, 0, 0, 0xff,\n\t\t0xff, 0xc7, 0, 0, 0, 0, 0, 0} },\n\t{0, 0x4d, 0, F_D_IN, resp_log_sense, NULL,\t \n\t    {10,  0xe3, 0xff, 0xff, 0, 0xff, 0xff, 0xff, 0xff, 0xc7, 0, 0, 0,\n\t     0, 0, 0} },\n\t{0, 0x25, 0, F_D_IN, resp_readcap, NULL,     \n\t    {10,  0xe1, 0xff, 0xff, 0xff, 0xff, 0, 0, 0x1, 0xc7, 0, 0, 0, 0,\n\t     0, 0} },\n\t{ARRAY_SIZE(read_iarr), 0x88, 0, F_D_IN | FF_MEDIA_IO,  \n\t    resp_read_dt0, read_iarr, {16,  0xfe, 0xff, 0xff, 0xff, 0xff,\n\t    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7} },\n \n\t{ARRAY_SIZE(write_iarr), 0x8a, 0, F_D_OUT | FF_MEDIA_IO,\n\t    resp_write_dt0, write_iarr,\t\t\t \n\t\t{16,  0xfa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7} },\n\t{0, 0x1b, 0, F_SSU_DELAY, resp_start_stop, NULL, \n\t    {6,  0x1, 0, 0xf, 0xf7, 0xc7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n\t{ARRAY_SIZE(sa_in_16_iarr), 0x9e, 0x10, F_SA_LOW | F_D_IN,\n\t    resp_readcap16, sa_in_16_iarr,  \n\t\t{16,  0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t 0xff, 0xff, 0xff, 0xff, 0x1, 0xc7} },\n\t{0, 0x9f, 0x12, F_SA_LOW | F_D_OUT | FF_MEDIA_IO, resp_write_scat,\n\t    NULL, {16,  0x12, 0xf9, 0x0, 0xff, 0xff, 0, 0, 0xff, 0xff, 0xff,\n\t    0xff, 0xff, 0xff, 0xff, 0xc7} },   \n\t{ARRAY_SIZE(maint_in_iarr), 0xa3, 0xa, F_SA_LOW | F_D_IN,\n\t    resp_report_tgtpgs,\t \n\t\tmaint_in_iarr, {12,  0xea, 0, 0, 0, 0, 0xff, 0xff, 0xff,\n\t\t\t\t0xff, 0, 0xc7, 0, 0, 0, 0} },\n \n\t{0, 0, 0, F_INV_OP | FF_RESPOND, NULL, NULL,  \n\t    {0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n\t{ARRAY_SIZE(verify_iarr), 0x8f, 0,\n\t    F_D_OUT_MAYBE | FF_MEDIA_IO, resp_verify,\t \n\t    verify_iarr, {16,  0xf6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xc7} },\n\t{ARRAY_SIZE(vl_iarr), 0x7f, 0x9, F_SA_HIGH | F_D_IN | FF_MEDIA_IO,\n\t    resp_read_dt0, vl_iarr,\t \n\t    {32,  0xc7, 0, 0, 0, 0, 0x3f, 0x18, 0x0, 0x9, 0xfe, 0, 0xff, 0xff,\n\t     0xff, 0xff} },\n\t{ARRAY_SIZE(reserve_iarr), 0x56, 0, F_D_OUT,\n\t    NULL, reserve_iarr,\t \n\t    {10,  0xff, 0xff, 0xff, 0, 0, 0, 0xff, 0xff, 0xc7, 0, 0, 0, 0, 0,\n\t     0} },\n\t{ARRAY_SIZE(release_iarr), 0x57, 0, F_D_OUT,\n\t    NULL, release_iarr,  \n\t    {10,  0x13, 0xff, 0xff, 0, 0, 0, 0xff, 0xff, 0xc7, 0, 0, 0, 0, 0,\n\t     0} },\n \n\t{0, 0x1e, 0, 0, NULL, NULL,  \n\t    {6,  0, 0, 0, 0x3, 0xc7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n\t{0, 0x1, 0, 0, resp_start_stop, NULL,  \n\t    {6,  0x1, 0, 0, 0, 0xc7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n\t{0, 0, 0, F_INV_OP | FF_RESPOND, NULL, NULL,  \n\t    {0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n\t{0, 0x1d, F_D_OUT, 0, NULL, NULL,\t \n\t    {6,  0xf7, 0, 0xff, 0xff, 0xc7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n\t{0, 0x42, 0, F_D_OUT | FF_MEDIA_IO, resp_unmap, NULL,  \n\t    {10,  0x1, 0, 0, 0, 0, 0x3f, 0xff, 0xff, 0xc7, 0, 0, 0, 0, 0, 0} },\n \n\t{0, 0x3b, 0, F_D_OUT_MAYBE, resp_write_buffer, NULL,\n\t    {10,  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0, 0,\n\t     0, 0, 0, 0} },\t\t\t \n\t{ARRAY_SIZE(write_same_iarr), 0x41, 0, F_D_OUT_MAYBE | FF_MEDIA_IO,\n\t    resp_write_same_10, write_same_iarr,\t \n\t\t{10,  0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xc7, 0,\n\t\t 0, 0, 0, 0, 0} },\n\t{ARRAY_SIZE(sync_cache_iarr), 0x35, 0, F_SYNC_DELAY | F_M_ACCESS,\n\t    resp_sync_cache, sync_cache_iarr,\n\t    {10,  0x7, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xc7, 0, 0,\n\t     0, 0, 0, 0} },\t\t\t \n\t{0, 0x89, 0, F_D_OUT | FF_MEDIA_IO, resp_comp_write, NULL,\n\t    {16,  0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0, 0,\n\t     0, 0xff, 0x3f, 0xc7} },\t\t \n\t{ARRAY_SIZE(pre_fetch_iarr), 0x34, 0, F_SYNC_DELAY | FF_MEDIA_IO,\n\t    resp_pre_fetch, pre_fetch_iarr,\n\t    {10,  0x2, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xc7, 0, 0,\n\t     0, 0, 0, 0} },\t\t\t \n\n \n\t{ARRAY_SIZE(zone_out_iarr), 0x94, 0x3, F_SA_LOW | F_M_ACCESS,\n\t    resp_open_zone, zone_out_iarr,  \n\t\t{16,  0x3  , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x1, 0xc7} },\n\t{ARRAY_SIZE(zone_in_iarr), 0x95, 0x0, F_SA_LOW | F_M_ACCESS,\n\t    resp_report_zones, zone_in_iarr,  \n\t\t{16,  0x0  , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xc7} },\n \n\t{0xff, 0, 0, 0, NULL, NULL,\t\t \n\t    {0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },\n};\n\nstatic int sdebug_num_hosts;\nstatic int sdebug_add_host = DEF_NUM_HOST;   \nstatic int sdebug_ato = DEF_ATO;\nstatic int sdebug_cdb_len = DEF_CDB_LEN;\nstatic int sdebug_jdelay = DEF_JDELAY;\t \nstatic int sdebug_dev_size_mb = DEF_DEV_SIZE_PRE_INIT;\nstatic int sdebug_dif = DEF_DIF;\nstatic int sdebug_dix = DEF_DIX;\nstatic int sdebug_dsense = DEF_D_SENSE;\nstatic int sdebug_every_nth = DEF_EVERY_NTH;\nstatic int sdebug_fake_rw = DEF_FAKE_RW;\nstatic unsigned int sdebug_guard = DEF_GUARD;\nstatic int sdebug_host_max_queue;\t \nstatic int sdebug_lowest_aligned = DEF_LOWEST_ALIGNED;\nstatic int sdebug_max_luns = DEF_MAX_LUNS;\nstatic int sdebug_max_queue = SDEBUG_CANQUEUE;\t \nstatic unsigned int sdebug_medium_error_start = OPT_MEDIUM_ERR_ADDR;\nstatic int sdebug_medium_error_count = OPT_MEDIUM_ERR_NUM;\nstatic int sdebug_ndelay = DEF_NDELAY;\t \nstatic int sdebug_no_lun_0 = DEF_NO_LUN_0;\nstatic int sdebug_no_uld;\nstatic int sdebug_num_parts = DEF_NUM_PARTS;\nstatic int sdebug_num_tgts = DEF_NUM_TGTS;  \nstatic int sdebug_opt_blks = DEF_OPT_BLKS;\nstatic int sdebug_opts = DEF_OPTS;\nstatic int sdebug_physblk_exp = DEF_PHYSBLK_EXP;\nstatic int sdebug_opt_xferlen_exp = DEF_OPT_XFERLEN_EXP;\nstatic int sdebug_ptype = DEF_PTYPE;  \nstatic int sdebug_scsi_level = DEF_SCSI_LEVEL;\nstatic int sdebug_sector_size = DEF_SECTOR_SIZE;\nstatic int sdeb_tur_ms_to_ready = DEF_TUR_MS_TO_READY;\nstatic int sdebug_virtual_gb = DEF_VIRTUAL_GB;\nstatic int sdebug_vpd_use_hostno = DEF_VPD_USE_HOSTNO;\nstatic unsigned int sdebug_lbpu = DEF_LBPU;\nstatic unsigned int sdebug_lbpws = DEF_LBPWS;\nstatic unsigned int sdebug_lbpws10 = DEF_LBPWS10;\nstatic unsigned int sdebug_lbprz = DEF_LBPRZ;\nstatic unsigned int sdebug_unmap_alignment = DEF_UNMAP_ALIGNMENT;\nstatic unsigned int sdebug_unmap_granularity = DEF_UNMAP_GRANULARITY;\nstatic unsigned int sdebug_unmap_max_blocks = DEF_UNMAP_MAX_BLOCKS;\nstatic unsigned int sdebug_unmap_max_desc = DEF_UNMAP_MAX_DESC;\nstatic unsigned int sdebug_write_same_length = DEF_WRITESAME_LENGTH;\nstatic int sdebug_uuid_ctl = DEF_UUID_CTL;\nstatic bool sdebug_random = DEF_RANDOM;\nstatic bool sdebug_per_host_store = DEF_PER_HOST_STORE;\nstatic bool sdebug_removable = DEF_REMOVABLE;\nstatic bool sdebug_clustering;\nstatic bool sdebug_host_lock = DEF_HOST_LOCK;\nstatic bool sdebug_strict = DEF_STRICT;\nstatic bool sdebug_any_injecting_opt;\nstatic bool sdebug_no_rwlock;\nstatic bool sdebug_verbose;\nstatic bool have_dif_prot;\nstatic bool write_since_sync;\nstatic bool sdebug_statistics = DEF_STATISTICS;\nstatic bool sdebug_wp;\n \nstatic enum blk_zoned_model sdeb_zbc_model = BLK_ZONED_NONE;\nstatic char *sdeb_zbc_model_s;\n\nenum sam_lun_addr_method {SAM_LUN_AM_PERIPHERAL = 0x0,\n\t\t\t  SAM_LUN_AM_FLAT = 0x1,\n\t\t\t  SAM_LUN_AM_LOGICAL_UNIT = 0x2,\n\t\t\t  SAM_LUN_AM_EXTENDED = 0x3};\nstatic enum sam_lun_addr_method sdebug_lun_am = SAM_LUN_AM_PERIPHERAL;\nstatic int sdebug_lun_am_i = (int)SAM_LUN_AM_PERIPHERAL;\n\nstatic unsigned int sdebug_store_sectors;\nstatic sector_t sdebug_capacity;\t \n\n \nstatic int sdebug_heads;\t\t \nstatic int sdebug_cylinders_per;\t \nstatic int sdebug_sectors_per;\t\t \n\nstatic LIST_HEAD(sdebug_host_list);\nstatic DEFINE_MUTEX(sdebug_host_list_mutex);\n\nstatic struct xarray per_store_arr;\nstatic struct xarray *per_store_ap = &per_store_arr;\nstatic int sdeb_first_idx = -1;\t\t \nstatic int sdeb_most_recent_idx = -1;\nstatic DEFINE_RWLOCK(sdeb_fake_rw_lck);\t \n\nstatic unsigned long map_size;\nstatic int num_aborts;\nstatic int num_dev_resets;\nstatic int num_target_resets;\nstatic int num_bus_resets;\nstatic int num_host_resets;\nstatic int dix_writes;\nstatic int dix_reads;\nstatic int dif_errors;\n\n \nstatic bool sdeb_zbc_in_use;\t \nstatic int sdeb_zbc_zone_cap_mb;\nstatic int sdeb_zbc_zone_size_mb;\nstatic int sdeb_zbc_max_open = DEF_ZBC_MAX_OPEN_ZONES;\nstatic int sdeb_zbc_nr_conv = DEF_ZBC_NR_CONV_ZONES;\n\nstatic int submit_queues = DEF_SUBMIT_QUEUES;   \nstatic int poll_queues;  \n\nstatic char sdebug_proc_name[] = MY_NAME;\nstatic const char *my_name = MY_NAME;\n\nstatic struct bus_type pseudo_lld_bus;\n\nstatic struct device_driver sdebug_driverfs_driver = {\n\t.name \t\t= sdebug_proc_name,\n\t.bus\t\t= &pseudo_lld_bus,\n};\n\nstatic const int check_condition_result =\n\tSAM_STAT_CHECK_CONDITION;\n\nstatic const int illegal_condition_result =\n\t(DID_ABORT << 16) | SAM_STAT_CHECK_CONDITION;\n\nstatic const int device_qfull_result =\n\t(DID_ABORT << 16) | SAM_STAT_TASK_SET_FULL;\n\nstatic const int condition_met_result = SAM_STAT_CONDITION_MET;\n\n\n \nstatic inline bool scsi_debug_lbp(void)\n{\n\treturn 0 == sdebug_fake_rw &&\n\t\t(sdebug_lbpu || sdebug_lbpws || sdebug_lbpws10);\n}\n\nstatic void *lba2fake_store(struct sdeb_store_info *sip,\n\t\t\t    unsigned long long lba)\n{\n\tstruct sdeb_store_info *lsip = sip;\n\n\tlba = do_div(lba, sdebug_store_sectors);\n\tif (!sip || !sip->storep) {\n\t\tWARN_ON_ONCE(true);\n\t\tlsip = xa_load(per_store_ap, 0);   \n\t}\n\treturn lsip->storep + lba * sdebug_sector_size;\n}\n\nstatic struct t10_pi_tuple *dif_store(struct sdeb_store_info *sip,\n\t\t\t\t      sector_t sector)\n{\n\tsector = sector_div(sector, sdebug_store_sectors);\n\n\treturn sip->dif_storep + sector;\n}\n\nstatic void sdebug_max_tgts_luns(void)\n{\n\tstruct sdebug_host_info *sdbg_host;\n\tstruct Scsi_Host *hpnt;\n\n\tmutex_lock(&sdebug_host_list_mutex);\n\tlist_for_each_entry(sdbg_host, &sdebug_host_list, host_list) {\n\t\thpnt = sdbg_host->shost;\n\t\tif ((hpnt->this_id >= 0) &&\n\t\t    (sdebug_num_tgts > hpnt->this_id))\n\t\t\thpnt->max_id = sdebug_num_tgts + 1;\n\t\telse\n\t\t\thpnt->max_id = sdebug_num_tgts;\n\t\t \n\t\thpnt->max_lun = SCSI_W_LUN_REPORT_LUNS + 1;\n\t}\n\tmutex_unlock(&sdebug_host_list_mutex);\n}\n\nenum sdeb_cmd_data {SDEB_IN_DATA = 0, SDEB_IN_CDB = 1};\n\n \nstatic void mk_sense_invalid_fld(struct scsi_cmnd *scp,\n\t\t\t\t enum sdeb_cmd_data c_d,\n\t\t\t\t int in_byte, int in_bit)\n{\n\tunsigned char *sbuff;\n\tu8 sks[4];\n\tint sl, asc;\n\n\tsbuff = scp->sense_buffer;\n\tif (!sbuff) {\n\t\tsdev_printk(KERN_ERR, scp->device,\n\t\t\t    \"%s: sense_buffer is NULL\\n\", __func__);\n\t\treturn;\n\t}\n\tasc = c_d ? INVALID_FIELD_IN_CDB : INVALID_FIELD_IN_PARAM_LIST;\n\tmemset(sbuff, 0, SCSI_SENSE_BUFFERSIZE);\n\tscsi_build_sense(scp, sdebug_dsense, ILLEGAL_REQUEST, asc, 0);\n\tmemset(sks, 0, sizeof(sks));\n\tsks[0] = 0x80;\n\tif (c_d)\n\t\tsks[0] |= 0x40;\n\tif (in_bit >= 0) {\n\t\tsks[0] |= 0x8;\n\t\tsks[0] |= 0x7 & in_bit;\n\t}\n\tput_unaligned_be16(in_byte, sks + 1);\n\tif (sdebug_dsense) {\n\t\tsl = sbuff[7] + 8;\n\t\tsbuff[7] = sl;\n\t\tsbuff[sl] = 0x2;\n\t\tsbuff[sl + 1] = 0x6;\n\t\tmemcpy(sbuff + sl + 4, sks, 3);\n\t} else\n\t\tmemcpy(sbuff + 15, sks, 3);\n\tif (sdebug_verbose)\n\t\tsdev_printk(KERN_INFO, scp->device, \"%s:  [sense_key,asc,ascq\"\n\t\t\t    \"]: [0x5,0x%x,0x0] %c byte=%d, bit=%d\\n\",\n\t\t\t    my_name, asc, c_d ? 'C' : 'D', in_byte, in_bit);\n}\n\nstatic void mk_sense_buffer(struct scsi_cmnd *scp, int key, int asc, int asq)\n{\n\tif (!scp->sense_buffer) {\n\t\tsdev_printk(KERN_ERR, scp->device,\n\t\t\t    \"%s: sense_buffer is NULL\\n\", __func__);\n\t\treturn;\n\t}\n\tmemset(scp->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\n\n\tscsi_build_sense(scp, sdebug_dsense, key, asc, asq);\n\n\tif (sdebug_verbose)\n\t\tsdev_printk(KERN_INFO, scp->device,\n\t\t\t    \"%s:  [sense_key,asc,ascq]: [0x%x,0x%x,0x%x]\\n\",\n\t\t\t    my_name, key, asc, asq);\n}\n\nstatic void mk_sense_invalid_opcode(struct scsi_cmnd *scp)\n{\n\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_OPCODE, 0);\n}\n\nstatic int scsi_debug_ioctl(struct scsi_device *dev, unsigned int cmd,\n\t\t\t    void __user *arg)\n{\n\tif (sdebug_verbose) {\n\t\tif (0x1261 == cmd)\n\t\t\tsdev_printk(KERN_INFO, dev,\n\t\t\t\t    \"%s: BLKFLSBUF [0x1261]\\n\", __func__);\n\t\telse if (0x5331 == cmd)\n\t\t\tsdev_printk(KERN_INFO, dev,\n\t\t\t\t    \"%s: CDROM_GET_CAPABILITY [0x5331]\\n\",\n\t\t\t\t    __func__);\n\t\telse\n\t\t\tsdev_printk(KERN_INFO, dev, \"%s: cmd=0x%x\\n\",\n\t\t\t\t    __func__, cmd);\n\t}\n\treturn -EINVAL;\n\t \n}\n\nstatic void config_cdb_len(struct scsi_device *sdev)\n{\n\tswitch (sdebug_cdb_len) {\n\tcase 6:\t \n\t\tsdev->use_10_for_rw = false;\n\t\tsdev->use_16_for_rw = false;\n\t\tsdev->use_10_for_ms = false;\n\t\tbreak;\n\tcase 10:  \n\t\tsdev->use_10_for_rw = true;\n\t\tsdev->use_16_for_rw = false;\n\t\tsdev->use_10_for_ms = false;\n\t\tbreak;\n\tcase 12:  \n\t\tsdev->use_10_for_rw = true;\n\t\tsdev->use_16_for_rw = false;\n\t\tsdev->use_10_for_ms = true;\n\t\tbreak;\n\tcase 16:\n\t\tsdev->use_10_for_rw = false;\n\t\tsdev->use_16_for_rw = true;\n\t\tsdev->use_10_for_ms = true;\n\t\tbreak;\n\tcase 32:  \n\t\tsdev->use_10_for_rw = false;\n\t\tsdev->use_16_for_rw = true;\n\t\tsdev->use_10_for_ms = true;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"unexpected cdb_len=%d, force to 10\\n\",\n\t\t\tsdebug_cdb_len);\n\t\tsdev->use_10_for_rw = true;\n\t\tsdev->use_16_for_rw = false;\n\t\tsdev->use_10_for_ms = false;\n\t\tsdebug_cdb_len = 10;\n\t\tbreak;\n\t}\n}\n\nstatic void all_config_cdb_len(void)\n{\n\tstruct sdebug_host_info *sdbg_host;\n\tstruct Scsi_Host *shost;\n\tstruct scsi_device *sdev;\n\n\tmutex_lock(&sdebug_host_list_mutex);\n\tlist_for_each_entry(sdbg_host, &sdebug_host_list, host_list) {\n\t\tshost = sdbg_host->shost;\n\t\tshost_for_each_device(sdev, shost) {\n\t\t\tconfig_cdb_len(sdev);\n\t\t}\n\t}\n\tmutex_unlock(&sdebug_host_list_mutex);\n}\n\nstatic void clear_luns_changed_on_target(struct sdebug_dev_info *devip)\n{\n\tstruct sdebug_host_info *sdhp = devip->sdbg_host;\n\tstruct sdebug_dev_info *dp;\n\n\tlist_for_each_entry(dp, &sdhp->dev_info_list, dev_list) {\n\t\tif ((devip->sdbg_host == dp->sdbg_host) &&\n\t\t    (devip->target == dp->target)) {\n\t\t\tclear_bit(SDEBUG_UA_LUNS_CHANGED, dp->uas_bm);\n\t\t}\n\t}\n}\n\nstatic int make_ua(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\n{\n\tint k;\n\n\tk = find_first_bit(devip->uas_bm, SDEBUG_NUM_UAS);\n\tif (k != SDEBUG_NUM_UAS) {\n\t\tconst char *cp = NULL;\n\n\t\tswitch (k) {\n\t\tcase SDEBUG_UA_POR:\n\t\t\tmk_sense_buffer(scp, UNIT_ATTENTION, UA_RESET_ASC,\n\t\t\t\t\tPOWER_ON_RESET_ASCQ);\n\t\t\tif (sdebug_verbose)\n\t\t\t\tcp = \"power on reset\";\n\t\t\tbreak;\n\t\tcase SDEBUG_UA_POOCCUR:\n\t\t\tmk_sense_buffer(scp, UNIT_ATTENTION, UA_RESET_ASC,\n\t\t\t\t\tPOWER_ON_OCCURRED_ASCQ);\n\t\t\tif (sdebug_verbose)\n\t\t\t\tcp = \"power on occurred\";\n\t\t\tbreak;\n\t\tcase SDEBUG_UA_BUS_RESET:\n\t\t\tmk_sense_buffer(scp, UNIT_ATTENTION, UA_RESET_ASC,\n\t\t\t\t\tBUS_RESET_ASCQ);\n\t\t\tif (sdebug_verbose)\n\t\t\t\tcp = \"bus reset\";\n\t\t\tbreak;\n\t\tcase SDEBUG_UA_MODE_CHANGED:\n\t\t\tmk_sense_buffer(scp, UNIT_ATTENTION, UA_CHANGED_ASC,\n\t\t\t\t\tMODE_CHANGED_ASCQ);\n\t\t\tif (sdebug_verbose)\n\t\t\t\tcp = \"mode parameters changed\";\n\t\t\tbreak;\n\t\tcase SDEBUG_UA_CAPACITY_CHANGED:\n\t\t\tmk_sense_buffer(scp, UNIT_ATTENTION, UA_CHANGED_ASC,\n\t\t\t\t\tCAPACITY_CHANGED_ASCQ);\n\t\t\tif (sdebug_verbose)\n\t\t\t\tcp = \"capacity data changed\";\n\t\t\tbreak;\n\t\tcase SDEBUG_UA_MICROCODE_CHANGED:\n\t\t\tmk_sense_buffer(scp, UNIT_ATTENTION,\n\t\t\t\t\tTARGET_CHANGED_ASC,\n\t\t\t\t\tMICROCODE_CHANGED_ASCQ);\n\t\t\tif (sdebug_verbose)\n\t\t\t\tcp = \"microcode has been changed\";\n\t\t\tbreak;\n\t\tcase SDEBUG_UA_MICROCODE_CHANGED_WO_RESET:\n\t\t\tmk_sense_buffer(scp, UNIT_ATTENTION,\n\t\t\t\t\tTARGET_CHANGED_ASC,\n\t\t\t\t\tMICROCODE_CHANGED_WO_RESET_ASCQ);\n\t\t\tif (sdebug_verbose)\n\t\t\t\tcp = \"microcode has been changed without reset\";\n\t\t\tbreak;\n\t\tcase SDEBUG_UA_LUNS_CHANGED:\n\t\t\t \n\t\t\tif (sdebug_scsi_level >= 6)\t \n\t\t\t\tclear_luns_changed_on_target(devip);\n\t\t\tmk_sense_buffer(scp, UNIT_ATTENTION,\n\t\t\t\t\tTARGET_CHANGED_ASC,\n\t\t\t\t\tLUNS_CHANGED_ASCQ);\n\t\t\tif (sdebug_verbose)\n\t\t\t\tcp = \"reported luns data has changed\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unexpected unit attention code=%d\\n\", k);\n\t\t\tif (sdebug_verbose)\n\t\t\t\tcp = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t\tclear_bit(k, devip->uas_bm);\n\t\tif (sdebug_verbose)\n\t\t\tsdev_printk(KERN_INFO, scp->device,\n\t\t\t\t   \"%s reports: Unit attention: %s\\n\",\n\t\t\t\t   my_name, cp);\n\t\treturn check_condition_result;\n\t}\n\treturn 0;\n}\n\n \nstatic int fill_from_dev_buffer(struct scsi_cmnd *scp, unsigned char *arr,\n\t\t\t\tint arr_len)\n{\n\tint act_len;\n\tstruct scsi_data_buffer *sdb = &scp->sdb;\n\n\tif (!sdb->length)\n\t\treturn 0;\n\tif (scp->sc_data_direction != DMA_FROM_DEVICE)\n\t\treturn DID_ERROR << 16;\n\n\tact_len = sg_copy_from_buffer(sdb->table.sgl, sdb->table.nents,\n\t\t\t\t      arr, arr_len);\n\tscsi_set_resid(scp, scsi_bufflen(scp) - act_len);\n\n\treturn 0;\n}\n\n \nstatic int p_fill_from_dev_buffer(struct scsi_cmnd *scp, const void *arr,\n\t\t\t\t  int arr_len, unsigned int off_dst)\n{\n\tunsigned int act_len, n;\n\tstruct scsi_data_buffer *sdb = &scp->sdb;\n\toff_t skip = off_dst;\n\n\tif (sdb->length <= off_dst)\n\t\treturn 0;\n\tif (scp->sc_data_direction != DMA_FROM_DEVICE)\n\t\treturn DID_ERROR << 16;\n\n\tact_len = sg_pcopy_from_buffer(sdb->table.sgl, sdb->table.nents,\n\t\t\t\t       arr, arr_len, skip);\n\tpr_debug(\"%s: off_dst=%u, scsi_bufflen=%u, act_len=%u, resid=%d\\n\",\n\t\t __func__, off_dst, scsi_bufflen(scp), act_len,\n\t\t scsi_get_resid(scp));\n\tn = scsi_bufflen(scp) - (off_dst + act_len);\n\tscsi_set_resid(scp, min_t(u32, scsi_get_resid(scp), n));\n\treturn 0;\n}\n\n \nstatic int fetch_to_dev_buffer(struct scsi_cmnd *scp, unsigned char *arr,\n\t\t\t       int arr_len)\n{\n\tif (!scsi_bufflen(scp))\n\t\treturn 0;\n\tif (scp->sc_data_direction != DMA_TO_DEVICE)\n\t\treturn -1;\n\n\treturn scsi_sg_copy_to_buffer(scp, arr, arr_len);\n}\n\n\nstatic char sdebug_inq_vendor_id[9] = \"Linux   \";\nstatic char sdebug_inq_product_id[17] = \"scsi_debug      \";\nstatic char sdebug_inq_product_rev[5] = SDEBUG_VERSION;\n \nstatic const u64 naa3_comp_a = 0x3222222000000000ULL;\nstatic const u64 naa3_comp_b = 0x3333333000000000ULL;\nstatic const u64 naa3_comp_c = 0x3111111000000000ULL;\n\n \nstatic int inquiry_vpd_83(unsigned char *arr, int port_group_id,\n\t\t\t  int target_dev_id, int dev_id_num,\n\t\t\t  const char *dev_id_str, int dev_id_str_len,\n\t\t\t  const uuid_t *lu_name)\n{\n\tint num, port_a;\n\tchar b[32];\n\n\tport_a = target_dev_id + 1;\n\t \n\tarr[0] = 0x2;\t \n\tarr[1] = 0x1;\n\tarr[2] = 0x0;\n\tmemcpy(&arr[4], sdebug_inq_vendor_id, 8);\n\tmemcpy(&arr[12], sdebug_inq_product_id, 16);\n\tmemcpy(&arr[28], dev_id_str, dev_id_str_len);\n\tnum = 8 + 16 + dev_id_str_len;\n\tarr[3] = num;\n\tnum += 4;\n\tif (dev_id_num >= 0) {\n\t\tif (sdebug_uuid_ctl) {\n\t\t\t \n\t\t\tarr[num++] = 0x1;   \n\t\t\tarr[num++] = 0xa;   \n\t\t\tarr[num++] = 0x0;\n\t\t\tarr[num++] = 0x12;\n\t\t\tarr[num++] = 0x10;  \n\t\t\tarr[num++] = 0x0;\n\t\t\tmemcpy(arr + num, lu_name, 16);\n\t\t\tnum += 16;\n\t\t} else {\n\t\t\t \n\t\t\tarr[num++] = 0x1;   \n\t\t\tarr[num++] = 0x3;   \n\t\t\tarr[num++] = 0x0;\n\t\t\tarr[num++] = 0x8;\n\t\t\tput_unaligned_be64(naa3_comp_b + dev_id_num, arr + num);\n\t\t\tnum += 8;\n\t\t}\n\t\t \n\t\tarr[num++] = 0x61;\t \n\t\tarr[num++] = 0x94;\t \n\t\tarr[num++] = 0x0;\t \n\t\tarr[num++] = 0x4;\t \n\t\tarr[num++] = 0x0;\t \n\t\tarr[num++] = 0x0;\t \n\t\tarr[num++] = 0x0;\n\t\tarr[num++] = 0x1;\t \n\t}\n\t \n\tarr[num++] = 0x61;\t \n\tarr[num++] = 0x93;\t \n\tarr[num++] = 0x0;\n\tarr[num++] = 0x8;\n\tput_unaligned_be64(naa3_comp_a + port_a, arr + num);\n\tnum += 8;\n\t \n\tarr[num++] = 0x61;\t \n\tarr[num++] = 0x95;\t \n\tarr[num++] = 0x0;\n\tarr[num++] = 0x4;\n\tarr[num++] = 0;\n\tarr[num++] = 0;\n\tput_unaligned_be16(port_group_id, arr + num);\n\tnum += 2;\n\t \n\tarr[num++] = 0x61;\t \n\tarr[num++] = 0xa3;\t \n\tarr[num++] = 0x0;\n\tarr[num++] = 0x8;\n\tput_unaligned_be64(naa3_comp_a + target_dev_id, arr + num);\n\tnum += 8;\n\t \n\tarr[num++] = 0x63;\t \n\tarr[num++] = 0xa8;\t \n\tarr[num++] = 0x0;\n\tarr[num++] = 24;\n\tmemcpy(arr + num, \"naa.32222220\", 12);\n\tnum += 12;\n\tsnprintf(b, sizeof(b), \"%08X\", target_dev_id);\n\tmemcpy(arr + num, b, 8);\n\tnum += 8;\n\tmemset(arr + num, 0, 4);\n\tnum += 4;\n\treturn num;\n}\n\nstatic unsigned char vpd84_data[] = {\n  0x22,0x22,0x22,0x0,0xbb,0x0,\n    0x22,0x22,0x22,0x0,0xbb,0x1,\n    0x22,0x22,0x22,0x0,0xbb,0x2,\n};\n\n \nstatic int inquiry_vpd_84(unsigned char *arr)\n{\n\tmemcpy(arr, vpd84_data, sizeof(vpd84_data));\n\treturn sizeof(vpd84_data);\n}\n\n \nstatic int inquiry_vpd_85(unsigned char *arr)\n{\n\tint num = 0;\n\tconst char *na1 = \"https://www.kernel.org/config\";\n\tconst char *na2 = \"http://www.kernel.org/log\";\n\tint plen, olen;\n\n\tarr[num++] = 0x1;\t \n\tarr[num++] = 0x0;\t \n\tarr[num++] = 0x0;\n\tolen = strlen(na1);\n\tplen = olen + 1;\n\tif (plen % 4)\n\t\tplen = ((plen / 4) + 1) * 4;\n\tarr[num++] = plen;\t \n\tmemcpy(arr + num, na1, olen);\n\tmemset(arr + num + olen, 0, plen - olen);\n\tnum += plen;\n\n\tarr[num++] = 0x4;\t \n\tarr[num++] = 0x0;\t \n\tarr[num++] = 0x0;\n\tolen = strlen(na2);\n\tplen = olen + 1;\n\tif (plen % 4)\n\t\tplen = ((plen / 4) + 1) * 4;\n\tarr[num++] = plen;\t \n\tmemcpy(arr + num, na2, olen);\n\tmemset(arr + num + olen, 0, plen - olen);\n\tnum += plen;\n\n\treturn num;\n}\n\n \nstatic int inquiry_vpd_88(unsigned char *arr, int target_dev_id)\n{\n\tint num = 0;\n\tint port_a, port_b;\n\n\tport_a = target_dev_id + 1;\n\tport_b = port_a + 1;\n\tarr[num++] = 0x0;\t \n\tarr[num++] = 0x0;\t \n\tarr[num++] = 0x0;\n\tarr[num++] = 0x1;\t \n\tmemset(arr + num, 0, 6);\n\tnum += 6;\n\tarr[num++] = 0x0;\n\tarr[num++] = 12;\t \n\t \n\tarr[num++] = 0x61;\t \n\tarr[num++] = 0x93;\t \n\tarr[num++] = 0x0;\t \n\tarr[num++] = 0x8;\t \n\tput_unaligned_be64(naa3_comp_a + port_a, arr + num);\n\tnum += 8;\n\tarr[num++] = 0x0;\t \n\tarr[num++] = 0x0;\t \n\tarr[num++] = 0x0;\n\tarr[num++] = 0x2;\t \n\tmemset(arr + num, 0, 6);\n\tnum += 6;\n\tarr[num++] = 0x0;\n\tarr[num++] = 12;\t \n\t \n\tarr[num++] = 0x61;\t \n\tarr[num++] = 0x93;\t \n\tarr[num++] = 0x0;\t \n\tarr[num++] = 0x8;\t \n\tput_unaligned_be64(naa3_comp_a + port_b, arr + num);\n\tnum += 8;\n\n\treturn num;\n}\n\n\nstatic unsigned char vpd89_data[] = {\n  0,0,0,0,\n'l','i','n','u','x',' ',' ',' ',\n'S','A','T',' ','s','c','s','i','_','d','e','b','u','g',' ',' ',\n'1','2','3','4',\n0x34,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n0xec,0,0,0,\n0x5a,0xc,0xff,0x3f,0x37,0xc8,0x10,0,0,0,0,0,0x3f,0,0,0,\n0,0,0,0,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x20,0x20,0x20,0x20,\n0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0,0,0,0x40,0x4,0,0x2e,0x33,\n0x38,0x31,0x20,0x20,0x20,0x20,0x54,0x53,0x38,0x33,0x30,0x30,0x33,0x31,\n0x53,0x41,\n0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,\n0x20,0x20,\n0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,\n0x10,0x80,\n0,0,0,0x2f,0,0,0,0x2,0,0x2,0x7,0,0xff,0xff,0x1,0,\n0x3f,0,0xc1,0xff,0x3e,0,0x10,0x1,0xb0,0xf8,0x50,0x9,0,0,0x7,0,\n0x3,0,0x78,0,0x78,0,0xf0,0,0x78,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0x2,0,0,0,0,0,0,0,\n0x7e,0,0x1b,0,0x6b,0x34,0x1,0x7d,0x3,0x40,0x69,0x34,0x1,0x3c,0x3,0x40,\n0x7f,0x40,0,0,0,0,0xfe,0xfe,0,0,0,0,0,0xfe,0,0,\n0,0,0,0,0,0,0,0,0xb0,0xf8,0x50,0x9,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0x1,0,0xb0,0xf8,0x50,0x9,0xb0,0xf8,0x50,0x9,0x20,0x20,0x2,0,0xb6,0x42,\n0,0x80,0x8a,0,0x6,0x3c,0xa,0x3c,0xff,0xff,0xc6,0x7,0,0x1,0,0x8,\n0xf0,0xf,0,0x10,0x2,0,0x30,0,0,0,0,0,0,0,0x6,0xfe,\n0,0,0x2,0,0x50,0,0x8a,0,0x4f,0x95,0,0,0x21,0,0xb,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0xa5,0x51,\n};\n\n \nstatic int inquiry_vpd_89(unsigned char *arr)\n{\n\tmemcpy(arr, vpd89_data, sizeof(vpd89_data));\n\treturn sizeof(vpd89_data);\n}\n\n\nstatic unsigned char vpdb0_data[] = {\n\t  0,0,0,4, 0,0,0x4,0, 0,0,0,64,\n\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n};\n\n \nstatic int inquiry_vpd_b0(unsigned char *arr)\n{\n\tunsigned int gran;\n\n\tmemcpy(arr, vpdb0_data, sizeof(vpdb0_data));\n\n\t \n\tif (sdebug_opt_xferlen_exp != 0 &&\n\t    sdebug_physblk_exp < sdebug_opt_xferlen_exp)\n\t\tgran = 1 << sdebug_opt_xferlen_exp;\n\telse\n\t\tgran = 1 << sdebug_physblk_exp;\n\tput_unaligned_be16(gran, arr + 2);\n\n\t \n\tif (sdebug_store_sectors > 0x400)\n\t\tput_unaligned_be32(sdebug_store_sectors, arr + 4);\n\n\t \n\tput_unaligned_be32(sdebug_opt_blks, &arr[8]);\n\n\tif (sdebug_lbpu) {\n\t\t \n\t\tput_unaligned_be32(sdebug_unmap_max_blocks, &arr[16]);\n\n\t\t \n\t\tput_unaligned_be32(sdebug_unmap_max_desc, &arr[20]);\n\t}\n\n\t \n\tif (sdebug_unmap_alignment) {\n\t\tput_unaligned_be32(sdebug_unmap_alignment, &arr[28]);\n\t\tarr[28] |= 0x80;  \n\t}\n\n\t \n\tput_unaligned_be32(sdebug_unmap_granularity, &arr[24]);\n\n\t \n\tput_unaligned_be64(sdebug_write_same_length, &arr[32]);\n\n\treturn 0x3c;  \n}\n\n \nstatic int inquiry_vpd_b1(struct sdebug_dev_info *devip, unsigned char *arr)\n{\n\tmemset(arr, 0, 0x3c);\n\tarr[0] = 0;\n\tarr[1] = 1;\t \n\tarr[2] = 0;\n\tarr[3] = 5;\t \n\tif (devip->zmodel == BLK_ZONED_HA)\n\t\tarr[4] = 1 << 4;\t \n\n\treturn 0x3c;\n}\n\n \nstatic int inquiry_vpd_b2(unsigned char *arr)\n{\n\tmemset(arr, 0, 0x4);\n\tarr[0] = 0;\t\t\t \n\tif (sdebug_lbpu)\n\t\tarr[1] = 1 << 7;\n\tif (sdebug_lbpws)\n\t\tarr[1] |= 1 << 6;\n\tif (sdebug_lbpws10)\n\t\tarr[1] |= 1 << 5;\n\tif (sdebug_lbprz && scsi_debug_lbp())\n\t\tarr[1] |= (sdebug_lbprz & 0x7) << 2;   \n\t \n\t \n\t \n\treturn 0x4;\n}\n\n \nstatic int inquiry_vpd_b6(struct sdebug_dev_info *devip, unsigned char *arr)\n{\n\tmemset(arr, 0, 0x3c);\n\tarr[0] = 0x1;  \n\t \n\tput_unaligned_be32(0xffffffff, &arr[4]);\n\tput_unaligned_be32(0xffffffff, &arr[8]);\n\tif (sdeb_zbc_model == BLK_ZONED_HM && devip->max_open)\n\t\tput_unaligned_be32(devip->max_open, &arr[12]);\n\telse\n\t\tput_unaligned_be32(0xffffffff, &arr[12]);\n\tif (devip->zcap < devip->zsize) {\n\t\tarr[19] = ZBC_CONSTANT_ZONE_START_OFFSET;\n\t\tput_unaligned_be64(devip->zsize, &arr[20]);\n\t} else {\n\t\tarr[19] = 0;\n\t}\n\treturn 0x3c;\n}\n\n#define SDEBUG_LONG_INQ_SZ 96\n#define SDEBUG_MAX_INQ_ARR_SZ 584\n\nstatic int resp_inquiry(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\n{\n\tunsigned char pq_pdt;\n\tunsigned char *arr;\n\tunsigned char *cmd = scp->cmnd;\n\tu32 alloc_len, n;\n\tint ret;\n\tbool have_wlun, is_disk, is_zbc, is_disk_zbc;\n\n\talloc_len = get_unaligned_be16(cmd + 3);\n\tarr = kzalloc(SDEBUG_MAX_INQ_ARR_SZ, GFP_ATOMIC);\n\tif (! arr)\n\t\treturn DID_REQUEUE << 16;\n\tis_disk = (sdebug_ptype == TYPE_DISK);\n\tis_zbc = (devip->zmodel != BLK_ZONED_NONE);\n\tis_disk_zbc = (is_disk || is_zbc);\n\thave_wlun = scsi_is_wlun(scp->device->lun);\n\tif (have_wlun)\n\t\tpq_pdt = TYPE_WLUN;\t \n\telse if (sdebug_no_lun_0 && (devip->lun == SDEBUG_LUN_0_VAL))\n\t\tpq_pdt = 0x7f;\t \n\telse\n\t\tpq_pdt = (sdebug_ptype & 0x1f);\n\tarr[0] = pq_pdt;\n\tif (0x2 & cmd[1]) {   \n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 1, 1);\n\t\tkfree(arr);\n\t\treturn check_condition_result;\n\t} else if (0x1 & cmd[1]) {   \n\t\tint lu_id_num, port_group_id, target_dev_id;\n\t\tu32 len;\n\t\tchar lu_id_str[6];\n\t\tint host_no = devip->sdbg_host->shost->host_no;\n\t\t\n\t\tport_group_id = (((host_no + 1) & 0x7f) << 8) +\n\t\t    (devip->channel & 0x7f);\n\t\tif (sdebug_vpd_use_hostno == 0)\n\t\t\thost_no = 0;\n\t\tlu_id_num = have_wlun ? -1 : (((host_no + 1) * 2000) +\n\t\t\t    (devip->target * 1000) + devip->lun);\n\t\ttarget_dev_id = ((host_no + 1) * 2000) +\n\t\t\t\t (devip->target * 1000) - 3;\n\t\tlen = scnprintf(lu_id_str, 6, \"%d\", lu_id_num);\n\t\tif (0 == cmd[2]) {  \n\t\t\tarr[1] = cmd[2];\t \n\t\t\tn = 4;\n\t\t\tarr[n++] = 0x0;    \n\t\t\tarr[n++] = 0x80;   \n\t\t\tarr[n++] = 0x83;   \n\t\t\tarr[n++] = 0x84;   \n\t\t\tarr[n++] = 0x85;   \n\t\t\tarr[n++] = 0x86;   \n\t\t\tarr[n++] = 0x87;   \n\t\t\tarr[n++] = 0x88;   \n\t\t\tif (is_disk_zbc) {\t   \n\t\t\t\tarr[n++] = 0x89;   \n\t\t\t\tarr[n++] = 0xb0;   \n\t\t\t\tarr[n++] = 0xb1;   \n\t\t\t\tif (is_disk)\n\t\t\t\t\tarr[n++] = 0xb2;   \n\t\t\t\tif (is_zbc)\n\t\t\t\t\tarr[n++] = 0xb6;   \n\t\t\t}\n\t\t\tarr[3] = n - 4;\t   \n\t\t} else if (0x80 == cmd[2]) {  \n\t\t\tarr[1] = cmd[2];\t \n\t\t\tarr[3] = len;\n\t\t\tmemcpy(&arr[4], lu_id_str, len);\n\t\t} else if (0x83 == cmd[2]) {  \n\t\t\tarr[1] = cmd[2];\t \n\t\t\tarr[3] = inquiry_vpd_83(&arr[4], port_group_id,\n\t\t\t\t\t\ttarget_dev_id, lu_id_num,\n\t\t\t\t\t\tlu_id_str, len,\n\t\t\t\t\t\t&devip->lu_name);\n\t\t} else if (0x84 == cmd[2]) {  \n\t\t\tarr[1] = cmd[2];\t \n\t\t\tarr[3] = inquiry_vpd_84(&arr[4]);\n\t\t} else if (0x85 == cmd[2]) {  \n\t\t\tarr[1] = cmd[2];\t \n\t\t\tarr[3] = inquiry_vpd_85(&arr[4]);\n\t\t} else if (0x86 == cmd[2]) {  \n\t\t\tarr[1] = cmd[2];\t \n\t\t\tarr[3] = 0x3c;\t \n\t\t\tif (sdebug_dif == T10_PI_TYPE3_PROTECTION)\n\t\t\t\tarr[4] = 0x4;\t \n\t\t\telse if (have_dif_prot)\n\t\t\t\tarr[4] = 0x5;    \n\t\t\telse\n\t\t\t\tarr[4] = 0x0;    \n\t\t\tarr[5] = 0x7;    \n\t\t} else if (0x87 == cmd[2]) {  \n\t\t\tarr[1] = cmd[2];\t \n\t\t\tarr[3] = 0x8;\t \n\t\t\tarr[4] = 0x2;\t \n\t\t\tarr[6] = 0x80;\t \n\t\t\tarr[8] = 0x18;\t  \n\t\t\tarr[10] = 0x82;\t  \n\t\t} else if (0x88 == cmd[2]) {  \n\t\t\tarr[1] = cmd[2];\t \n\t\t\tarr[3] = inquiry_vpd_88(&arr[4], target_dev_id);\n\t\t} else if (is_disk_zbc && 0x89 == cmd[2]) {  \n\t\t\tarr[1] = cmd[2];         \n\t\t\tn = inquiry_vpd_89(&arr[4]);\n\t\t\tput_unaligned_be16(n, arr + 2);\n\t\t} else if (is_disk_zbc && 0xb0 == cmd[2]) {  \n\t\t\tarr[1] = cmd[2];         \n\t\t\tarr[3] = inquiry_vpd_b0(&arr[4]);\n\t\t} else if (is_disk_zbc && 0xb1 == cmd[2]) {  \n\t\t\tarr[1] = cmd[2];         \n\t\t\tarr[3] = inquiry_vpd_b1(devip, &arr[4]);\n\t\t} else if (is_disk && 0xb2 == cmd[2]) {  \n\t\t\tarr[1] = cmd[2];         \n\t\t\tarr[3] = inquiry_vpd_b2(&arr[4]);\n\t\t} else if (is_zbc && cmd[2] == 0xb6) {  \n\t\t\tarr[1] = cmd[2];         \n\t\t\tarr[3] = inquiry_vpd_b6(devip, &arr[4]);\n\t\t} else {\n\t\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 2, -1);\n\t\t\tkfree(arr);\n\t\t\treturn check_condition_result;\n\t\t}\n\t\tlen = min_t(u32, get_unaligned_be16(arr + 2) + 4, alloc_len);\n\t\tret = fill_from_dev_buffer(scp, arr,\n\t\t\t    min_t(u32, len, SDEBUG_MAX_INQ_ARR_SZ));\n\t\tkfree(arr);\n\t\treturn ret;\n\t}\n\t \n\tarr[1] = sdebug_removable ? 0x80 : 0;\t \n\tarr[2] = sdebug_scsi_level;\n\tarr[3] = 2;     \n\tarr[4] = SDEBUG_LONG_INQ_SZ - 5;\n\tarr[5] = (int)have_dif_prot;\t \n\tif (sdebug_vpd_use_hostno == 0)\n\t\tarr[5] |= 0x10;  \n\tarr[6] = 0x10;  \n\t \n\tarr[7] = 0xa;  \n\tmemcpy(&arr[8], sdebug_inq_vendor_id, 8);\n\tmemcpy(&arr[16], sdebug_inq_product_id, 16);\n\tmemcpy(&arr[32], sdebug_inq_product_rev, 4);\n\t \n\tmemcpy(&arr[36], sdebug_version_date, 8);\n\t \n\tput_unaligned_be16(0xc0, arr + 58);    \n\tput_unaligned_be16(0x5c0, arr + 60);   \n\tn = 62;\n\tif (is_disk) {\t\t \n\t\tput_unaligned_be16(0x600, arr + n);\n\t\tn += 2;\n\t} else if (sdebug_ptype == TYPE_TAPE) {\t \n\t\tput_unaligned_be16(0x525, arr + n);\n\t\tn += 2;\n\t} else if (is_zbc) {\t \n\t\tput_unaligned_be16(0x624, arr + n);\n\t\tn += 2;\n\t}\n\tput_unaligned_be16(0x2100, arr + n);\t \n\tret = fill_from_dev_buffer(scp, arr,\n\t\t\t    min_t(u32, alloc_len, SDEBUG_LONG_INQ_SZ));\n\tkfree(arr);\n\treturn ret;\n}\n\n \nstatic unsigned char iec_m_pg[] = {0x1c, 0xa, 0x08, 0, 0, 0, 0, 0,\n\t\t\t\t   0, 0, 0x0, 0x0};\n\nstatic int resp_requests(struct scsi_cmnd *scp,\n\t\t\t struct sdebug_dev_info *devip)\n{\n\tunsigned char *cmd = scp->cmnd;\n\tunsigned char arr[SCSI_SENSE_BUFFERSIZE];\t \n\tbool dsense = !!(cmd[1] & 1);\n\tu32 alloc_len = cmd[4];\n\tu32 len = 18;\n\tint stopped_state = atomic_read(&devip->stopped);\n\n\tmemset(arr, 0, sizeof(arr));\n\tif (stopped_state > 0) {\t \n\t\tif (dsense) {\n\t\t\tarr[0] = 0x72;\n\t\t\tarr[1] = NOT_READY;\n\t\t\tarr[2] = LOGICAL_UNIT_NOT_READY;\n\t\t\tarr[3] = (stopped_state == 2) ? 0x1 : 0x2;\n\t\t\tlen = 8;\n\t\t} else {\n\t\t\tarr[0] = 0x70;\n\t\t\tarr[2] = NOT_READY;\t\t \n\t\t\tarr[7] = 0xa;\t\t\t \n\t\t\tarr[12] = LOGICAL_UNIT_NOT_READY;\n\t\t\tarr[13] = (stopped_state == 2) ? 0x1 : 0x2;\n\t\t}\n\t} else if ((iec_m_pg[2] & 0x4) && (6 == (iec_m_pg[3] & 0xf))) {\n\t\t \n\t\tif (dsense) {\n\t\t\tarr[0] = 0x72;\n\t\t\tarr[1] = 0x0;\t\t \n\t\t\tarr[2] = THRESHOLD_EXCEEDED;\n\t\t\tarr[3] = 0xff;\t\t \n\t\t\tlen = 8;\n\t\t} else {\n\t\t\tarr[0] = 0x70;\n\t\t\tarr[2] = 0x0;\t\t \n\t\t\tarr[7] = 0xa;   \t \n\t\t\tarr[12] = THRESHOLD_EXCEEDED;\n\t\t\tarr[13] = 0xff;\t\t \n\t\t}\n\t} else {\t \n\t\tif (dsense) {\n\t\t\tlen = 8;\n\t\t\tmemset(arr, 0, len);\n\t\t\tarr[0] = 0x72;\n\t\t} else {\n\t\t\tmemset(arr, 0, len);\n\t\t\tarr[0] = 0x70;\n\t\t\tarr[7] = 0xa;\n\t\t}\n\t}\n\treturn fill_from_dev_buffer(scp, arr, min_t(u32, len, alloc_len));\n}\n\nstatic int resp_start_stop(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\n{\n\tunsigned char *cmd = scp->cmnd;\n\tint power_cond, want_stop, stopped_state;\n\tbool changing;\n\n\tpower_cond = (cmd[4] & 0xf0) >> 4;\n\tif (power_cond) {\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 4, 7);\n\t\treturn check_condition_result;\n\t}\n\twant_stop = !(cmd[4] & 1);\n\tstopped_state = atomic_read(&devip->stopped);\n\tif (stopped_state == 2) {\n\t\tktime_t now_ts = ktime_get_boottime();\n\n\t\tif (ktime_to_ns(now_ts) > ktime_to_ns(devip->create_ts)) {\n\t\t\tu64 diff_ns = ktime_to_ns(ktime_sub(now_ts, devip->create_ts));\n\n\t\t\tif (diff_ns >= ((u64)sdeb_tur_ms_to_ready * 1000000)) {\n\t\t\t\t \n\t\t\t\tatomic_set(&devip->stopped, 0);\n\t\t\t\tstopped_state = 0;\n\t\t\t}\n\t\t}\n\t\tif (stopped_state == 2) {\n\t\t\tif (want_stop) {\n\t\t\t\tstopped_state = 1;\t \n\t\t\t} else {\t \n\t\t\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 4, 0  );\n\t\t\t\treturn check_condition_result;\n\t\t\t}\n\t\t}\n\t}\n\tchanging = (stopped_state != want_stop);\n\tif (changing)\n\t\tatomic_xchg(&devip->stopped, want_stop);\n\tif (!changing || (cmd[1] & 0x1))   \n\t\treturn SDEG_RES_IMMED_MASK;\n\telse\n\t\treturn 0;\n}\n\nstatic sector_t get_sdebug_capacity(void)\n{\n\tstatic const unsigned int gibibyte = 1073741824;\n\n\tif (sdebug_virtual_gb > 0)\n\t\treturn (sector_t)sdebug_virtual_gb *\n\t\t\t(gibibyte / sdebug_sector_size);\n\telse\n\t\treturn sdebug_store_sectors;\n}\n\n#define SDEBUG_READCAP_ARR_SZ 8\nstatic int resp_readcap(struct scsi_cmnd *scp,\n\t\t\tstruct sdebug_dev_info *devip)\n{\n\tunsigned char arr[SDEBUG_READCAP_ARR_SZ];\n\tunsigned int capac;\n\n\t \n\tsdebug_capacity = get_sdebug_capacity();\n\tmemset(arr, 0, SDEBUG_READCAP_ARR_SZ);\n\tif (sdebug_capacity < 0xffffffff) {\n\t\tcapac = (unsigned int)sdebug_capacity - 1;\n\t\tput_unaligned_be32(capac, arr + 0);\n\t} else\n\t\tput_unaligned_be32(0xffffffff, arr + 0);\n\tput_unaligned_be16(sdebug_sector_size, arr + 6);\n\treturn fill_from_dev_buffer(scp, arr, SDEBUG_READCAP_ARR_SZ);\n}\n\n#define SDEBUG_READCAP16_ARR_SZ 32\nstatic int resp_readcap16(struct scsi_cmnd *scp,\n\t\t\t  struct sdebug_dev_info *devip)\n{\n\tunsigned char *cmd = scp->cmnd;\n\tunsigned char arr[SDEBUG_READCAP16_ARR_SZ];\n\tu32 alloc_len;\n\n\talloc_len = get_unaligned_be32(cmd + 10);\n\t \n\tsdebug_capacity = get_sdebug_capacity();\n\tmemset(arr, 0, SDEBUG_READCAP16_ARR_SZ);\n\tput_unaligned_be64((u64)(sdebug_capacity - 1), arr + 0);\n\tput_unaligned_be32(sdebug_sector_size, arr + 8);\n\tarr[13] = sdebug_physblk_exp & 0xf;\n\tarr[14] = (sdebug_lowest_aligned >> 8) & 0x3f;\n\n\tif (scsi_debug_lbp()) {\n\t\tarr[14] |= 0x80;  \n\t\t \n\t\tif (sdebug_lbprz & 1)\t \n\t\t\tarr[14] |= 0x40;\n\t}\n\n\t \n\tif (devip->zmodel == BLK_ZONED_HM)\n\t\tarr[12] |= 1 << 4;\n\n\tarr[15] = sdebug_lowest_aligned & 0xff;\n\n\tif (have_dif_prot) {\n\t\tarr[12] = (sdebug_dif - 1) << 1;  \n\t\tarr[12] |= 1;  \n\t}\n\n\treturn fill_from_dev_buffer(scp, arr,\n\t\t\t    min_t(u32, alloc_len, SDEBUG_READCAP16_ARR_SZ));\n}\n\n#define SDEBUG_MAX_TGTPGS_ARR_SZ 1412\n\nstatic int resp_report_tgtpgs(struct scsi_cmnd *scp,\n\t\t\t      struct sdebug_dev_info *devip)\n{\n\tunsigned char *cmd = scp->cmnd;\n\tunsigned char *arr;\n\tint host_no = devip->sdbg_host->shost->host_no;\n\tint port_group_a, port_group_b, port_a, port_b;\n\tu32 alen, n, rlen;\n\tint ret;\n\n\talen = get_unaligned_be32(cmd + 6);\n\tarr = kzalloc(SDEBUG_MAX_TGTPGS_ARR_SZ, GFP_ATOMIC);\n\tif (! arr)\n\t\treturn DID_REQUEUE << 16;\n\t \n\tport_a = 0x1;  \n\tport_b = 0x2;  \n\tport_group_a = (((host_no + 1) & 0x7f) << 8) +\n\t\t\t(devip->channel & 0x7f);\n\tport_group_b = (((host_no + 1) & 0x7f) << 8) +\n\t\t\t(devip->channel & 0x7f) + 0x80;\n\n\t \n\tn = 4;\n\tif (sdebug_vpd_use_hostno == 0) {\n\t\tarr[n++] = host_no % 3;  \n\t\tarr[n++] = 0x0F;  \n\t} else {\n\t\tarr[n++] = 0x0;  \n\t\tarr[n++] = 0x01;  \n\t}\n\tput_unaligned_be16(port_group_a, arr + n);\n\tn += 2;\n\tarr[n++] = 0;     \n\tarr[n++] = 0;     \n\tarr[n++] = 0;     \n\tarr[n++] = 0x1;   \n\tarr[n++] = 0;     \n\tarr[n++] = 0;     \n\tput_unaligned_be16(port_a, arr + n);\n\tn += 2;\n\tarr[n++] = 3;     \n\tarr[n++] = 0x08;  \n\tput_unaligned_be16(port_group_b, arr + n);\n\tn += 2;\n\tarr[n++] = 0;     \n\tarr[n++] = 0;     \n\tarr[n++] = 0;     \n\tarr[n++] = 0x1;   \n\tarr[n++] = 0;     \n\tarr[n++] = 0;     \n\tput_unaligned_be16(port_b, arr + n);\n\tn += 2;\n\n\trlen = n - 4;\n\tput_unaligned_be32(rlen, arr + 0);\n\n\t \n\trlen = min(alen, n);\n\tret = fill_from_dev_buffer(scp, arr,\n\t\t\t   min_t(u32, rlen, SDEBUG_MAX_TGTPGS_ARR_SZ));\n\tkfree(arr);\n\treturn ret;\n}\n\nstatic int resp_rsup_opcodes(struct scsi_cmnd *scp,\n\t\t\t     struct sdebug_dev_info *devip)\n{\n\tbool rctd;\n\tu8 reporting_opts, req_opcode, sdeb_i, supp;\n\tu16 req_sa, u;\n\tu32 alloc_len, a_len;\n\tint k, offset, len, errsts, count, bump, na;\n\tconst struct opcode_info_t *oip;\n\tconst struct opcode_info_t *r_oip;\n\tu8 *arr;\n\tu8 *cmd = scp->cmnd;\n\n\trctd = !!(cmd[2] & 0x80);\n\treporting_opts = cmd[2] & 0x7;\n\treq_opcode = cmd[3];\n\treq_sa = get_unaligned_be16(cmd + 4);\n\talloc_len = get_unaligned_be32(cmd + 6);\n\tif (alloc_len < 4 || alloc_len > 0xffff) {\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 6, -1);\n\t\treturn check_condition_result;\n\t}\n\tif (alloc_len > 8192)\n\t\ta_len = 8192;\n\telse\n\t\ta_len = alloc_len;\n\tarr = kzalloc((a_len < 256) ? 320 : a_len + 64, GFP_ATOMIC);\n\tif (NULL == arr) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INSUFF_RES_ASC,\n\t\t\t\tINSUFF_RES_ASCQ);\n\t\treturn check_condition_result;\n\t}\n\tswitch (reporting_opts) {\n\tcase 0:\t \n\t\t \n\t\tfor (count = 0, oip = opcode_info_arr;\n\t\t     oip->num_attached != 0xff; ++oip) {\n\t\t\tif (F_INV_OP & oip->flags)\n\t\t\t\tcontinue;\n\t\t\tcount += (oip->num_attached + 1);\n\t\t}\n\t\tbump = rctd ? 20 : 8;\n\t\tput_unaligned_be32(count * bump, arr);\n\t\tfor (offset = 4, oip = opcode_info_arr;\n\t\t     oip->num_attached != 0xff && offset < a_len; ++oip) {\n\t\t\tif (F_INV_OP & oip->flags)\n\t\t\t\tcontinue;\n\t\t\tna = oip->num_attached;\n\t\t\tarr[offset] = oip->opcode;\n\t\t\tput_unaligned_be16(oip->sa, arr + offset + 2);\n\t\t\tif (rctd)\n\t\t\t\tarr[offset + 5] |= 0x2;\n\t\t\tif (FF_SA & oip->flags)\n\t\t\t\tarr[offset + 5] |= 0x1;\n\t\t\tput_unaligned_be16(oip->len_mask[0], arr + offset + 6);\n\t\t\tif (rctd)\n\t\t\t\tput_unaligned_be16(0xa, arr + offset + 8);\n\t\t\tr_oip = oip;\n\t\t\tfor (k = 0, oip = oip->arrp; k < na; ++k, ++oip) {\n\t\t\t\tif (F_INV_OP & oip->flags)\n\t\t\t\t\tcontinue;\n\t\t\t\toffset += bump;\n\t\t\t\tarr[offset] = oip->opcode;\n\t\t\t\tput_unaligned_be16(oip->sa, arr + offset + 2);\n\t\t\t\tif (rctd)\n\t\t\t\t\tarr[offset + 5] |= 0x2;\n\t\t\t\tif (FF_SA & oip->flags)\n\t\t\t\t\tarr[offset + 5] |= 0x1;\n\t\t\t\tput_unaligned_be16(oip->len_mask[0],\n\t\t\t\t\t\t   arr + offset + 6);\n\t\t\t\tif (rctd)\n\t\t\t\t\tput_unaligned_be16(0xa,\n\t\t\t\t\t\t\t   arr + offset + 8);\n\t\t\t}\n\t\t\toip = r_oip;\n\t\t\toffset += bump;\n\t\t}\n\t\tbreak;\n\tcase 1:\t \n\tcase 2:\t \n\tcase 3:\t \n\t\tsdeb_i = opcode_ind_arr[req_opcode];\n\t\toip = &opcode_info_arr[sdeb_i];\n\t\tif (F_INV_OP & oip->flags) {\n\t\t\tsupp = 1;\n\t\t\toffset = 4;\n\t\t} else {\n\t\t\tif (1 == reporting_opts) {\n\t\t\t\tif (FF_SA & oip->flags) {\n\t\t\t\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB,\n\t\t\t\t\t\t\t     2, 2);\n\t\t\t\t\tkfree(arr);\n\t\t\t\t\treturn check_condition_result;\n\t\t\t\t}\n\t\t\t\treq_sa = 0;\n\t\t\t} else if (2 == reporting_opts &&\n\t\t\t\t   0 == (FF_SA & oip->flags)) {\n\t\t\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 4, -1);\n\t\t\t\tkfree(arr);\t \n\t\t\t\treturn check_condition_result;\n\t\t\t}\n\t\t\tif (0 == (FF_SA & oip->flags) &&\n\t\t\t    req_opcode == oip->opcode)\n\t\t\t\tsupp = 3;\n\t\t\telse if (0 == (FF_SA & oip->flags)) {\n\t\t\t\tna = oip->num_attached;\n\t\t\t\tfor (k = 0, oip = oip->arrp; k < na;\n\t\t\t\t     ++k, ++oip) {\n\t\t\t\t\tif (req_opcode == oip->opcode)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsupp = (k >= na) ? 1 : 3;\n\t\t\t} else if (req_sa != oip->sa) {\n\t\t\t\tna = oip->num_attached;\n\t\t\t\tfor (k = 0, oip = oip->arrp; k < na;\n\t\t\t\t     ++k, ++oip) {\n\t\t\t\t\tif (req_sa == oip->sa)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsupp = (k >= na) ? 1 : 3;\n\t\t\t} else\n\t\t\t\tsupp = 3;\n\t\t\tif (3 == supp) {\n\t\t\t\tu = oip->len_mask[0];\n\t\t\t\tput_unaligned_be16(u, arr + 2);\n\t\t\t\tarr[4] = oip->opcode;\n\t\t\t\tfor (k = 1; k < u; ++k)\n\t\t\t\t\tarr[4 + k] = (k < 16) ?\n\t\t\t\t\t\t oip->len_mask[k] : 0xff;\n\t\t\t\toffset = 4 + u;\n\t\t\t} else\n\t\t\t\toffset = 4;\n\t\t}\n\t\tarr[1] = (rctd ? 0x80 : 0) | supp;\n\t\tif (rctd) {\n\t\t\tput_unaligned_be16(0xa, arr + offset);\n\t\t\toffset += 12;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 2, 2);\n\t\tkfree(arr);\n\t\treturn check_condition_result;\n\t}\n\toffset = (offset < a_len) ? offset : a_len;\n\tlen = (offset < alloc_len) ? offset : alloc_len;\n\terrsts = fill_from_dev_buffer(scp, arr, len);\n\tkfree(arr);\n\treturn errsts;\n}\n\nstatic int resp_rsup_tmfs(struct scsi_cmnd *scp,\n\t\t\t  struct sdebug_dev_info *devip)\n{\n\tbool repd;\n\tu32 alloc_len, len;\n\tu8 arr[16];\n\tu8 *cmd = scp->cmnd;\n\n\tmemset(arr, 0, sizeof(arr));\n\trepd = !!(cmd[2] & 0x80);\n\talloc_len = get_unaligned_be32(cmd + 6);\n\tif (alloc_len < 4) {\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 6, -1);\n\t\treturn check_condition_result;\n\t}\n\tarr[0] = 0xc8;\t\t \n\tarr[1] = 0x1;\t\t \n\tif (repd) {\n\t\tarr[3] = 0xc;\n\t\tlen = 16;\n\t} else\n\t\tlen = 4;\n\n\tlen = (len < alloc_len) ? len : alloc_len;\n\treturn fill_from_dev_buffer(scp, arr, len);\n}\n\n \n\nstatic int resp_err_recov_pg(unsigned char *p, int pcontrol, int target)\n{\t \n\tunsigned char err_recov_pg[] = {0x1, 0xa, 0xc0, 11, 240, 0, 0, 0,\n\t\t\t\t\t5, 0, 0xff, 0xff};\n\n\tmemcpy(p, err_recov_pg, sizeof(err_recov_pg));\n\tif (1 == pcontrol)\n\t\tmemset(p + 2, 0, sizeof(err_recov_pg) - 2);\n\treturn sizeof(err_recov_pg);\n}\n\nstatic int resp_disconnect_pg(unsigned char *p, int pcontrol, int target)\n{ \t \n\tunsigned char disconnect_pg[] = {0x2, 0xe, 128, 128, 0, 10, 0, 0,\n\t\t\t\t\t 0, 0, 0, 0, 0, 0, 0, 0};\n\n\tmemcpy(p, disconnect_pg, sizeof(disconnect_pg));\n\tif (1 == pcontrol)\n\t\tmemset(p + 2, 0, sizeof(disconnect_pg) - 2);\n\treturn sizeof(disconnect_pg);\n}\n\nstatic int resp_format_pg(unsigned char *p, int pcontrol, int target)\n{        \n\tunsigned char format_pg[] = {0x3, 0x16, 0, 0, 0, 0, 0, 0,\n\t\t\t\t     0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t\t     0, 0, 0, 0, 0x40, 0, 0, 0};\n\n\tmemcpy(p, format_pg, sizeof(format_pg));\n\tput_unaligned_be16(sdebug_sectors_per, p + 10);\n\tput_unaligned_be16(sdebug_sector_size, p + 12);\n\tif (sdebug_removable)\n\t\tp[20] |= 0x20;  \n\tif (1 == pcontrol)\n\t\tmemset(p + 2, 0, sizeof(format_pg) - 2);\n\treturn sizeof(format_pg);\n}\n\nstatic unsigned char caching_pg[] = {0x8, 18, 0x14, 0, 0xff, 0xff, 0, 0,\n\t\t\t\t     0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0, 0,\n\t\t\t\t     0, 0, 0, 0};\n\nstatic int resp_caching_pg(unsigned char *p, int pcontrol, int target)\n{ \t \n\tunsigned char ch_caching_pg[] = {  0x4, 0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\tunsigned char d_caching_pg[] = {0x8, 18, 0x14, 0, 0xff, 0xff, 0, 0,\n\t\t0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0, 0,     0, 0, 0, 0};\n\n\tif (SDEBUG_OPT_N_WCE & sdebug_opts)\n\t\tcaching_pg[2] &= ~0x4;\t \n\tmemcpy(p, caching_pg, sizeof(caching_pg));\n\tif (1 == pcontrol)\n\t\tmemcpy(p + 2, ch_caching_pg, sizeof(ch_caching_pg));\n\telse if (2 == pcontrol)\n\t\tmemcpy(p, d_caching_pg, sizeof(d_caching_pg));\n\treturn sizeof(caching_pg);\n}\n\nstatic unsigned char ctrl_m_pg[] = {0xa, 10, 2, 0, 0, 0, 0, 0,\n\t\t\t\t    0, 0, 0x2, 0x4b};\n\nstatic int resp_ctrl_m_pg(unsigned char *p, int pcontrol, int target)\n{ \t \n\tunsigned char ch_ctrl_m_pg[] = {  0x6, 0, 0, 0, 0, 0,\n\t\t\t\t\t0, 0, 0, 0};\n\tunsigned char d_ctrl_m_pg[] = {0xa, 10, 2, 0, 0, 0, 0, 0,\n\t\t\t\t     0, 0, 0x2, 0x4b};\n\n\tif (sdebug_dsense)\n\t\tctrl_m_pg[2] |= 0x4;\n\telse\n\t\tctrl_m_pg[2] &= ~0x4;\n\n\tif (sdebug_ato)\n\t\tctrl_m_pg[5] |= 0x80;  \n\n\tmemcpy(p, ctrl_m_pg, sizeof(ctrl_m_pg));\n\tif (1 == pcontrol)\n\t\tmemcpy(p + 2, ch_ctrl_m_pg, sizeof(ch_ctrl_m_pg));\n\telse if (2 == pcontrol)\n\t\tmemcpy(p, d_ctrl_m_pg, sizeof(d_ctrl_m_pg));\n\treturn sizeof(ctrl_m_pg);\n}\n\n\nstatic int resp_iec_m_pg(unsigned char *p, int pcontrol, int target)\n{\t \n\tunsigned char ch_iec_m_pg[] = {  0x4, 0xf, 0, 0, 0, 0,\n\t\t\t\t       0, 0, 0x0, 0x0};\n\tunsigned char d_iec_m_pg[] = {0x1c, 0xa, 0x08, 0, 0, 0, 0, 0,\n\t\t\t\t      0, 0, 0x0, 0x0};\n\n\tmemcpy(p, iec_m_pg, sizeof(iec_m_pg));\n\tif (1 == pcontrol)\n\t\tmemcpy(p + 2, ch_iec_m_pg, sizeof(ch_iec_m_pg));\n\telse if (2 == pcontrol)\n\t\tmemcpy(p, d_iec_m_pg, sizeof(d_iec_m_pg));\n\treturn sizeof(iec_m_pg);\n}\n\nstatic int resp_sas_sf_m_pg(unsigned char *p, int pcontrol, int target)\n{\t \n\tunsigned char sas_sf_m_pg[] = {0x19, 0x6,\n\t\t0x6, 0x0, 0x7, 0xd0, 0x0, 0x0};\n\n\tmemcpy(p, sas_sf_m_pg, sizeof(sas_sf_m_pg));\n\tif (1 == pcontrol)\n\t\tmemset(p + 2, 0, sizeof(sas_sf_m_pg) - 2);\n\treturn sizeof(sas_sf_m_pg);\n}\n\n\nstatic int resp_sas_pcd_m_spg(unsigned char *p, int pcontrol, int target,\n\t\t\t      int target_dev_id)\n{\t \n\tunsigned char sas_pcd_m_pg[] = {0x59, 0x1, 0, 0x64, 0, 0x6, 0, 2,\n\t\t    0, 0, 0, 0, 0x10, 0x9, 0x8, 0x0,\n\t\t    0, 0, 0, 0, 0, 0, 0, 0,\t \n\t\t    0, 0, 0, 0, 0, 0, 0, 0,\t \n\t\t    0x2, 0, 0, 0, 0, 0, 0, 0,\n\t\t    0x88, 0x99, 0, 0, 0, 0, 0, 0,\n\t\t    0, 0, 0, 0, 0, 0, 0, 0,\n\t\t    0, 1, 0, 0, 0x10, 0x9, 0x8, 0x0,\n\t\t    0, 0, 0, 0, 0, 0, 0, 0,\t \n\t\t    0, 0, 0, 0, 0, 0, 0, 0,\t \n\t\t    0x3, 0, 0, 0, 0, 0, 0, 0,\n\t\t    0x88, 0x99, 0, 0, 0, 0, 0, 0,\n\t\t    0, 0, 0, 0, 0, 0, 0, 0,\n\t\t};\n\tint port_a, port_b;\n\n\tput_unaligned_be64(naa3_comp_a, sas_pcd_m_pg + 16);\n\tput_unaligned_be64(naa3_comp_c + 1, sas_pcd_m_pg + 24);\n\tput_unaligned_be64(naa3_comp_a, sas_pcd_m_pg + 64);\n\tput_unaligned_be64(naa3_comp_c + 1, sas_pcd_m_pg + 72);\n\tport_a = target_dev_id + 1;\n\tport_b = port_a + 1;\n\tmemcpy(p, sas_pcd_m_pg, sizeof(sas_pcd_m_pg));\n\tput_unaligned_be32(port_a, p + 20);\n\tput_unaligned_be32(port_b, p + 48 + 20);\n\tif (1 == pcontrol)\n\t\tmemset(p + 4, 0, sizeof(sas_pcd_m_pg) - 4);\n\treturn sizeof(sas_pcd_m_pg);\n}\n\nstatic int resp_sas_sha_m_spg(unsigned char *p, int pcontrol)\n{\t \n\tunsigned char sas_sha_m_pg[] = {0x59, 0x2, 0, 0xc, 0, 0x6, 0x10, 0,\n\t\t    0, 0, 0, 0, 0, 0, 0, 0,\n\t\t};\n\n\tmemcpy(p, sas_sha_m_pg, sizeof(sas_sha_m_pg));\n\tif (1 == pcontrol)\n\t\tmemset(p + 4, 0, sizeof(sas_sha_m_pg) - 4);\n\treturn sizeof(sas_sha_m_pg);\n}\n\n#define SDEBUG_MAX_MSENSE_SZ 256\n\nstatic int resp_mode_sense(struct scsi_cmnd *scp,\n\t\t\t   struct sdebug_dev_info *devip)\n{\n\tint pcontrol, pcode, subpcode, bd_len;\n\tunsigned char dev_spec;\n\tu32 alloc_len, offset, len;\n\tint target_dev_id;\n\tint target = scp->device->id;\n\tunsigned char *ap;\n\tunsigned char arr[SDEBUG_MAX_MSENSE_SZ];\n\tunsigned char *cmd = scp->cmnd;\n\tbool dbd, llbaa, msense_6, is_disk, is_zbc, bad_pcode;\n\n\tdbd = !!(cmd[1] & 0x8);\t\t \n\tpcontrol = (cmd[2] & 0xc0) >> 6;\n\tpcode = cmd[2] & 0x3f;\n\tsubpcode = cmd[3];\n\tmsense_6 = (MODE_SENSE == cmd[0]);\n\tllbaa = msense_6 ? false : !!(cmd[1] & 0x10);\n\tis_disk = (sdebug_ptype == TYPE_DISK);\n\tis_zbc = (devip->zmodel != BLK_ZONED_NONE);\n\tif ((is_disk || is_zbc) && !dbd)\n\t\tbd_len = llbaa ? 16 : 8;\n\telse\n\t\tbd_len = 0;\n\talloc_len = msense_6 ? cmd[4] : get_unaligned_be16(cmd + 7);\n\tmemset(arr, 0, SDEBUG_MAX_MSENSE_SZ);\n\tif (0x3 == pcontrol) {   \n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, SAVING_PARAMS_UNSUP, 0);\n\t\treturn check_condition_result;\n\t}\n\ttarget_dev_id = ((devip->sdbg_host->shost->host_no + 1) * 2000) +\n\t\t\t(devip->target * 1000) - 3;\n\t \n\tif (is_disk || is_zbc) {\n\t\tdev_spec = 0x10;\t \n\t\tif (sdebug_wp)\n\t\t\tdev_spec |= 0x80;\n\t} else\n\t\tdev_spec = 0x0;\n\tif (msense_6) {\n\t\tarr[2] = dev_spec;\n\t\tarr[3] = bd_len;\n\t\toffset = 4;\n\t} else {\n\t\tarr[3] = dev_spec;\n\t\tif (16 == bd_len)\n\t\t\tarr[4] = 0x1;\t \n\t\tarr[7] = bd_len;\t \n\t\toffset = 8;\n\t}\n\tap = arr + offset;\n\tif ((bd_len > 0) && (!sdebug_capacity))\n\t\tsdebug_capacity = get_sdebug_capacity();\n\n\tif (8 == bd_len) {\n\t\tif (sdebug_capacity > 0xfffffffe)\n\t\t\tput_unaligned_be32(0xffffffff, ap + 0);\n\t\telse\n\t\t\tput_unaligned_be32(sdebug_capacity, ap + 0);\n\t\tput_unaligned_be16(sdebug_sector_size, ap + 6);\n\t\toffset += bd_len;\n\t\tap = arr + offset;\n\t} else if (16 == bd_len) {\n\t\tput_unaligned_be64((u64)sdebug_capacity, ap + 0);\n\t\tput_unaligned_be32(sdebug_sector_size, ap + 12);\n\t\toffset += bd_len;\n\t\tap = arr + offset;\n\t}\n\n\tif ((subpcode > 0x0) && (subpcode < 0xff) && (0x19 != pcode)) {\n\t\t \n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 3, -1);\n\t\treturn check_condition_result;\n\t}\n\tbad_pcode = false;\n\n\tswitch (pcode) {\n\tcase 0x1:\t \n\t\tlen = resp_err_recov_pg(ap, pcontrol, target);\n\t\toffset += len;\n\t\tbreak;\n\tcase 0x2:\t \n\t\tlen = resp_disconnect_pg(ap, pcontrol, target);\n\t\toffset += len;\n\t\tbreak;\n\tcase 0x3:        \n\t\tif (is_disk) {\n\t\t\tlen = resp_format_pg(ap, pcontrol, target);\n\t\t\toffset += len;\n\t\t} else\n\t\t\tbad_pcode = true;\n\t\tbreak;\n\tcase 0x8:\t \n\t\tif (is_disk || is_zbc) {\n\t\t\tlen = resp_caching_pg(ap, pcontrol, target);\n\t\t\toffset += len;\n\t\t} else\n\t\t\tbad_pcode = true;\n\t\tbreak;\n\tcase 0xa:\t \n\t\tlen = resp_ctrl_m_pg(ap, pcontrol, target);\n\t\toffset += len;\n\t\tbreak;\n\tcase 0x19:\t \n\t\tif ((subpcode > 0x2) && (subpcode < 0xff)) {\n\t\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 3, -1);\n\t\t\treturn check_condition_result;\n\t\t}\n\t\tlen = 0;\n\t\tif ((0x0 == subpcode) || (0xff == subpcode))\n\t\t\tlen += resp_sas_sf_m_pg(ap + len, pcontrol, target);\n\t\tif ((0x1 == subpcode) || (0xff == subpcode))\n\t\t\tlen += resp_sas_pcd_m_spg(ap + len, pcontrol, target,\n\t\t\t\t\t\t  target_dev_id);\n\t\tif ((0x2 == subpcode) || (0xff == subpcode))\n\t\t\tlen += resp_sas_sha_m_spg(ap + len, pcontrol);\n\t\toffset += len;\n\t\tbreak;\n\tcase 0x1c:\t \n\t\tlen = resp_iec_m_pg(ap, pcontrol, target);\n\t\toffset += len;\n\t\tbreak;\n\tcase 0x3f:\t \n\t\tif ((0 == subpcode) || (0xff == subpcode)) {\n\t\t\tlen = resp_err_recov_pg(ap, pcontrol, target);\n\t\t\tlen += resp_disconnect_pg(ap + len, pcontrol, target);\n\t\t\tif (is_disk) {\n\t\t\t\tlen += resp_format_pg(ap + len, pcontrol,\n\t\t\t\t\t\t      target);\n\t\t\t\tlen += resp_caching_pg(ap + len, pcontrol,\n\t\t\t\t\t\t       target);\n\t\t\t} else if (is_zbc) {\n\t\t\t\tlen += resp_caching_pg(ap + len, pcontrol,\n\t\t\t\t\t\t       target);\n\t\t\t}\n\t\t\tlen += resp_ctrl_m_pg(ap + len, pcontrol, target);\n\t\t\tlen += resp_sas_sf_m_pg(ap + len, pcontrol, target);\n\t\t\tif (0xff == subpcode) {\n\t\t\t\tlen += resp_sas_pcd_m_spg(ap + len, pcontrol,\n\t\t\t\t\t\t  target, target_dev_id);\n\t\t\t\tlen += resp_sas_sha_m_spg(ap + len, pcontrol);\n\t\t\t}\n\t\t\tlen += resp_iec_m_pg(ap + len, pcontrol, target);\n\t\t\toffset += len;\n\t\t} else {\n\t\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 3, -1);\n\t\t\treturn check_condition_result;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbad_pcode = true;\n\t\tbreak;\n\t}\n\tif (bad_pcode) {\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 2, 5);\n\t\treturn check_condition_result;\n\t}\n\tif (msense_6)\n\t\tarr[0] = offset - 1;\n\telse\n\t\tput_unaligned_be16((offset - 2), arr + 0);\n\treturn fill_from_dev_buffer(scp, arr, min_t(u32, alloc_len, offset));\n}\n\n#define SDEBUG_MAX_MSELECT_SZ 512\n\nstatic int resp_mode_select(struct scsi_cmnd *scp,\n\t\t\t    struct sdebug_dev_info *devip)\n{\n\tint pf, sp, ps, md_len, bd_len, off, spf, pg_len;\n\tint param_len, res, mpage;\n\tunsigned char arr[SDEBUG_MAX_MSELECT_SZ];\n\tunsigned char *cmd = scp->cmnd;\n\tint mselect6 = (MODE_SELECT == cmd[0]);\n\n\tmemset(arr, 0, sizeof(arr));\n\tpf = cmd[1] & 0x10;\n\tsp = cmd[1] & 0x1;\n\tparam_len = mselect6 ? cmd[4] : get_unaligned_be16(cmd + 7);\n\tif ((0 == pf) || sp || (param_len > SDEBUG_MAX_MSELECT_SZ)) {\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, mselect6 ? 4 : 7, -1);\n\t\treturn check_condition_result;\n\t}\n\tres = fetch_to_dev_buffer(scp, arr, param_len);\n\tif (-1 == res)\n\t\treturn DID_ERROR << 16;\n\telse if (sdebug_verbose && (res < param_len))\n\t\tsdev_printk(KERN_INFO, scp->device,\n\t\t\t    \"%s: cdb indicated=%d, IO sent=%d bytes\\n\",\n\t\t\t    __func__, param_len, res);\n\tmd_len = mselect6 ? (arr[0] + 1) : (get_unaligned_be16(arr + 0) + 2);\n\tbd_len = mselect6 ? arr[3] : get_unaligned_be16(arr + 6);\n\toff = bd_len + (mselect6 ? 4 : 8);\n\tif (md_len > 2 || off >= res) {\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_DATA, 0, -1);\n\t\treturn check_condition_result;\n\t}\n\tmpage = arr[off] & 0x3f;\n\tps = !!(arr[off] & 0x80);\n\tif (ps) {\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_DATA, off, 7);\n\t\treturn check_condition_result;\n\t}\n\tspf = !!(arr[off] & 0x40);\n\tpg_len = spf ? (get_unaligned_be16(arr + off + 2) + 4) :\n\t\t       (arr[off + 1] + 2);\n\tif ((pg_len + off) > param_len) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST,\n\t\t\t\tPARAMETER_LIST_LENGTH_ERR, 0);\n\t\treturn check_condition_result;\n\t}\n\tswitch (mpage) {\n\tcase 0x8:       \n\t\tif (caching_pg[1] == arr[off + 1]) {\n\t\t\tmemcpy(caching_pg + 2, arr + off + 2,\n\t\t\t       sizeof(caching_pg) - 2);\n\t\t\tgoto set_mode_changed_ua;\n\t\t}\n\t\tbreak;\n\tcase 0xa:       \n\t\tif (ctrl_m_pg[1] == arr[off + 1]) {\n\t\t\tmemcpy(ctrl_m_pg + 2, arr + off + 2,\n\t\t\t       sizeof(ctrl_m_pg) - 2);\n\t\t\tif (ctrl_m_pg[4] & 0x8)\n\t\t\t\tsdebug_wp = true;\n\t\t\telse\n\t\t\t\tsdebug_wp = false;\n\t\t\tsdebug_dsense = !!(ctrl_m_pg[2] & 0x4);\n\t\t\tgoto set_mode_changed_ua;\n\t\t}\n\t\tbreak;\n\tcase 0x1c:       \n\t\tif (iec_m_pg[1] == arr[off + 1]) {\n\t\t\tmemcpy(iec_m_pg + 2, arr + off + 2,\n\t\t\t       sizeof(iec_m_pg) - 2);\n\t\t\tgoto set_mode_changed_ua;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmk_sense_invalid_fld(scp, SDEB_IN_DATA, off, 5);\n\treturn check_condition_result;\nset_mode_changed_ua:\n\tset_bit(SDEBUG_UA_MODE_CHANGED, devip->uas_bm);\n\treturn 0;\n}\n\nstatic int resp_temp_l_pg(unsigned char *arr)\n{\n\tunsigned char temp_l_pg[] = {0x0, 0x0, 0x3, 0x2, 0x0, 38,\n\t\t\t\t     0x0, 0x1, 0x3, 0x2, 0x0, 65,\n\t\t};\n\n\tmemcpy(arr, temp_l_pg, sizeof(temp_l_pg));\n\treturn sizeof(temp_l_pg);\n}\n\nstatic int resp_ie_l_pg(unsigned char *arr)\n{\n\tunsigned char ie_l_pg[] = {0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 38,\n\t\t};\n\n\tmemcpy(arr, ie_l_pg, sizeof(ie_l_pg));\n\tif (iec_m_pg[2] & 0x4) {\t \n\t\tarr[4] = THRESHOLD_EXCEEDED;\n\t\tarr[5] = 0xff;\n\t}\n\treturn sizeof(ie_l_pg);\n}\n\nstatic int resp_env_rep_l_spg(unsigned char *arr)\n{\n\tunsigned char env_rep_l_spg[] = {0x0, 0x0, 0x23, 0x8,\n\t\t\t\t\t 0x0, 40, 72, 0xff, 45, 18, 0, 0,\n\t\t\t\t\t 0x1, 0x0, 0x23, 0x8,\n\t\t\t\t\t 0x0, 55, 72, 35, 55, 45, 0, 0,\n\t\t};\n\n\tmemcpy(arr, env_rep_l_spg, sizeof(env_rep_l_spg));\n\treturn sizeof(env_rep_l_spg);\n}\n\n#define SDEBUG_MAX_LSENSE_SZ 512\n\nstatic int resp_log_sense(struct scsi_cmnd *scp,\n\t\t\t  struct sdebug_dev_info *devip)\n{\n\tint ppc, sp, pcode, subpcode;\n\tu32 alloc_len, len, n;\n\tunsigned char arr[SDEBUG_MAX_LSENSE_SZ];\n\tunsigned char *cmd = scp->cmnd;\n\n\tmemset(arr, 0, sizeof(arr));\n\tppc = cmd[1] & 0x2;\n\tsp = cmd[1] & 0x1;\n\tif (ppc || sp) {\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 1, ppc ? 1 : 0);\n\t\treturn check_condition_result;\n\t}\n\tpcode = cmd[2] & 0x3f;\n\tsubpcode = cmd[3] & 0xff;\n\talloc_len = get_unaligned_be16(cmd + 7);\n\tarr[0] = pcode;\n\tif (0 == subpcode) {\n\t\tswitch (pcode) {\n\t\tcase 0x0:\t \n\t\t\tn = 4;\n\t\t\tarr[n++] = 0x0;\t\t \n\t\t\tarr[n++] = 0xd;\t\t \n\t\t\tarr[n++] = 0x2f;\t \n\t\t\tarr[3] = n - 4;\n\t\t\tbreak;\n\t\tcase 0xd:\t \n\t\t\tarr[3] = resp_temp_l_pg(arr + 4);\n\t\t\tbreak;\n\t\tcase 0x2f:\t \n\t\t\tarr[3] = resp_ie_l_pg(arr + 4);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 2, 5);\n\t\t\treturn check_condition_result;\n\t\t}\n\t} else if (0xff == subpcode) {\n\t\tarr[0] |= 0x40;\n\t\tarr[1] = subpcode;\n\t\tswitch (pcode) {\n\t\tcase 0x0:\t \n\t\t\tn = 4;\n\t\t\tarr[n++] = 0x0;\n\t\t\tarr[n++] = 0x0;\t\t \n\t\t\tarr[n++] = 0x0;\n\t\t\tarr[n++] = 0xff;\t \n\t\t\tarr[n++] = 0xd;\n\t\t\tarr[n++] = 0x0;\t\t \n\t\t\tarr[n++] = 0xd;\n\t\t\tarr[n++] = 0x1;\t\t \n\t\t\tarr[n++] = 0xd;\n\t\t\tarr[n++] = 0xff;\t \n\t\t\tarr[n++] = 0x2f;\n\t\t\tarr[n++] = 0x0;\t \n\t\t\tarr[n++] = 0x2f;\n\t\t\tarr[n++] = 0xff;\t \n\t\t\tarr[3] = n - 4;\n\t\t\tbreak;\n\t\tcase 0xd:\t \n\t\t\tn = 4;\n\t\t\tarr[n++] = 0xd;\n\t\t\tarr[n++] = 0x0;\t\t \n\t\t\tarr[n++] = 0xd;\n\t\t\tarr[n++] = 0x1;\t\t \n\t\t\tarr[n++] = 0xd;\n\t\t\tarr[n++] = 0xff;\t \n\t\t\tarr[3] = n - 4;\n\t\t\tbreak;\n\t\tcase 0x2f:\t \n\t\t\tn = 4;\n\t\t\tarr[n++] = 0x2f;\n\t\t\tarr[n++] = 0x0;\t\t \n\t\t\tarr[n++] = 0x2f;\n\t\t\tarr[n++] = 0xff;\t \n\t\t\tarr[3] = n - 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 2, 5);\n\t\t\treturn check_condition_result;\n\t\t}\n\t} else if (subpcode > 0) {\n\t\tarr[0] |= 0x40;\n\t\tarr[1] = subpcode;\n\t\tif (pcode == 0xd && subpcode == 1)\n\t\t\tarr[3] = resp_env_rep_l_spg(arr + 4);\n\t\telse {\n\t\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 2, 5);\n\t\t\treturn check_condition_result;\n\t\t}\n\t} else {\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 3, -1);\n\t\treturn check_condition_result;\n\t}\n\tlen = min_t(u32, get_unaligned_be16(arr + 2) + 4, alloc_len);\n\treturn fill_from_dev_buffer(scp, arr,\n\t\t    min_t(u32, len, SDEBUG_MAX_INQ_ARR_SZ));\n}\n\nstatic inline bool sdebug_dev_is_zoned(struct sdebug_dev_info *devip)\n{\n\treturn devip->nr_zones != 0;\n}\n\nstatic struct sdeb_zone_state *zbc_zone(struct sdebug_dev_info *devip,\n\t\t\t\t\tunsigned long long lba)\n{\n\tu32 zno = lba >> devip->zsize_shift;\n\tstruct sdeb_zone_state *zsp;\n\n\tif (devip->zcap == devip->zsize || zno < devip->nr_conv_zones)\n\t\treturn &devip->zstate[zno];\n\n\t \n\tzno = 2 * zno - devip->nr_conv_zones;\n\tWARN_ONCE(zno >= devip->nr_zones, \"%u > %u\\n\", zno, devip->nr_zones);\n\tzsp = &devip->zstate[zno];\n\tif (lba >= zsp->z_start + zsp->z_size)\n\t\tzsp++;\n\tWARN_ON_ONCE(lba >= zsp->z_start + zsp->z_size);\n\treturn zsp;\n}\n\nstatic inline bool zbc_zone_is_conv(struct sdeb_zone_state *zsp)\n{\n\treturn zsp->z_type == ZBC_ZTYPE_CNV;\n}\n\nstatic inline bool zbc_zone_is_gap(struct sdeb_zone_state *zsp)\n{\n\treturn zsp->z_type == ZBC_ZTYPE_GAP;\n}\n\nstatic inline bool zbc_zone_is_seq(struct sdeb_zone_state *zsp)\n{\n\treturn !zbc_zone_is_conv(zsp) && !zbc_zone_is_gap(zsp);\n}\n\nstatic void zbc_close_zone(struct sdebug_dev_info *devip,\n\t\t\t   struct sdeb_zone_state *zsp)\n{\n\tenum sdebug_z_cond zc;\n\n\tif (!zbc_zone_is_seq(zsp))\n\t\treturn;\n\n\tzc = zsp->z_cond;\n\tif (!(zc == ZC2_IMPLICIT_OPEN || zc == ZC3_EXPLICIT_OPEN))\n\t\treturn;\n\n\tif (zc == ZC2_IMPLICIT_OPEN)\n\t\tdevip->nr_imp_open--;\n\telse\n\t\tdevip->nr_exp_open--;\n\n\tif (zsp->z_wp == zsp->z_start) {\n\t\tzsp->z_cond = ZC1_EMPTY;\n\t} else {\n\t\tzsp->z_cond = ZC4_CLOSED;\n\t\tdevip->nr_closed++;\n\t}\n}\n\nstatic void zbc_close_imp_open_zone(struct sdebug_dev_info *devip)\n{\n\tstruct sdeb_zone_state *zsp = &devip->zstate[0];\n\tunsigned int i;\n\n\tfor (i = 0; i < devip->nr_zones; i++, zsp++) {\n\t\tif (zsp->z_cond == ZC2_IMPLICIT_OPEN) {\n\t\t\tzbc_close_zone(devip, zsp);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void zbc_open_zone(struct sdebug_dev_info *devip,\n\t\t\t  struct sdeb_zone_state *zsp, bool explicit)\n{\n\tenum sdebug_z_cond zc;\n\n\tif (!zbc_zone_is_seq(zsp))\n\t\treturn;\n\n\tzc = zsp->z_cond;\n\tif ((explicit && zc == ZC3_EXPLICIT_OPEN) ||\n\t    (!explicit && zc == ZC2_IMPLICIT_OPEN))\n\t\treturn;\n\n\t \n\tif (explicit && zsp->z_cond == ZC2_IMPLICIT_OPEN)\n\t\tzbc_close_zone(devip, zsp);\n\telse if (devip->max_open &&\n\t\t devip->nr_imp_open + devip->nr_exp_open >= devip->max_open)\n\t\tzbc_close_imp_open_zone(devip);\n\n\tif (zsp->z_cond == ZC4_CLOSED)\n\t\tdevip->nr_closed--;\n\tif (explicit) {\n\t\tzsp->z_cond = ZC3_EXPLICIT_OPEN;\n\t\tdevip->nr_exp_open++;\n\t} else {\n\t\tzsp->z_cond = ZC2_IMPLICIT_OPEN;\n\t\tdevip->nr_imp_open++;\n\t}\n}\n\nstatic inline void zbc_set_zone_full(struct sdebug_dev_info *devip,\n\t\t\t\t     struct sdeb_zone_state *zsp)\n{\n\tswitch (zsp->z_cond) {\n\tcase ZC2_IMPLICIT_OPEN:\n\t\tdevip->nr_imp_open--;\n\t\tbreak;\n\tcase ZC3_EXPLICIT_OPEN:\n\t\tdevip->nr_exp_open--;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(true, \"Invalid zone %llu condition %x\\n\",\n\t\t\t  zsp->z_start, zsp->z_cond);\n\t\tbreak;\n\t}\n\tzsp->z_cond = ZC5_FULL;\n}\n\nstatic void zbc_inc_wp(struct sdebug_dev_info *devip,\n\t\t       unsigned long long lba, unsigned int num)\n{\n\tstruct sdeb_zone_state *zsp = zbc_zone(devip, lba);\n\tunsigned long long n, end, zend = zsp->z_start + zsp->z_size;\n\n\tif (!zbc_zone_is_seq(zsp))\n\t\treturn;\n\n\tif (zsp->z_type == ZBC_ZTYPE_SWR) {\n\t\tzsp->z_wp += num;\n\t\tif (zsp->z_wp >= zend)\n\t\t\tzbc_set_zone_full(devip, zsp);\n\t\treturn;\n\t}\n\n\twhile (num) {\n\t\tif (lba != zsp->z_wp)\n\t\t\tzsp->z_non_seq_resource = true;\n\n\t\tend = lba + num;\n\t\tif (end >= zend) {\n\t\t\tn = zend - lba;\n\t\t\tzsp->z_wp = zend;\n\t\t} else if (end > zsp->z_wp) {\n\t\t\tn = num;\n\t\t\tzsp->z_wp = end;\n\t\t} else {\n\t\t\tn = num;\n\t\t}\n\t\tif (zsp->z_wp >= zend)\n\t\t\tzbc_set_zone_full(devip, zsp);\n\n\t\tnum -= n;\n\t\tlba += n;\n\t\tif (num) {\n\t\t\tzsp++;\n\t\t\tzend = zsp->z_start + zsp->z_size;\n\t\t}\n\t}\n}\n\nstatic int check_zbc_access_params(struct scsi_cmnd *scp,\n\t\t\tunsigned long long lba, unsigned int num, bool write)\n{\n\tstruct scsi_device *sdp = scp->device;\n\tstruct sdebug_dev_info *devip = (struct sdebug_dev_info *)sdp->hostdata;\n\tstruct sdeb_zone_state *zsp = zbc_zone(devip, lba);\n\tstruct sdeb_zone_state *zsp_end = zbc_zone(devip, lba + num - 1);\n\n\tif (!write) {\n\t\tif (devip->zmodel == BLK_ZONED_HA)\n\t\t\treturn 0;\n\t\t \n\t\tif (zsp->z_type != zsp_end->z_type) {\n\t\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST,\n\t\t\t\t\tLBA_OUT_OF_RANGE,\n\t\t\t\t\tREAD_INVDATA_ASCQ);\n\t\t\treturn check_condition_result;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tif (zbc_zone_is_gap(zsp)) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE,\n\t\t\t\tATTEMPT_ACCESS_GAP);\n\t\treturn check_condition_result;\n\t}\n\n\t \n\tif (zbc_zone_is_conv(zsp)) {\n\t\tif (!zbc_zone_is_conv(zsp_end)) {\n\t\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST,\n\t\t\t\t\tLBA_OUT_OF_RANGE,\n\t\t\t\t\tWRITE_BOUNDARY_ASCQ);\n\t\t\treturn check_condition_result;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (zsp->z_type == ZBC_ZTYPE_SWR) {\n\t\t \n\t\tif (zsp_end != zsp) {\n\t\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST,\n\t\t\t\t\tLBA_OUT_OF_RANGE,\n\t\t\t\t\tWRITE_BOUNDARY_ASCQ);\n\t\t\treturn check_condition_result;\n\t\t}\n\t\t \n\t\tif (zsp->z_cond == ZC5_FULL) {\n\t\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST,\n\t\t\t\t\tINVALID_FIELD_IN_CDB, 0);\n\t\t\treturn check_condition_result;\n\t\t}\n\t\t \n\t\tif (lba != zsp->z_wp) {\n\t\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST,\n\t\t\t\t\tLBA_OUT_OF_RANGE,\n\t\t\t\t\tUNALIGNED_WRITE_ASCQ);\n\t\t\treturn check_condition_result;\n\t\t}\n\t}\n\n\t \n\tif (zsp->z_cond == ZC1_EMPTY || zsp->z_cond == ZC4_CLOSED) {\n\t\tif (devip->max_open &&\n\t\t    devip->nr_exp_open >= devip->max_open) {\n\t\t\tmk_sense_buffer(scp, DATA_PROTECT,\n\t\t\t\t\tINSUFF_RES_ASC,\n\t\t\t\t\tINSUFF_ZONE_ASCQ);\n\t\t\treturn check_condition_result;\n\t\t}\n\t\tzbc_open_zone(devip, zsp, false);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int check_device_access_params\n\t\t\t(struct scsi_cmnd *scp, unsigned long long lba,\n\t\t\t unsigned int num, bool write)\n{\n\tstruct scsi_device *sdp = scp->device;\n\tstruct sdebug_dev_info *devip = (struct sdebug_dev_info *)sdp->hostdata;\n\n\tif (lba + num > sdebug_capacity) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);\n\t\treturn check_condition_result;\n\t}\n\t \n\tif (num > sdebug_store_sectors) {\n\t\t \n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\n\t\treturn check_condition_result;\n\t}\n\tif (write && unlikely(sdebug_wp)) {\n\t\tmk_sense_buffer(scp, DATA_PROTECT, WRITE_PROTECTED, 0x2);\n\t\treturn check_condition_result;\n\t}\n\tif (sdebug_dev_is_zoned(devip))\n\t\treturn check_zbc_access_params(scp, lba, num, write);\n\n\treturn 0;\n}\n\n \nstatic inline struct sdeb_store_info *devip2sip(struct sdebug_dev_info *devip,\n\t\t\t\t\t\tbool bug_if_fake_rw)\n{\n\tif (sdebug_fake_rw) {\n\t\tBUG_ON(bug_if_fake_rw);\t \n\t\treturn NULL;\n\t}\n\treturn xa_load(per_store_ap, devip->sdbg_host->si_idx);\n}\n\n \nstatic int do_device_access(struct sdeb_store_info *sip, struct scsi_cmnd *scp,\n\t\t\t    u32 sg_skip, u64 lba, u32 num, bool do_write)\n{\n\tint ret;\n\tu64 block, rest = 0;\n\tenum dma_data_direction dir;\n\tstruct scsi_data_buffer *sdb = &scp->sdb;\n\tu8 *fsp;\n\n\tif (do_write) {\n\t\tdir = DMA_TO_DEVICE;\n\t\twrite_since_sync = true;\n\t} else {\n\t\tdir = DMA_FROM_DEVICE;\n\t}\n\n\tif (!sdb->length || !sip)\n\t\treturn 0;\n\tif (scp->sc_data_direction != dir)\n\t\treturn -1;\n\tfsp = sip->storep;\n\n\tblock = do_div(lba, sdebug_store_sectors);\n\tif (block + num > sdebug_store_sectors)\n\t\trest = block + num - sdebug_store_sectors;\n\n\tret = sg_copy_buffer(sdb->table.sgl, sdb->table.nents,\n\t\t   fsp + (block * sdebug_sector_size),\n\t\t   (num - rest) * sdebug_sector_size, sg_skip, do_write);\n\tif (ret != (num - rest) * sdebug_sector_size)\n\t\treturn ret;\n\n\tif (rest) {\n\t\tret += sg_copy_buffer(sdb->table.sgl, sdb->table.nents,\n\t\t\t    fsp, rest * sdebug_sector_size,\n\t\t\t    sg_skip + ((num - rest) * sdebug_sector_size),\n\t\t\t    do_write);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int do_dout_fetch(struct scsi_cmnd *scp, u32 num, u8 *doutp)\n{\n\tstruct scsi_data_buffer *sdb = &scp->sdb;\n\n\tif (!sdb->length)\n\t\treturn 0;\n\tif (scp->sc_data_direction != DMA_TO_DEVICE)\n\t\treturn -1;\n\treturn sg_copy_buffer(sdb->table.sgl, sdb->table.nents, doutp,\n\t\t\t      num * sdebug_sector_size, 0, true);\n}\n\n \nstatic bool comp_write_worker(struct sdeb_store_info *sip, u64 lba, u32 num,\n\t\t\t      const u8 *arr, bool compare_only)\n{\n\tbool res;\n\tu64 block, rest = 0;\n\tu32 store_blks = sdebug_store_sectors;\n\tu32 lb_size = sdebug_sector_size;\n\tu8 *fsp = sip->storep;\n\n\tblock = do_div(lba, store_blks);\n\tif (block + num > store_blks)\n\t\trest = block + num - store_blks;\n\n\tres = !memcmp(fsp + (block * lb_size), arr, (num - rest) * lb_size);\n\tif (!res)\n\t\treturn res;\n\tif (rest)\n\t\tres = memcmp(fsp, arr + ((num - rest) * lb_size),\n\t\t\t     rest * lb_size);\n\tif (!res)\n\t\treturn res;\n\tif (compare_only)\n\t\treturn true;\n\tarr += num * lb_size;\n\tmemcpy(fsp + (block * lb_size), arr, (num - rest) * lb_size);\n\tif (rest)\n\t\tmemcpy(fsp, arr + ((num - rest) * lb_size), rest * lb_size);\n\treturn res;\n}\n\nstatic __be16 dif_compute_csum(const void *buf, int len)\n{\n\t__be16 csum;\n\n\tif (sdebug_guard)\n\t\tcsum = (__force __be16)ip_compute_csum(buf, len);\n\telse\n\t\tcsum = cpu_to_be16(crc_t10dif(buf, len));\n\n\treturn csum;\n}\n\nstatic int dif_verify(struct t10_pi_tuple *sdt, const void *data,\n\t\t      sector_t sector, u32 ei_lba)\n{\n\t__be16 csum = dif_compute_csum(data, sdebug_sector_size);\n\n\tif (sdt->guard_tag != csum) {\n\t\tpr_err(\"GUARD check failed on sector %lu rcvd 0x%04x, data 0x%04x\\n\",\n\t\t\t(unsigned long)sector,\n\t\t\tbe16_to_cpu(sdt->guard_tag),\n\t\t\tbe16_to_cpu(csum));\n\t\treturn 0x01;\n\t}\n\tif (sdebug_dif == T10_PI_TYPE1_PROTECTION &&\n\t    be32_to_cpu(sdt->ref_tag) != (sector & 0xffffffff)) {\n\t\tpr_err(\"REF check failed on sector %lu\\n\",\n\t\t\t(unsigned long)sector);\n\t\treturn 0x03;\n\t}\n\tif (sdebug_dif == T10_PI_TYPE2_PROTECTION &&\n\t    be32_to_cpu(sdt->ref_tag) != ei_lba) {\n\t\tpr_err(\"REF check failed on sector %lu\\n\",\n\t\t\t(unsigned long)sector);\n\t\treturn 0x03;\n\t}\n\treturn 0;\n}\n\nstatic void dif_copy_prot(struct scsi_cmnd *scp, sector_t sector,\n\t\t\t  unsigned int sectors, bool read)\n{\n\tsize_t resid;\n\tvoid *paddr;\n\tstruct sdeb_store_info *sip = devip2sip((struct sdebug_dev_info *)\n\t\t\t\t\t\tscp->device->hostdata, true);\n\tstruct t10_pi_tuple *dif_storep = sip->dif_storep;\n\tconst void *dif_store_end = dif_storep + sdebug_store_sectors;\n\tstruct sg_mapping_iter miter;\n\n\t \n\tresid = sectors * sizeof(*dif_storep);\n\n\tsg_miter_start(&miter, scsi_prot_sglist(scp),\n\t\t       scsi_prot_sg_count(scp), SG_MITER_ATOMIC |\n\t\t       (read ? SG_MITER_TO_SG : SG_MITER_FROM_SG));\n\n\twhile (sg_miter_next(&miter) && resid > 0) {\n\t\tsize_t len = min_t(size_t, miter.length, resid);\n\t\tvoid *start = dif_store(sip, sector);\n\t\tsize_t rest = 0;\n\n\t\tif (dif_store_end < start + len)\n\t\t\trest = start + len - dif_store_end;\n\n\t\tpaddr = miter.addr;\n\n\t\tif (read)\n\t\t\tmemcpy(paddr, start, len - rest);\n\t\telse\n\t\t\tmemcpy(start, paddr, len - rest);\n\n\t\tif (rest) {\n\t\t\tif (read)\n\t\t\t\tmemcpy(paddr + len - rest, dif_storep, rest);\n\t\t\telse\n\t\t\t\tmemcpy(dif_storep, paddr + len - rest, rest);\n\t\t}\n\n\t\tsector += len / sizeof(*dif_storep);\n\t\tresid -= len;\n\t}\n\tsg_miter_stop(&miter);\n}\n\nstatic int prot_verify_read(struct scsi_cmnd *scp, sector_t start_sec,\n\t\t\t    unsigned int sectors, u32 ei_lba)\n{\n\tint ret = 0;\n\tunsigned int i;\n\tsector_t sector;\n\tstruct sdeb_store_info *sip = devip2sip((struct sdebug_dev_info *)\n\t\t\t\t\t\tscp->device->hostdata, true);\n\tstruct t10_pi_tuple *sdt;\n\n\tfor (i = 0; i < sectors; i++, ei_lba++) {\n\t\tsector = start_sec + i;\n\t\tsdt = dif_store(sip, sector);\n\n\t\tif (sdt->app_tag == cpu_to_be16(0xffff))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (scp->cmnd[1] >> 5) {  \n\t\t\tret = dif_verify(sdt, lba2fake_store(sip, sector),\n\t\t\t\t\t sector, ei_lba);\n\t\t\tif (ret) {\n\t\t\t\tdif_errors++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tdif_copy_prot(scp, start_sec, sectors, true);\n\tdix_reads++;\n\n\treturn ret;\n}\n\nstatic inline void\nsdeb_read_lock(struct sdeb_store_info *sip)\n{\n\tif (sdebug_no_rwlock) {\n\t\tif (sip)\n\t\t\t__acquire(&sip->macc_lck);\n\t\telse\n\t\t\t__acquire(&sdeb_fake_rw_lck);\n\t} else {\n\t\tif (sip)\n\t\t\tread_lock(&sip->macc_lck);\n\t\telse\n\t\t\tread_lock(&sdeb_fake_rw_lck);\n\t}\n}\n\nstatic inline void\nsdeb_read_unlock(struct sdeb_store_info *sip)\n{\n\tif (sdebug_no_rwlock) {\n\t\tif (sip)\n\t\t\t__release(&sip->macc_lck);\n\t\telse\n\t\t\t__release(&sdeb_fake_rw_lck);\n\t} else {\n\t\tif (sip)\n\t\t\tread_unlock(&sip->macc_lck);\n\t\telse\n\t\t\tread_unlock(&sdeb_fake_rw_lck);\n\t}\n}\n\nstatic inline void\nsdeb_write_lock(struct sdeb_store_info *sip)\n{\n\tif (sdebug_no_rwlock) {\n\t\tif (sip)\n\t\t\t__acquire(&sip->macc_lck);\n\t\telse\n\t\t\t__acquire(&sdeb_fake_rw_lck);\n\t} else {\n\t\tif (sip)\n\t\t\twrite_lock(&sip->macc_lck);\n\t\telse\n\t\t\twrite_lock(&sdeb_fake_rw_lck);\n\t}\n}\n\nstatic inline void\nsdeb_write_unlock(struct sdeb_store_info *sip)\n{\n\tif (sdebug_no_rwlock) {\n\t\tif (sip)\n\t\t\t__release(&sip->macc_lck);\n\t\telse\n\t\t\t__release(&sdeb_fake_rw_lck);\n\t} else {\n\t\tif (sip)\n\t\t\twrite_unlock(&sip->macc_lck);\n\t\telse\n\t\t\twrite_unlock(&sdeb_fake_rw_lck);\n\t}\n}\n\nstatic int resp_read_dt0(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\n{\n\tbool check_prot;\n\tu32 num;\n\tu32 ei_lba;\n\tint ret;\n\tu64 lba;\n\tstruct sdeb_store_info *sip = devip2sip(devip, true);\n\tu8 *cmd = scp->cmnd;\n\n\tswitch (cmd[0]) {\n\tcase READ_16:\n\t\tei_lba = 0;\n\t\tlba = get_unaligned_be64(cmd + 2);\n\t\tnum = get_unaligned_be32(cmd + 10);\n\t\tcheck_prot = true;\n\t\tbreak;\n\tcase READ_10:\n\t\tei_lba = 0;\n\t\tlba = get_unaligned_be32(cmd + 2);\n\t\tnum = get_unaligned_be16(cmd + 7);\n\t\tcheck_prot = true;\n\t\tbreak;\n\tcase READ_6:\n\t\tei_lba = 0;\n\t\tlba = (u32)cmd[3] | (u32)cmd[2] << 8 |\n\t\t      (u32)(cmd[1] & 0x1f) << 16;\n\t\tnum = (0 == cmd[4]) ? 256 : cmd[4];\n\t\tcheck_prot = true;\n\t\tbreak;\n\tcase READ_12:\n\t\tei_lba = 0;\n\t\tlba = get_unaligned_be32(cmd + 2);\n\t\tnum = get_unaligned_be32(cmd + 6);\n\t\tcheck_prot = true;\n\t\tbreak;\n\tcase XDWRITEREAD_10:\n\t\tei_lba = 0;\n\t\tlba = get_unaligned_be32(cmd + 2);\n\t\tnum = get_unaligned_be16(cmd + 7);\n\t\tcheck_prot = false;\n\t\tbreak;\n\tdefault:\t \n\t\tlba = get_unaligned_be64(cmd + 12);\n\t\tei_lba = get_unaligned_be32(cmd + 20);\n\t\tnum = get_unaligned_be32(cmd + 28);\n\t\tcheck_prot = false;\n\t\tbreak;\n\t}\n\tif (unlikely(have_dif_prot && check_prot)) {\n\t\tif (sdebug_dif == T10_PI_TYPE2_PROTECTION &&\n\t\t    (cmd[1] & 0xe0)) {\n\t\t\tmk_sense_invalid_opcode(scp);\n\t\t\treturn check_condition_result;\n\t\t}\n\t\tif ((sdebug_dif == T10_PI_TYPE1_PROTECTION ||\n\t\t     sdebug_dif == T10_PI_TYPE3_PROTECTION) &&\n\t\t    (cmd[1] & 0xe0) == 0)\n\t\t\tsdev_printk(KERN_ERR, scp->device, \"Unprotected RD \"\n\t\t\t\t    \"to DIF device\\n\");\n\t}\n\tif (unlikely((sdebug_opts & SDEBUG_OPT_SHORT_TRANSFER) &&\n\t\t     atomic_read(&sdeb_inject_pending))) {\n\t\tnum /= 2;\n\t\tatomic_set(&sdeb_inject_pending, 0);\n\t}\n\n\tret = check_device_access_params(scp, lba, num, false);\n\tif (ret)\n\t\treturn ret;\n\tif (unlikely((SDEBUG_OPT_MEDIUM_ERR & sdebug_opts) &&\n\t\t     (lba <= (sdebug_medium_error_start + sdebug_medium_error_count - 1)) &&\n\t\t     ((lba + num) > sdebug_medium_error_start))) {\n\t\t \n\t\tmk_sense_buffer(scp, MEDIUM_ERROR, UNRECOVERED_READ_ERR, 0);\n\t\t \n\t\tif (0x70 == (scp->sense_buffer[0] & 0x7f)) {\n\t\t\tscp->sense_buffer[0] |= 0x80;\t \n\t\t\tret = (lba < OPT_MEDIUM_ERR_ADDR)\n\t\t\t      ? OPT_MEDIUM_ERR_ADDR : (int)lba;\n\t\t\tput_unaligned_be32(ret, scp->sense_buffer + 3);\n\t\t}\n\t\tscsi_set_resid(scp, scsi_bufflen(scp));\n\t\treturn check_condition_result;\n\t}\n\n\tsdeb_read_lock(sip);\n\n\t \n\tif (unlikely(sdebug_dix && scsi_prot_sg_count(scp))) {\n\t\tswitch (prot_verify_read(scp, lba, num, ei_lba)) {\n\t\tcase 1:  \n\t\t\tif (cmd[1] >> 5 != 3) {  \n\t\t\t\tsdeb_read_unlock(sip);\n\t\t\t\tmk_sense_buffer(scp, ABORTED_COMMAND, 0x10, 1);\n\t\t\t\treturn check_condition_result;\n\t\t\t} else if (scp->prot_flags & SCSI_PROT_GUARD_CHECK) {\n\t\t\t\tsdeb_read_unlock(sip);\n\t\t\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, 0x10, 1);\n\t\t\t\treturn illegal_condition_result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tif (cmd[1] >> 5 != 3) {  \n\t\t\t\tsdeb_read_unlock(sip);\n\t\t\t\tmk_sense_buffer(scp, ABORTED_COMMAND, 0x10, 3);\n\t\t\t\treturn check_condition_result;\n\t\t\t} else if (scp->prot_flags & SCSI_PROT_REF_CHECK) {\n\t\t\t\tsdeb_read_unlock(sip);\n\t\t\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, 0x10, 3);\n\t\t\t\treturn illegal_condition_result;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = do_device_access(sip, scp, 0, lba, num, false);\n\tsdeb_read_unlock(sip);\n\tif (unlikely(ret == -1))\n\t\treturn DID_ERROR << 16;\n\n\tscsi_set_resid(scp, scsi_bufflen(scp) - ret);\n\n\tif (unlikely((sdebug_opts & SDEBUG_OPT_RECOV_DIF_DIX) &&\n\t\t     atomic_read(&sdeb_inject_pending))) {\n\t\tif (sdebug_opts & SDEBUG_OPT_RECOVERED_ERR) {\n\t\t\tmk_sense_buffer(scp, RECOVERED_ERROR, THRESHOLD_EXCEEDED, 0);\n\t\t\tatomic_set(&sdeb_inject_pending, 0);\n\t\t\treturn check_condition_result;\n\t\t} else if (sdebug_opts & SDEBUG_OPT_DIF_ERR) {\n\t\t\t \n\t\t\tmk_sense_buffer(scp, ABORTED_COMMAND, 0x10, 1);\n\t\t\tatomic_set(&sdeb_inject_pending, 0);\n\t\t\treturn illegal_condition_result;\n\t\t} else if (SDEBUG_OPT_DIX_ERR & sdebug_opts) {\n\t\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, 0x10, 1);\n\t\t\tatomic_set(&sdeb_inject_pending, 0);\n\t\t\treturn illegal_condition_result;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int prot_verify_write(struct scsi_cmnd *SCpnt, sector_t start_sec,\n\t\t\t     unsigned int sectors, u32 ei_lba)\n{\n\tint ret;\n\tstruct t10_pi_tuple *sdt;\n\tvoid *daddr;\n\tsector_t sector = start_sec;\n\tint ppage_offset;\n\tint dpage_offset;\n\tstruct sg_mapping_iter diter;\n\tstruct sg_mapping_iter piter;\n\n\tBUG_ON(scsi_sg_count(SCpnt) == 0);\n\tBUG_ON(scsi_prot_sg_count(SCpnt) == 0);\n\n\tsg_miter_start(&piter, scsi_prot_sglist(SCpnt),\n\t\t\tscsi_prot_sg_count(SCpnt),\n\t\t\tSG_MITER_ATOMIC | SG_MITER_FROM_SG);\n\tsg_miter_start(&diter, scsi_sglist(SCpnt), scsi_sg_count(SCpnt),\n\t\t\tSG_MITER_ATOMIC | SG_MITER_FROM_SG);\n\n\t \n\twhile (sg_miter_next(&piter)) {\n\t\tdpage_offset = 0;\n\t\tif (WARN_ON(!sg_miter_next(&diter))) {\n\t\t\tret = 0x01;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (ppage_offset = 0; ppage_offset < piter.length;\n\t\t     ppage_offset += sizeof(struct t10_pi_tuple)) {\n\t\t\t \n\t\t\tif (dpage_offset >= diter.length) {\n\t\t\t\tif (WARN_ON(!sg_miter_next(&diter))) {\n\t\t\t\t\tret = 0x01;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tdpage_offset = 0;\n\t\t\t}\n\n\t\t\tsdt = piter.addr + ppage_offset;\n\t\t\tdaddr = diter.addr + dpage_offset;\n\n\t\t\tif (SCpnt->cmnd[1] >> 5 != 3) {  \n\t\t\t\tret = dif_verify(sdt, daddr, sector, ei_lba);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tsector++;\n\t\t\tei_lba++;\n\t\t\tdpage_offset += sdebug_sector_size;\n\t\t}\n\t\tditer.consumed = dpage_offset;\n\t\tsg_miter_stop(&diter);\n\t}\n\tsg_miter_stop(&piter);\n\n\tdif_copy_prot(SCpnt, start_sec, sectors, false);\n\tdix_writes++;\n\n\treturn 0;\n\nout:\n\tdif_errors++;\n\tsg_miter_stop(&diter);\n\tsg_miter_stop(&piter);\n\treturn ret;\n}\n\nstatic unsigned long lba_to_map_index(sector_t lba)\n{\n\tif (sdebug_unmap_alignment)\n\t\tlba += sdebug_unmap_granularity - sdebug_unmap_alignment;\n\tsector_div(lba, sdebug_unmap_granularity);\n\treturn lba;\n}\n\nstatic sector_t map_index_to_lba(unsigned long index)\n{\n\tsector_t lba = index * sdebug_unmap_granularity;\n\n\tif (sdebug_unmap_alignment)\n\t\tlba -= sdebug_unmap_granularity - sdebug_unmap_alignment;\n\treturn lba;\n}\n\nstatic unsigned int map_state(struct sdeb_store_info *sip, sector_t lba,\n\t\t\t      unsigned int *num)\n{\n\tsector_t end;\n\tunsigned int mapped;\n\tunsigned long index;\n\tunsigned long next;\n\n\tindex = lba_to_map_index(lba);\n\tmapped = test_bit(index, sip->map_storep);\n\n\tif (mapped)\n\t\tnext = find_next_zero_bit(sip->map_storep, map_size, index);\n\telse\n\t\tnext = find_next_bit(sip->map_storep, map_size, index);\n\n\tend = min_t(sector_t, sdebug_store_sectors,  map_index_to_lba(next));\n\t*num = end - lba;\n\treturn mapped;\n}\n\nstatic void map_region(struct sdeb_store_info *sip, sector_t lba,\n\t\t       unsigned int len)\n{\n\tsector_t end = lba + len;\n\n\twhile (lba < end) {\n\t\tunsigned long index = lba_to_map_index(lba);\n\n\t\tif (index < map_size)\n\t\t\tset_bit(index, sip->map_storep);\n\n\t\tlba = map_index_to_lba(index + 1);\n\t}\n}\n\nstatic void unmap_region(struct sdeb_store_info *sip, sector_t lba,\n\t\t\t unsigned int len)\n{\n\tsector_t end = lba + len;\n\tu8 *fsp = sip->storep;\n\n\twhile (lba < end) {\n\t\tunsigned long index = lba_to_map_index(lba);\n\n\t\tif (lba == map_index_to_lba(index) &&\n\t\t    lba + sdebug_unmap_granularity <= end &&\n\t\t    index < map_size) {\n\t\t\tclear_bit(index, sip->map_storep);\n\t\t\tif (sdebug_lbprz) {   \n\t\t\t\tmemset(fsp + lba * sdebug_sector_size,\n\t\t\t\t       (sdebug_lbprz & 1) ? 0 : 0xff,\n\t\t\t\t       sdebug_sector_size *\n\t\t\t\t       sdebug_unmap_granularity);\n\t\t\t}\n\t\t\tif (sip->dif_storep) {\n\t\t\t\tmemset(sip->dif_storep + lba, 0xff,\n\t\t\t\t       sizeof(*sip->dif_storep) *\n\t\t\t\t       sdebug_unmap_granularity);\n\t\t\t}\n\t\t}\n\t\tlba = map_index_to_lba(index + 1);\n\t}\n}\n\nstatic int resp_write_dt0(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\n{\n\tbool check_prot;\n\tu32 num;\n\tu32 ei_lba;\n\tint ret;\n\tu64 lba;\n\tstruct sdeb_store_info *sip = devip2sip(devip, true);\n\tu8 *cmd = scp->cmnd;\n\n\tswitch (cmd[0]) {\n\tcase WRITE_16:\n\t\tei_lba = 0;\n\t\tlba = get_unaligned_be64(cmd + 2);\n\t\tnum = get_unaligned_be32(cmd + 10);\n\t\tcheck_prot = true;\n\t\tbreak;\n\tcase WRITE_10:\n\t\tei_lba = 0;\n\t\tlba = get_unaligned_be32(cmd + 2);\n\t\tnum = get_unaligned_be16(cmd + 7);\n\t\tcheck_prot = true;\n\t\tbreak;\n\tcase WRITE_6:\n\t\tei_lba = 0;\n\t\tlba = (u32)cmd[3] | (u32)cmd[2] << 8 |\n\t\t      (u32)(cmd[1] & 0x1f) << 16;\n\t\tnum = (0 == cmd[4]) ? 256 : cmd[4];\n\t\tcheck_prot = true;\n\t\tbreak;\n\tcase WRITE_12:\n\t\tei_lba = 0;\n\t\tlba = get_unaligned_be32(cmd + 2);\n\t\tnum = get_unaligned_be32(cmd + 6);\n\t\tcheck_prot = true;\n\t\tbreak;\n\tcase 0x53:\t \n\t\tei_lba = 0;\n\t\tlba = get_unaligned_be32(cmd + 2);\n\t\tnum = get_unaligned_be16(cmd + 7);\n\t\tcheck_prot = false;\n\t\tbreak;\n\tdefault:\t \n\t\tlba = get_unaligned_be64(cmd + 12);\n\t\tei_lba = get_unaligned_be32(cmd + 20);\n\t\tnum = get_unaligned_be32(cmd + 28);\n\t\tcheck_prot = false;\n\t\tbreak;\n\t}\n\tif (unlikely(have_dif_prot && check_prot)) {\n\t\tif (sdebug_dif == T10_PI_TYPE2_PROTECTION &&\n\t\t    (cmd[1] & 0xe0)) {\n\t\t\tmk_sense_invalid_opcode(scp);\n\t\t\treturn check_condition_result;\n\t\t}\n\t\tif ((sdebug_dif == T10_PI_TYPE1_PROTECTION ||\n\t\t     sdebug_dif == T10_PI_TYPE3_PROTECTION) &&\n\t\t    (cmd[1] & 0xe0) == 0)\n\t\t\tsdev_printk(KERN_ERR, scp->device, \"Unprotected WR \"\n\t\t\t\t    \"to DIF device\\n\");\n\t}\n\n\tsdeb_write_lock(sip);\n\tret = check_device_access_params(scp, lba, num, true);\n\tif (ret) {\n\t\tsdeb_write_unlock(sip);\n\t\treturn ret;\n\t}\n\n\t \n\tif (unlikely(sdebug_dix && scsi_prot_sg_count(scp))) {\n\t\tswitch (prot_verify_write(scp, lba, num, ei_lba)) {\n\t\tcase 1:  \n\t\t\tif (scp->prot_flags & SCSI_PROT_GUARD_CHECK) {\n\t\t\t\tsdeb_write_unlock(sip);\n\t\t\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, 0x10, 1);\n\t\t\t\treturn illegal_condition_result;\n\t\t\t} else if (scp->cmnd[1] >> 5 != 3) {  \n\t\t\t\tsdeb_write_unlock(sip);\n\t\t\t\tmk_sense_buffer(scp, ABORTED_COMMAND, 0x10, 1);\n\t\t\t\treturn check_condition_result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tif (scp->prot_flags & SCSI_PROT_REF_CHECK) {\n\t\t\t\tsdeb_write_unlock(sip);\n\t\t\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, 0x10, 3);\n\t\t\t\treturn illegal_condition_result;\n\t\t\t} else if (scp->cmnd[1] >> 5 != 3) {  \n\t\t\t\tsdeb_write_unlock(sip);\n\t\t\t\tmk_sense_buffer(scp, ABORTED_COMMAND, 0x10, 3);\n\t\t\t\treturn check_condition_result;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = do_device_access(sip, scp, 0, lba, num, true);\n\tif (unlikely(scsi_debug_lbp()))\n\t\tmap_region(sip, lba, num);\n\t \n\tif (sdebug_dev_is_zoned(devip))\n\t\tzbc_inc_wp(devip, lba, num);\n\tsdeb_write_unlock(sip);\n\tif (unlikely(-1 == ret))\n\t\treturn DID_ERROR << 16;\n\telse if (unlikely(sdebug_verbose &&\n\t\t\t  (ret < (num * sdebug_sector_size))))\n\t\tsdev_printk(KERN_INFO, scp->device,\n\t\t\t    \"%s: write: cdb indicated=%u, IO sent=%d bytes\\n\",\n\t\t\t    my_name, num * sdebug_sector_size, ret);\n\n\tif (unlikely((sdebug_opts & SDEBUG_OPT_RECOV_DIF_DIX) &&\n\t\t     atomic_read(&sdeb_inject_pending))) {\n\t\tif (sdebug_opts & SDEBUG_OPT_RECOVERED_ERR) {\n\t\t\tmk_sense_buffer(scp, RECOVERED_ERROR, THRESHOLD_EXCEEDED, 0);\n\t\t\tatomic_set(&sdeb_inject_pending, 0);\n\t\t\treturn check_condition_result;\n\t\t} else if (sdebug_opts & SDEBUG_OPT_DIF_ERR) {\n\t\t\t \n\t\t\tmk_sense_buffer(scp, ABORTED_COMMAND, 0x10, 1);\n\t\t\tatomic_set(&sdeb_inject_pending, 0);\n\t\t\treturn illegal_condition_result;\n\t\t} else if (sdebug_opts & SDEBUG_OPT_DIX_ERR) {\n\t\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, 0x10, 1);\n\t\t\tatomic_set(&sdeb_inject_pending, 0);\n\t\t\treturn illegal_condition_result;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int resp_write_scat(struct scsi_cmnd *scp,\n\t\t\t   struct sdebug_dev_info *devip)\n{\n\tu8 *cmd = scp->cmnd;\n\tu8 *lrdp = NULL;\n\tu8 *up;\n\tstruct sdeb_store_info *sip = devip2sip(devip, true);\n\tu8 wrprotect;\n\tu16 lbdof, num_lrd, k;\n\tu32 num, num_by, bt_len, lbdof_blen, sg_off, cum_lb;\n\tu32 lb_size = sdebug_sector_size;\n\tu32 ei_lba;\n\tu64 lba;\n\tint ret, res;\n\tbool is_16;\n\tstatic const u32 lrd_size = 32;  \n\n\tif (cmd[0] == VARIABLE_LENGTH_CMD) {\n\t\tis_16 = false;\n\t\twrprotect = (cmd[10] >> 5) & 0x7;\n\t\tlbdof = get_unaligned_be16(cmd + 12);\n\t\tnum_lrd = get_unaligned_be16(cmd + 16);\n\t\tbt_len = get_unaligned_be32(cmd + 28);\n\t} else {         \n\t\tis_16 = true;\n\t\twrprotect = (cmd[2] >> 5) & 0x7;\n\t\tlbdof = get_unaligned_be16(cmd + 4);\n\t\tnum_lrd = get_unaligned_be16(cmd + 8);\n\t\tbt_len = get_unaligned_be32(cmd + 10);\n\t\tif (unlikely(have_dif_prot)) {\n\t\t\tif (sdebug_dif == T10_PI_TYPE2_PROTECTION &&\n\t\t\t    wrprotect) {\n\t\t\t\tmk_sense_invalid_opcode(scp);\n\t\t\t\treturn illegal_condition_result;\n\t\t\t}\n\t\t\tif ((sdebug_dif == T10_PI_TYPE1_PROTECTION ||\n\t\t\t     sdebug_dif == T10_PI_TYPE3_PROTECTION) &&\n\t\t\t     wrprotect == 0)\n\t\t\t\tsdev_printk(KERN_ERR, scp->device,\n\t\t\t\t\t    \"Unprotected WR to DIF device\\n\");\n\t\t}\n\t}\n\tif ((num_lrd == 0) || (bt_len == 0))\n\t\treturn 0;        \n\tif (lbdof == 0) {\n\t\tif (sdebug_verbose)\n\t\t\tsdev_printk(KERN_INFO, scp->device,\n\t\t\t\t\"%s: %s: LB Data Offset field bad\\n\",\n\t\t\t\tmy_name, __func__);\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\n\t\treturn illegal_condition_result;\n\t}\n\tlbdof_blen = lbdof * lb_size;\n\tif ((lrd_size + (num_lrd * lrd_size)) > lbdof_blen) {\n\t\tif (sdebug_verbose)\n\t\t\tsdev_printk(KERN_INFO, scp->device,\n\t\t\t\t\"%s: %s: LBA range descriptors don't fit\\n\",\n\t\t\t\tmy_name, __func__);\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\n\t\treturn illegal_condition_result;\n\t}\n\tlrdp = kzalloc(lbdof_blen, GFP_ATOMIC | __GFP_NOWARN);\n\tif (lrdp == NULL)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\tif (sdebug_verbose)\n\t\tsdev_printk(KERN_INFO, scp->device,\n\t\t\t\"%s: %s: Fetch header+scatter_list, lbdof_blen=%u\\n\",\n\t\t\tmy_name, __func__, lbdof_blen);\n\tres = fetch_to_dev_buffer(scp, lrdp, lbdof_blen);\n\tif (res == -1) {\n\t\tret = DID_ERROR << 16;\n\t\tgoto err_out;\n\t}\n\n\tsdeb_write_lock(sip);\n\tsg_off = lbdof_blen;\n\t \n\tcum_lb = 0;\n\tfor (k = 0, up = lrdp + lrd_size; k < num_lrd; ++k, up += lrd_size) {\n\t\tlba = get_unaligned_be64(up + 0);\n\t\tnum = get_unaligned_be32(up + 8);\n\t\tif (sdebug_verbose)\n\t\t\tsdev_printk(KERN_INFO, scp->device,\n\t\t\t\t\"%s: %s: k=%d  LBA=0x%llx num=%u  sg_off=%u\\n\",\n\t\t\t\tmy_name, __func__, k, lba, num, sg_off);\n\t\tif (num == 0)\n\t\t\tcontinue;\n\t\tret = check_device_access_params(scp, lba, num, true);\n\t\tif (ret)\n\t\t\tgoto err_out_unlock;\n\t\tnum_by = num * lb_size;\n\t\tei_lba = is_16 ? 0 : get_unaligned_be32(up + 12);\n\n\t\tif ((cum_lb + num) > bt_len) {\n\t\t\tif (sdebug_verbose)\n\t\t\t\tsdev_printk(KERN_INFO, scp->device,\n\t\t\t\t    \"%s: %s: sum of blocks > data provided\\n\",\n\t\t\t\t    my_name, __func__);\n\t\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, WRITE_ERROR_ASC,\n\t\t\t\t\t0);\n\t\t\tret = illegal_condition_result;\n\t\t\tgoto err_out_unlock;\n\t\t}\n\n\t\t \n\t\tif (unlikely(sdebug_dix && scsi_prot_sg_count(scp))) {\n\t\t\tint prot_ret = prot_verify_write(scp, lba, num,\n\t\t\t\t\t\t\t ei_lba);\n\n\t\t\tif (prot_ret) {\n\t\t\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, 0x10,\n\t\t\t\t\t\tprot_ret);\n\t\t\t\tret = illegal_condition_result;\n\t\t\t\tgoto err_out_unlock;\n\t\t\t}\n\t\t}\n\n\t\tret = do_device_access(sip, scp, sg_off, lba, num, true);\n\t\t \n\t\tif (sdebug_dev_is_zoned(devip))\n\t\t\tzbc_inc_wp(devip, lba, num);\n\t\tif (unlikely(scsi_debug_lbp()))\n\t\t\tmap_region(sip, lba, num);\n\t\tif (unlikely(-1 == ret)) {\n\t\t\tret = DID_ERROR << 16;\n\t\t\tgoto err_out_unlock;\n\t\t} else if (unlikely(sdebug_verbose && (ret < num_by)))\n\t\t\tsdev_printk(KERN_INFO, scp->device,\n\t\t\t    \"%s: write: cdb indicated=%u, IO sent=%d bytes\\n\",\n\t\t\t    my_name, num_by, ret);\n\n\t\tif (unlikely((sdebug_opts & SDEBUG_OPT_RECOV_DIF_DIX) &&\n\t\t\t     atomic_read(&sdeb_inject_pending))) {\n\t\t\tif (sdebug_opts & SDEBUG_OPT_RECOVERED_ERR) {\n\t\t\t\tmk_sense_buffer(scp, RECOVERED_ERROR, THRESHOLD_EXCEEDED, 0);\n\t\t\t\tatomic_set(&sdeb_inject_pending, 0);\n\t\t\t\tret = check_condition_result;\n\t\t\t\tgoto err_out_unlock;\n\t\t\t} else if (sdebug_opts & SDEBUG_OPT_DIF_ERR) {\n\t\t\t\t \n\t\t\t\tmk_sense_buffer(scp, ABORTED_COMMAND, 0x10, 1);\n\t\t\t\tatomic_set(&sdeb_inject_pending, 0);\n\t\t\t\tret = illegal_condition_result;\n\t\t\t\tgoto err_out_unlock;\n\t\t\t} else if (sdebug_opts & SDEBUG_OPT_DIX_ERR) {\n\t\t\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, 0x10, 1);\n\t\t\t\tatomic_set(&sdeb_inject_pending, 0);\n\t\t\t\tret = illegal_condition_result;\n\t\t\t\tgoto err_out_unlock;\n\t\t\t}\n\t\t}\n\t\tsg_off += num_by;\n\t\tcum_lb += num;\n\t}\n\tret = 0;\nerr_out_unlock:\n\tsdeb_write_unlock(sip);\nerr_out:\n\tkfree(lrdp);\n\treturn ret;\n}\n\nstatic int resp_write_same(struct scsi_cmnd *scp, u64 lba, u32 num,\n\t\t\t   u32 ei_lba, bool unmap, bool ndob)\n{\n\tstruct scsi_device *sdp = scp->device;\n\tstruct sdebug_dev_info *devip = (struct sdebug_dev_info *)sdp->hostdata;\n\tunsigned long long i;\n\tu64 block, lbaa;\n\tu32 lb_size = sdebug_sector_size;\n\tint ret;\n\tstruct sdeb_store_info *sip = devip2sip((struct sdebug_dev_info *)\n\t\t\t\t\t\tscp->device->hostdata, true);\n\tu8 *fs1p;\n\tu8 *fsp;\n\n\tsdeb_write_lock(sip);\n\n\tret = check_device_access_params(scp, lba, num, true);\n\tif (ret) {\n\t\tsdeb_write_unlock(sip);\n\t\treturn ret;\n\t}\n\n\tif (unmap && scsi_debug_lbp()) {\n\t\tunmap_region(sip, lba, num);\n\t\tgoto out;\n\t}\n\tlbaa = lba;\n\tblock = do_div(lbaa, sdebug_store_sectors);\n\t \n\tfsp = sip->storep;\n\tfs1p = fsp + (block * lb_size);\n\tif (ndob) {\n\t\tmemset(fs1p, 0, lb_size);\n\t\tret = 0;\n\t} else\n\t\tret = fetch_to_dev_buffer(scp, fs1p, lb_size);\n\n\tif (-1 == ret) {\n\t\tsdeb_write_unlock(sip);\n\t\treturn DID_ERROR << 16;\n\t} else if (sdebug_verbose && !ndob && (ret < lb_size))\n\t\tsdev_printk(KERN_INFO, scp->device,\n\t\t\t    \"%s: %s: lb size=%u, IO sent=%d bytes\\n\",\n\t\t\t    my_name, \"write same\", lb_size, ret);\n\n\t \n\tfor (i = 1 ; i < num ; i++) {\n\t\tlbaa = lba + i;\n\t\tblock = do_div(lbaa, sdebug_store_sectors);\n\t\tmemmove(fsp + (block * lb_size), fs1p, lb_size);\n\t}\n\tif (scsi_debug_lbp())\n\t\tmap_region(sip, lba, num);\n\t \n\tif (sdebug_dev_is_zoned(devip))\n\t\tzbc_inc_wp(devip, lba, num);\nout:\n\tsdeb_write_unlock(sip);\n\n\treturn 0;\n}\n\nstatic int resp_write_same_10(struct scsi_cmnd *scp,\n\t\t\t      struct sdebug_dev_info *devip)\n{\n\tu8 *cmd = scp->cmnd;\n\tu32 lba;\n\tu16 num;\n\tu32 ei_lba = 0;\n\tbool unmap = false;\n\n\tif (cmd[1] & 0x8) {\n\t\tif (sdebug_lbpws10 == 0) {\n\t\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 1, 3);\n\t\t\treturn check_condition_result;\n\t\t} else\n\t\t\tunmap = true;\n\t}\n\tlba = get_unaligned_be32(cmd + 2);\n\tnum = get_unaligned_be16(cmd + 7);\n\tif (num > sdebug_write_same_length) {\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 7, -1);\n\t\treturn check_condition_result;\n\t}\n\treturn resp_write_same(scp, lba, num, ei_lba, unmap, false);\n}\n\nstatic int resp_write_same_16(struct scsi_cmnd *scp,\n\t\t\t      struct sdebug_dev_info *devip)\n{\n\tu8 *cmd = scp->cmnd;\n\tu64 lba;\n\tu32 num;\n\tu32 ei_lba = 0;\n\tbool unmap = false;\n\tbool ndob = false;\n\n\tif (cmd[1] & 0x8) {\t \n\t\tif (sdebug_lbpws == 0) {\n\t\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 1, 3);\n\t\t\treturn check_condition_result;\n\t\t} else\n\t\t\tunmap = true;\n\t}\n\tif (cmd[1] & 0x1)   \n\t\tndob = true;\n\tlba = get_unaligned_be64(cmd + 2);\n\tnum = get_unaligned_be32(cmd + 10);\n\tif (num > sdebug_write_same_length) {\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 10, -1);\n\t\treturn check_condition_result;\n\t}\n\treturn resp_write_same(scp, lba, num, ei_lba, unmap, ndob);\n}\n\n \nstatic int resp_write_buffer(struct scsi_cmnd *scp,\n\t\t\t     struct sdebug_dev_info *devip)\n{\n\tu8 *cmd = scp->cmnd;\n\tstruct scsi_device *sdp = scp->device;\n\tstruct sdebug_dev_info *dp;\n\tu8 mode;\n\n\tmode = cmd[1] & 0x1f;\n\tswitch (mode) {\n\tcase 0x4:\t \n\t\t \n\t\tset_bit(SDEBUG_UA_BUS_RESET, devip->uas_bm);\n\t\tset_bit(SDEBUG_UA_MICROCODE_CHANGED, devip->uas_bm);\n\t\tbreak;\n\tcase 0x5:\t \n\t\tset_bit(SDEBUG_UA_MICROCODE_CHANGED_WO_RESET, devip->uas_bm);\n\t\tbreak;\n\tcase 0x6:\t \n\t\t \n\t\tlist_for_each_entry(dp,\n\t\t\t\t    &devip->sdbg_host->dev_info_list,\n\t\t\t\t    dev_list)\n\t\t\tif (dp->target == sdp->id) {\n\t\t\t\tset_bit(SDEBUG_UA_BUS_RESET, dp->uas_bm);\n\t\t\t\tif (devip != dp)\n\t\t\t\t\tset_bit(SDEBUG_UA_MICROCODE_CHANGED,\n\t\t\t\t\t\tdp->uas_bm);\n\t\t\t}\n\t\tbreak;\n\tcase 0x7:\t \n\t\t \n\t\tlist_for_each_entry(dp,\n\t\t\t\t    &devip->sdbg_host->dev_info_list,\n\t\t\t\t    dev_list)\n\t\t\tif (dp->target == sdp->id)\n\t\t\t\tset_bit(SDEBUG_UA_MICROCODE_CHANGED_WO_RESET,\n\t\t\t\t\tdp->uas_bm);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int resp_comp_write(struct scsi_cmnd *scp,\n\t\t\t   struct sdebug_dev_info *devip)\n{\n\tu8 *cmd = scp->cmnd;\n\tu8 *arr;\n\tstruct sdeb_store_info *sip = devip2sip(devip, true);\n\tu64 lba;\n\tu32 dnum;\n\tu32 lb_size = sdebug_sector_size;\n\tu8 num;\n\tint ret;\n\tint retval = 0;\n\n\tlba = get_unaligned_be64(cmd + 2);\n\tnum = cmd[13];\t\t \n\tif (0 == num)\n\t\treturn 0;\t \n\tif (sdebug_dif == T10_PI_TYPE2_PROTECTION &&\n\t    (cmd[1] & 0xe0)) {\n\t\tmk_sense_invalid_opcode(scp);\n\t\treturn check_condition_result;\n\t}\n\tif ((sdebug_dif == T10_PI_TYPE1_PROTECTION ||\n\t     sdebug_dif == T10_PI_TYPE3_PROTECTION) &&\n\t    (cmd[1] & 0xe0) == 0)\n\t\tsdev_printk(KERN_ERR, scp->device, \"Unprotected WR \"\n\t\t\t    \"to DIF device\\n\");\n\tret = check_device_access_params(scp, lba, num, false);\n\tif (ret)\n\t\treturn ret;\n\tdnum = 2 * num;\n\tarr = kcalloc(lb_size, dnum, GFP_ATOMIC);\n\tif (NULL == arr) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INSUFF_RES_ASC,\n\t\t\t\tINSUFF_RES_ASCQ);\n\t\treturn check_condition_result;\n\t}\n\n\tsdeb_write_lock(sip);\n\n\tret = do_dout_fetch(scp, dnum, arr);\n\tif (ret == -1) {\n\t\tretval = DID_ERROR << 16;\n\t\tgoto cleanup;\n\t} else if (sdebug_verbose && (ret < (dnum * lb_size)))\n\t\tsdev_printk(KERN_INFO, scp->device, \"%s: compare_write: cdb \"\n\t\t\t    \"indicated=%u, IO sent=%d bytes\\n\", my_name,\n\t\t\t    dnum * lb_size, ret);\n\tif (!comp_write_worker(sip, lba, num, arr, false)) {\n\t\tmk_sense_buffer(scp, MISCOMPARE, MISCOMPARE_VERIFY_ASC, 0);\n\t\tretval = check_condition_result;\n\t\tgoto cleanup;\n\t}\n\tif (scsi_debug_lbp())\n\t\tmap_region(sip, lba, num);\ncleanup:\n\tsdeb_write_unlock(sip);\n\tkfree(arr);\n\treturn retval;\n}\n\nstruct unmap_block_desc {\n\t__be64\tlba;\n\t__be32\tblocks;\n\t__be32\t__reserved;\n};\n\nstatic int resp_unmap(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\n{\n\tunsigned char *buf;\n\tstruct unmap_block_desc *desc;\n\tstruct sdeb_store_info *sip = devip2sip(devip, true);\n\tunsigned int i, payload_len, descriptors;\n\tint ret;\n\n\tif (!scsi_debug_lbp())\n\t\treturn 0;\t \n\tpayload_len = get_unaligned_be16(scp->cmnd + 7);\n\tBUG_ON(scsi_bufflen(scp) != payload_len);\n\n\tdescriptors = (payload_len - 8) / 16;\n\tif (descriptors > sdebug_unmap_max_desc) {\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 7, -1);\n\t\treturn check_condition_result;\n\t}\n\n\tbuf = kzalloc(scsi_bufflen(scp), GFP_ATOMIC);\n\tif (!buf) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INSUFF_RES_ASC,\n\t\t\t\tINSUFF_RES_ASCQ);\n\t\treturn check_condition_result;\n\t}\n\n\tscsi_sg_copy_to_buffer(scp, buf, scsi_bufflen(scp));\n\n\tBUG_ON(get_unaligned_be16(&buf[0]) != payload_len - 2);\n\tBUG_ON(get_unaligned_be16(&buf[2]) != descriptors * 16);\n\n\tdesc = (void *)&buf[8];\n\n\tsdeb_write_lock(sip);\n\n\tfor (i = 0 ; i < descriptors ; i++) {\n\t\tunsigned long long lba = get_unaligned_be64(&desc[i].lba);\n\t\tunsigned int num = get_unaligned_be32(&desc[i].blocks);\n\n\t\tret = check_device_access_params(scp, lba, num, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tunmap_region(sip, lba, num);\n\t}\n\n\tret = 0;\n\nout:\n\tsdeb_write_unlock(sip);\n\tkfree(buf);\n\n\treturn ret;\n}\n\n#define SDEBUG_GET_LBA_STATUS_LEN 32\n\nstatic int resp_get_lba_status(struct scsi_cmnd *scp,\n\t\t\t       struct sdebug_dev_info *devip)\n{\n\tu8 *cmd = scp->cmnd;\n\tu64 lba;\n\tu32 alloc_len, mapped, num;\n\tint ret;\n\tu8 arr[SDEBUG_GET_LBA_STATUS_LEN];\n\n\tlba = get_unaligned_be64(cmd + 2);\n\talloc_len = get_unaligned_be32(cmd + 10);\n\n\tif (alloc_len < 24)\n\t\treturn 0;\n\n\tret = check_device_access_params(scp, lba, 1, false);\n\tif (ret)\n\t\treturn ret;\n\n\tif (scsi_debug_lbp()) {\n\t\tstruct sdeb_store_info *sip = devip2sip(devip, true);\n\n\t\tmapped = map_state(sip, lba, &num);\n\t} else {\n\t\tmapped = 1;\n\t\t \n\t\tsdebug_capacity = get_sdebug_capacity();\n\t\tif (sdebug_capacity - lba <= 0xffffffff)\n\t\t\tnum = sdebug_capacity - lba;\n\t\telse\n\t\t\tnum = 0xffffffff;\n\t}\n\n\tmemset(arr, 0, SDEBUG_GET_LBA_STATUS_LEN);\n\tput_unaligned_be32(20, arr);\t\t \n\tput_unaligned_be64(lba, arr + 8);\t \n\tput_unaligned_be32(num, arr + 16);\t \n\tarr[20] = !mapped;\t\t \n\n\treturn fill_from_dev_buffer(scp, arr, SDEBUG_GET_LBA_STATUS_LEN);\n}\n\nstatic int resp_sync_cache(struct scsi_cmnd *scp,\n\t\t\t   struct sdebug_dev_info *devip)\n{\n\tint res = 0;\n\tu64 lba;\n\tu32 num_blocks;\n\tu8 *cmd = scp->cmnd;\n\n\tif (cmd[0] == SYNCHRONIZE_CACHE) {\t \n\t\tlba = get_unaligned_be32(cmd + 2);\n\t\tnum_blocks = get_unaligned_be16(cmd + 7);\n\t} else {\t\t\t\t \n\t\tlba = get_unaligned_be64(cmd + 2);\n\t\tnum_blocks = get_unaligned_be32(cmd + 10);\n\t}\n\tif (lba + num_blocks > sdebug_capacity) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);\n\t\treturn check_condition_result;\n\t}\n\tif (!write_since_sync || (cmd[1] & 0x2))\n\t\tres = SDEG_RES_IMMED_MASK;\n\telse\t\t \n\t\twrite_since_sync = false;\n\treturn res;\n}\n\n \nstatic int resp_pre_fetch(struct scsi_cmnd *scp,\n\t\t\t  struct sdebug_dev_info *devip)\n{\n\tint res = 0;\n\tu64 lba;\n\tu64 block, rest = 0;\n\tu32 nblks;\n\tu8 *cmd = scp->cmnd;\n\tstruct sdeb_store_info *sip = devip2sip(devip, true);\n\tu8 *fsp = sip->storep;\n\n\tif (cmd[0] == PRE_FETCH) {\t \n\t\tlba = get_unaligned_be32(cmd + 2);\n\t\tnblks = get_unaligned_be16(cmd + 7);\n\t} else {\t\t\t \n\t\tlba = get_unaligned_be64(cmd + 2);\n\t\tnblks = get_unaligned_be32(cmd + 10);\n\t}\n\tif (lba + nblks > sdebug_capacity) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);\n\t\treturn check_condition_result;\n\t}\n\tif (!fsp)\n\t\tgoto fini;\n\t \n\tblock = do_div(lba, sdebug_store_sectors);\n\tif (block + nblks > sdebug_store_sectors)\n\t\trest = block + nblks - sdebug_store_sectors;\n\n\t \n\tsdeb_read_lock(sip);\n\tprefetch_range(fsp + (sdebug_sector_size * block),\n\t\t       (nblks - rest) * sdebug_sector_size);\n\tif (rest)\n\t\tprefetch_range(fsp, rest * sdebug_sector_size);\n\tsdeb_read_unlock(sip);\nfini:\n\tif (cmd[1] & 0x2)\n\t\tres = SDEG_RES_IMMED_MASK;\n\treturn res | condition_met_result;\n}\n\n#define RL_BUCKET_ELEMS 8\n\n \nstatic int resp_report_luns(struct scsi_cmnd *scp,\n\t\t\t    struct sdebug_dev_info *devip)\n{\n\tunsigned char *cmd = scp->cmnd;\n\tunsigned int alloc_len;\n\tunsigned char select_report;\n\tu64 lun;\n\tstruct scsi_lun *lun_p;\n\tu8 arr[RL_BUCKET_ELEMS * sizeof(struct scsi_lun)];\n\tunsigned int lun_cnt;\t \n\tunsigned int wlun_cnt;\t \n\tunsigned int tlun_cnt;\t \n\tunsigned int rlen;\t \n\tint k, j, n, res;\n\tunsigned int off_rsp = 0;\n\tconst int sz_lun = sizeof(struct scsi_lun);\n\n\tclear_luns_changed_on_target(devip);\n\n\tselect_report = cmd[2];\n\talloc_len = get_unaligned_be32(cmd + 6);\n\n\tif (alloc_len < 4) {\n\t\tpr_err(\"alloc len too small %d\\n\", alloc_len);\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 6, -1);\n\t\treturn check_condition_result;\n\t}\n\n\tswitch (select_report) {\n\tcase 0:\t\t \n\t\tlun_cnt = sdebug_max_luns;\n\t\twlun_cnt = 0;\n\t\tbreak;\n\tcase 1:\t\t \n\t\tlun_cnt = 0;\n\t\twlun_cnt = 1;\n\t\tbreak;\n\tcase 2:\t\t \n\t\tlun_cnt = sdebug_max_luns;\n\t\twlun_cnt = 1;\n\t\tbreak;\n\tcase 0x10:\t \n\tcase 0x11:\t \n\tcase 0x12:\t \n\tdefault:\n\t\tpr_debug(\"select report invalid %d\\n\", select_report);\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 2, -1);\n\t\treturn check_condition_result;\n\t}\n\n\tif (sdebug_no_lun_0 && (lun_cnt > 0))\n\t\t--lun_cnt;\n\n\ttlun_cnt = lun_cnt + wlun_cnt;\n\trlen = tlun_cnt * sz_lun;\t \n\tscsi_set_resid(scp, scsi_bufflen(scp));\n\tpr_debug(\"select_report %d luns = %d wluns = %d no_lun0 %d\\n\",\n\t\t select_report, lun_cnt, wlun_cnt, sdebug_no_lun_0);\n\n\t \n\tlun = sdebug_no_lun_0 ? 1 : 0;\n\tfor (k = 0, j = 0, res = 0; true; ++k, j = 0) {\n\t\tmemset(arr, 0, sizeof(arr));\n\t\tlun_p = (struct scsi_lun *)&arr[0];\n\t\tif (k == 0) {\n\t\t\tput_unaligned_be32(rlen, &arr[0]);\n\t\t\t++lun_p;\n\t\t\tj = 1;\n\t\t}\n\t\tfor ( ; j < RL_BUCKET_ELEMS; ++j, ++lun_p) {\n\t\t\tif ((k * RL_BUCKET_ELEMS) + j > lun_cnt)\n\t\t\t\tbreak;\n\t\t\tint_to_scsilun(lun++, lun_p);\n\t\t\tif (lun > 1 && sdebug_lun_am == SAM_LUN_AM_FLAT)\n\t\t\t\tlun_p->scsi_lun[0] |= 0x40;\n\t\t}\n\t\tif (j < RL_BUCKET_ELEMS)\n\t\t\tbreak;\n\t\tn = j * sz_lun;\n\t\tres = p_fill_from_dev_buffer(scp, arr, n, off_rsp);\n\t\tif (res)\n\t\t\treturn res;\n\t\toff_rsp += n;\n\t}\n\tif (wlun_cnt) {\n\t\tint_to_scsilun(SCSI_W_LUN_REPORT_LUNS, lun_p);\n\t\t++j;\n\t}\n\tif (j > 0)\n\t\tres = p_fill_from_dev_buffer(scp, arr, j * sz_lun, off_rsp);\n\treturn res;\n}\n\nstatic int resp_verify(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\n{\n\tbool is_bytchk3 = false;\n\tu8 bytchk;\n\tint ret, j;\n\tu32 vnum, a_num, off;\n\tconst u32 lb_size = sdebug_sector_size;\n\tu64 lba;\n\tu8 *arr;\n\tu8 *cmd = scp->cmnd;\n\tstruct sdeb_store_info *sip = devip2sip(devip, true);\n\n\tbytchk = (cmd[1] >> 1) & 0x3;\n\tif (bytchk == 0) {\n\t\treturn 0;\t \n\t} else if (bytchk == 2) {\n\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 2, 2);\n\t\treturn check_condition_result;\n\t} else if (bytchk == 3) {\n\t\tis_bytchk3 = true;\t \n\t}\n\tswitch (cmd[0]) {\n\tcase VERIFY_16:\n\t\tlba = get_unaligned_be64(cmd + 2);\n\t\tvnum = get_unaligned_be32(cmd + 10);\n\t\tbreak;\n\tcase VERIFY:\t\t \n\t\tlba = get_unaligned_be32(cmd + 2);\n\t\tvnum = get_unaligned_be16(cmd + 7);\n\t\tbreak;\n\tdefault:\n\t\tmk_sense_invalid_opcode(scp);\n\t\treturn check_condition_result;\n\t}\n\tif (vnum == 0)\n\t\treturn 0;\t \n\ta_num = is_bytchk3 ? 1 : vnum;\n\t \n\tret = check_device_access_params(scp, lba, a_num, false);\n\tif (ret)\n\t\treturn ret;\n\n\tarr = kcalloc(lb_size, vnum, GFP_ATOMIC | __GFP_NOWARN);\n\tif (!arr) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INSUFF_RES_ASC,\n\t\t\t\tINSUFF_RES_ASCQ);\n\t\treturn check_condition_result;\n\t}\n\t \n\tsdeb_read_lock(sip);\n\n\tret = do_dout_fetch(scp, a_num, arr);\n\tif (ret == -1) {\n\t\tret = DID_ERROR << 16;\n\t\tgoto cleanup;\n\t} else if (sdebug_verbose && (ret < (a_num * lb_size))) {\n\t\tsdev_printk(KERN_INFO, scp->device,\n\t\t\t    \"%s: %s: cdb indicated=%u, IO sent=%d bytes\\n\",\n\t\t\t    my_name, __func__, a_num * lb_size, ret);\n\t}\n\tif (is_bytchk3) {\n\t\tfor (j = 1, off = lb_size; j < vnum; ++j, off += lb_size)\n\t\t\tmemcpy(arr + off, arr, lb_size);\n\t}\n\tret = 0;\n\tif (!comp_write_worker(sip, lba, vnum, arr, true)) {\n\t\tmk_sense_buffer(scp, MISCOMPARE, MISCOMPARE_VERIFY_ASC, 0);\n\t\tret = check_condition_result;\n\t\tgoto cleanup;\n\t}\ncleanup:\n\tsdeb_read_unlock(sip);\n\tkfree(arr);\n\treturn ret;\n}\n\n#define RZONES_DESC_HD 64\n\n \nstatic int resp_report_zones(struct scsi_cmnd *scp,\n\t\t\t     struct sdebug_dev_info *devip)\n{\n\tunsigned int rep_max_zones, nrz = 0;\n\tint ret = 0;\n\tu32 alloc_len, rep_opts, rep_len;\n\tbool partial;\n\tu64 lba, zs_lba;\n\tu8 *arr = NULL, *desc;\n\tu8 *cmd = scp->cmnd;\n\tstruct sdeb_zone_state *zsp = NULL;\n\tstruct sdeb_store_info *sip = devip2sip(devip, false);\n\n\tif (!sdebug_dev_is_zoned(devip)) {\n\t\tmk_sense_invalid_opcode(scp);\n\t\treturn check_condition_result;\n\t}\n\tzs_lba = get_unaligned_be64(cmd + 2);\n\talloc_len = get_unaligned_be32(cmd + 10);\n\tif (alloc_len == 0)\n\t\treturn 0;\t \n\trep_opts = cmd[14] & 0x3f;\n\tpartial = cmd[14] & 0x80;\n\n\tif (zs_lba >= sdebug_capacity) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);\n\t\treturn check_condition_result;\n\t}\n\n\trep_max_zones = (alloc_len - 64) >> ilog2(RZONES_DESC_HD);\n\n\tarr = kzalloc(alloc_len, GFP_ATOMIC | __GFP_NOWARN);\n\tif (!arr) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INSUFF_RES_ASC,\n\t\t\t\tINSUFF_RES_ASCQ);\n\t\treturn check_condition_result;\n\t}\n\n\tsdeb_read_lock(sip);\n\n\tdesc = arr + 64;\n\tfor (lba = zs_lba; lba < sdebug_capacity;\n\t     lba = zsp->z_start + zsp->z_size) {\n\t\tif (WARN_ONCE(zbc_zone(devip, lba) == zsp, \"lba = %llu\\n\", lba))\n\t\t\tbreak;\n\t\tzsp = zbc_zone(devip, lba);\n\t\tswitch (rep_opts) {\n\t\tcase 0x00:\n\t\t\t \n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\t \n\t\t\tif (zsp->z_cond != ZC1_EMPTY)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\t \n\t\t\tif (zsp->z_cond != ZC2_IMPLICIT_OPEN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\t \n\t\t\tif (zsp->z_cond != ZC3_EXPLICIT_OPEN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase 0x04:\n\t\t\t \n\t\t\tif (zsp->z_cond != ZC4_CLOSED)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\t \n\t\t\tif (zsp->z_cond != ZC5_FULL)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase 0x06:\n\t\tcase 0x07:\n\t\tcase 0x10:\n\t\t\t \n\t\t\tcontinue;\n\t\tcase 0x11:\n\t\t\t \n\t\t\tif (!zsp->z_non_seq_resource)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase 0x3e:\n\t\t\t \n\t\t\tif (zbc_zone_is_gap(zsp))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase 0x3f:\n\t\t\t \n\t\t\tif (zbc_zone_is_seq(zsp))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST,\n\t\t\t\t\tINVALID_FIELD_IN_CDB, 0);\n\t\t\tret = check_condition_result;\n\t\t\tgoto fini;\n\t\t}\n\n\t\tif (nrz < rep_max_zones) {\n\t\t\t \n\t\t\tdesc[0] = zsp->z_type;\n\t\t\tdesc[1] = zsp->z_cond << 4;\n\t\t\tif (zsp->z_non_seq_resource)\n\t\t\t\tdesc[1] |= 1 << 1;\n\t\t\tput_unaligned_be64((u64)zsp->z_size, desc + 8);\n\t\t\tput_unaligned_be64((u64)zsp->z_start, desc + 16);\n\t\t\tput_unaligned_be64((u64)zsp->z_wp, desc + 24);\n\t\t\tdesc += 64;\n\t\t}\n\n\t\tif (partial && nrz >= rep_max_zones)\n\t\t\tbreak;\n\n\t\tnrz++;\n\t}\n\n\t \n\t \n\tput_unaligned_be32(nrz * RZONES_DESC_HD, arr + 0);\n\t \n\tput_unaligned_be64(sdebug_capacity - 1, arr + 8);\n\t \n\tif (devip->zcap < devip->zsize)\n\t\tput_unaligned_be64(devip->zsize, arr + 16);\n\n\trep_len = (unsigned long)desc - (unsigned long)arr;\n\tret = fill_from_dev_buffer(scp, arr, min_t(u32, alloc_len, rep_len));\n\nfini:\n\tsdeb_read_unlock(sip);\n\tkfree(arr);\n\treturn ret;\n}\n\n \nstatic void zbc_open_all(struct sdebug_dev_info *devip)\n{\n\tstruct sdeb_zone_state *zsp = &devip->zstate[0];\n\tunsigned int i;\n\n\tfor (i = 0; i < devip->nr_zones; i++, zsp++) {\n\t\tif (zsp->z_cond == ZC4_CLOSED)\n\t\t\tzbc_open_zone(devip, &devip->zstate[i], true);\n\t}\n}\n\nstatic int resp_open_zone(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\n{\n\tint res = 0;\n\tu64 z_id;\n\tenum sdebug_z_cond zc;\n\tu8 *cmd = scp->cmnd;\n\tstruct sdeb_zone_state *zsp;\n\tbool all = cmd[14] & 0x01;\n\tstruct sdeb_store_info *sip = devip2sip(devip, false);\n\n\tif (!sdebug_dev_is_zoned(devip)) {\n\t\tmk_sense_invalid_opcode(scp);\n\t\treturn check_condition_result;\n\t}\n\n\tsdeb_write_lock(sip);\n\n\tif (all) {\n\t\t \n\t\tif (devip->max_open &&\n\t\t    devip->nr_exp_open + devip->nr_closed > devip->max_open) {\n\t\t\tmk_sense_buffer(scp, DATA_PROTECT, INSUFF_RES_ASC,\n\t\t\t\t\tINSUFF_ZONE_ASCQ);\n\t\t\tres = check_condition_result;\n\t\t\tgoto fini;\n\t\t}\n\t\t \n\t\tzbc_open_all(devip);\n\t\tgoto fini;\n\t}\n\n\t \n\tz_id = get_unaligned_be64(cmd + 2);\n\tif (z_id >= sdebug_capacity) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);\n\t\tres = check_condition_result;\n\t\tgoto fini;\n\t}\n\n\tzsp = zbc_zone(devip, z_id);\n\tif (z_id != zsp->z_start) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\n\t\tres = check_condition_result;\n\t\tgoto fini;\n\t}\n\tif (zbc_zone_is_conv(zsp)) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\n\t\tres = check_condition_result;\n\t\tgoto fini;\n\t}\n\n\tzc = zsp->z_cond;\n\tif (zc == ZC3_EXPLICIT_OPEN || zc == ZC5_FULL)\n\t\tgoto fini;\n\n\tif (devip->max_open && devip->nr_exp_open >= devip->max_open) {\n\t\tmk_sense_buffer(scp, DATA_PROTECT, INSUFF_RES_ASC,\n\t\t\t\tINSUFF_ZONE_ASCQ);\n\t\tres = check_condition_result;\n\t\tgoto fini;\n\t}\n\n\tzbc_open_zone(devip, zsp, true);\nfini:\n\tsdeb_write_unlock(sip);\n\treturn res;\n}\n\nstatic void zbc_close_all(struct sdebug_dev_info *devip)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < devip->nr_zones; i++)\n\t\tzbc_close_zone(devip, &devip->zstate[i]);\n}\n\nstatic int resp_close_zone(struct scsi_cmnd *scp,\n\t\t\t   struct sdebug_dev_info *devip)\n{\n\tint res = 0;\n\tu64 z_id;\n\tu8 *cmd = scp->cmnd;\n\tstruct sdeb_zone_state *zsp;\n\tbool all = cmd[14] & 0x01;\n\tstruct sdeb_store_info *sip = devip2sip(devip, false);\n\n\tif (!sdebug_dev_is_zoned(devip)) {\n\t\tmk_sense_invalid_opcode(scp);\n\t\treturn check_condition_result;\n\t}\n\n\tsdeb_write_lock(sip);\n\n\tif (all) {\n\t\tzbc_close_all(devip);\n\t\tgoto fini;\n\t}\n\n\t \n\tz_id = get_unaligned_be64(cmd + 2);\n\tif (z_id >= sdebug_capacity) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);\n\t\tres = check_condition_result;\n\t\tgoto fini;\n\t}\n\n\tzsp = zbc_zone(devip, z_id);\n\tif (z_id != zsp->z_start) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\n\t\tres = check_condition_result;\n\t\tgoto fini;\n\t}\n\tif (zbc_zone_is_conv(zsp)) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\n\t\tres = check_condition_result;\n\t\tgoto fini;\n\t}\n\n\tzbc_close_zone(devip, zsp);\nfini:\n\tsdeb_write_unlock(sip);\n\treturn res;\n}\n\nstatic void zbc_finish_zone(struct sdebug_dev_info *devip,\n\t\t\t    struct sdeb_zone_state *zsp, bool empty)\n{\n\tenum sdebug_z_cond zc = zsp->z_cond;\n\n\tif (zc == ZC4_CLOSED || zc == ZC2_IMPLICIT_OPEN ||\n\t    zc == ZC3_EXPLICIT_OPEN || (empty && zc == ZC1_EMPTY)) {\n\t\tif (zc == ZC2_IMPLICIT_OPEN || zc == ZC3_EXPLICIT_OPEN)\n\t\t\tzbc_close_zone(devip, zsp);\n\t\tif (zsp->z_cond == ZC4_CLOSED)\n\t\t\tdevip->nr_closed--;\n\t\tzsp->z_wp = zsp->z_start + zsp->z_size;\n\t\tzsp->z_cond = ZC5_FULL;\n\t}\n}\n\nstatic void zbc_finish_all(struct sdebug_dev_info *devip)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < devip->nr_zones; i++)\n\t\tzbc_finish_zone(devip, &devip->zstate[i], false);\n}\n\nstatic int resp_finish_zone(struct scsi_cmnd *scp,\n\t\t\t    struct sdebug_dev_info *devip)\n{\n\tstruct sdeb_zone_state *zsp;\n\tint res = 0;\n\tu64 z_id;\n\tu8 *cmd = scp->cmnd;\n\tbool all = cmd[14] & 0x01;\n\tstruct sdeb_store_info *sip = devip2sip(devip, false);\n\n\tif (!sdebug_dev_is_zoned(devip)) {\n\t\tmk_sense_invalid_opcode(scp);\n\t\treturn check_condition_result;\n\t}\n\n\tsdeb_write_lock(sip);\n\n\tif (all) {\n\t\tzbc_finish_all(devip);\n\t\tgoto fini;\n\t}\n\n\t \n\tz_id = get_unaligned_be64(cmd + 2);\n\tif (z_id >= sdebug_capacity) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);\n\t\tres = check_condition_result;\n\t\tgoto fini;\n\t}\n\n\tzsp = zbc_zone(devip, z_id);\n\tif (z_id != zsp->z_start) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\n\t\tres = check_condition_result;\n\t\tgoto fini;\n\t}\n\tif (zbc_zone_is_conv(zsp)) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\n\t\tres = check_condition_result;\n\t\tgoto fini;\n\t}\n\n\tzbc_finish_zone(devip, zsp, true);\nfini:\n\tsdeb_write_unlock(sip);\n\treturn res;\n}\n\nstatic void zbc_rwp_zone(struct sdebug_dev_info *devip,\n\t\t\t struct sdeb_zone_state *zsp)\n{\n\tenum sdebug_z_cond zc;\n\tstruct sdeb_store_info *sip = devip2sip(devip, false);\n\n\tif (!zbc_zone_is_seq(zsp))\n\t\treturn;\n\n\tzc = zsp->z_cond;\n\tif (zc == ZC2_IMPLICIT_OPEN || zc == ZC3_EXPLICIT_OPEN)\n\t\tzbc_close_zone(devip, zsp);\n\n\tif (zsp->z_cond == ZC4_CLOSED)\n\t\tdevip->nr_closed--;\n\n\tif (zsp->z_wp > zsp->z_start)\n\t\tmemset(sip->storep + zsp->z_start * sdebug_sector_size, 0,\n\t\t       (zsp->z_wp - zsp->z_start) * sdebug_sector_size);\n\n\tzsp->z_non_seq_resource = false;\n\tzsp->z_wp = zsp->z_start;\n\tzsp->z_cond = ZC1_EMPTY;\n}\n\nstatic void zbc_rwp_all(struct sdebug_dev_info *devip)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < devip->nr_zones; i++)\n\t\tzbc_rwp_zone(devip, &devip->zstate[i]);\n}\n\nstatic int resp_rwp_zone(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\n{\n\tstruct sdeb_zone_state *zsp;\n\tint res = 0;\n\tu64 z_id;\n\tu8 *cmd = scp->cmnd;\n\tbool all = cmd[14] & 0x01;\n\tstruct sdeb_store_info *sip = devip2sip(devip, false);\n\n\tif (!sdebug_dev_is_zoned(devip)) {\n\t\tmk_sense_invalid_opcode(scp);\n\t\treturn check_condition_result;\n\t}\n\n\tsdeb_write_lock(sip);\n\n\tif (all) {\n\t\tzbc_rwp_all(devip);\n\t\tgoto fini;\n\t}\n\n\tz_id = get_unaligned_be64(cmd + 2);\n\tif (z_id >= sdebug_capacity) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);\n\t\tres = check_condition_result;\n\t\tgoto fini;\n\t}\n\n\tzsp = zbc_zone(devip, z_id);\n\tif (z_id != zsp->z_start) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\n\t\tres = check_condition_result;\n\t\tgoto fini;\n\t}\n\tif (zbc_zone_is_conv(zsp)) {\n\t\tmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\n\t\tres = check_condition_result;\n\t\tgoto fini;\n\t}\n\n\tzbc_rwp_zone(devip, zsp);\nfini:\n\tsdeb_write_unlock(sip);\n\treturn res;\n}\n\nstatic u32 get_tag(struct scsi_cmnd *cmnd)\n{\n\treturn blk_mq_unique_tag(scsi_cmd_to_rq(cmnd));\n}\n\n \nstatic void sdebug_q_cmd_complete(struct sdebug_defer *sd_dp)\n{\n\tstruct sdebug_queued_cmd *sqcp = container_of(sd_dp, struct sdebug_queued_cmd, sd_dp);\n\tunsigned long flags;\n\tstruct scsi_cmnd *scp = sqcp->scmd;\n\tstruct sdebug_scsi_cmd *sdsc;\n\tbool aborted;\n\n\tif (sdebug_statistics) {\n\t\tatomic_inc(&sdebug_completions);\n\t\tif (raw_smp_processor_id() != sd_dp->issuing_cpu)\n\t\t\tatomic_inc(&sdebug_miss_cpus);\n\t}\n\n\tif (!scp) {\n\t\tpr_err(\"scmd=NULL\\n\");\n\t\tgoto out;\n\t}\n\n\tsdsc = scsi_cmd_priv(scp);\n\tspin_lock_irqsave(&sdsc->lock, flags);\n\taborted = sd_dp->aborted;\n\tif (unlikely(aborted))\n\t\tsd_dp->aborted = false;\n\tASSIGN_QUEUED_CMD(scp, NULL);\n\n\tspin_unlock_irqrestore(&sdsc->lock, flags);\n\n\tif (aborted) {\n\t\tpr_info(\"bypassing scsi_done() due to aborted cmd, kicking-off EH\\n\");\n\t\tblk_abort_request(scsi_cmd_to_rq(scp));\n\t\tgoto out;\n\t}\n\n\tscsi_done(scp);  \nout:\n\tsdebug_free_queued_cmd(sqcp);\n}\n\n \nstatic enum hrtimer_restart sdebug_q_cmd_hrt_complete(struct hrtimer *timer)\n{\n\tstruct sdebug_defer *sd_dp = container_of(timer, struct sdebug_defer,\n\t\t\t\t\t\t  hrt);\n\tsdebug_q_cmd_complete(sd_dp);\n\treturn HRTIMER_NORESTART;\n}\n\n \nstatic void sdebug_q_cmd_wq_complete(struct work_struct *work)\n{\n\tstruct sdebug_defer *sd_dp = container_of(work, struct sdebug_defer,\n\t\t\t\t\t\t  ew.work);\n\tsdebug_q_cmd_complete(sd_dp);\n}\n\nstatic bool got_shared_uuid;\nstatic uuid_t shared_uuid;\n\nstatic int sdebug_device_create_zones(struct sdebug_dev_info *devip)\n{\n\tstruct sdeb_zone_state *zsp;\n\tsector_t capacity = get_sdebug_capacity();\n\tsector_t conv_capacity;\n\tsector_t zstart = 0;\n\tunsigned int i;\n\n\t \n\tif (!sdeb_zbc_zone_size_mb) {\n\t\tdevip->zsize = (DEF_ZBC_ZONE_SIZE_MB * SZ_1M)\n\t\t\t>> ilog2(sdebug_sector_size);\n\t\twhile (capacity < devip->zsize << 2 && devip->zsize >= 2)\n\t\t\tdevip->zsize >>= 1;\n\t\tif (devip->zsize < 2) {\n\t\t\tpr_err(\"Device capacity too small\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (!is_power_of_2(sdeb_zbc_zone_size_mb)) {\n\t\t\tpr_err(\"Zone size is not a power of 2\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdevip->zsize = (sdeb_zbc_zone_size_mb * SZ_1M)\n\t\t\t>> ilog2(sdebug_sector_size);\n\t\tif (devip->zsize >= capacity) {\n\t\t\tpr_err(\"Zone size too large for device capacity\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdevip->zsize_shift = ilog2(devip->zsize);\n\tdevip->nr_zones = (capacity + devip->zsize - 1) >> devip->zsize_shift;\n\n\tif (sdeb_zbc_zone_cap_mb == 0) {\n\t\tdevip->zcap = devip->zsize;\n\t} else {\n\t\tdevip->zcap = (sdeb_zbc_zone_cap_mb * SZ_1M) >>\n\t\t\t      ilog2(sdebug_sector_size);\n\t\tif (devip->zcap > devip->zsize) {\n\t\t\tpr_err(\"Zone capacity too large\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tconv_capacity = (sector_t)sdeb_zbc_nr_conv << devip->zsize_shift;\n\tif (conv_capacity >= capacity) {\n\t\tpr_err(\"Number of conventional zones too large\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdevip->nr_conv_zones = sdeb_zbc_nr_conv;\n\tdevip->nr_seq_zones = ALIGN(capacity - conv_capacity, devip->zsize) >>\n\t\t\t      devip->zsize_shift;\n\tdevip->nr_zones = devip->nr_conv_zones + devip->nr_seq_zones;\n\n\t \n\tif (devip->zcap < devip->zsize)\n\t\tdevip->nr_zones += devip->nr_seq_zones;\n\n\tif (devip->zmodel == BLK_ZONED_HM) {\n\t\t \n\t\tif (sdeb_zbc_max_open >= devip->nr_zones - 1)\n\t\t\tdevip->max_open = (devip->nr_zones - 1) / 2;\n\t\telse\n\t\t\tdevip->max_open = sdeb_zbc_max_open;\n\t}\n\n\tdevip->zstate = kcalloc(devip->nr_zones,\n\t\t\t\tsizeof(struct sdeb_zone_state), GFP_KERNEL);\n\tif (!devip->zstate)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < devip->nr_zones; i++) {\n\t\tzsp = &devip->zstate[i];\n\n\t\tzsp->z_start = zstart;\n\n\t\tif (i < devip->nr_conv_zones) {\n\t\t\tzsp->z_type = ZBC_ZTYPE_CNV;\n\t\t\tzsp->z_cond = ZBC_NOT_WRITE_POINTER;\n\t\t\tzsp->z_wp = (sector_t)-1;\n\t\t\tzsp->z_size =\n\t\t\t\tmin_t(u64, devip->zsize, capacity - zstart);\n\t\t} else if ((zstart & (devip->zsize - 1)) == 0) {\n\t\t\tif (devip->zmodel == BLK_ZONED_HM)\n\t\t\t\tzsp->z_type = ZBC_ZTYPE_SWR;\n\t\t\telse\n\t\t\t\tzsp->z_type = ZBC_ZTYPE_SWP;\n\t\t\tzsp->z_cond = ZC1_EMPTY;\n\t\t\tzsp->z_wp = zsp->z_start;\n\t\t\tzsp->z_size =\n\t\t\t\tmin_t(u64, devip->zcap, capacity - zstart);\n\t\t} else {\n\t\t\tzsp->z_type = ZBC_ZTYPE_GAP;\n\t\t\tzsp->z_cond = ZBC_NOT_WRITE_POINTER;\n\t\t\tzsp->z_wp = (sector_t)-1;\n\t\t\tzsp->z_size = min_t(u64, devip->zsize - devip->zcap,\n\t\t\t\t\t    capacity - zstart);\n\t\t}\n\n\t\tWARN_ON_ONCE((int)zsp->z_size <= 0);\n\t\tzstart += zsp->z_size;\n\t}\n\n\treturn 0;\n}\n\nstatic struct sdebug_dev_info *sdebug_device_create(\n\t\t\tstruct sdebug_host_info *sdbg_host, gfp_t flags)\n{\n\tstruct sdebug_dev_info *devip;\n\n\tdevip = kzalloc(sizeof(*devip), flags);\n\tif (devip) {\n\t\tif (sdebug_uuid_ctl == 1)\n\t\t\tuuid_gen(&devip->lu_name);\n\t\telse if (sdebug_uuid_ctl == 2) {\n\t\t\tif (got_shared_uuid)\n\t\t\t\tdevip->lu_name = shared_uuid;\n\t\t\telse {\n\t\t\t\tuuid_gen(&shared_uuid);\n\t\t\t\tgot_shared_uuid = true;\n\t\t\t\tdevip->lu_name = shared_uuid;\n\t\t\t}\n\t\t}\n\t\tdevip->sdbg_host = sdbg_host;\n\t\tif (sdeb_zbc_in_use) {\n\t\t\tdevip->zmodel = sdeb_zbc_model;\n\t\t\tif (sdebug_device_create_zones(devip)) {\n\t\t\t\tkfree(devip);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tdevip->zmodel = BLK_ZONED_NONE;\n\t\t}\n\t\tdevip->create_ts = ktime_get_boottime();\n\t\tatomic_set(&devip->stopped, (sdeb_tur_ms_to_ready > 0 ? 2 : 0));\n\t\tlist_add_tail(&devip->dev_list, &sdbg_host->dev_info_list);\n\t}\n\treturn devip;\n}\n\nstatic struct sdebug_dev_info *find_build_dev_info(struct scsi_device *sdev)\n{\n\tstruct sdebug_host_info *sdbg_host;\n\tstruct sdebug_dev_info *open_devip = NULL;\n\tstruct sdebug_dev_info *devip;\n\n\tsdbg_host = shost_to_sdebug_host(sdev->host);\n\n\tlist_for_each_entry(devip, &sdbg_host->dev_info_list, dev_list) {\n\t\tif ((devip->used) && (devip->channel == sdev->channel) &&\n\t\t    (devip->target == sdev->id) &&\n\t\t    (devip->lun == sdev->lun))\n\t\t\treturn devip;\n\t\telse {\n\t\t\tif ((!devip->used) && (!open_devip))\n\t\t\t\topen_devip = devip;\n\t\t}\n\t}\n\tif (!open_devip) {  \n\t\topen_devip = sdebug_device_create(sdbg_host, GFP_ATOMIC);\n\t\tif (!open_devip) {\n\t\t\tpr_err(\"out of memory at line %d\\n\", __LINE__);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\topen_devip->channel = sdev->channel;\n\topen_devip->target = sdev->id;\n\topen_devip->lun = sdev->lun;\n\topen_devip->sdbg_host = sdbg_host;\n\tset_bit(SDEBUG_UA_POOCCUR, open_devip->uas_bm);\n\topen_devip->used = true;\n\treturn open_devip;\n}\n\nstatic int scsi_debug_slave_alloc(struct scsi_device *sdp)\n{\n\tif (sdebug_verbose)\n\t\tpr_info(\"slave_alloc <%u %u %u %llu>\\n\",\n\t\t       sdp->host->host_no, sdp->channel, sdp->id, sdp->lun);\n\treturn 0;\n}\n\nstatic int scsi_debug_slave_configure(struct scsi_device *sdp)\n{\n\tstruct sdebug_dev_info *devip =\n\t\t\t(struct sdebug_dev_info *)sdp->hostdata;\n\n\tif (sdebug_verbose)\n\t\tpr_info(\"slave_configure <%u %u %u %llu>\\n\",\n\t\t       sdp->host->host_no, sdp->channel, sdp->id, sdp->lun);\n\tif (sdp->host->max_cmd_len != SDEBUG_MAX_CMD_LEN)\n\t\tsdp->host->max_cmd_len = SDEBUG_MAX_CMD_LEN;\n\tif (devip == NULL) {\n\t\tdevip = find_build_dev_info(sdp);\n\t\tif (devip == NULL)\n\t\t\treturn 1;   \n\t}\n\tsdp->hostdata = devip;\n\tif (sdebug_no_uld)\n\t\tsdp->no_uld_attach = 1;\n\tconfig_cdb_len(sdp);\n\treturn 0;\n}\n\nstatic void scsi_debug_slave_destroy(struct scsi_device *sdp)\n{\n\tstruct sdebug_dev_info *devip =\n\t\t(struct sdebug_dev_info *)sdp->hostdata;\n\n\tif (sdebug_verbose)\n\t\tpr_info(\"slave_destroy <%u %u %u %llu>\\n\",\n\t\t       sdp->host->host_no, sdp->channel, sdp->id, sdp->lun);\n\tif (devip) {\n\t\t \n\t\tdevip->used = false;\n\t\tsdp->hostdata = NULL;\n\t}\n}\n\n \nstatic bool stop_qc_helper(struct sdebug_defer *sd_dp,\n\t\t\t   enum sdeb_defer_type defer_t)\n{\n\tif (defer_t == SDEB_DEFER_HRT) {\n\t\tint res = hrtimer_try_to_cancel(&sd_dp->hrt);\n\n\t\tswitch (res) {\n\t\tcase 0:  \n\t\tcase -1:  \n\t\t\treturn false;\n\t\tcase 1:  \n\t\tdefault:\n\t\t\treturn true;\n\t\t}\n\t} else if (defer_t == SDEB_DEFER_WQ) {\n\t\t \n\t\tif (cancel_work_sync(&sd_dp->ew.work))\n\t\t\treturn true;\n\t\t \n\t\treturn false;\n\t} else if (defer_t == SDEB_DEFER_POLL) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\nstatic bool scsi_debug_stop_cmnd(struct scsi_cmnd *cmnd)\n{\n\tenum sdeb_defer_type l_defer_t;\n\tstruct sdebug_defer *sd_dp;\n\tstruct sdebug_scsi_cmd *sdsc = scsi_cmd_priv(cmnd);\n\tstruct sdebug_queued_cmd *sqcp = TO_QUEUED_CMD(cmnd);\n\n\tlockdep_assert_held(&sdsc->lock);\n\n\tif (!sqcp)\n\t\treturn false;\n\tsd_dp = &sqcp->sd_dp;\n\tl_defer_t = READ_ONCE(sd_dp->defer_t);\n\tASSIGN_QUEUED_CMD(cmnd, NULL);\n\n\tif (stop_qc_helper(sd_dp, l_defer_t))\n\t\tsdebug_free_queued_cmd(sqcp);\n\n\treturn true;\n}\n\n \nstatic bool scsi_debug_abort_cmnd(struct scsi_cmnd *cmnd)\n{\n\tstruct sdebug_scsi_cmd *sdsc = scsi_cmd_priv(cmnd);\n\tunsigned long flags;\n\tbool res;\n\n\tspin_lock_irqsave(&sdsc->lock, flags);\n\tres = scsi_debug_stop_cmnd(cmnd);\n\tspin_unlock_irqrestore(&sdsc->lock, flags);\n\n\treturn res;\n}\n\n \nstatic bool sdebug_stop_cmnd(struct request *rq, void *data)\n{\n\tscsi_debug_abort_cmnd(blk_mq_rq_to_pdu(rq));\n\n\treturn true;\n}\n\n \nstatic void stop_all_queued(void)\n{\n\tstruct sdebug_host_info *sdhp;\n\n\tmutex_lock(&sdebug_host_list_mutex);\n\tlist_for_each_entry(sdhp, &sdebug_host_list, host_list) {\n\t\tstruct Scsi_Host *shost = sdhp->shost;\n\n\t\tblk_mq_tagset_busy_iter(&shost->tag_set, sdebug_stop_cmnd, NULL);\n\t}\n\tmutex_unlock(&sdebug_host_list_mutex);\n}\n\nstatic int scsi_debug_abort(struct scsi_cmnd *SCpnt)\n{\n\tbool ok = scsi_debug_abort_cmnd(SCpnt);\n\n\t++num_aborts;\n\n\tif (SDEBUG_OPT_ALL_NOISE & sdebug_opts)\n\t\tsdev_printk(KERN_INFO, SCpnt->device,\n\t\t\t    \"%s: command%s found\\n\", __func__,\n\t\t\t    ok ? \"\" : \" not\");\n\n\treturn SUCCESS;\n}\n\nstatic bool scsi_debug_stop_all_queued_iter(struct request *rq, void *data)\n{\n\tstruct scsi_device *sdp = data;\n\tstruct scsi_cmnd *scmd = blk_mq_rq_to_pdu(rq);\n\n\tif (scmd->device == sdp)\n\t\tscsi_debug_abort_cmnd(scmd);\n\n\treturn true;\n}\n\n \nstatic void scsi_debug_stop_all_queued(struct scsi_device *sdp)\n{\n\tstruct Scsi_Host *shost = sdp->host;\n\n\tblk_mq_tagset_busy_iter(&shost->tag_set,\n\t\t\t\tscsi_debug_stop_all_queued_iter, sdp);\n}\n\nstatic int scsi_debug_device_reset(struct scsi_cmnd *SCpnt)\n{\n\tstruct scsi_device *sdp = SCpnt->device;\n\tstruct sdebug_dev_info *devip = sdp->hostdata;\n\n\t++num_dev_resets;\n\n\tif (SDEBUG_OPT_ALL_NOISE & sdebug_opts)\n\t\tsdev_printk(KERN_INFO, sdp, \"%s\\n\", __func__);\n\n\tscsi_debug_stop_all_queued(sdp);\n\tif (devip)\n\t\tset_bit(SDEBUG_UA_POR, devip->uas_bm);\n\n\treturn SUCCESS;\n}\n\nstatic int scsi_debug_target_reset(struct scsi_cmnd *SCpnt)\n{\n\tstruct scsi_device *sdp = SCpnt->device;\n\tstruct sdebug_host_info *sdbg_host = shost_to_sdebug_host(sdp->host);\n\tstruct sdebug_dev_info *devip;\n\tint k = 0;\n\n\t++num_target_resets;\n\tif (SDEBUG_OPT_ALL_NOISE & sdebug_opts)\n\t\tsdev_printk(KERN_INFO, sdp, \"%s\\n\", __func__);\n\n\tlist_for_each_entry(devip, &sdbg_host->dev_info_list, dev_list) {\n\t\tif (devip->target == sdp->id) {\n\t\t\tset_bit(SDEBUG_UA_BUS_RESET, devip->uas_bm);\n\t\t\t++k;\n\t\t}\n\t}\n\n\tif (SDEBUG_OPT_RESET_NOISE & sdebug_opts)\n\t\tsdev_printk(KERN_INFO, sdp,\n\t\t\t    \"%s: %d device(s) found in target\\n\", __func__, k);\n\n\treturn SUCCESS;\n}\n\nstatic int scsi_debug_bus_reset(struct scsi_cmnd *SCpnt)\n{\n\tstruct scsi_device *sdp = SCpnt->device;\n\tstruct sdebug_host_info *sdbg_host = shost_to_sdebug_host(sdp->host);\n\tstruct sdebug_dev_info *devip;\n\tint k = 0;\n\n\t++num_bus_resets;\n\n\tif (SDEBUG_OPT_ALL_NOISE & sdebug_opts)\n\t\tsdev_printk(KERN_INFO, sdp, \"%s\\n\", __func__);\n\n\tlist_for_each_entry(devip, &sdbg_host->dev_info_list, dev_list) {\n\t\tset_bit(SDEBUG_UA_BUS_RESET, devip->uas_bm);\n\t\t++k;\n\t}\n\n\tif (SDEBUG_OPT_RESET_NOISE & sdebug_opts)\n\t\tsdev_printk(KERN_INFO, sdp,\n\t\t\t    \"%s: %d device(s) found in host\\n\", __func__, k);\n\treturn SUCCESS;\n}\n\nstatic int scsi_debug_host_reset(struct scsi_cmnd *SCpnt)\n{\n\tstruct sdebug_host_info *sdbg_host;\n\tstruct sdebug_dev_info *devip;\n\tint k = 0;\n\n\t++num_host_resets;\n\tif (SDEBUG_OPT_ALL_NOISE & sdebug_opts)\n\t\tsdev_printk(KERN_INFO, SCpnt->device, \"%s\\n\", __func__);\n\tmutex_lock(&sdebug_host_list_mutex);\n\tlist_for_each_entry(sdbg_host, &sdebug_host_list, host_list) {\n\t\tlist_for_each_entry(devip, &sdbg_host->dev_info_list,\n\t\t\t\t    dev_list) {\n\t\t\tset_bit(SDEBUG_UA_BUS_RESET, devip->uas_bm);\n\t\t\t++k;\n\t\t}\n\t}\n\tmutex_unlock(&sdebug_host_list_mutex);\n\tstop_all_queued();\n\tif (SDEBUG_OPT_RESET_NOISE & sdebug_opts)\n\t\tsdev_printk(KERN_INFO, SCpnt->device,\n\t\t\t    \"%s: %d device(s) found\\n\", __func__, k);\n\treturn SUCCESS;\n}\n\nstatic void sdebug_build_parts(unsigned char *ramp, unsigned long store_size)\n{\n\tstruct msdos_partition *pp;\n\tint starts[SDEBUG_MAX_PARTS + 2], max_part_secs;\n\tint sectors_per_part, num_sectors, k;\n\tint heads_by_sects, start_sec, end_sec;\n\n\t \n\tif ((sdebug_num_parts < 1) || (store_size < 1048576))\n\t\treturn;\n\tif (sdebug_num_parts > SDEBUG_MAX_PARTS) {\n\t\tsdebug_num_parts = SDEBUG_MAX_PARTS;\n\t\tpr_warn(\"reducing partitions to %d\\n\", SDEBUG_MAX_PARTS);\n\t}\n\tnum_sectors = (int)get_sdebug_capacity();\n\tsectors_per_part = (num_sectors - sdebug_sectors_per)\n\t\t\t   / sdebug_num_parts;\n\theads_by_sects = sdebug_heads * sdebug_sectors_per;\n\tstarts[0] = sdebug_sectors_per;\n\tmax_part_secs = sectors_per_part;\n\tfor (k = 1; k < sdebug_num_parts; ++k) {\n\t\tstarts[k] = ((k * sectors_per_part) / heads_by_sects)\n\t\t\t    * heads_by_sects;\n\t\tif (starts[k] - starts[k - 1] < max_part_secs)\n\t\t\tmax_part_secs = starts[k] - starts[k - 1];\n\t}\n\tstarts[sdebug_num_parts] = num_sectors;\n\tstarts[sdebug_num_parts + 1] = 0;\n\n\tramp[510] = 0x55;\t \n\tramp[511] = 0xAA;\n\tpp = (struct msdos_partition *)(ramp + 0x1be);\n\tfor (k = 0; starts[k + 1]; ++k, ++pp) {\n\t\tstart_sec = starts[k];\n\t\tend_sec = starts[k] + max_part_secs - 1;\n\t\tpp->boot_ind = 0;\n\n\t\tpp->cyl = start_sec / heads_by_sects;\n\t\tpp->head = (start_sec - (pp->cyl * heads_by_sects))\n\t\t\t   / sdebug_sectors_per;\n\t\tpp->sector = (start_sec % sdebug_sectors_per) + 1;\n\n\t\tpp->end_cyl = end_sec / heads_by_sects;\n\t\tpp->end_head = (end_sec - (pp->end_cyl * heads_by_sects))\n\t\t\t       / sdebug_sectors_per;\n\t\tpp->end_sector = (end_sec % sdebug_sectors_per) + 1;\n\n\t\tpp->start_sect = cpu_to_le32(start_sec);\n\t\tpp->nr_sects = cpu_to_le32(end_sec - start_sec + 1);\n\t\tpp->sys_ind = 0x83;\t \n\t}\n}\n\nstatic void block_unblock_all_queues(bool block)\n{\n\tstruct sdebug_host_info *sdhp;\n\n\tlockdep_assert_held(&sdebug_host_list_mutex);\n\n\tlist_for_each_entry(sdhp, &sdebug_host_list, host_list) {\n\t\tstruct Scsi_Host *shost = sdhp->shost;\n\n\t\tif (block)\n\t\t\tscsi_block_requests(shost);\n\t\telse\n\t\t\tscsi_unblock_requests(shost);\n\t}\n}\n\n \nstatic void tweak_cmnd_count(void)\n{\n\tint count, modulo;\n\n\tmodulo = abs(sdebug_every_nth);\n\tif (modulo < 2)\n\t\treturn;\n\n\tmutex_lock(&sdebug_host_list_mutex);\n\tblock_unblock_all_queues(true);\n\tcount = atomic_read(&sdebug_cmnd_count);\n\tatomic_set(&sdebug_cmnd_count, (count / modulo) * modulo);\n\tblock_unblock_all_queues(false);\n\tmutex_unlock(&sdebug_host_list_mutex);\n}\n\nstatic void clear_queue_stats(void)\n{\n\tatomic_set(&sdebug_cmnd_count, 0);\n\tatomic_set(&sdebug_completions, 0);\n\tatomic_set(&sdebug_miss_cpus, 0);\n\tatomic_set(&sdebug_a_tsf, 0);\n}\n\nstatic bool inject_on_this_cmd(void)\n{\n\tif (sdebug_every_nth == 0)\n\t\treturn false;\n\treturn (atomic_read(&sdebug_cmnd_count) % abs(sdebug_every_nth)) == 0;\n}\n\n#define INCLUSIVE_TIMING_MAX_NS 1000000\t\t \n\n\nvoid sdebug_free_queued_cmd(struct sdebug_queued_cmd *sqcp)\n{\n\tif (sqcp)\n\t\tkmem_cache_free(queued_cmd_cache, sqcp);\n}\n\nstatic struct sdebug_queued_cmd *sdebug_alloc_queued_cmd(struct scsi_cmnd *scmd)\n{\n\tstruct sdebug_queued_cmd *sqcp;\n\tstruct sdebug_defer *sd_dp;\n\n\tsqcp = kmem_cache_zalloc(queued_cmd_cache, GFP_ATOMIC);\n\tif (!sqcp)\n\t\treturn NULL;\n\n\tsd_dp = &sqcp->sd_dp;\n\n\thrtimer_init(&sd_dp->hrt, CLOCK_MONOTONIC, HRTIMER_MODE_REL_PINNED);\n\tsd_dp->hrt.function = sdebug_q_cmd_hrt_complete;\n\tINIT_WORK(&sd_dp->ew.work, sdebug_q_cmd_wq_complete);\n\n\tsqcp->scmd = scmd;\n\n\treturn sqcp;\n}\n\n \nstatic int schedule_resp(struct scsi_cmnd *cmnd, struct sdebug_dev_info *devip,\n\t\t\t int scsi_result,\n\t\t\t int (*pfp)(struct scsi_cmnd *,\n\t\t\t\t    struct sdebug_dev_info *),\n\t\t\t int delta_jiff, int ndelay)\n{\n\tstruct request *rq = scsi_cmd_to_rq(cmnd);\n\tbool polled = rq->cmd_flags & REQ_POLLED;\n\tstruct sdebug_scsi_cmd *sdsc = scsi_cmd_priv(cmnd);\n\tunsigned long flags;\n\tu64 ns_from_boot = 0;\n\tstruct sdebug_queued_cmd *sqcp;\n\tstruct scsi_device *sdp;\n\tstruct sdebug_defer *sd_dp;\n\n\tif (unlikely(devip == NULL)) {\n\t\tif (scsi_result == 0)\n\t\t\tscsi_result = DID_NO_CONNECT << 16;\n\t\tgoto respond_in_thread;\n\t}\n\tsdp = cmnd->device;\n\n\tif (delta_jiff == 0)\n\t\tgoto respond_in_thread;\n\n\n\tif (unlikely(sdebug_every_nth && (SDEBUG_OPT_RARE_TSF & sdebug_opts) &&\n\t\t     (scsi_result == 0))) {\n\t\tint num_in_q = scsi_device_busy(sdp);\n\t\tint qdepth = cmnd->device->queue_depth;\n\n\t\tif ((num_in_q == qdepth) &&\n\t\t    (atomic_inc_return(&sdebug_a_tsf) >=\n\t\t     abs(sdebug_every_nth))) {\n\t\t\tatomic_set(&sdebug_a_tsf, 0);\n\t\t\tscsi_result = device_qfull_result;\n\n\t\t\tif (unlikely(SDEBUG_OPT_Q_NOISE & sdebug_opts))\n\t\t\t\tsdev_printk(KERN_INFO, sdp, \"%s: num_in_q=%d +1, <inject> status: TASK SET FULL\\n\",\n\t\t\t\t\t    __func__, num_in_q);\n\t\t}\n\t}\n\n\tsqcp = sdebug_alloc_queued_cmd(cmnd);\n\tif (!sqcp) {\n\t\tpr_err(\"%s no alloc\\n\", __func__);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\tsd_dp = &sqcp->sd_dp;\n\n\tif (polled)\n\t\tns_from_boot = ktime_get_boottime_ns();\n\n\t \n\tcmnd->result = pfp ? pfp(cmnd, devip) : 0;\n\tif (cmnd->result & SDEG_RES_IMMED_MASK) {\n\t\tcmnd->result &= ~SDEG_RES_IMMED_MASK;\n\t\tdelta_jiff = ndelay = 0;\n\t}\n\tif (cmnd->result == 0 && scsi_result != 0)\n\t\tcmnd->result = scsi_result;\n\tif (cmnd->result == 0 && unlikely(sdebug_opts & SDEBUG_OPT_TRANSPORT_ERR)) {\n\t\tif (atomic_read(&sdeb_inject_pending)) {\n\t\t\tmk_sense_buffer(cmnd, ABORTED_COMMAND, TRANSPORT_PROBLEM, ACK_NAK_TO);\n\t\t\tatomic_set(&sdeb_inject_pending, 0);\n\t\t\tcmnd->result = check_condition_result;\n\t\t}\n\t}\n\n\tif (unlikely(sdebug_verbose && cmnd->result))\n\t\tsdev_printk(KERN_INFO, sdp, \"%s: non-zero result=0x%x\\n\",\n\t\t\t    __func__, cmnd->result);\n\n\tif (delta_jiff > 0 || ndelay > 0) {\n\t\tktime_t kt;\n\n\t\tif (delta_jiff > 0) {\n\t\t\tu64 ns = jiffies_to_nsecs(delta_jiff);\n\n\t\t\tif (sdebug_random && ns < U32_MAX) {\n\t\t\t\tns = get_random_u32_below((u32)ns);\n\t\t\t} else if (sdebug_random) {\n\t\t\t\tns >>= 12;\t \n\t\t\t\tif (ns < U32_MAX)\t \n\t\t\t\t\tns = get_random_u32_below((u32)ns);\n\t\t\t\tns <<= 12;\n\t\t\t}\n\t\t\tkt = ns_to_ktime(ns);\n\t\t} else {\t \n\t\t\tkt = sdebug_random ? get_random_u32_below((u32)ndelay) :\n\t\t\t\t\t     (u32)ndelay;\n\t\t\tif (ndelay < INCLUSIVE_TIMING_MAX_NS) {\n\t\t\t\tu64 d = ktime_get_boottime_ns() - ns_from_boot;\n\n\t\t\t\tif (kt <= d) {\t \n\t\t\t\t\t \n\t\t\t\t\tsdebug_free_queued_cmd(sqcp);\n\t\t\t\t\tscsi_done(cmnd);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tkt -= d;\n\t\t\t}\n\t\t}\n\t\tif (sdebug_statistics)\n\t\t\tsd_dp->issuing_cpu = raw_smp_processor_id();\n\t\tif (polled) {\n\t\t\tspin_lock_irqsave(&sdsc->lock, flags);\n\t\t\tsd_dp->cmpl_ts = ktime_add(ns_to_ktime(ns_from_boot), kt);\n\t\t\tASSIGN_QUEUED_CMD(cmnd, sqcp);\n\t\t\tWRITE_ONCE(sd_dp->defer_t, SDEB_DEFER_POLL);\n\t\t\tspin_unlock_irqrestore(&sdsc->lock, flags);\n\t\t} else {\n\t\t\t \n\t\t\tspin_lock_irqsave(&sdsc->lock, flags);\n\t\t\tASSIGN_QUEUED_CMD(cmnd, sqcp);\n\t\t\tWRITE_ONCE(sd_dp->defer_t, SDEB_DEFER_HRT);\n\t\t\thrtimer_start(&sd_dp->hrt, kt, HRTIMER_MODE_REL_PINNED);\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&sdsc->lock, flags);\n\t\t}\n\t} else {\t \n\t\tif (unlikely((sdebug_opts & SDEBUG_OPT_CMD_ABORT) &&\n\t\t\t     atomic_read(&sdeb_inject_pending))) {\n\t\t\tsd_dp->aborted = true;\n\t\t\tatomic_set(&sdeb_inject_pending, 0);\n\t\t\tsdev_printk(KERN_INFO, sdp, \"abort request tag=%#x\\n\",\n\t\t\t\t    blk_mq_unique_tag_to_tag(get_tag(cmnd)));\n\t\t}\n\n\t\tif (sdebug_statistics)\n\t\t\tsd_dp->issuing_cpu = raw_smp_processor_id();\n\t\tif (polled) {\n\t\t\tspin_lock_irqsave(&sdsc->lock, flags);\n\t\t\tASSIGN_QUEUED_CMD(cmnd, sqcp);\n\t\t\tsd_dp->cmpl_ts = ns_to_ktime(ns_from_boot);\n\t\t\tWRITE_ONCE(sd_dp->defer_t, SDEB_DEFER_POLL);\n\t\t\tspin_unlock_irqrestore(&sdsc->lock, flags);\n\t\t} else {\n\t\t\tspin_lock_irqsave(&sdsc->lock, flags);\n\t\t\tASSIGN_QUEUED_CMD(cmnd, sqcp);\n\t\t\tWRITE_ONCE(sd_dp->defer_t, SDEB_DEFER_WQ);\n\t\t\tschedule_work(&sd_dp->ew.work);\n\t\t\tspin_unlock_irqrestore(&sdsc->lock, flags);\n\t\t}\n\t}\n\n\treturn 0;\n\nrespond_in_thread:\t \n\tcmnd->result = pfp != NULL ? pfp(cmnd, devip) : 0;\n\tcmnd->result &= ~SDEG_RES_IMMED_MASK;\n\tif (cmnd->result == 0 && scsi_result != 0)\n\t\tcmnd->result = scsi_result;\n\tscsi_done(cmnd);\n\treturn 0;\n}\n\n \nmodule_param_named(add_host, sdebug_add_host, int, S_IRUGO | S_IWUSR);\nmodule_param_named(ato, sdebug_ato, int, S_IRUGO);\nmodule_param_named(cdb_len, sdebug_cdb_len, int, 0644);\nmodule_param_named(clustering, sdebug_clustering, bool, S_IRUGO | S_IWUSR);\nmodule_param_named(delay, sdebug_jdelay, int, S_IRUGO | S_IWUSR);\nmodule_param_named(dev_size_mb, sdebug_dev_size_mb, int, S_IRUGO);\nmodule_param_named(dif, sdebug_dif, int, S_IRUGO);\nmodule_param_named(dix, sdebug_dix, int, S_IRUGO);\nmodule_param_named(dsense, sdebug_dsense, int, S_IRUGO | S_IWUSR);\nmodule_param_named(every_nth, sdebug_every_nth, int, S_IRUGO | S_IWUSR);\nmodule_param_named(fake_rw, sdebug_fake_rw, int, S_IRUGO | S_IWUSR);\nmodule_param_named(guard, sdebug_guard, uint, S_IRUGO);\nmodule_param_named(host_lock, sdebug_host_lock, bool, S_IRUGO | S_IWUSR);\nmodule_param_named(host_max_queue, sdebug_host_max_queue, int, S_IRUGO);\nmodule_param_string(inq_product, sdebug_inq_product_id,\n\t\t    sizeof(sdebug_inq_product_id), S_IRUGO | S_IWUSR);\nmodule_param_string(inq_rev, sdebug_inq_product_rev,\n\t\t    sizeof(sdebug_inq_product_rev), S_IRUGO | S_IWUSR);\nmodule_param_string(inq_vendor, sdebug_inq_vendor_id,\n\t\t    sizeof(sdebug_inq_vendor_id), S_IRUGO | S_IWUSR);\nmodule_param_named(lbprz, sdebug_lbprz, int, S_IRUGO);\nmodule_param_named(lbpu, sdebug_lbpu, int, S_IRUGO);\nmodule_param_named(lbpws, sdebug_lbpws, int, S_IRUGO);\nmodule_param_named(lbpws10, sdebug_lbpws10, int, S_IRUGO);\nmodule_param_named(lowest_aligned, sdebug_lowest_aligned, int, S_IRUGO);\nmodule_param_named(lun_format, sdebug_lun_am_i, int, S_IRUGO | S_IWUSR);\nmodule_param_named(max_luns, sdebug_max_luns, int, S_IRUGO | S_IWUSR);\nmodule_param_named(max_queue, sdebug_max_queue, int, S_IRUGO | S_IWUSR);\nmodule_param_named(medium_error_count, sdebug_medium_error_count, int,\n\t\t   S_IRUGO | S_IWUSR);\nmodule_param_named(medium_error_start, sdebug_medium_error_start, int,\n\t\t   S_IRUGO | S_IWUSR);\nmodule_param_named(ndelay, sdebug_ndelay, int, S_IRUGO | S_IWUSR);\nmodule_param_named(no_lun_0, sdebug_no_lun_0, int, S_IRUGO | S_IWUSR);\nmodule_param_named(no_rwlock, sdebug_no_rwlock, bool, S_IRUGO | S_IWUSR);\nmodule_param_named(no_uld, sdebug_no_uld, int, S_IRUGO);\nmodule_param_named(num_parts, sdebug_num_parts, int, S_IRUGO);\nmodule_param_named(num_tgts, sdebug_num_tgts, int, S_IRUGO | S_IWUSR);\nmodule_param_named(opt_blks, sdebug_opt_blks, int, S_IRUGO);\nmodule_param_named(opt_xferlen_exp, sdebug_opt_xferlen_exp, int, S_IRUGO);\nmodule_param_named(opts, sdebug_opts, int, S_IRUGO | S_IWUSR);\nmodule_param_named(per_host_store, sdebug_per_host_store, bool,\n\t\t   S_IRUGO | S_IWUSR);\nmodule_param_named(physblk_exp, sdebug_physblk_exp, int, S_IRUGO);\nmodule_param_named(ptype, sdebug_ptype, int, S_IRUGO | S_IWUSR);\nmodule_param_named(random, sdebug_random, bool, S_IRUGO | S_IWUSR);\nmodule_param_named(removable, sdebug_removable, bool, S_IRUGO | S_IWUSR);\nmodule_param_named(scsi_level, sdebug_scsi_level, int, S_IRUGO);\nmodule_param_named(sector_size, sdebug_sector_size, int, S_IRUGO);\nmodule_param_named(statistics, sdebug_statistics, bool, S_IRUGO | S_IWUSR);\nmodule_param_named(strict, sdebug_strict, bool, S_IRUGO | S_IWUSR);\nmodule_param_named(submit_queues, submit_queues, int, S_IRUGO);\nmodule_param_named(poll_queues, poll_queues, int, S_IRUGO);\nmodule_param_named(tur_ms_to_ready, sdeb_tur_ms_to_ready, int, S_IRUGO);\nmodule_param_named(unmap_alignment, sdebug_unmap_alignment, int, S_IRUGO);\nmodule_param_named(unmap_granularity, sdebug_unmap_granularity, int, S_IRUGO);\nmodule_param_named(unmap_max_blocks, sdebug_unmap_max_blocks, int, S_IRUGO);\nmodule_param_named(unmap_max_desc, sdebug_unmap_max_desc, int, S_IRUGO);\nmodule_param_named(uuid_ctl, sdebug_uuid_ctl, int, S_IRUGO);\nmodule_param_named(virtual_gb, sdebug_virtual_gb, int, S_IRUGO | S_IWUSR);\nmodule_param_named(vpd_use_hostno, sdebug_vpd_use_hostno, int,\n\t\t   S_IRUGO | S_IWUSR);\nmodule_param_named(wp, sdebug_wp, bool, S_IRUGO | S_IWUSR);\nmodule_param_named(write_same_length, sdebug_write_same_length, int,\n\t\t   S_IRUGO | S_IWUSR);\nmodule_param_named(zbc, sdeb_zbc_model_s, charp, S_IRUGO);\nmodule_param_named(zone_cap_mb, sdeb_zbc_zone_cap_mb, int, S_IRUGO);\nmodule_param_named(zone_max_open, sdeb_zbc_max_open, int, S_IRUGO);\nmodule_param_named(zone_nr_conv, sdeb_zbc_nr_conv, int, S_IRUGO);\nmodule_param_named(zone_size_mb, sdeb_zbc_zone_size_mb, int, S_IRUGO);\n\nMODULE_AUTHOR(\"Eric Youngdale + Douglas Gilbert\");\nMODULE_DESCRIPTION(\"SCSI debug adapter driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(SDEBUG_VERSION);\n\nMODULE_PARM_DESC(add_host, \"add n hosts, in sysfs if negative remove host(s) (def=1)\");\nMODULE_PARM_DESC(ato, \"application tag ownership: 0=disk 1=host (def=1)\");\nMODULE_PARM_DESC(cdb_len, \"suggest CDB lengths to drivers (def=10)\");\nMODULE_PARM_DESC(clustering, \"when set enables larger transfers (def=0)\");\nMODULE_PARM_DESC(delay, \"response delay (def=1 jiffy); 0:imm, -1,-2:tiny\");\nMODULE_PARM_DESC(dev_size_mb, \"size in MiB of ram shared by devs(def=8)\");\nMODULE_PARM_DESC(dif, \"data integrity field type: 0-3 (def=0)\");\nMODULE_PARM_DESC(dix, \"data integrity extensions mask (def=0)\");\nMODULE_PARM_DESC(dsense, \"use descriptor sense format(def=0 -> fixed)\");\nMODULE_PARM_DESC(every_nth, \"timeout every nth command(def=0)\");\nMODULE_PARM_DESC(fake_rw, \"fake reads/writes instead of copying (def=0)\");\nMODULE_PARM_DESC(guard, \"protection checksum: 0=crc, 1=ip (def=0)\");\nMODULE_PARM_DESC(host_lock, \"host_lock is ignored (def=0)\");\nMODULE_PARM_DESC(host_max_queue,\n\t\t \"host max # of queued cmds (0 to max(def) [max_queue fixed equal for !0])\");\nMODULE_PARM_DESC(inq_product, \"SCSI INQUIRY product string (def=\\\"scsi_debug\\\")\");\nMODULE_PARM_DESC(inq_rev, \"SCSI INQUIRY revision string (def=\\\"\"\n\t\t SDEBUG_VERSION \"\\\")\");\nMODULE_PARM_DESC(inq_vendor, \"SCSI INQUIRY vendor string (def=\\\"Linux\\\")\");\nMODULE_PARM_DESC(lbprz,\n\t\t \"on read unmapped LBs return 0 when 1 (def), return 0xff when 2\");\nMODULE_PARM_DESC(lbpu, \"enable LBP, support UNMAP command (def=0)\");\nMODULE_PARM_DESC(lbpws, \"enable LBP, support WRITE SAME(16) with UNMAP bit (def=0)\");\nMODULE_PARM_DESC(lbpws10, \"enable LBP, support WRITE SAME(10) with UNMAP bit (def=0)\");\nMODULE_PARM_DESC(lowest_aligned, \"lowest aligned lba (def=0)\");\nMODULE_PARM_DESC(lun_format, \"LUN format: 0->peripheral (def); 1 --> flat address method\");\nMODULE_PARM_DESC(max_luns, \"number of LUNs per target to simulate(def=1)\");\nMODULE_PARM_DESC(max_queue, \"max number of queued commands (1 to max(def))\");\nMODULE_PARM_DESC(medium_error_count, \"count of sectors to return follow on MEDIUM error\");\nMODULE_PARM_DESC(medium_error_start, \"starting sector number to return MEDIUM error\");\nMODULE_PARM_DESC(ndelay, \"response delay in nanoseconds (def=0 -> ignore)\");\nMODULE_PARM_DESC(no_lun_0, \"no LU number 0 (def=0 -> have lun 0)\");\nMODULE_PARM_DESC(no_rwlock, \"don't protect user data reads+writes (def=0)\");\nMODULE_PARM_DESC(no_uld, \"stop ULD (e.g. sd driver) attaching (def=0))\");\nMODULE_PARM_DESC(num_parts, \"number of partitions(def=0)\");\nMODULE_PARM_DESC(num_tgts, \"number of targets per host to simulate(def=1)\");\nMODULE_PARM_DESC(opt_blks, \"optimal transfer length in blocks (def=1024)\");\nMODULE_PARM_DESC(opt_xferlen_exp, \"optimal transfer length granularity exponent (def=physblk_exp)\");\nMODULE_PARM_DESC(opts, \"1->noise, 2->medium_err, 4->timeout, 8->recovered_err... (def=0)\");\nMODULE_PARM_DESC(per_host_store, \"If set, next positive add_host will get new store (def=0)\");\nMODULE_PARM_DESC(physblk_exp, \"physical block exponent (def=0)\");\nMODULE_PARM_DESC(poll_queues, \"support for iouring iopoll queues (1 to max(submit_queues - 1))\");\nMODULE_PARM_DESC(ptype, \"SCSI peripheral type(def=0[disk])\");\nMODULE_PARM_DESC(random, \"If set, uniformly randomize command duration between 0 and delay_in_ns\");\nMODULE_PARM_DESC(removable, \"claim to have removable media (def=0)\");\nMODULE_PARM_DESC(scsi_level, \"SCSI level to simulate(def=7[SPC-5])\");\nMODULE_PARM_DESC(sector_size, \"logical block size in bytes (def=512)\");\nMODULE_PARM_DESC(statistics, \"collect statistics on commands, queues (def=0)\");\nMODULE_PARM_DESC(strict, \"stricter checks: reserved field in cdb (def=0)\");\nMODULE_PARM_DESC(submit_queues, \"support for block multi-queue (def=1)\");\nMODULE_PARM_DESC(tur_ms_to_ready, \"TEST UNIT READY millisecs before initial good status (def=0)\");\nMODULE_PARM_DESC(unmap_alignment, \"lowest aligned thin provisioning lba (def=0)\");\nMODULE_PARM_DESC(unmap_granularity, \"thin provisioning granularity in blocks (def=1)\");\nMODULE_PARM_DESC(unmap_max_blocks, \"max # of blocks can be unmapped in one cmd (def=0xffffffff)\");\nMODULE_PARM_DESC(unmap_max_desc, \"max # of ranges that can be unmapped in one cmd (def=256)\");\nMODULE_PARM_DESC(uuid_ctl,\n\t\t \"1->use uuid for lu name, 0->don't, 2->all use same (def=0)\");\nMODULE_PARM_DESC(virtual_gb, \"virtual gigabyte (GiB) size (def=0 -> use dev_size_mb)\");\nMODULE_PARM_DESC(vpd_use_hostno, \"0 -> dev ids ignore hostno (def=1 -> unique dev ids)\");\nMODULE_PARM_DESC(wp, \"Write Protect (def=0)\");\nMODULE_PARM_DESC(write_same_length, \"Maximum blocks per WRITE SAME cmd (def=0xffff)\");\nMODULE_PARM_DESC(zbc, \"'none' [0]; 'aware' [1]; 'managed' [2] (def=0). Can have 'host-' prefix\");\nMODULE_PARM_DESC(zone_cap_mb, \"Zone capacity in MiB (def=zone size)\");\nMODULE_PARM_DESC(zone_max_open, \"Maximum number of open zones; [0] for no limit (def=auto)\");\nMODULE_PARM_DESC(zone_nr_conv, \"Number of conventional zones (def=1)\");\nMODULE_PARM_DESC(zone_size_mb, \"Zone size in MiB (def=auto)\");\n\n#define SDEBUG_INFO_LEN 256\nstatic char sdebug_info[SDEBUG_INFO_LEN];\n\nstatic const char *scsi_debug_info(struct Scsi_Host *shp)\n{\n\tint k;\n\n\tk = scnprintf(sdebug_info, SDEBUG_INFO_LEN, \"%s: version %s [%s]\\n\",\n\t\t      my_name, SDEBUG_VERSION, sdebug_version_date);\n\tif (k >= (SDEBUG_INFO_LEN - 1))\n\t\treturn sdebug_info;\n\tscnprintf(sdebug_info + k, SDEBUG_INFO_LEN - k,\n\t\t  \"  dev_size_mb=%d, opts=0x%x, submit_queues=%d, %s=%d\",\n\t\t  sdebug_dev_size_mb, sdebug_opts, submit_queues,\n\t\t  \"statistics\", (int)sdebug_statistics);\n\treturn sdebug_info;\n}\n\n \nstatic int scsi_debug_write_info(struct Scsi_Host *host, char *buffer,\n\t\t\t\t int length)\n{\n\tchar arr[16];\n\tint opts;\n\tint minLen = length > 15 ? 15 : length;\n\n\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\n\t\treturn -EACCES;\n\tmemcpy(arr, buffer, minLen);\n\tarr[minLen] = '\\0';\n\tif (1 != sscanf(arr, \"%d\", &opts))\n\t\treturn -EINVAL;\n\tsdebug_opts = opts;\n\tsdebug_verbose = !!(SDEBUG_OPT_NOISE & opts);\n\tsdebug_any_injecting_opt = !!(SDEBUG_OPT_ALL_INJECTING & opts);\n\tif (sdebug_every_nth != 0)\n\t\ttweak_cmnd_count();\n\treturn length;\n}\n\nstruct sdebug_submit_queue_data {\n\tint *first;\n\tint *last;\n\tint queue_num;\n};\n\nstatic bool sdebug_submit_queue_iter(struct request *rq, void *opaque)\n{\n\tstruct sdebug_submit_queue_data *data = opaque;\n\tu32 unique_tag = blk_mq_unique_tag(rq);\n\tu16 hwq = blk_mq_unique_tag_to_hwq(unique_tag);\n\tu16 tag = blk_mq_unique_tag_to_tag(unique_tag);\n\tint queue_num = data->queue_num;\n\n\tif (hwq != queue_num)\n\t\treturn true;\n\n\t \n\tif (*data->first == -1)\n\t\t*data->first = *data->last = tag;\n\telse\n\t\t*data->last = tag;\n\n\treturn true;\n}\n\n \nstatic int scsi_debug_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tstruct sdebug_host_info *sdhp;\n\tint j;\n\n\tseq_printf(m, \"scsi_debug adapter driver, version %s [%s]\\n\",\n\t\t   SDEBUG_VERSION, sdebug_version_date);\n\tseq_printf(m, \"num_tgts=%d, %ssize=%d MB, opts=0x%x, every_nth=%d\\n\",\n\t\t   sdebug_num_tgts, \"shared (ram) \", sdebug_dev_size_mb,\n\t\t   sdebug_opts, sdebug_every_nth);\n\tseq_printf(m, \"delay=%d, ndelay=%d, max_luns=%d, sector_size=%d %s\\n\",\n\t\t   sdebug_jdelay, sdebug_ndelay, sdebug_max_luns,\n\t\t   sdebug_sector_size, \"bytes\");\n\tseq_printf(m, \"cylinders=%d, heads=%d, sectors=%d, command aborts=%d\\n\",\n\t\t   sdebug_cylinders_per, sdebug_heads, sdebug_sectors_per,\n\t\t   num_aborts);\n\tseq_printf(m, \"RESETs: device=%d, target=%d, bus=%d, host=%d\\n\",\n\t\t   num_dev_resets, num_target_resets, num_bus_resets,\n\t\t   num_host_resets);\n\tseq_printf(m, \"dix_reads=%d, dix_writes=%d, dif_errors=%d\\n\",\n\t\t   dix_reads, dix_writes, dif_errors);\n\tseq_printf(m, \"usec_in_jiffy=%lu, statistics=%d\\n\", TICK_NSEC / 1000,\n\t\t   sdebug_statistics);\n\tseq_printf(m, \"cmnd_count=%d, completions=%d, %s=%d, a_tsf=%d, mq_polls=%d\\n\",\n\t\t   atomic_read(&sdebug_cmnd_count),\n\t\t   atomic_read(&sdebug_completions),\n\t\t   \"miss_cpus\", atomic_read(&sdebug_miss_cpus),\n\t\t   atomic_read(&sdebug_a_tsf),\n\t\t   atomic_read(&sdeb_mq_poll_count));\n\n\tseq_printf(m, \"submit_queues=%d\\n\", submit_queues);\n\tfor (j = 0; j < submit_queues; ++j) {\n\t\tint f = -1, l = -1;\n\t\tstruct sdebug_submit_queue_data data = {\n\t\t\t.queue_num = j,\n\t\t\t.first = &f,\n\t\t\t.last = &l,\n\t\t};\n\t\tseq_printf(m, \"  queue %d:\\n\", j);\n\t\tblk_mq_tagset_busy_iter(&host->tag_set, sdebug_submit_queue_iter,\n\t\t\t\t\t&data);\n\t\tif (f >= 0) {\n\t\t\tseq_printf(m, \"    in_use_bm BUSY: %s: %d,%d\\n\",\n\t\t\t\t   \"first,last bits\", f, l);\n\t\t}\n\t}\n\n\tseq_printf(m, \"this host_no=%d\\n\", host->host_no);\n\tif (!xa_empty(per_store_ap)) {\n\t\tbool niu;\n\t\tint idx;\n\t\tunsigned long l_idx;\n\t\tstruct sdeb_store_info *sip;\n\n\t\tseq_puts(m, \"\\nhost list:\\n\");\n\t\tj = 0;\n\t\tlist_for_each_entry(sdhp, &sdebug_host_list, host_list) {\n\t\t\tidx = sdhp->si_idx;\n\t\t\tseq_printf(m, \"  %d: host_no=%d, si_idx=%d\\n\", j,\n\t\t\t\t   sdhp->shost->host_no, idx);\n\t\t\t++j;\n\t\t}\n\t\tseq_printf(m, \"\\nper_store array [most_recent_idx=%d]:\\n\",\n\t\t\t   sdeb_most_recent_idx);\n\t\tj = 0;\n\t\txa_for_each(per_store_ap, l_idx, sip) {\n\t\t\tniu = xa_get_mark(per_store_ap, l_idx,\n\t\t\t\t\t  SDEB_XA_NOT_IN_USE);\n\t\t\tidx = (int)l_idx;\n\t\t\tseq_printf(m, \"  %d: idx=%d%s\\n\", j, idx,\n\t\t\t\t   (niu ? \"  not_in_use\" : \"\"));\n\t\t\t++j;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ssize_t delay_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_jdelay);\n}\n \nstatic ssize_t delay_store(struct device_driver *ddp, const char *buf,\n\t\t\t   size_t count)\n{\n\tint jdelay, res;\n\n\tif (count > 0 && sscanf(buf, \"%d\", &jdelay) == 1) {\n\t\tres = count;\n\t\tif (sdebug_jdelay != jdelay) {\n\t\t\tstruct sdebug_host_info *sdhp;\n\n\t\t\tmutex_lock(&sdebug_host_list_mutex);\n\t\t\tblock_unblock_all_queues(true);\n\n\t\t\tlist_for_each_entry(sdhp, &sdebug_host_list, host_list) {\n\t\t\t\tstruct Scsi_Host *shost = sdhp->shost;\n\n\t\t\t\tif (scsi_host_busy(shost)) {\n\t\t\t\t\tres = -EBUSY;    \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res > 0) {\n\t\t\t\tsdebug_jdelay = jdelay;\n\t\t\t\tsdebug_ndelay = 0;\n\t\t\t}\n\t\t\tblock_unblock_all_queues(false);\n\t\t\tmutex_unlock(&sdebug_host_list_mutex);\n\t\t}\n\t\treturn res;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(delay);\n\nstatic ssize_t ndelay_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_ndelay);\n}\n \n \nstatic ssize_t ndelay_store(struct device_driver *ddp, const char *buf,\n\t\t\t    size_t count)\n{\n\tint ndelay, res;\n\n\tif ((count > 0) && (1 == sscanf(buf, \"%d\", &ndelay)) &&\n\t    (ndelay >= 0) && (ndelay < (1000 * 1000 * 1000))) {\n\t\tres = count;\n\t\tif (sdebug_ndelay != ndelay) {\n\t\t\tstruct sdebug_host_info *sdhp;\n\n\t\t\tmutex_lock(&sdebug_host_list_mutex);\n\t\t\tblock_unblock_all_queues(true);\n\n\t\t\tlist_for_each_entry(sdhp, &sdebug_host_list, host_list) {\n\t\t\t\tstruct Scsi_Host *shost = sdhp->shost;\n\n\t\t\t\tif (scsi_host_busy(shost)) {\n\t\t\t\t\tres = -EBUSY;    \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (res > 0) {\n\t\t\t\tsdebug_ndelay = ndelay;\n\t\t\t\tsdebug_jdelay = ndelay  ? JDELAY_OVERRIDDEN\n\t\t\t\t\t\t\t: DEF_JDELAY;\n\t\t\t}\n\t\t\tblock_unblock_all_queues(false);\n\t\t\tmutex_unlock(&sdebug_host_list_mutex);\n\t\t}\n\t\treturn res;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(ndelay);\n\nstatic ssize_t opts_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%x\\n\", sdebug_opts);\n}\n\nstatic ssize_t opts_store(struct device_driver *ddp, const char *buf,\n\t\t\t  size_t count)\n{\n\tint opts;\n\tchar work[20];\n\n\tif (sscanf(buf, \"%10s\", work) == 1) {\n\t\tif (strncasecmp(work, \"0x\", 2) == 0) {\n\t\t\tif (kstrtoint(work + 2, 16, &opts) == 0)\n\t\t\t\tgoto opts_done;\n\t\t} else {\n\t\t\tif (kstrtoint(work, 10, &opts) == 0)\n\t\t\t\tgoto opts_done;\n\t\t}\n\t}\n\treturn -EINVAL;\nopts_done:\n\tsdebug_opts = opts;\n\tsdebug_verbose = !!(SDEBUG_OPT_NOISE & opts);\n\tsdebug_any_injecting_opt = !!(SDEBUG_OPT_ALL_INJECTING & opts);\n\ttweak_cmnd_count();\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(opts);\n\nstatic ssize_t ptype_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_ptype);\n}\nstatic ssize_t ptype_store(struct device_driver *ddp, const char *buf,\n\t\t\t   size_t count)\n{\n\tint n;\n\n\t \n\tif (sdebug_ptype == TYPE_ZBC)\n\t\treturn -EINVAL;\n\n\tif ((count > 0) && (1 == sscanf(buf, \"%d\", &n)) && (n >= 0)) {\n\t\tif (n == TYPE_ZBC)\n\t\t\treturn -EINVAL;\n\t\tsdebug_ptype = n;\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(ptype);\n\nstatic ssize_t dsense_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_dsense);\n}\nstatic ssize_t dsense_store(struct device_driver *ddp, const char *buf,\n\t\t\t    size_t count)\n{\n\tint n;\n\n\tif ((count > 0) && (1 == sscanf(buf, \"%d\", &n)) && (n >= 0)) {\n\t\tsdebug_dsense = n;\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(dsense);\n\nstatic ssize_t fake_rw_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_fake_rw);\n}\nstatic ssize_t fake_rw_store(struct device_driver *ddp, const char *buf,\n\t\t\t     size_t count)\n{\n\tint n, idx;\n\n\tif ((count > 0) && (1 == sscanf(buf, \"%d\", &n)) && (n >= 0)) {\n\t\tbool want_store = (n == 0);\n\t\tstruct sdebug_host_info *sdhp;\n\n\t\tn = (n > 0);\n\t\tsdebug_fake_rw = (sdebug_fake_rw > 0);\n\t\tif (sdebug_fake_rw == n)\n\t\t\treturn count;\t \n\n\t\tif (want_store) {\t \n\t\t\tif (sdeb_first_idx < 0) {\n\t\t\t\tidx = sdebug_add_store();\n\t\t\t\tif (idx < 0)\n\t\t\t\t\treturn idx;\n\t\t\t} else {\n\t\t\t\tidx = sdeb_first_idx;\n\t\t\t\txa_clear_mark(per_store_ap, idx,\n\t\t\t\t\t      SDEB_XA_NOT_IN_USE);\n\t\t\t}\n\t\t\t \n\t\t\tlist_for_each_entry(sdhp, &sdebug_host_list,\n\t\t\t\t\t    host_list) {\n\t\t\t\tif (sdhp->si_idx != idx) {\n\t\t\t\t\txa_set_mark(per_store_ap, sdhp->si_idx,\n\t\t\t\t\t\t    SDEB_XA_NOT_IN_USE);\n\t\t\t\t\tsdhp->si_idx = idx;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsdeb_most_recent_idx = idx;\n\t\t} else {\t \n\t\t\tsdebug_erase_all_stores(true  );\n\t\t}\n\t\tsdebug_fake_rw = n;\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(fake_rw);\n\nstatic ssize_t no_lun_0_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_no_lun_0);\n}\nstatic ssize_t no_lun_0_store(struct device_driver *ddp, const char *buf,\n\t\t\t      size_t count)\n{\n\tint n;\n\n\tif ((count > 0) && (1 == sscanf(buf, \"%d\", &n)) && (n >= 0)) {\n\t\tsdebug_no_lun_0 = n;\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(no_lun_0);\n\nstatic ssize_t num_tgts_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_num_tgts);\n}\nstatic ssize_t num_tgts_store(struct device_driver *ddp, const char *buf,\n\t\t\t      size_t count)\n{\n\tint n;\n\n\tif ((count > 0) && (1 == sscanf(buf, \"%d\", &n)) && (n >= 0)) {\n\t\tsdebug_num_tgts = n;\n\t\tsdebug_max_tgts_luns();\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(num_tgts);\n\nstatic ssize_t dev_size_mb_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_dev_size_mb);\n}\nstatic DRIVER_ATTR_RO(dev_size_mb);\n\nstatic ssize_t per_host_store_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_per_host_store);\n}\n\nstatic ssize_t per_host_store_store(struct device_driver *ddp, const char *buf,\n\t\t\t\t    size_t count)\n{\n\tbool v;\n\n\tif (kstrtobool(buf, &v))\n\t\treturn -EINVAL;\n\n\tsdebug_per_host_store = v;\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(per_host_store);\n\nstatic ssize_t num_parts_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_num_parts);\n}\nstatic DRIVER_ATTR_RO(num_parts);\n\nstatic ssize_t every_nth_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_every_nth);\n}\nstatic ssize_t every_nth_store(struct device_driver *ddp, const char *buf,\n\t\t\t       size_t count)\n{\n\tint nth;\n\tchar work[20];\n\n\tif (sscanf(buf, \"%10s\", work) == 1) {\n\t\tif (strncasecmp(work, \"0x\", 2) == 0) {\n\t\t\tif (kstrtoint(work + 2, 16, &nth) == 0)\n\t\t\t\tgoto every_nth_done;\n\t\t} else {\n\t\t\tif (kstrtoint(work, 10, &nth) == 0)\n\t\t\t\tgoto every_nth_done;\n\t\t}\n\t}\n\treturn -EINVAL;\n\nevery_nth_done:\n\tsdebug_every_nth = nth;\n\tif (nth && !sdebug_statistics) {\n\t\tpr_info(\"every_nth needs statistics=1, set it\\n\");\n\t\tsdebug_statistics = true;\n\t}\n\ttweak_cmnd_count();\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(every_nth);\n\nstatic ssize_t lun_format_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", (int)sdebug_lun_am);\n}\nstatic ssize_t lun_format_store(struct device_driver *ddp, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tint n;\n\tbool changed;\n\n\tif (kstrtoint(buf, 0, &n))\n\t\treturn -EINVAL;\n\tif (n >= 0) {\n\t\tif (n > (int)SAM_LUN_AM_FLAT) {\n\t\t\tpr_warn(\"only LUN address methods 0 and 1 are supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tchanged = ((int)sdebug_lun_am != n);\n\t\tsdebug_lun_am = n;\n\t\tif (changed && sdebug_scsi_level >= 5) {\t \n\t\t\tstruct sdebug_host_info *sdhp;\n\t\t\tstruct sdebug_dev_info *dp;\n\n\t\t\tmutex_lock(&sdebug_host_list_mutex);\n\t\t\tlist_for_each_entry(sdhp, &sdebug_host_list, host_list) {\n\t\t\t\tlist_for_each_entry(dp, &sdhp->dev_info_list, dev_list) {\n\t\t\t\t\tset_bit(SDEBUG_UA_LUNS_CHANGED, dp->uas_bm);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&sdebug_host_list_mutex);\n\t\t}\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(lun_format);\n\nstatic ssize_t max_luns_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_max_luns);\n}\nstatic ssize_t max_luns_store(struct device_driver *ddp, const char *buf,\n\t\t\t      size_t count)\n{\n\tint n;\n\tbool changed;\n\n\tif ((count > 0) && (1 == sscanf(buf, \"%d\", &n)) && (n >= 0)) {\n\t\tif (n > 256) {\n\t\t\tpr_warn(\"max_luns can be no more than 256\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tchanged = (sdebug_max_luns != n);\n\t\tsdebug_max_luns = n;\n\t\tsdebug_max_tgts_luns();\n\t\tif (changed && (sdebug_scsi_level >= 5)) {\t \n\t\t\tstruct sdebug_host_info *sdhp;\n\t\t\tstruct sdebug_dev_info *dp;\n\n\t\t\tmutex_lock(&sdebug_host_list_mutex);\n\t\t\tlist_for_each_entry(sdhp, &sdebug_host_list,\n\t\t\t\t\t    host_list) {\n\t\t\t\tlist_for_each_entry(dp, &sdhp->dev_info_list,\n\t\t\t\t\t\t    dev_list) {\n\t\t\t\t\tset_bit(SDEBUG_UA_LUNS_CHANGED,\n\t\t\t\t\t\tdp->uas_bm);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&sdebug_host_list_mutex);\n\t\t}\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(max_luns);\n\nstatic ssize_t max_queue_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_max_queue);\n}\n \nstatic ssize_t max_queue_store(struct device_driver *ddp, const char *buf,\n\t\t\t       size_t count)\n{\n\tint n;\n\n\tif ((count > 0) && (1 == sscanf(buf, \"%d\", &n)) && (n > 0) &&\n\t    (n <= SDEBUG_CANQUEUE) &&\n\t    (sdebug_host_max_queue == 0)) {\n\t\tmutex_lock(&sdebug_host_list_mutex);\n\n\t\t \n\t\tif (list_empty(&sdebug_host_list))\n\t\t\tsdebug_max_queue = n;\n\t\telse\n\t\t\tcount = -EBUSY;\n\t\tmutex_unlock(&sdebug_host_list_mutex);\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(max_queue);\n\nstatic ssize_t host_max_queue_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_host_max_queue);\n}\n\nstatic ssize_t no_rwlock_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_no_rwlock);\n}\n\nstatic ssize_t no_rwlock_store(struct device_driver *ddp, const char *buf, size_t count)\n{\n\tbool v;\n\n\tif (kstrtobool(buf, &v))\n\t\treturn -EINVAL;\n\n\tsdebug_no_rwlock = v;\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(no_rwlock);\n\n \nstatic DRIVER_ATTR_RO(host_max_queue);\n\nstatic ssize_t no_uld_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_no_uld);\n}\nstatic DRIVER_ATTR_RO(no_uld);\n\nstatic ssize_t scsi_level_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_scsi_level);\n}\nstatic DRIVER_ATTR_RO(scsi_level);\n\nstatic ssize_t virtual_gb_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_virtual_gb);\n}\nstatic ssize_t virtual_gb_store(struct device_driver *ddp, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tint n;\n\tbool changed;\n\n\t \n\tif (sdeb_zbc_in_use)\n\t\treturn -ENOTSUPP;\n\n\tif ((count > 0) && (1 == sscanf(buf, \"%d\", &n)) && (n >= 0)) {\n\t\tchanged = (sdebug_virtual_gb != n);\n\t\tsdebug_virtual_gb = n;\n\t\tsdebug_capacity = get_sdebug_capacity();\n\t\tif (changed) {\n\t\t\tstruct sdebug_host_info *sdhp;\n\t\t\tstruct sdebug_dev_info *dp;\n\n\t\t\tmutex_lock(&sdebug_host_list_mutex);\n\t\t\tlist_for_each_entry(sdhp, &sdebug_host_list,\n\t\t\t\t\t    host_list) {\n\t\t\t\tlist_for_each_entry(dp, &sdhp->dev_info_list,\n\t\t\t\t\t\t    dev_list) {\n\t\t\t\t\tset_bit(SDEBUG_UA_CAPACITY_CHANGED,\n\t\t\t\t\t\tdp->uas_bm);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&sdebug_host_list_mutex);\n\t\t}\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(virtual_gb);\n\nstatic ssize_t add_host_show(struct device_driver *ddp, char *buf)\n{\n\t \n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_num_hosts);\n}\n\nstatic ssize_t add_host_store(struct device_driver *ddp, const char *buf,\n\t\t\t      size_t count)\n{\n\tbool found;\n\tunsigned long idx;\n\tstruct sdeb_store_info *sip;\n\tbool want_phs = (sdebug_fake_rw == 0) && sdebug_per_host_store;\n\tint delta_hosts;\n\n\tif (sscanf(buf, \"%d\", &delta_hosts) != 1)\n\t\treturn -EINVAL;\n\tif (delta_hosts > 0) {\n\t\tdo {\n\t\t\tfound = false;\n\t\t\tif (want_phs) {\n\t\t\t\txa_for_each_marked(per_store_ap, idx, sip,\n\t\t\t\t\t\t   SDEB_XA_NOT_IN_USE) {\n\t\t\t\t\tsdeb_most_recent_idx = (int)idx;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (found)\t \n\t\t\t\t\tsdebug_add_host_helper((int)idx);\n\t\t\t\telse\n\t\t\t\t\tsdebug_do_add_host(true);\n\t\t\t} else {\n\t\t\t\tsdebug_do_add_host(false);\n\t\t\t}\n\t\t} while (--delta_hosts);\n\t} else if (delta_hosts < 0) {\n\t\tdo {\n\t\t\tsdebug_do_remove_host(false);\n\t\t} while (++delta_hosts);\n\t}\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(add_host);\n\nstatic ssize_t vpd_use_hostno_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_vpd_use_hostno);\n}\nstatic ssize_t vpd_use_hostno_store(struct device_driver *ddp, const char *buf,\n\t\t\t\t    size_t count)\n{\n\tint n;\n\n\tif ((count > 0) && (1 == sscanf(buf, \"%d\", &n)) && (n >= 0)) {\n\t\tsdebug_vpd_use_hostno = n;\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(vpd_use_hostno);\n\nstatic ssize_t statistics_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", (int)sdebug_statistics);\n}\nstatic ssize_t statistics_store(struct device_driver *ddp, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tint n;\n\n\tif ((count > 0) && (sscanf(buf, \"%d\", &n) == 1) && (n >= 0)) {\n\t\tif (n > 0)\n\t\t\tsdebug_statistics = true;\n\t\telse {\n\t\t\tclear_queue_stats();\n\t\t\tsdebug_statistics = false;\n\t\t}\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(statistics);\n\nstatic ssize_t sector_size_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", sdebug_sector_size);\n}\nstatic DRIVER_ATTR_RO(sector_size);\n\nstatic ssize_t submit_queues_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", submit_queues);\n}\nstatic DRIVER_ATTR_RO(submit_queues);\n\nstatic ssize_t dix_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_dix);\n}\nstatic DRIVER_ATTR_RO(dix);\n\nstatic ssize_t dif_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_dif);\n}\nstatic DRIVER_ATTR_RO(dif);\n\nstatic ssize_t guard_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", sdebug_guard);\n}\nstatic DRIVER_ATTR_RO(guard);\n\nstatic ssize_t ato_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_ato);\n}\nstatic DRIVER_ATTR_RO(ato);\n\nstatic ssize_t map_show(struct device_driver *ddp, char *buf)\n{\n\tssize_t count = 0;\n\n\tif (!scsi_debug_lbp())\n\t\treturn scnprintf(buf, PAGE_SIZE, \"0-%u\\n\",\n\t\t\t\t sdebug_store_sectors);\n\n\tif (sdebug_fake_rw == 0 && !xa_empty(per_store_ap)) {\n\t\tstruct sdeb_store_info *sip = xa_load(per_store_ap, 0);\n\n\t\tif (sip)\n\t\t\tcount = scnprintf(buf, PAGE_SIZE - 1, \"%*pbl\",\n\t\t\t\t\t  (int)map_size, sip->map_storep);\n\t}\n\tbuf[count++] = '\\n';\n\tbuf[count] = '\\0';\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RO(map);\n\nstatic ssize_t random_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_random);\n}\n\nstatic ssize_t random_store(struct device_driver *ddp, const char *buf,\n\t\t\t    size_t count)\n{\n\tbool v;\n\n\tif (kstrtobool(buf, &v))\n\t\treturn -EINVAL;\n\n\tsdebug_random = v;\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(random);\n\nstatic ssize_t removable_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_removable ? 1 : 0);\n}\nstatic ssize_t removable_store(struct device_driver *ddp, const char *buf,\n\t\t\t       size_t count)\n{\n\tint n;\n\n\tif ((count > 0) && (1 == sscanf(buf, \"%d\", &n)) && (n >= 0)) {\n\t\tsdebug_removable = (n > 0);\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(removable);\n\nstatic ssize_t host_lock_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", !!sdebug_host_lock);\n}\n \nstatic ssize_t host_lock_store(struct device_driver *ddp, const char *buf,\n\t\t\t       size_t count)\n{\n\tint n;\n\n\tif ((count > 0) && (1 == sscanf(buf, \"%d\", &n)) && (n >= 0)) {\n\t\tsdebug_host_lock = (n > 0);\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(host_lock);\n\nstatic ssize_t strict_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", !!sdebug_strict);\n}\nstatic ssize_t strict_store(struct device_driver *ddp, const char *buf,\n\t\t\t    size_t count)\n{\n\tint n;\n\n\tif ((count > 0) && (1 == sscanf(buf, \"%d\", &n)) && (n >= 0)) {\n\t\tsdebug_strict = (n > 0);\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(strict);\n\nstatic ssize_t uuid_ctl_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", !!sdebug_uuid_ctl);\n}\nstatic DRIVER_ATTR_RO(uuid_ctl);\n\nstatic ssize_t cdb_len_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdebug_cdb_len);\n}\nstatic ssize_t cdb_len_store(struct device_driver *ddp, const char *buf,\n\t\t\t     size_t count)\n{\n\tint ret, n;\n\n\tret = kstrtoint(buf, 0, &n);\n\tif (ret)\n\t\treturn ret;\n\tsdebug_cdb_len = n;\n\tall_config_cdb_len();\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(cdb_len);\n\nstatic const char * const zbc_model_strs_a[] = {\n\t[BLK_ZONED_NONE] = \"none\",\n\t[BLK_ZONED_HA]   = \"host-aware\",\n\t[BLK_ZONED_HM]   = \"host-managed\",\n};\n\nstatic const char * const zbc_model_strs_b[] = {\n\t[BLK_ZONED_NONE] = \"no\",\n\t[BLK_ZONED_HA]   = \"aware\",\n\t[BLK_ZONED_HM]   = \"managed\",\n};\n\nstatic const char * const zbc_model_strs_c[] = {\n\t[BLK_ZONED_NONE] = \"0\",\n\t[BLK_ZONED_HA]   = \"1\",\n\t[BLK_ZONED_HM]   = \"2\",\n};\n\nstatic int sdeb_zbc_model_str(const char *cp)\n{\n\tint res = sysfs_match_string(zbc_model_strs_a, cp);\n\n\tif (res < 0) {\n\t\tres = sysfs_match_string(zbc_model_strs_b, cp);\n\t\tif (res < 0) {\n\t\t\tres = sysfs_match_string(zbc_model_strs_c, cp);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic ssize_t zbc_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\t zbc_model_strs_a[sdeb_zbc_model]);\n}\nstatic DRIVER_ATTR_RO(zbc);\n\nstatic ssize_t tur_ms_to_ready_show(struct device_driver *ddp, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", sdeb_tur_ms_to_ready);\n}\nstatic DRIVER_ATTR_RO(tur_ms_to_ready);\n\n \n\nstatic struct attribute *sdebug_drv_attrs[] = {\n\t&driver_attr_delay.attr,\n\t&driver_attr_opts.attr,\n\t&driver_attr_ptype.attr,\n\t&driver_attr_dsense.attr,\n\t&driver_attr_fake_rw.attr,\n\t&driver_attr_host_max_queue.attr,\n\t&driver_attr_no_lun_0.attr,\n\t&driver_attr_num_tgts.attr,\n\t&driver_attr_dev_size_mb.attr,\n\t&driver_attr_num_parts.attr,\n\t&driver_attr_every_nth.attr,\n\t&driver_attr_lun_format.attr,\n\t&driver_attr_max_luns.attr,\n\t&driver_attr_max_queue.attr,\n\t&driver_attr_no_rwlock.attr,\n\t&driver_attr_no_uld.attr,\n\t&driver_attr_scsi_level.attr,\n\t&driver_attr_virtual_gb.attr,\n\t&driver_attr_add_host.attr,\n\t&driver_attr_per_host_store.attr,\n\t&driver_attr_vpd_use_hostno.attr,\n\t&driver_attr_sector_size.attr,\n\t&driver_attr_statistics.attr,\n\t&driver_attr_submit_queues.attr,\n\t&driver_attr_dix.attr,\n\t&driver_attr_dif.attr,\n\t&driver_attr_guard.attr,\n\t&driver_attr_ato.attr,\n\t&driver_attr_map.attr,\n\t&driver_attr_random.attr,\n\t&driver_attr_removable.attr,\n\t&driver_attr_host_lock.attr,\n\t&driver_attr_ndelay.attr,\n\t&driver_attr_strict.attr,\n\t&driver_attr_uuid_ctl.attr,\n\t&driver_attr_cdb_len.attr,\n\t&driver_attr_tur_ms_to_ready.attr,\n\t&driver_attr_zbc.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(sdebug_drv);\n\nstatic struct device *pseudo_primary;\n\nstatic int __init scsi_debug_init(void)\n{\n\tbool want_store = (sdebug_fake_rw == 0);\n\tunsigned long sz;\n\tint k, ret, hosts_to_add;\n\tint idx = -1;\n\n\tif (sdebug_ndelay >= 1000 * 1000 * 1000) {\n\t\tpr_warn(\"ndelay must be less than 1 second, ignored\\n\");\n\t\tsdebug_ndelay = 0;\n\t} else if (sdebug_ndelay > 0)\n\t\tsdebug_jdelay = JDELAY_OVERRIDDEN;\n\n\tswitch (sdebug_sector_size) {\n\tcase  512:\n\tcase 1024:\n\tcase 2048:\n\tcase 4096:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"invalid sector_size %d\\n\", sdebug_sector_size);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (sdebug_dif) {\n\tcase T10_PI_TYPE0_PROTECTION:\n\t\tbreak;\n\tcase T10_PI_TYPE1_PROTECTION:\n\tcase T10_PI_TYPE2_PROTECTION:\n\tcase T10_PI_TYPE3_PROTECTION:\n\t\thave_dif_prot = true;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"dif must be 0, 1, 2 or 3\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sdebug_num_tgts < 0) {\n\t\tpr_err(\"num_tgts must be >= 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sdebug_guard > 1) {\n\t\tpr_err(\"guard must be 0 or 1\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sdebug_ato > 1) {\n\t\tpr_err(\"ato must be 0 or 1\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sdebug_physblk_exp > 15) {\n\t\tpr_err(\"invalid physblk_exp %u\\n\", sdebug_physblk_exp);\n\t\treturn -EINVAL;\n\t}\n\n\tsdebug_lun_am = sdebug_lun_am_i;\n\tif (sdebug_lun_am > SAM_LUN_AM_FLAT) {\n\t\tpr_warn(\"Invalid LUN format %u, using default\\n\", (int)sdebug_lun_am);\n\t\tsdebug_lun_am = SAM_LUN_AM_PERIPHERAL;\n\t}\n\n\tif (sdebug_max_luns > 256) {\n\t\tif (sdebug_max_luns > 16384) {\n\t\t\tpr_warn(\"max_luns can be no more than 16384, use default\\n\");\n\t\t\tsdebug_max_luns = DEF_MAX_LUNS;\n\t\t}\n\t\tsdebug_lun_am = SAM_LUN_AM_FLAT;\n\t}\n\n\tif (sdebug_lowest_aligned > 0x3fff) {\n\t\tpr_err(\"lowest_aligned too big: %u\\n\", sdebug_lowest_aligned);\n\t\treturn -EINVAL;\n\t}\n\n\tif (submit_queues < 1) {\n\t\tpr_err(\"submit_queues must be 1 or more\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((sdebug_max_queue > SDEBUG_CANQUEUE) || (sdebug_max_queue < 1)) {\n\t\tpr_err(\"max_queue must be in range [1, %d]\\n\", SDEBUG_CANQUEUE);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((sdebug_host_max_queue > SDEBUG_CANQUEUE) ||\n\t    (sdebug_host_max_queue < 0)) {\n\t\tpr_err(\"host_max_queue must be in range [0 %d]\\n\",\n\t\t       SDEBUG_CANQUEUE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sdebug_host_max_queue &&\n\t    (sdebug_max_queue != sdebug_host_max_queue)) {\n\t\tsdebug_max_queue = sdebug_host_max_queue;\n\t\tpr_warn(\"fixing max submit queue depth to host max queue depth, %d\\n\",\n\t\t\tsdebug_max_queue);\n\t}\n\n\t \n\tif (sdebug_ptype == TYPE_ZBC) {\n\t\tsdeb_zbc_model = BLK_ZONED_HM;\n\t} else if (sdeb_zbc_model_s && *sdeb_zbc_model_s) {\n\t\tk = sdeb_zbc_model_str(sdeb_zbc_model_s);\n\t\tif (k < 0)\n\t\t\treturn k;\n\t\tsdeb_zbc_model = k;\n\t\tswitch (sdeb_zbc_model) {\n\t\tcase BLK_ZONED_NONE:\n\t\tcase BLK_ZONED_HA:\n\t\t\tsdebug_ptype = TYPE_DISK;\n\t\t\tbreak;\n\t\tcase BLK_ZONED_HM:\n\t\t\tsdebug_ptype = TYPE_ZBC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid ZBC model\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (sdeb_zbc_model != BLK_ZONED_NONE) {\n\t\tsdeb_zbc_in_use = true;\n\t\tif (sdebug_dev_size_mb == DEF_DEV_SIZE_PRE_INIT)\n\t\t\tsdebug_dev_size_mb = DEF_ZBC_DEV_SIZE_MB;\n\t}\n\n\tif (sdebug_dev_size_mb == DEF_DEV_SIZE_PRE_INIT)\n\t\tsdebug_dev_size_mb = DEF_DEV_SIZE_MB;\n\tif (sdebug_dev_size_mb < 1)\n\t\tsdebug_dev_size_mb = 1;   \n\tsz = (unsigned long)sdebug_dev_size_mb * 1048576;\n\tsdebug_store_sectors = sz / sdebug_sector_size;\n\tsdebug_capacity = get_sdebug_capacity();\n\n\t \n\tsdebug_heads = 8;\n\tsdebug_sectors_per = 32;\n\tif (sdebug_dev_size_mb >= 256)\n\t\tsdebug_heads = 64;\n\telse if (sdebug_dev_size_mb >= 16)\n\t\tsdebug_heads = 32;\n\tsdebug_cylinders_per = (unsigned long)sdebug_capacity /\n\t\t\t       (sdebug_sectors_per * sdebug_heads);\n\tif (sdebug_cylinders_per >= 1024) {\n\t\t \n\t\tsdebug_heads = 255;\n\t\tsdebug_sectors_per = 63;\n\t\tsdebug_cylinders_per = (unsigned long)sdebug_capacity /\n\t\t\t       (sdebug_sectors_per * sdebug_heads);\n\t}\n\tif (scsi_debug_lbp()) {\n\t\tsdebug_unmap_max_blocks =\n\t\t\tclamp(sdebug_unmap_max_blocks, 0U, 0xffffffffU);\n\n\t\tsdebug_unmap_max_desc =\n\t\t\tclamp(sdebug_unmap_max_desc, 0U, 256U);\n\n\t\tsdebug_unmap_granularity =\n\t\t\tclamp(sdebug_unmap_granularity, 1U, 0xffffffffU);\n\n\t\tif (sdebug_unmap_alignment &&\n\t\t    sdebug_unmap_granularity <=\n\t\t    sdebug_unmap_alignment) {\n\t\t\tpr_err(\"ERR: unmap_granularity <= unmap_alignment\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\txa_init_flags(per_store_ap, XA_FLAGS_ALLOC | XA_FLAGS_LOCK_IRQ);\n\tif (want_store) {\n\t\tidx = sdebug_add_store();\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\t}\n\n\tpseudo_primary = root_device_register(\"pseudo_0\");\n\tif (IS_ERR(pseudo_primary)) {\n\t\tpr_warn(\"root_device_register() error\\n\");\n\t\tret = PTR_ERR(pseudo_primary);\n\t\tgoto free_vm;\n\t}\n\tret = bus_register(&pseudo_lld_bus);\n\tif (ret < 0) {\n\t\tpr_warn(\"bus_register error: %d\\n\", ret);\n\t\tgoto dev_unreg;\n\t}\n\tret = driver_register(&sdebug_driverfs_driver);\n\tif (ret < 0) {\n\t\tpr_warn(\"driver_register error: %d\\n\", ret);\n\t\tgoto bus_unreg;\n\t}\n\n\thosts_to_add = sdebug_add_host;\n\tsdebug_add_host = 0;\n\n\tqueued_cmd_cache = KMEM_CACHE(sdebug_queued_cmd, SLAB_HWCACHE_ALIGN);\n\tif (!queued_cmd_cache) {\n\t\tret = -ENOMEM;\n\t\tgoto driver_unreg;\n\t}\n\n\tfor (k = 0; k < hosts_to_add; k++) {\n\t\tif (want_store && k == 0) {\n\t\t\tret = sdebug_add_host_helper(idx);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"add_host_helper k=%d, error=%d\\n\",\n\t\t\t\t       k, -ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tret = sdebug_do_add_host(want_store &&\n\t\t\t\t\t\t sdebug_per_host_store);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"add_host k=%d error=%d\\n\", k, -ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (sdebug_verbose)\n\t\tpr_info(\"built %d host(s)\\n\", sdebug_num_hosts);\n\n\treturn 0;\n\ndriver_unreg:\n\tdriver_unregister(&sdebug_driverfs_driver);\nbus_unreg:\n\tbus_unregister(&pseudo_lld_bus);\ndev_unreg:\n\troot_device_unregister(pseudo_primary);\nfree_vm:\n\tsdebug_erase_store(idx, NULL);\n\treturn ret;\n}\n\nstatic void __exit scsi_debug_exit(void)\n{\n\tint k = sdebug_num_hosts;\n\n\tfor (; k; k--)\n\t\tsdebug_do_remove_host(true);\n\tkmem_cache_destroy(queued_cmd_cache);\n\tdriver_unregister(&sdebug_driverfs_driver);\n\tbus_unregister(&pseudo_lld_bus);\n\troot_device_unregister(pseudo_primary);\n\n\tsdebug_erase_all_stores(false);\n\txa_destroy(per_store_ap);\n}\n\ndevice_initcall(scsi_debug_init);\nmodule_exit(scsi_debug_exit);\n\nstatic void sdebug_release_adapter(struct device *dev)\n{\n\tstruct sdebug_host_info *sdbg_host;\n\n\tsdbg_host = dev_to_sdebug_host(dev);\n\tkfree(sdbg_host);\n}\n\n \nstatic void sdebug_erase_store(int idx, struct sdeb_store_info *sip)\n{\n\tif (idx < 0)\n\t\treturn;\n\tif (!sip) {\n\t\tif (xa_empty(per_store_ap))\n\t\t\treturn;\n\t\tsip = xa_load(per_store_ap, idx);\n\t\tif (!sip)\n\t\t\treturn;\n\t}\n\tvfree(sip->map_storep);\n\tvfree(sip->dif_storep);\n\tvfree(sip->storep);\n\txa_erase(per_store_ap, idx);\n\tkfree(sip);\n}\n\n \nstatic void sdebug_erase_all_stores(bool apart_from_first)\n{\n\tunsigned long idx;\n\tstruct sdeb_store_info *sip = NULL;\n\n\txa_for_each(per_store_ap, idx, sip) {\n\t\tif (apart_from_first)\n\t\t\tapart_from_first = false;\n\t\telse\n\t\t\tsdebug_erase_store(idx, sip);\n\t}\n\tif (apart_from_first)\n\t\tsdeb_most_recent_idx = sdeb_first_idx;\n}\n\n \nstatic int sdebug_add_store(void)\n{\n\tint res;\n\tu32 n_idx;\n\tunsigned long iflags;\n\tunsigned long sz = (unsigned long)sdebug_dev_size_mb * 1048576;\n\tstruct sdeb_store_info *sip = NULL;\n\tstruct xa_limit xal = { .max = 1 << 16, .min = 0 };\n\n\tsip = kzalloc(sizeof(*sip), GFP_KERNEL);\n\tif (!sip)\n\t\treturn -ENOMEM;\n\n\txa_lock_irqsave(per_store_ap, iflags);\n\tres = __xa_alloc(per_store_ap, &n_idx, sip, xal, GFP_ATOMIC);\n\tif (unlikely(res < 0)) {\n\t\txa_unlock_irqrestore(per_store_ap, iflags);\n\t\tkfree(sip);\n\t\tpr_warn(\"%s: xa_alloc() errno=%d\\n\", __func__, -res);\n\t\treturn res;\n\t}\n\tsdeb_most_recent_idx = n_idx;\n\tif (sdeb_first_idx < 0)\n\t\tsdeb_first_idx = n_idx;\n\txa_unlock_irqrestore(per_store_ap, iflags);\n\n\tres = -ENOMEM;\n\tsip->storep = vzalloc(sz);\n\tif (!sip->storep) {\n\t\tpr_err(\"user data oom\\n\");\n\t\tgoto err;\n\t}\n\tif (sdebug_num_parts > 0)\n\t\tsdebug_build_parts(sip->storep, sz);\n\n\t \n\tif (sdebug_dix) {\n\t\tint dif_size;\n\n\t\tdif_size = sdebug_store_sectors * sizeof(struct t10_pi_tuple);\n\t\tsip->dif_storep = vmalloc(dif_size);\n\n\t\tpr_info(\"dif_storep %u bytes @ %pK\\n\", dif_size,\n\t\t\tsip->dif_storep);\n\n\t\tif (!sip->dif_storep) {\n\t\t\tpr_err(\"DIX oom\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tmemset(sip->dif_storep, 0xff, dif_size);\n\t}\n\t \n\tif (scsi_debug_lbp()) {\n\t\tmap_size = lba_to_map_index(sdebug_store_sectors - 1) + 1;\n\t\tsip->map_storep = vmalloc(array_size(sizeof(long),\n\t\t\t\t\t\t     BITS_TO_LONGS(map_size)));\n\n\t\tpr_info(\"%lu provisioning blocks\\n\", map_size);\n\n\t\tif (!sip->map_storep) {\n\t\t\tpr_err(\"LBP map oom\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tbitmap_zero(sip->map_storep, map_size);\n\n\t\t \n\t\tif (sdebug_num_parts)\n\t\t\tmap_region(sip, 0, 2);\n\t}\n\n\trwlock_init(&sip->macc_lck);\n\treturn (int)n_idx;\nerr:\n\tsdebug_erase_store((int)n_idx, sip);\n\tpr_warn(\"%s: failed, errno=%d\\n\", __func__, -res);\n\treturn res;\n}\n\nstatic int sdebug_add_host_helper(int per_host_idx)\n{\n\tint k, devs_per_host, idx;\n\tint error = -ENOMEM;\n\tstruct sdebug_host_info *sdbg_host;\n\tstruct sdebug_dev_info *sdbg_devinfo, *tmp;\n\n\tsdbg_host = kzalloc(sizeof(*sdbg_host), GFP_KERNEL);\n\tif (!sdbg_host)\n\t\treturn -ENOMEM;\n\tidx = (per_host_idx < 0) ? sdeb_first_idx : per_host_idx;\n\tif (xa_get_mark(per_store_ap, idx, SDEB_XA_NOT_IN_USE))\n\t\txa_clear_mark(per_store_ap, idx, SDEB_XA_NOT_IN_USE);\n\tsdbg_host->si_idx = idx;\n\n\tINIT_LIST_HEAD(&sdbg_host->dev_info_list);\n\n\tdevs_per_host = sdebug_num_tgts * sdebug_max_luns;\n\tfor (k = 0; k < devs_per_host; k++) {\n\t\tsdbg_devinfo = sdebug_device_create(sdbg_host, GFP_KERNEL);\n\t\tif (!sdbg_devinfo)\n\t\t\tgoto clean;\n\t}\n\n\tmutex_lock(&sdebug_host_list_mutex);\n\tlist_add_tail(&sdbg_host->host_list, &sdebug_host_list);\n\tmutex_unlock(&sdebug_host_list_mutex);\n\n\tsdbg_host->dev.bus = &pseudo_lld_bus;\n\tsdbg_host->dev.parent = pseudo_primary;\n\tsdbg_host->dev.release = &sdebug_release_adapter;\n\tdev_set_name(&sdbg_host->dev, \"adapter%d\", sdebug_num_hosts);\n\n\terror = device_register(&sdbg_host->dev);\n\tif (error) {\n\t\tmutex_lock(&sdebug_host_list_mutex);\n\t\tlist_del(&sdbg_host->host_list);\n\t\tmutex_unlock(&sdebug_host_list_mutex);\n\t\tgoto clean;\n\t}\n\n\t++sdebug_num_hosts;\n\treturn 0;\n\nclean:\n\tlist_for_each_entry_safe(sdbg_devinfo, tmp, &sdbg_host->dev_info_list,\n\t\t\t\t dev_list) {\n\t\tlist_del(&sdbg_devinfo->dev_list);\n\t\tkfree(sdbg_devinfo->zstate);\n\t\tkfree(sdbg_devinfo);\n\t}\n\tif (sdbg_host->dev.release)\n\t\tput_device(&sdbg_host->dev);\n\telse\n\t\tkfree(sdbg_host);\n\tpr_warn(\"%s: failed, errno=%d\\n\", __func__, -error);\n\treturn error;\n}\n\nstatic int sdebug_do_add_host(bool mk_new_store)\n{\n\tint ph_idx = sdeb_most_recent_idx;\n\n\tif (mk_new_store) {\n\t\tph_idx = sdebug_add_store();\n\t\tif (ph_idx < 0)\n\t\t\treturn ph_idx;\n\t}\n\treturn sdebug_add_host_helper(ph_idx);\n}\n\nstatic void sdebug_do_remove_host(bool the_end)\n{\n\tint idx = -1;\n\tstruct sdebug_host_info *sdbg_host = NULL;\n\tstruct sdebug_host_info *sdbg_host2;\n\n\tmutex_lock(&sdebug_host_list_mutex);\n\tif (!list_empty(&sdebug_host_list)) {\n\t\tsdbg_host = list_entry(sdebug_host_list.prev,\n\t\t\t\t       struct sdebug_host_info, host_list);\n\t\tidx = sdbg_host->si_idx;\n\t}\n\tif (!the_end && idx >= 0) {\n\t\tbool unique = true;\n\n\t\tlist_for_each_entry(sdbg_host2, &sdebug_host_list, host_list) {\n\t\t\tif (sdbg_host2 == sdbg_host)\n\t\t\t\tcontinue;\n\t\t\tif (idx == sdbg_host2->si_idx) {\n\t\t\t\tunique = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (unique) {\n\t\t\txa_set_mark(per_store_ap, idx, SDEB_XA_NOT_IN_USE);\n\t\t\tif (idx == sdeb_most_recent_idx)\n\t\t\t\t--sdeb_most_recent_idx;\n\t\t}\n\t}\n\tif (sdbg_host)\n\t\tlist_del(&sdbg_host->host_list);\n\tmutex_unlock(&sdebug_host_list_mutex);\n\n\tif (!sdbg_host)\n\t\treturn;\n\n\tdevice_unregister(&sdbg_host->dev);\n\t--sdebug_num_hosts;\n}\n\nstatic int sdebug_change_qdepth(struct scsi_device *sdev, int qdepth)\n{\n\tstruct sdebug_dev_info *devip = sdev->hostdata;\n\n\tif (!devip)\n\t\treturn\t-ENODEV;\n\n\tmutex_lock(&sdebug_host_list_mutex);\n\tblock_unblock_all_queues(true);\n\n\tif (qdepth > SDEBUG_CANQUEUE) {\n\t\tqdepth = SDEBUG_CANQUEUE;\n\t\tpr_warn(\"%s: requested qdepth [%d] exceeds canqueue [%d], trim\\n\", __func__,\n\t\t\tqdepth, SDEBUG_CANQUEUE);\n\t}\n\tif (qdepth < 1)\n\t\tqdepth = 1;\n\tif (qdepth != sdev->queue_depth)\n\t\tscsi_change_queue_depth(sdev, qdepth);\n\n\tblock_unblock_all_queues(false);\n\tmutex_unlock(&sdebug_host_list_mutex);\n\n\tif (SDEBUG_OPT_Q_NOISE & sdebug_opts)\n\t\tsdev_printk(KERN_INFO, sdev, \"%s: qdepth=%d\\n\", __func__, qdepth);\n\n\treturn sdev->queue_depth;\n}\n\nstatic bool fake_timeout(struct scsi_cmnd *scp)\n{\n\tif (0 == (atomic_read(&sdebug_cmnd_count) % abs(sdebug_every_nth))) {\n\t\tif (sdebug_every_nth < -1)\n\t\t\tsdebug_every_nth = -1;\n\t\tif (SDEBUG_OPT_TIMEOUT & sdebug_opts)\n\t\t\treturn true;  \n\t\telse if (SDEBUG_OPT_MAC_TIMEOUT & sdebug_opts &&\n\t\t\t scsi_medium_access_command(scp))\n\t\t\treturn true;  \n\t}\n\treturn false;\n}\n\n \nstatic int resp_not_ready(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\n{\n\tint stopped_state;\n\tu64 diff_ns = 0;\n\tktime_t now_ts = ktime_get_boottime();\n\tstruct scsi_device *sdp = scp->device;\n\n\tstopped_state = atomic_read(&devip->stopped);\n\tif (stopped_state == 2) {\n\t\tif (ktime_to_ns(now_ts) > ktime_to_ns(devip->create_ts)) {\n\t\t\tdiff_ns = ktime_to_ns(ktime_sub(now_ts, devip->create_ts));\n\t\t\tif (diff_ns >= ((u64)sdeb_tur_ms_to_ready * 1000000)) {\n\t\t\t\t \n\t\t\t\tatomic_set(&devip->stopped, 0);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tmk_sense_buffer(scp, NOT_READY, LOGICAL_UNIT_NOT_READY, 0x1);\n\t\tif (sdebug_verbose)\n\t\t\tsdev_printk(KERN_INFO, sdp,\n\t\t\t\t    \"%s: Not ready: in process of becoming ready\\n\", my_name);\n\t\tif (scp->cmnd[0] == TEST_UNIT_READY) {\n\t\t\tu64 tur_nanosecs_to_ready = (u64)sdeb_tur_ms_to_ready * 1000000;\n\n\t\t\tif (diff_ns <= tur_nanosecs_to_ready)\n\t\t\t\tdiff_ns = tur_nanosecs_to_ready - diff_ns;\n\t\t\telse\n\t\t\t\tdiff_ns = tur_nanosecs_to_ready;\n\t\t\t \n\t\t\tdo_div(diff_ns, 1000000);\t \n\t\t\tscsi_set_sense_information(scp->sense_buffer, SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t\t\t   diff_ns);\n\t\t\treturn check_condition_result;\n\t\t}\n\t}\n\tmk_sense_buffer(scp, NOT_READY, LOGICAL_UNIT_NOT_READY, 0x2);\n\tif (sdebug_verbose)\n\t\tsdev_printk(KERN_INFO, sdp, \"%s: Not ready: initializing command required\\n\",\n\t\t\t    my_name);\n\treturn check_condition_result;\n}\n\nstatic void sdebug_map_queues(struct Scsi_Host *shost)\n{\n\tint i, qoff;\n\n\tif (shost->nr_hw_queues == 1)\n\t\treturn;\n\n\tfor (i = 0, qoff = 0; i < HCTX_MAX_TYPES; i++) {\n\t\tstruct blk_mq_queue_map *map = &shost->tag_set.map[i];\n\n\t\tmap->nr_queues  = 0;\n\n\t\tif (i == HCTX_TYPE_DEFAULT)\n\t\t\tmap->nr_queues = submit_queues - poll_queues;\n\t\telse if (i == HCTX_TYPE_POLL)\n\t\t\tmap->nr_queues = poll_queues;\n\n\t\tif (!map->nr_queues) {\n\t\t\tBUG_ON(i == HCTX_TYPE_DEFAULT);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmap->queue_offset = qoff;\n\t\tblk_mq_map_queues(map);\n\n\t\tqoff += map->nr_queues;\n\t}\n}\n\nstruct sdebug_blk_mq_poll_data {\n\tunsigned int queue_num;\n\tint *num_entries;\n};\n\n \nstatic bool sdebug_blk_mq_poll_iter(struct request *rq, void *opaque)\n{\n\tstruct sdebug_blk_mq_poll_data *data = opaque;\n\tstruct scsi_cmnd *cmd = blk_mq_rq_to_pdu(rq);\n\tstruct sdebug_scsi_cmd *sdsc = scsi_cmd_priv(cmd);\n\tstruct sdebug_defer *sd_dp;\n\tu32 unique_tag = blk_mq_unique_tag(rq);\n\tu16 hwq = blk_mq_unique_tag_to_hwq(unique_tag);\n\tstruct sdebug_queued_cmd *sqcp;\n\tunsigned long flags;\n\tint queue_num = data->queue_num;\n\tktime_t time;\n\n\t \n\tif (hwq != queue_num)\n\t\treturn true;\n\n\t \n\tif (!test_bit(SCMD_STATE_INFLIGHT, &cmd->state))\n\t\treturn true;\n\n\ttime = ktime_get_boottime();\n\n\tspin_lock_irqsave(&sdsc->lock, flags);\n\tsqcp = TO_QUEUED_CMD(cmd);\n\tif (!sqcp) {\n\t\tspin_unlock_irqrestore(&sdsc->lock, flags);\n\t\treturn true;\n\t}\n\n\tsd_dp = &sqcp->sd_dp;\n\tif (READ_ONCE(sd_dp->defer_t) != SDEB_DEFER_POLL) {\n\t\tspin_unlock_irqrestore(&sdsc->lock, flags);\n\t\treturn true;\n\t}\n\n\tif (time < sd_dp->cmpl_ts) {\n\t\tspin_unlock_irqrestore(&sdsc->lock, flags);\n\t\treturn true;\n\t}\n\n\tASSIGN_QUEUED_CMD(cmd, NULL);\n\tspin_unlock_irqrestore(&sdsc->lock, flags);\n\n\tif (sdebug_statistics) {\n\t\tatomic_inc(&sdebug_completions);\n\t\tif (raw_smp_processor_id() != sd_dp->issuing_cpu)\n\t\t\tatomic_inc(&sdebug_miss_cpus);\n\t}\n\n\tsdebug_free_queued_cmd(sqcp);\n\n\tscsi_done(cmd);  \n\t(*data->num_entries)++;\n\treturn true;\n}\n\nstatic int sdebug_blk_mq_poll(struct Scsi_Host *shost, unsigned int queue_num)\n{\n\tint num_entries = 0;\n\tstruct sdebug_blk_mq_poll_data data = {\n\t\t.queue_num = queue_num,\n\t\t.num_entries = &num_entries,\n\t};\n\n\tblk_mq_tagset_busy_iter(&shost->tag_set, sdebug_blk_mq_poll_iter,\n\t\t\t\t&data);\n\n\tif (num_entries > 0)\n\t\tatomic_add(num_entries, &sdeb_mq_poll_count);\n\treturn num_entries;\n}\n\nstatic int scsi_debug_queuecommand(struct Scsi_Host *shost,\n\t\t\t\t   struct scsi_cmnd *scp)\n{\n\tu8 sdeb_i;\n\tstruct scsi_device *sdp = scp->device;\n\tconst struct opcode_info_t *oip;\n\tconst struct opcode_info_t *r_oip;\n\tstruct sdebug_dev_info *devip;\n\tu8 *cmd = scp->cmnd;\n\tint (*r_pfp)(struct scsi_cmnd *, struct sdebug_dev_info *);\n\tint (*pfp)(struct scsi_cmnd *, struct sdebug_dev_info *) = NULL;\n\tint k, na;\n\tint errsts = 0;\n\tu64 lun_index = sdp->lun & 0x3FFF;\n\tu32 flags;\n\tu16 sa;\n\tu8 opcode = cmd[0];\n\tbool has_wlun_rl;\n\tbool inject_now;\n\n\tscsi_set_resid(scp, 0);\n\tif (sdebug_statistics) {\n\t\tatomic_inc(&sdebug_cmnd_count);\n\t\tinject_now = inject_on_this_cmd();\n\t} else {\n\t\tinject_now = false;\n\t}\n\tif (unlikely(sdebug_verbose &&\n\t\t     !(SDEBUG_OPT_NO_CDB_NOISE & sdebug_opts))) {\n\t\tchar b[120];\n\t\tint n, len, sb;\n\n\t\tlen = scp->cmd_len;\n\t\tsb = (int)sizeof(b);\n\t\tif (len > 32)\n\t\t\tstrcpy(b, \"too long, over 32 bytes\");\n\t\telse {\n\t\t\tfor (k = 0, n = 0; k < len && n < sb; ++k)\n\t\t\t\tn += scnprintf(b + n, sb - n, \"%02x \",\n\t\t\t\t\t       (u32)cmd[k]);\n\t\t}\n\t\tsdev_printk(KERN_INFO, sdp, \"%s: tag=%#x, cmd %s\\n\", my_name,\n\t\t\t    blk_mq_unique_tag(scsi_cmd_to_rq(scp)), b);\n\t}\n\tif (unlikely(inject_now && (sdebug_opts & SDEBUG_OPT_HOST_BUSY)))\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\thas_wlun_rl = (sdp->lun == SCSI_W_LUN_REPORT_LUNS);\n\tif (unlikely(lun_index >= sdebug_max_luns && !has_wlun_rl))\n\t\tgoto err_out;\n\n\tsdeb_i = opcode_ind_arr[opcode];\t \n\toip = &opcode_info_arr[sdeb_i];\t\t \n\tdevip = (struct sdebug_dev_info *)sdp->hostdata;\n\tif (unlikely(!devip)) {\n\t\tdevip = find_build_dev_info(sdp);\n\t\tif (NULL == devip)\n\t\t\tgoto err_out;\n\t}\n\tif (unlikely(inject_now && !atomic_read(&sdeb_inject_pending)))\n\t\tatomic_set(&sdeb_inject_pending, 1);\n\n\tna = oip->num_attached;\n\tr_pfp = oip->pfp;\n\tif (na) {\t \n\t\tr_oip = oip;\n\t\tif (FF_SA & r_oip->flags) {\n\t\t\tif (F_SA_LOW & oip->flags)\n\t\t\t\tsa = 0x1f & cmd[1];\n\t\t\telse\n\t\t\t\tsa = get_unaligned_be16(cmd + 8);\n\t\t\tfor (k = 0; k <= na; oip = r_oip->arrp + k++) {\n\t\t\t\tif (opcode == oip->opcode && sa == oip->sa)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {    \n\t\t\tfor (k = 0; k <= na; oip = r_oip->arrp + k++) {\n\t\t\t\tif (opcode == oip->opcode)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (k > na) {\n\t\t\tif (F_SA_LOW & r_oip->flags)\n\t\t\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 1, 4);\n\t\t\telse if (F_SA_HIGH & r_oip->flags)\n\t\t\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, 8, 7);\n\t\t\telse\n\t\t\t\tmk_sense_invalid_opcode(scp);\n\t\t\tgoto check_cond;\n\t\t}\n\t}\t \n\tflags = oip->flags;\n\tif (unlikely(F_INV_OP & flags)) {\n\t\tmk_sense_invalid_opcode(scp);\n\t\tgoto check_cond;\n\t}\n\tif (unlikely(has_wlun_rl && !(F_RL_WLUN_OK & flags))) {\n\t\tif (sdebug_verbose)\n\t\t\tsdev_printk(KERN_INFO, sdp, \"%s: Opcode 0x%x not%s\\n\",\n\t\t\t\t    my_name, opcode, \" supported for wlun\");\n\t\tmk_sense_invalid_opcode(scp);\n\t\tgoto check_cond;\n\t}\n\tif (unlikely(sdebug_strict)) {\t \n\t\tu8 rem;\n\t\tint j;\n\n\t\tfor (k = 1; k < oip->len_mask[0] && k < 16; ++k) {\n\t\t\trem = ~oip->len_mask[k] & cmd[k];\n\t\t\tif (rem) {\n\t\t\t\tfor (j = 7; j >= 0; --j, rem <<= 1) {\n\t\t\t\t\tif (0x80 & rem)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmk_sense_invalid_fld(scp, SDEB_IN_CDB, k, j);\n\t\t\t\tgoto check_cond;\n\t\t\t}\n\t\t}\n\t}\n\tif (unlikely(!(F_SKIP_UA & flags) &&\n\t\t     find_first_bit(devip->uas_bm,\n\t\t\t\t    SDEBUG_NUM_UAS) != SDEBUG_NUM_UAS)) {\n\t\terrsts = make_ua(scp, devip);\n\t\tif (errsts)\n\t\t\tgoto check_cond;\n\t}\n\tif (unlikely(((F_M_ACCESS & flags) || scp->cmnd[0] == TEST_UNIT_READY) &&\n\t\t     atomic_read(&devip->stopped))) {\n\t\terrsts = resp_not_ready(scp, devip);\n\t\tif (errsts)\n\t\t\tgoto fini;\n\t}\n\tif (sdebug_fake_rw && (F_FAKE_RW & flags))\n\t\tgoto fini;\n\tif (unlikely(sdebug_every_nth)) {\n\t\tif (fake_timeout(scp))\n\t\t\treturn 0;\t \n\t}\n\tif (likely(oip->pfp))\n\t\tpfp = oip->pfp;\t \n\telse\n\t\tpfp = r_pfp;     \n\nfini:\n\tif (F_DELAY_OVERR & flags)\t \n\t\treturn schedule_resp(scp, devip, errsts, pfp, 0, 0);\n\telse if ((flags & F_LONG_DELAY) && (sdebug_jdelay > 0 ||\n\t\t\t\t\t    sdebug_ndelay > 10000)) {\n\t\t \n\t\tint jdelay = (sdebug_jdelay < 2) ? 1 : sdebug_jdelay;\n\t\tint denom = (flags & F_SYNC_DELAY) ? 20 : 1;\n\n\t\tjdelay = mult_frac(USER_HZ * jdelay, HZ, denom * USER_HZ);\n\t\treturn schedule_resp(scp, devip, errsts, pfp, jdelay, 0);\n\t} else\n\t\treturn schedule_resp(scp, devip, errsts, pfp, sdebug_jdelay,\n\t\t\t\t     sdebug_ndelay);\ncheck_cond:\n\treturn schedule_resp(scp, devip, check_condition_result, NULL, 0, 0);\nerr_out:\n\treturn schedule_resp(scp, NULL, DID_NO_CONNECT << 16, NULL, 0, 0);\n}\n\nstatic int sdebug_init_cmd_priv(struct Scsi_Host *shost, struct scsi_cmnd *cmd)\n{\n\tstruct sdebug_scsi_cmd *sdsc = scsi_cmd_priv(cmd);\n\n\tspin_lock_init(&sdsc->lock);\n\n\treturn 0;\n}\n\n\nstatic struct scsi_host_template sdebug_driver_template = {\n\t.show_info =\t\tscsi_debug_show_info,\n\t.write_info =\t\tscsi_debug_write_info,\n\t.proc_name =\t\tsdebug_proc_name,\n\t.name =\t\t\t\"SCSI DEBUG\",\n\t.info =\t\t\tscsi_debug_info,\n\t.slave_alloc =\t\tscsi_debug_slave_alloc,\n\t.slave_configure =\tscsi_debug_slave_configure,\n\t.slave_destroy =\tscsi_debug_slave_destroy,\n\t.ioctl =\t\tscsi_debug_ioctl,\n\t.queuecommand =\t\tscsi_debug_queuecommand,\n\t.change_queue_depth =\tsdebug_change_qdepth,\n\t.map_queues =\t\tsdebug_map_queues,\n\t.mq_poll =\t\tsdebug_blk_mq_poll,\n\t.eh_abort_handler =\tscsi_debug_abort,\n\t.eh_device_reset_handler = scsi_debug_device_reset,\n\t.eh_target_reset_handler = scsi_debug_target_reset,\n\t.eh_bus_reset_handler = scsi_debug_bus_reset,\n\t.eh_host_reset_handler = scsi_debug_host_reset,\n\t.can_queue =\t\tSDEBUG_CANQUEUE,\n\t.this_id =\t\t7,\n\t.sg_tablesize =\t\tSG_MAX_SEGMENTS,\n\t.cmd_per_lun =\t\tDEF_CMD_PER_LUN,\n\t.max_sectors =\t\t-1U,\n\t.max_segment_size =\t-1U,\n\t.module =\t\tTHIS_MODULE,\n\t.track_queue_depth =\t1,\n\t.cmd_size = sizeof(struct sdebug_scsi_cmd),\n\t.init_cmd_priv = sdebug_init_cmd_priv,\n};\n\nstatic int sdebug_driver_probe(struct device *dev)\n{\n\tint error = 0;\n\tstruct sdebug_host_info *sdbg_host;\n\tstruct Scsi_Host *hpnt;\n\tint hprot;\n\n\tsdbg_host = dev_to_sdebug_host(dev);\n\n\tsdebug_driver_template.can_queue = sdebug_max_queue;\n\tsdebug_driver_template.cmd_per_lun = sdebug_max_queue;\n\tif (!sdebug_clustering)\n\t\tsdebug_driver_template.dma_boundary = PAGE_SIZE - 1;\n\n\thpnt = scsi_host_alloc(&sdebug_driver_template, 0);\n\tif (NULL == hpnt) {\n\t\tpr_err(\"scsi_host_alloc failed\\n\");\n\t\terror = -ENODEV;\n\t\treturn error;\n\t}\n\tif (submit_queues > nr_cpu_ids) {\n\t\tpr_warn(\"%s: trim submit_queues (was %d) to nr_cpu_ids=%u\\n\",\n\t\t\tmy_name, submit_queues, nr_cpu_ids);\n\t\tsubmit_queues = nr_cpu_ids;\n\t}\n\t \n\thpnt->nr_hw_queues = submit_queues;\n\tif (sdebug_host_max_queue)\n\t\thpnt->host_tagset = 1;\n\n\t \n\tif (hpnt->nr_hw_queues == 1 || (poll_queues < 1)) {\n\t\tpr_warn(\"%s: trim poll_queues to 0. poll_q/nr_hw = (%d/%d)\\n\",\n\t\t\t my_name, poll_queues, hpnt->nr_hw_queues);\n\t\tpoll_queues = 0;\n\t}\n\n\t \n\tif (poll_queues >= submit_queues) {\n\t\tif (submit_queues < 3)\n\t\t\tpr_warn(\"%s: trim poll_queues to 1\\n\", my_name);\n\t\telse\n\t\t\tpr_warn(\"%s: trim poll_queues to 1. Perhaps try poll_queues=%d\\n\",\n\t\t\t\tmy_name, submit_queues - 1);\n\t\tpoll_queues = 1;\n\t}\n\tif (poll_queues)\n\t\thpnt->nr_maps = 3;\n\n\tsdbg_host->shost = hpnt;\n\tif ((hpnt->this_id >= 0) && (sdebug_num_tgts > hpnt->this_id))\n\t\thpnt->max_id = sdebug_num_tgts + 1;\n\telse\n\t\thpnt->max_id = sdebug_num_tgts;\n\t \n\thpnt->max_lun = SCSI_W_LUN_REPORT_LUNS + 1;\n\n\thprot = 0;\n\n\tswitch (sdebug_dif) {\n\n\tcase T10_PI_TYPE1_PROTECTION:\n\t\thprot = SHOST_DIF_TYPE1_PROTECTION;\n\t\tif (sdebug_dix)\n\t\t\thprot |= SHOST_DIX_TYPE1_PROTECTION;\n\t\tbreak;\n\n\tcase T10_PI_TYPE2_PROTECTION:\n\t\thprot = SHOST_DIF_TYPE2_PROTECTION;\n\t\tif (sdebug_dix)\n\t\t\thprot |= SHOST_DIX_TYPE2_PROTECTION;\n\t\tbreak;\n\n\tcase T10_PI_TYPE3_PROTECTION:\n\t\thprot = SHOST_DIF_TYPE3_PROTECTION;\n\t\tif (sdebug_dix)\n\t\t\thprot |= SHOST_DIX_TYPE3_PROTECTION;\n\t\tbreak;\n\n\tdefault:\n\t\tif (sdebug_dix)\n\t\t\thprot |= SHOST_DIX_TYPE0_PROTECTION;\n\t\tbreak;\n\t}\n\n\tscsi_host_set_prot(hpnt, hprot);\n\n\tif (have_dif_prot || sdebug_dix)\n\t\tpr_info(\"host protection%s%s%s%s%s%s%s\\n\",\n\t\t\t(hprot & SHOST_DIF_TYPE1_PROTECTION) ? \" DIF1\" : \"\",\n\t\t\t(hprot & SHOST_DIF_TYPE2_PROTECTION) ? \" DIF2\" : \"\",\n\t\t\t(hprot & SHOST_DIF_TYPE3_PROTECTION) ? \" DIF3\" : \"\",\n\t\t\t(hprot & SHOST_DIX_TYPE0_PROTECTION) ? \" DIX0\" : \"\",\n\t\t\t(hprot & SHOST_DIX_TYPE1_PROTECTION) ? \" DIX1\" : \"\",\n\t\t\t(hprot & SHOST_DIX_TYPE2_PROTECTION) ? \" DIX2\" : \"\",\n\t\t\t(hprot & SHOST_DIX_TYPE3_PROTECTION) ? \" DIX3\" : \"\");\n\n\tif (sdebug_guard == 1)\n\t\tscsi_host_set_guard(hpnt, SHOST_DIX_GUARD_IP);\n\telse\n\t\tscsi_host_set_guard(hpnt, SHOST_DIX_GUARD_CRC);\n\n\tsdebug_verbose = !!(SDEBUG_OPT_NOISE & sdebug_opts);\n\tsdebug_any_injecting_opt = !!(SDEBUG_OPT_ALL_INJECTING & sdebug_opts);\n\tif (sdebug_every_nth)\t \n\t\tsdebug_statistics = true;\n\terror = scsi_add_host(hpnt, &sdbg_host->dev);\n\tif (error) {\n\t\tpr_err(\"scsi_add_host failed\\n\");\n\t\terror = -ENODEV;\n\t\tscsi_host_put(hpnt);\n\t} else {\n\t\tscsi_scan_host(hpnt);\n\t}\n\n\treturn error;\n}\n\nstatic void sdebug_driver_remove(struct device *dev)\n{\n\tstruct sdebug_host_info *sdbg_host;\n\tstruct sdebug_dev_info *sdbg_devinfo, *tmp;\n\n\tsdbg_host = dev_to_sdebug_host(dev);\n\n\tscsi_remove_host(sdbg_host->shost);\n\n\tlist_for_each_entry_safe(sdbg_devinfo, tmp, &sdbg_host->dev_info_list,\n\t\t\t\t dev_list) {\n\t\tlist_del(&sdbg_devinfo->dev_list);\n\t\tkfree(sdbg_devinfo->zstate);\n\t\tkfree(sdbg_devinfo);\n\t}\n\n\tscsi_host_put(sdbg_host->shost);\n}\n\nstatic struct bus_type pseudo_lld_bus = {\n\t.name = \"pseudo\",\n\t.probe = sdebug_driver_probe,\n\t.remove = sdebug_driver_remove,\n\t.drv_groups = sdebug_drv_groups,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}