{
  "module_name": "scsi_pm.c",
  "hash_id": "70c46b1b814a7bbfffc19babfc629c8f3a24ac05554ee64362db3ef6cc53eb27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_pm.c",
  "human_readable_source": "\n \n\n#include <linux/pm_runtime.h>\n#include <linux/export.h>\n#include <linux/blk-pm.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_driver.h>\n#include <scsi/scsi_host.h>\n\n#include \"scsi_priv.h\"\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int do_scsi_suspend(struct device *dev, const struct dev_pm_ops *pm)\n{\n\treturn pm && pm->suspend ? pm->suspend(dev) : 0;\n}\n\nstatic int do_scsi_freeze(struct device *dev, const struct dev_pm_ops *pm)\n{\n\treturn pm && pm->freeze ? pm->freeze(dev) : 0;\n}\n\nstatic int do_scsi_poweroff(struct device *dev, const struct dev_pm_ops *pm)\n{\n\treturn pm && pm->poweroff ? pm->poweroff(dev) : 0;\n}\n\nstatic int do_scsi_resume(struct device *dev, const struct dev_pm_ops *pm)\n{\n\treturn pm && pm->resume ? pm->resume(dev) : 0;\n}\n\nstatic int do_scsi_thaw(struct device *dev, const struct dev_pm_ops *pm)\n{\n\treturn pm && pm->thaw ? pm->thaw(dev) : 0;\n}\n\nstatic int do_scsi_restore(struct device *dev, const struct dev_pm_ops *pm)\n{\n\treturn pm && pm->restore ? pm->restore(dev) : 0;\n}\n\nstatic int scsi_dev_type_suspend(struct device *dev,\n\t\tint (*cb)(struct device *, const struct dev_pm_ops *))\n{\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\tint err;\n\n\terr = scsi_device_quiesce(to_scsi_device(dev));\n\tif (err == 0) {\n\t\terr = cb(dev, pm);\n\t\tif (err)\n\t\t\tscsi_device_resume(to_scsi_device(dev));\n\t}\n\tdev_dbg(dev, \"scsi suspend: %d\\n\", err);\n\treturn err;\n}\n\nstatic int\nscsi_bus_suspend_common(struct device *dev,\n\t\tint (*cb)(struct device *, const struct dev_pm_ops *))\n{\n\tif (!scsi_is_sdev_device(dev))\n\t\treturn 0;\n\n\treturn scsi_dev_type_suspend(dev, cb);\n}\n\nstatic int scsi_bus_resume_common(struct device *dev,\n\t\tint (*cb)(struct device *, const struct dev_pm_ops *))\n{\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\tint err;\n\n\tif (!scsi_is_sdev_device(dev))\n\t\treturn 0;\n\n\terr = cb(dev, pm);\n\tscsi_device_resume(to_scsi_device(dev));\n\tdev_dbg(dev, \"scsi resume: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic int scsi_bus_prepare(struct device *dev)\n{\n\tif (scsi_is_host_device(dev)) {\n\t\t \n\t\tscsi_complete_async_scans();\n\t}\n\treturn 0;\n}\n\nstatic int scsi_bus_suspend(struct device *dev)\n{\n\treturn scsi_bus_suspend_common(dev, do_scsi_suspend);\n}\n\nstatic int scsi_bus_resume(struct device *dev)\n{\n\treturn scsi_bus_resume_common(dev, do_scsi_resume);\n}\n\nstatic int scsi_bus_freeze(struct device *dev)\n{\n\treturn scsi_bus_suspend_common(dev, do_scsi_freeze);\n}\n\nstatic int scsi_bus_thaw(struct device *dev)\n{\n\treturn scsi_bus_resume_common(dev, do_scsi_thaw);\n}\n\nstatic int scsi_bus_poweroff(struct device *dev)\n{\n\treturn scsi_bus_suspend_common(dev, do_scsi_poweroff);\n}\n\nstatic int scsi_bus_restore(struct device *dev)\n{\n\treturn scsi_bus_resume_common(dev, do_scsi_restore);\n}\n\n#else  \n\n#define scsi_bus_prepare\t\tNULL\n#define scsi_bus_suspend\t\tNULL\n#define scsi_bus_resume\t\t\tNULL\n#define scsi_bus_freeze\t\t\tNULL\n#define scsi_bus_thaw\t\t\tNULL\n#define scsi_bus_poweroff\t\tNULL\n#define scsi_bus_restore\t\tNULL\n\n#endif  \n\nstatic int sdev_runtime_suspend(struct device *dev)\n{\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tint err = 0;\n\n\terr = blk_pre_runtime_suspend(sdev->request_queue);\n\tif (err)\n\t\treturn err;\n\tif (pm && pm->runtime_suspend)\n\t\terr = pm->runtime_suspend(dev);\n\tblk_post_runtime_suspend(sdev->request_queue, err);\n\n\treturn err;\n}\n\nstatic int scsi_runtime_suspend(struct device *dev)\n{\n\tint err = 0;\n\n\tdev_dbg(dev, \"scsi_runtime_suspend\\n\");\n\tif (scsi_is_sdev_device(dev))\n\t\terr = sdev_runtime_suspend(dev);\n\n\t \n\n\treturn err;\n}\n\nstatic int sdev_runtime_resume(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\tint err = 0;\n\n\tblk_pre_runtime_resume(sdev->request_queue);\n\tif (pm && pm->runtime_resume)\n\t\terr = pm->runtime_resume(dev);\n\tblk_post_runtime_resume(sdev->request_queue);\n\n\treturn err;\n}\n\nstatic int scsi_runtime_resume(struct device *dev)\n{\n\tint err = 0;\n\n\tdev_dbg(dev, \"scsi_runtime_resume\\n\");\n\tif (scsi_is_sdev_device(dev))\n\t\terr = sdev_runtime_resume(dev);\n\n\t \n\n\treturn err;\n}\n\nstatic int scsi_runtime_idle(struct device *dev)\n{\n\tdev_dbg(dev, \"scsi_runtime_idle\\n\");\n\n\t \n\n\tif (scsi_is_sdev_device(dev)) {\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tpm_runtime_autosuspend(dev);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nint scsi_autopm_get_device(struct scsi_device *sdev)\n{\n\tint\terr;\n\n\terr = pm_runtime_get_sync(&sdev->sdev_gendev);\n\tif (err < 0 && err !=-EACCES)\n\t\tpm_runtime_put_sync(&sdev->sdev_gendev);\n\telse\n\t\terr = 0;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(scsi_autopm_get_device);\n\nvoid scsi_autopm_put_device(struct scsi_device *sdev)\n{\n\tpm_runtime_put_sync(&sdev->sdev_gendev);\n}\nEXPORT_SYMBOL_GPL(scsi_autopm_put_device);\n\nvoid scsi_autopm_get_target(struct scsi_target *starget)\n{\n\tpm_runtime_get_sync(&starget->dev);\n}\n\nvoid scsi_autopm_put_target(struct scsi_target *starget)\n{\n\tpm_runtime_put_sync(&starget->dev);\n}\n\nint scsi_autopm_get_host(struct Scsi_Host *shost)\n{\n\tint\terr;\n\n\terr = pm_runtime_get_sync(&shost->shost_gendev);\n\tif (err < 0 && err !=-EACCES)\n\t\tpm_runtime_put_sync(&shost->shost_gendev);\n\telse\n\t\terr = 0;\n\treturn err;\n}\n\nvoid scsi_autopm_put_host(struct Scsi_Host *shost)\n{\n\tpm_runtime_put_sync(&shost->shost_gendev);\n}\n\nconst struct dev_pm_ops scsi_bus_pm_ops = {\n\t.prepare =\t\tscsi_bus_prepare,\n\t.suspend =\t\tscsi_bus_suspend,\n\t.resume =\t\tscsi_bus_resume,\n\t.freeze =\t\tscsi_bus_freeze,\n\t.thaw =\t\t\tscsi_bus_thaw,\n\t.poweroff =\t\tscsi_bus_poweroff,\n\t.restore =\t\tscsi_bus_restore,\n\t.runtime_suspend =\tscsi_runtime_suspend,\n\t.runtime_resume =\tscsi_runtime_resume,\n\t.runtime_idle =\t\tscsi_runtime_idle,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}