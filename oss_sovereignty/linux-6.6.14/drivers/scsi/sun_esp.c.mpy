{
  "module_name": "sun_esp.c",
  "hash_id": "26fc7e76655ae2229cd6b4cb3c7290b9a05de7c7b12c187c0865650afa3ccc5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sun_esp.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/gfp.h>\n\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <asm/dma.h>\n\n#include <scsi/scsi_host.h>\n\n#include \"esp_scsi.h\"\n\n#define DRV_MODULE_NAME\t\t\"sun_esp\"\n#define PFX DRV_MODULE_NAME\t\": \"\n#define DRV_VERSION\t\t\"1.100\"\n#define DRV_MODULE_RELDATE\t\"August 27, 2008\"\n\n#define dma_read32(REG) \\\n\tsbus_readl(esp->dma_regs + (REG))\n#define dma_write32(VAL, REG) \\\n\tsbus_writel((VAL), esp->dma_regs + (REG))\n\n \nenum dvma_rev {\n\tdvmarev0,\n\tdvmaesc1,\n\tdvmarev1,\n\tdvmarev2,\n\tdvmarev3,\n\tdvmarevplus,\n\tdvmahme\n};\n\nstatic int esp_sbus_setup_dma(struct esp *esp, struct platform_device *dma_of)\n{\n\tesp->dma = dma_of;\n\n\tesp->dma_regs = of_ioremap(&dma_of->resource[0], 0,\n\t\t\t\t   resource_size(&dma_of->resource[0]),\n\t\t\t\t   \"espdma\");\n\tif (!esp->dma_regs)\n\t\treturn -ENOMEM;\n\n\tswitch (dma_read32(DMA_CSR) & DMA_DEVICE_ID) {\n\tcase DMA_VERS0:\n\t\tesp->dmarev = dvmarev0;\n\t\tbreak;\n\tcase DMA_ESCV1:\n\t\tesp->dmarev = dvmaesc1;\n\t\tbreak;\n\tcase DMA_VERS1:\n\t\tesp->dmarev = dvmarev1;\n\t\tbreak;\n\tcase DMA_VERS2:\n\t\tesp->dmarev = dvmarev2;\n\t\tbreak;\n\tcase DMA_VERHME:\n\t\tesp->dmarev = dvmahme;\n\t\tbreak;\n\tcase DMA_VERSPLUS:\n\t\tesp->dmarev = dvmarevplus;\n\t\tbreak;\n\t}\n\n\treturn 0;\n\n}\n\nstatic int esp_sbus_map_regs(struct esp *esp, int hme)\n{\n\tstruct platform_device *op = to_platform_device(esp->dev);\n\tstruct resource *res;\n\n\t \n\tif (hme)\n\t\tres = &op->resource[1];\n\telse\n\t\tres = &op->resource[0];\n\n\tesp->regs = of_ioremap(res, 0, SBUS_ESP_REG_SIZE, \"ESP\");\n\tif (!esp->regs)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int esp_sbus_map_command_block(struct esp *esp)\n{\n\tesp->command_block = dma_alloc_coherent(esp->dev, 16,\n\t\t\t\t\t\t&esp->command_block_dma,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!esp->command_block)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int esp_sbus_register_irq(struct esp *esp)\n{\n\tstruct Scsi_Host *host = esp->host;\n\tstruct platform_device *op = to_platform_device(esp->dev);\n\n\thost->irq = op->archdata.irqs[0];\n\treturn request_irq(host->irq, scsi_esp_intr, IRQF_SHARED, \"ESP\", esp);\n}\n\nstatic void esp_get_scsi_id(struct esp *esp, struct platform_device *espdma)\n{\n\tstruct platform_device *op = to_platform_device(esp->dev);\n\tstruct device_node *dp;\n\n\tdp = op->dev.of_node;\n\tesp->scsi_id = of_getintprop_default(dp, \"initiator-id\", 0xff);\n\tif (esp->scsi_id != 0xff)\n\t\tgoto done;\n\n\tesp->scsi_id = of_getintprop_default(dp, \"scsi-initiator-id\", 0xff);\n\tif (esp->scsi_id != 0xff)\n\t\tgoto done;\n\n\tesp->scsi_id = of_getintprop_default(espdma->dev.of_node,\n\t\t\t\t\t     \"scsi-initiator-id\", 7);\n\ndone:\n\tesp->host->this_id = esp->scsi_id;\n\tesp->scsi_id_mask = (1 << esp->scsi_id);\n}\n\nstatic void esp_get_differential(struct esp *esp)\n{\n\tstruct platform_device *op = to_platform_device(esp->dev);\n\tstruct device_node *dp;\n\n\tdp = op->dev.of_node;\n\tif (of_property_read_bool(dp, \"differential\"))\n\t\tesp->flags |= ESP_FLAG_DIFFERENTIAL;\n\telse\n\t\tesp->flags &= ~ESP_FLAG_DIFFERENTIAL;\n}\n\nstatic void esp_get_clock_params(struct esp *esp)\n{\n\tstruct platform_device *op = to_platform_device(esp->dev);\n\tstruct device_node *bus_dp, *dp;\n\tint fmhz;\n\n\tdp = op->dev.of_node;\n\tbus_dp = dp->parent;\n\n\tfmhz = of_getintprop_default(dp, \"clock-frequency\", 0);\n\tif (fmhz == 0)\n\t\tfmhz = of_getintprop_default(bus_dp, \"clock-frequency\", 0);\n\n\tesp->cfreq = fmhz;\n}\n\nstatic void esp_get_bursts(struct esp *esp, struct platform_device *dma_of)\n{\n\tstruct device_node *dma_dp = dma_of->dev.of_node;\n\tstruct platform_device *op = to_platform_device(esp->dev);\n\tstruct device_node *dp;\n\tu8 bursts, val;\n\n\tdp = op->dev.of_node;\n\tbursts = of_getintprop_default(dp, \"burst-sizes\", 0xff);\n\tval = of_getintprop_default(dma_dp, \"burst-sizes\", 0xff);\n\tif (val != 0xff)\n\t\tbursts &= val;\n\n\tval = of_getintprop_default(dma_dp->parent, \"burst-sizes\", 0xff);\n\tif (val != 0xff)\n\t\tbursts &= val;\n\n\tif (bursts == 0xff ||\n\t    (bursts & DMA_BURST16) == 0 ||\n\t    (bursts & DMA_BURST32) == 0)\n\t\tbursts = (DMA_BURST32 - 1);\n\n\tesp->bursts = bursts;\n}\n\nstatic void esp_sbus_get_props(struct esp *esp, struct platform_device *espdma)\n{\n\tesp_get_scsi_id(esp, espdma);\n\tesp_get_differential(esp);\n\tesp_get_clock_params(esp);\n\tesp_get_bursts(esp, espdma);\n}\n\nstatic void sbus_esp_write8(struct esp *esp, u8 val, unsigned long reg)\n{\n\tsbus_writeb(val, esp->regs + (reg * 4UL));\n}\n\nstatic u8 sbus_esp_read8(struct esp *esp, unsigned long reg)\n{\n\treturn sbus_readb(esp->regs + (reg * 4UL));\n}\n\nstatic int sbus_esp_irq_pending(struct esp *esp)\n{\n\tif (dma_read32(DMA_CSR) & (DMA_HNDL_INTR | DMA_HNDL_ERROR))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void sbus_esp_reset_dma(struct esp *esp)\n{\n\tint can_do_burst16, can_do_burst32, can_do_burst64;\n\tint can_do_sbus64, lim;\n\tstruct platform_device *op = to_platform_device(esp->dev);\n\tu32 val;\n\n\tcan_do_burst16 = (esp->bursts & DMA_BURST16) != 0;\n\tcan_do_burst32 = (esp->bursts & DMA_BURST32) != 0;\n\tcan_do_burst64 = 0;\n\tcan_do_sbus64 = 0;\n\tif (sbus_can_dma_64bit())\n\t\tcan_do_sbus64 = 1;\n\tif (sbus_can_burst64())\n\t\tcan_do_burst64 = (esp->bursts & DMA_BURST64) != 0;\n\n\t \n\tif (esp->dmarev != dvmahme) {\n\t\tval = dma_read32(DMA_CSR);\n\t\tdma_write32(val | DMA_RST_SCSI, DMA_CSR);\n\t\tdma_write32(val & ~DMA_RST_SCSI, DMA_CSR);\n\t}\n\tswitch (esp->dmarev) {\n\tcase dvmahme:\n\t\tdma_write32(DMA_RESET_FAS366, DMA_CSR);\n\t\tdma_write32(DMA_RST_SCSI, DMA_CSR);\n\n\t\tesp->prev_hme_dmacsr = (DMA_PARITY_OFF | DMA_2CLKS |\n\t\t\t\t\tDMA_SCSI_DISAB | DMA_INT_ENAB);\n\n\t\tesp->prev_hme_dmacsr &= ~(DMA_ENABLE | DMA_ST_WRITE |\n\t\t\t\t\t  DMA_BRST_SZ);\n\n\t\tif (can_do_burst64)\n\t\t\tesp->prev_hme_dmacsr |= DMA_BRST64;\n\t\telse if (can_do_burst32)\n\t\t\tesp->prev_hme_dmacsr |= DMA_BRST32;\n\n\t\tif (can_do_sbus64) {\n\t\t\tesp->prev_hme_dmacsr |= DMA_SCSI_SBUS64;\n\t\t\tsbus_set_sbus64(&op->dev, esp->bursts);\n\t\t}\n\n\t\tlim = 1000;\n\t\twhile (dma_read32(DMA_CSR) & DMA_PEND_READ) {\n\t\t\tif (--lim == 0) {\n\t\t\t\tprintk(KERN_ALERT PFX \"esp%d: DMA_PEND_READ \"\n\t\t\t\t       \"will not clear!\\n\",\n\t\t\t\t       esp->host->unique_id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(1);\n\t\t}\n\n\t\tdma_write32(0, DMA_CSR);\n\t\tdma_write32(esp->prev_hme_dmacsr, DMA_CSR);\n\n\t\tdma_write32(0, DMA_ADDR);\n\t\tbreak;\n\n\tcase dvmarev2:\n\t\tif (esp->rev != ESP100) {\n\t\t\tval = dma_read32(DMA_CSR);\n\t\t\tdma_write32(val | DMA_3CLKS, DMA_CSR);\n\t\t}\n\t\tbreak;\n\n\tcase dvmarev3:\n\t\tval = dma_read32(DMA_CSR);\n\t\tval &= ~DMA_3CLKS;\n\t\tval |= DMA_2CLKS;\n\t\tif (can_do_burst32) {\n\t\t\tval &= ~DMA_BRST_SZ;\n\t\t\tval |= DMA_BRST32;\n\t\t}\n\t\tdma_write32(val, DMA_CSR);\n\t\tbreak;\n\n\tcase dvmaesc1:\n\t\tval = dma_read32(DMA_CSR);\n\t\tval |= DMA_ADD_ENABLE;\n\t\tval &= ~DMA_BCNT_ENAB;\n\t\tif (!can_do_burst32 && can_do_burst16) {\n\t\t\tval |= DMA_ESC_BURST;\n\t\t} else {\n\t\t\tval &= ~(DMA_ESC_BURST);\n\t\t}\n\t\tdma_write32(val, DMA_CSR);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tval = dma_read32(DMA_CSR);\n\tdma_write32(val | DMA_INT_ENAB, DMA_CSR);\n}\n\nstatic void sbus_esp_dma_drain(struct esp *esp)\n{\n\tu32 csr;\n\tint lim;\n\n\tif (esp->dmarev == dvmahme)\n\t\treturn;\n\n\tcsr = dma_read32(DMA_CSR);\n\tif (!(csr & DMA_FIFO_ISDRAIN))\n\t\treturn;\n\n\tif (esp->dmarev != dvmarev3 && esp->dmarev != dvmaesc1)\n\t\tdma_write32(csr | DMA_FIFO_STDRAIN, DMA_CSR);\n\n\tlim = 1000;\n\twhile (dma_read32(DMA_CSR) & DMA_FIFO_ISDRAIN) {\n\t\tif (--lim == 0) {\n\t\t\tprintk(KERN_ALERT PFX \"esp%d: DMA will not drain!\\n\",\n\t\t\t       esp->host->unique_id);\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1);\n\t}\n}\n\nstatic void sbus_esp_dma_invalidate(struct esp *esp)\n{\n\tif (esp->dmarev == dvmahme) {\n\t\tdma_write32(DMA_RST_SCSI, DMA_CSR);\n\n\t\tesp->prev_hme_dmacsr = ((esp->prev_hme_dmacsr |\n\t\t\t\t\t (DMA_PARITY_OFF | DMA_2CLKS |\n\t\t\t\t\t  DMA_SCSI_DISAB | DMA_INT_ENAB)) &\n\t\t\t\t\t~(DMA_ST_WRITE | DMA_ENABLE));\n\n\t\tdma_write32(0, DMA_CSR);\n\t\tdma_write32(esp->prev_hme_dmacsr, DMA_CSR);\n\n\t\t \n\t\tdma_write32(0, DMA_ADDR);\n\t} else {\n\t\tu32 val;\n\t\tint lim;\n\n\t\tlim = 1000;\n\t\twhile ((val = dma_read32(DMA_CSR)) & DMA_PEND_READ) {\n\t\t\tif (--lim == 0) {\n\t\t\t\tprintk(KERN_ALERT PFX \"esp%d: DMA will not \"\n\t\t\t\t       \"invalidate!\\n\", esp->host->unique_id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(1);\n\t\t}\n\n\t\tval &= ~(DMA_ENABLE | DMA_ST_WRITE | DMA_BCNT_ENAB);\n\t\tval |= DMA_FIFO_INV;\n\t\tdma_write32(val, DMA_CSR);\n\t\tval &= ~DMA_FIFO_INV;\n\t\tdma_write32(val, DMA_CSR);\n\t}\n}\n\nstatic void sbus_esp_send_dma_cmd(struct esp *esp, u32 addr, u32 esp_count,\n\t\t\t\t  u32 dma_count, int write, u8 cmd)\n{\n\tu32 csr;\n\n\tBUG_ON(!(cmd & ESP_CMD_DMA));\n\n\tsbus_esp_write8(esp, (esp_count >> 0) & 0xff, ESP_TCLOW);\n\tsbus_esp_write8(esp, (esp_count >> 8) & 0xff, ESP_TCMED);\n\tif (esp->rev == FASHME) {\n\t\tsbus_esp_write8(esp, (esp_count >> 16) & 0xff, FAS_RLO);\n\t\tsbus_esp_write8(esp, 0, FAS_RHI);\n\n\t\tscsi_esp_cmd(esp, cmd);\n\n\t\tcsr = esp->prev_hme_dmacsr;\n\t\tcsr |= DMA_SCSI_DISAB | DMA_ENABLE;\n\t\tif (write)\n\t\t\tcsr |= DMA_ST_WRITE;\n\t\telse\n\t\t\tcsr &= ~DMA_ST_WRITE;\n\t\tesp->prev_hme_dmacsr = csr;\n\n\t\tdma_write32(dma_count, DMA_COUNT);\n\t\tdma_write32(addr, DMA_ADDR);\n\t\tdma_write32(csr, DMA_CSR);\n\t} else {\n\t\tcsr = dma_read32(DMA_CSR);\n\t\tcsr |= DMA_ENABLE;\n\t\tif (write)\n\t\t\tcsr |= DMA_ST_WRITE;\n\t\telse\n\t\t\tcsr &= ~DMA_ST_WRITE;\n\t\tdma_write32(csr, DMA_CSR);\n\t\tif (esp->dmarev == dvmaesc1) {\n\t\t\tu32 end = PAGE_ALIGN(addr + dma_count + 16U);\n\t\t\tdma_write32(end - addr, DMA_COUNT);\n\t\t}\n\t\tdma_write32(addr, DMA_ADDR);\n\n\t\tscsi_esp_cmd(esp, cmd);\n\t}\n\n}\n\nstatic int sbus_esp_dma_error(struct esp *esp)\n{\n\tu32 csr = dma_read32(DMA_CSR);\n\n\tif (csr & DMA_HNDL_ERROR)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic const struct esp_driver_ops sbus_esp_ops = {\n\t.esp_write8\t=\tsbus_esp_write8,\n\t.esp_read8\t=\tsbus_esp_read8,\n\t.irq_pending\t=\tsbus_esp_irq_pending,\n\t.reset_dma\t=\tsbus_esp_reset_dma,\n\t.dma_drain\t=\tsbus_esp_dma_drain,\n\t.dma_invalidate\t=\tsbus_esp_dma_invalidate,\n\t.send_dma_cmd\t=\tsbus_esp_send_dma_cmd,\n\t.dma_error\t=\tsbus_esp_dma_error,\n};\n\nstatic int esp_sbus_probe_one(struct platform_device *op,\n\t\t\t      struct platform_device *espdma, int hme)\n{\n\tconst struct scsi_host_template *tpnt = &scsi_esp_template;\n\tstruct Scsi_Host *host;\n\tstruct esp *esp;\n\tint err;\n\n\thost = scsi_host_alloc(tpnt, sizeof(struct esp));\n\n\terr = -ENOMEM;\n\tif (!host)\n\t\tgoto fail;\n\n\thost->max_id = (hme ? 16 : 8);\n\tesp = shost_priv(host);\n\n\tesp->host = host;\n\tesp->dev = &op->dev;\n\tesp->ops = &sbus_esp_ops;\n\n\tif (hme)\n\t\tesp->flags |= ESP_FLAG_WIDE_CAPABLE;\n\n\terr = esp_sbus_setup_dma(esp, espdma);\n\tif (err < 0)\n\t\tgoto fail_unlink;\n\n\terr = esp_sbus_map_regs(esp, hme);\n\tif (err < 0)\n\t\tgoto fail_unlink;\n\n\terr = esp_sbus_map_command_block(esp);\n\tif (err < 0)\n\t\tgoto fail_unmap_regs;\n\n\terr = esp_sbus_register_irq(esp);\n\tif (err < 0)\n\t\tgoto fail_unmap_command_block;\n\n\tesp_sbus_get_props(esp, espdma);\n\n\t \n\tif (esp->dmarev == dvmaesc1) {\n\t\tu32 val = dma_read32(DMA_CSR);\n\n\t\tdma_write32(val & ~DMA_RST_SCSI, DMA_CSR);\n\t}\n\n\tdev_set_drvdata(&op->dev, esp);\n\n\terr = scsi_esp_register(esp);\n\tif (err)\n\t\tgoto fail_free_irq;\n\n\treturn 0;\n\nfail_free_irq:\n\tfree_irq(host->irq, esp);\nfail_unmap_command_block:\n\tdma_free_coherent(&op->dev, 16,\n\t\t\t  esp->command_block,\n\t\t\t  esp->command_block_dma);\nfail_unmap_regs:\n\tof_iounmap(&op->resource[(hme ? 1 : 0)], esp->regs, SBUS_ESP_REG_SIZE);\nfail_unlink:\n\tscsi_host_put(host);\nfail:\n\treturn err;\n}\n\nstatic int esp_sbus_probe(struct platform_device *op)\n{\n\tstruct device_node *dma_node = NULL;\n\tstruct device_node *dp = op->dev.of_node;\n\tstruct platform_device *dma_of = NULL;\n\tint hme = 0;\n\tint ret;\n\n\tif (of_node_name_eq(dp->parent, \"espdma\") ||\n\t    of_node_name_eq(dp->parent, \"dma\"))\n\t\tdma_node = dp->parent;\n\telse if (of_node_name_eq(dp, \"SUNW,fas\")) {\n\t\tdma_node = op->dev.of_node;\n\t\thme = 1;\n\t}\n\tif (dma_node)\n\t\tdma_of = of_find_device_by_node(dma_node);\n\tif (!dma_of)\n\t\treturn -ENODEV;\n\n\tret = esp_sbus_probe_one(op, dma_of, hme);\n\tif (ret)\n\t\tput_device(&dma_of->dev);\n\n\treturn ret;\n}\n\nstatic int esp_sbus_remove(struct platform_device *op)\n{\n\tstruct esp *esp = dev_get_drvdata(&op->dev);\n\tstruct platform_device *dma_of = esp->dma;\n\tunsigned int irq = esp->host->irq;\n\tbool is_hme;\n\tu32 val;\n\n\tscsi_esp_unregister(esp);\n\n\t \n\tval = dma_read32(DMA_CSR);\n\tdma_write32(val & ~DMA_INT_ENAB, DMA_CSR);\n\n\tfree_irq(irq, esp);\n\n\tis_hme = (esp->dmarev == dvmahme);\n\n\tdma_free_coherent(&op->dev, 16,\n\t\t\t  esp->command_block,\n\t\t\t  esp->command_block_dma);\n\tof_iounmap(&op->resource[(is_hme ? 1 : 0)], esp->regs,\n\t\t   SBUS_ESP_REG_SIZE);\n\tof_iounmap(&dma_of->resource[0], esp->dma_regs,\n\t\t   resource_size(&dma_of->resource[0]));\n\n\tscsi_host_put(esp->host);\n\n\tdev_set_drvdata(&op->dev, NULL);\n\n\tput_device(&dma_of->dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id esp_match[] = {\n\t{\n\t\t.name = \"SUNW,esp\",\n\t},\n\t{\n\t\t.name = \"SUNW,fas\",\n\t},\n\t{\n\t\t.name = \"esp\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, esp_match);\n\nstatic struct platform_driver esp_sbus_driver = {\n\t.driver = {\n\t\t.name = \"esp\",\n\t\t.of_match_table = esp_match,\n\t},\n\t.probe\t\t= esp_sbus_probe,\n\t.remove\t\t= esp_sbus_remove,\n};\nmodule_platform_driver(esp_sbus_driver);\n\nMODULE_DESCRIPTION(\"Sun ESP SCSI driver\");\nMODULE_AUTHOR(\"David S. Miller (davem@davemloft.net)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}