{
  "module_name": "libcxgbi.c",
  "hash_id": "e9847c8ef725112a5c0b0fc80efdd3ef5301f7584d23f0c3fdf97c7fc99a3250",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/cxgbi/libcxgbi.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/skbuff.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/pci.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_host.h>\n#include <linux/if_vlan.h>\n#include <linux/inet.h>\n#include <net/dst.h>\n#include <net/route.h>\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n\n#include <linux/inetdevice.h>\t \n#include <linux/module.h>\n#include <net/tcp.h>\n\nstatic unsigned int dbg_level;\n\n#include \"libcxgbi.h\"\n\n#define DRV_MODULE_NAME\t\t\"libcxgbi\"\n#define DRV_MODULE_DESC\t\t\"Chelsio iSCSI driver library\"\n#define DRV_MODULE_VERSION\t\"0.9.1-ko\"\n#define DRV_MODULE_RELDATE\t\"Apr. 2015\"\n\nstatic char version[] =\n\tDRV_MODULE_DESC \" \" DRV_MODULE_NAME\n\t\" v\" DRV_MODULE_VERSION \" (\" DRV_MODULE_RELDATE \")\\n\";\n\nMODULE_AUTHOR(\"Chelsio Communications, Inc.\");\nMODULE_DESCRIPTION(DRV_MODULE_DESC);\nMODULE_VERSION(DRV_MODULE_VERSION);\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(dbg_level, uint, 0644);\nMODULE_PARM_DESC(dbg_level, \"libiscsi debug level (default=0)\");\n\n\n \nstatic LIST_HEAD(cdev_list);\nstatic DEFINE_MUTEX(cdev_mutex);\n\nstatic LIST_HEAD(cdev_rcu_list);\nstatic DEFINE_SPINLOCK(cdev_rcu_lock);\n\nstatic inline void cxgbi_decode_sw_tag(u32 sw_tag, int *idx, int *age)\n{\n\tif (age)\n\t\t*age = sw_tag & 0x7FFF;\n\tif (idx)\n\t\t*idx = (sw_tag >> 16) & 0x7FFF;\n}\n\nint cxgbi_device_portmap_create(struct cxgbi_device *cdev, unsigned int base,\n\t\t\t\tunsigned int max_conn)\n{\n\tstruct cxgbi_ports_map *pmap = &cdev->pmap;\n\n\tpmap->port_csk = kvzalloc(array_size(max_conn,\n\t\t\t\t\t     sizeof(struct cxgbi_sock *)),\n\t\t\t\t  GFP_KERNEL | __GFP_NOWARN);\n\tif (!pmap->port_csk) {\n\t\tpr_warn(\"cdev 0x%p, portmap OOM %u.\\n\", cdev, max_conn);\n\t\treturn -ENOMEM;\n\t}\n\n\tpmap->max_connect = max_conn;\n\tpmap->sport_base = base;\n\tspin_lock_init(&pmap->lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cxgbi_device_portmap_create);\n\nvoid cxgbi_device_portmap_cleanup(struct cxgbi_device *cdev)\n{\n\tstruct cxgbi_ports_map *pmap = &cdev->pmap;\n\tstruct cxgbi_sock *csk;\n\tint i;\n\n\tfor (i = 0; i < pmap->max_connect; i++) {\n\t\tif (pmap->port_csk[i]) {\n\t\t\tcsk = pmap->port_csk[i];\n\t\t\tpmap->port_csk[i] = NULL;\n\t\t\tlog_debug(1 << CXGBI_DBG_SOCK,\n\t\t\t\t\"csk 0x%p, cdev 0x%p, offload down.\\n\",\n\t\t\t\tcsk, cdev);\n\t\t\tspin_lock_bh(&csk->lock);\n\t\t\tcxgbi_sock_set_flag(csk, CTPF_OFFLOAD_DOWN);\n\t\t\tcxgbi_sock_closed(csk);\n\t\t\tspin_unlock_bh(&csk->lock);\n\t\t\tcxgbi_sock_put(csk);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(cxgbi_device_portmap_cleanup);\n\nstatic inline void cxgbi_device_destroy(struct cxgbi_device *cdev)\n{\n\tlog_debug(1 << CXGBI_DBG_DEV,\n\t\t\"cdev 0x%p, p# %u.\\n\", cdev, cdev->nports);\n\tcxgbi_hbas_remove(cdev);\n\tcxgbi_device_portmap_cleanup(cdev);\n\tif (cdev->cdev2ppm)\n\t\tcxgbi_ppm_release(cdev->cdev2ppm(cdev));\n\tif (cdev->pmap.max_connect)\n\t\tkvfree(cdev->pmap.port_csk);\n\tkfree(cdev);\n}\n\nstruct cxgbi_device *cxgbi_device_register(unsigned int extra,\n\t\t\t\t\t   unsigned int nports)\n{\n\tstruct cxgbi_device *cdev;\n\n\tcdev = kzalloc(sizeof(*cdev) + extra + nports *\n\t\t\t(sizeof(struct cxgbi_hba *) +\n\t\t\t sizeof(struct net_device *)),\n\t\t\tGFP_KERNEL);\n\tif (!cdev) {\n\t\tpr_warn(\"nport %d, OOM.\\n\", nports);\n\t\treturn NULL;\n\t}\n\tcdev->ports = (struct net_device **)(cdev + 1);\n\tcdev->hbas = (struct cxgbi_hba **)(((char*)cdev->ports) + nports *\n\t\t\t\t\t\tsizeof(struct net_device *));\n\tif (extra)\n\t\tcdev->dd_data = ((char *)cdev->hbas) +\n\t\t\t\tnports * sizeof(struct cxgbi_hba *);\n\tspin_lock_init(&cdev->pmap.lock);\n\n\tmutex_lock(&cdev_mutex);\n\tlist_add_tail(&cdev->list_head, &cdev_list);\n\tmutex_unlock(&cdev_mutex);\n\n\tspin_lock(&cdev_rcu_lock);\n\tlist_add_tail_rcu(&cdev->rcu_node, &cdev_rcu_list);\n\tspin_unlock(&cdev_rcu_lock);\n\n\tlog_debug(1 << CXGBI_DBG_DEV,\n\t\t\"cdev 0x%p, p# %u.\\n\", cdev, nports);\n\treturn cdev;\n}\nEXPORT_SYMBOL_GPL(cxgbi_device_register);\n\nvoid cxgbi_device_unregister(struct cxgbi_device *cdev)\n{\n\tlog_debug(1 << CXGBI_DBG_DEV,\n\t\t\"cdev 0x%p, p# %u,%s.\\n\",\n\t\tcdev, cdev->nports, cdev->nports ? cdev->ports[0]->name : \"\");\n\n\tmutex_lock(&cdev_mutex);\n\tlist_del(&cdev->list_head);\n\tmutex_unlock(&cdev_mutex);\n\n\tspin_lock(&cdev_rcu_lock);\n\tlist_del_rcu(&cdev->rcu_node);\n\tspin_unlock(&cdev_rcu_lock);\n\tsynchronize_rcu();\n\n\tcxgbi_device_destroy(cdev);\n}\nEXPORT_SYMBOL_GPL(cxgbi_device_unregister);\n\nvoid cxgbi_device_unregister_all(unsigned int flag)\n{\n\tstruct cxgbi_device *cdev, *tmp;\n\n\tmutex_lock(&cdev_mutex);\n\tlist_for_each_entry_safe(cdev, tmp, &cdev_list, list_head) {\n\t\tif ((cdev->flags & flag) == flag) {\n\t\t\tmutex_unlock(&cdev_mutex);\n\t\t\tcxgbi_device_unregister(cdev);\n\t\t\tmutex_lock(&cdev_mutex);\n\t\t}\n\t}\n\tmutex_unlock(&cdev_mutex);\n}\nEXPORT_SYMBOL_GPL(cxgbi_device_unregister_all);\n\nstruct cxgbi_device *cxgbi_device_find_by_lldev(void *lldev)\n{\n\tstruct cxgbi_device *cdev, *tmp;\n\n\tmutex_lock(&cdev_mutex);\n\tlist_for_each_entry_safe(cdev, tmp, &cdev_list, list_head) {\n\t\tif (cdev->lldev == lldev) {\n\t\t\tmutex_unlock(&cdev_mutex);\n\t\t\treturn cdev;\n\t\t}\n\t}\n\tmutex_unlock(&cdev_mutex);\n\n\tlog_debug(1 << CXGBI_DBG_DEV,\n\t\t\"lldev 0x%p, NO match found.\\n\", lldev);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cxgbi_device_find_by_lldev);\n\nstruct cxgbi_device *cxgbi_device_find_by_netdev(struct net_device *ndev,\n\t\t\t\t\t\t int *port)\n{\n\tstruct net_device *vdev = NULL;\n\tstruct cxgbi_device *cdev, *tmp;\n\tint i;\n\n\tif (is_vlan_dev(ndev)) {\n\t\tvdev = ndev;\n\t\tndev = vlan_dev_real_dev(ndev);\n\t\tlog_debug(1 << CXGBI_DBG_DEV,\n\t\t\t\"vlan dev %s -> %s.\\n\", vdev->name, ndev->name);\n\t}\n\n\tmutex_lock(&cdev_mutex);\n\tlist_for_each_entry_safe(cdev, tmp, &cdev_list, list_head) {\n\t\tfor (i = 0; i < cdev->nports; i++) {\n\t\t\tif (ndev == cdev->ports[i]) {\n\t\t\t\tcdev->hbas[i]->vdev = vdev;\n\t\t\t\tmutex_unlock(&cdev_mutex);\n\t\t\t\tif (port)\n\t\t\t\t\t*port = i;\n\t\t\t\treturn cdev;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&cdev_mutex);\n\tlog_debug(1 << CXGBI_DBG_DEV,\n\t\t\"ndev 0x%p, %s, NO match found.\\n\", ndev, ndev->name);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cxgbi_device_find_by_netdev);\n\nstruct cxgbi_device *cxgbi_device_find_by_netdev_rcu(struct net_device *ndev,\n\t\t\t\t\t\t     int *port)\n{\n\tstruct net_device *vdev = NULL;\n\tstruct cxgbi_device *cdev;\n\tint i;\n\n\tif (is_vlan_dev(ndev)) {\n\t\tvdev = ndev;\n\t\tndev = vlan_dev_real_dev(ndev);\n\t\tpr_info(\"vlan dev %s -> %s.\\n\", vdev->name, ndev->name);\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cdev, &cdev_rcu_list, rcu_node) {\n\t\tfor (i = 0; i < cdev->nports; i++) {\n\t\t\tif (ndev == cdev->ports[i]) {\n\t\t\t\tcdev->hbas[i]->vdev = vdev;\n\t\t\t\trcu_read_unlock();\n\t\t\t\tif (port)\n\t\t\t\t\t*port = i;\n\t\t\t\treturn cdev;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tlog_debug(1 << CXGBI_DBG_DEV,\n\t\t  \"ndev 0x%p, %s, NO match found.\\n\", ndev, ndev->name);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cxgbi_device_find_by_netdev_rcu);\n\nstatic struct cxgbi_device *cxgbi_device_find_by_mac(struct net_device *ndev,\n\t\t\t\t\t\t     int *port)\n{\n\tstruct net_device *vdev = NULL;\n\tstruct cxgbi_device *cdev, *tmp;\n\tint i;\n\n\tif (is_vlan_dev(ndev)) {\n\t\tvdev = ndev;\n\t\tndev = vlan_dev_real_dev(ndev);\n\t\tpr_info(\"vlan dev %s -> %s.\\n\", vdev->name, ndev->name);\n\t}\n\n\tmutex_lock(&cdev_mutex);\n\tlist_for_each_entry_safe(cdev, tmp, &cdev_list, list_head) {\n\t\tfor (i = 0; i < cdev->nports; i++) {\n\t\t\tif (!memcmp(ndev->dev_addr, cdev->ports[i]->dev_addr,\n\t\t\t\t    MAX_ADDR_LEN)) {\n\t\t\t\tcdev->hbas[i]->vdev = vdev;\n\t\t\t\tmutex_unlock(&cdev_mutex);\n\t\t\t\tif (port)\n\t\t\t\t\t*port = i;\n\t\t\t\treturn cdev;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&cdev_mutex);\n\tlog_debug(1 << CXGBI_DBG_DEV,\n\t\t  \"ndev 0x%p, %s, NO match mac found.\\n\",\n\t\t  ndev, ndev->name);\n\treturn NULL;\n}\n\nvoid cxgbi_hbas_remove(struct cxgbi_device *cdev)\n{\n\tint i;\n\tstruct cxgbi_hba *chba;\n\n\tlog_debug(1 << CXGBI_DBG_DEV,\n\t\t\"cdev 0x%p, p#%u.\\n\", cdev, cdev->nports);\n\n\tfor (i = 0; i < cdev->nports; i++) {\n\t\tchba = cdev->hbas[i];\n\t\tif (chba) {\n\t\t\tcdev->hbas[i] = NULL;\n\t\t\tiscsi_host_remove(chba->shost, false);\n\t\t\tpci_dev_put(cdev->pdev);\n\t\t\tiscsi_host_free(chba->shost);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(cxgbi_hbas_remove);\n\nint cxgbi_hbas_add(struct cxgbi_device *cdev, u64 max_lun,\n\t\tunsigned int max_conns, const struct scsi_host_template *sht,\n\t\tstruct scsi_transport_template *stt)\n{\n\tstruct cxgbi_hba *chba;\n\tstruct Scsi_Host *shost;\n\tint i, err;\n\n\tlog_debug(1 << CXGBI_DBG_DEV, \"cdev 0x%p, p#%u.\\n\", cdev, cdev->nports);\n\n\tfor (i = 0; i < cdev->nports; i++) {\n\t\tshost = iscsi_host_alloc(sht, sizeof(*chba), 1);\n\t\tif (!shost) {\n\t\t\tpr_info(\"0x%p, p%d, %s, host alloc failed.\\n\",\n\t\t\t\tcdev, i, cdev->ports[i]->name);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tshost->transportt = stt;\n\t\tshost->max_lun = max_lun;\n\t\tshost->max_id = max_conns - 1;\n\t\tshost->max_channel = 0;\n\t\tshost->max_cmd_len = SCSI_MAX_VARLEN_CDB_SIZE;\n\n\t\tchba = iscsi_host_priv(shost);\n\t\tchba->cdev = cdev;\n\t\tchba->ndev = cdev->ports[i];\n\t\tchba->shost = shost;\n\n\t\tshost->can_queue = sht->can_queue - ISCSI_MGMT_CMDS_MAX;\n\n\t\tlog_debug(1 << CXGBI_DBG_DEV,\n\t\t\t\"cdev 0x%p, p#%d %s: chba 0x%p.\\n\",\n\t\t\tcdev, i, cdev->ports[i]->name, chba);\n\n\t\tpci_dev_get(cdev->pdev);\n\t\terr = iscsi_host_add(shost, &cdev->pdev->dev);\n\t\tif (err) {\n\t\t\tpr_info(\"cdev 0x%p, p#%d %s, host add failed.\\n\",\n\t\t\t\tcdev, i, cdev->ports[i]->name);\n\t\t\tpci_dev_put(cdev->pdev);\n\t\t\tscsi_host_put(shost);\n\t\t\tgoto  err_out;\n\t\t}\n\n\t\tcdev->hbas[i] = chba;\n\t}\n\n\treturn 0;\n\nerr_out:\n\tcxgbi_hbas_remove(cdev);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(cxgbi_hbas_add);\n\n \n\nstatic struct cxgbi_sock *find_sock_on_port(struct cxgbi_device *cdev,\n\t\t\t\t\t    unsigned char port_id)\n{\n\tstruct cxgbi_ports_map *pmap = &cdev->pmap;\n\tunsigned int i;\n\tunsigned int used;\n\n\tif (!pmap->max_connect || !pmap->used)\n\t\treturn NULL;\n\n\tspin_lock_bh(&pmap->lock);\n\tused = pmap->used;\n\tfor (i = 0; used && i < pmap->max_connect; i++) {\n\t\tstruct cxgbi_sock *csk = pmap->port_csk[i];\n\n\t\tif (csk) {\n\t\t\tif (csk->port_id == port_id) {\n\t\t\t\tspin_unlock_bh(&pmap->lock);\n\t\t\t\treturn csk;\n\t\t\t}\n\t\t\tused--;\n\t\t}\n\t}\n\tspin_unlock_bh(&pmap->lock);\n\n\treturn NULL;\n}\n\nstatic int sock_get_port(struct cxgbi_sock *csk)\n{\n\tstruct cxgbi_device *cdev = csk->cdev;\n\tstruct cxgbi_ports_map *pmap = &cdev->pmap;\n\tunsigned int start;\n\tint idx;\n\t__be16 *port;\n\n\tif (!pmap->max_connect) {\n\t\tpr_err(\"cdev 0x%p, p#%u %s, NO port map.\\n\",\n\t\t\t   cdev, csk->port_id, cdev->ports[csk->port_id]->name);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tif (csk->csk_family == AF_INET)\n\t\tport = &csk->saddr.sin_port;\n\telse  \n\t\tport = &csk->saddr6.sin6_port;\n\n\tif (*port) {\n\t\tpr_err(\"source port NON-ZERO %u.\\n\",\n\t\t\tntohs(*port));\n\t\treturn -EADDRINUSE;\n\t}\n\n\tspin_lock_bh(&pmap->lock);\n\tif (pmap->used >= pmap->max_connect) {\n\t\tspin_unlock_bh(&pmap->lock);\n\t\tpr_info(\"cdev 0x%p, p#%u %s, ALL ports used.\\n\",\n\t\t\tcdev, csk->port_id, cdev->ports[csk->port_id]->name);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tstart = idx = pmap->next;\n\tdo {\n\t\tif (++idx >= pmap->max_connect)\n\t\t\tidx = 0;\n\t\tif (!pmap->port_csk[idx]) {\n\t\t\tpmap->used++;\n\t\t\t*port = htons(pmap->sport_base + idx);\n\t\t\tpmap->next = idx;\n\t\t\tpmap->port_csk[idx] = csk;\n\t\t\tspin_unlock_bh(&pmap->lock);\n\t\t\tcxgbi_sock_get(csk);\n\t\t\tlog_debug(1 << CXGBI_DBG_SOCK,\n\t\t\t\t\"cdev 0x%p, p#%u %s, p %u, %u.\\n\",\n\t\t\t\tcdev, csk->port_id,\n\t\t\t\tcdev->ports[csk->port_id]->name,\n\t\t\t\tpmap->sport_base + idx, pmap->next);\n\t\t\treturn 0;\n\t\t}\n\t} while (idx != start);\n\tspin_unlock_bh(&pmap->lock);\n\n\t \n\tpr_warn(\"cdev 0x%p, p#%u %s, next %u?\\n\",\n\t\tcdev, csk->port_id, cdev->ports[csk->port_id]->name,\n\t\tpmap->next);\n\treturn -EADDRNOTAVAIL;\n}\n\nstatic void sock_put_port(struct cxgbi_sock *csk)\n{\n\tstruct cxgbi_device *cdev = csk->cdev;\n\tstruct cxgbi_ports_map *pmap = &cdev->pmap;\n\t__be16 *port;\n\n\tif (csk->csk_family == AF_INET)\n\t\tport = &csk->saddr.sin_port;\n\telse  \n\t\tport = &csk->saddr6.sin6_port;\n\n\tif (*port) {\n\t\tint idx = ntohs(*port) - pmap->sport_base;\n\n\t\t*port = 0;\n\t\tif (idx < 0 || idx >= pmap->max_connect) {\n\t\t\tpr_err(\"cdev 0x%p, p#%u %s, port %u OOR.\\n\",\n\t\t\t\tcdev, csk->port_id,\n\t\t\t\tcdev->ports[csk->port_id]->name,\n\t\t\t\tntohs(*port));\n\t\t\treturn;\n\t\t}\n\n\t\tspin_lock_bh(&pmap->lock);\n\t\tpmap->port_csk[idx] = NULL;\n\t\tpmap->used--;\n\t\tspin_unlock_bh(&pmap->lock);\n\n\t\tlog_debug(1 << CXGBI_DBG_SOCK,\n\t\t\t\"cdev 0x%p, p#%u %s, release %u.\\n\",\n\t\t\tcdev, csk->port_id, cdev->ports[csk->port_id]->name,\n\t\t\tpmap->sport_base + idx);\n\n\t\tcxgbi_sock_put(csk);\n\t}\n}\n\n \nvoid cxgbi_sock_free_cpl_skbs(struct cxgbi_sock *csk)\n{\n\tif (csk->cpl_close) {\n\t\tkfree_skb(csk->cpl_close);\n\t\tcsk->cpl_close = NULL;\n\t}\n\tif (csk->cpl_abort_req) {\n\t\tkfree_skb(csk->cpl_abort_req);\n\t\tcsk->cpl_abort_req = NULL;\n\t}\n\tif (csk->cpl_abort_rpl) {\n\t\tkfree_skb(csk->cpl_abort_rpl);\n\t\tcsk->cpl_abort_rpl = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(cxgbi_sock_free_cpl_skbs);\n\nstatic struct cxgbi_sock *cxgbi_sock_create(struct cxgbi_device *cdev)\n{\n\tstruct cxgbi_sock *csk = kzalloc(sizeof(*csk), GFP_NOIO);\n\n\tif (!csk) {\n\t\tpr_info(\"alloc csk %zu failed.\\n\", sizeof(*csk));\n\t\treturn NULL;\n\t}\n\n\tif (cdev->csk_alloc_cpls(csk) < 0) {\n\t\tpr_info(\"csk 0x%p, alloc cpls failed.\\n\", csk);\n\t\tkfree(csk);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&csk->lock);\n\tkref_init(&csk->refcnt);\n\tskb_queue_head_init(&csk->receive_queue);\n\tskb_queue_head_init(&csk->write_queue);\n\ttimer_setup(&csk->retry_timer, NULL, 0);\n\tinit_completion(&csk->cmpl);\n\trwlock_init(&csk->callback_lock);\n\tcsk->cdev = cdev;\n\tcsk->flags = 0;\n\tcxgbi_sock_set_state(csk, CTP_CLOSED);\n\n\tlog_debug(1 << CXGBI_DBG_SOCK, \"cdev 0x%p, new csk 0x%p.\\n\", cdev, csk);\n\n\treturn csk;\n}\n\nstatic struct rtable *find_route_ipv4(struct flowi4 *fl4,\n\t\t\t\t      __be32 saddr, __be32 daddr,\n\t\t\t\t      __be16 sport, __be16 dport, u8 tos,\n\t\t\t\t      int ifindex)\n{\n\tstruct rtable *rt;\n\n\trt = ip_route_output_ports(&init_net, fl4, NULL, daddr, saddr,\n\t\t\t\t   dport, sport, IPPROTO_TCP, tos, ifindex);\n\tif (IS_ERR(rt))\n\t\treturn NULL;\n\n\treturn rt;\n}\n\nstatic struct cxgbi_sock *\ncxgbi_check_route(struct sockaddr *dst_addr, int ifindex)\n{\n\tstruct sockaddr_in *daddr = (struct sockaddr_in *)dst_addr;\n\tstruct dst_entry *dst;\n\tstruct net_device *ndev;\n\tstruct cxgbi_device *cdev;\n\tstruct rtable *rt = NULL;\n\tstruct neighbour *n;\n\tstruct flowi4 fl4;\n\tstruct cxgbi_sock *csk = NULL;\n\tunsigned int mtu = 0;\n\tint port = 0xFFFF;\n\tint err = 0;\n\n\trt = find_route_ipv4(&fl4, 0, daddr->sin_addr.s_addr, 0,\n\t\t\t     daddr->sin_port, 0, ifindex);\n\tif (!rt) {\n\t\tpr_info(\"no route to ipv4 0x%x, port %u.\\n\",\n\t\t\tbe32_to_cpu(daddr->sin_addr.s_addr),\n\t\t\tbe16_to_cpu(daddr->sin_port));\n\t\terr = -ENETUNREACH;\n\t\tgoto err_out;\n\t}\n\tdst = &rt->dst;\n\tn = dst_neigh_lookup(dst, &daddr->sin_addr.s_addr);\n\tif (!n) {\n\t\terr = -ENODEV;\n\t\tgoto rel_rt;\n\t}\n\tndev = n->dev;\n\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tpr_info(\"multi-cast route %pI4, port %u, dev %s.\\n\",\n\t\t\t&daddr->sin_addr.s_addr, ntohs(daddr->sin_port),\n\t\t\tndev->name);\n\t\terr = -ENETUNREACH;\n\t\tgoto rel_neigh;\n\t}\n\n\tif (ndev->flags & IFF_LOOPBACK) {\n\t\tndev = ip_dev_find(&init_net, daddr->sin_addr.s_addr);\n\t\tif (!ndev) {\n\t\t\terr = -ENETUNREACH;\n\t\t\tgoto rel_neigh;\n\t\t}\n\t\tmtu = ndev->mtu;\n\t\tpr_info(\"rt dev %s, loopback -> %s, mtu %u.\\n\",\n\t\t\tn->dev->name, ndev->name, mtu);\n\t}\n\n\tif (!(ndev->flags & IFF_UP) || !netif_carrier_ok(ndev)) {\n\t\tpr_info(\"%s interface not up.\\n\", ndev->name);\n\t\terr = -ENETDOWN;\n\t\tgoto rel_neigh;\n\t}\n\n\tcdev = cxgbi_device_find_by_netdev(ndev, &port);\n\tif (!cdev)\n\t\tcdev = cxgbi_device_find_by_mac(ndev, &port);\n\tif (!cdev) {\n\t\tpr_info(\"dst %pI4, %s, NOT cxgbi device.\\n\",\n\t\t\t&daddr->sin_addr.s_addr, ndev->name);\n\t\terr = -ENETUNREACH;\n\t\tgoto rel_neigh;\n\t}\n\tlog_debug(1 << CXGBI_DBG_SOCK,\n\t\t\"route to %pI4 :%u, ndev p#%d,%s, cdev 0x%p.\\n\",\n\t\t&daddr->sin_addr.s_addr, ntohs(daddr->sin_port),\n\t\t\t   port, ndev->name, cdev);\n\n\tcsk = cxgbi_sock_create(cdev);\n\tif (!csk) {\n\t\terr = -ENOMEM;\n\t\tgoto rel_neigh;\n\t}\n\tcsk->cdev = cdev;\n\tcsk->port_id = port;\n\tcsk->mtu = mtu;\n\tcsk->dst = dst;\n\n\tcsk->csk_family = AF_INET;\n\tcsk->daddr.sin_addr.s_addr = daddr->sin_addr.s_addr;\n\tcsk->daddr.sin_port = daddr->sin_port;\n\tcsk->daddr.sin_family = daddr->sin_family;\n\tcsk->saddr.sin_family = daddr->sin_family;\n\tcsk->saddr.sin_addr.s_addr = fl4.saddr;\n\tneigh_release(n);\n\n\treturn csk;\n\nrel_neigh:\n\tneigh_release(n);\n\nrel_rt:\n\tip_rt_put(rt);\nerr_out:\n\treturn ERR_PTR(err);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct rt6_info *find_route_ipv6(const struct in6_addr *saddr,\n\t\t\t\t\tconst struct in6_addr *daddr,\n\t\t\t\t\tint ifindex)\n{\n\tstruct flowi6 fl;\n\n\tmemset(&fl, 0, sizeof(fl));\n\tfl.flowi6_oif = ifindex;\n\tif (saddr)\n\t\tmemcpy(&fl.saddr, saddr, sizeof(struct in6_addr));\n\tif (daddr)\n\t\tmemcpy(&fl.daddr, daddr, sizeof(struct in6_addr));\n\treturn (struct rt6_info *)ip6_route_output(&init_net, NULL, &fl);\n}\n\nstatic struct cxgbi_sock *\ncxgbi_check_route6(struct sockaddr *dst_addr, int ifindex)\n{\n\tstruct sockaddr_in6 *daddr6 = (struct sockaddr_in6 *)dst_addr;\n\tstruct dst_entry *dst;\n\tstruct net_device *ndev;\n\tstruct cxgbi_device *cdev;\n\tstruct rt6_info *rt = NULL;\n\tstruct neighbour *n;\n\tstruct in6_addr pref_saddr;\n\tstruct cxgbi_sock *csk = NULL;\n\tunsigned int mtu = 0;\n\tint port = 0xFFFF;\n\tint err = 0;\n\n\trt = find_route_ipv6(NULL, &daddr6->sin6_addr, ifindex);\n\n\tif (!rt) {\n\t\tpr_info(\"no route to ipv6 %pI6 port %u\\n\",\n\t\t\tdaddr6->sin6_addr.s6_addr,\n\t\t\tbe16_to_cpu(daddr6->sin6_port));\n\t\terr = -ENETUNREACH;\n\t\tgoto err_out;\n\t}\n\n\tdst = &rt->dst;\n\n\tn = dst_neigh_lookup(dst, &daddr6->sin6_addr);\n\n\tif (!n) {\n\t\tpr_info(\"%pI6, port %u, dst no neighbour.\\n\",\n\t\t\tdaddr6->sin6_addr.s6_addr,\n\t\t\tbe16_to_cpu(daddr6->sin6_port));\n\t\terr = -ENETUNREACH;\n\t\tgoto rel_rt;\n\t}\n\tndev = n->dev;\n\n\tif (!(ndev->flags & IFF_UP) || !netif_carrier_ok(ndev)) {\n\t\tpr_info(\"%s interface not up.\\n\", ndev->name);\n\t\terr = -ENETDOWN;\n\t\tgoto rel_rt;\n\t}\n\n\tif (ipv6_addr_is_multicast(&daddr6->sin6_addr)) {\n\t\tpr_info(\"multi-cast route %pI6 port %u, dev %s.\\n\",\n\t\t\tdaddr6->sin6_addr.s6_addr,\n\t\t\tntohs(daddr6->sin6_port), ndev->name);\n\t\terr = -ENETUNREACH;\n\t\tgoto rel_rt;\n\t}\n\n\tcdev = cxgbi_device_find_by_netdev(ndev, &port);\n\tif (!cdev)\n\t\tcdev = cxgbi_device_find_by_mac(ndev, &port);\n\tif (!cdev) {\n\t\tpr_info(\"dst %pI6 %s, NOT cxgbi device.\\n\",\n\t\t\tdaddr6->sin6_addr.s6_addr, ndev->name);\n\t\terr = -ENETUNREACH;\n\t\tgoto rel_rt;\n\t}\n\tlog_debug(1 << CXGBI_DBG_SOCK,\n\t\t  \"route to %pI6 :%u, ndev p#%d,%s, cdev 0x%p.\\n\",\n\t\t  daddr6->sin6_addr.s6_addr, ntohs(daddr6->sin6_port), port,\n\t\t  ndev->name, cdev);\n\n\tcsk = cxgbi_sock_create(cdev);\n\tif (!csk) {\n\t\terr = -ENOMEM;\n\t\tgoto rel_rt;\n\t}\n\tcsk->cdev = cdev;\n\tcsk->port_id = port;\n\tcsk->mtu = mtu;\n\tcsk->dst = dst;\n\n\trt6_get_prefsrc(rt, &pref_saddr);\n\tif (ipv6_addr_any(&pref_saddr)) {\n\t\tstruct inet6_dev *idev = ip6_dst_idev((struct dst_entry *)rt);\n\n\t\terr = ipv6_dev_get_saddr(&init_net, idev ? idev->dev : NULL,\n\t\t\t\t\t &daddr6->sin6_addr, 0, &pref_saddr);\n\t\tif (err) {\n\t\t\tpr_info(\"failed to get source address to reach %pI6\\n\",\n\t\t\t\t&daddr6->sin6_addr);\n\t\t\tgoto rel_rt;\n\t\t}\n\t}\n\n\tcsk->csk_family = AF_INET6;\n\tcsk->daddr6.sin6_addr = daddr6->sin6_addr;\n\tcsk->daddr6.sin6_port = daddr6->sin6_port;\n\tcsk->daddr6.sin6_family = daddr6->sin6_family;\n\tcsk->saddr6.sin6_family = daddr6->sin6_family;\n\tcsk->saddr6.sin6_addr = pref_saddr;\n\n\tneigh_release(n);\n\treturn csk;\n\nrel_rt:\n\tif (n)\n\t\tneigh_release(n);\n\n\tip6_rt_put(rt);\n\tif (csk)\n\t\tcxgbi_sock_closed(csk);\nerr_out:\n\treturn ERR_PTR(err);\n}\n#endif  \n\nvoid cxgbi_sock_established(struct cxgbi_sock *csk, unsigned int snd_isn,\n\t\t\tunsigned int opt)\n{\n\tcsk->write_seq = csk->snd_nxt = csk->snd_una = snd_isn;\n\tdst_confirm(csk->dst);\n\tsmp_mb();\n\tcxgbi_sock_set_state(csk, CTP_ESTABLISHED);\n}\nEXPORT_SYMBOL_GPL(cxgbi_sock_established);\n\nstatic void cxgbi_inform_iscsi_conn_closing(struct cxgbi_sock *csk)\n{\n\tlog_debug(1 << CXGBI_DBG_SOCK,\n\t\t\"csk 0x%p, state %u, flags 0x%lx, conn 0x%p.\\n\",\n\t\tcsk, csk->state, csk->flags, csk->user_data);\n\n\tif (csk->state != CTP_ESTABLISHED) {\n\t\tread_lock_bh(&csk->callback_lock);\n\t\tif (csk->user_data)\n\t\t\tiscsi_conn_failure(csk->user_data,\n\t\t\t\t\tISCSI_ERR_TCP_CONN_CLOSE);\n\t\tread_unlock_bh(&csk->callback_lock);\n\t}\n}\n\nvoid cxgbi_sock_closed(struct cxgbi_sock *csk)\n{\n\tlog_debug(1 << CXGBI_DBG_SOCK, \"csk 0x%p,%u,0x%lx,%u.\\n\",\n\t\tcsk, (csk)->state, (csk)->flags, (csk)->tid);\n\tcxgbi_sock_set_flag(csk, CTPF_ACTIVE_CLOSE_NEEDED);\n\tif (csk->state == CTP_ACTIVE_OPEN || csk->state == CTP_CLOSED)\n\t\treturn;\n\tif (csk->saddr.sin_port)\n\t\tsock_put_port(csk);\n\tif (csk->dst)\n\t\tdst_release(csk->dst);\n\tcsk->cdev->csk_release_offload_resources(csk);\n\tcxgbi_sock_set_state(csk, CTP_CLOSED);\n\tcxgbi_inform_iscsi_conn_closing(csk);\n\tcxgbi_sock_put(csk);\n}\nEXPORT_SYMBOL_GPL(cxgbi_sock_closed);\n\nstatic void need_active_close(struct cxgbi_sock *csk)\n{\n\tint data_lost;\n\tint close_req = 0;\n\n\tlog_debug(1 << CXGBI_DBG_SOCK, \"csk 0x%p,%u,0x%lx,%u.\\n\",\n\t\tcsk, (csk)->state, (csk)->flags, (csk)->tid);\n\tspin_lock_bh(&csk->lock);\n\tif (csk->dst)\n\t\tdst_confirm(csk->dst);\n\tdata_lost = skb_queue_len(&csk->receive_queue);\n\t__skb_queue_purge(&csk->receive_queue);\n\n\tif (csk->state == CTP_ACTIVE_OPEN)\n\t\tcxgbi_sock_set_flag(csk, CTPF_ACTIVE_CLOSE_NEEDED);\n\telse if (csk->state == CTP_ESTABLISHED) {\n\t\tclose_req = 1;\n\t\tcxgbi_sock_set_state(csk, CTP_ACTIVE_CLOSE);\n\t} else if (csk->state == CTP_PASSIVE_CLOSE) {\n\t\tclose_req = 1;\n\t\tcxgbi_sock_set_state(csk, CTP_CLOSE_WAIT_2);\n\t}\n\n\tif (close_req) {\n\t\tif (!cxgbi_sock_flag(csk, CTPF_LOGOUT_RSP_RCVD) ||\n\t\t    data_lost)\n\t\t\tcsk->cdev->csk_send_abort_req(csk);\n\t\telse\n\t\t\tcsk->cdev->csk_send_close_req(csk);\n\t}\n\n\tspin_unlock_bh(&csk->lock);\n}\n\nvoid cxgbi_sock_fail_act_open(struct cxgbi_sock *csk, int errno)\n{\n\tpr_info(\"csk 0x%p,%u,%lx, %pI4:%u-%pI4:%u, err %d.\\n\",\n\t\t\tcsk, csk->state, csk->flags,\n\t\t\t&csk->saddr.sin_addr.s_addr, csk->saddr.sin_port,\n\t\t\t&csk->daddr.sin_addr.s_addr, csk->daddr.sin_port,\n\t\t\terrno);\n\n\tcxgbi_sock_set_state(csk, CTP_CONNECTING);\n\tcsk->err = errno;\n\tcxgbi_sock_closed(csk);\n}\nEXPORT_SYMBOL_GPL(cxgbi_sock_fail_act_open);\n\nvoid cxgbi_sock_act_open_req_arp_failure(void *handle, struct sk_buff *skb)\n{\n\tstruct cxgbi_sock *csk = (struct cxgbi_sock *)skb->sk;\n\tstruct module *owner = csk->cdev->owner;\n\n\tlog_debug(1 << CXGBI_DBG_SOCK, \"csk 0x%p,%u,0x%lx,%u.\\n\",\n\t\tcsk, (csk)->state, (csk)->flags, (csk)->tid);\n\tcxgbi_sock_get(csk);\n\tspin_lock_bh(&csk->lock);\n\tif (csk->state == CTP_ACTIVE_OPEN)\n\t\tcxgbi_sock_fail_act_open(csk, -EHOSTUNREACH);\n\tspin_unlock_bh(&csk->lock);\n\tcxgbi_sock_put(csk);\n\t__kfree_skb(skb);\n\n\tmodule_put(owner);\n}\nEXPORT_SYMBOL_GPL(cxgbi_sock_act_open_req_arp_failure);\n\nvoid cxgbi_sock_rcv_abort_rpl(struct cxgbi_sock *csk)\n{\n\tcxgbi_sock_get(csk);\n\tspin_lock_bh(&csk->lock);\n\n\tcxgbi_sock_set_flag(csk, CTPF_ABORT_RPL_RCVD);\n\tif (cxgbi_sock_flag(csk, CTPF_ABORT_RPL_PENDING)) {\n\t\tcxgbi_sock_clear_flag(csk, CTPF_ABORT_RPL_PENDING);\n\t\tif (cxgbi_sock_flag(csk, CTPF_ABORT_REQ_RCVD))\n\t\t\tpr_err(\"csk 0x%p,%u,0x%lx,%u,ABT_RPL_RSS.\\n\",\n\t\t\t       csk, csk->state, csk->flags, csk->tid);\n\t\tcxgbi_sock_closed(csk);\n\t}\n\n\tspin_unlock_bh(&csk->lock);\n\tcxgbi_sock_put(csk);\n}\nEXPORT_SYMBOL_GPL(cxgbi_sock_rcv_abort_rpl);\n\nvoid cxgbi_sock_rcv_peer_close(struct cxgbi_sock *csk)\n{\n\tlog_debug(1 << CXGBI_DBG_SOCK, \"csk 0x%p,%u,0x%lx,%u.\\n\",\n\t\tcsk, (csk)->state, (csk)->flags, (csk)->tid);\n\tcxgbi_sock_get(csk);\n\tspin_lock_bh(&csk->lock);\n\n\tif (cxgbi_sock_flag(csk, CTPF_ABORT_RPL_PENDING))\n\t\tgoto done;\n\n\tswitch (csk->state) {\n\tcase CTP_ESTABLISHED:\n\t\tcxgbi_sock_set_state(csk, CTP_PASSIVE_CLOSE);\n\t\tbreak;\n\tcase CTP_ACTIVE_CLOSE:\n\t\tcxgbi_sock_set_state(csk, CTP_CLOSE_WAIT_2);\n\t\tbreak;\n\tcase CTP_CLOSE_WAIT_1:\n\t\tcxgbi_sock_closed(csk);\n\t\tbreak;\n\tcase CTP_ABORTING:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"csk 0x%p,%u,0x%lx,%u, bad state.\\n\",\n\t\t\tcsk, csk->state, csk->flags, csk->tid);\n\t}\n\tcxgbi_inform_iscsi_conn_closing(csk);\ndone:\n\tspin_unlock_bh(&csk->lock);\n\tcxgbi_sock_put(csk);\n}\nEXPORT_SYMBOL_GPL(cxgbi_sock_rcv_peer_close);\n\nvoid cxgbi_sock_rcv_close_conn_rpl(struct cxgbi_sock *csk, u32 snd_nxt)\n{\n\tlog_debug(1 << CXGBI_DBG_SOCK, \"csk 0x%p,%u,0x%lx,%u.\\n\",\n\t\tcsk, (csk)->state, (csk)->flags, (csk)->tid);\n\tcxgbi_sock_get(csk);\n\tspin_lock_bh(&csk->lock);\n\n\tcsk->snd_una = snd_nxt - 1;\n\tif (cxgbi_sock_flag(csk, CTPF_ABORT_RPL_PENDING))\n\t\tgoto done;\n\n\tswitch (csk->state) {\n\tcase CTP_ACTIVE_CLOSE:\n\t\tcxgbi_sock_set_state(csk, CTP_CLOSE_WAIT_1);\n\t\tbreak;\n\tcase CTP_CLOSE_WAIT_1:\n\tcase CTP_CLOSE_WAIT_2:\n\t\tcxgbi_sock_closed(csk);\n\t\tbreak;\n\tcase CTP_ABORTING:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"csk 0x%p,%u,0x%lx,%u, bad state.\\n\",\n\t\t\tcsk, csk->state, csk->flags, csk->tid);\n\t}\ndone:\n\tspin_unlock_bh(&csk->lock);\n\tcxgbi_sock_put(csk);\n}\nEXPORT_SYMBOL_GPL(cxgbi_sock_rcv_close_conn_rpl);\n\nvoid cxgbi_sock_rcv_wr_ack(struct cxgbi_sock *csk, unsigned int credits,\n\t\t\t   unsigned int snd_una, int seq_chk)\n{\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\t\"csk 0x%p,%u,0x%lx,%u, cr %u,%u+%u, snd_una %u,%d.\\n\",\n\t\t\tcsk, csk->state, csk->flags, csk->tid, credits,\n\t\t\tcsk->wr_cred, csk->wr_una_cred, snd_una, seq_chk);\n\n\tspin_lock_bh(&csk->lock);\n\n\tcsk->wr_cred += credits;\n\tif (csk->wr_una_cred > csk->wr_max_cred - csk->wr_cred)\n\t\tcsk->wr_una_cred = csk->wr_max_cred - csk->wr_cred;\n\n\twhile (credits) {\n\t\tstruct sk_buff *p = cxgbi_sock_peek_wr(csk);\n\n\t\tif (unlikely(!p)) {\n\t\t\tpr_err(\"csk 0x%p,%u,0x%lx,%u, cr %u,%u+%u, empty.\\n\",\n\t\t\t\tcsk, csk->state, csk->flags, csk->tid, credits,\n\t\t\t\tcsk->wr_cred, csk->wr_una_cred);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(credits < p->csum)) {\n\t\t\tpr_warn(\"csk 0x%p,%u,0x%lx,%u, cr %u,%u+%u, < %u.\\n\",\n\t\t\t\tcsk, csk->state, csk->flags, csk->tid,\n\t\t\t\tcredits, csk->wr_cred, csk->wr_una_cred,\n\t\t\t\tp->csum);\n\t\t\tp->csum -= credits;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tcxgbi_sock_dequeue_wr(csk);\n\t\t\tcredits -= p->csum;\n\t\t\tkfree_skb(p);\n\t\t}\n\t}\n\n\tcxgbi_sock_check_wr_invariants(csk);\n\n\tif (seq_chk) {\n\t\tif (unlikely(before(snd_una, csk->snd_una))) {\n\t\t\tpr_warn(\"csk 0x%p,%u,0x%lx,%u, snd_una %u/%u.\",\n\t\t\t\tcsk, csk->state, csk->flags, csk->tid, snd_una,\n\t\t\t\tcsk->snd_una);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (csk->snd_una != snd_una) {\n\t\t\tcsk->snd_una = snd_una;\n\t\t\tdst_confirm(csk->dst);\n\t\t}\n\t}\n\n\tif (skb_queue_len(&csk->write_queue)) {\n\t\tif (csk->cdev->csk_push_tx_frames(csk, 0))\n\t\t\tcxgbi_conn_tx_open(csk);\n\t} else\n\t\tcxgbi_conn_tx_open(csk);\ndone:\n\tspin_unlock_bh(&csk->lock);\n}\nEXPORT_SYMBOL_GPL(cxgbi_sock_rcv_wr_ack);\n\nstatic unsigned int cxgbi_sock_find_best_mtu(struct cxgbi_sock *csk,\n\t\t\t\t\t     unsigned short mtu)\n{\n\tint i = 0;\n\n\twhile (i < csk->cdev->nmtus - 1 && csk->cdev->mtus[i + 1] <= mtu)\n\t\t++i;\n\n\treturn i;\n}\n\nunsigned int cxgbi_sock_select_mss(struct cxgbi_sock *csk, unsigned int pmtu)\n{\n\tunsigned int idx;\n\tstruct dst_entry *dst = csk->dst;\n\n\tcsk->advmss = dst_metric_advmss(dst);\n\n\tif (csk->advmss > pmtu - 40)\n\t\tcsk->advmss = pmtu - 40;\n\tif (csk->advmss < csk->cdev->mtus[0] - 40)\n\t\tcsk->advmss = csk->cdev->mtus[0] - 40;\n\tidx = cxgbi_sock_find_best_mtu(csk, csk->advmss + 40);\n\n\treturn idx;\n}\nEXPORT_SYMBOL_GPL(cxgbi_sock_select_mss);\n\nvoid cxgbi_sock_skb_entail(struct cxgbi_sock *csk, struct sk_buff *skb)\n{\n\tcxgbi_skcb_tcp_seq(skb) = csk->write_seq;\n\t__skb_queue_tail(&csk->write_queue, skb);\n}\nEXPORT_SYMBOL_GPL(cxgbi_sock_skb_entail);\n\nvoid cxgbi_sock_purge_wr_queue(struct cxgbi_sock *csk)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = cxgbi_sock_dequeue_wr(csk)) != NULL)\n\t\tkfree_skb(skb);\n}\nEXPORT_SYMBOL_GPL(cxgbi_sock_purge_wr_queue);\n\nvoid cxgbi_sock_check_wr_invariants(const struct cxgbi_sock *csk)\n{\n\tint pending = cxgbi_sock_count_pending_wrs(csk);\n\n\tif (unlikely(csk->wr_cred + pending != csk->wr_max_cred))\n\t\tpr_err(\"csk 0x%p, tid %u, credit %u + %u != %u.\\n\",\n\t\t\tcsk, csk->tid, csk->wr_cred, pending, csk->wr_max_cred);\n}\nEXPORT_SYMBOL_GPL(cxgbi_sock_check_wr_invariants);\n\nstatic inline void\nscmd_get_params(struct scsi_cmnd *sc, struct scatterlist **sgl,\n\t\tunsigned int *sgcnt, unsigned int *dlen,\n\t\tunsigned int prot)\n{\n\tstruct scsi_data_buffer *sdb = prot ? scsi_prot(sc) : &sc->sdb;\n\n\t*sgl = sdb->table.sgl;\n\t*sgcnt = sdb->table.nents;\n\t*dlen = sdb->length;\n\t \n}\n\nvoid cxgbi_ddp_set_one_ppod(struct cxgbi_pagepod *ppod,\n\t\t\t    struct cxgbi_task_tag_info *ttinfo,\n\t\t\t    struct scatterlist **sg_pp, unsigned int *sg_off)\n{\n\tstruct scatterlist *sg = sg_pp ? *sg_pp : NULL;\n\tunsigned int offset = sg_off ? *sg_off : 0;\n\tdma_addr_t addr = 0UL;\n\tunsigned int len = 0;\n\tint i;\n\n\tmemcpy(ppod, &ttinfo->hdr, sizeof(struct cxgbi_pagepod_hdr));\n\n\tif (sg) {\n\t\taddr = sg_dma_address(sg);\n\t\tlen = sg_dma_len(sg);\n\t}\n\n\tfor (i = 0; i < PPOD_PAGES_MAX; i++) {\n\t\tif (sg) {\n\t\t\tppod->addr[i] = cpu_to_be64(addr + offset);\n\t\t\toffset += PAGE_SIZE;\n\t\t\tif (offset == (len + sg->offset)) {\n\t\t\t\toffset = 0;\n\t\t\t\tsg = sg_next(sg);\n\t\t\t\tif (sg) {\n\t\t\t\t\taddr = sg_dma_address(sg);\n\t\t\t\t\tlen = sg_dma_len(sg);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tppod->addr[i] = 0ULL;\n\t\t}\n\t}\n\n\t \n\tif (sg_pp) {\n\t\t*sg_pp = sg;\n\t\t*sg_off = offset;\n\t}\n\n\tif (offset == len) {\n\t\toffset = 0;\n\t\tsg = sg_next(sg);\n\t\tif (sg) {\n\t\t\taddr = sg_dma_address(sg);\n\t\t\tlen = sg_dma_len(sg);\n\t\t}\n\t}\n\tppod->addr[i] = sg ? cpu_to_be64(addr + offset) : 0ULL;\n}\nEXPORT_SYMBOL_GPL(cxgbi_ddp_set_one_ppod);\n\n \n\nint cxgbi_ddp_ppm_setup(void **ppm_pp, struct cxgbi_device *cdev,\n\t\t\tstruct cxgbi_tag_format *tformat,\n\t\t\tunsigned int iscsi_size, unsigned int llimit,\n\t\t\tunsigned int start, unsigned int rsvd_factor,\n\t\t\tunsigned int edram_start, unsigned int edram_size)\n{\n\tint err = cxgbi_ppm_init(ppm_pp, cdev->ports[0], cdev->pdev,\n\t\t\t\tcdev->lldev, tformat, iscsi_size, llimit, start,\n\t\t\t\trsvd_factor, edram_start, edram_size);\n\n\tif (err >= 0) {\n\t\tstruct cxgbi_ppm *ppm = (struct cxgbi_ppm *)(*ppm_pp);\n\n\t\tif (ppm->ppmax < 1024 ||\n\t\t    ppm->tformat.pgsz_idx_dflt >= DDP_PGIDX_MAX)\n\t\t\tcdev->flags |= CXGBI_FLAG_DDP_OFF;\n\t\terr = 0;\n\t} else {\n\t\tcdev->flags |= CXGBI_FLAG_DDP_OFF;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(cxgbi_ddp_ppm_setup);\n\nstatic int cxgbi_ddp_sgl_check(struct scatterlist *sgl, int nents)\n{\n\tint i;\n\tint last_sgidx = nents - 1;\n\tstruct scatterlist *sg = sgl;\n\n\tfor (i = 0; i < nents; i++, sg = sg_next(sg)) {\n\t\tunsigned int len = sg->length + sg->offset;\n\n\t\tif ((sg->offset & 0x3) || (i && sg->offset) ||\n\t\t    ((i != last_sgidx) && len != PAGE_SIZE)) {\n\t\t\tlog_debug(1 << CXGBI_DBG_DDP,\n\t\t\t\t  \"sg %u/%u, %u,%u, not aligned.\\n\",\n\t\t\t\t  i, nents, sg->offset, sg->length);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\treturn 0;\nerr_out:\n\treturn -EINVAL;\n}\n\nstatic int cxgbi_ddp_reserve(struct cxgbi_conn *cconn,\n\t\t\t     struct cxgbi_task_data *tdata, u32 sw_tag,\n\t\t\t     unsigned int xferlen)\n{\n\tstruct cxgbi_sock *csk = cconn->cep->csk;\n\tstruct cxgbi_device *cdev = csk->cdev;\n\tstruct cxgbi_ppm *ppm = cdev->cdev2ppm(cdev);\n\tstruct cxgbi_task_tag_info *ttinfo = &tdata->ttinfo;\n\tstruct scatterlist *sgl = ttinfo->sgl;\n\tunsigned int sgcnt = ttinfo->nents;\n\tunsigned int sg_offset = sgl->offset;\n\tint err;\n\n\tif (cdev->flags & CXGBI_FLAG_DDP_OFF) {\n\t\tlog_debug(1 << CXGBI_DBG_DDP,\n\t\t\t  \"cdev 0x%p DDP off.\\n\", cdev);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ppm || xferlen < DDP_THRESHOLD || !sgcnt ||\n\t    ppm->tformat.pgsz_idx_dflt >= DDP_PGIDX_MAX) {\n\t\tlog_debug(1 << CXGBI_DBG_DDP,\n\t\t\t  \"ppm 0x%p, pgidx %u, xfer %u, sgcnt %u, NO ddp.\\n\",\n\t\t\t  ppm, ppm ? ppm->tformat.pgsz_idx_dflt : DDP_PGIDX_MAX,\n\t\t\t  xferlen, ttinfo->nents);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (cxgbi_ddp_sgl_check(sgl, sgcnt) < 0)\n\t\treturn -EINVAL;\n\n\tttinfo->nr_pages = (xferlen + sgl->offset + (1 << PAGE_SHIFT) - 1) >>\n\t\t\t    PAGE_SHIFT;\n\n\t \n\terr = cxgbi_ppm_ppods_reserve(ppm, ttinfo->nr_pages, 0, &ttinfo->idx,\n\t\t\t\t      &ttinfo->tag, (unsigned long)sw_tag);\n\tif (err < 0) {\n\t\tcconn->ddp_full++;\n\t\treturn err;\n\t}\n\tttinfo->npods = err;\n\n\t  \n\tsgl->offset = 0;\n\terr = dma_map_sg(&ppm->pdev->dev, sgl, sgcnt, DMA_FROM_DEVICE);\n\tsgl->offset = sg_offset;\n\tif (err == 0) {\n\t\tpr_info(\"%s: 0x%x, xfer %u, sgl %u dma mapping err.\\n\",\n\t\t\t__func__, sw_tag, xferlen, sgcnt);\n\t\tgoto rel_ppods;\n\t}\n\tif (err != ttinfo->nr_pages) {\n\t\tlog_debug(1 << CXGBI_DBG_DDP,\n\t\t\t  \"%s: sw tag 0x%x, xfer %u, sgl %u, dma count %d.\\n\",\n\t\t\t  __func__, sw_tag, xferlen, sgcnt, err);\n\t}\n\n\tttinfo->flags |= CXGBI_PPOD_INFO_FLAG_MAPPED;\n\tttinfo->cid = csk->port_id;\n\n\tcxgbi_ppm_make_ppod_hdr(ppm, ttinfo->tag, csk->tid, sgl->offset,\n\t\t\t\txferlen, &ttinfo->hdr);\n\n\tif (cdev->flags & CXGBI_FLAG_USE_PPOD_OFLDQ) {\n\t\t \n\t\tttinfo->flags |= CXGBI_PPOD_INFO_FLAG_VALID;\n\t} else {\n\t\t \n\t\terr = cdev->csk_ddp_set_map(ppm, csk, ttinfo);\n\t\tif (err < 0)\n\t\t\tgoto rel_ppods;\n\t}\n\n\treturn 0;\n\nrel_ppods:\n\tcxgbi_ppm_ppod_release(ppm, ttinfo->idx);\n\n\tif (ttinfo->flags & CXGBI_PPOD_INFO_FLAG_MAPPED) {\n\t\tttinfo->flags &= ~CXGBI_PPOD_INFO_FLAG_MAPPED;\n\t\tdma_unmap_sg(&ppm->pdev->dev, sgl, sgcnt, DMA_FROM_DEVICE);\n\t}\n\treturn -EINVAL;\n}\n\nstatic void task_release_itt(struct iscsi_task *task, itt_t hdr_itt)\n{\n\tstruct scsi_cmnd *sc = task->sc;\n\tstruct iscsi_tcp_conn *tcp_conn = task->conn->dd_data;\n\tstruct cxgbi_conn *cconn = tcp_conn->dd_data;\n\tstruct cxgbi_device *cdev = cconn->chba->cdev;\n\tstruct cxgbi_ppm *ppm = cdev->cdev2ppm(cdev);\n\tu32 tag = ntohl((__force u32)hdr_itt);\n\n\tlog_debug(1 << CXGBI_DBG_DDP,\n\t\t  \"cdev 0x%p, task 0x%p, release tag 0x%x.\\n\",\n\t\t  cdev, task, tag);\n\tif (sc && sc->sc_data_direction == DMA_FROM_DEVICE &&\n\t    cxgbi_ppm_is_ddp_tag(ppm, tag)) {\n\t\tstruct cxgbi_task_data *tdata = iscsi_task_cxgbi_data(task);\n\t\tstruct cxgbi_task_tag_info *ttinfo = &tdata->ttinfo;\n\n\t\tif (!(cdev->flags & CXGBI_FLAG_USE_PPOD_OFLDQ))\n\t\t\tcdev->csk_ddp_clear_map(cdev, ppm, ttinfo);\n\t\tcxgbi_ppm_ppod_release(ppm, ttinfo->idx);\n\t\tdma_unmap_sg(&ppm->pdev->dev, ttinfo->sgl, ttinfo->nents,\n\t\t\t     DMA_FROM_DEVICE);\n\t}\n}\n\nstatic inline u32 cxgbi_build_sw_tag(u32 idx, u32 age)\n{\n\t \n\treturn (idx << 16) | age;\n}\n\nstatic int task_reserve_itt(struct iscsi_task *task, itt_t *hdr_itt)\n{\n\tstruct scsi_cmnd *sc = task->sc;\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct iscsi_session *sess = conn->session;\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct cxgbi_conn *cconn = tcp_conn->dd_data;\n\tstruct cxgbi_device *cdev = cconn->chba->cdev;\n\tstruct cxgbi_ppm *ppm = cdev->cdev2ppm(cdev);\n\tu32 sw_tag = cxgbi_build_sw_tag(task->itt, sess->age);\n\tu32 tag = 0;\n\tint err = -EINVAL;\n\n\tif (sc && sc->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tstruct cxgbi_task_data *tdata = iscsi_task_cxgbi_data(task);\n\t\tstruct cxgbi_task_tag_info *ttinfo = &tdata->ttinfo;\n\n\t\tscmd_get_params(sc, &ttinfo->sgl, &ttinfo->nents,\n\t\t\t\t&tdata->dlen, 0);\n\t\terr = cxgbi_ddp_reserve(cconn, tdata, sw_tag, tdata->dlen);\n\t\tif (!err)\n\t\t\ttag = ttinfo->tag;\n\t\telse\n\t\t\t log_debug(1 << CXGBI_DBG_DDP,\n\t\t\t\t   \"csk 0x%p, R task 0x%p, %u,%u, no ddp.\\n\",\n\t\t\t\t   cconn->cep->csk, task, tdata->dlen,\n\t\t\t\t   ttinfo->nents);\n\t}\n\n\tif (err < 0) {\n\t\terr = cxgbi_ppm_make_non_ddp_tag(ppm, sw_tag, &tag);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t \n\t*hdr_itt = (__force itt_t)htonl(tag);\n\n\tlog_debug(1 << CXGBI_DBG_DDP,\n\t\t  \"cdev 0x%p, task 0x%p, 0x%x(0x%x,0x%x)->0x%x/0x%x.\\n\",\n\t\t  cdev, task, sw_tag, task->itt, sess->age, tag, *hdr_itt);\n\treturn 0;\n}\n\nvoid cxgbi_parse_pdu_itt(struct iscsi_conn *conn, itt_t itt, int *idx, int *age)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct cxgbi_conn *cconn = tcp_conn->dd_data;\n\tstruct cxgbi_device *cdev = cconn->chba->cdev;\n\tstruct cxgbi_ppm *ppm = cdev->cdev2ppm(cdev);\n\tu32 tag = ntohl((__force u32)itt);\n\tu32 sw_bits;\n\n\tif (ppm) {\n\t\tif (cxgbi_ppm_is_ddp_tag(ppm, tag))\n\t\t\tsw_bits = cxgbi_ppm_get_tag_caller_data(ppm, tag);\n\t\telse\n\t\t\tsw_bits = cxgbi_ppm_decode_non_ddp_tag(ppm, tag);\n\t} else {\n\t\tsw_bits = tag;\n\t}\n\n\tcxgbi_decode_sw_tag(sw_bits, idx, age);\n\tlog_debug(1 << CXGBI_DBG_DDP,\n\t\t  \"cdev 0x%p, tag 0x%x/0x%x, -> 0x%x(0x%x,0x%x).\\n\",\n\t\t  cdev, tag, itt, sw_bits, idx ? *idx : 0xFFFFF,\n\t\t  age ? *age : 0xFF);\n}\nEXPORT_SYMBOL_GPL(cxgbi_parse_pdu_itt);\n\nvoid cxgbi_conn_tx_open(struct cxgbi_sock *csk)\n{\n\tstruct iscsi_conn *conn = csk->user_data;\n\n\tif (conn) {\n\t\tlog_debug(1 << CXGBI_DBG_SOCK,\n\t\t\t\"csk 0x%p, cid %d.\\n\", csk, conn->id);\n\t\tiscsi_conn_queue_xmit(conn);\n\t}\n}\nEXPORT_SYMBOL_GPL(cxgbi_conn_tx_open);\n\n \nstatic inline int read_pdu_skb(struct iscsi_conn *conn,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       unsigned int offset,\n\t\t\t       int offloaded)\n{\n\tint status = 0;\n\tint bytes_read;\n\n\tbytes_read = iscsi_tcp_recv_skb(conn, skb, offset, offloaded, &status);\n\tswitch (status) {\n\tcase ISCSI_TCP_CONN_ERR:\n\t\tpr_info(\"skb 0x%p, off %u, %d, TCP_ERR.\\n\",\n\t\t\t  skb, offset, offloaded);\n\t\treturn -EIO;\n\tcase ISCSI_TCP_SUSPENDED:\n\t\tlog_debug(1 << CXGBI_DBG_PDU_RX,\n\t\t\t\"skb 0x%p, off %u, %d, TCP_SUSPEND, rc %d.\\n\",\n\t\t\tskb, offset, offloaded, bytes_read);\n\t\t \n\t\treturn bytes_read;\n\tcase ISCSI_TCP_SKB_DONE:\n\t\tpr_info(\"skb 0x%p, off %u, %d, TCP_SKB_DONE.\\n\",\n\t\t\tskb, offset, offloaded);\n\t\t \n\t\tiscsi_conn_printk(KERN_ERR, conn, \"Invalid pdu or skb.\");\n\t\treturn -EFAULT;\n\tcase ISCSI_TCP_SEGMENT_DONE:\n\t\tlog_debug(1 << CXGBI_DBG_PDU_RX,\n\t\t\t\"skb 0x%p, off %u, %d, TCP_SEG_DONE, rc %d.\\n\",\n\t\t\tskb, offset, offloaded, bytes_read);\n\t\treturn bytes_read;\n\tdefault:\n\t\tpr_info(\"skb 0x%p, off %u, %d, invalid status %d.\\n\",\n\t\t\tskb, offset, offloaded, status);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int\nskb_read_pdu_bhs(struct cxgbi_sock *csk, struct iscsi_conn *conn,\n\t\t struct sk_buff *skb)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tint err;\n\n\tlog_debug(1 << CXGBI_DBG_PDU_RX,\n\t\t\"conn 0x%p, skb 0x%p, len %u, flag 0x%lx.\\n\",\n\t\tconn, skb, skb->len, cxgbi_skcb_flags(skb));\n\n\tif (!iscsi_tcp_recv_segment_is_hdr(tcp_conn)) {\n\t\tpr_info(\"conn 0x%p, skb 0x%p, not hdr.\\n\", conn, skb);\n\t\tiscsi_conn_failure(conn, ISCSI_ERR_PROTO);\n\t\treturn -EIO;\n\t}\n\n\tif (conn->hdrdgst_en &&\n\t    cxgbi_skcb_test_flag(skb, SKCBF_RX_HCRC_ERR)) {\n\t\tpr_info(\"conn 0x%p, skb 0x%p, hcrc.\\n\", conn, skb);\n\t\tiscsi_conn_failure(conn, ISCSI_ERR_HDR_DGST);\n\t\treturn -EIO;\n\t}\n\n\tif (cxgbi_skcb_test_flag(skb, SKCBF_RX_ISCSI_COMPL) &&\n\t    cxgbi_skcb_test_flag(skb, SKCBF_RX_DATA_DDPD)) {\n\t\t \n\t\titt_t itt = ((struct iscsi_data *)skb->data)->itt;\n\t\tstruct iscsi_task *task = iscsi_itt_to_ctask(conn, itt);\n\t\tu32 data_sn = be32_to_cpu(((struct iscsi_data *)\n\t\t\t\t\t\t\tskb->data)->datasn);\n\t\tif (task && task->sc) {\n\t\t\tstruct iscsi_tcp_task *tcp_task = task->dd_data;\n\n\t\t\ttcp_task->exp_datasn = data_sn;\n\t\t}\n\t}\n\n\terr = read_pdu_skb(conn, skb, 0, 0);\n\tif (likely(err >= 0)) {\n\t\tstruct iscsi_hdr *hdr = (struct iscsi_hdr *)skb->data;\n\t\tu8 opcode = hdr->opcode & ISCSI_OPCODE_MASK;\n\n\t\tif (unlikely(opcode == ISCSI_OP_LOGOUT_RSP))\n\t\t\tcxgbi_sock_set_flag(csk, CTPF_LOGOUT_RSP_RCVD);\n\t}\n\n\treturn err;\n}\n\nstatic int skb_read_pdu_data(struct iscsi_conn *conn, struct sk_buff *lskb,\n\t\t\t     struct sk_buff *skb, unsigned int offset)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tbool offloaded = 0;\n\tint opcode = tcp_conn->in.hdr->opcode & ISCSI_OPCODE_MASK;\n\n\tlog_debug(1 << CXGBI_DBG_PDU_RX,\n\t\t\"conn 0x%p, skb 0x%p, len %u, flag 0x%lx.\\n\",\n\t\tconn, skb, skb->len, cxgbi_skcb_flags(skb));\n\n\tif (conn->datadgst_en &&\n\t    cxgbi_skcb_test_flag(lskb, SKCBF_RX_DCRC_ERR)) {\n\t\tpr_info(\"conn 0x%p, skb 0x%p, dcrc 0x%lx.\\n\",\n\t\t\tconn, lskb, cxgbi_skcb_flags(lskb));\n\t\tiscsi_conn_failure(conn, ISCSI_ERR_DATA_DGST);\n\t\treturn -EIO;\n\t}\n\n\tif (iscsi_tcp_recv_segment_is_hdr(tcp_conn))\n\t\treturn 0;\n\n\t \n\tif (lskb == skb && conn->hdrdgst_en)\n\t\toffset += ISCSI_DIGEST_SIZE;\n\n\tif (cxgbi_skcb_test_flag(lskb, SKCBF_RX_DATA_DDPD))\n\t\toffloaded = 1;\n\n\tif (opcode == ISCSI_OP_SCSI_DATA_IN)\n\t\tlog_debug(1 << CXGBI_DBG_PDU_RX,\n\t\t\t\"skb 0x%p, op 0x%x, itt 0x%x, %u %s ddp'ed.\\n\",\n\t\t\tskb, opcode, ntohl(tcp_conn->in.hdr->itt),\n\t\t\ttcp_conn->in.datalen, offloaded ? \"is\" : \"not\");\n\n\treturn read_pdu_skb(conn, skb, offset, offloaded);\n}\n\nstatic void csk_return_rx_credits(struct cxgbi_sock *csk, int copied)\n{\n\tstruct cxgbi_device *cdev = csk->cdev;\n\tint must_send;\n\tu32 credits;\n\n\tlog_debug(1 << CXGBI_DBG_PDU_RX,\n\t\t\"csk 0x%p,%u,0x%lx,%u, seq %u, wup %u, thre %u, %u.\\n\",\n\t\tcsk, csk->state, csk->flags, csk->tid, csk->copied_seq,\n\t\tcsk->rcv_wup, cdev->rx_credit_thres,\n\t\tcsk->rcv_win);\n\n\tif (!cdev->rx_credit_thres)\n\t\treturn;\n\n\tif (csk->state != CTP_ESTABLISHED)\n\t\treturn;\n\n\tcredits = csk->copied_seq - csk->rcv_wup;\n\tif (unlikely(!credits))\n\t\treturn;\n\tmust_send = credits + 16384 >= csk->rcv_win;\n\tif (must_send || credits >= cdev->rx_credit_thres)\n\t\tcsk->rcv_wup += cdev->csk_send_rx_credits(csk, credits);\n}\n\nvoid cxgbi_conn_pdu_ready(struct cxgbi_sock *csk)\n{\n\tstruct cxgbi_device *cdev = csk->cdev;\n\tstruct iscsi_conn *conn = csk->user_data;\n\tstruct sk_buff *skb;\n\tunsigned int read = 0;\n\tint err = 0;\n\n\tlog_debug(1 << CXGBI_DBG_PDU_RX,\n\t\t\"csk 0x%p, conn 0x%p.\\n\", csk, conn);\n\n\tif (unlikely(!conn || test_bit(ISCSI_CONN_FLAG_SUSPEND_RX, &conn->flags))) {\n\t\tlog_debug(1 << CXGBI_DBG_PDU_RX,\n\t\t\t\"csk 0x%p, conn 0x%p, id %d, conn flags 0x%lx!\\n\",\n\t\t\tcsk, conn, conn ? conn->id : 0xFF,\n\t\t\tconn ? conn->flags : 0xFF);\n\t\treturn;\n\t}\n\n\twhile (!err) {\n\t\tskb = skb_peek(&csk->receive_queue);\n\t\tif (!skb ||\n\t\t    !(cxgbi_skcb_test_flag(skb, SKCBF_RX_STATUS))) {\n\t\t\tif (skb)\n\t\t\t\tlog_debug(1 << CXGBI_DBG_PDU_RX,\n\t\t\t\t\t\"skb 0x%p, NOT ready 0x%lx.\\n\",\n\t\t\t\t\tskb, cxgbi_skcb_flags(skb));\n\t\t\tbreak;\n\t\t}\n\t\t__skb_unlink(skb, &csk->receive_queue);\n\n\t\tread += cxgbi_skcb_rx_pdulen(skb);\n\t\tlog_debug(1 << CXGBI_DBG_PDU_RX,\n\t\t\t\"csk 0x%p, skb 0x%p,%u,f 0x%lx, pdu len %u.\\n\",\n\t\t\tcsk, skb, skb->len, cxgbi_skcb_flags(skb),\n\t\t\tcxgbi_skcb_rx_pdulen(skb));\n\n\t\tif (cxgbi_skcb_test_flag(skb, SKCBF_RX_COALESCED)) {\n\t\t\terr = skb_read_pdu_bhs(csk, conn, skb);\n\t\t\tif (err < 0) {\n\t\t\t\tpr_err(\"coalesced bhs, csk 0x%p, skb 0x%p,%u, \"\n\t\t\t\t\t\"f 0x%lx, plen %u.\\n\",\n\t\t\t\t\tcsk, skb, skb->len,\n\t\t\t\t\tcxgbi_skcb_flags(skb),\n\t\t\t\t\tcxgbi_skcb_rx_pdulen(skb));\n\t\t\t\tgoto skb_done;\n\t\t\t}\n\t\t\terr = skb_read_pdu_data(conn, skb, skb,\n\t\t\t\t\t\terr + cdev->skb_rx_extra);\n\t\t\tif (err < 0)\n\t\t\t\tpr_err(\"coalesced data, csk 0x%p, skb 0x%p,%u, \"\n\t\t\t\t\t\"f 0x%lx, plen %u.\\n\",\n\t\t\t\t\tcsk, skb, skb->len,\n\t\t\t\t\tcxgbi_skcb_flags(skb),\n\t\t\t\t\tcxgbi_skcb_rx_pdulen(skb));\n\t\t} else {\n\t\t\terr = skb_read_pdu_bhs(csk, conn, skb);\n\t\t\tif (err < 0) {\n\t\t\t\tpr_err(\"bhs, csk 0x%p, skb 0x%p,%u, \"\n\t\t\t\t\t\"f 0x%lx, plen %u.\\n\",\n\t\t\t\t\tcsk, skb, skb->len,\n\t\t\t\t\tcxgbi_skcb_flags(skb),\n\t\t\t\t\tcxgbi_skcb_rx_pdulen(skb));\n\t\t\t\tgoto skb_done;\n\t\t\t}\n\n\t\t\tif (cxgbi_skcb_test_flag(skb, SKCBF_RX_DATA)) {\n\t\t\t\tstruct sk_buff *dskb;\n\n\t\t\t\tdskb = skb_peek(&csk->receive_queue);\n\t\t\t\tif (!dskb) {\n\t\t\t\t\tpr_err(\"csk 0x%p, skb 0x%p,%u, f 0x%lx,\"\n\t\t\t\t\t\t\" plen %u, NO data.\\n\",\n\t\t\t\t\t\tcsk, skb, skb->len,\n\t\t\t\t\t\tcxgbi_skcb_flags(skb),\n\t\t\t\t\t\tcxgbi_skcb_rx_pdulen(skb));\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto skb_done;\n\t\t\t\t}\n\t\t\t\t__skb_unlink(dskb, &csk->receive_queue);\n\n\t\t\t\terr = skb_read_pdu_data(conn, skb, dskb, 0);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tpr_err(\"data, csk 0x%p, skb 0x%p,%u, \"\n\t\t\t\t\t\t\"f 0x%lx, plen %u, dskb 0x%p,\"\n\t\t\t\t\t\t\"%u.\\n\",\n\t\t\t\t\t\tcsk, skb, skb->len,\n\t\t\t\t\t\tcxgbi_skcb_flags(skb),\n\t\t\t\t\t\tcxgbi_skcb_rx_pdulen(skb),\n\t\t\t\t\t\tdskb, dskb->len);\n\t\t\t\t__kfree_skb(dskb);\n\t\t\t} else\n\t\t\t\terr = skb_read_pdu_data(conn, skb, skb, 0);\n\t\t}\nskb_done:\n\t\t__kfree_skb(skb);\n\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\tlog_debug(1 << CXGBI_DBG_PDU_RX, \"csk 0x%p, read %u.\\n\", csk, read);\n\tif (read) {\n\t\tcsk->copied_seq += read;\n\t\tcsk_return_rx_credits(csk, read);\n\t\tconn->rxdata_octets += read;\n\t}\n\n\tif (err < 0) {\n\t\tpr_info(\"csk 0x%p, 0x%p, rx failed %d, read %u.\\n\",\n\t\t\tcsk, conn, err, read);\n\t\tiscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);\n\t}\n}\nEXPORT_SYMBOL_GPL(cxgbi_conn_pdu_ready);\n\nstatic int sgl_seek_offset(struct scatterlist *sgl, unsigned int sgcnt,\n\t\t\t\tunsigned int offset, unsigned int *off,\n\t\t\t\tstruct scatterlist **sgp)\n{\n\tint i;\n\tstruct scatterlist *sg;\n\n\tfor_each_sg(sgl, sg, sgcnt, i) {\n\t\tif (offset < sg->length) {\n\t\t\t*off = offset;\n\t\t\t*sgp = sg;\n\t\t\treturn 0;\n\t\t}\n\t\toffset -= sg->length;\n\t}\n\treturn -EFAULT;\n}\n\nstatic int\nsgl_read_to_frags(struct scatterlist *sg, unsigned int sgoffset,\n\t\t  unsigned int dlen, struct page_frag *frags,\n\t\t  int frag_max, u32 *dlimit)\n{\n\tunsigned int datalen = dlen;\n\tunsigned int sglen = sg->length - sgoffset;\n\tstruct page *page = sg_page(sg);\n\tint i;\n\n\ti = 0;\n\tdo {\n\t\tunsigned int copy;\n\n\t\tif (!sglen) {\n\t\t\tsg = sg_next(sg);\n\t\t\tif (!sg) {\n\t\t\t\tpr_warn(\"sg %d NULL, len %u/%u.\\n\",\n\t\t\t\t\ti, datalen, dlen);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsgoffset = 0;\n\t\t\tsglen = sg->length;\n\t\t\tpage = sg_page(sg);\n\n\t\t}\n\t\tcopy = min(datalen, sglen);\n\t\tif (i && page == frags[i - 1].page &&\n\t\t    sgoffset + sg->offset ==\n\t\t\tfrags[i - 1].offset + frags[i - 1].size) {\n\t\t\tfrags[i - 1].size += copy;\n\t\t} else {\n\t\t\tif (i >= frag_max) {\n\t\t\t\tpr_warn(\"too many pages %u, dlen %u.\\n\",\n\t\t\t\t\tfrag_max, dlen);\n\t\t\t\t*dlimit = dlen - datalen;\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tfrags[i].page = page;\n\t\t\tfrags[i].offset = sg->offset + sgoffset;\n\t\t\tfrags[i].size = copy;\n\t\t\ti++;\n\t\t}\n\t\tdatalen -= copy;\n\t\tsgoffset += copy;\n\t\tsglen -= copy;\n\t} while (datalen);\n\n\treturn i;\n}\n\nstatic void cxgbi_task_data_sgl_check(struct iscsi_task *task)\n{\n\tstruct scsi_cmnd *sc = task->sc;\n\tstruct cxgbi_task_data *tdata = iscsi_task_cxgbi_data(task);\n\tstruct scatterlist *sg, *sgl = NULL;\n\tu32 sgcnt = 0;\n\tint i;\n\n\ttdata->flags = CXGBI_TASK_SGL_CHECKED;\n\tif (!sc)\n\t\treturn;\n\n\tscmd_get_params(sc, &sgl, &sgcnt, &tdata->dlen, 0);\n\tif (!sgl || !sgcnt) {\n\t\ttdata->flags |= CXGBI_TASK_SGL_COPY;\n\t\treturn;\n\t}\n\n\tfor_each_sg(sgl, sg, sgcnt, i) {\n\t\tif (page_count(sg_page(sg)) < 1) {\n\t\t\ttdata->flags |= CXGBI_TASK_SGL_COPY;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int\ncxgbi_task_data_sgl_read(struct iscsi_task *task, u32 offset, u32 count,\n\t\t\t u32 *dlimit)\n{\n\tstruct scsi_cmnd *sc = task->sc;\n\tstruct cxgbi_task_data *tdata = iscsi_task_cxgbi_data(task);\n\tstruct scatterlist *sgl = NULL;\n\tstruct scatterlist *sg;\n\tu32 dlen = 0;\n\tu32 sgcnt;\n\tint err;\n\n\tif (!sc)\n\t\treturn 0;\n\n\tscmd_get_params(sc, &sgl, &sgcnt, &dlen, 0);\n\tif (!sgl || !sgcnt)\n\t\treturn 0;\n\n\terr = sgl_seek_offset(sgl, sgcnt, offset, &tdata->sgoffset, &sg);\n\tif (err < 0) {\n\t\tpr_warn(\"tpdu max, sgl %u, bad offset %u/%u.\\n\",\n\t\t\tsgcnt, offset, tdata->dlen);\n\t\treturn err;\n\t}\n\terr = sgl_read_to_frags(sg, tdata->sgoffset, count,\n\t\t\t\ttdata->frags, MAX_SKB_FRAGS, dlimit);\n\tif (err < 0) {\n\t\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t\t  \"sgl max limit, sgl %u, offset %u, %u/%u, dlimit %u.\\n\",\n\t\t\t  sgcnt, offset, count, tdata->dlen, *dlimit);\n\t\treturn err;\n\t}\n\ttdata->offset = offset;\n\ttdata->count = count;\n\ttdata->nr_frags = err;\n\ttdata->total_count = count;\n\ttdata->total_offset = offset;\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI | 1 << CXGBI_DBG_PDU_TX,\n\t\t  \"%s: offset %u, count %u,\\n\"\n\t\t  \"err %u, total_count %u, total_offset %u\\n\",\n\t\t  __func__, offset, count, err,  tdata->total_count, tdata->total_offset);\n\n\treturn 0;\n}\n\nint cxgbi_conn_alloc_pdu(struct iscsi_task *task, u8 op)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct iscsi_session *session = task->conn->session;\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct cxgbi_conn *cconn = tcp_conn->dd_data;\n\tstruct cxgbi_device *cdev = cconn->chba->cdev;\n\tstruct cxgbi_sock *csk = cconn->cep ? cconn->cep->csk : NULL;\n\tstruct iscsi_tcp_task *tcp_task = task->dd_data;\n\tstruct cxgbi_task_data *tdata = iscsi_task_cxgbi_data(task);\n\tstruct scsi_cmnd *sc = task->sc;\n\tu32 headroom = SKB_TX_ISCSI_PDU_HEADER_MAX;\n\tu32 max_txdata_len = conn->max_xmit_dlength;\n\tu32 iso_tx_rsvd = 0, local_iso_info = 0;\n\tu32 last_tdata_offset, last_tdata_count;\n\tint err = 0;\n\n\tif (!tcp_task) {\n\t\tpr_err(\"task 0x%p, tcp_task 0x%p, tdata 0x%p.\\n\",\n\t\t       task, tcp_task, tdata);\n\t\treturn -ENOMEM;\n\t}\n\tif (!csk) {\n\t\tpr_err(\"task 0x%p, csk gone.\\n\", task);\n\t\treturn -EPIPE;\n\t}\n\n\top &= ISCSI_OPCODE_MASK;\n\n\ttcp_task->dd_data = tdata;\n\ttask->hdr = NULL;\n\n\tlast_tdata_count = tdata->count;\n\tlast_tdata_offset = tdata->offset;\n\n\tif ((op == ISCSI_OP_SCSI_DATA_OUT) ||\n\t    ((op == ISCSI_OP_SCSI_CMD) &&\n\t     (sc->sc_data_direction == DMA_TO_DEVICE))) {\n\t\tu32 remaining_data_tosend, dlimit = 0;\n\t\tu32 max_pdu_size, max_num_pdu, num_pdu;\n\t\tu32 count;\n\n\t\t \n\t\tif (task->state == ISCSI_TASK_PENDING)\n\t\t\ttdata->max_xmit_dlength = conn->max_xmit_dlength;\n\n\t\tif (!tdata->offset)\n\t\t\tcxgbi_task_data_sgl_check(task);\n\n\t\tremaining_data_tosend =\n\t\t\ttdata->dlen - tdata->offset - tdata->count;\n\nrecalculate_sgl:\n\t\tmax_txdata_len = tdata->max_xmit_dlength;\n\t\tlog_debug(1 << CXGBI_DBG_ISCSI | 1 << CXGBI_DBG_PDU_TX,\n\t\t\t  \"tdata->dlen %u, remaining to send %u \"\n\t\t\t  \"conn->max_xmit_dlength %u, \"\n\t\t\t  \"tdata->max_xmit_dlength %u\\n\",\n\t\t\t  tdata->dlen, remaining_data_tosend,\n\t\t\t  conn->max_xmit_dlength, tdata->max_xmit_dlength);\n\n\t\tif (cdev->skb_iso_txhdr && !csk->disable_iso &&\n\t\t    (remaining_data_tosend > tdata->max_xmit_dlength) &&\n\t\t    !(remaining_data_tosend % 4)) {\n\t\t\tu32 max_iso_data;\n\n\t\t\tif ((op == ISCSI_OP_SCSI_CMD) &&\n\t\t\t    session->initial_r2t_en)\n\t\t\t\tgoto no_iso;\n\n\t\t\tmax_pdu_size = tdata->max_xmit_dlength +\n\t\t\t\t       ISCSI_PDU_NONPAYLOAD_LEN;\n\t\t\tmax_iso_data = rounddown(CXGBI_MAX_ISO_DATA_IN_SKB,\n\t\t\t\t\t\t csk->advmss);\n\t\t\tmax_num_pdu = max_iso_data / max_pdu_size;\n\n\t\t\tnum_pdu = (remaining_data_tosend +\n\t\t\t\t   tdata->max_xmit_dlength - 1) /\n\t\t\t\t  tdata->max_xmit_dlength;\n\n\t\t\tif (num_pdu > max_num_pdu)\n\t\t\t\tnum_pdu = max_num_pdu;\n\n\t\t\tconn->max_xmit_dlength = tdata->max_xmit_dlength * num_pdu;\n\t\t\tmax_txdata_len = conn->max_xmit_dlength;\n\t\t\tiso_tx_rsvd = cdev->skb_iso_txhdr;\n\t\t\tlocal_iso_info = sizeof(struct cxgbi_iso_info);\n\n\t\t\tlog_debug(1 << CXGBI_DBG_ISCSI | 1 << CXGBI_DBG_PDU_TX,\n\t\t\t\t  \"max_pdu_size %u, max_num_pdu %u, \"\n\t\t\t\t  \"max_txdata %u, num_pdu %u\\n\",\n\t\t\t\t  max_pdu_size, max_num_pdu,\n\t\t\t\t  max_txdata_len, num_pdu);\n\t\t}\nno_iso:\n\t\tcount  = min_t(u32, max_txdata_len, remaining_data_tosend);\n\t\terr = cxgbi_task_data_sgl_read(task,\n\t\t\t\t\t       tdata->offset + tdata->count,\n\t\t\t\t\t       count, &dlimit);\n\t\tif (unlikely(err < 0)) {\n\t\t\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t\t\t  \"task 0x%p, tcp_task 0x%p, tdata 0x%p, \"\n\t\t\t\t  \"sgl err %d, count %u, dlimit %u\\n\",\n\t\t\t\t  task, tcp_task, tdata, err, count, dlimit);\n\t\t\tif (dlimit) {\n\t\t\t\tremaining_data_tosend =\n\t\t\t\t\trounddown(dlimit,\n\t\t\t\t\t\t  tdata->max_xmit_dlength);\n\t\t\t\tif (!remaining_data_tosend)\n\t\t\t\t\tremaining_data_tosend = dlimit;\n\n\t\t\t\tdlimit = 0;\n\n\t\t\t\tconn->max_xmit_dlength = remaining_data_tosend;\n\t\t\t\tgoto recalculate_sgl;\n\t\t\t}\n\n\t\t\tpr_err(\"task 0x%p, tcp_task 0x%p, tdata 0x%p, \"\n\t\t\t\t\"sgl err %d\\n\",\n\t\t\t\ttask, tcp_task, tdata, err);\n\t\t\tgoto ret_err;\n\t\t}\n\n\t\tif ((tdata->flags & CXGBI_TASK_SGL_COPY) ||\n\t\t    (tdata->nr_frags > MAX_SKB_FRAGS))\n\t\t\theadroom += conn->max_xmit_dlength;\n\t}\n\n\ttdata->skb = alloc_skb(local_iso_info + cdev->skb_tx_rsvd +\n\t\t\t       iso_tx_rsvd + headroom, GFP_ATOMIC);\n\tif (!tdata->skb) {\n\t\ttdata->count = last_tdata_count;\n\t\ttdata->offset = last_tdata_offset;\n\t\terr = -ENOMEM;\n\t\tgoto ret_err;\n\t}\n\n\tskb_reserve(tdata->skb, local_iso_info + cdev->skb_tx_rsvd +\n\t\t    iso_tx_rsvd);\n\n\tif (task->sc) {\n\t\ttask->hdr = (struct iscsi_hdr *)tdata->skb->data;\n\t} else {\n\t\ttask->hdr = kzalloc(SKB_TX_ISCSI_PDU_HEADER_MAX, GFP_ATOMIC);\n\t\tif (!task->hdr) {\n\t\t\t__kfree_skb(tdata->skb);\n\t\t\ttdata->skb = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\ttask->hdr_max = SKB_TX_ISCSI_PDU_HEADER_MAX;\n\n\tif (iso_tx_rsvd)\n\t\tcxgbi_skcb_set_flag(tdata->skb, SKCBF_TX_ISO);\n\n\t \n\tif (op != ISCSI_OP_SCSI_DATA_OUT)\n\t\ttask_reserve_itt(task, &task->hdr->itt);\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI | 1 << CXGBI_DBG_PDU_TX,\n\t\t  \"task 0x%p, op 0x%x, skb 0x%p,%u+%u/%u, itt 0x%x.\\n\",\n\t\t  task, op, tdata->skb, cdev->skb_tx_rsvd, headroom,\n\t\t  conn->max_xmit_dlength, be32_to_cpu(task->hdr->itt));\n\n\treturn 0;\n\nret_err:\n\tconn->max_xmit_dlength = tdata->max_xmit_dlength;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(cxgbi_conn_alloc_pdu);\n\nstatic int\ncxgbi_prep_iso_info(struct iscsi_task *task, struct sk_buff *skb,\n\t\t    u32 count)\n{\n\tstruct cxgbi_iso_info *iso_info = (struct cxgbi_iso_info *)skb->head;\n\tstruct iscsi_r2t_info *r2t;\n\tstruct cxgbi_task_data *tdata = iscsi_task_cxgbi_data(task);\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct iscsi_session *session = conn->session;\n\tstruct iscsi_tcp_task *tcp_task = task->dd_data;\n\tu32 burst_size = 0, r2t_dlength = 0, dlength;\n\tu32 max_pdu_len = tdata->max_xmit_dlength;\n\tu32 segment_offset = 0;\n\tu32 num_pdu;\n\n\tif (unlikely(!cxgbi_skcb_test_flag(skb, SKCBF_TX_ISO)))\n\t\treturn 0;\n\n\tmemset(iso_info, 0, sizeof(struct cxgbi_iso_info));\n\n\tif (task->hdr->opcode == ISCSI_OP_SCSI_CMD && session->imm_data_en) {\n\t\tiso_info->flags |= CXGBI_ISO_INFO_IMM_ENABLE;\n\t\tburst_size = count;\n\t}\n\n\tdlength = ntoh24(task->hdr->dlength);\n\tdlength = min(dlength, max_pdu_len);\n\thton24(task->hdr->dlength, dlength);\n\n\tnum_pdu = (count + max_pdu_len - 1) / max_pdu_len;\n\n\tif (iscsi_task_has_unsol_data(task))\n\t\tr2t = &task->unsol_r2t;\n\telse\n\t\tr2t = tcp_task->r2t;\n\n\tif (r2t) {\n\t\tlog_debug(1 << CXGBI_DBG_ISCSI | 1 << CXGBI_DBG_PDU_TX,\n\t\t\t  \"count %u, tdata->count %u, num_pdu %u,\"\n\t\t\t  \"task->hdr_len %u, r2t->data_length %u, r2t->sent %u\\n\",\n\t\t\t  count, tdata->count, num_pdu, task->hdr_len,\n\t\t\t  r2t->data_length, r2t->sent);\n\n\t\tr2t_dlength = r2t->data_length - r2t->sent;\n\t\tsegment_offset = r2t->sent;\n\t\tr2t->datasn += num_pdu - 1;\n\t}\n\n\tif (!r2t || !r2t->sent)\n\t\tiso_info->flags |= CXGBI_ISO_INFO_FSLICE;\n\n\tif (task->hdr->flags & ISCSI_FLAG_CMD_FINAL)\n\t\tiso_info->flags |= CXGBI_ISO_INFO_LSLICE;\n\n\ttask->hdr->flags &= ~ISCSI_FLAG_CMD_FINAL;\n\n\tiso_info->op = task->hdr->opcode;\n\tiso_info->ahs = task->hdr->hlength;\n\tiso_info->num_pdu = num_pdu;\n\tiso_info->mpdu = max_pdu_len;\n\tiso_info->burst_size = (burst_size + r2t_dlength) >> 2;\n\tiso_info->len = count + task->hdr_len;\n\tiso_info->segment_offset = segment_offset;\n\n\tcxgbi_skcb_tx_iscsi_hdrlen(skb) = task->hdr_len;\n\treturn 0;\n}\n\nstatic inline void tx_skb_setmode(struct sk_buff *skb, int hcrc, int dcrc)\n{\n\tif (hcrc || dcrc) {\n\t\tu8 submode = 0;\n\n\t\tif (hcrc)\n\t\t\tsubmode |= 1;\n\t\tif (dcrc)\n\t\t\tsubmode |= 2;\n\t\tcxgbi_skcb_tx_ulp_mode(skb) = (ULP2_MODE_ISCSI << 4) | submode;\n\t} else\n\t\tcxgbi_skcb_tx_ulp_mode(skb) = 0;\n}\n\nstatic struct page *rsvd_page;\n\nint cxgbi_conn_init_pdu(struct iscsi_task *task, unsigned int offset,\n\t\t\t      unsigned int count)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct iscsi_tcp_task *tcp_task = task->dd_data;\n\tstruct cxgbi_task_data *tdata = iscsi_task_cxgbi_data(task);\n\tstruct sk_buff *skb;\n\tstruct scsi_cmnd *sc = task->sc;\n\tu32 expected_count, expected_offset;\n\tu32 datalen = count, dlimit = 0;\n\tu32 i, padlen = iscsi_padding(count);\n\tstruct page *pg;\n\tint err;\n\n\tif (!tcp_task || (tcp_task->dd_data != tdata)) {\n\t\tpr_err(\"task 0x%p,0x%p, tcp_task 0x%p, tdata 0x%p/0x%p.\\n\",\n\t\t       task, task->sc, tcp_task,\n\t\t       tcp_task ? tcp_task->dd_data : NULL, tdata);\n\t\treturn -EINVAL;\n\t}\n\tskb = tdata->skb;\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI | 1 << CXGBI_DBG_PDU_TX,\n\t\t  \"task 0x%p,0x%p, skb 0x%p, 0x%x,0x%x,0x%x, %u+%u.\\n\",\n\t\t  task, task->sc, skb, (*skb->data) & ISCSI_OPCODE_MASK,\n\t\t  be32_to_cpu(task->cmdsn), be32_to_cpu(task->hdr->itt), offset, count);\n\n\tskb_put(skb, task->hdr_len);\n\ttx_skb_setmode(skb, conn->hdrdgst_en, datalen ? conn->datadgst_en : 0);\n\tif (!count) {\n\t\ttdata->count = count;\n\t\ttdata->offset = offset;\n\t\ttdata->nr_frags = 0;\n\t\ttdata->total_offset = 0;\n\t\ttdata->total_count = 0;\n\t\tif (tdata->max_xmit_dlength)\n\t\t\tconn->max_xmit_dlength = tdata->max_xmit_dlength;\n\t\tcxgbi_skcb_clear_flag(skb, SKCBF_TX_ISO);\n\t\treturn 0;\n\t}\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI | 1 << CXGBI_DBG_PDU_TX,\n\t\t  \"data->total_count %u, tdata->total_offset %u\\n\",\n\t\t  tdata->total_count, tdata->total_offset);\n\n\texpected_count = tdata->total_count;\n\texpected_offset = tdata->total_offset;\n\n\tif ((count != expected_count) ||\n\t    (offset != expected_offset)) {\n\t\terr = cxgbi_task_data_sgl_read(task, offset, count, &dlimit);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"task 0x%p,0x%p, tcp_task 0x%p, tdata 0x%p/0x%p \"\n\t\t\t       \"dlimit %u, sgl err %d.\\n\", task, task->sc,\n\t\t\t       tcp_task, tcp_task ? tcp_task->dd_data : NULL,\n\t\t\t       tdata, dlimit, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tconn->max_xmit_dlength = tdata->max_xmit_dlength;\n\n\tif (sc) {\n\t\tstruct page_frag *frag = tdata->frags;\n\n\t\tif ((tdata->flags & CXGBI_TASK_SGL_COPY) ||\n\t\t    (tdata->nr_frags > MAX_SKB_FRAGS) ||\n\t\t    (padlen && (tdata->nr_frags ==\n\t\t\t\t\tMAX_SKB_FRAGS))) {\n\t\t\tchar *dst = skb->data + task->hdr_len;\n\n\t\t\t \n\t\t\tfor (i = 0; i < tdata->nr_frags; i++, frag++) {\n\t\t\t\tchar *src = kmap_atomic(frag->page);\n\n\t\t\t\tmemcpy(dst, src + frag->offset, frag->size);\n\t\t\t\tdst += frag->size;\n\t\t\t\tkunmap_atomic(src);\n\t\t\t}\n\n\t\t\tif (padlen) {\n\t\t\t\tmemset(dst, 0, padlen);\n\t\t\t\tpadlen = 0;\n\t\t\t}\n\t\t\tskb_put(skb, count + padlen);\n\t\t} else {\n\t\t\tfor (i = 0; i < tdata->nr_frags; i++, frag++) {\n\t\t\t\tget_page(frag->page);\n\t\t\t\tskb_fill_page_desc(skb, i, frag->page,\n\t\t\t\t\t\t   frag->offset, frag->size);\n\t\t\t}\n\n\t\t\tskb->len += count;\n\t\t\tskb->data_len += count;\n\t\t\tskb->truesize += count;\n\t\t}\n\t} else {\n\t\tpg = virt_to_head_page(task->data);\n\t\tget_page(pg);\n\t\tskb_fill_page_desc(skb, 0, pg,\n\t\t\t\t   task->data - (char *)page_address(pg),\n\t\t\t\t   count);\n\t\tskb->len += count;\n\t\tskb->data_len += count;\n\t\tskb->truesize += count;\n\t}\n\n\tif (padlen) {\n\t\tget_page(rsvd_page);\n\t\tskb_fill_page_desc(skb, skb_shinfo(skb)->nr_frags,\n\t\t\t\t   rsvd_page, 0, padlen);\n\n\t\tskb->data_len += padlen;\n\t\tskb->truesize += padlen;\n\t\tskb->len += padlen;\n\t}\n\n\tif (likely(count > tdata->max_xmit_dlength))\n\t\tcxgbi_prep_iso_info(task, skb, count);\n\telse\n\t\tcxgbi_skcb_clear_flag(skb, SKCBF_TX_ISO);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cxgbi_conn_init_pdu);\n\nstatic int cxgbi_sock_tx_queue_up(struct cxgbi_sock *csk, struct sk_buff *skb)\n{\n\tstruct cxgbi_device *cdev = csk->cdev;\n\tstruct cxgbi_iso_info *iso_cpl;\n\tu32 frags = skb_shinfo(skb)->nr_frags;\n\tu32 extra_len, num_pdu, hdr_len;\n\tu32 iso_tx_rsvd = 0;\n\n\tif (csk->state != CTP_ESTABLISHED) {\n\t\tlog_debug(1 << CXGBI_DBG_PDU_TX,\n\t\t\t  \"csk 0x%p,%u,0x%lx,%u, EAGAIN.\\n\",\n\t\t\t  csk, csk->state, csk->flags, csk->tid);\n\t\treturn -EPIPE;\n\t}\n\n\tif (csk->err) {\n\t\tlog_debug(1 << CXGBI_DBG_PDU_TX,\n\t\t\t  \"csk 0x%p,%u,0x%lx,%u, EPIPE %d.\\n\",\n\t\t\t  csk, csk->state, csk->flags, csk->tid, csk->err);\n\t\treturn -EPIPE;\n\t}\n\n\tif ((cdev->flags & CXGBI_FLAG_DEV_T3) &&\n\t    before((csk->snd_win + csk->snd_una), csk->write_seq)) {\n\t\tlog_debug(1 << CXGBI_DBG_PDU_TX,\n\t\t\t  \"csk 0x%p,%u,0x%lx,%u, FULL %u-%u >= %u.\\n\",\n\t\t\t  csk, csk->state, csk->flags, csk->tid, csk->write_seq,\n\t\t\t  csk->snd_una, csk->snd_win);\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (cxgbi_skcb_test_flag(skb, SKCBF_TX_ISO))\n\t\tiso_tx_rsvd = cdev->skb_iso_txhdr;\n\n\tif (unlikely(skb_headroom(skb) < (cdev->skb_tx_rsvd + iso_tx_rsvd))) {\n\t\tpr_err(\"csk 0x%p, skb head %u < %u.\\n\",\n\t\t       csk, skb_headroom(skb), cdev->skb_tx_rsvd);\n\t\treturn -EINVAL;\n\t}\n\n\tif (skb->len != skb->data_len)\n\t\tfrags++;\n\n\tif (frags >= SKB_WR_LIST_SIZE) {\n\t\tpr_err(\"csk 0x%p, frags %u, %u,%u >%u.\\n\",\n\t\t       csk, skb_shinfo(skb)->nr_frags, skb->len,\n\t\t       skb->data_len, (unsigned int)SKB_WR_LIST_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tcxgbi_skcb_set_flag(skb, SKCBF_TX_NEED_HDR);\n\tskb_reset_transport_header(skb);\n\tcxgbi_sock_skb_entail(csk, skb);\n\n\textra_len = cxgbi_ulp_extra_len(cxgbi_skcb_tx_ulp_mode(skb));\n\n\tif (likely(cxgbi_skcb_test_flag(skb, SKCBF_TX_ISO))) {\n\t\tiso_cpl = (struct cxgbi_iso_info *)skb->head;\n\t\tnum_pdu = iso_cpl->num_pdu;\n\t\thdr_len = cxgbi_skcb_tx_iscsi_hdrlen(skb);\n\t\textra_len = (cxgbi_ulp_extra_len(cxgbi_skcb_tx_ulp_mode(skb)) *\n\t\t\t     num_pdu) +\t(hdr_len * (num_pdu - 1));\n\t}\n\n\tcsk->write_seq += (skb->len + extra_len);\n\n\treturn 0;\n}\n\nstatic int cxgbi_sock_send_skb(struct cxgbi_sock *csk, struct sk_buff *skb)\n{\n\tstruct cxgbi_device *cdev = csk->cdev;\n\tint len = skb->len;\n\tint err;\n\n\tspin_lock_bh(&csk->lock);\n\terr = cxgbi_sock_tx_queue_up(csk, skb);\n\tif (err < 0) {\n\t\tspin_unlock_bh(&csk->lock);\n\t\treturn err;\n\t}\n\n\tif (likely(skb_queue_len(&csk->write_queue)))\n\t\tcdev->csk_push_tx_frames(csk, 0);\n\tspin_unlock_bh(&csk->lock);\n\treturn len;\n}\n\nint cxgbi_conn_xmit_pdu(struct iscsi_task *task)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = task->conn->dd_data;\n\tstruct cxgbi_conn *cconn = tcp_conn->dd_data;\n\tstruct iscsi_tcp_task *tcp_task = task->dd_data;\n\tstruct cxgbi_task_data *tdata = iscsi_task_cxgbi_data(task);\n\tstruct cxgbi_task_tag_info *ttinfo = &tdata->ttinfo;\n\tstruct sk_buff *skb;\n\tstruct cxgbi_sock *csk = NULL;\n\tu32 pdulen = 0;\n\tu32 datalen;\n\tint err;\n\n\tif (!tcp_task || (tcp_task->dd_data != tdata)) {\n\t\tpr_err(\"task 0x%p,0x%p, tcp_task 0x%p, tdata 0x%p/0x%p.\\n\",\n\t\t       task, task->sc, tcp_task,\n\t\t       tcp_task ? tcp_task->dd_data : NULL, tdata);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = tdata->skb;\n\tif (!skb) {\n\t\tlog_debug(1 << CXGBI_DBG_ISCSI | 1 << CXGBI_DBG_PDU_TX,\n\t\t\t  \"task 0x%p, skb NULL.\\n\", task);\n\t\treturn 0;\n\t}\n\n\tif (cconn && cconn->cep)\n\t\tcsk = cconn->cep->csk;\n\n\tif (!csk) {\n\t\tlog_debug(1 << CXGBI_DBG_ISCSI | 1 << CXGBI_DBG_PDU_TX,\n\t\t\t  \"task 0x%p, csk gone.\\n\", task);\n\t\treturn -EPIPE;\n\t}\n\n\ttdata->skb = NULL;\n\tdatalen = skb->data_len;\n\n\t \n\tif (ttinfo->flags & CXGBI_PPOD_INFO_FLAG_VALID) {\n\t\tstruct cxgbi_ppm *ppm = csk->cdev->cdev2ppm(csk->cdev);\n\n\t\tttinfo->flags &= ~CXGBI_PPOD_INFO_FLAG_VALID;\n\t\tif (csk->cdev->csk_ddp_set_map(ppm, csk, ttinfo) < 0)\n\t\t\tpr_err(\"task 0x%p, ppod writing using ofldq failed.\\n\",\n\t\t\t       task);\n\t\t\t \n\t}\n\n\tif (!task->sc)\n\t\tmemcpy(skb->data, task->hdr, SKB_TX_ISCSI_PDU_HEADER_MAX);\n\n\terr = cxgbi_sock_send_skb(csk, skb);\n\tif (err > 0) {\n\t\tpdulen += err;\n\n\t\tlog_debug(1 << CXGBI_DBG_PDU_TX, \"task 0x%p,0x%p, rv %d.\\n\",\n\t\t\t  task, task->sc, err);\n\n\t\tif (task->conn->hdrdgst_en)\n\t\t\tpdulen += ISCSI_DIGEST_SIZE;\n\n\t\tif (datalen && task->conn->datadgst_en)\n\t\t\tpdulen += ISCSI_DIGEST_SIZE;\n\n\t\ttask->conn->txdata_octets += pdulen;\n\n\t\tif (unlikely(cxgbi_is_iso_config(csk) && cxgbi_is_iso_disabled(csk))) {\n\t\t\tif (time_after(jiffies, csk->prev_iso_ts + HZ)) {\n\t\t\t\tcsk->disable_iso = false;\n\t\t\t\tcsk->prev_iso_ts = 0;\n\t\t\t\tlog_debug(1 << CXGBI_DBG_PDU_TX,\n\t\t\t\t\t  \"enable iso: csk 0x%p\\n\", csk);\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (err == -EAGAIN || err == -ENOBUFS) {\n\t\tlog_debug(1 << CXGBI_DBG_PDU_TX,\n\t\t\t  \"task 0x%p, skb 0x%p, len %u/%u, %d EAGAIN.\\n\",\n\t\t\t  task, skb, skb->len, skb->data_len, err);\n\t\t \n\t\ttdata->skb = skb;\n\n\t\tif (cxgbi_is_iso_config(csk) && !cxgbi_is_iso_disabled(csk) &&\n\t\t    (csk->no_tx_credits++ >= 2)) {\n\t\t\tcsk->disable_iso = true;\n\t\t\tcsk->prev_iso_ts = jiffies;\n\t\t\tlog_debug(1 << CXGBI_DBG_PDU_TX,\n\t\t\t\t  \"disable iso:csk 0x%p, ts:%lu\\n\",\n\t\t\t\t  csk, csk->prev_iso_ts);\n\t\t}\n\n\t\treturn err;\n\t}\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI | 1 << CXGBI_DBG_PDU_TX,\n\t\t  \"itt 0x%x, skb 0x%p, len %u/%u, xmit err %d.\\n\",\n\t\t  task->itt, skb, skb->len, skb->data_len, err);\n\t__kfree_skb(skb);\n\tiscsi_conn_printk(KERN_ERR, task->conn, \"xmit err %d.\\n\", err);\n\tiscsi_conn_failure(task->conn, ISCSI_ERR_XMIT_FAILED);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(cxgbi_conn_xmit_pdu);\n\nvoid cxgbi_cleanup_task(struct iscsi_task *task)\n{\n\tstruct iscsi_tcp_task *tcp_task = task->dd_data;\n\tstruct cxgbi_task_data *tdata = iscsi_task_cxgbi_data(task);\n\n\tif (!tcp_task || (tcp_task->dd_data != tdata)) {\n\t\tpr_info(\"task 0x%p,0x%p, tcp_task 0x%p, tdata 0x%p/0x%p.\\n\",\n\t\t\ttask, task->sc, tcp_task,\n\t\t\ttcp_task ? tcp_task->dd_data : NULL, tdata);\n\t\treturn;\n\t}\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t\"task 0x%p, skb 0x%p, itt 0x%x.\\n\",\n\t\ttask, tdata->skb, task->hdr_itt);\n\n\ttcp_task->dd_data = NULL;\n\n\tif (!task->sc)\n\t\tkfree(task->hdr);\n\ttask->hdr = NULL;\n\n\t \n\tif (tdata->skb) {\n\t\t__kfree_skb(tdata->skb);\n\t\ttdata->skb = NULL;\n\t}\n\n\ttask_release_itt(task, task->hdr_itt);\n\tmemset(tdata, 0, sizeof(*tdata));\n\n\tiscsi_tcp_cleanup_task(task);\n}\nEXPORT_SYMBOL_GPL(cxgbi_cleanup_task);\n\nvoid cxgbi_get_conn_stats(struct iscsi_cls_conn *cls_conn,\n\t\t\t\tstruct iscsi_stats *stats)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\n\tstats->txdata_octets = conn->txdata_octets;\n\tstats->rxdata_octets = conn->rxdata_octets;\n\tstats->scsicmd_pdus = conn->scsicmd_pdus_cnt;\n\tstats->dataout_pdus = conn->dataout_pdus_cnt;\n\tstats->scsirsp_pdus = conn->scsirsp_pdus_cnt;\n\tstats->datain_pdus = conn->datain_pdus_cnt;\n\tstats->r2t_pdus = conn->r2t_pdus_cnt;\n\tstats->tmfcmd_pdus = conn->tmfcmd_pdus_cnt;\n\tstats->tmfrsp_pdus = conn->tmfrsp_pdus_cnt;\n\tstats->digest_err = 0;\n\tstats->timeout_err = 0;\n\tstats->custom_length = 1;\n\tstrcpy(stats->custom[0].desc, \"eh_abort_cnt\");\n\tstats->custom[0].value = conn->eh_abort_cnt;\n}\nEXPORT_SYMBOL_GPL(cxgbi_get_conn_stats);\n\nstatic int cxgbi_conn_max_xmit_dlength(struct iscsi_conn *conn)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct cxgbi_conn *cconn = tcp_conn->dd_data;\n\tstruct cxgbi_device *cdev = cconn->chba->cdev;\n\tunsigned int headroom = SKB_MAX_HEAD(cdev->skb_tx_rsvd);\n\tunsigned int max_def = 512 * MAX_SKB_FRAGS;\n\tunsigned int max = max(max_def, headroom);\n\n\tmax = min(cconn->chba->cdev->tx_max_size, max);\n\tif (conn->max_xmit_dlength)\n\t\tconn->max_xmit_dlength = min(conn->max_xmit_dlength, max);\n\telse\n\t\tconn->max_xmit_dlength = max;\n\tcxgbi_align_pdu_size(conn->max_xmit_dlength);\n\n\treturn 0;\n}\n\nstatic int cxgbi_conn_max_recv_dlength(struct iscsi_conn *conn)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct cxgbi_conn *cconn = tcp_conn->dd_data;\n\tunsigned int max = cconn->chba->cdev->rx_max_size;\n\n\tcxgbi_align_pdu_size(max);\n\n\tif (conn->max_recv_dlength) {\n\t\tif (conn->max_recv_dlength > max) {\n\t\t\tpr_err(\"MaxRecvDataSegmentLength %u > %u.\\n\",\n\t\t\t\tconn->max_recv_dlength, max);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconn->max_recv_dlength = min(conn->max_recv_dlength, max);\n\t\tcxgbi_align_pdu_size(conn->max_recv_dlength);\n\t} else\n\t\tconn->max_recv_dlength = max;\n\n\treturn 0;\n}\n\nint cxgbi_set_conn_param(struct iscsi_cls_conn *cls_conn,\n\t\t\tenum iscsi_param param, char *buf, int buflen)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct cxgbi_conn *cconn = tcp_conn->dd_data;\n\tstruct cxgbi_sock *csk = cconn->cep->csk;\n\tint err;\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t\"cls_conn 0x%p, param %d, buf(%d) %s.\\n\",\n\t\tcls_conn, param, buflen, buf);\n\n\tswitch (param) {\n\tcase ISCSI_PARAM_HDRDGST_EN:\n\t\terr = iscsi_set_param(cls_conn, param, buf, buflen);\n\t\tif (!err && conn->hdrdgst_en)\n\t\t\terr = csk->cdev->csk_ddp_setup_digest(csk, csk->tid,\n\t\t\t\t\t\t\tconn->hdrdgst_en,\n\t\t\t\t\t\t\tconn->datadgst_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DATADGST_EN:\n\t\terr = iscsi_set_param(cls_conn, param, buf, buflen);\n\t\tif (!err && conn->datadgst_en)\n\t\t\terr = csk->cdev->csk_ddp_setup_digest(csk, csk->tid,\n\t\t\t\t\t\t\tconn->hdrdgst_en,\n\t\t\t\t\t\t\tconn->datadgst_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_R2T:\n\t\treturn iscsi_tcp_set_max_r2t(conn, buf);\n\tcase ISCSI_PARAM_MAX_RECV_DLENGTH:\n\t\terr = iscsi_set_param(cls_conn, param, buf, buflen);\n\t\tif (!err)\n\t\t\terr = cxgbi_conn_max_recv_dlength(conn);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_XMIT_DLENGTH:\n\t\terr = iscsi_set_param(cls_conn, param, buf, buflen);\n\t\tif (!err)\n\t\t\terr = cxgbi_conn_max_xmit_dlength(conn);\n\t\tbreak;\n\tdefault:\n\t\treturn iscsi_set_param(cls_conn, param, buf, buflen);\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(cxgbi_set_conn_param);\n\nint cxgbi_get_ep_param(struct iscsi_endpoint *ep, enum iscsi_param param,\n\t\t       char *buf)\n{\n\tstruct cxgbi_endpoint *cep = ep->dd_data;\n\tstruct cxgbi_sock *csk;\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t\"cls_conn 0x%p, param %d.\\n\", ep, param);\n\n\tswitch (param) {\n\tcase ISCSI_PARAM_CONN_PORT:\n\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\tif (!cep)\n\t\t\treturn -ENOTCONN;\n\n\t\tcsk = cep->csk;\n\t\tif (!csk)\n\t\t\treturn -ENOTCONN;\n\n\t\treturn iscsi_conn_get_addr_param((struct sockaddr_storage *)\n\t\t\t\t\t\t &csk->daddr, param, buf);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -ENOSYS;\n}\nEXPORT_SYMBOL_GPL(cxgbi_get_ep_param);\n\nstruct iscsi_cls_conn *\ncxgbi_create_conn(struct iscsi_cls_session *cls_session, u32 cid)\n{\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct iscsi_conn *conn;\n\tstruct iscsi_tcp_conn *tcp_conn;\n\tstruct cxgbi_conn *cconn;\n\n\tcls_conn = iscsi_tcp_conn_setup(cls_session, sizeof(*cconn), cid);\n\tif (!cls_conn)\n\t\treturn NULL;\n\n\tconn = cls_conn->dd_data;\n\ttcp_conn = conn->dd_data;\n\tcconn = tcp_conn->dd_data;\n\tcconn->iconn = conn;\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t\"cid %u(0x%x), cls 0x%p,0x%p, conn 0x%p,0x%p,0x%p.\\n\",\n\t\tcid, cid, cls_session, cls_conn, conn, tcp_conn, cconn);\n\n\treturn cls_conn;\n}\nEXPORT_SYMBOL_GPL(cxgbi_create_conn);\n\nint cxgbi_bind_conn(struct iscsi_cls_session *cls_session,\n\t\t\t\tstruct iscsi_cls_conn *cls_conn,\n\t\t\t\tu64 transport_eph, int is_leading)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct cxgbi_conn *cconn = tcp_conn->dd_data;\n\tstruct cxgbi_ppm *ppm;\n\tstruct iscsi_endpoint *ep;\n\tstruct cxgbi_endpoint *cep;\n\tstruct cxgbi_sock *csk;\n\tint err;\n\n\tep = iscsi_lookup_endpoint(transport_eph);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\t \n\tcep = ep->dd_data;\n\tcsk = cep->csk;\n\n\tppm = csk->cdev->cdev2ppm(csk->cdev);\n\terr = csk->cdev->csk_ddp_setup_pgidx(csk, csk->tid,\n\t\t\t\t\t     ppm->tformat.pgsz_idx_dflt);\n\tif (err < 0)\n\t\tgoto put_ep;\n\n\terr = iscsi_conn_bind(cls_session, cls_conn, is_leading);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto put_ep;\n\t}\n\n\t \n\tcconn->task_idx_bits = (__ilog2_u32(conn->session->cmds_max - 1)) + 1;\n\n\twrite_lock_bh(&csk->callback_lock);\n\tcsk->user_data = conn;\n\tcconn->chba = cep->chba;\n\tcconn->cep = cep;\n\tcep->cconn = cconn;\n\twrite_unlock_bh(&csk->callback_lock);\n\n\tcxgbi_conn_max_xmit_dlength(conn);\n\tcxgbi_conn_max_recv_dlength(conn);\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t\"cls 0x%p,0x%p, ep 0x%p, cconn 0x%p, csk 0x%p.\\n\",\n\t\tcls_session, cls_conn, ep, cconn, csk);\n\t \n\tiscsi_tcp_hdr_recv_prep(tcp_conn);\n\nput_ep:\n\tiscsi_put_endpoint(ep);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(cxgbi_bind_conn);\n\nstruct iscsi_cls_session *cxgbi_create_session(struct iscsi_endpoint *ep,\n\t\t\t\t\t\tu16 cmds_max, u16 qdepth,\n\t\t\t\t\t\tu32 initial_cmdsn)\n{\n\tstruct cxgbi_endpoint *cep;\n\tstruct cxgbi_hba *chba;\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_cls_session *cls_session;\n\tstruct iscsi_session *session;\n\n\tif (!ep) {\n\t\tpr_err(\"missing endpoint.\\n\");\n\t\treturn NULL;\n\t}\n\n\tcep = ep->dd_data;\n\tchba = cep->chba;\n\tshost = chba->shost;\n\n\tBUG_ON(chba != iscsi_host_priv(shost));\n\n\tcls_session = iscsi_session_setup(chba->cdev->itp, shost,\n\t\t\t\t\tcmds_max, 0,\n\t\t\t\t\tsizeof(struct iscsi_tcp_task) +\n\t\t\t\t\tsizeof(struct cxgbi_task_data),\n\t\t\t\t\tinitial_cmdsn, ISCSI_MAX_TARGET);\n\tif (!cls_session)\n\t\treturn NULL;\n\n\tsession = cls_session->dd_data;\n\tif (iscsi_tcp_r2tpool_alloc(session))\n\t\tgoto remove_session;\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t\"ep 0x%p, cls sess 0x%p.\\n\", ep, cls_session);\n\treturn cls_session;\n\nremove_session:\n\tiscsi_session_teardown(cls_session);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cxgbi_create_session);\n\nvoid cxgbi_destroy_session(struct iscsi_cls_session *cls_session)\n{\n\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t\"cls sess 0x%p.\\n\", cls_session);\n\n\tiscsi_tcp_r2tpool_free(cls_session->dd_data);\n\tiscsi_session_teardown(cls_session);\n}\nEXPORT_SYMBOL_GPL(cxgbi_destroy_session);\n\nint cxgbi_set_host_param(struct Scsi_Host *shost, enum iscsi_host_param param,\n\t\t\tchar *buf, int buflen)\n{\n\tstruct cxgbi_hba *chba = iscsi_host_priv(shost);\n\n\tif (!chba->ndev) {\n\t\tshost_printk(KERN_ERR, shost, \"Could not get host param. \"\n\t\t\t\t\"netdev for host not set.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t\"shost 0x%p, hba 0x%p,%s, param %d, buf(%d) %s.\\n\",\n\t\tshost, chba, chba->ndev->name, param, buflen, buf);\n\n\tswitch (param) {\n\tcase ISCSI_HOST_PARAM_IPADDRESS:\n\t{\n\t\t__be32 addr = in_aton(buf);\n\t\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t\t\"hba %s, req. ipv4 %pI4.\\n\", chba->ndev->name, &addr);\n\t\tcxgbi_set_iscsi_ipv4(chba, addr);\n\t\treturn 0;\n\t}\n\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\tcase ISCSI_HOST_PARAM_NETDEV_NAME:\n\t\treturn 0;\n\tdefault:\n\t\treturn iscsi_host_set_param(shost, param, buf, buflen);\n\t}\n}\nEXPORT_SYMBOL_GPL(cxgbi_set_host_param);\n\nint cxgbi_get_host_param(struct Scsi_Host *shost, enum iscsi_host_param param,\n\t\t\tchar *buf)\n{\n\tstruct cxgbi_hba *chba = iscsi_host_priv(shost);\n\tint len = 0;\n\n\tif (!chba->ndev) {\n\t\tshost_printk(KERN_ERR, shost, \"Could not get host param. \"\n\t\t\t\t\"netdev for host not set.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t\"shost 0x%p, hba 0x%p,%s, param %d.\\n\",\n\t\tshost, chba, chba->ndev->name, param);\n\n\tswitch (param) {\n\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tlen = sysfs_format_mac(buf, chba->ndev->dev_addr, 6);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_NETDEV_NAME:\n\t\tlen = sprintf(buf, \"%s\\n\", chba->ndev->name);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_IPADDRESS:\n\t{\n\t\tstruct cxgbi_sock *csk = find_sock_on_port(chba->cdev,\n\t\t\t\t\t\t\t   chba->port_id);\n\t\tif (csk) {\n\t\t\tlen = sprintf(buf, \"%pIS\",\n\t\t\t\t      (struct sockaddr *)&csk->saddr);\n\t\t}\n\t\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t\t  \"hba %s, addr %s.\\n\", chba->ndev->name, buf);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn iscsi_host_get_param(shost, param, buf);\n\t}\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(cxgbi_get_host_param);\n\nstruct iscsi_endpoint *cxgbi_ep_connect(struct Scsi_Host *shost,\n\t\t\t\t\tstruct sockaddr *dst_addr,\n\t\t\t\t\tint non_blocking)\n{\n\tstruct iscsi_endpoint *ep;\n\tstruct cxgbi_endpoint *cep;\n\tstruct cxgbi_hba *hba = NULL;\n\tstruct cxgbi_sock *csk;\n\tint ifindex = 0;\n\tint err = -EINVAL;\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI | 1 << CXGBI_DBG_SOCK,\n\t\t\"shost 0x%p, non_blocking %d, dst_addr 0x%p.\\n\",\n\t\tshost, non_blocking, dst_addr);\n\n\tif (shost) {\n\t\thba = iscsi_host_priv(shost);\n\t\tif (!hba) {\n\t\t\tpr_info(\"shost 0x%p, priv NULL.\\n\", shost);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\ncheck_route:\n\tif (dst_addr->sa_family == AF_INET) {\n\t\tcsk = cxgbi_check_route(dst_addr, ifindex);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (dst_addr->sa_family == AF_INET6) {\n\t\tcsk = cxgbi_check_route6(dst_addr, ifindex);\n#endif\n\t} else {\n\t\tpr_info(\"address family 0x%x NOT supported.\\n\",\n\t\t\tdst_addr->sa_family);\n\t\terr = -EAFNOSUPPORT;\n\t\treturn (struct iscsi_endpoint *)ERR_PTR(err);\n\t}\n\n\tif (IS_ERR(csk))\n\t\treturn (struct iscsi_endpoint *)csk;\n\tcxgbi_sock_get(csk);\n\n\tif (!hba)\n\t\thba = csk->cdev->hbas[csk->port_id];\n\telse if (hba != csk->cdev->hbas[csk->port_id]) {\n\t\tif (ifindex != hba->ndev->ifindex) {\n\t\t\tcxgbi_sock_put(csk);\n\t\t\tcxgbi_sock_closed(csk);\n\t\t\tifindex = hba->ndev->ifindex;\n\t\t\tgoto check_route;\n\t\t}\n\n\t\tpr_info(\"Could not connect through requested host %u\"\n\t\t\t\"hba 0x%p != 0x%p (%u).\\n\",\n\t\t\tshost->host_no, hba,\n\t\t\tcsk->cdev->hbas[csk->port_id], csk->port_id);\n\t\terr = -ENOSPC;\n\t\tgoto release_conn;\n\t}\n\n\terr = sock_get_port(csk);\n\tif (err)\n\t\tgoto release_conn;\n\n\tcxgbi_sock_set_state(csk, CTP_CONNECTING);\n\terr = csk->cdev->csk_init_act_open(csk);\n\tif (err)\n\t\tgoto release_conn;\n\n\tif (cxgbi_sock_is_closing(csk)) {\n\t\terr = -ENOSPC;\n\t\tpr_info(\"csk 0x%p is closing.\\n\", csk);\n\t\tgoto release_conn;\n\t}\n\n\tep = iscsi_create_endpoint(sizeof(*cep));\n\tif (!ep) {\n\t\terr = -ENOMEM;\n\t\tpr_info(\"iscsi alloc ep, OOM.\\n\");\n\t\tgoto release_conn;\n\t}\n\n\tcep = ep->dd_data;\n\tcep->csk = csk;\n\tcep->chba = hba;\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI | 1 << CXGBI_DBG_SOCK,\n\t\t\"ep 0x%p, cep 0x%p, csk 0x%p, hba 0x%p,%s.\\n\",\n\t\tep, cep, csk, hba, hba->ndev->name);\n\treturn ep;\n\nrelease_conn:\n\tcxgbi_sock_put(csk);\n\tcxgbi_sock_closed(csk);\nerr_out:\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(cxgbi_ep_connect);\n\nint cxgbi_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)\n{\n\tstruct cxgbi_endpoint *cep = ep->dd_data;\n\tstruct cxgbi_sock *csk = cep->csk;\n\n\tif (!cxgbi_sock_is_established(csk))\n\t\treturn 0;\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(cxgbi_ep_poll);\n\nvoid cxgbi_ep_disconnect(struct iscsi_endpoint *ep)\n{\n\tstruct cxgbi_endpoint *cep = ep->dd_data;\n\tstruct cxgbi_conn *cconn = cep->cconn;\n\tstruct cxgbi_sock *csk = cep->csk;\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI | 1 << CXGBI_DBG_SOCK,\n\t\t\"ep 0x%p, cep 0x%p, cconn 0x%p, csk 0x%p,%u,0x%lx.\\n\",\n\t\tep, cep, cconn, csk, csk->state, csk->flags);\n\n\tif (cconn && cconn->iconn) {\n\t\twrite_lock_bh(&csk->callback_lock);\n\t\tcep->csk->user_data = NULL;\n\t\tcconn->cep = NULL;\n\t\twrite_unlock_bh(&csk->callback_lock);\n\t}\n\tiscsi_destroy_endpoint(ep);\n\n\tif (likely(csk->state >= CTP_ESTABLISHED))\n\t\tneed_active_close(csk);\n\telse\n\t\tcxgbi_sock_closed(csk);\n\n\tcxgbi_sock_put(csk);\n}\nEXPORT_SYMBOL_GPL(cxgbi_ep_disconnect);\n\nint cxgbi_iscsi_init(struct iscsi_transport *itp,\n\t\t\tstruct scsi_transport_template **stt)\n{\n\t*stt = iscsi_register_transport(itp);\n\tif (*stt == NULL) {\n\t\tpr_err(\"unable to register %s transport 0x%p.\\n\",\n\t\t\titp->name, itp);\n\t\treturn -ENODEV;\n\t}\n\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t\"%s, registered iscsi transport 0x%p.\\n\",\n\t\titp->name, stt);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cxgbi_iscsi_init);\n\nvoid cxgbi_iscsi_cleanup(struct iscsi_transport *itp,\n\t\t\tstruct scsi_transport_template **stt)\n{\n\tif (*stt) {\n\t\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t\t\"de-register transport 0x%p, %s, stt 0x%p.\\n\",\n\t\t\titp, itp->name, *stt);\n\t\t*stt = NULL;\n\t\tiscsi_unregister_transport(itp);\n\t}\n}\nEXPORT_SYMBOL_GPL(cxgbi_iscsi_cleanup);\n\numode_t cxgbi_attr_is_visible(int param_type, int param)\n{\n\tswitch (param_type) {\n\tcase ISCSI_HOST_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_HOST_PARAM_NETDEV_NAME:\n\t\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tcase ISCSI_HOST_PARAM_IPADDRESS:\n\t\tcase ISCSI_HOST_PARAM_INITIATOR_NAME:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase ISCSI_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_PARAM_MAX_RECV_DLENGTH:\n\t\tcase ISCSI_PARAM_MAX_XMIT_DLENGTH:\n\t\tcase ISCSI_PARAM_HDRDGST_EN:\n\t\tcase ISCSI_PARAM_DATADGST_EN:\n\t\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\tcase ISCSI_PARAM_CONN_PORT:\n\t\tcase ISCSI_PARAM_EXP_STATSN:\n\t\tcase ISCSI_PARAM_PERSISTENT_ADDRESS:\n\t\tcase ISCSI_PARAM_PERSISTENT_PORT:\n\t\tcase ISCSI_PARAM_PING_TMO:\n\t\tcase ISCSI_PARAM_RECV_TMO:\n\t\tcase ISCSI_PARAM_INITIAL_R2T_EN:\n\t\tcase ISCSI_PARAM_MAX_R2T:\n\t\tcase ISCSI_PARAM_IMM_DATA_EN:\n\t\tcase ISCSI_PARAM_FIRST_BURST:\n\t\tcase ISCSI_PARAM_MAX_BURST:\n\t\tcase ISCSI_PARAM_PDU_INORDER_EN:\n\t\tcase ISCSI_PARAM_DATASEQ_INORDER_EN:\n\t\tcase ISCSI_PARAM_ERL:\n\t\tcase ISCSI_PARAM_TARGET_NAME:\n\t\tcase ISCSI_PARAM_TPGT:\n\t\tcase ISCSI_PARAM_USERNAME:\n\t\tcase ISCSI_PARAM_PASSWORD:\n\t\tcase ISCSI_PARAM_USERNAME_IN:\n\t\tcase ISCSI_PARAM_PASSWORD_IN:\n\t\tcase ISCSI_PARAM_FAST_ABORT:\n\t\tcase ISCSI_PARAM_ABORT_TMO:\n\t\tcase ISCSI_PARAM_LU_RESET_TMO:\n\t\tcase ISCSI_PARAM_TGT_RESET_TMO:\n\t\tcase ISCSI_PARAM_IFACE_NAME:\n\t\tcase ISCSI_PARAM_INITIATOR_NAME:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cxgbi_attr_is_visible);\n\nstatic int __init libcxgbi_init_module(void)\n{\n\tpr_info(\"%s\", version);\n\n\tBUILD_BUG_ON(sizeof_field(struct sk_buff, cb) <\n\t\t     sizeof(struct cxgbi_skb_cb));\n\trsvd_page = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!rsvd_page)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __exit libcxgbi_exit_module(void)\n{\n\tcxgbi_device_unregister_all(0xFF);\n\tput_page(rsvd_page);\n\treturn;\n}\n\nmodule_init(libcxgbi_init_module);\nmodule_exit(libcxgbi_exit_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}