{
  "module_name": "cxgb4i.c",
  "hash_id": "7ebaed66c46f89595de69cb966820a50370eff311c8f4f1bac176baff86a5f42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <scsi/scsi_host.h>\n#include <net/tcp.h>\n#include <net/dst.h>\n#include <linux/netdevice.h>\n#include <net/addrconf.h>\n\n#include \"t4_regs.h\"\n#include \"t4_msg.h\"\n#include \"cxgb4.h\"\n#include \"cxgb4_uld.h\"\n#include \"t4fw_api.h\"\n#include \"l2t.h\"\n#include \"cxgb4i.h\"\n#include \"clip_tbl.h\"\n\nstatic unsigned int dbg_level;\n\n#include \"../libcxgbi.h\"\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n#include <net/dcbevent.h>\n#include \"cxgb4_dcb.h\"\n#endif\n\n#define\tDRV_MODULE_NAME\t\t\"cxgb4i\"\n#define DRV_MODULE_DESC\t\t\"Chelsio T4-T6 iSCSI Driver\"\n#define\tDRV_MODULE_VERSION\t\"0.9.5-ko\"\n#define DRV_MODULE_RELDATE\t\"Apr. 2015\"\n\nstatic char version[] =\n\tDRV_MODULE_DESC \" \" DRV_MODULE_NAME\n\t\" v\" DRV_MODULE_VERSION \" (\" DRV_MODULE_RELDATE \")\\n\";\n\nMODULE_AUTHOR(\"Chelsio Communications, Inc.\");\nMODULE_DESCRIPTION(DRV_MODULE_DESC);\nMODULE_VERSION(DRV_MODULE_VERSION);\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(dbg_level, uint, 0644);\nMODULE_PARM_DESC(dbg_level, \"Debug flag (default=0)\");\n\n#define CXGB4I_DEFAULT_10G_RCV_WIN (256 * 1024)\nstatic int cxgb4i_rcv_win = -1;\nmodule_param(cxgb4i_rcv_win, int, 0644);\nMODULE_PARM_DESC(cxgb4i_rcv_win, \"TCP receive window in bytes\");\n\n#define CXGB4I_DEFAULT_10G_SND_WIN (128 * 1024)\nstatic int cxgb4i_snd_win = -1;\nmodule_param(cxgb4i_snd_win, int, 0644);\nMODULE_PARM_DESC(cxgb4i_snd_win, \"TCP send window in bytes\");\n\nstatic int cxgb4i_rx_credit_thres = 10 * 1024;\nmodule_param(cxgb4i_rx_credit_thres, int, 0644);\nMODULE_PARM_DESC(cxgb4i_rx_credit_thres,\n\t\t\"RX credits return threshold in bytes (default=10KB)\");\n\nstatic unsigned int cxgb4i_max_connect = (8 * 1024);\nmodule_param(cxgb4i_max_connect, uint, 0644);\nMODULE_PARM_DESC(cxgb4i_max_connect, \"Maximum number of connections\");\n\nstatic unsigned short cxgb4i_sport_base = 20000;\nmodule_param(cxgb4i_sport_base, ushort, 0644);\nMODULE_PARM_DESC(cxgb4i_sport_base, \"Starting port number (default 20000)\");\n\ntypedef void (*cxgb4i_cplhandler_func)(struct cxgbi_device *, struct sk_buff *);\n\nstatic void *t4_uld_add(const struct cxgb4_lld_info *);\nstatic int t4_uld_rx_handler(void *, const __be64 *, const struct pkt_gl *);\nstatic int t4_uld_state_change(void *, enum cxgb4_state state);\nstatic inline int send_tx_flowc_wr(struct cxgbi_sock *);\n\nstatic const struct cxgb4_uld_info cxgb4i_uld_info = {\n\t.name = DRV_MODULE_NAME,\n\t.nrxq = MAX_ULD_QSETS,\n\t.ntxq = MAX_ULD_QSETS,\n\t.rxq_size = 1024,\n\t.lro = false,\n\t.add = t4_uld_add,\n\t.rx_handler = t4_uld_rx_handler,\n\t.state_change = t4_uld_state_change,\n};\n\nstatic struct scsi_host_template cxgb4i_host_template = {\n\t.module\t\t= THIS_MODULE,\n\t.name\t\t= DRV_MODULE_NAME,\n\t.proc_name\t= DRV_MODULE_NAME,\n\t.can_queue\t= CXGB4I_SCSI_HOST_QDEPTH,\n\t.queuecommand\t= iscsi_queuecommand,\n\t.change_queue_depth = scsi_change_queue_depth,\n\t.sg_tablesize\t= SG_ALL,\n\t.max_sectors\t= 0xFFFF,\n\t.cmd_per_lun\t= ISCSI_DEF_CMD_PER_LUN,\n\t.eh_timed_out\t= iscsi_eh_cmd_timed_out,\n\t.eh_abort_handler = iscsi_eh_abort,\n\t.eh_device_reset_handler = iscsi_eh_device_reset,\n\t.eh_target_reset_handler = iscsi_eh_recover_target,\n\t.target_alloc\t= iscsi_target_alloc,\n\t.dma_boundary\t= PAGE_SIZE - 1,\n\t.this_id\t= -1,\n\t.track_queue_depth = 1,\n\t.cmd_size\t= sizeof(struct iscsi_cmd),\n};\n\nstatic struct iscsi_transport cxgb4i_iscsi_transport = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= DRV_MODULE_NAME,\n\t.caps\t\t= CAP_RECOVERY_L0 | CAP_MULTI_R2T | CAP_HDRDGST |\n\t\t\t\tCAP_DATADGST | CAP_DIGEST_OFFLOAD |\n\t\t\t\tCAP_PADDING_OFFLOAD | CAP_TEXT_NEGO,\n\t.attr_is_visible\t= cxgbi_attr_is_visible,\n\t.get_host_param\t= cxgbi_get_host_param,\n\t.set_host_param\t= cxgbi_set_host_param,\n\t \n\t.create_session\t= cxgbi_create_session,\n\t.destroy_session\t= cxgbi_destroy_session,\n\t.get_session_param = iscsi_session_get_param,\n\t \n\t.create_conn\t= cxgbi_create_conn,\n\t.bind_conn\t\t= cxgbi_bind_conn,\n\t.unbind_conn\t= iscsi_conn_unbind,\n\t.destroy_conn\t= iscsi_tcp_conn_teardown,\n\t.start_conn\t\t= iscsi_conn_start,\n\t.stop_conn\t\t= iscsi_conn_stop,\n\t.get_conn_param\t= iscsi_conn_get_param,\n\t.set_param\t= cxgbi_set_conn_param,\n\t.get_stats\t= cxgbi_get_conn_stats,\n\t \n\t.send_pdu\t= iscsi_conn_send_pdu,\n\t \n\t.init_task\t= iscsi_tcp_task_init,\n\t.xmit_task\t= iscsi_tcp_task_xmit,\n\t.cleanup_task\t= cxgbi_cleanup_task,\n\t \n\t.alloc_pdu\t= cxgbi_conn_alloc_pdu,\n\t.init_pdu\t= cxgbi_conn_init_pdu,\n\t.xmit_pdu\t= cxgbi_conn_xmit_pdu,\n\t.parse_pdu_itt\t= cxgbi_parse_pdu_itt,\n\t \n\t.get_ep_param\t= cxgbi_get_ep_param,\n\t.ep_connect\t= cxgbi_ep_connect,\n\t.ep_poll\t= cxgbi_ep_poll,\n\t.ep_disconnect\t= cxgbi_ep_disconnect,\n\t \n\t.session_recovery_timedout = iscsi_session_recovery_timedout,\n};\n\n#ifdef CONFIG_CHELSIO_T4_DCB\nstatic int\ncxgb4_dcb_change_notify(struct notifier_block *, unsigned long, void *);\n\nstatic struct notifier_block cxgb4_dcb_change = {\n\t.notifier_call = cxgb4_dcb_change_notify,\n};\n#endif\n\nstatic struct scsi_transport_template *cxgb4i_stt;\n\n \n\n#define RCV_BUFSIZ_MASK\t\t0x3FFU\n#define MAX_IMM_TX_PKT_LEN\t256\n\nstatic int push_tx_frames(struct cxgbi_sock *, int);\n\n \nstatic inline bool is_ofld_imm(const struct sk_buff *skb)\n{\n\tint len = skb->len;\n\n\tif (likely(cxgbi_skcb_test_flag(skb, SKCBF_TX_NEED_HDR)))\n\t\tlen += sizeof(struct fw_ofld_tx_data_wr);\n\n\tif  (likely(cxgbi_skcb_test_flag((struct sk_buff *)skb, SKCBF_TX_ISO)))\n\t\tlen += sizeof(struct cpl_tx_data_iso);\n\n\treturn (len <= MAX_IMM_OFLD_TX_DATA_WR_LEN);\n}\n\nstatic void send_act_open_req(struct cxgbi_sock *csk, struct sk_buff *skb,\n\t\t\t\tstruct l2t_entry *e)\n{\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(csk->cdev);\n\tint wscale = cxgbi_sock_compute_wscale(csk->mss_idx);\n\tunsigned long long opt0;\n\tunsigned int opt2;\n\tunsigned int qid_atid = ((unsigned int)csk->atid) |\n\t\t\t\t (((unsigned int)csk->rss_qid) << 14);\n\n\topt0 = KEEP_ALIVE_F |\n\t\tWND_SCALE_V(wscale) |\n\t\tMSS_IDX_V(csk->mss_idx) |\n\t\tL2T_IDX_V(((struct l2t_entry *)csk->l2t)->idx) |\n\t\tTX_CHAN_V(csk->tx_chan) |\n\t\tSMAC_SEL_V(csk->smac_idx) |\n\t\tULP_MODE_V(ULP_MODE_ISCSI) |\n\t\tRCV_BUFSIZ_V(csk->rcv_win >> 10);\n\n\topt2 = RX_CHANNEL_V(0) |\n\t\tRSS_QUEUE_VALID_F |\n\t\tRSS_QUEUE_V(csk->rss_qid);\n\n\tif (is_t4(lldi->adapter_type)) {\n\t\tstruct cpl_act_open_req *req =\n\t\t\t\t(struct cpl_act_open_req *)skb->head;\n\n\t\tINIT_TP_WR(req, 0);\n\t\tOPCODE_TID(req) = cpu_to_be32(MK_OPCODE_TID(CPL_ACT_OPEN_REQ,\n\t\t\t\t\tqid_atid));\n\t\treq->local_port = csk->saddr.sin_port;\n\t\treq->peer_port = csk->daddr.sin_port;\n\t\treq->local_ip = csk->saddr.sin_addr.s_addr;\n\t\treq->peer_ip = csk->daddr.sin_addr.s_addr;\n\t\treq->opt0 = cpu_to_be64(opt0);\n\t\treq->params = cpu_to_be32(cxgb4_select_ntuple(\n\t\t\t\t\tcsk->cdev->ports[csk->port_id],\n\t\t\t\t\tcsk->l2t));\n\t\topt2 |= RX_FC_VALID_F;\n\t\treq->opt2 = cpu_to_be32(opt2);\n\n\t\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\t\"csk t4 0x%p, %pI4:%u-%pI4:%u, atid %d, qid %u.\\n\",\n\t\t\tcsk, &req->local_ip, ntohs(req->local_port),\n\t\t\t&req->peer_ip, ntohs(req->peer_port),\n\t\t\tcsk->atid, csk->rss_qid);\n\t} else if (is_t5(lldi->adapter_type)) {\n\t\tstruct cpl_t5_act_open_req *req =\n\t\t\t\t(struct cpl_t5_act_open_req *)skb->head;\n\t\tu32 isn = (get_random_u32() & ~7UL) - 1;\n\n\t\tINIT_TP_WR(req, 0);\n\t\tOPCODE_TID(req) = cpu_to_be32(MK_OPCODE_TID(CPL_ACT_OPEN_REQ,\n\t\t\t\t\tqid_atid));\n\t\treq->local_port = csk->saddr.sin_port;\n\t\treq->peer_port = csk->daddr.sin_port;\n\t\treq->local_ip = csk->saddr.sin_addr.s_addr;\n\t\treq->peer_ip = csk->daddr.sin_addr.s_addr;\n\t\treq->opt0 = cpu_to_be64(opt0);\n\t\treq->params = cpu_to_be64(FILTER_TUPLE_V(\n\t\t\t\tcxgb4_select_ntuple(\n\t\t\t\t\tcsk->cdev->ports[csk->port_id],\n\t\t\t\t\tcsk->l2t)));\n\t\treq->rsvd = cpu_to_be32(isn);\n\t\topt2 |= T5_ISS_VALID;\n\t\topt2 |= T5_OPT_2_VALID_F;\n\n\t\treq->opt2 = cpu_to_be32(opt2);\n\n\t\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\t\"csk t5 0x%p, %pI4:%u-%pI4:%u, atid %d, qid %u.\\n\",\n\t\t\tcsk, &req->local_ip, ntohs(req->local_port),\n\t\t\t&req->peer_ip, ntohs(req->peer_port),\n\t\t\tcsk->atid, csk->rss_qid);\n\t} else {\n\t\tstruct cpl_t6_act_open_req *req =\n\t\t\t\t(struct cpl_t6_act_open_req *)skb->head;\n\t\tu32 isn = (get_random_u32() & ~7UL) - 1;\n\n\t\tINIT_TP_WR(req, 0);\n\t\tOPCODE_TID(req) = cpu_to_be32(MK_OPCODE_TID(CPL_ACT_OPEN_REQ,\n\t\t\t\t\t\t\t    qid_atid));\n\t\treq->local_port = csk->saddr.sin_port;\n\t\treq->peer_port = csk->daddr.sin_port;\n\t\treq->local_ip = csk->saddr.sin_addr.s_addr;\n\t\treq->peer_ip = csk->daddr.sin_addr.s_addr;\n\t\treq->opt0 = cpu_to_be64(opt0);\n\t\treq->params = cpu_to_be64(FILTER_TUPLE_V(\n\t\t\t\tcxgb4_select_ntuple(\n\t\t\t\t\tcsk->cdev->ports[csk->port_id],\n\t\t\t\t\tcsk->l2t)));\n\t\treq->rsvd = cpu_to_be32(isn);\n\n\t\topt2 |= T5_ISS_VALID;\n\t\topt2 |= RX_FC_DISABLE_F;\n\t\topt2 |= T5_OPT_2_VALID_F;\n\n\t\treq->opt2 = cpu_to_be32(opt2);\n\t\treq->rsvd2 = cpu_to_be32(0);\n\t\treq->opt3 = cpu_to_be32(0);\n\n\t\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\t  \"csk t6 0x%p, %pI4:%u-%pI4:%u, atid %d, qid %u.\\n\",\n\t\t\t  csk, &req->local_ip, ntohs(req->local_port),\n\t\t\t  &req->peer_ip, ntohs(req->peer_port),\n\t\t\t  csk->atid, csk->rss_qid);\n\t}\n\n\tset_wr_txq(skb, CPL_PRIORITY_SETUP, csk->port_id);\n\n\tpr_info_ipaddr(\"t%d csk 0x%p,%u,0x%lx,%u, rss_qid %u.\\n\",\n\t\t       (&csk->saddr), (&csk->daddr),\n\t\t       CHELSIO_CHIP_VERSION(lldi->adapter_type), csk,\n\t\t       csk->state, csk->flags, csk->atid, csk->rss_qid);\n\n\tcxgb4_l2t_send(csk->cdev->ports[csk->port_id], skb, csk->l2t);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void send_act_open_req6(struct cxgbi_sock *csk, struct sk_buff *skb,\n\t\t\t       struct l2t_entry *e)\n{\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(csk->cdev);\n\tint wscale = cxgbi_sock_compute_wscale(csk->mss_idx);\n\tunsigned long long opt0;\n\tunsigned int opt2;\n\tunsigned int qid_atid = ((unsigned int)csk->atid) |\n\t\t\t\t (((unsigned int)csk->rss_qid) << 14);\n\n\topt0 = KEEP_ALIVE_F |\n\t\tWND_SCALE_V(wscale) |\n\t\tMSS_IDX_V(csk->mss_idx) |\n\t\tL2T_IDX_V(((struct l2t_entry *)csk->l2t)->idx) |\n\t\tTX_CHAN_V(csk->tx_chan) |\n\t\tSMAC_SEL_V(csk->smac_idx) |\n\t\tULP_MODE_V(ULP_MODE_ISCSI) |\n\t\tRCV_BUFSIZ_V(csk->rcv_win >> 10);\n\n\topt2 = RX_CHANNEL_V(0) |\n\t\tRSS_QUEUE_VALID_F |\n\t\tRSS_QUEUE_V(csk->rss_qid);\n\n\tif (is_t4(lldi->adapter_type)) {\n\t\tstruct cpl_act_open_req6 *req =\n\t\t\t    (struct cpl_act_open_req6 *)skb->head;\n\n\t\tINIT_TP_WR(req, 0);\n\t\tOPCODE_TID(req) = cpu_to_be32(MK_OPCODE_TID(CPL_ACT_OPEN_REQ6,\n\t\t\t\t\t\t\t    qid_atid));\n\t\treq->local_port = csk->saddr6.sin6_port;\n\t\treq->peer_port = csk->daddr6.sin6_port;\n\n\t\treq->local_ip_hi = *(__be64 *)(csk->saddr6.sin6_addr.s6_addr);\n\t\treq->local_ip_lo = *(__be64 *)(csk->saddr6.sin6_addr.s6_addr +\n\t\t\t\t\t\t\t\t    8);\n\t\treq->peer_ip_hi = *(__be64 *)(csk->daddr6.sin6_addr.s6_addr);\n\t\treq->peer_ip_lo = *(__be64 *)(csk->daddr6.sin6_addr.s6_addr +\n\t\t\t\t\t\t\t\t    8);\n\n\t\treq->opt0 = cpu_to_be64(opt0);\n\n\t\topt2 |= RX_FC_VALID_F;\n\t\treq->opt2 = cpu_to_be32(opt2);\n\n\t\treq->params = cpu_to_be32(cxgb4_select_ntuple(\n\t\t\t\t\t  csk->cdev->ports[csk->port_id],\n\t\t\t\t\t  csk->l2t));\n\t} else if (is_t5(lldi->adapter_type)) {\n\t\tstruct cpl_t5_act_open_req6 *req =\n\t\t\t\t(struct cpl_t5_act_open_req6 *)skb->head;\n\n\t\tINIT_TP_WR(req, 0);\n\t\tOPCODE_TID(req) = cpu_to_be32(MK_OPCODE_TID(CPL_ACT_OPEN_REQ6,\n\t\t\t\t\t\t\t    qid_atid));\n\t\treq->local_port = csk->saddr6.sin6_port;\n\t\treq->peer_port = csk->daddr6.sin6_port;\n\t\treq->local_ip_hi = *(__be64 *)(csk->saddr6.sin6_addr.s6_addr);\n\t\treq->local_ip_lo = *(__be64 *)(csk->saddr6.sin6_addr.s6_addr +\n\t\t\t\t\t\t\t\t\t8);\n\t\treq->peer_ip_hi = *(__be64 *)(csk->daddr6.sin6_addr.s6_addr);\n\t\treq->peer_ip_lo = *(__be64 *)(csk->daddr6.sin6_addr.s6_addr +\n\t\t\t\t\t\t\t\t\t8);\n\t\treq->opt0 = cpu_to_be64(opt0);\n\n\t\topt2 |= T5_OPT_2_VALID_F;\n\t\treq->opt2 = cpu_to_be32(opt2);\n\n\t\treq->params = cpu_to_be64(FILTER_TUPLE_V(cxgb4_select_ntuple(\n\t\t\t\t\t  csk->cdev->ports[csk->port_id],\n\t\t\t\t\t  csk->l2t)));\n\t} else {\n\t\tstruct cpl_t6_act_open_req6 *req =\n\t\t\t\t(struct cpl_t6_act_open_req6 *)skb->head;\n\n\t\tINIT_TP_WR(req, 0);\n\t\tOPCODE_TID(req) = cpu_to_be32(MK_OPCODE_TID(CPL_ACT_OPEN_REQ6,\n\t\t\t\t\t\t\t    qid_atid));\n\t\treq->local_port = csk->saddr6.sin6_port;\n\t\treq->peer_port = csk->daddr6.sin6_port;\n\t\treq->local_ip_hi = *(__be64 *)(csk->saddr6.sin6_addr.s6_addr);\n\t\treq->local_ip_lo = *(__be64 *)(csk->saddr6.sin6_addr.s6_addr +\n\t\t\t\t\t\t\t\t\t8);\n\t\treq->peer_ip_hi = *(__be64 *)(csk->daddr6.sin6_addr.s6_addr);\n\t\treq->peer_ip_lo = *(__be64 *)(csk->daddr6.sin6_addr.s6_addr +\n\t\t\t\t\t\t\t\t\t8);\n\t\treq->opt0 = cpu_to_be64(opt0);\n\n\t\topt2 |= RX_FC_DISABLE_F;\n\t\topt2 |= T5_OPT_2_VALID_F;\n\n\t\treq->opt2 = cpu_to_be32(opt2);\n\n\t\treq->params = cpu_to_be64(FILTER_TUPLE_V(cxgb4_select_ntuple(\n\t\t\t\t\t  csk->cdev->ports[csk->port_id],\n\t\t\t\t\t  csk->l2t)));\n\n\t\treq->rsvd2 = cpu_to_be32(0);\n\t\treq->opt3 = cpu_to_be32(0);\n\t}\n\n\tset_wr_txq(skb, CPL_PRIORITY_SETUP, csk->port_id);\n\n\tpr_info(\"t%d csk 0x%p,%u,0x%lx,%u, [%pI6]:%u-[%pI6]:%u, rss_qid %u.\\n\",\n\t\tCHELSIO_CHIP_VERSION(lldi->adapter_type), csk, csk->state,\n\t\tcsk->flags, csk->atid,\n\t\t&csk->saddr6.sin6_addr, ntohs(csk->saddr.sin_port),\n\t\t&csk->daddr6.sin6_addr, ntohs(csk->daddr.sin_port),\n\t\tcsk->rss_qid);\n\n\tcxgb4_l2t_send(csk->cdev->ports[csk->port_id], skb, csk->l2t);\n}\n#endif\n\nstatic void send_close_req(struct cxgbi_sock *csk)\n{\n\tstruct sk_buff *skb = csk->cpl_close;\n\tstruct cpl_close_con_req *req = (struct cpl_close_con_req *)skb->head;\n\tunsigned int tid = csk->tid;\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\"csk 0x%p,%u,0x%lx, tid %u.\\n\",\n\t\tcsk, csk->state, csk->flags, csk->tid);\n\tcsk->cpl_close = NULL;\n\tset_wr_txq(skb, CPL_PRIORITY_DATA, csk->port_id);\n\tINIT_TP_WR(req, tid);\n\tOPCODE_TID(req) = cpu_to_be32(MK_OPCODE_TID(CPL_CLOSE_CON_REQ, tid));\n\treq->rsvd = 0;\n\n\tcxgbi_sock_skb_entail(csk, skb);\n\tif (csk->state >= CTP_ESTABLISHED)\n\t\tpush_tx_frames(csk, 1);\n}\n\nstatic void abort_arp_failure(void *handle, struct sk_buff *skb)\n{\n\tstruct cxgbi_sock *csk = (struct cxgbi_sock *)handle;\n\tstruct cpl_abort_req *req;\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\"csk 0x%p,%u,0x%lx, tid %u, abort.\\n\",\n\t\tcsk, csk->state, csk->flags, csk->tid);\n\treq = (struct cpl_abort_req *)skb->data;\n\treq->cmd = CPL_ABORT_NO_RST;\n\tcxgb4_ofld_send(csk->cdev->ports[csk->port_id], skb);\n}\n\nstatic void send_abort_req(struct cxgbi_sock *csk)\n{\n\tstruct cpl_abort_req *req;\n\tstruct sk_buff *skb = csk->cpl_abort_req;\n\n\tif (unlikely(csk->state == CTP_ABORTING) || !skb || !csk->cdev)\n\t\treturn;\n\n\tif (!cxgbi_sock_flag(csk, CTPF_TX_DATA_SENT)) {\n\t\tsend_tx_flowc_wr(csk);\n\t\tcxgbi_sock_set_flag(csk, CTPF_TX_DATA_SENT);\n\t}\n\n\tcxgbi_sock_set_state(csk, CTP_ABORTING);\n\tcxgbi_sock_set_flag(csk, CTPF_ABORT_RPL_PENDING);\n\tcxgbi_sock_purge_write_queue(csk);\n\n\tcsk->cpl_abort_req = NULL;\n\treq = (struct cpl_abort_req *)skb->head;\n\tset_wr_txq(skb, CPL_PRIORITY_DATA, csk->port_id);\n\treq->cmd = CPL_ABORT_SEND_RST;\n\tt4_set_arp_err_handler(skb, csk, abort_arp_failure);\n\tINIT_TP_WR(req, csk->tid);\n\tOPCODE_TID(req) = cpu_to_be32(MK_OPCODE_TID(CPL_ABORT_REQ, csk->tid));\n\treq->rsvd0 = htonl(csk->snd_nxt);\n\treq->rsvd1 = !cxgbi_sock_flag(csk, CTPF_TX_DATA_SENT);\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\"csk 0x%p,%u,0x%lx,%u, snd_nxt %u, 0x%x.\\n\",\n\t\tcsk, csk->state, csk->flags, csk->tid, csk->snd_nxt,\n\t\treq->rsvd1);\n\n\tcxgb4_l2t_send(csk->cdev->ports[csk->port_id], skb, csk->l2t);\n}\n\nstatic void send_abort_rpl(struct cxgbi_sock *csk, int rst_status)\n{\n\tstruct sk_buff *skb = csk->cpl_abort_rpl;\n\tstruct cpl_abort_rpl *rpl = (struct cpl_abort_rpl *)skb->head;\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\"csk 0x%p,%u,0x%lx,%u, status %d.\\n\",\n\t\tcsk, csk->state, csk->flags, csk->tid, rst_status);\n\n\tcsk->cpl_abort_rpl = NULL;\n\tset_wr_txq(skb, CPL_PRIORITY_DATA, csk->port_id);\n\tINIT_TP_WR(rpl, csk->tid);\n\tOPCODE_TID(rpl) = cpu_to_be32(MK_OPCODE_TID(CPL_ABORT_RPL, csk->tid));\n\trpl->cmd = rst_status;\n\tcxgb4_ofld_send(csk->cdev->ports[csk->port_id], skb);\n}\n\n \nstatic u32 send_rx_credits(struct cxgbi_sock *csk, u32 credits)\n{\n\tstruct sk_buff *skb;\n\tstruct cpl_rx_data_ack *req;\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_PDU_RX,\n\t\t\"csk 0x%p,%u,0x%lx,%u, credit %u.\\n\",\n\t\tcsk, csk->state, csk->flags, csk->tid, credits);\n\n\tskb = alloc_wr(sizeof(*req), 0, GFP_ATOMIC);\n\tif (!skb) {\n\t\tpr_info(\"csk 0x%p, credit %u, OOM.\\n\", csk, credits);\n\t\treturn 0;\n\t}\n\treq = (struct cpl_rx_data_ack *)skb->head;\n\n\tset_wr_txq(skb, CPL_PRIORITY_ACK, csk->port_id);\n\tINIT_TP_WR(req, csk->tid);\n\tOPCODE_TID(req) = cpu_to_be32(MK_OPCODE_TID(CPL_RX_DATA_ACK,\n\t\t\t\t      csk->tid));\n\treq->credit_dack = cpu_to_be32(RX_CREDITS_V(credits)\n\t\t\t\t       | RX_FORCE_ACK_F);\n\tcxgb4_ofld_send(csk->cdev->ports[csk->port_id], skb);\n\treturn credits;\n}\n\n \nstatic inline unsigned int sgl_len(unsigned int n)\n{\n\tn--;\n\treturn (3 * n) / 2 + (n & 1) + 2;\n}\n\n \nstatic inline unsigned int calc_tx_flits_ofld(const struct sk_buff *skb)\n{\n\tunsigned int flits, cnt;\n\n\tif (is_ofld_imm(skb))\n\t\treturn DIV_ROUND_UP(skb->len, 8);\n\tflits = skb_transport_offset(skb) / 8;\n\tcnt = skb_shinfo(skb)->nr_frags;\n\tif (skb_tail_pointer(skb) != skb_transport_header(skb))\n\t\tcnt++;\n\treturn flits + sgl_len(cnt);\n}\n\n#define FLOWC_WR_NPARAMS_MIN\t9\nstatic inline int tx_flowc_wr_credits(int *nparamsp, int *flowclenp)\n{\n\tint nparams, flowclen16, flowclen;\n\n\tnparams = FLOWC_WR_NPARAMS_MIN;\n#ifdef CONFIG_CHELSIO_T4_DCB\n\tnparams++;\n#endif\n\tflowclen = offsetof(struct fw_flowc_wr, mnemval[nparams]);\n\tflowclen16 = DIV_ROUND_UP(flowclen, 16);\n\tflowclen = flowclen16 * 16;\n\t \n\tif (nparamsp)\n\t\t*nparamsp = nparams;\n\tif (flowclenp)\n\t\t*flowclenp = flowclen;\n\n\treturn flowclen16;\n}\n\nstatic inline int send_tx_flowc_wr(struct cxgbi_sock *csk)\n{\n\tstruct sk_buff *skb;\n\tstruct fw_flowc_wr *flowc;\n\tint nparams, flowclen16, flowclen;\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n\tu16 vlan = ((struct l2t_entry *)csk->l2t)->vlan;\n#endif\n\tflowclen16 = tx_flowc_wr_credits(&nparams, &flowclen);\n\tskb = alloc_wr(flowclen, 0, GFP_ATOMIC);\n\tflowc = (struct fw_flowc_wr *)skb->head;\n\tflowc->op_to_nparams =\n\t\thtonl(FW_WR_OP_V(FW_FLOWC_WR) | FW_FLOWC_WR_NPARAMS_V(nparams));\n\tflowc->flowid_len16 =\n\t\thtonl(FW_WR_LEN16_V(flowclen16) | FW_WR_FLOWID_V(csk->tid));\n\tflowc->mnemval[0].mnemonic = FW_FLOWC_MNEM_PFNVFN;\n\tflowc->mnemval[0].val = htonl(csk->cdev->pfvf);\n\tflowc->mnemval[1].mnemonic = FW_FLOWC_MNEM_CH;\n\tflowc->mnemval[1].val = htonl(csk->tx_chan);\n\tflowc->mnemval[2].mnemonic = FW_FLOWC_MNEM_PORT;\n\tflowc->mnemval[2].val = htonl(csk->tx_chan);\n\tflowc->mnemval[3].mnemonic = FW_FLOWC_MNEM_IQID;\n\tflowc->mnemval[3].val = htonl(csk->rss_qid);\n\tflowc->mnemval[4].mnemonic = FW_FLOWC_MNEM_SNDNXT;\n\tflowc->mnemval[4].val = htonl(csk->snd_nxt);\n\tflowc->mnemval[5].mnemonic = FW_FLOWC_MNEM_RCVNXT;\n\tflowc->mnemval[5].val = htonl(csk->rcv_nxt);\n\tflowc->mnemval[6].mnemonic = FW_FLOWC_MNEM_SNDBUF;\n\tflowc->mnemval[6].val = htonl(csk->snd_win);\n\tflowc->mnemval[7].mnemonic = FW_FLOWC_MNEM_MSS;\n\tflowc->mnemval[7].val = htonl(csk->advmss);\n\tflowc->mnemval[8].mnemonic = 0;\n\tflowc->mnemval[8].val = 0;\n\tflowc->mnemval[8].mnemonic = FW_FLOWC_MNEM_TXDATAPLEN_MAX;\n\tif (csk->cdev->skb_iso_txhdr)\n\t\tflowc->mnemval[8].val = cpu_to_be32(CXGBI_MAX_ISO_DATA_IN_SKB);\n\telse\n\t\tflowc->mnemval[8].val = cpu_to_be32(16128);\n#ifdef CONFIG_CHELSIO_T4_DCB\n\tflowc->mnemval[9].mnemonic = FW_FLOWC_MNEM_DCBPRIO;\n\tif (vlan == CPL_L2T_VLAN_NONE) {\n\t\tpr_warn_ratelimited(\"csk %u without VLAN Tag on DCB Link\\n\",\n\t\t\t\t    csk->tid);\n\t\tflowc->mnemval[9].val = cpu_to_be32(0);\n\t} else {\n\t\tflowc->mnemval[9].val = cpu_to_be32((vlan & VLAN_PRIO_MASK) >>\n\t\t\t\t\tVLAN_PRIO_SHIFT);\n\t}\n#endif\n\n\tset_wr_txq(skb, CPL_PRIORITY_DATA, csk->port_id);\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\"csk 0x%p, tid 0x%x, %u,%u,%u,%u,%u,%u,%u.\\n\",\n\t\tcsk, csk->tid, 0, csk->tx_chan, csk->rss_qid,\n\t\tcsk->snd_nxt, csk->rcv_nxt, csk->snd_win,\n\t\tcsk->advmss);\n\n\tcxgb4_ofld_send(csk->cdev->ports[csk->port_id], skb);\n\n\treturn flowclen16;\n}\n\nstatic void\ncxgb4i_make_tx_iso_cpl(struct sk_buff *skb, struct cpl_tx_data_iso *cpl)\n{\n\tstruct cxgbi_iso_info *info = (struct cxgbi_iso_info *)skb->head;\n\tu32 imm_en = !!(info->flags & CXGBI_ISO_INFO_IMM_ENABLE);\n\tu32 fslice = !!(info->flags & CXGBI_ISO_INFO_FSLICE);\n\tu32 lslice = !!(info->flags & CXGBI_ISO_INFO_LSLICE);\n\tu32 pdu_type = (info->op == ISCSI_OP_SCSI_CMD) ? 0 : 1;\n\tu32 submode = cxgbi_skcb_tx_ulp_mode(skb) & 0x3;\n\n\tcpl->op_to_scsi = cpu_to_be32(CPL_TX_DATA_ISO_OP_V(CPL_TX_DATA_ISO) |\n\t\t\t\tCPL_TX_DATA_ISO_FIRST_V(fslice) |\n\t\t\t\tCPL_TX_DATA_ISO_LAST_V(lslice) |\n\t\t\t\tCPL_TX_DATA_ISO_CPLHDRLEN_V(0) |\n\t\t\t\tCPL_TX_DATA_ISO_HDRCRC_V(submode & 1) |\n\t\t\t\tCPL_TX_DATA_ISO_PLDCRC_V(((submode >> 1) & 1)) |\n\t\t\t\tCPL_TX_DATA_ISO_IMMEDIATE_V(imm_en) |\n\t\t\t\tCPL_TX_DATA_ISO_SCSI_V(pdu_type));\n\n\tcpl->ahs_len = info->ahs;\n\tcpl->mpdu = cpu_to_be16(DIV_ROUND_UP(info->mpdu, 4));\n\tcpl->burst_size = cpu_to_be32(info->burst_size);\n\tcpl->len = cpu_to_be32(info->len);\n\tcpl->reserved2_seglen_offset =\n\t     cpu_to_be32(CPL_TX_DATA_ISO_SEGLEN_OFFSET_V(info->segment_offset));\n\tcpl->datasn_offset = cpu_to_be32(info->datasn_offset);\n\tcpl->buffer_offset = cpu_to_be32(info->buffer_offset);\n\tcpl->reserved3 = cpu_to_be32(0);\n\tlog_debug(1 << CXGBI_DBG_ISCSI | 1 << CXGBI_DBG_PDU_TX,\n\t\t  \"iso: flags 0x%x, op %u, ahs %u, num_pdu %u, mpdu %u, \"\n\t\t  \"burst_size %u, iso_len %u\\n\",\n\t\t  info->flags, info->op, info->ahs, info->num_pdu,\n\t\t  info->mpdu, info->burst_size << 2, info->len);\n}\n\nstatic void\ncxgb4i_make_tx_data_wr(struct cxgbi_sock *csk, struct sk_buff *skb, int dlen,\n\t\t       int len, u32 credits, int compl)\n{\n\tstruct cxgbi_device *cdev = csk->cdev;\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct fw_ofld_tx_data_wr *req;\n\tstruct cpl_tx_data_iso *cpl;\n\tu32 submode = cxgbi_skcb_tx_ulp_mode(skb) & 0x3;\n\tu32 wr_ulp_mode = 0;\n\tu32 hdr_size = sizeof(*req);\n\tu32 opcode = FW_OFLD_TX_DATA_WR;\n\tu32 immlen = 0;\n\tu32 force = is_t5(lldi->adapter_type) ? TX_FORCE_V(!submode) :\n\t\t\t\t\t\tT6_TX_FORCE_F;\n\n\tif (cxgbi_skcb_test_flag(skb, SKCBF_TX_ISO)) {\n\t\thdr_size += sizeof(struct cpl_tx_data_iso);\n\t\topcode = FW_ISCSI_TX_DATA_WR;\n\t\timmlen += sizeof(struct cpl_tx_data_iso);\n\t\tsubmode |= 8;\n\t}\n\n\tif (is_ofld_imm(skb))\n\t\timmlen += dlen;\n\n\treq = (struct fw_ofld_tx_data_wr *)__skb_push(skb, hdr_size);\n\treq->op_to_immdlen = cpu_to_be32(FW_WR_OP_V(opcode) |\n\t\t\t\t\t FW_WR_COMPL_V(compl) |\n\t\t\t\t\t FW_WR_IMMDLEN_V(immlen));\n\treq->flowid_len16 = cpu_to_be32(FW_WR_FLOWID_V(csk->tid) |\n\t\t\t\t\tFW_WR_LEN16_V(credits));\n\treq->plen = cpu_to_be32(len);\n\tcpl =  (struct cpl_tx_data_iso *)(req + 1);\n\n\tif (likely(cxgbi_skcb_test_flag(skb, SKCBF_TX_ISO)))\n\t\tcxgb4i_make_tx_iso_cpl(skb, cpl);\n\n\tif (submode)\n\t\twr_ulp_mode = FW_OFLD_TX_DATA_WR_ULPMODE_V(ULP2_MODE_ISCSI) |\n\t\t\t      FW_OFLD_TX_DATA_WR_ULPSUBMODE_V(submode);\n\n\treq->tunnel_to_proxy = cpu_to_be32(wr_ulp_mode | force |\n\t\t\t\t\t   FW_OFLD_TX_DATA_WR_SHOVE_V(1U));\n\n\tif (!cxgbi_sock_flag(csk, CTPF_TX_DATA_SENT))\n\t\tcxgbi_sock_set_flag(csk, CTPF_TX_DATA_SENT);\n}\n\nstatic void arp_failure_skb_discard(void *handle, struct sk_buff *skb)\n{\n\tkfree_skb(skb);\n}\n\nstatic int push_tx_frames(struct cxgbi_sock *csk, int req_completion)\n{\n\tint total_size = 0;\n\tstruct sk_buff *skb;\n\n\tif (unlikely(csk->state < CTP_ESTABLISHED ||\n\t\tcsk->state == CTP_CLOSE_WAIT_1 || csk->state >= CTP_ABORTING)) {\n\t\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK |\n\t\t\t  1 << CXGBI_DBG_PDU_TX,\n\t\t\t  \"csk 0x%p,%u,0x%lx,%u, in closing state.\\n\",\n\t\t\t  csk, csk->state, csk->flags, csk->tid);\n\t\treturn 0;\n\t}\n\n\twhile (csk->wr_cred && ((skb = skb_peek(&csk->write_queue)) != NULL)) {\n\t\tstruct cxgbi_iso_info *iso_cpl;\n\t\tu32 dlen = skb->len;\n\t\tu32 len = skb->len;\n\t\tu32 iso_cpl_len = 0;\n\t\tu32 flowclen16 = 0;\n\t\tu32 credits_needed;\n\t\tu32 num_pdu = 1, hdr_len;\n\n\t\tif (cxgbi_skcb_test_flag(skb, SKCBF_TX_ISO))\n\t\t\tiso_cpl_len = sizeof(struct cpl_tx_data_iso);\n\n\t\tif (is_ofld_imm(skb))\n\t\t\tcredits_needed = DIV_ROUND_UP(dlen + iso_cpl_len, 16);\n\t\telse\n\t\t\tcredits_needed =\n\t\t\t\tDIV_ROUND_UP((8 * calc_tx_flits_ofld(skb)) +\n\t\t\t\t\t     iso_cpl_len, 16);\n\n\t\tif (likely(cxgbi_skcb_test_flag(skb, SKCBF_TX_NEED_HDR)))\n\t\t\tcredits_needed +=\n\t\t\t   DIV_ROUND_UP(sizeof(struct fw_ofld_tx_data_wr), 16);\n\n\t\t \n\t\tif (!cxgbi_sock_flag(csk, CTPF_TX_DATA_SENT)) {\n\t\t\tflowclen16 = send_tx_flowc_wr(csk);\n\t\t\tcsk->wr_cred -= flowclen16;\n\t\t\tcsk->wr_una_cred += flowclen16;\n\t\t\tcxgbi_sock_set_flag(csk, CTPF_TX_DATA_SENT);\n\t\t}\n\n\t\tif (csk->wr_cred < credits_needed) {\n\t\t\tlog_debug(1 << CXGBI_DBG_PDU_TX,\n\t\t\t\t  \"csk 0x%p, skb %u/%u, wr %d < %u.\\n\",\n\t\t\t\t  csk, skb->len, skb->data_len,\n\t\t\t\t  credits_needed, csk->wr_cred);\n\n\t\t\tcsk->no_tx_credits++;\n\t\t\tbreak;\n\t\t}\n\n\t\tcsk->no_tx_credits = 0;\n\n\t\t__skb_unlink(skb, &csk->write_queue);\n\t\tset_wr_txq(skb, CPL_PRIORITY_DATA, csk->port_id);\n\t\tskb->csum = (__force __wsum)(credits_needed + flowclen16);\n\t\tcsk->wr_cred -= credits_needed;\n\t\tcsk->wr_una_cred += credits_needed;\n\t\tcxgbi_sock_enqueue_wr(csk, skb);\n\n\t\tlog_debug(1 << CXGBI_DBG_PDU_TX,\n\t\t\t\"csk 0x%p, skb %u/%u, wr %d, left %u, unack %u.\\n\",\n\t\t\tcsk, skb->len, skb->data_len, credits_needed,\n\t\t\tcsk->wr_cred, csk->wr_una_cred);\n\n\t\tif (!req_completion &&\n\t\t    ((csk->wr_una_cred >= (csk->wr_max_cred / 2)) ||\n\t\t     after(csk->write_seq, (csk->snd_una + csk->snd_win / 2))))\n\t\t\treq_completion = 1;\n\n\t\tif (likely(cxgbi_skcb_test_flag(skb, SKCBF_TX_NEED_HDR))) {\n\t\t\tu32 ulp_mode = cxgbi_skcb_tx_ulp_mode(skb);\n\n\t\t\tif (cxgbi_skcb_test_flag(skb, SKCBF_TX_ISO)) {\n\t\t\t\tiso_cpl = (struct cxgbi_iso_info *)skb->head;\n\t\t\t\tnum_pdu = iso_cpl->num_pdu;\n\t\t\t\thdr_len = cxgbi_skcb_tx_iscsi_hdrlen(skb);\n\t\t\t\tlen += (cxgbi_ulp_extra_len(ulp_mode) * num_pdu) +\n\t\t\t\t       (hdr_len * (num_pdu - 1));\n\t\t\t} else {\n\t\t\t\tlen += cxgbi_ulp_extra_len(ulp_mode);\n\t\t\t}\n\n\t\t\tcxgb4i_make_tx_data_wr(csk, skb, dlen, len,\n\t\t\t\t\t       credits_needed, req_completion);\n\t\t\tcsk->snd_nxt += len;\n\t\t\tcxgbi_skcb_clear_flag(skb, SKCBF_TX_NEED_HDR);\n\t\t} else if (cxgbi_skcb_test_flag(skb, SKCBF_TX_FLAG_COMPL) &&\n\t\t\t   (csk->wr_una_cred >= (csk->wr_max_cred / 2))) {\n\t\t\tstruct cpl_close_con_req *req =\n\t\t\t\t(struct cpl_close_con_req *)skb->data;\n\n\t\t\treq->wr.wr_hi |= cpu_to_be32(FW_WR_COMPL_F);\n\t\t}\n\n\t\ttotal_size += skb->truesize;\n\t\tt4_set_arp_err_handler(skb, csk, arp_failure_skb_discard);\n\n\t\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_PDU_TX,\n\t\t\t  \"csk 0x%p,%u,0x%lx,%u, skb 0x%p, %u.\\n\",\n\t\t\t  csk, csk->state, csk->flags, csk->tid, skb, len);\n\t\tcxgb4_l2t_send(csk->cdev->ports[csk->port_id], skb, csk->l2t);\n\t}\n\treturn total_size;\n}\n\nstatic inline void free_atid(struct cxgbi_sock *csk)\n{\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(csk->cdev);\n\n\tif (cxgbi_sock_flag(csk, CTPF_HAS_ATID)) {\n\t\tcxgb4_free_atid(lldi->tids, csk->atid);\n\t\tcxgbi_sock_clear_flag(csk, CTPF_HAS_ATID);\n\t\tcxgbi_sock_put(csk);\n\t}\n}\n\nstatic void do_act_establish(struct cxgbi_device *cdev, struct sk_buff *skb)\n{\n\tstruct cxgbi_sock *csk;\n\tstruct cpl_act_establish *req = (struct cpl_act_establish *)skb->data;\n\tunsigned short tcp_opt = ntohs(req->tcp_opt);\n\tunsigned int tid = GET_TID(req);\n\tunsigned int atid = TID_TID_G(ntohl(req->tos_atid));\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct tid_info *t = lldi->tids;\n\tu32 rcv_isn = be32_to_cpu(req->rcv_isn);\n\n\tcsk = lookup_atid(t, atid);\n\tif (unlikely(!csk)) {\n\t\tpr_err(\"NO conn. for atid %u, cdev 0x%p.\\n\", atid, cdev);\n\t\tgoto rel_skb;\n\t}\n\n\tif (csk->atid != atid) {\n\t\tpr_err(\"bad conn atid %u, csk 0x%p,%u,0x%lx,tid %u, atid %u.\\n\",\n\t\t\tatid, csk, csk->state, csk->flags, csk->tid, csk->atid);\n\t\tgoto rel_skb;\n\t}\n\n\tpr_info_ipaddr(\"atid 0x%x, tid 0x%x, csk 0x%p,%u,0x%lx, isn %u.\\n\",\n\t\t       (&csk->saddr), (&csk->daddr),\n\t\t       atid, tid, csk, csk->state, csk->flags, rcv_isn);\n\n\tmodule_put(cdev->owner);\n\n\tcxgbi_sock_get(csk);\n\tcsk->tid = tid;\n\tcxgb4_insert_tid(lldi->tids, csk, tid, csk->csk_family);\n\tcxgbi_sock_set_flag(csk, CTPF_HAS_TID);\n\n\tfree_atid(csk);\n\n\tspin_lock_bh(&csk->lock);\n\tif (unlikely(csk->state != CTP_ACTIVE_OPEN))\n\t\tpr_info(\"csk 0x%p,%u,0x%lx,%u, got EST.\\n\",\n\t\t\tcsk, csk->state, csk->flags, csk->tid);\n\n\tif (csk->retry_timer.function) {\n\t\tdel_timer(&csk->retry_timer);\n\t\tcsk->retry_timer.function = NULL;\n\t}\n\n\tcsk->copied_seq = csk->rcv_wup = csk->rcv_nxt = rcv_isn;\n\t \n\tif (csk->rcv_win > (RCV_BUFSIZ_MASK << 10))\n\t\tcsk->rcv_wup -= csk->rcv_win - (RCV_BUFSIZ_MASK << 10);\n\n\tcsk->advmss = lldi->mtus[TCPOPT_MSS_G(tcp_opt)] - 40;\n\tif (TCPOPT_TSTAMP_G(tcp_opt))\n\t\tcsk->advmss -= 12;\n\tif (csk->advmss < 128)\n\t\tcsk->advmss = 128;\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\"csk 0x%p, mss_idx %u, advmss %u.\\n\",\n\t\t\tcsk, TCPOPT_MSS_G(tcp_opt), csk->advmss);\n\n\tcxgbi_sock_established(csk, ntohl(req->snd_isn), ntohs(req->tcp_opt));\n\n\tif (unlikely(cxgbi_sock_flag(csk, CTPF_ACTIVE_CLOSE_NEEDED)))\n\t\tsend_abort_req(csk);\n\telse {\n\t\tif (skb_queue_len(&csk->write_queue))\n\t\t\tpush_tx_frames(csk, 0);\n\t\tcxgbi_conn_tx_open(csk);\n\t}\n\tspin_unlock_bh(&csk->lock);\n\nrel_skb:\n\t__kfree_skb(skb);\n}\n\nstatic int act_open_rpl_status_to_errno(int status)\n{\n\tswitch (status) {\n\tcase CPL_ERR_CONN_RESET:\n\t\treturn -ECONNREFUSED;\n\tcase CPL_ERR_ARP_MISS:\n\t\treturn -EHOSTUNREACH;\n\tcase CPL_ERR_CONN_TIMEDOUT:\n\t\treturn -ETIMEDOUT;\n\tcase CPL_ERR_TCAM_FULL:\n\t\treturn -ENOMEM;\n\tcase CPL_ERR_CONN_EXIST:\n\t\treturn -EADDRINUSE;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic void csk_act_open_retry_timer(struct timer_list *t)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct cxgbi_sock *csk = from_timer(csk, t, retry_timer);\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(csk->cdev);\n\tvoid (*send_act_open_func)(struct cxgbi_sock *, struct sk_buff *,\n\t\t\t\t   struct l2t_entry *);\n\tint t4 = is_t4(lldi->adapter_type), size, size6;\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\"csk 0x%p,%u,0x%lx,%u.\\n\",\n\t\tcsk, csk->state, csk->flags, csk->tid);\n\n\tcxgbi_sock_get(csk);\n\tspin_lock_bh(&csk->lock);\n\n\tif (t4) {\n\t\tsize = sizeof(struct cpl_act_open_req);\n\t\tsize6 = sizeof(struct cpl_act_open_req6);\n\t} else {\n\t\tsize = sizeof(struct cpl_t5_act_open_req);\n\t\tsize6 = sizeof(struct cpl_t5_act_open_req6);\n\t}\n\n\tif (csk->csk_family == AF_INET) {\n\t\tsend_act_open_func = send_act_open_req;\n\t\tskb = alloc_wr(size, 0, GFP_ATOMIC);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else {\n\t\tsend_act_open_func = send_act_open_req6;\n\t\tskb = alloc_wr(size6, 0, GFP_ATOMIC);\n#endif\n\t}\n\n\tif (!skb)\n\t\tcxgbi_sock_fail_act_open(csk, -ENOMEM);\n\telse {\n\t\tskb->sk = (struct sock *)csk;\n\t\tt4_set_arp_err_handler(skb, csk,\n\t\t\t\t       cxgbi_sock_act_open_req_arp_failure);\n\t\tsend_act_open_func(csk, skb, csk->l2t);\n\t}\n\n\tspin_unlock_bh(&csk->lock);\n\tcxgbi_sock_put(csk);\n\n}\n\nstatic inline bool is_neg_adv(unsigned int status)\n{\n\treturn status == CPL_ERR_RTX_NEG_ADVICE ||\n\t\tstatus == CPL_ERR_KEEPALV_NEG_ADVICE ||\n\t\tstatus == CPL_ERR_PERSIST_NEG_ADVICE;\n}\n\nstatic void do_act_open_rpl(struct cxgbi_device *cdev, struct sk_buff *skb)\n{\n\tstruct cxgbi_sock *csk;\n\tstruct cpl_act_open_rpl *rpl = (struct cpl_act_open_rpl *)skb->data;\n\tunsigned int tid = GET_TID(rpl);\n\tunsigned int atid =\n\t\tTID_TID_G(AOPEN_ATID_G(be32_to_cpu(rpl->atid_status)));\n\tunsigned int status = AOPEN_STATUS_G(be32_to_cpu(rpl->atid_status));\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct tid_info *t = lldi->tids;\n\n\tcsk = lookup_atid(t, atid);\n\tif (unlikely(!csk)) {\n\t\tpr_err(\"NO matching conn. atid %u, tid %u.\\n\", atid, tid);\n\t\tgoto rel_skb;\n\t}\n\n\tpr_info_ipaddr(\"tid %u/%u, status %u.\\n\"\n\t\t       \"csk 0x%p,%u,0x%lx. \", (&csk->saddr), (&csk->daddr),\n\t\t       atid, tid, status, csk, csk->state, csk->flags);\n\n\tif (is_neg_adv(status))\n\t\tgoto rel_skb;\n\n\tmodule_put(cdev->owner);\n\n\tif (status && status != CPL_ERR_TCAM_FULL &&\n\t    status != CPL_ERR_CONN_EXIST &&\n\t    status != CPL_ERR_ARP_MISS)\n\t\tcxgb4_remove_tid(lldi->tids, csk->port_id, GET_TID(rpl),\n\t\t\t\t csk->csk_family);\n\n\tcxgbi_sock_get(csk);\n\tspin_lock_bh(&csk->lock);\n\n\tif (status == CPL_ERR_CONN_EXIST &&\n\t    csk->retry_timer.function != csk_act_open_retry_timer) {\n\t\tcsk->retry_timer.function = csk_act_open_retry_timer;\n\t\tmod_timer(&csk->retry_timer, jiffies + HZ / 2);\n\t} else\n\t\tcxgbi_sock_fail_act_open(csk,\n\t\t\t\t\tact_open_rpl_status_to_errno(status));\n\n\tspin_unlock_bh(&csk->lock);\n\tcxgbi_sock_put(csk);\nrel_skb:\n\t__kfree_skb(skb);\n}\n\nstatic void do_peer_close(struct cxgbi_device *cdev, struct sk_buff *skb)\n{\n\tstruct cxgbi_sock *csk;\n\tstruct cpl_peer_close *req = (struct cpl_peer_close *)skb->data;\n\tunsigned int tid = GET_TID(req);\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct tid_info *t = lldi->tids;\n\n\tcsk = lookup_tid(t, tid);\n\tif (unlikely(!csk)) {\n\t\tpr_err(\"can't find connection for tid %u.\\n\", tid);\n\t\tgoto rel_skb;\n\t}\n\tpr_info_ipaddr(\"csk 0x%p,%u,0x%lx,%u.\\n\",\n\t\t       (&csk->saddr), (&csk->daddr),\n\t\t       csk, csk->state, csk->flags, csk->tid);\n\tcxgbi_sock_rcv_peer_close(csk);\nrel_skb:\n\t__kfree_skb(skb);\n}\n\nstatic void do_close_con_rpl(struct cxgbi_device *cdev, struct sk_buff *skb)\n{\n\tstruct cxgbi_sock *csk;\n\tstruct cpl_close_con_rpl *rpl = (struct cpl_close_con_rpl *)skb->data;\n\tunsigned int tid = GET_TID(rpl);\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct tid_info *t = lldi->tids;\n\n\tcsk = lookup_tid(t, tid);\n\tif (unlikely(!csk)) {\n\t\tpr_err(\"can't find connection for tid %u.\\n\", tid);\n\t\tgoto rel_skb;\n\t}\n\tpr_info_ipaddr(\"csk 0x%p,%u,0x%lx,%u.\\n\",\n\t\t       (&csk->saddr), (&csk->daddr),\n\t\t       csk, csk->state, csk->flags, csk->tid);\n\tcxgbi_sock_rcv_close_conn_rpl(csk, ntohl(rpl->snd_nxt));\nrel_skb:\n\t__kfree_skb(skb);\n}\n\nstatic int abort_status_to_errno(struct cxgbi_sock *csk, int abort_reason,\n\t\t\t\t\t\t\t\tint *need_rst)\n{\n\tswitch (abort_reason) {\n\tcase CPL_ERR_BAD_SYN:\n\tcase CPL_ERR_CONN_RESET:\n\t\treturn csk->state > CTP_ESTABLISHED ?\n\t\t\t-EPIPE : -ECONNRESET;\n\tcase CPL_ERR_XMIT_TIMEDOUT:\n\tcase CPL_ERR_PERSIST_TIMEDOUT:\n\tcase CPL_ERR_FINWAIT2_TIMEDOUT:\n\tcase CPL_ERR_KEEPALIVE_TIMEDOUT:\n\t\treturn -ETIMEDOUT;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic void do_abort_req_rss(struct cxgbi_device *cdev, struct sk_buff *skb)\n{\n\tstruct cxgbi_sock *csk;\n\tstruct cpl_abort_req_rss *req = (struct cpl_abort_req_rss *)skb->data;\n\tunsigned int tid = GET_TID(req);\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct tid_info *t = lldi->tids;\n\tint rst_status = CPL_ABORT_NO_RST;\n\n\tcsk = lookup_tid(t, tid);\n\tif (unlikely(!csk)) {\n\t\tpr_err(\"can't find connection for tid %u.\\n\", tid);\n\t\tgoto rel_skb;\n\t}\n\n\tpr_info_ipaddr(\"csk 0x%p,%u,0x%lx,%u, status %u.\\n\",\n\t\t       (&csk->saddr), (&csk->daddr),\n\t\t       csk, csk->state, csk->flags, csk->tid, req->status);\n\n\tif (is_neg_adv(req->status))\n\t\tgoto rel_skb;\n\n\tcxgbi_sock_get(csk);\n\tspin_lock_bh(&csk->lock);\n\n\tcxgbi_sock_clear_flag(csk, CTPF_ABORT_REQ_RCVD);\n\n\tif (!cxgbi_sock_flag(csk, CTPF_TX_DATA_SENT)) {\n\t\tsend_tx_flowc_wr(csk);\n\t\tcxgbi_sock_set_flag(csk, CTPF_TX_DATA_SENT);\n\t}\n\n\tcxgbi_sock_set_flag(csk, CTPF_ABORT_REQ_RCVD);\n\tcxgbi_sock_set_state(csk, CTP_ABORTING);\n\n\tsend_abort_rpl(csk, rst_status);\n\n\tif (!cxgbi_sock_flag(csk, CTPF_ABORT_RPL_PENDING)) {\n\t\tcsk->err = abort_status_to_errno(csk, req->status, &rst_status);\n\t\tcxgbi_sock_closed(csk);\n\t}\n\n\tspin_unlock_bh(&csk->lock);\n\tcxgbi_sock_put(csk);\nrel_skb:\n\t__kfree_skb(skb);\n}\n\nstatic void do_abort_rpl_rss(struct cxgbi_device *cdev, struct sk_buff *skb)\n{\n\tstruct cxgbi_sock *csk;\n\tstruct cpl_abort_rpl_rss *rpl = (struct cpl_abort_rpl_rss *)skb->data;\n\tunsigned int tid = GET_TID(rpl);\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct tid_info *t = lldi->tids;\n\n\tcsk = lookup_tid(t, tid);\n\tif (!csk)\n\t\tgoto rel_skb;\n\n\tpr_info_ipaddr(\"csk 0x%p,%u,0x%lx,%u, status %u.\\n\",\n\t\t       (&csk->saddr), (&csk->daddr), csk,\n\t\t       csk->state, csk->flags, csk->tid, rpl->status);\n\n\tif (rpl->status == CPL_ERR_ABORT_FAILED)\n\t\tgoto rel_skb;\n\n\tcxgbi_sock_rcv_abort_rpl(csk);\nrel_skb:\n\t__kfree_skb(skb);\n}\n\nstatic void do_rx_data(struct cxgbi_device *cdev, struct sk_buff *skb)\n{\n\tstruct cxgbi_sock *csk;\n\tstruct cpl_rx_data *cpl = (struct cpl_rx_data *)skb->data;\n\tunsigned int tid = GET_TID(cpl);\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct tid_info *t = lldi->tids;\n\n\tcsk = lookup_tid(t, tid);\n\tif (!csk) {\n\t\tpr_err(\"can't find connection for tid %u.\\n\", tid);\n\t} else {\n\t\t \n\t\tpr_err(\"csk 0x%p, tid %u, rcv cpl_rx_data.\\n\", csk, tid);\n\t\tspin_lock_bh(&csk->lock);\n\t\tsend_abort_req(csk);\n\t\tspin_unlock_bh(&csk->lock);\n\t}\n\t__kfree_skb(skb);\n}\n\nstatic void do_rx_iscsi_hdr(struct cxgbi_device *cdev, struct sk_buff *skb)\n{\n\tstruct cxgbi_sock *csk;\n\tstruct cpl_iscsi_hdr *cpl = (struct cpl_iscsi_hdr *)skb->data;\n\tunsigned short pdu_len_ddp = be16_to_cpu(cpl->pdu_len_ddp);\n\tunsigned int tid = GET_TID(cpl);\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct tid_info *t = lldi->tids;\n\n\tcsk = lookup_tid(t, tid);\n\tif (unlikely(!csk)) {\n\t\tpr_err(\"can't find conn. for tid %u.\\n\", tid);\n\t\tgoto rel_skb;\n\t}\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_PDU_RX,\n\t\t\"csk 0x%p,%u,0x%lx, tid %u, skb 0x%p,%u, 0x%x.\\n\",\n\t\tcsk, csk->state, csk->flags, csk->tid, skb, skb->len,\n\t\tpdu_len_ddp);\n\n\tspin_lock_bh(&csk->lock);\n\n\tif (unlikely(csk->state >= CTP_PASSIVE_CLOSE)) {\n\t\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\t\"csk 0x%p,%u,0x%lx,%u, bad state.\\n\",\n\t\t\tcsk, csk->state, csk->flags, csk->tid);\n\t\tif (csk->state != CTP_ABORTING)\n\t\t\tgoto abort_conn;\n\t\telse\n\t\t\tgoto discard;\n\t}\n\n\tcxgbi_skcb_tcp_seq(skb) = ntohl(cpl->seq);\n\tcxgbi_skcb_flags(skb) = 0;\n\n\tskb_reset_transport_header(skb);\n\t__skb_pull(skb, sizeof(*cpl));\n\t__pskb_trim(skb, ntohs(cpl->len));\n\n\tif (!csk->skb_ulp_lhdr) {\n\t\tunsigned char *bhs;\n\t\tunsigned int hlen, dlen, plen;\n\n\t\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_PDU_RX,\n\t\t\t\"csk 0x%p,%u,0x%lx, tid %u, skb 0x%p header.\\n\",\n\t\t\tcsk, csk->state, csk->flags, csk->tid, skb);\n\t\tcsk->skb_ulp_lhdr = skb;\n\t\tcxgbi_skcb_set_flag(skb, SKCBF_RX_HDR);\n\n\t\tif ((CHELSIO_CHIP_VERSION(lldi->adapter_type) <= CHELSIO_T5) &&\n\t\t    (cxgbi_skcb_tcp_seq(skb) != csk->rcv_nxt)) {\n\t\t\tpr_info(\"tid %u, CPL_ISCSI_HDR, bad seq, 0x%x/0x%x.\\n\",\n\t\t\t\tcsk->tid, cxgbi_skcb_tcp_seq(skb),\n\t\t\t\tcsk->rcv_nxt);\n\t\t\tgoto abort_conn;\n\t\t}\n\n\t\tbhs = skb->data;\n\t\thlen = ntohs(cpl->len);\n\t\tdlen = ntohl(*(unsigned int *)(bhs + 4)) & 0xFFFFFF;\n\n\t\tplen = ISCSI_PDU_LEN_G(pdu_len_ddp);\n\t\tif (is_t4(lldi->adapter_type))\n\t\t\tplen -= 40;\n\n\t\tif ((hlen + dlen) != plen) {\n\t\t\tpr_info(\"tid 0x%x, CPL_ISCSI_HDR, pdu len \"\n\t\t\t\t\"mismatch %u != %u + %u, seq 0x%x.\\n\",\n\t\t\t\tcsk->tid, plen, hlen, dlen,\n\t\t\t\tcxgbi_skcb_tcp_seq(skb));\n\t\t\tgoto abort_conn;\n\t\t}\n\n\t\tcxgbi_skcb_rx_pdulen(skb) = (hlen + dlen + 3) & (~0x3);\n\t\tif (dlen)\n\t\t\tcxgbi_skcb_rx_pdulen(skb) += csk->dcrc_len;\n\t\tcsk->rcv_nxt += cxgbi_skcb_rx_pdulen(skb);\n\n\t\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_PDU_RX,\n\t\t\t\"csk 0x%p, skb 0x%p, 0x%x,%u+%u,0x%x,0x%x.\\n\",\n\t\t\tcsk, skb, *bhs, hlen, dlen,\n\t\t\tntohl(*((unsigned int *)(bhs + 16))),\n\t\t\tntohl(*((unsigned int *)(bhs + 24))));\n\n\t} else {\n\t\tstruct sk_buff *lskb = csk->skb_ulp_lhdr;\n\n\t\tcxgbi_skcb_set_flag(lskb, SKCBF_RX_DATA);\n\t\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_PDU_RX,\n\t\t\t\"csk 0x%p,%u,0x%lx, skb 0x%p data, 0x%p.\\n\",\n\t\t\tcsk, csk->state, csk->flags, skb, lskb);\n\t}\n\n\t__skb_queue_tail(&csk->receive_queue, skb);\n\tspin_unlock_bh(&csk->lock);\n\treturn;\n\nabort_conn:\n\tsend_abort_req(csk);\ndiscard:\n\tspin_unlock_bh(&csk->lock);\nrel_skb:\n\t__kfree_skb(skb);\n}\n\nstatic void do_rx_iscsi_data(struct cxgbi_device *cdev, struct sk_buff *skb)\n{\n\tstruct cxgbi_sock *csk;\n\tstruct cpl_iscsi_hdr *cpl = (struct cpl_iscsi_hdr *)skb->data;\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct tid_info *t = lldi->tids;\n\tstruct sk_buff *lskb;\n\tu32 tid = GET_TID(cpl);\n\tu16 pdu_len_ddp = be16_to_cpu(cpl->pdu_len_ddp);\n\n\tcsk = lookup_tid(t, tid);\n\tif (unlikely(!csk)) {\n\t\tpr_err(\"can't find conn. for tid %u.\\n\", tid);\n\t\tgoto rel_skb;\n\t}\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_PDU_RX,\n\t\t  \"csk 0x%p,%u,0x%lx, tid %u, skb 0x%p,%u, 0x%x.\\n\",\n\t\t  csk, csk->state, csk->flags, csk->tid, skb,\n\t\t  skb->len, pdu_len_ddp);\n\n\tspin_lock_bh(&csk->lock);\n\n\tif (unlikely(csk->state >= CTP_PASSIVE_CLOSE)) {\n\t\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\t  \"csk 0x%p,%u,0x%lx,%u, bad state.\\n\",\n\t\t\t  csk, csk->state, csk->flags, csk->tid);\n\n\t\tif (csk->state != CTP_ABORTING)\n\t\t\tgoto abort_conn;\n\t\telse\n\t\t\tgoto discard;\n\t}\n\n\tcxgbi_skcb_tcp_seq(skb) = be32_to_cpu(cpl->seq);\n\tcxgbi_skcb_flags(skb) = 0;\n\n\tskb_reset_transport_header(skb);\n\t__skb_pull(skb, sizeof(*cpl));\n\t__pskb_trim(skb, ntohs(cpl->len));\n\n\tif (!csk->skb_ulp_lhdr)\n\t\tcsk->skb_ulp_lhdr = skb;\n\n\tlskb = csk->skb_ulp_lhdr;\n\tcxgbi_skcb_set_flag(lskb, SKCBF_RX_DATA);\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_PDU_RX,\n\t\t  \"csk 0x%p,%u,0x%lx, skb 0x%p data, 0x%p.\\n\",\n\t\t  csk, csk->state, csk->flags, skb, lskb);\n\n\t__skb_queue_tail(&csk->receive_queue, skb);\n\tspin_unlock_bh(&csk->lock);\n\treturn;\n\nabort_conn:\n\tsend_abort_req(csk);\ndiscard:\n\tspin_unlock_bh(&csk->lock);\nrel_skb:\n\t__kfree_skb(skb);\n}\n\nstatic void\ncxgb4i_process_ddpvld(struct cxgbi_sock *csk,\n\t\t      struct sk_buff *skb, u32 ddpvld)\n{\n\tif (ddpvld & (1 << CPL_RX_DDP_STATUS_HCRC_SHIFT)) {\n\t\tpr_info(\"csk 0x%p, lhdr 0x%p, status 0x%x, hcrc bad 0x%lx.\\n\",\n\t\t\tcsk, skb, ddpvld, cxgbi_skcb_flags(skb));\n\t\tcxgbi_skcb_set_flag(skb, SKCBF_RX_HCRC_ERR);\n\t}\n\n\tif (ddpvld & (1 << CPL_RX_DDP_STATUS_DCRC_SHIFT)) {\n\t\tpr_info(\"csk 0x%p, lhdr 0x%p, status 0x%x, dcrc bad 0x%lx.\\n\",\n\t\t\tcsk, skb, ddpvld, cxgbi_skcb_flags(skb));\n\t\tcxgbi_skcb_set_flag(skb, SKCBF_RX_DCRC_ERR);\n\t}\n\n\tif (ddpvld & (1 << CPL_RX_DDP_STATUS_PAD_SHIFT)) {\n\t\tlog_debug(1 << CXGBI_DBG_PDU_RX,\n\t\t\t  \"csk 0x%p, lhdr 0x%p, status 0x%x, pad bad.\\n\",\n\t\t\t  csk, skb, ddpvld);\n\t\tcxgbi_skcb_set_flag(skb, SKCBF_RX_PAD_ERR);\n\t}\n\n\tif ((ddpvld & (1 << CPL_RX_DDP_STATUS_DDP_SHIFT)) &&\n\t    !cxgbi_skcb_test_flag(skb, SKCBF_RX_DATA)) {\n\t\tlog_debug(1 << CXGBI_DBG_PDU_RX,\n\t\t\t  \"csk 0x%p, lhdr 0x%p, 0x%x, data ddp'ed.\\n\",\n\t\t\t  csk, skb, ddpvld);\n\t\tcxgbi_skcb_set_flag(skb, SKCBF_RX_DATA_DDPD);\n\t}\n}\n\nstatic void do_rx_data_ddp(struct cxgbi_device *cdev,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct cxgbi_sock *csk;\n\tstruct sk_buff *lskb;\n\tstruct cpl_rx_data_ddp *rpl = (struct cpl_rx_data_ddp *)skb->data;\n\tunsigned int tid = GET_TID(rpl);\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct tid_info *t = lldi->tids;\n\tu32 ddpvld = be32_to_cpu(rpl->ddpvld);\n\n\tcsk = lookup_tid(t, tid);\n\tif (unlikely(!csk)) {\n\t\tpr_err(\"can't find connection for tid %u.\\n\", tid);\n\t\tgoto rel_skb;\n\t}\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_PDU_RX,\n\t\t\"csk 0x%p,%u,0x%lx, skb 0x%p,0x%x, lhdr 0x%p.\\n\",\n\t\tcsk, csk->state, csk->flags, skb, ddpvld, csk->skb_ulp_lhdr);\n\n\tspin_lock_bh(&csk->lock);\n\n\tif (unlikely(csk->state >= CTP_PASSIVE_CLOSE)) {\n\t\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\t\"csk 0x%p,%u,0x%lx,%u, bad state.\\n\",\n\t\t\tcsk, csk->state, csk->flags, csk->tid);\n\t\tif (csk->state != CTP_ABORTING)\n\t\t\tgoto abort_conn;\n\t\telse\n\t\t\tgoto discard;\n\t}\n\n\tif (!csk->skb_ulp_lhdr) {\n\t\tpr_err(\"tid 0x%x, rcv RX_DATA_DDP w/o pdu bhs.\\n\", csk->tid);\n\t\tgoto abort_conn;\n\t}\n\n\tlskb = csk->skb_ulp_lhdr;\n\tcsk->skb_ulp_lhdr = NULL;\n\n\tcxgbi_skcb_rx_ddigest(lskb) = ntohl(rpl->ulp_crc);\n\n\tif (ntohs(rpl->len) != cxgbi_skcb_rx_pdulen(lskb))\n\t\tpr_info(\"tid 0x%x, RX_DATA_DDP pdulen %u != %u.\\n\",\n\t\t\tcsk->tid, ntohs(rpl->len), cxgbi_skcb_rx_pdulen(lskb));\n\n\tcxgb4i_process_ddpvld(csk, lskb, ddpvld);\n\n\tlog_debug(1 << CXGBI_DBG_PDU_RX,\n\t\t\"csk 0x%p, lskb 0x%p, f 0x%lx.\\n\",\n\t\tcsk, lskb, cxgbi_skcb_flags(lskb));\n\n\tcxgbi_skcb_set_flag(lskb, SKCBF_RX_STATUS);\n\tcxgbi_conn_pdu_ready(csk);\n\tspin_unlock_bh(&csk->lock);\n\tgoto rel_skb;\n\nabort_conn:\n\tsend_abort_req(csk);\ndiscard:\n\tspin_unlock_bh(&csk->lock);\nrel_skb:\n\t__kfree_skb(skb);\n}\n\nstatic void\ndo_rx_iscsi_cmp(struct cxgbi_device *cdev, struct sk_buff *skb)\n{\n\tstruct cxgbi_sock *csk;\n\tstruct cpl_rx_iscsi_cmp *rpl = (struct cpl_rx_iscsi_cmp *)skb->data;\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct tid_info *t = lldi->tids;\n\tstruct sk_buff *data_skb = NULL;\n\tu32 tid = GET_TID(rpl);\n\tu32 ddpvld = be32_to_cpu(rpl->ddpvld);\n\tu32 seq = be32_to_cpu(rpl->seq);\n\tu16 pdu_len_ddp = be16_to_cpu(rpl->pdu_len_ddp);\n\n\tcsk = lookup_tid(t, tid);\n\tif (unlikely(!csk)) {\n\t\tpr_err(\"can't find connection for tid %u.\\n\", tid);\n\t\tgoto rel_skb;\n\t}\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_PDU_RX,\n\t\t  \"csk 0x%p,%u,0x%lx, skb 0x%p,0x%x, lhdr 0x%p, len %u, \"\n\t\t  \"pdu_len_ddp %u, status %u.\\n\",\n\t\t  csk, csk->state, csk->flags, skb, ddpvld, csk->skb_ulp_lhdr,\n\t\t  ntohs(rpl->len), pdu_len_ddp,  rpl->status);\n\n\tspin_lock_bh(&csk->lock);\n\n\tif (unlikely(csk->state >= CTP_PASSIVE_CLOSE)) {\n\t\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\t  \"csk 0x%p,%u,0x%lx,%u, bad state.\\n\",\n\t\t\t  csk, csk->state, csk->flags, csk->tid);\n\n\t\tif (csk->state != CTP_ABORTING)\n\t\t\tgoto abort_conn;\n\t\telse\n\t\t\tgoto discard;\n\t}\n\n\tcxgbi_skcb_tcp_seq(skb) = seq;\n\tcxgbi_skcb_flags(skb) = 0;\n\tcxgbi_skcb_rx_pdulen(skb) = 0;\n\n\tskb_reset_transport_header(skb);\n\t__skb_pull(skb, sizeof(*rpl));\n\t__pskb_trim(skb, be16_to_cpu(rpl->len));\n\n\tcsk->rcv_nxt = seq + pdu_len_ddp;\n\n\tif (csk->skb_ulp_lhdr) {\n\t\tdata_skb = skb_peek(&csk->receive_queue);\n\t\tif (!data_skb ||\n\t\t    !cxgbi_skcb_test_flag(data_skb, SKCBF_RX_DATA)) {\n\t\t\tpr_err(\"Error! freelist data not found 0x%p, tid %u\\n\",\n\t\t\t       data_skb, tid);\n\n\t\t\tgoto abort_conn;\n\t\t}\n\t\t__skb_unlink(data_skb, &csk->receive_queue);\n\n\t\tcxgbi_skcb_set_flag(skb, SKCBF_RX_DATA);\n\n\t\t__skb_queue_tail(&csk->receive_queue, skb);\n\t\t__skb_queue_tail(&csk->receive_queue, data_skb);\n\t} else {\n\t\t __skb_queue_tail(&csk->receive_queue, skb);\n\t}\n\n\tcsk->skb_ulp_lhdr = NULL;\n\n\tcxgbi_skcb_set_flag(skb, SKCBF_RX_HDR);\n\tcxgbi_skcb_set_flag(skb, SKCBF_RX_STATUS);\n\tcxgbi_skcb_set_flag(skb, SKCBF_RX_ISCSI_COMPL);\n\tcxgbi_skcb_rx_ddigest(skb) = be32_to_cpu(rpl->ulp_crc);\n\n\tcxgb4i_process_ddpvld(csk, skb, ddpvld);\n\n\tlog_debug(1 << CXGBI_DBG_PDU_RX, \"csk 0x%p, skb 0x%p, f 0x%lx.\\n\",\n\t\t  csk, skb, cxgbi_skcb_flags(skb));\n\n\tcxgbi_conn_pdu_ready(csk);\n\tspin_unlock_bh(&csk->lock);\n\n\treturn;\n\nabort_conn:\n\tsend_abort_req(csk);\ndiscard:\n\tspin_unlock_bh(&csk->lock);\nrel_skb:\n\t__kfree_skb(skb);\n}\n\nstatic void do_fw4_ack(struct cxgbi_device *cdev, struct sk_buff *skb)\n{\n\tstruct cxgbi_sock *csk;\n\tstruct cpl_fw4_ack *rpl = (struct cpl_fw4_ack *)skb->data;\n\tunsigned int tid = GET_TID(rpl);\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct tid_info *t = lldi->tids;\n\n\tcsk = lookup_tid(t, tid);\n\tif (unlikely(!csk))\n\t\tpr_err(\"can't find connection for tid %u.\\n\", tid);\n\telse {\n\t\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\t\"csk 0x%p,%u,0x%lx,%u.\\n\",\n\t\t\tcsk, csk->state, csk->flags, csk->tid);\n\t\tcxgbi_sock_rcv_wr_ack(csk, rpl->credits, ntohl(rpl->snd_una),\n\t\t\t\t\trpl->seq_vld);\n\t}\n\t__kfree_skb(skb);\n}\n\nstatic void do_set_tcb_rpl(struct cxgbi_device *cdev, struct sk_buff *skb)\n{\n\tstruct cpl_set_tcb_rpl *rpl = (struct cpl_set_tcb_rpl *)skb->data;\n\tunsigned int tid = GET_TID(rpl);\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct tid_info *t = lldi->tids;\n\tstruct cxgbi_sock *csk;\n\n\tcsk = lookup_tid(t, tid);\n\tif (!csk) {\n\t\tpr_err(\"can't find conn. for tid %u.\\n\", tid);\n\t\treturn;\n\t}\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\"csk 0x%p,%u,%lx,%u, status 0x%x.\\n\",\n\t\tcsk, csk->state, csk->flags, csk->tid, rpl->status);\n\n\tif (rpl->status != CPL_ERR_NONE) {\n\t\tpr_err(\"csk 0x%p,%u, SET_TCB_RPL status %u.\\n\",\n\t\t\tcsk, tid, rpl->status);\n\t\tcsk->err = -EINVAL;\n\t}\n\n\tcomplete(&csk->cmpl);\n\n\t__kfree_skb(skb);\n}\n\nstatic int alloc_cpls(struct cxgbi_sock *csk)\n{\n\tcsk->cpl_close = alloc_wr(sizeof(struct cpl_close_con_req),\n\t\t\t\t\t0, GFP_KERNEL);\n\tif (!csk->cpl_close)\n\t\treturn -ENOMEM;\n\n\tcsk->cpl_abort_req = alloc_wr(sizeof(struct cpl_abort_req),\n\t\t\t\t\t0, GFP_KERNEL);\n\tif (!csk->cpl_abort_req)\n\t\tgoto free_cpls;\n\n\tcsk->cpl_abort_rpl = alloc_wr(sizeof(struct cpl_abort_rpl),\n\t\t\t\t\t0, GFP_KERNEL);\n\tif (!csk->cpl_abort_rpl)\n\t\tgoto free_cpls;\n\treturn 0;\n\nfree_cpls:\n\tcxgbi_sock_free_cpl_skbs(csk);\n\treturn -ENOMEM;\n}\n\nstatic inline void l2t_put(struct cxgbi_sock *csk)\n{\n\tif (csk->l2t) {\n\t\tcxgb4_l2t_release(csk->l2t);\n\t\tcsk->l2t = NULL;\n\t\tcxgbi_sock_put(csk);\n\t}\n}\n\nstatic void release_offload_resources(struct cxgbi_sock *csk)\n{\n\tstruct cxgb4_lld_info *lldi;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct net_device *ndev = csk->cdev->ports[csk->port_id];\n#endif\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\"csk 0x%p,%u,0x%lx,%u.\\n\",\n\t\tcsk, csk->state, csk->flags, csk->tid);\n\n\tcxgbi_sock_free_cpl_skbs(csk);\n\tcxgbi_sock_purge_write_queue(csk);\n\tif (csk->wr_cred != csk->wr_max_cred) {\n\t\tcxgbi_sock_purge_wr_queue(csk);\n\t\tcxgbi_sock_reset_wr_list(csk);\n\t}\n\n\tl2t_put(csk);\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (csk->csk_family == AF_INET6)\n\t\tcxgb4_clip_release(ndev,\n\t\t\t\t   (const u32 *)&csk->saddr6.sin6_addr, 1);\n#endif\n\n\tif (cxgbi_sock_flag(csk, CTPF_HAS_ATID))\n\t\tfree_atid(csk);\n\telse if (cxgbi_sock_flag(csk, CTPF_HAS_TID)) {\n\t\tlldi = cxgbi_cdev_priv(csk->cdev);\n\t\tcxgb4_remove_tid(lldi->tids, 0, csk->tid,\n\t\t\t\t csk->csk_family);\n\t\tcxgbi_sock_clear_flag(csk, CTPF_HAS_TID);\n\t\tcxgbi_sock_put(csk);\n\t}\n\tcsk->dst = NULL;\n}\n\n#ifdef CONFIG_CHELSIO_T4_DCB\nstatic inline u8 get_iscsi_dcb_state(struct net_device *ndev)\n{\n\treturn ndev->dcbnl_ops->getstate(ndev);\n}\n\nstatic int select_priority(int pri_mask)\n{\n\tif (!pri_mask)\n\t\treturn 0;\n\treturn (ffs(pri_mask) - 1);\n}\n\nstatic u8 get_iscsi_dcb_priority(struct net_device *ndev)\n{\n\tint rv;\n\tu8 caps;\n\n\tstruct dcb_app iscsi_dcb_app = {\n\t\t.protocol = 3260\n\t};\n\n\trv = (int)ndev->dcbnl_ops->getcap(ndev, DCB_CAP_ATTR_DCBX, &caps);\n\tif (rv)\n\t\treturn 0;\n\n\tif (caps & DCB_CAP_DCBX_VER_IEEE) {\n\t\tiscsi_dcb_app.selector = IEEE_8021QAZ_APP_SEL_STREAM;\n\t\trv = dcb_ieee_getapp_mask(ndev, &iscsi_dcb_app);\n\t\tif (!rv) {\n\t\t\tiscsi_dcb_app.selector = IEEE_8021QAZ_APP_SEL_ANY;\n\t\t\trv = dcb_ieee_getapp_mask(ndev, &iscsi_dcb_app);\n\t\t}\n\t} else if (caps & DCB_CAP_DCBX_VER_CEE) {\n\t\tiscsi_dcb_app.selector = DCB_APP_IDTYPE_PORTNUM;\n\t\trv = dcb_getapp(ndev, &iscsi_dcb_app);\n\t}\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI,\n\t\t  \"iSCSI priority is set to %u\\n\", select_priority(rv));\n\treturn select_priority(rv);\n}\n#endif\n\nstatic int init_act_open(struct cxgbi_sock *csk)\n{\n\tstruct cxgbi_device *cdev = csk->cdev;\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct net_device *ndev = cdev->ports[csk->port_id];\n\tstruct sk_buff *skb = NULL;\n\tstruct neighbour *n = NULL;\n\tvoid *daddr;\n\tunsigned int step;\n\tunsigned int rxq_idx;\n\tunsigned int size, size6;\n\tunsigned int linkspeed;\n\tunsigned int rcv_winf, snd_winf;\n#ifdef CONFIG_CHELSIO_T4_DCB\n\tu8 priority = 0;\n#endif\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\"csk 0x%p,%u,0x%lx,%u.\\n\",\n\t\tcsk, csk->state, csk->flags, csk->tid);\n\n\tif (csk->csk_family == AF_INET)\n\t\tdaddr = &csk->daddr.sin_addr.s_addr;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse if (csk->csk_family == AF_INET6)\n\t\tdaddr = &csk->daddr6.sin6_addr;\n#endif\n\telse {\n\t\tpr_err(\"address family 0x%x not supported\\n\", csk->csk_family);\n\t\tgoto rel_resource;\n\t}\n\n\tn = dst_neigh_lookup(csk->dst, daddr);\n\n\tif (!n) {\n\t\tpr_err(\"%s, can't get neighbour of csk->dst.\\n\", ndev->name);\n\t\tgoto rel_resource;\n\t}\n\n\tif (!(n->nud_state & NUD_VALID))\n\t\tneigh_event_send(n, NULL);\n\n\tcsk->atid = cxgb4_alloc_atid(lldi->tids, csk);\n\tif (csk->atid < 0) {\n\t\tpr_err(\"%s, NO atid available.\\n\", ndev->name);\n\t\tgoto rel_resource_without_clip;\n\t}\n\tcxgbi_sock_set_flag(csk, CTPF_HAS_ATID);\n\tcxgbi_sock_get(csk);\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n\tif (get_iscsi_dcb_state(ndev))\n\t\tpriority = get_iscsi_dcb_priority(ndev);\n\n\tcsk->dcb_priority = priority;\n\tcsk->l2t = cxgb4_l2t_get(lldi->l2t, n, ndev, priority);\n#else\n\tcsk->l2t = cxgb4_l2t_get(lldi->l2t, n, ndev, 0);\n#endif\n\tif (!csk->l2t) {\n\t\tpr_err(\"%s, cannot alloc l2t.\\n\", ndev->name);\n\t\tgoto rel_resource_without_clip;\n\t}\n\tcxgbi_sock_get(csk);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (csk->csk_family == AF_INET6)\n\t\tcxgb4_clip_get(ndev, (const u32 *)&csk->saddr6.sin6_addr, 1);\n#endif\n\n\tif (is_t4(lldi->adapter_type)) {\n\t\tsize = sizeof(struct cpl_act_open_req);\n\t\tsize6 = sizeof(struct cpl_act_open_req6);\n\t} else if (is_t5(lldi->adapter_type)) {\n\t\tsize = sizeof(struct cpl_t5_act_open_req);\n\t\tsize6 = sizeof(struct cpl_t5_act_open_req6);\n\t} else {\n\t\tsize = sizeof(struct cpl_t6_act_open_req);\n\t\tsize6 = sizeof(struct cpl_t6_act_open_req6);\n\t}\n\n\tif (csk->csk_family == AF_INET)\n\t\tskb = alloc_wr(size, 0, GFP_NOIO);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tskb = alloc_wr(size6, 0, GFP_NOIO);\n#endif\n\n\tif (!skb)\n\t\tgoto rel_resource;\n\tskb->sk = (struct sock *)csk;\n\tt4_set_arp_err_handler(skb, csk, cxgbi_sock_act_open_req_arp_failure);\n\n\tif (!csk->mtu)\n\t\tcsk->mtu = dst_mtu(csk->dst);\n\tcxgb4_best_mtu(lldi->mtus, csk->mtu, &csk->mss_idx);\n\tcsk->tx_chan = cxgb4_port_chan(ndev);\n\tcsk->smac_idx = ((struct port_info *)netdev_priv(ndev))->smt_idx;\n\tstep = lldi->ntxq / lldi->nchan;\n\tcsk->txq_idx = cxgb4_port_idx(ndev) * step;\n\tstep = lldi->nrxq / lldi->nchan;\n\trxq_idx = (cxgb4_port_idx(ndev) * step) + (cdev->rxq_idx_cntr % step);\n\tcdev->rxq_idx_cntr++;\n\tcsk->rss_qid = lldi->rxq_ids[rxq_idx];\n\tlinkspeed = ((struct port_info *)netdev_priv(ndev))->link_cfg.speed;\n\tcsk->snd_win = cxgb4i_snd_win;\n\tcsk->rcv_win = cxgb4i_rcv_win;\n\tif (cxgb4i_rcv_win <= 0) {\n\t\tcsk->rcv_win = CXGB4I_DEFAULT_10G_RCV_WIN;\n\t\trcv_winf = linkspeed / SPEED_10000;\n\t\tif (rcv_winf)\n\t\t\tcsk->rcv_win *= rcv_winf;\n\t}\n\tif (cxgb4i_snd_win <= 0) {\n\t\tcsk->snd_win = CXGB4I_DEFAULT_10G_SND_WIN;\n\t\tsnd_winf = linkspeed / SPEED_10000;\n\t\tif (snd_winf)\n\t\t\tcsk->snd_win *= snd_winf;\n\t}\n\tcsk->wr_cred = lldi->wr_cred -\n\t\t       DIV_ROUND_UP(sizeof(struct cpl_abort_req), 16);\n\tcsk->wr_max_cred = csk->wr_cred;\n\tcsk->wr_una_cred = 0;\n\tcxgbi_sock_reset_wr_list(csk);\n\tcsk->err = 0;\n\n\tpr_info_ipaddr(\"csk 0x%p,%u,0x%lx,%u,%u,%u, mtu %u,%u, smac %u.\\n\",\n\t\t       (&csk->saddr), (&csk->daddr), csk, csk->state,\n\t\t       csk->flags, csk->tx_chan, csk->txq_idx, csk->rss_qid,\n\t\t       csk->mtu, csk->mss_idx, csk->smac_idx);\n\n\t \n\tif (!try_module_get(cdev->owner)) {\n\t\tpr_err(\"%s, try_module_get failed.\\n\", ndev->name);\n\t\tgoto rel_resource;\n\t}\n\n\tcxgbi_sock_set_state(csk, CTP_ACTIVE_OPEN);\n\tif (csk->csk_family == AF_INET)\n\t\tsend_act_open_req(csk, skb, csk->l2t);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tsend_act_open_req6(csk, skb, csk->l2t);\n#endif\n\tneigh_release(n);\n\n\treturn 0;\n\nrel_resource:\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (csk->csk_family == AF_INET6)\n\t\tcxgb4_clip_release(ndev,\n\t\t\t\t   (const u32 *)&csk->saddr6.sin6_addr, 1);\n#endif\nrel_resource_without_clip:\n\tif (n)\n\t\tneigh_release(n);\n\tif (skb)\n\t\t__kfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic cxgb4i_cplhandler_func cxgb4i_cplhandlers[NUM_CPL_CMDS] = {\n\t[CPL_ACT_ESTABLISH] = do_act_establish,\n\t[CPL_ACT_OPEN_RPL] = do_act_open_rpl,\n\t[CPL_PEER_CLOSE] = do_peer_close,\n\t[CPL_ABORT_REQ_RSS] = do_abort_req_rss,\n\t[CPL_ABORT_RPL_RSS] = do_abort_rpl_rss,\n\t[CPL_CLOSE_CON_RPL] = do_close_con_rpl,\n\t[CPL_FW4_ACK] = do_fw4_ack,\n\t[CPL_ISCSI_HDR] = do_rx_iscsi_hdr,\n\t[CPL_ISCSI_DATA] = do_rx_iscsi_data,\n\t[CPL_SET_TCB_RPL] = do_set_tcb_rpl,\n\t[CPL_RX_DATA_DDP] = do_rx_data_ddp,\n\t[CPL_RX_ISCSI_DDP] = do_rx_data_ddp,\n\t[CPL_RX_ISCSI_CMP] = do_rx_iscsi_cmp,\n\t[CPL_RX_DATA] = do_rx_data,\n};\n\nstatic int cxgb4i_ofld_init(struct cxgbi_device *cdev)\n{\n\tint rc;\n\n\tif (cxgb4i_max_connect > CXGB4I_MAX_CONN)\n\t\tcxgb4i_max_connect = CXGB4I_MAX_CONN;\n\n\trc = cxgbi_device_portmap_create(cdev, cxgb4i_sport_base,\n\t\t\t\t\tcxgb4i_max_connect);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tcdev->csk_release_offload_resources = release_offload_resources;\n\tcdev->csk_push_tx_frames = push_tx_frames;\n\tcdev->csk_send_abort_req = send_abort_req;\n\tcdev->csk_send_close_req = send_close_req;\n\tcdev->csk_send_rx_credits = send_rx_credits;\n\tcdev->csk_alloc_cpls = alloc_cpls;\n\tcdev->csk_init_act_open = init_act_open;\n\n\tpr_info(\"cdev 0x%p, offload up, added.\\n\", cdev);\n\treturn 0;\n}\n\nstatic inline void\nulp_mem_io_set_hdr(struct cxgbi_device *cdev,\n\t\t   struct ulp_mem_io *req,\n\t\t   unsigned int wr_len, unsigned int dlen,\n\t\t   unsigned int pm_addr,\n\t\t   int tid)\n{\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct ulptx_idata *idata = (struct ulptx_idata *)(req + 1);\n\n\tINIT_ULPTX_WR(req, wr_len, 0, tid);\n\treq->wr.wr_hi = htonl(FW_WR_OP_V(FW_ULPTX_WR) |\n\t\tFW_WR_ATOMIC_V(0));\n\treq->cmd = htonl(ULPTX_CMD_V(ULP_TX_MEM_WRITE) |\n\t\tULP_MEMIO_ORDER_V(is_t4(lldi->adapter_type)) |\n\t\tT5_ULP_MEMIO_IMM_V(!is_t4(lldi->adapter_type)));\n\treq->dlen = htonl(ULP_MEMIO_DATA_LEN_V(dlen >> 5));\n\treq->lock_addr = htonl(ULP_MEMIO_ADDR_V(pm_addr >> 5));\n\treq->len16 = htonl(DIV_ROUND_UP(wr_len - sizeof(req->wr), 16));\n\n\tidata->cmd_more = htonl(ULPTX_CMD_V(ULP_TX_SC_IMM));\n\tidata->len = htonl(dlen);\n}\n\nstatic struct sk_buff *\nddp_ppod_init_idata(struct cxgbi_device *cdev,\n\t\t    struct cxgbi_ppm *ppm,\n\t\t    unsigned int idx, unsigned int npods,\n\t\t    unsigned int tid)\n{\n\tunsigned int pm_addr = (idx << PPOD_SIZE_SHIFT) + ppm->llimit;\n\tunsigned int dlen = npods << PPOD_SIZE_SHIFT;\n\tunsigned int wr_len = roundup(sizeof(struct ulp_mem_io) +\n\t\t\t\tsizeof(struct ulptx_idata) + dlen, 16);\n\tstruct sk_buff *skb = alloc_wr(wr_len, 0, GFP_ATOMIC);\n\n\tif (!skb) {\n\t\tpr_err(\"%s: %s idx %u, npods %u, OOM.\\n\",\n\t\t       __func__, ppm->ndev->name, idx, npods);\n\t\treturn NULL;\n\t}\n\n\tulp_mem_io_set_hdr(cdev, (struct ulp_mem_io *)skb->head, wr_len, dlen,\n\t\t\t   pm_addr, tid);\n\n\treturn skb;\n}\n\nstatic int ddp_ppod_write_idata(struct cxgbi_ppm *ppm, struct cxgbi_sock *csk,\n\t\t\t\tstruct cxgbi_task_tag_info *ttinfo,\n\t\t\t\tunsigned int idx, unsigned int npods,\n\t\t\t\tstruct scatterlist **sg_pp,\n\t\t\t\tunsigned int *sg_off)\n{\n\tstruct cxgbi_device *cdev = csk->cdev;\n\tstruct sk_buff *skb = ddp_ppod_init_idata(cdev, ppm, idx, npods,\n\t\t\t\t\t\t  csk->tid);\n\tstruct ulp_mem_io *req;\n\tstruct ulptx_idata *idata;\n\tstruct cxgbi_pagepod *ppod;\n\tint i;\n\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\treq = (struct ulp_mem_io *)skb->head;\n\tidata = (struct ulptx_idata *)(req + 1);\n\tppod = (struct cxgbi_pagepod *)(idata + 1);\n\n\tfor (i = 0; i < npods; i++, ppod++)\n\t\tcxgbi_ddp_set_one_ppod(ppod, ttinfo, sg_pp, sg_off);\n\n\tcxgbi_skcb_set_flag(skb, SKCBF_TX_MEM_WRITE);\n\tcxgbi_skcb_set_flag(skb, SKCBF_TX_FLAG_COMPL);\n\tset_wr_txq(skb, CPL_PRIORITY_DATA, csk->port_id);\n\n\tspin_lock_bh(&csk->lock);\n\tcxgbi_sock_skb_entail(csk, skb);\n\tspin_unlock_bh(&csk->lock);\n\n\treturn 0;\n}\n\nstatic int ddp_set_map(struct cxgbi_ppm *ppm, struct cxgbi_sock *csk,\n\t\t       struct cxgbi_task_tag_info *ttinfo)\n{\n\tunsigned int pidx = ttinfo->idx;\n\tunsigned int npods = ttinfo->npods;\n\tunsigned int i, cnt;\n\tint err = 0;\n\tstruct scatterlist *sg = ttinfo->sgl;\n\tunsigned int offset = 0;\n\n\tttinfo->cid = csk->port_id;\n\n\tfor (i = 0; i < npods; i += cnt, pidx += cnt) {\n\t\tcnt = npods - i;\n\n\t\tif (cnt > ULPMEM_IDATA_MAX_NPPODS)\n\t\t\tcnt = ULPMEM_IDATA_MAX_NPPODS;\n\t\terr = ddp_ppod_write_idata(ppm, csk, ttinfo, pidx, cnt,\n\t\t\t\t\t   &sg, &offset);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int ddp_setup_conn_pgidx(struct cxgbi_sock *csk, unsigned int tid,\n\t\t\t\tint pg_idx)\n{\n\tstruct sk_buff *skb;\n\tstruct cpl_set_tcb_field *req;\n\n\tif (!pg_idx || pg_idx >= DDP_PGIDX_MAX)\n\t\treturn 0;\n\n\tskb = alloc_wr(sizeof(*req), 0, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\t \n\treq = (struct cpl_set_tcb_field *)skb->head;\n\tINIT_TP_WR(req, csk->tid);\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_SET_TCB_FIELD, csk->tid));\n\treq->reply_ctrl = htons(NO_REPLY_V(0) | QUEUENO_V(csk->rss_qid));\n\treq->word_cookie = htons(0);\n\treq->mask = cpu_to_be64(0x3 << 8);\n\treq->val = cpu_to_be64(pg_idx << 8);\n\tset_wr_txq(skb, CPL_PRIORITY_CONTROL, csk->port_id);\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\"csk 0x%p, tid 0x%x, pg_idx %u.\\n\", csk, csk->tid, pg_idx);\n\n\treinit_completion(&csk->cmpl);\n\tcxgb4_ofld_send(csk->cdev->ports[csk->port_id], skb);\n\twait_for_completion(&csk->cmpl);\n\n\treturn csk->err;\n}\n\nstatic int ddp_setup_conn_digest(struct cxgbi_sock *csk, unsigned int tid,\n\t\t\t\t int hcrc, int dcrc)\n{\n\tstruct sk_buff *skb;\n\tstruct cpl_set_tcb_field *req;\n\n\tif (!hcrc && !dcrc)\n\t\treturn 0;\n\n\tskb = alloc_wr(sizeof(*req), 0, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcsk->hcrc_len = (hcrc ? 4 : 0);\n\tcsk->dcrc_len = (dcrc ? 4 : 0);\n\t \n\treq = (struct cpl_set_tcb_field *)skb->head;\n\tINIT_TP_WR(req, tid);\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_SET_TCB_FIELD, tid));\n\treq->reply_ctrl = htons(NO_REPLY_V(0) | QUEUENO_V(csk->rss_qid));\n\treq->word_cookie = htons(0);\n\treq->mask = cpu_to_be64(0x3 << 4);\n\treq->val = cpu_to_be64(((hcrc ? ULP_CRC_HEADER : 0) |\n\t\t\t\t(dcrc ? ULP_CRC_DATA : 0)) << 4);\n\tset_wr_txq(skb, CPL_PRIORITY_CONTROL, csk->port_id);\n\n\tlog_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,\n\t\t\"csk 0x%p, tid 0x%x, crc %d,%d.\\n\", csk, csk->tid, hcrc, dcrc);\n\n\treinit_completion(&csk->cmpl);\n\tcxgb4_ofld_send(csk->cdev->ports[csk->port_id], skb);\n\twait_for_completion(&csk->cmpl);\n\n\treturn csk->err;\n}\n\nstatic struct cxgbi_ppm *cdev2ppm(struct cxgbi_device *cdev)\n{\n\treturn (struct cxgbi_ppm *)(*((struct cxgb4_lld_info *)\n\t\t\t\t       (cxgbi_cdev_priv(cdev)))->iscsi_ppm);\n}\n\nstatic int cxgb4i_ddp_init(struct cxgbi_device *cdev)\n{\n\tstruct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);\n\tstruct net_device *ndev = cdev->ports[0];\n\tstruct cxgbi_tag_format tformat;\n\tint i, err;\n\n\tif (!lldi->vr->iscsi.size) {\n\t\tpr_warn(\"%s, iscsi NOT enabled, check config!\\n\", ndev->name);\n\t\treturn -EACCES;\n\t}\n\n\tcdev->flags |= CXGBI_FLAG_USE_PPOD_OFLDQ;\n\n\tmemset(&tformat, 0, sizeof(struct cxgbi_tag_format));\n\tfor (i = 0; i < 4; i++)\n\t\ttformat.pgsz_order[i] = (lldi->iscsi_pgsz_order >> (i << 3))\n\t\t\t\t\t & 0xF;\n\tcxgbi_tagmask_check(lldi->iscsi_tagmask, &tformat);\n\n\tpr_info(\"iscsi_edram.start 0x%x iscsi_edram.size 0x%x\",\n\t\tlldi->vr->ppod_edram.start, lldi->vr->ppod_edram.size);\n\n\terr = cxgbi_ddp_ppm_setup(lldi->iscsi_ppm, cdev, &tformat,\n\t\t\t\t  lldi->vr->iscsi.size, lldi->iscsi_llimit,\n\t\t\t\t  lldi->vr->iscsi.start, 2,\n\t\t\t\t  lldi->vr->ppod_edram.start,\n\t\t\t\t  lldi->vr->ppod_edram.size);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tcdev->csk_ddp_setup_digest = ddp_setup_conn_digest;\n\tcdev->csk_ddp_setup_pgidx = ddp_setup_conn_pgidx;\n\tcdev->csk_ddp_set_map = ddp_set_map;\n\tcdev->tx_max_size = min_t(unsigned int, ULP2_MAX_PDU_PAYLOAD,\n\t\t\t\t  lldi->iscsi_iolen - ISCSI_PDU_NONPAYLOAD_LEN);\n\tcdev->rx_max_size = min_t(unsigned int, ULP2_MAX_PDU_PAYLOAD,\n\t\t\t\t  lldi->iscsi_iolen - ISCSI_PDU_NONPAYLOAD_LEN);\n\tcdev->cdev2ppm = cdev2ppm;\n\n\treturn 0;\n}\n\nstatic bool is_memfree(struct adapter *adap)\n{\n\tu32 io;\n\n\tio = t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A);\n\tif (is_t5(adap->params.chip)) {\n\t\tif ((io & EXT_MEM0_ENABLE_F) || (io & EXT_MEM1_ENABLE_F))\n\t\t\treturn false;\n\t} else if (io & EXT_MEM_ENABLE_F) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void *t4_uld_add(const struct cxgb4_lld_info *lldi)\n{\n\tstruct cxgbi_device *cdev;\n\tstruct port_info *pi;\n\tstruct net_device *ndev;\n\tstruct adapter *adap;\n\tstruct tid_info *t;\n\tu32 max_cmds = CXGB4I_SCSI_HOST_QDEPTH;\n\tu32 max_conn = CXGBI_MAX_CONN;\n\tint i, rc;\n\n\tcdev = cxgbi_device_register(sizeof(*lldi), lldi->nports);\n\tif (!cdev) {\n\t\tpr_info(\"t4 device 0x%p, register failed.\\n\", lldi);\n\t\treturn NULL;\n\t}\n\tpr_info(\"0x%p,0x%x, ports %u,%s, chan %u, q %u,%u, wr %u.\\n\",\n\t\tcdev, lldi->adapter_type, lldi->nports,\n\t\tlldi->ports[0]->name, lldi->nchan, lldi->ntxq,\n\t\tlldi->nrxq, lldi->wr_cred);\n\tfor (i = 0; i < lldi->nrxq; i++)\n\t\tlog_debug(1 << CXGBI_DBG_DEV,\n\t\t\t\"t4 0x%p, rxq id #%d: %u.\\n\",\n\t\t\tcdev, i, lldi->rxq_ids[i]);\n\n\tmemcpy(cxgbi_cdev_priv(cdev), lldi, sizeof(*lldi));\n\tcdev->flags = CXGBI_FLAG_DEV_T4;\n\tcdev->pdev = lldi->pdev;\n\tcdev->ports = lldi->ports;\n\tcdev->nports = lldi->nports;\n\tcdev->mtus = lldi->mtus;\n\tcdev->nmtus = NMTUS;\n\tcdev->rx_credit_thres = (CHELSIO_CHIP_VERSION(lldi->adapter_type) <=\n\t\t\t\t CHELSIO_T5) ? cxgb4i_rx_credit_thres : 0;\n\tcdev->skb_tx_rsvd = CXGB4I_TX_HEADER_LEN;\n\tcdev->skb_rx_extra = sizeof(struct cpl_iscsi_hdr);\n\tcdev->itp = &cxgb4i_iscsi_transport;\n\tcdev->owner = THIS_MODULE;\n\n\tcdev->pfvf = FW_PFVF_CMD_PFN_V(lldi->pf);\n\tpr_info(\"cdev 0x%p,%s, pfvf %u.\\n\",\n\t\tcdev, lldi->ports[0]->name, cdev->pfvf);\n\n\trc = cxgb4i_ddp_init(cdev);\n\tif (rc) {\n\t\tpr_info(\"t4 0x%p ddp init failed %d.\\n\", cdev, rc);\n\t\tgoto err_out;\n\t}\n\n\tndev = cdev->ports[0];\n\tadap = netdev2adap(ndev);\n\tif (adap) {\n\t\tt = &adap->tids;\n\t\tif (t->ntids <= CXGBI_MAX_CONN)\n\t\t\tmax_conn = t->ntids;\n\n\t\tif (is_memfree(adap)) {\n\t\t\tcdev->flags |=\tCXGBI_FLAG_DEV_ISO_OFF;\n\t\t\tmax_cmds = CXGB4I_SCSI_HOST_QDEPTH >> 2;\n\n\t\t\tpr_info(\"%s: 0x%p, tid %u, SO adapter.\\n\",\n\t\t\t\tndev->name, cdev, t->ntids);\n\t\t}\n\t} else {\n\t\tpr_info(\"%s, 0x%p, NO adapter struct.\\n\", ndev->name, cdev);\n\t}\n\n\t \n\tif (!is_t4(lldi->adapter_type) &&\n\t    (lldi->fw_vers >= 0x10d2b00) &&\n\t    !(cdev->flags & CXGBI_FLAG_DEV_ISO_OFF))\n\t\tcdev->skb_iso_txhdr = sizeof(struct cpl_tx_data_iso);\n\n\trc = cxgb4i_ofld_init(cdev);\n\tif (rc) {\n\t\tpr_info(\"t4 0x%p ofld init failed.\\n\", cdev);\n\t\tgoto err_out;\n\t}\n\n\tcxgb4i_host_template.can_queue = max_cmds;\n\trc = cxgbi_hbas_add(cdev, CXGB4I_MAX_LUN, max_conn,\n\t\t\t    &cxgb4i_host_template, cxgb4i_stt);\n\tif (rc)\n\t\tgoto err_out;\n\n\tfor (i = 0; i < cdev->nports; i++) {\n\t\tpi = netdev_priv(lldi->ports[i]);\n\t\tcdev->hbas[i]->port_id = pi->port_id;\n\t}\n\treturn cdev;\n\nerr_out:\n\tcxgbi_device_unregister(cdev);\n\treturn ERR_PTR(-ENOMEM);\n}\n\n#define RX_PULL_LEN\t128\nstatic int t4_uld_rx_handler(void *handle, const __be64 *rsp,\n\t\t\t\tconst struct pkt_gl *pgl)\n{\n\tconst struct cpl_act_establish *rpl;\n\tstruct sk_buff *skb;\n\tunsigned int opc;\n\tstruct cxgbi_device *cdev = handle;\n\n\tif (pgl == NULL) {\n\t\tunsigned int len = 64 - sizeof(struct rsp_ctrl) - 8;\n\n\t\tskb = alloc_wr(len, 0, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\tgoto nomem;\n\t\tskb_copy_to_linear_data(skb, &rsp[1], len);\n\t} else {\n\t\tif (unlikely(*(u8 *)rsp != *(u8 *)pgl->va)) {\n\t\t\tpr_info(\"? FL 0x%p,RSS%#llx,FL %#llx,len %u.\\n\",\n\t\t\t\tpgl->va, be64_to_cpu(*rsp),\n\t\t\t\tbe64_to_cpu(*(u64 *)pgl->va),\n\t\t\t\tpgl->tot_len);\n\t\t\treturn 0;\n\t\t}\n\t\tskb = cxgb4_pktgl_to_skb(pgl, RX_PULL_LEN, RX_PULL_LEN);\n\t\tif (unlikely(!skb))\n\t\t\tgoto nomem;\n\t}\n\n\trpl = (struct cpl_act_establish *)skb->data;\n\topc = rpl->ot.opcode;\n\tlog_debug(1 << CXGBI_DBG_TOE,\n\t\t\"cdev %p, opcode 0x%x(0x%x,0x%x), skb %p.\\n\",\n\t\t cdev, opc, rpl->ot.opcode_tid, ntohl(rpl->ot.opcode_tid), skb);\n\tif (opc >= ARRAY_SIZE(cxgb4i_cplhandlers) || !cxgb4i_cplhandlers[opc]) {\n\t\tpr_err(\"No handler for opcode 0x%x.\\n\", opc);\n\t\t__kfree_skb(skb);\n\t} else\n\t\tcxgb4i_cplhandlers[opc](cdev, skb);\n\n\treturn 0;\nnomem:\n\tlog_debug(1 << CXGBI_DBG_TOE, \"OOM bailing out.\\n\");\n\treturn 1;\n}\n\nstatic int t4_uld_state_change(void *handle, enum cxgb4_state state)\n{\n\tstruct cxgbi_device *cdev = handle;\n\n\tswitch (state) {\n\tcase CXGB4_STATE_UP:\n\t\tpr_info(\"cdev 0x%p, UP.\\n\", cdev);\n\t\tbreak;\n\tcase CXGB4_STATE_START_RECOVERY:\n\t\tpr_info(\"cdev 0x%p, RECOVERY.\\n\", cdev);\n\t\t \n\t\tbreak;\n\tcase CXGB4_STATE_DOWN:\n\t\tpr_info(\"cdev 0x%p, DOWN.\\n\", cdev);\n\t\tbreak;\n\tcase CXGB4_STATE_DETACH:\n\t\tpr_info(\"cdev 0x%p, DETACH.\\n\", cdev);\n\t\tcxgbi_device_unregister(cdev);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"cdev 0x%p, unknown state %d.\\n\", cdev, state);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_CHELSIO_T4_DCB\nstatic int\ncxgb4_dcb_change_notify(struct notifier_block *self, unsigned long val,\n\t\t\tvoid *data)\n{\n\tint i, port = 0xFF;\n\tstruct net_device *ndev;\n\tstruct cxgbi_device *cdev = NULL;\n\tstruct dcb_app_type *iscsi_app = data;\n\tstruct cxgbi_ports_map *pmap;\n\tu8 priority;\n\n\tif (iscsi_app->dcbx & DCB_CAP_DCBX_VER_IEEE) {\n\t\tif ((iscsi_app->app.selector != IEEE_8021QAZ_APP_SEL_STREAM) &&\n\t\t    (iscsi_app->app.selector != IEEE_8021QAZ_APP_SEL_ANY))\n\t\t\treturn NOTIFY_DONE;\n\n\t\tpriority = iscsi_app->app.priority;\n\t} else if (iscsi_app->dcbx & DCB_CAP_DCBX_VER_CEE) {\n\t\tif (iscsi_app->app.selector != DCB_APP_IDTYPE_PORTNUM)\n\t\t\treturn NOTIFY_DONE;\n\n\t\tif (!iscsi_app->app.priority)\n\t\t\treturn NOTIFY_DONE;\n\n\t\tpriority = ffs(iscsi_app->app.priority) - 1;\n\t} else {\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tif (iscsi_app->app.protocol != 3260)\n\t\treturn NOTIFY_DONE;\n\n\tlog_debug(1 << CXGBI_DBG_ISCSI, \"iSCSI priority for ifid %d is %u\\n\",\n\t\t  iscsi_app->ifindex, priority);\n\n\tndev = dev_get_by_index(&init_net, iscsi_app->ifindex);\n\tif (!ndev)\n\t\treturn NOTIFY_DONE;\n\n\tcdev = cxgbi_device_find_by_netdev_rcu(ndev, &port);\n\n\tdev_put(ndev);\n\tif (!cdev)\n\t\treturn NOTIFY_DONE;\n\n\tpmap = &cdev->pmap;\n\n\tfor (i = 0; i < pmap->used; i++) {\n\t\tif (pmap->port_csk[i]) {\n\t\t\tstruct cxgbi_sock *csk = pmap->port_csk[i];\n\n\t\t\tif (csk->dcb_priority != priority) {\n\t\t\t\tiscsi_conn_failure(csk->user_data,\n\t\t\t\t\t\t   ISCSI_ERR_CONN_FAILED);\n\t\t\t\tpr_info(\"Restarting iSCSI connection %p with \"\n\t\t\t\t\t\"priority %u->%u.\\n\", csk,\n\t\t\t\t\tcsk->dcb_priority, priority);\n\t\t\t}\n\t\t}\n\t}\n\treturn NOTIFY_OK;\n}\n#endif\n\nstatic int __init cxgb4i_init_module(void)\n{\n\tint rc;\n\n\tprintk(KERN_INFO \"%s\", version);\n\n\trc = cxgbi_iscsi_init(&cxgb4i_iscsi_transport, &cxgb4i_stt);\n\tif (rc < 0)\n\t\treturn rc;\n\tcxgb4_register_uld(CXGB4_ULD_ISCSI, &cxgb4i_uld_info);\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n\tpr_info(\"%s dcb enabled.\\n\", DRV_MODULE_NAME);\n\tregister_dcbevent_notifier(&cxgb4_dcb_change);\n#endif\n\treturn 0;\n}\n\nstatic void __exit cxgb4i_exit_module(void)\n{\n#ifdef CONFIG_CHELSIO_T4_DCB\n\tunregister_dcbevent_notifier(&cxgb4_dcb_change);\n#endif\n\tcxgb4_unregister_uld(CXGB4_ULD_ISCSI);\n\tcxgbi_device_unregister_all(CXGBI_FLAG_DEV_T4);\n\tcxgbi_iscsi_cleanup(&cxgb4i_iscsi_transport, &cxgb4i_stt);\n}\n\nmodule_init(cxgb4i_init_module);\nmodule_exit(cxgb4i_exit_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}