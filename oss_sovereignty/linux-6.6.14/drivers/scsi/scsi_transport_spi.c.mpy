{
  "module_name": "scsi_transport_spi.c",
  "hash_id": "6e10f214e538348ea1f9bcbedad56d5b0441e92e159770a4abd86b87a4b69858",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_transport_spi.c",
  "human_readable_source": "\n \n#include <linux/ctype.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/workqueue.h>\n#include <linux/blkdev.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <scsi/scsi.h>\n#include \"scsi_priv.h\"\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_spi.h>\n\n#define SPI_NUM_ATTRS 14\t \n#define SPI_OTHER_ATTRS 1\t \n#define SPI_HOST_ATTRS\t1\n\n#define SPI_MAX_ECHO_BUFFER_SIZE\t4096\n\n#define DV_LOOPS\t3\n#define DV_TIMEOUT\t(10*HZ)\n#define DV_RETRIES\t3\t \n\n \nenum {\n\tSPI_BLIST_NOIUS = (__force blist_flags_t)0x1,\n};\n\n \nstatic struct {\n\tchar *vendor;\n\tchar *model;\n\tblist_flags_t flags;\n} spi_static_device_list[] __initdata = {\n\t{\"HP\", \"Ultrium 3-SCSI\", SPI_BLIST_NOIUS },\n\t{\"IBM\", \"ULTRIUM-TD3\", SPI_BLIST_NOIUS },\n\t{NULL, NULL, 0}\n};\n\n \n#define spi_dv_in_progress(x) (((struct spi_transport_attrs *)&(x)->starget_data)->dv_in_progress)\n#define spi_dv_mutex(x) (((struct spi_transport_attrs *)&(x)->starget_data)->dv_mutex)\n\nstruct spi_internal {\n\tstruct scsi_transport_template t;\n\tstruct spi_function_template *f;\n};\n\n#define to_spi_internal(tmpl)\tcontainer_of(tmpl, struct spi_internal, t)\n\nstatic const int ppr_to_ps[] = {\n\t \n\t-1,\t\t\t \n\t-1,\t\t\t \n\t-1,\t\t\t \n\t-1,\t\t\t \n\t-1,\t\t\t \n\t-1,\t\t\t \n\t-1,\t\t\t \n\t 3125,\t\t\t \n\t 6250,\t\t\t \n\t12500,\t\t\t \n\t25000,\t\t\t \n\t30300,\t\t\t \n\t50000,\t\t\t \n};\n \n#define SPI_STATIC_PPR\t0x0c\n\nstatic int sprint_frac(char *dest, int value, int denom)\n{\n\tint frac = value % denom;\n\tint result = sprintf(dest, \"%d\", value / denom);\n\n\tif (frac == 0)\n\t\treturn result;\n\tdest[result++] = '.';\n\n\tdo {\n\t\tdenom /= 10;\n\t\tsprintf(dest + result, \"%d\", frac / denom);\n\t\tresult++;\n\t\tfrac %= denom;\n\t} while (frac);\n\n\tdest[result++] = '\\0';\n\treturn result;\n}\n\nstatic int spi_execute(struct scsi_device *sdev, const void *cmd,\n\t\t       enum req_op op, void *buffer, unsigned int bufflen,\n\t\t       struct scsi_sense_hdr *sshdr)\n{\n\tint i, result;\n\tstruct scsi_sense_hdr sshdr_tmp;\n\tblk_opf_t opf = op | REQ_FAILFAST_DEV | REQ_FAILFAST_TRANSPORT |\n\t\t\tREQ_FAILFAST_DRIVER;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.req_flags = BLK_MQ_REQ_PM,\n\t\t.sshdr = sshdr ? : &sshdr_tmp,\n\t};\n\n\tsshdr = exec_args.sshdr;\n\n\tfor(i = 0; i < DV_RETRIES; i++) {\n\t\t \n\t\tresult = scsi_execute_cmd(sdev, cmd, opf, buffer, bufflen,\n\t\t\t\t\t  DV_TIMEOUT, 1, &exec_args);\n\t\tif (result < 0 || !scsi_sense_valid(sshdr) ||\n\t\t    sshdr->sense_key != UNIT_ATTENTION)\n\t\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic struct {\n\tenum spi_signal_type\tvalue;\n\tchar\t\t\t*name;\n} signal_types[] = {\n\t{ SPI_SIGNAL_UNKNOWN, \"unknown\" },\n\t{ SPI_SIGNAL_SE, \"SE\" },\n\t{ SPI_SIGNAL_LVD, \"LVD\" },\n\t{ SPI_SIGNAL_HVD, \"HVD\" },\n};\n\nstatic inline const char *spi_signal_to_string(enum spi_signal_type type)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(signal_types); i++) {\n\t\tif (type == signal_types[i].value)\n\t\t\treturn signal_types[i].name;\n\t}\n\treturn NULL;\n}\nstatic inline enum spi_signal_type spi_signal_to_value(const char *name)\n{\n\tint i, len;\n\n\tfor (i = 0; i < ARRAY_SIZE(signal_types); i++) {\n\t\tlen =  strlen(signal_types[i].name);\n\t\tif (strncmp(name, signal_types[i].name, len) == 0 &&\n\t\t    (name[len] == '\\n' || name[len] == '\\0'))\n\t\t\treturn signal_types[i].value;\n\t}\n\treturn SPI_SIGNAL_UNKNOWN;\n}\n\nstatic int spi_host_setup(struct transport_container *tc, struct device *dev,\n\t\t\t  struct device *cdev)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(dev);\n\n\tspi_signalling(shost) = SPI_SIGNAL_UNKNOWN;\n\n\treturn 0;\n}\n\nstatic int spi_host_configure(struct transport_container *tc,\n\t\t\t      struct device *dev,\n\t\t\t      struct device *cdev);\n\nstatic DECLARE_TRANSPORT_CLASS(spi_host_class,\n\t\t\t       \"spi_host\",\n\t\t\t       spi_host_setup,\n\t\t\t       NULL,\n\t\t\t       spi_host_configure);\n\nstatic int spi_host_match(struct attribute_container *cont,\n\t\t\t  struct device *dev)\n{\n\tstruct Scsi_Host *shost;\n\n\tif (!scsi_is_host_device(dev))\n\t\treturn 0;\n\n\tshost = dev_to_shost(dev);\n\tif (!shost->transportt  || shost->transportt->host_attrs.ac.class\n\t    != &spi_host_class.class)\n\t\treturn 0;\n\n\treturn &shost->transportt->host_attrs.ac == cont;\n}\n\nstatic int spi_target_configure(struct transport_container *tc,\n\t\t\t\tstruct device *dev,\n\t\t\t\tstruct device *cdev);\n\nstatic int spi_device_configure(struct transport_container *tc,\n\t\t\t\tstruct device *dev,\n\t\t\t\tstruct device *cdev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct scsi_target *starget = sdev->sdev_target;\n\tblist_flags_t bflags;\n\n\tbflags = scsi_get_device_flags_keyed(sdev, &sdev->inquiry[8],\n\t\t\t\t\t     &sdev->inquiry[16],\n\t\t\t\t\t     SCSI_DEVINFO_SPI);\n\n\t \n\n\tspi_support_sync(starget) = scsi_device_sync(sdev);\n\tspi_support_wide(starget) = scsi_device_wide(sdev);\n\tspi_support_dt(starget) = scsi_device_dt(sdev);\n\tspi_support_dt_only(starget) = scsi_device_dt_only(sdev);\n\tspi_support_ius(starget) = scsi_device_ius(sdev);\n\tif (bflags & SPI_BLIST_NOIUS) {\n\t\tdev_info(dev, \"Information Units disabled by blacklist\\n\");\n\t\tspi_support_ius(starget) = 0;\n\t}\n\tspi_support_qas(starget) = scsi_device_qas(sdev);\n\n\treturn 0;\n}\n\nstatic int spi_setup_transport_attrs(struct transport_container *tc,\n\t\t\t\t     struct device *dev,\n\t\t\t\t     struct device *cdev)\n{\n\tstruct scsi_target *starget = to_scsi_target(dev);\n\n\tspi_period(starget) = -1;\t \n\tspi_min_period(starget) = 0;\n\tspi_offset(starget) = 0;\t \n\tspi_max_offset(starget) = 255;\n\tspi_width(starget) = 0;\t \n\tspi_max_width(starget) = 1;\n\tspi_iu(starget) = 0;\t \n\tspi_max_iu(starget) = 1;\n\tspi_dt(starget) = 0;\t \n\tspi_qas(starget) = 0;\n\tspi_max_qas(starget) = 1;\n\tspi_wr_flow(starget) = 0;\n\tspi_rd_strm(starget) = 0;\n\tspi_rti(starget) = 0;\n\tspi_pcomp_en(starget) = 0;\n\tspi_hold_mcs(starget) = 0;\n\tspi_dv_pending(starget) = 0;\n\tspi_dv_in_progress(starget) = 0;\n\tspi_initial_dv(starget) = 0;\n\tmutex_init(&spi_dv_mutex(starget));\n\n\treturn 0;\n}\n\n#define spi_transport_show_simple(field, format_string)\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_spi_transport_##field(struct device *dev, \t\t\t\\\n\t\t\t   struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct scsi_target *starget = transport_class_to_starget(dev);\t\\\n\tstruct spi_transport_attrs *tp;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ttp = (struct spi_transport_attrs *)&starget->starget_data;\t\\\n\treturn snprintf(buf, 20, format_string, tp->field);\t\t\\\n}\n\n#define spi_transport_store_simple(field, format_string)\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nstore_spi_transport_##field(struct device *dev, \t\t\t\\\n\t\t\t    struct device_attribute *attr, \t\t\\\n\t\t\t    const char *buf, size_t count)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint val;\t\t\t\t\t\t\t\\\n\tstruct scsi_target *starget = transport_class_to_starget(dev);\t\\\n\tstruct spi_transport_attrs *tp;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ttp = (struct spi_transport_attrs *)&starget->starget_data;\t\\\n\tval = simple_strtoul(buf, NULL, 0);\t\t\t\t\\\n\ttp->field = val;\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define spi_transport_show_function(field, format_string)\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_spi_transport_##field(struct device *dev, \t\t\t\\\n\t\t\t   struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct scsi_target *starget = transport_class_to_starget(dev);\t\\\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\t\\\n\tstruct spi_transport_attrs *tp;\t\t\t\t\t\\\n\tstruct spi_internal *i = to_spi_internal(shost->transportt);\t\\\n\ttp = (struct spi_transport_attrs *)&starget->starget_data;\t\\\n\tif (i->f->get_##field)\t\t\t\t\t\t\\\n\t\ti->f->get_##field(starget);\t\t\t\t\\\n\treturn snprintf(buf, 20, format_string, tp->field);\t\t\\\n}\n\n#define spi_transport_store_function(field, format_string)\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nstore_spi_transport_##field(struct device *dev, \t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    const char *buf, size_t count)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint val;\t\t\t\t\t\t\t\\\n\tstruct scsi_target *starget = transport_class_to_starget(dev);\t\\\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\t\\\n\tstruct spi_internal *i = to_spi_internal(shost->transportt);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!i->f->set_##field)\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\tval = simple_strtoul(buf, NULL, 0);\t\t\t\t\\\n\ti->f->set_##field(starget, val);\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define spi_transport_store_max(field, format_string)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nstore_spi_transport_##field(struct device *dev, \t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    const char *buf, size_t count)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint val;\t\t\t\t\t\t\t\\\n\tstruct scsi_target *starget = transport_class_to_starget(dev);\t\\\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\t\\\n\tstruct spi_internal *i = to_spi_internal(shost->transportt);\t\\\n\tstruct spi_transport_attrs *tp\t\t\t\t\t\\\n\t\t= (struct spi_transport_attrs *)&starget->starget_data;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!i->f->set_##field)\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\tval = simple_strtoul(buf, NULL, 0);\t\t\t\t\\\n\tif (val > tp->max_##field)\t\t\t\t\t\\\n\t\tval = tp->max_##field;\t\t\t\t\t\\\n\ti->f->set_##field(starget, val);\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define spi_transport_rd_attr(field, format_string)\t\t\t\\\n\tspi_transport_show_function(field, format_string)\t\t\\\n\tspi_transport_store_function(field, format_string)\t\t\\\nstatic DEVICE_ATTR(field, S_IRUGO,\t\t\t\t\\\n\t\t   show_spi_transport_##field,\t\t\t\\\n\t\t   store_spi_transport_##field);\n\n#define spi_transport_simple_attr(field, format_string)\t\t\t\\\n\tspi_transport_show_simple(field, format_string)\t\t\t\\\n\tspi_transport_store_simple(field, format_string)\t\t\\\nstatic DEVICE_ATTR(field, S_IRUGO,\t\t\t\t\\\n\t\t   show_spi_transport_##field,\t\t\t\\\n\t\t   store_spi_transport_##field);\n\n#define spi_transport_max_attr(field, format_string)\t\t\t\\\n\tspi_transport_show_function(field, format_string)\t\t\\\n\tspi_transport_store_max(field, format_string)\t\t\t\\\n\tspi_transport_simple_attr(max_##field, format_string)\t\t\\\nstatic DEVICE_ATTR(field, S_IRUGO,\t\t\t\t\\\n\t\t   show_spi_transport_##field,\t\t\t\\\n\t\t   store_spi_transport_##field);\n\n \nspi_transport_max_attr(offset, \"%d\\n\");\nspi_transport_max_attr(width, \"%d\\n\");\nspi_transport_max_attr(iu, \"%d\\n\");\nspi_transport_rd_attr(dt, \"%d\\n\");\nspi_transport_max_attr(qas, \"%d\\n\");\nspi_transport_rd_attr(wr_flow, \"%d\\n\");\nspi_transport_rd_attr(rd_strm, \"%d\\n\");\nspi_transport_rd_attr(rti, \"%d\\n\");\nspi_transport_rd_attr(pcomp_en, \"%d\\n\");\nspi_transport_rd_attr(hold_mcs, \"%d\\n\");\n\n \nstatic int child_iter(struct device *dev, void *data)\n{\n\tif (!scsi_is_sdev_device(dev))\n\t\treturn 0;\n\n\tspi_dv_device(to_scsi_device(dev));\n\treturn 1;\n}\n\nstatic ssize_t\nstore_spi_revalidate(struct device *dev, struct device_attribute *attr,\n\t\t     const char *buf, size_t count)\n{\n\tstruct scsi_target *starget = transport_class_to_starget(dev);\n\n\tdevice_for_each_child(&starget->dev, NULL, child_iter);\n\treturn count;\n}\nstatic DEVICE_ATTR(revalidate, S_IWUSR, NULL, store_spi_revalidate);\n\n \nstatic int period_to_str(char *buf, int period)\n{\n\tint len, picosec;\n\n\tif (period < 0 || period > 0xff) {\n\t\tpicosec = -1;\n\t} else if (period <= SPI_STATIC_PPR) {\n\t\tpicosec = ppr_to_ps[period];\n\t} else {\n\t\tpicosec = period * 4000;\n\t}\n\n\tif (picosec == -1) {\n\t\tlen = sprintf(buf, \"reserved\");\n\t} else {\n\t\tlen = sprint_frac(buf, picosec, 1000);\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t\nshow_spi_transport_period_helper(char *buf, int period)\n{\n\tint len = period_to_str(buf, period);\n\tbuf[len++] = '\\n';\n\tbuf[len] = '\\0';\n\treturn len;\n}\n\nstatic ssize_t\nstore_spi_transport_period_helper(struct device *dev, const char *buf,\n\t\t\t\t  size_t count, int *periodp)\n{\n\tint j, picosec, period = -1;\n\tchar *endp;\n\n\tpicosec = simple_strtoul(buf, &endp, 10) * 1000;\n\tif (*endp == '.') {\n\t\tint mult = 100;\n\t\tdo {\n\t\t\tendp++;\n\t\t\tif (!isdigit(*endp))\n\t\t\t\tbreak;\n\t\t\tpicosec += (*endp - '0') * mult;\n\t\t\tmult /= 10;\n\t\t} while (mult > 0);\n\t}\n\n\tfor (j = 0; j <= SPI_STATIC_PPR; j++) {\n\t\tif (ppr_to_ps[j] < picosec)\n\t\t\tcontinue;\n\t\tperiod = j;\n\t\tbreak;\n\t}\n\n\tif (period == -1)\n\t\tperiod = picosec / 4000;\n\n\tif (period > 0xff)\n\t\tperiod = 0xff;\n\n\t*periodp = period;\n\n\treturn count;\n}\n\nstatic ssize_t\nshow_spi_transport_period(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_target *starget = transport_class_to_starget(dev);\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct spi_internal *i = to_spi_internal(shost->transportt);\n\tstruct spi_transport_attrs *tp =\n\t\t(struct spi_transport_attrs *)&starget->starget_data;\n\n\tif (i->f->get_period)\n\t\ti->f->get_period(starget);\n\n\treturn show_spi_transport_period_helper(buf, tp->period);\n}\n\nstatic ssize_t\nstore_spi_transport_period(struct device *cdev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct scsi_target *starget = transport_class_to_starget(cdev);\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct spi_internal *i = to_spi_internal(shost->transportt);\n\tstruct spi_transport_attrs *tp =\n\t\t(struct spi_transport_attrs *)&starget->starget_data;\n\tint period, retval;\n\n\tif (!i->f->set_period)\n\t\treturn -EINVAL;\n\n\tretval = store_spi_transport_period_helper(cdev, buf, count, &period);\n\n\tif (period < tp->min_period)\n\t\tperiod = tp->min_period;\n\n\ti->f->set_period(starget, period);\n\n\treturn retval;\n}\n\nstatic DEVICE_ATTR(period, S_IRUGO,\n\t\t   show_spi_transport_period,\n\t\t   store_spi_transport_period);\n\nstatic ssize_t\nshow_spi_transport_min_period(struct device *cdev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_target *starget = transport_class_to_starget(cdev);\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct spi_internal *i = to_spi_internal(shost->transportt);\n\tstruct spi_transport_attrs *tp =\n\t\t(struct spi_transport_attrs *)&starget->starget_data;\n\n\tif (!i->f->set_period)\n\t\treturn -EINVAL;\n\n\treturn show_spi_transport_period_helper(buf, tp->min_period);\n}\n\nstatic ssize_t\nstore_spi_transport_min_period(struct device *cdev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct scsi_target *starget = transport_class_to_starget(cdev);\n\tstruct spi_transport_attrs *tp =\n\t\t(struct spi_transport_attrs *)&starget->starget_data;\n\n\treturn store_spi_transport_period_helper(cdev, buf, count,\n\t\t\t\t\t\t &tp->min_period);\n}\n\n\nstatic DEVICE_ATTR(min_period, S_IRUGO,\n\t\t   show_spi_transport_min_period,\n\t\t   store_spi_transport_min_period);\n\n\nstatic ssize_t show_spi_host_signalling(struct device *cdev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(cdev);\n\tstruct spi_internal *i = to_spi_internal(shost->transportt);\n\n\tif (i->f->get_signalling)\n\t\ti->f->get_signalling(shost);\n\n\treturn sprintf(buf, \"%s\\n\", spi_signal_to_string(spi_signalling(shost)));\n}\nstatic ssize_t store_spi_host_signalling(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\n\tstruct spi_internal *i = to_spi_internal(shost->transportt);\n\tenum spi_signal_type type = spi_signal_to_value(buf);\n\n\tif (!i->f->set_signalling)\n\t\treturn -EINVAL;\n\n\tif (type != SPI_SIGNAL_UNKNOWN)\n\t\ti->f->set_signalling(shost, type);\n\n\treturn count;\n}\nstatic DEVICE_ATTR(signalling, S_IRUGO,\n\t\t   show_spi_host_signalling,\n\t\t   store_spi_host_signalling);\n\nstatic ssize_t show_spi_host_width(struct device *cdev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(cdev);\n\n\treturn sprintf(buf, \"%s\\n\", shost->max_id == 16 ? \"wide\" : \"narrow\");\n}\nstatic DEVICE_ATTR(host_width, S_IRUGO,\n\t\t   show_spi_host_width, NULL);\n\nstatic ssize_t show_spi_host_hba_id(struct device *cdev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(cdev);\n\n\treturn sprintf(buf, \"%d\\n\", shost->this_id);\n}\nstatic DEVICE_ATTR(hba_id, S_IRUGO,\n\t\t   show_spi_host_hba_id, NULL);\n\n#define DV_SET(x, y)\t\t\t\\\n\tif(i->f->set_##x)\t\t\\\n\t\ti->f->set_##x(sdev->sdev_target, y)\n\nenum spi_compare_returns {\n\tSPI_COMPARE_SUCCESS,\n\tSPI_COMPARE_FAILURE,\n\tSPI_COMPARE_SKIP_TEST,\n};\n\n\n \nstatic enum spi_compare_returns\nspi_dv_device_echo_buffer(struct scsi_device *sdev, u8 *buffer,\n\t\t\t  u8 *ptr, const int retries)\n{\n\tint len = ptr - buffer;\n\tint j, k, r, result;\n\tunsigned int pattern = 0x0000ffff;\n\tstruct scsi_sense_hdr sshdr;\n\n\tconst char spi_write_buffer[] = {\n\t\tWRITE_BUFFER, 0x0a, 0, 0, 0, 0, 0, len >> 8, len & 0xff, 0\n\t};\n\tconst char spi_read_buffer[] = {\n\t\tREAD_BUFFER, 0x0a, 0, 0, 0, 0, 0, len >> 8, len & 0xff, 0\n\t};\n\n\t \n\tfor (j = 0; j < len; ) {\n\n\t\t \n\t\tfor ( ; j < min(len, 32); j++)\n\t\t\tbuffer[j] = j;\n\t\tk = j;\n\t\t \n\t\tfor ( ; j < min(len, k + 32); j += 2) {\n\t\t\tu16 *word = (u16 *)&buffer[j];\n\t\t\t\n\t\t\t*word = (j & 0x02) ? 0x0000 : 0xffff;\n\t\t}\n\t\tk = j;\n\t\t \n\t\tfor ( ; j < min(len, k + 32); j += 2) {\n\t\t\tu16 *word = (u16 *)&buffer[j];\n\n\t\t\t*word = (j & 0x02) ? 0x5555 : 0xaaaa;\n\t\t}\n\t\tk = j;\n\t\t \n\t\tfor ( ; j < min(len, k + 32); j += 4) {\n\t\t\tu32 *word = (unsigned int *)&buffer[j];\n\t\t\tu32 roll = (pattern & 0x80000000) ? 1 : 0;\n\t\t\t\n\t\t\t*word = pattern;\n\t\t\tpattern = (pattern << 1) | roll;\n\t\t}\n\t\t \n\t}\n\n\tfor (r = 0; r < retries; r++) {\n\t\tresult = spi_execute(sdev, spi_write_buffer, REQ_OP_DRV_OUT,\n\t\t\t\t     buffer, len, &sshdr);\n\t\tif(result || !scsi_device_online(sdev)) {\n\n\t\t\tscsi_device_set_state(sdev, SDEV_QUIESCE);\n\t\t\tif (scsi_sense_valid(&sshdr)\n\t\t\t    && sshdr.sense_key == ILLEGAL_REQUEST\n\t\t\t     \n\t\t\t    && sshdr.asc == 0x24 && sshdr.ascq == 0x00)\n\t\t\t\t \n\t\t\t\treturn SPI_COMPARE_SKIP_TEST;\n\n\n\t\t\tsdev_printk(KERN_ERR, sdev, \"Write Buffer failure %x\\n\", result);\n\t\t\treturn SPI_COMPARE_FAILURE;\n\t\t}\n\n\t\tmemset(ptr, 0, len);\n\t\tspi_execute(sdev, spi_read_buffer, REQ_OP_DRV_IN,\n\t\t\t    ptr, len, NULL);\n\t\tscsi_device_set_state(sdev, SDEV_QUIESCE);\n\n\t\tif (memcmp(buffer, ptr, len) != 0)\n\t\t\treturn SPI_COMPARE_FAILURE;\n\t}\n\treturn SPI_COMPARE_SUCCESS;\n}\n\n \nstatic enum spi_compare_returns\nspi_dv_device_compare_inquiry(struct scsi_device *sdev, u8 *buffer,\n\t\t\t      u8 *ptr, const int retries)\n{\n\tint r, result;\n\tconst int len = sdev->inquiry_len;\n\tconst char spi_inquiry[] = {\n\t\tINQUIRY, 0, 0, 0, len, 0\n\t};\n\n\tfor (r = 0; r < retries; r++) {\n\t\tmemset(ptr, 0, len);\n\n\t\tresult = spi_execute(sdev, spi_inquiry, REQ_OP_DRV_IN,\n\t\t\t\t     ptr, len, NULL);\n\t\t\n\t\tif(result || !scsi_device_online(sdev)) {\n\t\t\tscsi_device_set_state(sdev, SDEV_QUIESCE);\n\t\t\treturn SPI_COMPARE_FAILURE;\n\t\t}\n\n\t\t \n\t\tif (ptr == buffer) {\n\t\t\tptr += len;\n\t\t\t--r;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (memcmp(buffer, ptr, len) != 0)\n\t\t\t \n\t\t\treturn SPI_COMPARE_FAILURE;\n\t}\n\treturn SPI_COMPARE_SUCCESS;\n}\n\nstatic enum spi_compare_returns\nspi_dv_retrain(struct scsi_device *sdev, u8 *buffer, u8 *ptr,\n\t       enum spi_compare_returns \n\t       (*compare_fn)(struct scsi_device *, u8 *, u8 *, int))\n{\n\tstruct spi_internal *i = to_spi_internal(sdev->host->transportt);\n\tstruct scsi_target *starget = sdev->sdev_target;\n\tint period = 0, prevperiod = 0; \n\tenum spi_compare_returns retval;\n\n\n\tfor (;;) {\n\t\tint newperiod;\n\t\tretval = compare_fn(sdev, buffer, ptr, DV_LOOPS);\n\n\t\tif (retval == SPI_COMPARE_SUCCESS\n\t\t    || retval == SPI_COMPARE_SKIP_TEST)\n\t\t\tbreak;\n\n\t\t \n\t\tif (i->f->get_iu)\n\t\t\ti->f->get_iu(starget);\n\t\tif (i->f->get_qas)\n\t\t\ti->f->get_qas(starget);\n\t\tif (i->f->get_period)\n\t\t\ti->f->get_period(sdev->sdev_target);\n\n\t\t \n\t\tif (i->f->set_iu && spi_iu(starget)) {\n\t\t\tstarget_printk(KERN_ERR, starget, \"Domain Validation Disabling Information Units\\n\");\n\t\t\tDV_SET(iu, 0);\n\t\t} else if (i->f->set_qas && spi_qas(starget)) {\n\t\t\tstarget_printk(KERN_ERR, starget, \"Domain Validation Disabling Quick Arbitration and Selection\\n\");\n\t\t\tDV_SET(qas, 0);\n\t\t} else {\n\t\t\tnewperiod = spi_period(starget);\n\t\t\tperiod = newperiod > period ? newperiod : period;\n\t\t\tif (period < 0x0d)\n\t\t\t\tperiod++;\n\t\t\telse\n\t\t\t\tperiod += period >> 1;\n\n\t\t\tif (unlikely(period > 0xff || period == prevperiod)) {\n\t\t\t\t \n\t\t\t\tstarget_printk(KERN_ERR, starget, \"Domain Validation Failure, dropping back to Asynchronous\\n\");\n\t\t\t\tDV_SET(offset, 0);\n\t\t\t\treturn SPI_COMPARE_FAILURE;\n\t\t\t}\n\t\t\tstarget_printk(KERN_ERR, starget, \"Domain Validation detected failure, dropping back\\n\");\n\t\t\tDV_SET(period, period);\n\t\t\tprevperiod = period;\n\t\t}\n\t}\n\treturn retval;\n}\n\nstatic int\nspi_dv_device_get_echo_buffer(struct scsi_device *sdev, u8 *buffer)\n{\n\tint l, result;\n\n\t \n\t\n\tstatic const char spi_test_unit_ready[] = {\n\t\tTEST_UNIT_READY, 0, 0, 0, 0, 0\n\t};\n\n\tstatic const char spi_read_buffer_descriptor[] = {\n\t\tREAD_BUFFER, 0x0b, 0, 0, 0, 0, 0, 0, 4, 0\n\t};\n\n\t\n\t \n\tfor (l = 0; ; l++) {\n\t\tresult = spi_execute(sdev, spi_test_unit_ready, REQ_OP_DRV_IN,\n\t\t\t\t     NULL, 0, NULL);\n\n\t\tif(result) {\n\t\t\tif(l >= 3)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tresult = spi_execute(sdev, spi_read_buffer_descriptor, \n\t\t\t     REQ_OP_DRV_IN, buffer, 4, NULL);\n\n\tif (result)\n\t\t \n\t\treturn 0;\n\n\treturn buffer[3] + ((buffer[2] & 0x1f) << 8);\n}\n\nstatic void\nspi_dv_device_internal(struct scsi_device *sdev, u8 *buffer)\n{\n\tstruct spi_internal *i = to_spi_internal(sdev->host->transportt);\n\tstruct scsi_target *starget = sdev->sdev_target;\n\tstruct Scsi_Host *shost = sdev->host;\n\tint len = sdev->inquiry_len;\n\tint min_period = spi_min_period(starget);\n\tint max_width = spi_max_width(starget);\n\t \n\tDV_SET(offset, 0);\n\tDV_SET(width, 0);\n\n\tif (spi_dv_device_compare_inquiry(sdev, buffer, buffer, DV_LOOPS)\n\t    != SPI_COMPARE_SUCCESS) {\n\t\tstarget_printk(KERN_ERR, starget, \"Domain Validation Initial Inquiry Failed\\n\");\n\t\t \n\t\treturn;\n\t}\n\n\tif (!spi_support_wide(starget)) {\n\t\tspi_max_width(starget) = 0;\n\t\tmax_width = 0;\n\t}\n\n\t \n\tif (i->f->set_width && max_width) {\n\t\ti->f->set_width(starget, 1);\n\n\t\tif (spi_dv_device_compare_inquiry(sdev, buffer,\n\t\t\t\t\t\t   buffer + len,\n\t\t\t\t\t\t   DV_LOOPS)\n\t\t    != SPI_COMPARE_SUCCESS) {\n\t\t\tstarget_printk(KERN_ERR, starget, \"Wide Transfers Fail\\n\");\n\t\t\ti->f->set_width(starget, 0);\n\t\t\t \n\t\t\tmax_width = 0;\n\t\t\tif (min_period < 10)\n\t\t\t\tmin_period = 10;\n\t\t}\n\t}\n\n\tif (!i->f->set_period)\n\t\treturn;\n\n\t \n\tif (!spi_support_sync(starget) && !spi_support_dt(starget))\n\t\treturn;\n\n\t \n\tlen = -1;\n\n retry:\n\n\t \n\tDV_SET(offset, spi_max_offset(starget));\n\tDV_SET(period, min_period);\n\n\t \n\tif (spi_support_qas(starget) && spi_max_qas(starget)) {\n\t\tDV_SET(qas, 1);\n\t} else {\n\t\tDV_SET(qas, 0);\n\t}\n\n\tif (spi_support_ius(starget) && spi_max_iu(starget) &&\n\t    min_period < 9) {\n\t\t \n\t\tDV_SET(iu, 1);\n\t\t \n\t\tDV_SET(rd_strm, 1);\n\t\tDV_SET(wr_flow, 1);\n\t\tDV_SET(rti, 1);\n\t\tif (min_period == 8)\n\t\t\tDV_SET(pcomp_en, 1);\n\t} else {\n\t\tDV_SET(iu, 0);\n\t}\n\n\t \n\tif (i->f->get_signalling)\n\t\ti->f->get_signalling(shost);\n\tif (spi_signalling(shost) == SPI_SIGNAL_SE ||\n\t    spi_signalling(shost) == SPI_SIGNAL_HVD ||\n\t    !spi_support_dt(starget)) {\n\t\tDV_SET(dt, 0);\n\t} else {\n\t\tDV_SET(dt, 1);\n\t}\n\t \n\tDV_SET(width, max_width);\n\n\t \n\tspi_dv_retrain(sdev, buffer, buffer + sdev->inquiry_len,\n\t\t       spi_dv_device_compare_inquiry);\n\t \n\tif (i->f->get_dt)\n\t\ti->f->get_dt(starget);\n\n\t \n\n\tif (len == -1 && spi_dt(starget))\n\t\tlen = spi_dv_device_get_echo_buffer(sdev, buffer);\n\n\tif (len <= 0) {\n\t\tstarget_printk(KERN_INFO, starget, \"Domain Validation skipping write tests\\n\");\n\t\treturn;\n\t}\n\n\tif (len > SPI_MAX_ECHO_BUFFER_SIZE) {\n\t\tstarget_printk(KERN_WARNING, starget, \"Echo buffer size %d is too big, trimming to %d\\n\", len, SPI_MAX_ECHO_BUFFER_SIZE);\n\t\tlen = SPI_MAX_ECHO_BUFFER_SIZE;\n\t}\n\n\tif (spi_dv_retrain(sdev, buffer, buffer + len,\n\t\t\t   spi_dv_device_echo_buffer)\n\t    == SPI_COMPARE_SKIP_TEST) {\n\t\t \n\t\tlen = 0;\n\t\tgoto retry;\n\t}\n}\n\n\n \nvoid\nspi_dv_device(struct scsi_device *sdev)\n{\n\tstruct scsi_target *starget = sdev->sdev_target;\n\tconst int len = SPI_MAX_ECHO_BUFFER_SIZE*2;\n\tunsigned int sleep_flags;\n\tu8 *buffer;\n\n\t \n\tsleep_flags = lock_system_sleep();\n\n\tif (scsi_autopm_get_device(sdev))\n\t\tgoto unlock_system_sleep;\n\n\tif (unlikely(spi_dv_in_progress(starget)))\n\t\tgoto put_autopm;\n\n\tif (unlikely(scsi_device_get(sdev)))\n\t\tgoto put_autopm;\n\n\tspi_dv_in_progress(starget) = 1;\n\n\tbuffer = kzalloc(len, GFP_KERNEL);\n\n\tif (unlikely(!buffer))\n\t\tgoto put_sdev;\n\n\t \n\tif (unlikely(scsi_device_quiesce(sdev)))\n\t\tgoto free_buffer;\n\n\tscsi_target_quiesce(starget);\n\n\tspi_dv_pending(starget) = 1;\n\tmutex_lock(&spi_dv_mutex(starget));\n\n\tstarget_printk(KERN_INFO, starget, \"Beginning Domain Validation\\n\");\n\n\tspi_dv_device_internal(sdev, buffer);\n\n\tstarget_printk(KERN_INFO, starget, \"Ending Domain Validation\\n\");\n\n\tmutex_unlock(&spi_dv_mutex(starget));\n\tspi_dv_pending(starget) = 0;\n\n\tscsi_target_resume(starget);\n\n\tspi_initial_dv(starget) = 1;\n\nfree_buffer:\n\tkfree(buffer);\n\nput_sdev:\n\tspi_dv_in_progress(starget) = 0;\n\tscsi_device_put(sdev);\nput_autopm:\n\tscsi_autopm_put_device(sdev);\n\nunlock_system_sleep:\n\tunlock_system_sleep(sleep_flags);\n}\nEXPORT_SYMBOL(spi_dv_device);\n\nstruct work_queue_wrapper {\n\tstruct work_struct\twork;\n\tstruct scsi_device\t*sdev;\n};\n\nstatic void\nspi_dv_device_work_wrapper(struct work_struct *work)\n{\n\tstruct work_queue_wrapper *wqw =\n\t\tcontainer_of(work, struct work_queue_wrapper, work);\n\tstruct scsi_device *sdev = wqw->sdev;\n\n\tkfree(wqw);\n\tspi_dv_device(sdev);\n\tspi_dv_pending(sdev->sdev_target) = 0;\n\tscsi_device_put(sdev);\n}\n\n\n \nvoid\nspi_schedule_dv_device(struct scsi_device *sdev)\n{\n\tstruct work_queue_wrapper *wqw =\n\t\tkmalloc(sizeof(struct work_queue_wrapper), GFP_ATOMIC);\n\n\tif (unlikely(!wqw))\n\t\treturn;\n\n\tif (unlikely(spi_dv_pending(sdev->sdev_target))) {\n\t\tkfree(wqw);\n\t\treturn;\n\t}\n\t \n\tspi_dv_pending(sdev->sdev_target) = 1;\n\tif (unlikely(scsi_device_get(sdev))) {\n\t\tkfree(wqw);\n\t\tspi_dv_pending(sdev->sdev_target) = 0;\n\t\treturn;\n\t}\n\n\tINIT_WORK(&wqw->work, spi_dv_device_work_wrapper);\n\twqw->sdev = sdev;\n\n\tschedule_work(&wqw->work);\n}\nEXPORT_SYMBOL(spi_schedule_dv_device);\n\n \nvoid spi_display_xfer_agreement(struct scsi_target *starget)\n{\n\tstruct spi_transport_attrs *tp;\n\ttp = (struct spi_transport_attrs *)&starget->starget_data;\n\n\tif (tp->offset > 0 && tp->period > 0) {\n\t\tunsigned int picosec, kb100;\n\t\tchar *scsi = \"FAST-?\";\n\t\tchar tmp[8];\n\n\t\tif (tp->period <= SPI_STATIC_PPR) {\n\t\t\tpicosec = ppr_to_ps[tp->period];\n\t\t\tswitch (tp->period) {\n\t\t\t\tcase  7: scsi = \"FAST-320\"; break;\n\t\t\t\tcase  8: scsi = \"FAST-160\"; break;\n\t\t\t\tcase  9: scsi = \"FAST-80\"; break;\n\t\t\t\tcase 10:\n\t\t\t\tcase 11: scsi = \"FAST-40\"; break;\n\t\t\t\tcase 12: scsi = \"FAST-20\"; break;\n\t\t\t}\n\t\t} else {\n\t\t\tpicosec = tp->period * 4000;\n\t\t\tif (tp->period < 25)\n\t\t\t\tscsi = \"FAST-20\";\n\t\t\telse if (tp->period < 50)\n\t\t\t\tscsi = \"FAST-10\";\n\t\t\telse\n\t\t\t\tscsi = \"FAST-5\";\n\t\t}\n\n\t\tkb100 = (10000000 + picosec / 2) / picosec;\n\t\tif (tp->width)\n\t\t\tkb100 *= 2;\n\t\tsprint_frac(tmp, picosec, 1000);\n\n\t\tdev_info(&starget->dev,\n\t\t\t \"%s %sSCSI %d.%d MB/s %s%s%s%s%s%s%s%s (%s ns, offset %d)\\n\",\n\t\t\t scsi, tp->width ? \"WIDE \" : \"\", kb100/10, kb100 % 10,\n\t\t\t tp->dt ? \"DT\" : \"ST\",\n\t\t\t tp->iu ? \" IU\" : \"\",\n\t\t\t tp->qas  ? \" QAS\" : \"\",\n\t\t\t tp->rd_strm ? \" RDSTRM\" : \"\",\n\t\t\t tp->rti ? \" RTI\" : \"\",\n\t\t\t tp->wr_flow ? \" WRFLOW\" : \"\",\n\t\t\t tp->pcomp_en ? \" PCOMP\" : \"\",\n\t\t\t tp->hold_mcs ? \" HMCS\" : \"\",\n\t\t\t tmp, tp->offset);\n\t} else {\n\t\tdev_info(&starget->dev, \"%sasynchronous\\n\",\n\t\t\t\ttp->width ? \"wide \" : \"\");\n\t}\n}\nEXPORT_SYMBOL(spi_display_xfer_agreement);\n\nint spi_populate_width_msg(unsigned char *msg, int width)\n{\n\tmsg[0] = EXTENDED_MESSAGE;\n\tmsg[1] = 2;\n\tmsg[2] = EXTENDED_WDTR;\n\tmsg[3] = width;\n\treturn 4;\n}\nEXPORT_SYMBOL_GPL(spi_populate_width_msg);\n\nint spi_populate_sync_msg(unsigned char *msg, int period, int offset)\n{\n\tmsg[0] = EXTENDED_MESSAGE;\n\tmsg[1] = 3;\n\tmsg[2] = EXTENDED_SDTR;\n\tmsg[3] = period;\n\tmsg[4] = offset;\n\treturn 5;\n}\nEXPORT_SYMBOL_GPL(spi_populate_sync_msg);\n\nint spi_populate_ppr_msg(unsigned char *msg, int period, int offset,\n\t\tint width, int options)\n{\n\tmsg[0] = EXTENDED_MESSAGE;\n\tmsg[1] = 6;\n\tmsg[2] = EXTENDED_PPR;\n\tmsg[3] = period;\n\tmsg[4] = 0;\n\tmsg[5] = offset;\n\tmsg[6] = width;\n\tmsg[7] = options;\n\treturn 8;\n}\nEXPORT_SYMBOL_GPL(spi_populate_ppr_msg);\n\n \nint spi_populate_tag_msg(unsigned char *msg, struct scsi_cmnd *cmd)\n{\n        if (cmd->flags & SCMD_TAGGED) {\n\t\t*msg++ = SIMPLE_QUEUE_TAG;\n\t\t*msg++ = scsi_cmd_to_rq(cmd)->tag;\n        \treturn 2;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(spi_populate_tag_msg);\n\n#ifdef CONFIG_SCSI_CONSTANTS\nstatic const char * const one_byte_msgs[] = {\n  \"Task Complete\", NULL  , \"Save Pointers\",\n  \"Restore Pointers\", \"Disconnect\", \"Initiator Error\", \n  \"Abort Task Set\", \"Message Reject\", \"Nop\", \"Message Parity Error\",\n  \"Linked Command Complete\", \"Linked Command Complete w/flag\",\n  \"Target Reset\", \"Abort Task\", \"Clear Task Set\", \n  \"Initiate Recovery\", \"Release Recovery\",\n  \"Terminate Process\", \"Continue Task\", \"Target Transfer Disable\",\n  NULL, NULL, \"Clear ACA\", \"LUN Reset\"\n};\n\nstatic const char * const two_byte_msgs[] = {\n  \"Simple Queue Tag\", \"Head of Queue Tag\", \"Ordered Queue Tag\",\n  \"Ignore Wide Residue\", \"ACA\"\n};\n\nstatic const char * const extended_msgs[] = {\n  \"Modify Data Pointer\", \"Synchronous Data Transfer Request\",\n  \"SCSI-I Extended Identify\", \"Wide Data Transfer Request\",\n  \"Parallel Protocol Request\", \"Modify Bidirectional Data Pointer\"\n};\n\nstatic void print_nego(const unsigned char *msg, int per, int off, int width)\n{\n\tif (per) {\n\t\tchar buf[20];\n\t\tperiod_to_str(buf, msg[per]);\n\t\tprintk(\"period = %s ns \", buf);\n\t}\n\n\tif (off)\n\t\tprintk(\"offset = %d \", msg[off]);\n\tif (width)\n\t\tprintk(\"width = %d \", 8 << msg[width]);\n}\n\nstatic void print_ptr(const unsigned char *msg, int msb, const char *desc)\n{\n\tint ptr = (msg[msb] << 24) | (msg[msb+1] << 16) | (msg[msb+2] << 8) |\n\t\t\tmsg[msb+3];\n\tprintk(\"%s = %d \", desc, ptr);\n}\n\nint spi_print_msg(const unsigned char *msg)\n{\n\tint len = 1, i;\n\tif (msg[0] == EXTENDED_MESSAGE) {\n\t\tlen = 2 + msg[1];\n\t\tif (len == 2)\n\t\t\tlen += 256;\n\t\tif (msg[2] < ARRAY_SIZE(extended_msgs))\n\t\t\tprintk (\"%s \", extended_msgs[msg[2]]); \n\t\telse \n\t\t\tprintk (\"Extended Message, reserved code (0x%02x) \",\n\t\t\t\t(int) msg[2]);\n\t\tswitch (msg[2]) {\n\t\tcase EXTENDED_MODIFY_DATA_POINTER:\n\t\t\tprint_ptr(msg, 3, \"pointer\");\n\t\t\tbreak;\n\t\tcase EXTENDED_SDTR:\n\t\t\tprint_nego(msg, 3, 4, 0);\n\t\t\tbreak;\n\t\tcase EXTENDED_WDTR:\n\t\t\tprint_nego(msg, 0, 0, 3);\n\t\t\tbreak;\n\t\tcase EXTENDED_PPR:\n\t\t\tprint_nego(msg, 3, 5, 6);\n\t\t\tbreak;\n\t\tcase EXTENDED_MODIFY_BIDI_DATA_PTR:\n\t\t\tprint_ptr(msg, 3, \"out\");\n\t\t\tprint_ptr(msg, 7, \"in\");\n\t\t\tbreak;\n\t\tdefault:\n\t\tfor (i = 2; i < len; ++i) \n\t\t\tprintk(\"%02x \", msg[i]);\n\t\t}\n\t \n\t} else if (msg[0] & 0x80) {\n\t\tprintk(\"Identify disconnect %sallowed %s %d \",\n\t\t\t(msg[0] & 0x40) ? \"\" : \"not \",\n\t\t\t(msg[0] & 0x20) ? \"target routine\" : \"lun\",\n\t\t\tmsg[0] & 0x7);\n\t \n\t} else if (msg[0] < 0x1f) {\n\t\tif (msg[0] < ARRAY_SIZE(one_byte_msgs) && one_byte_msgs[msg[0]])\n\t\t\tprintk(\"%s \", one_byte_msgs[msg[0]]);\n\t\telse\n\t\t\tprintk(\"reserved (%02x) \", msg[0]);\n\t} else if (msg[0] == 0x55) {\n\t\tprintk(\"QAS Request \");\n\t \n\t} else if (msg[0] <= 0x2f) {\n\t\tif ((msg[0] - 0x20) < ARRAY_SIZE(two_byte_msgs))\n\t\t\tprintk(\"%s %02x \", two_byte_msgs[msg[0] - 0x20], \n\t\t\t\tmsg[1]);\n\t\telse \n\t\t\tprintk(\"reserved two byte (%02x %02x) \", \n\t\t\t\tmsg[0], msg[1]);\n\t\tlen = 2;\n\t} else \n\t\tprintk(\"reserved \");\n\treturn len;\n}\nEXPORT_SYMBOL(spi_print_msg);\n\n#else   \n\nint spi_print_msg(const unsigned char *msg)\n{\n\tint len = 1, i;\n\n\tif (msg[0] == EXTENDED_MESSAGE) {\n\t\tlen = 2 + msg[1];\n\t\tif (len == 2)\n\t\t\tlen += 256;\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tprintk(\"%02x \", msg[i]);\n\t \n\t} else if (msg[0] & 0x80) {\n\t\tprintk(\"%02x \", msg[0]);\n\t \n\t} else if ((msg[0] < 0x1f) || (msg[0] == 0x55)) {\n\t\tprintk(\"%02x \", msg[0]);\n\t \n\t} else if (msg[0] <= 0x2f) {\n\t\tprintk(\"%02x %02x\", msg[0], msg[1]);\n\t\tlen = 2;\n\t} else \n\t\tprintk(\"%02x \", msg[0]);\n\treturn len;\n}\nEXPORT_SYMBOL(spi_print_msg);\n#endif  \n\nstatic int spi_device_match(struct attribute_container *cont,\n\t\t\t    struct device *dev)\n{\n\tstruct scsi_device *sdev;\n\tstruct Scsi_Host *shost;\n\tstruct spi_internal *i;\n\n\tif (!scsi_is_sdev_device(dev))\n\t\treturn 0;\n\n\tsdev = to_scsi_device(dev);\n\tshost = sdev->host;\n\tif (!shost->transportt  || shost->transportt->host_attrs.ac.class\n\t    != &spi_host_class.class)\n\t\treturn 0;\n\t \n\ti = to_spi_internal(shost->transportt);\n\tif (i->f->deny_binding && i->f->deny_binding(sdev->sdev_target))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int spi_target_match(struct attribute_container *cont,\n\t\t\t    struct device *dev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct scsi_target *starget;\n\tstruct spi_internal *i;\n\n\tif (!scsi_is_target_device(dev))\n\t\treturn 0;\n\n\tshost = dev_to_shost(dev->parent);\n\tif (!shost->transportt  || shost->transportt->host_attrs.ac.class\n\t    != &spi_host_class.class)\n\t\treturn 0;\n\n\ti = to_spi_internal(shost->transportt);\n\tstarget = to_scsi_target(dev);\n\n\tif (i->f->deny_binding && i->f->deny_binding(starget))\n\t\treturn 0;\n\n\treturn &i->t.target_attrs.ac == cont;\n}\n\nstatic DECLARE_TRANSPORT_CLASS(spi_transport_class,\n\t\t\t       \"spi_transport\",\n\t\t\t       spi_setup_transport_attrs,\n\t\t\t       NULL,\n\t\t\t       spi_target_configure);\n\nstatic DECLARE_ANON_TRANSPORT_CLASS(spi_device_class,\n\t\t\t\t    spi_device_match,\n\t\t\t\t    spi_device_configure);\n\nstatic struct attribute *host_attributes[] = {\n\t&dev_attr_signalling.attr,\n\t&dev_attr_host_width.attr,\n\t&dev_attr_hba_id.attr,\n\tNULL\n};\n\nstatic struct attribute_group host_attribute_group = {\n\t.attrs = host_attributes,\n};\n\nstatic int spi_host_configure(struct transport_container *tc,\n\t\t\t      struct device *dev,\n\t\t\t      struct device *cdev)\n{\n\tstruct kobject *kobj = &cdev->kobj;\n\tstruct Scsi_Host *shost = transport_class_to_shost(cdev);\n\tstruct spi_internal *si = to_spi_internal(shost->transportt);\n\tstruct attribute *attr = &dev_attr_signalling.attr;\n\tint rc = 0;\n\n\tif (si->f->set_signalling)\n\t\trc = sysfs_chmod_file(kobj, attr, attr->mode | S_IWUSR);\n\n\treturn rc;\n}\n\n \n#define TARGET_ATTRIBUTE_HELPER(name) \\\n\t(si->f->show_##name ? S_IRUGO : 0) | \\\n\t(si->f->set_##name ? S_IWUSR : 0)\n\nstatic umode_t target_attribute_is_visible(struct kobject *kobj,\n\t\t\t\t\t  struct attribute *attr, int i)\n{\n\tstruct device *cdev = container_of(kobj, struct device, kobj);\n\tstruct scsi_target *starget = transport_class_to_starget(cdev);\n\tstruct Scsi_Host *shost = transport_class_to_shost(cdev);\n\tstruct spi_internal *si = to_spi_internal(shost->transportt);\n\n\tif (attr == &dev_attr_period.attr &&\n\t    spi_support_sync(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(period);\n\telse if (attr == &dev_attr_min_period.attr &&\n\t\t spi_support_sync(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(period);\n\telse if (attr == &dev_attr_offset.attr &&\n\t\t spi_support_sync(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(offset);\n\telse if (attr == &dev_attr_max_offset.attr &&\n\t\t spi_support_sync(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(offset);\n\telse if (attr == &dev_attr_width.attr &&\n\t\t spi_support_wide(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(width);\n\telse if (attr == &dev_attr_max_width.attr &&\n\t\t spi_support_wide(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(width);\n\telse if (attr == &dev_attr_iu.attr &&\n\t\t spi_support_ius(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(iu);\n\telse if (attr == &dev_attr_max_iu.attr &&\n\t\t spi_support_ius(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(iu);\n\telse if (attr == &dev_attr_dt.attr &&\n\t\t spi_support_dt(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(dt);\n\telse if (attr == &dev_attr_qas.attr &&\n\t\t spi_support_qas(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(qas);\n\telse if (attr == &dev_attr_max_qas.attr &&\n\t\t spi_support_qas(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(qas);\n\telse if (attr == &dev_attr_wr_flow.attr &&\n\t\t spi_support_ius(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(wr_flow);\n\telse if (attr == &dev_attr_rd_strm.attr &&\n\t\t spi_support_ius(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(rd_strm);\n\telse if (attr == &dev_attr_rti.attr &&\n\t\t spi_support_ius(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(rti);\n\telse if (attr == &dev_attr_pcomp_en.attr &&\n\t\t spi_support_ius(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(pcomp_en);\n\telse if (attr == &dev_attr_hold_mcs.attr &&\n\t\t spi_support_ius(starget))\n\t\treturn TARGET_ATTRIBUTE_HELPER(hold_mcs);\n\telse if (attr == &dev_attr_revalidate.attr)\n\t\treturn S_IWUSR;\n\n\treturn 0;\n}\n\nstatic struct attribute *target_attributes[] = {\n\t&dev_attr_period.attr,\n\t&dev_attr_min_period.attr,\n\t&dev_attr_offset.attr,\n\t&dev_attr_max_offset.attr,\n\t&dev_attr_width.attr,\n\t&dev_attr_max_width.attr,\n\t&dev_attr_iu.attr,\n\t&dev_attr_max_iu.attr,\n\t&dev_attr_dt.attr,\n\t&dev_attr_qas.attr,\n\t&dev_attr_max_qas.attr,\n\t&dev_attr_wr_flow.attr,\n\t&dev_attr_rd_strm.attr,\n\t&dev_attr_rti.attr,\n\t&dev_attr_pcomp_en.attr,\n\t&dev_attr_hold_mcs.attr,\n\t&dev_attr_revalidate.attr,\n\tNULL\n};\n\nstatic struct attribute_group target_attribute_group = {\n\t.attrs = target_attributes,\n\t.is_visible = target_attribute_is_visible,\n};\n\nstatic int spi_target_configure(struct transport_container *tc,\n\t\t\t\tstruct device *dev,\n\t\t\t\tstruct device *cdev)\n{\n\tstruct kobject *kobj = &cdev->kobj;\n\n\t \n\tsysfs_update_group(kobj, &target_attribute_group);\n\n\treturn 0;\n}\n\nstruct scsi_transport_template *\nspi_attach_transport(struct spi_function_template *ft)\n{\n\tstruct spi_internal *i = kzalloc(sizeof(struct spi_internal),\n\t\t\t\t\t GFP_KERNEL);\n\n\tif (unlikely(!i))\n\t\treturn NULL;\n\n\ti->t.target_attrs.ac.class = &spi_transport_class.class;\n\ti->t.target_attrs.ac.grp = &target_attribute_group;\n\ti->t.target_attrs.ac.match = spi_target_match;\n\ttransport_container_register(&i->t.target_attrs);\n\ti->t.target_size = sizeof(struct spi_transport_attrs);\n\ti->t.host_attrs.ac.class = &spi_host_class.class;\n\ti->t.host_attrs.ac.grp = &host_attribute_group;\n\ti->t.host_attrs.ac.match = spi_host_match;\n\ttransport_container_register(&i->t.host_attrs);\n\ti->t.host_size = sizeof(struct spi_host_attrs);\n\ti->f = ft;\n\n\treturn &i->t;\n}\nEXPORT_SYMBOL(spi_attach_transport);\n\nvoid spi_release_transport(struct scsi_transport_template *t)\n{\n\tstruct spi_internal *i = to_spi_internal(t);\n\n\ttransport_container_unregister(&i->t.target_attrs);\n\ttransport_container_unregister(&i->t.host_attrs);\n\n\tkfree(i);\n}\nEXPORT_SYMBOL(spi_release_transport);\n\nstatic __init int spi_transport_init(void)\n{\n\tint error = scsi_dev_info_add_list(SCSI_DEVINFO_SPI,\n\t\t\t\t\t   \"SCSI Parallel Transport Class\");\n\tif (!error) {\n\t\tint i;\n\n\t\tfor (i = 0; spi_static_device_list[i].vendor; i++)\n\t\t\tscsi_dev_info_list_add_keyed(1,\t \n\t\t\t\t\t\t     spi_static_device_list[i].vendor,\n\t\t\t\t\t\t     spi_static_device_list[i].model,\n\t\t\t\t\t\t     NULL,\n\t\t\t\t\t\t     spi_static_device_list[i].flags,\n\t\t\t\t\t\t     SCSI_DEVINFO_SPI);\n\t}\n\n\terror = transport_class_register(&spi_transport_class);\n\tif (error)\n\t\treturn error;\n\terror = anon_transport_class_register(&spi_device_class);\n\treturn transport_class_register(&spi_host_class);\n}\n\nstatic void __exit spi_transport_exit(void)\n{\n\ttransport_class_unregister(&spi_transport_class);\n\tanon_transport_class_unregister(&spi_device_class);\n\ttransport_class_unregister(&spi_host_class);\n\tscsi_dev_info_remove_list(SCSI_DEVINFO_SPI);\n}\n\nMODULE_AUTHOR(\"Martin Hicks\");\nMODULE_DESCRIPTION(\"SPI Transport Attributes\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(spi_transport_init);\nmodule_exit(spi_transport_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}