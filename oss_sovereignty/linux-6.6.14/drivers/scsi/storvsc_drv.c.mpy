{
  "module_name": "storvsc_drv.c",
  "hash_id": "1b468cbfa9020f88ec9929b6fce099e02bf88f05422efa8a9b37bf36e11fb2cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/storvsc_drv.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/completion.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/hyperv.h>\n#include <linux/blkdev.h>\n#include <linux/dma-mapping.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_devinfo.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/scsi_transport.h>\n\n \n\n \n\n#define VMSTOR_PROTO_VERSION(MAJOR_, MINOR_)\t((((MAJOR_) & 0xff) << 8) | \\\n\t\t\t\t\t\t(((MINOR_) & 0xff)))\n#define VMSTOR_PROTO_VERSION_WIN6\tVMSTOR_PROTO_VERSION(2, 0)\n#define VMSTOR_PROTO_VERSION_WIN7\tVMSTOR_PROTO_VERSION(4, 2)\n#define VMSTOR_PROTO_VERSION_WIN8\tVMSTOR_PROTO_VERSION(5, 1)\n#define VMSTOR_PROTO_VERSION_WIN8_1\tVMSTOR_PROTO_VERSION(6, 0)\n#define VMSTOR_PROTO_VERSION_WIN10\tVMSTOR_PROTO_VERSION(6, 2)\n\n \n#define CALLBACK_TIMEOUT               2\n\n \nenum vstor_packet_operation {\n\tVSTOR_OPERATION_COMPLETE_IO\t\t= 1,\n\tVSTOR_OPERATION_REMOVE_DEVICE\t\t= 2,\n\tVSTOR_OPERATION_EXECUTE_SRB\t\t= 3,\n\tVSTOR_OPERATION_RESET_LUN\t\t= 4,\n\tVSTOR_OPERATION_RESET_ADAPTER\t\t= 5,\n\tVSTOR_OPERATION_RESET_BUS\t\t= 6,\n\tVSTOR_OPERATION_BEGIN_INITIALIZATION\t= 7,\n\tVSTOR_OPERATION_END_INITIALIZATION\t= 8,\n\tVSTOR_OPERATION_QUERY_PROTOCOL_VERSION\t= 9,\n\tVSTOR_OPERATION_QUERY_PROPERTIES\t= 10,\n\tVSTOR_OPERATION_ENUMERATE_BUS\t\t= 11,\n\tVSTOR_OPERATION_FCHBA_DATA              = 12,\n\tVSTOR_OPERATION_CREATE_SUB_CHANNELS     = 13,\n\tVSTOR_OPERATION_MAXIMUM                 = 13\n};\n\n \n\nstruct hv_fc_wwn_packet {\n\tu8\tprimary_active;\n\tu8\treserved1[3];\n\tu8\tprimary_port_wwn[8];\n\tu8\tprimary_node_wwn[8];\n\tu8\tsecondary_port_wwn[8];\n\tu8\tsecondary_node_wwn[8];\n};\n\n\n\n \n\n#define SRB_FLAGS_QUEUE_ACTION_ENABLE\t\t0x00000002\n#define SRB_FLAGS_DISABLE_DISCONNECT\t\t0x00000004\n#define SRB_FLAGS_DISABLE_SYNCH_TRANSFER\t0x00000008\n#define SRB_FLAGS_BYPASS_FROZEN_QUEUE\t\t0x00000010\n#define SRB_FLAGS_DISABLE_AUTOSENSE\t\t0x00000020\n#define SRB_FLAGS_DATA_IN\t\t\t0x00000040\n#define SRB_FLAGS_DATA_OUT\t\t\t0x00000080\n#define SRB_FLAGS_NO_DATA_TRANSFER\t\t0x00000000\n#define SRB_FLAGS_UNSPECIFIED_DIRECTION\t(SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)\n#define SRB_FLAGS_NO_QUEUE_FREEZE\t\t0x00000100\n#define SRB_FLAGS_ADAPTER_CACHE_ENABLE\t\t0x00000200\n#define SRB_FLAGS_FREE_SENSE_BUFFER\t\t0x00000400\n\n \n#define SRB_FLAGS_D3_PROCESSING\t\t\t0x00000800\n#define SRB_FLAGS_IS_ACTIVE\t\t\t0x00010000\n#define SRB_FLAGS_ALLOCATED_FROM_ZONE\t\t0x00020000\n#define SRB_FLAGS_SGLIST_FROM_POOL\t\t0x00040000\n#define SRB_FLAGS_BYPASS_LOCKED_QUEUE\t\t0x00080000\n#define SRB_FLAGS_NO_KEEP_AWAKE\t\t\t0x00100000\n#define SRB_FLAGS_PORT_DRIVER_ALLOCSENSE\t0x00200000\n#define SRB_FLAGS_PORT_DRIVER_SENSEHASPORT\t0x00400000\n#define SRB_FLAGS_DONT_START_NEXT_PACKET\t0x00800000\n#define SRB_FLAGS_PORT_DRIVER_RESERVED\t\t0x0F000000\n#define SRB_FLAGS_CLASS_DRIVER_RESERVED\t\t0xF0000000\n\n#define SP_UNTAGGED\t\t\t((unsigned char) ~0)\n#define SRB_SIMPLE_TAG_REQUEST\t\t0x20\n\n \n#define STORVSC_MAX_CMD_LEN\t\t\t0x10\n\n \n#define STORVSC_SENSE_BUFFER_SIZE\t\t0x14\n#define STORVSC_MAX_BUF_LEN_WITH_PADDING\t0x14\n\n \nstatic int vmstor_proto_version;\n\n#define STORVSC_LOGGING_NONE\t0\n#define STORVSC_LOGGING_ERROR\t1\n#define STORVSC_LOGGING_WARN\t2\n\nstatic int logging_level = STORVSC_LOGGING_ERROR;\nmodule_param(logging_level, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(logging_level,\n\t\"Logging level, 0 - None, 1 - Error (default), 2 - Warning.\");\n\nstatic inline bool do_logging(int level)\n{\n\treturn logging_level >= level;\n}\n\n#define storvsc_log(dev, level, fmt, ...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (do_logging(level))\t\t\t\t\t\\\n\t\tdev_warn(&(dev)->device, fmt, ##__VA_ARGS__);\t\\\n} while (0)\n\nstruct vmscsi_request {\n\tu16 length;\n\tu8 srb_status;\n\tu8 scsi_status;\n\n\tu8  port_number;\n\tu8  path_id;\n\tu8  target_id;\n\tu8  lun;\n\n\tu8  cdb_length;\n\tu8  sense_info_length;\n\tu8  data_in;\n\tu8  reserved;\n\n\tu32 data_transfer_length;\n\n\tunion {\n\t\tu8 cdb[STORVSC_MAX_CMD_LEN];\n\t\tu8 sense_data[STORVSC_SENSE_BUFFER_SIZE];\n\t\tu8 reserved_array[STORVSC_MAX_BUF_LEN_WITH_PADDING];\n\t};\n\t \n\tu16 reserve;\n\tu8  queue_tag;\n\tu8  queue_action;\n\tu32 srb_flags;\n\tu32 time_out_value;\n\tu32 queue_sort_ey;\n\n} __attribute((packed));\n\n \n\nstatic const int protocol_version[] = {\n\t\tVMSTOR_PROTO_VERSION_WIN10,\n\t\tVMSTOR_PROTO_VERSION_WIN8_1,\n\t\tVMSTOR_PROTO_VERSION_WIN8,\n};\n\n\n \n\n#define STORAGE_CHANNEL_SUPPORTS_MULTI_CHANNEL\t\t0x1\n\nstruct vmstorage_channel_properties {\n\tu32 reserved;\n\tu16 max_channel_cnt;\n\tu16 reserved1;\n\n\tu32 flags;\n\tu32   max_transfer_bytes;\n\n\tu64  reserved2;\n} __packed;\n\n \nstruct vmstorage_protocol_version {\n\t \n\tu16 major_minor;\n\n\t \n\tu16 revision;\n} __packed;\n\n \n#define STORAGE_CHANNEL_REMOVABLE_FLAG\t\t0x1\n#define STORAGE_CHANNEL_EMULATED_IDE_FLAG\t0x2\n\nstruct vstor_packet {\n\t \n\tenum vstor_packet_operation operation;\n\n\t \n\tu32 flags;\n\n\t \n\tu32 status;\n\n\t \n\tunion {\n\t\t \n\t\tstruct vmscsi_request vm_srb;\n\n\t\t \n\t\tstruct vmstorage_channel_properties storage_channel_properties;\n\n\t\t \n\t\tstruct vmstorage_protocol_version version;\n\n\t\t \n\t\tstruct hv_fc_wwn_packet wwn_packet;\n\n\t\t \n\t\tu16 sub_channel_count;\n\n\t\t \n\t\tu8  buffer[0x34];\n\t};\n} __packed;\n\n \n\n#define REQUEST_COMPLETION_FLAG\t0x1\n\n \nenum storvsc_request_type {\n\tWRITE_TYPE = 0,\n\tREAD_TYPE,\n\tUNKNOWN_TYPE,\n};\n\n \n#define SRB_STATUS_AUTOSENSE_VALID\t0x80\n#define SRB_STATUS_QUEUE_FROZEN\t\t0x40\n\n \n#define SRB_STATUS_SUCCESS\t\t0x01\n#define SRB_STATUS_ABORTED\t\t0x02\n#define SRB_STATUS_ERROR\t\t0x04\n#define SRB_STATUS_INVALID_REQUEST\t0x06\n#define SRB_STATUS_TIMEOUT\t\t0x09\n#define SRB_STATUS_SELECTION_TIMEOUT\t0x0A\n#define SRB_STATUS_BUS_RESET\t\t0x0E\n#define SRB_STATUS_DATA_OVERRUN\t\t0x12\n#define SRB_STATUS_INVALID_LUN\t\t0x20\n#define SRB_STATUS_INTERNAL_ERROR\t0x30\n\n#define SRB_STATUS(status) \\\n\t(status & ~(SRB_STATUS_AUTOSENSE_VALID | SRB_STATUS_QUEUE_FROZEN))\n \n\nstatic int storvsc_ringbuffer_size = (128 * 1024);\nstatic u32 max_outstanding_req_per_channel;\nstatic int storvsc_change_queue_depth(struct scsi_device *sdev, int queue_depth);\n\nstatic int storvsc_vcpus_per_sub_channel = 4;\nstatic unsigned int storvsc_max_hw_queues;\n\nmodule_param(storvsc_ringbuffer_size, int, S_IRUGO);\nMODULE_PARM_DESC(storvsc_ringbuffer_size, \"Ring buffer size (bytes)\");\n\nmodule_param(storvsc_max_hw_queues, uint, 0644);\nMODULE_PARM_DESC(storvsc_max_hw_queues, \"Maximum number of hardware queues\");\n\nmodule_param(storvsc_vcpus_per_sub_channel, int, S_IRUGO);\nMODULE_PARM_DESC(storvsc_vcpus_per_sub_channel, \"Ratio of VCPUs to subchannels\");\n\nstatic int ring_avail_percent_lowater = 10;\nmodule_param(ring_avail_percent_lowater, int, S_IRUGO);\nMODULE_PARM_DESC(ring_avail_percent_lowater,\n\t\t\"Select a channel if available ring size > this in percent\");\n\n \nstatic int storvsc_timeout = 180;\n\n#if IS_ENABLED(CONFIG_SCSI_FC_ATTRS)\nstatic struct scsi_transport_template *fc_transport_template;\n#endif\n\nstatic struct scsi_host_template scsi_driver;\nstatic void storvsc_on_channel_callback(void *context);\n\n#define STORVSC_MAX_LUNS_PER_TARGET\t\t\t255\n#define STORVSC_MAX_TARGETS\t\t\t\t2\n#define STORVSC_MAX_CHANNELS\t\t\t\t8\n\n#define STORVSC_FC_MAX_LUNS_PER_TARGET\t\t\t255\n#define STORVSC_FC_MAX_TARGETS\t\t\t\t128\n#define STORVSC_FC_MAX_CHANNELS\t\t\t\t8\n#define STORVSC_FC_MAX_XFER_SIZE\t\t\t((u32)(512 * 1024))\n\n#define STORVSC_IDE_MAX_LUNS_PER_TARGET\t\t\t64\n#define STORVSC_IDE_MAX_TARGETS\t\t\t\t1\n#define STORVSC_IDE_MAX_CHANNELS\t\t\t1\n\n \n#define STORVSC_MAX_PKT_SIZE (sizeof(struct vmpacket_descriptor) +\\\n\t\t\t      sizeof(struct vstor_packet))\n\nstruct storvsc_cmd_request {\n\tstruct scsi_cmnd *cmd;\n\n\tstruct hv_device *device;\n\n\t \n\tstruct completion wait_event;\n\n\tstruct vmbus_channel_packet_multipage_buffer mpb;\n\tstruct vmbus_packet_mpb_array *payload;\n\tu32 payload_sz;\n\n\tstruct vstor_packet vstor_packet;\n};\n\n\n \nstruct storvsc_device {\n\tstruct hv_device *device;\n\n\tbool\t destroy;\n\tbool\t drain_notify;\n\tatomic_t num_outstanding_req;\n\tstruct Scsi_Host *host;\n\n\twait_queue_head_t waiting_to_drain;\n\n\t \n\tunsigned int port_number;\n\tunsigned char path_id;\n\tunsigned char target_id;\n\n\t \n\tu32   max_transfer_bytes;\n\t \n\tu16 num_sc;\n\tstruct vmbus_channel **stor_chns;\n\t \n\tstruct cpumask alloced_cpus;\n\t \n\tspinlock_t lock;\n\t \n\tstruct storvsc_cmd_request init_request;\n\tstruct storvsc_cmd_request reset_request;\n\t \n\tu64 node_name;\n\tu64 port_name;\n#if IS_ENABLED(CONFIG_SCSI_FC_ATTRS)\n\tstruct fc_rport *rport;\n#endif\n};\n\nstruct hv_host_device {\n\tstruct hv_device *dev;\n\tunsigned int port;\n\tunsigned char path;\n\tunsigned char target;\n\tstruct workqueue_struct *handle_error_wq;\n\tstruct work_struct host_scan_work;\n\tstruct Scsi_Host *host;\n};\n\nstruct storvsc_scan_work {\n\tstruct work_struct work;\n\tstruct Scsi_Host *host;\n\tu8 lun;\n\tu8 tgt_id;\n};\n\nstatic void storvsc_device_scan(struct work_struct *work)\n{\n\tstruct storvsc_scan_work *wrk;\n\tstruct scsi_device *sdev;\n\n\twrk = container_of(work, struct storvsc_scan_work, work);\n\n\tsdev = scsi_device_lookup(wrk->host, 0, wrk->tgt_id, wrk->lun);\n\tif (!sdev)\n\t\tgoto done;\n\tscsi_rescan_device(sdev);\n\tscsi_device_put(sdev);\n\ndone:\n\tkfree(wrk);\n}\n\nstatic void storvsc_host_scan(struct work_struct *work)\n{\n\tstruct Scsi_Host *host;\n\tstruct scsi_device *sdev;\n\tstruct hv_host_device *host_device =\n\t\tcontainer_of(work, struct hv_host_device, host_scan_work);\n\n\thost = host_device->host;\n\t \n\tmutex_lock(&host->scan_mutex);\n\tshost_for_each_device(sdev, host)\n\t\tscsi_test_unit_ready(sdev, 1, 1, NULL);\n\tmutex_unlock(&host->scan_mutex);\n\t \n\tscsi_scan_host(host);\n}\n\nstatic void storvsc_remove_lun(struct work_struct *work)\n{\n\tstruct storvsc_scan_work *wrk;\n\tstruct scsi_device *sdev;\n\n\twrk = container_of(work, struct storvsc_scan_work, work);\n\tif (!scsi_host_get(wrk->host))\n\t\tgoto done;\n\n\tsdev = scsi_device_lookup(wrk->host, 0, wrk->tgt_id, wrk->lun);\n\n\tif (sdev) {\n\t\tscsi_remove_device(sdev);\n\t\tscsi_device_put(sdev);\n\t}\n\tscsi_host_put(wrk->host);\n\ndone:\n\tkfree(wrk);\n}\n\n\n \n\nstatic inline struct storvsc_device *get_out_stor_device(\n\t\t\t\t\tstruct hv_device *device)\n{\n\tstruct storvsc_device *stor_device;\n\n\tstor_device = hv_get_drvdata(device);\n\n\tif (stor_device && stor_device->destroy)\n\t\tstor_device = NULL;\n\n\treturn stor_device;\n}\n\n\nstatic inline void storvsc_wait_to_drain(struct storvsc_device *dev)\n{\n\tdev->drain_notify = true;\n\twait_event(dev->waiting_to_drain,\n\t\t   atomic_read(&dev->num_outstanding_req) == 0);\n\tdev->drain_notify = false;\n}\n\nstatic inline struct storvsc_device *get_in_stor_device(\n\t\t\t\t\tstruct hv_device *device)\n{\n\tstruct storvsc_device *stor_device;\n\n\tstor_device = hv_get_drvdata(device);\n\n\tif (!stor_device)\n\t\tgoto get_in_err;\n\n\t \n\n\tif (stor_device->destroy  &&\n\t\t(atomic_read(&stor_device->num_outstanding_req) == 0))\n\t\tstor_device = NULL;\n\nget_in_err:\n\treturn stor_device;\n\n}\n\nstatic void storvsc_change_target_cpu(struct vmbus_channel *channel, u32 old,\n\t\t\t\t      u32 new)\n{\n\tstruct storvsc_device *stor_device;\n\tstruct vmbus_channel *cur_chn;\n\tbool old_is_alloced = false;\n\tstruct hv_device *device;\n\tunsigned long flags;\n\tint cpu;\n\n\tdevice = channel->primary_channel ?\n\t\t\tchannel->primary_channel->device_obj\n\t\t\t\t: channel->device_obj;\n\tstor_device = get_out_stor_device(device);\n\tif (!stor_device)\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&stor_device->lock, flags);\n\n\t \n\tif (device->channel != channel && device->channel->target_cpu == old) {\n\t\tcur_chn = device->channel;\n\t\told_is_alloced = true;\n\t\tgoto old_is_alloced;\n\t}\n\tlist_for_each_entry(cur_chn, &device->channel->sc_list, sc_list) {\n\t\tif (cur_chn == channel)\n\t\t\tcontinue;\n\t\tif (cur_chn->target_cpu == old) {\n\t\t\told_is_alloced = true;\n\t\t\tgoto old_is_alloced;\n\t\t}\n\t}\n\nold_is_alloced:\n\tif (old_is_alloced)\n\t\tWRITE_ONCE(stor_device->stor_chns[old], cur_chn);\n\telse\n\t\tcpumask_clear_cpu(old, &stor_device->alloced_cpus);\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\tif (stor_device->stor_chns[cpu] && !cpumask_test_cpu(\n\t\t\t\t\tcpu, &stor_device->alloced_cpus))\n\t\t\tWRITE_ONCE(stor_device->stor_chns[cpu], NULL);\n\t}\n\n\tWRITE_ONCE(stor_device->stor_chns[new], channel);\n\tcpumask_set_cpu(new, &stor_device->alloced_cpus);\n\n\tspin_unlock_irqrestore(&stor_device->lock, flags);\n}\n\nstatic u64 storvsc_next_request_id(struct vmbus_channel *channel, u64 rqst_addr)\n{\n\tstruct storvsc_cmd_request *request =\n\t\t(struct storvsc_cmd_request *)(unsigned long)rqst_addr;\n\n\tif (rqst_addr == VMBUS_RQST_INIT)\n\t\treturn VMBUS_RQST_INIT;\n\tif (rqst_addr == VMBUS_RQST_RESET)\n\t\treturn VMBUS_RQST_RESET;\n\n\t \n\treturn (u64)blk_mq_unique_tag(scsi_cmd_to_rq(request->cmd)) + 1;\n}\n\nstatic void handle_sc_creation(struct vmbus_channel *new_sc)\n{\n\tstruct hv_device *device = new_sc->primary_channel->device_obj;\n\tstruct device *dev = &device->device;\n\tstruct storvsc_device *stor_device;\n\tstruct vmstorage_channel_properties props;\n\tint ret;\n\n\tstor_device = get_out_stor_device(device);\n\tif (!stor_device)\n\t\treturn;\n\n\tmemset(&props, 0, sizeof(struct vmstorage_channel_properties));\n\tnew_sc->max_pkt_size = STORVSC_MAX_PKT_SIZE;\n\n\tnew_sc->next_request_id_callback = storvsc_next_request_id;\n\n\tret = vmbus_open(new_sc,\n\t\t\t storvsc_ringbuffer_size,\n\t\t\t storvsc_ringbuffer_size,\n\t\t\t (void *)&props,\n\t\t\t sizeof(struct vmstorage_channel_properties),\n\t\t\t storvsc_on_channel_callback, new_sc);\n\n\t \n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to open sub-channel: err=%d\\n\", ret);\n\t\treturn;\n\t}\n\n\tnew_sc->change_target_cpu_callback = storvsc_change_target_cpu;\n\n\t \n\tstor_device->stor_chns[new_sc->target_cpu] = new_sc;\n\tcpumask_set_cpu(new_sc->target_cpu, &stor_device->alloced_cpus);\n}\n\nstatic void  handle_multichannel_storage(struct hv_device *device, int max_chns)\n{\n\tstruct device *dev = &device->device;\n\tstruct storvsc_device *stor_device;\n\tint num_sc;\n\tstruct storvsc_cmd_request *request;\n\tstruct vstor_packet *vstor_packet;\n\tint ret, t;\n\n\t \n\tnum_sc = min((int)(num_online_cpus() - 1), max_chns);\n\tif (!num_sc)\n\t\treturn;\n\n\tstor_device = get_out_stor_device(device);\n\tif (!stor_device)\n\t\treturn;\n\n\tstor_device->num_sc = num_sc;\n\trequest = &stor_device->init_request;\n\tvstor_packet = &request->vstor_packet;\n\n\t \n\tvmbus_set_sc_create_callback(device->channel, handle_sc_creation);\n\n\t \n\tmemset(request, 0, sizeof(struct storvsc_cmd_request));\n\tinit_completion(&request->wait_event);\n\tvstor_packet->operation = VSTOR_OPERATION_CREATE_SUB_CHANNELS;\n\tvstor_packet->flags = REQUEST_COMPLETION_FLAG;\n\tvstor_packet->sub_channel_count = num_sc;\n\n\tret = vmbus_sendpacket(device->channel, vstor_packet,\n\t\t\t       sizeof(struct vstor_packet),\n\t\t\t       VMBUS_RQST_INIT,\n\t\t\t       VM_PKT_DATA_INBAND,\n\t\t\t       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\n\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to create sub-channel: err=%d\\n\", ret);\n\t\treturn;\n\t}\n\n\tt = wait_for_completion_timeout(&request->wait_event, 10*HZ);\n\tif (t == 0) {\n\t\tdev_err(dev, \"Failed to create sub-channel: timed out\\n\");\n\t\treturn;\n\t}\n\n\tif (vstor_packet->operation != VSTOR_OPERATION_COMPLETE_IO ||\n\t    vstor_packet->status != 0) {\n\t\tdev_err(dev, \"Failed to create sub-channel: op=%d, sts=%d\\n\",\n\t\t\tvstor_packet->operation, vstor_packet->status);\n\t\treturn;\n\t}\n\n\t \n}\n\nstatic void cache_wwn(struct storvsc_device *stor_device,\n\t\t      struct vstor_packet *vstor_packet)\n{\n\t \n\tif (vstor_packet->wwn_packet.primary_active) {\n\t\tstor_device->node_name =\n\t\t\twwn_to_u64(vstor_packet->wwn_packet.primary_node_wwn);\n\t\tstor_device->port_name =\n\t\t\twwn_to_u64(vstor_packet->wwn_packet.primary_port_wwn);\n\t} else {\n\t\tstor_device->node_name =\n\t\t\twwn_to_u64(vstor_packet->wwn_packet.secondary_node_wwn);\n\t\tstor_device->port_name =\n\t\t\twwn_to_u64(vstor_packet->wwn_packet.secondary_port_wwn);\n\t}\n}\n\n\nstatic int storvsc_execute_vstor_op(struct hv_device *device,\n\t\t\t\t    struct storvsc_cmd_request *request,\n\t\t\t\t    bool status_check)\n{\n\tstruct storvsc_device *stor_device;\n\tstruct vstor_packet *vstor_packet;\n\tint ret, t;\n\n\tstor_device = get_out_stor_device(device);\n\tif (!stor_device)\n\t\treturn -ENODEV;\n\n\tvstor_packet = &request->vstor_packet;\n\n\tinit_completion(&request->wait_event);\n\tvstor_packet->flags = REQUEST_COMPLETION_FLAG;\n\n\tret = vmbus_sendpacket(device->channel, vstor_packet,\n\t\t\t       sizeof(struct vstor_packet),\n\t\t\t       VMBUS_RQST_INIT,\n\t\t\t       VM_PKT_DATA_INBAND,\n\t\t\t       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\n\tif (t == 0)\n\t\treturn -ETIMEDOUT;\n\n\tif (!status_check)\n\t\treturn ret;\n\n\tif (vstor_packet->operation != VSTOR_OPERATION_COMPLETE_IO ||\n\t    vstor_packet->status != 0)\n\t\treturn -EINVAL;\n\n\treturn ret;\n}\n\nstatic int storvsc_channel_init(struct hv_device *device, bool is_fc)\n{\n\tstruct storvsc_device *stor_device;\n\tstruct storvsc_cmd_request *request;\n\tstruct vstor_packet *vstor_packet;\n\tint ret, i;\n\tint max_chns;\n\tbool process_sub_channels = false;\n\n\tstor_device = get_out_stor_device(device);\n\tif (!stor_device)\n\t\treturn -ENODEV;\n\n\trequest = &stor_device->init_request;\n\tvstor_packet = &request->vstor_packet;\n\n\t \n\tmemset(request, 0, sizeof(struct storvsc_cmd_request));\n\tvstor_packet->operation = VSTOR_OPERATION_BEGIN_INITIALIZATION;\n\tret = storvsc_execute_vstor_op(device, request, true);\n\tif (ret)\n\t\treturn ret;\n\t \n\n\tfor (i = 0; i < ARRAY_SIZE(protocol_version); i++) {\n\t\t \n\t\tmemset(vstor_packet, 0, sizeof(struct vstor_packet));\n\t\tvstor_packet->operation =\n\t\t\tVSTOR_OPERATION_QUERY_PROTOCOL_VERSION;\n\n\t\tvstor_packet->version.major_minor = protocol_version[i];\n\n\t\t \n\t\tvstor_packet->version.revision = 0;\n\t\tret = storvsc_execute_vstor_op(device, request, false);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\tif (vstor_packet->operation != VSTOR_OPERATION_COMPLETE_IO)\n\t\t\treturn -EINVAL;\n\n\t\tif (vstor_packet->status == 0) {\n\t\t\tvmstor_proto_version = protocol_version[i];\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (vstor_packet->status != 0) {\n\t\tdev_err(&device->device, \"Obsolete Hyper-V version\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\n\tmemset(vstor_packet, 0, sizeof(struct vstor_packet));\n\tvstor_packet->operation = VSTOR_OPERATION_QUERY_PROPERTIES;\n\tret = storvsc_execute_vstor_op(device, request, true);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tmax_chns = vstor_packet->storage_channel_properties.max_channel_cnt;\n\n\t \n\tstor_device->stor_chns = kcalloc(num_possible_cpus(), sizeof(void *),\n\t\t\t\t\t GFP_KERNEL);\n\tif (stor_device->stor_chns == NULL)\n\t\treturn -ENOMEM;\n\n\tdevice->channel->change_target_cpu_callback = storvsc_change_target_cpu;\n\n\tstor_device->stor_chns[device->channel->target_cpu] = device->channel;\n\tcpumask_set_cpu(device->channel->target_cpu,\n\t\t\t&stor_device->alloced_cpus);\n\n\tif (vstor_packet->storage_channel_properties.flags &\n\t    STORAGE_CHANNEL_SUPPORTS_MULTI_CHANNEL)\n\t\tprocess_sub_channels = true;\n\n\tstor_device->max_transfer_bytes =\n\t\tvstor_packet->storage_channel_properties.max_transfer_bytes;\n\n\tif (!is_fc)\n\t\tgoto done;\n\n\t \n\tmemset(vstor_packet, 0, sizeof(struct vstor_packet));\n\tvstor_packet->operation = VSTOR_OPERATION_FCHBA_DATA;\n\tret = storvsc_execute_vstor_op(device, request, true);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tcache_wwn(stor_device, vstor_packet);\n\ndone:\n\n\tmemset(vstor_packet, 0, sizeof(struct vstor_packet));\n\tvstor_packet->operation = VSTOR_OPERATION_END_INITIALIZATION;\n\tret = storvsc_execute_vstor_op(device, request, true);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (process_sub_channels)\n\t\thandle_multichannel_storage(device, max_chns);\n\n\treturn ret;\n}\n\nstatic void storvsc_handle_error(struct vmscsi_request *vm_srb,\n\t\t\t\tstruct scsi_cmnd *scmnd,\n\t\t\t\tstruct Scsi_Host *host,\n\t\t\t\tu8 asc, u8 ascq)\n{\n\tstruct storvsc_scan_work *wrk;\n\tvoid (*process_err_fn)(struct work_struct *work);\n\tstruct hv_host_device *host_dev = shost_priv(host);\n\n\tswitch (SRB_STATUS(vm_srb->srb_status)) {\n\tcase SRB_STATUS_ERROR:\n\tcase SRB_STATUS_ABORTED:\n\tcase SRB_STATUS_INVALID_REQUEST:\n\tcase SRB_STATUS_INTERNAL_ERROR:\n\tcase SRB_STATUS_TIMEOUT:\n\tcase SRB_STATUS_SELECTION_TIMEOUT:\n\tcase SRB_STATUS_BUS_RESET:\n\tcase SRB_STATUS_DATA_OVERRUN:\n\t\tif (vm_srb->srb_status & SRB_STATUS_AUTOSENSE_VALID) {\n\t\t\t \n\t\t\tif ((asc == 0x2a) && (ascq == 0x9)) {\n\t\t\t\tprocess_err_fn = storvsc_device_scan;\n\t\t\t\t \n\t\t\t\tset_host_byte(scmnd, DID_REQUEUE);\n\t\t\t\tgoto do_work;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((asc == 0x3f) && (ascq != 0x03) &&\n\t\t\t\t\t(ascq != 0x0e)) {\n\t\t\t\tprocess_err_fn = storvsc_device_scan;\n\t\t\t\tset_host_byte(scmnd, DID_REQUEUE);\n\t\t\t\tgoto do_work;\n\t\t\t}\n\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tswitch (scmnd->cmnd[0]) {\n\t\tcase ATA_16:\n\t\tcase ATA_12:\n\t\t\tset_host_byte(scmnd, DID_PASSTHROUGH);\n\t\t\tbreak;\n\t\t \n\t\tcase TEST_UNIT_READY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tset_host_byte(scmnd, DID_ERROR);\n\t\t}\n\t\treturn;\n\n\tcase SRB_STATUS_INVALID_LUN:\n\t\tset_host_byte(scmnd, DID_NO_CONNECT);\n\t\tprocess_err_fn = storvsc_remove_lun;\n\t\tgoto do_work;\n\n\t}\n\treturn;\n\ndo_work:\n\t \n\twrk = kmalloc(sizeof(struct storvsc_scan_work), GFP_ATOMIC);\n\tif (!wrk) {\n\t\tset_host_byte(scmnd, DID_BAD_TARGET);\n\t\treturn;\n\t}\n\n\twrk->host = host;\n\twrk->lun = vm_srb->lun;\n\twrk->tgt_id = vm_srb->target_id;\n\tINIT_WORK(&wrk->work, process_err_fn);\n\tqueue_work(host_dev->handle_error_wq, &wrk->work);\n}\n\n\nstatic void storvsc_command_completion(struct storvsc_cmd_request *cmd_request,\n\t\t\t\t       struct storvsc_device *stor_dev)\n{\n\tstruct scsi_cmnd *scmnd = cmd_request->cmd;\n\tstruct scsi_sense_hdr sense_hdr;\n\tstruct vmscsi_request *vm_srb;\n\tu32 data_transfer_length;\n\tstruct Scsi_Host *host;\n\tu32 payload_sz = cmd_request->payload_sz;\n\tvoid *payload = cmd_request->payload;\n\tbool sense_ok;\n\n\thost = stor_dev->host;\n\n\tvm_srb = &cmd_request->vstor_packet.vm_srb;\n\tdata_transfer_length = vm_srb->data_transfer_length;\n\n\tscmnd->result = vm_srb->scsi_status;\n\n\tif (scmnd->result) {\n\t\tsense_ok = scsi_normalize_sense(scmnd->sense_buffer,\n\t\t\t\tSCSI_SENSE_BUFFERSIZE, &sense_hdr);\n\n\t\tif (sense_ok && do_logging(STORVSC_LOGGING_WARN))\n\t\t\tscsi_print_sense_hdr(scmnd->device, \"storvsc\",\n\t\t\t\t\t     &sense_hdr);\n\t}\n\n\tif (vm_srb->srb_status != SRB_STATUS_SUCCESS) {\n\t\tstorvsc_handle_error(vm_srb, scmnd, host, sense_hdr.asc,\n\t\t\t\t\t sense_hdr.ascq);\n\t\t \n\t\tif (vm_srb->srb_status != SRB_STATUS_DATA_OVERRUN)\n\t\t\tdata_transfer_length = 0;\n\t}\n\n\t \n\tif (data_transfer_length > cmd_request->payload->range.len)\n\t\tdata_transfer_length = cmd_request->payload->range.len;\n\n\tscsi_set_resid(scmnd,\n\t\tcmd_request->payload->range.len - data_transfer_length);\n\n\tscsi_done(scmnd);\n\n\tif (payload_sz >\n\t\tsizeof(struct vmbus_channel_packet_multipage_buffer))\n\t\tkfree(payload);\n}\n\nstatic void storvsc_on_io_completion(struct storvsc_device *stor_device,\n\t\t\t\t  struct vstor_packet *vstor_packet,\n\t\t\t\t  struct storvsc_cmd_request *request)\n{\n\tstruct vstor_packet *stor_pkt;\n\tstruct hv_device *device = stor_device->device;\n\n\tstor_pkt = &request->vstor_packet;\n\n\t \n\n\tif ((stor_pkt->vm_srb.cdb[0] == INQUIRY) ||\n\t   (stor_pkt->vm_srb.cdb[0] == MODE_SENSE)) {\n\t\tvstor_packet->vm_srb.scsi_status = 0;\n\t\tvstor_packet->vm_srb.srb_status = SRB_STATUS_SUCCESS;\n\t}\n\n\t \n\tstor_pkt->vm_srb.scsi_status = vstor_packet->vm_srb.scsi_status;\n\tstor_pkt->vm_srb.srb_status = vstor_packet->vm_srb.srb_status;\n\n\t \n\tstor_pkt->vm_srb.sense_info_length = min_t(u8, STORVSC_SENSE_BUFFER_SIZE,\n\t\tvstor_packet->vm_srb.sense_info_length);\n\n\tif (vstor_packet->vm_srb.scsi_status != 0 ||\n\t    vstor_packet->vm_srb.srb_status != SRB_STATUS_SUCCESS) {\n\n\t\t \n\t\tint loglevel = (stor_pkt->vm_srb.cdb[0] == TEST_UNIT_READY) ?\n\t\t\tSTORVSC_LOGGING_WARN : STORVSC_LOGGING_ERROR;\n\n\t\tstorvsc_log(device, loglevel,\n\t\t\t\"tag#%d cmd 0x%x status: scsi 0x%x srb 0x%x hv 0x%x\\n\",\n\t\t\tscsi_cmd_to_rq(request->cmd)->tag,\n\t\t\tstor_pkt->vm_srb.cdb[0],\n\t\t\tvstor_packet->vm_srb.scsi_status,\n\t\t\tvstor_packet->vm_srb.srb_status,\n\t\t\tvstor_packet->status);\n\t}\n\n\tif (vstor_packet->vm_srb.scsi_status == SAM_STAT_CHECK_CONDITION &&\n\t    (vstor_packet->vm_srb.srb_status & SRB_STATUS_AUTOSENSE_VALID))\n\t\tmemcpy(request->cmd->sense_buffer,\n\t\t       vstor_packet->vm_srb.sense_data,\n\t\t       stor_pkt->vm_srb.sense_info_length);\n\n\tstor_pkt->vm_srb.data_transfer_length =\n\t\tvstor_packet->vm_srb.data_transfer_length;\n\n\tstorvsc_command_completion(request, stor_device);\n\n\tif (atomic_dec_and_test(&stor_device->num_outstanding_req) &&\n\t\tstor_device->drain_notify)\n\t\twake_up(&stor_device->waiting_to_drain);\n}\n\nstatic void storvsc_on_receive(struct storvsc_device *stor_device,\n\t\t\t     struct vstor_packet *vstor_packet,\n\t\t\t     struct storvsc_cmd_request *request)\n{\n\tstruct hv_host_device *host_dev;\n\tswitch (vstor_packet->operation) {\n\tcase VSTOR_OPERATION_COMPLETE_IO:\n\t\tstorvsc_on_io_completion(stor_device, vstor_packet, request);\n\t\tbreak;\n\n\tcase VSTOR_OPERATION_REMOVE_DEVICE:\n\tcase VSTOR_OPERATION_ENUMERATE_BUS:\n\t\thost_dev = shost_priv(stor_device->host);\n\t\tqueue_work(\n\t\t\thost_dev->handle_error_wq, &host_dev->host_scan_work);\n\t\tbreak;\n\n\tcase VSTOR_OPERATION_FCHBA_DATA:\n\t\tcache_wwn(stor_device, vstor_packet);\n#if IS_ENABLED(CONFIG_SCSI_FC_ATTRS)\n\t\tfc_host_node_name(stor_device->host) = stor_device->node_name;\n\t\tfc_host_port_name(stor_device->host) = stor_device->port_name;\n#endif\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void storvsc_on_channel_callback(void *context)\n{\n\tstruct vmbus_channel *channel = (struct vmbus_channel *)context;\n\tconst struct vmpacket_descriptor *desc;\n\tstruct hv_device *device;\n\tstruct storvsc_device *stor_device;\n\tstruct Scsi_Host *shost;\n\tunsigned long time_limit = jiffies + msecs_to_jiffies(CALLBACK_TIMEOUT);\n\n\tif (channel->primary_channel != NULL)\n\t\tdevice = channel->primary_channel->device_obj;\n\telse\n\t\tdevice = channel->device_obj;\n\n\tstor_device = get_in_stor_device(device);\n\tif (!stor_device)\n\t\treturn;\n\n\tshost = stor_device->host;\n\n\tforeach_vmbus_pkt(desc, channel) {\n\t\tstruct vstor_packet *packet = hv_pkt_data(desc);\n\t\tstruct storvsc_cmd_request *request = NULL;\n\t\tu32 pktlen = hv_pkt_datalen(desc);\n\t\tu64 rqst_id = desc->trans_id;\n\t\tu32 minlen = rqst_id ? sizeof(struct vstor_packet) :\n\t\t\tsizeof(enum vstor_packet_operation);\n\n\t\tif (unlikely(time_after(jiffies, time_limit))) {\n\t\t\thv_pkt_iter_close(channel);\n\t\t\treturn;\n\t\t}\n\n\t\tif (pktlen < minlen) {\n\t\t\tdev_err(&device->device,\n\t\t\t\t\"Invalid pkt: id=%llu, len=%u, minlen=%u\\n\",\n\t\t\t\trqst_id, pktlen, minlen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rqst_id == VMBUS_RQST_INIT) {\n\t\t\trequest = &stor_device->init_request;\n\t\t} else if (rqst_id == VMBUS_RQST_RESET) {\n\t\t\trequest = &stor_device->reset_request;\n\t\t} else {\n\t\t\t \n\t\t\tif (rqst_id == 0) {\n\t\t\t\t \n\t\t\t\tif (packet->operation == VSTOR_OPERATION_COMPLETE_IO ||\n\t\t\t\t    packet->operation == VSTOR_OPERATION_FCHBA_DATA) {\n\t\t\t\t\tdev_err(&device->device, \"Invalid packet with ID of 0\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct scsi_cmnd *scmnd;\n\n\t\t\t\t \n\t\t\t\tscmnd = scsi_host_find_tag(shost, rqst_id - 1);\n\t\t\t\tif (scmnd == NULL) {\n\t\t\t\t\tdev_err(&device->device, \"Incorrect transaction ID\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trequest = (struct storvsc_cmd_request *)scsi_cmd_priv(scmnd);\n\t\t\t\tscsi_dma_unmap(scmnd);\n\t\t\t}\n\n\t\t\tstorvsc_on_receive(stor_device, packet, request);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemcpy(&request->vstor_packet, packet,\n\t\t       sizeof(struct vstor_packet));\n\t\tcomplete(&request->wait_event);\n\t}\n}\n\nstatic int storvsc_connect_to_vsp(struct hv_device *device, u32 ring_size,\n\t\t\t\t  bool is_fc)\n{\n\tstruct vmstorage_channel_properties props;\n\tint ret;\n\n\tmemset(&props, 0, sizeof(struct vmstorage_channel_properties));\n\n\tdevice->channel->max_pkt_size = STORVSC_MAX_PKT_SIZE;\n\tdevice->channel->next_request_id_callback = storvsc_next_request_id;\n\n\tret = vmbus_open(device->channel,\n\t\t\t ring_size,\n\t\t\t ring_size,\n\t\t\t (void *)&props,\n\t\t\t sizeof(struct vmstorage_channel_properties),\n\t\t\t storvsc_on_channel_callback, device->channel);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = storvsc_channel_init(device, is_fc);\n\n\treturn ret;\n}\n\nstatic int storvsc_dev_remove(struct hv_device *device)\n{\n\tstruct storvsc_device *stor_device;\n\n\tstor_device = hv_get_drvdata(device);\n\n\tstor_device->destroy = true;\n\n\t \n\twmb();\n\n\t \n\n\tstorvsc_wait_to_drain(stor_device);\n\n\t \n\thv_set_drvdata(device, NULL);\n\n\t \n\tvmbus_close(device->channel);\n\n\tkfree(stor_device->stor_chns);\n\tkfree(stor_device);\n\treturn 0;\n}\n\nstatic struct vmbus_channel *get_og_chn(struct storvsc_device *stor_device,\n\t\t\t\t\tu16 q_num)\n{\n\tu16 slot = 0;\n\tu16 hash_qnum;\n\tconst struct cpumask *node_mask;\n\tint num_channels, tgt_cpu;\n\n\tif (stor_device->num_sc == 0) {\n\t\tstor_device->stor_chns[q_num] = stor_device->device->channel;\n\t\treturn stor_device->device->channel;\n\t}\n\n\t \n\n\tnode_mask = cpumask_of_node(cpu_to_node(q_num));\n\n\tnum_channels = 0;\n\tfor_each_cpu(tgt_cpu, &stor_device->alloced_cpus) {\n\t\tif (cpumask_test_cpu(tgt_cpu, node_mask))\n\t\t\tnum_channels++;\n\t}\n\tif (num_channels == 0) {\n\t\tstor_device->stor_chns[q_num] = stor_device->device->channel;\n\t\treturn stor_device->device->channel;\n\t}\n\n\thash_qnum = q_num;\n\twhile (hash_qnum >= num_channels)\n\t\thash_qnum -= num_channels;\n\n\tfor_each_cpu(tgt_cpu, &stor_device->alloced_cpus) {\n\t\tif (!cpumask_test_cpu(tgt_cpu, node_mask))\n\t\t\tcontinue;\n\t\tif (slot == hash_qnum)\n\t\t\tbreak;\n\t\tslot++;\n\t}\n\n\tstor_device->stor_chns[q_num] = stor_device->stor_chns[tgt_cpu];\n\n\treturn stor_device->stor_chns[q_num];\n}\n\n\nstatic int storvsc_do_io(struct hv_device *device,\n\t\t\t struct storvsc_cmd_request *request, u16 q_num)\n{\n\tstruct storvsc_device *stor_device;\n\tstruct vstor_packet *vstor_packet;\n\tstruct vmbus_channel *outgoing_channel, *channel;\n\tunsigned long flags;\n\tint ret = 0;\n\tconst struct cpumask *node_mask;\n\tint tgt_cpu;\n\n\tvstor_packet = &request->vstor_packet;\n\tstor_device = get_out_stor_device(device);\n\n\tif (!stor_device)\n\t\treturn -ENODEV;\n\n\n\trequest->device  = device;\n\t \n\t \n\toutgoing_channel = READ_ONCE(stor_device->stor_chns[q_num]);\n\tif (outgoing_channel != NULL) {\n\t\tif (outgoing_channel->target_cpu == q_num) {\n\t\t\t \n\t\t\tnode_mask = cpumask_of_node(cpu_to_node(q_num));\n\t\t\tfor_each_cpu_wrap(tgt_cpu,\n\t\t\t\t &stor_device->alloced_cpus, q_num + 1) {\n\t\t\t\tif (!cpumask_test_cpu(tgt_cpu, node_mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (tgt_cpu == q_num)\n\t\t\t\t\tcontinue;\n\t\t\t\tchannel = READ_ONCE(\n\t\t\t\t\tstor_device->stor_chns[tgt_cpu]);\n\t\t\t\tif (channel == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (hv_get_avail_to_write_percent(\n\t\t\t\t\t\t\t&channel->outbound)\n\t\t\t\t\t\t> ring_avail_percent_lowater) {\n\t\t\t\t\toutgoing_channel = channel;\n\t\t\t\t\tgoto found_channel;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (hv_get_avail_to_write_percent(\n\t\t\t\t\t\t&outgoing_channel->outbound)\n\t\t\t\t\t> ring_avail_percent_lowater)\n\t\t\t\tgoto found_channel;\n\n\t\t\t \n\t\t\tfor_each_cpu(tgt_cpu, &stor_device->alloced_cpus) {\n\t\t\t\tif (cpumask_test_cpu(tgt_cpu, node_mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tchannel = READ_ONCE(\n\t\t\t\t\tstor_device->stor_chns[tgt_cpu]);\n\t\t\t\tif (channel == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (hv_get_avail_to_write_percent(\n\t\t\t\t\t\t\t&channel->outbound)\n\t\t\t\t\t\t> ring_avail_percent_lowater) {\n\t\t\t\t\toutgoing_channel = channel;\n\t\t\t\t\tgoto found_channel;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tspin_lock_irqsave(&stor_device->lock, flags);\n\t\toutgoing_channel = stor_device->stor_chns[q_num];\n\t\tif (outgoing_channel != NULL) {\n\t\t\tspin_unlock_irqrestore(&stor_device->lock, flags);\n\t\t\tgoto found_channel;\n\t\t}\n\t\toutgoing_channel = get_og_chn(stor_device, q_num);\n\t\tspin_unlock_irqrestore(&stor_device->lock, flags);\n\t}\n\nfound_channel:\n\tvstor_packet->flags |= REQUEST_COMPLETION_FLAG;\n\n\tvstor_packet->vm_srb.length = sizeof(struct vmscsi_request);\n\n\n\tvstor_packet->vm_srb.sense_info_length = STORVSC_SENSE_BUFFER_SIZE;\n\n\n\tvstor_packet->vm_srb.data_transfer_length =\n\trequest->payload->range.len;\n\n\tvstor_packet->operation = VSTOR_OPERATION_EXECUTE_SRB;\n\n\tif (request->payload->range.len) {\n\n\t\tret = vmbus_sendpacket_mpb_desc(outgoing_channel,\n\t\t\t\trequest->payload, request->payload_sz,\n\t\t\t\tvstor_packet,\n\t\t\t\tsizeof(struct vstor_packet),\n\t\t\t\t(unsigned long)request);\n\t} else {\n\t\tret = vmbus_sendpacket(outgoing_channel, vstor_packet,\n\t\t\t       sizeof(struct vstor_packet),\n\t\t\t       (unsigned long)request,\n\t\t\t       VM_PKT_DATA_INBAND,\n\t\t\t       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\n\t}\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\tatomic_inc(&stor_device->num_outstanding_req);\n\n\treturn ret;\n}\n\nstatic int storvsc_device_alloc(struct scsi_device *sdevice)\n{\n\t \n\tsdevice->sdev_bflags = BLIST_REPORTLUN2 | BLIST_TRY_VPD_PAGES;\n\n\treturn 0;\n}\n\nstatic int storvsc_device_configure(struct scsi_device *sdevice)\n{\n\tblk_queue_rq_timeout(sdevice->request_queue, (storvsc_timeout * HZ));\n\n\t \n\tsdevice->no_report_opcodes = 1;\n\tsdevice->no_write_same = 1;\n\n\t \n\tif (!strncmp(sdevice->vendor, \"Msft\", 4)) {\n\t\tswitch (vmstor_proto_version) {\n\t\tcase VMSTOR_PROTO_VERSION_WIN8:\n\t\tcase VMSTOR_PROTO_VERSION_WIN8_1:\n\t\t\tsdevice->scsi_level = SCSI_SPC_3;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (vmstor_proto_version >= VMSTOR_PROTO_VERSION_WIN10)\n\t\t\tsdevice->no_write_same = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int storvsc_get_chs(struct scsi_device *sdev, struct block_device * bdev,\n\t\t\t   sector_t capacity, int *info)\n{\n\tsector_t nsect = capacity;\n\tsector_t cylinders = nsect;\n\tint heads, sectors_pt;\n\n\t \n\theads = 0xff;\n\tsectors_pt = 0x3f;       \n\tsector_div(cylinders, heads * sectors_pt);\n\tif ((sector_t)(cylinders + 1) * heads * sectors_pt < nsect)\n\t\tcylinders = 0xffff;\n\n\tinfo[0] = heads;\n\tinfo[1] = sectors_pt;\n\tinfo[2] = (int)cylinders;\n\n\treturn 0;\n}\n\nstatic int storvsc_host_reset_handler(struct scsi_cmnd *scmnd)\n{\n\tstruct hv_host_device *host_dev = shost_priv(scmnd->device->host);\n\tstruct hv_device *device = host_dev->dev;\n\n\tstruct storvsc_device *stor_device;\n\tstruct storvsc_cmd_request *request;\n\tstruct vstor_packet *vstor_packet;\n\tint ret, t;\n\n\tstor_device = get_out_stor_device(device);\n\tif (!stor_device)\n\t\treturn FAILED;\n\n\trequest = &stor_device->reset_request;\n\tvstor_packet = &request->vstor_packet;\n\tmemset(vstor_packet, 0, sizeof(struct vstor_packet));\n\n\tinit_completion(&request->wait_event);\n\n\tvstor_packet->operation = VSTOR_OPERATION_RESET_BUS;\n\tvstor_packet->flags = REQUEST_COMPLETION_FLAG;\n\tvstor_packet->vm_srb.path_id = stor_device->path_id;\n\n\tret = vmbus_sendpacket(device->channel, vstor_packet,\n\t\t\t       sizeof(struct vstor_packet),\n\t\t\t       VMBUS_RQST_RESET,\n\t\t\t       VM_PKT_DATA_INBAND,\n\t\t\t       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\n\tif (ret != 0)\n\t\treturn FAILED;\n\n\tt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\n\tif (t == 0)\n\t\treturn TIMEOUT_ERROR;\n\n\n\t \n\tstorvsc_wait_to_drain(stor_device);\n\n\treturn SUCCESS;\n}\n\n \nstatic enum scsi_timeout_action storvsc_eh_timed_out(struct scsi_cmnd *scmnd)\n{\n\treturn SCSI_EH_RESET_TIMER;\n}\n\nstatic bool storvsc_scsi_cmd_ok(struct scsi_cmnd *scmnd)\n{\n\tbool allowed = true;\n\tu8 scsi_op = scmnd->cmnd[0];\n\n\tswitch (scsi_op) {\n\t \n\tcase WRITE_SAME:\n\t \n\tcase SET_WINDOW:\n\t\tset_host_byte(scmnd, DID_ERROR);\n\t\tallowed = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn allowed;\n}\n\nstatic int storvsc_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *scmnd)\n{\n\tint ret;\n\tstruct hv_host_device *host_dev = shost_priv(host);\n\tstruct hv_device *dev = host_dev->dev;\n\tstruct storvsc_cmd_request *cmd_request = scsi_cmd_priv(scmnd);\n\tstruct scatterlist *sgl;\n\tstruct vmscsi_request *vm_srb;\n\tstruct vmbus_packet_mpb_array  *payload;\n\tu32 payload_sz;\n\tu32 length;\n\n\tif (vmstor_proto_version <= VMSTOR_PROTO_VERSION_WIN8) {\n\t\t \n\t\tif (!storvsc_scsi_cmd_ok(scmnd)) {\n\t\t\tscsi_done(scmnd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tcmd_request->cmd = scmnd;\n\n\tmemset(&cmd_request->vstor_packet, 0, sizeof(struct vstor_packet));\n\tvm_srb = &cmd_request->vstor_packet.vm_srb;\n\tvm_srb->time_out_value = 60;\n\n\tvm_srb->srb_flags |=\n\t\tSRB_FLAGS_DISABLE_SYNCH_TRANSFER;\n\n\tif (scmnd->device->tagged_supported) {\n\t\tvm_srb->srb_flags |=\n\t\t(SRB_FLAGS_QUEUE_ACTION_ENABLE | SRB_FLAGS_NO_QUEUE_FREEZE);\n\t\tvm_srb->queue_tag = SP_UNTAGGED;\n\t\tvm_srb->queue_action = SRB_SIMPLE_TAG_REQUEST;\n\t}\n\n\t \n\tswitch (scmnd->sc_data_direction) {\n\tcase DMA_TO_DEVICE:\n\t\tvm_srb->data_in = WRITE_TYPE;\n\t\tvm_srb->srb_flags |= SRB_FLAGS_DATA_OUT;\n\t\tbreak;\n\tcase DMA_FROM_DEVICE:\n\t\tvm_srb->data_in = READ_TYPE;\n\t\tvm_srb->srb_flags |= SRB_FLAGS_DATA_IN;\n\t\tbreak;\n\tcase DMA_NONE:\n\t\tvm_srb->data_in = UNKNOWN_TYPE;\n\t\tvm_srb->srb_flags |= SRB_FLAGS_NO_DATA_TRANSFER;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN(1, \"Unexpected data direction: %d\\n\",\n\t\t     scmnd->sc_data_direction);\n\t\treturn -EINVAL;\n\t}\n\n\n\tvm_srb->port_number = host_dev->port;\n\tvm_srb->path_id = scmnd->device->channel;\n\tvm_srb->target_id = scmnd->device->id;\n\tvm_srb->lun = scmnd->device->lun;\n\n\tvm_srb->cdb_length = scmnd->cmd_len;\n\n\tmemcpy(vm_srb->cdb, scmnd->cmnd, vm_srb->cdb_length);\n\n\tsgl = (struct scatterlist *)scsi_sglist(scmnd);\n\n\tlength = scsi_bufflen(scmnd);\n\tpayload = (struct vmbus_packet_mpb_array *)&cmd_request->mpb;\n\tpayload_sz = 0;\n\n\tif (scsi_sg_count(scmnd)) {\n\t\tunsigned long offset_in_hvpg = offset_in_hvpage(sgl->offset);\n\t\tunsigned int hvpg_count = HVPFN_UP(offset_in_hvpg + length);\n\t\tstruct scatterlist *sg;\n\t\tunsigned long hvpfn, hvpfns_to_add;\n\t\tint j, i = 0, sg_count;\n\n\t\tpayload_sz = (hvpg_count * sizeof(u64) +\n\t\t\t      sizeof(struct vmbus_packet_mpb_array));\n\n\t\tif (hvpg_count > MAX_PAGE_BUFFER_COUNT) {\n\t\t\tpayload = kzalloc(payload_sz, GFP_ATOMIC);\n\t\t\tif (!payload)\n\t\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\t}\n\n\t\tpayload->range.len = length;\n\t\tpayload->range.offset = offset_in_hvpg;\n\n\t\tsg_count = scsi_dma_map(scmnd);\n\t\tif (sg_count < 0) {\n\t\t\tret = SCSI_MLQUEUE_DEVICE_BUSY;\n\t\t\tgoto err_free_payload;\n\t\t}\n\n\t\tfor_each_sg(sgl, sg, sg_count, j) {\n\t\t\t \n\t\t\thvpfn = HVPFN_DOWN(sg_dma_address(sg));\n\t\t\thvpfns_to_add = HVPFN_UP(sg_dma_address(sg) +\n\t\t\t\t\t\t sg_dma_len(sg)) - hvpfn;\n\n\t\t\t \n\t\t\twhile (hvpfns_to_add--)\n\t\t\t\tpayload->range.pfn_array[i++] = hvpfn++;\n\t\t}\n\t}\n\n\tcmd_request->payload = payload;\n\tcmd_request->payload_sz = payload_sz;\n\n\t \n\tret = storvsc_do_io(dev, cmd_request, get_cpu());\n\tput_cpu();\n\n\tif (ret)\n\t\tscsi_dma_unmap(scmnd);\n\n\tif (ret == -EAGAIN) {\n\t\t \n\t\tret = SCSI_MLQUEUE_DEVICE_BUSY;\n\t\tgoto err_free_payload;\n\t}\n\n\treturn 0;\n\nerr_free_payload:\n\tif (payload_sz > sizeof(cmd_request->mpb))\n\t\tkfree(payload);\n\n\treturn ret;\n}\n\nstatic struct scsi_host_template scsi_driver = {\n\t.module\t=\t\tTHIS_MODULE,\n\t.name =\t\t\t\"storvsc_host_t\",\n\t.cmd_size =             sizeof(struct storvsc_cmd_request),\n\t.bios_param =\t\tstorvsc_get_chs,\n\t.queuecommand =\t\tstorvsc_queuecommand,\n\t.eh_host_reset_handler =\tstorvsc_host_reset_handler,\n\t.proc_name =\t\t\"storvsc_host\",\n\t.eh_timed_out =\t\tstorvsc_eh_timed_out,\n\t.slave_alloc =\t\tstorvsc_device_alloc,\n\t.slave_configure =\tstorvsc_device_configure,\n\t.cmd_per_lun =\t\t2048,\n\t.this_id =\t\t-1,\n\t \n\t.virt_boundary_mask =\tHV_HYP_PAGE_SIZE - 1,\n\t.no_write_same =\t1,\n\t.track_queue_depth =\t1,\n\t.change_queue_depth =\tstorvsc_change_queue_depth,\n};\n\nenum {\n\tSCSI_GUID,\n\tIDE_GUID,\n\tSFC_GUID,\n};\n\nstatic const struct hv_vmbus_device_id id_table[] = {\n\t \n\t{ HV_SCSI_GUID,\n\t  .driver_data = SCSI_GUID\n\t},\n\t \n\t{ HV_IDE_GUID,\n\t  .driver_data = IDE_GUID\n\t},\n\t \n\t{\n\t  HV_SYNTHFC_GUID,\n\t  .driver_data = SFC_GUID\n\t},\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(vmbus, id_table);\n\nstatic const struct { guid_t guid; } fc_guid = { HV_SYNTHFC_GUID };\n\nstatic bool hv_dev_is_fc(struct hv_device *hv_dev)\n{\n\treturn guid_equal(&fc_guid.guid, &hv_dev->dev_type);\n}\n\nstatic int storvsc_probe(struct hv_device *device,\n\t\t\tconst struct hv_vmbus_device_id *dev_id)\n{\n\tint ret;\n\tint num_cpus = num_online_cpus();\n\tint num_present_cpus = num_present_cpus();\n\tstruct Scsi_Host *host;\n\tstruct hv_host_device *host_dev;\n\tbool dev_is_ide = ((dev_id->driver_data == IDE_GUID) ? true : false);\n\tbool is_fc = ((dev_id->driver_data == SFC_GUID) ? true : false);\n\tint target = 0;\n\tstruct storvsc_device *stor_device;\n\tint max_sub_channels = 0;\n\tu32 max_xfer_bytes;\n\n\t \n\tif (!dev_is_ide)\n\t\tmax_sub_channels =\n\t\t\t(num_cpus - 1) / storvsc_vcpus_per_sub_channel;\n\n\tscsi_driver.can_queue = max_outstanding_req_per_channel *\n\t\t\t\t(max_sub_channels + 1) *\n\t\t\t\t(100 - ring_avail_percent_lowater) / 100;\n\n\thost = scsi_host_alloc(&scsi_driver,\n\t\t\t       sizeof(struct hv_host_device));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost_dev = shost_priv(host);\n\tmemset(host_dev, 0, sizeof(struct hv_host_device));\n\n\thost_dev->port = host->host_no;\n\thost_dev->dev = device;\n\thost_dev->host = host;\n\n\n\tstor_device = kzalloc(sizeof(struct storvsc_device), GFP_KERNEL);\n\tif (!stor_device) {\n\t\tret = -ENOMEM;\n\t\tgoto err_out0;\n\t}\n\n\tstor_device->destroy = false;\n\tinit_waitqueue_head(&stor_device->waiting_to_drain);\n\tstor_device->device = device;\n\tstor_device->host = host;\n\tspin_lock_init(&stor_device->lock);\n\thv_set_drvdata(device, stor_device);\n\tdma_set_min_align_mask(&device->device, HV_HYP_PAGE_SIZE - 1);\n\n\tstor_device->port_number = host->host_no;\n\tret = storvsc_connect_to_vsp(device, storvsc_ringbuffer_size, is_fc);\n\tif (ret)\n\t\tgoto err_out1;\n\n\thost_dev->path = stor_device->path_id;\n\thost_dev->target = stor_device->target_id;\n\n\tswitch (dev_id->driver_data) {\n\tcase SFC_GUID:\n\t\thost->max_lun = STORVSC_FC_MAX_LUNS_PER_TARGET;\n\t\thost->max_id = STORVSC_FC_MAX_TARGETS;\n\t\thost->max_channel = STORVSC_FC_MAX_CHANNELS - 1;\n#if IS_ENABLED(CONFIG_SCSI_FC_ATTRS)\n\t\thost->transportt = fc_transport_template;\n#endif\n\t\tbreak;\n\n\tcase SCSI_GUID:\n\t\thost->max_lun = STORVSC_MAX_LUNS_PER_TARGET;\n\t\thost->max_id = STORVSC_MAX_TARGETS;\n\t\thost->max_channel = STORVSC_MAX_CHANNELS - 1;\n\t\tbreak;\n\n\tdefault:\n\t\thost->max_lun = STORVSC_IDE_MAX_LUNS_PER_TARGET;\n\t\thost->max_id = STORVSC_IDE_MAX_TARGETS;\n\t\thost->max_channel = STORVSC_IDE_MAX_CHANNELS - 1;\n\t\tbreak;\n\t}\n\t \n\thost->max_cmd_len = STORVSC_MAX_CMD_LEN;\n\t \n\tmax_xfer_bytes = round_down(stor_device->max_transfer_bytes, HV_HYP_PAGE_SIZE);\n\tif (is_fc)\n\t\tmax_xfer_bytes = min(max_xfer_bytes, STORVSC_FC_MAX_XFER_SIZE);\n\n\t \n\thost->max_sectors = max_xfer_bytes >> 9;\n\t \n\thost->sg_tablesize = (max_xfer_bytes >> HV_HYP_PAGE_SHIFT) + 1;\n\t \n\tif (!dev_is_ide) {\n\t\tif (storvsc_max_hw_queues > num_present_cpus) {\n\t\t\tstorvsc_max_hw_queues = 0;\n\t\t\tstorvsc_log(device, STORVSC_LOGGING_WARN,\n\t\t\t\t\"Resetting invalid storvsc_max_hw_queues value to default.\\n\");\n\t\t}\n\t\tif (storvsc_max_hw_queues)\n\t\t\thost->nr_hw_queues = storvsc_max_hw_queues;\n\t\telse\n\t\t\thost->nr_hw_queues = num_present_cpus;\n\t}\n\n\t \n\thost_dev->handle_error_wq =\n\t\t\talloc_ordered_workqueue(\"storvsc_error_wq_%d\",\n\t\t\t\t\t\t0,\n\t\t\t\t\t\thost->host_no);\n\tif (!host_dev->handle_error_wq) {\n\t\tret = -ENOMEM;\n\t\tgoto err_out2;\n\t}\n\tINIT_WORK(&host_dev->host_scan_work, storvsc_host_scan);\n\t \n\tret = scsi_add_host(host, &device->device);\n\tif (ret != 0)\n\t\tgoto err_out3;\n\n\tif (!dev_is_ide) {\n\t\tscsi_scan_host(host);\n\t} else {\n\t\ttarget = (device->dev_instance.b[5] << 8 |\n\t\t\t device->dev_instance.b[4]);\n\t\tret = scsi_add_device(host, 0, target, 0);\n\t\tif (ret)\n\t\t\tgoto err_out4;\n\t}\n#if IS_ENABLED(CONFIG_SCSI_FC_ATTRS)\n\tif (host->transportt == fc_transport_template) {\n\t\tstruct fc_rport_identifiers ids = {\n\t\t\t.roles = FC_PORT_ROLE_FCP_DUMMY_INITIATOR,\n\t\t};\n\n\t\tfc_host_node_name(host) = stor_device->node_name;\n\t\tfc_host_port_name(host) = stor_device->port_name;\n\t\tstor_device->rport = fc_remote_port_add(host, 0, &ids);\n\t\tif (!stor_device->rport) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_out4;\n\t\t}\n\t}\n#endif\n\treturn 0;\n\nerr_out4:\n\tscsi_remove_host(host);\n\nerr_out3:\n\tdestroy_workqueue(host_dev->handle_error_wq);\n\nerr_out2:\n\t \n\tstorvsc_dev_remove(device);\n\tgoto err_out0;\n\nerr_out1:\n\tkfree(stor_device->stor_chns);\n\tkfree(stor_device);\n\nerr_out0:\n\tscsi_host_put(host);\n\treturn ret;\n}\n\n \nstatic int storvsc_change_queue_depth(struct scsi_device *sdev, int queue_depth)\n{\n\tif (queue_depth > scsi_driver.can_queue)\n\t\tqueue_depth = scsi_driver.can_queue;\n\n\treturn scsi_change_queue_depth(sdev, queue_depth);\n}\n\nstatic void storvsc_remove(struct hv_device *dev)\n{\n\tstruct storvsc_device *stor_device = hv_get_drvdata(dev);\n\tstruct Scsi_Host *host = stor_device->host;\n\tstruct hv_host_device *host_dev = shost_priv(host);\n\n#if IS_ENABLED(CONFIG_SCSI_FC_ATTRS)\n\tif (host->transportt == fc_transport_template) {\n\t\tfc_remote_port_delete(stor_device->rport);\n\t\tfc_remove_host(host);\n\t}\n#endif\n\tdestroy_workqueue(host_dev->handle_error_wq);\n\tscsi_remove_host(host);\n\tstorvsc_dev_remove(dev);\n\tscsi_host_put(host);\n}\n\nstatic int storvsc_suspend(struct hv_device *hv_dev)\n{\n\tstruct storvsc_device *stor_device = hv_get_drvdata(hv_dev);\n\tstruct Scsi_Host *host = stor_device->host;\n\tstruct hv_host_device *host_dev = shost_priv(host);\n\n\tstorvsc_wait_to_drain(stor_device);\n\n\tdrain_workqueue(host_dev->handle_error_wq);\n\n\tvmbus_close(hv_dev->channel);\n\n\tkfree(stor_device->stor_chns);\n\tstor_device->stor_chns = NULL;\n\n\tcpumask_clear(&stor_device->alloced_cpus);\n\n\treturn 0;\n}\n\nstatic int storvsc_resume(struct hv_device *hv_dev)\n{\n\tint ret;\n\n\tret = storvsc_connect_to_vsp(hv_dev, storvsc_ringbuffer_size,\n\t\t\t\t     hv_dev_is_fc(hv_dev));\n\treturn ret;\n}\n\nstatic struct hv_driver storvsc_drv = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = id_table,\n\t.probe = storvsc_probe,\n\t.remove = storvsc_remove,\n\t.suspend = storvsc_suspend,\n\t.resume = storvsc_resume,\n\t.driver = {\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\n#if IS_ENABLED(CONFIG_SCSI_FC_ATTRS)\nstatic struct fc_function_template fc_transport_functions = {\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n};\n#endif\n\nstatic int __init storvsc_drv_init(void)\n{\n\tint ret;\n\n\t \n\tmax_outstanding_req_per_channel =\n\t\t((storvsc_ringbuffer_size - PAGE_SIZE) /\n\t\tALIGN(MAX_MULTIPAGE_BUFFER_PACKET +\n\t\tsizeof(struct vstor_packet) + sizeof(u64),\n\t\tsizeof(u64)));\n\n#if IS_ENABLED(CONFIG_SCSI_FC_ATTRS)\n\tfc_transport_template = fc_attach_transport(&fc_transport_functions);\n\tif (!fc_transport_template)\n\t\treturn -ENODEV;\n#endif\n\n\tret = vmbus_driver_register(&storvsc_drv);\n\n#if IS_ENABLED(CONFIG_SCSI_FC_ATTRS)\n\tif (ret)\n\t\tfc_release_transport(fc_transport_template);\n#endif\n\n\treturn ret;\n}\n\nstatic void __exit storvsc_drv_exit(void)\n{\n\tvmbus_driver_unregister(&storvsc_drv);\n#if IS_ENABLED(CONFIG_SCSI_FC_ATTRS)\n\tfc_release_transport(fc_transport_template);\n#endif\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Microsoft Hyper-V virtual storage driver\");\nmodule_init(storvsc_drv_init);\nmodule_exit(storvsc_drv_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}