{
  "module_name": "sun3x_esp.c",
  "hash_id": "d3cf532aabbb6a4f962fdea4dcf1f92df7d818ab01a74561537f033aec14b501",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sun3x_esp.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n\n#include <asm/sun3x.h>\n#include <asm/dma.h>\n#include <asm/dvma.h>\n\n \n#define DMA_CSR\t\t0x00UL\t \n#define DMA_ADDR        0x04UL\t \n#define DMA_COUNT       0x08UL\t \n#define DMA_TEST        0x0cUL\t \n\n#include <scsi/scsi_host.h>\n\n#include \"esp_scsi.h\"\n\n#define DRV_MODULE_NAME\t\t\"sun3x_esp\"\n#define PFX DRV_MODULE_NAME\t\": \"\n#define DRV_VERSION\t\t\"1.000\"\n#define DRV_MODULE_RELDATE\t\"Nov 1, 2007\"\n\n \n#if 0\n#define dma_read32(REG) \\\n\treadl(esp->dma_regs + (REG))\n#define dma_write32(VAL, REG) \\\n\twritel((VAL), esp->dma_regs + (REG))\n#else\n#define dma_read32(REG) \\\n\t*(volatile u32 *)(esp->dma_regs + (REG))\n#define dma_write32(VAL, REG) \\\n\tdo { *(volatile u32 *)(esp->dma_regs + (REG)) = (VAL); } while (0)\n#endif\n\nstatic void sun3x_esp_write8(struct esp *esp, u8 val, unsigned long reg)\n{\n\twriteb(val, esp->regs + (reg * 4UL));\n}\n\nstatic u8 sun3x_esp_read8(struct esp *esp, unsigned long reg)\n{\n\treturn readb(esp->regs + (reg * 4UL));\n}\n\nstatic int sun3x_esp_irq_pending(struct esp *esp)\n{\n\tif (dma_read32(DMA_CSR) & (DMA_HNDL_INTR | DMA_HNDL_ERROR))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void sun3x_esp_reset_dma(struct esp *esp)\n{\n\tu32 val;\n\n\tval = dma_read32(DMA_CSR);\n\tdma_write32(val | DMA_RST_SCSI, DMA_CSR);\n\tdma_write32(val & ~DMA_RST_SCSI, DMA_CSR);\n\n\t \n\tval = dma_read32(DMA_CSR);\n\tdma_write32(val | DMA_INT_ENAB, DMA_CSR);\n}\n\nstatic void sun3x_esp_dma_drain(struct esp *esp)\n{\n\tu32 csr;\n\tint lim;\n\n\tcsr = dma_read32(DMA_CSR);\n\tif (!(csr & DMA_FIFO_ISDRAIN))\n\t\treturn;\n\n\tdma_write32(csr | DMA_FIFO_STDRAIN, DMA_CSR);\n\n\tlim = 1000;\n\twhile (dma_read32(DMA_CSR) & DMA_FIFO_ISDRAIN) {\n\t\tif (--lim == 0) {\n\t\t\tprintk(KERN_ALERT PFX \"esp%d: DMA will not drain!\\n\",\n\t\t\t       esp->host->unique_id);\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1);\n\t}\n}\n\nstatic void sun3x_esp_dma_invalidate(struct esp *esp)\n{\n\tu32 val;\n\tint lim;\n\n\tlim = 1000;\n\twhile ((val = dma_read32(DMA_CSR)) & DMA_PEND_READ) {\n\t\tif (--lim == 0) {\n\t\t\tprintk(KERN_ALERT PFX \"esp%d: DMA will not \"\n\t\t\t       \"invalidate!\\n\", esp->host->unique_id);\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\tval &= ~(DMA_ENABLE | DMA_ST_WRITE | DMA_BCNT_ENAB);\n\tval |= DMA_FIFO_INV;\n\tdma_write32(val, DMA_CSR);\n\tval &= ~DMA_FIFO_INV;\n\tdma_write32(val, DMA_CSR);\n}\n\nstatic void sun3x_esp_send_dma_cmd(struct esp *esp, u32 addr, u32 esp_count,\n\t\t\t\t  u32 dma_count, int write, u8 cmd)\n{\n\tu32 csr;\n\n\tBUG_ON(!(cmd & ESP_CMD_DMA));\n\n\tsun3x_esp_write8(esp, (esp_count >> 0) & 0xff, ESP_TCLOW);\n\tsun3x_esp_write8(esp, (esp_count >> 8) & 0xff, ESP_TCMED);\n\tcsr = dma_read32(DMA_CSR);\n\tcsr |= DMA_ENABLE;\n\tif (write)\n\t\tcsr |= DMA_ST_WRITE;\n\telse\n\t\tcsr &= ~DMA_ST_WRITE;\n\tdma_write32(csr, DMA_CSR);\n\tdma_write32(addr, DMA_ADDR);\n\n\tscsi_esp_cmd(esp, cmd);\n}\n\nstatic int sun3x_esp_dma_error(struct esp *esp)\n{\n\tu32 csr = dma_read32(DMA_CSR);\n\n\tif (csr & DMA_HNDL_ERROR)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic const struct esp_driver_ops sun3x_esp_ops = {\n\t.esp_write8\t=\tsun3x_esp_write8,\n\t.esp_read8\t=\tsun3x_esp_read8,\n\t.irq_pending\t=\tsun3x_esp_irq_pending,\n\t.reset_dma\t=\tsun3x_esp_reset_dma,\n\t.dma_drain\t=\tsun3x_esp_dma_drain,\n\t.dma_invalidate\t=\tsun3x_esp_dma_invalidate,\n\t.send_dma_cmd\t=\tsun3x_esp_send_dma_cmd,\n\t.dma_error\t=\tsun3x_esp_dma_error,\n};\n\nstatic int esp_sun3x_probe(struct platform_device *dev)\n{\n\tconst struct scsi_host_template *tpnt = &scsi_esp_template;\n\tstruct Scsi_Host *host;\n\tstruct esp *esp;\n\tstruct resource *res;\n\tint err = -ENOMEM;\n\n\thost = scsi_host_alloc(tpnt, sizeof(struct esp));\n\tif (!host)\n\t\tgoto fail;\n\n\thost->max_id = 8;\n\tesp = shost_priv(host);\n\n\tesp->host = host;\n\tesp->dev = &dev->dev;\n\tesp->ops = &sun3x_esp_ops;\n\n\tres = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (!res || !res->start)\n\t\tgoto fail_unlink;\n\n\tesp->regs = ioremap(res->start, 0x20);\n\tif (!esp->regs)\n\t\tgoto fail_unmap_regs;\n\n\tres = platform_get_resource(dev, IORESOURCE_MEM, 1);\n\tif (!res || !res->start)\n\t\tgoto fail_unmap_regs;\n\n\tesp->dma_regs = ioremap(res->start, 0x10);\n\n\tesp->command_block = dma_alloc_coherent(esp->dev, 16,\n\t\t\t\t\t\t&esp->command_block_dma,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!esp->command_block)\n\t\tgoto fail_unmap_regs_dma;\n\n\thost->irq = err = platform_get_irq(dev, 0);\n\tif (err < 0)\n\t\tgoto fail_unmap_command_block;\n\terr = request_irq(host->irq, scsi_esp_intr, IRQF_SHARED,\n\t\t\t  \"SUN3X ESP\", esp);\n\tif (err < 0)\n\t\tgoto fail_unmap_command_block;\n\n\tesp->scsi_id = 7;\n\tesp->host->this_id = esp->scsi_id;\n\tesp->scsi_id_mask = (1 << esp->scsi_id);\n\tesp->cfreq = 20000000;\n\n\tdev_set_drvdata(&dev->dev, esp);\n\n\terr = scsi_esp_register(esp);\n\tif (err)\n\t\tgoto fail_free_irq;\n\n\treturn 0;\n\nfail_free_irq:\n\tfree_irq(host->irq, esp);\nfail_unmap_command_block:\n\tdma_free_coherent(esp->dev, 16,\n\t\t\t  esp->command_block,\n\t\t\t  esp->command_block_dma);\nfail_unmap_regs_dma:\n\tiounmap(esp->dma_regs);\nfail_unmap_regs:\n\tiounmap(esp->regs);\nfail_unlink:\n\tscsi_host_put(host);\nfail:\n\treturn err;\n}\n\nstatic int esp_sun3x_remove(struct platform_device *dev)\n{\n\tstruct esp *esp = dev_get_drvdata(&dev->dev);\n\tunsigned int irq = esp->host->irq;\n\tu32 val;\n\n\tscsi_esp_unregister(esp);\n\n\t \n\tval = dma_read32(DMA_CSR);\n\tdma_write32(val & ~DMA_INT_ENAB, DMA_CSR);\n\n\tfree_irq(irq, esp);\n\tdma_free_coherent(esp->dev, 16,\n\t\t\t  esp->command_block,\n\t\t\t  esp->command_block_dma);\n\n\tscsi_host_put(esp->host);\n\n\treturn 0;\n}\n\nstatic struct platform_driver esp_sun3x_driver = {\n\t.probe          = esp_sun3x_probe,\n\t.remove         = esp_sun3x_remove,\n\t.driver = {\n\t\t.name   = \"sun3x_esp\",\n\t},\n};\nmodule_platform_driver(esp_sun3x_driver);\n\nMODULE_DESCRIPTION(\"Sun3x ESP SCSI driver\");\nMODULE_AUTHOR(\"Thomas Bogendoerfer (tsbogend@alpha.franken.de)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_ALIAS(\"platform:sun3x_esp\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}