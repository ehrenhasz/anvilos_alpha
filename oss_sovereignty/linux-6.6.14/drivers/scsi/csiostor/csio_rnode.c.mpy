{
  "module_name": "csio_rnode.c",
  "hash_id": "7b9ebfd752031a7a3d49acf6f6fdaa948ce8c776e5e3dd0f306674f5c24e1936",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/csiostor/csio_rnode.c",
  "human_readable_source": " \n\n#include <linux/string.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/fc/fc_els.h>\n#include <scsi/fc/fc_fs.h>\n\n#include \"csio_hw.h\"\n#include \"csio_lnode.h\"\n#include \"csio_rnode.h\"\n\nstatic int csio_rnode_init(struct csio_rnode *, struct csio_lnode *);\nstatic void csio_rnode_exit(struct csio_rnode *);\n\n \nstatic void csio_rns_uninit(struct csio_rnode *, enum csio_rn_ev);\nstatic void csio_rns_ready(struct csio_rnode *, enum csio_rn_ev);\nstatic void csio_rns_offline(struct csio_rnode *, enum csio_rn_ev);\nstatic void csio_rns_disappeared(struct csio_rnode *, enum csio_rn_ev);\n\n \nstatic enum csio_rn_ev fwevt_to_rnevt[] = {\n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_LOGGED_IN,\t \n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_PLOGI_RECV,\t \n\tCSIO_RNFE_LOGO_RECV,\t \n\tCSIO_RNFE_PRLI_DONE,\t \n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_PRLI_RECV,\t \n\tCSIO_RNFE_PRLO_RECV,\t \n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_LOGO_RECV,\t \n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_LOGGED_IN,\t \n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_LOGGED_IN,\t \n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_NAME_MISSING,\t \n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_NONE,\t\t \n\tCSIO_RNFE_LOGO_RECV,\t \n};\n\n#define CSIO_FWE_TO_RNFE(_evt)\t((_evt > PROTO_ERR_IMPL_LOGO) ?\t\t\\\n\t\t\t\t\t\tCSIO_RNFE_NONE :\t\\\n\t\t\t\t\t\tfwevt_to_rnevt[_evt])\nint\ncsio_is_rnode_ready(struct csio_rnode *rn)\n{\n\treturn csio_match_state(rn, csio_rns_ready);\n}\n\nstatic int\ncsio_is_rnode_uninit(struct csio_rnode *rn)\n{\n\treturn csio_match_state(rn, csio_rns_uninit);\n}\n\nstatic int\ncsio_is_rnode_wka(uint8_t rport_type)\n{\n\tif ((rport_type == FLOGI_VFPORT) ||\n\t    (rport_type == FDISC_VFPORT) ||\n\t    (rport_type == NS_VNPORT) ||\n\t    (rport_type == FDMI_VNPORT))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic struct csio_rnode *\ncsio_rn_lookup(struct csio_lnode *ln, uint32_t flowid)\n{\n\tstruct csio_rnode *rnhead = (struct csio_rnode *) &ln->rnhead;\n\tstruct list_head *tmp;\n\tstruct csio_rnode *rn;\n\n\tlist_for_each(tmp, &rnhead->sm.sm_list) {\n\t\trn = (struct csio_rnode *) tmp;\n\t\tif (rn->flowid == flowid)\n\t\t\treturn rn;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct csio_rnode *\ncsio_rn_lookup_wwpn(struct csio_lnode *ln, uint8_t *wwpn)\n{\n\tstruct csio_rnode *rnhead = (struct csio_rnode *) &ln->rnhead;\n\tstruct list_head *tmp;\n\tstruct csio_rnode *rn;\n\n\tlist_for_each(tmp, &rnhead->sm.sm_list) {\n\t\trn = (struct csio_rnode *) tmp;\n\t\tif (!memcmp(csio_rn_wwpn(rn), wwpn, 8))\n\t\t\treturn rn;\n\t}\n\n\treturn NULL;\n}\n\n \nstruct csio_rnode *\ncsio_rnode_lookup_portid(struct csio_lnode *ln, uint32_t portid)\n{\n\tstruct csio_rnode *rnhead = (struct csio_rnode *) &ln->rnhead;\n\tstruct list_head *tmp;\n\tstruct csio_rnode *rn;\n\n\tlist_for_each(tmp, &rnhead->sm.sm_list) {\n\t\trn = (struct csio_rnode *) tmp;\n\t\tif (rn->nport_id == portid)\n\t\t\treturn rn;\n\t}\n\n\treturn NULL;\n}\n\nstatic int\ncsio_rn_dup_flowid(struct csio_lnode *ln, uint32_t rdev_flowid,\n\t\t    uint32_t *vnp_flowid)\n{\n\tstruct csio_rnode *rnhead;\n\tstruct list_head *tmp, *tmp1;\n\tstruct csio_rnode *rn;\n\tstruct csio_lnode *ln_tmp;\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\n\tlist_for_each(tmp1, &hw->sln_head) {\n\t\tln_tmp = (struct csio_lnode *) tmp1;\n\t\tif (ln_tmp == ln)\n\t\t\tcontinue;\n\n\t\trnhead = (struct csio_rnode *)&ln_tmp->rnhead;\n\t\tlist_for_each(tmp, &rnhead->sm.sm_list) {\n\n\t\t\trn = (struct csio_rnode *) tmp;\n\t\t\tif (csio_is_rnode_ready(rn)) {\n\t\t\t\tif (rn->flowid == rdev_flowid) {\n\t\t\t\t\t*vnp_flowid = csio_ln_flowid(ln_tmp);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct csio_rnode *\ncsio_alloc_rnode(struct csio_lnode *ln)\n{\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\n\tstruct csio_rnode *rn = mempool_alloc(hw->rnode_mempool, GFP_ATOMIC);\n\tif (!rn)\n\t\tgoto err;\n\n\tmemset(rn, 0, sizeof(struct csio_rnode));\n\tif (csio_rnode_init(rn, ln))\n\t\tgoto err_free;\n\n\tCSIO_INC_STATS(ln, n_rnode_alloc);\n\n\treturn rn;\n\nerr_free:\n\tmempool_free(rn, hw->rnode_mempool);\nerr:\n\tCSIO_INC_STATS(ln, n_rnode_nomem);\n\treturn NULL;\n}\n\nstatic void\ncsio_free_rnode(struct csio_rnode *rn)\n{\n\tstruct csio_hw *hw = csio_lnode_to_hw(csio_rnode_to_lnode(rn));\n\n\tcsio_rnode_exit(rn);\n\tCSIO_INC_STATS(rn->lnp, n_rnode_free);\n\tmempool_free(rn, hw->rnode_mempool);\n}\n\n \nstatic struct csio_rnode *\ncsio_get_rnode(struct csio_lnode *ln, uint32_t flowid)\n{\n\tstruct csio_rnode *rn;\n\n\trn = csio_rn_lookup(ln, flowid);\n\tif (!rn) {\n\t\trn = csio_alloc_rnode(ln);\n\t\tif (!rn)\n\t\t\treturn NULL;\n\n\t\trn->flowid = flowid;\n\t}\n\n\treturn rn;\n}\n\n \nvoid\ncsio_put_rnode(struct csio_lnode *ln, struct csio_rnode *rn)\n{\n\tCSIO_DB_ASSERT(csio_is_rnode_uninit(rn) != 0);\n\tcsio_free_rnode(rn);\n}\n\n \nstruct csio_rnode *\ncsio_confirm_rnode(struct csio_lnode *ln, uint32_t rdev_flowid,\n\t\t   struct fcoe_rdev_entry *rdevp)\n{\n\tuint8_t rport_type;\n\tstruct csio_rnode *rn, *match_rn;\n\tuint32_t vnp_flowid = 0;\n\t__be32 *port_id;\n\n\tport_id = (__be32 *)&rdevp->r_id[0];\n\trport_type =\n\t\tFW_RDEV_WR_RPORT_TYPE_GET(rdevp->rd_xfer_rdy_to_rport_type);\n\n\t \n\tif (rport_type == FAB_CTLR_VNPORT) {\n\t\tcsio_ln_dbg(ln,\n\t\t\t    \"Unhandled rport_type:%d recv in rdev evt \"\n\t\t\t    \"ssni:x%x\\n\", rport_type, rdev_flowid);\n\t\treturn NULL;\n\t}\n\n\t \n\trn = csio_rn_lookup(ln, rdev_flowid);\n\tif (!rn) {\n\n\t\t \n\t\tif (csio_rn_dup_flowid(ln, rdev_flowid, &vnp_flowid)) {\n\t\t\tcsio_ln_warn(ln,\n\t\t\t\t     \"ssni:%x already active on vnpi:%x\",\n\t\t\t\t     rdev_flowid, vnp_flowid);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\trn = csio_rn_lookup_wwpn(ln, rdevp->wwpn);\n\t\tif (!rn)\n\t\t\tgoto alloc_rnode;\n\n\t} else {\n\t\t \n\t\tif (csio_is_rnode_wka(rport_type)) {\n\t\t\tmatch_rn = csio_rnode_lookup_portid(ln,\n\t\t\t\t      ((ntohl(*port_id) >> 8) & CSIO_DID_MASK));\n\t\t\tif (match_rn == NULL) {\n\t\t\t\tcsio_rn_flowid(rn) = CSIO_INVALID_IDX;\n\t\t\t\tgoto alloc_rnode;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!memcmp(csio_rn_wwpn(match_rn), rdevp->wwpn, 8)) {\n\t\t\t\tif (rn == match_rn)\n\t\t\t\t\tgoto found_rnode;\n\t\t\t\tcsio_ln_dbg(ln,\n\t\t\t\t\t    \"nport_id:x%x and wwpn:%llx\"\n\t\t\t\t\t    \" match for ssni:x%x\\n\",\n\t\t\t\t\t    rn->nport_id,\n\t\t\t\t\t    wwn_to_u64(rdevp->wwpn),\n\t\t\t\t\t    rdev_flowid);\n\t\t\t\tif (csio_is_rnode_ready(rn)) {\n\t\t\t\t\tcsio_ln_warn(ln,\n\t\t\t\t\t\t     \"rnode is already\"\n\t\t\t\t\t\t     \"active ssni:x%x\\n\",\n\t\t\t\t\t\t     rdev_flowid);\n\t\t\t\t\tCSIO_ASSERT(0);\n\t\t\t\t}\n\t\t\t\tcsio_rn_flowid(rn) = CSIO_INVALID_IDX;\n\t\t\t\trn = match_rn;\n\n\t\t\t\t \n\t\t\t\tgoto found_rnode;\n\t\t\t}\n\t\t\tcsio_rn_flowid(rn) = CSIO_INVALID_IDX;\n\t\t\tgoto alloc_rnode;\n\t\t}\n\n\t\t \n\t\tif (!memcmp(csio_rn_wwpn(rn), rdevp->wwpn, 8))\n\t\t\tgoto found_rnode;\n\n\t\t \n\t\tmatch_rn = csio_rn_lookup_wwpn(ln, rdevp->wwpn);\n\t\tif (match_rn != NULL) {\n\t\t\tcsio_ln_dbg(ln,\n\t\t\t\t\"ssni:x%x changed for rport name(wwpn):%llx \"\n\t\t\t\t\"did:x%x\\n\", rdev_flowid,\n\t\t\t\twwn_to_u64(rdevp->wwpn),\n\t\t\t\tmatch_rn->nport_id);\n\t\t\tcsio_rn_flowid(rn) = CSIO_INVALID_IDX;\n\t\t\trn = match_rn;\n\t\t} else {\n\t\t\tcsio_ln_dbg(ln,\n\t\t\t\t\"rnode wwpn mismatch found ssni:x%x \"\n\t\t\t\t\"name(wwpn):%llx\\n\",\n\t\t\t\trdev_flowid,\n\t\t\t\twwn_to_u64(csio_rn_wwpn(rn)));\n\t\t\tif (csio_is_rnode_ready(rn)) {\n\t\t\t\tcsio_ln_warn(ln,\n\t\t\t\t\t     \"rnode is already active \"\n\t\t\t\t\t     \"wwpn:%llx ssni:x%x\\n\",\n\t\t\t\t\t     wwn_to_u64(csio_rn_wwpn(rn)),\n\t\t\t\t\t     rdev_flowid);\n\t\t\t\tCSIO_ASSERT(0);\n\t\t\t}\n\t\t\tcsio_rn_flowid(rn) = CSIO_INVALID_IDX;\n\t\t\tgoto alloc_rnode;\n\t\t}\n\t}\n\nfound_rnode:\n\tcsio_ln_dbg(ln, \"found rnode:%p ssni:x%x name(wwpn):%llx\\n\",\n\t\trn, rdev_flowid, wwn_to_u64(rdevp->wwpn));\n\n\t \n\tcsio_rn_flowid(rn) = rdev_flowid;\n\n\t \n\trn->rdev_entry = rdevp;\n\tCSIO_INC_STATS(ln, n_rnode_match);\n\treturn rn;\n\nalloc_rnode:\n\trn = csio_get_rnode(ln, rdev_flowid);\n\tif (!rn)\n\t\treturn NULL;\n\n\tcsio_ln_dbg(ln, \"alloc rnode:%p ssni:x%x name(wwpn):%llx\\n\",\n\t\trn, rdev_flowid, wwn_to_u64(rdevp->wwpn));\n\n\t \n\trn->rdev_entry = rdevp;\n\treturn rn;\n}\n\n \nstatic int\ncsio_rn_verify_rparams(struct csio_lnode *ln, struct csio_rnode *rn,\n\t\t\tstruct fcoe_rdev_entry *rdevp)\n{\n\tuint8_t null[8];\n\tuint8_t rport_type;\n\tuint8_t fc_class;\n\t__be32 *did;\n\n\tdid = (__be32 *) &rdevp->r_id[0];\n\trport_type =\n\t\tFW_RDEV_WR_RPORT_TYPE_GET(rdevp->rd_xfer_rdy_to_rport_type);\n\tswitch (rport_type) {\n\tcase FLOGI_VFPORT:\n\t\trn->role = CSIO_RNFR_FABRIC;\n\t\tif (((ntohl(*did) >> 8) & CSIO_DID_MASK) != FC_FID_FLOGI) {\n\t\t\tcsio_ln_err(ln, \"ssni:x%x invalid fabric portid\\n\",\n\t\t\t\tcsio_rn_flowid(rn));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (FW_RDEV_WR_NPIV_GET(rdevp->vft_to_qos))\n\t\t\tln->flags |= CSIO_LNF_NPIVSUPP;\n\n\t\tbreak;\n\n\tcase NS_VNPORT:\n\t\trn->role = CSIO_RNFR_NS;\n\t\tif (((ntohl(*did) >> 8) & CSIO_DID_MASK) != FC_FID_DIR_SERV) {\n\t\t\tcsio_ln_err(ln, \"ssni:x%x invalid fabric portid\\n\",\n\t\t\t\tcsio_rn_flowid(rn));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase REG_FC4_VNPORT:\n\tcase REG_VNPORT:\n\t\trn->role = CSIO_RNFR_NPORT;\n\t\tif (rdevp->event_cause == PRLI_ACC_RCVD ||\n\t\t\trdevp->event_cause == PRLI_RCVD) {\n\t\t\tif (FW_RDEV_WR_TASK_RETRY_ID_GET(\n\t\t\t\t\t\t\trdevp->enh_disc_to_tgt))\n\t\t\t\trn->fcp_flags |= FCP_SPPF_OVLY_ALLOW;\n\n\t\t\tif (FW_RDEV_WR_RETRY_GET(rdevp->enh_disc_to_tgt))\n\t\t\t\trn->fcp_flags |= FCP_SPPF_RETRY;\n\n\t\t\tif (FW_RDEV_WR_CONF_CMPL_GET(rdevp->enh_disc_to_tgt))\n\t\t\t\trn->fcp_flags |= FCP_SPPF_CONF_COMPL;\n\n\t\t\tif (FW_RDEV_WR_TGT_GET(rdevp->enh_disc_to_tgt))\n\t\t\t\trn->role |= CSIO_RNFR_TARGET;\n\n\t\t\tif (FW_RDEV_WR_INI_GET(rdevp->enh_disc_to_tgt))\n\t\t\t\trn->role |= CSIO_RNFR_INITIATOR;\n\t\t}\n\n\t\tbreak;\n\n\tcase FDMI_VNPORT:\n\tcase FAB_CTLR_VNPORT:\n\t\trn->role = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tcsio_ln_err(ln, \"ssni:x%x invalid rport type recv x%x\\n\",\n\t\t\tcsio_rn_flowid(rn), rport_type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rport_type == REG_VNPORT || rport_type == NS_VNPORT) {\n\t\tmemset(null, 0, 8);\n\t\tif (!memcmp(rdevp->wwnn, null, 8)) {\n\t\t\tcsio_ln_err(ln,\n\t\t\t\t    \"ssni:x%x invalid wwnn received from\"\n\t\t\t\t    \" rport did:x%x\\n\",\n\t\t\t\t    csio_rn_flowid(rn),\n\t\t\t\t    (ntohl(*did) & CSIO_DID_MASK));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!memcmp(rdevp->wwpn, null, 8)) {\n\t\t\tcsio_ln_err(ln,\n\t\t\t\t    \"ssni:x%x invalid wwpn received from\"\n\t\t\t\t    \" rport did:x%x\\n\",\n\t\t\t\t    csio_rn_flowid(rn),\n\t\t\t\t    (ntohl(*did) & CSIO_DID_MASK));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t}\n\n\t \n\trn->nport_id = (ntohl(*did) >> 8) & CSIO_DID_MASK;\n\tmemcpy(csio_rn_wwnn(rn), rdevp->wwnn, 8);\n\tmemcpy(csio_rn_wwpn(rn), rdevp->wwpn, 8);\n\trn->rn_sparm.csp.sp_bb_data = rdevp->rcv_fr_sz;\n\tfc_class = FW_RDEV_WR_CLASS_GET(rdevp->vft_to_qos);\n\trn->rn_sparm.clsp[fc_class - 1].cp_class = htons(FC_CPC_VALID);\n\n\treturn 0;\n}\n\nstatic void\n__csio_reg_rnode(struct csio_rnode *rn)\n{\n\tstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\n\tspin_unlock_irq(&hw->lock);\n\tcsio_reg_rnode(rn);\n\tspin_lock_irq(&hw->lock);\n\n\tif (rn->role & CSIO_RNFR_TARGET)\n\t\tln->n_scsi_tgts++;\n\n\tif (rn->nport_id == FC_FID_MGMT_SERV)\n\t\tcsio_ln_fdmi_start(ln, (void *) rn);\n}\n\nstatic void\n__csio_unreg_rnode(struct csio_rnode *rn)\n{\n\tstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\tLIST_HEAD(tmp_q);\n\tint cmpl = 0;\n\n\tif (!list_empty(&rn->host_cmpl_q)) {\n\t\tcsio_dbg(hw, \"Returning completion queue I/Os\\n\");\n\t\tlist_splice_tail_init(&rn->host_cmpl_q, &tmp_q);\n\t\tcmpl = 1;\n\t}\n\n\tif (rn->role & CSIO_RNFR_TARGET) {\n\t\tln->n_scsi_tgts--;\n\t\tln->last_scan_ntgts--;\n\t}\n\n\tspin_unlock_irq(&hw->lock);\n\tcsio_unreg_rnode(rn);\n\tspin_lock_irq(&hw->lock);\n\n\t \n\tif (cmpl)\n\t\tcsio_scsi_cleanup_io_q(csio_hw_to_scsim(hw), &tmp_q);\n\n}\n\n \n \n \n\n \nstatic void\ncsio_rns_uninit(struct csio_rnode *rn, enum csio_rn_ev evt)\n{\n\tstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\n\tint ret = 0;\n\n\tCSIO_INC_STATS(rn, n_evt_sm[evt]);\n\n\tswitch (evt) {\n\tcase CSIO_RNFE_LOGGED_IN:\n\tcase CSIO_RNFE_PLOGI_RECV:\n\t\tret = csio_rn_verify_rparams(ln, rn, rn->rdev_entry);\n\t\tif (!ret) {\n\t\t\tcsio_set_state(&rn->sm, csio_rns_ready);\n\t\t\t__csio_reg_rnode(rn);\n\t\t} else {\n\t\t\tCSIO_INC_STATS(rn, n_err_inval);\n\t\t}\n\t\tbreak;\n\tcase CSIO_RNFE_LOGO_RECV:\n\t\tcsio_ln_dbg(ln,\n\t\t\t    \"ssni:x%x Ignoring event %d recv \"\n\t\t\t    \"in rn state[uninit]\\n\", csio_rn_flowid(rn), evt);\n\t\tCSIO_INC_STATS(rn, n_evt_drop);\n\t\tbreak;\n\tdefault:\n\t\tcsio_ln_dbg(ln,\n\t\t\t    \"ssni:x%x unexp event %d recv \"\n\t\t\t    \"in rn state[uninit]\\n\", csio_rn_flowid(rn), evt);\n\t\tCSIO_INC_STATS(rn, n_evt_unexp);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\ncsio_rns_ready(struct csio_rnode *rn, enum csio_rn_ev evt)\n{\n\tstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\n\tint ret = 0;\n\n\tCSIO_INC_STATS(rn, n_evt_sm[evt]);\n\n\tswitch (evt) {\n\tcase CSIO_RNFE_LOGGED_IN:\n\tcase CSIO_RNFE_PLOGI_RECV:\n\t\tcsio_ln_dbg(ln,\n\t\t\t\"ssni:x%x Ignoring event %d recv from did:x%x \"\n\t\t\t\"in rn state[ready]\\n\", csio_rn_flowid(rn), evt,\n\t\t\trn->nport_id);\n\t\tCSIO_INC_STATS(rn, n_evt_drop);\n\t\tbreak;\n\n\tcase CSIO_RNFE_PRLI_DONE:\n\tcase CSIO_RNFE_PRLI_RECV:\n\t\tret = csio_rn_verify_rparams(ln, rn, rn->rdev_entry);\n\t\tif (!ret)\n\t\t\t__csio_reg_rnode(rn);\n\t\telse\n\t\t\tCSIO_INC_STATS(rn, n_err_inval);\n\n\t\tbreak;\n\tcase CSIO_RNFE_DOWN:\n\t\tcsio_set_state(&rn->sm, csio_rns_offline);\n\t\t__csio_unreg_rnode(rn);\n\n\t\t \n\t\tbreak;\n\n\tcase CSIO_RNFE_LOGO_RECV:\n\t\tcsio_set_state(&rn->sm, csio_rns_offline);\n\n\t\t__csio_unreg_rnode(rn);\n\n\t\t \n\t\tbreak;\n\n\tcase CSIO_RNFE_CLOSE:\n\t\t \n\t\tcsio_set_state(&rn->sm, csio_rns_uninit);\n\t\t__csio_unreg_rnode(rn);\n\t\tbreak;\n\n\tcase CSIO_RNFE_NAME_MISSING:\n\t\tcsio_set_state(&rn->sm, csio_rns_disappeared);\n\t\t__csio_unreg_rnode(rn);\n\n\t\t \n\n\t\tbreak;\n\n\tdefault:\n\t\tcsio_ln_dbg(ln,\n\t\t\t\"ssni:x%x unexp event %d recv from did:x%x \"\n\t\t\t\"in rn state[uninit]\\n\", csio_rn_flowid(rn), evt,\n\t\t\trn->nport_id);\n\t\tCSIO_INC_STATS(rn, n_evt_unexp);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\ncsio_rns_offline(struct csio_rnode *rn, enum csio_rn_ev evt)\n{\n\tstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\n\tint ret = 0;\n\n\tCSIO_INC_STATS(rn, n_evt_sm[evt]);\n\n\tswitch (evt) {\n\tcase CSIO_RNFE_LOGGED_IN:\n\tcase CSIO_RNFE_PLOGI_RECV:\n\t\tret = csio_rn_verify_rparams(ln, rn, rn->rdev_entry);\n\t\tif (!ret) {\n\t\t\tcsio_set_state(&rn->sm, csio_rns_ready);\n\t\t\t__csio_reg_rnode(rn);\n\t\t} else {\n\t\t\tCSIO_INC_STATS(rn, n_err_inval);\n\t\t\tcsio_post_event(&rn->sm, CSIO_RNFE_CLOSE);\n\t\t}\n\t\tbreak;\n\n\tcase CSIO_RNFE_DOWN:\n\t\tcsio_ln_dbg(ln,\n\t\t\t\"ssni:x%x Ignoring event %d recv from did:x%x \"\n\t\t\t\"in rn state[offline]\\n\", csio_rn_flowid(rn), evt,\n\t\t\trn->nport_id);\n\t\tCSIO_INC_STATS(rn, n_evt_drop);\n\t\tbreak;\n\n\tcase CSIO_RNFE_CLOSE:\n\t\t \n\t\tcsio_set_state(&rn->sm, csio_rns_uninit);\n\t\tbreak;\n\n\tcase CSIO_RNFE_NAME_MISSING:\n\t\tcsio_set_state(&rn->sm, csio_rns_disappeared);\n\t\tbreak;\n\n\tdefault:\n\t\tcsio_ln_dbg(ln,\n\t\t\t\"ssni:x%x unexp event %d recv from did:x%x \"\n\t\t\t\"in rn state[offline]\\n\", csio_rn_flowid(rn), evt,\n\t\t\trn->nport_id);\n\t\tCSIO_INC_STATS(rn, n_evt_unexp);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\ncsio_rns_disappeared(struct csio_rnode *rn, enum csio_rn_ev evt)\n{\n\tstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\n\tint ret = 0;\n\n\tCSIO_INC_STATS(rn, n_evt_sm[evt]);\n\n\tswitch (evt) {\n\tcase CSIO_RNFE_LOGGED_IN:\n\tcase CSIO_RNFE_PLOGI_RECV:\n\t\tret = csio_rn_verify_rparams(ln, rn, rn->rdev_entry);\n\t\tif (!ret) {\n\t\t\tcsio_set_state(&rn->sm, csio_rns_ready);\n\t\t\t__csio_reg_rnode(rn);\n\t\t} else {\n\t\t\tCSIO_INC_STATS(rn, n_err_inval);\n\t\t\tcsio_post_event(&rn->sm, CSIO_RNFE_CLOSE);\n\t\t}\n\t\tbreak;\n\n\tcase CSIO_RNFE_CLOSE:\n\t\t \n\t\tcsio_set_state(&rn->sm, csio_rns_uninit);\n\t\tbreak;\n\n\tcase CSIO_RNFE_DOWN:\n\tcase CSIO_RNFE_NAME_MISSING:\n\t\tcsio_ln_dbg(ln,\n\t\t\t\"ssni:x%x Ignoring event %d recv from did x%x\"\n\t\t\t\"in rn state[disappeared]\\n\", csio_rn_flowid(rn),\n\t\t\tevt, rn->nport_id);\n\t\tbreak;\n\n\tdefault:\n\t\tcsio_ln_dbg(ln,\n\t\t\t\"ssni:x%x unexp event %d recv from did x%x\"\n\t\t\t\"in rn state[disappeared]\\n\", csio_rn_flowid(rn),\n\t\t\tevt, rn->nport_id);\n\t\tCSIO_INC_STATS(rn, n_evt_unexp);\n\t\tbreak;\n\t}\n}\n\n \n \n \n\n \nvoid\ncsio_rnode_devloss_handler(struct csio_rnode *rn)\n{\n\tstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\n\n\t \n\tif (csio_is_rnode_ready(rn))\n\t\treturn;\n\n\tcsio_post_event(&rn->sm, CSIO_RNFE_CLOSE);\n\n\t \n\tif (csio_is_rnode_uninit(rn))\n\t\tcsio_put_rnode(ln, rn);\n}\n\n \nvoid\ncsio_rnode_fwevt_handler(struct csio_rnode *rn, uint8_t fwevt)\n{\n\tstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\n\tenum csio_rn_ev evt;\n\n\tevt = CSIO_FWE_TO_RNFE(fwevt);\n\tif (!evt) {\n\t\tcsio_ln_err(ln, \"ssni:x%x Unhandled FW Rdev event: %d\\n\",\n\t\t\t    csio_rn_flowid(rn), fwevt);\n\t\tCSIO_INC_STATS(rn, n_evt_unexp);\n\t\treturn;\n\t}\n\tCSIO_INC_STATS(rn, n_evt_fw[fwevt]);\n\n\t \n\trn->prev_evt = rn->cur_evt;\n\trn->cur_evt = fwevt;\n\n\t \n\tcsio_post_event(&rn->sm, evt);\n\n\t \n\tif (csio_is_rnode_uninit(rn))\n\t\tcsio_put_rnode(ln, rn);\n}\n\n \nstatic int\ncsio_rnode_init(struct csio_rnode *rn, struct csio_lnode *ln)\n{\n\tcsio_rnode_to_lnode(rn) = ln;\n\tcsio_init_state(&rn->sm, csio_rns_uninit);\n\tINIT_LIST_HEAD(&rn->host_cmpl_q);\n\tcsio_rn_flowid(rn) = CSIO_INVALID_IDX;\n\n\t \n\tlist_add_tail(&rn->sm.sm_list, &ln->rnhead);\n\n\treturn 0;\n}\n\nstatic void\ncsio_rnode_exit(struct csio_rnode *rn)\n{\n\tlist_del_init(&rn->sm.sm_list);\n\tCSIO_DB_ASSERT(list_empty(&rn->host_cmpl_q));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}