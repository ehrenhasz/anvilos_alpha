{
  "module_name": "csio_scsi.c",
  "hash_id": "6f126805837e816f05b34b61e87f8b952e3658d729eb84f83e8b5872d9390187",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/csiostor/csio_scsi.c",
  "human_readable_source": " \n\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/ctype.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <asm/unaligned.h>\n#include <asm/page.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_transport_fc.h>\n\n#include \"csio_hw.h\"\n#include \"csio_lnode.h\"\n#include \"csio_rnode.h\"\n#include \"csio_scsi.h\"\n#include \"csio_init.h\"\n\nint csio_scsi_eqsize = 65536;\nint csio_scsi_iqlen = 128;\nint csio_scsi_ioreqs = 2048;\nuint32_t csio_max_scan_tmo;\nuint32_t csio_delta_scan_tmo = 5;\nint csio_lun_qdepth = 32;\n\nstatic int csio_ddp_descs = 128;\n\nstatic int csio_do_abrt_cls(struct csio_hw *,\n\t\t\t\t      struct csio_ioreq *, bool);\n\nstatic void csio_scsis_uninit(struct csio_ioreq *, enum csio_scsi_ev);\nstatic void csio_scsis_io_active(struct csio_ioreq *, enum csio_scsi_ev);\nstatic void csio_scsis_tm_active(struct csio_ioreq *, enum csio_scsi_ev);\nstatic void csio_scsis_aborting(struct csio_ioreq *, enum csio_scsi_ev);\nstatic void csio_scsis_closing(struct csio_ioreq *, enum csio_scsi_ev);\nstatic void csio_scsis_shost_cmpl_await(struct csio_ioreq *, enum csio_scsi_ev);\n\n \nstatic bool\ncsio_scsi_match_io(struct csio_ioreq *ioreq, struct csio_scsi_level_data *sld)\n{\n\tstruct scsi_cmnd *scmnd = csio_scsi_cmnd(ioreq);\n\n\tswitch (sld->level) {\n\tcase CSIO_LEV_LUN:\n\t\tif (scmnd == NULL)\n\t\t\treturn false;\n\n\t\treturn ((ioreq->lnode == sld->lnode) &&\n\t\t\t(ioreq->rnode == sld->rnode) &&\n\t\t\t((uint64_t)scmnd->device->lun == sld->oslun));\n\n\tcase CSIO_LEV_RNODE:\n\t\treturn ((ioreq->lnode == sld->lnode) &&\n\t\t\t\t(ioreq->rnode == sld->rnode));\n\tcase CSIO_LEV_LNODE:\n\t\treturn (ioreq->lnode == sld->lnode);\n\tcase CSIO_LEV_ALL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic void\ncsio_scsi_gather_active_ios(struct csio_scsim *scm,\n\t\t\t    struct csio_scsi_level_data *sld,\n\t\t\t    struct list_head *dest)\n{\n\tstruct list_head *tmp, *next;\n\n\tif (list_empty(&scm->active_q))\n\t\treturn;\n\n\t \n\tif (sld->level == CSIO_LEV_ALL) {\n\t\tlist_splice_tail_init(&scm->active_q, dest);\n\t\treturn;\n\t}\n\n\tlist_for_each_safe(tmp, next, &scm->active_q) {\n\t\tif (csio_scsi_match_io((struct csio_ioreq *)tmp, sld)) {\n\t\t\tlist_del_init(tmp);\n\t\t\tlist_add_tail(tmp, dest);\n\t\t}\n\t}\n}\n\nstatic inline bool\ncsio_scsi_itnexus_loss_error(uint16_t error)\n{\n\tswitch (error) {\n\tcase FW_ERR_LINK_DOWN:\n\tcase FW_RDEV_NOT_READY:\n\tcase FW_ERR_RDEV_LOST:\n\tcase FW_ERR_RDEV_LOGO:\n\tcase FW_ERR_RDEV_IMPL_LOGO:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic inline void\ncsio_scsi_fcp_cmnd(struct csio_ioreq *req, void *addr)\n{\n\tstruct fcp_cmnd *fcp_cmnd = (struct fcp_cmnd *)addr;\n\tstruct scsi_cmnd *scmnd = csio_scsi_cmnd(req);\n\n\t \n\tif (likely(csio_priv(scmnd)->fc_tm_flags == 0)) {\n\t\tint_to_scsilun(scmnd->device->lun, &fcp_cmnd->fc_lun);\n\t\tfcp_cmnd->fc_tm_flags = 0;\n\t\tfcp_cmnd->fc_cmdref = 0;\n\n\t\tmemcpy(fcp_cmnd->fc_cdb, scmnd->cmnd, 16);\n\t\tfcp_cmnd->fc_pri_ta = FCP_PTA_SIMPLE;\n\t\tfcp_cmnd->fc_dl = cpu_to_be32(scsi_bufflen(scmnd));\n\n\t\tif (req->nsge)\n\t\t\tif (req->datadir == DMA_TO_DEVICE)\n\t\t\t\tfcp_cmnd->fc_flags = FCP_CFL_WRDATA;\n\t\t\telse\n\t\t\t\tfcp_cmnd->fc_flags = FCP_CFL_RDDATA;\n\t\telse\n\t\t\tfcp_cmnd->fc_flags = 0;\n\t} else {\n\t\tmemset(fcp_cmnd, 0, sizeof(*fcp_cmnd));\n\t\tint_to_scsilun(scmnd->device->lun, &fcp_cmnd->fc_lun);\n\t\tfcp_cmnd->fc_tm_flags = csio_priv(scmnd)->fc_tm_flags;\n\t}\n}\n\n \nstatic inline void\ncsio_scsi_init_cmd_wr(struct csio_ioreq *req, void *addr, uint32_t size)\n{\n\tstruct csio_hw *hw = req->lnode->hwp;\n\tstruct csio_rnode *rn = req->rnode;\n\tstruct fw_scsi_cmd_wr *wr = (struct fw_scsi_cmd_wr *)addr;\n\tstruct csio_dma_buf *dma_buf;\n\tuint8_t imm = csio_hw_to_scsim(hw)->proto_cmd_len;\n\n\twr->op_immdlen = cpu_to_be32(FW_WR_OP_V(FW_SCSI_CMD_WR) |\n\t\t\t\t\t  FW_SCSI_CMD_WR_IMMDLEN(imm));\n\twr->flowid_len16 = cpu_to_be32(FW_WR_FLOWID_V(rn->flowid) |\n\t\t\t\t\t    FW_WR_LEN16_V(\n\t\t\t\t\t\tDIV_ROUND_UP(size, 16)));\n\n\twr->cookie = (uintptr_t) req;\n\twr->iqid = cpu_to_be16(csio_q_physiqid(hw, req->iq_idx));\n\twr->tmo_val = (uint8_t) req->tmo;\n\twr->r3 = 0;\n\tmemset(&wr->r5, 0, 8);\n\n\t \n\tdma_buf = &req->dma_buf;\n\n\t \n\twr->rsp_dmalen = cpu_to_be32(dma_buf->len);\n\twr->rsp_dmaaddr = cpu_to_be64(dma_buf->paddr);\n\n\twr->r6 = 0;\n\n\twr->u.fcoe.ctl_pri = 0;\n\twr->u.fcoe.cp_en_class = 0;\n\twr->u.fcoe.r4_lo[0] = 0;\n\twr->u.fcoe.r4_lo[1] = 0;\n\n\t \n\tcsio_scsi_fcp_cmnd(req, (void *)((uintptr_t)addr +\n\t\t\t\t    sizeof(struct fw_scsi_cmd_wr)));\n}\n\n#define CSIO_SCSI_CMD_WR_SZ(_imm)\t\t\t\t\t\\\n\t(sizeof(struct fw_scsi_cmd_wr) +\t\t \t\\\n\t ALIGN((_imm), 16))\t\t\t\t \n\n#define CSIO_SCSI_CMD_WR_SZ_16(_imm)\t\t\t\t\t\\\n\t\t\t(ALIGN(CSIO_SCSI_CMD_WR_SZ((_imm)), 16))\n\n \nstatic inline void\ncsio_scsi_cmd(struct csio_ioreq *req)\n{\n\tstruct csio_wr_pair wrp;\n\tstruct csio_hw *hw = req->lnode->hwp;\n\tstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\n\tuint32_t size = CSIO_SCSI_CMD_WR_SZ_16(scsim->proto_cmd_len);\n\n\treq->drv_status = csio_wr_get(hw, req->eq_idx, size, &wrp);\n\tif (unlikely(req->drv_status != 0))\n\t\treturn;\n\n\tif (wrp.size1 >= size) {\n\t\t \n\t\tcsio_scsi_init_cmd_wr(req, wrp.addr1, size);\n\t} else {\n\t\tuint8_t *tmpwr = csio_q_eq_wrap(hw, req->eq_idx);\n\n\t\t \n\t\tcsio_scsi_init_cmd_wr(req, (void *)tmpwr, size);\n\t\tmemcpy(wrp.addr1, tmpwr, wrp.size1);\n\t\tmemcpy(wrp.addr2, tmpwr + wrp.size1, size - wrp.size1);\n\t}\n}\n\n \nstatic inline void\ncsio_scsi_init_ultptx_dsgl(struct csio_hw *hw, struct csio_ioreq *req,\n\t\t\t   struct ulptx_sgl *sgl)\n{\n\tstruct ulptx_sge_pair *sge_pair = NULL;\n\tstruct scatterlist *sgel;\n\tuint32_t i = 0;\n\tuint32_t xfer_len;\n\tstruct list_head *tmp;\n\tstruct csio_dma_buf *dma_buf;\n\tstruct scsi_cmnd *scmnd = csio_scsi_cmnd(req);\n\n\tsgl->cmd_nsge = htonl(ULPTX_CMD_V(ULP_TX_SC_DSGL) | ULPTX_MORE_F |\n\t\t\t\t     ULPTX_NSGE_V(req->nsge));\n\t \n\tif (likely(!req->dcopy)) {\n\t\tscsi_for_each_sg(scmnd, sgel, req->nsge, i) {\n\t\t\tif (i == 0) {\n\t\t\t\tsgl->addr0 = cpu_to_be64(sg_dma_address(sgel));\n\t\t\t\tsgl->len0 = cpu_to_be32(sg_dma_len(sgel));\n\t\t\t\tsge_pair = (struct ulptx_sge_pair *)(sgl + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((i - 1) & 0x1) {\n\t\t\t\tsge_pair->addr[1] = cpu_to_be64(\n\t\t\t\t\t\t\tsg_dma_address(sgel));\n\t\t\t\tsge_pair->len[1] = cpu_to_be32(\n\t\t\t\t\t\t\tsg_dma_len(sgel));\n\t\t\t\tsge_pair++;\n\t\t\t} else {\n\t\t\t\tsge_pair->addr[0] = cpu_to_be64(\n\t\t\t\t\t\t\tsg_dma_address(sgel));\n\t\t\t\tsge_pair->len[0] = cpu_to_be32(\n\t\t\t\t\t\t\tsg_dma_len(sgel));\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\txfer_len = scsi_bufflen(scmnd);\n\t\tlist_for_each(tmp, &req->gen_list) {\n\t\t\tdma_buf = (struct csio_dma_buf *)tmp;\n\t\t\tif (i == 0) {\n\t\t\t\tsgl->addr0 = cpu_to_be64(dma_buf->paddr);\n\t\t\t\tsgl->len0 = cpu_to_be32(\n\t\t\t\t\t\tmin(xfer_len, dma_buf->len));\n\t\t\t\tsge_pair = (struct ulptx_sge_pair *)(sgl + 1);\n\t\t\t} else if ((i - 1) & 0x1) {\n\t\t\t\tsge_pair->addr[1] = cpu_to_be64(dma_buf->paddr);\n\t\t\t\tsge_pair->len[1] = cpu_to_be32(\n\t\t\t\t\t\tmin(xfer_len, dma_buf->len));\n\t\t\t\tsge_pair++;\n\t\t\t} else {\n\t\t\t\tsge_pair->addr[0] = cpu_to_be64(dma_buf->paddr);\n\t\t\t\tsge_pair->len[0] = cpu_to_be32(\n\t\t\t\t\t\tmin(xfer_len, dma_buf->len));\n\t\t\t}\n\t\t\txfer_len -= min(xfer_len, dma_buf->len);\n\t\t\ti++;\n\t\t}\n\t}\n}\n\n \nstatic inline void\ncsio_scsi_init_read_wr(struct csio_ioreq *req, void *wrp, uint32_t size)\n{\n\tstruct csio_hw *hw = req->lnode->hwp;\n\tstruct csio_rnode *rn = req->rnode;\n\tstruct fw_scsi_read_wr *wr = (struct fw_scsi_read_wr *)wrp;\n\tstruct ulptx_sgl *sgl;\n\tstruct csio_dma_buf *dma_buf;\n\tuint8_t imm = csio_hw_to_scsim(hw)->proto_cmd_len;\n\tstruct scsi_cmnd *scmnd = csio_scsi_cmnd(req);\n\n\twr->op_immdlen = cpu_to_be32(FW_WR_OP_V(FW_SCSI_READ_WR) |\n\t\t\t\t     FW_SCSI_READ_WR_IMMDLEN(imm));\n\twr->flowid_len16 = cpu_to_be32(FW_WR_FLOWID_V(rn->flowid) |\n\t\t\t\t       FW_WR_LEN16_V(DIV_ROUND_UP(size, 16)));\n\twr->cookie = (uintptr_t)req;\n\twr->iqid = cpu_to_be16(csio_q_physiqid(hw, req->iq_idx));\n\twr->tmo_val = (uint8_t)(req->tmo);\n\twr->use_xfer_cnt = 1;\n\twr->xfer_cnt = cpu_to_be32(scsi_bufflen(scmnd));\n\twr->ini_xfer_cnt = cpu_to_be32(scsi_bufflen(scmnd));\n\t \n\tdma_buf = &req->dma_buf;\n\n\t \n\twr->rsp_dmalen = cpu_to_be32(dma_buf->len);\n\twr->rsp_dmaaddr = cpu_to_be64(dma_buf->paddr);\n\n\twr->r4 = 0;\n\n\twr->u.fcoe.ctl_pri = 0;\n\twr->u.fcoe.cp_en_class = 0;\n\twr->u.fcoe.r3_lo[0] = 0;\n\twr->u.fcoe.r3_lo[1] = 0;\n\tcsio_scsi_fcp_cmnd(req, (void *)((uintptr_t)wrp +\n\t\t\t\t\tsizeof(struct fw_scsi_read_wr)));\n\n\t \n\tsgl = (struct ulptx_sgl *)((uintptr_t)wrp +\n\t\t\t      sizeof(struct fw_scsi_read_wr) + ALIGN(imm, 16));\n\n\t \n\tcsio_scsi_init_ultptx_dsgl(hw, req, sgl);\n}\n\n \nstatic inline void\ncsio_scsi_init_write_wr(struct csio_ioreq *req, void *wrp, uint32_t size)\n{\n\tstruct csio_hw *hw = req->lnode->hwp;\n\tstruct csio_rnode *rn = req->rnode;\n\tstruct fw_scsi_write_wr *wr = (struct fw_scsi_write_wr *)wrp;\n\tstruct ulptx_sgl *sgl;\n\tstruct csio_dma_buf *dma_buf;\n\tuint8_t imm = csio_hw_to_scsim(hw)->proto_cmd_len;\n\tstruct scsi_cmnd *scmnd = csio_scsi_cmnd(req);\n\n\twr->op_immdlen = cpu_to_be32(FW_WR_OP_V(FW_SCSI_WRITE_WR) |\n\t\t\t\t     FW_SCSI_WRITE_WR_IMMDLEN(imm));\n\twr->flowid_len16 = cpu_to_be32(FW_WR_FLOWID_V(rn->flowid) |\n\t\t\t\t       FW_WR_LEN16_V(DIV_ROUND_UP(size, 16)));\n\twr->cookie = (uintptr_t)req;\n\twr->iqid = cpu_to_be16(csio_q_physiqid(hw, req->iq_idx));\n\twr->tmo_val = (uint8_t)(req->tmo);\n\twr->use_xfer_cnt = 1;\n\twr->xfer_cnt = cpu_to_be32(scsi_bufflen(scmnd));\n\twr->ini_xfer_cnt = cpu_to_be32(scsi_bufflen(scmnd));\n\t \n\tdma_buf = &req->dma_buf;\n\n\t \n\twr->rsp_dmalen = cpu_to_be32(dma_buf->len);\n\twr->rsp_dmaaddr = cpu_to_be64(dma_buf->paddr);\n\n\twr->r4 = 0;\n\n\twr->u.fcoe.ctl_pri = 0;\n\twr->u.fcoe.cp_en_class = 0;\n\twr->u.fcoe.r3_lo[0] = 0;\n\twr->u.fcoe.r3_lo[1] = 0;\n\tcsio_scsi_fcp_cmnd(req, (void *)((uintptr_t)wrp +\n\t\t\t\t\tsizeof(struct fw_scsi_write_wr)));\n\n\t \n\tsgl = (struct ulptx_sgl *)((uintptr_t)wrp +\n\t\t\t      sizeof(struct fw_scsi_write_wr) + ALIGN(imm, 16));\n\n\t \n\tcsio_scsi_init_ultptx_dsgl(hw, req, sgl);\n}\n\n \n#define CSIO_SCSI_DATA_WRSZ(req, oper, sz, imm)\t\t\t\t       \\\ndo {\t\t\t\t\t\t\t\t\t       \\\n\t(sz) = sizeof(struct fw_scsi_##oper##_wr) +\t           \\\n\t       ALIGN((imm), 16) +\t\t\t        \\\n\t       sizeof(struct ulptx_sgl);\t\t \t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\tif (unlikely((req)->nsge > 1))\t\t\t\t               \\\n\t\t(sz) += (sizeof(struct ulptx_sge_pair) *\t\t       \\\n\t\t\t\t(ALIGN(((req)->nsge - 1), 2) / 2));            \\\n\t\t\t\t\t\t\t \t       \\\n} while (0)\n\n \nstatic inline void\ncsio_scsi_read(struct csio_ioreq *req)\n{\n\tstruct csio_wr_pair wrp;\n\tuint32_t size;\n\tstruct csio_hw *hw = req->lnode->hwp;\n\tstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\n\n\tCSIO_SCSI_DATA_WRSZ(req, read, size, scsim->proto_cmd_len);\n\tsize = ALIGN(size, 16);\n\n\treq->drv_status = csio_wr_get(hw, req->eq_idx, size, &wrp);\n\tif (likely(req->drv_status == 0)) {\n\t\tif (likely(wrp.size1 >= size)) {\n\t\t\t \n\t\t\tcsio_scsi_init_read_wr(req, wrp.addr1, size);\n\t\t} else {\n\t\t\tuint8_t *tmpwr = csio_q_eq_wrap(hw, req->eq_idx);\n\t\t\t \n\t\t\tcsio_scsi_init_read_wr(req, (void *)tmpwr, size);\n\t\t\tmemcpy(wrp.addr1, tmpwr, wrp.size1);\n\t\t\tmemcpy(wrp.addr2, tmpwr + wrp.size1, size - wrp.size1);\n\t\t}\n\t}\n}\n\n \nstatic inline void\ncsio_scsi_write(struct csio_ioreq *req)\n{\n\tstruct csio_wr_pair wrp;\n\tuint32_t size;\n\tstruct csio_hw *hw = req->lnode->hwp;\n\tstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\n\n\tCSIO_SCSI_DATA_WRSZ(req, write, size, scsim->proto_cmd_len);\n\tsize = ALIGN(size, 16);\n\n\treq->drv_status = csio_wr_get(hw, req->eq_idx, size, &wrp);\n\tif (likely(req->drv_status == 0)) {\n\t\tif (likely(wrp.size1 >= size)) {\n\t\t\t \n\t\t\tcsio_scsi_init_write_wr(req, wrp.addr1, size);\n\t\t} else {\n\t\t\tuint8_t *tmpwr = csio_q_eq_wrap(hw, req->eq_idx);\n\t\t\t \n\t\t\tcsio_scsi_init_write_wr(req, (void *)tmpwr, size);\n\t\t\tmemcpy(wrp.addr1, tmpwr, wrp.size1);\n\t\t\tmemcpy(wrp.addr2, tmpwr + wrp.size1, size - wrp.size1);\n\t\t}\n\t}\n}\n\n \nstatic inline void\ncsio_setup_ddp(struct csio_scsim *scsim, struct csio_ioreq *req)\n{\n#ifdef __CSIO_DEBUG__\n\tstruct csio_hw *hw = req->lnode->hwp;\n#endif\n\tstruct scatterlist *sgel = NULL;\n\tstruct scsi_cmnd *scmnd = csio_scsi_cmnd(req);\n\tuint64_t sg_addr = 0;\n\tuint32_t ddp_pagesz = 4096;\n\tuint32_t buf_off;\n\tstruct csio_dma_buf *dma_buf = NULL;\n\tuint32_t alloc_len = 0;\n\tuint32_t xfer_len = 0;\n\tuint32_t sg_len = 0;\n\tuint32_t i;\n\n\tscsi_for_each_sg(scmnd, sgel, req->nsge, i) {\n\t\tsg_addr = sg_dma_address(sgel);\n\t\tsg_len\t= sg_dma_len(sgel);\n\n\t\tbuf_off = sg_addr & (ddp_pagesz - 1);\n\n\t\t \n\t\tif (i != 0 && buf_off) {\n\t\t\tcsio_dbg(hw, \"SGL addr not DDP aligned (%llx:%d)\\n\",\n\t\t\t\t sg_addr, sg_len);\n\t\t\tgoto unaligned;\n\t\t}\n\n\t\t \n\t\tif ((i != (req->nsge - 1)) &&\n\t\t\t((buf_off + sg_len) & (ddp_pagesz - 1))) {\n\t\t\tcsio_dbg(hw,\n\t\t\t\t \"SGL addr not ending on page boundary\"\n\t\t\t\t \"(%llx:%d)\\n\", sg_addr, sg_len);\n\t\t\tgoto unaligned;\n\t\t}\n\t}\n\n\t \n\treq->dcopy = 0;\n\tcsio_scsi_read(req);\n\n\treturn;\n\nunaligned:\n\tCSIO_INC_STATS(scsim, n_unaligned);\n\t \n\treq->dcopy = 1;\n\n\t \n\tINIT_LIST_HEAD(&req->gen_list);\n\txfer_len = scsi_bufflen(scmnd);\n\n\ti = 0;\n\t \n\twhile (alloc_len < xfer_len) {\n\t\tdma_buf = csio_get_scsi_ddp(scsim);\n\t\tif (dma_buf == NULL || i > scsim->max_sge) {\n\t\t\treq->drv_status = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_len += dma_buf->len;\n\t\t \n\t\tlist_add_tail(&dma_buf->list, &req->gen_list);\n\t\ti++;\n\t}\n\n\tif (!req->drv_status) {\n\t\t \n\t\treq->nsge = i;\n\t\tcsio_scsi_read(req);\n\t\treturn;\n\t}\n\n\t  \n\tif (i > 0)\n\t\tcsio_put_scsi_ddp_list(scsim, &req->gen_list, i);\n}\n\n \nstatic inline void\ncsio_scsi_init_abrt_cls_wr(struct csio_ioreq *req, void *addr, uint32_t size,\n\t\t\t   bool abort)\n{\n\tstruct csio_hw *hw = req->lnode->hwp;\n\tstruct csio_rnode *rn = req->rnode;\n\tstruct fw_scsi_abrt_cls_wr *wr = (struct fw_scsi_abrt_cls_wr *)addr;\n\n\twr->op_immdlen = cpu_to_be32(FW_WR_OP_V(FW_SCSI_ABRT_CLS_WR));\n\twr->flowid_len16 = cpu_to_be32(FW_WR_FLOWID_V(rn->flowid) |\n\t\t\t\t\t    FW_WR_LEN16_V(\n\t\t\t\t\t\tDIV_ROUND_UP(size, 16)));\n\n\twr->cookie = (uintptr_t) req;\n\twr->iqid = cpu_to_be16(csio_q_physiqid(hw, req->iq_idx));\n\twr->tmo_val = (uint8_t) req->tmo;\n\t \n\twr->sub_opcode_to_chk_all_io =\n\t\t\t\t(FW_SCSI_ABRT_CLS_WR_SUB_OPCODE(abort) |\n\t\t\t\t FW_SCSI_ABRT_CLS_WR_CHK_ALL_IO(0));\n\twr->r3[0] = 0;\n\twr->r3[1] = 0;\n\twr->r3[2] = 0;\n\twr->r3[3] = 0;\n\t \n\twr->t_cookie = (uintptr_t) req;\n}\n\nstatic inline void\ncsio_scsi_abrt_cls(struct csio_ioreq *req, bool abort)\n{\n\tstruct csio_wr_pair wrp;\n\tstruct csio_hw *hw = req->lnode->hwp;\n\tuint32_t size = ALIGN(sizeof(struct fw_scsi_abrt_cls_wr), 16);\n\n\treq->drv_status = csio_wr_get(hw, req->eq_idx, size, &wrp);\n\tif (req->drv_status != 0)\n\t\treturn;\n\n\tif (wrp.size1 >= size) {\n\t\t \n\t\tcsio_scsi_init_abrt_cls_wr(req, wrp.addr1, size, abort);\n\t} else {\n\t\tuint8_t *tmpwr = csio_q_eq_wrap(hw, req->eq_idx);\n\t\t \n\t\tcsio_scsi_init_abrt_cls_wr(req, (void *)tmpwr, size, abort);\n\t\tmemcpy(wrp.addr1, tmpwr, wrp.size1);\n\t\tmemcpy(wrp.addr2, tmpwr + wrp.size1, size - wrp.size1);\n\t}\n}\n\n \n \n \nstatic void\ncsio_scsis_uninit(struct csio_ioreq *req, enum csio_scsi_ev evt)\n{\n\tstruct csio_hw *hw = req->lnode->hwp;\n\tstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\n\n\tswitch (evt) {\n\tcase CSIO_SCSIE_START_IO:\n\n\t\tif (req->nsge) {\n\t\t\tif (req->datadir == DMA_TO_DEVICE) {\n\t\t\t\treq->dcopy = 0;\n\t\t\t\tcsio_scsi_write(req);\n\t\t\t} else\n\t\t\t\tcsio_setup_ddp(scsim, req);\n\t\t} else {\n\t\t\tcsio_scsi_cmd(req);\n\t\t}\n\n\t\tif (likely(req->drv_status == 0)) {\n\t\t\t \n\t\t\tcsio_set_state(&req->sm, csio_scsis_io_active);\n\t\t\tlist_add_tail(&req->sm.sm_list, &scsim->active_q);\n\t\t\tcsio_wr_issue(hw, req->eq_idx, false);\n\t\t\tCSIO_INC_STATS(scsim, n_active);\n\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase CSIO_SCSIE_START_TM:\n\t\tcsio_scsi_cmd(req);\n\t\tif (req->drv_status == 0) {\n\t\t\t \n\t\t\tcsio_set_state(&req->sm, csio_scsis_tm_active);\n\t\t\tlist_add_tail(&req->sm.sm_list, &scsim->active_q);\n\t\t\tcsio_wr_issue(hw, req->eq_idx, false);\n\t\t\tCSIO_INC_STATS(scsim, n_tm_active);\n\t\t}\n\t\treturn;\n\n\tcase CSIO_SCSIE_ABORT:\n\tcase CSIO_SCSIE_CLOSE:\n\t\t \n\t\treq->drv_status = -EINVAL;\n\t\tcsio_warn(hw, \"Trying to abort/close completed IO:%p!\\n\", req);\n\t\tbreak;\n\n\tdefault:\n\t\tcsio_dbg(hw, \"Unhandled event:%d sent to req:%p\\n\", evt, req);\n\t\tCSIO_DB_ASSERT(0);\n\t}\n}\n\nstatic void\ncsio_scsis_io_active(struct csio_ioreq *req, enum csio_scsi_ev evt)\n{\n\tstruct csio_hw *hw = req->lnode->hwp;\n\tstruct csio_scsim *scm = csio_hw_to_scsim(hw);\n\tstruct csio_rnode *rn;\n\n\tswitch (evt) {\n\tcase CSIO_SCSIE_COMPLETED:\n\t\tCSIO_DEC_STATS(scm, n_active);\n\t\tlist_del_init(&req->sm.sm_list);\n\t\tcsio_set_state(&req->sm, csio_scsis_uninit);\n\t\t \n\t\tif (unlikely(req->wr_status != FW_SUCCESS)) {\n\t\t\trn = req->rnode;\n\t\t\t \n\t\t\tif (csio_scsi_itnexus_loss_error(req->wr_status) &&\n\t\t\t\t\t\tcsio_is_rnode_ready(rn)) {\n\t\t\t\tcsio_set_state(&req->sm,\n\t\t\t\t\t\tcsio_scsis_shost_cmpl_await);\n\t\t\t\tlist_add_tail(&req->sm.sm_list,\n\t\t\t\t\t      &rn->host_cmpl_q);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase CSIO_SCSIE_ABORT:\n\t\tcsio_scsi_abrt_cls(req, SCSI_ABORT);\n\t\tif (req->drv_status == 0) {\n\t\t\tcsio_wr_issue(hw, req->eq_idx, false);\n\t\t\tcsio_set_state(&req->sm, csio_scsis_aborting);\n\t\t}\n\t\tbreak;\n\n\tcase CSIO_SCSIE_CLOSE:\n\t\tcsio_scsi_abrt_cls(req, SCSI_CLOSE);\n\t\tif (req->drv_status == 0) {\n\t\t\tcsio_wr_issue(hw, req->eq_idx, false);\n\t\t\tcsio_set_state(&req->sm, csio_scsis_closing);\n\t\t}\n\t\tbreak;\n\n\tcase CSIO_SCSIE_DRVCLEANUP:\n\t\treq->wr_status = FW_HOSTERROR;\n\t\tCSIO_DEC_STATS(scm, n_active);\n\t\tcsio_set_state(&req->sm, csio_scsis_uninit);\n\t\tbreak;\n\n\tdefault:\n\t\tcsio_dbg(hw, \"Unhandled event:%d sent to req:%p\\n\", evt, req);\n\t\tCSIO_DB_ASSERT(0);\n\t}\n}\n\nstatic void\ncsio_scsis_tm_active(struct csio_ioreq *req, enum csio_scsi_ev evt)\n{\n\tstruct csio_hw *hw = req->lnode->hwp;\n\tstruct csio_scsim *scm = csio_hw_to_scsim(hw);\n\n\tswitch (evt) {\n\tcase CSIO_SCSIE_COMPLETED:\n\t\tCSIO_DEC_STATS(scm, n_tm_active);\n\t\tlist_del_init(&req->sm.sm_list);\n\t\tcsio_set_state(&req->sm, csio_scsis_uninit);\n\n\t\tbreak;\n\n\tcase CSIO_SCSIE_ABORT:\n\t\tcsio_scsi_abrt_cls(req, SCSI_ABORT);\n\t\tif (req->drv_status == 0) {\n\t\t\tcsio_wr_issue(hw, req->eq_idx, false);\n\t\t\tcsio_set_state(&req->sm, csio_scsis_aborting);\n\t\t}\n\t\tbreak;\n\n\n\tcase CSIO_SCSIE_CLOSE:\n\t\tcsio_scsi_abrt_cls(req, SCSI_CLOSE);\n\t\tif (req->drv_status == 0) {\n\t\t\tcsio_wr_issue(hw, req->eq_idx, false);\n\t\t\tcsio_set_state(&req->sm, csio_scsis_closing);\n\t\t}\n\t\tbreak;\n\n\tcase CSIO_SCSIE_DRVCLEANUP:\n\t\treq->wr_status = FW_HOSTERROR;\n\t\tCSIO_DEC_STATS(scm, n_tm_active);\n\t\tcsio_set_state(&req->sm, csio_scsis_uninit);\n\t\tbreak;\n\n\tdefault:\n\t\tcsio_dbg(hw, \"Unhandled event:%d sent to req:%p\\n\", evt, req);\n\t\tCSIO_DB_ASSERT(0);\n\t}\n}\n\nstatic void\ncsio_scsis_aborting(struct csio_ioreq *req, enum csio_scsi_ev evt)\n{\n\tstruct csio_hw *hw = req->lnode->hwp;\n\tstruct csio_scsim *scm = csio_hw_to_scsim(hw);\n\n\tswitch (evt) {\n\tcase CSIO_SCSIE_COMPLETED:\n\t\tcsio_dbg(hw,\n\t\t\t \"ioreq %p recvd cmpltd (wr_status:%d) \"\n\t\t\t \"in aborting st\\n\", req, req->wr_status);\n\t\t \n\t\treq->drv_status = -ECANCELED;\n\t\tbreak;\n\n\tcase CSIO_SCSIE_ABORT:\n\t\tCSIO_INC_STATS(scm, n_abrt_dups);\n\t\tbreak;\n\n\tcase CSIO_SCSIE_ABORTED:\n\n\t\tcsio_dbg(hw, \"abort of %p return status:0x%x drv_status:%x\\n\",\n\t\t\t req, req->wr_status, req->drv_status);\n\t\t \n\t\tif (req->drv_status != -ECANCELED) {\n\t\t\tcsio_warn(hw,\n\t\t\t\t  \"Abort completed before original I/O,\"\n\t\t\t\t   \" req:%p\\n\", req);\n\t\t\tCSIO_DB_ASSERT(0);\n\t\t}\n\n\t\t \n\t\tif ((req->wr_status == FW_SUCCESS) ||\n\t\t    (req->wr_status == FW_EINVAL) ||\n\t\t    csio_scsi_itnexus_loss_error(req->wr_status))\n\t\t\treq->wr_status = FW_SCSI_ABORT_REQUESTED;\n\n\t\tCSIO_DEC_STATS(scm, n_active);\n\t\tlist_del_init(&req->sm.sm_list);\n\t\tcsio_set_state(&req->sm, csio_scsis_uninit);\n\t\tbreak;\n\n\tcase CSIO_SCSIE_DRVCLEANUP:\n\t\treq->wr_status = FW_HOSTERROR;\n\t\tCSIO_DEC_STATS(scm, n_active);\n\t\tcsio_set_state(&req->sm, csio_scsis_uninit);\n\t\tbreak;\n\n\tcase CSIO_SCSIE_CLOSE:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tcsio_dbg(hw, \"Unhandled event:%d sent to req:%p\\n\", evt, req);\n\t\tCSIO_DB_ASSERT(0);\n\t}\n}\n\nstatic void\ncsio_scsis_closing(struct csio_ioreq *req, enum csio_scsi_ev evt)\n{\n\tstruct csio_hw *hw = req->lnode->hwp;\n\tstruct csio_scsim *scm = csio_hw_to_scsim(hw);\n\n\tswitch (evt) {\n\tcase CSIO_SCSIE_COMPLETED:\n\t\tcsio_dbg(hw,\n\t\t\t \"ioreq %p recvd cmpltd (wr_status:%d) \"\n\t\t\t \"in closing st\\n\", req, req->wr_status);\n\t\t \n\t\treq->drv_status = -ECANCELED;\n\t\tbreak;\n\n\tcase CSIO_SCSIE_CLOSED:\n\t\t \n\t\tif (req->drv_status != -ECANCELED) {\n\t\t\tcsio_fatal(hw,\n\t\t\t\t   \"Close completed before original I/O,\"\n\t\t\t\t   \" req:%p\\n\", req);\n\t\t\tCSIO_DB_ASSERT(0);\n\t\t}\n\n\t\t \n\t\tCSIO_DB_ASSERT((req->wr_status == FW_SUCCESS) ||\n\t\t\t\t\t(req->wr_status == FW_EINVAL));\n\t\treq->wr_status = FW_SCSI_CLOSE_REQUESTED;\n\n\t\tCSIO_DEC_STATS(scm, n_active);\n\t\tlist_del_init(&req->sm.sm_list);\n\t\tcsio_set_state(&req->sm, csio_scsis_uninit);\n\t\tbreak;\n\n\tcase CSIO_SCSIE_CLOSE:\n\t\tbreak;\n\n\tcase CSIO_SCSIE_DRVCLEANUP:\n\t\treq->wr_status = FW_HOSTERROR;\n\t\tCSIO_DEC_STATS(scm, n_active);\n\t\tcsio_set_state(&req->sm, csio_scsis_uninit);\n\t\tbreak;\n\n\tdefault:\n\t\tcsio_dbg(hw, \"Unhandled event:%d sent to req:%p\\n\", evt, req);\n\t\tCSIO_DB_ASSERT(0);\n\t}\n}\n\nstatic void\ncsio_scsis_shost_cmpl_await(struct csio_ioreq *req, enum csio_scsi_ev evt)\n{\n\tswitch (evt) {\n\tcase CSIO_SCSIE_ABORT:\n\tcase CSIO_SCSIE_CLOSE:\n\t\t \n\t\t \n\t\treq->drv_status = 0;\n\t\tbreak;\n\tcase CSIO_SCSIE_DRVCLEANUP:\n\t\tcsio_set_state(&req->sm, csio_scsis_uninit);\n\t\tbreak;\n\tdefault:\n\t\tcsio_dbg(req->lnode->hwp, \"Unhandled event:%d sent to req:%p\\n\",\n\t\t\t evt, req);\n\t\tCSIO_DB_ASSERT(0);\n\t}\n}\n\n \nstruct csio_ioreq *\ncsio_scsi_cmpl_handler(struct csio_hw *hw, void *wr, uint32_t len,\n\t\t     struct csio_fl_dma_buf *flb, void *priv, uint8_t **scsiwr)\n{\n\tstruct csio_ioreq *ioreq = NULL;\n\tstruct cpl_fw6_msg *cpl;\n\tuint8_t *tempwr;\n\tuint8_t\tstatus;\n\tstruct csio_scsim *scm = csio_hw_to_scsim(hw);\n\n\t \n\tcpl = (struct cpl_fw6_msg *)((uintptr_t)wr + sizeof(__be64));\n\n\tif (unlikely(cpl->opcode != CPL_FW6_MSG)) {\n\t\tcsio_warn(hw, \"Error: Invalid CPL msg %x recvd on SCSI q\\n\",\n\t\t\t  cpl->opcode);\n\t\tCSIO_INC_STATS(scm, n_inval_cplop);\n\t\treturn NULL;\n\t}\n\n\ttempwr = (uint8_t *)(cpl->data);\n\tstatus = csio_wr_status(tempwr);\n\t*scsiwr = tempwr;\n\n\tif (likely((*tempwr == FW_SCSI_READ_WR) ||\n\t\t\t(*tempwr == FW_SCSI_WRITE_WR) ||\n\t\t\t(*tempwr == FW_SCSI_CMD_WR))) {\n\t\tioreq = (struct csio_ioreq *)((uintptr_t)\n\t\t\t\t (((struct fw_scsi_read_wr *)tempwr)->cookie));\n\t\tCSIO_DB_ASSERT(virt_addr_valid(ioreq));\n\n\t\tioreq->wr_status = status;\n\n\t\treturn ioreq;\n\t}\n\n\tif (*tempwr == FW_SCSI_ABRT_CLS_WR) {\n\t\tioreq = (struct csio_ioreq *)((uintptr_t)\n\t\t\t (((struct fw_scsi_abrt_cls_wr *)tempwr)->cookie));\n\t\tCSIO_DB_ASSERT(virt_addr_valid(ioreq));\n\n\t\tioreq->wr_status = status;\n\t\treturn ioreq;\n\t}\n\n\tcsio_warn(hw, \"WR with invalid opcode in SCSI IQ: %x\\n\", *tempwr);\n\tCSIO_INC_STATS(scm, n_inval_scsiop);\n\treturn NULL;\n}\n\n \nvoid\ncsio_scsi_cleanup_io_q(struct csio_scsim *scm, struct list_head *q)\n{\n\tstruct csio_hw *hw = scm->hw;\n\tstruct csio_ioreq *ioreq;\n\tstruct list_head *tmp, *next;\n\tstruct scsi_cmnd *scmnd;\n\n\t \n\tlist_for_each_safe(tmp, next, q) {\n\t\tioreq = (struct csio_ioreq *)tmp;\n\t\tcsio_scsi_drvcleanup(ioreq);\n\t\tlist_del_init(&ioreq->sm.sm_list);\n\t\tscmnd = csio_scsi_cmnd(ioreq);\n\t\tspin_unlock_irq(&hw->lock);\n\n\t\t \n\t\tif (scmnd != NULL)\n\t\t\tioreq->io_cbfn(hw, ioreq);\n\n\t\tspin_lock_irq(&scm->freelist_lock);\n\t\tcsio_put_scsi_ioreq(scm, ioreq);\n\t\tspin_unlock_irq(&scm->freelist_lock);\n\n\t\tspin_lock_irq(&hw->lock);\n\t}\n}\n\n#define CSIO_SCSI_ABORT_Q_POLL_MS\t\t2000\n\nstatic void\ncsio_abrt_cls(struct csio_ioreq *ioreq, struct scsi_cmnd *scmnd)\n{\n\tstruct csio_lnode *ln = ioreq->lnode;\n\tstruct csio_hw *hw = ln->hwp;\n\tint ready = 0;\n\tstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\n\tint rv;\n\n\tif (csio_scsi_cmnd(ioreq) != scmnd) {\n\t\tCSIO_INC_STATS(scsim, n_abrt_race_comp);\n\t\treturn;\n\t}\n\n\tready = csio_is_lnode_ready(ln);\n\n\trv = csio_do_abrt_cls(hw, ioreq, (ready ? SCSI_ABORT : SCSI_CLOSE));\n\tif (rv != 0) {\n\t\tif (ready)\n\t\t\tCSIO_INC_STATS(scsim, n_abrt_busy_error);\n\t\telse\n\t\t\tCSIO_INC_STATS(scsim, n_cls_busy_error);\n\t}\n}\n\n \nstatic int\ncsio_scsi_abort_io_q(struct csio_scsim *scm, struct list_head *q, uint32_t tmo)\n{\n\tstruct csio_hw *hw = scm->hw;\n\tstruct list_head *tmp, *next;\n\tint count = DIV_ROUND_UP(tmo, CSIO_SCSI_ABORT_Q_POLL_MS);\n\tstruct scsi_cmnd *scmnd;\n\n\tif (list_empty(q))\n\t\treturn 0;\n\n\tcsio_dbg(hw, \"Aborting SCSI I/Os\\n\");\n\n\t \n\tlist_for_each_safe(tmp, next, q) {\n\t\tscmnd = csio_scsi_cmnd((struct csio_ioreq *)tmp);\n\t\tcsio_abrt_cls((struct csio_ioreq *)tmp, scmnd);\n\t}\n\n\t \n\twhile (!list_empty(q) && count--) {\n\t\tspin_unlock_irq(&hw->lock);\n\t\tmsleep(CSIO_SCSI_ABORT_Q_POLL_MS);\n\t\tspin_lock_irq(&hw->lock);\n\t}\n\n\t \n\tif (list_empty(q))\n\t\treturn 0;\n\n\treturn -ETIMEDOUT;\n}\n\n \nint\ncsio_scsim_cleanup_io(struct csio_scsim *scm, bool abort)\n{\n\tstruct csio_hw *hw = scm->hw;\n\tint rv = 0;\n\tint count = DIV_ROUND_UP(60 * 1000, CSIO_SCSI_ABORT_Q_POLL_MS);\n\n\t \n\tif (list_empty(&scm->active_q))\n\t\treturn 0;\n\n\t \n\twhile (!list_empty(&scm->active_q) && count--) {\n\t\tspin_unlock_irq(&hw->lock);\n\t\tmsleep(CSIO_SCSI_ABORT_Q_POLL_MS);\n\t\tspin_lock_irq(&hw->lock);\n\t}\n\n\t \n\tif (list_empty(&scm->active_q))\n\t\treturn 0;\n\n\t \n\tif (abort) {\n\t\trv = csio_scsi_abort_io_q(scm, &scm->active_q, 30000);\n\t\tif (rv == 0)\n\t\t\treturn rv;\n\t\tcsio_dbg(hw, \"Some I/O aborts timed out, cleaning up..\\n\");\n\t}\n\n\tcsio_scsi_cleanup_io_q(scm, &scm->active_q);\n\n\tCSIO_DB_ASSERT(list_empty(&scm->active_q));\n\n\treturn rv;\n}\n\n \nint\ncsio_scsim_cleanup_io_lnode(struct csio_scsim *scm, struct csio_lnode *ln)\n{\n\tstruct csio_hw *hw = scm->hw;\n\tstruct csio_scsi_level_data sld;\n\tint rv;\n\tint count = DIV_ROUND_UP(60 * 1000, CSIO_SCSI_ABORT_Q_POLL_MS);\n\n\tcsio_dbg(hw, \"Gathering all SCSI I/Os on lnode %p\\n\", ln);\n\n\tsld.level = CSIO_LEV_LNODE;\n\tsld.lnode = ln;\n\tINIT_LIST_HEAD(&ln->cmpl_q);\n\tcsio_scsi_gather_active_ios(scm, &sld, &ln->cmpl_q);\n\n\t \n\tif (list_empty(&ln->cmpl_q))\n\t\treturn 0;\n\n\t \n\twhile (!list_empty(&ln->cmpl_q) && count--) {\n\t\tspin_unlock_irq(&hw->lock);\n\t\tmsleep(CSIO_SCSI_ABORT_Q_POLL_MS);\n\t\tspin_lock_irq(&hw->lock);\n\t}\n\n\t \n\tif (list_empty(&ln->cmpl_q))\n\t\treturn 0;\n\n\tcsio_dbg(hw, \"Some I/Os pending on ln:%p, aborting them..\\n\", ln);\n\n\t \n\trv = csio_scsi_abort_io_q(scm, &ln->cmpl_q, 30000);\n\tif (rv != 0) {\n\t\tcsio_dbg(hw, \"Some I/O aborts timed out, cleaning up..\\n\");\n\t\tcsio_scsi_cleanup_io_q(scm, &ln->cmpl_q);\n\t}\n\n\tCSIO_DB_ASSERT(list_empty(&ln->cmpl_q));\n\n\treturn rv;\n}\n\nstatic ssize_t\ncsio_show_hw_state(struct device *dev,\n\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct csio_lnode *ln = shost_priv(class_to_shost(dev));\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\n\tif (csio_is_hw_ready(hw))\n\t\treturn sysfs_emit(buf, \"ready\\n\");\n\n\treturn sysfs_emit(buf, \"not ready\\n\");\n}\n\n \nstatic ssize_t\ncsio_device_reset(struct device *dev,\n\t\t   struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct csio_lnode *ln = shost_priv(class_to_shost(dev));\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\n\tif (*buf != '1')\n\t\treturn -EINVAL;\n\n\t \n\tcsio_lnodes_exit(hw, 1);\n\n\t \n\tcsio_lnodes_block_request(hw);\n\n\tspin_lock_irq(&hw->lock);\n\tcsio_hw_reset(hw);\n\tspin_unlock_irq(&hw->lock);\n\n\t \n\tcsio_lnodes_unblock_request(hw);\n\treturn count;\n}\n\n \nstatic ssize_t\ncsio_disable_port(struct device *dev,\n\t\t   struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct csio_lnode *ln = shost_priv(class_to_shost(dev));\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\tbool disable;\n\n\tif (*buf == '1' || *buf == '0')\n\t\tdisable = (*buf == '1') ? true : false;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tcsio_lnodes_block_by_port(hw, ln->portid);\n\n\tspin_lock_irq(&hw->lock);\n\tcsio_disable_lnodes(hw, ln->portid, disable);\n\tspin_unlock_irq(&hw->lock);\n\n\t \n\tcsio_lnodes_unblock_by_port(hw, ln->portid);\n\treturn count;\n}\n\n \nstatic ssize_t\ncsio_show_dbg_level(struct device *dev,\n\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct csio_lnode *ln = shost_priv(class_to_shost(dev));\n\n\treturn sysfs_emit(buf, \"%x\\n\", ln->params.log_level);\n}\n\n \nstatic ssize_t\ncsio_store_dbg_level(struct device *dev,\n\t\t   struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct csio_lnode *ln = shost_priv(class_to_shost(dev));\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\tuint32_t dbg_level = 0;\n\n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\n\tif (sscanf(buf, \"%i\", &dbg_level))\n\t\treturn -EINVAL;\n\n\tln->params.log_level = dbg_level;\n\thw->params.log_level = dbg_level;\n\n\treturn 0;\n}\n\nstatic DEVICE_ATTR(hw_state, S_IRUGO, csio_show_hw_state, NULL);\nstatic DEVICE_ATTR(device_reset, S_IWUSR, NULL, csio_device_reset);\nstatic DEVICE_ATTR(disable_port, S_IWUSR, NULL, csio_disable_port);\nstatic DEVICE_ATTR(dbg_level, S_IRUGO | S_IWUSR, csio_show_dbg_level,\n\t\t  csio_store_dbg_level);\n\nstatic struct attribute *csio_fcoe_lport_attrs[] = {\n\t&dev_attr_hw_state.attr,\n\t&dev_attr_device_reset.attr,\n\t&dev_attr_disable_port.attr,\n\t&dev_attr_dbg_level.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(csio_fcoe_lport);\n\nstatic ssize_t\ncsio_show_num_reg_rnodes(struct device *dev,\n\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct csio_lnode *ln = shost_priv(class_to_shost(dev));\n\n\treturn sysfs_emit(buf, \"%d\\n\", ln->num_reg_rnodes);\n}\n\nstatic DEVICE_ATTR(num_reg_rnodes, S_IRUGO, csio_show_num_reg_rnodes, NULL);\n\nstatic struct attribute *csio_fcoe_vport_attrs[] = {\n\t&dev_attr_num_reg_rnodes.attr,\n\t&dev_attr_dbg_level.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(csio_fcoe_vport);\n\nstatic inline uint32_t\ncsio_scsi_copy_to_sgl(struct csio_hw *hw, struct csio_ioreq *req)\n{\n\tstruct scsi_cmnd *scmnd  = (struct scsi_cmnd *)csio_scsi_cmnd(req);\n\tstruct scatterlist *sg;\n\tuint32_t bytes_left;\n\tuint32_t bytes_copy;\n\tuint32_t buf_off = 0;\n\tuint32_t start_off = 0;\n\tuint32_t sg_off = 0;\n\tvoid *sg_addr;\n\tvoid *buf_addr;\n\tstruct csio_dma_buf *dma_buf;\n\n\tbytes_left = scsi_bufflen(scmnd);\n\tsg = scsi_sglist(scmnd);\n\tdma_buf = (struct csio_dma_buf *)csio_list_next(&req->gen_list);\n\n\t \n\twhile (bytes_left > 0 && sg && dma_buf) {\n\t\tif (buf_off >= dma_buf->len) {\n\t\t\tbuf_off = 0;\n\t\t\tdma_buf = (struct csio_dma_buf *)\n\t\t\t\t\tcsio_list_next(dma_buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (start_off >= sg->length) {\n\t\t\tstart_off -= sg->length;\n\t\t\tsg = sg_next(sg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuf_addr = dma_buf->vaddr + buf_off;\n\t\tsg_off = sg->offset + start_off;\n\t\tbytes_copy = min((dma_buf->len - buf_off),\n\t\t\t\tsg->length - start_off);\n\t\tbytes_copy = min((uint32_t)(PAGE_SIZE - (sg_off & ~PAGE_MASK)),\n\t\t\t\t bytes_copy);\n\n\t\tsg_addr = kmap_atomic(sg_page(sg) + (sg_off >> PAGE_SHIFT));\n\t\tif (!sg_addr) {\n\t\t\tcsio_err(hw, \"failed to kmap sg:%p of ioreq:%p\\n\",\n\t\t\t\tsg, req);\n\t\t\tbreak;\n\t\t}\n\n\t\tcsio_dbg(hw, \"copy_to_sgl:sg_addr %p sg_off %d buf %p len %d\\n\",\n\t\t\t\tsg_addr, sg_off, buf_addr, bytes_copy);\n\t\tmemcpy(sg_addr + (sg_off & ~PAGE_MASK), buf_addr, bytes_copy);\n\t\tkunmap_atomic(sg_addr);\n\n\t\tstart_off +=  bytes_copy;\n\t\tbuf_off += bytes_copy;\n\t\tbytes_left -= bytes_copy;\n\t}\n\n\tif (bytes_left > 0)\n\t\treturn DID_ERROR;\n\telse\n\t\treturn DID_OK;\n}\n\n \nstatic inline void\ncsio_scsi_err_handler(struct csio_hw *hw, struct csio_ioreq *req)\n{\n\tstruct scsi_cmnd *cmnd  = (struct scsi_cmnd *)csio_scsi_cmnd(req);\n\tstruct csio_scsim *scm = csio_hw_to_scsim(hw);\n\tstruct fcp_resp_with_ext *fcp_resp;\n\tstruct fcp_resp_rsp_info *rsp_info;\n\tstruct csio_dma_buf *dma_buf;\n\tuint8_t flags, scsi_status = 0;\n\tuint32_t host_status = DID_OK;\n\tuint32_t rsp_len = 0, sns_len = 0;\n\tstruct csio_rnode *rn = (struct csio_rnode *)(cmnd->device->hostdata);\n\n\n\tswitch (req->wr_status) {\n\tcase FW_HOSTERROR:\n\t\tif (unlikely(!csio_is_hw_ready(hw)))\n\t\t\treturn;\n\n\t\thost_status = DID_ERROR;\n\t\tCSIO_INC_STATS(scm, n_hosterror);\n\n\t\tbreak;\n\tcase FW_SCSI_RSP_ERR:\n\t\tdma_buf = &req->dma_buf;\n\t\tfcp_resp = (struct fcp_resp_with_ext *)dma_buf->vaddr;\n\t\trsp_info = (struct fcp_resp_rsp_info *)(fcp_resp + 1);\n\t\tflags = fcp_resp->resp.fr_flags;\n\t\tscsi_status = fcp_resp->resp.fr_status;\n\n\t\tif (flags & FCP_RSP_LEN_VAL) {\n\t\t\trsp_len = be32_to_cpu(fcp_resp->ext.fr_rsp_len);\n\t\t\tif ((rsp_len != 0 && rsp_len != 4 && rsp_len != 8) ||\n\t\t\t\t(rsp_info->rsp_code != FCP_TMF_CMPL)) {\n\t\t\t\thost_status = DID_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & FCP_SNS_LEN_VAL) && fcp_resp->ext.fr_sns_len) {\n\t\t\tsns_len = be32_to_cpu(fcp_resp->ext.fr_sns_len);\n\t\t\tif (sns_len > SCSI_SENSE_BUFFERSIZE)\n\t\t\t\tsns_len = SCSI_SENSE_BUFFERSIZE;\n\n\t\t\tmemcpy(cmnd->sense_buffer,\n\t\t\t       &rsp_info->_fr_resvd[0] + rsp_len, sns_len);\n\t\t\tCSIO_INC_STATS(scm, n_autosense);\n\t\t}\n\n\t\tscsi_set_resid(cmnd, 0);\n\n\t\t \n\t\tif (flags & FCP_RESID_UNDER) {\n\t\t\tscsi_set_resid(cmnd,\n\t\t\t\t       be32_to_cpu(fcp_resp->ext.fr_resid));\n\n\t\t\tif (!(flags & FCP_SNS_LEN_VAL) &&\n\t\t\t    (scsi_status == SAM_STAT_GOOD) &&\n\t\t\t    ((scsi_bufflen(cmnd) - scsi_get_resid(cmnd))\n\t\t\t\t\t\t\t< cmnd->underflow))\n\t\t\t\thost_status = DID_ERROR;\n\t\t} else if (flags & FCP_RESID_OVER)\n\t\t\thost_status = DID_ERROR;\n\n\t\tCSIO_INC_STATS(scm, n_rsperror);\n\t\tbreak;\n\n\tcase FW_SCSI_OVER_FLOW_ERR:\n\t\tcsio_warn(hw,\n\t\t\t  \"Over-flow error,cmnd:0x%x expected len:0x%x\"\n\t\t\t  \" resid:0x%x\\n\", cmnd->cmnd[0],\n\t\t\t  scsi_bufflen(cmnd), scsi_get_resid(cmnd));\n\t\thost_status = DID_ERROR;\n\t\tCSIO_INC_STATS(scm, n_ovflerror);\n\t\tbreak;\n\n\tcase FW_SCSI_UNDER_FLOW_ERR:\n\t\tcsio_warn(hw,\n\t\t\t  \"Under-flow error,cmnd:0x%x expected\"\n\t\t\t  \" len:0x%x resid:0x%x lun:0x%llx ssn:0x%x\\n\",\n\t\t\t  cmnd->cmnd[0], scsi_bufflen(cmnd),\n\t\t\t  scsi_get_resid(cmnd), cmnd->device->lun,\n\t\t\t  rn->flowid);\n\t\thost_status = DID_ERROR;\n\t\tCSIO_INC_STATS(scm, n_unflerror);\n\t\tbreak;\n\n\tcase FW_SCSI_ABORT_REQUESTED:\n\tcase FW_SCSI_ABORTED:\n\tcase FW_SCSI_CLOSE_REQUESTED:\n\t\tcsio_dbg(hw, \"Req %p cmd:%p op:%x %s\\n\", req, cmnd,\n\t\t\t     cmnd->cmnd[0],\n\t\t\t    (req->wr_status == FW_SCSI_CLOSE_REQUESTED) ?\n\t\t\t    \"closed\" : \"aborted\");\n\t\t \n\t\thost_status = DID_REQUEUE;\n\t\tif (req->wr_status == FW_SCSI_CLOSE_REQUESTED)\n\t\t\tCSIO_INC_STATS(scm, n_closed);\n\t\telse\n\t\t\tCSIO_INC_STATS(scm, n_aborted);\n\t\tbreak;\n\n\tcase FW_SCSI_ABORT_TIMEDOUT:\n\t\t \n\t\tcsio_dbg(hw, \"FW timed out abort req:%p cmnd:%p status:%x\\n\",\n\t\t\t req, cmnd, req->wr_status);\n\t\thost_status = DID_ERROR;\n\t\tCSIO_INC_STATS(scm, n_abrt_timedout);\n\t\tbreak;\n\n\tcase FW_RDEV_NOT_READY:\n\t\t \n\t\tCSIO_INC_STATS(scm, n_rdev_nr_error);\n\t\thost_status = DID_ERROR;\n\t\tbreak;\n\n\tcase FW_ERR_RDEV_LOST:\n\t\tCSIO_INC_STATS(scm, n_rdev_lost_error);\n\t\thost_status = DID_ERROR;\n\t\tbreak;\n\n\tcase FW_ERR_RDEV_LOGO:\n\t\tCSIO_INC_STATS(scm, n_rdev_logo_error);\n\t\thost_status = DID_ERROR;\n\t\tbreak;\n\n\tcase FW_ERR_RDEV_IMPL_LOGO:\n\t\thost_status = DID_ERROR;\n\t\tbreak;\n\n\tcase FW_ERR_LINK_DOWN:\n\t\tCSIO_INC_STATS(scm, n_link_down_error);\n\t\thost_status = DID_ERROR;\n\t\tbreak;\n\n\tcase FW_FCOE_NO_XCHG:\n\t\tCSIO_INC_STATS(scm, n_no_xchg_error);\n\t\thost_status = DID_ERROR;\n\t\tbreak;\n\n\tdefault:\n\t\tcsio_err(hw, \"Unknown SCSI FW WR status:%d req:%p cmnd:%p\\n\",\n\t\t\t    req->wr_status, req, cmnd);\n\t\tCSIO_DB_ASSERT(0);\n\n\t\tCSIO_INC_STATS(scm, n_unknown_error);\n\t\thost_status = DID_ERROR;\n\t\tbreak;\n\t}\n\nout:\n\tif (req->nsge > 0) {\n\t\tscsi_dma_unmap(cmnd);\n\t\tif (req->dcopy && (host_status == DID_OK))\n\t\t\thost_status = csio_scsi_copy_to_sgl(hw, req);\n\t}\n\n\tcmnd->result = (((host_status) << 16) | scsi_status);\n\tscsi_done(cmnd);\n\n\t \n\tcsio_scsi_cmnd(req) = NULL;\n\tcomplete(&req->cmplobj);\n}\n\n \nstatic void\ncsio_scsi_cbfn(struct csio_hw *hw, struct csio_ioreq *req)\n{\n\tstruct scsi_cmnd *cmnd  = (struct scsi_cmnd *)csio_scsi_cmnd(req);\n\tuint8_t scsi_status = SAM_STAT_GOOD;\n\tuint32_t host_status = DID_OK;\n\n\tif (likely(req->wr_status == FW_SUCCESS)) {\n\t\tif (req->nsge > 0) {\n\t\t\tscsi_dma_unmap(cmnd);\n\t\t\tif (req->dcopy)\n\t\t\t\thost_status = csio_scsi_copy_to_sgl(hw, req);\n\t\t}\n\n\t\tcmnd->result = (((host_status) << 16) | scsi_status);\n\t\tscsi_done(cmnd);\n\t\tcsio_scsi_cmnd(req) = NULL;\n\t\tCSIO_INC_STATS(csio_hw_to_scsim(hw), n_tot_success);\n\t} else {\n\t\t \n\t\tcsio_scsi_err_handler(hw, req);\n\t}\n}\n\n \nstatic int\ncsio_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmnd)\n{\n\tstruct csio_lnode *ln = shost_priv(host);\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\tstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\n\tstruct csio_rnode *rn = (struct csio_rnode *)(cmnd->device->hostdata);\n\tstruct csio_ioreq *ioreq = NULL;\n\tunsigned long flags;\n\tint nsge = 0;\n\tint rv = SCSI_MLQUEUE_HOST_BUSY, nr;\n\tint retval;\n\tstruct csio_scsi_qset *sqset;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(cmnd->device));\n\n\tsqset = &hw->sqset[ln->portid][blk_mq_rq_cpu(scsi_cmd_to_rq(cmnd))];\n\n\tnr = fc_remote_port_chkready(rport);\n\tif (nr) {\n\t\tcmnd->result = nr;\n\t\tCSIO_INC_STATS(scsim, n_rn_nr_error);\n\t\tgoto err_done;\n\t}\n\n\tif (unlikely(!csio_is_hw_ready(hw))) {\n\t\tcmnd->result = (DID_REQUEUE << 16);\n\t\tCSIO_INC_STATS(scsim, n_hw_nr_error);\n\t\tgoto err_done;\n\t}\n\n\t \n\tnsge = scsi_dma_map(cmnd);\n\tif (unlikely(nsge < 0)) {\n\t\tCSIO_INC_STATS(scsim, n_dmamap_error);\n\t\tgoto err;\n\t}\n\n\t \n\tif (unlikely(nsge > scsim->max_sge)) {\n\t\tcsio_warn(hw,\n\t\t\t  \"More SGEs than can be supported.\"\n\t\t\t  \" SGEs: %d, Max SGEs: %d\\n\", nsge, scsim->max_sge);\n\t\tCSIO_INC_STATS(scsim, n_unsupp_sge_error);\n\t\tgoto err_dma_unmap;\n\t}\n\n\t \n\tioreq = csio_get_scsi_ioreq_lock(hw, scsim);\n\tif (!ioreq) {\n\t\tcsio_err(hw, \"Out of I/O request elements. Active #:%d\\n\",\n\t\t\t scsim->stats.n_active);\n\t\tCSIO_INC_STATS(scsim, n_no_req_error);\n\t\tgoto err_dma_unmap;\n\t}\n\n\tioreq->nsge\t\t= nsge;\n\tioreq->lnode\t\t= ln;\n\tioreq->rnode\t\t= rn;\n\tioreq->iq_idx\t\t= sqset->iq_idx;\n\tioreq->eq_idx\t\t= sqset->eq_idx;\n\tioreq->wr_status\t= 0;\n\tioreq->drv_status\t= 0;\n\tcsio_scsi_cmnd(ioreq)\t= (void *)cmnd;\n\tioreq->tmo\t\t= 0;\n\tioreq->datadir\t\t= cmnd->sc_data_direction;\n\n\tif (cmnd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tCSIO_INC_STATS(ln, n_output_requests);\n\t\tln->stats.n_output_bytes += scsi_bufflen(cmnd);\n\t} else if (cmnd->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tCSIO_INC_STATS(ln, n_input_requests);\n\t\tln->stats.n_input_bytes += scsi_bufflen(cmnd);\n\t} else\n\t\tCSIO_INC_STATS(ln, n_control_requests);\n\n\t \n\tioreq->io_cbfn = csio_scsi_cbfn;\n\n\t \n\tcmnd->host_scribble = (unsigned char *)ioreq;\n\tcsio_priv(cmnd)->fc_tm_flags = 0;\n\n\t \n\tspin_lock_irqsave(&hw->lock, flags);\n\tretval = csio_scsi_start_io(ioreq);\n\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\tif (retval != 0) {\n\t\tcsio_err(hw, \"ioreq: %p couldn't be started, status:%d\\n\",\n\t\t\t ioreq, retval);\n\t\tCSIO_INC_STATS(scsim, n_busy_error);\n\t\tgoto err_put_req;\n\t}\n\n\treturn 0;\n\nerr_put_req:\n\tcsio_put_scsi_ioreq_lock(hw, scsim, ioreq);\nerr_dma_unmap:\n\tif (nsge > 0)\n\t\tscsi_dma_unmap(cmnd);\nerr:\n\treturn rv;\n\nerr_done:\n\tscsi_done(cmnd);\n\treturn 0;\n}\n\nstatic int\ncsio_do_abrt_cls(struct csio_hw *hw, struct csio_ioreq *ioreq, bool abort)\n{\n\tint rv;\n\tint cpu = smp_processor_id();\n\tstruct csio_lnode *ln = ioreq->lnode;\n\tstruct csio_scsi_qset *sqset = &hw->sqset[ln->portid][cpu];\n\n\tioreq->tmo = CSIO_SCSI_ABRT_TMO_MS;\n\t \n\tioreq->eq_idx = sqset->eq_idx;\n\n\tif (abort == SCSI_ABORT)\n\t\trv = csio_scsi_abort(ioreq);\n\telse\n\t\trv = csio_scsi_close(ioreq);\n\n\treturn rv;\n}\n\nstatic int\ncsio_eh_abort_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct csio_ioreq *ioreq;\n\tstruct csio_lnode *ln = shost_priv(cmnd->device->host);\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\tstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\n\tint ready = 0, ret;\n\tunsigned long tmo = 0;\n\tint rv;\n\tstruct csio_rnode *rn = (struct csio_rnode *)(cmnd->device->hostdata);\n\n\tret = fc_block_scsi_eh(cmnd);\n\tif (ret)\n\t\treturn ret;\n\n\tioreq = (struct csio_ioreq *)cmnd->host_scribble;\n\tif (!ioreq)\n\t\treturn SUCCESS;\n\n\tif (!rn)\n\t\treturn FAILED;\n\n\tcsio_dbg(hw,\n\t\t \"Request to abort ioreq:%p cmd:%p cdb:%08llx\"\n\t\t \" ssni:0x%x lun:%llu iq:0x%x\\n\",\n\t\tioreq, cmnd, *((uint64_t *)cmnd->cmnd), rn->flowid,\n\t\tcmnd->device->lun, csio_q_physiqid(hw, ioreq->iq_idx));\n\n\tif (((struct scsi_cmnd *)csio_scsi_cmnd(ioreq)) != cmnd) {\n\t\tCSIO_INC_STATS(scsim, n_abrt_race_comp);\n\t\treturn SUCCESS;\n\t}\n\n\tready = csio_is_lnode_ready(ln);\n\ttmo = CSIO_SCSI_ABRT_TMO_MS;\n\n\treinit_completion(&ioreq->cmplobj);\n\tspin_lock_irq(&hw->lock);\n\trv = csio_do_abrt_cls(hw, ioreq, (ready ? SCSI_ABORT : SCSI_CLOSE));\n\tspin_unlock_irq(&hw->lock);\n\n\tif (rv != 0) {\n\t\tif (rv == -EINVAL) {\n\t\t\t \n\t\t\treturn SUCCESS;\n\t\t}\n\t\tif (ready)\n\t\t\tCSIO_INC_STATS(scsim, n_abrt_busy_error);\n\t\telse\n\t\t\tCSIO_INC_STATS(scsim, n_cls_busy_error);\n\n\t\tgoto inval_scmnd;\n\t}\n\n\twait_for_completion_timeout(&ioreq->cmplobj, msecs_to_jiffies(tmo));\n\n\t \n\tif (((struct scsi_cmnd *)csio_scsi_cmnd(ioreq)) == cmnd) {\n\n\t\tcsio_err(hw, \"Abort timed out -- req: %p\\n\", ioreq);\n\t\tCSIO_INC_STATS(scsim, n_abrt_timedout);\n\ninval_scmnd:\n\t\tif (ioreq->nsge > 0)\n\t\t\tscsi_dma_unmap(cmnd);\n\n\t\tspin_lock_irq(&hw->lock);\n\t\tcsio_scsi_cmnd(ioreq) = NULL;\n\t\tspin_unlock_irq(&hw->lock);\n\n\t\tcmnd->result = (DID_ERROR << 16);\n\t\tscsi_done(cmnd);\n\n\t\treturn FAILED;\n\t}\n\n\t \n\tif (host_byte(cmnd->result) == DID_REQUEUE) {\n\t\tcsio_info(hw,\n\t\t\t\"Aborted SCSI command to (%d:%llu) tag %u\\n\",\n\t\t\tcmnd->device->id, cmnd->device->lun,\n\t\t\tscsi_cmd_to_rq(cmnd)->tag);\n\t\treturn SUCCESS;\n\t} else {\n\t\tcsio_info(hw,\n\t\t\t\"Failed to abort SCSI command, (%d:%llu) tag %u\\n\",\n\t\t\tcmnd->device->id, cmnd->device->lun,\n\t\t\tscsi_cmd_to_rq(cmnd)->tag);\n\t\treturn FAILED;\n\t}\n}\n\n \nstatic void\ncsio_tm_cbfn(struct csio_hw *hw, struct csio_ioreq *req)\n{\n\tstruct scsi_cmnd *cmnd  = (struct scsi_cmnd *)csio_scsi_cmnd(req);\n\tstruct csio_dma_buf *dma_buf;\n\tuint8_t flags = 0;\n\tstruct fcp_resp_with_ext *fcp_resp;\n\tstruct fcp_resp_rsp_info *rsp_info;\n\n\tcsio_dbg(hw, \"req: %p in csio_tm_cbfn status: %d\\n\",\n\t\t      req, req->wr_status);\n\n\t \n\tcsio_priv(cmnd)->wr_status = req->wr_status;\n\n\t \n\n\t \n\tif (req->wr_status == FW_SCSI_RSP_ERR) {\n\t\tdma_buf = &req->dma_buf;\n\t\tfcp_resp = (struct fcp_resp_with_ext *)dma_buf->vaddr;\n\t\trsp_info = (struct fcp_resp_rsp_info *)(fcp_resp + 1);\n\n\t\tflags = fcp_resp->resp.fr_flags;\n\n\t\t \n\t\tif (flags & FCP_RSP_LEN_VAL)\n\t\t\tif (rsp_info->rsp_code == FCP_TMF_CMPL)\n\t\t\t\tcsio_priv(cmnd)->wr_status = FW_SUCCESS;\n\n\t\tcsio_dbg(hw, \"TM FCP rsp code: %d\\n\", rsp_info->rsp_code);\n\t}\n\n\t \n\tcsio_scsi_cmnd(req) = NULL;\n}\n\nstatic int\ncsio_eh_lun_reset_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct csio_lnode *ln = shost_priv(cmnd->device->host);\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\tstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\n\tstruct csio_rnode *rn = (struct csio_rnode *)(cmnd->device->hostdata);\n\tstruct csio_ioreq *ioreq = NULL;\n\tstruct csio_scsi_qset *sqset;\n\tunsigned long flags;\n\tint retval;\n\tint count, ret;\n\tLIST_HEAD(local_q);\n\tstruct csio_scsi_level_data sld;\n\n\tif (!rn)\n\t\tgoto fail;\n\n\tcsio_dbg(hw, \"Request to reset LUN:%llu (ssni:0x%x tgtid:%d)\\n\",\n\t\t      cmnd->device->lun, rn->flowid, rn->scsi_id);\n\n\tif (!csio_is_lnode_ready(ln)) {\n\t\tcsio_err(hw,\n\t\t\t \"LUN reset cannot be issued on non-ready\"\n\t\t\t \" local node vnpi:0x%x (LUN:%llu)\\n\",\n\t\t\t ln->vnp_flowid, cmnd->device->lun);\n\t\tgoto fail;\n\t}\n\n\t \n\tret = fc_block_scsi_eh(cmnd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (fc_remote_port_chkready(rn->rport)) {\n\t\tcsio_err(hw,\n\t\t\t \"LUN reset cannot be issued on non-ready\"\n\t\t\t \" remote node ssni:0x%x (LUN:%llu)\\n\",\n\t\t\t rn->flowid, cmnd->device->lun);\n\t\tgoto fail;\n\t}\n\n\t \n\tioreq = csio_get_scsi_ioreq_lock(hw, scsim);\n\n\tif (!ioreq) {\n\t\tcsio_err(hw, \"Out of IO request elements. Active # :%d\\n\",\n\t\t\t scsim->stats.n_active);\n\t\tgoto fail;\n\t}\n\n\tsqset\t\t\t= &hw->sqset[ln->portid][smp_processor_id()];\n\tioreq->nsge\t\t= 0;\n\tioreq->lnode\t\t= ln;\n\tioreq->rnode\t\t= rn;\n\tioreq->iq_idx\t\t= sqset->iq_idx;\n\tioreq->eq_idx\t\t= sqset->eq_idx;\n\n\tcsio_scsi_cmnd(ioreq)\t= cmnd;\n\tcmnd->host_scribble\t= (unsigned char *)ioreq;\n\tcsio_priv(cmnd)->wr_status = 0;\n\n\tcsio_priv(cmnd)->fc_tm_flags = FCP_TMF_LUN_RESET;\n\tioreq->tmo\t\t= CSIO_SCSI_LUNRST_TMO_MS / 1000;\n\n\t \n\tcount = DIV_ROUND_UP((ioreq->tmo + 10) * 1000, CSIO_SCSI_TM_POLL_MS);\n\n\t \n\tioreq->io_cbfn = csio_tm_cbfn;\n\n\t \n\tsld.level = CSIO_LEV_LUN;\n\tsld.lnode = ioreq->lnode;\n\tsld.rnode = ioreq->rnode;\n\tsld.oslun = cmnd->device->lun;\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\t \n\tretval = csio_scsi_start_tm(ioreq);\n\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\tif (retval != 0) {\n\t\tcsio_err(hw, \"Failed to issue LUN reset, req:%p, status:%d\\n\",\n\t\t\t    ioreq, retval);\n\t\tgoto fail_ret_ioreq;\n\t}\n\n\tcsio_dbg(hw, \"Waiting max %d secs for LUN reset completion\\n\",\n\t\t    count * (CSIO_SCSI_TM_POLL_MS / 1000));\n\t \n\twhile ((((struct scsi_cmnd *)csio_scsi_cmnd(ioreq)) == cmnd)\n\t\t\t\t\t\t\t\t&& count--)\n\t\tmsleep(CSIO_SCSI_TM_POLL_MS);\n\n\t \n\tif (((struct scsi_cmnd *)csio_scsi_cmnd(ioreq)) == cmnd) {\n\t\tcsio_err(hw, \"LUN reset (%d:%llu) timed out\\n\",\n\t\t\t cmnd->device->id, cmnd->device->lun);\n\n\t\tspin_lock_irq(&hw->lock);\n\t\tcsio_scsi_drvcleanup(ioreq);\n\t\tlist_del_init(&ioreq->sm.sm_list);\n\t\tspin_unlock_irq(&hw->lock);\n\n\t\tgoto fail_ret_ioreq;\n\t}\n\n\t \n\tif (csio_priv(cmnd)->wr_status != FW_SUCCESS) {\n\t\tcsio_err(hw, \"LUN reset failed (%d:%llu), status: %d\\n\",\n\t\t\t cmnd->device->id, cmnd->device->lun,\n\t\t\t csio_priv(cmnd)->wr_status);\n\t\tgoto fail;\n\t}\n\n\t \n\t \n\tspin_lock_irq(&hw->lock);\n\tcsio_scsi_gather_active_ios(scsim, &sld, &local_q);\n\n\tretval = csio_scsi_abort_io_q(scsim, &local_q, 30000);\n\tspin_unlock_irq(&hw->lock);\n\n\t \n\tif (retval != 0) {\n\t\tcsio_err(hw,\n\t\t\t \"Attempt to abort I/Os during LUN reset of %llu\"\n\t\t\t \" returned %d\\n\", cmnd->device->lun, retval);\n\t\t \n\t\tspin_lock_irq(&hw->lock);\n\t\tlist_splice_tail_init(&local_q, &scsim->active_q);\n\t\tspin_unlock_irq(&hw->lock);\n\t\tgoto fail;\n\t}\n\n\tCSIO_INC_STATS(rn, n_lun_rst);\n\n\tcsio_info(hw, \"LUN reset occurred (%d:%llu)\\n\",\n\t\t  cmnd->device->id, cmnd->device->lun);\n\n\treturn SUCCESS;\n\nfail_ret_ioreq:\n\tcsio_put_scsi_ioreq_lock(hw, scsim, ioreq);\nfail:\n\tCSIO_INC_STATS(rn, n_lun_rst_fail);\n\treturn FAILED;\n}\n\nstatic int\ncsio_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\n\tif (!rport || fc_remote_port_chkready(rport))\n\t\treturn -ENXIO;\n\n\tsdev->hostdata = *((struct csio_lnode **)(rport->dd_data));\n\n\treturn 0;\n}\n\nstatic int\ncsio_slave_configure(struct scsi_device *sdev)\n{\n\tscsi_change_queue_depth(sdev, csio_lun_qdepth);\n\treturn 0;\n}\n\nstatic void\ncsio_slave_destroy(struct scsi_device *sdev)\n{\n\tsdev->hostdata = NULL;\n}\n\nstatic int\ncsio_scan_finished(struct Scsi_Host *shost, unsigned long time)\n{\n\tstruct csio_lnode *ln = shost_priv(shost);\n\tint rv = 1;\n\n\tspin_lock_irq(shost->host_lock);\n\tif (!ln->hwp || csio_list_deleted(&ln->sm.sm_list))\n\t\tgoto out;\n\n\trv = csio_scan_done(ln, jiffies, time, csio_max_scan_tmo * HZ,\n\t\t\t    csio_delta_scan_tmo * HZ);\nout:\n\tspin_unlock_irq(shost->host_lock);\n\n\treturn rv;\n}\n\nstruct scsi_host_template csio_fcoe_shost_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= CSIO_DRV_DESC,\n\t.proc_name\t\t= KBUILD_MODNAME,\n\t.queuecommand\t\t= csio_queuecommand,\n\t.cmd_size\t\t= sizeof(struct csio_cmd_priv),\n\t.eh_timed_out\t\t= fc_eh_timed_out,\n\t.eh_abort_handler\t= csio_eh_abort_handler,\n\t.eh_device_reset_handler = csio_eh_lun_reset_handler,\n\t.slave_alloc\t\t= csio_slave_alloc,\n\t.slave_configure\t= csio_slave_configure,\n\t.slave_destroy\t\t= csio_slave_destroy,\n\t.scan_finished\t\t= csio_scan_finished,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= CSIO_SCSI_MAX_SGE,\n\t.cmd_per_lun\t\t= CSIO_MAX_CMD_PER_LUN,\n\t.shost_groups\t\t= csio_fcoe_lport_groups,\n\t.max_sectors\t\t= CSIO_MAX_SECTOR_SIZE,\n};\n\nstruct scsi_host_template csio_fcoe_shost_vport_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= CSIO_DRV_DESC,\n\t.proc_name\t\t= KBUILD_MODNAME,\n\t.queuecommand\t\t= csio_queuecommand,\n\t.eh_timed_out\t\t= fc_eh_timed_out,\n\t.eh_abort_handler\t= csio_eh_abort_handler,\n\t.eh_device_reset_handler = csio_eh_lun_reset_handler,\n\t.slave_alloc\t\t= csio_slave_alloc,\n\t.slave_configure\t= csio_slave_configure,\n\t.slave_destroy\t\t= csio_slave_destroy,\n\t.scan_finished\t\t= csio_scan_finished,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= CSIO_SCSI_MAX_SGE,\n\t.cmd_per_lun\t\t= CSIO_MAX_CMD_PER_LUN,\n\t.shost_groups\t\t= csio_fcoe_vport_groups,\n\t.max_sectors\t\t= CSIO_MAX_SECTOR_SIZE,\n};\n\n \nstatic int\ncsio_scsi_alloc_ddp_bufs(struct csio_scsim *scm, struct csio_hw *hw,\n\t\t\t int buf_size, int num_buf)\n{\n\tint n = 0;\n\tstruct list_head *tmp;\n\tstruct csio_dma_buf *ddp_desc = NULL;\n\tuint32_t unit_size = 0;\n\n\tif (!num_buf)\n\t\treturn 0;\n\n\tif (!buf_size)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&scm->ddp_freelist);\n\n\t \n\tbuf_size = (buf_size + PAGE_SIZE - 1) & PAGE_MASK;\n\t \n\tfor (n = 0; n < num_buf; n++) {\n\t\t \n\t\tunit_size = buf_size;\n\t\tddp_desc = kzalloc(sizeof(struct csio_dma_buf), GFP_KERNEL);\n\t\tif (!ddp_desc) {\n\t\t\tcsio_err(hw,\n\t\t\t\t \"Failed to allocate ddp descriptors,\"\n\t\t\t\t \" Num allocated = %d.\\n\",\n\t\t\t\t scm->stats.n_free_ddp);\n\t\t\tgoto no_mem;\n\t\t}\n\n\t\t \n\t\tddp_desc->vaddr = dma_alloc_coherent(&hw->pdev->dev, unit_size,\n\t\t\t\t&ddp_desc->paddr, GFP_KERNEL);\n\t\tif (!ddp_desc->vaddr) {\n\t\t\tcsio_err(hw,\n\t\t\t\t \"SCSI response DMA buffer (ddp) allocation\"\n\t\t\t\t \" failed!\\n\");\n\t\t\tkfree(ddp_desc);\n\t\t\tgoto no_mem;\n\t\t}\n\n\t\tddp_desc->len = unit_size;\n\n\t\t \n\t\tlist_add_tail(&ddp_desc->list, &scm->ddp_freelist);\n\t\tCSIO_INC_STATS(scm, n_free_ddp);\n\t}\n\n\treturn 0;\nno_mem:\n\t \n\tlist_for_each(tmp, &scm->ddp_freelist) {\n\t\tddp_desc = (struct csio_dma_buf *) tmp;\n\t\ttmp = csio_list_prev(tmp);\n\t\tdma_free_coherent(&hw->pdev->dev, ddp_desc->len,\n\t\t\t\t  ddp_desc->vaddr, ddp_desc->paddr);\n\t\tlist_del_init(&ddp_desc->list);\n\t\tkfree(ddp_desc);\n\t}\n\tscm->stats.n_free_ddp = 0;\n\n\treturn -ENOMEM;\n}\n\n \nstatic void\ncsio_scsi_free_ddp_bufs(struct csio_scsim *scm, struct csio_hw *hw)\n{\n\tstruct list_head *tmp;\n\tstruct csio_dma_buf *ddp_desc;\n\n\t \n\tlist_for_each(tmp, &scm->ddp_freelist) {\n\t\tddp_desc = (struct csio_dma_buf *) tmp;\n\t\ttmp = csio_list_prev(tmp);\n\t\tdma_free_coherent(&hw->pdev->dev, ddp_desc->len,\n\t\t\t\t  ddp_desc->vaddr, ddp_desc->paddr);\n\t\tlist_del_init(&ddp_desc->list);\n\t\tkfree(ddp_desc);\n\t}\n\tscm->stats.n_free_ddp = 0;\n}\n\n \nint\ncsio_scsim_init(struct csio_scsim *scm, struct csio_hw *hw)\n{\n\tint i;\n\tstruct csio_ioreq *ioreq;\n\tstruct csio_dma_buf *dma_buf;\n\n\tINIT_LIST_HEAD(&scm->active_q);\n\tscm->hw = hw;\n\n\tscm->proto_cmd_len = sizeof(struct fcp_cmnd);\n\tscm->proto_rsp_len = CSIO_SCSI_RSP_LEN;\n\tscm->max_sge = CSIO_SCSI_MAX_SGE;\n\n\tspin_lock_init(&scm->freelist_lock);\n\n\t \n\tINIT_LIST_HEAD(&scm->ioreq_freelist);\n\tfor (i = 0; i < csio_scsi_ioreqs; i++) {\n\n\t\tioreq = kzalloc(sizeof(struct csio_ioreq), GFP_KERNEL);\n\t\tif (!ioreq) {\n\t\t\tcsio_err(hw,\n\t\t\t\t \"I/O request element allocation failed, \"\n\t\t\t\t \" Num allocated = %d.\\n\",\n\t\t\t\t scm->stats.n_free_ioreq);\n\n\t\t\tgoto free_ioreq;\n\t\t}\n\n\t\t \n\t\tdma_buf = &ioreq->dma_buf;\n\t\tdma_buf->vaddr = dma_pool_alloc(hw->scsi_dma_pool, GFP_KERNEL,\n\t\t\t\t\t\t&dma_buf->paddr);\n\t\tif (!dma_buf->vaddr) {\n\t\t\tcsio_err(hw,\n\t\t\t\t \"SCSI response DMA buffer allocation\"\n\t\t\t\t \" failed!\\n\");\n\t\t\tkfree(ioreq);\n\t\t\tgoto free_ioreq;\n\t\t}\n\n\t\tdma_buf->len = scm->proto_rsp_len;\n\n\t\t \n\t\tcsio_init_state(&ioreq->sm, csio_scsis_uninit);\n\t\tINIT_LIST_HEAD(&ioreq->gen_list);\n\t\tinit_completion(&ioreq->cmplobj);\n\n\t\tlist_add_tail(&ioreq->sm.sm_list, &scm->ioreq_freelist);\n\t\tCSIO_INC_STATS(scm, n_free_ioreq);\n\t}\n\n\tif (csio_scsi_alloc_ddp_bufs(scm, hw, PAGE_SIZE, csio_ddp_descs))\n\t\tgoto free_ioreq;\n\n\treturn 0;\n\nfree_ioreq:\n\t \n\twhile (!list_empty(&scm->ioreq_freelist)) {\n\t\tstruct csio_sm *tmp;\n\n\t\ttmp = list_first_entry(&scm->ioreq_freelist,\n\t\t\t\t       struct csio_sm, sm_list);\n\t\tlist_del_init(&tmp->sm_list);\n\t\tioreq = (struct csio_ioreq *)tmp;\n\n\t\tdma_buf = &ioreq->dma_buf;\n\t\tdma_pool_free(hw->scsi_dma_pool, dma_buf->vaddr,\n\t\t\t      dma_buf->paddr);\n\n\t\tkfree(ioreq);\n\t}\n\n\tscm->stats.n_free_ioreq = 0;\n\n\treturn -ENOMEM;\n}\n\n \nvoid\ncsio_scsim_exit(struct csio_scsim *scm)\n{\n\tstruct csio_ioreq *ioreq;\n\tstruct csio_dma_buf *dma_buf;\n\n\twhile (!list_empty(&scm->ioreq_freelist)) {\n\t\tstruct csio_sm *tmp;\n\n\t\ttmp = list_first_entry(&scm->ioreq_freelist,\n\t\t\t\t       struct csio_sm, sm_list);\n\t\tlist_del_init(&tmp->sm_list);\n\t\tioreq = (struct csio_ioreq *)tmp;\n\n\t\tdma_buf = &ioreq->dma_buf;\n\t\tdma_pool_free(scm->hw->scsi_dma_pool, dma_buf->vaddr,\n\t\t\t      dma_buf->paddr);\n\n\t\tkfree(ioreq);\n\t}\n\n\tscm->stats.n_free_ioreq = 0;\n\n\tcsio_scsi_free_ddp_bufs(scm, scm->hw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}