{
  "module_name": "csio_wr.c",
  "hash_id": "280e8e7b295987f02e04bbb40dd331b70862c8388f836273e3a66f3d87a7eb95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/csiostor/csio_wr.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <asm/page.h>\n#include <linux/cache.h>\n\n#include \"t4_values.h\"\n#include \"csio_hw.h\"\n#include \"csio_wr.h\"\n#include \"csio_mb.h\"\n#include \"csio_defs.h\"\n\nint csio_intr_coalesce_cnt;\t\t \nstatic int csio_sge_thresh_reg;\t\t \n\nint csio_intr_coalesce_time = 10;\t \nstatic int csio_sge_timer_reg = 1;\n\n#define CSIO_SET_FLBUF_SIZE(_hw, _reg, _val)\t\t\t\t\\\n\tcsio_wr_reg32((_hw), (_val), SGE_FL_BUFFER_SIZE##_reg##_A)\n\nstatic void\ncsio_get_flbuf_size(struct csio_hw *hw, struct csio_sge *sge, uint32_t reg)\n{\n\tsge->sge_fl_buf_size[reg] = csio_rd_reg32(hw, SGE_FL_BUFFER_SIZE0_A +\n\t\t\t\t\t\t\treg * sizeof(uint32_t));\n}\n\n \nstatic inline uint32_t\ncsio_wr_fl_bufsz(struct csio_sge *sge, struct csio_dma_buf *buf)\n{\n\treturn sge->sge_fl_buf_size[buf->paddr & 0xF];\n}\n\n \nstatic inline uint32_t\ncsio_wr_qstat_pgsz(struct csio_hw *hw)\n{\n\treturn (hw->wrm.sge.sge_control & EGRSTATUSPAGESIZE_F) ?  128 : 64;\n}\n\n \nstatic inline void\ncsio_wr_ring_fldb(struct csio_hw *hw, struct csio_q *flq)\n{\n\t \n\tif (flq->inc_idx >= 8) {\n\t\tcsio_wr_reg32(hw, DBPRIO_F | QID_V(flq->un.fl.flid) |\n\t\t\t\t  PIDX_T5_V(flq->inc_idx / 8) | DBTYPE_F,\n\t\t\t\t  MYPF_REG(SGE_PF_KDOORBELL_A));\n\t\tflq->inc_idx &= 7;\n\t}\n}\n\n \nstatic void\ncsio_wr_sge_intr_enable(struct csio_hw *hw, uint16_t iqid)\n{\n\tcsio_wr_reg32(hw, CIDXINC_V(0)\t\t|\n\t\t\t  INGRESSQID_V(iqid)\t|\n\t\t\t  TIMERREG_V(X_TIMERREG_RESTART_COUNTER),\n\t\t\t  MYPF_REG(SGE_PF_GTS_A));\n}\n\n \nstatic int\ncsio_wr_fill_fl(struct csio_hw *hw, struct csio_q *flq)\n{\n\tstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\n\tstruct csio_sge *sge = &wrm->sge;\n\t__be64 *d = (__be64 *)(flq->vstart);\n\tstruct csio_dma_buf *buf = &flq->un.fl.bufs[0];\n\tuint64_t paddr;\n\tint sreg = flq->un.fl.sreg;\n\tint n = flq->credits;\n\n\twhile (n--) {\n\t\tbuf->len = sge->sge_fl_buf_size[sreg];\n\t\tbuf->vaddr = dma_alloc_coherent(&hw->pdev->dev, buf->len,\n\t\t\t\t\t\t&buf->paddr, GFP_KERNEL);\n\t\tif (!buf->vaddr) {\n\t\t\tcsio_err(hw, \"Could only fill %d buffers!\\n\", n + 1);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpaddr = buf->paddr | (sreg & 0xF);\n\n\t\t*d++ = cpu_to_be64(paddr);\n\t\tbuf++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline void\ncsio_wr_update_fl(struct csio_hw *hw, struct csio_q *flq, uint16_t n)\n{\n\n\tflq->inc_idx += n;\n\tflq->pidx += n;\n\tif (unlikely(flq->pidx >= flq->credits))\n\t\tflq->pidx -= (uint16_t)flq->credits;\n\n\tCSIO_INC_STATS(flq, n_flq_refill);\n}\n\n \nint\ncsio_wr_alloc_q(struct csio_hw *hw, uint32_t qsize, uint32_t wrsize,\n\t\tuint16_t type, void *owner, uint32_t nflb, int sreg,\n\t\tiq_handler_t iq_intx_handler)\n{\n\tstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\n\tstruct csio_q\t*q, *flq;\n\tint\t\tfree_idx = wrm->free_qidx;\n\tint\t\tret_idx = free_idx;\n\tuint32_t\tqsz;\n\tint flq_idx;\n\n\tif (free_idx >= wrm->num_q) {\n\t\tcsio_err(hw, \"No more free queues.\\n\");\n\t\treturn -1;\n\t}\n\n\tswitch (type) {\n\tcase CSIO_EGRESS:\n\t\tqsz = ALIGN(qsize, CSIO_QCREDIT_SZ) + csio_wr_qstat_pgsz(hw);\n\t\tbreak;\n\tcase CSIO_INGRESS:\n\t\tswitch (wrsize) {\n\t\tcase 16:\n\t\tcase 32:\n\t\tcase 64:\n\t\tcase 128:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcsio_err(hw, \"Invalid Ingress queue WR size:%d\\n\",\n\t\t\t\t    wrsize);\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tqsz = ALIGN(qsize/wrsize, 16) * wrsize;\n\n\t\tbreak;\n\tcase CSIO_FREELIST:\n\t\tqsz = ALIGN(qsize/wrsize, 8) * wrsize + csio_wr_qstat_pgsz(hw);\n\t\tbreak;\n\tdefault:\n\t\tcsio_err(hw, \"Invalid queue type: 0x%x\\n\", type);\n\t\treturn -1;\n\t}\n\n\tq = wrm->q_arr[free_idx];\n\n\tq->vstart = dma_alloc_coherent(&hw->pdev->dev, qsz, &q->pstart,\n\t\t\t\t       GFP_KERNEL);\n\tif (!q->vstart) {\n\t\tcsio_err(hw,\n\t\t\t \"Failed to allocate DMA memory for \"\n\t\t\t \"queue at id: %d size: %d\\n\", free_idx, qsize);\n\t\treturn -1;\n\t}\n\n\tq->type\t\t= type;\n\tq->owner\t= owner;\n\tq->pidx\t\t= q->cidx = q->inc_idx = 0;\n\tq->size\t\t= qsz;\n\tq->wr_sz\t= wrsize;\t \n\n\twrm->free_qidx++;\n\n\tif (type == CSIO_INGRESS) {\n\t\t \n\t\tq->un.iq.genbit\t= 1;\n\n\t\t \n\t\tq->credits\t= (qsz - q->wr_sz) / q->wr_sz;\n\t\tq->vwrap\t= (void *)((uintptr_t)(q->vstart) + qsz\n\t\t\t\t\t\t\t- q->wr_sz);\n\n\t\t \n\t\tif (nflb > 0) {\n\t\t\tflq_idx = csio_wr_alloc_q(hw, nflb * sizeof(__be64),\n\t\t\t\t\t\t  sizeof(__be64), CSIO_FREELIST,\n\t\t\t\t\t\t  owner, 0, sreg, NULL);\n\t\t\tif (flq_idx == -1) {\n\t\t\t\tcsio_err(hw,\n\t\t\t\t\t \"Failed to allocate FL queue\"\n\t\t\t\t\t \" for IQ idx:%d\\n\", free_idx);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t \n\t\t\tq->un.iq.flq_idx = flq_idx;\n\n\t\t\tflq = wrm->q_arr[q->un.iq.flq_idx];\n\t\t\tflq->un.fl.bufs = kcalloc(flq->credits,\n\t\t\t\t\t\t  sizeof(struct csio_dma_buf),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!flq->un.fl.bufs) {\n\t\t\t\tcsio_err(hw,\n\t\t\t\t\t \"Failed to allocate FL queue bufs\"\n\t\t\t\t\t \" for IQ idx:%d\\n\", free_idx);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tflq->un.fl.packen = 0;\n\t\t\tflq->un.fl.offset = 0;\n\t\t\tflq->un.fl.sreg = sreg;\n\n\t\t\t \n\t\t\tif (csio_wr_fill_fl(hw, flq))\n\t\t\t\treturn -1;\n\n\t\t\t \n\t\t\tflq->pidx = flq->inc_idx = flq->credits - 8;\n\t\t} else {\n\t\t\tq->un.iq.flq_idx = -1;\n\t\t}\n\n\t\t \n\t\tq->un.iq.iq_intx_handler = iq_intx_handler;\n\n\t\tcsio_q_iqid(hw, ret_idx) = CSIO_MAX_QID;\n\n\t} else if (type == CSIO_EGRESS) {\n\t\tq->credits = (qsz - csio_wr_qstat_pgsz(hw)) / CSIO_QCREDIT_SZ;\n\t\tq->vwrap   = (void *)((uintptr_t)(q->vstart) + qsz\n\t\t\t\t\t\t- csio_wr_qstat_pgsz(hw));\n\t\tcsio_q_eqid(hw, ret_idx) = CSIO_MAX_QID;\n\t} else {  \n\t\tq->credits = (qsz - csio_wr_qstat_pgsz(hw)) / sizeof(__be64);\n\t\tq->vwrap   = (void *)((uintptr_t)(q->vstart) + qsz\n\t\t\t\t\t\t- csio_wr_qstat_pgsz(hw));\n\t\tcsio_q_flid(hw, ret_idx) = CSIO_MAX_QID;\n\t}\n\n\treturn ret_idx;\n}\n\n \nstatic int\ncsio_wr_iq_create_rsp(struct csio_hw *hw, struct csio_mb *mbp, int iq_idx)\n{\n\tstruct csio_iq_params iqp;\n\tenum fw_retval retval;\n\tuint32_t iq_id;\n\tint flq_idx;\n\n\tmemset(&iqp, 0, sizeof(struct csio_iq_params));\n\n\tcsio_mb_iq_alloc_write_rsp(hw, mbp, &retval, &iqp);\n\n\tif (retval != FW_SUCCESS) {\n\t\tcsio_err(hw, \"IQ cmd returned 0x%x!\\n\", retval);\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\tcsio_q_iqid(hw, iq_idx)\t\t= iqp.iqid;\n\tcsio_q_physiqid(hw, iq_idx)\t= iqp.physiqid;\n\tcsio_q_pidx(hw, iq_idx)\t\t= csio_q_cidx(hw, iq_idx) = 0;\n\tcsio_q_inc_idx(hw, iq_idx)\t= 0;\n\n\t \n\tiq_id = iqp.iqid - hw->wrm.fw_iq_start;\n\n\t \n\tif (iq_id >= CSIO_MAX_IQ) {\n\t\tcsio_err(hw,\n\t\t\t \"Exceeding MAX_IQ(%d) supported!\"\n\t\t\t \" iqid:%d rel_iqid:%d FW iq_start:%d\\n\",\n\t\t\t CSIO_MAX_IQ, iq_id, iqp.iqid, hw->wrm.fw_iq_start);\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\tcsio_q_set_intr_map(hw, iq_idx, iq_id);\n\n\t \n\tcsio_wr_sge_intr_enable(hw, iqp.physiqid);\n\n\tflq_idx = csio_q_iq_flq_idx(hw, iq_idx);\n\tif (flq_idx != -1) {\n\t\tstruct csio_q *flq = hw->wrm.q_arr[flq_idx];\n\n\t\tcsio_q_flid(hw, flq_idx) = iqp.fl0id;\n\t\tcsio_q_cidx(hw, flq_idx) = 0;\n\t\tcsio_q_pidx(hw, flq_idx)    = csio_q_credits(hw, flq_idx) - 8;\n\t\tcsio_q_inc_idx(hw, flq_idx) = csio_q_credits(hw, flq_idx) - 8;\n\n\t\t \n\t\tcsio_wr_ring_fldb(hw, flq);\n\t}\n\n\tmempool_free(mbp, hw->mb_mempool);\n\n\treturn 0;\n}\n\n \nint\ncsio_wr_iq_create(struct csio_hw *hw, void *priv, int iq_idx,\n\t\t  uint32_t vec, uint8_t portid, bool async,\n\t\t  void (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct csio_mb  *mbp;\n\tstruct csio_iq_params iqp;\n\tint flq_idx;\n\n\tmemset(&iqp, 0, sizeof(struct csio_iq_params));\n\tcsio_q_portid(hw, iq_idx) = portid;\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tcsio_err(hw, \"IQ command out of memory!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tswitch (hw->intr_mode) {\n\tcase CSIO_IM_INTX:\n\tcase CSIO_IM_MSI:\n\t\t \n\t\tif (hw->intr_iq_idx == iq_idx)\n\t\t\tiqp.iqandst\t= X_INTERRUPTDESTINATION_PCIE;\n\t\telse\n\t\t\tiqp.iqandst\t= X_INTERRUPTDESTINATION_IQ;\n\t\tiqp.iqandstindex\t=\n\t\t\tcsio_q_physiqid(hw, hw->intr_iq_idx);\n\t\tbreak;\n\tcase CSIO_IM_MSIX:\n\t\tiqp.iqandst\t\t= X_INTERRUPTDESTINATION_PCIE;\n\t\tiqp.iqandstindex\t= (uint16_t)vec;\n\t\tbreak;\n\tcase CSIO_IM_NONE:\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tiqp.pfn\t\t\t= hw->pfn;\n\tiqp.vfn\t\t\t= 0;\n\tiqp.iq_start\t\t= 1;\n\tiqp.viid\t\t= 0;\n\tiqp.type\t\t= FW_IQ_TYPE_FL_INT_CAP;\n\tiqp.iqasynch\t\t= async;\n\tif (csio_intr_coalesce_cnt)\n\t\tiqp.iqanus\t= X_UPDATESCHEDULING_COUNTER_OPTTIMER;\n\telse\n\t\tiqp.iqanus\t= X_UPDATESCHEDULING_TIMER;\n\tiqp.iqanud\t\t= X_UPDATEDELIVERY_INTERRUPT;\n\tiqp.iqpciech\t\t= portid;\n\tiqp.iqintcntthresh\t= (uint8_t)csio_sge_thresh_reg;\n\n\tswitch (csio_q_wr_sz(hw, iq_idx)) {\n\tcase 16:\n\t\tiqp.iqesize = 0; break;\n\tcase 32:\n\t\tiqp.iqesize = 1; break;\n\tcase 64:\n\t\tiqp.iqesize = 2; break;\n\tcase 128:\n\t\tiqp.iqesize = 3; break;\n\t}\n\n\tiqp.iqsize\t\t= csio_q_size(hw, iq_idx) /\n\t\t\t\t\t\tcsio_q_wr_sz(hw, iq_idx);\n\tiqp.iqaddr\t\t= csio_q_pstart(hw, iq_idx);\n\n\tflq_idx = csio_q_iq_flq_idx(hw, iq_idx);\n\tif (flq_idx != -1) {\n\t\tenum chip_type chip = CHELSIO_CHIP_VERSION(hw->chip_id);\n\t\tstruct csio_q *flq = hw->wrm.q_arr[flq_idx];\n\n\t\tiqp.fl0paden\t= 1;\n\t\tiqp.fl0packen\t= flq->un.fl.packen ? 1 : 0;\n\t\tiqp.fl0fbmin\t= X_FETCHBURSTMIN_64B;\n\t\tiqp.fl0fbmax\t= ((chip == CHELSIO_T5) ?\n\t\t\t\t  X_FETCHBURSTMAX_512B : X_FETCHBURSTMAX_256B);\n\t\tiqp.fl0size\t= csio_q_size(hw, flq_idx) / CSIO_QCREDIT_SZ;\n\t\tiqp.fl0addr\t= csio_q_pstart(hw, flq_idx);\n\t}\n\n\tcsio_mb_iq_alloc_write(hw, mbp, priv, CSIO_MB_DEFAULT_TMO, &iqp, cbfn);\n\n\tif (csio_mb_issue(hw, mbp)) {\n\t\tcsio_err(hw, \"Issue of IQ cmd failed!\\n\");\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cbfn != NULL)\n\t\treturn 0;\n\n\treturn csio_wr_iq_create_rsp(hw, mbp, iq_idx);\n}\n\n \nstatic int\ncsio_wr_eq_cfg_rsp(struct csio_hw *hw, struct csio_mb *mbp, int eq_idx)\n{\n\tstruct csio_eq_params eqp;\n\tenum fw_retval retval;\n\n\tmemset(&eqp, 0, sizeof(struct csio_eq_params));\n\n\tcsio_mb_eq_ofld_alloc_write_rsp(hw, mbp, &retval, &eqp);\n\n\tif (retval != FW_SUCCESS) {\n\t\tcsio_err(hw, \"EQ OFLD cmd returned 0x%x!\\n\", retval);\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\tcsio_q_eqid(hw, eq_idx)\t= (uint16_t)eqp.eqid;\n\tcsio_q_physeqid(hw, eq_idx) = (uint16_t)eqp.physeqid;\n\tcsio_q_pidx(hw, eq_idx)\t= csio_q_cidx(hw, eq_idx) = 0;\n\tcsio_q_inc_idx(hw, eq_idx) = 0;\n\n\tmempool_free(mbp, hw->mb_mempool);\n\n\treturn 0;\n}\n\n \nint\ncsio_wr_eq_create(struct csio_hw *hw, void *priv, int eq_idx,\n\t\t  int iq_idx, uint8_t portid,\n\t\t  void (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct csio_mb  *mbp;\n\tstruct csio_eq_params eqp;\n\n\tmemset(&eqp, 0, sizeof(struct csio_eq_params));\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tcsio_err(hw, \"EQ command out of memory!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\teqp.pfn\t\t\t= hw->pfn;\n\teqp.vfn\t\t\t= 0;\n\teqp.eqstart\t\t= 1;\n\teqp.hostfcmode\t\t= X_HOSTFCMODE_STATUS_PAGE;\n\teqp.iqid\t\t= csio_q_iqid(hw, iq_idx);\n\teqp.fbmin\t\t= X_FETCHBURSTMIN_64B;\n\teqp.fbmax\t\t= X_FETCHBURSTMAX_512B;\n\teqp.cidxfthresh\t\t= 0;\n\teqp.pciechn\t\t= portid;\n\teqp.eqsize\t\t= csio_q_size(hw, eq_idx) / CSIO_QCREDIT_SZ;\n\teqp.eqaddr\t\t= csio_q_pstart(hw, eq_idx);\n\n\tcsio_mb_eq_ofld_alloc_write(hw, mbp, priv, CSIO_MB_DEFAULT_TMO,\n\t\t\t\t    &eqp, cbfn);\n\n\tif (csio_mb_issue(hw, mbp)) {\n\t\tcsio_err(hw, \"Issue of EQ OFLD cmd failed!\\n\");\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cbfn != NULL)\n\t\treturn 0;\n\n\treturn csio_wr_eq_cfg_rsp(hw, mbp, eq_idx);\n}\n\n \nstatic int\ncsio_wr_iq_destroy_rsp(struct csio_hw *hw, struct csio_mb *mbp, int iq_idx)\n{\n\tenum fw_retval retval = csio_mb_fw_retval(mbp);\n\tint rv = 0;\n\n\tif (retval != FW_SUCCESS)\n\t\trv = -EINVAL;\n\n\tmempool_free(mbp, hw->mb_mempool);\n\n\treturn rv;\n}\n\n \nstatic int\ncsio_wr_iq_destroy(struct csio_hw *hw, void *priv, int iq_idx,\n\t\t   void (*cbfn)(struct csio_hw *, struct csio_mb *))\n{\n\tint rv = 0;\n\tstruct csio_mb  *mbp;\n\tstruct csio_iq_params iqp;\n\tint flq_idx;\n\n\tmemset(&iqp, 0, sizeof(struct csio_iq_params));\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp)\n\t\treturn -ENOMEM;\n\n\tiqp.pfn\t\t= hw->pfn;\n\tiqp.vfn\t\t= 0;\n\tiqp.iqid\t= csio_q_iqid(hw, iq_idx);\n\tiqp.type\t= FW_IQ_TYPE_FL_INT_CAP;\n\n\tflq_idx = csio_q_iq_flq_idx(hw, iq_idx);\n\tif (flq_idx != -1)\n\t\tiqp.fl0id = csio_q_flid(hw, flq_idx);\n\telse\n\t\tiqp.fl0id = 0xFFFF;\n\n\tiqp.fl1id = 0xFFFF;\n\n\tcsio_mb_iq_free(hw, mbp, priv, CSIO_MB_DEFAULT_TMO, &iqp, cbfn);\n\n\trv = csio_mb_issue(hw, mbp);\n\tif (rv != 0) {\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn rv;\n\t}\n\n\tif (cbfn != NULL)\n\t\treturn 0;\n\n\treturn csio_wr_iq_destroy_rsp(hw, mbp, iq_idx);\n}\n\n \nstatic int\ncsio_wr_eq_destroy_rsp(struct csio_hw *hw, struct csio_mb *mbp, int eq_idx)\n{\n\tenum fw_retval retval = csio_mb_fw_retval(mbp);\n\tint rv = 0;\n\n\tif (retval != FW_SUCCESS)\n\t\trv = -EINVAL;\n\n\tmempool_free(mbp, hw->mb_mempool);\n\n\treturn rv;\n}\n\n \nstatic int\ncsio_wr_eq_destroy(struct csio_hw *hw, void *priv, int eq_idx,\n\t\t   void (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tint rv = 0;\n\tstruct csio_mb  *mbp;\n\tstruct csio_eq_params eqp;\n\n\tmemset(&eqp, 0, sizeof(struct csio_eq_params));\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp)\n\t\treturn -ENOMEM;\n\n\teqp.pfn\t\t= hw->pfn;\n\teqp.vfn\t\t= 0;\n\teqp.eqid\t= csio_q_eqid(hw, eq_idx);\n\n\tcsio_mb_eq_ofld_free(hw, mbp, priv, CSIO_MB_DEFAULT_TMO, &eqp, cbfn);\n\n\trv = csio_mb_issue(hw, mbp);\n\tif (rv != 0) {\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn rv;\n\t}\n\n\tif (cbfn != NULL)\n\t\treturn 0;\n\n\treturn csio_wr_eq_destroy_rsp(hw, mbp, eq_idx);\n}\n\n \nstatic void\ncsio_wr_cleanup_eq_stpg(struct csio_hw *hw, int qidx)\n{\n\tstruct csio_q\t*q = csio_hw_to_wrm(hw)->q_arr[qidx];\n\tstruct csio_qstatus_page *stp = (struct csio_qstatus_page *)q->vwrap;\n\n\tmemset(stp, 0, sizeof(*stp));\n}\n\n \nstatic void\ncsio_wr_cleanup_iq_ftr(struct csio_hw *hw, int qidx)\n{\n\tstruct csio_wrm *wrm\t= csio_hw_to_wrm(hw);\n\tstruct csio_q\t*q\t= wrm->q_arr[qidx];\n\tvoid *wr;\n\tstruct csio_iqwr_footer *ftr;\n\tuint32_t i = 0;\n\n\t \n\tq->un.iq.genbit = 1;\n\n\tfor (i = 0; i < q->credits; i++) {\n\t\t \n\t\twr = (void *)((uintptr_t)q->vstart +\n\t\t\t\t\t   (i * q->wr_sz));\n\t\t \n\t\tftr = (struct csio_iqwr_footer *)((uintptr_t)wr +\n\t\t\t\t\t  (q->wr_sz - sizeof(*ftr)));\n\t\t \n\t\tmemset(ftr, 0, sizeof(*ftr));\n\t}\n}\n\nint\ncsio_wr_destroy_queues(struct csio_hw *hw, bool cmd)\n{\n\tint i, flq_idx;\n\tstruct csio_q *q;\n\tstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\n\tint rv;\n\n\tfor (i = 0; i < wrm->free_qidx; i++) {\n\t\tq = wrm->q_arr[i];\n\n\t\tswitch (q->type) {\n\t\tcase CSIO_EGRESS:\n\t\t\tif (csio_q_eqid(hw, i) != CSIO_MAX_QID) {\n\t\t\t\tcsio_wr_cleanup_eq_stpg(hw, i);\n\t\t\t\tif (!cmd) {\n\t\t\t\t\tcsio_q_eqid(hw, i) = CSIO_MAX_QID;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trv = csio_wr_eq_destroy(hw, NULL, i, NULL);\n\t\t\t\tif ((rv == -EBUSY) || (rv == -ETIMEDOUT))\n\t\t\t\t\tcmd = false;\n\n\t\t\t\tcsio_q_eqid(hw, i) = CSIO_MAX_QID;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase CSIO_INGRESS:\n\t\t\tif (csio_q_iqid(hw, i) != CSIO_MAX_QID) {\n\t\t\t\tcsio_wr_cleanup_iq_ftr(hw, i);\n\t\t\t\tif (!cmd) {\n\t\t\t\t\tcsio_q_iqid(hw, i) = CSIO_MAX_QID;\n\t\t\t\t\tflq_idx = csio_q_iq_flq_idx(hw, i);\n\t\t\t\t\tif (flq_idx != -1)\n\t\t\t\t\t\tcsio_q_flid(hw, flq_idx) =\n\t\t\t\t\t\t\t\tCSIO_MAX_QID;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trv = csio_wr_iq_destroy(hw, NULL, i, NULL);\n\t\t\t\tif ((rv == -EBUSY) || (rv == -ETIMEDOUT))\n\t\t\t\t\tcmd = false;\n\n\t\t\t\tcsio_q_iqid(hw, i) = CSIO_MAX_QID;\n\t\t\t\tflq_idx = csio_q_iq_flq_idx(hw, i);\n\t\t\t\tif (flq_idx != -1)\n\t\t\t\t\tcsio_q_flid(hw, flq_idx) = CSIO_MAX_QID;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thw->flags &= ~CSIO_HWF_Q_FW_ALLOCED;\n\n\treturn 0;\n}\n\n \nint\ncsio_wr_get(struct csio_hw *hw, int qidx, uint32_t size,\n\t    struct csio_wr_pair *wrp)\n{\n\tstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\n\tstruct csio_q *q = wrm->q_arr[qidx];\n\tvoid *cwr = (void *)((uintptr_t)(q->vstart) +\n\t\t\t\t\t\t(q->pidx * CSIO_QCREDIT_SZ));\n\tstruct csio_qstatus_page *stp = (struct csio_qstatus_page *)q->vwrap;\n\tuint16_t cidx = q->cidx = ntohs(stp->cidx);\n\tuint16_t pidx = q->pidx;\n\tuint32_t req_sz\t= ALIGN(size, CSIO_QCREDIT_SZ);\n\tint req_credits\t= req_sz / CSIO_QCREDIT_SZ;\n\tint credits;\n\n\tCSIO_DB_ASSERT(q->owner != NULL);\n\tCSIO_DB_ASSERT((qidx >= 0) && (qidx < wrm->free_qidx));\n\tCSIO_DB_ASSERT(cidx <= q->credits);\n\n\t \n\tif (pidx > cidx) {\n\t\tcredits = q->credits - (pidx - cidx) - 1;\n\t} else if (cidx > pidx) {\n\t\tcredits = cidx - pidx - 1;\n\t} else {\n\t\t \n\t\tcredits = q->credits;\n\t\tCSIO_INC_STATS(q, n_qempty);\n\t}\n\n\t \n\tif (!credits || (req_credits > credits)) {\n\t\tCSIO_INC_STATS(q, n_qfull);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (unlikely(((uintptr_t)cwr + req_sz) > (uintptr_t)(q->vwrap))) {\n\t\twrp->addr1 = cwr;\n\t\twrp->size1 = (uint32_t)((uintptr_t)q->vwrap - (uintptr_t)cwr);\n\t\twrp->addr2 = q->vstart;\n\t\twrp->size2 = req_sz - wrp->size1;\n\t\tq->pidx\t= (uint16_t)(ALIGN(wrp->size2, CSIO_QCREDIT_SZ) /\n\t\t\t\t\t\t\tCSIO_QCREDIT_SZ);\n\t\tCSIO_INC_STATS(q, n_qwrap);\n\t\tCSIO_INC_STATS(q, n_eq_wr_split);\n\t} else {\n\t\twrp->addr1 = cwr;\n\t\twrp->size1 = req_sz;\n\t\twrp->addr2 = NULL;\n\t\twrp->size2 = 0;\n\t\tq->pidx\t+= (uint16_t)req_credits;\n\n\t\t \n\t\tif (unlikely(q->pidx == q->credits)) {\n\t\t\tq->pidx = 0;\n\t\t\tCSIO_INC_STATS(q, n_qwrap);\n\t\t}\n\t}\n\n\tq->inc_idx = (uint16_t)req_credits;\n\n\tCSIO_INC_STATS(q, n_tot_reqs);\n\n\treturn 0;\n}\n\n \nvoid\ncsio_wr_copy_to_wrp(void *data_buf, struct csio_wr_pair *wrp,\n\t\t   uint32_t wr_off, uint32_t data_len)\n{\n\tuint32_t nbytes;\n\n\t \n\tnbytes = ((wrp->size1 - wr_off) >= data_len) ?\n\t\t\t\t\tdata_len : (wrp->size1 - wr_off);\n\n\tmemcpy((uint8_t *) wrp->addr1 + wr_off, data_buf, nbytes);\n\tdata_len -= nbytes;\n\n\t \n\tif (data_len) {\n\t\tCSIO_DB_ASSERT(data_len <= wrp->size2);\n\t\tCSIO_DB_ASSERT(wrp->addr2 != NULL);\n\t\tmemcpy(wrp->addr2, (uint8_t *) data_buf + nbytes, data_len);\n\t}\n}\n\n \nint\ncsio_wr_issue(struct csio_hw *hw, int qidx, bool prio)\n{\n\tstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\n\tstruct csio_q *q = wrm->q_arr[qidx];\n\n\tCSIO_DB_ASSERT((qidx >= 0) && (qidx < wrm->free_qidx));\n\n\twmb();\n\t \n\tcsio_wr_reg32(hw, DBPRIO_V(prio) | QID_V(q->un.eq.physeqid) |\n\t\t\t  PIDX_T5_V(q->inc_idx) | DBTYPE_F,\n\t\t\t  MYPF_REG(SGE_PF_KDOORBELL_A));\n\tq->inc_idx = 0;\n\n\treturn 0;\n}\n\nstatic inline uint32_t\ncsio_wr_avail_qcredits(struct csio_q *q)\n{\n\tif (q->pidx > q->cidx)\n\t\treturn q->pidx - q->cidx;\n\telse if (q->cidx > q->pidx)\n\t\treturn q->credits - (q->cidx - q->pidx);\n\telse\n\t\treturn 0;\t \n}\n\n \nstatic inline void\ncsio_wr_inval_flq_buf(struct csio_hw *hw, struct csio_q *flq)\n{\n\tflq->cidx++;\n\tif (flq->cidx == flq->credits) {\n\t\tflq->cidx = 0;\n\t\tCSIO_INC_STATS(flq, n_qwrap);\n\t}\n}\n\n \nstatic inline void\ncsio_wr_process_fl(struct csio_hw *hw, struct csio_q *q,\n\t\t   void *wr, uint32_t len_to_qid,\n\t\t   void (*iq_handler)(struct csio_hw *, void *,\n\t\t\t\t      uint32_t, struct csio_fl_dma_buf *,\n\t\t\t\t      void *),\n\t\t   void *priv)\n{\n\tstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\n\tstruct csio_sge *sge = &wrm->sge;\n\tstruct csio_fl_dma_buf flb;\n\tstruct csio_dma_buf *buf, *fbuf;\n\tuint32_t bufsz, len, lastlen = 0;\n\tstruct csio_q *flq = hw->wrm.q_arr[q->un.iq.flq_idx];\n\n\tCSIO_DB_ASSERT(flq != NULL);\n\n\tlen = len_to_qid;\n\n\tif (len & IQWRF_NEWBUF) {\n\t\tif (flq->un.fl.offset > 0) {\n\t\t\tcsio_wr_inval_flq_buf(hw, flq);\n\t\t\tflq->un.fl.offset = 0;\n\t\t}\n\t\tlen = IQWRF_LEN_GET(len);\n\t}\n\n\tCSIO_DB_ASSERT(len != 0);\n\n\tflb.totlen = len;\n\n\t \n\tfor (fbuf = flb.flbufs; ; fbuf++) {\n\t\tbuf = &flq->un.fl.bufs[flq->cidx];\n\t\tbufsz = csio_wr_fl_bufsz(sge, buf);\n\n\t\tfbuf->paddr\t= buf->paddr;\n\t\tfbuf->vaddr\t= buf->vaddr;\n\n\t\tflb.offset\t= flq->un.fl.offset;\n\t\tlastlen\t\t= min(bufsz, len);\n\t\tfbuf->len\t= lastlen;\n\n\t\tlen -= lastlen;\n\t\tif (!len)\n\t\t\tbreak;\n\t\tcsio_wr_inval_flq_buf(hw, flq);\n\t}\n\n\tflb.defer_free = flq->un.fl.packen ? 0 : 1;\n\n\tiq_handler(hw, wr, q->wr_sz - sizeof(struct csio_iqwr_footer),\n\t\t   &flb, priv);\n\n\tif (flq->un.fl.packen)\n\t\tflq->un.fl.offset += ALIGN(lastlen, sge->csio_fl_align);\n\telse\n\t\tcsio_wr_inval_flq_buf(hw, flq);\n\n}\n\n \nstatic inline bool\ncsio_is_new_iqwr(struct csio_q *q, struct csio_iqwr_footer *ftr)\n{\n\treturn (q->un.iq.genbit == (ftr->u.type_gen >> IQWRF_GEN_SHIFT));\n}\n\n \nint\ncsio_wr_process_iq(struct csio_hw *hw, struct csio_q *q,\n\t\t   void (*iq_handler)(struct csio_hw *, void *,\n\t\t\t\t      uint32_t, struct csio_fl_dma_buf *,\n\t\t\t\t      void *),\n\t\t   void *priv)\n{\n\tstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\n\tvoid *wr = (void *)((uintptr_t)q->vstart + (q->cidx * q->wr_sz));\n\tstruct csio_iqwr_footer *ftr;\n\tuint32_t wr_type, fw_qid, qid;\n\tstruct csio_q *q_completed;\n\tstruct csio_q *flq = csio_iq_has_fl(q) ?\n\t\t\t\t\twrm->q_arr[q->un.iq.flq_idx] : NULL;\n\tint rv = 0;\n\n\t \n\tftr = (struct csio_iqwr_footer *)((uintptr_t)wr +\n\t\t\t\t\t  (q->wr_sz - sizeof(*ftr)));\n\n\t \n\twhile (csio_is_new_iqwr(q, ftr)) {\n\n\t\tCSIO_DB_ASSERT(((uintptr_t)wr + q->wr_sz) <=\n\t\t\t\t\t\t(uintptr_t)q->vwrap);\n\t\trmb();\n\t\twr_type = IQWRF_TYPE_GET(ftr->u.type_gen);\n\n\t\tswitch (wr_type) {\n\t\tcase X_RSPD_TYPE_CPL:\n\t\t\t \n\t\t\tiq_handler(hw, wr, q->wr_sz - sizeof(*ftr), NULL, priv);\n\t\t\tbreak;\n\t\tcase X_RSPD_TYPE_FLBUF:\n\t\t\tcsio_wr_process_fl(hw, q, wr,\n\t\t\t\t\t   ntohl(ftr->pldbuflen_qid),\n\t\t\t\t\t   iq_handler, priv);\n\t\t\tbreak;\n\t\tcase X_RSPD_TYPE_INTR:\n\t\t\tfw_qid = ntohl(ftr->pldbuflen_qid);\n\t\t\tqid = fw_qid - wrm->fw_iq_start;\n\t\t\tq_completed = hw->wrm.intr_map[qid];\n\n\t\t\tif (unlikely(qid ==\n\t\t\t\t\tcsio_q_physiqid(hw, hw->intr_iq_idx))) {\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\tCSIO_DB_ASSERT(q_completed);\n\t\t\t\tCSIO_DB_ASSERT(\n\t\t\t\t\tq_completed->un.iq.iq_intx_handler);\n\n\t\t\t\t \n\t\t\t\tq_completed->un.iq.iq_intx_handler(hw, NULL,\n\t\t\t\t\t\t0, NULL, (void *)q_completed);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcsio_warn(hw, \"Unknown resp type 0x%x received\\n\",\n\t\t\t\t wr_type);\n\t\t\tCSIO_INC_STATS(q, n_rsp_unknown);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (((uintptr_t)wr + q->wr_sz) == (uintptr_t)q->vwrap) {\n\n\t\t\t \n\t\t\tq->cidx = 0;\n\t\t\twr\t= q->vstart;\n\n\t\t\t \n\t\t\tq->un.iq.genbit ^= 0x1;\n\n\t\t\tCSIO_INC_STATS(q, n_qwrap);\n\t\t} else {\n\t\t\tq->cidx++;\n\t\t\twr\t= (void *)((uintptr_t)(q->vstart) +\n\t\t\t\t\t   (q->cidx * q->wr_sz));\n\t\t}\n\n\t\tftr = (struct csio_iqwr_footer *)((uintptr_t)wr +\n\t\t\t\t\t\t  (q->wr_sz - sizeof(*ftr)));\n\t\tq->inc_idx++;\n\n\t}  \n\n\t \n\tif (unlikely(!q->inc_idx)) {\n\t\tCSIO_INC_STATS(q, n_stray_comp);\n\t\trv = -EINVAL;\n\t\tgoto restart;\n\t}\n\n\t \n\tif (flq) {\n\t\tuint32_t avail  = csio_wr_avail_qcredits(flq);\n\t\tif (avail <= 16) {\n\t\t\t \n\t\t\tcsio_wr_update_fl(hw, flq, (flq->credits - 8) - avail);\n\t\t\tcsio_wr_ring_fldb(hw, flq);\n\t\t}\n\t}\n\nrestart:\n\t \n\tcsio_wr_reg32(hw, CIDXINC_V(q->inc_idx)\t\t|\n\t\t\t  INGRESSQID_V(q->un.iq.physiqid)\t|\n\t\t\t  TIMERREG_V(csio_sge_timer_reg),\n\t\t\t  MYPF_REG(SGE_PF_GTS_A));\n\tq->stats.n_tot_rsps += q->inc_idx;\n\n\tq->inc_idx = 0;\n\n\treturn rv;\n}\n\nint\ncsio_wr_process_iq_idx(struct csio_hw *hw, int qidx,\n\t\t   void (*iq_handler)(struct csio_hw *, void *,\n\t\t\t\t      uint32_t, struct csio_fl_dma_buf *,\n\t\t\t\t      void *),\n\t\t   void *priv)\n{\n\tstruct csio_wrm *wrm\t= csio_hw_to_wrm(hw);\n\tstruct csio_q\t*iq\t= wrm->q_arr[qidx];\n\n\treturn csio_wr_process_iq(hw, iq, iq_handler, priv);\n}\n\nstatic int\ncsio_closest_timer(struct csio_sge *s, int time)\n{\n\tint i, delta, match = 0, min_delta = INT_MAX;\n\n\tfor (i = 0; i < ARRAY_SIZE(s->timer_val); i++) {\n\t\tdelta = time - s->timer_val[i];\n\t\tif (delta < 0)\n\t\t\tdelta = -delta;\n\t\tif (delta < min_delta) {\n\t\t\tmin_delta = delta;\n\t\t\tmatch = i;\n\t\t}\n\t}\n\treturn match;\n}\n\nstatic int\ncsio_closest_thresh(struct csio_sge *s, int cnt)\n{\n\tint i, delta, match = 0, min_delta = INT_MAX;\n\n\tfor (i = 0; i < ARRAY_SIZE(s->counter_val); i++) {\n\t\tdelta = cnt - s->counter_val[i];\n\t\tif (delta < 0)\n\t\t\tdelta = -delta;\n\t\tif (delta < min_delta) {\n\t\t\tmin_delta = delta;\n\t\t\tmatch = i;\n\t\t}\n\t}\n\treturn match;\n}\n\nstatic void\ncsio_wr_fixup_host_params(struct csio_hw *hw)\n{\n\tstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\n\tstruct csio_sge *sge = &wrm->sge;\n\tuint32_t clsz = L1_CACHE_BYTES;\n\tuint32_t s_hps = PAGE_SHIFT - 10;\n\tuint32_t stat_len = clsz > 64 ? 128 : 64;\n\tu32 fl_align = clsz < 32 ? 32 : clsz;\n\tu32 pack_align;\n\tu32 ingpad, ingpack;\n\n\tcsio_wr_reg32(hw, HOSTPAGESIZEPF0_V(s_hps) | HOSTPAGESIZEPF1_V(s_hps) |\n\t\t      HOSTPAGESIZEPF2_V(s_hps) | HOSTPAGESIZEPF3_V(s_hps) |\n\t\t      HOSTPAGESIZEPF4_V(s_hps) | HOSTPAGESIZEPF5_V(s_hps) |\n\t\t      HOSTPAGESIZEPF6_V(s_hps) | HOSTPAGESIZEPF7_V(s_hps),\n\t\t      SGE_HOST_PAGE_SIZE_A);\n\n\t \n\n\t \n\tpack_align = fl_align;\n\tif (pci_is_pcie(hw->pdev)) {\n\t\tu32 mps, mps_log;\n\t\tu16 devctl;\n\n\t\t \n\t\tpcie_capability_read_word(hw->pdev, PCI_EXP_DEVCTL, &devctl);\n\t\tmps_log = ((devctl & PCI_EXP_DEVCTL_PAYLOAD) >> 5) + 7;\n\t\tmps = 1 << mps_log;\n\t\tif (mps > pack_align)\n\t\t\tpack_align = mps;\n\t}\n\n\t \n\tif (pack_align <= 16) {\n\t\tingpack = INGPACKBOUNDARY_16B_X;\n\t\tfl_align = 16;\n\t} else if (pack_align == 32) {\n\t\tingpack = INGPACKBOUNDARY_64B_X;\n\t\tfl_align = 64;\n\t} else {\n\t\tu32 pack_align_log = fls(pack_align) - 1;\n\n\t\tingpack = pack_align_log - INGPACKBOUNDARY_SHIFT_X;\n\t\tfl_align = pack_align;\n\t}\n\n\t \n\tif (csio_is_t5(hw->pdev->device & CSIO_HW_CHIP_MASK))\n\t\tingpad = INGPADBOUNDARY_32B_X;\n\telse\n\t\tingpad = T6_INGPADBOUNDARY_8B_X;\n\n\tcsio_set_reg_field(hw, SGE_CONTROL_A,\n\t\t\t   INGPADBOUNDARY_V(INGPADBOUNDARY_M) |\n\t\t\t   EGRSTATUSPAGESIZE_F,\n\t\t\t   INGPADBOUNDARY_V(ingpad) |\n\t\t\t   EGRSTATUSPAGESIZE_V(stat_len != 64));\n\tcsio_set_reg_field(hw, SGE_CONTROL2_A,\n\t\t\t   INGPACKBOUNDARY_V(INGPACKBOUNDARY_M),\n\t\t\t   INGPACKBOUNDARY_V(ingpack));\n\n\t \n\tcsio_wr_reg32(hw, PAGE_SIZE, SGE_FL_BUFFER_SIZE0_A);\n\n\t \n\tif (hw->flags & CSIO_HWF_USING_SOFT_PARAMS) {\n\t\tcsio_wr_reg32(hw,\n\t\t\t(csio_rd_reg32(hw, SGE_FL_BUFFER_SIZE2_A) +\n\t\t\tfl_align - 1) & ~(fl_align - 1),\n\t\t\tSGE_FL_BUFFER_SIZE2_A);\n\t\tcsio_wr_reg32(hw,\n\t\t\t(csio_rd_reg32(hw, SGE_FL_BUFFER_SIZE3_A) +\n\t\t\tfl_align - 1) & ~(fl_align - 1),\n\t\t\tSGE_FL_BUFFER_SIZE3_A);\n\t}\n\n\tsge->csio_fl_align = fl_align;\n\n\tcsio_wr_reg32(hw, HPZ0_V(PAGE_SHIFT - 12), ULP_RX_TDDP_PSZ_A);\n\n\t \n\tcsio_set_reg_field(hw, SGE_CONTROL_A,\n\t\t\t   PKTSHIFT_V(PKTSHIFT_M),\n\t\t\t   PKTSHIFT_V(CSIO_SGE_RX_DMA_OFFSET));\n\n\tcsio_hw_tp_wr_bits_indirect(hw, TP_INGRESS_CONFIG_A,\n\t\t\t\t    CSUM_HAS_PSEUDO_HDR_F, 0);\n}\n\nstatic void\ncsio_init_intr_coalesce_parms(struct csio_hw *hw)\n{\n\tstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\n\tstruct csio_sge *sge = &wrm->sge;\n\n\tcsio_sge_thresh_reg = csio_closest_thresh(sge, csio_intr_coalesce_cnt);\n\tif (csio_intr_coalesce_cnt) {\n\t\tcsio_sge_thresh_reg = 0;\n\t\tcsio_sge_timer_reg = X_TIMERREG_RESTART_COUNTER;\n\t\treturn;\n\t}\n\n\tcsio_sge_timer_reg = csio_closest_timer(sge, csio_intr_coalesce_time);\n}\n\n \nstatic void\ncsio_wr_get_sge(struct csio_hw *hw)\n{\n\tstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\n\tstruct csio_sge *sge = &wrm->sge;\n\tuint32_t ingpad;\n\tint i;\n\tu32 timer_value_0_and_1, timer_value_2_and_3, timer_value_4_and_5;\n\tu32 ingress_rx_threshold;\n\n\tsge->sge_control = csio_rd_reg32(hw, SGE_CONTROL_A);\n\n\tingpad = INGPADBOUNDARY_G(sge->sge_control);\n\n\tswitch (ingpad) {\n\tcase X_INGPCIEBOUNDARY_32B:\n\t\tsge->csio_fl_align = 32; break;\n\tcase X_INGPCIEBOUNDARY_64B:\n\t\tsge->csio_fl_align = 64; break;\n\tcase X_INGPCIEBOUNDARY_128B:\n\t\tsge->csio_fl_align = 128; break;\n\tcase X_INGPCIEBOUNDARY_256B:\n\t\tsge->csio_fl_align = 256; break;\n\tcase X_INGPCIEBOUNDARY_512B:\n\t\tsge->csio_fl_align = 512; break;\n\tcase X_INGPCIEBOUNDARY_1024B:\n\t\tsge->csio_fl_align = 1024; break;\n\tcase X_INGPCIEBOUNDARY_2048B:\n\t\tsge->csio_fl_align = 2048; break;\n\tcase X_INGPCIEBOUNDARY_4096B:\n\t\tsge->csio_fl_align = 4096; break;\n\t}\n\n\tfor (i = 0; i < CSIO_SGE_FL_SIZE_REGS; i++)\n\t\tcsio_get_flbuf_size(hw, sge, i);\n\n\ttimer_value_0_and_1 = csio_rd_reg32(hw, SGE_TIMER_VALUE_0_AND_1_A);\n\ttimer_value_2_and_3 = csio_rd_reg32(hw, SGE_TIMER_VALUE_2_AND_3_A);\n\ttimer_value_4_and_5 = csio_rd_reg32(hw, SGE_TIMER_VALUE_4_AND_5_A);\n\n\tsge->timer_val[0] = (uint16_t)csio_core_ticks_to_us(hw,\n\t\t\t\t\tTIMERVALUE0_G(timer_value_0_and_1));\n\tsge->timer_val[1] = (uint16_t)csio_core_ticks_to_us(hw,\n\t\t\t\t\tTIMERVALUE1_G(timer_value_0_and_1));\n\tsge->timer_val[2] = (uint16_t)csio_core_ticks_to_us(hw,\n\t\t\t\t\tTIMERVALUE2_G(timer_value_2_and_3));\n\tsge->timer_val[3] = (uint16_t)csio_core_ticks_to_us(hw,\n\t\t\t\t\tTIMERVALUE3_G(timer_value_2_and_3));\n\tsge->timer_val[4] = (uint16_t)csio_core_ticks_to_us(hw,\n\t\t\t\t\tTIMERVALUE4_G(timer_value_4_and_5));\n\tsge->timer_val[5] = (uint16_t)csio_core_ticks_to_us(hw,\n\t\t\t\t\tTIMERVALUE5_G(timer_value_4_and_5));\n\n\tingress_rx_threshold = csio_rd_reg32(hw, SGE_INGRESS_RX_THRESHOLD_A);\n\tsge->counter_val[0] = THRESHOLD_0_G(ingress_rx_threshold);\n\tsge->counter_val[1] = THRESHOLD_1_G(ingress_rx_threshold);\n\tsge->counter_val[2] = THRESHOLD_2_G(ingress_rx_threshold);\n\tsge->counter_val[3] = THRESHOLD_3_G(ingress_rx_threshold);\n\n\tcsio_init_intr_coalesce_parms(hw);\n}\n\n \nstatic void\ncsio_wr_set_sge(struct csio_hw *hw)\n{\n\tstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\n\tstruct csio_sge *sge = &wrm->sge;\n\tint i;\n\n\t \n\tcsio_set_reg_field(hw, SGE_CONTROL_A, RXPKTCPLMODE_F, RXPKTCPLMODE_F);\n\n\tsge->sge_control = csio_rd_reg32(hw, SGE_CONTROL_A);\n\n\t \n\n\t \n\tcsio_set_reg_field(hw, SGE_DBFIFO_STATUS_A,\n\t\t\t   LP_INT_THRESH_T5_V(LP_INT_THRESH_T5_M),\n\t\t\t   LP_INT_THRESH_T5_V(CSIO_SGE_DBFIFO_INT_THRESH));\n\tcsio_set_reg_field(hw, SGE_DBFIFO_STATUS2_A,\n\t\t\t   HP_INT_THRESH_T5_V(LP_INT_THRESH_T5_M),\n\t\t\t   HP_INT_THRESH_T5_V(CSIO_SGE_DBFIFO_INT_THRESH));\n\n\tcsio_set_reg_field(hw, SGE_DOORBELL_CONTROL_A, ENABLE_DROP_F,\n\t\t\t   ENABLE_DROP_F);\n\n\t \n\n\tCSIO_SET_FLBUF_SIZE(hw, 1, CSIO_SGE_FLBUF_SIZE1);\n\tcsio_wr_reg32(hw, (CSIO_SGE_FLBUF_SIZE2 + sge->csio_fl_align - 1)\n\t\t      & ~(sge->csio_fl_align - 1), SGE_FL_BUFFER_SIZE2_A);\n\tcsio_wr_reg32(hw, (CSIO_SGE_FLBUF_SIZE3 + sge->csio_fl_align - 1)\n\t\t      & ~(sge->csio_fl_align - 1), SGE_FL_BUFFER_SIZE3_A);\n\tCSIO_SET_FLBUF_SIZE(hw, 4, CSIO_SGE_FLBUF_SIZE4);\n\tCSIO_SET_FLBUF_SIZE(hw, 5, CSIO_SGE_FLBUF_SIZE5);\n\tCSIO_SET_FLBUF_SIZE(hw, 6, CSIO_SGE_FLBUF_SIZE6);\n\tCSIO_SET_FLBUF_SIZE(hw, 7, CSIO_SGE_FLBUF_SIZE7);\n\tCSIO_SET_FLBUF_SIZE(hw, 8, CSIO_SGE_FLBUF_SIZE8);\n\n\tfor (i = 0; i < CSIO_SGE_FL_SIZE_REGS; i++)\n\t\tcsio_get_flbuf_size(hw, sge, i);\n\n\t \n\tsge->timer_val[0] = CSIO_SGE_TIMER_VAL_0;\n\tsge->timer_val[1] = CSIO_SGE_TIMER_VAL_1;\n\tsge->timer_val[2] = CSIO_SGE_TIMER_VAL_2;\n\tsge->timer_val[3] = CSIO_SGE_TIMER_VAL_3;\n\tsge->timer_val[4] = CSIO_SGE_TIMER_VAL_4;\n\tsge->timer_val[5] = CSIO_SGE_TIMER_VAL_5;\n\n\tsge->counter_val[0] = CSIO_SGE_INT_CNT_VAL_0;\n\tsge->counter_val[1] = CSIO_SGE_INT_CNT_VAL_1;\n\tsge->counter_val[2] = CSIO_SGE_INT_CNT_VAL_2;\n\tsge->counter_val[3] = CSIO_SGE_INT_CNT_VAL_3;\n\n\tcsio_wr_reg32(hw, THRESHOLD_0_V(sge->counter_val[0]) |\n\t\t      THRESHOLD_1_V(sge->counter_val[1]) |\n\t\t      THRESHOLD_2_V(sge->counter_val[2]) |\n\t\t      THRESHOLD_3_V(sge->counter_val[3]),\n\t\t      SGE_INGRESS_RX_THRESHOLD_A);\n\n\tcsio_wr_reg32(hw,\n\t\t   TIMERVALUE0_V(csio_us_to_core_ticks(hw, sge->timer_val[0])) |\n\t\t   TIMERVALUE1_V(csio_us_to_core_ticks(hw, sge->timer_val[1])),\n\t\t   SGE_TIMER_VALUE_0_AND_1_A);\n\n\tcsio_wr_reg32(hw,\n\t\t   TIMERVALUE2_V(csio_us_to_core_ticks(hw, sge->timer_val[2])) |\n\t\t   TIMERVALUE3_V(csio_us_to_core_ticks(hw, sge->timer_val[3])),\n\t\t   SGE_TIMER_VALUE_2_AND_3_A);\n\n\tcsio_wr_reg32(hw,\n\t\t   TIMERVALUE4_V(csio_us_to_core_ticks(hw, sge->timer_val[4])) |\n\t\t   TIMERVALUE5_V(csio_us_to_core_ticks(hw, sge->timer_val[5])),\n\t\t   SGE_TIMER_VALUE_4_AND_5_A);\n\n\tcsio_init_intr_coalesce_parms(hw);\n}\n\nvoid\ncsio_wr_sge_init(struct csio_hw *hw)\n{\n\t \n\tif (csio_is_hw_master(hw)) {\n\t\tif (hw->fw_state != CSIO_DEV_STATE_INIT)\n\t\t\tcsio_wr_fixup_host_params(hw);\n\n\t\tif (hw->flags & CSIO_HWF_USING_SOFT_PARAMS)\n\t\t\tcsio_wr_get_sge(hw);\n\t\telse\n\t\t\tcsio_wr_set_sge(hw);\n\t} else\n\t\tcsio_wr_get_sge(hw);\n}\n\n \nint\ncsio_wrm_init(struct csio_wrm *wrm, struct csio_hw *hw)\n{\n\tint i;\n\n\tif (!wrm->num_q) {\n\t\tcsio_err(hw, \"Num queues is not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twrm->q_arr = kcalloc(wrm->num_q, sizeof(struct csio_q *), GFP_KERNEL);\n\tif (!wrm->q_arr)\n\t\tgoto err;\n\n\tfor (i = 0; i < wrm->num_q; i++) {\n\t\twrm->q_arr[i] = kzalloc(sizeof(struct csio_q), GFP_KERNEL);\n\t\tif (!wrm->q_arr[i]) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tkfree(wrm->q_arr[i]);\n\t\t\tgoto err_free_arr;\n\t\t}\n\t}\n\twrm->free_qidx\t= 0;\n\n\treturn 0;\n\nerr_free_arr:\n\tkfree(wrm->q_arr);\nerr:\n\treturn -ENOMEM;\n}\n\n \nvoid\ncsio_wrm_exit(struct csio_wrm *wrm, struct csio_hw *hw)\n{\n\tint i;\n\tuint32_t j;\n\tstruct csio_q *q;\n\tstruct csio_dma_buf *buf;\n\n\tfor (i = 0; i < wrm->num_q; i++) {\n\t\tq = wrm->q_arr[i];\n\n\t\tif (wrm->free_qidx && (i < wrm->free_qidx)) {\n\t\t\tif (q->type == CSIO_FREELIST) {\n\t\t\t\tif (!q->un.fl.bufs)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (j = 0; j < q->credits; j++) {\n\t\t\t\t\tbuf = &q->un.fl.bufs[j];\n\t\t\t\t\tif (!buf->vaddr)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdma_free_coherent(&hw->pdev->dev,\n\t\t\t\t\t\t\tbuf->len, buf->vaddr,\n\t\t\t\t\t\t\tbuf->paddr);\n\t\t\t\t}\n\t\t\t\tkfree(q->un.fl.bufs);\n\t\t\t}\n\t\t\tdma_free_coherent(&hw->pdev->dev, q->size,\n\t\t\t\t\tq->vstart, q->pstart);\n\t\t}\n\t\tkfree(q);\n\t}\n\n\thw->flags &= ~CSIO_HWF_Q_MEM_ALLOCED;\n\n\tkfree(wrm->q_arr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}