{
  "module_name": "csio_mb.c",
  "hash_id": "22ee92afb2b314d2311258fdcd96dfbc6fb3094eeb6ebbccae4d19dc5cf2979d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/csiostor/csio_mb.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/string.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_transport_fc.h>\n\n#include \"csio_hw.h\"\n#include \"csio_lnode.h\"\n#include \"csio_rnode.h\"\n#include \"csio_mb.h\"\n#include \"csio_wr.h\"\n\n#define csio_mb_is_host_owner(__owner)\t\t((__owner) == CSIO_MBOWNER_PL)\n\n \n \nenum fw_retval\ncsio_mb_fw_retval(struct csio_mb *mbp)\n{\n\tstruct fw_cmd_hdr *hdr;\n\n\thdr = (struct fw_cmd_hdr *)(mbp->mb);\n\n\treturn FW_CMD_RETVAL_G(ntohl(hdr->lo));\n}\n\n \nvoid\ncsio_mb_hello(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo,\n\t      uint32_t m_mbox, uint32_t a_mbox, enum csio_dev_master master,\n\t      void (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_hello_cmd *cmdp = (struct fw_hello_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, tmo, hw, cbfn, 1);\n\n\tcmdp->op_to_write = htonl(FW_CMD_OP_V(FW_HELLO_CMD) |\n\t\t\t\t       FW_CMD_REQUEST_F | FW_CMD_WRITE_F);\n\tcmdp->retval_len16 = htonl(FW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\tcmdp->err_to_clearinit = htonl(\n\t\tFW_HELLO_CMD_MASTERDIS_V(master == CSIO_MASTER_CANT)\t|\n\t\tFW_HELLO_CMD_MASTERFORCE_V(master == CSIO_MASTER_MUST)\t|\n\t\tFW_HELLO_CMD_MBMASTER_V(master == CSIO_MASTER_MUST ?\n\t\t\t\tm_mbox : FW_HELLO_CMD_MBMASTER_M)\t|\n\t\tFW_HELLO_CMD_MBASYNCNOT_V(a_mbox) |\n\t\tFW_HELLO_CMD_STAGE_V(fw_hello_cmd_stage_os) |\n\t\tFW_HELLO_CMD_CLEARINIT_F);\n\n}\n\n \nvoid\ncsio_mb_process_hello_rsp(struct csio_hw *hw, struct csio_mb *mbp,\n\t\t\t  enum fw_retval *retval, enum csio_dev_state *state,\n\t\t\t  uint8_t *mpfn)\n{\n\tstruct fw_hello_cmd *rsp = (struct fw_hello_cmd *)(mbp->mb);\n\tuint32_t value;\n\n\t*retval = FW_CMD_RETVAL_G(ntohl(rsp->retval_len16));\n\n\tif (*retval == FW_SUCCESS) {\n\t\thw->fwrev = ntohl(rsp->fwrev);\n\n\t\tvalue = ntohl(rsp->err_to_clearinit);\n\t\t*mpfn = FW_HELLO_CMD_MBMASTER_G(value);\n\n\t\tif (value & FW_HELLO_CMD_INIT_F)\n\t\t\t*state = CSIO_DEV_STATE_INIT;\n\t\telse if (value & FW_HELLO_CMD_ERR_F)\n\t\t\t*state = CSIO_DEV_STATE_ERR;\n\t\telse\n\t\t\t*state = CSIO_DEV_STATE_UNINIT;\n\t}\n}\n\n \nvoid\ncsio_mb_bye(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo,\n\t    void (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_bye_cmd *cmdp = (struct fw_bye_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, tmo, hw, cbfn, 1);\n\n\tcmdp->op_to_write = htonl(FW_CMD_OP_V(FW_BYE_CMD) |\n\t\t\t\t       FW_CMD_REQUEST_F | FW_CMD_WRITE_F);\n\tcmdp->retval_len16 = htonl(FW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\n}\n\n \nvoid\ncsio_mb_reset(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo,\n\t      int reset, int halt,\n\t      void (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_reset_cmd *cmdp = (struct fw_reset_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, tmo, hw, cbfn, 1);\n\n\tcmdp->op_to_write = htonl(FW_CMD_OP_V(FW_RESET_CMD) |\n\t\t\t\t  FW_CMD_REQUEST_F | FW_CMD_WRITE_F);\n\tcmdp->retval_len16 = htonl(FW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\tcmdp->val = htonl(reset);\n\tcmdp->halt_pkd = htonl(halt);\n\n}\n\n \nvoid\ncsio_mb_params(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo,\n\t       unsigned int pf, unsigned int vf, unsigned int nparams,\n\t       const u32 *params, u32 *val, bool wr,\n\t       void (*cbfn)(struct csio_hw *, struct csio_mb *))\n{\n\tuint32_t i;\n\tuint32_t temp_params = 0, temp_val = 0;\n\tstruct fw_params_cmd *cmdp = (struct fw_params_cmd *)(mbp->mb);\n\t__be32 *p = &cmdp->param[0].mnem;\n\n\tCSIO_INIT_MBP(mbp, cmdp, tmo, hw, cbfn, 1);\n\n\tcmdp->op_to_vfn = htonl(FW_CMD_OP_V(FW_PARAMS_CMD)\t\t|\n\t\t\t\tFW_CMD_REQUEST_F\t\t\t|\n\t\t\t\t(wr ? FW_CMD_WRITE_F : FW_CMD_READ_F)\t|\n\t\t\t\tFW_PARAMS_CMD_PFN_V(pf)\t\t\t|\n\t\t\t\tFW_PARAMS_CMD_VFN_V(vf));\n\tcmdp->retval_len16 = htonl(FW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\n\t \n\tif (wr) {\n\t\twhile (nparams--) {\n\t\t\ttemp_params = *params++;\n\t\t\ttemp_val = *val++;\n\n\t\t\t*p++ = htonl(temp_params);\n\t\t\t*p++ = htonl(temp_val);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < nparams; i++, p += 2) {\n\t\t\ttemp_params = *params++;\n\t\t\t*p = htonl(temp_params);\n\t\t}\n\t}\n\n}\n\n \nvoid\ncsio_mb_process_read_params_rsp(struct csio_hw *hw, struct csio_mb *mbp,\n\t\t\t   enum fw_retval *retval, unsigned int nparams,\n\t\t\t   u32 *val)\n{\n\tstruct fw_params_cmd *rsp = (struct fw_params_cmd *)(mbp->mb);\n\tuint32_t i;\n\t__be32 *p = &rsp->param[0].val;\n\n\t*retval = FW_CMD_RETVAL_G(ntohl(rsp->retval_len16));\n\n\tif (*retval == FW_SUCCESS)\n\t\tfor (i = 0; i < nparams; i++, p += 2)\n\t\t\t*val++ = ntohl(*p);\n}\n\n \nvoid\ncsio_mb_ldst(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo, int reg)\n{\n\tstruct fw_ldst_cmd *ldst_cmd = (struct fw_ldst_cmd *)(mbp->mb);\n\tCSIO_INIT_MBP(mbp, ldst_cmd, tmo, hw, NULL, 1);\n\n\t \n\tldst_cmd->op_to_addrspace =\n\t\t\thtonl(FW_CMD_OP_V(FW_LDST_CMD)\t|\n\t\t\tFW_CMD_REQUEST_F\t\t\t|\n\t\t\tFW_CMD_READ_F\t\t\t|\n\t\t\tFW_LDST_CMD_ADDRSPACE_V(FW_LDST_ADDRSPC_FUNC_PCIE));\n\tldst_cmd->cycles_to_len16 = htonl(FW_LEN16(struct fw_ldst_cmd));\n\tldst_cmd->u.pcie.select_naccess = FW_LDST_CMD_NACCESS_V(1);\n\tldst_cmd->u.pcie.ctrl_to_fn =\n\t\t(FW_LDST_CMD_LC_F | FW_LDST_CMD_FN_V(hw->pfn));\n\tldst_cmd->u.pcie.r = (uint8_t)reg;\n}\n\n \nvoid\ncsio_mb_caps_config(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo,\n\t\t    bool wr, bool init, bool tgt, bool cofld,\n\t\t    void (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_caps_config_cmd *cmdp =\n\t\t\t\t(struct fw_caps_config_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, tmo, hw, cbfn, wr ? 0 : 1);\n\n\tcmdp->op_to_write = htonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t\t\t  FW_CMD_REQUEST_F\t\t|\n\t\t\t\t  (wr ? FW_CMD_WRITE_F : FW_CMD_READ_F));\n\tcmdp->cfvalid_to_len16 = htonl(FW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\n\t \n\tif (!wr)\n\t\treturn;\n\n\t \n\tcmdp->fcoecaps = 0;\n\n\tif (cofld)\n\t\tcmdp->fcoecaps |= htons(FW_CAPS_CONFIG_FCOE_CTRL_OFLD);\n\tif (init)\n\t\tcmdp->fcoecaps |= htons(FW_CAPS_CONFIG_FCOE_INITIATOR);\n\tif (tgt)\n\t\tcmdp->fcoecaps |= htons(FW_CAPS_CONFIG_FCOE_TARGET);\n}\n\n \nvoid\ncsio_mb_port(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo,\n\t     u8 portid, bool wr, uint32_t fc, uint16_t fw_caps,\n\t     void (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_port_cmd *cmdp = (struct fw_port_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, tmo, hw, cbfn,  1);\n\n\tcmdp->op_to_portid = htonl(FW_CMD_OP_V(FW_PORT_CMD)\t\t|\n\t\t\t\t   FW_CMD_REQUEST_F\t\t\t|\n\t\t\t\t   (wr ? FW_CMD_EXEC_F : FW_CMD_READ_F)\t|\n\t\t\t\t   FW_PORT_CMD_PORTID_V(portid));\n\tif (!wr) {\n\t\tcmdp->action_to_len16 = htonl(\n\t\t\tFW_PORT_CMD_ACTION_V(fw_caps == FW_CAPS16\n\t\t\t? FW_PORT_ACTION_GET_PORT_INFO\n\t\t\t: FW_PORT_ACTION_GET_PORT_INFO32) |\n\t\t\tFW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\t\treturn;\n\t}\n\n\t \n\tcmdp->action_to_len16 = htonl(\n\t\t\tFW_PORT_CMD_ACTION_V(fw_caps == FW_CAPS16\n\t\t\t? FW_PORT_ACTION_L1_CFG\n\t\t\t: FW_PORT_ACTION_L1_CFG32) |\n\t\t\tFW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\n\tif (fw_caps == FW_CAPS16)\n\t\tcmdp->u.l1cfg.rcap = cpu_to_be32(fwcaps32_to_caps16(fc));\n\telse\n\t\tcmdp->u.l1cfg32.rcap32 = cpu_to_be32(fc);\n}\n\n \nvoid\ncsio_mb_process_read_port_rsp(struct csio_hw *hw, struct csio_mb *mbp,\n\t\t\t enum fw_retval *retval, uint16_t fw_caps,\n\t\t\t u32 *pcaps, u32 *acaps)\n{\n\tstruct fw_port_cmd *rsp = (struct fw_port_cmd *)(mbp->mb);\n\n\t*retval = FW_CMD_RETVAL_G(ntohl(rsp->action_to_len16));\n\n\tif (*retval == FW_SUCCESS) {\n\t\tif (fw_caps == FW_CAPS16) {\n\t\t\t*pcaps = fwcaps16_to_caps32(ntohs(rsp->u.info.pcap));\n\t\t\t*acaps = fwcaps16_to_caps32(ntohs(rsp->u.info.acap));\n\t\t} else {\n\t\t\t*pcaps = be32_to_cpu(rsp->u.info32.pcaps32);\n\t\t\t*acaps = be32_to_cpu(rsp->u.info32.acaps32);\n\t\t}\n\t}\n}\n\n \nvoid\ncsio_mb_initialize(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo,\n\t\t   void (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_initialize_cmd *cmdp = (struct fw_initialize_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, tmo, hw, cbfn, 1);\n\n\tcmdp->op_to_write = htonl(FW_CMD_OP_V(FW_INITIALIZE_CMD)\t|\n\t\t\t\t  FW_CMD_REQUEST_F | FW_CMD_WRITE_F);\n\tcmdp->retval_len16 = htonl(FW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\n}\n\n \nstatic void\ncsio_mb_iq_alloc(struct csio_hw *hw, struct csio_mb *mbp, void *priv,\n\t\t uint32_t mb_tmo, struct csio_iq_params *iq_params,\n\t\t void (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_iq_cmd *cmdp = (struct fw_iq_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, mb_tmo, priv, cbfn, 1);\n\n\tcmdp->op_to_vfn = htonl(FW_CMD_OP_V(FW_IQ_CMD)\t\t|\n\t\t\t\tFW_CMD_REQUEST_F | FW_CMD_EXEC_F\t|\n\t\t\t\tFW_IQ_CMD_PFN_V(iq_params->pfn)\t|\n\t\t\t\tFW_IQ_CMD_VFN_V(iq_params->vfn));\n\n\tcmdp->alloc_to_len16 = htonl(FW_IQ_CMD_ALLOC_F\t\t|\n\t\t\t\tFW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\n\tcmdp->type_to_iqandstindex = htonl(\n\t\t\t\tFW_IQ_CMD_VIID_V(iq_params->viid)\t|\n\t\t\t\tFW_IQ_CMD_TYPE_V(iq_params->type)\t|\n\t\t\t\tFW_IQ_CMD_IQASYNCH_V(iq_params->iqasynch));\n\n\tcmdp->fl0size = htons(iq_params->fl0size);\n\tcmdp->fl0size = htons(iq_params->fl1size);\n\n}  \n\n \nstatic void\ncsio_mb_iq_write(struct csio_hw *hw, struct csio_mb *mbp, void *priv,\n\t\t uint32_t mb_tmo, bool cascaded_req,\n\t\t struct csio_iq_params *iq_params,\n\t\t void (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_iq_cmd *cmdp = (struct fw_iq_cmd *)(mbp->mb);\n\n\tuint32_t iq_start_stop = (iq_params->iq_start)\t?\n\t\t\t\t\tFW_IQ_CMD_IQSTART_F :\n\t\t\t\t\tFW_IQ_CMD_IQSTOP_F;\n\tint relaxed = !(hw->flags & CSIO_HWF_ROOT_NO_RELAXED_ORDERING);\n\n\t \n\tif (!cascaded_req)\n\t\tCSIO_INIT_MBP(mbp, cmdp, mb_tmo, priv, cbfn, 1);\n\n\tcmdp->op_to_vfn |= htonl(FW_CMD_OP_V(FW_IQ_CMD)\t\t|\n\t\t\t\tFW_CMD_REQUEST_F | FW_CMD_WRITE_F\t|\n\t\t\t\tFW_IQ_CMD_PFN_V(iq_params->pfn)\t|\n\t\t\t\tFW_IQ_CMD_VFN_V(iq_params->vfn));\n\tcmdp->alloc_to_len16 |= htonl(iq_start_stop |\n\t\t\t\tFW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\tcmdp->iqid |= htons(iq_params->iqid);\n\tcmdp->fl0id |= htons(iq_params->fl0id);\n\tcmdp->fl1id |= htons(iq_params->fl1id);\n\tcmdp->type_to_iqandstindex |= htonl(\n\t\t\tFW_IQ_CMD_IQANDST_V(iq_params->iqandst)\t|\n\t\t\tFW_IQ_CMD_IQANUS_V(iq_params->iqanus)\t|\n\t\t\tFW_IQ_CMD_IQANUD_V(iq_params->iqanud)\t|\n\t\t\tFW_IQ_CMD_IQANDSTINDEX_V(iq_params->iqandstindex));\n\tcmdp->iqdroprss_to_iqesize |= htons(\n\t\t\tFW_IQ_CMD_IQPCIECH_V(iq_params->iqpciech)\t|\n\t\t\tFW_IQ_CMD_IQDCAEN_V(iq_params->iqdcaen)\t\t|\n\t\t\tFW_IQ_CMD_IQDCACPU_V(iq_params->iqdcacpu)\t|\n\t\t\tFW_IQ_CMD_IQINTCNTTHRESH_V(iq_params->iqintcntthresh) |\n\t\t\tFW_IQ_CMD_IQCPRIO_V(iq_params->iqcprio)\t\t|\n\t\t\tFW_IQ_CMD_IQESIZE_V(iq_params->iqesize));\n\n\tcmdp->iqsize |= htons(iq_params->iqsize);\n\tcmdp->iqaddr |= cpu_to_be64(iq_params->iqaddr);\n\n\tif (iq_params->type == 0) {\n\t\tcmdp->iqns_to_fl0congen |= htonl(\n\t\t\tFW_IQ_CMD_IQFLINTIQHSEN_V(iq_params->iqflintiqhsen)|\n\t\t\tFW_IQ_CMD_IQFLINTCONGEN_V(iq_params->iqflintcongen));\n\t}\n\n\tif (iq_params->fl0size && iq_params->fl0addr &&\n\t    (iq_params->fl0id != 0xFFFF)) {\n\n\t\tcmdp->iqns_to_fl0congen |= htonl(\n\t\t\tFW_IQ_CMD_FL0HOSTFCMODE_V(iq_params->fl0hostfcmode)|\n\t\t\tFW_IQ_CMD_FL0CPRIO_V(iq_params->fl0cprio)\t|\n\t\t\tFW_IQ_CMD_FL0FETCHRO_V(relaxed)\t\t\t|\n\t\t\tFW_IQ_CMD_FL0DATARO_V(relaxed)\t\t\t|\n\t\t\tFW_IQ_CMD_FL0PADEN_V(iq_params->fl0paden)\t|\n\t\t\tFW_IQ_CMD_FL0PACKEN_V(iq_params->fl0packen));\n\t\tcmdp->fl0dcaen_to_fl0cidxfthresh |= htons(\n\t\t\tFW_IQ_CMD_FL0DCAEN_V(iq_params->fl0dcaen)\t|\n\t\t\tFW_IQ_CMD_FL0DCACPU_V(iq_params->fl0dcacpu)\t|\n\t\t\tFW_IQ_CMD_FL0FBMIN_V(iq_params->fl0fbmin)\t|\n\t\t\tFW_IQ_CMD_FL0FBMAX_V(iq_params->fl0fbmax)\t|\n\t\t\tFW_IQ_CMD_FL0CIDXFTHRESH_V(iq_params->fl0cidxfthresh));\n\t\tcmdp->fl0size |= htons(iq_params->fl0size);\n\t\tcmdp->fl0addr |= cpu_to_be64(iq_params->fl0addr);\n\t}\n}  \n\n \nvoid\ncsio_mb_iq_alloc_write(struct csio_hw *hw, struct csio_mb *mbp, void *priv,\n\t\t       uint32_t mb_tmo, struct csio_iq_params *iq_params,\n\t\t       void (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tcsio_mb_iq_alloc(hw, mbp, priv, mb_tmo, iq_params, cbfn);\n\tcsio_mb_iq_write(hw, mbp, priv, mb_tmo, true, iq_params, cbfn);\n}  \n\n \nvoid\ncsio_mb_iq_alloc_write_rsp(struct csio_hw *hw, struct csio_mb *mbp,\n\t\t\t   enum fw_retval *ret_val,\n\t\t\t   struct csio_iq_params *iq_params)\n{\n\tstruct fw_iq_cmd *rsp = (struct fw_iq_cmd *)(mbp->mb);\n\n\t*ret_val = FW_CMD_RETVAL_G(ntohl(rsp->alloc_to_len16));\n\tif (*ret_val == FW_SUCCESS) {\n\t\tiq_params->physiqid = ntohs(rsp->physiqid);\n\t\tiq_params->iqid = ntohs(rsp->iqid);\n\t\tiq_params->fl0id = ntohs(rsp->fl0id);\n\t\tiq_params->fl1id = ntohs(rsp->fl1id);\n\t} else {\n\t\tiq_params->physiqid = iq_params->iqid =\n\t\tiq_params->fl0id = iq_params->fl1id = 0;\n\t}\n}  \n\n \nvoid\ncsio_mb_iq_free(struct csio_hw *hw, struct csio_mb *mbp, void *priv,\n\t\tuint32_t mb_tmo, struct csio_iq_params *iq_params,\n\t\tvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_iq_cmd *cmdp = (struct fw_iq_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, mb_tmo, priv, cbfn, 1);\n\n\tcmdp->op_to_vfn = htonl(FW_CMD_OP_V(FW_IQ_CMD)\t\t|\n\t\t\t\tFW_CMD_REQUEST_F | FW_CMD_EXEC_F\t|\n\t\t\t\tFW_IQ_CMD_PFN_V(iq_params->pfn)\t|\n\t\t\t\tFW_IQ_CMD_VFN_V(iq_params->vfn));\n\tcmdp->alloc_to_len16 = htonl(FW_IQ_CMD_FREE_F\t\t|\n\t\t\t\tFW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\tcmdp->type_to_iqandstindex = htonl(FW_IQ_CMD_TYPE_V(iq_params->type));\n\n\tcmdp->iqid = htons(iq_params->iqid);\n\tcmdp->fl0id = htons(iq_params->fl0id);\n\tcmdp->fl1id = htons(iq_params->fl1id);\n\n}  \n\n \nstatic void\ncsio_mb_eq_ofld_alloc(struct csio_hw *hw, struct csio_mb *mbp, void *priv,\n\t\tuint32_t mb_tmo, struct csio_eq_params *eq_ofld_params,\n\t\tvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_eq_ofld_cmd *cmdp = (struct fw_eq_ofld_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, mb_tmo, priv, cbfn, 1);\n\tcmdp->op_to_vfn = htonl(FW_CMD_OP_V(FW_EQ_OFLD_CMD)\t\t|\n\t\t\t\tFW_CMD_REQUEST_F | FW_CMD_EXEC_F\t|\n\t\t\t\tFW_EQ_OFLD_CMD_PFN_V(eq_ofld_params->pfn) |\n\t\t\t\tFW_EQ_OFLD_CMD_VFN_V(eq_ofld_params->vfn));\n\tcmdp->alloc_to_len16 = htonl(FW_EQ_OFLD_CMD_ALLOC_F\t|\n\t\t\t\tFW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\n}  \n\n \nstatic void\ncsio_mb_eq_ofld_write(struct csio_hw *hw, struct csio_mb *mbp, void *priv,\n\t\t      uint32_t mb_tmo, bool cascaded_req,\n\t\t      struct csio_eq_params *eq_ofld_params,\n\t\t      void (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_eq_ofld_cmd *cmdp = (struct fw_eq_ofld_cmd *)(mbp->mb);\n\n\tuint32_t eq_start_stop = (eq_ofld_params->eqstart)\t?\n\t\t\t\tFW_EQ_OFLD_CMD_EQSTART_F :\n\t\t\t\tFW_EQ_OFLD_CMD_EQSTOP_F;\n\n\t \n\tif (!cascaded_req)\n\t\tCSIO_INIT_MBP(mbp, cmdp, mb_tmo, priv, cbfn, 1);\n\n\tcmdp->op_to_vfn |= htonl(FW_CMD_OP_V(FW_EQ_OFLD_CMD)\t|\n\t\t\t\tFW_CMD_REQUEST_F | FW_CMD_WRITE_F\t|\n\t\t\t\tFW_EQ_OFLD_CMD_PFN_V(eq_ofld_params->pfn) |\n\t\t\t\tFW_EQ_OFLD_CMD_VFN_V(eq_ofld_params->vfn));\n\tcmdp->alloc_to_len16 |= htonl(eq_start_stop\t\t|\n\t\t\t\t      FW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\n\tcmdp->eqid_pkd |= htonl(FW_EQ_OFLD_CMD_EQID_V(eq_ofld_params->eqid));\n\n\tcmdp->fetchszm_to_iqid |= htonl(\n\t\tFW_EQ_OFLD_CMD_HOSTFCMODE_V(eq_ofld_params->hostfcmode)\t|\n\t\tFW_EQ_OFLD_CMD_CPRIO_V(eq_ofld_params->cprio)\t\t|\n\t\tFW_EQ_OFLD_CMD_PCIECHN_V(eq_ofld_params->pciechn)\t|\n\t\tFW_EQ_OFLD_CMD_IQID_V(eq_ofld_params->iqid));\n\n\tcmdp->dcaen_to_eqsize |= htonl(\n\t\tFW_EQ_OFLD_CMD_DCAEN_V(eq_ofld_params->dcaen)\t\t|\n\t\tFW_EQ_OFLD_CMD_DCACPU_V(eq_ofld_params->dcacpu)\t\t|\n\t\tFW_EQ_OFLD_CMD_FBMIN_V(eq_ofld_params->fbmin)\t\t|\n\t\tFW_EQ_OFLD_CMD_FBMAX_V(eq_ofld_params->fbmax)\t\t|\n\t\tFW_EQ_OFLD_CMD_CIDXFTHRESHO_V(eq_ofld_params->cidxfthresho) |\n\t\tFW_EQ_OFLD_CMD_CIDXFTHRESH_V(eq_ofld_params->cidxfthresh) |\n\t\tFW_EQ_OFLD_CMD_EQSIZE_V(eq_ofld_params->eqsize));\n\n\tcmdp->eqaddr |= cpu_to_be64(eq_ofld_params->eqaddr);\n\n}  \n\n \nvoid\ncsio_mb_eq_ofld_alloc_write(struct csio_hw *hw, struct csio_mb *mbp,\n\t\t\t    void *priv, uint32_t mb_tmo,\n\t\t\t    struct csio_eq_params *eq_ofld_params,\n\t\t\t    void (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tcsio_mb_eq_ofld_alloc(hw, mbp, priv, mb_tmo, eq_ofld_params, cbfn);\n\tcsio_mb_eq_ofld_write(hw, mbp, priv, mb_tmo, true,\n\t\t\t      eq_ofld_params, cbfn);\n}  \n\n \nvoid\ncsio_mb_eq_ofld_alloc_write_rsp(struct csio_hw *hw,\n\t\t\t\tstruct csio_mb *mbp, enum fw_retval *ret_val,\n\t\t\t\tstruct csio_eq_params *eq_ofld_params)\n{\n\tstruct fw_eq_ofld_cmd *rsp = (struct fw_eq_ofld_cmd *)(mbp->mb);\n\n\t*ret_val = FW_CMD_RETVAL_G(ntohl(rsp->alloc_to_len16));\n\n\tif (*ret_val == FW_SUCCESS) {\n\t\teq_ofld_params->eqid = FW_EQ_OFLD_CMD_EQID_G(\n\t\t\t\t\t\tntohl(rsp->eqid_pkd));\n\t\teq_ofld_params->physeqid = FW_EQ_OFLD_CMD_PHYSEQID_G(\n\t\t\t\t\t\tntohl(rsp->physeqid_pkd));\n\t} else\n\t\teq_ofld_params->eqid = 0;\n\n}  \n\n \nvoid\ncsio_mb_eq_ofld_free(struct csio_hw *hw, struct csio_mb *mbp, void *priv,\n\t\t     uint32_t mb_tmo, struct csio_eq_params *eq_ofld_params,\n\t\t     void (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_eq_ofld_cmd *cmdp = (struct fw_eq_ofld_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, mb_tmo, priv, cbfn, 1);\n\n\tcmdp->op_to_vfn = htonl(FW_CMD_OP_V(FW_EQ_OFLD_CMD)\t|\n\t\t\t\tFW_CMD_REQUEST_F | FW_CMD_EXEC_F\t|\n\t\t\t\tFW_EQ_OFLD_CMD_PFN_V(eq_ofld_params->pfn) |\n\t\t\t\tFW_EQ_OFLD_CMD_VFN_V(eq_ofld_params->vfn));\n\tcmdp->alloc_to_len16 = htonl(FW_EQ_OFLD_CMD_FREE_F |\n\t\t\t\tFW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\tcmdp->eqid_pkd = htonl(FW_EQ_OFLD_CMD_EQID_V(eq_ofld_params->eqid));\n\n}  \n\n \nvoid\ncsio_write_fcoe_link_cond_init_mb(struct csio_lnode *ln, struct csio_mb *mbp,\n\t\t\tuint32_t mb_tmo, uint8_t port_id, uint32_t sub_opcode,\n\t\t\tuint8_t cos, bool link_status, uint32_t fcfi,\n\t\t\tvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_fcoe_link_cmd *cmdp =\n\t\t\t\t(struct fw_fcoe_link_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, mb_tmo, ln, cbfn, 1);\n\n\tcmdp->op_to_portid = htonl((\n\t\t\tFW_CMD_OP_V(FW_FCOE_LINK_CMD)\t\t|\n\t\t\tFW_CMD_REQUEST_F\t\t\t\t|\n\t\t\tFW_CMD_WRITE_F\t\t\t\t|\n\t\t\tFW_FCOE_LINK_CMD_PORTID(port_id)));\n\tcmdp->sub_opcode_fcfi = htonl(\n\t\t\tFW_FCOE_LINK_CMD_SUB_OPCODE(sub_opcode)\t|\n\t\t\tFW_FCOE_LINK_CMD_FCFI(fcfi));\n\tcmdp->lstatus = link_status;\n\tcmdp->retval_len16 = htonl(FW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\n}  \n\n \nvoid\ncsio_fcoe_read_res_info_init_mb(struct csio_hw *hw, struct csio_mb *mbp,\n\t\t\tuint32_t mb_tmo,\n\t\t\tvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_fcoe_res_info_cmd *cmdp =\n\t\t\t(struct fw_fcoe_res_info_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, mb_tmo, hw, cbfn, 1);\n\n\tcmdp->op_to_read = htonl((FW_CMD_OP_V(FW_FCOE_RES_INFO_CMD)\t|\n\t\t\t\t  FW_CMD_REQUEST_F\t\t\t|\n\t\t\t\t  FW_CMD_READ_F));\n\n\tcmdp->retval_len16 = htonl(FW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\n}  \n\n \nvoid\ncsio_fcoe_vnp_alloc_init_mb(struct csio_lnode *ln, struct csio_mb *mbp,\n\t\tuint32_t mb_tmo, uint32_t fcfi, uint32_t vnpi, uint16_t iqid,\n\t\tuint8_t vnport_wwnn[8],\tuint8_t vnport_wwpn[8],\n\t\tvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_fcoe_vnp_cmd *cmdp =\n\t\t\t(struct fw_fcoe_vnp_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, mb_tmo, ln, cbfn, 1);\n\n\tcmdp->op_to_fcfi = htonl((FW_CMD_OP_V(FW_FCOE_VNP_CMD)\t\t|\n\t\t\t\t  FW_CMD_REQUEST_F\t\t\t|\n\t\t\t\t  FW_CMD_EXEC_F\t\t\t\t|\n\t\t\t\t  FW_FCOE_VNP_CMD_FCFI(fcfi)));\n\n\tcmdp->alloc_to_len16 = htonl(FW_FCOE_VNP_CMD_ALLOC\t\t|\n\t\t\t\t     FW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\n\tcmdp->gen_wwn_to_vnpi = htonl(FW_FCOE_VNP_CMD_VNPI(vnpi));\n\n\tcmdp->iqid = htons(iqid);\n\n\tif (!wwn_to_u64(vnport_wwnn) && !wwn_to_u64(vnport_wwpn))\n\t\tcmdp->gen_wwn_to_vnpi |= htonl(FW_FCOE_VNP_CMD_GEN_WWN);\n\n\tif (vnport_wwnn)\n\t\tmemcpy(cmdp->vnport_wwnn, vnport_wwnn, 8);\n\tif (vnport_wwpn)\n\t\tmemcpy(cmdp->vnport_wwpn, vnport_wwpn, 8);\n\n}  \n\n \nvoid\ncsio_fcoe_vnp_read_init_mb(struct csio_lnode *ln, struct csio_mb *mbp,\n\t\tuint32_t mb_tmo, uint32_t fcfi, uint32_t vnpi,\n\t\tvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_fcoe_vnp_cmd *cmdp =\n\t\t\t(struct fw_fcoe_vnp_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, mb_tmo, ln, cbfn, 1);\n\tcmdp->op_to_fcfi = htonl(FW_CMD_OP_V(FW_FCOE_VNP_CMD)\t|\n\t\t\t\t FW_CMD_REQUEST_F\t\t\t|\n\t\t\t\t FW_CMD_READ_F\t\t\t|\n\t\t\t\t FW_FCOE_VNP_CMD_FCFI(fcfi));\n\tcmdp->alloc_to_len16 = htonl(FW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\tcmdp->gen_wwn_to_vnpi = htonl(FW_FCOE_VNP_CMD_VNPI(vnpi));\n}\n\n \nvoid\ncsio_fcoe_vnp_free_init_mb(struct csio_lnode *ln, struct csio_mb *mbp,\n\t\tuint32_t mb_tmo, uint32_t fcfi, uint32_t vnpi,\n\t\tvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_fcoe_vnp_cmd *cmdp =\n\t\t\t(struct fw_fcoe_vnp_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, mb_tmo, ln, cbfn, 1);\n\n\tcmdp->op_to_fcfi = htonl(FW_CMD_OP_V(FW_FCOE_VNP_CMD)\t|\n\t\t\t\t FW_CMD_REQUEST_F\t\t\t|\n\t\t\t\t FW_CMD_EXEC_F\t\t\t|\n\t\t\t\t FW_FCOE_VNP_CMD_FCFI(fcfi));\n\tcmdp->alloc_to_len16 = htonl(FW_FCOE_VNP_CMD_FREE\t|\n\t\t\t\t     FW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\tcmdp->gen_wwn_to_vnpi = htonl(FW_FCOE_VNP_CMD_VNPI(vnpi));\n}\n\n \nvoid\ncsio_fcoe_read_fcf_init_mb(struct csio_lnode *ln, struct csio_mb *mbp,\n\t\tuint32_t mb_tmo, uint32_t portid, uint32_t fcfi,\n\t\tvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct fw_fcoe_fcf_cmd *cmdp =\n\t\t\t(struct fw_fcoe_fcf_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, mb_tmo, ln, cbfn, 1);\n\n\tcmdp->op_to_fcfi = htonl(FW_CMD_OP_V(FW_FCOE_FCF_CMD)\t|\n\t\t\t\t FW_CMD_REQUEST_F\t\t\t|\n\t\t\t\t FW_CMD_READ_F\t\t\t|\n\t\t\t\t FW_FCOE_FCF_CMD_FCFI(fcfi));\n\tcmdp->retval_len16 = htonl(FW_CMD_LEN16_V(sizeof(*cmdp) / 16));\n\n}  \n\nvoid\ncsio_fcoe_read_portparams_init_mb(struct csio_hw *hw, struct csio_mb *mbp,\n\t\t\t\tuint32_t mb_tmo,\n\t\t\t\tstruct fw_fcoe_port_cmd_params *portparams,\n\t\t\t\tvoid (*cbfn)(struct csio_hw *,\n\t\t\t\t\t     struct csio_mb *))\n{\n\tstruct fw_fcoe_stats_cmd *cmdp = (struct fw_fcoe_stats_cmd *)(mbp->mb);\n\n\tCSIO_INIT_MBP(mbp, cmdp, mb_tmo, hw, cbfn, 1);\n\tmbp->mb_size = 64;\n\n\tcmdp->op_to_flowid = htonl(FW_CMD_OP_V(FW_FCOE_STATS_CMD)         |\n\t\t\t\t   FW_CMD_REQUEST_F | FW_CMD_READ_F);\n\tcmdp->free_to_len16 = htonl(FW_CMD_LEN16_V(CSIO_MAX_MB_SIZE/16));\n\n\tcmdp->u.ctl.nstats_port = FW_FCOE_STATS_CMD_NSTATS(portparams->nstats) |\n\t\t\t\t  FW_FCOE_STATS_CMD_PORT(portparams->portid);\n\n\tcmdp->u.ctl.port_valid_ix = FW_FCOE_STATS_CMD_IX(portparams->idx)    |\n\t\t\t\t    FW_FCOE_STATS_CMD_PORT_VALID;\n\n}  \n\nvoid\ncsio_mb_process_portparams_rsp(struct csio_hw *hw,\n\t\t\t\tstruct csio_mb *mbp,\n\t\t\t\tenum fw_retval *retval,\n\t\t\t\tstruct fw_fcoe_port_cmd_params *portparams,\n\t\t\t\tstruct fw_fcoe_port_stats *portstats)\n{\n\tstruct fw_fcoe_stats_cmd *rsp = (struct fw_fcoe_stats_cmd *)(mbp->mb);\n\tstruct fw_fcoe_port_stats stats;\n\tuint8_t *src;\n\tuint8_t *dst;\n\n\t*retval = FW_CMD_RETVAL_G(ntohl(rsp->free_to_len16));\n\n\tmemset(&stats, 0, sizeof(struct fw_fcoe_port_stats));\n\n\tif (*retval == FW_SUCCESS) {\n\t\tdst = (uint8_t *)(&stats) + ((portparams->idx - 1) * 8);\n\t\tsrc = (uint8_t *)rsp + (CSIO_STATS_OFFSET * 8);\n\t\tmemcpy(dst, src, (portparams->nstats * 8));\n\t\tif (portparams->idx == 1) {\n\t\t\t \n\t\t\tportstats->tx_bcast_bytes = stats.tx_bcast_bytes;\n\t\t\tportstats->tx_bcast_frames = stats.tx_bcast_frames;\n\t\t\tportstats->tx_mcast_bytes = stats.tx_mcast_bytes;\n\t\t\tportstats->tx_mcast_frames = stats.tx_mcast_frames;\n\t\t\tportstats->tx_ucast_bytes = stats.tx_ucast_bytes;\n\t\t\tportstats->tx_ucast_frames = stats.tx_ucast_frames;\n\t\t}\n\t\tif (portparams->idx == 7) {\n\t\t\t \n\t\t\tportstats->tx_drop_frames = stats.tx_drop_frames;\n\t\t\tportstats->tx_offload_bytes = stats.tx_offload_bytes;\n\t\t\tportstats->tx_offload_frames = stats.tx_offload_frames;\n#if 0\n\t\t\tportstats->rx_pf_bytes = stats.rx_pf_bytes;\n\t\t\tportstats->rx_pf_frames\t= stats.rx_pf_frames;\n#endif\n\t\t\tportstats->rx_bcast_bytes = stats.rx_bcast_bytes;\n\t\t\tportstats->rx_bcast_frames = stats.rx_bcast_frames;\n\t\t\tportstats->rx_mcast_bytes = stats.rx_mcast_bytes;\n\t\t}\n\t\tif (portparams->idx == 13) {\n\t\t\t \n\t\t\tportstats->rx_mcast_frames = stats.rx_mcast_frames;\n\t\t\tportstats->rx_ucast_bytes = stats.rx_ucast_bytes;\n\t\t\tportstats->rx_ucast_frames = stats.rx_ucast_frames;\n\t\t\tportstats->rx_err_frames = stats.rx_err_frames;\n\t\t}\n\t}\n}\n\n \n \nvoid\ncsio_mb_intr_enable(struct csio_hw *hw)\n{\n\tcsio_wr_reg32(hw, MBMSGRDYINTEN_F, MYPF_REG(CIM_PF_HOST_INT_ENABLE_A));\n\tcsio_rd_reg32(hw, MYPF_REG(CIM_PF_HOST_INT_ENABLE_A));\n}\n\n \nvoid\ncsio_mb_intr_disable(struct csio_hw *hw)\n{\n\tcsio_wr_reg32(hw, MBMSGRDYINTEN_V(0),\n\t\t      MYPF_REG(CIM_PF_HOST_INT_ENABLE_A));\n\tcsio_rd_reg32(hw, MYPF_REG(CIM_PF_HOST_INT_ENABLE_A));\n}\n\nstatic void\ncsio_mb_dump_fw_dbg(struct csio_hw *hw, __be64 *cmd)\n{\n\tstruct fw_debug_cmd *dbg = (struct fw_debug_cmd *)cmd;\n\n\tif ((FW_DEBUG_CMD_TYPE_G(ntohl(dbg->op_type))) == 1) {\n\t\tcsio_info(hw, \"FW print message:\\n\");\n\t\tcsio_info(hw, \"\\tdebug->dprtstridx = %d\\n\",\n\t\t\t    ntohs(dbg->u.prt.dprtstridx));\n\t\tcsio_info(hw, \"\\tdebug->dprtstrparam0 = 0x%x\\n\",\n\t\t\t    ntohl(dbg->u.prt.dprtstrparam0));\n\t\tcsio_info(hw, \"\\tdebug->dprtstrparam1 = 0x%x\\n\",\n\t\t\t    ntohl(dbg->u.prt.dprtstrparam1));\n\t\tcsio_info(hw, \"\\tdebug->dprtstrparam2 = 0x%x\\n\",\n\t\t\t    ntohl(dbg->u.prt.dprtstrparam2));\n\t\tcsio_info(hw, \"\\tdebug->dprtstrparam3 = 0x%x\\n\",\n\t\t\t    ntohl(dbg->u.prt.dprtstrparam3));\n\t} else {\n\t\t \n\t\tcsio_fatal(hw, \"FW assertion at %.16s:%u, val0 %#x, val1 %#x\\n\",\n\t\t\t    dbg->u.assert.filename_0_7,\n\t\t\t    ntohl(dbg->u.assert.line),\n\t\t\t    ntohl(dbg->u.assert.x),\n\t\t\t    ntohl(dbg->u.assert.y));\n\t}\n}\n\nstatic void\ncsio_mb_debug_cmd_handler(struct csio_hw *hw)\n{\n\tint i;\n\t__be64 cmd[CSIO_MB_MAX_REGS];\n\tuint32_t ctl_reg = PF_REG(hw->pfn, CIM_PF_MAILBOX_CTRL_A);\n\tuint32_t data_reg = PF_REG(hw->pfn, CIM_PF_MAILBOX_DATA_A);\n\tint size = sizeof(struct fw_debug_cmd);\n\n\t \n\tfor (i = 0; i < size; i += 8)\n\t\tcmd[i / 8] = cpu_to_be64(csio_rd_reg64(hw, data_reg + i));\n\n\tcsio_mb_dump_fw_dbg(hw, cmd);\n\n\t \n\tcsio_wr_reg32(hw, MBMSGVALID_F | MBINTREQ_F |\n\t\t      MBOWNER_V(CSIO_MBOWNER_FW), ctl_reg);\n\n\tcsio_rd_reg32(hw, ctl_reg);\n\twmb();\n}\n\n \nint\ncsio_mb_issue(struct csio_hw *hw, struct csio_mb *mbp)\n{\n\tuint32_t owner, ctl;\n\tint i;\n\tuint32_t ii;\n\t__be64 *cmd = mbp->mb;\n\t__be64 hdr;\n\tstruct csio_mbm\t*mbm = &hw->mbm;\n\tuint32_t ctl_reg = PF_REG(hw->pfn, CIM_PF_MAILBOX_CTRL_A);\n\tuint32_t data_reg = PF_REG(hw->pfn, CIM_PF_MAILBOX_DATA_A);\n\tint size = mbp->mb_size;\n\tint rv = -EINVAL;\n\tstruct fw_cmd_hdr *fw_hdr;\n\n\t \n\tif (mbp->mb_cbfn == NULL) {\n\t\t \n\t\tif (mbp->tmo < CSIO_MB_POLL_FREQ) {\n\t\t\tcsio_err(hw, \"Invalid tmo: 0x%x\\n\", mbp->tmo);\n\t\t\tgoto error_out;\n\t\t}\n\t} else if (!csio_is_host_intr_enabled(hw) ||\n\t\t   !csio_is_hw_intr_enabled(hw)) {\n\t\tcsio_err(hw, \"Cannot issue mailbox in interrupt mode 0x%x\\n\",\n\t\t\t *((uint8_t *)mbp->mb));\n\t\tgoto error_out;\n\t}\n\n\tif (mbm->mcurrent != NULL) {\n\t\t \n\t\tif (mbp->mb_cbfn == NULL) {\n\t\t\trv = -EBUSY;\n\t\t\tcsio_dbg(hw, \"Couldn't own Mailbox %x op:0x%x\\n\",\n\t\t\t\t    hw->pfn, *((uint8_t *)mbp->mb));\n\n\t\t\tgoto error_out;\n\t\t} else {\n\t\t\tlist_add_tail(&mbp->list, &mbm->req_q);\n\t\t\tCSIO_INC_STATS(mbm, n_activeq);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\towner = MBOWNER_G(csio_rd_reg32(hw, ctl_reg));\n\n\tif (!csio_mb_is_host_owner(owner)) {\n\n\t\tfor (i = 0; (owner == CSIO_MBOWNER_NONE) && (i < 3); i++)\n\t\t\towner = MBOWNER_G(csio_rd_reg32(hw, ctl_reg));\n\t\t \n\t\tif (!csio_mb_is_host_owner(owner)) {\n\t\t\tif (mbp->mb_cbfn == NULL) {\n\t\t\t\trv = owner ? -EBUSY : -ETIMEDOUT;\n\n\t\t\t\tcsio_dbg(hw,\n\t\t\t\t\t \"Couldn't own Mailbox %x op:0x%x \"\n\t\t\t\t\t \"owner:%x\\n\",\n\t\t\t\t\t hw->pfn, *((uint8_t *)mbp->mb), owner);\n\t\t\t\tgoto error_out;\n\t\t\t} else {\n\t\t\t\tif (mbm->mcurrent == NULL) {\n\t\t\t\t\tcsio_err(hw,\n\t\t\t\t\t\t \"Couldn't own Mailbox %x \"\n\t\t\t\t\t\t \"op:0x%x owner:%x\\n\",\n\t\t\t\t\t\t hw->pfn, *((uint8_t *)mbp->mb),\n\t\t\t\t\t\t owner);\n\t\t\t\t\tcsio_err(hw,\n\t\t\t\t\t\t \"No outstanding driver\"\n\t\t\t\t\t\t \" mailbox as well\\n\");\n\t\t\t\t\tgoto error_out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < size; i += 8) {\n\t\tcsio_wr_reg64(hw, be64_to_cpu(*cmd), data_reg + i);\n\t\tcmd++;\n\t}\n\n\tCSIO_DUMP_MB(hw, hw->pfn, data_reg);\n\n\t \n\tif (mbp->mb_cbfn != NULL) {\n\t\tmbm->mcurrent = mbp;\n\t\tmod_timer(&mbm->timer, jiffies + msecs_to_jiffies(mbp->tmo));\n\t\tcsio_wr_reg32(hw, MBMSGVALID_F | MBINTREQ_F |\n\t\t\t      MBOWNER_V(CSIO_MBOWNER_FW), ctl_reg);\n\t} else\n\t\tcsio_wr_reg32(hw, MBMSGVALID_F | MBOWNER_V(CSIO_MBOWNER_FW),\n\t\t\t      ctl_reg);\n\n\t \n\tcsio_rd_reg32(hw, ctl_reg);\n\twmb();\n\n\tCSIO_INC_STATS(mbm, n_req);\n\n\tif (mbp->mb_cbfn)\n\t\treturn 0;\n\n\t \n\tcmd = mbp->mb;\n\n\tfor (ii = 0; ii < mbp->tmo; ii += CSIO_MB_POLL_FREQ) {\n\t\tmdelay(CSIO_MB_POLL_FREQ);\n\n\t\t \n\t\tctl = csio_rd_reg32(hw, ctl_reg);\n\t\tif (csio_mb_is_host_owner(MBOWNER_G(ctl))) {\n\n\t\t\tif (!(ctl & MBMSGVALID_F)) {\n\t\t\t\tcsio_wr_reg32(hw, 0, ctl_reg);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tCSIO_DUMP_MB(hw, hw->pfn, data_reg);\n\n\t\t\thdr = cpu_to_be64(csio_rd_reg64(hw, data_reg));\n\t\t\tfw_hdr = (struct fw_cmd_hdr *)&hdr;\n\n\t\t\tswitch (FW_CMD_OP_G(ntohl(fw_hdr->hi))) {\n\t\t\tcase FW_DEBUG_CMD:\n\t\t\t\tcsio_mb_debug_cmd_handler(hw);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (i = 0; i < size; i += 8)\n\t\t\t\t*cmd++ = cpu_to_be64(csio_rd_reg64\n\t\t\t\t\t\t\t  (hw, data_reg + i));\n\t\t\tcsio_wr_reg32(hw, 0, ctl_reg);\n\n\t\t\tif (csio_mb_fw_retval(mbp) != FW_SUCCESS)\n\t\t\t\tCSIO_INC_STATS(mbm, n_err);\n\n\t\t\tCSIO_INC_STATS(mbm, n_rsp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tCSIO_INC_STATS(mbm, n_tmo);\n\n\tcsio_err(hw, \"Mailbox %x op:0x%x timed out!\\n\",\n\t\t hw->pfn, *((uint8_t *)cmd));\n\n\treturn -ETIMEDOUT;\n\nerror_out:\n\tCSIO_INC_STATS(mbm, n_err);\n\treturn rv;\n}\n\n \nvoid\ncsio_mb_completions(struct csio_hw *hw, struct list_head *cbfn_q)\n{\n\tstruct csio_mb *mbp;\n\tstruct csio_mbm *mbm = &hw->mbm;\n\tenum fw_retval rv;\n\n\twhile (!list_empty(cbfn_q)) {\n\t\tmbp = list_first_entry(cbfn_q, struct csio_mb, list);\n\t\tlist_del_init(&mbp->list);\n\n\t\trv = csio_mb_fw_retval(mbp);\n\t\tif ((rv != FW_SUCCESS) && (rv != FW_HOSTERROR))\n\t\t\tCSIO_INC_STATS(mbm, n_err);\n\t\telse if (rv != FW_HOSTERROR)\n\t\t\tCSIO_INC_STATS(mbm, n_rsp);\n\n\t\tif (mbp->mb_cbfn)\n\t\t\tmbp->mb_cbfn(hw, mbp);\n\t}\n}\n\nstatic void\ncsio_mb_portmod_changed(struct csio_hw *hw, uint8_t port_id)\n{\n\tstatic char *mod_str[] = {\n\t\tNULL, \"LR\", \"SR\", \"ER\", \"TWINAX\", \"active TWINAX\", \"LRM\"\n\t};\n\n\tstruct csio_pport *port = &hw->pport[port_id];\n\n\tif (port->mod_type == FW_PORT_MOD_TYPE_NONE)\n\t\tcsio_info(hw, \"Port:%d - port module unplugged\\n\", port_id);\n\telse if (port->mod_type < ARRAY_SIZE(mod_str))\n\t\tcsio_info(hw, \"Port:%d - %s port module inserted\\n\", port_id,\n\t\t\t  mod_str[port->mod_type]);\n\telse if (port->mod_type == FW_PORT_MOD_TYPE_NOTSUPPORTED)\n\t\tcsio_info(hw,\n\t\t\t  \"Port:%d - unsupported optical port module \"\n\t\t\t  \"inserted\\n\", port_id);\n\telse if (port->mod_type == FW_PORT_MOD_TYPE_UNKNOWN)\n\t\tcsio_info(hw,\n\t\t\t  \"Port:%d - unknown port module inserted, forcing \"\n\t\t\t  \"TWINAX\\n\", port_id);\n\telse if (port->mod_type == FW_PORT_MOD_TYPE_ERROR)\n\t\tcsio_info(hw, \"Port:%d - transceiver module error\\n\", port_id);\n\telse\n\t\tcsio_info(hw, \"Port:%d - unknown module type %d inserted\\n\",\n\t\t\t  port_id, port->mod_type);\n}\n\nint\ncsio_mb_fwevt_handler(struct csio_hw *hw, __be64 *cmd)\n{\n\tuint8_t opcode = *(uint8_t *)cmd;\n\tstruct fw_port_cmd *pcmd;\n\tuint8_t port_id;\n\tuint32_t link_status;\n\tuint16_t action;\n\tuint8_t mod_type;\n\tfw_port_cap32_t linkattr;\n\n\tif (opcode == FW_PORT_CMD) {\n\t\tpcmd = (struct fw_port_cmd *)cmd;\n\t\tport_id = FW_PORT_CMD_PORTID_G(\n\t\t\t\tntohl(pcmd->op_to_portid));\n\t\taction = FW_PORT_CMD_ACTION_G(\n\t\t\t\tntohl(pcmd->action_to_len16));\n\t\tif (action != FW_PORT_ACTION_GET_PORT_INFO &&\n\t\t    action != FW_PORT_ACTION_GET_PORT_INFO32) {\n\t\t\tcsio_err(hw, \"Unhandled FW_PORT_CMD action: %u\\n\",\n\t\t\t\taction);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (action == FW_PORT_ACTION_GET_PORT_INFO) {\n\t\t\tlink_status = ntohl(pcmd->u.info.lstatus_to_modtype);\n\t\t\tmod_type = FW_PORT_CMD_MODTYPE_G(link_status);\n\t\t\tlinkattr = lstatus_to_fwcap(link_status);\n\n\t\t\thw->pport[port_id].link_status =\n\t\t\t\tFW_PORT_CMD_LSTATUS_G(link_status);\n\t\t} else {\n\t\t\tlink_status =\n\t\t\t\tntohl(pcmd->u.info32.lstatus32_to_cbllen32);\n\t\t\tmod_type = FW_PORT_CMD_MODTYPE32_G(link_status);\n\t\t\tlinkattr = ntohl(pcmd->u.info32.linkattr32);\n\n\t\t\thw->pport[port_id].link_status =\n\t\t\t\tFW_PORT_CMD_LSTATUS32_G(link_status);\n\t\t}\n\n\t\thw->pport[port_id].link_speed = fwcap_to_fwspeed(linkattr);\n\n\t\tcsio_info(hw, \"Port:%x - LINK %s\\n\", port_id,\n\t\t\thw->pport[port_id].link_status ? \"UP\" : \"DOWN\");\n\n\t\tif (mod_type != hw->pport[port_id].mod_type) {\n\t\t\thw->pport[port_id].mod_type = mod_type;\n\t\t\tcsio_mb_portmod_changed(hw, port_id);\n\t\t}\n\t} else if (opcode == FW_DEBUG_CMD) {\n\t\tcsio_mb_dump_fw_dbg(hw, cmd);\n\t} else {\n\t\tcsio_dbg(hw, \"Gen MB can't handle op:0x%x on evtq.\\n\", opcode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint\ncsio_mb_isr_handler(struct csio_hw *hw)\n{\n\tstruct csio_mbm\t\t*mbm = &hw->mbm;\n\tstruct csio_mb\t\t*mbp =  mbm->mcurrent;\n\t__be64\t\t\t*cmd;\n\tuint32_t\t\tctl, cim_cause, pl_cause;\n\tint\t\t\ti;\n\tuint32_t\tctl_reg = PF_REG(hw->pfn, CIM_PF_MAILBOX_CTRL_A);\n\tuint32_t\tdata_reg = PF_REG(hw->pfn, CIM_PF_MAILBOX_DATA_A);\n\tint\t\t\tsize;\n\t__be64\t\t\thdr;\n\tstruct fw_cmd_hdr\t*fw_hdr;\n\n\tpl_cause = csio_rd_reg32(hw, MYPF_REG(PL_PF_INT_CAUSE_A));\n\tcim_cause = csio_rd_reg32(hw, MYPF_REG(CIM_PF_HOST_INT_CAUSE_A));\n\n\tif (!(pl_cause & PFCIM_F) || !(cim_cause & MBMSGRDYINT_F)) {\n\t\tCSIO_INC_STATS(hw, n_mbint_unexp);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcsio_wr_reg32(hw, MBMSGRDYINT_F, MYPF_REG(CIM_PF_HOST_INT_CAUSE_A));\n\tcsio_wr_reg32(hw, PFCIM_F, MYPF_REG(PL_PF_INT_CAUSE_A));\n\n\tctl = csio_rd_reg32(hw, ctl_reg);\n\n\tif (csio_mb_is_host_owner(MBOWNER_G(ctl))) {\n\n\t\tCSIO_DUMP_MB(hw, hw->pfn, data_reg);\n\n\t\tif (!(ctl & MBMSGVALID_F)) {\n\t\t\tcsio_warn(hw,\n\t\t\t\t  \"Stray mailbox interrupt recvd,\"\n\t\t\t\t  \" mailbox data not valid\\n\");\n\t\t\tcsio_wr_reg32(hw, 0, ctl_reg);\n\t\t\t \n\t\t\tcsio_rd_reg32(hw, ctl_reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\thdr = cpu_to_be64(csio_rd_reg64(hw, data_reg));\n\t\tfw_hdr = (struct fw_cmd_hdr *)&hdr;\n\n\t\tswitch (FW_CMD_OP_G(ntohl(fw_hdr->hi))) {\n\t\tcase FW_DEBUG_CMD:\n\t\t\tcsio_mb_debug_cmd_handler(hw);\n\t\t\treturn -EINVAL;\n#if 0\n\t\tcase FW_ERROR_CMD:\n\t\tcase FW_INITIALIZE_CMD:  \n#endif\n\t\t}\n\n\t\tCSIO_ASSERT(mbp != NULL);\n\n\t\tcmd = mbp->mb;\n\t\tsize = mbp->mb_size;\n\t\t \n\t\tfor (i = 0; i < size; i += 8)\n\t\t\t*cmd++ = cpu_to_be64(csio_rd_reg64\n\t\t\t\t\t\t  (hw, data_reg + i));\n\n\t\tcsio_wr_reg32(hw, 0, ctl_reg);\n\t\t \n\t\tcsio_rd_reg32(hw, ctl_reg);\n\n\t\tmbm->mcurrent = NULL;\n\n\t\t \n\t\tlist_add_tail(&mbp->list, &mbm->cbfn_q);\n\t\tCSIO_INC_STATS(mbm, n_cbfnq);\n\n\t\t \n\t\tif (csio_enqueue_evt(hw, CSIO_EVT_MBX, mbp, sizeof(mbp)))\n\t\t\tCSIO_INC_STATS(hw, n_evt_drop);\n\n\t\treturn 0;\n\n\t} else {\n\t\t \n\t\tcsio_dbg(hw, \"Host not owner, no mailbox interrupt\\n\");\n\t\tCSIO_INC_STATS(hw, n_int_stray);\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstruct csio_mb *\ncsio_mb_tmo_handler(struct csio_hw *hw)\n{\n\tstruct csio_mbm *mbm = &hw->mbm;\n\tstruct csio_mb *mbp =  mbm->mcurrent;\n\tstruct fw_cmd_hdr *fw_hdr;\n\n\t \n\tif (mbp == NULL) {\n\t\tCSIO_DB_ASSERT(0);\n\t\treturn NULL;\n\t}\n\n\tfw_hdr = (struct fw_cmd_hdr *)(mbp->mb);\n\n\tcsio_dbg(hw, \"Mailbox num:%x op:0x%x timed out\\n\", hw->pfn,\n\t\t    FW_CMD_OP_G(ntohl(fw_hdr->hi)));\n\n\tmbm->mcurrent = NULL;\n\tCSIO_INC_STATS(mbm, n_tmo);\n\tfw_hdr->lo = htonl(FW_CMD_RETVAL_V(FW_ETIMEDOUT));\n\n\treturn mbp;\n}\n\n \nvoid\ncsio_mb_cancel_all(struct csio_hw *hw, struct list_head *cbfn_q)\n{\n\tstruct csio_mb *mbp;\n\tstruct csio_mbm *mbm = &hw->mbm;\n\tstruct fw_cmd_hdr *hdr;\n\tstruct list_head *tmp;\n\n\tif (mbm->mcurrent) {\n\t\tmbp = mbm->mcurrent;\n\n\t\t \n\t\tdel_timer_sync(&mbm->timer);\n\n\t\t \n\t\tlist_add_tail(&mbp->list, cbfn_q);\n\t\tmbm->mcurrent = NULL;\n\t}\n\n\tif (!list_empty(&mbm->req_q)) {\n\t\tlist_splice_tail_init(&mbm->req_q, cbfn_q);\n\t\tmbm->stats.n_activeq = 0;\n\t}\n\n\tif (!list_empty(&mbm->cbfn_q)) {\n\t\tlist_splice_tail_init(&mbm->cbfn_q, cbfn_q);\n\t\tmbm->stats.n_cbfnq = 0;\n\t}\n\n\tif (list_empty(cbfn_q))\n\t\treturn;\n\n\tlist_for_each(tmp, cbfn_q) {\n\t\tmbp = (struct csio_mb *)tmp;\n\t\thdr = (struct fw_cmd_hdr *)(mbp->mb);\n\n\t\tcsio_dbg(hw, \"Cancelling pending mailbox num %x op:%x\\n\",\n\t\t\t    hw->pfn, FW_CMD_OP_G(ntohl(hdr->hi)));\n\n\t\tCSIO_INC_STATS(mbm, n_cancel);\n\t\thdr->lo = htonl(FW_CMD_RETVAL_V(FW_HOSTERROR));\n\t}\n}\n\n \nint\ncsio_mbm_init(struct csio_mbm *mbm, struct csio_hw *hw,\n\t      void (*timer_fn)(struct timer_list *))\n{\n\tmbm->hw = hw;\n\ttimer_setup(&mbm->timer, timer_fn, 0);\n\n\tINIT_LIST_HEAD(&mbm->req_q);\n\tINIT_LIST_HEAD(&mbm->cbfn_q);\n\tcsio_set_mb_intr_idx(mbm, -1);\n\n\treturn 0;\n}\n\n \nvoid\ncsio_mbm_exit(struct csio_mbm *mbm)\n{\n\tdel_timer_sync(&mbm->timer);\n\n\tCSIO_DB_ASSERT(mbm->mcurrent == NULL);\n\tCSIO_DB_ASSERT(list_empty(&mbm->req_q));\n\tCSIO_DB_ASSERT(list_empty(&mbm->cbfn_q));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}