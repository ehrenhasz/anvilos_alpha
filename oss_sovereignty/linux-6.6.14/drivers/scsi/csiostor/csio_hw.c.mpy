{
  "module_name": "csio_hw.c",
  "hash_id": "24a9c9bbc6367d77cd3f545f19419d74eaed7d74f5695dcb4e5c6daa4224826a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/csiostor/csio_hw.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/pci_regs.h>\n#include <linux/firmware.h>\n#include <linux/stddef.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/compiler.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n\n#include \"csio_hw.h\"\n#include \"csio_lnode.h\"\n#include \"csio_rnode.h\"\n\nint csio_dbg_level = 0xFEFF;\nunsigned int csio_port_mask = 0xf;\n\n \nstatic uint32_t csio_evtq_sz = CSIO_EVTQ_SIZE;\n\n \nint csio_msi = 2;\n\n \nstatic int dev_num;\n\n \nstatic const struct csio_adap_desc csio_t5_fcoe_adapters[] = {\n\t{\"T580-Dbg 10G\", \"Chelsio T580-Dbg 10G [FCoE]\"},\n\t{\"T520-CR 10G\", \"Chelsio T520-CR 10G [FCoE]\"},\n\t{\"T522-CR 10G/1G\", \"Chelsio T522-CR 10G/1G [FCoE]\"},\n\t{\"T540-CR 10G\", \"Chelsio T540-CR 10G [FCoE]\"},\n\t{\"T520-BCH 10G\", \"Chelsio T520-BCH 10G [FCoE]\"},\n\t{\"T540-BCH 10G\", \"Chelsio T540-BCH 10G [FCoE]\"},\n\t{\"T540-CH 10G\", \"Chelsio T540-CH 10G [FCoE]\"},\n\t{\"T520-SO 10G\", \"Chelsio T520-SO 10G [FCoE]\"},\n\t{\"T520-CX4 10G\", \"Chelsio T520-CX4 10G [FCoE]\"},\n\t{\"T520-BT 10G\", \"Chelsio T520-BT 10G [FCoE]\"},\n\t{\"T504-BT 1G\", \"Chelsio T504-BT 1G [FCoE]\"},\n\t{\"B520-SR 10G\", \"Chelsio B520-SR 10G [FCoE]\"},\n\t{\"B504-BT 1G\", \"Chelsio B504-BT 1G [FCoE]\"},\n\t{\"T580-CR 10G\", \"Chelsio T580-CR 10G [FCoE]\"},\n\t{\"T540-LP-CR 10G\", \"Chelsio T540-LP-CR 10G [FCoE]\"},\n\t{\"AMSTERDAM 10G\", \"Chelsio AMSTERDAM 10G [FCoE]\"},\n\t{\"T580-LP-CR 40G\", \"Chelsio T580-LP-CR 40G [FCoE]\"},\n\t{\"T520-LL-CR 10G\", \"Chelsio T520-LL-CR 10G [FCoE]\"},\n\t{\"T560-CR 40G\", \"Chelsio T560-CR 40G [FCoE]\"},\n\t{\"T580-CR 40G\", \"Chelsio T580-CR 40G [FCoE]\"},\n\t{\"T580-SO 40G\", \"Chelsio T580-SO 40G [FCoE]\"},\n\t{\"T502-BT 1G\", \"Chelsio T502-BT 1G [FCoE]\"}\n};\n\nstatic void csio_mgmtm_cleanup(struct csio_mgmtm *);\nstatic void csio_hw_mbm_cleanup(struct csio_hw *);\n\n \nstatic void csio_hws_uninit(struct csio_hw *, enum csio_hw_ev);\nstatic void csio_hws_configuring(struct csio_hw *, enum csio_hw_ev);\nstatic void csio_hws_initializing(struct csio_hw *, enum csio_hw_ev);\nstatic void csio_hws_ready(struct csio_hw *, enum csio_hw_ev);\nstatic void csio_hws_quiescing(struct csio_hw *, enum csio_hw_ev);\nstatic void csio_hws_quiesced(struct csio_hw *, enum csio_hw_ev);\nstatic void csio_hws_resetting(struct csio_hw *, enum csio_hw_ev);\nstatic void csio_hws_removing(struct csio_hw *, enum csio_hw_ev);\nstatic void csio_hws_pcierr(struct csio_hw *, enum csio_hw_ev);\n\nstatic void csio_hw_initialize(struct csio_hw *hw);\nstatic void csio_evtq_stop(struct csio_hw *hw);\nstatic void csio_evtq_start(struct csio_hw *hw);\n\nint csio_is_hw_ready(struct csio_hw *hw)\n{\n\treturn csio_match_state(hw, csio_hws_ready);\n}\n\nint csio_is_hw_removing(struct csio_hw *hw)\n{\n\treturn csio_match_state(hw, csio_hws_removing);\n}\n\n\n \nint\ncsio_hw_wait_op_done_val(struct csio_hw *hw, int reg, uint32_t mask,\n\t\t\t int polarity, int attempts, int delay, uint32_t *valp)\n{\n\tuint32_t val;\n\twhile (1) {\n\t\tval = csio_rd_reg32(hw, reg);\n\n\t\tif (!!(val & mask) == polarity) {\n\t\t\tif (valp)\n\t\t\t\t*valp = val;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (--attempts == 0)\n\t\t\treturn -EAGAIN;\n\t\tif (delay)\n\t\t\tudelay(delay);\n\t}\n}\n\n \nvoid\ncsio_hw_tp_wr_bits_indirect(struct csio_hw *hw, unsigned int addr,\n\t\t\tunsigned int mask, unsigned int val)\n{\n\tcsio_wr_reg32(hw, addr, TP_PIO_ADDR_A);\n\tval |= csio_rd_reg32(hw, TP_PIO_DATA_A) & ~mask;\n\tcsio_wr_reg32(hw, val, TP_PIO_DATA_A);\n}\n\nvoid\ncsio_set_reg_field(struct csio_hw *hw, uint32_t reg, uint32_t mask,\n\t\t   uint32_t value)\n{\n\tuint32_t val = csio_rd_reg32(hw, reg) & ~mask;\n\n\tcsio_wr_reg32(hw, val | value, reg);\n\t \n\tcsio_rd_reg32(hw, reg);\n\n}\n\nstatic int\ncsio_memory_write(struct csio_hw *hw, int mtype, u32 addr, u32 len, u32 *buf)\n{\n\treturn hw->chip_ops->chip_memory_rw(hw, MEMWIN_CSIOSTOR, mtype,\n\t\t\t\t\t    addr, len, buf, 0);\n}\n\n \n#define EEPROM_MAX_RD_POLL\t40\n#define EEPROM_MAX_WR_POLL\t6\n#define EEPROM_STAT_ADDR\t0x7bfc\n#define VPD_BASE\t\t0x400\n#define VPD_BASE_OLD\t\t0\n#define VPD_LEN\t\t\t1024\n#define VPD_INFO_FLD_HDR_SIZE\t3\n\n \nstatic int\ncsio_hw_seeprom_read(struct csio_hw *hw, uint32_t addr, uint32_t *data)\n{\n\tuint16_t val = 0;\n\tint attempts = EEPROM_MAX_RD_POLL;\n\tuint32_t base = hw->params.pci.vpd_cap_addr;\n\n\tif (addr >= EEPROMVSIZE || (addr & 3))\n\t\treturn -EINVAL;\n\n\tpci_write_config_word(hw->pdev, base + PCI_VPD_ADDR, (uint16_t)addr);\n\n\tdo {\n\t\tudelay(10);\n\t\tpci_read_config_word(hw->pdev, base + PCI_VPD_ADDR, &val);\n\t} while (!(val & PCI_VPD_ADDR_F) && --attempts);\n\n\tif (!(val & PCI_VPD_ADDR_F)) {\n\t\tcsio_err(hw, \"reading EEPROM address 0x%x failed\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\tpci_read_config_dword(hw->pdev, base + PCI_VPD_DATA, data);\n\t*data = le32_to_cpu(*(__le32 *)data);\n\n\treturn 0;\n}\n\n \nstruct t4_vpd_hdr {\n\tu8  id_tag;\n\tu8  id_len[2];\n\tu8  id_data[ID_LEN];\n\tu8  vpdr_tag;\n\tu8  vpdr_len[2];\n};\n\n \nstatic int\ncsio_hw_get_vpd_keyword_val(const struct t4_vpd_hdr *v, const char *kw)\n{\n\tint32_t i;\n\tint32_t offset , len;\n\tconst uint8_t *buf = &v->id_tag;\n\tconst uint8_t *vpdr_len = &v->vpdr_tag;\n\toffset = sizeof(struct t4_vpd_hdr);\n\tlen =  (uint16_t)vpdr_len[1] + ((uint16_t)vpdr_len[2] << 8);\n\n\tif (len + sizeof(struct t4_vpd_hdr) > VPD_LEN)\n\t\treturn -EINVAL;\n\n\tfor (i = offset; (i + VPD_INFO_FLD_HDR_SIZE) <= (offset + len);) {\n\t\tif (memcmp(buf + i , kw, 2) == 0) {\n\t\t\ti += VPD_INFO_FLD_HDR_SIZE;\n\t\t\treturn i;\n\t\t}\n\n\t\ti += VPD_INFO_FLD_HDR_SIZE + buf[i+2];\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\ncsio_pci_capability(struct pci_dev *pdev, int cap, int *pos)\n{\n\t*pos = pci_find_capability(pdev, cap);\n\tif (*pos)\n\t\treturn 0;\n\n\treturn -1;\n}\n\n \nstatic int\ncsio_hw_get_vpd_params(struct csio_hw *hw, struct csio_vpd *p)\n{\n\tint i, ret, ec, sn, addr;\n\tuint8_t *vpd, csum;\n\tconst struct t4_vpd_hdr *v;\n\t \n\tchar __always_unused *s;\n\n\tif (csio_is_valid_vpd(hw))\n\t\treturn 0;\n\n\tret = csio_pci_capability(hw->pdev, PCI_CAP_ID_VPD,\n\t\t\t\t  &hw->params.pci.vpd_cap_addr);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tvpd = kzalloc(VPD_LEN, GFP_ATOMIC);\n\tif (vpd == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tret = csio_hw_seeprom_read(hw, VPD_BASE, (uint32_t *)(vpd));\n\taddr = *vpd == 0x82 ? VPD_BASE : VPD_BASE_OLD;\n\n\tfor (i = 0; i < VPD_LEN; i += 4) {\n\t\tret = csio_hw_seeprom_read(hw, addr + i, (uint32_t *)(vpd + i));\n\t\tif (ret) {\n\t\t\tkfree(vpd);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\thw->flags &= (~CSIO_HWF_VPD_VALID);\n\n\tv = (const struct t4_vpd_hdr *)vpd;\n\n#define FIND_VPD_KW(var, name) do { \\\n\tvar = csio_hw_get_vpd_keyword_val(v, name); \\\n\tif (var < 0) { \\\n\t\tcsio_err(hw, \"missing VPD keyword \" name \"\\n\"); \\\n\t\tkfree(vpd); \\\n\t\treturn -EINVAL; \\\n\t} \\\n} while (0)\n\n\tFIND_VPD_KW(i, \"RV\");\n\tfor (csum = 0; i >= 0; i--)\n\t\tcsum += vpd[i];\n\n\tif (csum) {\n\t\tcsio_err(hw, \"corrupted VPD EEPROM, actual csum %u\\n\", csum);\n\t\tkfree(vpd);\n\t\treturn -EINVAL;\n\t}\n\tFIND_VPD_KW(ec, \"EC\");\n\tFIND_VPD_KW(sn, \"SN\");\n#undef FIND_VPD_KW\n\n\tmemcpy(p->id, v->id_data, ID_LEN);\n\ts = strstrip(p->id);\n\tmemcpy(p->ec, vpd + ec, EC_LEN);\n\ts = strstrip(p->ec);\n\ti = vpd[sn - VPD_INFO_FLD_HDR_SIZE + 2];\n\tmemcpy(p->sn, vpd + sn, min(i, SERNUM_LEN));\n\ts = strstrip(p->sn);\n\n\tcsio_valid_vpd_copied(hw);\n\n\tkfree(vpd);\n\treturn 0;\n}\n\n \nstatic int\ncsio_hw_sf1_read(struct csio_hw *hw, uint32_t byte_cnt, int32_t cont,\n\t\t int32_t lock, uint32_t *valp)\n{\n\tint ret;\n\n\tif (!byte_cnt || byte_cnt > 4)\n\t\treturn -EINVAL;\n\tif (csio_rd_reg32(hw, SF_OP_A) & SF_BUSY_F)\n\t\treturn -EBUSY;\n\n\tcsio_wr_reg32(hw,  SF_LOCK_V(lock) | SF_CONT_V(cont) |\n\t\t      BYTECNT_V(byte_cnt - 1), SF_OP_A);\n\tret = csio_hw_wait_op_done_val(hw, SF_OP_A, SF_BUSY_F, 0, SF_ATTEMPTS,\n\t\t\t\t       10, NULL);\n\tif (!ret)\n\t\t*valp = csio_rd_reg32(hw, SF_DATA_A);\n\treturn ret;\n}\n\n \nstatic int\ncsio_hw_sf1_write(struct csio_hw *hw, uint32_t byte_cnt, uint32_t cont,\n\t\t  int32_t lock, uint32_t val)\n{\n\tif (!byte_cnt || byte_cnt > 4)\n\t\treturn -EINVAL;\n\tif (csio_rd_reg32(hw, SF_OP_A) & SF_BUSY_F)\n\t\treturn -EBUSY;\n\n\tcsio_wr_reg32(hw, val, SF_DATA_A);\n\tcsio_wr_reg32(hw, SF_CONT_V(cont) | BYTECNT_V(byte_cnt - 1) |\n\t\t      OP_V(1) | SF_LOCK_V(lock), SF_OP_A);\n\n\treturn csio_hw_wait_op_done_val(hw, SF_OP_A, SF_BUSY_F, 0, SF_ATTEMPTS,\n\t\t\t\t\t10, NULL);\n}\n\n \nstatic int\ncsio_hw_flash_wait_op(struct csio_hw *hw, int32_t attempts, int32_t delay)\n{\n\tint ret;\n\tuint32_t status;\n\n\twhile (1) {\n\t\tret = csio_hw_sf1_write(hw, 1, 1, 1, SF_RD_STATUS);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\tret = csio_hw_sf1_read(hw, 1, 0, 1, &status);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\tif (!(status & 1))\n\t\t\treturn 0;\n\t\tif (--attempts == 0)\n\t\t\treturn -EAGAIN;\n\t\tif (delay)\n\t\t\tmsleep(delay);\n\t}\n}\n\n \nstatic int\ncsio_hw_read_flash(struct csio_hw *hw, uint32_t addr, uint32_t nwords,\n\t\t  uint32_t *data, int32_t byte_oriented)\n{\n\tint ret;\n\n\tif (addr + nwords * sizeof(uint32_t) > hw->params.sf_size || (addr & 3))\n\t\treturn -EINVAL;\n\n\taddr = swab32(addr) | SF_RD_DATA_FAST;\n\n\tret = csio_hw_sf1_write(hw, 4, 1, 0, addr);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = csio_hw_sf1_read(hw, 1, 1, 0, data);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tfor ( ; nwords; nwords--, data++) {\n\t\tret = csio_hw_sf1_read(hw, 4, nwords > 1, nwords == 1, data);\n\t\tif (nwords == 1)\n\t\t\tcsio_wr_reg32(hw, 0, SF_OP_A);     \n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (byte_oriented)\n\t\t\t*data = (__force __u32) htonl(*data);\n\t}\n\treturn 0;\n}\n\n \nstatic int\ncsio_hw_write_flash(struct csio_hw *hw, uint32_t addr,\n\t\t    uint32_t n, const uint8_t *data)\n{\n\tint ret = -EINVAL;\n\tuint32_t buf[64];\n\tuint32_t i, c, left, val, offset = addr & 0xff;\n\n\tif (addr >= hw->params.sf_size || offset + n > SF_PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tval = swab32(addr) | SF_PROG_PAGE;\n\n\tret = csio_hw_sf1_write(hw, 1, 0, 1, SF_WR_ENABLE);\n\tif (ret != 0)\n\t\tgoto unlock;\n\n\tret = csio_hw_sf1_write(hw, 4, 1, 1, val);\n\tif (ret != 0)\n\t\tgoto unlock;\n\n\tfor (left = n; left; left -= c) {\n\t\tc = min(left, 4U);\n\t\tfor (val = 0, i = 0; i < c; ++i)\n\t\t\tval = (val << 8) + *data++;\n\n\t\tret = csio_hw_sf1_write(hw, c, c != left, 1, val);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\tret = csio_hw_flash_wait_op(hw, 8, 1);\n\tif (ret)\n\t\tgoto unlock;\n\n\tcsio_wr_reg32(hw, 0, SF_OP_A);     \n\n\t \n\tret = csio_hw_read_flash(hw, addr & ~0xff, ARRAY_SIZE(buf), buf, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (memcmp(data - n, (uint8_t *)buf + offset, n)) {\n\t\tcsio_err(hw,\n\t\t\t \"failed to correctly write the flash page at %#x\\n\",\n\t\t\t addr);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\nunlock:\n\tcsio_wr_reg32(hw, 0, SF_OP_A);     \n\treturn ret;\n}\n\n \nstatic int\ncsio_hw_flash_erase_sectors(struct csio_hw *hw, int32_t start, int32_t end)\n{\n\tint ret = 0;\n\n\twhile (start <= end) {\n\n\t\tret = csio_hw_sf1_write(hw, 1, 0, 1, SF_WR_ENABLE);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\n\t\tret = csio_hw_sf1_write(hw, 4, 0, 1,\n\t\t\t\t\tSF_ERASE_SECTOR | (start << 8));\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\n\t\tret = csio_hw_flash_wait_op(hw, 14, 500);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\n\t\tstart++;\n\t}\nout:\n\tif (ret)\n\t\tcsio_err(hw, \"erase of flash sector %d failed, error %d\\n\",\n\t\t\t start, ret);\n\tcsio_wr_reg32(hw, 0, SF_OP_A);     \n\treturn 0;\n}\n\nstatic void\ncsio_hw_print_fw_version(struct csio_hw *hw, char *str)\n{\n\tcsio_info(hw, \"%s: %u.%u.%u.%u\\n\", str,\n\t\t    FW_HDR_FW_VER_MAJOR_G(hw->fwrev),\n\t\t    FW_HDR_FW_VER_MINOR_G(hw->fwrev),\n\t\t    FW_HDR_FW_VER_MICRO_G(hw->fwrev),\n\t\t    FW_HDR_FW_VER_BUILD_G(hw->fwrev));\n}\n\n \nstatic int\ncsio_hw_get_fw_version(struct csio_hw *hw, uint32_t *vers)\n{\n\treturn csio_hw_read_flash(hw, FLASH_FW_START +\n\t\t\t\t  offsetof(struct fw_hdr, fw_ver), 1,\n\t\t\t\t  vers, 0);\n}\n\n \nstatic int\ncsio_hw_get_tp_version(struct csio_hw *hw, u32 *vers)\n{\n\treturn csio_hw_read_flash(hw, FLASH_FW_START +\n\t\t\toffsetof(struct fw_hdr, tp_microcode_ver), 1,\n\t\t\tvers, 0);\n}\n\n \nstatic int\ncsio_hw_fw_dload(struct csio_hw *hw, uint8_t *fw_data, uint32_t size)\n{\n\tuint32_t csum;\n\tint32_t addr;\n\tint ret;\n\tuint32_t i;\n\tuint8_t first_page[SF_PAGE_SIZE];\n\tconst __be32 *p = (const __be32 *)fw_data;\n\tstruct fw_hdr *hdr = (struct fw_hdr *)fw_data;\n\tuint32_t sf_sec_size;\n\n\tif ((!hw->params.sf_size) || (!hw->params.sf_nsec)) {\n\t\tcsio_err(hw, \"Serial Flash data invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!size) {\n\t\tcsio_err(hw, \"FW image has no data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (size & 511) {\n\t\tcsio_err(hw, \"FW image size not multiple of 512 bytes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ntohs(hdr->len512) * 512 != size) {\n\t\tcsio_err(hw, \"FW image size differs from size in FW header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (size > FLASH_FW_MAX_SIZE) {\n\t\tcsio_err(hw, \"FW image too large, max is %u bytes\\n\",\n\t\t\t    FLASH_FW_MAX_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (csum = 0, i = 0; i < size / sizeof(csum); i++)\n\t\tcsum += ntohl(p[i]);\n\n\tif (csum != 0xffffffff) {\n\t\tcsio_err(hw, \"corrupted firmware image, checksum %#x\\n\", csum);\n\t\treturn -EINVAL;\n\t}\n\n\tsf_sec_size = hw->params.sf_size / hw->params.sf_nsec;\n\ti = DIV_ROUND_UP(size, sf_sec_size);         \n\n\tcsio_dbg(hw, \"Erasing sectors... start:%d end:%d\\n\",\n\t\t\t  FLASH_FW_START_SEC, FLASH_FW_START_SEC + i - 1);\n\n\tret = csio_hw_flash_erase_sectors(hw, FLASH_FW_START_SEC,\n\t\t\t\t\t  FLASH_FW_START_SEC + i - 1);\n\tif (ret) {\n\t\tcsio_err(hw, \"Flash Erase failed\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tmemcpy(first_page, fw_data, SF_PAGE_SIZE);\n\t((struct fw_hdr *)first_page)->fw_ver = htonl(0xffffffff);\n\tret = csio_hw_write_flash(hw, FLASH_FW_START, SF_PAGE_SIZE, first_page);\n\tif (ret)\n\t\tgoto out;\n\n\tcsio_dbg(hw, \"Writing Flash .. start:%d end:%d\\n\",\n\t\t    FW_IMG_START, FW_IMG_START + size);\n\n\taddr = FLASH_FW_START;\n\tfor (size -= SF_PAGE_SIZE; size; size -= SF_PAGE_SIZE) {\n\t\taddr += SF_PAGE_SIZE;\n\t\tfw_data += SF_PAGE_SIZE;\n\t\tret = csio_hw_write_flash(hw, addr, SF_PAGE_SIZE, fw_data);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = csio_hw_write_flash(hw,\n\t\t\t\t  FLASH_FW_START +\n\t\t\t\t\toffsetof(struct fw_hdr, fw_ver),\n\t\t\t\t  sizeof(hdr->fw_ver),\n\t\t\t\t  (const uint8_t *)&hdr->fw_ver);\n\nout:\n\tif (ret)\n\t\tcsio_err(hw, \"firmware download failed, error %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int\ncsio_hw_get_flash_params(struct csio_hw *hw)\n{\n\t \n\tstatic struct flash_desc {\n\t\tu32 vendor_and_model_id;\n\t\tu32 size_mb;\n\t} supported_flash[] = {\n\t\t{ 0x150201, 4 << 20 },        \n\t};\n\n\tu32 part, manufacturer;\n\tu32 density, size = 0;\n\tu32 flashid = 0;\n\tint ret;\n\n\tret = csio_hw_sf1_write(hw, 1, 1, 0, SF_RD_ID);\n\tif (!ret)\n\t\tret = csio_hw_sf1_read(hw, 3, 0, 1, &flashid);\n\tcsio_wr_reg32(hw, 0, SF_OP_A);     \n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (part = 0; part < ARRAY_SIZE(supported_flash); part++)\n\t\tif (supported_flash[part].vendor_and_model_id == flashid) {\n\t\t\thw->params.sf_size = supported_flash[part].size_mb;\n\t\t\thw->params.sf_nsec =\n\t\t\t\thw->params.sf_size / SF_SEC_SIZE;\n\t\t\tgoto found;\n\t\t}\n\n\t \n\tmanufacturer = flashid & 0xff;\n\tswitch (manufacturer) {\n\tcase 0x20: {  \n\t\t \n\t\tdensity = (flashid >> 16) & 0xff;\n\t\tswitch (density) {\n\t\tcase 0x14 ... 0x19:  \n\t\t\tsize = 1 << density;\n\t\t\tbreak;\n\t\tcase 0x20:  \n\t\t\tsize = 1 << 26;\n\t\t\tbreak;\n\t\tcase 0x21:  \n\t\t\tsize = 1 << 27;\n\t\t\tbreak;\n\t\tcase 0x22:  \n\t\t\tsize = 1 << 28;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 0x9d: {  \n\t\t \n\t\tdensity = (flashid >> 16) & 0xff;\n\t\tswitch (density) {\n\t\tcase 0x16:  \n\t\t\tsize = 1 << 25;\n\t\t\tbreak;\n\t\tcase 0x17:  \n\t\t\tsize = 1 << 26;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 0xc2:  \n\tcase 0xef:   {\n\t\t \n\t\tdensity = (flashid >> 16) & 0xff;\n\t\tswitch (density) {\n\t\tcase 0x17:  \n\t\tcase 0x18:  \n\t\t\tsize = 1 << density;\n\t\t}\n\t}\n\t}\n\n\t \n\tif (size == 0) {\n\t\tcsio_warn(hw, \"Unknown Flash Part, ID = %#x, assuming 4MB\\n\",\n\t\t\t  flashid);\n\t\tsize = 1 << 22;\n\t}\n\n\t \n\thw->params.sf_size = size;\n\thw->params.sf_nsec = size / SF_SEC_SIZE;\n\nfound:\n\tif (hw->params.sf_size < FLASH_MIN_SIZE)\n\t\tcsio_warn(hw, \"WARNING: Flash Part ID %#x, size %#x < %#x\\n\",\n\t\t\t  flashid, hw->params.sf_size, FLASH_MIN_SIZE);\n\treturn 0;\n}\n\n \n \n \n\nstatic int\ncsio_hw_dev_ready(struct csio_hw *hw)\n{\n\tuint32_t reg;\n\tint cnt = 6;\n\tint src_pf;\n\n\twhile (((reg = csio_rd_reg32(hw, PL_WHOAMI_A)) == 0xFFFFFFFF) &&\n\t       (--cnt != 0))\n\t\tmdelay(100);\n\n\tif (csio_is_t5(hw->pdev->device & CSIO_HW_CHIP_MASK))\n\t\tsrc_pf = SOURCEPF_G(reg);\n\telse\n\t\tsrc_pf = T6_SOURCEPF_G(reg);\n\n\tif ((cnt == 0) && (((int32_t)(src_pf) < 0) ||\n\t\t\t   (src_pf >= CSIO_MAX_PFN))) {\n\t\tcsio_err(hw, \"PL_WHOAMI returned 0x%x, cnt:%d\\n\", reg, cnt);\n\t\treturn -EIO;\n\t}\n\n\thw->pfn = src_pf;\n\n\treturn 0;\n}\n\n \nstatic int\ncsio_do_hello(struct csio_hw *hw, enum csio_dev_state *state)\n{\n\tstruct csio_mb\t*mbp;\n\tint\trv = 0;\n\tenum fw_retval retval;\n\tuint8_t mpfn;\n\tchar state_str[16];\n\tint retries = FW_CMD_HELLO_RETRIES;\n\n\tmemset(state_str, 0, sizeof(state_str));\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\trv = -ENOMEM;\n\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\tgoto out;\n\t}\n\nretry:\n\tcsio_mb_hello(hw, mbp, CSIO_MB_DEFAULT_TMO, hw->pfn,\n\t\t      hw->pfn, CSIO_MASTER_MAY, NULL);\n\n\trv = csio_mb_issue(hw, mbp);\n\tif (rv) {\n\t\tcsio_err(hw, \"failed to issue HELLO cmd. ret:%d.\\n\", rv);\n\t\tgoto out_free_mb;\n\t}\n\n\tcsio_mb_process_hello_rsp(hw, mbp, &retval, state, &mpfn);\n\tif (retval != FW_SUCCESS) {\n\t\tcsio_err(hw, \"HELLO cmd failed with ret: %d\\n\", retval);\n\t\trv = -EINVAL;\n\t\tgoto out_free_mb;\n\t}\n\n\t \n\tif (hw->pfn == mpfn) {\n\t\thw->flags |= CSIO_HWF_MASTER;\n\t} else if (*state == CSIO_DEV_STATE_UNINIT) {\n\t\t \n\n\t\tint waiting = FW_CMD_HELLO_TIMEOUT;\n\n\t\t \n\t\tfor (;;) {\n\t\t\tuint32_t pcie_fw;\n\n\t\t\tspin_unlock_irq(&hw->lock);\n\t\t\tmsleep(50);\n\t\t\tspin_lock_irq(&hw->lock);\n\t\t\twaiting -= 50;\n\n\t\t\t \n\t\t\tpcie_fw = csio_rd_reg32(hw, PCIE_FW_A);\n\t\t\tif (!(pcie_fw & (PCIE_FW_ERR_F|PCIE_FW_INIT_F))) {\n\t\t\t\tif (waiting <= 0) {\n\t\t\t\t\tif (retries-- > 0)\n\t\t\t\t\t\tgoto retry;\n\n\t\t\t\t\trv = -ETIMEDOUT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (state) {\n\t\t\t\tif (pcie_fw & PCIE_FW_ERR_F) {\n\t\t\t\t\t*state = CSIO_DEV_STATE_ERR;\n\t\t\t\t\trv = -ETIMEDOUT;\n\t\t\t\t} else if (pcie_fw & PCIE_FW_INIT_F)\n\t\t\t\t\t*state = CSIO_DEV_STATE_INIT;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (mpfn == PCIE_FW_MASTER_M &&\n\t\t\t    (pcie_fw & PCIE_FW_MASTER_VLD_F))\n\t\t\t\tmpfn = PCIE_FW_MASTER_G(pcie_fw);\n\t\t\tbreak;\n\t\t}\n\t\thw->flags &= ~CSIO_HWF_MASTER;\n\t}\n\n\tswitch (*state) {\n\tcase CSIO_DEV_STATE_UNINIT:\n\t\tstrcpy(state_str, \"Initializing\");\n\t\tbreak;\n\tcase CSIO_DEV_STATE_INIT:\n\t\tstrcpy(state_str, \"Initialized\");\n\t\tbreak;\n\tcase CSIO_DEV_STATE_ERR:\n\t\tstrcpy(state_str, \"Error\");\n\t\tbreak;\n\tdefault:\n\t\tstrcpy(state_str, \"Unknown\");\n\t\tbreak;\n\t}\n\n\tif (hw->pfn == mpfn)\n\t\tcsio_info(hw, \"PF: %d, Coming up as MASTER, HW state: %s\\n\",\n\t\t\thw->pfn, state_str);\n\telse\n\t\tcsio_info(hw,\n\t\t    \"PF: %d, Coming up as SLAVE, Master PF: %d, HW state: %s\\n\",\n\t\t    hw->pfn, mpfn, state_str);\n\nout_free_mb:\n\tmempool_free(mbp, hw->mb_mempool);\nout:\n\treturn rv;\n}\n\n \nstatic int\ncsio_do_bye(struct csio_hw *hw)\n{\n\tstruct csio_mb\t*mbp;\n\tenum fw_retval retval;\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\treturn -ENOMEM;\n\t}\n\n\tcsio_mb_bye(hw, mbp, CSIO_MB_DEFAULT_TMO, NULL);\n\n\tif (csio_mb_issue(hw, mbp)) {\n\t\tcsio_err(hw, \"Issue of BYE command failed\\n\");\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\tretval = csio_mb_fw_retval(mbp);\n\tif (retval != FW_SUCCESS) {\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\tmempool_free(mbp, hw->mb_mempool);\n\n\treturn 0;\n}\n\n \nstatic int\ncsio_do_reset(struct csio_hw *hw, bool fw_rst)\n{\n\tstruct csio_mb\t*mbp;\n\tenum fw_retval retval;\n\n\tif (!fw_rst) {\n\t\t \n\t\tcsio_wr_reg32(hw, PIORSTMODE_F | PIORST_F, PL_RST_A);\n\t\tmdelay(2000);\n\t\treturn 0;\n\t}\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\treturn -ENOMEM;\n\t}\n\n\tcsio_mb_reset(hw, mbp, CSIO_MB_DEFAULT_TMO,\n\t\t      PIORSTMODE_F | PIORST_F, 0, NULL);\n\n\tif (csio_mb_issue(hw, mbp)) {\n\t\tcsio_err(hw, \"Issue of RESET command failed.n\");\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\tretval = csio_mb_fw_retval(mbp);\n\tif (retval != FW_SUCCESS) {\n\t\tcsio_err(hw, \"RESET cmd failed with ret:0x%x.\\n\", retval);\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\tmempool_free(mbp, hw->mb_mempool);\n\n\treturn 0;\n}\n\nstatic int\ncsio_hw_validate_caps(struct csio_hw *hw, struct csio_mb *mbp)\n{\n\tstruct fw_caps_config_cmd *rsp = (struct fw_caps_config_cmd *)mbp->mb;\n\tuint16_t caps;\n\n\tcaps = ntohs(rsp->fcoecaps);\n\n\tif (!(caps & FW_CAPS_CONFIG_FCOE_INITIATOR)) {\n\t\tcsio_err(hw, \"No FCoE Initiator capability in the firmware.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(caps & FW_CAPS_CONFIG_FCOE_CTRL_OFLD)) {\n\t\tcsio_err(hw, \"No FCoE Control Offload capability\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\ncsio_hw_fw_halt(struct csio_hw *hw, uint32_t mbox, int32_t force)\n{\n\tenum fw_retval retval = 0;\n\n\t \n\tif (mbox <= PCIE_FW_MASTER_M) {\n\t\tstruct csio_mb\t*mbp;\n\n\t\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\t\tif (!mbp) {\n\t\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcsio_mb_reset(hw, mbp, CSIO_MB_DEFAULT_TMO,\n\t\t\t      PIORSTMODE_F | PIORST_F, FW_RESET_CMD_HALT_F,\n\t\t\t      NULL);\n\n\t\tif (csio_mb_issue(hw, mbp)) {\n\t\t\tcsio_err(hw, \"Issue of RESET command failed!\\n\");\n\t\t\tmempool_free(mbp, hw->mb_mempool);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tretval = csio_mb_fw_retval(mbp);\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t}\n\n\t \n\tif (retval == 0 || force) {\n\t\tcsio_set_reg_field(hw, CIM_BOOT_CFG_A, UPCRST_F, UPCRST_F);\n\t\tcsio_set_reg_field(hw, PCIE_FW_A, PCIE_FW_HALT_F,\n\t\t\t\t   PCIE_FW_HALT_F);\n\t}\n\n\t \n\treturn retval ? -EINVAL : 0;\n}\n\n \nstatic int\ncsio_hw_fw_restart(struct csio_hw *hw, uint32_t mbox, int32_t reset)\n{\n\tif (reset) {\n\t\t \n\t\tcsio_set_reg_field(hw, PCIE_FW_A, PCIE_FW_HALT_F, 0);\n\n\t\t \n\t\tif (mbox <= PCIE_FW_MASTER_M) {\n\t\t\tcsio_set_reg_field(hw, CIM_BOOT_CFG_A, UPCRST_F, 0);\n\t\t\tmsleep(100);\n\t\t\tif (csio_do_reset(hw, true) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tcsio_wr_reg32(hw, PIORSTMODE_F | PIORST_F, PL_RST_A);\n\t\tmsleep(2000);\n\t} else {\n\t\tint ms;\n\n\t\tcsio_set_reg_field(hw, CIM_BOOT_CFG_A, UPCRST_F, 0);\n\t\tfor (ms = 0; ms < FW_CMD_MAX_TIMEOUT; ) {\n\t\t\tif (!(csio_rd_reg32(hw, PCIE_FW_A) & PCIE_FW_HALT_F))\n\t\t\t\treturn 0;\n\t\t\tmsleep(100);\n\t\t\tms += 100;\n\t\t}\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\n}\n\n \nstatic int\ncsio_hw_fw_upgrade(struct csio_hw *hw, uint32_t mbox,\n\t\t  const u8 *fw_data, uint32_t size, int32_t force)\n{\n\tconst struct fw_hdr *fw_hdr = (const struct fw_hdr *)fw_data;\n\tint reset, ret;\n\n\tret = csio_hw_fw_halt(hw, mbox, force);\n\tif (ret != 0 && !force)\n\t\treturn ret;\n\n\tret = csio_hw_fw_dload(hw, (uint8_t *) fw_data, size);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\treset = ((ntohl(fw_hdr->flags) & FW_HDR_FLAGS_RESET_HALT) == 0);\n\treturn csio_hw_fw_restart(hw, mbox, reset);\n}\n\n \nstatic int\ncsio_get_device_params(struct csio_hw *hw)\n{\n\tstruct csio_wrm *wrm\t= csio_hw_to_wrm(hw);\n\tstruct csio_mb\t*mbp;\n\tenum fw_retval retval;\n\tu32 param[6];\n\tint i, j = 0;\n\n\t \n\tfor (i = 0; i < CSIO_MAX_PPORTS; i++)\n\t\thw->pport[i].portid = -1;\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tparam[0] = FW_PARAM_DEV(PORTVEC);\n\n\t \n\tparam[1] = FW_PARAM_DEV(CCLK);\n\n\t \n\tparam[2] = FW_PARAM_PFVF(EQ_START);\n\tparam[3] = FW_PARAM_PFVF(EQ_END);\n\n\t \n\tparam[4] = FW_PARAM_PFVF(IQFLINT_START);\n\tparam[5] = FW_PARAM_PFVF(IQFLINT_END);\n\n\tcsio_mb_params(hw, mbp, CSIO_MB_DEFAULT_TMO, hw->pfn, 0,\n\t\t       ARRAY_SIZE(param), param, NULL, false, NULL);\n\tif (csio_mb_issue(hw, mbp)) {\n\t\tcsio_err(hw, \"Issue of FW_PARAMS_CMD(read) failed!\\n\");\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\tcsio_mb_process_read_params_rsp(hw, mbp, &retval,\n\t\t\tARRAY_SIZE(param), param);\n\tif (retval != FW_SUCCESS) {\n\t\tcsio_err(hw, \"FW_PARAMS_CMD(read) failed with ret:0x%x!\\n\",\n\t\t\t\tretval);\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\thw->port_vec = param[0];\n\thw->vpd.cclk = param[1];\n\twrm->fw_eq_start = param[2];\n\twrm->fw_iq_start = param[4];\n\n\t \n\tif ((hw->flags & CSIO_HWF_USING_SOFT_PARAMS) ||\n\t\t!csio_is_hw_master(hw)) {\n\t\thw->cfg_niq = param[5] - param[4] + 1;\n\t\thw->cfg_neq = param[3] - param[2] + 1;\n\t\tcsio_dbg(hw, \"Using fwconfig max niqs %d neqs %d\\n\",\n\t\t\thw->cfg_niq, hw->cfg_neq);\n\t}\n\n\thw->port_vec &= csio_port_mask;\n\n\thw->num_pports\t= hweight32(hw->port_vec);\n\n\tcsio_dbg(hw, \"Port vector: 0x%x, #ports: %d\\n\",\n\t\t    hw->port_vec, hw->num_pports);\n\n\tfor (i = 0; i < hw->num_pports; i++) {\n\t\twhile ((hw->port_vec & (1 << j)) == 0)\n\t\t\tj++;\n\t\thw->pport[i].portid = j++;\n\t\tcsio_dbg(hw, \"Found Port:%d\\n\", hw->pport[i].portid);\n\t}\n\tmempool_free(mbp, hw->mb_mempool);\n\n\treturn 0;\n}\n\n\n \nstatic int\ncsio_config_device_caps(struct csio_hw *hw)\n{\n\tstruct csio_mb\t*mbp;\n\tenum fw_retval retval;\n\tint rv = -EINVAL;\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tcsio_mb_caps_config(hw, mbp, CSIO_MB_DEFAULT_TMO, 0, 0, 0, 0, NULL);\n\n\tif (csio_mb_issue(hw, mbp)) {\n\t\tcsio_err(hw, \"Issue of FW_CAPS_CONFIG_CMD(r) failed!\\n\");\n\t\tgoto out;\n\t}\n\n\tretval = csio_mb_fw_retval(mbp);\n\tif (retval != FW_SUCCESS) {\n\t\tcsio_err(hw, \"FW_CAPS_CONFIG_CMD(r) returned %d!\\n\", retval);\n\t\tgoto out;\n\t}\n\n\t \n\trv = csio_hw_validate_caps(hw, mbp);\n\tif (rv != 0)\n\t\tgoto out;\n\n\t \n\tif (hw->fw_state == CSIO_DEV_STATE_INIT) {\n\t\trv = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tcsio_mb_caps_config(hw, mbp, CSIO_MB_DEFAULT_TMO, true, true,\n\t\t\t    false, true, NULL);\n\n\tif (csio_mb_issue(hw, mbp)) {\n\t\tcsio_err(hw, \"Issue of FW_CAPS_CONFIG_CMD(w) failed!\\n\");\n\t\tgoto out;\n\t}\n\n\tretval = csio_mb_fw_retval(mbp);\n\tif (retval != FW_SUCCESS) {\n\t\tcsio_err(hw, \"FW_CAPS_CONFIG_CMD(w) returned %d!\\n\", retval);\n\t\tgoto out;\n\t}\n\n\trv = 0;\nout:\n\tmempool_free(mbp, hw->mb_mempool);\n\treturn rv;\n}\n\nstatic inline enum cc_fec fwcap_to_cc_fec(fw_port_cap32_t fw_fec)\n{\n\tenum cc_fec cc_fec = 0;\n\n\tif (fw_fec & FW_PORT_CAP32_FEC_RS)\n\t\tcc_fec |= FEC_RS;\n\tif (fw_fec & FW_PORT_CAP32_FEC_BASER_RS)\n\t\tcc_fec |= FEC_BASER_RS;\n\n\treturn cc_fec;\n}\n\nstatic inline fw_port_cap32_t cc_to_fwcap_pause(enum cc_pause cc_pause)\n{\n\tfw_port_cap32_t fw_pause = 0;\n\n\tif (cc_pause & PAUSE_RX)\n\t\tfw_pause |= FW_PORT_CAP32_FC_RX;\n\tif (cc_pause & PAUSE_TX)\n\t\tfw_pause |= FW_PORT_CAP32_FC_TX;\n\n\treturn fw_pause;\n}\n\nstatic inline fw_port_cap32_t cc_to_fwcap_fec(enum cc_fec cc_fec)\n{\n\tfw_port_cap32_t fw_fec = 0;\n\n\tif (cc_fec & FEC_RS)\n\t\tfw_fec |= FW_PORT_CAP32_FEC_RS;\n\tif (cc_fec & FEC_BASER_RS)\n\t\tfw_fec |= FW_PORT_CAP32_FEC_BASER_RS;\n\n\treturn fw_fec;\n}\n\n \nfw_port_cap32_t fwcap_to_fwspeed(fw_port_cap32_t acaps)\n{\n\t#define TEST_SPEED_RETURN(__caps_speed) \\\n\t\tdo { \\\n\t\t\tif (acaps & FW_PORT_CAP32_SPEED_##__caps_speed) \\\n\t\t\t\treturn FW_PORT_CAP32_SPEED_##__caps_speed; \\\n\t\t} while (0)\n\n\tTEST_SPEED_RETURN(400G);\n\tTEST_SPEED_RETURN(200G);\n\tTEST_SPEED_RETURN(100G);\n\tTEST_SPEED_RETURN(50G);\n\tTEST_SPEED_RETURN(40G);\n\tTEST_SPEED_RETURN(25G);\n\tTEST_SPEED_RETURN(10G);\n\tTEST_SPEED_RETURN(1G);\n\tTEST_SPEED_RETURN(100M);\n\n\t#undef TEST_SPEED_RETURN\n\n\treturn 0;\n}\n\n \nfw_port_cap32_t fwcaps16_to_caps32(fw_port_cap16_t caps16)\n{\n\tfw_port_cap32_t caps32 = 0;\n\n\t#define CAP16_TO_CAP32(__cap) \\\n\t\tdo { \\\n\t\t\tif (caps16 & FW_PORT_CAP_##__cap) \\\n\t\t\t\tcaps32 |= FW_PORT_CAP32_##__cap; \\\n\t\t} while (0)\n\n\tCAP16_TO_CAP32(SPEED_100M);\n\tCAP16_TO_CAP32(SPEED_1G);\n\tCAP16_TO_CAP32(SPEED_25G);\n\tCAP16_TO_CAP32(SPEED_10G);\n\tCAP16_TO_CAP32(SPEED_40G);\n\tCAP16_TO_CAP32(SPEED_100G);\n\tCAP16_TO_CAP32(FC_RX);\n\tCAP16_TO_CAP32(FC_TX);\n\tCAP16_TO_CAP32(ANEG);\n\tCAP16_TO_CAP32(MDIAUTO);\n\tCAP16_TO_CAP32(MDISTRAIGHT);\n\tCAP16_TO_CAP32(FEC_RS);\n\tCAP16_TO_CAP32(FEC_BASER_RS);\n\tCAP16_TO_CAP32(802_3_PAUSE);\n\tCAP16_TO_CAP32(802_3_ASM_DIR);\n\n\t#undef CAP16_TO_CAP32\n\n\treturn caps32;\n}\n\n \nfw_port_cap16_t fwcaps32_to_caps16(fw_port_cap32_t caps32)\n{\n\tfw_port_cap16_t caps16 = 0;\n\n\t#define CAP32_TO_CAP16(__cap) \\\n\t\tdo { \\\n\t\t\tif (caps32 & FW_PORT_CAP32_##__cap) \\\n\t\t\t\tcaps16 |= FW_PORT_CAP_##__cap; \\\n\t\t} while (0)\n\n\tCAP32_TO_CAP16(SPEED_100M);\n\tCAP32_TO_CAP16(SPEED_1G);\n\tCAP32_TO_CAP16(SPEED_10G);\n\tCAP32_TO_CAP16(SPEED_25G);\n\tCAP32_TO_CAP16(SPEED_40G);\n\tCAP32_TO_CAP16(SPEED_100G);\n\tCAP32_TO_CAP16(FC_RX);\n\tCAP32_TO_CAP16(FC_TX);\n\tCAP32_TO_CAP16(802_3_PAUSE);\n\tCAP32_TO_CAP16(802_3_ASM_DIR);\n\tCAP32_TO_CAP16(ANEG);\n\tCAP32_TO_CAP16(FORCE_PAUSE);\n\tCAP32_TO_CAP16(MDIAUTO);\n\tCAP32_TO_CAP16(MDISTRAIGHT);\n\tCAP32_TO_CAP16(FEC_RS);\n\tCAP32_TO_CAP16(FEC_BASER_RS);\n\n\t#undef CAP32_TO_CAP16\n\n\treturn caps16;\n}\n\n \nfw_port_cap32_t lstatus_to_fwcap(u32 lstatus)\n{\n\tfw_port_cap32_t linkattr = 0;\n\n\t \n\tif (lstatus & FW_PORT_CMD_RXPAUSE_F)\n\t\tlinkattr |= FW_PORT_CAP32_FC_RX;\n\tif (lstatus & FW_PORT_CMD_TXPAUSE_F)\n\t\tlinkattr |= FW_PORT_CAP32_FC_TX;\n\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_100M))\n\t\tlinkattr |= FW_PORT_CAP32_SPEED_100M;\n\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_1G))\n\t\tlinkattr |= FW_PORT_CAP32_SPEED_1G;\n\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_10G))\n\t\tlinkattr |= FW_PORT_CAP32_SPEED_10G;\n\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_25G))\n\t\tlinkattr |= FW_PORT_CAP32_SPEED_25G;\n\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_40G))\n\t\tlinkattr |= FW_PORT_CAP32_SPEED_40G;\n\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_100G))\n\t\tlinkattr |= FW_PORT_CAP32_SPEED_100G;\n\n\treturn linkattr;\n}\n\n \nstatic void csio_init_link_config(struct link_config *lc, fw_port_cap32_t pcaps,\n\t\t\t\t  fw_port_cap32_t acaps)\n{\n\tlc->pcaps = pcaps;\n\tlc->def_acaps = acaps;\n\tlc->lpacaps = 0;\n\tlc->speed_caps = 0;\n\tlc->speed = 0;\n\tlc->requested_fc = PAUSE_RX | PAUSE_TX;\n\tlc->fc = lc->requested_fc;\n\n\t \n\tlc->requested_fec = FEC_AUTO;\n\tlc->fec = fwcap_to_cc_fec(lc->def_acaps);\n\n\t \n\tif (lc->pcaps & FW_PORT_CAP32_ANEG) {\n\t\tlc->acaps = lc->pcaps & ADVERT_MASK;\n\t\tlc->autoneg = AUTONEG_ENABLE;\n\t\tlc->requested_fc |= PAUSE_AUTONEG;\n\t} else {\n\t\tlc->acaps = 0;\n\t\tlc->autoneg = AUTONEG_DISABLE;\n\t}\n}\n\nstatic void csio_link_l1cfg(struct link_config *lc, uint16_t fw_caps,\n\t\t\t    uint32_t *rcaps)\n{\n\tunsigned int fw_mdi = FW_PORT_CAP32_MDI_V(FW_PORT_CAP32_MDI_AUTO);\n\tfw_port_cap32_t fw_fc, cc_fec, fw_fec, lrcap;\n\n\tlc->link_ok = 0;\n\n\t \n\tfw_fc = cc_to_fwcap_pause(lc->requested_fc);\n\n\t \n\tif (lc->requested_fec & FEC_AUTO)\n\t\tcc_fec = fwcap_to_cc_fec(lc->def_acaps);\n\telse\n\t\tcc_fec = lc->requested_fec;\n\tfw_fec = cc_to_fwcap_fec(cc_fec);\n\n\t \n\tif (!(lc->pcaps & FW_PORT_CAP32_ANEG)) {\n\t\tlrcap = (lc->pcaps & ADVERT_MASK) | fw_fc | fw_fec;\n\t\tlc->fc = lc->requested_fc & ~PAUSE_AUTONEG;\n\t\tlc->fec = cc_fec;\n\t} else if (lc->autoneg == AUTONEG_DISABLE) {\n\t\tlrcap = lc->speed_caps | fw_fc | fw_fec | fw_mdi;\n\t\tlc->fc = lc->requested_fc & ~PAUSE_AUTONEG;\n\t\tlc->fec = cc_fec;\n\t} else {\n\t\tlrcap = lc->acaps | fw_fc | fw_fec | fw_mdi;\n\t}\n\n\t*rcaps = lrcap;\n}\n\n \nstatic int\ncsio_enable_ports(struct csio_hw *hw)\n{\n\tstruct csio_mb  *mbp;\n\tu16 fw_caps = FW_CAPS_UNKNOWN;\n\tenum fw_retval retval;\n\tuint8_t portid;\n\tfw_port_cap32_t pcaps, acaps, rcaps;\n\tint i;\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < hw->num_pports; i++) {\n\t\tportid = hw->pport[i].portid;\n\n\t\tif (fw_caps == FW_CAPS_UNKNOWN) {\n\t\t\tu32 param, val;\n\n\t\t\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_PFVF) |\n\t\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_PFVF_PORT_CAPS32));\n\t\t\tval = 1;\n\n\t\t\tcsio_mb_params(hw, mbp, CSIO_MB_DEFAULT_TMO,\n\t\t\t\t       hw->pfn, 0, 1, &param, &val, true,\n\t\t\t\t       NULL);\n\n\t\t\tif (csio_mb_issue(hw, mbp)) {\n\t\t\t\tcsio_err(hw, \"failed to issue FW_PARAMS_CMD(r) port:%d\\n\",\n\t\t\t\t\t portid);\n\t\t\t\tmempool_free(mbp, hw->mb_mempool);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tcsio_mb_process_read_params_rsp(hw, mbp, &retval,\n\t\t\t\t\t\t\t0, NULL);\n\t\t\tfw_caps = retval ? FW_CAPS16 : FW_CAPS32;\n\t\t}\n\n\t\t \n\t\tcsio_mb_port(hw, mbp, CSIO_MB_DEFAULT_TMO, portid,\n\t\t\t     false, 0, fw_caps, NULL);\n\n\t\tif (csio_mb_issue(hw, mbp)) {\n\t\t\tcsio_err(hw, \"failed to issue FW_PORT_CMD(r) port:%d\\n\",\n\t\t\t\t portid);\n\t\t\tmempool_free(mbp, hw->mb_mempool);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcsio_mb_process_read_port_rsp(hw, mbp, &retval, fw_caps,\n\t\t\t\t\t      &pcaps, &acaps);\n\t\tif (retval != FW_SUCCESS) {\n\t\t\tcsio_err(hw, \"FW_PORT_CMD(r) port:%d failed: 0x%x\\n\",\n\t\t\t\t portid, retval);\n\t\t\tmempool_free(mbp, hw->mb_mempool);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcsio_init_link_config(&hw->pport[i].link_cfg, pcaps, acaps);\n\n\t\tcsio_link_l1cfg(&hw->pport[i].link_cfg, fw_caps, &rcaps);\n\n\t\t \n\t\tcsio_mb_port(hw, mbp, CSIO_MB_DEFAULT_TMO, portid,\n\t\t\t     true, rcaps, fw_caps, NULL);\n\n\t\tif (csio_mb_issue(hw, mbp)) {\n\t\t\tcsio_err(hw, \"failed to issue FW_PORT_CMD(w) port:%d\\n\",\n\t\t\t\t portid);\n\t\t\tmempool_free(mbp, hw->mb_mempool);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tretval = csio_mb_fw_retval(mbp);\n\t\tif (retval != FW_SUCCESS) {\n\t\t\tcsio_err(hw, \"FW_PORT_CMD(w) port:%d failed :0x%x\\n\",\n\t\t\t\t portid, retval);\n\t\t\tmempool_free(mbp, hw->mb_mempool);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t}  \n\n\tmempool_free(mbp, hw->mb_mempool);\n\n\treturn 0;\n}\n\n \nstatic int\ncsio_get_fcoe_resinfo(struct csio_hw *hw)\n{\n\tstruct csio_fcoe_res_info *res_info = &hw->fres_info;\n\tstruct fw_fcoe_res_info_cmd *rsp;\n\tstruct csio_mb  *mbp;\n\tenum fw_retval retval;\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tcsio_fcoe_read_res_info_init_mb(hw, mbp, CSIO_MB_DEFAULT_TMO, NULL);\n\n\tif (csio_mb_issue(hw, mbp)) {\n\t\tcsio_err(hw, \"failed to issue FW_FCOE_RES_INFO_CMD\\n\");\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\trsp = (struct fw_fcoe_res_info_cmd *)(mbp->mb);\n\tretval = FW_CMD_RETVAL_G(ntohl(rsp->retval_len16));\n\tif (retval != FW_SUCCESS) {\n\t\tcsio_err(hw, \"FW_FCOE_RES_INFO_CMD failed with ret x%x\\n\",\n\t\t\t retval);\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\tres_info->e_d_tov = ntohs(rsp->e_d_tov);\n\tres_info->r_a_tov_seq = ntohs(rsp->r_a_tov_seq);\n\tres_info->r_a_tov_els = ntohs(rsp->r_a_tov_els);\n\tres_info->r_r_tov = ntohs(rsp->r_r_tov);\n\tres_info->max_xchgs = ntohl(rsp->max_xchgs);\n\tres_info->max_ssns = ntohl(rsp->max_ssns);\n\tres_info->used_xchgs = ntohl(rsp->used_xchgs);\n\tres_info->used_ssns = ntohl(rsp->used_ssns);\n\tres_info->max_fcfs = ntohl(rsp->max_fcfs);\n\tres_info->max_vnps = ntohl(rsp->max_vnps);\n\tres_info->used_fcfs = ntohl(rsp->used_fcfs);\n\tres_info->used_vnps = ntohl(rsp->used_vnps);\n\n\tcsio_dbg(hw, \"max ssns:%d max xchgs:%d\\n\", res_info->max_ssns,\n\t\t\t\t\t\t  res_info->max_xchgs);\n\tmempool_free(mbp, hw->mb_mempool);\n\n\treturn 0;\n}\n\nstatic int\ncsio_hw_check_fwconfig(struct csio_hw *hw, u32 *param)\n{\n\tstruct csio_mb\t*mbp;\n\tenum fw_retval retval;\n\tu32 _param[1];\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\t_param[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t     FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_CF));\n\n\tcsio_mb_params(hw, mbp, CSIO_MB_DEFAULT_TMO, hw->pfn, 0,\n\t\t       ARRAY_SIZE(_param), _param, NULL, false, NULL);\n\tif (csio_mb_issue(hw, mbp)) {\n\t\tcsio_err(hw, \"Issue of FW_PARAMS_CMD(read) failed!\\n\");\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\tcsio_mb_process_read_params_rsp(hw, mbp, &retval,\n\t\t\tARRAY_SIZE(_param), _param);\n\tif (retval != FW_SUCCESS) {\n\t\tcsio_err(hw, \"FW_PARAMS_CMD(read) failed with ret:0x%x!\\n\",\n\t\t\t\tretval);\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\tmempool_free(mbp, hw->mb_mempool);\n\t*param = _param[0];\n\n\treturn 0;\n}\n\nstatic int\ncsio_hw_flash_config(struct csio_hw *hw, u32 *fw_cfg_param, char *path)\n{\n\tint ret = 0;\n\tconst struct firmware *cf;\n\tstruct pci_dev *pci_dev = hw->pdev;\n\tstruct device *dev = &pci_dev->dev;\n\tunsigned int mtype = 0, maddr = 0;\n\tuint32_t *cfg_data;\n\tint value_to_add = 0;\n\tconst char *fw_cfg_file;\n\n\tif (csio_is_t5(pci_dev->device & CSIO_HW_CHIP_MASK))\n\t\tfw_cfg_file = FW_CFG_NAME_T5;\n\telse\n\t\tfw_cfg_file = FW_CFG_NAME_T6;\n\n\tif (request_firmware(&cf, fw_cfg_file, dev) < 0) {\n\t\tcsio_err(hw, \"could not find config file %s, err: %d\\n\",\n\t\t\t fw_cfg_file, ret);\n\t\treturn -ENOENT;\n\t}\n\n\tif (cf->size%4 != 0)\n\t\tvalue_to_add = 4 - (cf->size % 4);\n\n\tcfg_data = kzalloc(cf->size+value_to_add, GFP_KERNEL);\n\tif (cfg_data == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto leave;\n\t}\n\n\tmemcpy((void *)cfg_data, (const void *)cf->data, cf->size);\n\tif (csio_hw_check_fwconfig(hw, fw_cfg_param) != 0) {\n\t\tret = -EINVAL;\n\t\tgoto leave;\n\t}\n\n\tmtype = FW_PARAMS_PARAM_Y_G(*fw_cfg_param);\n\tmaddr = FW_PARAMS_PARAM_Z_G(*fw_cfg_param) << 16;\n\n\tret = csio_memory_write(hw, mtype, maddr,\n\t\t\t\tcf->size + value_to_add, cfg_data);\n\n\tif ((ret == 0) && (value_to_add != 0)) {\n\t\tunion {\n\t\t\tu32 word;\n\t\t\tchar buf[4];\n\t\t} last;\n\t\tsize_t size = cf->size & ~0x3;\n\t\tint i;\n\n\t\tlast.word = cfg_data[size >> 2];\n\t\tfor (i = value_to_add; i < 4; i++)\n\t\t\tlast.buf[i] = 0;\n\t\tret = csio_memory_write(hw, mtype, maddr + size, 4, &last.word);\n\t}\n\tif (ret == 0) {\n\t\tcsio_info(hw, \"config file upgraded to %s\\n\", fw_cfg_file);\n\t\tsnprintf(path, 64, \"%s%s\", \"/lib/firmware/\", fw_cfg_file);\n\t}\n\nleave:\n\tkfree(cfg_data);\n\trelease_firmware(cf);\n\treturn ret;\n}\n\n \n\n \nstatic int\ncsio_hw_use_fwconfig(struct csio_hw *hw, int reset, u32 *fw_cfg_param)\n{\n\tstruct csio_mb\t*mbp = NULL;\n\tstruct fw_caps_config_cmd *caps_cmd;\n\tunsigned int mtype, maddr;\n\tint rv = -EINVAL;\n\tuint32_t finiver = 0, finicsum = 0, cfcsum = 0;\n\tchar path[64];\n\tchar *config_name = NULL;\n\n\t \n\tif (reset) {\n\t\trv = csio_do_reset(hw, true);\n\t\tif (rv != 0)\n\t\t\tgoto bye;\n\t}\n\n\t \n\tspin_unlock_irq(&hw->lock);\n\trv = csio_hw_flash_config(hw, fw_cfg_param, path);\n\tspin_lock_irq(&hw->lock);\n\tif (rv != 0) {\n\t\t \n\t\tconfig_name = \"On FLASH\";\n\t\tmtype = FW_MEMTYPE_CF_FLASH;\n\t\tmaddr = hw->chip_ops->chip_flash_cfg_addr(hw);\n\t} else {\n\t\tconfig_name = path;\n\t\tmtype = FW_PARAMS_PARAM_Y_G(*fw_cfg_param);\n\t\tmaddr = FW_PARAMS_PARAM_Z_G(*fw_cfg_param) << 16;\n\t}\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\treturn -ENOMEM;\n\t}\n\t \n\tcaps_cmd = (struct fw_caps_config_cmd *)(mbp->mb);\n\tCSIO_INIT_MBP(mbp, caps_cmd, CSIO_MB_DEFAULT_TMO, hw, NULL, 1);\n\tcaps_cmd->op_to_write =\n\t\thtonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t      FW_CMD_REQUEST_F |\n\t\t      FW_CMD_READ_F);\n\tcaps_cmd->cfvalid_to_len16 =\n\t\thtonl(FW_CAPS_CONFIG_CMD_CFVALID_F |\n\t\t      FW_CAPS_CONFIG_CMD_MEMTYPE_CF_V(mtype) |\n\t\t      FW_CAPS_CONFIG_CMD_MEMADDR64K_CF_V(maddr >> 16) |\n\t\t      FW_LEN16(*caps_cmd));\n\n\tif (csio_mb_issue(hw, mbp)) {\n\t\trv = -EINVAL;\n\t\tgoto bye;\n\t}\n\n\trv = csio_mb_fw_retval(mbp);\n\t  \n\tif (rv == ENOENT) {\n\t\tCSIO_INIT_MBP(mbp, caps_cmd, CSIO_MB_DEFAULT_TMO, hw, NULL, 1);\n\t\tcaps_cmd->op_to_write = htonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t\t\t\t      FW_CMD_REQUEST_F |\n\t\t\t\t\t      FW_CMD_READ_F);\n\t\tcaps_cmd->cfvalid_to_len16 = htonl(FW_LEN16(*caps_cmd));\n\n\t\tif (csio_mb_issue(hw, mbp)) {\n\t\t\trv = -EINVAL;\n\t\t\tgoto bye;\n\t\t}\n\n\t\trv = csio_mb_fw_retval(mbp);\n\t\tconfig_name = \"Firmware Default\";\n\t}\n\tif (rv != FW_SUCCESS)\n\t\tgoto bye;\n\n\tfiniver = ntohl(caps_cmd->finiver);\n\tfinicsum = ntohl(caps_cmd->finicsum);\n\tcfcsum = ntohl(caps_cmd->cfcsum);\n\n\t \n\tcaps_cmd->op_to_write =\n\t\thtonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t      FW_CMD_REQUEST_F |\n\t\t      FW_CMD_WRITE_F);\n\tcaps_cmd->cfvalid_to_len16 = htonl(FW_LEN16(*caps_cmd));\n\n\tif (csio_mb_issue(hw, mbp)) {\n\t\trv = -EINVAL;\n\t\tgoto bye;\n\t}\n\n\trv = csio_mb_fw_retval(mbp);\n\tif (rv != FW_SUCCESS) {\n\t\tcsio_dbg(hw, \"FW_CAPS_CONFIG_CMD returned %d!\\n\", rv);\n\t\tgoto bye;\n\t}\n\n\tif (finicsum != cfcsum) {\n\t\tcsio_warn(hw,\n\t\t      \"Config File checksum mismatch: csum=%#x, computed=%#x\\n\",\n\t\t      finicsum, cfcsum);\n\t}\n\n\t \n\trv = csio_hw_validate_caps(hw, mbp);\n\tif (rv != 0)\n\t\tgoto bye;\n\n\tmempool_free(mbp, hw->mb_mempool);\n\tmbp = NULL;\n\n\t \n\thw->flags |= CSIO_HWF_USING_SOFT_PARAMS;\n\n\t \n\trv = csio_get_device_params(hw);\n\tif (rv != 0)\n\t\tgoto bye;\n\n\t \n\tcsio_wr_sge_init(hw);\n\n\t \n\t \n\tcsio_post_event(&hw->sm, CSIO_HWE_INIT);\n\n\tcsio_info(hw, \"Successfully configure using Firmware \"\n\t\t  \"Configuration File %s, version %#x, computed checksum %#x\\n\",\n\t\t  config_name, finiver, cfcsum);\n\treturn 0;\n\n\t \nbye:\n\tif (mbp)\n\t\tmempool_free(mbp, hw->mb_mempool);\n\thw->flags &= ~CSIO_HWF_USING_SOFT_PARAMS;\n\tcsio_warn(hw, \"Configuration file error %d\\n\", rv);\n\treturn rv;\n}\n\n \nstatic int fw_compatible(const struct fw_hdr *hdr1, const struct fw_hdr *hdr2)\n{\n\n\t \n\tif (hdr1->chip == hdr2->chip && hdr1->fw_ver == hdr2->fw_ver)\n\t\treturn 1;\n\n#define SAME_INTF(x) (hdr1->intfver_##x == hdr2->intfver_##x)\n\tif (hdr1->chip == hdr2->chip && SAME_INTF(nic) && SAME_INTF(vnic) &&\n\t    SAME_INTF(ri) && SAME_INTF(iscsi) && SAME_INTF(fcoe))\n\t\treturn 1;\n#undef SAME_INTF\n\n\treturn 0;\n}\n\n \nstatic int csio_should_install_fs_fw(struct csio_hw *hw, int card_fw_usable,\n\t\t\t\tint k, int c)\n{\n\tconst char *reason;\n\n\tif (!card_fw_usable) {\n\t\treason = \"incompatible or unusable\";\n\t\tgoto install;\n\t}\n\n\tif (k > c) {\n\t\treason = \"older than the version supported with this driver\";\n\t\tgoto install;\n\t}\n\n\treturn 0;\n\ninstall:\n\tcsio_err(hw, \"firmware on card (%u.%u.%u.%u) is %s, \"\n\t\t\"installing firmware %u.%u.%u.%u on card.\\n\",\n\t\tFW_HDR_FW_VER_MAJOR_G(c), FW_HDR_FW_VER_MINOR_G(c),\n\t\tFW_HDR_FW_VER_MICRO_G(c), FW_HDR_FW_VER_BUILD_G(c), reason,\n\t\tFW_HDR_FW_VER_MAJOR_G(k), FW_HDR_FW_VER_MINOR_G(k),\n\t\tFW_HDR_FW_VER_MICRO_G(k), FW_HDR_FW_VER_BUILD_G(k));\n\n\treturn 1;\n}\n\nstatic struct fw_info fw_info_array[] = {\n\t{\n\t\t.chip = CHELSIO_T5,\n\t\t.fs_name = FW_CFG_NAME_T5,\n\t\t.fw_mod_name = FW_FNAME_T5,\n\t\t.fw_hdr = {\n\t\t\t.chip = FW_HDR_CHIP_T5,\n\t\t\t.fw_ver = __cpu_to_be32(FW_VERSION(T5)),\n\t\t\t.intfver_nic = FW_INTFVER(T5, NIC),\n\t\t\t.intfver_vnic = FW_INTFVER(T5, VNIC),\n\t\t\t.intfver_ri = FW_INTFVER(T5, RI),\n\t\t\t.intfver_iscsi = FW_INTFVER(T5, ISCSI),\n\t\t\t.intfver_fcoe = FW_INTFVER(T5, FCOE),\n\t\t},\n\t}, {\n\t\t.chip = CHELSIO_T6,\n\t\t.fs_name = FW_CFG_NAME_T6,\n\t\t.fw_mod_name = FW_FNAME_T6,\n\t\t.fw_hdr = {\n\t\t\t.chip = FW_HDR_CHIP_T6,\n\t\t\t.fw_ver = __cpu_to_be32(FW_VERSION(T6)),\n\t\t\t.intfver_nic = FW_INTFVER(T6, NIC),\n\t\t\t.intfver_vnic = FW_INTFVER(T6, VNIC),\n\t\t\t.intfver_ri = FW_INTFVER(T6, RI),\n\t\t\t.intfver_iscsi = FW_INTFVER(T6, ISCSI),\n\t\t\t.intfver_fcoe = FW_INTFVER(T6, FCOE),\n\t\t},\n\t}\n};\n\nstatic struct fw_info *find_fw_info(int chip)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fw_info_array); i++) {\n\t\tif (fw_info_array[i].chip == chip)\n\t\t\treturn &fw_info_array[i];\n\t}\n\treturn NULL;\n}\n\nstatic int csio_hw_prep_fw(struct csio_hw *hw, struct fw_info *fw_info,\n\t       const u8 *fw_data, unsigned int fw_size,\n\t       struct fw_hdr *card_fw, enum csio_dev_state state,\n\t       int *reset)\n{\n\tint ret, card_fw_usable, fs_fw_usable;\n\tconst struct fw_hdr *fs_fw;\n\tconst struct fw_hdr *drv_fw;\n\n\tdrv_fw = &fw_info->fw_hdr;\n\n\t \n\tret = csio_hw_read_flash(hw, FLASH_FW_START,\n\t\t\t    sizeof(*card_fw) / sizeof(uint32_t),\n\t\t\t    (uint32_t *)card_fw, 1);\n\tif (ret == 0) {\n\t\tcard_fw_usable = fw_compatible(drv_fw, (const void *)card_fw);\n\t} else {\n\t\tcsio_err(hw,\n\t\t\t\"Unable to read card's firmware header: %d\\n\", ret);\n\t\tcard_fw_usable = 0;\n\t}\n\n\tif (fw_data != NULL) {\n\t\tfs_fw = (const void *)fw_data;\n\t\tfs_fw_usable = fw_compatible(drv_fw, fs_fw);\n\t} else {\n\t\tfs_fw = NULL;\n\t\tfs_fw_usable = 0;\n\t}\n\n\tif (card_fw_usable && card_fw->fw_ver == drv_fw->fw_ver &&\n\t    (!fs_fw_usable || fs_fw->fw_ver == drv_fw->fw_ver)) {\n\t\t \n\t} else if (fs_fw_usable && state == CSIO_DEV_STATE_UNINIT &&\n\t\t   csio_should_install_fs_fw(hw, card_fw_usable,\n\t\t\t\t\tbe32_to_cpu(fs_fw->fw_ver),\n\t\t\t\t\tbe32_to_cpu(card_fw->fw_ver))) {\n\t\tret = csio_hw_fw_upgrade(hw, hw->pfn, fw_data,\n\t\t\t\t     fw_size, 0);\n\t\tif (ret != 0) {\n\t\t\tcsio_err(hw,\n\t\t\t\t\"failed to install firmware: %d\\n\", ret);\n\t\t\tgoto bye;\n\t\t}\n\n\t\t \n\t\tmemcpy(card_fw, fs_fw, sizeof(*card_fw));\n\t\tcard_fw_usable = 1;\n\t\t*reset = 0;\t \n\t}\n\n\tif (!card_fw_usable) {\n\t\tuint32_t d, c, k;\n\n\t\td = be32_to_cpu(drv_fw->fw_ver);\n\t\tc = be32_to_cpu(card_fw->fw_ver);\n\t\tk = fs_fw ? be32_to_cpu(fs_fw->fw_ver) : 0;\n\n\t\tcsio_err(hw, \"Cannot find a usable firmware: \"\n\t\t\t\"chip state %d, \"\n\t\t\t\"driver compiled with %d.%d.%d.%d, \"\n\t\t\t\"card has %d.%d.%d.%d, filesystem has %d.%d.%d.%d\\n\",\n\t\t\tstate,\n\t\t\tFW_HDR_FW_VER_MAJOR_G(d), FW_HDR_FW_VER_MINOR_G(d),\n\t\t\tFW_HDR_FW_VER_MICRO_G(d), FW_HDR_FW_VER_BUILD_G(d),\n\t\t\tFW_HDR_FW_VER_MAJOR_G(c), FW_HDR_FW_VER_MINOR_G(c),\n\t\t\tFW_HDR_FW_VER_MICRO_G(c), FW_HDR_FW_VER_BUILD_G(c),\n\t\t\tFW_HDR_FW_VER_MAJOR_G(k), FW_HDR_FW_VER_MINOR_G(k),\n\t\t\tFW_HDR_FW_VER_MICRO_G(k), FW_HDR_FW_VER_BUILD_G(k));\n\t\tret = -EINVAL;\n\t\tgoto bye;\n\t}\n\n\t \n\thw->fwrev = be32_to_cpu(card_fw->fw_ver);\n\thw->tp_vers = be32_to_cpu(card_fw->tp_microcode_ver);\n\nbye:\n\treturn ret;\n}\n\n \nstatic int\ncsio_hw_flash_fw(struct csio_hw *hw, int *reset)\n{\n\tint ret = -ECANCELED;\n\tconst struct firmware *fw;\n\tstruct fw_info *fw_info;\n\tstruct fw_hdr *card_fw;\n\tstruct pci_dev *pci_dev = hw->pdev;\n\tstruct device *dev = &pci_dev->dev ;\n\tconst u8 *fw_data = NULL;\n\tunsigned int fw_size = 0;\n\tconst char *fw_bin_file;\n\n\t \n\tfw_info = find_fw_info(CHELSIO_CHIP_VERSION(hw->chip_id));\n\tif (fw_info == NULL) {\n\t\tcsio_err(hw,\n\t\t\t\"unable to get firmware info for chip %d.\\n\",\n\t\t\tCHELSIO_CHIP_VERSION(hw->chip_id));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcard_fw = kmalloc(sizeof(*card_fw), GFP_KERNEL);\n\tif (!card_fw)\n\t\treturn -ENOMEM;\n\n\tif (csio_is_t5(pci_dev->device & CSIO_HW_CHIP_MASK))\n\t\tfw_bin_file = FW_FNAME_T5;\n\telse\n\t\tfw_bin_file = FW_FNAME_T6;\n\n\tif (request_firmware(&fw, fw_bin_file, dev) < 0) {\n\t\tcsio_err(hw, \"could not find firmware image %s, err: %d\\n\",\n\t\t\t fw_bin_file, ret);\n\t} else {\n\t\tfw_data = fw->data;\n\t\tfw_size = fw->size;\n\t}\n\n\t \n\tret = csio_hw_prep_fw(hw, fw_info, fw_data, fw_size, card_fw,\n\t\t\t hw->fw_state, reset);\n\n\t \n\tif (fw != NULL)\n\t\trelease_firmware(fw);\n\tkfree(card_fw);\n\treturn ret;\n}\n\nstatic int csio_hw_check_fwver(struct csio_hw *hw)\n{\n\tif (csio_is_t6(hw->pdev->device & CSIO_HW_CHIP_MASK) &&\n\t    (hw->fwrev < CSIO_MIN_T6_FW)) {\n\t\tcsio_hw_print_fw_version(hw, \"T6 unsupported fw\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\ncsio_hw_configure(struct csio_hw *hw)\n{\n\tint reset = 1;\n\tint rv;\n\tu32 param[1];\n\n\trv = csio_hw_dev_ready(hw);\n\tif (rv != 0) {\n\t\tCSIO_INC_STATS(hw, n_err_fatal);\n\t\tcsio_post_event(&hw->sm, CSIO_HWE_FATAL);\n\t\tgoto out;\n\t}\n\n\t \n\thw->chip_ver = (char)csio_rd_reg32(hw, PL_REV_A);\n\n\t \n\trv = csio_hw_get_flash_params(hw);\n\tif (rv != 0) {\n\t\tcsio_err(hw, \"Failed to get serial flash params rv:%d\\n\", rv);\n\t\tcsio_post_event(&hw->sm, CSIO_HWE_FATAL);\n\t\tgoto out;\n\t}\n\n\t \n\tif (pci_is_pcie(hw->pdev))\n\t\tpcie_capability_clear_and_set_word(hw->pdev, PCI_EXP_DEVCTL2,\n\t\t\t\tPCI_EXP_DEVCTL2_COMP_TIMEOUT, 0xd);\n\n\thw->chip_ops->chip_set_mem_win(hw, MEMWIN_CSIOSTOR);\n\n\trv = csio_hw_get_fw_version(hw, &hw->fwrev);\n\tif (rv != 0)\n\t\tgoto out;\n\n\tcsio_hw_print_fw_version(hw, \"Firmware revision\");\n\n\trv = csio_do_hello(hw, &hw->fw_state);\n\tif (rv != 0) {\n\t\tCSIO_INC_STATS(hw, n_err_fatal);\n\t\tcsio_post_event(&hw->sm, CSIO_HWE_FATAL);\n\t\tgoto out;\n\t}\n\n\t \n\trv = csio_hw_get_vpd_params(hw, &hw->vpd);\n\tif (rv != 0)\n\t\tgoto out;\n\n\tcsio_hw_get_fw_version(hw, &hw->fwrev);\n\tcsio_hw_get_tp_version(hw, &hw->tp_vers);\n\tif (csio_is_hw_master(hw) && hw->fw_state != CSIO_DEV_STATE_INIT) {\n\n\t\t\t \n\t\tspin_unlock_irq(&hw->lock);\n\t\trv = csio_hw_flash_fw(hw, &reset);\n\t\tspin_lock_irq(&hw->lock);\n\n\t\tif (rv != 0)\n\t\t\tgoto out;\n\n\t\trv = csio_hw_check_fwver(hw);\n\t\tif (rv < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\trv = csio_hw_check_fwconfig(hw, param);\n\t\tif (rv != 0) {\n\t\t\tcsio_info(hw, \"Firmware doesn't support \"\n\t\t\t\t  \"Firmware Configuration files\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\trv = csio_hw_use_fwconfig(hw, reset, param);\n\t\tif (rv == -ENOENT) {\n\t\t\tcsio_info(hw, \"Could not initialize \"\n\t\t\t\t  \"adapter, error%d\\n\", rv);\n\t\t\tgoto out;\n\t\t}\n\t\tif (rv != 0) {\n\t\t\tcsio_info(hw, \"Could not initialize \"\n\t\t\t\t  \"adapter, error%d\\n\", rv);\n\t\t\tgoto out;\n\t\t}\n\n\t} else {\n\t\trv = csio_hw_check_fwver(hw);\n\t\tif (rv < 0)\n\t\t\tgoto out;\n\n\t\tif (hw->fw_state == CSIO_DEV_STATE_INIT) {\n\n\t\t\thw->flags |= CSIO_HWF_USING_SOFT_PARAMS;\n\n\t\t\t \n\t\t\trv = csio_get_device_params(hw);\n\t\t\tif (rv != 0)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\trv = csio_config_device_caps(hw);\n\t\t\tif (rv != 0)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tcsio_wr_sge_init(hw);\n\n\t\t\t \n\t\t\tcsio_post_event(&hw->sm, CSIO_HWE_INIT);\n\t\t\tgoto out;\n\t\t}\n\t}  \n\nout:\n\treturn;\n}\n\n \nstatic void\ncsio_hw_initialize(struct csio_hw *hw)\n{\n\tstruct csio_mb\t*mbp;\n\tenum fw_retval retval;\n\tint rv;\n\tint i;\n\n\tif (csio_is_hw_master(hw) && hw->fw_state != CSIO_DEV_STATE_INIT) {\n\t\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\t\tif (!mbp)\n\t\t\tgoto out;\n\n\t\tcsio_mb_initialize(hw, mbp, CSIO_MB_DEFAULT_TMO, NULL);\n\n\t\tif (csio_mb_issue(hw, mbp)) {\n\t\t\tcsio_err(hw, \"Issue of FW_INITIALIZE_CMD failed!\\n\");\n\t\t\tgoto free_and_out;\n\t\t}\n\n\t\tretval = csio_mb_fw_retval(mbp);\n\t\tif (retval != FW_SUCCESS) {\n\t\t\tcsio_err(hw, \"FW_INITIALIZE_CMD returned 0x%x!\\n\",\n\t\t\t\t retval);\n\t\t\tgoto free_and_out;\n\t\t}\n\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t}\n\n\trv = csio_get_fcoe_resinfo(hw);\n\tif (rv != 0) {\n\t\tcsio_err(hw, \"Failed to read fcoe resource info: %d\\n\", rv);\n\t\tgoto out;\n\t}\n\n\tspin_unlock_irq(&hw->lock);\n\trv = csio_config_queues(hw);\n\tspin_lock_irq(&hw->lock);\n\n\tif (rv != 0) {\n\t\tcsio_err(hw, \"Config of queues failed!: %d\\n\", rv);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < hw->num_pports; i++)\n\t\thw->pport[i].mod_type = FW_PORT_MOD_TYPE_NA;\n\n\tif (csio_is_hw_master(hw) && hw->fw_state != CSIO_DEV_STATE_INIT) {\n\t\trv = csio_enable_ports(hw);\n\t\tif (rv != 0) {\n\t\t\tcsio_err(hw, \"Failed to enable ports: %d\\n\", rv);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcsio_post_event(&hw->sm, CSIO_HWE_INIT_DONE);\n\treturn;\n\nfree_and_out:\n\tmempool_free(mbp, hw->mb_mempool);\nout:\n\treturn;\n}\n\n#define PF_INTR_MASK (PFSW_F | PFCIM_F)\n\n \nstatic void\ncsio_hw_intr_enable(struct csio_hw *hw)\n{\n\tuint16_t vec = (uint16_t)csio_get_mb_intr_idx(csio_hw_to_mbm(hw));\n\tu32 pf = 0;\n\tuint32_t pl = csio_rd_reg32(hw, PL_INT_ENABLE_A);\n\n\tif (csio_is_t5(hw->pdev->device & CSIO_HW_CHIP_MASK))\n\t\tpf = SOURCEPF_G(csio_rd_reg32(hw, PL_WHOAMI_A));\n\telse\n\t\tpf = T6_SOURCEPF_G(csio_rd_reg32(hw, PL_WHOAMI_A));\n\n\t \n\tif (hw->intr_mode == CSIO_IM_MSIX)\n\t\tcsio_set_reg_field(hw, MYPF_REG(PCIE_PF_CFG_A),\n\t\t\t\t   AIVEC_V(AIVEC_M), vec);\n\telse if (hw->intr_mode == CSIO_IM_MSI)\n\t\tcsio_set_reg_field(hw, MYPF_REG(PCIE_PF_CFG_A),\n\t\t\t\t   AIVEC_V(AIVEC_M), 0);\n\n\tcsio_wr_reg32(hw, PF_INTR_MASK, MYPF_REG(PL_PF_INT_ENABLE_A));\n\n\t \n\tcsio_mb_intr_enable(hw);\n\n\t \n\tif (csio_is_hw_master(hw)) {\n\t\t \n\t\tpl &= (~SF_F);\n\t\tcsio_wr_reg32(hw, pl, PL_INT_ENABLE_A);\n\n\t\tcsio_wr_reg32(hw, ERR_CPL_EXCEED_IQE_SIZE_F |\n\t\t\t      EGRESS_SIZE_ERR_F | ERR_INVALID_CIDX_INC_F |\n\t\t\t      ERR_CPL_OPCODE_0_F | ERR_DROPPED_DB_F |\n\t\t\t      ERR_DATA_CPL_ON_HIGH_QID1_F |\n\t\t\t      ERR_DATA_CPL_ON_HIGH_QID0_F | ERR_BAD_DB_PIDX3_F |\n\t\t\t      ERR_BAD_DB_PIDX2_F | ERR_BAD_DB_PIDX1_F |\n\t\t\t      ERR_BAD_DB_PIDX0_F | ERR_ING_CTXT_PRIO_F |\n\t\t\t      ERR_EGR_CTXT_PRIO_F | INGRESS_SIZE_ERR_F,\n\t\t\t      SGE_INT_ENABLE3_A);\n\t\tcsio_set_reg_field(hw, PL_INT_MAP0_A, 0, 1 << pf);\n\t}\n\n\thw->flags |= CSIO_HWF_HW_INTR_ENABLED;\n\n}\n\n \nvoid\ncsio_hw_intr_disable(struct csio_hw *hw)\n{\n\tu32 pf = 0;\n\n\tif (csio_is_t5(hw->pdev->device & CSIO_HW_CHIP_MASK))\n\t\tpf = SOURCEPF_G(csio_rd_reg32(hw, PL_WHOAMI_A));\n\telse\n\t\tpf = T6_SOURCEPF_G(csio_rd_reg32(hw, PL_WHOAMI_A));\n\n\tif (!(hw->flags & CSIO_HWF_HW_INTR_ENABLED))\n\t\treturn;\n\n\thw->flags &= ~CSIO_HWF_HW_INTR_ENABLED;\n\n\tcsio_wr_reg32(hw, 0, MYPF_REG(PL_PF_INT_ENABLE_A));\n\tif (csio_is_hw_master(hw))\n\t\tcsio_set_reg_field(hw, PL_INT_MAP0_A, 1 << pf, 0);\n\n\t \n\tcsio_mb_intr_disable(hw);\n\n}\n\nvoid\ncsio_hw_fatal_err(struct csio_hw *hw)\n{\n\tcsio_set_reg_field(hw, SGE_CONTROL_A, GLOBALENABLE_F, 0);\n\tcsio_hw_intr_disable(hw);\n\n\t \n\tcsio_fatal(hw, \"HW Fatal error encountered!\\n\");\n}\n\n \n \n \n \nstatic void\ncsio_hws_uninit(struct csio_hw *hw, enum csio_hw_ev evt)\n{\n\thw->prev_evt = hw->cur_evt;\n\thw->cur_evt = evt;\n\tCSIO_INC_STATS(hw, n_evt_sm[evt]);\n\n\tswitch (evt) {\n\tcase CSIO_HWE_CFG:\n\t\tcsio_set_state(&hw->sm, csio_hws_configuring);\n\t\tcsio_hw_configure(hw);\n\t\tbreak;\n\n\tdefault:\n\t\tCSIO_INC_STATS(hw, n_evt_unexp);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\ncsio_hws_configuring(struct csio_hw *hw, enum csio_hw_ev evt)\n{\n\thw->prev_evt = hw->cur_evt;\n\thw->cur_evt = evt;\n\tCSIO_INC_STATS(hw, n_evt_sm[evt]);\n\n\tswitch (evt) {\n\tcase CSIO_HWE_INIT:\n\t\tcsio_set_state(&hw->sm, csio_hws_initializing);\n\t\tcsio_hw_initialize(hw);\n\t\tbreak;\n\n\tcase CSIO_HWE_INIT_DONE:\n\t\tcsio_set_state(&hw->sm, csio_hws_ready);\n\t\t \n\t\tcsio_notify_lnodes(hw, CSIO_LN_NOTIFY_HWREADY);\n\t\tbreak;\n\n\tcase CSIO_HWE_FATAL:\n\t\tcsio_set_state(&hw->sm, csio_hws_uninit);\n\t\tbreak;\n\n\tcase CSIO_HWE_PCI_REMOVE:\n\t\tcsio_do_bye(hw);\n\t\tbreak;\n\tdefault:\n\t\tCSIO_INC_STATS(hw, n_evt_unexp);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\ncsio_hws_initializing(struct csio_hw *hw, enum csio_hw_ev evt)\n{\n\thw->prev_evt = hw->cur_evt;\n\thw->cur_evt = evt;\n\tCSIO_INC_STATS(hw, n_evt_sm[evt]);\n\n\tswitch (evt) {\n\tcase CSIO_HWE_INIT_DONE:\n\t\tcsio_set_state(&hw->sm, csio_hws_ready);\n\n\t\t \n\t\tcsio_notify_lnodes(hw, CSIO_LN_NOTIFY_HWREADY);\n\n\t\t \n\t\tcsio_hw_intr_enable(hw);\n\t\tbreak;\n\n\tcase CSIO_HWE_FATAL:\n\t\tcsio_set_state(&hw->sm, csio_hws_uninit);\n\t\tbreak;\n\n\tcase CSIO_HWE_PCI_REMOVE:\n\t\tcsio_do_bye(hw);\n\t\tbreak;\n\n\tdefault:\n\t\tCSIO_INC_STATS(hw, n_evt_unexp);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\ncsio_hws_ready(struct csio_hw *hw, enum csio_hw_ev evt)\n{\n\t \n\thw->evtflag = evt;\n\n\thw->prev_evt = hw->cur_evt;\n\thw->cur_evt = evt;\n\tCSIO_INC_STATS(hw, n_evt_sm[evt]);\n\n\tswitch (evt) {\n\tcase CSIO_HWE_HBA_RESET:\n\tcase CSIO_HWE_FW_DLOAD:\n\tcase CSIO_HWE_SUSPEND:\n\tcase CSIO_HWE_PCI_REMOVE:\n\tcase CSIO_HWE_PCIERR_DETECTED:\n\t\tcsio_set_state(&hw->sm, csio_hws_quiescing);\n\t\t \n\t\tif (evt == CSIO_HWE_HBA_RESET ||\n\t\t    evt == CSIO_HWE_PCIERR_DETECTED)\n\t\t\tcsio_scsim_cleanup_io(csio_hw_to_scsim(hw), false);\n\t\telse\n\t\t\tcsio_scsim_cleanup_io(csio_hw_to_scsim(hw), true);\n\n\t\tcsio_hw_intr_disable(hw);\n\t\tcsio_hw_mbm_cleanup(hw);\n\t\tcsio_evtq_stop(hw);\n\t\tcsio_notify_lnodes(hw, CSIO_LN_NOTIFY_HWSTOP);\n\t\tcsio_evtq_flush(hw);\n\t\tcsio_mgmtm_cleanup(csio_hw_to_mgmtm(hw));\n\t\tcsio_post_event(&hw->sm, CSIO_HWE_QUIESCED);\n\t\tbreak;\n\n\tcase CSIO_HWE_FATAL:\n\t\tcsio_set_state(&hw->sm, csio_hws_uninit);\n\t\tbreak;\n\n\tdefault:\n\t\tCSIO_INC_STATS(hw, n_evt_unexp);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\ncsio_hws_quiescing(struct csio_hw *hw, enum csio_hw_ev evt)\n{\n\thw->prev_evt = hw->cur_evt;\n\thw->cur_evt = evt;\n\tCSIO_INC_STATS(hw, n_evt_sm[evt]);\n\n\tswitch (evt) {\n\tcase CSIO_HWE_QUIESCED:\n\t\tswitch (hw->evtflag) {\n\t\tcase CSIO_HWE_FW_DLOAD:\n\t\t\tcsio_set_state(&hw->sm, csio_hws_resetting);\n\t\t\t \n\t\t\tfallthrough;\n\n\t\tcase CSIO_HWE_HBA_RESET:\n\t\t\tcsio_set_state(&hw->sm, csio_hws_resetting);\n\t\t\t \n\t\t\tcsio_notify_lnodes(hw, CSIO_LN_NOTIFY_HWRESET);\n\t\t\tcsio_wr_destroy_queues(hw, false);\n\t\t\tcsio_do_reset(hw, false);\n\t\t\tcsio_post_event(&hw->sm, CSIO_HWE_HBA_RESET_DONE);\n\t\t\tbreak;\n\n\t\tcase CSIO_HWE_PCI_REMOVE:\n\t\t\tcsio_set_state(&hw->sm, csio_hws_removing);\n\t\t\tcsio_notify_lnodes(hw, CSIO_LN_NOTIFY_HWREMOVE);\n\t\t\tcsio_wr_destroy_queues(hw, true);\n\t\t\t \n\t\t\tcsio_do_bye(hw);\n\t\t\tbreak;\n\n\t\tcase CSIO_HWE_SUSPEND:\n\t\t\tcsio_set_state(&hw->sm, csio_hws_quiesced);\n\t\t\tbreak;\n\n\t\tcase CSIO_HWE_PCIERR_DETECTED:\n\t\t\tcsio_set_state(&hw->sm, csio_hws_pcierr);\n\t\t\tcsio_wr_destroy_queues(hw, false);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tCSIO_INC_STATS(hw, n_evt_unexp);\n\t\t\tbreak;\n\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tCSIO_INC_STATS(hw, n_evt_unexp);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\ncsio_hws_quiesced(struct csio_hw *hw, enum csio_hw_ev evt)\n{\n\thw->prev_evt = hw->cur_evt;\n\thw->cur_evt = evt;\n\tCSIO_INC_STATS(hw, n_evt_sm[evt]);\n\n\tswitch (evt) {\n\tcase CSIO_HWE_RESUME:\n\t\tcsio_set_state(&hw->sm, csio_hws_configuring);\n\t\tcsio_hw_configure(hw);\n\t\tbreak;\n\n\tdefault:\n\t\tCSIO_INC_STATS(hw, n_evt_unexp);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\ncsio_hws_resetting(struct csio_hw *hw, enum csio_hw_ev evt)\n{\n\thw->prev_evt = hw->cur_evt;\n\thw->cur_evt = evt;\n\tCSIO_INC_STATS(hw, n_evt_sm[evt]);\n\n\tswitch (evt) {\n\tcase CSIO_HWE_HBA_RESET_DONE:\n\t\tcsio_evtq_start(hw);\n\t\tcsio_set_state(&hw->sm, csio_hws_configuring);\n\t\tcsio_hw_configure(hw);\n\t\tbreak;\n\n\tdefault:\n\t\tCSIO_INC_STATS(hw, n_evt_unexp);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\ncsio_hws_removing(struct csio_hw *hw, enum csio_hw_ev evt)\n{\n\thw->prev_evt = hw->cur_evt;\n\thw->cur_evt = evt;\n\tCSIO_INC_STATS(hw, n_evt_sm[evt]);\n\n\tswitch (evt) {\n\tcase CSIO_HWE_HBA_RESET:\n\t\tif (!csio_is_hw_master(hw))\n\t\t\tbreak;\n\t\t \n\t\tcsio_err(hw, \"Resetting HW and waiting 2 seconds...\\n\");\n\t\tcsio_wr_reg32(hw, PIORSTMODE_F | PIORST_F, PL_RST_A);\n\t\tmdelay(2000);\n\t\tbreak;\n\n\t \n\tdefault:\n\t\tCSIO_INC_STATS(hw, n_evt_unexp);\n\t\tbreak;\n\n\t}\n}\n\n \nstatic void\ncsio_hws_pcierr(struct csio_hw *hw, enum csio_hw_ev evt)\n{\n\thw->prev_evt = hw->cur_evt;\n\thw->cur_evt = evt;\n\tCSIO_INC_STATS(hw, n_evt_sm[evt]);\n\n\tswitch (evt) {\n\tcase CSIO_HWE_PCIERR_SLOT_RESET:\n\t\tcsio_evtq_start(hw);\n\t\tcsio_set_state(&hw->sm, csio_hws_configuring);\n\t\tcsio_hw_configure(hw);\n\t\tbreak;\n\n\tdefault:\n\t\tCSIO_INC_STATS(hw, n_evt_unexp);\n\t\tbreak;\n\t}\n}\n\n \n \n \n\n \nint\ncsio_handle_intr_status(struct csio_hw *hw, unsigned int reg,\n\t\t\t\t const struct intr_info *acts)\n{\n\tint fatal = 0;\n\tunsigned int mask = 0;\n\tunsigned int status = csio_rd_reg32(hw, reg);\n\n\tfor ( ; acts->mask; ++acts) {\n\t\tif (!(status & acts->mask))\n\t\t\tcontinue;\n\t\tif (acts->fatal) {\n\t\t\tfatal++;\n\t\t\tcsio_fatal(hw, \"Fatal %s (0x%x)\\n\",\n\t\t\t\t    acts->msg, status & acts->mask);\n\t\t} else if (acts->msg)\n\t\t\tcsio_info(hw, \"%s (0x%x)\\n\",\n\t\t\t\t    acts->msg, status & acts->mask);\n\t\tmask |= acts->mask;\n\t}\n\tstatus &= mask;\n\tif (status)                            \n\t\tcsio_wr_reg32(hw, status, reg);\n\treturn fatal;\n}\n\n \nstatic void csio_tp_intr_handler(struct csio_hw *hw)\n{\n\tstatic struct intr_info tp_intr_info[] = {\n\t\t{ 0x3fffffff, \"TP parity error\", -1, 1 },\n\t\t{ FLMTXFLSTEMPTY_F, \"TP out of Tx pages\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\n\tif (csio_handle_intr_status(hw, TP_INT_CAUSE_A, tp_intr_info))\n\t\tcsio_hw_fatal_err(hw);\n}\n\n \nstatic void csio_sge_intr_handler(struct csio_hw *hw)\n{\n\tuint64_t v;\n\n\tstatic struct intr_info sge_intr_info[] = {\n\t\t{ ERR_CPL_EXCEED_IQE_SIZE_F,\n\t\t  \"SGE received CPL exceeding IQE size\", -1, 1 },\n\t\t{ ERR_INVALID_CIDX_INC_F,\n\t\t  \"SGE GTS CIDX increment too large\", -1, 0 },\n\t\t{ ERR_CPL_OPCODE_0_F, \"SGE received 0-length CPL\", -1, 0 },\n\t\t{ ERR_DROPPED_DB_F, \"SGE doorbell dropped\", -1, 0 },\n\t\t{ ERR_DATA_CPL_ON_HIGH_QID1_F | ERR_DATA_CPL_ON_HIGH_QID0_F,\n\t\t  \"SGE IQID > 1023 received CPL for FL\", -1, 0 },\n\t\t{ ERR_BAD_DB_PIDX3_F, \"SGE DBP 3 pidx increment too large\", -1,\n\t\t  0 },\n\t\t{ ERR_BAD_DB_PIDX2_F, \"SGE DBP 2 pidx increment too large\", -1,\n\t\t  0 },\n\t\t{ ERR_BAD_DB_PIDX1_F, \"SGE DBP 1 pidx increment too large\", -1,\n\t\t  0 },\n\t\t{ ERR_BAD_DB_PIDX0_F, \"SGE DBP 0 pidx increment too large\", -1,\n\t\t  0 },\n\t\t{ ERR_ING_CTXT_PRIO_F,\n\t\t  \"SGE too many priority ingress contexts\", -1, 0 },\n\t\t{ ERR_EGR_CTXT_PRIO_F,\n\t\t  \"SGE too many priority egress contexts\", -1, 0 },\n\t\t{ INGRESS_SIZE_ERR_F, \"SGE illegal ingress QID\", -1, 0 },\n\t\t{ EGRESS_SIZE_ERR_F, \"SGE illegal egress QID\", -1, 0 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\n\tv = (uint64_t)csio_rd_reg32(hw, SGE_INT_CAUSE1_A) |\n\t    ((uint64_t)csio_rd_reg32(hw, SGE_INT_CAUSE2_A) << 32);\n\tif (v) {\n\t\tcsio_fatal(hw, \"SGE parity error (%#llx)\\n\",\n\t\t\t    (unsigned long long)v);\n\t\tcsio_wr_reg32(hw, (uint32_t)(v & 0xFFFFFFFF),\n\t\t\t\t\t\tSGE_INT_CAUSE1_A);\n\t\tcsio_wr_reg32(hw, (uint32_t)(v >> 32), SGE_INT_CAUSE2_A);\n\t}\n\n\tv |= csio_handle_intr_status(hw, SGE_INT_CAUSE3_A, sge_intr_info);\n\n\tif (csio_handle_intr_status(hw, SGE_INT_CAUSE3_A, sge_intr_info) ||\n\t    v != 0)\n\t\tcsio_hw_fatal_err(hw);\n}\n\n#define CIM_OBQ_INTR (OBQULP0PARERR_F | OBQULP1PARERR_F | OBQULP2PARERR_F |\\\n\t\t      OBQULP3PARERR_F | OBQSGEPARERR_F | OBQNCSIPARERR_F)\n#define CIM_IBQ_INTR (IBQTP0PARERR_F | IBQTP1PARERR_F | IBQULPPARERR_F |\\\n\t\t      IBQSGEHIPARERR_F | IBQSGELOPARERR_F | IBQNCSIPARERR_F)\n\n \nstatic void csio_cim_intr_handler(struct csio_hw *hw)\n{\n\tstatic struct intr_info cim_intr_info[] = {\n\t\t{ PREFDROPINT_F, \"CIM control register prefetch drop\", -1, 1 },\n\t\t{ CIM_OBQ_INTR, \"CIM OBQ parity error\", -1, 1 },\n\t\t{ CIM_IBQ_INTR, \"CIM IBQ parity error\", -1, 1 },\n\t\t{ MBUPPARERR_F, \"CIM mailbox uP parity error\", -1, 1 },\n\t\t{ MBHOSTPARERR_F, \"CIM mailbox host parity error\", -1, 1 },\n\t\t{ TIEQINPARERRINT_F, \"CIM TIEQ outgoing parity error\", -1, 1 },\n\t\t{ TIEQOUTPARERRINT_F, \"CIM TIEQ incoming parity error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\tstatic struct intr_info cim_upintr_info[] = {\n\t\t{ RSVDSPACEINT_F, \"CIM reserved space access\", -1, 1 },\n\t\t{ ILLTRANSINT_F, \"CIM illegal transaction\", -1, 1 },\n\t\t{ ILLWRINT_F, \"CIM illegal write\", -1, 1 },\n\t\t{ ILLRDINT_F, \"CIM illegal read\", -1, 1 },\n\t\t{ ILLRDBEINT_F, \"CIM illegal read BE\", -1, 1 },\n\t\t{ ILLWRBEINT_F, \"CIM illegal write BE\", -1, 1 },\n\t\t{ SGLRDBOOTINT_F, \"CIM single read from boot space\", -1, 1 },\n\t\t{ SGLWRBOOTINT_F, \"CIM single write to boot space\", -1, 1 },\n\t\t{ BLKWRBOOTINT_F, \"CIM block write to boot space\", -1, 1 },\n\t\t{ SGLRDFLASHINT_F, \"CIM single read from flash space\", -1, 1 },\n\t\t{ SGLWRFLASHINT_F, \"CIM single write to flash space\", -1, 1 },\n\t\t{ BLKWRFLASHINT_F, \"CIM block write to flash space\", -1, 1 },\n\t\t{ SGLRDEEPROMINT_F, \"CIM single EEPROM read\", -1, 1 },\n\t\t{ SGLWREEPROMINT_F, \"CIM single EEPROM write\", -1, 1 },\n\t\t{ BLKRDEEPROMINT_F, \"CIM block EEPROM read\", -1, 1 },\n\t\t{ BLKWREEPROMINT_F, \"CIM block EEPROM write\", -1, 1 },\n\t\t{ SGLRDCTLINT_F, \"CIM single read from CTL space\", -1, 1 },\n\t\t{ SGLWRCTLINT_F, \"CIM single write to CTL space\", -1, 1 },\n\t\t{ BLKRDCTLINT_F, \"CIM block read from CTL space\", -1, 1 },\n\t\t{ BLKWRCTLINT_F, \"CIM block write to CTL space\", -1, 1 },\n\t\t{ SGLRDPLINT_F, \"CIM single read from PL space\", -1, 1 },\n\t\t{ SGLWRPLINT_F, \"CIM single write to PL space\", -1, 1 },\n\t\t{ BLKRDPLINT_F, \"CIM block read from PL space\", -1, 1 },\n\t\t{ BLKWRPLINT_F, \"CIM block write to PL space\", -1, 1 },\n\t\t{ REQOVRLOOKUPINT_F, \"CIM request FIFO overwrite\", -1, 1 },\n\t\t{ RSPOVRLOOKUPINT_F, \"CIM response FIFO overwrite\", -1, 1 },\n\t\t{ TIMEOUTINT_F, \"CIM PIF timeout\", -1, 1 },\n\t\t{ TIMEOUTMAINT_F, \"CIM PIF MA timeout\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\n\tint fat;\n\n\tfat = csio_handle_intr_status(hw, CIM_HOST_INT_CAUSE_A,\n\t\t\t\t      cim_intr_info) +\n\t      csio_handle_intr_status(hw, CIM_HOST_UPACC_INT_CAUSE_A,\n\t\t\t\t      cim_upintr_info);\n\tif (fat)\n\t\tcsio_hw_fatal_err(hw);\n}\n\n \nstatic void csio_ulprx_intr_handler(struct csio_hw *hw)\n{\n\tstatic struct intr_info ulprx_intr_info[] = {\n\t\t{ 0x1800000, \"ULPRX context error\", -1, 1 },\n\t\t{ 0x7fffff, \"ULPRX parity error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\n\tif (csio_handle_intr_status(hw, ULP_RX_INT_CAUSE_A, ulprx_intr_info))\n\t\tcsio_hw_fatal_err(hw);\n}\n\n \nstatic void csio_ulptx_intr_handler(struct csio_hw *hw)\n{\n\tstatic struct intr_info ulptx_intr_info[] = {\n\t\t{ PBL_BOUND_ERR_CH3_F, \"ULPTX channel 3 PBL out of bounds\", -1,\n\t\t  0 },\n\t\t{ PBL_BOUND_ERR_CH2_F, \"ULPTX channel 2 PBL out of bounds\", -1,\n\t\t  0 },\n\t\t{ PBL_BOUND_ERR_CH1_F, \"ULPTX channel 1 PBL out of bounds\", -1,\n\t\t  0 },\n\t\t{ PBL_BOUND_ERR_CH0_F, \"ULPTX channel 0 PBL out of bounds\", -1,\n\t\t  0 },\n\t\t{ 0xfffffff, \"ULPTX parity error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\n\tif (csio_handle_intr_status(hw, ULP_TX_INT_CAUSE_A, ulptx_intr_info))\n\t\tcsio_hw_fatal_err(hw);\n}\n\n \nstatic void csio_pmtx_intr_handler(struct csio_hw *hw)\n{\n\tstatic struct intr_info pmtx_intr_info[] = {\n\t\t{ PCMD_LEN_OVFL0_F, \"PMTX channel 0 pcmd too large\", -1, 1 },\n\t\t{ PCMD_LEN_OVFL1_F, \"PMTX channel 1 pcmd too large\", -1, 1 },\n\t\t{ PCMD_LEN_OVFL2_F, \"PMTX channel 2 pcmd too large\", -1, 1 },\n\t\t{ ZERO_C_CMD_ERROR_F, \"PMTX 0-length pcmd\", -1, 1 },\n\t\t{ 0xffffff0, \"PMTX framing error\", -1, 1 },\n\t\t{ OESPI_PAR_ERROR_F, \"PMTX oespi parity error\", -1, 1 },\n\t\t{ DB_OPTIONS_PAR_ERROR_F, \"PMTX db_options parity error\", -1,\n\t\t  1 },\n\t\t{ ICSPI_PAR_ERROR_F, \"PMTX icspi parity error\", -1, 1 },\n\t\t{ PMTX_C_PCMD_PAR_ERROR_F, \"PMTX c_pcmd parity error\", -1, 1},\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\n\tif (csio_handle_intr_status(hw, PM_TX_INT_CAUSE_A, pmtx_intr_info))\n\t\tcsio_hw_fatal_err(hw);\n}\n\n \nstatic void csio_pmrx_intr_handler(struct csio_hw *hw)\n{\n\tstatic struct intr_info pmrx_intr_info[] = {\n\t\t{ ZERO_E_CMD_ERROR_F, \"PMRX 0-length pcmd\", -1, 1 },\n\t\t{ 0x3ffff0, \"PMRX framing error\", -1, 1 },\n\t\t{ OCSPI_PAR_ERROR_F, \"PMRX ocspi parity error\", -1, 1 },\n\t\t{ DB_OPTIONS_PAR_ERROR_F, \"PMRX db_options parity error\", -1,\n\t\t  1 },\n\t\t{ IESPI_PAR_ERROR_F, \"PMRX iespi parity error\", -1, 1 },\n\t\t{ PMRX_E_PCMD_PAR_ERROR_F, \"PMRX e_pcmd parity error\", -1, 1},\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\n\tif (csio_handle_intr_status(hw, PM_RX_INT_CAUSE_A, pmrx_intr_info))\n\t\tcsio_hw_fatal_err(hw);\n}\n\n \nstatic void csio_cplsw_intr_handler(struct csio_hw *hw)\n{\n\tstatic struct intr_info cplsw_intr_info[] = {\n\t\t{ CIM_OP_MAP_PERR_F, \"CPLSW CIM op_map parity error\", -1, 1 },\n\t\t{ CIM_OVFL_ERROR_F, \"CPLSW CIM overflow\", -1, 1 },\n\t\t{ TP_FRAMING_ERROR_F, \"CPLSW TP framing error\", -1, 1 },\n\t\t{ SGE_FRAMING_ERROR_F, \"CPLSW SGE framing error\", -1, 1 },\n\t\t{ CIM_FRAMING_ERROR_F, \"CPLSW CIM framing error\", -1, 1 },\n\t\t{ ZERO_SWITCH_ERROR_F, \"CPLSW no-switch error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\n\tif (csio_handle_intr_status(hw, CPL_INTR_CAUSE_A, cplsw_intr_info))\n\t\tcsio_hw_fatal_err(hw);\n}\n\n \nstatic void csio_le_intr_handler(struct csio_hw *hw)\n{\n\tenum chip_type chip = CHELSIO_CHIP_VERSION(hw->chip_id);\n\n\tstatic struct intr_info le_intr_info[] = {\n\t\t{ LIPMISS_F, \"LE LIP miss\", -1, 0 },\n\t\t{ LIP0_F, \"LE 0 LIP error\", -1, 0 },\n\t\t{ PARITYERR_F, \"LE parity error\", -1, 1 },\n\t\t{ UNKNOWNCMD_F, \"LE unknown command\", -1, 1 },\n\t\t{ REQQPARERR_F, \"LE request queue parity error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\n\tstatic struct intr_info t6_le_intr_info[] = {\n\t\t{ T6_LIPMISS_F, \"LE LIP miss\", -1, 0 },\n\t\t{ T6_LIP0_F, \"LE 0 LIP error\", -1, 0 },\n\t\t{ TCAMINTPERR_F, \"LE parity error\", -1, 1 },\n\t\t{ T6_UNKNOWNCMD_F, \"LE unknown command\", -1, 1 },\n\t\t{ SSRAMINTPERR_F, \"LE request queue parity error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\n\tif (csio_handle_intr_status(hw, LE_DB_INT_CAUSE_A,\n\t\t\t\t    (chip == CHELSIO_T5) ?\n\t\t\t\t    le_intr_info : t6_le_intr_info))\n\t\tcsio_hw_fatal_err(hw);\n}\n\n \nstatic void csio_mps_intr_handler(struct csio_hw *hw)\n{\n\tstatic struct intr_info mps_rx_intr_info[] = {\n\t\t{ 0xffffff, \"MPS Rx parity error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\tstatic struct intr_info mps_tx_intr_info[] = {\n\t\t{ TPFIFO_V(TPFIFO_M), \"MPS Tx TP FIFO parity error\", -1, 1 },\n\t\t{ NCSIFIFO_F, \"MPS Tx NC-SI FIFO parity error\", -1, 1 },\n\t\t{ TXDATAFIFO_V(TXDATAFIFO_M), \"MPS Tx data FIFO parity error\",\n\t\t  -1, 1 },\n\t\t{ TXDESCFIFO_V(TXDESCFIFO_M), \"MPS Tx desc FIFO parity error\",\n\t\t  -1, 1 },\n\t\t{ BUBBLE_F, \"MPS Tx underflow\", -1, 1 },\n\t\t{ SECNTERR_F, \"MPS Tx SOP/EOP error\", -1, 1 },\n\t\t{ FRMERR_F, \"MPS Tx framing error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\tstatic struct intr_info mps_trc_intr_info[] = {\n\t\t{ FILTMEM_V(FILTMEM_M), \"MPS TRC filter parity error\", -1, 1 },\n\t\t{ PKTFIFO_V(PKTFIFO_M), \"MPS TRC packet FIFO parity error\",\n\t\t  -1, 1 },\n\t\t{ MISCPERR_F, \"MPS TRC misc parity error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\tstatic struct intr_info mps_stat_sram_intr_info[] = {\n\t\t{ 0x1fffff, \"MPS statistics SRAM parity error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\tstatic struct intr_info mps_stat_tx_intr_info[] = {\n\t\t{ 0xfffff, \"MPS statistics Tx FIFO parity error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\tstatic struct intr_info mps_stat_rx_intr_info[] = {\n\t\t{ 0xffffff, \"MPS statistics Rx FIFO parity error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\tstatic struct intr_info mps_cls_intr_info[] = {\n\t\t{ MATCHSRAM_F, \"MPS match SRAM parity error\", -1, 1 },\n\t\t{ MATCHTCAM_F, \"MPS match TCAM parity error\", -1, 1 },\n\t\t{ HASHSRAM_F, \"MPS hash SRAM parity error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\n\tint fat;\n\n\tfat = csio_handle_intr_status(hw, MPS_RX_PERR_INT_CAUSE_A,\n\t\t\t\t      mps_rx_intr_info) +\n\t      csio_handle_intr_status(hw, MPS_TX_INT_CAUSE_A,\n\t\t\t\t      mps_tx_intr_info) +\n\t      csio_handle_intr_status(hw, MPS_TRC_INT_CAUSE_A,\n\t\t\t\t      mps_trc_intr_info) +\n\t      csio_handle_intr_status(hw, MPS_STAT_PERR_INT_CAUSE_SRAM_A,\n\t\t\t\t      mps_stat_sram_intr_info) +\n\t      csio_handle_intr_status(hw, MPS_STAT_PERR_INT_CAUSE_TX_FIFO_A,\n\t\t\t\t      mps_stat_tx_intr_info) +\n\t      csio_handle_intr_status(hw, MPS_STAT_PERR_INT_CAUSE_RX_FIFO_A,\n\t\t\t\t      mps_stat_rx_intr_info) +\n\t      csio_handle_intr_status(hw, MPS_CLS_INT_CAUSE_A,\n\t\t\t\t      mps_cls_intr_info);\n\n\tcsio_wr_reg32(hw, 0, MPS_INT_CAUSE_A);\n\tcsio_rd_reg32(hw, MPS_INT_CAUSE_A);                     \n\tif (fat)\n\t\tcsio_hw_fatal_err(hw);\n}\n\n#define MEM_INT_MASK (PERR_INT_CAUSE_F | ECC_CE_INT_CAUSE_F | \\\n\t\t      ECC_UE_INT_CAUSE_F)\n\n \nstatic void csio_mem_intr_handler(struct csio_hw *hw, int idx)\n{\n\tstatic const char name[3][5] = { \"EDC0\", \"EDC1\", \"MC\" };\n\n\tunsigned int addr, cnt_addr, v;\n\n\tif (idx <= MEM_EDC1) {\n\t\taddr = EDC_REG(EDC_INT_CAUSE_A, idx);\n\t\tcnt_addr = EDC_REG(EDC_ECC_STATUS_A, idx);\n\t} else {\n\t\taddr = MC_INT_CAUSE_A;\n\t\tcnt_addr = MC_ECC_STATUS_A;\n\t}\n\n\tv = csio_rd_reg32(hw, addr) & MEM_INT_MASK;\n\tif (v & PERR_INT_CAUSE_F)\n\t\tcsio_fatal(hw, \"%s FIFO parity error\\n\", name[idx]);\n\tif (v & ECC_CE_INT_CAUSE_F) {\n\t\tuint32_t cnt = ECC_CECNT_G(csio_rd_reg32(hw, cnt_addr));\n\n\t\tcsio_wr_reg32(hw, ECC_CECNT_V(ECC_CECNT_M), cnt_addr);\n\t\tcsio_warn(hw, \"%u %s correctable ECC data error%s\\n\",\n\t\t\t    cnt, name[idx], cnt > 1 ? \"s\" : \"\");\n\t}\n\tif (v & ECC_UE_INT_CAUSE_F)\n\t\tcsio_fatal(hw, \"%s uncorrectable ECC data error\\n\", name[idx]);\n\n\tcsio_wr_reg32(hw, v, addr);\n\tif (v & (PERR_INT_CAUSE_F | ECC_UE_INT_CAUSE_F))\n\t\tcsio_hw_fatal_err(hw);\n}\n\n \nstatic void csio_ma_intr_handler(struct csio_hw *hw)\n{\n\tuint32_t v, status = csio_rd_reg32(hw, MA_INT_CAUSE_A);\n\n\tif (status & MEM_PERR_INT_CAUSE_F)\n\t\tcsio_fatal(hw, \"MA parity error, parity status %#x\\n\",\n\t\t\t    csio_rd_reg32(hw, MA_PARITY_ERROR_STATUS_A));\n\tif (status & MEM_WRAP_INT_CAUSE_F) {\n\t\tv = csio_rd_reg32(hw, MA_INT_WRAP_STATUS_A);\n\t\tcsio_fatal(hw,\n\t\t   \"MA address wrap-around error by client %u to address %#x\\n\",\n\t\t   MEM_WRAP_CLIENT_NUM_G(v), MEM_WRAP_ADDRESS_G(v) << 4);\n\t}\n\tcsio_wr_reg32(hw, status, MA_INT_CAUSE_A);\n\tcsio_hw_fatal_err(hw);\n}\n\n \nstatic void csio_smb_intr_handler(struct csio_hw *hw)\n{\n\tstatic struct intr_info smb_intr_info[] = {\n\t\t{ MSTTXFIFOPARINT_F, \"SMB master Tx FIFO parity error\", -1, 1 },\n\t\t{ MSTRXFIFOPARINT_F, \"SMB master Rx FIFO parity error\", -1, 1 },\n\t\t{ SLVFIFOPARINT_F, \"SMB slave FIFO parity error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\n\tif (csio_handle_intr_status(hw, SMB_INT_CAUSE_A, smb_intr_info))\n\t\tcsio_hw_fatal_err(hw);\n}\n\n \nstatic void csio_ncsi_intr_handler(struct csio_hw *hw)\n{\n\tstatic struct intr_info ncsi_intr_info[] = {\n\t\t{ CIM_DM_PRTY_ERR_F, \"NC-SI CIM parity error\", -1, 1 },\n\t\t{ MPS_DM_PRTY_ERR_F, \"NC-SI MPS parity error\", -1, 1 },\n\t\t{ TXFIFO_PRTY_ERR_F, \"NC-SI Tx FIFO parity error\", -1, 1 },\n\t\t{ RXFIFO_PRTY_ERR_F, \"NC-SI Rx FIFO parity error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\n\tif (csio_handle_intr_status(hw, NCSI_INT_CAUSE_A, ncsi_intr_info))\n\t\tcsio_hw_fatal_err(hw);\n}\n\n \nstatic void csio_xgmac_intr_handler(struct csio_hw *hw, int port)\n{\n\tuint32_t v = csio_rd_reg32(hw, T5_PORT_REG(port, MAC_PORT_INT_CAUSE_A));\n\n\tv &= TXFIFO_PRTY_ERR_F | RXFIFO_PRTY_ERR_F;\n\tif (!v)\n\t\treturn;\n\n\tif (v & TXFIFO_PRTY_ERR_F)\n\t\tcsio_fatal(hw, \"XGMAC %d Tx FIFO parity error\\n\", port);\n\tif (v & RXFIFO_PRTY_ERR_F)\n\t\tcsio_fatal(hw, \"XGMAC %d Rx FIFO parity error\\n\", port);\n\tcsio_wr_reg32(hw, v, T5_PORT_REG(port, MAC_PORT_INT_CAUSE_A));\n\tcsio_hw_fatal_err(hw);\n}\n\n \nstatic void csio_pl_intr_handler(struct csio_hw *hw)\n{\n\tstatic struct intr_info pl_intr_info[] = {\n\t\t{ FATALPERR_F, \"T4 fatal parity error\", -1, 1 },\n\t\t{ PERRVFID_F, \"PL VFID_MAP parity error\", -1, 1 },\n\t\t{ 0, NULL, 0, 0 }\n\t};\n\n\tif (csio_handle_intr_status(hw, PL_PL_INT_CAUSE_A, pl_intr_info))\n\t\tcsio_hw_fatal_err(hw);\n}\n\n \nint\ncsio_hw_slow_intr_handler(struct csio_hw *hw)\n{\n\tuint32_t cause = csio_rd_reg32(hw, PL_INT_CAUSE_A);\n\n\tif (!(cause & CSIO_GLBL_INTR_MASK)) {\n\t\tCSIO_INC_STATS(hw, n_plint_unexp);\n\t\treturn 0;\n\t}\n\n\tcsio_dbg(hw, \"Slow interrupt! cause: 0x%x\\n\", cause);\n\n\tCSIO_INC_STATS(hw, n_plint_cnt);\n\n\tif (cause & CIM_F)\n\t\tcsio_cim_intr_handler(hw);\n\n\tif (cause & MPS_F)\n\t\tcsio_mps_intr_handler(hw);\n\n\tif (cause & NCSI_F)\n\t\tcsio_ncsi_intr_handler(hw);\n\n\tif (cause & PL_F)\n\t\tcsio_pl_intr_handler(hw);\n\n\tif (cause & SMB_F)\n\t\tcsio_smb_intr_handler(hw);\n\n\tif (cause & XGMAC0_F)\n\t\tcsio_xgmac_intr_handler(hw, 0);\n\n\tif (cause & XGMAC1_F)\n\t\tcsio_xgmac_intr_handler(hw, 1);\n\n\tif (cause & XGMAC_KR0_F)\n\t\tcsio_xgmac_intr_handler(hw, 2);\n\n\tif (cause & XGMAC_KR1_F)\n\t\tcsio_xgmac_intr_handler(hw, 3);\n\n\tif (cause & PCIE_F)\n\t\thw->chip_ops->chip_pcie_intr_handler(hw);\n\n\tif (cause & MC_F)\n\t\tcsio_mem_intr_handler(hw, MEM_MC);\n\n\tif (cause & EDC0_F)\n\t\tcsio_mem_intr_handler(hw, MEM_EDC0);\n\n\tif (cause & EDC1_F)\n\t\tcsio_mem_intr_handler(hw, MEM_EDC1);\n\n\tif (cause & LE_F)\n\t\tcsio_le_intr_handler(hw);\n\n\tif (cause & TP_F)\n\t\tcsio_tp_intr_handler(hw);\n\n\tif (cause & MA_F)\n\t\tcsio_ma_intr_handler(hw);\n\n\tif (cause & PM_TX_F)\n\t\tcsio_pmtx_intr_handler(hw);\n\n\tif (cause & PM_RX_F)\n\t\tcsio_pmrx_intr_handler(hw);\n\n\tif (cause & ULP_RX_F)\n\t\tcsio_ulprx_intr_handler(hw);\n\n\tif (cause & CPL_SWITCH_F)\n\t\tcsio_cplsw_intr_handler(hw);\n\n\tif (cause & SGE_F)\n\t\tcsio_sge_intr_handler(hw);\n\n\tif (cause & ULP_TX_F)\n\t\tcsio_ulptx_intr_handler(hw);\n\n\t \n\tcsio_wr_reg32(hw, cause & CSIO_GLBL_INTR_MASK, PL_INT_CAUSE_A);\n\tcsio_rd_reg32(hw, PL_INT_CAUSE_A);  \n\n\treturn 1;\n}\n\n \n \nstatic void\ncsio_mberr_worker(void *data)\n{\n\tstruct csio_hw *hw = (struct csio_hw *)data;\n\tstruct csio_mbm *mbm = &hw->mbm;\n\tLIST_HEAD(cbfn_q);\n\tstruct csio_mb *mbp_next;\n\tint rv;\n\n\tdel_timer_sync(&mbm->timer);\n\n\tspin_lock_irq(&hw->lock);\n\tif (list_empty(&mbm->cbfn_q)) {\n\t\tspin_unlock_irq(&hw->lock);\n\t\treturn;\n\t}\n\n\tlist_splice_tail_init(&mbm->cbfn_q, &cbfn_q);\n\tmbm->stats.n_cbfnq = 0;\n\n\t \n\tif (!list_empty(&mbm->req_q)) {\n\t\tmbp_next = list_first_entry(&mbm->req_q, struct csio_mb, list);\n\t\tlist_del_init(&mbp_next->list);\n\n\t\trv = csio_mb_issue(hw, mbp_next);\n\t\tif (rv != 0)\n\t\t\tlist_add_tail(&mbp_next->list, &mbm->req_q);\n\t\telse\n\t\t\tCSIO_DEC_STATS(mbm, n_activeq);\n\t}\n\tspin_unlock_irq(&hw->lock);\n\n\t \n\tcsio_mb_completions(hw, &cbfn_q);\n}\n\n \nstatic void\ncsio_hw_mb_timer(struct timer_list *t)\n{\n\tstruct csio_mbm *mbm = from_timer(mbm, t, timer);\n\tstruct csio_hw *hw = mbm->hw;\n\tstruct csio_mb *mbp = NULL;\n\n\tspin_lock_irq(&hw->lock);\n\tmbp = csio_mb_tmo_handler(hw);\n\tspin_unlock_irq(&hw->lock);\n\n\t \n\tif (mbp)\n\t\tmbp->mb_cbfn(hw, mbp);\n\n}\n\n \nstatic void\ncsio_hw_mbm_cleanup(struct csio_hw *hw)\n{\n\tLIST_HEAD(cbfn_q);\n\n\tcsio_mb_cancel_all(hw, &cbfn_q);\n\n\tspin_unlock_irq(&hw->lock);\n\tcsio_mb_completions(hw, &cbfn_q);\n\tspin_lock_irq(&hw->lock);\n}\n\n \nint\ncsio_enqueue_evt(struct csio_hw *hw, enum csio_evt type, void *evt_msg,\n\t\t\tuint16_t len)\n{\n\tstruct csio_evt_msg *evt_entry = NULL;\n\n\tif (type >= CSIO_EVT_MAX)\n\t\treturn -EINVAL;\n\n\tif (len > CSIO_EVT_MSG_SIZE)\n\t\treturn -EINVAL;\n\n\tif (hw->flags & CSIO_HWF_FWEVT_STOP)\n\t\treturn -EINVAL;\n\n\tif (list_empty(&hw->evt_free_q)) {\n\t\tcsio_err(hw, \"Failed to alloc evt entry, msg type %d len %d\\n\",\n\t\t\t type, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tevt_entry = list_first_entry(&hw->evt_free_q,\n\t\t\t\t     struct csio_evt_msg, list);\n\tlist_del_init(&evt_entry->list);\n\n\t \n\tevt_entry->type = type;\n\tmemcpy((void *)evt_entry->data, evt_msg, len);\n\tlist_add_tail(&evt_entry->list, &hw->evt_active_q);\n\n\tCSIO_DEC_STATS(hw, n_evt_freeq);\n\tCSIO_INC_STATS(hw, n_evt_activeq);\n\n\treturn 0;\n}\n\nstatic int\ncsio_enqueue_evt_lock(struct csio_hw *hw, enum csio_evt type, void *evt_msg,\n\t\t\tuint16_t len, bool msg_sg)\n{\n\tstruct csio_evt_msg *evt_entry = NULL;\n\tstruct csio_fl_dma_buf *fl_sg;\n\tuint32_t off = 0;\n\tunsigned long flags;\n\tint n, ret = 0;\n\n\tif (type >= CSIO_EVT_MAX)\n\t\treturn -EINVAL;\n\n\tif (len > CSIO_EVT_MSG_SIZE)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\tif (hw->flags & CSIO_HWF_FWEVT_STOP) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (list_empty(&hw->evt_free_q)) {\n\t\tcsio_err(hw, \"Failed to alloc evt entry, msg type %d len %d\\n\",\n\t\t\t type, len);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tevt_entry = list_first_entry(&hw->evt_free_q,\n\t\t\t\t     struct csio_evt_msg, list);\n\tlist_del_init(&evt_entry->list);\n\n\t \n\tevt_entry->type = type;\n\n\t \n\tif (msg_sg) {\n\t\tfl_sg = (struct csio_fl_dma_buf *) evt_msg;\n\t\tfor (n = 0; (n < CSIO_MAX_FLBUF_PER_IQWR && off < len); n++) {\n\t\t\tmemcpy((void *)((uintptr_t)evt_entry->data + off),\n\t\t\t\tfl_sg->flbufs[n].vaddr,\n\t\t\t\tfl_sg->flbufs[n].len);\n\t\t\toff += fl_sg->flbufs[n].len;\n\t\t}\n\t} else\n\t\tmemcpy((void *)evt_entry->data, evt_msg, len);\n\n\tlist_add_tail(&evt_entry->list, &hw->evt_active_q);\n\tCSIO_DEC_STATS(hw, n_evt_freeq);\n\tCSIO_INC_STATS(hw, n_evt_activeq);\nout:\n\tspin_unlock_irqrestore(&hw->lock, flags);\n\treturn ret;\n}\n\nstatic void\ncsio_free_evt(struct csio_hw *hw, struct csio_evt_msg *evt_entry)\n{\n\tif (evt_entry) {\n\t\tspin_lock_irq(&hw->lock);\n\t\tlist_del_init(&evt_entry->list);\n\t\tlist_add_tail(&evt_entry->list, &hw->evt_free_q);\n\t\tCSIO_DEC_STATS(hw, n_evt_activeq);\n\t\tCSIO_INC_STATS(hw, n_evt_freeq);\n\t\tspin_unlock_irq(&hw->lock);\n\t}\n}\n\nvoid\ncsio_evtq_flush(struct csio_hw *hw)\n{\n\tuint32_t count;\n\tcount = 30;\n\twhile (hw->flags & CSIO_HWF_FWEVT_PENDING && count--) {\n\t\tspin_unlock_irq(&hw->lock);\n\t\tmsleep(2000);\n\t\tspin_lock_irq(&hw->lock);\n\t}\n\n\tCSIO_DB_ASSERT(!(hw->flags & CSIO_HWF_FWEVT_PENDING));\n}\n\nstatic void\ncsio_evtq_stop(struct csio_hw *hw)\n{\n\thw->flags |= CSIO_HWF_FWEVT_STOP;\n}\n\nstatic void\ncsio_evtq_start(struct csio_hw *hw)\n{\n\thw->flags &= ~CSIO_HWF_FWEVT_STOP;\n}\n\nstatic void\ncsio_evtq_cleanup(struct csio_hw *hw)\n{\n\tstruct list_head *evt_entry, *next_entry;\n\n\t \n\tif (!list_empty(&hw->evt_active_q))\n\t\tlist_splice_tail_init(&hw->evt_active_q, &hw->evt_free_q);\n\n\thw->stats.n_evt_activeq = 0;\n\thw->flags &= ~CSIO_HWF_FWEVT_PENDING;\n\n\t \n\tlist_for_each_safe(evt_entry, next_entry, &hw->evt_free_q) {\n\t\tkfree(evt_entry);\n\t\tCSIO_DEC_STATS(hw, n_evt_freeq);\n\t}\n\n\thw->stats.n_evt_freeq = 0;\n}\n\n\nstatic void\ncsio_process_fwevtq_entry(struct csio_hw *hw, void *wr, uint32_t len,\n\t\t\t  struct csio_fl_dma_buf *flb, void *priv)\n{\n\t__u8 op;\n\tvoid *msg = NULL;\n\tuint32_t msg_len = 0;\n\tbool msg_sg = 0;\n\n\top = ((struct rss_header *) wr)->opcode;\n\tif (op == CPL_FW6_PLD) {\n\t\tCSIO_INC_STATS(hw, n_cpl_fw6_pld);\n\t\tif (!flb || !flb->totlen) {\n\t\t\tCSIO_INC_STATS(hw, n_cpl_unexp);\n\t\t\treturn;\n\t\t}\n\n\t\tmsg = (void *) flb;\n\t\tmsg_len = flb->totlen;\n\t\tmsg_sg = 1;\n\t} else if (op == CPL_FW6_MSG || op == CPL_FW4_MSG) {\n\n\t\tCSIO_INC_STATS(hw, n_cpl_fw6_msg);\n\t\t \n\t\tmsg = (void *)((uintptr_t)wr + sizeof(__be64));\n\t\tmsg_len = (op == CPL_FW6_MSG) ? sizeof(struct cpl_fw6_msg) :\n\t\t\t   sizeof(struct cpl_fw4_msg);\n\t} else {\n\t\tcsio_warn(hw, \"unexpected CPL %#x on FW event queue\\n\", op);\n\t\tCSIO_INC_STATS(hw, n_cpl_unexp);\n\t\treturn;\n\t}\n\n\t \n\tif (csio_enqueue_evt_lock(hw, CSIO_EVT_FW, msg,\n\t\t\t\t  (uint16_t)msg_len, msg_sg))\n\t\tCSIO_INC_STATS(hw, n_evt_drop);\n}\n\nvoid\ncsio_evtq_worker(struct work_struct *work)\n{\n\tstruct csio_hw *hw = container_of(work, struct csio_hw, evtq_work);\n\tstruct list_head *evt_entry, *next_entry;\n\tLIST_HEAD(evt_q);\n\tstruct csio_evt_msg\t*evt_msg;\n\tstruct cpl_fw6_msg *msg;\n\tstruct csio_rnode *rn;\n\tint rv = 0;\n\tuint8_t evtq_stop = 0;\n\n\tcsio_dbg(hw, \"event worker thread active evts#%d\\n\",\n\t\t hw->stats.n_evt_activeq);\n\n\tspin_lock_irq(&hw->lock);\n\twhile (!list_empty(&hw->evt_active_q)) {\n\t\tlist_splice_tail_init(&hw->evt_active_q, &evt_q);\n\t\tspin_unlock_irq(&hw->lock);\n\n\t\tlist_for_each_safe(evt_entry, next_entry, &evt_q) {\n\t\t\tevt_msg = (struct csio_evt_msg *) evt_entry;\n\n\t\t\t \n\t\t\tspin_lock_irq(&hw->lock);\n\t\t\tif (hw->flags & CSIO_HWF_FWEVT_STOP)\n\t\t\t\tevtq_stop = 1;\n\t\t\tspin_unlock_irq(&hw->lock);\n\t\t\tif (evtq_stop) {\n\t\t\t\tCSIO_INC_STATS(hw, n_evt_drop);\n\t\t\t\tgoto free_evt;\n\t\t\t}\n\n\t\t\tswitch (evt_msg->type) {\n\t\t\tcase CSIO_EVT_FW:\n\t\t\t\tmsg = (struct cpl_fw6_msg *)(evt_msg->data);\n\n\t\t\t\tif ((msg->opcode == CPL_FW6_MSG ||\n\t\t\t\t     msg->opcode == CPL_FW4_MSG) &&\n\t\t\t\t    !msg->type) {\n\t\t\t\t\trv = csio_mb_fwevt_handler(hw,\n\t\t\t\t\t\t\t\tmsg->data);\n\t\t\t\t\tif (!rv)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t \n\t\t\t\t\tcsio_fcoe_fwevt_handler(hw,\n\t\t\t\t\t\t\tmsg->opcode, msg->data);\n\t\t\t\t} else if (msg->opcode == CPL_FW6_PLD) {\n\n\t\t\t\t\tcsio_fcoe_fwevt_handler(hw,\n\t\t\t\t\t\t\tmsg->opcode, msg->data);\n\t\t\t\t} else {\n\t\t\t\t\tcsio_warn(hw,\n\t\t\t\t\t     \"Unhandled FW msg op %x type %x\\n\",\n\t\t\t\t\t\t  msg->opcode, msg->type);\n\t\t\t\t\tCSIO_INC_STATS(hw, n_evt_drop);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CSIO_EVT_MBX:\n\t\t\t\tcsio_mberr_worker(hw);\n\t\t\t\tbreak;\n\n\t\t\tcase CSIO_EVT_DEV_LOSS:\n\t\t\t\tmemcpy(&rn, evt_msg->data, sizeof(rn));\n\t\t\t\tcsio_rnode_devloss_handler(rn);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tcsio_warn(hw, \"Unhandled event %x on evtq\\n\",\n\t\t\t\t\t  evt_msg->type);\n\t\t\t\tCSIO_INC_STATS(hw, n_evt_unexp);\n\t\t\t\tbreak;\n\t\t\t}\nfree_evt:\n\t\t\tcsio_free_evt(hw, evt_msg);\n\t\t}\n\n\t\tspin_lock_irq(&hw->lock);\n\t}\n\thw->flags &= ~CSIO_HWF_FWEVT_PENDING;\n\tspin_unlock_irq(&hw->lock);\n}\n\nint\ncsio_fwevtq_handler(struct csio_hw *hw)\n{\n\tint rv;\n\n\tif (csio_q_iqid(hw, hw->fwevt_iq_idx) == CSIO_MAX_QID) {\n\t\tCSIO_INC_STATS(hw, n_int_stray);\n\t\treturn -EINVAL;\n\t}\n\n\trv = csio_wr_process_iq_idx(hw, hw->fwevt_iq_idx,\n\t\t\t   csio_process_fwevtq_entry, NULL);\n\treturn rv;\n}\n\n \n\n \n \nint\ncsio_mgmt_req_lookup(struct csio_mgmtm *mgmtm, struct csio_ioreq *io_req)\n{\n\tstruct list_head *tmp;\n\n\t \n\tlist_for_each(tmp, &mgmtm->active_q) {\n\t\tif (io_req == (struct csio_ioreq *)tmp)\n\t\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n#define\tECM_MIN_TMO\t1000\t \n\n \nstatic void\ncsio_mgmt_tmo_handler(struct timer_list *t)\n{\n\tstruct csio_mgmtm *mgmtm = from_timer(mgmtm, t, mgmt_timer);\n\tstruct list_head *tmp;\n\tstruct csio_ioreq *io_req;\n\n\tcsio_dbg(mgmtm->hw, \"Mgmt timer invoked!\\n\");\n\n\tspin_lock_irq(&mgmtm->hw->lock);\n\n\tlist_for_each(tmp, &mgmtm->active_q) {\n\t\tio_req = (struct csio_ioreq *) tmp;\n\t\tio_req->tmo -= min_t(uint32_t, io_req->tmo, ECM_MIN_TMO);\n\n\t\tif (!io_req->tmo) {\n\t\t\t \n\t\t\ttmp = csio_list_prev(tmp);\n\t\t\tlist_del_init(&io_req->sm.sm_list);\n\t\t\tif (io_req->io_cbfn) {\n\t\t\t\t \n\t\t\t\tio_req->wr_status = -ETIMEDOUT;\n\t\t\t\tio_req->io_cbfn(mgmtm->hw, io_req);\n\t\t\t} else {\n\t\t\t\tCSIO_DB_ASSERT(0);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!list_empty(&mgmtm->active_q))\n\t\tmod_timer(&mgmtm->mgmt_timer,\n\t\t\t  jiffies + msecs_to_jiffies(ECM_MIN_TMO));\n\tspin_unlock_irq(&mgmtm->hw->lock);\n}\n\nstatic void\ncsio_mgmtm_cleanup(struct csio_mgmtm *mgmtm)\n{\n\tstruct csio_hw *hw = mgmtm->hw;\n\tstruct csio_ioreq *io_req;\n\tstruct list_head *tmp;\n\tuint32_t count;\n\n\tcount = 30;\n\t \n\twhile ((!list_empty(&mgmtm->active_q)) && count--) {\n\t\tspin_unlock_irq(&hw->lock);\n\t\tmsleep(2000);\n\t\tspin_lock_irq(&hw->lock);\n\t}\n\n\t \n\tlist_for_each(tmp, &mgmtm->active_q) {\n\t\tio_req = (struct csio_ioreq *) tmp;\n\t\ttmp = csio_list_prev(tmp);\n\t\tlist_del_init(&io_req->sm.sm_list);\n\t\tmgmtm->stats.n_active--;\n\t\tif (io_req->io_cbfn) {\n\t\t\t \n\t\t\tio_req->wr_status = -ETIMEDOUT;\n\t\t\tio_req->io_cbfn(mgmtm->hw, io_req);\n\t\t}\n\t}\n}\n\n \nstatic int\ncsio_mgmtm_init(struct csio_mgmtm *mgmtm, struct csio_hw *hw)\n{\n\ttimer_setup(&mgmtm->mgmt_timer, csio_mgmt_tmo_handler, 0);\n\n\tINIT_LIST_HEAD(&mgmtm->active_q);\n\tINIT_LIST_HEAD(&mgmtm->cbfn_q);\n\n\tmgmtm->hw = hw;\n\t \n\n\treturn 0;\n}\n\n \nstatic void\ncsio_mgmtm_exit(struct csio_mgmtm *mgmtm)\n{\n\tdel_timer_sync(&mgmtm->mgmt_timer);\n}\n\n\n \nint\ncsio_hw_start(struct csio_hw *hw)\n{\n\tspin_lock_irq(&hw->lock);\n\tcsio_post_event(&hw->sm, CSIO_HWE_CFG);\n\tspin_unlock_irq(&hw->lock);\n\n\tif (csio_is_hw_ready(hw))\n\t\treturn 0;\n\telse if (csio_match_state(hw, csio_hws_uninit))\n\t\treturn -EINVAL;\n\telse\n\t\treturn -ENODEV;\n}\n\nint\ncsio_hw_stop(struct csio_hw *hw)\n{\n\tcsio_post_event(&hw->sm, CSIO_HWE_PCI_REMOVE);\n\n\tif (csio_is_hw_removing(hw))\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}\n\n \n#define CSIO_MAX_RESET_RETRIES\t3\n\n \nint\ncsio_hw_reset(struct csio_hw *hw)\n{\n\tif (!csio_is_hw_master(hw))\n\t\treturn -EPERM;\n\n\tif (hw->rst_retries >= CSIO_MAX_RESET_RETRIES) {\n\t\tcsio_dbg(hw, \"Max hw reset attempts reached..\");\n\t\treturn -EINVAL;\n\t}\n\n\thw->rst_retries++;\n\tcsio_post_event(&hw->sm, CSIO_HWE_HBA_RESET);\n\n\tif (csio_is_hw_ready(hw)) {\n\t\thw->rst_retries = 0;\n\t\thw->stats.n_reset_start = jiffies_to_msecs(jiffies);\n\t\treturn 0;\n\t} else\n\t\treturn -EINVAL;\n}\n\n \nstatic void\ncsio_hw_get_device_id(struct csio_hw *hw)\n{\n\t \n\tif (csio_is_dev_id_cached(hw))\n\t\treturn;\n\n\t \n\tpci_read_config_word(hw->pdev, PCI_VENDOR_ID,\n\t\t\t     &hw->params.pci.vendor_id);\n\tpci_read_config_word(hw->pdev, PCI_DEVICE_ID,\n\t\t\t     &hw->params.pci.device_id);\n\n\tcsio_dev_id_cached(hw);\n\thw->chip_id = (hw->params.pci.device_id & CSIO_HW_CHIP_MASK);\n\n}  \n\n \nstatic void\ncsio_hw_set_description(struct csio_hw *hw, uint16_t ven_id, uint16_t dev_id)\n{\n\tuint32_t adap_type, prot_type;\n\n\tif (ven_id == CSIO_VENDOR_ID) {\n\t\tprot_type = (dev_id & CSIO_ASIC_DEVID_PROTO_MASK);\n\t\tadap_type = (dev_id & CSIO_ASIC_DEVID_TYPE_MASK);\n\n\t\tif (prot_type == CSIO_T5_FCOE_ASIC) {\n\t\t\tmemcpy(hw->hw_ver,\n\t\t\t       csio_t5_fcoe_adapters[adap_type].model_no, 16);\n\t\t\tmemcpy(hw->model_desc,\n\t\t\t       csio_t5_fcoe_adapters[adap_type].description,\n\t\t\t       32);\n\t\t} else {\n\t\t\tchar tempName[32] = \"Chelsio FCoE Controller\";\n\t\t\tmemcpy(hw->model_desc, tempName, 32);\n\t\t}\n\t}\n}  \n\n \nint\ncsio_hw_init(struct csio_hw *hw)\n{\n\tint rv = -EINVAL;\n\tuint32_t i;\n\tuint16_t ven_id, dev_id;\n\tstruct csio_evt_msg\t*evt_entry;\n\n\tINIT_LIST_HEAD(&hw->sm.sm_list);\n\tcsio_init_state(&hw->sm, csio_hws_uninit);\n\tspin_lock_init(&hw->lock);\n\tINIT_LIST_HEAD(&hw->sln_head);\n\n\t \n\tcsio_hw_get_device_id(hw);\n\n\tstrcpy(hw->name, CSIO_HW_NAME);\n\n\t \n\thw->chip_ops = &t5_ops;\n\n\t \n\n\tven_id = hw->params.pci.vendor_id;\n\tdev_id = hw->params.pci.device_id;\n\n\tcsio_hw_set_description(hw, ven_id, dev_id);\n\n\t \n\thw->params.log_level = (uint32_t) csio_dbg_level;\n\n\tcsio_set_fwevt_intr_idx(hw, -1);\n\tcsio_set_nondata_intr_idx(hw, -1);\n\n\t \n\tif (csio_mbm_init(csio_hw_to_mbm(hw), hw, csio_hw_mb_timer))\n\t\tgoto err;\n\n\trv = csio_wrm_init(csio_hw_to_wrm(hw), hw);\n\tif (rv)\n\t\tgoto err_mbm_exit;\n\n\trv = csio_scsim_init(csio_hw_to_scsim(hw), hw);\n\tif (rv)\n\t\tgoto err_wrm_exit;\n\n\trv = csio_mgmtm_init(csio_hw_to_mgmtm(hw), hw);\n\tif (rv)\n\t\tgoto err_scsim_exit;\n\t \n\tINIT_LIST_HEAD(&hw->evt_active_q);\n\tINIT_LIST_HEAD(&hw->evt_free_q);\n\tfor (i = 0; i < csio_evtq_sz; i++) {\n\n\t\tevt_entry = kzalloc(sizeof(struct csio_evt_msg), GFP_KERNEL);\n\t\tif (!evt_entry) {\n\t\t\trv = -ENOMEM;\n\t\t\tcsio_err(hw, \"Failed to initialize eventq\");\n\t\t\tgoto err_evtq_cleanup;\n\t\t}\n\n\t\tlist_add_tail(&evt_entry->list, &hw->evt_free_q);\n\t\tCSIO_INC_STATS(hw, n_evt_freeq);\n\t}\n\n\thw->dev_num = dev_num;\n\tdev_num++;\n\n\treturn 0;\n\nerr_evtq_cleanup:\n\tcsio_evtq_cleanup(hw);\n\tcsio_mgmtm_exit(csio_hw_to_mgmtm(hw));\nerr_scsim_exit:\n\tcsio_scsim_exit(csio_hw_to_scsim(hw));\nerr_wrm_exit:\n\tcsio_wrm_exit(csio_hw_to_wrm(hw), hw);\nerr_mbm_exit:\n\tcsio_mbm_exit(csio_hw_to_mbm(hw));\nerr:\n\treturn rv;\n}\n\n \nvoid\ncsio_hw_exit(struct csio_hw *hw)\n{\n\tcsio_evtq_cleanup(hw);\n\tcsio_mgmtm_exit(csio_hw_to_mgmtm(hw));\n\tcsio_scsim_exit(csio_hw_to_scsim(hw));\n\tcsio_wrm_exit(csio_hw_to_wrm(hw), hw);\n\tcsio_mbm_exit(csio_hw_to_mbm(hw));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}