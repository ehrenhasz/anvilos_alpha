{
  "module_name": "csio_scsi.h",
  "hash_id": "52442e3af1a71f3d885a314fa0b1a3ba9343857857b8a9fdbea0d12d9d25c867",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/csiostor/csio_scsi.h",
  "human_readable_source": " \n\n#ifndef __CSIO_SCSI_H__\n#define __CSIO_SCSI_H__\n\n#include <linux/spinlock_types.h>\n#include <linux/completion.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/fc/fc_fcp.h>\n\n#include \"csio_defs.h\"\n#include \"csio_wr.h\"\n\nextern struct scsi_host_template csio_fcoe_shost_template;\nextern struct scsi_host_template csio_fcoe_shost_vport_template;\n\nextern int csio_scsi_eqsize;\nextern int csio_scsi_iqlen;\nextern int csio_scsi_ioreqs;\nextern uint32_t csio_max_scan_tmo;\nextern uint32_t csio_delta_scan_tmo;\nextern int csio_lun_qdepth;\n\n \n#define CSIO_SCSI_MAX_SGE\t\t35\n#define CSIO_SCSI_ABRT_TMO_MS\t\t60000\n#define CSIO_SCSI_LUNRST_TMO_MS\t\t60000\n#define CSIO_SCSI_TM_POLL_MS\t\t2000\t \n#define CSIO_SCSI_IQ_WRSZ\t\t128\n#define CSIO_SCSI_IQSIZE\t\t(csio_scsi_iqlen * CSIO_SCSI_IQ_WRSZ)\n\n#define\tCSIO_MAX_SNS_LEN\t\t128\n#define\tCSIO_SCSI_RSP_LEN\t(FCP_RESP_WITH_EXT + 4 + CSIO_MAX_SNS_LEN)\n\n \n#define csio_scsi_cmnd(req)\t\t((req)->scratch1)\n\nstruct csio_scsi_stats {\n\tuint64_t\t\tn_tot_success;\t \n\tuint32_t\t\tn_rn_nr_error;\t \n\tuint32_t\t\tn_hw_nr_error;\t \n\tuint32_t\t\tn_dmamap_error;\t \n\tuint32_t\t\tn_unsupp_sge_error;  \n\tuint32_t\t\tn_no_req_error;\t \n\tuint32_t\t\tn_busy_error;\t \n\tuint32_t\t\tn_hosterror;\t \n\tuint32_t\t\tn_rsperror;\t \n\tuint32_t\t\tn_autosense;\t \n\tuint32_t\t\tn_ovflerror;\t \n\tuint32_t\t\tn_unflerror;\t \n\tuint32_t\t\tn_rdev_nr_error; \n\tuint32_t\t\tn_rdev_lost_error; \n\tuint32_t\t\tn_rdev_logo_error; \n\tuint32_t\t\tn_link_down_error; \n\tuint32_t\t\tn_no_xchg_error;  \n\tuint32_t\t\tn_unknown_error; \n\tuint32_t\t\tn_aborted;\t \n\tuint32_t\t\tn_abrt_timedout;  \n\tuint32_t\t\tn_abrt_fail;\t \n\tuint32_t\t\tn_abrt_dups;\t \n\tuint32_t\t\tn_abrt_race_comp;  \n\tuint32_t\t\tn_abrt_busy_error; \n\tuint32_t\t\tn_closed;\t \n\tuint32_t\t\tn_cls_busy_error;  \n\tuint32_t\t\tn_active;\t \n\tuint32_t\t\tn_tm_active;\t \n\tuint32_t\t\tn_wcbfn;\t \n\tuint32_t\t\tn_free_ioreq;\t \n\tuint32_t\t\tn_free_ddp;\t \n\tuint32_t\t\tn_unaligned;\t \n\tuint32_t\t\tn_inval_cplop;\t \n\tuint32_t\t\tn_inval_scsiop;\t \n};\n\nstruct csio_scsim {\n\tstruct csio_hw\t\t*hw;\t\t \n\tuint8_t\t\t\tmax_sge;\t \n\tuint8_t\t\t\tproto_cmd_len;\t \n\tuint16_t\t\tproto_rsp_len;\t \n\tspinlock_t\t\tfreelist_lock;\t \n\tstruct list_head\tactive_q;\t \n\tstruct list_head\tioreq_freelist;\t \n\tstruct list_head\tddp_freelist;\t \n\tstruct csio_scsi_stats\tstats;\t\t \n};\n\n \nenum csio_scsi_ev {\n\tCSIO_SCSIE_START_IO = 1,\t\t \n\tCSIO_SCSIE_START_TM,\t\t\t \n\tCSIO_SCSIE_COMPLETED,\t\t\t \n\tCSIO_SCSIE_ABORT,\t\t\t \n\tCSIO_SCSIE_ABORTED,\t\t\t \n\tCSIO_SCSIE_CLOSE,\t\t\t \n\tCSIO_SCSIE_CLOSED,\t\t\t \n\tCSIO_SCSIE_DRVCLEANUP,\t\t\t \n};\n\nenum csio_scsi_lev {\n\tCSIO_LEV_ALL = 1,\n\tCSIO_LEV_LNODE,\n\tCSIO_LEV_RNODE,\n\tCSIO_LEV_LUN,\n};\n\nstruct csio_scsi_level_data {\n\tenum csio_scsi_lev\tlevel;\n\tstruct csio_rnode\t*rnode;\n\tstruct csio_lnode\t*lnode;\n\tuint64_t\t\toslun;\n};\n\nstruct csio_cmd_priv {\n\tuint8_t fc_tm_flags;\t \n\tuint16_t wr_status;\n};\n\nstatic inline struct csio_cmd_priv *csio_priv(struct scsi_cmnd *cmd)\n{\n\treturn scsi_cmd_priv(cmd);\n}\n\nstatic inline struct csio_ioreq *\ncsio_get_scsi_ioreq(struct csio_scsim *scm)\n{\n\tstruct csio_sm *req;\n\n\tif (likely(!list_empty(&scm->ioreq_freelist))) {\n\t\treq = list_first_entry(&scm->ioreq_freelist,\n\t\t\t\t       struct csio_sm, sm_list);\n\t\tlist_del_init(&req->sm_list);\n\t\tCSIO_DEC_STATS(scm, n_free_ioreq);\n\t\treturn (struct csio_ioreq *)req;\n\t} else\n\t\treturn NULL;\n}\n\nstatic inline void\ncsio_put_scsi_ioreq(struct csio_scsim *scm, struct csio_ioreq *ioreq)\n{\n\tlist_add_tail(&ioreq->sm.sm_list, &scm->ioreq_freelist);\n\tCSIO_INC_STATS(scm, n_free_ioreq);\n}\n\nstatic inline void\ncsio_put_scsi_ioreq_list(struct csio_scsim *scm, struct list_head *reqlist,\n\t\t\t int n)\n{\n\tlist_splice_init(reqlist, &scm->ioreq_freelist);\n\tscm->stats.n_free_ioreq += n;\n}\n\nstatic inline struct csio_dma_buf *\ncsio_get_scsi_ddp(struct csio_scsim *scm)\n{\n\tstruct csio_dma_buf *ddp;\n\n\tif (likely(!list_empty(&scm->ddp_freelist))) {\n\t\tddp = list_first_entry(&scm->ddp_freelist,\n\t\t\t\t       struct csio_dma_buf, list);\n\t\tlist_del_init(&ddp->list);\n\t\tCSIO_DEC_STATS(scm, n_free_ddp);\n\t\treturn ddp;\n\t} else\n\t\treturn NULL;\n}\n\nstatic inline void\ncsio_put_scsi_ddp(struct csio_scsim *scm, struct csio_dma_buf *ddp)\n{\n\tlist_add_tail(&ddp->list, &scm->ddp_freelist);\n\tCSIO_INC_STATS(scm, n_free_ddp);\n}\n\nstatic inline void\ncsio_put_scsi_ddp_list(struct csio_scsim *scm, struct list_head *reqlist,\n\t\t\t int n)\n{\n\tlist_splice_tail_init(reqlist, &scm->ddp_freelist);\n\tscm->stats.n_free_ddp += n;\n}\n\nstatic inline void\ncsio_scsi_completed(struct csio_ioreq *ioreq, struct list_head *cbfn_q)\n{\n\tcsio_post_event(&ioreq->sm, CSIO_SCSIE_COMPLETED);\n\tif (csio_list_deleted(&ioreq->sm.sm_list))\n\t\tlist_add_tail(&ioreq->sm.sm_list, cbfn_q);\n}\n\nstatic inline void\ncsio_scsi_aborted(struct csio_ioreq *ioreq, struct list_head *cbfn_q)\n{\n\tcsio_post_event(&ioreq->sm, CSIO_SCSIE_ABORTED);\n\tlist_add_tail(&ioreq->sm.sm_list, cbfn_q);\n}\n\nstatic inline void\ncsio_scsi_closed(struct csio_ioreq *ioreq, struct list_head *cbfn_q)\n{\n\tcsio_post_event(&ioreq->sm, CSIO_SCSIE_CLOSED);\n\tlist_add_tail(&ioreq->sm.sm_list, cbfn_q);\n}\n\nstatic inline void\ncsio_scsi_drvcleanup(struct csio_ioreq *ioreq)\n{\n\tcsio_post_event(&ioreq->sm, CSIO_SCSIE_DRVCLEANUP);\n}\n\n \nstatic inline int\ncsio_scsi_start_io(struct csio_ioreq *ioreq)\n{\n\tcsio_post_event(&ioreq->sm, CSIO_SCSIE_START_IO);\n\treturn ioreq->drv_status;\n}\n\n \nstatic inline int\ncsio_scsi_start_tm(struct csio_ioreq *ioreq)\n{\n\tcsio_post_event(&ioreq->sm, CSIO_SCSIE_START_TM);\n\treturn ioreq->drv_status;\n}\n\n \nstatic inline int\ncsio_scsi_abort(struct csio_ioreq *ioreq)\n{\n\tcsio_post_event(&ioreq->sm, CSIO_SCSIE_ABORT);\n\treturn ioreq->drv_status;\n}\n\n \nstatic inline int\ncsio_scsi_close(struct csio_ioreq *ioreq)\n{\n\tcsio_post_event(&ioreq->sm, CSIO_SCSIE_CLOSE);\n\treturn ioreq->drv_status;\n}\n\nvoid csio_scsi_cleanup_io_q(struct csio_scsim *, struct list_head *);\nint csio_scsim_cleanup_io(struct csio_scsim *, bool abort);\nint csio_scsim_cleanup_io_lnode(struct csio_scsim *,\n\t\t\t\t\t  struct csio_lnode *);\nstruct csio_ioreq *csio_scsi_cmpl_handler(struct csio_hw *, void *, uint32_t,\n\t\t\t\t\t  struct csio_fl_dma_buf *,\n\t\t\t\t\t  void *, uint8_t **);\nint csio_scsi_qconfig(struct csio_hw *);\nint csio_scsim_init(struct csio_scsim *, struct csio_hw *);\nvoid csio_scsim_exit(struct csio_scsim *);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}