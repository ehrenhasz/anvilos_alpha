{
  "module_name": "csio_attr.c",
  "hash_id": "6fcb33bf2736af0db78a4cf775e4ab8d9170c03fbfc18870d30ff7e5be523717",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/csiostor/csio_attr.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <scsi/fc/fc_fs.h>\n\n#include \"csio_init.h\"\n\nstatic void\ncsio_vport_set_state(struct csio_lnode *ln);\n\n \nvoid\ncsio_reg_rnode(struct csio_rnode *rn)\n{\n\tstruct csio_lnode *ln\t\t= csio_rnode_to_lnode(rn);\n\tstruct Scsi_Host *shost\t\t= csio_ln_to_shost(ln);\n\tstruct fc_rport_identifiers ids;\n\tstruct fc_rport  *rport;\n\tstruct csio_service_parms *sp;\n\n\tids.node_name\t= wwn_to_u64(csio_rn_wwnn(rn));\n\tids.port_name\t= wwn_to_u64(csio_rn_wwpn(rn));\n\tids.port_id\t= rn->nport_id;\n\tids.roles\t= FC_RPORT_ROLE_UNKNOWN;\n\n\tif (rn->role & CSIO_RNFR_INITIATOR || rn->role & CSIO_RNFR_TARGET) {\n\t\trport = rn->rport;\n\t\tCSIO_ASSERT(rport != NULL);\n\t\tgoto update_role;\n\t}\n\n\trn->rport = fc_remote_port_add(shost, 0, &ids);\n\tif (!rn->rport) {\n\t\tcsio_ln_err(ln, \"Failed to register rport = 0x%x.\\n\",\n\t\t\t\t\trn->nport_id);\n\t\treturn;\n\t}\n\n\tln->num_reg_rnodes++;\n\trport = rn->rport;\n\tspin_lock_irq(shost->host_lock);\n\t*((struct csio_rnode **)rport->dd_data) = rn;\n\tspin_unlock_irq(shost->host_lock);\n\n\tsp = &rn->rn_sparm;\n\trport->maxframe_size = ntohs(sp->csp.sp_bb_data);\n\tif (ntohs(sp->clsp[2].cp_class) & FC_CPC_VALID)\n\t\trport->supported_classes = FC_COS_CLASS3;\n\telse\n\t\trport->supported_classes = FC_COS_UNSPECIFIED;\nupdate_role:\n\tif (rn->role & CSIO_RNFR_INITIATOR)\n\t\tids.roles |= FC_RPORT_ROLE_FCP_INITIATOR;\n\tif (rn->role & CSIO_RNFR_TARGET)\n\t\tids.roles |= FC_RPORT_ROLE_FCP_TARGET;\n\n\tif (ids.roles != FC_RPORT_ROLE_UNKNOWN)\n\t\tfc_remote_port_rolechg(rport, ids.roles);\n\n\trn->scsi_id = rport->scsi_target_id;\n\n\tcsio_ln_dbg(ln, \"Remote port x%x role 0x%x registered\\n\",\n\t\trn->nport_id, ids.roles);\n}\n\n \nvoid\ncsio_unreg_rnode(struct csio_rnode *rn)\n{\n\tstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\n\tstruct fc_rport *rport = rn->rport;\n\n\trn->role &= ~(CSIO_RNFR_INITIATOR | CSIO_RNFR_TARGET);\n\tfc_remote_port_delete(rport);\n\tln->num_reg_rnodes--;\n\n\tcsio_ln_dbg(ln, \"Remote port x%x un-registered\\n\", rn->nport_id);\n}\n\n \nvoid\ncsio_lnode_async_event(struct csio_lnode *ln, enum csio_ln_fc_evt fc_evt)\n{\n\tswitch (fc_evt) {\n\tcase CSIO_LN_FC_RSCN:\n\t\t \n\t\t \n\t\t\t \n\t\tbreak;\n\tcase CSIO_LN_FC_LINKUP:\n\t\t \n\t\t \n\t\tif (csio_is_npiv_ln(ln))\n\t\t\tcsio_vport_set_state(ln);\n\n\t\tbreak;\n\tcase CSIO_LN_FC_LINKDOWN:\n\t\t \n\t\t \n\t\tif (csio_is_npiv_ln(ln))\n\t\t\tcsio_vport_set_state(ln);\n\n\t\tbreak;\n\tcase CSIO_LN_FC_ATTRIB_UPDATE:\n\t\tcsio_fchost_attr_init(ln);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nvoid\ncsio_fchost_attr_init(struct csio_lnode *ln)\n{\n\tstruct Scsi_Host  *shost = csio_ln_to_shost(ln);\n\n\tfc_host_node_name(shost) = wwn_to_u64(csio_ln_wwnn(ln));\n\tfc_host_port_name(shost) = wwn_to_u64(csio_ln_wwpn(ln));\n\n\tfc_host_supported_classes(shost) = FC_COS_CLASS3;\n\tfc_host_max_npiv_vports(shost) =\n\t\t\t(csio_lnode_to_hw(ln))->fres_info.max_vnps;\n\tfc_host_supported_speeds(shost) = FC_PORTSPEED_10GBIT |\n\t\tFC_PORTSPEED_1GBIT;\n\n\tfc_host_maxframe_size(shost) = ntohs(ln->ln_sparm.csp.sp_bb_data);\n\tmemset(fc_host_supported_fc4s(shost), 0,\n\t\tsizeof(fc_host_supported_fc4s(shost)));\n\tfc_host_supported_fc4s(shost)[7] = 1;\n\n\tmemset(fc_host_active_fc4s(shost), 0,\n\t\tsizeof(fc_host_active_fc4s(shost)));\n\tfc_host_active_fc4s(shost)[7] = 1;\n}\n\n \nstatic void\ncsio_get_host_port_id(struct Scsi_Host *shost)\n{\n\tstruct csio_lnode *ln\t= shost_priv(shost);\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\n\tspin_lock_irq(&hw->lock);\n\tfc_host_port_id(shost) = ln->nport_id;\n\tspin_unlock_irq(&hw->lock);\n}\n\n \nstatic void\ncsio_get_host_port_type(struct Scsi_Host *shost)\n{\n\tstruct csio_lnode *ln = shost_priv(shost);\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\n\tspin_lock_irq(&hw->lock);\n\tif (csio_is_npiv_ln(ln))\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_NPIV;\n\telse\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_NPORT;\n\tspin_unlock_irq(&hw->lock);\n}\n\n \nstatic void\ncsio_get_host_port_state(struct Scsi_Host *shost)\n{\n\tstruct csio_lnode *ln = shost_priv(shost);\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\tchar state[16];\n\n\tspin_lock_irq(&hw->lock);\n\n\tcsio_lnode_state_to_str(ln, state);\n\tif (!strcmp(state, \"READY\"))\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_ONLINE;\n\telse if (!strcmp(state, \"OFFLINE\"))\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\n\telse\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\n\n\tspin_unlock_irq(&hw->lock);\n}\n\n \nstatic void\ncsio_get_host_speed(struct Scsi_Host *shost)\n{\n\tstruct csio_lnode *ln = shost_priv(shost);\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\n\tspin_lock_irq(&hw->lock);\n\tswitch (hw->pport[ln->portid].link_speed) {\n\tcase FW_PORT_CAP32_SPEED_1G:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_1GBIT;\n\t\tbreak;\n\tcase FW_PORT_CAP32_SPEED_10G:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\n\t\tbreak;\n\tcase FW_PORT_CAP32_SPEED_25G:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_25GBIT;\n\t\tbreak;\n\tcase FW_PORT_CAP32_SPEED_40G:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_40GBIT;\n\t\tbreak;\n\tcase FW_PORT_CAP32_SPEED_50G:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_50GBIT;\n\t\tbreak;\n\tcase FW_PORT_CAP32_SPEED_100G:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_100GBIT;\n\t\tbreak;\n\tdefault:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\n\t\tbreak;\n\t}\n\tspin_unlock_irq(&hw->lock);\n}\n\n \nstatic void\ncsio_get_host_fabric_name(struct Scsi_Host *shost)\n{\n\tstruct csio_lnode *ln = shost_priv(shost);\n\tstruct csio_rnode *rn = NULL;\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\n\tspin_lock_irq(&hw->lock);\n\trn = csio_rnode_lookup_portid(ln, FC_FID_FLOGI);\n\tif (rn)\n\t\tfc_host_fabric_name(shost) = wwn_to_u64(csio_rn_wwnn(rn));\n\telse\n\t\tfc_host_fabric_name(shost) = 0;\n\tspin_unlock_irq(&hw->lock);\n}\n\n \nstatic struct fc_host_statistics *\ncsio_get_stats(struct Scsi_Host *shost)\n{\n\tstruct csio_lnode *ln = shost_priv(shost);\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\tstruct fc_host_statistics *fhs = &ln->fch_stats;\n\tstruct fw_fcoe_port_stats fcoe_port_stats;\n\tuint64_t seconds;\n\n\tmemset(&fcoe_port_stats, 0, sizeof(struct fw_fcoe_port_stats));\n\tcsio_get_phy_port_stats(hw, ln->portid, &fcoe_port_stats);\n\n\tfhs->tx_frames  += (be64_to_cpu(fcoe_port_stats.tx_bcast_frames) +\n\t\t\t    be64_to_cpu(fcoe_port_stats.tx_mcast_frames) +\n\t\t\t    be64_to_cpu(fcoe_port_stats.tx_ucast_frames) +\n\t\t\t    be64_to_cpu(fcoe_port_stats.tx_offload_frames));\n\tfhs->tx_words  += (be64_to_cpu(fcoe_port_stats.tx_bcast_bytes) +\n\t\t\t   be64_to_cpu(fcoe_port_stats.tx_mcast_bytes) +\n\t\t\t   be64_to_cpu(fcoe_port_stats.tx_ucast_bytes) +\n\t\t\t   be64_to_cpu(fcoe_port_stats.tx_offload_bytes)) /\n\t\t\t\t\t\t\tCSIO_WORD_TO_BYTE;\n\tfhs->rx_frames += (be64_to_cpu(fcoe_port_stats.rx_bcast_frames) +\n\t\t\t   be64_to_cpu(fcoe_port_stats.rx_mcast_frames) +\n\t\t\t   be64_to_cpu(fcoe_port_stats.rx_ucast_frames));\n\tfhs->rx_words += (be64_to_cpu(fcoe_port_stats.rx_bcast_bytes) +\n\t\t\t  be64_to_cpu(fcoe_port_stats.rx_mcast_bytes) +\n\t\t\t  be64_to_cpu(fcoe_port_stats.rx_ucast_bytes)) /\n\t\t\t\t\t\t\tCSIO_WORD_TO_BYTE;\n\tfhs->error_frames += be64_to_cpu(fcoe_port_stats.rx_err_frames);\n\tfhs->fcp_input_requests +=  ln->stats.n_input_requests;\n\tfhs->fcp_output_requests +=  ln->stats.n_output_requests;\n\tfhs->fcp_control_requests +=  ln->stats.n_control_requests;\n\tfhs->fcp_input_megabytes +=  ln->stats.n_input_bytes >> 20;\n\tfhs->fcp_output_megabytes +=  ln->stats.n_output_bytes >> 20;\n\tfhs->link_failure_count = ln->stats.n_link_down;\n\t \n\tseconds = jiffies_to_msecs(jiffies) - hw->stats.n_reset_start;\n\tdo_div(seconds, 1000);\n\tfhs->seconds_since_last_reset = seconds;\n\n\treturn fhs;\n}\n\n \nstatic void\ncsio_set_rport_loss_tmo(struct fc_rport *rport, uint32_t timeout)\n{\n\tif (timeout)\n\t\trport->dev_loss_tmo = timeout;\n\telse\n\t\trport->dev_loss_tmo = 1;\n}\n\nstatic void\ncsio_vport_set_state(struct csio_lnode *ln)\n{\n\tstruct fc_vport *fc_vport = ln->fc_vport;\n\tstruct csio_lnode  *pln = ln->pln;\n\tchar state[16];\n\n\t \n\tcsio_lnode_state_to_str(pln, state);\n\tif (strcmp(state, \"READY\")) {\n\t\tfc_vport_set_state(fc_vport, FC_VPORT_LINKDOWN);\n\t\treturn;\n\t}\n\n\tif (!(pln->flags & CSIO_LNF_NPIVSUPP)) {\n\t\tfc_vport_set_state(fc_vport, FC_VPORT_NO_FABRIC_SUPP);\n\t\treturn;\n\t}\n\n\t \n\tcsio_lnode_state_to_str(ln, state);\n\tif (strcmp(state, \"READY\")) {\n\t\tfc_vport_set_state(fc_vport, FC_VPORT_LINKDOWN);\n\t\treturn;\n\t}\n\tfc_vport_set_state(fc_vport, FC_VPORT_ACTIVE);\n}\n\nstatic int\ncsio_fcoe_alloc_vnp(struct csio_hw *hw, struct csio_lnode *ln)\n{\n\tstruct csio_lnode *pln;\n\tstruct csio_mb  *mbp;\n\tstruct fw_fcoe_vnp_cmd *rsp;\n\tint ret = 0;\n\tint retry = 0;\n\n\t \n\t \n\tspin_lock_irq(&hw->lock);\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpln = ln->pln;\n\tln->fcf_flowid = pln->fcf_flowid;\n\tln->portid = pln->portid;\n\n\tcsio_fcoe_vnp_alloc_init_mb(ln, mbp, CSIO_MB_DEFAULT_TMO,\n\t\t\t\t    pln->fcf_flowid, pln->vnp_flowid, 0,\n\t\t\t\t    csio_ln_wwnn(ln), csio_ln_wwpn(ln), NULL);\n\n\tfor (retry = 0; retry < 3; retry++) {\n\t\t \n\t\tret = csio_mb_issue(hw, mbp);\n\t\tif (ret != -EBUSY)\n\t\t\tbreak;\n\n\t\t \n\t\tspin_unlock_irq(&hw->lock);\n\t\tmsleep(2000);\n\t\tspin_lock_irq(&hw->lock);\n\t}\n\n\tif (ret) {\n\t\tcsio_ln_err(ln, \"Failed to issue mbox FCoE VNP command\\n\");\n\t\tgoto out_free;\n\t}\n\n\t \n\trsp = (struct fw_fcoe_vnp_cmd *)(mbp->mb);\n\tif (FW_CMD_RETVAL_G(ntohl(rsp->alloc_to_len16)) != FW_SUCCESS) {\n\t\tcsio_ln_err(ln, \"FCOE VNP ALLOC cmd returned 0x%x!\\n\",\n\t\t\t    FW_CMD_RETVAL_G(ntohl(rsp->alloc_to_len16)));\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tln->vnp_flowid = FW_FCOE_VNP_CMD_VNPI_GET(\n\t\t\t\tntohl(rsp->gen_wwn_to_vnpi));\n\tmemcpy(csio_ln_wwnn(ln), rsp->vnport_wwnn, 8);\n\tmemcpy(csio_ln_wwpn(ln), rsp->vnport_wwpn, 8);\n\n\tcsio_ln_dbg(ln, \"FCOE VNPI: 0x%x\\n\", ln->vnp_flowid);\n\tcsio_ln_dbg(ln, \"\\tWWNN: %x%x%x%x%x%x%x%x\\n\",\n\t\t    ln->ln_sparm.wwnn[0], ln->ln_sparm.wwnn[1],\n\t\t    ln->ln_sparm.wwnn[2], ln->ln_sparm.wwnn[3],\n\t\t    ln->ln_sparm.wwnn[4], ln->ln_sparm.wwnn[5],\n\t\t    ln->ln_sparm.wwnn[6], ln->ln_sparm.wwnn[7]);\n\tcsio_ln_dbg(ln, \"\\tWWPN: %x%x%x%x%x%x%x%x\\n\",\n\t\t    ln->ln_sparm.wwpn[0], ln->ln_sparm.wwpn[1],\n\t\t    ln->ln_sparm.wwpn[2], ln->ln_sparm.wwpn[3],\n\t\t    ln->ln_sparm.wwpn[4], ln->ln_sparm.wwpn[5],\n\t\t    ln->ln_sparm.wwpn[6], ln->ln_sparm.wwpn[7]);\n\nout_free:\n\tmempool_free(mbp, hw->mb_mempool);\nout:\n\tspin_unlock_irq(&hw->lock);\n\treturn ret;\n}\n\nstatic int\ncsio_fcoe_free_vnp(struct csio_hw *hw, struct csio_lnode *ln)\n{\n\tstruct csio_mb  *mbp;\n\tstruct fw_fcoe_vnp_cmd *rsp;\n\tint ret = 0;\n\tint retry = 0;\n\n\t \n\t \n\n\tspin_lock_irq(&hw->lock);\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcsio_fcoe_vnp_free_init_mb(ln, mbp, CSIO_MB_DEFAULT_TMO,\n\t\t\t\t   ln->fcf_flowid, ln->vnp_flowid,\n\t\t\t\t   NULL);\n\n\tfor (retry = 0; retry < 3; retry++) {\n\t\tret = csio_mb_issue(hw, mbp);\n\t\tif (ret != -EBUSY)\n\t\t\tbreak;\n\n\t\t \n\t\tspin_unlock_irq(&hw->lock);\n\t\tmsleep(2000);\n\t\tspin_lock_irq(&hw->lock);\n\t}\n\n\tif (ret) {\n\t\tcsio_ln_err(ln, \"Failed to issue mbox FCoE VNP command\\n\");\n\t\tgoto out_free;\n\t}\n\n\t \n\trsp = (struct fw_fcoe_vnp_cmd *)(mbp->mb);\n\tif (FW_CMD_RETVAL_G(ntohl(rsp->alloc_to_len16)) != FW_SUCCESS) {\n\t\tcsio_ln_err(ln, \"FCOE VNP FREE cmd returned 0x%x!\\n\",\n\t\t\t    FW_CMD_RETVAL_G(ntohl(rsp->alloc_to_len16)));\n\t\tret = -EINVAL;\n\t}\n\nout_free:\n\tmempool_free(mbp, hw->mb_mempool);\nout:\n\tspin_unlock_irq(&hw->lock);\n\treturn ret;\n}\n\nstatic int\ncsio_vport_create(struct fc_vport *fc_vport, bool disable)\n{\n\tstruct Scsi_Host *shost = fc_vport->shost;\n\tstruct csio_lnode *pln = shost_priv(shost);\n\tstruct csio_lnode *ln = NULL;\n\tstruct csio_hw *hw = csio_lnode_to_hw(pln);\n\tuint8_t wwn[8];\n\tint ret = -1;\n\n\tln = csio_shost_init(hw, &fc_vport->dev, false, pln);\n\tif (!ln)\n\t\tgoto error;\n\n\tif (fc_vport->node_name != 0) {\n\t\tu64_to_wwn(fc_vport->node_name, wwn);\n\n\t\tif (!CSIO_VALID_WWN(wwn)) {\n\t\t\tcsio_ln_err(ln,\n\t\t\t\t    \"vport create failed. Invalid wwnn\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(csio_ln_wwnn(ln), wwn, 8);\n\t}\n\n\tif (fc_vport->port_name != 0) {\n\t\tu64_to_wwn(fc_vport->port_name, wwn);\n\n\t\tif (!CSIO_VALID_WWN(wwn)) {\n\t\t\tcsio_ln_err(ln,\n\t\t\t\t    \"vport create failed. Invalid wwpn\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (csio_lnode_lookup_by_wwpn(hw, wwn)) {\n\t\t\tcsio_ln_err(ln,\n\t\t\t    \"vport create failed. wwpn already exists\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(csio_ln_wwpn(ln), wwn, 8);\n\t}\n\n\tfc_vport_set_state(fc_vport, FC_VPORT_INITIALIZING);\n\tln->fc_vport = fc_vport;\n\n\tif (csio_fcoe_alloc_vnp(hw, ln))\n\t\tgoto error;\n\n\t*(struct csio_lnode **)fc_vport->dd_data = ln;\n\tif (!fc_vport->node_name)\n\t\tfc_vport->node_name = wwn_to_u64(csio_ln_wwnn(ln));\n\tif (!fc_vport->port_name)\n\t\tfc_vport->port_name = wwn_to_u64(csio_ln_wwpn(ln));\n\tcsio_fchost_attr_init(ln);\n\treturn 0;\nerror:\n\tif (ln)\n\t\tcsio_shost_exit(ln);\n\n\treturn ret;\n}\n\nstatic int\ncsio_vport_delete(struct fc_vport *fc_vport)\n{\n\tstruct csio_lnode *ln = *(struct csio_lnode **)fc_vport->dd_data;\n\tstruct Scsi_Host *shost = csio_ln_to_shost(ln);\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\tint rmv;\n\n\tspin_lock_irq(&hw->lock);\n\trmv = csio_is_hw_removing(hw);\n\tspin_unlock_irq(&hw->lock);\n\n\tif (rmv) {\n\t\tcsio_shost_exit(ln);\n\t\treturn 0;\n\t}\n\n\t \n\tscsi_block_requests(shost);\n\tspin_lock_irq(&hw->lock);\n\tcsio_scsim_cleanup_io_lnode(csio_hw_to_scsim(hw), ln);\n\tcsio_lnode_close(ln);\n\tspin_unlock_irq(&hw->lock);\n\tscsi_unblock_requests(shost);\n\n\t \n\tif (fc_vport->vport_state !=  FC_VPORT_DISABLED)\n\t\tcsio_fcoe_free_vnp(hw, ln);\n\n\tcsio_shost_exit(ln);\n\treturn 0;\n}\n\nstatic int\ncsio_vport_disable(struct fc_vport *fc_vport, bool disable)\n{\n\tstruct csio_lnode *ln = *(struct csio_lnode **)fc_vport->dd_data;\n\tstruct Scsi_Host *shost = csio_ln_to_shost(ln);\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\n\t \n\tif (disable) {\n\t\t \n\t\tscsi_block_requests(shost);\n\t\tspin_lock_irq(&hw->lock);\n\t\tcsio_scsim_cleanup_io_lnode(csio_hw_to_scsim(hw), ln);\n\t\tcsio_lnode_stop(ln);\n\t\tspin_unlock_irq(&hw->lock);\n\t\tscsi_unblock_requests(shost);\n\n\t\t \n\t\tcsio_fcoe_free_vnp(hw, ln);\n\t\tfc_vport_set_state(fc_vport, FC_VPORT_DISABLED);\n\t\tcsio_ln_err(ln, \"vport disabled\\n\");\n\t\treturn 0;\n\t} else {\n\t\t \n\t\tfc_vport_set_state(fc_vport, FC_VPORT_INITIALIZING);\n\t\tif (csio_fcoe_alloc_vnp(hw, ln)) {\n\t\t\tcsio_ln_err(ln, \"vport enabled failed.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tcsio_ln_err(ln, \"vport enabled\\n\");\n\t\treturn 0;\n\t}\n}\n\nstatic void\ncsio_dev_loss_tmo_callbk(struct fc_rport *rport)\n{\n\tstruct csio_rnode *rn;\n\tstruct csio_hw *hw;\n\tstruct csio_lnode *ln;\n\n\trn = *((struct csio_rnode **)rport->dd_data);\n\tln = csio_rnode_to_lnode(rn);\n\thw = csio_lnode_to_hw(ln);\n\n\tspin_lock_irq(&hw->lock);\n\n\t \n\tif (csio_is_hw_removing(hw) || csio_is_rnode_ready(rn))\n\t\tgoto out;\n\n\tcsio_ln_dbg(ln, \"devloss timeout on rnode:%p portid:x%x flowid:x%x\\n\",\n\t\t    rn, rn->nport_id, csio_rn_flowid(rn));\n\n\tCSIO_INC_STATS(ln, n_dev_loss_tmo);\n\n\t \n\tif (csio_enqueue_evt(hw, CSIO_EVT_DEV_LOSS, &rn, sizeof(rn))) {\n\t\tCSIO_INC_STATS(hw, n_evt_drop);\n\t\tgoto out;\n\t}\n\n\tif (!(hw->flags & CSIO_HWF_FWEVT_PENDING)) {\n\t\thw->flags |= CSIO_HWF_FWEVT_PENDING;\n\t\tspin_unlock_irq(&hw->lock);\n\t\tschedule_work(&hw->evtq_work);\n\t\treturn;\n\t}\n\nout:\n\tspin_unlock_irq(&hw->lock);\n}\n\n \nstruct fc_function_template csio_fc_transport_funcs = {\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_maxframe_size = 1,\n\n\t.get_host_port_id = csio_get_host_port_id,\n\t.show_host_port_id = 1,\n\n\t.get_host_port_type = csio_get_host_port_type,\n\t.show_host_port_type = 1,\n\n\t.get_host_port_state = csio_get_host_port_state,\n\t.show_host_port_state = 1,\n\n\t.show_host_active_fc4s = 1,\n\t.get_host_speed = csio_get_host_speed,\n\t.show_host_speed = 1,\n\t.get_host_fabric_name = csio_get_host_fabric_name,\n\t.show_host_fabric_name = 1,\n\n\t.get_fc_host_stats = csio_get_stats,\n\n\t.dd_fcrport_size = sizeof(struct csio_rnode *),\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\n\t.set_rport_dev_loss_tmo = csio_set_rport_loss_tmo,\n\t.show_rport_dev_loss_tmo = 1,\n\n\t.show_starget_port_id = 1,\n\t.show_starget_node_name = 1,\n\t.show_starget_port_name = 1,\n\n\t.dev_loss_tmo_callbk = csio_dev_loss_tmo_callbk,\n\t.dd_fcvport_size = sizeof(struct csio_lnode *),\n\n\t.vport_create = csio_vport_create,\n\t.vport_disable = csio_vport_disable,\n\t.vport_delete = csio_vport_delete,\n};\n\n \nstruct fc_function_template csio_fc_transport_vport_funcs = {\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_maxframe_size = 1,\n\n\t.get_host_port_id = csio_get_host_port_id,\n\t.show_host_port_id = 1,\n\n\t.get_host_port_type = csio_get_host_port_type,\n\t.show_host_port_type = 1,\n\n\t.get_host_port_state = csio_get_host_port_state,\n\t.show_host_port_state = 1,\n\t.show_host_active_fc4s = 1,\n\n\t.get_host_speed = csio_get_host_speed,\n\t.show_host_speed = 1,\n\n\t.get_host_fabric_name = csio_get_host_fabric_name,\n\t.show_host_fabric_name = 1,\n\n\t.get_fc_host_stats = csio_get_stats,\n\n\t.dd_fcrport_size = sizeof(struct csio_rnode *),\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\n\t.set_rport_dev_loss_tmo = csio_set_rport_loss_tmo,\n\t.show_rport_dev_loss_tmo = 1,\n\n\t.show_starget_port_id = 1,\n\t.show_starget_node_name = 1,\n\t.show_starget_port_name = 1,\n\n\t.dev_loss_tmo_callbk = csio_dev_loss_tmo_callbk,\n\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}