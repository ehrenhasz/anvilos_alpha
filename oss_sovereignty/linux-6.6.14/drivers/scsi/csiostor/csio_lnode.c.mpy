{
  "module_name": "csio_lnode.c",
  "hash_id": "4263e14b3f18c5c1b327357df7c07ec034b2cb0b8214e0cdf5fefe12edb44e1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/csiostor/csio_lnode.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_transport_fc.h>\n#include <asm/unaligned.h>\n#include <scsi/fc/fc_els.h>\n#include <scsi/fc/fc_fs.h>\n#include <scsi/fc/fc_gs.h>\n#include <scsi/fc/fc_ms.h>\n\n#include \"csio_hw.h\"\n#include \"csio_mb.h\"\n#include \"csio_lnode.h\"\n#include \"csio_rnode.h\"\n\nint csio_fcoe_rnodes = 1024;\nint csio_fdmi_enable = 1;\n\n#define PORT_ID_PTR(_x)         ((uint8_t *)(&_x) + 1)\n\n \nstatic void csio_lns_uninit(struct csio_lnode *, enum csio_ln_ev);\nstatic void csio_lns_online(struct csio_lnode *, enum csio_ln_ev);\nstatic void csio_lns_ready(struct csio_lnode *, enum csio_ln_ev);\nstatic void csio_lns_offline(struct csio_lnode *, enum csio_ln_ev);\n\nstatic int csio_ln_mgmt_submit_req(struct csio_ioreq *,\n\t\tvoid (*io_cbfn) (struct csio_hw *, struct csio_ioreq *),\n\t\tenum fcoe_cmn_type, struct csio_dma_buf *, uint32_t);\n\n \nstatic enum csio_ln_ev fwevt_to_lnevt[] = {\n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_LOGO,\t\t \n\tCSIO_LNE_LOGO,\t\t \n\tCSIO_LNE_FAB_INIT_DONE, \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_FAB_INIT_DONE, \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n\tCSIO_LNE_NONE,\t\t \n};\n\n#define CSIO_FWE_TO_LNE(_evt)\t((_evt > PROTO_ERR_IMPL_LOGO) ?\t\t\\\n\t\t\t\t\t\tCSIO_LNE_NONE :\t\\\n\t\t\t\t\t\tfwevt_to_lnevt[_evt])\n\n#define csio_ct_rsp(cp)\t\t(((struct fc_ct_hdr *)cp)->ct_cmd)\n#define csio_ct_reason(cp)\t(((struct fc_ct_hdr *)cp)->ct_reason)\n#define csio_ct_expl(cp)\t(((struct fc_ct_hdr *)cp)->ct_explan)\n#define csio_ct_get_pld(cp)\t((void *)(((uint8_t *)cp) + FC_CT_HDR_LEN))\n\n \nstatic struct csio_lnode *\ncsio_ln_lookup_by_portid(struct csio_hw *hw, uint8_t portid)\n{\n\tstruct csio_lnode *ln;\n\tstruct list_head *tmp;\n\n\t \n\tlist_for_each(tmp, &hw->sln_head) {\n\t\tln = (struct csio_lnode *) tmp;\n\t\tif (ln->portid == portid)\n\t\t\treturn ln;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct csio_lnode *\ncsio_ln_lookup_by_vnpi(struct csio_hw *hw, uint32_t vnp_id)\n{\n\tstruct list_head *tmp1, *tmp2;\n\tstruct csio_lnode *sln = NULL, *cln = NULL;\n\n\tif (list_empty(&hw->sln_head)) {\n\t\tCSIO_INC_STATS(hw, n_lnlkup_miss);\n\t\treturn NULL;\n\t}\n\t \n\tlist_for_each(tmp1, &hw->sln_head) {\n\t\tsln = (struct csio_lnode *) tmp1;\n\n\t\t \n\t\tif (sln->vnp_flowid == vnp_id)\n\t\t\treturn sln;\n\n\t\tif (list_empty(&sln->cln_head))\n\t\t\tcontinue;\n\n\t\t \n\t\tlist_for_each(tmp2, &sln->cln_head) {\n\t\t\tcln = (struct csio_lnode *) tmp2;\n\n\t\t\tif (cln->vnp_flowid == vnp_id)\n\t\t\t\treturn cln;\n\t\t}\n\t}\n\tCSIO_INC_STATS(hw, n_lnlkup_miss);\n\treturn NULL;\n}\n\n \nstruct csio_lnode *\ncsio_lnode_lookup_by_wwpn(struct csio_hw *hw, uint8_t *wwpn)\n{\n\tstruct list_head *tmp1, *tmp2;\n\tstruct csio_lnode *sln = NULL, *cln = NULL;\n\n\tif (list_empty(&hw->sln_head)) {\n\t\tCSIO_INC_STATS(hw, n_lnlkup_miss);\n\t\treturn NULL;\n\t}\n\t \n\tlist_for_each(tmp1, &hw->sln_head) {\n\t\tsln = (struct csio_lnode *) tmp1;\n\n\t\t \n\t\tif (!memcmp(csio_ln_wwpn(sln), wwpn, 8))\n\t\t\treturn sln;\n\n\t\tif (list_empty(&sln->cln_head))\n\t\t\tcontinue;\n\n\t\t \n\t\tlist_for_each(tmp2, &sln->cln_head) {\n\t\t\tcln = (struct csio_lnode *) tmp2;\n\n\t\t\tif (!memcmp(csio_ln_wwpn(cln), wwpn, 8))\n\t\t\t\treturn cln;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic void\ncsio_fill_ct_iu(void *buf, uint8_t type, uint8_t sub_type, uint16_t op)\n{\n\tstruct fc_ct_hdr *cmd = (struct fc_ct_hdr *)buf;\n\tcmd->ct_rev = FC_CT_REV;\n\tcmd->ct_fs_type = type;\n\tcmd->ct_fs_subtype = sub_type;\n\tcmd->ct_cmd = htons(op);\n}\n\nstatic int\ncsio_hostname(uint8_t *buf, size_t buf_len)\n{\n\tif (snprintf(buf, buf_len, \"%s\", init_utsname()->nodename) > 0)\n\t\treturn 0;\n\treturn -1;\n}\n\nstatic int\ncsio_osname(uint8_t *buf, size_t buf_len)\n{\n\tif (snprintf(buf, buf_len, \"%s %s %s\",\n\t\t     init_utsname()->sysname,\n\t\t     init_utsname()->release,\n\t\t     init_utsname()->version) > 0)\n\t\treturn 0;\n\n\treturn -1;\n}\n\nstatic inline void\ncsio_append_attrib(uint8_t **ptr, uint16_t type, void *val, size_t val_len)\n{\n\tuint16_t len;\n\tstruct fc_fdmi_attr_entry *ae = (struct fc_fdmi_attr_entry *)*ptr;\n\n\tif (WARN_ON(val_len > U16_MAX))\n\t\treturn;\n\n\tlen = val_len;\n\n\tae->type = htons(type);\n\tlen += 4;\t\t \n\tlen = (len + 3) & ~3;\t \n\tae->len = htons(len);\n\tmemcpy(ae->value, val, val_len);\n\tif (len > val_len)\n\t\tmemset(ae->value + val_len, 0, len - val_len);\n\t*ptr += len;\n}\n\n \nstatic void\ncsio_ln_fdmi_done(struct csio_hw *hw, struct csio_ioreq *fdmi_req)\n{\n\tvoid *cmd;\n\tstruct csio_lnode *ln = fdmi_req->lnode;\n\n\tif (fdmi_req->wr_status != FW_SUCCESS) {\n\t\tcsio_ln_dbg(ln, \"WR error:%x in processing fdmi rpa cmd\\n\",\n\t\t\t    fdmi_req->wr_status);\n\t\tCSIO_INC_STATS(ln, n_fdmi_err);\n\t}\n\n\tcmd = fdmi_req->dma_buf.vaddr;\n\tif (ntohs(csio_ct_rsp(cmd)) != FC_FS_ACC) {\n\t\tcsio_ln_dbg(ln, \"fdmi rpa cmd rejected reason %x expl %x\\n\",\n\t\t\t    csio_ct_reason(cmd), csio_ct_expl(cmd));\n\t}\n}\n\n \nstatic void\ncsio_ln_fdmi_rhba_cbfn(struct csio_hw *hw, struct csio_ioreq *fdmi_req)\n{\n\tvoid *cmd;\n\tuint8_t *pld;\n\tuint32_t len = 0;\n\t__be32 val;\n\t__be16 mfs;\n\tuint32_t numattrs = 0;\n\tstruct csio_lnode *ln = fdmi_req->lnode;\n\tstruct fs_fdmi_attrs *attrib_blk;\n\tstruct fc_fdmi_port_name *port_name;\n\tuint8_t buf[64];\n\tuint8_t *fc4_type;\n\tunsigned long flags;\n\n\tif (fdmi_req->wr_status != FW_SUCCESS) {\n\t\tcsio_ln_dbg(ln, \"WR error:%x in processing fdmi rhba cmd\\n\",\n\t\t\t    fdmi_req->wr_status);\n\t\tCSIO_INC_STATS(ln, n_fdmi_err);\n\t}\n\n\tcmd = fdmi_req->dma_buf.vaddr;\n\tif (ntohs(csio_ct_rsp(cmd)) != FC_FS_ACC) {\n\t\tcsio_ln_dbg(ln, \"fdmi rhba cmd rejected reason %x expl %x\\n\",\n\t\t\t    csio_ct_reason(cmd), csio_ct_expl(cmd));\n\t}\n\n\tif (!csio_is_rnode_ready(fdmi_req->rnode)) {\n\t\tCSIO_INC_STATS(ln, n_fdmi_err);\n\t\treturn;\n\t}\n\n\t \n\tmemset(cmd, 0, FC_CT_HDR_LEN);\n\tcsio_fill_ct_iu(cmd, FC_FST_MGMT, FC_FDMI_SUBTYPE, FC_FDMI_RPA);\n\n\t \n\tpld = (uint8_t *)csio_ct_get_pld(cmd);\n\tport_name = (struct fc_fdmi_port_name *)pld;\n\tmemcpy(&port_name->portname, csio_ln_wwpn(ln), 8);\n\tpld += sizeof(*port_name);\n\n\t \n\tattrib_blk = (struct fs_fdmi_attrs *)pld;\n\tattrib_blk->numattrs = 0;\n\tlen += sizeof(attrib_blk->numattrs);\n\tpld += sizeof(attrib_blk->numattrs);\n\n\tfc4_type = &buf[0];\n\tmemset(fc4_type, 0, FC_FDMI_PORT_ATTR_FC4TYPES_LEN);\n\tfc4_type[2] = 1;\n\tfc4_type[7] = 1;\n\tcsio_append_attrib(&pld, FC_FDMI_PORT_ATTR_FC4TYPES,\n\t\t\t   fc4_type, FC_FDMI_PORT_ATTR_FC4TYPES_LEN);\n\tnumattrs++;\n\tval = htonl(FC_PORTSPEED_1GBIT | FC_PORTSPEED_10GBIT);\n\tcsio_append_attrib(&pld, FC_FDMI_PORT_ATTR_SUPPORTEDSPEED,\n\t\t\t   &val,\n\t\t\t   FC_FDMI_PORT_ATTR_SUPPORTEDSPEED_LEN);\n\tnumattrs++;\n\n\tif (hw->pport[ln->portid].link_speed == FW_PORT_CAP_SPEED_1G)\n\t\tval = htonl(FC_PORTSPEED_1GBIT);\n\telse if (hw->pport[ln->portid].link_speed == FW_PORT_CAP_SPEED_10G)\n\t\tval = htonl(FC_PORTSPEED_10GBIT);\n\telse if (hw->pport[ln->portid].link_speed == FW_PORT_CAP32_SPEED_25G)\n\t\tval = htonl(FC_PORTSPEED_25GBIT);\n\telse if (hw->pport[ln->portid].link_speed == FW_PORT_CAP32_SPEED_40G)\n\t\tval = htonl(FC_PORTSPEED_40GBIT);\n\telse if (hw->pport[ln->portid].link_speed == FW_PORT_CAP32_SPEED_50G)\n\t\tval = htonl(FC_PORTSPEED_50GBIT);\n\telse if (hw->pport[ln->portid].link_speed == FW_PORT_CAP32_SPEED_100G)\n\t\tval = htonl(FC_PORTSPEED_100GBIT);\n\telse\n\t\tval = htonl(CSIO_HBA_PORTSPEED_UNKNOWN);\n\tcsio_append_attrib(&pld, FC_FDMI_PORT_ATTR_CURRENTPORTSPEED,\n\t\t\t   &val, FC_FDMI_PORT_ATTR_CURRENTPORTSPEED_LEN);\n\tnumattrs++;\n\n\tmfs = ln->ln_sparm.csp.sp_bb_data;\n\tcsio_append_attrib(&pld, FC_FDMI_PORT_ATTR_MAXFRAMESIZE,\n\t\t\t   &mfs, sizeof(mfs));\n\tnumattrs++;\n\n\tstrcpy(buf, \"csiostor\");\n\tcsio_append_attrib(&pld, FC_FDMI_PORT_ATTR_OSDEVICENAME, buf,\n\t\t\t   strlen(buf));\n\tnumattrs++;\n\n\tif (!csio_hostname(buf, sizeof(buf))) {\n\t\tcsio_append_attrib(&pld, FC_FDMI_PORT_ATTR_HOSTNAME,\n\t\t\t\t   buf, strlen(buf));\n\t\tnumattrs++;\n\t}\n\tattrib_blk->numattrs = htonl(numattrs);\n\tlen = (uint32_t)(pld - (uint8_t *)cmd);\n\n\t \n\tspin_lock_irqsave(&hw->lock, flags);\n\tif (csio_ln_mgmt_submit_req(fdmi_req, csio_ln_fdmi_done,\n\t\t\t\tFCOE_CT, &fdmi_req->dma_buf, len)) {\n\t\tCSIO_INC_STATS(ln, n_fdmi_err);\n\t\tcsio_ln_dbg(ln, \"Failed to issue fdmi rpa req\\n\");\n\t}\n\tspin_unlock_irqrestore(&hw->lock, flags);\n}\n\n \nstatic void\ncsio_ln_fdmi_dprt_cbfn(struct csio_hw *hw, struct csio_ioreq *fdmi_req)\n{\n\tvoid *cmd;\n\tuint8_t *pld;\n\tuint32_t len = 0;\n\tuint32_t numattrs = 0;\n\t__be32  maxpayload = htonl(65536);\n\tstruct fc_fdmi_hba_identifier *hbaid;\n\tstruct csio_lnode *ln = fdmi_req->lnode;\n\tstruct fc_fdmi_rpl *reg_pl;\n\tstruct fs_fdmi_attrs *attrib_blk;\n\tuint8_t buf[64];\n\tunsigned long flags;\n\n\tif (fdmi_req->wr_status != FW_SUCCESS) {\n\t\tcsio_ln_dbg(ln, \"WR error:%x in processing fdmi dprt cmd\\n\",\n\t\t\t    fdmi_req->wr_status);\n\t\tCSIO_INC_STATS(ln, n_fdmi_err);\n\t}\n\n\tif (!csio_is_rnode_ready(fdmi_req->rnode)) {\n\t\tCSIO_INC_STATS(ln, n_fdmi_err);\n\t\treturn;\n\t}\n\tcmd = fdmi_req->dma_buf.vaddr;\n\tif (ntohs(csio_ct_rsp(cmd)) != FC_FS_ACC) {\n\t\tcsio_ln_dbg(ln, \"fdmi dprt cmd rejected reason %x expl %x\\n\",\n\t\t\t    csio_ct_reason(cmd), csio_ct_expl(cmd));\n\t}\n\n\t \n\tmemset(cmd, 0, FC_CT_HDR_LEN);\n\tcsio_fill_ct_iu(cmd, FC_FST_MGMT, FC_FDMI_SUBTYPE, FC_FDMI_RHBA);\n\tlen = FC_CT_HDR_LEN;\n\n\t \n\tpld = (uint8_t *)csio_ct_get_pld(cmd);\n\thbaid = (struct fc_fdmi_hba_identifier *)pld;\n\tmemcpy(&hbaid->id, csio_ln_wwpn(ln), 8);  \n\tpld += sizeof(*hbaid);\n\n\t \n\treg_pl = (struct fc_fdmi_rpl *)pld;\n\treg_pl->numport = htonl(1);\n\tmemcpy(&reg_pl->port[0].portname, csio_ln_wwpn(ln), 8);\n\tpld += sizeof(*reg_pl);\n\n\t \n\tattrib_blk = (struct fs_fdmi_attrs *)pld;\n\tattrib_blk->numattrs = 0;\n\tlen += sizeof(attrib_blk->numattrs);\n\tpld += sizeof(attrib_blk->numattrs);\n\n\tcsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_NODENAME, csio_ln_wwnn(ln),\n\t\t\t   FC_FDMI_HBA_ATTR_NODENAME_LEN);\n\tnumattrs++;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tstrcpy(buf, \"Chelsio Communications\");\n\tcsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_MANUFACTURER, buf,\n\t\t\t   strlen(buf));\n\tnumattrs++;\n\tcsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_SERIALNUMBER,\n\t\t\t   hw->vpd.sn, sizeof(hw->vpd.sn));\n\tnumattrs++;\n\tcsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_MODEL, hw->vpd.id,\n\t\t\t   sizeof(hw->vpd.id));\n\tnumattrs++;\n\tcsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_MODELDESCRIPTION,\n\t\t\t   hw->model_desc, strlen(hw->model_desc));\n\tnumattrs++;\n\tcsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_HARDWAREVERSION,\n\t\t\t   hw->hw_ver, sizeof(hw->hw_ver));\n\tnumattrs++;\n\tcsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_FIRMWAREVERSION,\n\t\t\t   hw->fwrev_str, strlen(hw->fwrev_str));\n\tnumattrs++;\n\n\tif (!csio_osname(buf, sizeof(buf))) {\n\t\tcsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_OSNAMEVERSION,\n\t\t\t\t   buf, strlen(buf));\n\t\tnumattrs++;\n\t}\n\n\tcsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_MAXCTPAYLOAD,\n\t\t\t   &maxpayload, FC_FDMI_HBA_ATTR_MAXCTPAYLOAD_LEN);\n\tlen = (uint32_t)(pld - (uint8_t *)cmd);\n\tnumattrs++;\n\tattrib_blk->numattrs = htonl(numattrs);\n\n\t \n\tspin_lock_irqsave(&hw->lock, flags);\n\tif (csio_ln_mgmt_submit_req(fdmi_req, csio_ln_fdmi_rhba_cbfn,\n\t\t\t\tFCOE_CT, &fdmi_req->dma_buf, len)) {\n\t\tCSIO_INC_STATS(ln, n_fdmi_err);\n\t\tcsio_ln_dbg(ln, \"Failed to issue fdmi rhba req\\n\");\n\t}\n\tspin_unlock_irqrestore(&hw->lock, flags);\n}\n\n \nstatic void\ncsio_ln_fdmi_dhba_cbfn(struct csio_hw *hw, struct csio_ioreq *fdmi_req)\n{\n\tstruct csio_lnode *ln = fdmi_req->lnode;\n\tvoid *cmd;\n\tstruct fc_fdmi_port_name *port_name;\n\tuint32_t len;\n\tunsigned long flags;\n\n\tif (fdmi_req->wr_status != FW_SUCCESS) {\n\t\tcsio_ln_dbg(ln, \"WR error:%x in processing fdmi dhba cmd\\n\",\n\t\t\t    fdmi_req->wr_status);\n\t\tCSIO_INC_STATS(ln, n_fdmi_err);\n\t}\n\n\tif (!csio_is_rnode_ready(fdmi_req->rnode)) {\n\t\tCSIO_INC_STATS(ln, n_fdmi_err);\n\t\treturn;\n\t}\n\tcmd = fdmi_req->dma_buf.vaddr;\n\tif (ntohs(csio_ct_rsp(cmd)) != FC_FS_ACC) {\n\t\tcsio_ln_dbg(ln, \"fdmi dhba cmd rejected reason %x expl %x\\n\",\n\t\t\t    csio_ct_reason(cmd), csio_ct_expl(cmd));\n\t}\n\n\t \n\n\t \n\tmemset(cmd, 0, FC_CT_HDR_LEN);\n\tcsio_fill_ct_iu(cmd, FC_FST_MGMT, FC_FDMI_SUBTYPE, FC_FDMI_DPRT);\n\tlen = FC_CT_HDR_LEN;\n\tport_name = (struct fc_fdmi_port_name *)csio_ct_get_pld(cmd);\n\tmemcpy(&port_name->portname, csio_ln_wwpn(ln), 8);\n\tlen += sizeof(*port_name);\n\n\t \n\tspin_lock_irqsave(&hw->lock, flags);\n\tif (csio_ln_mgmt_submit_req(fdmi_req, csio_ln_fdmi_dprt_cbfn,\n\t\t\t\tFCOE_CT, &fdmi_req->dma_buf, len)) {\n\t\tCSIO_INC_STATS(ln, n_fdmi_err);\n\t\tcsio_ln_dbg(ln, \"Failed to issue fdmi dprt req\\n\");\n\t}\n\tspin_unlock_irqrestore(&hw->lock, flags);\n}\n\n \nint\ncsio_ln_fdmi_start(struct csio_lnode *ln, void *context)\n{\n\tstruct csio_ioreq *fdmi_req;\n\tstruct csio_rnode *fdmi_rn = (struct csio_rnode *)context;\n\tvoid *cmd;\n\tstruct fc_fdmi_hba_identifier *hbaid;\n\tuint32_t len;\n\n\tif (!(ln->flags & CSIO_LNF_FDMI_ENABLE))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (!csio_is_rnode_ready(fdmi_rn))\n\t\tCSIO_INC_STATS(ln, n_fdmi_err);\n\n\t \n\n\tfdmi_req = ln->mgmt_req;\n\tfdmi_req->lnode = ln;\n\tfdmi_req->rnode = fdmi_rn;\n\n\t \n\tcmd = fdmi_req->dma_buf.vaddr;\n\tmemset(cmd, 0, FC_CT_HDR_LEN);\n\tcsio_fill_ct_iu(cmd, FC_FST_MGMT, FC_FDMI_SUBTYPE, FC_FDMI_DHBA);\n\tlen = FC_CT_HDR_LEN;\n\n\thbaid = (struct fc_fdmi_hba_identifier *)csio_ct_get_pld(cmd);\n\tmemcpy(&hbaid->id, csio_ln_wwpn(ln), 8);\n\tlen += sizeof(*hbaid);\n\n\t \n\tif (csio_ln_mgmt_submit_req(fdmi_req, csio_ln_fdmi_dhba_cbfn,\n\t\t\t\t\tFCOE_CT, &fdmi_req->dma_buf, len)) {\n\t\tCSIO_INC_STATS(ln, n_fdmi_err);\n\t\tcsio_ln_dbg(ln, \"Failed to issue fdmi dhba req\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\ncsio_ln_vnp_read_cbfn(struct csio_hw *hw, struct csio_mb *mbp)\n{\n\tstruct csio_lnode *ln = ((struct csio_lnode *)mbp->priv);\n\tstruct fw_fcoe_vnp_cmd *rsp = (struct fw_fcoe_vnp_cmd *)(mbp->mb);\n\tstruct fc_els_csp *csp;\n\tstruct fc_els_cssp *clsp;\n\tenum fw_retval retval;\n\t__be32 nport_id = 0;\n\n\tretval = FW_CMD_RETVAL_G(ntohl(rsp->alloc_to_len16));\n\tif (retval != FW_SUCCESS) {\n\t\tcsio_err(hw, \"FCOE VNP read cmd returned error:0x%x\\n\", retval);\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&hw->lock);\n\n\tmemcpy(ln->mac, rsp->vnport_mac, sizeof(ln->mac));\n\tmemcpy(&nport_id, &rsp->vnport_mac[3], sizeof(uint8_t)*3);\n\tln->nport_id = ntohl(nport_id);\n\tln->nport_id = ln->nport_id >> 8;\n\n\t \n\t \n\tmemcpy(csio_ln_wwnn(ln), rsp->vnport_wwnn, 8);\n\tmemcpy(csio_ln_wwpn(ln), rsp->vnport_wwpn, 8);\n\n\t \n\tcsp = (struct fc_els_csp *)rsp->cmn_srv_parms;\n\tln->ln_sparm.csp.sp_hi_ver = csp->sp_hi_ver;\n\tln->ln_sparm.csp.sp_lo_ver = csp->sp_lo_ver;\n\tln->ln_sparm.csp.sp_bb_cred = csp->sp_bb_cred;\n\tln->ln_sparm.csp.sp_features = csp->sp_features;\n\tln->ln_sparm.csp.sp_bb_data = csp->sp_bb_data;\n\tln->ln_sparm.csp.sp_r_a_tov = csp->sp_r_a_tov;\n\tln->ln_sparm.csp.sp_e_d_tov = csp->sp_e_d_tov;\n\n\t \n\tclsp = (struct fc_els_cssp *)rsp->clsp_word_0_1;\n\tln->ln_sparm.clsp[2].cp_class = clsp->cp_class;\n\tln->ln_sparm.clsp[2].cp_init = clsp->cp_init;\n\tln->ln_sparm.clsp[2].cp_recip = clsp->cp_recip;\n\tln->ln_sparm.clsp[2].cp_rdfs = clsp->cp_rdfs;\n\n\tspin_unlock_irq(&hw->lock);\n\n\tmempool_free(mbp, hw->mb_mempool);\n\n\t \n\tcsio_lnode_async_event(ln, CSIO_LN_FC_ATTRIB_UPDATE);\n}\n\n \nstatic int\ncsio_ln_vnp_read(struct csio_lnode *ln,\n\t\tvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct csio_hw *hw = ln->hwp;\n\tstruct csio_mb  *mbp;\n\n\t \n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tcsio_fcoe_vnp_read_init_mb(ln, mbp,\n\t\t\t\t    CSIO_MB_DEFAULT_TMO,\n\t\t\t\t    ln->fcf_flowid,\n\t\t\t\t    ln->vnp_flowid,\n\t\t\t\t    cbfn);\n\n\t \n\tif (csio_mb_issue(hw, mbp)) {\n\t\tcsio_err(hw, \"Failed to issue mbox FCoE VNP command\\n\");\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\ncsio_fcoe_enable_link(struct csio_lnode *ln, bool enable)\n{\n\tstruct csio_hw *hw = ln->hwp;\n\tstruct csio_mb  *mbp;\n\tenum fw_retval retval;\n\tuint8_t portid;\n\tuint8_t sub_op;\n\tstruct fw_fcoe_link_cmd *lcmd;\n\tint i;\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\treturn -ENOMEM;\n\t}\n\n\tportid = ln->portid;\n\tsub_op = enable ? FCOE_LINK_UP : FCOE_LINK_DOWN;\n\n\tcsio_dbg(hw, \"bringing FCOE LINK %s on Port:%d\\n\",\n\t\t sub_op ? \"UP\" : \"DOWN\", portid);\n\n\tcsio_write_fcoe_link_cond_init_mb(ln, mbp, CSIO_MB_DEFAULT_TMO,\n\t\t\t\t\t  portid, sub_op, 0, 0, 0, NULL);\n\n\tif (csio_mb_issue(hw, mbp)) {\n\t\tcsio_err(hw, \"failed to issue FCOE LINK cmd on port[%d]\\n\",\n\t\t\tportid);\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\tretval = csio_mb_fw_retval(mbp);\n\tif (retval != FW_SUCCESS) {\n\t\tcsio_err(hw,\n\t\t\t \"FCOE LINK %s cmd on port[%d] failed with \"\n\t\t\t \"ret:x%x\\n\", sub_op ? \"UP\" : \"DOWN\", portid, retval);\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!enable)\n\t\tgoto out;\n\n\tlcmd = (struct fw_fcoe_link_cmd *)mbp->mb;\n\n\tmemcpy(csio_ln_wwnn(ln), lcmd->vnport_wwnn, 8);\n\tmemcpy(csio_ln_wwpn(ln), lcmd->vnport_wwpn, 8);\n\n\tfor (i = 0; i < CSIO_MAX_PPORTS; i++)\n\t\tif (hw->pport[i].portid == portid)\n\t\t\tmemcpy(hw->pport[i].mac, lcmd->phy_mac, 6);\n\nout:\n\tmempool_free(mbp, hw->mb_mempool);\n\treturn 0;\n}\n\n \nstatic void\ncsio_ln_read_fcf_cbfn(struct csio_hw *hw, struct csio_mb *mbp)\n{\n\tstruct csio_lnode *ln = (struct csio_lnode *)mbp->priv;\n\tstruct csio_fcf_info\t*fcf_info;\n\tstruct fw_fcoe_fcf_cmd *rsp =\n\t\t\t\t(struct fw_fcoe_fcf_cmd *)(mbp->mb);\n\tenum fw_retval retval;\n\n\tretval = FW_CMD_RETVAL_G(ntohl(rsp->retval_len16));\n\tif (retval != FW_SUCCESS) {\n\t\tcsio_ln_err(ln, \"FCOE FCF cmd failed with ret x%x\\n\",\n\t\t\t\tretval);\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&hw->lock);\n\tfcf_info = ln->fcfinfo;\n\tfcf_info->priority = FW_FCOE_FCF_CMD_PRIORITY_GET(\n\t\t\t\t\tntohs(rsp->priority_pkd));\n\tfcf_info->vf_id = ntohs(rsp->vf_id);\n\tfcf_info->vlan_id = rsp->vlan_id;\n\tfcf_info->max_fcoe_size = ntohs(rsp->max_fcoe_size);\n\tfcf_info->fka_adv = be32_to_cpu(rsp->fka_adv);\n\tfcf_info->fcfi = FW_FCOE_FCF_CMD_FCFI_GET(ntohl(rsp->op_to_fcfi));\n\tfcf_info->fpma = FW_FCOE_FCF_CMD_FPMA_GET(rsp->fpma_to_portid);\n\tfcf_info->spma = FW_FCOE_FCF_CMD_SPMA_GET(rsp->fpma_to_portid);\n\tfcf_info->login = FW_FCOE_FCF_CMD_LOGIN_GET(rsp->fpma_to_portid);\n\tfcf_info->portid = FW_FCOE_FCF_CMD_PORTID_GET(rsp->fpma_to_portid);\n\tmemcpy(fcf_info->fc_map, rsp->fc_map, sizeof(fcf_info->fc_map));\n\tmemcpy(fcf_info->mac, rsp->mac, sizeof(fcf_info->mac));\n\tmemcpy(fcf_info->name_id, rsp->name_id, sizeof(fcf_info->name_id));\n\tmemcpy(fcf_info->fabric, rsp->fabric, sizeof(fcf_info->fabric));\n\tmemcpy(fcf_info->spma_mac, rsp->spma_mac, sizeof(fcf_info->spma_mac));\n\n\tspin_unlock_irq(&hw->lock);\n\n\tmempool_free(mbp, hw->mb_mempool);\n}\n\n \nstatic int\ncsio_ln_read_fcf_entry(struct csio_lnode *ln,\n\t\t\tvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\n{\n\tstruct csio_hw *hw = ln->hwp;\n\tstruct csio_mb  *mbp;\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tcsio_fcoe_read_fcf_init_mb(ln, mbp, CSIO_MB_DEFAULT_TMO,\n\t\t\t\t      ln->portid, ln->fcf_flowid, cbfn);\n\n\tif (csio_mb_issue(hw, mbp)) {\n\t\tcsio_err(hw, \"failed to issue FCOE FCF cmd\\n\");\n\t\tmempool_free(mbp, hw->mb_mempool);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\ncsio_handle_link_up(struct csio_hw *hw, uint8_t portid, uint32_t fcfi,\n\t\t    uint32_t vnpi)\n{\n\tstruct csio_lnode *ln = NULL;\n\n\t \n\tln = csio_ln_lookup_by_vnpi(hw, vnpi);\n\tif (!ln) {\n\t\t \n\t\tln = csio_ln_lookup_by_portid(hw, portid);\n\t\tif (!ln) {\n\t\t\tcsio_err(hw, \"failed to lookup fcoe lnode on port:%d\\n\",\n\t\t\t\tportid);\n\t\t\tCSIO_DB_ASSERT(0);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (ln->vnp_flowid != CSIO_INVALID_IDX) {\n\t\t\t \n\t\t\tspin_unlock_irq(&hw->lock);\n\t\t\tcsio_lnode_alloc(hw);\n\t\t\tspin_lock_irq(&hw->lock);\n\t\t\tif (!ln) {\n\t\t\t\tcsio_err(hw,\n\t\t\t\t\t \"failed to allocate fcoe lnode\"\n\t\t\t\t\t \"for port:%d vnpi:x%x\\n\",\n\t\t\t\t\t portid, vnpi);\n\t\t\t\tCSIO_DB_ASSERT(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tln->portid = portid;\n\t\t}\n\t\tln->vnp_flowid = vnpi;\n\t\tln->dev_num &= ~0xFFFF;\n\t\tln->dev_num |= vnpi;\n\t}\n\n\t \n\tln->fcf_flowid = fcfi;\n\n\tcsio_info(hw, \"Port:%d - FCOE LINK UP\\n\", portid);\n\n\tCSIO_INC_STATS(ln, n_link_up);\n\n\t \n\tcsio_post_event(&ln->sm, CSIO_LNE_LINKUP);\n}\n\n \nstatic void\ncsio_post_event_rns(struct csio_lnode *ln, enum csio_rn_ev evt)\n{\n\tstruct csio_rnode *rnhead = (struct csio_rnode *) &ln->rnhead;\n\tstruct list_head *tmp, *next;\n\tstruct csio_rnode *rn;\n\n\tlist_for_each_safe(tmp, next, &rnhead->sm.sm_list) {\n\t\trn = (struct csio_rnode *) tmp;\n\t\tcsio_post_event(&rn->sm, evt);\n\t}\n}\n\n \nstatic void\ncsio_cleanup_rns(struct csio_lnode *ln)\n{\n\tstruct csio_rnode *rnhead = (struct csio_rnode *) &ln->rnhead;\n\tstruct list_head *tmp, *next_rn;\n\tstruct csio_rnode *rn;\n\n\tlist_for_each_safe(tmp, next_rn, &rnhead->sm.sm_list) {\n\t\trn = (struct csio_rnode *) tmp;\n\t\tcsio_put_rnode(ln, rn);\n\t}\n\n}\n\n \nstatic void\ncsio_post_event_lns(struct csio_lnode *ln, enum csio_ln_ev evt)\n{\n\tstruct list_head *tmp;\n\tstruct csio_lnode *cln, *sln;\n\n\t \n\tif (csio_is_npiv_ln(ln)) {\n\t\tcsio_post_event(&ln->sm, evt);\n\t\treturn;\n\t}\n\n\tsln = ln;\n\t \n\tlist_for_each(tmp, &sln->cln_head) {\n\t\tcln = (struct csio_lnode *) tmp;\n\t\tcsio_post_event(&cln->sm, evt);\n\t}\n\n\t \n\tcsio_post_event(&ln->sm, evt);\n}\n\n \nstatic void\ncsio_ln_down(struct csio_lnode *ln)\n{\n\tcsio_post_event_lns(ln, CSIO_LNE_LINK_DOWN);\n}\n\n \nstatic void\ncsio_handle_link_down(struct csio_hw *hw, uint8_t portid, uint32_t fcfi,\n\t\t      uint32_t vnpi)\n{\n\tstruct csio_fcf_info *fp;\n\tstruct csio_lnode *ln;\n\n\t \n\tln = csio_ln_lookup_by_vnpi(hw, vnpi);\n\tif (ln) {\n\t\tfp = ln->fcfinfo;\n\t\tCSIO_INC_STATS(ln, n_link_down);\n\n\t\t \n\t\tif (!csio_is_lnode_ready(ln)) {\n\t\t\tcsio_ln_warn(ln,\n\t\t\t\t\"warn: FCOE link is already in offline \"\n\t\t\t\t\"Ignoring Fcoe linkdown event on portid %d\\n\",\n\t\t\t\t portid);\n\t\t\tCSIO_INC_STATS(ln, n_evt_drop);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (fp->portid != portid) {\n\t\t\tcsio_ln_warn(ln,\n\t\t\t\t\"warn: FCOE linkdown recv with \"\n\t\t\t\t\"invalid port %d\\n\", portid);\n\t\t\tCSIO_INC_STATS(ln, n_evt_drop);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (ln->fcf_flowid != fcfi) {\n\t\t\tcsio_ln_warn(ln,\n\t\t\t\t\"warn: FCOE linkdown recv with \"\n\t\t\t\t\"invalid fcfi x%x\\n\", fcfi);\n\t\t\tCSIO_INC_STATS(ln, n_evt_drop);\n\t\t\treturn;\n\t\t}\n\n\t\tcsio_info(hw, \"Port:%d - FCOE LINK DOWN\\n\", portid);\n\n\t\t \n\t\tcsio_ln_down(ln);\n\n\t\treturn;\n\t} else {\n\t\tcsio_warn(hw,\n\t\t\t  \"warn: FCOE linkdown recv with invalid vnpi x%x\\n\",\n\t\t\t  vnpi);\n\t\tCSIO_INC_STATS(hw, n_evt_drop);\n\t}\n}\n\n \nint\ncsio_is_lnode_ready(struct csio_lnode *ln)\n{\n\treturn (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_ready));\n}\n\n \n \n \n \nstatic void\ncsio_lns_uninit(struct csio_lnode *ln, enum csio_ln_ev evt)\n{\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\tstruct csio_lnode *rln = hw->rln;\n\tint rv;\n\n\tCSIO_INC_STATS(ln, n_evt_sm[evt]);\n\tswitch (evt) {\n\tcase CSIO_LNE_LINKUP:\n\t\tcsio_set_state(&ln->sm, csio_lns_online);\n\t\t \n\t\tif (csio_is_phys_ln(ln)) {\n\t\t\trv = csio_ln_read_fcf_entry(ln,\n\t\t\t\t\tcsio_ln_read_fcf_cbfn);\n\t\t\tif (rv != 0) {\n\t\t\t\t \n\t\t\t\tCSIO_INC_STATS(ln, n_err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tlist_add_tail(&ln->fcfinfo->list, &rln->fcf_lsthead);\n\t\t}\n\n\t\trv = csio_ln_vnp_read(ln, csio_ln_vnp_read_cbfn);\n\t\tif (rv != 0) {\n\t\t\t \n\t\t\tCSIO_INC_STATS(ln, n_err);\n\t\t}\n\t\tbreak;\n\n\tcase CSIO_LNE_DOWN_LINK:\n\t\tbreak;\n\n\tdefault:\n\t\tcsio_ln_dbg(ln,\n\t\t\t    \"unexp ln event %d recv from did:x%x in \"\n\t\t\t    \"ln state[uninit].\\n\", evt, ln->nport_id);\n\t\tCSIO_INC_STATS(ln, n_evt_unexp);\n\t\tbreak;\n\t}  \n}\n\n \nstatic void\ncsio_lns_online(struct csio_lnode *ln, enum csio_ln_ev evt)\n{\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\n\tCSIO_INC_STATS(ln, n_evt_sm[evt]);\n\tswitch (evt) {\n\tcase CSIO_LNE_LINKUP:\n\t\tcsio_ln_warn(ln,\n\t\t\t     \"warn: FCOE link is up already \"\n\t\t\t     \"Ignoring linkup on port:%d\\n\", ln->portid);\n\t\tCSIO_INC_STATS(ln, n_evt_drop);\n\t\tbreak;\n\n\tcase CSIO_LNE_FAB_INIT_DONE:\n\t\tcsio_set_state(&ln->sm, csio_lns_ready);\n\n\t\tspin_unlock_irq(&hw->lock);\n\t\tcsio_lnode_async_event(ln, CSIO_LN_FC_LINKUP);\n\t\tspin_lock_irq(&hw->lock);\n\n\t\tbreak;\n\n\tcase CSIO_LNE_LINK_DOWN:\n\tcase CSIO_LNE_DOWN_LINK:\n\t\tcsio_set_state(&ln->sm, csio_lns_uninit);\n\t\tif (csio_is_phys_ln(ln)) {\n\t\t\t \n\t\t\tlist_del_init(&ln->fcfinfo->list);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tcsio_ln_dbg(ln,\n\t\t\t    \"unexp ln event %d recv from did:x%x in \"\n\t\t\t    \"ln state[uninit].\\n\", evt, ln->nport_id);\n\t\tCSIO_INC_STATS(ln, n_evt_unexp);\n\n\t\tbreak;\n\t}  \n}\n\n \nstatic void\ncsio_lns_ready(struct csio_lnode *ln, enum csio_ln_ev evt)\n{\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\n\tCSIO_INC_STATS(ln, n_evt_sm[evt]);\n\tswitch (evt) {\n\tcase CSIO_LNE_FAB_INIT_DONE:\n\t\tcsio_ln_dbg(ln,\n\t\t\t    \"ignoring event %d recv from did x%x\"\n\t\t\t    \"in ln state[ready].\\n\", evt, ln->nport_id);\n\t\tCSIO_INC_STATS(ln, n_evt_drop);\n\t\tbreak;\n\n\tcase CSIO_LNE_LINK_DOWN:\n\t\tcsio_set_state(&ln->sm, csio_lns_offline);\n\t\tcsio_post_event_rns(ln, CSIO_RNFE_DOWN);\n\n\t\tspin_unlock_irq(&hw->lock);\n\t\tcsio_lnode_async_event(ln, CSIO_LN_FC_LINKDOWN);\n\t\tspin_lock_irq(&hw->lock);\n\n\t\tif (csio_is_phys_ln(ln)) {\n\t\t\t \n\t\t\tlist_del_init(&ln->fcfinfo->list);\n\t\t}\n\t\tbreak;\n\n\tcase CSIO_LNE_DOWN_LINK:\n\t\tcsio_set_state(&ln->sm, csio_lns_offline);\n\t\tcsio_post_event_rns(ln, CSIO_RNFE_DOWN);\n\n\t\t \n\t\tspin_unlock_irq(&hw->lock);\n\t\tcsio_lnode_async_event(ln, CSIO_LN_FC_LINKDOWN);\n\t\tspin_lock_irq(&hw->lock);\n\n\t\tif (csio_is_phys_ln(ln)) {\n\t\t\t \n\t\t\tlist_del_init(&ln->fcfinfo->list);\n\t\t}\n\t\tbreak;\n\n\tcase CSIO_LNE_CLOSE:\n\t\tcsio_set_state(&ln->sm, csio_lns_uninit);\n\t\tcsio_post_event_rns(ln, CSIO_RNFE_CLOSE);\n\t\tbreak;\n\n\tcase CSIO_LNE_LOGO:\n\t\tcsio_set_state(&ln->sm, csio_lns_offline);\n\t\tcsio_post_event_rns(ln, CSIO_RNFE_DOWN);\n\t\tbreak;\n\n\tdefault:\n\t\tcsio_ln_dbg(ln,\n\t\t\t    \"unexp ln event %d recv from did:x%x in \"\n\t\t\t    \"ln state[uninit].\\n\", evt, ln->nport_id);\n\t\tCSIO_INC_STATS(ln, n_evt_unexp);\n\t\tCSIO_DB_ASSERT(0);\n\t\tbreak;\n\t}  \n}\n\n \nstatic void\ncsio_lns_offline(struct csio_lnode *ln, enum csio_ln_ev evt)\n{\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\tstruct csio_lnode *rln = hw->rln;\n\tint rv;\n\n\tCSIO_INC_STATS(ln, n_evt_sm[evt]);\n\tswitch (evt) {\n\tcase CSIO_LNE_LINKUP:\n\t\tcsio_set_state(&ln->sm, csio_lns_online);\n\t\t \n\t\tif (csio_is_phys_ln(ln)) {\n\t\t\trv = csio_ln_read_fcf_entry(ln,\n\t\t\t\t\tcsio_ln_read_fcf_cbfn);\n\t\t\tif (rv != 0) {\n\t\t\t\t \n\t\t\t\tCSIO_INC_STATS(ln, n_err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tlist_add_tail(&ln->fcfinfo->list, &rln->fcf_lsthead);\n\t\t}\n\n\t\trv = csio_ln_vnp_read(ln, csio_ln_vnp_read_cbfn);\n\t\tif (rv != 0) {\n\t\t\t \n\t\t\tCSIO_INC_STATS(ln, n_err);\n\t\t}\n\t\tbreak;\n\n\tcase CSIO_LNE_LINK_DOWN:\n\tcase CSIO_LNE_DOWN_LINK:\n\tcase CSIO_LNE_LOGO:\n\t\tcsio_ln_dbg(ln,\n\t\t\t    \"ignoring event %d recv from did x%x\"\n\t\t\t    \"in ln state[offline].\\n\", evt, ln->nport_id);\n\t\tCSIO_INC_STATS(ln, n_evt_drop);\n\t\tbreak;\n\n\tcase CSIO_LNE_CLOSE:\n\t\tcsio_set_state(&ln->sm, csio_lns_uninit);\n\t\tcsio_post_event_rns(ln, CSIO_RNFE_CLOSE);\n\t\tbreak;\n\n\tdefault:\n\t\tcsio_ln_dbg(ln,\n\t\t\t    \"unexp ln event %d recv from did:x%x in \"\n\t\t\t    \"ln state[offline]\\n\", evt, ln->nport_id);\n\t\tCSIO_INC_STATS(ln, n_evt_unexp);\n\t\tCSIO_DB_ASSERT(0);\n\t\tbreak;\n\t}  \n}\n\n \n \n \n\nstatic void\ncsio_free_fcfinfo(struct kref *kref)\n{\n\tstruct csio_fcf_info *fcfinfo = container_of(kref,\n\t\t\t\t\t\tstruct csio_fcf_info, kref);\n\tkfree(fcfinfo);\n}\n\n \n \nvoid\ncsio_lnode_state_to_str(struct csio_lnode *ln, int8_t *str)\n{\n\tif (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_uninit)) {\n\t\tstrcpy(str, \"UNINIT\");\n\t\treturn;\n\t}\n\tif (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_ready)) {\n\t\tstrcpy(str, \"READY\");\n\t\treturn;\n\t}\n\tif (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_offline)) {\n\t\tstrcpy(str, \"OFFLINE\");\n\t\treturn;\n\t}\n\tstrcpy(str, \"UNKNOWN\");\n}  \n\n\nint\ncsio_get_phy_port_stats(struct csio_hw *hw, uint8_t portid,\n\t\t\tstruct fw_fcoe_port_stats *port_stats)\n{\n\tstruct csio_mb  *mbp;\n\tstruct fw_fcoe_port_cmd_params portparams;\n\tenum fw_retval retval;\n\tint idx;\n\n\tmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\n\tif (!mbp) {\n\t\tcsio_err(hw, \"FCoE FCF PARAMS command out of memory!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tportparams.portid = portid;\n\n\tfor (idx = 1; idx <= 3; idx++) {\n\t\tportparams.idx = (idx-1)*6 + 1;\n\t\tportparams.nstats = 6;\n\t\tif (idx == 3)\n\t\t\tportparams.nstats = 4;\n\t\tcsio_fcoe_read_portparams_init_mb(hw, mbp, CSIO_MB_DEFAULT_TMO,\n\t\t\t\t\t\t\t&portparams, NULL);\n\t\tif (csio_mb_issue(hw, mbp)) {\n\t\t\tcsio_err(hw, \"Issue of FCoE port params failed!\\n\");\n\t\t\tmempool_free(mbp, hw->mb_mempool);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcsio_mb_process_portparams_rsp(hw, mbp, &retval,\n\t\t\t\t\t\t&portparams, port_stats);\n\t}\n\n\tmempool_free(mbp, hw->mb_mempool);\n\treturn 0;\n}\n\n \n\nstatic void\ncsio_ln_mgmt_wr_handler(struct csio_hw *hw, void *wr, uint32_t len)\n{\n\tstruct csio_mgmtm *mgmtm = csio_hw_to_mgmtm(hw);\n\tstruct csio_ioreq *io_req = NULL;\n\tstruct fw_fcoe_els_ct_wr *wr_cmd;\n\n\n\twr_cmd = (struct fw_fcoe_els_ct_wr *) wr;\n\n\tif (len < sizeof(struct fw_fcoe_els_ct_wr)) {\n\t\tcsio_err(mgmtm->hw,\n\t\t\t \"Invalid ELS CT WR length recvd, len:%x\\n\", len);\n\t\tmgmtm->stats.n_err++;\n\t\treturn;\n\t}\n\n\tio_req = (struct csio_ioreq *) ((uintptr_t) wr_cmd->cookie);\n\tio_req->wr_status = csio_wr_status(wr_cmd);\n\n\t \n\tspin_lock_irq(&hw->lock);\n\tif (csio_mgmt_req_lookup(mgmtm, io_req) != 0) {\n\t\tcsio_err(mgmtm->hw,\n\t\t\t\"Error- Invalid IO handle recv in WR. handle: %p\\n\",\n\t\t\tio_req);\n\t\tmgmtm->stats.n_err++;\n\t\tspin_unlock_irq(&hw->lock);\n\t\treturn;\n\t}\n\n\tmgmtm = csio_hw_to_mgmtm(hw);\n\n\t \n\tlist_del_init(&io_req->sm.sm_list);\n\tmgmtm->stats.n_active--;\n\tspin_unlock_irq(&hw->lock);\n\n\t \n\tif (io_req->io_cbfn)\n\t\tio_req->io_cbfn(hw, io_req);\n}\n\n \nvoid\ncsio_fcoe_fwevt_handler(struct csio_hw *hw, __u8 cpl_op, __be64 *cmd)\n{\n\tstruct csio_lnode *ln;\n\tstruct csio_rnode *rn;\n\tuint8_t portid, opcode = *(uint8_t *)cmd;\n\tstruct fw_fcoe_link_cmd *lcmd;\n\tstruct fw_wr_hdr *wr;\n\tstruct fw_rdev_wr *rdev_wr;\n\tenum fw_fcoe_link_status lstatus;\n\tuint32_t fcfi, rdev_flowid, vnpi;\n\tenum csio_ln_ev evt;\n\n\tif (cpl_op == CPL_FW6_MSG && opcode == FW_FCOE_LINK_CMD) {\n\n\t\tlcmd = (struct fw_fcoe_link_cmd *)cmd;\n\t\tlstatus = lcmd->lstatus;\n\t\tportid = FW_FCOE_LINK_CMD_PORTID_GET(\n\t\t\t\t\tntohl(lcmd->op_to_portid));\n\t\tfcfi = FW_FCOE_LINK_CMD_FCFI_GET(ntohl(lcmd->sub_opcode_fcfi));\n\t\tvnpi = FW_FCOE_LINK_CMD_VNPI_GET(ntohl(lcmd->vnpi_pkd));\n\n\t\tif (lstatus == FCOE_LINKUP) {\n\n\t\t\t \n\t\t\tspin_lock_irq(&hw->lock);\n\t\t\tcsio_handle_link_up(hw, portid, fcfi, vnpi);\n\t\t\tspin_unlock_irq(&hw->lock);\n\t\t\t \n\n\t\t} else if (lstatus == FCOE_LINKDOWN) {\n\n\t\t\t \n\t\t\tspin_lock_irq(&hw->lock);\n\t\t\tcsio_handle_link_down(hw, portid, fcfi, vnpi);\n\t\t\tspin_unlock_irq(&hw->lock);\n\t\t\t \n\t\t} else {\n\t\t\tcsio_warn(hw, \"Unexpected FCOE LINK status:0x%x\\n\",\n\t\t\t\t  lcmd->lstatus);\n\t\t\tCSIO_INC_STATS(hw, n_cpl_unexp);\n\t\t}\n\t} else if (cpl_op == CPL_FW6_PLD) {\n\t\twr = (struct fw_wr_hdr *) (cmd + 4);\n\t\tif (FW_WR_OP_G(be32_to_cpu(wr->hi))\n\t\t\t== FW_RDEV_WR) {\n\n\t\t\trdev_wr = (struct fw_rdev_wr *) (cmd + 4);\n\n\t\t\trdev_flowid = FW_RDEV_WR_FLOWID_GET(\n\t\t\t\t\tntohl(rdev_wr->alloc_to_len16));\n\t\t\tvnpi = FW_RDEV_WR_ASSOC_FLOWID_GET(\n\t\t\t\t    ntohl(rdev_wr->flags_to_assoc_flowid));\n\n\t\t\tcsio_dbg(hw,\n\t\t\t\t\"FW_RDEV_WR: flowid:x%x ev_cause:x%x \"\n\t\t\t\t\"vnpi:0x%x\\n\", rdev_flowid,\n\t\t\t\trdev_wr->event_cause, vnpi);\n\n\t\t\tif (rdev_wr->protocol != PROT_FCOE) {\n\t\t\t\tcsio_err(hw,\n\t\t\t\t\t\"FW_RDEV_WR: invalid proto:x%x \"\n\t\t\t\t\t\"received with flowid:x%x\\n\",\n\t\t\t\t\trdev_wr->protocol,\n\t\t\t\t\trdev_flowid);\n\t\t\t\tCSIO_INC_STATS(hw, n_evt_drop);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\tspin_lock_irq(&hw->lock);\n\t\t\tln = csio_ln_lookup_by_vnpi(hw, vnpi);\n\t\t\tif (!ln) {\n\t\t\t\tcsio_err(hw,\n\t\t\t\t\t\"FW_DEV_WR: invalid vnpi:x%x received \"\n\t\t\t\t\t\"with flowid:x%x\\n\", vnpi, rdev_flowid);\n\t\t\t\tCSIO_INC_STATS(hw, n_evt_drop);\n\t\t\t\tgoto out_pld;\n\t\t\t}\n\n\t\t\trn = csio_confirm_rnode(ln, rdev_flowid,\n\t\t\t\t\t&rdev_wr->u.fcoe_rdev);\n\t\t\tif (!rn) {\n\t\t\t\tcsio_ln_dbg(ln,\n\t\t\t\t\t\"Failed to confirm rnode \"\n\t\t\t\t\t\"for flowid:x%x\\n\", rdev_flowid);\n\t\t\t\tCSIO_INC_STATS(hw, n_evt_drop);\n\t\t\t\tgoto out_pld;\n\t\t\t}\n\n\t\t\t \n\t\t\tln->prev_evt = ln->cur_evt;\n\t\t\tln->cur_evt = rdev_wr->event_cause;\n\t\t\tCSIO_INC_STATS(ln, n_evt_fw[rdev_wr->event_cause]);\n\n\t\t\t \n\t\t\tevt = CSIO_FWE_TO_LNE(rdev_wr->event_cause);\n\t\t\tif (evt) {\n\t\t\t\tcsio_ln_dbg(ln,\n\t\t\t\t\t\"Posting event to lnode event:%d \"\n\t\t\t\t\t\"cause:%d flowid:x%x\\n\", evt,\n\t\t\t\t\trdev_wr->event_cause, rdev_flowid);\n\t\t\t\tcsio_post_event(&ln->sm, evt);\n\t\t\t}\n\n\t\t\t \n\t\t\tcsio_rnode_fwevt_handler(rn, rdev_wr->event_cause);\nout_pld:\n\t\t\tspin_unlock_irq(&hw->lock);\n\t\t\treturn;\n\t\t} else {\n\t\t\tcsio_warn(hw, \"unexpected WR op(0x%x) recv\\n\",\n\t\t\t\t  FW_WR_OP_G(be32_to_cpu((wr->hi))));\n\t\t\tCSIO_INC_STATS(hw, n_cpl_unexp);\n\t\t}\n\t} else if (cpl_op == CPL_FW6_MSG) {\n\t\twr = (struct fw_wr_hdr *) (cmd);\n\t\tif (FW_WR_OP_G(be32_to_cpu(wr->hi)) == FW_FCOE_ELS_CT_WR) {\n\t\t\tcsio_ln_mgmt_wr_handler(hw, wr,\n\t\t\t\t\tsizeof(struct fw_fcoe_els_ct_wr));\n\t\t} else {\n\t\t\tcsio_warn(hw, \"unexpected WR op(0x%x) recv\\n\",\n\t\t\t\t  FW_WR_OP_G(be32_to_cpu((wr->hi))));\n\t\t\tCSIO_INC_STATS(hw, n_cpl_unexp);\n\t\t}\n\t} else {\n\t\tcsio_warn(hw, \"unexpected CPL op(0x%x) recv\\n\", opcode);\n\t\tCSIO_INC_STATS(hw, n_cpl_unexp);\n\t}\n}\n\n \nint\ncsio_lnode_start(struct csio_lnode *ln)\n{\n\tint rv = 0;\n\tif (csio_is_phys_ln(ln) && !(ln->flags & CSIO_LNF_LINK_ENABLE)) {\n\t\trv = csio_fcoe_enable_link(ln, 1);\n\t\tln->flags |= CSIO_LNF_LINK_ENABLE;\n\t}\n\n\treturn rv;\n}\n\n \nvoid\ncsio_lnode_stop(struct csio_lnode *ln)\n{\n\tcsio_post_event_lns(ln, CSIO_LNE_DOWN_LINK);\n\tif (csio_is_phys_ln(ln) && (ln->flags & CSIO_LNF_LINK_ENABLE)) {\n\t\tcsio_fcoe_enable_link(ln, 0);\n\t\tln->flags &= ~CSIO_LNF_LINK_ENABLE;\n\t}\n\tcsio_ln_dbg(ln, \"stopping ln :%p\\n\", ln);\n}\n\n \nvoid\ncsio_lnode_close(struct csio_lnode *ln)\n{\n\tcsio_post_event_lns(ln, CSIO_LNE_CLOSE);\n\tif (csio_is_phys_ln(ln))\n\t\tln->vnp_flowid = CSIO_INVALID_IDX;\n\n\tcsio_ln_dbg(ln, \"closed ln :%p\\n\", ln);\n}\n\n \nstatic int\ncsio_ln_prep_ecwr(struct csio_ioreq *io_req, uint32_t wr_len,\n\t\t      uint32_t immd_len, uint8_t sub_op, uint32_t sid,\n\t\t      uint32_t did, uint32_t flow_id, uint8_t *fw_wr)\n{\n\tstruct fw_fcoe_els_ct_wr *wr;\n\t__be32 port_id;\n\n\twr  = (struct fw_fcoe_els_ct_wr *)fw_wr;\n\twr->op_immdlen = cpu_to_be32(FW_WR_OP_V(FW_FCOE_ELS_CT_WR) |\n\t\t\t\t     FW_FCOE_ELS_CT_WR_IMMDLEN(immd_len));\n\n\twr_len =  DIV_ROUND_UP(wr_len, 16);\n\twr->flowid_len16 = cpu_to_be32(FW_WR_FLOWID_V(flow_id) |\n\t\t\t\t       FW_WR_LEN16_V(wr_len));\n\twr->els_ct_type = sub_op;\n\twr->ctl_pri = 0;\n\twr->cp_en_class = 0;\n\twr->cookie = io_req->fw_handle;\n\twr->iqid = cpu_to_be16(csio_q_physiqid(\n\t\t\t\t\tio_req->lnode->hwp, io_req->iq_idx));\n\twr->fl_to_sp =  FW_FCOE_ELS_CT_WR_SP(1);\n\twr->tmo_val = (uint8_t) io_req->tmo;\n\tport_id = htonl(sid);\n\tmemcpy(wr->l_id, PORT_ID_PTR(port_id), 3);\n\tport_id = htonl(did);\n\tmemcpy(wr->r_id, PORT_ID_PTR(port_id), 3);\n\n\t \n\twr->rsp_dmalen = cpu_to_be32(io_req->dma_buf.len);\n\twr->rsp_dmaaddr = cpu_to_be64(io_req->dma_buf.paddr);\n\treturn 0;\n}\n\n \nstatic int\ncsio_ln_mgmt_submit_wr(struct csio_mgmtm *mgmtm, struct csio_ioreq *io_req,\n\t\tuint8_t sub_op, struct csio_dma_buf *pld,\n\t\tuint32_t pld_len)\n{\n\tstruct csio_wr_pair wrp;\n\tstruct csio_lnode *ln = io_req->lnode;\n\tstruct csio_rnode *rn = io_req->rnode;\n\tstruct\tcsio_hw\t*hw = mgmtm->hw;\n\tuint8_t fw_wr[64];\n\tstruct ulptx_sgl dsgl;\n\tuint32_t wr_size = 0;\n\tuint8_t im_len = 0;\n\tuint32_t wr_off = 0;\n\n\tint ret = 0;\n\n\t \n\twr_size = sizeof(struct fw_fcoe_els_ct_wr);\n\n\t \n\tif (pld_len < 256) {\n\t\twr_size += ALIGN(pld_len, 8);\n\t\tim_len = (uint8_t)pld_len;\n\t} else\n\t\twr_size += sizeof(struct ulptx_sgl);\n\n\t \n\twr_size = ALIGN(wr_size, 16);\n\n\t \n\tret = csio_wr_get(hw, mgmtm->eq_idx, wr_size, &wrp);\n\tif (ret != 0) {\n\t\tcsio_err(hw, \"Failed to get WR for ec_req %p ret:%d\\n\",\n\t\t\tio_req, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcsio_ln_prep_ecwr(io_req, wr_size, im_len, sub_op,\n\t\t\t\tln->nport_id, rn->nport_id,\n\t\t\t\tcsio_rn_flowid(rn),\n\t\t\t\t&fw_wr[0]);\n\n\t \n\tcsio_wr_copy_to_wrp(&fw_wr[0], &wrp, wr_off,\n\t\t\tsizeof(struct fw_fcoe_els_ct_wr));\n\twr_off += sizeof(struct fw_fcoe_els_ct_wr);\n\n\t \n\tif (im_len)\n\t\tcsio_wr_copy_to_wrp(pld->vaddr, &wrp, wr_off, im_len);\n\telse {\n\t\t \n\t\tdsgl.cmd_nsge = htonl(ULPTX_CMD_V(ULP_TX_SC_DSGL) |\n\t\t\t\t\tULPTX_MORE_F | ULPTX_NSGE_V(1));\n\t\tdsgl.len0 = cpu_to_be32(pld_len);\n\t\tdsgl.addr0 = cpu_to_be64(pld->paddr);\n\t\tcsio_wr_copy_to_wrp(&dsgl, &wrp, ALIGN(wr_off, 8),\n\t\t\t\t   sizeof(struct ulptx_sgl));\n\t}\n\n\t \n\tcsio_wr_issue(mgmtm->hw, mgmtm->eq_idx, false);\n\treturn ret;\n}\n\n \nstatic int\ncsio_ln_mgmt_submit_req(struct csio_ioreq *io_req,\n\t\tvoid (*io_cbfn) (struct csio_hw *, struct csio_ioreq *),\n\t\tenum fcoe_cmn_type req_type, struct csio_dma_buf *pld,\n\t\tuint32_t pld_len)\n{\n\tstruct csio_hw *hw = csio_lnode_to_hw(io_req->lnode);\n\tstruct csio_mgmtm *mgmtm = csio_hw_to_mgmtm(hw);\n\tint rv;\n\n\tBUG_ON(pld_len > pld->len);\n\n\tio_req->io_cbfn = io_cbfn;\t \n\tio_req->fw_handle = (uintptr_t) (io_req);\n\tio_req->eq_idx = mgmtm->eq_idx;\n\tio_req->iq_idx = mgmtm->iq_idx;\n\n\trv = csio_ln_mgmt_submit_wr(mgmtm, io_req, req_type, pld, pld_len);\n\tif (rv == 0) {\n\t\tlist_add_tail(&io_req->sm.sm_list, &mgmtm->active_q);\n\t\tmgmtm->stats.n_active++;\n\t}\n\treturn rv;\n}\n\n \nstatic int\ncsio_ln_fdmi_init(struct csio_lnode *ln)\n{\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\tstruct csio_dma_buf\t*dma_buf;\n\n\t \n\tln->mgmt_req = kzalloc(sizeof(struct csio_ioreq), GFP_KERNEL);\n\tif (!ln->mgmt_req) {\n\t\tcsio_ln_err(ln, \"Failed to alloc ioreq for FDMI\\n\");\n\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdma_buf = &ln->mgmt_req->dma_buf;\n\tdma_buf->len = 2048;\n\tdma_buf->vaddr = dma_alloc_coherent(&hw->pdev->dev, dma_buf->len,\n\t\t\t\t\t\t&dma_buf->paddr, GFP_KERNEL);\n\tif (!dma_buf->vaddr) {\n\t\tcsio_err(hw, \"Failed to alloc DMA buffer for FDMI!\\n\");\n\t\tkfree(ln->mgmt_req);\n\t\tln->mgmt_req = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tln->flags |= CSIO_LNF_FDMI_ENABLE;\n\treturn 0;\n}\n\n \nstatic int\ncsio_ln_fdmi_exit(struct csio_lnode *ln)\n{\n\tstruct csio_dma_buf *dma_buf;\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\n\tif (!ln->mgmt_req)\n\t\treturn 0;\n\n\tdma_buf = &ln->mgmt_req->dma_buf;\n\tif (dma_buf->vaddr)\n\t\tdma_free_coherent(&hw->pdev->dev, dma_buf->len, dma_buf->vaddr,\n\t\t\t\t    dma_buf->paddr);\n\n\tkfree(ln->mgmt_req);\n\treturn 0;\n}\n\nint\ncsio_scan_done(struct csio_lnode *ln, unsigned long ticks,\n\t\tunsigned long time, unsigned long max_scan_ticks,\n\t\tunsigned long delta_scan_ticks)\n{\n\tint rv = 0;\n\n\tif (time >= max_scan_ticks)\n\t\treturn 1;\n\n\tif (!ln->tgt_scan_tick)\n\t\tln->tgt_scan_tick = ticks;\n\n\tif (((ticks - ln->tgt_scan_tick) >= delta_scan_ticks)) {\n\t\tif (!ln->last_scan_ntgts)\n\t\t\tln->last_scan_ntgts = ln->n_scsi_tgts;\n\t\telse {\n\t\t\tif (ln->last_scan_ntgts == ln->n_scsi_tgts)\n\t\t\t\treturn 1;\n\n\t\t\tln->last_scan_ntgts = ln->n_scsi_tgts;\n\t\t}\n\t\tln->tgt_scan_tick = ticks;\n\t}\n\treturn rv;\n}\n\n \nvoid\ncsio_notify_lnodes(struct csio_hw *hw, enum csio_ln_notify note)\n{\n\tstruct list_head *tmp;\n\tstruct csio_lnode *ln;\n\n\tcsio_dbg(hw, \"Notifying all nodes of event %d\\n\", note);\n\n\t \n\tlist_for_each(tmp, &hw->sln_head) {\n\t\tln = (struct csio_lnode *) tmp;\n\n\t\tswitch (note) {\n\t\tcase CSIO_LN_NOTIFY_HWREADY:\n\t\t\tcsio_lnode_start(ln);\n\t\t\tbreak;\n\n\t\tcase CSIO_LN_NOTIFY_HWRESET:\n\t\tcase CSIO_LN_NOTIFY_HWREMOVE:\n\t\t\tcsio_lnode_close(ln);\n\t\t\tbreak;\n\n\t\tcase CSIO_LN_NOTIFY_HWSTOP:\n\t\t\tcsio_lnode_stop(ln);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\n\t\t}\n\t}\n}\n\n \nvoid\ncsio_disable_lnodes(struct csio_hw *hw, uint8_t portid, bool disable)\n{\n\tstruct list_head *tmp;\n\tstruct csio_lnode *ln;\n\n\tcsio_dbg(hw, \"Notifying event to all nodes of port:%d\\n\", portid);\n\n\t \n\tlist_for_each(tmp, &hw->sln_head) {\n\t\tln = (struct csio_lnode *) tmp;\n\t\tif (ln->portid != portid)\n\t\t\tcontinue;\n\n\t\tif (disable)\n\t\t\tcsio_lnode_stop(ln);\n\t\telse\n\t\t\tcsio_lnode_start(ln);\n\t}\n}\n\n \nstatic int\ncsio_ln_init(struct csio_lnode *ln)\n{\n\tint rv = -EINVAL;\n\tstruct csio_lnode *pln;\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\n\tcsio_init_state(&ln->sm, csio_lns_uninit);\n\tln->vnp_flowid = CSIO_INVALID_IDX;\n\tln->fcf_flowid = CSIO_INVALID_IDX;\n\n\tif (csio_is_root_ln(ln)) {\n\n\t\t \n\n\t\tln->fcfinfo = kzalloc(sizeof(struct csio_fcf_info), GFP_KERNEL);\n\t\tif (!ln->fcfinfo) {\n\t\t\tcsio_ln_err(ln, \"Failed to alloc FCF record\\n\");\n\t\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\t\tgoto err;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&ln->fcf_lsthead);\n\t\tkref_init(&ln->fcfinfo->kref);\n\n\t\tif (csio_fdmi_enable && csio_ln_fdmi_init(ln))\n\t\t\tgoto err;\n\n\t} else {  \n\n\t\t \n\n\t\tif (csio_is_npiv_ln(ln)) {\n\t\t\t \n\t\t\tpln = csio_parent_lnode(ln);\n\t\t\tkref_get(&pln->fcfinfo->kref);\n\t\t\tln->fcfinfo = pln->fcfinfo;\n\t\t} else {\n\t\t\t \n\t\t\tln->fcfinfo = kzalloc(sizeof(struct csio_fcf_info),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!ln->fcfinfo) {\n\t\t\t\tcsio_ln_err(ln, \"Failed to alloc FCF info\\n\");\n\t\t\t\tCSIO_INC_STATS(hw, n_err_nomem);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tkref_init(&ln->fcfinfo->kref);\n\n\t\t\tif (csio_fdmi_enable && csio_ln_fdmi_init(ln))\n\t\t\t\tgoto err;\n\t\t}\n\n\t}  \n\n\treturn 0;\nerr:\n\treturn rv;\n}\n\nstatic void\ncsio_ln_exit(struct csio_lnode *ln)\n{\n\tstruct csio_lnode *pln;\n\n\tcsio_cleanup_rns(ln);\n\tif (csio_is_npiv_ln(ln)) {\n\t\tpln = csio_parent_lnode(ln);\n\t\tkref_put(&pln->fcfinfo->kref, csio_free_fcfinfo);\n\t} else {\n\t\tkref_put(&ln->fcfinfo->kref, csio_free_fcfinfo);\n\t\tif (csio_fdmi_enable)\n\t\t\tcsio_ln_fdmi_exit(ln);\n\t}\n\tln->fcfinfo = NULL;\n}\n\n \nint\ncsio_lnode_init(struct csio_lnode *ln, struct csio_hw *hw,\n\t\tstruct csio_lnode *pln)\n{\n\tint rv = -EINVAL;\n\n\t \n\tcsio_lnode_to_hw(ln)\t= hw;\n\n\t \n\tif (pln)\n\t\tln->pln = pln;\n\telse\n\t\tln->pln = NULL;\n\n\t \n\tln->n_scsi_tgts = 0;\n\tln->last_scan_ntgts = 0;\n\tln->tgt_scan_tick = 0;\n\n\t \n\tINIT_LIST_HEAD(&ln->rnhead);\n\tINIT_LIST_HEAD(&ln->cln_head);\n\n\t \n\tln->params.log_level\t= hw->params.log_level;\n\n\tif (csio_ln_init(ln))\n\t\tgoto err;\n\n\t \n\tspin_lock_irq(&hw->lock);\n\tlist_add_tail(&ln->sm.sm_list, pln ? &pln->cln_head : &hw->sln_head);\n\tif (pln)\n\t\tpln->num_vports++;\n\tspin_unlock_irq(&hw->lock);\n\n\thw->num_lns++;\n\n\treturn 0;\nerr:\n\tcsio_lnode_to_hw(ln) = NULL;\n\treturn rv;\n}\n\n \nvoid\ncsio_lnode_exit(struct csio_lnode *ln)\n{\n\tstruct csio_hw *hw = csio_lnode_to_hw(ln);\n\n\tcsio_ln_exit(ln);\n\n\t \n\tspin_lock_irq(&hw->lock);\n\n\tlist_del_init(&ln->sm.sm_list);\n\n\t \n\tif (ln->pln)\n\t\tln->pln->num_vports--;\n\n\t \n\tif (list_empty(&hw->sln_head))\n\t\thw->rln = NULL;\n\telse\n\t\thw->rln = (struct csio_lnode *)csio_list_next(&hw->sln_head);\n\n\tspin_unlock_irq(&hw->lock);\n\n\tcsio_lnode_to_hw(ln)\t= NULL;\n\thw->num_lns--;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}