{
  "module_name": "csio_isr.c",
  "hash_id": "fddd25a6bf1c7fcd6249fa6476686c87b43333b529a13dd1715d4a8bbafec6c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/csiostor/csio_isr.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/cpumask.h>\n#include <linux/string.h>\n\n#include \"csio_init.h\"\n#include \"csio_hw.h\"\n\nstatic irqreturn_t\ncsio_nondata_isr(int irq, void *dev_id)\n{\n\tstruct csio_hw *hw = (struct csio_hw *) dev_id;\n\tint rv;\n\tunsigned long flags;\n\n\tif (unlikely(!hw))\n\t\treturn IRQ_NONE;\n\n\tif (unlikely(pci_channel_offline(hw->pdev))) {\n\t\tCSIO_INC_STATS(hw, n_pcich_offline);\n\t\treturn IRQ_NONE;\n\t}\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\tcsio_hw_slow_intr_handler(hw);\n\trv = csio_mb_isr_handler(hw);\n\n\tif (rv == 0 && !(hw->flags & CSIO_HWF_FWEVT_PENDING)) {\n\t\thw->flags |= CSIO_HWF_FWEVT_PENDING;\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\tschedule_work(&hw->evtq_work);\n\t\treturn IRQ_HANDLED;\n\t}\n\tspin_unlock_irqrestore(&hw->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void\ncsio_fwevt_handler(struct csio_hw *hw)\n{\n\tint rv;\n\tunsigned long flags;\n\n\trv = csio_fwevtq_handler(hw);\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\tif (rv == 0 && !(hw->flags & CSIO_HWF_FWEVT_PENDING)) {\n\t\thw->flags |= CSIO_HWF_FWEVT_PENDING;\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\tschedule_work(&hw->evtq_work);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&hw->lock, flags);\n\n}  \n\n \nstatic irqreturn_t\ncsio_fwevt_isr(int irq, void *dev_id)\n{\n\tstruct csio_hw *hw = (struct csio_hw *) dev_id;\n\n\tif (unlikely(!hw))\n\t\treturn IRQ_NONE;\n\n\tif (unlikely(pci_channel_offline(hw->pdev))) {\n\t\tCSIO_INC_STATS(hw, n_pcich_offline);\n\t\treturn IRQ_NONE;\n\t}\n\n\tcsio_fwevt_handler(hw);\n\n\treturn IRQ_HANDLED;\n}\n\n \nvoid\ncsio_fwevt_intx_handler(struct csio_hw *hw, void *wr, uint32_t len,\n\t\t\t   struct csio_fl_dma_buf *flb, void *priv)\n{\n\tcsio_fwevt_handler(hw);\n}  \n\n \nstatic void\ncsio_process_scsi_cmpl(struct csio_hw *hw, void *wr, uint32_t len,\n\t\t\tstruct csio_fl_dma_buf *flb, void *cbfn_q)\n{\n\tstruct csio_ioreq *ioreq;\n\tuint8_t *scsiwr;\n\tuint8_t subop;\n\tvoid *cmnd;\n\tunsigned long flags;\n\n\tioreq = csio_scsi_cmpl_handler(hw, wr, len, flb, NULL, &scsiwr);\n\tif (likely(ioreq)) {\n\t\tif (unlikely(*scsiwr == FW_SCSI_ABRT_CLS_WR)) {\n\t\t\tsubop = FW_SCSI_ABRT_CLS_WR_SUB_OPCODE_GET(\n\t\t\t\t\t((struct fw_scsi_abrt_cls_wr *)\n\t\t\t\t\t    scsiwr)->sub_opcode_to_chk_all_io);\n\n\t\t\tcsio_dbg(hw, \"%s cmpl recvd ioreq:%p status:%d\\n\",\n\t\t\t\t    subop ? \"Close\" : \"Abort\",\n\t\t\t\t    ioreq, ioreq->wr_status);\n\n\t\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\t\tif (subop)\n\t\t\t\tcsio_scsi_closed(ioreq,\n\t\t\t\t\t\t (struct list_head *)cbfn_q);\n\t\t\telse\n\t\t\t\tcsio_scsi_aborted(ioreq,\n\t\t\t\t\t\t  (struct list_head *)cbfn_q);\n\t\t\t \n\t\t\tcmnd = csio_scsi_cmnd(ioreq);\n\t\t\tif (unlikely(cmnd == NULL))\n\t\t\t\tlist_del_init(&ioreq->sm.sm_list);\n\n\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\t\t\tif (unlikely(cmnd == NULL))\n\t\t\t\tcsio_put_scsi_ioreq_lock(hw,\n\t\t\t\t\t\tcsio_hw_to_scsim(hw), ioreq);\n\t\t} else {\n\t\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\t\tcsio_scsi_completed(ioreq, (struct list_head *)cbfn_q);\n\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t}\n\t}\n}\n\n \nstatic inline irqreturn_t\ncsio_scsi_isr_handler(struct csio_q *iq)\n{\n\tstruct csio_hw *hw = (struct csio_hw *)iq->owner;\n\tLIST_HEAD(cbfn_q);\n\tstruct list_head *tmp;\n\tstruct csio_scsim *scm;\n\tstruct csio_ioreq *ioreq;\n\tint isr_completions = 0;\n\n\tscm = csio_hw_to_scsim(hw);\n\n\tif (unlikely(csio_wr_process_iq(hw, iq, csio_process_scsi_cmpl,\n\t\t\t\t\t&cbfn_q) != 0))\n\t\treturn IRQ_NONE;\n\n\t \n\tlist_for_each(tmp, &cbfn_q) {\n\t\tioreq = (struct csio_ioreq *)tmp;\n\t\tisr_completions++;\n\t\tioreq->io_cbfn(hw, ioreq);\n\t\t \n\t\tif (unlikely(ioreq->dcopy))\n\t\t\tcsio_put_scsi_ddp_list_lock(hw, scm, &ioreq->gen_list,\n\t\t\t\t\t\t    ioreq->nsge);\n\t}\n\n\tif (isr_completions) {\n\t\t \n\t\tcsio_put_scsi_ioreq_list_lock(hw, scm, &cbfn_q,\n\t\t\t\t\t      isr_completions);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t\ncsio_scsi_isr(int irq, void *dev_id)\n{\n\tstruct csio_q *iq = (struct csio_q *) dev_id;\n\tstruct csio_hw *hw;\n\n\tif (unlikely(!iq))\n\t\treturn IRQ_NONE;\n\n\thw = (struct csio_hw *)iq->owner;\n\n\tif (unlikely(pci_channel_offline(hw->pdev))) {\n\t\tCSIO_INC_STATS(hw, n_pcich_offline);\n\t\treturn IRQ_NONE;\n\t}\n\n\tcsio_scsi_isr_handler(iq);\n\n\treturn IRQ_HANDLED;\n}\n\n \nvoid\ncsio_scsi_intx_handler(struct csio_hw *hw, void *wr, uint32_t len,\n\t\t\tstruct csio_fl_dma_buf *flb, void *priv)\n{\n\tstruct csio_q *iq = priv;\n\n\tcsio_scsi_isr_handler(iq);\n\n}  \n\n \nstatic irqreturn_t\ncsio_fcoe_isr(int irq, void *dev_id)\n{\n\tstruct csio_hw *hw = (struct csio_hw *) dev_id;\n\tstruct csio_q *intx_q = NULL;\n\tint rv;\n\tirqreturn_t ret = IRQ_NONE;\n\tunsigned long flags;\n\n\tif (unlikely(!hw))\n\t\treturn IRQ_NONE;\n\n\tif (unlikely(pci_channel_offline(hw->pdev))) {\n\t\tCSIO_INC_STATS(hw, n_pcich_offline);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif (hw->intr_mode == CSIO_IM_INTX)\n\t\tcsio_wr_reg32(hw, 0, MYPF_REG(PCIE_PF_CLI_A));\n\n\t \n\tif (csio_hw_slow_intr_handler(hw))\n\t\tret = IRQ_HANDLED;\n\n\t \n\tintx_q = csio_get_q(hw, hw->intr_iq_idx);\n\n\tCSIO_DB_ASSERT(intx_q);\n\n\t \n\tif (likely(csio_wr_process_iq(hw, intx_q, NULL, NULL) == 0))\n\t\tret = IRQ_HANDLED;\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\trv = csio_mb_isr_handler(hw);\n\tif (rv == 0 && !(hw->flags & CSIO_HWF_FWEVT_PENDING)) {\n\t\thw->flags |= CSIO_HWF_FWEVT_PENDING;\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\tschedule_work(&hw->evtq_work);\n\t\treturn IRQ_HANDLED;\n\t}\n\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\treturn ret;\n}\n\nstatic void\ncsio_add_msix_desc(struct csio_hw *hw)\n{\n\tint i;\n\tstruct csio_msix_entries *entryp = &hw->msix_entries[0];\n\tint k = CSIO_EXTRA_VECS;\n\tint len = sizeof(entryp->desc) - 1;\n\tint cnt = hw->num_sqsets + k;\n\n\t \n\tmemset(entryp->desc, 0, len + 1);\n\tsnprintf(entryp->desc, len, \"csio-%02x:%02x:%x-nondata\",\n\t\t CSIO_PCI_BUS(hw), CSIO_PCI_DEV(hw), CSIO_PCI_FUNC(hw));\n\n\tentryp++;\n\tmemset(entryp->desc, 0, len + 1);\n\tsnprintf(entryp->desc, len, \"csio-%02x:%02x:%x-fwevt\",\n\t\t CSIO_PCI_BUS(hw), CSIO_PCI_DEV(hw), CSIO_PCI_FUNC(hw));\n\tentryp++;\n\n\t \n\tfor (i = k; i < cnt; i++, entryp++) {\n\t\tmemset(entryp->desc, 0, len + 1);\n\t\tsnprintf(entryp->desc, len, \"csio-%02x:%02x:%x-scsi%d\",\n\t\t\t CSIO_PCI_BUS(hw), CSIO_PCI_DEV(hw),\n\t\t\t CSIO_PCI_FUNC(hw), i - CSIO_EXTRA_VECS);\n\t}\n}\n\nint\ncsio_request_irqs(struct csio_hw *hw)\n{\n\tint rv, i, j, k = 0;\n\tstruct csio_msix_entries *entryp = &hw->msix_entries[0];\n\tstruct csio_scsi_cpu_info *info;\n\tstruct pci_dev *pdev = hw->pdev;\n\n\tif (hw->intr_mode != CSIO_IM_MSIX) {\n\t\trv = request_irq(pci_irq_vector(pdev, 0), csio_fcoe_isr,\n\t\t\t\thw->intr_mode == CSIO_IM_MSI ? 0 : IRQF_SHARED,\n\t\t\t\tKBUILD_MODNAME, hw);\n\t\tif (rv) {\n\t\t\tcsio_err(hw, \"Failed to allocate interrupt line.\\n\");\n\t\t\tgoto out_free_irqs;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t \n\tcsio_add_msix_desc(hw);\n\n\trv = request_irq(pci_irq_vector(pdev, k), csio_nondata_isr, 0,\n\t\t\t entryp[k].desc, hw);\n\tif (rv) {\n\t\tcsio_err(hw, \"IRQ request failed for vec %d err:%d\\n\",\n\t\t\t pci_irq_vector(pdev, k), rv);\n\t\tgoto out_free_irqs;\n\t}\n\n\tentryp[k++].dev_id = hw;\n\n\trv = request_irq(pci_irq_vector(pdev, k), csio_fwevt_isr, 0,\n\t\t\t entryp[k].desc, hw);\n\tif (rv) {\n\t\tcsio_err(hw, \"IRQ request failed for vec %d err:%d\\n\",\n\t\t\t pci_irq_vector(pdev, k), rv);\n\t\tgoto out_free_irqs;\n\t}\n\n\tentryp[k++].dev_id = (void *)hw;\n\n\t \n\tfor (i = 0; i < hw->num_pports; i++) {\n\t\tinfo = &hw->scsi_cpu_info[i];\n\t\tfor (j = 0; j < info->max_cpus; j++, k++) {\n\t\t\tstruct csio_scsi_qset *sqset = &hw->sqset[i][j];\n\t\t\tstruct csio_q *q = hw->wrm.q_arr[sqset->iq_idx];\n\n\t\t\trv = request_irq(pci_irq_vector(pdev, k), csio_scsi_isr, 0,\n\t\t\t\t\t entryp[k].desc, q);\n\t\t\tif (rv) {\n\t\t\t\tcsio_err(hw,\n\t\t\t\t       \"IRQ request failed for vec %d err:%d\\n\",\n\t\t\t\t       pci_irq_vector(pdev, k), rv);\n\t\t\t\tgoto out_free_irqs;\n\t\t\t}\n\n\t\t\tentryp[k].dev_id = q;\n\n\t\t}  \n\t}  \n\nout:\n\thw->flags |= CSIO_HWF_HOST_INTR_ENABLED;\n\treturn 0;\n\nout_free_irqs:\n\tfor (i = 0; i < k; i++)\n\t\tfree_irq(pci_irq_vector(pdev, i), hw->msix_entries[i].dev_id);\n\tpci_free_irq_vectors(hw->pdev);\n\treturn -EINVAL;\n}\n\n \nstatic void\ncsio_reduce_sqsets(struct csio_hw *hw, int cnt)\n{\n\tint i;\n\tstruct csio_scsi_cpu_info *info;\n\n\twhile (cnt < hw->num_sqsets) {\n\t\tfor (i = 0; i < hw->num_pports; i++) {\n\t\t\tinfo = &hw->scsi_cpu_info[i];\n\t\t\tif (info->max_cpus > 1) {\n\t\t\t\tinfo->max_cpus--;\n\t\t\t\thw->num_sqsets--;\n\t\t\t\tif (hw->num_sqsets <= cnt)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcsio_dbg(hw, \"Reduced sqsets to %d\\n\", hw->num_sqsets);\n}\n\nstatic void csio_calc_sets(struct irq_affinity *affd, unsigned int nvecs)\n{\n\tstruct csio_hw *hw = affd->priv;\n\tu8 i;\n\n\tif (!nvecs)\n\t\treturn;\n\n\tif (nvecs < hw->num_pports) {\n\t\taffd->nr_sets = 1;\n\t\taffd->set_size[0] = nvecs;\n\t\treturn;\n\t}\n\n\taffd->nr_sets = hw->num_pports;\n\tfor (i = 0; i < hw->num_pports; i++)\n\t\taffd->set_size[i] = nvecs / hw->num_pports;\n}\n\nstatic int\ncsio_enable_msix(struct csio_hw *hw)\n{\n\tint i, j, k, n, min, cnt;\n\tint extra = CSIO_EXTRA_VECS;\n\tstruct csio_scsi_cpu_info *info;\n\tstruct irq_affinity desc = {\n\t\t.pre_vectors = CSIO_EXTRA_VECS,\n\t\t.calc_sets = csio_calc_sets,\n\t\t.priv = hw,\n\t};\n\n\tif (hw->num_pports > IRQ_AFFINITY_MAX_SETS)\n\t\treturn -ENOSPC;\n\n\tmin = hw->num_pports + extra;\n\tcnt = hw->num_sqsets + extra;\n\n\t \n\tif (hw->flags & CSIO_HWF_USING_SOFT_PARAMS || !csio_is_hw_master(hw))\n\t\tcnt = min_t(uint8_t, hw->cfg_niq, cnt);\n\n\tcsio_dbg(hw, \"FW supp #niq:%d, trying %d msix's\\n\", hw->cfg_niq, cnt);\n\n\tcnt = pci_alloc_irq_vectors_affinity(hw->pdev, min, cnt,\n\t\t\tPCI_IRQ_MSIX | PCI_IRQ_AFFINITY, &desc);\n\tif (cnt < 0)\n\t\treturn cnt;\n\n\tif (cnt < (hw->num_sqsets + extra)) {\n\t\tcsio_dbg(hw, \"Reducing sqsets to %d\\n\", cnt - extra);\n\t\tcsio_reduce_sqsets(hw, cnt - extra);\n\t}\n\n\t \n\tk = 0;\n\tcsio_set_nondata_intr_idx(hw, k);\n\tcsio_set_mb_intr_idx(csio_hw_to_mbm(hw), k++);\n\tcsio_set_fwevt_intr_idx(hw, k++);\n\n\tfor (i = 0; i < hw->num_pports; i++) {\n\t\tinfo = &hw->scsi_cpu_info[i];\n\n\t\tfor (j = 0; j < hw->num_scsi_msix_cpus; j++) {\n\t\t\tn = (j % info->max_cpus) +  k;\n\t\t\thw->sqset[i][j].intr_idx = n;\n\t\t}\n\n\t\tk += info->max_cpus;\n\t}\n\n\treturn 0;\n}\n\nvoid\ncsio_intr_enable(struct csio_hw *hw)\n{\n\thw->intr_mode = CSIO_IM_NONE;\n\thw->flags &= ~CSIO_HWF_HOST_INTR_ENABLED;\n\n\t \n\tif ((csio_msi == 2) && !csio_enable_msix(hw))\n\t\thw->intr_mode = CSIO_IM_MSIX;\n\telse {\n\t\t \n\t\tif (hw->flags & CSIO_HWF_USING_SOFT_PARAMS ||\n\t\t\t!csio_is_hw_master(hw)) {\n\t\t\tint extra = CSIO_EXTRA_MSI_IQS;\n\n\t\t\tif (hw->cfg_niq < (hw->num_sqsets + extra)) {\n\t\t\t\tcsio_dbg(hw, \"Reducing sqsets to %d\\n\",\n\t\t\t\t\t hw->cfg_niq - extra);\n\t\t\t\tcsio_reduce_sqsets(hw, hw->cfg_niq - extra);\n\t\t\t}\n\t\t}\n\n\t\tif ((csio_msi == 1) && !pci_enable_msi(hw->pdev))\n\t\t\thw->intr_mode = CSIO_IM_MSI;\n\t\telse\n\t\t\thw->intr_mode = CSIO_IM_INTX;\n\t}\n\n\tcsio_dbg(hw, \"Using %s interrupt mode.\\n\",\n\t\t(hw->intr_mode == CSIO_IM_MSIX) ? \"MSIX\" :\n\t\t((hw->intr_mode == CSIO_IM_MSI) ? \"MSI\" : \"INTx\"));\n}\n\nvoid\ncsio_intr_disable(struct csio_hw *hw, bool free)\n{\n\tcsio_hw_intr_disable(hw);\n\n\tif (free) {\n\t\tint i;\n\n\t\tswitch (hw->intr_mode) {\n\t\tcase CSIO_IM_MSIX:\n\t\t\tfor (i = 0; i < hw->num_sqsets + CSIO_EXTRA_VECS; i++) {\n\t\t\t\tfree_irq(pci_irq_vector(hw->pdev, i),\n\t\t\t\t\t hw->msix_entries[i].dev_id);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSIO_IM_MSI:\n\t\tcase CSIO_IM_INTX:\n\t\t\tfree_irq(pci_irq_vector(hw->pdev, 0), hw);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpci_free_irq_vectors(hw->pdev);\n\thw->intr_mode = CSIO_IM_NONE;\n\thw->flags &= ~CSIO_HWF_HOST_INTR_ENABLED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}