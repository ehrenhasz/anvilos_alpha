{
  "module_name": "csio_init.h",
  "hash_id": "b5e02001de19ceeb97ba20aca3cab09047b15f495b063bb6cc546a7507b5d74d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/csiostor/csio_init.h",
  "human_readable_source": " \n\n#ifndef __CSIO_INIT_H__\n#define __CSIO_INIT_H__\n\n#include <linux/pci.h>\n#include <linux/if_ether.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_fc.h>\n\n#include \"csio_scsi.h\"\n#include \"csio_lnode.h\"\n#include \"csio_rnode.h\"\n#include \"csio_hw.h\"\n\n#define CSIO_DRV_AUTHOR\t\t\t\"Chelsio Communications\"\n#define CSIO_DRV_DESC\t\t\t\"Chelsio FCoE driver\"\n#define CSIO_DRV_VERSION\t\t\"1.0.0-ko\"\n\nextern struct fc_function_template csio_fc_transport_funcs;\nextern struct fc_function_template csio_fc_transport_vport_funcs;\n\nvoid csio_fchost_attr_init(struct csio_lnode *);\n\n \nvoid csio_scsi_intx_handler(struct csio_hw *, void *, uint32_t,\n\t\t\t       struct csio_fl_dma_buf *, void *);\n\nvoid csio_fwevt_intx_handler(struct csio_hw *, void *, uint32_t,\n\t\t\t\tstruct csio_fl_dma_buf *, void *);\n\n \nvoid csio_lnodes_block_request(struct csio_hw *);\nvoid csio_lnodes_unblock_request(struct csio_hw *);\nvoid csio_lnodes_block_by_port(struct csio_hw *, uint8_t);\nvoid csio_lnodes_unblock_by_port(struct csio_hw *, uint8_t);\n\nstruct csio_lnode *csio_shost_init(struct csio_hw *, struct device *, bool,\n\t\t\t\t\tstruct csio_lnode *);\nvoid csio_shost_exit(struct csio_lnode *);\nvoid csio_lnodes_exit(struct csio_hw *, bool);\n\n \nvoid csio_add_debugfs_mem(struct csio_hw *, const char *,\n\t\tunsigned int, unsigned int);\n\nstatic inline struct Scsi_Host *\ncsio_ln_to_shost(struct csio_lnode *ln)\n{\n\treturn container_of((void *)ln, struct Scsi_Host, hostdata[0]);\n}\n\n \nstatic inline struct csio_ioreq *\ncsio_get_scsi_ioreq_lock(struct csio_hw *hw, struct csio_scsim *scsim)\n{\n\tstruct csio_ioreq *ioreq;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&scsim->freelist_lock, flags);\n\tioreq = csio_get_scsi_ioreq(scsim);\n\tspin_unlock_irqrestore(&scsim->freelist_lock, flags);\n\n\treturn ioreq;\n}\n\nstatic inline void\ncsio_put_scsi_ioreq_lock(struct csio_hw *hw, struct csio_scsim *scsim,\n\t\t\t struct csio_ioreq *ioreq)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&scsim->freelist_lock, flags);\n\tcsio_put_scsi_ioreq(scsim, ioreq);\n\tspin_unlock_irqrestore(&scsim->freelist_lock, flags);\n}\n\n \nstatic inline void\ncsio_put_scsi_ioreq_list_lock(struct csio_hw *hw, struct csio_scsim *scsim,\n\t\t\t      struct list_head *reqlist, int n)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&scsim->freelist_lock, flags);\n\tcsio_put_scsi_ioreq_list(scsim, reqlist, n);\n\tspin_unlock_irqrestore(&scsim->freelist_lock, flags);\n}\n\n \nstatic inline void\ncsio_put_scsi_ddp_list_lock(struct csio_hw *hw, struct csio_scsim *scsim,\n\t\t\t      struct list_head *reqlist, int n)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\tcsio_put_scsi_ddp_list(scsim, reqlist, n);\n\tspin_unlock_irqrestore(&hw->lock, flags);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}