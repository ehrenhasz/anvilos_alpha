{
  "module_name": "ips.c",
  "hash_id": "e6e17bccd53e877f727de3443a7914b3d4b6352a87dcd86ccb33c69f2a5f87b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/ips.c",
  "human_readable_source": " \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n\n#include <asm/io.h>\n#include <asm/byteorder.h>\n#include <asm/page.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/proc_fs.h>\n#include <linux/reboot.h>\n#include <linux/interrupt.h>\n\n#include <linux/blkdev.h>\n#include <linux/types.h>\n#include <linux/dma-mapping.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/sg.h>\n\n#include \"ips.h\"\n\n#include <linux/module.h>\n\n#include <linux/stat.h>\n\n#include <linux/spinlock.h>\n#include <linux/init.h>\n\n#include <linux/smp.h>\n\n#ifdef MODULE\nstatic char *ips = NULL;\nmodule_param(ips, charp, 0);\n#endif\n\n \n#define IPS_VERSION_HIGH        IPS_VER_MAJOR_STRING \".\" IPS_VER_MINOR_STRING\n#define IPS_VERSION_LOW         \".\" IPS_VER_BUILD_STRING \" \"\n\n#define IPS_DMA_DIR(scb) ((!scb->scsi_cmd || ips_is_passthru(scb->scsi_cmd) || \\\n                         DMA_NONE == scb->scsi_cmd->sc_data_direction) ? \\\n                         DMA_BIDIRECTIONAL : \\\n                         scb->scsi_cmd->sc_data_direction)\n\n#ifdef IPS_DEBUG\n#define METHOD_TRACE(s, i)    if (ips_debug >= (i+10)) printk(KERN_NOTICE s \"\\n\");\n#define DEBUG(i, s)           if (ips_debug >= i) printk(KERN_NOTICE s \"\\n\");\n#define DEBUG_VAR(i, s, v...) if (ips_debug >= i) printk(KERN_NOTICE s \"\\n\", v);\n#else\n#define METHOD_TRACE(s, i)\n#define DEBUG(i, s)\n#define DEBUG_VAR(i, s, v...)\n#endif\n\n \nstatic int ips_eh_abort(struct scsi_cmnd *);\nstatic int ips_eh_reset(struct scsi_cmnd *);\nstatic int ips_queue(struct Scsi_Host *, struct scsi_cmnd *);\nstatic const char *ips_info(struct Scsi_Host *);\nstatic irqreturn_t do_ipsintr(int, void *);\nstatic int ips_hainit(ips_ha_t *);\nstatic int ips_map_status(ips_ha_t *, ips_scb_t *, ips_stat_t *);\nstatic int ips_send_wait(ips_ha_t *, ips_scb_t *, int, int);\nstatic int ips_send_cmd(ips_ha_t *, ips_scb_t *);\nstatic int ips_online(ips_ha_t *, ips_scb_t *);\nstatic int ips_inquiry(ips_ha_t *, ips_scb_t *);\nstatic int ips_rdcap(ips_ha_t *, ips_scb_t *);\nstatic int ips_msense(ips_ha_t *, ips_scb_t *);\nstatic int ips_reqsen(ips_ha_t *, ips_scb_t *);\nstatic int ips_deallocatescbs(ips_ha_t *, int);\nstatic int ips_allocatescbs(ips_ha_t *);\nstatic int ips_reset_copperhead(ips_ha_t *);\nstatic int ips_reset_copperhead_memio(ips_ha_t *);\nstatic int ips_reset_morpheus(ips_ha_t *);\nstatic int ips_issue_copperhead(ips_ha_t *, ips_scb_t *);\nstatic int ips_issue_copperhead_memio(ips_ha_t *, ips_scb_t *);\nstatic int ips_issue_i2o(ips_ha_t *, ips_scb_t *);\nstatic int ips_issue_i2o_memio(ips_ha_t *, ips_scb_t *);\nstatic int ips_isintr_copperhead(ips_ha_t *);\nstatic int ips_isintr_copperhead_memio(ips_ha_t *);\nstatic int ips_isintr_morpheus(ips_ha_t *);\nstatic int ips_wait(ips_ha_t *, int, int);\nstatic int ips_write_driver_status(ips_ha_t *, int);\nstatic int ips_read_adapter_status(ips_ha_t *, int);\nstatic int ips_read_subsystem_parameters(ips_ha_t *, int);\nstatic int ips_read_config(ips_ha_t *, int);\nstatic int ips_clear_adapter(ips_ha_t *, int);\nstatic int ips_readwrite_page5(ips_ha_t *, int, int);\nstatic int ips_init_copperhead(ips_ha_t *);\nstatic int ips_init_copperhead_memio(ips_ha_t *);\nstatic int ips_init_morpheus(ips_ha_t *);\nstatic int ips_isinit_copperhead(ips_ha_t *);\nstatic int ips_isinit_copperhead_memio(ips_ha_t *);\nstatic int ips_isinit_morpheus(ips_ha_t *);\nstatic int ips_erase_bios(ips_ha_t *);\nstatic int ips_program_bios(ips_ha_t *, char *, uint32_t, uint32_t);\nstatic int ips_verify_bios(ips_ha_t *, char *, uint32_t, uint32_t);\nstatic int ips_erase_bios_memio(ips_ha_t *);\nstatic int ips_program_bios_memio(ips_ha_t *, char *, uint32_t, uint32_t);\nstatic int ips_verify_bios_memio(ips_ha_t *, char *, uint32_t, uint32_t);\nstatic int ips_flash_copperhead(ips_ha_t *, ips_passthru_t *, ips_scb_t *);\nstatic int ips_flash_bios(ips_ha_t *, ips_passthru_t *, ips_scb_t *);\nstatic int ips_flash_firmware(ips_ha_t *, ips_passthru_t *, ips_scb_t *);\nstatic void ips_free_flash_copperhead(ips_ha_t * ha);\nstatic void ips_get_bios_version(ips_ha_t *, int);\nstatic void ips_identify_controller(ips_ha_t *);\nstatic void ips_chkstatus(ips_ha_t *, IPS_STATUS *);\nstatic void ips_enable_int_copperhead(ips_ha_t *);\nstatic void ips_enable_int_copperhead_memio(ips_ha_t *);\nstatic void ips_enable_int_morpheus(ips_ha_t *);\nstatic int ips_intr_copperhead(ips_ha_t *);\nstatic int ips_intr_morpheus(ips_ha_t *);\nstatic void ips_next(ips_ha_t *, int);\nstatic void ipsintr_blocking(ips_ha_t *, struct ips_scb *);\nstatic void ipsintr_done(ips_ha_t *, struct ips_scb *);\nstatic void ips_done(ips_ha_t *, ips_scb_t *);\nstatic void ips_free(ips_ha_t *);\nstatic void ips_init_scb(ips_ha_t *, ips_scb_t *);\nstatic void ips_freescb(ips_ha_t *, ips_scb_t *);\nstatic void ips_setup_funclist(ips_ha_t *);\nstatic void ips_statinit(ips_ha_t *);\nstatic void ips_statinit_memio(ips_ha_t *);\nstatic void ips_fix_ffdc_time(ips_ha_t *, ips_scb_t *, time64_t);\nstatic void ips_ffdc_reset(ips_ha_t *, int);\nstatic void ips_ffdc_time(ips_ha_t *);\nstatic uint32_t ips_statupd_copperhead(ips_ha_t *);\nstatic uint32_t ips_statupd_copperhead_memio(ips_ha_t *);\nstatic uint32_t ips_statupd_morpheus(ips_ha_t *);\nstatic ips_scb_t *ips_getscb(ips_ha_t *);\nstatic void ips_putq_scb_head(ips_scb_queue_t *, ips_scb_t *);\nstatic void ips_putq_wait_tail(ips_wait_queue_entry_t *, struct scsi_cmnd *);\nstatic void ips_putq_copp_tail(ips_copp_queue_t *,\n\t\t\t\t      ips_copp_wait_item_t *);\nstatic ips_scb_t *ips_removeq_scb_head(ips_scb_queue_t *);\nstatic ips_scb_t *ips_removeq_scb(ips_scb_queue_t *, ips_scb_t *);\nstatic struct scsi_cmnd *ips_removeq_wait_head(ips_wait_queue_entry_t *);\nstatic struct scsi_cmnd *ips_removeq_wait(ips_wait_queue_entry_t *,\n\t\t\t\t\t  struct scsi_cmnd *);\nstatic ips_copp_wait_item_t *ips_removeq_copp(ips_copp_queue_t *,\n\t\t\t\t\t\t     ips_copp_wait_item_t *);\nstatic ips_copp_wait_item_t *ips_removeq_copp_head(ips_copp_queue_t *);\n\nstatic int ips_is_passthru(struct scsi_cmnd *);\nstatic int ips_make_passthru(ips_ha_t *, struct scsi_cmnd *, ips_scb_t *, int);\nstatic int ips_usrcmd(ips_ha_t *, ips_passthru_t *, ips_scb_t *);\nstatic void ips_cleanup_passthru(ips_ha_t *, ips_scb_t *);\nstatic void ips_scmd_buf_write(struct scsi_cmnd * scmd, void *data,\n\t\t\t       unsigned int count);\nstatic void ips_scmd_buf_read(struct scsi_cmnd * scmd, void *data,\n\t\t\t      unsigned int count);\n\nstatic int ips_write_info(struct Scsi_Host *, char *, int);\nstatic int ips_show_info(struct seq_file *, struct Scsi_Host *);\nstatic int ips_host_info(ips_ha_t *, struct seq_file *);\nstatic int ips_abort_init(ips_ha_t * ha, int index);\nstatic int ips_init_phase2(int index);\n\nstatic int ips_init_phase1(struct pci_dev *pci_dev, int *indexPtr);\nstatic int ips_register_scsi(int index);\n\nstatic int  ips_poll_for_flush_complete(ips_ha_t * ha);\nstatic void ips_flush_and_reset(ips_ha_t *ha);\n\n \nstatic const char ips_name[] = \"ips\";\nstatic struct Scsi_Host *ips_sh[IPS_MAX_ADAPTERS];\t \nstatic ips_ha_t *ips_ha[IPS_MAX_ADAPTERS];\t \nstatic unsigned int ips_next_controller;\nstatic unsigned int ips_num_controllers;\nstatic unsigned int ips_released_controllers;\nstatic int ips_hotplug;\nstatic int ips_cmd_timeout = 60;\nstatic int ips_reset_timeout = 60 * 5;\nstatic int ips_force_memio = 1;\t\t \nstatic int ips_force_i2o = 1;\t \nstatic int ips_ioctlsize = IPS_IOCTL_SIZE;\t \nstatic int ips_cd_boot;\t\t\t \nstatic char *ips_FlashData = NULL;\t \nstatic dma_addr_t ips_flashbusaddr;\nstatic long ips_FlashDataInUse;\t\t \nstatic uint32_t MaxLiteCmds = 32;\t \nstatic struct scsi_host_template ips_driver_template = {\n\t.info\t\t\t= ips_info,\n\t.queuecommand\t\t= ips_queue,\n\t.eh_abort_handler\t= ips_eh_abort,\n\t.eh_host_reset_handler\t= ips_eh_reset,\n\t.proc_name\t\t= \"ips\",\n\t.show_info\t\t= ips_show_info,\n\t.write_info\t\t= ips_write_info,\n\t.slave_configure\t= ips_slave_configure,\n\t.bios_param\t\t= ips_biosparam,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= IPS_MAX_SG,\n\t.cmd_per_lun\t\t= 3,\n\t.no_write_same\t\t= 1,\n};\n\n\n \nstatic struct  pci_device_id  ips_pci_table[] = {\n\t{ 0x1014, 0x002E, PCI_ANY_ID, PCI_ANY_ID, 0, 0 },\n\t{ 0x1014, 0x01BD, PCI_ANY_ID, PCI_ANY_ID, 0, 0 },\n\t{ 0x9005, 0x0250, PCI_ANY_ID, PCI_ANY_ID, 0, 0 },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE( pci, ips_pci_table );\n\nstatic char ips_hot_plug_name[] = \"ips\";\n\nstatic int  ips_insert_device(struct pci_dev *pci_dev, const struct pci_device_id *ent);\nstatic void ips_remove_device(struct pci_dev *pci_dev);\n\nstatic struct pci_driver ips_pci_driver = {\n\t.name\t\t= ips_hot_plug_name,\n\t.id_table\t= ips_pci_table,\n\t.probe\t\t= ips_insert_device,\n\t.remove\t\t= ips_remove_device,\n};\n\n\n \nstatic int ips_halt(struct notifier_block *nb, ulong event, void *buf);\n\n#define MAX_ADAPTER_NAME 15\n\nstatic char ips_adapter_name[][30] = {\n\t\"ServeRAID\",\n\t\"ServeRAID II\",\n\t\"ServeRAID on motherboard\",\n\t\"ServeRAID on motherboard\",\n\t\"ServeRAID 3H\",\n\t\"ServeRAID 3L\",\n\t\"ServeRAID 4H\",\n\t\"ServeRAID 4M\",\n\t\"ServeRAID 4L\",\n\t\"ServeRAID 4Mx\",\n\t\"ServeRAID 4Lx\",\n\t\"ServeRAID 5i\",\n\t\"ServeRAID 5i\",\n\t\"ServeRAID 6M\",\n\t\"ServeRAID 6i\",\n\t\"ServeRAID 7t\",\n\t\"ServeRAID 7k\",\n\t\"ServeRAID 7M\"\n};\n\nstatic struct notifier_block ips_notifier = {\n\tips_halt, NULL, 0\n};\n\n \nstatic char ips_command_direction[] = {\n\tIPS_DATA_NONE, IPS_DATA_NONE, IPS_DATA_IN, IPS_DATA_IN, IPS_DATA_OUT,\n\tIPS_DATA_IN, IPS_DATA_IN, IPS_DATA_OUT, IPS_DATA_IN, IPS_DATA_UNK,\n\tIPS_DATA_OUT, IPS_DATA_OUT, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_IN, IPS_DATA_NONE, IPS_DATA_NONE, IPS_DATA_IN, IPS_DATA_OUT,\n\tIPS_DATA_IN, IPS_DATA_OUT, IPS_DATA_NONE, IPS_DATA_NONE, IPS_DATA_OUT,\n\tIPS_DATA_NONE, IPS_DATA_IN, IPS_DATA_NONE, IPS_DATA_IN, IPS_DATA_OUT,\n\tIPS_DATA_NONE, IPS_DATA_UNK, IPS_DATA_IN, IPS_DATA_UNK, IPS_DATA_IN,\n\tIPS_DATA_UNK, IPS_DATA_OUT, IPS_DATA_IN, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_IN, IPS_DATA_IN, IPS_DATA_OUT, IPS_DATA_NONE, IPS_DATA_UNK,\n\tIPS_DATA_IN, IPS_DATA_OUT, IPS_DATA_OUT, IPS_DATA_OUT, IPS_DATA_OUT,\n\tIPS_DATA_OUT, IPS_DATA_NONE, IPS_DATA_IN, IPS_DATA_NONE, IPS_DATA_NONE,\n\tIPS_DATA_IN, IPS_DATA_OUT, IPS_DATA_OUT, IPS_DATA_OUT, IPS_DATA_OUT,\n\tIPS_DATA_IN, IPS_DATA_OUT, IPS_DATA_IN, IPS_DATA_OUT, IPS_DATA_OUT,\n\tIPS_DATA_OUT, IPS_DATA_IN, IPS_DATA_IN, IPS_DATA_IN, IPS_DATA_NONE,\n\tIPS_DATA_UNK, IPS_DATA_NONE, IPS_DATA_NONE, IPS_DATA_NONE, IPS_DATA_UNK,\n\tIPS_DATA_NONE, IPS_DATA_OUT, IPS_DATA_IN, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_OUT, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_IN, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_NONE, IPS_DATA_NONE, IPS_DATA_UNK, IPS_DATA_IN, IPS_DATA_NONE,\n\tIPS_DATA_OUT, IPS_DATA_UNK, IPS_DATA_NONE, IPS_DATA_UNK, IPS_DATA_OUT,\n\tIPS_DATA_OUT, IPS_DATA_OUT, IPS_DATA_OUT, IPS_DATA_OUT, IPS_DATA_NONE,\n\tIPS_DATA_UNK, IPS_DATA_IN, IPS_DATA_OUT, IPS_DATA_IN, IPS_DATA_IN,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_OUT,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK,\n\tIPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK, IPS_DATA_UNK\n};\n\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_setup(char *ips_str)\n{\n\n\tint i;\n\tchar *key;\n\tchar *value;\n\tstatic const IPS_OPTION options[] = {\n\t\t{\"noi2o\", &ips_force_i2o, 0},\n\t\t{\"nommap\", &ips_force_memio, 0},\n\t\t{\"ioctlsize\", &ips_ioctlsize, IPS_IOCTL_SIZE},\n\t\t{\"cdboot\", &ips_cd_boot, 0},\n\t\t{\"maxcmds\", &MaxLiteCmds, 32},\n\t};\n\n\t \n\t \n\twhile ((key = strsep(&ips_str, \",.\"))) {\n\t\tif (!*key)\n\t\t\tcontinue;\n\t\tvalue = strchr(key, ':');\n\t\tif (value)\n\t\t\t*value++ = '\\0';\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(options); i++) {\n\t\t\tif (strncasecmp\n\t\t\t    (key, options[i].option_name,\n\t\t\t     strlen(options[i].option_name)) == 0) {\n\t\t\t\tif (value)\n\t\t\t\t\t*options[i].option_flag =\n\t\t\t\t\t    simple_strtoul(value, NULL, 0);\n\t\t\t\telse\n\t\t\t\t\t*options[i].option_flag =\n\t\t\t\t\t    options[i].option_value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (1);\n}\n\n__setup(\"ips=\", ips_setup);\n\n \n \n \n \n \n \n \n \n \n \n \nstatic int\nips_detect(struct scsi_host_template * SHT)\n{\n\tint i;\n\n\tMETHOD_TRACE(\"ips_detect\", 1);\n\n#ifdef MODULE\n\tif (ips)\n\t\tips_setup(ips);\n#endif\n\n\tfor (i = 0; i < ips_num_controllers; i++) {\n\t\tif (ips_register_scsi(i))\n\t\t\tips_free(ips_ha[i]);\n\t\tips_released_controllers++;\n\t}\n\tips_hotplug = 1;\n\treturn (ips_num_controllers);\n}\n\n \n \n \n \nstatic void\nips_setup_funclist(ips_ha_t * ha)\n{\n\n\t \n\tif (IPS_IS_MORPHEUS(ha) || IPS_IS_MARCO(ha)) {\n\t\t \n\t\tha->func.isintr = ips_isintr_morpheus;\n\t\tha->func.isinit = ips_isinit_morpheus;\n\t\tha->func.issue = ips_issue_i2o_memio;\n\t\tha->func.init = ips_init_morpheus;\n\t\tha->func.statupd = ips_statupd_morpheus;\n\t\tha->func.reset = ips_reset_morpheus;\n\t\tha->func.intr = ips_intr_morpheus;\n\t\tha->func.enableint = ips_enable_int_morpheus;\n\t} else if (IPS_USE_MEMIO(ha)) {\n\t\t \n\t\tha->func.isintr = ips_isintr_copperhead_memio;\n\t\tha->func.isinit = ips_isinit_copperhead_memio;\n\t\tha->func.init = ips_init_copperhead_memio;\n\t\tha->func.statupd = ips_statupd_copperhead_memio;\n\t\tha->func.statinit = ips_statinit_memio;\n\t\tha->func.reset = ips_reset_copperhead_memio;\n\t\tha->func.intr = ips_intr_copperhead;\n\t\tha->func.erasebios = ips_erase_bios_memio;\n\t\tha->func.programbios = ips_program_bios_memio;\n\t\tha->func.verifybios = ips_verify_bios_memio;\n\t\tha->func.enableint = ips_enable_int_copperhead_memio;\n\t\tif (IPS_USE_I2O_DELIVER(ha))\n\t\t\tha->func.issue = ips_issue_i2o_memio;\n\t\telse\n\t\t\tha->func.issue = ips_issue_copperhead_memio;\n\t} else {\n\t\t \n\t\tha->func.isintr = ips_isintr_copperhead;\n\t\tha->func.isinit = ips_isinit_copperhead;\n\t\tha->func.init = ips_init_copperhead;\n\t\tha->func.statupd = ips_statupd_copperhead;\n\t\tha->func.statinit = ips_statinit;\n\t\tha->func.reset = ips_reset_copperhead;\n\t\tha->func.intr = ips_intr_copperhead;\n\t\tha->func.erasebios = ips_erase_bios;\n\t\tha->func.programbios = ips_program_bios;\n\t\tha->func.verifybios = ips_verify_bios;\n\t\tha->func.enableint = ips_enable_int_copperhead;\n\n\t\tif (IPS_USE_I2O_DELIVER(ha))\n\t\t\tha->func.issue = ips_issue_i2o;\n\t\telse\n\t\t\tha->func.issue = ips_issue_copperhead;\n\t}\n}\n\n \n \n \n \n \n \n \n \n \nstatic void ips_release(struct Scsi_Host *sh)\n{\n\tips_scb_t *scb;\n\tips_ha_t *ha;\n\tint i;\n\n\tMETHOD_TRACE(\"ips_release\", 1);\n\n\tscsi_remove_host(sh);\n\n\tfor (i = 0; i < IPS_MAX_ADAPTERS && ips_sh[i] != sh; i++) ;\n\n\tif (i == IPS_MAX_ADAPTERS) {\n\t\tprintk(KERN_WARNING\n\t\t       \"(%s) release, invalid Scsi_Host pointer.\\n\", ips_name);\n\t\tBUG();\n\t}\n\n\tha = IPS_HA(sh);\n\n\tif (!ha)\n\t\treturn;\n\n\t \n\tscb = &ha->scbs[ha->max_cmds - 1];\n\n\tips_init_scb(ha, scb);\n\n\tscb->timeout = ips_cmd_timeout;\n\tscb->cdb[0] = IPS_CMD_FLUSH;\n\n\tscb->cmd.flush_cache.op_code = IPS_CMD_FLUSH;\n\tscb->cmd.flush_cache.command_id = IPS_COMMAND_ID(ha, scb);\n\tscb->cmd.flush_cache.state = IPS_NORM_STATE;\n\tscb->cmd.flush_cache.reserved = 0;\n\tscb->cmd.flush_cache.reserved2 = 0;\n\tscb->cmd.flush_cache.reserved3 = 0;\n\tscb->cmd.flush_cache.reserved4 = 0;\n\n\tIPS_PRINTK(KERN_WARNING, ha->pcidev, \"Flushing Cache.\\n\");\n\n\t \n\tif (ips_send_wait(ha, scb, ips_cmd_timeout, IPS_INTR_ON) == IPS_FAILURE)\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev, \"Incomplete Flush.\\n\");\n\n\tIPS_PRINTK(KERN_WARNING, ha->pcidev, \"Flushing Complete.\\n\");\n\n\tips_sh[i] = NULL;\n\tips_ha[i] = NULL;\n\n\t \n\tips_free(ha);\n\n\t \n\tfree_irq(ha->pcidev->irq, ha);\n\n\tscsi_host_put(sh);\n\n\tips_released_controllers++;\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_halt(struct notifier_block *nb, ulong event, void *buf)\n{\n\tips_scb_t *scb;\n\tips_ha_t *ha;\n\tint i;\n\n\tif ((event != SYS_RESTART) && (event != SYS_HALT) &&\n\t    (event != SYS_POWER_OFF))\n\t\treturn (NOTIFY_DONE);\n\n\tfor (i = 0; i < ips_next_controller; i++) {\n\t\tha = (ips_ha_t *) ips_ha[i];\n\n\t\tif (!ha)\n\t\t\tcontinue;\n\n\t\tif (!ha->active)\n\t\t\tcontinue;\n\n\t\t \n\t\tscb = &ha->scbs[ha->max_cmds - 1];\n\n\t\tips_init_scb(ha, scb);\n\n\t\tscb->timeout = ips_cmd_timeout;\n\t\tscb->cdb[0] = IPS_CMD_FLUSH;\n\n\t\tscb->cmd.flush_cache.op_code = IPS_CMD_FLUSH;\n\t\tscb->cmd.flush_cache.command_id = IPS_COMMAND_ID(ha, scb);\n\t\tscb->cmd.flush_cache.state = IPS_NORM_STATE;\n\t\tscb->cmd.flush_cache.reserved = 0;\n\t\tscb->cmd.flush_cache.reserved2 = 0;\n\t\tscb->cmd.flush_cache.reserved3 = 0;\n\t\tscb->cmd.flush_cache.reserved4 = 0;\n\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev, \"Flushing Cache.\\n\");\n\n\t\t \n\t\tif (ips_send_wait(ha, scb, ips_cmd_timeout, IPS_INTR_ON) ==\n\t\t    IPS_FAILURE)\n\t\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t\t   \"Incomplete Flush.\\n\");\n\t\telse\n\t\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t\t   \"Flushing Complete.\\n\");\n\t}\n\n\treturn (NOTIFY_OK);\n}\n\n \n \n \n \n \n \n \n \n \nint ips_eh_abort(struct scsi_cmnd *SC)\n{\n\tips_ha_t *ha;\n\tips_copp_wait_item_t *item;\n\tint ret;\n\tstruct Scsi_Host *host;\n\n\tMETHOD_TRACE(\"ips_eh_abort\", 1);\n\n\tif (!SC)\n\t\treturn (FAILED);\n\n\thost = SC->device->host;\n\tha = (ips_ha_t *) SC->device->host->hostdata;\n\n\tif (!ha)\n\t\treturn (FAILED);\n\n\tif (!ha->active)\n\t\treturn (FAILED);\n\n\tspin_lock(host->host_lock);\n\n\t \n\titem = ha->copp_waitlist.head;\n\twhile ((item) && (item->scsi_cmd != SC))\n\t\titem = item->next;\n\n\tif (item) {\n\t\t \n\t\tips_removeq_copp(&ha->copp_waitlist, item);\n\t\tret = (SUCCESS);\n\n\t\t \n\t} else if (ips_removeq_wait(&ha->scb_waitlist, SC)) {\n\t\t \n\t\tret = (SUCCESS);\n\t} else {\n\t\t \n\t\tret = (FAILED);\n\t}\n\n\tspin_unlock(host->host_lock);\n\treturn ret;\n}\n\n \n \n \n \n \n \n \n \n \n \n \nstatic int __ips_eh_reset(struct scsi_cmnd *SC)\n{\n\tint ret;\n\tint i;\n\tips_ha_t *ha;\n\tips_scb_t *scb;\n\tips_copp_wait_item_t *item;\n\n\tMETHOD_TRACE(\"ips_eh_reset\", 1);\n\n#ifdef NO_IPS_RESET\n\treturn (FAILED);\n#else\n\n\tif (!SC) {\n\t\tDEBUG(1, \"Reset called with NULL scsi command\");\n\n\t\treturn (FAILED);\n\t}\n\n\tha = (ips_ha_t *) SC->device->host->hostdata;\n\n\tif (!ha) {\n\t\tDEBUG(1, \"Reset called with NULL ha struct\");\n\n\t\treturn (FAILED);\n\t}\n\n\tif (!ha->active)\n\t\treturn (FAILED);\n\n\t \n\titem = ha->copp_waitlist.head;\n\twhile ((item) && (item->scsi_cmd != SC))\n\t\titem = item->next;\n\n\tif (item) {\n\t\t \n\t\tips_removeq_copp(&ha->copp_waitlist, item);\n\t\treturn (SUCCESS);\n\t}\n\n\t \n\tif (ips_removeq_wait(&ha->scb_waitlist, SC)) {\n\t\t \n\t\treturn (SUCCESS);\n\t}\n\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\n\tif (ha->ioctl_reset == 0) {\t \n\t\tscb = &ha->scbs[ha->max_cmds - 1];\n\n\t\tips_init_scb(ha, scb);\n\n\t\tscb->timeout = ips_cmd_timeout;\n\t\tscb->cdb[0] = IPS_CMD_FLUSH;\n\n\t\tscb->cmd.flush_cache.op_code = IPS_CMD_FLUSH;\n\t\tscb->cmd.flush_cache.command_id = IPS_COMMAND_ID(ha, scb);\n\t\tscb->cmd.flush_cache.state = IPS_NORM_STATE;\n\t\tscb->cmd.flush_cache.reserved = 0;\n\t\tscb->cmd.flush_cache.reserved2 = 0;\n\t\tscb->cmd.flush_cache.reserved3 = 0;\n\t\tscb->cmd.flush_cache.reserved4 = 0;\n\n\t\t \n\t\tret = ips_send_wait(ha, scb, ips_cmd_timeout, IPS_INTR_IORL);\n\t\tif (ret == IPS_SUCCESS) {\n\t\t\tIPS_PRINTK(KERN_NOTICE, ha->pcidev,\n\t\t\t\t   \"Reset Request - Flushed Cache\\n\");\n\t\t\treturn (SUCCESS);\n\t\t}\n\t}\n\n\t \n\t \n\n\tha->ioctl_reset = 0;\t \n\n\t \n\tIPS_PRINTK(KERN_NOTICE, ha->pcidev, \"Resetting controller.\\n\");\n\tret = (*ha->func.reset) (ha);\n\n\tif (!ret) {\n\t\tstruct scsi_cmnd *scsi_cmd;\n\n\t\tIPS_PRINTK(KERN_NOTICE, ha->pcidev,\n\t\t\t   \"Controller reset failed - controller now offline.\\n\");\n\n\t\t \n\t\tDEBUG_VAR(1, \"(%s%d) Failing active commands\",\n\t\t\t  ips_name, ha->host_num);\n\n\t\twhile ((scb = ips_removeq_scb_head(&ha->scb_activelist))) {\n\t\t\tscb->scsi_cmd->result = DID_ERROR << 16;\n\t\t\tscsi_done(scb->scsi_cmd);\n\t\t\tips_freescb(ha, scb);\n\t\t}\n\n\t\t \n\t\tDEBUG_VAR(1, \"(%s%d) Failing pending commands\",\n\t\t\t  ips_name, ha->host_num);\n\n\t\twhile ((scsi_cmd = ips_removeq_wait_head(&ha->scb_waitlist))) {\n\t\t\tscsi_cmd->result = DID_ERROR;\n\t\t\tscsi_done(scsi_cmd);\n\t\t}\n\n\t\tha->active = false;\n\t\treturn (FAILED);\n\t}\n\n\tif (!ips_clear_adapter(ha, IPS_INTR_IORL)) {\n\t\tstruct scsi_cmnd *scsi_cmd;\n\n\t\tIPS_PRINTK(KERN_NOTICE, ha->pcidev,\n\t\t\t   \"Controller reset failed - controller now offline.\\n\");\n\n\t\t \n\t\tDEBUG_VAR(1, \"(%s%d) Failing active commands\",\n\t\t\t  ips_name, ha->host_num);\n\n\t\twhile ((scb = ips_removeq_scb_head(&ha->scb_activelist))) {\n\t\t\tscb->scsi_cmd->result = DID_ERROR << 16;\n\t\t\tscsi_done(scb->scsi_cmd);\n\t\t\tips_freescb(ha, scb);\n\t\t}\n\n\t\t \n\t\tDEBUG_VAR(1, \"(%s%d) Failing pending commands\",\n\t\t\t  ips_name, ha->host_num);\n\n\t\twhile ((scsi_cmd = ips_removeq_wait_head(&ha->scb_waitlist))) {\n\t\t\tscsi_cmd->result = DID_ERROR << 16;\n\t\t\tscsi_done(scsi_cmd);\n\t\t}\n\n\t\tha->active = false;\n\t\treturn (FAILED);\n\t}\n\n\t \n\tif (le32_to_cpu(ha->subsys->param[3]) & 0x300000) {\n\t\tha->last_ffdc = ktime_get_real_seconds();\n\t\tha->reset_count++;\n\t\tips_ffdc_reset(ha, IPS_INTR_IORL);\n\t}\n\n\t \n\tDEBUG_VAR(1, \"(%s%d) Failing active commands\", ips_name, ha->host_num);\n\n\twhile ((scb = ips_removeq_scb_head(&ha->scb_activelist))) {\n\t\tscb->scsi_cmd->result = DID_RESET << 16;\n\t\tscsi_done(scb->scsi_cmd);\n\t\tips_freescb(ha, scb);\n\t}\n\n\t \n\tfor (i = 1; i < ha->nbus; i++)\n\t\tha->dcdb_active[i - 1] = 0;\n\n\t \n\tha->num_ioctl = 0;\n\n\tips_next(ha, IPS_INTR_IORL);\n\n\treturn (SUCCESS);\n#endif\t\t\t\t \n\n}\n\nstatic int ips_eh_reset(struct scsi_cmnd *SC)\n{\n\tint rc;\n\n\tspin_lock_irq(SC->device->host->host_lock);\n\trc = __ips_eh_reset(SC);\n\tspin_unlock_irq(SC->device->host->host_lock);\n\n\treturn rc;\n}\n\n \n \n \n \n \n \n \n \n \n \n \n \nstatic int ips_queue_lck(struct scsi_cmnd *SC)\n{\n\tvoid (*done)(struct scsi_cmnd *) = scsi_done;\n\tips_ha_t *ha;\n\tips_passthru_t *pt;\n\n\tMETHOD_TRACE(\"ips_queue\", 1);\n\n\tha = (ips_ha_t *) SC->device->host->hostdata;\n\n\tif (!ha)\n\t\tgoto out_error;\n\n\tif (!ha->active)\n\t\tgoto out_error;\n\n\tif (ips_is_passthru(SC)) {\n\t\tif (ha->copp_waitlist.count == IPS_MAX_IOCTL_QUEUE) {\n\t\t\tSC->result = DID_BUS_BUSY << 16;\n\t\t\tdone(SC);\n\n\t\t\treturn (0);\n\t\t}\n\t} else if (ha->scb_waitlist.count == IPS_MAX_QUEUE) {\n\t\tSC->result = DID_BUS_BUSY << 16;\n\t\tdone(SC);\n\n\t\treturn (0);\n\t}\n\n\tDEBUG_VAR(2, \"(%s%d): ips_queue: cmd 0x%X (%d %d %d)\",\n\t\t  ips_name,\n\t\t  ha->host_num,\n\t\t  SC->cmnd[0],\n\t\t  SC->device->channel, SC->device->id, SC->device->lun);\n\n\t \n\tif ((scmd_channel(SC) > 0)\n\t    && (scmd_id(SC) == ha->ha_id[scmd_channel(SC)])) {\n\t\tSC->result = DID_NO_CONNECT << 16;\n\t\tdone(SC);\n\n\t\treturn (0);\n\t}\n\n\tif (ips_is_passthru(SC)) {\n\n\t\tips_copp_wait_item_t *scratch;\n\n\t\t \n\t\t \n\t\t \n\t\tpt = (ips_passthru_t *) scsi_sglist(SC);\n\t\tif ((pt->CoppCP.cmd.reset.op_code == IPS_CMD_RESET_CHANNEL) &&\n\t\t    (pt->CoppCP.cmd.reset.adapter_flag == 1)) {\n\t\t\tif (ha->scb_activelist.count != 0) {\n\t\t\t\tSC->result = DID_BUS_BUSY << 16;\n\t\t\t\tdone(SC);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tha->ioctl_reset = 1;\t \n\t\t\t__ips_eh_reset(SC);\n\t\t\tSC->result = DID_OK << 16;\n\t\t\tscsi_done(SC);\n\t\t\treturn (0);\n\t\t}\n\n\t\t \n\t\tscratch = kmalloc(sizeof (ips_copp_wait_item_t), GFP_ATOMIC);\n\n\t\tif (!scratch) {\n\t\t\tSC->result = DID_ERROR << 16;\n\t\t\tdone(SC);\n\n\t\t\treturn (0);\n\t\t}\n\n\t\tscratch->scsi_cmd = SC;\n\t\tscratch->next = NULL;\n\n\t\tips_putq_copp_tail(&ha->copp_waitlist, scratch);\n\t} else {\n\t\tips_putq_wait_tail(&ha->scb_waitlist, SC);\n\t}\n\n\tips_next(ha, IPS_INTR_IORL);\n\n\treturn (0);\nout_error:\n\tSC->result = DID_ERROR << 16;\n\tdone(SC);\n\n\treturn (0);\n}\n\nstatic DEF_SCSI_QCMD(ips_queue)\n\n \n \n \n \n \n \n \n \n \nstatic int ips_biosparam(struct scsi_device *sdev, struct block_device *bdev,\n\t\t\t sector_t capacity, int geom[])\n{\n\tips_ha_t *ha = (ips_ha_t *) sdev->host->hostdata;\n\tint heads;\n\tint sectors;\n\tint cylinders;\n\n\tMETHOD_TRACE(\"ips_biosparam\", 1);\n\n\tif (!ha)\n\t\t \n\t\treturn (0);\n\n\tif (!ha->active)\n\t\treturn (0);\n\n\tif (!ips_read_adapter_status(ha, IPS_INTR_ON))\n\t\t \n\t\treturn (0);\n\n\tif ((capacity > 0x400000) && ((ha->enq->ucMiscFlag & 0x8) == 0)) {\n\t\theads = IPS_NORM_HEADS;\n\t\tsectors = IPS_NORM_SECTORS;\n\t} else {\n\t\theads = IPS_COMP_HEADS;\n\t\tsectors = IPS_COMP_SECTORS;\n\t}\n\n\tcylinders = (unsigned long) capacity / (heads * sectors);\n\n\tDEBUG_VAR(2, \"Geometry: heads: %d, sectors: %d, cylinders: %d\",\n\t\t  heads, sectors, cylinders);\n\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\n\treturn (0);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_slave_configure(struct scsi_device * SDptr)\n{\n\tips_ha_t *ha;\n\tint min;\n\n\tha = IPS_HA(SDptr->host);\n\tif (SDptr->tagged_supported && SDptr->type == TYPE_DISK) {\n\t\tmin = ha->max_cmds / 2;\n\t\tif (ha->enq->ucLogDriveCount <= 2)\n\t\t\tmin = ha->max_cmds - 1;\n\t\tscsi_change_queue_depth(SDptr, min);\n\t}\n\n\tSDptr->skip_ms_page_8 = 1;\n\tSDptr->skip_ms_page_3f = 1;\n\treturn 0;\n}\n\n \n \n \n \n \n \n \n \n \nstatic irqreturn_t\ndo_ipsintr(int irq, void *dev_id)\n{\n\tips_ha_t *ha;\n\tstruct Scsi_Host *host;\n\tint irqstatus;\n\n\tMETHOD_TRACE(\"do_ipsintr\", 2);\n\n\tha = (ips_ha_t *) dev_id;\n\tif (!ha)\n\t\treturn IRQ_NONE;\n\thost = ips_sh[ha->host_num];\n\t \n\tif (!host) {\n\t\t(*ha->func.intr) (ha);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tspin_lock(host->host_lock);\n\n\tif (!ha->active) {\n\t\tspin_unlock(host->host_lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tirqstatus = (*ha->func.intr) (ha);\n\n\tspin_unlock(host->host_lock);\n\n\t \n\tips_next(ha, IPS_INTR_ON);\n\treturn IRQ_RETVAL(irqstatus);\n}\n\n \n \n \n \n \n \n \n \n \n \n \nint\nips_intr_copperhead(ips_ha_t * ha)\n{\n\tips_stat_t *sp;\n\tips_scb_t *scb;\n\tIPS_STATUS cstatus;\n\tint intrstatus;\n\n\tMETHOD_TRACE(\"ips_intr\", 2);\n\n\tif (!ha)\n\t\treturn 0;\n\n\tif (!ha->active)\n\t\treturn 0;\n\n\tintrstatus = (*ha->func.isintr) (ha);\n\n\tif (!intrstatus) {\n\t\t \n\n\t\treturn 0;\n\t}\n\n\twhile (true) {\n\t\tsp = &ha->sp;\n\n\t\tintrstatus = (*ha->func.isintr) (ha);\n\n\t\tif (!intrstatus)\n\t\t\tbreak;\n\t\telse\n\t\t\tcstatus.value = (*ha->func.statupd) (ha);\n\n\t\tif (cstatus.fields.command_id > (IPS_MAX_CMDS - 1)) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tips_chkstatus(ha, &cstatus);\n\t\tscb = (ips_scb_t *) sp->scb_addr;\n\n\t\t \n\t\t(*scb->callback) (ha, scb);\n\t}\t\t\t \n\treturn 1;\n}\n\n \n \n \n \n \n \n \n \n \n \n \nint\nips_intr_morpheus(ips_ha_t * ha)\n{\n\tips_stat_t *sp;\n\tips_scb_t *scb;\n\tIPS_STATUS cstatus;\n\tint intrstatus;\n\n\tMETHOD_TRACE(\"ips_intr_morpheus\", 2);\n\n\tif (!ha)\n\t\treturn 0;\n\n\tif (!ha->active)\n\t\treturn 0;\n\n\tintrstatus = (*ha->func.isintr) (ha);\n\n\tif (!intrstatus) {\n\t\t \n\n\t\treturn 0;\n\t}\n\n\twhile (true) {\n\t\tsp = &ha->sp;\n\n\t\tintrstatus = (*ha->func.isintr) (ha);\n\n\t\tif (!intrstatus)\n\t\t\tbreak;\n\t\telse\n\t\t\tcstatus.value = (*ha->func.statupd) (ha);\n\n\t\tif (cstatus.value == 0xffffffff)\n\t\t\t \n\t\t\tbreak;\n\n\t\tif (cstatus.fields.command_id > (IPS_MAX_CMDS - 1)) {\n\t\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t\t   \"Spurious interrupt; no ccb.\\n\");\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tips_chkstatus(ha, &cstatus);\n\t\tscb = (ips_scb_t *) sp->scb_addr;\n\n\t\t \n\t\t(*scb->callback) (ha, scb);\n\t}\t\t\t \n\treturn 1;\n}\n\n \n \n \n \n \n \n \n \n \nstatic const char *\nips_info(struct Scsi_Host *SH)\n{\n\tstatic char buffer[256];\n\tchar *bp;\n\tips_ha_t *ha;\n\n\tMETHOD_TRACE(\"ips_info\", 1);\n\n\tha = IPS_HA(SH);\n\n\tif (!ha)\n\t\treturn (NULL);\n\n\tbp = &buffer[0];\n\tmemset(bp, 0, sizeof (buffer));\n\n\tsprintf(bp, \"%s%s%s Build %d\", \"IBM PCI ServeRAID \",\n\t\tIPS_VERSION_HIGH, IPS_VERSION_LOW, IPS_BUILD_IDENT);\n\n\tif (ha->ad_type > 0 && ha->ad_type <= MAX_ADAPTER_NAME) {\n\t\tstrcat(bp, \" <\");\n\t\tstrcat(bp, ips_adapter_name[ha->ad_type - 1]);\n\t\tstrcat(bp, \">\");\n\t}\n\n\treturn (bp);\n}\n\nstatic int\nips_write_info(struct Scsi_Host *host, char *buffer, int length)\n{\n\tint i;\n\tips_ha_t *ha = NULL;\n\n\t \n\tfor (i = 0; i < ips_next_controller; i++) {\n\t\tif (ips_sh[i]) {\n\t\t\tif (ips_sh[i] == host) {\n\t\t\t\tha = (ips_ha_t *) ips_sh[i]->hostdata;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ha)\n\t\treturn (-EINVAL);\n\n\treturn 0;\n}\n\nstatic int\nips_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tint i;\n\tips_ha_t *ha = NULL;\n\n\t \n\tfor (i = 0; i < ips_next_controller; i++) {\n\t\tif (ips_sh[i]) {\n\t\t\tif (ips_sh[i] == host) {\n\t\t\t\tha = (ips_ha_t *) ips_sh[i]->hostdata;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ha)\n\t\treturn (-EINVAL);\n\n\treturn ips_host_info(ha, m);\n}\n\n \n \n \n\n \n \n \n \n \n \n \n \n \nstatic int ips_is_passthru(struct scsi_cmnd *SC)\n{\n\tunsigned long flags;\n\n\tMETHOD_TRACE(\"ips_is_passthru\", 1);\n\n\tif (!SC)\n\t\treturn (0);\n\n\tif ((SC->cmnd[0] == IPS_IOCTL_COMMAND) &&\n\t    (SC->device->channel == 0) &&\n\t    (SC->device->id == IPS_ADAPTER_ID) &&\n\t    (SC->device->lun == 0) && scsi_sglist(SC)) {\n                struct scatterlist *sg = scsi_sglist(SC);\n                char  *buffer;\n\n                 \n                local_irq_save(flags);\n\t\tbuffer = kmap_local_page(sg_page(sg)) + sg->offset;\n\t\tif (buffer && buffer[0] == 'C' && buffer[1] == 'O' &&\n\t\t    buffer[2] == 'P' && buffer[3] == 'P') {\n\t\t\tkunmap_local(buffer);\n                        local_irq_restore(flags);\n                        return 1;\n                }\n\t\tkunmap_local(buffer);\n                local_irq_restore(flags);\n\t}\n\treturn 0;\n}\n\n \n \n \n \n \n \n \n \nstatic int\nips_alloc_passthru_buffer(ips_ha_t * ha, int length)\n{\n\tvoid *bigger_buf;\n\tdma_addr_t dma_busaddr;\n\n\tif (ha->ioctl_data && length <= ha->ioctl_len)\n\t\treturn 0;\n\t \n\tbigger_buf = dma_alloc_coherent(&ha->pcidev->dev, length, &dma_busaddr,\n\t\t\tGFP_KERNEL);\n\tif (bigger_buf) {\n\t\t \n\t\tdma_free_coherent(&ha->pcidev->dev, ha->ioctl_len,\n\t\t\t\t  ha->ioctl_data, ha->ioctl_busaddr);\n\t\t \n\t\tha->ioctl_data = (char *) bigger_buf;\n\t\tha->ioctl_len = length;\n\t\tha->ioctl_busaddr = dma_busaddr;\n\t} else {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_make_passthru(ips_ha_t *ha, struct scsi_cmnd *SC, ips_scb_t *scb, int intr)\n{\n\tips_passthru_t *pt;\n\tint length = 0;\n\tint i, ret;\n        struct scatterlist *sg = scsi_sglist(SC);\n\n\tMETHOD_TRACE(\"ips_make_passthru\", 1);\n\n        scsi_for_each_sg(SC, sg, scsi_sg_count(SC), i)\n\t\tlength += sg->length;\n\n\tif (length < sizeof (ips_passthru_t)) {\n\t\t \n\t\tDEBUG_VAR(1, \"(%s%d) Passthru structure wrong size\",\n\t\t\t  ips_name, ha->host_num);\n\t\treturn (IPS_FAILURE);\n\t}\n\tif (ips_alloc_passthru_buffer(ha, length)) {\n\t\t \n\t\tif (ha->ioctl_data) {\n\t\t\tpt = (ips_passthru_t *) ha->ioctl_data;\n\t\t\tips_scmd_buf_read(SC, pt, sizeof (ips_passthru_t));\n\t\t\tpt->BasicStatus = 0x0B;\n\t\t\tpt->ExtendedStatus = 0x00;\n\t\t\tips_scmd_buf_write(SC, pt, sizeof (ips_passthru_t));\n\t\t}\n\t\treturn IPS_FAILURE;\n\t}\n\tha->ioctl_datasize = length;\n\n\tips_scmd_buf_read(SC, ha->ioctl_data, ha->ioctl_datasize);\n\tpt = (ips_passthru_t *) ha->ioctl_data;\n\n\t \n\n\tswitch (pt->CoppCmd) {\n\tcase IPS_NUMCTRLS:\n\t\tmemcpy(ha->ioctl_data + sizeof (ips_passthru_t),\n\t\t       &ips_num_controllers, sizeof (int));\n\t\tips_scmd_buf_write(SC, ha->ioctl_data,\n\t\t\t\t   sizeof (ips_passthru_t) + sizeof (int));\n\t\tSC->result = DID_OK << 16;\n\n\t\treturn (IPS_SUCCESS_IMM);\n\n\tcase IPS_COPPUSRCMD:\n\tcase IPS_COPPIOCCMD:\n\t\tif (SC->cmnd[0] == IPS_IOCTL_COMMAND) {\n\t\t\tif (length < (sizeof (ips_passthru_t) + pt->CmdBSize)) {\n\t\t\t\t \n\t\t\t\tDEBUG_VAR(1,\n\t\t\t\t\t  \"(%s%d) Passthru structure wrong size\",\n\t\t\t\t\t  ips_name, ha->host_num);\n\n\t\t\t\treturn (IPS_FAILURE);\n\t\t\t}\n\n\t\t\tif (ha->pcidev->device == IPS_DEVICEID_COPPERHEAD &&\n\t\t\t    pt->CoppCP.cmd.flashfw.op_code ==\n\t\t\t    IPS_CMD_RW_BIOSFW) {\n\t\t\t\tret = ips_flash_copperhead(ha, pt, scb);\n\t\t\t\tips_scmd_buf_write(SC, ha->ioctl_data,\n\t\t\t\t\t\t   sizeof (ips_passthru_t));\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tif (ips_usrcmd(ha, pt, scb))\n\t\t\t\treturn (IPS_SUCCESS);\n\t\t\telse\n\t\t\t\treturn (IPS_FAILURE);\n\t\t}\n\n\t\tbreak;\n\n\t}\t\t\t \n\n\treturn (IPS_FAILURE);\n}\n\n \n \n \n \n \nstatic int\nips_flash_copperhead(ips_ha_t * ha, ips_passthru_t * pt, ips_scb_t * scb)\n{\n\tint datasize;\n\n\t \n\tif (IPS_IS_TROMBONE(ha) && pt->CoppCP.cmd.flashfw.type == IPS_FW_IMAGE) {\n\t\tif (ips_usrcmd(ha, pt, scb))\n\t\t\treturn IPS_SUCCESS;\n\t\telse\n\t\t\treturn IPS_FAILURE;\n\t}\n\tpt->BasicStatus = 0x0B;\n\tpt->ExtendedStatus = 0;\n\tscb->scsi_cmd->result = DID_OK << 16;\n\t \n\t \n\tif (pt->CoppCP.cmd.flashfw.type == IPS_BIOS_IMAGE &&\n\t    pt->CoppCP.cmd.flashfw.direction == IPS_ERASE_BIOS) {\n\t\tpt->BasicStatus = 0;\n\t\treturn ips_flash_bios(ha, pt, scb);\n\t} else if (pt->CoppCP.cmd.flashfw.packet_num == 0) {\n\t\tif (ips_FlashData && !test_and_set_bit(0, &ips_FlashDataInUse)){\n\t\t\tha->flash_data = ips_FlashData;\n\t\t\tha->flash_busaddr = ips_flashbusaddr;\n\t\t\tha->flash_len = PAGE_SIZE << 7;\n\t\t\tha->flash_datasize = 0;\n\t\t} else if (!ha->flash_data) {\n\t\t\tdatasize = pt->CoppCP.cmd.flashfw.total_packets *\n\t\t\t    pt->CoppCP.cmd.flashfw.count;\n\t\t\tha->flash_data = dma_alloc_coherent(&ha->pcidev->dev,\n\t\t\t\t\tdatasize, &ha->flash_busaddr, GFP_KERNEL);\n\t\t\tif (!ha->flash_data){\n\t\t\t\tprintk(KERN_WARNING \"Unable to allocate a flash buffer\\n\");\n\t\t\t\treturn IPS_FAILURE;\n\t\t\t}\n\t\t\tha->flash_datasize = 0;\n\t\t\tha->flash_len = datasize;\n\t\t} else\n\t\t\treturn IPS_FAILURE;\n\t} else {\n\t\tif (pt->CoppCP.cmd.flashfw.count + ha->flash_datasize >\n\t\t    ha->flash_len) {\n\t\t\tips_free_flash_copperhead(ha);\n\t\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t\t   \"failed size sanity check\\n\");\n\t\t\treturn IPS_FAILURE;\n\t\t}\n\t}\n\tif (!ha->flash_data)\n\t\treturn IPS_FAILURE;\n\tpt->BasicStatus = 0;\n\tmemcpy(&ha->flash_data[ha->flash_datasize], pt + 1,\n\t       pt->CoppCP.cmd.flashfw.count);\n\tha->flash_datasize += pt->CoppCP.cmd.flashfw.count;\n\tif (pt->CoppCP.cmd.flashfw.packet_num ==\n\t    pt->CoppCP.cmd.flashfw.total_packets - 1) {\n\t\tif (pt->CoppCP.cmd.flashfw.type == IPS_BIOS_IMAGE)\n\t\t\treturn ips_flash_bios(ha, pt, scb);\n\t\telse if (pt->CoppCP.cmd.flashfw.type == IPS_FW_IMAGE)\n\t\t\treturn ips_flash_firmware(ha, pt, scb);\n\t}\n\treturn IPS_SUCCESS_IMM;\n}\n\n \n \n \n \n \nstatic int\nips_flash_bios(ips_ha_t * ha, ips_passthru_t * pt, ips_scb_t * scb)\n{\n\n\tif (pt->CoppCP.cmd.flashfw.type == IPS_BIOS_IMAGE &&\n\t    pt->CoppCP.cmd.flashfw.direction == IPS_WRITE_BIOS) {\n\t\tif ((!ha->func.programbios) || (!ha->func.erasebios) ||\n\t\t    (!ha->func.verifybios))\n\t\t\tgoto error;\n\t\tif ((*ha->func.erasebios) (ha)) {\n\t\t\tDEBUG_VAR(1,\n\t\t\t\t  \"(%s%d) flash bios failed - unable to erase flash\",\n\t\t\t\t  ips_name, ha->host_num);\n\t\t\tgoto error;\n\t\t} else\n\t\t    if ((*ha->func.programbios) (ha,\n\t\t\t\t\t\t ha->flash_data +\n\t\t\t\t\t\t IPS_BIOS_HEADER,\n\t\t\t\t\t\t ha->flash_datasize -\n\t\t\t\t\t\t IPS_BIOS_HEADER, 0)) {\n\t\t\tDEBUG_VAR(1,\n\t\t\t\t  \"(%s%d) flash bios failed - unable to flash\",\n\t\t\t\t  ips_name, ha->host_num);\n\t\t\tgoto error;\n\t\t} else\n\t\t    if ((*ha->func.verifybios) (ha,\n\t\t\t\t\t\tha->flash_data +\n\t\t\t\t\t\tIPS_BIOS_HEADER,\n\t\t\t\t\t\tha->flash_datasize -\n\t\t\t\t\t\tIPS_BIOS_HEADER, 0)) {\n\t\t\tDEBUG_VAR(1,\n\t\t\t\t  \"(%s%d) flash bios failed - unable to verify flash\",\n\t\t\t\t  ips_name, ha->host_num);\n\t\t\tgoto error;\n\t\t}\n\t\tips_free_flash_copperhead(ha);\n\t\treturn IPS_SUCCESS_IMM;\n\t} else if (pt->CoppCP.cmd.flashfw.type == IPS_BIOS_IMAGE &&\n\t\t   pt->CoppCP.cmd.flashfw.direction == IPS_ERASE_BIOS) {\n\t\tif (!ha->func.erasebios)\n\t\t\tgoto error;\n\t\tif ((*ha->func.erasebios) (ha)) {\n\t\t\tDEBUG_VAR(1,\n\t\t\t\t  \"(%s%d) flash bios failed - unable to erase flash\",\n\t\t\t\t  ips_name, ha->host_num);\n\t\t\tgoto error;\n\t\t}\n\t\treturn IPS_SUCCESS_IMM;\n\t}\n      error:\n\tpt->BasicStatus = 0x0B;\n\tpt->ExtendedStatus = 0x00;\n\tips_free_flash_copperhead(ha);\n\treturn IPS_FAILURE;\n}\n\n \n \n \n \n \n \n \n \nstatic int\nips_fill_scb_sg_single(ips_ha_t * ha, dma_addr_t busaddr,\n\t\t       ips_scb_t * scb, int indx, unsigned int e_len)\n{\n\n\tint ret_val = 0;\n\n\tif ((scb->data_len + e_len) > ha->max_xfer) {\n\t\te_len = ha->max_xfer - scb->data_len;\n\t\tscb->breakup = indx;\n\t\t++scb->sg_break;\n\t\tret_val = -1;\n\t} else {\n\t\tscb->breakup = 0;\n\t\tscb->sg_break = 0;\n\t}\n\tif (IPS_USE_ENH_SGLIST(ha)) {\n\t\tscb->sg_list.enh_list[indx].address_lo =\n\t\t    cpu_to_le32(lower_32_bits(busaddr));\n\t\tscb->sg_list.enh_list[indx].address_hi =\n\t\t    cpu_to_le32(upper_32_bits(busaddr));\n\t\tscb->sg_list.enh_list[indx].length = cpu_to_le32(e_len);\n\t} else {\n\t\tscb->sg_list.std_list[indx].address =\n\t\t    cpu_to_le32(lower_32_bits(busaddr));\n\t\tscb->sg_list.std_list[indx].length = cpu_to_le32(e_len);\n\t}\n\n\t++scb->sg_len;\n\tscb->data_len += e_len;\n\treturn ret_val;\n}\n\n \n \n \n \n \nstatic int\nips_flash_firmware(ips_ha_t * ha, ips_passthru_t * pt, ips_scb_t * scb)\n{\n\tIPS_SG_LIST sg_list;\n\tuint32_t cmd_busaddr;\n\n\tif (pt->CoppCP.cmd.flashfw.type == IPS_FW_IMAGE &&\n\t    pt->CoppCP.cmd.flashfw.direction == IPS_WRITE_FW) {\n\t\tmemset(&pt->CoppCP.cmd, 0, sizeof (IPS_HOST_COMMAND));\n\t\tpt->CoppCP.cmd.flashfw.op_code = IPS_CMD_DOWNLOAD;\n\t\tpt->CoppCP.cmd.flashfw.count = cpu_to_le32(ha->flash_datasize);\n\t} else {\n\t\tpt->BasicStatus = 0x0B;\n\t\tpt->ExtendedStatus = 0x00;\n\t\tips_free_flash_copperhead(ha);\n\t\treturn IPS_FAILURE;\n\t}\n\t \n\tsg_list.list = scb->sg_list.list;\n\tcmd_busaddr = scb->scb_busaddr;\n\t \n\tmemcpy(&scb->cmd, &pt->CoppCP.cmd, sizeof (IPS_IOCTL_CMD));\n\t \n\tscb->sg_list.list = sg_list.list;\n\tscb->scb_busaddr = cmd_busaddr;\n\tscb->bus = scb->scsi_cmd->device->channel;\n\tscb->target_id = scb->scsi_cmd->device->id;\n\tscb->lun = scb->scsi_cmd->device->lun;\n\tscb->sg_len = 0;\n\tscb->data_len = 0;\n\tscb->flags = 0;\n\tscb->op_code = 0;\n\tscb->callback = ipsintr_done;\n\tscb->timeout = ips_cmd_timeout;\n\n\tscb->data_len = ha->flash_datasize;\n\tscb->data_busaddr =\n\t    dma_map_single(&ha->pcidev->dev, ha->flash_data, scb->data_len,\n\t\t\t   IPS_DMA_DIR(scb));\n\tscb->flags |= IPS_SCB_MAP_SINGLE;\n\tscb->cmd.flashfw.command_id = IPS_COMMAND_ID(ha, scb);\n\tscb->cmd.flashfw.buffer_addr = cpu_to_le32(scb->data_busaddr);\n\tif (pt->TimeOut)\n\t\tscb->timeout = pt->TimeOut;\n\tscb->scsi_cmd->result = DID_OK << 16;\n\treturn IPS_SUCCESS;\n}\n\n \n \n \n \n \nstatic void\nips_free_flash_copperhead(ips_ha_t * ha)\n{\n\tif (ha->flash_data == ips_FlashData)\n\t\ttest_and_clear_bit(0, &ips_FlashDataInUse);\n\telse if (ha->flash_data)\n\t\tdma_free_coherent(&ha->pcidev->dev, ha->flash_len,\n\t\t\t\t  ha->flash_data, ha->flash_busaddr);\n\tha->flash_data = NULL;\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_usrcmd(ips_ha_t * ha, ips_passthru_t * pt, ips_scb_t * scb)\n{\n\tIPS_SG_LIST sg_list;\n\tuint32_t cmd_busaddr;\n\n\tMETHOD_TRACE(\"ips_usrcmd\", 1);\n\n\tif ((!scb) || (!pt) || (!ha))\n\t\treturn (0);\n\n\t \n\tsg_list.list = scb->sg_list.list;\n\tcmd_busaddr = scb->scb_busaddr;\n\t \n\tmemcpy(&scb->cmd, &pt->CoppCP.cmd, sizeof (IPS_IOCTL_CMD));\n\tmemcpy(&scb->dcdb, &pt->CoppCP.dcdb, sizeof (IPS_DCDB_TABLE));\n\n\t \n\tscb->sg_list.list = sg_list.list;\n\tscb->scb_busaddr = cmd_busaddr;\n\tscb->bus = scb->scsi_cmd->device->channel;\n\tscb->target_id = scb->scsi_cmd->device->id;\n\tscb->lun = scb->scsi_cmd->device->lun;\n\tscb->sg_len = 0;\n\tscb->data_len = 0;\n\tscb->flags = 0;\n\tscb->op_code = 0;\n\tscb->callback = ipsintr_done;\n\tscb->timeout = ips_cmd_timeout;\n\tscb->cmd.basic_io.command_id = IPS_COMMAND_ID(ha, scb);\n\n\t \n\tif ((scb->cmd.basic_io.op_code == IPS_CMD_READ_SG) ||\n\t    (scb->cmd.basic_io.op_code == IPS_CMD_WRITE_SG) ||\n\t    (scb->cmd.basic_io.op_code == IPS_CMD_DCDB_SG))\n\t\treturn (0);\n\n\tif (pt->CmdBSize) {\n\t\tscb->data_len = pt->CmdBSize;\n\t\tscb->data_busaddr = ha->ioctl_busaddr + sizeof (ips_passthru_t);\n\t} else {\n\t\tscb->data_busaddr = 0L;\n\t}\n\n\tif (scb->cmd.dcdb.op_code == IPS_CMD_DCDB)\n\t\tscb->cmd.dcdb.dcdb_address = cpu_to_le32(scb->scb_busaddr +\n\t\t\t\t\t\t\t (unsigned long) &scb->\n\t\t\t\t\t\t\t dcdb -\n\t\t\t\t\t\t\t (unsigned long) scb);\n\n\tif (pt->CmdBSize) {\n\t\tif (scb->cmd.dcdb.op_code == IPS_CMD_DCDB)\n\t\t\tscb->dcdb.buffer_pointer =\n\t\t\t    cpu_to_le32(scb->data_busaddr);\n\t\telse\n\t\t\tscb->cmd.basic_io.sg_addr =\n\t\t\t    cpu_to_le32(scb->data_busaddr);\n\t}\n\n\t \n\tif (pt->TimeOut) {\n\t\tscb->timeout = pt->TimeOut;\n\n\t\tif (pt->TimeOut <= 10)\n\t\t\tscb->dcdb.cmd_attribute |= IPS_TIMEOUT10;\n\t\telse if (pt->TimeOut <= 60)\n\t\t\tscb->dcdb.cmd_attribute |= IPS_TIMEOUT60;\n\t\telse\n\t\t\tscb->dcdb.cmd_attribute |= IPS_TIMEOUT20M;\n\t}\n\n\t \n\tscb->scsi_cmd->result = DID_OK << 16;\n\n\t \n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic void\nips_cleanup_passthru(ips_ha_t * ha, ips_scb_t * scb)\n{\n\tips_passthru_t *pt;\n\n\tMETHOD_TRACE(\"ips_cleanup_passthru\", 1);\n\n\tif ((!scb) || (!scb->scsi_cmd) || (!scsi_sglist(scb->scsi_cmd))) {\n\t\tDEBUG_VAR(1, \"(%s%d) couldn't cleanup after passthru\",\n\t\t\t  ips_name, ha->host_num);\n\n\t\treturn;\n\t}\n\tpt = (ips_passthru_t *) ha->ioctl_data;\n\n\t \n\tif (scb->cmd.dcdb.op_code == IPS_CMD_DCDB)\t \n\t\tmemcpy(&pt->CoppCP.dcdb, &scb->dcdb, sizeof (IPS_DCDB_TABLE));\n\n\tpt->BasicStatus = scb->basic_status;\n\tpt->ExtendedStatus = scb->extended_status;\n\tpt->AdapterType = ha->ad_type;\n\n\tif (ha->pcidev->device == IPS_DEVICEID_COPPERHEAD &&\n\t    (scb->cmd.flashfw.op_code == IPS_CMD_DOWNLOAD ||\n\t     scb->cmd.flashfw.op_code == IPS_CMD_RW_BIOSFW))\n\t\tips_free_flash_copperhead(ha);\n\n\tips_scmd_buf_write(scb->scsi_cmd, ha->ioctl_data, ha->ioctl_datasize);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_host_info(ips_ha_t *ha, struct seq_file *m)\n{\n\tMETHOD_TRACE(\"ips_host_info\", 1);\n\n\tseq_puts(m, \"\\nIBM ServeRAID General Information:\\n\\n\");\n\n\tif ((le32_to_cpu(ha->nvram->signature) == IPS_NVRAM_P5_SIG) &&\n\t    (le16_to_cpu(ha->nvram->adapter_type) != 0))\n\t\tseq_printf(m, \"\\tController Type                   : %s\\n\",\n\t\t\t  ips_adapter_name[ha->ad_type - 1]);\n\telse\n\t\tseq_puts(m, \"\\tController Type                   : Unknown\\n\");\n\n\tif (ha->io_addr)\n\t\tseq_printf(m,\n\t\t\t  \"\\tIO region                         : 0x%x (%d bytes)\\n\",\n\t\t\t  ha->io_addr, ha->io_len);\n\n\tif (ha->mem_addr) {\n\t\tseq_printf(m,\n\t\t\t  \"\\tMemory region                     : 0x%x (%d bytes)\\n\",\n\t\t\t  ha->mem_addr, ha->mem_len);\n\t\tseq_printf(m,\n\t\t\t  \"\\tShared memory address             : 0x%lx\\n\",\n\t\t\t  (unsigned long)ha->mem_ptr);\n\t}\n\n\tseq_printf(m, \"\\tIRQ number                        : %d\\n\", ha->pcidev->irq);\n\n     \n     \n\n\tif (le32_to_cpu(ha->nvram->signature) == IPS_NVRAM_P5_SIG) {\n\tif (ha->nvram->bios_low[3] == 0) {\n\t\tseq_printf(m,\n\t\t\t  \"\\tBIOS Version                      : %c%c%c%c%c%c%c\\n\",\n\t\t\t  ha->nvram->bios_high[0], ha->nvram->bios_high[1],\n\t\t\t  ha->nvram->bios_high[2], ha->nvram->bios_high[3],\n\t\t\t  ha->nvram->bios_low[0], ha->nvram->bios_low[1],\n\t\t\t  ha->nvram->bios_low[2]);\n\n        } else {\n\t\tseq_printf(m,\n\t\t\t  \"\\tBIOS Version                      : %c%c%c%c%c%c%c%c\\n\",\n\t\t\t  ha->nvram->bios_high[0], ha->nvram->bios_high[1],\n\t\t\t  ha->nvram->bios_high[2], ha->nvram->bios_high[3],\n\t\t\t  ha->nvram->bios_low[0], ha->nvram->bios_low[1],\n\t\t\t  ha->nvram->bios_low[2], ha->nvram->bios_low[3]);\n        }\n\n    }\n\n    if (ha->enq->CodeBlkVersion[7] == 0) {\n        seq_printf(m,\n\t\t  \"\\tFirmware Version                  : %c%c%c%c%c%c%c\\n\",\n\t\t  ha->enq->CodeBlkVersion[0], ha->enq->CodeBlkVersion[1],\n\t\t  ha->enq->CodeBlkVersion[2], ha->enq->CodeBlkVersion[3],\n\t\t  ha->enq->CodeBlkVersion[4], ha->enq->CodeBlkVersion[5],\n\t\t  ha->enq->CodeBlkVersion[6]);\n    } else {\n\tseq_printf(m,\n\t\t  \"\\tFirmware Version                  : %c%c%c%c%c%c%c%c\\n\",\n\t\t  ha->enq->CodeBlkVersion[0], ha->enq->CodeBlkVersion[1],\n\t\t  ha->enq->CodeBlkVersion[2], ha->enq->CodeBlkVersion[3],\n\t\t  ha->enq->CodeBlkVersion[4], ha->enq->CodeBlkVersion[5],\n\t\t  ha->enq->CodeBlkVersion[6], ha->enq->CodeBlkVersion[7]);\n    }\n\n    if (ha->enq->BootBlkVersion[7] == 0) {\n        seq_printf(m,\n\t\t  \"\\tBoot Block Version                : %c%c%c%c%c%c%c\\n\",\n\t\t  ha->enq->BootBlkVersion[0], ha->enq->BootBlkVersion[1],\n\t\t  ha->enq->BootBlkVersion[2], ha->enq->BootBlkVersion[3],\n\t\t  ha->enq->BootBlkVersion[4], ha->enq->BootBlkVersion[5],\n\t\t  ha->enq->BootBlkVersion[6]);\n    } else {\n        seq_printf(m,\n\t\t  \"\\tBoot Block Version                : %c%c%c%c%c%c%c%c\\n\",\n\t\t  ha->enq->BootBlkVersion[0], ha->enq->BootBlkVersion[1],\n\t\t  ha->enq->BootBlkVersion[2], ha->enq->BootBlkVersion[3],\n\t\t  ha->enq->BootBlkVersion[4], ha->enq->BootBlkVersion[5],\n\t\t  ha->enq->BootBlkVersion[6], ha->enq->BootBlkVersion[7]);\n    }\n\n\tseq_printf(m, \"\\tDriver Version                    : %s%s\\n\",\n\t\t  IPS_VERSION_HIGH, IPS_VERSION_LOW);\n\n\tseq_printf(m, \"\\tDriver Build                      : %d\\n\",\n\t\t  IPS_BUILD_IDENT);\n\n\tseq_printf(m, \"\\tMax Physical Devices              : %d\\n\",\n\t\t  ha->enq->ucMaxPhysicalDevices);\n\tseq_printf(m, \"\\tMax Active Commands               : %d\\n\",\n\t\t  ha->max_cmds);\n\tseq_printf(m, \"\\tCurrent Queued Commands           : %d\\n\",\n\t\t  ha->scb_waitlist.count);\n\tseq_printf(m, \"\\tCurrent Active Commands           : %d\\n\",\n\t\t  ha->scb_activelist.count - ha->num_ioctl);\n\tseq_printf(m, \"\\tCurrent Queued PT Commands        : %d\\n\",\n\t\t  ha->copp_waitlist.count);\n\tseq_printf(m, \"\\tCurrent Active PT Commands        : %d\\n\",\n\t\t  ha->num_ioctl);\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}\n\n \n \n \n \n \n \n \n \n \nstatic void\nips_identify_controller(ips_ha_t * ha)\n{\n\tMETHOD_TRACE(\"ips_identify_controller\", 1);\n\n\tswitch (ha->pcidev->device) {\n\tcase IPS_DEVICEID_COPPERHEAD:\n\t\tif (ha->pcidev->revision <= IPS_REVID_SERVERAID) {\n\t\t\tha->ad_type = IPS_ADTYPE_SERVERAID;\n\t\t} else if (ha->pcidev->revision == IPS_REVID_SERVERAID2) {\n\t\t\tha->ad_type = IPS_ADTYPE_SERVERAID2;\n\t\t} else if (ha->pcidev->revision == IPS_REVID_NAVAJO) {\n\t\t\tha->ad_type = IPS_ADTYPE_NAVAJO;\n\t\t} else if ((ha->pcidev->revision == IPS_REVID_SERVERAID2)\n\t\t\t   && (ha->slot_num == 0)) {\n\t\t\tha->ad_type = IPS_ADTYPE_KIOWA;\n\t\t} else if ((ha->pcidev->revision >= IPS_REVID_CLARINETP1) &&\n\t\t\t   (ha->pcidev->revision <= IPS_REVID_CLARINETP3)) {\n\t\t\tif (ha->enq->ucMaxPhysicalDevices == 15)\n\t\t\t\tha->ad_type = IPS_ADTYPE_SERVERAID3L;\n\t\t\telse\n\t\t\t\tha->ad_type = IPS_ADTYPE_SERVERAID3;\n\t\t} else if ((ha->pcidev->revision >= IPS_REVID_TROMBONE32) &&\n\t\t\t   (ha->pcidev->revision <= IPS_REVID_TROMBONE64)) {\n\t\t\tha->ad_type = IPS_ADTYPE_SERVERAID4H;\n\t\t}\n\t\tbreak;\n\n\tcase IPS_DEVICEID_MORPHEUS:\n\t\tswitch (ha->pcidev->subsystem_device) {\n\t\tcase IPS_SUBDEVICEID_4L:\n\t\t\tha->ad_type = IPS_ADTYPE_SERVERAID4L;\n\t\t\tbreak;\n\n\t\tcase IPS_SUBDEVICEID_4M:\n\t\t\tha->ad_type = IPS_ADTYPE_SERVERAID4M;\n\t\t\tbreak;\n\n\t\tcase IPS_SUBDEVICEID_4MX:\n\t\t\tha->ad_type = IPS_ADTYPE_SERVERAID4MX;\n\t\t\tbreak;\n\n\t\tcase IPS_SUBDEVICEID_4LX:\n\t\t\tha->ad_type = IPS_ADTYPE_SERVERAID4LX;\n\t\t\tbreak;\n\n\t\tcase IPS_SUBDEVICEID_5I2:\n\t\t\tha->ad_type = IPS_ADTYPE_SERVERAID5I2;\n\t\t\tbreak;\n\n\t\tcase IPS_SUBDEVICEID_5I1:\n\t\t\tha->ad_type = IPS_ADTYPE_SERVERAID5I1;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase IPS_DEVICEID_MARCO:\n\t\tswitch (ha->pcidev->subsystem_device) {\n\t\tcase IPS_SUBDEVICEID_6M:\n\t\t\tha->ad_type = IPS_ADTYPE_SERVERAID6M;\n\t\t\tbreak;\n\t\tcase IPS_SUBDEVICEID_6I:\n\t\t\tha->ad_type = IPS_ADTYPE_SERVERAID6I;\n\t\t\tbreak;\n\t\tcase IPS_SUBDEVICEID_7k:\n\t\t\tha->ad_type = IPS_ADTYPE_SERVERAID7k;\n\t\t\tbreak;\n\t\tcase IPS_SUBDEVICEID_7M:\n\t\t\tha->ad_type = IPS_ADTYPE_SERVERAID7M;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \n \n \n \n \n \n \n \n \nstatic void\nips_get_bios_version(ips_ha_t * ha, int intr)\n{\n\tips_scb_t *scb;\n\tint ret;\n\tuint8_t major;\n\tuint8_t minor;\n\tuint8_t subminor;\n\tuint8_t *buffer;\n\n\tMETHOD_TRACE(\"ips_get_bios_version\", 1);\n\n\tmajor = 0;\n\tminor = 0;\n\n\tmemcpy(ha->bios_version, \"       ?\", 8);\n\n\tif (ha->pcidev->device == IPS_DEVICEID_COPPERHEAD) {\n\t\tif (IPS_USE_MEMIO(ha)) {\n\t\t\t \n\n\t\t\t \n\t\t\twritel(0, ha->mem_ptr + IPS_REG_FLAP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\tif (readb(ha->mem_ptr + IPS_REG_FLDP) != 0x55)\n\t\t\t\treturn;\n\n\t\t\twritel(1, ha->mem_ptr + IPS_REG_FLAP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\tif (readb(ha->mem_ptr + IPS_REG_FLDP) != 0xAA)\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\twritel(0x1FF, ha->mem_ptr + IPS_REG_FLAP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\tmajor = readb(ha->mem_ptr + IPS_REG_FLDP);\n\n\t\t\t \n\t\t\twritel(0x1FE, ha->mem_ptr + IPS_REG_FLAP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\t\t\tminor = readb(ha->mem_ptr + IPS_REG_FLDP);\n\n\t\t\t \n\t\t\twritel(0x1FD, ha->mem_ptr + IPS_REG_FLAP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\t\t\tsubminor = readb(ha->mem_ptr + IPS_REG_FLDP);\n\n\t\t} else {\n\t\t\t \n\n\t\t\t \n\t\t\toutl(0, ha->io_addr + IPS_REG_FLAP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\tif (inb(ha->io_addr + IPS_REG_FLDP) != 0x55)\n\t\t\t\treturn;\n\n\t\t\toutl(1, ha->io_addr + IPS_REG_FLAP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\tif (inb(ha->io_addr + IPS_REG_FLDP) != 0xAA)\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\toutl(0x1FF, ha->io_addr + IPS_REG_FLAP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\tmajor = inb(ha->io_addr + IPS_REG_FLDP);\n\n\t\t\t \n\t\t\toutl(0x1FE, ha->io_addr + IPS_REG_FLAP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\tminor = inb(ha->io_addr + IPS_REG_FLDP);\n\n\t\t\t \n\t\t\toutl(0x1FD, ha->io_addr + IPS_REG_FLAP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\tsubminor = inb(ha->io_addr + IPS_REG_FLDP);\n\n\t\t}\n\t} else {\n\t\t \n\n\t\tbuffer = ha->ioctl_data;\n\n\t\tmemset(buffer, 0, 0x1000);\n\n\t\tscb = &ha->scbs[ha->max_cmds - 1];\n\n\t\tips_init_scb(ha, scb);\n\n\t\tscb->timeout = ips_cmd_timeout;\n\t\tscb->cdb[0] = IPS_CMD_RW_BIOSFW;\n\n\t\tscb->cmd.flashfw.op_code = IPS_CMD_RW_BIOSFW;\n\t\tscb->cmd.flashfw.command_id = IPS_COMMAND_ID(ha, scb);\n\t\tscb->cmd.flashfw.type = 1;\n\t\tscb->cmd.flashfw.direction = 0;\n\t\tscb->cmd.flashfw.count = cpu_to_le32(0x800);\n\t\tscb->cmd.flashfw.total_packets = 1;\n\t\tscb->cmd.flashfw.packet_num = 0;\n\t\tscb->data_len = 0x1000;\n\t\tscb->cmd.flashfw.buffer_addr = ha->ioctl_busaddr;\n\n\t\t \n\t\tif (((ret =\n\t\t      ips_send_wait(ha, scb, ips_cmd_timeout,\n\t\t\t\t    intr)) == IPS_FAILURE)\n\t\t    || (ret == IPS_SUCCESS_IMM)\n\t\t    || ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1)) {\n\t\t\t \n\n\t\t\treturn;\n\t\t}\n\n\t\tif ((buffer[0xC0] == 0x55) && (buffer[0xC1] == 0xAA)) {\n\t\t\tmajor = buffer[0x1ff + 0xC0];\t \n\t\t\tminor = buffer[0x1fe + 0xC0];\t \n\t\t\tsubminor = buffer[0x1fd + 0xC0];\t \n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tha->bios_version[0] = hex_asc_upper_hi(major);\n\tha->bios_version[1] = '.';\n\tha->bios_version[2] = hex_asc_upper_lo(major);\n\tha->bios_version[3] = hex_asc_upper_lo(subminor);\n\tha->bios_version[4] = '.';\n\tha->bios_version[5] = hex_asc_upper_hi(minor);\n\tha->bios_version[6] = hex_asc_upper_lo(minor);\n\tha->bios_version[7] = 0;\n}\n\n \n \n \n \n \n \n \n \n \n \n \nstatic int\nips_hainit(ips_ha_t * ha)\n{\n\tint i;\n\n\tMETHOD_TRACE(\"ips_hainit\", 1);\n\n\tif (!ha)\n\t\treturn (0);\n\n\tif (ha->func.statinit)\n\t\t(*ha->func.statinit) (ha);\n\n\tif (ha->func.enableint)\n\t\t(*ha->func.enableint) (ha);\n\n\t \n\tha->reset_count = 1;\n\tha->last_ffdc = ktime_get_real_seconds();\n\tips_ffdc_reset(ha, IPS_INTR_IORL);\n\n\tif (!ips_read_config(ha, IPS_INTR_IORL)) {\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"unable to read config from controller.\\n\");\n\n\t\treturn (0);\n\t}\n\t \n\tif (!ips_read_adapter_status(ha, IPS_INTR_IORL)) {\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"unable to read controller status.\\n\");\n\n\t\treturn (0);\n\t}\n\n\t \n\tips_identify_controller(ha);\n\n\tif (!ips_read_subsystem_parameters(ha, IPS_INTR_IORL)) {\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"unable to read subsystem parameters.\\n\");\n\n\t\treturn (0);\n\t}\n\n\t \n\tif (!ips_write_driver_status(ha, IPS_INTR_IORL)) {\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"unable to write driver info to controller.\\n\");\n\n\t\treturn (0);\n\t}\n\n\t \n\tif ((ha->conf->ucLogDriveCount > 0) && (ha->requires_esl == 1))\n\t\tips_clear_adapter(ha, IPS_INTR_IORL);\n\n\t \n\tha->ntargets = IPS_MAX_TARGETS + 1;\n\tha->nlun = 1;\n\tha->nbus = (ha->enq->ucMaxPhysicalDevices / IPS_MAX_TARGETS) + 1;\n\n\tswitch (ha->conf->logical_drive[0].ucStripeSize) {\n\tcase 4:\n\t\tha->max_xfer = 0x10000;\n\t\tbreak;\n\n\tcase 5:\n\t\tha->max_xfer = 0x20000;\n\t\tbreak;\n\n\tcase 6:\n\t\tha->max_xfer = 0x40000;\n\t\tbreak;\n\n\tcase 7:\n\tdefault:\n\t\tha->max_xfer = 0x80000;\n\t\tbreak;\n\t}\n\n\t \n\tif (le32_to_cpu(ha->subsys->param[4]) & 0x1) {\n\t\t \n\t\tha->max_cmds = ha->enq->ucConcurrentCmdCount;\n\t} else {\n\t\t \n\t\tswitch (ha->conf->logical_drive[0].ucStripeSize) {\n\t\tcase 4:\n\t\t\tha->max_cmds = 32;\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\tha->max_cmds = 16;\n\t\t\tbreak;\n\n\t\tcase 6:\n\t\t\tha->max_cmds = 8;\n\t\t\tbreak;\n\n\t\tcase 7:\n\t\tdefault:\n\t\t\tha->max_cmds = 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif ((ha->ad_type == IPS_ADTYPE_SERVERAID3L) ||\n\t    (ha->ad_type == IPS_ADTYPE_SERVERAID4L) ||\n\t    (ha->ad_type == IPS_ADTYPE_SERVERAID4LX)) {\n\t\tif ((ha->max_cmds > MaxLiteCmds) && (MaxLiteCmds))\n\t\t\tha->max_cmds = MaxLiteCmds;\n\t}\n\n\t \n\tha->ha_id[0] = IPS_ADAPTER_ID;\n\tfor (i = 1; i < ha->nbus; i++) {\n\t\tha->ha_id[i] = ha->conf->init_id[i - 1] & 0x1f;\n\t\tha->dcdb_active[i - 1] = 0;\n\t}\n\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic void\nips_next(ips_ha_t * ha, int intr)\n{\n\tips_scb_t *scb;\n\tstruct scsi_cmnd *SC;\n\tstruct scsi_cmnd *p;\n\tstruct scsi_cmnd *q;\n\tips_copp_wait_item_t *item;\n\tint ret;\n\tstruct Scsi_Host *host;\n\tMETHOD_TRACE(\"ips_next\", 1);\n\n\tif (!ha)\n\t\treturn;\n\thost = ips_sh[ha->host_num];\n\t \n\tif (intr == IPS_INTR_ON)\n\t\tspin_lock(host->host_lock);\n\n\tif ((ha->subsys->param[3] & 0x300000)\n\t    && (ha->scb_activelist.count == 0)) {\n\t\ttime64_t now = ktime_get_real_seconds();\n\t\tif (now - ha->last_ffdc > IPS_SECS_8HOURS) {\n\t\t\tha->last_ffdc = now;\n\t\t\tips_ffdc_time(ha);\n\t\t}\n\t}\n\n\t \n\twhile ((ha->num_ioctl < IPS_MAX_IOCTL) &&\n\t       (ha->copp_waitlist.head) && (scb = ips_getscb(ha))) {\n\n\t\titem = ips_removeq_copp_head(&ha->copp_waitlist);\n\t\tha->num_ioctl++;\n\t\tif (intr == IPS_INTR_ON)\n\t\t\tspin_unlock(host->host_lock);\n\t\tscb->scsi_cmd = item->scsi_cmd;\n\t\tkfree(item);\n\n\t\tret = ips_make_passthru(ha, scb->scsi_cmd, scb, intr);\n\n\t\tif (intr == IPS_INTR_ON)\n\t\t\tspin_lock(host->host_lock);\n\t\tswitch (ret) {\n\t\tcase IPS_FAILURE:\n\t\t\tif (scb->scsi_cmd) {\n\t\t\t\tscb->scsi_cmd->result = DID_ERROR << 16;\n\t\t\t\tscsi_done(scb->scsi_cmd);\n\t\t\t}\n\n\t\t\tips_freescb(ha, scb);\n\t\t\tbreak;\n\t\tcase IPS_SUCCESS_IMM:\n\t\t\tif (scb->scsi_cmd) {\n\t\t\t\tscb->scsi_cmd->result = DID_OK << 16;\n\t\t\t\tscsi_done(scb->scsi_cmd);\n\t\t\t}\n\n\t\t\tips_freescb(ha, scb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\t\t \n\n\t\tif (ret != IPS_SUCCESS) {\n\t\t\tha->num_ioctl--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = ips_send_cmd(ha, scb);\n\n\t\tif (ret == IPS_SUCCESS)\n\t\t\tips_putq_scb_head(&ha->scb_activelist, scb);\n\t\telse\n\t\t\tha->num_ioctl--;\n\n\t\tswitch (ret) {\n\t\tcase IPS_FAILURE:\n\t\t\tif (scb->scsi_cmd) {\n\t\t\t\tscb->scsi_cmd->result = DID_ERROR << 16;\n\t\t\t}\n\n\t\t\tips_freescb(ha, scb);\n\t\t\tbreak;\n\t\tcase IPS_SUCCESS_IMM:\n\t\t\tips_freescb(ha, scb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\t\t \n\n\t}\n\n\t \n\n\tp = ha->scb_waitlist.head;\n\twhile ((p) && (scb = ips_getscb(ha))) {\n\t\tif ((scmd_channel(p) > 0)\n\t\t    && (ha->\n\t\t\tdcdb_active[scmd_channel(p) -\n\t\t\t\t    1] & (1 << scmd_id(p)))) {\n\t\t\tips_freescb(ha, scb);\n\t\t\tp = (struct scsi_cmnd *) p->host_scribble;\n\t\t\tcontinue;\n\t\t}\n\n\t\tq = p;\n\t\tSC = ips_removeq_wait(&ha->scb_waitlist, q);\n\n\t\tif (intr == IPS_INTR_ON)\n\t\t\tspin_unlock(host->host_lock);\t \n\n\t\tSC->result = DID_OK;\n\t\tSC->host_scribble = NULL;\n\n\t\tscb->target_id = SC->device->id;\n\t\tscb->lun = SC->device->lun;\n\t\tscb->bus = SC->device->channel;\n\t\tscb->scsi_cmd = SC;\n\t\tscb->breakup = 0;\n\t\tscb->data_len = 0;\n\t\tscb->callback = ipsintr_done;\n\t\tscb->timeout = ips_cmd_timeout;\n\t\tmemset(&scb->cmd, 0, 16);\n\n\t\t \n\t\tmemcpy(scb->cdb, SC->cmnd, SC->cmd_len);\n\n                scb->sg_count = scsi_dma_map(SC);\n                BUG_ON(scb->sg_count < 0);\n\t\tif (scb->sg_count) {\n\t\t\tstruct scatterlist *sg;\n\t\t\tint i;\n\n\t\t\tscb->flags |= IPS_SCB_MAP_SG;\n\n                        scsi_for_each_sg(SC, sg, scb->sg_count, i) {\n\t\t\t\tif (ips_fill_scb_sg_single\n\t\t\t\t    (ha, sg_dma_address(sg), scb, i,\n\t\t\t\t     sg_dma_len(sg)) < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tscb->dcdb.transfer_length = scb->data_len;\n\t\t} else {\n                        scb->data_busaddr = 0L;\n                        scb->sg_len = 0;\n                        scb->data_len = 0;\n                        scb->dcdb.transfer_length = 0;\n\t\t}\n\n\t\tscb->dcdb.cmd_attribute =\n\t\t    ips_command_direction[scb->scsi_cmd->cmnd[0]];\n\n\t\t \n\t\t \n\t\tif ((scb->scsi_cmd->cmnd[0] == WRITE_BUFFER) &&\n\t\t\t\t(scb->data_len == 0))\n\t\t\tscb->dcdb.cmd_attribute = 0;\n\n\t\tif (!(scb->dcdb.cmd_attribute & 0x3))\n\t\t\tscb->dcdb.transfer_length = 0;\n\n\t\tif (scb->data_len >= IPS_MAX_XFER) {\n\t\t\tscb->dcdb.cmd_attribute |= IPS_TRANSFER64K;\n\t\t\tscb->dcdb.transfer_length = 0;\n\t\t}\n\t\tif (intr == IPS_INTR_ON)\n\t\t\tspin_lock(host->host_lock);\n\n\t\tret = ips_send_cmd(ha, scb);\n\n\t\tswitch (ret) {\n\t\tcase IPS_SUCCESS:\n\t\t\tips_putq_scb_head(&ha->scb_activelist, scb);\n\t\t\tbreak;\n\t\tcase IPS_FAILURE:\n\t\t\tif (scb->scsi_cmd) {\n\t\t\t\tscb->scsi_cmd->result = DID_ERROR << 16;\n\t\t\t\tscsi_done(scb->scsi_cmd);\n\t\t\t}\n\n\t\t\tif (scb->bus)\n\t\t\t\tha->dcdb_active[scb->bus - 1] &=\n\t\t\t\t    ~(1 << scb->target_id);\n\n\t\t\tips_freescb(ha, scb);\n\t\t\tbreak;\n\t\tcase IPS_SUCCESS_IMM:\n\t\t\tif (scb->scsi_cmd)\n\t\t\t\tscsi_done(scb->scsi_cmd);\n\n\t\t\tif (scb->bus)\n\t\t\t\tha->dcdb_active[scb->bus - 1] &=\n\t\t\t\t    ~(1 << scb->target_id);\n\n\t\t\tips_freescb(ha, scb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\t\t \n\n\t\tp = (struct scsi_cmnd *) p->host_scribble;\n\n\t}\t\t\t \n\n\tif (intr == IPS_INTR_ON)\n\t\tspin_unlock(host->host_lock);\n}\n\n \n \n \n \n \n \n \n \n \n \n \nstatic void\nips_putq_scb_head(ips_scb_queue_t * queue, ips_scb_t * item)\n{\n\tMETHOD_TRACE(\"ips_putq_scb_head\", 1);\n\n\tif (!item)\n\t\treturn;\n\n\titem->q_next = queue->head;\n\tqueue->head = item;\n\n\tif (!queue->tail)\n\t\tqueue->tail = item;\n\n\tqueue->count++;\n}\n\n \n \n \n \n \n \n \n \n \n \n \nstatic ips_scb_t *\nips_removeq_scb_head(ips_scb_queue_t * queue)\n{\n\tips_scb_t *item;\n\n\tMETHOD_TRACE(\"ips_removeq_scb_head\", 1);\n\n\titem = queue->head;\n\n\tif (!item) {\n\t\treturn (NULL);\n\t}\n\n\tqueue->head = item->q_next;\n\titem->q_next = NULL;\n\n\tif (queue->tail == item)\n\t\tqueue->tail = NULL;\n\n\tqueue->count--;\n\n\treturn (item);\n}\n\n \n \n \n \n \n \n \n \n \n \n \nstatic ips_scb_t *\nips_removeq_scb(ips_scb_queue_t * queue, ips_scb_t * item)\n{\n\tips_scb_t *p;\n\n\tMETHOD_TRACE(\"ips_removeq_scb\", 1);\n\n\tif (!item)\n\t\treturn (NULL);\n\n\tif (item == queue->head) {\n\t\treturn (ips_removeq_scb_head(queue));\n\t}\n\n\tp = queue->head;\n\n\twhile ((p) && (item != p->q_next))\n\t\tp = p->q_next;\n\n\tif (p) {\n\t\t \n\t\tp->q_next = item->q_next;\n\n\t\tif (!item->q_next)\n\t\t\tqueue->tail = p;\n\n\t\titem->q_next = NULL;\n\t\tqueue->count--;\n\n\t\treturn (item);\n\t}\n\n\treturn (NULL);\n}\n\n \n \n \n \n \n \n \n \n \n \n \nstatic void ips_putq_wait_tail(ips_wait_queue_entry_t *queue, struct scsi_cmnd *item)\n{\n\tMETHOD_TRACE(\"ips_putq_wait_tail\", 1);\n\n\tif (!item)\n\t\treturn;\n\n\titem->host_scribble = NULL;\n\n\tif (queue->tail)\n\t\tqueue->tail->host_scribble = (char *) item;\n\n\tqueue->tail = item;\n\n\tif (!queue->head)\n\t\tqueue->head = item;\n\n\tqueue->count++;\n}\n\n \n \n \n \n \n \n \n \n \n \n \nstatic struct scsi_cmnd *ips_removeq_wait_head(ips_wait_queue_entry_t *queue)\n{\n\tstruct scsi_cmnd *item;\n\n\tMETHOD_TRACE(\"ips_removeq_wait_head\", 1);\n\n\titem = queue->head;\n\n\tif (!item) {\n\t\treturn (NULL);\n\t}\n\n\tqueue->head = (struct scsi_cmnd *) item->host_scribble;\n\titem->host_scribble = NULL;\n\n\tif (queue->tail == item)\n\t\tqueue->tail = NULL;\n\n\tqueue->count--;\n\n\treturn (item);\n}\n\n \n \n \n \n \n \n \n \n \n \n \nstatic struct scsi_cmnd *ips_removeq_wait(ips_wait_queue_entry_t *queue,\n\t\t\t\t\t  struct scsi_cmnd *item)\n{\n\tstruct scsi_cmnd *p;\n\n\tMETHOD_TRACE(\"ips_removeq_wait\", 1);\n\n\tif (!item)\n\t\treturn (NULL);\n\n\tif (item == queue->head) {\n\t\treturn (ips_removeq_wait_head(queue));\n\t}\n\n\tp = queue->head;\n\n\twhile ((p) && (item != (struct scsi_cmnd *) p->host_scribble))\n\t\tp = (struct scsi_cmnd *) p->host_scribble;\n\n\tif (p) {\n\t\t \n\t\tp->host_scribble = item->host_scribble;\n\n\t\tif (!item->host_scribble)\n\t\t\tqueue->tail = p;\n\n\t\titem->host_scribble = NULL;\n\t\tqueue->count--;\n\n\t\treturn (item);\n\t}\n\n\treturn (NULL);\n}\n\n \n \n \n \n \n \n \n \n \n \n \nstatic void\nips_putq_copp_tail(ips_copp_queue_t * queue, ips_copp_wait_item_t * item)\n{\n\tMETHOD_TRACE(\"ips_putq_copp_tail\", 1);\n\n\tif (!item)\n\t\treturn;\n\n\titem->next = NULL;\n\n\tif (queue->tail)\n\t\tqueue->tail->next = item;\n\n\tqueue->tail = item;\n\n\tif (!queue->head)\n\t\tqueue->head = item;\n\n\tqueue->count++;\n}\n\n \n \n \n \n \n \n \n \n \n \n \nstatic ips_copp_wait_item_t *\nips_removeq_copp_head(ips_copp_queue_t * queue)\n{\n\tips_copp_wait_item_t *item;\n\n\tMETHOD_TRACE(\"ips_removeq_copp_head\", 1);\n\n\titem = queue->head;\n\n\tif (!item) {\n\t\treturn (NULL);\n\t}\n\n\tqueue->head = item->next;\n\titem->next = NULL;\n\n\tif (queue->tail == item)\n\t\tqueue->tail = NULL;\n\n\tqueue->count--;\n\n\treturn (item);\n}\n\n \n \n \n \n \n \n \n \n \n \n \nstatic ips_copp_wait_item_t *\nips_removeq_copp(ips_copp_queue_t * queue, ips_copp_wait_item_t * item)\n{\n\tips_copp_wait_item_t *p;\n\n\tMETHOD_TRACE(\"ips_removeq_copp\", 1);\n\n\tif (!item)\n\t\treturn (NULL);\n\n\tif (item == queue->head) {\n\t\treturn (ips_removeq_copp_head(queue));\n\t}\n\n\tp = queue->head;\n\n\twhile ((p) && (item != p->next))\n\t\tp = p->next;\n\n\tif (p) {\n\t\t \n\t\tp->next = item->next;\n\n\t\tif (!item->next)\n\t\t\tqueue->tail = p;\n\n\t\titem->next = NULL;\n\t\tqueue->count--;\n\n\t\treturn (item);\n\t}\n\n\treturn (NULL);\n}\n\n \n \n \n \n \n \n \n \n \nstatic void\nipsintr_blocking(ips_ha_t * ha, ips_scb_t * scb)\n{\n\tMETHOD_TRACE(\"ipsintr_blocking\", 2);\n\n\tips_freescb(ha, scb);\n\tif (ha->waitflag && ha->cmd_in_progress == scb->cdb[0]) {\n\t\tha->waitflag = false;\n\n\t\treturn;\n\t}\n}\n\n \n \n \n \n \n \n \n \n \nstatic void\nipsintr_done(ips_ha_t * ha, ips_scb_t * scb)\n{\n\tMETHOD_TRACE(\"ipsintr_done\", 2);\n\n\tif (!scb) {\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"Spurious interrupt; scb NULL.\\n\");\n\n\t\treturn;\n\t}\n\n\tif (scb->scsi_cmd == NULL) {\n\t\t \n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"Spurious interrupt; scsi_cmd not set.\\n\");\n\n\t\treturn;\n\t}\n\n\tips_done(ha, scb);\n}\n\n \n \n \n \n \n \n \n \n \nstatic void\nips_done(ips_ha_t * ha, ips_scb_t * scb)\n{\n\tint ret;\n\n\tMETHOD_TRACE(\"ips_done\", 1);\n\n\tif (!scb)\n\t\treturn;\n\n\tif ((scb->scsi_cmd) && (ips_is_passthru(scb->scsi_cmd))) {\n\t\tips_cleanup_passthru(ha, scb);\n\t\tha->num_ioctl--;\n\t} else {\n\t\t \n\t\tif ((scb->breakup) || (scb->sg_break)) {\n                        struct scatterlist *sg;\n                        int i, sg_dma_index, ips_sg_index = 0;\n\n\t\t\t \n\t\t\tscb->data_len = 0;\n\n                        sg = scsi_sglist(scb->scsi_cmd);\n\n                         \n                        sg_dma_index = scb->breakup;\n                        for (i = 0; i < scb->breakup; i++)\n                                sg = sg_next(sg);\n\n\t\t\t \n                        ips_fill_scb_sg_single(ha,\n                                               sg_dma_address(sg),\n                                               scb, ips_sg_index++,\n                                               sg_dma_len(sg));\n\n                        for (; sg_dma_index < scsi_sg_count(scb->scsi_cmd);\n                             sg_dma_index++, sg = sg_next(sg)) {\n                                if (ips_fill_scb_sg_single\n                                    (ha,\n                                     sg_dma_address(sg),\n                                     scb, ips_sg_index++,\n                                     sg_dma_len(sg)) < 0)\n                                        break;\n                        }\n\n\t\t\tscb->dcdb.transfer_length = scb->data_len;\n\t\t\tscb->dcdb.cmd_attribute |=\n\t\t\t    ips_command_direction[scb->scsi_cmd->cmnd[0]];\n\n\t\t\tif (!(scb->dcdb.cmd_attribute & 0x3))\n\t\t\t\tscb->dcdb.transfer_length = 0;\n\n\t\t\tif (scb->data_len >= IPS_MAX_XFER) {\n\t\t\t\tscb->dcdb.cmd_attribute |= IPS_TRANSFER64K;\n\t\t\t\tscb->dcdb.transfer_length = 0;\n\t\t\t}\n\n\t\t\tret = ips_send_cmd(ha, scb);\n\n\t\t\tswitch (ret) {\n\t\t\tcase IPS_FAILURE:\n\t\t\t\tif (scb->scsi_cmd) {\n\t\t\t\t\tscb->scsi_cmd->result = DID_ERROR << 16;\n\t\t\t\t\tscsi_done(scb->scsi_cmd);\n\t\t\t\t}\n\n\t\t\t\tips_freescb(ha, scb);\n\t\t\t\tbreak;\n\t\t\tcase IPS_SUCCESS_IMM:\n\t\t\t\tif (scb->scsi_cmd) {\n\t\t\t\t\tscb->scsi_cmd->result = DID_ERROR << 16;\n\t\t\t\t\tscsi_done(scb->scsi_cmd);\n\t\t\t\t}\n\n\t\t\t\tips_freescb(ha, scb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\t \n\n\t\t\treturn;\n\t\t}\n\t}\t\t\t \n\n\tif (scb->bus) {\n\t\tha->dcdb_active[scb->bus - 1] &= ~(1 << scb->target_id);\n\t}\n\n\tscsi_done(scb->scsi_cmd);\n\n\tips_freescb(ha, scb);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_map_status(ips_ha_t * ha, ips_scb_t * scb, ips_stat_t * sp)\n{\n\tint errcode;\n\tint device_error;\n\tuint32_t transfer_len;\n\tIPS_DCDB_TABLE_TAPE *tapeDCDB;\n\tIPS_SCSI_INQ_DATA inquiryData;\n\n\tMETHOD_TRACE(\"ips_map_status\", 1);\n\n\tif (scb->bus) {\n\t\tDEBUG_VAR(2,\n\t\t\t  \"(%s%d) Physical device error (%d %d %d): %x %x, Sense Key: %x, ASC: %x, ASCQ: %x\",\n\t\t\t  ips_name, ha->host_num,\n\t\t\t  scb->scsi_cmd->device->channel,\n\t\t\t  scb->scsi_cmd->device->id, scb->scsi_cmd->device->lun,\n\t\t\t  scb->basic_status, scb->extended_status,\n\t\t\t  scb->extended_status ==\n\t\t\t  IPS_ERR_CKCOND ? scb->dcdb.sense_info[2] & 0xf : 0,\n\t\t\t  scb->extended_status ==\n\t\t\t  IPS_ERR_CKCOND ? scb->dcdb.sense_info[12] : 0,\n\t\t\t  scb->extended_status ==\n\t\t\t  IPS_ERR_CKCOND ? scb->dcdb.sense_info[13] : 0);\n\t}\n\n\t \n\terrcode = DID_ERROR;\n\tdevice_error = 0;\n\n\tswitch (scb->basic_status & IPS_GSC_STATUS_MASK) {\n\tcase IPS_CMD_TIMEOUT:\n\t\terrcode = DID_TIME_OUT;\n\t\tbreak;\n\n\tcase IPS_INVAL_OPCO:\n\tcase IPS_INVAL_CMD_BLK:\n\tcase IPS_INVAL_PARM_BLK:\n\tcase IPS_LD_ERROR:\n\tcase IPS_CMD_CMPLT_WERROR:\n\t\tbreak;\n\n\tcase IPS_PHYS_DRV_ERROR:\n\t\tswitch (scb->extended_status) {\n\t\tcase IPS_ERR_SEL_TO:\n\t\t\tif (scb->bus)\n\t\t\t\terrcode = DID_NO_CONNECT;\n\n\t\t\tbreak;\n\n\t\tcase IPS_ERR_OU_RUN:\n\t\t\tif ((scb->cmd.dcdb.op_code == IPS_CMD_EXTENDED_DCDB) ||\n\t\t\t    (scb->cmd.dcdb.op_code ==\n\t\t\t     IPS_CMD_EXTENDED_DCDB_SG)) {\n\t\t\t\ttapeDCDB = (IPS_DCDB_TABLE_TAPE *) & scb->dcdb;\n\t\t\t\ttransfer_len = tapeDCDB->transfer_length;\n\t\t\t} else {\n\t\t\t\ttransfer_len =\n\t\t\t\t    (uint32_t) scb->dcdb.transfer_length;\n\t\t\t}\n\n\t\t\tif ((scb->bus) && (transfer_len < scb->data_len)) {\n\t\t\t\t \n\t\t\t\terrcode = DID_OK;\n\n\t\t\t\t \n\t\t\t\tif (scb->scsi_cmd->cmnd[0] == INQUIRY) {\n\t\t\t\t    ips_scmd_buf_read(scb->scsi_cmd,\n                                      &inquiryData, sizeof (inquiryData));\n \t\t\t\t    if ((inquiryData.DeviceType & 0x1f) == TYPE_DISK) {\n\t\t\t\t        errcode = DID_TIME_OUT;\n\t\t\t\t        break;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\terrcode = DID_ERROR;\n\n\t\t\tbreak;\n\n\t\tcase IPS_ERR_RECOVERY:\n\t\t\t \n\t\t\tif (scb->bus)\n\t\t\t\terrcode = DID_OK;\n\n\t\t\tbreak;\n\n\t\tcase IPS_ERR_HOST_RESET:\n\t\tcase IPS_ERR_DEV_RESET:\n\t\t\terrcode = DID_RESET;\n\t\t\tbreak;\n\n\t\tcase IPS_ERR_CKCOND:\n\t\t\tif (scb->bus) {\n\t\t\t\tif ((scb->cmd.dcdb.op_code ==\n\t\t\t\t     IPS_CMD_EXTENDED_DCDB)\n\t\t\t\t    || (scb->cmd.dcdb.op_code ==\n\t\t\t\t\tIPS_CMD_EXTENDED_DCDB_SG)) {\n\t\t\t\t\ttapeDCDB =\n\t\t\t\t\t    (IPS_DCDB_TABLE_TAPE *) & scb->dcdb;\n\t\t\t\t\tmemcpy_and_pad(scb->scsi_cmd->sense_buffer,\n\t\t\t\t\t       SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t\t       tapeDCDB->sense_info,\n\t\t\t\t\t       sizeof(tapeDCDB->sense_info), 0);\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy_and_pad(scb->scsi_cmd->sense_buffer,\n\t\t\t\t\t       SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t\t       scb->dcdb.sense_info,\n\t\t\t\t\t       sizeof(scb->dcdb.sense_info), 0);\n\t\t\t\t}\n\t\t\t\tdevice_error = 2;\t \n\t\t\t}\n\n\t\t\terrcode = DID_OK;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terrcode = DID_ERROR;\n\t\t\tbreak;\n\n\t\t}\t\t \n\t}\t\t\t \n\n\tscb->scsi_cmd->result = device_error | (errcode << 16);\n\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \n \n \nstatic int\nips_send_wait(ips_ha_t * ha, ips_scb_t * scb, int timeout, int intr)\n{\n\tint ret;\n\n\tMETHOD_TRACE(\"ips_send_wait\", 1);\n\n\tif (intr != IPS_FFDC) {\t \n\t\tha->waitflag = true;\n\t\tha->cmd_in_progress = scb->cdb[0];\n\t}\n\tscb->callback = ipsintr_blocking;\n\tret = ips_send_cmd(ha, scb);\n\n\tif ((ret == IPS_FAILURE) || (ret == IPS_SUCCESS_IMM))\n\t\treturn (ret);\n\n\tif (intr != IPS_FFDC)\t \n\t\tret = ips_wait(ha, timeout, intr);\n\n\treturn (ret);\n}\n\n \n \n \n \n \n \n \nstatic void\nips_scmd_buf_write(struct scsi_cmnd *scmd, void *data, unsigned int count)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tscsi_sg_copy_from_buffer(scmd, data, count);\n\tlocal_irq_restore(flags);\n}\n\n \n \n \n \n \n \n \nstatic void\nips_scmd_buf_read(struct scsi_cmnd *scmd, void *data, unsigned int count)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tscsi_sg_copy_to_buffer(scmd, data, count);\n\tlocal_irq_restore(flags);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_send_cmd(ips_ha_t * ha, ips_scb_t * scb)\n{\n\tint ret;\n\tchar *sp;\n\tint device_error;\n\tIPS_DCDB_TABLE_TAPE *tapeDCDB;\n\tint TimeOut;\n\n\tMETHOD_TRACE(\"ips_send_cmd\", 1);\n\n\tret = IPS_SUCCESS;\n\n\tif (!scb->scsi_cmd) {\n\t\t \n\n\t\tif (scb->bus > 0) {\n\t\t\t \n\t\t\t \n\t\t\tif (ha->waitflag && ha->cmd_in_progress == scb->cdb[0])\n\t\t\t\tha->waitflag = false;\n\n\t\t\treturn (1);\n\t\t}\n\t} else if ((scb->bus == 0) && (!ips_is_passthru(scb->scsi_cmd))) {\n\t\t \n\t\tret = IPS_SUCCESS_IMM;\n\n\t\tswitch (scb->scsi_cmd->cmnd[0]) {\n\t\tcase ALLOW_MEDIUM_REMOVAL:\n\t\tcase REZERO_UNIT:\n\t\tcase ERASE:\n\t\tcase WRITE_FILEMARKS:\n\t\tcase SPACE:\n\t\t\tscb->scsi_cmd->result = DID_ERROR << 16;\n\t\t\tbreak;\n\n\t\tcase START_STOP:\n\t\t\tscb->scsi_cmd->result = DID_OK << 16;\n\t\t\tbreak;\n\n\t\tcase TEST_UNIT_READY:\n\t\tcase INQUIRY:\n\t\t\tif (scb->target_id == IPS_ADAPTER_ID) {\n\t\t\t\t \n\t\t\t\tif (scb->scsi_cmd->cmnd[0] == TEST_UNIT_READY)\n\t\t\t\t\tscb->scsi_cmd->result = DID_OK << 16;\n\n\t\t\t\tif (scb->scsi_cmd->cmnd[0] == INQUIRY) {\n\t\t\t\t\tIPS_SCSI_INQ_DATA inquiry;\n\n\t\t\t\t\tmemset(&inquiry, 0,\n\t\t\t\t\t       sizeof (IPS_SCSI_INQ_DATA));\n\n\t\t\t\t\tinquiry.DeviceType =\n\t\t\t\t\t    IPS_SCSI_INQ_TYPE_PROCESSOR;\n\t\t\t\t\tinquiry.DeviceTypeQualifier =\n\t\t\t\t\t    IPS_SCSI_INQ_LU_CONNECTED;\n\t\t\t\t\tinquiry.Version = IPS_SCSI_INQ_REV2;\n\t\t\t\t\tinquiry.ResponseDataFormat =\n\t\t\t\t\t    IPS_SCSI_INQ_RD_REV2;\n\t\t\t\t\tinquiry.AdditionalLength = 31;\n\t\t\t\t\tinquiry.Flags[0] =\n\t\t\t\t\t    IPS_SCSI_INQ_Address16;\n\t\t\t\t\tinquiry.Flags[1] =\n\t\t\t\t\t    IPS_SCSI_INQ_WBus16 |\n\t\t\t\t\t    IPS_SCSI_INQ_Sync;\n\t\t\t\t\tmemcpy(inquiry.VendorId, \"IBM     \",\n\t\t\t\t\t\t8);\n\t\t\t\t\tmemcpy(inquiry.ProductId,\n\t\t\t\t\t\t\"SERVERAID       \", 16);\n\t\t\t\t\tmemcpy(inquiry.ProductRevisionLevel,\n\t\t\t\t\t\t\"1.00\", 4);\n\n\t\t\t\t\tips_scmd_buf_write(scb->scsi_cmd,\n\t\t\t\t\t\t\t   &inquiry,\n\t\t\t\t\t\t\t   sizeof (inquiry));\n\n\t\t\t\t\tscb->scsi_cmd->result = DID_OK << 16;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscb->cmd.logical_info.op_code = IPS_CMD_GET_LD_INFO;\n\t\t\t\tscb->cmd.logical_info.command_id = IPS_COMMAND_ID(ha, scb);\n\t\t\t\tscb->cmd.logical_info.reserved = 0;\n\t\t\t\tscb->cmd.logical_info.reserved2 = 0;\n\t\t\t\tscb->data_len = sizeof (IPS_LD_INFO);\n\t\t\t\tscb->data_busaddr = ha->logical_drive_info_dma_addr;\n\t\t\t\tscb->flags = 0;\n\t\t\t\tscb->cmd.logical_info.buffer_addr = scb->data_busaddr;\n\t\t\t\tret = IPS_SUCCESS;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase REQUEST_SENSE:\n\t\t\tips_reqsen(ha, scb);\n\t\t\tscb->scsi_cmd->result = DID_OK << 16;\n\t\t\tbreak;\n\n\t\tcase READ_6:\n\t\tcase WRITE_6:\n\t\t\tif (!scb->sg_len) {\n\t\t\t\tscb->cmd.basic_io.op_code =\n\t\t\t\t    (scb->scsi_cmd->cmnd[0] ==\n\t\t\t\t     READ_6) ? IPS_CMD_READ : IPS_CMD_WRITE;\n\t\t\t\tscb->cmd.basic_io.enhanced_sg = 0;\n\t\t\t\tscb->cmd.basic_io.sg_addr =\n\t\t\t\t    cpu_to_le32(scb->data_busaddr);\n\t\t\t} else {\n\t\t\t\tscb->cmd.basic_io.op_code =\n\t\t\t\t    (scb->scsi_cmd->cmnd[0] ==\n\t\t\t\t     READ_6) ? IPS_CMD_READ_SG :\n\t\t\t\t    IPS_CMD_WRITE_SG;\n\t\t\t\tscb->cmd.basic_io.enhanced_sg =\n\t\t\t\t    IPS_USE_ENH_SGLIST(ha) ? 0xFF : 0;\n\t\t\t\tscb->cmd.basic_io.sg_addr =\n\t\t\t\t    cpu_to_le32(scb->sg_busaddr);\n\t\t\t}\n\n\t\t\tscb->cmd.basic_io.segment_4G = 0;\n\t\t\tscb->cmd.basic_io.command_id = IPS_COMMAND_ID(ha, scb);\n\t\t\tscb->cmd.basic_io.log_drv = scb->target_id;\n\t\t\tscb->cmd.basic_io.sg_count = scb->sg_len;\n\n\t\t\tif (scb->cmd.basic_io.lba)\n\t\t\t\tle32_add_cpu(&scb->cmd.basic_io.lba,\n\t\t\t\t\t\tle16_to_cpu(scb->cmd.basic_io.\n\t\t\t\t\t\t\t    sector_count));\n\t\t\telse\n\t\t\t\tscb->cmd.basic_io.lba =\n\t\t\t\t    (((scb->scsi_cmd->\n\t\t\t\t       cmnd[1] & 0x1f) << 16) | (scb->scsi_cmd->\n\t\t\t\t\t\t\t\t cmnd[2] << 8) |\n\t\t\t\t     (scb->scsi_cmd->cmnd[3]));\n\n\t\t\tscb->cmd.basic_io.sector_count =\n\t\t\t    cpu_to_le16(scb->data_len / IPS_BLKSIZE);\n\n\t\t\tif (le16_to_cpu(scb->cmd.basic_io.sector_count) == 0)\n\t\t\t\tscb->cmd.basic_io.sector_count =\n\t\t\t\t    cpu_to_le16(256);\n\n\t\t\tret = IPS_SUCCESS;\n\t\t\tbreak;\n\n\t\tcase READ_10:\n\t\tcase WRITE_10:\n\t\t\tif (!scb->sg_len) {\n\t\t\t\tscb->cmd.basic_io.op_code =\n\t\t\t\t    (scb->scsi_cmd->cmnd[0] ==\n\t\t\t\t     READ_10) ? IPS_CMD_READ : IPS_CMD_WRITE;\n\t\t\t\tscb->cmd.basic_io.enhanced_sg = 0;\n\t\t\t\tscb->cmd.basic_io.sg_addr =\n\t\t\t\t    cpu_to_le32(scb->data_busaddr);\n\t\t\t} else {\n\t\t\t\tscb->cmd.basic_io.op_code =\n\t\t\t\t    (scb->scsi_cmd->cmnd[0] ==\n\t\t\t\t     READ_10) ? IPS_CMD_READ_SG :\n\t\t\t\t    IPS_CMD_WRITE_SG;\n\t\t\t\tscb->cmd.basic_io.enhanced_sg =\n\t\t\t\t    IPS_USE_ENH_SGLIST(ha) ? 0xFF : 0;\n\t\t\t\tscb->cmd.basic_io.sg_addr =\n\t\t\t\t    cpu_to_le32(scb->sg_busaddr);\n\t\t\t}\n\n\t\t\tscb->cmd.basic_io.segment_4G = 0;\n\t\t\tscb->cmd.basic_io.command_id = IPS_COMMAND_ID(ha, scb);\n\t\t\tscb->cmd.basic_io.log_drv = scb->target_id;\n\t\t\tscb->cmd.basic_io.sg_count = scb->sg_len;\n\n\t\t\tif (scb->cmd.basic_io.lba)\n\t\t\t\tle32_add_cpu(&scb->cmd.basic_io.lba,\n\t\t\t\t\t\tle16_to_cpu(scb->cmd.basic_io.\n\t\t\t\t\t\t\t    sector_count));\n\t\t\telse\n\t\t\t\tscb->cmd.basic_io.lba =\n\t\t\t\t    ((scb->scsi_cmd->cmnd[2] << 24) | (scb->\n\t\t\t\t\t\t\t\t       scsi_cmd->\n\t\t\t\t\t\t\t\t       cmnd[3]\n\t\t\t\t\t\t\t\t       << 16) |\n\t\t\t\t     (scb->scsi_cmd->cmnd[4] << 8) | scb->\n\t\t\t\t     scsi_cmd->cmnd[5]);\n\n\t\t\tscb->cmd.basic_io.sector_count =\n\t\t\t    cpu_to_le16(scb->data_len / IPS_BLKSIZE);\n\n\t\t\tif (cpu_to_le16(scb->cmd.basic_io.sector_count) == 0) {\n\t\t\t\t \n\t\t\t\tscb->scsi_cmd->result = DID_OK << 16;\n\t\t\t} else\n\t\t\t\tret = IPS_SUCCESS;\n\n\t\t\tbreak;\n\n\t\tcase RESERVE:\n\t\tcase RELEASE:\n\t\t\tscb->scsi_cmd->result = DID_OK << 16;\n\t\t\tbreak;\n\n\t\tcase MODE_SENSE:\n\t\t\tscb->cmd.basic_io.op_code = IPS_CMD_ENQUIRY;\n\t\t\tscb->cmd.basic_io.command_id = IPS_COMMAND_ID(ha, scb);\n\t\t\tscb->cmd.basic_io.segment_4G = 0;\n\t\t\tscb->cmd.basic_io.enhanced_sg = 0;\n\t\t\tscb->data_len = sizeof (*ha->enq);\n\t\t\tscb->cmd.basic_io.sg_addr = ha->enq_busaddr;\n\t\t\tret = IPS_SUCCESS;\n\t\t\tbreak;\n\n\t\tcase READ_CAPACITY:\n\t\t\tscb->cmd.logical_info.op_code = IPS_CMD_GET_LD_INFO;\n\t\t\tscb->cmd.logical_info.command_id = IPS_COMMAND_ID(ha, scb);\n\t\t\tscb->cmd.logical_info.reserved = 0;\n\t\t\tscb->cmd.logical_info.reserved2 = 0;\n\t\t\tscb->cmd.logical_info.reserved3 = 0;\n\t\t\tscb->data_len = sizeof (IPS_LD_INFO);\n\t\t\tscb->data_busaddr = ha->logical_drive_info_dma_addr;\n\t\t\tscb->flags = 0;\n\t\t\tscb->cmd.logical_info.buffer_addr = scb->data_busaddr;\n\t\t\tret = IPS_SUCCESS;\n\t\t\tbreak;\n\n\t\tcase SEND_DIAGNOSTIC:\n\t\tcase REASSIGN_BLOCKS:\n\t\tcase FORMAT_UNIT:\n\t\tcase SEEK_10:\n\t\tcase VERIFY:\n\t\tcase READ_DEFECT_DATA:\n\t\tcase READ_BUFFER:\n\t\tcase WRITE_BUFFER:\n\t\t\tscb->scsi_cmd->result = DID_OK << 16;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tsp = (char *) scb->scsi_cmd->sense_buffer;\n\n\t\t\tsp[0] = 0x70;\t \n\t\t\tsp[2] = ILLEGAL_REQUEST;\t \n\t\t\tsp[7] = 0x0A;\t \n\t\t\tsp[12] = 0x20;\t \n\t\t\tsp[13] = 0x00;\t \n\n\t\t\tdevice_error = 2;\t \n\t\t\tscb->scsi_cmd->result = device_error | (DID_OK << 16);\n\t\t\tbreak;\n\t\t}\t\t \n\t}\n\t \n\tif (ret == IPS_SUCCESS_IMM)\n\t\treturn (ret);\n\n\t \n\tif (scb->bus > 0) {\n\n\t\t \n\t\t \n\t\tif (ha->conf->dev[scb->bus - 1][scb->target_id].ucState == 0) {\n\t\t\tscb->scsi_cmd->result = DID_NO_CONNECT << 16;\n\t\t\treturn (IPS_SUCCESS_IMM);\n\t\t}\n\n\t\tha->dcdb_active[scb->bus - 1] |= (1 << scb->target_id);\n\t\tscb->cmd.dcdb.command_id = IPS_COMMAND_ID(ha, scb);\n\t\tscb->cmd.dcdb.dcdb_address = cpu_to_le32(scb->scb_busaddr +\n\t\t\t\t\t\t\t (unsigned long) &scb->\n\t\t\t\t\t\t\t dcdb -\n\t\t\t\t\t\t\t (unsigned long) scb);\n\t\tscb->cmd.dcdb.reserved = 0;\n\t\tscb->cmd.dcdb.reserved2 = 0;\n\t\tscb->cmd.dcdb.reserved3 = 0;\n\t\tscb->cmd.dcdb.segment_4G = 0;\n\t\tscb->cmd.dcdb.enhanced_sg = 0;\n\n\t\tTimeOut = scsi_cmd_to_rq(scb->scsi_cmd)->timeout;\n\n\t\tif (ha->subsys->param[4] & 0x00100000) {\t \n\t\t\tif (!scb->sg_len) {\n\t\t\t\tscb->cmd.dcdb.op_code = IPS_CMD_EXTENDED_DCDB;\n\t\t\t} else {\n\t\t\t\tscb->cmd.dcdb.op_code =\n\t\t\t\t    IPS_CMD_EXTENDED_DCDB_SG;\n\t\t\t\tscb->cmd.dcdb.enhanced_sg =\n\t\t\t\t    IPS_USE_ENH_SGLIST(ha) ? 0xFF : 0;\n\t\t\t}\n\n\t\t\ttapeDCDB = (IPS_DCDB_TABLE_TAPE *) & scb->dcdb;\t \n\t\t\ttapeDCDB->device_address =\n\t\t\t    ((scb->bus - 1) << 4) | scb->target_id;\n\t\t\ttapeDCDB->cmd_attribute |= IPS_DISCONNECT_ALLOWED;\n\t\t\ttapeDCDB->cmd_attribute &= ~IPS_TRANSFER64K;\t \n\n\t\t\tif (TimeOut) {\n\t\t\t\tif (TimeOut < (10 * HZ))\n\t\t\t\t\ttapeDCDB->cmd_attribute |= IPS_TIMEOUT10;\t \n\t\t\t\telse if (TimeOut < (60 * HZ))\n\t\t\t\t\ttapeDCDB->cmd_attribute |= IPS_TIMEOUT60;\t \n\t\t\t\telse if (TimeOut < (1200 * HZ))\n\t\t\t\t\ttapeDCDB->cmd_attribute |= IPS_TIMEOUT20M;\t \n\t\t\t}\n\n\t\t\ttapeDCDB->cdb_length = scb->scsi_cmd->cmd_len;\n\t\t\ttapeDCDB->reserved_for_LUN = 0;\n\t\t\ttapeDCDB->transfer_length = scb->data_len;\n\t\t\tif (scb->cmd.dcdb.op_code == IPS_CMD_EXTENDED_DCDB_SG)\n\t\t\t\ttapeDCDB->buffer_pointer =\n\t\t\t\t    cpu_to_le32(scb->sg_busaddr);\n\t\t\telse\n\t\t\t\ttapeDCDB->buffer_pointer =\n\t\t\t\t    cpu_to_le32(scb->data_busaddr);\n\t\t\ttapeDCDB->sg_count = scb->sg_len;\n\t\t\ttapeDCDB->sense_length = sizeof (tapeDCDB->sense_info);\n\t\t\ttapeDCDB->scsi_status = 0;\n\t\t\ttapeDCDB->reserved = 0;\n\t\t\tmemcpy(tapeDCDB->scsi_cdb, scb->scsi_cmd->cmnd,\n\t\t\t       scb->scsi_cmd->cmd_len);\n\t\t} else {\n\t\t\tif (!scb->sg_len) {\n\t\t\t\tscb->cmd.dcdb.op_code = IPS_CMD_DCDB;\n\t\t\t} else {\n\t\t\t\tscb->cmd.dcdb.op_code = IPS_CMD_DCDB_SG;\n\t\t\t\tscb->cmd.dcdb.enhanced_sg =\n\t\t\t\t    IPS_USE_ENH_SGLIST(ha) ? 0xFF : 0;\n\t\t\t}\n\n\t\t\tscb->dcdb.device_address =\n\t\t\t    ((scb->bus - 1) << 4) | scb->target_id;\n\t\t\tscb->dcdb.cmd_attribute |= IPS_DISCONNECT_ALLOWED;\n\n\t\t\tif (TimeOut) {\n\t\t\t\tif (TimeOut < (10 * HZ))\n\t\t\t\t\tscb->dcdb.cmd_attribute |= IPS_TIMEOUT10;\t \n\t\t\t\telse if (TimeOut < (60 * HZ))\n\t\t\t\t\tscb->dcdb.cmd_attribute |= IPS_TIMEOUT60;\t \n\t\t\t\telse if (TimeOut < (1200 * HZ))\n\t\t\t\t\tscb->dcdb.cmd_attribute |= IPS_TIMEOUT20M;\t \n\t\t\t}\n\n\t\t\tscb->dcdb.transfer_length = scb->data_len;\n\t\t\tif (scb->dcdb.cmd_attribute & IPS_TRANSFER64K)\n\t\t\t\tscb->dcdb.transfer_length = 0;\n\t\t\tif (scb->cmd.dcdb.op_code == IPS_CMD_DCDB_SG)\n\t\t\t\tscb->dcdb.buffer_pointer =\n\t\t\t\t    cpu_to_le32(scb->sg_busaddr);\n\t\t\telse\n\t\t\t\tscb->dcdb.buffer_pointer =\n\t\t\t\t    cpu_to_le32(scb->data_busaddr);\n\t\t\tscb->dcdb.cdb_length = scb->scsi_cmd->cmd_len;\n\t\t\tscb->dcdb.sense_length = sizeof (scb->dcdb.sense_info);\n\t\t\tscb->dcdb.sg_count = scb->sg_len;\n\t\t\tscb->dcdb.reserved = 0;\n\t\t\tmemcpy(scb->dcdb.scsi_cdb, scb->scsi_cmd->cmnd,\n\t\t\t       scb->scsi_cmd->cmd_len);\n\t\t\tscb->dcdb.scsi_status = 0;\n\t\t\tscb->dcdb.reserved2[0] = 0;\n\t\t\tscb->dcdb.reserved2[1] = 0;\n\t\t\tscb->dcdb.reserved2[2] = 0;\n\t\t}\n\t}\n\n\treturn ((*ha->func.issue) (ha, scb));\n}\n\n \n \n \n \n \n \n \n \n \nstatic void\nips_chkstatus(ips_ha_t * ha, IPS_STATUS * pstatus)\n{\n\tips_scb_t *scb;\n\tips_stat_t *sp;\n\tuint8_t basic_status;\n\tuint8_t ext_status;\n\tint errcode;\n\tIPS_SCSI_INQ_DATA inquiryData;\n\n\tMETHOD_TRACE(\"ips_chkstatus\", 1);\n\n\tscb = &ha->scbs[pstatus->fields.command_id];\n\tscb->basic_status = basic_status =\n\t    pstatus->fields.basic_status & IPS_BASIC_STATUS_MASK;\n\tscb->extended_status = ext_status = pstatus->fields.extended_status;\n\n\tsp = &ha->sp;\n\tsp->residue_len = 0;\n\tsp->scb_addr = (void *) scb;\n\n\t \n\tips_removeq_scb(&ha->scb_activelist, scb);\n\n\tif (!scb->scsi_cmd)\n\t\t \n\t\treturn;\n\n\tDEBUG_VAR(2, \"(%s%d) ips_chkstatus: cmd 0x%X id %d (%d %d %d)\",\n\t\t  ips_name,\n\t\t  ha->host_num,\n\t\t  scb->cdb[0],\n\t\t  scb->cmd.basic_io.command_id,\n\t\t  scb->bus, scb->target_id, scb->lun);\n\n\tif ((scb->scsi_cmd) && (ips_is_passthru(scb->scsi_cmd)))\n\t\t \n\t\treturn;\n\n\terrcode = DID_OK;\n\n\tif (((basic_status & IPS_GSC_STATUS_MASK) == IPS_CMD_SUCCESS) ||\n\t    ((basic_status & IPS_GSC_STATUS_MASK) == IPS_CMD_RECOVERED_ERROR)) {\n\n\t\tif (scb->bus == 0) {\n\t\t\tif ((basic_status & IPS_GSC_STATUS_MASK) ==\n\t\t\t    IPS_CMD_RECOVERED_ERROR) {\n\t\t\t\tDEBUG_VAR(1,\n\t\t\t\t\t  \"(%s%d) Recovered Logical Drive Error OpCode: %x, BSB: %x, ESB: %x\",\n\t\t\t\t\t  ips_name, ha->host_num,\n\t\t\t\t\t  scb->cmd.basic_io.op_code,\n\t\t\t\t\t  basic_status, ext_status);\n\t\t\t}\n\n\t\t\tswitch (scb->scsi_cmd->cmnd[0]) {\n\t\t\tcase ALLOW_MEDIUM_REMOVAL:\n\t\t\tcase REZERO_UNIT:\n\t\t\tcase ERASE:\n\t\t\tcase WRITE_FILEMARKS:\n\t\t\tcase SPACE:\n\t\t\t\terrcode = DID_ERROR;\n\t\t\t\tbreak;\n\n\t\t\tcase START_STOP:\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_UNIT_READY:\n\t\t\t\tif (!ips_online(ha, scb)) {\n\t\t\t\t\terrcode = DID_TIME_OUT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase INQUIRY:\n\t\t\t\tif (ips_online(ha, scb)) {\n\t\t\t\t\tips_inquiry(ha, scb);\n\t\t\t\t} else {\n\t\t\t\t\terrcode = DID_TIME_OUT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase REQUEST_SENSE:\n\t\t\t\tips_reqsen(ha, scb);\n\t\t\t\tbreak;\n\n\t\t\tcase READ_6:\n\t\t\tcase WRITE_6:\n\t\t\tcase READ_10:\n\t\t\tcase WRITE_10:\n\t\t\tcase RESERVE:\n\t\t\tcase RELEASE:\n\t\t\t\tbreak;\n\n\t\t\tcase MODE_SENSE:\n\t\t\t\tif (!ips_online(ha, scb)\n\t\t\t\t    || !ips_msense(ha, scb)) {\n\t\t\t\t\terrcode = DID_ERROR;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase READ_CAPACITY:\n\t\t\t\tif (ips_online(ha, scb))\n\t\t\t\t\tips_rdcap(ha, scb);\n\t\t\t\telse {\n\t\t\t\t\terrcode = DID_TIME_OUT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase SEND_DIAGNOSTIC:\n\t\t\tcase REASSIGN_BLOCKS:\n\t\t\t\tbreak;\n\n\t\t\tcase FORMAT_UNIT:\n\t\t\t\terrcode = DID_ERROR;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEK_10:\n\t\t\tcase VERIFY:\n\t\t\tcase READ_DEFECT_DATA:\n\t\t\tcase READ_BUFFER:\n\t\t\tcase WRITE_BUFFER:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\terrcode = DID_ERROR;\n\t\t\t}\t \n\n\t\t\tscb->scsi_cmd->result = errcode << 16;\n\t\t} else {\t \n\t\t\t \n\t\t\tif (scb->scsi_cmd->cmnd[0] == INQUIRY) {\n\t\t\t    ips_scmd_buf_read(scb->scsi_cmd,\n                                  &inquiryData, sizeof (inquiryData));\n\t\t\t    if ((inquiryData.DeviceType & 0x1f) == TYPE_DISK)\n\t\t\t        scb->scsi_cmd->result = DID_TIME_OUT << 16;\n\t\t\t}\n\t\t}\t\t \n\t} else {\t\t \n\t\tif (scb->bus == 0) {\n\t\t\tDEBUG_VAR(1,\n\t\t\t\t  \"(%s%d) Unrecovered Logical Drive Error OpCode: %x, BSB: %x, ESB: %x\",\n\t\t\t\t  ips_name, ha->host_num,\n\t\t\t\t  scb->cmd.basic_io.op_code, basic_status,\n\t\t\t\t  ext_status);\n\t\t}\n\n\t\tips_map_status(ha, scb, sp);\n\t}\t\t\t \n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_online(ips_ha_t * ha, ips_scb_t * scb)\n{\n\tMETHOD_TRACE(\"ips_online\", 1);\n\n\tif (scb->target_id >= IPS_MAX_LD)\n\t\treturn (0);\n\n\tif ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1) {\n\t\tmemset(ha->logical_drive_info, 0, sizeof (IPS_LD_INFO));\n\t\treturn (0);\n\t}\n\n\tif (ha->logical_drive_info->drive_info[scb->target_id].state !=\n\t    IPS_LD_OFFLINE\n\t    && ha->logical_drive_info->drive_info[scb->target_id].state !=\n\t    IPS_LD_FREE\n\t    && ha->logical_drive_info->drive_info[scb->target_id].state !=\n\t    IPS_LD_CRS\n\t    && ha->logical_drive_info->drive_info[scb->target_id].state !=\n\t    IPS_LD_SYS)\n\t\treturn (1);\n\telse\n\t\treturn (0);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_inquiry(ips_ha_t * ha, ips_scb_t * scb)\n{\n\tIPS_SCSI_INQ_DATA inquiry;\n\n\tMETHOD_TRACE(\"ips_inquiry\", 1);\n\n\tmemset(&inquiry, 0, sizeof (IPS_SCSI_INQ_DATA));\n\n\tinquiry.DeviceType = IPS_SCSI_INQ_TYPE_DASD;\n\tinquiry.DeviceTypeQualifier = IPS_SCSI_INQ_LU_CONNECTED;\n\tinquiry.Version = IPS_SCSI_INQ_REV2;\n\tinquiry.ResponseDataFormat = IPS_SCSI_INQ_RD_REV2;\n\tinquiry.AdditionalLength = 31;\n\tinquiry.Flags[0] = IPS_SCSI_INQ_Address16;\n\tinquiry.Flags[1] =\n\t    IPS_SCSI_INQ_WBus16 | IPS_SCSI_INQ_Sync | IPS_SCSI_INQ_CmdQue;\n\tmemcpy(inquiry.VendorId, \"IBM     \", 8);\n\tmemcpy(inquiry.ProductId, \"SERVERAID       \", 16);\n\tmemcpy(inquiry.ProductRevisionLevel, \"1.00\", 4);\n\n\tips_scmd_buf_write(scb->scsi_cmd, &inquiry, sizeof (inquiry));\n\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_rdcap(ips_ha_t * ha, ips_scb_t * scb)\n{\n\tIPS_SCSI_CAPACITY cap;\n\n\tMETHOD_TRACE(\"ips_rdcap\", 1);\n\n\tif (scsi_bufflen(scb->scsi_cmd) < 8)\n\t\treturn (0);\n\n\tcap.lba =\n\t    cpu_to_be32(le32_to_cpu\n\t\t\t(ha->logical_drive_info->\n\t\t\t drive_info[scb->target_id].sector_count) - 1);\n\tcap.len = cpu_to_be32((uint32_t) IPS_BLKSIZE);\n\n\tips_scmd_buf_write(scb->scsi_cmd, &cap, sizeof (cap));\n\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_msense(ips_ha_t * ha, ips_scb_t * scb)\n{\n\tuint16_t heads;\n\tuint16_t sectors;\n\tuint32_t cylinders;\n\tIPS_SCSI_MODE_PAGE_DATA mdata;\n\n\tMETHOD_TRACE(\"ips_msense\", 1);\n\n\tif (le32_to_cpu(ha->enq->ulDriveSize[scb->target_id]) > 0x400000 &&\n\t    (ha->enq->ucMiscFlag & 0x8) == 0) {\n\t\theads = IPS_NORM_HEADS;\n\t\tsectors = IPS_NORM_SECTORS;\n\t} else {\n\t\theads = IPS_COMP_HEADS;\n\t\tsectors = IPS_COMP_SECTORS;\n\t}\n\n\tcylinders =\n\t    (le32_to_cpu(ha->enq->ulDriveSize[scb->target_id]) -\n\t     1) / (heads * sectors);\n\n\tmemset(&mdata, 0, sizeof (IPS_SCSI_MODE_PAGE_DATA));\n\n\tmdata.hdr.BlockDescLength = 8;\n\n\tswitch (scb->scsi_cmd->cmnd[2] & 0x3f) {\n\tcase 0x03:\t\t \n\t\tmdata.pdata.pg3.PageCode = 3;\n\t\tmdata.pdata.pg3.PageLength = sizeof (IPS_SCSI_MODE_PAGE3);\n\t\tmdata.hdr.DataLength =\n\t\t    3 + mdata.hdr.BlockDescLength + mdata.pdata.pg3.PageLength;\n\t\tmdata.pdata.pg3.TracksPerZone = 0;\n\t\tmdata.pdata.pg3.AltSectorsPerZone = 0;\n\t\tmdata.pdata.pg3.AltTracksPerZone = 0;\n\t\tmdata.pdata.pg3.AltTracksPerVolume = 0;\n\t\tmdata.pdata.pg3.SectorsPerTrack = cpu_to_be16(sectors);\n\t\tmdata.pdata.pg3.BytesPerSector = cpu_to_be16(IPS_BLKSIZE);\n\t\tmdata.pdata.pg3.Interleave = cpu_to_be16(1);\n\t\tmdata.pdata.pg3.TrackSkew = 0;\n\t\tmdata.pdata.pg3.CylinderSkew = 0;\n\t\tmdata.pdata.pg3.flags = IPS_SCSI_MP3_SoftSector;\n\t\tbreak;\n\n\tcase 0x4:\n\t\tmdata.pdata.pg4.PageCode = 4;\n\t\tmdata.pdata.pg4.PageLength = sizeof (IPS_SCSI_MODE_PAGE4);\n\t\tmdata.hdr.DataLength =\n\t\t    3 + mdata.hdr.BlockDescLength + mdata.pdata.pg4.PageLength;\n\t\tmdata.pdata.pg4.CylindersHigh =\n\t\t    cpu_to_be16((cylinders >> 8) & 0xFFFF);\n\t\tmdata.pdata.pg4.CylindersLow = (cylinders & 0xFF);\n\t\tmdata.pdata.pg4.Heads = heads;\n\t\tmdata.pdata.pg4.WritePrecompHigh = 0;\n\t\tmdata.pdata.pg4.WritePrecompLow = 0;\n\t\tmdata.pdata.pg4.ReducedWriteCurrentHigh = 0;\n\t\tmdata.pdata.pg4.ReducedWriteCurrentLow = 0;\n\t\tmdata.pdata.pg4.StepRate = cpu_to_be16(1);\n\t\tmdata.pdata.pg4.LandingZoneHigh = 0;\n\t\tmdata.pdata.pg4.LandingZoneLow = 0;\n\t\tmdata.pdata.pg4.flags = 0;\n\t\tmdata.pdata.pg4.RotationalOffset = 0;\n\t\tmdata.pdata.pg4.MediumRotationRate = 0;\n\t\tbreak;\n\tcase 0x8:\n\t\tmdata.pdata.pg8.PageCode = 8;\n\t\tmdata.pdata.pg8.PageLength = sizeof (IPS_SCSI_MODE_PAGE8);\n\t\tmdata.hdr.DataLength =\n\t\t    3 + mdata.hdr.BlockDescLength + mdata.pdata.pg8.PageLength;\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\treturn (0);\n\t}\t\t\t \n\n\tips_scmd_buf_write(scb->scsi_cmd, &mdata, sizeof (mdata));\n\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_reqsen(ips_ha_t * ha, ips_scb_t * scb)\n{\n\tIPS_SCSI_REQSEN reqsen;\n\n\tMETHOD_TRACE(\"ips_reqsen\", 1);\n\n\tmemset(&reqsen, 0, sizeof (IPS_SCSI_REQSEN));\n\n\treqsen.ResponseCode =\n\t    IPS_SCSI_REQSEN_VALID | IPS_SCSI_REQSEN_CURRENT_ERR;\n\treqsen.AdditionalLength = 10;\n\treqsen.AdditionalSenseCode = IPS_SCSI_REQSEN_NO_SENSE;\n\treqsen.AdditionalSenseCodeQual = IPS_SCSI_REQSEN_NO_SENSE;\n\n\tips_scmd_buf_write(scb->scsi_cmd, &reqsen, sizeof (reqsen));\n\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic void\nips_free(ips_ha_t * ha)\n{\n\n\tMETHOD_TRACE(\"ips_free\", 1);\n\n\tif (ha) {\n\t\tif (ha->enq) {\n\t\t\tdma_free_coherent(&ha->pcidev->dev, sizeof(IPS_ENQ),\n\t\t\t\t\t    ha->enq, ha->enq_busaddr);\n\t\t\tha->enq = NULL;\n\t\t}\n\n\t\tkfree(ha->conf);\n\t\tha->conf = NULL;\n\n\t\tif (ha->adapt) {\n\t\t\tdma_free_coherent(&ha->pcidev->dev,\n\t\t\t\t\t    sizeof (IPS_ADAPTER) +\n\t\t\t\t\t    sizeof (IPS_IO_CMD), ha->adapt,\n\t\t\t\t\t    ha->adapt->hw_status_start);\n\t\t\tha->adapt = NULL;\n\t\t}\n\n\t\tif (ha->logical_drive_info) {\n\t\t\tdma_free_coherent(&ha->pcidev->dev,\n\t\t\t\t\t    sizeof (IPS_LD_INFO),\n\t\t\t\t\t    ha->logical_drive_info,\n\t\t\t\t\t    ha->logical_drive_info_dma_addr);\n\t\t\tha->logical_drive_info = NULL;\n\t\t}\n\n\t\tkfree(ha->nvram);\n\t\tha->nvram = NULL;\n\n\t\tkfree(ha->subsys);\n\t\tha->subsys = NULL;\n\n\t\tif (ha->ioctl_data) {\n\t\t\tdma_free_coherent(&ha->pcidev->dev, ha->ioctl_len,\n\t\t\t\t\t    ha->ioctl_data, ha->ioctl_busaddr);\n\t\t\tha->ioctl_data = NULL;\n\t\t\tha->ioctl_datasize = 0;\n\t\t\tha->ioctl_len = 0;\n\t\t}\n\t\tips_deallocatescbs(ha, ha->max_cmds);\n\n\t\t \n\t\tif (ha->mem_ptr) {\n\t\t\tiounmap(ha->ioremap_ptr);\n\t\t\tha->ioremap_ptr = NULL;\n\t\t\tha->mem_ptr = NULL;\n\t\t}\n\n\t\tha->mem_addr = 0;\n\n\t}\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_deallocatescbs(ips_ha_t * ha, int cmds)\n{\n\tif (ha->scbs) {\n\t\tdma_free_coherent(&ha->pcidev->dev,\n\t\t\t\t    IPS_SGLIST_SIZE(ha) * IPS_MAX_SG * cmds,\n\t\t\t\t    ha->scbs->sg_list.list,\n\t\t\t\t    ha->scbs->sg_busaddr);\n\t\tdma_free_coherent(&ha->pcidev->dev, sizeof (ips_scb_t) * cmds,\n\t\t\t\t    ha->scbs, ha->scbs->scb_busaddr);\n\t\tha->scbs = NULL;\n\t}\t\t\t \n\treturn 1;\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_allocatescbs(ips_ha_t * ha)\n{\n\tips_scb_t *scb_p;\n\tIPS_SG_LIST ips_sg;\n\tint i;\n\tdma_addr_t command_dma, sg_dma;\n\n\tMETHOD_TRACE(\"ips_allocatescbs\", 1);\n\n\t \n\tha->scbs = dma_alloc_coherent(&ha->pcidev->dev,\n\t\t\tha->max_cmds * sizeof (ips_scb_t),\n\t\t\t&command_dma, GFP_KERNEL);\n\tif (ha->scbs == NULL)\n\t\treturn 0;\n\tips_sg.list = dma_alloc_coherent(&ha->pcidev->dev,\n\t\t\tIPS_SGLIST_SIZE(ha) * IPS_MAX_SG * ha->max_cmds,\n\t\t\t&sg_dma, GFP_KERNEL);\n\tif (ips_sg.list == NULL) {\n\t\tdma_free_coherent(&ha->pcidev->dev,\n\t\t\t\t    ha->max_cmds * sizeof (ips_scb_t), ha->scbs,\n\t\t\t\t    command_dma);\n\t\treturn 0;\n\t}\n\n\tmemset(ha->scbs, 0, ha->max_cmds * sizeof (ips_scb_t));\n\n\tfor (i = 0; i < ha->max_cmds; i++) {\n\t\tscb_p = &ha->scbs[i];\n\t\tscb_p->scb_busaddr = command_dma + sizeof (ips_scb_t) * i;\n\t\t \n\t\tif (IPS_USE_ENH_SGLIST(ha)) {\n\t\t\tscb_p->sg_list.enh_list =\n\t\t\t    ips_sg.enh_list + i * IPS_MAX_SG;\n\t\t\tscb_p->sg_busaddr =\n\t\t\t    sg_dma + IPS_SGLIST_SIZE(ha) * IPS_MAX_SG * i;\n\t\t} else {\n\t\t\tscb_p->sg_list.std_list =\n\t\t\t    ips_sg.std_list + i * IPS_MAX_SG;\n\t\t\tscb_p->sg_busaddr =\n\t\t\t    sg_dma + IPS_SGLIST_SIZE(ha) * IPS_MAX_SG * i;\n\t\t}\n\n\t\t \n\t\tif (i < ha->max_cmds - 1) {\n\t\t\tscb_p->q_next = ha->scb_freelist;\n\t\t\tha->scb_freelist = scb_p;\n\t\t}\n\t}\n\n\t \n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic void\nips_init_scb(ips_ha_t * ha, ips_scb_t * scb)\n{\n\tIPS_SG_LIST sg_list;\n\tuint32_t cmd_busaddr, sg_busaddr;\n\tMETHOD_TRACE(\"ips_init_scb\", 1);\n\n\tif (scb == NULL)\n\t\treturn;\n\n\tsg_list.list = scb->sg_list.list;\n\tcmd_busaddr = scb->scb_busaddr;\n\tsg_busaddr = scb->sg_busaddr;\n\t \n\tmemset(scb, 0, sizeof (ips_scb_t));\n\tmemset(ha->dummy, 0, sizeof (IPS_IO_CMD));\n\n\t \n\tha->dummy->op_code = 0xFF;\n\tha->dummy->ccsar = cpu_to_le32(ha->adapt->hw_status_start\n\t\t\t\t       + sizeof (IPS_ADAPTER));\n\tha->dummy->command_id = IPS_MAX_CMDS;\n\n\t \n\tscb->scb_busaddr = cmd_busaddr;\n\tscb->sg_busaddr = sg_busaddr;\n\tscb->sg_list.list = sg_list.list;\n\n\t \n\tscb->cmd.basic_io.cccr = cpu_to_le32((uint32_t) IPS_BIT_ILE);\n\tscb->cmd.basic_io.ccsar = cpu_to_le32(ha->adapt->hw_status_start\n\t\t\t\t\t      + sizeof (IPS_ADAPTER));\n}\n\n \n \n \n \n \n \n \n \n \n \n \nstatic ips_scb_t *\nips_getscb(ips_ha_t * ha)\n{\n\tips_scb_t *scb;\n\n\tMETHOD_TRACE(\"ips_getscb\", 1);\n\n\tif ((scb = ha->scb_freelist) == NULL) {\n\n\t\treturn (NULL);\n\t}\n\n\tha->scb_freelist = scb->q_next;\n\tscb->flags = 0;\n\tscb->q_next = NULL;\n\n\tips_init_scb(ha, scb);\n\n\treturn (scb);\n}\n\n \n \n \n \n \n \n \n \n \n \n \nstatic void\nips_freescb(ips_ha_t * ha, ips_scb_t * scb)\n{\n\n\tMETHOD_TRACE(\"ips_freescb\", 1);\n\tif (scb->flags & IPS_SCB_MAP_SG)\n                scsi_dma_unmap(scb->scsi_cmd);\n\telse if (scb->flags & IPS_SCB_MAP_SINGLE)\n\t\tdma_unmap_single(&ha->pcidev->dev, scb->data_busaddr,\n\t\t\t\t scb->data_len, IPS_DMA_DIR(scb));\n\n\t \n\tif (IPS_COMMAND_ID(ha, scb) < (ha->max_cmds - 1)) {\n\t\tscb->q_next = ha->scb_freelist;\n\t\tha->scb_freelist = scb;\n\t}\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_isinit_copperhead(ips_ha_t * ha)\n{\n\tuint8_t scpr;\n\tuint8_t isr;\n\n\tMETHOD_TRACE(\"ips_isinit_copperhead\", 1);\n\n\tisr = inb(ha->io_addr + IPS_REG_HISR);\n\tscpr = inb(ha->io_addr + IPS_REG_SCPR);\n\n\tif (((isr & IPS_BIT_EI) == 0) && ((scpr & IPS_BIT_EBM) == 0))\n\t\treturn (0);\n\telse\n\t\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_isinit_copperhead_memio(ips_ha_t * ha)\n{\n\tuint8_t isr = 0;\n\tuint8_t scpr;\n\n\tMETHOD_TRACE(\"ips_is_init_copperhead_memio\", 1);\n\n\tisr = readb(ha->mem_ptr + IPS_REG_HISR);\n\tscpr = readb(ha->mem_ptr + IPS_REG_SCPR);\n\n\tif (((isr & IPS_BIT_EI) == 0) && ((scpr & IPS_BIT_EBM) == 0))\n\t\treturn (0);\n\telse\n\t\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_isinit_morpheus(ips_ha_t * ha)\n{\n\tuint32_t post;\n\tuint32_t bits;\n\n\tMETHOD_TRACE(\"ips_is_init_morpheus\", 1);\n\n\tif (ips_isintr_morpheus(ha))\n\t    ips_flush_and_reset(ha);\n\n\tpost = readl(ha->mem_ptr + IPS_REG_I960_MSG0);\n\tbits = readl(ha->mem_ptr + IPS_REG_I2O_HIR);\n\n\tif (post == 0)\n\t\treturn (0);\n\telse if (bits & 0x3)\n\t\treturn (0);\n\telse\n\t\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \n \nstatic void\nips_flush_and_reset(ips_ha_t *ha)\n{\n\tips_scb_t *scb;\n\tint  ret;\n \tint  time;\n\tint  done;\n\tdma_addr_t command_dma;\n\n\t \n\tscb = dma_alloc_coherent(&ha->pcidev->dev, sizeof(ips_scb_t),\n\t\t\t&command_dma, GFP_KERNEL);\n\tif (scb) {\n\t    memset(scb, 0, sizeof(ips_scb_t));\n\t    ips_init_scb(ha, scb);\n\t    scb->scb_busaddr = command_dma;\n\n\t    scb->timeout = ips_cmd_timeout;\n\t    scb->cdb[0] = IPS_CMD_FLUSH;\n\n\t    scb->cmd.flush_cache.op_code = IPS_CMD_FLUSH;\n\t    scb->cmd.flush_cache.command_id = IPS_MAX_CMDS;    \n\t    scb->cmd.flush_cache.state = IPS_NORM_STATE;\n\t    scb->cmd.flush_cache.reserved = 0;\n\t    scb->cmd.flush_cache.reserved2 = 0;\n\t    scb->cmd.flush_cache.reserved3 = 0;\n\t    scb->cmd.flush_cache.reserved4 = 0;\n\n\t    ret = ips_send_cmd(ha, scb);                       \n\n\t    if (ret == IPS_SUCCESS) {\n\t        time = 60 * IPS_ONE_SEC;\t               \n\t        done = 0;\n\n\t        while ((time > 0) && (!done)) {\n\t\t   done = ips_poll_for_flush_complete(ha);\n\t            \n\t           udelay(1000);\n\t           time--;\n\t        }\n        }\n\t}\n\n\t \n\t(*ha->func.reset) (ha);\n\n\tdma_free_coherent(&ha->pcidev->dev, sizeof(ips_scb_t), scb, command_dma);\n\treturn;\n}\n\n \n \n \n \n \n \n \n \n \n \nstatic int\nips_poll_for_flush_complete(ips_ha_t * ha)\n{\n\tIPS_STATUS cstatus;\n\n\twhile (true) {\n\t    cstatus.value = (*ha->func.statupd) (ha);\n\n\t    if (cstatus.value == 0xffffffff)       \n\t\t\tbreak;\n\n\t     \n\t    if (cstatus.fields.command_id == IPS_MAX_CMDS)\n\t        return 1;\n\t }\n\n\treturn 0;\n}\n\n \n \n \n \n \n \n \n \nstatic void\nips_enable_int_copperhead(ips_ha_t * ha)\n{\n\tMETHOD_TRACE(\"ips_enable_int_copperhead\", 1);\n\n\toutb(ha->io_addr + IPS_REG_HISR, IPS_BIT_EI);\n\tinb(ha->io_addr + IPS_REG_HISR);\t \n}\n\n \n \n \n \n \n \n \n \nstatic void\nips_enable_int_copperhead_memio(ips_ha_t * ha)\n{\n\tMETHOD_TRACE(\"ips_enable_int_copperhead_memio\", 1);\n\n\twriteb(IPS_BIT_EI, ha->mem_ptr + IPS_REG_HISR);\n\treadb(ha->mem_ptr + IPS_REG_HISR);\t \n}\n\n \n \n \n \n \n \n \n \nstatic void\nips_enable_int_morpheus(ips_ha_t * ha)\n{\n\tuint32_t Oimr;\n\n\tMETHOD_TRACE(\"ips_enable_int_morpheus\", 1);\n\n\tOimr = readl(ha->mem_ptr + IPS_REG_I960_OIMR);\n\tOimr &= ~0x08;\n\twritel(Oimr, ha->mem_ptr + IPS_REG_I960_OIMR);\n\treadl(ha->mem_ptr + IPS_REG_I960_OIMR);\t \n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_init_copperhead(ips_ha_t * ha)\n{\n\tuint8_t Isr;\n\tuint8_t Cbsp;\n\tuint8_t PostByte[IPS_MAX_POST_BYTES];\n\tint i, j;\n\n\tMETHOD_TRACE(\"ips_init_copperhead\", 1);\n\n\tfor (i = 0; i < IPS_MAX_POST_BYTES; i++) {\n\t\tfor (j = 0; j < 45; j++) {\n\t\t\tIsr = inb(ha->io_addr + IPS_REG_HISR);\n\t\t\tif (Isr & IPS_BIT_GHI)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tMDELAY(IPS_ONE_SEC);\n\t\t}\n\n\t\tif (j >= 45)\n\t\t\t \n\t\t\treturn (0);\n\n\t\tPostByte[i] = inb(ha->io_addr + IPS_REG_ISPR);\n\t\toutb(Isr, ha->io_addr + IPS_REG_HISR);\n\t}\n\n\tif (PostByte[0] < IPS_GOOD_POST_STATUS) {\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"reset controller fails (post status %x %x).\\n\",\n\t\t\t   PostByte[0], PostByte[1]);\n\n\t\treturn (0);\n\t}\n\n\tfor (i = 0; i < IPS_MAX_CONFIG_BYTES; i++) {\n\t\tfor (j = 0; j < 240; j++) {\n\t\t\tIsr = inb(ha->io_addr + IPS_REG_HISR);\n\t\t\tif (Isr & IPS_BIT_GHI)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tMDELAY(IPS_ONE_SEC);\n\t\t}\n\n\t\tif (j >= 240)\n\t\t\t \n\t\t\treturn (0);\n\n\t\tinb(ha->io_addr + IPS_REG_ISPR);\n\t\toutb(Isr, ha->io_addr + IPS_REG_HISR);\n\t}\n\n\tfor (i = 0; i < 240; i++) {\n\t\tCbsp = inb(ha->io_addr + IPS_REG_CBSP);\n\n\t\tif ((Cbsp & IPS_BIT_OP) == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tMDELAY(IPS_ONE_SEC);\n\t}\n\n\tif (i >= 240)\n\t\t \n\t\treturn (0);\n\n\t \n\toutl(0x1010, ha->io_addr + IPS_REG_CCCR);\n\n\t \n\toutb(IPS_BIT_EBM, ha->io_addr + IPS_REG_SCPR);\n\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t \n\t\toutl(0, ha->io_addr + IPS_REG_NDAE);\n\n\t \n\toutb(IPS_BIT_EI, ha->io_addr + IPS_REG_HISR);\n\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_init_copperhead_memio(ips_ha_t * ha)\n{\n\tuint8_t Isr = 0;\n\tuint8_t Cbsp;\n\tuint8_t PostByte[IPS_MAX_POST_BYTES];\n\tint i, j;\n\n\tMETHOD_TRACE(\"ips_init_copperhead_memio\", 1);\n\n\tfor (i = 0; i < IPS_MAX_POST_BYTES; i++) {\n\t\tfor (j = 0; j < 45; j++) {\n\t\t\tIsr = readb(ha->mem_ptr + IPS_REG_HISR);\n\t\t\tif (Isr & IPS_BIT_GHI)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tMDELAY(IPS_ONE_SEC);\n\t\t}\n\n\t\tif (j >= 45)\n\t\t\t \n\t\t\treturn (0);\n\n\t\tPostByte[i] = readb(ha->mem_ptr + IPS_REG_ISPR);\n\t\twriteb(Isr, ha->mem_ptr + IPS_REG_HISR);\n\t}\n\n\tif (PostByte[0] < IPS_GOOD_POST_STATUS) {\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"reset controller fails (post status %x %x).\\n\",\n\t\t\t   PostByte[0], PostByte[1]);\n\n\t\treturn (0);\n\t}\n\n\tfor (i = 0; i < IPS_MAX_CONFIG_BYTES; i++) {\n\t\tfor (j = 0; j < 240; j++) {\n\t\t\tIsr = readb(ha->mem_ptr + IPS_REG_HISR);\n\t\t\tif (Isr & IPS_BIT_GHI)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tMDELAY(IPS_ONE_SEC);\n\t\t}\n\n\t\tif (j >= 240)\n\t\t\t \n\t\t\treturn (0);\n\n\t\treadb(ha->mem_ptr + IPS_REG_ISPR);\n\t\twriteb(Isr, ha->mem_ptr + IPS_REG_HISR);\n\t}\n\n\tfor (i = 0; i < 240; i++) {\n\t\tCbsp = readb(ha->mem_ptr + IPS_REG_CBSP);\n\n\t\tif ((Cbsp & IPS_BIT_OP) == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tMDELAY(IPS_ONE_SEC);\n\t}\n\n\tif (i >= 240)\n\t\t \n\t\treturn (0);\n\n\t \n\twritel(0x1010, ha->mem_ptr + IPS_REG_CCCR);\n\n\t \n\twriteb(IPS_BIT_EBM, ha->mem_ptr + IPS_REG_SCPR);\n\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t \n\t\twritel(0, ha->mem_ptr + IPS_REG_NDAE);\n\n\t \n\twriteb(IPS_BIT_EI, ha->mem_ptr + IPS_REG_HISR);\n\n\t \n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_init_morpheus(ips_ha_t * ha)\n{\n\tuint32_t Post;\n\tuint32_t Config;\n\tuint32_t Isr;\n\tuint32_t Oimr;\n\tint i;\n\n\tMETHOD_TRACE(\"ips_init_morpheus\", 1);\n\n\t \n\tfor (i = 0; i < 45; i++) {\n\t\tIsr = readl(ha->mem_ptr + IPS_REG_I2O_HIR);\n\n\t\tif (Isr & IPS_BIT_I960_MSG0I)\n\t\t\tbreak;\n\n\t\t \n\t\tMDELAY(IPS_ONE_SEC);\n\t}\n\n\tif (i >= 45) {\n\t\t \n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"timeout waiting for post.\\n\");\n\n\t\treturn (0);\n\t}\n\n\tPost = readl(ha->mem_ptr + IPS_REG_I960_MSG0);\n\n\tif (Post == 0x4F00) {\t \n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"Flashing Battery PIC, Please wait ...\\n\");\n\n\t\t \n\t\tIsr = (uint32_t) IPS_BIT_I960_MSG0I;\n\t\twritel(Isr, ha->mem_ptr + IPS_REG_I2O_HIR);\n\n\t\tfor (i = 0; i < 120; i++) {\t \n\t\t\tPost = readl(ha->mem_ptr + IPS_REG_I960_MSG0);\n\t\t\tif (Post != 0x4F00)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tMDELAY(IPS_ONE_SEC);\n\t\t}\n\n\t\tif (i >= 120) {\n\t\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t\t   \"timeout waiting for Battery PIC Flash\\n\");\n\t\t\treturn (0);\n\t\t}\n\n\t}\n\n\t \n\tIsr = (uint32_t) IPS_BIT_I960_MSG0I;\n\twritel(Isr, ha->mem_ptr + IPS_REG_I2O_HIR);\n\n\tif (Post < (IPS_GOOD_POST_STATUS << 8)) {\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"reset controller fails (post status %x).\\n\", Post);\n\n\t\treturn (0);\n\t}\n\n\t \n\tfor (i = 0; i < 240; i++) {\n\t\tIsr = readl(ha->mem_ptr + IPS_REG_I2O_HIR);\n\n\t\tif (Isr & IPS_BIT_I960_MSG1I)\n\t\t\tbreak;\n\n\t\t \n\t\tMDELAY(IPS_ONE_SEC);\n\t}\n\n\tif (i >= 240) {\n\t\t \n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"timeout waiting for config.\\n\");\n\n\t\treturn (0);\n\t}\n\n\tConfig = readl(ha->mem_ptr + IPS_REG_I960_MSG1);\n\n\t \n\tIsr = (uint32_t) IPS_BIT_I960_MSG1I;\n\twritel(Isr, ha->mem_ptr + IPS_REG_I2O_HIR);\n\n\t \n\tOimr = readl(ha->mem_ptr + IPS_REG_I960_OIMR);\n\tOimr &= ~0x8;\n\twritel(Oimr, ha->mem_ptr + IPS_REG_I960_OIMR);\n\n\t \n\n\t \n\tif (Post == 0xEF10) {\n\t\tif ((Config == 0x000F) || (Config == 0x0009))\n\t\t\tha->requires_esl = 1;\n\t}\n\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_reset_copperhead(ips_ha_t * ha)\n{\n\tint reset_counter;\n\n\tMETHOD_TRACE(\"ips_reset_copperhead\", 1);\n\n\tDEBUG_VAR(1, \"(%s%d) ips_reset_copperhead: io addr: %x, irq: %d\",\n\t\t  ips_name, ha->host_num, ha->io_addr, ha->pcidev->irq);\n\n\treset_counter = 0;\n\n\twhile (reset_counter < 2) {\n\t\treset_counter++;\n\n\t\toutb(IPS_BIT_RST, ha->io_addr + IPS_REG_SCPR);\n\n\t\t \n\t\tMDELAY(IPS_ONE_SEC);\n\n\t\toutb(0, ha->io_addr + IPS_REG_SCPR);\n\n\t\t \n\t\tMDELAY(IPS_ONE_SEC);\n\n\t\tif ((*ha->func.init) (ha))\n\t\t\tbreak;\n\t\telse if (reset_counter >= 2) {\n\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_reset_copperhead_memio(ips_ha_t * ha)\n{\n\tint reset_counter;\n\n\tMETHOD_TRACE(\"ips_reset_copperhead_memio\", 1);\n\n\tDEBUG_VAR(1, \"(%s%d) ips_reset_copperhead_memio: mem addr: %x, irq: %d\",\n\t\t  ips_name, ha->host_num, ha->mem_addr, ha->pcidev->irq);\n\n\treset_counter = 0;\n\n\twhile (reset_counter < 2) {\n\t\treset_counter++;\n\n\t\twriteb(IPS_BIT_RST, ha->mem_ptr + IPS_REG_SCPR);\n\n\t\t \n\t\tMDELAY(IPS_ONE_SEC);\n\n\t\twriteb(0, ha->mem_ptr + IPS_REG_SCPR);\n\n\t\t \n\t\tMDELAY(IPS_ONE_SEC);\n\n\t\tif ((*ha->func.init) (ha))\n\t\t\tbreak;\n\t\telse if (reset_counter >= 2) {\n\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_reset_morpheus(ips_ha_t * ha)\n{\n\tint reset_counter;\n\tuint8_t junk;\n\n\tMETHOD_TRACE(\"ips_reset_morpheus\", 1);\n\n\tDEBUG_VAR(1, \"(%s%d) ips_reset_morpheus: mem addr: %x, irq: %d\",\n\t\t  ips_name, ha->host_num, ha->mem_addr, ha->pcidev->irq);\n\n\treset_counter = 0;\n\n\twhile (reset_counter < 2) {\n\t\treset_counter++;\n\n\t\twritel(0x80000000, ha->mem_ptr + IPS_REG_I960_IDR);\n\n\t\t \n\t\tMDELAY(5 * IPS_ONE_SEC);\n\n\t\t \n\t\tpci_read_config_byte(ha->pcidev, 4, &junk);\n\n\t\tif ((*ha->func.init) (ha))\n\t\t\tbreak;\n\t\telse if (reset_counter >= 2) {\n\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic void\nips_statinit(ips_ha_t * ha)\n{\n\tuint32_t phys_status_start;\n\n\tMETHOD_TRACE(\"ips_statinit\", 1);\n\n\tha->adapt->p_status_start = ha->adapt->status;\n\tha->adapt->p_status_end = ha->adapt->status + IPS_MAX_CMDS;\n\tha->adapt->p_status_tail = ha->adapt->status;\n\n\tphys_status_start = ha->adapt->hw_status_start;\n\toutl(phys_status_start, ha->io_addr + IPS_REG_SQSR);\n\toutl(phys_status_start + IPS_STATUS_Q_SIZE,\n\t     ha->io_addr + IPS_REG_SQER);\n\toutl(phys_status_start + IPS_STATUS_SIZE,\n\t     ha->io_addr + IPS_REG_SQHR);\n\toutl(phys_status_start, ha->io_addr + IPS_REG_SQTR);\n\n\tha->adapt->hw_status_tail = phys_status_start;\n}\n\n \n \n \n \n \n \n \n \n \nstatic void\nips_statinit_memio(ips_ha_t * ha)\n{\n\tuint32_t phys_status_start;\n\n\tMETHOD_TRACE(\"ips_statinit_memio\", 1);\n\n\tha->adapt->p_status_start = ha->adapt->status;\n\tha->adapt->p_status_end = ha->adapt->status + IPS_MAX_CMDS;\n\tha->adapt->p_status_tail = ha->adapt->status;\n\n\tphys_status_start = ha->adapt->hw_status_start;\n\twritel(phys_status_start, ha->mem_ptr + IPS_REG_SQSR);\n\twritel(phys_status_start + IPS_STATUS_Q_SIZE,\n\t       ha->mem_ptr + IPS_REG_SQER);\n\twritel(phys_status_start + IPS_STATUS_SIZE, ha->mem_ptr + IPS_REG_SQHR);\n\twritel(phys_status_start, ha->mem_ptr + IPS_REG_SQTR);\n\n\tha->adapt->hw_status_tail = phys_status_start;\n}\n\n \n \n \n \n \n \n \n \n \nstatic uint32_t\nips_statupd_copperhead(ips_ha_t * ha)\n{\n\tMETHOD_TRACE(\"ips_statupd_copperhead\", 1);\n\n\tif (ha->adapt->p_status_tail != ha->adapt->p_status_end) {\n\t\tha->adapt->p_status_tail++;\n\t\tha->adapt->hw_status_tail += sizeof (IPS_STATUS);\n\t} else {\n\t\tha->adapt->p_status_tail = ha->adapt->p_status_start;\n\t\tha->adapt->hw_status_tail = ha->adapt->hw_status_start;\n\t}\n\n\toutl(ha->adapt->hw_status_tail,\n\t     ha->io_addr + IPS_REG_SQTR);\n\n\treturn (ha->adapt->p_status_tail->value);\n}\n\n \n \n \n \n \n \n \n \n \nstatic uint32_t\nips_statupd_copperhead_memio(ips_ha_t * ha)\n{\n\tMETHOD_TRACE(\"ips_statupd_copperhead_memio\", 1);\n\n\tif (ha->adapt->p_status_tail != ha->adapt->p_status_end) {\n\t\tha->adapt->p_status_tail++;\n\t\tha->adapt->hw_status_tail += sizeof (IPS_STATUS);\n\t} else {\n\t\tha->adapt->p_status_tail = ha->adapt->p_status_start;\n\t\tha->adapt->hw_status_tail = ha->adapt->hw_status_start;\n\t}\n\n\twritel(ha->adapt->hw_status_tail, ha->mem_ptr + IPS_REG_SQTR);\n\n\treturn (ha->adapt->p_status_tail->value);\n}\n\n \n \n \n \n \n \n \n \n \nstatic uint32_t\nips_statupd_morpheus(ips_ha_t * ha)\n{\n\tuint32_t val;\n\n\tMETHOD_TRACE(\"ips_statupd_morpheus\", 1);\n\n\tval = readl(ha->mem_ptr + IPS_REG_I2O_OUTMSGQ);\n\n\treturn (val);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_issue_copperhead(ips_ha_t * ha, ips_scb_t * scb)\n{\n\tuint32_t TimeOut;\n\tuint32_t val;\n\n\tMETHOD_TRACE(\"ips_issue_copperhead\", 1);\n\n\tif (scb->scsi_cmd) {\n\t\tDEBUG_VAR(2, \"(%s%d) ips_issue: cmd 0x%X id %d (%d %d %d)\",\n\t\t\t  ips_name,\n\t\t\t  ha->host_num,\n\t\t\t  scb->cdb[0],\n\t\t\t  scb->cmd.basic_io.command_id,\n\t\t\t  scb->bus, scb->target_id, scb->lun);\n\t} else {\n\t\tDEBUG_VAR(2, KERN_NOTICE \"(%s%d) ips_issue: logical cmd id %d\",\n\t\t\t  ips_name, ha->host_num, scb->cmd.basic_io.command_id);\n\t}\n\n\tTimeOut = 0;\n\n\twhile ((val =\n\t\tle32_to_cpu(inl(ha->io_addr + IPS_REG_CCCR))) & IPS_BIT_SEM) {\n\t\tudelay(1000);\n\n\t\tif (++TimeOut >= IPS_SEM_TIMEOUT) {\n\t\t\tif (!(val & IPS_BIT_START_STOP))\n\t\t\t\tbreak;\n\n\t\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t\t   \"ips_issue val [0x%x].\\n\", val);\n\t\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t\t   \"ips_issue semaphore chk timeout.\\n\");\n\n\t\t\treturn (IPS_FAILURE);\n\t\t}\t\t \n\t}\t\t\t \n\n\toutl(scb->scb_busaddr, ha->io_addr + IPS_REG_CCSAR);\n\toutw(IPS_BIT_START_CMD, ha->io_addr + IPS_REG_CCCR);\n\n\treturn (IPS_SUCCESS);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_issue_copperhead_memio(ips_ha_t * ha, ips_scb_t * scb)\n{\n\tuint32_t TimeOut;\n\tuint32_t val;\n\n\tMETHOD_TRACE(\"ips_issue_copperhead_memio\", 1);\n\n\tif (scb->scsi_cmd) {\n\t\tDEBUG_VAR(2, \"(%s%d) ips_issue: cmd 0x%X id %d (%d %d %d)\",\n\t\t\t  ips_name,\n\t\t\t  ha->host_num,\n\t\t\t  scb->cdb[0],\n\t\t\t  scb->cmd.basic_io.command_id,\n\t\t\t  scb->bus, scb->target_id, scb->lun);\n\t} else {\n\t\tDEBUG_VAR(2, \"(%s%d) ips_issue: logical cmd id %d\",\n\t\t\t  ips_name, ha->host_num, scb->cmd.basic_io.command_id);\n\t}\n\n\tTimeOut = 0;\n\n\twhile ((val = readl(ha->mem_ptr + IPS_REG_CCCR)) & IPS_BIT_SEM) {\n\t\tudelay(1000);\n\n\t\tif (++TimeOut >= IPS_SEM_TIMEOUT) {\n\t\t\tif (!(val & IPS_BIT_START_STOP))\n\t\t\t\tbreak;\n\n\t\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t\t   \"ips_issue val [0x%x].\\n\", val);\n\t\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t\t   \"ips_issue semaphore chk timeout.\\n\");\n\n\t\t\treturn (IPS_FAILURE);\n\t\t}\t\t \n\t}\t\t\t \n\n\twritel(scb->scb_busaddr, ha->mem_ptr + IPS_REG_CCSAR);\n\twritel(IPS_BIT_START_CMD, ha->mem_ptr + IPS_REG_CCCR);\n\n\treturn (IPS_SUCCESS);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_issue_i2o(ips_ha_t * ha, ips_scb_t * scb)\n{\n\n\tMETHOD_TRACE(\"ips_issue_i2o\", 1);\n\n\tif (scb->scsi_cmd) {\n\t\tDEBUG_VAR(2, \"(%s%d) ips_issue: cmd 0x%X id %d (%d %d %d)\",\n\t\t\t  ips_name,\n\t\t\t  ha->host_num,\n\t\t\t  scb->cdb[0],\n\t\t\t  scb->cmd.basic_io.command_id,\n\t\t\t  scb->bus, scb->target_id, scb->lun);\n\t} else {\n\t\tDEBUG_VAR(2, \"(%s%d) ips_issue: logical cmd id %d\",\n\t\t\t  ips_name, ha->host_num, scb->cmd.basic_io.command_id);\n\t}\n\n\toutl(scb->scb_busaddr, ha->io_addr + IPS_REG_I2O_INMSGQ);\n\n\treturn (IPS_SUCCESS);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_issue_i2o_memio(ips_ha_t * ha, ips_scb_t * scb)\n{\n\n\tMETHOD_TRACE(\"ips_issue_i2o_memio\", 1);\n\n\tif (scb->scsi_cmd) {\n\t\tDEBUG_VAR(2, \"(%s%d) ips_issue: cmd 0x%X id %d (%d %d %d)\",\n\t\t\t  ips_name,\n\t\t\t  ha->host_num,\n\t\t\t  scb->cdb[0],\n\t\t\t  scb->cmd.basic_io.command_id,\n\t\t\t  scb->bus, scb->target_id, scb->lun);\n\t} else {\n\t\tDEBUG_VAR(2, \"(%s%d) ips_issue: logical cmd id %d\",\n\t\t\t  ips_name, ha->host_num, scb->cmd.basic_io.command_id);\n\t}\n\n\twritel(scb->scb_busaddr, ha->mem_ptr + IPS_REG_I2O_INMSGQ);\n\n\treturn (IPS_SUCCESS);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_isintr_copperhead(ips_ha_t * ha)\n{\n\tuint8_t Isr;\n\n\tMETHOD_TRACE(\"ips_isintr_copperhead\", 2);\n\n\tIsr = inb(ha->io_addr + IPS_REG_HISR);\n\n\tif (Isr == 0xFF)\n\t\t \n\t\treturn (0);\n\n\tif (Isr & IPS_BIT_SCE)\n\t\treturn (1);\n\telse if (Isr & (IPS_BIT_SQO | IPS_BIT_GHI)) {\n\t\t \n\t\t \n\t\toutb(Isr, ha->io_addr + IPS_REG_HISR);\n\t}\n\n\treturn (0);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_isintr_copperhead_memio(ips_ha_t * ha)\n{\n\tuint8_t Isr;\n\n\tMETHOD_TRACE(\"ips_isintr_memio\", 2);\n\n\tIsr = readb(ha->mem_ptr + IPS_REG_HISR);\n\n\tif (Isr == 0xFF)\n\t\t \n\t\treturn (0);\n\n\tif (Isr & IPS_BIT_SCE)\n\t\treturn (1);\n\telse if (Isr & (IPS_BIT_SQO | IPS_BIT_GHI)) {\n\t\t \n\t\t \n\t\twriteb(Isr, ha->mem_ptr + IPS_REG_HISR);\n\t}\n\n\treturn (0);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_isintr_morpheus(ips_ha_t * ha)\n{\n\tuint32_t Isr;\n\n\tMETHOD_TRACE(\"ips_isintr_morpheus\", 2);\n\n\tIsr = readl(ha->mem_ptr + IPS_REG_I2O_HIR);\n\n\tif (Isr & IPS_BIT_I2O_OPQI)\n\t\treturn (1);\n\telse\n\t\treturn (0);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_wait(ips_ha_t * ha, int time, int intr)\n{\n\tint ret;\n\tint done;\n\n\tMETHOD_TRACE(\"ips_wait\", 1);\n\n\tret = IPS_FAILURE;\n\tdone = false;\n\n\ttime *= IPS_ONE_SEC;\t \n\n\twhile ((time > 0) && (!done)) {\n\t\tif (intr == IPS_INTR_ON) {\n\t\t\tif (!ha->waitflag) {\n\t\t\t\tret = IPS_SUCCESS;\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (intr == IPS_INTR_IORL) {\n\t\t\tif (!ha->waitflag) {\n\t\t\t\t \n\t\t\t\tret = IPS_SUCCESS;\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\n\t\t\t(*ha->func.intr) (ha);\n\t\t}\n\n\t\t \n\t\tudelay(1000);\n\t\ttime--;\n\t}\n\n\treturn (ret);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_write_driver_status(ips_ha_t * ha, int intr)\n{\n\tMETHOD_TRACE(\"ips_write_driver_status\", 1);\n\n\tif (!ips_readwrite_page5(ha, false, intr)) {\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"unable to read NVRAM page 5.\\n\");\n\n\t\treturn (0);\n\t}\n\n\t \n\t \n\tif (le32_to_cpu(ha->nvram->signature) != IPS_NVRAM_P5_SIG) {\n\t\tDEBUG_VAR(1,\n\t\t\t  \"(%s%d) NVRAM page 5 has an invalid signature: %X.\",\n\t\t\t  ips_name, ha->host_num, ha->nvram->signature);\n\t\tha->nvram->signature = IPS_NVRAM_P5_SIG;\n\t}\n\n\tDEBUG_VAR(2,\n\t\t  \"(%s%d) Ad Type: %d, Ad Slot: %d, BIOS: %c%c%c%c %c%c%c%c.\",\n\t\t  ips_name, ha->host_num, le16_to_cpu(ha->nvram->adapter_type),\n\t\t  ha->nvram->adapter_slot, ha->nvram->bios_high[0],\n\t\t  ha->nvram->bios_high[1], ha->nvram->bios_high[2],\n\t\t  ha->nvram->bios_high[3], ha->nvram->bios_low[0],\n\t\t  ha->nvram->bios_low[1], ha->nvram->bios_low[2],\n\t\t  ha->nvram->bios_low[3]);\n\n\tips_get_bios_version(ha, intr);\n\n\t \n\tha->nvram->operating_system = IPS_OS_LINUX;\n\tha->nvram->adapter_type = ha->ad_type;\n\tmemcpy((char *) ha->nvram->driver_high, IPS_VERSION_HIGH, 4);\n\tmemcpy((char *) ha->nvram->driver_low, IPS_VERSION_LOW, 4);\n\tmemcpy((char *) ha->nvram->bios_high, ha->bios_version, 4);\n\tmemcpy((char *) ha->nvram->bios_low, ha->bios_version + 4, 4);\n\n\tha->nvram->versioning = 0;\t \n\n\t \n\tif (!ips_readwrite_page5(ha, true, intr)) {\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"unable to write NVRAM page 5.\\n\");\n\n\t\treturn (0);\n\t}\n\n\t \n\tha->slot_num = ha->nvram->adapter_slot;\n\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_read_adapter_status(ips_ha_t * ha, int intr)\n{\n\tips_scb_t *scb;\n\tint ret;\n\n\tMETHOD_TRACE(\"ips_read_adapter_status\", 1);\n\n\tscb = &ha->scbs[ha->max_cmds - 1];\n\n\tips_init_scb(ha, scb);\n\n\tscb->timeout = ips_cmd_timeout;\n\tscb->cdb[0] = IPS_CMD_ENQUIRY;\n\n\tscb->cmd.basic_io.op_code = IPS_CMD_ENQUIRY;\n\tscb->cmd.basic_io.command_id = IPS_COMMAND_ID(ha, scb);\n\tscb->cmd.basic_io.sg_count = 0;\n\tscb->cmd.basic_io.lba = 0;\n\tscb->cmd.basic_io.sector_count = 0;\n\tscb->cmd.basic_io.log_drv = 0;\n\tscb->data_len = sizeof (*ha->enq);\n\tscb->cmd.basic_io.sg_addr = ha->enq_busaddr;\n\n\t \n\tif (((ret =\n\t      ips_send_wait(ha, scb, ips_cmd_timeout, intr)) == IPS_FAILURE)\n\t    || (ret == IPS_SUCCESS_IMM)\n\t    || ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1))\n\t\treturn (0);\n\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_read_subsystem_parameters(ips_ha_t * ha, int intr)\n{\n\tips_scb_t *scb;\n\tint ret;\n\n\tMETHOD_TRACE(\"ips_read_subsystem_parameters\", 1);\n\n\tscb = &ha->scbs[ha->max_cmds - 1];\n\n\tips_init_scb(ha, scb);\n\n\tscb->timeout = ips_cmd_timeout;\n\tscb->cdb[0] = IPS_CMD_GET_SUBSYS;\n\n\tscb->cmd.basic_io.op_code = IPS_CMD_GET_SUBSYS;\n\tscb->cmd.basic_io.command_id = IPS_COMMAND_ID(ha, scb);\n\tscb->cmd.basic_io.sg_count = 0;\n\tscb->cmd.basic_io.lba = 0;\n\tscb->cmd.basic_io.sector_count = 0;\n\tscb->cmd.basic_io.log_drv = 0;\n\tscb->data_len = sizeof (*ha->subsys);\n\tscb->cmd.basic_io.sg_addr = ha->ioctl_busaddr;\n\n\t \n\tif (((ret =\n\t      ips_send_wait(ha, scb, ips_cmd_timeout, intr)) == IPS_FAILURE)\n\t    || (ret == IPS_SUCCESS_IMM)\n\t    || ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1))\n\t\treturn (0);\n\n\tmemcpy(ha->subsys, ha->ioctl_data, sizeof(*ha->subsys));\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_read_config(ips_ha_t * ha, int intr)\n{\n\tips_scb_t *scb;\n\tint i;\n\tint ret;\n\n\tMETHOD_TRACE(\"ips_read_config\", 1);\n\n\t \n\tfor (i = 0; i < 4; i++)\n\t\tha->conf->init_id[i] = 7;\n\n\tscb = &ha->scbs[ha->max_cmds - 1];\n\n\tips_init_scb(ha, scb);\n\n\tscb->timeout = ips_cmd_timeout;\n\tscb->cdb[0] = IPS_CMD_READ_CONF;\n\n\tscb->cmd.basic_io.op_code = IPS_CMD_READ_CONF;\n\tscb->cmd.basic_io.command_id = IPS_COMMAND_ID(ha, scb);\n\tscb->data_len = sizeof (*ha->conf);\n\tscb->cmd.basic_io.sg_addr = ha->ioctl_busaddr;\n\n\t \n\tif (((ret =\n\t      ips_send_wait(ha, scb, ips_cmd_timeout, intr)) == IPS_FAILURE)\n\t    || (ret == IPS_SUCCESS_IMM)\n\t    || ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1)) {\n\n\t\tmemset(ha->conf, 0, sizeof (IPS_CONF));\n\n\t\t \n\t\tfor (i = 0; i < 4; i++)\n\t\t\tha->conf->init_id[i] = 7;\n\n\t\t \n\t\tif ((scb->basic_status & IPS_GSC_STATUS_MASK) ==\n\t\t    IPS_CMD_CMPLT_WERROR)\n\t\t\treturn (1);\n\n\t\treturn (0);\n\t}\n\n\tmemcpy(ha->conf, ha->ioctl_data, sizeof(*ha->conf));\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_readwrite_page5(ips_ha_t * ha, int write, int intr)\n{\n\tips_scb_t *scb;\n\tint ret;\n\n\tMETHOD_TRACE(\"ips_readwrite_page5\", 1);\n\n\tscb = &ha->scbs[ha->max_cmds - 1];\n\n\tips_init_scb(ha, scb);\n\n\tscb->timeout = ips_cmd_timeout;\n\tscb->cdb[0] = IPS_CMD_RW_NVRAM_PAGE;\n\n\tscb->cmd.nvram.op_code = IPS_CMD_RW_NVRAM_PAGE;\n\tscb->cmd.nvram.command_id = IPS_COMMAND_ID(ha, scb);\n\tscb->cmd.nvram.page = 5;\n\tscb->cmd.nvram.write = write;\n\tscb->cmd.nvram.reserved = 0;\n\tscb->cmd.nvram.reserved2 = 0;\n\tscb->data_len = sizeof (*ha->nvram);\n\tscb->cmd.nvram.buffer_addr = ha->ioctl_busaddr;\n\tif (write)\n\t\tmemcpy(ha->ioctl_data, ha->nvram, sizeof(*ha->nvram));\n\n\t \n\tif (((ret =\n\t      ips_send_wait(ha, scb, ips_cmd_timeout, intr)) == IPS_FAILURE)\n\t    || (ret == IPS_SUCCESS_IMM)\n\t    || ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1)) {\n\n\t\tmemset(ha->nvram, 0, sizeof (IPS_NVRAM_P5));\n\n\t\treturn (0);\n\t}\n\tif (!write)\n\t\tmemcpy(ha->nvram, ha->ioctl_data, sizeof(*ha->nvram));\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_clear_adapter(ips_ha_t * ha, int intr)\n{\n\tips_scb_t *scb;\n\tint ret;\n\n\tMETHOD_TRACE(\"ips_clear_adapter\", 1);\n\n\tscb = &ha->scbs[ha->max_cmds - 1];\n\n\tips_init_scb(ha, scb);\n\n\tscb->timeout = ips_reset_timeout;\n\tscb->cdb[0] = IPS_CMD_CONFIG_SYNC;\n\n\tscb->cmd.config_sync.op_code = IPS_CMD_CONFIG_SYNC;\n\tscb->cmd.config_sync.command_id = IPS_COMMAND_ID(ha, scb);\n\tscb->cmd.config_sync.channel = 0;\n\tscb->cmd.config_sync.source_target = IPS_POCL;\n\tscb->cmd.config_sync.reserved = 0;\n\tscb->cmd.config_sync.reserved2 = 0;\n\tscb->cmd.config_sync.reserved3 = 0;\n\n\t \n\tif (((ret =\n\t      ips_send_wait(ha, scb, ips_reset_timeout, intr)) == IPS_FAILURE)\n\t    || (ret == IPS_SUCCESS_IMM)\n\t    || ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1))\n\t\treturn (0);\n\n\t \n\tips_init_scb(ha, scb);\n\n\tscb->cdb[0] = IPS_CMD_ERROR_TABLE;\n\tscb->timeout = ips_reset_timeout;\n\n\tscb->cmd.unlock_stripe.op_code = IPS_CMD_ERROR_TABLE;\n\tscb->cmd.unlock_stripe.command_id = IPS_COMMAND_ID(ha, scb);\n\tscb->cmd.unlock_stripe.log_drv = 0;\n\tscb->cmd.unlock_stripe.control = IPS_CSL;\n\tscb->cmd.unlock_stripe.reserved = 0;\n\tscb->cmd.unlock_stripe.reserved2 = 0;\n\tscb->cmd.unlock_stripe.reserved3 = 0;\n\n\t \n\tif (((ret =\n\t      ips_send_wait(ha, scb, ips_cmd_timeout, intr)) == IPS_FAILURE)\n\t    || (ret == IPS_SUCCESS_IMM)\n\t    || ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1))\n\t\treturn (0);\n\n\treturn (1);\n}\n\n \n \n \n \n \n \n \n \n \nstatic void\nips_ffdc_reset(ips_ha_t * ha, int intr)\n{\n\tips_scb_t *scb;\n\n\tMETHOD_TRACE(\"ips_ffdc_reset\", 1);\n\n\tscb = &ha->scbs[ha->max_cmds - 1];\n\n\tips_init_scb(ha, scb);\n\n\tscb->timeout = ips_cmd_timeout;\n\tscb->cdb[0] = IPS_CMD_FFDC;\n\tscb->cmd.ffdc.op_code = IPS_CMD_FFDC;\n\tscb->cmd.ffdc.command_id = IPS_COMMAND_ID(ha, scb);\n\tscb->cmd.ffdc.reset_count = ha->reset_count;\n\tscb->cmd.ffdc.reset_type = 0x80;\n\n\t \n\tips_fix_ffdc_time(ha, scb, ha->last_ffdc);\n\n\t \n\tips_send_wait(ha, scb, ips_cmd_timeout, intr);\n}\n\n \n \n \n \n \n \n \n \n \nstatic void\nips_ffdc_time(ips_ha_t * ha)\n{\n\tips_scb_t *scb;\n\n\tMETHOD_TRACE(\"ips_ffdc_time\", 1);\n\n\tDEBUG_VAR(1, \"(%s%d) Sending time update.\", ips_name, ha->host_num);\n\n\tscb = &ha->scbs[ha->max_cmds - 1];\n\n\tips_init_scb(ha, scb);\n\n\tscb->timeout = ips_cmd_timeout;\n\tscb->cdb[0] = IPS_CMD_FFDC;\n\tscb->cmd.ffdc.op_code = IPS_CMD_FFDC;\n\tscb->cmd.ffdc.command_id = IPS_COMMAND_ID(ha, scb);\n\tscb->cmd.ffdc.reset_count = 0;\n\tscb->cmd.ffdc.reset_type = 0;\n\n\t \n\tips_fix_ffdc_time(ha, scb, ha->last_ffdc);\n\n\t \n\tips_send_wait(ha, scb, ips_cmd_timeout, IPS_FFDC);\n}\n\n \n \n \n \n \n \n \n \nstatic void\nips_fix_ffdc_time(ips_ha_t * ha, ips_scb_t * scb, time64_t current_time)\n{\n\tstruct tm tm;\n\n\tMETHOD_TRACE(\"ips_fix_ffdc_time\", 1);\n\n\ttime64_to_tm(current_time, 0, &tm);\n\n\tscb->cmd.ffdc.hour   = tm.tm_hour;\n\tscb->cmd.ffdc.minute = tm.tm_min;\n\tscb->cmd.ffdc.second = tm.tm_sec;\n\tscb->cmd.ffdc.yearH  = (tm.tm_year + 1900) / 100;\n\tscb->cmd.ffdc.yearL  = tm.tm_year % 100;\n\tscb->cmd.ffdc.month  = tm.tm_mon + 1;\n\tscb->cmd.ffdc.day    = tm.tm_mday;\n}\n\n \n\n \n \n \n \n \n \n \n \nstatic int\nips_erase_bios(ips_ha_t * ha)\n{\n\tint timeout;\n\tuint8_t status = 0;\n\n\tMETHOD_TRACE(\"ips_erase_bios\", 1);\n\n\tstatus = 0;\n\n\t \n\toutl(0, ha->io_addr + IPS_REG_FLAP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\toutb(0x50, ha->io_addr + IPS_REG_FLDP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\t \n\toutb(0x20, ha->io_addr + IPS_REG_FLDP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\t \n\toutb(0xD0, ha->io_addr + IPS_REG_FLDP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\t \n\toutb(0x70, ha->io_addr + IPS_REG_FLDP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\ttimeout = 80000;\t \n\n\twhile (timeout > 0) {\n\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64) {\n\t\t\toutl(0, ha->io_addr + IPS_REG_FLAP);\n\t\t\tudelay(25);\t \n\t\t}\n\n\t\tstatus = inb(ha->io_addr + IPS_REG_FLDP);\n\n\t\tif (status & 0x80)\n\t\t\tbreak;\n\n\t\tMDELAY(1);\n\t\ttimeout--;\n\t}\n\n\t \n\tif (timeout <= 0) {\n\t\t \n\n\t\t \n\t\toutb(0xB0, ha->io_addr + IPS_REG_FLDP);\n\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\tudelay(25);\t \n\n\t\t \n\t\ttimeout = 10000;\n\t\twhile (timeout > 0) {\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64) {\n\t\t\t\toutl(0, ha->io_addr + IPS_REG_FLAP);\n\t\t\t\tudelay(25);\t \n\t\t\t}\n\n\t\t\tstatus = inb(ha->io_addr + IPS_REG_FLDP);\n\n\t\t\tif (status & 0xC0)\n\t\t\t\tbreak;\n\n\t\t\tMDELAY(1);\n\t\t\ttimeout--;\n\t\t}\n\n\t\treturn (1);\n\t}\n\n\t \n\tif (status & 0x08)\n\t\t \n\t\treturn (1);\n\n\t \n\tif (status & 0x30)\n\t\t \n\t\treturn (1);\n\n\t \n\t \n\toutb(0x50, ha->io_addr + IPS_REG_FLDP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\t \n\toutb(0xFF, ha->io_addr + IPS_REG_FLDP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\treturn (0);\n}\n\n \n \n \n \n \n \n \n \nstatic int\nips_erase_bios_memio(ips_ha_t * ha)\n{\n\tint timeout;\n\tuint8_t status;\n\n\tMETHOD_TRACE(\"ips_erase_bios_memio\", 1);\n\n\tstatus = 0;\n\n\t \n\twritel(0, ha->mem_ptr + IPS_REG_FLAP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\twriteb(0x50, ha->mem_ptr + IPS_REG_FLDP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\t \n\twriteb(0x20, ha->mem_ptr + IPS_REG_FLDP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\t \n\twriteb(0xD0, ha->mem_ptr + IPS_REG_FLDP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\t \n\twriteb(0x70, ha->mem_ptr + IPS_REG_FLDP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\ttimeout = 80000;\t \n\n\twhile (timeout > 0) {\n\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64) {\n\t\t\twritel(0, ha->mem_ptr + IPS_REG_FLAP);\n\t\t\tudelay(25);\t \n\t\t}\n\n\t\tstatus = readb(ha->mem_ptr + IPS_REG_FLDP);\n\n\t\tif (status & 0x80)\n\t\t\tbreak;\n\n\t\tMDELAY(1);\n\t\ttimeout--;\n\t}\n\n\t \n\tif (timeout <= 0) {\n\t\t \n\n\t\t \n\t\twriteb(0xB0, ha->mem_ptr + IPS_REG_FLDP);\n\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\tudelay(25);\t \n\n\t\t \n\t\ttimeout = 10000;\n\t\twhile (timeout > 0) {\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64) {\n\t\t\t\twritel(0, ha->mem_ptr + IPS_REG_FLAP);\n\t\t\t\tudelay(25);\t \n\t\t\t}\n\n\t\t\tstatus = readb(ha->mem_ptr + IPS_REG_FLDP);\n\n\t\t\tif (status & 0xC0)\n\t\t\t\tbreak;\n\n\t\t\tMDELAY(1);\n\t\t\ttimeout--;\n\t\t}\n\n\t\treturn (1);\n\t}\n\n\t \n\tif (status & 0x08)\n\t\t \n\t\treturn (1);\n\n\t \n\tif (status & 0x30)\n\t\t \n\t\treturn (1);\n\n\t \n\t \n\twriteb(0x50, ha->mem_ptr + IPS_REG_FLDP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\t \n\twriteb(0xFF, ha->mem_ptr + IPS_REG_FLDP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\treturn (0);\n}\n\n \n \n \n \n \n \n \n \nstatic int\nips_program_bios(ips_ha_t * ha, char *buffer, uint32_t buffersize,\n\t\t uint32_t offset)\n{\n\tint i;\n\tint timeout;\n\tuint8_t status = 0;\n\n\tMETHOD_TRACE(\"ips_program_bios\", 1);\n\n\tstatus = 0;\n\n\tfor (i = 0; i < buffersize; i++) {\n\t\t \n\t\toutl(i + offset, ha->io_addr + IPS_REG_FLAP);\n\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\tudelay(25);\t \n\n\t\toutb(0x40, ha->io_addr + IPS_REG_FLDP);\n\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\tudelay(25);\t \n\n\t\toutb(buffer[i], ha->io_addr + IPS_REG_FLDP);\n\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\tudelay(25);\t \n\n\t\t \n\t\ttimeout = 1000;\n\t\twhile (timeout > 0) {\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64) {\n\t\t\t\toutl(0, ha->io_addr + IPS_REG_FLAP);\n\t\t\t\tudelay(25);\t \n\t\t\t}\n\n\t\t\tstatus = inb(ha->io_addr + IPS_REG_FLDP);\n\n\t\t\tif (status & 0x80)\n\t\t\t\tbreak;\n\n\t\t\tMDELAY(1);\n\t\t\ttimeout--;\n\t\t}\n\n\t\tif (timeout == 0) {\n\t\t\t \n\t\t\toutl(0, ha->io_addr + IPS_REG_FLAP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\toutb(0xFF, ha->io_addr + IPS_REG_FLDP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\treturn (1);\n\t\t}\n\n\t\t \n\t\tif (status & 0x18) {\n\t\t\t \n\t\t\toutl(0, ha->io_addr + IPS_REG_FLAP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\toutb(0xFF, ha->io_addr + IPS_REG_FLDP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\treturn (1);\n\t\t}\n\t}\t\t\t \n\n\t \n\toutl(0, ha->io_addr + IPS_REG_FLAP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\toutb(0xFF, ha->io_addr + IPS_REG_FLDP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\treturn (0);\n}\n\n \n \n \n \n \n \n \n \nstatic int\nips_program_bios_memio(ips_ha_t * ha, char *buffer, uint32_t buffersize,\n\t\t       uint32_t offset)\n{\n\tint i;\n\tint timeout;\n\tuint8_t status = 0;\n\n\tMETHOD_TRACE(\"ips_program_bios_memio\", 1);\n\n\tstatus = 0;\n\n\tfor (i = 0; i < buffersize; i++) {\n\t\t \n\t\twritel(i + offset, ha->mem_ptr + IPS_REG_FLAP);\n\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\tudelay(25);\t \n\n\t\twriteb(0x40, ha->mem_ptr + IPS_REG_FLDP);\n\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\tudelay(25);\t \n\n\t\twriteb(buffer[i], ha->mem_ptr + IPS_REG_FLDP);\n\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\tudelay(25);\t \n\n\t\t \n\t\ttimeout = 1000;\n\t\twhile (timeout > 0) {\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64) {\n\t\t\t\twritel(0, ha->mem_ptr + IPS_REG_FLAP);\n\t\t\t\tudelay(25);\t \n\t\t\t}\n\n\t\t\tstatus = readb(ha->mem_ptr + IPS_REG_FLDP);\n\n\t\t\tif (status & 0x80)\n\t\t\t\tbreak;\n\n\t\t\tMDELAY(1);\n\t\t\ttimeout--;\n\t\t}\n\n\t\tif (timeout == 0) {\n\t\t\t \n\t\t\twritel(0, ha->mem_ptr + IPS_REG_FLAP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\twriteb(0xFF, ha->mem_ptr + IPS_REG_FLDP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\treturn (1);\n\t\t}\n\n\t\t \n\t\tif (status & 0x18) {\n\t\t\t \n\t\t\twritel(0, ha->mem_ptr + IPS_REG_FLAP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\twriteb(0xFF, ha->mem_ptr + IPS_REG_FLDP);\n\t\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\t\tudelay(25);\t \n\n\t\t\treturn (1);\n\t\t}\n\t}\t\t\t \n\n\t \n\twritel(0, ha->mem_ptr + IPS_REG_FLAP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\twriteb(0xFF, ha->mem_ptr + IPS_REG_FLDP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\treturn (0);\n}\n\n \n \n \n \n \n \n \n \nstatic int\nips_verify_bios(ips_ha_t * ha, char *buffer, uint32_t buffersize,\n\t\tuint32_t offset)\n{\n\tuint8_t checksum;\n\tint i;\n\n\tMETHOD_TRACE(\"ips_verify_bios\", 1);\n\n\t \n\toutl(0, ha->io_addr + IPS_REG_FLAP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\tif (inb(ha->io_addr + IPS_REG_FLDP) != 0x55)\n\t\treturn (1);\n\n\toutl(1, ha->io_addr + IPS_REG_FLAP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\tif (inb(ha->io_addr + IPS_REG_FLDP) != 0xAA)\n\t\treturn (1);\n\n\tchecksum = 0xff;\n\tfor (i = 2; i < buffersize; i++) {\n\n\t\toutl(i + offset, ha->io_addr + IPS_REG_FLAP);\n\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\tudelay(25);\t \n\n\t\tchecksum = (uint8_t) checksum + inb(ha->io_addr + IPS_REG_FLDP);\n\t}\n\n\tif (checksum != 0)\n\t\t \n\t\treturn (1);\n\telse\n\t\t \n\t\treturn (0);\n}\n\n \n \n \n \n \n \n \n \nstatic int\nips_verify_bios_memio(ips_ha_t * ha, char *buffer, uint32_t buffersize,\n\t\t      uint32_t offset)\n{\n\tuint8_t checksum;\n\tint i;\n\n\tMETHOD_TRACE(\"ips_verify_bios_memio\", 1);\n\n\t \n\twritel(0, ha->mem_ptr + IPS_REG_FLAP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\n\tif (readb(ha->mem_ptr + IPS_REG_FLDP) != 0x55)\n\t\treturn (1);\n\n\twritel(1, ha->mem_ptr + IPS_REG_FLAP);\n\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\tudelay(25);\t \n\tif (readb(ha->mem_ptr + IPS_REG_FLDP) != 0xAA)\n\t\treturn (1);\n\n\tchecksum = 0xff;\n\tfor (i = 2; i < buffersize; i++) {\n\n\t\twritel(i + offset, ha->mem_ptr + IPS_REG_FLAP);\n\t\tif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\n\t\t\tudelay(25);\t \n\n\t\tchecksum =\n\t\t    (uint8_t) checksum + readb(ha->mem_ptr + IPS_REG_FLDP);\n\t}\n\n\tif (checksum != 0)\n\t\t \n\t\treturn (1);\n\telse\n\t\t \n\t\treturn (0);\n}\n\n \n \n \n \n \n \n \nstatic int\nips_abort_init(ips_ha_t * ha, int index)\n{\n\tha->active = 0;\n\tips_free(ha);\n\tips_ha[index] = NULL;\n\tips_sh[index] = NULL;\n\treturn -1;\n}\n\n \n \n \n \n \n \n \nstatic void\nips_shift_controllers(int lowindex, int highindex)\n{\n\tips_ha_t *ha_sav = ips_ha[highindex];\n\tstruct Scsi_Host *sh_sav = ips_sh[highindex];\n\tint i;\n\n\tfor (i = highindex; i > lowindex; i--) {\n\t\tips_ha[i] = ips_ha[i - 1];\n\t\tips_sh[i] = ips_sh[i - 1];\n\t\tips_ha[i]->host_num = i;\n\t}\n\tha_sav->host_num = lowindex;\n\tips_ha[lowindex] = ha_sav;\n\tips_sh[lowindex] = sh_sav;\n}\n\n \n \n \n \n \n \n \nstatic void\nips_order_controllers(void)\n{\n\tint i, j, tmp, position = 0;\n\tIPS_NVRAM_P5 *nvram;\n\tif (!ips_ha[0])\n\t\treturn;\n\tnvram = ips_ha[0]->nvram;\n\n\tif (nvram->adapter_order[0]) {\n\t\tfor (i = 1; i <= nvram->adapter_order[0]; i++) {\n\t\t\tfor (j = position; j < ips_num_controllers; j++) {\n\t\t\t\tswitch (ips_ha[j]->ad_type) {\n\t\t\t\tcase IPS_ADTYPE_SERVERAID6M:\n\t\t\t\tcase IPS_ADTYPE_SERVERAID7M:\n\t\t\t\t\tif (nvram->adapter_order[i] == 'M') {\n\t\t\t\t\t\tips_shift_controllers(position,\n\t\t\t\t\t\t\t\t      j);\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase IPS_ADTYPE_SERVERAID4L:\n\t\t\t\tcase IPS_ADTYPE_SERVERAID4M:\n\t\t\t\tcase IPS_ADTYPE_SERVERAID4MX:\n\t\t\t\tcase IPS_ADTYPE_SERVERAID4LX:\n\t\t\t\t\tif (nvram->adapter_order[i] == 'N') {\n\t\t\t\t\t\tips_shift_controllers(position,\n\t\t\t\t\t\t\t\t      j);\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase IPS_ADTYPE_SERVERAID6I:\n\t\t\t\tcase IPS_ADTYPE_SERVERAID5I2:\n\t\t\t\tcase IPS_ADTYPE_SERVERAID5I1:\n\t\t\t\tcase IPS_ADTYPE_SERVERAID7k:\n\t\t\t\t\tif (nvram->adapter_order[i] == 'S') {\n\t\t\t\t\t\tips_shift_controllers(position,\n\t\t\t\t\t\t\t\t      j);\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase IPS_ADTYPE_SERVERAID:\n\t\t\t\tcase IPS_ADTYPE_SERVERAID2:\n\t\t\t\tcase IPS_ADTYPE_NAVAJO:\n\t\t\t\tcase IPS_ADTYPE_KIOWA:\n\t\t\t\tcase IPS_ADTYPE_SERVERAID3L:\n\t\t\t\tcase IPS_ADTYPE_SERVERAID3:\n\t\t\t\tcase IPS_ADTYPE_SERVERAID4H:\n\t\t\t\t\tif (nvram->adapter_order[i] == 'A') {\n\t\t\t\t\t\tips_shift_controllers(position,\n\t\t\t\t\t\t\t\t      j);\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t \n\t\treturn;\n\t}\n\t \n\ttmp = 0;\n\tfor (i = position; i < ips_num_controllers; i++) {\n\t\tif (ips_ha[i]->ad_type == IPS_ADTYPE_SERVERAID5I2 ||\n\t\t    ips_ha[i]->ad_type == IPS_ADTYPE_SERVERAID5I1) {\n\t\t\tips_shift_controllers(position, i);\n\t\t\tposition++;\n\t\t\ttmp = 1;\n\t\t}\n\t}\n\t \n\tif (!tmp)\n\t\treturn;\n\tfor (i = position; i < ips_num_controllers; i++) {\n\t\tif (ips_ha[i]->ad_type == IPS_ADTYPE_SERVERAID4L ||\n\t\t    ips_ha[i]->ad_type == IPS_ADTYPE_SERVERAID4M ||\n\t\t    ips_ha[i]->ad_type == IPS_ADTYPE_SERVERAID4LX ||\n\t\t    ips_ha[i]->ad_type == IPS_ADTYPE_SERVERAID4MX) {\n\t\t\tips_shift_controllers(position, i);\n\t\t\tposition++;\n\t\t}\n\t}\n\n\treturn;\n}\n\n \n \n \n \n \n \n \nstatic int\nips_register_scsi(int index)\n{\n\tstruct Scsi_Host *sh;\n\tips_ha_t *ha, *oldha = ips_ha[index];\n\tsh = scsi_host_alloc(&ips_driver_template, sizeof (ips_ha_t));\n\tif (!sh) {\n\t\tIPS_PRINTK(KERN_WARNING, oldha->pcidev,\n\t\t\t   \"Unable to register controller with SCSI subsystem\\n\");\n\t\treturn -1;\n\t}\n\tha = IPS_HA(sh);\n\tmemcpy(ha, oldha, sizeof (ips_ha_t));\n\tfree_irq(oldha->pcidev->irq, oldha);\n\t \n\tif (request_irq(ha->pcidev->irq, do_ipsintr, IRQF_SHARED, ips_name, ha)) {\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"Unable to install interrupt handler\\n\");\n\t\tgoto err_out_sh;\n\t}\n\n\tkfree(oldha);\n\n\t \n\tsh->unique_id = (ha->io_addr) ? ha->io_addr : ha->mem_addr;\n\tsh->sg_tablesize = sh->hostt->sg_tablesize;\n\tsh->can_queue = sh->hostt->can_queue;\n\tsh->cmd_per_lun = sh->hostt->cmd_per_lun;\n\tsh->max_sectors = 128;\n\n\tsh->max_id = ha->ntargets;\n\tsh->max_lun = ha->nlun;\n\tsh->max_channel = ha->nbus - 1;\n\tsh->can_queue = ha->max_cmds - 1;\n\n\tif (scsi_add_host(sh, &ha->pcidev->dev))\n\t\tgoto err_out;\n\n\tips_sh[index] = sh;\n\tips_ha[index] = ha;\n\n\tscsi_scan_host(sh);\n\n\treturn 0;\n\nerr_out:\n\tfree_irq(ha->pcidev->irq, ha);\nerr_out_sh:\n\tscsi_host_put(sh);\n\treturn -1;\n}\n\n \n \n \n \n \n \nstatic void\nips_remove_device(struct pci_dev *pci_dev)\n{\n\tstruct Scsi_Host *sh = pci_get_drvdata(pci_dev);\n\n\tpci_set_drvdata(pci_dev, NULL);\n\n\tips_release(sh);\n\n\tpci_release_regions(pci_dev);\n\tpci_disable_device(pci_dev);\n}\n\n \n \n \n \n \n \n \nstatic int __init\nips_module_init(void)\n{\n#if !defined(__i386__) && !defined(__ia64__) && !defined(__x86_64__)\n\tprintk(KERN_ERR \"ips: This driver has only been tested on the x86/ia64/x86_64 platforms\\n\");\n\tadd_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);\n#endif\n\n\tif (pci_register_driver(&ips_pci_driver) < 0)\n\t\treturn -ENODEV;\n\tips_driver_template.module = THIS_MODULE;\n\tips_order_controllers();\n\tif (!ips_detect(&ips_driver_template)) {\n\t\tpci_unregister_driver(&ips_pci_driver);\n\t\treturn -ENODEV;\n\t}\n\tregister_reboot_notifier(&ips_notifier);\n\treturn 0;\n}\n\n \n \n \n \n \n \n \nstatic void __exit\nips_module_exit(void)\n{\n\tpci_unregister_driver(&ips_pci_driver);\n\tunregister_reboot_notifier(&ips_notifier);\n}\n\nmodule_init(ips_module_init);\nmodule_exit(ips_module_exit);\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_insert_device(struct pci_dev *pci_dev, const struct pci_device_id *ent)\n{\n\tint index = -1;\n\tint rc;\n\n\tMETHOD_TRACE(\"ips_insert_device\", 1);\n\trc = pci_enable_device(pci_dev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pci_request_regions(pci_dev, \"ips\");\n\tif (rc)\n\t\tgoto err_out;\n\n\trc = ips_init_phase1(pci_dev, &index);\n\tif (rc == SUCCESS)\n\t\trc = ips_init_phase2(index);\n\n\tif (ips_hotplug)\n\t\tif (ips_register_scsi(index)) {\n\t\t\tips_free(ips_ha[index]);\n\t\t\trc = -1;\n\t\t}\n\n\tif (rc == SUCCESS)\n\t\tips_num_controllers++;\n\n\tips_next_controller = ips_num_controllers;\n\n\tif (rc < 0) {\n\t\trc = -ENODEV;\n\t\tgoto err_out_regions;\n\t}\n\n\tpci_set_drvdata(pci_dev, ips_sh[index]);\n\treturn 0;\n\nerr_out_regions:\n\tpci_release_regions(pci_dev);\nerr_out:\n\tpci_disable_device(pci_dev);\n\treturn rc;\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_init_phase1(struct pci_dev *pci_dev, int *indexPtr)\n{\n\tips_ha_t *ha;\n\tuint32_t io_addr;\n\tuint32_t mem_addr;\n\tuint32_t io_len;\n\tuint32_t mem_len;\n\tint j;\n\tint index;\n\tdma_addr_t dma_address;\n\tchar __iomem *ioremap_ptr;\n\tchar __iomem *mem_ptr;\n\tuint32_t IsDead;\n\n\tMETHOD_TRACE(\"ips_init_phase1\", 1);\n\tindex = IPS_MAX_ADAPTERS;\n\tfor (j = 0; j < IPS_MAX_ADAPTERS; j++) {\n\t\tif (ips_ha[j] == NULL) {\n\t\t\tindex = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (index >= IPS_MAX_ADAPTERS)\n\t\treturn -1;\n\n\t \n\tmem_addr = 0;\n\tio_addr = 0;\n\tmem_len = 0;\n\tio_len = 0;\n\n\tfor (j = 0; j < 2; j++) {\n\t\tif (!pci_resource_start(pci_dev, j))\n\t\t\tbreak;\n\n\t\tif (pci_resource_flags(pci_dev, j) & IORESOURCE_IO) {\n\t\t\tio_addr = pci_resource_start(pci_dev, j);\n\t\t\tio_len = pci_resource_len(pci_dev, j);\n\t\t} else {\n\t\t\tmem_addr = pci_resource_start(pci_dev, j);\n\t\t\tmem_len = pci_resource_len(pci_dev, j);\n\t\t}\n\t}\n\n\t \n\tif (mem_addr) {\n\t\tuint32_t base;\n\t\tuint32_t offs;\n\n\t\tbase = mem_addr & PAGE_MASK;\n\t\toffs = mem_addr - base;\n\t\tioremap_ptr = ioremap(base, PAGE_SIZE);\n\t\tif (!ioremap_ptr)\n\t\t\treturn -1;\n\t\tmem_ptr = ioremap_ptr + offs;\n\t} else {\n\t\tioremap_ptr = NULL;\n\t\tmem_ptr = NULL;\n\t}\n\n\t \n\tha = kzalloc(sizeof (ips_ha_t), GFP_KERNEL);\n\tif (ha == NULL) {\n\t\tIPS_PRINTK(KERN_WARNING, pci_dev,\n\t\t\t   \"Unable to allocate temporary ha struct\\n\");\n\t\treturn -1;\n\t}\n\n\tips_sh[index] = NULL;\n\tips_ha[index] = ha;\n\tha->active = 1;\n\n\t \n\tha->io_addr = io_addr;\n\tha->io_len = io_len;\n\tha->mem_addr = mem_addr;\n\tha->mem_len = mem_len;\n\tha->mem_ptr = mem_ptr;\n\tha->ioremap_ptr = ioremap_ptr;\n\tha->host_num = (uint32_t) index;\n\tha->slot_num = PCI_SLOT(pci_dev->devfn);\n\tha->pcidev = pci_dev;\n\n\t \n\tif (sizeof(dma_addr_t) > 4 && IPS_HAS_ENH_SGLIST(ha) &&\n\t    !dma_set_mask(&ha->pcidev->dev, DMA_BIT_MASK(64))) {\n\t\t(ha)->flags |= IPS_HA_ENH_SG;\n\t} else {\n\t\tif (dma_set_mask(&ha->pcidev->dev, DMA_BIT_MASK(32)) != 0) {\n\t\t\tprintk(KERN_WARNING \"Unable to set DMA Mask\\n\");\n\t\t\treturn ips_abort_init(ha, index);\n\t\t}\n\t}\n\tif(ips_cd_boot && !ips_FlashData){\n\t\tips_FlashData = dma_alloc_coherent(&pci_dev->dev,\n\t\t\t\tPAGE_SIZE << 7, &ips_flashbusaddr, GFP_KERNEL);\n\t}\n\n\tha->enq = dma_alloc_coherent(&pci_dev->dev, sizeof (IPS_ENQ),\n\t\t\t&ha->enq_busaddr, GFP_KERNEL);\n\tif (!ha->enq) {\n\t\tIPS_PRINTK(KERN_WARNING, pci_dev,\n\t\t\t   \"Unable to allocate host inquiry structure\\n\");\n\t\treturn ips_abort_init(ha, index);\n\t}\n\n\tha->adapt = dma_alloc_coherent(&pci_dev->dev,\n\t\t\tsizeof (IPS_ADAPTER) + sizeof (IPS_IO_CMD),\n\t\t\t&dma_address, GFP_KERNEL);\n\tif (!ha->adapt) {\n\t\tIPS_PRINTK(KERN_WARNING, pci_dev,\n\t\t\t   \"Unable to allocate host adapt & dummy structures\\n\");\n\t\treturn ips_abort_init(ha, index);\n\t}\n\tha->adapt->hw_status_start = dma_address;\n\tha->dummy = (void *) (ha->adapt + 1);\n\n\n\n\tha->logical_drive_info = dma_alloc_coherent(&pci_dev->dev,\n\t\t\tsizeof (IPS_LD_INFO), &dma_address, GFP_KERNEL);\n\tif (!ha->logical_drive_info) {\n\t\tIPS_PRINTK(KERN_WARNING, pci_dev,\n\t\t\t   \"Unable to allocate logical drive info structure\\n\");\n\t\treturn ips_abort_init(ha, index);\n\t}\n\tha->logical_drive_info_dma_addr = dma_address;\n\n\n\tha->conf = kmalloc(sizeof (IPS_CONF), GFP_KERNEL);\n\n\tif (!ha->conf) {\n\t\tIPS_PRINTK(KERN_WARNING, pci_dev,\n\t\t\t   \"Unable to allocate host conf structure\\n\");\n\t\treturn ips_abort_init(ha, index);\n\t}\n\n\tha->nvram = kmalloc(sizeof (IPS_NVRAM_P5), GFP_KERNEL);\n\n\tif (!ha->nvram) {\n\t\tIPS_PRINTK(KERN_WARNING, pci_dev,\n\t\t\t   \"Unable to allocate host NVRAM structure\\n\");\n\t\treturn ips_abort_init(ha, index);\n\t}\n\n\tha->subsys = kmalloc(sizeof (IPS_SUBSYS), GFP_KERNEL);\n\n\tif (!ha->subsys) {\n\t\tIPS_PRINTK(KERN_WARNING, pci_dev,\n\t\t\t   \"Unable to allocate host subsystem structure\\n\");\n\t\treturn ips_abort_init(ha, index);\n\t}\n\n\t \n\tif (ips_ioctlsize < PAGE_SIZE)\n\t\tips_ioctlsize = PAGE_SIZE;\n\n\tha->ioctl_data = dma_alloc_coherent(&pci_dev->dev, ips_ioctlsize,\n\t\t\t&ha->ioctl_busaddr, GFP_KERNEL);\n\tha->ioctl_len = ips_ioctlsize;\n\tif (!ha->ioctl_data) {\n\t\tIPS_PRINTK(KERN_WARNING, pci_dev,\n\t\t\t   \"Unable to allocate IOCTL data\\n\");\n\t\treturn ips_abort_init(ha, index);\n\t}\n\n\t \n\tips_setup_funclist(ha);\n\n\tif ((IPS_IS_MORPHEUS(ha)) || (IPS_IS_MARCO(ha))) {\n\t\t \n\t\tIsDead = readl(ha->mem_ptr + IPS_REG_I960_MSG1);\n\t\tif (IsDead == 0xDEADBEEF) {\n\t\t\tips_reset_morpheus(ha);\n\t\t}\n\t}\n\n\t \n\n\tif (!(*ha->func.isinit) (ha)) {\n\t\tif (!(*ha->func.init) (ha)) {\n\t\t\t \n\t\t\tIPS_PRINTK(KERN_WARNING, pci_dev,\n\t\t\t\t   \"Unable to initialize controller\\n\");\n\t\t\treturn ips_abort_init(ha, index);\n\t\t}\n\t}\n\n\t*indexPtr = index;\n\treturn SUCCESS;\n}\n\n \n \n \n \n \n \n \n \n \nstatic int\nips_init_phase2(int index)\n{\n\tips_ha_t *ha;\n\n\tha = ips_ha[index];\n\n\tMETHOD_TRACE(\"ips_init_phase2\", 1);\n\tif (!ha->active) {\n\t\tips_ha[index] = NULL;\n\t\treturn -1;\n\t}\n\n\t \n\tif (request_irq(ha->pcidev->irq, do_ipsintr, IRQF_SHARED, ips_name, ha)) {\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"Unable to install interrupt handler\\n\");\n\t\treturn ips_abort_init(ha, index);\n\t}\n\n\t \n\tha->max_cmds = 1;\n\tif (!ips_allocatescbs(ha)) {\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"Unable to allocate a CCB\\n\");\n\t\tfree_irq(ha->pcidev->irq, ha);\n\t\treturn ips_abort_init(ha, index);\n\t}\n\n\tif (!ips_hainit(ha)) {\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"Unable to initialize controller\\n\");\n\t\tfree_irq(ha->pcidev->irq, ha);\n\t\treturn ips_abort_init(ha, index);\n\t}\n\t \n\tips_deallocatescbs(ha, 1);\n\n\t \n\tif (!ips_allocatescbs(ha)) {\n\t\tIPS_PRINTK(KERN_WARNING, ha->pcidev,\n\t\t\t   \"Unable to allocate CCBs\\n\");\n\t\tfree_irq(ha->pcidev->irq, ha);\n\t\treturn ips_abort_init(ha, index);\n\t}\n\n\treturn SUCCESS;\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"IBM ServeRAID Adapter Driver \" IPS_VER_STRING);\nMODULE_VERSION(IPS_VER_STRING);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}