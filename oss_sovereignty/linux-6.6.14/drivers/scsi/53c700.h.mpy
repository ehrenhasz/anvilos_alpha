{
  "module_name": "53c700.h",
  "hash_id": "a3e239d606cf8e93d9c7ca7b434690214b29091b5c2ac3b64cceb79cd0a7ee8f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/53c700.h",
  "human_readable_source": " \n\n \n\n#ifndef _53C700_H\n#define _53C700_H\n\n#include <linux/interrupt.h>\n#include <asm/io.h>\n\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n\n \n#undef\tNCR_700_DEBUG\n \n#undef NCR_700_TAG_DEBUG\n\n#ifdef NCR_700_DEBUG\n#define DEBUG(x)\tprintk x\n#define DDEBUG(prefix, sdev, fmt, a...) \\\n\tsdev_printk(prefix, sdev, fmt, ##a)\n#define CDEBUG(prefix, scmd, fmt, a...) \\\n\tscmd_printk(prefix, scmd, fmt, ##a)\n#else\n#define DEBUG(x)\tdo {} while (0)\n#define DDEBUG(prefix, scmd, fmt, a...) do {} while (0)\n#define CDEBUG(prefix, scmd, fmt, a...) do {} while (0)\n#endif\n\n \n#define NCR_700_COMMAND_SLOTS_PER_HOST\t64\n \n#define NCR_700_SG_SEGMENTS\t\t32\n \n#define NCR_700_MAX_LUNS\t\t32\n#define NCR_700_LUN_MASK\t\t(NCR_700_MAX_LUNS - 1)\n \n#define NCR_700_MAX_TAGS\t\t16\n \n#define NCR_700_DEFAULT_TAGS\t\t4\n \n#define NCR_700_CMD_PER_LUN\t\t2\n \n#define NCR_700_INTERNAL_SENSE_MAGIC\t0x42\n\nstruct NCR_700_Host_Parameters;\n\n \nstruct Scsi_Host *NCR_700_detect(struct scsi_host_template *,\n\t\tstruct NCR_700_Host_Parameters *, struct device *);\nint NCR_700_release(struct Scsi_Host *host);\nirqreturn_t NCR_700_intr(int, void *);\n\n\nenum NCR_700_Host_State {\n\tNCR_700_HOST_BUSY,\n\tNCR_700_HOST_FREE,\n};\n\nstruct NCR_700_SG_List {\n\t \n\t#define\tSCRIPT_MOVE_DATA_IN\t\t0x09000000\n\t#define\tSCRIPT_MOVE_DATA_OUT\t\t0x08000000\n\t__u32\tins;\n\t__u32\tpAddr;\n\t#define\tSCRIPT_NOP\t\t\t0x80000000\n\t#define\tSCRIPT_RETURN\t\t\t0x90080000\n};\n\nstruct NCR_700_Device_Parameters {\n\t \n\tunsigned char cmnd[MAX_COMMAND_SIZE];\n\t__u8\tdepth;\n\tstruct scsi_cmnd *current_cmnd;\t \n};\n\n\n \n#define NCR_700_DEV_NEGOTIATED_SYNC\t(1<<16)\n#define NCR_700_DEV_BEGIN_SYNC_NEGOTIATION\t(1<<17)\n#define NCR_700_DEV_PRINT_SYNC_NEGOTIATION (1<<19)\n\nstatic inline char *NCR_700_get_sense_cmnd(struct scsi_device *SDp)\n{\n\tstruct NCR_700_Device_Parameters *hostdata = SDp->hostdata;\n\n\treturn hostdata->cmnd;\n}\n\nstatic inline void\nNCR_700_set_depth(struct scsi_device *SDp, __u8 depth)\n{\n\tstruct NCR_700_Device_Parameters *hostdata = SDp->hostdata;\n\n\thostdata->depth = depth;\n}\nstatic inline __u8\nNCR_700_get_depth(struct scsi_device *SDp)\n{\n\tstruct NCR_700_Device_Parameters *hostdata = SDp->hostdata;\n\n\treturn hostdata->depth;\n}\nstatic inline int\nNCR_700_is_flag_set(struct scsi_device *SDp, __u32 flag)\n{\n\treturn (spi_flags(SDp->sdev_target) & flag) == flag;\n}\nstatic inline int\nNCR_700_is_flag_clear(struct scsi_device *SDp, __u32 flag)\n{\n\treturn (spi_flags(SDp->sdev_target) & flag) == 0;\n}\nstatic inline void\nNCR_700_set_flag(struct scsi_device *SDp, __u32 flag)\n{\n\tspi_flags(SDp->sdev_target) |= flag;\n}\nstatic inline void\nNCR_700_clear_flag(struct scsi_device *SDp, __u32 flag)\n{\n\tspi_flags(SDp->sdev_target) &= ~flag;\n}\n\nenum NCR_700_tag_neg_state {\n\tNCR_700_START_TAG_NEGOTIATION = 0,\n\tNCR_700_DURING_TAG_NEGOTIATION = 1,\n\tNCR_700_FINISHED_TAG_NEGOTIATION = 2,\n};\n\nstatic inline enum NCR_700_tag_neg_state\nNCR_700_get_tag_neg_state(struct scsi_device *SDp)\n{\n\treturn (enum NCR_700_tag_neg_state)((spi_flags(SDp->sdev_target)>>20) & 0x3);\n}\n\nstatic inline void\nNCR_700_set_tag_neg_state(struct scsi_device *SDp,\n\t\t\t  enum NCR_700_tag_neg_state state)\n{\n\t \n\tspi_flags(SDp->sdev_target) &= ~(0x3 << 20);\n\tspi_flags(SDp->sdev_target) |= ((__u32)state) << 20;\n}\n\nstruct NCR_700_command_slot {\n\tstruct NCR_700_SG_List\tSG[NCR_700_SG_SEGMENTS+1];\n\tstruct NCR_700_SG_List\t*pSG;\n\t#define NCR_700_SLOT_MASK 0xFC\n\t#define NCR_700_SLOT_MAGIC 0xb8\n\t#define\tNCR_700_SLOT_FREE (0|NCR_700_SLOT_MAGIC)  \n\t#define NCR_700_SLOT_BUSY (1|NCR_700_SLOT_MAGIC)  \n\t#define NCR_700_SLOT_QUEUED (2|NCR_700_SLOT_MAGIC)  \n\t__u8\tstate;\n\t#define NCR_700_FLAG_AUTOSENSE\t0x01\n\t__u8\tflags;\n\t__u8\tpad1[2];\t \n\tint\ttag;\n\t__u32\tresume_offset;\n\tstruct scsi_cmnd *cmnd;\n\t \n\tdma_addr_t\tpCmd;\n\t__u32\t\ttemp;\n\t \n\tdma_addr_t\tdma_handle;\n\t \n\tstruct NCR_700_command_slot *ITL_forw;\n};\n\nstruct NCR_700_Host_Parameters {\n\t \n\tint\tclock;\t\t\t \n\tvoid __iomem\t*base;\t\t \n\tstruct device\t*dev;\n\t__u32\tdmode_extra;\t \n\t__u32\tdcntl_extra;\t \n\t__u32\tctest7_extra;\t \n\t__u32\tdifferential:1;\t \n#ifdef CONFIG_53C700_LE_ON_BE\n\t \n\t__u32\tforce_le_on_be:1;\n#endif\n\t__u32\tchip710:1;\t \n\t__u32\tburst_length:4;\t \n\t__u32\tnoncoherent:1;\t \n\n\t \n\t__u32\tfast:1;\t\t \n\tint\tsync_clock;\t \n\n\t__u32\t*script;\t\t \n\t__u32\tpScript;\t\t \n\n\tenum NCR_700_Host_State state;  \n\tstruct scsi_cmnd *cmd;\n\t \n#define\tMSG_ARRAY_SIZE\t8\n#define\tMSGOUT_OFFSET\t(L1_CACHE_ALIGN(sizeof(SCRIPT)))\n\t__u8\t*msgout;\n#define MSGIN_OFFSET\t(MSGOUT_OFFSET + L1_CACHE_ALIGN(MSG_ARRAY_SIZE))\n\t__u8\t*msgin;\n#define STATUS_OFFSET\t(MSGIN_OFFSET + L1_CACHE_ALIGN(MSG_ARRAY_SIZE))\n\t__u8\t*status;\n#define SLOTS_OFFSET\t(STATUS_OFFSET + L1_CACHE_ALIGN(MSG_ARRAY_SIZE))\n\tstruct NCR_700_command_slot\t*slots;\n#define\tTOTAL_MEM_SIZE\t(SLOTS_OFFSET + L1_CACHE_ALIGN(sizeof(struct NCR_700_command_slot) * NCR_700_COMMAND_SLOTS_PER_HOST))\n\tint\tsaved_slot_position;\n\tint\tcommand_slot_count;  \n\t__u8\ttag_negotiated;\n\t__u8\trev;\n\t__u8\treselection_id;\n\t__u8\tmin_period;\n\n\t \n\tstruct NCR_700_command_slot *free_list;\n\t \n\tstruct completion *eh_complete;\n};\n\n \n#ifdef CONFIG_53C700_LE_ON_BE\n#define bE\t(hostdata->force_le_on_be ? 0 : 3)\n#define\tbSWAP\t(hostdata->force_le_on_be)\n#define bEBus\t(!hostdata->force_le_on_be)\n#elif defined(__BIG_ENDIAN)\n#define bE\t3\n#define bSWAP\t0\n#elif defined(__LITTLE_ENDIAN)\n#define bE\t0\n#define bSWAP\t0\n#else\n#error \"__BIG_ENDIAN or __LITTLE_ENDIAN must be defined, did you include byteorder.h?\"\n#endif\n#ifndef bEBus\n#ifdef CONFIG_53C700_BE_BUS\n#define bEBus\t1\n#else\n#define bEBus\t0\n#endif\n#endif\n#define bS_to_cpu(x)\t(bSWAP ? le32_to_cpu(x) : (x))\n#define bS_to_host(x)\t(bSWAP ? cpu_to_le32(x) : (x))\n\n \n#define\tSCNTL0_REG\t\t\t0x00\n#define\t\tFULL_ARBITRATION\t0xc0\n#define \tPARITY\t\t\t0x08\n#define\t\tENABLE_PARITY\t\t0x04\n#define \tAUTO_ATN\t\t0x02\n#define\tSCNTL1_REG\t\t\t0x01\n#define \tSLOW_BUS\t\t0x80\n#define\t\tENABLE_SELECT\t\t0x20\n#define\t\tASSERT_RST\t\t0x08\n#define\t\tASSERT_EVEN_PARITY\t0x04\n#define\tSDID_REG\t\t\t0x02\n#define\tSIEN_REG\t\t\t0x03\n#define \tPHASE_MM_INT\t\t0x80\n#define \tFUNC_COMP_INT\t\t0x40\n#define \tSEL_TIMEOUT_INT\t\t0x20\n#define \tSELECT_INT\t\t0x10\n#define \tGROSS_ERR_INT\t\t0x08\n#define \tUX_DISC_INT\t\t0x04\n#define \tRST_INT\t\t\t0x02\n#define \tPAR_ERR_INT\t\t0x01\n#define\tSCID_REG\t\t\t0x04\n#define SXFER_REG\t\t\t0x05\n#define\t\tASYNC_OPERATION\t\t0x00\n#define SODL_REG                        0x06\n#define\tSOCL_REG\t\t\t0x07\n#define\tSFBR_REG\t\t\t0x08\n#define\tSIDL_REG\t\t\t0x09\n#define\tSBDL_REG\t\t\t0x0A\n#define\tSBCL_REG\t\t\t0x0B\n \n#define\t\tSBCL_IO\t\t\t0x01\n \n#define\t\tSYNC_DIV_AS_ASYNC\t0x00\n#define\t\tSYNC_DIV_1_0\t\t0x01\n#define\t\tSYNC_DIV_1_5\t\t0x02\n#define\t\tSYNC_DIV_2_0\t\t0x03\n#define\tDSTAT_REG\t\t\t0x0C\n#define\t\tILGL_INST_DETECTED\t0x01\n#define\t\tWATCH_DOG_INTERRUPT\t0x02\n#define\t\tSCRIPT_INT_RECEIVED\t0x04\n#define\t\tABORTED\t\t\t0x10\n#define\tSSTAT0_REG\t\t\t0x0D\n#define\t\tPARITY_ERROR\t\t0x01\n#define\t\tSCSI_RESET_DETECTED\t0x02\n#define\t\tUNEXPECTED_DISCONNECT\t0x04\n#define\t\tSCSI_GROSS_ERROR\t0x08\n#define\t\tSELECTED\t\t0x10\n#define\t\tSELECTION_TIMEOUT\t0x20\n#define\t\tFUNCTION_COMPLETE\t0x40\n#define\t\tPHASE_MISMATCH \t\t0x80\n#define\tSSTAT1_REG\t\t\t0x0E\n#define\t\tSIDL_REG_FULL\t\t0x80\n#define\t\tSODR_REG_FULL\t\t0x40\n#define\t\tSODL_REG_FULL\t\t0x20\n#define SSTAT2_REG                      0x0F\n#define CTEST0_REG                      0x14\n#define\t\tBTB_TIMER_DISABLE\t0x40\n#define CTEST1_REG                      0x15\n#define CTEST2_REG                      0x16\n#define CTEST3_REG                      0x17\n#define CTEST4_REG                      0x18\n#define         DISABLE_FIFO            0x00\n#define         SLBE                    0x10\n#define         SFWR                    0x08\n#define         BYTE_LANE0              0x04\n#define         BYTE_LANE1              0x05\n#define         BYTE_LANE2              0x06\n#define         BYTE_LANE3              0x07\n#define         SCSI_ZMODE              0x20\n#define         ZMODE                   0x40\n#define CTEST5_REG                      0x19\n#define         MASTER_CONTROL          0x10\n#define         DMA_DIRECTION           0x08\n#define CTEST7_REG                      0x1B\n#define\t\tBURST_DISABLE\t\t0x80  \n#define\t\tSEL_TIMEOUT_DISABLE\t0x10  \n#define         DFP                     0x08\n#define         EVP                     0x04\n#define         CTEST7_TT1              0x02\n#define\t\tDIFF\t\t\t0x01\n#define CTEST6_REG                      0x1A\n#define\tTEMP_REG\t\t\t0x1C\n#define\tDFIFO_REG\t\t\t0x20\n#define\t\tFLUSH_DMA_FIFO\t\t0x80\n#define\t\tCLR_FIFO\t\t0x40\n#define\tISTAT_REG\t\t\t0x21\n#define\t\tABORT_OPERATION\t\t0x80\n#define\t\tSOFTWARE_RESET_710\t0x40\n#define\t\tDMA_INT_PENDING\t\t0x01\n#define\t\tSCSI_INT_PENDING\t0x02\n#define\t\tCONNECTED\t\t0x08\n#define CTEST8_REG                      0x22\n#define         LAST_DIS_ENBL           0x01\n#define\t\tSHORTEN_FILTERING\t0x04\n#define\t\tENABLE_ACTIVE_NEGATION\t0x10\n#define\t\tGENERATE_RECEIVE_PARITY\t0x20\n#define\t\tCLR_FIFO_710\t\t0x04\n#define\t\tFLUSH_DMA_FIFO_710\t0x08\n#define CTEST9_REG                      0x23\n#define\tDBC_REG\t\t\t\t0x24\n#define\tDCMD_REG\t\t\t0x27\n#define\tDNAD_REG\t\t\t0x28\n#define\tDIEN_REG\t\t\t0x39\n#define\t\tBUS_FAULT\t\t0x20\n#define \tABORT_INT\t\t0x10\n#define \tINT_INST_INT\t\t0x04\n#define \tWD_INT\t\t\t0x02\n#define \tILGL_INST_INT\t\t0x01\n#define\tDCNTL_REG\t\t\t0x3B\n#define\t\tSOFTWARE_RESET\t\t0x01\n#define\t\tCOMPAT_700_MODE\t\t0x01\n#define \tSCRPTS_16BITS\t\t0x20\n#define\t\tEA_710\t\t\t0x20\n#define\t\tASYNC_DIV_2_0\t\t0x00\n#define\t\tASYNC_DIV_1_5\t\t0x40\n#define\t\tASYNC_DIV_1_0\t\t0x80\n#define\t\tASYNC_DIV_3_0\t\t0xc0\n#define DMODE_710_REG\t\t\t0x38\n#define\tDMODE_700_REG\t\t\t0x34\n#define\t\tBURST_LENGTH_1\t\t0x00\n#define\t\tBURST_LENGTH_2\t\t0x40\n#define\t\tBURST_LENGTH_4\t\t0x80\n#define\t\tBURST_LENGTH_8\t\t0xC0\n#define\t\tDMODE_FC1\t\t0x10\n#define\t\tDMODE_FC2\t\t0x20\n#define \tBW16\t\t\t32 \n#define \tMODE_286\t\t16\n#define \tIO_XFER\t\t\t8\n#define \tFIXED_ADDR\t\t4\n\n#define DSP_REG                         0x2C\n#define DSPS_REG                        0x30\n\n \n#define NCR_700_MAX_OFFSET\t8\n \n#define NCR_710_MAX_OFFSET\t8\n#define NCR_700_MIN_XFERP\t1\n#define NCR_710_MIN_XFERP\t0\n#define NCR_700_MIN_PERIOD\t25  \n\n#define script_patch_32(h, script, symbol, value) \\\n{ \\\n\tint i; \\\n\tdma_addr_t da = value; \\\n\tfor(i=0; i< (sizeof(A_##symbol##_used) / sizeof(__u32)); i++) { \\\n\t\t__u32 val = bS_to_cpu((script)[A_##symbol##_used[i]]) + da; \\\n\t\t(script)[A_##symbol##_used[i]] = bS_to_host(val); \\\n\t\tdma_sync_to_dev((h), &(script)[A_##symbol##_used[i]], 4); \\\n\t\tDEBUG((\" script, patching %s at %d to %pad\\n\", \\\n\t\t       #symbol, A_##symbol##_used[i], &da)); \\\n\t} \\\n}\n\n#define script_patch_32_abs(h, script, symbol, value) \\\n{ \\\n\tint i; \\\n\tdma_addr_t da = value; \\\n\tfor(i=0; i< (sizeof(A_##symbol##_used) / sizeof(__u32)); i++) { \\\n\t\t(script)[A_##symbol##_used[i]] = bS_to_host(da); \\\n\t\tdma_sync_to_dev((h), &(script)[A_##symbol##_used[i]], 4); \\\n\t\tDEBUG((\" script, patching %s at %d to %pad\\n\", \\\n\t\t       #symbol, A_##symbol##_used[i], &da)); \\\n\t} \\\n}\n\n \n#define script_patch_ID(h, script, symbol, value) \\\n{ \\\n\tint i; \\\n\tfor(i=0; i< (sizeof(A_##symbol##_used) / sizeof(__u32)); i++) { \\\n\t\t__u32 val = bS_to_cpu((script)[A_##symbol##_used[i]]); \\\n\t\tval &= 0xff00ffff; \\\n\t\tval |= ((value) & 0xff) << 16; \\\n\t\t(script)[A_##symbol##_used[i]] = bS_to_host(val); \\\n\t\tdma_sync_to_dev((h), &(script)[A_##symbol##_used[i]], 4); \\\n\t\tDEBUG((\" script, patching ID field %s at %d to 0x%x\\n\", \\\n\t\t       #symbol, A_##symbol##_used[i], val)); \\\n\t} \\\n}\n\n#define script_patch_16(h, script, symbol, value) \\\n{ \\\n\tint i; \\\n\tfor(i=0; i< (sizeof(A_##symbol##_used) / sizeof(__u32)); i++) { \\\n\t\t__u32 val = bS_to_cpu((script)[A_##symbol##_used[i]]); \\\n\t\tval &= 0xffff0000; \\\n\t\tval |= ((value) & 0xffff); \\\n\t\t(script)[A_##symbol##_used[i]] = bS_to_host(val); \\\n\t\tdma_sync_to_dev((h), &(script)[A_##symbol##_used[i]], 4); \\\n\t\tDEBUG((\" script, patching short field %s at %d to 0x%x\\n\", \\\n\t\t       #symbol, A_##symbol##_used[i], val)); \\\n\t} \\\n}\n\n\nstatic inline __u8\nNCR_700_readb(struct Scsi_Host *host, __u32 reg)\n{\n\tconst struct NCR_700_Host_Parameters *hostdata\n\t\t= (struct NCR_700_Host_Parameters *)host->hostdata[0];\n\n\treturn ioread8(hostdata->base + (reg^bE));\n}\n\nstatic inline __u32\nNCR_700_readl(struct Scsi_Host *host, __u32 reg)\n{\n\tconst struct NCR_700_Host_Parameters *hostdata\n\t\t= (struct NCR_700_Host_Parameters *)host->hostdata[0];\n\t__u32 value = bEBus ? ioread32be(hostdata->base + reg) :\n\t\tioread32(hostdata->base + reg);\n#if 1\n\t \n\tBUG_ON((reg & 0x3) != 0);\n#endif\n\n\treturn value;\n}\n\nstatic inline void\nNCR_700_writeb(__u8 value, struct Scsi_Host *host, __u32 reg)\n{\n\tconst struct NCR_700_Host_Parameters *hostdata\n\t\t= (struct NCR_700_Host_Parameters *)host->hostdata[0];\n\n\tiowrite8(value, hostdata->base + (reg^bE));\n}\n\nstatic inline void\nNCR_700_writel(__u32 value, struct Scsi_Host *host, __u32 reg)\n{\n\tconst struct NCR_700_Host_Parameters *hostdata\n\t\t= (struct NCR_700_Host_Parameters *)host->hostdata[0];\n\n#if 1\n\t \n\tBUG_ON((reg & 0x3) != 0);\n#endif\n\n\tbEBus ? iowrite32be(value, hostdata->base + reg): \n\t\tiowrite32(value, hostdata->base + reg);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}