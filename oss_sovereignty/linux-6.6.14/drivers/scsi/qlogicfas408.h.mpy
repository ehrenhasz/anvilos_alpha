{
  "module_name": "qlogicfas408.h",
  "hash_id": "24b6a5bbaf820fd70c01550efb6bb836bdd62d3088ed3673122965390fdccc7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qlogicfas408.h",
  "human_readable_source": " \n \n#ifndef __QLOGICFAS408_H\n#define __QLOGICFAS408_H\n\n \n \n\n \n\n#define QL_TURBO_PDMA 1\n\n \n\n#define QL_ENABLE_PARITY 1\n\n \n\n#define QL_RESET_AT_START 0\n\n \n\n#define XTALFREQ\t40\n\n \n \n \n \n\n \n \n \n#define SLOWCABLE 1\n\n \n \n \n#define FASTSCSI 0\n\n \n#define FASTCLK 0\t \n\n \n \n \n#define SYNCXFRPD 5\t \n\n \n \n \n#define SYNCOFFST 0\n \n\n \n\nstruct qlogicfas408_priv {\n\tint qbase;\t\t \n\tint qinitid;\t\t \n\tint qabort;\t\t \n\tint qlirq;\t\t \n\tint int_type;\t\t \n\tchar qinfo[80];\t\t \n\tstruct scsi_cmnd *qlcmd;\t \n\tstruct Scsi_Host *shost;\t \n\tstruct qlogicfas408_priv *next;  \n};\n\n \n#define REG0 ( outb( inb( qbase + 0xd ) & 0x7f , qbase + 0xd ), outb( 4 , qbase + 0xd ))\n#define REG1 ( outb( inb( qbase + 0xd ) | 0x80 , qbase + 0xd ), outb( 0xb4 | int_type, qbase + 0xd ))\n\n \n#define WATCHDOG 5000000\n\n \n \n\n#define rtrc(i) {}\n\n#define get_priv_by_cmd(x) (struct qlogicfas408_priv *)&((x)->device->host->hostdata[0])\n#define get_priv_by_host(x) (struct qlogicfas408_priv *)&((x)->hostdata[0])\n\nirqreturn_t qlogicfas408_ihandl(int irq, void *dev_id);\nint qlogicfas408_queuecommand(struct Scsi_Host *h, struct scsi_cmnd * cmd);\nint qlogicfas408_biosparam(struct scsi_device * disk,\n\t\t\t   struct block_device *dev,\n\t\t\t   sector_t capacity, int ip[]);\nint qlogicfas408_abort(struct scsi_cmnd * cmd);\nextern int qlogicfas408_host_reset(struct scsi_cmnd *cmd);\nconst char *qlogicfas408_info(struct Scsi_Host *host);\nint qlogicfas408_get_chip_type(int qbase, int int_type);\nvoid qlogicfas408_setup(int qbase, int id, int int_type);\nint qlogicfas408_detect(int qbase, int int_type);\nvoid qlogicfas408_disable_ints(struct qlogicfas408_priv *priv);\n#endif\t \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}