{
  "module_name": "scsi_transport_fc.c",
  "hash_id": "270b2c84f79e148806500a661e357ce5613bbcf6548d38476fb0667867fd7bab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_transport_fc.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/bsg-lib.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/scsi_cmnd.h>\n#include <net/netlink.h>\n#include <scsi/scsi_netlink_fc.h>\n#include <scsi/scsi_bsg_fc.h>\n#include <uapi/scsi/fc/fc_els.h>\n#include \"scsi_priv.h\"\n\nstatic int fc_queue_work(struct Scsi_Host *, struct work_struct *);\nstatic void fc_vport_sched_delete(struct work_struct *work);\nstatic int fc_vport_setup(struct Scsi_Host *shost, int channel,\n\tstruct device *pdev, struct fc_vport_identifiers  *ids,\n\tstruct fc_vport **vport);\nstatic int fc_bsg_hostadd(struct Scsi_Host *, struct fc_host_attrs *);\nstatic int fc_bsg_rportadd(struct Scsi_Host *, struct fc_rport *);\nstatic void fc_bsg_remove(struct request_queue *);\nstatic void fc_bsg_goose_queue(struct fc_rport *);\nstatic void fc_li_stats_update(u16 event_type,\n\t\t\t       struct fc_fpin_stats *stats);\nstatic void fc_delivery_stats_update(u32 reason_code,\n\t\t\t\t     struct fc_fpin_stats *stats);\nstatic void fc_cn_stats_update(u16 event_type, struct fc_fpin_stats *stats);\n\n \n\n \nstatic unsigned int fc_dev_loss_tmo = 60;\t\t \n\nmodule_param_named(dev_loss_tmo, fc_dev_loss_tmo, uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(dev_loss_tmo,\n\t\t \"Maximum number of seconds that the FC transport should\"\n\t\t \" insulate the loss of a remote port. Once this value is\"\n\t\t \" exceeded, the scsi target is removed. Value should be\"\n\t\t \" between 1 and SCSI_DEVICE_BLOCK_MAX_TIMEOUT if\"\n\t\t \" fast_io_fail_tmo is not set.\");\n\n \n#define FC_DEVICE_ATTR(_prefix,_name,_mode,_show,_store)\t\t\\\nstruct device_attribute device_attr_##_prefix##_##_name = \t\\\n\t__ATTR(_name,_mode,_show,_store)\n\n#define fc_enum_name_search(title, table_type, table)\t\t\t\\\nstatic const char *get_fc_##title##_name(enum table_type table_key)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\t\\\n\tchar *name = NULL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < ARRAY_SIZE(table); i++) {\t\t\t\\\n\t\tif (table[i].value == table_key) {\t\t\t\\\n\t\t\tname = table[i].name;\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn name;\t\t\t\t\t\t\t\\\n}\n\n#define fc_enum_name_match(title, table_type, table)\t\t\t\\\nstatic int get_fc_##title##_match(const char *table_key,\t\t\\\n\t\tenum table_type *value)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < ARRAY_SIZE(table); i++) {\t\t\t\\\n\t\tif (strncmp(table_key, table[i].name,\t\t\t\\\n\t\t\t\ttable[i].matchlen) == 0) {\t\t\\\n\t\t\t*value = table[i].value;\t\t\t\\\n\t\t\treturn 0;  \t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn 1;  \t\t\t\t\t\t\\\n}\n\n\n \nstatic struct {\n\tenum fc_port_type\tvalue;\n\tchar\t\t\t*name;\n} fc_port_type_names[] = {\n\t{ FC_PORTTYPE_UNKNOWN,\t\t\"Unknown\" },\n\t{ FC_PORTTYPE_OTHER,\t\t\"Other\" },\n\t{ FC_PORTTYPE_NOTPRESENT,\t\"Not Present\" },\n\t{ FC_PORTTYPE_NPORT,\t\"NPort (fabric via point-to-point)\" },\n\t{ FC_PORTTYPE_NLPORT,\t\"NLPort (fabric via loop)\" },\n\t{ FC_PORTTYPE_LPORT,\t\"LPort (private loop)\" },\n\t{ FC_PORTTYPE_PTP,\t\"Point-To-Point (direct nport connection)\" },\n\t{ FC_PORTTYPE_NPIV,\t\t\"NPIV VPORT\" },\n};\nfc_enum_name_search(port_type, fc_port_type, fc_port_type_names)\n#define FC_PORTTYPE_MAX_NAMELEN\t\t50\n\n \n#define get_fc_vport_type_name get_fc_port_type_name\n\n\n \nstatic const struct {\n\tenum fc_host_event_code\t\tvalue;\n\tchar\t\t\t\t*name;\n} fc_host_event_code_names[] = {\n\t{ FCH_EVT_LIP,\t\t\t\"lip\" },\n\t{ FCH_EVT_LINKUP,\t\t\"link_up\" },\n\t{ FCH_EVT_LINKDOWN,\t\t\"link_down\" },\n\t{ FCH_EVT_LIPRESET,\t\t\"lip_reset\" },\n\t{ FCH_EVT_RSCN,\t\t\t\"rscn\" },\n\t{ FCH_EVT_ADAPTER_CHANGE,\t\"adapter_chg\" },\n\t{ FCH_EVT_PORT_UNKNOWN,\t\t\"port_unknown\" },\n\t{ FCH_EVT_PORT_ONLINE,\t\t\"port_online\" },\n\t{ FCH_EVT_PORT_OFFLINE,\t\t\"port_offline\" },\n\t{ FCH_EVT_PORT_FABRIC,\t\t\"port_fabric\" },\n\t{ FCH_EVT_LINK_UNKNOWN,\t\t\"link_unknown\" },\n\t{ FCH_EVT_LINK_FPIN,\t\t\"link_FPIN\" },\n\t{ FCH_EVT_LINK_FPIN_ACK,\t\"link_FPIN_ACK\" },\n\t{ FCH_EVT_VENDOR_UNIQUE,\t\"vendor_unique\" },\n};\nfc_enum_name_search(host_event_code, fc_host_event_code,\n\t\tfc_host_event_code_names)\n#define FC_HOST_EVENT_CODE_MAX_NAMELEN\t30\n\n\n \nstatic struct {\n\tenum fc_port_state\tvalue;\n\tchar\t\t\t*name;\n\tint\t\t\tmatchlen;\n} fc_port_state_names[] = {\n\t{ FC_PORTSTATE_UNKNOWN,\t\t\"Unknown\", 7},\n\t{ FC_PORTSTATE_NOTPRESENT,\t\"Not Present\", 11 },\n\t{ FC_PORTSTATE_ONLINE,\t\t\"Online\", 6 },\n\t{ FC_PORTSTATE_OFFLINE,\t\t\"Offline\", 7 },\n\t{ FC_PORTSTATE_BLOCKED,\t\t\"Blocked\", 7 },\n\t{ FC_PORTSTATE_BYPASSED,\t\"Bypassed\", 8 },\n\t{ FC_PORTSTATE_DIAGNOSTICS,\t\"Diagnostics\", 11 },\n\t{ FC_PORTSTATE_LINKDOWN,\t\"Linkdown\", 8 },\n\t{ FC_PORTSTATE_ERROR,\t\t\"Error\", 5 },\n\t{ FC_PORTSTATE_LOOPBACK,\t\"Loopback\", 8 },\n\t{ FC_PORTSTATE_DELETED,\t\t\"Deleted\", 7 },\n\t{ FC_PORTSTATE_MARGINAL,\t\"Marginal\", 8 },\n};\nfc_enum_name_search(port_state, fc_port_state, fc_port_state_names)\nfc_enum_name_match(port_state, fc_port_state, fc_port_state_names)\n#define FC_PORTSTATE_MAX_NAMELEN\t20\n\n\n \nstatic struct {\n\tenum fc_vport_state\tvalue;\n\tchar\t\t\t*name;\n} fc_vport_state_names[] = {\n\t{ FC_VPORT_UNKNOWN,\t\t\"Unknown\" },\n\t{ FC_VPORT_ACTIVE,\t\t\"Active\" },\n\t{ FC_VPORT_DISABLED,\t\t\"Disabled\" },\n\t{ FC_VPORT_LINKDOWN,\t\t\"Linkdown\" },\n\t{ FC_VPORT_INITIALIZING,\t\"Initializing\" },\n\t{ FC_VPORT_NO_FABRIC_SUPP,\t\"No Fabric Support\" },\n\t{ FC_VPORT_NO_FABRIC_RSCS,\t\"No Fabric Resources\" },\n\t{ FC_VPORT_FABRIC_LOGOUT,\t\"Fabric Logout\" },\n\t{ FC_VPORT_FABRIC_REJ_WWN,\t\"Fabric Rejected WWN\" },\n\t{ FC_VPORT_FAILED,\t\t\"VPort Failed\" },\n};\nfc_enum_name_search(vport_state, fc_vport_state, fc_vport_state_names)\n#define FC_VPORTSTATE_MAX_NAMELEN\t24\n\n \n#define get_fc_vport_last_state_name get_fc_vport_state_name\n\n\n \nstatic const struct {\n\tenum fc_tgtid_binding_type\tvalue;\n\tchar\t\t\t\t*name;\n\tint\t\t\t\tmatchlen;\n} fc_tgtid_binding_type_names[] = {\n\t{ FC_TGTID_BIND_NONE, \"none\", 4 },\n\t{ FC_TGTID_BIND_BY_WWPN, \"wwpn (World Wide Port Name)\", 4 },\n\t{ FC_TGTID_BIND_BY_WWNN, \"wwnn (World Wide Node Name)\", 4 },\n\t{ FC_TGTID_BIND_BY_ID, \"port_id (FC Address)\", 7 },\n};\nfc_enum_name_search(tgtid_bind_type, fc_tgtid_binding_type,\n\t\tfc_tgtid_binding_type_names)\nfc_enum_name_match(tgtid_bind_type, fc_tgtid_binding_type,\n\t\tfc_tgtid_binding_type_names)\n#define FC_BINDTYPE_MAX_NAMELEN\t30\n\n\n#define fc_bitfield_name_search(title, table)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\\\nget_fc_##title##_names(u32 table_key, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tchar *prefix = \"\";\t\t\t\t\t\\\n\tssize_t len = 0;\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < ARRAY_SIZE(table); i++) {\t\t\\\n\t\tif (table[i].value & table_key) {\t\t\\\n\t\t\tlen += sprintf(buf + len, \"%s%s\",\t\\\n\t\t\t\tprefix, table[i].name);\t\t\\\n\t\t\tprefix = \", \";\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tlen += sprintf(buf + len, \"\\n\");\t\t\t\\\n\treturn len;\t\t\t\t\t\t\\\n}\n\n\n \nstatic const struct {\n\tu32 \t\t\tvalue;\n\tchar\t\t\t*name;\n} fc_cos_names[] = {\n\t{ FC_COS_CLASS1,\t\"Class 1\" },\n\t{ FC_COS_CLASS2,\t\"Class 2\" },\n\t{ FC_COS_CLASS3,\t\"Class 3\" },\n\t{ FC_COS_CLASS4,\t\"Class 4\" },\n\t{ FC_COS_CLASS6,\t\"Class 6\" },\n};\nfc_bitfield_name_search(cos, fc_cos_names)\n\n\n \nstatic const struct {\n\tu32 \t\t\tvalue;\n\tchar\t\t\t*name;\n} fc_port_speed_names[] = {\n\t{ FC_PORTSPEED_1GBIT,\t\t\"1 Gbit\" },\n\t{ FC_PORTSPEED_2GBIT,\t\t\"2 Gbit\" },\n\t{ FC_PORTSPEED_4GBIT,\t\t\"4 Gbit\" },\n\t{ FC_PORTSPEED_10GBIT,\t\t\"10 Gbit\" },\n\t{ FC_PORTSPEED_8GBIT,\t\t\"8 Gbit\" },\n\t{ FC_PORTSPEED_16GBIT,\t\t\"16 Gbit\" },\n\t{ FC_PORTSPEED_32GBIT,\t\t\"32 Gbit\" },\n\t{ FC_PORTSPEED_20GBIT,\t\t\"20 Gbit\" },\n\t{ FC_PORTSPEED_40GBIT,\t\t\"40 Gbit\" },\n\t{ FC_PORTSPEED_50GBIT,\t\t\"50 Gbit\" },\n\t{ FC_PORTSPEED_100GBIT,\t\t\"100 Gbit\" },\n\t{ FC_PORTSPEED_25GBIT,\t\t\"25 Gbit\" },\n\t{ FC_PORTSPEED_64GBIT,\t\t\"64 Gbit\" },\n\t{ FC_PORTSPEED_128GBIT,\t\t\"128 Gbit\" },\n\t{ FC_PORTSPEED_256GBIT,\t\t\"256 Gbit\" },\n\t{ FC_PORTSPEED_NOT_NEGOTIATED,\t\"Not Negotiated\" },\n};\nfc_bitfield_name_search(port_speed, fc_port_speed_names)\n\n\nstatic int\nshow_fc_fc4s (char *buf, u8 *fc4_list)\n{\n\tint i, len=0;\n\n\tfor (i = 0; i < FC_FC4_LIST_SIZE; i++, fc4_list++)\n\t\tlen += sprintf(buf + len , \"0x%02x \", *fc4_list);\n\tlen += sprintf(buf + len, \"\\n\");\n\treturn len;\n}\n\n\n \nstatic const struct {\n\tu32 \t\t\tvalue;\n\tchar\t\t\t*name;\n} fc_port_role_names[] = {\n\t{ FC_PORT_ROLE_FCP_TARGET,\t\t\"FCP Target\" },\n\t{ FC_PORT_ROLE_FCP_INITIATOR,\t\t\"FCP Initiator\" },\n\t{ FC_PORT_ROLE_IP_PORT,\t\t\t\"IP Port\" },\n\t{ FC_PORT_ROLE_FCP_DUMMY_INITIATOR,\t\"FCP Dummy Initiator\" },\n\t{ FC_PORT_ROLE_NVME_INITIATOR,\t\t\"NVMe Initiator\" },\n\t{ FC_PORT_ROLE_NVME_TARGET,\t\t\"NVMe Target\" },\n\t{ FC_PORT_ROLE_NVME_DISCOVERY,\t\t\"NVMe Discovery\" },\n};\nfc_bitfield_name_search(port_roles, fc_port_role_names)\n\n \n#define FC_WELLKNOWN_PORTID_MASK\t0xfffff0\n#define FC_WELLKNOWN_ROLE_MASK  \t0x00000f\n#define FC_FPORT_PORTID\t\t\t0x00000e\n#define FC_FABCTLR_PORTID\t\t0x00000d\n#define FC_DIRSRVR_PORTID\t\t0x00000c\n#define FC_TIMESRVR_PORTID\t\t0x00000b\n#define FC_MGMTSRVR_PORTID\t\t0x00000a\n\n\nstatic void fc_timeout_deleted_rport(struct work_struct *work);\nstatic void fc_timeout_fail_rport_io(struct work_struct *work);\nstatic void fc_scsi_scan_rport(struct work_struct *work);\n\n \n#define FC_STARGET_NUM_ATTRS \t3\n#define FC_RPORT_NUM_ATTRS\t10\n#define FC_VPORT_NUM_ATTRS\t9\n#define FC_HOST_NUM_ATTRS\t29\n\nstruct fc_internal {\n\tstruct scsi_transport_template t;\n\tstruct fc_function_template *f;\n\n\t \n\tstruct device_attribute private_starget_attrs[\n\t\t\t\t\t\t\tFC_STARGET_NUM_ATTRS];\n\tstruct device_attribute *starget_attrs[FC_STARGET_NUM_ATTRS + 1];\n\n\tstruct device_attribute private_host_attrs[FC_HOST_NUM_ATTRS];\n\tstruct device_attribute *host_attrs[FC_HOST_NUM_ATTRS + 1];\n\n\tstruct transport_container rport_attr_cont;\n\tstruct device_attribute private_rport_attrs[FC_RPORT_NUM_ATTRS];\n\tstruct device_attribute *rport_attrs[FC_RPORT_NUM_ATTRS + 1];\n\n\tstruct transport_container vport_attr_cont;\n\tstruct device_attribute private_vport_attrs[FC_VPORT_NUM_ATTRS];\n\tstruct device_attribute *vport_attrs[FC_VPORT_NUM_ATTRS + 1];\n};\n\n#define to_fc_internal(tmpl)\tcontainer_of(tmpl, struct fc_internal, t)\n\nstatic int fc_target_setup(struct transport_container *tc, struct device *dev,\n\t\t\t   struct device *cdev)\n{\n\tstruct scsi_target *starget = to_scsi_target(dev);\n\tstruct fc_rport *rport = starget_to_rport(starget);\n\n\t \n\tif (rport) {\n\t\tfc_starget_node_name(starget) = rport->node_name;\n\t\tfc_starget_port_name(starget) = rport->port_name;\n\t\tfc_starget_port_id(starget) = rport->port_id;\n\t} else {\n\t\tfc_starget_node_name(starget) = -1;\n\t\tfc_starget_port_name(starget) = -1;\n\t\tfc_starget_port_id(starget) = -1;\n\t}\n\n\treturn 0;\n}\n\nstatic DECLARE_TRANSPORT_CLASS(fc_transport_class,\n\t\t\t       \"fc_transport\",\n\t\t\t       fc_target_setup,\n\t\t\t       NULL,\n\t\t\t       NULL);\n\nstatic int fc_host_setup(struct transport_container *tc, struct device *dev,\n\t\t\t struct device *cdev)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(dev);\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\n\n\t \n\tfc_host->node_name = -1;\n\tfc_host->port_name = -1;\n\tfc_host->permanent_port_name = -1;\n\tfc_host->supported_classes = FC_COS_UNSPECIFIED;\n\tmemset(fc_host->supported_fc4s, 0,\n\t\tsizeof(fc_host->supported_fc4s));\n\tfc_host->supported_speeds = FC_PORTSPEED_UNKNOWN;\n\tfc_host->maxframe_size = -1;\n\tfc_host->max_npiv_vports = 0;\n\tmemset(fc_host->serial_number, 0,\n\t\tsizeof(fc_host->serial_number));\n\tmemset(fc_host->manufacturer, 0,\n\t\tsizeof(fc_host->manufacturer));\n\tmemset(fc_host->model, 0,\n\t\tsizeof(fc_host->model));\n\tmemset(fc_host->model_description, 0,\n\t\tsizeof(fc_host->model_description));\n\tmemset(fc_host->hardware_version, 0,\n\t\tsizeof(fc_host->hardware_version));\n\tmemset(fc_host->driver_version, 0,\n\t\tsizeof(fc_host->driver_version));\n\tmemset(fc_host->firmware_version, 0,\n\t\tsizeof(fc_host->firmware_version));\n\tmemset(fc_host->optionrom_version, 0,\n\t\tsizeof(fc_host->optionrom_version));\n\n\tfc_host->port_id = -1;\n\tfc_host->port_type = FC_PORTTYPE_UNKNOWN;\n\tfc_host->port_state = FC_PORTSTATE_UNKNOWN;\n\tmemset(fc_host->active_fc4s, 0,\n\t\tsizeof(fc_host->active_fc4s));\n\tfc_host->speed = FC_PORTSPEED_UNKNOWN;\n\tfc_host->fabric_name = -1;\n\tmemset(fc_host->symbolic_name, 0, sizeof(fc_host->symbolic_name));\n\tmemset(fc_host->system_hostname, 0, sizeof(fc_host->system_hostname));\n\tmemset(&fc_host->fpin_stats, 0, sizeof(fc_host->fpin_stats));\n\n\tfc_host->tgtid_bind_type = FC_TGTID_BIND_BY_WWPN;\n\n\tINIT_LIST_HEAD(&fc_host->rports);\n\tINIT_LIST_HEAD(&fc_host->rport_bindings);\n\tINIT_LIST_HEAD(&fc_host->vports);\n\tfc_host->next_rport_number = 0;\n\tfc_host->next_target_id = 0;\n\tfc_host->next_vport_number = 0;\n\tfc_host->npiv_vports_inuse = 0;\n\n\tsnprintf(fc_host->work_q_name, sizeof(fc_host->work_q_name),\n\t\t \"fc_wq_%d\", shost->host_no);\n\tfc_host->work_q = alloc_workqueue(\"%s\", 0, 0, fc_host->work_q_name);\n\tif (!fc_host->work_q)\n\t\treturn -ENOMEM;\n\n\tfc_host->dev_loss_tmo = fc_dev_loss_tmo;\n\tsnprintf(fc_host->devloss_work_q_name,\n\t\t sizeof(fc_host->devloss_work_q_name),\n\t\t \"fc_dl_%d\", shost->host_no);\n\tfc_host->devloss_work_q = alloc_workqueue(\"%s\", 0, 0,\n\t\t\t\t\tfc_host->devloss_work_q_name);\n\tif (!fc_host->devloss_work_q) {\n\t\tdestroy_workqueue(fc_host->work_q);\n\t\tfc_host->work_q = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tfc_bsg_hostadd(shost, fc_host);\n\t \n\n\treturn 0;\n}\n\nstatic int fc_host_remove(struct transport_container *tc, struct device *dev,\n\t\t\t struct device *cdev)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(dev);\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\n\n\tfc_bsg_remove(fc_host->rqst_q);\n\treturn 0;\n}\n\nstatic DECLARE_TRANSPORT_CLASS(fc_host_class,\n\t\t\t       \"fc_host\",\n\t\t\t       fc_host_setup,\n\t\t\t       fc_host_remove,\n\t\t\t       NULL);\n\n \nstatic DECLARE_TRANSPORT_CLASS(fc_rport_class,\n\t\t\t       \"fc_remote_ports\",\n\t\t\t       NULL,\n\t\t\t       NULL,\n\t\t\t       NULL);\n\n \nstatic DECLARE_TRANSPORT_CLASS(fc_vport_class,\n\t\t\t       \"fc_vports\",\n\t\t\t       NULL,\n\t\t\t       NULL,\n\t\t\t       NULL);\n\n \n\nstatic atomic_t fc_event_seq;\n\n \nu32\nfc_get_event_number(void)\n{\n\treturn atomic_add_return(1, &fc_event_seq);\n}\nEXPORT_SYMBOL(fc_get_event_number);\n\n \nvoid\nfc_host_post_fc_event(struct Scsi_Host *shost, u32 event_number,\n\t\tenum fc_host_event_code event_code,\n\t\tu32 data_len, char *data_buf, u64 vendor_id)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr\t*nlh;\n\tstruct fc_nl_event *event;\n\tconst char *name;\n\tsize_t len, padding;\n\tint err;\n\n\tif (!data_buf || data_len < 4)\n\t\tdata_len = 0;\n\n\tif (!scsi_nl_sock) {\n\t\terr = -ENOENT;\n\t\tgoto send_fail;\n\t}\n\n\tlen = FC_NL_MSGALIGN(sizeof(*event) - sizeof(event->event_data) + data_len);\n\n\tskb = nlmsg_new(len, GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto send_fail;\n\t}\n\n\tnlh = nlmsg_put(skb, 0, 0, SCSI_TRANSPORT_MSG, len, 0);\n\tif (!nlh) {\n\t\terr = -ENOBUFS;\n\t\tgoto send_fail_skb;\n\t}\n\tevent = nlmsg_data(nlh);\n\n\tINIT_SCSI_NL_HDR(&event->snlh, SCSI_NL_TRANSPORT_FC,\n\t\t\t\tFC_NL_ASYNC_EVENT, len);\n\tevent->seconds = ktime_get_real_seconds();\n\tevent->vendor_id = vendor_id;\n\tevent->host_no = shost->host_no;\n\tevent->event_datalen = data_len;\t \n\tevent->event_num = event_number;\n\tevent->event_code = event_code;\n\tif (data_len)\n\t\tmemcpy(event->event_data_flex, data_buf, data_len);\n\tpadding = len - offsetof(typeof(*event), event_data_flex) - data_len;\n\tmemset(event->event_data_flex + data_len, 0, padding);\n\n\tnlmsg_multicast(scsi_nl_sock, skb, 0, SCSI_NL_GRP_FC_EVENTS,\n\t\t\tGFP_KERNEL);\n\treturn;\n\nsend_fail_skb:\n\tkfree_skb(skb);\nsend_fail:\n\tname = get_fc_host_event_code_name(event_code);\n\tprintk(KERN_WARNING\n\t\t\"%s: Dropped Event : host %d %s data 0x%08x - err %d\\n\",\n\t\t__func__, shost->host_no,\n\t\t(name) ? name : \"<unknown>\",\n\t\t(data_len) ? *((u32 *)data_buf) : 0xFFFFFFFF, err);\n\treturn;\n}\nEXPORT_SYMBOL(fc_host_post_fc_event);\n\n \nvoid\nfc_host_post_event(struct Scsi_Host *shost, u32 event_number,\n\t\tenum fc_host_event_code event_code, u32 event_data)\n{\n\tfc_host_post_fc_event(shost, event_number, event_code,\n\t\t(u32)sizeof(u32), (char *)&event_data, 0);\n}\nEXPORT_SYMBOL(fc_host_post_event);\n\n\n \nvoid\nfc_host_post_vendor_event(struct Scsi_Host *shost, u32 event_number,\n\t\tu32 data_len, char * data_buf, u64 vendor_id)\n{\n\tfc_host_post_fc_event(shost, event_number, FCH_EVT_VENDOR_UNIQUE,\n\t\tdata_len, data_buf, vendor_id);\n}\nEXPORT_SYMBOL(fc_host_post_vendor_event);\n\n \nstruct fc_rport *\nfc_find_rport_by_wwpn(struct Scsi_Host *shost, u64 wwpn)\n{\n\tstruct fc_rport *rport;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\n\tlist_for_each_entry(rport, &fc_host_rports(shost), peers) {\n\t\tif (rport->port_state != FC_PORTSTATE_ONLINE)\n\t\t\tcontinue;\n\n\t\tif (rport->port_name == wwpn) {\n\t\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\t\treturn rport;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\treturn NULL;\n}\nEXPORT_SYMBOL(fc_find_rport_by_wwpn);\n\nstatic void\nfc_li_stats_update(u16 event_type,\n\t\t   struct fc_fpin_stats *stats)\n{\n\tstats->li++;\n\tswitch (event_type) {\n\tcase FPIN_LI_UNKNOWN:\n\t\tstats->li_failure_unknown++;\n\t\tbreak;\n\tcase FPIN_LI_LINK_FAILURE:\n\t\tstats->li_link_failure_count++;\n\t\tbreak;\n\tcase FPIN_LI_LOSS_OF_SYNC:\n\t\tstats->li_loss_of_sync_count++;\n\t\tbreak;\n\tcase FPIN_LI_LOSS_OF_SIG:\n\t\tstats->li_loss_of_signals_count++;\n\t\tbreak;\n\tcase FPIN_LI_PRIM_SEQ_ERR:\n\t\tstats->li_prim_seq_err_count++;\n\t\tbreak;\n\tcase FPIN_LI_INVALID_TX_WD:\n\t\tstats->li_invalid_tx_word_count++;\n\t\tbreak;\n\tcase FPIN_LI_INVALID_CRC:\n\t\tstats->li_invalid_crc_count++;\n\t\tbreak;\n\tcase FPIN_LI_DEVICE_SPEC:\n\t\tstats->li_device_specific++;\n\t\tbreak;\n\t}\n}\n\nstatic void\nfc_delivery_stats_update(u32 reason_code, struct fc_fpin_stats *stats)\n{\n\tstats->dn++;\n\tswitch (reason_code) {\n\tcase FPIN_DELI_UNKNOWN:\n\t\tstats->dn_unknown++;\n\t\tbreak;\n\tcase FPIN_DELI_TIMEOUT:\n\t\tstats->dn_timeout++;\n\t\tbreak;\n\tcase FPIN_DELI_UNABLE_TO_ROUTE:\n\t\tstats->dn_unable_to_route++;\n\t\tbreak;\n\tcase FPIN_DELI_DEVICE_SPEC:\n\t\tstats->dn_device_specific++;\n\t\tbreak;\n\t}\n}\n\nstatic void\nfc_cn_stats_update(u16 event_type, struct fc_fpin_stats *stats)\n{\n\tstats->cn++;\n\tswitch (event_type) {\n\tcase FPIN_CONGN_CLEAR:\n\t\tstats->cn_clear++;\n\t\tbreak;\n\tcase FPIN_CONGN_LOST_CREDIT:\n\t\tstats->cn_lost_credit++;\n\t\tbreak;\n\tcase FPIN_CONGN_CREDIT_STALL:\n\t\tstats->cn_credit_stall++;\n\t\tbreak;\n\tcase FPIN_CONGN_OVERSUBSCRIPTION:\n\t\tstats->cn_oversubscription++;\n\t\tbreak;\n\tcase FPIN_CONGN_DEVICE_SPEC:\n\t\tstats->cn_device_specific++;\n\t}\n}\n\n \nstatic void\nfc_fpin_li_stats_update(struct Scsi_Host *shost, struct fc_tlv_desc *tlv)\n{\n\tu8 i;\n\tstruct fc_rport *rport = NULL;\n\tstruct fc_rport *attach_rport = NULL;\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\n\tstruct fc_fn_li_desc *li_desc = (struct fc_fn_li_desc *)tlv;\n\tu16 event_type = be16_to_cpu(li_desc->event_type);\n\tu64 wwpn;\n\n\trport = fc_find_rport_by_wwpn(shost,\n\t\t\t\t      be64_to_cpu(li_desc->attached_wwpn));\n\tif (rport &&\n\t    (rport->roles & FC_PORT_ROLE_FCP_TARGET ||\n\t     rport->roles & FC_PORT_ROLE_NVME_TARGET)) {\n\t\tattach_rport = rport;\n\t\tfc_li_stats_update(event_type, &attach_rport->fpin_stats);\n\t}\n\n\tif (be32_to_cpu(li_desc->pname_count) > 0) {\n\t\tfor (i = 0;\n\t\t    i < be32_to_cpu(li_desc->pname_count);\n\t\t    i++) {\n\t\t\twwpn = be64_to_cpu(li_desc->pname_list[i]);\n\t\t\trport = fc_find_rport_by_wwpn(shost, wwpn);\n\t\t\tif (rport &&\n\t\t\t    (rport->roles & FC_PORT_ROLE_FCP_TARGET ||\n\t\t\t    rport->roles & FC_PORT_ROLE_NVME_TARGET)) {\n\t\t\t\tif (rport == attach_rport)\n\t\t\t\t\tcontinue;\n\t\t\t\tfc_li_stats_update(event_type,\n\t\t\t\t\t\t   &rport->fpin_stats);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fc_host->port_name == be64_to_cpu(li_desc->attached_wwpn))\n\t\tfc_li_stats_update(event_type, &fc_host->fpin_stats);\n}\n\n \nstatic void\nfc_fpin_delivery_stats_update(struct Scsi_Host *shost,\n\t\t\t      struct fc_tlv_desc *tlv)\n{\n\tstruct fc_rport *rport = NULL;\n\tstruct fc_rport *attach_rport = NULL;\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\n\tstruct fc_fn_deli_desc *dn_desc = (struct fc_fn_deli_desc *)tlv;\n\tu32 reason_code = be32_to_cpu(dn_desc->deli_reason_code);\n\n\trport = fc_find_rport_by_wwpn(shost,\n\t\t\t\t      be64_to_cpu(dn_desc->attached_wwpn));\n\tif (rport &&\n\t    (rport->roles & FC_PORT_ROLE_FCP_TARGET ||\n\t     rport->roles & FC_PORT_ROLE_NVME_TARGET)) {\n\t\tattach_rport = rport;\n\t\tfc_delivery_stats_update(reason_code,\n\t\t\t\t\t &attach_rport->fpin_stats);\n\t}\n\n\tif (fc_host->port_name == be64_to_cpu(dn_desc->attached_wwpn))\n\t\tfc_delivery_stats_update(reason_code, &fc_host->fpin_stats);\n}\n\n \nstatic void\nfc_fpin_peer_congn_stats_update(struct Scsi_Host *shost,\n\t\t\t\tstruct fc_tlv_desc *tlv)\n{\n\tu8 i;\n\tstruct fc_rport *rport = NULL;\n\tstruct fc_rport *attach_rport = NULL;\n\tstruct fc_fn_peer_congn_desc *pc_desc =\n\t    (struct fc_fn_peer_congn_desc *)tlv;\n\tu16 event_type = be16_to_cpu(pc_desc->event_type);\n\tu64 wwpn;\n\n\trport = fc_find_rport_by_wwpn(shost,\n\t\t\t\t      be64_to_cpu(pc_desc->attached_wwpn));\n\tif (rport &&\n\t    (rport->roles & FC_PORT_ROLE_FCP_TARGET ||\n\t     rport->roles & FC_PORT_ROLE_NVME_TARGET)) {\n\t\tattach_rport = rport;\n\t\tfc_cn_stats_update(event_type, &attach_rport->fpin_stats);\n\t}\n\n\tif (be32_to_cpu(pc_desc->pname_count) > 0) {\n\t\tfor (i = 0;\n\t\t    i < be32_to_cpu(pc_desc->pname_count);\n\t\t    i++) {\n\t\t\twwpn = be64_to_cpu(pc_desc->pname_list[i]);\n\t\t\trport = fc_find_rport_by_wwpn(shost, wwpn);\n\t\t\tif (rport &&\n\t\t\t    (rport->roles & FC_PORT_ROLE_FCP_TARGET ||\n\t\t\t     rport->roles & FC_PORT_ROLE_NVME_TARGET)) {\n\t\t\t\tif (rport == attach_rport)\n\t\t\t\t\tcontinue;\n\t\t\t\tfc_cn_stats_update(event_type,\n\t\t\t\t\t\t   &rport->fpin_stats);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void\nfc_fpin_congn_stats_update(struct Scsi_Host *shost,\n\t\t\t   struct fc_tlv_desc *tlv)\n{\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\n\tstruct fc_fn_congn_desc *congn = (struct fc_fn_congn_desc *)tlv;\n\n\tfc_cn_stats_update(be16_to_cpu(congn->event_type),\n\t\t\t   &fc_host->fpin_stats);\n}\n\n \nvoid\nfc_host_fpin_rcv(struct Scsi_Host *shost, u32 fpin_len, char *fpin_buf,\n\t\tu8 event_acknowledge)\n{\n\tstruct fc_els_fpin *fpin = (struct fc_els_fpin *)fpin_buf;\n\tstruct fc_tlv_desc *tlv;\n\tu32 bytes_remain;\n\tu32 dtag;\n\tenum fc_host_event_code event_code =\n\t\tevent_acknowledge ? FCH_EVT_LINK_FPIN_ACK : FCH_EVT_LINK_FPIN;\n\n\t \n\ttlv = (struct fc_tlv_desc *)&fpin->fpin_desc[0];\n\tbytes_remain = fpin_len - offsetof(struct fc_els_fpin, fpin_desc);\n\tbytes_remain = min_t(u32, bytes_remain, be32_to_cpu(fpin->desc_len));\n\n\twhile (bytes_remain >= FC_TLV_DESC_HDR_SZ &&\n\t       bytes_remain >= FC_TLV_DESC_SZ_FROM_LENGTH(tlv)) {\n\t\tdtag = be32_to_cpu(tlv->desc_tag);\n\t\tswitch (dtag) {\n\t\tcase ELS_DTAG_LNK_INTEGRITY:\n\t\t\tfc_fpin_li_stats_update(shost, tlv);\n\t\t\tbreak;\n\t\tcase ELS_DTAG_DELIVERY:\n\t\t\tfc_fpin_delivery_stats_update(shost, tlv);\n\t\t\tbreak;\n\t\tcase ELS_DTAG_PEER_CONGEST:\n\t\t\tfc_fpin_peer_congn_stats_update(shost, tlv);\n\t\t\tbreak;\n\t\tcase ELS_DTAG_CONGESTION:\n\t\t\tfc_fpin_congn_stats_update(shost, tlv);\n\t\t}\n\n\t\tbytes_remain -= FC_TLV_DESC_SZ_FROM_LENGTH(tlv);\n\t\ttlv = fc_tlv_next_desc(tlv);\n\t}\n\n\tfc_host_post_fc_event(shost, fc_get_event_number(),\n\t\t\t\tevent_code, fpin_len, fpin_buf, 0);\n}\nEXPORT_SYMBOL(fc_host_fpin_rcv);\n\n\nstatic __init int fc_transport_init(void)\n{\n\tint error;\n\n\tatomic_set(&fc_event_seq, 0);\n\n\terror = transport_class_register(&fc_host_class);\n\tif (error)\n\t\treturn error;\n\terror = transport_class_register(&fc_vport_class);\n\tif (error)\n\t\tgoto unreg_host_class;\n\terror = transport_class_register(&fc_rport_class);\n\tif (error)\n\t\tgoto unreg_vport_class;\n\terror = transport_class_register(&fc_transport_class);\n\tif (error)\n\t\tgoto unreg_rport_class;\n\treturn 0;\n\nunreg_rport_class:\n\ttransport_class_unregister(&fc_rport_class);\nunreg_vport_class:\n\ttransport_class_unregister(&fc_vport_class);\nunreg_host_class:\n\ttransport_class_unregister(&fc_host_class);\n\treturn error;\n}\n\nstatic void __exit fc_transport_exit(void)\n{\n\ttransport_class_unregister(&fc_transport_class);\n\ttransport_class_unregister(&fc_rport_class);\n\ttransport_class_unregister(&fc_host_class);\n\ttransport_class_unregister(&fc_vport_class);\n}\n\n \n\n#define fc_rport_show_function(field, format_string, sz, cast)\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_fc_rport_##field (struct device *dev, \t\t\t\t\\\n\t\t       struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct fc_rport *rport = transport_class_to_rport(dev);\t\t\\\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\t\t\\\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\t\\\n\tif ((i->f->get_rport_##field) &&\t\t\t\t\\\n\t    !((rport->port_state == FC_PORTSTATE_BLOCKED) ||\t\t\\\n\t      (rport->port_state == FC_PORTSTATE_DELETED) ||\t\t\\\n\t      (rport->port_state == FC_PORTSTATE_NOTPRESENT)))\t\t\\\n\t\ti->f->get_rport_##field(rport);\t\t\t\t\\\n\treturn snprintf(buf, sz, format_string, cast rport->field); \t\\\n}\n\n#define fc_rport_store_function(field)\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nstore_fc_rport_##field(struct device *dev,\t\t\t\t\\\n\t\t       struct device_attribute *attr,\t\t\t\\\n\t\t       const char *buf,\tsize_t count)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint val;\t\t\t\t\t\t\t\\\n\tstruct fc_rport *rport = transport_class_to_rport(dev);\t\t\\\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\t\t\\\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\t\\\n\tchar *cp;\t\t\t\t\t\t\t\\\n\tif ((rport->port_state == FC_PORTSTATE_BLOCKED) ||\t\t\\\n\t    (rport->port_state == FC_PORTSTATE_DELETED) ||\t\t\\\n\t    (rport->port_state == FC_PORTSTATE_NOTPRESENT))\t\t\\\n\t\treturn -EBUSY;\t\t\t\t\t\t\\\n\tval = simple_strtoul(buf, &cp, 0);\t\t\t\t\\\n\tif (*cp && (*cp != '\\n'))\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\ti->f->set_rport_##field(rport, val);\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define fc_rport_rd_attr(field, format_string, sz)\t\t\t\\\n\tfc_rport_show_function(field, format_string, sz, )\t\t\\\nstatic FC_DEVICE_ATTR(rport, field, S_IRUGO,\t\t\t\\\n\t\t\t show_fc_rport_##field, NULL)\n\n#define fc_rport_rd_attr_cast(field, format_string, sz, cast)\t\t\\\n\tfc_rport_show_function(field, format_string, sz, (cast))\t\\\nstatic FC_DEVICE_ATTR(rport, field, S_IRUGO,\t\t\t\\\n\t\t\t  show_fc_rport_##field, NULL)\n\n#define fc_rport_rw_attr(field, format_string, sz)\t\t\t\\\n\tfc_rport_show_function(field, format_string, sz, )\t\t\\\n\tfc_rport_store_function(field)\t\t\t\t\t\\\nstatic FC_DEVICE_ATTR(rport, field, S_IRUGO | S_IWUSR,\t\t\\\n\t\t\tshow_fc_rport_##field,\t\t\t\t\\\n\t\t\tstore_fc_rport_##field)\n\n\n#define fc_private_rport_show_function(field, format_string, sz, cast)\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_fc_rport_##field (struct device *dev, \t\t\t\t\\\n\t\t       struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct fc_rport *rport = transport_class_to_rport(dev);\t\t\\\n\treturn snprintf(buf, sz, format_string, cast rport->field); \t\\\n}\n\n#define fc_private_rport_rd_attr(field, format_string, sz)\t\t\\\n\tfc_private_rport_show_function(field, format_string, sz, )\t\\\nstatic FC_DEVICE_ATTR(rport, field, S_IRUGO,\t\t\t\\\n\t\t\t show_fc_rport_##field, NULL)\n\n#define fc_private_rport_rd_attr_cast(field, format_string, sz, cast)\t\\\n\tfc_private_rport_show_function(field, format_string, sz, (cast)) \\\nstatic FC_DEVICE_ATTR(rport, field, S_IRUGO,\t\t\t\\\n\t\t\t  show_fc_rport_##field, NULL)\n\n\n#define fc_private_rport_rd_enum_attr(title, maxlen)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_fc_rport_##title (struct device *dev,\t\t\t\t\\\n\t\t       struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct fc_rport *rport = transport_class_to_rport(dev);\t\t\\\n\tconst char *name;\t\t\t\t\t\t\\\n\tname = get_fc_##title##_name(rport->title);\t\t\t\\\n\tif (!name)\t\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\treturn snprintf(buf, maxlen, \"%s\\n\", name);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic FC_DEVICE_ATTR(rport, title, S_IRUGO,\t\t\t\\\n\t\t\tshow_fc_rport_##title, NULL)\n\n\n#define SETUP_RPORT_ATTRIBUTE_RD(field)\t\t\t\t\t\\\n\ti->private_rport_attrs[count] = device_attr_rport_##field; \\\n\ti->private_rport_attrs[count].attr.mode = S_IRUGO;\t\t\\\n\ti->private_rport_attrs[count].store = NULL;\t\t\t\\\n\ti->rport_attrs[count] = &i->private_rport_attrs[count];\t\t\\\n\tif (i->f->show_rport_##field)\t\t\t\t\t\\\n\t\tcount++\n\n#define SETUP_PRIVATE_RPORT_ATTRIBUTE_RD(field)\t\t\t\t\\\n\ti->private_rport_attrs[count] = device_attr_rport_##field; \\\n\ti->private_rport_attrs[count].attr.mode = S_IRUGO;\t\t\\\n\ti->private_rport_attrs[count].store = NULL;\t\t\t\\\n\ti->rport_attrs[count] = &i->private_rport_attrs[count];\t\t\\\n\tcount++\n\n#define SETUP_RPORT_ATTRIBUTE_RW(field)\t\t\t\t\t\\\n\ti->private_rport_attrs[count] = device_attr_rport_##field; \\\n\tif (!i->f->set_rport_##field) {\t\t\t\t\t\\\n\t\ti->private_rport_attrs[count].attr.mode = S_IRUGO;\t\\\n\t\ti->private_rport_attrs[count].store = NULL;\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\ti->rport_attrs[count] = &i->private_rport_attrs[count];\t\t\\\n\tif (i->f->show_rport_##field)\t\t\t\t\t\\\n\t\tcount++\n\n#define SETUP_PRIVATE_RPORT_ATTRIBUTE_RW(field)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ti->private_rport_attrs[count] = device_attr_rport_##field; \\\n\ti->rport_attrs[count] = &i->private_rport_attrs[count];\t\t\\\n\tcount++;\t\t\t\t\t\t\t\\\n}\n\n\n \n\n \n\nfc_private_rport_rd_attr(maxframe_size, \"%u bytes\\n\", 20);\n\nstatic ssize_t\nshow_fc_rport_supported_classes (struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct fc_rport *rport = transport_class_to_rport(dev);\n\tif (rport->supported_classes == FC_COS_UNSPECIFIED)\n\t\treturn snprintf(buf, 20, \"unspecified\\n\");\n\treturn get_fc_cos_names(rport->supported_classes, buf);\n}\nstatic FC_DEVICE_ATTR(rport, supported_classes, S_IRUGO,\n\t\tshow_fc_rport_supported_classes, NULL);\n\n \n\n \nstatic int fc_str_to_dev_loss(const char *buf, unsigned long *val)\n{\n\tchar *cp;\n\n\t*val = simple_strtoul(buf, &cp, 0);\n\tif (*cp && (*cp != '\\n'))\n\t\treturn -EINVAL;\n\t \n\tif (*val > UINT_MAX)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int fc_rport_set_dev_loss_tmo(struct fc_rport *rport,\n\t\t\t\t     unsigned long val)\n{\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\n\tif ((rport->port_state == FC_PORTSTATE_BLOCKED) ||\n\t    (rport->port_state == FC_PORTSTATE_DELETED) ||\n\t    (rport->port_state == FC_PORTSTATE_NOTPRESENT))\n\t\treturn -EBUSY;\n\t \n\tif (val > UINT_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tif (rport->fast_io_fail_tmo == -1 &&\n\t    val > SCSI_DEVICE_BLOCK_MAX_TIMEOUT)\n\t\treturn -EINVAL;\n\n\ti->f->set_rport_dev_loss_tmo(rport, val);\n\treturn 0;\n}\n\nfc_rport_show_function(dev_loss_tmo, \"%u\\n\", 20, )\nstatic ssize_t\nstore_fc_rport_dev_loss_tmo(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct fc_rport *rport = transport_class_to_rport(dev);\n\tunsigned long val;\n\tint rc;\n\n\trc = fc_str_to_dev_loss(buf, &val);\n\tif (rc)\n\t\treturn rc;\n\n\trc = fc_rport_set_dev_loss_tmo(rport, val);\n\tif (rc)\n\t\treturn rc;\n\treturn count;\n}\nstatic FC_DEVICE_ATTR(rport, dev_loss_tmo, S_IRUGO | S_IWUSR,\n\t\tshow_fc_rport_dev_loss_tmo, store_fc_rport_dev_loss_tmo);\n\n\n \n\nfc_private_rport_rd_attr_cast(node_name, \"0x%llx\\n\", 20, unsigned long long);\nfc_private_rport_rd_attr_cast(port_name, \"0x%llx\\n\", 20, unsigned long long);\nfc_private_rport_rd_attr(port_id, \"0x%06x\\n\", 20);\n\nstatic ssize_t\nshow_fc_rport_roles (struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct fc_rport *rport = transport_class_to_rport(dev);\n\n\t \n\tif ((rport->port_id != -1) &&\n\t    (rport->port_id & FC_WELLKNOWN_PORTID_MASK) ==\n\t\t\t\t\tFC_WELLKNOWN_PORTID_MASK) {\n\t\tswitch (rport->port_id & FC_WELLKNOWN_ROLE_MASK) {\n\t\tcase FC_FPORT_PORTID:\n\t\t\treturn snprintf(buf, 30, \"Fabric Port\\n\");\n\t\tcase FC_FABCTLR_PORTID:\n\t\t\treturn snprintf(buf, 30, \"Fabric Controller\\n\");\n\t\tcase FC_DIRSRVR_PORTID:\n\t\t\treturn snprintf(buf, 30, \"Directory Server\\n\");\n\t\tcase FC_TIMESRVR_PORTID:\n\t\t\treturn snprintf(buf, 30, \"Time Server\\n\");\n\t\tcase FC_MGMTSRVR_PORTID:\n\t\t\treturn snprintf(buf, 30, \"Management Server\\n\");\n\t\tdefault:\n\t\t\treturn snprintf(buf, 30, \"Unknown Fabric Entity\\n\");\n\t\t}\n\t} else {\n\t\tif (rport->roles == FC_PORT_ROLE_UNKNOWN)\n\t\t\treturn snprintf(buf, 20, \"unknown\\n\");\n\t\treturn get_fc_port_roles_names(rport->roles, buf);\n\t}\n}\nstatic FC_DEVICE_ATTR(rport, roles, S_IRUGO,\n\t\tshow_fc_rport_roles, NULL);\n\nstatic ssize_t fc_rport_set_marginal_state(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct fc_rport *rport = transport_class_to_rport(dev);\n\tenum fc_port_state port_state;\n\tint ret = 0;\n\n\tret = get_fc_port_state_match(buf, &port_state);\n\tif (ret)\n\t\treturn -EINVAL;\n\tif (port_state == FC_PORTSTATE_MARGINAL) {\n\t\t \n\t\tif (rport->port_state == FC_PORTSTATE_ONLINE)\n\t\t\trport->port_state = port_state;\n\t\telse\n\t\t\treturn -EINVAL;\n\t} else if (port_state == FC_PORTSTATE_ONLINE) {\n\t\t \n\t\tif (rport->port_state == FC_PORTSTATE_MARGINAL)\n\t\t\trport->port_state = port_state;\n\t\telse\n\t\t\treturn -EINVAL;\n\t} else\n\t\treturn -EINVAL;\n\treturn count;\n}\n\nstatic ssize_t\nshow_fc_rport_port_state(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tconst char *name;\n\tstruct fc_rport *rport = transport_class_to_rport(dev);\n\n\tname = get_fc_port_state_name(rport->port_state);\n\tif (!name)\n\t\treturn -EINVAL;\n\n\treturn snprintf(buf, 20, \"%s\\n\", name);\n}\n\nstatic FC_DEVICE_ATTR(rport, port_state, 0444 | 0200,\n\t\t\tshow_fc_rport_port_state, fc_rport_set_marginal_state);\n\nfc_private_rport_rd_attr(scsi_target_id, \"%d\\n\", 20);\n\n \nstatic ssize_t\nshow_fc_rport_fast_io_fail_tmo (struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fc_rport *rport = transport_class_to_rport(dev);\n\n\tif (rport->fast_io_fail_tmo == -1)\n\t\treturn snprintf(buf, 5, \"off\\n\");\n\treturn snprintf(buf, 20, \"%d\\n\", rport->fast_io_fail_tmo);\n}\n\nstatic ssize_t\nstore_fc_rport_fast_io_fail_tmo(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tint val;\n\tchar *cp;\n\tstruct fc_rport *rport = transport_class_to_rport(dev);\n\n\tif ((rport->port_state == FC_PORTSTATE_BLOCKED) ||\n\t    (rport->port_state == FC_PORTSTATE_DELETED) ||\n\t    (rport->port_state == FC_PORTSTATE_NOTPRESENT))\n\t\treturn -EBUSY;\n\tif (strncmp(buf, \"off\", 3) == 0)\n\t\trport->fast_io_fail_tmo = -1;\n\telse {\n\t\tval = simple_strtoul(buf, &cp, 0);\n\t\tif ((*cp && (*cp != '\\n')) || (val < 0))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif ((val >= rport->dev_loss_tmo) ||\n\t\t    (val > SCSI_DEVICE_BLOCK_MAX_TIMEOUT))\n\t\t\treturn -EINVAL;\n\n\t\trport->fast_io_fail_tmo = val;\n\t}\n\treturn count;\n}\nstatic FC_DEVICE_ATTR(rport, fast_io_fail_tmo, S_IRUGO | S_IWUSR,\n\tshow_fc_rport_fast_io_fail_tmo, store_fc_rport_fast_io_fail_tmo);\n\n#define fc_rport_fpin_statistic(name)\t\t\t\t\t\\\nstatic ssize_t fc_rport_fpinstat_##name(struct device *cd,\t\t\\\n\t\t\t\t  struct device_attribute *attr,\t\\\n\t\t\t\t  char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct fc_rport *rport = transport_class_to_rport(cd);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn snprintf(buf, 20, \"0x%llx\\n\", rport->fpin_stats.name);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic FC_DEVICE_ATTR(rport, fpin_##name, 0444, fc_rport_fpinstat_##name, NULL)\n\nfc_rport_fpin_statistic(dn);\nfc_rport_fpin_statistic(dn_unknown);\nfc_rport_fpin_statistic(dn_timeout);\nfc_rport_fpin_statistic(dn_unable_to_route);\nfc_rport_fpin_statistic(dn_device_specific);\nfc_rport_fpin_statistic(cn);\nfc_rport_fpin_statistic(cn_clear);\nfc_rport_fpin_statistic(cn_lost_credit);\nfc_rport_fpin_statistic(cn_credit_stall);\nfc_rport_fpin_statistic(cn_oversubscription);\nfc_rport_fpin_statistic(cn_device_specific);\nfc_rport_fpin_statistic(li);\nfc_rport_fpin_statistic(li_failure_unknown);\nfc_rport_fpin_statistic(li_link_failure_count);\nfc_rport_fpin_statistic(li_loss_of_sync_count);\nfc_rport_fpin_statistic(li_loss_of_signals_count);\nfc_rport_fpin_statistic(li_prim_seq_err_count);\nfc_rport_fpin_statistic(li_invalid_tx_word_count);\nfc_rport_fpin_statistic(li_invalid_crc_count);\nfc_rport_fpin_statistic(li_device_specific);\n\nstatic struct attribute *fc_rport_statistics_attrs[] = {\n\t&device_attr_rport_fpin_dn.attr,\n\t&device_attr_rport_fpin_dn_unknown.attr,\n\t&device_attr_rport_fpin_dn_timeout.attr,\n\t&device_attr_rport_fpin_dn_unable_to_route.attr,\n\t&device_attr_rport_fpin_dn_device_specific.attr,\n\t&device_attr_rport_fpin_li.attr,\n\t&device_attr_rport_fpin_li_failure_unknown.attr,\n\t&device_attr_rport_fpin_li_link_failure_count.attr,\n\t&device_attr_rport_fpin_li_loss_of_sync_count.attr,\n\t&device_attr_rport_fpin_li_loss_of_signals_count.attr,\n\t&device_attr_rport_fpin_li_prim_seq_err_count.attr,\n\t&device_attr_rport_fpin_li_invalid_tx_word_count.attr,\n\t&device_attr_rport_fpin_li_invalid_crc_count.attr,\n\t&device_attr_rport_fpin_li_device_specific.attr,\n\t&device_attr_rport_fpin_cn.attr,\n\t&device_attr_rport_fpin_cn_clear.attr,\n\t&device_attr_rport_fpin_cn_lost_credit.attr,\n\t&device_attr_rport_fpin_cn_credit_stall.attr,\n\t&device_attr_rport_fpin_cn_oversubscription.attr,\n\t&device_attr_rport_fpin_cn_device_specific.attr,\n\tNULL\n};\n\nstatic struct attribute_group fc_rport_statistics_group = {\n\t.name = \"statistics\",\n\t.attrs = fc_rport_statistics_attrs,\n};\n\n\n \n\n \n#define fc_starget_show_function(field, format_string, sz, cast)\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_fc_starget_##field (struct device *dev, \t\t\t\t\\\n\t\t\t struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct scsi_target *starget = transport_class_to_starget(dev);\t\\\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\t\\\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\t\\\n\tstruct fc_rport *rport = starget_to_rport(starget);\t\t\\\n\tif (rport)\t\t\t\t\t\t\t\\\n\t\tfc_starget_##field(starget) = rport->field;\t\t\\\n\telse if (i->f->get_starget_##field)\t\t\t\t\\\n\t\ti->f->get_starget_##field(starget);\t\t\t\\\n\treturn snprintf(buf, sz, format_string, \t\t\t\\\n\t\tcast fc_starget_##field(starget)); \t\t\t\\\n}\n\n#define fc_starget_rd_attr(field, format_string, sz)\t\t\t\\\n\tfc_starget_show_function(field, format_string, sz, )\t\t\\\nstatic FC_DEVICE_ATTR(starget, field, S_IRUGO,\t\t\t\\\n\t\t\t show_fc_starget_##field, NULL)\n\n#define fc_starget_rd_attr_cast(field, format_string, sz, cast)\t\t\\\n\tfc_starget_show_function(field, format_string, sz, (cast))\t\\\nstatic FC_DEVICE_ATTR(starget, field, S_IRUGO,\t\t\t\\\n\t\t\t  show_fc_starget_##field, NULL)\n\n#define SETUP_STARGET_ATTRIBUTE_RD(field)\t\t\t\t\\\n\ti->private_starget_attrs[count] = device_attr_starget_##field; \\\n\ti->private_starget_attrs[count].attr.mode = S_IRUGO;\t\t\\\n\ti->private_starget_attrs[count].store = NULL;\t\t\t\\\n\ti->starget_attrs[count] = &i->private_starget_attrs[count];\t\\\n\tif (i->f->show_starget_##field)\t\t\t\t\t\\\n\t\tcount++\n\n#define SETUP_STARGET_ATTRIBUTE_RW(field)\t\t\t\t\\\n\ti->private_starget_attrs[count] = device_attr_starget_##field; \\\n\tif (!i->f->set_starget_##field) {\t\t\t\t\\\n\t\ti->private_starget_attrs[count].attr.mode = S_IRUGO;\t\\\n\t\ti->private_starget_attrs[count].store = NULL;\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\ti->starget_attrs[count] = &i->private_starget_attrs[count];\t\\\n\tif (i->f->show_starget_##field)\t\t\t\t\t\\\n\t\tcount++\n\n \nfc_starget_rd_attr_cast(node_name, \"0x%llx\\n\", 20, unsigned long long);\nfc_starget_rd_attr_cast(port_name, \"0x%llx\\n\", 20, unsigned long long);\nfc_starget_rd_attr(port_id, \"0x%06x\\n\", 20);\n\n\n \n\n#define fc_vport_show_function(field, format_string, sz, cast)\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_fc_vport_##field (struct device *dev, \t\t\t\t\\\n\t\t       struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct fc_vport *vport = transport_class_to_vport(dev);\t\t\\\n\tstruct Scsi_Host *shost = vport_to_shost(vport);\t\t\\\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\t\\\n\tif ((i->f->get_vport_##field) &&\t\t\t\t\\\n\t    !(vport->flags & (FC_VPORT_DEL | FC_VPORT_CREATING)))\t\\\n\t\ti->f->get_vport_##field(vport);\t\t\t\t\\\n\treturn snprintf(buf, sz, format_string, cast vport->field); \t\\\n}\n\n#define fc_vport_store_function(field)\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nstore_fc_vport_##field(struct device *dev,\t\t\t\t\\\n\t\t       struct device_attribute *attr,\t\t\t\\\n\t\t       const char *buf,\tsize_t count)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint val;\t\t\t\t\t\t\t\\\n\tstruct fc_vport *vport = transport_class_to_vport(dev);\t\t\\\n\tstruct Scsi_Host *shost = vport_to_shost(vport);\t\t\\\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\t\\\n\tchar *cp;\t\t\t\t\t\t\t\\\n\tif (vport->flags & (FC_VPORT_DEL | FC_VPORT_CREATING))\t\\\n\t\treturn -EBUSY;\t\t\t\t\t\t\\\n\tval = simple_strtoul(buf, &cp, 0);\t\t\t\t\\\n\tif (*cp && (*cp != '\\n'))\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\ti->f->set_vport_##field(vport, val);\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define fc_vport_store_str_function(field, slen)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nstore_fc_vport_##field(struct device *dev,\t\t\t\t\\\n\t\t       struct device_attribute *attr, \t\t\t\\\n\t\t       const char *buf,\tsize_t count)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct fc_vport *vport = transport_class_to_vport(dev);\t\t\\\n\tstruct Scsi_Host *shost = vport_to_shost(vport);\t\t\\\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\t\\\n\tunsigned int cnt=count;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\\\n\tif (buf[cnt-1] == '\\n')\t\t\t\t\t\t\\\n\t\tcnt--;\t\t\t\t\t\t\t\\\n\tif (cnt > ((slen) - 1))\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\tmemcpy(vport->field, buf, cnt);\t\t\t\t\t\\\n\ti->f->set_vport_##field(vport);\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define fc_vport_rd_attr(field, format_string, sz)\t\t\t\\\n\tfc_vport_show_function(field, format_string, sz, )\t\t\\\nstatic FC_DEVICE_ATTR(vport, field, S_IRUGO,\t\t\t\\\n\t\t\t show_fc_vport_##field, NULL)\n\n#define fc_vport_rd_attr_cast(field, format_string, sz, cast)\t\t\\\n\tfc_vport_show_function(field, format_string, sz, (cast))\t\\\nstatic FC_DEVICE_ATTR(vport, field, S_IRUGO,\t\t\t\\\n\t\t\t  show_fc_vport_##field, NULL)\n\n#define fc_vport_rw_attr(field, format_string, sz)\t\t\t\\\n\tfc_vport_show_function(field, format_string, sz, )\t\t\\\n\tfc_vport_store_function(field)\t\t\t\t\t\\\nstatic FC_DEVICE_ATTR(vport, field, S_IRUGO | S_IWUSR,\t\t\\\n\t\t\tshow_fc_vport_##field,\t\t\t\t\\\n\t\t\tstore_fc_vport_##field)\n\n#define fc_private_vport_show_function(field, format_string, sz, cast)\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_fc_vport_##field (struct device *dev,\t\t\t\t\\\n\t\t       struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct fc_vport *vport = transport_class_to_vport(dev);\t\t\\\n\treturn snprintf(buf, sz, format_string, cast vport->field); \t\\\n}\n\n#define fc_private_vport_store_u32_function(field)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nstore_fc_vport_##field(struct device *dev,\t\t\t\t\\\n\t\t       struct device_attribute *attr,\t\t\t\\\n\t\t       const char *buf,\tsize_t count)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu32 val;\t\t\t\t\t\t\t\\\n\tstruct fc_vport *vport = transport_class_to_vport(dev);\t\t\\\n\tchar *cp;\t\t\t\t\t\t\t\\\n\tif (vport->flags & (FC_VPORT_DEL | FC_VPORT_CREATING))\t\t\\\n\t\treturn -EBUSY;\t\t\t\t\t\t\\\n\tval = simple_strtoul(buf, &cp, 0);\t\t\t\t\\\n\tif (*cp && (*cp != '\\n'))\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\tvport->field = val;\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n\n#define fc_private_vport_rd_attr(field, format_string, sz)\t\t\\\n\tfc_private_vport_show_function(field, format_string, sz, )\t\\\nstatic FC_DEVICE_ATTR(vport, field, S_IRUGO,\t\t\t\\\n\t\t\t show_fc_vport_##field, NULL)\n\n#define fc_private_vport_rd_attr_cast(field, format_string, sz, cast)\t\\\n\tfc_private_vport_show_function(field, format_string, sz, (cast)) \\\nstatic FC_DEVICE_ATTR(vport, field, S_IRUGO,\t\t\t\\\n\t\t\t  show_fc_vport_##field, NULL)\n\n#define fc_private_vport_rw_u32_attr(field, format_string, sz)\t\t\\\n\tfc_private_vport_show_function(field, format_string, sz, )\t\\\n\tfc_private_vport_store_u32_function(field)\t\t\t\\\nstatic FC_DEVICE_ATTR(vport, field, S_IRUGO | S_IWUSR,\t\t\\\n\t\t\tshow_fc_vport_##field,\t\t\t\t\\\n\t\t\tstore_fc_vport_##field)\n\n\n#define fc_private_vport_rd_enum_attr(title, maxlen)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_fc_vport_##title (struct device *dev,\t\t\t\t\\\n\t\t       struct device_attribute *attr,\t\t\t\\\n\t\t       char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct fc_vport *vport = transport_class_to_vport(dev);\t\t\\\n\tconst char *name;\t\t\t\t\t\t\\\n\tname = get_fc_##title##_name(vport->title);\t\t\t\\\n\tif (!name)\t\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\treturn snprintf(buf, maxlen, \"%s\\n\", name);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic FC_DEVICE_ATTR(vport, title, S_IRUGO,\t\t\t\\\n\t\t\tshow_fc_vport_##title, NULL)\n\n\n#define SETUP_VPORT_ATTRIBUTE_RD(field)\t\t\t\t\t\\\n\ti->private_vport_attrs[count] = device_attr_vport_##field; \\\n\ti->private_vport_attrs[count].attr.mode = S_IRUGO;\t\t\\\n\ti->private_vport_attrs[count].store = NULL;\t\t\t\\\n\ti->vport_attrs[count] = &i->private_vport_attrs[count];\t\t\\\n\tif (i->f->get_##field)\t\t\t\t\t\t\\\n\t\tcount++\n\t \n\n#define SETUP_PRIVATE_VPORT_ATTRIBUTE_RD(field)\t\t\t\t\\\n\ti->private_vport_attrs[count] = device_attr_vport_##field; \\\n\ti->private_vport_attrs[count].attr.mode = S_IRUGO;\t\t\\\n\ti->private_vport_attrs[count].store = NULL;\t\t\t\\\n\ti->vport_attrs[count] = &i->private_vport_attrs[count];\t\t\\\n\tcount++\n\n#define SETUP_VPORT_ATTRIBUTE_WR(field)\t\t\t\t\t\\\n\ti->private_vport_attrs[count] = device_attr_vport_##field; \\\n\ti->vport_attrs[count] = &i->private_vport_attrs[count];\t\t\\\n\tif (i->f->field)\t\t\t\t\t\t\\\n\t\tcount++\n\t \n\n#define SETUP_VPORT_ATTRIBUTE_RW(field)\t\t\t\t\t\\\n\ti->private_vport_attrs[count] = device_attr_vport_##field; \\\n\tif (!i->f->set_vport_##field) {\t\t\t\t\t\\\n\t\ti->private_vport_attrs[count].attr.mode = S_IRUGO;\t\\\n\t\ti->private_vport_attrs[count].store = NULL;\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\ti->vport_attrs[count] = &i->private_vport_attrs[count];\t\t\\\n\tcount++\n\t \n\n#define SETUP_PRIVATE_VPORT_ATTRIBUTE_RW(field)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ti->private_vport_attrs[count] = device_attr_vport_##field; \\\n\ti->vport_attrs[count] = &i->private_vport_attrs[count];\t\t\\\n\tcount++;\t\t\t\t\t\t\t\\\n}\n\n\n \n\n \n\n \n\n \n\nfc_private_vport_rd_enum_attr(vport_state, FC_VPORTSTATE_MAX_NAMELEN);\nfc_private_vport_rd_enum_attr(vport_last_state, FC_VPORTSTATE_MAX_NAMELEN);\nfc_private_vport_rd_attr_cast(node_name, \"0x%llx\\n\", 20, unsigned long long);\nfc_private_vport_rd_attr_cast(port_name, \"0x%llx\\n\", 20, unsigned long long);\n\nstatic ssize_t\nshow_fc_vport_roles (struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct fc_vport *vport = transport_class_to_vport(dev);\n\n\tif (vport->roles == FC_PORT_ROLE_UNKNOWN)\n\t\treturn snprintf(buf, 20, \"unknown\\n\");\n\treturn get_fc_port_roles_names(vport->roles, buf);\n}\nstatic FC_DEVICE_ATTR(vport, roles, S_IRUGO, show_fc_vport_roles, NULL);\n\nfc_private_vport_rd_enum_attr(vport_type, FC_PORTTYPE_MAX_NAMELEN);\n\nfc_private_vport_show_function(symbolic_name, \"%s\\n\",\n\t\tFC_VPORT_SYMBOLIC_NAMELEN + 1, )\nfc_vport_store_str_function(symbolic_name, FC_VPORT_SYMBOLIC_NAMELEN)\nstatic FC_DEVICE_ATTR(vport, symbolic_name, S_IRUGO | S_IWUSR,\n\t\tshow_fc_vport_symbolic_name, store_fc_vport_symbolic_name);\n\nstatic ssize_t\nstore_fc_vport_delete(struct device *dev, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct fc_vport *vport = transport_class_to_vport(dev);\n\tstruct Scsi_Host *shost = vport_to_shost(vport);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (vport->flags & (FC_VPORT_DEL | FC_VPORT_CREATING)) {\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\treturn -EBUSY;\n\t}\n\tvport->flags |= FC_VPORT_DELETING;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tfc_queue_work(shost, &vport->vport_delete_work);\n\treturn count;\n}\nstatic FC_DEVICE_ATTR(vport, vport_delete, S_IWUSR,\n\t\t\tNULL, store_fc_vport_delete);\n\n\n \nstatic ssize_t\nstore_fc_vport_disable(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf,\n\t\t\t   size_t count)\n{\n\tstruct fc_vport *vport = transport_class_to_vport(dev);\n\tstruct Scsi_Host *shost = vport_to_shost(vport);\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\tint stat;\n\n\tif (vport->flags & (FC_VPORT_DEL | FC_VPORT_CREATING))\n\t\treturn -EBUSY;\n\n\tif (*buf == '0') {\n\t\tif (vport->vport_state != FC_VPORT_DISABLED)\n\t\t\treturn -EALREADY;\n\t} else if (*buf == '1') {\n\t\tif (vport->vport_state == FC_VPORT_DISABLED)\n\t\t\treturn -EALREADY;\n\t} else\n\t\treturn -EINVAL;\n\n\tstat = i->f->vport_disable(vport, ((*buf == '0') ? false : true));\n\treturn stat ? stat : count;\n}\nstatic FC_DEVICE_ATTR(vport, vport_disable, S_IWUSR,\n\t\t\tNULL, store_fc_vport_disable);\n\n\n \n\n#define fc_host_show_function(field, format_string, sz, cast)\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_fc_host_##field (struct device *dev,\t\t\t\t\\\n\t\t      struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\t\\\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\t\\\n\tif (i->f->get_host_##field)\t\t\t\t\t\\\n\t\ti->f->get_host_##field(shost);\t\t\t\t\\\n\treturn snprintf(buf, sz, format_string, cast fc_host_##field(shost)); \\\n}\n\n#define fc_host_store_function(field)\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nstore_fc_host_##field(struct device *dev, \t\t\t\t\\\n\t\t      struct device_attribute *attr,\t\t\t\\\n\t\t      const char *buf,\tsize_t count)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint val;\t\t\t\t\t\t\t\\\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\t\\\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\t\\\n\tchar *cp;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tval = simple_strtoul(buf, &cp, 0);\t\t\t\t\\\n\tif (*cp && (*cp != '\\n'))\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\ti->f->set_host_##field(shost, val);\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define fc_host_store_str_function(field, slen)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nstore_fc_host_##field(struct device *dev,\t\t\t\t\\\n\t\t      struct device_attribute *attr,\t\t\t\\\n\t\t      const char *buf, size_t count)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\t\\\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\t\\\n\tunsigned int cnt=count;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\\\n\tif (buf[cnt-1] == '\\n')\t\t\t\t\t\t\\\n\t\tcnt--;\t\t\t\t\t\t\t\\\n\tif (cnt > ((slen) - 1))\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\tmemcpy(fc_host_##field(shost), buf, cnt);\t\t\t\\\n\ti->f->set_host_##field(shost);\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define fc_host_rd_attr(field, format_string, sz)\t\t\t\\\n\tfc_host_show_function(field, format_string, sz, )\t\t\\\nstatic FC_DEVICE_ATTR(host, field, S_IRUGO,\t\t\t\\\n\t\t\t show_fc_host_##field, NULL)\n\n#define fc_host_rd_attr_cast(field, format_string, sz, cast)\t\t\\\n\tfc_host_show_function(field, format_string, sz, (cast))\t\t\\\nstatic FC_DEVICE_ATTR(host, field, S_IRUGO,\t\t\t\\\n\t\t\t  show_fc_host_##field, NULL)\n\n#define fc_host_rw_attr(field, format_string, sz)\t\t\t\\\n\tfc_host_show_function(field, format_string, sz, )\t\t\\\n\tfc_host_store_function(field)\t\t\t\t\t\\\nstatic FC_DEVICE_ATTR(host, field, S_IRUGO | S_IWUSR,\t\t\\\n\t\t\tshow_fc_host_##field,\t\t\t\t\\\n\t\t\tstore_fc_host_##field)\n\n#define fc_host_rd_enum_attr(title, maxlen)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_fc_host_##title (struct device *dev,\t\t\t\t\\\n\t\t      struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\t\\\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\t\\\n\tconst char *name;\t\t\t\t\t\t\\\n\tif (i->f->get_host_##title)\t\t\t\t\t\\\n\t\ti->f->get_host_##title(shost);\t\t\t\t\\\n\tname = get_fc_##title##_name(fc_host_##title(shost));\t\t\\\n\tif (!name)\t\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\treturn snprintf(buf, maxlen, \"%s\\n\", name);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic FC_DEVICE_ATTR(host, title, S_IRUGO, show_fc_host_##title, NULL)\n\n#define SETUP_HOST_ATTRIBUTE_RD(field)\t\t\t\t\t\\\n\ti->private_host_attrs[count] = device_attr_host_##field;\t\\\n\ti->private_host_attrs[count].attr.mode = S_IRUGO;\t\t\\\n\ti->private_host_attrs[count].store = NULL;\t\t\t\\\n\ti->host_attrs[count] = &i->private_host_attrs[count];\t\t\\\n\tif (i->f->show_host_##field)\t\t\t\t\t\\\n\t\tcount++\n\n#define SETUP_HOST_ATTRIBUTE_RD_NS(field)\t\t\t\t\\\n\ti->private_host_attrs[count] = device_attr_host_##field;\t\\\n\ti->private_host_attrs[count].attr.mode = S_IRUGO;\t\t\\\n\ti->private_host_attrs[count].store = NULL;\t\t\t\\\n\ti->host_attrs[count] = &i->private_host_attrs[count];\t\t\\\n\tcount++\n\n#define SETUP_HOST_ATTRIBUTE_RW(field)\t\t\t\t\t\\\n\ti->private_host_attrs[count] = device_attr_host_##field;\t\\\n\tif (!i->f->set_host_##field) {\t\t\t\t\t\\\n\t\ti->private_host_attrs[count].attr.mode = S_IRUGO;\t\\\n\t\ti->private_host_attrs[count].store = NULL;\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\ti->host_attrs[count] = &i->private_host_attrs[count];\t\t\\\n\tif (i->f->show_host_##field)\t\t\t\t\t\\\n\t\tcount++\n\n\n#define fc_private_host_show_function(field, format_string, sz, cast)\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_fc_host_##field (struct device *dev,\t\t\t\t\\\n\t\t      struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\t\\\n\treturn snprintf(buf, sz, format_string, cast fc_host_##field(shost)); \\\n}\n\n#define fc_private_host_rd_attr(field, format_string, sz)\t\t\\\n\tfc_private_host_show_function(field, format_string, sz, )\t\\\nstatic FC_DEVICE_ATTR(host, field, S_IRUGO,\t\t\t\\\n\t\t\t show_fc_host_##field, NULL)\n\n#define fc_private_host_rd_attr_cast(field, format_string, sz, cast)\t\\\n\tfc_private_host_show_function(field, format_string, sz, (cast)) \\\nstatic FC_DEVICE_ATTR(host, field, S_IRUGO,\t\t\t\\\n\t\t\t  show_fc_host_##field, NULL)\n\n#define SETUP_PRIVATE_HOST_ATTRIBUTE_RD(field)\t\t\t\\\n\ti->private_host_attrs[count] = device_attr_host_##field;\t\\\n\ti->private_host_attrs[count].attr.mode = S_IRUGO;\t\t\\\n\ti->private_host_attrs[count].store = NULL;\t\t\t\\\n\ti->host_attrs[count] = &i->private_host_attrs[count];\t\t\\\n\tcount++\n\n#define SETUP_PRIVATE_HOST_ATTRIBUTE_RW(field)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ti->private_host_attrs[count] = device_attr_host_##field;\t\\\n\ti->host_attrs[count] = &i->private_host_attrs[count];\t\t\\\n\tcount++;\t\t\t\t\t\t\t\\\n}\n\n\n \n\nstatic ssize_t\nshow_fc_host_supported_classes (struct device *dev,\n\t\t\t        struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\n\n\tif (fc_host_supported_classes(shost) == FC_COS_UNSPECIFIED)\n\t\treturn snprintf(buf, 20, \"unspecified\\n\");\n\n\treturn get_fc_cos_names(fc_host_supported_classes(shost), buf);\n}\nstatic FC_DEVICE_ATTR(host, supported_classes, S_IRUGO,\n\t\tshow_fc_host_supported_classes, NULL);\n\nstatic ssize_t\nshow_fc_host_supported_fc4s (struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\n\treturn (ssize_t)show_fc_fc4s(buf, fc_host_supported_fc4s(shost));\n}\nstatic FC_DEVICE_ATTR(host, supported_fc4s, S_IRUGO,\n\t\tshow_fc_host_supported_fc4s, NULL);\n\nstatic ssize_t\nshow_fc_host_supported_speeds (struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\n\n\tif (fc_host_supported_speeds(shost) == FC_PORTSPEED_UNKNOWN)\n\t\treturn snprintf(buf, 20, \"unknown\\n\");\n\n\treturn get_fc_port_speed_names(fc_host_supported_speeds(shost), buf);\n}\nstatic FC_DEVICE_ATTR(host, supported_speeds, S_IRUGO,\n\t\tshow_fc_host_supported_speeds, NULL);\n\n\nfc_private_host_rd_attr_cast(node_name, \"0x%llx\\n\", 20, unsigned long long);\nfc_private_host_rd_attr_cast(port_name, \"0x%llx\\n\", 20, unsigned long long);\nfc_private_host_rd_attr_cast(permanent_port_name, \"0x%llx\\n\", 20,\n\t\t\t     unsigned long long);\nfc_private_host_rd_attr(maxframe_size, \"%u bytes\\n\", 20);\nfc_private_host_rd_attr(max_npiv_vports, \"%u\\n\", 20);\nfc_private_host_rd_attr(serial_number, \"%s\\n\", (FC_SERIAL_NUMBER_SIZE +1));\nfc_private_host_rd_attr(manufacturer, \"%s\\n\", FC_SERIAL_NUMBER_SIZE + 1);\nfc_private_host_rd_attr(model, \"%s\\n\", FC_SYMBOLIC_NAME_SIZE + 1);\nfc_private_host_rd_attr(model_description, \"%s\\n\", FC_SYMBOLIC_NAME_SIZE + 1);\nfc_private_host_rd_attr(hardware_version, \"%s\\n\", FC_VERSION_STRING_SIZE + 1);\nfc_private_host_rd_attr(driver_version, \"%s\\n\", FC_VERSION_STRING_SIZE + 1);\nfc_private_host_rd_attr(firmware_version, \"%s\\n\", FC_VERSION_STRING_SIZE + 1);\nfc_private_host_rd_attr(optionrom_version, \"%s\\n\", FC_VERSION_STRING_SIZE + 1);\n\n\n \n\nstatic ssize_t\nshow_fc_host_active_fc4s (struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\n\tif (i->f->get_host_active_fc4s)\n\t\ti->f->get_host_active_fc4s(shost);\n\n\treturn (ssize_t)show_fc_fc4s(buf, fc_host_active_fc4s(shost));\n}\nstatic FC_DEVICE_ATTR(host, active_fc4s, S_IRUGO,\n\t\tshow_fc_host_active_fc4s, NULL);\n\nstatic ssize_t\nshow_fc_host_speed (struct device *dev,\n\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\n\tif (i->f->get_host_speed)\n\t\ti->f->get_host_speed(shost);\n\n\tif (fc_host_speed(shost) == FC_PORTSPEED_UNKNOWN)\n\t\treturn snprintf(buf, 20, \"unknown\\n\");\n\n\treturn get_fc_port_speed_names(fc_host_speed(shost), buf);\n}\nstatic FC_DEVICE_ATTR(host, speed, S_IRUGO,\n\t\tshow_fc_host_speed, NULL);\n\n\nfc_host_rd_attr(port_id, \"0x%06x\\n\", 20);\nfc_host_rd_enum_attr(port_type, FC_PORTTYPE_MAX_NAMELEN);\nfc_host_rd_enum_attr(port_state, FC_PORTSTATE_MAX_NAMELEN);\nfc_host_rd_attr_cast(fabric_name, \"0x%llx\\n\", 20, unsigned long long);\nfc_host_rd_attr(symbolic_name, \"%s\\n\", FC_SYMBOLIC_NAME_SIZE + 1);\n\nfc_private_host_show_function(system_hostname, \"%s\\n\",\n\t\tFC_SYMBOLIC_NAME_SIZE + 1, )\nfc_host_store_str_function(system_hostname, FC_SYMBOLIC_NAME_SIZE)\nstatic FC_DEVICE_ATTR(host, system_hostname, S_IRUGO | S_IWUSR,\n\t\tshow_fc_host_system_hostname, store_fc_host_system_hostname);\n\n\n \n\nstatic ssize_t\nshow_fc_private_host_tgtid_bind_type(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\n\tconst char *name;\n\n\tname = get_fc_tgtid_bind_type_name(fc_host_tgtid_bind_type(shost));\n\tif (!name)\n\t\treturn -EINVAL;\n\treturn snprintf(buf, FC_BINDTYPE_MAX_NAMELEN, \"%s\\n\", name);\n}\n\n#define get_list_head_entry(pos, head, member) \t\t\\\n\tpos = list_entry((head)->next, typeof(*pos), member)\n\nstatic ssize_t\nstore_fc_private_host_tgtid_bind_type(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\n\tstruct fc_rport *rport;\n \tenum fc_tgtid_binding_type val;\n\tunsigned long flags;\n\n\tif (get_fc_tgtid_bind_type_match(buf, &val))\n\t\treturn -EINVAL;\n\n\t \n\tif (val != fc_host_tgtid_bind_type(shost)) {\n\t\tspin_lock_irqsave(shost->host_lock, flags);\n\t\twhile (!list_empty(&fc_host_rport_bindings(shost))) {\n\t\t\tget_list_head_entry(rport,\n\t\t\t\t&fc_host_rport_bindings(shost), peers);\n\t\t\tlist_del(&rport->peers);\n\t\t\trport->port_state = FC_PORTSTATE_DELETED;\n\t\t\tfc_queue_work(shost, &rport->rport_delete_work);\n\t\t}\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t}\n\n\tfc_host_tgtid_bind_type(shost) = val;\n\treturn count;\n}\n\nstatic FC_DEVICE_ATTR(host, tgtid_bind_type, S_IRUGO | S_IWUSR,\n\t\t\tshow_fc_private_host_tgtid_bind_type,\n\t\t\tstore_fc_private_host_tgtid_bind_type);\n\nstatic ssize_t\nstore_fc_private_host_issue_lip(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\tint ret;\n\n\t \n\tif (i->f->issue_fc_host_lip) {\n\t\tret = i->f->issue_fc_host_lip(shost);\n\t\treturn ret ? ret: count;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic FC_DEVICE_ATTR(host, issue_lip, S_IWUSR, NULL,\n\t\t\tstore_fc_private_host_issue_lip);\n\nstatic ssize_t\nstore_fc_private_host_dev_loss_tmo(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\n\tstruct fc_rport *rport;\n\tunsigned long val, flags;\n\tint rc;\n\n\trc = fc_str_to_dev_loss(buf, &val);\n\tif (rc)\n\t\treturn rc;\n\n\tfc_host_dev_loss_tmo(shost) = val;\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tlist_for_each_entry(rport, &fc_host->rports, peers)\n\t\tfc_rport_set_dev_loss_tmo(rport, val);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\treturn count;\n}\n\nfc_private_host_show_function(dev_loss_tmo, \"%d\\n\", 20, );\nstatic FC_DEVICE_ATTR(host, dev_loss_tmo, S_IRUGO | S_IWUSR,\n\t\t      show_fc_host_dev_loss_tmo,\n\t\t      store_fc_private_host_dev_loss_tmo);\n\nfc_private_host_rd_attr(npiv_vports_inuse, \"%u\\n\", 20);\n\n \n\n \nstatic ssize_t\nfc_stat_show(const struct device *dev, char *buf, unsigned long offset)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\tstruct fc_host_statistics *stats;\n\tssize_t ret = -ENOENT;\n\n\tif (offset > sizeof(struct fc_host_statistics) ||\n\t    offset % sizeof(u64) != 0)\n\t\tWARN_ON(1);\n\n\tif (i->f->get_fc_host_stats) {\n\t\tstats = (i->f->get_fc_host_stats)(shost);\n\t\tif (stats)\n\t\t\tret = snprintf(buf, 20, \"0x%llx\\n\",\n\t\t\t      (unsigned long long)*(u64 *)(((u8 *) stats) + offset));\n\t}\n\treturn ret;\n}\n\n\n \n#define fc_host_statistic(name)\t\t\t\t\t\t\\\nstatic ssize_t show_fcstat_##name(struct device *cd,\t\t\t\\\n\t\t\t\t  struct device_attribute *attr,\t\\\n\t\t\t\t  char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn fc_stat_show(cd, buf, \t\t\t\t\t\\\n\t\t\t    offsetof(struct fc_host_statistics, name));\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic FC_DEVICE_ATTR(host, name, S_IRUGO, show_fcstat_##name, NULL)\n\nfc_host_statistic(seconds_since_last_reset);\nfc_host_statistic(tx_frames);\nfc_host_statistic(tx_words);\nfc_host_statistic(rx_frames);\nfc_host_statistic(rx_words);\nfc_host_statistic(lip_count);\nfc_host_statistic(nos_count);\nfc_host_statistic(error_frames);\nfc_host_statistic(dumped_frames);\nfc_host_statistic(link_failure_count);\nfc_host_statistic(loss_of_sync_count);\nfc_host_statistic(loss_of_signal_count);\nfc_host_statistic(prim_seq_protocol_err_count);\nfc_host_statistic(invalid_tx_word_count);\nfc_host_statistic(invalid_crc_count);\nfc_host_statistic(fcp_input_requests);\nfc_host_statistic(fcp_output_requests);\nfc_host_statistic(fcp_control_requests);\nfc_host_statistic(fcp_input_megabytes);\nfc_host_statistic(fcp_output_megabytes);\nfc_host_statistic(fcp_packet_alloc_failures);\nfc_host_statistic(fcp_packet_aborts);\nfc_host_statistic(fcp_frame_alloc_failures);\nfc_host_statistic(fc_no_free_exch);\nfc_host_statistic(fc_no_free_exch_xid);\nfc_host_statistic(fc_xid_not_found);\nfc_host_statistic(fc_xid_busy);\nfc_host_statistic(fc_seq_not_found);\nfc_host_statistic(fc_non_bls_resp);\nfc_host_statistic(cn_sig_warn);\nfc_host_statistic(cn_sig_alarm);\n\n\n#define fc_host_fpin_statistic(name)\t\t\t\t\t\\\nstatic ssize_t fc_host_fpinstat_##name(struct device *cd,\t\t\\\n\t\t\t\t  struct device_attribute *attr,\t\\\n\t\t\t\t  char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct Scsi_Host *shost = transport_class_to_shost(cd);\t\t\\\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn snprintf(buf, 20, \"0x%llx\\n\", fc_host->fpin_stats.name);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic FC_DEVICE_ATTR(host, fpin_##name, 0444, fc_host_fpinstat_##name, NULL)\n\nfc_host_fpin_statistic(dn);\nfc_host_fpin_statistic(dn_unknown);\nfc_host_fpin_statistic(dn_timeout);\nfc_host_fpin_statistic(dn_unable_to_route);\nfc_host_fpin_statistic(dn_device_specific);\nfc_host_fpin_statistic(cn);\nfc_host_fpin_statistic(cn_clear);\nfc_host_fpin_statistic(cn_lost_credit);\nfc_host_fpin_statistic(cn_credit_stall);\nfc_host_fpin_statistic(cn_oversubscription);\nfc_host_fpin_statistic(cn_device_specific);\nfc_host_fpin_statistic(li);\nfc_host_fpin_statistic(li_failure_unknown);\nfc_host_fpin_statistic(li_link_failure_count);\nfc_host_fpin_statistic(li_loss_of_sync_count);\nfc_host_fpin_statistic(li_loss_of_signals_count);\nfc_host_fpin_statistic(li_prim_seq_err_count);\nfc_host_fpin_statistic(li_invalid_tx_word_count);\nfc_host_fpin_statistic(li_invalid_crc_count);\nfc_host_fpin_statistic(li_device_specific);\n\nstatic ssize_t\nfc_reset_statistics(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\n\t \n\tif (i->f->reset_fc_host_stats) {\n\t\ti->f->reset_fc_host_stats(shost);\n\t\treturn count;\n\t}\n\n\treturn -ENOENT;\n}\nstatic FC_DEVICE_ATTR(host, reset_statistics, S_IWUSR, NULL,\n\t\t\t\tfc_reset_statistics);\n\nstatic struct attribute *fc_statistics_attrs[] = {\n\t&device_attr_host_seconds_since_last_reset.attr,\n\t&device_attr_host_tx_frames.attr,\n\t&device_attr_host_tx_words.attr,\n\t&device_attr_host_rx_frames.attr,\n\t&device_attr_host_rx_words.attr,\n\t&device_attr_host_lip_count.attr,\n\t&device_attr_host_nos_count.attr,\n\t&device_attr_host_error_frames.attr,\n\t&device_attr_host_dumped_frames.attr,\n\t&device_attr_host_link_failure_count.attr,\n\t&device_attr_host_loss_of_sync_count.attr,\n\t&device_attr_host_loss_of_signal_count.attr,\n\t&device_attr_host_prim_seq_protocol_err_count.attr,\n\t&device_attr_host_invalid_tx_word_count.attr,\n\t&device_attr_host_invalid_crc_count.attr,\n\t&device_attr_host_fcp_input_requests.attr,\n\t&device_attr_host_fcp_output_requests.attr,\n\t&device_attr_host_fcp_control_requests.attr,\n\t&device_attr_host_fcp_input_megabytes.attr,\n\t&device_attr_host_fcp_output_megabytes.attr,\n\t&device_attr_host_fcp_packet_alloc_failures.attr,\n\t&device_attr_host_fcp_packet_aborts.attr,\n\t&device_attr_host_fcp_frame_alloc_failures.attr,\n\t&device_attr_host_fc_no_free_exch.attr,\n\t&device_attr_host_fc_no_free_exch_xid.attr,\n\t&device_attr_host_fc_xid_not_found.attr,\n\t&device_attr_host_fc_xid_busy.attr,\n\t&device_attr_host_fc_seq_not_found.attr,\n\t&device_attr_host_fc_non_bls_resp.attr,\n\t&device_attr_host_cn_sig_warn.attr,\n\t&device_attr_host_cn_sig_alarm.attr,\n\t&device_attr_host_reset_statistics.attr,\n\t&device_attr_host_fpin_dn.attr,\n\t&device_attr_host_fpin_dn_unknown.attr,\n\t&device_attr_host_fpin_dn_timeout.attr,\n\t&device_attr_host_fpin_dn_unable_to_route.attr,\n\t&device_attr_host_fpin_dn_device_specific.attr,\n\t&device_attr_host_fpin_li.attr,\n\t&device_attr_host_fpin_li_failure_unknown.attr,\n\t&device_attr_host_fpin_li_link_failure_count.attr,\n\t&device_attr_host_fpin_li_loss_of_sync_count.attr,\n\t&device_attr_host_fpin_li_loss_of_signals_count.attr,\n\t&device_attr_host_fpin_li_prim_seq_err_count.attr,\n\t&device_attr_host_fpin_li_invalid_tx_word_count.attr,\n\t&device_attr_host_fpin_li_invalid_crc_count.attr,\n\t&device_attr_host_fpin_li_device_specific.attr,\n\t&device_attr_host_fpin_cn.attr,\n\t&device_attr_host_fpin_cn_clear.attr,\n\t&device_attr_host_fpin_cn_lost_credit.attr,\n\t&device_attr_host_fpin_cn_credit_stall.attr,\n\t&device_attr_host_fpin_cn_oversubscription.attr,\n\t&device_attr_host_fpin_cn_device_specific.attr,\n\tNULL\n};\n\nstatic struct attribute_group fc_statistics_group = {\n\t.name = \"statistics\",\n\t.attrs = fc_statistics_attrs,\n};\n\n\n \n\nstatic int\nfc_parse_wwn(const char *ns, u64 *nm)\n{\n\tunsigned int i, j;\n\tu8 wwn[8];\n\n\tmemset(wwn, 0, sizeof(wwn));\n\n\t \n\tfor (i=0, j=0; i < 16; i++) {\n\t\tint value;\n\n\t\tvalue = hex_to_bin(*ns++);\n\t\tif (value >= 0)\n\t\t\tj = (j << 4) | value;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tif (i % 2) {\n\t\t\twwn[i/2] = j & 0xff;\n\t\t\tj = 0;\n\t\t}\n\t}\n\n\t*nm = wwn_to_u64(wwn);\n\n\treturn 0;\n}\n\n\n \nstatic ssize_t\nstore_fc_host_vport_create(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\n\tstruct fc_vport_identifiers vid;\n\tstruct fc_vport *vport;\n\tunsigned int cnt=count;\n\tint stat;\n\n\tmemset(&vid, 0, sizeof(vid));\n\n\t \n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\n\t \n\tif ((cnt != (16+1+16)) || (buf[16] != ':'))\n\t\treturn -EINVAL;\n\n\tstat = fc_parse_wwn(&buf[0], &vid.port_name);\n\tif (stat)\n\t\treturn stat;\n\n\tstat = fc_parse_wwn(&buf[17], &vid.node_name);\n\tif (stat)\n\t\treturn stat;\n\n\tvid.roles = FC_PORT_ROLE_FCP_INITIATOR;\n\tvid.vport_type = FC_PORTTYPE_NPIV;\n\t \n\tvid.disable = false;\t\t \n\n\t \n\tstat = fc_vport_setup(shost, 0, &shost->shost_gendev, &vid, &vport);\n\treturn stat ? stat : count;\n}\nstatic FC_DEVICE_ATTR(host, vport_create, S_IWUSR, NULL,\n\t\t\tstore_fc_host_vport_create);\n\n\n \nstatic ssize_t\nstore_fc_host_vport_delete(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\n\tstruct fc_vport *vport;\n\tu64 wwpn, wwnn;\n\tunsigned long flags;\n\tunsigned int cnt=count;\n\tint stat, match;\n\n\t \n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\n\t \n\tif ((cnt != (16+1+16)) || (buf[16] != ':'))\n\t\treturn -EINVAL;\n\n\tstat = fc_parse_wwn(&buf[0], &wwpn);\n\tif (stat)\n\t\treturn stat;\n\n\tstat = fc_parse_wwn(&buf[17], &wwnn);\n\tif (stat)\n\t\treturn stat;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tmatch = 0;\n\t \n\tlist_for_each_entry(vport, &fc_host->vports, peers) {\n\t\tif ((vport->channel == 0) &&\n\t\t    (vport->port_name == wwpn) && (vport->node_name == wwnn)) {\n\t\t\tif (vport->flags & (FC_VPORT_DEL | FC_VPORT_CREATING))\n\t\t\t\tbreak;\n\t\t\tvport->flags |= FC_VPORT_DELETING;\n\t\t\tmatch = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tstat = fc_vport_terminate(vport);\n\treturn stat ? stat : count;\n}\nstatic FC_DEVICE_ATTR(host, vport_delete, S_IWUSR, NULL,\n\t\t\tstore_fc_host_vport_delete);\n\n\nstatic int fc_host_match(struct attribute_container *cont,\n\t\t\t  struct device *dev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct fc_internal *i;\n\n\tif (!scsi_is_host_device(dev))\n\t\treturn 0;\n\n\tshost = dev_to_shost(dev);\n\tif (!shost->transportt  || shost->transportt->host_attrs.ac.class\n\t    != &fc_host_class.class)\n\t\treturn 0;\n\n\ti = to_fc_internal(shost->transportt);\n\n\treturn &i->t.host_attrs.ac == cont;\n}\n\nstatic int fc_target_match(struct attribute_container *cont,\n\t\t\t    struct device *dev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct fc_internal *i;\n\n\tif (!scsi_is_target_device(dev))\n\t\treturn 0;\n\n\tshost = dev_to_shost(dev->parent);\n\tif (!shost->transportt  || shost->transportt->host_attrs.ac.class\n\t    != &fc_host_class.class)\n\t\treturn 0;\n\n\ti = to_fc_internal(shost->transportt);\n\n\treturn &i->t.target_attrs.ac == cont;\n}\n\nstatic void fc_rport_dev_release(struct device *dev)\n{\n\tstruct fc_rport *rport = dev_to_rport(dev);\n\tput_device(dev->parent);\n\tkfree(rport);\n}\n\nint scsi_is_fc_rport(const struct device *dev)\n{\n\treturn dev->release == fc_rport_dev_release;\n}\nEXPORT_SYMBOL(scsi_is_fc_rport);\n\nstatic int fc_rport_match(struct attribute_container *cont,\n\t\t\t    struct device *dev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct fc_internal *i;\n\n\tif (!scsi_is_fc_rport(dev))\n\t\treturn 0;\n\n\tshost = dev_to_shost(dev->parent);\n\tif (!shost->transportt  || shost->transportt->host_attrs.ac.class\n\t    != &fc_host_class.class)\n\t\treturn 0;\n\n\ti = to_fc_internal(shost->transportt);\n\n\treturn &i->rport_attr_cont.ac == cont;\n}\n\n\nstatic void fc_vport_dev_release(struct device *dev)\n{\n\tstruct fc_vport *vport = dev_to_vport(dev);\n\tput_device(dev->parent);\t\t \n\tkfree(vport);\n}\n\nstatic int scsi_is_fc_vport(const struct device *dev)\n{\n\treturn dev->release == fc_vport_dev_release;\n}\n\nstatic int fc_vport_match(struct attribute_container *cont,\n\t\t\t    struct device *dev)\n{\n\tstruct fc_vport *vport;\n\tstruct Scsi_Host *shost;\n\tstruct fc_internal *i;\n\n\tif (!scsi_is_fc_vport(dev))\n\t\treturn 0;\n\tvport = dev_to_vport(dev);\n\n\tshost = vport_to_shost(vport);\n\tif (!shost->transportt  || shost->transportt->host_attrs.ac.class\n\t    != &fc_host_class.class)\n\t\treturn 0;\n\n\ti = to_fc_internal(shost->transportt);\n\treturn &i->vport_attr_cont.ac == cont;\n}\n\n\n \nenum scsi_timeout_action fc_eh_timed_out(struct scsi_cmnd *scmd)\n{\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(scmd->device));\n\n\tif (rport->port_state == FC_PORTSTATE_BLOCKED)\n\t\treturn SCSI_EH_RESET_TIMER;\n\n\treturn SCSI_EH_NOT_HANDLED;\n}\nEXPORT_SYMBOL(fc_eh_timed_out);\n\n \nstatic void\nfc_user_scan_tgt(struct Scsi_Host *shost, uint channel, uint id, u64 lun)\n{\n\tstruct fc_rport *rport;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\n\tlist_for_each_entry(rport, &fc_host_rports(shost), peers) {\n\t\tif (rport->scsi_target_id == -1)\n\t\t\tcontinue;\n\n\t\tif ((rport->port_state != FC_PORTSTATE_ONLINE) &&\n\t\t\t(rport->port_state != FC_PORTSTATE_MARGINAL))\n\t\t\tcontinue;\n\n\t\tif ((channel == rport->channel) &&\n\t\t    (id == rport->scsi_target_id)) {\n\t\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\t\tscsi_scan_target(&rport->dev, channel, id, lun,\n\t\t\t\t\t SCSI_SCAN_MANUAL);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n}\n\n \nstatic int\nfc_user_scan(struct Scsi_Host *shost, uint channel, uint id, u64 lun)\n{\n\tuint chlo, chhi;\n\tuint tgtlo, tgthi;\n\n\tif (((channel != SCAN_WILD_CARD) && (channel > shost->max_channel)) ||\n\t    ((id != SCAN_WILD_CARD) && (id >= shost->max_id)) ||\n\t    ((lun != SCAN_WILD_CARD) && (lun > shost->max_lun)))\n\t\treturn -EINVAL;\n\n\tif (channel == SCAN_WILD_CARD) {\n\t\tchlo = 0;\n\t\tchhi = shost->max_channel + 1;\n\t} else {\n\t\tchlo = channel;\n\t\tchhi = channel + 1;\n\t}\n\n\tif (id == SCAN_WILD_CARD) {\n\t\ttgtlo = 0;\n\t\ttgthi = shost->max_id;\n\t} else {\n\t\ttgtlo = id;\n\t\ttgthi = id + 1;\n\t}\n\n\tfor ( ; chlo < chhi; chlo++)\n\t\tfor ( ; tgtlo < tgthi; tgtlo++)\n\t\t\tfc_user_scan_tgt(shost, chlo, tgtlo, lun);\n\n\treturn 0;\n}\n\nstruct scsi_transport_template *\nfc_attach_transport(struct fc_function_template *ft)\n{\n\tint count;\n\tstruct fc_internal *i = kzalloc(sizeof(struct fc_internal),\n\t\t\t\t\tGFP_KERNEL);\n\n\tif (unlikely(!i))\n\t\treturn NULL;\n\n\ti->t.target_attrs.ac.attrs = &i->starget_attrs[0];\n\ti->t.target_attrs.ac.class = &fc_transport_class.class;\n\ti->t.target_attrs.ac.match = fc_target_match;\n\ti->t.target_size = sizeof(struct fc_starget_attrs);\n\ttransport_container_register(&i->t.target_attrs);\n\n\ti->t.host_attrs.ac.attrs = &i->host_attrs[0];\n\ti->t.host_attrs.ac.class = &fc_host_class.class;\n\ti->t.host_attrs.ac.match = fc_host_match;\n\ti->t.host_size = sizeof(struct fc_host_attrs);\n\tif (ft->get_fc_host_stats)\n\t\ti->t.host_attrs.statistics = &fc_statistics_group;\n\ttransport_container_register(&i->t.host_attrs);\n\n\ti->rport_attr_cont.ac.attrs = &i->rport_attrs[0];\n\ti->rport_attr_cont.ac.class = &fc_rport_class.class;\n\ti->rport_attr_cont.ac.match = fc_rport_match;\n\ti->rport_attr_cont.statistics = &fc_rport_statistics_group;\n\ttransport_container_register(&i->rport_attr_cont);\n\n\ti->vport_attr_cont.ac.attrs = &i->vport_attrs[0];\n\ti->vport_attr_cont.ac.class = &fc_vport_class.class;\n\ti->vport_attr_cont.ac.match = fc_vport_match;\n\ttransport_container_register(&i->vport_attr_cont);\n\n\ti->f = ft;\n\n\t \n\ti->t.create_work_queue = 1;\n\n\ti->t.user_scan = fc_user_scan;\n\n\t \n\tcount = 0;\n\tSETUP_STARGET_ATTRIBUTE_RD(node_name);\n\tSETUP_STARGET_ATTRIBUTE_RD(port_name);\n\tSETUP_STARGET_ATTRIBUTE_RD(port_id);\n\n\tBUG_ON(count > FC_STARGET_NUM_ATTRS);\n\n\ti->starget_attrs[count] = NULL;\n\n\n\t \n\tcount=0;\n\tSETUP_HOST_ATTRIBUTE_RD(node_name);\n\tSETUP_HOST_ATTRIBUTE_RD(port_name);\n\tSETUP_HOST_ATTRIBUTE_RD(permanent_port_name);\n\tSETUP_HOST_ATTRIBUTE_RD(supported_classes);\n\tSETUP_HOST_ATTRIBUTE_RD(supported_fc4s);\n\tSETUP_HOST_ATTRIBUTE_RD(supported_speeds);\n\tSETUP_HOST_ATTRIBUTE_RD(maxframe_size);\n\tif (ft->vport_create) {\n\t\tSETUP_HOST_ATTRIBUTE_RD_NS(max_npiv_vports);\n\t\tSETUP_HOST_ATTRIBUTE_RD_NS(npiv_vports_inuse);\n\t}\n\tSETUP_HOST_ATTRIBUTE_RD(serial_number);\n\tSETUP_HOST_ATTRIBUTE_RD(manufacturer);\n\tSETUP_HOST_ATTRIBUTE_RD(model);\n\tSETUP_HOST_ATTRIBUTE_RD(model_description);\n\tSETUP_HOST_ATTRIBUTE_RD(hardware_version);\n\tSETUP_HOST_ATTRIBUTE_RD(driver_version);\n\tSETUP_HOST_ATTRIBUTE_RD(firmware_version);\n\tSETUP_HOST_ATTRIBUTE_RD(optionrom_version);\n\n\tSETUP_HOST_ATTRIBUTE_RD(port_id);\n\tSETUP_HOST_ATTRIBUTE_RD(port_type);\n\tSETUP_HOST_ATTRIBUTE_RD(port_state);\n\tSETUP_HOST_ATTRIBUTE_RD(active_fc4s);\n\tSETUP_HOST_ATTRIBUTE_RD(speed);\n\tSETUP_HOST_ATTRIBUTE_RD(fabric_name);\n\tSETUP_HOST_ATTRIBUTE_RD(symbolic_name);\n\tSETUP_HOST_ATTRIBUTE_RW(system_hostname);\n\n\t \n\tSETUP_PRIVATE_HOST_ATTRIBUTE_RW(dev_loss_tmo);\n\tSETUP_PRIVATE_HOST_ATTRIBUTE_RW(tgtid_bind_type);\n\tif (ft->issue_fc_host_lip)\n\t\tSETUP_PRIVATE_HOST_ATTRIBUTE_RW(issue_lip);\n\tif (ft->vport_create)\n\t\tSETUP_PRIVATE_HOST_ATTRIBUTE_RW(vport_create);\n\tif (ft->vport_delete)\n\t\tSETUP_PRIVATE_HOST_ATTRIBUTE_RW(vport_delete);\n\n\tBUG_ON(count > FC_HOST_NUM_ATTRS);\n\n\ti->host_attrs[count] = NULL;\n\n\t \n\tcount=0;\n\tSETUP_RPORT_ATTRIBUTE_RD(maxframe_size);\n\tSETUP_RPORT_ATTRIBUTE_RD(supported_classes);\n\tSETUP_RPORT_ATTRIBUTE_RW(dev_loss_tmo);\n\tSETUP_PRIVATE_RPORT_ATTRIBUTE_RD(node_name);\n\tSETUP_PRIVATE_RPORT_ATTRIBUTE_RD(port_name);\n\tSETUP_PRIVATE_RPORT_ATTRIBUTE_RD(port_id);\n\tSETUP_PRIVATE_RPORT_ATTRIBUTE_RD(roles);\n\tSETUP_PRIVATE_RPORT_ATTRIBUTE_RW(port_state);\n\tSETUP_PRIVATE_RPORT_ATTRIBUTE_RD(scsi_target_id);\n\tSETUP_PRIVATE_RPORT_ATTRIBUTE_RW(fast_io_fail_tmo);\n\n\tBUG_ON(count > FC_RPORT_NUM_ATTRS);\n\n\ti->rport_attrs[count] = NULL;\n\n\t \n\tcount=0;\n\tSETUP_PRIVATE_VPORT_ATTRIBUTE_RD(vport_state);\n\tSETUP_PRIVATE_VPORT_ATTRIBUTE_RD(vport_last_state);\n\tSETUP_PRIVATE_VPORT_ATTRIBUTE_RD(node_name);\n\tSETUP_PRIVATE_VPORT_ATTRIBUTE_RD(port_name);\n\tSETUP_PRIVATE_VPORT_ATTRIBUTE_RD(roles);\n\tSETUP_PRIVATE_VPORT_ATTRIBUTE_RD(vport_type);\n\tSETUP_VPORT_ATTRIBUTE_RW(symbolic_name);\n\tSETUP_VPORT_ATTRIBUTE_WR(vport_delete);\n\tSETUP_VPORT_ATTRIBUTE_WR(vport_disable);\n\n\tBUG_ON(count > FC_VPORT_NUM_ATTRS);\n\n\ti->vport_attrs[count] = NULL;\n\n\treturn &i->t;\n}\nEXPORT_SYMBOL(fc_attach_transport);\n\nvoid fc_release_transport(struct scsi_transport_template *t)\n{\n\tstruct fc_internal *i = to_fc_internal(t);\n\n\ttransport_container_unregister(&i->t.target_attrs);\n\ttransport_container_unregister(&i->t.host_attrs);\n\ttransport_container_unregister(&i->rport_attr_cont);\n\ttransport_container_unregister(&i->vport_attr_cont);\n\n\tkfree(i);\n}\nEXPORT_SYMBOL(fc_release_transport);\n\n \nstatic int\nfc_queue_work(struct Scsi_Host *shost, struct work_struct *work)\n{\n\tif (unlikely(!fc_host_work_q(shost))) {\n\t\tprintk(KERN_ERR\n\t\t\t\"ERROR: FC host '%s' attempted to queue work, \"\n\t\t\t\"when no workqueue created.\\n\", shost->hostt->name);\n\t\tdump_stack();\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn queue_work(fc_host_work_q(shost), work);\n}\n\n \nstatic void\nfc_flush_work(struct Scsi_Host *shost)\n{\n\tif (!fc_host_work_q(shost)) {\n\t\tprintk(KERN_ERR\n\t\t\t\"ERROR: FC host '%s' attempted to flush work, \"\n\t\t\t\"when no workqueue created.\\n\", shost->hostt->name);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\tflush_workqueue(fc_host_work_q(shost));\n}\n\n \nstatic int\nfc_queue_devloss_work(struct Scsi_Host *shost, struct delayed_work *work,\n\t\t\t\tunsigned long delay)\n{\n\tif (unlikely(!fc_host_devloss_work_q(shost))) {\n\t\tprintk(KERN_ERR\n\t\t\t\"ERROR: FC host '%s' attempted to queue work, \"\n\t\t\t\"when no workqueue created.\\n\", shost->hostt->name);\n\t\tdump_stack();\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn queue_delayed_work(fc_host_devloss_work_q(shost), work, delay);\n}\n\n \nstatic void\nfc_flush_devloss(struct Scsi_Host *shost)\n{\n\tif (!fc_host_devloss_work_q(shost)) {\n\t\tprintk(KERN_ERR\n\t\t\t\"ERROR: FC host '%s' attempted to flush work, \"\n\t\t\t\"when no workqueue created.\\n\", shost->hostt->name);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\tflush_workqueue(fc_host_devloss_work_q(shost));\n}\n\n\n \nvoid\nfc_remove_host(struct Scsi_Host *shost)\n{\n\tstruct fc_vport *vport = NULL, *next_vport = NULL;\n\tstruct fc_rport *rport = NULL, *next_rport = NULL;\n\tstruct workqueue_struct *work_q;\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\n\t \n\tlist_for_each_entry_safe(vport, next_vport, &fc_host->vports, peers) {\n\t\tvport->flags |= FC_VPORT_DELETING;\n\t\tfc_queue_work(shost, &vport->vport_delete_work);\n\t}\n\n\t \n\tlist_for_each_entry_safe(rport, next_rport,\n\t\t\t&fc_host->rports, peers) {\n\t\tlist_del(&rport->peers);\n\t\trport->port_state = FC_PORTSTATE_DELETED;\n\t\tfc_queue_work(shost, &rport->rport_delete_work);\n\t}\n\n\tlist_for_each_entry_safe(rport, next_rport,\n\t\t\t&fc_host->rport_bindings, peers) {\n\t\tlist_del(&rport->peers);\n\t\trport->port_state = FC_PORTSTATE_DELETED;\n\t\tfc_queue_work(shost, &rport->rport_delete_work);\n\t}\n\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\t \n\tscsi_flush_work(shost);\n\n\t \n\tif (fc_host->work_q) {\n\t\twork_q = fc_host->work_q;\n\t\tfc_host->work_q = NULL;\n\t\tdestroy_workqueue(work_q);\n\t}\n\n\t \n\tif (fc_host->devloss_work_q) {\n\t\twork_q = fc_host->devloss_work_q;\n\t\tfc_host->devloss_work_q = NULL;\n\t\tdestroy_workqueue(work_q);\n\t}\n}\nEXPORT_SYMBOL(fc_remove_host);\n\nstatic void fc_terminate_rport_io(struct fc_rport *rport)\n{\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\n\t \n\tif (i->f->terminate_rport_io)\n\t\ti->f->terminate_rport_io(rport);\n\n\t \n\tscsi_target_unblock(&rport->dev, SDEV_TRANSPORT_OFFLINE);\n}\n\n \nstatic void\nfc_starget_delete(struct work_struct *work)\n{\n\tstruct fc_rport *rport =\n\t\tcontainer_of(work, struct fc_rport, stgt_delete_work);\n\n\tfc_terminate_rport_io(rport);\n\tscsi_remove_target(&rport->dev);\n}\n\n\n \nstatic void\nfc_rport_final_delete(struct work_struct *work)\n{\n\tstruct fc_rport *rport =\n\t\tcontainer_of(work, struct fc_rport, rport_delete_work);\n\tstruct device *dev = &rport->dev;\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\tunsigned long flags;\n\tint do_callback = 0;\n\n\tfc_terminate_rport_io(rport);\n\n\t \n\tif (rport->flags & FC_RPORT_SCAN_PENDING)\n\t\tscsi_flush_work(shost);\n\n\t \n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (rport->flags & FC_RPORT_DEVLOSS_PENDING) {\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\tif (!cancel_delayed_work(&rport->fail_io_work))\n\t\t\tfc_flush_devloss(shost);\n\t\tif (!cancel_delayed_work(&rport->dev_loss_work))\n\t\t\tfc_flush_devloss(shost);\n\t\tcancel_work_sync(&rport->scan_work);\n\t\tspin_lock_irqsave(shost->host_lock, flags);\n\t\trport->flags &= ~FC_RPORT_DEVLOSS_PENDING;\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\t \n\tif (rport->scsi_target_id != -1)\n\t\tfc_starget_delete(&rport->stgt_delete_work);\n\n\t \n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (!(rport->flags & FC_RPORT_DEVLOSS_CALLBK_DONE) &&\n\t    (i->f->dev_loss_tmo_callbk)) {\n\t\trport->flags |= FC_RPORT_DEVLOSS_CALLBK_DONE;\n\t\tdo_callback = 1;\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tif (do_callback)\n\t\ti->f->dev_loss_tmo_callbk(rport);\n\n\tfc_bsg_remove(rport->rqst_q);\n\n\ttransport_remove_device(dev);\n\tdevice_del(dev);\n\ttransport_destroy_device(dev);\n\tscsi_host_put(shost);\t\t\t \n\tput_device(dev);\t\t\t \n}\n\n\n \nstatic struct fc_rport *\nfc_remote_port_create(struct Scsi_Host *shost, int channel,\n\t\t      struct fc_rport_identifiers  *ids)\n{\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\n\tstruct fc_internal *fci = to_fc_internal(shost->transportt);\n\tstruct fc_rport *rport;\n\tstruct device *dev;\n\tunsigned long flags;\n\tint error;\n\tsize_t size;\n\n\tsize = (sizeof(struct fc_rport) + fci->f->dd_fcrport_size);\n\trport = kzalloc(size, GFP_KERNEL);\n\tif (unlikely(!rport)) {\n\t\tprintk(KERN_ERR \"%s: allocation failure\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\trport->maxframe_size = -1;\n\trport->supported_classes = FC_COS_UNSPECIFIED;\n\trport->dev_loss_tmo = fc_host->dev_loss_tmo;\n\tmemcpy(&rport->node_name, &ids->node_name, sizeof(rport->node_name));\n\tmemcpy(&rport->port_name, &ids->port_name, sizeof(rport->port_name));\n\trport->port_id = ids->port_id;\n\trport->roles = ids->roles;\n\trport->port_state = FC_PORTSTATE_ONLINE;\n\tif (fci->f->dd_fcrport_size)\n\t\trport->dd_data = &rport[1];\n\trport->channel = channel;\n\trport->fast_io_fail_tmo = -1;\n\n\tINIT_DELAYED_WORK(&rport->dev_loss_work, fc_timeout_deleted_rport);\n\tINIT_DELAYED_WORK(&rport->fail_io_work, fc_timeout_fail_rport_io);\n\tINIT_WORK(&rport->scan_work, fc_scsi_scan_rport);\n\tINIT_WORK(&rport->stgt_delete_work, fc_starget_delete);\n\tINIT_WORK(&rport->rport_delete_work, fc_rport_final_delete);\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\n\trport->number = fc_host->next_rport_number++;\n\tif ((rport->roles & FC_PORT_ROLE_FCP_TARGET) ||\n\t    (rport->roles & FC_PORT_ROLE_FCP_DUMMY_INITIATOR))\n\t\trport->scsi_target_id = fc_host->next_target_id++;\n\telse\n\t\trport->scsi_target_id = -1;\n\tlist_add_tail(&rport->peers, &fc_host->rports);\n\tscsi_host_get(shost);\t\t\t \n\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tdev = &rport->dev;\n\tdevice_initialize(dev);\t\t\t \n\tdev->parent = get_device(&shost->shost_gendev);  \n\tdev->release = fc_rport_dev_release;\n\tdev_set_name(dev, \"rport-%d:%d-%d\",\n\t\t     shost->host_no, channel, rport->number);\n\ttransport_setup_device(dev);\n\n\terror = device_add(dev);\n\tif (error) {\n\t\tprintk(KERN_ERR \"FC Remote Port device_add failed\\n\");\n\t\tgoto delete_rport;\n\t}\n\ttransport_add_device(dev);\n\ttransport_configure_device(dev);\n\n\tfc_bsg_rportadd(shost, rport);\n\t \n\n\tif (rport->roles & FC_PORT_ROLE_FCP_TARGET) {\n\t\t \n\t\trport->flags |= FC_RPORT_SCAN_PENDING;\n\t\tscsi_queue_work(shost, &rport->scan_work);\n\t}\n\n\treturn rport;\n\ndelete_rport:\n\ttransport_destroy_device(dev);\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tlist_del(&rport->peers);\n\tscsi_host_put(shost);\t\t\t \n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\tput_device(dev->parent);\n\tkfree(rport);\n\treturn NULL;\n}\n\n \nstruct fc_rport *\nfc_remote_port_add(struct Scsi_Host *shost, int channel,\n\tstruct fc_rport_identifiers  *ids)\n{\n\tstruct fc_internal *fci = to_fc_internal(shost->transportt);\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\n\tstruct fc_rport *rport;\n\tunsigned long flags;\n\tint match = 0;\n\n\t \n\tfc_flush_work(shost);\n\n\t \n\tspin_lock_irqsave(shost->host_lock, flags);\n\n\tlist_for_each_entry(rport, &fc_host->rports, peers) {\n\n\t\tif ((rport->port_state == FC_PORTSTATE_BLOCKED ||\n\t\t     rport->port_state == FC_PORTSTATE_NOTPRESENT) &&\n\t\t\t(rport->channel == channel)) {\n\n\t\t\tswitch (fc_host->tgtid_bind_type) {\n\t\t\tcase FC_TGTID_BIND_BY_WWPN:\n\t\t\tcase FC_TGTID_BIND_NONE:\n\t\t\t\tif (rport->port_name == ids->port_name)\n\t\t\t\t\tmatch = 1;\n\t\t\t\tbreak;\n\t\t\tcase FC_TGTID_BIND_BY_WWNN:\n\t\t\t\tif (rport->node_name == ids->node_name)\n\t\t\t\t\tmatch = 1;\n\t\t\t\tbreak;\n\t\t\tcase FC_TGTID_BIND_BY_ID:\n\t\t\t\tif (rport->port_id == ids->port_id)\n\t\t\t\t\tmatch = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (match) {\n\n\t\t\t\tmemcpy(&rport->node_name, &ids->node_name,\n\t\t\t\t\tsizeof(rport->node_name));\n\t\t\t\tmemcpy(&rport->port_name, &ids->port_name,\n\t\t\t\t\tsizeof(rport->port_name));\n\t\t\t\trport->port_id = ids->port_id;\n\n\t\t\t\trport->port_state = FC_PORTSTATE_ONLINE;\n\t\t\t\trport->roles = ids->roles;\n\n\t\t\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\t\t\t\tif (fci->f->dd_fcrport_size)\n\t\t\t\t\tmemset(rport->dd_data, 0,\n\t\t\t\t\t\tfci->f->dd_fcrport_size);\n\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\tif ((rport->scsi_target_id != -1) &&\n\t\t\t\t    (!(ids->roles & FC_PORT_ROLE_FCP_TARGET)))\n\t\t\t\t\treturn rport;\n\n\t\t\t\t \n\t\t\t\tif (!cancel_delayed_work(&rport->fail_io_work))\n\t\t\t\t\tfc_flush_devloss(shost);\n\t\t\t\tif (!cancel_delayed_work(&rport->dev_loss_work))\n\t\t\t\t\tfc_flush_devloss(shost);\n\n\t\t\t\tspin_lock_irqsave(shost->host_lock, flags);\n\n\t\t\t\trport->flags &= ~(FC_RPORT_FAST_FAIL_TIMEDOUT |\n\t\t\t\t\t\t  FC_RPORT_DEVLOSS_PENDING |\n\t\t\t\t\t\t  FC_RPORT_DEVLOSS_CALLBK_DONE);\n\n\t\t\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\t\t\t\t \n\t\t\t\tif (rport->scsi_target_id != -1) {\n\t\t\t\t\tscsi_target_unblock(&rport->dev,\n\t\t\t\t\t\t\t    SDEV_RUNNING);\n\t\t\t\t\tspin_lock_irqsave(shost->host_lock,\n\t\t\t\t\t\t\t  flags);\n\t\t\t\t\trport->flags |= FC_RPORT_SCAN_PENDING;\n\t\t\t\t\tscsi_queue_work(shost,\n\t\t\t\t\t\t\t&rport->scan_work);\n\t\t\t\t\tspin_unlock_irqrestore(shost->host_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\t}\n\n\t\t\t\tfc_bsg_goose_queue(rport);\n\n\t\t\t\treturn rport;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (fc_host->tgtid_bind_type != FC_TGTID_BIND_NONE) {\n\n\t\t \n\n\t\tlist_for_each_entry(rport, &fc_host->rport_bindings,\n\t\t\t\t\tpeers) {\n\t\t\tif (rport->channel != channel)\n\t\t\t\tcontinue;\n\n\t\t\tswitch (fc_host->tgtid_bind_type) {\n\t\t\tcase FC_TGTID_BIND_BY_WWPN:\n\t\t\t\tif (rport->port_name == ids->port_name)\n\t\t\t\t\tmatch = 1;\n\t\t\t\tbreak;\n\t\t\tcase FC_TGTID_BIND_BY_WWNN:\n\t\t\t\tif (rport->node_name == ids->node_name)\n\t\t\t\t\tmatch = 1;\n\t\t\t\tbreak;\n\t\t\tcase FC_TGTID_BIND_BY_ID:\n\t\t\t\tif (rport->port_id == ids->port_id)\n\t\t\t\t\tmatch = 1;\n\t\t\t\tbreak;\n\t\t\tcase FC_TGTID_BIND_NONE:  \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (match) {\n\t\t\t\tlist_move_tail(&rport->peers, &fc_host->rports);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (match) {\n\t\t\tmemcpy(&rport->node_name, &ids->node_name,\n\t\t\t\tsizeof(rport->node_name));\n\t\t\tmemcpy(&rport->port_name, &ids->port_name,\n\t\t\t\tsizeof(rport->port_name));\n\t\t\trport->port_id = ids->port_id;\n\t\t\trport->port_state = FC_PORTSTATE_ONLINE;\n\t\t\trport->flags &= ~FC_RPORT_FAST_FAIL_TIMEDOUT;\n\n\t\t\tif (fci->f->dd_fcrport_size)\n\t\t\t\tmemset(rport->dd_data, 0,\n\t\t\t\t\t\tfci->f->dd_fcrport_size);\n\t\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\t\t\tfc_remote_port_rolechg(rport, ids->roles);\n\t\t\treturn rport;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\t \n\trport = fc_remote_port_create(shost, channel, ids);\n\n\treturn rport;\n}\nEXPORT_SYMBOL(fc_remote_port_add);\n\n\n \nvoid\nfc_remote_port_delete(struct fc_rport  *rport)\n{\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tunsigned long timeout = rport->dev_loss_tmo;\n\tunsigned long flags;\n\n\t \n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\n\tif ((rport->port_state != FC_PORTSTATE_ONLINE) &&\n\t\t(rport->port_state != FC_PORTSTATE_MARGINAL)) {\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\n\trport->port_state = FC_PORTSTATE_BLOCKED;\n\n\trport->flags |= FC_RPORT_DEVLOSS_PENDING;\n\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tscsi_block_targets(shost, &rport->dev);\n\n\t \n\tif ((rport->fast_io_fail_tmo != -1) &&\n\t    (rport->fast_io_fail_tmo < timeout))\n\t\tfc_queue_devloss_work(shost, &rport->fail_io_work,\n\t\t\t\t\trport->fast_io_fail_tmo * HZ);\n\n\t \n\tfc_queue_devloss_work(shost, &rport->dev_loss_work, timeout * HZ);\n}\nEXPORT_SYMBOL(fc_remote_port_delete);\n\n \nvoid\nfc_remote_port_rolechg(struct fc_rport  *rport, u32 roles)\n{\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\n\tunsigned long flags;\n\tint create = 0;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (roles & FC_PORT_ROLE_FCP_TARGET) {\n\t\tif (rport->scsi_target_id == -1) {\n\t\t\trport->scsi_target_id = fc_host->next_target_id++;\n\t\t\tcreate = 1;\n\t\t} else if (!(rport->roles & FC_PORT_ROLE_FCP_TARGET))\n\t\t\tcreate = 1;\n\t}\n\n\trport->roles = roles;\n\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tif (create) {\n\t\t \n\t\tif (!cancel_delayed_work(&rport->fail_io_work))\n\t\t\tfc_flush_devloss(shost);\n\t\tif (!cancel_delayed_work(&rport->dev_loss_work))\n\t\t\tfc_flush_devloss(shost);\n\n\t\tspin_lock_irqsave(shost->host_lock, flags);\n\t\trport->flags &= ~(FC_RPORT_FAST_FAIL_TIMEDOUT |\n\t\t\t\t  FC_RPORT_DEVLOSS_PENDING |\n\t\t\t\t  FC_RPORT_DEVLOSS_CALLBK_DONE);\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\t\t \n\t\tfc_flush_work(shost);\n\n\t\tscsi_target_unblock(&rport->dev, SDEV_RUNNING);\n\t\t \n\t\tspin_lock_irqsave(shost->host_lock, flags);\n\t\trport->flags |= FC_RPORT_SCAN_PENDING;\n\t\tscsi_queue_work(shost, &rport->scan_work);\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t}\n}\nEXPORT_SYMBOL(fc_remote_port_rolechg);\n\n \nstatic void\nfc_timeout_deleted_rport(struct work_struct *work)\n{\n\tstruct fc_rport *rport =\n\t\tcontainer_of(work, struct fc_rport, dev_loss_work.work);\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\n\tunsigned long flags;\n\tint do_callback = 0;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\n\trport->flags &= ~FC_RPORT_DEVLOSS_PENDING;\n\n\t \n\tif (((rport->port_state == FC_PORTSTATE_ONLINE) ||\n\t\t(rport->port_state == FC_PORTSTATE_MARGINAL)) &&\n\t    (rport->scsi_target_id != -1) &&\n\t    !(rport->roles & FC_PORT_ROLE_FCP_TARGET)) {\n\t\tdev_printk(KERN_ERR, &rport->dev,\n\t\t\t\"blocked FC remote port time out: no longer\"\n\t\t\t\" a FCP target, removing starget\\n\");\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\tscsi_target_unblock(&rport->dev, SDEV_TRANSPORT_OFFLINE);\n\t\tfc_queue_work(shost, &rport->stgt_delete_work);\n\t\treturn;\n\t}\n\n\t \n\tif (rport->port_state != FC_PORTSTATE_BLOCKED) {\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\tdev_printk(KERN_ERR, &rport->dev,\n\t\t\t\"blocked FC remote port time out: leaving\"\n\t\t\t\" rport%s alone\\n\",\n\t\t\t(rport->scsi_target_id != -1) ?  \" and starget\" : \"\");\n\t\treturn;\n\t}\n\n\tif ((fc_host->tgtid_bind_type == FC_TGTID_BIND_NONE) ||\n\t    (rport->scsi_target_id == -1)) {\n\t\tlist_del(&rport->peers);\n\t\trport->port_state = FC_PORTSTATE_DELETED;\n\t\tdev_printk(KERN_ERR, &rport->dev,\n\t\t\t\"blocked FC remote port time out: removing\"\n\t\t\t\" rport%s\\n\",\n\t\t\t(rport->scsi_target_id != -1) ?  \" and starget\" : \"\");\n\t\tfc_queue_work(shost, &rport->rport_delete_work);\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\treturn;\n\t}\n\n\tdev_printk(KERN_ERR, &rport->dev,\n\t\t\"blocked FC remote port time out: removing target and \"\n\t\t\"saving binding\\n\");\n\n\tlist_move_tail(&rport->peers, &fc_host->rport_bindings);\n\n\t \n\n\t \n\trport->maxframe_size = -1;\n\trport->supported_classes = FC_COS_UNSPECIFIED;\n\trport->roles = FC_PORT_ROLE_UNKNOWN;\n\trport->port_state = FC_PORTSTATE_NOTPRESENT;\n\trport->flags &= ~FC_RPORT_FAST_FAIL_TIMEDOUT;\n\n\t \n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\tfc_terminate_rport_io(rport);\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\n\tif (rport->port_state == FC_PORTSTATE_NOTPRESENT) {\t \n\n\t\t \n\t\tswitch (fc_host->tgtid_bind_type) {\n\t\tcase FC_TGTID_BIND_BY_WWPN:\n\t\t\trport->node_name = -1;\n\t\t\trport->port_id = -1;\n\t\t\tbreak;\n\t\tcase FC_TGTID_BIND_BY_WWNN:\n\t\t\trport->port_name = -1;\n\t\t\trport->port_id = -1;\n\t\t\tbreak;\n\t\tcase FC_TGTID_BIND_BY_ID:\n\t\t\trport->node_name = -1;\n\t\t\trport->port_name = -1;\n\t\t\tbreak;\n\t\tcase FC_TGTID_BIND_NONE:\t \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trport->flags |= FC_RPORT_DEVLOSS_CALLBK_DONE;\n\t\tfc_queue_work(shost, &rport->stgt_delete_work);\n\n\t\tdo_callback = 1;\n\t}\n\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\t \n\tif (do_callback && i->f->dev_loss_tmo_callbk)\n\t\ti->f->dev_loss_tmo_callbk(rport);\n}\n\n\n \nstatic void\nfc_timeout_fail_rport_io(struct work_struct *work)\n{\n\tstruct fc_rport *rport =\n\t\tcontainer_of(work, struct fc_rport, fail_io_work.work);\n\n\tif (rport->port_state != FC_PORTSTATE_BLOCKED)\n\t\treturn;\n\n\trport->flags |= FC_RPORT_FAST_FAIL_TIMEDOUT;\n\tfc_terminate_rport_io(rport);\n}\n\n \nstatic void\nfc_scsi_scan_rport(struct work_struct *work)\n{\n\tstruct fc_rport *rport =\n\t\tcontainer_of(work, struct fc_rport, scan_work);\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\tunsigned long flags;\n\n\tif (((rport->port_state == FC_PORTSTATE_ONLINE) ||\n\t\t(rport->port_state == FC_PORTSTATE_MARGINAL)) &&\n\t    (rport->roles & FC_PORT_ROLE_FCP_TARGET) &&\n\t    !(i->f->disable_target_scan)) {\n\t\tscsi_scan_target(&rport->dev, rport->channel,\n\t\t\t\t rport->scsi_target_id, SCAN_WILD_CARD,\n\t\t\t\t SCSI_SCAN_RESCAN);\n\t}\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\trport->flags &= ~FC_RPORT_SCAN_PENDING;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n}\n\n \nint fc_block_rport(struct fc_rport *rport)\n{\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\twhile (rport->port_state == FC_PORTSTATE_BLOCKED &&\n\t       !(rport->flags & FC_RPORT_FAST_FAIL_TIMEDOUT)) {\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\tmsleep(1000);\n\t\tspin_lock_irqsave(shost->host_lock, flags);\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tif (rport->flags & FC_RPORT_FAST_FAIL_TIMEDOUT)\n\t\treturn FAST_IO_FAIL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fc_block_rport);\n\n \nint fc_block_scsi_eh(struct scsi_cmnd *cmnd)\n{\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(cmnd->device));\n\n\tif (WARN_ON_ONCE(!rport))\n\t\treturn FAST_IO_FAIL;\n\n\treturn fc_block_rport(rport);\n}\nEXPORT_SYMBOL(fc_block_scsi_eh);\n\n \nbool fc_eh_should_retry_cmd(struct scsi_cmnd *scmd)\n{\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(scmd->device));\n\n\tif ((rport->port_state != FC_PORTSTATE_ONLINE) &&\n\t\t(scsi_cmd_to_rq(scmd)->cmd_flags & REQ_FAILFAST_TRANSPORT)) {\n\t\tset_host_byte(scmd, DID_TRANSPORT_MARGINAL);\n\t\treturn false;\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(fc_eh_should_retry_cmd);\n\n \nstatic int\nfc_vport_setup(struct Scsi_Host *shost, int channel, struct device *pdev,\n\tstruct fc_vport_identifiers  *ids, struct fc_vport **ret_vport)\n{\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\n\tstruct fc_internal *fci = to_fc_internal(shost->transportt);\n\tstruct fc_vport *vport;\n\tstruct device *dev;\n\tunsigned long flags;\n\tsize_t size;\n\tint error;\n\n\t*ret_vport = NULL;\n\n\tif ( ! fci->f->vport_create)\n\t\treturn -ENOENT;\n\n\tsize = (sizeof(struct fc_vport) + fci->f->dd_fcvport_size);\n\tvport = kzalloc(size, GFP_KERNEL);\n\tif (unlikely(!vport)) {\n\t\tprintk(KERN_ERR \"%s: allocation failure\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tvport->vport_state = FC_VPORT_UNKNOWN;\n\tvport->vport_last_state = FC_VPORT_UNKNOWN;\n\tvport->node_name = ids->node_name;\n\tvport->port_name = ids->port_name;\n\tvport->roles = ids->roles;\n\tvport->vport_type = ids->vport_type;\n\tif (fci->f->dd_fcvport_size)\n\t\tvport->dd_data = &vport[1];\n\tvport->shost = shost;\n\tvport->channel = channel;\n\tvport->flags = FC_VPORT_CREATING;\n\tINIT_WORK(&vport->vport_delete_work, fc_vport_sched_delete);\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\n\tif (fc_host->npiv_vports_inuse >= fc_host->max_npiv_vports) {\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\tkfree(vport);\n\t\treturn -ENOSPC;\n\t}\n\tfc_host->npiv_vports_inuse++;\n\tvport->number = fc_host->next_vport_number++;\n\tlist_add_tail(&vport->peers, &fc_host->vports);\n\tscsi_host_get(shost);\t\t\t \n\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tdev = &vport->dev;\n\tdevice_initialize(dev);\t\t\t \n\tdev->parent = get_device(pdev);\t\t \n\tdev->release = fc_vport_dev_release;\n\tdev_set_name(dev, \"vport-%d:%d-%d\",\n\t\t     shost->host_no, channel, vport->number);\n\ttransport_setup_device(dev);\n\n\terror = device_add(dev);\n\tif (error) {\n\t\tprintk(KERN_ERR \"FC Virtual Port device_add failed\\n\");\n\t\tgoto delete_vport;\n\t}\n\ttransport_add_device(dev);\n\ttransport_configure_device(dev);\n\n\terror = fci->f->vport_create(vport, ids->disable);\n\tif (error) {\n\t\tprintk(KERN_ERR \"FC Virtual Port LLDD Create failed\\n\");\n\t\tgoto delete_vport_all;\n\t}\n\n\t \n\tif (pdev != &shost->shost_gendev) {\n\t\terror = sysfs_create_link(&shost->shost_gendev.kobj,\n\t\t\t\t &dev->kobj, dev_name(dev));\n\t\tif (error)\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"%s: Cannot create vport symlinks for \"\n\t\t\t\t\"%s, err=%d\\n\",\n\t\t\t\t__func__, dev_name(dev), error);\n\t}\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tvport->flags &= ~FC_VPORT_CREATING;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tdev_printk(KERN_NOTICE, pdev,\n\t\t\t\"%s created via shost%d channel %d\\n\", dev_name(dev),\n\t\t\tshost->host_no, channel);\n\n\t*ret_vport = vport;\n\n\treturn 0;\n\ndelete_vport_all:\n\ttransport_remove_device(dev);\n\tdevice_del(dev);\ndelete_vport:\n\ttransport_destroy_device(dev);\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tlist_del(&vport->peers);\n\tscsi_host_put(shost);\t\t\t \n\tfc_host->npiv_vports_inuse--;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\tput_device(dev->parent);\n\tkfree(vport);\n\n\treturn error;\n}\n\n \nstruct fc_vport *\nfc_vport_create(struct Scsi_Host *shost, int channel,\n\tstruct fc_vport_identifiers *ids)\n{\n\tint stat;\n\tstruct fc_vport *vport;\n\n\tstat = fc_vport_setup(shost, channel, &shost->shost_gendev,\n\t\t ids, &vport);\n\treturn stat ? NULL : vport;\n}\nEXPORT_SYMBOL(fc_vport_create);\n\n \nint\nfc_vport_terminate(struct fc_vport *vport)\n{\n\tstruct Scsi_Host *shost = vport_to_shost(vport);\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\tstruct device *dev = &vport->dev;\n\tunsigned long flags;\n\tint stat;\n\n\tif (i->f->vport_delete)\n\t\tstat = i->f->vport_delete(vport);\n\telse\n\t\tstat = -ENOENT;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tvport->flags &= ~FC_VPORT_DELETING;\n\tif (!stat) {\n\t\tvport->flags |= FC_VPORT_DELETED;\n\t\tlist_del(&vport->peers);\n\t\tfc_host->npiv_vports_inuse--;\n\t\tscsi_host_put(shost);\t\t \n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tif (stat)\n\t\treturn stat;\n\n\tif (dev->parent != &shost->shost_gendev)\n\t\tsysfs_remove_link(&shost->shost_gendev.kobj, dev_name(dev));\n\ttransport_remove_device(dev);\n\tdevice_del(dev);\n\ttransport_destroy_device(dev);\n\n\t \n\tput_device(dev);\t\t\t \n\n\treturn 0;  \n}\nEXPORT_SYMBOL(fc_vport_terminate);\n\n \nstatic void\nfc_vport_sched_delete(struct work_struct *work)\n{\n\tstruct fc_vport *vport =\n\t\tcontainer_of(work, struct fc_vport, vport_delete_work);\n\tint stat;\n\n\tstat = fc_vport_terminate(vport);\n\tif (stat)\n\t\tdev_printk(KERN_ERR, vport->dev.parent,\n\t\t\t\"%s: %s could not be deleted created via \"\n\t\t\t\"shost%d channel %d - error %d\\n\", __func__,\n\t\t\tdev_name(&vport->dev), vport->shost->host_no,\n\t\t\tvport->channel, stat);\n}\n\n\n \n\n \nstatic enum blk_eh_timer_return\nfc_bsg_job_timeout(struct request *req)\n{\n\tstruct bsg_job *job = blk_mq_rq_to_pdu(req);\n\tstruct Scsi_Host *shost = fc_bsg_to_shost(job);\n\tstruct fc_rport *rport = fc_bsg_to_rport(job);\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\tint err = 0, inflight = 0;\n\n\tif (rport && rport->port_state == FC_PORTSTATE_BLOCKED)\n\t\treturn BLK_EH_RESET_TIMER;\n\n\tinflight = bsg_job_get(job);\n\n\tif (inflight && i->f->bsg_timeout) {\n\t\t \n\t\terr = i->f->bsg_timeout(job);\n\t\tif (err == -EAGAIN) {\n\t\t\tbsg_job_put(job);\n\t\t\treturn BLK_EH_RESET_TIMER;\n\t\t} else if (err)\n\t\t\tprintk(KERN_ERR \"ERROR: FC BSG request timeout - LLD \"\n\t\t\t\t\"abort failed with status %d\\n\", err);\n\t}\n\n\t \n\tif (inflight)\n\t\tblk_mq_end_request(req, BLK_STS_IOERR);\n\treturn BLK_EH_DONE;\n}\n\n \nstatic int fc_bsg_host_dispatch(struct Scsi_Host *shost, struct bsg_job *job)\n{\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tint cmdlen = sizeof(uint32_t);\t \n\tint ret;\n\n\t \n\tif (job->request_len < cmdlen) {\n\t\tret = -ENOMSG;\n\t\tgoto fail_host_msg;\n\t}\n\n\t \n\tswitch (bsg_request->msgcode) {\n\tcase FC_BSG_HST_ADD_RPORT:\n\t\tcmdlen += sizeof(struct fc_bsg_host_add_rport);\n\t\tbreak;\n\n\tcase FC_BSG_HST_DEL_RPORT:\n\t\tcmdlen += sizeof(struct fc_bsg_host_del_rport);\n\t\tbreak;\n\n\tcase FC_BSG_HST_ELS_NOLOGIN:\n\t\tcmdlen += sizeof(struct fc_bsg_host_els);\n\t\t \n\t\tif ((!job->request_payload.payload_len) ||\n\t\t    (!job->reply_payload.payload_len)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail_host_msg;\n\t\t}\n\t\tbreak;\n\n\tcase FC_BSG_HST_CT:\n\t\tcmdlen += sizeof(struct fc_bsg_host_ct);\n\t\t \n\t\tif ((!job->request_payload.payload_len) ||\n\t\t    (!job->reply_payload.payload_len)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail_host_msg;\n\t\t}\n\t\tbreak;\n\n\tcase FC_BSG_HST_VENDOR:\n\t\tcmdlen += sizeof(struct fc_bsg_host_vendor);\n\t\tif ((shost->hostt->vendor_id == 0L) ||\n\t\t    (bsg_request->rqst_data.h_vendor.vendor_id !=\n\t\t\tshost->hostt->vendor_id)) {\n\t\t\tret = -ESRCH;\n\t\t\tgoto fail_host_msg;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EBADR;\n\t\tgoto fail_host_msg;\n\t}\n\n\tret = i->f->bsg_request(job);\n\tif (!ret)\n\t\treturn 0;\n\nfail_host_msg:\n\t \n\tBUG_ON(job->reply_len < sizeof(uint32_t));\n\tbsg_reply->reply_payload_rcv_len = 0;\n\tbsg_reply->result = ret;\n\tjob->reply_len = sizeof(uint32_t);\n\tbsg_job_done(job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn 0;\n}\n\n\n \nstatic void\nfc_bsg_goose_queue(struct fc_rport *rport)\n{\n\tstruct request_queue *q = rport->rqst_q;\n\n\tif (q)\n\t\tblk_mq_run_hw_queues(q, true);\n}\n\n \nstatic int fc_bsg_rport_dispatch(struct Scsi_Host *shost, struct bsg_job *job)\n{\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tint cmdlen = sizeof(uint32_t);\t \n\tint ret;\n\n\t \n\tif (job->request_len < cmdlen) {\n\t\tret = -ENOMSG;\n\t\tgoto fail_rport_msg;\n\t}\n\n\t \n\tswitch (bsg_request->msgcode) {\n\tcase FC_BSG_RPT_ELS:\n\t\tcmdlen += sizeof(struct fc_bsg_rport_els);\n\t\tgoto check_bidi;\n\n\tcase FC_BSG_RPT_CT:\n\t\tcmdlen += sizeof(struct fc_bsg_rport_ct);\ncheck_bidi:\n\t\t \n\t\tif ((!job->request_payload.payload_len) ||\n\t\t    (!job->reply_payload.payload_len)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail_rport_msg;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EBADR;\n\t\tgoto fail_rport_msg;\n\t}\n\n\tret = i->f->bsg_request(job);\n\tif (!ret)\n\t\treturn 0;\n\nfail_rport_msg:\n\t \n\tBUG_ON(job->reply_len < sizeof(uint32_t));\n\tbsg_reply->reply_payload_rcv_len = 0;\n\tbsg_reply->result = ret;\n\tjob->reply_len = sizeof(uint32_t);\n\tbsg_job_done(job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn 0;\n}\n\nstatic int fc_bsg_dispatch(struct bsg_job *job)\n{\n\tstruct Scsi_Host *shost = fc_bsg_to_shost(job);\n\n\tif (scsi_is_fc_rport(job->dev))\n\t\treturn fc_bsg_rport_dispatch(shost, job);\n\telse\n\t\treturn fc_bsg_host_dispatch(shost, job);\n}\n\nstatic blk_status_t fc_bsg_rport_prep(struct fc_rport *rport)\n{\n\tif (rport->port_state == FC_PORTSTATE_BLOCKED &&\n\t    !(rport->flags & FC_RPORT_FAST_FAIL_TIMEDOUT))\n\t\treturn BLK_STS_RESOURCE;\n\n\tif ((rport->port_state != FC_PORTSTATE_ONLINE) &&\n\t\t(rport->port_state != FC_PORTSTATE_MARGINAL))\n\t\treturn BLK_STS_IOERR;\n\n\treturn BLK_STS_OK;\n}\n\n\nstatic int fc_bsg_dispatch_prep(struct bsg_job *job)\n{\n\tstruct fc_rport *rport = fc_bsg_to_rport(job);\n\tblk_status_t ret;\n\n\tret = fc_bsg_rport_prep(rport);\n\tswitch (ret) {\n\tcase BLK_STS_OK:\n\t\tbreak;\n\tcase BLK_STS_RESOURCE:\n\t\treturn -EAGAIN;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\treturn fc_bsg_dispatch(job);\n}\n\n \nstatic int\nfc_bsg_hostadd(struct Scsi_Host *shost, struct fc_host_attrs *fc_host)\n{\n\tstruct device *dev = &shost->shost_gendev;\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\tstruct request_queue *q;\n\tchar bsg_name[20];\n\n\tfc_host->rqst_q = NULL;\n\n\tif (!i->f->bsg_request)\n\t\treturn -ENOTSUPP;\n\n\tsnprintf(bsg_name, sizeof(bsg_name),\n\t\t \"fc_host%d\", shost->host_no);\n\n\tq = bsg_setup_queue(dev, bsg_name, fc_bsg_dispatch, fc_bsg_job_timeout,\n\t\t\t\ti->f->dd_bsg_size);\n\tif (IS_ERR(q)) {\n\t\tdev_err(dev,\n\t\t\t\"fc_host%d: bsg interface failed to initialize - setup queue\\n\",\n\t\t\tshost->host_no);\n\t\treturn PTR_ERR(q);\n\t}\n\t__scsi_init_queue(shost, q);\n\tblk_queue_rq_timeout(q, FC_DEFAULT_BSG_TIMEOUT);\n\tfc_host->rqst_q = q;\n\treturn 0;\n}\n\n \nstatic int\nfc_bsg_rportadd(struct Scsi_Host *shost, struct fc_rport *rport)\n{\n\tstruct device *dev = &rport->dev;\n\tstruct fc_internal *i = to_fc_internal(shost->transportt);\n\tstruct request_queue *q;\n\n\trport->rqst_q = NULL;\n\n\tif (!i->f->bsg_request)\n\t\treturn -ENOTSUPP;\n\n\tq = bsg_setup_queue(dev, dev_name(dev), fc_bsg_dispatch_prep,\n\t\t\t\tfc_bsg_job_timeout, i->f->dd_bsg_size);\n\tif (IS_ERR(q)) {\n\t\tdev_err(dev, \"failed to setup bsg queue\\n\");\n\t\treturn PTR_ERR(q);\n\t}\n\t__scsi_init_queue(shost, q);\n\tblk_queue_rq_timeout(q, BLK_DEFAULT_SG_TIMEOUT);\n\trport->rqst_q = q;\n\treturn 0;\n}\n\n\n \nstatic void\nfc_bsg_remove(struct request_queue *q)\n{\n\tbsg_remove_queue(q);\n}\n\n\n \nMODULE_AUTHOR(\"James Smart\");\nMODULE_DESCRIPTION(\"FC Transport Attributes\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(fc_transport_init);\nmodule_exit(fc_transport_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}