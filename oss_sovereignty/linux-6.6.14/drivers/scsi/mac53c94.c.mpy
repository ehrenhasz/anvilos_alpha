{
  "module_name": "mac53c94.c",
  "hash_id": "41caf03e2342c1e390cb9a934c935c23fe338b57b483aeaa4e636a325dd9ad7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mac53c94.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pgtable.h>\n#include <asm/dbdma.h>\n#include <asm/io.h>\n#include <asm/prom.h>\n#include <asm/macio.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n\n#include \"mac53c94.h\"\n\nenum fsc_phase {\n\tidle,\n\tselecting,\n\tdataing,\n\tcompleting,\n\tbusfreeing,\n};\n\nstruct fsc_state {\n\tstruct\tmac53c94_regs __iomem *regs;\n\tint\tintr;\n\tstruct\tdbdma_regs __iomem *dma;\n\tint\tdmaintr;\n\tint\tclk_freq;\n\tstruct\tScsi_Host *host;\n\tstruct scsi_cmnd *request_q;\n\tstruct scsi_cmnd *request_qtail;\n\tstruct scsi_cmnd *current_req;\t\t \n\tenum fsc_phase phase;\t\t \n\tstruct dbdma_cmd *dma_cmds;\t \n\tvoid\t*dma_cmd_space;\n\tstruct\tpci_dev *pdev;\n\tdma_addr_t dma_addr;\n\tstruct macio_dev *mdev;\n};\n\nstatic void mac53c94_init(struct fsc_state *);\nstatic void mac53c94_start(struct fsc_state *);\nstatic void mac53c94_interrupt(int, void *);\nstatic irqreturn_t do_mac53c94_interrupt(int, void *);\nstatic void cmd_done(struct fsc_state *, int result);\nstatic void set_dma_cmds(struct fsc_state *, struct scsi_cmnd *);\n\nstatic int mac53c94_queue_lck(struct scsi_cmnd *cmd)\n{\n\tstruct fsc_state *state;\n\n#if 0\n\tif (cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tint i;\n\t\tprintk(KERN_DEBUG \"mac53c94_queue %p: command is\", cmd);\n\t\tfor (i = 0; i < cmd->cmd_len; ++i)\n\t\t\tprintk(KERN_CONT \" %.2x\", cmd->cmnd[i]);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tprintk(KERN_DEBUG \"use_sg=%d request_bufflen=%d request_buffer=%p\\n\",\n\t\t       scsi_sg_count(cmd), scsi_bufflen(cmd), scsi_sglist(cmd));\n\t}\n#endif\n\n\tcmd->host_scribble = NULL;\n\n\tstate = (struct fsc_state *) cmd->device->host->hostdata;\n\n\tif (state->request_q == NULL)\n\t\tstate->request_q = cmd;\n\telse\n\t\tstate->request_qtail->host_scribble = (void *) cmd;\n\tstate->request_qtail = cmd;\n\n\tif (state->phase == idle)\n\t\tmac53c94_start(state);\n\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(mac53c94_queue)\n\nstatic int mac53c94_host_reset(struct scsi_cmnd *cmd)\n{\n\tstruct fsc_state *state = (struct fsc_state *) cmd->device->host->hostdata;\n\tstruct mac53c94_regs __iomem *regs = state->regs;\n\tstruct dbdma_regs __iomem *dma = state->dma;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(cmd->device->host->host_lock, flags);\n\n\twritel((RUN|PAUSE|FLUSH|WAKE) << 16, &dma->control);\n\twriteb(CMD_SCSI_RESET, &regs->command);\t \n\tudelay(100);\t\t\t \n\twriteb(CMD_RESET, &regs->command);\n\tudelay(20);\n\tmac53c94_init(state);\n\twriteb(CMD_NOP, &regs->command);\n\n\tspin_unlock_irqrestore(cmd->device->host->host_lock, flags);\n\treturn SUCCESS;\n}\n\nstatic void mac53c94_init(struct fsc_state *state)\n{\n\tstruct mac53c94_regs __iomem *regs = state->regs;\n\tstruct dbdma_regs __iomem *dma = state->dma;\n\n\twriteb(state->host->this_id | CF1_PAR_ENABLE, &regs->config1);\n\twriteb(TIMO_VAL(250), &regs->sel_timeout);\t \n\twriteb(CLKF_VAL(state->clk_freq), &regs->clk_factor);\n\twriteb(CF2_FEATURE_EN, &regs->config2);\n\twriteb(0, &regs->config3);\n\twriteb(0, &regs->sync_period);\n\twriteb(0, &regs->sync_offset);\n\t(void)readb(&regs->interrupt);\n\twritel((RUN|PAUSE|FLUSH|WAKE) << 16, &dma->control);\n}\n\n \nstatic void mac53c94_start(struct fsc_state *state)\n{\n\tstruct scsi_cmnd *cmd;\n\tstruct mac53c94_regs __iomem *regs = state->regs;\n\tint i;\n\n\tif (state->phase != idle || state->current_req != NULL)\n\t\tpanic(\"inappropriate mac53c94_start (state=%p)\", state);\n\tif (state->request_q == NULL)\n\t\treturn;\n\tstate->current_req = cmd = state->request_q;\n\tstate->request_q = (struct scsi_cmnd *) cmd->host_scribble;\n\n\t \n\twriteb(0, &regs->count_lo);\n\twriteb(0, &regs->count_mid);\n\twriteb(0, &regs->count_hi);\n\twriteb(CMD_NOP + CMD_DMA_MODE, &regs->command);\n\tudelay(1);\n\twriteb(CMD_FLUSH, &regs->command);\n\tudelay(1);\n\twriteb(cmd->device->id, &regs->dest_id);\n\twriteb(0, &regs->sync_period);\n\twriteb(0, &regs->sync_offset);\n\n\t \n\tfor (i = 0; i < cmd->cmd_len; ++i)\n\t\twriteb(cmd->cmnd[i], &regs->fifo);\n\n\t \n\twriteb(CMD_SELECT, &regs->command);\n\tstate->phase = selecting;\n\n\tset_dma_cmds(state, cmd);\n}\n\nstatic irqreturn_t do_mac53c94_interrupt(int irq, void *dev_id)\n{\n\tunsigned long flags;\n\tstruct Scsi_Host *dev = ((struct fsc_state *) dev_id)->current_req->device->host;\n\t\n\tspin_lock_irqsave(dev->host_lock, flags);\n\tmac53c94_interrupt(irq, dev_id);\n\tspin_unlock_irqrestore(dev->host_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic void mac53c94_interrupt(int irq, void *dev_id)\n{\n\tstruct fsc_state *state = (struct fsc_state *) dev_id;\n\tstruct mac53c94_regs __iomem *regs = state->regs;\n\tstruct dbdma_regs __iomem *dma = state->dma;\n\tstruct scsi_cmnd *const cmd = state->current_req;\n\tstruct mac53c94_cmd_priv *const mcmd = mac53c94_priv(cmd);\n\tint nb, stat, seq, intr;\n\tstatic int mac53c94_errors;\n\n\t \n\tseq = readb(&regs->seqstep);\n\tstat = readb(&regs->status);\n\tintr = readb(&regs->interrupt);\n\n#if 0\n\tprintk(KERN_DEBUG \"mac53c94_intr, intr=%x stat=%x seq=%x phase=%d\\n\",\n\t       intr, stat, seq, state->phase);\n#endif\n\n\tif (intr & INTR_RESET) {\n\t\t \n\t\tprintk(KERN_INFO \"external SCSI bus reset detected\\n\");\n\t\twriteb(CMD_NOP, &regs->command);\n\t\twritel(RUN << 16, &dma->control);\t \n\t\tcmd_done(state, DID_RESET << 16);\n\t\treturn;\n\t}\n\tif (intr & INTR_ILL_CMD) {\n\t\tprintk(KERN_ERR \"53c94: invalid cmd, intr=%x stat=%x seq=%x phase=%d\\n\",\n\t\t       intr, stat, seq, state->phase);\n\t\tcmd_done(state, DID_ERROR << 16);\n\t\treturn;\n\t}\n\tif (stat & STAT_ERROR) {\n#if 0\n\t\t \n\t\tprintk(\"53c94: bad error, intr=%x stat=%x seq=%x phase=%d\\n\",\n\t\t       intr, stat, seq, state->phase);\n#endif\n\t\t++mac53c94_errors;\n\t\twriteb(CMD_NOP + CMD_DMA_MODE, &regs->command);\n\t}\n\tif (!cmd) {\n\t\tprintk(KERN_DEBUG \"53c94: interrupt with no command active?\\n\");\n\t\treturn;\n\t}\n\tif (stat & STAT_PARITY) {\n\t\tprintk(KERN_ERR \"mac53c94: parity error\\n\");\n\t\tcmd_done(state, DID_PARITY << 16);\n\t\treturn;\n\t}\n\tswitch (state->phase) {\n\tcase selecting:\n\t\tif (intr & INTR_DISCONNECT) {\n\t\t\t \n\t\t\tcmd_done(state, DID_BAD_TARGET << 16);\n\t\t\treturn;\n\t\t}\n\t\tif (intr != INTR_BUS_SERV + INTR_DONE) {\n\t\t\tprintk(KERN_DEBUG \"got intr %x during selection\\n\", intr);\n\t\t\tcmd_done(state, DID_ERROR << 16);\n\t\t\treturn;\n\t\t}\n\t\tif ((seq & SS_MASK) != SS_DONE) {\n\t\t\tprintk(KERN_DEBUG \"seq step %x after command\\n\", seq);\n\t\t\tcmd_done(state, DID_ERROR << 16);\n\t\t\treturn;\n\t\t}\n\t\twriteb(CMD_NOP, &regs->command);\n\t\t \n\t\tif ((stat & (STAT_MSG|STAT_CD)) == 0\n\t\t    && (scsi_sg_count(cmd) > 0 || scsi_bufflen(cmd))) {\n\t\t\tnb = mcmd->this_residual;\n\t\t\tif (nb > 0xfff0)\n\t\t\t\tnb = 0xfff0;\n\t\t\tmcmd->this_residual -= nb;\n\t\t\twriteb(nb, &regs->count_lo);\n\t\t\twriteb(nb >> 8, &regs->count_mid);\n\t\t\twriteb(CMD_DMA_MODE + CMD_NOP, &regs->command);\n\t\t\twritel(virt_to_phys(state->dma_cmds), &dma->cmdptr);\n\t\t\twritel((RUN << 16) | RUN, &dma->control);\n\t\t\twriteb(CMD_DMA_MODE + CMD_XFER_DATA, &regs->command);\n\t\t\tstate->phase = dataing;\n\t\t\tbreak;\n\t\t} else if ((stat & STAT_PHASE) == STAT_CD + STAT_IO) {\n\t\t\t \n\t\t\twriteb(CMD_I_COMPLETE, &regs->command);\n\t\t\tstate->phase = completing;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG \"in unexpected phase %x after cmd\\n\",\n\t\t\t       stat & STAT_PHASE);\n\t\t\tcmd_done(state, DID_ERROR << 16);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase dataing:\n\t\tif (intr != INTR_BUS_SERV) {\n\t\t\tprintk(KERN_DEBUG \"got intr %x before status\\n\", intr);\n\t\t\tcmd_done(state, DID_ERROR << 16);\n\t\t\treturn;\n\t\t}\n\t\tif (mcmd->this_residual != 0\n\t\t    && (stat & (STAT_MSG|STAT_CD)) == 0) {\n\t\t\t \n\t\t\tnb = mcmd->this_residual;\n\t\t\tif (nb > 0xfff0)\n\t\t\t\tnb = 0xfff0;\n\t\t\tmcmd->this_residual -= nb;\n\t\t\twriteb(nb, &regs->count_lo);\n\t\t\twriteb(nb >> 8, &regs->count_mid);\n\t\t\twriteb(CMD_DMA_MODE + CMD_NOP, &regs->command);\n\t\t\twriteb(CMD_DMA_MODE + CMD_XFER_DATA, &regs->command);\n\t\t\tbreak;\n\t\t}\n\t\tif ((stat & STAT_PHASE) != STAT_CD + STAT_IO) {\n\t\t\tprintk(KERN_DEBUG \"intr %x before data xfer complete\\n\", intr);\n\t\t}\n\t\twritel(RUN << 16, &dma->control);\t \n\t\tscsi_dma_unmap(cmd);\n\t\t \n\t\twriteb(CMD_I_COMPLETE, &regs->command);\n\t\tstate->phase = completing;\n\t\tbreak;\n\tcase completing:\n\t\tif (intr != INTR_DONE) {\n\t\t\tprintk(KERN_DEBUG \"got intr %x on completion\\n\", intr);\n\t\t\tcmd_done(state, DID_ERROR << 16);\n\t\t\treturn;\n\t\t}\n\t\tmcmd->status = readb(&regs->fifo);\n\t\tmcmd->message = readb(&regs->fifo);\n\t\twriteb(CMD_ACCEPT_MSG, &regs->command);\n\t\tstate->phase = busfreeing;\n\t\tbreak;\n\tcase busfreeing:\n\t\tif (intr != INTR_DISCONNECT) {\n\t\t\tprintk(KERN_DEBUG \"got intr %x when expected disconnect\\n\", intr);\n\t\t}\n\t\tcmd_done(state, (DID_OK << 16) + (mcmd->message << 8) + mcmd->status);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_DEBUG \"don't know about phase %d\\n\", state->phase);\n\t}\n}\n\nstatic void cmd_done(struct fsc_state *state, int result)\n{\n\tstruct scsi_cmnd *cmd;\n\n\tcmd = state->current_req;\n\tif (cmd) {\n\t\tcmd->result = result;\n\t\tscsi_done(cmd);\n\t\tstate->current_req = NULL;\n\t}\n\tstate->phase = idle;\n\tmac53c94_start(state);\n}\n\n \nstatic void set_dma_cmds(struct fsc_state *state, struct scsi_cmnd *cmd)\n{\n\tint i, dma_cmd, total, nseg;\n\tstruct scatterlist *scl;\n\tstruct dbdma_cmd *dcmds;\n\tdma_addr_t dma_addr;\n\tu32 dma_len;\n\n\tnseg = scsi_dma_map(cmd);\n\tBUG_ON(nseg < 0);\n\tif (!nseg)\n\t\treturn;\n\n\tdma_cmd = cmd->sc_data_direction == DMA_TO_DEVICE ?\n\t\t\tOUTPUT_MORE : INPUT_MORE;\n\tdcmds = state->dma_cmds;\n\ttotal = 0;\n\n\tscsi_for_each_sg(cmd, scl, nseg, i) {\n\t\tdma_addr = sg_dma_address(scl);\n\t\tdma_len = sg_dma_len(scl);\n\t\tif (dma_len > 0xffff)\n\t\t\tpanic(\"mac53c94: scatterlist element >= 64k\");\n\t\ttotal += dma_len;\n\t\tdcmds->req_count = cpu_to_le16(dma_len);\n\t\tdcmds->command = cpu_to_le16(dma_cmd);\n\t\tdcmds->phy_addr = cpu_to_le32(dma_addr);\n\t\tdcmds->xfer_status = 0;\n\t\t++dcmds;\n\t}\n\n\tdma_cmd += OUTPUT_LAST - OUTPUT_MORE;\n\tdcmds[-1].command = cpu_to_le16(dma_cmd);\n\tdcmds->command = cpu_to_le16(DBDMA_STOP);\n\tmac53c94_priv(cmd)->this_residual = total;\n}\n\nstatic const struct scsi_host_template mac53c94_template = {\n\t.proc_name\t= \"53c94\",\n\t.name\t\t= \"53C94\",\n\t.queuecommand\t= mac53c94_queue,\n\t.eh_host_reset_handler = mac53c94_host_reset,\n\t.can_queue\t= 1,\n\t.this_id\t= 7,\n\t.sg_tablesize\t= SG_ALL,\n\t.max_segment_size = 65535,\n\t.cmd_size\t= sizeof(struct mac53c94_cmd_priv),\n};\n\nstatic int mac53c94_probe(struct macio_dev *mdev, const struct of_device_id *match)\n{\n\tstruct device_node *node = macio_get_of_node(mdev);\n\tstruct pci_dev *pdev = macio_get_pci_dev(mdev);\n\tstruct fsc_state *state;\n\tstruct Scsi_Host *host;\n\tvoid *dma_cmd_space;\n\tconst unsigned char *clkprop;\n\tint proplen, rc = -ENODEV;\n\n\tif (macio_resource_count(mdev) != 2 || macio_irq_count(mdev) != 2) {\n\t\tprintk(KERN_ERR \"mac53c94: expected 2 addrs and intrs\"\n\t\t       \" (got %d/%d)\\n\",\n\t\t       macio_resource_count(mdev), macio_irq_count(mdev));\n\t\treturn -ENODEV;\n\t}\n\n\tif (macio_request_resources(mdev, \"mac53c94\") != 0) {\n       \t\tprintk(KERN_ERR \"mac53c94: unable to request memory resources\");\n\t\treturn -EBUSY;\n\t}\n\n       \thost = scsi_host_alloc(&mac53c94_template, sizeof(struct fsc_state));\n\tif (host == NULL) {\n\t\tprintk(KERN_ERR \"mac53c94: couldn't register host\");\n\t\trc = -ENOMEM;\n\t\tgoto out_release;\n\t}\n\n\tstate = (struct fsc_state *) host->hostdata;\n\tmacio_set_drvdata(mdev, state);\n\tstate->host = host;\n\tstate->pdev = pdev;\n\tstate->mdev = mdev;\n\n\tstate->regs = (struct mac53c94_regs __iomem *)\n\t\tioremap(macio_resource_start(mdev, 0), 0x1000);\n\tstate->intr = macio_irq(mdev, 0);\n\tstate->dma = (struct dbdma_regs __iomem *)\n\t\tioremap(macio_resource_start(mdev, 1), 0x1000);\n\tstate->dmaintr = macio_irq(mdev, 1);\n\tif (state->regs == NULL || state->dma == NULL) {\n\t\tprintk(KERN_ERR \"mac53c94: ioremap failed for %pOF\\n\", node);\n\t\tgoto out_free;\n\t}\n\n\tclkprop = of_get_property(node, \"clock-frequency\", &proplen);\n       \tif (clkprop == NULL || proplen != sizeof(int)) {\n       \t\tprintk(KERN_ERR \"%pOF: can't get clock frequency, \"\n       \t\t       \"assuming 25MHz\\n\", node);\n       \t\tstate->clk_freq = 25000000;\n       \t} else\n       \t\tstate->clk_freq = *(int *)clkprop;\n\n       \t \n       \tdma_cmd_space = kmalloc_array(host->sg_tablesize + 2,\n\t\t\t\t\t     sizeof(struct dbdma_cmd),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!dma_cmd_space) {\n\t\tprintk(KERN_ERR \"mac53c94: couldn't allocate dma \"\n\t\t       \"command space for %pOF\\n\", node);\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tstate->dma_cmds = (struct dbdma_cmd *)DBDMA_ALIGN(dma_cmd_space);\n\tmemset(state->dma_cmds, 0, (host->sg_tablesize + 1)\n\t       * sizeof(struct dbdma_cmd));\n\tstate->dma_cmd_space = dma_cmd_space;\n\n\tmac53c94_init(state);\n\n\tif (request_irq(state->intr, do_mac53c94_interrupt, 0, \"53C94\",state)) {\n\t\tprintk(KERN_ERR \"mac53C94: can't get irq %d for %pOF\\n\",\n\t\t       state->intr, node);\n\t\tgoto out_free_dma;\n\t}\n\n\trc = scsi_add_host(host, &mdev->ofdev.dev);\n\tif (rc != 0)\n\t\tgoto out_release_irq;\n\n\tscsi_scan_host(host);\n\treturn 0;\n\n out_release_irq:\n\tfree_irq(state->intr, state);\n out_free_dma:\n\tkfree(state->dma_cmd_space);\n out_free:\n\tif (state->dma != NULL)\n\t\tiounmap(state->dma);\n\tif (state->regs != NULL)\n\t\tiounmap(state->regs);\n\tscsi_host_put(host);\n out_release:\n\tmacio_release_resources(mdev);\n\n\treturn rc;\n}\n\nstatic int mac53c94_remove(struct macio_dev *mdev)\n{\n\tstruct fsc_state *fp = (struct fsc_state *)macio_get_drvdata(mdev);\n\tstruct Scsi_Host *host = fp->host;\n\n\tscsi_remove_host(host);\n\n\tfree_irq(fp->intr, fp);\n\n\tif (fp->regs)\n\t\tiounmap(fp->regs);\n\tif (fp->dma)\n\t\tiounmap(fp->dma);\n\tkfree(fp->dma_cmd_space);\n\n\tscsi_host_put(host);\n\n\tmacio_release_resources(mdev);\n\n\treturn 0;\n}\n\n\nstatic struct of_device_id mac53c94_match[] = \n{\n\t{\n\t.name \t\t= \"53c94\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE (of, mac53c94_match);\n\nstatic struct macio_driver mac53c94_driver = \n{\n\t.driver = {\n\t\t.name \t\t= \"mac53c94\",\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.of_match_table\t= mac53c94_match,\n\t},\n\t.probe\t\t= mac53c94_probe,\n\t.remove\t\t= mac53c94_remove,\n};\n\n\nstatic int __init init_mac53c94(void)\n{\n\treturn macio_register_driver(&mac53c94_driver);\n}\n\nstatic void __exit exit_mac53c94(void)\n{\n\treturn macio_unregister_driver(&mac53c94_driver);\n}\n\nmodule_init(init_mac53c94);\nmodule_exit(exit_mac53c94);\n\nMODULE_DESCRIPTION(\"PowerMac 53c94 SCSI driver\");\nMODULE_AUTHOR(\"Paul Mackerras <paulus@samba.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}