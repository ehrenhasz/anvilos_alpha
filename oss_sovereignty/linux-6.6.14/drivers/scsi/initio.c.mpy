{
  "module_name": "initio.c",
  "hash_id": "62956f921908ce824f6e6ae2dff0952c544a70aaf8146dc2c5a45b1704f5d8b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/initio.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/kernel.h>\n#include <linux/proc_fs.h>\n#include <linux/string.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/dma-mapping.h>\n#include <asm/io.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n\n#include \"initio.h\"\n\n#define SENSE_SIZE\t\t14\n\n#define i91u_MAXQUEUE\t\t2\n#define i91u_REVID \"Initio INI-9X00U/UW SCSI device driver; Revision: 1.04a\"\n\n#ifdef DEBUG_i91u\nstatic unsigned int i91u_debug = DEBUG_DEFAULT;\n#endif\n\nstatic int initio_tag_enable = 1;\n\n#ifdef DEBUG_i91u\nstatic int setup_debug = 0;\n#endif\n\nstatic void i91uSCBPost(u8 * pHcb, u8 * pScb);\n\n#define DEBUG_INTERRUPT 0\n#define DEBUG_QUEUE     0\n#define DEBUG_STATE     0\n#define INT_DISC\t0\n\n \nstatic struct scsi_ctrl_blk *initio_find_busy_scb(struct initio_host * host, u16 tarlun);\nstatic struct scsi_ctrl_blk *initio_find_done_scb(struct initio_host * host);\n\nstatic int tulip_main(struct initio_host * host);\n\nstatic int initio_next_state(struct initio_host * host);\nstatic int initio_state_1(struct initio_host * host);\nstatic int initio_state_2(struct initio_host * host);\nstatic int initio_state_3(struct initio_host * host);\nstatic int initio_state_4(struct initio_host * host);\nstatic int initio_state_5(struct initio_host * host);\nstatic int initio_state_6(struct initio_host * host);\nstatic int initio_state_7(struct initio_host * host);\nstatic int initio_xfer_data_in(struct initio_host * host);\nstatic int initio_xfer_data_out(struct initio_host * host);\nstatic int initio_xpad_in(struct initio_host * host);\nstatic int initio_xpad_out(struct initio_host * host);\nstatic int initio_status_msg(struct initio_host * host);\n\nstatic int initio_msgin(struct initio_host * host);\nstatic int initio_msgin_sync(struct initio_host * host);\nstatic int initio_msgin_accept(struct initio_host * host);\nstatic int initio_msgout_reject(struct initio_host * host);\nstatic int initio_msgin_extend(struct initio_host * host);\n\nstatic int initio_msgout_ide(struct initio_host * host);\nstatic int initio_msgout_abort_targ(struct initio_host * host);\nstatic int initio_msgout_abort_tag(struct initio_host * host);\n\nstatic int initio_bus_device_reset(struct initio_host * host);\nstatic void initio_select_atn(struct initio_host * host, struct scsi_ctrl_blk * scb);\nstatic void initio_select_atn3(struct initio_host * host, struct scsi_ctrl_blk * scb);\nstatic void initio_select_atn_stop(struct initio_host * host, struct scsi_ctrl_blk * scb);\nstatic int int_initio_busfree(struct initio_host * host);\nstatic int int_initio_scsi_rst(struct initio_host * host);\nstatic int int_initio_bad_seq(struct initio_host * host);\nstatic int int_initio_resel(struct initio_host * host);\nstatic int initio_sync_done(struct initio_host * host);\nstatic int wdtr_done(struct initio_host * host);\nstatic int wait_tulip(struct initio_host * host);\nstatic int initio_wait_done_disc(struct initio_host * host);\nstatic int initio_wait_disc(struct initio_host * host);\nstatic void tulip_scsi(struct initio_host * host);\nstatic int initio_post_scsi_rst(struct initio_host * host);\n\nstatic void initio_se2_ew_en(unsigned long base);\nstatic void initio_se2_ew_ds(unsigned long base);\nstatic int initio_se2_rd_all(unsigned long base);\nstatic void initio_se2_update_all(unsigned long base);\t \nstatic void initio_read_eeprom(unsigned long base);\n\n \n\nstatic NVRAM i91unvram;\nstatic NVRAM *i91unvramp;\n\nstatic u8 i91udftNvRam[64] =\n{\n\t \n\t0x25, 0xc9,\t\t \n\t0x40,\t\t\t \n\t0x01,\t\t\t \n\t \n\t0x95,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x01,\t\t\t \n\tNBC1_DEFAULT,\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t \n\t7,\t\t\t \n\tNCC1_DEFAULT,\t\t \n\t0,\t\t\t \n\t0x10,\t\t\t \n\n\tNTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT,\n\tNTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT,\n\tNTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT,\n\tNTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT,\n\n\t \n\t7,\t\t\t \n\tNCC1_DEFAULT,\t\t \n\t0,\t\t\t \n\t0x10,\t\t\t \n\n\tNTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT,\n\tNTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT,\n\tNTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT,\n\tNTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT, NTC_DEFAULT,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0};\t\t\t \n\n\nstatic u8 initio_rate_tbl[8] =\t \n{\n\t\t\t\t \n\t12,\t\t\t \n\t18,\t\t\t \n\t25,\t\t\t \n\t31,\t\t\t \n\t37,\t\t\t \n\t43,\t\t\t \n\t50,\t\t\t \n\t62\t\t\t \n};\n\nstatic void initio_do_pause(unsigned amount)\n{\n\t \n\tunsigned long the_time = jiffies + amount;\n\n\twhile (time_before_eq(jiffies, the_time))\n\t\tcpu_relax();\n}\n\n \n\n \n\n \n\nstatic void initio_se2_instr(unsigned long base, u8 instr)\n{\n\tint i;\n\tu8 b;\n\n\toutb(SE2CS | SE2DO, base + TUL_NVRAM);\t\t \n\tudelay(30);\n\toutb(SE2CS | SE2CLK | SE2DO, base + TUL_NVRAM);\t \n\tudelay(30);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (instr & 0x80)\n\t\t\tb = SE2CS | SE2DO;\t\t \n\t\telse\n\t\t\tb = SE2CS;\t\t\t \n\t\toutb(b, base + TUL_NVRAM);\n\t\tudelay(30);\n\t\toutb(b | SE2CLK, base + TUL_NVRAM);\t \n\t\tudelay(30);\n\t\tinstr <<= 1;\n\t}\n\toutb(SE2CS, base + TUL_NVRAM);\t\t\t \n\tudelay(30);\n}\n\n\n \nvoid initio_se2_ew_en(unsigned long base)\n{\n\tinitio_se2_instr(base, 0x30);\t \n\toutb(0, base + TUL_NVRAM);\t \n\tudelay(30);\n}\n\n\n \nvoid initio_se2_ew_ds(unsigned long base)\n{\n\tinitio_se2_instr(base, 0);\t \n\toutb(0, base + TUL_NVRAM);\t \n\tudelay(30);\n}\n\n\n \nstatic u16 initio_se2_rd(unsigned long base, u8 addr)\n{\n\tu8 instr, rb;\n\tu16 val = 0;\n\tint i;\n\n\tinstr = (u8) (addr | 0x80);\n\tinitio_se2_instr(base, instr);\t \n\n\tfor (i = 15; i >= 0; i--) {\n\t\toutb(SE2CS | SE2CLK, base + TUL_NVRAM);\t \n\t\tudelay(30);\n\t\toutb(SE2CS, base + TUL_NVRAM);\t\t \n\n\t\t \n\t\trb = inb(base + TUL_NVRAM);\n\t\trb &= SE2DI;\n\t\tval += (rb << i);\n\t\tudelay(30);\t \n\t}\n\n\toutb(0, base + TUL_NVRAM);\t\t \n\tudelay(30);\n\treturn val;\n}\n\n \nstatic void initio_se2_wr(unsigned long base, u8 addr, u16 val)\n{\n\tu8 rb;\n\tu8 instr;\n\tint i;\n\n\tinstr = (u8) (addr | 0x40);\n\tinitio_se2_instr(base, instr);\t \n\tfor (i = 15; i >= 0; i--) {\n\t\tif (val & 0x8000)\n\t\t\toutb(SE2CS | SE2DO, base + TUL_NVRAM);\t \n\t\telse\n\t\t\toutb(SE2CS, base + TUL_NVRAM);\t\t \n\t\tudelay(30);\n\t\toutb(SE2CS | SE2CLK, base + TUL_NVRAM);\t\t \n\t\tudelay(30);\n\t\tval <<= 1;\n\t}\n\toutb(SE2CS, base + TUL_NVRAM);\t\t\t\t \n\tudelay(30);\n\toutb(0, base + TUL_NVRAM);\t\t\t\t \n\tudelay(30);\n\n\toutb(SE2CS, base + TUL_NVRAM);\t\t\t\t \n\tudelay(30);\n\n\tfor (;;) {\n\t\toutb(SE2CS | SE2CLK, base + TUL_NVRAM);\t\t \n\t\tudelay(30);\n\t\toutb(SE2CS, base + TUL_NVRAM);\t\t\t \n\t\tudelay(30);\n\t\tif ((rb = inb(base + TUL_NVRAM)) & SE2DI)\n\t\t\tbreak;\t \n\t}\n\toutb(0, base + TUL_NVRAM);\t\t\t\t \n}\n\n \n\nstatic int initio_se2_rd_all(unsigned long base)\n{\n\tint i;\n\tu16 chksum = 0;\n\tu16 *np;\n\n\ti91unvramp = &i91unvram;\n\tnp = (u16 *) i91unvramp;\n\tfor (i = 0; i < 32; i++)\n\t\t*np++ = initio_se2_rd(base, i);\n\n\t \n\tif (i91unvramp->NVM_Signature != INI_SIGNATURE)\n\t\treturn -1;\n\t \n\tnp = (u16 *) i91unvramp;\n\tfor (i = 0; i < 31; i++)\n\t\tchksum += *np++;\n\tif (i91unvramp->NVM_CheckSum != chksum)\n\t\treturn -1;\n\treturn 1;\n}\n\n \nstatic void initio_se2_update_all(unsigned long base)\n{\t\t\t\t \n\tint i;\n\tu16 chksum = 0;\n\tu16 *np, *np1;\n\n\ti91unvramp = &i91unvram;\n\t \n\tnp = (u16 *) i91udftNvRam;\n\tfor (i = 0; i < 31; i++)\n\t\tchksum += *np++;\n\t*np = chksum;\n\tinitio_se2_ew_en(base);\t \n\n\tnp = (u16 *) i91udftNvRam;\n\tnp1 = (u16 *) i91unvramp;\n\tfor (i = 0; i < 32; i++, np++, np1++) {\n\t\tif (*np != *np1)\n\t\t\tinitio_se2_wr(base, i, *np);\n\t}\n\tinitio_se2_ew_ds(base);\t \n}\n\n \n\nstatic void initio_read_eeprom(unsigned long base)\n{\n\tu8 gctrl;\n\n\ti91unvramp = &i91unvram;\n\t \n\tgctrl = inb(base + TUL_GCTRL);\n\toutb(gctrl | TUL_GCTRL_EEPROM_BIT, base + TUL_GCTRL);\n\tif (initio_se2_rd_all(base) != 1) {\n\t\tinitio_se2_update_all(base);\t \n\t\tinitio_se2_rd_all(base);\t \n\t}\n\t \n\tgctrl = inb(base + TUL_GCTRL);\n\toutb(gctrl & ~TUL_GCTRL_EEPROM_BIT, base + TUL_GCTRL);\n}\n\n \n\nstatic void initio_stop_bm(struct initio_host * host)\n{\n\n\tif (inb(host->addr + TUL_XStatus) & XPEND) {\t \n\t\toutb(TAX_X_ABT | TAX_X_CLR_FIFO, host->addr + TUL_XCmd);\n\t\t \n\t\twhile ((inb(host->addr + TUL_Int) & XABT) == 0)\n\t\t\tcpu_relax();\n\t}\n\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\n}\n\n \n\nstatic int initio_reset_scsi(struct initio_host * host, int seconds)\n{\n\toutb(TSC_RST_BUS, host->addr + TUL_SCtrl0);\n\n\twhile (!((host->jsint = inb(host->addr + TUL_SInt)) & TSS_SCSIRST_INT))\n\t\tcpu_relax();\n\n\t \n\toutb(0, host->addr + TUL_SSignal);\n\n\t \n\t \n\t \n\tinitio_do_pause(seconds * HZ);\n\n\tinb(host->addr + TUL_SInt);\n\treturn SCSI_RESET_SUCCESS;\n}\n\n \n\nstatic void initio_init(struct initio_host * host, u8 *bios_addr)\n{\n\tint i;\n\tu8 *flags;\n\tu8 *heads;\n\n\t \n\tinitio_read_eeprom(host->addr);\n\tif (i91unvramp->NVM_SCSIInfo[0].NVM_NumOfTarg == 8)\n\t\thost->max_tar = 8;\n\telse\n\t\thost->max_tar = 16;\n\n\thost->config = i91unvramp->NVM_SCSIInfo[0].NVM_ChConfig1;\n\n\thost->scsi_id = i91unvramp->NVM_SCSIInfo[0].NVM_ChSCSIID;\n\thost->idmask = ~(1 << host->scsi_id);\n\n#ifdef CHK_PARITY\n\t \n\toutb(inb(host->addr + TUL_PCMD) | 0x40, host->addr + TUL_PCMD);\n#endif\n\n\t \n\toutb(0x1F, host->addr + TUL_Mask);\n\n\tinitio_stop_bm(host);\n\t \n\toutb(TSC_RST_CHIP, host->addr + TUL_SCtrl0);\n\n\t \n\toutb(host->scsi_id << 4, host->addr + TUL_SScsiId);\n\n\t \n\tif (host->config & HCC_EN_PAR)\n\t\thost->sconf1 = (TSC_INITDEFAULT | TSC_EN_SCSI_PAR);\n\telse\n\t\thost->sconf1 = (TSC_INITDEFAULT);\n\toutb(host->sconf1, host->addr + TUL_SConfig);\n\n\t \n\toutb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\n\n\toutb(0, host->addr + TUL_SPeriod);\n\n\t \n\toutb(153, host->addr + TUL_STimeOut);\n\n\t \n\toutb((host->config & (HCC_ACT_TERM1 | HCC_ACT_TERM2)),\n\t\thost->addr + TUL_XCtrl);\n\toutb(((host->config & HCC_AUTO_TERM) >> 4) |\n\t\t(inb(host->addr + TUL_GCTRL1) & 0xFE),\n\t\thost->addr + TUL_GCTRL1);\n\n\tfor (i = 0,\n\t     flags = & (i91unvramp->NVM_SCSIInfo[0].NVM_Targ0Config),\n\t     heads = bios_addr + 0x180;\n\t     i < host->max_tar;\n\t     i++, flags++) {\n\t\thost->targets[i].flags = *flags & ~(TCF_SYNC_DONE | TCF_WDTR_DONE);\n\t\tif (host->targets[i].flags & TCF_EN_255)\n\t\t\thost->targets[i].drv_flags = TCF_DRV_255_63;\n\t\telse\n\t\t\thost->targets[i].drv_flags = 0;\n\t\thost->targets[i].js_period = 0;\n\t\thost->targets[i].sconfig0 = host->sconf1;\n\t\thost->targets[i].heads = *heads++;\n\t\tif (host->targets[i].heads == 255)\n\t\t\thost->targets[i].drv_flags = TCF_DRV_255_63;\n\t\telse\n\t\t\thost->targets[i].drv_flags = 0;\n\t\thost->targets[i].sectors = *heads++;\n\t\thost->targets[i].flags &= ~TCF_BUSY;\n\t\thost->act_tags[i] = 0;\n\t\thost->max_tags[i] = 0xFF;\n\t}\t\t\t \n\tprintk(\"i91u: PCI Base=0x%04X, IRQ=%d, BIOS=0x%04X0, SCSI ID=%d\\n\",\n\t       host->addr, host->pci_dev->irq,\n\t       host->bios_addr, host->scsi_id);\n\t \n\tif (host->config & HCC_SCSI_RESET) {\n\t\tprintk(KERN_INFO \"i91u: Reset SCSI Bus ... \\n\");\n\t\tinitio_reset_scsi(host, 10);\n\t}\n\toutb(0x17, host->addr + TUL_SCFG1);\n\toutb(0xE9, host->addr + TUL_SIntEnable);\n}\n\n \nstatic struct scsi_ctrl_blk *initio_alloc_scb(struct initio_host *host)\n{\n\tstruct scsi_ctrl_blk *scb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->avail_lock, flags);\n\tif ((scb = host->first_avail) != NULL) {\n#if DEBUG_QUEUE\n\t\tprintk(\"find scb at %p\\n\", scb);\n#endif\n\t\tif ((host->first_avail = scb->next) == NULL)\n\t\t\thost->last_avail = NULL;\n\t\tscb->next = NULL;\n\t\tscb->status = SCB_RENT;\n\t}\n\tspin_unlock_irqrestore(&host->avail_lock, flags);\n\treturn scb;\n}\n\n \n\nstatic void initio_release_scb(struct initio_host * host, struct scsi_ctrl_blk * cmnd)\n{\n\tunsigned long flags;\n\n#if DEBUG_QUEUE\n\tprintk(\"Release SCB %p; \", cmnd);\n#endif\n\tspin_lock_irqsave(&(host->avail_lock), flags);\n\tcmnd->srb = NULL;\n\tcmnd->status = 0;\n\tcmnd->next = NULL;\n\tif (host->last_avail != NULL) {\n\t\thost->last_avail->next = cmnd;\n\t\thost->last_avail = cmnd;\n\t} else {\n\t\thost->first_avail = cmnd;\n\t\thost->last_avail = cmnd;\n\t}\n\tspin_unlock_irqrestore(&(host->avail_lock), flags);\n}\n\n \nstatic void initio_append_pend_scb(struct initio_host * host, struct scsi_ctrl_blk * scbp)\n{\n\n#if DEBUG_QUEUE\n\tprintk(\"Append pend SCB %p; \", scbp);\n#endif\n\tscbp->status = SCB_PEND;\n\tscbp->next = NULL;\n\tif (host->last_pending != NULL) {\n\t\thost->last_pending->next = scbp;\n\t\thost->last_pending = scbp;\n\t} else {\n\t\thost->first_pending = scbp;\n\t\thost->last_pending = scbp;\n\t}\n}\n\n \nstatic void initio_push_pend_scb(struct initio_host * host, struct scsi_ctrl_blk * scbp)\n{\n\n#if DEBUG_QUEUE\n\tprintk(\"Push pend SCB %p; \", scbp);\n#endif\n\tscbp->status = SCB_PEND;\n\tif ((scbp->next = host->first_pending) != NULL) {\n\t\thost->first_pending = scbp;\n\t} else {\n\t\thost->first_pending = scbp;\n\t\thost->last_pending = scbp;\n\t}\n}\n\nstatic struct scsi_ctrl_blk *initio_find_first_pend_scb(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *first;\n\n\n\tfirst = host->first_pending;\n\twhile (first != NULL) {\n\t\tif (first->opcode != ExecSCSI)\n\t\t\treturn first;\n\t\tif (first->tagmsg == 0) {\n\t\t\tif ((host->act_tags[first->target] == 0) &&\n\t\t\t    !(host->targets[first->target].flags & TCF_BUSY))\n\t\t\t\treturn first;\n\t\t} else {\n\t\t\tif ((host->act_tags[first->target] >=\n\t\t\t  host->max_tags[first->target]) |\n\t\t\t    (host->targets[first->target].flags & TCF_BUSY)) {\n\t\t\t\tfirst = first->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn first;\n\t\t}\n\t\tfirst = first->next;\n\t}\n\treturn first;\n}\n\nstatic void initio_unlink_pend_scb(struct initio_host * host, struct scsi_ctrl_blk * scb)\n{\n\tstruct scsi_ctrl_blk *tmp, *prev;\n\n#if DEBUG_QUEUE\n\tprintk(\"unlink pend SCB %p; \", scb);\n#endif\n\n\tprev = tmp = host->first_pending;\n\twhile (tmp != NULL) {\n\t\tif (scb == tmp) {\t \n\t\t\tif (tmp == host->first_pending) {\n\t\t\t\tif ((host->first_pending = tmp->next) == NULL)\n\t\t\t\t\thost->last_pending = NULL;\n\t\t\t} else {\n\t\t\t\tprev->next = tmp->next;\n\t\t\t\tif (tmp == host->last_pending)\n\t\t\t\t\thost->last_pending = prev;\n\t\t\t}\n\t\t\ttmp->next = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tprev = tmp;\n\t\ttmp = tmp->next;\n\t}\n}\n\nstatic void initio_append_busy_scb(struct initio_host * host, struct scsi_ctrl_blk * scbp)\n{\n\n#if DEBUG_QUEUE\n\tprintk(\"append busy SCB %p; \", scbp);\n#endif\n\tif (scbp->tagmsg)\n\t\thost->act_tags[scbp->target]++;\n\telse\n\t\thost->targets[scbp->target].flags |= TCF_BUSY;\n\tscbp->status = SCB_BUSY;\n\tscbp->next = NULL;\n\tif (host->last_busy != NULL) {\n\t\thost->last_busy->next = scbp;\n\t\thost->last_busy = scbp;\n\t} else {\n\t\thost->first_busy = scbp;\n\t\thost->last_busy = scbp;\n\t}\n}\n\n \nstatic struct scsi_ctrl_blk *initio_pop_busy_scb(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *tmp;\n\n\n\tif ((tmp = host->first_busy) != NULL) {\n\t\tif ((host->first_busy = tmp->next) == NULL)\n\t\t\thost->last_busy = NULL;\n\t\ttmp->next = NULL;\n\t\tif (tmp->tagmsg)\n\t\t\thost->act_tags[tmp->target]--;\n\t\telse\n\t\t\thost->targets[tmp->target].flags &= ~TCF_BUSY;\n\t}\n#if DEBUG_QUEUE\n\tprintk(\"Pop busy SCB %p; \", tmp);\n#endif\n\treturn tmp;\n}\n\n \nstatic void initio_unlink_busy_scb(struct initio_host * host, struct scsi_ctrl_blk * scb)\n{\n\tstruct scsi_ctrl_blk *tmp, *prev;\n\n#if DEBUG_QUEUE\n\tprintk(\"unlink busy SCB %p; \", scb);\n#endif\n\n\tprev = tmp = host->first_busy;\n\twhile (tmp != NULL) {\n\t\tif (scb == tmp) {\t \n\t\t\tif (tmp == host->first_busy) {\n\t\t\t\tif ((host->first_busy = tmp->next) == NULL)\n\t\t\t\t\thost->last_busy = NULL;\n\t\t\t} else {\n\t\t\t\tprev->next = tmp->next;\n\t\t\t\tif (tmp == host->last_busy)\n\t\t\t\t\thost->last_busy = prev;\n\t\t\t}\n\t\t\ttmp->next = NULL;\n\t\t\tif (tmp->tagmsg)\n\t\t\t\thost->act_tags[tmp->target]--;\n\t\t\telse\n\t\t\t\thost->targets[tmp->target].flags &= ~TCF_BUSY;\n\t\t\tbreak;\n\t\t}\n\t\tprev = tmp;\n\t\ttmp = tmp->next;\n\t}\n\treturn;\n}\n\nstruct scsi_ctrl_blk *initio_find_busy_scb(struct initio_host * host, u16 tarlun)\n{\n\tstruct scsi_ctrl_blk *tmp;\n\tu16 scbp_tarlun;\n\n\n\ttmp = host->first_busy;\n\twhile (tmp != NULL) {\n\t\tscbp_tarlun = (tmp->lun << 8) | (tmp->target);\n\t\tif (scbp_tarlun == tarlun) {\t \n\t\t\tbreak;\n\t\t}\n\t\ttmp = tmp->next;\n\t}\n#if DEBUG_QUEUE\n\tprintk(\"find busy SCB %p; \", tmp);\n#endif\n\treturn tmp;\n}\n\nstatic void initio_append_done_scb(struct initio_host * host, struct scsi_ctrl_blk * scbp)\n{\n#if DEBUG_QUEUE\n\tprintk(\"append done SCB %p; \", scbp);\n#endif\n\n\tscbp->status = SCB_DONE;\n\tscbp->next = NULL;\n\tif (host->last_done != NULL) {\n\t\thost->last_done->next = scbp;\n\t\thost->last_done = scbp;\n\t} else {\n\t\thost->first_done = scbp;\n\t\thost->last_done = scbp;\n\t}\n}\n\nstruct scsi_ctrl_blk *initio_find_done_scb(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *tmp;\n\n\tif ((tmp = host->first_done) != NULL) {\n\t\tif ((host->first_done = tmp->next) == NULL)\n\t\t\thost->last_done = NULL;\n\t\ttmp->next = NULL;\n\t}\n#if DEBUG_QUEUE\n\tprintk(\"find done SCB %p; \",tmp);\n#endif\n\treturn tmp;\n}\n\nstatic int initio_abort_srb(struct initio_host * host, struct scsi_cmnd *srbp)\n{\n\tunsigned long flags;\n\tstruct scsi_ctrl_blk *tmp, *prev;\n\n\tspin_lock_irqsave(&host->semaph_lock, flags);\n\n\tif ((host->semaph == 0) && (host->active == NULL)) {\n\t\t \n\t\toutb(0x1F, host->addr + TUL_Mask);\n\t\tspin_unlock_irqrestore(&host->semaph_lock, flags);\n\t\t \n\t\ttulip_main(host);\n\t\tspin_lock_irqsave(&host->semaph_lock, flags);\n\t\thost->semaph = 1;\n\t\toutb(0x0F, host->addr + TUL_Mask);\n\t\tspin_unlock_irqrestore(&host->semaph_lock, flags);\n\t\treturn SCSI_ABORT_SNOOZE;\n\t}\n\tprev = tmp = host->first_pending;\t \n\twhile (tmp != NULL) {\n\t\t \n\t\tif (tmp->srb == srbp) {\n\t\t\tif (tmp == host->active) {\n\t\t\t\tspin_unlock_irqrestore(&host->semaph_lock, flags);\n\t\t\t\treturn SCSI_ABORT_BUSY;\n\t\t\t} else if (tmp == host->first_pending) {\n\t\t\t\tif ((host->first_pending = tmp->next) == NULL)\n\t\t\t\t\thost->last_pending = NULL;\n\t\t\t} else {\n\t\t\t\tprev->next = tmp->next;\n\t\t\t\tif (tmp == host->last_pending)\n\t\t\t\t\thost->last_pending = prev;\n\t\t\t}\n\t\t\ttmp->hastat = HOST_ABORTED;\n\t\t\ttmp->flags |= SCF_DONE;\n\t\t\tif (tmp->flags & SCF_POST)\n\t\t\t\t(*tmp->post) ((u8 *) host, (u8 *) tmp);\n\t\t\tspin_unlock_irqrestore(&host->semaph_lock, flags);\n\t\t\treturn SCSI_ABORT_SUCCESS;\n\t\t}\n\t\tprev = tmp;\n\t\ttmp = tmp->next;\n\t}\n\n\tprev = tmp = host->first_busy;\t \n\twhile (tmp != NULL) {\n\t\tif (tmp->srb == srbp) {\n\t\t\tif (tmp == host->active) {\n\t\t\t\tspin_unlock_irqrestore(&host->semaph_lock, flags);\n\t\t\t\treturn SCSI_ABORT_BUSY;\n\t\t\t} else if (tmp->tagmsg == 0) {\n\t\t\t\tspin_unlock_irqrestore(&host->semaph_lock, flags);\n\t\t\t\treturn SCSI_ABORT_BUSY;\n\t\t\t} else {\n\t\t\t\thost->act_tags[tmp->target]--;\n\t\t\t\tif (tmp == host->first_busy) {\n\t\t\t\t\tif ((host->first_busy = tmp->next) == NULL)\n\t\t\t\t\t\thost->last_busy = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tprev->next = tmp->next;\n\t\t\t\t\tif (tmp == host->last_busy)\n\t\t\t\t\t\thost->last_busy = prev;\n\t\t\t\t}\n\t\t\t\ttmp->next = NULL;\n\n\n\t\t\t\ttmp->hastat = HOST_ABORTED;\n\t\t\t\ttmp->flags |= SCF_DONE;\n\t\t\t\tif (tmp->flags & SCF_POST)\n\t\t\t\t\t(*tmp->post) ((u8 *) host, (u8 *) tmp);\n\t\t\t\tspin_unlock_irqrestore(&host->semaph_lock, flags);\n\t\t\t\treturn SCSI_ABORT_SUCCESS;\n\t\t\t}\n\t\t}\n\t\tprev = tmp;\n\t\ttmp = tmp->next;\n\t}\n\tspin_unlock_irqrestore(&host->semaph_lock, flags);\n\treturn SCSI_ABORT_NOT_RUNNING;\n}\n\n \nstatic int initio_bad_seq(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb;\n\n\tprintk(\"initio_bad_seg c=%d\\n\", host->index);\n\n\tif ((scb = host->active) != NULL) {\n\t\tinitio_unlink_busy_scb(host, scb);\n\t\tscb->hastat = HOST_BAD_PHAS;\n\t\tscb->tastat = 0;\n\t\tinitio_append_done_scb(host, scb);\n\t}\n\tinitio_stop_bm(host);\n\tinitio_reset_scsi(host, 8);\t \n\treturn initio_post_scsi_rst(host);\n}\n\n\n \nstatic void initio_exec_scb(struct initio_host * host, struct scsi_ctrl_blk * scb)\n{\n\tunsigned long flags;\n\n\tscb->mode = 0;\n\n\tscb->sgidx = 0;\n\tscb->sgmax = scb->sglen;\n\n\tspin_lock_irqsave(&host->semaph_lock, flags);\n\n\tinitio_append_pend_scb(host, scb);\t \n\n \n\tif (host->semaph == 1) {\n\t\t \n\t\toutb(0x1F, host->addr + TUL_Mask);\n\t\thost->semaph = 0;\n\t\tspin_unlock_irqrestore(&host->semaph_lock, flags);\n\n\t\ttulip_main(host);\n\n\t\tspin_lock_irqsave(&host->semaph_lock, flags);\n\t\thost->semaph = 1;\n\t\toutb(0x0F, host->addr + TUL_Mask);\n\t}\n\tspin_unlock_irqrestore(&host->semaph_lock, flags);\n\treturn;\n}\n\n \nstatic int initio_isr(struct initio_host * host)\n{\n\tif (inb(host->addr + TUL_Int) & TSS_INT_PENDING) {\n\t\tif (host->semaph == 1) {\n\t\t\toutb(0x1F, host->addr + TUL_Mask);\n\t\t\t \n\t\t\thost->semaph = 0;\n\n\t\t\ttulip_main(host);\n\n\t\t\thost->semaph = 1;\n\t\t\toutb(0x0F, host->addr + TUL_Mask);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int tulip_main(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb;\n\n\tfor (;;) {\n\t\ttulip_scsi(host);\t \n\n\t\t \n\t\twhile ((scb = initio_find_done_scb(host)) != NULL) {\t \n\t\t\tif (scb->tastat == INI_QUEUE_FULL) {\n\t\t\t\thost->max_tags[scb->target] =\n\t\t\t\t    host->act_tags[scb->target] - 1;\n\t\t\t\tscb->tastat = 0;\n\t\t\t\tinitio_append_pend_scb(host, scb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(scb->mode & SCM_RSENS)) {\t\t \n\t\t\t\tif (scb->tastat == 2) {\n\n\t\t\t\t\t \n\n\t\t\t\t\tif (scb->flags & SCF_SENSE) {\n\t\t\t\t\t\tu8 len;\n\t\t\t\t\t\tlen = scb->senselen;\n\t\t\t\t\t\tif (len == 0)\n\t\t\t\t\t\t\tlen = 1;\n\t\t\t\t\t\tscb->buflen = scb->senselen;\n\t\t\t\t\t\tscb->bufptr = scb->senseptr;\n\t\t\t\t\t\tscb->flags &= ~(SCF_SG | SCF_DIR);\t \n\t\t\t\t\t\t \n\t\t\t\t\t\tscb->mode = SCM_RSENS;\n\t\t\t\t\t\tscb->ident &= 0xBF;\t \n\t\t\t\t\t\tscb->tagmsg = 0;\n\t\t\t\t\t\tscb->tastat = 0;\n\t\t\t\t\t\tscb->cdblen = 6;\n\t\t\t\t\t\tscb->cdb[0] = SCSICMD_RequestSense;\n\t\t\t\t\t\tscb->cdb[1] = 0;\n\t\t\t\t\t\tscb->cdb[2] = 0;\n\t\t\t\t\t\tscb->cdb[3] = 0;\n\t\t\t\t\t\tscb->cdb[4] = len;\n\t\t\t\t\t\tscb->cdb[5] = 0;\n\t\t\t\t\t\tinitio_push_pend_scb(host, scb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\t \n\n\t\t\t\tif (scb->tastat == 2) {\t\t \n\t\t\t\t\tscb->hastat = HOST_BAD_PHAS;\n\t\t\t\t}\n\t\t\t\tscb->tastat = 2;\n\t\t\t}\n\t\t\tscb->flags |= SCF_DONE;\n\t\t\tif (scb->flags & SCF_POST) {\n\t\t\t\t \n\t\t\t\t(*scb->post) ((u8 *) host, (u8 *) scb);\n\t\t\t}\n\t\t}\t\t \n\t\t \n\t\tif (inb(host->addr + TUL_SStatus0) & TSS_INT_PENDING)\n\t\t\tcontinue;\n\t\tif (host->active)\t \n\t\t\treturn 1;\t \n\t\t \n\t\tif (initio_find_first_pend_scb(host) == NULL)\n\t\t\treturn 1;\t \n\t}\t\t\t \n\t \n}\n\nstatic void tulip_scsi(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb;\n\tstruct target_control *active_tc;\n\n\t \n\tif ((host->jsstatus0 = inb(host->addr + TUL_SStatus0)) & TSS_INT_PENDING) {\n\t\thost->phase = host->jsstatus0 & TSS_PH_MASK;\n\t\thost->jsstatus1 = inb(host->addr + TUL_SStatus1);\n\t\thost->jsint = inb(host->addr + TUL_SInt);\n\t\tif (host->jsint & TSS_SCSIRST_INT) {\t \n\t\t\tint_initio_scsi_rst(host);\n\t\t\treturn;\n\t\t}\n\t\tif (host->jsint & TSS_RESEL_INT) {\t \n\t\t\tif (int_initio_resel(host) == 0)\n\t\t\t\tinitio_next_state(host);\n\t\t\treturn;\n\t\t}\n\t\tif (host->jsint & TSS_SEL_TIMEOUT) {\n\t\t\tint_initio_busfree(host);\n\t\t\treturn;\n\t\t}\n\t\tif (host->jsint & TSS_DISC_INT) {\t \n\t\t\tint_initio_busfree(host);\t \n\t\t\treturn;\n\t\t}\n\t\tif (host->jsint & (TSS_FUNC_COMP | TSS_BUS_SERV)) {\t \n\t\t\tif (host->active)\n\t\t\t\tinitio_next_state(host);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (host->active != NULL)\n\t\treturn;\n\n\tif ((scb = initio_find_first_pend_scb(host)) == NULL)\n\t\treturn;\n\n\t \n\toutb((host->scsi_id << 4) | (scb->target & 0x0F),\n\t\thost->addr + TUL_SScsiId);\n\tif (scb->opcode == ExecSCSI) {\n\t\tactive_tc = &host->targets[scb->target];\n\n\t\tif (scb->tagmsg)\n\t\t\tactive_tc->drv_flags |= TCF_DRV_EN_TAG;\n\t\telse\n\t\t\tactive_tc->drv_flags &= ~TCF_DRV_EN_TAG;\n\n\t\toutb(active_tc->js_period, host->addr + TUL_SPeriod);\n\t\tif ((active_tc->flags & (TCF_WDTR_DONE | TCF_NO_WDTR)) == 0) {\t \n\t\t\tinitio_select_atn_stop(host, scb);\n\t\t} else {\n\t\t\tif ((active_tc->flags & (TCF_SYNC_DONE | TCF_NO_SYNC_NEGO)) == 0) {\t \n\t\t\t\tinitio_select_atn_stop(host, scb);\n\t\t\t} else {\n\t\t\t\tif (scb->tagmsg)\n\t\t\t\t\tinitio_select_atn3(host, scb);\n\t\t\t\telse\n\t\t\t\t\tinitio_select_atn(host, scb);\n\t\t\t}\n\t\t}\n\t\tif (scb->flags & SCF_POLL) {\n\t\t\twhile (wait_tulip(host) != -1) {\n\t\t\t\tif (initio_next_state(host) == -1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (scb->opcode == BusDevRst) {\n\t\tinitio_select_atn_stop(host, scb);\n\t\tscb->next_state = 8;\n\t\tif (scb->flags & SCF_POLL) {\n\t\t\twhile (wait_tulip(host) != -1) {\n\t\t\t\tif (initio_next_state(host) == -1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (scb->opcode == AbortCmd) {\n\t\tif (initio_abort_srb(host, scb->srb) != 0) {\n\t\t\tinitio_unlink_pend_scb(host, scb);\n\t\t\tinitio_release_scb(host, scb);\n\t\t} else {\n\t\t\tscb->opcode = BusDevRst;\n\t\t\tinitio_select_atn_stop(host, scb);\n\t\t\tscb->next_state = 8;\n\t\t}\n\t} else {\n\t\tinitio_unlink_pend_scb(host, scb);\n\t\tscb->hastat = 0x16;\t \n\t\tinitio_append_done_scb(host, scb);\n\t}\n\treturn;\n}\n\n \n\nstatic int initio_next_state(struct initio_host * host)\n{\n\tint next;\n\n\tnext = host->active->next_state;\n\tfor (;;) {\n\t\tswitch (next) {\n\t\tcase 1:\n\t\t\tnext = initio_state_1(host);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tnext = initio_state_2(host);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tnext = initio_state_3(host);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tnext = initio_state_4(host);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tnext = initio_state_5(host);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tnext = initio_state_6(host);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tnext = initio_state_7(host);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\treturn initio_bus_device_reset(host);\n\t\tdefault:\n\t\t\treturn initio_bad_seq(host);\n\t\t}\n\t\tif (next <= 0)\n\t\t\treturn next;\n\t}\n}\n\n\n \n\nstatic int initio_state_1(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb = host->active;\n\tstruct target_control *active_tc = host->active_tc;\n#if DEBUG_STATE\n\tprintk(\"-s1-\");\n#endif\n\n\t \n\tinitio_unlink_pend_scb(host, scb);\n\tinitio_append_busy_scb(host, scb);\n\n\toutb(active_tc->sconfig0, host->addr + TUL_SConfig );\n\t \n\tif (host->phase == MSG_OUT) {\n\t\toutb(TSC_EN_BUS_IN | TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\n\t\toutb(scb->ident, host->addr + TUL_SFifo);\n\n\t\tif (scb->tagmsg) {\n\t\t\toutb(scb->tagmsg, host->addr + TUL_SFifo);\n\t\t\toutb(scb->tagid, host->addr + TUL_SFifo);\n\t\t}\n\t\tif ((active_tc->flags & (TCF_WDTR_DONE | TCF_NO_WDTR)) == 0) {\n\t\t\tactive_tc->flags |= TCF_WDTR_DONE;\n\t\t\toutb(EXTENDED_MESSAGE, host->addr + TUL_SFifo);\n\t\t\toutb(2, host->addr + TUL_SFifo);\t \n\t\t\toutb(EXTENDED_SDTR, host->addr + TUL_SFifo);\t \n\t\t\toutb(1, host->addr + TUL_SFifo);\t \n\t\t} else if ((active_tc->flags & (TCF_SYNC_DONE | TCF_NO_SYNC_NEGO)) == 0) {\n\t\t\tactive_tc->flags |= TCF_SYNC_DONE;\n\t\t\toutb(EXTENDED_MESSAGE, host->addr + TUL_SFifo);\n\t\t\toutb(3, host->addr + TUL_SFifo);\t \n\t\t\toutb(EXTENDED_SDTR, host->addr + TUL_SFifo);\t \n\t\t\toutb(initio_rate_tbl[active_tc->flags & TCF_SCSI_RATE], host->addr + TUL_SFifo);\n\t\t\toutb(MAX_OFFSET, host->addr + TUL_SFifo);\t \n\t\t}\n\t\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\t\tif (wait_tulip(host) == -1)\n\t\t\treturn -1;\n\t}\n\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\n\toutb((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)), host->addr + TUL_SSignal);\n\t \n\treturn 3;\n}\n\n\n \n\nstatic int initio_state_2(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb = host->active;\n\tstruct target_control *active_tc = host->active_tc;\n#if DEBUG_STATE\n\tprintk(\"-s2-\");\n#endif\n\n\tinitio_unlink_pend_scb(host, scb);\n\tinitio_append_busy_scb(host, scb);\n\n\toutb(active_tc->sconfig0, host->addr + TUL_SConfig);\n\n\tif (host->jsstatus1 & TSS_CMD_PH_CMP)\n\t\treturn 4;\n\n\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\n\toutb((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)), host->addr + TUL_SSignal);\n\t \n\treturn 3;\n}\n\n \n\nstatic int initio_state_3(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb = host->active;\n\tstruct target_control *active_tc = host->active_tc;\n\tint i;\n\n#if DEBUG_STATE\n\tprintk(\"-s3-\");\n#endif\n\tfor (;;) {\n\t\tswitch (host->phase) {\n\t\tcase CMD_OUT:\t \n\t\t\tfor (i = 0; i < (int) scb->cdblen; i++)\n\t\t\t\toutb(scb->cdb[i], host->addr + TUL_SFifo);\n\t\t\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\t\t\tif (wait_tulip(host) == -1)\n\t\t\t\treturn -1;\n\t\t\tif (host->phase == CMD_OUT)\n\t\t\t\treturn initio_bad_seq(host);\n\t\t\treturn 4;\n\n\t\tcase MSG_IN:\t \n\t\t\tscb->next_state = 3;\n\t\t\tif (initio_msgin(host) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase STATUS_IN:\t \n\t\t\tif (initio_status_msg(host) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase MSG_OUT:\t \n\t\t\tif (active_tc->flags & (TCF_SYNC_DONE | TCF_NO_SYNC_NEGO)) {\n\t\t\t\toutb(NOP, host->addr + TUL_SFifo);\t\t \n\t\t\t\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\t\t\t\tif (wait_tulip(host) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tactive_tc->flags |= TCF_SYNC_DONE;\n\n\t\t\t\toutb(EXTENDED_MESSAGE, host->addr + TUL_SFifo);\n\t\t\t\toutb(3, host->addr + TUL_SFifo);\t \n\t\t\t\toutb(EXTENDED_SDTR, host->addr + TUL_SFifo);\t \n\t\t\t\toutb(initio_rate_tbl[active_tc->flags & TCF_SCSI_RATE], host->addr + TUL_SFifo);\n\t\t\t\toutb(MAX_OFFSET, host->addr + TUL_SFifo);\t \n\t\t\t\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\t\t\t\tif (wait_tulip(host) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\n\t\t\t\toutb(inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7), host->addr + TUL_SSignal);\n\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn initio_bad_seq(host);\n\t\t}\n\t}\n}\n\n \n\nstatic int initio_state_4(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb = host->active;\n\n#if DEBUG_STATE\n\tprintk(\"-s4-\");\n#endif\n\tif ((scb->flags & SCF_DIR) == SCF_NO_XF) {\n\t\treturn 6;\t \n\t}\n\tfor (;;) {\n\t\tif (scb->buflen == 0)\n\t\t\treturn 6;\n\n\t\tswitch (host->phase) {\n\n\t\tcase STATUS_IN:\t \n\t\t\tif ((scb->flags & SCF_DIR) != 0)\t \n\t\t\t\tscb->hastat = HOST_DO_DU;\n\t\t\tif ((initio_status_msg(host)) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase MSG_IN:\t \n\t\t\tscb->next_state = 0x4;\n\t\t\tif (initio_msgin(host) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase MSG_OUT:\t \n\t\t\tif (host->jsstatus0 & TSS_PAR_ERROR) {\n\t\t\t\tscb->buflen = 0;\n\t\t\t\tscb->hastat = HOST_DO_DU;\n\t\t\t\tif (initio_msgout_ide(host) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\treturn 6;\n\t\t\t} else {\n\t\t\t\toutb(NOP, host->addr + TUL_SFifo);\t\t \n\t\t\t\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\t\t\t\tif (wait_tulip(host) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DATA_IN:\t \n\t\t\treturn initio_xfer_data_in(host);\n\n\t\tcase DATA_OUT:\t \n\t\t\treturn initio_xfer_data_out(host);\n\n\t\tdefault:\n\t\t\treturn initio_bad_seq(host);\n\t\t}\n\t}\n}\n\n\n \n\nstatic int initio_state_5(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb = host->active;\n\tlong cnt, xcnt;\t\t \n\n#if DEBUG_STATE\n\tprintk(\"-s5-\");\n#endif\n\t \n\tcnt = inl(host->addr + TUL_SCnt0) & 0x0FFFFFF;\n\n\tif (inb(host->addr + TUL_XCmd) & 0x20) {\n\t\t \n\t\t \n\t\tif (host->jsstatus0 & TSS_PAR_ERROR)\n\t\t\tscb->hastat = HOST_DO_DU;\n\t\tif (inb(host->addr + TUL_XStatus) & XPEND) {\t \n\t\t\t \n\t\t\toutb(inb(host->addr + TUL_XCtrl) | 0x80, host->addr + TUL_XCtrl);\n\t\t\t \n\t\t\twhile (inb(host->addr + TUL_XStatus) & XPEND)\n\t\t\t\tcpu_relax();\n\t\t}\n\t} else {\n\t\t \n\t\tif ((inb(host->addr + TUL_SStatus1) & TSS_XFER_CMP) == 0) {\n\t\t\tif (host->active_tc->js_period & TSC_WIDE_SCSI)\n\t\t\t\tcnt += (inb(host->addr + TUL_SFifoCnt) & 0x1F) << 1;\n\t\t\telse\n\t\t\t\tcnt += (inb(host->addr + TUL_SFifoCnt) & 0x1F);\n\t\t}\n\t\tif (inb(host->addr + TUL_XStatus) & XPEND) {\t \n\t\t\toutb(TAX_X_ABT, host->addr + TUL_XCmd);\n\t\t\t \n\t\t\twhile ((inb(host->addr + TUL_Int) & XABT) == 0)\n\t\t\t\tcpu_relax();\n\t\t}\n\t\tif ((cnt == 1) && (host->phase == DATA_OUT)) {\n\t\t\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\t\t\tif (wait_tulip(host) == -1)\n\t\t\t\treturn -1;\n\t\t\tcnt = 0;\n\t\t} else {\n\t\t\tif ((inb(host->addr + TUL_SStatus1) & TSS_XFER_CMP) == 0)\n\t\t\t\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\n\t\t}\n\t}\n\tif (cnt == 0) {\n\t\tscb->buflen = 0;\n\t\treturn 6;\t \n\t}\n\t \n\txcnt = (long) scb->buflen - cnt;\t \n\tscb->buflen = (u32) cnt;\t\t \n\tif (scb->flags & SCF_SG) {\n\t\tstruct sg_entry *sgp;\n\t\tunsigned long i;\n\n\t\tsgp = &scb->sglist[scb->sgidx];\n\t\tfor (i = scb->sgidx; i < scb->sgmax; sgp++, i++) {\n\t\t\txcnt -= (long) sgp->len;\n\t\t\tif (xcnt < 0) {\t\t \n\t\t\t\txcnt += (long) sgp->len;\t \n\t\t\t\tsgp->data += (u32) xcnt;\t \n\t\t\t\tsgp->len -= (u32) xcnt;\t \n\t\t\t\tscb->bufptr += ((u32) (i - scb->sgidx) << 3);\n\t\t\t\t \n\t\t\t\tscb->sglen = (u8) (scb->sgmax - i);\n\t\t\t\t \n\t\t\t\tscb->sgidx = (u16) i;\n\t\t\t\t \n\t\t\t\treturn 4;\t \n\t\t\t}\n\t\t\t \n\t\t}\t\t \n\t\treturn 6;\t \n\t} else {\n\t\tscb->bufptr += (u32) xcnt;\n\t}\n\treturn 4;\t\t \n}\n\n \n\nstatic int initio_state_6(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb = host->active;\n\n#if DEBUG_STATE\n\tprintk(\"-s6-\");\n#endif\n\tfor (;;) {\n\t\tswitch (host->phase) {\n\t\tcase STATUS_IN:\t \n\t\t\tif ((initio_status_msg(host)) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase MSG_IN:\t \n\t\t\tscb->next_state = 6;\n\t\t\tif ((initio_msgin(host)) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase MSG_OUT:\t \n\t\t\toutb(NOP, host->addr + TUL_SFifo);\t\t \n\t\t\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\t\t\tif (wait_tulip(host) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_IN:\t \n\t\t\treturn initio_xpad_in(host);\n\n\t\tcase DATA_OUT:\t \n\t\t\treturn initio_xpad_out(host);\n\n\t\tdefault:\n\t\t\treturn initio_bad_seq(host);\n\t\t}\n\t}\n}\n\n \n\nstatic int initio_state_7(struct initio_host * host)\n{\n\tint cnt, i;\n\n#if DEBUG_STATE\n\tprintk(\"-s7-\");\n#endif\n\t \n\tcnt = inb(host->addr + TUL_SFifoCnt) & 0x1F;\n\tif (cnt) {\n\t\tfor (i = 0; i < cnt; i++)\n\t\t\tinb(host->addr + TUL_SFifo);\n\t}\n\tswitch (host->phase) {\n\tcase DATA_IN:\t\t \n\tcase DATA_OUT:\t\t \n\t\treturn initio_bad_seq(host);\n\tdefault:\n\t\treturn 6;\t \n\t}\n}\n\n \nstatic int initio_xfer_data_in(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb = host->active;\n\n\tif ((scb->flags & SCF_DIR) == SCF_DOUT)\n\t\treturn 6;\t \n\n\toutl(scb->buflen, host->addr + TUL_SCnt0);\n\toutb(TSC_XF_DMA_IN, host->addr + TUL_SCmd);\t \n\n\tif (scb->flags & SCF_SG) {\t \n\t\toutl(((u32) scb->sglen) << 3, host->addr + TUL_XCntH);\n\t\toutl(scb->bufptr, host->addr + TUL_XAddH);\n\t\toutb(TAX_SG_IN, host->addr + TUL_XCmd);\n\t} else {\n\t\toutl(scb->buflen, host->addr + TUL_XCntH);\n\t\toutl(scb->bufptr, host->addr + TUL_XAddH);\n\t\toutb(TAX_X_IN, host->addr + TUL_XCmd);\n\t}\n\tscb->next_state = 0x5;\n\treturn 0;\t\t \n}\n\n \n\nstatic int initio_xfer_data_out(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb = host->active;\n\n\tif ((scb->flags & SCF_DIR) == SCF_DIN)\n\t\treturn 6;\t \n\n\toutl(scb->buflen, host->addr + TUL_SCnt0);\n\toutb(TSC_XF_DMA_OUT, host->addr + TUL_SCmd);\n\n\tif (scb->flags & SCF_SG) {\t \n\t\toutl(((u32) scb->sglen) << 3, host->addr + TUL_XCntH);\n\t\toutl(scb->bufptr, host->addr + TUL_XAddH);\n\t\toutb(TAX_SG_OUT, host->addr + TUL_XCmd);\n\t} else {\n\t\toutl(scb->buflen, host->addr + TUL_XCntH);\n\t\toutl(scb->bufptr, host->addr + TUL_XAddH);\n\t\toutb(TAX_X_OUT, host->addr + TUL_XCmd);\n\t}\n\n\tscb->next_state = 0x5;\n\treturn 0;\t\t \n}\n\nint initio_xpad_in(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb = host->active;\n\tstruct target_control *active_tc = host->active_tc;\n\n\tif ((scb->flags & SCF_DIR) != SCF_NO_DCHK)\n\t\tscb->hastat = HOST_DO_DU;\t \n\tfor (;;) {\n\t\tif (active_tc->js_period & TSC_WIDE_SCSI)\n\t\t\toutl(2, host->addr + TUL_SCnt0);\n\t\telse\n\t\t\toutl(1, host->addr + TUL_SCnt0);\n\n\t\toutb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);\n\t\tif (wait_tulip(host) == -1)\n\t\t\treturn -1;\n\t\tif (host->phase != DATA_IN) {\n\t\t\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\n\t\t\treturn 6;\n\t\t}\n\t\tinb(host->addr + TUL_SFifo);\n\t}\n}\n\nint initio_xpad_out(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb = host->active;\n\tstruct target_control *active_tc = host->active_tc;\n\n\tif ((scb->flags & SCF_DIR) != SCF_NO_DCHK)\n\t\tscb->hastat = HOST_DO_DU;\t \n\tfor (;;) {\n\t\tif (active_tc->js_period & TSC_WIDE_SCSI)\n\t\t\toutl(2, host->addr + TUL_SCnt0);\n\t\telse\n\t\t\toutl(1, host->addr + TUL_SCnt0);\n\n\t\toutb(0, host->addr + TUL_SFifo);\n\t\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\t\tif ((wait_tulip(host)) == -1)\n\t\t\treturn -1;\n\t\tif (host->phase != DATA_OUT) {\t \n\t\t\toutb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\n\t\t\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\n\t\t\treturn 6;\n\t\t}\n\t}\n}\n\nint initio_status_msg(struct initio_host * host)\n{\t\t\t\t \n\tstruct scsi_ctrl_blk *scb = host->active;\n\tu8 msg;\n\n\toutb(TSC_CMD_COMP, host->addr + TUL_SCmd);\n\tif (wait_tulip(host) == -1)\n\t\treturn -1;\n\n\t \n\tscb->tastat = inb(host->addr + TUL_SFifo);\n\n\tif (host->phase == MSG_OUT) {\n\t\tif (host->jsstatus0 & TSS_PAR_ERROR)\n\t\t\toutb(MSG_PARITY_ERROR, host->addr + TUL_SFifo);\n\t\telse\n\t\t\toutb(NOP, host->addr + TUL_SFifo);\n\t\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\t\treturn wait_tulip(host);\n\t}\n\tif (host->phase == MSG_IN) {\n\t\tmsg = inb(host->addr + TUL_SFifo);\n\t\tif (host->jsstatus0 & TSS_PAR_ERROR) {\t \n\t\t\tif ((initio_msgin_accept(host)) == -1)\n\t\t\t\treturn -1;\n\t\t\tif (host->phase != MSG_OUT)\n\t\t\t\treturn initio_bad_seq(host);\n\t\t\toutb(MSG_PARITY_ERROR, host->addr + TUL_SFifo);\n\t\t\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\t\t\treturn wait_tulip(host);\n\t\t}\n\t\tif (msg == 0) {\t \n\n\t\t\tif ((scb->tastat & 0x18) == 0x10)\t \n\t\t\t\treturn initio_bad_seq(host);\n\t\t\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\n\t\t\toutb(TSC_MSG_ACCEPT, host->addr + TUL_SCmd);\n\t\t\treturn initio_wait_done_disc(host);\n\n\t\t}\n\t\tif (msg == LINKED_CMD_COMPLETE ||\n\t\t    msg == LINKED_FLG_CMD_COMPLETE) {\n\t\t\tif ((scb->tastat & 0x18) == 0x10)\n\t\t\t\treturn initio_msgin_accept(host);\n\t\t}\n\t}\n\treturn initio_bad_seq(host);\n}\n\n\n \nint int_initio_busfree(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb = host->active;\n\n\tif (scb != NULL) {\n\t\tif (scb->status & SCB_SELECT) {\t\t \n\t\t\tinitio_unlink_pend_scb(host, scb);\n\t\t\tscb->hastat = HOST_SEL_TOUT;\n\t\t\tinitio_append_done_scb(host, scb);\n\t\t} else {\t \n\t\t\tinitio_unlink_busy_scb(host, scb);\n\t\t\tscb->hastat = HOST_BUS_FREE;\n\t\t\tinitio_append_done_scb(host, scb);\n\t\t}\n\t\thost->active = NULL;\n\t\thost->active_tc = NULL;\n\t}\n\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\t\t \n\toutb(TSC_INITDEFAULT, host->addr + TUL_SConfig);\n\toutb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\t \n\treturn -1;\n}\n\n\n \n\nstatic int int_initio_scsi_rst(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb;\n\tint i;\n\n\t \n\tif (inb(host->addr + TUL_XStatus) & 0x01) {\n\t\toutb(TAX_X_ABT | TAX_X_CLR_FIFO, host->addr + TUL_XCmd);\n\t\t \n\t\twhile ((inb(host->addr + TUL_Int) & 0x04) == 0)\n\t\t\tcpu_relax();\n\t\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\n\t}\n\t \n\twhile ((scb = initio_pop_busy_scb(host)) != NULL) {\n\t\tscb->hastat = HOST_BAD_PHAS;\n\t\tinitio_append_done_scb(host, scb);\n\t}\n\thost->active = NULL;\n\thost->active_tc = NULL;\n\n\t \n\tfor (i = 0; i < host->max_tar; i++)\n\t\thost->targets[i].flags &= ~(TCF_SYNC_DONE | TCF_WDTR_DONE);\n\treturn -1;\n}\n\n \n\nint int_initio_resel(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb;\n\tstruct target_control *active_tc;\n\tu8 tag, msg = 0;\n\tu8 tar, lun;\n\n\tif ((scb = host->active) != NULL) {\n\t\t \n\t\tif (scb->status & SCB_SELECT)\t\t \n\t\t\tscb->status &= ~SCB_SELECT;\n\t\thost->active = NULL;\n\t}\n\t \n\ttar = inb(host->addr + TUL_SBusId);\n\t \n\tlun = inb(host->addr + TUL_SIdent) & 0x0F;\n\t \n\tactive_tc = &host->targets[tar];\n\thost->active_tc = active_tc;\n\toutb(active_tc->sconfig0, host->addr + TUL_SConfig);\n\toutb(active_tc->js_period, host->addr + TUL_SPeriod);\n\n\t \n\tif (active_tc->drv_flags & TCF_DRV_EN_TAG) {\n\t\tif ((initio_msgin_accept(host)) == -1)\n\t\t\treturn -1;\n\t\tif (host->phase != MSG_IN)\n\t\t\tgoto no_tag;\n\t\toutl(1, host->addr + TUL_SCnt0);\n\t\toutb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);\n\t\tif (wait_tulip(host) == -1)\n\t\t\treturn -1;\n\t\tmsg = inb(host->addr + TUL_SFifo);\t \n\n\t\tif (msg < SIMPLE_QUEUE_TAG || msg > ORDERED_QUEUE_TAG)\n\t\t\t \n\t\t\tgoto no_tag;\n\n\t\tif (initio_msgin_accept(host) == -1)\n\t\t\treturn -1;\n\n\t\tif (host->phase != MSG_IN)\n\t\t\tgoto no_tag;\n\n\t\toutl(1, host->addr + TUL_SCnt0);\n\t\toutb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);\n\t\tif (wait_tulip(host) == -1)\n\t\t\treturn -1;\n\t\ttag = inb(host->addr + TUL_SFifo);\t \n\t\tscb = host->scb + tag;\n\t\tif (scb->target != tar || scb->lun != lun) {\n\t\t\treturn initio_msgout_abort_tag(host);\n\t\t}\n\t\tif (scb->status != SCB_BUSY) {\t \n\t\t\treturn initio_msgout_abort_tag(host);\n\t\t}\n\t\thost->active = scb;\n\t\tif ((initio_msgin_accept(host)) == -1)\n\t\t\treturn -1;\n\t} else {\t\t \n\t      no_tag:\n\t\tif ((scb = initio_find_busy_scb(host, tar | (lun << 8))) == NULL) {\n\t\t\treturn initio_msgout_abort_targ(host);\n\t\t}\n\t\thost->active = scb;\n\t\tif (!(active_tc->drv_flags & TCF_DRV_EN_TAG)) {\n\t\t\tif ((initio_msgin_accept(host)) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\nstatic int int_initio_bad_seq(struct initio_host * host)\n{\t\t\t\t \n\tstruct scsi_ctrl_blk *scb;\n\tint i;\n\n\tinitio_reset_scsi(host, 10);\n\n\twhile ((scb = initio_pop_busy_scb(host)) != NULL) {\n\t\tscb->hastat = HOST_BAD_PHAS;\n\t\tinitio_append_done_scb(host, scb);\n\t}\n\tfor (i = 0; i < host->max_tar; i++)\n\t\thost->targets[i].flags &= ~(TCF_SYNC_DONE | TCF_WDTR_DONE);\n\treturn -1;\n}\n\n\n \n\nstatic int initio_msgout_abort_targ(struct initio_host * host)\n{\n\n\toutb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);\n\tif (initio_msgin_accept(host) == -1)\n\t\treturn -1;\n\tif (host->phase != MSG_OUT)\n\t\treturn initio_bad_seq(host);\n\n\toutb(ABORT_TASK_SET, host->addr + TUL_SFifo);\n\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\n\treturn initio_wait_disc(host);\n}\n\n \n\nstatic int initio_msgout_abort_tag(struct initio_host * host)\n{\n\n\toutb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);\n\tif (initio_msgin_accept(host) == -1)\n\t\treturn -1;\n\tif (host->phase != MSG_OUT)\n\t\treturn initio_bad_seq(host);\n\n\toutb(ABORT_TASK, host->addr + TUL_SFifo);\n\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\n\treturn initio_wait_disc(host);\n\n}\n\n \nstatic int initio_msgin(struct initio_host * host)\n{\n\tstruct target_control *active_tc;\n\n\tfor (;;) {\n\t\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\n\n\t\toutl(1, host->addr + TUL_SCnt0);\n\t\toutb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);\n\t\tif (wait_tulip(host) == -1)\n\t\t\treturn -1;\n\n\t\tswitch (inb(host->addr + TUL_SFifo)) {\n\t\tcase DISCONNECT:\t \n\t\t\toutb(TSC_MSG_ACCEPT, host->addr + TUL_SCmd);\n\t\t\treturn initio_wait_disc(host);\n\t\tcase SAVE_POINTERS:\n\t\tcase RESTORE_POINTERS:\n\t\tcase NOP:\n\t\t\tinitio_msgin_accept(host);\n\t\t\tbreak;\n\t\tcase MESSAGE_REJECT:\t \n\t\t\toutb((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)),\n\t\t\t\thost->addr + TUL_SSignal);\n\t\t\tactive_tc = host->active_tc;\n\t\t\tif ((active_tc->flags & (TCF_SYNC_DONE | TCF_NO_SYNC_NEGO)) == 0)\t \n\t\t\t\toutb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN),\n\t\t\t\t\thost->addr + TUL_SSignal);\n\t\t\tinitio_msgin_accept(host);\n\t\t\tbreak;\n\t\tcase EXTENDED_MESSAGE:\t \n\t\t\tinitio_msgin_extend(host);\n\t\t\tbreak;\n\t\tcase IGNORE_WIDE_RESIDUE:\n\t\t\tinitio_msgin_accept(host);\n\t\t\tbreak;\n\t\tcase COMMAND_COMPLETE:\n\t\t\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\n\t\t\toutb(TSC_MSG_ACCEPT, host->addr + TUL_SCmd);\n\t\t\treturn initio_wait_done_disc(host);\n\t\tdefault:\n\t\t\tinitio_msgout_reject(host);\n\t\t\tbreak;\n\t\t}\n\t\tif (host->phase != MSG_IN)\n\t\t\treturn host->phase;\n\t}\n\t \n}\n\nstatic int initio_msgout_reject(struct initio_host * host)\n{\n\toutb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);\n\n\tif (initio_msgin_accept(host) == -1)\n\t\treturn -1;\n\n\tif (host->phase == MSG_OUT) {\n\t\toutb(MESSAGE_REJECT, host->addr + TUL_SFifo);\t\t \n\t\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\t\treturn wait_tulip(host);\n\t}\n\treturn host->phase;\n}\n\nstatic int initio_msgout_ide(struct initio_host * host)\n{\n\toutb(INITIATOR_ERROR, host->addr + TUL_SFifo);\t\t \n\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\treturn wait_tulip(host);\n}\n\nstatic int initio_msgin_extend(struct initio_host * host)\n{\n\tu8 len, idx;\n\n\tif (initio_msgin_accept(host) != MSG_IN)\n\t\treturn host->phase;\n\n\t \n\toutl(1, host->addr + TUL_SCnt0);\n\toutb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);\n\tif (wait_tulip(host) == -1)\n\t\treturn -1;\n\n\tlen = inb(host->addr + TUL_SFifo);\n\thost->msg[0] = len;\n\tfor (idx = 1; len != 0; len--) {\n\n\t\tif ((initio_msgin_accept(host)) != MSG_IN)\n\t\t\treturn host->phase;\n\t\toutl(1, host->addr + TUL_SCnt0);\n\t\toutb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);\n\t\tif (wait_tulip(host) == -1)\n\t\t\treturn -1;\n\t\thost->msg[idx++] = inb(host->addr + TUL_SFifo);\n\t}\n\tif (host->msg[1] == 1) {\t\t \n\t\tu8 r;\n\t\tif (host->msg[0] != 3)\t \n\t\t\treturn initio_msgout_reject(host);\n\t\tif (host->active_tc->flags & TCF_NO_SYNC_NEGO) {\t \n\t\t\thost->msg[3] = 0;\n\t\t} else {\n\t\t\tif (initio_msgin_sync(host) == 0 &&\n\t\t\t    (host->active_tc->flags & TCF_SYNC_DONE)) {\n\t\t\t\tinitio_sync_done(host);\n\t\t\t\treturn initio_msgin_accept(host);\n\t\t\t}\n\t\t}\n\n\t\tr = inb(host->addr + TUL_SSignal);\n\t\toutb((r & (TSC_SET_ACK | 7)) | TSC_SET_ATN,\n\t\t\thost->addr + TUL_SSignal);\n\t\tif (initio_msgin_accept(host) != MSG_OUT)\n\t\t\treturn host->phase;\n\t\t \n\t\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\n\n\t\tinitio_sync_done(host);\n\n\t\toutb(EXTENDED_MESSAGE, host->addr + TUL_SFifo);\n\t\toutb(3, host->addr + TUL_SFifo);\n\t\toutb(EXTENDED_SDTR, host->addr + TUL_SFifo);\n\t\toutb(host->msg[2], host->addr + TUL_SFifo);\n\t\toutb(host->msg[3], host->addr + TUL_SFifo);\n\t\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\t\treturn wait_tulip(host);\n\t}\n\tif (host->msg[0] != 2 || host->msg[1] != 3)\n\t\treturn initio_msgout_reject(host);\n\t \n\tif (host->active_tc->flags & TCF_NO_WDTR) {\n\t\thost->msg[2] = 0;\n\t} else {\n\t\tif (host->msg[2] > 2)\t \n\t\t\treturn initio_msgout_reject(host);\n\t\tif (host->msg[2] == 2) {\t\t \n\t\t\thost->msg[2] = 1;\n\t\t} else {\n\t\t\tif ((host->active_tc->flags & TCF_NO_WDTR) == 0) {\n\t\t\t\twdtr_done(host);\n\t\t\t\tif ((host->active_tc->flags & (TCF_SYNC_DONE | TCF_NO_SYNC_NEGO)) == 0)\n\t\t\t\t\toutb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);\n\t\t\t\treturn initio_msgin_accept(host);\n\t\t\t}\n\t\t}\n\t}\n\toutb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);\n\n\tif (initio_msgin_accept(host) != MSG_OUT)\n\t\treturn host->phase;\n\t \n\toutb(EXTENDED_MESSAGE, host->addr + TUL_SFifo);\n\toutb(2, host->addr + TUL_SFifo);\n\toutb(EXTENDED_WDTR, host->addr + TUL_SFifo);\n\toutb(host->msg[2], host->addr + TUL_SFifo);\n\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\treturn wait_tulip(host);\n}\n\nstatic int initio_msgin_sync(struct initio_host * host)\n{\n\tchar default_period;\n\n\tdefault_period = initio_rate_tbl[host->active_tc->flags & TCF_SCSI_RATE];\n\tif (host->msg[3] > MAX_OFFSET) {\n\t\thost->msg[3] = MAX_OFFSET;\n\t\tif (host->msg[2] < default_period) {\n\t\t\thost->msg[2] = default_period;\n\t\t\treturn 1;\n\t\t}\n\t\tif (host->msg[2] >= 59)\t \n\t\t\thost->msg[3] = 0;\n\t\treturn 1;\n\t}\n\t \n\tif (host->msg[3] == 0) {\n\t\treturn 0;\n\t}\n\tif (host->msg[2] < default_period) {\n\t\thost->msg[2] = default_period;\n\t\treturn 1;\n\t}\n\tif (host->msg[2] >= 59) {\n\t\thost->msg[3] = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int wdtr_done(struct initio_host * host)\n{\n\thost->active_tc->flags &= ~TCF_SYNC_DONE;\n\thost->active_tc->flags |= TCF_WDTR_DONE;\n\n\thost->active_tc->js_period = 0;\n\tif (host->msg[2])\t \n\t\thost->active_tc->js_period |= TSC_WIDE_SCSI;\n\thost->active_tc->sconfig0 &= ~TSC_ALT_PERIOD;\n\toutb(host->active_tc->sconfig0, host->addr + TUL_SConfig);\n\toutb(host->active_tc->js_period, host->addr + TUL_SPeriod);\n\n\treturn 1;\n}\n\nstatic int initio_sync_done(struct initio_host * host)\n{\n\tint i;\n\n\thost->active_tc->flags |= TCF_SYNC_DONE;\n\n\tif (host->msg[3]) {\n\t\thost->active_tc->js_period |= host->msg[3];\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (initio_rate_tbl[i] >= host->msg[2])\t \n\t\t\t\tbreak;\n\t\t}\n\t\thost->active_tc->js_period |= (i << 4);\n\t\thost->active_tc->sconfig0 |= TSC_ALT_PERIOD;\n\t}\n\toutb(host->active_tc->sconfig0, host->addr + TUL_SConfig);\n\toutb(host->active_tc->js_period, host->addr + TUL_SPeriod);\n\n\treturn -1;\n}\n\n\nstatic int initio_post_scsi_rst(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb;\n\tstruct target_control *active_tc;\n\tint i;\n\n\thost->active = NULL;\n\thost->active_tc = NULL;\n\thost->flags = 0;\n\n\twhile ((scb = initio_pop_busy_scb(host)) != NULL) {\n\t\tscb->hastat = HOST_BAD_PHAS;\n\t\tinitio_append_done_scb(host, scb);\n\t}\n\t \n\tactive_tc = &host->targets[0];\n\tfor (i = 0; i < host->max_tar; active_tc++, i++) {\n\t\tactive_tc->flags &= ~(TCF_SYNC_DONE | TCF_WDTR_DONE);\n\t\t \n\t\tactive_tc->js_period = 0;\n\t\tactive_tc->sconfig0 = host->sconf1;\n\t\thost->act_tags[0] = 0;\t \n\t\thost->targets[i].flags &= ~TCF_BUSY;\t \n\t}\t\t\t \n\n\treturn -1;\n}\n\nstatic void initio_select_atn_stop(struct initio_host * host, struct scsi_ctrl_blk * scb)\n{\n\tscb->status |= SCB_SELECT;\n\tscb->next_state = 0x1;\n\thost->active = scb;\n\thost->active_tc = &host->targets[scb->target];\n\toutb(TSC_SELATNSTOP, host->addr + TUL_SCmd);\n}\n\n\nstatic void initio_select_atn(struct initio_host * host, struct scsi_ctrl_blk * scb)\n{\n\tint i;\n\n\tscb->status |= SCB_SELECT;\n\tscb->next_state = 0x2;\n\n\toutb(scb->ident, host->addr + TUL_SFifo);\n\tfor (i = 0; i < (int) scb->cdblen; i++)\n\t\toutb(scb->cdb[i], host->addr + TUL_SFifo);\n\thost->active_tc = &host->targets[scb->target];\n\thost->active = scb;\n\toutb(TSC_SEL_ATN, host->addr + TUL_SCmd);\n}\n\nstatic void initio_select_atn3(struct initio_host * host, struct scsi_ctrl_blk * scb)\n{\n\tint i;\n\n\tscb->status |= SCB_SELECT;\n\tscb->next_state = 0x2;\n\n\toutb(scb->ident, host->addr + TUL_SFifo);\n\toutb(scb->tagmsg, host->addr + TUL_SFifo);\n\toutb(scb->tagid, host->addr + TUL_SFifo);\n\tfor (i = 0; i < scb->cdblen; i++)\n\t\toutb(scb->cdb[i], host->addr + TUL_SFifo);\n\thost->active_tc = &host->targets[scb->target];\n\thost->active = scb;\n\toutb(TSC_SEL_ATN3, host->addr + TUL_SCmd);\n}\n\n \nint initio_bus_device_reset(struct initio_host * host)\n{\n\tstruct scsi_ctrl_blk *scb = host->active;\n\tstruct target_control *active_tc = host->active_tc;\n\tstruct scsi_ctrl_blk *tmp, *prev;\n\tu8 tar;\n\n\tif (host->phase != MSG_OUT)\n\t\treturn int_initio_bad_seq(host);\t \n\n\tinitio_unlink_pend_scb(host, scb);\n\tinitio_release_scb(host, scb);\n\n\n\ttar = scb->target;\t \n\tactive_tc->flags &= ~(TCF_SYNC_DONE | TCF_WDTR_DONE | TCF_BUSY);\n\t \n\n\t \n\tprev = tmp = host->first_busy;\t \n\twhile (tmp != NULL) {\n\t\tif (tmp->target == tar) {\n\t\t\t \n\t\t\tif (tmp == host->first_busy) {\n\t\t\t\tif ((host->first_busy = tmp->next) == NULL)\n\t\t\t\t\thost->last_busy = NULL;\n\t\t\t} else {\n\t\t\t\tprev->next = tmp->next;\n\t\t\t\tif (tmp == host->last_busy)\n\t\t\t\t\thost->last_busy = prev;\n\t\t\t}\n\t\t\ttmp->hastat = HOST_ABORTED;\n\t\t\tinitio_append_done_scb(host, tmp);\n\t\t}\n\t\t \n\t\telse {\n\t\t\tprev = tmp;\n\t\t}\n\t\ttmp = tmp->next;\n\t}\n\toutb(TARGET_RESET, host->addr + TUL_SFifo);\n\toutb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);\n\treturn initio_wait_disc(host);\n\n}\n\nstatic int initio_msgin_accept(struct initio_host * host)\n{\n\toutb(TSC_MSG_ACCEPT, host->addr + TUL_SCmd);\n\treturn wait_tulip(host);\n}\n\nstatic int wait_tulip(struct initio_host * host)\n{\n\n\twhile (!((host->jsstatus0 = inb(host->addr + TUL_SStatus0))\n\t\t & TSS_INT_PENDING))\n\t\t\tcpu_relax();\n\n\thost->jsint = inb(host->addr + TUL_SInt);\n\thost->phase = host->jsstatus0 & TSS_PH_MASK;\n\thost->jsstatus1 = inb(host->addr + TUL_SStatus1);\n\n\tif (host->jsint & TSS_RESEL_INT)\t \n\t\treturn int_initio_resel(host);\n\tif (host->jsint & TSS_SEL_TIMEOUT)\t \n\t\treturn int_initio_busfree(host);\n\tif (host->jsint & TSS_SCSIRST_INT)\t \n\t\treturn int_initio_scsi_rst(host);\n\n\tif (host->jsint & TSS_DISC_INT) {\t \n\t\tif (host->flags & HCF_EXPECT_DONE_DISC) {\n\t\t\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);  \n\t\t\tinitio_unlink_busy_scb(host, host->active);\n\t\t\thost->active->hastat = 0;\n\t\t\tinitio_append_done_scb(host, host->active);\n\t\t\thost->active = NULL;\n\t\t\thost->active_tc = NULL;\n\t\t\thost->flags &= ~HCF_EXPECT_DONE_DISC;\n\t\t\toutb(TSC_INITDEFAULT, host->addr + TUL_SConfig);\n\t\t\toutb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\t \n\t\t\treturn -1;\n\t\t}\n\t\tif (host->flags & HCF_EXPECT_DISC) {\n\t\t\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);  \n\t\t\thost->active = NULL;\n\t\t\thost->active_tc = NULL;\n\t\t\thost->flags &= ~HCF_EXPECT_DISC;\n\t\t\toutb(TSC_INITDEFAULT, host->addr + TUL_SConfig);\n\t\t\toutb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\t \n\t\t\treturn -1;\n\t\t}\n\t\treturn int_initio_busfree(host);\n\t}\n\t \n\tif (host->jsint & (TSS_FUNC_COMP | TSS_BUS_SERV))\n\t\treturn host->phase;\n\treturn host->phase;\n}\n\nstatic int initio_wait_disc(struct initio_host * host)\n{\n\twhile (!((host->jsstatus0 = inb(host->addr + TUL_SStatus0)) & TSS_INT_PENDING))\n\t\tcpu_relax();\n\n\thost->jsint = inb(host->addr + TUL_SInt);\n\n\tif (host->jsint & TSS_SCSIRST_INT)\t \n\t\treturn int_initio_scsi_rst(host);\n\tif (host->jsint & TSS_DISC_INT) {\t \n\t\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);  \n\t\toutb(TSC_INITDEFAULT, host->addr + TUL_SConfig);\n\t\toutb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\t \n\t\thost->active = NULL;\n\t\treturn -1;\n\t}\n\treturn initio_bad_seq(host);\n}\n\nstatic int initio_wait_done_disc(struct initio_host * host)\n{\n\twhile (!((host->jsstatus0 = inb(host->addr + TUL_SStatus0))\n\t\t & TSS_INT_PENDING))\n\t\t cpu_relax();\n\n\thost->jsint = inb(host->addr + TUL_SInt);\n\n\tif (host->jsint & TSS_SCSIRST_INT)\t \n\t\treturn int_initio_scsi_rst(host);\n\tif (host->jsint & TSS_DISC_INT) {\t \n\t\toutb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);\t\t \n\t\toutb(TSC_INITDEFAULT, host->addr + TUL_SConfig);\n\t\toutb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);\t\t \n\t\tinitio_unlink_busy_scb(host, host->active);\n\n\t\tinitio_append_done_scb(host, host->active);\n\t\thost->active = NULL;\n\t\treturn -1;\n\t}\n\treturn initio_bad_seq(host);\n}\n\n \n\nstatic irqreturn_t i91u_intr(int irqno, void *dev_id)\n{\n\tstruct Scsi_Host *dev = dev_id;\n\tunsigned long flags;\n\tint r;\n\t\n\tspin_lock_irqsave(dev->host_lock, flags);\n\tr = initio_isr((struct initio_host *)dev->hostdata);\n\tspin_unlock_irqrestore(dev->host_lock, flags);\n\tif (r)\n\t\treturn IRQ_HANDLED;\n\telse\n\t\treturn IRQ_NONE;\n}\n\n\n \n\nstatic void initio_build_scb(struct initio_host * host, struct scsi_ctrl_blk * cblk, struct scsi_cmnd * cmnd)\n{\t\t\t\t \n\tstruct scatterlist *sglist;\n\tstruct sg_entry *sg;\t\t \n\tint i, nseg;\n\tlong total_len;\n\tdma_addr_t dma_addr;\n\n\t \n\tcblk->post = i91uSCBPost;\t \n\tcblk->srb = cmnd;\n\tcblk->opcode = ExecSCSI;\n\tcblk->flags = SCF_POST;\t \n\tcblk->target = cmnd->device->id;\n\tcblk->lun = cmnd->device->lun;\n\tcblk->ident = cmnd->device->lun | DISC_ALLOW;\n\n\tcblk->flags |= SCF_SENSE;\t \n\n\t \n\tdma_addr = dma_map_single(&host->pci_dev->dev, cmnd->sense_buffer,\n\t\t\t\t  SENSE_SIZE, DMA_FROM_DEVICE);\n\tcblk->senseptr = (u32)dma_addr;\n\tcblk->senselen = SENSE_SIZE;\n\tinitio_priv(cmnd)->sense_dma_addr = dma_addr;\n\tcblk->cdblen = cmnd->cmd_len;\n\n\t \n\tcblk->hastat = 0;\n\tcblk->tastat = 0;\n\t \n\tmemcpy(cblk->cdb, cmnd->cmnd, cmnd->cmd_len);\n\n\t \n\tif (cmnd->device->tagged_supported) {\t \n\t\tcblk->tagmsg = SIMPLE_QUEUE_TAG;\t \n\t} else {\n\t\tcblk->tagmsg = 0;\t \n\t}\n\n\t \n\tnseg = scsi_dma_map(cmnd);\n\tBUG_ON(nseg < 0);\n\tif (nseg) {\n\t\tdma_addr = dma_map_single(&host->pci_dev->dev, &cblk->sglist[0],\n\t\t\t\t\t  sizeof(struct sg_entry) * TOTAL_SG_ENTRY,\n\t\t\t\t\t  DMA_BIDIRECTIONAL);\n\t\tcblk->bufptr = (u32)dma_addr;\n\t\tinitio_priv(cmnd)->sglist_dma_addr = dma_addr;\n\n\t\tcblk->sglen = nseg;\n\n\t\tcblk->flags |= SCF_SG;\t \n\t\ttotal_len = 0;\n\t\tsg = &cblk->sglist[0];\n\t\tscsi_for_each_sg(cmnd, sglist, cblk->sglen, i) {\n\t\t\tsg->data = cpu_to_le32((u32)sg_dma_address(sglist));\n\t\t\tsg->len = cpu_to_le32((u32)sg_dma_len(sglist));\n\t\t\ttotal_len += sg_dma_len(sglist);\n\t\t\t++sg;\n\t\t}\n\n\t\tcblk->buflen = (scsi_bufflen(cmnd) > total_len) ?\n\t\t\ttotal_len : scsi_bufflen(cmnd);\n\t} else {\t \n\t\tcblk->buflen = 0;\n\t\tcblk->sglen = 0;\n\t}\n}\n\n \nstatic int i91u_queuecommand_lck(struct scsi_cmnd *cmd)\n{\n\tstruct initio_host *host = (struct initio_host *) cmd->device->host->hostdata;\n\tstruct scsi_ctrl_blk *cmnd;\n\n\tcmnd = initio_alloc_scb(host);\n\tif (!cmnd)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tinitio_build_scb(host, cmnd, cmd);\n\tinitio_exec_scb(host, cmnd);\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(i91u_queuecommand)\n\n \n\nstatic int i91u_bus_reset(struct scsi_cmnd * cmnd)\n{\n\tstruct initio_host *host;\n\n\thost = (struct initio_host *) cmnd->device->host->hostdata;\n\n\tspin_lock_irq(cmnd->device->host->host_lock);\n\tinitio_reset_scsi(host, 0);\n\tspin_unlock_irq(cmnd->device->host->host_lock);\n\n\treturn SUCCESS;\n}\n\n \n\nstatic int i91u_biosparam(struct scsi_device *sdev, struct block_device *dev,\n\t\tsector_t capacity, int *info_array)\n{\n\tstruct initio_host *host;\t\t \n\tstruct target_control *tc;\n\n\thost = (struct initio_host *) sdev->host->hostdata;\n\ttc = &host->targets[sdev->id];\n\n\tif (tc->heads) {\n\t\tinfo_array[0] = tc->heads;\n\t\tinfo_array[1] = tc->sectors;\n\t\tinfo_array[2] = (unsigned long)capacity / tc->heads / tc->sectors;\n\t} else {\n\t\tif (tc->drv_flags & TCF_DRV_255_63) {\n\t\t\tinfo_array[0] = 255;\n\t\t\tinfo_array[1] = 63;\n\t\t\tinfo_array[2] = (unsigned long)capacity / 255 / 63;\n\t\t} else {\n\t\t\tinfo_array[0] = 64;\n\t\t\tinfo_array[1] = 32;\n\t\t\tinfo_array[2] = (unsigned long)capacity >> 11;\n\t\t}\n\t}\n\n#if defined(DEBUG_BIOSPARAM)\n\tif (i91u_debug & debug_biosparam) {\n\t\tprintk(\"bios geometry: head=%d, sec=%d, cyl=%d\\n\",\n\t\t       info_array[0], info_array[1], info_array[2]);\n\t\tprintk(\"WARNING: check, if the bios geometry is correct.\\n\");\n\t}\n#endif\n\n\treturn 0;\n}\n\n \n\nstatic void i91u_unmap_scb(struct pci_dev *pci_dev, struct scsi_cmnd *cmnd)\n{\n\t \n\tif (initio_priv(cmnd)->sense_dma_addr) {\n\t\tdma_unmap_single(&pci_dev->dev,\n\t\t\t\t initio_priv(cmnd)->sense_dma_addr,\n\t\t\t\t SENSE_SIZE, DMA_FROM_DEVICE);\n\t\tinitio_priv(cmnd)->sense_dma_addr = 0;\n\t}\n\n\t \n\tif (scsi_sg_count(cmnd)) {\n\t\tdma_unmap_single(&pci_dev->dev,\n\t\t\t\t initio_priv(cmnd)->sglist_dma_addr,\n\t\t\t\t sizeof(struct sg_entry) * TOTAL_SG_ENTRY,\n\t\t\t\t DMA_BIDIRECTIONAL);\n\n\t\tscsi_dma_unmap(cmnd);\n\t}\n}\n\n \n\nstatic void i91uSCBPost(u8 * host_mem, u8 * cblk_mem)\n{\n\tstruct scsi_cmnd *cmnd;\t \n\tstruct initio_host *host;\n\tstruct scsi_ctrl_blk *cblk;\n\n\thost = (struct initio_host *) host_mem;\n\tcblk = (struct scsi_ctrl_blk *) cblk_mem;\n\tif ((cmnd = cblk->srb) == NULL) {\n\t\tprintk(KERN_ERR \"i91uSCBPost: SRB pointer is empty\\n\");\n\t\tWARN_ON(1);\n\t\tinitio_release_scb(host, cblk);\t \n\t\treturn;\n\t}\n\n\t \n\tswitch (cblk->hastat) {\n\tcase 0x0:\n\tcase 0xa:\t\t \n\tcase 0xb:\t\t \n\t\tcblk->hastat = 0;\n\t\tbreak;\n\n\tcase 0x11:\t\t \n\t\tcblk->hastat = DID_TIME_OUT;\n\t\tbreak;\n\n\tcase 0x14:\t\t \n\t\tcblk->hastat = DID_RESET;\n\t\tbreak;\n\n\tcase 0x1a:\t\t \n\t\tcblk->hastat = DID_ABORT;\n\t\tbreak;\n\n\tcase 0x12:\t\t \n\tcase 0x13:\t\t \n\tcase 0x16:\t\t \n\n\tdefault:\n\t\tprintk(\"ini9100u: %x %x\\n\", cblk->hastat, cblk->tastat);\n\t\tcblk->hastat = DID_ERROR;\t \n\t\tbreak;\n\t}\n\n\tcmnd->result = cblk->tastat | (cblk->hastat << 16);\n\ti91u_unmap_scb(host->pci_dev, cmnd);\n\tscsi_done(cmnd);\t \n\tinitio_release_scb(host, cblk);\t \n}\n\nstatic const struct scsi_host_template initio_template = {\n\t.proc_name\t\t= \"INI9100U\",\n\t.name\t\t\t= \"Initio INI-9X00U/UW SCSI device driver\",\n\t.queuecommand\t\t= i91u_queuecommand,\n\t.eh_bus_reset_handler\t= i91u_bus_reset,\n\t.bios_param\t\t= i91u_biosparam,\n\t.can_queue\t\t= MAX_TARGETS * i91u_MAXQUEUE,\n\t.this_id\t\t= 1,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.cmd_size\t\t= sizeof(struct initio_cmd_priv),\n};\n\nstatic int initio_probe_one(struct pci_dev *pdev,\n\tconst struct pci_device_id *id)\n{\n\tstruct Scsi_Host *shost;\n\tstruct initio_host *host;\n\tu32 reg;\n\tu16 bios_seg;\n\tstruct scsi_ctrl_blk *scb, *tmp, *prev = NULL  ;\n\tint num_scb, i, error;\n\n\terror = pci_enable_device(pdev);\n\tif (error)\n\t\treturn error;\n\n\tpci_read_config_dword(pdev, 0x44, (u32 *) & reg);\n\tbios_seg = (u16) (reg & 0xFF);\n\tif (((reg & 0xFF00) >> 8) == 0xFF)\n\t\treg = 0;\n\tbios_seg = (bios_seg << 8) + ((u16) ((reg & 0xFF00) >> 8));\n\n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tprintk(KERN_WARNING  \"i91u: Could not set 32 bit DMA mask\\n\");\n\t\terror = -ENODEV;\n\t\tgoto out_disable_device;\n\t}\n\tshost = scsi_host_alloc(&initio_template, sizeof(struct initio_host));\n\tif (!shost) {\n\t\tprintk(KERN_WARNING \"initio: Could not allocate host structure.\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto out_disable_device;\n\t}\n\thost = (struct initio_host *)shost->hostdata;\n\tmemset(host, 0, sizeof(struct initio_host));\n\thost->addr = pci_resource_start(pdev, 0);\n\thost->bios_addr = bios_seg;\n\n\tif (!request_region(host->addr, 256, \"i91u\")) {\n\t\tprintk(KERN_WARNING \"initio: I/O port range 0x%x is busy.\\n\", host->addr);\n\t\terror = -ENODEV;\n\t\tgoto out_host_put;\n\t}\n\n\tif (initio_tag_enable)\t \n\t\tnum_scb = MAX_TARGETS * i91u_MAXQUEUE;\n\telse\n\t\tnum_scb = MAX_TARGETS + 3;\t \n\n\tfor (; num_scb >= MAX_TARGETS + 3; num_scb--) {\n\t\ti = num_scb * sizeof(struct scsi_ctrl_blk);\n\t\tscb = kzalloc(i, GFP_KERNEL);\n\t\tif (scb)\n\t\t\tbreak;\n\t}\n\n\tif (!scb) {\n\t\tprintk(KERN_WARNING \"initio: Cannot allocate SCB array.\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto out_release_region;\n\t}\n\n\thost->pci_dev = pdev;\n\n\thost->semaph = 1;\n\tspin_lock_init(&host->semaph_lock);\n\thost->num_scbs = num_scb;\n\thost->scb = scb;\n\thost->next_pending = scb;\n\thost->next_avail = scb;\n\tfor (i = 0, tmp = scb; i < num_scb; i++, tmp++) {\n\t\ttmp->tagid = i;\n\t\tif (i != 0)\n\t\t\tprev->next = tmp;\n\t\tprev = tmp;\n\t}\n\tprev->next = NULL;\n\thost->scb_end = tmp;\n\thost->first_avail = scb;\n\thost->last_avail = prev;\n\tspin_lock_init(&host->avail_lock);\n\n\tinitio_init(host, phys_to_virt(((u32)bios_seg << 4)));\n\n\thost->jsstatus0 = 0;\n\n\tshost->io_port = host->addr;\n\tshost->n_io_port = 0xff;\n\tshost->can_queue = num_scb;\t\t \n\tshost->unique_id = host->addr;\n\tshost->max_id = host->max_tar;\n\tshost->max_lun = 32;\t \n\tshost->irq = pdev->irq;\n\tshost->this_id = host->scsi_id;\t \n\tshost->base = host->addr;\n\tshost->sg_tablesize = TOTAL_SG_ENTRY;\n\n\terror = request_irq(pdev->irq, i91u_intr, IRQF_SHARED, \"i91u\", shost);\n\tif (error < 0) {\n\t\tprintk(KERN_WARNING \"initio: Unable to request IRQ %d\\n\", pdev->irq);\n\t\tgoto out_free_scbs;\n\t}\n\n\tpci_set_drvdata(pdev, shost);\n\n\terror = scsi_add_host(shost, &pdev->dev);\n\tif (error)\n\t\tgoto out_free_irq;\n\tscsi_scan_host(shost);\n\treturn 0;\nout_free_irq:\n\tfree_irq(pdev->irq, shost);\nout_free_scbs:\n\tkfree(host->scb);\nout_release_region:\n\trelease_region(host->addr, 256);\nout_host_put:\n\tscsi_host_put(shost);\nout_disable_device:\n\tpci_disable_device(pdev);\n\treturn error;\n}\n\n \n\nstatic void initio_remove_one(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct initio_host *s = (struct initio_host *)host->hostdata;\n\tscsi_remove_host(host);\n\tfree_irq(pdev->irq, host);\n\trelease_region(s->addr, 256);\n\tscsi_host_put(host);\n\tpci_disable_device(pdev);\n}\n\nMODULE_LICENSE(\"GPL\");\n\nstatic struct pci_device_id initio_pci_tbl[] = {\n\t{PCI_VENDOR_ID_INIT, 0x9500, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_INIT, 0x9400, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_INIT, 0x9401, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_INIT, 0x0002, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_DOMEX, 0x0002, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{0,}\n};\nMODULE_DEVICE_TABLE(pci, initio_pci_tbl);\n\nstatic struct pci_driver initio_pci_driver = {\n\t.name\t\t= \"initio\",\n\t.id_table\t= initio_pci_tbl,\n\t.probe\t\t= initio_probe_one,\n\t.remove\t\t= initio_remove_one,\n};\nmodule_pci_driver(initio_pci_driver);\n\nMODULE_DESCRIPTION(\"Initio INI-9X00U/UW SCSI device driver\");\nMODULE_AUTHOR(\"Initio Corporation\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}