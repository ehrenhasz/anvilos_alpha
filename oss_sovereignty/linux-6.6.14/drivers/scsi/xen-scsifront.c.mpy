{
  "module_name": "xen-scsifront.c",
  "hash_id": "85fded93e8d473c5bae99b1f9b9aa9d1ba5cbda521aad65535b287cca5dd0bbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/xen-scsifront.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/wait.h>\n#include <linux/interrupt.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/pfn.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n\n#include <xen/xen.h>\n#include <xen/xenbus.h>\n#include <xen/grant_table.h>\n#include <xen/events.h>\n#include <xen/page.h>\n\n#include <xen/interface/grant_table.h>\n#include <xen/interface/io/vscsiif.h>\n#include <xen/interface/io/protocols.h>\n\n#include <asm/xen/hypervisor.h>\n\n#define VSCSIFRONT_OP_ADD_LUN\t1\n#define VSCSIFRONT_OP_DEL_LUN\t2\n#define VSCSIFRONT_OP_READD_LUN\t3\n\n \n#define VSCSIIF_DEFAULT_CMD_PER_LUN 10\n#define VSCSIIF_MAX_TARGET          64\n#define VSCSIIF_MAX_LUN             255\n\n#define VSCSIIF_RING_SIZE\t__CONST_RING_SIZE(vscsiif, PAGE_SIZE)\n#define VSCSIIF_MAX_REQS\tVSCSIIF_RING_SIZE\n\n#define vscsiif_grants_sg(_sg)\t(PFN_UP((_sg) *\t\t\\\n\t\t\t\tsizeof(struct scsiif_request_segment)))\n\nstruct vscsifrnt_shadow {\n\t \n\tunsigned char act;\n\tuint8_t nr_segments;\n\tuint16_t rqid;\n\tuint16_t ref_rqid;\n\n\tbool inflight;\n\n\tunsigned int nr_grants;\t\t \n\tstruct scsiif_request_segment *sg;\t \n\tstruct scsiif_request_segment seg[VSCSIIF_SG_TABLESIZE];\n\n\t \n\twait_queue_head_t wq_reset;\t \n\tint wait_reset;\t\t\t \n\tint32_t rslt_reset;\t\t \n\t\t\t\t\t \n#define RSLT_RESET_WAITING\t0\n#define RSLT_RESET_ERR\t\t-1\n\n\t \n\tstruct scsi_cmnd *sc;\n\tint gref[vscsiif_grants_sg(SG_ALL) + SG_ALL];\n};\n\nstruct vscsifrnt_info {\n\tstruct xenbus_device *dev;\n\n\tstruct Scsi_Host *host;\n\tenum {\n\t\tSTATE_INACTIVE,\n\t\tSTATE_ACTIVE,\n\t\tSTATE_ERROR\n\t}  host_active;\n\n\tunsigned int evtchn;\n\tunsigned int irq;\n\n\tgrant_ref_t ring_ref;\n\tstruct vscsiif_front_ring ring;\n\tstruct vscsiif_response\tring_rsp;\n\n\tspinlock_t shadow_lock;\n\tDECLARE_BITMAP(shadow_free_bitmap, VSCSIIF_MAX_REQS);\n\tstruct vscsifrnt_shadow *shadow[VSCSIIF_MAX_REQS];\n\n\t \n\twait_queue_head_t wq_sync;\n\twait_queue_head_t wq_pause;\n\tunsigned int wait_ring_available:1;\n\tunsigned int waiting_pause:1;\n\tunsigned int pause:1;\n\tunsigned callers;\n\n\tchar dev_state_path[64];\n\tstruct task_struct *curr;\n};\n\nstatic DEFINE_MUTEX(scsifront_mutex);\n\nstatic void scsifront_wake_up(struct vscsifrnt_info *info)\n{\n\tinfo->wait_ring_available = 0;\n\twake_up(&info->wq_sync);\n}\n\nstatic int scsifront_get_rqid(struct vscsifrnt_info *info)\n{\n\tunsigned long flags;\n\tint free;\n\n\tspin_lock_irqsave(&info->shadow_lock, flags);\n\n\tfree = find_first_bit(info->shadow_free_bitmap, VSCSIIF_MAX_REQS);\n\t__clear_bit(free, info->shadow_free_bitmap);\n\n\tspin_unlock_irqrestore(&info->shadow_lock, flags);\n\n\treturn free;\n}\n\nstatic int _scsifront_put_rqid(struct vscsifrnt_info *info, uint32_t id)\n{\n\tint empty = bitmap_empty(info->shadow_free_bitmap, VSCSIIF_MAX_REQS);\n\n\t__set_bit(id, info->shadow_free_bitmap);\n\tinfo->shadow[id] = NULL;\n\n\treturn empty || info->wait_ring_available;\n}\n\nstatic void scsifront_put_rqid(struct vscsifrnt_info *info, uint32_t id)\n{\n\tunsigned long flags;\n\tint kick;\n\n\tspin_lock_irqsave(&info->shadow_lock, flags);\n\tkick = _scsifront_put_rqid(info, id);\n\tspin_unlock_irqrestore(&info->shadow_lock, flags);\n\n\tif (kick)\n\t\tscsifront_wake_up(info);\n}\n\nstatic int scsifront_do_request(struct vscsifrnt_info *info,\n\t\t\t\tstruct vscsifrnt_shadow *shadow)\n{\n\tstruct vscsiif_front_ring *ring = &(info->ring);\n\tstruct vscsiif_request *ring_req;\n\tstruct scsi_cmnd *sc = shadow->sc;\n\tuint32_t id;\n\tint i, notify;\n\n\tif (RING_FULL(&info->ring))\n\t\treturn -EBUSY;\n\n\tid = scsifront_get_rqid(info);\t \n\tif (id >= VSCSIIF_MAX_REQS)\n\t\treturn -EBUSY;\n\n\tinfo->shadow[id] = shadow;\n\tshadow->rqid = id;\n\n\tring_req = RING_GET_REQUEST(&(info->ring), ring->req_prod_pvt);\n\tring->req_prod_pvt++;\n\n\tring_req->rqid        = id;\n\tring_req->act         = shadow->act;\n\tring_req->ref_rqid    = shadow->ref_rqid;\n\tring_req->nr_segments = shadow->nr_segments;\n\n\tring_req->id      = sc->device->id;\n\tring_req->lun     = sc->device->lun;\n\tring_req->channel = sc->device->channel;\n\tring_req->cmd_len = sc->cmd_len;\n\n\tBUG_ON(sc->cmd_len > VSCSIIF_MAX_COMMAND_SIZE);\n\n\tmemcpy(ring_req->cmnd, sc->cmnd, sc->cmd_len);\n\n\tring_req->sc_data_direction   = (uint8_t)sc->sc_data_direction;\n\tring_req->timeout_per_command = scsi_cmd_to_rq(sc)->timeout / HZ;\n\n\tfor (i = 0; i < (shadow->nr_segments & ~VSCSIIF_SG_GRANT); i++)\n\t\tring_req->seg[i] = shadow->seg[i];\n\n\tshadow->inflight = true;\n\n\tRING_PUSH_REQUESTS_AND_CHECK_NOTIFY(ring, notify);\n\tif (notify)\n\t\tnotify_remote_via_irq(info->irq);\n\n\treturn 0;\n}\n\nstatic void scsifront_set_error(struct vscsifrnt_info *info, const char *msg)\n{\n\tshost_printk(KERN_ERR, info->host, KBUILD_MODNAME \"%s\\n\"\n\t\t     \"Disabling device for further use\\n\", msg);\n\tinfo->host_active = STATE_ERROR;\n}\n\nstatic void scsifront_gnttab_done(struct vscsifrnt_info *info,\n\t\t\t\t  struct vscsifrnt_shadow *shadow)\n{\n\tint i;\n\n\tif (shadow->sc->sc_data_direction == DMA_NONE)\n\t\treturn;\n\n\tfor (i = 0; i < shadow->nr_grants; i++) {\n\t\tif (unlikely(!gnttab_try_end_foreign_access(shadow->gref[i]))) {\n\t\t\tscsifront_set_error(info, \"grant still in use by backend\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkfree(shadow->sg);\n}\n\nstatic unsigned int scsifront_host_byte(int32_t rslt)\n{\n\tswitch (XEN_VSCSIIF_RSLT_HOST(rslt)) {\n\tcase XEN_VSCSIIF_RSLT_HOST_OK:\n\t\treturn DID_OK;\n\tcase XEN_VSCSIIF_RSLT_HOST_NO_CONNECT:\n\t\treturn DID_NO_CONNECT;\n\tcase XEN_VSCSIIF_RSLT_HOST_BUS_BUSY:\n\t\treturn DID_BUS_BUSY;\n\tcase XEN_VSCSIIF_RSLT_HOST_TIME_OUT:\n\t\treturn DID_TIME_OUT;\n\tcase XEN_VSCSIIF_RSLT_HOST_BAD_TARGET:\n\t\treturn DID_BAD_TARGET;\n\tcase XEN_VSCSIIF_RSLT_HOST_ABORT:\n\t\treturn DID_ABORT;\n\tcase XEN_VSCSIIF_RSLT_HOST_PARITY:\n\t\treturn DID_PARITY;\n\tcase XEN_VSCSIIF_RSLT_HOST_ERROR:\n\t\treturn DID_ERROR;\n\tcase XEN_VSCSIIF_RSLT_HOST_RESET:\n\t\treturn DID_RESET;\n\tcase XEN_VSCSIIF_RSLT_HOST_BAD_INTR:\n\t\treturn DID_BAD_INTR;\n\tcase XEN_VSCSIIF_RSLT_HOST_PASSTHROUGH:\n\t\treturn DID_PASSTHROUGH;\n\tcase XEN_VSCSIIF_RSLT_HOST_SOFT_ERROR:\n\t\treturn DID_SOFT_ERROR;\n\tcase XEN_VSCSIIF_RSLT_HOST_IMM_RETRY:\n\t\treturn DID_IMM_RETRY;\n\tcase XEN_VSCSIIF_RSLT_HOST_REQUEUE:\n\t\treturn DID_REQUEUE;\n\tcase XEN_VSCSIIF_RSLT_HOST_TRANSPORT_DISRUPTED:\n\t\treturn DID_TRANSPORT_DISRUPTED;\n\tcase XEN_VSCSIIF_RSLT_HOST_TRANSPORT_FAILFAST:\n\t\treturn DID_TRANSPORT_FAILFAST;\n\tcase XEN_VSCSIIF_RSLT_HOST_TRANSPORT_MARGINAL:\n\t\treturn DID_TRANSPORT_MARGINAL;\n\tdefault:\n\t\treturn DID_ERROR;\n\t}\n}\n\nstatic void scsifront_cdb_cmd_done(struct vscsifrnt_info *info,\n\t\t\t\t   struct vscsiif_response *ring_rsp)\n{\n\tstruct vscsifrnt_shadow *shadow;\n\tstruct scsi_cmnd *sc;\n\tuint32_t id;\n\tuint8_t sense_len;\n\n\tid = ring_rsp->rqid;\n\tshadow = info->shadow[id];\n\tsc = shadow->sc;\n\n\tBUG_ON(sc == NULL);\n\n\tscsifront_gnttab_done(info, shadow);\n\tif (info->host_active == STATE_ERROR)\n\t\treturn;\n\tscsifront_put_rqid(info, id);\n\n\tset_host_byte(sc, scsifront_host_byte(ring_rsp->rslt));\n\tset_status_byte(sc, XEN_VSCSIIF_RSLT_STATUS(ring_rsp->rslt));\n\tscsi_set_resid(sc, ring_rsp->residual_len);\n\n\tsense_len = min_t(uint8_t, VSCSIIF_SENSE_BUFFERSIZE,\n\t\t\t  ring_rsp->sense_len);\n\n\tif (sense_len)\n\t\tmemcpy(sc->sense_buffer, ring_rsp->sense_buffer, sense_len);\n\n\tscsi_done(sc);\n}\n\nstatic void scsifront_sync_cmd_done(struct vscsifrnt_info *info,\n\t\t\t\t    struct vscsiif_response *ring_rsp)\n{\n\tuint16_t id = ring_rsp->rqid;\n\tunsigned long flags;\n\tstruct vscsifrnt_shadow *shadow = info->shadow[id];\n\tint kick;\n\n\tspin_lock_irqsave(&info->shadow_lock, flags);\n\tshadow->wait_reset = 1;\n\tswitch (shadow->rslt_reset) {\n\tcase RSLT_RESET_WAITING:\n\t\tif (ring_rsp->rslt == XEN_VSCSIIF_RSLT_RESET_SUCCESS)\n\t\t\tshadow->rslt_reset = SUCCESS;\n\t\telse\n\t\t\tshadow->rslt_reset = FAILED;\n\t\tbreak;\n\tcase RSLT_RESET_ERR:\n\t\tkick = _scsifront_put_rqid(info, id);\n\t\tspin_unlock_irqrestore(&info->shadow_lock, flags);\n\t\tkfree(shadow);\n\t\tif (kick)\n\t\t\tscsifront_wake_up(info);\n\t\treturn;\n\tdefault:\n\t\tscsifront_set_error(info, \"bad reset state\");\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&info->shadow_lock, flags);\n\n\twake_up(&shadow->wq_reset);\n}\n\nstatic void scsifront_do_response(struct vscsifrnt_info *info,\n\t\t\t\t  struct vscsiif_response *ring_rsp)\n{\n\tstruct vscsifrnt_shadow *shadow;\n\n\tif (ring_rsp->rqid >= VSCSIIF_MAX_REQS ||\n\t    !info->shadow[ring_rsp->rqid]->inflight) {\n\t\tscsifront_set_error(info, \"illegal rqid returned by backend!\");\n\t\treturn;\n\t}\n\tshadow = info->shadow[ring_rsp->rqid];\n\tshadow->inflight = false;\n\n\tif (shadow->act == VSCSIIF_ACT_SCSI_CDB)\n\t\tscsifront_cdb_cmd_done(info, ring_rsp);\n\telse\n\t\tscsifront_sync_cmd_done(info, ring_rsp);\n}\n\nstatic int scsifront_ring_drain(struct vscsifrnt_info *info,\n\t\t\t\tunsigned int *eoiflag)\n{\n\tstruct vscsiif_response ring_rsp;\n\tRING_IDX i, rp;\n\tint more_to_do = 0;\n\n\trp = READ_ONCE(info->ring.sring->rsp_prod);\n\tvirt_rmb();\t \n\tif (RING_RESPONSE_PROD_OVERFLOW(&info->ring, rp)) {\n\t\tscsifront_set_error(info, \"illegal number of responses\");\n\t\treturn 0;\n\t}\n\tfor (i = info->ring.rsp_cons; i != rp; i++) {\n\t\tRING_COPY_RESPONSE(&info->ring, i, &ring_rsp);\n\t\tscsifront_do_response(info, &ring_rsp);\n\t\tif (info->host_active == STATE_ERROR)\n\t\t\treturn 0;\n\t\t*eoiflag &= ~XEN_EOI_FLAG_SPURIOUS;\n\t}\n\n\tinfo->ring.rsp_cons = i;\n\n\tif (i != info->ring.req_prod_pvt)\n\t\tRING_FINAL_CHECK_FOR_RESPONSES(&info->ring, more_to_do);\n\telse\n\t\tinfo->ring.sring->rsp_event = i + 1;\n\n\treturn more_to_do;\n}\n\nstatic int scsifront_cmd_done(struct vscsifrnt_info *info,\n\t\t\t      unsigned int *eoiflag)\n{\n\tint more_to_do;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(info->host->host_lock, flags);\n\n\tmore_to_do = scsifront_ring_drain(info, eoiflag);\n\n\tinfo->wait_ring_available = 0;\n\n\tspin_unlock_irqrestore(info->host->host_lock, flags);\n\n\twake_up(&info->wq_sync);\n\n\treturn more_to_do;\n}\n\nstatic irqreturn_t scsifront_irq_fn(int irq, void *dev_id)\n{\n\tstruct vscsifrnt_info *info = dev_id;\n\tunsigned int eoiflag = XEN_EOI_FLAG_SPURIOUS;\n\n\tif (info->host_active == STATE_ERROR) {\n\t\txen_irq_lateeoi(irq, XEN_EOI_FLAG_SPURIOUS);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\twhile (scsifront_cmd_done(info, &eoiflag))\n\t\t \n\t\tcond_resched();\n\n\txen_irq_lateeoi(irq, eoiflag);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void scsifront_finish_all(struct vscsifrnt_info *info)\n{\n\tunsigned int i, dummy;\n\tstruct vscsiif_response resp;\n\n\tscsifront_ring_drain(info, &dummy);\n\n\tfor (i = 0; i < VSCSIIF_MAX_REQS; i++) {\n\t\tif (test_bit(i, info->shadow_free_bitmap))\n\t\t\tcontinue;\n\t\tresp.rqid = i;\n\t\tresp.sense_len = 0;\n\t\tresp.rslt = DID_RESET << 16;\n\t\tresp.residual_len = 0;\n\t\tscsifront_do_response(info, &resp);\n\t}\n}\n\nstatic int map_data_for_request(struct vscsifrnt_info *info,\n\t\t\t\tstruct scsi_cmnd *sc,\n\t\t\t\tstruct vscsifrnt_shadow *shadow)\n{\n\tgrant_ref_t gref_head;\n\tstruct page *page;\n\tint err, ref, ref_cnt = 0;\n\tint grant_ro = (sc->sc_data_direction == DMA_TO_DEVICE);\n\tunsigned int i, off, len, bytes;\n\tunsigned int data_len = scsi_bufflen(sc);\n\tunsigned int data_grants = 0, seg_grants = 0;\n\tstruct scatterlist *sg;\n\tstruct scsiif_request_segment *seg;\n\n\tif (sc->sc_data_direction == DMA_NONE || !data_len)\n\t\treturn 0;\n\n\tscsi_for_each_sg(sc, sg, scsi_sg_count(sc), i)\n\t\tdata_grants += PFN_UP(sg->offset + sg->length);\n\n\tif (data_grants > VSCSIIF_SG_TABLESIZE) {\n\t\tif (data_grants > info->host->sg_tablesize) {\n\t\t\tshost_printk(KERN_ERR, info->host, KBUILD_MODNAME\n\t\t\t     \"Unable to map request_buffer for command!\\n\");\n\t\t\treturn -E2BIG;\n\t\t}\n\t\tseg_grants = vscsiif_grants_sg(data_grants);\n\t\tshadow->sg = kcalloc(data_grants,\n\t\t\tsizeof(struct scsiif_request_segment), GFP_ATOMIC);\n\t\tif (!shadow->sg)\n\t\t\treturn -ENOMEM;\n\t}\n\tseg = shadow->sg ? : shadow->seg;\n\n\terr = gnttab_alloc_grant_references(seg_grants + data_grants,\n\t\t\t\t\t    &gref_head);\n\tif (err) {\n\t\tkfree(shadow->sg);\n\t\tshost_printk(KERN_ERR, info->host, KBUILD_MODNAME\n\t\t\t     \"gnttab_alloc_grant_references() error\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (seg_grants) {\n\t\tpage = virt_to_page(seg);\n\t\toff = offset_in_page(seg);\n\t\tlen = sizeof(struct scsiif_request_segment) * data_grants;\n\t\twhile (len > 0) {\n\t\t\tbytes = min_t(unsigned int, len, PAGE_SIZE - off);\n\n\t\t\tref = gnttab_claim_grant_reference(&gref_head);\n\t\t\tBUG_ON(ref == -ENOSPC);\n\n\t\t\tgnttab_grant_foreign_access_ref(ref,\n\t\t\t\tinfo->dev->otherend_id,\n\t\t\t\txen_page_to_gfn(page), 1);\n\t\t\tshadow->gref[ref_cnt] = ref;\n\t\t\tshadow->seg[ref_cnt].gref   = ref;\n\t\t\tshadow->seg[ref_cnt].offset = (uint16_t)off;\n\t\t\tshadow->seg[ref_cnt].length = (uint16_t)bytes;\n\n\t\t\tpage++;\n\t\t\tlen -= bytes;\n\t\t\toff = 0;\n\t\t\tref_cnt++;\n\t\t}\n\t\tBUG_ON(seg_grants < ref_cnt);\n\t\tseg_grants = ref_cnt;\n\t}\n\n\tscsi_for_each_sg(sc, sg, scsi_sg_count(sc), i) {\n\t\tpage = sg_page(sg);\n\t\toff = sg->offset;\n\t\tlen = sg->length;\n\n\t\twhile (len > 0 && data_len > 0) {\n\t\t\t \n\t\t\tbytes = min_t(unsigned int, len, PAGE_SIZE - off);\n\t\t\tbytes = min(bytes, data_len);\n\n\t\t\tref = gnttab_claim_grant_reference(&gref_head);\n\t\t\tBUG_ON(ref == -ENOSPC);\n\n\t\t\tgnttab_grant_foreign_access_ref(ref,\n\t\t\t\tinfo->dev->otherend_id,\n\t\t\t\txen_page_to_gfn(page),\n\t\t\t\tgrant_ro);\n\n\t\t\tshadow->gref[ref_cnt] = ref;\n\t\t\tseg->gref   = ref;\n\t\t\tseg->offset = (uint16_t)off;\n\t\t\tseg->length = (uint16_t)bytes;\n\n\t\t\tpage++;\n\t\t\tseg++;\n\t\t\tlen -= bytes;\n\t\t\tdata_len -= bytes;\n\t\t\toff = 0;\n\t\t\tref_cnt++;\n\t\t}\n\t}\n\n\tif (seg_grants)\n\t\tshadow->nr_segments = VSCSIIF_SG_GRANT | seg_grants;\n\telse\n\t\tshadow->nr_segments = (uint8_t)ref_cnt;\n\tshadow->nr_grants = ref_cnt;\n\n\treturn 0;\n}\n\nstatic int scsifront_enter(struct vscsifrnt_info *info)\n{\n\tif (info->pause)\n\t\treturn 1;\n\tinfo->callers++;\n\treturn 0;\n}\n\nstatic void scsifront_return(struct vscsifrnt_info *info)\n{\n\tinfo->callers--;\n\tif (info->callers)\n\t\treturn;\n\n\tif (!info->waiting_pause)\n\t\treturn;\n\n\tinfo->waiting_pause = 0;\n\twake_up(&info->wq_pause);\n}\n\nstatic int scsifront_queuecommand(struct Scsi_Host *shost,\n\t\t\t\t  struct scsi_cmnd *sc)\n{\n\tstruct vscsifrnt_info *info = shost_priv(shost);\n\tstruct vscsifrnt_shadow *shadow = scsi_cmd_priv(sc);\n\tunsigned long flags;\n\tint err;\n\n\tif (info->host_active == STATE_ERROR)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tsc->result = 0;\n\n\tshadow->sc  = sc;\n\tshadow->act = VSCSIIF_ACT_SCSI_CDB;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (scsifront_enter(info)) {\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\terr = map_data_for_request(info, sc, shadow);\n\tif (err < 0) {\n\t\tpr_debug(\"%s: err %d\\n\", __func__, err);\n\t\tscsifront_return(info);\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\tif (err == -ENOMEM)\n\t\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t\tsc->result = DID_ERROR << 16;\n\t\tscsi_done(sc);\n\t\treturn 0;\n\t}\n\n\tif (scsifront_do_request(info, shadow)) {\n\t\tscsifront_gnttab_done(info, shadow);\n\t\tgoto busy;\n\t}\n\n\tscsifront_return(info);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\treturn 0;\n\nbusy:\n\tscsifront_return(info);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\tpr_debug(\"%s: busy\\n\", __func__);\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n}\n\n \nstatic int scsifront_action_handler(struct scsi_cmnd *sc, uint8_t act)\n{\n\tstruct Scsi_Host *host = sc->device->host;\n\tstruct vscsifrnt_info *info = shost_priv(host);\n\tstruct vscsifrnt_shadow *shadow, *s = scsi_cmd_priv(sc);\n\tint err = 0;\n\n\tif (info->host_active == STATE_ERROR)\n\t\treturn FAILED;\n\n\tshadow = kzalloc(sizeof(*shadow), GFP_NOIO);\n\tif (!shadow)\n\t\treturn FAILED;\n\n\tshadow->act = act;\n\tshadow->rslt_reset = RSLT_RESET_WAITING;\n\tshadow->sc = sc;\n\tshadow->ref_rqid = s->rqid;\n\tinit_waitqueue_head(&shadow->wq_reset);\n\n\tspin_lock_irq(host->host_lock);\n\n\tfor (;;) {\n\t\tif (scsifront_enter(info))\n\t\t\tgoto fail;\n\n\t\tif (!scsifront_do_request(info, shadow))\n\t\t\tbreak;\n\n\t\tscsifront_return(info);\n\t\tif (err)\n\t\t\tgoto fail;\n\t\tinfo->wait_ring_available = 1;\n\t\tspin_unlock_irq(host->host_lock);\n\t\terr = wait_event_interruptible(info->wq_sync,\n\t\t\t\t\t       !info->wait_ring_available);\n\t\tspin_lock_irq(host->host_lock);\n\t}\n\n\tspin_unlock_irq(host->host_lock);\n\terr = wait_event_interruptible(shadow->wq_reset, shadow->wait_reset);\n\tspin_lock_irq(host->host_lock);\n\n\tif (!err) {\n\t\terr = shadow->rslt_reset;\n\t\tscsifront_put_rqid(info, shadow->rqid);\n\t\tkfree(shadow);\n\t} else {\n\t\tspin_lock(&info->shadow_lock);\n\t\tshadow->rslt_reset = RSLT_RESET_ERR;\n\t\tspin_unlock(&info->shadow_lock);\n\t\terr = FAILED;\n\t}\n\n\tscsifront_return(info);\n\tspin_unlock_irq(host->host_lock);\n\treturn err;\n\nfail:\n\tspin_unlock_irq(host->host_lock);\n\tkfree(shadow);\n\treturn FAILED;\n}\n\nstatic int scsifront_eh_abort_handler(struct scsi_cmnd *sc)\n{\n\tpr_debug(\"%s\\n\", __func__);\n\treturn scsifront_action_handler(sc, VSCSIIF_ACT_SCSI_ABORT);\n}\n\nstatic int scsifront_dev_reset_handler(struct scsi_cmnd *sc)\n{\n\tpr_debug(\"%s\\n\", __func__);\n\treturn scsifront_action_handler(sc, VSCSIIF_ACT_SCSI_RESET);\n}\n\nstatic int scsifront_sdev_configure(struct scsi_device *sdev)\n{\n\tstruct vscsifrnt_info *info = shost_priv(sdev->host);\n\tint err;\n\n\tif (info->host_active == STATE_ERROR)\n\t\treturn -EIO;\n\n\tif (current == info->curr) {\n\t\terr = xenbus_printf(XBT_NIL, info->dev->nodename,\n\t\t\t      info->dev_state_path, \"%d\", XenbusStateConnected);\n\t\tif (err) {\n\t\t\txenbus_dev_error(info->dev, err,\n\t\t\t\t\"%s: writing dev_state_path\", __func__);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void scsifront_sdev_destroy(struct scsi_device *sdev)\n{\n\tstruct vscsifrnt_info *info = shost_priv(sdev->host);\n\tint err;\n\n\tif (current == info->curr) {\n\t\terr = xenbus_printf(XBT_NIL, info->dev->nodename,\n\t\t\t      info->dev_state_path, \"%d\", XenbusStateClosed);\n\t\tif (err)\n\t\t\txenbus_dev_error(info->dev, err,\n\t\t\t\t\"%s: writing dev_state_path\", __func__);\n\t}\n}\n\nstatic const struct scsi_host_template scsifront_sht = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"Xen SCSI frontend driver\",\n\t.queuecommand\t\t= scsifront_queuecommand,\n\t.eh_abort_handler\t= scsifront_eh_abort_handler,\n\t.eh_device_reset_handler = scsifront_dev_reset_handler,\n\t.slave_configure\t= scsifront_sdev_configure,\n\t.slave_destroy\t\t= scsifront_sdev_destroy,\n\t.cmd_per_lun\t\t= VSCSIIF_DEFAULT_CMD_PER_LUN,\n\t.can_queue\t\t= VSCSIIF_MAX_REQS,\n\t.this_id\t\t= -1,\n\t.cmd_size\t\t= sizeof(struct vscsifrnt_shadow),\n\t.sg_tablesize\t\t= VSCSIIF_SG_TABLESIZE,\n\t.proc_name\t\t= \"scsifront\",\n};\n\nstatic int scsifront_alloc_ring(struct vscsifrnt_info *info)\n{\n\tstruct xenbus_device *dev = info->dev;\n\tstruct vscsiif_sring *sring;\n\tint err;\n\n\t \n\terr = xenbus_setup_ring(dev, GFP_KERNEL, (void **)&sring, 1,\n\t\t\t\t&info->ring_ref);\n\tif (err)\n\t\treturn err;\n\n\tXEN_FRONT_RING_INIT(&info->ring, sring, PAGE_SIZE);\n\n\terr = xenbus_alloc_evtchn(dev, &info->evtchn);\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err, \"xenbus_alloc_evtchn\");\n\t\tgoto free_gnttab;\n\t}\n\n\terr = bind_evtchn_to_irq_lateeoi(info->evtchn);\n\tif (err <= 0) {\n\t\txenbus_dev_fatal(dev, err, \"bind_evtchn_to_irq\");\n\t\tgoto free_gnttab;\n\t}\n\n\tinfo->irq = err;\n\n\terr = request_threaded_irq(info->irq, NULL, scsifront_irq_fn,\n\t\t\t\t   IRQF_ONESHOT, \"scsifront\", info);\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err, \"request_threaded_irq\");\n\t\tgoto free_irq;\n\t}\n\n\treturn 0;\n\n \nfree_irq:\n\tunbind_from_irqhandler(info->irq, info);\nfree_gnttab:\n\txenbus_teardown_ring((void **)&sring, 1, &info->ring_ref);\n\n\treturn err;\n}\n\nstatic void scsifront_free_ring(struct vscsifrnt_info *info)\n{\n\tunbind_from_irqhandler(info->irq, info);\n\txenbus_teardown_ring((void **)&info->ring.sring, 1, &info->ring_ref);\n}\n\nstatic int scsifront_init_ring(struct vscsifrnt_info *info)\n{\n\tstruct xenbus_device *dev = info->dev;\n\tstruct xenbus_transaction xbt;\n\tint err;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\terr = scsifront_alloc_ring(info);\n\tif (err)\n\t\treturn err;\n\tpr_debug(\"%s: %u %u\\n\", __func__, info->ring_ref, info->evtchn);\n\nagain:\n\terr = xenbus_transaction_start(&xbt);\n\tif (err)\n\t\txenbus_dev_fatal(dev, err, \"starting transaction\");\n\n\terr = xenbus_printf(xbt, dev->nodename, \"ring-ref\", \"%u\",\n\t\t\t    info->ring_ref);\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err, \"%s\", \"writing ring-ref\");\n\t\tgoto fail;\n\t}\n\n\terr = xenbus_printf(xbt, dev->nodename, \"event-channel\", \"%u\",\n\t\t\t    info->evtchn);\n\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err, \"%s\", \"writing event-channel\");\n\t\tgoto fail;\n\t}\n\n\terr = xenbus_transaction_end(xbt, 0);\n\tif (err) {\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\t\txenbus_dev_fatal(dev, err, \"completing transaction\");\n\t\tgoto free_sring;\n\t}\n\n\treturn 0;\n\nfail:\n\txenbus_transaction_end(xbt, 1);\nfree_sring:\n\tscsifront_free_ring(info);\n\n\treturn err;\n}\n\n\nstatic int scsifront_probe(struct xenbus_device *dev,\n\t\t\t   const struct xenbus_device_id *id)\n{\n\tstruct vscsifrnt_info *info;\n\tstruct Scsi_Host *host;\n\tint err = -ENOMEM;\n\tchar name[TASK_COMM_LEN];\n\n\thost = scsi_host_alloc(&scsifront_sht, sizeof(*info));\n\tif (!host) {\n\t\txenbus_dev_fatal(dev, err, \"fail to allocate scsi host\");\n\t\treturn err;\n\t}\n\tinfo = shost_priv(host);\n\n\tdev_set_drvdata(&dev->dev, info);\n\tinfo->dev = dev;\n\n\tbitmap_fill(info->shadow_free_bitmap, VSCSIIF_MAX_REQS);\n\n\terr = scsifront_init_ring(info);\n\tif (err) {\n\t\tscsi_host_put(host);\n\t\treturn err;\n\t}\n\n\tinit_waitqueue_head(&info->wq_sync);\n\tinit_waitqueue_head(&info->wq_pause);\n\tspin_lock_init(&info->shadow_lock);\n\n\tsnprintf(name, TASK_COMM_LEN, \"vscsiif.%d\", host->host_no);\n\n\thost->max_id      = VSCSIIF_MAX_TARGET;\n\thost->max_channel = 0;\n\thost->max_lun     = VSCSIIF_MAX_LUN;\n\thost->max_sectors = (host->sg_tablesize - 1) * PAGE_SIZE / 512;\n\thost->max_cmd_len = VSCSIIF_MAX_COMMAND_SIZE;\n\n\terr = scsi_add_host(host, &dev->dev);\n\tif (err) {\n\t\tdev_err(&dev->dev, \"fail to add scsi host %d\\n\", err);\n\t\tgoto free_sring;\n\t}\n\tinfo->host = host;\n\tinfo->host_active = STATE_ACTIVE;\n\n\txenbus_switch_state(dev, XenbusStateInitialised);\n\n\treturn 0;\n\nfree_sring:\n\tscsifront_free_ring(info);\n\tscsi_host_put(host);\n\treturn err;\n}\n\nstatic int scsifront_resume(struct xenbus_device *dev)\n{\n\tstruct vscsifrnt_info *info = dev_get_drvdata(&dev->dev);\n\tstruct Scsi_Host *host = info->host;\n\tint err;\n\n\tspin_lock_irq(host->host_lock);\n\n\t \n\tscsifront_finish_all(info);\n\n\tspin_unlock_irq(host->host_lock);\n\n\t \n\tscsifront_free_ring(info);\n\terr = scsifront_init_ring(info);\n\tif (err) {\n\t\tdev_err(&dev->dev, \"fail to resume %d\\n\", err);\n\t\tscsi_host_put(host);\n\t\treturn err;\n\t}\n\n\txenbus_switch_state(dev, XenbusStateInitialised);\n\n\treturn 0;\n}\n\nstatic int scsifront_suspend(struct xenbus_device *dev)\n{\n\tstruct vscsifrnt_info *info = dev_get_drvdata(&dev->dev);\n\tstruct Scsi_Host *host = info->host;\n\tint err = 0;\n\n\t \n\tspin_lock_irq(host->host_lock);\n\tinfo->pause = 1;\n\twhile (info->callers && !err) {\n\t\tinfo->waiting_pause = 1;\n\t\tinfo->wait_ring_available = 0;\n\t\tspin_unlock_irq(host->host_lock);\n\t\twake_up(&info->wq_sync);\n\t\terr = wait_event_interruptible(info->wq_pause,\n\t\t\t\t\t       !info->waiting_pause);\n\t\tspin_lock_irq(host->host_lock);\n\t}\n\tspin_unlock_irq(host->host_lock);\n\treturn err;\n}\n\nstatic void scsifront_remove(struct xenbus_device *dev)\n{\n\tstruct vscsifrnt_info *info = dev_get_drvdata(&dev->dev);\n\n\tpr_debug(\"%s: %s removed\\n\", __func__, dev->nodename);\n\n\tmutex_lock(&scsifront_mutex);\n\tif (info->host_active != STATE_INACTIVE) {\n\t\t \n\t\tscsi_remove_host(info->host);\n\t\tinfo->host_active = STATE_INACTIVE;\n\t}\n\tmutex_unlock(&scsifront_mutex);\n\n\tscsifront_free_ring(info);\n\tscsi_host_put(info->host);\n}\n\nstatic void scsifront_disconnect(struct vscsifrnt_info *info)\n{\n\tstruct xenbus_device *dev = info->dev;\n\tstruct Scsi_Host *host = info->host;\n\n\tpr_debug(\"%s: %s disconnect\\n\", __func__, dev->nodename);\n\n\t \n\n\tmutex_lock(&scsifront_mutex);\n\tif (info->host_active != STATE_INACTIVE) {\n\t\tscsi_remove_host(host);\n\t\tinfo->host_active = STATE_INACTIVE;\n\t}\n\tmutex_unlock(&scsifront_mutex);\n\n\txenbus_frontend_closed(dev);\n}\n\nstatic void scsifront_do_lun_hotplug(struct vscsifrnt_info *info, int op)\n{\n\tstruct xenbus_device *dev = info->dev;\n\tint i, err = 0;\n\tchar str[64];\n\tchar **dir;\n\tunsigned int dir_n = 0;\n\tunsigned int device_state;\n\tunsigned int hst, chn, tgt, lun;\n\tstruct scsi_device *sdev;\n\n\tif (info->host_active == STATE_ERROR)\n\t\treturn;\n\n\tdir = xenbus_directory(XBT_NIL, dev->otherend, \"vscsi-devs\", &dir_n);\n\tif (IS_ERR(dir))\n\t\treturn;\n\n\t \n\tBUG_ON(info->curr);\n\tinfo->curr = current;\n\n\tfor (i = 0; i < dir_n; i++) {\n\t\t \n\t\tsnprintf(str, sizeof(str), \"vscsi-devs/%s/state\", dir[i]);\n\t\terr = xenbus_scanf(XBT_NIL, dev->otherend, str, \"%u\",\n\t\t\t\t   &device_state);\n\t\tif (XENBUS_EXIST_ERR(err))\n\t\t\tcontinue;\n\n\t\t \n\t\tsnprintf(str, sizeof(str), \"vscsi-devs/%s/v-dev\", dir[i]);\n\t\terr = xenbus_scanf(XBT_NIL, dev->otherend, str,\n\t\t\t\t   \"%u:%u:%u:%u\", &hst, &chn, &tgt, &lun);\n\t\tif (XENBUS_EXIST_ERR(err))\n\t\t\tcontinue;\n\n\t\t \n\t\tsnprintf(info->dev_state_path, sizeof(info->dev_state_path),\n\t\t\t \"vscsi-devs/%s/state\", dir[i]);\n\n\t\tswitch (op) {\n\t\tcase VSCSIFRONT_OP_ADD_LUN:\n\t\t\tif (device_state != XenbusStateInitialised)\n\t\t\t\tbreak;\n\n\t\t\tif (scsi_add_device(info->host, chn, tgt, lun)) {\n\t\t\t\tdev_err(&dev->dev, \"scsi_add_device\\n\");\n\t\t\t\terr = xenbus_printf(XBT_NIL, dev->nodename,\n\t\t\t\t\t      info->dev_state_path,\n\t\t\t\t\t      \"%d\", XenbusStateClosed);\n\t\t\t\tif (err)\n\t\t\t\t\txenbus_dev_error(dev, err,\n\t\t\t\t\t\t\"%s: writing dev_state_path\", __func__);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VSCSIFRONT_OP_DEL_LUN:\n\t\t\tif (device_state != XenbusStateClosing)\n\t\t\t\tbreak;\n\n\t\t\tsdev = scsi_device_lookup(info->host, chn, tgt, lun);\n\t\t\tif (sdev) {\n\t\t\t\tscsi_remove_device(sdev);\n\t\t\t\tscsi_device_put(sdev);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VSCSIFRONT_OP_READD_LUN:\n\t\t\tif (device_state == XenbusStateConnected) {\n\t\t\t\terr = xenbus_printf(XBT_NIL, dev->nodename,\n\t\t\t\t\t      info->dev_state_path,\n\t\t\t\t\t      \"%d\", XenbusStateConnected);\n\t\t\t\tif (err)\n\t\t\t\t\txenbus_dev_error(dev, err,\n\t\t\t\t\t\t\"%s: writing dev_state_path\", __func__);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinfo->curr = NULL;\n\n\tkfree(dir);\n}\n\nstatic void scsifront_read_backend_params(struct xenbus_device *dev,\n\t\t\t\t\t  struct vscsifrnt_info *info)\n{\n\tunsigned int sg_grant, nr_segs;\n\tstruct Scsi_Host *host = info->host;\n\n\tsg_grant = xenbus_read_unsigned(dev->otherend, \"feature-sg-grant\", 0);\n\tnr_segs = min_t(unsigned int, sg_grant, SG_ALL);\n\tnr_segs = max_t(unsigned int, nr_segs, VSCSIIF_SG_TABLESIZE);\n\tnr_segs = min_t(unsigned int, nr_segs,\n\t\t\tVSCSIIF_SG_TABLESIZE * PAGE_SIZE /\n\t\t\tsizeof(struct scsiif_request_segment));\n\n\tif (!info->pause && sg_grant)\n\t\tdev_info(&dev->dev, \"using up to %d SG entries\\n\", nr_segs);\n\telse if (info->pause && nr_segs < host->sg_tablesize)\n\t\tdev_warn(&dev->dev,\n\t\t\t \"SG entries decreased from %d to %u - device may not work properly anymore\\n\",\n\t\t\t host->sg_tablesize, nr_segs);\n\n\thost->sg_tablesize = nr_segs;\n\thost->max_sectors = (nr_segs - 1) * PAGE_SIZE / 512;\n}\n\nstatic void scsifront_backend_changed(struct xenbus_device *dev,\n\t\t\t\t      enum xenbus_state backend_state)\n{\n\tstruct vscsifrnt_info *info = dev_get_drvdata(&dev->dev);\n\n\tpr_debug(\"%s: %p %u %u\\n\", __func__, dev, dev->state, backend_state);\n\n\tswitch (backend_state) {\n\tcase XenbusStateUnknown:\n\tcase XenbusStateInitialising:\n\tcase XenbusStateInitWait:\n\tcase XenbusStateInitialised:\n\t\tbreak;\n\n\tcase XenbusStateConnected:\n\t\tscsifront_read_backend_params(dev, info);\n\n\t\tif (info->pause) {\n\t\t\tscsifront_do_lun_hotplug(info, VSCSIFRONT_OP_READD_LUN);\n\t\t\txenbus_switch_state(dev, XenbusStateConnected);\n\t\t\tinfo->pause = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (xenbus_read_driver_state(dev->nodename) ==\n\t\t    XenbusStateInitialised)\n\t\t\tscsifront_do_lun_hotplug(info, VSCSIFRONT_OP_ADD_LUN);\n\n\t\tif (dev->state != XenbusStateConnected)\n\t\t\txenbus_switch_state(dev, XenbusStateConnected);\n\t\tbreak;\n\n\tcase XenbusStateClosed:\n\t\tif (dev->state == XenbusStateClosed)\n\t\t\tbreak;\n\t\tfallthrough;\t \n\tcase XenbusStateClosing:\n\t\tscsifront_disconnect(info);\n\t\tbreak;\n\n\tcase XenbusStateReconfiguring:\n\t\tscsifront_do_lun_hotplug(info, VSCSIFRONT_OP_DEL_LUN);\n\t\txenbus_switch_state(dev, XenbusStateReconfiguring);\n\t\tbreak;\n\n\tcase XenbusStateReconfigured:\n\t\tscsifront_do_lun_hotplug(info, VSCSIFRONT_OP_ADD_LUN);\n\t\txenbus_switch_state(dev, XenbusStateConnected);\n\t\tbreak;\n\t}\n}\n\nstatic const struct xenbus_device_id scsifront_ids[] = {\n\t{ \"vscsi\" },\n\t{ \"\" }\n};\n\nstatic struct xenbus_driver scsifront_driver = {\n\t.ids\t\t\t= scsifront_ids,\n\t.probe\t\t\t= scsifront_probe,\n\t.remove\t\t\t= scsifront_remove,\n\t.resume\t\t\t= scsifront_resume,\n\t.suspend\t\t= scsifront_suspend,\n\t.otherend_changed\t= scsifront_backend_changed,\n};\n\nstatic int __init scsifront_init(void)\n{\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\treturn xenbus_register_frontend(&scsifront_driver);\n}\nmodule_init(scsifront_init);\n\nstatic void __exit scsifront_exit(void)\n{\n\txenbus_unregister_driver(&scsifront_driver);\n}\nmodule_exit(scsifront_exit);\n\nMODULE_DESCRIPTION(\"Xen SCSI frontend driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"xen:vscsi\");\nMODULE_AUTHOR(\"Juergen Gross <jgross@suse.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}