{
  "module_name": "ibmvscsi_tgt.h",
  "hash_id": "a16965be459fb4f38a7d5fa751e3956098688a1e14d15ffaadfa00f4cadafa3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.h",
  "human_readable_source": " \n \n\n#ifndef __H_IBMVSCSI_TGT\n#define __H_IBMVSCSI_TGT\n\n#include <linux/interrupt.h>\n#include \"libsrp.h\"\n\n#define SYS_ID_NAME_LEN\t\t64\n#define PARTITION_NAMELEN\t96\n#define IBMVSCSIS_NAMELEN       32\n\n#define MSG_HI  0\n#define MSG_LOW 1\n\n#define MAX_CMD_Q_PAGES       4\n#define CRQ_PER_PAGE          (PAGE_SIZE / sizeof(struct viosrp_crq))\n \n#define DEFAULT_CMD_Q_SIZE    CRQ_PER_PAGE\n#define MAX_CMD_Q_SIZE        (DEFAULT_CMD_Q_SIZE * MAX_CMD_Q_PAGES)\n\n#define SRP_VIOLATION           0x102   \n\n \n#define SUPPORTED_FORMATS  ((SRP_DATA_DESC_DIRECT << 1) | \\\n\t\t\t    (SRP_DATA_DESC_INDIRECT << 1))\n\n#define SCSI_LUN_ADDR_METHOD_FLAT\t1\n\nstruct dma_window {\n\tu32 liobn;\t \n\tu64 tce_base;\t \n\tu64 tce_size;\t \n};\n\nstruct target_dds {\n\tu64 unit_id;                 \n#define NUM_DMA_WINDOWS 2\n#define LOCAL  0\n#define REMOTE 1\n\tstruct dma_window  window[NUM_DMA_WINDOWS];\n\n\t \n\tuint partition_num;\n\tchar partition_name[PARTITION_NAMELEN];\n};\n\n#define MAX_NUM_PORTS        1\n#define MAX_H_COPY_RDMA      (128 * 1024)\n\n#define MAX_EYE   64\n\n \n#define ADAPT_SUCCESS            0L\n \n#define ERROR                   -40L\n\nstruct format_code {\n\tu8 reserved;\n\tu8 buffers;\n};\n\nstruct client_info {\n#define SRP_VERSION \"16.a\"\n\tchar srp_version[8];\n\t \n\tchar partition_name[PARTITION_NAMELEN];\n\t \n\tu32 partition_number;\n\t \n\tu32 mad_version;\n\tu32 os_type;\n};\n\n \n#define SECONDS_TO_CONSIDER_FAILED 30\n \n#define WAIT_SECONDS 1\n#define WAIT_NANO_SECONDS 5000\n#define MAX_TIMER_POPS ((1000000 / WAIT_NANO_SECONDS) * \\\n\t\t\tSECONDS_TO_CONSIDER_FAILED)\n \nstruct timer_cb {\n\tstruct hrtimer timer;\n\t \n\tint timer_pops;\n\t \n\tbool started;\n};\n\nstruct cmd_queue {\n\t \n\tstruct viosrp_crq *base_addr;\n\tdma_addr_t crq_token;\n\t \n\tuint mask;\n\t \n\tuint index;\n\tint size;\n};\n\n#define SCSOLNT_RESP_SHIFT\t1\n#define UCSOLNT_RESP_SHIFT\t2\n\n#define SCSOLNT         BIT(SCSOLNT_RESP_SHIFT)\n#define UCSOLNT         BIT(UCSOLNT_RESP_SHIFT)\n\nenum cmd_type {\n\tSCSI_CDB\t= 0x01,\n\tTASK_MANAGEMENT\t= 0x02,\n\t \n\tADAPTER_MAD\t= 0x04,\n\tUNSET_TYPE\t= 0x08,\n};\n\nstruct iu_rsp {\n\tu8 format;\n\tu8 sol_not;\n\tu16 len;\n\t \n\tu64 tag;\n};\n\nstruct ibmvscsis_cmd {\n\tstruct list_head list;\n\t \n\tstruct se_cmd se_cmd;\n\tstruct iu_entry *iue;\n\tstruct iu_rsp rsp;\n\tstruct work_struct work;\n\tstruct scsi_info *adapter;\n\tstruct ibmvscsis_cmd *abort_cmd;\n\t \n\tunsigned char sense_buf[TRANSPORT_SENSE_BUFFER];\n\tu64 init_time;\n#define CMD_FAST_FAIL\tBIT(0)\n#define DELAY_SEND\tBIT(1)\n\tu32 flags;\n\tchar type;\n};\n\nstruct ibmvscsis_nexus {\n\tstruct se_session *se_sess;\n};\n\nstruct ibmvscsis_tport {\n\t \n\tu8 tport_proto_id;\n\t \n\tchar tport_name[IBMVSCSIS_NAMELEN];\n\t \n\tstruct se_wwn tport_wwn;\n\t \n\tstruct se_portal_group se_tpg;\n\t \n\tu16 tport_tpgt;\n\t \n\tstruct ibmvscsis_nexus *ibmv_nexus;\n\tbool enabled;\n\tbool releasing;\n};\n\nstruct scsi_info {\n\tstruct list_head list;\n\tchar eye[MAX_EYE];\n\n\t \n\tstruct list_head waiting_rsp;\n#define NO_QUEUE                    0x00\n#define WAIT_ENABLED                0X01\n#define WAIT_CONNECTION             0x04\n\t \n#define CONNECTED                   0x08\n\t \n#define SRP_PROCESSING              0x10\n\t \n#define UNCONFIGURING               0x20\n\t \n#define WAIT_IDLE                   0x40\n\t \n#define ERR_DISCONNECT              0x80\n\t \n#define ERR_DISCONNECT_RECONNECT    0x100\n\t \n#define ERR_DISCONNECTED            0x200\n\t \n#define UNDEFINED                   0x400\n\tu16  state;\n\tint fast_fail;\n\tstruct target_dds dds;\n\tchar *cmd_pool;\n\t \n\tstruct list_head free_cmd;\n\t \n\tstruct list_head schedule_q;\n\t \n\tstruct list_head active_q;\n\tcaddr_t *map_buf;\n\t \n\tdma_addr_t map_ioba;\n\t \n\tint request_limit;\n\t \n\tint credit;\n\t \n\tint debit;\n\n\t \n#define PROCESSING_MAD                0x00002\n\t \n#define WAIT_FOR_IDLE\t\t      0x00004\n\t \n#define CRQ_CLOSED                    0x00010\n\t \n#define CLIENT_FAILED                 0x00040\n\t \n#define TRANS_EVENT                   0x00080\n\t \n#define RESPONSE_Q_DOWN               0x00100\n\t \n#define SCHEDULE_DISCONNECT           0x00400\n\t \n#define DISCONNECT_SCHEDULED          0x00800\n\t \n#define CFG_SLEEPING                  0x01000\n\t \n#define PREP_FOR_SUSPEND_ENABLED      0x02000\n\t \n#define PREP_FOR_SUSPEND_PENDING      0x04000\n\t \n#define PREP_FOR_SUSPEND_ABORTED      0x08000\n\t \n#define PREP_FOR_SUSPEND_OVERWRITE    0x10000\n\tu32 flags;\n\t \n\tspinlock_t intr_lock;\n\t \n\tstruct cmd_queue cmd_q;\n\t \n\tu64  empty_iu_id;\n\t \n\tu64  empty_iu_tag;\n\tuint new_state;\n\tuint resume_state;\n\t \n\tstruct timer_cb rsp_q_timer;\n\t \n\tstruct client_info client_data;\n\t \n\tu32 client_cap;\n\t \n\tu16  phyp_acr_state;\n\tu32 phyp_acr_flags;\n\n\tstruct workqueue_struct *work_q;\n\tstruct completion wait_idle;\n\tstruct completion unconfig;\n\tstruct device dev;\n\tstruct vio_dev *dma_dev;\n\tstruct srp_target target;\n\tstruct ibmvscsis_tport tport;\n\tstruct tasklet_struct work_task;\n\tstruct work_struct proc_work;\n};\n\n \n#define IS_DISCONNECTING (UNCONFIGURING | ERR_DISCONNECT_RECONNECT | \\\n\t\t\t  ERR_DISCONNECT)\n\n \n#define DONT_PROCESS_STATE (IS_DISCONNECTING | UNDEFINED | \\\n\t\t\t    ERR_DISCONNECTED  | WAIT_IDLE)\n\n \n#define BLOCK (DISCONNECT_SCHEDULED)\n\n \n#define TARGET_STOP(VSCSI) (long)(((VSCSI)->state & DONT_PROCESS_STATE) | \\\n\t\t\t\t  ((VSCSI)->flags & BLOCK))\n\n#define PREP_FOR_SUSPEND_FLAGS  (PREP_FOR_SUSPEND_ENABLED | \\\n\t\t\t\t PREP_FOR_SUSPEND_PENDING | \\\n\t\t\t\t PREP_FOR_SUSPEND_ABORTED | \\\n\t\t\t\t PREP_FOR_SUSPEND_OVERWRITE)\n\n \n#define PRESERVE_FLAG_FIELDS (PREP_FOR_SUSPEND_FLAGS)\n\n#define vio_iu(IUE) ((union viosrp_iu *)((IUE)->sbuf->buf))\n\n#define READ_CMD(cdb)\t(((cdb)[0] & 0x1F) == 8)\n#define WRITE_CMD(cdb)\t(((cdb)[0] & 0x1F) == 0xA)\n\n#ifndef H_GET_PARTNER_INFO\n#define H_GET_PARTNER_INFO              0x0000000000000008LL\n#endif\n#ifndef H_ENABLE_PREPARE_FOR_SUSPEND\n#define H_ENABLE_PREPARE_FOR_SUSPEND    0x000000000000001DLL\n#endif\n#ifndef H_READY_FOR_SUSPEND\n#define H_READY_FOR_SUSPEND             0x000000000000001ELL\n#endif\n\n\n#define h_copy_rdma(l, sa, sb, da, db) \\\n\t\tplpar_hcall_norets(H_COPY_RDMA, l, sa, sb, da, db)\n#define h_vioctl(u, o, a, u1, u2, u3, u4) \\\n\t\tplpar_hcall_norets(H_VIOCTL, u, o, a, u1, u2)\n#define h_reg_crq(ua, tok, sz) \\\n\t\tplpar_hcall_norets(H_REG_CRQ, ua, tok, sz)\n#define h_free_crq(ua) \\\n\t\tplpar_hcall_norets(H_FREE_CRQ, ua)\n#define h_send_crq(ua, d1, d2) \\\n\t\tplpar_hcall_norets(H_SEND_CRQ, ua, d1, d2)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}