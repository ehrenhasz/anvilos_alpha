{
  "module_name": "ibmvscsi_tgt.c",
  "hash_id": "f414b35e8acf625b97f098914aad87df74278f722a89c47ac0cf58fafc725860",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n\n#include <asm/hvcall.h>\n#include <asm/vio.h>\n\n#include <scsi/viosrp.h>\n\n#include \"ibmvscsi_tgt.h\"\n\n#define IBMVSCSIS_VERSION\t\"v0.2\"\n\n#define\tINITIAL_SRP_LIMIT\t1024\n#define\tDEFAULT_MAX_SECTORS\t256\n#define MAX_TXU\t\t\t1024 * 1024\n\nstatic uint max_vdma_size = MAX_H_COPY_RDMA;\n\nstatic char system_id[SYS_ID_NAME_LEN] = \"\";\nstatic char partition_name[PARTITION_NAMELEN] = \"UNKNOWN\";\nstatic uint partition_number = -1;\n\n \nstatic DEFINE_SPINLOCK(ibmvscsis_dev_lock);\nstatic LIST_HEAD(ibmvscsis_dev_list);\n\nstatic long ibmvscsis_parse_command(struct scsi_info *vscsi,\n\t\t\t\t    struct viosrp_crq *crq);\n\nstatic void ibmvscsis_adapter_idle(struct scsi_info *vscsi);\n\nstatic void ibmvscsis_determine_resid(struct se_cmd *se_cmd,\n\t\t\t\t      struct srp_rsp *rsp)\n{\n\tu32 residual_count = se_cmd->residual_count;\n\n\tif (!residual_count)\n\t\treturn;\n\n\tif (se_cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {\n\t\tif (se_cmd->data_direction == DMA_TO_DEVICE) {\n\t\t\t \n\t\t\trsp->flags = SRP_RSP_FLAG_DOUNDER;\n\t\t\trsp->data_out_res_cnt = cpu_to_be32(residual_count);\n\t\t} else if (se_cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t\t \n\t\t\trsp->flags = SRP_RSP_FLAG_DIUNDER;\n\t\t\trsp->data_in_res_cnt = cpu_to_be32(residual_count);\n\t\t}\n\t} else if (se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\n\t\tif (se_cmd->data_direction == DMA_TO_DEVICE) {\n\t\t\t \n\t\t\trsp->flags = SRP_RSP_FLAG_DOOVER;\n\t\t\trsp->data_out_res_cnt = cpu_to_be32(residual_count);\n\t\t} else if (se_cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t\t \n\t\t\trsp->flags = SRP_RSP_FLAG_DIOVER;\n\t\t\trsp->data_in_res_cnt = cpu_to_be32(residual_count);\n\t\t}\n\t}\n}\n\n \nstatic bool connection_broken(struct scsi_info *vscsi)\n{\n\tstruct viosrp_crq *crq;\n\tu64 buffer[2] = { 0, 0 };\n\tlong h_return_code;\n\tbool rc = false;\n\n\t \n\tcrq = (struct viosrp_crq *)&buffer;\n\tcrq->valid = VALID_CMD_RESP_EL;\n\tcrq->format = MESSAGE_IN_CRQ;\n\tcrq->status = PING;\n\n\th_return_code = h_send_crq(vscsi->dds.unit_id,\n\t\t\t\t   cpu_to_be64(buffer[MSG_HI]),\n\t\t\t\t   cpu_to_be64(buffer[MSG_LOW]));\n\n\tdev_dbg(&vscsi->dev, \"Connection_broken: rc %ld\\n\", h_return_code);\n\n\tif (h_return_code == H_CLOSED)\n\t\trc = true;\n\n\treturn rc;\n}\n\n \nstatic long ibmvscsis_unregister_command_q(struct scsi_info *vscsi)\n{\n\tlong qrc;\n\tlong rc = ADAPT_SUCCESS;\n\tint ticks = 0;\n\n\tdo {\n\t\tqrc = h_free_crq(vscsi->dds.unit_id);\n\t\tswitch (qrc) {\n\t\tcase H_SUCCESS:\n\t\t\tspin_lock_bh(&vscsi->intr_lock);\n\t\t\tvscsi->flags &= ~PREP_FOR_SUSPEND_FLAGS;\n\t\t\tspin_unlock_bh(&vscsi->intr_lock);\n\t\t\tbreak;\n\n\t\tcase H_HARDWARE:\n\t\tcase H_PARAMETER:\n\t\t\tdev_err(&vscsi->dev, \"unregister_command_q: error from h_free_crq %ld\\n\",\n\t\t\t\tqrc);\n\t\t\trc = ERROR;\n\t\t\tbreak;\n\n\t\tcase H_BUSY:\n\t\tcase H_LONG_BUSY_ORDER_1_MSEC:\n\t\t\t \n\t\t\tusleep_range(1000, 2000);\n\t\t\tticks += 1;\n\t\t\tbreak;\n\t\tcase H_LONG_BUSY_ORDER_10_MSEC:\n\t\t\tusleep_range(10000, 20000);\n\t\t\tticks += 10;\n\t\t\tbreak;\n\t\tcase H_LONG_BUSY_ORDER_100_MSEC:\n\t\t\tmsleep(100);\n\t\t\tticks += 100;\n\t\t\tbreak;\n\t\tcase H_LONG_BUSY_ORDER_1_SEC:\n\t\t\tssleep(1);\n\t\t\tticks += 1000;\n\t\t\tbreak;\n\t\tcase H_LONG_BUSY_ORDER_10_SEC:\n\t\t\tssleep(10);\n\t\t\tticks += 10000;\n\t\t\tbreak;\n\t\tcase H_LONG_BUSY_ORDER_100_SEC:\n\t\t\tssleep(100);\n\t\t\tticks += 100000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&vscsi->dev, \"unregister_command_q: unknown error %ld from h_free_crq\\n\",\n\t\t\t\tqrc);\n\t\t\trc = ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ticks > 300000 && qrc != H_SUCCESS) {\n\t\t\trc = ERROR;\n\t\t\tdev_err(&vscsi->dev, \"Excessive wait for h_free_crq\\n\");\n\t\t}\n\t} while (qrc != H_SUCCESS && rc == ADAPT_SUCCESS);\n\n\tdev_dbg(&vscsi->dev, \"Freeing CRQ: phyp rc %ld, rc %ld\\n\", qrc, rc);\n\n\treturn rc;\n}\n\n \nstatic void ibmvscsis_delete_client_info(struct scsi_info *vscsi,\n\t\t\t\t\t bool client_closed)\n{\n\tvscsi->client_cap = 0;\n\n\t \n\tif (client_closed)\n\t\tvscsi->client_data.os_type = 0;\n}\n\n \nstatic long ibmvscsis_free_command_q(struct scsi_info *vscsi)\n{\n\tint bytes;\n\tu32 flags_under_lock;\n\tu16 state_under_lock;\n\tlong rc = ADAPT_SUCCESS;\n\n\tif (!(vscsi->flags & CRQ_CLOSED)) {\n\t\tvio_disable_interrupts(vscsi->dma_dev);\n\n\t\tstate_under_lock = vscsi->new_state;\n\t\tflags_under_lock = vscsi->flags;\n\t\tvscsi->phyp_acr_state = 0;\n\t\tvscsi->phyp_acr_flags = 0;\n\n\t\tspin_unlock_bh(&vscsi->intr_lock);\n\t\trc = ibmvscsis_unregister_command_q(vscsi);\n\t\tspin_lock_bh(&vscsi->intr_lock);\n\n\t\tif (state_under_lock != vscsi->new_state)\n\t\t\tvscsi->phyp_acr_state = vscsi->new_state;\n\n\t\tvscsi->phyp_acr_flags = ((~flags_under_lock) & vscsi->flags);\n\n\t\tif (rc == ADAPT_SUCCESS) {\n\t\t\tbytes = vscsi->cmd_q.size * PAGE_SIZE;\n\t\t\tmemset(vscsi->cmd_q.base_addr, 0, bytes);\n\t\t\tvscsi->cmd_q.index = 0;\n\t\t\tvscsi->flags |= CRQ_CLOSED;\n\n\t\t\tibmvscsis_delete_client_info(vscsi, false);\n\t\t}\n\n\t\tdev_dbg(&vscsi->dev, \"free_command_q: flags 0x%x, state 0x%hx, acr_flags 0x%x, acr_state 0x%hx\\n\",\n\t\t\tvscsi->flags, vscsi->state, vscsi->phyp_acr_flags,\n\t\t\tvscsi->phyp_acr_state);\n\t}\n\treturn rc;\n}\n\n \nstatic struct viosrp_crq *ibmvscsis_cmd_q_dequeue(uint mask,\n\t\t\t\t\t\t  uint *current_index,\n\t\t\t\t\t\t  struct viosrp_crq *base_addr)\n{\n\tstruct viosrp_crq *ptr;\n\n\tptr = base_addr + *current_index;\n\n\tif (ptr->valid) {\n\t\t*current_index = (*current_index + 1) & mask;\n\t\tdma_rmb();\n\t} else {\n\t\tptr = NULL;\n\t}\n\n\treturn ptr;\n}\n\n \nstatic long ibmvscsis_send_init_message(struct scsi_info *vscsi, u8 format)\n{\n\tstruct viosrp_crq *crq;\n\tu64 buffer[2] = { 0, 0 };\n\tlong rc;\n\n\tcrq = (struct viosrp_crq *)&buffer;\n\tcrq->valid = VALID_INIT_MSG;\n\tcrq->format = format;\n\trc = h_send_crq(vscsi->dds.unit_id, cpu_to_be64(buffer[MSG_HI]),\n\t\t\tcpu_to_be64(buffer[MSG_LOW]));\n\n\treturn rc;\n}\n\n \nstatic long ibmvscsis_check_init_msg(struct scsi_info *vscsi, uint *format)\n{\n\tstruct viosrp_crq *crq;\n\tlong rc = ADAPT_SUCCESS;\n\n\tcrq = ibmvscsis_cmd_q_dequeue(vscsi->cmd_q.mask, &vscsi->cmd_q.index,\n\t\t\t\t      vscsi->cmd_q.base_addr);\n\tif (!crq) {\n\t\t*format = (uint)UNUSED_FORMAT;\n\t} else if (crq->valid == VALID_INIT_MSG && crq->format == INIT_MSG) {\n\t\t*format = (uint)INIT_MSG;\n\t\tcrq->valid = INVALIDATE_CMD_RESP_EL;\n\t\tdma_rmb();\n\n\t\t \n\t\tcrq = ibmvscsis_cmd_q_dequeue(vscsi->cmd_q.mask,\n\t\t\t\t\t      &vscsi->cmd_q.index,\n\t\t\t\t\t      vscsi->cmd_q.base_addr);\n\t\tif (crq) {\n\t\t\t*format = (uint)(crq->format);\n\t\t\trc = ERROR;\n\t\t\tcrq->valid = INVALIDATE_CMD_RESP_EL;\n\t\t\tdma_rmb();\n\t\t}\n\t} else {\n\t\t*format = (uint)(crq->format);\n\t\trc = ERROR;\n\t\tcrq->valid = INVALIDATE_CMD_RESP_EL;\n\t\tdma_rmb();\n\t}\n\n\treturn rc;\n}\n\n \nstatic void ibmvscsis_disconnect(struct work_struct *work)\n{\n\tstruct scsi_info *vscsi = container_of(work, struct scsi_info,\n\t\t\t\t\t       proc_work);\n\tu16 new_state;\n\tbool wait_idle = false;\n\n\tspin_lock_bh(&vscsi->intr_lock);\n\tnew_state = vscsi->new_state;\n\tvscsi->new_state = 0;\n\n\tvscsi->flags |= DISCONNECT_SCHEDULED;\n\tvscsi->flags &= ~SCHEDULE_DISCONNECT;\n\n\tdev_dbg(&vscsi->dev, \"disconnect: flags 0x%x, state 0x%hx\\n\",\n\t\tvscsi->flags, vscsi->state);\n\n\t \n\tswitch (vscsi->state) {\n\t \n\tcase NO_QUEUE:\n\t \n\tcase UNCONFIGURING:\n\t\tbreak;\n\n\t \n\tcase ERR_DISCONNECT:\n\t\tif (new_state == UNCONFIGURING)\n\t\t\tvscsi->state = new_state;\n\t\tbreak;\n\n\t \n\tcase ERR_DISCONNECT_RECONNECT:\n\t\tswitch (new_state) {\n\t\tcase UNCONFIGURING:\n\t\tcase ERR_DISCONNECT:\n\t\t\tvscsi->state = new_state;\n\t\t\tbreak;\n\n\t\tcase WAIT_IDLE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t \n\tcase ERR_DISCONNECTED:\n\t\tif (new_state == UNCONFIGURING)\n\t\t\tvscsi->state = new_state;\n\t\tbreak;\n\n\tcase WAIT_ENABLED:\n\t\tswitch (new_state) {\n\t\tcase UNCONFIGURING:\n\t\t\tvscsi->state = new_state;\n\t\t\tvscsi->flags |= RESPONSE_Q_DOWN;\n\t\t\tvscsi->flags &= ~(SCHEDULE_DISCONNECT |\n\t\t\t\t\t  DISCONNECT_SCHEDULED);\n\t\t\tdma_rmb();\n\t\t\tif (vscsi->flags & CFG_SLEEPING) {\n\t\t\t\tvscsi->flags &= ~CFG_SLEEPING;\n\t\t\t\tcomplete(&vscsi->unconfig);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t \n\t\tcase ERR_DISCONNECT:\n\t\tcase ERR_DISCONNECT_RECONNECT:\n\t\tcase WAIT_IDLE:\n\t\t\tdev_err(&vscsi->dev, \"disconnect: invalid state %d for WAIT_IDLE\\n\",\n\t\t\t\tvscsi->state);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase WAIT_IDLE:\n\t\tswitch (new_state) {\n\t\tcase UNCONFIGURING:\n\t\t\tvscsi->flags |= RESPONSE_Q_DOWN;\n\t\t\tvscsi->state = new_state;\n\t\t\tvscsi->flags &= ~(SCHEDULE_DISCONNECT |\n\t\t\t\t\t  DISCONNECT_SCHEDULED);\n\t\t\tibmvscsis_free_command_q(vscsi);\n\t\t\tbreak;\n\t\tcase ERR_DISCONNECT:\n\t\tcase ERR_DISCONNECT_RECONNECT:\n\t\t\tvscsi->state = new_state;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t \n\tcase WAIT_CONNECTION:\n\tcase CONNECTED:\n\tcase SRP_PROCESSING:\n\t\twait_idle = true;\n\t\tvscsi->state = new_state;\n\t\tbreak;\n\n\t \n\tcase UNDEFINED:\n\t\tif (new_state == UNCONFIGURING)\n\t\t\tvscsi->state = new_state;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (wait_idle) {\n\t\tdev_dbg(&vscsi->dev, \"disconnect start wait, active %d, sched %d\\n\",\n\t\t\t(int)list_empty(&vscsi->active_q),\n\t\t\t(int)list_empty(&vscsi->schedule_q));\n\t\tif (!list_empty(&vscsi->active_q) ||\n\t\t    !list_empty(&vscsi->schedule_q)) {\n\t\t\tvscsi->flags |= WAIT_FOR_IDLE;\n\t\t\tdev_dbg(&vscsi->dev, \"disconnect flags 0x%x\\n\",\n\t\t\t\tvscsi->flags);\n\t\t\t \n\t\t\tspin_unlock_bh(&vscsi->intr_lock);\n\t\t\twait_for_completion(&vscsi->wait_idle);\n\t\t\tspin_lock_bh(&vscsi->intr_lock);\n\t\t}\n\t\tdev_dbg(&vscsi->dev, \"disconnect stop wait\\n\");\n\n\t\tibmvscsis_adapter_idle(vscsi);\n\t}\n\n\tspin_unlock_bh(&vscsi->intr_lock);\n}\n\n \nstatic void ibmvscsis_post_disconnect(struct scsi_info *vscsi, uint new_state,\n\t\t\t\t      uint flag_bits)\n{\n\tuint state;\n\n\t \n\tswitch (new_state) {\n\tcase UNCONFIGURING:\n\tcase ERR_DISCONNECT:\n\tcase ERR_DISCONNECT_RECONNECT:\n\tcase WAIT_IDLE:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&vscsi->dev, \"post_disconnect: Invalid new state %d\\n\",\n\t\t\tnew_state);\n\t\treturn;\n\t}\n\n\tvscsi->flags |= flag_bits;\n\n\tdev_dbg(&vscsi->dev, \"post_disconnect: new_state 0x%x, flag_bits 0x%x, vscsi->flags 0x%x, state %hx\\n\",\n\t\tnew_state, flag_bits, vscsi->flags, vscsi->state);\n\n\tif (!(vscsi->flags & (DISCONNECT_SCHEDULED | SCHEDULE_DISCONNECT))) {\n\t\tvscsi->flags |= SCHEDULE_DISCONNECT;\n\t\tvscsi->new_state = new_state;\n\n\t\tINIT_WORK(&vscsi->proc_work, ibmvscsis_disconnect);\n\t\t(void)queue_work(vscsi->work_q, &vscsi->proc_work);\n\t} else {\n\t\tif (vscsi->new_state)\n\t\t\tstate = vscsi->new_state;\n\t\telse\n\t\t\tstate = vscsi->state;\n\n\t\tswitch (state) {\n\t\tcase NO_QUEUE:\n\t\tcase UNCONFIGURING:\n\t\t\tbreak;\n\n\t\tcase ERR_DISCONNECTED:\n\t\tcase ERR_DISCONNECT:\n\t\tcase UNDEFINED:\n\t\t\tif (new_state == UNCONFIGURING)\n\t\t\t\tvscsi->new_state = new_state;\n\t\t\tbreak;\n\n\t\tcase ERR_DISCONNECT_RECONNECT:\n\t\t\tswitch (new_state) {\n\t\t\tcase UNCONFIGURING:\n\t\t\tcase ERR_DISCONNECT:\n\t\t\t\tvscsi->new_state = new_state;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase WAIT_ENABLED:\n\t\tcase WAIT_IDLE:\n\t\tcase WAIT_CONNECTION:\n\t\tcase CONNECTED:\n\t\tcase SRP_PROCESSING:\n\t\t\tvscsi->new_state = new_state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdev_dbg(&vscsi->dev, \"Leaving post_disconnect: flags 0x%x, new_state 0x%x\\n\",\n\t\tvscsi->flags, vscsi->new_state);\n}\n\n \nstatic long ibmvscsis_handle_init_compl_msg(struct scsi_info *vscsi)\n{\n\tlong rc = ADAPT_SUCCESS;\n\n\tswitch (vscsi->state) {\n\tcase NO_QUEUE:\n\tcase ERR_DISCONNECT:\n\tcase ERR_DISCONNECT_RECONNECT:\n\tcase ERR_DISCONNECTED:\n\tcase UNCONFIGURING:\n\tcase UNDEFINED:\n\t\trc = ERROR;\n\t\tbreak;\n\n\tcase WAIT_CONNECTION:\n\t\tvscsi->state = CONNECTED;\n\t\tbreak;\n\n\tcase WAIT_IDLE:\n\tcase SRP_PROCESSING:\n\tcase CONNECTED:\n\tcase WAIT_ENABLED:\n\tdefault:\n\t\trc = ERROR;\n\t\tdev_err(&vscsi->dev, \"init_msg: invalid state %d to get init compl msg\\n\",\n\t\t\tvscsi->state);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nstatic long ibmvscsis_handle_init_msg(struct scsi_info *vscsi)\n{\n\tlong rc = ADAPT_SUCCESS;\n\n\tswitch (vscsi->state) {\n\tcase WAIT_CONNECTION:\n\t\trc = ibmvscsis_send_init_message(vscsi, INIT_COMPLETE_MSG);\n\t\tswitch (rc) {\n\t\tcase H_SUCCESS:\n\t\t\tvscsi->state = CONNECTED;\n\t\t\tbreak;\n\n\t\tcase H_PARAMETER:\n\t\t\tdev_err(&vscsi->dev, \"init_msg: failed to send, rc %ld\\n\",\n\t\t\t\trc);\n\t\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT, 0);\n\t\t\tbreak;\n\n\t\tcase H_DROPPED:\n\t\t\tdev_err(&vscsi->dev, \"init_msg: failed to send, rc %ld\\n\",\n\t\t\t\trc);\n\t\t\trc = ERROR;\n\t\t\tibmvscsis_post_disconnect(vscsi,\n\t\t\t\t\t\t  ERR_DISCONNECT_RECONNECT, 0);\n\t\t\tbreak;\n\n\t\tcase H_CLOSED:\n\t\t\tdev_warn(&vscsi->dev, \"init_msg: failed to send, rc %ld\\n\",\n\t\t\t\t rc);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase UNDEFINED:\n\t\trc = ERROR;\n\t\tbreak;\n\n\tcase UNCONFIGURING:\n\t\tbreak;\n\n\tcase WAIT_ENABLED:\n\tcase CONNECTED:\n\tcase SRP_PROCESSING:\n\tcase WAIT_IDLE:\n\tcase NO_QUEUE:\n\tcase ERR_DISCONNECT:\n\tcase ERR_DISCONNECT_RECONNECT:\n\tcase ERR_DISCONNECTED:\n\tdefault:\n\t\trc = ERROR;\n\t\tdev_err(&vscsi->dev, \"init_msg: invalid state %d to get init msg\\n\",\n\t\t\tvscsi->state);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nstatic long ibmvscsis_init_msg(struct scsi_info *vscsi, struct viosrp_crq *crq)\n{\n\tlong rc = ADAPT_SUCCESS;\n\n\tdev_dbg(&vscsi->dev, \"init_msg: state 0x%hx\\n\", vscsi->state);\n\n\trc = h_vioctl(vscsi->dds.unit_id, H_GET_PARTNER_INFO,\n\t\t      (u64)vscsi->map_ioba | ((u64)PAGE_SIZE << 32), 0, 0, 0,\n\t\t      0);\n\tif (rc == H_SUCCESS) {\n\t\tvscsi->client_data.partition_number =\n\t\t\tbe64_to_cpu(*(u64 *)vscsi->map_buf);\n\t\tdev_dbg(&vscsi->dev, \"init_msg, part num %d\\n\",\n\t\t\tvscsi->client_data.partition_number);\n\t} else {\n\t\tdev_dbg(&vscsi->dev, \"init_msg h_vioctl rc %ld\\n\", rc);\n\t\trc = ADAPT_SUCCESS;\n\t}\n\n\tif (crq->format == INIT_MSG) {\n\t\trc = ibmvscsis_handle_init_msg(vscsi);\n\t} else if (crq->format == INIT_COMPLETE_MSG) {\n\t\trc = ibmvscsis_handle_init_compl_msg(vscsi);\n\t} else {\n\t\trc = ERROR;\n\t\tdev_err(&vscsi->dev, \"init_msg: invalid format %d\\n\",\n\t\t\t(uint)crq->format);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\n\t}\n\n\treturn rc;\n}\n\n \nstatic long ibmvscsis_establish_new_q(struct scsi_info *vscsi)\n{\n\tlong rc = ADAPT_SUCCESS;\n\tuint format;\n\n\trc = h_vioctl(vscsi->dds.unit_id, H_ENABLE_PREPARE_FOR_SUSPEND, 30000,\n\t\t      0, 0, 0, 0);\n\tif (rc == H_SUCCESS)\n\t\tvscsi->flags |= PREP_FOR_SUSPEND_ENABLED;\n\telse if (rc != H_NOT_FOUND)\n\t\tdev_err(&vscsi->dev, \"Error from Enable Prepare for Suspend: %ld\\n\",\n\t\t\trc);\n\n\tvscsi->flags &= PRESERVE_FLAG_FIELDS;\n\tvscsi->rsp_q_timer.timer_pops = 0;\n\tvscsi->debit = 0;\n\tvscsi->credit = 0;\n\n\trc = vio_enable_interrupts(vscsi->dma_dev);\n\tif (rc) {\n\t\tdev_warn(&vscsi->dev, \"establish_new_q: failed to enable interrupts, rc %ld\\n\",\n\t\t\t rc);\n\t\treturn rc;\n\t}\n\n\trc = ibmvscsis_check_init_msg(vscsi, &format);\n\tif (rc) {\n\t\tdev_err(&vscsi->dev, \"establish_new_q: check_init_msg failed, rc %ld\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\tif (format == UNUSED_FORMAT) {\n\t\trc = ibmvscsis_send_init_message(vscsi, INIT_MSG);\n\t\tswitch (rc) {\n\t\tcase H_SUCCESS:\n\t\tcase H_DROPPED:\n\t\tcase H_CLOSED:\n\t\t\trc = ADAPT_SUCCESS;\n\t\t\tbreak;\n\n\t\tcase H_PARAMETER:\n\t\tcase H_HARDWARE:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tvscsi->state = UNDEFINED;\n\t\t\trc = H_HARDWARE;\n\t\t\tbreak;\n\t\t}\n\t} else if (format == INIT_MSG) {\n\t\trc = ibmvscsis_handle_init_msg(vscsi);\n\t}\n\n\treturn rc;\n}\n\n \nstatic void ibmvscsis_reset_queue(struct scsi_info *vscsi)\n{\n\tint bytes;\n\tlong rc = ADAPT_SUCCESS;\n\n\tdev_dbg(&vscsi->dev, \"reset_queue: flags 0x%x\\n\", vscsi->flags);\n\n\t \n\tif (vscsi->flags & (CLIENT_FAILED | TRANS_EVENT)) {\n\t\tvscsi->flags &= PRESERVE_FLAG_FIELDS;\n\t\tvscsi->rsp_q_timer.timer_pops = 0;\n\t\tvscsi->debit = 0;\n\t\tvscsi->credit = 0;\n\t\tvscsi->state = WAIT_CONNECTION;\n\t\tvio_enable_interrupts(vscsi->dma_dev);\n\t} else {\n\t\trc = ibmvscsis_free_command_q(vscsi);\n\t\tif (rc == ADAPT_SUCCESS) {\n\t\t\tvscsi->state = WAIT_CONNECTION;\n\n\t\t\tbytes = vscsi->cmd_q.size * PAGE_SIZE;\n\t\t\trc = h_reg_crq(vscsi->dds.unit_id,\n\t\t\t\t       vscsi->cmd_q.crq_token, bytes);\n\t\t\tif (rc == H_CLOSED || rc == H_SUCCESS) {\n\t\t\t\trc = ibmvscsis_establish_new_q(vscsi);\n\t\t\t}\n\n\t\t\tif (rc != ADAPT_SUCCESS) {\n\t\t\t\tdev_dbg(&vscsi->dev, \"reset_queue: reg_crq rc %ld\\n\",\n\t\t\t\t\trc);\n\n\t\t\t\tvscsi->state = ERR_DISCONNECTED;\n\t\t\t\tvscsi->flags |= RESPONSE_Q_DOWN;\n\t\t\t\tibmvscsis_free_command_q(vscsi);\n\t\t\t}\n\t\t} else {\n\t\t\tvscsi->state = ERR_DISCONNECTED;\n\t\t\tvscsi->flags |= RESPONSE_Q_DOWN;\n\t\t}\n\t}\n}\n\n \nstatic void ibmvscsis_free_cmd_resources(struct scsi_info *vscsi,\n\t\t\t\t\t struct ibmvscsis_cmd *cmd)\n{\n\tstruct iu_entry *iue = cmd->iue;\n\n\tswitch (cmd->type) {\n\tcase TASK_MANAGEMENT:\n\tcase SCSI_CDB:\n\t\t \n\t\tif (vscsi->debit)\n\t\t\tvscsi->debit -= 1;\n\t\tbreak;\n\tcase ADAPTER_MAD:\n\t\tvscsi->flags &= ~PROCESSING_MAD;\n\t\tbreak;\n\tcase UNSET_TYPE:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&vscsi->dev, \"free_cmd_resources unknown type %d\\n\",\n\t\t\tcmd->type);\n\t\tbreak;\n\t}\n\n\tcmd->iue = NULL;\n\tlist_add_tail(&cmd->list, &vscsi->free_cmd);\n\tsrp_iu_put(iue);\n\n\tif (list_empty(&vscsi->active_q) && list_empty(&vscsi->schedule_q) &&\n\t    list_empty(&vscsi->waiting_rsp) && (vscsi->flags & WAIT_FOR_IDLE)) {\n\t\tvscsi->flags &= ~WAIT_FOR_IDLE;\n\t\tcomplete(&vscsi->wait_idle);\n\t}\n}\n\n \nstatic long ibmvscsis_ready_for_suspend(struct scsi_info *vscsi, bool idle)\n{\n\tlong rc = 0;\n\tstruct viosrp_crq *crq;\n\n\t \n\tcrq = vscsi->cmd_q.base_addr + vscsi->cmd_q.index;\n\n\tdev_dbg(&vscsi->dev, \"ready_suspend: flags 0x%x, state 0x%hx crq_valid:%x\\n\",\n\t\tvscsi->flags, vscsi->state, (int)crq->valid);\n\n\tif (!(vscsi->flags & PREP_FOR_SUSPEND_ABORTED) && !(crq->valid)) {\n\t\trc = h_vioctl(vscsi->dds.unit_id, H_READY_FOR_SUSPEND, 0, 0, 0,\n\t\t\t      0, 0);\n\t\tif (rc) {\n\t\t\tdev_err(&vscsi->dev, \"Ready for Suspend Vioctl failed: %ld\\n\",\n\t\t\t\trc);\n\t\t\trc = 0;\n\t\t}\n\t} else if (((vscsi->flags & PREP_FOR_SUSPEND_OVERWRITE) &&\n\t\t    (vscsi->flags & PREP_FOR_SUSPEND_ABORTED)) ||\n\t\t   ((crq->valid) && ((crq->valid != VALID_TRANS_EVENT) ||\n\t\t\t\t     (crq->format != RESUME_FROM_SUSP)))) {\n\t\tif (idle) {\n\t\t\tvscsi->state = ERR_DISCONNECT_RECONNECT;\n\t\t\tibmvscsis_reset_queue(vscsi);\n\t\t\trc = -1;\n\t\t} else if (vscsi->state == CONNECTED) {\n\t\t\tibmvscsis_post_disconnect(vscsi,\n\t\t\t\t\t\t  ERR_DISCONNECT_RECONNECT, 0);\n\t\t}\n\n\t\tvscsi->flags &= ~PREP_FOR_SUSPEND_OVERWRITE;\n\n\t\tif ((crq->valid) && ((crq->valid != VALID_TRANS_EVENT) ||\n\t\t\t\t     (crq->format != RESUME_FROM_SUSP)))\n\t\t\tdev_err(&vscsi->dev, \"Invalid element in CRQ after Prepare for Suspend\");\n\t}\n\n\tvscsi->flags &= ~(PREP_FOR_SUSPEND_PENDING | PREP_FOR_SUSPEND_ABORTED);\n\n\treturn rc;\n}\n\n \nstatic long ibmvscsis_trans_event(struct scsi_info *vscsi,\n\t\t\t\t  struct viosrp_crq *crq)\n{\n\tlong rc = ADAPT_SUCCESS;\n\n\tdev_dbg(&vscsi->dev, \"trans_event: format %d, flags 0x%x, state 0x%hx\\n\",\n\t\t(int)crq->format, vscsi->flags, vscsi->state);\n\n\tswitch (crq->format) {\n\tcase MIGRATED:\n\tcase PARTNER_FAILED:\n\tcase PARTNER_DEREGISTER:\n\t\tibmvscsis_delete_client_info(vscsi, true);\n\t\tif (crq->format == MIGRATED)\n\t\t\tvscsi->flags &= ~PREP_FOR_SUSPEND_OVERWRITE;\n\t\tswitch (vscsi->state) {\n\t\tcase NO_QUEUE:\n\t\tcase ERR_DISCONNECTED:\n\t\tcase UNDEFINED:\n\t\t\tbreak;\n\n\t\tcase UNCONFIGURING:\n\t\t\tvscsi->flags |= (RESPONSE_Q_DOWN | TRANS_EVENT);\n\t\t\tbreak;\n\n\t\tcase WAIT_ENABLED:\n\t\t\tbreak;\n\n\t\tcase WAIT_CONNECTION:\n\t\t\tbreak;\n\n\t\tcase CONNECTED:\n\t\t\tibmvscsis_post_disconnect(vscsi, WAIT_IDLE,\n\t\t\t\t\t\t  (RESPONSE_Q_DOWN |\n\t\t\t\t\t\t   TRANS_EVENT));\n\t\t\tbreak;\n\n\t\tcase SRP_PROCESSING:\n\t\t\tif ((vscsi->debit > 0) ||\n\t\t\t    !list_empty(&vscsi->schedule_q) ||\n\t\t\t    !list_empty(&vscsi->waiting_rsp) ||\n\t\t\t    !list_empty(&vscsi->active_q)) {\n\t\t\t\tdev_dbg(&vscsi->dev, \"debit %d, sched %d, wait %d, active %d\\n\",\n\t\t\t\t\tvscsi->debit,\n\t\t\t\t\t(int)list_empty(&vscsi->schedule_q),\n\t\t\t\t\t(int)list_empty(&vscsi->waiting_rsp),\n\t\t\t\t\t(int)list_empty(&vscsi->active_q));\n\t\t\t\tdev_warn(&vscsi->dev, \"connection lost with outstanding work\\n\");\n\t\t\t} else {\n\t\t\t\tdev_dbg(&vscsi->dev, \"trans_event: SRP Processing, but no outstanding work\\n\");\n\t\t\t}\n\n\t\t\tibmvscsis_post_disconnect(vscsi, WAIT_IDLE,\n\t\t\t\t\t\t  (RESPONSE_Q_DOWN |\n\t\t\t\t\t\t   TRANS_EVENT));\n\t\t\tbreak;\n\n\t\tcase ERR_DISCONNECT:\n\t\tcase ERR_DISCONNECT_RECONNECT:\n\t\tcase WAIT_IDLE:\n\t\t\tvscsi->flags |= (RESPONSE_Q_DOWN | TRANS_EVENT);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase PREPARE_FOR_SUSPEND:\n\t\tdev_dbg(&vscsi->dev, \"Prep for Suspend, crq status = 0x%x\\n\",\n\t\t\t(int)crq->status);\n\t\tswitch (vscsi->state) {\n\t\tcase ERR_DISCONNECTED:\n\t\tcase WAIT_CONNECTION:\n\t\tcase CONNECTED:\n\t\t\tibmvscsis_ready_for_suspend(vscsi, false);\n\t\t\tbreak;\n\t\tcase SRP_PROCESSING:\n\t\t\tvscsi->resume_state = vscsi->state;\n\t\t\tvscsi->flags |= PREP_FOR_SUSPEND_PENDING;\n\t\t\tif (crq->status == CRQ_ENTRY_OVERWRITTEN)\n\t\t\t\tvscsi->flags |= PREP_FOR_SUSPEND_OVERWRITE;\n\t\t\tibmvscsis_post_disconnect(vscsi, WAIT_IDLE, 0);\n\t\t\tbreak;\n\t\tcase NO_QUEUE:\n\t\tcase UNDEFINED:\n\t\tcase UNCONFIGURING:\n\t\tcase WAIT_ENABLED:\n\t\tcase ERR_DISCONNECT:\n\t\tcase ERR_DISCONNECT_RECONNECT:\n\t\tcase WAIT_IDLE:\n\t\t\tdev_err(&vscsi->dev, \"Invalid state for Prepare for Suspend Trans Event: 0x%x\\n\",\n\t\t\t\tvscsi->state);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase RESUME_FROM_SUSP:\n\t\tdev_dbg(&vscsi->dev, \"Resume from Suspend, crq status = 0x%x\\n\",\n\t\t\t(int)crq->status);\n\t\tif (vscsi->flags & PREP_FOR_SUSPEND_PENDING) {\n\t\t\tvscsi->flags |= PREP_FOR_SUSPEND_ABORTED;\n\t\t} else {\n\t\t\tif ((crq->status == CRQ_ENTRY_OVERWRITTEN) ||\n\t\t\t    (vscsi->flags & PREP_FOR_SUSPEND_OVERWRITE)) {\n\t\t\t\tibmvscsis_post_disconnect(vscsi,\n\t\t\t\t\t\t\t  ERR_DISCONNECT_RECONNECT,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tvscsi->flags &= ~PREP_FOR_SUSPEND_OVERWRITE;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trc = ERROR;\n\t\tdev_err(&vscsi->dev, \"trans_event: invalid format %d\\n\",\n\t\t\t(uint)crq->format);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT,\n\t\t\t\t\t  RESPONSE_Q_DOWN);\n\t\tbreak;\n\t}\n\n\trc = vscsi->flags & SCHEDULE_DISCONNECT;\n\n\tdev_dbg(&vscsi->dev, \"Leaving trans_event: flags 0x%x, state 0x%hx, rc %ld\\n\",\n\t\tvscsi->flags, vscsi->state, rc);\n\n\treturn rc;\n}\n\n \nstatic void ibmvscsis_poll_cmd_q(struct scsi_info *vscsi)\n{\n\tstruct viosrp_crq *crq;\n\tlong rc;\n\tbool ack = true;\n\tvolatile u8 valid;\n\n\tdev_dbg(&vscsi->dev, \"poll_cmd_q: flags 0x%x, state 0x%hx, q index %ud\\n\",\n\t\tvscsi->flags, vscsi->state, vscsi->cmd_q.index);\n\n\trc = vscsi->flags & SCHEDULE_DISCONNECT;\n\tcrq = vscsi->cmd_q.base_addr + vscsi->cmd_q.index;\n\tvalid = crq->valid;\n\tdma_rmb();\n\n\twhile (valid) {\npoll_work:\n\t\tvscsi->cmd_q.index =\n\t\t\t(vscsi->cmd_q.index + 1) & vscsi->cmd_q.mask;\n\n\t\tif (!rc) {\n\t\t\trc = ibmvscsis_parse_command(vscsi, crq);\n\t\t} else {\n\t\t\tif ((uint)crq->valid == VALID_TRANS_EVENT) {\n\t\t\t\t \n\t\t\t\trc = ibmvscsis_trans_event(vscsi, crq);\n\t\t\t} else if (vscsi->flags & TRANS_EVENT) {\n\t\t\t\t \n\t\t\t\tdev_dbg(&vscsi->dev, \"poll_cmd_q, ignoring\\n\");\n\n\t\t\t\t \n\t\t\t\tif (vscsi->cmd_q.index)\n\t\t\t\t\tvscsi->cmd_q.index -= 1;\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\tvscsi->cmd_q.index = vscsi->cmd_q.mask;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcrq->valid = INVALIDATE_CMD_RESP_EL;\n\n\t\tcrq = vscsi->cmd_q.base_addr + vscsi->cmd_q.index;\n\t\tvalid = crq->valid;\n\t\tdma_rmb();\n\t}\n\n\tif (!rc) {\n\t\tif (ack) {\n\t\t\tvio_enable_interrupts(vscsi->dma_dev);\n\t\t\tack = false;\n\t\t\tdev_dbg(&vscsi->dev, \"poll_cmd_q, reenabling interrupts\\n\");\n\t\t}\n\t\tvalid = crq->valid;\n\t\tdma_rmb();\n\t\tif (valid)\n\t\t\tgoto poll_work;\n\t}\n\n\tdev_dbg(&vscsi->dev, \"Leaving poll_cmd_q: rc %ld\\n\", rc);\n}\n\n \nstatic void ibmvscsis_free_cmd_qs(struct scsi_info *vscsi)\n{\n\tstruct ibmvscsis_cmd *cmd, *nxt;\n\n\tdev_dbg(&vscsi->dev, \"free_cmd_qs: waiting_rsp empty %d, timer starter %d\\n\",\n\t\t(int)list_empty(&vscsi->waiting_rsp),\n\t\tvscsi->rsp_q_timer.started);\n\n\tlist_for_each_entry_safe(cmd, nxt, &vscsi->waiting_rsp, list) {\n\t\tlist_del(&cmd->list);\n\t\tibmvscsis_free_cmd_resources(vscsi, cmd);\n\t}\n}\n\n \nstatic struct ibmvscsis_cmd *ibmvscsis_get_free_cmd(struct scsi_info *vscsi)\n{\n\tstruct ibmvscsis_cmd *cmd = NULL;\n\tstruct iu_entry *iue;\n\n\tiue = srp_iu_get(&vscsi->target);\n\tif (iue) {\n\t\tcmd = list_first_entry_or_null(&vscsi->free_cmd,\n\t\t\t\t\t       struct ibmvscsis_cmd, list);\n\t\tif (cmd) {\n\t\t\tif (cmd->abort_cmd)\n\t\t\t\tcmd->abort_cmd = NULL;\n\t\t\tcmd->flags &= ~(DELAY_SEND);\n\t\t\tlist_del(&cmd->list);\n\t\t\tcmd->iue = iue;\n\t\t\tcmd->type = UNSET_TYPE;\n\t\t\tmemset(&cmd->se_cmd, 0, sizeof(cmd->se_cmd));\n\t\t} else {\n\t\t\tsrp_iu_put(iue);\n\t\t}\n\t}\n\n\treturn cmd;\n}\n\n \nstatic void ibmvscsis_adapter_idle(struct scsi_info *vscsi)\n{\n\tint free_qs = false;\n\tlong rc = 0;\n\n\tdev_dbg(&vscsi->dev, \"adapter_idle: flags 0x%x, state 0x%hx\\n\",\n\t\tvscsi->flags, vscsi->state);\n\n\t \n\tif (vscsi->state != WAIT_CONNECTION || vscsi->flags & TRANS_EVENT)\n\t\tfree_qs = true;\n\n\tswitch (vscsi->state) {\n\tcase UNCONFIGURING:\n\t\tibmvscsis_free_command_q(vscsi);\n\t\tdma_rmb();\n\t\tisync();\n\t\tif (vscsi->flags & CFG_SLEEPING) {\n\t\t\tvscsi->flags &= ~CFG_SLEEPING;\n\t\t\tcomplete(&vscsi->unconfig);\n\t\t}\n\t\tbreak;\n\tcase ERR_DISCONNECT_RECONNECT:\n\t\tibmvscsis_reset_queue(vscsi);\n\t\tdev_dbg(&vscsi->dev, \"adapter_idle, disc_rec: flags 0x%x\\n\",\n\t\t\tvscsi->flags);\n\t\tbreak;\n\n\tcase ERR_DISCONNECT:\n\t\tibmvscsis_free_command_q(vscsi);\n\t\tvscsi->flags &= ~(SCHEDULE_DISCONNECT | DISCONNECT_SCHEDULED);\n\t\tvscsi->flags |= RESPONSE_Q_DOWN;\n\t\tif (vscsi->tport.enabled)\n\t\t\tvscsi->state = ERR_DISCONNECTED;\n\t\telse\n\t\t\tvscsi->state = WAIT_ENABLED;\n\t\tdev_dbg(&vscsi->dev, \"adapter_idle, disc: flags 0x%x, state 0x%hx\\n\",\n\t\t\tvscsi->flags, vscsi->state);\n\t\tbreak;\n\n\tcase WAIT_IDLE:\n\t\tvscsi->rsp_q_timer.timer_pops = 0;\n\t\tvscsi->debit = 0;\n\t\tvscsi->credit = 0;\n\t\tif (vscsi->flags & PREP_FOR_SUSPEND_PENDING) {\n\t\t\tvscsi->state = vscsi->resume_state;\n\t\t\tvscsi->resume_state = 0;\n\t\t\trc = ibmvscsis_ready_for_suspend(vscsi, true);\n\t\t\tvscsi->flags &= ~DISCONNECT_SCHEDULED;\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t} else if (vscsi->flags & TRANS_EVENT) {\n\t\t\tvscsi->state = WAIT_CONNECTION;\n\t\t\tvscsi->flags &= PRESERVE_FLAG_FIELDS;\n\t\t} else {\n\t\t\tvscsi->state = CONNECTED;\n\t\t\tvscsi->flags &= ~DISCONNECT_SCHEDULED;\n\t\t}\n\n\t\tdev_dbg(&vscsi->dev, \"adapter_idle, wait: flags 0x%x, state 0x%hx\\n\",\n\t\t\tvscsi->flags, vscsi->state);\n\t\tibmvscsis_poll_cmd_q(vscsi);\n\t\tbreak;\n\n\tcase ERR_DISCONNECTED:\n\t\tvscsi->flags &= ~DISCONNECT_SCHEDULED;\n\t\tdev_dbg(&vscsi->dev, \"adapter_idle, disconnected: flags 0x%x, state 0x%hx\\n\",\n\t\t\tvscsi->flags, vscsi->state);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&vscsi->dev, \"adapter_idle: in invalid state %d\\n\",\n\t\t\tvscsi->state);\n\t\tbreak;\n\t}\n\n\tif (free_qs)\n\t\tibmvscsis_free_cmd_qs(vscsi);\n\n\t \n\tif (vscsi->phyp_acr_state != 0)\t{\n\t\t \n\t\tvscsi->flags |= vscsi->phyp_acr_flags;\n\t\tibmvscsis_post_disconnect(vscsi, vscsi->phyp_acr_state, 0);\n\t\tvscsi->phyp_acr_state = 0;\n\t\tvscsi->phyp_acr_flags = 0;\n\n\t\tdev_dbg(&vscsi->dev, \"adapter_idle: flags 0x%x, state 0x%hx, acr_flags 0x%x, acr_state 0x%hx\\n\",\n\t\t\tvscsi->flags, vscsi->state, vscsi->phyp_acr_flags,\n\t\t\tvscsi->phyp_acr_state);\n\t}\n\n\tdev_dbg(&vscsi->dev, \"Leaving adapter_idle: flags 0x%x, state 0x%hx, new_state 0x%x\\n\",\n\t\tvscsi->flags, vscsi->state, vscsi->new_state);\n}\n\n \nstatic long ibmvscsis_copy_crq_packet(struct scsi_info *vscsi,\n\t\t\t\t      struct ibmvscsis_cmd *cmd,\n\t\t\t\t      struct viosrp_crq *crq)\n{\n\tstruct iu_entry *iue = cmd->iue;\n\tlong rc = 0;\n\tu16 len;\n\n\tlen = be16_to_cpu(crq->IU_length);\n\tif ((len > SRP_MAX_IU_LEN) || (len == 0)) {\n\t\tdev_err(&vscsi->dev, \"copy_crq: Invalid len %d passed\", len);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\n\t\treturn SRP_VIOLATION;\n\t}\n\n\trc = h_copy_rdma(len, vscsi->dds.window[REMOTE].liobn,\n\t\t\t be64_to_cpu(crq->IU_data_ptr),\n\t\t\t vscsi->dds.window[LOCAL].liobn, iue->sbuf->dma);\n\n\tswitch (rc) {\n\tcase H_SUCCESS:\n\t\tcmd->init_time = mftb();\n\t\tiue->remote_token = crq->IU_data_ptr;\n\t\tiue->iu_len = len;\n\t\tdev_dbg(&vscsi->dev, \"copy_crq: ioba 0x%llx, init_time 0x%llx\\n\",\n\t\t\tbe64_to_cpu(crq->IU_data_ptr), cmd->init_time);\n\t\tbreak;\n\tcase H_PERMISSION:\n\t\tif (connection_broken(vscsi))\n\t\t\tibmvscsis_post_disconnect(vscsi,\n\t\t\t\t\t\t  ERR_DISCONNECT_RECONNECT,\n\t\t\t\t\t\t  (RESPONSE_Q_DOWN |\n\t\t\t\t\t\t   CLIENT_FAILED));\n\t\telse\n\t\t\tibmvscsis_post_disconnect(vscsi,\n\t\t\t\t\t\t  ERR_DISCONNECT_RECONNECT, 0);\n\n\t\tdev_err(&vscsi->dev, \"copy_crq: h_copy_rdma failed, rc %ld\\n\",\n\t\t\trc);\n\t\tbreak;\n\tcase H_DEST_PARM:\n\tcase H_SOURCE_PARM:\n\tdefault:\n\t\tdev_err(&vscsi->dev, \"copy_crq: h_copy_rdma failed, rc %ld\\n\",\n\t\t\trc);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nstatic long ibmvscsis_adapter_info(struct scsi_info *vscsi,\n\t\t\t\t   struct iu_entry *iue)\n{\n\tstruct viosrp_adapter_info *mad = &vio_iu(iue)->mad.adapter_info;\n\tstruct mad_adapter_info_data *info;\n\tuint flag_bits = 0;\n\tdma_addr_t token;\n\tlong rc;\n\n\tmad->common.status = cpu_to_be16(VIOSRP_MAD_SUCCESS);\n\n\tif (be16_to_cpu(mad->common.length) > sizeof(*info)) {\n\t\tmad->common.status = cpu_to_be16(VIOSRP_MAD_FAILED);\n\t\treturn 0;\n\t}\n\n\tinfo = dma_alloc_coherent(&vscsi->dma_dev->dev, sizeof(*info), &token,\n\t\t\t\t  GFP_ATOMIC);\n\tif (!info) {\n\t\tdev_err(&vscsi->dev, \"bad dma_alloc_coherent %p\\n\",\n\t\t\tiue->target);\n\t\tmad->common.status = cpu_to_be16(VIOSRP_MAD_FAILED);\n\t\treturn 0;\n\t}\n\n\t \n\trc = h_copy_rdma(be16_to_cpu(mad->common.length),\n\t\t\t vscsi->dds.window[REMOTE].liobn,\n\t\t\t be64_to_cpu(mad->buffer),\n\t\t\t vscsi->dds.window[LOCAL].liobn, token);\n\n\tif (rc != H_SUCCESS) {\n\t\tif (rc == H_PERMISSION) {\n\t\t\tif (connection_broken(vscsi))\n\t\t\t\tflag_bits = (RESPONSE_Q_DOWN | CLIENT_FAILED);\n\t\t}\n\t\tdev_warn(&vscsi->dev, \"adapter_info: h_copy_rdma from client failed, rc %ld\\n\",\n\t\t\t rc);\n\t\tdev_dbg(&vscsi->dev, \"adapter_info: ioba 0x%llx, flags 0x%x, flag_bits 0x%x\\n\",\n\t\t\tbe64_to_cpu(mad->buffer), vscsi->flags, flag_bits);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT,\n\t\t\t\t\t  flag_bits);\n\t\tgoto free_dma;\n\t}\n\n\t \n\tif (vscsi->client_data.partition_number == 0)\n\t\tvscsi->client_data.partition_number =\n\t\t\tbe32_to_cpu(info->partition_number);\n\tstrncpy(vscsi->client_data.srp_version, info->srp_version,\n\t\tsizeof(vscsi->client_data.srp_version));\n\tstrncpy(vscsi->client_data.partition_name, info->partition_name,\n\t\tsizeof(vscsi->client_data.partition_name));\n\tvscsi->client_data.mad_version = be32_to_cpu(info->mad_version);\n\tvscsi->client_data.os_type = be32_to_cpu(info->os_type);\n\n\t \n\tstrncpy(info->srp_version, SRP_VERSION,\n\t\tsizeof(info->srp_version));\n\tstrncpy(info->partition_name, vscsi->dds.partition_name,\n\t\tsizeof(info->partition_name));\n\tinfo->partition_number = cpu_to_be32(vscsi->dds.partition_num);\n\tinfo->mad_version = cpu_to_be32(MAD_VERSION_1);\n\tinfo->os_type = cpu_to_be32(LINUX);\n\tmemset(&info->port_max_txu[0], 0, sizeof(info->port_max_txu));\n\tinfo->port_max_txu[0] = cpu_to_be32(MAX_TXU);\n\n\tdma_wmb();\n\trc = h_copy_rdma(sizeof(*info), vscsi->dds.window[LOCAL].liobn,\n\t\t\t token, vscsi->dds.window[REMOTE].liobn,\n\t\t\t be64_to_cpu(mad->buffer));\n\tswitch (rc) {\n\tcase H_SUCCESS:\n\t\tbreak;\n\n\tcase H_SOURCE_PARM:\n\tcase H_DEST_PARM:\n\tcase H_PERMISSION:\n\t\tif (connection_broken(vscsi))\n\t\t\tflag_bits = (RESPONSE_Q_DOWN | CLIENT_FAILED);\n\t\tfallthrough;\n\tdefault:\n\t\tdev_err(&vscsi->dev, \"adapter_info: h_copy_rdma to client failed, rc %ld\\n\",\n\t\t\trc);\n\t\tibmvscsis_post_disconnect(vscsi,\n\t\t\t\t\t  ERR_DISCONNECT_RECONNECT,\n\t\t\t\t\t  flag_bits);\n\t\tbreak;\n\t}\n\nfree_dma:\n\tdma_free_coherent(&vscsi->dma_dev->dev, sizeof(*info), info, token);\n\tdev_dbg(&vscsi->dev, \"Leaving adapter_info, rc %ld\\n\", rc);\n\n\treturn rc;\n}\n\n \nstatic int ibmvscsis_cap_mad(struct scsi_info *vscsi, struct iu_entry *iue)\n{\n\tstruct viosrp_capabilities *mad = &vio_iu(iue)->mad.capabilities;\n\tstruct capabilities *cap;\n\tstruct mad_capability_common *common;\n\tdma_addr_t token;\n\tu16 olen, len, status, min_len, cap_len;\n\tu32 flag;\n\tuint flag_bits = 0;\n\tlong rc = 0;\n\n\tolen = be16_to_cpu(mad->common.length);\n\t \n\tmin_len = offsetof(struct capabilities, migration);\n\tif ((olen < min_len) || (olen > PAGE_SIZE)) {\n\t\tdev_warn(&vscsi->dev, \"cap_mad: invalid len %d\\n\", olen);\n\t\tmad->common.status = cpu_to_be16(VIOSRP_MAD_FAILED);\n\t\treturn 0;\n\t}\n\n\tcap = dma_alloc_coherent(&vscsi->dma_dev->dev, olen, &token,\n\t\t\t\t GFP_ATOMIC);\n\tif (!cap) {\n\t\tdev_err(&vscsi->dev, \"bad dma_alloc_coherent %p\\n\",\n\t\t\tiue->target);\n\t\tmad->common.status = cpu_to_be16(VIOSRP_MAD_FAILED);\n\t\treturn 0;\n\t}\n\trc = h_copy_rdma(olen, vscsi->dds.window[REMOTE].liobn,\n\t\t\t be64_to_cpu(mad->buffer),\n\t\t\t vscsi->dds.window[LOCAL].liobn, token);\n\tif (rc == H_SUCCESS) {\n\t\tstrncpy(cap->name, dev_name(&vscsi->dma_dev->dev),\n\t\t\tSRP_MAX_LOC_LEN);\n\n\t\tlen = olen - min_len;\n\t\tstatus = VIOSRP_MAD_SUCCESS;\n\t\tcommon = (struct mad_capability_common *)&cap->migration;\n\n\t\twhile ((len > 0) && (status == VIOSRP_MAD_SUCCESS) && !rc) {\n\t\t\tdev_dbg(&vscsi->dev, \"cap_mad: len left %hd, cap type %d, cap len %hd\\n\",\n\t\t\t\tlen, be32_to_cpu(common->cap_type),\n\t\t\t\tbe16_to_cpu(common->length));\n\n\t\t\tcap_len = be16_to_cpu(common->length);\n\t\t\tif (cap_len > len) {\n\t\t\t\tdev_err(&vscsi->dev, \"cap_mad: cap len mismatch with total len\\n\");\n\t\t\t\tstatus = VIOSRP_MAD_FAILED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (cap_len == 0) {\n\t\t\t\tdev_err(&vscsi->dev, \"cap_mad: cap len is 0\\n\");\n\t\t\t\tstatus = VIOSRP_MAD_FAILED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (common->cap_type) {\n\t\t\tdefault:\n\t\t\t\tdev_dbg(&vscsi->dev, \"cap_mad: unsupported capability\\n\");\n\t\t\t\tcommon->server_support = 0;\n\t\t\t\tflag = cpu_to_be32((u32)CAP_LIST_SUPPORTED);\n\t\t\t\tcap->flags &= ~flag;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlen = len - cap_len;\n\t\t\tcommon = (struct mad_capability_common *)\n\t\t\t\t((char *)common + cap_len);\n\t\t}\n\n\t\tmad->common.status = cpu_to_be16(status);\n\n\t\tdma_wmb();\n\t\trc = h_copy_rdma(olen, vscsi->dds.window[LOCAL].liobn, token,\n\t\t\t\t vscsi->dds.window[REMOTE].liobn,\n\t\t\t\t be64_to_cpu(mad->buffer));\n\n\t\tif (rc != H_SUCCESS) {\n\t\t\tdev_dbg(&vscsi->dev, \"cap_mad: failed to copy to client, rc %ld\\n\",\n\t\t\t\trc);\n\n\t\t\tif (rc == H_PERMISSION) {\n\t\t\t\tif (connection_broken(vscsi))\n\t\t\t\t\tflag_bits = (RESPONSE_Q_DOWN |\n\t\t\t\t\t\t     CLIENT_FAILED);\n\t\t\t}\n\n\t\t\tdev_warn(&vscsi->dev, \"cap_mad: error copying data to client, rc %ld\\n\",\n\t\t\t\t rc);\n\t\t\tibmvscsis_post_disconnect(vscsi,\n\t\t\t\t\t\t  ERR_DISCONNECT_RECONNECT,\n\t\t\t\t\t\t  flag_bits);\n\t\t}\n\t}\n\n\tdma_free_coherent(&vscsi->dma_dev->dev, olen, cap, token);\n\n\tdev_dbg(&vscsi->dev, \"Leaving cap_mad, rc %ld, client_cap 0x%x\\n\",\n\t\trc, vscsi->client_cap);\n\n\treturn rc;\n}\n\n \nstatic long ibmvscsis_process_mad(struct scsi_info *vscsi, struct iu_entry *iue)\n{\n\tstruct mad_common *mad = (struct mad_common *)&vio_iu(iue)->mad;\n\tstruct viosrp_empty_iu *empty;\n\tlong rc = ADAPT_SUCCESS;\n\n\tswitch (be32_to_cpu(mad->type)) {\n\tcase VIOSRP_EMPTY_IU_TYPE:\n\t\tempty = &vio_iu(iue)->mad.empty_iu;\n\t\tvscsi->empty_iu_id = be64_to_cpu(empty->buffer);\n\t\tvscsi->empty_iu_tag = be64_to_cpu(empty->common.tag);\n\t\tmad->status = cpu_to_be16(VIOSRP_MAD_SUCCESS);\n\t\tbreak;\n\tcase VIOSRP_ADAPTER_INFO_TYPE:\n\t\trc = ibmvscsis_adapter_info(vscsi, iue);\n\t\tbreak;\n\tcase VIOSRP_CAPABILITIES_TYPE:\n\t\trc = ibmvscsis_cap_mad(vscsi, iue);\n\t\tbreak;\n\tcase VIOSRP_ENABLE_FAST_FAIL:\n\t\tif (vscsi->state == CONNECTED) {\n\t\t\tvscsi->fast_fail = true;\n\t\t\tmad->status = cpu_to_be16(VIOSRP_MAD_SUCCESS);\n\t\t} else {\n\t\t\tdev_warn(&vscsi->dev, \"fast fail mad sent after login\\n\");\n\t\t\tmad->status = cpu_to_be16(VIOSRP_MAD_FAILED);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tmad->status = cpu_to_be16(VIOSRP_MAD_NOT_SUPPORTED);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nstatic void srp_snd_msg_failed(struct scsi_info *vscsi, long rc)\n{\n\tktime_t kt;\n\n\tif (rc != H_DROPPED) {\n\t\tibmvscsis_free_cmd_qs(vscsi);\n\n\t\tif (rc == H_CLOSED)\n\t\t\tvscsi->flags |= CLIENT_FAILED;\n\n\t\t \n\t\tif (!(vscsi->flags & RESPONSE_Q_DOWN)) {\n\t\t\tvscsi->flags |= RESPONSE_Q_DOWN;\n\t\t\tif (!(vscsi->state & (ERR_DISCONNECT |\n\t\t\t\t\t      ERR_DISCONNECT_RECONNECT |\n\t\t\t\t\t      ERR_DISCONNECTED | UNDEFINED))) {\n\t\t\t\tdev_err(&vscsi->dev, \"snd_msg_failed: setting RESPONSE_Q_DOWN, state 0x%hx, flags 0x%x, rc %ld\\n\",\n\t\t\t\t\tvscsi->state, vscsi->flags, rc);\n\t\t\t}\n\t\t\tibmvscsis_post_disconnect(vscsi,\n\t\t\t\t\t\t  ERR_DISCONNECT_RECONNECT, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif ((vscsi->rsp_q_timer.timer_pops < MAX_TIMER_POPS) ||\n\t    (vscsi->state == SRP_PROCESSING)) {\n\t\tdev_dbg(&vscsi->dev, \"snd_msg_failed: response queue full, flags 0x%x, timer started %d, pops %d\\n\",\n\t\t\tvscsi->flags, (int)vscsi->rsp_q_timer.started,\n\t\t\tvscsi->rsp_q_timer.timer_pops);\n\n\t\t \n\t\tif (!vscsi->rsp_q_timer.started) {\n\t\t\tif (vscsi->rsp_q_timer.timer_pops <\n\t\t\t    MAX_TIMER_POPS) {\n\t\t\t\tkt = WAIT_NANO_SECONDS;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tkt = ktime_set(WAIT_SECONDS, 0);\n\t\t\t}\n\n\t\t\tvscsi->rsp_q_timer.started = true;\n\t\t\thrtimer_start(&vscsi->rsp_q_timer.timer, kt,\n\t\t\t\t      HRTIMER_MODE_REL);\n\t\t}\n\t} else {\n\t\t \n\t\t \n\t\tvscsi->flags |= RESPONSE_Q_DOWN;\n\t\tibmvscsis_free_cmd_qs(vscsi);\n\t\t \n\t\tif (!(vscsi->state & (ERR_DISCONNECT |\n\t\t\t\t      ERR_DISCONNECT_RECONNECT |\n\t\t\t\t      ERR_DISCONNECTED | UNDEFINED))) {\n\t\t\tdev_err(&vscsi->dev, \"client crq full too long\\n\");\n\t\t\tibmvscsis_post_disconnect(vscsi,\n\t\t\t\t\t\t  ERR_DISCONNECT_RECONNECT,\n\t\t\t\t\t\t  0);\n\t\t}\n\t}\n}\n\n \nstatic void ibmvscsis_send_messages(struct scsi_info *vscsi)\n{\n\tstruct viosrp_crq empty_crq = { };\n\tstruct viosrp_crq *crq = &empty_crq;\n\tstruct ibmvscsis_cmd *cmd, *nxt;\n\tlong rc = ADAPT_SUCCESS;\n\tbool retry = false;\n\n\tif (!(vscsi->flags & RESPONSE_Q_DOWN)) {\n\t\tdo {\n\t\t\tretry = false;\n\t\t\tlist_for_each_entry_safe(cmd, nxt, &vscsi->waiting_rsp,\n\t\t\t\t\t\t list) {\n\t\t\t\t \n\t\t\t\tif (cmd->flags & DELAY_SEND)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (cmd->abort_cmd) {\n\t\t\t\t\tretry = true;\n\t\t\t\t\tcmd->abort_cmd->flags &= ~(DELAY_SEND);\n\t\t\t\t\tcmd->abort_cmd = NULL;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (cmd->se_cmd.transport_state & CMD_T_ABORTED &&\n\t\t\t\t    !(cmd->se_cmd.transport_state & CMD_T_TAS)) {\n\t\t\t\t\tlist_del(&cmd->list);\n\t\t\t\t\tibmvscsis_free_cmd_resources(vscsi,\n\t\t\t\t\t\t\t\t     cmd);\n\t\t\t\t\t \n\t\t\t\t\tvscsi->credit += 1;\n\t\t\t\t} else {\n\t\t\t\t\tcrq->valid = VALID_CMD_RESP_EL;\n\t\t\t\t\tcrq->format = cmd->rsp.format;\n\n\t\t\t\t\tif (cmd->flags & CMD_FAST_FAIL)\n\t\t\t\t\t\tcrq->status = VIOSRP_ADAPTER_FAIL;\n\n\t\t\t\t\tcrq->IU_length = cpu_to_be16(cmd->rsp.len);\n\n\t\t\t\t\trc = h_send_crq(vscsi->dma_dev->unit_address,\n\t\t\t\t\t\t\tbe64_to_cpu(crq->high),\n\t\t\t\t\t\t\tbe64_to_cpu(cmd->rsp.tag));\n\n\t\t\t\t\tdev_dbg(&vscsi->dev, \"send_messages: cmd %p, tag 0x%llx, rc %ld\\n\",\n\t\t\t\t\t\tcmd, be64_to_cpu(cmd->rsp.tag),\n\t\t\t\t\t\trc);\n\n\t\t\t\t\t \n\t\t\t\t\tif (rc == H_SUCCESS) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tvscsi->rsp_q_timer.timer_pops = 0;\n\t\t\t\t\t\tlist_del(&cmd->list);\n\n\t\t\t\t\t\tibmvscsis_free_cmd_resources(vscsi,\n\t\t\t\t\t\t\t\t\t     cmd);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsrp_snd_msg_failed(vscsi, rc);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while (retry);\n\n\t\tif (!rc) {\n\t\t\t \n\t\t\tvscsi->rsp_q_timer.timer_pops = 0;\n\t\t}\n\t} else {\n\t\tibmvscsis_free_cmd_qs(vscsi);\n\t}\n}\n\n \nstatic void ibmvscsis_send_mad_resp(struct scsi_info *vscsi,\n\t\t\t\t    struct ibmvscsis_cmd *cmd,\n\t\t\t\t    struct viosrp_crq *crq)\n{\n\tstruct iu_entry *iue = cmd->iue;\n\tstruct mad_common *mad = (struct mad_common *)&vio_iu(iue)->mad;\n\tuint flag_bits = 0;\n\tlong rc;\n\n\tdma_wmb();\n\trc = h_copy_rdma(sizeof(struct mad_common),\n\t\t\t vscsi->dds.window[LOCAL].liobn, iue->sbuf->dma,\n\t\t\t vscsi->dds.window[REMOTE].liobn,\n\t\t\t be64_to_cpu(crq->IU_data_ptr));\n\tif (!rc) {\n\t\tcmd->rsp.format = VIOSRP_MAD_FORMAT;\n\t\tcmd->rsp.len = sizeof(struct mad_common);\n\t\tcmd->rsp.tag = mad->tag;\n\t\tlist_add_tail(&cmd->list, &vscsi->waiting_rsp);\n\t\tibmvscsis_send_messages(vscsi);\n\t} else {\n\t\tdev_dbg(&vscsi->dev, \"Error sending mad response, rc %ld\\n\",\n\t\t\trc);\n\t\tif (rc == H_PERMISSION) {\n\t\t\tif (connection_broken(vscsi))\n\t\t\t\tflag_bits = (RESPONSE_Q_DOWN | CLIENT_FAILED);\n\t\t}\n\t\tdev_err(&vscsi->dev, \"mad: failed to copy to client, rc %ld\\n\",\n\t\t\trc);\n\n\t\tibmvscsis_free_cmd_resources(vscsi, cmd);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT,\n\t\t\t\t\t  flag_bits);\n\t}\n}\n\n \nstatic long ibmvscsis_mad(struct scsi_info *vscsi, struct viosrp_crq *crq)\n{\n\tstruct iu_entry *iue;\n\tstruct ibmvscsis_cmd *cmd;\n\tstruct mad_common *mad;\n\tlong rc = ADAPT_SUCCESS;\n\n\tswitch (vscsi->state) {\n\t\t \n\tcase WAIT_CONNECTION:\n\t\tdev_dbg(&vscsi->dev, \"mad: in Wait Connection state, ignoring MAD, flags %d\\n\",\n\t\t\tvscsi->flags);\n\t\treturn ADAPT_SUCCESS;\n\n\tcase SRP_PROCESSING:\n\tcase CONNECTED:\n\t\tbreak;\n\n\t\t \n\tcase UNCONFIGURING:\n\tcase WAIT_IDLE:\n\tcase ERR_DISCONNECT:\n\tcase ERR_DISCONNECT_RECONNECT:\n\tdefault:\n\t\tdev_err(&vscsi->dev, \"mad: invalid adapter state %d for mad\\n\",\n\t\t\tvscsi->state);\n\t\treturn ADAPT_SUCCESS;\n\t}\n\n\tcmd = ibmvscsis_get_free_cmd(vscsi);\n\tif (!cmd) {\n\t\tdev_err(&vscsi->dev, \"mad: failed to get cmd, debit %d\\n\",\n\t\t\tvscsi->debit);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\n\t\treturn ERROR;\n\t}\n\tiue = cmd->iue;\n\tcmd->type = ADAPTER_MAD;\n\n\trc = ibmvscsis_copy_crq_packet(vscsi, cmd, crq);\n\tif (!rc) {\n\t\tmad = (struct mad_common *)&vio_iu(iue)->mad;\n\n\t\tdev_dbg(&vscsi->dev, \"mad: type %d\\n\", be32_to_cpu(mad->type));\n\n\t\trc = ibmvscsis_process_mad(vscsi, iue);\n\n\t\tdev_dbg(&vscsi->dev, \"mad: status %hd, rc %ld\\n\",\n\t\t\tbe16_to_cpu(mad->status), rc);\n\n\t\tif (!rc)\n\t\t\tibmvscsis_send_mad_resp(vscsi, cmd, crq);\n\t} else {\n\t\tibmvscsis_free_cmd_resources(vscsi, cmd);\n\t}\n\n\tdev_dbg(&vscsi->dev, \"Leaving mad, rc %ld\\n\", rc);\n\treturn rc;\n}\n\n \nstatic long ibmvscsis_login_rsp(struct scsi_info *vscsi,\n\t\t\t\tstruct ibmvscsis_cmd *cmd)\n{\n\tstruct iu_entry *iue = cmd->iue;\n\tstruct srp_login_rsp *rsp = &vio_iu(iue)->srp.login_rsp;\n\tstruct format_code *fmt;\n\tuint flag_bits = 0;\n\tlong rc = ADAPT_SUCCESS;\n\n\tmemset(rsp, 0, sizeof(struct srp_login_rsp));\n\n\trsp->opcode = SRP_LOGIN_RSP;\n\trsp->req_lim_delta = cpu_to_be32(vscsi->request_limit);\n\trsp->tag = cmd->rsp.tag;\n\trsp->max_it_iu_len = cpu_to_be32(SRP_MAX_IU_LEN);\n\trsp->max_ti_iu_len = cpu_to_be32(SRP_MAX_IU_LEN);\n\tfmt = (struct format_code *)&rsp->buf_fmt;\n\tfmt->buffers = SUPPORTED_FORMATS;\n\tvscsi->credit = 0;\n\n\tcmd->rsp.len = sizeof(struct srp_login_rsp);\n\n\tdma_wmb();\n\trc = h_copy_rdma(cmd->rsp.len, vscsi->dds.window[LOCAL].liobn,\n\t\t\t iue->sbuf->dma, vscsi->dds.window[REMOTE].liobn,\n\t\t\t be64_to_cpu(iue->remote_token));\n\n\tswitch (rc) {\n\tcase H_SUCCESS:\n\t\tbreak;\n\n\tcase H_PERMISSION:\n\t\tif (connection_broken(vscsi))\n\t\t\tflag_bits = RESPONSE_Q_DOWN | CLIENT_FAILED;\n\t\tdev_err(&vscsi->dev, \"login_rsp: error copying to client, rc %ld\\n\",\n\t\t\trc);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT,\n\t\t\t\t\t  flag_bits);\n\t\tbreak;\n\tcase H_SOURCE_PARM:\n\tcase H_DEST_PARM:\n\tdefault:\n\t\tdev_err(&vscsi->dev, \"login_rsp: error copying to client, rc %ld\\n\",\n\t\t\trc);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nstatic long ibmvscsis_srp_login_rej(struct scsi_info *vscsi,\n\t\t\t\t    struct ibmvscsis_cmd *cmd, u32 reason)\n{\n\tstruct iu_entry *iue = cmd->iue;\n\tstruct srp_login_rej *rej = &vio_iu(iue)->srp.login_rej;\n\tstruct format_code *fmt;\n\tuint flag_bits = 0;\n\tlong rc = ADAPT_SUCCESS;\n\n\tmemset(rej, 0, sizeof(*rej));\n\n\trej->opcode = SRP_LOGIN_REJ;\n\trej->reason = cpu_to_be32(reason);\n\trej->tag = cmd->rsp.tag;\n\tfmt = (struct format_code *)&rej->buf_fmt;\n\tfmt->buffers = SUPPORTED_FORMATS;\n\n\tcmd->rsp.len = sizeof(*rej);\n\n\tdma_wmb();\n\trc = h_copy_rdma(cmd->rsp.len, vscsi->dds.window[LOCAL].liobn,\n\t\t\t iue->sbuf->dma, vscsi->dds.window[REMOTE].liobn,\n\t\t\t be64_to_cpu(iue->remote_token));\n\n\tswitch (rc) {\n\tcase H_SUCCESS:\n\t\tbreak;\n\tcase H_PERMISSION:\n\t\tif (connection_broken(vscsi))\n\t\t\tflag_bits = RESPONSE_Q_DOWN | CLIENT_FAILED;\n\t\tdev_err(&vscsi->dev, \"login_rej: error copying to client, rc %ld\\n\",\n\t\t\trc);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT,\n\t\t\t\t\t  flag_bits);\n\t\tbreak;\n\tcase H_SOURCE_PARM:\n\tcase H_DEST_PARM:\n\tdefault:\n\t\tdev_err(&vscsi->dev, \"login_rej: error copying to client, rc %ld\\n\",\n\t\t\trc);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int ibmvscsis_make_nexus(struct ibmvscsis_tport *tport)\n{\n\tchar *name = tport->tport_name;\n\tstruct ibmvscsis_nexus *nexus;\n\tstruct scsi_info *vscsi = container_of(tport, struct scsi_info, tport);\n\tint rc;\n\n\tif (tport->ibmv_nexus) {\n\t\tdev_dbg(&vscsi->dev, \"tport->ibmv_nexus already exists\\n\");\n\t\treturn 0;\n\t}\n\n\tnexus = kzalloc(sizeof(*nexus), GFP_KERNEL);\n\tif (!nexus) {\n\t\tdev_err(&vscsi->dev, \"Unable to allocate struct ibmvscsis_nexus\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnexus->se_sess = target_setup_session(&tport->se_tpg, 0, 0,\n\t\t\t\t\t      TARGET_PROT_NORMAL, name, nexus,\n\t\t\t\t\t      NULL);\n\tif (IS_ERR(nexus->se_sess)) {\n\t\trc = PTR_ERR(nexus->se_sess);\n\t\tgoto transport_init_fail;\n\t}\n\n\ttport->ibmv_nexus = nexus;\n\n\treturn 0;\n\ntransport_init_fail:\n\tkfree(nexus);\n\treturn rc;\n}\n\nstatic int ibmvscsis_drop_nexus(struct ibmvscsis_tport *tport)\n{\n\tstruct se_session *se_sess;\n\tstruct ibmvscsis_nexus *nexus;\n\n\tnexus = tport->ibmv_nexus;\n\tif (!nexus)\n\t\treturn -ENODEV;\n\n\tse_sess = nexus->se_sess;\n\tif (!se_sess)\n\t\treturn -ENODEV;\n\n\t \n\ttarget_remove_session(se_sess);\n\ttport->ibmv_nexus = NULL;\n\tkfree(nexus);\n\n\treturn 0;\n}\n\n \nstatic long ibmvscsis_srp_login(struct scsi_info *vscsi,\n\t\t\t\tstruct ibmvscsis_cmd *cmd,\n\t\t\t\tstruct viosrp_crq *crq)\n{\n\tstruct iu_entry *iue = cmd->iue;\n\tstruct srp_login_req *req = &vio_iu(iue)->srp.login_req;\n\tstruct port_id {\n\t\t__be64 id_extension;\n\t\t__be64 io_guid;\n\t} *iport, *tport;\n\tstruct format_code *fmt;\n\tu32 reason = 0x0;\n\tlong rc = ADAPT_SUCCESS;\n\n\tiport = (struct port_id *)req->initiator_port_id;\n\ttport = (struct port_id *)req->target_port_id;\n\tfmt = (struct format_code *)&req->req_buf_fmt;\n\tif (be32_to_cpu(req->req_it_iu_len) > SRP_MAX_IU_LEN)\n\t\treason = SRP_LOGIN_REJ_REQ_IT_IU_LENGTH_TOO_LARGE;\n\telse if (be32_to_cpu(req->req_it_iu_len) < 64)\n\t\treason = SRP_LOGIN_REJ_UNABLE_ESTABLISH_CHANNEL;\n\telse if ((be64_to_cpu(iport->id_extension) > (MAX_NUM_PORTS - 1)) ||\n\t\t (be64_to_cpu(tport->id_extension) > (MAX_NUM_PORTS - 1)))\n\t\treason = SRP_LOGIN_REJ_UNABLE_ASSOCIATE_CHANNEL;\n\telse if (req->req_flags & SRP_MULTICHAN_MULTI)\n\t\treason = SRP_LOGIN_REJ_MULTI_CHANNEL_UNSUPPORTED;\n\telse if (fmt->buffers & (~SUPPORTED_FORMATS))\n\t\treason = SRP_LOGIN_REJ_UNSUPPORTED_DESCRIPTOR_FMT;\n\telse if ((fmt->buffers & SUPPORTED_FORMATS) == 0)\n\t\treason = SRP_LOGIN_REJ_UNSUPPORTED_DESCRIPTOR_FMT;\n\n\tif (vscsi->state == SRP_PROCESSING)\n\t\treason = SRP_LOGIN_REJ_CHANNEL_LIMIT_REACHED;\n\n\trc = ibmvscsis_make_nexus(&vscsi->tport);\n\tif (rc)\n\t\treason = SRP_LOGIN_REJ_UNABLE_ESTABLISH_CHANNEL;\n\n\tcmd->rsp.format = VIOSRP_SRP_FORMAT;\n\tcmd->rsp.tag = req->tag;\n\n\tdev_dbg(&vscsi->dev, \"srp_login: reason 0x%x\\n\", reason);\n\n\tif (reason)\n\t\trc = ibmvscsis_srp_login_rej(vscsi, cmd, reason);\n\telse\n\t\trc = ibmvscsis_login_rsp(vscsi, cmd);\n\n\tif (!rc) {\n\t\tif (!reason)\n\t\t\tvscsi->state = SRP_PROCESSING;\n\n\t\tlist_add_tail(&cmd->list, &vscsi->waiting_rsp);\n\t\tibmvscsis_send_messages(vscsi);\n\t} else {\n\t\tibmvscsis_free_cmd_resources(vscsi, cmd);\n\t}\n\n\tdev_dbg(&vscsi->dev, \"Leaving srp_login, rc %ld\\n\", rc);\n\treturn rc;\n}\n\n \nstatic long ibmvscsis_srp_i_logout(struct scsi_info *vscsi,\n\t\t\t\t   struct ibmvscsis_cmd *cmd,\n\t\t\t\t   struct viosrp_crq *crq)\n{\n\tstruct iu_entry *iue = cmd->iue;\n\tstruct srp_i_logout *log_out = &vio_iu(iue)->srp.i_logout;\n\n\tif ((vscsi->debit > 0) || !list_empty(&vscsi->schedule_q) ||\n\t    !list_empty(&vscsi->waiting_rsp)) {\n\t\tdev_err(&vscsi->dev, \"i_logout: outstanding work\\n\");\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT, 0);\n\t} else {\n\t\tcmd->rsp.format = SRP_FORMAT;\n\t\tcmd->rsp.tag = log_out->tag;\n\t\tcmd->rsp.len = sizeof(struct mad_common);\n\t\tlist_add_tail(&cmd->list, &vscsi->waiting_rsp);\n\t\tibmvscsis_send_messages(vscsi);\n\n\t\tibmvscsis_post_disconnect(vscsi, WAIT_IDLE, 0);\n\t}\n\n\treturn ADAPT_SUCCESS;\n}\n\n \nstatic void ibmvscsis_srp_cmd(struct scsi_info *vscsi, struct viosrp_crq *crq)\n{\n\tstruct ibmvscsis_cmd *cmd;\n\tstruct iu_entry *iue;\n\tstruct srp_cmd *srp;\n\tstruct srp_tsk_mgmt *tsk;\n\tlong rc;\n\n\tif (vscsi->request_limit - vscsi->debit <= 0) {\n\t\t \n\t\tdev_err(&vscsi->dev, \"Client exceeded the request limit (%d), debit %d\\n\",\n\t\t\tvscsi->request_limit, vscsi->debit);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\n\t\treturn;\n\t}\n\n\tcmd = ibmvscsis_get_free_cmd(vscsi);\n\tif (!cmd) {\n\t\tdev_err(&vscsi->dev, \"srp_cmd failed to get cmd, debit %d\\n\",\n\t\t\tvscsi->debit);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\n\t\treturn;\n\t}\n\tiue = cmd->iue;\n\tsrp = &vio_iu(iue)->srp.cmd;\n\n\trc = ibmvscsis_copy_crq_packet(vscsi, cmd, crq);\n\tif (rc) {\n\t\tibmvscsis_free_cmd_resources(vscsi, cmd);\n\t\treturn;\n\t}\n\n\tif (vscsi->state == SRP_PROCESSING) {\n\t\tswitch (srp->opcode) {\n\t\tcase SRP_LOGIN_REQ:\n\t\t\trc = ibmvscsis_srp_login(vscsi, cmd, crq);\n\t\t\tbreak;\n\n\t\tcase SRP_TSK_MGMT:\n\t\t\ttsk = &vio_iu(iue)->srp.tsk_mgmt;\n\t\t\tdev_dbg(&vscsi->dev, \"tsk_mgmt tag: %llu (0x%llx)\\n\",\n\t\t\t\ttsk->tag, tsk->tag);\n\t\t\tcmd->rsp.tag = tsk->tag;\n\t\t\tvscsi->debit += 1;\n\t\t\tcmd->type = TASK_MANAGEMENT;\n\t\t\tlist_add_tail(&cmd->list, &vscsi->schedule_q);\n\t\t\tqueue_work(vscsi->work_q, &cmd->work);\n\t\t\tbreak;\n\n\t\tcase SRP_CMD:\n\t\t\tdev_dbg(&vscsi->dev, \"srp_cmd tag: %llu (0x%llx)\\n\",\n\t\t\t\tsrp->tag, srp->tag);\n\t\t\tcmd->rsp.tag = srp->tag;\n\t\t\tvscsi->debit += 1;\n\t\t\tcmd->type = SCSI_CDB;\n\t\t\t \n\t\t\tlist_add_tail(&cmd->list, &vscsi->schedule_q);\n\t\t\tqueue_work(vscsi->work_q, &cmd->work);\n\t\t\tbreak;\n\n\t\tcase SRP_I_LOGOUT:\n\t\t\trc = ibmvscsis_srp_i_logout(vscsi, cmd, crq);\n\t\t\tbreak;\n\n\t\tcase SRP_CRED_RSP:\n\t\tcase SRP_AER_RSP:\n\t\tdefault:\n\t\t\tibmvscsis_free_cmd_resources(vscsi, cmd);\n\t\t\tdev_err(&vscsi->dev, \"invalid srp cmd, opcode %d\\n\",\n\t\t\t\t(uint)srp->opcode);\n\t\t\tibmvscsis_post_disconnect(vscsi,\n\t\t\t\t\t\t  ERR_DISCONNECT_RECONNECT, 0);\n\t\t\tbreak;\n\t\t}\n\t} else if (srp->opcode == SRP_LOGIN_REQ && vscsi->state == CONNECTED) {\n\t\trc = ibmvscsis_srp_login(vscsi, cmd, crq);\n\t} else {\n\t\tibmvscsis_free_cmd_resources(vscsi, cmd);\n\t\tdev_err(&vscsi->dev, \"Invalid state %d to handle srp cmd\\n\",\n\t\t\tvscsi->state);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\n\t}\n}\n\n \nstatic long ibmvscsis_ping_response(struct scsi_info *vscsi)\n{\n\tstruct viosrp_crq *crq;\n\tu64 buffer[2] = { 0, 0 };\n\tlong rc;\n\n\tcrq = (struct viosrp_crq *)&buffer;\n\tcrq->valid = VALID_CMD_RESP_EL;\n\tcrq->format = (u8)MESSAGE_IN_CRQ;\n\tcrq->status = PING_RESPONSE;\n\n\trc = h_send_crq(vscsi->dds.unit_id, cpu_to_be64(buffer[MSG_HI]),\n\t\t\tcpu_to_be64(buffer[MSG_LOW]));\n\n\tswitch (rc) {\n\tcase H_SUCCESS:\n\t\tbreak;\n\tcase H_CLOSED:\n\t\tvscsi->flags |= CLIENT_FAILED;\n\t\tfallthrough;\n\tcase H_DROPPED:\n\t\tvscsi->flags |= RESPONSE_Q_DOWN;\n\t\tfallthrough;\n\tcase H_REMOTE_PARM:\n\t\tdev_err(&vscsi->dev, \"ping_response: h_send_crq failed, rc %ld\\n\",\n\t\t\trc);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&vscsi->dev, \"ping_response: h_send_crq returned unknown rc %ld\\n\",\n\t\t\trc);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT, 0);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nstatic long ibmvscsis_parse_command(struct scsi_info *vscsi,\n\t\t\t\t    struct viosrp_crq *crq)\n{\n\tlong rc = ADAPT_SUCCESS;\n\n\tswitch (crq->valid) {\n\tcase VALID_CMD_RESP_EL:\n\t\tswitch (crq->format) {\n\t\tcase OS400_FORMAT:\n\t\tcase AIX_FORMAT:\n\t\tcase LINUX_FORMAT:\n\t\tcase MAD_FORMAT:\n\t\t\tif (vscsi->flags & PROCESSING_MAD) {\n\t\t\t\trc = ERROR;\n\t\t\t\tdev_err(&vscsi->dev, \"parse_command: already processing mad\\n\");\n\t\t\t\tibmvscsis_post_disconnect(vscsi,\n\t\t\t\t\t\t       ERR_DISCONNECT_RECONNECT,\n\t\t\t\t\t\t       0);\n\t\t\t} else {\n\t\t\t\tvscsi->flags |= PROCESSING_MAD;\n\t\t\t\trc = ibmvscsis_mad(vscsi, crq);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SRP_FORMAT:\n\t\t\tibmvscsis_srp_cmd(vscsi, crq);\n\t\t\tbreak;\n\n\t\tcase MESSAGE_IN_CRQ:\n\t\t\tif (crq->status == PING)\n\t\t\t\tibmvscsis_ping_response(vscsi);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&vscsi->dev, \"parse_command: invalid format %d\\n\",\n\t\t\t\t(uint)crq->format);\n\t\t\tibmvscsis_post_disconnect(vscsi,\n\t\t\t\t\t\t  ERR_DISCONNECT_RECONNECT, 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase VALID_TRANS_EVENT:\n\t\trc = ibmvscsis_trans_event(vscsi, crq);\n\t\tbreak;\n\n\tcase VALID_INIT_MSG:\n\t\trc = ibmvscsis_init_msg(vscsi, crq);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&vscsi->dev, \"parse_command: invalid valid field %d\\n\",\n\t\t\t(uint)crq->valid);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\n\t\tbreak;\n\t}\n\n\t \n\trc = vscsi->flags & SCHEDULE_DISCONNECT;\n\n\treturn rc;\n}\n\nstatic int read_dma_window(struct scsi_info *vscsi)\n{\n\tstruct vio_dev *vdev = vscsi->dma_dev;\n\tconst __be32 *dma_window;\n\tconst __be32 *prop;\n\n\t \n\tdma_window = (const __be32 *)vio_get_attribute(vdev,\n\t\t\t\t\t\t       \"ibm,my-dma-window\",\n\t\t\t\t\t\t       NULL);\n\tif (!dma_window) {\n\t\tdev_err(&vscsi->dev, \"Couldn't find ibm,my-dma-window property\\n\");\n\t\treturn -1;\n\t}\n\n\tvscsi->dds.window[LOCAL].liobn = be32_to_cpu(*dma_window);\n\tdma_window++;\n\n\tprop = (const __be32 *)vio_get_attribute(vdev, \"ibm,#dma-address-cells\",\n\t\t\t\t\t\t NULL);\n\tif (!prop) {\n\t\tdev_warn(&vscsi->dev, \"Couldn't find ibm,#dma-address-cells property\\n\");\n\t\tdma_window++;\n\t} else {\n\t\tdma_window += be32_to_cpu(*prop);\n\t}\n\n\tprop = (const __be32 *)vio_get_attribute(vdev, \"ibm,#dma-size-cells\",\n\t\t\t\t\t\t NULL);\n\tif (!prop) {\n\t\tdev_warn(&vscsi->dev, \"Couldn't find ibm,#dma-size-cells property\\n\");\n\t\tdma_window++;\n\t} else {\n\t\tdma_window += be32_to_cpu(*prop);\n\t}\n\n\t \n\tvscsi->dds.window[REMOTE].liobn = be32_to_cpu(*dma_window);\n\n\treturn 0;\n}\n\nstatic struct ibmvscsis_tport *ibmvscsis_lookup_port(const char *name)\n{\n\tstruct ibmvscsis_tport *tport = NULL;\n\tstruct vio_dev *vdev;\n\tstruct scsi_info *vscsi;\n\n\tspin_lock_bh(&ibmvscsis_dev_lock);\n\tlist_for_each_entry(vscsi, &ibmvscsis_dev_list, list) {\n\t\tvdev = vscsi->dma_dev;\n\t\tif (!strcmp(dev_name(&vdev->dev), name)) {\n\t\t\ttport = &vscsi->tport;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&ibmvscsis_dev_lock);\n\n\treturn tport;\n}\n\n \nstatic void ibmvscsis_parse_cmd(struct scsi_info *vscsi,\n\t\t\t\tstruct ibmvscsis_cmd *cmd)\n{\n\tstruct iu_entry *iue = cmd->iue;\n\tstruct srp_cmd *srp = (struct srp_cmd *)iue->sbuf->buf;\n\tstruct ibmvscsis_nexus *nexus;\n\tu64 data_len = 0;\n\tenum dma_data_direction dir;\n\tint attr = 0;\n\n\tnexus = vscsi->tport.ibmv_nexus;\n\t \n\tif (srp->add_cdb_len & 0x03) {\n\t\tdev_err(&vscsi->dev, \"parse_cmd: reserved bits set in IU\\n\");\n\t\tspin_lock_bh(&vscsi->intr_lock);\n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\n\t\tibmvscsis_free_cmd_resources(vscsi, cmd);\n\t\tspin_unlock_bh(&vscsi->intr_lock);\n\t\treturn;\n\t}\n\n\tif (srp_get_desc_table(srp, &dir, &data_len)) {\n\t\tdev_err(&vscsi->dev, \"0x%llx: parsing SRP descriptor table failed.\\n\",\n\t\t\tsrp->tag);\n\t\tgoto fail;\n\t}\n\n\tcmd->rsp.sol_not = srp->sol_not;\n\n\tswitch (srp->task_attr) {\n\tcase SRP_SIMPLE_TASK:\n\t\tattr = TCM_SIMPLE_TAG;\n\t\tbreak;\n\tcase SRP_ORDERED_TASK:\n\t\tattr = TCM_ORDERED_TAG;\n\t\tbreak;\n\tcase SRP_HEAD_TASK:\n\t\tattr = TCM_HEAD_TAG;\n\t\tbreak;\n\tcase SRP_ACA_TASK:\n\t\tattr = TCM_ACA_TAG;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&vscsi->dev, \"Invalid task attribute %d\\n\",\n\t\t\tsrp->task_attr);\n\t\tgoto fail;\n\t}\n\n\tcmd->se_cmd.tag = be64_to_cpu(srp->tag);\n\n\tspin_lock_bh(&vscsi->intr_lock);\n\tlist_add_tail(&cmd->list, &vscsi->active_q);\n\tspin_unlock_bh(&vscsi->intr_lock);\n\n\tsrp->lun.scsi_lun[0] &= 0x3f;\n\n\ttarget_submit_cmd(&cmd->se_cmd, nexus->se_sess, srp->cdb,\n\t\t\t  cmd->sense_buf, scsilun_to_int(&srp->lun),\n\t\t\t  data_len, attr, dir, 0);\n\treturn;\n\nfail:\n\tspin_lock_bh(&vscsi->intr_lock);\n\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\n\tspin_unlock_bh(&vscsi->intr_lock);\n}\n\n \nstatic void ibmvscsis_parse_task(struct scsi_info *vscsi,\n\t\t\t\t struct ibmvscsis_cmd *cmd)\n{\n\tstruct iu_entry *iue = cmd->iue;\n\tstruct srp_tsk_mgmt *srp_tsk = &vio_iu(iue)->srp.tsk_mgmt;\n\tint tcm_type;\n\tu64 tag_to_abort = 0;\n\tint rc = 0;\n\tstruct ibmvscsis_nexus *nexus;\n\n\tnexus = vscsi->tport.ibmv_nexus;\n\n\tcmd->rsp.sol_not = srp_tsk->sol_not;\n\n\tswitch (srp_tsk->tsk_mgmt_func) {\n\tcase SRP_TSK_ABORT_TASK:\n\t\ttcm_type = TMR_ABORT_TASK;\n\t\ttag_to_abort = be64_to_cpu(srp_tsk->task_tag);\n\t\tbreak;\n\tcase SRP_TSK_ABORT_TASK_SET:\n\t\ttcm_type = TMR_ABORT_TASK_SET;\n\t\tbreak;\n\tcase SRP_TSK_CLEAR_TASK_SET:\n\t\ttcm_type = TMR_CLEAR_TASK_SET;\n\t\tbreak;\n\tcase SRP_TSK_LUN_RESET:\n\t\ttcm_type = TMR_LUN_RESET;\n\t\tbreak;\n\tcase SRP_TSK_CLEAR_ACA:\n\t\ttcm_type = TMR_CLEAR_ACA;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&vscsi->dev, \"unknown task mgmt func %d\\n\",\n\t\t\tsrp_tsk->tsk_mgmt_func);\n\t\tcmd->se_cmd.se_tmr_req->response =\n\t\t\tTMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\n\t\trc = -1;\n\t\tbreak;\n\t}\n\n\tif (!rc) {\n\t\tcmd->se_cmd.tag = be64_to_cpu(srp_tsk->tag);\n\n\t\tspin_lock_bh(&vscsi->intr_lock);\n\t\tlist_add_tail(&cmd->list, &vscsi->active_q);\n\t\tspin_unlock_bh(&vscsi->intr_lock);\n\n\t\tsrp_tsk->lun.scsi_lun[0] &= 0x3f;\n\n\t\tdev_dbg(&vscsi->dev, \"calling submit_tmr, func %d\\n\",\n\t\t\tsrp_tsk->tsk_mgmt_func);\n\t\trc = target_submit_tmr(&cmd->se_cmd, nexus->se_sess, NULL,\n\t\t\t\t       scsilun_to_int(&srp_tsk->lun), srp_tsk,\n\t\t\t\t       tcm_type, GFP_KERNEL, tag_to_abort, 0);\n\t\tif (rc) {\n\t\t\tdev_err(&vscsi->dev, \"target_submit_tmr failed, rc %d\\n\",\n\t\t\t\trc);\n\t\t\tspin_lock_bh(&vscsi->intr_lock);\n\t\t\tlist_del(&cmd->list);\n\t\t\tspin_unlock_bh(&vscsi->intr_lock);\n\t\t\tcmd->se_cmd.se_tmr_req->response =\n\t\t\t\tTMR_FUNCTION_REJECTED;\n\t\t}\n\t}\n\n\tif (rc)\n\t\ttransport_send_check_condition_and_sense(&cmd->se_cmd, 0, 0);\n}\n\nstatic void ibmvscsis_scheduler(struct work_struct *work)\n{\n\tstruct ibmvscsis_cmd *cmd = container_of(work, struct ibmvscsis_cmd,\n\t\t\t\t\t\t work);\n\tstruct scsi_info *vscsi = cmd->adapter;\n\n\tspin_lock_bh(&vscsi->intr_lock);\n\n\t \n\tlist_del(&cmd->list);\n\n\t \n\tif (vscsi->flags & (SCHEDULE_DISCONNECT | DISCONNECT_SCHEDULED)) {\n\t\tibmvscsis_free_cmd_resources(vscsi, cmd);\n\n\t\t \n\t\tif (list_empty(&vscsi->active_q) &&\n\t\t    list_empty(&vscsi->schedule_q) &&\n\t\t    (vscsi->flags & WAIT_FOR_IDLE)) {\n\t\t\tvscsi->flags &= ~WAIT_FOR_IDLE;\n\t\t\tcomplete(&vscsi->wait_idle);\n\t\t}\n\n\t\tspin_unlock_bh(&vscsi->intr_lock);\n\t\treturn;\n\t}\n\n\tspin_unlock_bh(&vscsi->intr_lock);\n\n\tswitch (cmd->type) {\n\tcase SCSI_CDB:\n\t\tibmvscsis_parse_cmd(vscsi, cmd);\n\t\tbreak;\n\tcase TASK_MANAGEMENT:\n\t\tibmvscsis_parse_task(vscsi, cmd);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&vscsi->dev, \"scheduler, invalid cmd type %d\\n\",\n\t\t\tcmd->type);\n\t\tspin_lock_bh(&vscsi->intr_lock);\n\t\tibmvscsis_free_cmd_resources(vscsi, cmd);\n\t\tspin_unlock_bh(&vscsi->intr_lock);\n\t\tbreak;\n\t}\n}\n\nstatic int ibmvscsis_alloc_cmds(struct scsi_info *vscsi, int num)\n{\n\tstruct ibmvscsis_cmd *cmd;\n\tint i;\n\n\tINIT_LIST_HEAD(&vscsi->free_cmd);\n\tvscsi->cmd_pool = kcalloc(num, sizeof(struct ibmvscsis_cmd),\n\t\t\t\t  GFP_KERNEL);\n\tif (!vscsi->cmd_pool)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, cmd = (struct ibmvscsis_cmd *)vscsi->cmd_pool; i < num;\n\t     i++, cmd++) {\n\t\tcmd->abort_cmd = NULL;\n\t\tcmd->adapter = vscsi;\n\t\tINIT_WORK(&cmd->work, ibmvscsis_scheduler);\n\t\tlist_add_tail(&cmd->list, &vscsi->free_cmd);\n\t}\n\n\treturn 0;\n}\n\nstatic void ibmvscsis_free_cmds(struct scsi_info *vscsi)\n{\n\tkfree(vscsi->cmd_pool);\n\tvscsi->cmd_pool = NULL;\n\tINIT_LIST_HEAD(&vscsi->free_cmd);\n}\n\n \nstatic enum hrtimer_restart ibmvscsis_service_wait_q(struct hrtimer *timer)\n{\n\tstruct timer_cb *p_timer = container_of(timer, struct timer_cb, timer);\n\tstruct scsi_info *vscsi = container_of(p_timer, struct scsi_info,\n\t\t\t\t\t       rsp_q_timer);\n\n\tspin_lock_bh(&vscsi->intr_lock);\n\tp_timer->timer_pops += 1;\n\tp_timer->started = false;\n\tibmvscsis_send_messages(vscsi);\n\tspin_unlock_bh(&vscsi->intr_lock);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic long ibmvscsis_alloctimer(struct scsi_info *vscsi)\n{\n\tstruct timer_cb *p_timer;\n\n\tp_timer = &vscsi->rsp_q_timer;\n\thrtimer_init(&p_timer->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\n\tp_timer->timer.function = ibmvscsis_service_wait_q;\n\tp_timer->started = false;\n\tp_timer->timer_pops = 0;\n\n\treturn ADAPT_SUCCESS;\n}\n\nstatic void ibmvscsis_freetimer(struct scsi_info *vscsi)\n{\n\tstruct timer_cb *p_timer;\n\n\tp_timer = &vscsi->rsp_q_timer;\n\n\t(void)hrtimer_cancel(&p_timer->timer);\n\n\tp_timer->started = false;\n\tp_timer->timer_pops = 0;\n}\n\nstatic irqreturn_t ibmvscsis_interrupt(int dummy, void *data)\n{\n\tstruct scsi_info *vscsi = data;\n\n\tvio_disable_interrupts(vscsi->dma_dev);\n\ttasklet_schedule(&vscsi->work_task);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic long ibmvscsis_enable_change_state(struct scsi_info *vscsi)\n{\n\tint bytes;\n\tlong rc = ADAPT_SUCCESS;\n\n\tbytes = vscsi->cmd_q.size * PAGE_SIZE;\n\trc = h_reg_crq(vscsi->dds.unit_id, vscsi->cmd_q.crq_token, bytes);\n\tif (rc == H_CLOSED || rc == H_SUCCESS) {\n\t\tvscsi->state = WAIT_CONNECTION;\n\t\trc = ibmvscsis_establish_new_q(vscsi);\n\t}\n\n\tif (rc != ADAPT_SUCCESS) {\n\t\tvscsi->state = ERR_DISCONNECTED;\n\t\tvscsi->flags |= RESPONSE_Q_DOWN;\n\t}\n\n\treturn rc;\n}\n\n \nstatic long ibmvscsis_create_command_q(struct scsi_info *vscsi, int num_cmds)\n{\n\tint pages;\n\tstruct vio_dev *vdev = vscsi->dma_dev;\n\n\t \n\tpages = 1;\n\n\tvscsi->cmd_q.size = pages;\n\n\tvscsi->cmd_q.base_addr =\n\t\t(struct viosrp_crq *)get_zeroed_page(GFP_KERNEL);\n\tif (!vscsi->cmd_q.base_addr)\n\t\treturn -ENOMEM;\n\n\tvscsi->cmd_q.mask = ((uint)pages * CRQ_PER_PAGE) - 1;\n\n\tvscsi->cmd_q.crq_token = dma_map_single(&vdev->dev,\n\t\t\t\t\t\tvscsi->cmd_q.base_addr,\n\t\t\t\t\t\tPAGE_SIZE, DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(&vdev->dev, vscsi->cmd_q.crq_token)) {\n\t\tfree_page((unsigned long)vscsi->cmd_q.base_addr);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ibmvscsis_destroy_command_q(struct scsi_info *vscsi)\n{\n\tdma_unmap_single(&vscsi->dma_dev->dev, vscsi->cmd_q.crq_token,\n\t\t\t PAGE_SIZE, DMA_BIDIRECTIONAL);\n\tfree_page((unsigned long)vscsi->cmd_q.base_addr);\n\tvscsi->cmd_q.base_addr = NULL;\n\tvscsi->state = NO_QUEUE;\n}\n\nstatic u8 ibmvscsis_fast_fail(struct scsi_info *vscsi,\n\t\t\t      struct ibmvscsis_cmd *cmd)\n{\n\tstruct iu_entry *iue = cmd->iue;\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tstruct srp_cmd *srp = (struct srp_cmd *)iue->sbuf->buf;\n\tstruct scsi_sense_hdr sshdr;\n\tu8 rc = se_cmd->scsi_status;\n\n\tif (vscsi->fast_fail && (READ_CMD(srp->cdb) || WRITE_CMD(srp->cdb)))\n\t\tif (scsi_normalize_sense(se_cmd->sense_buffer,\n\t\t\t\t\t se_cmd->scsi_sense_length, &sshdr))\n\t\t\tif (sshdr.sense_key == HARDWARE_ERROR &&\n\t\t\t    (se_cmd->residual_count == 0 ||\n\t\t\t     se_cmd->residual_count == se_cmd->data_length)) {\n\t\t\t\trc = NO_SENSE;\n\t\t\t\tcmd->flags |= CMD_FAST_FAIL;\n\t\t\t}\n\n\treturn rc;\n}\n\n \nstatic long srp_build_response(struct scsi_info *vscsi,\n\t\t\t       struct ibmvscsis_cmd *cmd, uint *len_p)\n{\n\tstruct iu_entry *iue = cmd->iue;\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tstruct srp_rsp *rsp;\n\tuint len;\n\tu32 rsp_code;\n\tchar *data;\n\tu32 *tsk_status;\n\tlong rc = ADAPT_SUCCESS;\n\n\tspin_lock_bh(&vscsi->intr_lock);\n\n\trsp = &vio_iu(iue)->srp.rsp;\n\tlen = sizeof(*rsp);\n\tmemset(rsp, 0, len);\n\tdata = rsp->data;\n\n\trsp->opcode = SRP_RSP;\n\n\trsp->req_lim_delta = cpu_to_be32(1 + vscsi->credit);\n\trsp->tag = cmd->rsp.tag;\n\trsp->flags = 0;\n\n\tif (cmd->type == SCSI_CDB) {\n\t\trsp->status = ibmvscsis_fast_fail(vscsi, cmd);\n\t\tif (rsp->status) {\n\t\t\tdev_dbg(&vscsi->dev, \"build_resp: cmd %p, scsi status %d\\n\",\n\t\t\t\tcmd, (int)rsp->status);\n\t\t\tibmvscsis_determine_resid(se_cmd, rsp);\n\t\t\tif (se_cmd->scsi_sense_length && se_cmd->sense_buffer) {\n\t\t\t\trsp->sense_data_len =\n\t\t\t\t\tcpu_to_be32(se_cmd->scsi_sense_length);\n\t\t\t\trsp->flags |= SRP_RSP_FLAG_SNSVALID;\n\t\t\t\tlen += se_cmd->scsi_sense_length;\n\t\t\t\tmemcpy(data, se_cmd->sense_buffer,\n\t\t\t\t       se_cmd->scsi_sense_length);\n\t\t\t}\n\t\t\trsp->sol_not = (cmd->rsp.sol_not & UCSOLNT) >>\n\t\t\t\tUCSOLNT_RESP_SHIFT;\n\t\t} else if (cmd->flags & CMD_FAST_FAIL) {\n\t\t\tdev_dbg(&vscsi->dev, \"build_resp: cmd %p, fast fail\\n\",\n\t\t\t\tcmd);\n\t\t\trsp->sol_not = (cmd->rsp.sol_not & UCSOLNT) >>\n\t\t\t\tUCSOLNT_RESP_SHIFT;\n\t\t} else {\n\t\t\trsp->sol_not = (cmd->rsp.sol_not & SCSOLNT) >>\n\t\t\t\tSCSOLNT_RESP_SHIFT;\n\t\t}\n\t} else {\n\t\t \n\t\trsp->status = 0;\n\t\trsp->resp_data_len = cpu_to_be32(4);\n\t\trsp->flags |= SRP_RSP_FLAG_RSPVALID;\n\n\t\tswitch (se_cmd->se_tmr_req->response) {\n\t\tcase TMR_FUNCTION_COMPLETE:\n\t\tcase TMR_TASK_DOES_NOT_EXIST:\n\t\t\trsp_code = SRP_TASK_MANAGEMENT_FUNCTION_COMPLETE;\n\t\t\trsp->sol_not = (cmd->rsp.sol_not & SCSOLNT) >>\n\t\t\t\tSCSOLNT_RESP_SHIFT;\n\t\t\tbreak;\n\t\tcase TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED:\n\t\tcase TMR_LUN_DOES_NOT_EXIST:\n\t\t\trsp_code = SRP_TASK_MANAGEMENT_FUNCTION_NOT_SUPPORTED;\n\t\t\trsp->sol_not = (cmd->rsp.sol_not & UCSOLNT) >>\n\t\t\t\tUCSOLNT_RESP_SHIFT;\n\t\t\tbreak;\n\t\tcase TMR_FUNCTION_FAILED:\n\t\tcase TMR_FUNCTION_REJECTED:\n\t\tdefault:\n\t\t\trsp_code = SRP_TASK_MANAGEMENT_FUNCTION_FAILED;\n\t\t\trsp->sol_not = (cmd->rsp.sol_not & UCSOLNT) >>\n\t\t\t\tUCSOLNT_RESP_SHIFT;\n\t\t\tbreak;\n\t\t}\n\n\t\ttsk_status = (u32 *)data;\n\t\t*tsk_status = cpu_to_be32(rsp_code);\n\t\tdata = (char *)(tsk_status + 1);\n\t\tlen += 4;\n\t}\n\n\tdma_wmb();\n\trc = h_copy_rdma(len, vscsi->dds.window[LOCAL].liobn, iue->sbuf->dma,\n\t\t\t vscsi->dds.window[REMOTE].liobn,\n\t\t\t be64_to_cpu(iue->remote_token));\n\n\tswitch (rc) {\n\tcase H_SUCCESS:\n\t\tvscsi->credit = 0;\n\t\t*len_p = len;\n\t\tbreak;\n\tcase H_PERMISSION:\n\t\tif (connection_broken(vscsi))\n\t\t\tvscsi->flags |= RESPONSE_Q_DOWN | CLIENT_FAILED;\n\n\t\tdev_err(&vscsi->dev, \"build_response: error copying to client, rc %ld, flags 0x%x, state 0x%hx\\n\",\n\t\t\trc, vscsi->flags, vscsi->state);\n\t\tbreak;\n\tcase H_SOURCE_PARM:\n\tcase H_DEST_PARM:\n\tdefault:\n\t\tdev_err(&vscsi->dev, \"build_response: error copying to client, rc %ld\\n\",\n\t\t\trc);\n\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&vscsi->intr_lock);\n\n\treturn rc;\n}\n\nstatic int ibmvscsis_rdma(struct ibmvscsis_cmd *cmd, struct scatterlist *sg,\n\t\t\t  int nsg, struct srp_direct_buf *md, int nmd,\n\t\t\t  enum dma_data_direction dir, unsigned int bytes)\n{\n\tstruct iu_entry *iue = cmd->iue;\n\tstruct srp_target *target = iue->target;\n\tstruct scsi_info *vscsi = target->ldata;\n\tstruct scatterlist *sgp;\n\tdma_addr_t client_ioba, server_ioba;\n\tulong buf_len;\n\tulong client_len, server_len;\n\tint md_idx;\n\tlong tx_len;\n\tlong rc = 0;\n\n\tif (bytes == 0)\n\t\treturn 0;\n\n\tsgp = sg;\n\tclient_len = 0;\n\tserver_len = 0;\n\tmd_idx = 0;\n\ttx_len = bytes;\n\n\tdo {\n\t\tif (client_len == 0) {\n\t\t\tif (md_idx >= nmd) {\n\t\t\t\tdev_err(&vscsi->dev, \"rdma: ran out of client memory descriptors\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tclient_ioba = be64_to_cpu(md[md_idx].va);\n\t\t\tclient_len = be32_to_cpu(md[md_idx].len);\n\t\t}\n\t\tif (server_len == 0) {\n\t\t\tif (!sgp) {\n\t\t\t\tdev_err(&vscsi->dev, \"rdma: ran out of scatter/gather list\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tserver_ioba = sg_dma_address(sgp);\n\t\t\tserver_len = sg_dma_len(sgp);\n\t\t}\n\n\t\tbuf_len = tx_len;\n\n\t\tif (buf_len > client_len)\n\t\t\tbuf_len = client_len;\n\n\t\tif (buf_len > server_len)\n\t\t\tbuf_len = server_len;\n\n\t\tif (buf_len > max_vdma_size)\n\t\t\tbuf_len = max_vdma_size;\n\n\t\tif (dir == DMA_TO_DEVICE) {\n\t\t\t \n\t\t\trc = h_copy_rdma(buf_len,\n\t\t\t\t\t vscsi->dds.window[REMOTE].liobn,\n\t\t\t\t\t client_ioba,\n\t\t\t\t\t vscsi->dds.window[LOCAL].liobn,\n\t\t\t\t\t server_ioba);\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tisync();\n\t\t\t \n\t\t\tdma_wmb();\n\t\t\trc = h_copy_rdma(buf_len,\n\t\t\t\t\t vscsi->dds.window[LOCAL].liobn,\n\t\t\t\t\t server_ioba,\n\t\t\t\t\t vscsi->dds.window[REMOTE].liobn,\n\t\t\t\t\t client_ioba);\n\t\t}\n\t\tswitch (rc) {\n\t\tcase H_SUCCESS:\n\t\t\tbreak;\n\t\tcase H_PERMISSION:\n\t\tcase H_SOURCE_PARM:\n\t\tcase H_DEST_PARM:\n\t\t\tif (connection_broken(vscsi)) {\n\t\t\t\tspin_lock_bh(&vscsi->intr_lock);\n\t\t\t\tvscsi->flags |=\n\t\t\t\t\t(RESPONSE_Q_DOWN | CLIENT_FAILED);\n\t\t\t\tspin_unlock_bh(&vscsi->intr_lock);\n\t\t\t}\n\t\t\tdev_err(&vscsi->dev, \"rdma: h_copy_rdma failed, rc %ld\\n\",\n\t\t\t\trc);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&vscsi->dev, \"rdma: unknown error %ld from h_copy_rdma\\n\",\n\t\t\t\trc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rc) {\n\t\t\ttx_len -= buf_len;\n\t\t\tif (tx_len) {\n\t\t\t\tclient_len -= buf_len;\n\t\t\t\tif (client_len == 0)\n\t\t\t\t\tmd_idx++;\n\t\t\t\telse\n\t\t\t\t\tclient_ioba += buf_len;\n\n\t\t\t\tserver_len -= buf_len;\n\t\t\t\tif (server_len == 0)\n\t\t\t\t\tsgp = sg_next(sgp);\n\t\t\t\telse\n\t\t\t\t\tserver_ioba += buf_len;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (!rc);\n\n\treturn rc;\n}\n\n \nstatic void ibmvscsis_handle_crq(unsigned long data)\n{\n\tstruct scsi_info *vscsi = (struct scsi_info *)data;\n\tstruct viosrp_crq *crq;\n\tlong rc;\n\tbool ack = true;\n\tvolatile u8 valid;\n\n\tspin_lock_bh(&vscsi->intr_lock);\n\n\tdev_dbg(&vscsi->dev, \"got interrupt\\n\");\n\n\t \n\tif (TARGET_STOP(vscsi)) {\n\t\tvio_enable_interrupts(vscsi->dma_dev);\n\n\t\tdev_dbg(&vscsi->dev, \"handle_crq, don't process: flags 0x%x, state 0x%hx\\n\",\n\t\t\tvscsi->flags, vscsi->state);\n\t\tspin_unlock_bh(&vscsi->intr_lock);\n\t\treturn;\n\t}\n\n\trc = vscsi->flags & SCHEDULE_DISCONNECT;\n\tcrq = vscsi->cmd_q.base_addr + vscsi->cmd_q.index;\n\tvalid = crq->valid;\n\tdma_rmb();\n\n\twhile (valid) {\n\t\t \ncmd_work:\n\t\tvscsi->cmd_q.index =\n\t\t\t(vscsi->cmd_q.index + 1) & vscsi->cmd_q.mask;\n\n\t\tif (!rc) {\n\t\t\trc = ibmvscsis_parse_command(vscsi, crq);\n\t\t} else {\n\t\t\tif ((uint)crq->valid == VALID_TRANS_EVENT) {\n\t\t\t\t \n\t\t\t\trc = ibmvscsis_trans_event(vscsi, crq);\n\t\t\t} else if (vscsi->flags & TRANS_EVENT) {\n\t\t\t\t \n\t\t\t\tif (vscsi->cmd_q.index)\n\t\t\t\t\tvscsi->cmd_q.index -= 1;\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\tvscsi->cmd_q.index = vscsi->cmd_q.mask;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcrq->valid = INVALIDATE_CMD_RESP_EL;\n\n\t\tcrq = vscsi->cmd_q.base_addr + vscsi->cmd_q.index;\n\t\tvalid = crq->valid;\n\t\tdma_rmb();\n\t}\n\n\tif (!rc) {\n\t\tif (ack) {\n\t\t\tvio_enable_interrupts(vscsi->dma_dev);\n\t\t\tack = false;\n\t\t\tdev_dbg(&vscsi->dev, \"handle_crq, reenabling interrupts\\n\");\n\t\t}\n\t\tvalid = crq->valid;\n\t\tdma_rmb();\n\t\tif (valid)\n\t\t\tgoto cmd_work;\n\t} else {\n\t\tdev_dbg(&vscsi->dev, \"handle_crq, error: flags 0x%x, state 0x%hx, crq index 0x%x\\n\",\n\t\t\tvscsi->flags, vscsi->state, vscsi->cmd_q.index);\n\t}\n\n\tdev_dbg(&vscsi->dev, \"Leaving handle_crq: schedule_q empty %d, flags 0x%x, state 0x%hx\\n\",\n\t\t(int)list_empty(&vscsi->schedule_q), vscsi->flags,\n\t\tvscsi->state);\n\n\tspin_unlock_bh(&vscsi->intr_lock);\n}\n\nstatic int ibmvscsis_probe(struct vio_dev *vdev,\n\t\t\t   const struct vio_device_id *id)\n{\n\tstruct scsi_info *vscsi;\n\tint rc = 0;\n\tlong hrc = 0;\n\tchar wq_name[24];\n\n\tvscsi = kzalloc(sizeof(*vscsi), GFP_KERNEL);\n\tif (!vscsi) {\n\t\trc = -ENOMEM;\n\t\tdev_err(&vdev->dev, \"probe: allocation of adapter failed\\n\");\n\t\treturn rc;\n\t}\n\n\tvscsi->dma_dev = vdev;\n\tvscsi->dev = vdev->dev;\n\tINIT_LIST_HEAD(&vscsi->schedule_q);\n\tINIT_LIST_HEAD(&vscsi->waiting_rsp);\n\tINIT_LIST_HEAD(&vscsi->active_q);\n\n\tsnprintf(vscsi->tport.tport_name, IBMVSCSIS_NAMELEN, \"%s\",\n\t\t dev_name(&vdev->dev));\n\n\tdev_dbg(&vscsi->dev, \"probe tport_name: %s\\n\", vscsi->tport.tport_name);\n\n\trc = read_dma_window(vscsi);\n\tif (rc)\n\t\tgoto free_adapter;\n\tdev_dbg(&vscsi->dev, \"Probe: liobn 0x%x, riobn 0x%x\\n\",\n\t\tvscsi->dds.window[LOCAL].liobn,\n\t\tvscsi->dds.window[REMOTE].liobn);\n\n\tsnprintf(vscsi->eye, sizeof(vscsi->eye), \"VSCSI %s\", vdev->name);\n\n\tvscsi->dds.unit_id = vdev->unit_address;\n\tstrscpy(vscsi->dds.partition_name, partition_name,\n\t\tsizeof(vscsi->dds.partition_name));\n\tvscsi->dds.partition_num = partition_number;\n\n\tspin_lock_bh(&ibmvscsis_dev_lock);\n\tlist_add_tail(&vscsi->list, &ibmvscsis_dev_list);\n\tspin_unlock_bh(&ibmvscsis_dev_lock);\n\n\t \n\tvscsi->request_limit = INITIAL_SRP_LIMIT;\n\trc = srp_target_alloc(&vscsi->target, &vdev->dev, vscsi->request_limit,\n\t\t\t      SRP_MAX_IU_LEN);\n\tif (rc)\n\t\tgoto rem_list;\n\n\tvscsi->target.ldata = vscsi;\n\n\trc = ibmvscsis_alloc_cmds(vscsi, vscsi->request_limit);\n\tif (rc) {\n\t\tdev_err(&vscsi->dev, \"alloc_cmds failed, rc %d, num %d\\n\",\n\t\t\trc, vscsi->request_limit);\n\t\tgoto free_target;\n\t}\n\n\t \n\tspin_lock_init(&vscsi->intr_lock);\n\n\trc = ibmvscsis_alloctimer(vscsi);\n\tif (rc) {\n\t\tdev_err(&vscsi->dev, \"probe: alloctimer failed, rc %d\\n\", rc);\n\t\tgoto free_cmds;\n\t}\n\n\trc = ibmvscsis_create_command_q(vscsi, 256);\n\tif (rc) {\n\t\tdev_err(&vscsi->dev, \"probe: create_command_q failed, rc %d\\n\",\n\t\t\trc);\n\t\tgoto free_timer;\n\t}\n\n\tvscsi->map_buf = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!vscsi->map_buf) {\n\t\trc = -ENOMEM;\n\t\tdev_err(&vscsi->dev, \"probe: allocating cmd buffer failed\\n\");\n\t\tgoto destroy_queue;\n\t}\n\n\tvscsi->map_ioba = dma_map_single(&vdev->dev, vscsi->map_buf, PAGE_SIZE,\n\t\t\t\t\t DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(&vdev->dev, vscsi->map_ioba)) {\n\t\trc = -ENOMEM;\n\t\tdev_err(&vscsi->dev, \"probe: error mapping command buffer\\n\");\n\t\tgoto free_buf;\n\t}\n\n\thrc = h_vioctl(vscsi->dds.unit_id, H_GET_PARTNER_INFO,\n\t\t       (u64)vscsi->map_ioba | ((u64)PAGE_SIZE << 32), 0, 0, 0,\n\t\t       0);\n\tif (hrc == H_SUCCESS)\n\t\tvscsi->client_data.partition_number =\n\t\t\tbe64_to_cpu(*(u64 *)vscsi->map_buf);\n\t \n\tdev_dbg(&vscsi->dev, \"probe hrc %ld, client partition num %d\\n\",\n\t\thrc, vscsi->client_data.partition_number);\n\n\ttasklet_init(&vscsi->work_task, ibmvscsis_handle_crq,\n\t\t     (unsigned long)vscsi);\n\n\tinit_completion(&vscsi->wait_idle);\n\tinit_completion(&vscsi->unconfig);\n\n\tsnprintf(wq_name, 24, \"ibmvscsis%s\", dev_name(&vdev->dev));\n\tvscsi->work_q = create_workqueue(wq_name);\n\tif (!vscsi->work_q) {\n\t\trc = -ENOMEM;\n\t\tdev_err(&vscsi->dev, \"create_workqueue failed\\n\");\n\t\tgoto unmap_buf;\n\t}\n\n\trc = request_irq(vdev->irq, ibmvscsis_interrupt, 0, \"ibmvscsis\", vscsi);\n\tif (rc) {\n\t\trc = -EPERM;\n\t\tdev_err(&vscsi->dev, \"probe: request_irq failed, rc %d\\n\", rc);\n\t\tgoto destroy_WQ;\n\t}\n\n\tvscsi->state = WAIT_ENABLED;\n\n\tdev_set_drvdata(&vdev->dev, vscsi);\n\n\treturn 0;\n\ndestroy_WQ:\n\tdestroy_workqueue(vscsi->work_q);\nunmap_buf:\n\tdma_unmap_single(&vdev->dev, vscsi->map_ioba, PAGE_SIZE,\n\t\t\t DMA_BIDIRECTIONAL);\nfree_buf:\n\tkfree(vscsi->map_buf);\ndestroy_queue:\n\ttasklet_kill(&vscsi->work_task);\n\tibmvscsis_unregister_command_q(vscsi);\n\tibmvscsis_destroy_command_q(vscsi);\nfree_timer:\n\tibmvscsis_freetimer(vscsi);\nfree_cmds:\n\tibmvscsis_free_cmds(vscsi);\nfree_target:\n\tsrp_target_free(&vscsi->target);\nrem_list:\n\tspin_lock_bh(&ibmvscsis_dev_lock);\n\tlist_del(&vscsi->list);\n\tspin_unlock_bh(&ibmvscsis_dev_lock);\nfree_adapter:\n\tkfree(vscsi);\n\n\treturn rc;\n}\n\nstatic void ibmvscsis_remove(struct vio_dev *vdev)\n{\n\tstruct scsi_info *vscsi = dev_get_drvdata(&vdev->dev);\n\n\tdev_dbg(&vscsi->dev, \"remove (%s)\\n\", dev_name(&vscsi->dma_dev->dev));\n\n\tspin_lock_bh(&vscsi->intr_lock);\n\tibmvscsis_post_disconnect(vscsi, UNCONFIGURING, 0);\n\tvscsi->flags |= CFG_SLEEPING;\n\tspin_unlock_bh(&vscsi->intr_lock);\n\twait_for_completion(&vscsi->unconfig);\n\n\tvio_disable_interrupts(vdev);\n\tfree_irq(vdev->irq, vscsi);\n\tdestroy_workqueue(vscsi->work_q);\n\tdma_unmap_single(&vdev->dev, vscsi->map_ioba, PAGE_SIZE,\n\t\t\t DMA_BIDIRECTIONAL);\n\tkfree(vscsi->map_buf);\n\ttasklet_kill(&vscsi->work_task);\n\tibmvscsis_destroy_command_q(vscsi);\n\tibmvscsis_freetimer(vscsi);\n\tibmvscsis_free_cmds(vscsi);\n\tsrp_target_free(&vscsi->target);\n\tspin_lock_bh(&ibmvscsis_dev_lock);\n\tlist_del(&vscsi->list);\n\tspin_unlock_bh(&ibmvscsis_dev_lock);\n\tkfree(vscsi);\n}\n\nstatic ssize_t system_id_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", system_id);\n}\n\nstatic ssize_t partition_number_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%x\\n\", partition_number);\n}\n\nstatic ssize_t unit_address_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_info *vscsi = container_of(dev, struct scsi_info, dev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%x\\n\", vscsi->dma_dev->unit_address);\n}\n\nstatic int ibmvscsis_get_system_info(void)\n{\n\tstruct device_node *rootdn, *vdevdn;\n\tconst char *id, *model, *name;\n\tconst uint *num;\n\n\trootdn = of_find_node_by_path(\"/\");\n\tif (!rootdn)\n\t\treturn -ENOENT;\n\n\tmodel = of_get_property(rootdn, \"model\", NULL);\n\tid = of_get_property(rootdn, \"system-id\", NULL);\n\tif (model && id)\n\t\tsnprintf(system_id, sizeof(system_id), \"%s-%s\", model, id);\n\n\tname = of_get_property(rootdn, \"ibm,partition-name\", NULL);\n\tif (name)\n\t\tstrncpy(partition_name, name, sizeof(partition_name));\n\n\tnum = of_get_property(rootdn, \"ibm,partition-no\", NULL);\n\tif (num)\n\t\tpartition_number = of_read_number(num, 1);\n\n\tof_node_put(rootdn);\n\n\tvdevdn = of_find_node_by_path(\"/vdevice\");\n\tif (vdevdn) {\n\t\tconst uint *mvds;\n\n\t\tmvds = of_get_property(vdevdn, \"ibm,max-virtual-dma-size\",\n\t\t\t\t       NULL);\n\t\tif (mvds)\n\t\t\tmax_vdma_size = *mvds;\n\t\tof_node_put(vdevdn);\n\t}\n\n\treturn 0;\n}\n\nstatic char *ibmvscsis_get_fabric_wwn(struct se_portal_group *se_tpg)\n{\n\tstruct ibmvscsis_tport *tport =\n\t\tcontainer_of(se_tpg, struct ibmvscsis_tport, se_tpg);\n\n\treturn tport->tport_name;\n}\n\nstatic u16 ibmvscsis_get_tag(struct se_portal_group *se_tpg)\n{\n\tstruct ibmvscsis_tport *tport =\n\t\tcontainer_of(se_tpg, struct ibmvscsis_tport, se_tpg);\n\n\treturn tport->tport_tpgt;\n}\n\nstatic u32 ibmvscsis_get_default_depth(struct se_portal_group *se_tpg)\n{\n\treturn 1;\n}\n\nstatic int ibmvscsis_check_true(struct se_portal_group *se_tpg)\n{\n\treturn 1;\n}\n\nstatic int ibmvscsis_check_stop_free(struct se_cmd *se_cmd)\n{\n\treturn target_put_sess_cmd(se_cmd);\n}\n\nstatic void ibmvscsis_release_cmd(struct se_cmd *se_cmd)\n{\n\tstruct ibmvscsis_cmd *cmd = container_of(se_cmd, struct ibmvscsis_cmd,\n\t\t\t\t\t\t se_cmd);\n\tstruct scsi_info *vscsi = cmd->adapter;\n\n\tspin_lock_bh(&vscsi->intr_lock);\n\t \n\tlist_move_tail(&cmd->list, &vscsi->waiting_rsp);\n\tibmvscsis_send_messages(vscsi);\n\tspin_unlock_bh(&vscsi->intr_lock);\n}\n\nstatic int ibmvscsis_write_pending(struct se_cmd *se_cmd)\n{\n\tstruct ibmvscsis_cmd *cmd = container_of(se_cmd, struct ibmvscsis_cmd,\n\t\t\t\t\t\t se_cmd);\n\tstruct scsi_info *vscsi = cmd->adapter;\n\tstruct iu_entry *iue = cmd->iue;\n\tint rc;\n\n\t \n\tif ((vscsi->flags & (CLIENT_FAILED | RESPONSE_Q_DOWN))) {\n\t\tdev_err(&vscsi->dev, \"write_pending failed since: %d\\n\",\n\t\t\tvscsi->flags);\n\t\treturn -EIO;\n\n\t}\n\n\trc = srp_transfer_data(cmd, &vio_iu(iue)->srp.cmd, ibmvscsis_rdma,\n\t\t\t       1, 1);\n\tif (rc) {\n\t\tdev_err(&vscsi->dev, \"srp_transfer_data() failed: %d\\n\", rc);\n\t\treturn -EIO;\n\t}\n\t \n\ttarget_execute_cmd(se_cmd);\n\treturn 0;\n}\n\nstatic int ibmvscsis_queue_data_in(struct se_cmd *se_cmd)\n{\n\tstruct ibmvscsis_cmd *cmd = container_of(se_cmd, struct ibmvscsis_cmd,\n\t\t\t\t\t\t se_cmd);\n\tstruct iu_entry *iue = cmd->iue;\n\tstruct scsi_info *vscsi = cmd->adapter;\n\tuint len = 0;\n\tint rc;\n\n\trc = srp_transfer_data(cmd, &vio_iu(iue)->srp.cmd, ibmvscsis_rdma, 1,\n\t\t\t       1);\n\tif (rc) {\n\t\tdev_err(&vscsi->dev, \"srp_transfer_data failed: %d\\n\", rc);\n\t\tse_cmd->scsi_sense_length = 18;\n\t\tmemset(se_cmd->sense_buffer, 0, se_cmd->scsi_sense_length);\n\t\t \n\t\tscsi_build_sense_buffer(0, se_cmd->sense_buffer, MEDIUM_ERROR,\n\t\t\t\t\t0x08, 0x01);\n\t}\n\n\tsrp_build_response(vscsi, cmd, &len);\n\tcmd->rsp.format = SRP_FORMAT;\n\tcmd->rsp.len = len;\n\n\treturn 0;\n}\n\nstatic int ibmvscsis_queue_status(struct se_cmd *se_cmd)\n{\n\tstruct ibmvscsis_cmd *cmd = container_of(se_cmd, struct ibmvscsis_cmd,\n\t\t\t\t\t\t se_cmd);\n\tstruct scsi_info *vscsi = cmd->adapter;\n\tuint len;\n\n\tdev_dbg(&vscsi->dev, \"queue_status %p\\n\", se_cmd);\n\n\tsrp_build_response(vscsi, cmd, &len);\n\tcmd->rsp.format = SRP_FORMAT;\n\tcmd->rsp.len = len;\n\n\treturn 0;\n}\n\nstatic void ibmvscsis_queue_tm_rsp(struct se_cmd *se_cmd)\n{\n\tstruct ibmvscsis_cmd *cmd = container_of(se_cmd, struct ibmvscsis_cmd,\n\t\t\t\t\t\t se_cmd);\n\tstruct scsi_info *vscsi = cmd->adapter;\n\tstruct ibmvscsis_cmd *cmd_itr;\n\tstruct iu_entry *iue = iue = cmd->iue;\n\tstruct srp_tsk_mgmt *srp_tsk = &vio_iu(iue)->srp.tsk_mgmt;\n\tu64 tag_to_abort = be64_to_cpu(srp_tsk->task_tag);\n\tuint len;\n\n\tdev_dbg(&vscsi->dev, \"queue_tm_rsp %p, status %d\\n\",\n\t\tse_cmd, (int)se_cmd->se_tmr_req->response);\n\n\tif (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK &&\n\t    cmd->se_cmd.se_tmr_req->response == TMR_TASK_DOES_NOT_EXIST) {\n\t\tspin_lock_bh(&vscsi->intr_lock);\n\t\tlist_for_each_entry(cmd_itr, &vscsi->active_q, list) {\n\t\t\tif (tag_to_abort == cmd_itr->se_cmd.tag) {\n\t\t\t\tcmd_itr->abort_cmd = cmd;\n\t\t\t\tcmd->flags |= DELAY_SEND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&vscsi->intr_lock);\n\t}\n\n\tsrp_build_response(vscsi, cmd, &len);\n\tcmd->rsp.format = SRP_FORMAT;\n\tcmd->rsp.len = len;\n}\n\nstatic void ibmvscsis_aborted_task(struct se_cmd *se_cmd)\n{\n\tstruct ibmvscsis_cmd *cmd = container_of(se_cmd, struct ibmvscsis_cmd,\n\t\t\t\t\t\t se_cmd);\n\tstruct scsi_info *vscsi = cmd->adapter;\n\n\tdev_dbg(&vscsi->dev, \"ibmvscsis_aborted_task %p task_tag: %llu\\n\",\n\t\tse_cmd, se_cmd->tag);\n}\n\nstatic struct se_wwn *ibmvscsis_make_tport(struct target_fabric_configfs *tf,\n\t\t\t\t\t   struct config_group *group,\n\t\t\t\t\t   const char *name)\n{\n\tstruct ibmvscsis_tport *tport;\n\tstruct scsi_info *vscsi;\n\n\ttport = ibmvscsis_lookup_port(name);\n\tif (tport) {\n\t\tvscsi = container_of(tport, struct scsi_info, tport);\n\t\ttport->tport_proto_id = SCSI_PROTOCOL_SRP;\n\t\tdev_dbg(&vscsi->dev, \"make_tport(%s), pointer:%p, tport_id:%x\\n\",\n\t\t\tname, tport, tport->tport_proto_id);\n\t\treturn &tport->tport_wwn;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic void ibmvscsis_drop_tport(struct se_wwn *wwn)\n{\n\tstruct ibmvscsis_tport *tport = container_of(wwn,\n\t\t\t\t\t\t     struct ibmvscsis_tport,\n\t\t\t\t\t\t     tport_wwn);\n\tstruct scsi_info *vscsi = container_of(tport, struct scsi_info, tport);\n\n\tdev_dbg(&vscsi->dev, \"drop_tport(%s)\\n\",\n\t\tconfig_item_name(&tport->tport_wwn.wwn_group.cg_item));\n}\n\nstatic struct se_portal_group *ibmvscsis_make_tpg(struct se_wwn *wwn,\n\t\t\t\t\t\t  const char *name)\n{\n\tstruct ibmvscsis_tport *tport =\n\t\tcontainer_of(wwn, struct ibmvscsis_tport, tport_wwn);\n\tu16 tpgt;\n\tint rc;\n\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\trc = kstrtou16(name + 5, 0, &tpgt);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\ttport->tport_tpgt = tpgt;\n\n\ttport->releasing = false;\n\n\trc = core_tpg_register(&tport->tport_wwn, &tport->se_tpg,\n\t\t\t       tport->tport_proto_id);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\n\treturn &tport->se_tpg;\n}\n\nstatic void ibmvscsis_drop_tpg(struct se_portal_group *se_tpg)\n{\n\tstruct ibmvscsis_tport *tport = container_of(se_tpg,\n\t\t\t\t\t\t     struct ibmvscsis_tport,\n\t\t\t\t\t\t     se_tpg);\n\n\ttport->releasing = true;\n\ttport->enabled = false;\n\n\t \n\tibmvscsis_drop_nexus(tport);\n\t \n\tcore_tpg_deregister(se_tpg);\n}\n\nstatic ssize_t ibmvscsis_wwn_version_show(struct config_item *item,\n\t\t\t\t\t  char *page)\n{\n\treturn scnprintf(page, PAGE_SIZE, \"%s\\n\", IBMVSCSIS_VERSION);\n}\nCONFIGFS_ATTR_RO(ibmvscsis_wwn_, version);\n\nstatic struct configfs_attribute *ibmvscsis_wwn_attrs[] = {\n\t&ibmvscsis_wwn_attr_version,\n\tNULL,\n};\n\n\nstatic int ibmvscsis_enable_tpg(struct se_portal_group *se_tpg, bool enable)\n{\n\tstruct ibmvscsis_tport *tport = container_of(se_tpg,\n\t\t\t\t\t\t     struct ibmvscsis_tport,\n\t\t\t\t\t\t     se_tpg);\n\tstruct scsi_info *vscsi = container_of(tport, struct scsi_info, tport);\n\tlong lrc;\n\n\tif (enable) {\n\t\tspin_lock_bh(&vscsi->intr_lock);\n\t\ttport->enabled = true;\n\t\tlrc = ibmvscsis_enable_change_state(vscsi);\n\t\tif (lrc)\n\t\t\tdev_err(&vscsi->dev, \"enable_change_state failed, rc %ld state %d\\n\",\n\t\t\t\tlrc, vscsi->state);\n\t\tspin_unlock_bh(&vscsi->intr_lock);\n\t} else {\n\t\tspin_lock_bh(&vscsi->intr_lock);\n\t\ttport->enabled = false;\n\t\t \n\t\tibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT, 0);\n\t\tspin_unlock_bh(&vscsi->intr_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct target_core_fabric_ops ibmvscsis_ops = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.fabric_name\t\t\t= \"ibmvscsis\",\n\t.max_data_sg_nents\t\t= MAX_TXU / PAGE_SIZE,\n\t.tpg_get_wwn\t\t\t= ibmvscsis_get_fabric_wwn,\n\t.tpg_get_tag\t\t\t= ibmvscsis_get_tag,\n\t.tpg_get_default_depth\t\t= ibmvscsis_get_default_depth,\n\t.tpg_check_demo_mode\t\t= ibmvscsis_check_true,\n\t.tpg_check_demo_mode_cache\t= ibmvscsis_check_true,\n\t.check_stop_free\t\t= ibmvscsis_check_stop_free,\n\t.release_cmd\t\t\t= ibmvscsis_release_cmd,\n\t.write_pending\t\t\t= ibmvscsis_write_pending,\n\t.queue_data_in\t\t\t= ibmvscsis_queue_data_in,\n\t.queue_status\t\t\t= ibmvscsis_queue_status,\n\t.queue_tm_rsp\t\t\t= ibmvscsis_queue_tm_rsp,\n\t.aborted_task\t\t\t= ibmvscsis_aborted_task,\n\t \n\t.fabric_make_wwn\t\t= ibmvscsis_make_tport,\n\t.fabric_drop_wwn\t\t= ibmvscsis_drop_tport,\n\t.fabric_make_tpg\t\t= ibmvscsis_make_tpg,\n\t.fabric_enable_tpg\t\t= ibmvscsis_enable_tpg,\n\t.fabric_drop_tpg\t\t= ibmvscsis_drop_tpg,\n\n\t.tfc_wwn_attrs\t\t\t= ibmvscsis_wwn_attrs,\n};\n\nstatic void ibmvscsis_dev_release(struct device *dev) {};\n\nstatic struct device_attribute dev_attr_system_id =\n\t__ATTR(system_id, S_IRUGO, system_id_show, NULL);\n\nstatic struct device_attribute dev_attr_partition_number =\n\t__ATTR(partition_number, S_IRUGO, partition_number_show, NULL);\n\nstatic struct device_attribute dev_attr_unit_address =\n\t__ATTR(unit_address, S_IRUGO, unit_address_show, NULL);\n\nstatic struct attribute *ibmvscsis_dev_attrs[] = {\n\t&dev_attr_system_id.attr,\n\t&dev_attr_partition_number.attr,\n\t&dev_attr_unit_address.attr,\n};\nATTRIBUTE_GROUPS(ibmvscsis_dev);\n\nstatic struct class ibmvscsis_class = {\n\t.name\t\t= \"ibmvscsis\",\n\t.dev_release\t= ibmvscsis_dev_release,\n\t.dev_groups\t= ibmvscsis_dev_groups,\n};\n\nstatic const struct vio_device_id ibmvscsis_device_table[] = {\n\t{ \"v-scsi-host\", \"IBM,v-scsi-host\" },\n\t{ \"\", \"\" }\n};\nMODULE_DEVICE_TABLE(vio, ibmvscsis_device_table);\n\nstatic struct vio_driver ibmvscsis_driver = {\n\t.name = \"ibmvscsis\",\n\t.id_table = ibmvscsis_device_table,\n\t.probe = ibmvscsis_probe,\n\t.remove = ibmvscsis_remove,\n};\n\n \nstatic int __init ibmvscsis_init(void)\n{\n\tint rc = 0;\n\n\trc = ibmvscsis_get_system_info();\n\tif (rc) {\n\t\tpr_err(\"rc %d from get_system_info\\n\", rc);\n\t\tgoto out;\n\t}\n\n\trc = class_register(&ibmvscsis_class);\n\tif (rc) {\n\t\tpr_err(\"failed class register\\n\");\n\t\tgoto out;\n\t}\n\n\trc = target_register_template(&ibmvscsis_ops);\n\tif (rc) {\n\t\tpr_err(\"rc %d from target_register_template\\n\", rc);\n\t\tgoto unregister_class;\n\t}\n\n\trc = vio_register_driver(&ibmvscsis_driver);\n\tif (rc) {\n\t\tpr_err(\"rc %d from vio_register_driver\\n\", rc);\n\t\tgoto unregister_target;\n\t}\n\n\treturn 0;\n\nunregister_target:\n\ttarget_unregister_template(&ibmvscsis_ops);\nunregister_class:\n\tclass_unregister(&ibmvscsis_class);\nout:\n\treturn rc;\n}\n\nstatic void __exit ibmvscsis_exit(void)\n{\n\tpr_info(\"Unregister IBM virtual SCSI host driver\\n\");\n\tvio_unregister_driver(&ibmvscsis_driver);\n\ttarget_unregister_template(&ibmvscsis_ops);\n\tclass_unregister(&ibmvscsis_class);\n}\n\nMODULE_DESCRIPTION(\"IBMVSCSIS fabric driver\");\nMODULE_AUTHOR(\"Bryant G. Ly and Michael Cyr\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(IBMVSCSIS_VERSION);\nmodule_init(ibmvscsis_init);\nmodule_exit(ibmvscsis_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}