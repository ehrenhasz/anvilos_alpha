{
  "module_name": "libsrp.c",
  "hash_id": "901a47d0a053bf2b0f0f3bb1499ed3eb2dbca150b95bf18b27d41483520bf2ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/ibmvscsi_tgt/libsrp.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"libsrp: \" fmt\n\n#include <linux/printk.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/kfifo.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <scsi/srp.h>\n#include <target/target_core_base.h>\n#include \"libsrp.h\"\n#include \"ibmvscsi_tgt.h\"\n\nstatic int srp_iu_pool_alloc(struct srp_queue *q, size_t max,\n\t\t\t     struct srp_buf **ring)\n{\n\tstruct iu_entry *iue;\n\tint i;\n\n\tq->pool = kcalloc(max, sizeof(struct iu_entry *), GFP_KERNEL);\n\tif (!q->pool)\n\t\treturn -ENOMEM;\n\tq->items = kcalloc(max, sizeof(struct iu_entry), GFP_KERNEL);\n\tif (!q->items)\n\t\tgoto free_pool;\n\n\tspin_lock_init(&q->lock);\n\tkfifo_init(&q->queue, (void *)q->pool, max * sizeof(void *));\n\n\tfor (i = 0, iue = q->items; i < max; i++) {\n\t\tkfifo_in(&q->queue, (void *)&iue, sizeof(void *));\n\t\tiue->sbuf = ring[i];\n\t\tiue++;\n\t}\n\treturn 0;\n\nfree_pool:\n\tkfree(q->pool);\n\treturn -ENOMEM;\n}\n\nstatic void srp_iu_pool_free(struct srp_queue *q)\n{\n\tkfree(q->items);\n\tkfree(q->pool);\n}\n\nstatic struct srp_buf **srp_ring_alloc(struct device *dev,\n\t\t\t\t       size_t max, size_t size)\n{\n\tstruct srp_buf **ring;\n\tint i;\n\n\tring = kcalloc(max, sizeof(struct srp_buf *), GFP_KERNEL);\n\tif (!ring)\n\t\treturn NULL;\n\n\tfor (i = 0; i < max; i++) {\n\t\tring[i] = kzalloc(sizeof(*ring[i]), GFP_KERNEL);\n\t\tif (!ring[i])\n\t\t\tgoto out;\n\t\tring[i]->buf = dma_alloc_coherent(dev, size, &ring[i]->dma,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!ring[i]->buf)\n\t\t\tgoto out;\n\t}\n\treturn ring;\n\nout:\n\tfor (i = 0; i < max && ring[i]; i++) {\n\t\tif (ring[i]->buf) {\n\t\t\tdma_free_coherent(dev, size, ring[i]->buf,\n\t\t\t\t\t  ring[i]->dma);\n\t\t}\n\t\tkfree(ring[i]);\n\t}\n\tkfree(ring);\n\n\treturn NULL;\n}\n\nstatic void srp_ring_free(struct device *dev, struct srp_buf **ring,\n\t\t\t  size_t max, size_t size)\n{\n\tint i;\n\n\tfor (i = 0; i < max; i++) {\n\t\tdma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);\n\t\tkfree(ring[i]);\n\t}\n\tkfree(ring);\n}\n\nint srp_target_alloc(struct srp_target *target, struct device *dev,\n\t\t     size_t nr, size_t iu_size)\n{\n\tint err;\n\n\tspin_lock_init(&target->lock);\n\n\ttarget->dev = dev;\n\n\ttarget->srp_iu_size = iu_size;\n\ttarget->rx_ring_size = nr;\n\ttarget->rx_ring = srp_ring_alloc(target->dev, nr, iu_size);\n\tif (!target->rx_ring)\n\t\treturn -ENOMEM;\n\terr = srp_iu_pool_alloc(&target->iu_queue, nr, target->rx_ring);\n\tif (err)\n\t\tgoto free_ring;\n\n\tdev_set_drvdata(target->dev, target);\n\treturn 0;\n\nfree_ring:\n\tsrp_ring_free(target->dev, target->rx_ring, nr, iu_size);\n\treturn -ENOMEM;\n}\n\nvoid srp_target_free(struct srp_target *target)\n{\n\tdev_set_drvdata(target->dev, NULL);\n\tsrp_ring_free(target->dev, target->rx_ring, target->rx_ring_size,\n\t\t      target->srp_iu_size);\n\tsrp_iu_pool_free(&target->iu_queue);\n}\n\nstruct iu_entry *srp_iu_get(struct srp_target *target)\n{\n\tstruct iu_entry *iue = NULL;\n\n\tif (kfifo_out_locked(&target->iu_queue.queue, (void *)&iue,\n\t\t\t     sizeof(void *),\n\t\t\t     &target->iu_queue.lock) != sizeof(void *)) {\n\t\tWARN_ONCE(1, \"unexpected fifo state\");\n\t\treturn NULL;\n\t}\n\tif (!iue)\n\t\treturn iue;\n\tiue->target = target;\n\tiue->flags = 0;\n\treturn iue;\n}\n\nvoid srp_iu_put(struct iu_entry *iue)\n{\n\tkfifo_in_locked(&iue->target->iu_queue.queue, (void *)&iue,\n\t\t\tsizeof(void *), &iue->target->iu_queue.lock);\n}\n\nstatic int srp_direct_data(struct ibmvscsis_cmd *cmd, struct srp_direct_buf *md,\n\t\t\t   enum dma_data_direction dir, srp_rdma_t rdma_io,\n\t\t\t   int dma_map, int ext_desc)\n{\n\tstruct iu_entry *iue = NULL;\n\tstruct scatterlist *sg = NULL;\n\tint err, nsg = 0, len;\n\n\tif (dma_map) {\n\t\tiue = cmd->iue;\n\t\tsg = cmd->se_cmd.t_data_sg;\n\t\tnsg = dma_map_sg(iue->target->dev, sg, cmd->se_cmd.t_data_nents,\n\t\t\t\t DMA_BIDIRECTIONAL);\n\t\tif (!nsg) {\n\t\t\tpr_err(\"fail to map %p %d\\n\", iue,\n\t\t\t       cmd->se_cmd.t_data_nents);\n\t\t\treturn 0;\n\t\t}\n\t\tlen = min(cmd->se_cmd.data_length, be32_to_cpu(md->len));\n\t} else {\n\t\tlen = be32_to_cpu(md->len);\n\t}\n\n\terr = rdma_io(cmd, sg, nsg, md, 1, dir, len);\n\n\tif (dma_map)\n\t\tdma_unmap_sg(iue->target->dev, sg, nsg, DMA_BIDIRECTIONAL);\n\n\treturn err;\n}\n\nstatic int srp_indirect_data(struct ibmvscsis_cmd *cmd, struct srp_cmd *srp_cmd,\n\t\t\t     struct srp_indirect_buf *id,\n\t\t\t     enum dma_data_direction dir, srp_rdma_t rdma_io,\n\t\t\t     int dma_map, int ext_desc)\n{\n\tstruct iu_entry *iue = NULL;\n\tstruct srp_direct_buf *md = NULL;\n\tstruct scatterlist dummy, *sg = NULL;\n\tdma_addr_t token = 0;\n\tint err = 0;\n\tint nmd, nsg = 0, len;\n\n\tif (dma_map || ext_desc) {\n\t\tiue = cmd->iue;\n\t\tsg = cmd->se_cmd.t_data_sg;\n\t}\n\n\tnmd = be32_to_cpu(id->table_desc.len) / sizeof(struct srp_direct_buf);\n\n\tif ((dir == DMA_FROM_DEVICE && nmd == srp_cmd->data_in_desc_cnt) ||\n\t    (dir == DMA_TO_DEVICE && nmd == srp_cmd->data_out_desc_cnt)) {\n\t\tmd = &id->desc_list[0];\n\t\tgoto rdma;\n\t}\n\n\tif (ext_desc && dma_map) {\n\t\tmd = dma_alloc_coherent(iue->target->dev,\n\t\t\t\t\tbe32_to_cpu(id->table_desc.len),\n\t\t\t\t\t&token, GFP_KERNEL);\n\t\tif (!md) {\n\t\t\tpr_err(\"Can't get dma memory %u\\n\",\n\t\t\t       be32_to_cpu(id->table_desc.len));\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tsg_init_one(&dummy, md, be32_to_cpu(id->table_desc.len));\n\t\tsg_dma_address(&dummy) = token;\n\t\tsg_dma_len(&dummy) = be32_to_cpu(id->table_desc.len);\n\t\terr = rdma_io(cmd, &dummy, 1, &id->table_desc, 1, DMA_TO_DEVICE,\n\t\t\t      be32_to_cpu(id->table_desc.len));\n\t\tif (err) {\n\t\t\tpr_err(\"Error copying indirect table %d\\n\", err);\n\t\t\tgoto free_mem;\n\t\t}\n\t} else {\n\t\tpr_err(\"This command uses external indirect buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\nrdma:\n\tif (dma_map) {\n\t\tnsg = dma_map_sg(iue->target->dev, sg, cmd->se_cmd.t_data_nents,\n\t\t\t\t DMA_BIDIRECTIONAL);\n\t\tif (!nsg) {\n\t\t\tpr_err(\"fail to map %p %d\\n\", iue,\n\t\t\t       cmd->se_cmd.t_data_nents);\n\t\t\terr = -EIO;\n\t\t\tgoto free_mem;\n\t\t}\n\t\tlen = min(cmd->se_cmd.data_length, be32_to_cpu(id->len));\n\t} else {\n\t\tlen = be32_to_cpu(id->len);\n\t}\n\n\terr = rdma_io(cmd, sg, nsg, md, nmd, dir, len);\n\n\tif (dma_map)\n\t\tdma_unmap_sg(iue->target->dev, sg, nsg, DMA_BIDIRECTIONAL);\n\nfree_mem:\n\tif (token && dma_map) {\n\t\tdma_free_coherent(iue->target->dev,\n\t\t\t\t  be32_to_cpu(id->table_desc.len), md, token);\n\t}\n\treturn err;\n}\n\nstatic int data_out_desc_size(struct srp_cmd *cmd)\n{\n\tint size = 0;\n\tu8 fmt = cmd->buf_fmt >> 4;\n\n\tswitch (fmt) {\n\tcase SRP_NO_DATA_DESC:\n\t\tbreak;\n\tcase SRP_DATA_DESC_DIRECT:\n\t\tsize = sizeof(struct srp_direct_buf);\n\t\tbreak;\n\tcase SRP_DATA_DESC_INDIRECT:\n\t\tsize = sizeof(struct srp_indirect_buf) +\n\t\t\tsizeof(struct srp_direct_buf) * cmd->data_out_desc_cnt;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"client error. Invalid data_out_format %x\\n\", fmt);\n\t\tbreak;\n\t}\n\treturn size;\n}\n\n \nint srp_transfer_data(struct ibmvscsis_cmd *cmd, struct srp_cmd *srp_cmd,\n\t\t      srp_rdma_t rdma_io, int dma_map, int ext_desc)\n{\n\tstruct srp_direct_buf *md;\n\tstruct srp_indirect_buf *id;\n\tenum dma_data_direction dir;\n\tint offset, err = 0;\n\tu8 format;\n\n\tif (!cmd->se_cmd.t_data_nents)\n\t\treturn 0;\n\n\toffset = srp_cmd->add_cdb_len & ~3;\n\n\tdir = srp_cmd_direction(srp_cmd);\n\tif (dir == DMA_FROM_DEVICE)\n\t\toffset += data_out_desc_size(srp_cmd);\n\n\tif (dir == DMA_TO_DEVICE)\n\t\tformat = srp_cmd->buf_fmt >> 4;\n\telse\n\t\tformat = srp_cmd->buf_fmt & ((1U << 4) - 1);\n\n\tswitch (format) {\n\tcase SRP_NO_DATA_DESC:\n\t\tbreak;\n\tcase SRP_DATA_DESC_DIRECT:\n\t\tmd = (struct srp_direct_buf *)(srp_cmd->add_data + offset);\n\t\terr = srp_direct_data(cmd, md, dir, rdma_io, dma_map, ext_desc);\n\t\tbreak;\n\tcase SRP_DATA_DESC_INDIRECT:\n\t\tid = (struct srp_indirect_buf *)(srp_cmd->add_data + offset);\n\t\terr = srp_indirect_data(cmd, srp_cmd, id, dir, rdma_io, dma_map,\n\t\t\t\t\text_desc);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown format %d %x\\n\", dir, format);\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nu64 srp_data_length(struct srp_cmd *cmd, enum dma_data_direction dir)\n{\n\tstruct srp_direct_buf *md;\n\tstruct srp_indirect_buf *id;\n\tu64 len = 0;\n\tuint offset = cmd->add_cdb_len & ~3;\n\tu8 fmt;\n\n\tif (dir == DMA_TO_DEVICE) {\n\t\tfmt = cmd->buf_fmt >> 4;\n\t} else {\n\t\tfmt = cmd->buf_fmt & ((1U << 4) - 1);\n\t\toffset += data_out_desc_size(cmd);\n\t}\n\n\tswitch (fmt) {\n\tcase SRP_NO_DATA_DESC:\n\t\tbreak;\n\tcase SRP_DATA_DESC_DIRECT:\n\t\tmd = (struct srp_direct_buf *)(cmd->add_data + offset);\n\t\tlen = be32_to_cpu(md->len);\n\t\tbreak;\n\tcase SRP_DATA_DESC_INDIRECT:\n\t\tid = (struct srp_indirect_buf *)(cmd->add_data + offset);\n\t\tlen = be32_to_cpu(id->len);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"invalid data format %x\\n\", fmt);\n\t\tbreak;\n\t}\n\treturn len;\n}\n\nint srp_get_desc_table(struct srp_cmd *srp_cmd, enum dma_data_direction *dir,\n\t\t       u64 *data_len)\n{\n\tstruct srp_indirect_buf *idb;\n\tstruct srp_direct_buf *db;\n\tuint add_cdb_offset;\n\tint rc;\n\n\t \n\tBUILD_BUG_ON(!__same_type(srp_cmd->add_data[0], (s8)0)\n\t\t     && !__same_type(srp_cmd->add_data[0], (u8)0));\n\n\tBUG_ON(!dir);\n\tBUG_ON(!data_len);\n\n\trc = 0;\n\t*data_len = 0;\n\n\t*dir = DMA_NONE;\n\n\tif (srp_cmd->buf_fmt & 0xf)\n\t\t*dir = DMA_FROM_DEVICE;\n\telse if (srp_cmd->buf_fmt >> 4)\n\t\t*dir = DMA_TO_DEVICE;\n\n\tadd_cdb_offset = srp_cmd->add_cdb_len & ~3;\n\tif (((srp_cmd->buf_fmt & 0xf) == SRP_DATA_DESC_DIRECT) ||\n\t    ((srp_cmd->buf_fmt >> 4) == SRP_DATA_DESC_DIRECT)) {\n\t\tdb = (struct srp_direct_buf *)(srp_cmd->add_data\n\t\t\t\t\t       + add_cdb_offset);\n\t\t*data_len = be32_to_cpu(db->len);\n\t} else if (((srp_cmd->buf_fmt & 0xf) == SRP_DATA_DESC_INDIRECT) ||\n\t\t   ((srp_cmd->buf_fmt >> 4) == SRP_DATA_DESC_INDIRECT)) {\n\t\tidb = (struct srp_indirect_buf *)(srp_cmd->add_data\n\t\t\t\t\t\t  + add_cdb_offset);\n\n\t\t*data_len = be32_to_cpu(idb->len);\n\t}\n\treturn rc;\n}\n\nMODULE_DESCRIPTION(\"SCSI RDMA Protocol lib functions\");\nMODULE_AUTHOR(\"FUJITA Tomonori\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}