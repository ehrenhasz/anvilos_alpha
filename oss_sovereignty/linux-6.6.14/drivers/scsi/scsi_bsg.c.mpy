{
  "module_name": "scsi_bsg.c",
  "hash_id": "736f6f6e55081d45065fa94b9f3bf7cb607c7dcb9712c9a5759def7889dd76cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_bsg.c",
  "human_readable_source": "\n#include <linux/bsg.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_ioctl.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/sg.h>\n#include \"scsi_priv.h\"\n\n#define uptr64(val) ((void __user *)(uintptr_t)(val))\n\nstatic int scsi_bsg_sg_io_fn(struct request_queue *q, struct sg_io_v4 *hdr,\n\t\tbool open_for_write, unsigned int timeout)\n{\n\tstruct scsi_cmnd *scmd;\n\tstruct request *rq;\n\tstruct bio *bio;\n\tint ret;\n\n\tif (hdr->protocol != BSG_PROTOCOL_SCSI  ||\n\t    hdr->subprotocol != BSG_SUB_PROTOCOL_SCSI_CMD)\n\t\treturn -EINVAL;\n\tif (hdr->dout_xfer_len && hdr->din_xfer_len) {\n\t\tpr_warn_once(\"BIDI support in bsg has been removed.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trq = scsi_alloc_request(q, hdr->dout_xfer_len ?\n\t\t\t\tREQ_OP_DRV_OUT : REQ_OP_DRV_IN, 0);\n\tif (IS_ERR(rq))\n\t\treturn PTR_ERR(rq);\n\trq->timeout = timeout;\n\n\tscmd = blk_mq_rq_to_pdu(rq);\n\tscmd->cmd_len = hdr->request_len;\n\tif (scmd->cmd_len > sizeof(scmd->cmnd)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_request;\n\t}\n\n\tret = -EFAULT;\n\tif (copy_from_user(scmd->cmnd, uptr64(hdr->request), scmd->cmd_len))\n\t\tgoto out_put_request;\n\tret = -EPERM;\n\tif (!scsi_cmd_allowed(scmd->cmnd, open_for_write))\n\t\tgoto out_put_request;\n\n\tret = 0;\n\tif (hdr->dout_xfer_len) {\n\t\tret = blk_rq_map_user(rq->q, rq, NULL, uptr64(hdr->dout_xferp),\n\t\t\t\thdr->dout_xfer_len, GFP_KERNEL);\n\t} else if (hdr->din_xfer_len) {\n\t\tret = blk_rq_map_user(rq->q, rq, NULL, uptr64(hdr->din_xferp),\n\t\t\t\thdr->din_xfer_len, GFP_KERNEL);\n\t}\n\n\tif (ret)\n\t\tgoto out_put_request;\n\n\tbio = rq->bio;\n\tblk_execute_rq(rq, !(hdr->flags & BSG_FLAG_Q_AT_TAIL));\n\n\t \n\thdr->device_status = scmd->result & 0xff;\n\thdr->transport_status = host_byte(scmd->result);\n\thdr->driver_status = 0;\n\tif (scsi_status_is_check_condition(scmd->result))\n\t\thdr->driver_status = DRIVER_SENSE;\n\thdr->info = 0;\n\tif (hdr->device_status || hdr->transport_status || hdr->driver_status)\n\t\thdr->info |= SG_INFO_CHECK;\n\thdr->response_len = 0;\n\n\tif (scmd->sense_len && hdr->response) {\n\t\tint len = min_t(unsigned int, hdr->max_response_len,\n\t\t\t\tscmd->sense_len);\n\n\t\tif (copy_to_user(uptr64(hdr->response), scmd->sense_buffer,\n\t\t\t\t len))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\thdr->response_len = len;\n\t}\n\n\tif (rq_data_dir(rq) == READ)\n\t\thdr->din_resid = scmd->resid_len;\n\telse\n\t\thdr->dout_resid = scmd->resid_len;\n\n\tblk_rq_unmap_user(bio);\n\nout_put_request:\n\tblk_mq_free_request(rq);\n\treturn ret;\n}\n\nstruct bsg_device *scsi_bsg_register_queue(struct scsi_device *sdev)\n{\n\treturn bsg_register_queue(sdev->request_queue, &sdev->sdev_gendev,\n\t\t\tdev_name(&sdev->sdev_gendev), scsi_bsg_sg_io_fn);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}