{
  "module_name": "hisi_sas_v1_hw.c",
  "hash_id": "4ec2abe3e6dec722db19336fcb7afb6ed48c2f4dd3a0e338aecb31a096eba468",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/hisi_sas/hisi_sas_v1_hw.c",
  "human_readable_source": "\n \n\n#include \"hisi_sas.h\"\n#define DRV_NAME \"hisi_sas_v1_hw\"\n\n \n#define DLVRY_QUEUE_ENABLE\t\t0x0\n#define IOST_BASE_ADDR_LO\t\t0x8\n#define IOST_BASE_ADDR_HI\t\t0xc\n#define ITCT_BASE_ADDR_LO\t\t0x10\n#define ITCT_BASE_ADDR_HI\t\t0x14\n#define BROKEN_MSG_ADDR_LO\t\t0x18\n#define BROKEN_MSG_ADDR_HI\t\t0x1c\n#define PHY_CONTEXT\t\t\t0x20\n#define PHY_STATE\t\t\t0x24\n#define PHY_PORT_NUM_MA\t\t\t0x28\n#define PORT_STATE\t\t\t0x2c\n#define PHY_CONN_RATE\t\t\t0x30\n#define HGC_TRANS_TASK_CNT_LIMIT\t0x38\n#define AXI_AHB_CLK_CFG\t\t\t0x3c\n#define HGC_SAS_TXFAIL_RETRY_CTRL\t0x84\n#define HGC_GET_ITV_TIME\t\t0x90\n#define DEVICE_MSG_WORK_MODE\t\t0x94\n#define I_T_NEXUS_LOSS_TIME\t\t0xa0\n#define BUS_INACTIVE_LIMIT_TIME\t\t0xa8\n#define REJECT_TO_OPEN_LIMIT_TIME\t0xac\n#define CFG_AGING_TIME\t\t\t0xbc\n#define CFG_AGING_TIME_ITCT_REL_OFF\t0\n#define CFG_AGING_TIME_ITCT_REL_MSK\t(0x1 << CFG_AGING_TIME_ITCT_REL_OFF)\n#define HGC_DFX_CFG2\t\t\t0xc0\n#define FIS_LIST_BADDR_L\t\t0xc4\n#define CFG_1US_TIMER_TRSH\t\t0xcc\n#define CFG_SAS_CONFIG\t\t\t0xd4\n#define HGC_IOST_ECC_ADDR\t\t0x140\n#define HGC_IOST_ECC_ADDR_BAD_OFF\t16\n#define HGC_IOST_ECC_ADDR_BAD_MSK\t(0x3ff << HGC_IOST_ECC_ADDR_BAD_OFF)\n#define HGC_DQ_ECC_ADDR\t\t\t0x144\n#define HGC_DQ_ECC_ADDR_BAD_OFF\t\t16\n#define HGC_DQ_ECC_ADDR_BAD_MSK\t\t(0xfff << HGC_DQ_ECC_ADDR_BAD_OFF)\n#define HGC_INVLD_DQE_INFO\t\t0x148\n#define HGC_INVLD_DQE_INFO_DQ_OFF\t0\n#define HGC_INVLD_DQE_INFO_DQ_MSK\t(0xffff << HGC_INVLD_DQE_INFO_DQ_OFF)\n#define HGC_INVLD_DQE_INFO_TYPE_OFF\t16\n#define HGC_INVLD_DQE_INFO_TYPE_MSK\t(0x1 << HGC_INVLD_DQE_INFO_TYPE_OFF)\n#define HGC_INVLD_DQE_INFO_FORCE_OFF\t17\n#define HGC_INVLD_DQE_INFO_FORCE_MSK\t(0x1 << HGC_INVLD_DQE_INFO_FORCE_OFF)\n#define HGC_INVLD_DQE_INFO_PHY_OFF\t18\n#define HGC_INVLD_DQE_INFO_PHY_MSK\t(0x1 << HGC_INVLD_DQE_INFO_PHY_OFF)\n#define HGC_INVLD_DQE_INFO_ABORT_OFF\t19\n#define HGC_INVLD_DQE_INFO_ABORT_MSK\t(0x1 << HGC_INVLD_DQE_INFO_ABORT_OFF)\n#define HGC_INVLD_DQE_INFO_IPTT_OF_OFF\t20\n#define HGC_INVLD_DQE_INFO_IPTT_OF_MSK\t(0x1 << HGC_INVLD_DQE_INFO_IPTT_OF_OFF)\n#define HGC_INVLD_DQE_INFO_SSP_ERR_OFF\t21\n#define HGC_INVLD_DQE_INFO_SSP_ERR_MSK\t(0x1 << HGC_INVLD_DQE_INFO_SSP_ERR_OFF)\n#define HGC_INVLD_DQE_INFO_OFL_OFF\t22\n#define HGC_INVLD_DQE_INFO_OFL_MSK\t(0x1 << HGC_INVLD_DQE_INFO_OFL_OFF)\n#define HGC_ITCT_ECC_ADDR\t\t0x150\n#define HGC_ITCT_ECC_ADDR_BAD_OFF\t16\n#define HGC_ITCT_ECC_ADDR_BAD_MSK\t(0x3ff << HGC_ITCT_ECC_ADDR_BAD_OFF)\n#define HGC_AXI_FIFO_ERR_INFO\t\t0x154\n#define INT_COAL_EN\t\t\t0x1bc\n#define OQ_INT_COAL_TIME\t\t0x1c0\n#define OQ_INT_COAL_CNT\t\t\t0x1c4\n#define ENT_INT_COAL_TIME\t\t0x1c8\n#define ENT_INT_COAL_CNT\t\t0x1cc\n#define OQ_INT_SRC\t\t\t0x1d0\n#define OQ_INT_SRC_MSK\t\t\t0x1d4\n#define ENT_INT_SRC1\t\t\t0x1d8\n#define ENT_INT_SRC2\t\t\t0x1dc\n#define ENT_INT_SRC2_DQ_CFG_ERR_OFF\t25\n#define ENT_INT_SRC2_DQ_CFG_ERR_MSK\t(0x1 << ENT_INT_SRC2_DQ_CFG_ERR_OFF)\n#define ENT_INT_SRC2_CQ_CFG_ERR_OFF\t27\n#define ENT_INT_SRC2_CQ_CFG_ERR_MSK\t(0x1 << ENT_INT_SRC2_CQ_CFG_ERR_OFF)\n#define ENT_INT_SRC2_AXI_WRONG_INT_OFF\t28\n#define ENT_INT_SRC2_AXI_WRONG_INT_MSK\t(0x1 << ENT_INT_SRC2_AXI_WRONG_INT_OFF)\n#define ENT_INT_SRC2_AXI_OVERLF_INT_OFF\t29\n#define ENT_INT_SRC2_AXI_OVERLF_INT_MSK\t(0x1 << ENT_INT_SRC2_AXI_OVERLF_INT_OFF)\n#define ENT_INT_SRC_MSK1\t\t0x1e0\n#define ENT_INT_SRC_MSK2\t\t0x1e4\n#define SAS_ECC_INTR\t\t\t0x1e8\n#define SAS_ECC_INTR_DQ_ECC1B_OFF\t0\n#define SAS_ECC_INTR_DQ_ECC1B_MSK\t(0x1 << SAS_ECC_INTR_DQ_ECC1B_OFF)\n#define SAS_ECC_INTR_DQ_ECCBAD_OFF\t1\n#define SAS_ECC_INTR_DQ_ECCBAD_MSK\t(0x1 << SAS_ECC_INTR_DQ_ECCBAD_OFF)\n#define SAS_ECC_INTR_IOST_ECC1B_OFF\t2\n#define SAS_ECC_INTR_IOST_ECC1B_MSK\t(0x1 << SAS_ECC_INTR_IOST_ECC1B_OFF)\n#define SAS_ECC_INTR_IOST_ECCBAD_OFF\t3\n#define SAS_ECC_INTR_IOST_ECCBAD_MSK\t(0x1 << SAS_ECC_INTR_IOST_ECCBAD_OFF)\n#define SAS_ECC_INTR_ITCT_ECC1B_OFF\t4\n#define SAS_ECC_INTR_ITCT_ECC1B_MSK\t(0x1 << SAS_ECC_INTR_ITCT_ECC1B_OFF)\n#define SAS_ECC_INTR_ITCT_ECCBAD_OFF\t5\n#define SAS_ECC_INTR_ITCT_ECCBAD_MSK\t(0x1 << SAS_ECC_INTR_ITCT_ECCBAD_OFF)\n#define SAS_ECC_INTR_MSK\t\t0x1ec\n#define HGC_ERR_STAT_EN\t\t\t0x238\n#define DLVRY_Q_0_BASE_ADDR_LO\t\t0x260\n#define DLVRY_Q_0_BASE_ADDR_HI\t\t0x264\n#define DLVRY_Q_0_DEPTH\t\t\t0x268\n#define DLVRY_Q_0_WR_PTR\t\t0x26c\n#define DLVRY_Q_0_RD_PTR\t\t0x270\n#define COMPL_Q_0_BASE_ADDR_LO\t\t0x4e0\n#define COMPL_Q_0_BASE_ADDR_HI\t\t0x4e4\n#define COMPL_Q_0_DEPTH\t\t\t0x4e8\n#define COMPL_Q_0_WR_PTR\t\t0x4ec\n#define COMPL_Q_0_RD_PTR\t\t0x4f0\n#define HGC_ECC_ERR\t\t\t0x7d0\n\n \n#define PORT_BASE\t\t\t(0x800)\n\n#define PHY_CFG\t\t\t\t(PORT_BASE + 0x0)\n#define PHY_CFG_ENA_OFF\t\t\t0\n#define PHY_CFG_ENA_MSK\t\t\t(0x1 << PHY_CFG_ENA_OFF)\n#define PHY_CFG_DC_OPT_OFF\t\t2\n#define PHY_CFG_DC_OPT_MSK\t\t(0x1 << PHY_CFG_DC_OPT_OFF)\n#define PROG_PHY_LINK_RATE\t\t(PORT_BASE + 0xc)\n#define PROG_PHY_LINK_RATE_MAX_OFF\t0\n#define PROG_PHY_LINK_RATE_MAX_MSK\t(0xf << PROG_PHY_LINK_RATE_MAX_OFF)\n#define PROG_PHY_LINK_RATE_MIN_OFF\t4\n#define PROG_PHY_LINK_RATE_MIN_MSK\t(0xf << PROG_PHY_LINK_RATE_MIN_OFF)\n#define PROG_PHY_LINK_RATE_OOB_OFF\t8\n#define PROG_PHY_LINK_RATE_OOB_MSK\t(0xf << PROG_PHY_LINK_RATE_OOB_OFF)\n#define PHY_CTRL\t\t\t(PORT_BASE + 0x14)\n#define PHY_CTRL_RESET_OFF\t\t0\n#define PHY_CTRL_RESET_MSK\t\t(0x1 << PHY_CTRL_RESET_OFF)\n#define PHY_RATE_NEGO\t\t\t(PORT_BASE + 0x30)\n#define PHY_PCN\t\t\t\t(PORT_BASE + 0x44)\n#define SL_TOUT_CFG\t\t\t(PORT_BASE + 0x8c)\n#define SL_CONTROL\t\t\t(PORT_BASE + 0x94)\n#define SL_CONTROL_NOTIFY_EN_OFF\t0\n#define SL_CONTROL_NOTIFY_EN_MSK\t(0x1 << SL_CONTROL_NOTIFY_EN_OFF)\n#define TX_ID_DWORD0\t\t\t(PORT_BASE + 0x9c)\n#define TX_ID_DWORD1\t\t\t(PORT_BASE + 0xa0)\n#define TX_ID_DWORD2\t\t\t(PORT_BASE + 0xa4)\n#define TX_ID_DWORD3\t\t\t(PORT_BASE + 0xa8)\n#define TX_ID_DWORD4\t\t\t(PORT_BASE + 0xaC)\n#define TX_ID_DWORD5\t\t\t(PORT_BASE + 0xb0)\n#define TX_ID_DWORD6\t\t\t(PORT_BASE + 0xb4)\n#define RX_IDAF_DWORD0\t\t\t(PORT_BASE + 0xc4)\n#define RX_IDAF_DWORD1\t\t\t(PORT_BASE + 0xc8)\n#define RX_IDAF_DWORD2\t\t\t(PORT_BASE + 0xcc)\n#define RX_IDAF_DWORD3\t\t\t(PORT_BASE + 0xd0)\n#define RX_IDAF_DWORD4\t\t\t(PORT_BASE + 0xd4)\n#define RX_IDAF_DWORD5\t\t\t(PORT_BASE + 0xd8)\n#define RX_IDAF_DWORD6\t\t\t(PORT_BASE + 0xdc)\n#define RXOP_CHECK_CFG_H\t\t(PORT_BASE + 0xfc)\n#define DONE_RECEIVED_TIME\t\t(PORT_BASE + 0x12c)\n#define CON_CFG_DRIVER\t\t\t(PORT_BASE + 0x130)\n#define PHY_CONFIG2\t\t\t(PORT_BASE + 0x1a8)\n#define PHY_CONFIG2_FORCE_TXDEEMPH_OFF\t3\n#define PHY_CONFIG2_FORCE_TXDEEMPH_MSK\t(0x1 << PHY_CONFIG2_FORCE_TXDEEMPH_OFF)\n#define PHY_CONFIG2_TX_TRAIN_COMP_OFF\t24\n#define PHY_CONFIG2_TX_TRAIN_COMP_MSK\t(0x1 << PHY_CONFIG2_TX_TRAIN_COMP_OFF)\n#define CHL_INT0\t\t\t(PORT_BASE + 0x1b0)\n#define CHL_INT0_PHYCTRL_NOTRDY_OFF\t0\n#define CHL_INT0_PHYCTRL_NOTRDY_MSK\t(0x1 << CHL_INT0_PHYCTRL_NOTRDY_OFF)\n#define CHL_INT0_SN_FAIL_NGR_OFF\t2\n#define CHL_INT0_SN_FAIL_NGR_MSK\t(0x1 << CHL_INT0_SN_FAIL_NGR_OFF)\n#define CHL_INT0_DWS_LOST_OFF\t\t4\n#define CHL_INT0_DWS_LOST_MSK\t\t(0x1 << CHL_INT0_DWS_LOST_OFF)\n#define CHL_INT0_SL_IDAF_FAIL_OFF\t10\n#define CHL_INT0_SL_IDAF_FAIL_MSK\t(0x1 << CHL_INT0_SL_IDAF_FAIL_OFF)\n#define CHL_INT0_ID_TIMEOUT_OFF\t\t11\n#define CHL_INT0_ID_TIMEOUT_MSK\t\t(0x1 << CHL_INT0_ID_TIMEOUT_OFF)\n#define CHL_INT0_SL_OPAF_FAIL_OFF\t12\n#define CHL_INT0_SL_OPAF_FAIL_MSK\t(0x1 << CHL_INT0_SL_OPAF_FAIL_OFF)\n#define CHL_INT0_SL_PS_FAIL_OFF\t\t21\n#define CHL_INT0_SL_PS_FAIL_MSK\t\t(0x1 << CHL_INT0_SL_PS_FAIL_OFF)\n#define CHL_INT1\t\t\t(PORT_BASE + 0x1b4)\n#define CHL_INT2\t\t\t(PORT_BASE + 0x1b8)\n#define CHL_INT2_SL_RX_BC_ACK_OFF\t2\n#define CHL_INT2_SL_RX_BC_ACK_MSK\t(0x1 << CHL_INT2_SL_RX_BC_ACK_OFF)\n#define CHL_INT2_SL_PHY_ENA_OFF\t\t6\n#define CHL_INT2_SL_PHY_ENA_MSK\t\t(0x1 << CHL_INT2_SL_PHY_ENA_OFF)\n#define CHL_INT0_MSK\t\t\t(PORT_BASE + 0x1bc)\n#define CHL_INT0_MSK_PHYCTRL_NOTRDY_OFF\t0\n#define CHL_INT0_MSK_PHYCTRL_NOTRDY_MSK\t(0x1 << CHL_INT0_MSK_PHYCTRL_NOTRDY_OFF)\n#define CHL_INT1_MSK\t\t\t(PORT_BASE + 0x1c0)\n#define CHL_INT2_MSK\t\t\t(PORT_BASE + 0x1c4)\n#define CHL_INT_COAL_EN\t\t\t(PORT_BASE + 0x1d0)\n#define DMA_TX_STATUS\t\t\t(PORT_BASE + 0x2d0)\n#define DMA_TX_STATUS_BUSY_OFF\t\t0\n#define DMA_TX_STATUS_BUSY_MSK\t\t(0x1 << DMA_TX_STATUS_BUSY_OFF)\n#define DMA_RX_STATUS\t\t\t(PORT_BASE + 0x2e8)\n#define DMA_RX_STATUS_BUSY_OFF\t\t0\n#define DMA_RX_STATUS_BUSY_MSK\t\t(0x1 << DMA_RX_STATUS_BUSY_OFF)\n\n#define AXI_CFG\t\t\t\t0x5100\n#define RESET_VALUE\t\t\t0x7ffff\n\n \n \n \n#define CMD_HDR_RESP_REPORT_OFF\t\t5\n#define CMD_HDR_RESP_REPORT_MSK\t\t0x20\n#define CMD_HDR_TLR_CTRL_OFF\t\t6\n#define CMD_HDR_TLR_CTRL_MSK\t\t0xc0\n#define CMD_HDR_PORT_OFF\t\t17\n#define CMD_HDR_PORT_MSK\t\t0xe0000\n#define CMD_HDR_PRIORITY_OFF\t\t27\n#define CMD_HDR_PRIORITY_MSK\t\t0x8000000\n#define CMD_HDR_MODE_OFF\t\t28\n#define CMD_HDR_MODE_MSK\t\t0x10000000\n#define CMD_HDR_CMD_OFF\t\t\t29\n#define CMD_HDR_CMD_MSK\t\t\t0xe0000000\n \n#define CMD_HDR_VERIFY_DTL_OFF\t\t10\n#define CMD_HDR_VERIFY_DTL_MSK\t\t0x400\n#define CMD_HDR_SSP_FRAME_TYPE_OFF\t13\n#define CMD_HDR_SSP_FRAME_TYPE_MSK\t0xe000\n#define CMD_HDR_DEVICE_ID_OFF\t\t16\n#define CMD_HDR_DEVICE_ID_MSK\t\t0xffff0000\n \n#define CMD_HDR_CFL_OFF\t\t\t0\n#define CMD_HDR_CFL_MSK\t\t\t0x1ff\n#define CMD_HDR_MRFL_OFF\t\t15\n#define CMD_HDR_MRFL_MSK\t\t0xff8000\n#define CMD_HDR_FIRST_BURST_OFF\t\t25\n#define CMD_HDR_FIRST_BURST_MSK\t\t0x2000000\n \n#define CMD_HDR_IPTT_OFF\t\t0\n#define CMD_HDR_IPTT_MSK\t\t0xffff\n \n#define CMD_HDR_DATA_SGL_LEN_OFF\t16\n#define CMD_HDR_DATA_SGL_LEN_MSK\t0xffff0000\n\n \n#define CMPLT_HDR_IPTT_OFF\t\t0\n#define CMPLT_HDR_IPTT_MSK\t\t(0xffff << CMPLT_HDR_IPTT_OFF)\n#define CMPLT_HDR_CMD_CMPLT_OFF\t\t17\n#define CMPLT_HDR_CMD_CMPLT_MSK\t\t(0x1 << CMPLT_HDR_CMD_CMPLT_OFF)\n#define CMPLT_HDR_ERR_RCRD_XFRD_OFF\t18\n#define CMPLT_HDR_ERR_RCRD_XFRD_MSK\t(0x1 << CMPLT_HDR_ERR_RCRD_XFRD_OFF)\n#define CMPLT_HDR_RSPNS_XFRD_OFF\t19\n#define CMPLT_HDR_RSPNS_XFRD_MSK\t(0x1 << CMPLT_HDR_RSPNS_XFRD_OFF)\n#define CMPLT_HDR_IO_CFG_ERR_OFF\t27\n#define CMPLT_HDR_IO_CFG_ERR_MSK\t(0x1 << CMPLT_HDR_IO_CFG_ERR_OFF)\n\n \n \n#define ITCT_HDR_DEV_TYPE_OFF\t\t0\n#define ITCT_HDR_DEV_TYPE_MSK\t\t(0x3ULL << ITCT_HDR_DEV_TYPE_OFF)\n#define ITCT_HDR_VALID_OFF\t\t2\n#define ITCT_HDR_VALID_MSK\t\t(0x1ULL << ITCT_HDR_VALID_OFF)\n#define ITCT_HDR_AWT_CONTROL_OFF\t4\n#define ITCT_HDR_AWT_CONTROL_MSK\t(0x1ULL << ITCT_HDR_AWT_CONTROL_OFF)\n#define ITCT_HDR_MAX_CONN_RATE_OFF\t5\n#define ITCT_HDR_MAX_CONN_RATE_MSK\t(0xfULL << ITCT_HDR_MAX_CONN_RATE_OFF)\n#define ITCT_HDR_VALID_LINK_NUM_OFF\t9\n#define ITCT_HDR_VALID_LINK_NUM_MSK\t(0xfULL << ITCT_HDR_VALID_LINK_NUM_OFF)\n#define ITCT_HDR_PORT_ID_OFF\t\t13\n#define ITCT_HDR_PORT_ID_MSK\t\t(0x7ULL << ITCT_HDR_PORT_ID_OFF)\n#define ITCT_HDR_SMP_TIMEOUT_OFF\t16\n#define ITCT_HDR_SMP_TIMEOUT_MSK\t(0xffffULL << ITCT_HDR_SMP_TIMEOUT_OFF)\n \n#define ITCT_HDR_MAX_SAS_ADDR_OFF\t0\n#define ITCT_HDR_MAX_SAS_ADDR_MSK\t(0xffffffffffffffff << \\\n\t\t\t\t\tITCT_HDR_MAX_SAS_ADDR_OFF)\n \n#define ITCT_HDR_IT_NEXUS_LOSS_TL_OFF\t0\n#define ITCT_HDR_IT_NEXUS_LOSS_TL_MSK\t(0xffffULL << \\\n\t\t\t\t\tITCT_HDR_IT_NEXUS_LOSS_TL_OFF)\n#define ITCT_HDR_BUS_INACTIVE_TL_OFF\t16\n#define ITCT_HDR_BUS_INACTIVE_TL_MSK\t(0xffffULL << \\\n\t\t\t\t\tITCT_HDR_BUS_INACTIVE_TL_OFF)\n#define ITCT_HDR_MAX_CONN_TL_OFF\t32\n#define ITCT_HDR_MAX_CONN_TL_MSK\t(0xffffULL << \\\n\t\t\t\t\tITCT_HDR_MAX_CONN_TL_OFF)\n#define ITCT_HDR_REJ_OPEN_TL_OFF\t48\n#define ITCT_HDR_REJ_OPEN_TL_MSK\t(0xffffULL << \\\n\t\t\t\t\tITCT_HDR_REJ_OPEN_TL_OFF)\n\n \n#define ERR_HDR_DMA_TX_ERR_TYPE_OFF\t0\n#define ERR_HDR_DMA_TX_ERR_TYPE_MSK\t(0xffff << ERR_HDR_DMA_TX_ERR_TYPE_OFF)\n#define ERR_HDR_DMA_RX_ERR_TYPE_OFF\t16\n#define ERR_HDR_DMA_RX_ERR_TYPE_MSK\t(0xffff << ERR_HDR_DMA_RX_ERR_TYPE_OFF)\n\nstruct hisi_sas_complete_v1_hdr {\n\t__le32 data;\n};\n\nstruct hisi_sas_err_record_v1 {\n\t \n\t__le32 dma_err_type;\n\n\t \n\t__le32 trans_tx_fail_type;\n\n\t \n\t__le32 trans_rx_fail_type;\n\n\t \n\tu32 rsvd;\n};\n\nenum {\n\tHISI_SAS_PHY_BCAST_ACK = 0,\n\tHISI_SAS_PHY_SL_PHY_ENABLED,\n\tHISI_SAS_PHY_INT_ABNORMAL,\n\tHISI_SAS_PHY_INT_NR\n};\n\nenum {\n\tDMA_TX_ERR_BASE = 0x0,\n\tDMA_RX_ERR_BASE = 0x100,\n\tTRANS_TX_FAIL_BASE = 0x200,\n\tTRANS_RX_FAIL_BASE = 0x300,\n\n\t \n\tDMA_TX_DIF_CRC_ERR = DMA_TX_ERR_BASE,  \n\tDMA_TX_DIF_APP_ERR,  \n\tDMA_TX_DIF_RPP_ERR,  \n\tDMA_TX_AXI_BUS_ERR,  \n\tDMA_TX_DATA_SGL_OVERFLOW_ERR,  \n\tDMA_TX_DIF_SGL_OVERFLOW_ERR,  \n\tDMA_TX_UNEXP_XFER_RDY_ERR,  \n\tDMA_TX_XFER_RDY_OFFSET_ERR,  \n\tDMA_TX_DATA_UNDERFLOW_ERR,  \n\tDMA_TX_XFER_RDY_LENGTH_OVERFLOW_ERR,  \n\n\t \n\tDMA_RX_BUFFER_ECC_ERR = DMA_RX_ERR_BASE,  \n\tDMA_RX_DIF_CRC_ERR,  \n\tDMA_RX_DIF_APP_ERR,  \n\tDMA_RX_DIF_RPP_ERR,  \n\tDMA_RX_RESP_BUFFER_OVERFLOW_ERR,  \n\tDMA_RX_AXI_BUS_ERR,  \n\tDMA_RX_DATA_SGL_OVERFLOW_ERR,  \n\tDMA_RX_DIF_SGL_OVERFLOW_ERR,  \n\tDMA_RX_DATA_OFFSET_ERR,  \n\tDMA_RX_UNEXP_RX_DATA_ERR,  \n\tDMA_RX_DATA_OVERFLOW_ERR,  \n\tDMA_RX_DATA_UNDERFLOW_ERR,  \n\tDMA_RX_UNEXP_RETRANS_RESP_ERR,  \n\n\t \n\tTRANS_TX_RSVD0_ERR = TRANS_TX_FAIL_BASE,  \n\tTRANS_TX_PHY_NOT_ENABLE_ERR,  \n\tTRANS_TX_OPEN_REJCT_WRONG_DEST_ERR,  \n\tTRANS_TX_OPEN_REJCT_ZONE_VIOLATION_ERR,  \n\tTRANS_TX_OPEN_REJCT_BY_OTHER_ERR,  \n\tTRANS_TX_RSVD1_ERR,  \n\tTRANS_TX_OPEN_REJCT_AIP_TIMEOUT_ERR,  \n\tTRANS_TX_OPEN_REJCT_STP_BUSY_ERR,  \n\tTRANS_TX_OPEN_REJCT_PROTOCOL_NOT_SUPPORT_ERR,  \n\tTRANS_TX_OPEN_REJCT_RATE_NOT_SUPPORT_ERR,  \n\tTRANS_TX_OPEN_REJCT_BAD_DEST_ERR,  \n\tTRANS_TX_OPEN_BREAK_RECEIVE_ERR,  \n\tTRANS_TX_LOW_PHY_POWER_ERR,  \n\tTRANS_TX_OPEN_REJCT_PATHWAY_BLOCKED_ERR,  \n\tTRANS_TX_OPEN_TIMEOUT_ERR,  \n\tTRANS_TX_OPEN_REJCT_NO_DEST_ERR,  \n\tTRANS_TX_OPEN_RETRY_ERR,  \n\tTRANS_TX_RSVD2_ERR,  \n\tTRANS_TX_BREAK_TIMEOUT_ERR,  \n\tTRANS_TX_BREAK_REQUEST_ERR,  \n\tTRANS_TX_BREAK_RECEIVE_ERR,  \n\tTRANS_TX_CLOSE_TIMEOUT_ERR,  \n\tTRANS_TX_CLOSE_NORMAL_ERR,  \n\tTRANS_TX_CLOSE_PHYRESET_ERR,  \n\tTRANS_TX_WITH_CLOSE_DWS_TIMEOUT_ERR,  \n\tTRANS_TX_WITH_CLOSE_COMINIT_ERR,  \n\tTRANS_TX_NAK_RECEIVE_ERR,  \n\tTRANS_TX_ACK_NAK_TIMEOUT_ERR,  \n\tTRANS_TX_CREDIT_TIMEOUT_ERR,  \n\tTRANS_TX_IPTT_CONFLICT_ERR,  \n\tTRANS_TX_TXFRM_TYPE_ERR,  \n\tTRANS_TX_TXSMP_LENGTH_ERR,  \n\n\t \n\tTRANS_RX_FRAME_CRC_ERR = TRANS_RX_FAIL_BASE,  \n\tTRANS_RX_FRAME_DONE_ERR,  \n\tTRANS_RX_FRAME_ERRPRM_ERR,  \n\tTRANS_RX_FRAME_NO_CREDIT_ERR,  \n\tTRANS_RX_RSVD0_ERR,  \n\tTRANS_RX_FRAME_OVERRUN_ERR,  \n\tTRANS_RX_FRAME_NO_EOF_ERR,  \n\tTRANS_RX_LINK_BUF_OVERRUN_ERR,  \n\tTRANS_RX_BREAK_TIMEOUT_ERR,  \n\tTRANS_RX_BREAK_REQUEST_ERR,  \n\tTRANS_RX_BREAK_RECEIVE_ERR,  \n\tTRANS_RX_CLOSE_TIMEOUT_ERR,  \n\tTRANS_RX_CLOSE_NORMAL_ERR,  \n\tTRANS_RX_CLOSE_PHYRESET_ERR,  \n\tTRANS_RX_WITH_CLOSE_DWS_TIMEOUT_ERR,  \n\tTRANS_RX_WITH_CLOSE_COMINIT_ERR,  \n\tTRANS_RX_DATA_LENGTH0_ERR,  \n\tTRANS_RX_BAD_HASH_ERR,  \n\tTRANS_RX_XRDY_ZERO_ERR,  \n\tTRANS_RX_SSP_FRAME_LEN_ERR,  \n\tTRANS_RX_TRANS_RX_RSVD1_ERR,  \n\tTRANS_RX_NO_BALANCE_ERR,  \n\tTRANS_RX_TRANS_RX_RSVD2_ERR,  \n\tTRANS_RX_TRANS_RX_RSVD3_ERR,  \n\tTRANS_RX_BAD_FRAME_TYPE_ERR,  \n\tTRANS_RX_SMP_FRAME_LEN_ERR,  \n\tTRANS_RX_SMP_RESP_TIMEOUT_ERR,  \n};\n\n#define HISI_SAS_PHY_MAX_INT_NR (HISI_SAS_PHY_INT_NR * HISI_SAS_MAX_PHYS)\n#define HISI_SAS_CQ_MAX_INT_NR (HISI_SAS_MAX_QUEUES)\n#define HISI_SAS_FATAL_INT_NR (2)\n\n#define HISI_SAS_MAX_INT_NR \\\n\t(HISI_SAS_PHY_MAX_INT_NR + HISI_SAS_CQ_MAX_INT_NR +\\\n\tHISI_SAS_FATAL_INT_NR)\n\nstatic u32 hisi_sas_read32(struct hisi_hba *hisi_hba, u32 off)\n{\n\tvoid __iomem *regs = hisi_hba->regs + off;\n\n\treturn readl(regs);\n}\n\nstatic void hisi_sas_write32(struct hisi_hba *hisi_hba,\n\t\t\t\t    u32 off, u32 val)\n{\n\tvoid __iomem *regs = hisi_hba->regs + off;\n\n\twritel(val, regs);\n}\n\nstatic void hisi_sas_phy_write32(struct hisi_hba *hisi_hba,\n\t\t\t\t\tint phy_no, u32 off, u32 val)\n{\n\tvoid __iomem *regs = hisi_hba->regs + (0x400 * phy_no) + off;\n\n\twritel(val, regs);\n}\n\nstatic u32 hisi_sas_phy_read32(struct hisi_hba *hisi_hba,\n\t\t\t\t      int phy_no, u32 off)\n{\n\tvoid __iomem *regs = hisi_hba->regs + (0x400 * phy_no) + off;\n\n\treturn readl(regs);\n}\n\nstatic void config_phy_opt_mode_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 cfg = hisi_sas_phy_read32(hisi_hba, phy_no, PHY_CFG);\n\n\tcfg &= ~PHY_CFG_DC_OPT_MSK;\n\tcfg |= 1 << PHY_CFG_DC_OPT_OFF;\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHY_CFG, cfg);\n}\n\nstatic void config_tx_tfe_autoneg_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 cfg = hisi_sas_phy_read32(hisi_hba, phy_no, PHY_CONFIG2);\n\n\tcfg &= ~PHY_CONFIG2_FORCE_TXDEEMPH_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHY_CONFIG2, cfg);\n}\n\nstatic void config_id_frame_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tstruct sas_identify_frame identify_frame;\n\tu32 *identify_buffer;\n\n\tmemset(&identify_frame, 0, sizeof(identify_frame));\n\tidentify_frame.dev_type = SAS_END_DEVICE;\n\tidentify_frame.frame_type = 0;\n\tidentify_frame._un1 = 1;\n\tidentify_frame.initiator_bits = SAS_PROTOCOL_ALL;\n\tidentify_frame.target_bits = SAS_PROTOCOL_NONE;\n\tmemcpy(&identify_frame._un4_11[0], hisi_hba->sas_addr, SAS_ADDR_SIZE);\n\tmemcpy(&identify_frame.sas_addr[0], hisi_hba->sas_addr,\tSAS_ADDR_SIZE);\n\tidentify_frame.phy_id = phy_no;\n\tidentify_buffer = (u32 *)(&identify_frame);\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD0,\n\t\t\t__swab32(identify_buffer[0]));\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD1,\n\t\t\t__swab32(identify_buffer[1]));\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD2,\n\t\t\t__swab32(identify_buffer[2]));\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD3,\n\t\t\t__swab32(identify_buffer[3]));\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD4,\n\t\t\t__swab32(identify_buffer[4]));\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD5,\n\t\t\t__swab32(identify_buffer[5]));\n}\n\nstatic void setup_itct_v1_hw(struct hisi_hba *hisi_hba,\n\t\t\t     struct hisi_sas_device *sas_dev)\n{\n\tstruct domain_device *device = sas_dev->sas_device;\n\tstruct device *dev = hisi_hba->dev;\n\tu64 qw0, device_id = sas_dev->device_id;\n\tstruct hisi_sas_itct *itct = &hisi_hba->itct[device_id];\n\tstruct asd_sas_port *sas_port = device->port;\n\tstruct hisi_sas_port *port = to_hisi_sas_port(sas_port);\n\tu64 sas_addr;\n\n\tmemset(itct, 0, sizeof(*itct));\n\n\t \n\tqw0 = 0;\n\tswitch (sas_dev->dev_type) {\n\tcase SAS_END_DEVICE:\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tqw0 = HISI_SAS_DEV_TYPE_SSP << ITCT_HDR_DEV_TYPE_OFF;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"setup itct: unsupported dev type (%d)\\n\",\n\t\t\t sas_dev->dev_type);\n\t}\n\n\tqw0 |= ((1 << ITCT_HDR_VALID_OFF) |\n\t\t(1 << ITCT_HDR_AWT_CONTROL_OFF) |\n\t\t(device->max_linkrate << ITCT_HDR_MAX_CONN_RATE_OFF) |\n\t\t(1 << ITCT_HDR_VALID_LINK_NUM_OFF) |\n\t\t(port->id << ITCT_HDR_PORT_ID_OFF));\n\titct->qw0 = cpu_to_le64(qw0);\n\n\t \n\tmemcpy(&sas_addr, device->sas_addr, SAS_ADDR_SIZE);\n\titct->sas_addr = cpu_to_le64(__swab64(sas_addr));\n\n\t \n\titct->qw2 = cpu_to_le64((500ULL << ITCT_HDR_IT_NEXUS_LOSS_TL_OFF) |\n\t\t\t\t(0xff00ULL << ITCT_HDR_BUS_INACTIVE_TL_OFF) |\n\t\t\t\t(0xff00ULL << ITCT_HDR_MAX_CONN_TL_OFF) |\n\t\t\t\t(0xff00ULL << ITCT_HDR_REJ_OPEN_TL_OFF));\n}\n\nstatic int clear_itct_v1_hw(struct hisi_hba *hisi_hba,\n\t\t\t    struct hisi_sas_device *sas_dev)\n{\n\tu64 dev_id = sas_dev->device_id;\n\tstruct hisi_sas_itct *itct = &hisi_hba->itct[dev_id];\n\tu64 qw0;\n\tu32 reg_val = hisi_sas_read32(hisi_hba, CFG_AGING_TIME);\n\n\treg_val |= CFG_AGING_TIME_ITCT_REL_MSK;\n\thisi_sas_write32(hisi_hba, CFG_AGING_TIME, reg_val);\n\n\t \n\tudelay(1);\n\treg_val = hisi_sas_read32(hisi_hba, CFG_AGING_TIME);\n\treg_val &= ~CFG_AGING_TIME_ITCT_REL_MSK;\n\thisi_sas_write32(hisi_hba, CFG_AGING_TIME, reg_val);\n\n\tqw0 = le64_to_cpu(itct->qw0);\n\tqw0 &= ~ITCT_HDR_VALID_MSK;\n\titct->qw0 = cpu_to_le64(qw0);\n\n\treturn 0;\n}\n\nstatic int reset_hw_v1_hw(struct hisi_hba *hisi_hba)\n{\n\tint i;\n\tunsigned long end_time;\n\tu32 val;\n\tstruct device *dev = hisi_hba->dev;\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\tu32 phy_ctrl = hisi_sas_phy_read32(hisi_hba, i, PHY_CTRL);\n\n\t\tphy_ctrl |= PHY_CTRL_RESET_MSK;\n\t\thisi_sas_phy_write32(hisi_hba, i, PHY_CTRL, phy_ctrl);\n\t}\n\tmsleep(1);  \n\n\t \n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\tu32 dma_tx_status, dma_rx_status;\n\n\t\tend_time = jiffies + msecs_to_jiffies(1000);\n\n\t\twhile (1) {\n\t\t\tdma_tx_status = hisi_sas_phy_read32(hisi_hba, i,\n\t\t\t\t\t\t\t    DMA_TX_STATUS);\n\t\t\tdma_rx_status = hisi_sas_phy_read32(hisi_hba, i,\n\t\t\t\t\t\t\t    DMA_RX_STATUS);\n\n\t\t\tif (!(dma_tx_status & DMA_TX_STATUS_BUSY_MSK) &&\n\t\t\t\t!(dma_rx_status & DMA_RX_STATUS_BUSY_MSK))\n\t\t\t\tbreak;\n\n\t\t\tmsleep(20);\n\t\t\tif (time_after(jiffies, end_time))\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tend_time = jiffies + msecs_to_jiffies(1000);\n\twhile (1) {\n\t\tu32 axi_status =\n\t\t\thisi_sas_read32(hisi_hba, AXI_CFG);\n\n\t\tif (axi_status == 0)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t\tif (time_after(jiffies, end_time))\n\t\t\treturn -EIO;\n\t}\n\n\tif (ACPI_HANDLE(dev)) {\n\t\tacpi_status s;\n\n\t\ts = acpi_evaluate_object(ACPI_HANDLE(dev), \"_RST\", NULL, NULL);\n\t\tif (ACPI_FAILURE(s)) {\n\t\t\tdev_err(dev, \"Reset failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else if (hisi_hba->ctrl) {\n\t\t \n\t\t \n\t\tregmap_write(hisi_hba->ctrl, hisi_hba->ctrl_reset_reg,\n\t\t\t     RESET_VALUE);\n\t\tregmap_write(hisi_hba->ctrl, hisi_hba->ctrl_clock_ena_reg + 4,\n\t\t\t     RESET_VALUE);\n\t\tmsleep(1);\n\t\tregmap_read(hisi_hba->ctrl, hisi_hba->ctrl_reset_sts_reg, &val);\n\t\tif (RESET_VALUE != (val & RESET_VALUE)) {\n\t\t\tdev_err(dev, \"Reset failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\t \n\t\tregmap_write(hisi_hba->ctrl, hisi_hba->ctrl_reset_reg + 4,\n\t\t\t     RESET_VALUE);\n\t\tregmap_write(hisi_hba->ctrl, hisi_hba->ctrl_clock_ena_reg,\n\t\t\t     RESET_VALUE);\n\t\tmsleep(1);\n\t\tregmap_read(hisi_hba->ctrl, hisi_hba->ctrl_reset_sts_reg, &val);\n\t\tif (val & RESET_VALUE) {\n\t\t\tdev_err(dev, \"De-reset failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\tdev_warn(dev, \"no reset method\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void init_reg_v1_hw(struct hisi_hba *hisi_hba)\n{\n\tint i;\n\n\t \n\thisi_sas_write32(hisi_hba, DLVRY_QUEUE_ENABLE,\n\t\t\t (u32)((1ULL << hisi_hba->queue_count) - 1));\n\thisi_sas_write32(hisi_hba, HGC_TRANS_TASK_CNT_LIMIT, 0x11);\n\thisi_sas_write32(hisi_hba, DEVICE_MSG_WORK_MODE, 0x1);\n\thisi_sas_write32(hisi_hba, HGC_SAS_TXFAIL_RETRY_CTRL, 0x1ff);\n\thisi_sas_write32(hisi_hba, HGC_ERR_STAT_EN, 0x401);\n\thisi_sas_write32(hisi_hba, CFG_1US_TIMER_TRSH, 0x64);\n\thisi_sas_write32(hisi_hba, HGC_GET_ITV_TIME, 0x1);\n\thisi_sas_write32(hisi_hba, I_T_NEXUS_LOSS_TIME, 0x64);\n\thisi_sas_write32(hisi_hba, BUS_INACTIVE_LIMIT_TIME, 0x2710);\n\thisi_sas_write32(hisi_hba, REJECT_TO_OPEN_LIMIT_TIME, 0x1);\n\thisi_sas_write32(hisi_hba, CFG_AGING_TIME, 0x7a12);\n\thisi_sas_write32(hisi_hba, HGC_DFX_CFG2, 0x9c40);\n\thisi_sas_write32(hisi_hba, FIS_LIST_BADDR_L, 0x2);\n\thisi_sas_write32(hisi_hba, INT_COAL_EN, 0xc);\n\thisi_sas_write32(hisi_hba, OQ_INT_COAL_TIME, 0x186a0);\n\thisi_sas_write32(hisi_hba, OQ_INT_COAL_CNT, 1);\n\thisi_sas_write32(hisi_hba, ENT_INT_COAL_TIME, 0x1);\n\thisi_sas_write32(hisi_hba, ENT_INT_COAL_CNT, 0x1);\n\thisi_sas_write32(hisi_hba, OQ_INT_SRC, 0xffffffff);\n\thisi_sas_write32(hisi_hba, OQ_INT_SRC_MSK, 0);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC1, 0xffffffff);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK1, 0);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC2, 0xffffffff);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK2, 0);\n\thisi_sas_write32(hisi_hba, SAS_ECC_INTR_MSK, 0);\n\thisi_sas_write32(hisi_hba, AXI_AHB_CLK_CFG, 0x2);\n\thisi_sas_write32(hisi_hba, CFG_SAS_CONFIG, 0x22000000);\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\thisi_sas_phy_write32(hisi_hba, i, PROG_PHY_LINK_RATE, 0x88a);\n\t\thisi_sas_phy_write32(hisi_hba, i, PHY_CONFIG2, 0x7c080);\n\t\thisi_sas_phy_write32(hisi_hba, i, PHY_RATE_NEGO, 0x415ee00);\n\t\thisi_sas_phy_write32(hisi_hba, i, PHY_PCN, 0x80a80000);\n\t\thisi_sas_phy_write32(hisi_hba, i, SL_TOUT_CFG, 0x7d7d7d7d);\n\t\thisi_sas_phy_write32(hisi_hba, i, DONE_RECEIVED_TIME, 0x0);\n\t\thisi_sas_phy_write32(hisi_hba, i, RXOP_CHECK_CFG_H, 0x1000);\n\t\thisi_sas_phy_write32(hisi_hba, i, DONE_RECEIVED_TIME, 0);\n\t\thisi_sas_phy_write32(hisi_hba, i, CON_CFG_DRIVER, 0x13f0a);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT_COAL_EN, 3);\n\t\thisi_sas_phy_write32(hisi_hba, i, DONE_RECEIVED_TIME, 8);\n\t}\n\n\tfor (i = 0; i < hisi_hba->queue_count; i++) {\n\t\t \n\t\thisi_sas_write32(hisi_hba,\n\t\t\t\t DLVRY_Q_0_BASE_ADDR_HI + (i * 0x14),\n\t\t\t\t upper_32_bits(hisi_hba->cmd_hdr_dma[i]));\n\n\t\thisi_sas_write32(hisi_hba,\n\t\t\t\t DLVRY_Q_0_BASE_ADDR_LO + (i * 0x14),\n\t\t\t\t lower_32_bits(hisi_hba->cmd_hdr_dma[i]));\n\n\t\thisi_sas_write32(hisi_hba,\n\t\t\t\t DLVRY_Q_0_DEPTH + (i * 0x14),\n\t\t\t\t HISI_SAS_QUEUE_SLOTS);\n\n\t\t \n\t\thisi_sas_write32(hisi_hba,\n\t\t\t\t COMPL_Q_0_BASE_ADDR_HI + (i * 0x14),\n\t\t\t\t upper_32_bits(hisi_hba->complete_hdr_dma[i]));\n\n\t\thisi_sas_write32(hisi_hba,\n\t\t\t\t COMPL_Q_0_BASE_ADDR_LO + (i * 0x14),\n\t\t\t\t lower_32_bits(hisi_hba->complete_hdr_dma[i]));\n\n\t\thisi_sas_write32(hisi_hba, COMPL_Q_0_DEPTH + (i * 0x14),\n\t\t\t\t HISI_SAS_QUEUE_SLOTS);\n\t}\n\n\t \n\thisi_sas_write32(hisi_hba, ITCT_BASE_ADDR_LO,\n\t\t\t lower_32_bits(hisi_hba->itct_dma));\n\n\thisi_sas_write32(hisi_hba, ITCT_BASE_ADDR_HI,\n\t\t\t upper_32_bits(hisi_hba->itct_dma));\n\n\t \n\thisi_sas_write32(hisi_hba, IOST_BASE_ADDR_LO,\n\t\t\t lower_32_bits(hisi_hba->iost_dma));\n\n\thisi_sas_write32(hisi_hba, IOST_BASE_ADDR_HI,\n\t\t\t upper_32_bits(hisi_hba->iost_dma));\n\n\t \n\thisi_sas_write32(hisi_hba, BROKEN_MSG_ADDR_LO,\n\t\t\t lower_32_bits(hisi_hba->breakpoint_dma));\n\n\thisi_sas_write32(hisi_hba, BROKEN_MSG_ADDR_HI,\n\t\t\t upper_32_bits(hisi_hba->breakpoint_dma));\n}\n\nstatic int hw_init_v1_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tint rc;\n\n\trc = reset_hw_v1_hw(hisi_hba);\n\tif (rc) {\n\t\tdev_err(dev, \"hisi_sas_reset_hw failed, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tmsleep(100);\n\tinit_reg_v1_hw(hisi_hba);\n\n\treturn 0;\n}\n\nstatic void enable_phy_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 cfg = hisi_sas_phy_read32(hisi_hba, phy_no, PHY_CFG);\n\n\tcfg |= PHY_CFG_ENA_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHY_CFG, cfg);\n}\n\nstatic void disable_phy_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 cfg = hisi_sas_phy_read32(hisi_hba, phy_no, PHY_CFG);\n\n\tcfg &= ~PHY_CFG_ENA_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHY_CFG, cfg);\n}\n\nstatic void start_phy_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tconfig_id_frame_v1_hw(hisi_hba, phy_no);\n\tconfig_phy_opt_mode_v1_hw(hisi_hba, phy_no);\n\tconfig_tx_tfe_autoneg_v1_hw(hisi_hba, phy_no);\n\tenable_phy_v1_hw(hisi_hba, phy_no);\n}\n\nstatic void phy_hard_reset_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\thisi_sas_phy_enable(hisi_hba, phy_no, 0);\n\tmsleep(100);\n\thisi_sas_phy_enable(hisi_hba, phy_no, 1);\n}\n\nstatic void start_phys_v1_hw(struct timer_list *t)\n{\n\tstruct hisi_hba *hisi_hba = from_timer(hisi_hba, t, timer);\n\tint i;\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT2_MSK, 0x12a);\n\t\thisi_sas_phy_enable(hisi_hba, i, 1);\n\t}\n}\n\nstatic void phys_init_v1_hw(struct hisi_hba *hisi_hba)\n{\n\tint i;\n\tstruct timer_list *timer = &hisi_hba->timer;\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT2_MSK, 0x6a);\n\t\thisi_sas_phy_read32(hisi_hba, i, CHL_INT2_MSK);\n\t}\n\n\ttimer_setup(timer, start_phys_v1_hw, 0);\n\tmod_timer(timer, jiffies + HZ);\n}\n\nstatic void sl_notify_ssp_v1_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 sl_control;\n\n\tsl_control = hisi_sas_phy_read32(hisi_hba, phy_no, SL_CONTROL);\n\tsl_control |= SL_CONTROL_NOTIFY_EN_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, SL_CONTROL, sl_control);\n\tmsleep(1);\n\tsl_control = hisi_sas_phy_read32(hisi_hba, phy_no, SL_CONTROL);\n\tsl_control &= ~SL_CONTROL_NOTIFY_EN_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, SL_CONTROL, sl_control);\n}\n\nstatic enum sas_linkrate phy_get_max_linkrate_v1_hw(void)\n{\n\treturn SAS_LINK_RATE_6_0_GBPS;\n}\n\nstatic void phy_set_linkrate_v1_hw(struct hisi_hba *hisi_hba, int phy_no,\n\t\tstruct sas_phy_linkrates *r)\n{\n\tenum sas_linkrate max = r->maximum_linkrate;\n\tu32 prog_phy_link_rate = 0x800;\n\n\tprog_phy_link_rate |= hisi_sas_get_prog_phy_linkrate_mask(max);\n\thisi_sas_phy_write32(hisi_hba, phy_no, PROG_PHY_LINK_RATE,\n\t\t\t     prog_phy_link_rate);\n}\n\nstatic int get_wideport_bitmap_v1_hw(struct hisi_hba *hisi_hba, int port_id)\n{\n\tint i, bitmap = 0;\n\tu32 phy_port_num_ma = hisi_sas_read32(hisi_hba, PHY_PORT_NUM_MA);\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++)\n\t\tif (((phy_port_num_ma >> (i * 4)) & 0xf) == port_id)\n\t\t\tbitmap |= 1 << i;\n\n\treturn bitmap;\n}\n\n \nstatic void start_delivery_v1_hw(struct hisi_sas_dq *dq)\n{\n\tstruct hisi_hba *hisi_hba = dq->hisi_hba;\n\tstruct hisi_sas_slot *s, *s1, *s2 = NULL;\n\tint dlvry_queue = dq->id;\n\tint wp;\n\n\tlist_for_each_entry_safe(s, s1, &dq->list, delivery) {\n\t\tif (!s->ready)\n\t\t\tbreak;\n\t\ts2 = s;\n\t\tlist_del(&s->delivery);\n\t}\n\n\tif (!s2)\n\t\treturn;\n\n\t \n\tsmp_rmb();\n\twp = (s2->dlvry_queue_slot + 1) % HISI_SAS_QUEUE_SLOTS;\n\n\thisi_sas_write32(hisi_hba, DLVRY_Q_0_WR_PTR + (dlvry_queue * 0x14), wp);\n}\n\nstatic void prep_prd_sge_v1_hw(struct hisi_hba *hisi_hba,\n\t\t\t      struct hisi_sas_slot *slot,\n\t\t\t      struct hisi_sas_cmd_hdr *hdr,\n\t\t\t      struct scatterlist *scatter,\n\t\t\t      int n_elem)\n{\n\tstruct hisi_sas_sge_page *sge_page = hisi_sas_sge_addr_mem(slot);\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(scatter, sg, n_elem, i) {\n\t\tstruct hisi_sas_sge *entry = &sge_page->sge[i];\n\n\t\tentry->addr = cpu_to_le64(sg_dma_address(sg));\n\t\tentry->page_ctrl_0 = entry->page_ctrl_1 = 0;\n\t\tentry->data_len = cpu_to_le32(sg_dma_len(sg));\n\t\tentry->data_off = 0;\n\t}\n\n\thdr->prd_table_addr = cpu_to_le64(hisi_sas_sge_addr_dma(slot));\n\n\thdr->sg_len = cpu_to_le32(n_elem << CMD_HDR_DATA_SGL_LEN_OFF);\n}\n\nstatic void prep_smp_v1_hw(struct hisi_hba *hisi_hba,\n\t\t\t  struct hisi_sas_slot *slot)\n{\n\tstruct sas_task *task = slot->task;\n\tstruct hisi_sas_cmd_hdr *hdr = slot->cmd_hdr;\n\tstruct domain_device *device = task->dev;\n\tstruct hisi_sas_port *port = slot->port;\n\tstruct scatterlist *sg_req;\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tdma_addr_t req_dma_addr;\n\tunsigned int req_len;\n\n\t \n\tsg_req = &task->smp_task.smp_req;\n\treq_len = sg_dma_len(sg_req);\n\treq_dma_addr = sg_dma_address(sg_req);\n\n\t \n\t \n\thdr->dw0 = cpu_to_le32((port->id << CMD_HDR_PORT_OFF) |\n\t\t\t       (1 << CMD_HDR_PRIORITY_OFF) |  \n\t\t\t       (1 << CMD_HDR_MODE_OFF) |  \n\t\t\t       (2 << CMD_HDR_CMD_OFF));  \n\n\t \n\thdr->dw1 = cpu_to_le32(sas_dev->device_id << CMD_HDR_DEVICE_ID_OFF);\n\n\t \n\thdr->dw2 = cpu_to_le32((((req_len-4)/4) << CMD_HDR_CFL_OFF) |\n\t\t\t       (HISI_SAS_MAX_SMP_RESP_SZ/4 <<\n\t\t\t       CMD_HDR_MRFL_OFF));\n\n\thdr->transfer_tags = cpu_to_le32(slot->idx << CMD_HDR_IPTT_OFF);\n\n\thdr->cmd_table_addr = cpu_to_le64(req_dma_addr);\n\thdr->sts_buffer_addr = cpu_to_le64(hisi_sas_status_buf_addr_dma(slot));\n}\n\nstatic void prep_ssp_v1_hw(struct hisi_hba *hisi_hba,\n\t\t\t  struct hisi_sas_slot *slot)\n{\n\tstruct sas_task *task = slot->task;\n\tstruct hisi_sas_cmd_hdr *hdr = slot->cmd_hdr;\n\tstruct domain_device *device = task->dev;\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tstruct hisi_sas_port *port = slot->port;\n\tstruct sas_ssp_task *ssp_task = &task->ssp_task;\n\tstruct scsi_cmnd *scsi_cmnd = ssp_task->cmd;\n\tstruct sas_tmf_task *tmf = slot->tmf;\n\tint has_data = 0, priority = !!tmf;\n\tu8 *buf_cmd;\n\tu32 dw1, dw2;\n\n\t \n\thdr->dw0 = cpu_to_le32((1 << CMD_HDR_RESP_REPORT_OFF) |\n\t\t\t       (0x2 << CMD_HDR_TLR_CTRL_OFF) |\n\t\t\t       (port->id << CMD_HDR_PORT_OFF) |\n\t\t\t       (priority << CMD_HDR_PRIORITY_OFF) |\n\t\t\t       (1 << CMD_HDR_MODE_OFF) |  \n\t\t\t       (1 << CMD_HDR_CMD_OFF));  \n\n\tdw1 = 1 << CMD_HDR_VERIFY_DTL_OFF;\n\n\tif (tmf) {\n\t\tdw1 |= 3 << CMD_HDR_SSP_FRAME_TYPE_OFF;\n\t} else {\n\t\tswitch (scsi_cmnd->sc_data_direction) {\n\t\tcase DMA_TO_DEVICE:\n\t\t\tdw1 |= 2 << CMD_HDR_SSP_FRAME_TYPE_OFF;\n\t\t\thas_data = 1;\n\t\t\tbreak;\n\t\tcase DMA_FROM_DEVICE:\n\t\t\tdw1 |= 1 << CMD_HDR_SSP_FRAME_TYPE_OFF;\n\t\t\thas_data = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdw1 |= 0 << CMD_HDR_SSP_FRAME_TYPE_OFF;\n\t\t}\n\t}\n\n\t \n\tdw1 |= sas_dev->device_id << CMD_HDR_DEVICE_ID_OFF;\n\thdr->dw1 = cpu_to_le32(dw1);\n\n\tif (tmf) {\n\t\tdw2 = ((sizeof(struct ssp_tmf_iu) +\n\t\t\tsizeof(struct ssp_frame_hdr)+3)/4) <<\n\t\t\tCMD_HDR_CFL_OFF;\n\t} else {\n\t\tdw2 = ((sizeof(struct ssp_command_iu) +\n\t\t\tsizeof(struct ssp_frame_hdr)+3)/4) <<\n\t\t\tCMD_HDR_CFL_OFF;\n\t}\n\n\tdw2 |= (HISI_SAS_MAX_SSP_RESP_SZ/4) << CMD_HDR_MRFL_OFF;\n\n\thdr->transfer_tags = cpu_to_le32(slot->idx << CMD_HDR_IPTT_OFF);\n\n\tif (has_data)\n\t\tprep_prd_sge_v1_hw(hisi_hba, slot, hdr, task->scatter,\n\t\t\t\t\tslot->n_elem);\n\n\thdr->data_transfer_len = cpu_to_le32(task->total_xfer_len);\n\thdr->cmd_table_addr = cpu_to_le64(hisi_sas_cmd_hdr_addr_dma(slot));\n\thdr->sts_buffer_addr = cpu_to_le64(hisi_sas_status_buf_addr_dma(slot));\n\n\tbuf_cmd = hisi_sas_cmd_hdr_addr_mem(slot) +\n\t\tsizeof(struct ssp_frame_hdr);\n\thdr->dw2 = cpu_to_le32(dw2);\n\n\tmemcpy(buf_cmd, &task->ssp_task.LUN, 8);\n\tif (!tmf) {\n\t\tbuf_cmd[9] = task->ssp_task.task_attr;\n\t\tmemcpy(buf_cmd + 12, task->ssp_task.cmd->cmnd,\n\t\t\t\ttask->ssp_task.cmd->cmd_len);\n\t} else {\n\t\tbuf_cmd[10] = tmf->tmf;\n\t\tswitch (tmf->tmf) {\n\t\tcase TMF_ABORT_TASK:\n\t\tcase TMF_QUERY_TASK:\n\t\t\tbuf_cmd[12] =\n\t\t\t\t(tmf->tag_of_task_to_be_managed >> 8) & 0xff;\n\t\t\tbuf_cmd[13] =\n\t\t\t\ttmf->tag_of_task_to_be_managed & 0xff;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void slot_err_v1_hw(struct hisi_hba *hisi_hba,\n\t\t\t   struct sas_task *task,\n\t\t\t   struct hisi_sas_slot *slot)\n{\n\tstruct task_status_struct *ts = &task->task_status;\n\tstruct hisi_sas_err_record_v1 *err_record =\n\t\t\thisi_sas_status_buf_addr_mem(slot);\n\tstruct device *dev = hisi_hba->dev;\n\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SSP:\n\t{\n\t\tint error = -1;\n\t\tu32 dma_err_type = le32_to_cpu(err_record->dma_err_type);\n\t\tu32 dma_tx_err_type = ((dma_err_type &\n\t\t\t\t\tERR_HDR_DMA_TX_ERR_TYPE_MSK)) >>\n\t\t\t\t\tERR_HDR_DMA_TX_ERR_TYPE_OFF;\n\t\tu32 dma_rx_err_type = ((dma_err_type &\n\t\t\t\t\tERR_HDR_DMA_RX_ERR_TYPE_MSK)) >>\n\t\t\t\t\tERR_HDR_DMA_RX_ERR_TYPE_OFF;\n\t\tu32 trans_tx_fail_type =\n\t\t\t\tle32_to_cpu(err_record->trans_tx_fail_type);\n\t\tu32 trans_rx_fail_type =\n\t\t\t\tle32_to_cpu(err_record->trans_rx_fail_type);\n\n\t\tif (dma_tx_err_type) {\n\t\t\t \n\t\t\terror = ffs(dma_tx_err_type)\n\t\t\t\t- 1 + DMA_TX_ERR_BASE;\n\t\t} else if (dma_rx_err_type) {\n\t\t\t \n\t\t\terror = ffs(dma_rx_err_type)\n\t\t\t\t- 1 + DMA_RX_ERR_BASE;\n\t\t} else if (trans_tx_fail_type) {\n\t\t\t \n\t\t\terror = ffs(trans_tx_fail_type)\n\t\t\t\t- 1 + TRANS_TX_FAIL_BASE;\n\t\t} else if (trans_rx_fail_type) {\n\t\t\t \n\t\t\terror = ffs(trans_rx_fail_type)\n\t\t\t\t- 1 + TRANS_RX_FAIL_BASE;\n\t\t}\n\n\t\tswitch (error) {\n\t\tcase DMA_TX_DATA_UNDERFLOW_ERR:\n\t\tcase DMA_RX_DATA_UNDERFLOW_ERR:\n\t\t{\n\t\t\tts->residual = 0;\n\t\t\tts->stat = SAS_DATA_UNDERRUN;\n\t\t\tbreak;\n\t\t}\n\t\tcase DMA_TX_DATA_SGL_OVERFLOW_ERR:\n\t\tcase DMA_TX_DIF_SGL_OVERFLOW_ERR:\n\t\tcase DMA_TX_XFER_RDY_LENGTH_OVERFLOW_ERR:\n\t\tcase DMA_RX_DATA_OVERFLOW_ERR:\n\t\tcase TRANS_RX_FRAME_OVERRUN_ERR:\n\t\tcase TRANS_RX_LINK_BUF_OVERRUN_ERR:\n\t\t{\n\t\t\tts->stat = SAS_DATA_OVERRUN;\n\t\t\tts->residual = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_PHY_NOT_ENABLE_ERR:\n\t\t{\n\t\t\tts->stat = SAS_PHY_DOWN;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_OPEN_REJCT_WRONG_DEST_ERR:\n\t\tcase TRANS_TX_OPEN_REJCT_ZONE_VIOLATION_ERR:\n\t\tcase TRANS_TX_OPEN_REJCT_BY_OTHER_ERR:\n\t\tcase TRANS_TX_OPEN_REJCT_AIP_TIMEOUT_ERR:\n\t\tcase TRANS_TX_OPEN_REJCT_STP_BUSY_ERR:\n\t\tcase TRANS_TX_OPEN_REJCT_PROTOCOL_NOT_SUPPORT_ERR:\n\t\tcase TRANS_TX_OPEN_REJCT_RATE_NOT_SUPPORT_ERR:\n\t\tcase TRANS_TX_OPEN_REJCT_BAD_DEST_ERR:\n\t\tcase TRANS_TX_OPEN_BREAK_RECEIVE_ERR:\n\t\tcase TRANS_TX_OPEN_REJCT_PATHWAY_BLOCKED_ERR:\n\t\tcase TRANS_TX_OPEN_REJCT_NO_DEST_ERR:\n\t\tcase TRANS_TX_OPEN_RETRY_ERR:\n\t\t{\n\t\t\tts->stat = SAS_OPEN_REJECT;\n\t\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_OPEN_TIMEOUT_ERR:\n\t\t{\n\t\t\tts->stat = SAS_OPEN_TO;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_NAK_RECEIVE_ERR:\n\t\tcase TRANS_TX_ACK_NAK_TIMEOUT_ERR:\n\t\t{\n\t\t\tts->stat = SAS_NAK_R_ERR;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_CREDIT_TIMEOUT_ERR:\n\t\tcase TRANS_TX_CLOSE_NORMAL_ERR:\n\t\t{\n\t\t\t \n\t\t\tts->stat = SAS_QUEUE_FULL;\n\t\t\tslot->abort = 1;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t{\n\t\t\tts->stat = SAS_SAM_STAT_CHECK_CONDITION;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\t\tbreak;\n\tcase SAS_PROTOCOL_SMP:\n\t\tts->stat = SAS_SAM_STAT_CHECK_CONDITION;\n\t\tbreak;\n\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\tcase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:\n\t{\n\t\tdev_err(dev, \"slot err: SATA/STP not supported\\n\");\n\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n}\n\nstatic void slot_complete_v1_hw(struct hisi_hba *hisi_hba,\n\t\t\t\tstruct hisi_sas_slot *slot)\n{\n\tstruct sas_task *task = slot->task;\n\tstruct hisi_sas_device *sas_dev;\n\tstruct device *dev = hisi_hba->dev;\n\tstruct task_status_struct *ts;\n\tstruct domain_device *device;\n\tstruct hisi_sas_complete_v1_hdr *complete_queue =\n\t\t\thisi_hba->complete_hdr[slot->cmplt_queue];\n\tstruct hisi_sas_complete_v1_hdr *complete_hdr;\n\tunsigned long flags;\n\tu32 cmplt_hdr_data;\n\n\tcomplete_hdr = &complete_queue[slot->cmplt_queue_slot];\n\tcmplt_hdr_data = le32_to_cpu(complete_hdr->data);\n\n\tif (unlikely(!task || !task->lldd_task || !task->dev))\n\t\treturn;\n\n\tts = &task->task_status;\n\tdevice = task->dev;\n\tsas_dev = device->lldd_dev;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\ttask->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\ttask->task_state_flags |= SAS_TASK_STATE_DONE;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tmemset(ts, 0, sizeof(*ts));\n\tts->resp = SAS_TASK_COMPLETE;\n\n\tif (unlikely(!sas_dev)) {\n\t\tdev_dbg(dev, \"slot complete: port has no device\\n\");\n\t\tts->stat = SAS_PHY_DOWN;\n\t\tgoto out;\n\t}\n\n\tif (cmplt_hdr_data & CMPLT_HDR_IO_CFG_ERR_MSK) {\n\t\tu32 info_reg = hisi_sas_read32(hisi_hba, HGC_INVLD_DQE_INFO);\n\n\t\tif (info_reg & HGC_INVLD_DQE_INFO_DQ_MSK)\n\t\t\tdev_err(dev, \"slot complete: [%d:%d] has dq IPTT err\\n\",\n\t\t\t\tslot->cmplt_queue, slot->cmplt_queue_slot);\n\n\t\tif (info_reg & HGC_INVLD_DQE_INFO_TYPE_MSK)\n\t\t\tdev_err(dev, \"slot complete: [%d:%d] has dq type err\\n\",\n\t\t\t\tslot->cmplt_queue, slot->cmplt_queue_slot);\n\n\t\tif (info_reg & HGC_INVLD_DQE_INFO_FORCE_MSK)\n\t\t\tdev_err(dev, \"slot complete: [%d:%d] has dq force phy err\\n\",\n\t\t\t\tslot->cmplt_queue, slot->cmplt_queue_slot);\n\n\t\tif (info_reg & HGC_INVLD_DQE_INFO_PHY_MSK)\n\t\t\tdev_err(dev, \"slot complete: [%d:%d] has dq phy id err\\n\",\n\t\t\t\tslot->cmplt_queue, slot->cmplt_queue_slot);\n\n\t\tif (info_reg & HGC_INVLD_DQE_INFO_ABORT_MSK)\n\t\t\tdev_err(dev, \"slot complete: [%d:%d] has dq abort flag err\\n\",\n\t\t\t\tslot->cmplt_queue, slot->cmplt_queue_slot);\n\n\t\tif (info_reg & HGC_INVLD_DQE_INFO_IPTT_OF_MSK)\n\t\t\tdev_err(dev, \"slot complete: [%d:%d] has dq IPTT or ICT err\\n\",\n\t\t\t\tslot->cmplt_queue, slot->cmplt_queue_slot);\n\n\t\tif (info_reg & HGC_INVLD_DQE_INFO_SSP_ERR_MSK)\n\t\t\tdev_err(dev, \"slot complete: [%d:%d] has dq SSP frame type err\\n\",\n\t\t\t\tslot->cmplt_queue, slot->cmplt_queue_slot);\n\n\t\tif (info_reg & HGC_INVLD_DQE_INFO_OFL_MSK)\n\t\t\tdev_err(dev, \"slot complete: [%d:%d] has dq order frame len err\\n\",\n\t\t\t\tslot->cmplt_queue, slot->cmplt_queue_slot);\n\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tgoto out;\n\t}\n\n\tif (cmplt_hdr_data & CMPLT_HDR_ERR_RCRD_XFRD_MSK &&\n\t\t!(cmplt_hdr_data & CMPLT_HDR_RSPNS_XFRD_MSK)) {\n\n\t\tslot_err_v1_hw(hisi_hba, task, slot);\n\t\tif (unlikely(slot->abort)) {\n\t\t\tif (dev_is_sata(device) && task->ata_task.use_ncq)\n\t\t\t\tsas_ata_device_link_abort(device, true);\n\t\t\telse\n\t\t\t\tsas_task_abort(task);\n\n\t\t\treturn;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SSP:\n\t{\n\t\tstruct hisi_sas_status_buffer *status_buffer =\n\t\t\t\thisi_sas_status_buf_addr_mem(slot);\n\t\tstruct ssp_response_iu *iu = (struct ssp_response_iu *)\n\t\t\t\t&status_buffer->iu[0];\n\n\t\tsas_ssp_task_response(dev, task, iu);\n\t\tbreak;\n\t}\n\tcase SAS_PROTOCOL_SMP:\n\t{\n\t\tstruct scatterlist *sg_resp = &task->smp_task.smp_resp;\n\t\tvoid *to = page_address(sg_page(sg_resp));\n\n\t\tts->stat = SAS_SAM_STAT_GOOD;\n\n\t\tmemcpy(to + sg_resp->offset,\n\t\t       hisi_sas_status_buf_addr_mem(slot) +\n\t\t       sizeof(struct hisi_sas_err_record),\n\t\t       sg_resp->length);\n\t\tbreak;\n\t}\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\tcase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:\n\t\tdev_err(dev, \"slot complete: SATA/STP not supported\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tts->stat = SAS_SAM_STAT_CHECK_CONDITION;\n\t\tbreak;\n\t}\n\n\tif (!slot->port->port_attached) {\n\t\tdev_err(dev, \"slot complete: port %d has removed\\n\",\n\t\t\tslot->port->sas_port.id);\n\t\tts->stat = SAS_PHY_DOWN;\n\t}\n\nout:\n\thisi_sas_slot_task_free(hisi_hba, task, slot, true);\n\n\tif (task->task_done)\n\t\ttask->task_done(task);\n}\n\n \nstatic irqreturn_t int_phyup_v1_hw(int irq_no, void *p)\n{\n\tstruct hisi_sas_phy *phy = p;\n\tstruct hisi_hba *hisi_hba = phy->hisi_hba;\n\tstruct device *dev = hisi_hba->dev;\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tint i, phy_no = sas_phy->id;\n\tu32 irq_value, context, port_id, link_rate;\n\tu32 *frame_rcvd = (u32 *)sas_phy->frame_rcvd;\n\tstruct sas_identify_frame *id = (struct sas_identify_frame *)frame_rcvd;\n\tirqreturn_t res = IRQ_HANDLED;\n\n\tirq_value = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT2);\n\tif (!(irq_value & CHL_INT2_SL_PHY_ENA_MSK)) {\n\t\tdev_dbg(dev, \"phyup: irq_value = %x not set enable bit\\n\",\n\t\t\tirq_value);\n\t\tres = IRQ_NONE;\n\t\tgoto end;\n\t}\n\n\tcontext = hisi_sas_read32(hisi_hba, PHY_CONTEXT);\n\tif (context & 1 << phy_no) {\n\t\tdev_err(dev, \"phyup: phy%d SATA attached equipment\\n\",\n\t\t\tphy_no);\n\t\tgoto end;\n\t}\n\n\tport_id = (hisi_sas_read32(hisi_hba, PHY_PORT_NUM_MA) >> (4 * phy_no))\n\t\t  & 0xf;\n\tif (port_id == 0xf) {\n\t\tdev_err(dev, \"phyup: phy%d invalid portid\\n\", phy_no);\n\t\tres = IRQ_NONE;\n\t\tgoto end;\n\t}\n\n\tfor (i = 0; i < 6; i++) {\n\t\tu32 idaf = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\tRX_IDAF_DWORD0 + (i * 4));\n\t\tframe_rcvd[i] = __swab32(idaf);\n\t}\n\n\t \n\tlink_rate = hisi_sas_read32(hisi_hba, PHY_CONN_RATE);\n\tlink_rate = (link_rate >> (phy_no * 4)) & 0xf;\n\tsas_phy->linkrate = link_rate;\n\tsas_phy->oob_mode = SAS_OOB_MODE;\n\tmemcpy(sas_phy->attached_sas_addr,\n\t\t&id->sas_addr, SAS_ADDR_SIZE);\n\tdev_info(dev, \"phyup: phy%d link_rate=%d\\n\",\n\t\t phy_no, link_rate);\n\tphy->port_id = port_id;\n\tphy->phy_type &= ~(PORT_TYPE_SAS | PORT_TYPE_SATA);\n\tphy->phy_type |= PORT_TYPE_SAS;\n\tphy->phy_attached = 1;\n\tphy->identify.device_type = id->dev_type;\n\tphy->frame_rcvd_size =\tsizeof(struct sas_identify_frame);\n\tif (phy->identify.device_type == SAS_END_DEVICE)\n\t\tphy->identify.target_port_protocols =\n\t\t\tSAS_PROTOCOL_SSP;\n\telse if (phy->identify.device_type != SAS_PHY_UNUSED)\n\t\tphy->identify.target_port_protocols =\n\t\t\tSAS_PROTOCOL_SMP;\n\thisi_sas_notify_phy_event(phy, HISI_PHYE_PHY_UP);\nend:\n\tif (phy->reset_completion)\n\t\tcomplete(phy->reset_completion);\n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT2,\n\t\t\t     CHL_INT2_SL_PHY_ENA_MSK);\n\n\tif (irq_value & CHL_INT2_SL_PHY_ENA_MSK) {\n\t\tu32 chl_int0 = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT0);\n\n\t\tchl_int0 &= ~CHL_INT0_PHYCTRL_NOTRDY_MSK;\n\t\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0, chl_int0);\n\t\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0_MSK, 0x3ce3ee);\n\t}\n\n\treturn res;\n}\n\nstatic irqreturn_t int_bcast_v1_hw(int irq, void *p)\n{\n\tstruct hisi_sas_phy *phy = p;\n\tstruct hisi_hba *hisi_hba = phy->hisi_hba;\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tstruct device *dev = hisi_hba->dev;\n\tint phy_no = sas_phy->id;\n\tu32 irq_value;\n\tirqreturn_t res = IRQ_HANDLED;\n\n\tirq_value = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT2);\n\n\tif (!(irq_value & CHL_INT2_SL_RX_BC_ACK_MSK)) {\n\t\tdev_err(dev, \"bcast: irq_value = %x not set enable bit\\n\",\n\t\t\tirq_value);\n\t\tres = IRQ_NONE;\n\t\tgoto end;\n\t}\n\n\thisi_sas_phy_bcast(phy);\n\nend:\n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT2,\n\t\t\t     CHL_INT2_SL_RX_BC_ACK_MSK);\n\n\treturn res;\n}\n\nstatic irqreturn_t int_abnormal_v1_hw(int irq, void *p)\n{\n\tstruct hisi_sas_phy *phy = p;\n\tstruct hisi_hba *hisi_hba = phy->hisi_hba;\n\tstruct device *dev = hisi_hba->dev;\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tu32 irq_value, irq_mask_old;\n\tint phy_no = sas_phy->id;\n\n\t \n\tirq_mask_old = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT0_MSK);\n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0_MSK, 0x3fffff);\n\n\t \n\tirq_value = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT0);\n\n\tif (irq_value & CHL_INT0_PHYCTRL_NOTRDY_MSK) {\n\t\tu32 phy_state = hisi_sas_read32(hisi_hba, PHY_STATE);\n\n\t\thisi_sas_phy_down(hisi_hba, phy_no,\n\t\t\t\t  (phy_state & 1 << phy_no) ? 1 : 0,\n\t\t\t\t  GFP_ATOMIC);\n\t}\n\n\tif (irq_value & CHL_INT0_ID_TIMEOUT_MSK)\n\t\tdev_dbg(dev, \"abnormal: ID_TIMEOUT phy%d identify timeout\\n\",\n\t\t\tphy_no);\n\n\tif (irq_value & CHL_INT0_DWS_LOST_MSK)\n\t\tdev_dbg(dev, \"abnormal: DWS_LOST phy%d dws lost\\n\", phy_no);\n\n\tif (irq_value & CHL_INT0_SN_FAIL_NGR_MSK)\n\t\tdev_dbg(dev, \"abnormal: SN_FAIL_NGR phy%d sn fail ngr\\n\",\n\t\t\tphy_no);\n\n\tif (irq_value & CHL_INT0_SL_IDAF_FAIL_MSK ||\n\t\tirq_value & CHL_INT0_SL_OPAF_FAIL_MSK)\n\t\tdev_dbg(dev, \"abnormal: SL_ID/OPAF_FAIL phy%d check adr frm err\\n\",\n\t\t\tphy_no);\n\n\tif (irq_value & CHL_INT0_SL_PS_FAIL_OFF)\n\t\tdev_dbg(dev, \"abnormal: SL_PS_FAIL phy%d fail\\n\", phy_no);\n\n\t \n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0, irq_value);\n\n\tif (irq_value & CHL_INT0_PHYCTRL_NOTRDY_MSK)\n\t\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0_MSK,\n\t\t\t\t0x3fffff & ~CHL_INT0_MSK_PHYCTRL_NOTRDY_MSK);\n\telse\n\t\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0_MSK,\n\t\t\t\tirq_mask_old);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cq_interrupt_v1_hw(int irq, void *p)\n{\n\tstruct hisi_sas_cq *cq = p;\n\tstruct hisi_hba *hisi_hba = cq->hisi_hba;\n\tstruct hisi_sas_slot *slot;\n\tint queue = cq->id;\n\tstruct hisi_sas_complete_v1_hdr *complete_queue =\n\t\t\t(struct hisi_sas_complete_v1_hdr *)\n\t\t\thisi_hba->complete_hdr[queue];\n\tu32 rd_point = cq->rd_point, wr_point;\n\n\tspin_lock(&hisi_hba->lock);\n\thisi_sas_write32(hisi_hba, OQ_INT_SRC, 1 << queue);\n\twr_point = hisi_sas_read32(hisi_hba,\n\t\t\tCOMPL_Q_0_WR_PTR + (0x14 * queue));\n\n\twhile (rd_point != wr_point) {\n\t\tstruct hisi_sas_complete_v1_hdr *complete_hdr;\n\t\tint idx;\n\t\tu32 cmplt_hdr_data;\n\n\t\tcomplete_hdr = &complete_queue[rd_point];\n\t\tcmplt_hdr_data = le32_to_cpu(complete_hdr->data);\n\t\tidx = (cmplt_hdr_data & CMPLT_HDR_IPTT_MSK) >>\n\t\t      CMPLT_HDR_IPTT_OFF;\n\t\tslot = &hisi_hba->slot_info[idx];\n\n\t\t \n\t\tslot->cmplt_queue_slot = rd_point;\n\t\tslot->cmplt_queue = queue;\n\t\tslot_complete_v1_hw(hisi_hba, slot);\n\n\t\tif (++rd_point >= HISI_SAS_QUEUE_SLOTS)\n\t\t\trd_point = 0;\n\t}\n\n\t \n\tcq->rd_point = rd_point;\n\thisi_sas_write32(hisi_hba, COMPL_Q_0_RD_PTR + (0x14 * queue), rd_point);\n\tspin_unlock(&hisi_hba->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t fatal_ecc_int_v1_hw(int irq, void *p)\n{\n\tstruct hisi_hba *hisi_hba = p;\n\tstruct device *dev = hisi_hba->dev;\n\tu32 ecc_int = hisi_sas_read32(hisi_hba, SAS_ECC_INTR);\n\n\tif (ecc_int & SAS_ECC_INTR_DQ_ECC1B_MSK) {\n\t\tu32 ecc_err = hisi_sas_read32(hisi_hba, HGC_ECC_ERR);\n\n\t\tpanic(\"%s: Fatal DQ 1b ECC interrupt (0x%x)\\n\",\n\t\t      dev_name(dev), ecc_err);\n\t}\n\n\tif (ecc_int & SAS_ECC_INTR_DQ_ECCBAD_MSK) {\n\t\tu32 addr = (hisi_sas_read32(hisi_hba, HGC_DQ_ECC_ADDR) &\n\t\t\t\tHGC_DQ_ECC_ADDR_BAD_MSK) >>\n\t\t\t\tHGC_DQ_ECC_ADDR_BAD_OFF;\n\n\t\tpanic(\"%s: Fatal DQ RAM ECC interrupt @ 0x%08x\\n\",\n\t\t      dev_name(dev), addr);\n\t}\n\n\tif (ecc_int & SAS_ECC_INTR_IOST_ECC1B_MSK) {\n\t\tu32 ecc_err = hisi_sas_read32(hisi_hba, HGC_ECC_ERR);\n\n\t\tpanic(\"%s: Fatal IOST 1b ECC interrupt (0x%x)\\n\",\n\t\t      dev_name(dev), ecc_err);\n\t}\n\n\tif (ecc_int & SAS_ECC_INTR_IOST_ECCBAD_MSK) {\n\t\tu32 addr = (hisi_sas_read32(hisi_hba, HGC_IOST_ECC_ADDR) &\n\t\t\t\tHGC_IOST_ECC_ADDR_BAD_MSK) >>\n\t\t\t\tHGC_IOST_ECC_ADDR_BAD_OFF;\n\n\t\tpanic(\"%s: Fatal IOST RAM ECC interrupt @ 0x%08x\\n\",\n\t\t      dev_name(dev), addr);\n\t}\n\n\tif (ecc_int & SAS_ECC_INTR_ITCT_ECCBAD_MSK) {\n\t\tu32 addr = (hisi_sas_read32(hisi_hba, HGC_ITCT_ECC_ADDR) &\n\t\t\t\tHGC_ITCT_ECC_ADDR_BAD_MSK) >>\n\t\t\t\tHGC_ITCT_ECC_ADDR_BAD_OFF;\n\n\t\tpanic(\"%s: Fatal TCT RAM ECC interrupt @ 0x%08x\\n\",\n\t\t      dev_name(dev), addr);\n\t}\n\n\tif (ecc_int & SAS_ECC_INTR_ITCT_ECC1B_MSK) {\n\t\tu32 ecc_err = hisi_sas_read32(hisi_hba, HGC_ECC_ERR);\n\n\t\tpanic(\"%s: Fatal ITCT 1b ECC interrupt (0x%x)\\n\",\n\t\t      dev_name(dev), ecc_err);\n\t}\n\n\thisi_sas_write32(hisi_hba, SAS_ECC_INTR, ecc_int | 0x3f);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t fatal_axi_int_v1_hw(int irq, void *p)\n{\n\tstruct hisi_hba *hisi_hba = p;\n\tstruct device *dev = hisi_hba->dev;\n\tu32 axi_int = hisi_sas_read32(hisi_hba, ENT_INT_SRC2);\n\tu32 axi_info = hisi_sas_read32(hisi_hba, HGC_AXI_FIFO_ERR_INFO);\n\n\tif (axi_int & ENT_INT_SRC2_DQ_CFG_ERR_MSK)\n\t\tpanic(\"%s: Fatal DQ_CFG_ERR interrupt (0x%x)\\n\",\n\t\t      dev_name(dev), axi_info);\n\n\tif (axi_int & ENT_INT_SRC2_CQ_CFG_ERR_MSK)\n\t\tpanic(\"%s: Fatal CQ_CFG_ERR interrupt (0x%x)\\n\",\n\t\t      dev_name(dev), axi_info);\n\n\tif (axi_int & ENT_INT_SRC2_AXI_WRONG_INT_MSK)\n\t\tpanic(\"%s: Fatal AXI_WRONG_INT interrupt (0x%x)\\n\",\n\t\t      dev_name(dev), axi_info);\n\n\tif (axi_int & ENT_INT_SRC2_AXI_OVERLF_INT_MSK)\n\t\tpanic(\"%s: Fatal AXI_OVERLF_INT incorrect interrupt (0x%x)\\n\",\n\t\t      dev_name(dev), axi_info);\n\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC2, axi_int | 0x30000000);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irq_handler_t phy_interrupts[HISI_SAS_PHY_INT_NR] = {\n\tint_bcast_v1_hw,\n\tint_phyup_v1_hw,\n\tint_abnormal_v1_hw\n};\n\nstatic irq_handler_t fatal_interrupts[HISI_SAS_MAX_QUEUES] = {\n\tfatal_ecc_int_v1_hw,\n\tfatal_axi_int_v1_hw\n};\n\nstatic int interrupt_init_v1_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct platform_device *pdev = hisi_hba->platform_dev;\n\tstruct device *dev = &pdev->dev;\n\tint i, j, irq, rc, idx;\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\tstruct hisi_sas_phy *phy = &hisi_hba->phy[i];\n\n\t\tidx = i * HISI_SAS_PHY_INT_NR;\n\t\tfor (j = 0; j < HISI_SAS_PHY_INT_NR; j++, idx++) {\n\t\t\tirq = platform_get_irq(pdev, idx);\n\t\t\tif (irq < 0)\n\t\t\t\treturn irq;\n\n\t\t\trc = devm_request_irq(dev, irq, phy_interrupts[j], 0,\n\t\t\t\t\t      DRV_NAME \" phy\", phy);\n\t\t\tif (rc) {\n\t\t\t\tdev_err(dev, \"irq init: could not request phy interrupt %d, rc=%d\\n\",\n\t\t\t\t\tirq, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t}\n\n\tidx = hisi_hba->n_phy * HISI_SAS_PHY_INT_NR;\n\tfor (i = 0; i < hisi_hba->queue_count; i++, idx++) {\n\t\tirq = platform_get_irq(pdev, idx);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\trc = devm_request_irq(dev, irq, cq_interrupt_v1_hw, 0,\n\t\t\t\t      DRV_NAME \" cq\", &hisi_hba->cq[i]);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"irq init: could not request cq interrupt %d, rc=%d\\n\",\n\t\t\t\tirq, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tidx = (hisi_hba->n_phy * HISI_SAS_PHY_INT_NR) + hisi_hba->queue_count;\n\tfor (i = 0; i < HISI_SAS_FATAL_INT_NR; i++, idx++) {\n\t\tirq = platform_get_irq(pdev, idx);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\trc = devm_request_irq(dev, irq, fatal_interrupts[i], 0,\n\t\t\t\t      DRV_NAME \" fatal\", hisi_hba);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"irq init: could not request fatal interrupt %d, rc=%d\\n\",\n\t\t\t\tirq, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\thisi_hba->cq_nvecs = hisi_hba->queue_count;\n\n\treturn 0;\n}\n\nstatic int interrupt_openall_v1_hw(struct hisi_hba *hisi_hba)\n{\n\tint i;\n\tu32 val;\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\t \n\t\tval = hisi_sas_phy_read32(hisi_hba, i, CHL_INT0);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT0, val);\n\t\tval = hisi_sas_phy_read32(hisi_hba, i, CHL_INT1);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT1, val);\n\t\tval = hisi_sas_phy_read32(hisi_hba, i, CHL_INT2);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT2, val);\n\n\t\t \n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT0_MSK, 0x3ce3ee);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT1_MSK, 0x17fff);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT2_MSK, 0x8000012a);\n\n\t\t \n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT0_MSK,\n\t\t\t\t0x3fffff & ~CHL_INT0_MSK_PHYCTRL_NOTRDY_MSK);\n\t}\n\n\treturn 0;\n}\n\nstatic int hisi_sas_v1_init(struct hisi_hba *hisi_hba)\n{\n\tint rc;\n\n\trc = hw_init_v1_hw(hisi_hba);\n\tif (rc)\n\t\treturn rc;\n\n\trc = interrupt_init_v1_hw(hisi_hba);\n\tif (rc)\n\t\treturn rc;\n\n\trc = interrupt_openall_v1_hw(hisi_hba);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic struct attribute *host_v1_hw_attrs[] = {\n\t&dev_attr_phy_event_threshold.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(host_v1_hw);\n\nstatic const struct scsi_host_template sht_v1_hw = {\n\t.name\t\t\t= DRV_NAME,\n\t.proc_name\t\t= DRV_NAME,\n\t.module\t\t\t= THIS_MODULE,\n\t.queuecommand\t\t= sas_queuecommand,\n\t.dma_need_drain\t\t= ata_scsi_dma_need_drain,\n\t.target_alloc\t\t= sas_target_alloc,\n\t.slave_configure\t= hisi_sas_slave_configure,\n\t.scan_finished\t\t= hisi_sas_scan_finished,\n\t.scan_start\t\t= hisi_sas_scan_start,\n\t.change_queue_depth\t= sas_change_queue_depth,\n\t.bios_param\t\t= sas_bios_param,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= HISI_SAS_SGE_PAGE_CNT,\n\t.max_sectors\t\t= SCSI_DEFAULT_MAX_SECTORS,\n\t.eh_device_reset_handler = sas_eh_device_reset_handler,\n\t.eh_target_reset_handler = sas_eh_target_reset_handler,\n\t.slave_alloc\t\t= hisi_sas_slave_alloc,\n\t.target_destroy\t\t= sas_target_destroy,\n\t.ioctl\t\t\t= sas_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= sas_ioctl,\n#endif\n\t.shost_groups\t\t= host_v1_hw_groups,\n\t.host_reset             = hisi_sas_host_reset,\n};\n\nstatic const struct hisi_sas_hw hisi_sas_v1_hw = {\n\t.hw_init = hisi_sas_v1_init,\n\t.setup_itct = setup_itct_v1_hw,\n\t.sl_notify_ssp = sl_notify_ssp_v1_hw,\n\t.clear_itct = clear_itct_v1_hw,\n\t.prep_smp = prep_smp_v1_hw,\n\t.prep_ssp = prep_ssp_v1_hw,\n\t.start_delivery = start_delivery_v1_hw,\n\t.phys_init = phys_init_v1_hw,\n\t.phy_start = start_phy_v1_hw,\n\t.phy_disable = disable_phy_v1_hw,\n\t.phy_hard_reset = phy_hard_reset_v1_hw,\n\t.phy_set_linkrate = phy_set_linkrate_v1_hw,\n\t.phy_get_max_linkrate = phy_get_max_linkrate_v1_hw,\n\t.get_wideport_bitmap = get_wideport_bitmap_v1_hw,\n\t.complete_hdr_size = sizeof(struct hisi_sas_complete_v1_hdr),\n\t.sht = &sht_v1_hw,\n};\n\nstatic int hisi_sas_v1_probe(struct platform_device *pdev)\n{\n\treturn hisi_sas_probe(pdev, &hisi_sas_v1_hw);\n}\n\nstatic const struct of_device_id sas_v1_of_match[] = {\n\t{ .compatible = \"hisilicon,hip05-sas-v1\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sas_v1_of_match);\n\nstatic const struct acpi_device_id sas_v1_acpi_match[] = {\n\t{ \"HISI0161\", 0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(acpi, sas_v1_acpi_match);\n\nstatic struct platform_driver hisi_sas_v1_driver = {\n\t.probe = hisi_sas_v1_probe,\n\t.remove_new = hisi_sas_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = sas_v1_of_match,\n\t\t.acpi_match_table = ACPI_PTR(sas_v1_acpi_match),\n\t},\n};\n\nmodule_platform_driver(hisi_sas_v1_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"John Garry <john.garry@huawei.com>\");\nMODULE_DESCRIPTION(\"HISILICON SAS controller v1 hw driver\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}