{
  "module_name": "hisi_sas_main.c",
  "hash_id": "a60e2444eee1f3d260aed67b1dc31e6b32f3302580919f75a959a65f98934915",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/hisi_sas/hisi_sas_main.c",
  "human_readable_source": "\n \n\n#include \"hisi_sas.h\"\n#define DRV_NAME \"hisi_sas\"\n\n#define DEV_IS_GONE(dev) \\\n\t((!dev) || (dev->dev_type == SAS_PHY_UNUSED))\n\nstatic int hisi_sas_softreset_ata_disk(struct domain_device *device);\nstatic int hisi_sas_control_phy(struct asd_sas_phy *sas_phy, enum phy_func func,\n\t\t\t\tvoid *funcdata);\nstatic void hisi_sas_release_task(struct hisi_hba *hisi_hba,\n\t\t\t\t  struct domain_device *device);\nstatic void hisi_sas_dev_gone(struct domain_device *device);\n\nstruct hisi_sas_internal_abort_data {\n\tbool rst_ha_timeout;  \n};\n\nu8 hisi_sas_get_ata_protocol(struct host_to_dev_fis *fis, int direction)\n{\n\tswitch (fis->command) {\n\tcase ATA_CMD_FPDMA_WRITE:\n\tcase ATA_CMD_FPDMA_READ:\n\tcase ATA_CMD_FPDMA_RECV:\n\tcase ATA_CMD_FPDMA_SEND:\n\tcase ATA_CMD_NCQ_NON_DATA:\n\t\treturn HISI_SAS_SATA_PROTOCOL_FPDMA;\n\n\tcase ATA_CMD_DOWNLOAD_MICRO:\n\tcase ATA_CMD_ID_ATA:\n\tcase ATA_CMD_PMP_READ:\n\tcase ATA_CMD_READ_LOG_EXT:\n\tcase ATA_CMD_PIO_READ:\n\tcase ATA_CMD_PIO_READ_EXT:\n\tcase ATA_CMD_PMP_WRITE:\n\tcase ATA_CMD_WRITE_LOG_EXT:\n\tcase ATA_CMD_PIO_WRITE:\n\tcase ATA_CMD_PIO_WRITE_EXT:\n\t\treturn HISI_SAS_SATA_PROTOCOL_PIO;\n\n\tcase ATA_CMD_DSM:\n\tcase ATA_CMD_DOWNLOAD_MICRO_DMA:\n\tcase ATA_CMD_PMP_READ_DMA:\n\tcase ATA_CMD_PMP_WRITE_DMA:\n\tcase ATA_CMD_READ:\n\tcase ATA_CMD_READ_EXT:\n\tcase ATA_CMD_READ_LOG_DMA_EXT:\n\tcase ATA_CMD_READ_STREAM_DMA_EXT:\n\tcase ATA_CMD_TRUSTED_RCV_DMA:\n\tcase ATA_CMD_TRUSTED_SND_DMA:\n\tcase ATA_CMD_WRITE:\n\tcase ATA_CMD_WRITE_EXT:\n\tcase ATA_CMD_WRITE_FUA_EXT:\n\tcase ATA_CMD_WRITE_QUEUED:\n\tcase ATA_CMD_WRITE_LOG_DMA_EXT:\n\tcase ATA_CMD_WRITE_STREAM_DMA_EXT:\n\tcase ATA_CMD_ZAC_MGMT_IN:\n\t\treturn HISI_SAS_SATA_PROTOCOL_DMA;\n\n\tcase ATA_CMD_CHK_POWER:\n\tcase ATA_CMD_DEV_RESET:\n\tcase ATA_CMD_EDD:\n\tcase ATA_CMD_FLUSH:\n\tcase ATA_CMD_FLUSH_EXT:\n\tcase ATA_CMD_VERIFY:\n\tcase ATA_CMD_VERIFY_EXT:\n\tcase ATA_CMD_SET_FEATURES:\n\tcase ATA_CMD_STANDBY:\n\tcase ATA_CMD_STANDBYNOW1:\n\tcase ATA_CMD_ZAC_MGMT_OUT:\n\t\treturn HISI_SAS_SATA_PROTOCOL_NONDATA;\n\n\tcase ATA_CMD_SET_MAX:\n\t\tswitch (fis->features) {\n\t\tcase ATA_SET_MAX_PASSWD:\n\t\tcase ATA_SET_MAX_LOCK:\n\t\t\treturn HISI_SAS_SATA_PROTOCOL_PIO;\n\n\t\tcase ATA_SET_MAX_PASSWD_DMA:\n\t\tcase ATA_SET_MAX_UNLOCK_DMA:\n\t\t\treturn HISI_SAS_SATA_PROTOCOL_DMA;\n\n\t\tdefault:\n\t\t\treturn HISI_SAS_SATA_PROTOCOL_NONDATA;\n\t\t}\n\n\tdefault:\n\t{\n\t\tif (direction == DMA_NONE)\n\t\t\treturn HISI_SAS_SATA_PROTOCOL_NONDATA;\n\t\treturn HISI_SAS_SATA_PROTOCOL_PIO;\n\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(hisi_sas_get_ata_protocol);\n\nvoid hisi_sas_sata_done(struct sas_task *task,\n\t\t\t    struct hisi_sas_slot *slot)\n{\n\tstruct task_status_struct *ts = &task->task_status;\n\tstruct ata_task_resp *resp = (struct ata_task_resp *)ts->buf;\n\tstruct hisi_sas_status_buffer *status_buf =\n\t\t\thisi_sas_status_buf_addr_mem(slot);\n\tu8 *iu = &status_buf->iu[0];\n\tstruct dev_to_host_fis *d2h =  (struct dev_to_host_fis *)iu;\n\n\tresp->frame_len = sizeof(struct dev_to_host_fis);\n\tmemcpy(&resp->ending_fis[0], d2h, sizeof(struct dev_to_host_fis));\n\n\tts->buf_valid_size = sizeof(*resp);\n}\nEXPORT_SYMBOL_GPL(hisi_sas_sata_done);\n\n \nu8 hisi_sas_get_prog_phy_linkrate_mask(enum sas_linkrate max)\n{\n\tu8 rate = 0;\n\tint i;\n\n\tmax -= SAS_LINK_RATE_1_5_GBPS;\n\tfor (i = 0; i <= max; i++)\n\t\trate |= 1 << (i * 2);\n\treturn rate;\n}\nEXPORT_SYMBOL_GPL(hisi_sas_get_prog_phy_linkrate_mask);\n\nstatic struct hisi_hba *dev_to_hisi_hba(struct domain_device *device)\n{\n\treturn device->port->ha->lldd_ha;\n}\n\nstruct hisi_sas_port *to_hisi_sas_port(struct asd_sas_port *sas_port)\n{\n\treturn container_of(sas_port, struct hisi_sas_port, sas_port);\n}\nEXPORT_SYMBOL_GPL(to_hisi_sas_port);\n\nvoid hisi_sas_stop_phys(struct hisi_hba *hisi_hba)\n{\n\tint phy_no;\n\n\tfor (phy_no = 0; phy_no < hisi_hba->n_phy; phy_no++)\n\t\thisi_sas_phy_enable(hisi_hba, phy_no, 0);\n}\nEXPORT_SYMBOL_GPL(hisi_sas_stop_phys);\n\nstatic void hisi_sas_slot_index_clear(struct hisi_hba *hisi_hba, int slot_idx)\n{\n\tvoid *bitmap = hisi_hba->slot_index_tags;\n\n\t__clear_bit(slot_idx, bitmap);\n}\n\nstatic void hisi_sas_slot_index_free(struct hisi_hba *hisi_hba, int slot_idx)\n{\n\tif (hisi_hba->hw->slot_index_alloc ||\n\t    slot_idx < HISI_SAS_RESERVED_IPTT) {\n\t\tspin_lock(&hisi_hba->lock);\n\t\thisi_sas_slot_index_clear(hisi_hba, slot_idx);\n\t\tspin_unlock(&hisi_hba->lock);\n\t}\n}\n\nstatic void hisi_sas_slot_index_set(struct hisi_hba *hisi_hba, int slot_idx)\n{\n\tvoid *bitmap = hisi_hba->slot_index_tags;\n\n\t__set_bit(slot_idx, bitmap);\n}\n\nstatic int hisi_sas_slot_index_alloc(struct hisi_hba *hisi_hba,\n\t\t\t\t     struct request *rq)\n{\n\tint index;\n\tvoid *bitmap = hisi_hba->slot_index_tags;\n\n\tif (rq)\n\t\treturn rq->tag + HISI_SAS_RESERVED_IPTT;\n\n\tspin_lock(&hisi_hba->lock);\n\tindex = find_next_zero_bit(bitmap, HISI_SAS_RESERVED_IPTT,\n\t\t\t\t   hisi_hba->last_slot_index + 1);\n\tif (index >= HISI_SAS_RESERVED_IPTT) {\n\t\tindex = find_next_zero_bit(bitmap,\n\t\t\t\tHISI_SAS_RESERVED_IPTT,\n\t\t\t\t0);\n\t\tif (index >= HISI_SAS_RESERVED_IPTT) {\n\t\t\tspin_unlock(&hisi_hba->lock);\n\t\t\treturn -SAS_QUEUE_FULL;\n\t\t}\n\t}\n\thisi_sas_slot_index_set(hisi_hba, index);\n\thisi_hba->last_slot_index = index;\n\tspin_unlock(&hisi_hba->lock);\n\n\treturn index;\n}\n\nvoid hisi_sas_slot_task_free(struct hisi_hba *hisi_hba, struct sas_task *task,\n\t\t\t     struct hisi_sas_slot *slot, bool need_lock)\n{\n\tint device_id = slot->device_id;\n\tstruct hisi_sas_device *sas_dev = &hisi_hba->devices[device_id];\n\n\tif (task) {\n\t\tstruct device *dev = hisi_hba->dev;\n\n\t\tif (!task->lldd_task)\n\t\t\treturn;\n\n\t\ttask->lldd_task = NULL;\n\n\t\tif (!sas_protocol_ata(task->task_proto)) {\n\t\t\tif (slot->n_elem) {\n\t\t\t\tif (task->task_proto & SAS_PROTOCOL_SSP)\n\t\t\t\t\tdma_unmap_sg(dev, task->scatter,\n\t\t\t\t\t\t     task->num_scatter,\n\t\t\t\t\t\t     task->data_dir);\n\t\t\t\telse\n\t\t\t\t\tdma_unmap_sg(dev, &task->smp_task.smp_req,\n\t\t\t\t\t\t     1, DMA_TO_DEVICE);\n\t\t\t}\n\t\t\tif (slot->n_elem_dif) {\n\t\t\t\tstruct sas_ssp_task *ssp_task = &task->ssp_task;\n\t\t\t\tstruct scsi_cmnd *scsi_cmnd = ssp_task->cmd;\n\n\t\t\t\tdma_unmap_sg(dev, scsi_prot_sglist(scsi_cmnd),\n\t\t\t\t\t     scsi_prot_sg_count(scsi_cmnd),\n\t\t\t\t\t     task->data_dir);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (need_lock) {\n\t\tspin_lock(&sas_dev->lock);\n\t\tlist_del_init(&slot->entry);\n\t\tspin_unlock(&sas_dev->lock);\n\t} else {\n\t\tlist_del_init(&slot->entry);\n\t}\n\n\tmemset(slot, 0, offsetof(struct hisi_sas_slot, buf));\n\n\thisi_sas_slot_index_free(hisi_hba, slot->idx);\n}\nEXPORT_SYMBOL_GPL(hisi_sas_slot_task_free);\n\nstatic void hisi_sas_task_prep_smp(struct hisi_hba *hisi_hba,\n\t\t\t\t  struct hisi_sas_slot *slot)\n{\n\thisi_hba->hw->prep_smp(hisi_hba, slot);\n}\n\nstatic void hisi_sas_task_prep_ssp(struct hisi_hba *hisi_hba,\n\t\t\t\t  struct hisi_sas_slot *slot)\n{\n\thisi_hba->hw->prep_ssp(hisi_hba, slot);\n}\n\nstatic void hisi_sas_task_prep_ata(struct hisi_hba *hisi_hba,\n\t\t\t\t  struct hisi_sas_slot *slot)\n{\n\thisi_hba->hw->prep_stp(hisi_hba, slot);\n}\n\nstatic void hisi_sas_task_prep_abort(struct hisi_hba *hisi_hba,\n\t\t\t\t     struct hisi_sas_slot *slot)\n{\n\thisi_hba->hw->prep_abort(hisi_hba, slot);\n}\n\nstatic void hisi_sas_dma_unmap(struct hisi_hba *hisi_hba,\n\t\t\t       struct sas_task *task, int n_elem)\n{\n\tstruct device *dev = hisi_hba->dev;\n\n\tif (!sas_protocol_ata(task->task_proto) && n_elem) {\n\t\tif (task->num_scatter) {\n\t\t\tdma_unmap_sg(dev, task->scatter, task->num_scatter,\n\t\t\t\t     task->data_dir);\n\t\t} else if (task->task_proto & SAS_PROTOCOL_SMP) {\n\t\t\tdma_unmap_sg(dev, &task->smp_task.smp_req,\n\t\t\t\t     1, DMA_TO_DEVICE);\n\t\t}\n\t}\n}\n\nstatic int hisi_sas_dma_map(struct hisi_hba *hisi_hba,\n\t\t\t    struct sas_task *task, int *n_elem)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tint rc;\n\n\tif (sas_protocol_ata(task->task_proto)) {\n\t\t*n_elem = task->num_scatter;\n\t} else {\n\t\tunsigned int req_len;\n\n\t\tif (task->num_scatter) {\n\t\t\t*n_elem = dma_map_sg(dev, task->scatter,\n\t\t\t\t\t     task->num_scatter, task->data_dir);\n\t\t\tif (!*n_elem) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto prep_out;\n\t\t\t}\n\t\t} else if (task->task_proto & SAS_PROTOCOL_SMP) {\n\t\t\t*n_elem = dma_map_sg(dev, &task->smp_task.smp_req,\n\t\t\t\t\t     1, DMA_TO_DEVICE);\n\t\t\tif (!*n_elem) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto prep_out;\n\t\t\t}\n\t\t\treq_len = sg_dma_len(&task->smp_task.smp_req);\n\t\t\tif (req_len & 0x3) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out_dma_unmap;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*n_elem > HISI_SAS_SGE_PAGE_CNT) {\n\t\tdev_err(dev, \"task prep: n_elem(%d) > HISI_SAS_SGE_PAGE_CNT\\n\",\n\t\t\t*n_elem);\n\t\trc = -EINVAL;\n\t\tgoto err_out_dma_unmap;\n\t}\n\treturn 0;\n\nerr_out_dma_unmap:\n\t \n\thisi_sas_dma_unmap(hisi_hba, task, *n_elem);\nprep_out:\n\treturn rc;\n}\n\nstatic void hisi_sas_dif_dma_unmap(struct hisi_hba *hisi_hba,\n\t\t\t\t   struct sas_task *task, int n_elem_dif)\n{\n\tstruct device *dev = hisi_hba->dev;\n\n\tif (n_elem_dif) {\n\t\tstruct sas_ssp_task *ssp_task = &task->ssp_task;\n\t\tstruct scsi_cmnd *scsi_cmnd = ssp_task->cmd;\n\n\t\tdma_unmap_sg(dev, scsi_prot_sglist(scsi_cmnd),\n\t\t\t     scsi_prot_sg_count(scsi_cmnd),\n\t\t\t     task->data_dir);\n\t}\n}\n\nstatic int hisi_sas_dif_dma_map(struct hisi_hba *hisi_hba,\n\t\t\t\tint *n_elem_dif, struct sas_task *task)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tstruct sas_ssp_task *ssp_task;\n\tstruct scsi_cmnd *scsi_cmnd;\n\tint rc;\n\n\tif (task->num_scatter) {\n\t\tssp_task = &task->ssp_task;\n\t\tscsi_cmnd = ssp_task->cmd;\n\n\t\tif (scsi_prot_sg_count(scsi_cmnd)) {\n\t\t\t*n_elem_dif = dma_map_sg(dev,\n\t\t\t\t\t\t scsi_prot_sglist(scsi_cmnd),\n\t\t\t\t\t\t scsi_prot_sg_count(scsi_cmnd),\n\t\t\t\t\t\t task->data_dir);\n\n\t\t\tif (!*n_elem_dif)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (*n_elem_dif > HISI_SAS_SGE_DIF_PAGE_CNT) {\n\t\t\t\tdev_err(dev, \"task prep: n_elem_dif(%d) too large\\n\",\n\t\t\t\t\t*n_elem_dif);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out_dif_dma_unmap;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_out_dif_dma_unmap:\n\tdma_unmap_sg(dev, scsi_prot_sglist(scsi_cmnd),\n\t\t     scsi_prot_sg_count(scsi_cmnd), task->data_dir);\n\treturn rc;\n}\n\nstatic\nvoid hisi_sas_task_deliver(struct hisi_hba *hisi_hba,\n\t\t\t   struct hisi_sas_slot *slot,\n\t\t\t   struct hisi_sas_dq *dq,\n\t\t\t   struct hisi_sas_device *sas_dev)\n{\n\tstruct hisi_sas_cmd_hdr *cmd_hdr_base;\n\tint dlvry_queue_slot, dlvry_queue;\n\tstruct sas_task *task = slot->task;\n\tint wr_q_index;\n\n\tspin_lock(&dq->lock);\n\twr_q_index = dq->wr_point;\n\tdq->wr_point = (dq->wr_point + 1) % HISI_SAS_QUEUE_SLOTS;\n\tlist_add_tail(&slot->delivery, &dq->list);\n\tspin_unlock(&dq->lock);\n\tspin_lock(&sas_dev->lock);\n\tlist_add_tail(&slot->entry, &sas_dev->list);\n\tspin_unlock(&sas_dev->lock);\n\n\tdlvry_queue = dq->id;\n\tdlvry_queue_slot = wr_q_index;\n\n\tslot->device_id = sas_dev->device_id;\n\tslot->dlvry_queue = dlvry_queue;\n\tslot->dlvry_queue_slot = dlvry_queue_slot;\n\tcmd_hdr_base = hisi_hba->cmd_hdr[dlvry_queue];\n\tslot->cmd_hdr = &cmd_hdr_base[dlvry_queue_slot];\n\n\ttask->lldd_task = slot;\n\n\tmemset(slot->cmd_hdr, 0, sizeof(struct hisi_sas_cmd_hdr));\n\tmemset(hisi_sas_cmd_hdr_addr_mem(slot), 0, HISI_SAS_COMMAND_TABLE_SZ);\n\tmemset(hisi_sas_status_buf_addr_mem(slot), 0,\n\t       sizeof(struct hisi_sas_err_record));\n\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SMP:\n\t\thisi_sas_task_prep_smp(hisi_hba, slot);\n\t\tbreak;\n\tcase SAS_PROTOCOL_SSP:\n\t\thisi_sas_task_prep_ssp(hisi_hba, slot);\n\t\tbreak;\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\tcase SAS_PROTOCOL_STP_ALL:\n\t\thisi_sas_task_prep_ata(hisi_hba, slot);\n\t\tbreak;\n\tcase SAS_PROTOCOL_INTERNAL_ABORT:\n\t\thisi_sas_task_prep_abort(hisi_hba, slot);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tsmp_wmb();\n\tWRITE_ONCE(slot->ready, 1);\n\n\tspin_lock(&dq->lock);\n\thisi_hba->hw->start_delivery(dq);\n\tspin_unlock(&dq->lock);\n}\n\nstatic int hisi_sas_queue_command(struct sas_task *task, gfp_t gfp_flags)\n{\n\tint n_elem = 0, n_elem_dif = 0;\n\tstruct domain_device *device = task->dev;\n\tstruct asd_sas_port *sas_port = device->port;\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tbool internal_abort = sas_is_internal_abort(task);\n\tstruct hisi_sas_dq *dq = NULL;\n\tstruct hisi_sas_port *port;\n\tstruct hisi_hba *hisi_hba;\n\tstruct hisi_sas_slot *slot;\n\tstruct request *rq = NULL;\n\tstruct device *dev;\n\tint rc;\n\n\tif (!sas_port) {\n\t\tstruct task_status_struct *ts = &task->task_status;\n\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_PHY_DOWN;\n\t\t \n\t\tif (device->dev_type != SAS_SATA_DEV && !internal_abort)\n\t\t\ttask->task_done(task);\n\t\treturn -ECOMM;\n\t}\n\n\thisi_hba = dev_to_hisi_hba(device);\n\tdev = hisi_hba->dev;\n\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SSP:\n\tcase SAS_PROTOCOL_SMP:\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\tcase SAS_PROTOCOL_STP_ALL:\n\t\tif (unlikely(test_bit(HISI_SAS_REJECT_CMD_BIT, &hisi_hba->flags))) {\n\t\t\tif (!gfpflags_allow_blocking(gfp_flags))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdown(&hisi_hba->sem);\n\t\t\tup(&hisi_hba->sem);\n\t\t}\n\n\t\tif (DEV_IS_GONE(sas_dev)) {\n\t\t\tif (sas_dev)\n\t\t\t\tdev_info(dev, \"task prep: device %d not ready\\n\",\n\t\t\t\t\t sas_dev->device_id);\n\t\t\telse\n\t\t\t\tdev_info(dev, \"task prep: device %016llx not ready\\n\",\n\t\t\t\t\t SAS_ADDR(device->sas_addr));\n\n\t\t\treturn -ECOMM;\n\t\t}\n\n\t\tport = to_hisi_sas_port(sas_port);\n\t\tif (!port->port_attached) {\n\t\t\tdev_info(dev, \"task prep: %s port%d not attach device\\n\",\n\t\t\t\t dev_is_sata(device) ? \"SATA/STP\" : \"SAS\",\n\t\t\t\t device->port->id);\n\n\t\t\t\treturn -ECOMM;\n\t\t}\n\n\t\trq = sas_task_find_rq(task);\n\t\tif (rq) {\n\t\t\tunsigned int dq_index;\n\t\t\tu32 blk_tag;\n\n\t\t\tblk_tag = blk_mq_unique_tag(rq);\n\t\t\tdq_index = blk_mq_unique_tag_to_hwq(blk_tag);\n\t\t\tdq = &hisi_hba->dq[dq_index];\n\t\t} else {\n\t\t\tint queue;\n\n\t\t\tif (hisi_hba->iopoll_q_cnt) {\n\t\t\t\t \n\t\t\t\tqueue = 0;\n\t\t\t} else {\n\t\t\t\tstruct Scsi_Host *shost = hisi_hba->shost;\n\t\t\t\tstruct blk_mq_queue_map *qmap = &shost->tag_set.map[HCTX_TYPE_DEFAULT];\n\n\t\t\t\tqueue = qmap->mq_map[raw_smp_processor_id()];\n\t\t\t}\n\t\t\tdq = &hisi_hba->dq[queue];\n\t\t}\n\t\tbreak;\n\tcase SAS_PROTOCOL_INTERNAL_ABORT:\n\t\tif (!hisi_hba->hw->prep_abort)\n\t\t\treturn TMF_RESP_FUNC_FAILED;\n\n\t\tif (test_bit(HISI_SAS_HW_FAULT_BIT, &hisi_hba->flags))\n\t\t\treturn -EIO;\n\n\t\thisi_hba = dev_to_hisi_hba(device);\n\n\t\tif (unlikely(test_bit(HISI_SAS_REJECT_CMD_BIT, &hisi_hba->flags)))\n\t\t\treturn -EINVAL;\n\n\t\tport = to_hisi_sas_port(sas_port);\n\t\tdq = &hisi_hba->dq[task->abort_task.qid];\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hisi_hba->dev, \"task prep: unknown/unsupported proto (0x%x)\\n\",\n\t\t\ttask->task_proto);\n\t\treturn -EINVAL;\n\t}\n\n\trc = hisi_sas_dma_map(hisi_hba, task, &n_elem);\n\tif (rc < 0)\n\t\tgoto prep_out;\n\n\tif (!sas_protocol_ata(task->task_proto)) {\n\t\trc = hisi_sas_dif_dma_map(hisi_hba, &n_elem_dif, task);\n\t\tif (rc < 0)\n\t\t\tgoto err_out_dma_unmap;\n\t}\n\n\tif (!internal_abort && hisi_hba->hw->slot_index_alloc)\n\t\trc = hisi_hba->hw->slot_index_alloc(hisi_hba, device);\n\telse\n\t\trc = hisi_sas_slot_index_alloc(hisi_hba, rq);\n\n\tif (rc < 0)\n\t\tgoto err_out_dif_dma_unmap;\n\n\tslot = &hisi_hba->slot_info[rc];\n\tslot->n_elem = n_elem;\n\tslot->n_elem_dif = n_elem_dif;\n\tslot->task = task;\n\tslot->port = port;\n\n\tslot->tmf = task->tmf;\n\tslot->is_internal = !!task->tmf || internal_abort;\n\n\t \n\thisi_sas_task_deliver(hisi_hba, slot, dq, sas_dev);\n\n\treturn 0;\n\nerr_out_dif_dma_unmap:\n\tif (!sas_protocol_ata(task->task_proto))\n\t\thisi_sas_dif_dma_unmap(hisi_hba, task, n_elem_dif);\nerr_out_dma_unmap:\n\thisi_sas_dma_unmap(hisi_hba, task, n_elem);\nprep_out:\n\tdev_err(dev, \"task exec: failed[%d]!\\n\", rc);\n\treturn rc;\n}\n\nstatic void hisi_sas_bytes_dmaed(struct hisi_hba *hisi_hba, int phy_no,\n\t\t\t\t gfp_t gfp_flags)\n{\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\n\tif (!phy->phy_attached)\n\t\treturn;\n\n\tsas_notify_phy_event(sas_phy, PHYE_OOB_DONE, gfp_flags);\n\n\tif (sas_phy->phy) {\n\t\tstruct sas_phy *sphy = sas_phy->phy;\n\n\t\tsphy->negotiated_linkrate = sas_phy->linkrate;\n\t\tsphy->minimum_linkrate_hw = SAS_LINK_RATE_1_5_GBPS;\n\t\tsphy->maximum_linkrate_hw =\n\t\t\thisi_hba->hw->phy_get_max_linkrate();\n\t\tif (sphy->minimum_linkrate == SAS_LINK_RATE_UNKNOWN)\n\t\t\tsphy->minimum_linkrate = phy->minimum_linkrate;\n\n\t\tif (sphy->maximum_linkrate == SAS_LINK_RATE_UNKNOWN)\n\t\t\tsphy->maximum_linkrate = phy->maximum_linkrate;\n\t}\n\n\tif (phy->phy_type & PORT_TYPE_SAS) {\n\t\tstruct sas_identify_frame *id;\n\n\t\tid = (struct sas_identify_frame *)phy->frame_rcvd;\n\t\tid->dev_type = phy->identify.device_type;\n\t\tid->initiator_bits = SAS_PROTOCOL_ALL;\n\t\tid->target_bits = phy->identify.target_port_protocols;\n\t} else if (phy->phy_type & PORT_TYPE_SATA) {\n\t\t \n\t}\n\n\tsas_phy->frame_rcvd_size = phy->frame_rcvd_size;\n\tsas_notify_port_event(sas_phy, PORTE_BYTES_DMAED, gfp_flags);\n}\n\nstatic struct hisi_sas_device *hisi_sas_alloc_dev(struct domain_device *device)\n{\n\tstruct hisi_hba *hisi_hba = dev_to_hisi_hba(device);\n\tstruct hisi_sas_device *sas_dev = NULL;\n\tint last = hisi_hba->last_dev_id;\n\tint first = (hisi_hba->last_dev_id + 1) % HISI_SAS_MAX_DEVICES;\n\tint i;\n\n\tspin_lock(&hisi_hba->lock);\n\tfor (i = first; i != last; i %= HISI_SAS_MAX_DEVICES) {\n\t\tif (hisi_hba->devices[i].dev_type == SAS_PHY_UNUSED) {\n\t\t\tint queue = i % hisi_hba->queue_count;\n\t\t\tstruct hisi_sas_dq *dq = &hisi_hba->dq[queue];\n\n\t\t\thisi_hba->devices[i].device_id = i;\n\t\t\tsas_dev = &hisi_hba->devices[i];\n\t\t\tsas_dev->dev_status = HISI_SAS_DEV_INIT;\n\t\t\tsas_dev->dev_type = device->dev_type;\n\t\t\tsas_dev->hisi_hba = hisi_hba;\n\t\t\tsas_dev->sas_device = device;\n\t\t\tsas_dev->dq = dq;\n\t\t\tspin_lock_init(&sas_dev->lock);\n\t\t\tINIT_LIST_HEAD(&hisi_hba->devices[i].list);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\thisi_hba->last_dev_id = i;\n\tspin_unlock(&hisi_hba->lock);\n\n\treturn sas_dev;\n}\n\nstatic void hisi_sas_sync_poll_cq(struct hisi_sas_cq *cq)\n{\n\t \n\tspin_lock(&cq->poll_lock);\n\tspin_unlock(&cq->poll_lock);\n}\n\nstatic bool hisi_sas_queue_is_poll(struct hisi_sas_cq *cq)\n{\n\tstruct hisi_hba *hisi_hba = cq->hisi_hba;\n\n\tif (cq->id < hisi_hba->queue_count - hisi_hba->iopoll_q_cnt)\n\t\treturn false;\n\treturn true;\n}\n\nstatic void hisi_sas_sync_cq(struct hisi_sas_cq *cq)\n{\n\tif (hisi_sas_queue_is_poll(cq))\n\t\thisi_sas_sync_poll_cq(cq);\n\telse\n\t\tsynchronize_irq(cq->irq_no);\n}\n\nvoid hisi_sas_sync_poll_cqs(struct hisi_hba *hisi_hba)\n{\n\tint i;\n\n\tfor (i = 0; i < hisi_hba->queue_count; i++) {\n\t\tstruct hisi_sas_cq *cq = &hisi_hba->cq[i];\n\n\t\tif (hisi_sas_queue_is_poll(cq))\n\t\t\thisi_sas_sync_poll_cq(cq);\n\t}\n}\nEXPORT_SYMBOL_GPL(hisi_sas_sync_poll_cqs);\n\nvoid hisi_sas_sync_cqs(struct hisi_hba *hisi_hba)\n{\n\tint i;\n\n\tfor (i = 0; i < hisi_hba->queue_count; i++) {\n\t\tstruct hisi_sas_cq *cq = &hisi_hba->cq[i];\n\n\t\thisi_sas_sync_cq(cq);\n\t}\n}\nEXPORT_SYMBOL_GPL(hisi_sas_sync_cqs);\n\nstatic void hisi_sas_tmf_aborted(struct sas_task *task)\n{\n\tstruct hisi_sas_slot *slot = task->lldd_task;\n\tstruct domain_device *device = task->dev;\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tstruct hisi_hba *hisi_hba = sas_dev->hisi_hba;\n\n\tif (slot) {\n\t\tstruct hisi_sas_cq *cq =\n\t\t\t   &hisi_hba->cq[slot->dlvry_queue];\n\t\t \n\t\thisi_sas_sync_cq(cq);\n\t\tslot->task = NULL;\n\t}\n}\n\n#define HISI_SAS_DISK_RECOVER_CNT 3\nstatic int hisi_sas_init_device(struct domain_device *device)\n{\n\tint rc = TMF_RESP_FUNC_COMPLETE;\n\tstruct scsi_lun lun;\n\tint retry = HISI_SAS_DISK_RECOVER_CNT;\n\tstruct hisi_hba *hisi_hba = dev_to_hisi_hba(device);\n\n\tswitch (device->dev_type) {\n\tcase SAS_END_DEVICE:\n\t\tint_to_scsilun(0, &lun);\n\n\t\twhile (retry-- > 0) {\n\t\t\trc = sas_abort_task_set(device, lun.scsi_lun);\n\t\t\tif (rc == TMF_RESP_FUNC_COMPLETE) {\n\t\t\t\thisi_sas_release_task(hisi_hba, device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SAS_SATA_DEV:\n\tcase SAS_SATA_PM:\n\tcase SAS_SATA_PM_PORT:\n\tcase SAS_SATA_PENDING:\n\t\t \n\t\twhile (retry-- > 0) {\n\t\t\trc = hisi_sas_softreset_ata_disk(device);\n\t\t\tif (!rc)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nint hisi_sas_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct domain_device *ddev = sdev_to_domain_dev(sdev);\n\tstruct hisi_sas_device *sas_dev = ddev->lldd_dev;\n\tint rc;\n\n\trc = sas_slave_alloc(sdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hisi_sas_init_device(ddev);\n\tif (rc)\n\t\treturn rc;\n\tsas_dev->dev_status = HISI_SAS_DEV_NORMAL;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hisi_sas_slave_alloc);\n\nstatic int hisi_sas_dev_found(struct domain_device *device)\n{\n\tstruct hisi_hba *hisi_hba = dev_to_hisi_hba(device);\n\tstruct domain_device *parent_dev = device->parent;\n\tstruct hisi_sas_device *sas_dev;\n\tstruct device *dev = hisi_hba->dev;\n\tint rc;\n\n\tif (hisi_hba->hw->alloc_dev)\n\t\tsas_dev = hisi_hba->hw->alloc_dev(device);\n\telse\n\t\tsas_dev = hisi_sas_alloc_dev(device);\n\tif (!sas_dev) {\n\t\tdev_err(dev, \"fail alloc dev: max support %d devices\\n\",\n\t\t\tHISI_SAS_MAX_DEVICES);\n\t\treturn -EINVAL;\n\t}\n\n\tdevice->lldd_dev = sas_dev;\n\thisi_hba->hw->setup_itct(hisi_hba, sas_dev);\n\n\tif (parent_dev && dev_is_expander(parent_dev->dev_type)) {\n\t\tint phy_no;\n\n\t\tphy_no = sas_find_attached_phy_id(&parent_dev->ex_dev, device);\n\t\tif (phy_no < 0) {\n\t\t\tdev_info(dev, \"dev found: no attached \"\n\t\t\t\t \"dev:%016llx at ex:%016llx\\n\",\n\t\t\t\t SAS_ADDR(device->sas_addr),\n\t\t\t\t SAS_ADDR(parent_dev->sas_addr));\n\t\t\trc = phy_no;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tdev_info(dev, \"dev[%d:%x] found\\n\",\n\t\tsas_dev->device_id, sas_dev->dev_type);\n\n\treturn 0;\n\nerr_out:\n\thisi_sas_dev_gone(device);\n\treturn rc;\n}\n\nint hisi_sas_slave_configure(struct scsi_device *sdev)\n{\n\tstruct domain_device *dev = sdev_to_domain_dev(sdev);\n\tint ret = sas_slave_configure(sdev);\n\n\tif (ret)\n\t\treturn ret;\n\tif (!dev_is_sata(dev))\n\t\tsas_change_queue_depth(sdev, 64);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hisi_sas_slave_configure);\n\nvoid hisi_sas_scan_start(struct Scsi_Host *shost)\n{\n\tstruct hisi_hba *hisi_hba = shost_priv(shost);\n\n\thisi_hba->hw->phys_init(hisi_hba);\n}\nEXPORT_SYMBOL_GPL(hisi_sas_scan_start);\n\nint hisi_sas_scan_finished(struct Scsi_Host *shost, unsigned long time)\n{\n\tstruct hisi_hba *hisi_hba = shost_priv(shost);\n\tstruct sas_ha_struct *sha = &hisi_hba->sha;\n\n\t \n\tif (time < HZ)\n\t\treturn 0;\n\n\tsas_drain_work(sha);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(hisi_sas_scan_finished);\n\nstatic void hisi_sas_phyup_work_common(struct work_struct *work,\n\t\tenum hisi_sas_phy_event event)\n{\n\tstruct hisi_sas_phy *phy =\n\t\tcontainer_of(work, typeof(*phy), works[event]);\n\tstruct hisi_hba *hisi_hba = phy->hisi_hba;\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tint phy_no = sas_phy->id;\n\n\tphy->wait_phyup_cnt = 0;\n\tif (phy->identify.target_port_protocols == SAS_PROTOCOL_SSP)\n\t\thisi_hba->hw->sl_notify_ssp(hisi_hba, phy_no);\n\thisi_sas_bytes_dmaed(hisi_hba, phy_no, GFP_KERNEL);\n}\n\nstatic void hisi_sas_phyup_work(struct work_struct *work)\n{\n\thisi_sas_phyup_work_common(work, HISI_PHYE_PHY_UP);\n}\n\nstatic void hisi_sas_linkreset_work(struct work_struct *work)\n{\n\tstruct hisi_sas_phy *phy =\n\t\tcontainer_of(work, typeof(*phy), works[HISI_PHYE_LINK_RESET]);\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\n\thisi_sas_control_phy(sas_phy, PHY_FUNC_LINK_RESET, NULL);\n}\n\nstatic void hisi_sas_phyup_pm_work(struct work_struct *work)\n{\n\tstruct hisi_sas_phy *phy =\n\t\tcontainer_of(work, typeof(*phy), works[HISI_PHYE_PHY_UP_PM]);\n\tstruct hisi_hba *hisi_hba = phy->hisi_hba;\n\tstruct device *dev = hisi_hba->dev;\n\n\thisi_sas_phyup_work_common(work, HISI_PHYE_PHY_UP_PM);\n\tpm_runtime_put_sync(dev);\n}\n\nstatic const work_func_t hisi_sas_phye_fns[HISI_PHYES_NUM] = {\n\t[HISI_PHYE_PHY_UP] = hisi_sas_phyup_work,\n\t[HISI_PHYE_LINK_RESET] = hisi_sas_linkreset_work,\n\t[HISI_PHYE_PHY_UP_PM] = hisi_sas_phyup_pm_work,\n};\n\nbool hisi_sas_notify_phy_event(struct hisi_sas_phy *phy,\n\t\t\t\tenum hisi_sas_phy_event event)\n{\n\tstruct hisi_hba *hisi_hba = phy->hisi_hba;\n\n\tif (WARN_ON(event >= HISI_PHYES_NUM))\n\t\treturn false;\n\n\treturn queue_work(hisi_hba->wq, &phy->works[event]);\n}\nEXPORT_SYMBOL_GPL(hisi_sas_notify_phy_event);\n\nstatic void hisi_sas_wait_phyup_timedout(struct timer_list *t)\n{\n\tstruct hisi_sas_phy *phy = from_timer(phy, t, timer);\n\tstruct hisi_hba *hisi_hba = phy->hisi_hba;\n\tstruct device *dev = hisi_hba->dev;\n\tint phy_no = phy->sas_phy.id;\n\n\tdev_warn(dev, \"phy%d wait phyup timeout, issuing link reset\\n\", phy_no);\n\thisi_sas_notify_phy_event(phy, HISI_PHYE_LINK_RESET);\n}\n\n#define HISI_SAS_WAIT_PHYUP_RETRIES\t10\n\nvoid hisi_sas_phy_oob_ready(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tstruct device *dev = hisi_hba->dev;\n\tunsigned long flags;\n\n\tdev_dbg(dev, \"phy%d OOB ready\\n\", phy_no);\n\tspin_lock_irqsave(&phy->lock, flags);\n\tif (phy->phy_attached) {\n\t\tspin_unlock_irqrestore(&phy->lock, flags);\n\t\treturn;\n\t}\n\n\tif (!timer_pending(&phy->timer)) {\n\t\tif (phy->wait_phyup_cnt < HISI_SAS_WAIT_PHYUP_RETRIES) {\n\t\t\tphy->wait_phyup_cnt++;\n\t\t\tphy->timer.expires = jiffies +\n\t\t\t\t\t     HISI_SAS_WAIT_PHYUP_TIMEOUT;\n\t\t\tadd_timer(&phy->timer);\n\t\t\tspin_unlock_irqrestore(&phy->lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tdev_warn(dev, \"phy%d failed to come up %d times, giving up\\n\",\n\t\t\t phy_no, phy->wait_phyup_cnt);\n\t\tphy->wait_phyup_cnt = 0;\n\t}\n\tspin_unlock_irqrestore(&phy->lock, flags);\n}\n\nEXPORT_SYMBOL_GPL(hisi_sas_phy_oob_ready);\n\nstatic void hisi_sas_phy_init(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tint i;\n\n\tphy->hisi_hba = hisi_hba;\n\tphy->port = NULL;\n\tphy->minimum_linkrate = SAS_LINK_RATE_1_5_GBPS;\n\tphy->maximum_linkrate = hisi_hba->hw->phy_get_max_linkrate();\n\tsas_phy->enabled = (phy_no < hisi_hba->n_phy) ? 1 : 0;\n\tsas_phy->iproto = SAS_PROTOCOL_ALL;\n\tsas_phy->tproto = 0;\n\tsas_phy->role = PHY_ROLE_INITIATOR;\n\tsas_phy->oob_mode = OOB_NOT_CONNECTED;\n\tsas_phy->linkrate = SAS_LINK_RATE_UNKNOWN;\n\tsas_phy->id = phy_no;\n\tsas_phy->sas_addr = &hisi_hba->sas_addr[0];\n\tsas_phy->frame_rcvd = &phy->frame_rcvd[0];\n\tsas_phy->ha = (struct sas_ha_struct *)hisi_hba->shost->hostdata;\n\tsas_phy->lldd_phy = phy;\n\n\tfor (i = 0; i < HISI_PHYES_NUM; i++)\n\t\tINIT_WORK(&phy->works[i], hisi_sas_phye_fns[i]);\n\n\tspin_lock_init(&phy->lock);\n\n\ttimer_setup(&phy->timer, hisi_sas_wait_phyup_timedout, 0);\n}\n\n \nvoid hisi_sas_phy_enable(struct hisi_hba *hisi_hba, int phy_no, int enable)\n{\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tstruct asd_sas_phy *aphy = &phy->sas_phy;\n\tstruct sas_phy *sphy = aphy->phy;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&phy->lock, flags);\n\n\tif (enable) {\n\t\t \n\t\tif (!phy->enable)\n\t\t\tsphy->negotiated_linkrate = SAS_LINK_RATE_UNKNOWN;\n\t\thisi_hba->hw->phy_start(hisi_hba, phy_no);\n\t} else {\n\t\tsphy->negotiated_linkrate = SAS_PHY_DISABLED;\n\t\thisi_hba->hw->phy_disable(hisi_hba, phy_no);\n\t}\n\tphy->enable = enable;\n\tspin_unlock_irqrestore(&phy->lock, flags);\n}\nEXPORT_SYMBOL_GPL(hisi_sas_phy_enable);\n\nstatic void hisi_sas_port_notify_formed(struct asd_sas_phy *sas_phy)\n{\n\tstruct hisi_sas_phy *phy = sas_phy->lldd_phy;\n\tstruct asd_sas_port *sas_port = sas_phy->port;\n\tstruct hisi_sas_port *port;\n\n\tif (!sas_port)\n\t\treturn;\n\n\tport = to_hisi_sas_port(sas_port);\n\tport->port_attached = 1;\n\tport->id = phy->port_id;\n\tphy->port = port;\n\tsas_port->lldd_port = port;\n}\n\nstatic void hisi_sas_do_release_task(struct hisi_hba *hisi_hba, struct sas_task *task,\n\t\t\t\t     struct hisi_sas_slot *slot, bool need_lock)\n{\n\tif (task) {\n\t\tunsigned long flags;\n\t\tstruct task_status_struct *ts;\n\n\t\tts = &task->task_status;\n\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_ABORTED_TASK;\n\t\tspin_lock_irqsave(&task->task_state_lock, flags);\n\t\ttask->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\t\tif (!slot->is_internal && task->task_proto != SAS_PROTOCOL_SMP)\n\t\t\ttask->task_state_flags |= SAS_TASK_STATE_DONE;\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t}\n\n\thisi_sas_slot_task_free(hisi_hba, task, slot, need_lock);\n}\n\nstatic void hisi_sas_release_task(struct hisi_hba *hisi_hba,\n\t\t\tstruct domain_device *device)\n{\n\tstruct hisi_sas_slot *slot, *slot2;\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\n\tspin_lock(&sas_dev->lock);\n\tlist_for_each_entry_safe(slot, slot2, &sas_dev->list, entry)\n\t\thisi_sas_do_release_task(hisi_hba, slot->task, slot, false);\n\n\tspin_unlock(&sas_dev->lock);\n}\n\nvoid hisi_sas_release_tasks(struct hisi_hba *hisi_hba)\n{\n\tstruct hisi_sas_device *sas_dev;\n\tstruct domain_device *device;\n\tint i;\n\n\tfor (i = 0; i < HISI_SAS_MAX_DEVICES; i++) {\n\t\tsas_dev = &hisi_hba->devices[i];\n\t\tdevice = sas_dev->sas_device;\n\n\t\tif ((sas_dev->dev_type == SAS_PHY_UNUSED) ||\n\t\t    !device)\n\t\t\tcontinue;\n\n\t\thisi_sas_release_task(hisi_hba, device);\n\t}\n}\nEXPORT_SYMBOL_GPL(hisi_sas_release_tasks);\n\nstatic void hisi_sas_dereg_device(struct hisi_hba *hisi_hba,\n\t\t\t\tstruct domain_device *device)\n{\n\tif (hisi_hba->hw->dereg_device)\n\t\thisi_hba->hw->dereg_device(hisi_hba, device);\n}\n\nstatic int\nhisi_sas_internal_task_abort_dev(struct hisi_sas_device *sas_dev,\n\t\t\t\t bool rst_ha_timeout)\n{\n\tstruct hisi_sas_internal_abort_data data = { rst_ha_timeout };\n\tstruct domain_device *device = sas_dev->sas_device;\n\tstruct hisi_hba *hisi_hba = sas_dev->hisi_hba;\n\tint i, rc;\n\n\tfor (i = 0; i < hisi_hba->cq_nvecs; i++) {\n\t\tstruct hisi_sas_cq *cq = &hisi_hba->cq[i];\n\t\tconst struct cpumask *mask = cq->irq_mask;\n\n\t\tif (mask && !cpumask_intersects(cpu_online_mask, mask))\n\t\t\tcontinue;\n\t\trc = sas_execute_internal_abort_dev(device, i, &data);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void hisi_sas_dev_gone(struct domain_device *device)\n{\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tstruct hisi_hba *hisi_hba = dev_to_hisi_hba(device);\n\tstruct device *dev = hisi_hba->dev;\n\tint ret = 0;\n\n\tdev_info(dev, \"dev[%d:%x] is gone\\n\",\n\t\t sas_dev->device_id, sas_dev->dev_type);\n\n\tdown(&hisi_hba->sem);\n\tif (!test_bit(HISI_SAS_RESETTING_BIT, &hisi_hba->flags)) {\n\t\thisi_sas_internal_task_abort_dev(sas_dev, true);\n\n\t\thisi_sas_dereg_device(hisi_hba, device);\n\n\t\tret = hisi_hba->hw->clear_itct(hisi_hba, sas_dev);\n\t\tdevice->lldd_dev = NULL;\n\t}\n\n\tif (hisi_hba->hw->free_device)\n\t\thisi_hba->hw->free_device(sas_dev);\n\n\t \n\tif (!ret)\n\t\tsas_dev->dev_type = SAS_PHY_UNUSED;\n\tsas_dev->sas_device = NULL;\n\tup(&hisi_hba->sem);\n}\n\nstatic int hisi_sas_phy_set_linkrate(struct hisi_hba *hisi_hba, int phy_no,\n\t\t\tstruct sas_phy_linkrates *r)\n{\n\tstruct sas_phy_linkrates _r;\n\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tenum sas_linkrate min, max;\n\n\tif (r->minimum_linkrate > SAS_LINK_RATE_1_5_GBPS)\n\t\treturn -EINVAL;\n\n\tif (r->maximum_linkrate == SAS_LINK_RATE_UNKNOWN) {\n\t\tmax = sas_phy->phy->maximum_linkrate;\n\t\tmin = r->minimum_linkrate;\n\t} else if (r->minimum_linkrate == SAS_LINK_RATE_UNKNOWN) {\n\t\tmax = r->maximum_linkrate;\n\t\tmin = sas_phy->phy->minimum_linkrate;\n\t} else\n\t\treturn -EINVAL;\n\n\t_r.maximum_linkrate = max;\n\t_r.minimum_linkrate = min;\n\n\tsas_phy->phy->maximum_linkrate = max;\n\tsas_phy->phy->minimum_linkrate = min;\n\n\thisi_sas_phy_enable(hisi_hba, phy_no, 0);\n\tmsleep(100);\n\thisi_hba->hw->phy_set_linkrate(hisi_hba, phy_no, &_r);\n\thisi_sas_phy_enable(hisi_hba, phy_no, 1);\n\n\treturn 0;\n}\n\nstatic int hisi_sas_control_phy(struct asd_sas_phy *sas_phy, enum phy_func func,\n\t\t\t\tvoid *funcdata)\n{\n\tstruct hisi_sas_phy *phy = container_of(sas_phy,\n\t\t\tstruct hisi_sas_phy, sas_phy);\n\tstruct sas_ha_struct *sas_ha = sas_phy->ha;\n\tstruct hisi_hba *hisi_hba = sas_ha->lldd_ha;\n\tstruct device *dev = hisi_hba->dev;\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tint phy_no = sas_phy->id;\n\tu8 sts = phy->phy_attached;\n\tint ret = 0;\n\n\tdown(&hisi_hba->sem);\n\tphy->reset_completion = &completion;\n\n\tswitch (func) {\n\tcase PHY_FUNC_HARD_RESET:\n\t\thisi_hba->hw->phy_hard_reset(hisi_hba, phy_no);\n\t\tbreak;\n\n\tcase PHY_FUNC_LINK_RESET:\n\t\thisi_sas_phy_enable(hisi_hba, phy_no, 0);\n\t\tmsleep(100);\n\t\thisi_sas_phy_enable(hisi_hba, phy_no, 1);\n\t\tbreak;\n\n\tcase PHY_FUNC_DISABLE:\n\t\thisi_sas_phy_enable(hisi_hba, phy_no, 0);\n\t\tgoto out;\n\n\tcase PHY_FUNC_SET_LINK_RATE:\n\t\tret = hisi_sas_phy_set_linkrate(hisi_hba, phy_no, funcdata);\n\t\tbreak;\n\n\tcase PHY_FUNC_GET_EVENTS:\n\t\tif (hisi_hba->hw->get_events) {\n\t\t\thisi_hba->hw->get_events(hisi_hba, phy_no);\n\t\t\tgoto out;\n\t\t}\n\t\tfallthrough;\n\tcase PHY_FUNC_RELEASE_SPINUP_HOLD:\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (sts && !wait_for_completion_timeout(&completion,\n\t\tHISI_SAS_WAIT_PHYUP_TIMEOUT)) {\n\t\tdev_warn(dev, \"phy%d wait phyup timed out for func %d\\n\",\n\t\t\t phy_no, func);\n\t\tif (phy->in_reset)\n\t\t\tret = -ETIMEDOUT;\n\t}\n\nout:\n\tphy->reset_completion = NULL;\n\n\tup(&hisi_hba->sem);\n\treturn ret;\n}\n\nstatic void hisi_sas_fill_ata_reset_cmd(struct ata_device *dev,\n\t\tbool reset, int pmp, u8 *fis)\n{\n\tstruct ata_taskfile tf;\n\n\tata_tf_init(dev, &tf);\n\tif (reset)\n\t\ttf.ctl |= ATA_SRST;\n\telse\n\t\ttf.ctl &= ~ATA_SRST;\n\ttf.command = ATA_CMD_DEV_RESET;\n\tata_tf_to_fis(&tf, pmp, 0, fis);\n}\n\nstatic int hisi_sas_softreset_ata_disk(struct domain_device *device)\n{\n\tu8 fis[20] = {0};\n\tstruct ata_port *ap = device->sata_dev.ap;\n\tstruct ata_link *link;\n\tint rc = TMF_RESP_FUNC_FAILED;\n\tstruct hisi_hba *hisi_hba = dev_to_hisi_hba(device);\n\tstruct device *dev = hisi_hba->dev;\n\n\tata_for_each_link(link, ap, EDGE) {\n\t\tint pmp = sata_srst_pmp(link);\n\n\t\thisi_sas_fill_ata_reset_cmd(link->device, 1, pmp, fis);\n\t\trc = sas_execute_ata_cmd(device, fis, -1);\n\t\tif (rc != TMF_RESP_FUNC_COMPLETE)\n\t\t\tbreak;\n\t}\n\n\tif (rc == TMF_RESP_FUNC_COMPLETE) {\n\t\tata_for_each_link(link, ap, EDGE) {\n\t\t\tint pmp = sata_srst_pmp(link);\n\n\t\t\thisi_sas_fill_ata_reset_cmd(link->device, 0, pmp, fis);\n\t\t\trc = sas_execute_ata_cmd(device, fis, -1);\n\t\t\tif (rc != TMF_RESP_FUNC_COMPLETE)\n\t\t\t\tdev_err(dev, \"ata disk %016llx de-reset failed\\n\",\n\t\t\t\t\tSAS_ADDR(device->sas_addr));\n\t\t}\n\t} else {\n\t\tdev_err(dev, \"ata disk %016llx reset failed\\n\",\n\t\t\tSAS_ADDR(device->sas_addr));\n\t}\n\n\tif (rc == TMF_RESP_FUNC_COMPLETE)\n\t\thisi_sas_release_task(hisi_hba, device);\n\n\treturn rc;\n}\n\nstatic void hisi_sas_refresh_port_id(struct hisi_hba *hisi_hba)\n{\n\tu32 state = hisi_hba->hw->get_phys_state(hisi_hba);\n\tint i;\n\n\tfor (i = 0; i < HISI_SAS_MAX_DEVICES; i++) {\n\t\tstruct hisi_sas_device *sas_dev = &hisi_hba->devices[i];\n\t\tstruct domain_device *device = sas_dev->sas_device;\n\t\tstruct asd_sas_port *sas_port;\n\t\tstruct hisi_sas_port *port;\n\t\tstruct hisi_sas_phy *phy = NULL;\n\t\tstruct asd_sas_phy *sas_phy;\n\n\t\tif ((sas_dev->dev_type == SAS_PHY_UNUSED)\n\t\t\t\t|| !device || !device->port)\n\t\t\tcontinue;\n\n\t\tsas_port = device->port;\n\t\tport = to_hisi_sas_port(sas_port);\n\n\t\tspin_lock(&sas_port->phy_list_lock);\n\t\tlist_for_each_entry(sas_phy, &sas_port->phy_list, port_phy_el)\n\t\t\tif (state & BIT(sas_phy->id)) {\n\t\t\t\tphy = sas_phy->lldd_phy;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tspin_unlock(&sas_port->phy_list_lock);\n\n\t\tif (phy) {\n\t\t\tport->id = phy->port_id;\n\n\t\t\t \n\t\t\tif (!device->parent)\n\t\t\t\tdevice->linkrate = phy->sas_phy.linkrate;\n\n\t\t\thisi_hba->hw->setup_itct(hisi_hba, sas_dev);\n\t\t} else if (!port->port_attached)\n\t\t\tport->id = 0xff;\n\t}\n}\n\nstatic void hisi_sas_rescan_topology(struct hisi_hba *hisi_hba, u32 state)\n{\n\tstruct asd_sas_port *_sas_port = NULL;\n\tint phy_no;\n\n\tfor (phy_no = 0; phy_no < hisi_hba->n_phy; phy_no++) {\n\t\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\t\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\t\tstruct asd_sas_port *sas_port = sas_phy->port;\n\t\tbool do_port_check = _sas_port != sas_port;\n\n\t\tif (!sas_phy->phy->enabled)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (state & BIT(phy_no)) {\n\t\t\tif (do_port_check && sas_port && sas_port->port_dev) {\n\t\t\t\tstruct domain_device *dev = sas_port->port_dev;\n\n\t\t\t\t_sas_port = sas_port;\n\n\t\t\t\tif (dev_is_expander(dev->dev_type))\n\t\t\t\t\tsas_notify_port_event(sas_phy,\n\t\t\t\t\t\t\tPORTE_BROADCAST_RCVD,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t}\n\t\t} else {\n\t\t\thisi_sas_phy_down(hisi_hba, phy_no, 0, GFP_KERNEL);\n\t\t}\n\t}\n}\n\nstatic void hisi_sas_reset_init_all_devices(struct hisi_hba *hisi_hba)\n{\n\tstruct hisi_sas_device *sas_dev;\n\tstruct domain_device *device;\n\tint i;\n\n\tfor (i = 0; i < HISI_SAS_MAX_DEVICES; i++) {\n\t\tsas_dev = &hisi_hba->devices[i];\n\t\tdevice = sas_dev->sas_device;\n\n\t\tif ((sas_dev->dev_type == SAS_PHY_UNUSED) || !device)\n\t\t\tcontinue;\n\n\t\thisi_sas_init_device(device);\n\t}\n}\n\nstatic void hisi_sas_send_ata_reset_each_phy(struct hisi_hba *hisi_hba,\n\t\t\t\t\t     struct asd_sas_port *sas_port,\n\t\t\t\t\t     struct domain_device *device)\n{\n\tstruct ata_port *ap = device->sata_dev.ap;\n\tstruct device *dev = hisi_hba->dev;\n\tint rc = TMF_RESP_FUNC_FAILED;\n\tstruct ata_link *link;\n\tu8 fis[20] = {0};\n\tint i;\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\tif (!(sas_port->phy_mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tata_for_each_link(link, ap, EDGE) {\n\t\t\tint pmp = sata_srst_pmp(link);\n\n\t\t\thisi_sas_fill_ata_reset_cmd(link->device, 1, pmp, fis);\n\t\t\trc = sas_execute_ata_cmd(device, fis, i);\n\t\t\tif (rc != TMF_RESP_FUNC_COMPLETE) {\n\t\t\t\tdev_err(dev, \"phy%d ata reset failed rc=%d\\n\",\n\t\t\t\t\ti, rc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void hisi_sas_terminate_stp_reject(struct hisi_hba *hisi_hba)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tint port_no, rc, i;\n\n\tfor (i = 0; i < HISI_SAS_MAX_DEVICES; i++) {\n\t\tstruct hisi_sas_device *sas_dev = &hisi_hba->devices[i];\n\t\tstruct domain_device *device = sas_dev->sas_device;\n\n\t\tif ((sas_dev->dev_type == SAS_PHY_UNUSED) || !device)\n\t\t\tcontinue;\n\n\t\trc = hisi_sas_internal_task_abort_dev(sas_dev, false);\n\t\tif (rc < 0)\n\t\t\tdev_err(dev, \"STP reject: abort dev failed %d\\n\", rc);\n\t}\n\n\tfor (port_no = 0; port_no < hisi_hba->n_phy; port_no++) {\n\t\tstruct hisi_sas_port *port = &hisi_hba->port[port_no];\n\t\tstruct asd_sas_port *sas_port = &port->sas_port;\n\t\tstruct domain_device *port_dev = sas_port->port_dev;\n\t\tstruct domain_device *device;\n\n\t\tif (!port_dev || !dev_is_expander(port_dev->dev_type))\n\t\t\tcontinue;\n\n\t\t \n\t\tlist_for_each_entry(device, &sas_port->dev_list,\n\t\t\t\t    dev_list_node) {\n\t\t\tif (dev_is_sata(device)) {\n\t\t\t\thisi_sas_send_ata_reset_each_phy(hisi_hba,\n\t\t\t\t\t\t\t\t sas_port,\n\t\t\t\t\t\t\t\t device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid hisi_sas_controller_reset_prepare(struct hisi_hba *hisi_hba)\n{\n\tstruct Scsi_Host *shost = hisi_hba->shost;\n\n\thisi_hba->phy_state = hisi_hba->hw->get_phys_state(hisi_hba);\n\n\tscsi_block_requests(shost);\n\thisi_hba->hw->wait_cmds_complete_timeout(hisi_hba, 100, 5000);\n\n\tdel_timer_sync(&hisi_hba->timer);\n\n\tset_bit(HISI_SAS_REJECT_CMD_BIT, &hisi_hba->flags);\n}\nEXPORT_SYMBOL_GPL(hisi_sas_controller_reset_prepare);\n\nstatic void hisi_sas_async_init_wait_phyup(void *data, async_cookie_t cookie)\n{\n\tstruct hisi_sas_phy *phy = data;\n\tstruct hisi_hba *hisi_hba = phy->hisi_hba;\n\tstruct device *dev = hisi_hba->dev;\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tint phy_no = phy->sas_phy.id;\n\n\tphy->reset_completion = &completion;\n\thisi_sas_phy_enable(hisi_hba, phy_no, 1);\n\tif (!wait_for_completion_timeout(&completion,\n\t\t\t\t\t HISI_SAS_WAIT_PHYUP_TIMEOUT))\n\t\tdev_warn(dev, \"phy%d wait phyup timed out\\n\", phy_no);\n\n\tphy->reset_completion = NULL;\n}\n\nvoid hisi_sas_controller_reset_done(struct hisi_hba *hisi_hba)\n{\n\tstruct Scsi_Host *shost = hisi_hba->shost;\n\tASYNC_DOMAIN_EXCLUSIVE(async);\n\tint phy_no;\n\n\t \n\tfor (phy_no = 0; phy_no < hisi_hba->n_phy; phy_no++) {\n\t\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\n\t\tif (!(hisi_hba->phy_state & BIT(phy_no)))\n\t\t\tcontinue;\n\n\t\tasync_schedule_domain(hisi_sas_async_init_wait_phyup,\n\t\t\t\t      phy, &async);\n\t}\n\n\tasync_synchronize_full_domain(&async);\n\thisi_sas_refresh_port_id(hisi_hba);\n\tclear_bit(HISI_SAS_REJECT_CMD_BIT, &hisi_hba->flags);\n\n\tif (hisi_hba->reject_stp_links_msk)\n\t\thisi_sas_terminate_stp_reject(hisi_hba);\n\thisi_sas_reset_init_all_devices(hisi_hba);\n\tscsi_unblock_requests(shost);\n\tclear_bit(HISI_SAS_RESETTING_BIT, &hisi_hba->flags);\n\tup(&hisi_hba->sem);\n\n\thisi_sas_rescan_topology(hisi_hba, hisi_hba->phy_state);\n}\nEXPORT_SYMBOL_GPL(hisi_sas_controller_reset_done);\n\nstatic int hisi_sas_controller_prereset(struct hisi_hba *hisi_hba)\n{\n\tif (!hisi_hba->hw->soft_reset)\n\t\treturn -ENOENT;\n\n\tdown(&hisi_hba->sem);\n\tif (test_and_set_bit(HISI_SAS_RESETTING_BIT, &hisi_hba->flags)) {\n\t\tup(&hisi_hba->sem);\n\t\treturn -EPERM;\n\t}\n\n\tif (hisi_sas_debugfs_enable && hisi_hba->debugfs_itct[0].itct)\n\t\thisi_hba->hw->debugfs_snapshot_regs(hisi_hba);\n\n\treturn 0;\n}\n\nstatic int hisi_sas_controller_reset(struct hisi_hba *hisi_hba)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tstruct Scsi_Host *shost = hisi_hba->shost;\n\tint rc;\n\n\tdev_info(dev, \"controller resetting...\\n\");\n\thisi_sas_controller_reset_prepare(hisi_hba);\n\n\trc = hisi_hba->hw->soft_reset(hisi_hba);\n\tif (rc) {\n\t\tdev_warn(dev, \"controller reset failed (%d)\\n\", rc);\n\t\tclear_bit(HISI_SAS_REJECT_CMD_BIT, &hisi_hba->flags);\n\t\tup(&hisi_hba->sem);\n\t\tscsi_unblock_requests(shost);\n\t\tclear_bit(HISI_SAS_RESETTING_BIT, &hisi_hba->flags);\n\t\treturn rc;\n\t}\n\tclear_bit(HISI_SAS_HW_FAULT_BIT, &hisi_hba->flags);\n\n\thisi_sas_controller_reset_done(hisi_hba);\n\tdev_info(dev, \"controller reset complete\\n\");\n\n\treturn 0;\n}\n\nstatic int hisi_sas_abort_task(struct sas_task *task)\n{\n\tstruct hisi_sas_internal_abort_data internal_abort_data = { false };\n\tstruct domain_device *device = task->dev;\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tstruct hisi_sas_slot *slot = task->lldd_task;\n\tstruct hisi_hba *hisi_hba;\n\tstruct device *dev;\n\tint rc = TMF_RESP_FUNC_FAILED;\n\tunsigned long flags;\n\n\tif (!sas_dev)\n\t\treturn TMF_RESP_FUNC_FAILED;\n\n\thisi_hba = dev_to_hisi_hba(task->dev);\n\tdev = hisi_hba->dev;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (task->task_state_flags & SAS_TASK_STATE_DONE) {\n\t\tstruct hisi_sas_cq *cq;\n\n\t\tif (slot) {\n\t\t\t \n\t\t\tcq = &hisi_hba->cq[slot->dlvry_queue];\n\t\t\thisi_sas_sync_cq(cq);\n\t\t}\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\trc = TMF_RESP_FUNC_COMPLETE;\n\t\tgoto out;\n\t}\n\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tif (!slot)\n\t\tgoto out;\n\n\tif (task->task_proto & SAS_PROTOCOL_SSP) {\n\t\tu16 tag = slot->idx;\n\t\tint rc2;\n\n\t\trc = sas_abort_task(task, tag);\n\t\trc2 = sas_execute_internal_abort_single(device, tag,\n\t\t\t\tslot->dlvry_queue, &internal_abort_data);\n\t\tif (rc2 < 0) {\n\t\t\tdev_err(dev, \"abort task: internal abort (%d)\\n\", rc2);\n\t\t\treturn TMF_RESP_FUNC_FAILED;\n\t\t}\n\n\t\t \n\t\tif (rc == TMF_RESP_FUNC_COMPLETE && rc2 != TMF_RESP_FUNC_SUCC) {\n\t\t\tif (task->lldd_task)\n\t\t\t\thisi_sas_do_release_task(hisi_hba, task, slot, true);\n\t\t}\n\t} else if (task->task_proto & SAS_PROTOCOL_SATA ||\n\t\ttask->task_proto & SAS_PROTOCOL_STP) {\n\t\tif (task->dev->dev_type == SAS_SATA_DEV) {\n\t\t\tstruct ata_queued_cmd *qc = task->uldd_task;\n\n\t\t\trc = hisi_sas_internal_task_abort_dev(sas_dev, false);\n\t\t\tif (rc < 0) {\n\t\t\t\tdev_err(dev, \"abort task: internal abort failed\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thisi_sas_dereg_device(hisi_hba, device);\n\n\t\t\t \n\t\t\tif ((sas_dev->dev_status == HISI_SAS_DEV_NCQ_ERR) &&\n\t\t\t    qc && qc->scsicmd) {\n\t\t\t\thisi_sas_do_release_task(hisi_hba, task, slot, true);\n\t\t\t\trc = TMF_RESP_FUNC_COMPLETE;\n\t\t\t} else {\n\t\t\t\trc = hisi_sas_softreset_ata_disk(device);\n\t\t\t}\n\t\t}\n\t} else if (task->task_proto & SAS_PROTOCOL_SMP) {\n\t\t \n\t\tu32 tag = slot->idx;\n\t\tstruct hisi_sas_cq *cq = &hisi_hba->cq[slot->dlvry_queue];\n\n\t\trc = sas_execute_internal_abort_single(device,\n\t\t\t\t\t\t       tag, slot->dlvry_queue,\n\t\t\t\t\t\t       &internal_abort_data);\n\t\tif (((rc < 0) || (rc == TMF_RESP_FUNC_FAILED)) &&\n\t\t\t\t\ttask->lldd_task) {\n\t\t\t \n\t\t\thisi_sas_sync_cq(cq);\n\t\t\tslot->task = NULL;\n\t\t}\n\t}\n\nout:\n\tif (rc != TMF_RESP_FUNC_COMPLETE)\n\t\tdev_notice(dev, \"abort task: rc=%d\\n\", rc);\n\treturn rc;\n}\n\nstatic int hisi_sas_abort_task_set(struct domain_device *device, u8 *lun)\n{\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tstruct hisi_hba *hisi_hba = dev_to_hisi_hba(device);\n\tstruct device *dev = hisi_hba->dev;\n\tint rc;\n\n\trc = hisi_sas_internal_task_abort_dev(sas_dev, false);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"abort task set: internal abort rc=%d\\n\", rc);\n\t\treturn TMF_RESP_FUNC_FAILED;\n\t}\n\thisi_sas_dereg_device(hisi_hba, device);\n\n\trc = sas_abort_task_set(device, lun);\n\tif (rc == TMF_RESP_FUNC_COMPLETE)\n\t\thisi_sas_release_task(hisi_hba, device);\n\n\treturn rc;\n}\n\nstatic int hisi_sas_debug_I_T_nexus_reset(struct domain_device *device)\n{\n\tstruct sas_phy *local_phy = sas_get_local_phy(device);\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tstruct hisi_hba *hisi_hba = dev_to_hisi_hba(device);\n\tstruct sas_ha_struct *sas_ha = &hisi_hba->sha;\n\tint rc, reset_type;\n\n\tif (!local_phy->enabled) {\n\t\tsas_put_local_phy(local_phy);\n\t\treturn -ENODEV;\n\t}\n\n\tif (scsi_is_sas_phy_local(local_phy)) {\n\t\tstruct asd_sas_phy *sas_phy =\n\t\t\tsas_ha->sas_phy[local_phy->number];\n\t\tstruct hisi_sas_phy *phy =\n\t\t\tcontainer_of(sas_phy, struct hisi_sas_phy, sas_phy);\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&phy->lock, flags);\n\t\tphy->in_reset = 1;\n\t\tspin_unlock_irqrestore(&phy->lock, flags);\n\t}\n\n\treset_type = (sas_dev->dev_status == HISI_SAS_DEV_INIT ||\n\t\t      !dev_is_sata(device)) ? true : false;\n\n\trc = sas_phy_reset(local_phy, reset_type);\n\tsas_put_local_phy(local_phy);\n\n\tif (scsi_is_sas_phy_local(local_phy)) {\n\t\tstruct asd_sas_phy *sas_phy =\n\t\t\tsas_ha->sas_phy[local_phy->number];\n\t\tstruct hisi_sas_phy *phy =\n\t\t\tcontainer_of(sas_phy, struct hisi_sas_phy, sas_phy);\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&phy->lock, flags);\n\t\tphy->in_reset = 0;\n\t\tspin_unlock_irqrestore(&phy->lock, flags);\n\n\t\t \n\t\tif (rc == -ETIMEDOUT)\n\t\t\thisi_sas_phy_down(hisi_hba, sas_phy->id, 0, GFP_KERNEL);\n\t\treturn rc;\n\t}\n\n\t \n\tif (rc)\n\t\treturn rc;\n\n\tif (dev_is_sata(device)) {\n\t\tstruct ata_link *link = &device->sata_dev.ap->link;\n\n\t\trc = ata_wait_after_reset(link, HISI_SAS_WAIT_PHYUP_TIMEOUT,\n\t\t\t\t\t  smp_ata_check_ready_type);\n\t} else {\n\t\tmsleep(2000);\n\t}\n\n\treturn rc;\n}\n\nstatic int hisi_sas_I_T_nexus_reset(struct domain_device *device)\n{\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tstruct hisi_hba *hisi_hba = dev_to_hisi_hba(device);\n\tstruct device *dev = hisi_hba->dev;\n\tint rc;\n\n\tif (sas_dev->dev_status == HISI_SAS_DEV_NCQ_ERR)\n\t\tsas_dev->dev_status = HISI_SAS_DEV_NORMAL;\n\n\trc = hisi_sas_internal_task_abort_dev(sas_dev, false);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"I_T nexus reset: internal abort (%d)\\n\", rc);\n\t\treturn TMF_RESP_FUNC_FAILED;\n\t}\n\thisi_sas_dereg_device(hisi_hba, device);\n\n\trc = hisi_sas_debug_I_T_nexus_reset(device);\n\tif (rc == TMF_RESP_FUNC_COMPLETE && dev_is_sata(device)) {\n\t\tstruct sas_phy *local_phy;\n\n\t\trc = hisi_sas_softreset_ata_disk(device);\n\t\tswitch (rc) {\n\t\tcase -ECOMM:\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tcase TMF_RESP_FUNC_FAILED:\n\t\tcase -EMSGSIZE:\n\t\tcase -EIO:\n\t\t\tlocal_phy = sas_get_local_phy(device);\n\t\t\trc = sas_phy_enable(local_phy, 0);\n\t\t\tif (!rc) {\n\t\t\t\tlocal_phy->enabled = 0;\n\t\t\t\tdev_err(dev, \"Disabled local phy of ATA disk %016llx due to softreset fail (%d)\\n\",\n\t\t\t\t\tSAS_ADDR(device->sas_addr), rc);\n\t\t\t\trc = -ENODEV;\n\t\t\t}\n\t\t\tsas_put_local_phy(local_phy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((rc == TMF_RESP_FUNC_COMPLETE) || (rc == -ENODEV))\n\t\thisi_sas_release_task(hisi_hba, device);\n\n\treturn rc;\n}\n\nstatic int hisi_sas_lu_reset(struct domain_device *device, u8 *lun)\n{\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tstruct hisi_hba *hisi_hba = dev_to_hisi_hba(device);\n\tstruct device *dev = hisi_hba->dev;\n\tint rc = TMF_RESP_FUNC_FAILED;\n\n\t \n\trc = hisi_sas_internal_task_abort_dev(sas_dev, false);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"lu_reset: internal abort failed\\n\");\n\t\tgoto out;\n\t}\n\thisi_sas_dereg_device(hisi_hba, device);\n\n\tif (dev_is_sata(device)) {\n\t\tstruct sas_phy *phy;\n\n\t\tphy = sas_get_local_phy(device);\n\n\t\trc = sas_phy_reset(phy, true);\n\n\t\tif (rc == 0)\n\t\t\thisi_sas_release_task(hisi_hba, device);\n\t\tsas_put_local_phy(phy);\n\t} else {\n\t\trc = sas_lu_reset(device, lun);\n\t\tif (rc == TMF_RESP_FUNC_COMPLETE)\n\t\t\thisi_sas_release_task(hisi_hba, device);\n\t}\nout:\n\tif (rc != TMF_RESP_FUNC_COMPLETE)\n\t\tdev_err(dev, \"lu_reset: for device[%d]:rc= %d\\n\",\n\t\t\t     sas_dev->device_id, rc);\n\treturn rc;\n}\n\nstatic void hisi_sas_async_I_T_nexus_reset(void *data, async_cookie_t cookie)\n{\n\tstruct domain_device *device = data;\n\tstruct hisi_hba *hisi_hba = dev_to_hisi_hba(device);\n\tint rc;\n\n\trc = hisi_sas_debug_I_T_nexus_reset(device);\n\tif (rc != TMF_RESP_FUNC_COMPLETE)\n\t\tdev_info(hisi_hba->dev, \"I_T_nexus reset fail for dev:%016llx rc=%d\\n\",\n\t\t\t SAS_ADDR(device->sas_addr), rc);\n}\n\nstatic int hisi_sas_clear_nexus_ha(struct sas_ha_struct *sas_ha)\n{\n\tstruct hisi_hba *hisi_hba = sas_ha->lldd_ha;\n\tHISI_SAS_DECLARE_RST_WORK_ON_STACK(r);\n\tASYNC_DOMAIN_EXCLUSIVE(async);\n\tint i;\n\n\tqueue_work(hisi_hba->wq, &r.work);\n\twait_for_completion(r.completion);\n\tif (!r.done)\n\t\treturn TMF_RESP_FUNC_FAILED;\n\n\tfor (i = 0; i < HISI_SAS_MAX_DEVICES; i++) {\n\t\tstruct hisi_sas_device *sas_dev = &hisi_hba->devices[i];\n\t\tstruct domain_device *device = sas_dev->sas_device;\n\n\t\tif ((sas_dev->dev_type == SAS_PHY_UNUSED) || !device ||\n\t\t    dev_is_expander(device->dev_type))\n\t\t\tcontinue;\n\n\t\tasync_schedule_domain(hisi_sas_async_I_T_nexus_reset,\n\t\t\t\t      device, &async);\n\t}\n\n\tasync_synchronize_full_domain(&async);\n\thisi_sas_release_tasks(hisi_hba);\n\n\treturn TMF_RESP_FUNC_COMPLETE;\n}\n\nstatic int hisi_sas_query_task(struct sas_task *task)\n{\n\tint rc = TMF_RESP_FUNC_FAILED;\n\n\tif (task->lldd_task && task->task_proto & SAS_PROTOCOL_SSP) {\n\t\tstruct hisi_sas_slot *slot = task->lldd_task;\n\t\tu32 tag = slot->idx;\n\n\t\trc = sas_query_task(task, tag);\n\t\tswitch (rc) {\n\t\t \n\t\tcase TMF_RESP_FUNC_SUCC:\n\t\t \n\t\tcase TMF_RESP_FUNC_FAILED:\n\t\tcase TMF_RESP_FUNC_COMPLETE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = TMF_RESP_FUNC_FAILED;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic bool hisi_sas_internal_abort_timeout(struct sas_task *task,\n\t\t\t\t\t    void *data)\n{\n\tstruct domain_device *device = task->dev;\n\tstruct hisi_hba *hisi_hba = dev_to_hisi_hba(device);\n\tstruct hisi_sas_internal_abort_data *timeout = data;\n\n\tif (hisi_sas_debugfs_enable && hisi_hba->debugfs_itct[0].itct)\n\t\tqueue_work(hisi_hba->wq, &hisi_hba->debugfs_work);\n\n\tif (task->task_state_flags & SAS_TASK_STATE_DONE) {\n\t\tpr_err(\"Internal abort: timeout %016llx\\n\",\n\t\t       SAS_ADDR(device->sas_addr));\n\t} else {\n\t\tstruct hisi_sas_slot *slot = task->lldd_task;\n\n\t\tset_bit(HISI_SAS_HW_FAULT_BIT, &hisi_hba->flags);\n\n\t\tif (slot) {\n\t\t\tstruct hisi_sas_cq *cq =\n\t\t\t\t&hisi_hba->cq[slot->dlvry_queue];\n\t\t\t \n\t\t\thisi_sas_sync_cq(cq);\n\t\t\tslot->task = NULL;\n\t\t}\n\n\t\tif (timeout->rst_ha_timeout) {\n\t\t\tpr_err(\"Internal abort: timeout and not done %016llx. Queuing reset.\\n\",\n\t\t\t       SAS_ADDR(device->sas_addr));\n\t\t\tqueue_work(hisi_hba->wq, &hisi_hba->rst_work);\n\t\t} else {\n\t\t\tpr_err(\"Internal abort: timeout and not done %016llx.\\n\",\n\t\t\t       SAS_ADDR(device->sas_addr));\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void hisi_sas_port_formed(struct asd_sas_phy *sas_phy)\n{\n\thisi_sas_port_notify_formed(sas_phy);\n}\n\nstatic int hisi_sas_write_gpio(struct sas_ha_struct *sha, u8 reg_type,\n\t\t\tu8 reg_index, u8 reg_count, u8 *write_data)\n{\n\tstruct hisi_hba *hisi_hba = sha->lldd_ha;\n\n\tif (!hisi_hba->hw->write_gpio)\n\t\treturn -EOPNOTSUPP;\n\n\treturn hisi_hba->hw->write_gpio(hisi_hba, reg_type,\n\t\t\t\treg_index, reg_count, write_data);\n}\n\nstatic void hisi_sas_phy_disconnected(struct hisi_sas_phy *phy)\n{\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tstruct sas_phy *sphy = sas_phy->phy;\n\tunsigned long flags;\n\n\tphy->phy_attached = 0;\n\tphy->phy_type = 0;\n\tphy->port = NULL;\n\n\tspin_lock_irqsave(&phy->lock, flags);\n\tif (phy->enable)\n\t\tsphy->negotiated_linkrate = SAS_LINK_RATE_UNKNOWN;\n\telse\n\t\tsphy->negotiated_linkrate = SAS_PHY_DISABLED;\n\tspin_unlock_irqrestore(&phy->lock, flags);\n}\n\nvoid hisi_sas_phy_down(struct hisi_hba *hisi_hba, int phy_no, int rdy,\n\t\t       gfp_t gfp_flags)\n{\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tstruct device *dev = hisi_hba->dev;\n\n\tif (rdy) {\n\t\t \n\t\thisi_sas_bytes_dmaed(hisi_hba, phy_no, gfp_flags);\n\t\thisi_sas_port_notify_formed(sas_phy);\n\t} else {\n\t\tstruct hisi_sas_port *port  = phy->port;\n\n\t\tif (test_bit(HISI_SAS_RESETTING_BIT, &hisi_hba->flags) ||\n\t\t    phy->in_reset) {\n\t\t\tdev_info(dev, \"ignore flutter phy%d down\\n\", phy_no);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tsas_notify_phy_event(sas_phy, PHYE_LOSS_OF_SIGNAL, gfp_flags);\n\t\tsas_phy_disconnected(sas_phy);\n\n\t\tif (port) {\n\t\t\tif (phy->phy_type & PORT_TYPE_SAS) {\n\t\t\t\tint port_id = port->id;\n\n\t\t\t\tif (!hisi_hba->hw->get_wideport_bitmap(hisi_hba,\n\t\t\t\t\t\t\t\t       port_id))\n\t\t\t\t\tport->port_attached = 0;\n\t\t\t} else if (phy->phy_type & PORT_TYPE_SATA)\n\t\t\t\tport->port_attached = 0;\n\t\t}\n\t\thisi_sas_phy_disconnected(phy);\n\t}\n}\nEXPORT_SYMBOL_GPL(hisi_sas_phy_down);\n\nvoid hisi_sas_phy_bcast(struct hisi_sas_phy *phy)\n{\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tstruct hisi_hba\t*hisi_hba = phy->hisi_hba;\n\n\tif (test_bit(HISI_SAS_RESETTING_BIT, &hisi_hba->flags))\n\t\treturn;\n\n\tsas_notify_port_event(sas_phy, PORTE_BROADCAST_RCVD, GFP_ATOMIC);\n}\nEXPORT_SYMBOL_GPL(hisi_sas_phy_bcast);\n\nint hisi_sas_host_reset(struct Scsi_Host *shost, int reset_type)\n{\n\tstruct hisi_hba *hisi_hba = shost_priv(shost);\n\n\tif (reset_type != SCSI_ADAPTER_RESET)\n\t\treturn -EOPNOTSUPP;\n\n\tqueue_work(hisi_hba->wq, &hisi_hba->rst_work);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hisi_sas_host_reset);\n\nstruct scsi_transport_template *hisi_sas_stt;\nEXPORT_SYMBOL_GPL(hisi_sas_stt);\n\nstatic struct sas_domain_function_template hisi_sas_transport_ops = {\n\t.lldd_dev_found\t\t= hisi_sas_dev_found,\n\t.lldd_dev_gone\t\t= hisi_sas_dev_gone,\n\t.lldd_execute_task\t= hisi_sas_queue_command,\n\t.lldd_control_phy\t= hisi_sas_control_phy,\n\t.lldd_abort_task\t= hisi_sas_abort_task,\n\t.lldd_abort_task_set\t= hisi_sas_abort_task_set,\n\t.lldd_I_T_nexus_reset\t= hisi_sas_I_T_nexus_reset,\n\t.lldd_lu_reset\t\t= hisi_sas_lu_reset,\n\t.lldd_query_task\t= hisi_sas_query_task,\n\t.lldd_clear_nexus_ha\t= hisi_sas_clear_nexus_ha,\n\t.lldd_port_formed\t= hisi_sas_port_formed,\n\t.lldd_write_gpio\t= hisi_sas_write_gpio,\n\t.lldd_tmf_aborted\t= hisi_sas_tmf_aborted,\n\t.lldd_abort_timeout\t= hisi_sas_internal_abort_timeout,\n};\n\nvoid hisi_sas_init_mem(struct hisi_hba *hisi_hba)\n{\n\tint i, s, j, max_command_entries = HISI_SAS_MAX_COMMANDS;\n\tstruct hisi_sas_breakpoint *sata_breakpoint = hisi_hba->sata_breakpoint;\n\n\tfor (i = 0; i < hisi_hba->queue_count; i++) {\n\t\tstruct hisi_sas_cq *cq = &hisi_hba->cq[i];\n\t\tstruct hisi_sas_dq *dq = &hisi_hba->dq[i];\n\t\tstruct hisi_sas_cmd_hdr *cmd_hdr = hisi_hba->cmd_hdr[i];\n\n\t\ts = sizeof(struct hisi_sas_cmd_hdr);\n\t\tfor (j = 0; j < HISI_SAS_QUEUE_SLOTS; j++)\n\t\t\tmemset(&cmd_hdr[j], 0, s);\n\n\t\tdq->wr_point = 0;\n\n\t\ts = hisi_hba->hw->complete_hdr_size * HISI_SAS_QUEUE_SLOTS;\n\t\tmemset(hisi_hba->complete_hdr[i], 0, s);\n\t\tcq->rd_point = 0;\n\t}\n\n\ts = sizeof(struct hisi_sas_initial_fis) * hisi_hba->n_phy;\n\tmemset(hisi_hba->initial_fis, 0, s);\n\n\ts = max_command_entries * sizeof(struct hisi_sas_iost);\n\tmemset(hisi_hba->iost, 0, s);\n\n\ts = max_command_entries * sizeof(struct hisi_sas_breakpoint);\n\tmemset(hisi_hba->breakpoint, 0, s);\n\n\ts = sizeof(struct hisi_sas_sata_breakpoint);\n\tfor (j = 0; j < HISI_SAS_MAX_ITCT_ENTRIES; j++)\n\t\tmemset(&sata_breakpoint[j], 0, s);\n}\nEXPORT_SYMBOL_GPL(hisi_sas_init_mem);\n\nint hisi_sas_alloc(struct hisi_hba *hisi_hba)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tint i, j, s, max_command_entries = HISI_SAS_MAX_COMMANDS;\n\tint max_command_entries_ru, sz_slot_buf_ru;\n\tint blk_cnt, slots_per_blk;\n\n\tsema_init(&hisi_hba->sem, 1);\n\tspin_lock_init(&hisi_hba->lock);\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\thisi_sas_phy_init(hisi_hba, i);\n\t\thisi_hba->port[i].port_attached = 0;\n\t\thisi_hba->port[i].id = -1;\n\t}\n\n\tfor (i = 0; i < HISI_SAS_MAX_DEVICES; i++) {\n\t\thisi_hba->devices[i].dev_type = SAS_PHY_UNUSED;\n\t\thisi_hba->devices[i].device_id = i;\n\t\thisi_hba->devices[i].dev_status = HISI_SAS_DEV_INIT;\n\t}\n\n\tfor (i = 0; i < hisi_hba->queue_count; i++) {\n\t\tstruct hisi_sas_cq *cq = &hisi_hba->cq[i];\n\t\tstruct hisi_sas_dq *dq = &hisi_hba->dq[i];\n\n\t\t \n\t\tcq->id = i;\n\t\tcq->hisi_hba = hisi_hba;\n\t\tspin_lock_init(&cq->poll_lock);\n\n\t\t \n\t\tspin_lock_init(&dq->lock);\n\t\tINIT_LIST_HEAD(&dq->list);\n\t\tdq->id = i;\n\t\tdq->hisi_hba = hisi_hba;\n\n\t\t \n\t\ts = sizeof(struct hisi_sas_cmd_hdr) * HISI_SAS_QUEUE_SLOTS;\n\t\thisi_hba->cmd_hdr[i] = dmam_alloc_coherent(dev, s,\n\t\t\t\t\t\t&hisi_hba->cmd_hdr_dma[i],\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!hisi_hba->cmd_hdr[i])\n\t\t\tgoto err_out;\n\n\t\t \n\t\ts = hisi_hba->hw->complete_hdr_size * HISI_SAS_QUEUE_SLOTS;\n\t\thisi_hba->complete_hdr[i] = dmam_alloc_coherent(dev, s,\n\t\t\t\t\t\t&hisi_hba->complete_hdr_dma[i],\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!hisi_hba->complete_hdr[i])\n\t\t\tgoto err_out;\n\t}\n\n\ts = HISI_SAS_MAX_ITCT_ENTRIES * sizeof(struct hisi_sas_itct);\n\thisi_hba->itct = dmam_alloc_coherent(dev, s, &hisi_hba->itct_dma,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!hisi_hba->itct)\n\t\tgoto err_out;\n\n\thisi_hba->slot_info = devm_kcalloc(dev, max_command_entries,\n\t\t\t\t\t   sizeof(struct hisi_sas_slot),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!hisi_hba->slot_info)\n\t\tgoto err_out;\n\n\t \n\tmax_command_entries_ru = roundup(max_command_entries, 64);\n\tif (hisi_hba->prot_mask & HISI_SAS_DIX_PROT_MASK)\n\t\tsz_slot_buf_ru = sizeof(struct hisi_sas_slot_dif_buf_table);\n\telse\n\t\tsz_slot_buf_ru = sizeof(struct hisi_sas_slot_buf_table);\n\tsz_slot_buf_ru = roundup(sz_slot_buf_ru, 64);\n\ts = max(lcm(max_command_entries_ru, sz_slot_buf_ru), PAGE_SIZE);\n\tblk_cnt = (max_command_entries_ru * sz_slot_buf_ru) / s;\n\tslots_per_blk = s / sz_slot_buf_ru;\n\n\tfor (i = 0; i < blk_cnt; i++) {\n\t\tint slot_index = i * slots_per_blk;\n\t\tdma_addr_t buf_dma;\n\t\tvoid *buf;\n\n\t\tbuf = dmam_alloc_coherent(dev, s, &buf_dma,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto err_out;\n\n\t\tfor (j = 0; j < slots_per_blk; j++, slot_index++) {\n\t\t\tstruct hisi_sas_slot *slot;\n\n\t\t\tslot = &hisi_hba->slot_info[slot_index];\n\t\t\tslot->buf = buf;\n\t\t\tslot->buf_dma = buf_dma;\n\t\t\tslot->idx = slot_index;\n\n\t\t\tbuf += sz_slot_buf_ru;\n\t\t\tbuf_dma += sz_slot_buf_ru;\n\t\t}\n\t}\n\n\ts = max_command_entries * sizeof(struct hisi_sas_iost);\n\thisi_hba->iost = dmam_alloc_coherent(dev, s, &hisi_hba->iost_dma,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!hisi_hba->iost)\n\t\tgoto err_out;\n\n\ts = max_command_entries * sizeof(struct hisi_sas_breakpoint);\n\thisi_hba->breakpoint = dmam_alloc_coherent(dev, s,\n\t\t\t\t\t\t   &hisi_hba->breakpoint_dma,\n\t\t\t\t\t\t   GFP_KERNEL);\n\tif (!hisi_hba->breakpoint)\n\t\tgoto err_out;\n\n\ts = hisi_hba->slot_index_count = max_command_entries;\n\thisi_hba->slot_index_tags = devm_bitmap_zalloc(dev, s, GFP_KERNEL);\n\tif (!hisi_hba->slot_index_tags)\n\t\tgoto err_out;\n\n\ts = sizeof(struct hisi_sas_initial_fis) * HISI_SAS_MAX_PHYS;\n\thisi_hba->initial_fis = dmam_alloc_coherent(dev, s,\n\t\t\t\t\t\t    &hisi_hba->initial_fis_dma,\n\t\t\t\t\t\t    GFP_KERNEL);\n\tif (!hisi_hba->initial_fis)\n\t\tgoto err_out;\n\n\ts = HISI_SAS_MAX_ITCT_ENTRIES * sizeof(struct hisi_sas_sata_breakpoint);\n\thisi_hba->sata_breakpoint = dmam_alloc_coherent(dev, s,\n\t\t\t\t\t&hisi_hba->sata_breakpoint_dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!hisi_hba->sata_breakpoint)\n\t\tgoto err_out;\n\n\thisi_hba->last_slot_index = 0;\n\n\thisi_hba->wq = create_singlethread_workqueue(dev_name(dev));\n\tif (!hisi_hba->wq) {\n\t\tdev_err(dev, \"sas_alloc: failed to create workqueue\\n\");\n\t\tgoto err_out;\n\t}\n\n\treturn 0;\nerr_out:\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(hisi_sas_alloc);\n\nvoid hisi_sas_free(struct hisi_hba *hisi_hba)\n{\n\tint i;\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\tstruct hisi_sas_phy *phy = &hisi_hba->phy[i];\n\n\t\tdel_timer_sync(&phy->timer);\n\t}\n\n\tif (hisi_hba->wq)\n\t\tdestroy_workqueue(hisi_hba->wq);\n}\nEXPORT_SYMBOL_GPL(hisi_sas_free);\n\nvoid hisi_sas_rst_work_handler(struct work_struct *work)\n{\n\tstruct hisi_hba *hisi_hba =\n\t\tcontainer_of(work, struct hisi_hba, rst_work);\n\n\tif (hisi_sas_controller_prereset(hisi_hba))\n\t\treturn;\n\n\thisi_sas_controller_reset(hisi_hba);\n}\nEXPORT_SYMBOL_GPL(hisi_sas_rst_work_handler);\n\nvoid hisi_sas_sync_rst_work_handler(struct work_struct *work)\n{\n\tstruct hisi_sas_rst *rst =\n\t\tcontainer_of(work, struct hisi_sas_rst, work);\n\n\tif (hisi_sas_controller_prereset(rst->hisi_hba))\n\t\tgoto rst_complete;\n\n\tif (!hisi_sas_controller_reset(rst->hisi_hba))\n\t\trst->done = true;\nrst_complete:\n\tcomplete(rst->completion);\n}\nEXPORT_SYMBOL_GPL(hisi_sas_sync_rst_work_handler);\n\nint hisi_sas_get_fw_info(struct hisi_hba *hisi_hba)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tstruct platform_device *pdev = hisi_hba->platform_dev;\n\tstruct device_node *np = pdev ? pdev->dev.of_node : NULL;\n\tstruct clk *refclk;\n\n\tif (device_property_read_u8_array(dev, \"sas-addr\", hisi_hba->sas_addr,\n\t\t\t\t\t  SAS_ADDR_SIZE)) {\n\t\tdev_err(dev, \"could not get property sas-addr\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (np) {\n\t\t \n\t\thisi_hba->ctrl = syscon_regmap_lookup_by_phandle(np,\n\t\t\t\t\t\"hisilicon,sas-syscon\");\n\t\tif (IS_ERR(hisi_hba->ctrl)) {\n\t\t\tdev_err(dev, \"could not get syscon\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (device_property_read_u32(dev, \"ctrl-reset-reg\",\n\t\t\t\t\t     &hisi_hba->ctrl_reset_reg)) {\n\t\t\tdev_err(dev, \"could not get property ctrl-reset-reg\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (device_property_read_u32(dev, \"ctrl-reset-sts-reg\",\n\t\t\t\t\t     &hisi_hba->ctrl_reset_sts_reg)) {\n\t\t\tdev_err(dev, \"could not get property ctrl-reset-sts-reg\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (device_property_read_u32(dev, \"ctrl-clock-ena-reg\",\n\t\t\t\t\t     &hisi_hba->ctrl_clock_ena_reg)) {\n\t\t\tdev_err(dev, \"could not get property ctrl-clock-ena-reg\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\trefclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(refclk))\n\t\tdev_dbg(dev, \"no ref clk property\\n\");\n\telse\n\t\thisi_hba->refclk_frequency_mhz = clk_get_rate(refclk) / 1000000;\n\n\tif (device_property_read_u32(dev, \"phy-count\", &hisi_hba->n_phy)) {\n\t\tdev_err(dev, \"could not get property phy-count\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (device_property_read_u32(dev, \"queue-count\",\n\t\t\t\t     &hisi_hba->queue_count)) {\n\t\tdev_err(dev, \"could not get property queue-count\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hisi_sas_get_fw_info);\n\nstatic struct Scsi_Host *hisi_sas_shost_alloc(struct platform_device *pdev,\n\t\t\t\t\t      const struct hisi_sas_hw *hw)\n{\n\tstruct resource *res;\n\tstruct Scsi_Host *shost;\n\tstruct hisi_hba *hisi_hba;\n\tstruct device *dev = &pdev->dev;\n\tint error;\n\n\tshost = scsi_host_alloc(hw->sht, sizeof(*hisi_hba));\n\tif (!shost) {\n\t\tdev_err(dev, \"scsi host alloc failed\\n\");\n\t\treturn NULL;\n\t}\n\thisi_hba = shost_priv(shost);\n\n\tINIT_WORK(&hisi_hba->rst_work, hisi_sas_rst_work_handler);\n\thisi_hba->hw = hw;\n\thisi_hba->dev = dev;\n\thisi_hba->platform_dev = pdev;\n\thisi_hba->shost = shost;\n\tSHOST_TO_SAS_HA(shost) = &hisi_hba->sha;\n\n\ttimer_setup(&hisi_hba->timer, NULL, 0);\n\n\tif (hisi_sas_get_fw_info(hisi_hba) < 0)\n\t\tgoto err_out;\n\n\terror = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));\n\tif (error) {\n\t\tdev_err(dev, \"No usable DMA addressing method\\n\");\n\t\tgoto err_out;\n\t}\n\n\thisi_hba->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hisi_hba->regs))\n\t\tgoto err_out;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (res) {\n\t\thisi_hba->sgpio_regs = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(hisi_hba->sgpio_regs))\n\t\t\tgoto err_out;\n\t}\n\n\tif (hisi_sas_alloc(hisi_hba)) {\n\t\thisi_sas_free(hisi_hba);\n\t\tgoto err_out;\n\t}\n\n\treturn shost;\nerr_out:\n\tscsi_host_put(shost);\n\tdev_err(dev, \"shost alloc failed\\n\");\n\treturn NULL;\n}\n\nstatic int hisi_sas_interrupt_preinit(struct hisi_hba *hisi_hba)\n{\n\tif (hisi_hba->hw->interrupt_preinit)\n\t\treturn hisi_hba->hw->interrupt_preinit(hisi_hba);\n\treturn 0;\n}\n\nint hisi_sas_probe(struct platform_device *pdev,\n\t\t   const struct hisi_sas_hw *hw)\n{\n\tstruct Scsi_Host *shost;\n\tstruct hisi_hba *hisi_hba;\n\tstruct device *dev = &pdev->dev;\n\tstruct asd_sas_phy **arr_phy;\n\tstruct asd_sas_port **arr_port;\n\tstruct sas_ha_struct *sha;\n\tint rc, phy_nr, port_nr, i;\n\n\tshost = hisi_sas_shost_alloc(pdev, hw);\n\tif (!shost)\n\t\treturn -ENOMEM;\n\n\tsha = SHOST_TO_SAS_HA(shost);\n\thisi_hba = shost_priv(shost);\n\tplatform_set_drvdata(pdev, sha);\n\n\tphy_nr = port_nr = hisi_hba->n_phy;\n\n\tarr_phy = devm_kcalloc(dev, phy_nr, sizeof(void *), GFP_KERNEL);\n\tarr_port = devm_kcalloc(dev, port_nr, sizeof(void *), GFP_KERNEL);\n\tif (!arr_phy || !arr_port) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_ha;\n\t}\n\n\tsha->sas_phy = arr_phy;\n\tsha->sas_port = arr_port;\n\tsha->lldd_ha = hisi_hba;\n\n\tshost->transportt = hisi_sas_stt;\n\tshost->max_id = HISI_SAS_MAX_DEVICES;\n\tshost->max_lun = ~0;\n\tshost->max_channel = 1;\n\tshost->max_cmd_len = 16;\n\tif (hisi_hba->hw->slot_index_alloc) {\n\t\tshost->can_queue = HISI_SAS_MAX_COMMANDS;\n\t\tshost->cmd_per_lun = HISI_SAS_MAX_COMMANDS;\n\t} else {\n\t\tshost->can_queue = HISI_SAS_UNRESERVED_IPTT;\n\t\tshost->cmd_per_lun = HISI_SAS_UNRESERVED_IPTT;\n\t}\n\n\tsha->sas_ha_name = DRV_NAME;\n\tsha->dev = hisi_hba->dev;\n\tsha->sas_addr = &hisi_hba->sas_addr[0];\n\tsha->num_phys = hisi_hba->n_phy;\n\tsha->shost = hisi_hba->shost;\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\tsha->sas_phy[i] = &hisi_hba->phy[i].sas_phy;\n\t\tsha->sas_port[i] = &hisi_hba->port[i].sas_port;\n\t}\n\n\trc = hisi_sas_interrupt_preinit(hisi_hba);\n\tif (rc)\n\t\tgoto err_out_ha;\n\n\trc = scsi_add_host(shost, &pdev->dev);\n\tif (rc)\n\t\tgoto err_out_ha;\n\n\trc = sas_register_ha(sha);\n\tif (rc)\n\t\tgoto err_out_register_ha;\n\n\trc = hisi_hba->hw->hw_init(hisi_hba);\n\tif (rc)\n\t\tgoto err_out_hw_init;\n\n\tscsi_scan_host(shost);\n\n\treturn 0;\n\nerr_out_hw_init:\n\tsas_unregister_ha(sha);\nerr_out_register_ha:\n\tscsi_remove_host(shost);\nerr_out_ha:\n\thisi_sas_free(hisi_hba);\n\tscsi_host_put(shost);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(hisi_sas_probe);\n\nvoid hisi_sas_remove(struct platform_device *pdev)\n{\n\tstruct sas_ha_struct *sha = platform_get_drvdata(pdev);\n\tstruct hisi_hba *hisi_hba = sha->lldd_ha;\n\tstruct Scsi_Host *shost = sha->shost;\n\n\tdel_timer_sync(&hisi_hba->timer);\n\n\tsas_unregister_ha(sha);\n\tsas_remove_host(shost);\n\n\thisi_sas_free(hisi_hba);\n\tscsi_host_put(shost);\n}\nEXPORT_SYMBOL_GPL(hisi_sas_remove);\n\n#if IS_ENABLED(CONFIG_SCSI_HISI_SAS_DEBUGFS_DEFAULT_ENABLE)\n#define DEBUGFS_ENABLE_DEFAULT  \"enabled\"\nbool hisi_sas_debugfs_enable = true;\nu32 hisi_sas_debugfs_dump_count = 50;\n#else\n#define DEBUGFS_ENABLE_DEFAULT \"disabled\"\nbool hisi_sas_debugfs_enable;\nu32 hisi_sas_debugfs_dump_count = 1;\n#endif\n\nEXPORT_SYMBOL_GPL(hisi_sas_debugfs_enable);\nmodule_param_named(debugfs_enable, hisi_sas_debugfs_enable, bool, 0444);\nMODULE_PARM_DESC(hisi_sas_debugfs_enable,\n\t\t \"Enable driver debugfs (default \"DEBUGFS_ENABLE_DEFAULT\")\");\n\nEXPORT_SYMBOL_GPL(hisi_sas_debugfs_dump_count);\nmodule_param_named(debugfs_dump_count, hisi_sas_debugfs_dump_count, uint, 0444);\nMODULE_PARM_DESC(hisi_sas_debugfs_dump_count, \"Number of debugfs dumps to allow\");\n\nstruct dentry *hisi_sas_debugfs_dir;\nEXPORT_SYMBOL_GPL(hisi_sas_debugfs_dir);\n\nstatic __init int hisi_sas_init(void)\n{\n\thisi_sas_stt = sas_domain_attach_transport(&hisi_sas_transport_ops);\n\tif (!hisi_sas_stt)\n\t\treturn -ENOMEM;\n\n\tif (hisi_sas_debugfs_enable) {\n\t\thisi_sas_debugfs_dir = debugfs_create_dir(\"hisi_sas\", NULL);\n\t\tif (hisi_sas_debugfs_dump_count > HISI_SAS_MAX_DEBUGFS_DUMP) {\n\t\t\tpr_info(\"hisi_sas: Limiting debugfs dump count\\n\");\n\t\t\thisi_sas_debugfs_dump_count = HISI_SAS_MAX_DEBUGFS_DUMP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic __exit void hisi_sas_exit(void)\n{\n\tsas_release_transport(hisi_sas_stt);\n\n\tdebugfs_remove(hisi_sas_debugfs_dir);\n}\n\nmodule_init(hisi_sas_init);\nmodule_exit(hisi_sas_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"John Garry <john.garry@huawei.com>\");\nMODULE_DESCRIPTION(\"HISILICON SAS controller driver\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}