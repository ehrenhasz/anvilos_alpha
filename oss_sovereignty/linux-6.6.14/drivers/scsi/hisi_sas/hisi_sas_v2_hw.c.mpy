{
  "module_name": "hisi_sas_v2_hw.c",
  "hash_id": "17ab80531729aadda01d1b828354213852d4aaf2aa3775f857ae0983e8de7b16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/hisi_sas/hisi_sas_v2_hw.c",
  "human_readable_source": "\n \n\n#include \"hisi_sas.h\"\n#define DRV_NAME \"hisi_sas_v2_hw\"\n\n \n#define DLVRY_QUEUE_ENABLE\t\t0x0\n#define IOST_BASE_ADDR_LO\t\t0x8\n#define IOST_BASE_ADDR_HI\t\t0xc\n#define ITCT_BASE_ADDR_LO\t\t0x10\n#define ITCT_BASE_ADDR_HI\t\t0x14\n#define IO_BROKEN_MSG_ADDR_LO\t\t0x18\n#define IO_BROKEN_MSG_ADDR_HI\t\t0x1c\n#define PHY_CONTEXT\t\t\t0x20\n#define PHY_STATE\t\t\t0x24\n#define PHY_PORT_NUM_MA\t\t\t0x28\n#define PORT_STATE\t\t\t0x2c\n#define PORT_STATE_PHY8_PORT_NUM_OFF\t16\n#define PORT_STATE_PHY8_PORT_NUM_MSK\t(0xf << PORT_STATE_PHY8_PORT_NUM_OFF)\n#define PORT_STATE_PHY8_CONN_RATE_OFF\t20\n#define PORT_STATE_PHY8_CONN_RATE_MSK\t(0xf << PORT_STATE_PHY8_CONN_RATE_OFF)\n#define PHY_CONN_RATE\t\t\t0x30\n#define HGC_TRANS_TASK_CNT_LIMIT\t0x38\n#define AXI_AHB_CLK_CFG\t\t\t0x3c\n#define ITCT_CLR\t\t\t0x44\n#define ITCT_CLR_EN_OFF\t\t\t16\n#define ITCT_CLR_EN_MSK\t\t\t(0x1 << ITCT_CLR_EN_OFF)\n#define ITCT_DEV_OFF\t\t\t0\n#define ITCT_DEV_MSK\t\t\t(0x7ff << ITCT_DEV_OFF)\n#define AXI_USER1\t\t\t0x48\n#define AXI_USER2\t\t\t0x4c\n#define IO_SATA_BROKEN_MSG_ADDR_LO\t0x58\n#define IO_SATA_BROKEN_MSG_ADDR_HI\t0x5c\n#define SATA_INITI_D2H_STORE_ADDR_LO\t0x60\n#define SATA_INITI_D2H_STORE_ADDR_HI\t0x64\n#define HGC_SAS_TX_OPEN_FAIL_RETRY_CTRL\t0x84\n#define HGC_SAS_TXFAIL_RETRY_CTRL\t0x88\n#define HGC_GET_ITV_TIME\t\t0x90\n#define DEVICE_MSG_WORK_MODE\t\t0x94\n#define OPENA_WT_CONTI_TIME\t\t0x9c\n#define I_T_NEXUS_LOSS_TIME\t\t0xa0\n#define MAX_CON_TIME_LIMIT_TIME\t\t0xa4\n#define BUS_INACTIVE_LIMIT_TIME\t\t0xa8\n#define REJECT_TO_OPEN_LIMIT_TIME\t0xac\n#define CFG_AGING_TIME\t\t\t0xbc\n#define HGC_DFX_CFG2\t\t\t0xc0\n#define HGC_IOMB_PROC1_STATUS\t0x104\n#define CFG_1US_TIMER_TRSH\t\t0xcc\n#define HGC_LM_DFX_STATUS2\t\t0x128\n#define HGC_LM_DFX_STATUS2_IOSTLIST_OFF\t\t0\n#define HGC_LM_DFX_STATUS2_IOSTLIST_MSK\t(0xfff << \\\n\t\t\t\t\t HGC_LM_DFX_STATUS2_IOSTLIST_OFF)\n#define HGC_LM_DFX_STATUS2_ITCTLIST_OFF\t\t12\n#define HGC_LM_DFX_STATUS2_ITCTLIST_MSK\t(0x7ff << \\\n\t\t\t\t\t HGC_LM_DFX_STATUS2_ITCTLIST_OFF)\n#define HGC_CQE_ECC_ADDR\t\t0x13c\n#define HGC_CQE_ECC_1B_ADDR_OFF\t0\n#define HGC_CQE_ECC_1B_ADDR_MSK\t(0x3f << HGC_CQE_ECC_1B_ADDR_OFF)\n#define HGC_CQE_ECC_MB_ADDR_OFF\t8\n#define HGC_CQE_ECC_MB_ADDR_MSK (0x3f << HGC_CQE_ECC_MB_ADDR_OFF)\n#define HGC_IOST_ECC_ADDR\t\t0x140\n#define HGC_IOST_ECC_1B_ADDR_OFF\t0\n#define HGC_IOST_ECC_1B_ADDR_MSK\t(0x3ff << HGC_IOST_ECC_1B_ADDR_OFF)\n#define HGC_IOST_ECC_MB_ADDR_OFF\t16\n#define HGC_IOST_ECC_MB_ADDR_MSK\t(0x3ff << HGC_IOST_ECC_MB_ADDR_OFF)\n#define HGC_DQE_ECC_ADDR\t\t0x144\n#define HGC_DQE_ECC_1B_ADDR_OFF\t0\n#define HGC_DQE_ECC_1B_ADDR_MSK\t(0xfff << HGC_DQE_ECC_1B_ADDR_OFF)\n#define HGC_DQE_ECC_MB_ADDR_OFF\t16\n#define HGC_DQE_ECC_MB_ADDR_MSK (0xfff << HGC_DQE_ECC_MB_ADDR_OFF)\n#define HGC_INVLD_DQE_INFO\t\t0x148\n#define HGC_INVLD_DQE_INFO_FB_CH0_OFF\t9\n#define HGC_INVLD_DQE_INFO_FB_CH0_MSK\t(0x1 << HGC_INVLD_DQE_INFO_FB_CH0_OFF)\n#define HGC_INVLD_DQE_INFO_FB_CH3_OFF\t18\n#define HGC_ITCT_ECC_ADDR\t\t0x150\n#define HGC_ITCT_ECC_1B_ADDR_OFF\t\t0\n#define HGC_ITCT_ECC_1B_ADDR_MSK\t\t(0x3ff << \\\n\t\t\t\t\t\t HGC_ITCT_ECC_1B_ADDR_OFF)\n#define HGC_ITCT_ECC_MB_ADDR_OFF\t\t16\n#define HGC_ITCT_ECC_MB_ADDR_MSK\t\t(0x3ff << \\\n\t\t\t\t\t\t HGC_ITCT_ECC_MB_ADDR_OFF)\n#define HGC_AXI_FIFO_ERR_INFO\t0x154\n#define AXI_ERR_INFO_OFF\t\t0\n#define AXI_ERR_INFO_MSK\t\t(0xff << AXI_ERR_INFO_OFF)\n#define FIFO_ERR_INFO_OFF\t\t8\n#define FIFO_ERR_INFO_MSK\t\t(0xff << FIFO_ERR_INFO_OFF)\n#define INT_COAL_EN\t\t\t0x19c\n#define OQ_INT_COAL_TIME\t\t0x1a0\n#define OQ_INT_COAL_CNT\t\t\t0x1a4\n#define ENT_INT_COAL_TIME\t\t0x1a8\n#define ENT_INT_COAL_CNT\t\t0x1ac\n#define OQ_INT_SRC\t\t\t0x1b0\n#define OQ_INT_SRC_MSK\t\t\t0x1b4\n#define ENT_INT_SRC1\t\t\t0x1b8\n#define ENT_INT_SRC1_D2H_FIS_CH0_OFF\t0\n#define ENT_INT_SRC1_D2H_FIS_CH0_MSK\t(0x1 << ENT_INT_SRC1_D2H_FIS_CH0_OFF)\n#define ENT_INT_SRC1_D2H_FIS_CH1_OFF\t8\n#define ENT_INT_SRC1_D2H_FIS_CH1_MSK\t(0x1 << ENT_INT_SRC1_D2H_FIS_CH1_OFF)\n#define ENT_INT_SRC2\t\t\t0x1bc\n#define ENT_INT_SRC3\t\t\t0x1c0\n#define ENT_INT_SRC3_WP_DEPTH_OFF\t\t8\n#define ENT_INT_SRC3_IPTT_SLOT_NOMATCH_OFF\t9\n#define ENT_INT_SRC3_RP_DEPTH_OFF\t\t10\n#define ENT_INT_SRC3_AXI_OFF\t\t\t11\n#define ENT_INT_SRC3_FIFO_OFF\t\t\t12\n#define ENT_INT_SRC3_LM_OFF\t\t\t\t14\n#define ENT_INT_SRC3_ITC_INT_OFF\t15\n#define ENT_INT_SRC3_ITC_INT_MSK\t(0x1 << ENT_INT_SRC3_ITC_INT_OFF)\n#define ENT_INT_SRC3_ABT_OFF\t\t16\n#define ENT_INT_SRC_MSK1\t\t0x1c4\n#define ENT_INT_SRC_MSK2\t\t0x1c8\n#define ENT_INT_SRC_MSK3\t\t0x1cc\n#define ENT_INT_SRC_MSK3_ENT95_MSK_OFF\t31\n#define ENT_INT_SRC_MSK3_ENT95_MSK_MSK\t(0x1 << ENT_INT_SRC_MSK3_ENT95_MSK_OFF)\n#define SAS_ECC_INTR\t\t\t0x1e8\n#define SAS_ECC_INTR_DQE_ECC_1B_OFF\t\t0\n#define SAS_ECC_INTR_DQE_ECC_MB_OFF\t\t1\n#define SAS_ECC_INTR_IOST_ECC_1B_OFF\t2\n#define SAS_ECC_INTR_IOST_ECC_MB_OFF\t3\n#define SAS_ECC_INTR_ITCT_ECC_MB_OFF\t4\n#define SAS_ECC_INTR_ITCT_ECC_1B_OFF\t5\n#define SAS_ECC_INTR_IOSTLIST_ECC_MB_OFF\t6\n#define SAS_ECC_INTR_IOSTLIST_ECC_1B_OFF\t7\n#define SAS_ECC_INTR_ITCTLIST_ECC_1B_OFF\t8\n#define SAS_ECC_INTR_ITCTLIST_ECC_MB_OFF\t9\n#define SAS_ECC_INTR_CQE_ECC_1B_OFF\t\t10\n#define SAS_ECC_INTR_CQE_ECC_MB_OFF\t\t11\n#define SAS_ECC_INTR_NCQ_MEM0_ECC_MB_OFF\t12\n#define SAS_ECC_INTR_NCQ_MEM0_ECC_1B_OFF\t13\n#define SAS_ECC_INTR_NCQ_MEM1_ECC_MB_OFF\t14\n#define SAS_ECC_INTR_NCQ_MEM1_ECC_1B_OFF\t15\n#define SAS_ECC_INTR_NCQ_MEM2_ECC_MB_OFF\t16\n#define SAS_ECC_INTR_NCQ_MEM2_ECC_1B_OFF\t17\n#define SAS_ECC_INTR_NCQ_MEM3_ECC_MB_OFF\t18\n#define SAS_ECC_INTR_NCQ_MEM3_ECC_1B_OFF\t19\n#define SAS_ECC_INTR_MSK\t\t0x1ec\n#define HGC_ERR_STAT_EN\t\t\t0x238\n#define CQE_SEND_CNT\t\t\t0x248\n#define DLVRY_Q_0_BASE_ADDR_LO\t\t0x260\n#define DLVRY_Q_0_BASE_ADDR_HI\t\t0x264\n#define DLVRY_Q_0_DEPTH\t\t\t0x268\n#define DLVRY_Q_0_WR_PTR\t\t0x26c\n#define DLVRY_Q_0_RD_PTR\t\t0x270\n#define HYPER_STREAM_ID_EN_CFG\t\t0xc80\n#define OQ0_INT_SRC_MSK\t\t\t0xc90\n#define COMPL_Q_0_BASE_ADDR_LO\t\t0x4e0\n#define COMPL_Q_0_BASE_ADDR_HI\t\t0x4e4\n#define COMPL_Q_0_DEPTH\t\t\t0x4e8\n#define COMPL_Q_0_WR_PTR\t\t0x4ec\n#define COMPL_Q_0_RD_PTR\t\t0x4f0\n#define HGC_RXM_DFX_STATUS14\t0xae8\n#define HGC_RXM_DFX_STATUS14_MEM0_OFF\t\t0\n#define HGC_RXM_DFX_STATUS14_MEM0_MSK\t\t(0x1ff << \\\n\t\t\t\t\t\t HGC_RXM_DFX_STATUS14_MEM0_OFF)\n#define HGC_RXM_DFX_STATUS14_MEM1_OFF\t\t9\n#define HGC_RXM_DFX_STATUS14_MEM1_MSK\t\t(0x1ff << \\\n\t\t\t\t\t\t HGC_RXM_DFX_STATUS14_MEM1_OFF)\n#define HGC_RXM_DFX_STATUS14_MEM2_OFF\t\t18\n#define HGC_RXM_DFX_STATUS14_MEM2_MSK\t\t(0x1ff << \\\n\t\t\t\t\t\t HGC_RXM_DFX_STATUS14_MEM2_OFF)\n#define HGC_RXM_DFX_STATUS15\t0xaec\n#define HGC_RXM_DFX_STATUS15_MEM3_OFF\t\t0\n#define HGC_RXM_DFX_STATUS15_MEM3_MSK\t\t(0x1ff << \\\n\t\t\t\t\t\t HGC_RXM_DFX_STATUS15_MEM3_OFF)\n \n#define PORT_BASE\t\t\t(0x2000)\n\n#define PHY_CFG\t\t\t\t(PORT_BASE + 0x0)\n#define HARD_PHY_LINKRATE\t\t(PORT_BASE + 0x4)\n#define PHY_CFG_ENA_OFF\t\t\t0\n#define PHY_CFG_ENA_MSK\t\t\t(0x1 << PHY_CFG_ENA_OFF)\n#define PHY_CFG_DC_OPT_OFF\t\t2\n#define PHY_CFG_DC_OPT_MSK\t\t(0x1 << PHY_CFG_DC_OPT_OFF)\n#define PROG_PHY_LINK_RATE\t\t(PORT_BASE + 0x8)\n#define PROG_PHY_LINK_RATE_MAX_OFF\t0\n#define PROG_PHY_LINK_RATE_MAX_MSK\t(0xff << PROG_PHY_LINK_RATE_MAX_OFF)\n#define PHY_CTRL\t\t\t(PORT_BASE + 0x14)\n#define PHY_CTRL_RESET_OFF\t\t0\n#define PHY_CTRL_RESET_MSK\t\t(0x1 << PHY_CTRL_RESET_OFF)\n#define SAS_PHY_CTRL\t\t\t(PORT_BASE + 0x20)\n#define SL_CFG\t\t\t\t(PORT_BASE + 0x84)\n#define PHY_PCN\t\t\t\t(PORT_BASE + 0x44)\n#define SL_TOUT_CFG\t\t\t(PORT_BASE + 0x8c)\n#define SL_CONTROL\t\t\t(PORT_BASE + 0x94)\n#define SL_CONTROL_NOTIFY_EN_OFF\t0\n#define SL_CONTROL_NOTIFY_EN_MSK\t(0x1 << SL_CONTROL_NOTIFY_EN_OFF)\n#define SL_CONTROL_CTA_OFF\t\t17\n#define SL_CONTROL_CTA_MSK\t\t(0x1 << SL_CONTROL_CTA_OFF)\n#define RX_PRIMS_STATUS\t\t\t(PORT_BASE + 0x98)\n#define RX_BCAST_CHG_OFF\t\t1\n#define RX_BCAST_CHG_MSK\t\t(0x1 << RX_BCAST_CHG_OFF)\n#define TX_ID_DWORD0\t\t\t(PORT_BASE + 0x9c)\n#define TX_ID_DWORD1\t\t\t(PORT_BASE + 0xa0)\n#define TX_ID_DWORD2\t\t\t(PORT_BASE + 0xa4)\n#define TX_ID_DWORD3\t\t\t(PORT_BASE + 0xa8)\n#define TX_ID_DWORD4\t\t\t(PORT_BASE + 0xaC)\n#define TX_ID_DWORD5\t\t\t(PORT_BASE + 0xb0)\n#define TX_ID_DWORD6\t\t\t(PORT_BASE + 0xb4)\n#define TXID_AUTO\t\t\t(PORT_BASE + 0xb8)\n#define TXID_AUTO_CT3_OFF\t\t1\n#define TXID_AUTO_CT3_MSK\t\t(0x1 << TXID_AUTO_CT3_OFF)\n#define TXID_AUTO_CTB_OFF\t\t11\n#define TXID_AUTO_CTB_MSK\t\t(0x1 << TXID_AUTO_CTB_OFF)\n#define TX_HARDRST_OFF\t\t\t2\n#define TX_HARDRST_MSK\t\t\t(0x1 << TX_HARDRST_OFF)\n#define RX_IDAF_DWORD0\t\t\t(PORT_BASE + 0xc4)\n#define RX_IDAF_DWORD1\t\t\t(PORT_BASE + 0xc8)\n#define RX_IDAF_DWORD2\t\t\t(PORT_BASE + 0xcc)\n#define RX_IDAF_DWORD3\t\t\t(PORT_BASE + 0xd0)\n#define RX_IDAF_DWORD4\t\t\t(PORT_BASE + 0xd4)\n#define RX_IDAF_DWORD5\t\t\t(PORT_BASE + 0xd8)\n#define RX_IDAF_DWORD6\t\t\t(PORT_BASE + 0xdc)\n#define RXOP_CHECK_CFG_H\t\t(PORT_BASE + 0xfc)\n#define CON_CONTROL\t\t\t(PORT_BASE + 0x118)\n#define CON_CONTROL_CFG_OPEN_ACC_STP_OFF\t0\n#define CON_CONTROL_CFG_OPEN_ACC_STP_MSK\t\\\n\t\t(0x01 << CON_CONTROL_CFG_OPEN_ACC_STP_OFF)\n#define DONE_RECEIVED_TIME\t\t(PORT_BASE + 0x11c)\n#define CHL_INT0\t\t\t(PORT_BASE + 0x1b4)\n#define CHL_INT0_HOTPLUG_TOUT_OFF\t0\n#define CHL_INT0_HOTPLUG_TOUT_MSK\t(0x1 << CHL_INT0_HOTPLUG_TOUT_OFF)\n#define CHL_INT0_SL_RX_BCST_ACK_OFF\t1\n#define CHL_INT0_SL_RX_BCST_ACK_MSK\t(0x1 << CHL_INT0_SL_RX_BCST_ACK_OFF)\n#define CHL_INT0_SL_PHY_ENABLE_OFF\t2\n#define CHL_INT0_SL_PHY_ENABLE_MSK\t(0x1 << CHL_INT0_SL_PHY_ENABLE_OFF)\n#define CHL_INT0_NOT_RDY_OFF\t\t4\n#define CHL_INT0_NOT_RDY_MSK\t\t(0x1 << CHL_INT0_NOT_RDY_OFF)\n#define CHL_INT0_PHY_RDY_OFF\t\t5\n#define CHL_INT0_PHY_RDY_MSK\t\t(0x1 << CHL_INT0_PHY_RDY_OFF)\n#define CHL_INT1\t\t\t(PORT_BASE + 0x1b8)\n#define CHL_INT1_DMAC_TX_ECC_ERR_OFF\t15\n#define CHL_INT1_DMAC_TX_ECC_ERR_MSK\t(0x1 << CHL_INT1_DMAC_TX_ECC_ERR_OFF)\n#define CHL_INT1_DMAC_RX_ECC_ERR_OFF\t17\n#define CHL_INT1_DMAC_RX_ECC_ERR_MSK\t(0x1 << CHL_INT1_DMAC_RX_ECC_ERR_OFF)\n#define CHL_INT1_DMAC_TX_AXI_WR_ERR_OFF\t19\n#define CHL_INT1_DMAC_TX_AXI_RD_ERR_OFF\t20\n#define CHL_INT1_DMAC_RX_AXI_WR_ERR_OFF\t21\n#define CHL_INT1_DMAC_RX_AXI_RD_ERR_OFF\t22\n#define CHL_INT2\t\t\t(PORT_BASE + 0x1bc)\n#define CHL_INT2_SL_IDAF_TOUT_CONF_OFF\t0\n#define CHL_INT0_MSK\t\t\t(PORT_BASE + 0x1c0)\n#define CHL_INT1_MSK\t\t\t(PORT_BASE + 0x1c4)\n#define CHL_INT2_MSK\t\t\t(PORT_BASE + 0x1c8)\n#define CHL_INT_COAL_EN\t\t\t(PORT_BASE + 0x1d0)\n#define DMA_TX_DFX0\t\t\t\t(PORT_BASE + 0x200)\n#define DMA_TX_DFX1\t\t\t\t(PORT_BASE + 0x204)\n#define DMA_TX_DFX1_IPTT_OFF\t\t0\n#define DMA_TX_DFX1_IPTT_MSK\t\t(0xffff << DMA_TX_DFX1_IPTT_OFF)\n#define DMA_TX_FIFO_DFX0\t\t(PORT_BASE + 0x240)\n#define PORT_DFX0\t\t\t\t(PORT_BASE + 0x258)\n#define LINK_DFX2\t\t\t\t\t(PORT_BASE + 0X264)\n#define LINK_DFX2_RCVR_HOLD_STS_OFF\t9\n#define LINK_DFX2_RCVR_HOLD_STS_MSK\t(0x1 << LINK_DFX2_RCVR_HOLD_STS_OFF)\n#define LINK_DFX2_SEND_HOLD_STS_OFF\t10\n#define LINK_DFX2_SEND_HOLD_STS_MSK\t(0x1 << LINK_DFX2_SEND_HOLD_STS_OFF)\n#define SAS_ERR_CNT4_REG\t\t(PORT_BASE + 0x290)\n#define SAS_ERR_CNT6_REG\t\t(PORT_BASE + 0x298)\n#define PHY_CTRL_RDY_MSK\t\t(PORT_BASE + 0x2b0)\n#define PHYCTRL_NOT_RDY_MSK\t\t(PORT_BASE + 0x2b4)\n#define PHYCTRL_DWS_RESET_MSK\t\t(PORT_BASE + 0x2b8)\n#define PHYCTRL_PHY_ENA_MSK\t\t(PORT_BASE + 0x2bc)\n#define SL_RX_BCAST_CHK_MSK\t\t(PORT_BASE + 0x2c0)\n#define PHYCTRL_OOB_RESTART_MSK\t\t(PORT_BASE + 0x2c4)\n#define DMA_TX_STATUS\t\t\t(PORT_BASE + 0x2d0)\n#define DMA_TX_STATUS_BUSY_OFF\t\t0\n#define DMA_TX_STATUS_BUSY_MSK\t\t(0x1 << DMA_TX_STATUS_BUSY_OFF)\n#define DMA_RX_STATUS\t\t\t(PORT_BASE + 0x2e8)\n#define DMA_RX_STATUS_BUSY_OFF\t\t0\n#define DMA_RX_STATUS_BUSY_MSK\t\t(0x1 << DMA_RX_STATUS_BUSY_OFF)\n\n#define AXI_CFG\t\t\t\t(0x5100)\n#define AM_CFG_MAX_TRANS\t\t(0x5010)\n#define AM_CFG_SINGLE_PORT_MAX_TRANS\t(0x5014)\n\n#define AXI_MASTER_CFG_BASE\t\t(0x5000)\n#define AM_CTRL_GLOBAL\t\t\t(0x0)\n#define AM_CURR_TRANS_RETURN\t(0x150)\n\n \n \n \n#define CMD_HDR_ABORT_FLAG_OFF\t\t0\n#define CMD_HDR_ABORT_FLAG_MSK\t\t(0x3 << CMD_HDR_ABORT_FLAG_OFF)\n#define CMD_HDR_ABORT_DEVICE_TYPE_OFF\t2\n#define CMD_HDR_ABORT_DEVICE_TYPE_MSK\t(0x1 << CMD_HDR_ABORT_DEVICE_TYPE_OFF)\n#define CMD_HDR_RESP_REPORT_OFF\t\t5\n#define CMD_HDR_RESP_REPORT_MSK\t\t(0x1 << CMD_HDR_RESP_REPORT_OFF)\n#define CMD_HDR_TLR_CTRL_OFF\t\t6\n#define CMD_HDR_TLR_CTRL_MSK\t\t(0x3 << CMD_HDR_TLR_CTRL_OFF)\n#define CMD_HDR_PHY_ID_OFF\t\t8\n#define CMD_HDR_PHY_ID_MSK\t\t(0x1ff << CMD_HDR_PHY_ID_OFF)\n#define CMD_HDR_FORCE_PHY_OFF\t\t17\n#define CMD_HDR_FORCE_PHY_MSK\t\t(0x1 << CMD_HDR_FORCE_PHY_OFF)\n#define CMD_HDR_PORT_OFF\t\t18\n#define CMD_HDR_PORT_MSK\t\t(0xf << CMD_HDR_PORT_OFF)\n#define CMD_HDR_PRIORITY_OFF\t\t27\n#define CMD_HDR_PRIORITY_MSK\t\t(0x1 << CMD_HDR_PRIORITY_OFF)\n#define CMD_HDR_CMD_OFF\t\t\t29\n#define CMD_HDR_CMD_MSK\t\t\t(0x7 << CMD_HDR_CMD_OFF)\n \n#define CMD_HDR_DIR_OFF\t\t\t5\n#define CMD_HDR_DIR_MSK\t\t\t(0x3 << CMD_HDR_DIR_OFF)\n#define CMD_HDR_RESET_OFF\t\t7\n#define CMD_HDR_RESET_MSK\t\t(0x1 << CMD_HDR_RESET_OFF)\n#define CMD_HDR_VDTL_OFF\t\t10\n#define CMD_HDR_VDTL_MSK\t\t(0x1 << CMD_HDR_VDTL_OFF)\n#define CMD_HDR_FRAME_TYPE_OFF\t\t11\n#define CMD_HDR_FRAME_TYPE_MSK\t\t(0x1f << CMD_HDR_FRAME_TYPE_OFF)\n#define CMD_HDR_DEV_ID_OFF\t\t16\n#define CMD_HDR_DEV_ID_MSK\t\t(0xffff << CMD_HDR_DEV_ID_OFF)\n \n#define CMD_HDR_CFL_OFF\t\t\t0\n#define CMD_HDR_CFL_MSK\t\t\t(0x1ff << CMD_HDR_CFL_OFF)\n#define CMD_HDR_NCQ_TAG_OFF\t\t10\n#define CMD_HDR_NCQ_TAG_MSK\t\t(0x1f << CMD_HDR_NCQ_TAG_OFF)\n#define CMD_HDR_MRFL_OFF\t\t15\n#define CMD_HDR_MRFL_MSK\t\t(0x1ff << CMD_HDR_MRFL_OFF)\n#define CMD_HDR_SG_MOD_OFF\t\t24\n#define CMD_HDR_SG_MOD_MSK\t\t(0x3 << CMD_HDR_SG_MOD_OFF)\n#define CMD_HDR_FIRST_BURST_OFF\t\t26\n#define CMD_HDR_FIRST_BURST_MSK\t\t(0x1 << CMD_HDR_SG_MOD_OFF)\n \n#define CMD_HDR_IPTT_OFF\t\t0\n#define CMD_HDR_IPTT_MSK\t\t(0xffff << CMD_HDR_IPTT_OFF)\n \n#define CMD_HDR_DIF_SGL_LEN_OFF\t\t0\n#define CMD_HDR_DIF_SGL_LEN_MSK\t\t(0xffff << CMD_HDR_DIF_SGL_LEN_OFF)\n#define CMD_HDR_DATA_SGL_LEN_OFF\t16\n#define CMD_HDR_DATA_SGL_LEN_MSK\t(0xffff << CMD_HDR_DATA_SGL_LEN_OFF)\n#define CMD_HDR_ABORT_IPTT_OFF\t\t16\n#define CMD_HDR_ABORT_IPTT_MSK\t\t(0xffff << CMD_HDR_ABORT_IPTT_OFF)\n\n \n \n#define CMPLT_HDR_ERR_PHASE_OFF\t2\n#define CMPLT_HDR_ERR_PHASE_MSK\t(0xff << CMPLT_HDR_ERR_PHASE_OFF)\n#define CMPLT_HDR_RSPNS_XFRD_OFF\t10\n#define CMPLT_HDR_RSPNS_XFRD_MSK\t(0x1 << CMPLT_HDR_RSPNS_XFRD_OFF)\n#define CMPLT_HDR_ERX_OFF\t\t12\n#define CMPLT_HDR_ERX_MSK\t\t(0x1 << CMPLT_HDR_ERX_OFF)\n#define CMPLT_HDR_ABORT_STAT_OFF\t13\n#define CMPLT_HDR_ABORT_STAT_MSK\t(0x7 << CMPLT_HDR_ABORT_STAT_OFF)\n \n#define STAT_IO_NOT_VALID\t\t0x1\n#define STAT_IO_NO_DEVICE\t\t0x2\n#define STAT_IO_COMPLETE\t\t0x3\n#define STAT_IO_ABORTED\t\t\t0x4\n \n#define CMPLT_HDR_IPTT_OFF\t\t0\n#define CMPLT_HDR_IPTT_MSK\t\t(0xffff << CMPLT_HDR_IPTT_OFF)\n#define CMPLT_HDR_DEV_ID_OFF\t\t16\n#define CMPLT_HDR_DEV_ID_MSK\t\t(0xffff << CMPLT_HDR_DEV_ID_OFF)\n\n \n \n#define ITCT_HDR_DEV_TYPE_OFF\t\t0\n#define ITCT_HDR_DEV_TYPE_MSK\t\t(0x3 << ITCT_HDR_DEV_TYPE_OFF)\n#define ITCT_HDR_VALID_OFF\t\t2\n#define ITCT_HDR_VALID_MSK\t\t(0x1 << ITCT_HDR_VALID_OFF)\n#define ITCT_HDR_MCR_OFF\t\t5\n#define ITCT_HDR_MCR_MSK\t\t(0xf << ITCT_HDR_MCR_OFF)\n#define ITCT_HDR_VLN_OFF\t\t9\n#define ITCT_HDR_VLN_MSK\t\t(0xf << ITCT_HDR_VLN_OFF)\n#define ITCT_HDR_SMP_TIMEOUT_OFF\t16\n#define ITCT_HDR_SMP_TIMEOUT_8US\t1\n#define ITCT_HDR_SMP_TIMEOUT\t\t(ITCT_HDR_SMP_TIMEOUT_8US * \\\n\t\t\t\t\t 250)  \n#define ITCT_HDR_AWT_CONTINUE_OFF\t25\n#define ITCT_HDR_PORT_ID_OFF\t\t28\n#define ITCT_HDR_PORT_ID_MSK\t\t(0xf << ITCT_HDR_PORT_ID_OFF)\n \n#define ITCT_HDR_INLT_OFF\t\t0\n#define ITCT_HDR_INLT_MSK\t\t(0xffffULL << ITCT_HDR_INLT_OFF)\n#define ITCT_HDR_BITLT_OFF\t\t16\n#define ITCT_HDR_BITLT_MSK\t\t(0xffffULL << ITCT_HDR_BITLT_OFF)\n#define ITCT_HDR_MCTLT_OFF\t\t32\n#define ITCT_HDR_MCTLT_MSK\t\t(0xffffULL << ITCT_HDR_MCTLT_OFF)\n#define ITCT_HDR_RTOLT_OFF\t\t48\n#define ITCT_HDR_RTOLT_MSK\t\t(0xffffULL << ITCT_HDR_RTOLT_OFF)\n\n#define HISI_SAS_FATAL_INT_NR\t2\n\nstruct hisi_sas_complete_v2_hdr {\n\t__le32 dw0;\n\t__le32 dw1;\n\t__le32 act;\n\t__le32 dw3;\n};\n\nstruct hisi_sas_err_record_v2 {\n\t \n\t__le32 trans_tx_fail_type;\n\n\t \n\t__le32 trans_rx_fail_type;\n\n\t \n\t__le16 dma_tx_err_type;\n\t__le16 sipc_rx_err_type;\n\n\t \n\t__le32 dma_rx_err_type;\n};\n\nstruct signal_attenuation_s {\n\tu32 de_emphasis;\n\tu32 preshoot;\n\tu32 boost;\n};\n\nstruct sig_atten_lu_s {\n\tconst struct signal_attenuation_s *att;\n\tu32 sas_phy_ctrl;\n};\n\nstatic const struct hisi_sas_hw_error one_bit_ecc_errors[] = {\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_DQE_ECC_1B_OFF),\n\t\t.msk = HGC_DQE_ECC_1B_ADDR_MSK,\n\t\t.shift = HGC_DQE_ECC_1B_ADDR_OFF,\n\t\t.msg = \"hgc_dqe_ecc1b_intr\",\n\t\t.reg = HGC_DQE_ECC_ADDR,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_IOST_ECC_1B_OFF),\n\t\t.msk = HGC_IOST_ECC_1B_ADDR_MSK,\n\t\t.shift = HGC_IOST_ECC_1B_ADDR_OFF,\n\t\t.msg = \"hgc_iost_ecc1b_intr\",\n\t\t.reg = HGC_IOST_ECC_ADDR,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_ITCT_ECC_1B_OFF),\n\t\t.msk = HGC_ITCT_ECC_1B_ADDR_MSK,\n\t\t.shift = HGC_ITCT_ECC_1B_ADDR_OFF,\n\t\t.msg = \"hgc_itct_ecc1b_intr\",\n\t\t.reg = HGC_ITCT_ECC_ADDR,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_IOSTLIST_ECC_1B_OFF),\n\t\t.msk = HGC_LM_DFX_STATUS2_IOSTLIST_MSK,\n\t\t.shift = HGC_LM_DFX_STATUS2_IOSTLIST_OFF,\n\t\t.msg = \"hgc_iostl_ecc1b_intr\",\n\t\t.reg = HGC_LM_DFX_STATUS2,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_ITCTLIST_ECC_1B_OFF),\n\t\t.msk = HGC_LM_DFX_STATUS2_ITCTLIST_MSK,\n\t\t.shift = HGC_LM_DFX_STATUS2_ITCTLIST_OFF,\n\t\t.msg = \"hgc_itctl_ecc1b_intr\",\n\t\t.reg = HGC_LM_DFX_STATUS2,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_CQE_ECC_1B_OFF),\n\t\t.msk = HGC_CQE_ECC_1B_ADDR_MSK,\n\t\t.shift = HGC_CQE_ECC_1B_ADDR_OFF,\n\t\t.msg = \"hgc_cqe_ecc1b_intr\",\n\t\t.reg = HGC_CQE_ECC_ADDR,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_NCQ_MEM0_ECC_1B_OFF),\n\t\t.msk = HGC_RXM_DFX_STATUS14_MEM0_MSK,\n\t\t.shift = HGC_RXM_DFX_STATUS14_MEM0_OFF,\n\t\t.msg = \"rxm_mem0_ecc1b_intr\",\n\t\t.reg = HGC_RXM_DFX_STATUS14,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_NCQ_MEM1_ECC_1B_OFF),\n\t\t.msk = HGC_RXM_DFX_STATUS14_MEM1_MSK,\n\t\t.shift = HGC_RXM_DFX_STATUS14_MEM1_OFF,\n\t\t.msg = \"rxm_mem1_ecc1b_intr\",\n\t\t.reg = HGC_RXM_DFX_STATUS14,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_NCQ_MEM2_ECC_1B_OFF),\n\t\t.msk = HGC_RXM_DFX_STATUS14_MEM2_MSK,\n\t\t.shift = HGC_RXM_DFX_STATUS14_MEM2_OFF,\n\t\t.msg = \"rxm_mem2_ecc1b_intr\",\n\t\t.reg = HGC_RXM_DFX_STATUS14,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_NCQ_MEM3_ECC_1B_OFF),\n\t\t.msk = HGC_RXM_DFX_STATUS15_MEM3_MSK,\n\t\t.shift = HGC_RXM_DFX_STATUS15_MEM3_OFF,\n\t\t.msg = \"rxm_mem3_ecc1b_intr\",\n\t\t.reg = HGC_RXM_DFX_STATUS15,\n\t},\n};\n\nstatic const struct hisi_sas_hw_error multi_bit_ecc_errors[] = {\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_DQE_ECC_MB_OFF),\n\t\t.msk = HGC_DQE_ECC_MB_ADDR_MSK,\n\t\t.shift = HGC_DQE_ECC_MB_ADDR_OFF,\n\t\t.msg = \"hgc_dqe_eccbad_intr\",\n\t\t.reg = HGC_DQE_ECC_ADDR,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_IOST_ECC_MB_OFF),\n\t\t.msk = HGC_IOST_ECC_MB_ADDR_MSK,\n\t\t.shift = HGC_IOST_ECC_MB_ADDR_OFF,\n\t\t.msg = \"hgc_iost_eccbad_intr\",\n\t\t.reg = HGC_IOST_ECC_ADDR,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_ITCT_ECC_MB_OFF),\n\t\t.msk = HGC_ITCT_ECC_MB_ADDR_MSK,\n\t\t.shift = HGC_ITCT_ECC_MB_ADDR_OFF,\n\t\t.msg = \"hgc_itct_eccbad_intr\",\n\t\t.reg = HGC_ITCT_ECC_ADDR,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_IOSTLIST_ECC_MB_OFF),\n\t\t.msk = HGC_LM_DFX_STATUS2_IOSTLIST_MSK,\n\t\t.shift = HGC_LM_DFX_STATUS2_IOSTLIST_OFF,\n\t\t.msg = \"hgc_iostl_eccbad_intr\",\n\t\t.reg = HGC_LM_DFX_STATUS2,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_ITCTLIST_ECC_MB_OFF),\n\t\t.msk = HGC_LM_DFX_STATUS2_ITCTLIST_MSK,\n\t\t.shift = HGC_LM_DFX_STATUS2_ITCTLIST_OFF,\n\t\t.msg = \"hgc_itctl_eccbad_intr\",\n\t\t.reg = HGC_LM_DFX_STATUS2,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_CQE_ECC_MB_OFF),\n\t\t.msk = HGC_CQE_ECC_MB_ADDR_MSK,\n\t\t.shift = HGC_CQE_ECC_MB_ADDR_OFF,\n\t\t.msg = \"hgc_cqe_eccbad_intr\",\n\t\t.reg = HGC_CQE_ECC_ADDR,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_NCQ_MEM0_ECC_MB_OFF),\n\t\t.msk = HGC_RXM_DFX_STATUS14_MEM0_MSK,\n\t\t.shift = HGC_RXM_DFX_STATUS14_MEM0_OFF,\n\t\t.msg = \"rxm_mem0_eccbad_intr\",\n\t\t.reg = HGC_RXM_DFX_STATUS14,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_NCQ_MEM1_ECC_MB_OFF),\n\t\t.msk = HGC_RXM_DFX_STATUS14_MEM1_MSK,\n\t\t.shift = HGC_RXM_DFX_STATUS14_MEM1_OFF,\n\t\t.msg = \"rxm_mem1_eccbad_intr\",\n\t\t.reg = HGC_RXM_DFX_STATUS14,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_NCQ_MEM2_ECC_MB_OFF),\n\t\t.msk = HGC_RXM_DFX_STATUS14_MEM2_MSK,\n\t\t.shift = HGC_RXM_DFX_STATUS14_MEM2_OFF,\n\t\t.msg = \"rxm_mem2_eccbad_intr\",\n\t\t.reg = HGC_RXM_DFX_STATUS14,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_NCQ_MEM3_ECC_MB_OFF),\n\t\t.msk = HGC_RXM_DFX_STATUS15_MEM3_MSK,\n\t\t.shift = HGC_RXM_DFX_STATUS15_MEM3_OFF,\n\t\t.msg = \"rxm_mem3_eccbad_intr\",\n\t\t.reg = HGC_RXM_DFX_STATUS15,\n\t},\n};\n\nenum {\n\tHISI_SAS_PHY_PHY_UPDOWN,\n\tHISI_SAS_PHY_CHNL_INT,\n\tHISI_SAS_PHY_INT_NR\n};\n\nenum {\n\tTRANS_TX_FAIL_BASE = 0x0,  \n\tTRANS_RX_FAIL_BASE = 0x20,  \n\tDMA_TX_ERR_BASE = 0x40,  \n\tSIPC_RX_ERR_BASE = 0x50,  \n\tDMA_RX_ERR_BASE = 0x60,  \n\n\t \n\tTRANS_TX_OPEN_FAIL_WITH_IT_NEXUS_LOSS = TRANS_TX_FAIL_BASE,  \n\tTRANS_TX_ERR_PHY_NOT_ENABLE,  \n\tTRANS_TX_OPEN_CNX_ERR_WRONG_DESTINATION,  \n\tTRANS_TX_OPEN_CNX_ERR_ZONE_VIOLATION,  \n\tTRANS_TX_OPEN_CNX_ERR_BY_OTHER,  \n\tRESERVED0,  \n\tTRANS_TX_OPEN_CNX_ERR_AIP_TIMEOUT,  \n\tTRANS_TX_OPEN_CNX_ERR_STP_RESOURCES_BUSY,  \n\tTRANS_TX_OPEN_CNX_ERR_PROTOCOL_NOT_SUPPORTED,  \n\tTRANS_TX_OPEN_CNX_ERR_CONNECTION_RATE_NOT_SUPPORTED,  \n\tTRANS_TX_OPEN_CNX_ERR_BAD_DESTINATION,  \n\tTRANS_TX_OPEN_CNX_ERR_BREAK_RCVD,  \n\tTRANS_TX_OPEN_CNX_ERR_LOW_PHY_POWER,  \n\tTRANS_TX_OPEN_CNX_ERR_PATHWAY_BLOCKED,  \n\tTRANS_TX_OPEN_CNX_ERR_OPEN_TIMEOUT,  \n\tTRANS_TX_OPEN_CNX_ERR_NO_DESTINATION,  \n\tTRANS_TX_OPEN_RETRY_ERR_THRESHOLD_REACHED,  \n\tTRANS_TX_ERR_FRAME_TXED,  \n\tTRANS_TX_ERR_WITH_BREAK_TIMEOUT,  \n\tTRANS_TX_ERR_WITH_BREAK_REQUEST,  \n\tTRANS_TX_ERR_WITH_BREAK_RECEVIED,  \n\tTRANS_TX_ERR_WITH_CLOSE_TIMEOUT,  \n\tTRANS_TX_ERR_WITH_CLOSE_NORMAL,  \n\tTRANS_TX_ERR_WITH_CLOSE_PHYDISALE,  \n\tTRANS_TX_ERR_WITH_CLOSE_DWS_TIMEOUT,  \n\tTRANS_TX_ERR_WITH_CLOSE_COMINIT,  \n\tTRANS_TX_ERR_WITH_NAK_RECEVIED,  \n\tTRANS_TX_ERR_WITH_ACK_NAK_TIMEOUT,  \n\t \n\tTRANS_TX_ERR_WITH_CREDIT_TIMEOUT,  \n\t \n\tTRANS_TX_ERR_WITH_IPTT_CONFLICT,  \n\tTRANS_TX_ERR_WITH_OPEN_BY_DES_OR_OTHERS,  \n\t \n\tTRANS_TX_ERR_WITH_WAIT_RECV_TIMEOUT,  \n\n\t \n\tTRANS_RX_ERR_WITH_RXFRAME_CRC_ERR = TRANS_RX_FAIL_BASE,  \n\tTRANS_RX_ERR_WITH_RXFIS_8B10B_DISP_ERR,  \n\tTRANS_RX_ERR_WITH_RXFRAME_HAVE_ERRPRM,  \n\t \n\tTRANS_RX_ERR_WITH_RXFIS_DECODE_ERROR,  \n\tTRANS_RX_ERR_WITH_RXFIS_CRC_ERR,  \n\tTRANS_RX_ERR_WITH_RXFRAME_LENGTH_OVERRUN,  \n\t \n\tTRANS_RX_ERR_WITH_RXFIS_RX_SYNCP,  \n\tTRANS_RX_ERR_WITH_LINK_BUF_OVERRUN,  \n\tTRANS_RX_ERR_WITH_BREAK_TIMEOUT,  \n\tTRANS_RX_ERR_WITH_BREAK_REQUEST,  \n\tTRANS_RX_ERR_WITH_BREAK_RECEVIED,  \n\tRESERVED1,  \n\tTRANS_RX_ERR_WITH_CLOSE_NORMAL,  \n\tTRANS_RX_ERR_WITH_CLOSE_PHY_DISABLE,  \n\tTRANS_RX_ERR_WITH_CLOSE_DWS_TIMEOUT,  \n\tTRANS_RX_ERR_WITH_CLOSE_COMINIT,  \n\tTRANS_RX_ERR_WITH_DATA_LEN0,  \n\tTRANS_RX_ERR_WITH_BAD_HASH,  \n\t \n\tTRANS_RX_XRDY_WLEN_ZERO_ERR,  \n\t \n\tTRANS_RX_SSP_FRM_LEN_ERR,  \n\t \n\tRESERVED2,  \n\tRESERVED3,  \n\tRESERVED4,  \n\tRESERVED5,  \n\tTRANS_RX_ERR_WITH_BAD_FRM_TYPE,  \n\tTRANS_RX_SMP_FRM_LEN_ERR,  \n\tTRANS_RX_SMP_RESP_TIMEOUT_ERR,  \n\tRESERVED6,  \n\tRESERVED7,  \n\tRESERVED8,  \n\tRESERVED9,  \n\tTRANS_RX_R_ERR,  \n\n\t \n\tDMA_TX_DIF_CRC_ERR = DMA_TX_ERR_BASE,  \n\tDMA_TX_DIF_APP_ERR,  \n\tDMA_TX_DIF_RPP_ERR,  \n\tDMA_TX_DATA_SGL_OVERFLOW,  \n\tDMA_TX_DIF_SGL_OVERFLOW,  \n\tDMA_TX_UNEXP_XFER_ERR,  \n\tDMA_TX_UNEXP_RETRANS_ERR,  \n\tDMA_TX_XFER_LEN_OVERFLOW,  \n\tDMA_TX_XFER_OFFSET_ERR,  \n\tDMA_TX_RAM_ECC_ERR,  \n\tDMA_TX_DIF_LEN_ALIGN_ERR,  \n\tDMA_TX_MAX_ERR_CODE,\n\n\t \n\tSIPC_RX_FIS_STATUS_ERR_BIT_VLD = SIPC_RX_ERR_BASE,  \n\tSIPC_RX_PIO_WRSETUP_STATUS_DRQ_ERR,  \n\tSIPC_RX_FIS_STATUS_BSY_BIT_ERR,  \n\tSIPC_RX_WRSETUP_LEN_ODD_ERR,  \n\tSIPC_RX_WRSETUP_LEN_ZERO_ERR,  \n\tSIPC_RX_WRDATA_LEN_NOT_MATCH_ERR,  \n\tSIPC_RX_NCQ_WRSETUP_OFFSET_ERR,  \n\tSIPC_RX_NCQ_WRSETUP_AUTO_ACTIVE_ERR,  \n\tSIPC_RX_SATA_UNEXP_FIS_ERR,  \n\tSIPC_RX_WRSETUP_ESTATUS_ERR,  \n\tSIPC_RX_DATA_UNDERFLOW_ERR,  \n\tSIPC_RX_MAX_ERR_CODE,\n\n\t \n\tDMA_RX_DIF_CRC_ERR = DMA_RX_ERR_BASE,  \n\tDMA_RX_DIF_APP_ERR,  \n\tDMA_RX_DIF_RPP_ERR,  \n\tDMA_RX_DATA_SGL_OVERFLOW,  \n\tDMA_RX_DIF_SGL_OVERFLOW,  \n\tDMA_RX_DATA_LEN_OVERFLOW,  \n\tDMA_RX_DATA_LEN_UNDERFLOW,  \n\tDMA_RX_DATA_OFFSET_ERR,  \n\tRESERVED10,  \n\tDMA_RX_SATA_FRAME_TYPE_ERR,  \n\tDMA_RX_RESP_BUF_OVERFLOW,  \n\tDMA_RX_UNEXP_RETRANS_RESP_ERR,  \n\tDMA_RX_UNEXP_NORM_RESP_ERR,  \n\tDMA_RX_UNEXP_RDFRAME_ERR,  \n\tDMA_RX_PIO_DATA_LEN_ERR,  \n\tDMA_RX_RDSETUP_STATUS_ERR,  \n\tDMA_RX_RDSETUP_STATUS_DRQ_ERR,  \n\tDMA_RX_RDSETUP_STATUS_BSY_ERR,  \n\tDMA_RX_RDSETUP_LEN_ODD_ERR,  \n\tDMA_RX_RDSETUP_LEN_ZERO_ERR,  \n\tDMA_RX_RDSETUP_LEN_OVER_ERR,  \n\tDMA_RX_RDSETUP_OFFSET_ERR,  \n\tDMA_RX_RDSETUP_ACTIVE_ERR,  \n\tDMA_RX_RDSETUP_ESTATUS_ERR,  \n\tDMA_RX_RAM_ECC_ERR,  \n\tDMA_RX_UNKNOWN_FRM_ERR,  \n\tDMA_RX_MAX_ERR_CODE,\n};\n\n#define HISI_SAS_COMMAND_ENTRIES_V2_HW 4096\n#define HISI_MAX_SATA_SUPPORT_V2_HW\t(HISI_SAS_COMMAND_ENTRIES_V2_HW/64 - 1)\n\n#define DIR_NO_DATA 0\n#define DIR_TO_INI 1\n#define DIR_TO_DEVICE 2\n#define DIR_RESERVED 3\n\n#define ERR_ON_TX_PHASE(err_phase) (err_phase == 0x2 || \\\n\t\terr_phase == 0x4 || err_phase == 0x8 ||\\\n\t\terr_phase == 0x6 || err_phase == 0xa)\n#define ERR_ON_RX_PHASE(err_phase) (err_phase == 0x10 || \\\n\t\terr_phase == 0x20 || err_phase == 0x40)\n\nstatic void link_timeout_disable_link(struct timer_list *t);\n\nstatic u32 hisi_sas_read32(struct hisi_hba *hisi_hba, u32 off)\n{\n\tvoid __iomem *regs = hisi_hba->regs + off;\n\n\treturn readl(regs);\n}\n\nstatic u32 hisi_sas_read32_relaxed(struct hisi_hba *hisi_hba, u32 off)\n{\n\tvoid __iomem *regs = hisi_hba->regs + off;\n\n\treturn readl_relaxed(regs);\n}\n\nstatic void hisi_sas_write32(struct hisi_hba *hisi_hba, u32 off, u32 val)\n{\n\tvoid __iomem *regs = hisi_hba->regs + off;\n\n\twritel(val, regs);\n}\n\nstatic void hisi_sas_phy_write32(struct hisi_hba *hisi_hba, int phy_no,\n\t\t\t\t u32 off, u32 val)\n{\n\tvoid __iomem *regs = hisi_hba->regs + (0x400 * phy_no) + off;\n\n\twritel(val, regs);\n}\n\nstatic u32 hisi_sas_phy_read32(struct hisi_hba *hisi_hba,\n\t\t\t\t      int phy_no, u32 off)\n{\n\tvoid __iomem *regs = hisi_hba->regs + (0x400 * phy_no) + off;\n\n\treturn readl(regs);\n}\n\n \nstatic int\nslot_index_alloc_quirk_v2_hw(struct hisi_hba *hisi_hba,\n\t\t\t     struct domain_device *device)\n{\n\tint sata_dev = dev_is_sata(device);\n\tvoid *bitmap = hisi_hba->slot_index_tags;\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tint sata_idx = sas_dev->sata_idx;\n\tint start, end;\n\n\tif (!sata_dev) {\n\t\t \n\t\tstart = 1;\n\t\tend = hisi_hba->slot_index_count;\n\t} else {\n\t\tif (sata_idx >= HISI_MAX_SATA_SUPPORT_V2_HW)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tstart = 64 * (sata_idx + 1);\n\t\tend = 64 * (sata_idx + 2);\n\t}\n\n\tspin_lock(&hisi_hba->lock);\n\twhile (1) {\n\t\tstart = find_next_zero_bit(bitmap,\n\t\t\t\t\thisi_hba->slot_index_count, start);\n\t\tif (start >= end) {\n\t\t\tspin_unlock(&hisi_hba->lock);\n\t\t\treturn -SAS_QUEUE_FULL;\n\t\t}\n\t\t \n\t\tif (sata_dev ^ (start & 1))\n\t\t\tbreak;\n\t\tstart++;\n\t}\n\n\tset_bit(start, bitmap);\n\tspin_unlock(&hisi_hba->lock);\n\treturn start;\n}\n\nstatic bool sata_index_alloc_v2_hw(struct hisi_hba *hisi_hba, int *idx)\n{\n\tunsigned int index;\n\tstruct device *dev = hisi_hba->dev;\n\tvoid *bitmap = hisi_hba->sata_dev_bitmap;\n\n\tindex = find_first_zero_bit(bitmap, HISI_MAX_SATA_SUPPORT_V2_HW);\n\tif (index >= HISI_MAX_SATA_SUPPORT_V2_HW) {\n\t\tdev_warn(dev, \"alloc sata index failed, index=%d\\n\", index);\n\t\treturn false;\n\t}\n\n\tset_bit(index, bitmap);\n\t*idx = index;\n\treturn true;\n}\n\n\nstatic struct\nhisi_sas_device *alloc_dev_quirk_v2_hw(struct domain_device *device)\n{\n\tstruct hisi_hba *hisi_hba = device->port->ha->lldd_ha;\n\tstruct hisi_sas_device *sas_dev = NULL;\n\tint i, sata_dev = dev_is_sata(device);\n\tint sata_idx = -1;\n\n\tspin_lock(&hisi_hba->lock);\n\n\tif (sata_dev)\n\t\tif (!sata_index_alloc_v2_hw(hisi_hba, &sata_idx))\n\t\t\tgoto out;\n\n\tfor (i = 0; i < HISI_SAS_MAX_DEVICES; i++) {\n\t\t \n\t\tif (sata_dev && (i & 1))\n\t\t\tcontinue;\n\t\tif (hisi_hba->devices[i].dev_type == SAS_PHY_UNUSED) {\n\t\t\tint queue = i % hisi_hba->queue_count;\n\t\t\tstruct hisi_sas_dq *dq = &hisi_hba->dq[queue];\n\n\t\t\thisi_hba->devices[i].device_id = i;\n\t\t\tsas_dev = &hisi_hba->devices[i];\n\t\t\tsas_dev->dev_status = HISI_SAS_DEV_INIT;\n\t\t\tsas_dev->dev_type = device->dev_type;\n\t\t\tsas_dev->hisi_hba = hisi_hba;\n\t\t\tsas_dev->sas_device = device;\n\t\t\tsas_dev->sata_idx = sata_idx;\n\t\t\tsas_dev->dq = dq;\n\t\t\tspin_lock_init(&sas_dev->lock);\n\t\t\tINIT_LIST_HEAD(&hisi_hba->devices[i].list);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&hisi_hba->lock);\n\n\treturn sas_dev;\n}\n\nstatic void config_phy_opt_mode_v2_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 cfg = hisi_sas_phy_read32(hisi_hba, phy_no, PHY_CFG);\n\n\tcfg &= ~PHY_CFG_DC_OPT_MSK;\n\tcfg |= 1 << PHY_CFG_DC_OPT_OFF;\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHY_CFG, cfg);\n}\n\nstatic void config_id_frame_v2_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tstruct sas_identify_frame identify_frame;\n\tu32 *identify_buffer;\n\n\tmemset(&identify_frame, 0, sizeof(identify_frame));\n\tidentify_frame.dev_type = SAS_END_DEVICE;\n\tidentify_frame.frame_type = 0;\n\tidentify_frame._un1 = 1;\n\tidentify_frame.initiator_bits = SAS_PROTOCOL_ALL;\n\tidentify_frame.target_bits = SAS_PROTOCOL_NONE;\n\tmemcpy(&identify_frame._un4_11[0], hisi_hba->sas_addr, SAS_ADDR_SIZE);\n\tmemcpy(&identify_frame.sas_addr[0], hisi_hba->sas_addr,\tSAS_ADDR_SIZE);\n\tidentify_frame.phy_id = phy_no;\n\tidentify_buffer = (u32 *)(&identify_frame);\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD0,\n\t\t\t__swab32(identify_buffer[0]));\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD1,\n\t\t\t__swab32(identify_buffer[1]));\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD2,\n\t\t\t__swab32(identify_buffer[2]));\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD3,\n\t\t\t__swab32(identify_buffer[3]));\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD4,\n\t\t\t__swab32(identify_buffer[4]));\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD5,\n\t\t\t__swab32(identify_buffer[5]));\n}\n\nstatic void setup_itct_v2_hw(struct hisi_hba *hisi_hba,\n\t\t\t     struct hisi_sas_device *sas_dev)\n{\n\tstruct domain_device *device = sas_dev->sas_device;\n\tstruct device *dev = hisi_hba->dev;\n\tu64 qw0, device_id = sas_dev->device_id;\n\tstruct hisi_sas_itct *itct = &hisi_hba->itct[device_id];\n\tstruct domain_device *parent_dev = device->parent;\n\tstruct asd_sas_port *sas_port = device->port;\n\tstruct hisi_sas_port *port = to_hisi_sas_port(sas_port);\n\tu64 sas_addr;\n\n\tmemset(itct, 0, sizeof(*itct));\n\n\t \n\tqw0 = 0;\n\tswitch (sas_dev->dev_type) {\n\tcase SAS_END_DEVICE:\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tqw0 = HISI_SAS_DEV_TYPE_SSP << ITCT_HDR_DEV_TYPE_OFF;\n\t\tbreak;\n\tcase SAS_SATA_DEV:\n\tcase SAS_SATA_PENDING:\n\t\tif (parent_dev && dev_is_expander(parent_dev->dev_type))\n\t\t\tqw0 = HISI_SAS_DEV_TYPE_STP << ITCT_HDR_DEV_TYPE_OFF;\n\t\telse\n\t\t\tqw0 = HISI_SAS_DEV_TYPE_SATA << ITCT_HDR_DEV_TYPE_OFF;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"setup itct: unsupported dev type (%d)\\n\",\n\t\t\t sas_dev->dev_type);\n\t}\n\n\tqw0 |= ((1 << ITCT_HDR_VALID_OFF) |\n\t\t(device->linkrate << ITCT_HDR_MCR_OFF) |\n\t\t(1 << ITCT_HDR_VLN_OFF) |\n\t\t(ITCT_HDR_SMP_TIMEOUT << ITCT_HDR_SMP_TIMEOUT_OFF) |\n\t\t(1 << ITCT_HDR_AWT_CONTINUE_OFF) |\n\t\t(port->id << ITCT_HDR_PORT_ID_OFF));\n\titct->qw0 = cpu_to_le64(qw0);\n\n\t \n\tmemcpy(&sas_addr, device->sas_addr, SAS_ADDR_SIZE);\n\titct->sas_addr = cpu_to_le64(__swab64(sas_addr));\n\n\t \n\tif (!dev_is_sata(device))\n\t\titct->qw2 = cpu_to_le64((5000ULL << ITCT_HDR_INLT_OFF) |\n\t\t\t\t\t(0x1ULL << ITCT_HDR_BITLT_OFF) |\n\t\t\t\t\t(0x32ULL << ITCT_HDR_MCTLT_OFF) |\n\t\t\t\t\t(0x1ULL << ITCT_HDR_RTOLT_OFF));\n}\n\nstatic int clear_itct_v2_hw(struct hisi_hba *hisi_hba,\n\t\t\t    struct hisi_sas_device *sas_dev)\n{\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tu64 dev_id = sas_dev->device_id;\n\tstruct hisi_sas_itct *itct = &hisi_hba->itct[dev_id];\n\tu32 reg_val = hisi_sas_read32(hisi_hba, ENT_INT_SRC3);\n\tstruct device *dev = hisi_hba->dev;\n\tint i;\n\n\tsas_dev->completion = &completion;\n\n\t \n\tif (ENT_INT_SRC3_ITC_INT_MSK & reg_val)\n\t\thisi_sas_write32(hisi_hba, ENT_INT_SRC3,\n\t\t\t\t ENT_INT_SRC3_ITC_INT_MSK);\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\treg_val = ITCT_CLR_EN_MSK | (dev_id & ITCT_DEV_MSK);\n\t\thisi_sas_write32(hisi_hba, ITCT_CLR, reg_val);\n\t\tif (!wait_for_completion_timeout(sas_dev->completion,\n\t\t\t\t\t\t HISI_SAS_CLEAR_ITCT_TIMEOUT)) {\n\t\t\tdev_warn(dev, \"failed to clear ITCT\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tmemset(itct, 0, sizeof(struct hisi_sas_itct));\n\t}\n\treturn 0;\n}\n\nstatic void free_device_v2_hw(struct hisi_sas_device *sas_dev)\n{\n\tstruct hisi_hba *hisi_hba = sas_dev->hisi_hba;\n\n\t \n\tif (dev_is_sata(sas_dev->sas_device))\n\t\tclear_bit(sas_dev->sata_idx, hisi_hba->sata_dev_bitmap);\n}\n\nstatic int reset_hw_v2_hw(struct hisi_hba *hisi_hba)\n{\n\tint i, reset_val;\n\tu32 val;\n\tunsigned long end_time;\n\tstruct device *dev = hisi_hba->dev;\n\n\t \n\tif (hisi_hba->n_phy == 9)\n\t\treset_val = 0x1fffff;\n\telse\n\t\treset_val = 0x7ffff;\n\n\thisi_sas_write32(hisi_hba, DLVRY_QUEUE_ENABLE, 0);\n\n\t \n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\tu32 phy_cfg = hisi_sas_phy_read32(hisi_hba, i, PHY_CFG);\n\n\t\tphy_cfg &= ~PHY_CTRL_RESET_MSK;\n\t\thisi_sas_phy_write32(hisi_hba, i, PHY_CFG, phy_cfg);\n\t}\n\tudelay(50);\n\n\t \n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\tu32 dma_tx_status, dma_rx_status;\n\n\t\tend_time = jiffies + msecs_to_jiffies(1000);\n\n\t\twhile (1) {\n\t\t\tdma_tx_status = hisi_sas_phy_read32(hisi_hba, i,\n\t\t\t\t\t\t\t    DMA_TX_STATUS);\n\t\t\tdma_rx_status = hisi_sas_phy_read32(hisi_hba, i,\n\t\t\t\t\t\t\t    DMA_RX_STATUS);\n\n\t\t\tif (!(dma_tx_status & DMA_TX_STATUS_BUSY_MSK) &&\n\t\t\t\t!(dma_rx_status & DMA_RX_STATUS_BUSY_MSK))\n\t\t\t\tbreak;\n\n\t\t\tmsleep(20);\n\t\t\tif (time_after(jiffies, end_time))\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tend_time = jiffies + msecs_to_jiffies(1000);\n\twhile (1) {\n\t\tu32 axi_status =\n\t\t\thisi_sas_read32(hisi_hba, AXI_CFG);\n\n\t\tif (axi_status == 0)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t\tif (time_after(jiffies, end_time))\n\t\t\treturn -EIO;\n\t}\n\n\tif (ACPI_HANDLE(dev)) {\n\t\tacpi_status s;\n\n\t\ts = acpi_evaluate_object(ACPI_HANDLE(dev), \"_RST\", NULL, NULL);\n\t\tif (ACPI_FAILURE(s)) {\n\t\t\tdev_err(dev, \"Reset failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else if (hisi_hba->ctrl) {\n\t\t \n\t\tregmap_write(hisi_hba->ctrl, hisi_hba->ctrl_reset_reg,\n\t\t\t\treset_val);\n\t\tregmap_write(hisi_hba->ctrl, hisi_hba->ctrl_clock_ena_reg + 4,\n\t\t\t\treset_val);\n\t\tmsleep(1);\n\t\tregmap_read(hisi_hba->ctrl, hisi_hba->ctrl_reset_sts_reg, &val);\n\t\tif (reset_val != (val & reset_val)) {\n\t\t\tdev_err(dev, \"SAS reset fail.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tregmap_write(hisi_hba->ctrl, hisi_hba->ctrl_reset_reg + 4,\n\t\t\t\treset_val);\n\t\tregmap_write(hisi_hba->ctrl, hisi_hba->ctrl_clock_ena_reg,\n\t\t\t\treset_val);\n\t\tmsleep(1);\n\t\tregmap_read(hisi_hba->ctrl, hisi_hba->ctrl_reset_sts_reg,\n\t\t\t\t&val);\n\t\tif (val & reset_val) {\n\t\t\tdev_err(dev, \"SAS de-reset fail.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\tdev_err(dev, \"no reset method\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void phys_reject_stp_links_v2_hw(struct hisi_hba *hisi_hba)\n{\n\tu32 cfg;\n\tint phy_no;\n\n\thisi_hba->reject_stp_links_msk = (1 << hisi_hba->n_phy) - 1;\n\tfor (phy_no = 0; phy_no < hisi_hba->n_phy; phy_no++) {\n\t\tcfg = hisi_sas_phy_read32(hisi_hba, phy_no, CON_CONTROL);\n\t\tif (!(cfg & CON_CONTROL_CFG_OPEN_ACC_STP_MSK))\n\t\t\tcontinue;\n\n\t\tcfg &= ~CON_CONTROL_CFG_OPEN_ACC_STP_MSK;\n\t\thisi_sas_phy_write32(hisi_hba, phy_no, CON_CONTROL, cfg);\n\t}\n}\n\nstatic void phys_try_accept_stp_links_v2_hw(struct hisi_hba *hisi_hba)\n{\n\tint phy_no;\n\tu32 dma_tx_dfx1;\n\n\tfor (phy_no = 0; phy_no < hisi_hba->n_phy; phy_no++) {\n\t\tif (!(hisi_hba->reject_stp_links_msk & BIT(phy_no)))\n\t\t\tcontinue;\n\n\t\tdma_tx_dfx1 = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\t\tDMA_TX_DFX1);\n\t\tif (dma_tx_dfx1 & DMA_TX_DFX1_IPTT_MSK) {\n\t\t\tu32 cfg = hisi_sas_phy_read32(hisi_hba,\n\t\t\t\tphy_no, CON_CONTROL);\n\n\t\t\tcfg |= CON_CONTROL_CFG_OPEN_ACC_STP_MSK;\n\t\t\thisi_sas_phy_write32(hisi_hba, phy_no,\n\t\t\t\tCON_CONTROL, cfg);\n\t\t\tclear_bit(phy_no, &hisi_hba->reject_stp_links_msk);\n\t\t}\n\t}\n}\n\nstatic const struct signal_attenuation_s x6000 = {9200, 0, 10476};\nstatic const struct sig_atten_lu_s sig_atten_lu[] = {\n\t{ &x6000, 0x3016a68 },\n};\n\nstatic void init_reg_v2_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tu32 sas_phy_ctrl = 0x30b9908;\n\tu32 signal[3];\n\tint i;\n\n\t \n\n\t \n\tif (device_property_present(dev, \"hip06-sas-v2-quirk-amt\")) {\n\t\thisi_sas_write32(hisi_hba, AM_CFG_MAX_TRANS, 0x2020);\n\t\thisi_sas_write32(hisi_hba, AM_CFG_SINGLE_PORT_MAX_TRANS,\n\t\t\t\t 0x2020);\n\t}  \n\n\thisi_sas_write32(hisi_hba, DLVRY_QUEUE_ENABLE,\n\t\t\t (u32)((1ULL << hisi_hba->queue_count) - 1));\n\thisi_sas_write32(hisi_hba, AXI_USER1, 0xc0000000);\n\thisi_sas_write32(hisi_hba, AXI_USER2, 0x10000);\n\thisi_sas_write32(hisi_hba, HGC_SAS_TXFAIL_RETRY_CTRL, 0x0);\n\thisi_sas_write32(hisi_hba, HGC_SAS_TX_OPEN_FAIL_RETRY_CTRL, 0x7FF);\n\thisi_sas_write32(hisi_hba, OPENA_WT_CONTI_TIME, 0x1);\n\thisi_sas_write32(hisi_hba, I_T_NEXUS_LOSS_TIME, 0x1F4);\n\thisi_sas_write32(hisi_hba, MAX_CON_TIME_LIMIT_TIME, 0x32);\n\thisi_sas_write32(hisi_hba, BUS_INACTIVE_LIMIT_TIME, 0x1);\n\thisi_sas_write32(hisi_hba, CFG_AGING_TIME, 0x1);\n\thisi_sas_write32(hisi_hba, HGC_ERR_STAT_EN, 0x1);\n\thisi_sas_write32(hisi_hba, HGC_GET_ITV_TIME, 0x1);\n\thisi_sas_write32(hisi_hba, INT_COAL_EN, 0xc);\n\thisi_sas_write32(hisi_hba, OQ_INT_COAL_TIME, 0x60);\n\thisi_sas_write32(hisi_hba, OQ_INT_COAL_CNT, 0x3);\n\thisi_sas_write32(hisi_hba, ENT_INT_COAL_TIME, 0x1);\n\thisi_sas_write32(hisi_hba, ENT_INT_COAL_CNT, 0x1);\n\thisi_sas_write32(hisi_hba, OQ_INT_SRC, 0x0);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC1, 0xffffffff);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC2, 0xffffffff);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC3, 0xffffffff);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK1, 0x7efefefe);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK2, 0x7efefefe);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK3, 0x7ffe20fe);\n\thisi_sas_write32(hisi_hba, SAS_ECC_INTR_MSK, 0xfff00c30);\n\tfor (i = 0; i < hisi_hba->queue_count; i++)\n\t\thisi_sas_write32(hisi_hba, OQ0_INT_SRC_MSK + 0x4 * i, 0);\n\n\thisi_sas_write32(hisi_hba, AXI_AHB_CLK_CFG, 1);\n\thisi_sas_write32(hisi_hba, HYPER_STREAM_ID_EN_CFG, 1);\n\n\t \n\tif (!device_property_read_u32_array(dev, \"hisilicon,signal-attenuation\",\n\t\t\t\t\t    signal, ARRAY_SIZE(signal))) {\n\t\tfor (i = 0; i < ARRAY_SIZE(sig_atten_lu); i++) {\n\t\t\tconst struct sig_atten_lu_s *lookup = &sig_atten_lu[i];\n\t\t\tconst struct signal_attenuation_s *att = lookup->att;\n\n\t\t\tif ((signal[0] == att->de_emphasis) &&\n\t\t\t    (signal[1] == att->preshoot) &&\n\t\t\t    (signal[2] == att->boost)) {\n\t\t\t\tsas_phy_ctrl = lookup->sas_phy_ctrl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == ARRAY_SIZE(sig_atten_lu))\n\t\t\tdev_warn(dev, \"unknown signal attenuation values, using default PHY ctrl config\\n\");\n\t}\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\tstruct hisi_sas_phy *phy = &hisi_hba->phy[i];\n\t\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\t\tu32 prog_phy_link_rate = 0x800;\n\n\t\tif (!sas_phy->phy || (sas_phy->phy->maximum_linkrate <\n\t\t\t\tSAS_LINK_RATE_1_5_GBPS)) {\n\t\t\tprog_phy_link_rate = 0x855;\n\t\t} else {\n\t\t\tenum sas_linkrate max = sas_phy->phy->maximum_linkrate;\n\n\t\t\tprog_phy_link_rate =\n\t\t\t\thisi_sas_get_prog_phy_linkrate_mask(max) |\n\t\t\t\t0x800;\n\t\t}\n\t\thisi_sas_phy_write32(hisi_hba, i, PROG_PHY_LINK_RATE,\n\t\t\tprog_phy_link_rate);\n\t\thisi_sas_phy_write32(hisi_hba, i, SAS_PHY_CTRL, sas_phy_ctrl);\n\t\thisi_sas_phy_write32(hisi_hba, i, SL_TOUT_CFG, 0x7d7d7d7d);\n\t\thisi_sas_phy_write32(hisi_hba, i, SL_CONTROL, 0x0);\n\t\thisi_sas_phy_write32(hisi_hba, i, TXID_AUTO, 0x2);\n\t\thisi_sas_phy_write32(hisi_hba, i, DONE_RECEIVED_TIME, 0x8);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT0, 0xffffffff);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT1, 0xffffffff);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT2, 0xfff87fff);\n\t\thisi_sas_phy_write32(hisi_hba, i, RXOP_CHECK_CFG_H, 0x1000);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT1_MSK, 0xff857fff);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT2_MSK, 0x8ffffbfe);\n\t\thisi_sas_phy_write32(hisi_hba, i, SL_CFG, 0x13f801fc);\n\t\thisi_sas_phy_write32(hisi_hba, i, PHY_CTRL_RDY_MSK, 0x0);\n\t\thisi_sas_phy_write32(hisi_hba, i, PHYCTRL_NOT_RDY_MSK, 0x0);\n\t\thisi_sas_phy_write32(hisi_hba, i, PHYCTRL_DWS_RESET_MSK, 0x0);\n\t\thisi_sas_phy_write32(hisi_hba, i, PHYCTRL_PHY_ENA_MSK, 0x0);\n\t\thisi_sas_phy_write32(hisi_hba, i, SL_RX_BCAST_CHK_MSK, 0x0);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT_COAL_EN, 0x0);\n\t\thisi_sas_phy_write32(hisi_hba, i, PHYCTRL_OOB_RESTART_MSK, 0x0);\n\t\tif (hisi_hba->refclk_frequency_mhz == 66)\n\t\t\thisi_sas_phy_write32(hisi_hba, i, PHY_CTRL, 0x199B694);\n\t\t \n\t}\n\n\tfor (i = 0; i < hisi_hba->queue_count; i++) {\n\t\t \n\t\thisi_sas_write32(hisi_hba,\n\t\t\t\t DLVRY_Q_0_BASE_ADDR_HI + (i * 0x14),\n\t\t\t\t upper_32_bits(hisi_hba->cmd_hdr_dma[i]));\n\n\t\thisi_sas_write32(hisi_hba, DLVRY_Q_0_BASE_ADDR_LO + (i * 0x14),\n\t\t\t\t lower_32_bits(hisi_hba->cmd_hdr_dma[i]));\n\n\t\thisi_sas_write32(hisi_hba, DLVRY_Q_0_DEPTH + (i * 0x14),\n\t\t\t\t HISI_SAS_QUEUE_SLOTS);\n\n\t\t \n\t\thisi_sas_write32(hisi_hba, COMPL_Q_0_BASE_ADDR_HI + (i * 0x14),\n\t\t\t\t upper_32_bits(hisi_hba->complete_hdr_dma[i]));\n\n\t\thisi_sas_write32(hisi_hba, COMPL_Q_0_BASE_ADDR_LO + (i * 0x14),\n\t\t\t\t lower_32_bits(hisi_hba->complete_hdr_dma[i]));\n\n\t\thisi_sas_write32(hisi_hba, COMPL_Q_0_DEPTH + (i * 0x14),\n\t\t\t\t HISI_SAS_QUEUE_SLOTS);\n\t}\n\n\t \n\thisi_sas_write32(hisi_hba, ITCT_BASE_ADDR_LO,\n\t\t\t lower_32_bits(hisi_hba->itct_dma));\n\n\thisi_sas_write32(hisi_hba, ITCT_BASE_ADDR_HI,\n\t\t\t upper_32_bits(hisi_hba->itct_dma));\n\n\t \n\thisi_sas_write32(hisi_hba, IOST_BASE_ADDR_LO,\n\t\t\t lower_32_bits(hisi_hba->iost_dma));\n\n\thisi_sas_write32(hisi_hba, IOST_BASE_ADDR_HI,\n\t\t\t upper_32_bits(hisi_hba->iost_dma));\n\n\t \n\thisi_sas_write32(hisi_hba, IO_BROKEN_MSG_ADDR_LO,\n\t\t\t lower_32_bits(hisi_hba->breakpoint_dma));\n\n\thisi_sas_write32(hisi_hba, IO_BROKEN_MSG_ADDR_HI,\n\t\t\t upper_32_bits(hisi_hba->breakpoint_dma));\n\n\t \n\thisi_sas_write32(hisi_hba, IO_SATA_BROKEN_MSG_ADDR_LO,\n\t\t\t lower_32_bits(hisi_hba->sata_breakpoint_dma));\n\n\thisi_sas_write32(hisi_hba, IO_SATA_BROKEN_MSG_ADDR_HI,\n\t\t\t upper_32_bits(hisi_hba->sata_breakpoint_dma));\n\n\t \n\thisi_sas_write32(hisi_hba, SATA_INITI_D2H_STORE_ADDR_LO,\n\t\t\t lower_32_bits(hisi_hba->initial_fis_dma));\n\n\thisi_sas_write32(hisi_hba, SATA_INITI_D2H_STORE_ADDR_HI,\n\t\t\t upper_32_bits(hisi_hba->initial_fis_dma));\n}\n\nstatic void link_timeout_enable_link(struct timer_list *t)\n{\n\tstruct hisi_hba *hisi_hba = from_timer(hisi_hba, t, timer);\n\tint i, reg_val;\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\tif (hisi_hba->reject_stp_links_msk & BIT(i))\n\t\t\tcontinue;\n\n\t\treg_val = hisi_sas_phy_read32(hisi_hba, i, CON_CONTROL);\n\t\tif (!(reg_val & BIT(0))) {\n\t\t\thisi_sas_phy_write32(hisi_hba, i,\n\t\t\t\t\tCON_CONTROL, 0x7);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thisi_hba->timer.function = link_timeout_disable_link;\n\tmod_timer(&hisi_hba->timer, jiffies + msecs_to_jiffies(900));\n}\n\nstatic void link_timeout_disable_link(struct timer_list *t)\n{\n\tstruct hisi_hba *hisi_hba = from_timer(hisi_hba, t, timer);\n\tint i, reg_val;\n\n\treg_val = hisi_sas_read32(hisi_hba, PHY_STATE);\n\tfor (i = 0; i < hisi_hba->n_phy && reg_val; i++) {\n\t\tif (hisi_hba->reject_stp_links_msk & BIT(i))\n\t\t\tcontinue;\n\n\t\tif (reg_val & BIT(i)) {\n\t\t\thisi_sas_phy_write32(hisi_hba, i,\n\t\t\t\t\tCON_CONTROL, 0x6);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thisi_hba->timer.function = link_timeout_enable_link;\n\tmod_timer(&hisi_hba->timer, jiffies + msecs_to_jiffies(100));\n}\n\nstatic void set_link_timer_quirk(struct hisi_hba *hisi_hba)\n{\n\thisi_hba->timer.function = link_timeout_disable_link;\n\thisi_hba->timer.expires = jiffies + msecs_to_jiffies(1000);\n\tadd_timer(&hisi_hba->timer);\n}\n\nstatic int hw_init_v2_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tint rc;\n\n\trc = reset_hw_v2_hw(hisi_hba);\n\tif (rc) {\n\t\tdev_err(dev, \"hisi_sas_reset_hw failed, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tmsleep(100);\n\tinit_reg_v2_hw(hisi_hba);\n\n\treturn 0;\n}\n\nstatic void enable_phy_v2_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 cfg = hisi_sas_phy_read32(hisi_hba, phy_no, PHY_CFG);\n\n\tcfg |= PHY_CFG_ENA_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHY_CFG, cfg);\n}\n\nstatic bool is_sata_phy_v2_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 context;\n\n\tcontext = hisi_sas_read32(hisi_hba, PHY_CONTEXT);\n\tif (context & (1 << phy_no))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool tx_fifo_is_empty_v2_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 dfx_val;\n\n\tdfx_val = hisi_sas_phy_read32(hisi_hba, phy_no, DMA_TX_DFX1);\n\n\tif (dfx_val & BIT(16))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool axi_bus_is_idle_v2_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tint i, max_loop = 1000;\n\tstruct device *dev = hisi_hba->dev;\n\tu32 status, axi_status, dfx_val, dfx_tx_val;\n\n\tfor (i = 0; i < max_loop; i++) {\n\t\tstatus = hisi_sas_read32_relaxed(hisi_hba,\n\t\t\tAXI_MASTER_CFG_BASE + AM_CURR_TRANS_RETURN);\n\n\t\taxi_status = hisi_sas_read32(hisi_hba, AXI_CFG);\n\t\tdfx_val = hisi_sas_phy_read32(hisi_hba, phy_no, DMA_TX_DFX1);\n\t\tdfx_tx_val = hisi_sas_phy_read32(hisi_hba,\n\t\t\tphy_no, DMA_TX_FIFO_DFX0);\n\n\t\tif ((status == 0x3) && (axi_status == 0x0) &&\n\t\t    (dfx_val & BIT(20)) && (dfx_tx_val & BIT(10)))\n\t\t\treturn true;\n\t\tudelay(10);\n\t}\n\tdev_err(dev, \"bus is not idle phy%d, axi150:0x%x axi100:0x%x port204:0x%x port240:0x%x\\n\",\n\t\t\tphy_no, status, axi_status,\n\t\t\tdfx_val, dfx_tx_val);\n\treturn false;\n}\n\nstatic bool wait_io_done_v2_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tint i, max_loop = 1000;\n\tstruct device *dev = hisi_hba->dev;\n\tu32 status, tx_dfx0;\n\n\tfor (i = 0; i < max_loop; i++) {\n\t\tstatus = hisi_sas_phy_read32(hisi_hba, phy_no, LINK_DFX2);\n\t\tstatus = (status & 0x3fc0) >> 6;\n\n\t\tif (status != 0x1)\n\t\t\treturn true;\n\n\t\ttx_dfx0 = hisi_sas_phy_read32(hisi_hba, phy_no, DMA_TX_DFX0);\n\t\tif ((tx_dfx0 & 0x1ff) == 0x2)\n\t\t\treturn true;\n\t\tudelay(10);\n\t}\n\tdev_err(dev, \"IO not done phy%d, port264:0x%x port200:0x%x\\n\",\n\t\t\tphy_no, status, tx_dfx0);\n\treturn false;\n}\n\nstatic bool allowed_disable_phy_v2_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tif (tx_fifo_is_empty_v2_hw(hisi_hba, phy_no))\n\t\treturn true;\n\n\tif (!axi_bus_is_idle_v2_hw(hisi_hba, phy_no))\n\t\treturn false;\n\n\tif (!wait_io_done_v2_hw(hisi_hba, phy_no))\n\t\treturn false;\n\n\treturn true;\n}\n\n\nstatic void disable_phy_v2_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 cfg, axi_val, dfx0_val, txid_auto;\n\tstruct device *dev = hisi_hba->dev;\n\n\t \n\taxi_val = hisi_sas_read32(hisi_hba, AXI_MASTER_CFG_BASE +\n\t\t\t\tAM_CTRL_GLOBAL);\n\taxi_val |= 0x1;\n\thisi_sas_write32(hisi_hba, AXI_MASTER_CFG_BASE +\n\t\tAM_CTRL_GLOBAL, axi_val);\n\n\tif (is_sata_phy_v2_hw(hisi_hba, phy_no)) {\n\t\tif (allowed_disable_phy_v2_hw(hisi_hba, phy_no))\n\t\t\tgoto do_disable;\n\n\t\t \n\t\tqueue_work(hisi_hba->wq, &hisi_hba->rst_work);\n\t\treturn;\n\t}\n\n\tdfx0_val = hisi_sas_phy_read32(hisi_hba, phy_no, PORT_DFX0);\n\tdfx0_val = (dfx0_val & 0x1fc0) >> 6;\n\tif (dfx0_val != 0x4)\n\t\tgoto do_disable;\n\n\tif (!tx_fifo_is_empty_v2_hw(hisi_hba, phy_no)) {\n\t\tdev_warn(dev, \"phy%d, wait tx fifo need send break\\n\",\n\t\t\tphy_no);\n\t\ttxid_auto = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\tTXID_AUTO);\n\t\ttxid_auto |= TXID_AUTO_CTB_MSK;\n\t\thisi_sas_phy_write32(hisi_hba, phy_no, TXID_AUTO,\n\t\t\t\t\ttxid_auto);\n\t}\n\ndo_disable:\n\tcfg = hisi_sas_phy_read32(hisi_hba, phy_no, PHY_CFG);\n\tcfg &= ~PHY_CFG_ENA_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHY_CFG, cfg);\n\n\t \n\taxi_val &= ~0x1;\n\thisi_sas_write32(hisi_hba, AXI_MASTER_CFG_BASE +\n\t\tAM_CTRL_GLOBAL, axi_val);\n}\n\nstatic void start_phy_v2_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tconfig_id_frame_v2_hw(hisi_hba, phy_no);\n\tconfig_phy_opt_mode_v2_hw(hisi_hba, phy_no);\n\tenable_phy_v2_hw(hisi_hba, phy_no);\n}\n\nstatic void phy_hard_reset_v2_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tu32 txid_auto;\n\n\thisi_sas_phy_enable(hisi_hba, phy_no, 0);\n\tif (phy->identify.device_type == SAS_END_DEVICE) {\n\t\ttxid_auto = hisi_sas_phy_read32(hisi_hba, phy_no, TXID_AUTO);\n\t\thisi_sas_phy_write32(hisi_hba, phy_no, TXID_AUTO,\n\t\t\t\t\ttxid_auto | TX_HARDRST_MSK);\n\t}\n\tmsleep(100);\n\thisi_sas_phy_enable(hisi_hba, phy_no, 1);\n}\n\nstatic void phy_get_events_v2_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tstruct sas_phy *sphy = sas_phy->phy;\n\tu32 err4_reg_val, err6_reg_val;\n\n\t \n\terr4_reg_val = hisi_sas_phy_read32(hisi_hba, phy_no, SAS_ERR_CNT4_REG);\n\n\t \n\terr6_reg_val = hisi_sas_phy_read32(hisi_hba, phy_no, SAS_ERR_CNT6_REG);\n\n\tsphy->loss_of_dword_sync_count += (err4_reg_val >> 16) & 0xFFFF;\n\tsphy->phy_reset_problem_count += err4_reg_val & 0xFFFF;\n\tsphy->invalid_dword_count += (err6_reg_val & 0xFF0000) >> 16;\n\tsphy->running_disparity_error_count += err6_reg_val & 0xFF;\n}\n\nstatic void phys_init_v2_hw(struct hisi_hba *hisi_hba)\n{\n\tint i;\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\tstruct hisi_sas_phy *phy = &hisi_hba->phy[i];\n\t\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\n\t\tif (!sas_phy->phy->enabled)\n\t\t\tcontinue;\n\n\t\thisi_sas_phy_enable(hisi_hba, i, 1);\n\t}\n}\n\nstatic void sl_notify_ssp_v2_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 sl_control;\n\n\tsl_control = hisi_sas_phy_read32(hisi_hba, phy_no, SL_CONTROL);\n\tsl_control |= SL_CONTROL_NOTIFY_EN_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, SL_CONTROL, sl_control);\n\tmsleep(1);\n\tsl_control = hisi_sas_phy_read32(hisi_hba, phy_no, SL_CONTROL);\n\tsl_control &= ~SL_CONTROL_NOTIFY_EN_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, SL_CONTROL, sl_control);\n}\n\nstatic enum sas_linkrate phy_get_max_linkrate_v2_hw(void)\n{\n\treturn SAS_LINK_RATE_12_0_GBPS;\n}\n\nstatic void phy_set_linkrate_v2_hw(struct hisi_hba *hisi_hba, int phy_no,\n\t\tstruct sas_phy_linkrates *r)\n{\n\tenum sas_linkrate max = r->maximum_linkrate;\n\tu32 prog_phy_link_rate = 0x800;\n\n\tprog_phy_link_rate |= hisi_sas_get_prog_phy_linkrate_mask(max);\n\thisi_sas_phy_write32(hisi_hba, phy_no, PROG_PHY_LINK_RATE,\n\t\t\t     prog_phy_link_rate);\n}\n\nstatic int get_wideport_bitmap_v2_hw(struct hisi_hba *hisi_hba, int port_id)\n{\n\tint i, bitmap = 0;\n\tu32 phy_port_num_ma = hisi_sas_read32(hisi_hba, PHY_PORT_NUM_MA);\n\tu32 phy_state = hisi_sas_read32(hisi_hba, PHY_STATE);\n\n\tfor (i = 0; i < (hisi_hba->n_phy < 9 ? hisi_hba->n_phy : 8); i++)\n\t\tif (phy_state & 1 << i)\n\t\t\tif (((phy_port_num_ma >> (i * 4)) & 0xf) == port_id)\n\t\t\t\tbitmap |= 1 << i;\n\n\tif (hisi_hba->n_phy == 9) {\n\t\tu32 port_state = hisi_sas_read32(hisi_hba, PORT_STATE);\n\n\t\tif (phy_state & 1 << 8)\n\t\t\tif (((port_state & PORT_STATE_PHY8_PORT_NUM_MSK) >>\n\t\t\t     PORT_STATE_PHY8_PORT_NUM_OFF) == port_id)\n\t\t\t\tbitmap |= 1 << 9;\n\t}\n\n\treturn bitmap;\n}\n\n \nstatic void start_delivery_v2_hw(struct hisi_sas_dq *dq)\n{\n\tstruct hisi_hba *hisi_hba = dq->hisi_hba;\n\tstruct hisi_sas_slot *s, *s1, *s2 = NULL;\n\tint dlvry_queue = dq->id;\n\tint wp;\n\n\tlist_for_each_entry_safe(s, s1, &dq->list, delivery) {\n\t\tif (!s->ready)\n\t\t\tbreak;\n\t\ts2 = s;\n\t\tlist_del(&s->delivery);\n\t}\n\n\tif (!s2)\n\t\treturn;\n\n\t \n\tsmp_rmb();\n\twp = (s2->dlvry_queue_slot + 1) % HISI_SAS_QUEUE_SLOTS;\n\n\thisi_sas_write32(hisi_hba, DLVRY_Q_0_WR_PTR + (dlvry_queue * 0x14), wp);\n}\n\nstatic void prep_prd_sge_v2_hw(struct hisi_hba *hisi_hba,\n\t\t\t      struct hisi_sas_slot *slot,\n\t\t\t      struct hisi_sas_cmd_hdr *hdr,\n\t\t\t      struct scatterlist *scatter,\n\t\t\t      int n_elem)\n{\n\tstruct hisi_sas_sge_page *sge_page = hisi_sas_sge_addr_mem(slot);\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(scatter, sg, n_elem, i) {\n\t\tstruct hisi_sas_sge *entry = &sge_page->sge[i];\n\n\t\tentry->addr = cpu_to_le64(sg_dma_address(sg));\n\t\tentry->page_ctrl_0 = entry->page_ctrl_1 = 0;\n\t\tentry->data_len = cpu_to_le32(sg_dma_len(sg));\n\t\tentry->data_off = 0;\n\t}\n\n\thdr->prd_table_addr = cpu_to_le64(hisi_sas_sge_addr_dma(slot));\n\n\thdr->sg_len = cpu_to_le32(n_elem << CMD_HDR_DATA_SGL_LEN_OFF);\n}\n\nstatic void prep_smp_v2_hw(struct hisi_hba *hisi_hba,\n\t\t\t  struct hisi_sas_slot *slot)\n{\n\tstruct sas_task *task = slot->task;\n\tstruct hisi_sas_cmd_hdr *hdr = slot->cmd_hdr;\n\tstruct domain_device *device = task->dev;\n\tstruct hisi_sas_port *port = slot->port;\n\tstruct scatterlist *sg_req;\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tdma_addr_t req_dma_addr;\n\tunsigned int req_len;\n\n\t \n\tsg_req = &task->smp_task.smp_req;\n\treq_dma_addr = sg_dma_address(sg_req);\n\treq_len = sg_dma_len(&task->smp_task.smp_req);\n\n\t \n\t \n\thdr->dw0 = cpu_to_le32((port->id << CMD_HDR_PORT_OFF) |\n\t\t\t       (1 << CMD_HDR_PRIORITY_OFF) |  \n\t\t\t       (2 << CMD_HDR_CMD_OFF));  \n\n\t \n\thdr->dw1 = cpu_to_le32((sas_dev->device_id << CMD_HDR_DEV_ID_OFF) |\n\t\t\t       (1 << CMD_HDR_FRAME_TYPE_OFF) |\n\t\t\t       (DIR_NO_DATA << CMD_HDR_DIR_OFF));\n\n\t \n\thdr->dw2 = cpu_to_le32((((req_len - 4) / 4) << CMD_HDR_CFL_OFF) |\n\t\t\t       (HISI_SAS_MAX_SMP_RESP_SZ / 4 <<\n\t\t\t       CMD_HDR_MRFL_OFF));\n\n\thdr->transfer_tags = cpu_to_le32(slot->idx << CMD_HDR_IPTT_OFF);\n\n\thdr->cmd_table_addr = cpu_to_le64(req_dma_addr);\n\thdr->sts_buffer_addr = cpu_to_le64(hisi_sas_status_buf_addr_dma(slot));\n}\n\nstatic void prep_ssp_v2_hw(struct hisi_hba *hisi_hba,\n\t\t\t  struct hisi_sas_slot *slot)\n{\n\tstruct sas_task *task = slot->task;\n\tstruct hisi_sas_cmd_hdr *hdr = slot->cmd_hdr;\n\tstruct domain_device *device = task->dev;\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tstruct hisi_sas_port *port = slot->port;\n\tstruct sas_ssp_task *ssp_task = &task->ssp_task;\n\tstruct scsi_cmnd *scsi_cmnd = ssp_task->cmd;\n\tstruct sas_tmf_task *tmf = slot->tmf;\n\tint has_data = 0, priority = !!tmf;\n\tu8 *buf_cmd;\n\tu32 dw1 = 0, dw2 = 0;\n\n\thdr->dw0 = cpu_to_le32((1 << CMD_HDR_RESP_REPORT_OFF) |\n\t\t\t       (2 << CMD_HDR_TLR_CTRL_OFF) |\n\t\t\t       (port->id << CMD_HDR_PORT_OFF) |\n\t\t\t       (priority << CMD_HDR_PRIORITY_OFF) |\n\t\t\t       (1 << CMD_HDR_CMD_OFF));  \n\n\tdw1 = 1 << CMD_HDR_VDTL_OFF;\n\tif (tmf) {\n\t\tdw1 |= 2 << CMD_HDR_FRAME_TYPE_OFF;\n\t\tdw1 |= DIR_NO_DATA << CMD_HDR_DIR_OFF;\n\t} else {\n\t\tdw1 |= 1 << CMD_HDR_FRAME_TYPE_OFF;\n\t\tswitch (scsi_cmnd->sc_data_direction) {\n\t\tcase DMA_TO_DEVICE:\n\t\t\thas_data = 1;\n\t\t\tdw1 |= DIR_TO_DEVICE << CMD_HDR_DIR_OFF;\n\t\t\tbreak;\n\t\tcase DMA_FROM_DEVICE:\n\t\t\thas_data = 1;\n\t\t\tdw1 |= DIR_TO_INI << CMD_HDR_DIR_OFF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdw1 &= ~CMD_HDR_DIR_MSK;\n\t\t}\n\t}\n\n\t \n\tdw1 |= sas_dev->device_id << CMD_HDR_DEV_ID_OFF;\n\thdr->dw1 = cpu_to_le32(dw1);\n\n\tdw2 = (((sizeof(struct ssp_command_iu) + sizeof(struct ssp_frame_hdr)\n\t      + 3) / 4) << CMD_HDR_CFL_OFF) |\n\t      ((HISI_SAS_MAX_SSP_RESP_SZ / 4) << CMD_HDR_MRFL_OFF) |\n\t      (2 << CMD_HDR_SG_MOD_OFF);\n\thdr->dw2 = cpu_to_le32(dw2);\n\n\thdr->transfer_tags = cpu_to_le32(slot->idx);\n\n\tif (has_data)\n\t\tprep_prd_sge_v2_hw(hisi_hba, slot, hdr, task->scatter,\n\t\t\t\t\tslot->n_elem);\n\n\thdr->data_transfer_len = cpu_to_le32(task->total_xfer_len);\n\thdr->cmd_table_addr = cpu_to_le64(hisi_sas_cmd_hdr_addr_dma(slot));\n\thdr->sts_buffer_addr = cpu_to_le64(hisi_sas_status_buf_addr_dma(slot));\n\n\tbuf_cmd = hisi_sas_cmd_hdr_addr_mem(slot) +\n\t\tsizeof(struct ssp_frame_hdr);\n\n\tmemcpy(buf_cmd, &task->ssp_task.LUN, 8);\n\tif (!tmf) {\n\t\tbuf_cmd[9] = task->ssp_task.task_attr;\n\t\tmemcpy(buf_cmd + 12, task->ssp_task.cmd->cmnd,\n\t\t\t\ttask->ssp_task.cmd->cmd_len);\n\t} else {\n\t\tbuf_cmd[10] = tmf->tmf;\n\t\tswitch (tmf->tmf) {\n\t\tcase TMF_ABORT_TASK:\n\t\tcase TMF_QUERY_TASK:\n\t\t\tbuf_cmd[12] =\n\t\t\t\t(tmf->tag_of_task_to_be_managed >> 8) & 0xff;\n\t\t\tbuf_cmd[13] =\n\t\t\t\ttmf->tag_of_task_to_be_managed & 0xff;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n#define TRANS_TX_ERR\t0\n#define TRANS_RX_ERR\t1\n#define DMA_TX_ERR\t\t2\n#define SIPC_RX_ERR\t\t3\n#define DMA_RX_ERR\t\t4\n\n#define DMA_TX_ERR_OFF\t0\n#define DMA_TX_ERR_MSK\t(0xffff << DMA_TX_ERR_OFF)\n#define SIPC_RX_ERR_OFF\t16\n#define SIPC_RX_ERR_MSK (0xffff << SIPC_RX_ERR_OFF)\n\nstatic int parse_trans_tx_err_code_v2_hw(u32 err_msk)\n{\n\tstatic const u8 trans_tx_err_code_prio[] = {\n\t\tTRANS_TX_OPEN_FAIL_WITH_IT_NEXUS_LOSS,\n\t\tTRANS_TX_ERR_PHY_NOT_ENABLE,\n\t\tTRANS_TX_OPEN_CNX_ERR_WRONG_DESTINATION,\n\t\tTRANS_TX_OPEN_CNX_ERR_ZONE_VIOLATION,\n\t\tTRANS_TX_OPEN_CNX_ERR_BY_OTHER,\n\t\tRESERVED0,\n\t\tTRANS_TX_OPEN_CNX_ERR_AIP_TIMEOUT,\n\t\tTRANS_TX_OPEN_CNX_ERR_STP_RESOURCES_BUSY,\n\t\tTRANS_TX_OPEN_CNX_ERR_PROTOCOL_NOT_SUPPORTED,\n\t\tTRANS_TX_OPEN_CNX_ERR_CONNECTION_RATE_NOT_SUPPORTED,\n\t\tTRANS_TX_OPEN_CNX_ERR_BAD_DESTINATION,\n\t\tTRANS_TX_OPEN_CNX_ERR_BREAK_RCVD,\n\t\tTRANS_TX_OPEN_CNX_ERR_LOW_PHY_POWER,\n\t\tTRANS_TX_OPEN_CNX_ERR_PATHWAY_BLOCKED,\n\t\tTRANS_TX_OPEN_CNX_ERR_OPEN_TIMEOUT,\n\t\tTRANS_TX_OPEN_CNX_ERR_NO_DESTINATION,\n\t\tTRANS_TX_OPEN_RETRY_ERR_THRESHOLD_REACHED,\n\t\tTRANS_TX_ERR_WITH_CLOSE_PHYDISALE,\n\t\tTRANS_TX_ERR_WITH_CLOSE_DWS_TIMEOUT,\n\t\tTRANS_TX_ERR_WITH_CLOSE_COMINIT,\n\t\tTRANS_TX_ERR_WITH_BREAK_TIMEOUT,\n\t\tTRANS_TX_ERR_WITH_BREAK_REQUEST,\n\t\tTRANS_TX_ERR_WITH_BREAK_RECEVIED,\n\t\tTRANS_TX_ERR_WITH_CLOSE_TIMEOUT,\n\t\tTRANS_TX_ERR_WITH_CLOSE_NORMAL,\n\t\tTRANS_TX_ERR_WITH_NAK_RECEVIED,\n\t\tTRANS_TX_ERR_WITH_ACK_NAK_TIMEOUT,\n\t\tTRANS_TX_ERR_WITH_CREDIT_TIMEOUT,\n\t\tTRANS_TX_ERR_WITH_IPTT_CONFLICT,\n\t\tTRANS_TX_ERR_WITH_OPEN_BY_DES_OR_OTHERS,\n\t\tTRANS_TX_ERR_WITH_WAIT_RECV_TIMEOUT,\n\t};\n\tint index, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(trans_tx_err_code_prio); i++) {\n\t\tindex = trans_tx_err_code_prio[i] - TRANS_TX_FAIL_BASE;\n\t\tif (err_msk & (1 << index))\n\t\t\treturn trans_tx_err_code_prio[i];\n\t}\n\treturn -1;\n}\n\nstatic int parse_trans_rx_err_code_v2_hw(u32 err_msk)\n{\n\tstatic const u8 trans_rx_err_code_prio[] = {\n\t\tTRANS_RX_ERR_WITH_RXFRAME_CRC_ERR,\n\t\tTRANS_RX_ERR_WITH_RXFIS_8B10B_DISP_ERR,\n\t\tTRANS_RX_ERR_WITH_RXFRAME_HAVE_ERRPRM,\n\t\tTRANS_RX_ERR_WITH_RXFIS_DECODE_ERROR,\n\t\tTRANS_RX_ERR_WITH_RXFIS_CRC_ERR,\n\t\tTRANS_RX_ERR_WITH_RXFRAME_LENGTH_OVERRUN,\n\t\tTRANS_RX_ERR_WITH_RXFIS_RX_SYNCP,\n\t\tTRANS_RX_ERR_WITH_LINK_BUF_OVERRUN,\n\t\tTRANS_RX_ERR_WITH_CLOSE_PHY_DISABLE,\n\t\tTRANS_RX_ERR_WITH_CLOSE_DWS_TIMEOUT,\n\t\tTRANS_RX_ERR_WITH_CLOSE_COMINIT,\n\t\tTRANS_RX_ERR_WITH_BREAK_TIMEOUT,\n\t\tTRANS_RX_ERR_WITH_BREAK_REQUEST,\n\t\tTRANS_RX_ERR_WITH_BREAK_RECEVIED,\n\t\tRESERVED1,\n\t\tTRANS_RX_ERR_WITH_CLOSE_NORMAL,\n\t\tTRANS_RX_ERR_WITH_DATA_LEN0,\n\t\tTRANS_RX_ERR_WITH_BAD_HASH,\n\t\tTRANS_RX_XRDY_WLEN_ZERO_ERR,\n\t\tTRANS_RX_SSP_FRM_LEN_ERR,\n\t\tRESERVED2,\n\t\tRESERVED3,\n\t\tRESERVED4,\n\t\tRESERVED5,\n\t\tTRANS_RX_ERR_WITH_BAD_FRM_TYPE,\n\t\tTRANS_RX_SMP_FRM_LEN_ERR,\n\t\tTRANS_RX_SMP_RESP_TIMEOUT_ERR,\n\t\tRESERVED6,\n\t\tRESERVED7,\n\t\tRESERVED8,\n\t\tRESERVED9,\n\t\tTRANS_RX_R_ERR,\n\t};\n\tint index, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(trans_rx_err_code_prio); i++) {\n\t\tindex = trans_rx_err_code_prio[i] - TRANS_RX_FAIL_BASE;\n\t\tif (err_msk & (1 << index))\n\t\t\treturn trans_rx_err_code_prio[i];\n\t}\n\treturn -1;\n}\n\nstatic int parse_dma_tx_err_code_v2_hw(u32 err_msk)\n{\n\tstatic const u8 dma_tx_err_code_prio[] = {\n\t\tDMA_TX_UNEXP_XFER_ERR,\n\t\tDMA_TX_UNEXP_RETRANS_ERR,\n\t\tDMA_TX_XFER_LEN_OVERFLOW,\n\t\tDMA_TX_XFER_OFFSET_ERR,\n\t\tDMA_TX_RAM_ECC_ERR,\n\t\tDMA_TX_DIF_LEN_ALIGN_ERR,\n\t\tDMA_TX_DIF_CRC_ERR,\n\t\tDMA_TX_DIF_APP_ERR,\n\t\tDMA_TX_DIF_RPP_ERR,\n\t\tDMA_TX_DATA_SGL_OVERFLOW,\n\t\tDMA_TX_DIF_SGL_OVERFLOW,\n\t};\n\tint index, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dma_tx_err_code_prio); i++) {\n\t\tindex = dma_tx_err_code_prio[i] - DMA_TX_ERR_BASE;\n\t\terr_msk = err_msk & DMA_TX_ERR_MSK;\n\t\tif (err_msk & (1 << index))\n\t\t\treturn dma_tx_err_code_prio[i];\n\t}\n\treturn -1;\n}\n\nstatic int parse_sipc_rx_err_code_v2_hw(u32 err_msk)\n{\n\tstatic const u8 sipc_rx_err_code_prio[] = {\n\t\tSIPC_RX_FIS_STATUS_ERR_BIT_VLD,\n\t\tSIPC_RX_PIO_WRSETUP_STATUS_DRQ_ERR,\n\t\tSIPC_RX_FIS_STATUS_BSY_BIT_ERR,\n\t\tSIPC_RX_WRSETUP_LEN_ODD_ERR,\n\t\tSIPC_RX_WRSETUP_LEN_ZERO_ERR,\n\t\tSIPC_RX_WRDATA_LEN_NOT_MATCH_ERR,\n\t\tSIPC_RX_NCQ_WRSETUP_OFFSET_ERR,\n\t\tSIPC_RX_NCQ_WRSETUP_AUTO_ACTIVE_ERR,\n\t\tSIPC_RX_SATA_UNEXP_FIS_ERR,\n\t\tSIPC_RX_WRSETUP_ESTATUS_ERR,\n\t\tSIPC_RX_DATA_UNDERFLOW_ERR,\n\t};\n\tint index, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sipc_rx_err_code_prio); i++) {\n\t\tindex = sipc_rx_err_code_prio[i] - SIPC_RX_ERR_BASE;\n\t\terr_msk = err_msk & SIPC_RX_ERR_MSK;\n\t\tif (err_msk & (1 << (index + 0x10)))\n\t\t\treturn sipc_rx_err_code_prio[i];\n\t}\n\treturn -1;\n}\n\nstatic int parse_dma_rx_err_code_v2_hw(u32 err_msk)\n{\n\tstatic const u8 dma_rx_err_code_prio[] = {\n\t\tDMA_RX_UNKNOWN_FRM_ERR,\n\t\tDMA_RX_DATA_LEN_OVERFLOW,\n\t\tDMA_RX_DATA_LEN_UNDERFLOW,\n\t\tDMA_RX_DATA_OFFSET_ERR,\n\t\tRESERVED10,\n\t\tDMA_RX_SATA_FRAME_TYPE_ERR,\n\t\tDMA_RX_RESP_BUF_OVERFLOW,\n\t\tDMA_RX_UNEXP_RETRANS_RESP_ERR,\n\t\tDMA_RX_UNEXP_NORM_RESP_ERR,\n\t\tDMA_RX_UNEXP_RDFRAME_ERR,\n\t\tDMA_RX_PIO_DATA_LEN_ERR,\n\t\tDMA_RX_RDSETUP_STATUS_ERR,\n\t\tDMA_RX_RDSETUP_STATUS_DRQ_ERR,\n\t\tDMA_RX_RDSETUP_STATUS_BSY_ERR,\n\t\tDMA_RX_RDSETUP_LEN_ODD_ERR,\n\t\tDMA_RX_RDSETUP_LEN_ZERO_ERR,\n\t\tDMA_RX_RDSETUP_LEN_OVER_ERR,\n\t\tDMA_RX_RDSETUP_OFFSET_ERR,\n\t\tDMA_RX_RDSETUP_ACTIVE_ERR,\n\t\tDMA_RX_RDSETUP_ESTATUS_ERR,\n\t\tDMA_RX_RAM_ECC_ERR,\n\t\tDMA_RX_DIF_CRC_ERR,\n\t\tDMA_RX_DIF_APP_ERR,\n\t\tDMA_RX_DIF_RPP_ERR,\n\t\tDMA_RX_DATA_SGL_OVERFLOW,\n\t\tDMA_RX_DIF_SGL_OVERFLOW,\n\t};\n\tint index, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dma_rx_err_code_prio); i++) {\n\t\tindex = dma_rx_err_code_prio[i] - DMA_RX_ERR_BASE;\n\t\tif (err_msk & (1 << index))\n\t\t\treturn dma_rx_err_code_prio[i];\n\t}\n\treturn -1;\n}\n\n \nstatic void slot_err_v2_hw(struct hisi_hba *hisi_hba,\n\t\t\t   struct sas_task *task,\n\t\t\t   struct hisi_sas_slot *slot,\n\t\t\t   int err_phase)\n{\n\tstruct task_status_struct *ts = &task->task_status;\n\tstruct hisi_sas_err_record_v2 *err_record =\n\t\t\thisi_sas_status_buf_addr_mem(slot);\n\tu32 trans_tx_fail_type = le32_to_cpu(err_record->trans_tx_fail_type);\n\tu32 trans_rx_fail_type = le32_to_cpu(err_record->trans_rx_fail_type);\n\tu16 dma_tx_err_type = le16_to_cpu(err_record->dma_tx_err_type);\n\tu16 sipc_rx_err_type = le16_to_cpu(err_record->sipc_rx_err_type);\n\tu32 dma_rx_err_type = le32_to_cpu(err_record->dma_rx_err_type);\n\tstruct hisi_sas_complete_v2_hdr *complete_queue =\n\t\t\thisi_hba->complete_hdr[slot->cmplt_queue];\n\tstruct hisi_sas_complete_v2_hdr *complete_hdr =\n\t\t\t&complete_queue[slot->cmplt_queue_slot];\n\tu32 dw0 = le32_to_cpu(complete_hdr->dw0);\n\tint error = -1;\n\n\tif (err_phase == 1) {\n\t\t \n\t\terror = parse_dma_tx_err_code_v2_hw(dma_tx_err_type);\n\t\tif (error == -1)\n\t\t\terror = parse_trans_tx_err_code_v2_hw(\n\t\t\t\t\ttrans_tx_fail_type);\n\t} else if (err_phase == 2) {\n\t\t \n\t\terror = parse_trans_rx_err_code_v2_hw(trans_rx_fail_type);\n\t\tif (error == -1) {\n\t\t\terror = parse_dma_rx_err_code_v2_hw(\n\t\t\t\t\tdma_rx_err_type);\n\t\t\tif (error == -1)\n\t\t\t\terror = parse_sipc_rx_err_code_v2_hw(\n\t\t\t\t\t\tsipc_rx_err_type);\n\t\t}\n\t}\n\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SSP:\n\t{\n\t\tswitch (error) {\n\t\tcase TRANS_TX_OPEN_CNX_ERR_NO_DESTINATION:\n\t\t{\n\t\t\tts->stat = SAS_OPEN_REJECT;\n\t\t\tts->open_rej_reason = SAS_OREJ_NO_DEST;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_OPEN_CNX_ERR_PROTOCOL_NOT_SUPPORTED:\n\t\t{\n\t\t\tts->stat = SAS_OPEN_REJECT;\n\t\t\tts->open_rej_reason = SAS_OREJ_EPROTO;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_OPEN_CNX_ERR_CONNECTION_RATE_NOT_SUPPORTED:\n\t\t{\n\t\t\tts->stat = SAS_OPEN_REJECT;\n\t\t\tts->open_rej_reason = SAS_OREJ_CONN_RATE;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_OPEN_CNX_ERR_BAD_DESTINATION:\n\t\t{\n\t\t\tts->stat = SAS_OPEN_REJECT;\n\t\t\tts->open_rej_reason = SAS_OREJ_BAD_DEST;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_OPEN_CNX_ERR_WRONG_DESTINATION:\n\t\t{\n\t\t\tts->stat = SAS_OPEN_REJECT;\n\t\t\tts->open_rej_reason = SAS_OREJ_WRONG_DEST;\n\t\t\tbreak;\n\t\t}\n\t\tcase DMA_RX_UNEXP_NORM_RESP_ERR:\n\t\tcase TRANS_TX_OPEN_CNX_ERR_ZONE_VIOLATION:\n\t\tcase DMA_RX_RESP_BUF_OVERFLOW:\n\t\t{\n\t\t\tts->stat = SAS_OPEN_REJECT;\n\t\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_OPEN_CNX_ERR_LOW_PHY_POWER:\n\t\t{\n\t\t\t \n\t\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\t\tbreak;\n\t\t}\n\t\tcase DMA_RX_DATA_LEN_OVERFLOW:\n\t\t{\n\t\t\tts->stat = SAS_DATA_OVERRUN;\n\t\t\tts->residual = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcase DMA_RX_DATA_LEN_UNDERFLOW:\n\t\t{\n\t\t\tts->residual = trans_tx_fail_type;\n\t\t\tts->stat = SAS_DATA_UNDERRUN;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_OPEN_FAIL_WITH_IT_NEXUS_LOSS:\n\t\tcase TRANS_TX_ERR_PHY_NOT_ENABLE:\n\t\tcase TRANS_TX_OPEN_CNX_ERR_BY_OTHER:\n\t\tcase TRANS_TX_OPEN_CNX_ERR_AIP_TIMEOUT:\n\t\tcase TRANS_TX_OPEN_CNX_ERR_BREAK_RCVD:\n\t\tcase TRANS_TX_OPEN_CNX_ERR_PATHWAY_BLOCKED:\n\t\tcase TRANS_TX_OPEN_CNX_ERR_OPEN_TIMEOUT:\n\t\tcase TRANS_TX_OPEN_RETRY_ERR_THRESHOLD_REACHED:\n\t\tcase TRANS_TX_ERR_WITH_BREAK_TIMEOUT:\n\t\tcase TRANS_TX_ERR_WITH_BREAK_REQUEST:\n\t\tcase TRANS_TX_ERR_WITH_BREAK_RECEVIED:\n\t\tcase TRANS_TX_ERR_WITH_CLOSE_TIMEOUT:\n\t\tcase TRANS_TX_ERR_WITH_CLOSE_NORMAL:\n\t\tcase TRANS_TX_ERR_WITH_CLOSE_PHYDISALE:\n\t\tcase TRANS_TX_ERR_WITH_CLOSE_DWS_TIMEOUT:\n\t\tcase TRANS_TX_ERR_WITH_CLOSE_COMINIT:\n\t\tcase TRANS_TX_ERR_WITH_NAK_RECEVIED:\n\t\tcase TRANS_TX_ERR_WITH_ACK_NAK_TIMEOUT:\n\t\tcase TRANS_TX_ERR_WITH_CREDIT_TIMEOUT:\n\t\tcase TRANS_TX_ERR_WITH_IPTT_CONFLICT:\n\t\tcase TRANS_RX_ERR_WITH_RXFRAME_CRC_ERR:\n\t\tcase TRANS_RX_ERR_WITH_RXFIS_8B10B_DISP_ERR:\n\t\tcase TRANS_RX_ERR_WITH_RXFRAME_HAVE_ERRPRM:\n\t\tcase TRANS_RX_ERR_WITH_LINK_BUF_OVERRUN:\n\t\tcase TRANS_RX_ERR_WITH_BREAK_TIMEOUT:\n\t\tcase TRANS_RX_ERR_WITH_BREAK_REQUEST:\n\t\tcase TRANS_RX_ERR_WITH_BREAK_RECEVIED:\n\t\tcase TRANS_RX_ERR_WITH_CLOSE_NORMAL:\n\t\tcase TRANS_RX_ERR_WITH_CLOSE_DWS_TIMEOUT:\n\t\tcase TRANS_RX_ERR_WITH_CLOSE_COMINIT:\n\t\tcase TRANS_TX_ERR_FRAME_TXED:\n\t\tcase TRANS_RX_ERR_WITH_CLOSE_PHY_DISABLE:\n\t\tcase TRANS_RX_ERR_WITH_DATA_LEN0:\n\t\tcase TRANS_RX_ERR_WITH_BAD_HASH:\n\t\tcase TRANS_RX_XRDY_WLEN_ZERO_ERR:\n\t\tcase TRANS_RX_SSP_FRM_LEN_ERR:\n\t\tcase TRANS_RX_ERR_WITH_BAD_FRM_TYPE:\n\t\tcase DMA_TX_DATA_SGL_OVERFLOW:\n\t\tcase DMA_TX_UNEXP_XFER_ERR:\n\t\tcase DMA_TX_UNEXP_RETRANS_ERR:\n\t\tcase DMA_TX_XFER_LEN_OVERFLOW:\n\t\tcase DMA_TX_XFER_OFFSET_ERR:\n\t\tcase SIPC_RX_DATA_UNDERFLOW_ERR:\n\t\tcase DMA_RX_DATA_SGL_OVERFLOW:\n\t\tcase DMA_RX_DATA_OFFSET_ERR:\n\t\tcase DMA_RX_RDSETUP_LEN_ODD_ERR:\n\t\tcase DMA_RX_RDSETUP_LEN_ZERO_ERR:\n\t\tcase DMA_RX_RDSETUP_LEN_OVER_ERR:\n\t\tcase DMA_RX_SATA_FRAME_TYPE_ERR:\n\t\tcase DMA_RX_UNKNOWN_FRM_ERR:\n\t\t{\n\t\t\t \n\t\t\tts->stat = SAS_QUEUE_FULL;\n\t\t\tslot->abort = 1;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t\tbreak;\n\tcase SAS_PROTOCOL_SMP:\n\t\tts->stat = SAS_SAM_STAT_CHECK_CONDITION;\n\t\tbreak;\n\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\tcase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:\n\t{\n\t\tswitch (error) {\n\t\tcase TRANS_TX_OPEN_CNX_ERR_NO_DESTINATION:\n\t\t{\n\t\t\tts->stat = SAS_OPEN_REJECT;\n\t\t\tts->open_rej_reason = SAS_OREJ_NO_DEST;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_OPEN_CNX_ERR_LOW_PHY_POWER:\n\t\t{\n\t\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_OPEN_CNX_ERR_PROTOCOL_NOT_SUPPORTED:\n\t\t{\n\t\t\tts->stat = SAS_OPEN_REJECT;\n\t\t\tts->open_rej_reason = SAS_OREJ_EPROTO;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_OPEN_CNX_ERR_CONNECTION_RATE_NOT_SUPPORTED:\n\t\t{\n\t\t\tts->stat = SAS_OPEN_REJECT;\n\t\t\tts->open_rej_reason = SAS_OREJ_CONN_RATE;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_OPEN_CNX_ERR_BAD_DESTINATION:\n\t\t{\n\t\t\tts->stat = SAS_OPEN_REJECT;\n\t\t\tts->open_rej_reason = SAS_OREJ_CONN_RATE;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_OPEN_CNX_ERR_WRONG_DESTINATION:\n\t\t{\n\t\t\tts->stat = SAS_OPEN_REJECT;\n\t\t\tts->open_rej_reason = SAS_OREJ_WRONG_DEST;\n\t\t\tbreak;\n\t\t}\n\t\tcase DMA_RX_RESP_BUF_OVERFLOW:\n\t\tcase DMA_RX_UNEXP_NORM_RESP_ERR:\n\t\tcase TRANS_TX_OPEN_CNX_ERR_ZONE_VIOLATION:\n\t\t{\n\t\t\tts->stat = SAS_OPEN_REJECT;\n\t\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t\tcase DMA_RX_DATA_LEN_OVERFLOW:\n\t\t{\n\t\t\tts->stat = SAS_DATA_OVERRUN;\n\t\t\tts->residual = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcase DMA_RX_DATA_LEN_UNDERFLOW:\n\t\t{\n\t\t\tts->residual = trans_tx_fail_type;\n\t\t\tts->stat = SAS_DATA_UNDERRUN;\n\t\t\tbreak;\n\t\t}\n\t\tcase TRANS_TX_OPEN_FAIL_WITH_IT_NEXUS_LOSS:\n\t\tcase TRANS_TX_ERR_PHY_NOT_ENABLE:\n\t\tcase TRANS_TX_OPEN_CNX_ERR_BY_OTHER:\n\t\tcase TRANS_TX_OPEN_CNX_ERR_AIP_TIMEOUT:\n\t\tcase TRANS_TX_OPEN_CNX_ERR_BREAK_RCVD:\n\t\tcase TRANS_TX_OPEN_CNX_ERR_PATHWAY_BLOCKED:\n\t\tcase TRANS_TX_OPEN_CNX_ERR_OPEN_TIMEOUT:\n\t\tcase TRANS_TX_OPEN_RETRY_ERR_THRESHOLD_REACHED:\n\t\tcase TRANS_TX_ERR_WITH_BREAK_TIMEOUT:\n\t\tcase TRANS_TX_ERR_WITH_BREAK_REQUEST:\n\t\tcase TRANS_TX_ERR_WITH_BREAK_RECEVIED:\n\t\tcase TRANS_TX_ERR_WITH_CLOSE_TIMEOUT:\n\t\tcase TRANS_TX_ERR_WITH_CLOSE_NORMAL:\n\t\tcase TRANS_TX_ERR_WITH_CLOSE_PHYDISALE:\n\t\tcase TRANS_TX_ERR_WITH_CLOSE_DWS_TIMEOUT:\n\t\tcase TRANS_TX_ERR_WITH_CLOSE_COMINIT:\n\t\tcase TRANS_TX_ERR_WITH_ACK_NAK_TIMEOUT:\n\t\tcase TRANS_TX_ERR_WITH_CREDIT_TIMEOUT:\n\t\tcase TRANS_TX_ERR_WITH_OPEN_BY_DES_OR_OTHERS:\n\t\tcase TRANS_TX_ERR_WITH_WAIT_RECV_TIMEOUT:\n\t\tcase TRANS_RX_ERR_WITH_RXFRAME_HAVE_ERRPRM:\n\t\tcase TRANS_RX_ERR_WITH_RXFIS_8B10B_DISP_ERR:\n\t\tcase TRANS_RX_ERR_WITH_RXFIS_DECODE_ERROR:\n\t\tcase TRANS_RX_ERR_WITH_RXFIS_CRC_ERR:\n\t\tcase TRANS_RX_ERR_WITH_RXFRAME_LENGTH_OVERRUN:\n\t\tcase TRANS_RX_ERR_WITH_RXFIS_RX_SYNCP:\n\t\tcase TRANS_RX_ERR_WITH_LINK_BUF_OVERRUN:\n\t\tcase TRANS_RX_ERR_WITH_BREAK_TIMEOUT:\n\t\tcase TRANS_RX_ERR_WITH_BREAK_REQUEST:\n\t\tcase TRANS_RX_ERR_WITH_BREAK_RECEVIED:\n\t\tcase TRANS_RX_ERR_WITH_CLOSE_NORMAL:\n\t\tcase TRANS_RX_ERR_WITH_CLOSE_PHY_DISABLE:\n\t\tcase TRANS_RX_ERR_WITH_CLOSE_DWS_TIMEOUT:\n\t\tcase TRANS_RX_ERR_WITH_CLOSE_COMINIT:\n\t\tcase TRANS_RX_ERR_WITH_DATA_LEN0:\n\t\tcase TRANS_RX_ERR_WITH_BAD_HASH:\n\t\tcase TRANS_RX_XRDY_WLEN_ZERO_ERR:\n\t\tcase TRANS_RX_ERR_WITH_BAD_FRM_TYPE:\n\t\tcase DMA_TX_DATA_SGL_OVERFLOW:\n\t\tcase DMA_TX_UNEXP_XFER_ERR:\n\t\tcase DMA_TX_UNEXP_RETRANS_ERR:\n\t\tcase DMA_TX_XFER_LEN_OVERFLOW:\n\t\tcase DMA_TX_XFER_OFFSET_ERR:\n\t\tcase SIPC_RX_FIS_STATUS_ERR_BIT_VLD:\n\t\tcase SIPC_RX_PIO_WRSETUP_STATUS_DRQ_ERR:\n\t\tcase SIPC_RX_FIS_STATUS_BSY_BIT_ERR:\n\t\tcase SIPC_RX_WRSETUP_LEN_ODD_ERR:\n\t\tcase SIPC_RX_WRSETUP_LEN_ZERO_ERR:\n\t\tcase SIPC_RX_WRDATA_LEN_NOT_MATCH_ERR:\n\t\tcase SIPC_RX_SATA_UNEXP_FIS_ERR:\n\t\tcase DMA_RX_DATA_SGL_OVERFLOW:\n\t\tcase DMA_RX_DATA_OFFSET_ERR:\n\t\tcase DMA_RX_SATA_FRAME_TYPE_ERR:\n\t\tcase DMA_RX_UNEXP_RDFRAME_ERR:\n\t\tcase DMA_RX_PIO_DATA_LEN_ERR:\n\t\tcase DMA_RX_RDSETUP_STATUS_ERR:\n\t\tcase DMA_RX_RDSETUP_STATUS_DRQ_ERR:\n\t\tcase DMA_RX_RDSETUP_STATUS_BSY_ERR:\n\t\tcase DMA_RX_RDSETUP_LEN_ODD_ERR:\n\t\tcase DMA_RX_RDSETUP_LEN_ZERO_ERR:\n\t\tcase DMA_RX_RDSETUP_LEN_OVER_ERR:\n\t\tcase DMA_RX_RDSETUP_OFFSET_ERR:\n\t\tcase DMA_RX_RDSETUP_ACTIVE_ERR:\n\t\tcase DMA_RX_RDSETUP_ESTATUS_ERR:\n\t\tcase DMA_RX_UNKNOWN_FRM_ERR:\n\t\tcase TRANS_RX_SSP_FRM_LEN_ERR:\n\t\tcase TRANS_TX_OPEN_CNX_ERR_STP_RESOURCES_BUSY:\n\t\t{\n\t\t\tslot->abort = 1;\n\t\t\tts->stat = SAS_PHY_DOWN;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t{\n\t\t\tts->stat = SAS_PROTO_RESPONSE;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tif (dw0 & CMPLT_HDR_RSPNS_XFRD_MSK)\n\t\t\thisi_sas_sata_done(task, slot);\n\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void slot_complete_v2_hw(struct hisi_hba *hisi_hba,\n\t\t\t\tstruct hisi_sas_slot *slot)\n{\n\tstruct sas_task *task = slot->task;\n\tstruct hisi_sas_device *sas_dev;\n\tstruct device *dev = hisi_hba->dev;\n\tstruct task_status_struct *ts;\n\tstruct domain_device *device;\n\tstruct sas_ha_struct *ha;\n\tstruct hisi_sas_complete_v2_hdr *complete_queue =\n\t\t\thisi_hba->complete_hdr[slot->cmplt_queue];\n\tstruct hisi_sas_complete_v2_hdr *complete_hdr =\n\t\t\t&complete_queue[slot->cmplt_queue_slot];\n\tunsigned long flags;\n\tbool is_internal = slot->is_internal;\n\tu32 dw0;\n\n\tif (unlikely(!task || !task->lldd_task || !task->dev))\n\t\treturn;\n\n\tts = &task->task_status;\n\tdevice = task->dev;\n\tha = device->port->ha;\n\tsas_dev = device->lldd_dev;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\ttask->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tmemset(ts, 0, sizeof(*ts));\n\tts->resp = SAS_TASK_COMPLETE;\n\n\tif (unlikely(!sas_dev)) {\n\t\tdev_dbg(dev, \"slot complete: port has no device\\n\");\n\t\tts->stat = SAS_PHY_DOWN;\n\t\tgoto out;\n\t}\n\n\t \n\tdw0 = le32_to_cpu(complete_hdr->dw0);\n\tswitch ((dw0 & CMPLT_HDR_ABORT_STAT_MSK) >>\n\t\tCMPLT_HDR_ABORT_STAT_OFF) {\n\tcase STAT_IO_ABORTED:\n\t\t \n\t\tts->stat = SAS_ABORTED_TASK;\n\t\tgoto out;\n\tcase STAT_IO_COMPLETE:\n\t\t \n\t\tts->stat = TMF_RESP_FUNC_SUCC;\n\t\tdel_timer_sync(&slot->internal_abort_timer);\n\t\tgoto out;\n\tcase STAT_IO_NO_DEVICE:\n\t\tts->stat = TMF_RESP_FUNC_COMPLETE;\n\t\tdel_timer_sync(&slot->internal_abort_timer);\n\t\tgoto out;\n\tcase STAT_IO_NOT_VALID:\n\t\t \n\t\tts->stat = TMF_RESP_FUNC_FAILED;\n\t\tdel_timer_sync(&slot->internal_abort_timer);\n\t\tgoto out;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((dw0 & CMPLT_HDR_ERX_MSK) && (!(dw0 & CMPLT_HDR_RSPNS_XFRD_MSK))) {\n\t\tu32 err_phase = (dw0 & CMPLT_HDR_ERR_PHASE_MSK)\n\t\t\t\t>> CMPLT_HDR_ERR_PHASE_OFF;\n\t\tu32 *error_info = hisi_sas_status_buf_addr_mem(slot);\n\n\t\t \n\t\tif (ERR_ON_TX_PHASE(err_phase))\n\t\t\tslot_err_v2_hw(hisi_hba, task, slot, 1);\n\t\telse if (ERR_ON_RX_PHASE(err_phase))\n\t\t\tslot_err_v2_hw(hisi_hba, task, slot, 2);\n\n\t\tif (ts->stat != SAS_DATA_UNDERRUN)\n\t\t\tdev_info(dev, \"erroneous completion iptt=%d task=%pK dev id=%d CQ hdr: 0x%x 0x%x 0x%x 0x%x Error info: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t\t slot->idx, task, sas_dev->device_id,\n\t\t\t\t complete_hdr->dw0, complete_hdr->dw1,\n\t\t\t\t complete_hdr->act, complete_hdr->dw3,\n\t\t\t\t error_info[0], error_info[1],\n\t\t\t\t error_info[2], error_info[3]);\n\n\t\tif (unlikely(slot->abort)) {\n\t\t\tif (dev_is_sata(device) && task->ata_task.use_ncq)\n\t\t\t\tsas_ata_device_link_abort(device, true);\n\t\t\telse\n\t\t\t\tsas_task_abort(task);\n\n\t\t\treturn;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SSP:\n\t{\n\t\tstruct hisi_sas_status_buffer *status_buffer =\n\t\t\t\thisi_sas_status_buf_addr_mem(slot);\n\t\tstruct ssp_response_iu *iu = (struct ssp_response_iu *)\n\t\t\t\t&status_buffer->iu[0];\n\n\t\tsas_ssp_task_response(dev, task, iu);\n\t\tbreak;\n\t}\n\tcase SAS_PROTOCOL_SMP:\n\t{\n\t\tstruct scatterlist *sg_resp = &task->smp_task.smp_resp;\n\t\tvoid *to = page_address(sg_page(sg_resp));\n\n\t\tts->stat = SAS_SAM_STAT_GOOD;\n\n\t\tmemcpy(to + sg_resp->offset,\n\t\t       hisi_sas_status_buf_addr_mem(slot) +\n\t\t       sizeof(struct hisi_sas_err_record),\n\t\t       sg_resp->length);\n\t\tbreak;\n\t}\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\tcase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:\n\t{\n\t\tts->stat = SAS_SAM_STAT_GOOD;\n\t\tif (dw0 & CMPLT_HDR_RSPNS_XFRD_MSK)\n\t\t\thisi_sas_sata_done(task, slot);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tts->stat = SAS_SAM_STAT_CHECK_CONDITION;\n\t\tbreak;\n\t}\n\n\tif (!slot->port->port_attached) {\n\t\tdev_warn(dev, \"slot complete: port %d has removed\\n\",\n\t\t\tslot->port->sas_port.id);\n\t\tts->stat = SAS_PHY_DOWN;\n\t}\n\nout:\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (task->task_state_flags & SAS_TASK_STATE_ABORTED) {\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\tdev_info(dev, \"slot complete: task(%pK) aborted\\n\", task);\n\t\treturn;\n\t}\n\ttask->task_state_flags |= SAS_TASK_STATE_DONE;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\thisi_sas_slot_task_free(hisi_hba, task, slot, true);\n\n\tif (!is_internal && (task->task_proto != SAS_PROTOCOL_SMP)) {\n\t\tspin_lock_irqsave(&device->done_lock, flags);\n\t\tif (test_bit(SAS_HA_FROZEN, &ha->state)) {\n\t\t\tspin_unlock_irqrestore(&device->done_lock, flags);\n\t\t\tdev_info(dev, \"slot complete: task(%pK) ignored\\n\",\n\t\t\t\t task);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore(&device->done_lock, flags);\n\t}\n\n\tif (task->task_done)\n\t\ttask->task_done(task);\n}\n\nstatic void prep_ata_v2_hw(struct hisi_hba *hisi_hba,\n\t\t\t  struct hisi_sas_slot *slot)\n{\n\tstruct sas_task *task = slot->task;\n\tstruct domain_device *device = task->dev;\n\tstruct domain_device *parent_dev = device->parent;\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tstruct hisi_sas_cmd_hdr *hdr = slot->cmd_hdr;\n\tstruct asd_sas_port *sas_port = device->port;\n\tstruct hisi_sas_port *port = to_hisi_sas_port(sas_port);\n\tstruct sas_ata_task *ata_task = &task->ata_task;\n\tstruct sas_tmf_task *tmf = slot->tmf;\n\tu8 *buf_cmd;\n\tint has_data = 0, hdr_tag = 0;\n\tu32 dw0, dw1 = 0, dw2 = 0;\n\n\t \n\t \n\tdw0 = port->id << CMD_HDR_PORT_OFF;\n\tif (parent_dev && dev_is_expander(parent_dev->dev_type))\n\t\tdw0 |= 3 << CMD_HDR_CMD_OFF;\n\telse\n\t\tdw0 |= 4 << CMD_HDR_CMD_OFF;\n\n\tif (tmf && ata_task->force_phy) {\n\t\tdw0 |= CMD_HDR_FORCE_PHY_MSK;\n\t\tdw0 |= (1 << ata_task->force_phy_id) << CMD_HDR_PHY_ID_OFF;\n\t}\n\n\thdr->dw0 = cpu_to_le32(dw0);\n\n\t \n\tswitch (task->data_dir) {\n\tcase DMA_TO_DEVICE:\n\t\thas_data = 1;\n\t\tdw1 |= DIR_TO_DEVICE << CMD_HDR_DIR_OFF;\n\t\tbreak;\n\tcase DMA_FROM_DEVICE:\n\t\thas_data = 1;\n\t\tdw1 |= DIR_TO_INI << CMD_HDR_DIR_OFF;\n\t\tbreak;\n\tdefault:\n\t\tdw1 &= ~CMD_HDR_DIR_MSK;\n\t}\n\n\tif ((task->ata_task.fis.command == ATA_CMD_DEV_RESET) &&\n\t\t\t(task->ata_task.fis.control & ATA_SRST))\n\t\tdw1 |= 1 << CMD_HDR_RESET_OFF;\n\n\tdw1 |= (hisi_sas_get_ata_protocol(\n\t\t&task->ata_task.fis, task->data_dir))\n\t\t<< CMD_HDR_FRAME_TYPE_OFF;\n\tdw1 |= sas_dev->device_id << CMD_HDR_DEV_ID_OFF;\n\thdr->dw1 = cpu_to_le32(dw1);\n\n\t \n\tif (task->ata_task.use_ncq) {\n\t\tstruct ata_queued_cmd *qc = task->uldd_task;\n\n\t\thdr_tag = qc->tag;\n\t\ttask->ata_task.fis.sector_count |= (u8) (hdr_tag << 3);\n\t\tdw2 |= hdr_tag << CMD_HDR_NCQ_TAG_OFF;\n\t}\n\n\tdw2 |= (HISI_SAS_MAX_STP_RESP_SZ / 4) << CMD_HDR_CFL_OFF |\n\t\t\t2 << CMD_HDR_SG_MOD_OFF;\n\thdr->dw2 = cpu_to_le32(dw2);\n\n\t \n\thdr->transfer_tags = cpu_to_le32(slot->idx);\n\n\tif (has_data)\n\t\tprep_prd_sge_v2_hw(hisi_hba, slot, hdr, task->scatter,\n\t\t\t\t\tslot->n_elem);\n\n\thdr->data_transfer_len = cpu_to_le32(task->total_xfer_len);\n\thdr->cmd_table_addr = cpu_to_le64(hisi_sas_cmd_hdr_addr_dma(slot));\n\thdr->sts_buffer_addr = cpu_to_le64(hisi_sas_status_buf_addr_dma(slot));\n\n\tbuf_cmd = hisi_sas_cmd_hdr_addr_mem(slot);\n\n\tif (likely(!task->ata_task.device_control_reg_update))\n\t\ttask->ata_task.fis.flags |= 0x80;  \n\t \n\tmemcpy(buf_cmd, &task->ata_task.fis, sizeof(struct host_to_dev_fis));\n}\n\nstatic void hisi_sas_internal_abort_quirk_timeout(struct timer_list *t)\n{\n\tstruct hisi_sas_slot *slot = from_timer(slot, t, internal_abort_timer);\n\tstruct hisi_sas_port *port = slot->port;\n\tstruct asd_sas_port *asd_sas_port;\n\tstruct asd_sas_phy *sas_phy;\n\n\tif (!port)\n\t\treturn;\n\n\tasd_sas_port = &port->sas_port;\n\n\t \n\tlist_for_each_entry(sas_phy, &asd_sas_port->phy_list, port_phy_el) {\n\t\tstruct hisi_sas_phy *phy = sas_phy->lldd_phy;\n\t\tstruct hisi_hba *hisi_hba = phy->hisi_hba;\n\t\tint phy_no = sas_phy->id;\n\t\tu32 link_dfx2;\n\n\t\tlink_dfx2 = hisi_sas_phy_read32(hisi_hba, phy_no, LINK_DFX2);\n\t\tif ((link_dfx2 == LINK_DFX2_RCVR_HOLD_STS_MSK) ||\n\t\t    (link_dfx2 & LINK_DFX2_SEND_HOLD_STS_MSK)) {\n\t\t\tu32 txid_auto;\n\n\t\t\ttxid_auto = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\t\t\tTXID_AUTO);\n\t\t\ttxid_auto |= TXID_AUTO_CTB_MSK;\n\t\t\thisi_sas_phy_write32(hisi_hba, phy_no, TXID_AUTO,\n\t\t\t\t\t     txid_auto);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void prep_abort_v2_hw(struct hisi_hba *hisi_hba,\n\t\t\t     struct hisi_sas_slot *slot)\n{\n\tstruct sas_task *task = slot->task;\n\tstruct sas_internal_abort_task *abort = &task->abort_task;\n\tstruct domain_device *dev = task->dev;\n\tstruct hisi_sas_cmd_hdr *hdr = slot->cmd_hdr;\n\tstruct hisi_sas_port *port = slot->port;\n\tstruct timer_list *timer = &slot->internal_abort_timer;\n\tstruct hisi_sas_device *sas_dev = dev->lldd_dev;\n\n\t \n\ttimer_setup(timer, hisi_sas_internal_abort_quirk_timeout, 0);\n\t \n\tmod_timer(timer, jiffies + msecs_to_jiffies(100));\n\n\t \n\thdr->dw0 = cpu_to_le32((5 << CMD_HDR_CMD_OFF) |  \n\t\t\t       (port->id << CMD_HDR_PORT_OFF) |\n\t\t\t       (dev_is_sata(dev) <<\n\t\t\t\tCMD_HDR_ABORT_DEVICE_TYPE_OFF) |\n\t\t\t       (abort->type << CMD_HDR_ABORT_FLAG_OFF));\n\n\t \n\thdr->dw1 = cpu_to_le32(sas_dev->device_id << CMD_HDR_DEV_ID_OFF);\n\n\t \n\thdr->dw7 = cpu_to_le32(abort->tag << CMD_HDR_ABORT_IPTT_OFF);\n\thdr->transfer_tags = cpu_to_le32(slot->idx);\n}\n\nstatic int phy_up_v2_hw(int phy_no, struct hisi_hba *hisi_hba)\n{\n\tint i, res = IRQ_HANDLED;\n\tu32 port_id, link_rate;\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tstruct device *dev = hisi_hba->dev;\n\tu32 *frame_rcvd = (u32 *)sas_phy->frame_rcvd;\n\tstruct sas_identify_frame *id = (struct sas_identify_frame *)frame_rcvd;\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHYCTRL_PHY_ENA_MSK, 1);\n\n\tif (is_sata_phy_v2_hw(hisi_hba, phy_no))\n\t\tgoto end;\n\n\tdel_timer(&phy->timer);\n\n\tif (phy_no == 8) {\n\t\tu32 port_state = hisi_sas_read32(hisi_hba, PORT_STATE);\n\n\t\tport_id = (port_state & PORT_STATE_PHY8_PORT_NUM_MSK) >>\n\t\t\t  PORT_STATE_PHY8_PORT_NUM_OFF;\n\t\tlink_rate = (port_state & PORT_STATE_PHY8_CONN_RATE_MSK) >>\n\t\t\t    PORT_STATE_PHY8_CONN_RATE_OFF;\n\t} else {\n\t\tport_id = hisi_sas_read32(hisi_hba, PHY_PORT_NUM_MA);\n\t\tport_id = (port_id >> (4 * phy_no)) & 0xf;\n\t\tlink_rate = hisi_sas_read32(hisi_hba, PHY_CONN_RATE);\n\t\tlink_rate = (link_rate >> (phy_no * 4)) & 0xf;\n\t}\n\n\tif (port_id == 0xf) {\n\t\tdev_err(dev, \"phyup: phy%d invalid portid\\n\", phy_no);\n\t\tres = IRQ_NONE;\n\t\tgoto end;\n\t}\n\n\tfor (i = 0; i < 6; i++) {\n\t\tu32 idaf = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\t       RX_IDAF_DWORD0 + (i * 4));\n\t\tframe_rcvd[i] = __swab32(idaf);\n\t}\n\n\tsas_phy->linkrate = link_rate;\n\tsas_phy->oob_mode = SAS_OOB_MODE;\n\tmemcpy(sas_phy->attached_sas_addr, &id->sas_addr, SAS_ADDR_SIZE);\n\tdev_info(dev, \"phyup: phy%d link_rate=%d\\n\", phy_no, link_rate);\n\tphy->port_id = port_id;\n\tphy->phy_type &= ~(PORT_TYPE_SAS | PORT_TYPE_SATA);\n\tphy->phy_type |= PORT_TYPE_SAS;\n\tphy->phy_attached = 1;\n\tphy->identify.device_type = id->dev_type;\n\tphy->frame_rcvd_size =\tsizeof(struct sas_identify_frame);\n\tif (phy->identify.device_type == SAS_END_DEVICE)\n\t\tphy->identify.target_port_protocols =\n\t\t\tSAS_PROTOCOL_SSP;\n\telse if (phy->identify.device_type != SAS_PHY_UNUSED) {\n\t\tphy->identify.target_port_protocols =\n\t\t\tSAS_PROTOCOL_SMP;\n\t\tif (!timer_pending(&hisi_hba->timer))\n\t\t\tset_link_timer_quirk(hisi_hba);\n\t}\n\thisi_sas_notify_phy_event(phy, HISI_PHYE_PHY_UP);\nend:\n\tif (phy->reset_completion)\n\t\tcomplete(phy->reset_completion);\n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0,\n\t\t\t     CHL_INT0_SL_PHY_ENABLE_MSK);\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHYCTRL_PHY_ENA_MSK, 0);\n\n\treturn res;\n}\n\nstatic bool check_any_wideports_v2_hw(struct hisi_hba *hisi_hba)\n{\n\tu32 port_state;\n\n\tport_state = hisi_sas_read32(hisi_hba, PORT_STATE);\n\tif (port_state & 0x1ff)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int phy_down_v2_hw(int phy_no, struct hisi_hba *hisi_hba)\n{\n\tu32 phy_state, sl_ctrl, txid_auto;\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tstruct hisi_sas_port *port = phy->port;\n\tstruct device *dev = hisi_hba->dev;\n\n\tdel_timer(&phy->timer);\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHYCTRL_NOT_RDY_MSK, 1);\n\n\tphy_state = hisi_sas_read32(hisi_hba, PHY_STATE);\n\tdev_info(dev, \"phydown: phy%d phy_state=0x%x\\n\", phy_no, phy_state);\n\thisi_sas_phy_down(hisi_hba, phy_no, (phy_state & 1 << phy_no) ? 1 : 0,\n\t\t\t  GFP_ATOMIC);\n\n\tsl_ctrl = hisi_sas_phy_read32(hisi_hba, phy_no, SL_CONTROL);\n\thisi_sas_phy_write32(hisi_hba, phy_no, SL_CONTROL,\n\t\t\t     sl_ctrl & ~SL_CONTROL_CTA_MSK);\n\tif (port && !get_wideport_bitmap_v2_hw(hisi_hba, port->id))\n\t\tif (!check_any_wideports_v2_hw(hisi_hba) &&\n\t\t\t\ttimer_pending(&hisi_hba->timer))\n\t\t\tdel_timer(&hisi_hba->timer);\n\n\ttxid_auto = hisi_sas_phy_read32(hisi_hba, phy_no, TXID_AUTO);\n\thisi_sas_phy_write32(hisi_hba, phy_no, TXID_AUTO,\n\t\t\t     txid_auto | TXID_AUTO_CT3_MSK);\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0, CHL_INT0_NOT_RDY_MSK);\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHYCTRL_NOT_RDY_MSK, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t int_phy_updown_v2_hw(int irq_no, void *p)\n{\n\tstruct hisi_hba *hisi_hba = p;\n\tu32 irq_msk;\n\tint phy_no = 0;\n\tirqreturn_t res = IRQ_NONE;\n\n\tirq_msk = (hisi_sas_read32(hisi_hba, HGC_INVLD_DQE_INFO)\n\t\t   >> HGC_INVLD_DQE_INFO_FB_CH0_OFF) & 0x1ff;\n\twhile (irq_msk) {\n\t\tif (irq_msk  & 1) {\n\t\t\tu32 reg_value = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\t    CHL_INT0);\n\n\t\t\tswitch (reg_value & (CHL_INT0_NOT_RDY_MSK |\n\t\t\t\t\tCHL_INT0_SL_PHY_ENABLE_MSK)) {\n\n\t\t\tcase CHL_INT0_SL_PHY_ENABLE_MSK:\n\t\t\t\t \n\t\t\t\tif (phy_up_v2_hw(phy_no, hisi_hba) ==\n\t\t\t\t    IRQ_HANDLED)\n\t\t\t\t\tres = IRQ_HANDLED;\n\t\t\t\tbreak;\n\n\t\t\tcase CHL_INT0_NOT_RDY_MSK:\n\t\t\t\t \n\t\t\t\tif (phy_down_v2_hw(phy_no, hisi_hba) ==\n\t\t\t\t    IRQ_HANDLED)\n\t\t\t\t\tres = IRQ_HANDLED;\n\t\t\t\tbreak;\n\n\t\t\tcase (CHL_INT0_NOT_RDY_MSK |\n\t\t\t\t\tCHL_INT0_SL_PHY_ENABLE_MSK):\n\t\t\t\treg_value = hisi_sas_read32(hisi_hba,\n\t\t\t\t\t\tPHY_STATE);\n\t\t\t\tif (reg_value & BIT(phy_no)) {\n\t\t\t\t\t \n\t\t\t\t\tif (phy_up_v2_hw(phy_no, hisi_hba) ==\n\t\t\t\t\t    IRQ_HANDLED)\n\t\t\t\t\t\tres = IRQ_HANDLED;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tif (phy_down_v2_hw(phy_no, hisi_hba) ==\n\t\t\t\t\t    IRQ_HANDLED)\n\t\t\t\t\t\tres = IRQ_HANDLED;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tirq_msk >>= 1;\n\t\tphy_no++;\n\t}\n\n\treturn res;\n}\n\nstatic void phy_bcast_v2_hw(int phy_no, struct hisi_hba *hisi_hba)\n{\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tu32 bcast_status;\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, SL_RX_BCAST_CHK_MSK, 1);\n\tbcast_status = hisi_sas_phy_read32(hisi_hba, phy_no, RX_PRIMS_STATUS);\n\tif (bcast_status & RX_BCAST_CHG_MSK)\n\t\thisi_sas_phy_bcast(phy);\n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0,\n\t\t\t     CHL_INT0_SL_RX_BCST_ACK_MSK);\n\thisi_sas_phy_write32(hisi_hba, phy_no, SL_RX_BCAST_CHK_MSK, 0);\n}\n\nstatic const struct hisi_sas_hw_error port_ecc_axi_error[] = {\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_TX_ECC_ERR_OFF),\n\t\t.msg = \"dmac_tx_ecc_bad_err\",\n\t},\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_RX_ECC_ERR_OFF),\n\t\t.msg = \"dmac_rx_ecc_bad_err\",\n\t},\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_TX_AXI_WR_ERR_OFF),\n\t\t.msg = \"dma_tx_axi_wr_err\",\n\t},\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_TX_AXI_RD_ERR_OFF),\n\t\t.msg = \"dma_tx_axi_rd_err\",\n\t},\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_RX_AXI_WR_ERR_OFF),\n\t\t.msg = \"dma_rx_axi_wr_err\",\n\t},\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_RX_AXI_RD_ERR_OFF),\n\t\t.msg = \"dma_rx_axi_rd_err\",\n\t},\n};\n\nstatic irqreturn_t int_chnl_int_v2_hw(int irq_no, void *p)\n{\n\tstruct hisi_hba *hisi_hba = p;\n\tstruct device *dev = hisi_hba->dev;\n\tu32 ent_msk, ent_tmp, irq_msk;\n\tint phy_no = 0;\n\n\tent_msk = hisi_sas_read32(hisi_hba, ENT_INT_SRC_MSK3);\n\tent_tmp = ent_msk;\n\tent_msk |= ENT_INT_SRC_MSK3_ENT95_MSK_MSK;\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK3, ent_msk);\n\n\tirq_msk = (hisi_sas_read32(hisi_hba, HGC_INVLD_DQE_INFO) >>\n\t\t\tHGC_INVLD_DQE_INFO_FB_CH3_OFF) & 0x1ff;\n\n\twhile (irq_msk) {\n\t\tu32 irq_value0 = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\t\t     CHL_INT0);\n\t\tu32 irq_value1 = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\t\t     CHL_INT1);\n\t\tu32 irq_value2 = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\t\t     CHL_INT2);\n\n\t\tif ((irq_msk & (1 << phy_no)) && irq_value1) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < ARRAY_SIZE(port_ecc_axi_error); i++) {\n\t\t\t\tconst struct hisi_sas_hw_error *error =\n\t\t\t\t\t\t&port_ecc_axi_error[i];\n\n\t\t\t\tif (!(irq_value1 & error->irq_msk))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdev_warn(dev, \"%s error (phy%d 0x%x) found!\\n\",\n\t\t\t\t\terror->msg, phy_no, irq_value1);\n\t\t\t\tqueue_work(hisi_hba->wq, &hisi_hba->rst_work);\n\t\t\t}\n\n\t\t\thisi_sas_phy_write32(hisi_hba, phy_no,\n\t\t\t\t\t     CHL_INT1, irq_value1);\n\t\t}\n\n\t\tif ((irq_msk & (1 << phy_no)) && irq_value2) {\n\t\t\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\n\t\t\tif (irq_value2 & BIT(CHL_INT2_SL_IDAF_TOUT_CONF_OFF)) {\n\t\t\t\tdev_warn(dev, \"phy%d identify timeout\\n\",\n\t\t\t\t\t phy_no);\n\t\t\t\thisi_sas_notify_phy_event(phy,\n\t\t\t\t\t\tHISI_PHYE_LINK_RESET);\n\t\t\t}\n\n\t\t\thisi_sas_phy_write32(hisi_hba, phy_no,\n\t\t\t\t\t\t CHL_INT2, irq_value2);\n\t\t}\n\n\t\tif ((irq_msk & (1 << phy_no)) && irq_value0) {\n\t\t\tif (irq_value0 & CHL_INT0_SL_RX_BCST_ACK_MSK)\n\t\t\t\tphy_bcast_v2_hw(phy_no, hisi_hba);\n\n\t\t\tif (irq_value0 & CHL_INT0_PHY_RDY_MSK)\n\t\t\t\thisi_sas_phy_oob_ready(hisi_hba, phy_no);\n\n\t\t\thisi_sas_phy_write32(hisi_hba, phy_no,\n\t\t\t\t\tCHL_INT0, irq_value0\n\t\t\t\t\t& (~CHL_INT0_HOTPLUG_TOUT_MSK)\n\t\t\t\t\t& (~CHL_INT0_SL_PHY_ENABLE_MSK)\n\t\t\t\t\t& (~CHL_INT0_NOT_RDY_MSK));\n\t\t}\n\t\tirq_msk &= ~(1 << phy_no);\n\t\tphy_no++;\n\t}\n\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK3, ent_tmp);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void\none_bit_ecc_error_process_v2_hw(struct hisi_hba *hisi_hba, u32 irq_value)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tconst struct hisi_sas_hw_error *ecc_error;\n\tu32 val;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(one_bit_ecc_errors); i++) {\n\t\tecc_error = &one_bit_ecc_errors[i];\n\t\tif (irq_value & ecc_error->irq_msk) {\n\t\t\tval = hisi_sas_read32(hisi_hba, ecc_error->reg);\n\t\t\tval &= ecc_error->msk;\n\t\t\tval >>= ecc_error->shift;\n\t\t\tdev_warn(dev, \"%s found: mem addr is 0x%08X\\n\",\n\t\t\t\t ecc_error->msg, val);\n\t\t}\n\t}\n}\n\nstatic void multi_bit_ecc_error_process_v2_hw(struct hisi_hba *hisi_hba,\n\t\tu32 irq_value)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tconst struct hisi_sas_hw_error *ecc_error;\n\tu32 val;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(multi_bit_ecc_errors); i++) {\n\t\tecc_error = &multi_bit_ecc_errors[i];\n\t\tif (irq_value & ecc_error->irq_msk) {\n\t\t\tval = hisi_sas_read32(hisi_hba, ecc_error->reg);\n\t\t\tval &= ecc_error->msk;\n\t\t\tval >>= ecc_error->shift;\n\t\t\tdev_err(dev, \"%s (0x%x) found: mem addr is 0x%08X\\n\",\n\t\t\t\tecc_error->msg, irq_value, val);\n\t\t\tqueue_work(hisi_hba->wq, &hisi_hba->rst_work);\n\t\t}\n\t}\n\n\treturn;\n}\n\nstatic irqreturn_t fatal_ecc_int_v2_hw(int irq_no, void *p)\n{\n\tstruct hisi_hba *hisi_hba = p;\n\tu32 irq_value, irq_msk;\n\n\tirq_msk = hisi_sas_read32(hisi_hba, SAS_ECC_INTR_MSK);\n\thisi_sas_write32(hisi_hba, SAS_ECC_INTR_MSK, irq_msk | 0xffffffff);\n\n\tirq_value = hisi_sas_read32(hisi_hba, SAS_ECC_INTR);\n\tif (irq_value) {\n\t\tone_bit_ecc_error_process_v2_hw(hisi_hba, irq_value);\n\t\tmulti_bit_ecc_error_process_v2_hw(hisi_hba, irq_value);\n\t}\n\n\thisi_sas_write32(hisi_hba, SAS_ECC_INTR, irq_value);\n\thisi_sas_write32(hisi_hba, SAS_ECC_INTR_MSK, irq_msk);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct hisi_sas_hw_error axi_error[] = {\n\t{ .msk = BIT(0), .msg = \"IOST_AXI_W_ERR\" },\n\t{ .msk = BIT(1), .msg = \"IOST_AXI_R_ERR\" },\n\t{ .msk = BIT(2), .msg = \"ITCT_AXI_W_ERR\" },\n\t{ .msk = BIT(3), .msg = \"ITCT_AXI_R_ERR\" },\n\t{ .msk = BIT(4), .msg = \"SATA_AXI_W_ERR\" },\n\t{ .msk = BIT(5), .msg = \"SATA_AXI_R_ERR\" },\n\t{ .msk = BIT(6), .msg = \"DQE_AXI_R_ERR\" },\n\t{ .msk = BIT(7), .msg = \"CQE_AXI_W_ERR\" },\n\t{}\n};\n\nstatic const struct hisi_sas_hw_error fifo_error[] = {\n\t{ .msk = BIT(8),  .msg = \"CQE_WINFO_FIFO\" },\n\t{ .msk = BIT(9),  .msg = \"CQE_MSG_FIFIO\" },\n\t{ .msk = BIT(10), .msg = \"GETDQE_FIFO\" },\n\t{ .msk = BIT(11), .msg = \"CMDP_FIFO\" },\n\t{ .msk = BIT(12), .msg = \"AWTCTRL_FIFO\" },\n\t{}\n};\n\nstatic const struct hisi_sas_hw_error fatal_axi_errors[] = {\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_WP_DEPTH_OFF),\n\t\t.msg = \"write pointer and depth\",\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_IPTT_SLOT_NOMATCH_OFF),\n\t\t.msg = \"iptt no match slot\",\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_RP_DEPTH_OFF),\n\t\t.msg = \"read pointer and depth\",\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_AXI_OFF),\n\t\t.reg = HGC_AXI_FIFO_ERR_INFO,\n\t\t.sub = axi_error,\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_FIFO_OFF),\n\t\t.reg = HGC_AXI_FIFO_ERR_INFO,\n\t\t.sub = fifo_error,\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_LM_OFF),\n\t\t.msg = \"LM add/fetch list\",\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_ABT_OFF),\n\t\t.msg = \"SAS_HGC_ABT fetch LM list\",\n\t},\n};\n\nstatic irqreturn_t fatal_axi_int_v2_hw(int irq_no, void *p)\n{\n\tstruct hisi_hba *hisi_hba = p;\n\tu32 irq_value, irq_msk, err_value;\n\tstruct device *dev = hisi_hba->dev;\n\tconst struct hisi_sas_hw_error *axi_error;\n\tint i;\n\n\tirq_msk = hisi_sas_read32(hisi_hba, ENT_INT_SRC_MSK3);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK3, irq_msk | 0xfffffffe);\n\n\tirq_value = hisi_sas_read32(hisi_hba, ENT_INT_SRC3);\n\n\tfor (i = 0; i < ARRAY_SIZE(fatal_axi_errors); i++) {\n\t\taxi_error = &fatal_axi_errors[i];\n\t\tif (!(irq_value & axi_error->irq_msk))\n\t\t\tcontinue;\n\n\t\thisi_sas_write32(hisi_hba, ENT_INT_SRC3,\n\t\t\t\t 1 << axi_error->shift);\n\t\tif (axi_error->sub) {\n\t\t\tconst struct hisi_sas_hw_error *sub = axi_error->sub;\n\n\t\t\terr_value = hisi_sas_read32(hisi_hba, axi_error->reg);\n\t\t\tfor (; sub->msk || sub->msg; sub++) {\n\t\t\t\tif (!(err_value & sub->msk))\n\t\t\t\t\tcontinue;\n\t\t\t\tdev_err(dev, \"%s (0x%x) found!\\n\",\n\t\t\t\t\tsub->msg, irq_value);\n\t\t\t\tqueue_work(hisi_hba->wq, &hisi_hba->rst_work);\n\t\t\t}\n\t\t} else {\n\t\t\tdev_err(dev, \"%s (0x%x) found!\\n\",\n\t\t\t\taxi_error->msg, irq_value);\n\t\t\tqueue_work(hisi_hba->wq, &hisi_hba->rst_work);\n\t\t}\n\t}\n\n\tif (irq_value & BIT(ENT_INT_SRC3_ITC_INT_OFF)) {\n\t\tu32 reg_val = hisi_sas_read32(hisi_hba, ITCT_CLR);\n\t\tu32 dev_id = reg_val & ITCT_DEV_MSK;\n\t\tstruct hisi_sas_device *sas_dev = &hisi_hba->devices[dev_id];\n\n\t\thisi_sas_write32(hisi_hba, ITCT_CLR, 0);\n\t\tdev_dbg(dev, \"clear ITCT ok\\n\");\n\t\tcomplete(sas_dev->completion);\n\t}\n\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC3, irq_value);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK3, irq_msk);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t  cq_thread_v2_hw(int irq_no, void *p)\n{\n\tstruct hisi_sas_cq *cq = p;\n\tstruct hisi_hba *hisi_hba = cq->hisi_hba;\n\tstruct hisi_sas_slot *slot;\n\tstruct hisi_sas_itct *itct;\n\tstruct hisi_sas_complete_v2_hdr *complete_queue;\n\tu32 rd_point = cq->rd_point, wr_point, dev_id;\n\tint queue = cq->id;\n\n\tif (unlikely(hisi_hba->reject_stp_links_msk))\n\t\tphys_try_accept_stp_links_v2_hw(hisi_hba);\n\n\tcomplete_queue = hisi_hba->complete_hdr[queue];\n\n\twr_point = hisi_sas_read32(hisi_hba, COMPL_Q_0_WR_PTR +\n\t\t\t\t   (0x14 * queue));\n\n\twhile (rd_point != wr_point) {\n\t\tstruct hisi_sas_complete_v2_hdr *complete_hdr;\n\t\tint iptt;\n\n\t\tcomplete_hdr = &complete_queue[rd_point];\n\n\t\t \n\t\tif (complete_hdr->act) {\n\t\t\tu32 act_tmp = le32_to_cpu(complete_hdr->act);\n\t\t\tint ncq_tag_count = ffs(act_tmp);\n\t\t\tu32 dw1 = le32_to_cpu(complete_hdr->dw1);\n\n\t\t\tdev_id = (dw1 & CMPLT_HDR_DEV_ID_MSK) >>\n\t\t\t\t CMPLT_HDR_DEV_ID_OFF;\n\t\t\titct = &hisi_hba->itct[dev_id];\n\n\t\t\t \n\t\t\twhile (ncq_tag_count) {\n\t\t\t\t__le64 *_ncq_tag = &itct->qw4_15[0], __ncq_tag;\n\t\t\t\tu64 ncq_tag;\n\n\t\t\t\tncq_tag_count--;\n\t\t\t\t__ncq_tag = _ncq_tag[ncq_tag_count / 5];\n\t\t\t\tncq_tag = le64_to_cpu(__ncq_tag);\n\t\t\t\tiptt = (ncq_tag >> (ncq_tag_count % 5) * 12) &\n\t\t\t\t       0xfff;\n\n\t\t\t\tslot = &hisi_hba->slot_info[iptt];\n\t\t\t\tslot->cmplt_queue_slot = rd_point;\n\t\t\t\tslot->cmplt_queue = queue;\n\t\t\t\tslot_complete_v2_hw(hisi_hba, slot);\n\n\t\t\t\tact_tmp &= ~(1 << ncq_tag_count);\n\t\t\t\tncq_tag_count = ffs(act_tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tu32 dw1 = le32_to_cpu(complete_hdr->dw1);\n\n\t\t\tiptt = dw1 & CMPLT_HDR_IPTT_MSK;\n\t\t\tslot = &hisi_hba->slot_info[iptt];\n\t\t\tslot->cmplt_queue_slot = rd_point;\n\t\t\tslot->cmplt_queue = queue;\n\t\t\tslot_complete_v2_hw(hisi_hba, slot);\n\t\t}\n\n\t\tif (++rd_point >= HISI_SAS_QUEUE_SLOTS)\n\t\t\trd_point = 0;\n\t}\n\n\t \n\tcq->rd_point = rd_point;\n\thisi_sas_write32(hisi_hba, COMPL_Q_0_RD_PTR + (0x14 * queue), rd_point);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cq_interrupt_v2_hw(int irq_no, void *p)\n{\n\tstruct hisi_sas_cq *cq = p;\n\tstruct hisi_hba *hisi_hba = cq->hisi_hba;\n\tint queue = cq->id;\n\n\thisi_sas_write32(hisi_hba, OQ_INT_SRC, 1 << queue);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t sata_int_v2_hw(int irq_no, void *p)\n{\n\tstruct hisi_sas_phy *phy = p;\n\tstruct hisi_hba *hisi_hba = phy->hisi_hba;\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tstruct device *dev = hisi_hba->dev;\n\tstruct\thisi_sas_initial_fis *initial_fis;\n\tstruct dev_to_host_fis *fis;\n\tu32 ent_tmp, ent_msk, ent_int, port_id, link_rate, hard_phy_linkrate;\n\tirqreturn_t res = IRQ_HANDLED;\n\tu8 attached_sas_addr[SAS_ADDR_SIZE] = {0};\n\tint phy_no, offset;\n\n\tdel_timer(&phy->timer);\n\n\tphy_no = sas_phy->id;\n\tinitial_fis = &hisi_hba->initial_fis[phy_no];\n\tfis = &initial_fis->fis;\n\n\toffset = 4 * (phy_no / 4);\n\tent_msk = hisi_sas_read32(hisi_hba, ENT_INT_SRC_MSK1 + offset);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK1 + offset,\n\t\t\t ent_msk | 1 << ((phy_no % 4) * 8));\n\n\tent_int = hisi_sas_read32(hisi_hba, ENT_INT_SRC1 + offset);\n\tent_tmp = ent_int & (1 << (ENT_INT_SRC1_D2H_FIS_CH1_OFF *\n\t\t\t     (phy_no % 4)));\n\tent_int >>= ENT_INT_SRC1_D2H_FIS_CH1_OFF * (phy_no % 4);\n\tif ((ent_int & ENT_INT_SRC1_D2H_FIS_CH0_MSK) == 0) {\n\t\tdev_warn(dev, \"sata int: phy%d did not receive FIS\\n\", phy_no);\n\t\tres = IRQ_NONE;\n\t\tgoto end;\n\t}\n\n\t \n\tif (fis->status & ATA_ERR) {\n\t\tdev_warn(dev, \"sata int: phy%d FIS status: 0x%x\\n\", phy_no,\n\t\t\t fis->status);\n\t\thisi_sas_notify_phy_event(phy, HISI_PHYE_LINK_RESET);\n\t\tres = IRQ_NONE;\n\t\tgoto end;\n\t}\n\n\tif (unlikely(phy_no == 8)) {\n\t\tu32 port_state = hisi_sas_read32(hisi_hba, PORT_STATE);\n\n\t\tport_id = (port_state & PORT_STATE_PHY8_PORT_NUM_MSK) >>\n\t\t\t  PORT_STATE_PHY8_PORT_NUM_OFF;\n\t\tlink_rate = (port_state & PORT_STATE_PHY8_CONN_RATE_MSK) >>\n\t\t\t    PORT_STATE_PHY8_CONN_RATE_OFF;\n\t} else {\n\t\tport_id = hisi_sas_read32(hisi_hba, PHY_PORT_NUM_MA);\n\t\tport_id = (port_id >> (4 * phy_no)) & 0xf;\n\t\tlink_rate = hisi_sas_read32(hisi_hba, PHY_CONN_RATE);\n\t\tlink_rate = (link_rate >> (phy_no * 4)) & 0xf;\n\t}\n\n\tif (port_id == 0xf) {\n\t\tdev_err(dev, \"sata int: phy%d invalid portid\\n\", phy_no);\n\t\tres = IRQ_NONE;\n\t\tgoto end;\n\t}\n\n\tsas_phy->linkrate = link_rate;\n\thard_phy_linkrate = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\t\tHARD_PHY_LINKRATE);\n\tphy->maximum_linkrate = hard_phy_linkrate & 0xf;\n\tphy->minimum_linkrate = (hard_phy_linkrate >> 4) & 0xf;\n\n\tsas_phy->oob_mode = SATA_OOB_MODE;\n\t \n\tattached_sas_addr[0] = 0x50;\n\tattached_sas_addr[6] = hisi_hba->shost->host_no;\n\tattached_sas_addr[7] = phy_no;\n\tmemcpy(sas_phy->attached_sas_addr, attached_sas_addr, SAS_ADDR_SIZE);\n\tmemcpy(sas_phy->frame_rcvd, fis, sizeof(struct dev_to_host_fis));\n\tdev_info(dev, \"sata int phyup: phy%d link_rate=%d\\n\", phy_no, link_rate);\n\tphy->phy_type &= ~(PORT_TYPE_SAS | PORT_TYPE_SATA);\n\tphy->port_id = port_id;\n\tphy->phy_type |= PORT_TYPE_SATA;\n\tphy->phy_attached = 1;\n\tphy->identify.device_type = SAS_SATA_DEV;\n\tphy->frame_rcvd_size = sizeof(struct dev_to_host_fis);\n\tphy->identify.target_port_protocols = SAS_PROTOCOL_SATA;\n\thisi_sas_notify_phy_event(phy, HISI_PHYE_PHY_UP);\n\n\tif (phy->reset_completion)\n\t\tcomplete(phy->reset_completion);\nend:\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC1 + offset, ent_tmp);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK1 + offset, ent_msk);\n\n\treturn res;\n}\n\nstatic irq_handler_t phy_interrupts[HISI_SAS_PHY_INT_NR] = {\n\tint_phy_updown_v2_hw,\n\tint_chnl_int_v2_hw,\n};\n\nstatic irq_handler_t fatal_interrupts[HISI_SAS_FATAL_INT_NR] = {\n\tfatal_ecc_int_v2_hw,\n\tfatal_axi_int_v2_hw\n};\n\n#define CQ0_IRQ_INDEX (96)\n\nstatic int hisi_sas_v2_interrupt_preinit(struct hisi_hba *hisi_hba)\n{\n\tstruct platform_device *pdev = hisi_hba->platform_dev;\n\tstruct Scsi_Host *shost = hisi_hba->shost;\n\tstruct irq_affinity desc = {\n\t\t.pre_vectors = CQ0_IRQ_INDEX,\n\t\t.post_vectors = 16,\n\t};\n\tint resv = desc.pre_vectors + desc.post_vectors, minvec = resv + 1, nvec;\n\n\tnvec = devm_platform_get_irqs_affinity(pdev, &desc, minvec, 128,\n\t\t\t\t\t       &hisi_hba->irq_map);\n\tif (nvec < 0)\n\t\treturn nvec;\n\n\tshost->nr_hw_queues = hisi_hba->cq_nvecs = nvec - resv;\n\n\treturn 0;\n}\n\n \nstatic int interrupt_init_v2_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct platform_device *pdev = hisi_hba->platform_dev;\n\tstruct device *dev = &pdev->dev;\n\tint irq, rc = 0;\n\tint i, phy_no, fatal_no, queue_no;\n\n\tfor (i = 0; i < HISI_SAS_PHY_INT_NR; i++) {\n\t\tirq = hisi_hba->irq_map[i + 1];  \n\t\trc = devm_request_irq(dev, irq, phy_interrupts[i], 0,\n\t\t\t\t      DRV_NAME \" phy\", hisi_hba);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"irq init: could not request phy interrupt %d, rc=%d\\n\",\n\t\t\t\tirq, rc);\n\t\t\trc = -ENOENT;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tfor (phy_no = 0; phy_no < hisi_hba->n_phy; phy_no++) {\n\t\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\n\t\tirq = hisi_hba->irq_map[phy_no + 72];\n\t\trc = devm_request_irq(dev, irq, sata_int_v2_hw, 0,\n\t\t\t\t      DRV_NAME \" sata\", phy);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"irq init: could not request sata interrupt %d, rc=%d\\n\",\n\t\t\t\tirq, rc);\n\t\t\trc = -ENOENT;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tfor (fatal_no = 0; fatal_no < HISI_SAS_FATAL_INT_NR; fatal_no++) {\n\t\tirq = hisi_hba->irq_map[fatal_no + 81];\n\t\trc = devm_request_irq(dev, irq, fatal_interrupts[fatal_no], 0,\n\t\t\t\t      DRV_NAME \" fatal\", hisi_hba);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"irq init: could not request fatal interrupt %d, rc=%d\\n\",\n\t\t\t\tirq, rc);\n\t\t\trc = -ENOENT;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tfor (queue_no = 0; queue_no < hisi_hba->cq_nvecs; queue_no++) {\n\t\tstruct hisi_sas_cq *cq = &hisi_hba->cq[queue_no];\n\n\t\tcq->irq_no = hisi_hba->irq_map[queue_no + 96];\n\t\trc = devm_request_threaded_irq(dev, cq->irq_no,\n\t\t\t\t\t       cq_interrupt_v2_hw,\n\t\t\t\t\t       cq_thread_v2_hw, IRQF_ONESHOT,\n\t\t\t\t\t       DRV_NAME \" cq\", cq);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"irq init: could not request cq interrupt %d, rc=%d\\n\",\n\t\t\t\t\tcq->irq_no, rc);\n\t\t\trc = -ENOENT;\n\t\t\tgoto err_out;\n\t\t}\n\t\tcq->irq_mask = irq_get_affinity_mask(cq->irq_no);\n\t}\nerr_out:\n\treturn rc;\n}\n\nstatic int hisi_sas_v2_init(struct hisi_hba *hisi_hba)\n{\n\tint rc;\n\n\tmemset(hisi_hba->sata_dev_bitmap, 0, sizeof(hisi_hba->sata_dev_bitmap));\n\n\trc = hw_init_v2_hw(hisi_hba);\n\tif (rc)\n\t\treturn rc;\n\n\trc = interrupt_init_v2_hw(hisi_hba);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic void interrupt_disable_v2_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct platform_device *pdev = hisi_hba->platform_dev;\n\tint i;\n\n\tfor (i = 0; i < hisi_hba->queue_count; i++)\n\t\thisi_sas_write32(hisi_hba, OQ0_INT_SRC_MSK + 0x4 * i, 0x1);\n\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK1, 0xffffffff);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK2, 0xffffffff);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK3, 0xffffffff);\n\thisi_sas_write32(hisi_hba, SAS_ECC_INTR_MSK, 0xffffffff);\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT1_MSK, 0xffffffff);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT2_MSK, 0xffffffff);\n\t}\n\n\tfor (i = 0; i < 128; i++)\n\t\tsynchronize_irq(platform_get_irq(pdev, i));\n}\n\n\nstatic u32 get_phys_state_v2_hw(struct hisi_hba *hisi_hba)\n{\n\treturn hisi_sas_read32(hisi_hba, PHY_STATE);\n}\n\nstatic int soft_reset_v2_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tint rc, cnt;\n\n\tinterrupt_disable_v2_hw(hisi_hba);\n\thisi_sas_write32(hisi_hba, DLVRY_QUEUE_ENABLE, 0x0);\n\n\thisi_sas_stop_phys(hisi_hba);\n\n\tmdelay(10);\n\n\thisi_sas_write32(hisi_hba, AXI_MASTER_CFG_BASE + AM_CTRL_GLOBAL, 0x1);\n\n\t \n\tcnt = 0;\n\twhile (1) {\n\t\tu32 status = hisi_sas_read32_relaxed(hisi_hba,\n\t\t\t\tAXI_MASTER_CFG_BASE + AM_CURR_TRANS_RETURN);\n\n\t\tif (status == 0x3)\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t\tif (cnt++ > 10) {\n\t\t\tdev_err(dev, \"wait axi bus state to idle timeout!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\thisi_sas_init_mem(hisi_hba);\n\n\trc = hw_init_v2_hw(hisi_hba);\n\tif (rc)\n\t\treturn rc;\n\n\tphys_reject_stp_links_v2_hw(hisi_hba);\n\n\treturn 0;\n}\n\nstatic int write_gpio_v2_hw(struct hisi_hba *hisi_hba, u8 reg_type,\n\t\t\tu8 reg_index, u8 reg_count, u8 *write_data)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tint phy_no, count;\n\n\tif (!hisi_hba->sgpio_regs)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (reg_type) {\n\tcase SAS_GPIO_REG_TX:\n\t\tcount = reg_count * 4;\n\t\tcount = min(count, hisi_hba->n_phy);\n\n\t\tfor (phy_no = 0; phy_no < count; phy_no++) {\n\t\t\t \n\t\t\tvoid __iomem  *reg_addr = hisi_hba->sgpio_regs +\n\t\t\t\t\treg_index * 4 + phy_no;\n\t\t\tint data_idx = phy_no + 3 - (phy_no % 4) * 2;\n\n\t\t\twriteb(write_data[data_idx], reg_addr);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"write gpio: unsupported or bad reg type %d\\n\",\n\t\t\treg_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void wait_cmds_complete_timeout_v2_hw(struct hisi_hba *hisi_hba,\n\t\t\t\t\t     int delay_ms, int timeout_ms)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tint entries, entries_old = 0, time;\n\n\tfor (time = 0; time < timeout_ms; time += delay_ms) {\n\t\tentries = hisi_sas_read32(hisi_hba, CQE_SEND_CNT);\n\t\tif (entries == entries_old)\n\t\t\tbreak;\n\n\t\tentries_old = entries;\n\t\tmsleep(delay_ms);\n\t}\n\n\tif (time >= timeout_ms) {\n\t\tdev_dbg(dev, \"Wait commands complete timeout!\\n\");\n\t\treturn;\n\t}\n\n\tdev_dbg(dev, \"wait commands complete %dms\\n\", time);\n\n}\n\nstatic struct attribute *host_v2_hw_attrs[] = {\n\t&dev_attr_phy_event_threshold.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(host_v2_hw);\n\nstatic void map_queues_v2_hw(struct Scsi_Host *shost)\n{\n\tstruct hisi_hba *hisi_hba = shost_priv(shost);\n\tstruct blk_mq_queue_map *qmap = &shost->tag_set.map[HCTX_TYPE_DEFAULT];\n\tconst struct cpumask *mask;\n\tunsigned int queue, cpu;\n\n\tfor (queue = 0; queue < qmap->nr_queues; queue++) {\n\t\tmask = irq_get_affinity_mask(hisi_hba->irq_map[96 + queue]);\n\t\tif (!mask)\n\t\t\tcontinue;\n\n\t\tfor_each_cpu(cpu, mask)\n\t\t\tqmap->mq_map[cpu] = qmap->queue_offset + queue;\n\t}\n}\n\nstatic const struct scsi_host_template sht_v2_hw = {\n\t.name\t\t\t= DRV_NAME,\n\t.proc_name\t\t= DRV_NAME,\n\t.module\t\t\t= THIS_MODULE,\n\t.queuecommand\t\t= sas_queuecommand,\n\t.dma_need_drain\t\t= ata_scsi_dma_need_drain,\n\t.target_alloc\t\t= sas_target_alloc,\n\t.slave_configure\t= hisi_sas_slave_configure,\n\t.scan_finished\t\t= hisi_sas_scan_finished,\n\t.scan_start\t\t= hisi_sas_scan_start,\n\t.change_queue_depth\t= sas_change_queue_depth,\n\t.bios_param\t\t= sas_bios_param,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= HISI_SAS_SGE_PAGE_CNT,\n\t.max_sectors\t\t= SCSI_DEFAULT_MAX_SECTORS,\n\t.eh_device_reset_handler = sas_eh_device_reset_handler,\n\t.eh_target_reset_handler = sas_eh_target_reset_handler,\n\t.slave_alloc\t\t= hisi_sas_slave_alloc,\n\t.target_destroy\t\t= sas_target_destroy,\n\t.ioctl\t\t\t= sas_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= sas_ioctl,\n#endif\n\t.shost_groups\t\t= host_v2_hw_groups,\n\t.host_reset\t\t= hisi_sas_host_reset,\n\t.map_queues\t\t= map_queues_v2_hw,\n\t.host_tagset\t\t= 1,\n};\n\nstatic const struct hisi_sas_hw hisi_sas_v2_hw = {\n\t.hw_init = hisi_sas_v2_init,\n\t.interrupt_preinit = hisi_sas_v2_interrupt_preinit,\n\t.setup_itct = setup_itct_v2_hw,\n\t.slot_index_alloc = slot_index_alloc_quirk_v2_hw,\n\t.alloc_dev = alloc_dev_quirk_v2_hw,\n\t.sl_notify_ssp = sl_notify_ssp_v2_hw,\n\t.get_wideport_bitmap = get_wideport_bitmap_v2_hw,\n\t.clear_itct = clear_itct_v2_hw,\n\t.free_device = free_device_v2_hw,\n\t.prep_smp = prep_smp_v2_hw,\n\t.prep_ssp = prep_ssp_v2_hw,\n\t.prep_stp = prep_ata_v2_hw,\n\t.prep_abort = prep_abort_v2_hw,\n\t.start_delivery = start_delivery_v2_hw,\n\t.phys_init = phys_init_v2_hw,\n\t.phy_start = start_phy_v2_hw,\n\t.phy_disable = disable_phy_v2_hw,\n\t.phy_hard_reset = phy_hard_reset_v2_hw,\n\t.get_events = phy_get_events_v2_hw,\n\t.phy_set_linkrate = phy_set_linkrate_v2_hw,\n\t.phy_get_max_linkrate = phy_get_max_linkrate_v2_hw,\n\t.complete_hdr_size = sizeof(struct hisi_sas_complete_v2_hdr),\n\t.soft_reset = soft_reset_v2_hw,\n\t.get_phys_state = get_phys_state_v2_hw,\n\t.write_gpio = write_gpio_v2_hw,\n\t.wait_cmds_complete_timeout = wait_cmds_complete_timeout_v2_hw,\n\t.sht = &sht_v2_hw,\n};\n\nstatic int hisi_sas_v2_probe(struct platform_device *pdev)\n{\n\treturn hisi_sas_probe(pdev, &hisi_sas_v2_hw);\n}\n\nstatic const struct of_device_id sas_v2_of_match[] = {\n\t{ .compatible = \"hisilicon,hip06-sas-v2\",},\n\t{ .compatible = \"hisilicon,hip07-sas-v2\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sas_v2_of_match);\n\nstatic const struct acpi_device_id sas_v2_acpi_match[] = {\n\t{ \"HISI0162\", 0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(acpi, sas_v2_acpi_match);\n\nstatic struct platform_driver hisi_sas_v2_driver = {\n\t.probe = hisi_sas_v2_probe,\n\t.remove_new = hisi_sas_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = sas_v2_of_match,\n\t\t.acpi_match_table = ACPI_PTR(sas_v2_acpi_match),\n\t},\n};\n\nmodule_platform_driver(hisi_sas_v2_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"John Garry <john.garry@huawei.com>\");\nMODULE_DESCRIPTION(\"HISILICON SAS controller v2 hw driver\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}