{
  "module_name": "hisi_sas_v3_hw.c",
  "hash_id": "c699d0975d26b3592f6ed77a0c74597300ad68c77e3b0186b775ead093f096e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/hisi_sas/hisi_sas_v3_hw.c",
  "human_readable_source": "\n \n\n#include <linux/sched/clock.h>\n#include \"hisi_sas.h\"\n#define DRV_NAME \"hisi_sas_v3_hw\"\n\n \n#define DLVRY_QUEUE_ENABLE\t\t0x0\n#define IOST_BASE_ADDR_LO\t\t0x8\n#define IOST_BASE_ADDR_HI\t\t0xc\n#define ITCT_BASE_ADDR_LO\t\t0x10\n#define ITCT_BASE_ADDR_HI\t\t0x14\n#define IO_BROKEN_MSG_ADDR_LO\t\t0x18\n#define IO_BROKEN_MSG_ADDR_HI\t\t0x1c\n#define PHY_CONTEXT\t\t\t0x20\n#define PHY_STATE\t\t\t0x24\n#define PHY_PORT_NUM_MA\t\t\t0x28\n#define PHY_CONN_RATE\t\t\t0x30\n#define ITCT_CLR\t\t\t0x44\n#define ITCT_CLR_EN_OFF\t\t\t16\n#define ITCT_CLR_EN_MSK\t\t\t(0x1 << ITCT_CLR_EN_OFF)\n#define ITCT_DEV_OFF\t\t\t0\n#define ITCT_DEV_MSK\t\t\t(0x7ff << ITCT_DEV_OFF)\n#define SAS_AXI_USER3\t\t\t0x50\n#define IO_SATA_BROKEN_MSG_ADDR_LO\t0x58\n#define IO_SATA_BROKEN_MSG_ADDR_HI\t0x5c\n#define SATA_INITI_D2H_STORE_ADDR_LO\t0x60\n#define SATA_INITI_D2H_STORE_ADDR_HI\t0x64\n#define CFG_MAX_TAG\t\t\t0x68\n#define TRANS_LOCK_ICT_TIME\t\t0X70\n#define HGC_SAS_TX_OPEN_FAIL_RETRY_CTRL\t0x84\n#define HGC_SAS_TXFAIL_RETRY_CTRL\t0x88\n#define HGC_GET_ITV_TIME\t\t0x90\n#define DEVICE_MSG_WORK_MODE\t\t0x94\n#define OPENA_WT_CONTI_TIME\t\t0x9c\n#define I_T_NEXUS_LOSS_TIME\t\t0xa0\n#define MAX_CON_TIME_LIMIT_TIME\t\t0xa4\n#define BUS_INACTIVE_LIMIT_TIME\t\t0xa8\n#define REJECT_TO_OPEN_LIMIT_TIME\t0xac\n#define CQ_INT_CONVERGE_EN\t\t0xb0\n#define CFG_AGING_TIME\t\t\t0xbc\n#define HGC_DFX_CFG2\t\t\t0xc0\n#define CFG_ABT_SET_QUERY_IPTT\t0xd4\n#define CFG_SET_ABORTED_IPTT_OFF\t0\n#define CFG_SET_ABORTED_IPTT_MSK\t(0xfff << CFG_SET_ABORTED_IPTT_OFF)\n#define CFG_SET_ABORTED_EN_OFF\t12\n#define CFG_ABT_SET_IPTT_DONE\t0xd8\n#define CFG_ABT_SET_IPTT_DONE_OFF\t0\n#define HGC_IOMB_PROC1_STATUS\t0x104\n#define HGC_LM_DFX_STATUS2\t\t0x128\n#define HGC_LM_DFX_STATUS2_IOSTLIST_OFF\t\t0\n#define HGC_LM_DFX_STATUS2_IOSTLIST_MSK\t(0xfff << \\\n\t\t\t\t\t HGC_LM_DFX_STATUS2_IOSTLIST_OFF)\n#define HGC_LM_DFX_STATUS2_ITCTLIST_OFF\t\t12\n#define HGC_LM_DFX_STATUS2_ITCTLIST_MSK\t(0x7ff << \\\n\t\t\t\t\t HGC_LM_DFX_STATUS2_ITCTLIST_OFF)\n#define HGC_CQE_ECC_ADDR\t\t0x13c\n#define HGC_CQE_ECC_1B_ADDR_OFF\t0\n#define HGC_CQE_ECC_1B_ADDR_MSK\t(0x3f << HGC_CQE_ECC_1B_ADDR_OFF)\n#define HGC_CQE_ECC_MB_ADDR_OFF\t8\n#define HGC_CQE_ECC_MB_ADDR_MSK (0x3f << HGC_CQE_ECC_MB_ADDR_OFF)\n#define HGC_IOST_ECC_ADDR\t\t0x140\n#define HGC_IOST_ECC_1B_ADDR_OFF\t0\n#define HGC_IOST_ECC_1B_ADDR_MSK\t(0x3ff << HGC_IOST_ECC_1B_ADDR_OFF)\n#define HGC_IOST_ECC_MB_ADDR_OFF\t16\n#define HGC_IOST_ECC_MB_ADDR_MSK\t(0x3ff << HGC_IOST_ECC_MB_ADDR_OFF)\n#define HGC_DQE_ECC_ADDR\t\t0x144\n#define HGC_DQE_ECC_1B_ADDR_OFF\t0\n#define HGC_DQE_ECC_1B_ADDR_MSK\t(0xfff << HGC_DQE_ECC_1B_ADDR_OFF)\n#define HGC_DQE_ECC_MB_ADDR_OFF\t16\n#define HGC_DQE_ECC_MB_ADDR_MSK (0xfff << HGC_DQE_ECC_MB_ADDR_OFF)\n#define CHNL_INT_STATUS\t\t\t0x148\n#define TAB_DFX\t\t\t\t0x14c\n#define HGC_ITCT_ECC_ADDR\t\t0x150\n#define HGC_ITCT_ECC_1B_ADDR_OFF\t\t0\n#define HGC_ITCT_ECC_1B_ADDR_MSK\t\t(0x3ff << \\\n\t\t\t\t\t\t HGC_ITCT_ECC_1B_ADDR_OFF)\n#define HGC_ITCT_ECC_MB_ADDR_OFF\t\t16\n#define HGC_ITCT_ECC_MB_ADDR_MSK\t\t(0x3ff << \\\n\t\t\t\t\t\t HGC_ITCT_ECC_MB_ADDR_OFF)\n#define HGC_AXI_FIFO_ERR_INFO  0x154\n#define AXI_ERR_INFO_OFF               0\n#define AXI_ERR_INFO_MSK               (0xff << AXI_ERR_INFO_OFF)\n#define FIFO_ERR_INFO_OFF              8\n#define FIFO_ERR_INFO_MSK              (0xff << FIFO_ERR_INFO_OFF)\n#define TAB_RD_TYPE\t\t\t0x15c\n#define INT_COAL_EN\t\t\t0x19c\n#define OQ_INT_COAL_TIME\t\t0x1a0\n#define OQ_INT_COAL_CNT\t\t\t0x1a4\n#define ENT_INT_COAL_TIME\t\t0x1a8\n#define ENT_INT_COAL_CNT\t\t0x1ac\n#define OQ_INT_SRC\t\t\t0x1b0\n#define OQ_INT_SRC_MSK\t\t\t0x1b4\n#define ENT_INT_SRC1\t\t\t0x1b8\n#define ENT_INT_SRC1_D2H_FIS_CH0_OFF\t0\n#define ENT_INT_SRC1_D2H_FIS_CH0_MSK\t(0x1 << ENT_INT_SRC1_D2H_FIS_CH0_OFF)\n#define ENT_INT_SRC1_D2H_FIS_CH1_OFF\t8\n#define ENT_INT_SRC1_D2H_FIS_CH1_MSK\t(0x1 << ENT_INT_SRC1_D2H_FIS_CH1_OFF)\n#define ENT_INT_SRC2\t\t\t0x1bc\n#define ENT_INT_SRC3\t\t\t0x1c0\n#define ENT_INT_SRC3_WP_DEPTH_OFF\t\t8\n#define ENT_INT_SRC3_IPTT_SLOT_NOMATCH_OFF\t9\n#define ENT_INT_SRC3_RP_DEPTH_OFF\t\t10\n#define ENT_INT_SRC3_AXI_OFF\t\t\t11\n#define ENT_INT_SRC3_FIFO_OFF\t\t\t12\n#define ENT_INT_SRC3_LM_OFF\t\t\t\t14\n#define ENT_INT_SRC3_ITC_INT_OFF\t15\n#define ENT_INT_SRC3_ITC_INT_MSK\t(0x1 << ENT_INT_SRC3_ITC_INT_OFF)\n#define ENT_INT_SRC3_ABT_OFF\t\t16\n#define ENT_INT_SRC3_DQE_POISON_OFF\t18\n#define ENT_INT_SRC3_IOST_POISON_OFF\t19\n#define ENT_INT_SRC3_ITCT_POISON_OFF\t20\n#define ENT_INT_SRC3_ITCT_NCQ_POISON_OFF\t21\n#define ENT_INT_SRC_MSK1\t\t0x1c4\n#define ENT_INT_SRC_MSK2\t\t0x1c8\n#define ENT_INT_SRC_MSK3\t\t0x1cc\n#define ENT_INT_SRC_MSK3_ENT95_MSK_OFF\t31\n#define CHNL_PHYUPDOWN_INT_MSK\t\t0x1d0\n#define CHNL_ENT_INT_MSK\t\t\t0x1d4\n#define HGC_COM_INT_MSK\t\t\t\t0x1d8\n#define ENT_INT_SRC_MSK3_ENT95_MSK_MSK\t(0x1 << ENT_INT_SRC_MSK3_ENT95_MSK_OFF)\n#define SAS_ECC_INTR\t\t\t0x1e8\n#define SAS_ECC_INTR_DQE_ECC_1B_OFF\t\t0\n#define SAS_ECC_INTR_DQE_ECC_MB_OFF\t\t1\n#define SAS_ECC_INTR_IOST_ECC_1B_OFF\t2\n#define SAS_ECC_INTR_IOST_ECC_MB_OFF\t3\n#define SAS_ECC_INTR_ITCT_ECC_1B_OFF\t4\n#define SAS_ECC_INTR_ITCT_ECC_MB_OFF\t5\n#define SAS_ECC_INTR_ITCTLIST_ECC_1B_OFF\t6\n#define SAS_ECC_INTR_ITCTLIST_ECC_MB_OFF\t7\n#define SAS_ECC_INTR_IOSTLIST_ECC_1B_OFF\t8\n#define SAS_ECC_INTR_IOSTLIST_ECC_MB_OFF\t9\n#define SAS_ECC_INTR_CQE_ECC_1B_OFF\t\t10\n#define SAS_ECC_INTR_CQE_ECC_MB_OFF\t\t11\n#define SAS_ECC_INTR_NCQ_MEM0_ECC_1B_OFF\t12\n#define SAS_ECC_INTR_NCQ_MEM0_ECC_MB_OFF\t13\n#define SAS_ECC_INTR_NCQ_MEM1_ECC_1B_OFF\t14\n#define SAS_ECC_INTR_NCQ_MEM1_ECC_MB_OFF\t15\n#define SAS_ECC_INTR_NCQ_MEM2_ECC_1B_OFF\t16\n#define SAS_ECC_INTR_NCQ_MEM2_ECC_MB_OFF\t17\n#define SAS_ECC_INTR_NCQ_MEM3_ECC_1B_OFF\t18\n#define SAS_ECC_INTR_NCQ_MEM3_ECC_MB_OFF\t19\n#define SAS_ECC_INTR_OOO_RAM_ECC_1B_OFF\t\t20\n#define SAS_ECC_INTR_OOO_RAM_ECC_MB_OFF\t\t21\n#define SAS_ECC_INTR_MSK\t\t0x1ec\n#define HGC_ERR_STAT_EN\t\t\t0x238\n#define CQE_SEND_CNT\t\t\t0x248\n#define DLVRY_Q_0_BASE_ADDR_LO\t\t0x260\n#define DLVRY_Q_0_BASE_ADDR_HI\t\t0x264\n#define DLVRY_Q_0_DEPTH\t\t\t0x268\n#define DLVRY_Q_0_WR_PTR\t\t0x26c\n#define DLVRY_Q_0_RD_PTR\t\t0x270\n#define HYPER_STREAM_ID_EN_CFG\t\t0xc80\n#define OQ0_INT_SRC_MSK\t\t\t0xc90\n#define COMPL_Q_0_BASE_ADDR_LO\t\t0x4e0\n#define COMPL_Q_0_BASE_ADDR_HI\t\t0x4e4\n#define COMPL_Q_0_DEPTH\t\t\t0x4e8\n#define COMPL_Q_0_WR_PTR\t\t0x4ec\n#define COMPL_Q_0_RD_PTR\t\t0x4f0\n#define HGC_RXM_DFX_STATUS14\t\t0xae8\n#define HGC_RXM_DFX_STATUS14_MEM0_OFF\t0\n#define HGC_RXM_DFX_STATUS14_MEM0_MSK\t(0x1ff << \\\n\t\t\t\t\t HGC_RXM_DFX_STATUS14_MEM0_OFF)\n#define HGC_RXM_DFX_STATUS14_MEM1_OFF\t9\n#define HGC_RXM_DFX_STATUS14_MEM1_MSK\t(0x1ff << \\\n\t\t\t\t\t HGC_RXM_DFX_STATUS14_MEM1_OFF)\n#define HGC_RXM_DFX_STATUS14_MEM2_OFF\t18\n#define HGC_RXM_DFX_STATUS14_MEM2_MSK\t(0x1ff << \\\n\t\t\t\t\t HGC_RXM_DFX_STATUS14_MEM2_OFF)\n#define HGC_RXM_DFX_STATUS15\t\t0xaec\n#define HGC_RXM_DFX_STATUS15_MEM3_OFF\t0\n#define HGC_RXM_DFX_STATUS15_MEM3_MSK\t(0x1ff << \\\n\t\t\t\t\t HGC_RXM_DFX_STATUS15_MEM3_OFF)\n#define AWQOS_AWCACHE_CFG\t0xc84\n#define ARQOS_ARCACHE_CFG\t0xc88\n#define HILINK_ERR_DFX\t\t0xe04\n#define SAS_GPIO_CFG_0\t\t0x1000\n#define SAS_GPIO_CFG_1\t\t0x1004\n#define SAS_GPIO_TX_0_1\t0x1040\n#define SAS_CFG_DRIVE_VLD\t0x1070\n\n \n#define PORT_BASE\t\t\t(0x2000)\n#define PHY_CFG\t\t\t\t(PORT_BASE + 0x0)\n#define HARD_PHY_LINKRATE\t\t(PORT_BASE + 0x4)\n#define PHY_CFG_ENA_OFF\t\t\t0\n#define PHY_CFG_ENA_MSK\t\t\t(0x1 << PHY_CFG_ENA_OFF)\n#define PHY_CFG_DC_OPT_OFF\t\t2\n#define PHY_CFG_DC_OPT_MSK\t\t(0x1 << PHY_CFG_DC_OPT_OFF)\n#define PHY_CFG_PHY_RST_OFF\t\t3\n#define PHY_CFG_PHY_RST_MSK\t\t(0x1 << PHY_CFG_PHY_RST_OFF)\n#define PROG_PHY_LINK_RATE\t\t(PORT_BASE + 0x8)\n#define CFG_PROG_PHY_LINK_RATE_OFF\t0\n#define CFG_PROG_PHY_LINK_RATE_MSK\t(0xff << CFG_PROG_PHY_LINK_RATE_OFF)\n#define CFG_PROG_OOB_PHY_LINK_RATE_OFF\t8\n#define CFG_PROG_OOB_PHY_LINK_RATE_MSK\t(0xf << CFG_PROG_OOB_PHY_LINK_RATE_OFF)\n#define PHY_CTRL\t\t\t(PORT_BASE + 0x14)\n#define PHY_CTRL_RESET_OFF\t\t0\n#define PHY_CTRL_RESET_MSK\t\t(0x1 << PHY_CTRL_RESET_OFF)\n#define CMD_HDR_PIR_OFF\t\t\t8\n#define CMD_HDR_PIR_MSK\t\t\t(0x1 << CMD_HDR_PIR_OFF)\n#define SERDES_CFG\t\t\t(PORT_BASE + 0x1c)\n#define CFG_ALOS_CHK_DISABLE_OFF\t9\n#define CFG_ALOS_CHK_DISABLE_MSK\t(0x1 << CFG_ALOS_CHK_DISABLE_OFF)\n#define SAS_PHY_BIST_CTRL\t\t(PORT_BASE + 0x2c)\n#define CFG_BIST_MODE_SEL_OFF\t\t0\n#define CFG_BIST_MODE_SEL_MSK\t\t(0xf << CFG_BIST_MODE_SEL_OFF)\n#define CFG_LOOP_TEST_MODE_OFF\t\t14\n#define CFG_LOOP_TEST_MODE_MSK\t\t(0x3 << CFG_LOOP_TEST_MODE_OFF)\n#define CFG_RX_BIST_EN_OFF\t\t16\n#define CFG_RX_BIST_EN_MSK\t\t(0x1 << CFG_RX_BIST_EN_OFF)\n#define CFG_TX_BIST_EN_OFF\t\t17\n#define CFG_TX_BIST_EN_MSK\t\t(0x1 << CFG_TX_BIST_EN_OFF)\n#define CFG_BIST_TEST_OFF\t\t18\n#define CFG_BIST_TEST_MSK\t\t(0x1 << CFG_BIST_TEST_OFF)\n#define SAS_PHY_BIST_CODE\t\t(PORT_BASE + 0x30)\n#define SAS_PHY_BIST_CODE1\t\t(PORT_BASE + 0x34)\n#define SAS_BIST_ERR_CNT\t\t(PORT_BASE + 0x38)\n#define SL_CFG\t\t\t\t(PORT_BASE + 0x84)\n#define AIP_LIMIT\t\t\t(PORT_BASE + 0x90)\n#define SL_CONTROL\t\t\t(PORT_BASE + 0x94)\n#define SL_CONTROL_NOTIFY_EN_OFF\t0\n#define SL_CONTROL_NOTIFY_EN_MSK\t(0x1 << SL_CONTROL_NOTIFY_EN_OFF)\n#define SL_CTA_OFF\t\t17\n#define SL_CTA_MSK\t\t(0x1 << SL_CTA_OFF)\n#define RX_PRIMS_STATUS\t\t\t(PORT_BASE + 0x98)\n#define RX_BCAST_CHG_OFF\t\t1\n#define RX_BCAST_CHG_MSK\t\t(0x1 << RX_BCAST_CHG_OFF)\n#define TX_ID_DWORD0\t\t\t(PORT_BASE + 0x9c)\n#define TX_ID_DWORD1\t\t\t(PORT_BASE + 0xa0)\n#define TX_ID_DWORD2\t\t\t(PORT_BASE + 0xa4)\n#define TX_ID_DWORD3\t\t\t(PORT_BASE + 0xa8)\n#define TX_ID_DWORD4\t\t\t(PORT_BASE + 0xaC)\n#define TX_ID_DWORD5\t\t\t(PORT_BASE + 0xb0)\n#define TX_ID_DWORD6\t\t\t(PORT_BASE + 0xb4)\n#define TXID_AUTO\t\t\t\t(PORT_BASE + 0xb8)\n#define CT3_OFF\t\t1\n#define CT3_MSK\t\t(0x1 << CT3_OFF)\n#define TX_HARDRST_OFF          2\n#define TX_HARDRST_MSK          (0x1 << TX_HARDRST_OFF)\n#define RX_IDAF_DWORD0\t\t\t(PORT_BASE + 0xc4)\n#define RXOP_CHECK_CFG_H\t\t(PORT_BASE + 0xfc)\n#define STP_LINK_TIMER\t\t\t(PORT_BASE + 0x120)\n#define STP_LINK_TIMEOUT_STATE\t\t(PORT_BASE + 0x124)\n#define CON_CFG_DRIVER\t\t\t(PORT_BASE + 0x130)\n#define SAS_SSP_CON_TIMER_CFG\t\t(PORT_BASE + 0x134)\n#define SAS_SMP_CON_TIMER_CFG\t\t(PORT_BASE + 0x138)\n#define SAS_STP_CON_TIMER_CFG\t\t(PORT_BASE + 0x13c)\n#define CHL_INT0\t\t\t(PORT_BASE + 0x1b4)\n#define CHL_INT0_HOTPLUG_TOUT_OFF\t0\n#define CHL_INT0_HOTPLUG_TOUT_MSK\t(0x1 << CHL_INT0_HOTPLUG_TOUT_OFF)\n#define CHL_INT0_SL_RX_BCST_ACK_OFF\t1\n#define CHL_INT0_SL_RX_BCST_ACK_MSK\t(0x1 << CHL_INT0_SL_RX_BCST_ACK_OFF)\n#define CHL_INT0_SL_PHY_ENABLE_OFF\t2\n#define CHL_INT0_SL_PHY_ENABLE_MSK\t(0x1 << CHL_INT0_SL_PHY_ENABLE_OFF)\n#define CHL_INT0_NOT_RDY_OFF\t\t4\n#define CHL_INT0_NOT_RDY_MSK\t\t(0x1 << CHL_INT0_NOT_RDY_OFF)\n#define CHL_INT0_PHY_RDY_OFF\t\t5\n#define CHL_INT0_PHY_RDY_MSK\t\t(0x1 << CHL_INT0_PHY_RDY_OFF)\n#define CHL_INT1\t\t\t(PORT_BASE + 0x1b8)\n#define CHL_INT1_DMAC_TX_ECC_MB_ERR_OFF\t15\n#define CHL_INT1_DMAC_TX_ECC_1B_ERR_OFF\t16\n#define CHL_INT1_DMAC_RX_ECC_MB_ERR_OFF\t17\n#define CHL_INT1_DMAC_RX_ECC_1B_ERR_OFF\t18\n#define CHL_INT1_DMAC_TX_AXI_WR_ERR_OFF\t19\n#define CHL_INT1_DMAC_TX_AXI_RD_ERR_OFF\t20\n#define CHL_INT1_DMAC_RX_AXI_WR_ERR_OFF\t21\n#define CHL_INT1_DMAC_RX_AXI_RD_ERR_OFF\t22\n#define CHL_INT1_DMAC_TX_FIFO_ERR_OFF\t23\n#define CHL_INT1_DMAC_RX_FIFO_ERR_OFF\t24\n#define CHL_INT1_DMAC_TX_AXI_RUSER_ERR_OFF\t26\n#define CHL_INT1_DMAC_RX_AXI_RUSER_ERR_OFF\t27\n#define CHL_INT2\t\t\t(PORT_BASE + 0x1bc)\n#define CHL_INT2_SL_IDAF_TOUT_CONF_OFF\t0\n#define CHL_INT2_RX_DISP_ERR_OFF\t28\n#define CHL_INT2_RX_CODE_ERR_OFF\t29\n#define CHL_INT2_RX_INVLD_DW_OFF\t30\n#define CHL_INT2_STP_LINK_TIMEOUT_OFF\t31\n#define CHL_INT0_MSK\t\t\t(PORT_BASE + 0x1c0)\n#define CHL_INT1_MSK\t\t\t(PORT_BASE + 0x1c4)\n#define CHL_INT2_MSK\t\t\t(PORT_BASE + 0x1c8)\n#define SAS_EC_INT_COAL_TIME\t\t(PORT_BASE + 0x1cc)\n#define CHL_INT_COAL_EN\t\t\t(PORT_BASE + 0x1d0)\n#define SAS_RX_TRAIN_TIMER\t\t(PORT_BASE + 0x2a4)\n#define PHY_CTRL_RDY_MSK\t\t(PORT_BASE + 0x2b0)\n#define PHYCTRL_NOT_RDY_MSK\t\t(PORT_BASE + 0x2b4)\n#define PHYCTRL_DWS_RESET_MSK\t\t(PORT_BASE + 0x2b8)\n#define PHYCTRL_PHY_ENA_MSK\t\t(PORT_BASE + 0x2bc)\n#define SL_RX_BCAST_CHK_MSK\t\t(PORT_BASE + 0x2c0)\n#define PHYCTRL_OOB_RESTART_MSK\t\t(PORT_BASE + 0x2c4)\n#define DMA_TX_STATUS\t\t\t(PORT_BASE + 0x2d0)\n#define DMA_TX_STATUS_BUSY_OFF\t\t0\n#define DMA_TX_STATUS_BUSY_MSK\t\t(0x1 << DMA_TX_STATUS_BUSY_OFF)\n#define DMA_RX_STATUS\t\t\t(PORT_BASE + 0x2e8)\n#define DMA_RX_STATUS_BUSY_OFF\t\t0\n#define DMA_RX_STATUS_BUSY_MSK\t\t(0x1 << DMA_RX_STATUS_BUSY_OFF)\n\n#define COARSETUNE_TIME\t\t\t(PORT_BASE + 0x304)\n#define TXDEEMPH_G1\t\t\t(PORT_BASE + 0x350)\n#define ERR_CNT_DWS_LOST\t\t(PORT_BASE + 0x380)\n#define ERR_CNT_RESET_PROB\t\t(PORT_BASE + 0x384)\n#define ERR_CNT_INVLD_DW\t\t(PORT_BASE + 0x390)\n#define ERR_CNT_CODE_ERR\t\t(PORT_BASE + 0x394)\n#define ERR_CNT_DISP_ERR\t\t(PORT_BASE + 0x398)\n#define DFX_FIFO_CTRL\t\t\t(PORT_BASE + 0x3a0)\n#define DFX_FIFO_CTRL_TRIGGER_MODE_OFF\t0\n#define DFX_FIFO_CTRL_TRIGGER_MODE_MSK\t(0x7 << DFX_FIFO_CTRL_TRIGGER_MODE_OFF)\n#define DFX_FIFO_CTRL_DUMP_MODE_OFF\t3\n#define DFX_FIFO_CTRL_DUMP_MODE_MSK\t(0x7 << DFX_FIFO_CTRL_DUMP_MODE_OFF)\n#define DFX_FIFO_CTRL_SIGNAL_SEL_OFF\t6\n#define DFX_FIFO_CTRL_SIGNAL_SEL_MSK\t(0xF << DFX_FIFO_CTRL_SIGNAL_SEL_OFF)\n#define DFX_FIFO_CTRL_DUMP_DISABLE_OFF\t10\n#define DFX_FIFO_CTRL_DUMP_DISABLE_MSK\t(0x1 << DFX_FIFO_CTRL_DUMP_DISABLE_OFF)\n#define DFX_FIFO_TRIGGER\t\t(PORT_BASE + 0x3a4)\n#define DFX_FIFO_TRIGGER_MSK\t\t(PORT_BASE + 0x3a8)\n#define DFX_FIFO_DUMP_MSK\t\t(PORT_BASE + 0x3aC)\n#define DFX_FIFO_RD_DATA\t\t(PORT_BASE + 0x3b0)\n\n#define DEFAULT_ITCT_HW\t\t2048  \n#if (HISI_SAS_MAX_DEVICES > DEFAULT_ITCT_HW)\n#error Max ITCT exceeded\n#endif\n\n#define AXI_MASTER_CFG_BASE\t\t(0x5000)\n#define AM_CTRL_GLOBAL\t\t\t(0x0)\n#define AM_CTRL_SHUTDOWN_REQ_OFF\t0\n#define AM_CTRL_SHUTDOWN_REQ_MSK\t(0x1 << AM_CTRL_SHUTDOWN_REQ_OFF)\n#define AM_CURR_TRANS_RETURN\t(0x150)\n\n#define AM_CFG_MAX_TRANS\t\t(0x5010)\n#define AM_CFG_SINGLE_PORT_MAX_TRANS\t(0x5014)\n#define AXI_CFG\t\t\t\t\t(0x5100)\n#define AM_ROB_ECC_ERR_ADDR\t\t(0x510c)\n#define AM_ROB_ECC_ERR_ADDR_OFF\t0\n#define AM_ROB_ECC_ERR_ADDR_MSK\t0xffffffff\n\n \n#define RAS_BASE\t\t(0x6000)\n#define SAS_RAS_INTR0\t\t\t(RAS_BASE)\n#define SAS_RAS_INTR1\t\t\t(RAS_BASE + 0x04)\n#define SAS_RAS_INTR0_MASK\t\t(RAS_BASE + 0x08)\n#define SAS_RAS_INTR1_MASK\t\t(RAS_BASE + 0x0c)\n#define CFG_SAS_RAS_INTR_MASK\t\t(RAS_BASE + 0x1c)\n#define SAS_RAS_INTR2\t\t\t(RAS_BASE + 0x20)\n#define SAS_RAS_INTR2_MASK\t\t(RAS_BASE + 0x24)\n\n \n \n \n#define CMD_HDR_ABORT_FLAG_OFF\t\t0\n#define CMD_HDR_ABORT_FLAG_MSK\t\t(0x3 << CMD_HDR_ABORT_FLAG_OFF)\n#define CMD_HDR_ABORT_DEVICE_TYPE_OFF\t2\n#define CMD_HDR_ABORT_DEVICE_TYPE_MSK\t(0x1 << CMD_HDR_ABORT_DEVICE_TYPE_OFF)\n#define CMD_HDR_RESP_REPORT_OFF\t\t5\n#define CMD_HDR_RESP_REPORT_MSK\t\t(0x1 << CMD_HDR_RESP_REPORT_OFF)\n#define CMD_HDR_TLR_CTRL_OFF\t\t6\n#define CMD_HDR_TLR_CTRL_MSK\t\t(0x3 << CMD_HDR_TLR_CTRL_OFF)\n#define CMD_HDR_PORT_OFF\t\t18\n#define CMD_HDR_PORT_MSK\t\t(0xf << CMD_HDR_PORT_OFF)\n#define CMD_HDR_PRIORITY_OFF\t\t27\n#define CMD_HDR_PRIORITY_MSK\t\t(0x1 << CMD_HDR_PRIORITY_OFF)\n#define CMD_HDR_CMD_OFF\t\t\t29\n#define CMD_HDR_CMD_MSK\t\t\t(0x7 << CMD_HDR_CMD_OFF)\n \n#define CMD_HDR_UNCON_CMD_OFF\t3\n#define CMD_HDR_DIR_OFF\t\t\t5\n#define CMD_HDR_DIR_MSK\t\t\t(0x3 << CMD_HDR_DIR_OFF)\n#define CMD_HDR_RESET_OFF\t\t7\n#define CMD_HDR_RESET_MSK\t\t(0x1 << CMD_HDR_RESET_OFF)\n#define CMD_HDR_VDTL_OFF\t\t10\n#define CMD_HDR_VDTL_MSK\t\t(0x1 << CMD_HDR_VDTL_OFF)\n#define CMD_HDR_FRAME_TYPE_OFF\t\t11\n#define CMD_HDR_FRAME_TYPE_MSK\t\t(0x1f << CMD_HDR_FRAME_TYPE_OFF)\n#define CMD_HDR_DEV_ID_OFF\t\t16\n#define CMD_HDR_DEV_ID_MSK\t\t(0xffff << CMD_HDR_DEV_ID_OFF)\n \n#define CMD_HDR_CFL_OFF\t\t\t0\n#define CMD_HDR_CFL_MSK\t\t\t(0x1ff << CMD_HDR_CFL_OFF)\n#define CMD_HDR_NCQ_TAG_OFF\t\t10\n#define CMD_HDR_NCQ_TAG_MSK\t\t(0x1f << CMD_HDR_NCQ_TAG_OFF)\n#define CMD_HDR_MRFL_OFF\t\t15\n#define CMD_HDR_MRFL_MSK\t\t(0x1ff << CMD_HDR_MRFL_OFF)\n#define CMD_HDR_SG_MOD_OFF\t\t24\n#define CMD_HDR_SG_MOD_MSK\t\t(0x3 << CMD_HDR_SG_MOD_OFF)\n \n#define CMD_HDR_IPTT_OFF\t\t0\n#define CMD_HDR_IPTT_MSK\t\t(0xffff << CMD_HDR_IPTT_OFF)\n \n#define CMD_HDR_DIF_SGL_LEN_OFF\t\t0\n#define CMD_HDR_DIF_SGL_LEN_MSK\t\t(0xffff << CMD_HDR_DIF_SGL_LEN_OFF)\n#define CMD_HDR_DATA_SGL_LEN_OFF\t16\n#define CMD_HDR_DATA_SGL_LEN_MSK\t(0xffff << CMD_HDR_DATA_SGL_LEN_OFF)\n \n#define CMD_HDR_ADDR_MODE_SEL_OFF\t\t15\n#define CMD_HDR_ADDR_MODE_SEL_MSK\t\t(1 << CMD_HDR_ADDR_MODE_SEL_OFF)\n#define CMD_HDR_ABORT_IPTT_OFF\t\t16\n#define CMD_HDR_ABORT_IPTT_MSK\t\t(0xffff << CMD_HDR_ABORT_IPTT_OFF)\n\n \n \n#define CMPLT_HDR_CMPLT_OFF\t\t0\n#define CMPLT_HDR_CMPLT_MSK\t\t(0x3 << CMPLT_HDR_CMPLT_OFF)\n#define CMPLT_HDR_ERROR_PHASE_OFF   2\n#define CMPLT_HDR_ERROR_PHASE_MSK   (0xff << CMPLT_HDR_ERROR_PHASE_OFF)\n \n#define ERR_PHASE_RESPONSE_FRAME_REV_STAGE_OFF\t\\\n\t\t\t\t\t8\n#define ERR_PHASE_RESPONSE_FRAME_REV_STAGE_MSK\t\\\n\t(0x1 << ERR_PHASE_RESPONSE_FRAME_REV_STAGE_OFF)\n#define CMPLT_HDR_RSPNS_XFRD_OFF\t10\n#define CMPLT_HDR_RSPNS_XFRD_MSK\t(0x1 << CMPLT_HDR_RSPNS_XFRD_OFF)\n#define CMPLT_HDR_RSPNS_GOOD_OFF\t11\n#define CMPLT_HDR_RSPNS_GOOD_MSK\t(0x1 << CMPLT_HDR_RSPNS_GOOD_OFF)\n#define CMPLT_HDR_ERX_OFF\t\t12\n#define CMPLT_HDR_ERX_MSK\t\t(0x1 << CMPLT_HDR_ERX_OFF)\n#define CMPLT_HDR_ABORT_STAT_OFF\t13\n#define CMPLT_HDR_ABORT_STAT_MSK\t(0x7 << CMPLT_HDR_ABORT_STAT_OFF)\n \n#define STAT_IO_NOT_VALID\t\t0x1\n#define STAT_IO_NO_DEVICE\t\t0x2\n#define STAT_IO_COMPLETE\t\t0x3\n#define STAT_IO_ABORTED\t\t\t0x4\n \n#define CMPLT_HDR_IPTT_OFF\t\t0\n#define CMPLT_HDR_IPTT_MSK\t\t(0xffff << CMPLT_HDR_IPTT_OFF)\n#define CMPLT_HDR_DEV_ID_OFF\t\t16\n#define CMPLT_HDR_DEV_ID_MSK\t\t(0xffff << CMPLT_HDR_DEV_ID_OFF)\n \n#define SATA_DISK_IN_ERROR_STATUS_OFF\t8\n#define SATA_DISK_IN_ERROR_STATUS_MSK\t(0x1 << SATA_DISK_IN_ERROR_STATUS_OFF)\n#define CMPLT_HDR_SATA_DISK_ERR_OFF\t16\n#define CMPLT_HDR_SATA_DISK_ERR_MSK\t(0x1 << CMPLT_HDR_SATA_DISK_ERR_OFF)\n#define CMPLT_HDR_IO_IN_TARGET_OFF\t17\n#define CMPLT_HDR_IO_IN_TARGET_MSK\t(0x1 << CMPLT_HDR_IO_IN_TARGET_OFF)\n \n#define FIS_ATA_STATUS_ERR_OFF\t\t18\n#define FIS_ATA_STATUS_ERR_MSK\t\t(0x1 << FIS_ATA_STATUS_ERR_OFF)\n#define FIS_TYPE_SDB_OFF\t\t31\n#define FIS_TYPE_SDB_MSK\t\t(0x1 << FIS_TYPE_SDB_OFF)\n\n \n \n#define ITCT_HDR_DEV_TYPE_OFF\t\t0\n#define ITCT_HDR_DEV_TYPE_MSK\t\t(0x3 << ITCT_HDR_DEV_TYPE_OFF)\n#define ITCT_HDR_VALID_OFF\t\t2\n#define ITCT_HDR_VALID_MSK\t\t(0x1 << ITCT_HDR_VALID_OFF)\n#define ITCT_HDR_MCR_OFF\t\t5\n#define ITCT_HDR_MCR_MSK\t\t(0xf << ITCT_HDR_MCR_OFF)\n#define ITCT_HDR_VLN_OFF\t\t9\n#define ITCT_HDR_VLN_MSK\t\t(0xf << ITCT_HDR_VLN_OFF)\n#define ITCT_HDR_SMP_TIMEOUT_OFF\t16\n#define ITCT_HDR_AWT_CONTINUE_OFF\t25\n#define ITCT_HDR_PORT_ID_OFF\t\t28\n#define ITCT_HDR_PORT_ID_MSK\t\t(0xf << ITCT_HDR_PORT_ID_OFF)\n \n#define ITCT_HDR_INLT_OFF\t\t0\n#define ITCT_HDR_INLT_MSK\t\t(0xffffULL << ITCT_HDR_INLT_OFF)\n#define ITCT_HDR_RTOLT_OFF\t\t48\n#define ITCT_HDR_RTOLT_MSK\t\t(0xffffULL << ITCT_HDR_RTOLT_OFF)\n\nstruct hisi_sas_protect_iu_v3_hw {\n\tu32 dw0;\n\tu32 lbrtcv;\n\tu32 lbrtgv;\n\tu32 dw3;\n\tu32 dw4;\n\tu32 dw5;\n\tu32 rsv;\n};\n\nstruct hisi_sas_complete_v3_hdr {\n\t__le32 dw0;\n\t__le32 dw1;\n\t__le32 act;\n\t__le32 dw3;\n};\n\nstruct hisi_sas_err_record_v3 {\n\t \n\t__le32 trans_tx_fail_type;\n\n\t \n\t__le32 trans_rx_fail_type;\n\n\t \n\t__le16 dma_tx_err_type;\n\t__le16 sipc_rx_err_type;\n\n\t \n\t__le32 dma_rx_err_type;\n};\n\n#define RX_DATA_LEN_UNDERFLOW_OFF\t6\n#define RX_DATA_LEN_UNDERFLOW_MSK\t(1 << RX_DATA_LEN_UNDERFLOW_OFF)\n\n#define RX_FIS_STATUS_ERR_OFF\t\t0\n#define RX_FIS_STATUS_ERR_MSK\t\t(1 << RX_FIS_STATUS_ERR_OFF)\n\n#define HISI_SAS_COMMAND_ENTRIES_V3_HW 4096\n#define HISI_SAS_MSI_COUNT_V3_HW 32\n\n#define DIR_NO_DATA 0\n#define DIR_TO_INI 1\n#define DIR_TO_DEVICE 2\n#define DIR_RESERVED 3\n\n#define FIS_CMD_IS_UNCONSTRAINED(fis) \\\n\t((fis.command == ATA_CMD_READ_LOG_EXT) || \\\n\t(fis.command == ATA_CMD_READ_LOG_DMA_EXT) || \\\n\t((fis.command == ATA_CMD_DEV_RESET) && \\\n\t((fis.control & ATA_SRST) != 0)))\n\n#define T10_INSRT_EN_OFF    0\n#define T10_INSRT_EN_MSK    (1 << T10_INSRT_EN_OFF)\n#define T10_RMV_EN_OFF\t    1\n#define T10_RMV_EN_MSK\t    (1 << T10_RMV_EN_OFF)\n#define T10_RPLC_EN_OFF\t    2\n#define T10_RPLC_EN_MSK\t    (1 << T10_RPLC_EN_OFF)\n#define T10_CHK_EN_OFF\t    3\n#define T10_CHK_EN_MSK\t    (1 << T10_CHK_EN_OFF)\n#define INCR_LBRT_OFF\t    5\n#define INCR_LBRT_MSK\t    (1 << INCR_LBRT_OFF)\n#define USR_DATA_BLOCK_SZ_OFF\t20\n#define USR_DATA_BLOCK_SZ_MSK\t(0x3 << USR_DATA_BLOCK_SZ_OFF)\n#define T10_CHK_MSK_OFF\t    16\n#define T10_CHK_REF_TAG_MSK (0xf0 << T10_CHK_MSK_OFF)\n#define T10_CHK_APP_TAG_MSK (0xc << T10_CHK_MSK_OFF)\n\n#define BASE_VECTORS_V3_HW  16\n#define MIN_AFFINE_VECTORS_V3_HW  (BASE_VECTORS_V3_HW + 1)\n\n#define CHNL_INT_STS_MSK\t0xeeeeeeee\n#define CHNL_INT_STS_PHY_MSK\t0xe\n#define CHNL_INT_STS_INT0_MSK BIT(1)\n#define CHNL_INT_STS_INT1_MSK BIT(2)\n#define CHNL_INT_STS_INT2_MSK BIT(3)\n#define CHNL_WIDTH 4\n\n#define BAR_NO_V3_HW\t5\n\nenum {\n\tDSM_FUNC_ERR_HANDLE_MSI = 0,\n};\n\nstatic bool hisi_sas_intr_conv;\nMODULE_PARM_DESC(intr_conv, \"interrupt converge enable (0-1)\");\n\n \nstatic int prot_mask;\nmodule_param(prot_mask, int, 0444);\nMODULE_PARM_DESC(prot_mask, \" host protection capabilities mask, def=0x0 \");\n\n \nstatic int experimental_iopoll_q_cnt;\nmodule_param(experimental_iopoll_q_cnt, int, 0444);\nMODULE_PARM_DESC(experimental_iopoll_q_cnt, \"number of queues to be used as poll mode, def=0\");\n\nstatic void debugfs_work_handler_v3_hw(struct work_struct *work);\nstatic void debugfs_snapshot_regs_v3_hw(struct hisi_hba *hisi_hba);\n\nstatic u32 hisi_sas_read32(struct hisi_hba *hisi_hba, u32 off)\n{\n\tvoid __iomem *regs = hisi_hba->regs + off;\n\n\treturn readl(regs);\n}\n\nstatic void hisi_sas_write32(struct hisi_hba *hisi_hba, u32 off, u32 val)\n{\n\tvoid __iomem *regs = hisi_hba->regs + off;\n\n\twritel(val, regs);\n}\n\nstatic void hisi_sas_phy_write32(struct hisi_hba *hisi_hba, int phy_no,\n\t\t\t\t u32 off, u32 val)\n{\n\tvoid __iomem *regs = hisi_hba->regs + (0x400 * phy_no) + off;\n\n\twritel(val, regs);\n}\n\nstatic u32 hisi_sas_phy_read32(struct hisi_hba *hisi_hba,\n\t\t\t\t      int phy_no, u32 off)\n{\n\tvoid __iomem *regs = hisi_hba->regs + (0x400 * phy_no) + off;\n\n\treturn readl(regs);\n}\n\n#define hisi_sas_read32_poll_timeout(off, val, cond, delay_us,\t\t\\\n\t\t\t\t     timeout_us)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tvoid __iomem *regs = hisi_hba->regs + off;\t\t\t\\\n\treadl_poll_timeout(regs, val, cond, delay_us, timeout_us);\t\\\n})\n\n#define hisi_sas_read32_poll_timeout_atomic(off, val, cond, delay_us,\t\\\n\t\t\t\t\t    timeout_us)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tvoid __iomem *regs = hisi_hba->regs + off;\t\t\t\\\n\treadl_poll_timeout_atomic(regs, val, cond, delay_us, timeout_us);\\\n})\n\nstatic void interrupt_enable_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tint i;\n\n\tfor (i = 0; i < hisi_hba->queue_count; i++)\n\t\thisi_sas_write32(hisi_hba, OQ0_INT_SRC_MSK + 0x4 * i, 0);\n\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK1, 0xfefefefe);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK2, 0xfefefefe);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK3, 0xffc220ff);\n\thisi_sas_write32(hisi_hba, SAS_ECC_INTR_MSK, 0x155555);\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT1_MSK, 0xf2057fff);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT2_MSK, 0xffffbfe);\n\t\thisi_sas_phy_write32(hisi_hba, i, PHYCTRL_NOT_RDY_MSK, 0x0);\n\t\thisi_sas_phy_write32(hisi_hba, i, PHYCTRL_PHY_ENA_MSK, 0x0);\n\t\thisi_sas_phy_write32(hisi_hba, i, SL_RX_BCAST_CHK_MSK, 0x0);\n\t}\n}\n\nstatic void init_reg_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct pci_dev *pdev = hisi_hba->pci_dev;\n\tint i, j;\n\n\t \n\thisi_sas_write32(hisi_hba, DLVRY_QUEUE_ENABLE,\n\t\t\t (u32)((1ULL << hisi_hba->queue_count) - 1));\n\thisi_sas_write32(hisi_hba, CFG_MAX_TAG, 0xfff0400);\n\t \n\thisi_sas_write32(hisi_hba, TRANS_LOCK_ICT_TIME, 0x4A817C80);\n\thisi_sas_write32(hisi_hba, HGC_SAS_TXFAIL_RETRY_CTRL, 0x108);\n\thisi_sas_write32(hisi_hba, CFG_AGING_TIME, 0x1);\n\thisi_sas_write32(hisi_hba, INT_COAL_EN, 0x1);\n\thisi_sas_write32(hisi_hba, OQ_INT_COAL_TIME, 0x1);\n\thisi_sas_write32(hisi_hba, OQ_INT_COAL_CNT, 0x1);\n\thisi_sas_write32(hisi_hba, CQ_INT_CONVERGE_EN,\n\t\t\t hisi_sas_intr_conv);\n\thisi_sas_write32(hisi_hba, OQ_INT_SRC, 0xffff);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC1, 0xffffffff);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC2, 0xffffffff);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC3, 0xffffffff);\n\thisi_sas_write32(hisi_hba, CHNL_PHYUPDOWN_INT_MSK, 0x0);\n\thisi_sas_write32(hisi_hba, CHNL_ENT_INT_MSK, 0x0);\n\thisi_sas_write32(hisi_hba, HGC_COM_INT_MSK, 0x0);\n\thisi_sas_write32(hisi_hba, AWQOS_AWCACHE_CFG, 0xf0f0);\n\thisi_sas_write32(hisi_hba, ARQOS_ARCACHE_CFG, 0xf0f0);\n\thisi_sas_write32(hisi_hba, HYPER_STREAM_ID_EN_CFG, 1);\n\n\tif (pdev->revision < 0x30)\n\t\thisi_sas_write32(hisi_hba, SAS_AXI_USER3, 0);\n\n\tinterrupt_enable_v3_hw(hisi_hba);\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\tenum sas_linkrate max;\n\t\tstruct hisi_sas_phy *phy = &hisi_hba->phy[i];\n\t\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\t\tu32 prog_phy_link_rate = hisi_sas_phy_read32(hisi_hba, i,\n\t\t\t\t\t\t\t   PROG_PHY_LINK_RATE);\n\n\t\tprog_phy_link_rate &= ~CFG_PROG_PHY_LINK_RATE_MSK;\n\t\tif (!sas_phy->phy || (sas_phy->phy->maximum_linkrate <\n\t\t\t\tSAS_LINK_RATE_1_5_GBPS))\n\t\t\tmax = SAS_LINK_RATE_12_0_GBPS;\n\t\telse\n\t\t\tmax = sas_phy->phy->maximum_linkrate;\n\t\tprog_phy_link_rate |= hisi_sas_get_prog_phy_linkrate_mask(max);\n\t\thisi_sas_phy_write32(hisi_hba, i, PROG_PHY_LINK_RATE,\n\t\t\tprog_phy_link_rate);\n\t\thisi_sas_phy_write32(hisi_hba, i, SAS_RX_TRAIN_TIMER, 0x13e80);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT0, 0xffffffff);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT1, 0xffffffff);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT2, 0xffffffff);\n\t\thisi_sas_phy_write32(hisi_hba, i, RXOP_CHECK_CFG_H, 0x1000);\n\t\thisi_sas_phy_write32(hisi_hba, i, PHY_CTRL_RDY_MSK, 0x0);\n\t\thisi_sas_phy_write32(hisi_hba, i, PHYCTRL_DWS_RESET_MSK, 0x0);\n\t\thisi_sas_phy_write32(hisi_hba, i, PHYCTRL_OOB_RESTART_MSK, 0x1);\n\t\thisi_sas_phy_write32(hisi_hba, i, STP_LINK_TIMER, 0x7f7a120);\n\t\thisi_sas_phy_write32(hisi_hba, i, CON_CFG_DRIVER, 0x2a0a01);\n\t\thisi_sas_phy_write32(hisi_hba, i, SAS_EC_INT_COAL_TIME,\n\t\t\t\t     0x30f4240);\n\t\thisi_sas_phy_write32(hisi_hba, i, AIP_LIMIT, 0x2ffff);\n\n\t\t \n\t\tif (pdev->revision < 0x30) {\n\t\t\thisi_sas_phy_write32(hisi_hba, i, SAS_SSP_CON_TIMER_CFG, 0x32);\n\t\t\thisi_sas_phy_write32(hisi_hba, i, SERDES_CFG, 0xffc00);\n\t\t\t \n\t\t\thisi_sas_phy_write32(hisi_hba, i, COARSETUNE_TIME, 0x1e);\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < FFE_CFG_MAX; j++) {\n\t\t\tu32 val = hisi_sas_phy_read32(hisi_hba, i,\n\t\t\t\t\t\t      TXDEEMPH_G1 + (j * 0x4));\n\t\t\thisi_hba->debugfs_bist_ffe[i][j] = val;\n\t\t}\n\t}\n\n\tfor (i = 0; i < hisi_hba->queue_count; i++) {\n\t\t \n\t\thisi_sas_write32(hisi_hba,\n\t\t\t\t DLVRY_Q_0_BASE_ADDR_HI + (i * 0x14),\n\t\t\t\t upper_32_bits(hisi_hba->cmd_hdr_dma[i]));\n\n\t\thisi_sas_write32(hisi_hba, DLVRY_Q_0_BASE_ADDR_LO + (i * 0x14),\n\t\t\t\t lower_32_bits(hisi_hba->cmd_hdr_dma[i]));\n\n\t\thisi_sas_write32(hisi_hba, DLVRY_Q_0_DEPTH + (i * 0x14),\n\t\t\t\t HISI_SAS_QUEUE_SLOTS);\n\n\t\t \n\t\thisi_sas_write32(hisi_hba, COMPL_Q_0_BASE_ADDR_HI + (i * 0x14),\n\t\t\t\t upper_32_bits(hisi_hba->complete_hdr_dma[i]));\n\n\t\thisi_sas_write32(hisi_hba, COMPL_Q_0_BASE_ADDR_LO + (i * 0x14),\n\t\t\t\t lower_32_bits(hisi_hba->complete_hdr_dma[i]));\n\n\t\thisi_sas_write32(hisi_hba, COMPL_Q_0_DEPTH + (i * 0x14),\n\t\t\t\t HISI_SAS_QUEUE_SLOTS);\n\t}\n\n\t \n\thisi_sas_write32(hisi_hba, ITCT_BASE_ADDR_LO,\n\t\t\t lower_32_bits(hisi_hba->itct_dma));\n\n\thisi_sas_write32(hisi_hba, ITCT_BASE_ADDR_HI,\n\t\t\t upper_32_bits(hisi_hba->itct_dma));\n\n\t \n\thisi_sas_write32(hisi_hba, IOST_BASE_ADDR_LO,\n\t\t\t lower_32_bits(hisi_hba->iost_dma));\n\n\thisi_sas_write32(hisi_hba, IOST_BASE_ADDR_HI,\n\t\t\t upper_32_bits(hisi_hba->iost_dma));\n\n\t \n\thisi_sas_write32(hisi_hba, IO_BROKEN_MSG_ADDR_LO,\n\t\t\t lower_32_bits(hisi_hba->breakpoint_dma));\n\n\thisi_sas_write32(hisi_hba, IO_BROKEN_MSG_ADDR_HI,\n\t\t\t upper_32_bits(hisi_hba->breakpoint_dma));\n\n\t \n\thisi_sas_write32(hisi_hba, IO_SATA_BROKEN_MSG_ADDR_LO,\n\t\t\t lower_32_bits(hisi_hba->sata_breakpoint_dma));\n\n\thisi_sas_write32(hisi_hba, IO_SATA_BROKEN_MSG_ADDR_HI,\n\t\t\t upper_32_bits(hisi_hba->sata_breakpoint_dma));\n\n\t \n\thisi_sas_write32(hisi_hba, SATA_INITI_D2H_STORE_ADDR_LO,\n\t\t\t lower_32_bits(hisi_hba->initial_fis_dma));\n\n\thisi_sas_write32(hisi_hba, SATA_INITI_D2H_STORE_ADDR_HI,\n\t\t\t upper_32_bits(hisi_hba->initial_fis_dma));\n\n\t \n\thisi_sas_write32(hisi_hba, SAS_RAS_INTR0_MASK, 0x0);\n\thisi_sas_write32(hisi_hba, SAS_RAS_INTR1_MASK, 0x0);\n\thisi_sas_write32(hisi_hba, SAS_RAS_INTR2_MASK, 0x0);\n\thisi_sas_write32(hisi_hba, CFG_SAS_RAS_INTR_MASK, 0x0);\n\n\t \n\thisi_sas_write32(hisi_hba, SAS_CFG_DRIVE_VLD, 0x80000ff);\n\thisi_sas_write32(hisi_hba, SAS_GPIO_TX_0_1, 0x80808080);\n\thisi_sas_write32(hisi_hba, SAS_GPIO_TX_0_1 + 0x4, 0x80808080);\n\t \n\thisi_sas_write32(hisi_hba, SAS_GPIO_CFG_1, 0x121700);\n\thisi_sas_write32(hisi_hba, SAS_GPIO_CFG_0, 0x800000);\n}\n\nstatic void config_phy_opt_mode_v3_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 cfg = hisi_sas_phy_read32(hisi_hba, phy_no, PHY_CFG);\n\n\tcfg &= ~PHY_CFG_DC_OPT_MSK;\n\tcfg |= 1 << PHY_CFG_DC_OPT_OFF;\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHY_CFG, cfg);\n}\n\nstatic void config_id_frame_v3_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tstruct sas_identify_frame identify_frame;\n\tu32 *identify_buffer;\n\n\tmemset(&identify_frame, 0, sizeof(identify_frame));\n\tidentify_frame.dev_type = SAS_END_DEVICE;\n\tidentify_frame.frame_type = 0;\n\tidentify_frame._un1 = 1;\n\tidentify_frame.initiator_bits = SAS_PROTOCOL_ALL;\n\tidentify_frame.target_bits = SAS_PROTOCOL_NONE;\n\tmemcpy(&identify_frame._un4_11[0], hisi_hba->sas_addr, SAS_ADDR_SIZE);\n\tmemcpy(&identify_frame.sas_addr[0], hisi_hba->sas_addr,\tSAS_ADDR_SIZE);\n\tidentify_frame.phy_id = phy_no;\n\tidentify_buffer = (u32 *)(&identify_frame);\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD0,\n\t\t\t__swab32(identify_buffer[0]));\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD1,\n\t\t\t__swab32(identify_buffer[1]));\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD2,\n\t\t\t__swab32(identify_buffer[2]));\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD3,\n\t\t\t__swab32(identify_buffer[3]));\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD4,\n\t\t\t__swab32(identify_buffer[4]));\n\thisi_sas_phy_write32(hisi_hba, phy_no, TX_ID_DWORD5,\n\t\t\t__swab32(identify_buffer[5]));\n}\n\nstatic void setup_itct_v3_hw(struct hisi_hba *hisi_hba,\n\t\t\t     struct hisi_sas_device *sas_dev)\n{\n\tstruct domain_device *device = sas_dev->sas_device;\n\tstruct device *dev = hisi_hba->dev;\n\tu64 qw0, device_id = sas_dev->device_id;\n\tstruct hisi_sas_itct *itct = &hisi_hba->itct[device_id];\n\tstruct domain_device *parent_dev = device->parent;\n\tstruct asd_sas_port *sas_port = device->port;\n\tstruct hisi_sas_port *port = to_hisi_sas_port(sas_port);\n\tu64 sas_addr;\n\n\tmemset(itct, 0, sizeof(*itct));\n\n\t \n\tqw0 = 0;\n\tswitch (sas_dev->dev_type) {\n\tcase SAS_END_DEVICE:\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tqw0 = HISI_SAS_DEV_TYPE_SSP << ITCT_HDR_DEV_TYPE_OFF;\n\t\tbreak;\n\tcase SAS_SATA_DEV:\n\tcase SAS_SATA_PENDING:\n\t\tif (parent_dev && dev_is_expander(parent_dev->dev_type))\n\t\t\tqw0 = HISI_SAS_DEV_TYPE_STP << ITCT_HDR_DEV_TYPE_OFF;\n\t\telse\n\t\t\tqw0 = HISI_SAS_DEV_TYPE_SATA << ITCT_HDR_DEV_TYPE_OFF;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"setup itct: unsupported dev type (%d)\\n\",\n\t\t\t sas_dev->dev_type);\n\t}\n\n\tqw0 |= ((1 << ITCT_HDR_VALID_OFF) |\n\t\t(device->linkrate << ITCT_HDR_MCR_OFF) |\n\t\t(1 << ITCT_HDR_VLN_OFF) |\n\t\t(0xfa << ITCT_HDR_SMP_TIMEOUT_OFF) |\n\t\t(1 << ITCT_HDR_AWT_CONTINUE_OFF) |\n\t\t(port->id << ITCT_HDR_PORT_ID_OFF));\n\titct->qw0 = cpu_to_le64(qw0);\n\n\t \n\tmemcpy(&sas_addr, device->sas_addr, SAS_ADDR_SIZE);\n\titct->sas_addr = cpu_to_le64(__swab64(sas_addr));\n\n\t \n\tif (!dev_is_sata(device))\n\t\titct->qw2 = cpu_to_le64((5000ULL << ITCT_HDR_INLT_OFF) |\n\t\t\t\t\t(0x1ULL << ITCT_HDR_RTOLT_OFF));\n}\n\nstatic int clear_itct_v3_hw(struct hisi_hba *hisi_hba,\n\t\t\t    struct hisi_sas_device *sas_dev)\n{\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tu64 dev_id = sas_dev->device_id;\n\tstruct hisi_sas_itct *itct = &hisi_hba->itct[dev_id];\n\tu32 reg_val = hisi_sas_read32(hisi_hba, ENT_INT_SRC3);\n\tstruct device *dev = hisi_hba->dev;\n\n\tsas_dev->completion = &completion;\n\n\t \n\tif (ENT_INT_SRC3_ITC_INT_MSK & reg_val)\n\t\thisi_sas_write32(hisi_hba, ENT_INT_SRC3,\n\t\t\t\t ENT_INT_SRC3_ITC_INT_MSK);\n\n\t \n\treg_val = ITCT_CLR_EN_MSK | (dev_id & ITCT_DEV_MSK);\n\thisi_sas_write32(hisi_hba, ITCT_CLR, reg_val);\n\n\tif (!wait_for_completion_timeout(sas_dev->completion,\n\t\t\t\t\t HISI_SAS_CLEAR_ITCT_TIMEOUT)) {\n\t\tdev_warn(dev, \"failed to clear ITCT\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tmemset(itct, 0, sizeof(struct hisi_sas_itct));\n\treturn 0;\n}\n\nstatic void dereg_device_v3_hw(struct hisi_hba *hisi_hba,\n\t\t\t\tstruct domain_device *device)\n{\n\tstruct hisi_sas_slot *slot, *slot2;\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tu32 cfg_abt_set_query_iptt;\n\n\tcfg_abt_set_query_iptt = hisi_sas_read32(hisi_hba,\n\t\tCFG_ABT_SET_QUERY_IPTT);\n\tspin_lock(&sas_dev->lock);\n\tlist_for_each_entry_safe(slot, slot2, &sas_dev->list, entry) {\n\t\tcfg_abt_set_query_iptt &= ~CFG_SET_ABORTED_IPTT_MSK;\n\t\tcfg_abt_set_query_iptt |= (1 << CFG_SET_ABORTED_EN_OFF) |\n\t\t\t(slot->idx << CFG_SET_ABORTED_IPTT_OFF);\n\t\thisi_sas_write32(hisi_hba, CFG_ABT_SET_QUERY_IPTT,\n\t\t\tcfg_abt_set_query_iptt);\n\t}\n\tspin_unlock(&sas_dev->lock);\n\tcfg_abt_set_query_iptt &= ~(1 << CFG_SET_ABORTED_EN_OFF);\n\thisi_sas_write32(hisi_hba, CFG_ABT_SET_QUERY_IPTT,\n\t\tcfg_abt_set_query_iptt);\n\thisi_sas_write32(hisi_hba, CFG_ABT_SET_IPTT_DONE,\n\t\t\t\t\t1 << CFG_ABT_SET_IPTT_DONE_OFF);\n}\n\nstatic int reset_hw_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tint ret;\n\tu32 val;\n\n\thisi_sas_write32(hisi_hba, DLVRY_QUEUE_ENABLE, 0);\n\n\t \n\thisi_sas_stop_phys(hisi_hba);\n\tudelay(50);\n\n\t \n\tret = hisi_sas_read32_poll_timeout(AXI_CFG, val, !val,\n\t\t\t\t\t   20000, 1000000);\n\tif (ret) {\n\t\tdev_err(dev, \"axi bus is not idle, ret = %d!\\n\", ret);\n\t\treturn -EIO;\n\t}\n\n\tif (ACPI_HANDLE(dev)) {\n\t\tacpi_status s;\n\n\t\ts = acpi_evaluate_object(ACPI_HANDLE(dev), \"_RST\", NULL, NULL);\n\t\tif (ACPI_FAILURE(s)) {\n\t\t\tdev_err(dev, \"Reset failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\tdev_err(dev, \"no reset method!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hw_init_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tstruct acpi_device *acpi_dev;\n\tunion acpi_object *obj;\n\tguid_t guid;\n\tint rc;\n\n\trc = reset_hw_v3_hw(hisi_hba);\n\tif (rc) {\n\t\tdev_err(dev, \"hisi_sas_reset_hw failed, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tmsleep(100);\n\tinit_reg_v3_hw(hisi_hba);\n\n\tif (guid_parse(\"D5918B4B-37AE-4E10-A99F-E5E8A6EF4C1F\", &guid)) {\n\t\tdev_err(dev, \"Parse GUID failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tobj = acpi_evaluate_dsm(ACPI_HANDLE(dev), &guid, 0,\n\t\t\t\tDSM_FUNC_ERR_HANDLE_MSI, NULL);\n\tif (!obj)\n\t\tdev_warn(dev, \"can not find DSM method, ignore\\n\");\n\telse\n\t\tACPI_FREE(obj);\n\n\tacpi_dev = ACPI_COMPANION(dev);\n\tif (!acpi_device_power_manageable(acpi_dev))\n\t\tdev_notice(dev, \"neither _PS0 nor _PR0 is defined\\n\");\n\treturn 0;\n}\n\nstatic void enable_phy_v3_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 cfg = hisi_sas_phy_read32(hisi_hba, phy_no, PHY_CFG);\n\n\tcfg |= PHY_CFG_ENA_MSK;\n\tcfg &= ~PHY_CFG_PHY_RST_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHY_CFG, cfg);\n}\n\nstatic void disable_phy_v3_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 cfg = hisi_sas_phy_read32(hisi_hba, phy_no, PHY_CFG);\n\tu32 irq_msk = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT2_MSK);\n\tstatic const u32 msk = BIT(CHL_INT2_RX_DISP_ERR_OFF) |\n\t\t\t       BIT(CHL_INT2_RX_CODE_ERR_OFF) |\n\t\t\t       BIT(CHL_INT2_RX_INVLD_DW_OFF);\n\tu32 state;\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT2_MSK, msk | irq_msk);\n\n\tcfg &= ~PHY_CFG_ENA_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHY_CFG, cfg);\n\n\tmdelay(50);\n\n\tstate = hisi_sas_read32(hisi_hba, PHY_STATE);\n\tif (state & BIT(phy_no)) {\n\t\tcfg |= PHY_CFG_PHY_RST_MSK;\n\t\thisi_sas_phy_write32(hisi_hba, phy_no, PHY_CFG, cfg);\n\t}\n\n\tudelay(1);\n\n\thisi_sas_phy_read32(hisi_hba, phy_no, ERR_CNT_INVLD_DW);\n\thisi_sas_phy_read32(hisi_hba, phy_no, ERR_CNT_DISP_ERR);\n\thisi_sas_phy_read32(hisi_hba, phy_no, ERR_CNT_CODE_ERR);\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT2, msk);\n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT2_MSK, irq_msk);\n}\n\nstatic void start_phy_v3_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tconfig_id_frame_v3_hw(hisi_hba, phy_no);\n\tconfig_phy_opt_mode_v3_hw(hisi_hba, phy_no);\n\tenable_phy_v3_hw(hisi_hba, phy_no);\n}\n\nstatic void phy_hard_reset_v3_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tu32 txid_auto;\n\n\thisi_sas_phy_enable(hisi_hba, phy_no, 0);\n\tif (phy->identify.device_type == SAS_END_DEVICE) {\n\t\ttxid_auto = hisi_sas_phy_read32(hisi_hba, phy_no, TXID_AUTO);\n\t\thisi_sas_phy_write32(hisi_hba, phy_no, TXID_AUTO,\n\t\t\t\t\ttxid_auto | TX_HARDRST_MSK);\n\t}\n\tmsleep(100);\n\thisi_sas_phy_enable(hisi_hba, phy_no, 1);\n}\n\nstatic enum sas_linkrate phy_get_max_linkrate_v3_hw(void)\n{\n\treturn SAS_LINK_RATE_12_0_GBPS;\n}\n\nstatic void phys_init_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tint i;\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\tstruct hisi_sas_phy *phy = &hisi_hba->phy[i];\n\t\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\n\t\tif (!sas_phy->phy->enabled)\n\t\t\tcontinue;\n\n\t\thisi_sas_phy_enable(hisi_hba, i, 1);\n\t}\n}\n\nstatic void sl_notify_ssp_v3_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 sl_control;\n\n\tsl_control = hisi_sas_phy_read32(hisi_hba, phy_no, SL_CONTROL);\n\tsl_control |= SL_CONTROL_NOTIFY_EN_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, SL_CONTROL, sl_control);\n\tmsleep(1);\n\tsl_control = hisi_sas_phy_read32(hisi_hba, phy_no, SL_CONTROL);\n\tsl_control &= ~SL_CONTROL_NOTIFY_EN_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, SL_CONTROL, sl_control);\n}\n\nstatic int get_wideport_bitmap_v3_hw(struct hisi_hba *hisi_hba, int port_id)\n{\n\tint i, bitmap = 0;\n\tu32 phy_port_num_ma = hisi_sas_read32(hisi_hba, PHY_PORT_NUM_MA);\n\tu32 phy_state = hisi_sas_read32(hisi_hba, PHY_STATE);\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++)\n\t\tif (phy_state & BIT(i))\n\t\t\tif (((phy_port_num_ma >> (i * 4)) & 0xf) == port_id)\n\t\t\t\tbitmap |= BIT(i);\n\n\treturn bitmap;\n}\n\nstatic void start_delivery_v3_hw(struct hisi_sas_dq *dq)\n{\n\tstruct hisi_hba *hisi_hba = dq->hisi_hba;\n\tstruct hisi_sas_slot *s, *s1, *s2 = NULL;\n\tint dlvry_queue = dq->id;\n\tint wp;\n\n\tlist_for_each_entry_safe(s, s1, &dq->list, delivery) {\n\t\tif (!s->ready)\n\t\t\tbreak;\n\t\ts2 = s;\n\t\tlist_del(&s->delivery);\n\t}\n\n\tif (!s2)\n\t\treturn;\n\n\t \n\tsmp_rmb();\n\twp = (s2->dlvry_queue_slot + 1) % HISI_SAS_QUEUE_SLOTS;\n\n\thisi_sas_write32(hisi_hba, DLVRY_Q_0_WR_PTR + (dlvry_queue * 0x14), wp);\n}\n\nstatic void prep_prd_sge_v3_hw(struct hisi_hba *hisi_hba,\n\t\t\t      struct hisi_sas_slot *slot,\n\t\t\t      struct hisi_sas_cmd_hdr *hdr,\n\t\t\t      struct scatterlist *scatter,\n\t\t\t      int n_elem)\n{\n\tstruct hisi_sas_sge_page *sge_page = hisi_sas_sge_addr_mem(slot);\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(scatter, sg, n_elem, i) {\n\t\tstruct hisi_sas_sge *entry = &sge_page->sge[i];\n\n\t\tentry->addr = cpu_to_le64(sg_dma_address(sg));\n\t\tentry->page_ctrl_0 = entry->page_ctrl_1 = 0;\n\t\tentry->data_len = cpu_to_le32(sg_dma_len(sg));\n\t\tentry->data_off = 0;\n\t}\n\n\thdr->prd_table_addr = cpu_to_le64(hisi_sas_sge_addr_dma(slot));\n\n\thdr->sg_len |= cpu_to_le32(n_elem << CMD_HDR_DATA_SGL_LEN_OFF);\n}\n\nstatic void prep_prd_sge_dif_v3_hw(struct hisi_hba *hisi_hba,\n\t\t\t\t   struct hisi_sas_slot *slot,\n\t\t\t\t   struct hisi_sas_cmd_hdr *hdr,\n\t\t\t\t   struct scatterlist *scatter,\n\t\t\t\t   int n_elem)\n{\n\tstruct hisi_sas_sge_dif_page *sge_dif_page;\n\tstruct scatterlist *sg;\n\tint i;\n\n\tsge_dif_page = hisi_sas_sge_dif_addr_mem(slot);\n\n\tfor_each_sg(scatter, sg, n_elem, i) {\n\t\tstruct hisi_sas_sge *entry = &sge_dif_page->sge[i];\n\n\t\tentry->addr = cpu_to_le64(sg_dma_address(sg));\n\t\tentry->page_ctrl_0 = 0;\n\t\tentry->page_ctrl_1 = 0;\n\t\tentry->data_len = cpu_to_le32(sg_dma_len(sg));\n\t\tentry->data_off = 0;\n\t}\n\n\thdr->dif_prd_table_addr =\n\t\tcpu_to_le64(hisi_sas_sge_dif_addr_dma(slot));\n\n\thdr->sg_len |= cpu_to_le32(n_elem << CMD_HDR_DIF_SGL_LEN_OFF);\n}\n\nstatic u32 get_prot_chk_msk_v3_hw(struct scsi_cmnd *scsi_cmnd)\n{\n\tunsigned char prot_flags = scsi_cmnd->prot_flags;\n\n\tif (prot_flags & SCSI_PROT_REF_CHECK)\n\t\treturn T10_CHK_APP_TAG_MSK;\n\treturn T10_CHK_REF_TAG_MSK | T10_CHK_APP_TAG_MSK;\n}\n\nstatic void fill_prot_v3_hw(struct scsi_cmnd *scsi_cmnd,\n\t\t\t    struct hisi_sas_protect_iu_v3_hw *prot)\n{\n\tunsigned char prot_op = scsi_get_prot_op(scsi_cmnd);\n\tunsigned int interval = scsi_prot_interval(scsi_cmnd);\n\tu32 lbrt_chk_val = t10_pi_ref_tag(scsi_cmd_to_rq(scsi_cmnd));\n\n\tswitch (prot_op) {\n\tcase SCSI_PROT_READ_INSERT:\n\t\tprot->dw0 |= T10_INSRT_EN_MSK;\n\t\tprot->lbrtgv = lbrt_chk_val;\n\t\tbreak;\n\tcase SCSI_PROT_READ_STRIP:\n\t\tprot->dw0 |= (T10_RMV_EN_MSK | T10_CHK_EN_MSK);\n\t\tprot->lbrtcv = lbrt_chk_val;\n\t\tprot->dw4 |= get_prot_chk_msk_v3_hw(scsi_cmnd);\n\t\tbreak;\n\tcase SCSI_PROT_READ_PASS:\n\t\tprot->dw0 |= T10_CHK_EN_MSK;\n\t\tprot->lbrtcv = lbrt_chk_val;\n\t\tprot->dw4 |= get_prot_chk_msk_v3_hw(scsi_cmnd);\n\t\tbreak;\n\tcase SCSI_PROT_WRITE_INSERT:\n\t\tprot->dw0 |= T10_INSRT_EN_MSK;\n\t\tprot->lbrtgv = lbrt_chk_val;\n\t\tbreak;\n\tcase SCSI_PROT_WRITE_STRIP:\n\t\tprot->dw0 |= (T10_RMV_EN_MSK | T10_CHK_EN_MSK);\n\t\tprot->lbrtcv = lbrt_chk_val;\n\t\tbreak;\n\tcase SCSI_PROT_WRITE_PASS:\n\t\tprot->dw0 |= T10_CHK_EN_MSK;\n\t\tprot->lbrtcv = lbrt_chk_val;\n\t\tprot->dw4 |= get_prot_chk_msk_v3_hw(scsi_cmnd);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"prot_op(0x%x) is not valid\\n\", prot_op);\n\t\tbreak;\n\t}\n\n\tswitch (interval) {\n\tcase 512:\n\t\tbreak;\n\tcase 4096:\n\t\tprot->dw0 |= (0x1 << USR_DATA_BLOCK_SZ_OFF);\n\t\tbreak;\n\tcase 520:\n\t\tprot->dw0 |= (0x2 << USR_DATA_BLOCK_SZ_OFF);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"protection interval (0x%x) invalid\\n\",\n\t\t     interval);\n\t\tbreak;\n\t}\n\n\tprot->dw0 |= INCR_LBRT_MSK;\n}\n\nstatic void prep_ssp_v3_hw(struct hisi_hba *hisi_hba,\n\t\t\t  struct hisi_sas_slot *slot)\n{\n\tstruct sas_task *task = slot->task;\n\tstruct hisi_sas_cmd_hdr *hdr = slot->cmd_hdr;\n\tstruct domain_device *device = task->dev;\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tstruct hisi_sas_port *port = slot->port;\n\tstruct sas_ssp_task *ssp_task = &task->ssp_task;\n\tstruct scsi_cmnd *scsi_cmnd = ssp_task->cmd;\n\tstruct sas_tmf_task *tmf = slot->tmf;\n\tint has_data = 0, priority = !!tmf;\n\tunsigned char prot_op;\n\tu8 *buf_cmd;\n\tu32 dw1 = 0, dw2 = 0, len = 0;\n\n\thdr->dw0 = cpu_to_le32((1 << CMD_HDR_RESP_REPORT_OFF) |\n\t\t\t       (2 << CMD_HDR_TLR_CTRL_OFF) |\n\t\t\t       (port->id << CMD_HDR_PORT_OFF) |\n\t\t\t       (priority << CMD_HDR_PRIORITY_OFF) |\n\t\t\t       (1 << CMD_HDR_CMD_OFF));  \n\n\tdw1 = 1 << CMD_HDR_VDTL_OFF;\n\tif (tmf) {\n\t\tdw1 |= 2 << CMD_HDR_FRAME_TYPE_OFF;\n\t\tdw1 |= DIR_NO_DATA << CMD_HDR_DIR_OFF;\n\t} else {\n\t\tprot_op = scsi_get_prot_op(scsi_cmnd);\n\t\tdw1 |= 1 << CMD_HDR_FRAME_TYPE_OFF;\n\t\tswitch (scsi_cmnd->sc_data_direction) {\n\t\tcase DMA_TO_DEVICE:\n\t\t\thas_data = 1;\n\t\t\tdw1 |= DIR_TO_DEVICE << CMD_HDR_DIR_OFF;\n\t\t\tbreak;\n\t\tcase DMA_FROM_DEVICE:\n\t\t\thas_data = 1;\n\t\t\tdw1 |= DIR_TO_INI << CMD_HDR_DIR_OFF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdw1 &= ~CMD_HDR_DIR_MSK;\n\t\t}\n\t}\n\n\t \n\tdw1 |= sas_dev->device_id << CMD_HDR_DEV_ID_OFF;\n\n\tdw2 = (((sizeof(struct ssp_command_iu) + sizeof(struct ssp_frame_hdr)\n\t      + 3) / 4) << CMD_HDR_CFL_OFF) |\n\t      ((HISI_SAS_MAX_SSP_RESP_SZ / 4) << CMD_HDR_MRFL_OFF) |\n\t      (2 << CMD_HDR_SG_MOD_OFF);\n\thdr->dw2 = cpu_to_le32(dw2);\n\thdr->transfer_tags = cpu_to_le32(slot->idx);\n\n\tif (has_data) {\n\t\tprep_prd_sge_v3_hw(hisi_hba, slot, hdr, task->scatter,\n\t\t\t\t   slot->n_elem);\n\n\t\tif (scsi_prot_sg_count(scsi_cmnd))\n\t\t\tprep_prd_sge_dif_v3_hw(hisi_hba, slot, hdr,\n\t\t\t\t\t       scsi_prot_sglist(scsi_cmnd),\n\t\t\t\t\t       slot->n_elem_dif);\n\t}\n\n\thdr->cmd_table_addr = cpu_to_le64(hisi_sas_cmd_hdr_addr_dma(slot));\n\thdr->sts_buffer_addr = cpu_to_le64(hisi_sas_status_buf_addr_dma(slot));\n\n\tbuf_cmd = hisi_sas_cmd_hdr_addr_mem(slot) +\n\t\tsizeof(struct ssp_frame_hdr);\n\n\tmemcpy(buf_cmd, &task->ssp_task.LUN, 8);\n\tif (!tmf) {\n\t\tbuf_cmd[9] = ssp_task->task_attr;\n\t\tmemcpy(buf_cmd + 12, scsi_cmnd->cmnd, scsi_cmnd->cmd_len);\n\t} else {\n\t\tbuf_cmd[10] = tmf->tmf;\n\t\tswitch (tmf->tmf) {\n\t\tcase TMF_ABORT_TASK:\n\t\tcase TMF_QUERY_TASK:\n\t\t\tbuf_cmd[12] =\n\t\t\t\t(tmf->tag_of_task_to_be_managed >> 8) & 0xff;\n\t\t\tbuf_cmd[13] =\n\t\t\t\ttmf->tag_of_task_to_be_managed & 0xff;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (has_data && (prot_op != SCSI_PROT_NORMAL)) {\n\t\tstruct hisi_sas_protect_iu_v3_hw prot;\n\t\tu8 *buf_cmd_prot;\n\n\t\thdr->dw7 |= cpu_to_le32(1 << CMD_HDR_ADDR_MODE_SEL_OFF);\n\t\tdw1 |= CMD_HDR_PIR_MSK;\n\t\tbuf_cmd_prot = hisi_sas_cmd_hdr_addr_mem(slot) +\n\t\t\t       sizeof(struct ssp_frame_hdr) +\n\t\t\t       sizeof(struct ssp_command_iu);\n\n\t\tmemset(&prot, 0, sizeof(struct hisi_sas_protect_iu_v3_hw));\n\t\tfill_prot_v3_hw(scsi_cmnd, &prot);\n\t\tmemcpy(buf_cmd_prot, &prot,\n\t\t       sizeof(struct hisi_sas_protect_iu_v3_hw));\n\t\t \n\t\tif (prot_op == SCSI_PROT_WRITE_INSERT ||\n\t\t    prot_op == SCSI_PROT_READ_INSERT ||\n\t\t    prot_op == SCSI_PROT_WRITE_PASS ||\n\t\t    prot_op == SCSI_PROT_READ_PASS) {\n\t\t\tunsigned int interval = scsi_prot_interval(scsi_cmnd);\n\t\t\tunsigned int ilog2_interval = ilog2(interval);\n\n\t\t\tlen = (task->total_xfer_len >> ilog2_interval) * 8;\n\t\t}\n\t}\n\n\thdr->dw1 = cpu_to_le32(dw1);\n\n\thdr->data_transfer_len = cpu_to_le32(task->total_xfer_len + len);\n}\n\nstatic void prep_smp_v3_hw(struct hisi_hba *hisi_hba,\n\t\t\t  struct hisi_sas_slot *slot)\n{\n\tstruct sas_task *task = slot->task;\n\tstruct hisi_sas_cmd_hdr *hdr = slot->cmd_hdr;\n\tstruct domain_device *device = task->dev;\n\tstruct hisi_sas_port *port = slot->port;\n\tstruct scatterlist *sg_req;\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tdma_addr_t req_dma_addr;\n\tunsigned int req_len;\n\n\t \n\tsg_req = &task->smp_task.smp_req;\n\treq_len = sg_dma_len(sg_req);\n\treq_dma_addr = sg_dma_address(sg_req);\n\n\t \n\t \n\thdr->dw0 = cpu_to_le32((port->id << CMD_HDR_PORT_OFF) |\n\t\t\t       (1 << CMD_HDR_PRIORITY_OFF) |  \n\t\t\t       (2 << CMD_HDR_CMD_OFF));  \n\n\t \n\thdr->dw1 = cpu_to_le32((sas_dev->device_id << CMD_HDR_DEV_ID_OFF) |\n\t\t\t       (1 << CMD_HDR_FRAME_TYPE_OFF) |\n\t\t\t       (DIR_NO_DATA << CMD_HDR_DIR_OFF));\n\n\t \n\thdr->dw2 = cpu_to_le32((((req_len - 4) / 4) << CMD_HDR_CFL_OFF) |\n\t\t\t       (HISI_SAS_MAX_SMP_RESP_SZ / 4 <<\n\t\t\t       CMD_HDR_MRFL_OFF));\n\n\thdr->transfer_tags = cpu_to_le32(slot->idx << CMD_HDR_IPTT_OFF);\n\n\thdr->cmd_table_addr = cpu_to_le64(req_dma_addr);\n\thdr->sts_buffer_addr = cpu_to_le64(hisi_sas_status_buf_addr_dma(slot));\n}\n\nstatic void prep_ata_v3_hw(struct hisi_hba *hisi_hba,\n\t\t\t  struct hisi_sas_slot *slot)\n{\n\tstruct sas_task *task = slot->task;\n\tstruct domain_device *device = task->dev;\n\tstruct domain_device *parent_dev = device->parent;\n\tstruct hisi_sas_device *sas_dev = device->lldd_dev;\n\tstruct hisi_sas_cmd_hdr *hdr = slot->cmd_hdr;\n\tstruct asd_sas_port *sas_port = device->port;\n\tstruct hisi_sas_port *port = to_hisi_sas_port(sas_port);\n\tu8 *buf_cmd;\n\tint has_data = 0, hdr_tag = 0;\n\tu32 dw1 = 0, dw2 = 0;\n\n\thdr->dw0 = cpu_to_le32(port->id << CMD_HDR_PORT_OFF);\n\tif (parent_dev && dev_is_expander(parent_dev->dev_type))\n\t\thdr->dw0 |= cpu_to_le32(3 << CMD_HDR_CMD_OFF);\n\telse\n\t\thdr->dw0 |= cpu_to_le32(4U << CMD_HDR_CMD_OFF);\n\n\tswitch (task->data_dir) {\n\tcase DMA_TO_DEVICE:\n\t\thas_data = 1;\n\t\tdw1 |= DIR_TO_DEVICE << CMD_HDR_DIR_OFF;\n\t\tbreak;\n\tcase DMA_FROM_DEVICE:\n\t\thas_data = 1;\n\t\tdw1 |= DIR_TO_INI << CMD_HDR_DIR_OFF;\n\t\tbreak;\n\tdefault:\n\t\tdw1 &= ~CMD_HDR_DIR_MSK;\n\t}\n\n\tif ((task->ata_task.fis.command == ATA_CMD_DEV_RESET) &&\n\t\t\t(task->ata_task.fis.control & ATA_SRST))\n\t\tdw1 |= 1 << CMD_HDR_RESET_OFF;\n\n\tdw1 |= (hisi_sas_get_ata_protocol(\n\t\t&task->ata_task.fis, task->data_dir))\n\t\t<< CMD_HDR_FRAME_TYPE_OFF;\n\tdw1 |= sas_dev->device_id << CMD_HDR_DEV_ID_OFF;\n\n\tif (FIS_CMD_IS_UNCONSTRAINED(task->ata_task.fis))\n\t\tdw1 |= 1 << CMD_HDR_UNCON_CMD_OFF;\n\n\thdr->dw1 = cpu_to_le32(dw1);\n\n\t \n\tif (task->ata_task.use_ncq) {\n\t\tstruct ata_queued_cmd *qc = task->uldd_task;\n\n\t\thdr_tag = qc->tag;\n\t\ttask->ata_task.fis.sector_count |= (u8) (hdr_tag << 3);\n\t\tdw2 |= hdr_tag << CMD_HDR_NCQ_TAG_OFF;\n\t}\n\n\tdw2 |= (HISI_SAS_MAX_STP_RESP_SZ / 4) << CMD_HDR_CFL_OFF |\n\t\t\t2 << CMD_HDR_SG_MOD_OFF;\n\thdr->dw2 = cpu_to_le32(dw2);\n\n\t \n\thdr->transfer_tags = cpu_to_le32(slot->idx);\n\n\tif (has_data)\n\t\tprep_prd_sge_v3_hw(hisi_hba, slot, hdr, task->scatter,\n\t\t\t\t\tslot->n_elem);\n\n\thdr->data_transfer_len = cpu_to_le32(task->total_xfer_len);\n\thdr->cmd_table_addr = cpu_to_le64(hisi_sas_cmd_hdr_addr_dma(slot));\n\thdr->sts_buffer_addr = cpu_to_le64(hisi_sas_status_buf_addr_dma(slot));\n\n\tbuf_cmd = hisi_sas_cmd_hdr_addr_mem(slot);\n\n\tif (likely(!task->ata_task.device_control_reg_update))\n\t\ttask->ata_task.fis.flags |= 0x80;  \n\t \n\tmemcpy(buf_cmd, &task->ata_task.fis, sizeof(struct host_to_dev_fis));\n}\n\nstatic void prep_abort_v3_hw(struct hisi_hba *hisi_hba,\n\t\t\t     struct hisi_sas_slot *slot)\n{\n\tstruct sas_task *task = slot->task;\n\tstruct sas_internal_abort_task *abort = &task->abort_task;\n\tstruct domain_device *dev = task->dev;\n\tstruct hisi_sas_cmd_hdr *hdr = slot->cmd_hdr;\n\tstruct hisi_sas_port *port = slot->port;\n\tstruct hisi_sas_device *sas_dev = dev->lldd_dev;\n\tbool sata = dev_is_sata(dev);\n\n\t \n\thdr->dw0 = cpu_to_le32((5U << CMD_HDR_CMD_OFF) |  \n\t\t\t       (port->id << CMD_HDR_PORT_OFF) |\n\t\t\t\t(sata << CMD_HDR_ABORT_DEVICE_TYPE_OFF) |\n\t\t\t\t(abort->type << CMD_HDR_ABORT_FLAG_OFF));\n\n\t \n\thdr->dw1 = cpu_to_le32(sas_dev->device_id\n\t\t\t<< CMD_HDR_DEV_ID_OFF);\n\n\t \n\thdr->dw7 = cpu_to_le32(abort->tag << CMD_HDR_ABORT_IPTT_OFF);\n\thdr->transfer_tags = cpu_to_le32(slot->idx);\n}\n\nstatic irqreturn_t phy_up_v3_hw(int phy_no, struct hisi_hba *hisi_hba)\n{\n\tint i;\n\tirqreturn_t res;\n\tu32 context, port_id, link_rate;\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tstruct device *dev = hisi_hba->dev;\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHYCTRL_PHY_ENA_MSK, 1);\n\n\tport_id = hisi_sas_read32(hisi_hba, PHY_PORT_NUM_MA);\n\tport_id = (port_id >> (4 * phy_no)) & 0xf;\n\tlink_rate = hisi_sas_read32(hisi_hba, PHY_CONN_RATE);\n\tlink_rate = (link_rate >> (phy_no * 4)) & 0xf;\n\n\tif (port_id == 0xf) {\n\t\tdev_err(dev, \"phyup: phy%d invalid portid\\n\", phy_no);\n\t\tres = IRQ_NONE;\n\t\tgoto end;\n\t}\n\tsas_phy->linkrate = link_rate;\n\tphy->phy_type &= ~(PORT_TYPE_SAS | PORT_TYPE_SATA);\n\n\t \n\tcontext = hisi_sas_read32(hisi_hba, PHY_CONTEXT);\n\tif (context & (1 << phy_no)) {\n\t\tstruct hisi_sas_initial_fis *initial_fis;\n\t\tstruct dev_to_host_fis *fis;\n\t\tu8 attached_sas_addr[SAS_ADDR_SIZE] = {0};\n\t\tstruct Scsi_Host *shost = hisi_hba->shost;\n\n\t\tdev_info(dev, \"phyup: phy%d link_rate=%d(sata)\\n\", phy_no, link_rate);\n\t\tinitial_fis = &hisi_hba->initial_fis[phy_no];\n\t\tfis = &initial_fis->fis;\n\n\t\t \n\t\tif (fis->status & ATA_ERR) {\n\t\t\tdev_warn(dev, \"sata int: phy%d FIS status: 0x%x\\n\",\n\t\t\t\t phy_no, fis->status);\n\t\t\thisi_sas_notify_phy_event(phy, HISI_PHYE_LINK_RESET);\n\t\t\tres = IRQ_NONE;\n\t\t\tgoto end;\n\t\t}\n\n\t\tsas_phy->oob_mode = SATA_OOB_MODE;\n\t\tattached_sas_addr[0] = 0x50;\n\t\tattached_sas_addr[6] = shost->host_no;\n\t\tattached_sas_addr[7] = phy_no;\n\t\tmemcpy(sas_phy->attached_sas_addr,\n\t\t       attached_sas_addr,\n\t\t       SAS_ADDR_SIZE);\n\t\tmemcpy(sas_phy->frame_rcvd, fis,\n\t\t       sizeof(struct dev_to_host_fis));\n\t\tphy->phy_type |= PORT_TYPE_SATA;\n\t\tphy->identify.device_type = SAS_SATA_DEV;\n\t\tphy->frame_rcvd_size = sizeof(struct dev_to_host_fis);\n\t\tphy->identify.target_port_protocols = SAS_PROTOCOL_SATA;\n\t} else {\n\t\tu32 *frame_rcvd = (u32 *)sas_phy->frame_rcvd;\n\t\tstruct sas_identify_frame *id =\n\t\t\t(struct sas_identify_frame *)frame_rcvd;\n\n\t\tdev_info(dev, \"phyup: phy%d link_rate=%d\\n\", phy_no, link_rate);\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tu32 idaf = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\t       RX_IDAF_DWORD0 + (i * 4));\n\t\t\tframe_rcvd[i] = __swab32(idaf);\n\t\t}\n\t\tsas_phy->oob_mode = SAS_OOB_MODE;\n\t\tmemcpy(sas_phy->attached_sas_addr,\n\t\t       &id->sas_addr,\n\t\t       SAS_ADDR_SIZE);\n\t\tphy->phy_type |= PORT_TYPE_SAS;\n\t\tphy->identify.device_type = id->dev_type;\n\t\tphy->frame_rcvd_size = sizeof(struct sas_identify_frame);\n\t\tif (phy->identify.device_type == SAS_END_DEVICE)\n\t\t\tphy->identify.target_port_protocols =\n\t\t\t\tSAS_PROTOCOL_SSP;\n\t\telse if (phy->identify.device_type != SAS_PHY_UNUSED)\n\t\t\tphy->identify.target_port_protocols =\n\t\t\t\tSAS_PROTOCOL_SMP;\n\t}\n\n\tphy->port_id = port_id;\n\n\t \n\tpm_runtime_get_noresume(dev);\n\tres = hisi_sas_notify_phy_event(phy, HISI_PHYE_PHY_UP_PM);\n\tif (!res)\n\t\tpm_runtime_put(dev);\n\n\tres = IRQ_HANDLED;\n\n\tspin_lock(&phy->lock);\n\t \n\tdel_timer(&phy->timer);\n\tphy->phy_attached = 1;\n\tspin_unlock(&phy->lock);\nend:\n\tif (phy->reset_completion)\n\t\tcomplete(phy->reset_completion);\n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0,\n\t\t\t     CHL_INT0_SL_PHY_ENABLE_MSK);\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHYCTRL_PHY_ENA_MSK, 0);\n\n\treturn res;\n}\n\nstatic irqreturn_t phy_down_v3_hw(int phy_no, struct hisi_hba *hisi_hba)\n{\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tu32 phy_state, sl_ctrl, txid_auto;\n\tstruct device *dev = hisi_hba->dev;\n\n\tatomic_inc(&phy->down_cnt);\n\n\tdel_timer(&phy->timer);\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHYCTRL_NOT_RDY_MSK, 1);\n\n\tphy_state = hisi_sas_read32(hisi_hba, PHY_STATE);\n\tdev_info(dev, \"phydown: phy%d phy_state=0x%x\\n\", phy_no, phy_state);\n\thisi_sas_phy_down(hisi_hba, phy_no, (phy_state & 1 << phy_no) ? 1 : 0,\n\t\t\t  GFP_ATOMIC);\n\n\tsl_ctrl = hisi_sas_phy_read32(hisi_hba, phy_no, SL_CONTROL);\n\thisi_sas_phy_write32(hisi_hba, phy_no, SL_CONTROL,\n\t\t\t\t\t\tsl_ctrl&(~SL_CTA_MSK));\n\n\ttxid_auto = hisi_sas_phy_read32(hisi_hba, phy_no, TXID_AUTO);\n\thisi_sas_phy_write32(hisi_hba, phy_no, TXID_AUTO,\n\t\t\t\t\t\ttxid_auto | CT3_MSK);\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0, CHL_INT0_NOT_RDY_MSK);\n\thisi_sas_phy_write32(hisi_hba, phy_no, PHYCTRL_NOT_RDY_MSK, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t phy_bcast_v3_hw(int phy_no, struct hisi_hba *hisi_hba)\n{\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tu32 bcast_status;\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, SL_RX_BCAST_CHK_MSK, 1);\n\tbcast_status = hisi_sas_phy_read32(hisi_hba, phy_no, RX_PRIMS_STATUS);\n\tif (bcast_status & RX_BCAST_CHG_MSK)\n\t\thisi_sas_phy_bcast(phy);\n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0,\n\t\t\t     CHL_INT0_SL_RX_BCST_ACK_MSK);\n\thisi_sas_phy_write32(hisi_hba, phy_no, SL_RX_BCAST_CHK_MSK, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t int_phy_up_down_bcast_v3_hw(int irq_no, void *p)\n{\n\tstruct hisi_hba *hisi_hba = p;\n\tu32 irq_msk;\n\tint phy_no = 0;\n\tirqreturn_t res = IRQ_NONE;\n\n\tirq_msk = hisi_sas_read32(hisi_hba, CHNL_INT_STATUS)\n\t\t\t\t& 0x11111111;\n\twhile (irq_msk) {\n\t\tif (irq_msk  & 1) {\n\t\t\tu32 irq_value = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\t\t\t    CHL_INT0);\n\t\t\tu32 phy_state = hisi_sas_read32(hisi_hba, PHY_STATE);\n\t\t\tint rdy = phy_state & (1 << phy_no);\n\n\t\t\tif (rdy) {\n\t\t\t\tif (irq_value & CHL_INT0_SL_PHY_ENABLE_MSK)\n\t\t\t\t\t \n\t\t\t\t\tif (phy_up_v3_hw(phy_no, hisi_hba)\n\t\t\t\t\t\t\t== IRQ_HANDLED)\n\t\t\t\t\t\tres = IRQ_HANDLED;\n\t\t\t\tif (irq_value & CHL_INT0_SL_RX_BCST_ACK_MSK)\n\t\t\t\t\t \n\t\t\t\t\tif (phy_bcast_v3_hw(phy_no, hisi_hba)\n\t\t\t\t\t\t\t== IRQ_HANDLED)\n\t\t\t\t\t\tres = IRQ_HANDLED;\n\t\t\t} else {\n\t\t\t\tif (irq_value & CHL_INT0_NOT_RDY_MSK)\n\t\t\t\t\t \n\t\t\t\t\tif (phy_down_v3_hw(phy_no, hisi_hba)\n\t\t\t\t\t\t\t== IRQ_HANDLED)\n\t\t\t\t\t\tres = IRQ_HANDLED;\n\t\t\t}\n\t\t}\n\t\tirq_msk >>= 4;\n\t\tphy_no++;\n\t}\n\n\treturn res;\n}\n\nstatic const struct hisi_sas_hw_error port_axi_error[] = {\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_TX_ECC_MB_ERR_OFF),\n\t\t.msg = \"dmac_tx_ecc_bad_err\",\n\t},\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_RX_ECC_MB_ERR_OFF),\n\t\t.msg = \"dmac_rx_ecc_bad_err\",\n\t},\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_TX_AXI_WR_ERR_OFF),\n\t\t.msg = \"dma_tx_axi_wr_err\",\n\t},\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_TX_AXI_RD_ERR_OFF),\n\t\t.msg = \"dma_tx_axi_rd_err\",\n\t},\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_RX_AXI_WR_ERR_OFF),\n\t\t.msg = \"dma_rx_axi_wr_err\",\n\t},\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_RX_AXI_RD_ERR_OFF),\n\t\t.msg = \"dma_rx_axi_rd_err\",\n\t},\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_TX_FIFO_ERR_OFF),\n\t\t.msg = \"dma_tx_fifo_err\",\n\t},\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_RX_FIFO_ERR_OFF),\n\t\t.msg = \"dma_rx_fifo_err\",\n\t},\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_TX_AXI_RUSER_ERR_OFF),\n\t\t.msg = \"dma_tx_axi_ruser_err\",\n\t},\n\t{\n\t\t.irq_msk = BIT(CHL_INT1_DMAC_RX_AXI_RUSER_ERR_OFF),\n\t\t.msg = \"dma_rx_axi_ruser_err\",\n\t},\n};\n\nstatic void handle_chl_int1_v3_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 irq_value = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT1);\n\tu32 irq_msk = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT1_MSK);\n\tstruct device *dev = hisi_hba->dev;\n\tint i;\n\n\tirq_value &= ~irq_msk;\n\tif (!irq_value) {\n\t\tdev_warn(dev, \"phy%d channel int 1 received with status bits cleared\\n\",\n\t\t\t phy_no);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(port_axi_error); i++) {\n\t\tconst struct hisi_sas_hw_error *error = &port_axi_error[i];\n\n\t\tif (!(irq_value & error->irq_msk))\n\t\t\tcontinue;\n\n\t\tdev_err(dev, \"%s error (phy%d 0x%x) found!\\n\",\n\t\t\terror->msg, phy_no, irq_value);\n\t\tqueue_work(hisi_hba->wq, &hisi_hba->rst_work);\n\t}\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT1, irq_value);\n}\n\nstatic void phy_get_events_v3_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tstruct sas_phy *sphy = sas_phy->phy;\n\tunsigned long flags;\n\tu32 reg_value;\n\n\tspin_lock_irqsave(&phy->lock, flags);\n\n\t \n\treg_value = hisi_sas_phy_read32(hisi_hba, phy_no, ERR_CNT_DWS_LOST);\n\tsphy->loss_of_dword_sync_count += reg_value;\n\n\t \n\treg_value = hisi_sas_phy_read32(hisi_hba, phy_no, ERR_CNT_RESET_PROB);\n\tsphy->phy_reset_problem_count += reg_value;\n\n\t \n\treg_value = hisi_sas_phy_read32(hisi_hba, phy_no, ERR_CNT_INVLD_DW);\n\tsphy->invalid_dword_count += reg_value;\n\n\t \n\treg_value = hisi_sas_phy_read32(hisi_hba, phy_no, ERR_CNT_DISP_ERR);\n\tsphy->running_disparity_error_count += reg_value;\n\n\t \n\treg_value = hisi_sas_phy_read32(hisi_hba, phy_no, ERR_CNT_CODE_ERR);\n\tphy->code_violation_err_count += reg_value;\n\n\tspin_unlock_irqrestore(&phy->lock, flags);\n}\n\nstatic void handle_chl_int2_v3_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 irq_msk = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT2_MSK);\n\tu32 irq_value = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT2);\n\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\tstruct pci_dev *pci_dev = hisi_hba->pci_dev;\n\tstruct device *dev = hisi_hba->dev;\n\tstatic const u32 msk = BIT(CHL_INT2_RX_DISP_ERR_OFF) |\n\t\t\tBIT(CHL_INT2_RX_CODE_ERR_OFF) |\n\t\t\tBIT(CHL_INT2_RX_INVLD_DW_OFF);\n\n\tirq_value &= ~irq_msk;\n\tif (!irq_value) {\n\t\tdev_warn(dev, \"phy%d channel int 2 received with status bits cleared\\n\",\n\t\t\t phy_no);\n\t\treturn;\n\t}\n\n\tif (irq_value & BIT(CHL_INT2_SL_IDAF_TOUT_CONF_OFF)) {\n\t\tdev_warn(dev, \"phy%d identify timeout\\n\", phy_no);\n\t\thisi_sas_notify_phy_event(phy, HISI_PHYE_LINK_RESET);\n\t}\n\n\tif (irq_value & BIT(CHL_INT2_STP_LINK_TIMEOUT_OFF)) {\n\t\tu32 reg_value = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\tSTP_LINK_TIMEOUT_STATE);\n\n\t\tdev_warn(dev, \"phy%d stp link timeout (0x%x)\\n\",\n\t\t\t phy_no, reg_value);\n\t\tif (reg_value & BIT(4))\n\t\t\thisi_sas_notify_phy_event(phy, HISI_PHYE_LINK_RESET);\n\t}\n\n\tif (pci_dev->revision > 0x20 && (irq_value & msk)) {\n\t\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\t\tstruct sas_phy *sphy = sas_phy->phy;\n\n\t\tphy_get_events_v3_hw(hisi_hba, phy_no);\n\n\t\tif (irq_value & BIT(CHL_INT2_RX_INVLD_DW_OFF))\n\t\t\tdev_info(dev, \"phy%d invalid dword cnt:   %u\\n\", phy_no,\n\t\t\t\t sphy->invalid_dword_count);\n\n\t\tif (irq_value & BIT(CHL_INT2_RX_CODE_ERR_OFF))\n\t\t\tdev_info(dev, \"phy%d code violation cnt:  %u\\n\", phy_no,\n\t\t\t\t phy->code_violation_err_count);\n\n\t\tif (irq_value & BIT(CHL_INT2_RX_DISP_ERR_OFF))\n\t\t\tdev_info(dev, \"phy%d disparity error cnt: %u\\n\", phy_no,\n\t\t\t\t sphy->running_disparity_error_count);\n\t}\n\n\tif ((irq_value & BIT(CHL_INT2_RX_INVLD_DW_OFF)) &&\n\t    (pci_dev->revision == 0x20)) {\n\t\tu32 reg_value;\n\t\tint rc;\n\n\t\trc = hisi_sas_read32_poll_timeout_atomic(\n\t\t\t\tHILINK_ERR_DFX, reg_value,\n\t\t\t\t!((reg_value >> 8) & BIT(phy_no)),\n\t\t\t\t1000, 10000);\n\t\tif (rc)\n\t\t\thisi_sas_notify_phy_event(phy, HISI_PHYE_LINK_RESET);\n\t}\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT2, irq_value);\n}\n\nstatic void handle_chl_int0_v3_hw(struct hisi_hba *hisi_hba, int phy_no)\n{\n\tu32 irq_value0 = hisi_sas_phy_read32(hisi_hba, phy_no, CHL_INT0);\n\n\tif (irq_value0 & CHL_INT0_PHY_RDY_MSK)\n\t\thisi_sas_phy_oob_ready(hisi_hba, phy_no);\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, CHL_INT0,\n\t\t\t     irq_value0 & (~CHL_INT0_SL_RX_BCST_ACK_MSK)\n\t\t\t     & (~CHL_INT0_SL_PHY_ENABLE_MSK)\n\t\t\t     & (~CHL_INT0_NOT_RDY_MSK));\n}\n\nstatic irqreturn_t int_chnl_int_v3_hw(int irq_no, void *p)\n{\n\tstruct hisi_hba *hisi_hba = p;\n\tu32 irq_msk;\n\tint phy_no = 0;\n\n\tirq_msk = hisi_sas_read32(hisi_hba, CHNL_INT_STATUS)\n\t\t  & CHNL_INT_STS_MSK;\n\n\twhile (irq_msk) {\n\t\tif (irq_msk & (CHNL_INT_STS_INT0_MSK << (phy_no * CHNL_WIDTH)))\n\t\t\thandle_chl_int0_v3_hw(hisi_hba, phy_no);\n\n\t\tif (irq_msk & (CHNL_INT_STS_INT1_MSK << (phy_no * CHNL_WIDTH)))\n\t\t\thandle_chl_int1_v3_hw(hisi_hba, phy_no);\n\n\t\tif (irq_msk & (CHNL_INT_STS_INT2_MSK << (phy_no * CHNL_WIDTH)))\n\t\t\thandle_chl_int2_v3_hw(hisi_hba, phy_no);\n\n\t\tirq_msk &= ~(CHNL_INT_STS_PHY_MSK << (phy_no * CHNL_WIDTH));\n\t\tphy_no++;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct hisi_sas_hw_error multi_bit_ecc_errors[] = {\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_DQE_ECC_MB_OFF),\n\t\t.msk = HGC_DQE_ECC_MB_ADDR_MSK,\n\t\t.shift = HGC_DQE_ECC_MB_ADDR_OFF,\n\t\t.msg = \"hgc_dqe_eccbad_intr\",\n\t\t.reg = HGC_DQE_ECC_ADDR,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_IOST_ECC_MB_OFF),\n\t\t.msk = HGC_IOST_ECC_MB_ADDR_MSK,\n\t\t.shift = HGC_IOST_ECC_MB_ADDR_OFF,\n\t\t.msg = \"hgc_iost_eccbad_intr\",\n\t\t.reg = HGC_IOST_ECC_ADDR,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_ITCT_ECC_MB_OFF),\n\t\t.msk = HGC_ITCT_ECC_MB_ADDR_MSK,\n\t\t.shift = HGC_ITCT_ECC_MB_ADDR_OFF,\n\t\t.msg = \"hgc_itct_eccbad_intr\",\n\t\t.reg = HGC_ITCT_ECC_ADDR,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_IOSTLIST_ECC_MB_OFF),\n\t\t.msk = HGC_LM_DFX_STATUS2_IOSTLIST_MSK,\n\t\t.shift = HGC_LM_DFX_STATUS2_IOSTLIST_OFF,\n\t\t.msg = \"hgc_iostl_eccbad_intr\",\n\t\t.reg = HGC_LM_DFX_STATUS2,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_ITCTLIST_ECC_MB_OFF),\n\t\t.msk = HGC_LM_DFX_STATUS2_ITCTLIST_MSK,\n\t\t.shift = HGC_LM_DFX_STATUS2_ITCTLIST_OFF,\n\t\t.msg = \"hgc_itctl_eccbad_intr\",\n\t\t.reg = HGC_LM_DFX_STATUS2,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_CQE_ECC_MB_OFF),\n\t\t.msk = HGC_CQE_ECC_MB_ADDR_MSK,\n\t\t.shift = HGC_CQE_ECC_MB_ADDR_OFF,\n\t\t.msg = \"hgc_cqe_eccbad_intr\",\n\t\t.reg = HGC_CQE_ECC_ADDR,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_NCQ_MEM0_ECC_MB_OFF),\n\t\t.msk = HGC_RXM_DFX_STATUS14_MEM0_MSK,\n\t\t.shift = HGC_RXM_DFX_STATUS14_MEM0_OFF,\n\t\t.msg = \"rxm_mem0_eccbad_intr\",\n\t\t.reg = HGC_RXM_DFX_STATUS14,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_NCQ_MEM1_ECC_MB_OFF),\n\t\t.msk = HGC_RXM_DFX_STATUS14_MEM1_MSK,\n\t\t.shift = HGC_RXM_DFX_STATUS14_MEM1_OFF,\n\t\t.msg = \"rxm_mem1_eccbad_intr\",\n\t\t.reg = HGC_RXM_DFX_STATUS14,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_NCQ_MEM2_ECC_MB_OFF),\n\t\t.msk = HGC_RXM_DFX_STATUS14_MEM2_MSK,\n\t\t.shift = HGC_RXM_DFX_STATUS14_MEM2_OFF,\n\t\t.msg = \"rxm_mem2_eccbad_intr\",\n\t\t.reg = HGC_RXM_DFX_STATUS14,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_NCQ_MEM3_ECC_MB_OFF),\n\t\t.msk = HGC_RXM_DFX_STATUS15_MEM3_MSK,\n\t\t.shift = HGC_RXM_DFX_STATUS15_MEM3_OFF,\n\t\t.msg = \"rxm_mem3_eccbad_intr\",\n\t\t.reg = HGC_RXM_DFX_STATUS15,\n\t},\n\t{\n\t\t.irq_msk = BIT(SAS_ECC_INTR_OOO_RAM_ECC_MB_OFF),\n\t\t.msk = AM_ROB_ECC_ERR_ADDR_MSK,\n\t\t.shift = AM_ROB_ECC_ERR_ADDR_OFF,\n\t\t.msg = \"ooo_ram_eccbad_intr\",\n\t\t.reg = AM_ROB_ECC_ERR_ADDR,\n\t},\n};\n\nstatic void multi_bit_ecc_error_process_v3_hw(struct hisi_hba *hisi_hba,\n\t\t\t\t\t      u32 irq_value)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tconst struct hisi_sas_hw_error *ecc_error;\n\tu32 val;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(multi_bit_ecc_errors); i++) {\n\t\tecc_error = &multi_bit_ecc_errors[i];\n\t\tif (irq_value & ecc_error->irq_msk) {\n\t\t\tval = hisi_sas_read32(hisi_hba, ecc_error->reg);\n\t\t\tval &= ecc_error->msk;\n\t\t\tval >>= ecc_error->shift;\n\t\t\tdev_err(dev, \"%s (0x%x) found: mem addr is 0x%08X\\n\",\n\t\t\t\tecc_error->msg, irq_value, val);\n\t\t\tqueue_work(hisi_hba->wq, &hisi_hba->rst_work);\n\t\t}\n\t}\n}\n\nstatic void fatal_ecc_int_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tu32 irq_value, irq_msk;\n\n\tirq_msk = hisi_sas_read32(hisi_hba, SAS_ECC_INTR_MSK);\n\thisi_sas_write32(hisi_hba, SAS_ECC_INTR_MSK, 0xffffffff);\n\n\tirq_value = hisi_sas_read32(hisi_hba, SAS_ECC_INTR);\n\tif (irq_value)\n\t\tmulti_bit_ecc_error_process_v3_hw(hisi_hba, irq_value);\n\n\thisi_sas_write32(hisi_hba, SAS_ECC_INTR, irq_value);\n\thisi_sas_write32(hisi_hba, SAS_ECC_INTR_MSK, irq_msk);\n}\n\nstatic const struct hisi_sas_hw_error axi_error[] = {\n\t{ .msk = BIT(0), .msg = \"IOST_AXI_W_ERR\" },\n\t{ .msk = BIT(1), .msg = \"IOST_AXI_R_ERR\" },\n\t{ .msk = BIT(2), .msg = \"ITCT_AXI_W_ERR\" },\n\t{ .msk = BIT(3), .msg = \"ITCT_AXI_R_ERR\" },\n\t{ .msk = BIT(4), .msg = \"SATA_AXI_W_ERR\" },\n\t{ .msk = BIT(5), .msg = \"SATA_AXI_R_ERR\" },\n\t{ .msk = BIT(6), .msg = \"DQE_AXI_R_ERR\" },\n\t{ .msk = BIT(7), .msg = \"CQE_AXI_W_ERR\" },\n\t{}\n};\n\nstatic const struct hisi_sas_hw_error fifo_error[] = {\n\t{ .msk = BIT(8),  .msg = \"CQE_WINFO_FIFO\" },\n\t{ .msk = BIT(9),  .msg = \"CQE_MSG_FIFIO\" },\n\t{ .msk = BIT(10), .msg = \"GETDQE_FIFO\" },\n\t{ .msk = BIT(11), .msg = \"CMDP_FIFO\" },\n\t{ .msk = BIT(12), .msg = \"AWTCTRL_FIFO\" },\n\t{}\n};\n\nstatic const struct hisi_sas_hw_error fatal_axi_error[] = {\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_WP_DEPTH_OFF),\n\t\t.msg = \"write pointer and depth\",\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_IPTT_SLOT_NOMATCH_OFF),\n\t\t.msg = \"iptt no match slot\",\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_RP_DEPTH_OFF),\n\t\t.msg = \"read pointer and depth\",\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_AXI_OFF),\n\t\t.reg = HGC_AXI_FIFO_ERR_INFO,\n\t\t.sub = axi_error,\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_FIFO_OFF),\n\t\t.reg = HGC_AXI_FIFO_ERR_INFO,\n\t\t.sub = fifo_error,\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_LM_OFF),\n\t\t.msg = \"LM add/fetch list\",\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_ABT_OFF),\n\t\t.msg = \"SAS_HGC_ABT fetch LM list\",\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_DQE_POISON_OFF),\n\t\t.msg = \"read dqe poison\",\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_IOST_POISON_OFF),\n\t\t.msg = \"read iost poison\",\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_ITCT_POISON_OFF),\n\t\t.msg = \"read itct poison\",\n\t},\n\t{\n\t\t.irq_msk = BIT(ENT_INT_SRC3_ITCT_NCQ_POISON_OFF),\n\t\t.msg = \"read itct ncq poison\",\n\t},\n\n};\n\nstatic irqreturn_t fatal_axi_int_v3_hw(int irq_no, void *p)\n{\n\tu32 irq_value, irq_msk;\n\tstruct hisi_hba *hisi_hba = p;\n\tstruct device *dev = hisi_hba->dev;\n\tstruct pci_dev *pdev = hisi_hba->pci_dev;\n\tint i;\n\n\tirq_msk = hisi_sas_read32(hisi_hba, ENT_INT_SRC_MSK3);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK3, irq_msk | 0x1df00);\n\n\tirq_value = hisi_sas_read32(hisi_hba, ENT_INT_SRC3);\n\tirq_value &= ~irq_msk;\n\n\tfor (i = 0; i < ARRAY_SIZE(fatal_axi_error); i++) {\n\t\tconst struct hisi_sas_hw_error *error = &fatal_axi_error[i];\n\n\t\tif (!(irq_value & error->irq_msk))\n\t\t\tcontinue;\n\n\t\tif (error->sub) {\n\t\t\tconst struct hisi_sas_hw_error *sub = error->sub;\n\t\t\tu32 err_value = hisi_sas_read32(hisi_hba, error->reg);\n\n\t\t\tfor (; sub->msk || sub->msg; sub++) {\n\t\t\t\tif (!(err_value & sub->msk))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdev_err(dev, \"%s error (0x%x) found!\\n\",\n\t\t\t\t\tsub->msg, irq_value);\n\t\t\t\tqueue_work(hisi_hba->wq, &hisi_hba->rst_work);\n\t\t\t}\n\t\t} else {\n\t\t\tdev_err(dev, \"%s error (0x%x) found!\\n\",\n\t\t\t\terror->msg, irq_value);\n\t\t\tqueue_work(hisi_hba->wq, &hisi_hba->rst_work);\n\t\t}\n\n\t\tif (pdev->revision < 0x21) {\n\t\t\tu32 reg_val;\n\n\t\t\treg_val = hisi_sas_read32(hisi_hba,\n\t\t\t\t\t\t  AXI_MASTER_CFG_BASE +\n\t\t\t\t\t\t  AM_CTRL_GLOBAL);\n\t\t\treg_val |= AM_CTRL_SHUTDOWN_REQ_MSK;\n\t\t\thisi_sas_write32(hisi_hba, AXI_MASTER_CFG_BASE +\n\t\t\t\t\t AM_CTRL_GLOBAL, reg_val);\n\t\t}\n\t}\n\n\tfatal_ecc_int_v3_hw(hisi_hba);\n\n\tif (irq_value & BIT(ENT_INT_SRC3_ITC_INT_OFF)) {\n\t\tu32 reg_val = hisi_sas_read32(hisi_hba, ITCT_CLR);\n\t\tu32 dev_id = reg_val & ITCT_DEV_MSK;\n\t\tstruct hisi_sas_device *sas_dev =\n\t\t\t\t&hisi_hba->devices[dev_id];\n\n\t\thisi_sas_write32(hisi_hba, ITCT_CLR, 0);\n\t\tdev_dbg(dev, \"clear ITCT ok\\n\");\n\t\tcomplete(sas_dev->completion);\n\t}\n\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC3, irq_value & 0x1df00);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK3, irq_msk);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool is_ncq_err_v3_hw(struct hisi_sas_complete_v3_hdr *complete_hdr)\n{\n\tu32 dw0, dw3;\n\n\tdw0 = le32_to_cpu(complete_hdr->dw0);\n\tdw3 = le32_to_cpu(complete_hdr->dw3);\n\n\treturn (dw0 & ERR_PHASE_RESPONSE_FRAME_REV_STAGE_MSK) &&\n\t       (dw3 & FIS_TYPE_SDB_MSK) &&\n\t       (dw3 & FIS_ATA_STATUS_ERR_MSK);\n}\n\nstatic bool\nslot_err_v3_hw(struct hisi_hba *hisi_hba, struct sas_task *task,\n\t       struct hisi_sas_slot *slot)\n{\n\tstruct task_status_struct *ts = &task->task_status;\n\tstruct hisi_sas_complete_v3_hdr *complete_queue =\n\t\t\thisi_hba->complete_hdr[slot->cmplt_queue];\n\tstruct hisi_sas_complete_v3_hdr *complete_hdr =\n\t\t\t&complete_queue[slot->cmplt_queue_slot];\n\tstruct hisi_sas_err_record_v3 *record =\n\t\t\thisi_sas_status_buf_addr_mem(slot);\n\tu32 dma_rx_err_type = le32_to_cpu(record->dma_rx_err_type);\n\tu32 trans_tx_fail_type = le32_to_cpu(record->trans_tx_fail_type);\n\tu16 sipc_rx_err_type = le16_to_cpu(record->sipc_rx_err_type);\n\tu32 dw3 = le32_to_cpu(complete_hdr->dw3);\n\tu32 dw0 = le32_to_cpu(complete_hdr->dw0);\n\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SSP:\n\t\tif (dma_rx_err_type & RX_DATA_LEN_UNDERFLOW_MSK) {\n\t\t\t \n\t\t\tif (!(dw0 & CMPLT_HDR_RSPNS_GOOD_MSK) &&\n\t\t\t    (dw0 & CMPLT_HDR_RSPNS_XFRD_MSK))\n\t\t\t\treturn false;\n\n\t\t\tts->residual = trans_tx_fail_type;\n\t\t\tts->stat = SAS_DATA_UNDERRUN;\n\t\t} else if (dw3 & CMPLT_HDR_IO_IN_TARGET_MSK) {\n\t\t\tts->stat = SAS_QUEUE_FULL;\n\t\t\tslot->abort = 1;\n\t\t} else {\n\t\t\tts->stat = SAS_OPEN_REJECT;\n\t\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\t}\n\t\tbreak;\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\tcase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:\n\t\tif ((dw0 & CMPLT_HDR_RSPNS_XFRD_MSK) &&\n\t\t    (sipc_rx_err_type & RX_FIS_STATUS_ERR_MSK)) {\n\t\t\tts->stat = SAS_PROTO_RESPONSE;\n\t\t} else if (dma_rx_err_type & RX_DATA_LEN_UNDERFLOW_MSK) {\n\t\t\tts->residual = trans_tx_fail_type;\n\t\t\tts->stat = SAS_DATA_UNDERRUN;\n\t\t} else if ((dw3 & CMPLT_HDR_IO_IN_TARGET_MSK) ||\n\t\t\t   (dw3 & SATA_DISK_IN_ERROR_STATUS_MSK)) {\n\t\t\tts->stat = SAS_PHY_DOWN;\n\t\t\tslot->abort = 1;\n\t\t} else {\n\t\t\tts->stat = SAS_OPEN_REJECT;\n\t\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\t}\n\t\tif (dw0 & CMPLT_HDR_RSPNS_XFRD_MSK)\n\t\t\thisi_sas_sata_done(task, slot);\n\t\tbreak;\n\tcase SAS_PROTOCOL_SMP:\n\t\tts->stat = SAS_SAM_STAT_CHECK_CONDITION;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nstatic void slot_complete_v3_hw(struct hisi_hba *hisi_hba,\n\t\t\t\tstruct hisi_sas_slot *slot)\n{\n\tstruct sas_task *task = slot->task;\n\tstruct hisi_sas_device *sas_dev;\n\tstruct device *dev = hisi_hba->dev;\n\tstruct task_status_struct *ts;\n\tstruct domain_device *device;\n\tstruct sas_ha_struct *ha;\n\tstruct hisi_sas_complete_v3_hdr *complete_queue =\n\t\t\thisi_hba->complete_hdr[slot->cmplt_queue];\n\tstruct hisi_sas_complete_v3_hdr *complete_hdr =\n\t\t\t&complete_queue[slot->cmplt_queue_slot];\n\tunsigned long flags;\n\tbool is_internal = slot->is_internal;\n\tu32 dw0, dw1, dw3;\n\n\tif (unlikely(!task || !task->lldd_task || !task->dev))\n\t\treturn;\n\n\tts = &task->task_status;\n\tdevice = task->dev;\n\tha = device->port->ha;\n\tsas_dev = device->lldd_dev;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\ttask->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tmemset(ts, 0, sizeof(*ts));\n\tts->resp = SAS_TASK_COMPLETE;\n\n\tif (unlikely(!sas_dev)) {\n\t\tdev_dbg(dev, \"slot complete: port has not device\\n\");\n\t\tts->stat = SAS_PHY_DOWN;\n\t\tgoto out;\n\t}\n\n\tdw0 = le32_to_cpu(complete_hdr->dw0);\n\tdw1 = le32_to_cpu(complete_hdr->dw1);\n\tdw3 = le32_to_cpu(complete_hdr->dw3);\n\n\t \n\tswitch ((dw0 & CMPLT_HDR_ABORT_STAT_MSK) >> CMPLT_HDR_ABORT_STAT_OFF) {\n\tcase STAT_IO_ABORTED:\n\t\t \n\t\tts->stat = SAS_ABORTED_TASK;\n\t\tgoto out;\n\tcase STAT_IO_COMPLETE:\n\t\t \n\t\tts->stat = TMF_RESP_FUNC_SUCC;\n\t\tgoto out;\n\tcase STAT_IO_NO_DEVICE:\n\t\tts->stat = TMF_RESP_FUNC_COMPLETE;\n\t\tgoto out;\n\tcase STAT_IO_NOT_VALID:\n\t\t \n\t\tts->stat = TMF_RESP_FUNC_FAILED;\n\t\tgoto out;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif ((dw0 & CMPLT_HDR_CMPLT_MSK) == 0x3) {\n\t\tu32 *error_info = hisi_sas_status_buf_addr_mem(slot);\n\n\t\tif (slot_err_v3_hw(hisi_hba, task, slot)) {\n\t\t\tif (ts->stat != SAS_DATA_UNDERRUN)\n\t\t\t\tdev_info(dev, \"erroneous completion iptt=%d task=%pK dev id=%d addr=%016llx CQ hdr: 0x%x 0x%x 0x%x 0x%x Error info: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t\t\tslot->idx, task, sas_dev->device_id,\n\t\t\t\t\tSAS_ADDR(device->sas_addr),\n\t\t\t\t\tdw0, dw1, complete_hdr->act, dw3,\n\t\t\t\t\terror_info[0], error_info[1],\n\t\t\t\t\terror_info[2], error_info[3]);\n\t\t\tif (unlikely(slot->abort)) {\n\t\t\t\tif (dev_is_sata(device) && task->ata_task.use_ncq)\n\t\t\t\t\tsas_ata_device_link_abort(device, true);\n\t\t\t\telse\n\t\t\t\t\tsas_task_abort(task);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SSP: {\n\t\tstruct ssp_response_iu *iu =\n\t\t\thisi_sas_status_buf_addr_mem(slot) +\n\t\t\tsizeof(struct hisi_sas_err_record);\n\n\t\tsas_ssp_task_response(dev, task, iu);\n\t\tbreak;\n\t}\n\tcase SAS_PROTOCOL_SMP: {\n\t\tstruct scatterlist *sg_resp = &task->smp_task.smp_resp;\n\t\tvoid *to = page_address(sg_page(sg_resp));\n\n\t\tts->stat = SAS_SAM_STAT_GOOD;\n\n\t\tmemcpy(to + sg_resp->offset,\n\t\t\thisi_sas_status_buf_addr_mem(slot) +\n\t\t       sizeof(struct hisi_sas_err_record),\n\t\t       sg_resp->length);\n\t\tbreak;\n\t}\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\tcase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:\n\t\tts->stat = SAS_SAM_STAT_GOOD;\n\t\tif (dw0 & CMPLT_HDR_RSPNS_XFRD_MSK)\n\t\t\thisi_sas_sata_done(task, slot);\n\t\tbreak;\n\tdefault:\n\t\tts->stat = SAS_SAM_STAT_CHECK_CONDITION;\n\t\tbreak;\n\t}\n\n\tif (!slot->port->port_attached) {\n\t\tdev_warn(dev, \"slot complete: port %d has removed\\n\",\n\t\t\tslot->port->sas_port.id);\n\t\tts->stat = SAS_PHY_DOWN;\n\t}\n\nout:\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (task->task_state_flags & SAS_TASK_STATE_ABORTED) {\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\tdev_info(dev, \"slot complete: task(%pK) aborted\\n\", task);\n\t\treturn;\n\t}\n\ttask->task_state_flags |= SAS_TASK_STATE_DONE;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\thisi_sas_slot_task_free(hisi_hba, task, slot, true);\n\n\tif (!is_internal && (task->task_proto != SAS_PROTOCOL_SMP)) {\n\t\tspin_lock_irqsave(&device->done_lock, flags);\n\t\tif (test_bit(SAS_HA_FROZEN, &ha->state)) {\n\t\t\tspin_unlock_irqrestore(&device->done_lock, flags);\n\t\t\tdev_info(dev, \"slot complete: task(%pK) ignored\\n \",\n\t\t\t\t task);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore(&device->done_lock, flags);\n\t}\n\n\tif (task->task_done)\n\t\ttask->task_done(task);\n}\n\nstatic int complete_v3_hw(struct hisi_sas_cq *cq)\n{\n\tstruct hisi_sas_complete_v3_hdr *complete_queue;\n\tstruct hisi_hba *hisi_hba = cq->hisi_hba;\n\tu32 rd_point, wr_point;\n\tint queue = cq->id;\n\tint completed;\n\n\trd_point = cq->rd_point;\n\tcomplete_queue = hisi_hba->complete_hdr[queue];\n\n\twr_point = hisi_sas_read32(hisi_hba, COMPL_Q_0_WR_PTR +\n\t\t\t\t   (0x14 * queue));\n\tcompleted = (wr_point + HISI_SAS_QUEUE_SLOTS - rd_point) % HISI_SAS_QUEUE_SLOTS;\n\n\twhile (rd_point != wr_point) {\n\t\tstruct hisi_sas_complete_v3_hdr *complete_hdr;\n\t\tstruct device *dev = hisi_hba->dev;\n\t\tstruct hisi_sas_slot *slot;\n\t\tu32 dw0, dw1, dw3;\n\t\tint iptt;\n\n\t\tcomplete_hdr = &complete_queue[rd_point];\n\t\tdw0 = le32_to_cpu(complete_hdr->dw0);\n\t\tdw1 = le32_to_cpu(complete_hdr->dw1);\n\t\tdw3 = le32_to_cpu(complete_hdr->dw3);\n\n\t\tiptt = dw1 & CMPLT_HDR_IPTT_MSK;\n\t\tif (unlikely((dw0 & CMPLT_HDR_CMPLT_MSK) == 0x3) &&\n\t\t\t     (dw3 & CMPLT_HDR_SATA_DISK_ERR_MSK)) {\n\t\t\tint device_id = (dw1 & CMPLT_HDR_DEV_ID_MSK) >>\n\t\t\t\t\tCMPLT_HDR_DEV_ID_OFF;\n\t\t\tstruct hisi_sas_itct *itct =\n\t\t\t\t&hisi_hba->itct[device_id];\n\t\t\tstruct hisi_sas_device *sas_dev =\n\t\t\t\t&hisi_hba->devices[device_id];\n\t\t\tstruct domain_device *device = sas_dev->sas_device;\n\n\t\t\tdev_err(dev, \"erroneous completion disk err dev id=%d sas_addr=0x%llx CQ hdr: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t\tdevice_id, itct->sas_addr, dw0, dw1,\n\t\t\t\tcomplete_hdr->act, dw3);\n\n\t\t\tif (is_ncq_err_v3_hw(complete_hdr))\n\t\t\t\tsas_dev->dev_status = HISI_SAS_DEV_NCQ_ERR;\n\n\t\t\tsas_ata_device_link_abort(device, true);\n\t\t} else if (likely(iptt < HISI_SAS_COMMAND_ENTRIES_V3_HW)) {\n\t\t\tslot = &hisi_hba->slot_info[iptt];\n\t\t\tslot->cmplt_queue_slot = rd_point;\n\t\t\tslot->cmplt_queue = queue;\n\t\t\tslot_complete_v3_hw(hisi_hba, slot);\n\t\t} else\n\t\t\tdev_err(dev, \"IPTT %d is invalid, discard it.\\n\", iptt);\n\n\t\tif (++rd_point >= HISI_SAS_QUEUE_SLOTS)\n\t\t\trd_point = 0;\n\t}\n\n\t \n\tcq->rd_point = rd_point;\n\thisi_sas_write32(hisi_hba, COMPL_Q_0_RD_PTR + (0x14 * queue), rd_point);\n\n\treturn completed;\n}\n\nstatic int queue_complete_v3_hw(struct Scsi_Host *shost, unsigned int queue)\n{\n\tstruct hisi_hba *hisi_hba = shost_priv(shost);\n\tstruct hisi_sas_cq *cq = &hisi_hba->cq[queue];\n\tint completed;\n\n\tspin_lock(&cq->poll_lock);\n\tcompleted = complete_v3_hw(cq);\n\tspin_unlock(&cq->poll_lock);\n\n\treturn completed;\n}\n\nstatic irqreturn_t cq_thread_v3_hw(int irq_no, void *p)\n{\n\tstruct hisi_sas_cq *cq = p;\n\n\tcomplete_v3_hw(cq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cq_interrupt_v3_hw(int irq_no, void *p)\n{\n\tstruct hisi_sas_cq *cq = p;\n\tstruct hisi_hba *hisi_hba = cq->hisi_hba;\n\tint queue = cq->id;\n\n\thisi_sas_write32(hisi_hba, OQ_INT_SRC, 1 << queue);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic void hisi_sas_v3_free_vectors(void *data)\n{\n\tstruct pci_dev *pdev = data;\n\n\tpci_free_irq_vectors(pdev);\n}\n\nstatic int interrupt_preinit_v3_hw(struct hisi_hba *hisi_hba)\n{\n\t \n\tint max_msi = HISI_SAS_MSI_COUNT_V3_HW;\n\tint vectors, min_msi;\n\tstruct Scsi_Host *shost = hisi_hba->shost;\n\tstruct pci_dev *pdev = hisi_hba->pci_dev;\n\tstruct irq_affinity desc = {\n\t\t.pre_vectors = BASE_VECTORS_V3_HW,\n\t};\n\n\tmin_msi = MIN_AFFINE_VECTORS_V3_HW;\n\tvectors = pci_alloc_irq_vectors_affinity(pdev,\n\t\t\t\t\t\t min_msi, max_msi,\n\t\t\t\t\t\t PCI_IRQ_MSI |\n\t\t\t\t\t\t PCI_IRQ_AFFINITY,\n\t\t\t\t\t\t &desc);\n\tif (vectors < 0)\n\t\treturn -ENOENT;\n\n\n\thisi_hba->cq_nvecs = vectors - BASE_VECTORS_V3_HW - hisi_hba->iopoll_q_cnt;\n\tshost->nr_hw_queues = hisi_hba->cq_nvecs + hisi_hba->iopoll_q_cnt;\n\n\treturn devm_add_action(&pdev->dev, hisi_sas_v3_free_vectors, pdev);\n}\n\nstatic int interrupt_init_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tstruct pci_dev *pdev = hisi_hba->pci_dev;\n\tint rc, i;\n\n\trc = devm_request_irq(dev, pci_irq_vector(pdev, 1),\n\t\t\t      int_phy_up_down_bcast_v3_hw, 0,\n\t\t\t      DRV_NAME \" phy\", hisi_hba);\n\tif (rc) {\n\t\tdev_err(dev, \"could not request phy interrupt, rc=%d\\n\", rc);\n\t\treturn -ENOENT;\n\t}\n\n\trc = devm_request_irq(dev, pci_irq_vector(pdev, 2),\n\t\t\t      int_chnl_int_v3_hw, 0,\n\t\t\t      DRV_NAME \" channel\", hisi_hba);\n\tif (rc) {\n\t\tdev_err(dev, \"could not request chnl interrupt, rc=%d\\n\", rc);\n\t\treturn -ENOENT;\n\t}\n\n\trc = devm_request_irq(dev, pci_irq_vector(pdev, 11),\n\t\t\t      fatal_axi_int_v3_hw, 0,\n\t\t\t      DRV_NAME \" fatal\", hisi_hba);\n\tif (rc) {\n\t\tdev_err(dev, \"could not request fatal interrupt, rc=%d\\n\", rc);\n\t\treturn -ENOENT;\n\t}\n\n\tif (hisi_sas_intr_conv)\n\t\tdev_info(dev, \"Enable interrupt converge\\n\");\n\n\tfor (i = 0; i < hisi_hba->cq_nvecs; i++) {\n\t\tstruct hisi_sas_cq *cq = &hisi_hba->cq[i];\n\t\tint nr = hisi_sas_intr_conv ? 16 : 16 + i;\n\t\tunsigned long irqflags = hisi_sas_intr_conv ? IRQF_SHARED :\n\t\t\t\t\t\t\t      IRQF_ONESHOT;\n\n\t\tcq->irq_no = pci_irq_vector(pdev, nr);\n\t\trc = devm_request_threaded_irq(dev, cq->irq_no,\n\t\t\t\t      cq_interrupt_v3_hw,\n\t\t\t\t      cq_thread_v3_hw,\n\t\t\t\t      irqflags,\n\t\t\t\t      DRV_NAME \" cq\", cq);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"could not request cq%d interrupt, rc=%d\\n\",\n\t\t\t\ti, rc);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tcq->irq_mask = pci_irq_get_affinity(pdev, i + BASE_VECTORS_V3_HW);\n\t\tif (!cq->irq_mask) {\n\t\t\tdev_err(dev, \"could not get cq%d irq affinity!\\n\", i);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hisi_sas_v3_init(struct hisi_hba *hisi_hba)\n{\n\tint rc;\n\n\trc = hw_init_v3_hw(hisi_hba);\n\tif (rc)\n\t\treturn rc;\n\n\trc = interrupt_init_v3_hw(hisi_hba);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic void phy_set_linkrate_v3_hw(struct hisi_hba *hisi_hba, int phy_no,\n\t\tstruct sas_phy_linkrates *r)\n{\n\tenum sas_linkrate max = r->maximum_linkrate;\n\tu32 prog_phy_link_rate = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\t\t     PROG_PHY_LINK_RATE);\n\n\tprog_phy_link_rate &= ~CFG_PROG_PHY_LINK_RATE_MSK;\n\tprog_phy_link_rate |= hisi_sas_get_prog_phy_linkrate_mask(max);\n\thisi_sas_phy_write32(hisi_hba, phy_no, PROG_PHY_LINK_RATE,\n\t\t\t     prog_phy_link_rate);\n}\n\nstatic void interrupt_disable_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct pci_dev *pdev = hisi_hba->pci_dev;\n\tint i;\n\n\tsynchronize_irq(pci_irq_vector(pdev, 1));\n\tsynchronize_irq(pci_irq_vector(pdev, 2));\n\tsynchronize_irq(pci_irq_vector(pdev, 11));\n\tfor (i = 0; i < hisi_hba->queue_count; i++)\n\t\thisi_sas_write32(hisi_hba, OQ0_INT_SRC_MSK + 0x4 * i, 0x1);\n\n\tfor (i = 0; i < hisi_hba->cq_nvecs; i++)\n\t\tsynchronize_irq(pci_irq_vector(pdev, i + 16));\n\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK1, 0xffffffff);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK2, 0xffffffff);\n\thisi_sas_write32(hisi_hba, ENT_INT_SRC_MSK3, 0xffffffff);\n\thisi_sas_write32(hisi_hba, SAS_ECC_INTR_MSK, 0xffffffff);\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT1_MSK, 0xffffffff);\n\t\thisi_sas_phy_write32(hisi_hba, i, CHL_INT2_MSK, 0xffffffff);\n\t\thisi_sas_phy_write32(hisi_hba, i, PHYCTRL_NOT_RDY_MSK, 0x1);\n\t\thisi_sas_phy_write32(hisi_hba, i, PHYCTRL_PHY_ENA_MSK, 0x1);\n\t\thisi_sas_phy_write32(hisi_hba, i, SL_RX_BCAST_CHK_MSK, 0x1);\n\t}\n}\n\nstatic u32 get_phys_state_v3_hw(struct hisi_hba *hisi_hba)\n{\n\treturn hisi_sas_read32(hisi_hba, PHY_STATE);\n}\n\nstatic int disable_host_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tu32 status, reg_val;\n\tint rc;\n\n\thisi_sas_sync_poll_cqs(hisi_hba);\n\thisi_sas_write32(hisi_hba, DLVRY_QUEUE_ENABLE, 0x0);\n\n\thisi_sas_stop_phys(hisi_hba);\n\n\tmdelay(10);\n\n\treg_val = hisi_sas_read32(hisi_hba, AXI_MASTER_CFG_BASE +\n\t\t\t\t  AM_CTRL_GLOBAL);\n\treg_val |= AM_CTRL_SHUTDOWN_REQ_MSK;\n\thisi_sas_write32(hisi_hba, AXI_MASTER_CFG_BASE +\n\t\t\t AM_CTRL_GLOBAL, reg_val);\n\n\t \n\trc = hisi_sas_read32_poll_timeout(AXI_MASTER_CFG_BASE +\n\t\t\t\t\t  AM_CURR_TRANS_RETURN, status,\n\t\t\t\t\t  status == 0x3, 10, 100);\n\tif (rc) {\n\t\tdev_err(dev, \"axi bus is not idle, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int soft_reset_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tint rc;\n\n\tinterrupt_disable_v3_hw(hisi_hba);\n\trc = disable_host_v3_hw(hisi_hba);\n\tif (rc) {\n\t\tdev_err(dev, \"soft reset: disable host failed rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\thisi_sas_init_mem(hisi_hba);\n\n\treturn hw_init_v3_hw(hisi_hba);\n}\n\nstatic int write_gpio_v3_hw(struct hisi_hba *hisi_hba, u8 reg_type,\n\t\t\tu8 reg_index, u8 reg_count, u8 *write_data)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tu32 *data = (u32 *)write_data;\n\tint i;\n\n\tswitch (reg_type) {\n\tcase SAS_GPIO_REG_TX:\n\t\tif ((reg_index + reg_count) > ((hisi_hba->n_phy + 3) / 4)) {\n\t\t\tdev_err(dev, \"write gpio: invalid reg range[%d, %d]\\n\",\n\t\t\t\treg_index, reg_index + reg_count - 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < reg_count; i++)\n\t\t\thisi_sas_write32(hisi_hba,\n\t\t\t\t\t SAS_GPIO_TX_0_1 + (reg_index + i) * 4,\n\t\t\t\t\t data[i]);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"write gpio: unsupported or bad reg type %d\\n\",\n\t\t\treg_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void wait_cmds_complete_timeout_v3_hw(struct hisi_hba *hisi_hba,\n\t\t\t\t\t     int delay_ms, int timeout_ms)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tint entries, entries_old = 0, time;\n\n\tfor (time = 0; time < timeout_ms; time += delay_ms) {\n\t\tentries = hisi_sas_read32(hisi_hba, CQE_SEND_CNT);\n\t\tif (entries == entries_old)\n\t\t\tbreak;\n\n\t\tentries_old = entries;\n\t\tmsleep(delay_ms);\n\t}\n\n\tif (time >= timeout_ms) {\n\t\tdev_dbg(dev, \"Wait commands complete timeout!\\n\");\n\t\treturn;\n\t}\n\n\tdev_dbg(dev, \"wait commands complete %dms\\n\", time);\n}\n\nstatic ssize_t intr_conv_v3_hw_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", hisi_sas_intr_conv);\n}\nstatic DEVICE_ATTR_RO(intr_conv_v3_hw);\n\nstatic void config_intr_coal_v3_hw(struct hisi_hba *hisi_hba)\n{\n\t \n\thisi_sas_stop_phys(hisi_hba);\n\n\tif (hisi_hba->intr_coal_ticks == 0 ||\n\t    hisi_hba->intr_coal_count == 0) {\n\t\thisi_sas_write32(hisi_hba, INT_COAL_EN, 0x1);\n\t\thisi_sas_write32(hisi_hba, OQ_INT_COAL_TIME, 0x1);\n\t\thisi_sas_write32(hisi_hba, OQ_INT_COAL_CNT, 0x1);\n\t} else {\n\t\thisi_sas_write32(hisi_hba, INT_COAL_EN, 0x3);\n\t\thisi_sas_write32(hisi_hba, OQ_INT_COAL_TIME,\n\t\t\t\t hisi_hba->intr_coal_ticks);\n\t\thisi_sas_write32(hisi_hba, OQ_INT_COAL_CNT,\n\t\t\t\t hisi_hba->intr_coal_count);\n\t}\n\tphys_init_v3_hw(hisi_hba);\n}\n\nstatic ssize_t intr_coal_ticks_v3_hw_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct hisi_hba *hisi_hba = shost_priv(shost);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\",\n\t\t\t hisi_hba->intr_coal_ticks);\n}\n\nstatic ssize_t intr_coal_ticks_v3_hw_store(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct hisi_hba *hisi_hba = shost_priv(shost);\n\tu32 intr_coal_ticks;\n\tint ret;\n\n\tret = kstrtou32(buf, 10, &intr_coal_ticks);\n\tif (ret) {\n\t\tdev_err(dev, \"Input data of interrupt coalesce unmatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (intr_coal_ticks >= BIT(24)) {\n\t\tdev_err(dev, \"intr_coal_ticks must be less than 2^24!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thisi_hba->intr_coal_ticks = intr_coal_ticks;\n\n\tconfig_intr_coal_v3_hw(hisi_hba);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(intr_coal_ticks_v3_hw);\n\nstatic ssize_t intr_coal_count_v3_hw_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute\n\t\t\t\t\t  *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct hisi_hba *hisi_hba = shost_priv(shost);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\",\n\t\t\t hisi_hba->intr_coal_count);\n}\n\nstatic ssize_t intr_coal_count_v3_hw_store(struct device *dev,\n\t\tstruct device_attribute\n\t\t*attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct hisi_hba *hisi_hba = shost_priv(shost);\n\tu32 intr_coal_count;\n\tint ret;\n\n\tret = kstrtou32(buf, 10, &intr_coal_count);\n\tif (ret) {\n\t\tdev_err(dev, \"Input data of interrupt coalesce unmatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (intr_coal_count >= BIT(8)) {\n\t\tdev_err(dev, \"intr_coal_count must be less than 2^8!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thisi_hba->intr_coal_count = intr_coal_count;\n\n\tconfig_intr_coal_v3_hw(hisi_hba);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(intr_coal_count_v3_hw);\n\nstatic ssize_t iopoll_q_cnt_v3_hw_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute\n\t\t\t\t\t  *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct hisi_hba *hisi_hba = shost_priv(shost);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\",\n\t\t\t hisi_hba->iopoll_q_cnt);\n}\nstatic DEVICE_ATTR_RO(iopoll_q_cnt_v3_hw);\n\nstatic int slave_configure_v3_hw(struct scsi_device *sdev)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(&sdev->sdev_gendev);\n\tstruct hisi_hba *hisi_hba = shost_priv(shost);\n\tint ret = hisi_sas_slave_configure(sdev);\n\tstruct device *dev = hisi_hba->dev;\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (sdev->type == TYPE_ENCLOSURE)\n\t\treturn 0;\n\n\tif (!device_link_add(&sdev->sdev_gendev, dev,\n\t\t\t     DL_FLAG_PM_RUNTIME | DL_FLAG_RPM_ACTIVE)) {\n\t\tif (pm_runtime_enabled(dev)) {\n\t\t\tdev_info(dev, \"add device link failed, disable runtime PM for the host\\n\");\n\t\t\tpm_runtime_disable(dev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct attribute *host_v3_hw_attrs[] = {\n\t&dev_attr_phy_event_threshold.attr,\n\t&dev_attr_intr_conv_v3_hw.attr,\n\t&dev_attr_intr_coal_ticks_v3_hw.attr,\n\t&dev_attr_intr_coal_count_v3_hw.attr,\n\t&dev_attr_iopoll_q_cnt_v3_hw.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(host_v3_hw);\n\n#define HISI_SAS_DEBUGFS_REG(x) {#x, x}\n\nstruct hisi_sas_debugfs_reg_lu {\n\tchar *name;\n\tint off;\n};\n\nstruct hisi_sas_debugfs_reg {\n\tconst struct hisi_sas_debugfs_reg_lu *lu;\n\tint count;\n\tint base_off;\n};\n\nstatic const struct hisi_sas_debugfs_reg_lu debugfs_port_reg_lu[] = {\n\tHISI_SAS_DEBUGFS_REG(PHY_CFG),\n\tHISI_SAS_DEBUGFS_REG(HARD_PHY_LINKRATE),\n\tHISI_SAS_DEBUGFS_REG(PROG_PHY_LINK_RATE),\n\tHISI_SAS_DEBUGFS_REG(PHY_CTRL),\n\tHISI_SAS_DEBUGFS_REG(SL_CFG),\n\tHISI_SAS_DEBUGFS_REG(AIP_LIMIT),\n\tHISI_SAS_DEBUGFS_REG(SL_CONTROL),\n\tHISI_SAS_DEBUGFS_REG(RX_PRIMS_STATUS),\n\tHISI_SAS_DEBUGFS_REG(TX_ID_DWORD0),\n\tHISI_SAS_DEBUGFS_REG(TX_ID_DWORD1),\n\tHISI_SAS_DEBUGFS_REG(TX_ID_DWORD2),\n\tHISI_SAS_DEBUGFS_REG(TX_ID_DWORD3),\n\tHISI_SAS_DEBUGFS_REG(TX_ID_DWORD4),\n\tHISI_SAS_DEBUGFS_REG(TX_ID_DWORD5),\n\tHISI_SAS_DEBUGFS_REG(TX_ID_DWORD6),\n\tHISI_SAS_DEBUGFS_REG(TXID_AUTO),\n\tHISI_SAS_DEBUGFS_REG(RX_IDAF_DWORD0),\n\tHISI_SAS_DEBUGFS_REG(RXOP_CHECK_CFG_H),\n\tHISI_SAS_DEBUGFS_REG(STP_LINK_TIMER),\n\tHISI_SAS_DEBUGFS_REG(STP_LINK_TIMEOUT_STATE),\n\tHISI_SAS_DEBUGFS_REG(CON_CFG_DRIVER),\n\tHISI_SAS_DEBUGFS_REG(SAS_SSP_CON_TIMER_CFG),\n\tHISI_SAS_DEBUGFS_REG(SAS_SMP_CON_TIMER_CFG),\n\tHISI_SAS_DEBUGFS_REG(SAS_STP_CON_TIMER_CFG),\n\tHISI_SAS_DEBUGFS_REG(CHL_INT0),\n\tHISI_SAS_DEBUGFS_REG(CHL_INT1),\n\tHISI_SAS_DEBUGFS_REG(CHL_INT2),\n\tHISI_SAS_DEBUGFS_REG(CHL_INT0_MSK),\n\tHISI_SAS_DEBUGFS_REG(CHL_INT1_MSK),\n\tHISI_SAS_DEBUGFS_REG(CHL_INT2_MSK),\n\tHISI_SAS_DEBUGFS_REG(SAS_EC_INT_COAL_TIME),\n\tHISI_SAS_DEBUGFS_REG(CHL_INT_COAL_EN),\n\tHISI_SAS_DEBUGFS_REG(SAS_RX_TRAIN_TIMER),\n\tHISI_SAS_DEBUGFS_REG(PHY_CTRL_RDY_MSK),\n\tHISI_SAS_DEBUGFS_REG(PHYCTRL_NOT_RDY_MSK),\n\tHISI_SAS_DEBUGFS_REG(PHYCTRL_DWS_RESET_MSK),\n\tHISI_SAS_DEBUGFS_REG(PHYCTRL_PHY_ENA_MSK),\n\tHISI_SAS_DEBUGFS_REG(SL_RX_BCAST_CHK_MSK),\n\tHISI_SAS_DEBUGFS_REG(PHYCTRL_OOB_RESTART_MSK),\n\tHISI_SAS_DEBUGFS_REG(DMA_TX_STATUS),\n\tHISI_SAS_DEBUGFS_REG(DMA_RX_STATUS),\n\tHISI_SAS_DEBUGFS_REG(COARSETUNE_TIME),\n\tHISI_SAS_DEBUGFS_REG(ERR_CNT_DWS_LOST),\n\tHISI_SAS_DEBUGFS_REG(ERR_CNT_RESET_PROB),\n\tHISI_SAS_DEBUGFS_REG(ERR_CNT_INVLD_DW),\n\tHISI_SAS_DEBUGFS_REG(ERR_CNT_CODE_ERR),\n\tHISI_SAS_DEBUGFS_REG(ERR_CNT_DISP_ERR),\n\t{}\n};\n\nstatic const struct hisi_sas_debugfs_reg debugfs_port_reg = {\n\t.lu = debugfs_port_reg_lu,\n\t.count = 0x100,\n\t.base_off = PORT_BASE,\n};\n\nstatic const struct hisi_sas_debugfs_reg_lu debugfs_global_reg_lu[] = {\n\tHISI_SAS_DEBUGFS_REG(DLVRY_QUEUE_ENABLE),\n\tHISI_SAS_DEBUGFS_REG(PHY_CONTEXT),\n\tHISI_SAS_DEBUGFS_REG(PHY_STATE),\n\tHISI_SAS_DEBUGFS_REG(PHY_PORT_NUM_MA),\n\tHISI_SAS_DEBUGFS_REG(PHY_CONN_RATE),\n\tHISI_SAS_DEBUGFS_REG(ITCT_CLR),\n\tHISI_SAS_DEBUGFS_REG(IO_SATA_BROKEN_MSG_ADDR_LO),\n\tHISI_SAS_DEBUGFS_REG(IO_SATA_BROKEN_MSG_ADDR_HI),\n\tHISI_SAS_DEBUGFS_REG(SATA_INITI_D2H_STORE_ADDR_LO),\n\tHISI_SAS_DEBUGFS_REG(SATA_INITI_D2H_STORE_ADDR_HI),\n\tHISI_SAS_DEBUGFS_REG(CFG_MAX_TAG),\n\tHISI_SAS_DEBUGFS_REG(TRANS_LOCK_ICT_TIME),\n\tHISI_SAS_DEBUGFS_REG(HGC_SAS_TX_OPEN_FAIL_RETRY_CTRL),\n\tHISI_SAS_DEBUGFS_REG(HGC_SAS_TXFAIL_RETRY_CTRL),\n\tHISI_SAS_DEBUGFS_REG(HGC_GET_ITV_TIME),\n\tHISI_SAS_DEBUGFS_REG(DEVICE_MSG_WORK_MODE),\n\tHISI_SAS_DEBUGFS_REG(OPENA_WT_CONTI_TIME),\n\tHISI_SAS_DEBUGFS_REG(I_T_NEXUS_LOSS_TIME),\n\tHISI_SAS_DEBUGFS_REG(MAX_CON_TIME_LIMIT_TIME),\n\tHISI_SAS_DEBUGFS_REG(BUS_INACTIVE_LIMIT_TIME),\n\tHISI_SAS_DEBUGFS_REG(REJECT_TO_OPEN_LIMIT_TIME),\n\tHISI_SAS_DEBUGFS_REG(CQ_INT_CONVERGE_EN),\n\tHISI_SAS_DEBUGFS_REG(CFG_AGING_TIME),\n\tHISI_SAS_DEBUGFS_REG(HGC_DFX_CFG2),\n\tHISI_SAS_DEBUGFS_REG(CFG_ABT_SET_QUERY_IPTT),\n\tHISI_SAS_DEBUGFS_REG(CFG_ABT_SET_IPTT_DONE),\n\tHISI_SAS_DEBUGFS_REG(HGC_IOMB_PROC1_STATUS),\n\tHISI_SAS_DEBUGFS_REG(CHNL_INT_STATUS),\n\tHISI_SAS_DEBUGFS_REG(HGC_AXI_FIFO_ERR_INFO),\n\tHISI_SAS_DEBUGFS_REG(INT_COAL_EN),\n\tHISI_SAS_DEBUGFS_REG(OQ_INT_COAL_TIME),\n\tHISI_SAS_DEBUGFS_REG(OQ_INT_COAL_CNT),\n\tHISI_SAS_DEBUGFS_REG(ENT_INT_COAL_TIME),\n\tHISI_SAS_DEBUGFS_REG(ENT_INT_COAL_CNT),\n\tHISI_SAS_DEBUGFS_REG(OQ_INT_SRC),\n\tHISI_SAS_DEBUGFS_REG(OQ_INT_SRC_MSK),\n\tHISI_SAS_DEBUGFS_REG(ENT_INT_SRC1),\n\tHISI_SAS_DEBUGFS_REG(ENT_INT_SRC2),\n\tHISI_SAS_DEBUGFS_REG(ENT_INT_SRC3),\n\tHISI_SAS_DEBUGFS_REG(ENT_INT_SRC_MSK1),\n\tHISI_SAS_DEBUGFS_REG(ENT_INT_SRC_MSK2),\n\tHISI_SAS_DEBUGFS_REG(ENT_INT_SRC_MSK3),\n\tHISI_SAS_DEBUGFS_REG(CHNL_PHYUPDOWN_INT_MSK),\n\tHISI_SAS_DEBUGFS_REG(CHNL_ENT_INT_MSK),\n\tHISI_SAS_DEBUGFS_REG(HGC_COM_INT_MSK),\n\tHISI_SAS_DEBUGFS_REG(SAS_ECC_INTR),\n\tHISI_SAS_DEBUGFS_REG(SAS_ECC_INTR_MSK),\n\tHISI_SAS_DEBUGFS_REG(HGC_ERR_STAT_EN),\n\tHISI_SAS_DEBUGFS_REG(CQE_SEND_CNT),\n\tHISI_SAS_DEBUGFS_REG(DLVRY_Q_0_DEPTH),\n\tHISI_SAS_DEBUGFS_REG(DLVRY_Q_0_WR_PTR),\n\tHISI_SAS_DEBUGFS_REG(DLVRY_Q_0_RD_PTR),\n\tHISI_SAS_DEBUGFS_REG(HYPER_STREAM_ID_EN_CFG),\n\tHISI_SAS_DEBUGFS_REG(OQ0_INT_SRC_MSK),\n\tHISI_SAS_DEBUGFS_REG(COMPL_Q_0_DEPTH),\n\tHISI_SAS_DEBUGFS_REG(COMPL_Q_0_WR_PTR),\n\tHISI_SAS_DEBUGFS_REG(COMPL_Q_0_RD_PTR),\n\tHISI_SAS_DEBUGFS_REG(AWQOS_AWCACHE_CFG),\n\tHISI_SAS_DEBUGFS_REG(ARQOS_ARCACHE_CFG),\n\tHISI_SAS_DEBUGFS_REG(HILINK_ERR_DFX),\n\tHISI_SAS_DEBUGFS_REG(SAS_GPIO_CFG_0),\n\tHISI_SAS_DEBUGFS_REG(SAS_GPIO_CFG_1),\n\tHISI_SAS_DEBUGFS_REG(SAS_GPIO_TX_0_1),\n\tHISI_SAS_DEBUGFS_REG(SAS_CFG_DRIVE_VLD),\n\t{}\n};\n\nstatic const struct hisi_sas_debugfs_reg debugfs_global_reg = {\n\t.lu = debugfs_global_reg_lu,\n\t.count = 0x800,\n};\n\nstatic const struct hisi_sas_debugfs_reg_lu debugfs_axi_reg_lu[] = {\n\tHISI_SAS_DEBUGFS_REG(AM_CFG_MAX_TRANS),\n\tHISI_SAS_DEBUGFS_REG(AM_CFG_SINGLE_PORT_MAX_TRANS),\n\tHISI_SAS_DEBUGFS_REG(AXI_CFG),\n\tHISI_SAS_DEBUGFS_REG(AM_ROB_ECC_ERR_ADDR),\n\t{}\n};\n\nstatic const struct hisi_sas_debugfs_reg debugfs_axi_reg = {\n\t.lu = debugfs_axi_reg_lu,\n\t.count = 0x61,\n\t.base_off = AXI_MASTER_CFG_BASE,\n};\n\nstatic const struct hisi_sas_debugfs_reg_lu debugfs_ras_reg_lu[] = {\n\tHISI_SAS_DEBUGFS_REG(SAS_RAS_INTR0),\n\tHISI_SAS_DEBUGFS_REG(SAS_RAS_INTR1),\n\tHISI_SAS_DEBUGFS_REG(SAS_RAS_INTR0_MASK),\n\tHISI_SAS_DEBUGFS_REG(SAS_RAS_INTR1_MASK),\n\tHISI_SAS_DEBUGFS_REG(CFG_SAS_RAS_INTR_MASK),\n\tHISI_SAS_DEBUGFS_REG(SAS_RAS_INTR2),\n\tHISI_SAS_DEBUGFS_REG(SAS_RAS_INTR2_MASK),\n\t{}\n};\n\nstatic const struct hisi_sas_debugfs_reg debugfs_ras_reg = {\n\t.lu = debugfs_ras_reg_lu,\n\t.count = 0x10,\n\t.base_off = RAS_BASE,\n};\n\nstatic void debugfs_snapshot_prepare_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct Scsi_Host *shost = hisi_hba->shost;\n\n\tscsi_block_requests(shost);\n\twait_cmds_complete_timeout_v3_hw(hisi_hba, 100, 5000);\n\n\tset_bit(HISI_SAS_REJECT_CMD_BIT, &hisi_hba->flags);\n\thisi_sas_sync_cqs(hisi_hba);\n\thisi_sas_write32(hisi_hba, DLVRY_QUEUE_ENABLE, 0);\n}\n\nstatic void debugfs_snapshot_restore_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct Scsi_Host *shost = hisi_hba->shost;\n\n\thisi_sas_write32(hisi_hba, DLVRY_QUEUE_ENABLE,\n\t\t\t (u32)((1ULL << hisi_hba->queue_count) - 1));\n\n\tclear_bit(HISI_SAS_REJECT_CMD_BIT, &hisi_hba->flags);\n\tscsi_unblock_requests(shost);\n}\n\nstatic void read_iost_itct_cache_v3_hw(struct hisi_hba *hisi_hba,\n\t\t\t\t       enum hisi_sas_debugfs_cache_type type,\n\t\t\t\t       u32 *cache)\n{\n\tu32 cache_dw_size = HISI_SAS_IOST_ITCT_CACHE_DW_SZ *\n\t\t\t    HISI_SAS_IOST_ITCT_CACHE_NUM;\n\tstruct device *dev = hisi_hba->dev;\n\tu32 *buf = cache;\n\tu32 i, val;\n\n\thisi_sas_write32(hisi_hba, TAB_RD_TYPE, type);\n\n\tfor (i = 0; i < HISI_SAS_IOST_ITCT_CACHE_DW_SZ; i++) {\n\t\tval = hisi_sas_read32(hisi_hba, TAB_DFX);\n\t\tif (val == 0xffffffff)\n\t\t\tbreak;\n\t}\n\n\tif (val != 0xffffffff) {\n\t\tdev_err(dev, \"Issue occurred in reading IOST/ITCT cache!\\n\");\n\t\treturn;\n\t}\n\n\tmemset(buf, 0, cache_dw_size * 4);\n\tbuf[0] = val;\n\n\tfor (i = 1; i < cache_dw_size; i++)\n\t\tbuf[i] = hisi_sas_read32(hisi_hba, TAB_DFX);\n}\n\nstatic void hisi_sas_bist_test_prep_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tu32 reg_val;\n\tint phy_no = hisi_hba->debugfs_bist_phy_no;\n\tint i;\n\n\t \n\thisi_sas_phy_enable(hisi_hba, phy_no, 0);\n\n\t \n\tfor (i = 0; i < FFE_CFG_MAX; i++)\n\t\thisi_sas_phy_write32(hisi_hba, phy_no, TXDEEMPH_G1 + (i * 0x4),\n\t\t\t\t     hisi_hba->debugfs_bist_ffe[phy_no][i]);\n\n\t \n\treg_val = hisi_sas_phy_read32(hisi_hba, phy_no, SERDES_CFG);\n\treg_val |= CFG_ALOS_CHK_DISABLE_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, SERDES_CFG, reg_val);\n}\n\nstatic void hisi_sas_bist_test_restore_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tu32 reg_val;\n\tint phy_no = hisi_hba->debugfs_bist_phy_no;\n\n\t \n\treg_val = hisi_sas_phy_read32(hisi_hba, phy_no, SAS_PHY_BIST_CTRL);\n\treg_val &= ~(CFG_RX_BIST_EN_MSK | CFG_TX_BIST_EN_MSK |\n\t\t     CFG_BIST_TEST_MSK);\n\thisi_sas_phy_write32(hisi_hba, phy_no, SAS_PHY_BIST_CTRL, reg_val);\n\n\t \n\treg_val = hisi_sas_phy_read32(hisi_hba, phy_no, SERDES_CFG);\n\treg_val &= ~CFG_ALOS_CHK_DISABLE_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, SERDES_CFG, reg_val);\n\n\t \n\treg_val = hisi_sas_phy_read32(hisi_hba, phy_no, PROG_PHY_LINK_RATE);\n\t \n\treg_val &= ~CFG_PROG_OOB_PHY_LINK_RATE_MSK;\n\treg_val |= (0x8 << CFG_PROG_OOB_PHY_LINK_RATE_OFF);\n\thisi_sas_phy_write32(hisi_hba, phy_no, PROG_PHY_LINK_RATE, reg_val);\n\n\t \n\thisi_sas_phy_enable(hisi_hba, phy_no, 1);\n}\n\n#define SAS_PHY_BIST_CODE_INIT\t0x1\n#define SAS_PHY_BIST_CODE1_INIT\t0X80\nstatic int debugfs_set_bist_v3_hw(struct hisi_hba *hisi_hba, bool enable)\n{\n\tu32 reg_val, mode_tmp;\n\tu32 linkrate = hisi_hba->debugfs_bist_linkrate;\n\tu32 phy_no = hisi_hba->debugfs_bist_phy_no;\n\tu32 *ffe = hisi_hba->debugfs_bist_ffe[phy_no];\n\tu32 code_mode = hisi_hba->debugfs_bist_code_mode;\n\tu32 path_mode = hisi_hba->debugfs_bist_mode;\n\tu32 *fix_code = &hisi_hba->debugfs_bist_fixed_code[0];\n\tstruct device *dev = hisi_hba->dev;\n\n\tdev_info(dev, \"BIST info:phy%d link_rate=%d code_mode=%d path_mode=%d ffe={0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x} fixed_code={0x%x, 0x%x}\\n\",\n\t\t phy_no, linkrate, code_mode, path_mode,\n\t\t ffe[FFE_SAS_1_5_GBPS], ffe[FFE_SAS_3_0_GBPS],\n\t\t ffe[FFE_SAS_6_0_GBPS], ffe[FFE_SAS_12_0_GBPS],\n\t\t ffe[FFE_SATA_1_5_GBPS], ffe[FFE_SATA_3_0_GBPS],\n\t\t ffe[FFE_SATA_6_0_GBPS], fix_code[FIXED_CODE],\n\t\t fix_code[FIXED_CODE_1]);\n\tmode_tmp = path_mode ? 2 : 1;\n\tif (enable) {\n\t\t \n\t\thisi_sas_bist_test_prep_v3_hw(hisi_hba);\n\n\t\t \n\t\treg_val = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\t      PROG_PHY_LINK_RATE);\n\t\treg_val &= ~CFG_PROG_OOB_PHY_LINK_RATE_MSK;\n\t\treg_val |= (linkrate << CFG_PROG_OOB_PHY_LINK_RATE_OFF);\n\t\thisi_sas_phy_write32(hisi_hba, phy_no, PROG_PHY_LINK_RATE,\n\t\t\t\t     reg_val);\n\n\t\t \n\t\treg_val = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\t      SAS_PHY_BIST_CTRL);\n\t\treg_val &= ~(CFG_BIST_MODE_SEL_MSK | CFG_LOOP_TEST_MODE_MSK |\n\t\t\t     CFG_RX_BIST_EN_MSK | CFG_TX_BIST_EN_MSK |\n\t\t\t     CFG_BIST_TEST_MSK);\n\t\treg_val |= ((code_mode << CFG_BIST_MODE_SEL_OFF) |\n\t\t\t    (mode_tmp << CFG_LOOP_TEST_MODE_OFF) |\n\t\t\t    CFG_BIST_TEST_MSK);\n\t\thisi_sas_phy_write32(hisi_hba, phy_no, SAS_PHY_BIST_CTRL,\n\t\t\t\t     reg_val);\n\n\t\t \n\t\tif (code_mode == HISI_SAS_BIST_CODE_MODE_FIXED_DATA) {\n\t\t\treg_val = hisi_hba->debugfs_bist_fixed_code[0];\n\t\t\thisi_sas_phy_write32(hisi_hba, phy_no,\n\t\t\t\t\t     SAS_PHY_BIST_CODE, reg_val);\n\n\t\t\treg_val = hisi_hba->debugfs_bist_fixed_code[1];\n\t\t\thisi_sas_phy_write32(hisi_hba, phy_no,\n\t\t\t\t\t     SAS_PHY_BIST_CODE1, reg_val);\n\t\t} else {\n\t\t\thisi_sas_phy_write32(hisi_hba, phy_no,\n\t\t\t\t\t     SAS_PHY_BIST_CODE,\n\t\t\t\t\t     SAS_PHY_BIST_CODE_INIT);\n\t\t\thisi_sas_phy_write32(hisi_hba, phy_no,\n\t\t\t\t\t     SAS_PHY_BIST_CODE1,\n\t\t\t\t\t     SAS_PHY_BIST_CODE1_INIT);\n\t\t}\n\n\t\tmdelay(100);\n\t\treg_val |= (CFG_RX_BIST_EN_MSK | CFG_TX_BIST_EN_MSK);\n\t\thisi_sas_phy_write32(hisi_hba, phy_no, SAS_PHY_BIST_CTRL,\n\t\t\t\t     reg_val);\n\n\t\t \n\t\tmdelay(100);\n\t\thisi_sas_phy_read32(hisi_hba, phy_no, SAS_BIST_ERR_CNT);\n\t} else {\n\t\t \n\t\thisi_hba->debugfs_bist_cnt += hisi_sas_phy_read32(hisi_hba,\n\t\t\t\tphy_no, SAS_BIST_ERR_CNT);\n\t\thisi_sas_bist_test_restore_v3_hw(hisi_hba);\n\t}\n\n\treturn 0;\n}\n\nstatic void hisi_sas_map_queues(struct Scsi_Host *shost)\n{\n\tstruct hisi_hba *hisi_hba = shost_priv(shost);\n\tstruct blk_mq_queue_map *qmap;\n\tint i, qoff;\n\n\tfor (i = 0, qoff = 0; i < shost->nr_maps; i++) {\n\t\tqmap = &shost->tag_set.map[i];\n\t\tif (i == HCTX_TYPE_DEFAULT) {\n\t\t\tqmap->nr_queues = hisi_hba->cq_nvecs;\n\t\t} else if (i == HCTX_TYPE_POLL) {\n\t\t\tqmap->nr_queues = hisi_hba->iopoll_q_cnt;\n\t\t} else {\n\t\t\tqmap->nr_queues = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!qmap->nr_queues)\n\t\t\tWARN_ON(i == HCTX_TYPE_DEFAULT);\n\t\tqmap->queue_offset = qoff;\n\t\tif (i == HCTX_TYPE_POLL)\n\t\t\tblk_mq_map_queues(qmap);\n\t\telse\n\t\t\tblk_mq_pci_map_queues(qmap, hisi_hba->pci_dev,\n\t\t\t\t\t      BASE_VECTORS_V3_HW);\n\t\tqoff += qmap->nr_queues;\n\t}\n}\n\nstatic const struct scsi_host_template sht_v3_hw = {\n\t.name\t\t\t= DRV_NAME,\n\t.proc_name\t\t= DRV_NAME,\n\t.module\t\t\t= THIS_MODULE,\n\t.queuecommand\t\t= sas_queuecommand,\n\t.dma_need_drain\t\t= ata_scsi_dma_need_drain,\n\t.target_alloc\t\t= sas_target_alloc,\n\t.slave_configure\t= slave_configure_v3_hw,\n\t.scan_finished\t\t= hisi_sas_scan_finished,\n\t.scan_start\t\t= hisi_sas_scan_start,\n\t.map_queues\t\t= hisi_sas_map_queues,\n\t.change_queue_depth\t= sas_change_queue_depth,\n\t.bios_param\t\t= sas_bios_param,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= HISI_SAS_SGE_PAGE_CNT,\n\t.sg_prot_tablesize\t= HISI_SAS_SGE_PAGE_CNT,\n\t.max_sectors\t\t= SCSI_DEFAULT_MAX_SECTORS,\n\t.eh_device_reset_handler = sas_eh_device_reset_handler,\n\t.eh_target_reset_handler = sas_eh_target_reset_handler,\n\t.slave_alloc\t\t= hisi_sas_slave_alloc,\n\t.target_destroy\t\t= sas_target_destroy,\n\t.ioctl\t\t\t= sas_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= sas_ioctl,\n#endif\n\t.shost_groups\t\t= host_v3_hw_groups,\n\t.tag_alloc_policy\t= BLK_TAG_ALLOC_RR,\n\t.host_reset             = hisi_sas_host_reset,\n\t.host_tagset\t\t= 1,\n\t.mq_poll\t\t= queue_complete_v3_hw,\n};\n\nstatic const struct hisi_sas_hw hisi_sas_v3_hw = {\n\t.setup_itct = setup_itct_v3_hw,\n\t.get_wideport_bitmap = get_wideport_bitmap_v3_hw,\n\t.complete_hdr_size = sizeof(struct hisi_sas_complete_v3_hdr),\n\t.clear_itct = clear_itct_v3_hw,\n\t.sl_notify_ssp = sl_notify_ssp_v3_hw,\n\t.prep_ssp = prep_ssp_v3_hw,\n\t.prep_smp = prep_smp_v3_hw,\n\t.prep_stp = prep_ata_v3_hw,\n\t.prep_abort = prep_abort_v3_hw,\n\t.start_delivery = start_delivery_v3_hw,\n\t.phys_init = phys_init_v3_hw,\n\t.phy_start = start_phy_v3_hw,\n\t.phy_disable = disable_phy_v3_hw,\n\t.phy_hard_reset = phy_hard_reset_v3_hw,\n\t.phy_get_max_linkrate = phy_get_max_linkrate_v3_hw,\n\t.phy_set_linkrate = phy_set_linkrate_v3_hw,\n\t.dereg_device = dereg_device_v3_hw,\n\t.soft_reset = soft_reset_v3_hw,\n\t.get_phys_state = get_phys_state_v3_hw,\n\t.get_events = phy_get_events_v3_hw,\n\t.write_gpio = write_gpio_v3_hw,\n\t.wait_cmds_complete_timeout = wait_cmds_complete_timeout_v3_hw,\n\t.debugfs_snapshot_regs = debugfs_snapshot_regs_v3_hw,\n};\n\nstatic struct Scsi_Host *\nhisi_sas_shost_alloc_pci(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct hisi_hba *hisi_hba;\n\tstruct device *dev = &pdev->dev;\n\n\tshost = scsi_host_alloc(&sht_v3_hw, sizeof(*hisi_hba));\n\tif (!shost) {\n\t\tdev_err(dev, \"shost alloc failed\\n\");\n\t\treturn NULL;\n\t}\n\thisi_hba = shost_priv(shost);\n\n\tINIT_WORK(&hisi_hba->rst_work, hisi_sas_rst_work_handler);\n\tINIT_WORK(&hisi_hba->debugfs_work, debugfs_work_handler_v3_hw);\n\thisi_hba->hw = &hisi_sas_v3_hw;\n\thisi_hba->pci_dev = pdev;\n\thisi_hba->dev = dev;\n\thisi_hba->shost = shost;\n\tSHOST_TO_SAS_HA(shost) = &hisi_hba->sha;\n\n\tif (prot_mask & ~HISI_SAS_PROT_MASK)\n\t\tdev_err(dev, \"unsupported protection mask 0x%x, using default (0x0)\\n\",\n\t\t\tprot_mask);\n\telse\n\t\thisi_hba->prot_mask = prot_mask;\n\n\tif (hisi_sas_get_fw_info(hisi_hba) < 0)\n\t\tgoto err_out;\n\n\tif (experimental_iopoll_q_cnt < 0 ||\n\t\texperimental_iopoll_q_cnt >= hisi_hba->queue_count)\n\t\tdev_err(dev, \"iopoll queue count %d cannot exceed or equal 16, using default 0\\n\",\n\t\t\texperimental_iopoll_q_cnt);\n\telse\n\t\thisi_hba->iopoll_q_cnt = experimental_iopoll_q_cnt;\n\n\tif (hisi_sas_alloc(hisi_hba)) {\n\t\thisi_sas_free(hisi_hba);\n\t\tgoto err_out;\n\t}\n\n\treturn shost;\nerr_out:\n\tscsi_host_put(shost);\n\tdev_err(dev, \"shost alloc failed\\n\");\n\treturn NULL;\n}\n\nstatic void debugfs_snapshot_cq_reg_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tint queue_entry_size = hisi_hba->hw->complete_hdr_size;\n\tint dump_index = hisi_hba->debugfs_dump_index;\n\tint i;\n\n\tfor (i = 0; i < hisi_hba->queue_count; i++)\n\t\tmemcpy(hisi_hba->debugfs_cq[dump_index][i].complete_hdr,\n\t\t       hisi_hba->complete_hdr[i],\n\t\t       HISI_SAS_QUEUE_SLOTS * queue_entry_size);\n}\n\nstatic void debugfs_snapshot_dq_reg_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tint queue_entry_size = sizeof(struct hisi_sas_cmd_hdr);\n\tint dump_index = hisi_hba->debugfs_dump_index;\n\tint i;\n\n\tfor (i = 0; i < hisi_hba->queue_count; i++) {\n\t\tstruct hisi_sas_cmd_hdr *debugfs_cmd_hdr, *cmd_hdr;\n\t\tint j;\n\n\t\tdebugfs_cmd_hdr = hisi_hba->debugfs_dq[dump_index][i].hdr;\n\t\tcmd_hdr = hisi_hba->cmd_hdr[i];\n\n\t\tfor (j = 0; j < HISI_SAS_QUEUE_SLOTS; j++)\n\t\t\tmemcpy(&debugfs_cmd_hdr[j], &cmd_hdr[j],\n\t\t\t       queue_entry_size);\n\t}\n}\n\nstatic void debugfs_snapshot_port_reg_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tint dump_index = hisi_hba->debugfs_dump_index;\n\tconst struct hisi_sas_debugfs_reg *port = &debugfs_port_reg;\n\tint i, phy_cnt;\n\tu32 offset;\n\tu32 *databuf;\n\n\tfor (phy_cnt = 0; phy_cnt < hisi_hba->n_phy; phy_cnt++) {\n\t\tdatabuf = hisi_hba->debugfs_port_reg[dump_index][phy_cnt].data;\n\t\tfor (i = 0; i < port->count; i++, databuf++) {\n\t\t\toffset = port->base_off + 4 * i;\n\t\t\t*databuf = hisi_sas_phy_read32(hisi_hba, phy_cnt,\n\t\t\t\t\t\t       offset);\n\t\t}\n\t}\n}\n\nstatic void debugfs_snapshot_global_reg_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tint dump_index = hisi_hba->debugfs_dump_index;\n\tu32 *databuf = hisi_hba->debugfs_regs[dump_index][DEBUGFS_GLOBAL].data;\n\tint i;\n\n\tfor (i = 0; i < debugfs_global_reg.count; i++, databuf++)\n\t\t*databuf = hisi_sas_read32(hisi_hba, 4 * i);\n}\n\nstatic void debugfs_snapshot_axi_reg_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tint dump_index = hisi_hba->debugfs_dump_index;\n\tu32 *databuf = hisi_hba->debugfs_regs[dump_index][DEBUGFS_AXI].data;\n\tconst struct hisi_sas_debugfs_reg *axi = &debugfs_axi_reg;\n\tint i;\n\n\tfor (i = 0; i < axi->count; i++, databuf++)\n\t\t*databuf = hisi_sas_read32(hisi_hba, 4 * i + axi->base_off);\n}\n\nstatic void debugfs_snapshot_ras_reg_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tint dump_index = hisi_hba->debugfs_dump_index;\n\tu32 *databuf = hisi_hba->debugfs_regs[dump_index][DEBUGFS_RAS].data;\n\tconst struct hisi_sas_debugfs_reg *ras = &debugfs_ras_reg;\n\tint i;\n\n\tfor (i = 0; i < ras->count; i++, databuf++)\n\t\t*databuf = hisi_sas_read32(hisi_hba, 4 * i + ras->base_off);\n}\n\nstatic void debugfs_snapshot_itct_reg_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tint dump_index = hisi_hba->debugfs_dump_index;\n\tvoid *cachebuf = hisi_hba->debugfs_itct_cache[dump_index].cache;\n\tvoid *databuf = hisi_hba->debugfs_itct[dump_index].itct;\n\tstruct hisi_sas_itct *itct;\n\tint i;\n\n\tread_iost_itct_cache_v3_hw(hisi_hba, HISI_SAS_ITCT_CACHE, cachebuf);\n\n\titct = hisi_hba->itct;\n\n\tfor (i = 0; i < HISI_SAS_MAX_ITCT_ENTRIES; i++, itct++) {\n\t\tmemcpy(databuf, itct, sizeof(struct hisi_sas_itct));\n\t\tdatabuf += sizeof(struct hisi_sas_itct);\n\t}\n}\n\nstatic void debugfs_snapshot_iost_reg_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tint dump_index = hisi_hba->debugfs_dump_index;\n\tint max_command_entries = HISI_SAS_MAX_COMMANDS;\n\tvoid *cachebuf = hisi_hba->debugfs_iost_cache[dump_index].cache;\n\tvoid *databuf = hisi_hba->debugfs_iost[dump_index].iost;\n\tstruct hisi_sas_iost *iost;\n\tint i;\n\n\tread_iost_itct_cache_v3_hw(hisi_hba, HISI_SAS_IOST_CACHE, cachebuf);\n\n\tiost = hisi_hba->iost;\n\n\tfor (i = 0; i < max_command_entries; i++, iost++) {\n\t\tmemcpy(databuf, iost, sizeof(struct hisi_sas_iost));\n\t\tdatabuf += sizeof(struct hisi_sas_iost);\n\t}\n}\n\nstatic const char *\ndebugfs_to_reg_name_v3_hw(int off, int base_off,\n\t\t\t  const struct hisi_sas_debugfs_reg_lu *lu)\n{\n\tfor (; lu->name; lu++) {\n\t\tif (off == lu->off - base_off)\n\t\t\treturn lu->name;\n\t}\n\n\treturn NULL;\n}\n\nstatic void debugfs_print_reg_v3_hw(u32 *regs_val, struct seq_file *s,\n\t\t\t\t    const struct hisi_sas_debugfs_reg *reg)\n{\n\tint i;\n\n\tfor (i = 0; i < reg->count; i++) {\n\t\tint off = i * 4;\n\t\tconst char *name;\n\n\t\tname = debugfs_to_reg_name_v3_hw(off, reg->base_off,\n\t\t\t\t\t\t reg->lu);\n\n\t\tif (name)\n\t\t\tseq_printf(s, \"0x%08x 0x%08x %s\\n\", off,\n\t\t\t\t   regs_val[i], name);\n\t\telse\n\t\t\tseq_printf(s, \"0x%08x 0x%08x\\n\", off,\n\t\t\t\t   regs_val[i]);\n\t}\n}\n\nstatic int debugfs_global_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_sas_debugfs_regs *global = s->private;\n\n\tdebugfs_print_reg_v3_hw(global->data, s,\n\t\t\t\t&debugfs_global_reg);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_global_v3_hw);\n\nstatic int debugfs_axi_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_sas_debugfs_regs *axi = s->private;\n\n\tdebugfs_print_reg_v3_hw(axi->data, s,\n\t\t\t\t&debugfs_axi_reg);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_axi_v3_hw);\n\nstatic int debugfs_ras_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_sas_debugfs_regs *ras = s->private;\n\n\tdebugfs_print_reg_v3_hw(ras->data, s,\n\t\t\t\t&debugfs_ras_reg);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_ras_v3_hw);\n\nstatic int debugfs_port_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_sas_debugfs_port *port = s->private;\n\tconst struct hisi_sas_debugfs_reg *reg_port = &debugfs_port_reg;\n\n\tdebugfs_print_reg_v3_hw(port->data, s, reg_port);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_port_v3_hw);\n\nstatic void debugfs_show_row_64_v3_hw(struct seq_file *s, int index,\n\t\t\t\t      int sz, __le64 *ptr)\n{\n\tint i;\n\n\t \n\tseq_printf(s, \"index %04d:\\n\\t\", index);\n\tfor (i = 1; i <= sz / 8; i++, ptr++) {\n\t\tseq_printf(s, \" 0x%016llx\", le64_to_cpu(*ptr));\n\t\tif (!(i % 2))\n\t\t\tseq_puts(s, \"\\n\\t\");\n\t}\n\n\tseq_puts(s, \"\\n\");\n}\n\nstatic void debugfs_show_row_32_v3_hw(struct seq_file *s, int index,\n\t\t\t\t      int sz, __le32 *ptr)\n{\n\tint i;\n\n\t \n\tseq_printf(s, \"index %04d:\\n\\t\", index);\n\tfor (i = 1; i <= sz / 4; i++, ptr++) {\n\t\tseq_printf(s, \" 0x%08x\", le32_to_cpu(*ptr));\n\t\tif (!(i % 4))\n\t\t\tseq_puts(s, \"\\n\\t\");\n\t}\n\tseq_puts(s, \"\\n\");\n}\n\nstatic void debugfs_cq_show_slot_v3_hw(struct seq_file *s, int slot,\n\t\t\t\t       struct hisi_sas_debugfs_cq *debugfs_cq)\n{\n\tstruct hisi_sas_cq *cq = debugfs_cq->cq;\n\tstruct hisi_hba *hisi_hba = cq->hisi_hba;\n\t__le32 *complete_hdr = debugfs_cq->complete_hdr +\n\t\t\t       (hisi_hba->hw->complete_hdr_size * slot);\n\n\tdebugfs_show_row_32_v3_hw(s, slot,\n\t\t\t\t  hisi_hba->hw->complete_hdr_size,\n\t\t\t\t  complete_hdr);\n}\n\nstatic int debugfs_cq_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_sas_debugfs_cq *debugfs_cq = s->private;\n\tint slot;\n\n\tfor (slot = 0; slot < HISI_SAS_QUEUE_SLOTS; slot++)\n\t\tdebugfs_cq_show_slot_v3_hw(s, slot, debugfs_cq);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_cq_v3_hw);\n\nstatic void debugfs_dq_show_slot_v3_hw(struct seq_file *s, int slot,\n\t\t\t\t       void *dq_ptr)\n{\n\tstruct hisi_sas_debugfs_dq *debugfs_dq = dq_ptr;\n\tvoid *cmd_queue = debugfs_dq->hdr;\n\t__le32 *cmd_hdr = cmd_queue +\n\t\tsizeof(struct hisi_sas_cmd_hdr) * slot;\n\n\tdebugfs_show_row_32_v3_hw(s, slot, sizeof(struct hisi_sas_cmd_hdr),\n\t\t\t\t  cmd_hdr);\n}\n\nstatic int debugfs_dq_v3_hw_show(struct seq_file *s, void *p)\n{\n\tint slot;\n\n\tfor (slot = 0; slot < HISI_SAS_QUEUE_SLOTS; slot++)\n\t\tdebugfs_dq_show_slot_v3_hw(s, slot, s->private);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_dq_v3_hw);\n\nstatic int debugfs_iost_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_sas_debugfs_iost *debugfs_iost = s->private;\n\tstruct hisi_sas_iost *iost = debugfs_iost->iost;\n\tint i, max_command_entries = HISI_SAS_MAX_COMMANDS;\n\n\tfor (i = 0; i < max_command_entries; i++, iost++) {\n\t\t__le64 *data = &iost->qw0;\n\n\t\tdebugfs_show_row_64_v3_hw(s, i, sizeof(*iost), data);\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_iost_v3_hw);\n\nstatic int debugfs_iost_cache_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_sas_debugfs_iost_cache *debugfs_iost_cache = s->private;\n\tstruct hisi_sas_iost_itct_cache *iost_cache =\n\t\t\t\t\t\tdebugfs_iost_cache->cache;\n\tu32 cache_size = HISI_SAS_IOST_ITCT_CACHE_DW_SZ * 4;\n\tint i, tab_idx;\n\t__le64 *iost;\n\n\tfor (i = 0; i < HISI_SAS_IOST_ITCT_CACHE_NUM; i++, iost_cache++) {\n\t\t \n\t\ttab_idx = (iost_cache->data[1] & 0xffff);\n\t\tiost = (__le64 *)iost_cache;\n\n\t\tdebugfs_show_row_64_v3_hw(s, tab_idx, cache_size, iost);\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_iost_cache_v3_hw);\n\nstatic int debugfs_itct_v3_hw_show(struct seq_file *s, void *p)\n{\n\tint i;\n\tstruct hisi_sas_debugfs_itct *debugfs_itct = s->private;\n\tstruct hisi_sas_itct *itct = debugfs_itct->itct;\n\n\tfor (i = 0; i < HISI_SAS_MAX_ITCT_ENTRIES; i++, itct++) {\n\t\t__le64 *data = &itct->qw0;\n\n\t\tdebugfs_show_row_64_v3_hw(s, i, sizeof(*itct), data);\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_itct_v3_hw);\n\nstatic int debugfs_itct_cache_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_sas_debugfs_itct_cache *debugfs_itct_cache = s->private;\n\tstruct hisi_sas_iost_itct_cache *itct_cache =\n\t\t\t\t\t\tdebugfs_itct_cache->cache;\n\tu32 cache_size = HISI_SAS_IOST_ITCT_CACHE_DW_SZ * 4;\n\tint i, tab_idx;\n\t__le64 *itct;\n\n\tfor (i = 0; i < HISI_SAS_IOST_ITCT_CACHE_NUM; i++, itct_cache++) {\n\t\t \n\t\ttab_idx = itct_cache->data[1] & 0xffff;\n\t\titct = (__le64 *)itct_cache;\n\n\t\tdebugfs_show_row_64_v3_hw(s, tab_idx, cache_size, itct);\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_itct_cache_v3_hw);\n\nstatic void debugfs_create_files_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tu64 *debugfs_timestamp;\n\tint dump_index = hisi_hba->debugfs_dump_index;\n\tstruct dentry *dump_dentry;\n\tstruct dentry *dentry;\n\tchar name[256];\n\tint p;\n\tint c;\n\tint d;\n\n\tsnprintf(name, 256, \"%d\", dump_index);\n\n\tdump_dentry = debugfs_create_dir(name, hisi_hba->debugfs_dump_dentry);\n\n\tdebugfs_timestamp = &hisi_hba->debugfs_timestamp[dump_index];\n\n\tdebugfs_create_u64(\"timestamp\", 0400, dump_dentry,\n\t\t\t   debugfs_timestamp);\n\n\tdebugfs_create_file(\"global\", 0400, dump_dentry,\n\t\t\t    &hisi_hba->debugfs_regs[dump_index][DEBUGFS_GLOBAL],\n\t\t\t    &debugfs_global_v3_hw_fops);\n\n\t \n\tdentry = debugfs_create_dir(\"port\", dump_dentry);\n\tfor (p = 0; p < hisi_hba->n_phy; p++) {\n\t\tsnprintf(name, 256, \"%d\", p);\n\n\t\tdebugfs_create_file(name, 0400, dentry,\n\t\t\t\t    &hisi_hba->debugfs_port_reg[dump_index][p],\n\t\t\t\t    &debugfs_port_v3_hw_fops);\n\t}\n\n\t \n\tdentry = debugfs_create_dir(\"cq\", dump_dentry);\n\tfor (c = 0; c < hisi_hba->queue_count; c++) {\n\t\tsnprintf(name, 256, \"%d\", c);\n\n\t\tdebugfs_create_file(name, 0400, dentry,\n\t\t\t\t    &hisi_hba->debugfs_cq[dump_index][c],\n\t\t\t\t    &debugfs_cq_v3_hw_fops);\n\t}\n\n\t \n\tdentry = debugfs_create_dir(\"dq\", dump_dentry);\n\tfor (d = 0; d < hisi_hba->queue_count; d++) {\n\t\tsnprintf(name, 256, \"%d\", d);\n\n\t\tdebugfs_create_file(name, 0400, dentry,\n\t\t\t\t    &hisi_hba->debugfs_dq[dump_index][d],\n\t\t\t\t    &debugfs_dq_v3_hw_fops);\n\t}\n\n\tdebugfs_create_file(\"iost\", 0400, dump_dentry,\n\t\t\t    &hisi_hba->debugfs_iost[dump_index],\n\t\t\t    &debugfs_iost_v3_hw_fops);\n\n\tdebugfs_create_file(\"iost_cache\", 0400, dump_dentry,\n\t\t\t    &hisi_hba->debugfs_iost_cache[dump_index],\n\t\t\t    &debugfs_iost_cache_v3_hw_fops);\n\n\tdebugfs_create_file(\"itct\", 0400, dump_dentry,\n\t\t\t    &hisi_hba->debugfs_itct[dump_index],\n\t\t\t    &debugfs_itct_v3_hw_fops);\n\n\tdebugfs_create_file(\"itct_cache\", 0400, dump_dentry,\n\t\t\t    &hisi_hba->debugfs_itct_cache[dump_index],\n\t\t\t    &debugfs_itct_cache_v3_hw_fops);\n\n\tdebugfs_create_file(\"axi\", 0400, dump_dentry,\n\t\t\t    &hisi_hba->debugfs_regs[dump_index][DEBUGFS_AXI],\n\t\t\t    &debugfs_axi_v3_hw_fops);\n\n\tdebugfs_create_file(\"ras\", 0400, dump_dentry,\n\t\t\t    &hisi_hba->debugfs_regs[dump_index][DEBUGFS_RAS],\n\t\t\t    &debugfs_ras_v3_hw_fops);\n}\n\nstatic void debugfs_snapshot_regs_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tint debugfs_dump_index = hisi_hba->debugfs_dump_index;\n\tstruct device *dev = hisi_hba->dev;\n\tu64 timestamp = local_clock();\n\n\tif (debugfs_dump_index >= hisi_sas_debugfs_dump_count) {\n\t\tdev_warn(dev, \"dump count exceeded!\\n\");\n\t\treturn;\n\t}\n\n\tdo_div(timestamp, NSEC_PER_MSEC);\n\thisi_hba->debugfs_timestamp[debugfs_dump_index] = timestamp;\n\n\tdebugfs_snapshot_prepare_v3_hw(hisi_hba);\n\n\tdebugfs_snapshot_global_reg_v3_hw(hisi_hba);\n\tdebugfs_snapshot_port_reg_v3_hw(hisi_hba);\n\tdebugfs_snapshot_axi_reg_v3_hw(hisi_hba);\n\tdebugfs_snapshot_ras_reg_v3_hw(hisi_hba);\n\tdebugfs_snapshot_cq_reg_v3_hw(hisi_hba);\n\tdebugfs_snapshot_dq_reg_v3_hw(hisi_hba);\n\tdebugfs_snapshot_itct_reg_v3_hw(hisi_hba);\n\tdebugfs_snapshot_iost_reg_v3_hw(hisi_hba);\n\n\tdebugfs_create_files_v3_hw(hisi_hba);\n\n\tdebugfs_snapshot_restore_v3_hw(hisi_hba);\n\thisi_hba->debugfs_dump_index++;\n}\n\nstatic ssize_t debugfs_trigger_dump_v3_hw_write(struct file *file,\n\t\t\t\t\t\tconst char __user *user_buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hisi_hba *hisi_hba = file->f_inode->i_private;\n\tchar buf[8];\n\n\tif (hisi_hba->debugfs_dump_index >= hisi_sas_debugfs_dump_count)\n\t\treturn -EFAULT;\n\n\tif (count > 8)\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(buf, user_buf, count))\n\t\treturn -EFAULT;\n\n\tif (buf[0] != '1')\n\t\treturn -EFAULT;\n\n\tqueue_work(hisi_hba->wq, &hisi_hba->debugfs_work);\n\n\treturn count;\n}\n\nstatic const struct file_operations debugfs_trigger_dump_v3_hw_fops = {\n\t.write = &debugfs_trigger_dump_v3_hw_write,\n\t.owner = THIS_MODULE,\n};\n\nenum {\n\tHISI_SAS_BIST_LOOPBACK_MODE_DIGITAL = 0,\n\tHISI_SAS_BIST_LOOPBACK_MODE_SERDES,\n\tHISI_SAS_BIST_LOOPBACK_MODE_REMOTE,\n};\n\nstatic const struct {\n\tint\t\tvalue;\n\tchar\t\t*name;\n} debugfs_loop_linkrate_v3_hw[] = {\n\t{ SAS_LINK_RATE_1_5_GBPS, \"1.5 Gbit\" },\n\t{ SAS_LINK_RATE_3_0_GBPS, \"3.0 Gbit\" },\n\t{ SAS_LINK_RATE_6_0_GBPS, \"6.0 Gbit\" },\n\t{ SAS_LINK_RATE_12_0_GBPS, \"12.0 Gbit\" },\n};\n\nstatic int debugfs_bist_linkrate_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_hba *hisi_hba = s->private;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(debugfs_loop_linkrate_v3_hw); i++) {\n\t\tint match = (hisi_hba->debugfs_bist_linkrate ==\n\t\t\t     debugfs_loop_linkrate_v3_hw[i].value);\n\n\t\tseq_printf(s, \"%s%s%s \", match ? \"[\" : \"\",\n\t\t\t   debugfs_loop_linkrate_v3_hw[i].name,\n\t\t\t   match ? \"]\" : \"\");\n\t}\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\n\nstatic ssize_t debugfs_bist_linkrate_v3_hw_write(struct file *filp,\n\t\t\t\t\t\t const char __user *buf,\n\t\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct hisi_hba *hisi_hba = m->private;\n\tchar kbuf[16] = {}, *pkbuf;\n\tbool found = false;\n\tint i;\n\n\tif (hisi_hba->debugfs_bist_enable)\n\t\treturn -EPERM;\n\n\tif (count >= sizeof(kbuf))\n\t\treturn -EOVERFLOW;\n\n\tif (copy_from_user(kbuf, buf, count))\n\t\treturn -EINVAL;\n\n\tpkbuf = strstrip(kbuf);\n\n\tfor (i = 0; i < ARRAY_SIZE(debugfs_loop_linkrate_v3_hw); i++) {\n\t\tif (!strncmp(debugfs_loop_linkrate_v3_hw[i].name,\n\t\t\t     pkbuf, 16)) {\n\t\t\thisi_hba->debugfs_bist_linkrate =\n\t\t\t\tdebugfs_loop_linkrate_v3_hw[i].value;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic int debugfs_bist_linkrate_v3_hw_open(struct inode *inode,\n\t\t\t\t\t    struct file *filp)\n{\n\treturn single_open(filp, debugfs_bist_linkrate_v3_hw_show,\n\t\t\t   inode->i_private);\n}\n\nstatic const struct file_operations debugfs_bist_linkrate_v3_hw_fops = {\n\t.open = debugfs_bist_linkrate_v3_hw_open,\n\t.read = seq_read,\n\t.write = debugfs_bist_linkrate_v3_hw_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct {\n\tint\t\tvalue;\n\tchar\t\t*name;\n} debugfs_loop_code_mode_v3_hw[] = {\n\t{ HISI_SAS_BIST_CODE_MODE_PRBS7, \"PRBS7\" },\n\t{ HISI_SAS_BIST_CODE_MODE_PRBS23, \"PRBS23\" },\n\t{ HISI_SAS_BIST_CODE_MODE_PRBS31, \"PRBS31\" },\n\t{ HISI_SAS_BIST_CODE_MODE_JTPAT, \"JTPAT\" },\n\t{ HISI_SAS_BIST_CODE_MODE_CJTPAT, \"CJTPAT\" },\n\t{ HISI_SAS_BIST_CODE_MODE_SCRAMBED_0, \"SCRAMBED_0\" },\n\t{ HISI_SAS_BIST_CODE_MODE_TRAIN, \"TRAIN\" },\n\t{ HISI_SAS_BIST_CODE_MODE_TRAIN_DONE, \"TRAIN_DONE\" },\n\t{ HISI_SAS_BIST_CODE_MODE_HFTP, \"HFTP\" },\n\t{ HISI_SAS_BIST_CODE_MODE_MFTP, \"MFTP\" },\n\t{ HISI_SAS_BIST_CODE_MODE_LFTP, \"LFTP\" },\n\t{ HISI_SAS_BIST_CODE_MODE_FIXED_DATA, \"FIXED_DATA\" },\n};\n\nstatic int debugfs_bist_code_mode_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_hba *hisi_hba = s->private;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(debugfs_loop_code_mode_v3_hw); i++) {\n\t\tint match = (hisi_hba->debugfs_bist_code_mode ==\n\t\t\t     debugfs_loop_code_mode_v3_hw[i].value);\n\n\t\tseq_printf(s, \"%s%s%s \", match ? \"[\" : \"\",\n\t\t\t   debugfs_loop_code_mode_v3_hw[i].name,\n\t\t\t   match ? \"]\" : \"\");\n\t}\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\n\nstatic ssize_t debugfs_bist_code_mode_v3_hw_write(struct file *filp,\n\t\t\t\t\t\t  const char __user *buf,\n\t\t\t\t\t\t  size_t count,\n\t\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct hisi_hba *hisi_hba = m->private;\n\tchar kbuf[16] = {}, *pkbuf;\n\tbool found = false;\n\tint i;\n\n\tif (hisi_hba->debugfs_bist_enable)\n\t\treturn -EPERM;\n\n\tif (count >= sizeof(kbuf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(kbuf, buf, count))\n\t\treturn -EOVERFLOW;\n\n\tpkbuf = strstrip(kbuf);\n\n\tfor (i = 0; i < ARRAY_SIZE(debugfs_loop_code_mode_v3_hw); i++) {\n\t\tif (!strncmp(debugfs_loop_code_mode_v3_hw[i].name,\n\t\t\t     pkbuf, 16)) {\n\t\t\thisi_hba->debugfs_bist_code_mode =\n\t\t\t\tdebugfs_loop_code_mode_v3_hw[i].value;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic int debugfs_bist_code_mode_v3_hw_open(struct inode *inode,\n\t\t\t\t\t     struct file *filp)\n{\n\treturn single_open(filp, debugfs_bist_code_mode_v3_hw_show,\n\t\t\t   inode->i_private);\n}\n\nstatic const struct file_operations debugfs_bist_code_mode_v3_hw_fops = {\n\t.open = debugfs_bist_code_mode_v3_hw_open,\n\t.read = seq_read,\n\t.write = debugfs_bist_code_mode_v3_hw_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.owner = THIS_MODULE,\n};\n\nstatic ssize_t debugfs_bist_phy_v3_hw_write(struct file *filp,\n\t\t\t\t\t    const char __user *buf,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct hisi_hba *hisi_hba = m->private;\n\tunsigned int phy_no;\n\tint val;\n\n\tif (hisi_hba->debugfs_bist_enable)\n\t\treturn -EPERM;\n\n\tval = kstrtouint_from_user(buf, count, 0, &phy_no);\n\tif (val)\n\t\treturn val;\n\n\tif (phy_no >= hisi_hba->n_phy)\n\t\treturn -EINVAL;\n\n\thisi_hba->debugfs_bist_phy_no = phy_no;\n\n\treturn count;\n}\n\nstatic int debugfs_bist_phy_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_hba *hisi_hba = s->private;\n\n\tseq_printf(s, \"%d\\n\", hisi_hba->debugfs_bist_phy_no);\n\n\treturn 0;\n}\n\nstatic int debugfs_bist_phy_v3_hw_open(struct inode *inode,\n\t\t\t\t       struct file *filp)\n{\n\treturn single_open(filp, debugfs_bist_phy_v3_hw_show,\n\t\t\t   inode->i_private);\n}\n\nstatic const struct file_operations debugfs_bist_phy_v3_hw_fops = {\n\t.open = debugfs_bist_phy_v3_hw_open,\n\t.read = seq_read,\n\t.write = debugfs_bist_phy_v3_hw_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.owner = THIS_MODULE,\n};\n\nstatic ssize_t debugfs_bist_cnt_v3_hw_write(struct file *filp,\n\t\t\t\t\tconst char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct hisi_hba *hisi_hba = m->private;\n\tunsigned int cnt;\n\tint val;\n\n\tif (hisi_hba->debugfs_bist_enable)\n\t\treturn -EPERM;\n\n\tval = kstrtouint_from_user(buf, count, 0, &cnt);\n\tif (val)\n\t\treturn val;\n\n\tif (cnt)\n\t\treturn -EINVAL;\n\n\thisi_hba->debugfs_bist_cnt = 0;\n\treturn count;\n}\n\nstatic int debugfs_bist_cnt_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_hba *hisi_hba = s->private;\n\n\tseq_printf(s, \"%u\\n\", hisi_hba->debugfs_bist_cnt);\n\n\treturn 0;\n}\n\nstatic int debugfs_bist_cnt_v3_hw_open(struct inode *inode,\n\t\t\t\t\t  struct file *filp)\n{\n\treturn single_open(filp, debugfs_bist_cnt_v3_hw_show,\n\t\t\t   inode->i_private);\n}\n\nstatic const struct file_operations debugfs_bist_cnt_v3_hw_ops = {\n\t.open = debugfs_bist_cnt_v3_hw_open,\n\t.read = seq_read,\n\t.write = debugfs_bist_cnt_v3_hw_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct {\n\tint\t\tvalue;\n\tchar\t\t*name;\n} debugfs_loop_modes_v3_hw[] = {\n\t{ HISI_SAS_BIST_LOOPBACK_MODE_DIGITAL, \"digital\" },\n\t{ HISI_SAS_BIST_LOOPBACK_MODE_SERDES, \"serdes\" },\n\t{ HISI_SAS_BIST_LOOPBACK_MODE_REMOTE, \"remote\" },\n};\n\nstatic int debugfs_bist_mode_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_hba *hisi_hba = s->private;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(debugfs_loop_modes_v3_hw); i++) {\n\t\tint match = (hisi_hba->debugfs_bist_mode ==\n\t\t\t     debugfs_loop_modes_v3_hw[i].value);\n\n\t\tseq_printf(s, \"%s%s%s \", match ? \"[\" : \"\",\n\t\t\t   debugfs_loop_modes_v3_hw[i].name,\n\t\t\t   match ? \"]\" : \"\");\n\t}\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\n\nstatic ssize_t debugfs_bist_mode_v3_hw_write(struct file *filp,\n\t\t\t\t\t     const char __user *buf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct hisi_hba *hisi_hba = m->private;\n\tchar kbuf[16] = {}, *pkbuf;\n\tbool found = false;\n\tint i;\n\n\tif (hisi_hba->debugfs_bist_enable)\n\t\treturn -EPERM;\n\n\tif (count >= sizeof(kbuf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(kbuf, buf, count))\n\t\treturn -EOVERFLOW;\n\n\tpkbuf = strstrip(kbuf);\n\n\tfor (i = 0; i < ARRAY_SIZE(debugfs_loop_modes_v3_hw); i++) {\n\t\tif (!strncmp(debugfs_loop_modes_v3_hw[i].name, pkbuf, 16)) {\n\t\t\thisi_hba->debugfs_bist_mode =\n\t\t\t\tdebugfs_loop_modes_v3_hw[i].value;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic int debugfs_bist_mode_v3_hw_open(struct inode *inode,\n\t\t\t\t\tstruct file *filp)\n{\n\treturn single_open(filp, debugfs_bist_mode_v3_hw_show,\n\t\t\t   inode->i_private);\n}\n\nstatic const struct file_operations debugfs_bist_mode_v3_hw_fops = {\n\t.open = debugfs_bist_mode_v3_hw_open,\n\t.read = seq_read,\n\t.write = debugfs_bist_mode_v3_hw_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.owner = THIS_MODULE,\n};\n\nstatic ssize_t debugfs_bist_enable_v3_hw_write(struct file *filp,\n\t\t\t\t\t       const char __user *buf,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct hisi_hba *hisi_hba = m->private;\n\tunsigned int enable;\n\tint val;\n\n\tval = kstrtouint_from_user(buf, count, 0, &enable);\n\tif (val)\n\t\treturn val;\n\n\tif (enable > 1)\n\t\treturn -EINVAL;\n\n\tif (enable == hisi_hba->debugfs_bist_enable)\n\t\treturn count;\n\n\tval = debugfs_set_bist_v3_hw(hisi_hba, enable);\n\tif (val < 0)\n\t\treturn val;\n\n\thisi_hba->debugfs_bist_enable = enable;\n\n\treturn count;\n}\n\nstatic int debugfs_bist_enable_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_hba *hisi_hba = s->private;\n\n\tseq_printf(s, \"%d\\n\", hisi_hba->debugfs_bist_enable);\n\n\treturn 0;\n}\n\nstatic int debugfs_bist_enable_v3_hw_open(struct inode *inode,\n\t\t\t\t\t  struct file *filp)\n{\n\treturn single_open(filp, debugfs_bist_enable_v3_hw_show,\n\t\t\t   inode->i_private);\n}\n\nstatic const struct file_operations debugfs_bist_enable_v3_hw_fops = {\n\t.open = debugfs_bist_enable_v3_hw_open,\n\t.read = seq_read,\n\t.write = debugfs_bist_enable_v3_hw_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct {\n\tchar *name;\n} debugfs_ffe_name_v3_hw[FFE_CFG_MAX] = {\n\t{ \"SAS_1_5_GBPS\" },\n\t{ \"SAS_3_0_GBPS\" },\n\t{ \"SAS_6_0_GBPS\" },\n\t{ \"SAS_12_0_GBPS\" },\n\t{ \"FFE_RESV\" },\n\t{ \"SATA_1_5_GBPS\" },\n\t{ \"SATA_3_0_GBPS\" },\n\t{ \"SATA_6_0_GBPS\" },\n};\n\nstatic ssize_t debugfs_v3_hw_write(struct file *filp,\n\t\t\t\t   const char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tu32 *val = m->private;\n\tint res;\n\n\tres = kstrtouint_from_user(buf, count, 0, val);\n\tif (res)\n\t\treturn res;\n\n\treturn count;\n}\n\nstatic int debugfs_v3_hw_show(struct seq_file *s, void *p)\n{\n\tu32 *val = s->private;\n\n\tseq_printf(s, \"0x%x\\n\", *val);\n\n\treturn 0;\n}\n\nstatic int debugfs_v3_hw_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, debugfs_v3_hw_show,\n\t\t\t   inode->i_private);\n}\n\nstatic const struct file_operations debugfs_v3_hw_fops = {\n\t.open = debugfs_v3_hw_open,\n\t.read = seq_read,\n\t.write = debugfs_v3_hw_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.owner = THIS_MODULE,\n};\n\nstatic ssize_t debugfs_phy_down_cnt_v3_hw_write(struct file *filp,\n\t\t\t\t\t\tconst char __user *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct seq_file *s = filp->private_data;\n\tstruct hisi_sas_phy *phy = s->private;\n\tunsigned int set_val;\n\tint res;\n\n\tres = kstrtouint_from_user(buf, count, 0, &set_val);\n\tif (res)\n\t\treturn res;\n\n\tif (set_val > 0)\n\t\treturn -EINVAL;\n\n\tatomic_set(&phy->down_cnt, 0);\n\n\treturn count;\n}\n\nstatic int debugfs_phy_down_cnt_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_sas_phy *phy = s->private;\n\n\tseq_printf(s, \"%d\\n\", atomic_read(&phy->down_cnt));\n\n\treturn 0;\n}\n\nstatic int debugfs_phy_down_cnt_v3_hw_open(struct inode *inode,\n\t\t\t\t\t   struct file *filp)\n{\n\treturn single_open(filp, debugfs_phy_down_cnt_v3_hw_show,\n\t\t\t   inode->i_private);\n}\n\nstatic const struct file_operations debugfs_phy_down_cnt_v3_hw_fops = {\n\t.open = debugfs_phy_down_cnt_v3_hw_open,\n\t.read = seq_read,\n\t.write = debugfs_phy_down_cnt_v3_hw_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.owner = THIS_MODULE,\n};\n\nenum fifo_dump_mode_v3_hw {\n\tFIFO_DUMP_FORVER =\t\t(1U << 0),\n\tFIFO_DUMP_AFTER_TRIGGER =\t(1U << 1),\n\tFIFO_DUMP_UNTILL_TRIGGER =\t(1U << 2),\n};\n\nenum fifo_trigger_mode_v3_hw {\n\tFIFO_TRIGGER_EDGE =\t\t(1U << 0),\n\tFIFO_TRIGGER_SAME_LEVEL =\t(1U << 1),\n\tFIFO_TRIGGER_DIFF_LEVEL =\t(1U << 2),\n};\n\nstatic int debugfs_is_fifo_config_valid_v3_hw(struct hisi_sas_phy *phy)\n{\n\tstruct hisi_hba *hisi_hba = phy->hisi_hba;\n\n\tif (phy->fifo.signal_sel > 0xf) {\n\t\tdev_info(hisi_hba->dev, \"Invalid signal select: %u\\n\",\n\t\t\t phy->fifo.signal_sel);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (phy->fifo.dump_mode) {\n\tcase FIFO_DUMP_FORVER:\n\tcase FIFO_DUMP_AFTER_TRIGGER:\n\tcase FIFO_DUMP_UNTILL_TRIGGER:\n\t\tbreak;\n\tdefault:\n\t\tdev_info(hisi_hba->dev, \"Invalid dump mode: %u\\n\",\n\t\t\t phy->fifo.dump_mode);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (phy->fifo.dump_mode == FIFO_DUMP_FORVER)\n\t\treturn 0;\n\n\tswitch (phy->fifo.trigger_mode) {\n\tcase FIFO_TRIGGER_EDGE:\n\tcase FIFO_TRIGGER_SAME_LEVEL:\n\tcase FIFO_TRIGGER_DIFF_LEVEL:\n\t\tbreak;\n\tdefault:\n\t\tdev_info(hisi_hba->dev, \"Invalid trigger mode: %u\\n\",\n\t\t\t phy->fifo.trigger_mode);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int debugfs_update_fifo_config_v3_hw(struct hisi_sas_phy *phy)\n{\n\tu32 trigger_mode = phy->fifo.trigger_mode;\n\tu32 signal_sel = phy->fifo.signal_sel;\n\tu32 dump_mode = phy->fifo.dump_mode;\n\tstruct hisi_hba *hisi_hba = phy->hisi_hba;\n\tint phy_no = phy->sas_phy.id;\n\tu32 reg_val;\n\tint res;\n\n\t \n\tres = debugfs_is_fifo_config_valid_v3_hw(phy);\n\tif (res)\n\t\treturn res;\n\n\treg_val = hisi_sas_phy_read32(hisi_hba, phy_no, DFX_FIFO_CTRL);\n\t \n\treg_val |= DFX_FIFO_CTRL_DUMP_DISABLE_MSK;\n\n\t \n\treg_val &= ~(DFX_FIFO_CTRL_DUMP_MODE_MSK |\n\t\t     DFX_FIFO_CTRL_SIGNAL_SEL_MSK |\n\t\t     DFX_FIFO_CTRL_TRIGGER_MODE_MSK);\n\n\treg_val |= ((trigger_mode << DFX_FIFO_CTRL_TRIGGER_MODE_OFF) |\n\t\t    (dump_mode << DFX_FIFO_CTRL_DUMP_MODE_OFF) |\n\t\t    (signal_sel << DFX_FIFO_CTRL_SIGNAL_SEL_OFF));\n\thisi_sas_phy_write32(hisi_hba, phy_no, DFX_FIFO_CTRL, reg_val);\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, DFX_FIFO_DUMP_MSK,\n\t\t\t     phy->fifo.dump_msk);\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, DFX_FIFO_TRIGGER,\n\t\t\t     phy->fifo.trigger);\n\n\thisi_sas_phy_write32(hisi_hba, phy_no, DFX_FIFO_TRIGGER_MSK,\n\t\t\t     phy->fifo.trigger_msk);\n\n\t \n\treg_val = hisi_sas_phy_read32(hisi_hba, phy_no, DFX_FIFO_CTRL);\n\treg_val &= ~DFX_FIFO_CTRL_DUMP_DISABLE_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, DFX_FIFO_CTRL, reg_val);\n\n\treturn 0;\n}\n\nstatic ssize_t debugfs_fifo_update_cfg_v3_hw_write(struct file *filp,\n\t\t\t\t\t\t   const char __user *buf,\n\t\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct hisi_sas_phy *phy = filp->private_data;\n\tbool update;\n\tint val;\n\n\tval = kstrtobool_from_user(buf, count, &update);\n\tif (val)\n\t\treturn val;\n\n\tif (update != 1)\n\t\treturn -EINVAL;\n\n\tval = debugfs_update_fifo_config_v3_hw(phy);\n\tif (val)\n\t\treturn val;\n\n\treturn count;\n}\n\nstatic const struct file_operations debugfs_fifo_update_cfg_v3_hw_fops = {\n\t.open = simple_open,\n\t.write = debugfs_fifo_update_cfg_v3_hw_write,\n\t.owner = THIS_MODULE,\n};\n\nstatic void debugfs_read_fifo_data_v3_hw(struct hisi_sas_phy *phy)\n{\n\tstruct hisi_hba *hisi_hba = phy->hisi_hba;\n\tu32 *buf = phy->fifo.rd_data;\n\tint phy_no = phy->sas_phy.id;\n\tu32 val;\n\tint i;\n\n\tmemset(buf, 0, sizeof(phy->fifo.rd_data));\n\n\t \n\tval = hisi_sas_phy_read32(hisi_hba, phy_no, DFX_FIFO_CTRL);\n\tval |= DFX_FIFO_CTRL_DUMP_DISABLE_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, DFX_FIFO_CTRL, val);\n\n\tfor (i = 0; i < HISI_SAS_FIFO_DATA_DW_SIZE; i++) {\n\t\tval = hisi_sas_phy_read32(hisi_hba, phy_no,\n\t\t\t\t\t  DFX_FIFO_RD_DATA);\n\t\tbuf[i] = val;\n\t}\n\n\t \n\tval = hisi_sas_phy_read32(hisi_hba, phy_no, DFX_FIFO_CTRL);\n\tval &= ~DFX_FIFO_CTRL_DUMP_DISABLE_MSK;\n\thisi_sas_phy_write32(hisi_hba, phy_no, DFX_FIFO_CTRL, val);\n}\n\nstatic int debugfs_fifo_data_v3_hw_show(struct seq_file *s, void *p)\n{\n\tstruct hisi_sas_phy *phy = s->private;\n\n\tdebugfs_read_fifo_data_v3_hw(phy);\n\n\tdebugfs_show_row_32_v3_hw(s, 0, HISI_SAS_FIFO_DATA_DW_SIZE * 4,\n\t\t\t\t  (__le32 *)phy->fifo.rd_data);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_fifo_data_v3_hw);\n\nstatic void debugfs_fifo_init_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tint phy_no;\n\n\thisi_hba->debugfs_fifo_dentry =\n\t\t\tdebugfs_create_dir(\"fifo\", hisi_hba->debugfs_dir);\n\n\tfor (phy_no = 0; phy_no < hisi_hba->n_phy; phy_no++) {\n\t\tstruct hisi_sas_phy *phy = &hisi_hba->phy[phy_no];\n\t\tstruct dentry *port_dentry;\n\t\tchar name[256];\n\t\tu32 val;\n\n\t\t \n\t\tval = hisi_sas_phy_read32(hisi_hba, phy_no, DFX_FIFO_CTRL);\n\t\tval &= DFX_FIFO_CTRL_DUMP_MODE_MSK;\n\t\tval >>= DFX_FIFO_CTRL_DUMP_MODE_OFF;\n\t\tphy->fifo.dump_mode = val;\n\n\t\tval = hisi_sas_phy_read32(hisi_hba, phy_no, DFX_FIFO_CTRL);\n\t\tval &= DFX_FIFO_CTRL_TRIGGER_MODE_MSK;\n\t\tval >>= DFX_FIFO_CTRL_TRIGGER_MODE_OFF;\n\t\tphy->fifo.trigger_mode = val;\n\n\t\tval = hisi_sas_phy_read32(hisi_hba, phy_no, DFX_FIFO_CTRL);\n\t\tval &= DFX_FIFO_CTRL_SIGNAL_SEL_MSK;\n\t\tval >>= DFX_FIFO_CTRL_SIGNAL_SEL_OFF;\n\t\tphy->fifo.signal_sel = val;\n\n\t\tval = hisi_sas_phy_read32(hisi_hba, phy_no, DFX_FIFO_DUMP_MSK);\n\t\tphy->fifo.dump_msk = val;\n\n\t\tval = hisi_sas_phy_read32(hisi_hba, phy_no, DFX_FIFO_TRIGGER);\n\t\tphy->fifo.trigger = val;\n\t\tval = hisi_sas_phy_read32(hisi_hba, phy_no, DFX_FIFO_TRIGGER_MSK);\n\t\tphy->fifo.trigger_msk = val;\n\n\t\tsnprintf(name, 256, \"%d\", phy_no);\n\t\tport_dentry = debugfs_create_dir(name,\n\t\t\t\t\t\t hisi_hba->debugfs_fifo_dentry);\n\n\t\tdebugfs_create_file(\"update_config\", 0200, port_dentry, phy,\n\t\t\t\t    &debugfs_fifo_update_cfg_v3_hw_fops);\n\n\t\tdebugfs_create_file(\"signal_sel\", 0600, port_dentry,\n\t\t\t\t    &phy->fifo.signal_sel,\n\t\t\t\t    &debugfs_v3_hw_fops);\n\n\t\tdebugfs_create_file(\"dump_msk\", 0600, port_dentry,\n\t\t\t\t    &phy->fifo.dump_msk,\n\t\t\t\t    &debugfs_v3_hw_fops);\n\n\t\tdebugfs_create_file(\"dump_mode\", 0600, port_dentry,\n\t\t\t\t    &phy->fifo.dump_mode,\n\t\t\t\t    &debugfs_v3_hw_fops);\n\n\t\tdebugfs_create_file(\"trigger_mode\", 0600, port_dentry,\n\t\t\t\t    &phy->fifo.trigger_mode,\n\t\t\t\t    &debugfs_v3_hw_fops);\n\n\t\tdebugfs_create_file(\"trigger\", 0600, port_dentry,\n\t\t\t\t    &phy->fifo.trigger,\n\t\t\t\t    &debugfs_v3_hw_fops);\n\n\t\tdebugfs_create_file(\"trigger_msk\", 0600, port_dentry,\n\t\t\t\t    &phy->fifo.trigger_msk,\n\t\t\t\t    &debugfs_v3_hw_fops);\n\n\t\tdebugfs_create_file(\"fifo_data\", 0400, port_dentry, phy,\n\t\t\t\t    &debugfs_fifo_data_v3_hw_fops);\n\t}\n}\n\nstatic void debugfs_work_handler_v3_hw(struct work_struct *work)\n{\n\tstruct hisi_hba *hisi_hba =\n\t\tcontainer_of(work, struct hisi_hba, debugfs_work);\n\n\tdebugfs_snapshot_regs_v3_hw(hisi_hba);\n}\n\nstatic void debugfs_release_v3_hw(struct hisi_hba *hisi_hba, int dump_index)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tint i;\n\n\tdevm_kfree(dev, hisi_hba->debugfs_iost_cache[dump_index].cache);\n\tdevm_kfree(dev, hisi_hba->debugfs_itct_cache[dump_index].cache);\n\tdevm_kfree(dev, hisi_hba->debugfs_iost[dump_index].iost);\n\tdevm_kfree(dev, hisi_hba->debugfs_itct[dump_index].itct);\n\n\tfor (i = 0; i < hisi_hba->queue_count; i++)\n\t\tdevm_kfree(dev, hisi_hba->debugfs_dq[dump_index][i].hdr);\n\n\tfor (i = 0; i < hisi_hba->queue_count; i++)\n\t\tdevm_kfree(dev,\n\t\t\t   hisi_hba->debugfs_cq[dump_index][i].complete_hdr);\n\n\tfor (i = 0; i < DEBUGFS_REGS_NUM; i++)\n\t\tdevm_kfree(dev, hisi_hba->debugfs_regs[dump_index][i].data);\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++)\n\t\tdevm_kfree(dev, hisi_hba->debugfs_port_reg[dump_index][i].data);\n}\n\nstatic const struct hisi_sas_debugfs_reg *debugfs_reg_array_v3_hw[DEBUGFS_REGS_NUM] = {\n\t[DEBUGFS_GLOBAL] = &debugfs_global_reg,\n\t[DEBUGFS_AXI] = &debugfs_axi_reg,\n\t[DEBUGFS_RAS] = &debugfs_ras_reg,\n};\n\nstatic int debugfs_alloc_v3_hw(struct hisi_hba *hisi_hba, int dump_index)\n{\n\tconst struct hisi_sas_hw *hw = hisi_hba->hw;\n\tstruct device *dev = hisi_hba->dev;\n\tint p, c, d, r, i;\n\tsize_t sz;\n\n\tfor (r = 0; r < DEBUGFS_REGS_NUM; r++) {\n\t\tstruct hisi_sas_debugfs_regs *regs =\n\t\t\t\t&hisi_hba->debugfs_regs[dump_index][r];\n\n\t\tsz = debugfs_reg_array_v3_hw[r]->count * 4;\n\t\tregs->data = devm_kmalloc(dev, sz, GFP_KERNEL);\n\t\tif (!regs->data)\n\t\t\tgoto fail;\n\t\tregs->hisi_hba = hisi_hba;\n\t}\n\n\tsz = debugfs_port_reg.count * 4;\n\tfor (p = 0; p < hisi_hba->n_phy; p++) {\n\t\tstruct hisi_sas_debugfs_port *port =\n\t\t\t\t&hisi_hba->debugfs_port_reg[dump_index][p];\n\n\t\tport->data = devm_kmalloc(dev, sz, GFP_KERNEL);\n\t\tif (!port->data)\n\t\t\tgoto fail;\n\t\tport->phy = &hisi_hba->phy[p];\n\t}\n\n\tsz = hw->complete_hdr_size * HISI_SAS_QUEUE_SLOTS;\n\tfor (c = 0; c < hisi_hba->queue_count; c++) {\n\t\tstruct hisi_sas_debugfs_cq *cq =\n\t\t\t\t&hisi_hba->debugfs_cq[dump_index][c];\n\n\t\tcq->complete_hdr = devm_kmalloc(dev, sz, GFP_KERNEL);\n\t\tif (!cq->complete_hdr)\n\t\t\tgoto fail;\n\t\tcq->cq = &hisi_hba->cq[c];\n\t}\n\n\tsz = sizeof(struct hisi_sas_cmd_hdr) * HISI_SAS_QUEUE_SLOTS;\n\tfor (d = 0; d < hisi_hba->queue_count; d++) {\n\t\tstruct hisi_sas_debugfs_dq *dq =\n\t\t\t\t&hisi_hba->debugfs_dq[dump_index][d];\n\n\t\tdq->hdr = devm_kmalloc(dev, sz, GFP_KERNEL);\n\t\tif (!dq->hdr)\n\t\t\tgoto fail;\n\t\tdq->dq = &hisi_hba->dq[d];\n\t}\n\n\tsz = HISI_SAS_MAX_COMMANDS * sizeof(struct hisi_sas_iost);\n\n\thisi_hba->debugfs_iost[dump_index].iost =\n\t\t\t\tdevm_kmalloc(dev, sz, GFP_KERNEL);\n\tif (!hisi_hba->debugfs_iost[dump_index].iost)\n\t\tgoto fail;\n\n\tsz = HISI_SAS_IOST_ITCT_CACHE_NUM *\n\t     sizeof(struct hisi_sas_iost_itct_cache);\n\n\thisi_hba->debugfs_iost_cache[dump_index].cache =\n\t\t\t\tdevm_kmalloc(dev, sz, GFP_KERNEL);\n\tif (!hisi_hba->debugfs_iost_cache[dump_index].cache)\n\t\tgoto fail;\n\n\tsz = HISI_SAS_IOST_ITCT_CACHE_NUM *\n\t     sizeof(struct hisi_sas_iost_itct_cache);\n\n\thisi_hba->debugfs_itct_cache[dump_index].cache =\n\t\t\t\tdevm_kmalloc(dev, sz, GFP_KERNEL);\n\tif (!hisi_hba->debugfs_itct_cache[dump_index].cache)\n\t\tgoto fail;\n\n\t \n\tsz = HISI_SAS_MAX_ITCT_ENTRIES * sizeof(struct hisi_sas_itct);\n\n\thisi_hba->debugfs_itct[dump_index].itct =\n\t\t\t\tdevm_kmalloc(dev, sz, GFP_KERNEL);\n\tif (!hisi_hba->debugfs_itct[dump_index].itct)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tfor (i = 0; i < hisi_sas_debugfs_dump_count; i++)\n\t\tdebugfs_release_v3_hw(hisi_hba, i);\n\treturn -ENOMEM;\n}\n\nstatic void debugfs_phy_down_cnt_init_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct dentry *dir = debugfs_create_dir(\"phy_down_cnt\",\n\t\t\t\t\t\thisi_hba->debugfs_dir);\n\tchar name[16];\n\tint phy_no;\n\n\tfor (phy_no = 0; phy_no < hisi_hba->n_phy; phy_no++) {\n\t\tsnprintf(name, 16, \"%d\", phy_no);\n\t\tdebugfs_create_file(name, 0600, dir,\n\t\t\t\t    &hisi_hba->phy[phy_no],\n\t\t\t\t    &debugfs_phy_down_cnt_v3_hw_fops);\n\t}\n}\n\nstatic void debugfs_bist_init_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct dentry *ports_dentry;\n\tint phy_no;\n\n\thisi_hba->debugfs_bist_dentry =\n\t\t\tdebugfs_create_dir(\"bist\", hisi_hba->debugfs_dir);\n\tdebugfs_create_file(\"link_rate\", 0600,\n\t\t\t    hisi_hba->debugfs_bist_dentry, hisi_hba,\n\t\t\t    &debugfs_bist_linkrate_v3_hw_fops);\n\n\tdebugfs_create_file(\"code_mode\", 0600,\n\t\t\t    hisi_hba->debugfs_bist_dentry, hisi_hba,\n\t\t\t    &debugfs_bist_code_mode_v3_hw_fops);\n\n\tdebugfs_create_file(\"fixed_code\", 0600,\n\t\t\t    hisi_hba->debugfs_bist_dentry,\n\t\t\t    &hisi_hba->debugfs_bist_fixed_code[0],\n\t\t\t    &debugfs_v3_hw_fops);\n\n\tdebugfs_create_file(\"fixed_code_1\", 0600,\n\t\t\t    hisi_hba->debugfs_bist_dentry,\n\t\t\t    &hisi_hba->debugfs_bist_fixed_code[1],\n\t\t\t    &debugfs_v3_hw_fops);\n\n\tdebugfs_create_file(\"phy_id\", 0600, hisi_hba->debugfs_bist_dentry,\n\t\t\t    hisi_hba, &debugfs_bist_phy_v3_hw_fops);\n\n\tdebugfs_create_file(\"cnt\", 0600, hisi_hba->debugfs_bist_dentry,\n\t\t\t    hisi_hba, &debugfs_bist_cnt_v3_hw_ops);\n\n\tdebugfs_create_file(\"loopback_mode\", 0600,\n\t\t\t    hisi_hba->debugfs_bist_dentry,\n\t\t\t    hisi_hba, &debugfs_bist_mode_v3_hw_fops);\n\n\tdebugfs_create_file(\"enable\", 0600, hisi_hba->debugfs_bist_dentry,\n\t\t\t    hisi_hba, &debugfs_bist_enable_v3_hw_fops);\n\n\tports_dentry = debugfs_create_dir(\"port\", hisi_hba->debugfs_bist_dentry);\n\n\tfor (phy_no = 0; phy_no < hisi_hba->n_phy; phy_no++) {\n\t\tstruct dentry *port_dentry;\n\t\tstruct dentry *ffe_dentry;\n\t\tchar name[256];\n\t\tint i;\n\n\t\tsnprintf(name, 256, \"%d\", phy_no);\n\t\tport_dentry = debugfs_create_dir(name, ports_dentry);\n\t\tffe_dentry = debugfs_create_dir(\"ffe\", port_dentry);\n\t\tfor (i = 0; i < FFE_CFG_MAX; i++) {\n\t\t\tif (i == FFE_RESV)\n\t\t\t\tcontinue;\n\t\t\tdebugfs_create_file(debugfs_ffe_name_v3_hw[i].name,\n\t\t\t\t\t    0600, ffe_dentry,\n\t\t\t\t\t    &hisi_hba->debugfs_bist_ffe[phy_no][i],\n\t\t\t\t\t    &debugfs_v3_hw_fops);\n\t\t}\n\t}\n\n\thisi_hba->debugfs_bist_linkrate = SAS_LINK_RATE_1_5_GBPS;\n}\n\nstatic void debugfs_exit_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tdebugfs_remove_recursive(hisi_hba->debugfs_dir);\n\thisi_hba->debugfs_dir = NULL;\n}\n\nstatic void debugfs_init_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tstruct device *dev = hisi_hba->dev;\n\tint i;\n\n\thisi_hba->debugfs_dir = debugfs_create_dir(dev_name(dev),\n\t\t\t\t\t\t   hisi_sas_debugfs_dir);\n\tdebugfs_create_file(\"trigger_dump\", 0200,\n\t\t\t    hisi_hba->debugfs_dir,\n\t\t\t    hisi_hba,\n\t\t\t    &debugfs_trigger_dump_v3_hw_fops);\n\n\t \n\tdebugfs_bist_init_v3_hw(hisi_hba);\n\n\thisi_hba->debugfs_dump_dentry =\n\t\t\tdebugfs_create_dir(\"dump\", hisi_hba->debugfs_dir);\n\n\tdebugfs_phy_down_cnt_init_v3_hw(hisi_hba);\n\tdebugfs_fifo_init_v3_hw(hisi_hba);\n\n\tfor (i = 0; i < hisi_sas_debugfs_dump_count; i++) {\n\t\tif (debugfs_alloc_v3_hw(hisi_hba, i)) {\n\t\t\tdebugfs_exit_v3_hw(hisi_hba);\n\t\t\tdev_dbg(dev, \"failed to init debugfs!\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int\nhisi_sas_v3_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct Scsi_Host *shost;\n\tstruct hisi_hba *hisi_hba;\n\tstruct device *dev = &pdev->dev;\n\tstruct asd_sas_phy **arr_phy;\n\tstruct asd_sas_port **arr_port;\n\tstruct sas_ha_struct *sha;\n\tint rc, phy_nr, port_nr, i;\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\tgoto err_out;\n\n\tpci_set_master(pdev);\n\n\trc = pcim_iomap_regions(pdev, 1 << BAR_NO_V3_HW, DRV_NAME);\n\tif (rc)\n\t\tgoto err_out;\n\n\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (rc) {\n\t\tdev_err(dev, \"No usable DMA addressing method\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\tshost = hisi_sas_shost_alloc_pci(pdev);\n\tif (!shost) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tsha = SHOST_TO_SAS_HA(shost);\n\thisi_hba = shost_priv(shost);\n\tdev_set_drvdata(dev, sha);\n\n\thisi_hba->regs = pcim_iomap_table(pdev)[BAR_NO_V3_HW];\n\tif (!hisi_hba->regs) {\n\t\tdev_err(dev, \"cannot map register\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_out_free_host;\n\t}\n\n\tphy_nr = port_nr = hisi_hba->n_phy;\n\n\tarr_phy = devm_kcalloc(dev, phy_nr, sizeof(void *), GFP_KERNEL);\n\tarr_port = devm_kcalloc(dev, port_nr, sizeof(void *), GFP_KERNEL);\n\tif (!arr_phy || !arr_port) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_free_host;\n\t}\n\n\tsha->sas_phy = arr_phy;\n\tsha->sas_port = arr_port;\n\tsha->shost = shost;\n\tsha->lldd_ha = hisi_hba;\n\n\tshost->transportt = hisi_sas_stt;\n\tshost->max_id = HISI_SAS_MAX_DEVICES;\n\tshost->max_lun = ~0;\n\tshost->max_channel = 1;\n\tshost->max_cmd_len = 16;\n\tshost->can_queue = HISI_SAS_UNRESERVED_IPTT;\n\tshost->cmd_per_lun = HISI_SAS_UNRESERVED_IPTT;\n\tif (hisi_hba->iopoll_q_cnt)\n\t\tshost->nr_maps = 3;\n\telse\n\t\tshost->nr_maps = 1;\n\n\tsha->sas_ha_name = DRV_NAME;\n\tsha->dev = dev;\n\tsha->sas_addr = &hisi_hba->sas_addr[0];\n\tsha->num_phys = hisi_hba->n_phy;\n\n\tfor (i = 0; i < hisi_hba->n_phy; i++) {\n\t\tsha->sas_phy[i] = &hisi_hba->phy[i].sas_phy;\n\t\tsha->sas_port[i] = &hisi_hba->port[i].sas_port;\n\t}\n\n\tif (hisi_hba->prot_mask) {\n\t\tdev_info(dev, \"Registering for DIF/DIX prot_mask=0x%x\\n\",\n\t\t\t prot_mask);\n\t\tscsi_host_set_prot(hisi_hba->shost, prot_mask);\n\t\tif (hisi_hba->prot_mask & HISI_SAS_DIX_PROT_MASK)\n\t\t\tscsi_host_set_guard(hisi_hba->shost,\n\t\t\t\t\t    SHOST_DIX_GUARD_CRC);\n\t}\n\n\tif (hisi_sas_debugfs_enable)\n\t\tdebugfs_init_v3_hw(hisi_hba);\n\n\trc = interrupt_preinit_v3_hw(hisi_hba);\n\tif (rc)\n\t\tgoto err_out_undo_debugfs;\n\n\trc = scsi_add_host(shost, dev);\n\tif (rc)\n\t\tgoto err_out_undo_debugfs;\n\n\trc = sas_register_ha(sha);\n\tif (rc)\n\t\tgoto err_out_remove_host;\n\n\trc = hisi_sas_v3_init(hisi_hba);\n\tif (rc)\n\t\tgoto err_out_unregister_ha;\n\n\tscsi_scan_host(shost);\n\n\tpm_runtime_set_autosuspend_delay(dev, 5000);\n\tpm_runtime_use_autosuspend(dev);\n\t \n\tpm_suspend_ignore_children(dev, true);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\treturn 0;\n\nerr_out_unregister_ha:\n\tsas_unregister_ha(sha);\nerr_out_remove_host:\n\tscsi_remove_host(shost);\nerr_out_undo_debugfs:\n\tdebugfs_exit_v3_hw(hisi_hba);\nerr_out_free_host:\n\thisi_sas_free(hisi_hba);\n\tscsi_host_put(shost);\nerr_out:\n\treturn rc;\n}\n\nstatic void\nhisi_sas_v3_destroy_irqs(struct pci_dev *pdev, struct hisi_hba *hisi_hba)\n{\n\tint i;\n\n\tdevm_free_irq(&pdev->dev, pci_irq_vector(pdev, 1), hisi_hba);\n\tdevm_free_irq(&pdev->dev, pci_irq_vector(pdev, 2), hisi_hba);\n\tdevm_free_irq(&pdev->dev, pci_irq_vector(pdev, 11), hisi_hba);\n\tfor (i = 0; i < hisi_hba->cq_nvecs; i++) {\n\t\tstruct hisi_sas_cq *cq = &hisi_hba->cq[i];\n\t\tint nr = hisi_sas_intr_conv ? 16 : 16 + i;\n\n\t\tdevm_free_irq(&pdev->dev, pci_irq_vector(pdev, nr), cq);\n\t}\n}\n\nstatic void hisi_sas_v3_remove(struct pci_dev *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sas_ha_struct *sha = dev_get_drvdata(dev);\n\tstruct hisi_hba *hisi_hba = sha->lldd_ha;\n\tstruct Scsi_Host *shost = sha->shost;\n\n\tpm_runtime_get_noresume(dev);\n\tdel_timer_sync(&hisi_hba->timer);\n\n\tsas_unregister_ha(sha);\n\tflush_workqueue(hisi_hba->wq);\n\tsas_remove_host(shost);\n\n\thisi_sas_v3_destroy_irqs(pdev, hisi_hba);\n\thisi_sas_free(hisi_hba);\n\tdebugfs_exit_v3_hw(hisi_hba);\n\tscsi_host_put(shost);\n}\n\nstatic void hisi_sas_reset_prepare_v3_hw(struct pci_dev *pdev)\n{\n\tstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\n\tstruct hisi_hba *hisi_hba = sha->lldd_ha;\n\tstruct device *dev = hisi_hba->dev;\n\tint rc;\n\n\tdev_info(dev, \"FLR prepare\\n\");\n\tdown(&hisi_hba->sem);\n\tset_bit(HISI_SAS_RESETTING_BIT, &hisi_hba->flags);\n\thisi_sas_controller_reset_prepare(hisi_hba);\n\n\tinterrupt_disable_v3_hw(hisi_hba);\n\trc = disable_host_v3_hw(hisi_hba);\n\tif (rc)\n\t\tdev_err(dev, \"FLR: disable host failed rc=%d\\n\", rc);\n}\n\nstatic void hisi_sas_reset_done_v3_hw(struct pci_dev *pdev)\n{\n\tstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\n\tstruct hisi_hba *hisi_hba = sha->lldd_ha;\n\tstruct Scsi_Host *shost = hisi_hba->shost;\n\tstruct device *dev = hisi_hba->dev;\n\tint rc;\n\n\thisi_sas_init_mem(hisi_hba);\n\n\trc = hw_init_v3_hw(hisi_hba);\n\tif (rc) {\n\t\tdev_err(dev, \"FLR: hw init failed rc=%d\\n\", rc);\n\t\tclear_bit(HISI_SAS_REJECT_CMD_BIT, &hisi_hba->flags);\n\t\tscsi_unblock_requests(shost);\n\t\tclear_bit(HISI_SAS_RESETTING_BIT, &hisi_hba->flags);\n\t\tup(&hisi_hba->sem);\n\t\treturn;\n\t}\n\n\thisi_sas_controller_reset_done(hisi_hba);\n\tdev_info(dev, \"FLR done\\n\");\n}\n\nenum {\n\t \n\thip08,\n};\n\nstatic void enable_host_v3_hw(struct hisi_hba *hisi_hba)\n{\n\tu32 reg_val;\n\n\thisi_sas_write32(hisi_hba, DLVRY_QUEUE_ENABLE,\n\t\t\t (u32)((1ULL << hisi_hba->queue_count) - 1));\n\n\tphys_init_v3_hw(hisi_hba);\n\treg_val = hisi_sas_read32(hisi_hba, AXI_MASTER_CFG_BASE +\n\t\t\t\t  AM_CTRL_GLOBAL);\n\treg_val &= ~AM_CTRL_SHUTDOWN_REQ_MSK;\n\thisi_sas_write32(hisi_hba, AXI_MASTER_CFG_BASE +\n\t\t\t AM_CTRL_GLOBAL, reg_val);\n}\n\nstatic int _suspend_v3_hw(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\n\tstruct hisi_hba *hisi_hba = sha->lldd_ha;\n\tstruct device *dev = hisi_hba->dev;\n\tstruct Scsi_Host *shost = hisi_hba->shost;\n\tint rc;\n\n\tif (!pdev->pm_cap) {\n\t\tdev_err(dev, \"PCI PM not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (test_and_set_bit(HISI_SAS_RESETTING_BIT, &hisi_hba->flags))\n\t\treturn -EPERM;\n\n\tdev_warn(dev, \"entering suspend state\\n\");\n\n\tscsi_block_requests(shost);\n\tset_bit(HISI_SAS_REJECT_CMD_BIT, &hisi_hba->flags);\n\tflush_workqueue(hisi_hba->wq);\n\tinterrupt_disable_v3_hw(hisi_hba);\n\n#ifdef CONFIG_PM\n\tif (atomic_read(&device->power.usage_count)) {\n\t\tdev_err(dev, \"PM suspend: host status cannot be suspended\\n\");\n\t\trc = -EBUSY;\n\t\tgoto err_out;\n\t}\n#endif\n\n\trc = disable_host_v3_hw(hisi_hba);\n\tif (rc) {\n\t\tdev_err(dev, \"PM suspend: disable host failed rc=%d\\n\", rc);\n\t\tgoto err_out_recover_host;\n\t}\n\n\thisi_sas_init_mem(hisi_hba);\n\n\thisi_sas_release_tasks(hisi_hba);\n\n\tsas_suspend_ha(sha);\n\n\tdev_warn(dev, \"end of suspending controller\\n\");\n\treturn 0;\n\nerr_out_recover_host:\n\tenable_host_v3_hw(hisi_hba);\n#ifdef CONFIG_PM\nerr_out:\n#endif\n\tinterrupt_enable_v3_hw(hisi_hba);\n\tclear_bit(HISI_SAS_REJECT_CMD_BIT, &hisi_hba->flags);\n\tclear_bit(HISI_SAS_RESETTING_BIT, &hisi_hba->flags);\n\tscsi_unblock_requests(shost);\n\treturn rc;\n}\n\nstatic int _resume_v3_hw(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\n\tstruct hisi_hba *hisi_hba = sha->lldd_ha;\n\tstruct Scsi_Host *shost = hisi_hba->shost;\n\tstruct device *dev = hisi_hba->dev;\n\tunsigned int rc;\n\tpci_power_t device_state = pdev->current_state;\n\n\tdev_warn(dev, \"resuming from operating state [D%d]\\n\",\n\t\t device_state);\n\n\tscsi_unblock_requests(shost);\n\tclear_bit(HISI_SAS_REJECT_CMD_BIT, &hisi_hba->flags);\n\n\tsas_prep_resume_ha(sha);\n\trc = hw_init_v3_hw(hisi_hba);\n\tif (rc) {\n\t\tscsi_remove_host(shost);\n\t\treturn rc;\n\t}\n\tphys_init_v3_hw(hisi_hba);\n\n\t \n\tsas_resume_ha_no_sync(sha);\n\tclear_bit(HISI_SAS_RESETTING_BIT, &hisi_hba->flags);\n\n\tdev_warn(dev, \"end of resuming controller\\n\");\n\n\treturn 0;\n}\n\nstatic int __maybe_unused suspend_v3_hw(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\n\tstruct hisi_hba *hisi_hba = sha->lldd_ha;\n\tint rc;\n\n\tset_bit(HISI_SAS_PM_BIT, &hisi_hba->flags);\n\n\trc = _suspend_v3_hw(device);\n\tif (rc)\n\t\tclear_bit(HISI_SAS_PM_BIT, &hisi_hba->flags);\n\n\treturn rc;\n}\n\nstatic int __maybe_unused resume_v3_hw(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\n\tstruct hisi_hba *hisi_hba = sha->lldd_ha;\n\tint rc = _resume_v3_hw(device);\n\n\tclear_bit(HISI_SAS_PM_BIT, &hisi_hba->flags);\n\n\treturn rc;\n}\n\nstatic const struct pci_device_id sas_v3_pci_table[] = {\n\t{ PCI_VDEVICE(HUAWEI, 0xa230), hip08 },\n\t{}\n};\nMODULE_DEVICE_TABLE(pci, sas_v3_pci_table);\n\nstatic const struct pci_error_handlers hisi_sas_err_handler = {\n\t.reset_prepare\t= hisi_sas_reset_prepare_v3_hw,\n\t.reset_done\t= hisi_sas_reset_done_v3_hw,\n};\n\nstatic UNIVERSAL_DEV_PM_OPS(hisi_sas_v3_pm_ops,\n\t\t\t    suspend_v3_hw,\n\t\t\t    resume_v3_hw,\n\t\t\t    NULL);\n\nstatic struct pci_driver sas_v3_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= sas_v3_pci_table,\n\t.probe\t\t= hisi_sas_v3_probe,\n\t.remove\t\t= hisi_sas_v3_remove,\n\t.err_handler\t= &hisi_sas_err_handler,\n\t.driver.pm\t= &hisi_sas_v3_pm_ops,\n};\n\nmodule_pci_driver(sas_v3_pci_driver);\nmodule_param_named(intr_conv, hisi_sas_intr_conv, bool, 0444);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"John Garry <john.garry@huawei.com>\");\nMODULE_DESCRIPTION(\"HISILICON SAS controller v3 hw driver based on pci device\");\nMODULE_ALIAS(\"pci:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}