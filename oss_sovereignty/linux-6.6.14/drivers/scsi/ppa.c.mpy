{
  "module_name": "ppa.c",
  "hash_id": "bd2157d3552d3a140ded6fa9640383d3832c8516ca798409f356324a8c25b0be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/ppa.c",
  "human_readable_source": " \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/parport.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <asm/io.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n\n\nstatic void ppa_reset_pulse(unsigned int base);\n\ntypedef struct {\n\tstruct pardevice *dev;\t \n\tint base;\t\t \n\tint mode;\t\t \n\tstruct scsi_cmnd *cur_cmd;\t \n\tstruct delayed_work ppa_tq;\t \n\tunsigned long jstart;\t \n\tunsigned long recon_tmo;\t \n\tunsigned int failed:1;\t \n\tunsigned wanted:1;\t \n\tunsigned int dev_no;\t \n\twait_queue_head_t *waiting;\n\tstruct Scsi_Host *host;\n\tstruct list_head list;\n} ppa_struct;\n\n#include  \"ppa.h\"\n\nstatic unsigned int mode = PPA_AUTODETECT;\nmodule_param(mode, uint, 0644);\nMODULE_PARM_DESC(mode, \"Transfer mode (0 = Autodetect, 1 = SPP 4-bit, \"\n\t\"2 = SPP 8-bit, 3 = EPP 8-bit, 4 = EPP 16-bit, 5 = EPP 32-bit\");\n\nstatic struct scsi_pointer *ppa_scsi_pointer(struct scsi_cmnd *cmd)\n{\n\treturn scsi_cmd_priv(cmd);\n}\n\nstatic inline ppa_struct *ppa_dev(struct Scsi_Host *host)\n{\n\treturn *(ppa_struct **)&host->hostdata;\n}\n\nstatic DEFINE_SPINLOCK(arbitration_lock);\n\nstatic void got_it(ppa_struct *dev)\n{\n\tdev->base = dev->dev->port->base;\n\tif (dev->cur_cmd)\n\t\tppa_scsi_pointer(dev->cur_cmd)->phase = 1;\n\telse\n\t\twake_up(dev->waiting);\n}\n\nstatic void ppa_wakeup(void *ref)\n{\n\tppa_struct *dev = (ppa_struct *) ref;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&arbitration_lock, flags);\n\tif (dev->wanted) {\n\t\tparport_claim(dev->dev);\n\t\tgot_it(dev);\n\t\tdev->wanted = 0;\n\t}\n\tspin_unlock_irqrestore(&arbitration_lock, flags);\n\treturn;\n}\n\nstatic int ppa_pb_claim(ppa_struct *dev)\n{\n\tunsigned long flags;\n\tint res = 1;\n\tspin_lock_irqsave(&arbitration_lock, flags);\n\tif (parport_claim(dev->dev) == 0) {\n\t\tgot_it(dev);\n\t\tres = 0;\n\t}\n\tdev->wanted = res;\n\tspin_unlock_irqrestore(&arbitration_lock, flags);\n\treturn res;\n}\n\nstatic void ppa_pb_dismiss(ppa_struct *dev)\n{\n\tunsigned long flags;\n\tint wanted;\n\tspin_lock_irqsave(&arbitration_lock, flags);\n\twanted = dev->wanted;\n\tdev->wanted = 0;\n\tspin_unlock_irqrestore(&arbitration_lock, flags);\n\tif (!wanted)\n\t\tparport_release(dev->dev);\n}\n\nstatic inline void ppa_pb_release(ppa_struct *dev)\n{\n\tparport_release(dev->dev);\n}\n\n \n\n \n\nstatic inline int ppa_write_info(struct Scsi_Host *host, char *buffer, int length)\n{\n\tppa_struct *dev = ppa_dev(host);\n\tunsigned long x;\n\n\tif ((length > 5) && (strncmp(buffer, \"mode=\", 5) == 0)) {\n\t\tx = simple_strtoul(buffer + 5, NULL, 0);\n\t\tdev->mode = x;\n\t\treturn length;\n\t}\n\tif ((length > 10) && (strncmp(buffer, \"recon_tmo=\", 10) == 0)) {\n\t\tx = simple_strtoul(buffer + 10, NULL, 0);\n\t\tdev->recon_tmo = x;\n\t\tprintk(KERN_INFO \"ppa: recon_tmo set to %ld\\n\", x);\n\t\treturn length;\n\t}\n\tprintk(KERN_WARNING \"ppa /proc: invalid variable\\n\");\n\treturn -EINVAL;\n}\n\nstatic int ppa_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tppa_struct *dev = ppa_dev(host);\n\n\tseq_printf(m, \"Version : %s\\n\", PPA_VERSION);\n\tseq_printf(m, \"Parport : %s\\n\", dev->dev->port->name);\n\tseq_printf(m, \"Mode    : %s\\n\", PPA_MODE_STRING[dev->mode]);\n#if PPA_DEBUG > 0\n\tseq_printf(m, \"recon_tmo : %lu\\n\", dev->recon_tmo);\n#endif\n\treturn 0;\n}\n\nstatic int device_check(ppa_struct *dev, bool autodetect);\n\n#if PPA_DEBUG > 0\n#define ppa_fail(x,y) printk(\"ppa: ppa_fail(%i) from %s at line %d\\n\",\\\n\t   y, __func__, __LINE__); ppa_fail_func(x,y);\nstatic inline void ppa_fail_func(ppa_struct *dev, int error_code)\n#else\nstatic inline void ppa_fail(ppa_struct *dev, int error_code)\n#endif\n{\n\t \n\tif (dev->cur_cmd) {\n\t\tdev->cur_cmd->result = error_code << 16;\n\t\tdev->failed = 1;\n\t}\n}\n\n \nstatic unsigned char ppa_wait(ppa_struct *dev)\n{\n\tint k;\n\tunsigned short ppb = dev->base;\n\tunsigned char r;\n\n\tk = PPA_SPIN_TMO;\n\t \n\tfor (r = r_str(ppb); ((r & 0xc0) != 0xc0) && (k); k--) {\n\t\tudelay(1);\n\t\tr = r_str(ppb);\n\t}\n\n\t \n\tif (k)\n\t\treturn (r & 0xf0);\n\n\t \n\tppa_fail(dev, DID_TIME_OUT);\n\tprintk(KERN_WARNING \"ppa timeout in ppa_wait\\n\");\n\treturn 0;\t\t \n}\n\n \nstatic inline void epp_reset(unsigned short ppb)\n{\n\tint i;\n\n\ti = r_str(ppb);\n\tw_str(ppb, i);\n\tw_str(ppb, i & 0xfe);\n}\n\n \nstatic inline void ecp_sync(ppa_struct *dev)\n{\n\tint i, ppb_hi = dev->dev->port->base_hi;\n\n\tif (ppb_hi == 0)\n\t\treturn;\n\n\tif ((r_ecr(ppb_hi) & 0xe0) == 0x60) {\t \n\t\tfor (i = 0; i < 100; i++) {\n\t\t\tif (r_ecr(ppb_hi) & 0x01)\n\t\t\t\treturn;\n\t\t\tudelay(5);\n\t\t}\n\t\tprintk(KERN_WARNING \"ppa: ECP sync failed as data still present in FIFO.\\n\");\n\t}\n}\n\nstatic int ppa_byte_out(unsigned short base, const char *buffer, int len)\n{\n\tint i;\n\n\tfor (i = len; i; i--) {\n\t\tw_dtr(base, *buffer++);\n\t\tw_ctr(base, 0xe);\n\t\tw_ctr(base, 0xc);\n\t}\n\treturn 1;\t\t \n}\n\nstatic int ppa_byte_in(unsigned short base, char *buffer, int len)\n{\n\tint i;\n\n\tfor (i = len; i; i--) {\n\t\t*buffer++ = r_dtr(base);\n\t\tw_ctr(base, 0x27);\n\t\tw_ctr(base, 0x25);\n\t}\n\treturn 1;\t\t \n}\n\nstatic int ppa_nibble_in(unsigned short base, char *buffer, int len)\n{\n\tfor (; len; len--) {\n\t\tunsigned char h;\n\n\t\tw_ctr(base, 0x4);\n\t\th = r_str(base) & 0xf0;\n\t\tw_ctr(base, 0x6);\n\t\t*buffer++ = h | ((r_str(base) & 0xf0) >> 4);\n\t}\n\treturn 1;\t\t \n}\n\nstatic int ppa_out(ppa_struct *dev, char *buffer, int len)\n{\n\tint r;\n\tunsigned short ppb = dev->base;\n\n\tr = ppa_wait(dev);\n\n\tif ((r & 0x50) != 0x40) {\n\t\tppa_fail(dev, DID_ERROR);\n\t\treturn 0;\n\t}\n\tswitch (dev->mode) {\n\tcase PPA_NIBBLE:\n\tcase PPA_PS2:\n\t\t \n\t\tr = ppa_byte_out(ppb, buffer, len);\n\t\tbreak;\n\n\tcase PPA_EPP_32:\n\tcase PPA_EPP_16:\n\tcase PPA_EPP_8:\n\t\tepp_reset(ppb);\n\t\tw_ctr(ppb, 0x4);\n\t\tif (dev->mode == PPA_EPP_32 && !(((long) buffer | len) & 0x03))\n\t\t\toutsl(ppb + 4, buffer, len >> 2);\n\t\telse if (dev->mode == PPA_EPP_16 && !(((long) buffer | len) & 0x01))\n\t\t\toutsw(ppb + 4, buffer, len >> 1);\n\t\telse\n\t\t\toutsb(ppb + 4, buffer, len);\n\t\tw_ctr(ppb, 0xc);\n\t\tr = !(r_str(ppb) & 0x01);\n\t\tw_ctr(ppb, 0xc);\n\t\tecp_sync(dev);\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"PPA: bug in ppa_out()\\n\");\n\t\tr = 0;\n\t}\n\treturn r;\n}\n\nstatic int ppa_in(ppa_struct *dev, char *buffer, int len)\n{\n\tint r;\n\tunsigned short ppb = dev->base;\n\n\tr = ppa_wait(dev);\n\n\tif ((r & 0x50) != 0x50) {\n\t\tppa_fail(dev, DID_ERROR);\n\t\treturn 0;\n\t}\n\tswitch (dev->mode) {\n\tcase PPA_NIBBLE:\n\t\t \n\t\tr = ppa_nibble_in(ppb, buffer, len);\n\t\tw_ctr(ppb, 0xc);\n\t\tbreak;\n\n\tcase PPA_PS2:\n\t\t \n\t\tw_ctr(ppb, 0x25);\n\t\tr = ppa_byte_in(ppb, buffer, len);\n\t\tw_ctr(ppb, 0x4);\n\t\tw_ctr(ppb, 0xc);\n\t\tbreak;\n\n\tcase PPA_EPP_32:\n\tcase PPA_EPP_16:\n\tcase PPA_EPP_8:\n\t\tepp_reset(ppb);\n\t\tw_ctr(ppb, 0x24);\n\t\tif (dev->mode == PPA_EPP_32 && !(((long) buffer | len) & 0x03))\n\t\t\tinsl(ppb + 4, buffer, len >> 2);\n\t\telse if (dev->mode == PPA_EPP_16 && !(((long) buffer | len) & 0x01))\n\t\t\tinsw(ppb + 4, buffer, len >> 1);\n\t\telse\n\t\t\tinsb(ppb + 4, buffer, len);\n\t\tw_ctr(ppb, 0x2c);\n\t\tr = !(r_str(ppb) & 0x01);\n\t\tw_ctr(ppb, 0x2c);\n\t\tecp_sync(dev);\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"PPA: bug in ppa_ins()\\n\");\n\t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n}\n\n \nstatic inline void ppa_d_pulse(unsigned short ppb, unsigned char b)\n{\n\tw_dtr(ppb, b);\n\tw_ctr(ppb, 0xc);\n\tw_ctr(ppb, 0xe);\n\tw_ctr(ppb, 0xc);\n\tw_ctr(ppb, 0x4);\n\tw_ctr(ppb, 0xc);\n}\n\nstatic void ppa_disconnect(ppa_struct *dev)\n{\n\tunsigned short ppb = dev->base;\n\n\tppa_d_pulse(ppb, 0);\n\tppa_d_pulse(ppb, 0x3c);\n\tppa_d_pulse(ppb, 0x20);\n\tppa_d_pulse(ppb, 0xf);\n}\n\nstatic inline void ppa_c_pulse(unsigned short ppb, unsigned char b)\n{\n\tw_dtr(ppb, b);\n\tw_ctr(ppb, 0x4);\n\tw_ctr(ppb, 0x6);\n\tw_ctr(ppb, 0x4);\n\tw_ctr(ppb, 0xc);\n}\n\nstatic inline void ppa_connect(ppa_struct *dev, int flag)\n{\n\tunsigned short ppb = dev->base;\n\n\tppa_c_pulse(ppb, 0);\n\tppa_c_pulse(ppb, 0x3c);\n\tppa_c_pulse(ppb, 0x20);\n\tif ((flag == CONNECT_EPP_MAYBE) && IN_EPP_MODE(dev->mode))\n\t\tppa_c_pulse(ppb, 0xcf);\n\telse\n\t\tppa_c_pulse(ppb, 0x8f);\n}\n\nstatic int ppa_select(ppa_struct *dev, int target)\n{\n\tint k;\n\tunsigned short ppb = dev->base;\n\n\t \n\tk = PPA_SELECT_TMO;\n\tdo {\n\t\tk--;\n\t\tudelay(1);\n\t} while ((r_str(ppb) & 0x40) && (k));\n\tif (!k)\n\t\treturn 0;\n\n\tw_dtr(ppb, (1 << target));\n\tw_ctr(ppb, 0xe);\n\tw_ctr(ppb, 0xc);\n\tw_dtr(ppb, 0x80);\t \n\tw_ctr(ppb, 0x8);\n\n\tk = PPA_SELECT_TMO;\n\tdo {\n\t\tk--;\n\t\tudelay(1);\n\t}\n\twhile (!(r_str(ppb) & 0x40) && (k));\n\tif (!k)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic int ppa_init(ppa_struct *dev)\n{\n\tint retv;\n\tunsigned short ppb = dev->base;\n\tbool autodetect = dev->mode == PPA_AUTODETECT;\n\n\tif (autodetect) {\n\t\tint modes = dev->dev->port->modes;\n\t\tint ppb_hi = dev->dev->port->base_hi;\n\n\t\t \n\t\tdev->mode = PPA_NIBBLE;\n\n\t\tif (modes & PARPORT_MODE_TRISTATE)\n\t\t\tdev->mode = PPA_PS2;\n\n\t\tif (modes & PARPORT_MODE_ECP) {\n\t\t\tw_ecr(ppb_hi, 0x20);\n\t\t\tdev->mode = PPA_PS2;\n\t\t}\n\t\tif ((modes & PARPORT_MODE_EPP) && (modes & PARPORT_MODE_ECP))\n\t\t\tw_ecr(ppb_hi, 0x80);\n\t}\n\n\tppa_disconnect(dev);\n\tppa_connect(dev, CONNECT_NORMAL);\n\n\tretv = 2;\t\t \n\n\tw_ctr(ppb, 0xe);\n\tif ((r_str(ppb) & 0x08) == 0x08)\n\t\tretv--;\n\n\tw_ctr(ppb, 0xc);\n\tif ((r_str(ppb) & 0x08) == 0x00)\n\t\tretv--;\n\n\tif (!retv)\n\t\tppa_reset_pulse(ppb);\n\tudelay(1000);\t\t \n\tppa_disconnect(dev);\n\tudelay(1000);\t\t \n\n\tif (retv)\n\t\treturn -EIO;\n\n\treturn device_check(dev, autodetect);\n}\n\nstatic inline int ppa_send_command(struct scsi_cmnd *cmd)\n{\n\tppa_struct *dev = ppa_dev(cmd->device->host);\n\tint k;\n\n\tw_ctr(dev->base, 0x0c);\n\n\tfor (k = 0; k < cmd->cmd_len; k++)\n\t\tif (!ppa_out(dev, &cmd->cmnd[k], 1))\n\t\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int ppa_completion(struct scsi_cmnd *const cmd)\n{\n\t \n\tstruct scsi_pointer *scsi_pointer = ppa_scsi_pointer(cmd);\n\tppa_struct *dev = ppa_dev(cmd->device->host);\n\tunsigned short ppb = dev->base;\n\tunsigned long start_jiffies = jiffies;\n\n\tunsigned char r, v;\n\tint fast, bulk, status;\n\n\tv = cmd->cmnd[0];\n\tbulk = ((v == READ_6) ||\n\t\t(v == READ_10) || (v == WRITE_6) || (v == WRITE_10));\n\n\t \n\tr = (r_str(ppb) & 0xf0);\n\n\twhile (r != (unsigned char) 0xf0) {\n\t\t \n\t\tif (time_after(jiffies, start_jiffies + 1))\n\t\t\treturn 0;\n\n\t\tif (scsi_pointer->this_residual <= 0) {\n\t\t\tppa_fail(dev, DID_ERROR);\n\t\t\treturn -1;\t \n\t\t}\n\n\t\t \n\t\tif ((r & 0xc0) != 0xc0) {\n\t\t\t \n\t\t\tunsigned long k = dev->recon_tmo;\n\t\t\tfor (; k && ((r = (r_str(ppb) & 0xf0)) & 0xc0) != 0xc0;\n\t\t\t     k--)\n\t\t\t\tudelay(1);\n\n\t\t\tif (!k)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tfast = bulk && scsi_pointer->this_residual >= PPA_BURST_SIZE ?\n\t\t\tPPA_BURST_SIZE : 1;\n\n\t\tif (r == (unsigned char) 0xc0)\n\t\t\tstatus = ppa_out(dev, scsi_pointer->ptr, fast);\n\t\telse\n\t\t\tstatus = ppa_in(dev, scsi_pointer->ptr, fast);\n\n\t\tscsi_pointer->ptr += fast;\n\t\tscsi_pointer->this_residual -= fast;\n\n\t\tif (!status) {\n\t\t\tppa_fail(dev, DID_BUS_BUSY);\n\t\t\treturn -1;\t \n\t\t}\n\t\tif (scsi_pointer->buffer && !scsi_pointer->this_residual) {\n\t\t\t \n\t\t\tif (scsi_pointer->buffers_residual--) {\n\t\t\t\tscsi_pointer->buffer =\n\t\t\t\t\tsg_next(scsi_pointer->buffer);\n\t\t\t\tscsi_pointer->this_residual =\n\t\t\t\t    scsi_pointer->buffer->length;\n\t\t\t\tscsi_pointer->ptr =\n\t\t\t\t\tsg_virt(scsi_pointer->buffer);\n\t\t\t}\n\t\t}\n\t\t \n\t\tr = (r_str(ppb) & 0xf0);\n\t\t \n\t\tif (!(r & 0x80))\n\t\t\treturn 0;\n\t}\n\treturn 1;\t\t \n}\n\n \nstatic void ppa_interrupt(struct work_struct *work)\n{\n\tppa_struct *dev = container_of(work, ppa_struct, ppa_tq.work);\n\tstruct scsi_cmnd *cmd = dev->cur_cmd;\n\n\tif (!cmd) {\n\t\tprintk(KERN_ERR \"PPA: bug in ppa_interrupt\\n\");\n\t\treturn;\n\t}\n\tif (ppa_engine(dev, cmd)) {\n\t\tschedule_delayed_work(&dev->ppa_tq, 1);\n\t\treturn;\n\t}\n\t \n#if PPA_DEBUG > 0\n\tswitch ((cmd->result >> 16) & 0xff) {\n\tcase DID_OK:\n\t\tbreak;\n\tcase DID_NO_CONNECT:\n\t\tprintk(KERN_DEBUG \"ppa: no device at SCSI ID %i\\n\", scmd_id(cmd));\n\t\tbreak;\n\tcase DID_BUS_BUSY:\n\t\tprintk(KERN_DEBUG \"ppa: BUS BUSY - EPP timeout detected\\n\");\n\t\tbreak;\n\tcase DID_TIME_OUT:\n\t\tprintk(KERN_DEBUG \"ppa: unknown timeout\\n\");\n\t\tbreak;\n\tcase DID_ABORT:\n\t\tprintk(KERN_DEBUG \"ppa: told to abort\\n\");\n\t\tbreak;\n\tcase DID_PARITY:\n\t\tprintk(KERN_DEBUG \"ppa: parity error (???)\\n\");\n\t\tbreak;\n\tcase DID_ERROR:\n\t\tprintk(KERN_DEBUG \"ppa: internal driver error\\n\");\n\t\tbreak;\n\tcase DID_RESET:\n\t\tprintk(KERN_DEBUG \"ppa: told to reset device\\n\");\n\t\tbreak;\n\tcase DID_BAD_INTR:\n\t\tprintk(KERN_WARNING \"ppa: bad interrupt (???)\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ppa: bad return code (%02x)\\n\",\n\t\t       (cmd->result >> 16) & 0xff);\n\t}\n#endif\n\n\tif (ppa_scsi_pointer(cmd)->phase > 1)\n\t\tppa_disconnect(dev);\n\n\tppa_pb_dismiss(dev);\n\n\tdev->cur_cmd = NULL;\n\n\tscsi_done(cmd);\n}\n\nstatic int ppa_engine(ppa_struct *dev, struct scsi_cmnd *cmd)\n{\n\tstruct scsi_pointer *scsi_pointer = ppa_scsi_pointer(cmd);\n\tunsigned short ppb = dev->base;\n\tunsigned char l = 0, h = 0;\n\tint retv;\n\n\t \n\tif (dev->failed)\n\t\treturn 0;\n\n\tswitch (scsi_pointer->phase) {\n\tcase 0:\t\t \n\t\tif (time_after(jiffies, dev->jstart + HZ)) {\n\t\t\t \n\t\t\tppa_fail(dev, DID_BUS_BUSY);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\t \n\tcase 1:\t\t \n\t\t{\t\t \n\t\t\tint retv = 2;\t \n\n\t\t\tppa_connect(dev, CONNECT_EPP_MAYBE);\n\n\t\t\tw_ctr(ppb, 0xe);\n\t\t\tif ((r_str(ppb) & 0x08) == 0x08)\n\t\t\t\tretv--;\n\n\t\t\tw_ctr(ppb, 0xc);\n\t\t\tif ((r_str(ppb) & 0x08) == 0x00)\n\t\t\t\tretv--;\n\n\t\t\tif (retv) {\n\t\t\t\tif (time_after(jiffies, dev->jstart + (1 * HZ))) {\n\t\t\t\t\tprintk(KERN_ERR \"ppa: Parallel port cable is unplugged.\\n\");\n\t\t\t\t\tppa_fail(dev, DID_BUS_BUSY);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\tppa_disconnect(dev);\n\t\t\t\t\treturn 1;\t \n\t\t\t\t}\n\t\t\t}\n\t\t\tscsi_pointer->phase++;\n\t\t}\n\t\tfallthrough;\n\n\tcase 2:\t\t \n\t\tif (!ppa_select(dev, scmd_id(cmd))) {\n\t\t\tppa_fail(dev, DID_NO_CONNECT);\n\t\t\treturn 0;\n\t\t}\n\t\tscsi_pointer->phase++;\n\t\tfallthrough;\n\n\tcase 3:\t\t \n\t\tw_ctr(ppb, 0x0c);\n\t\tif (!(r_str(ppb) & 0x80))\n\t\t\treturn 1;\n\n\t\tif (!ppa_send_command(cmd))\n\t\t\treturn 0;\n\t\tscsi_pointer->phase++;\n\t\tfallthrough;\n\n\tcase 4:\t\t \n\t\tif (scsi_bufflen(cmd)) {\n\t\t\tscsi_pointer->buffer = scsi_sglist(cmd);\n\t\t\tscsi_pointer->this_residual =\n\t\t\t\tscsi_pointer->buffer->length;\n\t\t\tscsi_pointer->ptr = sg_virt(scsi_pointer->buffer);\n\t\t} else {\n\t\t\tscsi_pointer->buffer = NULL;\n\t\t\tscsi_pointer->this_residual = 0;\n\t\t\tscsi_pointer->ptr = NULL;\n\t\t}\n\t\tscsi_pointer->buffers_residual = scsi_sg_count(cmd) - 1;\n\t\tscsi_pointer->phase++;\n\t\tfallthrough;\n\n\tcase 5:\t\t \n\t\tw_ctr(ppb, 0x0c);\n\t\tif (!(r_str(ppb) & 0x80))\n\t\t\treturn 1;\n\n\t\tretv = ppa_completion(cmd);\n\t\tif (retv == -1)\n\t\t\treturn 0;\n\t\tif (retv == 0)\n\t\t\treturn 1;\n\t\tscsi_pointer->phase++;\n\t\tfallthrough;\n\n\tcase 6:\t\t \n\t\tcmd->result = DID_OK << 16;\n\t\t \n\t\tif (ppa_wait(dev) != (unsigned char) 0xf0) {\n\t\t\tppa_fail(dev, DID_ERROR);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ppa_in(dev, &l, 1)) {\t \n\t\t\t \n\t\t\tif (ppa_wait(dev) == (unsigned char) 0xf0)\n\t\t\t\tppa_in(dev, &h, 1);\n\t\t\tcmd->result =\n\t\t\t    (DID_OK << 16) + (h << 8) + (l & STATUS_MASK);\n\t\t}\n\t\treturn 0;\t \n\n\tdefault:\n\t\tprintk(KERN_ERR \"ppa: Invalid scsi phase\\n\");\n\t}\n\treturn 0;\n}\n\nstatic int ppa_queuecommand_lck(struct scsi_cmnd *cmd)\n{\n\tppa_struct *dev = ppa_dev(cmd->device->host);\n\n\tif (dev->cur_cmd) {\n\t\tprintk(KERN_ERR \"PPA: bug in ppa_queuecommand\\n\");\n\t\treturn 0;\n\t}\n\tdev->failed = 0;\n\tdev->jstart = jiffies;\n\tdev->cur_cmd = cmd;\n\tcmd->result = DID_ERROR << 16;\t \n\tppa_scsi_pointer(cmd)->phase = 0;\t \n\n\tschedule_delayed_work(&dev->ppa_tq, 0);\n\n\tppa_pb_claim(dev);\n\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(ppa_queuecommand)\n\n \nstatic int ppa_biosparam(struct scsi_device *sdev, struct block_device *dev,\n\t      sector_t capacity, int ip[])\n{\n\tip[0] = 0x40;\n\tip[1] = 0x20;\n\tip[2] = ((unsigned long) capacity + 1) / (ip[0] * ip[1]);\n\tif (ip[2] > 1024) {\n\t\tip[0] = 0xff;\n\t\tip[1] = 0x3f;\n\t\tip[2] = ((unsigned long) capacity + 1) / (ip[0] * ip[1]);\n\t\tif (ip[2] > 1023)\n\t\t\tip[2] = 1023;\n\t}\n\treturn 0;\n}\n\nstatic int ppa_abort(struct scsi_cmnd *cmd)\n{\n\tppa_struct *dev = ppa_dev(cmd->device->host);\n\t \n\n\tswitch (ppa_scsi_pointer(cmd)->phase) {\n\tcase 0:\t\t \n\tcase 1:\t\t \n\t\tdev->cur_cmd = NULL;\t \n\t\treturn SUCCESS;\n\tdefault:\t\t \n\t\treturn FAILED;\n\t}\n}\n\nstatic void ppa_reset_pulse(unsigned int base)\n{\n\tw_dtr(base, 0x40);\n\tw_ctr(base, 0x8);\n\tudelay(30);\n\tw_ctr(base, 0xc);\n}\n\nstatic int ppa_reset(struct scsi_cmnd *cmd)\n{\n\tppa_struct *dev = ppa_dev(cmd->device->host);\n\n\tif (ppa_scsi_pointer(cmd)->phase)\n\t\tppa_disconnect(dev);\n\tdev->cur_cmd = NULL;\t \n\n\tppa_connect(dev, CONNECT_NORMAL);\n\tppa_reset_pulse(dev->base);\n\tmdelay(1);\t\t \n\tppa_disconnect(dev);\n\tmdelay(1);\t\t \n\treturn SUCCESS;\n}\n\nstatic int device_check(ppa_struct *dev, bool autodetect)\n{\n\t \n\n\tstatic u8 cmd[6] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tint loop, old_mode, status, k, ppb = dev->base;\n\tunsigned char l;\n\n\told_mode = dev->mode;\n\tfor (loop = 0; loop < 8; loop++) {\n\t\t \n\t\tif (autodetect && (ppb & 0x0007) == 0x0000)\n\t\t\tdev->mode = PPA_EPP_8;\n\nsecond_pass:\n\t\tppa_connect(dev, CONNECT_EPP_MAYBE);\n\t\t \n\t\tif (!ppa_select(dev, loop)) {\n\t\t\tppa_disconnect(dev);\n\t\t\tcontinue;\n\t\t}\n\t\tprintk(KERN_INFO \"ppa: Found device at ID %i, Attempting to use %s\\n\",\n\t\t       loop, PPA_MODE_STRING[dev->mode]);\n\n\t\t \n\t\tstatus = 1;\n\t\tw_ctr(ppb, 0x0c);\n\t\tfor (l = 0; (l < 6) && (status); l++)\n\t\t\tstatus = ppa_out(dev, cmd, 1);\n\n\t\tif (!status) {\n\t\t\tppa_disconnect(dev);\n\t\t\tppa_connect(dev, CONNECT_EPP_MAYBE);\n\t\t\tw_dtr(ppb, 0x40);\n\t\t\tw_ctr(ppb, 0x08);\n\t\t\tudelay(30);\n\t\t\tw_ctr(ppb, 0x0c);\n\t\t\tudelay(1000);\n\t\t\tppa_disconnect(dev);\n\t\t\tudelay(1000);\n\t\t\tif (dev->mode != old_mode) {\n\t\t\t\tdev->mode = old_mode;\n\t\t\t\tgoto second_pass;\n\t\t\t}\n\t\t\treturn -EIO;\n\t\t}\n\t\tw_ctr(ppb, 0x0c);\n\t\tk = 1000000;\t \n\t\tdo {\n\t\t\tl = r_str(ppb);\n\t\t\tk--;\n\t\t\tudelay(1);\n\t\t} while (!(l & 0x80) && (k));\n\n\t\tl &= 0xf0;\n\n\t\tif (l != 0xf0) {\n\t\t\tppa_disconnect(dev);\n\t\t\tppa_connect(dev, CONNECT_EPP_MAYBE);\n\t\t\tppa_reset_pulse(ppb);\n\t\t\tudelay(1000);\n\t\t\tppa_disconnect(dev);\n\t\t\tudelay(1000);\n\t\t\tif (dev->mode != old_mode) {\n\t\t\t\tdev->mode = old_mode;\n\t\t\t\tgoto second_pass;\n\t\t\t}\n\t\t\treturn -EIO;\n\t\t}\n\t\tppa_disconnect(dev);\n\t\tprintk(KERN_INFO \"ppa: Communication established with ID %i using %s\\n\",\n\t\t       loop, PPA_MODE_STRING[dev->mode]);\n\t\tppa_connect(dev, CONNECT_EPP_MAYBE);\n\t\tppa_reset_pulse(ppb);\n\t\tudelay(1000);\n\t\tppa_disconnect(dev);\n\t\tudelay(1000);\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic int ppa_adjust_queue(struct scsi_device *device)\n{\n\tblk_queue_bounce_limit(device->request_queue, BLK_BOUNCE_HIGH);\n\treturn 0;\n}\n\nstatic const struct scsi_host_template ppa_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.proc_name\t\t= \"ppa\",\n\t.show_info\t\t= ppa_show_info,\n\t.write_info\t\t= ppa_write_info,\n\t.name\t\t\t= \"Iomega VPI0 (ppa) interface\",\n\t.queuecommand\t\t= ppa_queuecommand,\n\t.eh_abort_handler\t= ppa_abort,\n\t.eh_host_reset_handler\t= ppa_reset,\n\t.bios_param\t\t= ppa_biosparam,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.can_queue\t\t= 1,\n\t.slave_alloc\t\t= ppa_adjust_queue,\n\t.cmd_size\t\t= sizeof(struct scsi_pointer),\n};\n\n \n\nstatic LIST_HEAD(ppa_hosts);\n\n \n\nstatic inline ppa_struct *find_parent(void)\n{\n\tppa_struct *dev, *par = NULL;\n\tunsigned int cnt = 0;\n\n\tif (list_empty(&ppa_hosts))\n\t\treturn NULL;\n\n\tlist_for_each_entry(dev, &ppa_hosts, list) {\n\t\tif (dev->dev_no != cnt)\n\t\t\treturn par;\n\t\tcnt++;\n\t\tpar = dev;\n\t}\n\n\treturn par;\n}\n\nstatic int __ppa_attach(struct parport *pb)\n{\n\tstruct Scsi_Host *host;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(waiting);\n\tDEFINE_WAIT(wait);\n\tppa_struct *dev, *temp;\n\tint ports;\n\tint err = -ENOMEM;\n\tstruct pardev_cb ppa_cb;\n\n\tdev = kzalloc(sizeof(ppa_struct), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->base = -1;\n\tdev->mode = mode < PPA_UNKNOWN ? mode : PPA_AUTODETECT;\n\tdev->recon_tmo = PPA_RECON_TMO;\n\tinit_waitqueue_head(&waiting);\n\ttemp = find_parent();\n\tif (temp)\n\t\tdev->dev_no = temp->dev_no + 1;\n\n\tmemset(&ppa_cb, 0, sizeof(ppa_cb));\n\tppa_cb.private = dev;\n\tppa_cb.wakeup = ppa_wakeup;\n\n\tdev->dev = parport_register_dev_model(pb, \"ppa\", &ppa_cb, dev->dev_no);\n\n\tif (!dev->dev)\n\t\tgoto out;\n\n\t \n\terr = -EBUSY;\n\tdev->waiting = &waiting;\n\tprepare_to_wait(&waiting, &wait, TASK_UNINTERRUPTIBLE);\n\tif (ppa_pb_claim(dev))\n\t\tschedule_timeout(3 * HZ);\n\tif (dev->wanted) {\n\t\tprintk(KERN_ERR \"ppa%d: failed to claim parport because \"\n\t\t\t\t\"a pardevice is owning the port for too long \"\n\t\t\t\t\"time!\\n\", pb->number);\n\t\tppa_pb_dismiss(dev);\n\t\tdev->waiting = NULL;\n\t\tfinish_wait(&waiting, &wait);\n\t\tgoto out1;\n\t}\n\tdev->waiting = NULL;\n\tfinish_wait(&waiting, &wait);\n\tdev->base = dev->dev->port->base;\n\tw_ctr(dev->base, 0x0c);\n\n\t \n\n\terr = ppa_init(dev);\n\tppa_pb_release(dev);\n\n\tif (err)\n\t\tgoto out1;\n\n\t \n\tif (dev->mode == PPA_NIBBLE || dev->mode == PPA_PS2)\n\t\tports = 3;\n\telse\n\t\tports = 8;\n\n\tINIT_DELAYED_WORK(&dev->ppa_tq, ppa_interrupt);\n\n\terr = -ENOMEM;\n\thost = scsi_host_alloc(&ppa_template, sizeof(ppa_struct *));\n\tif (!host)\n\t\tgoto out1;\n\thost->io_port = pb->base;\n\thost->n_io_port = ports;\n\thost->dma_channel = -1;\n\thost->unique_id = pb->number;\n\t*(ppa_struct **)&host->hostdata = dev;\n\tdev->host = host;\n\tlist_add_tail(&dev->list, &ppa_hosts);\n\terr = scsi_add_host(host, NULL);\n\tif (err)\n\t\tgoto out2;\n\tscsi_scan_host(host);\n\treturn 0;\nout2:\n\tlist_del_init(&dev->list);\n\tscsi_host_put(host);\nout1:\n\tparport_unregister_device(dev->dev);\nout:\n\tkfree(dev);\n\treturn err;\n}\n\nstatic void ppa_attach(struct parport *pb)\n{\n\t__ppa_attach(pb);\n}\n\nstatic void ppa_detach(struct parport *pb)\n{\n\tppa_struct *dev;\n\tlist_for_each_entry(dev, &ppa_hosts, list) {\n\t\tif (dev->dev->port == pb) {\n\t\t\tlist_del_init(&dev->list);\n\t\t\tscsi_remove_host(dev->host);\n\t\t\tscsi_host_put(dev->host);\n\t\t\tparport_unregister_device(dev->dev);\n\t\t\tkfree(dev);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct parport_driver ppa_driver = {\n\t.name\t\t= \"ppa\",\n\t.match_port\t= ppa_attach,\n\t.detach\t\t= ppa_detach,\n\t.devmodel\t= true,\n};\nmodule_parport_driver(ppa_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}