{
  "module_name": "megaraid_mbox.c",
  "hash_id": "f6052beab990a4430626be0a8aac911eb61a5019ad14127c643ba8518617efcf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/megaraid/megaraid_mbox.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include \"megaraid_mbox.h\"\n\nstatic int megaraid_init(void);\nstatic void megaraid_exit(void);\n\nstatic int megaraid_probe_one(struct pci_dev*, const struct pci_device_id *);\nstatic void megaraid_detach_one(struct pci_dev *);\nstatic void megaraid_mbox_shutdown(struct pci_dev *);\n\nstatic int megaraid_io_attach(adapter_t *);\nstatic void megaraid_io_detach(adapter_t *);\n\nstatic int megaraid_init_mbox(adapter_t *);\nstatic void megaraid_fini_mbox(adapter_t *);\n\nstatic int megaraid_alloc_cmd_packets(adapter_t *);\nstatic void megaraid_free_cmd_packets(adapter_t *);\n\nstatic int megaraid_mbox_setup_dma_pools(adapter_t *);\nstatic void megaraid_mbox_teardown_dma_pools(adapter_t *);\n\nstatic int megaraid_sysfs_alloc_resources(adapter_t *);\nstatic void megaraid_sysfs_free_resources(adapter_t *);\n\nstatic int megaraid_abort_handler(struct scsi_cmnd *);\nstatic int megaraid_reset_handler(struct scsi_cmnd *);\n\nstatic int mbox_post_sync_cmd(adapter_t *, uint8_t []);\nstatic int mbox_post_sync_cmd_fast(adapter_t *, uint8_t []);\nstatic int megaraid_busywait_mbox(mraid_device_t *);\nstatic int megaraid_mbox_product_info(adapter_t *);\nstatic int megaraid_mbox_extended_cdb(adapter_t *);\nstatic int megaraid_mbox_support_ha(adapter_t *, uint16_t *);\nstatic int megaraid_mbox_support_random_del(adapter_t *);\nstatic int megaraid_mbox_get_max_sg(adapter_t *);\nstatic void megaraid_mbox_enum_raid_scsi(adapter_t *);\nstatic void megaraid_mbox_flush_cache(adapter_t *);\nstatic int megaraid_mbox_fire_sync_cmd(adapter_t *);\n\nstatic void megaraid_mbox_display_scb(adapter_t *, scb_t *);\nstatic void megaraid_mbox_setup_device_map(adapter_t *);\n\nstatic int megaraid_queue_command(struct Scsi_Host *, struct scsi_cmnd *);\nstatic scb_t *megaraid_mbox_build_cmd(adapter_t *, struct scsi_cmnd *, int *);\nstatic void megaraid_mbox_runpendq(adapter_t *, scb_t *);\nstatic void megaraid_mbox_prepare_pthru(adapter_t *, scb_t *,\n\t\tstruct scsi_cmnd *);\nstatic void megaraid_mbox_prepare_epthru(adapter_t *, scb_t *,\n\t\tstruct scsi_cmnd *);\n\nstatic irqreturn_t megaraid_isr(int, void *);\n\nstatic void megaraid_mbox_dpc(unsigned long);\n\nstatic ssize_t megaraid_mbox_app_hndl_show(struct device *, struct device_attribute *attr, char *);\nstatic ssize_t megaraid_mbox_ld_show(struct device *, struct device_attribute *attr, char *);\n\nstatic int megaraid_cmm_register(adapter_t *);\nstatic int megaraid_cmm_unregister(adapter_t *);\nstatic int megaraid_mbox_mm_handler(unsigned long, uioc_t *, uint32_t);\nstatic int megaraid_mbox_mm_command(adapter_t *, uioc_t *);\nstatic void megaraid_mbox_mm_done(adapter_t *, scb_t *);\nstatic int gather_hbainfo(adapter_t *, mraid_hba_info_t *);\nstatic int wait_till_fw_empty(adapter_t *);\n\n\n\nMODULE_AUTHOR(\"megaraidlinux@lsi.com\");\nMODULE_DESCRIPTION(\"LSI Logic MegaRAID Mailbox Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(MEGARAID_VERSION);\n\n \n\n \nstatic int megaraid_expose_unconf_disks = 0;\nmodule_param_named(unconf_disks, megaraid_expose_unconf_disks, int, 0);\nMODULE_PARM_DESC(unconf_disks,\n\t\"Set to expose unconfigured disks to kernel (default=0)\");\n\n \nstatic unsigned int max_mbox_busy_wait = MBOX_BUSY_WAIT;\nmodule_param_named(busy_wait, max_mbox_busy_wait, int, 0);\nMODULE_PARM_DESC(busy_wait,\n\t\"Max wait for mailbox in microseconds if busy (default=10)\");\n\n \nstatic unsigned int megaraid_max_sectors = MBOX_MAX_SECTORS;\nmodule_param_named(max_sectors, megaraid_max_sectors, int, 0);\nMODULE_PARM_DESC(max_sectors,\n\t\"Maximum number of sectors per IO command (default=128)\");\n\n \nstatic unsigned int megaraid_cmd_per_lun = MBOX_DEF_CMD_PER_LUN;\nmodule_param_named(cmd_per_lun, megaraid_cmd_per_lun, int, 0);\nMODULE_PARM_DESC(cmd_per_lun,\n\t\"Maximum number of commands per logical unit (default=64)\");\n\n\n \nstatic unsigned int megaraid_fast_load;\nmodule_param_named(fast_load, megaraid_fast_load, int, 0);\nMODULE_PARM_DESC(fast_load,\n\t\"Faster loading of the driver, skips physical devices! (default=0)\");\n\n\n \nint mraid_debug_level = CL_ANN;\nmodule_param_named(debug_level, mraid_debug_level, int, 0);\nMODULE_PARM_DESC(debug_level, \"Debug level for driver (default=0)\");\n\n \nstatic struct pci_device_id pci_id_table_g[] =  {\n\t{\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_DEVICE_ID_PERC4_DI_DISCOVERY,\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_SUBSYS_ID_PERC4_DI_DISCOVERY,\n\t},\n\t{\n\t\tPCI_VENDOR_ID_LSI_LOGIC,\n\t\tPCI_DEVICE_ID_PERC4_SC,\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_SUBSYS_ID_PERC4_SC,\n\t},\n\t{\n\t\tPCI_VENDOR_ID_LSI_LOGIC,\n\t\tPCI_DEVICE_ID_PERC4_DC,\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_SUBSYS_ID_PERC4_DC,\n\t},\n\t{\n\t\tPCI_VENDOR_ID_LSI_LOGIC,\n\t\tPCI_DEVICE_ID_VERDE,\n\t\tPCI_ANY_ID,\n\t\tPCI_ANY_ID,\n\t},\n\t{\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_DEVICE_ID_PERC4_DI_EVERGLADES,\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_SUBSYS_ID_PERC4_DI_EVERGLADES,\n\t},\n\t{\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_DEVICE_ID_PERC4E_SI_BIGBEND,\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_SUBSYS_ID_PERC4E_SI_BIGBEND,\n\t},\n\t{\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_DEVICE_ID_PERC4E_DI_KOBUK,\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_SUBSYS_ID_PERC4E_DI_KOBUK,\n\t},\n\t{\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_DEVICE_ID_PERC4E_DI_CORVETTE,\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_SUBSYS_ID_PERC4E_DI_CORVETTE,\n\t},\n\t{\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_DEVICE_ID_PERC4E_DI_EXPEDITION,\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_SUBSYS_ID_PERC4E_DI_EXPEDITION,\n\t},\n\t{\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_DEVICE_ID_PERC4E_DI_GUADALUPE,\n\t\tPCI_VENDOR_ID_DELL,\n\t\tPCI_SUBSYS_ID_PERC4E_DI_GUADALUPE,\n\t},\n\t{\n\t\tPCI_VENDOR_ID_LSI_LOGIC,\n\t\tPCI_DEVICE_ID_DOBSON,\n\t\tPCI_ANY_ID,\n\t\tPCI_ANY_ID,\n\t},\n\t{\n\t\tPCI_VENDOR_ID_AMI,\n\t\tPCI_DEVICE_ID_AMI_MEGARAID3,\n\t\tPCI_ANY_ID,\n\t\tPCI_ANY_ID,\n\t},\n\t{\n\t\tPCI_VENDOR_ID_LSI_LOGIC,\n\t\tPCI_DEVICE_ID_AMI_MEGARAID3,\n\t\tPCI_ANY_ID,\n\t\tPCI_ANY_ID,\n\t},\n\t{\n\t\tPCI_VENDOR_ID_LSI_LOGIC,\n\t\tPCI_DEVICE_ID_LINDSAY,\n\t\tPCI_ANY_ID,\n\t\tPCI_ANY_ID,\n\t},\n\t{0}\t \n};\nMODULE_DEVICE_TABLE(pci, pci_id_table_g);\n\n\nstatic struct pci_driver megaraid_pci_driver = {\n\t.name\t\t= \"megaraid\",\n\t.id_table\t= pci_id_table_g,\n\t.probe\t\t= megaraid_probe_one,\n\t.remove\t\t= megaraid_detach_one,\n\t.shutdown\t= megaraid_mbox_shutdown,\n};\n\n\n\n \n \n\nstatic DEVICE_ATTR_ADMIN_RO(megaraid_mbox_app_hndl);\n\n \nstatic struct attribute *megaraid_shost_attrs[] = {\n\t&dev_attr_megaraid_mbox_app_hndl.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(megaraid_shost);\n\nstatic DEVICE_ATTR_ADMIN_RO(megaraid_mbox_ld);\n\n \nstatic struct attribute *megaraid_sdev_attrs[] = {\n\t&dev_attr_megaraid_mbox_ld.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(megaraid_sdev);\n\n \nstatic const struct scsi_host_template megaraid_template_g = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.name\t\t\t\t= \"LSI Logic MegaRAID driver\",\n\t.proc_name\t\t\t= \"megaraid\",\n\t.queuecommand\t\t\t= megaraid_queue_command,\n\t.eh_abort_handler\t\t= megaraid_abort_handler,\n\t.eh_host_reset_handler\t\t= megaraid_reset_handler,\n\t.change_queue_depth\t\t= scsi_change_queue_depth,\n\t.no_write_same\t\t\t= 1,\n\t.sdev_groups\t\t\t= megaraid_sdev_groups,\n\t.shost_groups\t\t\t= megaraid_shost_groups,\n};\n\n\n \nstatic int __init\nmegaraid_init(void)\n{\n\tint\trval;\n\n\t \n\tcon_log(CL_ANN, (KERN_INFO \"megaraid: %s %s\\n\", MEGARAID_VERSION,\n\t\tMEGARAID_EXT_VERSION));\n\n\t \n\tif (megaraid_cmd_per_lun > MBOX_MAX_SCSI_CMDS) {\n\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid mailbox: max commands per lun reset to %d\\n\",\n\t\t\tMBOX_MAX_SCSI_CMDS));\n\n\t\tmegaraid_cmd_per_lun = MBOX_MAX_SCSI_CMDS;\n\t}\n\n\n\t \n\trval = pci_register_driver(&megaraid_pci_driver);\n\tif (rval < 0) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: could not register hotplug support.\\n\"));\n\t}\n\n\treturn rval;\n}\n\n\n \nstatic void __exit\nmegaraid_exit(void)\n{\n\tcon_log(CL_DLEVEL1, (KERN_NOTICE \"megaraid: unloading framework\\n\"));\n\n\t \n\tpci_unregister_driver(&megaraid_pci_driver);\n\n\treturn;\n}\n\n\n \nstatic int\nmegaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tadapter_t\t*adapter;\n\n\n\t\n\tcon_log(CL_ANN, (KERN_INFO\n\t\t\"megaraid: probe new device %#4.04x:%#4.04x:%#4.04x:%#4.04x: \",\n\t\tpdev->vendor, pdev->device, pdev->subsystem_vendor,\n\t\tpdev->subsystem_device));\n\n\tcon_log(CL_ANN, (\"bus %d:slot %d:func %d\\n\", pdev->bus->number,\n\t\tPCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn)));\n\n\tif (pci_enable_device(pdev)) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\"megaraid: pci_enable_device failed\\n\"));\n\n\t\treturn -ENODEV;\n\t}\n\n\t\n\tpci_set_master(pdev);\n\n\t\n\tadapter = kzalloc(sizeof(adapter_t), GFP_KERNEL);\n\n\tif (adapter == NULL) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\"megaraid: out of memory, %s %d.\\n\", __func__, __LINE__));\n\n\t\tgoto out_probe_one;\n\t}\n\n\n\t\n\tadapter->unique_id\t= pci_dev_id(pdev);\n\tadapter->irq\t\t= pdev->irq;\n\tadapter->pdev\t\t= pdev;\n\n\tatomic_set(&adapter->being_detached, 0);\n\n\t\n\t\n\tif (dma_set_mask(&adapter->pdev->dev, DMA_BIT_MASK(32))) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: dma_set_mask failed:%d\\n\", __LINE__));\n\n\t\tgoto out_free_adapter;\n\t}\n\n\n\t\n\tspin_lock_init(&adapter->lock);\n\n\t\n\t\n\tINIT_LIST_HEAD(&adapter->kscb_pool);\n\tspin_lock_init(SCSI_FREE_LIST_LOCK(adapter));\n\n\tINIT_LIST_HEAD(&adapter->pend_list);\n\tspin_lock_init(PENDING_LIST_LOCK(adapter));\n\n\tINIT_LIST_HEAD(&adapter->completed_list);\n\tspin_lock_init(COMPLETED_LIST_LOCK(adapter));\n\n\n\t\n\tif (megaraid_init_mbox(adapter) != 0) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: mailbox adapter did not initialize\\n\"));\n\n\t\tgoto out_free_adapter;\n\t}\n\n\t\n\tif (megaraid_cmm_register(adapter) != 0) {\n\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\"megaraid: could not register with management module\\n\"));\n\n\t\tgoto out_fini_mbox;\n\t}\n\n\t\n\tpci_set_drvdata(pdev, adapter);\n\n\t\n\tif (megaraid_io_attach(adapter) != 0) {\n\n\t\tcon_log(CL_ANN, (KERN_WARNING \"megaraid: io attach failed\\n\"));\n\n\t\tgoto out_cmm_unreg;\n\t}\n\n\treturn 0;\n\nout_cmm_unreg:\n\tmegaraid_cmm_unregister(adapter);\nout_fini_mbox:\n\tmegaraid_fini_mbox(adapter);\nout_free_adapter:\n\tkfree(adapter);\nout_probe_one:\n\tpci_disable_device(pdev);\n\n\treturn -ENODEV;\n}\n\n\n \nstatic void\nmegaraid_detach_one(struct pci_dev *pdev)\n{\n\tadapter_t\t\t*adapter;\n\tstruct Scsi_Host\t*host;\n\n\n\t\n\tadapter = pci_get_drvdata(pdev);\n\n\tif (!adapter) {\n\t\tcon_log(CL_ANN, (KERN_CRIT\n\t\t\"megaraid: Invalid detach on %#4.04x:%#4.04x:%#4.04x:%#4.04x\\n\",\n\t\t\tpdev->vendor, pdev->device, pdev->subsystem_vendor,\n\t\t\tpdev->subsystem_device));\n\n\t\treturn;\n\t}\n\telse {\n\t\tcon_log(CL_ANN, (KERN_NOTICE\n\t\t\"megaraid: detaching device %#4.04x:%#4.04x:%#4.04x:%#4.04x\\n\",\n\t\t\tpdev->vendor, pdev->device, pdev->subsystem_vendor,\n\t\t\tpdev->subsystem_device));\n\t}\n\n\n\thost = adapter->host;\n\n\t\n\t\n\t\n\t\n\tatomic_set(&adapter->being_detached, 1);\n\n\t\n\tmegaraid_io_detach(adapter);\n\n\t\n\t\n\t\n\t\n\tmegaraid_cmm_unregister(adapter);\n\n\t\n\tmegaraid_fini_mbox(adapter);\n\n\tkfree(adapter);\n\n\tscsi_host_put(host);\n\n\tpci_disable_device(pdev);\n\n\treturn;\n}\n\n\n \nstatic void\nmegaraid_mbox_shutdown(struct pci_dev *pdev)\n{\n\tadapter_t\t\t*adapter = pci_get_drvdata(pdev);\n\tstatic int\t\tcounter;\n\n\tif (!adapter) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: null device in shutdown\\n\"));\n\t\treturn;\n\t}\n\n\t\n\tcon_log(CL_ANN, (KERN_INFO \"megaraid: flushing adapter %d...\",\n\t\tcounter++));\n\n\tmegaraid_mbox_flush_cache(adapter);\n\n\tcon_log(CL_ANN, (\"done\\n\"));\n}\n\n\n \nstatic int\nmegaraid_io_attach(adapter_t *adapter)\n{\n\tstruct Scsi_Host\t*host;\n\n\t \n\thost = scsi_host_alloc(&megaraid_template_g, 8);\n\tif (!host) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid mbox: scsi_register failed\\n\"));\n\n\t\treturn -1;\n\t}\n\n\tSCSIHOST2ADAP(host)\t= (caddr_t)adapter;\n\tadapter->host\t\t= host;\n\n\thost->irq\t\t= adapter->irq;\n\thost->unique_id\t\t= adapter->unique_id;\n\thost->can_queue\t\t= adapter->max_cmds;\n\thost->this_id\t\t= adapter->init_id;\n\thost->sg_tablesize\t= adapter->sglen;\n\thost->max_sectors\t= adapter->max_sectors;\n\thost->cmd_per_lun\t= adapter->cmd_per_lun;\n\thost->max_channel\t= adapter->max_channel;\n\thost->max_id\t\t= adapter->max_target;\n\thost->max_lun\t\t= adapter->max_lun;\n\n\n\t \n\tif (scsi_add_host(host, &adapter->pdev->dev)) {\n\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid mbox: scsi_add_host failed\\n\"));\n\n\t\tscsi_host_put(host);\n\n\t\treturn -1;\n\t}\n\n\tscsi_scan_host(host);\n\n\treturn 0;\n}\n\n\n \nstatic void\nmegaraid_io_detach(adapter_t *adapter)\n{\n\tstruct Scsi_Host\t*host;\n\n\tcon_log(CL_DLEVEL1, (KERN_INFO \"megaraid: io detach\\n\"));\n\n\thost = adapter->host;\n\n\tscsi_remove_host(host);\n\n\treturn;\n}\n\n\n \n\n \nstatic int\nmegaraid_init_mbox(adapter_t *adapter)\n{\n\tstruct pci_dev\t\t*pdev;\n\tmraid_device_t\t\t*raid_dev;\n\tint\t\t\ti;\n\tuint32_t\t\tmagic64;\n\n\n\tadapter->ito\t= MBOX_TIMEOUT;\n\tpdev\t\t= adapter->pdev;\n\n\t \n\traid_dev = kzalloc(sizeof(mraid_device_t), GFP_KERNEL);\n\tif (raid_dev == NULL) return -1;\n\n\n\t \n\tadapter->raid_device\t= (caddr_t)raid_dev;\n\traid_dev->fast_load\t= megaraid_fast_load;\n\n\n\t \n\traid_dev->baseport = pci_resource_start(pdev, 0);\n\n\tif (pci_request_regions(pdev, \"MegaRAID: LSI Logic Corporation\") != 0) {\n\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\"megaraid: mem region busy\\n\"));\n\n\t\tgoto out_free_raid_dev;\n\t}\n\n\traid_dev->baseaddr = ioremap(raid_dev->baseport, 128);\n\n\tif (!raid_dev->baseaddr) {\n\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: could not map hba memory\\n\") );\n\n\t\tgoto out_release_regions;\n\t}\n\n\t \n\tspin_lock_init(&raid_dev->mailbox_lock);\n\n\t \n\tif (megaraid_alloc_cmd_packets(adapter) != 0)\n\t\tgoto out_iounmap;\n\n\t \n\n\tif (megaraid_mbox_fire_sync_cmd(adapter))\n\t\tcon_log(CL_ANN, (\"megaraid: sync cmd failed\\n\"));\n\n\t \n\n\t \n\tif (request_irq(adapter->irq, megaraid_isr, IRQF_SHARED, \"megaraid\",\n\t\tadapter)) {\n\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: Couldn't register IRQ %d!\\n\", adapter->irq));\n\t\tgoto out_alloc_cmds;\n\n\t}\n\n\t \n\tif (megaraid_mbox_product_info(adapter) != 0)\n\t\tgoto out_free_irq;\n\n\t \n\tadapter->max_cdb_sz = 10;\n\tif (megaraid_mbox_extended_cdb(adapter) == 0) {\n\t\tadapter->max_cdb_sz = 16;\n\t}\n\n\t \n\tadapter->ha\t\t= 0;\n\tadapter->init_id\t= -1;\n\tif (megaraid_mbox_support_ha(adapter, &adapter->init_id) == 0) {\n\t\tadapter->ha = 1;\n\t}\n\n\t \n\tmegaraid_mbox_setup_device_map(adapter);\n\n\t \n\tif (megaraid_mbox_support_random_del(adapter)) {\n\n\t\t \n\t\t \n\t\t \n\t\tfor (i = 0; i <= MAX_LOGICAL_DRIVES_40LD; i++) {\n\t\t\tadapter->device_ids[adapter->max_channel][i] += 0x80;\n\t\t}\n\t\tadapter->device_ids[adapter->max_channel][adapter->init_id] =\n\t\t\t0xFF;\n\n\t\traid_dev->random_del_supported = 1;\n\t}\n\n\t \n\tadapter->sglen = megaraid_mbox_get_max_sg(adapter);\n\n\t \n\t \n\tmegaraid_mbox_enum_raid_scsi(adapter);\n\n\t \n\tadapter->max_sectors = megaraid_max_sectors;\n\n\t \n\tadapter->cmd_per_lun = megaraid_cmd_per_lun;\n\n\t \n\tif (megaraid_sysfs_alloc_resources(adapter) != 0)\n\t\tgoto out_free_irq;\n\n\t \n\t \n\tpci_read_config_dword(adapter->pdev, PCI_CONF_AMISIG64, &magic64);\n\n\tif (((magic64 == HBA_SIGNATURE_64_BIT) &&\n\t\t((adapter->pdev->subsystem_device !=\n\t\tPCI_SUBSYS_ID_MEGARAID_SATA_150_6) &&\n\t\t(adapter->pdev->subsystem_device !=\n\t\tPCI_SUBSYS_ID_MEGARAID_SATA_150_4))) ||\n\t\t(adapter->pdev->vendor == PCI_VENDOR_ID_LSI_LOGIC &&\n\t\tadapter->pdev->device == PCI_DEVICE_ID_VERDE) ||\n\t\t(adapter->pdev->vendor == PCI_VENDOR_ID_LSI_LOGIC &&\n\t\tadapter->pdev->device == PCI_DEVICE_ID_DOBSON) ||\n\t\t(adapter->pdev->vendor == PCI_VENDOR_ID_LSI_LOGIC &&\n\t\tadapter->pdev->device == PCI_DEVICE_ID_LINDSAY) ||\n\t\t(adapter->pdev->vendor == PCI_VENDOR_ID_DELL &&\n\t\tadapter->pdev->device == PCI_DEVICE_ID_PERC4_DI_EVERGLADES) ||\n\t\t(adapter->pdev->vendor == PCI_VENDOR_ID_DELL &&\n\t\tadapter->pdev->device == PCI_DEVICE_ID_PERC4E_DI_KOBUK)) {\n\t\tif (dma_set_mask(&adapter->pdev->dev, DMA_BIT_MASK(64))) {\n\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\"megaraid: DMA mask for 64-bit failed\\n\"));\n\n\t\t\tif (dma_set_mask(&adapter->pdev->dev,\n\t\t\t\t\t\tDMA_BIT_MASK(32))) {\n\t\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\t\"megaraid: 32-bit DMA mask failed\\n\"));\n\t\t\t\tgoto out_free_sysfs_res;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\ttasklet_init(&adapter->dpc_h, megaraid_mbox_dpc,\n\t\t\t(unsigned long)adapter);\n\n\tcon_log(CL_DLEVEL1, (KERN_INFO\n\t\t\"megaraid mbox hba successfully initialized\\n\"));\n\n\treturn 0;\n\nout_free_sysfs_res:\n\tmegaraid_sysfs_free_resources(adapter);\nout_free_irq:\n\tfree_irq(adapter->irq, adapter);\nout_alloc_cmds:\n\tmegaraid_free_cmd_packets(adapter);\nout_iounmap:\n\tiounmap(raid_dev->baseaddr);\nout_release_regions:\n\tpci_release_regions(pdev);\nout_free_raid_dev:\n\tkfree(raid_dev);\n\n\treturn -1;\n}\n\n\n \nstatic void\nmegaraid_fini_mbox(adapter_t *adapter)\n{\n\tmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\n\n\t \n\tmegaraid_mbox_flush_cache(adapter);\n\n\ttasklet_kill(&adapter->dpc_h);\n\n\tmegaraid_sysfs_free_resources(adapter);\n\n\tmegaraid_free_cmd_packets(adapter);\n\n\tfree_irq(adapter->irq, adapter);\n\n\tiounmap(raid_dev->baseaddr);\n\n\tpci_release_regions(adapter->pdev);\n\n\tkfree(raid_dev);\n\n\treturn;\n}\n\n\n \nstatic int\nmegaraid_alloc_cmd_packets(adapter_t *adapter)\n{\n\tmraid_device_t\t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\tstruct pci_dev\t\t*pdev;\n\tunsigned long\t\talign;\n\tscb_t\t\t\t*scb;\n\tmbox_ccb_t\t\t*ccb;\n\tstruct mraid_pci_blk\t*epthru_pci_blk;\n\tstruct mraid_pci_blk\t*sg_pci_blk;\n\tstruct mraid_pci_blk\t*mbox_pci_blk;\n\tint\t\t\ti;\n\n\tpdev = adapter->pdev;\n\n\t \n\traid_dev->una_mbox64 = dma_alloc_coherent(&adapter->pdev->dev,\n\t\t\t\t\t\t  sizeof(mbox64_t),\n\t\t\t\t\t\t  &raid_dev->una_mbox64_dma,\n\t\t\t\t\t\t  GFP_KERNEL);\n\n\tif (!raid_dev->una_mbox64) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: out of memory, %s %d\\n\", __func__,\n\t\t\t__LINE__));\n\t\treturn -1;\n\t}\n\n\t \n\traid_dev->mbox\t= &raid_dev->una_mbox64->mbox32;\n\n\traid_dev->mbox\t= (mbox_t *)((((unsigned long)raid_dev->mbox) + 15) &\n\t\t\t\t(~0UL ^ 0xFUL));\n\n\traid_dev->mbox64 = (mbox64_t *)(((unsigned long)raid_dev->mbox) - 8);\n\n\talign = ((void *)raid_dev->mbox -\n\t\t\t((void *)&raid_dev->una_mbox64->mbox32));\n\n\traid_dev->mbox_dma = (unsigned long)raid_dev->una_mbox64_dma + 8 +\n\t\t\talign;\n\n\t \n\tadapter->ibuf = dma_alloc_coherent(&pdev->dev, MBOX_IBUF_SIZE,\n\t\t\t\t\t   &adapter->ibuf_dma_h, GFP_KERNEL);\n\tif (!adapter->ibuf) {\n\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: out of memory, %s %d\\n\", __func__,\n\t\t\t__LINE__));\n\n\t\tgoto out_free_common_mbox;\n\t}\n\n\t \n\t \n\n\t \n\tadapter->kscb_list = kcalloc(MBOX_MAX_SCSI_CMDS, sizeof(scb_t), GFP_KERNEL);\n\n\tif (adapter->kscb_list == NULL) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: out of memory, %s %d\\n\", __func__,\n\t\t\t__LINE__));\n\t\tgoto out_free_ibuf;\n\t}\n\n\t \n\tif (megaraid_mbox_setup_dma_pools(adapter) != 0) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: out of memory, %s %d\\n\", __func__,\n\t\t\t__LINE__));\n\t\tgoto out_free_scb_list;\n\t}\n\n\t \n\tepthru_pci_blk\t= raid_dev->epthru_pool;\n\tsg_pci_blk\t= raid_dev->sg_pool;\n\tmbox_pci_blk\t= raid_dev->mbox_pool;\n\n\tfor (i = 0; i < MBOX_MAX_SCSI_CMDS; i++) {\n\t\tscb\t\t\t= adapter->kscb_list + i;\n\t\tccb\t\t\t= raid_dev->ccb_list + i;\n\n\t\tccb->mbox\t= (mbox_t *)(mbox_pci_blk[i].vaddr + 16);\n\t\tccb->raw_mbox\t= (uint8_t *)ccb->mbox;\n\t\tccb->mbox64\t= (mbox64_t *)(mbox_pci_blk[i].vaddr + 8);\n\t\tccb->mbox_dma_h\t= (unsigned long)mbox_pci_blk[i].dma_addr + 16;\n\n\t\t \n\t\tif (ccb->mbox_dma_h & 0x0F) {\n\t\t\tcon_log(CL_ANN, (KERN_CRIT\n\t\t\t\t\"megaraid mbox: not aligned on 16-bytes\\n\"));\n\n\t\t\tgoto out_teardown_dma_pools;\n\t\t}\n\n\t\tccb->epthru\t\t= (mraid_epassthru_t *)\n\t\t\t\t\t\tepthru_pci_blk[i].vaddr;\n\t\tccb->epthru_dma_h\t= epthru_pci_blk[i].dma_addr;\n\t\tccb->pthru\t\t= (mraid_passthru_t *)ccb->epthru;\n\t\tccb->pthru_dma_h\t= ccb->epthru_dma_h;\n\n\n\t\tccb->sgl64\t\t= (mbox_sgl64 *)sg_pci_blk[i].vaddr;\n\t\tccb->sgl_dma_h\t\t= sg_pci_blk[i].dma_addr;\n\t\tccb->sgl32\t\t= (mbox_sgl32 *)ccb->sgl64;\n\n\t\tscb->ccb\t\t= (caddr_t)ccb;\n\t\tscb->gp\t\t\t= 0;\n\n\t\tscb->sno\t\t= i;\t \n\n\t\tscb->scp\t\t= NULL;\n\t\tscb->state\t\t= SCB_FREE;\n\t\tscb->dma_direction\t= DMA_NONE;\n\t\tscb->dma_type\t\t= MRAID_DMA_NONE;\n\t\tscb->dev_channel\t= -1;\n\t\tscb->dev_target\t\t= -1;\n\n\t\t \n\t\tlist_add_tail(&scb->list, &adapter->kscb_pool);\n\t}\n\n\treturn 0;\n\nout_teardown_dma_pools:\n\tmegaraid_mbox_teardown_dma_pools(adapter);\nout_free_scb_list:\n\tkfree(adapter->kscb_list);\nout_free_ibuf:\n\tdma_free_coherent(&pdev->dev, MBOX_IBUF_SIZE, (void *)adapter->ibuf,\n\t\tadapter->ibuf_dma_h);\nout_free_common_mbox:\n\tdma_free_coherent(&adapter->pdev->dev, sizeof(mbox64_t),\n\t\t(caddr_t)raid_dev->una_mbox64, raid_dev->una_mbox64_dma);\n\n\treturn -1;\n}\n\n\n \nstatic void\nmegaraid_free_cmd_packets(adapter_t *adapter)\n{\n\tmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\n\n\tmegaraid_mbox_teardown_dma_pools(adapter);\n\n\tkfree(adapter->kscb_list);\n\n\tdma_free_coherent(&adapter->pdev->dev, MBOX_IBUF_SIZE,\n\t\t(void *)adapter->ibuf, adapter->ibuf_dma_h);\n\n\tdma_free_coherent(&adapter->pdev->dev, sizeof(mbox64_t),\n\t\t(caddr_t)raid_dev->una_mbox64, raid_dev->una_mbox64_dma);\n\treturn;\n}\n\n\n \nstatic int\nmegaraid_mbox_setup_dma_pools(adapter_t *adapter)\n{\n\tmraid_device_t\t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\tstruct mraid_pci_blk\t*epthru_pci_blk;\n\tstruct mraid_pci_blk\t*sg_pci_blk;\n\tstruct mraid_pci_blk\t*mbox_pci_blk;\n\tint\t\t\ti;\n\n\n\n\t \n\traid_dev->mbox_pool_handle = dma_pool_create(\"megaraid mbox pool\",\n\t\t\t\t\t\t&adapter->pdev->dev,\n\t\t\t\t\t\tsizeof(mbox64_t) + 16,\n\t\t\t\t\t\t16, 0);\n\n\tif (raid_dev->mbox_pool_handle == NULL) {\n\t\tgoto fail_setup_dma_pool;\n\t}\n\n\tmbox_pci_blk = raid_dev->mbox_pool;\n\tfor (i = 0; i < MBOX_MAX_SCSI_CMDS; i++) {\n\t\tmbox_pci_blk[i].vaddr = dma_pool_alloc(\n\t\t\t\t\t\traid_dev->mbox_pool_handle,\n\t\t\t\t\t\tGFP_KERNEL,\n\t\t\t\t\t\t&mbox_pci_blk[i].dma_addr);\n\t\tif (!mbox_pci_blk[i].vaddr) {\n\t\t\tgoto fail_setup_dma_pool;\n\t\t}\n\t}\n\n\t \n\traid_dev->epthru_pool_handle = dma_pool_create(\"megaraid mbox pthru\",\n\t\t\t&adapter->pdev->dev, sizeof(mraid_epassthru_t), 128, 0);\n\n\tif (raid_dev->epthru_pool_handle == NULL) {\n\t\tgoto fail_setup_dma_pool;\n\t}\n\n\tepthru_pci_blk = raid_dev->epthru_pool;\n\tfor (i = 0; i < MBOX_MAX_SCSI_CMDS; i++) {\n\t\tepthru_pci_blk[i].vaddr = dma_pool_alloc(\n\t\t\t\t\t\traid_dev->epthru_pool_handle,\n\t\t\t\t\t\tGFP_KERNEL,\n\t\t\t\t\t\t&epthru_pci_blk[i].dma_addr);\n\t\tif (!epthru_pci_blk[i].vaddr) {\n\t\t\tgoto fail_setup_dma_pool;\n\t\t}\n\t}\n\n\n\t \n\t \n\traid_dev->sg_pool_handle = dma_pool_create(\"megaraid mbox sg\",\n\t\t\t\t\t&adapter->pdev->dev,\n\t\t\t\t\tsizeof(mbox_sgl64) * MBOX_MAX_SG_SIZE,\n\t\t\t\t\t512, 0);\n\n\tif (raid_dev->sg_pool_handle == NULL) {\n\t\tgoto fail_setup_dma_pool;\n\t}\n\n\tsg_pci_blk = raid_dev->sg_pool;\n\tfor (i = 0; i < MBOX_MAX_SCSI_CMDS; i++) {\n\t\tsg_pci_blk[i].vaddr = dma_pool_alloc(\n\t\t\t\t\t\traid_dev->sg_pool_handle,\n\t\t\t\t\t\tGFP_KERNEL,\n\t\t\t\t\t\t&sg_pci_blk[i].dma_addr);\n\t\tif (!sg_pci_blk[i].vaddr) {\n\t\t\tgoto fail_setup_dma_pool;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail_setup_dma_pool:\n\tmegaraid_mbox_teardown_dma_pools(adapter);\n\treturn -1;\n}\n\n\n \nstatic void\nmegaraid_mbox_teardown_dma_pools(adapter_t *adapter)\n{\n\tmraid_device_t\t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\tstruct mraid_pci_blk\t*epthru_pci_blk;\n\tstruct mraid_pci_blk\t*sg_pci_blk;\n\tstruct mraid_pci_blk\t*mbox_pci_blk;\n\tint\t\t\ti;\n\n\n\tsg_pci_blk = raid_dev->sg_pool;\n\tfor (i = 0; i < MBOX_MAX_SCSI_CMDS && sg_pci_blk[i].vaddr; i++) {\n\t\tdma_pool_free(raid_dev->sg_pool_handle, sg_pci_blk[i].vaddr,\n\t\t\tsg_pci_blk[i].dma_addr);\n\t}\n\tdma_pool_destroy(raid_dev->sg_pool_handle);\n\n\n\tepthru_pci_blk = raid_dev->epthru_pool;\n\tfor (i = 0; i < MBOX_MAX_SCSI_CMDS && epthru_pci_blk[i].vaddr; i++) {\n\t\tdma_pool_free(raid_dev->epthru_pool_handle,\n\t\t\tepthru_pci_blk[i].vaddr, epthru_pci_blk[i].dma_addr);\n\t}\n\tdma_pool_destroy(raid_dev->epthru_pool_handle);\n\n\n\tmbox_pci_blk = raid_dev->mbox_pool;\n\tfor (i = 0; i < MBOX_MAX_SCSI_CMDS && mbox_pci_blk[i].vaddr; i++) {\n\t\tdma_pool_free(raid_dev->mbox_pool_handle,\n\t\t\tmbox_pci_blk[i].vaddr, mbox_pci_blk[i].dma_addr);\n\t}\n\tdma_pool_destroy(raid_dev->mbox_pool_handle);\n\n\treturn;\n}\n\n\n \nstatic scb_t *\nmegaraid_alloc_scb(adapter_t *adapter, struct scsi_cmnd *scp)\n{\n\tstruct list_head\t*head = &adapter->kscb_pool;\n\tscb_t\t\t\t*scb = NULL;\n\tunsigned long\t\tflags;\n\n\t \n\tspin_lock_irqsave(SCSI_FREE_LIST_LOCK(adapter), flags);\n\n\tif (list_empty(head)) {\n\t\tspin_unlock_irqrestore(SCSI_FREE_LIST_LOCK(adapter), flags);\n\t\treturn NULL;\n\t}\n\n\tscb = list_entry(head->next, scb_t, list);\n\tlist_del_init(&scb->list);\n\n\tspin_unlock_irqrestore(SCSI_FREE_LIST_LOCK(adapter), flags);\n\n\tscb->state\t= SCB_ACTIVE;\n\tscb->scp\t= scp;\n\tscb->dma_type\t= MRAID_DMA_NONE;\n\n\treturn scb;\n}\n\n\n \nstatic inline void\nmegaraid_dealloc_scb(adapter_t *adapter, scb_t *scb)\n{\n\tunsigned long\t\tflags;\n\n\t \n\tscb->state\t= SCB_FREE;\n\tscb->scp\t= NULL;\n\tspin_lock_irqsave(SCSI_FREE_LIST_LOCK(adapter), flags);\n\n\tlist_add(&scb->list, &adapter->kscb_pool);\n\n\tspin_unlock_irqrestore(SCSI_FREE_LIST_LOCK(adapter), flags);\n\n\treturn;\n}\n\n\n \nstatic int\nmegaraid_mbox_mksgl(adapter_t *adapter, scb_t *scb)\n{\n\tstruct scatterlist\t*sgl;\n\tmbox_ccb_t\t\t*ccb;\n\tstruct scsi_cmnd\t*scp;\n\tint\t\t\tsgcnt;\n\tint\t\t\ti;\n\n\n\tscp\t= scb->scp;\n\tccb\t= (mbox_ccb_t *)scb->ccb;\n\n\tsgcnt = scsi_dma_map(scp);\n\tBUG_ON(sgcnt < 0 || sgcnt > adapter->sglen);\n\n\t \n\tif (!sgcnt)\n\t\treturn 0;\n\n\tscb->dma_type = MRAID_DMA_WSG;\n\n\tscsi_for_each_sg(scp, sgl, sgcnt, i) {\n\t\tccb->sgl64[i].address\t= sg_dma_address(sgl);\n\t\tccb->sgl64[i].length\t= sg_dma_len(sgl);\n\t}\n\n\t \n\treturn sgcnt;\n}\n\n\n \nstatic int\nmbox_post_cmd(adapter_t *adapter, scb_t *scb)\n{\n\tmraid_device_t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\tmbox64_t\t*mbox64;\n\tmbox_t\t\t*mbox;\n\tmbox_ccb_t\t*ccb;\n\tunsigned long\tflags;\n\tunsigned int\ti = 0;\n\n\n\tccb\t= (mbox_ccb_t *)scb->ccb;\n\tmbox\t= raid_dev->mbox;\n\tmbox64\t= raid_dev->mbox64;\n\n\t \n\tspin_lock_irqsave(MAILBOX_LOCK(raid_dev), flags);\n\n\tif (unlikely(mbox->busy)) {\n\t\tdo {\n\t\t\tudelay(1);\n\t\t\ti++;\n\t\t\trmb();\n\t\t} while(mbox->busy && (i < max_mbox_busy_wait));\n\n\t\tif (mbox->busy) {\n\n\t\t\tspin_unlock_irqrestore(MAILBOX_LOCK(raid_dev), flags);\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\n\t \n\tmemcpy((caddr_t)mbox64, (caddr_t)ccb->mbox64, 22);\n\tmbox->cmdid = scb->sno;\n\n\tadapter->outstanding_cmds++;\n\n\tmbox->busy\t= 1;\t \n\tmbox->poll\t= 0;\n\tmbox->ack\t= 0;\n\twmb();\n\n\tWRINDOOR(raid_dev, raid_dev->mbox_dma | 0x1);\n\n\tspin_unlock_irqrestore(MAILBOX_LOCK(raid_dev), flags);\n\n\treturn 0;\n}\n\n\n \nstatic int megaraid_queue_command_lck(struct scsi_cmnd *scp)\n{\n\tvoid (*done)(struct scsi_cmnd *) = scsi_done;\n\tadapter_t\t*adapter;\n\tscb_t\t\t*scb;\n\tint\t\tif_busy;\n\n\tadapter\t\t= SCP2ADAPTER(scp);\n\tscp->result\t= 0;\n\n\t \n\tif_busy\t= 0;\n\tscb = megaraid_mbox_build_cmd(adapter, scp, &if_busy);\n\tif (!scb) {\t \n\t\tdone(scp);\n\t\treturn 0;\n\t}\n\n\tmegaraid_mbox_runpendq(adapter, scb);\n\treturn if_busy;\n}\n\nstatic DEF_SCSI_QCMD(megaraid_queue_command)\n\n \nstatic scb_t *\nmegaraid_mbox_build_cmd(adapter_t *adapter, struct scsi_cmnd *scp, int *busy)\n{\n\tmraid_device_t\t\t*rdev = ADAP2RAIDDEV(adapter);\n\tint\t\t\tchannel;\n\tint\t\t\ttarget;\n\tint\t\t\tislogical;\n\tmbox_ccb_t\t\t*ccb;\n\tmraid_passthru_t\t*pthru;\n\tmbox64_t\t\t*mbox64;\n\tmbox_t\t\t\t*mbox;\n\tscb_t\t\t\t*scb;\n\tchar\t\t\tskip[] = \"skipping\";\n\tchar\t\t\tscan[] = \"scanning\";\n\tchar\t\t\t*ss;\n\n\n\t \n\tMRAID_GET_DEVICE_MAP(adapter, scp, channel, target, islogical);\n\n\t \n\tif (islogical) {\n\t\tswitch (scp->cmnd[0]) {\n\t\tcase TEST_UNIT_READY:\n\t\t\t \n\t\t\tif (!adapter->ha) {\n\t\t\t\tscp->result = (DID_OK << 16);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tif (!(scb = megaraid_alloc_scb(adapter, scp))) {\n\t\t\t\tscp->result = (DID_ERROR << 16);\n\t\t\t\t*busy = 1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tscb->dma_direction\t= scp->sc_data_direction;\n\t\t\tscb->dev_channel\t= 0xFF;\n\t\t\tscb->dev_target\t\t= target;\n\t\t\tccb\t\t\t= (mbox_ccb_t *)scb->ccb;\n\n\t\t\t \n\t\t\tccb->raw_mbox[0]\t= CLUSTER_CMD;\n\t\t\tccb->raw_mbox[2]\t= RESERVATION_STATUS;\n\t\t\tccb->raw_mbox[3]\t= target;\n\n\t\t\treturn scb;\n\n\t\tcase MODE_SENSE:\n\t\t{\n\t\t\tstruct scatterlist\t*sgl;\n\t\t\tcaddr_t\t\t\tvaddr;\n\n\t\t\tsgl = scsi_sglist(scp);\n\t\t\tif (sg_page(sgl)) {\n\t\t\t\tvaddr = (caddr_t) sg_virt(&sgl[0]);\n\n\t\t\t\tmemset(vaddr, 0, scp->cmnd[4]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\t\t \"megaraid mailbox: invalid sg:%d\\n\",\n\t\t\t\t\t\t __LINE__));\n\t\t\t}\n\t\t}\n\t\tscp->result = (DID_OK << 16);\n\t\treturn NULL;\n\n\t\tcase INQUIRY:\n\t\t\t \n\t\t\tif (!(rdev->last_disp & (1L << SCP2CHANNEL(scp)))) {\n\n\t\t\t\tcon_log(CL_ANN, (KERN_INFO\n\t\t\t\t\t\"scsi[%d]: scanning scsi channel %d\",\n\t\t\t\t\tadapter->host->host_no,\n\t\t\t\t\tSCP2CHANNEL(scp)));\n\n\t\t\t\tcon_log(CL_ANN, (\n\t\t\t\t\t\" [virtual] for logical drives\\n\"));\n\n\t\t\t\trdev->last_disp |= (1L << SCP2CHANNEL(scp));\n\t\t\t}\n\n\t\t\tif (scp->cmnd[1] & MEGA_SCSI_INQ_EVPD) {\n\t\t\t\tscsi_build_sense(scp, 0, ILLEGAL_REQUEST,\n\t\t\t\t\t\t MEGA_INVALID_FIELD_IN_CDB, 0);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tfallthrough;\n\n\t\tcase READ_CAPACITY:\n\t\t\t \n\t\t\tif (SCP2LUN(scp)) {\n\t\t\t\tscp->result = (DID_BAD_TARGET << 16);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif ((target % 0x80) >= MAX_LOGICAL_DRIVES_40LD) {\n\t\t\t\tscp->result = (DID_BAD_TARGET << 16);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\n\t\t\t \n\t\t\tif (!(scb = megaraid_alloc_scb(adapter, scp))) {\n\t\t\t\tscp->result = (DID_ERROR << 16);\n\t\t\t\t*busy = 1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tccb\t\t\t= (mbox_ccb_t *)scb->ccb;\n\t\t\tscb->dev_channel\t= 0xFF;\n\t\t\tscb->dev_target\t\t= target;\n\t\t\tpthru\t\t\t= ccb->pthru;\n\t\t\tmbox\t\t\t= ccb->mbox;\n\t\t\tmbox64\t\t\t= ccb->mbox64;\n\n\t\t\tpthru->timeout\t\t= 0;\n\t\t\tpthru->ars\t\t= 1;\n\t\t\tpthru->reqsenselen\t= 14;\n\t\t\tpthru->islogical\t= 1;\n\t\t\tpthru->logdrv\t\t= target;\n\t\t\tpthru->cdblen\t\t= scp->cmd_len;\n\t\t\tmemcpy(pthru->cdb, scp->cmnd, scp->cmd_len);\n\n\t\t\tmbox->cmd\t\t= MBOXCMD_PASSTHRU64;\n\t\t\tscb->dma_direction\t= scp->sc_data_direction;\n\n\t\t\tpthru->dataxferlen\t= scsi_bufflen(scp);\n\t\t\tpthru->dataxferaddr\t= ccb->sgl_dma_h;\n\t\t\tpthru->numsge\t\t= megaraid_mbox_mksgl(adapter,\n\t\t\t\t\t\t\tscb);\n\n\t\t\tmbox->xferaddr\t\t= 0xFFFFFFFF;\n\t\t\tmbox64->xferaddr_lo\t= (uint32_t )ccb->pthru_dma_h;\n\t\t\tmbox64->xferaddr_hi\t= 0;\n\n\t\t\treturn scb;\n\n\t\tcase READ_6:\n\t\tcase WRITE_6:\n\t\tcase READ_10:\n\t\tcase WRITE_10:\n\t\tcase READ_12:\n\t\tcase WRITE_12:\n\n\t\t\t \n\t\t\tif (!(scb = megaraid_alloc_scb(adapter, scp))) {\n\t\t\t\tscp->result = (DID_ERROR << 16);\n\t\t\t\t*busy = 1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tccb\t\t\t= (mbox_ccb_t *)scb->ccb;\n\t\t\tscb->dev_channel\t= 0xFF;\n\t\t\tscb->dev_target\t\t= target;\n\t\t\tmbox\t\t\t= ccb->mbox;\n\t\t\tmbox64\t\t\t= ccb->mbox64;\n\t\t\tmbox->logdrv\t\t= target;\n\n\t\t\t \n\t\t\tmbox->cmd = (scp->cmnd[0] & 0x02) ?  MBOXCMD_LWRITE64:\n\t\t\t\t\tMBOXCMD_LREAD64 ;\n\n\t\t\t \n\t\t\tif (scp->cmd_len == 6) {\n\t\t\t\tmbox->numsectors = (uint32_t)scp->cmnd[4];\n\t\t\t\tmbox->lba =\n\t\t\t\t\t((uint32_t)scp->cmnd[1] << 16)\t|\n\t\t\t\t\t((uint32_t)scp->cmnd[2] << 8)\t|\n\t\t\t\t\t(uint32_t)scp->cmnd[3];\n\n\t\t\t\tmbox->lba &= 0x1FFFFF;\n\t\t\t}\n\n\t\t\t \n\t\t\telse if (scp->cmd_len == 10) {\n\t\t\t\tmbox->numsectors =\n\t\t\t\t\t(uint32_t)scp->cmnd[8] |\n\t\t\t\t\t((uint32_t)scp->cmnd[7] << 8);\n\t\t\t\tmbox->lba =\n\t\t\t\t\t((uint32_t)scp->cmnd[2] << 24) |\n\t\t\t\t\t((uint32_t)scp->cmnd[3] << 16) |\n\t\t\t\t\t((uint32_t)scp->cmnd[4] << 8) |\n\t\t\t\t\t(uint32_t)scp->cmnd[5];\n\t\t\t}\n\n\t\t\t \n\t\t\telse if (scp->cmd_len == 12) {\n\t\t\t\tmbox->lba =\n\t\t\t\t\t((uint32_t)scp->cmnd[2] << 24) |\n\t\t\t\t\t((uint32_t)scp->cmnd[3] << 16) |\n\t\t\t\t\t((uint32_t)scp->cmnd[4] << 8) |\n\t\t\t\t\t(uint32_t)scp->cmnd[5];\n\n\t\t\t\tmbox->numsectors =\n\t\t\t\t\t((uint32_t)scp->cmnd[6] << 24) |\n\t\t\t\t\t((uint32_t)scp->cmnd[7] << 16) |\n\t\t\t\t\t((uint32_t)scp->cmnd[8] << 8) |\n\t\t\t\t\t(uint32_t)scp->cmnd[9];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\t\"megaraid: unsupported CDB length\\n\"));\n\n\t\t\t\tmegaraid_dealloc_scb(adapter, scb);\n\n\t\t\t\tscp->result = (DID_ERROR << 16);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tscb->dma_direction = scp->sc_data_direction;\n\n\t\t\t\n\t\t\tmbox64->xferaddr_lo\t= (uint32_t )ccb->sgl_dma_h;\n\t\t\tmbox->numsge\t\t= megaraid_mbox_mksgl(adapter,\n\t\t\t\t\t\t\tscb);\n\t\t\tmbox->xferaddr\t\t= 0xFFFFFFFF;\n\t\t\tmbox64->xferaddr_hi\t= 0;\n\n\t\t\treturn scb;\n\n\t\tcase RESERVE:\n\t\tcase RELEASE:\n\t\t\t \n\t\t\tif (!adapter->ha) {\n\t\t\t\tscp->result = (DID_BAD_TARGET << 16);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!(scb = megaraid_alloc_scb(adapter, scp))) {\n\t\t\t\tscp->result = (DID_ERROR << 16);\n\t\t\t\t*busy = 1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tccb\t\t\t= (mbox_ccb_t *)scb->ccb;\n\t\t\tscb->dev_channel\t= 0xFF;\n\t\t\tscb->dev_target\t\t= target;\n\t\t\tccb->raw_mbox[0]\t= CLUSTER_CMD;\n\t\t\tccb->raw_mbox[2]\t=  (scp->cmnd[0] == RESERVE) ?\n\t\t\t\t\t\tRESERVE_LD : RELEASE_LD;\n\n\t\t\tccb->raw_mbox[3]\t= target;\n\t\t\tscb->dma_direction\t= scp->sc_data_direction;\n\n\t\t\treturn scb;\n\n\t\tdefault:\n\t\t\tscp->result = (DID_BAD_TARGET << 16);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse { \n\n\t\t\n\t\tif (target > 15 || SCP2LUN(scp) > 7) {\n\t\t\tscp->result = (DID_BAD_TARGET << 16);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t\n\t\t\n\t\t\n\t\tif (rdev->fast_load && (target == 15) &&\n\t\t\t(SCP2CHANNEL(scp) == adapter->max_channel -1)) {\n\n\t\t\tcon_log(CL_ANN, (KERN_INFO\n\t\t\t\"megaraid[%d]: physical device scan re-enabled\\n\",\n\t\t\t\tadapter->host->host_no));\n\t\t\trdev->fast_load = 0;\n\t\t}\n\n\t\t \n\t\tif (!(rdev->last_disp & (1L << SCP2CHANNEL(scp)))) {\n\n\t\t\tss = rdev->fast_load ? skip : scan;\n\n\t\t\tcon_log(CL_ANN, (KERN_INFO\n\t\t\t\t\"scsi[%d]: %s scsi channel %d [Phy %d]\",\n\t\t\t\tadapter->host->host_no, ss, SCP2CHANNEL(scp),\n\t\t\t\tchannel));\n\n\t\t\tcon_log(CL_ANN, (\n\t\t\t\t\" for non-raid devices\\n\"));\n\n\t\t\trdev->last_disp |= (1L << SCP2CHANNEL(scp));\n\t\t}\n\n\t\t\n\t\tif (rdev->fast_load) {\n\t\t\tscp->result = (DID_BAD_TARGET << 16);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t\n\t\tif (!(scb = megaraid_alloc_scb(adapter, scp))) {\n\t\t\tscp->result = (DID_ERROR << 16);\n\t\t\t*busy = 1;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tccb\t\t\t= (mbox_ccb_t *)scb->ccb;\n\t\tscb->dev_channel\t= channel;\n\t\tscb->dev_target\t\t= target;\n\t\tscb->dma_direction\t= scp->sc_data_direction;\n\t\tmbox\t\t\t= ccb->mbox;\n\t\tmbox64\t\t\t= ccb->mbox64;\n\n\t\t\n\t\tif (adapter->max_cdb_sz == 16) {\n\t\t\tmbox->cmd\t\t= MBOXCMD_EXTPTHRU;\n\n\t\t\tmegaraid_mbox_prepare_epthru(adapter, scb, scp);\n\n\t\t\tmbox64->xferaddr_lo\t= (uint32_t)ccb->epthru_dma_h;\n\t\t\tmbox64->xferaddr_hi\t= 0;\n\t\t\tmbox->xferaddr\t\t= 0xFFFFFFFF;\n\t\t}\n\t\telse {\n\t\t\tmbox->cmd = MBOXCMD_PASSTHRU64;\n\n\t\t\tmegaraid_mbox_prepare_pthru(adapter, scb, scp);\n\n\t\t\tmbox64->xferaddr_lo\t= (uint32_t)ccb->pthru_dma_h;\n\t\t\tmbox64->xferaddr_hi\t= 0;\n\t\t\tmbox->xferaddr\t\t= 0xFFFFFFFF;\n\t\t}\n\t\treturn scb;\n\t}\n\n\t\n}\n\n\n \nstatic void\nmegaraid_mbox_runpendq(adapter_t *adapter, scb_t *scb_q)\n{\n\tscb_t\t\t\t*scb;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);\n\n\tif (scb_q) {\n\t\tscb_q->state = SCB_PENDQ;\n\t\tlist_add_tail(&scb_q->list, &adapter->pend_list);\n\t}\n\n\t \n\tif (adapter->quiescent) {\n\t\tspin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);\n\t\treturn;\n\t}\n\n\twhile (!list_empty(&adapter->pend_list)) {\n\n\t\tassert_spin_locked(PENDING_LIST_LOCK(adapter));\n\n\t\tscb = list_entry(adapter->pend_list.next, scb_t, list);\n\n\t\t \n\t\t \n\t\t \n\n\t\tlist_del_init(&scb->list);\n\n\t\tspin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);\n\n\t\t \n\t\t \n\t\t\n\n\t\tscb->state = SCB_ISSUED;\n\n\t\tif (mbox_post_cmd(adapter, scb) != 0) {\n\n\t\t\tspin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);\n\n\t\t\tscb->state = SCB_PENDQ;\n\n\t\t\tlist_add(&scb->list, &adapter->pend_list);\n\n\t\t\tspin_unlock_irqrestore(PENDING_LIST_LOCK(adapter),\n\t\t\t\tflags);\n\n\t\t\treturn;\n\t\t}\n\n\t\tspin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);\n\t}\n\n\tspin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);\n\n\n\treturn;\n}\n\n\n \nstatic void\nmegaraid_mbox_prepare_pthru(adapter_t *adapter, scb_t *scb,\n\t\tstruct scsi_cmnd *scp)\n{\n\tmbox_ccb_t\t\t*ccb;\n\tmraid_passthru_t\t*pthru;\n\tuint8_t\t\t\tchannel;\n\tuint8_t\t\t\ttarget;\n\n\tccb\t= (mbox_ccb_t *)scb->ccb;\n\tpthru\t= ccb->pthru;\n\tchannel\t= scb->dev_channel;\n\ttarget\t= scb->dev_target;\n\n\t \n\tpthru->timeout\t\t= 4;\t\n\tpthru->ars\t\t= 1;\n\tpthru->islogical\t= 0;\n\tpthru->channel\t\t= 0;\n\tpthru->target\t\t= (channel << 4) | target;\n\tpthru->logdrv\t\t= SCP2LUN(scp);\n\tpthru->reqsenselen\t= 14;\n\tpthru->cdblen\t\t= scp->cmd_len;\n\n\tmemcpy(pthru->cdb, scp->cmnd, scp->cmd_len);\n\n\tif (scsi_bufflen(scp)) {\n\t\tpthru->dataxferlen\t= scsi_bufflen(scp);\n\t\tpthru->dataxferaddr\t= ccb->sgl_dma_h;\n\t\tpthru->numsge\t\t= megaraid_mbox_mksgl(adapter, scb);\n\t}\n\telse {\n\t\tpthru->dataxferaddr\t= 0;\n\t\tpthru->dataxferlen\t= 0;\n\t\tpthru->numsge\t\t= 0;\n\t}\n\treturn;\n}\n\n\n \nstatic void\nmegaraid_mbox_prepare_epthru(adapter_t *adapter, scb_t *scb,\n\t\tstruct scsi_cmnd *scp)\n{\n\tmbox_ccb_t\t\t*ccb;\n\tmraid_epassthru_t\t*epthru;\n\tuint8_t\t\t\tchannel;\n\tuint8_t\t\t\ttarget;\n\n\tccb\t= (mbox_ccb_t *)scb->ccb;\n\tepthru\t= ccb->epthru;\n\tchannel\t= scb->dev_channel;\n\ttarget\t= scb->dev_target;\n\n\t\n\tepthru->timeout\t\t= 4;\t\n\tepthru->ars\t\t= 1;\n\tepthru->islogical\t= 0;\n\tepthru->channel\t\t= 0;\n\tepthru->target\t\t= (channel << 4) | target;\n\tepthru->logdrv\t\t= SCP2LUN(scp);\n\tepthru->reqsenselen\t= 14;\n\tepthru->cdblen\t\t= scp->cmd_len;\n\n\tmemcpy(epthru->cdb, scp->cmnd, scp->cmd_len);\n\n\tif (scsi_bufflen(scp)) {\n\t\tepthru->dataxferlen\t= scsi_bufflen(scp);\n\t\tepthru->dataxferaddr\t= ccb->sgl_dma_h;\n\t\tepthru->numsge\t\t= megaraid_mbox_mksgl(adapter, scb);\n\t}\n\telse {\n\t\tepthru->dataxferaddr\t= 0;\n\t\tepthru->dataxferlen\t= 0;\n\t\tepthru->numsge\t\t= 0;\n\t}\n\treturn;\n}\n\n\n \nstatic int\nmegaraid_ack_sequence(adapter_t *adapter)\n{\n\tmraid_device_t\t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\tmbox_t\t\t\t*mbox;\n\tscb_t\t\t\t*scb;\n\tuint8_t\t\t\tnstatus;\n\tuint8_t\t\t\tcompleted[MBOX_MAX_FIRMWARE_STATUS];\n\tstruct list_head\tclist;\n\tint\t\t\thandled;\n\tuint32_t\t\tdword;\n\tunsigned long\t\tflags;\n\tint\t\t\ti, j;\n\n\n\tmbox\t= raid_dev->mbox;\n\n\t \n\tINIT_LIST_HEAD(&clist);\n\n\t \n\thandled = 0;\n\tspin_lock_irqsave(MAILBOX_LOCK(raid_dev), flags);\n\tdo {\n\t\t \n\t\tdword = RDOUTDOOR(raid_dev);\n\t\tif (dword != 0x10001234) break;\n\n\t\thandled = 1;\n\n\t\tWROUTDOOR(raid_dev, 0x10001234);\n\n\t\tnstatus = 0;\n\t\t \n\t\tfor (i = 0; i < 0xFFFFF; i++) {\n\t\t\tif (mbox->numstatus != 0xFF) {\n\t\t\t\tnstatus = mbox->numstatus;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trmb();\n\t\t}\n\t\tmbox->numstatus = 0xFF;\n\n\t\tadapter->outstanding_cmds -= nstatus;\n\n\t\tfor (i = 0; i < nstatus; i++) {\n\n\t\t\t \n\t\t\tfor (j = 0; j < 0xFFFFF; j++) {\n\t\t\t\tif (mbox->completed[i] != 0xFF) break;\n\t\t\t\trmb();\n\t\t\t}\n\t\t\tcompleted[i]\t\t= mbox->completed[i];\n\t\t\tmbox->completed[i]\t= 0xFF;\n\n\t\t\tif (completed[i] == 0xFF) {\n\t\t\t\tcon_log(CL_ANN, (KERN_CRIT\n\t\t\t\t\"megaraid: command posting timed out\\n\"));\n\n\t\t\t\tBUG();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (completed[i] >= MBOX_MAX_SCSI_CMDS) {\n\t\t\t\t \n\t\t\t\tscb = adapter->uscb_list + (completed[i] -\n\t\t\t\t\t\tMBOX_MAX_SCSI_CMDS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tscb = adapter->kscb_list + completed[i];\n\t\t\t}\n\n\t\t\tscb->status = mbox->status;\n\t\t\tlist_add_tail(&scb->list, &clist);\n\t\t}\n\n\t\t \n\t\tWRINDOOR(raid_dev, 0x02);\n\n\t} while(1);\n\n\tspin_unlock_irqrestore(MAILBOX_LOCK(raid_dev), flags);\n\n\n\t \n\t \n\tspin_lock_irqsave(COMPLETED_LIST_LOCK(adapter), flags);\n\n\tlist_splice(&clist, &adapter->completed_list);\n\n\tspin_unlock_irqrestore(COMPLETED_LIST_LOCK(adapter), flags);\n\n\n\t \n\tif (handled)\n\t\ttasklet_schedule(&adapter->dpc_h);\n\n\treturn handled;\n}\n\n\n \nstatic irqreturn_t\nmegaraid_isr(int irq, void *devp)\n{\n\tadapter_t\t*adapter = devp;\n\tint\t\thandled;\n\n\thandled = megaraid_ack_sequence(adapter);\n\n\t \n\tif (!adapter->quiescent) {\n\t\tmegaraid_mbox_runpendq(adapter, NULL);\n\t}\n\n\treturn IRQ_RETVAL(handled);\n}\n\n\n \nstatic void\nmegaraid_mbox_dpc(unsigned long devp)\n{\n\tadapter_t\t\t*adapter = (adapter_t *)devp;\n\tmraid_device_t\t\t*raid_dev;\n\tstruct list_head\tclist;\n\tstruct scatterlist\t*sgl;\n\tscb_t\t\t\t*scb;\n\tscb_t\t\t\t*tmp;\n\tstruct scsi_cmnd\t*scp;\n\tmraid_passthru_t\t*pthru;\n\tmraid_epassthru_t\t*epthru;\n\tmbox_ccb_t\t\t*ccb;\n\tint\t\t\tislogical;\n\tint\t\t\tpdev_index;\n\tint\t\t\tpdev_state;\n\tmbox_t\t\t\t*mbox;\n\tunsigned long\t\tflags;\n\tuint8_t\t\t\tc;\n\tint\t\t\tstatus;\n\tuioc_t\t\t\t*kioc;\n\n\n\tif (!adapter) return;\n\n\traid_dev = ADAP2RAIDDEV(adapter);\n\n\t \n\tINIT_LIST_HEAD(&clist);\n\n\tspin_lock_irqsave(COMPLETED_LIST_LOCK(adapter), flags);\n\n\tlist_splice_init(&adapter->completed_list, &clist);\n\n\tspin_unlock_irqrestore(COMPLETED_LIST_LOCK(adapter), flags);\n\n\n\tlist_for_each_entry_safe(scb, tmp, &clist, list) {\n\n\t\tstatus\t\t= scb->status;\n\t\tscp\t\t= scb->scp;\n\t\tccb\t\t= (mbox_ccb_t *)scb->ccb;\n\t\tpthru\t\t= ccb->pthru;\n\t\tepthru\t\t= ccb->epthru;\n\t\tmbox\t\t= ccb->mbox;\n\n\t\t \n\t\tif (scb->state != SCB_ISSUED) {\n\t\t\tcon_log(CL_ANN, (KERN_CRIT\n\t\t\t\"megaraid critical err: invalid command %d:%d:%p\\n\",\n\t\t\t\tscb->sno, scb->state, scp));\n\t\t\tBUG();\n\t\t\tcontinue;\t \n\t\t}\n\n\t\t \n\t\tif (scb->sno >= MBOX_MAX_SCSI_CMDS) {\n\t\t\tscb->state\t= SCB_FREE;\n\t\t\tscb->status\t= status;\n\n\t\t\t \n\t\t\tlist_del_init(&scb->list);\n\n\t\t\tkioc\t\t\t= (uioc_t *)scb->gp;\n\t\t\tkioc->status\t\t= 0;\n\n\t\t\tmegaraid_mbox_mm_done(adapter, scb);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (scb->state & SCB_ABORT) {\n\t\t\tcon_log(CL_ANN, (KERN_NOTICE\n\t\t\t\"megaraid: aborted cmd [%x] completed\\n\",\n\t\t\t\tscb->sno));\n\t\t}\n\n\t\t \n\t\tislogical = MRAID_IS_LOGICAL(adapter, scp);\n\t\tif (scp->cmnd[0] == INQUIRY && status == 0 && islogical == 0\n\t\t\t\t&& IS_RAID_CH(raid_dev, scb->dev_channel)) {\n\n\t\t\tsgl = scsi_sglist(scp);\n\t\t\tif (sg_page(sgl)) {\n\t\t\t\tc = *(unsigned char *) sg_virt(&sgl[0]);\n\t\t\t} else {\n\t\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\t\t \"megaraid mailbox: invalid sg:%d\\n\",\n\t\t\t\t\t\t __LINE__));\n\t\t\t\tc = 0;\n\t\t\t}\n\n\t\t\tif ((c & 0x1F ) == TYPE_DISK) {\n\t\t\t\tpdev_index = (scb->dev_channel * 16) +\n\t\t\t\t\tscb->dev_target;\n\t\t\t\tpdev_state =\n\t\t\t\t\traid_dev->pdrv_state[pdev_index] & 0x0F;\n\n\t\t\t\tif (pdev_state == PDRV_ONLINE\t\t||\n\t\t\t\t\tpdev_state == PDRV_FAILED\t||\n\t\t\t\t\tpdev_state == PDRV_RBLD\t\t||\n\t\t\t\t\tpdev_state == PDRV_HOTSPARE\t||\n\t\t\t\t\tmegaraid_expose_unconf_disks == 0) {\n\n\t\t\t\t\tstatus = 0xF0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tswitch (status) {\n\n\t\tcase 0x00:\n\n\t\t\tscp->result = (DID_OK << 16);\n\t\t\tbreak;\n\n\t\tcase 0x02:\n\n\t\t\t \n\t\t\tif (mbox->cmd == MBOXCMD_PASSTHRU ||\n\t\t\t\tmbox->cmd == MBOXCMD_PASSTHRU64) {\n\n\t\t\t\tmemcpy(scp->sense_buffer, pthru->reqsensearea,\n\t\t\t\t\t\t14);\n\n\t\t\t\tscp->result = SAM_STAT_CHECK_CONDITION;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mbox->cmd == MBOXCMD_EXTPTHRU) {\n\n\t\t\t\t\tmemcpy(scp->sense_buffer,\n\t\t\t\t\t\tepthru->reqsensearea, 14);\n\n\t\t\t\t\tscp->result = SAM_STAT_CHECK_CONDITION;\n\t\t\t\t} else\n\t\t\t\t\tscsi_build_sense(scp, 0,\n\t\t\t\t\t\t\t ABORTED_COMMAND, 0, 0);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x08:\n\n\t\t\tscp->result = DID_BUS_BUSY << 16 | status;\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\t \n\t\t\tif (scp->cmnd[0] == TEST_UNIT_READY) {\n\t\t\t\tscp->result = DID_ERROR << 16 |\n\t\t\t\t\tSAM_STAT_RESERVATION_CONFLICT;\n\t\t\t}\n\t\t\telse\n\t\t\t \n\t\t\tif (status == 1 && (scp->cmnd[0] == RESERVE ||\n\t\t\t\t\t scp->cmnd[0] == RELEASE)) {\n\n\t\t\t\tscp->result = DID_ERROR << 16 |\n\t\t\t\t\tSAM_STAT_RESERVATION_CONFLICT;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscp->result = DID_BAD_TARGET << 16 | status;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (status) {\n\t\t\tmegaraid_mbox_display_scb(adapter, scb);\n\t\t}\n\n\t\tscsi_dma_unmap(scp);\n\n\t\t \n\t\tlist_del_init(&scb->list);\n\n\t\t \n\t\tmegaraid_dealloc_scb(adapter, scb);\n\n\t\t \n\t\tscsi_done(scp);\n\t}\n\n\treturn;\n}\n\n\n \nstatic int\nmegaraid_abort_handler(struct scsi_cmnd *scp)\n{\n\tadapter_t\t\t*adapter;\n\tmraid_device_t\t\t*raid_dev;\n\tscb_t\t\t\t*scb;\n\tscb_t\t\t\t*tmp;\n\tint\t\t\tfound;\n\tunsigned long\t\tflags;\n\tint\t\t\ti;\n\n\n\tadapter\t\t= SCP2ADAPTER(scp);\n\traid_dev\t= ADAP2RAIDDEV(adapter);\n\n\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\"megaraid: aborting cmd=%x <c=%d t=%d l=%d>\\n\",\n\t\tscp->cmnd[0], SCP2CHANNEL(scp),\n\t\tSCP2TARGET(scp), SCP2LUN(scp)));\n\n\t \n\tif (raid_dev->hw_error) {\n\t\tcon_log(CL_ANN, (KERN_NOTICE\n\t\t\t\"megaraid: hw error, not aborting\\n\"));\n\t\treturn FAILED;\n\t}\n\n\t \n\t \n\t \n\t \n\tscb = NULL;\n\tspin_lock_irqsave(COMPLETED_LIST_LOCK(adapter), flags);\n\tlist_for_each_entry_safe(scb, tmp, &adapter->completed_list, list) {\n\n\t\tif (scb->scp == scp) {\t \n\n\t\t\tlist_del_init(&scb->list);\t \n\n\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: %d[%d:%d], abort from completed list\\n\",\n\t\t\t\tscb->sno, scb->dev_channel, scb->dev_target));\n\n\t\t\tscp->result = (DID_ABORT << 16);\n\t\t\tscsi_done(scp);\n\n\t\t\tmegaraid_dealloc_scb(adapter, scb);\n\n\t\t\tspin_unlock_irqrestore(COMPLETED_LIST_LOCK(adapter),\n\t\t\t\tflags);\n\n\t\t\treturn SUCCESS;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(COMPLETED_LIST_LOCK(adapter), flags);\n\n\n\t \n\t \n\t \n\tspin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);\n\tlist_for_each_entry_safe(scb, tmp, &adapter->pend_list, list) {\n\n\t\tif (scb->scp == scp) {\t \n\n\t\t\tlist_del_init(&scb->list);\t \n\n\t\t\tASSERT(!(scb->state & SCB_ISSUED));\n\n\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\"megaraid abort: [%d:%d], driver owner\\n\",\n\t\t\t\tscb->dev_channel, scb->dev_target));\n\n\t\t\tscp->result = (DID_ABORT << 16);\n\t\t\tscsi_done(scp);\n\n\t\t\tmegaraid_dealloc_scb(adapter, scb);\n\n\t\t\tspin_unlock_irqrestore(PENDING_LIST_LOCK(adapter),\n\t\t\t\tflags);\n\n\t\t\treturn SUCCESS;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);\n\n\n\t \n\t \n\t \n\t \n\tfound = 0;\n\tspin_lock_irq(&adapter->lock);\n\tfor (i = 0; i < MBOX_MAX_SCSI_CMDS; i++) {\n\t\tscb = adapter->kscb_list + i;\n\n\t\tif (scb->scp == scp) {\n\n\t\t\tfound = 1;\n\n\t\t\tif (!(scb->state & SCB_ISSUED)) {\n\t\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\"megaraid abort: %d[%d:%d], invalid state\\n\",\n\t\t\t\tscb->sno, scb->dev_channel, scb->dev_target));\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\"megaraid abort: %d[%d:%d], fw owner\\n\",\n\t\t\t\tscb->sno, scb->dev_channel, scb->dev_target));\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irq(&adapter->lock);\n\n\tif (!found) {\n\t\tcon_log(CL_ANN, (KERN_WARNING \"megaraid abort: do now own\\n\"));\n\n\t\t \n\t\treturn SUCCESS;\n\t}\n\n\t \n\t \n\t \n\treturn FAILED;\n}\n\n \nstatic int\nmegaraid_reset_handler(struct scsi_cmnd *scp)\n{\n\tadapter_t\t*adapter;\n\tscb_t\t\t*scb;\n\tscb_t\t\t*tmp;\n\tmraid_device_t\t*raid_dev;\n\tunsigned long\tflags;\n\tuint8_t\t\traw_mbox[sizeof(mbox_t)];\n\tint\t\trval;\n\tint\t\trecovery_window;\n\tint\t\ti;\n\tuioc_t\t\t*kioc;\n\n\tadapter\t\t= SCP2ADAPTER(scp);\n\traid_dev\t= ADAP2RAIDDEV(adapter);\n\n\t \n\tif (raid_dev->hw_error) {\n\t\tcon_log(CL_ANN, (KERN_NOTICE\n\t\t\t\"megaraid: hw error, cannot reset\\n\"));\n\t\treturn FAILED;\n\t}\n\n\t \n\t \n\t \n\t\n\t\n\tspin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);\n\tlist_for_each_entry_safe(scb, tmp, &adapter->pend_list, list) {\n\t\tlist_del_init(&scb->list);\t\n\n\t\tif (scb->sno >= MBOX_MAX_SCSI_CMDS) {\n\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: IOCTL packet with %d[%d:%d] being reset\\n\",\n\t\t\tscb->sno, scb->dev_channel, scb->dev_target));\n\n\t\t\tscb->status = -1;\n\n\t\t\tkioc\t\t\t= (uioc_t *)scb->gp;\n\t\t\tkioc->status\t\t= -EFAULT;\n\n\t\t\tmegaraid_mbox_mm_done(adapter, scb);\n\t\t} else {\n\t\t\tif (scb->scp == scp) {\t\n\t\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\t\"megaraid: %d[%d:%d], reset from pending list\\n\",\n\t\t\t\t\tscb->sno, scb->dev_channel, scb->dev_target));\n\t\t\t} else {\n\t\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\"megaraid: IO packet with %d[%d:%d] being reset\\n\",\n\t\t\t\tscb->sno, scb->dev_channel, scb->dev_target));\n\t\t\t}\n\n\t\t\tscb->scp->result = (DID_RESET << 16);\n\t\t\tscsi_done(scb->scp);\n\n\t\t\tmegaraid_dealloc_scb(adapter, scb);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);\n\n\tif (adapter->outstanding_cmds) {\n\t\tcon_log(CL_ANN, (KERN_NOTICE\n\t\t\t\"megaraid: %d outstanding commands. Max wait %d sec\\n\",\n\t\t\tadapter->outstanding_cmds,\n\t\t\t(MBOX_RESET_WAIT + MBOX_RESET_EXT_WAIT)));\n\t}\n\n\trecovery_window = MBOX_RESET_WAIT + MBOX_RESET_EXT_WAIT;\n\n\tfor (i = 0; i < recovery_window; i++) {\n\n\t\tmegaraid_ack_sequence(adapter);\n\n\t\t\n\t\tif (!(i % 5)) {\n\t\t\tcon_log(CL_ANN, (\n\t\t\t\"megaraid mbox: Wait for %d commands to complete:%d\\n\",\n\t\t\t\tadapter->outstanding_cmds,\n\t\t\t\t(MBOX_RESET_WAIT + MBOX_RESET_EXT_WAIT) - i));\n\t\t}\n\n\t\t\n\t\tif (adapter->outstanding_cmds == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(1000);\n\t}\n\n\tspin_lock(&adapter->lock);\n\n\t\n\tif (adapter->outstanding_cmds) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid mbox: critical hardware error!\\n\"));\n\n\t\traid_dev->hw_error = 1;\n\n\t\trval = FAILED;\n\t\tgoto out;\n\t}\n\telse {\n\t\tcon_log(CL_ANN, (KERN_NOTICE\n\t\t\"megaraid mbox: reset sequence completed successfully\\n\"));\n\t}\n\n\n\t\n\tif (!adapter->ha) {\n\t\trval = SUCCESS;\n\t\tgoto out;\n\t}\n\n\t\n\traw_mbox[0] = CLUSTER_CMD;\n\traw_mbox[2] = RESET_RESERVATIONS;\n\n\trval = SUCCESS;\n\tif (mbox_post_sync_cmd_fast(adapter, raw_mbox) == 0) {\n\t\tcon_log(CL_ANN,\n\t\t\t(KERN_INFO \"megaraid: reservation reset\\n\"));\n\t}\n\telse {\n\t\trval = FAILED;\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\"megaraid: reservation reset failed\\n\"));\n\t}\n\n out:\n\tspin_unlock(&adapter->lock);\n\treturn rval;\n}\n\n \n\n \nstatic int\nmbox_post_sync_cmd(adapter_t *adapter, uint8_t raw_mbox[])\n{\n\tmraid_device_t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\tmbox_t\t\t*mbox;\n\tuint8_t\t\tstatus;\n\tint\t\ti;\n\n\tmbox\t= raid_dev->mbox;\n\n\t \n\tif (megaraid_busywait_mbox(raid_dev) != 0)\n\t\tgoto blocked_mailbox;\n\n\t \n\tmemcpy((caddr_t)mbox, (caddr_t)raw_mbox, 16);\n\tmbox->cmdid\t\t= 0xFE;\n\tmbox->busy\t\t= 1;\n\tmbox->poll\t\t= 0;\n\tmbox->ack\t\t= 0;\n\tmbox->numstatus\t\t= 0xFF;\n\tmbox->status\t\t= 0xFF;\n\n\twmb();\n\tWRINDOOR(raid_dev, raid_dev->mbox_dma | 0x1);\n\n\t \n\t \n\t \n\tif (mbox->numstatus == 0xFF) {\t \n\t\tudelay(25);\n\n\t\tfor (i = 0; mbox->numstatus == 0xFF && i < 1000; i++) {\n\t\t\trmb();\n\t\t\tmsleep(1);\n\t\t}\n\n\n\t\tif (i == 1000) {\n\t\t\tcon_log(CL_ANN, (KERN_NOTICE\n\t\t\t\t\"megaraid mailbox: wait for FW to boot      \"));\n\n\t\t\tfor (i = 0; (mbox->numstatus == 0xFF) &&\n\t\t\t\t\t(i < MBOX_RESET_WAIT); i++) {\n\t\t\t\trmb();\n\t\t\t\tcon_log(CL_ANN, (\"\\b\\b\\b\\b\\b[%03d]\",\n\t\t\t\t\t\t\tMBOX_RESET_WAIT - i));\n\t\t\t\tmsleep(1000);\n\t\t\t}\n\n\t\t\tif (i == MBOX_RESET_WAIT) {\n\n\t\t\t\tcon_log(CL_ANN, (\n\t\t\t\t\"\\nmegaraid mailbox: status not available\\n\"));\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcon_log(CL_ANN, (\"\\b\\b\\b\\b\\b[ok] \\n\"));\n\t\t}\n\t}\n\n\t \n\tif (mbox->poll != 0x77) {\n\t\tudelay(25);\n\n\t\tfor (i = 0; (mbox->poll != 0x77) && (i < 1000); i++) {\n\t\t\trmb();\n\t\t\tmsleep(1);\n\t\t}\n\n\t\tif (i == 1000) {\n\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid mailbox: could not get poll semaphore\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tWRINDOOR(raid_dev, raid_dev->mbox_dma | 0x2);\n\twmb();\n\n\t \n\tif (RDINDOOR(raid_dev) & 0x2) {\n\t\tudelay(25);\n\n\t\tfor (i = 0; (RDINDOOR(raid_dev) & 0x2) && (i < 1000); i++) {\n\t\t\trmb();\n\t\t\tmsleep(1);\n\t\t}\n\n\t\tif (i == 1000) {\n\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\"megaraid mailbox: could not acknowledge\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tmbox->poll\t= 0;\n\tmbox->ack\t= 0x77;\n\n\tstatus = mbox->status;\n\n\t \n\t \n\tmbox->numstatus\t= 0xFF;\n\tmbox->status\t= 0xFF;\n\tfor (i = 0; i < MBOX_MAX_FIRMWARE_STATUS; i++) {\n\t\tmbox->completed[i] = 0xFF;\n\t}\n\n\treturn status;\n\nblocked_mailbox:\n\n\tcon_log(CL_ANN, (KERN_WARNING \"megaraid: blocked mailbox\\n\") );\n\treturn -1;\n}\n\n\n \nstatic int\nmbox_post_sync_cmd_fast(adapter_t *adapter, uint8_t raw_mbox[])\n{\n\tmraid_device_t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\tmbox_t\t\t*mbox;\n\tlong\t\ti;\n\n\n\tmbox\t= raid_dev->mbox;\n\n\t\n\tif (mbox->busy) return -1;\n\n\t\n\tmemcpy((caddr_t)mbox, (caddr_t)raw_mbox, 14);\n\tmbox->cmdid\t\t= 0xFE;\n\tmbox->busy\t\t= 1;\n\tmbox->poll\t\t= 0;\n\tmbox->ack\t\t= 0;\n\tmbox->numstatus\t\t= 0xFF;\n\tmbox->status\t\t= 0xFF;\n\n\twmb();\n\tWRINDOOR(raid_dev, raid_dev->mbox_dma | 0x1);\n\n\tfor (i = 0; i < MBOX_SYNC_WAIT_CNT; i++) {\n\t\tif (mbox->numstatus != 0xFF) break;\n\t\trmb();\n\t\tudelay(MBOX_SYNC_DELAY_200);\n\t}\n\n\tif (i == MBOX_SYNC_WAIT_CNT) {\n\t\t\n\t\tcon_log(CL_ANN, (KERN_CRIT\n\t\t\t\"megaraid: fast sync command timed out\\n\"));\n\t}\n\n\tWRINDOOR(raid_dev, raid_dev->mbox_dma | 0x2);\n\twmb();\n\n\treturn mbox->status;\n}\n\n\n \nstatic int\nmegaraid_busywait_mbox(mraid_device_t *raid_dev)\n{\n\tmbox_t\t*mbox = raid_dev->mbox;\n\tint\ti = 0;\n\n\tif (mbox->busy) {\n\t\tudelay(25);\n\t\tfor (i = 0; mbox->busy && i < 1000; i++)\n\t\t\tmsleep(1);\n\t}\n\n\tif (i < 1000) return 0;\n\telse return -1;\n}\n\n\n \nstatic int\nmegaraid_mbox_product_info(adapter_t *adapter)\n{\n\tmraid_device_t\t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\tmbox_t\t\t\t*mbox;\n\tuint8_t\t\t\traw_mbox[sizeof(mbox_t)];\n\tmraid_pinfo_t\t\t*pinfo;\n\tdma_addr_t\t\tpinfo_dma_h;\n\tmraid_inquiry3_t\t*mraid_inq3;\n\tint\t\t\ti;\n\n\n\tmemset((caddr_t)raw_mbox, 0, sizeof(raw_mbox));\n\tmbox = (mbox_t *)raw_mbox;\n\n\t \n\tpinfo = dma_alloc_coherent(&adapter->pdev->dev, sizeof(mraid_pinfo_t),\n\t\t\t\t   &pinfo_dma_h, GFP_KERNEL);\n\tif (pinfo == NULL) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: out of memory, %s %d\\n\", __func__,\n\t\t\t__LINE__));\n\n\t\treturn -1;\n\t}\n\n\tmbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;\n\tmemset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);\n\n\traw_mbox[0] = FC_NEW_CONFIG;\n\traw_mbox[2] = NC_SUBOP_ENQUIRY3;\n\traw_mbox[3] = ENQ3_GET_SOLICITED_FULL;\n\n\t\n\tif (mbox_post_sync_cmd(adapter, raw_mbox) != 0) {\n\n\t\tcon_log(CL_ANN, (KERN_WARNING \"megaraid: Inquiry3 failed\\n\"));\n\n\t\tdma_free_coherent(&adapter->pdev->dev, sizeof(mraid_pinfo_t),\n\t\t\tpinfo, pinfo_dma_h);\n\n\t\treturn -1;\n\t}\n\n\t \n\tmraid_inq3 = (mraid_inquiry3_t *)adapter->ibuf;\n\tfor (i = 0; i < MBOX_MAX_PHYSICAL_DRIVES; i++) {\n\t\traid_dev->pdrv_state[i] = mraid_inq3->pdrv_state[i];\n\t}\n\n\t \n\tmemset((caddr_t)raw_mbox, 0, sizeof(raw_mbox));\n\tmbox->xferaddr = (uint32_t)pinfo_dma_h;\n\n\traw_mbox[0] = FC_NEW_CONFIG;\n\traw_mbox[2] = NC_SUBOP_PRODUCT_INFO;\n\n\tif (mbox_post_sync_cmd(adapter, raw_mbox) != 0) {\n\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: product info failed\\n\"));\n\n\t\tdma_free_coherent(&adapter->pdev->dev, sizeof(mraid_pinfo_t),\n\t\t\tpinfo, pinfo_dma_h);\n\n\t\treturn -1;\n\t}\n\n\t \n\tadapter->max_channel = pinfo->nchannels;\n\n\t \n\tadapter->max_target\t= MAX_LOGICAL_DRIVES_40LD + 1;\n\tadapter->max_lun\t= 8;\t\n\n\t \n\tadapter->max_cmds\t= MBOX_MAX_SCSI_CMDS;\n\n\tmemset(adapter->fw_version, 0, VERSION_SIZE);\n\tmemset(adapter->bios_version, 0, VERSION_SIZE);\n\n\tmemcpy(adapter->fw_version, pinfo->fw_version, 4);\n\tadapter->fw_version[4] = 0;\n\n\tmemcpy(adapter->bios_version, pinfo->bios_version, 4);\n\tadapter->bios_version[4] = 0;\n\n\tcon_log(CL_ANN, (KERN_NOTICE\n\t\t\"megaraid: fw version:[%s] bios version:[%s]\\n\",\n\t\tadapter->fw_version, adapter->bios_version));\n\n\tdma_free_coherent(&adapter->pdev->dev, sizeof(mraid_pinfo_t), pinfo,\n\t\t\tpinfo_dma_h);\n\n\treturn 0;\n}\n\n\n\n \nstatic int\nmegaraid_mbox_extended_cdb(adapter_t *adapter)\n{\n\tmbox_t\t\t*mbox;\n\tuint8_t\t\traw_mbox[sizeof(mbox_t)];\n\tint\t\trval;\n\n\tmbox = (mbox_t *)raw_mbox;\n\n\tmemset((caddr_t)raw_mbox, 0, sizeof(raw_mbox));\n\tmbox->xferaddr\t= (uint32_t)adapter->ibuf_dma_h;\n\n\tmemset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);\n\n\traw_mbox[0] = MAIN_MISC_OPCODE;\n\traw_mbox[2] = SUPPORT_EXT_CDB;\n\n\t \n\trval = 0;\n\tif (mbox_post_sync_cmd(adapter, raw_mbox) != 0) {\n\t\trval = -1;\n\t}\n\n\treturn rval;\n}\n\n\n \nstatic int\nmegaraid_mbox_support_ha(adapter_t *adapter, uint16_t *init_id)\n{\n\tmbox_t\t\t*mbox;\n\tuint8_t\t\traw_mbox[sizeof(mbox_t)];\n\tint\t\trval;\n\n\n\tmbox = (mbox_t *)raw_mbox;\n\n\tmemset((caddr_t)raw_mbox, 0, sizeof(raw_mbox));\n\n\tmbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;\n\n\tmemset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);\n\n\traw_mbox[0] = GET_TARGET_ID;\n\n\t\n\t*init_id = 7;\n\trval =  -1;\n\tif (mbox_post_sync_cmd(adapter, raw_mbox) == 0) {\n\n\t\t*init_id = *(uint8_t *)adapter->ibuf;\n\n\t\tcon_log(CL_ANN, (KERN_INFO\n\t\t\t\"megaraid: cluster firmware, initiator ID: %d\\n\",\n\t\t\t*init_id));\n\n\t\trval =  0;\n\t}\n\n\treturn rval;\n}\n\n\n \nstatic int\nmegaraid_mbox_support_random_del(adapter_t *adapter)\n{\n\tuint8_t\t\traw_mbox[sizeof(mbox_t)];\n\tint\t\trval;\n\n\t \n\tif (adapter->pdev->vendor == PCI_VENDOR_ID_AMI &&\n\t    adapter->pdev->device == PCI_DEVICE_ID_AMI_MEGARAID3 &&\n\t    adapter->pdev->subsystem_vendor == PCI_VENDOR_ID_DELL &&\n\t    adapter->pdev->subsystem_device == PCI_SUBSYS_ID_CERC_ATA100_4CH &&\n\t    (adapter->fw_version[0] > '6' ||\n\t     (adapter->fw_version[0] == '6' &&\n\t      adapter->fw_version[2] > '6') ||\n\t     (adapter->fw_version[0] == '6'\n\t      && adapter->fw_version[2] == '6'\n\t      && adapter->fw_version[3] > '1'))) {\n\t\tcon_log(CL_DLEVEL1, (\"megaraid: disable random deletion\\n\"));\n\t\treturn 0;\n\t}\n\n\tmemset((caddr_t)raw_mbox, 0, sizeof(mbox_t));\n\n\traw_mbox[0] = FC_DEL_LOGDRV;\n\traw_mbox[2] = OP_SUP_DEL_LOGDRV;\n\n\t\n\trval = 0;\n\tif (mbox_post_sync_cmd(adapter, raw_mbox) == 0) {\n\n\t\tcon_log(CL_DLEVEL1, (\"megaraid: supports random deletion\\n\"));\n\n\t\trval =  1;\n\t}\n\n\treturn rval;\n}\n\n\n \nstatic int\nmegaraid_mbox_get_max_sg(adapter_t *adapter)\n{\n\tmbox_t\t\t*mbox;\n\tuint8_t\t\traw_mbox[sizeof(mbox_t)];\n\tint\t\tnsg;\n\n\n\tmbox = (mbox_t *)raw_mbox;\n\n\tmemset((caddr_t)raw_mbox, 0, sizeof(mbox_t));\n\n\tmbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;\n\n\tmemset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);\n\n\traw_mbox[0] = MAIN_MISC_OPCODE;\n\traw_mbox[2] = GET_MAX_SG_SUPPORT;\n\n\t\n\tif (mbox_post_sync_cmd(adapter, raw_mbox) == 0) {\n\t\tnsg =  *(uint8_t *)adapter->ibuf;\n\t}\n\telse {\n\t\tnsg =  MBOX_DEFAULT_SG_SIZE;\n\t}\n\n\tif (nsg > MBOX_MAX_SG_SIZE) nsg = MBOX_MAX_SG_SIZE;\n\n\treturn nsg;\n}\n\n\n \nstatic void\nmegaraid_mbox_enum_raid_scsi(adapter_t *adapter)\n{\n\tmraid_device_t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\tmbox_t\t\t*mbox;\n\tuint8_t\t\traw_mbox[sizeof(mbox_t)];\n\n\n\tmbox = (mbox_t *)raw_mbox;\n\n\tmemset((caddr_t)raw_mbox, 0, sizeof(mbox_t));\n\n\tmbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;\n\n\tmemset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);\n\n\traw_mbox[0] = CHNL_CLASS;\n\traw_mbox[2] = GET_CHNL_CLASS;\n\n\t\n\t\n\traid_dev->channel_class = 0xFF;\n\tif (mbox_post_sync_cmd(adapter, raw_mbox) == 0) {\n\t\traid_dev->channel_class =  *(uint8_t *)adapter->ibuf;\n\t}\n\n\treturn;\n}\n\n\n \nstatic void\nmegaraid_mbox_flush_cache(adapter_t *adapter)\n{\n\tuint8_t\traw_mbox[sizeof(mbox_t)];\n\n\tmemset((caddr_t)raw_mbox, 0, sizeof(mbox_t));\n\n\traw_mbox[0] = FLUSH_ADAPTER;\n\n\tif (mbox_post_sync_cmd(adapter, raw_mbox) != 0) {\n\t\tcon_log(CL_ANN, (\"megaraid: flush adapter failed\\n\"));\n\t}\n\n\traw_mbox[0] = FLUSH_SYSTEM;\n\n\tif (mbox_post_sync_cmd(adapter, raw_mbox) != 0) {\n\t\tcon_log(CL_ANN, (\"megaraid: flush disks cache failed\\n\"));\n\t}\n\n\treturn;\n}\n\n\n \nstatic int\nmegaraid_mbox_fire_sync_cmd(adapter_t *adapter)\n{\n\tmbox_t\t*mbox;\n\tuint8_t\traw_mbox[sizeof(mbox_t)];\n\tmraid_device_t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\tint\tstatus = 0;\n\tint i;\n\tuint32_t dword;\n\n\tmemset((caddr_t)raw_mbox, 0, sizeof(mbox_t));\n\n\traw_mbox[0] = 0xFF;\n\n\tmbox\t= raid_dev->mbox;\n\n\t \n\tif (megaraid_busywait_mbox(raid_dev) != 0) {\n\t\tstatus = 1;\n\t\tgoto blocked_mailbox;\n\t}\n\n\t \n\tmemcpy((caddr_t)mbox, (caddr_t)raw_mbox, 16);\n\tmbox->cmdid\t\t= 0xFE;\n\tmbox->busy\t\t= 1;\n\tmbox->poll\t\t= 0;\n\tmbox->ack\t\t= 0;\n\tmbox->numstatus\t\t= 0;\n\tmbox->status\t\t= 0;\n\n\twmb();\n\tWRINDOOR(raid_dev, raid_dev->mbox_dma | 0x1);\n\n\t \n\n\ti = 0;\n\tstatus = 0;\n\twhile (!mbox->numstatus && mbox->cmd == 0xFF) {\n\t\trmb();\n\t\tmsleep(1);\n\t\ti++;\n\t\tif (i > 1000 * 60) {\n\t\t\tstatus = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mbox->numstatus == 1)\n\t\tstatus = 1;  \n\n\t \n\tdword = RDOUTDOOR(raid_dev);\n\tWROUTDOOR(raid_dev, dword);\n\tWRINDOOR(raid_dev,2);\n\n\treturn status;\n\nblocked_mailbox:\n\tcon_log(CL_ANN, (KERN_WARNING \"megaraid: blocked mailbox\\n\"));\n\treturn status;\n}\n\n \nstatic void\nmegaraid_mbox_display_scb(adapter_t *adapter, scb_t *scb)\n{\n\tmbox_ccb_t\t\t*ccb;\n\tstruct scsi_cmnd\t*scp;\n\tmbox_t\t\t\t*mbox;\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\n\tccb\t= (mbox_ccb_t *)scb->ccb;\n\tscp\t= scb->scp;\n\tmbox\t= ccb->mbox;\n\n\tlevel = CL_DLEVEL3;\n\n\tcon_log(level, (KERN_NOTICE\n\t\t\"megaraid mailbox: status:%#x cmd:%#x id:%#x \", scb->status,\n\t\tmbox->cmd, scb->sno));\n\n\tcon_log(level, (\"sec:%#x lba:%#x addr:%#x ld:%d sg:%d\\n\",\n\t\tmbox->numsectors, mbox->lba, mbox->xferaddr, mbox->logdrv,\n\t\tmbox->numsge));\n\n\tif (!scp) return;\n\n\tcon_log(level, (KERN_NOTICE \"scsi cmnd: \"));\n\n\tfor (i = 0; i < scp->cmd_len; i++) {\n\t\tcon_log(level, (\"%#2.02x \", scp->cmnd[i]));\n\t}\n\n\tcon_log(level, (\"\\n\"));\n\n\treturn;\n}\n\n\n \nstatic void\nmegaraid_mbox_setup_device_map(adapter_t *adapter)\n{\n\tuint8_t\t\tc;\n\tuint8_t\t\tt;\n\n\t \n\tfor (t = 0; t < LSI_MAX_LOGICAL_DRIVES_64LD; t++)\n\t\tadapter->device_ids[adapter->max_channel][t] =\n\t\t\t(t < adapter->init_id) ?  t : t - 1;\n\n\tadapter->device_ids[adapter->max_channel][adapter->init_id] = 0xFF;\n\n\t \n\tfor (c = 0; c < adapter->max_channel; c++)\n\t\tfor (t = 0; t < LSI_MAX_LOGICAL_DRIVES_64LD; t++)\n\t\t\tadapter->device_ids[c][t] = (c << 8) | t;\n}\n\n\n \n\n \n\n \nstatic int\nmegaraid_cmm_register(adapter_t *adapter)\n{\n\tmraid_device_t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\tmraid_mmadp_t\tadp;\n\tscb_t\t\t*scb;\n\tmbox_ccb_t\t*ccb;\n\tint\t\trval;\n\tint\t\ti;\n\n\t\n\tadapter->uscb_list = kcalloc(MBOX_MAX_USER_CMDS, sizeof(scb_t), GFP_KERNEL);\n\n\tif (adapter->uscb_list == NULL) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: out of memory, %s %d\\n\", __func__,\n\t\t\t__LINE__));\n\t\treturn -1;\n\t}\n\n\n\t\n\t\n\tINIT_LIST_HEAD(&adapter->uscb_pool);\n\n\tspin_lock_init(USER_FREE_LIST_LOCK(adapter));\n\n\n\n\t\n\t\n\t\n\t\n\tfor (i = 0; i < MBOX_MAX_USER_CMDS; i++) {\n\n\t\tscb\t\t\t= adapter->uscb_list + i;\n\t\tccb\t\t\t= raid_dev->uccb_list + i;\n\n\t\tscb->ccb\t\t= (caddr_t)ccb;\n\t\tccb->mbox64\t\t= raid_dev->umbox64 + i;\n\t\tccb->mbox\t\t= &ccb->mbox64->mbox32;\n\t\tccb->raw_mbox\t\t= (uint8_t *)ccb->mbox;\n\n\t\tscb->gp\t\t\t= 0;\n\n\t\t\n\t\t\n\t\tscb->sno\t\t= i + MBOX_MAX_SCSI_CMDS;\n\n\t\tscb->scp\t\t= NULL;\n\t\tscb->state\t\t= SCB_FREE;\n\t\tscb->dma_direction\t= DMA_NONE;\n\t\tscb->dma_type\t\t= MRAID_DMA_NONE;\n\t\tscb->dev_channel\t= -1;\n\t\tscb->dev_target\t\t= -1;\n\n\t\t\n\t\tlist_add_tail(&scb->list, &adapter->uscb_pool);\n\t}\n\n\tadp.unique_id\t\t= adapter->unique_id;\n\tadp.drvr_type\t\t= DRVRTYPE_MBOX;\n\tadp.drvr_data\t\t= (unsigned long)adapter;\n\tadp.pdev\t\t= adapter->pdev;\n\tadp.issue_uioc\t\t= megaraid_mbox_mm_handler;\n\tadp.timeout\t\t= MBOX_RESET_WAIT + MBOX_RESET_EXT_WAIT;\n\tadp.max_kioc\t\t= MBOX_MAX_USER_CMDS;\n\n\tif ((rval = mraid_mm_register_adp(&adp)) != 0) {\n\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid mbox: did not register with CMM\\n\"));\n\n\t\tkfree(adapter->uscb_list);\n\t}\n\n\treturn rval;\n}\n\n\n \nstatic int\nmegaraid_cmm_unregister(adapter_t *adapter)\n{\n\tkfree(adapter->uscb_list);\n\tmraid_mm_unregister_adp(adapter->unique_id);\n\treturn 0;\n}\n\n\n \nstatic int\nmegaraid_mbox_mm_handler(unsigned long drvr_data, uioc_t *kioc, uint32_t action)\n{\n\tadapter_t *adapter;\n\n\tif (action != IOCTL_ISSUE) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: unsupported management action:%#2x\\n\",\n\t\t\taction));\n\t\treturn (-ENOTSUPP);\n\t}\n\n\tadapter = (adapter_t *)drvr_data;\n\n\t\n\tif (atomic_read(&adapter->being_detached)) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: reject management request, detaching\\n\"));\n\t\treturn (-ENODEV);\n\t}\n\n\tswitch (kioc->opcode) {\n\n\tcase GET_ADAP_INFO:\n\n\t\tkioc->status =  gather_hbainfo(adapter, (mraid_hba_info_t *)\n\t\t\t\t\t(unsigned long)kioc->buf_vaddr);\n\n\t\tkioc->done(kioc);\n\n\t\treturn kioc->status;\n\n\tcase MBOX_CMD:\n\n\t\treturn megaraid_mbox_mm_command(adapter, kioc);\n\n\tdefault:\n\t\tkioc->status = (-EINVAL);\n\t\tkioc->done(kioc);\n\t\treturn (-EINVAL);\n\t}\n\n\treturn 0;\t\n}\n\n \nstatic int\nmegaraid_mbox_mm_command(adapter_t *adapter, uioc_t *kioc)\n{\n\tstruct list_head\t*head = &adapter->uscb_pool;\n\tmbox64_t\t\t*mbox64;\n\tuint8_t\t\t\t*raw_mbox;\n\tscb_t\t\t\t*scb;\n\tmbox_ccb_t\t\t*ccb;\n\tunsigned long\t\tflags;\n\n\t\n\tspin_lock_irqsave(USER_FREE_LIST_LOCK(adapter), flags);\n\n\tif (list_empty(head)) {\t\n\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid mbox: bug in cmm handler, lost resources\\n\"));\n\n\t\tspin_unlock_irqrestore(USER_FREE_LIST_LOCK(adapter), flags);\n\n\t\treturn (-EINVAL);\n\t}\n\n\tscb = list_entry(head->next, scb_t, list);\n\tlist_del_init(&scb->list);\n\n\tspin_unlock_irqrestore(USER_FREE_LIST_LOCK(adapter), flags);\n\n\tscb->state\t\t= SCB_ACTIVE;\n\tscb->dma_type\t\t= MRAID_DMA_NONE;\n\tscb->dma_direction\t= DMA_NONE;\n\n\tccb\t\t= (mbox_ccb_t *)scb->ccb;\n\tmbox64\t\t= (mbox64_t *)(unsigned long)kioc->cmdbuf;\n\traw_mbox\t= (uint8_t *)&mbox64->mbox32;\n\n\tmemcpy(ccb->mbox64, mbox64, sizeof(mbox64_t));\n\n\tscb->gp\t\t= (unsigned long)kioc;\n\n\t \n\tif (raw_mbox[0] == FC_DEL_LOGDRV && raw_mbox[2] == OP_DEL_LOGDRV) {\n\n\t\tif (wait_till_fw_empty(adapter)) {\n\t\t\tcon_log(CL_ANN, (KERN_NOTICE\n\t\t\t\t\"megaraid mbox: LD delete, timed out\\n\"));\n\n\t\t\tkioc->status = -ETIME;\n\n\t\t\tscb->status = -1;\n\n\t\t\tmegaraid_mbox_mm_done(adapter, scb);\n\n\t\t\treturn (-ETIME);\n\t\t}\n\n\t\tINIT_LIST_HEAD(&scb->list);\n\n\t\tscb->state = SCB_ISSUED;\n\t\tif (mbox_post_cmd(adapter, scb) != 0) {\n\n\t\t\tcon_log(CL_ANN, (KERN_NOTICE\n\t\t\t\t\"megaraid mbox: LD delete, mailbox busy\\n\"));\n\n\t\t\tkioc->status = -EBUSY;\n\n\t\t\tscb->status = -1;\n\n\t\t\tmegaraid_mbox_mm_done(adapter, scb);\n\n\t\t\treturn (-EBUSY);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t\n\tmegaraid_mbox_runpendq(adapter, scb);\n\n\treturn 0;\n}\n\n\nstatic int\nwait_till_fw_empty(adapter_t *adapter)\n{\n\tunsigned long\tflags = 0;\n\tint\t\ti;\n\n\n\t \n\tspin_lock_irqsave(&adapter->lock, flags);\n\tadapter->quiescent++;\n\tspin_unlock_irqrestore(&adapter->lock, flags);\n\n\t \n\tfor (i = 0; i < 60 && adapter->outstanding_cmds; i++) {\n\t\tcon_log(CL_DLEVEL1, (KERN_INFO\n\t\t\t\"megaraid: FW has %d pending commands\\n\",\n\t\t\tadapter->outstanding_cmds));\n\n\t\tmsleep(1000);\n\t}\n\n\treturn adapter->outstanding_cmds;\n}\n\n\n \nstatic void\nmegaraid_mbox_mm_done(adapter_t *adapter, scb_t *scb)\n{\n\tuioc_t\t\t\t*kioc;\n\tmbox64_t\t\t*mbox64;\n\tuint8_t\t\t\t*raw_mbox;\n\tunsigned long\t\tflags;\n\n\tkioc\t\t\t= (uioc_t *)scb->gp;\n\tmbox64\t\t\t= (mbox64_t *)(unsigned long)kioc->cmdbuf;\n\tmbox64->mbox32.status\t= scb->status;\n\traw_mbox\t\t= (uint8_t *)&mbox64->mbox32;\n\n\n\t\n\tscb->state\t= SCB_FREE;\n\tscb->scp\t= NULL;\n\n\tspin_lock_irqsave(USER_FREE_LIST_LOCK(adapter), flags);\n\n\tlist_add(&scb->list, &adapter->uscb_pool);\n\n\tspin_unlock_irqrestore(USER_FREE_LIST_LOCK(adapter), flags);\n\n\t\n\t\n\tif (raw_mbox[0] == FC_DEL_LOGDRV && raw_mbox[2] == OP_DEL_LOGDRV) {\n\n\t\tadapter->quiescent--;\n\n\t\tmegaraid_mbox_runpendq(adapter, NULL);\n\t}\n\n\tkioc->done(kioc);\n\n\treturn;\n}\n\n\n \nstatic int\ngather_hbainfo(adapter_t *adapter, mraid_hba_info_t *hinfo)\n{\n\thinfo->pci_vendor_id\t= adapter->pdev->vendor;\n\thinfo->pci_device_id\t= adapter->pdev->device;\n\thinfo->subsys_vendor_id\t= adapter->pdev->subsystem_vendor;\n\thinfo->subsys_device_id\t= adapter->pdev->subsystem_device;\n\n\thinfo->pci_bus\t\t= adapter->pdev->bus->number;\n\thinfo->pci_dev_fn\t= adapter->pdev->devfn;\n\thinfo->pci_slot\t\t= PCI_SLOT(adapter->pdev->devfn);\n\thinfo->irq\t\t= adapter->host->irq;\n\thinfo->baseport\t\t= ADAP2RAIDDEV(adapter)->baseport;\n\n\thinfo->unique_id\t= (hinfo->pci_bus << 8) | adapter->pdev->devfn;\n\thinfo->host_no\t\t= adapter->host->host_no;\n\n\treturn 0;\n}\n\n \n\n\n\n \nstatic int\nmegaraid_sysfs_alloc_resources(adapter_t *adapter)\n{\n\tmraid_device_t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\tint\t\trval = 0;\n\n\traid_dev->sysfs_uioc = kmalloc(sizeof(uioc_t), GFP_KERNEL);\n\n\traid_dev->sysfs_mbox64 = kmalloc(sizeof(mbox64_t), GFP_KERNEL);\n\n\traid_dev->sysfs_buffer = dma_alloc_coherent(&adapter->pdev->dev,\n\t\t\tPAGE_SIZE, &raid_dev->sysfs_buffer_dma, GFP_KERNEL);\n\n\tif (!raid_dev->sysfs_uioc || !raid_dev->sysfs_mbox64 ||\n\t\t!raid_dev->sysfs_buffer) {\n\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid: out of memory, %s %d\\n\", __func__,\n\t\t\t__LINE__));\n\n\t\trval = -ENOMEM;\n\n\t\tmegaraid_sysfs_free_resources(adapter);\n\t}\n\n\tmutex_init(&raid_dev->sysfs_mtx);\n\n\tinit_waitqueue_head(&raid_dev->sysfs_wait_q);\n\n\treturn rval;\n}\n\n\n \nstatic void\nmegaraid_sysfs_free_resources(adapter_t *adapter)\n{\n\tmraid_device_t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\n\tkfree(raid_dev->sysfs_uioc);\n\tkfree(raid_dev->sysfs_mbox64);\n\n\tif (raid_dev->sysfs_buffer) {\n\t\tdma_free_coherent(&adapter->pdev->dev, PAGE_SIZE,\n\t\t\traid_dev->sysfs_buffer, raid_dev->sysfs_buffer_dma);\n\t}\n}\n\n\n \nstatic void\nmegaraid_sysfs_get_ldmap_done(uioc_t *uioc)\n{\n\tadapter_t\t*adapter = (adapter_t *)uioc->buf_vaddr;\n\tmraid_device_t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\n\tuioc->status = 0;\n\n\twake_up(&raid_dev->sysfs_wait_q);\n}\n\n \nstatic void\nmegaraid_sysfs_get_ldmap_timeout(struct timer_list *t)\n{\n\tstruct uioc_timeout *timeout = from_timer(timeout, t, timer);\n\tuioc_t\t\t*uioc = timeout->uioc;\n\tadapter_t\t*adapter = (adapter_t *)uioc->buf_vaddr;\n\tmraid_device_t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\n\tuioc->status = -ETIME;\n\n\twake_up(&raid_dev->sysfs_wait_q);\n}\n\n\n \nstatic int\nmegaraid_sysfs_get_ldmap(adapter_t *adapter)\n{\n\tmraid_device_t\t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\tuioc_t\t\t\t*uioc;\n\tmbox64_t\t\t*mbox64;\n\tmbox_t\t\t\t*mbox;\n\tchar\t\t\t*raw_mbox;\n\tstruct uioc_timeout\ttimeout;\n\tcaddr_t\t\t\tldmap;\n\tint\t\t\trval = 0;\n\n\t \n\tmutex_lock(&raid_dev->sysfs_mtx);\n\n\tuioc\t= raid_dev->sysfs_uioc;\n\tmbox64\t= raid_dev->sysfs_mbox64;\n\tldmap\t= raid_dev->sysfs_buffer;\n\n\tmemset(uioc, 0, sizeof(uioc_t));\n\tmemset(mbox64, 0, sizeof(mbox64_t));\n\tmemset(ldmap, 0, sizeof(raid_dev->curr_ldmap));\n\n\tmbox\t\t= &mbox64->mbox32;\n\traw_mbox\t= (char *)mbox;\n\tuioc->cmdbuf    = (uint64_t)(unsigned long)mbox64;\n\tuioc->buf_vaddr\t= (caddr_t)adapter;\n\tuioc->status\t= -ENODATA;\n\tuioc->done\t= megaraid_sysfs_get_ldmap_done;\n\n\t \n\tmbox->xferaddr = (uint32_t)raid_dev->sysfs_buffer_dma;\n\n\traw_mbox[0] = FC_DEL_LOGDRV;\n\traw_mbox[2] = OP_GET_LDID_MAP;\n\n\t \n\ttimeout.uioc = uioc;\n\ttimer_setup_on_stack(&timeout.timer,\n\t\t\t     megaraid_sysfs_get_ldmap_timeout, 0);\n\n\ttimeout.timer.expires\t\t= jiffies + 60 * HZ;\n\tadd_timer(&timeout.timer);\n\n\t \n\trval = megaraid_mbox_mm_command(adapter, uioc);\n\n\tif (rval == 0) {\t\n\t\twait_event(raid_dev->sysfs_wait_q, (uioc->status != -ENODATA));\n\n\t\t \n\t\tif (uioc->status == -ETIME) {\n\t\t\tcon_log(CL_ANN, (KERN_NOTICE\n\t\t\t\t\"megaraid: sysfs get ld map timed out\\n\"));\n\n\t\t\trval = -ETIME;\n\t\t}\n\t\telse {\n\t\t\trval = mbox->status;\n\t\t}\n\n\t\tif (rval == 0) {\n\t\t\tmemcpy(raid_dev->curr_ldmap, ldmap,\n\t\t\t\tsizeof(raid_dev->curr_ldmap));\n\t\t}\n\t\telse {\n\t\t\tcon_log(CL_ANN, (KERN_NOTICE\n\t\t\t\t\"megaraid: get ld map failed with %x\\n\", rval));\n\t\t}\n\t}\n\telse {\n\t\tcon_log(CL_ANN, (KERN_NOTICE\n\t\t\t\"megaraid: could not issue ldmap command:%x\\n\", rval));\n\t}\n\n\n\tdel_timer_sync(&timeout.timer);\n\tdestroy_timer_on_stack(&timeout.timer);\n\n\tmutex_unlock(&raid_dev->sysfs_mtx);\n\n\treturn rval;\n}\n\n\n \nstatic ssize_t\nmegaraid_mbox_app_hndl_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tadapter_t\t*adapter = (adapter_t *)SCSIHOST2ADAP(shost);\n\tuint32_t\tapp_hndl;\n\n\tapp_hndl = mraid_mm_adapter_app_handle(adapter->unique_id);\n\n\treturn sysfs_emit(buf, \"%u\\n\", app_hndl);\n}\n\n\n \nstatic ssize_t\nmegaraid_mbox_ld_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tadapter_t\t*adapter = (adapter_t *)SCSIHOST2ADAP(sdev->host);\n\tmraid_device_t\t*raid_dev = ADAP2RAIDDEV(adapter);\n\tint\t\tscsi_id = -1;\n\tint\t\tlogical_drv = -1;\n\tint\t\tldid_map = -1;\n\tuint32_t\tapp_hndl = 0;\n\tint\t\tmapped_sdev_id;\n\tint\t\trval;\n\tint\t\ti;\n\n\tif (raid_dev->random_del_supported &&\n\t\t\tMRAID_IS_LOGICAL_SDEV(adapter, sdev)) {\n\n\t\trval = megaraid_sysfs_get_ldmap(adapter);\n\t\tif (rval == 0) {\n\n\t\t\tfor (i = 0; i < MAX_LOGICAL_DRIVES_40LD; i++) {\n\n\t\t\t\tmapped_sdev_id = sdev->id;\n\n\t\t\t\tif (sdev->id > adapter->init_id) {\n\t\t\t\t\tmapped_sdev_id -= 1;\n\t\t\t\t}\n\n\t\t\t\tif (raid_dev->curr_ldmap[i] == mapped_sdev_id) {\n\n\t\t\t\t\tscsi_id = sdev->id;\n\n\t\t\t\t\tlogical_drv = i;\n\n\t\t\t\t\tldid_map = raid_dev->curr_ldmap[i];\n\n\t\t\t\t\tapp_hndl = mraid_mm_adapter_app_handle(\n\t\t\t\t\t\t\tadapter->unique_id);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcon_log(CL_ANN, (KERN_NOTICE\n\t\t\t\t\"megaraid: sysfs get ld map failed: %x\\n\",\n\t\t\t\trval));\n\t\t}\n\t}\n\n\treturn sysfs_emit(buf, \"%d %d %d %d\\n\", scsi_id, logical_drv,\n\t\t\tldid_map, app_hndl);\n}\n\n\n \nmodule_init(megaraid_init);\nmodule_exit(megaraid_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}