{
  "module_name": "megaraid_sas_fusion.c",
  "hash_id": "227d23fae1fe19533cd477f0d24da9cbb9b916bf440be3ddf73bc178212fa526",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/megaraid/megaraid_sas_fusion.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/uio.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/vmalloc.h>\n#include <linux/workqueue.h>\n#include <linux/irq_poll.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_dbg.h>\n#include <linux/dmi.h>\n\n#include \"megaraid_sas_fusion.h\"\n#include \"megaraid_sas.h\"\n\n\nextern void\nmegasas_complete_cmd(struct megasas_instance *instance,\n\t\t     struct megasas_cmd *cmd, u8 alt_status);\nint\nwait_and_poll(struct megasas_instance *instance, struct megasas_cmd *cmd,\n\t      int seconds);\n\nint\nmegasas_clear_intr_fusion(struct megasas_instance *instance);\n\nint megasas_transition_to_ready(struct megasas_instance *instance, int ocr);\n\nextern u32 megasas_dbg_lvl;\nint megasas_sriov_start_heartbeat(struct megasas_instance *instance,\n\t\t\t\t  int initial);\nextern struct megasas_mgmt_info megasas_mgmt_info;\nextern unsigned int resetwaittime;\nextern unsigned int dual_qdepth_disable;\nstatic void megasas_free_rdpq_fusion(struct megasas_instance *instance);\nstatic void megasas_free_reply_fusion(struct megasas_instance *instance);\nstatic inline\nvoid megasas_configure_queue_sizes(struct megasas_instance *instance);\nstatic void megasas_fusion_crash_dump(struct megasas_instance *instance);\n\n \nint\nmegasas_adp_reset_wait_for_ready(struct megasas_instance *instance,\n\t\t\t\t bool do_adp_reset,\n\t\t\t\t int ocr_context)\n{\n\tint ret = FAILED;\n\n\t \n\tif (megasas_dbg_lvl & OCR_DEBUG)\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"Block access to PCI config space %s %d\\n\",\n\t\t\t __func__, __LINE__);\n\n\tpci_cfg_access_lock(instance->pdev);\n\n\tif (do_adp_reset) {\n\t\tif (instance->instancet->adp_reset\n\t\t\t(instance, instance->reg_set))\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (megasas_transition_to_ready(instance, ocr_context)) {\n\t\tdev_warn(&instance->pdev->dev,\n\t\t\t \"Failed to transition controller to ready for scsi%d.\\n\",\n\t\t\t instance->host->host_no);\n\t\tgoto out;\n\t}\n\n\tret = SUCCESS;\nout:\n\tif (megasas_dbg_lvl & OCR_DEBUG)\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"Unlock access to PCI config space %s %d\\n\",\n\t\t\t __func__, __LINE__);\n\n\tpci_cfg_access_unlock(instance->pdev);\n\n\treturn ret;\n}\n\n \nstatic inline bool megasas_check_same_4gb_region\n\t(struct megasas_instance *instance, dma_addr_t start_addr, size_t size)\n{\n\tdma_addr_t end_addr;\n\n\tend_addr = start_addr + size;\n\n\tif (upper_32_bits(start_addr) != upper_32_bits(end_addr)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to get same 4GB boundary: start_addr: 0x%llx end_addr: 0x%llx\\n\",\n\t\t\t(unsigned long long)start_addr,\n\t\t\t(unsigned long long)end_addr);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic void\nmegasas_enable_intr_fusion(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\tinstance->mask_interrupts = 0;\n\t \n\twritel(~0, &regs->outbound_intr_status);\n\treadl(&regs->outbound_intr_status);\n\n\twritel(~MFI_FUSION_ENABLE_INTERRUPT_MASK, &(regs)->outbound_intr_mask);\n\n\t \n\tdev_info(&instance->pdev->dev, \"%s is called outbound_intr_mask:0x%08x\\n\",\n\t\t __func__, readl(&regs->outbound_intr_mask));\n}\n\n \nstatic void\nmegasas_disable_intr_fusion(struct megasas_instance *instance)\n{\n\tu32 mask = 0xFFFFFFFF;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\tinstance->mask_interrupts = 1;\n\n\twritel(mask, &regs->outbound_intr_mask);\n\t \n\tdev_info(&instance->pdev->dev, \"%s is called outbound_intr_mask:0x%08x\\n\",\n\t\t __func__, readl(&regs->outbound_intr_mask));\n}\n\nint\nmegasas_clear_intr_fusion(struct megasas_instance *instance)\n{\n\tu32 status;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\t \n\tstatus = megasas_readl(instance,\n\t\t\t       &regs->outbound_intr_status);\n\n\tif (status & 1) {\n\t\twritel(status, &regs->outbound_intr_status);\n\t\treadl(&regs->outbound_intr_status);\n\t\treturn 1;\n\t}\n\tif (!(status & MFI_FUSION_ENABLE_INTERRUPT_MASK))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic inline void\nmegasas_sdev_busy_inc(struct megasas_instance *instance,\n\t\t      struct scsi_cmnd *scmd)\n{\n\tif (instance->perf_mode == MR_BALANCED_PERF_MODE) {\n\t\tstruct MR_PRIV_DEVICE *mr_device_priv_data =\n\t\t\tscmd->device->hostdata;\n\t\tatomic_inc(&mr_device_priv_data->sdev_priv_busy);\n\t}\n}\n\nstatic inline void\nmegasas_sdev_busy_dec(struct megasas_instance *instance,\n\t\t      struct scsi_cmnd *scmd)\n{\n\tif (instance->perf_mode == MR_BALANCED_PERF_MODE) {\n\t\tstruct MR_PRIV_DEVICE *mr_device_priv_data =\n\t\t\tscmd->device->hostdata;\n\t\tatomic_dec(&mr_device_priv_data->sdev_priv_busy);\n\t}\n}\n\nstatic inline int\nmegasas_sdev_busy_read(struct megasas_instance *instance,\n\t\t       struct scsi_cmnd *scmd)\n{\n\tif (instance->perf_mode == MR_BALANCED_PERF_MODE) {\n\t\tstruct MR_PRIV_DEVICE *mr_device_priv_data =\n\t\t\tscmd->device->hostdata;\n\t\treturn atomic_read(&mr_device_priv_data->sdev_priv_busy);\n\t}\n\treturn 0;\n}\n\n \ninline struct megasas_cmd_fusion *megasas_get_cmd_fusion(struct megasas_instance\n\t\t\t\t\t\t  *instance, u32 blk_tag)\n{\n\tstruct fusion_context *fusion;\n\n\tfusion = instance->ctrl_context;\n\treturn fusion->cmd_list[blk_tag];\n}\n\n \ninline void megasas_return_cmd_fusion(struct megasas_instance *instance,\n\tstruct megasas_cmd_fusion *cmd)\n{\n\tcmd->scmd = NULL;\n\tmemset(cmd->io_request, 0, MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE);\n\tcmd->r1_alt_dev_handle = MR_DEVHANDLE_INVALID;\n\tcmd->cmd_completed = false;\n}\n\n \nstatic void\nmegasas_write_64bit_req_desc(struct megasas_instance *instance,\n\t\tunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc)\n{\n#if defined(writeq) && defined(CONFIG_64BIT)\n\tu64 req_data = (((u64)le32_to_cpu(req_desc->u.high) << 32) |\n\t\tle32_to_cpu(req_desc->u.low));\n\twriteq(req_data, &instance->reg_set->inbound_low_queue_port);\n#else\n\tunsigned long flags;\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel(le32_to_cpu(req_desc->u.low),\n\t\t&instance->reg_set->inbound_low_queue_port);\n\twritel(le32_to_cpu(req_desc->u.high),\n\t\t&instance->reg_set->inbound_high_queue_port);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n#endif\n}\n\n \nstatic void\nmegasas_fire_cmd_fusion(struct megasas_instance *instance,\n\t\tunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc)\n{\n\tif (instance->atomic_desc_support)\n\t\twritel(le32_to_cpu(req_desc->u.low),\n\t\t\t&instance->reg_set->inbound_single_queue_port);\n\telse\n\t\tmegasas_write_64bit_req_desc(instance, req_desc);\n}\n\n \nstatic void\nmegasas_fusion_update_can_queue(struct megasas_instance *instance, int fw_boot_context)\n{\n\tu16 cur_max_fw_cmds = 0;\n\tu16 ldio_threshold = 0;\n\n\t \n\tif (instance->adapter_type < VENTURA_SERIES)\n\t\tcur_max_fw_cmds =\n\t\tmegasas_readl(instance,\n\t\t\t      &instance->reg_set->outbound_scratch_pad_2) & 0x00FFFF;\n\n\tif (dual_qdepth_disable || !cur_max_fw_cmds)\n\t\tcur_max_fw_cmds = instance->instancet->read_fw_status_reg(instance) & 0x00FFFF;\n\telse\n\t\tldio_threshold =\n\t\t\t(instance->instancet->read_fw_status_reg(instance) & 0x00FFFF) - MEGASAS_FUSION_IOCTL_CMDS;\n\n\tdev_info(&instance->pdev->dev,\n\t\t \"Current firmware supports maximum commands: %d\\t LDIO threshold: %d\\n\",\n\t\t cur_max_fw_cmds, ldio_threshold);\n\n\tif (fw_boot_context == OCR_CONTEXT) {\n\t\tcur_max_fw_cmds = cur_max_fw_cmds - 1;\n\t\tif (cur_max_fw_cmds < instance->max_fw_cmds) {\n\t\t\tinstance->cur_can_queue =\n\t\t\t\tcur_max_fw_cmds - (MEGASAS_FUSION_INTERNAL_CMDS +\n\t\t\t\t\t\tMEGASAS_FUSION_IOCTL_CMDS);\n\t\t\tinstance->host->can_queue = instance->cur_can_queue;\n\t\t\tinstance->ldio_threshold = ldio_threshold;\n\t\t}\n\t} else {\n\t\tinstance->max_fw_cmds = cur_max_fw_cmds;\n\t\tinstance->ldio_threshold = ldio_threshold;\n\n\t\tif (reset_devices)\n\t\t\tinstance->max_fw_cmds = min(instance->max_fw_cmds,\n\t\t\t\t\t\t(u16)MEGASAS_KDUMP_QUEUE_DEPTH);\n\t\t \n\t\tinstance->max_fw_cmds = instance->max_fw_cmds-1;\n\t}\n}\n\nstatic inline void\nmegasas_get_msix_index(struct megasas_instance *instance,\n\t\t       struct scsi_cmnd *scmd,\n\t\t       struct megasas_cmd_fusion *cmd,\n\t\t       u8 data_arms)\n{\n\tif (instance->perf_mode == MR_BALANCED_PERF_MODE &&\n\t    (megasas_sdev_busy_read(instance, scmd) >\n\t     (data_arms * MR_DEVICE_HIGH_IOPS_DEPTH))) {\n\t\tcmd->request_desc->SCSIIO.MSIxIndex =\n\t\t\tmega_mod64((atomic64_add_return(1, &instance->high_iops_outstanding) /\n\t\t\t\t\tMR_HIGH_IOPS_BATCH_COUNT), instance->low_latency_index_start);\n\t} else if (instance->msix_load_balance) {\n\t\tcmd->request_desc->SCSIIO.MSIxIndex =\n\t\t\t(mega_mod64(atomic64_add_return(1, &instance->total_io_count),\n\t\t\t\tinstance->msix_vectors));\n\t} else if (instance->host->nr_hw_queues > 1) {\n\t\tu32 tag = blk_mq_unique_tag(scsi_cmd_to_rq(scmd));\n\n\t\tcmd->request_desc->SCSIIO.MSIxIndex = blk_mq_unique_tag_to_hwq(tag) +\n\t\t\tinstance->low_latency_index_start;\n\t} else {\n\t\tcmd->request_desc->SCSIIO.MSIxIndex =\n\t\t\tinstance->reply_map[raw_smp_processor_id()];\n\t}\n}\n\n \nvoid\nmegasas_free_cmds_fusion(struct megasas_instance *instance)\n{\n\tint i;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tstruct megasas_cmd_fusion *cmd;\n\n\tif (fusion->sense)\n\t\tdma_pool_free(fusion->sense_dma_pool, fusion->sense,\n\t\t\t      fusion->sense_phys_addr);\n\n\t \n\tif (fusion->cmd_list) {\n\t\tfor (i = 0; i < instance->max_mpt_cmds; i++) {\n\t\t\tcmd = fusion->cmd_list[i];\n\t\t\tif (cmd) {\n\t\t\t\tif (cmd->sg_frame)\n\t\t\t\t\tdma_pool_free(fusion->sg_dma_pool,\n\t\t\t\t\t\t      cmd->sg_frame,\n\t\t\t\t\t\t      cmd->sg_frame_phys_addr);\n\t\t\t}\n\t\t\tkfree(cmd);\n\t\t}\n\t\tkfree(fusion->cmd_list);\n\t}\n\n\tif (fusion->sg_dma_pool) {\n\t\tdma_pool_destroy(fusion->sg_dma_pool);\n\t\tfusion->sg_dma_pool = NULL;\n\t}\n\tif (fusion->sense_dma_pool) {\n\t\tdma_pool_destroy(fusion->sense_dma_pool);\n\t\tfusion->sense_dma_pool = NULL;\n\t}\n\n\n\t \n\tif (instance->is_rdpq)\n\t\tmegasas_free_rdpq_fusion(instance);\n\telse\n\t\tmegasas_free_reply_fusion(instance);\n\n\t \n\tif (fusion->req_frames_desc)\n\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\tfusion->request_alloc_sz, fusion->req_frames_desc,\n\t\t\tfusion->req_frames_desc_phys);\n\tif (fusion->io_request_frames)\n\t\tdma_pool_free(fusion->io_request_frames_pool,\n\t\t\tfusion->io_request_frames,\n\t\t\tfusion->io_request_frames_phys);\n\tif (fusion->io_request_frames_pool) {\n\t\tdma_pool_destroy(fusion->io_request_frames_pool);\n\t\tfusion->io_request_frames_pool = NULL;\n\t}\n}\n\n \nstatic int megasas_create_sg_sense_fusion(struct megasas_instance *instance)\n{\n\tint i;\n\tu16 max_cmd;\n\tstruct fusion_context *fusion;\n\tstruct megasas_cmd_fusion *cmd;\n\tint sense_sz;\n\tu32 offset;\n\n\tfusion = instance->ctrl_context;\n\tmax_cmd = instance->max_fw_cmds;\n\tsense_sz = instance->max_mpt_cmds * SCSI_SENSE_BUFFERSIZE;\n\n\tfusion->sg_dma_pool =\n\t\t\tdma_pool_create(\"mr_sg\", &instance->pdev->dev,\n\t\t\t\tinstance->max_chain_frame_sz,\n\t\t\t\tMR_DEFAULT_NVME_PAGE_SIZE, 0);\n\t \n\tfusion->sense_dma_pool =\n\t\t\tdma_pool_create(\"mr_sense\", &instance->pdev->dev,\n\t\t\t\tsense_sz, 64, 0);\n\n\tif (!fusion->sense_dma_pool || !fusion->sg_dma_pool) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfusion->sense = dma_pool_alloc(fusion->sense_dma_pool,\n\t\t\t\t       GFP_KERNEL, &fusion->sense_phys_addr);\n\tif (!fusion->sense) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"failed from %s %d\\n\",  __func__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\n\tif (!megasas_check_same_4gb_region(instance, fusion->sense_phys_addr,\n\t\t\t\t\t   sense_sz)) {\n\t\tdma_pool_free(fusion->sense_dma_pool, fusion->sense,\n\t\t\t      fusion->sense_phys_addr);\n\t\tfusion->sense = NULL;\n\t\tdma_pool_destroy(fusion->sense_dma_pool);\n\n\t\tfusion->sense_dma_pool =\n\t\t\tdma_pool_create(\"mr_sense_align\", &instance->pdev->dev,\n\t\t\t\t\tsense_sz, roundup_pow_of_two(sense_sz),\n\t\t\t\t\t0);\n\t\tif (!fusion->sense_dma_pool) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfusion->sense = dma_pool_alloc(fusion->sense_dma_pool,\n\t\t\t\t\t       GFP_KERNEL,\n\t\t\t\t\t       &fusion->sense_phys_addr);\n\t\tif (!fusion->sense) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"failed from %s %d\\n\",  __func__, __LINE__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = fusion->cmd_list[i];\n\t\tcmd->sg_frame = dma_pool_alloc(fusion->sg_dma_pool,\n\t\t\t\t\tGFP_KERNEL, &cmd->sg_frame_phys_addr);\n\n\t\toffset = SCSI_SENSE_BUFFERSIZE * i;\n\t\tcmd->sense = (u8 *)fusion->sense + offset;\n\t\tcmd->sense_phys_addr = fusion->sense_phys_addr + offset;\n\n\t\tif (!cmd->sg_frame) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tfor (i = max_cmd; i < instance->max_mpt_cmds; i++) {\n\t\tcmd = fusion->cmd_list[i];\n\t\toffset = SCSI_SENSE_BUFFERSIZE * i;\n\t\tcmd->sense = (u8 *)fusion->sense + offset;\n\t\tcmd->sense_phys_addr = fusion->sense_phys_addr + offset;\n\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmegasas_alloc_cmdlist_fusion(struct megasas_instance *instance)\n{\n\tu32 max_mpt_cmd, i, j;\n\tstruct fusion_context *fusion;\n\n\tfusion = instance->ctrl_context;\n\n\tmax_mpt_cmd = instance->max_mpt_cmds;\n\n\t \n\tfusion->cmd_list =\n\t\tkcalloc(max_mpt_cmd, sizeof(struct megasas_cmd_fusion *),\n\t\t\tGFP_KERNEL);\n\tif (!fusion->cmd_list) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < max_mpt_cmd; i++) {\n\t\tfusion->cmd_list[i] = kzalloc(sizeof(struct megasas_cmd_fusion),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!fusion->cmd_list[i]) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(fusion->cmd_list[j]);\n\t\t\tkfree(fusion->cmd_list);\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmegasas_alloc_request_fusion(struct megasas_instance *instance)\n{\n\tstruct fusion_context *fusion;\n\n\tfusion = instance->ctrl_context;\n\nretry_alloc:\n\tfusion->io_request_frames_pool =\n\t\t\tdma_pool_create(\"mr_ioreq\", &instance->pdev->dev,\n\t\t\t\tfusion->io_frames_alloc_sz, 16, 0);\n\n\tif (!fusion->io_request_frames_pool) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfusion->io_request_frames =\n\t\t\tdma_pool_alloc(fusion->io_request_frames_pool,\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN,\n\t\t\t\t&fusion->io_request_frames_phys);\n\tif (!fusion->io_request_frames) {\n\t\tif (instance->max_fw_cmds >= (MEGASAS_REDUCE_QD_COUNT * 2)) {\n\t\t\tinstance->max_fw_cmds -= MEGASAS_REDUCE_QD_COUNT;\n\t\t\tdma_pool_destroy(fusion->io_request_frames_pool);\n\t\t\tmegasas_configure_queue_sizes(instance);\n\t\t\tgoto retry_alloc;\n\t\t} else {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (!megasas_check_same_4gb_region(instance,\n\t\t\t\t\t   fusion->io_request_frames_phys,\n\t\t\t\t\t   fusion->io_frames_alloc_sz)) {\n\t\tdma_pool_free(fusion->io_request_frames_pool,\n\t\t\t      fusion->io_request_frames,\n\t\t\t      fusion->io_request_frames_phys);\n\t\tfusion->io_request_frames = NULL;\n\t\tdma_pool_destroy(fusion->io_request_frames_pool);\n\n\t\tfusion->io_request_frames_pool =\n\t\t\tdma_pool_create(\"mr_ioreq_align\",\n\t\t\t\t\t&instance->pdev->dev,\n\t\t\t\t\tfusion->io_frames_alloc_sz,\n\t\t\t\t\troundup_pow_of_two(fusion->io_frames_alloc_sz),\n\t\t\t\t\t0);\n\n\t\tif (!fusion->io_request_frames_pool) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfusion->io_request_frames =\n\t\t\tdma_pool_alloc(fusion->io_request_frames_pool,\n\t\t\t\t       GFP_KERNEL | __GFP_NOWARN,\n\t\t\t\t       &fusion->io_request_frames_phys);\n\n\t\tif (!fusion->io_request_frames) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfusion->req_frames_desc =\n\t\tdma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t   fusion->request_alloc_sz,\n\t\t\t\t   &fusion->req_frames_desc_phys, GFP_KERNEL);\n\tif (!fusion->req_frames_desc) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmegasas_alloc_reply_fusion(struct megasas_instance *instance)\n{\n\tint i, count;\n\tstruct fusion_context *fusion;\n\tunion MPI2_REPLY_DESCRIPTORS_UNION *reply_desc;\n\tfusion = instance->ctrl_context;\n\n\tcount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\n\tcount += instance->iopoll_q_count;\n\n\tfusion->reply_frames_desc_pool =\n\t\t\tdma_pool_create(\"mr_reply\", &instance->pdev->dev,\n\t\t\t\tfusion->reply_alloc_sz * count, 16, 0);\n\n\tif (!fusion->reply_frames_desc_pool) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfusion->reply_frames_desc[0] =\n\t\tdma_pool_alloc(fusion->reply_frames_desc_pool,\n\t\t\tGFP_KERNEL, &fusion->reply_frames_desc_phys[0]);\n\tif (!fusion->reply_frames_desc[0]) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!megasas_check_same_4gb_region(instance,\n\t\t\t\t\t   fusion->reply_frames_desc_phys[0],\n\t\t\t\t\t   (fusion->reply_alloc_sz * count))) {\n\t\tdma_pool_free(fusion->reply_frames_desc_pool,\n\t\t\t      fusion->reply_frames_desc[0],\n\t\t\t      fusion->reply_frames_desc_phys[0]);\n\t\tfusion->reply_frames_desc[0] = NULL;\n\t\tdma_pool_destroy(fusion->reply_frames_desc_pool);\n\n\t\tfusion->reply_frames_desc_pool =\n\t\t\tdma_pool_create(\"mr_reply_align\",\n\t\t\t\t\t&instance->pdev->dev,\n\t\t\t\t\tfusion->reply_alloc_sz * count,\n\t\t\t\t\troundup_pow_of_two(fusion->reply_alloc_sz * count),\n\t\t\t\t\t0);\n\n\t\tif (!fusion->reply_frames_desc_pool) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfusion->reply_frames_desc[0] =\n\t\t\tdma_pool_alloc(fusion->reply_frames_desc_pool,\n\t\t\t\t       GFP_KERNEL,\n\t\t\t\t       &fusion->reply_frames_desc_phys[0]);\n\n\t\tif (!fusion->reply_frames_desc[0]) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treply_desc = fusion->reply_frames_desc[0];\n\tfor (i = 0; i < fusion->reply_q_depth * count; i++, reply_desc++)\n\t\treply_desc->Words = cpu_to_le64(ULLONG_MAX);\n\n\t \n\tfor (i = 0; i < (count - 1); i++)\n\t\tfusion->reply_frames_desc[i + 1] =\n\t\t\tfusion->reply_frames_desc[i] +\n\t\t\t(fusion->reply_alloc_sz)/sizeof(union MPI2_REPLY_DESCRIPTORS_UNION);\n\n\treturn 0;\n}\n\nstatic int\nmegasas_alloc_rdpq_fusion(struct megasas_instance *instance)\n{\n\tint i, j, k, msix_count;\n\tstruct fusion_context *fusion;\n\tunion MPI2_REPLY_DESCRIPTORS_UNION *reply_desc;\n\tunion MPI2_REPLY_DESCRIPTORS_UNION *rdpq_chunk_virt[RDPQ_MAX_CHUNK_COUNT];\n\tdma_addr_t rdpq_chunk_phys[RDPQ_MAX_CHUNK_COUNT];\n\tu8 dma_alloc_count, abs_index;\n\tu32 chunk_size, array_size, offset;\n\n\tfusion = instance->ctrl_context;\n\tchunk_size = fusion->reply_alloc_sz * RDPQ_MAX_INDEX_IN_ONE_CHUNK;\n\tarray_size = sizeof(struct MPI2_IOC_INIT_RDPQ_ARRAY_ENTRY) *\n\t\t     MAX_MSIX_QUEUES_FUSION;\n\n\tfusion->rdpq_virt = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t       array_size, &fusion->rdpq_phys,\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!fusion->rdpq_virt) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmsix_count = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\n\tmsix_count += instance->iopoll_q_count;\n\n\tfusion->reply_frames_desc_pool = dma_pool_create(\"mr_rdpq\",\n\t\t\t\t\t\t\t &instance->pdev->dev,\n\t\t\t\t\t\t\t chunk_size, 16, 0);\n\tfusion->reply_frames_desc_pool_align =\n\t\t\t\tdma_pool_create(\"mr_rdpq_align\",\n\t\t\t\t\t\t&instance->pdev->dev,\n\t\t\t\t\t\tchunk_size,\n\t\t\t\t\t\troundup_pow_of_two(chunk_size),\n\t\t\t\t\t\t0);\n\n\tif (!fusion->reply_frames_desc_pool ||\n\t    !fusion->reply_frames_desc_pool_align) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n \n\tdma_alloc_count = DIV_ROUND_UP(msix_count, RDPQ_MAX_INDEX_IN_ONE_CHUNK);\n\n\tfor (i = 0; i < dma_alloc_count; i++) {\n\t\trdpq_chunk_virt[i] =\n\t\t\tdma_pool_alloc(fusion->reply_frames_desc_pool,\n\t\t\t\t       GFP_KERNEL, &rdpq_chunk_phys[i]);\n\t\tif (!rdpq_chunk_virt[i]) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed from %s %d\\n\",  __func__, __LINE__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t \n\t\tif (!megasas_check_same_4gb_region(instance, rdpq_chunk_phys[i],\n\t\t\t\t\t\t   chunk_size)) {\n\t\t\tdma_pool_free(fusion->reply_frames_desc_pool,\n\t\t\t\t      rdpq_chunk_virt[i],\n\t\t\t\t      rdpq_chunk_phys[i]);\n\n\t\t\trdpq_chunk_virt[i] =\n\t\t\t\tdma_pool_alloc(fusion->reply_frames_desc_pool_align,\n\t\t\t\t\t       GFP_KERNEL, &rdpq_chunk_phys[i]);\n\t\t\tif (!rdpq_chunk_virt[i]) {\n\t\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\t\"Failed from %s %d\\n\",\n\t\t\t\t\t__func__, __LINE__);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tfusion->rdpq_tracker[i].dma_pool_ptr =\n\t\t\t\t\tfusion->reply_frames_desc_pool_align;\n\t\t} else {\n\t\t\tfusion->rdpq_tracker[i].dma_pool_ptr =\n\t\t\t\t\tfusion->reply_frames_desc_pool;\n\t\t}\n\n\t\tfusion->rdpq_tracker[i].pool_entry_phys = rdpq_chunk_phys[i];\n\t\tfusion->rdpq_tracker[i].pool_entry_virt = rdpq_chunk_virt[i];\n\t}\n\n\tfor (k = 0; k < dma_alloc_count; k++) {\n\t\tfor (i = 0; i < RDPQ_MAX_INDEX_IN_ONE_CHUNK; i++) {\n\t\t\tabs_index = (k * RDPQ_MAX_INDEX_IN_ONE_CHUNK) + i;\n\n\t\t\tif (abs_index == msix_count)\n\t\t\t\tbreak;\n\t\t\toffset = fusion->reply_alloc_sz * i;\n\t\t\tfusion->rdpq_virt[abs_index].RDPQBaseAddress =\n\t\t\t\t\tcpu_to_le64(rdpq_chunk_phys[k] + offset);\n\t\t\tfusion->reply_frames_desc_phys[abs_index] =\n\t\t\t\t\trdpq_chunk_phys[k] + offset;\n\t\t\tfusion->reply_frames_desc[abs_index] =\n\t\t\t\t\t(union MPI2_REPLY_DESCRIPTORS_UNION *)((u8 *)rdpq_chunk_virt[k] + offset);\n\n\t\t\treply_desc = fusion->reply_frames_desc[abs_index];\n\t\t\tfor (j = 0; j < fusion->reply_q_depth; j++, reply_desc++)\n\t\t\t\treply_desc->Words = ULLONG_MAX;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void\nmegasas_free_rdpq_fusion(struct megasas_instance *instance) {\n\n\tint i;\n\tstruct fusion_context *fusion;\n\n\tfusion = instance->ctrl_context;\n\n\tfor (i = 0; i < RDPQ_MAX_CHUNK_COUNT; i++) {\n\t\tif (fusion->rdpq_tracker[i].pool_entry_virt)\n\t\t\tdma_pool_free(fusion->rdpq_tracker[i].dma_pool_ptr,\n\t\t\t\t      fusion->rdpq_tracker[i].pool_entry_virt,\n\t\t\t\t      fusion->rdpq_tracker[i].pool_entry_phys);\n\n\t}\n\n\tdma_pool_destroy(fusion->reply_frames_desc_pool);\n\tdma_pool_destroy(fusion->reply_frames_desc_pool_align);\n\n\tif (fusion->rdpq_virt)\n\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\tsizeof(struct MPI2_IOC_INIT_RDPQ_ARRAY_ENTRY) * MAX_MSIX_QUEUES_FUSION,\n\t\t\tfusion->rdpq_virt, fusion->rdpq_phys);\n}\n\nstatic void\nmegasas_free_reply_fusion(struct megasas_instance *instance) {\n\n\tstruct fusion_context *fusion;\n\n\tfusion = instance->ctrl_context;\n\n\tif (fusion->reply_frames_desc[0])\n\t\tdma_pool_free(fusion->reply_frames_desc_pool,\n\t\t\tfusion->reply_frames_desc[0],\n\t\t\tfusion->reply_frames_desc_phys[0]);\n\n\tdma_pool_destroy(fusion->reply_frames_desc_pool);\n\n}\n\n\n \nstatic int\nmegasas_alloc_cmds_fusion(struct megasas_instance *instance)\n{\n\tint i;\n\tstruct fusion_context *fusion;\n\tstruct megasas_cmd_fusion *cmd;\n\tu32 offset;\n\tdma_addr_t io_req_base_phys;\n\tu8 *io_req_base;\n\n\n\tfusion = instance->ctrl_context;\n\n\tif (megasas_alloc_request_fusion(instance))\n\t\tgoto fail_exit;\n\n\tif (instance->is_rdpq) {\n\t\tif (megasas_alloc_rdpq_fusion(instance))\n\t\t\tgoto fail_exit;\n\t} else\n\t\tif (megasas_alloc_reply_fusion(instance))\n\t\t\tgoto fail_exit;\n\n\tif (megasas_alloc_cmdlist_fusion(instance))\n\t\tgoto fail_exit;\n\n\t \n\tio_req_base = fusion->io_request_frames + MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE;\n\tio_req_base_phys = fusion->io_request_frames_phys + MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE;\n\n\t \n\n\t \n\tfor (i = 0; i < instance->max_mpt_cmds; i++) {\n\t\tcmd = fusion->cmd_list[i];\n\t\toffset = MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE * i;\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd_fusion));\n\t\tcmd->index = i + 1;\n\t\tcmd->scmd = NULL;\n\t\tcmd->sync_cmd_idx =\n\t\t(i >= instance->max_scsi_cmds && i < instance->max_fw_cmds) ?\n\t\t\t\t(i - instance->max_scsi_cmds) :\n\t\t\t\t(u32)ULONG_MAX;  \n\t\tcmd->instance = instance;\n\t\tcmd->io_request =\n\t\t\t(struct MPI2_RAID_SCSI_IO_REQUEST *)\n\t\t  (io_req_base + offset);\n\t\tmemset(cmd->io_request, 0,\n\t\t       sizeof(struct MPI2_RAID_SCSI_IO_REQUEST));\n\t\tcmd->io_request_phys_addr = io_req_base_phys + offset;\n\t\tcmd->r1_alt_dev_handle = MR_DEVHANDLE_INVALID;\n\t}\n\n\tif (megasas_create_sg_sense_fusion(instance))\n\t\tgoto fail_exit;\n\n\treturn 0;\n\nfail_exit:\n\tmegasas_free_cmds_fusion(instance);\n\treturn -ENOMEM;\n}\n\n \nint\nwait_and_poll(struct megasas_instance *instance, struct megasas_cmd *cmd,\n\tint seconds)\n{\n\tint i;\n\tstruct megasas_header *frame_hdr = &cmd->frame->hdr;\n\tu32 status_reg;\n\n\tu32 msecs = seconds * 1000;\n\n\t \n\tfor (i = 0; (i < msecs) && (frame_hdr->cmd_status == 0xff); i += 20) {\n\t\trmb();\n\t\tmsleep(20);\n\t\tif (!(i % 5000)) {\n\t\t\tstatus_reg = instance->instancet->read_fw_status_reg(instance)\n\t\t\t\t\t& MFI_STATE_MASK;\n\t\t\tif (status_reg == MFI_STATE_FAULT)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (frame_hdr->cmd_status == MFI_STAT_INVALID_STATUS)\n\t\treturn DCMD_TIMEOUT;\n\telse if (frame_hdr->cmd_status == MFI_STAT_OK)\n\t\treturn DCMD_SUCCESS;\n\telse\n\t\treturn DCMD_FAILED;\n}\n\n \nint\nmegasas_ioc_init_fusion(struct megasas_instance *instance)\n{\n\tstruct megasas_init_frame *init_frame;\n\tstruct MPI2_IOC_INIT_REQUEST *IOCInitMessage = NULL;\n\tdma_addr_t\tioc_init_handle;\n\tstruct megasas_cmd *cmd;\n\tu8 ret, cur_rdpq_mode;\n\tstruct fusion_context *fusion;\n\tunion MEGASAS_REQUEST_DESCRIPTOR_UNION req_desc;\n\tint i;\n\tstruct megasas_header *frame_hdr;\n\tconst char *sys_info;\n\tMFI_CAPABILITIES *drv_ops;\n\tu32 scratch_pad_1;\n\tktime_t time;\n\tbool cur_fw_64bit_dma_capable;\n\tbool cur_intr_coalescing;\n\n\tfusion = instance->ctrl_context;\n\n\tioc_init_handle = fusion->ioc_init_request_phys;\n\tIOCInitMessage = fusion->ioc_init_request;\n\n\tcmd = fusion->ioc_init_cmd;\n\n\tscratch_pad_1 = megasas_readl\n\t\t(instance, &instance->reg_set->outbound_scratch_pad_1);\n\n\tcur_rdpq_mode = (scratch_pad_1 & MR_RDPQ_MODE_OFFSET) ? 1 : 0;\n\n\tif (instance->adapter_type == INVADER_SERIES) {\n\t\tcur_fw_64bit_dma_capable =\n\t\t\t(scratch_pad_1 & MR_CAN_HANDLE_64_BIT_DMA_OFFSET) ? true : false;\n\n\t\tif (instance->consistent_mask_64bit && !cur_fw_64bit_dma_capable) {\n\t\t\tdev_err(&instance->pdev->dev, \"Driver was operating on 64bit \"\n\t\t\t\t\"DMA mask, but upcoming FW does not support 64bit DMA mask\\n\");\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tret = 1;\n\t\t\tgoto fail_fw_init;\n\t\t}\n\t}\n\n\tif (instance->is_rdpq && !cur_rdpq_mode) {\n\t\tdev_err(&instance->pdev->dev, \"Firmware downgrade *NOT SUPPORTED*\"\n\t\t\t\" from RDPQ mode to non RDPQ mode\\n\");\n\t\tret = 1;\n\t\tgoto fail_fw_init;\n\t}\n\n\tcur_intr_coalescing = (scratch_pad_1 & MR_INTR_COALESCING_SUPPORT_OFFSET) ?\n\t\t\t\t\t\t\ttrue : false;\n\n\tif ((instance->low_latency_index_start ==\n\t\tMR_HIGH_IOPS_QUEUE_COUNT) && cur_intr_coalescing)\n\t\tinstance->perf_mode = MR_BALANCED_PERF_MODE;\n\n\tdev_info(&instance->pdev->dev, \"Performance mode :%s (latency index = %d)\\n\",\n\t\tMEGASAS_PERF_MODE_2STR(instance->perf_mode),\n\t\tinstance->low_latency_index_start);\n\n\tinstance->fw_sync_cache_support = (scratch_pad_1 &\n\t\tMR_CAN_HANDLE_SYNC_CACHE_OFFSET) ? 1 : 0;\n\tdev_info(&instance->pdev->dev, \"FW supports sync cache\\t: %s\\n\",\n\t\t instance->fw_sync_cache_support ? \"Yes\" : \"No\");\n\n\tmemset(IOCInitMessage, 0, sizeof(struct MPI2_IOC_INIT_REQUEST));\n\n\tIOCInitMessage->Function = MPI2_FUNCTION_IOC_INIT;\n\tIOCInitMessage->WhoInit\t= MPI2_WHOINIT_HOST_DRIVER;\n\tIOCInitMessage->MsgVersion = cpu_to_le16(MPI2_VERSION);\n\tIOCInitMessage->HeaderVersion = cpu_to_le16(MPI2_HEADER_VERSION);\n\tIOCInitMessage->SystemRequestFrameSize = cpu_to_le16(MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE / 4);\n\n\tIOCInitMessage->ReplyDescriptorPostQueueDepth = cpu_to_le16(fusion->reply_q_depth);\n\tIOCInitMessage->ReplyDescriptorPostQueueAddress = instance->is_rdpq ?\n\t\t\tcpu_to_le64(fusion->rdpq_phys) :\n\t\t\tcpu_to_le64(fusion->reply_frames_desc_phys[0]);\n\tIOCInitMessage->MsgFlags = instance->is_rdpq ?\n\t\t\tMPI2_IOCINIT_MSGFLAG_RDPQ_ARRAY_MODE : 0;\n\tIOCInitMessage->SystemRequestFrameBaseAddress = cpu_to_le64(fusion->io_request_frames_phys);\n\tIOCInitMessage->SenseBufferAddressHigh = cpu_to_le32(upper_32_bits(fusion->sense_phys_addr));\n\tIOCInitMessage->HostMSIxVectors = instance->msix_vectors + instance->iopoll_q_count;\n\tIOCInitMessage->HostPageSize = MR_DEFAULT_NVME_PAGE_SHIFT;\n\n\ttime = ktime_get_real();\n\t \n\tIOCInitMessage->TimeStamp = cpu_to_le64(ktime_to_ms(time));\n\n\tinit_frame = (struct megasas_init_frame *)cmd->frame;\n\tmemset(init_frame, 0, IOC_INIT_FRAME_SIZE);\n\n\tframe_hdr = &cmd->frame->hdr;\n\tframe_hdr->cmd_status = 0xFF;\n\tframe_hdr->flags |= cpu_to_le16(MFI_FRAME_DONT_POST_IN_REPLY_QUEUE);\n\n\tinit_frame->cmd\t= MFI_CMD_INIT;\n\tinit_frame->cmd_status = 0xFF;\n\n\tdrv_ops = (MFI_CAPABILITIES *) &(init_frame->driver_operations);\n\n\t \n\tif (instance->adapter_type >= INVADER_SERIES)\n\t\tdrv_ops->mfi_capabilities.support_additional_msix = 1;\n\t \n\tdrv_ops->mfi_capabilities.support_fp_remote_lun = 1;\n\n\tdrv_ops->mfi_capabilities.support_max_255lds = 1;\n\tdrv_ops->mfi_capabilities.support_ndrive_r1_lb = 1;\n\tdrv_ops->mfi_capabilities.security_protocol_cmds_fw = 1;\n\n\tif (instance->max_chain_frame_sz > MEGASAS_CHAIN_FRAME_SZ_MIN)\n\t\tdrv_ops->mfi_capabilities.support_ext_io_size = 1;\n\n\tdrv_ops->mfi_capabilities.support_fp_rlbypass = 1;\n\tif (!dual_qdepth_disable)\n\t\tdrv_ops->mfi_capabilities.support_ext_queue_depth = 1;\n\n\tdrv_ops->mfi_capabilities.support_qd_throttling = 1;\n\tdrv_ops->mfi_capabilities.support_pd_map_target_id = 1;\n\tdrv_ops->mfi_capabilities.support_nvme_passthru = 1;\n\tdrv_ops->mfi_capabilities.support_fw_exposed_dev_list = 1;\n\n\tif (reset_devices)\n\t\tdrv_ops->mfi_capabilities.support_memdump = 1;\n\n\tif (instance->consistent_mask_64bit)\n\t\tdrv_ops->mfi_capabilities.support_64bit_mode = 1;\n\n\t \n\tcpu_to_le32s((u32 *)&init_frame->driver_operations.mfi_capabilities);\n\n\tsys_info = dmi_get_system_info(DMI_PRODUCT_UUID);\n\tif (instance->system_info_buf && sys_info) {\n\t\tmemcpy(instance->system_info_buf->systemId, sys_info,\n\t\t\tstrlen(sys_info) > 64 ? 64 : strlen(sys_info));\n\t\tinstance->system_info_buf->systemIdLength =\n\t\t\tstrlen(sys_info) > 64 ? 64 : strlen(sys_info);\n\t\tinit_frame->system_info_lo = cpu_to_le32(lower_32_bits(instance->system_info_h));\n\t\tinit_frame->system_info_hi = cpu_to_le32(upper_32_bits(instance->system_info_h));\n\t}\n\n\tinit_frame->queue_info_new_phys_addr_hi =\n\t\tcpu_to_le32(upper_32_bits(ioc_init_handle));\n\tinit_frame->queue_info_new_phys_addr_lo =\n\t\tcpu_to_le32(lower_32_bits(ioc_init_handle));\n\tinit_frame->data_xfer_len = cpu_to_le32(sizeof(struct MPI2_IOC_INIT_REQUEST));\n\n\t \n\tswitch (instance->perf_mode) {\n\tcase MR_BALANCED_PERF_MODE:\n\t\tinit_frame->replyqueue_mask =\n\t\t       cpu_to_le16(~(~0 << instance->low_latency_index_start/8));\n\t\tbreak;\n\tcase MR_IOPS_PERF_MODE:\n\t\tinit_frame->replyqueue_mask =\n\t\t       cpu_to_le16(~(~0 << instance->msix_vectors/8));\n\t\tbreak;\n\t}\n\n\n\treq_desc.u.low = cpu_to_le32(lower_32_bits(cmd->frame_phys_addr));\n\treq_desc.u.high = cpu_to_le32(upper_32_bits(cmd->frame_phys_addr));\n\treq_desc.MFAIo.RequestFlags =\n\t\t(MEGASAS_REQ_DESCRIPT_FLAGS_MFA <<\n\t\tMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\n\n\t \n\tinstance->instancet->disable_intr(instance);\n\n\tfor (i = 0; i < (10 * 1000); i += 20) {\n\t\tif (megasas_readl(instance, &instance->reg_set->doorbell) & 1)\n\t\t\tmsleep(20);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t \n\tmegasas_write_64bit_req_desc(instance, &req_desc);\n\n\twait_and_poll(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\n\tframe_hdr = &cmd->frame->hdr;\n\tif (frame_hdr->cmd_status != 0) {\n\t\tret = 1;\n\t\tgoto fail_fw_init;\n\t}\n\n\tif (instance->adapter_type >= AERO_SERIES) {\n\t\tscratch_pad_1 = megasas_readl\n\t\t\t(instance, &instance->reg_set->outbound_scratch_pad_1);\n\n\t\tinstance->atomic_desc_support =\n\t\t\t(scratch_pad_1 & MR_ATOMIC_DESCRIPTOR_SUPPORT_OFFSET) ? 1 : 0;\n\n\t\tdev_info(&instance->pdev->dev, \"FW supports atomic descriptor\\t: %s\\n\",\n\t\t\tinstance->atomic_desc_support ? \"Yes\" : \"No\");\n\t}\n\n\treturn 0;\n\nfail_fw_init:\n\tdev_err(&instance->pdev->dev,\n\t\t\"Init cmd return status FAILED for SCSI host %d\\n\",\n\t\tinstance->host->host_no);\n\n\treturn ret;\n}\n\n \nint\nmegasas_sync_pd_seq_num(struct megasas_instance *instance, bool pend) {\n\tint ret = 0;\n\tsize_t pd_seq_map_sz;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tstruct MR_PD_CFG_SEQ_NUM_SYNC *pd_sync;\n\tdma_addr_t pd_seq_h;\n\n\tpd_sync = (void *)fusion->pd_seq_sync[(instance->pd_seq_map_id & 1)];\n\tpd_seq_h = fusion->pd_seq_phys[(instance->pd_seq_map_id & 1)];\n\tpd_seq_map_sz = struct_size(pd_sync, seq, MAX_PHYSICAL_DEVICES);\n\n\tcmd = megasas_get_cmd(instance);\n\tif (!cmd) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Could not get mfi cmd. Fail from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(pd_sync, 0, pd_seq_map_sz);\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tif (pend) {\n\t\tdcmd->mbox.b[0] = MEGASAS_DCMD_MBOX_PEND_FLAG;\n\t\tdcmd->flags = MFI_FRAME_DIR_WRITE;\n\t\tinstance->jbod_seq_cmd = cmd;\n\t} else {\n\t\tdcmd->flags = MFI_FRAME_DIR_READ;\n\t}\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0xFF;\n\tdcmd->sge_count = 1;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(pd_seq_map_sz);\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_SYSTEM_PD_MAP_GET_INFO);\n\n\tmegasas_set_dma_settings(instance, dcmd, pd_seq_h, pd_seq_map_sz);\n\n\tif (pend) {\n\t\tinstance->instancet->issue_dcmd(instance, cmd);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\tMFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tif (le32_to_cpu(pd_sync->count) > MAX_PHYSICAL_DEVICES) {\n\t\tdev_warn(&instance->pdev->dev,\n\t\t\t\"driver supports max %d JBOD, but FW reports %d\\n\",\n\t\t\tMAX_PHYSICAL_DEVICES, le32_to_cpu(pd_sync->count));\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret == DCMD_TIMEOUT)\n\t\tdev_warn(&instance->pdev->dev,\n\t\t\t \"%s DCMD timed out, continue without JBOD sequence map\\n\",\n\t\t\t __func__);\n\n\tif (ret == DCMD_SUCCESS)\n\t\tinstance->pd_seq_map_id++;\n\n\tmegasas_return_cmd(instance, cmd);\n\treturn ret;\n}\n\n \nstatic int\nmegasas_get_ld_map_info(struct megasas_instance *instance)\n{\n\tint ret = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tvoid *ci;\n\tdma_addr_t ci_h = 0;\n\tu32 size_map_info;\n\tstruct fusion_context *fusion;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to get cmd for map info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfusion = instance->ctrl_context;\n\n\tif (!fusion) {\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn -ENXIO;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tsize_map_info = fusion->current_map_sz;\n\n\tci = (void *) fusion->ld_map[(instance->map_id & 1)];\n\tci_h = fusion->ld_map_phys[(instance->map_id & 1)];\n\n\tif (!ci) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to alloc mem for ld_map_info\\n\");\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ci, 0, fusion->max_map_sz);\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0xFF;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(size_map_info);\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_MAP_GET_INFO);\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h, size_map_info);\n\n\tif (!instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\tMFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tif (ret == DCMD_TIMEOUT)\n\t\tdev_warn(&instance->pdev->dev,\n\t\t\t \"%s DCMD timed out, RAID map is disabled\\n\",\n\t\t\t __func__);\n\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\nu8\nmegasas_get_map_info(struct megasas_instance *instance)\n{\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\tfusion->fast_path_io = 0;\n\tif (!megasas_get_ld_map_info(instance)) {\n\t\tif (MR_ValidateMapInfo(instance, instance->map_id)) {\n\t\t\tfusion->fast_path_io = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n \nint\nmegasas_sync_map_info(struct megasas_instance *instance)\n{\n\tint i;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tu16 num_lds;\n\tstruct fusion_context *fusion;\n\tstruct MR_LD_TARGET_SYNC *ci = NULL;\n\tstruct MR_DRV_RAID_MAP_ALL *map;\n\tstruct MR_LD_RAID  *raid;\n\tstruct MR_LD_TARGET_SYNC *ld_sync;\n\tdma_addr_t ci_h = 0;\n\tu32 size_map_info;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to get cmd for sync info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfusion = instance->ctrl_context;\n\n\tif (!fusion) {\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn 1;\n\t}\n\n\tmap = fusion->ld_drv_map[instance->map_id & 1];\n\n\tnum_lds = le16_to_cpu(map->raidMap.ldCount);\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tci = (struct MR_LD_TARGET_SYNC *)\n\t  fusion->ld_map[(instance->map_id - 1) & 1];\n\tmemset(ci, 0, fusion->max_map_sz);\n\n\tci_h = fusion->ld_map_phys[(instance->map_id - 1) & 1];\n\n\tld_sync = (struct MR_LD_TARGET_SYNC *)ci;\n\n\tfor (i = 0; i < num_lds; i++, ld_sync++) {\n\t\traid = MR_LdRaidGet(i, map);\n\t\tld_sync->targetId = MR_GetLDTgtId(i, map);\n\t\tld_sync->seqNum = raid->seqNum;\n\t}\n\n\tsize_map_info = fusion->current_map_sz;\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0xFF;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_WRITE;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(size_map_info);\n\tdcmd->mbox.b[0] = num_lds;\n\tdcmd->mbox.b[1] = MEGASAS_DCMD_MBOX_PEND_FLAG;\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_MAP_GET_INFO);\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h, size_map_info);\n\n\tinstance->map_update_cmd = cmd;\n\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\treturn 0;\n}\n\n \nstatic void\nmegasas_display_intel_branding(struct megasas_instance *instance)\n{\n\tif (instance->pdev->subsystem_vendor != PCI_VENDOR_ID_INTEL)\n\t\treturn;\n\n\tswitch (instance->pdev->device) {\n\tcase PCI_DEVICE_ID_LSI_INVADER:\n\t\tswitch (instance->pdev->subsystem_device) {\n\t\tcase MEGARAID_INTEL_RS3DC080_SSDID:\n\t\t\tdev_info(&instance->pdev->dev, \"scsi host %d: %s\\n\",\n\t\t\t\tinstance->host->host_no,\n\t\t\t\tMEGARAID_INTEL_RS3DC080_BRANDING);\n\t\t\tbreak;\n\t\tcase MEGARAID_INTEL_RS3DC040_SSDID:\n\t\t\tdev_info(&instance->pdev->dev, \"scsi host %d: %s\\n\",\n\t\t\t\tinstance->host->host_no,\n\t\t\t\tMEGARAID_INTEL_RS3DC040_BRANDING);\n\t\t\tbreak;\n\t\tcase MEGARAID_INTEL_RS3SC008_SSDID:\n\t\t\tdev_info(&instance->pdev->dev, \"scsi host %d: %s\\n\",\n\t\t\t\tinstance->host->host_no,\n\t\t\t\tMEGARAID_INTEL_RS3SC008_BRANDING);\n\t\t\tbreak;\n\t\tcase MEGARAID_INTEL_RS3MC044_SSDID:\n\t\t\tdev_info(&instance->pdev->dev, \"scsi host %d: %s\\n\",\n\t\t\t\tinstance->host->host_no,\n\t\t\t\tMEGARAID_INTEL_RS3MC044_BRANDING);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PCI_DEVICE_ID_LSI_FURY:\n\t\tswitch (instance->pdev->subsystem_device) {\n\t\tcase MEGARAID_INTEL_RS3WC080_SSDID:\n\t\t\tdev_info(&instance->pdev->dev, \"scsi host %d: %s\\n\",\n\t\t\t\tinstance->host->host_no,\n\t\t\t\tMEGARAID_INTEL_RS3WC080_BRANDING);\n\t\t\tbreak;\n\t\tcase MEGARAID_INTEL_RS3WC040_SSDID:\n\t\t\tdev_info(&instance->pdev->dev, \"scsi host %d: %s\\n\",\n\t\t\t\tinstance->host->host_no,\n\t\t\t\tMEGARAID_INTEL_RS3WC040_BRANDING);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PCI_DEVICE_ID_LSI_CUTLASS_52:\n\tcase PCI_DEVICE_ID_LSI_CUTLASS_53:\n\t\tswitch (instance->pdev->subsystem_device) {\n\t\tcase MEGARAID_INTEL_RMS3BC160_SSDID:\n\t\t\tdev_info(&instance->pdev->dev, \"scsi host %d: %s\\n\",\n\t\t\t\tinstance->host->host_no,\n\t\t\t\tMEGARAID_INTEL_RMS3BC160_BRANDING);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic inline int megasas_allocate_raid_maps(struct megasas_instance *instance)\n{\n\tstruct fusion_context *fusion;\n\tint i = 0;\n\n\tfusion = instance->ctrl_context;\n\n\tfusion->drv_map_pages = get_order(fusion->drv_map_sz);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tfusion->ld_map[i] = NULL;\n\n\t\tfusion->ld_drv_map[i] = (void *)\n\t\t\t__get_free_pages(__GFP_ZERO | GFP_KERNEL,\n\t\t\t\t\t fusion->drv_map_pages);\n\n\t\tif (!fusion->ld_drv_map[i]) {\n\t\t\tfusion->ld_drv_map[i] = vzalloc(fusion->drv_map_sz);\n\n\t\t\tif (!fusion->ld_drv_map[i]) {\n\t\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\t\"Could not allocate memory for local map\"\n\t\t\t\t\t\" size requested: %d\\n\",\n\t\t\t\t\tfusion->drv_map_sz);\n\t\t\t\tgoto ld_drv_map_alloc_fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tfusion->ld_map[i] = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t\t       fusion->max_map_sz,\n\t\t\t\t\t\t       &fusion->ld_map_phys[i],\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!fusion->ld_map[i]) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Could not allocate memory for map info %s:%d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tgoto ld_map_alloc_fail;\n\t\t}\n\t}\n\n\treturn 0;\n\nld_map_alloc_fail:\n\tfor (i = 0; i < 2; i++) {\n\t\tif (fusion->ld_map[i])\n\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\t  fusion->max_map_sz,\n\t\t\t\t\t  fusion->ld_map[i],\n\t\t\t\t\t  fusion->ld_map_phys[i]);\n\t}\n\nld_drv_map_alloc_fail:\n\tfor (i = 0; i < 2; i++) {\n\t\tif (fusion->ld_drv_map[i]) {\n\t\t\tif (is_vmalloc_addr(fusion->ld_drv_map[i]))\n\t\t\t\tvfree(fusion->ld_drv_map[i]);\n\t\t\telse\n\t\t\t\tfree_pages((ulong)fusion->ld_drv_map[i],\n\t\t\t\t\t   fusion->drv_map_pages);\n\t\t}\n\t}\n\n\treturn -ENOMEM;\n}\n\n \nstatic inline\nvoid megasas_configure_queue_sizes(struct megasas_instance *instance)\n{\n\tstruct fusion_context *fusion;\n\tu16 max_cmd;\n\n\tfusion = instance->ctrl_context;\n\tmax_cmd = instance->max_fw_cmds;\n\n\tif (instance->adapter_type >= VENTURA_SERIES)\n\t\tinstance->max_mpt_cmds = instance->max_fw_cmds * RAID_1_PEER_CMDS;\n\telse\n\t\tinstance->max_mpt_cmds = instance->max_fw_cmds;\n\n\tinstance->max_scsi_cmds = instance->max_fw_cmds - instance->max_mfi_cmds;\n\tinstance->cur_can_queue = instance->max_scsi_cmds;\n\tinstance->host->can_queue = instance->cur_can_queue;\n\n\tfusion->reply_q_depth = 2 * ((max_cmd + 1 + 15) / 16) * 16;\n\n\tfusion->request_alloc_sz = sizeof(union MEGASAS_REQUEST_DESCRIPTOR_UNION) *\n\t\t\t\t\t  instance->max_mpt_cmds;\n\tfusion->reply_alloc_sz = sizeof(union MPI2_REPLY_DESCRIPTORS_UNION) *\n\t\t\t\t\t(fusion->reply_q_depth);\n\tfusion->io_frames_alloc_sz = MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE +\n\t\t(MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE\n\t\t * (instance->max_mpt_cmds + 1));  \n}\n\nstatic int megasas_alloc_ioc_init_frame(struct megasas_instance *instance)\n{\n\tstruct fusion_context *fusion;\n\tstruct megasas_cmd *cmd;\n\n\tfusion = instance->ctrl_context;\n\n\tcmd = kzalloc(sizeof(struct megasas_cmd), GFP_KERNEL);\n\n\tif (!cmd) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from func: %s line: %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\tcmd->frame = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t\tIOC_INIT_FRAME_SIZE,\n\t\t\t\t\t&cmd->frame_phys_addr, GFP_KERNEL);\n\n\tif (!cmd->frame) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from func: %s line: %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\tkfree(cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tfusion->ioc_init_cmd = cmd;\n\treturn 0;\n}\n\n \nstatic inline void megasas_free_ioc_init_cmd(struct megasas_instance *instance)\n{\n\tstruct fusion_context *fusion;\n\n\tfusion = instance->ctrl_context;\n\n\tif (fusion->ioc_init_cmd && fusion->ioc_init_cmd->frame)\n\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t  IOC_INIT_FRAME_SIZE,\n\t\t\t\t  fusion->ioc_init_cmd->frame,\n\t\t\t\t  fusion->ioc_init_cmd->frame_phys_addr);\n\n\tkfree(fusion->ioc_init_cmd);\n}\n\n \nstatic u32\nmegasas_init_adapter_fusion(struct megasas_instance *instance)\n{\n\tstruct fusion_context *fusion;\n\tu32 scratch_pad_1;\n\tint i = 0, count;\n\tu32 status_reg;\n\n\tfusion = instance->ctrl_context;\n\n\tmegasas_fusion_update_can_queue(instance, PROBE_CONTEXT);\n\n\t \n\tinstance->max_mfi_cmds =\n\t\tMEGASAS_FUSION_INTERNAL_CMDS + MEGASAS_FUSION_IOCTL_CMDS;\n\n\tmegasas_configure_queue_sizes(instance);\n\n\tscratch_pad_1 = megasas_readl(instance,\n\t\t\t\t      &instance->reg_set->outbound_scratch_pad_1);\n\t \n\tif (scratch_pad_1 & MEGASAS_MAX_CHAIN_SIZE_UNITS_MASK)\n\t\tinstance->max_chain_frame_sz =\n\t\t\t((scratch_pad_1 & MEGASAS_MAX_CHAIN_SIZE_MASK) >>\n\t\t\tMEGASAS_MAX_CHAIN_SHIFT) * MEGASAS_1MB_IO;\n\telse\n\t\tinstance->max_chain_frame_sz =\n\t\t\t((scratch_pad_1 & MEGASAS_MAX_CHAIN_SIZE_MASK) >>\n\t\t\tMEGASAS_MAX_CHAIN_SHIFT) * MEGASAS_256K_IO;\n\n\tif (instance->max_chain_frame_sz < MEGASAS_CHAIN_FRAME_SZ_MIN) {\n\t\tdev_warn(&instance->pdev->dev, \"frame size %d invalid, fall back to legacy max frame size %d\\n\",\n\t\t\tinstance->max_chain_frame_sz,\n\t\t\tMEGASAS_CHAIN_FRAME_SZ_MIN);\n\t\tinstance->max_chain_frame_sz = MEGASAS_CHAIN_FRAME_SZ_MIN;\n\t}\n\n\tfusion->max_sge_in_main_msg =\n\t\t(MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE\n\t\t\t- offsetof(struct MPI2_RAID_SCSI_IO_REQUEST, SGL))/16;\n\n\tfusion->max_sge_in_chain =\n\t\tinstance->max_chain_frame_sz\n\t\t\t/ sizeof(union MPI2_SGE_IO_UNION);\n\n\tinstance->max_num_sge =\n\t\trounddown_pow_of_two(fusion->max_sge_in_main_msg\n\t\t\t+ fusion->max_sge_in_chain - 2);\n\n\t \n\tfusion->chain_offset_mfi_pthru =\n\t\toffsetof(struct MPI2_RAID_SCSI_IO_REQUEST, SGL)/16;\n\n\tfusion->chain_offset_io_request =\n\t\t(MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE -\n\t\t sizeof(union MPI2_SGE_IO_UNION))/16;\n\n\tcount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\n\tcount += instance->iopoll_q_count;\n\n\tfor (i = 0 ; i < count; i++)\n\t\tfusion->last_reply_idx[i] = 0;\n\n\t \n\tinstance->max_scsi_cmds = instance->max_fw_cmds -\n\t\t\t\t(MEGASAS_FUSION_INTERNAL_CMDS +\n\t\t\t\tMEGASAS_FUSION_IOCTL_CMDS);\n\tsema_init(&instance->ioctl_sem, MEGASAS_FUSION_IOCTL_CMDS);\n\n\tfor (i = 0; i < MAX_MSIX_QUEUES_FUSION; i++)\n\t\tatomic_set(&fusion->busy_mq_poll[i], 0);\n\n\tif (megasas_alloc_ioc_init_frame(instance))\n\t\treturn 1;\n\n\t \n\tif (megasas_alloc_cmds(instance))\n\t\tgoto fail_alloc_mfi_cmds;\n\tif (megasas_alloc_cmds_fusion(instance))\n\t\tgoto fail_alloc_cmds;\n\n\tif (megasas_ioc_init_fusion(instance)) {\n\t\tstatus_reg = instance->instancet->read_fw_status_reg(instance);\n\t\tif (((status_reg & MFI_STATE_MASK) == MFI_STATE_FAULT) &&\n\t\t    (status_reg & MFI_RESET_ADAPTER)) {\n\t\t\t \n\t\t\tif (megasas_adp_reset_wait_for_ready\n\t\t\t\t(instance, true, 0) == FAILED)\n\t\t\t\tgoto fail_ioc_init;\n\n\t\t\tif (megasas_ioc_init_fusion(instance))\n\t\t\t\tgoto fail_ioc_init;\n\t\t} else {\n\t\t\tgoto fail_ioc_init;\n\t\t}\n\t}\n\n\tmegasas_display_intel_branding(instance);\n\tif (megasas_get_ctrl_info(instance)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Could not get controller info. Fail from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\tgoto fail_ioc_init;\n\t}\n\n\tinstance->flag_ieee = 1;\n\tinstance->r1_ldio_hint_default =  MR_R1_LDIO_PIGGYBACK_DEFAULT;\n\tinstance->threshold_reply_count = instance->max_fw_cmds / 4;\n\tfusion->fast_path_io = 0;\n\n\tif (megasas_allocate_raid_maps(instance))\n\t\tgoto fail_ioc_init;\n\n\tif (!megasas_get_map_info(instance))\n\t\tmegasas_sync_map_info(instance);\n\n\treturn 0;\n\nfail_ioc_init:\n\tmegasas_free_cmds_fusion(instance);\nfail_alloc_cmds:\n\tmegasas_free_cmds(instance);\nfail_alloc_mfi_cmds:\n\tmegasas_free_ioc_init_cmd(instance);\n\treturn 1;\n}\n\n \nstatic void\nmegasas_fault_detect_work(struct work_struct *work)\n{\n\tstruct megasas_instance *instance =\n\t\tcontainer_of(work, struct megasas_instance,\n\t\t\t     fw_fault_work.work);\n\tu32 fw_state, dma_state, status;\n\n\t \n\tfw_state = instance->instancet->read_fw_status_reg(instance) &\n\t\t\tMFI_STATE_MASK;\n\n\tif (fw_state == MFI_STATE_FAULT) {\n\t\tdma_state = instance->instancet->read_fw_status_reg(instance) &\n\t\t\t\tMFI_STATE_DMADONE;\n\t\t \n\t\tif (instance->crash_dump_drv_support &&\n\t\t    instance->crash_dump_app_support && dma_state) {\n\t\t\tmegasas_fusion_crash_dump(instance);\n\t\t} else {\n\t\t\tif (instance->unload == 0) {\n\t\t\t\tstatus = megasas_reset_fusion(instance->host, 0);\n\t\t\t\tif (status != SUCCESS) {\n\t\t\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\t\t\"Failed from %s %d, do not re-arm timer\\n\",\n\t\t\t\t\t\t__func__, __LINE__);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (instance->fw_fault_work_q)\n\t\tqueue_delayed_work(instance->fw_fault_work_q,\n\t\t\t&instance->fw_fault_work,\n\t\t\tmsecs_to_jiffies(MEGASAS_WATCHDOG_THREAD_INTERVAL));\n}\n\nint\nmegasas_fusion_start_watchdog(struct megasas_instance *instance)\n{\n\t \n\tif (instance->fw_fault_work_q)\n\t\treturn SUCCESS;\n\n\tINIT_DELAYED_WORK(&instance->fw_fault_work, megasas_fault_detect_work);\n\n\tsnprintf(instance->fault_handler_work_q_name,\n\t\t sizeof(instance->fault_handler_work_q_name),\n\t\t \"poll_megasas%d_status\", instance->host->host_no);\n\n\tinstance->fw_fault_work_q =\n\t\tcreate_singlethread_workqueue(instance->fault_handler_work_q_name);\n\tif (!instance->fw_fault_work_q) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn FAILED;\n\t}\n\n\tqueue_delayed_work(instance->fw_fault_work_q,\n\t\t\t   &instance->fw_fault_work,\n\t\t\t   msecs_to_jiffies(MEGASAS_WATCHDOG_THREAD_INTERVAL));\n\n\treturn SUCCESS;\n}\n\nvoid\nmegasas_fusion_stop_watchdog(struct megasas_instance *instance)\n{\n\tstruct workqueue_struct *wq;\n\n\tif (instance->fw_fault_work_q) {\n\t\twq = instance->fw_fault_work_q;\n\t\tinstance->fw_fault_work_q = NULL;\n\t\tif (!cancel_delayed_work_sync(&instance->fw_fault_work))\n\t\t\tflush_workqueue(wq);\n\t\tdestroy_workqueue(wq);\n\t}\n}\n\n \nstatic void\nmap_cmd_status(struct fusion_context *fusion,\n\t\tstruct scsi_cmnd *scmd, u8 status, u8 ext_status,\n\t\tu32 data_length, u8 *sense)\n{\n\tu8 cmd_type;\n\tint resid;\n\n\tcmd_type = megasas_cmd_type(scmd);\n\tswitch (status) {\n\n\tcase MFI_STAT_OK:\n\t\tscmd->result = DID_OK << 16;\n\t\tbreak;\n\n\tcase MFI_STAT_SCSI_IO_FAILED:\n\tcase MFI_STAT_LD_INIT_IN_PROGRESS:\n\t\tscmd->result = (DID_ERROR << 16) | ext_status;\n\t\tbreak;\n\n\tcase MFI_STAT_SCSI_DONE_WITH_ERROR:\n\n\t\tscmd->result = (DID_OK << 16) | ext_status;\n\t\tif (ext_status == SAM_STAT_CHECK_CONDITION) {\n\t\t\tmemcpy(scmd->sense_buffer, sense,\n\t\t\t       SCSI_SENSE_BUFFERSIZE);\n\t\t}\n\n\t\t \n\t\tresid = (scsi_bufflen(scmd) - data_length);\n\t\tscsi_set_resid(scmd, resid);\n\n\t\tif (resid &&\n\t\t\t((cmd_type == READ_WRITE_LDIO) ||\n\t\t\t(cmd_type == READ_WRITE_SYSPDIO)))\n\t\t\tscmd_printk(KERN_INFO, scmd, \"BRCM Debug mfi stat 0x%x, data len\"\n\t\t\t\t\" requested/completed 0x%x/0x%x\\n\",\n\t\t\t\tstatus, scsi_bufflen(scmd), data_length);\n\t\tbreak;\n\n\tcase MFI_STAT_LD_OFFLINE:\n\tcase MFI_STAT_DEVICE_NOT_FOUND:\n\t\tscmd->result = DID_BAD_TARGET << 16;\n\t\tbreak;\n\tcase MFI_STAT_CONFIG_SEQ_MISMATCH:\n\t\tscmd->result = DID_IMM_RETRY << 16;\n\t\tbreak;\n\tdefault:\n\t\tscmd->result = DID_ERROR << 16;\n\t\tbreak;\n\t}\n}\n\n \nstatic bool\nmegasas_is_prp_possible(struct megasas_instance *instance,\n\t\t\tstruct scsi_cmnd *scmd, int sge_count)\n{\n\tu32 data_length = 0;\n\tstruct scatterlist *sg_scmd;\n\tbool build_prp = false;\n\tu32 mr_nvme_pg_size;\n\n\tmr_nvme_pg_size = max_t(u32, instance->nvme_page_size,\n\t\t\t\tMR_DEFAULT_NVME_PAGE_SIZE);\n\tdata_length = scsi_bufflen(scmd);\n\tsg_scmd = scsi_sglist(scmd);\n\n\t \n\n\tif (data_length > (mr_nvme_pg_size * 5)) {\n\t\tbuild_prp = true;\n\t} else if ((data_length > (mr_nvme_pg_size * 4)) &&\n\t\t\t(data_length <= (mr_nvme_pg_size * 5)))  {\n\t\t \n\t\tif (sg_dma_len(sg_scmd) < (data_length - (mr_nvme_pg_size * 4)))\n\t\t\tbuild_prp = true;\n\t}\n\n\treturn build_prp;\n}\n\n \nstatic bool\nmegasas_make_prp_nvme(struct megasas_instance *instance, struct scsi_cmnd *scmd,\n\t\t      struct MPI25_IEEE_SGE_CHAIN64 *sgl_ptr,\n\t\t      struct megasas_cmd_fusion *cmd, int sge_count)\n{\n\tint sge_len, offset, num_prp_in_chain = 0;\n\tstruct MPI25_IEEE_SGE_CHAIN64 *main_chain_element, *ptr_first_sgl;\n\tu64 *ptr_sgl;\n\tdma_addr_t ptr_sgl_phys;\n\tu64 sge_addr;\n\tu32 page_mask, page_mask_result;\n\tstruct scatterlist *sg_scmd;\n\tu32 first_prp_len;\n\tbool build_prp = false;\n\tint data_len = scsi_bufflen(scmd);\n\tu32 mr_nvme_pg_size = max_t(u32, instance->nvme_page_size,\n\t\t\t\t\tMR_DEFAULT_NVME_PAGE_SIZE);\n\n\tbuild_prp = megasas_is_prp_possible(instance, scmd, sge_count);\n\n\tif (!build_prp)\n\t\treturn false;\n\n\t \n\tpage_mask = mr_nvme_pg_size - 1;\n\tptr_sgl = (u64 *)cmd->sg_frame;\n\tptr_sgl_phys = cmd->sg_frame_phys_addr;\n\tmemset(ptr_sgl, 0, instance->max_chain_frame_sz);\n\n\t \n\tmain_chain_element = (struct MPI25_IEEE_SGE_CHAIN64 *)\n\t    ((u8 *)sgl_ptr + sizeof(struct MPI25_IEEE_SGE_CHAIN64));\n\n\tmain_chain_element->Address = cpu_to_le64(ptr_sgl_phys);\n\tmain_chain_element->NextChainOffset = 0;\n\tmain_chain_element->Flags = IEEE_SGE_FLAGS_CHAIN_ELEMENT |\n\t\t\t\t\tIEEE_SGE_FLAGS_SYSTEM_ADDR |\n\t\t\t\t\tMPI26_IEEE_SGE_FLAGS_NSF_NVME_PRP;\n\n\t \n\tptr_first_sgl = sgl_ptr;\n\tsg_scmd = scsi_sglist(scmd);\n\tsge_addr = sg_dma_address(sg_scmd);\n\tsge_len = sg_dma_len(sg_scmd);\n\n\toffset = (u32)(sge_addr & page_mask);\n\tfirst_prp_len = mr_nvme_pg_size - offset;\n\n\tptr_first_sgl->Address = cpu_to_le64(sge_addr);\n\tptr_first_sgl->Length = cpu_to_le32(first_prp_len);\n\n\tdata_len -= first_prp_len;\n\n\tif (sge_len > first_prp_len) {\n\t\tsge_addr += first_prp_len;\n\t\tsge_len -= first_prp_len;\n\t} else if (sge_len == first_prp_len) {\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsge_addr = sg_dma_address(sg_scmd);\n\t\tsge_len = sg_dma_len(sg_scmd);\n\t}\n\n\tfor (;;) {\n\t\toffset = (u32)(sge_addr & page_mask);\n\n\t\t \n\t\tpage_mask_result = (uintptr_t)(ptr_sgl + 1) & page_mask;\n\t\tif (unlikely(!page_mask_result)) {\n\t\t\tscmd_printk(KERN_NOTICE,\n\t\t\t\t    scmd, \"page boundary ptr_sgl: 0x%p\\n\",\n\t\t\t\t    ptr_sgl);\n\t\t\tptr_sgl_phys += 8;\n\t\t\t*ptr_sgl = cpu_to_le64(ptr_sgl_phys);\n\t\t\tptr_sgl++;\n\t\t\tnum_prp_in_chain++;\n\t\t}\n\n\t\t*ptr_sgl = cpu_to_le64(sge_addr);\n\t\tptr_sgl++;\n\t\tptr_sgl_phys += 8;\n\t\tnum_prp_in_chain++;\n\n\t\tsge_addr += mr_nvme_pg_size;\n\t\tsge_len -= mr_nvme_pg_size;\n\t\tdata_len -= mr_nvme_pg_size;\n\n\t\tif (data_len <= 0)\n\t\t\tbreak;\n\n\t\tif (sge_len > 0)\n\t\t\tcontinue;\n\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsge_addr = sg_dma_address(sg_scmd);\n\t\tsge_len = sg_dma_len(sg_scmd);\n\t}\n\n\tmain_chain_element->Length =\n\t\t\tcpu_to_le32(num_prp_in_chain * sizeof(u64));\n\n\treturn build_prp;\n}\n\n \nstatic void\nmegasas_make_sgl_fusion(struct megasas_instance *instance,\n\t\t\tstruct scsi_cmnd *scp,\n\t\t\tstruct MPI25_IEEE_SGE_CHAIN64 *sgl_ptr,\n\t\t\tstruct megasas_cmd_fusion *cmd, int sge_count)\n{\n\tint i, sg_processed;\n\tstruct scatterlist *os_sgl;\n\tstruct fusion_context *fusion;\n\n\tfusion = instance->ctrl_context;\n\n\tif (instance->adapter_type >= INVADER_SERIES) {\n\t\tstruct MPI25_IEEE_SGE_CHAIN64 *sgl_ptr_end = sgl_ptr;\n\t\tsgl_ptr_end += fusion->max_sge_in_main_msg - 1;\n\t\tsgl_ptr_end->Flags = 0;\n\t}\n\n\tscsi_for_each_sg(scp, os_sgl, sge_count, i) {\n\t\tsgl_ptr->Length = cpu_to_le32(sg_dma_len(os_sgl));\n\t\tsgl_ptr->Address = cpu_to_le64(sg_dma_address(os_sgl));\n\t\tsgl_ptr->Flags = 0;\n\t\tif (instance->adapter_type >= INVADER_SERIES)\n\t\t\tif (i == sge_count - 1)\n\t\t\t\tsgl_ptr->Flags = IEEE_SGE_FLAGS_END_OF_LIST;\n\t\tsgl_ptr++;\n\t\tsg_processed = i + 1;\n\n\t\tif ((sg_processed ==  (fusion->max_sge_in_main_msg - 1)) &&\n\t\t    (sge_count > fusion->max_sge_in_main_msg)) {\n\n\t\t\tstruct MPI25_IEEE_SGE_CHAIN64 *sg_chain;\n\t\t\tif (instance->adapter_type >= INVADER_SERIES) {\n\t\t\t\tif ((le16_to_cpu(cmd->io_request->IoFlags) &\n\t\t\t\t\tMPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH) !=\n\t\t\t\t\tMPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH)\n\t\t\t\t\tcmd->io_request->ChainOffset =\n\t\t\t\t\t\tfusion->\n\t\t\t\t\t\tchain_offset_io_request;\n\t\t\t\telse\n\t\t\t\t\tcmd->io_request->ChainOffset = 0;\n\t\t\t} else\n\t\t\t\tcmd->io_request->ChainOffset =\n\t\t\t\t\tfusion->chain_offset_io_request;\n\n\t\t\tsg_chain = sgl_ptr;\n\t\t\t \n\t\t\tsg_chain->NextChainOffset = 0;\n\t\t\tif (instance->adapter_type >= INVADER_SERIES)\n\t\t\t\tsg_chain->Flags = IEEE_SGE_FLAGS_CHAIN_ELEMENT;\n\t\t\telse\n\t\t\t\tsg_chain->Flags =\n\t\t\t\t\t(IEEE_SGE_FLAGS_CHAIN_ELEMENT |\n\t\t\t\t\t MPI2_IEEE_SGE_FLAGS_IOCPLBNTA_ADDR);\n\t\t\tsg_chain->Length =  cpu_to_le32((sizeof(union MPI2_SGE_IO_UNION) * (sge_count - sg_processed)));\n\t\t\tsg_chain->Address = cpu_to_le64(cmd->sg_frame_phys_addr);\n\n\t\t\tsgl_ptr =\n\t\t\t  (struct MPI25_IEEE_SGE_CHAIN64 *)cmd->sg_frame;\n\t\t\tmemset(sgl_ptr, 0, instance->max_chain_frame_sz);\n\t\t}\n\t}\n}\n\n \nstatic\nint megasas_make_sgl(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t     struct megasas_cmd_fusion *cmd)\n{\n\tint sge_count;\n\tbool build_prp = false;\n\tstruct MPI25_IEEE_SGE_CHAIN64 *sgl_chain64;\n\n\tsge_count = scsi_dma_map(scp);\n\n\tif ((sge_count > instance->max_num_sge) || (sge_count <= 0))\n\t\treturn sge_count;\n\n\tsgl_chain64 = (struct MPI25_IEEE_SGE_CHAIN64 *)&cmd->io_request->SGL;\n\tif ((le16_to_cpu(cmd->io_request->IoFlags) &\n\t    MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH) &&\n\t    (cmd->pd_interface == NVME_PD))\n\t\tbuild_prp = megasas_make_prp_nvme(instance, scp, sgl_chain64,\n\t\t\t\t\t\t  cmd, sge_count);\n\n\tif (!build_prp)\n\t\tmegasas_make_sgl_fusion(instance, scp, sgl_chain64,\n\t\t\t\t\tcmd, sge_count);\n\n\treturn sge_count;\n}\n\n \nstatic void\nmegasas_set_pd_lba(struct MPI2_RAID_SCSI_IO_REQUEST *io_request, u8 cdb_len,\n\t\t   struct IO_REQUEST_INFO *io_info, struct scsi_cmnd *scp,\n\t\t   struct MR_DRV_RAID_MAP_ALL *local_map_ptr, u32 ref_tag)\n{\n\tstruct MR_LD_RAID *raid;\n\tu16 ld;\n\tu64 start_blk = io_info->pdBlock;\n\tu8 *cdb = io_request->CDB.CDB32;\n\tu32 num_blocks = io_info->numBlocks;\n\tu8 opcode = 0, flagvals = 0, groupnum = 0, control = 0;\n\n\t \n\tld = MR_TargetIdToLdGet(io_info->ldTgtId, local_map_ptr);\n\traid = MR_LdRaidGet(ld, local_map_ptr);\n\tif (raid->capability.ldPiMode == MR_PROT_INFO_TYPE_CONTROLLER) {\n\t\tmemset(cdb, 0, sizeof(io_request->CDB.CDB32));\n\t\tcdb[0] =  MEGASAS_SCSI_VARIABLE_LENGTH_CMD;\n\t\tcdb[7] =  MEGASAS_SCSI_ADDL_CDB_LEN;\n\n\t\tif (scp->sc_data_direction == DMA_FROM_DEVICE)\n\t\t\tcdb[9] = MEGASAS_SCSI_SERVICE_ACTION_READ32;\n\t\telse\n\t\t\tcdb[9] = MEGASAS_SCSI_SERVICE_ACTION_WRITE32;\n\t\tcdb[10] = MEGASAS_RD_WR_PROTECT_CHECK_ALL;\n\n\t\t \n\t\tcdb[12] = (u8)((start_blk >> 56) & 0xff);\n\t\tcdb[13] = (u8)((start_blk >> 48) & 0xff);\n\t\tcdb[14] = (u8)((start_blk >> 40) & 0xff);\n\t\tcdb[15] = (u8)((start_blk >> 32) & 0xff);\n\t\tcdb[16] = (u8)((start_blk >> 24) & 0xff);\n\t\tcdb[17] = (u8)((start_blk >> 16) & 0xff);\n\t\tcdb[18] = (u8)((start_blk >> 8) & 0xff);\n\t\tcdb[19] = (u8)(start_blk & 0xff);\n\n\t\t \n\t\tio_request->CDB.EEDP32.PrimaryReferenceTag =\n\t\t\tcpu_to_be32(ref_tag);\n\t\tio_request->CDB.EEDP32.PrimaryApplicationTagMask = cpu_to_be16(0xffff);\n\t\tio_request->IoFlags = cpu_to_le16(32);  \n\n\t\t \n\t\tcdb[28] = (u8)((num_blocks >> 24) & 0xff);\n\t\tcdb[29] = (u8)((num_blocks >> 16) & 0xff);\n\t\tcdb[30] = (u8)((num_blocks >> 8) & 0xff);\n\t\tcdb[31] = (u8)(num_blocks & 0xff);\n\n\t\t \n\t\tif (scp->sc_data_direction == DMA_FROM_DEVICE) {\n\t\t\tio_request->EEDPFlags = cpu_to_le16(\n\t\t\t\tMPI2_SCSIIO_EEDPFLAGS_INC_PRI_REFTAG  |\n\t\t\t\tMPI2_SCSIIO_EEDPFLAGS_CHECK_REFTAG |\n\t\t\t\tMPI2_SCSIIO_EEDPFLAGS_CHECK_REMOVE_OP |\n\t\t\t\tMPI2_SCSIIO_EEDPFLAGS_CHECK_APPTAG |\n\t\t\t\tMPI25_SCSIIO_EEDPFLAGS_DO_NOT_DISABLE_MODE |\n\t\t\t\tMPI2_SCSIIO_EEDPFLAGS_CHECK_GUARD);\n\t\t} else {\n\t\t\tio_request->EEDPFlags = cpu_to_le16(\n\t\t\t\tMPI2_SCSIIO_EEDPFLAGS_INC_PRI_REFTAG |\n\t\t\t\tMPI2_SCSIIO_EEDPFLAGS_INSERT_OP);\n\t\t}\n\t\tio_request->Control |= cpu_to_le32((0x4 << 26));\n\t\tio_request->EEDPBlockSize = cpu_to_le32(scp->device->sector_size);\n\t} else {\n\t\t \n\t\tif (((cdb_len == 12) || (cdb_len == 16)) &&\n\t\t    (start_blk <= 0xffffffff)) {\n\t\t\tif (cdb_len == 16) {\n\t\t\t\topcode = cdb[0] == READ_16 ? READ_10 : WRITE_10;\n\t\t\t\tflagvals = cdb[1];\n\t\t\t\tgroupnum = cdb[14];\n\t\t\t\tcontrol = cdb[15];\n\t\t\t} else {\n\t\t\t\topcode = cdb[0] == READ_12 ? READ_10 : WRITE_10;\n\t\t\t\tflagvals = cdb[1];\n\t\t\t\tgroupnum = cdb[10];\n\t\t\t\tcontrol = cdb[11];\n\t\t\t}\n\n\t\t\tmemset(cdb, 0, sizeof(io_request->CDB.CDB32));\n\n\t\t\tcdb[0] = opcode;\n\t\t\tcdb[1] = flagvals;\n\t\t\tcdb[6] = groupnum;\n\t\t\tcdb[9] = control;\n\n\t\t\t \n\t\t\tcdb[8] = (u8)(num_blocks & 0xff);\n\t\t\tcdb[7] = (u8)((num_blocks >> 8) & 0xff);\n\n\t\t\tio_request->IoFlags = cpu_to_le16(10);  \n\t\t\tcdb_len = 10;\n\t\t} else if ((cdb_len < 16) && (start_blk > 0xffffffff)) {\n\t\t\t \n\t\t\tswitch (cdb_len) {\n\t\t\tcase 6:\n\t\t\t\topcode = cdb[0] == READ_6 ? READ_16 : WRITE_16;\n\t\t\t\tcontrol = cdb[5];\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\topcode =\n\t\t\t\t\tcdb[0] == READ_10 ? READ_16 : WRITE_16;\n\t\t\t\tflagvals = cdb[1];\n\t\t\t\tgroupnum = cdb[6];\n\t\t\t\tcontrol = cdb[9];\n\t\t\t\tbreak;\n\t\t\tcase 12:\n\t\t\t\topcode =\n\t\t\t\t\tcdb[0] == READ_12 ? READ_16 : WRITE_16;\n\t\t\t\tflagvals = cdb[1];\n\t\t\t\tgroupnum = cdb[10];\n\t\t\t\tcontrol = cdb[11];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemset(cdb, 0, sizeof(io_request->CDB.CDB32));\n\n\t\t\tcdb[0] = opcode;\n\t\t\tcdb[1] = flagvals;\n\t\t\tcdb[14] = groupnum;\n\t\t\tcdb[15] = control;\n\n\t\t\t \n\t\t\tcdb[13] = (u8)(num_blocks & 0xff);\n\t\t\tcdb[12] = (u8)((num_blocks >> 8) & 0xff);\n\t\t\tcdb[11] = (u8)((num_blocks >> 16) & 0xff);\n\t\t\tcdb[10] = (u8)((num_blocks >> 24) & 0xff);\n\n\t\t\tio_request->IoFlags = cpu_to_le16(16);  \n\t\t\tcdb_len = 16;\n\t\t}\n\n\t\t \n\t\tswitch (cdb_len) {\n\t\tcase 6:\n\t\t{\n\t\t\tu8 val = cdb[1] & 0xE0;\n\t\t\tcdb[3] = (u8)(start_blk & 0xff);\n\t\t\tcdb[2] = (u8)((start_blk >> 8) & 0xff);\n\t\t\tcdb[1] = val | ((u8)(start_blk >> 16) & 0x1f);\n\t\t\tbreak;\n\t\t}\n\t\tcase 10:\n\t\t\tcdb[5] = (u8)(start_blk & 0xff);\n\t\t\tcdb[4] = (u8)((start_blk >> 8) & 0xff);\n\t\t\tcdb[3] = (u8)((start_blk >> 16) & 0xff);\n\t\t\tcdb[2] = (u8)((start_blk >> 24) & 0xff);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tcdb[5]    = (u8)(start_blk & 0xff);\n\t\t\tcdb[4]    = (u8)((start_blk >> 8) & 0xff);\n\t\t\tcdb[3]    = (u8)((start_blk >> 16) & 0xff);\n\t\t\tcdb[2]    = (u8)((start_blk >> 24) & 0xff);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tcdb[9]    = (u8)(start_blk & 0xff);\n\t\t\tcdb[8]    = (u8)((start_blk >> 8) & 0xff);\n\t\t\tcdb[7]    = (u8)((start_blk >> 16) & 0xff);\n\t\t\tcdb[6]    = (u8)((start_blk >> 24) & 0xff);\n\t\t\tcdb[5]    = (u8)((start_blk >> 32) & 0xff);\n\t\t\tcdb[4]    = (u8)((start_blk >> 40) & 0xff);\n\t\t\tcdb[3]    = (u8)((start_blk >> 48) & 0xff);\n\t\t\tcdb[2]    = (u8)((start_blk >> 56) & 0xff);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \n\n \nstatic void megasas_stream_detect(struct megasas_instance *instance,\n\t\t\t\t  struct megasas_cmd_fusion *cmd,\n\t\t\t\t  struct IO_REQUEST_INFO *io_info)\n{\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tu32 device_id = io_info->ldTgtId;\n\tstruct LD_STREAM_DETECT *current_ld_sd\n\t\t= fusion->stream_detect_by_ld[device_id];\n\tu32 *track_stream = &current_ld_sd->mru_bit_map, stream_num;\n\tu32 shifted_values, unshifted_values;\n\tu32 index_value_mask, shifted_values_mask;\n\tint i;\n\tbool is_read_ahead = false;\n\tstruct STREAM_DETECT *current_sd;\n\t \n\tfor (i = 0; i < MAX_STREAMS_TRACKED; ++i) {\n\t\tstream_num = (*track_stream >>\n\t\t\t(i * BITS_PER_INDEX_STREAM)) &\n\t\t\tSTREAM_MASK;\n\t\tcurrent_sd = &current_ld_sd->stream_track[stream_num];\n\t\t \n\t\t \n\t\tif ((current_sd->next_seq_lba) &&\n\t\t    (io_info->ldStartBlock >= current_sd->next_seq_lba) &&\n\t\t    (io_info->ldStartBlock <= (current_sd->next_seq_lba + 32)) &&\n\t\t    (current_sd->is_read == io_info->isRead)) {\n\n\t\t\tif ((io_info->ldStartBlock != current_sd->next_seq_lba)\t&&\n\t\t\t    ((!io_info->isRead) || (!is_read_ahead)))\n\t\t\t\t \n\t\t\t\tcontinue;\n\n\t\t\tSET_STREAM_DETECTED(cmd->io_request->RaidContext.raid_context_g35);\n\t\t\tcurrent_sd->next_seq_lba =\n\t\t\tio_info->ldStartBlock + io_info->numBlocks;\n\t\t\t \n\t\t\tshifted_values_mask =\n\t\t\t\t(1 <<  i * BITS_PER_INDEX_STREAM) - 1;\n\t\t\tshifted_values = ((*track_stream & shifted_values_mask)\n\t\t\t\t\t\t<< BITS_PER_INDEX_STREAM);\n\t\t\tindex_value_mask =\n\t\t\t\tSTREAM_MASK << i * BITS_PER_INDEX_STREAM;\n\t\t\tunshifted_values =\n\t\t\t\t*track_stream & ~(shifted_values_mask |\n\t\t\t\tindex_value_mask);\n\t\t\t*track_stream =\n\t\t\t\tunshifted_values | shifted_values | stream_num;\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\tstream_num = (*track_stream >>\n\t\t((MAX_STREAMS_TRACKED - 1) * BITS_PER_INDEX_STREAM)) &\n\t\tSTREAM_MASK;\n\tcurrent_sd = &current_ld_sd->stream_track[stream_num];\n\tcurrent_sd->is_read = io_info->isRead;\n\tcurrent_sd->next_seq_lba = io_info->ldStartBlock + io_info->numBlocks;\n\t*track_stream = (((*track_stream & ZERO_LAST_STREAM) << 4) | stream_num);\n\treturn;\n}\n\n \nstatic void\nmegasas_set_raidflag_cpu_affinity(struct fusion_context *fusion,\n\t\t\t\tunion RAID_CONTEXT_UNION *praid_context,\n\t\t\t\tstruct MR_LD_RAID *raid, bool fp_possible,\n\t\t\t\tu8 is_read, u32 scsi_buff_len)\n{\n\tu8 cpu_sel = MR_RAID_CTX_CPUSEL_0;\n\tstruct RAID_CONTEXT_G35 *rctx_g35;\n\n\trctx_g35 = &praid_context->raid_context_g35;\n\tif (fp_possible) {\n\t\tif (is_read) {\n\t\t\tif ((raid->cpuAffinity.pdRead.cpu0) &&\n\t\t\t    (raid->cpuAffinity.pdRead.cpu1))\n\t\t\t\tcpu_sel = MR_RAID_CTX_CPUSEL_FCFS;\n\t\t\telse if (raid->cpuAffinity.pdRead.cpu1)\n\t\t\t\tcpu_sel = MR_RAID_CTX_CPUSEL_1;\n\t\t} else {\n\t\t\tif ((raid->cpuAffinity.pdWrite.cpu0) &&\n\t\t\t    (raid->cpuAffinity.pdWrite.cpu1))\n\t\t\t\tcpu_sel = MR_RAID_CTX_CPUSEL_FCFS;\n\t\t\telse if (raid->cpuAffinity.pdWrite.cpu1)\n\t\t\t\tcpu_sel = MR_RAID_CTX_CPUSEL_1;\n\t\t\t \n\t\t\tif ((raid->level <= 1) &&\n\t\t\t    (raid->capability.fp_cache_bypass_capable)) {\n\t\t\t\trctx_g35->routing_flags |=\n\t\t\t\t\t(1 << MR_RAID_CTX_ROUTINGFLAGS_SLD_SHIFT);\n\t\t\t\trctx_g35->raid_flags =\n\t\t\t\t\t(MR_RAID_FLAGS_IO_SUB_TYPE_CACHE_BYPASS\n\t\t\t\t\t<< MR_RAID_CTX_RAID_FLAGS_IO_SUB_TYPE_SHIFT);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (is_read) {\n\t\t\tif ((raid->cpuAffinity.ldRead.cpu0) &&\n\t\t\t    (raid->cpuAffinity.ldRead.cpu1))\n\t\t\t\tcpu_sel = MR_RAID_CTX_CPUSEL_FCFS;\n\t\t\telse if (raid->cpuAffinity.ldRead.cpu1)\n\t\t\t\tcpu_sel = MR_RAID_CTX_CPUSEL_1;\n\t\t} else {\n\t\t\tif ((raid->cpuAffinity.ldWrite.cpu0) &&\n\t\t\t    (raid->cpuAffinity.ldWrite.cpu1))\n\t\t\t\tcpu_sel = MR_RAID_CTX_CPUSEL_FCFS;\n\t\t\telse if (raid->cpuAffinity.ldWrite.cpu1)\n\t\t\t\tcpu_sel = MR_RAID_CTX_CPUSEL_1;\n\n\t\t\tif (is_stream_detected(rctx_g35) &&\n\t\t\t    ((raid->level == 5) || (raid->level == 6)) &&\n\t\t\t    (raid->writeMode == MR_RL_WRITE_THROUGH_MODE) &&\n\t\t\t    (cpu_sel == MR_RAID_CTX_CPUSEL_FCFS))\n\t\t\t\tcpu_sel = MR_RAID_CTX_CPUSEL_0;\n\t\t}\n\t}\n\n\trctx_g35->routing_flags |=\n\t\t(cpu_sel << MR_RAID_CTX_ROUTINGFLAGS_CPUSEL_SHIFT);\n\n\t \n\tif ((fusion->pcie_bw_limitation) && (raid->level == 1) && (!is_read) &&\n\t\t\t(scsi_buff_len > MR_LARGE_IO_MIN_SIZE)) {\n\t\tpraid_context->raid_context_g35.raid_flags =\n\t\t\t(MR_RAID_FLAGS_IO_SUB_TYPE_LDIO_BW_LIMIT\n\t\t\t<< MR_RAID_CTX_RAID_FLAGS_IO_SUB_TYPE_SHIFT);\n\t}\n}\n\n \nstatic void\nmegasas_build_ldio_fusion(struct megasas_instance *instance,\n\t\t\t  struct scsi_cmnd *scp,\n\t\t\t  struct megasas_cmd_fusion *cmd)\n{\n\tbool fp_possible;\n\tu16 ld;\n\tu32 start_lba_lo, start_lba_hi, device_id, datalength = 0;\n\tu32 scsi_buff_len;\n\tstruct MPI2_RAID_SCSI_IO_REQUEST *io_request;\n\tstruct IO_REQUEST_INFO io_info;\n\tstruct fusion_context *fusion;\n\tstruct MR_DRV_RAID_MAP_ALL *local_map_ptr;\n\tu8 *raidLUN;\n\tunsigned long spinlock_flags;\n\tstruct MR_LD_RAID *raid = NULL;\n\tstruct MR_PRIV_DEVICE *mrdev_priv;\n\tstruct RAID_CONTEXT *rctx;\n\tstruct RAID_CONTEXT_G35 *rctx_g35;\n\n\tdevice_id = MEGASAS_DEV_INDEX(scp);\n\n\tfusion = instance->ctrl_context;\n\n\tio_request = cmd->io_request;\n\trctx = &io_request->RaidContext.raid_context;\n\trctx_g35 = &io_request->RaidContext.raid_context_g35;\n\n\trctx->virtual_disk_tgt_id = cpu_to_le16(device_id);\n\trctx->status = 0;\n\trctx->ex_status = 0;\n\n\tstart_lba_lo = 0;\n\tstart_lba_hi = 0;\n\tfp_possible = false;\n\n\t \n\tif (scp->cmd_len == 6) {\n\t\tdatalength = (u32) scp->cmnd[4];\n\t\tstart_lba_lo = ((u32) scp->cmnd[1] << 16) |\n\t\t\t((u32) scp->cmnd[2] << 8) | (u32) scp->cmnd[3];\n\n\t\tstart_lba_lo &= 0x1FFFFF;\n\t}\n\n\t \n\telse if (scp->cmd_len == 10) {\n\t\tdatalength = (u32) scp->cmnd[8] |\n\t\t\t((u32) scp->cmnd[7] << 8);\n\t\tstart_lba_lo = ((u32) scp->cmnd[2] << 24) |\n\t\t\t((u32) scp->cmnd[3] << 16) |\n\t\t\t((u32) scp->cmnd[4] << 8) | (u32) scp->cmnd[5];\n\t}\n\n\t \n\telse if (scp->cmd_len == 12) {\n\t\tdatalength = ((u32) scp->cmnd[6] << 24) |\n\t\t\t((u32) scp->cmnd[7] << 16) |\n\t\t\t((u32) scp->cmnd[8] << 8) | (u32) scp->cmnd[9];\n\t\tstart_lba_lo = ((u32) scp->cmnd[2] << 24) |\n\t\t\t((u32) scp->cmnd[3] << 16) |\n\t\t\t((u32) scp->cmnd[4] << 8) | (u32) scp->cmnd[5];\n\t}\n\n\t \n\telse if (scp->cmd_len == 16) {\n\t\tdatalength = ((u32) scp->cmnd[10] << 24) |\n\t\t\t((u32) scp->cmnd[11] << 16) |\n\t\t\t((u32) scp->cmnd[12] << 8) | (u32) scp->cmnd[13];\n\t\tstart_lba_lo = ((u32) scp->cmnd[6] << 24) |\n\t\t\t((u32) scp->cmnd[7] << 16) |\n\t\t\t((u32) scp->cmnd[8] << 8) | (u32) scp->cmnd[9];\n\n\t\tstart_lba_hi = ((u32) scp->cmnd[2] << 24) |\n\t\t\t((u32) scp->cmnd[3] << 16) |\n\t\t\t((u32) scp->cmnd[4] << 8) | (u32) scp->cmnd[5];\n\t}\n\n\tmemset(&io_info, 0, sizeof(struct IO_REQUEST_INFO));\n\tio_info.ldStartBlock = ((u64)start_lba_hi << 32) | start_lba_lo;\n\tio_info.numBlocks = datalength;\n\tio_info.ldTgtId = device_id;\n\tio_info.r1_alt_dev_handle = MR_DEVHANDLE_INVALID;\n\tscsi_buff_len = scsi_bufflen(scp);\n\tio_request->DataLength = cpu_to_le32(scsi_buff_len);\n\tio_info.data_arms = 1;\n\n\tif (scp->sc_data_direction == DMA_FROM_DEVICE)\n\t\tio_info.isRead = 1;\n\n\tlocal_map_ptr = fusion->ld_drv_map[(instance->map_id & 1)];\n\tld = MR_TargetIdToLdGet(device_id, local_map_ptr);\n\n\tif (ld < instance->fw_supported_vd_count)\n\t\traid = MR_LdRaidGet(ld, local_map_ptr);\n\n\tif (!raid || (!fusion->fast_path_io)) {\n\t\trctx->reg_lock_flags  = 0;\n\t\tfp_possible = false;\n\t} else {\n\t\tif (MR_BuildRaidContext(instance, &io_info, rctx,\n\t\t\t\t\tlocal_map_ptr, &raidLUN))\n\t\t\tfp_possible = (io_info.fpOkForIo > 0) ? true : false;\n\t}\n\n\tmegasas_get_msix_index(instance, scp, cmd, io_info.data_arms);\n\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\t \n\t\tif (io_info.r1_alt_dev_handle != MR_DEVHANDLE_INVALID) {\n\t\t\tmrdev_priv = scp->device->hostdata;\n\n\t\t\tif (atomic_inc_return(&instance->fw_outstanding) >\n\t\t\t\t(instance->host->can_queue)) {\n\t\t\t\tfp_possible = false;\n\t\t\t\tatomic_dec(&instance->fw_outstanding);\n\t\t\t} else if (fusion->pcie_bw_limitation &&\n\t\t\t\t((scsi_buff_len > MR_LARGE_IO_MIN_SIZE) ||\n\t\t\t\t   (atomic_dec_if_positive(&mrdev_priv->r1_ldio_hint) > 0))) {\n\t\t\t\tfp_possible = false;\n\t\t\t\tatomic_dec(&instance->fw_outstanding);\n\t\t\t\tif (scsi_buff_len > MR_LARGE_IO_MIN_SIZE)\n\t\t\t\t\tatomic_set(&mrdev_priv->r1_ldio_hint,\n\t\t\t\t\t\t   instance->r1_ldio_hint_default);\n\t\t\t}\n\t\t}\n\n\t\tif (!fp_possible ||\n\t\t    (io_info.isRead && io_info.ra_capable)) {\n\t\t\tspin_lock_irqsave(&instance->stream_lock,\n\t\t\t\t\t  spinlock_flags);\n\t\t\tmegasas_stream_detect(instance, cmd, &io_info);\n\t\t\tspin_unlock_irqrestore(&instance->stream_lock,\n\t\t\t\t\t       spinlock_flags);\n\t\t\t \n\t\t\tif (is_stream_detected(rctx_g35))\n\t\t\t\tfp_possible = false;\n\t\t}\n\n\t\t \n\t\tif (raid)\n\t\t\tmegasas_set_raidflag_cpu_affinity(fusion, &io_request->RaidContext,\n\t\t\t\traid, fp_possible, io_info.isRead,\n\t\t\t\tscsi_buff_len);\n\t\telse\n\t\t\trctx_g35->routing_flags |=\n\t\t\t\t(MR_RAID_CTX_CPUSEL_0 << MR_RAID_CTX_ROUTINGFLAGS_CPUSEL_SHIFT);\n\t}\n\n\tif (fp_possible) {\n\t\tmegasas_set_pd_lba(io_request, scp->cmd_len, &io_info, scp,\n\t\t\t\t   local_map_ptr, start_lba_lo);\n\t\tio_request->Function = MPI2_FUNCTION_SCSI_IO_REQUEST;\n\t\tcmd->request_desc->SCSIIO.RequestFlags =\n\t\t\t(MPI2_REQ_DESCRIPT_FLAGS_FP_IO\n\t\t\t << MEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\n\t\tif (instance->adapter_type == INVADER_SERIES) {\n\t\t\trctx->type = MPI2_TYPE_CUDA;\n\t\t\trctx->nseg = 0x1;\n\t\t\tio_request->IoFlags |= cpu_to_le16(MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH);\n\t\t\trctx->reg_lock_flags |=\n\t\t\t  (MR_RL_FLAGS_GRANT_DESTINATION_CUDA |\n\t\t\t   MR_RL_FLAGS_SEQ_NUM_ENABLE);\n\t\t} else if (instance->adapter_type >= VENTURA_SERIES) {\n\t\t\trctx_g35->nseg_type |= (1 << RAID_CONTEXT_NSEG_SHIFT);\n\t\t\trctx_g35->nseg_type |= (MPI2_TYPE_CUDA << RAID_CONTEXT_TYPE_SHIFT);\n\t\t\trctx_g35->routing_flags |= (1 << MR_RAID_CTX_ROUTINGFLAGS_SQN_SHIFT);\n\t\t\tio_request->IoFlags |=\n\t\t\t\tcpu_to_le16(MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH);\n\t\t}\n\t\tif (fusion->load_balance_info &&\n\t\t\t(fusion->load_balance_info[device_id].loadBalanceFlag) &&\n\t\t\t(io_info.isRead)) {\n\t\t\tio_info.devHandle =\n\t\t\t\tget_updated_dev_handle(instance,\n\t\t\t\t\t&fusion->load_balance_info[device_id],\n\t\t\t\t\t&io_info, local_map_ptr);\n\t\t\tmegasas_priv(scp)->status |= MEGASAS_LOAD_BALANCE_FLAG;\n\t\t\tcmd->pd_r1_lb = io_info.pd_after_lb;\n\t\t\tif (instance->adapter_type >= VENTURA_SERIES)\n\t\t\t\trctx_g35->span_arm = io_info.span_arm;\n\t\t\telse\n\t\t\t\trctx->span_arm = io_info.span_arm;\n\n\t\t} else\n\t\t\tmegasas_priv(scp)->status &= ~MEGASAS_LOAD_BALANCE_FLAG;\n\n\t\tif (instance->adapter_type >= VENTURA_SERIES)\n\t\t\tcmd->r1_alt_dev_handle = io_info.r1_alt_dev_handle;\n\t\telse\n\t\t\tcmd->r1_alt_dev_handle = MR_DEVHANDLE_INVALID;\n\n\t\tif ((raidLUN[0] == 1) &&\n\t\t\t(local_map_ptr->raidMap.devHndlInfo[io_info.pd_after_lb].validHandles > 1)) {\n\t\t\tinstance->dev_handle = !(instance->dev_handle);\n\t\t\tio_info.devHandle =\n\t\t\t\tlocal_map_ptr->raidMap.devHndlInfo[io_info.pd_after_lb].devHandle[instance->dev_handle];\n\t\t}\n\n\t\tcmd->request_desc->SCSIIO.DevHandle = io_info.devHandle;\n\t\tio_request->DevHandle = io_info.devHandle;\n\t\tcmd->pd_interface = io_info.pd_interface;\n\t\t \n\t\tmemcpy(io_request->LUN, raidLUN, 8);\n\t} else {\n\t\trctx->timeout_value =\n\t\t\tcpu_to_le16(local_map_ptr->raidMap.fpPdIoTimeoutSec);\n\t\tcmd->request_desc->SCSIIO.RequestFlags =\n\t\t\t(MEGASAS_REQ_DESCRIPT_FLAGS_LD_IO\n\t\t\t << MEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\n\t\tif (instance->adapter_type == INVADER_SERIES) {\n\t\t\tif (io_info.do_fp_rlbypass ||\n\t\t\t(rctx->reg_lock_flags == REGION_TYPE_UNUSED))\n\t\t\t\tcmd->request_desc->SCSIIO.RequestFlags =\n\t\t\t\t\t(MEGASAS_REQ_DESCRIPT_FLAGS_NO_LOCK <<\n\t\t\t\t\tMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\n\t\t\trctx->type = MPI2_TYPE_CUDA;\n\t\t\trctx->reg_lock_flags |=\n\t\t\t\t(MR_RL_FLAGS_GRANT_DESTINATION_CPU0 |\n\t\t\t\t\tMR_RL_FLAGS_SEQ_NUM_ENABLE);\n\t\t\trctx->nseg = 0x1;\n\t\t} else if (instance->adapter_type >= VENTURA_SERIES) {\n\t\t\trctx_g35->routing_flags |= (1 << MR_RAID_CTX_ROUTINGFLAGS_SQN_SHIFT);\n\t\t\trctx_g35->nseg_type |= (1 << RAID_CONTEXT_NSEG_SHIFT);\n\t\t\trctx_g35->nseg_type |= (MPI2_TYPE_CUDA << RAID_CONTEXT_TYPE_SHIFT);\n\t\t}\n\t\tio_request->Function = MEGASAS_MPI2_FUNCTION_LD_IO_REQUEST;\n\t\tio_request->DevHandle = cpu_to_le16(device_id);\n\n\t}  \n}\n\n \nstatic void megasas_build_ld_nonrw_fusion(struct megasas_instance *instance,\n\t\t\t  struct scsi_cmnd *scmd, struct megasas_cmd_fusion *cmd)\n{\n\tu32 device_id;\n\tstruct MPI2_RAID_SCSI_IO_REQUEST *io_request;\n\tu16 ld;\n\tstruct MR_DRV_RAID_MAP_ALL *local_map_ptr;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tu8                          span, physArm;\n\t__le16                      devHandle;\n\tu32                         arRef, pd;\n\tstruct MR_LD_RAID                  *raid;\n\tstruct RAID_CONTEXT                *pRAID_Context;\n\tu8 fp_possible = 1;\n\n\tio_request = cmd->io_request;\n\tdevice_id = MEGASAS_DEV_INDEX(scmd);\n\tlocal_map_ptr = fusion->ld_drv_map[(instance->map_id & 1)];\n\tio_request->DataLength = cpu_to_le32(scsi_bufflen(scmd));\n\t \n\tpRAID_Context = &io_request->RaidContext.raid_context;\n\t \n\tpRAID_Context->virtual_disk_tgt_id = cpu_to_le16(device_id);\n\tpRAID_Context->reg_lock_row_lba    = 0;\n\tpRAID_Context->reg_lock_length    = 0;\n\n\tif (fusion->fast_path_io && (\n\t\tdevice_id < instance->fw_supported_vd_count)) {\n\n\t\tld = MR_TargetIdToLdGet(device_id, local_map_ptr);\n\t\tif (ld >= instance->fw_supported_vd_count - 1)\n\t\t\tfp_possible = 0;\n\t\telse {\n\t\t\traid = MR_LdRaidGet(ld, local_map_ptr);\n\t\t\tif (!(raid->capability.fpNonRWCapable))\n\t\t\t\tfp_possible = 0;\n\t\t}\n\t} else\n\t\tfp_possible = 0;\n\n\tif (!fp_possible) {\n\t\tio_request->Function  = MEGASAS_MPI2_FUNCTION_LD_IO_REQUEST;\n\t\tio_request->DevHandle = cpu_to_le16(device_id);\n\t\tio_request->LUN[1] = scmd->device->lun;\n\t\tpRAID_Context->timeout_value =\n\t\t\tcpu_to_le16(scsi_cmd_to_rq(scmd)->timeout / HZ);\n\t\tcmd->request_desc->SCSIIO.RequestFlags =\n\t\t\t(MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO <<\n\t\t\tMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\n\t} else {\n\n\t\t \n\t\tpRAID_Context->config_seq_num = raid->seqNum;\n\t\tif (instance->adapter_type < VENTURA_SERIES)\n\t\t\tpRAID_Context->reg_lock_flags = REGION_TYPE_SHARED_READ;\n\t\tpRAID_Context->timeout_value =\n\t\t\tcpu_to_le16(raid->fpIoTimeoutForLd);\n\n\t\t \n\t\tspan = physArm = 0;\n\t\tarRef = MR_LdSpanArrayGet(ld, span, local_map_ptr);\n\t\tpd = MR_ArPdGet(arRef, physArm, local_map_ptr);\n\t\tdevHandle = MR_PdDevHandleGet(pd, local_map_ptr);\n\n\t\t \n\t\tcmd->request_desc->SCSIIO.RequestFlags =\n\t\t\t(MPI2_REQ_DESCRIPT_FLAGS_FP_IO <<\n\t\t\tMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\n\t\tcmd->request_desc->SCSIIO.DevHandle = devHandle;\n\n\t\t \n\t\tmemcpy(io_request->LUN, raid->LUN, 8);\n\n\t\t \n\t\tio_request->Function = MPI2_FUNCTION_SCSI_IO_REQUEST;\n\t\tio_request->DevHandle = devHandle;\n\t}\n}\n\n \nstatic void\nmegasas_build_syspd_fusion(struct megasas_instance *instance,\n\tstruct scsi_cmnd *scmd, struct megasas_cmd_fusion *cmd,\n\tbool fp_possible)\n{\n\tu32 device_id;\n\tstruct MPI2_RAID_SCSI_IO_REQUEST *io_request;\n\tu16 pd_index = 0;\n\tu16 os_timeout_value;\n\tu16 timeout_limit;\n\tstruct MR_DRV_RAID_MAP_ALL *local_map_ptr;\n\tstruct RAID_CONTEXT\t*pRAID_Context;\n\tstruct MR_PD_CFG_SEQ_NUM_SYNC *pd_sync;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tpd_sync = (void *)fusion->pd_seq_sync[(instance->pd_seq_map_id - 1) & 1];\n\n\tdevice_id = MEGASAS_DEV_INDEX(scmd);\n\tpd_index = MEGASAS_PD_INDEX(scmd);\n\tos_timeout_value = scsi_cmd_to_rq(scmd)->timeout / HZ;\n\tmr_device_priv_data = scmd->device->hostdata;\n\tcmd->pd_interface = mr_device_priv_data->interface_type;\n\n\tio_request = cmd->io_request;\n\t \n\tpRAID_Context = &io_request->RaidContext.raid_context;\n\tpRAID_Context->reg_lock_flags = 0;\n\tpRAID_Context->reg_lock_row_lba = 0;\n\tpRAID_Context->reg_lock_length = 0;\n\tio_request->DataLength = cpu_to_le32(scsi_bufflen(scmd));\n\tio_request->LUN[1] = scmd->device->lun;\n\tpRAID_Context->raid_flags = MR_RAID_FLAGS_IO_SUB_TYPE_SYSTEM_PD\n\t\t<< MR_RAID_CTX_RAID_FLAGS_IO_SUB_TYPE_SHIFT;\n\n\t \n\tif (instance->support_seqnum_jbod_fp) {\n\t\tif (instance->use_seqnum_jbod_fp &&\n\t\t\tinstance->pd_list[pd_index].driveType == TYPE_DISK) {\n\n\t\t\t \n\t\t\tif (instance->support_morethan256jbod)\n\t\t\t\tpRAID_Context->virtual_disk_tgt_id =\n\t\t\t\t\tpd_sync->seq[pd_index].pd_target_id;\n\t\t\telse\n\t\t\t\tpRAID_Context->virtual_disk_tgt_id =\n\t\t\t\t\tcpu_to_le16(device_id +\n\t\t\t\t\t(MAX_PHYSICAL_DEVICES - 1));\n\t\t\tpRAID_Context->config_seq_num =\n\t\t\t\tpd_sync->seq[pd_index].seqNum;\n\t\t\tio_request->DevHandle =\n\t\t\t\tpd_sync->seq[pd_index].devHandle;\n\t\t\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\t\t\tio_request->RaidContext.raid_context_g35.routing_flags |=\n\t\t\t\t\t(1 << MR_RAID_CTX_ROUTINGFLAGS_SQN_SHIFT);\n\t\t\t\tio_request->RaidContext.raid_context_g35.nseg_type |=\n\t\t\t\t\t(1 << RAID_CONTEXT_NSEG_SHIFT);\n\t\t\t\tio_request->RaidContext.raid_context_g35.nseg_type |=\n\t\t\t\t\t(MPI2_TYPE_CUDA << RAID_CONTEXT_TYPE_SHIFT);\n\t\t\t} else {\n\t\t\t\tpRAID_Context->type = MPI2_TYPE_CUDA;\n\t\t\t\tpRAID_Context->nseg = 0x1;\n\t\t\t\tpRAID_Context->reg_lock_flags |=\n\t\t\t\t\t(MR_RL_FLAGS_SEQ_NUM_ENABLE |\n\t\t\t\t\t MR_RL_FLAGS_GRANT_DESTINATION_CUDA);\n\t\t\t}\n\t\t} else {\n\t\t\tpRAID_Context->virtual_disk_tgt_id =\n\t\t\t\tcpu_to_le16(device_id +\n\t\t\t\t(MAX_PHYSICAL_DEVICES - 1));\n\t\t\tpRAID_Context->config_seq_num = 0;\n\t\t\tio_request->DevHandle = cpu_to_le16(0xFFFF);\n\t\t}\n\t} else {\n\t\tpRAID_Context->virtual_disk_tgt_id = cpu_to_le16(device_id);\n\t\tpRAID_Context->config_seq_num = 0;\n\n\t\tif (fusion->fast_path_io) {\n\t\t\tlocal_map_ptr =\n\t\t\t\tfusion->ld_drv_map[(instance->map_id & 1)];\n\t\t\tio_request->DevHandle =\n\t\t\t\tlocal_map_ptr->raidMap.devHndlInfo[device_id].curDevHdl;\n\t\t} else {\n\t\t\tio_request->DevHandle = cpu_to_le16(0xFFFF);\n\t\t}\n\t}\n\n\tcmd->request_desc->SCSIIO.DevHandle = io_request->DevHandle;\n\n\tmegasas_get_msix_index(instance, scmd, cmd, 1);\n\n\tif (!fp_possible) {\n\t\t \n\t\tio_request->Function  = MEGASAS_MPI2_FUNCTION_LD_IO_REQUEST;\n\t\tcmd->request_desc->SCSIIO.RequestFlags =\n\t\t\t(MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO <<\n\t\t\t\tMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\n\t\tpRAID_Context->timeout_value = cpu_to_le16(os_timeout_value);\n\t\tpRAID_Context->virtual_disk_tgt_id = cpu_to_le16(device_id);\n\t} else {\n\t\tif (os_timeout_value)\n\t\t\tos_timeout_value++;\n\n\t\t \n\t\tio_request->Function = MPI2_FUNCTION_SCSI_IO_REQUEST;\n\t\ttimeout_limit = (scmd->device->type == TYPE_DISK) ?\n\t\t\t\t255 : 0xFFFF;\n\t\tpRAID_Context->timeout_value =\n\t\t\tcpu_to_le16((os_timeout_value > timeout_limit) ?\n\t\t\ttimeout_limit : os_timeout_value);\n\t\tif (instance->adapter_type >= INVADER_SERIES)\n\t\t\tio_request->IoFlags |=\n\t\t\t\tcpu_to_le16(MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH);\n\n\t\tcmd->request_desc->SCSIIO.RequestFlags =\n\t\t\t(MPI2_REQ_DESCRIPT_FLAGS_FP_IO <<\n\t\t\t\tMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\n\t}\n}\n\n \nstatic int\nmegasas_build_io_fusion(struct megasas_instance *instance,\n\t\t\tstruct scsi_cmnd *scp,\n\t\t\tstruct megasas_cmd_fusion *cmd)\n{\n\tint sge_count;\n\tu16 pd_index = 0;\n\tu8 drive_type = 0;\n\tstruct MPI2_RAID_SCSI_IO_REQUEST *io_request = cmd->io_request;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\tmr_device_priv_data = scp->device->hostdata;\n\n\t \n\tmemset(io_request->LUN, 0x0, 8);\n\tio_request->CDB.EEDP32.PrimaryReferenceTag = 0;\n\tio_request->CDB.EEDP32.PrimaryApplicationTagMask = 0;\n\tio_request->EEDPFlags = 0;\n\tio_request->Control = 0;\n\tio_request->EEDPBlockSize = 0;\n\tio_request->ChainOffset = 0;\n\tio_request->RaidContext.raid_context.raid_flags = 0;\n\tio_request->RaidContext.raid_context.type = 0;\n\tio_request->RaidContext.raid_context.nseg = 0;\n\n\tmemcpy(io_request->CDB.CDB32, scp->cmnd, scp->cmd_len);\n\t \n\tio_request->IoFlags = cpu_to_le16(scp->cmd_len);\n\n\tswitch (megasas_cmd_type(scp)) {\n\tcase READ_WRITE_LDIO:\n\t\tmegasas_build_ldio_fusion(instance, scp, cmd);\n\t\tbreak;\n\tcase NON_READ_WRITE_LDIO:\n\t\tmegasas_build_ld_nonrw_fusion(instance, scp, cmd);\n\t\tbreak;\n\tcase READ_WRITE_SYSPDIO:\n\t\tmegasas_build_syspd_fusion(instance, scp, cmd, true);\n\t\tbreak;\n\tcase NON_READ_WRITE_SYSPDIO:\n\t\tpd_index = MEGASAS_PD_INDEX(scp);\n\t\tdrive_type = instance->pd_list[pd_index].driveType;\n\t\tif ((instance->secure_jbod_support ||\n\t\t     mr_device_priv_data->is_tm_capable) ||\n\t\t     (instance->adapter_type >= VENTURA_SERIES &&\n\t\t     drive_type == TYPE_ENCLOSURE))\n\t\t\tmegasas_build_syspd_fusion(instance, scp, cmd, false);\n\t\telse\n\t\t\tmegasas_build_syspd_fusion(instance, scp, cmd, true);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\n\tsge_count = megasas_make_sgl(instance, scp, cmd);\n\n\tif (sge_count > instance->max_num_sge || (sge_count < 0)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"%s %d sge_count (%d) is out of range. Range is:  0-%d\\n\",\n\t\t\t__func__, __LINE__, sge_count, instance->max_num_sge);\n\t\treturn 1;\n\t}\n\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tset_num_sge(&io_request->RaidContext.raid_context_g35, sge_count);\n\t\tcpu_to_le16s(&io_request->RaidContext.raid_context_g35.routing_flags);\n\t\tcpu_to_le16s(&io_request->RaidContext.raid_context_g35.nseg_type);\n\t} else {\n\t\t \n\t\tio_request->RaidContext.raid_context.num_sge = sge_count;\n\t\tio_request->RaidContext.raid_context.num_sge_ext =\n\t\t\t(u8)(sge_count >> 8);\n\t}\n\n\tio_request->SGLFlags = cpu_to_le16(MPI2_SGE_FLAGS_64_BIT_ADDRESSING);\n\n\tif (scp->sc_data_direction == DMA_TO_DEVICE)\n\t\tio_request->Control |= cpu_to_le32(MPI2_SCSIIO_CONTROL_WRITE);\n\telse if (scp->sc_data_direction == DMA_FROM_DEVICE)\n\t\tio_request->Control |= cpu_to_le32(MPI2_SCSIIO_CONTROL_READ);\n\n\tio_request->SGLOffset0 =\n\t\toffsetof(struct MPI2_RAID_SCSI_IO_REQUEST, SGL) / 4;\n\n\tio_request->SenseBufferLowAddress =\n\t\tcpu_to_le32(lower_32_bits(cmd->sense_phys_addr));\n\tio_request->SenseBufferLength = SCSI_SENSE_BUFFERSIZE;\n\n\tcmd->scmd = scp;\n\tmegasas_priv(scp)->cmd_priv = cmd;\n\n\treturn 0;\n}\n\nstatic union MEGASAS_REQUEST_DESCRIPTOR_UNION *\nmegasas_get_request_descriptor(struct megasas_instance *instance, u16 index)\n{\n\tu8 *p;\n\tstruct fusion_context *fusion;\n\n\tfusion = instance->ctrl_context;\n\tp = fusion->req_frames_desc +\n\t\tsizeof(union MEGASAS_REQUEST_DESCRIPTOR_UNION) * index;\n\n\treturn (union MEGASAS_REQUEST_DESCRIPTOR_UNION *)p;\n}\n\n\n \nstatic void megasas_prepare_secondRaid1_IO(struct megasas_instance *instance,\n\t\t\t\t\t   struct megasas_cmd_fusion *cmd,\n\t\t\t\t\t   struct megasas_cmd_fusion *r1_cmd)\n{\n\tunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc, *req_desc2 = NULL;\n\tstruct fusion_context *fusion;\n\tfusion = instance->ctrl_context;\n\treq_desc = cmd->request_desc;\n\t \n\tmemcpy(r1_cmd->io_request, cmd->io_request,\n\t       (sizeof(struct MPI2_RAID_SCSI_IO_REQUEST)));\n\tmemcpy(r1_cmd->io_request->SGLs, cmd->io_request->SGLs,\n\t       (fusion->max_sge_in_main_msg * sizeof(union MPI2_SGE_IO_UNION)));\n\t \n\tr1_cmd->io_request->SenseBufferLowAddress =\n\t\t\tcpu_to_le32(lower_32_bits(r1_cmd->sense_phys_addr));\n\tr1_cmd->scmd = cmd->scmd;\n\treq_desc2 = megasas_get_request_descriptor(instance,\n\t\t\t\t\t\t   (r1_cmd->index - 1));\n\treq_desc2->Words = 0;\n\tr1_cmd->request_desc = req_desc2;\n\treq_desc2->SCSIIO.SMID = cpu_to_le16(r1_cmd->index);\n\treq_desc2->SCSIIO.RequestFlags = req_desc->SCSIIO.RequestFlags;\n\tr1_cmd->request_desc->SCSIIO.DevHandle = cmd->r1_alt_dev_handle;\n\tr1_cmd->io_request->DevHandle = cmd->r1_alt_dev_handle;\n\tr1_cmd->r1_alt_dev_handle = cmd->io_request->DevHandle;\n\tcmd->io_request->RaidContext.raid_context_g35.flow_specific.peer_smid =\n\t\t\tcpu_to_le16(r1_cmd->index);\n\tr1_cmd->io_request->RaidContext.raid_context_g35.flow_specific.peer_smid =\n\t\t\tcpu_to_le16(cmd->index);\n\t \n\tr1_cmd->request_desc->SCSIIO.MSIxIndex =\n\t\t\tcmd->request_desc->SCSIIO.MSIxIndex;\n\t \n\tr1_cmd->io_request->RaidContext.raid_context_g35.span_arm =\n\t\t\tcmd->io_request->RaidContext.raid_context_g35.span_arm + 1;\n}\n\n \nstatic u32\nmegasas_build_and_issue_cmd_fusion(struct megasas_instance *instance,\n\t\t\t\t   struct scsi_cmnd *scmd)\n{\n\tstruct megasas_cmd_fusion *cmd, *r1_cmd = NULL;\n\tunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\n\tu32 index;\n\n\tif ((megasas_cmd_type(scmd) == READ_WRITE_LDIO) &&\n\t\tinstance->ldio_threshold &&\n\t\t(atomic_inc_return(&instance->ldio_outstanding) >\n\t\tinstance->ldio_threshold)) {\n\t\tatomic_dec(&instance->ldio_outstanding);\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t}\n\n\tif (atomic_inc_return(&instance->fw_outstanding) >\n\t\t\tinstance->host->can_queue) {\n\t\tatomic_dec(&instance->fw_outstanding);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tcmd = megasas_get_cmd_fusion(instance, scsi_cmd_to_rq(scmd)->tag);\n\n\tif (!cmd) {\n\t\tatomic_dec(&instance->fw_outstanding);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tindex = cmd->index;\n\n\treq_desc = megasas_get_request_descriptor(instance, index-1);\n\n\treq_desc->Words = 0;\n\tcmd->request_desc = req_desc;\n\n\tif (megasas_build_io_fusion(instance, scmd, cmd)) {\n\t\tmegasas_return_cmd_fusion(instance, cmd);\n\t\tdev_err(&instance->pdev->dev, \"Error building command\\n\");\n\t\tcmd->request_desc = NULL;\n\t\tatomic_dec(&instance->fw_outstanding);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\treq_desc = cmd->request_desc;\n\treq_desc->SCSIIO.SMID = cpu_to_le16(index);\n\n\tif (cmd->io_request->ChainOffset != 0 &&\n\t    cmd->io_request->ChainOffset != 0xF)\n\t\tdev_err(&instance->pdev->dev, \"The chain offset value is not \"\n\t\t       \"correct : %x\\n\", cmd->io_request->ChainOffset);\n\t \n\t \n\tif (cmd->r1_alt_dev_handle != MR_DEVHANDLE_INVALID) {\n\t\tr1_cmd = megasas_get_cmd_fusion(instance,\n\t\t\t\tscsi_cmd_to_rq(scmd)->tag + instance->max_fw_cmds);\n\t\tmegasas_prepare_secondRaid1_IO(instance, cmd, r1_cmd);\n\t}\n\n\n\t \n\n\tmegasas_sdev_busy_inc(instance, scmd);\n\tmegasas_fire_cmd_fusion(instance, req_desc);\n\n\tif (r1_cmd)\n\t\tmegasas_fire_cmd_fusion(instance, r1_cmd->request_desc);\n\n\n\treturn 0;\n}\n\n \nstatic inline void\nmegasas_complete_r1_command(struct megasas_instance *instance,\n\t\t\t    struct megasas_cmd_fusion *cmd)\n{\n\tu8 *sense, status, ex_status;\n\tu32 data_length;\n\tu16 peer_smid;\n\tstruct fusion_context *fusion;\n\tstruct megasas_cmd_fusion *r1_cmd = NULL;\n\tstruct scsi_cmnd *scmd_local = NULL;\n\tstruct RAID_CONTEXT_G35 *rctx_g35;\n\n\trctx_g35 = &cmd->io_request->RaidContext.raid_context_g35;\n\tfusion = instance->ctrl_context;\n\tpeer_smid = le16_to_cpu(rctx_g35->flow_specific.peer_smid);\n\n\tr1_cmd = fusion->cmd_list[peer_smid - 1];\n\tscmd_local = cmd->scmd;\n\tstatus = rctx_g35->status;\n\tex_status = rctx_g35->ex_status;\n\tdata_length = cmd->io_request->DataLength;\n\tsense = cmd->sense;\n\n\tcmd->cmd_completed = true;\n\n\t \n\tif (r1_cmd->cmd_completed) {\n\t\trctx_g35 = &r1_cmd->io_request->RaidContext.raid_context_g35;\n\t\tif (rctx_g35->status != MFI_STAT_OK) {\n\t\t\tstatus = rctx_g35->status;\n\t\t\tex_status = rctx_g35->ex_status;\n\t\t\tdata_length = r1_cmd->io_request->DataLength;\n\t\t\tsense = r1_cmd->sense;\n\t\t}\n\n\t\tmegasas_return_cmd_fusion(instance, r1_cmd);\n\t\tmap_cmd_status(fusion, scmd_local, status, ex_status,\n\t\t\t       le32_to_cpu(data_length), sense);\n\t\tif (instance->ldio_threshold &&\n\t\t    megasas_cmd_type(scmd_local) == READ_WRITE_LDIO)\n\t\t\tatomic_dec(&instance->ldio_outstanding);\n\t\tmegasas_priv(scmd_local)->cmd_priv = NULL;\n\t\tmegasas_return_cmd_fusion(instance, cmd);\n\t\tscsi_dma_unmap(scmd_local);\n\t\tmegasas_sdev_busy_dec(instance, scmd_local);\n\t\tscsi_done(scmd_local);\n\t}\n}\n\n \nstatic inline\nbool access_irq_context(struct megasas_irq_context  *irq_context)\n{\n\tif (!irq_context)\n\t\treturn true;\n\n\tif (atomic_add_unless(&irq_context->in_used, 1, 1))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic inline\nvoid release_irq_context(struct megasas_irq_context  *irq_context)\n{\n\tif (irq_context)\n\t\tatomic_dec(&irq_context->in_used);\n}\n\n \nstatic int\ncomplete_cmd_fusion(struct megasas_instance *instance, u32 MSIxIndex,\n\t\t    struct megasas_irq_context *irq_context)\n{\n\tunion MPI2_REPLY_DESCRIPTORS_UNION *desc;\n\tstruct MPI2_SCSI_IO_SUCCESS_REPLY_DESCRIPTOR *reply_desc;\n\tstruct MPI2_RAID_SCSI_IO_REQUEST *scsi_io_req;\n\tstruct fusion_context *fusion;\n\tstruct megasas_cmd *cmd_mfi;\n\tstruct megasas_cmd_fusion *cmd_fusion;\n\tu16 smid, num_completed;\n\tu8 reply_descript_type, *sense, status, extStatus;\n\tu32 device_id, data_length;\n\tunion desc_value d_val;\n\tstruct LD_LOAD_BALANCE_INFO *lbinfo;\n\tint threshold_reply_count = 0;\n\tstruct scsi_cmnd *scmd_local = NULL;\n\tstruct MR_TASK_MANAGE_REQUEST *mr_tm_req;\n\tstruct MPI2_SCSI_TASK_MANAGE_REQUEST *mpi_tm_req;\n\n\tfusion = instance->ctrl_context;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)\n\t\treturn IRQ_HANDLED;\n\n\tif (!access_irq_context(irq_context))\n\t\treturn 0;\n\n\tdesc = fusion->reply_frames_desc[MSIxIndex] +\n\t\t\t\tfusion->last_reply_idx[MSIxIndex];\n\n\treply_desc = (struct MPI2_SCSI_IO_SUCCESS_REPLY_DESCRIPTOR *)desc;\n\n\td_val.word = desc->Words;\n\n\treply_descript_type = reply_desc->ReplyFlags &\n\t\tMPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK;\n\n\tif (reply_descript_type == MPI2_RPY_DESCRIPT_FLAGS_UNUSED) {\n\t\trelease_irq_context(irq_context);\n\t\treturn IRQ_NONE;\n\t}\n\n\tnum_completed = 0;\n\n\twhile (d_val.u.low != cpu_to_le32(UINT_MAX) &&\n\t       d_val.u.high != cpu_to_le32(UINT_MAX)) {\n\n\t\tsmid = le16_to_cpu(reply_desc->SMID);\n\t\tcmd_fusion = fusion->cmd_list[smid - 1];\n\t\tscsi_io_req = (struct MPI2_RAID_SCSI_IO_REQUEST *)\n\t\t\t\t\t\tcmd_fusion->io_request;\n\n\t\tscmd_local = cmd_fusion->scmd;\n\t\tstatus = scsi_io_req->RaidContext.raid_context.status;\n\t\textStatus = scsi_io_req->RaidContext.raid_context.ex_status;\n\t\tsense = cmd_fusion->sense;\n\t\tdata_length = scsi_io_req->DataLength;\n\n\t\tswitch (scsi_io_req->Function) {\n\t\tcase MPI2_FUNCTION_SCSI_TASK_MGMT:\n\t\t\tmr_tm_req = (struct MR_TASK_MANAGE_REQUEST *)\n\t\t\t\t\t\tcmd_fusion->io_request;\n\t\t\tmpi_tm_req = (struct MPI2_SCSI_TASK_MANAGE_REQUEST *)\n\t\t\t\t\t\t&mr_tm_req->TmRequest;\n\t\t\tdev_dbg(&instance->pdev->dev, \"TM completion:\"\n\t\t\t\t\"type: 0x%x TaskMID: 0x%x\\n\",\n\t\t\t\tmpi_tm_req->TaskType, mpi_tm_req->TaskMID);\n\t\t\tcomplete(&cmd_fusion->done);\n\t\t\tbreak;\n\t\tcase MPI2_FUNCTION_SCSI_IO_REQUEST:   \n\t\t\t \n\t\t\tif (fusion->load_balance_info &&\n\t\t\t    (megasas_priv(cmd_fusion->scmd)->status &\n\t\t\t    MEGASAS_LOAD_BALANCE_FLAG)) {\n\t\t\t\tdevice_id = MEGASAS_DEV_INDEX(scmd_local);\n\t\t\t\tlbinfo = &fusion->load_balance_info[device_id];\n\t\t\t\tatomic_dec(&lbinfo->scsi_pending_cmds[cmd_fusion->pd_r1_lb]);\n\t\t\t\tmegasas_priv(cmd_fusion->scmd)->status &=\n\t\t\t\t\t~MEGASAS_LOAD_BALANCE_FLAG;\n\t\t\t}\n\t\t\tfallthrough;\t \n\t\tcase MEGASAS_MPI2_FUNCTION_LD_IO_REQUEST:  \n\t\t\tatomic_dec(&instance->fw_outstanding);\n\t\t\tif (cmd_fusion->r1_alt_dev_handle == MR_DEVHANDLE_INVALID) {\n\t\t\t\tmap_cmd_status(fusion, scmd_local, status,\n\t\t\t\t\t       extStatus, le32_to_cpu(data_length),\n\t\t\t\t\t       sense);\n\t\t\t\tif (instance->ldio_threshold &&\n\t\t\t\t    (megasas_cmd_type(scmd_local) == READ_WRITE_LDIO))\n\t\t\t\t\tatomic_dec(&instance->ldio_outstanding);\n\t\t\t\tmegasas_priv(scmd_local)->cmd_priv = NULL;\n\t\t\t\tmegasas_return_cmd_fusion(instance, cmd_fusion);\n\t\t\t\tscsi_dma_unmap(scmd_local);\n\t\t\t\tmegasas_sdev_busy_dec(instance, scmd_local);\n\t\t\t\tscsi_done(scmd_local);\n\t\t\t} else\t \n\t\t\t\tmegasas_complete_r1_command(instance, cmd_fusion);\n\t\t\tbreak;\n\t\tcase MEGASAS_MPI2_FUNCTION_PASSTHRU_IO_REQUEST:  \n\t\t\tcmd_mfi = instance->cmd_list[cmd_fusion->sync_cmd_idx];\n\t\t\t \n\t\t\tif (cmd_mfi->flags & DRV_DCMD_POLLED_MODE) {\n\t\t\t\tcmd_mfi->flags &= ~DRV_DCMD_POLLED_MODE;\n\t\t\t\tmegasas_return_cmd(instance, cmd_mfi);\n\t\t\t} else\n\t\t\t\tmegasas_complete_cmd(instance, cmd_mfi, DID_OK);\n\t\t\tbreak;\n\t\t}\n\n\t\tfusion->last_reply_idx[MSIxIndex]++;\n\t\tif (fusion->last_reply_idx[MSIxIndex] >=\n\t\t    fusion->reply_q_depth)\n\t\t\tfusion->last_reply_idx[MSIxIndex] = 0;\n\n\t\tdesc->Words = cpu_to_le64(ULLONG_MAX);\n\t\tnum_completed++;\n\t\tthreshold_reply_count++;\n\n\t\t \n\t\tif (!fusion->last_reply_idx[MSIxIndex])\n\t\t\tdesc = fusion->reply_frames_desc[MSIxIndex];\n\t\telse\n\t\t\tdesc++;\n\n\t\treply_desc =\n\t\t  (struct MPI2_SCSI_IO_SUCCESS_REPLY_DESCRIPTOR *)desc;\n\n\t\td_val.word = desc->Words;\n\n\t\treply_descript_type = reply_desc->ReplyFlags &\n\t\t\tMPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK;\n\n\t\tif (reply_descript_type == MPI2_RPY_DESCRIPT_FLAGS_UNUSED)\n\t\t\tbreak;\n\t\t \n\t\tif (threshold_reply_count >= instance->threshold_reply_count) {\n\t\t\tif (instance->msix_combined)\n\t\t\t\twritel(((MSIxIndex & 0x7) << 24) |\n\t\t\t\t\tfusion->last_reply_idx[MSIxIndex],\n\t\t\t\t\tinstance->reply_post_host_index_addr[MSIxIndex/8]);\n\t\t\telse\n\t\t\t\twritel((MSIxIndex << 24) |\n\t\t\t\t\tfusion->last_reply_idx[MSIxIndex],\n\t\t\t\t\tinstance->reply_post_host_index_addr[0]);\n\t\t\tthreshold_reply_count = 0;\n\t\t\tif (irq_context) {\n\t\t\t\tif (!irq_context->irq_poll_scheduled) {\n\t\t\t\t\tirq_context->irq_poll_scheduled = true;\n\t\t\t\t\tirq_context->irq_line_enable = true;\n\t\t\t\t\tirq_poll_sched(&irq_context->irqpoll);\n\t\t\t\t}\n\t\t\t\trelease_irq_context(irq_context);\n\t\t\t\treturn num_completed;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (num_completed) {\n\t\twmb();\n\t\tif (instance->msix_combined)\n\t\t\twritel(((MSIxIndex & 0x7) << 24) |\n\t\t\t\tfusion->last_reply_idx[MSIxIndex],\n\t\t\t\tinstance->reply_post_host_index_addr[MSIxIndex/8]);\n\t\telse\n\t\t\twritel((MSIxIndex << 24) |\n\t\t\t\tfusion->last_reply_idx[MSIxIndex],\n\t\t\t\tinstance->reply_post_host_index_addr[0]);\n\t\tmegasas_check_and_restore_queue_depth(instance);\n\t}\n\n\trelease_irq_context(irq_context);\n\n\treturn num_completed;\n}\n\nint megasas_blk_mq_poll(struct Scsi_Host *shost, unsigned int queue_num)\n{\n\n\tstruct megasas_instance *instance;\n\tint num_entries = 0;\n\tstruct fusion_context *fusion;\n\n\tinstance = (struct megasas_instance *)shost->hostdata;\n\n\tfusion = instance->ctrl_context;\n\n\tqueue_num = queue_num + instance->low_latency_index_start;\n\n\tif (!atomic_add_unless(&fusion->busy_mq_poll[queue_num], 1, 1))\n\t\treturn 0;\n\n\tnum_entries = complete_cmd_fusion(instance, queue_num, NULL);\n\tatomic_dec(&fusion->busy_mq_poll[queue_num]);\n\n\treturn num_entries;\n}\n\n \nstatic void megasas_enable_irq_poll(struct megasas_instance *instance)\n{\n\tu32 count, i;\n\tstruct megasas_irq_context *irq_ctx;\n\n\tcount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\n\n\tfor (i = 0; i < count; i++) {\n\t\tirq_ctx = &instance->irq_context[i];\n\t\tirq_poll_enable(&irq_ctx->irqpoll);\n\t}\n}\n\n \nstatic void megasas_sync_irqs(unsigned long instance_addr)\n{\n\tu32 count, i;\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *)instance_addr;\n\tstruct megasas_irq_context *irq_ctx;\n\n\tcount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\n\n\tfor (i = 0; i < count; i++) {\n\t\tsynchronize_irq(pci_irq_vector(instance->pdev, i));\n\t\tirq_ctx = &instance->irq_context[i];\n\t\tirq_poll_disable(&irq_ctx->irqpoll);\n\t\tif (irq_ctx->irq_poll_scheduled) {\n\t\t\tirq_ctx->irq_poll_scheduled = false;\n\t\t\tenable_irq(irq_ctx->os_irq);\n\t\t\tcomplete_cmd_fusion(instance, irq_ctx->MSIxIndex, irq_ctx);\n\t\t}\n\t}\n}\n\n \n\nint megasas_irqpoll(struct irq_poll *irqpoll, int budget)\n{\n\tstruct megasas_irq_context *irq_ctx;\n\tstruct megasas_instance *instance;\n\tint num_entries;\n\n\tirq_ctx = container_of(irqpoll, struct megasas_irq_context, irqpoll);\n\tinstance = irq_ctx->instance;\n\n\tif (irq_ctx->irq_line_enable) {\n\t\tdisable_irq_nosync(irq_ctx->os_irq);\n\t\tirq_ctx->irq_line_enable = false;\n\t}\n\n\tnum_entries = complete_cmd_fusion(instance, irq_ctx->MSIxIndex, irq_ctx);\n\tif (num_entries < budget) {\n\t\tirq_poll_complete(irqpoll);\n\t\tirq_ctx->irq_poll_scheduled = false;\n\t\tenable_irq(irq_ctx->os_irq);\n\t\tcomplete_cmd_fusion(instance, irq_ctx->MSIxIndex, irq_ctx);\n\t}\n\n\treturn num_entries;\n}\n\n \nstatic void\nmegasas_complete_cmd_dpc_fusion(unsigned long instance_addr)\n{\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *)instance_addr;\n\tstruct megasas_irq_context *irq_ctx = NULL;\n\tu32 count, MSIxIndex;\n\n\tcount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\n\n\t \n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)\n\t\treturn;\n\n\tfor (MSIxIndex = 0 ; MSIxIndex < count; MSIxIndex++) {\n\t\tirq_ctx = &instance->irq_context[MSIxIndex];\n\t\tcomplete_cmd_fusion(instance, MSIxIndex, irq_ctx);\n\t}\n}\n\n \nstatic irqreturn_t megasas_isr_fusion(int irq, void *devp)\n{\n\tstruct megasas_irq_context *irq_context = devp;\n\tstruct megasas_instance *instance = irq_context->instance;\n\tu32 mfiStatus;\n\n\tif (instance->mask_interrupts)\n\t\treturn IRQ_NONE;\n\n\tif (irq_context->irq_poll_scheduled)\n\t\treturn IRQ_HANDLED;\n\n\tif (!instance->msix_vectors) {\n\t\tmfiStatus = instance->instancet->clear_intr(instance);\n\t\tif (!mfiStatus)\n\t\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif (test_bit(MEGASAS_FUSION_IN_RESET, &instance->reset_flags)) {\n\t\tinstance->instancet->clear_intr(instance);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn complete_cmd_fusion(instance, irq_context->MSIxIndex, irq_context)\n\t\t\t? IRQ_HANDLED : IRQ_NONE;\n}\n\n \nstatic void\nbuild_mpt_mfi_pass_thru(struct megasas_instance *instance,\n\t\t\tstruct megasas_cmd *mfi_cmd)\n{\n\tstruct MPI25_IEEE_SGE_CHAIN64 *mpi25_ieee_chain;\n\tstruct MPI2_RAID_SCSI_IO_REQUEST *io_req;\n\tstruct megasas_cmd_fusion *cmd;\n\tstruct fusion_context *fusion;\n\tstruct megasas_header *frame_hdr = &mfi_cmd->frame->hdr;\n\n\tfusion = instance->ctrl_context;\n\n\tcmd = megasas_get_cmd_fusion(instance,\n\t\t\tinstance->max_scsi_cmds + mfi_cmd->index);\n\n\t \n\tmfi_cmd->context.smid = cmd->index;\n\n\t \n\n\tif (frame_hdr->flags & cpu_to_le16(MFI_FRAME_DONT_POST_IN_REPLY_QUEUE))\n\t\tmfi_cmd->flags |= DRV_DCMD_POLLED_MODE;\n\n\tio_req = cmd->io_request;\n\n\tif (instance->adapter_type >= INVADER_SERIES) {\n\t\tstruct MPI25_IEEE_SGE_CHAIN64 *sgl_ptr_end =\n\t\t\t(struct MPI25_IEEE_SGE_CHAIN64 *)&io_req->SGL;\n\t\tsgl_ptr_end += fusion->max_sge_in_main_msg - 1;\n\t\tsgl_ptr_end->Flags = 0;\n\t}\n\n\tmpi25_ieee_chain =\n\t  (struct MPI25_IEEE_SGE_CHAIN64 *)&io_req->SGL.IeeeChain;\n\n\tio_req->Function    = MEGASAS_MPI2_FUNCTION_PASSTHRU_IO_REQUEST;\n\tio_req->SGLOffset0  = offsetof(struct MPI2_RAID_SCSI_IO_REQUEST,\n\t\t\t\t       SGL) / 4;\n\tio_req->ChainOffset = fusion->chain_offset_mfi_pthru;\n\n\tmpi25_ieee_chain->Address = cpu_to_le64(mfi_cmd->frame_phys_addr);\n\n\tmpi25_ieee_chain->Flags = IEEE_SGE_FLAGS_CHAIN_ELEMENT |\n\t\tMPI2_IEEE_SGE_FLAGS_IOCPLBNTA_ADDR;\n\n\tmpi25_ieee_chain->Length = cpu_to_le32(instance->mfi_frame_size);\n}\n\n \nstatic union MEGASAS_REQUEST_DESCRIPTOR_UNION *\nbuild_mpt_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc = NULL;\n\tu16 index;\n\n\tbuild_mpt_mfi_pass_thru(instance, cmd);\n\tindex = cmd->context.smid;\n\n\treq_desc = megasas_get_request_descriptor(instance, index - 1);\n\n\treq_desc->Words = 0;\n\treq_desc->SCSIIO.RequestFlags = (MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO <<\n\t\t\t\t\t MEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\n\n\treq_desc->SCSIIO.SMID = cpu_to_le16(index);\n\n\treturn req_desc;\n}\n\n \nstatic void\nmegasas_issue_dcmd_fusion(struct megasas_instance *instance,\n\t\t\t  struct megasas_cmd *cmd)\n{\n\tunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\n\n\treq_desc = build_mpt_cmd(instance, cmd);\n\n\tmegasas_fire_cmd_fusion(instance, req_desc);\n\treturn;\n}\n\n \nvoid\nmegasas_release_fusion(struct megasas_instance *instance)\n{\n\tmegasas_free_ioc_init_cmd(instance);\n\tmegasas_free_cmds(instance);\n\tmegasas_free_cmds_fusion(instance);\n\n\tiounmap(instance->reg_set);\n\n\tpci_release_selected_regions(instance->pdev, 1<<instance->bar);\n}\n\n \nstatic u32\nmegasas_read_fw_status_reg_fusion(struct megasas_instance *instance)\n{\n\treturn megasas_readl(instance, &instance->reg_set->outbound_scratch_pad_0);\n}\n\n \nstatic void\nmegasas_alloc_host_crash_buffer(struct megasas_instance *instance)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < MAX_CRASH_DUMP_SIZE; i++) {\n\t\tinstance->crash_buf[i] = vzalloc(CRASH_DMA_BUF_SIZE);\n\t\tif (!instance->crash_buf[i]) {\n\t\t\tdev_info(&instance->pdev->dev, \"Firmware crash dump \"\n\t\t\t\t\"memory allocation failed at index %d\\n\", i);\n\t\t\tbreak;\n\t\t}\n\t}\n\tinstance->drv_buf_alloc = i;\n}\n\n \nvoid\nmegasas_free_host_crash_buffer(struct megasas_instance *instance)\n{\n\tunsigned int i;\n\tfor (i = 0; i < instance->drv_buf_alloc; i++) {\n\t\tvfree(instance->crash_buf[i]);\n\t}\n\tinstance->drv_buf_index = 0;\n\tinstance->drv_buf_alloc = 0;\n\tinstance->fw_crash_state = UNAVAILABLE;\n\tinstance->fw_crash_buffer_size = 0;\n}\n\n \nstatic int\nmegasas_adp_reset_fusion(struct megasas_instance *instance,\n\t\t\t struct megasas_register_set __iomem *regs)\n{\n\tu32 host_diag, abs_state, retry;\n\n\t \n\twritel(MPI2_WRSEQ_FLUSH_KEY_VALUE, &instance->reg_set->fusion_seq_offset);\n\twritel(MPI2_WRSEQ_1ST_KEY_VALUE, &instance->reg_set->fusion_seq_offset);\n\twritel(MPI2_WRSEQ_2ND_KEY_VALUE, &instance->reg_set->fusion_seq_offset);\n\twritel(MPI2_WRSEQ_3RD_KEY_VALUE, &instance->reg_set->fusion_seq_offset);\n\twritel(MPI2_WRSEQ_4TH_KEY_VALUE, &instance->reg_set->fusion_seq_offset);\n\twritel(MPI2_WRSEQ_5TH_KEY_VALUE, &instance->reg_set->fusion_seq_offset);\n\twritel(MPI2_WRSEQ_6TH_KEY_VALUE, &instance->reg_set->fusion_seq_offset);\n\n\t \n\thost_diag = megasas_readl(instance, &instance->reg_set->fusion_host_diag);\n\tretry = 0;\n\twhile (!(host_diag & HOST_DIAG_WRITE_ENABLE)) {\n\t\tmsleep(100);\n\t\thost_diag = megasas_readl(instance,\n\t\t\t\t\t  &instance->reg_set->fusion_host_diag);\n\t\tif (retry++ == 100) {\n\t\t\tdev_warn(&instance->pdev->dev,\n\t\t\t\t\"Host diag unlock failed from %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!(host_diag & HOST_DIAG_WRITE_ENABLE))\n\t\treturn -1;\n\n\t \n\twritel(host_diag | HOST_DIAG_RESET_ADAPTER,\n\t\t&instance->reg_set->fusion_host_diag);\n\tmsleep(3000);\n\n\t \n\thost_diag = megasas_readl(instance, &instance->reg_set->fusion_host_diag);\n\tretry = 0;\n\twhile (host_diag & HOST_DIAG_RESET_ADAPTER) {\n\t\tmsleep(100);\n\t\thost_diag = megasas_readl(instance,\n\t\t\t\t\t  &instance->reg_set->fusion_host_diag);\n\t\tif (retry++ == 1000) {\n\t\t\tdev_warn(&instance->pdev->dev,\n\t\t\t\t\"Diag reset adapter never cleared %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (host_diag & HOST_DIAG_RESET_ADAPTER)\n\t\treturn -1;\n\n\tabs_state = instance->instancet->read_fw_status_reg(instance)\n\t\t\t& MFI_STATE_MASK;\n\tretry = 0;\n\n\twhile ((abs_state <= MFI_STATE_FW_INIT) && (retry++ < 1000)) {\n\t\tmsleep(100);\n\t\tabs_state = instance->instancet->\n\t\t\tread_fw_status_reg(instance) & MFI_STATE_MASK;\n\t}\n\tif (abs_state <= MFI_STATE_FW_INIT) {\n\t\tdev_warn(&instance->pdev->dev,\n\t\t\t\"fw state < MFI_STATE_FW_INIT, state = 0x%x %s %d\\n\",\n\t\t\tabs_state, __func__, __LINE__);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmegasas_check_reset_fusion(struct megasas_instance *instance,\n\t\t\t   struct megasas_register_set __iomem *regs)\n{\n\treturn 0;\n}\n\n \nstatic inline void megasas_trigger_snap_dump(struct megasas_instance *instance)\n{\n\tint j;\n\tu32 fw_state, abs_state;\n\n\tif (!instance->disableOnlineCtrlReset) {\n\t\tdev_info(&instance->pdev->dev, \"Trigger snap dump\\n\");\n\t\twritel(MFI_ADP_TRIGGER_SNAP_DUMP,\n\t\t       &instance->reg_set->doorbell);\n\t\treadl(&instance->reg_set->doorbell);\n\t}\n\n\tfor (j = 0; j < instance->snapdump_wait_time; j++) {\n\t\tabs_state = instance->instancet->read_fw_status_reg(instance);\n\t\tfw_state = abs_state & MFI_STATE_MASK;\n\t\tif (fw_state == MFI_STATE_FAULT) {\n\t\t\tdev_printk(KERN_ERR, &instance->pdev->dev,\n\t\t\t\t   \"FW in FAULT state Fault code:0x%x subcode:0x%x func:%s\\n\",\n\t\t\t\t   abs_state & MFI_STATE_FAULT_CODE,\n\t\t\t\t   abs_state & MFI_STATE_FAULT_SUBCODE, __func__);\n\t\t\treturn;\n\t\t}\n\t\tmsleep(1000);\n\t}\n}\n\n \nstatic int\nmegasas_wait_for_outstanding_fusion(struct megasas_instance *instance,\n\t\t\t\t    int reason, int *convert)\n{\n\tint i, outstanding, retval = 0, hb_seconds_missed = 0;\n\tu32 fw_state, abs_state;\n\tu32 waittime_for_io_completion;\n\n\twaittime_for_io_completion =\n\t\tmin_t(u32, resetwaittime,\n\t\t\t(resetwaittime - instance->snapdump_wait_time));\n\n\tif (reason == MFI_IO_TIMEOUT_OCR) {\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t\"MFI command is timed out\\n\");\n\t\tmegasas_complete_cmd_dpc_fusion((unsigned long)instance);\n\t\tif (instance->snapdump_wait_time)\n\t\t\tmegasas_trigger_snap_dump(instance);\n\t\tretval = 1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < waittime_for_io_completion; i++) {\n\t\t \n\t\tabs_state = instance->instancet->read_fw_status_reg(instance);\n\t\tfw_state = abs_state & MFI_STATE_MASK;\n\t\tif (fw_state == MFI_STATE_FAULT) {\n\t\t\tdev_printk(KERN_ERR, &instance->pdev->dev,\n\t\t\t\t   \"FW in FAULT state Fault code:0x%x subcode:0x%x func:%s\\n\",\n\t\t\t\t   abs_state & MFI_STATE_FAULT_CODE,\n\t\t\t\t   abs_state & MFI_STATE_FAULT_SUBCODE, __func__);\n\t\t\tmegasas_complete_cmd_dpc_fusion((unsigned long)instance);\n\t\t\tif (instance->requestorId && reason) {\n\t\t\t\tdev_warn(&instance->pdev->dev, \"SR-IOV Found FW in FAULT\"\n\t\t\t\t\" state while polling during\"\n\t\t\t\t\" I/O timeout handling for %d\\n\",\n\t\t\t\tinstance->host->host_no);\n\t\t\t\t*convert = 1;\n\t\t\t}\n\n\t\t\tretval = 1;\n\t\t\tgoto out;\n\t\t}\n\n\n\t\t \n\t\tif (instance->requestorId && !reason) {\n\t\t\tretval = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (instance->requestorId && (reason == SCSIIO_TIMEOUT_OCR)) {\n\t\t\tif (instance->hb_host_mem->HB.fwCounter !=\n\t\t\t    instance->hb_host_mem->HB.driverCounter) {\n\t\t\t\tinstance->hb_host_mem->HB.driverCounter =\n\t\t\t\t\tinstance->hb_host_mem->HB.fwCounter;\n\t\t\t\thb_seconds_missed = 0;\n\t\t\t} else {\n\t\t\t\thb_seconds_missed++;\n\t\t\t\tif (hb_seconds_missed ==\n\t\t\t\t    (MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF/HZ)) {\n\t\t\t\t\tdev_warn(&instance->pdev->dev, \"SR-IOV:\"\n\t\t\t\t\t       \" Heartbeat never completed \"\n\t\t\t\t\t       \" while polling during I/O \"\n\t\t\t\t\t       \" timeout handling for \"\n\t\t\t\t\t       \"scsi%d.\\n\",\n\t\t\t\t\t       instance->host->host_no);\n\t\t\t\t\t       *convert = 1;\n\t\t\t\t\t       retval = 1;\n\t\t\t\t\t       goto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmegasas_complete_cmd_dpc_fusion((unsigned long)instance);\n\t\toutstanding = atomic_read(&instance->fw_outstanding);\n\t\tif (!outstanding)\n\t\t\tgoto out;\n\n\t\tif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\n\t\t\tdev_notice(&instance->pdev->dev, \"[%2d]waiting for %d \"\n\t\t\t       \"commands to complete for scsi%d\\n\", i,\n\t\t\t       outstanding, instance->host->host_no);\n\t\t}\n\t\tmsleep(1000);\n\t}\n\n\tif (instance->snapdump_wait_time) {\n\t\tmegasas_trigger_snap_dump(instance);\n\t\tretval = 1;\n\t\tgoto out;\n\t}\n\n\tif (atomic_read(&instance->fw_outstanding)) {\n\t\tdev_err(&instance->pdev->dev, \"pending commands remain after waiting, \"\n\t\t       \"will reset adapter scsi%d.\\n\",\n\t\t       instance->host->host_no);\n\t\t*convert = 1;\n\t\tretval = 1;\n\t}\n\nout:\n\treturn retval;\n}\n\nvoid  megasas_reset_reply_desc(struct megasas_instance *instance)\n{\n\tint i, j, count;\n\tstruct fusion_context *fusion;\n\tunion MPI2_REPLY_DESCRIPTORS_UNION *reply_desc;\n\n\tfusion = instance->ctrl_context;\n\tcount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\n\tcount += instance->iopoll_q_count;\n\n\tfor (i = 0 ; i < count ; i++) {\n\t\tfusion->last_reply_idx[i] = 0;\n\t\treply_desc = fusion->reply_frames_desc[i];\n\t\tfor (j = 0 ; j < fusion->reply_q_depth; j++, reply_desc++)\n\t\t\treply_desc->Words = cpu_to_le64(ULLONG_MAX);\n\t}\n}\n\n \nstatic void megasas_refire_mgmt_cmd(struct megasas_instance *instance,\n\t\t\t     bool return_ioctl)\n{\n\tint j;\n\tstruct megasas_cmd_fusion *cmd_fusion;\n\tstruct fusion_context *fusion;\n\tstruct megasas_cmd *cmd_mfi;\n\tunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\n\tstruct MPI2_RAID_SCSI_IO_REQUEST *scsi_io_req;\n\tu16 smid;\n\tbool refire_cmd = false;\n\tu8 result;\n\tu32 opcode = 0;\n\n\tfusion = instance->ctrl_context;\n\n\t \n\tfor (j = instance->max_scsi_cmds ; j < instance->max_fw_cmds; j++) {\n\t\tcmd_fusion = fusion->cmd_list[j];\n\t\tcmd_mfi = instance->cmd_list[cmd_fusion->sync_cmd_idx];\n\t\tsmid = le16_to_cpu(cmd_mfi->context.smid);\n\t\tresult = REFIRE_CMD;\n\n\t\tif (!smid)\n\t\t\tcontinue;\n\n\t\treq_desc = megasas_get_request_descriptor(instance, smid - 1);\n\n\t\tswitch (cmd_mfi->frame->hdr.cmd) {\n\t\tcase MFI_CMD_DCMD:\n\t\t\topcode = le32_to_cpu(cmd_mfi->frame->dcmd.opcode);\n\t\t\t  \n\t\t\tif (opcode == MR_DCMD_CTRL_SHUTDOWN) {\n\t\t\t\tcmd_mfi->frame->dcmd.cmd_status = MFI_STAT_OK;\n\t\t\t\tresult = COMPLETE_CMD;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trefire_cmd = ((opcode != MR_DCMD_LD_MAP_GET_INFO)) &&\n\t\t\t\t      (opcode != MR_DCMD_SYSTEM_PD_MAP_GET_INFO) &&\n\t\t\t\t      !(cmd_mfi->flags & DRV_DCMD_SKIP_REFIRE);\n\n\t\t\tif (!refire_cmd)\n\t\t\t\tresult = RETURN_CMD;\n\n\t\t\tbreak;\n\t\tcase MFI_CMD_NVME:\n\t\t\tif (!instance->support_nvme_passthru) {\n\t\t\t\tcmd_mfi->frame->hdr.cmd_status = MFI_STAT_INVALID_CMD;\n\t\t\t\tresult = COMPLETE_CMD;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase MFI_CMD_TOOLBOX:\n\t\t\tif (!instance->support_pci_lane_margining) {\n\t\t\t\tcmd_mfi->frame->hdr.cmd_status = MFI_STAT_INVALID_CMD;\n\t\t\t\tresult = COMPLETE_CMD;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (return_ioctl && cmd_mfi->sync_cmd &&\n\t\t    cmd_mfi->frame->hdr.cmd != MFI_CMD_ABORT) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"return -EBUSY from %s %d cmd 0x%x opcode 0x%x\\n\",\n\t\t\t\t__func__, __LINE__, cmd_mfi->frame->hdr.cmd,\n\t\t\t\tle32_to_cpu(cmd_mfi->frame->dcmd.opcode));\n\t\t\tcmd_mfi->cmd_status_drv = DCMD_BUSY;\n\t\t\tresult = COMPLETE_CMD;\n\t\t}\n\n\t\tscsi_io_req = (struct MPI2_RAID_SCSI_IO_REQUEST *)\n\t\t\t\tcmd_fusion->io_request;\n\t\tif (scsi_io_req->Function == MPI2_FUNCTION_SCSI_TASK_MGMT)\n\t\t\tresult = RETURN_CMD;\n\n\t\tswitch (result) {\n\t\tcase REFIRE_CMD:\n\t\t\tmegasas_fire_cmd_fusion(instance, req_desc);\n\t\t\tbreak;\n\t\tcase RETURN_CMD:\n\t\t\tmegasas_return_cmd(instance, cmd_mfi);\n\t\t\tbreak;\n\t\tcase COMPLETE_CMD:\n\t\t\tmegasas_complete_cmd(instance, cmd_mfi, DID_OK);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void\nmegasas_return_polled_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tstruct megasas_cmd_fusion *cmd_fusion;\n\tstruct fusion_context *fusion;\n\tstruct megasas_cmd *cmd_mfi;\n\n\tfusion = instance->ctrl_context;\n\n\tfor (i = instance->max_scsi_cmds; i < instance->max_fw_cmds; i++) {\n\t\tcmd_fusion = fusion->cmd_list[i];\n\t\tcmd_mfi = instance->cmd_list[cmd_fusion->sync_cmd_idx];\n\n\t\tif (cmd_mfi->flags & DRV_DCMD_POLLED_MODE) {\n\t\t\tif (megasas_dbg_lvl & OCR_DEBUG)\n\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t \"%s %d return cmd 0x%x opcode 0x%x\\n\",\n\t\t\t\t\t __func__, __LINE__, cmd_mfi->frame->hdr.cmd,\n\t\t\t\t\t le32_to_cpu(cmd_mfi->frame->dcmd.opcode));\n\t\t\tcmd_mfi->flags &= ~DRV_DCMD_POLLED_MODE;\n\t\t\tmegasas_return_cmd(instance, cmd_mfi);\n\t\t}\n\t}\n}\n\n \n\nstatic int megasas_track_scsiio(struct megasas_instance *instance,\n\t\tint id, int channel)\n{\n\tint i, found = 0;\n\tstruct megasas_cmd_fusion *cmd_fusion;\n\tstruct fusion_context *fusion;\n\tfusion = instance->ctrl_context;\n\n\tfor (i = 0 ; i < instance->max_scsi_cmds; i++) {\n\t\tcmd_fusion = fusion->cmd_list[i];\n\t\tif (cmd_fusion->scmd &&\n\t\t\t(cmd_fusion->scmd->device->id == id &&\n\t\t\tcmd_fusion->scmd->device->channel == channel)) {\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\"SCSI commands pending to target\"\n\t\t\t\t\"channel %d id %d \\tSMID: 0x%x\\n\",\n\t\t\t\tchannel, id, cmd_fusion->index);\n\t\t\tscsi_print_command(cmd_fusion->scmd);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found ? FAILED : SUCCESS;\n}\n\n \nstatic void\nmegasas_tm_response_code(struct megasas_instance *instance,\n\t\tstruct MPI2_SCSI_TASK_MANAGE_REPLY *mpi_reply)\n{\n\tchar *desc;\n\n\tswitch (mpi_reply->ResponseCode) {\n\tcase MPI2_SCSITASKMGMT_RSP_TM_COMPLETE:\n\t\tdesc = \"task management request completed\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_INVALID_FRAME:\n\t\tdesc = \"invalid frame\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_TM_NOT_SUPPORTED:\n\t\tdesc = \"task management request not supported\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_TM_FAILED:\n\t\tdesc = \"task management request failed\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_TM_SUCCEEDED:\n\t\tdesc = \"task management request succeeded\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_TM_INVALID_LUN:\n\t\tdesc = \"invalid lun\";\n\t\tbreak;\n\tcase 0xA:\n\t\tdesc = \"overlapped tag attempted\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC:\n\t\tdesc = \"task queued, however not sent to target\";\n\t\tbreak;\n\tdefault:\n\t\tdesc = \"unknown\";\n\t\tbreak;\n\t}\n\tdev_dbg(&instance->pdev->dev, \"response_code(%01x): %s\\n\",\n\t\tmpi_reply->ResponseCode, desc);\n\tdev_dbg(&instance->pdev->dev,\n\t\t\"TerminationCount/DevHandle/Function/TaskType/IOCStat/IOCLoginfo\"\n\t\t\" 0x%x/0x%x/0x%x/0x%x/0x%x/0x%x\\n\",\n\t\tmpi_reply->TerminationCount, mpi_reply->DevHandle,\n\t\tmpi_reply->Function, mpi_reply->TaskType,\n\t\tmpi_reply->IOCStatus, mpi_reply->IOCLogInfo);\n}\n\n \nstatic int\nmegasas_issue_tm(struct megasas_instance *instance, u16 device_handle,\n\tuint channel, uint id, u16 smid_task, u8 type,\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data)\n{\n\tstruct MR_TASK_MANAGE_REQUEST *mr_request;\n\tstruct MPI2_SCSI_TASK_MANAGE_REQUEST *mpi_request;\n\tunsigned long timeleft;\n\tstruct megasas_cmd_fusion *cmd_fusion;\n\tstruct megasas_cmd *cmd_mfi;\n\tunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\n\tstruct fusion_context *fusion = NULL;\n\tstruct megasas_cmd_fusion *scsi_lookup;\n\tint rc;\n\tint timeout = MEGASAS_DEFAULT_TM_TIMEOUT;\n\tstruct MPI2_SCSI_TASK_MANAGE_REPLY *mpi_reply;\n\n\tfusion = instance->ctrl_context;\n\n\tcmd_mfi = megasas_get_cmd(instance);\n\n\tif (!cmd_mfi) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\tcmd_fusion = megasas_get_cmd_fusion(instance,\n\t\t\tinstance->max_scsi_cmds + cmd_mfi->index);\n\n\t \n\tcmd_mfi->context.smid = cmd_fusion->index;\n\n\treq_desc = megasas_get_request_descriptor(instance,\n\t\t\t(cmd_fusion->index - 1));\n\n\tcmd_fusion->request_desc = req_desc;\n\treq_desc->Words = 0;\n\n\tmr_request = (struct MR_TASK_MANAGE_REQUEST *) cmd_fusion->io_request;\n\tmemset(mr_request, 0, sizeof(struct MR_TASK_MANAGE_REQUEST));\n\tmpi_request = (struct MPI2_SCSI_TASK_MANAGE_REQUEST *) &mr_request->TmRequest;\n\tmpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;\n\tmpi_request->DevHandle = cpu_to_le16(device_handle);\n\tmpi_request->TaskType = type;\n\tmpi_request->TaskMID = cpu_to_le16(smid_task);\n\tmpi_request->LUN[1] = 0;\n\n\n\treq_desc = cmd_fusion->request_desc;\n\treq_desc->HighPriority.SMID = cpu_to_le16(cmd_fusion->index);\n\treq_desc->HighPriority.RequestFlags =\n\t\t(MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY <<\n\t\tMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\n\treq_desc->HighPriority.MSIxIndex =  0;\n\treq_desc->HighPriority.LMID = 0;\n\treq_desc->HighPriority.Reserved1 = 0;\n\n\tif (channel < MEGASAS_MAX_PD_CHANNELS)\n\t\tmr_request->tmReqFlags.isTMForPD = 1;\n\telse\n\t\tmr_request->tmReqFlags.isTMForLD = 1;\n\n\tinit_completion(&cmd_fusion->done);\n\tmegasas_fire_cmd_fusion(instance, req_desc);\n\n\tswitch (type) {\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK:\n\t\ttimeout = mr_device_priv_data->task_abort_tmo;\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET:\n\t\ttimeout = mr_device_priv_data->target_reset_tmo;\n\t\tbreak;\n\t}\n\n\ttimeleft = wait_for_completion_timeout(&cmd_fusion->done, timeout * HZ);\n\n\tif (!timeleft) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"task mgmt type 0x%x timed out\\n\", type);\n\t\tmutex_unlock(&instance->reset_mutex);\n\t\trc = megasas_reset_fusion(instance->host, MFI_IO_TIMEOUT_OCR);\n\t\tmutex_lock(&instance->reset_mutex);\n\t\treturn rc;\n\t}\n\n\tmpi_reply = (struct MPI2_SCSI_TASK_MANAGE_REPLY *) &mr_request->TMReply;\n\tmegasas_tm_response_code(instance, mpi_reply);\n\n\tmegasas_return_cmd(instance, cmd_mfi);\n\trc = SUCCESS;\n\tswitch (type) {\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK:\n\t\tscsi_lookup = fusion->cmd_list[smid_task - 1];\n\n\t\tif (scsi_lookup->scmd == NULL)\n\t\t\tbreak;\n\t\telse {\n\t\t\tinstance->instancet->disable_intr(instance);\n\t\t\tmegasas_sync_irqs((unsigned long)instance);\n\t\t\tinstance->instancet->enable_intr(instance);\n\t\t\tmegasas_enable_irq_poll(instance);\n\t\t\tif (scsi_lookup->scmd == NULL)\n\t\t\t\tbreak;\n\t\t}\n\t\trc = FAILED;\n\t\tbreak;\n\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET:\n\t\tif ((channel == 0xFFFFFFFF) && (id == 0xFFFFFFFF))\n\t\t\tbreak;\n\t\tinstance->instancet->disable_intr(instance);\n\t\tmegasas_sync_irqs((unsigned long)instance);\n\t\trc = megasas_track_scsiio(instance, id, channel);\n\t\tinstance->instancet->enable_intr(instance);\n\t\tmegasas_enable_irq_poll(instance);\n\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET:\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK:\n\t\tbreak;\n\tdefault:\n\t\trc = FAILED;\n\t\tbreak;\n\t}\n\n\treturn rc;\n\n}\n\n \nstatic u16 megasas_fusion_smid_lookup(struct scsi_cmnd *scmd)\n{\n\tint i, ret = 0;\n\tstruct megasas_instance *instance;\n\tstruct megasas_cmd_fusion *cmd_fusion;\n\tstruct fusion_context *fusion;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tfusion = instance->ctrl_context;\n\n\tfor (i = 0; i < instance->max_scsi_cmds; i++) {\n\t\tcmd_fusion = fusion->cmd_list[i];\n\t\tif (cmd_fusion->scmd && (cmd_fusion->scmd == scmd)) {\n\t\t\tscmd_printk(KERN_NOTICE, scmd, \"Abort request is for\"\n\t\t\t\t\" SMID: %d\\n\", cmd_fusion->index);\n\t\t\tret = cmd_fusion->index;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic u16 megasas_get_tm_devhandle(struct scsi_device *sdev)\n{\n\tu16 pd_index = 0;\n\tu32 device_id;\n\tstruct megasas_instance *instance;\n\tstruct fusion_context *fusion;\n\tstruct MR_PD_CFG_SEQ_NUM_SYNC *pd_sync;\n\tu16 devhandle = (u16)ULONG_MAX;\n\n\tinstance = (struct megasas_instance *)sdev->host->hostdata;\n\tfusion = instance->ctrl_context;\n\n\tif (!MEGASAS_IS_LOGICAL(sdev)) {\n\t\tif (instance->use_seqnum_jbod_fp) {\n\t\t\tpd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL)\n\t\t\t\t    + sdev->id;\n\t\t\tpd_sync = (void *)fusion->pd_seq_sync\n\t\t\t\t\t[(instance->pd_seq_map_id - 1) & 1];\n\t\t\tdevhandle = pd_sync->seq[pd_index].devHandle;\n\t\t} else\n\t\t\tsdev_printk(KERN_ERR, sdev, \"Firmware expose tmCapable\"\n\t\t\t\t\" without JBOD MAP support from %s %d\\n\", __func__, __LINE__);\n\t} else {\n\t\tdevice_id = ((sdev->channel % 2) * MEGASAS_MAX_DEV_PER_CHANNEL)\n\t\t\t\t+ sdev->id;\n\t\tdevhandle = device_id;\n\t}\n\n\treturn devhandle;\n}\n\n \n\nint megasas_task_abort_fusion(struct scsi_cmnd *scmd)\n{\n\tstruct megasas_instance *instance;\n\tu16 smid, devhandle;\n\tint ret;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\tmr_device_priv_data = scmd->device->hostdata;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {\n\t\tdev_err(&instance->pdev->dev, \"Controller is not OPERATIONAL,\"\n\t\t\"SCSI host:%d\\n\", instance->host->host_no);\n\t\tret = FAILED;\n\t\treturn ret;\n\t}\n\n\tif (!mr_device_priv_data) {\n\t\tsdev_printk(KERN_INFO, scmd->device, \"device been deleted! \"\n\t\t\t\"scmd(%p)\\n\", scmd);\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tret = SUCCESS;\n\t\tgoto out;\n\t}\n\n\tif (!mr_device_priv_data->is_tm_capable) {\n\t\tret = FAILED;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&instance->reset_mutex);\n\n\tsmid = megasas_fusion_smid_lookup(scmd);\n\n\tif (!smid) {\n\t\tret = SUCCESS;\n\t\tscmd_printk(KERN_NOTICE, scmd, \"Command for which abort is\"\n\t\t\t\" issued is not found in outstanding commands\\n\");\n\t\tmutex_unlock(&instance->reset_mutex);\n\t\tgoto out;\n\t}\n\n\tdevhandle = megasas_get_tm_devhandle(scmd->device);\n\n\tif (devhandle == (u16)ULONG_MAX) {\n\t\tret = FAILED;\n\t\tsdev_printk(KERN_INFO, scmd->device,\n\t\t\t\"task abort issued for invalid devhandle\\n\");\n\t\tmutex_unlock(&instance->reset_mutex);\n\t\tgoto out;\n\t}\n\tsdev_printk(KERN_INFO, scmd->device,\n\t\t\"attempting task abort! scmd(0x%p) tm_dev_handle 0x%x\\n\",\n\t\tscmd, devhandle);\n\n\tmr_device_priv_data->tm_busy = true;\n\tret = megasas_issue_tm(instance, devhandle,\n\t\t\tscmd->device->channel, scmd->device->id, smid,\n\t\t\tMPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK,\n\t\t\tmr_device_priv_data);\n\tmr_device_priv_data->tm_busy = false;\n\n\tmutex_unlock(&instance->reset_mutex);\n\tscmd_printk(KERN_INFO, scmd, \"task abort %s!! scmd(0x%p)\\n\",\n\t\t\t((ret == SUCCESS) ? \"SUCCESS\" : \"FAILED\"), scmd);\nout:\n\tscsi_print_command(scmd);\n\tif (megasas_dbg_lvl & TM_DEBUG)\n\t\tmegasas_dump_fusion_io(scmd);\n\n\treturn ret;\n}\n\n \n\nint megasas_reset_target_fusion(struct scsi_cmnd *scmd)\n{\n\n\tstruct megasas_instance *instance;\n\tint ret = FAILED;\n\tu16 devhandle;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\tmr_device_priv_data = scmd->device->hostdata;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {\n\t\tdev_err(&instance->pdev->dev, \"Controller is not OPERATIONAL,\"\n\t\t\"SCSI host:%d\\n\", instance->host->host_no);\n\t\tret = FAILED;\n\t\treturn ret;\n\t}\n\n\tif (!mr_device_priv_data) {\n\t\tsdev_printk(KERN_INFO, scmd->device,\n\t\t\t    \"device been deleted! scmd: (0x%p)\\n\", scmd);\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tret = SUCCESS;\n\t\tgoto out;\n\t}\n\n\tif (!mr_device_priv_data->is_tm_capable) {\n\t\tret = FAILED;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&instance->reset_mutex);\n\tdevhandle = megasas_get_tm_devhandle(scmd->device);\n\n\tif (devhandle == (u16)ULONG_MAX) {\n\t\tret = FAILED;\n\t\tsdev_printk(KERN_INFO, scmd->device,\n\t\t\t\"target reset issued for invalid devhandle\\n\");\n\t\tmutex_unlock(&instance->reset_mutex);\n\t\tgoto out;\n\t}\n\n\tsdev_printk(KERN_INFO, scmd->device,\n\t\t\"attempting target reset! scmd(0x%p) tm_dev_handle: 0x%x\\n\",\n\t\tscmd, devhandle);\n\tmr_device_priv_data->tm_busy = true;\n\tret = megasas_issue_tm(instance, devhandle,\n\t\t\tscmd->device->channel, scmd->device->id, 0,\n\t\t\tMPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET,\n\t\t\tmr_device_priv_data);\n\tmr_device_priv_data->tm_busy = false;\n\tmutex_unlock(&instance->reset_mutex);\n\tscmd_printk(KERN_NOTICE, scmd, \"target reset %s!!\\n\",\n\t\t(ret == SUCCESS) ? \"SUCCESS\" : \"FAILED\");\n\nout:\n\treturn ret;\n}\n\n \nstatic struct\nmegasas_instance *megasas_get_peer_instance(struct megasas_instance *instance)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_MGMT_ADAPTERS; i++) {\n\t\tif (megasas_mgmt_info.instance[i] &&\n\t\t\t(megasas_mgmt_info.instance[i] != instance) &&\n\t\t\t megasas_mgmt_info.instance[i]->requestorId &&\n\t\t\t megasas_mgmt_info.instance[i]->peerIsPresent &&\n\t\t\t(memcmp((megasas_mgmt_info.instance[i]->clusterId),\n\t\t\tinstance->clusterId, MEGASAS_CLUSTER_ID_SIZE) == 0))\n\t\t\treturn megasas_mgmt_info.instance[i];\n\t}\n\treturn NULL;\n}\n\n \nint megasas_check_mpio_paths(struct megasas_instance *instance,\n\tstruct scsi_cmnd *scmd)\n{\n\tstruct megasas_instance *peer_instance = NULL;\n\tint retval = (DID_REQUEUE << 16);\n\n\tif (instance->peerIsPresent) {\n\t\tpeer_instance = megasas_get_peer_instance(instance);\n\t\tif ((peer_instance) &&\n\t\t\t(atomic_read(&peer_instance->adprecovery) ==\n\t\t\tMEGASAS_HBA_OPERATIONAL))\n\t\t\tretval = (DID_NO_CONNECT << 16);\n\t}\n\treturn retval;\n}\n\n \nint megasas_reset_fusion(struct Scsi_Host *shost, int reason)\n{\n\tint retval = SUCCESS, i, j, convert = 0;\n\tstruct megasas_instance *instance;\n\tstruct megasas_cmd_fusion *cmd_fusion, *r1_cmd;\n\tstruct fusion_context *fusion;\n\tu32 abs_state, status_reg, reset_adapter, fpio_count = 0;\n\tu32 io_timeout_in_crash_mode = 0;\n\tstruct scsi_cmnd *scmd_local = NULL;\n\tstruct scsi_device *sdev;\n\tint ret_target_prop = DCMD_FAILED;\n\tbool is_target_prop = false;\n\tbool do_adp_reset = true;\n\tint max_reset_tries = MEGASAS_FUSION_MAX_RESET_TRIES;\n\n\tinstance = (struct megasas_instance *)shost->hostdata;\n\tfusion = instance->ctrl_context;\n\n\tmutex_lock(&instance->reset_mutex);\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_warn(&instance->pdev->dev, \"Hardware critical error, \"\n\t\t       \"returning FAILED for scsi%d.\\n\",\n\t\t\tinstance->host->host_no);\n\t\tmutex_unlock(&instance->reset_mutex);\n\t\treturn FAILED;\n\t}\n\tstatus_reg = instance->instancet->read_fw_status_reg(instance);\n\tabs_state = status_reg & MFI_STATE_MASK;\n\n\t \n\tif (abs_state != MFI_STATE_FAULT && instance->crash_dump_buf &&\n\t\tinstance->crash_dump_app_support && reason) {\n\t\tdev_info(&instance->pdev->dev, \"IO/DCMD timeout is detected, \"\n\t\t\t\"forcibly FAULT Firmware\\n\");\n\t\tatomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_INFAULT);\n\t\tstatus_reg = megasas_readl(instance, &instance->reg_set->doorbell);\n\t\twritel(status_reg | MFI_STATE_FORCE_OCR,\n\t\t\t&instance->reg_set->doorbell);\n\t\treadl(&instance->reg_set->doorbell);\n\t\tmutex_unlock(&instance->reset_mutex);\n\t\tdo {\n\t\t\tssleep(3);\n\t\t\tio_timeout_in_crash_mode++;\n\t\t\tdev_dbg(&instance->pdev->dev, \"waiting for [%d] \"\n\t\t\t\t\"seconds for crash dump collection and OCR \"\n\t\t\t\t\"to be done\\n\", (io_timeout_in_crash_mode * 3));\n\t\t} while ((atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) &&\n\t\t\t(io_timeout_in_crash_mode < 80));\n\n\t\tif (atomic_read(&instance->adprecovery) == MEGASAS_HBA_OPERATIONAL) {\n\t\t\tdev_info(&instance->pdev->dev, \"OCR done for IO \"\n\t\t\t\t\"timeout case\\n\");\n\t\t\tretval = SUCCESS;\n\t\t} else {\n\t\t\tdev_info(&instance->pdev->dev, \"Controller is not \"\n\t\t\t\t\"operational after 240 seconds wait for IO \"\n\t\t\t\t\"timeout case in FW crash dump mode\\n do \"\n\t\t\t\t\"OCR/kill adapter\\n\");\n\t\t\tretval = megasas_reset_fusion(shost, 0);\n\t\t}\n\t\treturn retval;\n\t}\n\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\n\tset_bit(MEGASAS_FUSION_IN_RESET, &instance->reset_flags);\n\tset_bit(MEGASAS_FUSION_OCR_NOT_POSSIBLE, &instance->reset_flags);\n\tatomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_POLLING);\n\tinstance->instancet->disable_intr(instance);\n\tmegasas_sync_irqs((unsigned long)instance);\n\n\t \n\tif (megasas_wait_for_outstanding_fusion(instance, reason,\n\t\t\t\t\t\t&convert)) {\n\t\tatomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_INFAULT);\n\t\tdev_warn(&instance->pdev->dev, \"resetting fusion \"\n\t\t       \"adapter scsi%d.\\n\", instance->host->host_no);\n\t\tif (convert)\n\t\t\treason = 0;\n\n\t\tif (megasas_dbg_lvl & OCR_DEBUG)\n\t\t\tdev_info(&instance->pdev->dev, \"\\nPending SCSI commands:\\n\");\n\n\t\t \n\t\tfor (i = 0 ; i < instance->max_scsi_cmds; i++) {\n\t\t\tcmd_fusion = fusion->cmd_list[i];\n\t\t\t \n\t\t\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\t\t\tr1_cmd = fusion->cmd_list[i + instance->max_fw_cmds];\n\t\t\t\tmegasas_return_cmd_fusion(instance, r1_cmd);\n\t\t\t}\n\t\t\tscmd_local = cmd_fusion->scmd;\n\t\t\tif (cmd_fusion->scmd) {\n\t\t\t\tif (megasas_dbg_lvl & OCR_DEBUG) {\n\t\t\t\t\tsdev_printk(KERN_INFO,\n\t\t\t\t\t\tcmd_fusion->scmd->device, \"SMID: 0x%x\\n\",\n\t\t\t\t\t\tcmd_fusion->index);\n\t\t\t\t\tmegasas_dump_fusion_io(cmd_fusion->scmd);\n\t\t\t\t}\n\n\t\t\t\tif (cmd_fusion->io_request->Function ==\n\t\t\t\t\tMPI2_FUNCTION_SCSI_IO_REQUEST)\n\t\t\t\t\tfpio_count++;\n\n\t\t\t\tscmd_local->result =\n\t\t\t\t\tmegasas_check_mpio_paths(instance,\n\t\t\t\t\t\t\tscmd_local);\n\t\t\t\tif (instance->ldio_threshold &&\n\t\t\t\t\tmegasas_cmd_type(scmd_local) == READ_WRITE_LDIO)\n\t\t\t\t\tatomic_dec(&instance->ldio_outstanding);\n\t\t\t\tmegasas_return_cmd_fusion(instance, cmd_fusion);\n\t\t\t\tscsi_dma_unmap(scmd_local);\n\t\t\t\tscsi_done(scmd_local);\n\t\t\t}\n\t\t}\n\n\t\tdev_info(&instance->pdev->dev, \"Outstanding fastpath IOs: %d\\n\",\n\t\t\tfpio_count);\n\n\t\tatomic_set(&instance->fw_outstanding, 0);\n\n\t\tstatus_reg = instance->instancet->read_fw_status_reg(instance);\n\t\tabs_state = status_reg & MFI_STATE_MASK;\n\t\treset_adapter = status_reg & MFI_RESET_ADAPTER;\n\t\tif (instance->disableOnlineCtrlReset ||\n\t\t    (abs_state == MFI_STATE_FAULT && !reset_adapter)) {\n\t\t\t \n\t\t\tdev_warn(&instance->pdev->dev, \"Reset not supported\"\n\t\t\t       \", killing adapter scsi%d.\\n\",\n\t\t\t\tinstance->host->host_no);\n\t\t\tgoto kill_hba;\n\t\t}\n\n\t\t \n\t\tif (instance->requestorId && !reason) {\n\t\t\tmsleep(MEGASAS_OCR_SETTLE_TIME_VF);\n\t\t\tdo_adp_reset = false;\n\t\t\tmax_reset_tries = MEGASAS_SRIOV_MAX_RESET_TRIES_VF;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < max_reset_tries; i++) {\n\t\t\t \n\t\t\tif (megasas_adp_reset_wait_for_ready(instance,\n\t\t\t\tdo_adp_reset, 1) == FAILED)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (megasas_transition_to_ready(instance, 1)) {\n\t\t\t\tdev_warn(&instance->pdev->dev,\n\t\t\t\t\t\"Failed to transition controller to ready for \"\n\t\t\t\t\t\"scsi%d.\\n\", instance->host->host_no);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmegasas_reset_reply_desc(instance);\n\t\t\tmegasas_fusion_update_can_queue(instance, OCR_CONTEXT);\n\n\t\t\tif (megasas_ioc_init_fusion(instance)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (megasas_get_ctrl_info(instance)) {\n\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t\"Failed from %s %d\\n\",\n\t\t\t\t\t__func__, __LINE__);\n\t\t\t\tgoto kill_hba;\n\t\t\t}\n\n\t\t\tmegasas_refire_mgmt_cmd(instance,\n\t\t\t\t\t\t(i == (MEGASAS_FUSION_MAX_RESET_TRIES - 1)\n\t\t\t\t\t\t\t? 1 : 0));\n\n\t\t\t \n\t\t\tif (fusion->load_balance_info)\n\t\t\t\tmemset(fusion->load_balance_info, 0,\n\t\t\t\t       (sizeof(struct LD_LOAD_BALANCE_INFO) *\n\t\t\t\t       MAX_LOGICAL_DRIVES_EXT));\n\n\t\t\tif (!megasas_get_map_info(instance)) {\n\t\t\t\tmegasas_sync_map_info(instance);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmegasas_return_polled_cmds(instance);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmegasas_setup_jbod_map(instance);\n\n\t\t\t \n\t\t\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\t\t\tfor (j = 0; j < MAX_LOGICAL_DRIVES_EXT; ++j) {\n\t\t\t\t\tmemset(fusion->stream_detect_by_ld[j],\n\t\t\t\t\t       0, sizeof(struct LD_STREAM_DETECT));\n\t\t\t\t\tfusion->stream_detect_by_ld[j]->mru_bit_map\n\t\t\t\t\t\t= MR_STREAM_BITMAP;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclear_bit(MEGASAS_FUSION_IN_RESET,\n\t\t\t\t  &instance->reset_flags);\n\t\t\tinstance->instancet->enable_intr(instance);\n\t\t\tmegasas_enable_irq_poll(instance);\n\t\t\tshost_for_each_device(sdev, shost) {\n\t\t\t\tif ((instance->tgt_prop) &&\n\t\t\t\t    (instance->nvme_page_size))\n\t\t\t\t\tret_target_prop = megasas_get_target_prop(instance, sdev);\n\n\t\t\t\tis_target_prop = (ret_target_prop == DCMD_SUCCESS) ? true : false;\n\t\t\t\tmegasas_set_dynamic_target_properties(sdev, is_target_prop);\n\t\t\t}\n\n\t\t\tstatus_reg = instance->instancet->read_fw_status_reg\n\t\t\t\t\t(instance);\n\t\t\tabs_state = status_reg & MFI_STATE_MASK;\n\t\t\tif (abs_state != MFI_STATE_OPERATIONAL) {\n\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t \"Adapter is not OPERATIONAL, state 0x%x for scsi:%d\\n\",\n\t\t\t\t\t abs_state, instance->host->host_no);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tatomic_set(&instance->adprecovery, MEGASAS_HBA_OPERATIONAL);\n\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t \"Adapter is OPERATIONAL for scsi:%d\\n\",\n\t\t\t\t instance->host->host_no);\n\n\t\t\t \n\t\t\tif (instance->requestorId) {\n\t\t\t\tif (!megasas_sriov_start_heartbeat(instance, 0))\n\t\t\t\t\tmegasas_start_timer(instance);\n\t\t\t\telse\n\t\t\t\t\tinstance->skip_heartbeat_timer_del = 1;\n\t\t\t}\n\n\t\t\tif (instance->crash_dump_drv_support &&\n\t\t\t\tinstance->crash_dump_app_support)\n\t\t\t\tmegasas_set_crash_dump_params(instance,\n\t\t\t\t\tMR_CRASH_BUF_TURN_ON);\n\t\t\telse\n\t\t\t\tmegasas_set_crash_dump_params(instance,\n\t\t\t\t\tMR_CRASH_BUF_TURN_OFF);\n\n\t\t\tif (instance->snapdump_wait_time) {\n\t\t\t\tmegasas_get_snapdump_properties(instance);\n\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t \"Snap dump wait time\\t: %d\\n\",\n\t\t\t\t\t instance->snapdump_wait_time);\n\t\t\t}\n\n\t\t\tretval = SUCCESS;\n\n\t\t\t \n\t\t\tdev_warn(&instance->pdev->dev,\n\t\t\t\t \"Reset successful for scsi%d.\\n\",\n\t\t\t\t instance->host->host_no);\n\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tdev_warn(&instance->pdev->dev, \"Reset failed, killing \"\n\t\t       \"adapter scsi%d.\\n\", instance->host->host_no);\n\t\tgoto kill_hba;\n\t} else {\n\t\t \n\t\tif (instance->requestorId) {\n\t\t\tmegasas_start_timer(instance);\n\t\t}\n\t\tclear_bit(MEGASAS_FUSION_IN_RESET, &instance->reset_flags);\n\t\tinstance->instancet->enable_intr(instance);\n\t\tmegasas_enable_irq_poll(instance);\n\t\tatomic_set(&instance->adprecovery, MEGASAS_HBA_OPERATIONAL);\n\t\tgoto out;\n\t}\nkill_hba:\n\tmegaraid_sas_kill_hba(instance);\n\tmegasas_enable_irq_poll(instance);\n\tinstance->skip_heartbeat_timer_del = 1;\n\tretval = FAILED;\nout:\n\tclear_bit(MEGASAS_FUSION_OCR_NOT_POSSIBLE, &instance->reset_flags);\n\tmutex_unlock(&instance->reset_mutex);\n\treturn retval;\n}\n\n \nstatic void  megasas_fusion_crash_dump(struct megasas_instance *instance)\n{\n\tu32 status_reg;\n\tu8 partial_copy = 0;\n\tint wait = 0;\n\n\n\tstatus_reg = instance->instancet->read_fw_status_reg(instance);\n\n\t \n\tif (instance->drv_buf_index == 0) {\n\t\t \n\t\tif (instance->drv_buf_alloc) {\n\t\t\tdev_info(&instance->pdev->dev, \"earlier crash dump is \"\n\t\t\t\t\"not yet copied by application, ignoring this \"\n\t\t\t\t\"crash dump and initiating OCR\\n\");\n\t\t\tstatus_reg |= MFI_STATE_CRASH_DUMP_DONE;\n\t\t\twritel(status_reg,\n\t\t\t\t&instance->reg_set->outbound_scratch_pad_0);\n\t\t\treadl(&instance->reg_set->outbound_scratch_pad_0);\n\t\t\treturn;\n\t\t}\n\t\tmegasas_alloc_host_crash_buffer(instance);\n\t\tdev_info(&instance->pdev->dev, \"Number of host crash buffers \"\n\t\t\t\"allocated: %d\\n\", instance->drv_buf_alloc);\n\t}\n\n\twhile (!(status_reg & MFI_STATE_CRASH_DUMP_DONE) &&\n\t       (wait < MEGASAS_WATCHDOG_WAIT_COUNT)) {\n\t\tif (!(status_reg & MFI_STATE_DMADONE)) {\n\t\t\t \n\t\t\twait++;\n\t\t\tmsleep(MEGASAS_WAIT_FOR_NEXT_DMA_MSECS);\n\t\t\tstatus_reg = instance->instancet->read_fw_status_reg(\n\t\t\t\t\tinstance);\n\t\t\tcontinue;\n\t\t}\n\n\t\twait = 0;\n\t\tif (instance->drv_buf_index >= instance->drv_buf_alloc) {\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t \"Driver is done copying the buffer: %d\\n\",\n\t\t\t\t instance->drv_buf_alloc);\n\t\t\tstatus_reg |= MFI_STATE_CRASH_DUMP_DONE;\n\t\t\tpartial_copy = 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tmemcpy(instance->crash_buf[instance->drv_buf_index],\n\t\t\t       instance->crash_dump_buf, CRASH_DMA_BUF_SIZE);\n\t\t\tinstance->drv_buf_index++;\n\t\t\tstatus_reg &= ~MFI_STATE_DMADONE;\n\t\t}\n\n\t\twritel(status_reg, &instance->reg_set->outbound_scratch_pad_0);\n\t\treadl(&instance->reg_set->outbound_scratch_pad_0);\n\n\t\tmsleep(MEGASAS_WAIT_FOR_NEXT_DMA_MSECS);\n\t\tstatus_reg = instance->instancet->read_fw_status_reg(instance);\n\t}\n\n\tif (status_reg & MFI_STATE_CRASH_DUMP_DONE) {\n\t\tdev_info(&instance->pdev->dev, \"Crash Dump is available,number \"\n\t\t\t\"of copied buffers: %d\\n\", instance->drv_buf_index);\n\t\tinstance->fw_crash_buffer_size =  instance->drv_buf_index;\n\t\tinstance->fw_crash_state = AVAILABLE;\n\t\tinstance->drv_buf_index = 0;\n\t\twritel(status_reg, &instance->reg_set->outbound_scratch_pad_0);\n\t\treadl(&instance->reg_set->outbound_scratch_pad_0);\n\t\tif (!partial_copy)\n\t\t\tmegasas_reset_fusion(instance->host, 0);\n\t}\n}\n\n\n \nvoid megasas_fusion_ocr_wq(struct work_struct *work)\n{\n\tstruct megasas_instance *instance =\n\t\tcontainer_of(work, struct megasas_instance, work_init);\n\n\tmegasas_reset_fusion(instance->host, 0);\n}\n\n \nint\nmegasas_alloc_fusion_context(struct megasas_instance *instance)\n{\n\tstruct fusion_context *fusion;\n\n\tinstance->ctrl_context = kzalloc(sizeof(struct fusion_context),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!instance->ctrl_context) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfusion = instance->ctrl_context;\n\n\tfusion->log_to_span_pages = get_order(MAX_LOGICAL_DRIVES_EXT *\n\t\t\t\t\t      sizeof(LD_SPAN_INFO));\n\tfusion->log_to_span =\n\t\t(PLD_SPAN_INFO)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\t\t\t\t\tfusion->log_to_span_pages);\n\tif (!fusion->log_to_span) {\n\t\tfusion->log_to_span =\n\t\t\tvzalloc(array_size(MAX_LOGICAL_DRIVES_EXT,\n\t\t\t\t\t   sizeof(LD_SPAN_INFO)));\n\t\tif (!fusion->log_to_span) {\n\t\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfusion->load_balance_info_pages = get_order(MAX_LOGICAL_DRIVES_EXT *\n\t\tsizeof(struct LD_LOAD_BALANCE_INFO));\n\tfusion->load_balance_info =\n\t\t(struct LD_LOAD_BALANCE_INFO *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\tfusion->load_balance_info_pages);\n\tif (!fusion->load_balance_info) {\n\t\tfusion->load_balance_info =\n\t\t\tvzalloc(array_size(MAX_LOGICAL_DRIVES_EXT,\n\t\t\t\t\t   sizeof(struct LD_LOAD_BALANCE_INFO)));\n\t\tif (!fusion->load_balance_info)\n\t\t\tdev_err(&instance->pdev->dev, \"Failed to allocate load_balance_info, \"\n\t\t\t\t\"continuing without Load Balance support\\n\");\n\t}\n\n\treturn 0;\n}\n\nvoid\nmegasas_free_fusion_context(struct megasas_instance *instance)\n{\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\tif (fusion) {\n\t\tif (fusion->load_balance_info) {\n\t\t\tif (is_vmalloc_addr(fusion->load_balance_info))\n\t\t\t\tvfree(fusion->load_balance_info);\n\t\t\telse\n\t\t\t\tfree_pages((ulong)fusion->load_balance_info,\n\t\t\t\t\tfusion->load_balance_info_pages);\n\t\t}\n\n\t\tif (fusion->log_to_span) {\n\t\t\tif (is_vmalloc_addr(fusion->log_to_span))\n\t\t\t\tvfree(fusion->log_to_span);\n\t\t\telse\n\t\t\t\tfree_pages((ulong)fusion->log_to_span,\n\t\t\t\t\t   fusion->log_to_span_pages);\n\t\t}\n\n\t\tkfree(fusion);\n\t}\n}\n\nstruct megasas_instance_template megasas_instance_template_fusion = {\n\t.enable_intr = megasas_enable_intr_fusion,\n\t.disable_intr = megasas_disable_intr_fusion,\n\t.clear_intr = megasas_clear_intr_fusion,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_fusion,\n\t.adp_reset = megasas_adp_reset_fusion,\n\t.check_reset = megasas_check_reset_fusion,\n\t.service_isr = megasas_isr_fusion,\n\t.tasklet = megasas_complete_cmd_dpc_fusion,\n\t.init_adapter = megasas_init_adapter_fusion,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd_fusion,\n\t.issue_dcmd = megasas_issue_dcmd_fusion,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}