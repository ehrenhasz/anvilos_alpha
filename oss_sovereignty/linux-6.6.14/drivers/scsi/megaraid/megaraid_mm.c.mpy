{
  "module_name": "megaraid_mm.c",
  "hash_id": "96ed7ba7a6f83addccd09db5f61cfdba6aa3c16b5cff4ce5ce4133b815acb6db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/megaraid/megaraid_mm.c",
  "human_readable_source": "\n \n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include \"megaraid_mm.h\"\n\n\n\nstatic DEFINE_MUTEX(mraid_mm_mutex);\nstatic int mraid_mm_open(struct inode *, struct file *);\nstatic long mraid_mm_unlocked_ioctl(struct file *, uint, unsigned long);\n\n\n\nstatic int mimd_to_kioc(mimd_t __user *, mraid_mmadp_t *, uioc_t *);\nstatic int kioc_to_mimd(uioc_t *, mimd_t __user *);\n\n\n\nstatic int handle_drvrcmd(void __user *, uint8_t, int *);\nstatic int lld_ioctl(mraid_mmadp_t *, uioc_t *);\nstatic void ioctl_done(uioc_t *);\nstatic void lld_timedout(struct timer_list *);\nstatic void hinfo_to_cinfo(mraid_hba_info_t *, mcontroller_t *);\nstatic mraid_mmadp_t *mraid_mm_get_adapter(mimd_t __user *, int *);\nstatic uioc_t *mraid_mm_alloc_kioc(mraid_mmadp_t *);\nstatic void mraid_mm_dealloc_kioc(mraid_mmadp_t *, uioc_t *);\nstatic int mraid_mm_attach_buf(mraid_mmadp_t *, uioc_t *, int);\nstatic int mraid_mm_setup_dma_pools(mraid_mmadp_t *);\nstatic void mraid_mm_free_adp_resources(mraid_mmadp_t *);\nstatic void mraid_mm_teardown_dma_pools(mraid_mmadp_t *);\n\nMODULE_AUTHOR(\"LSI Logic Corporation\");\nMODULE_DESCRIPTION(\"LSI Logic Management Module\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(LSI_COMMON_MOD_VERSION);\n\nstatic int dbglevel = CL_ANN;\nmodule_param_named(dlevel, dbglevel, int, 0);\nMODULE_PARM_DESC(dlevel, \"Debug level (default=0)\");\n\nEXPORT_SYMBOL(mraid_mm_register_adp);\nEXPORT_SYMBOL(mraid_mm_unregister_adp);\nEXPORT_SYMBOL(mraid_mm_adapter_app_handle);\n\nstatic uint32_t drvr_ver\t= 0x02200207;\n\nstatic int adapters_count_g;\nstatic struct list_head adapters_list_g;\n\nstatic wait_queue_head_t wait_q;\n\nstatic const struct file_operations lsi_fops = {\n\t.open\t= mraid_mm_open,\n\t.unlocked_ioctl = mraid_mm_unlocked_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.owner\t= THIS_MODULE,\n\t.llseek = noop_llseek,\n};\n\nstatic struct miscdevice megaraid_mm_dev = {\n\t.minor\t= MISC_DYNAMIC_MINOR,\n\t.name   = \"megadev0\",\n\t.fops   = &lsi_fops,\n};\n\n \nstatic int\nmraid_mm_open(struct inode *inode, struct file *filep)\n{\n\t \n\tif (!capable(CAP_SYS_ADMIN)) return (-EACCES);\n\n\treturn 0;\n}\n\n \nstatic int\nmraid_mm_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\n{\n\tuioc_t\t\t*kioc;\n\tchar\t\tsignature[EXT_IOCTL_SIGN_SZ]\t= {0};\n\tint\t\trval;\n\tmraid_mmadp_t\t*adp;\n\tuint8_t\t\told_ioctl;\n\tint\t\tdrvrcmd_rval;\n\tvoid __user *argp = (void __user *)arg;\n\n\t \n\n\tif ((_IOC_TYPE(cmd) != MEGAIOC_MAGIC) && (cmd != USCSICMD)) {\n\t\treturn (-EINVAL);\n\t}\n\n\t \n\tif (copy_from_user(signature, argp, EXT_IOCTL_SIGN_SZ)) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid cmm: copy from usr addr failed\\n\"));\n\t\treturn (-EFAULT);\n\t}\n\n\tif (memcmp(signature, EXT_IOCTL_SIGN, EXT_IOCTL_SIGN_SZ) == 0)\n\t\told_ioctl = 0;\n\telse\n\t\told_ioctl = 1;\n\n\t \n\tif (!old_ioctl )\n\t\treturn (-EINVAL);\n\n\t \n\trval = handle_drvrcmd(argp, old_ioctl, &drvrcmd_rval);\n\n\tif (rval < 0)\n\t\treturn rval;\n\telse if (rval == 0)\n\t\treturn drvrcmd_rval;\n\n\trval = 0;\n\tif ((adp = mraid_mm_get_adapter(argp, &rval)) == NULL) {\n\t\treturn rval;\n\t}\n\n\t \n\tif (!adp->quiescent) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid cmm: controller cannot accept cmds due to \"\n\t\t\t\"earlier errors\\n\" ));\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tkioc = mraid_mm_alloc_kioc(adp);\n\tif (!kioc)\n\t\treturn -ENXIO;\n\n\t \n\tif ((rval = mimd_to_kioc(argp, adp, kioc))) {\n\t\tmraid_mm_dealloc_kioc(adp, kioc);\n\t\treturn rval;\n\t}\n\n\tkioc->done = ioctl_done;\n\n\t \n\tif ((rval = lld_ioctl(adp, kioc))) {\n\n\t\tif (!kioc->timedout)\n\t\t\tmraid_mm_dealloc_kioc(adp, kioc);\n\n\t\treturn rval;\n\t}\n\n\t \n\trval = kioc_to_mimd(kioc, argp);\n\n\t \n\tmraid_mm_dealloc_kioc(adp, kioc);\n\n\treturn rval;\n}\n\nstatic long\nmraid_mm_unlocked_ioctl(struct file *filep, unsigned int cmd,\n\t\t        unsigned long arg)\n{\n\tint err;\n\n\tmutex_lock(&mraid_mm_mutex);\n\terr = mraid_mm_ioctl(filep, cmd, arg);\n\tmutex_unlock(&mraid_mm_mutex);\n\n\treturn err;\n}\n\n \nstatic mraid_mmadp_t *\nmraid_mm_get_adapter(mimd_t __user *umimd, int *rval)\n{\n\tmraid_mmadp_t\t*adapter;\n\tmimd_t\t\tmimd;\n\tuint32_t\tadapno;\n\tint\t\titerator;\n\tbool\t\tis_found;\n\n\tif (copy_from_user(&mimd, umimd, sizeof(mimd_t))) {\n\t\t*rval = -EFAULT;\n\t\treturn NULL;\n\t}\n\n\tadapno = GETADAP(mimd.ui.fcs.adapno);\n\n\tif (adapno >= adapters_count_g) {\n\t\t*rval = -ENODEV;\n\t\treturn NULL;\n\t}\n\n\tadapter = NULL;\n\titerator = 0;\n\tis_found = false;\n\n\tlist_for_each_entry(adapter, &adapters_list_g, list) {\n\t\tif (iterator++ == adapno) {\n\t\t\tis_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!is_found) {\n\t\t*rval = -ENODEV;\n\t\treturn NULL;\n\t}\n\n\treturn adapter;\n}\n\n \nstatic int\nhandle_drvrcmd(void __user *arg, uint8_t old_ioctl, int *rval)\n{\n\tmimd_t\t\t__user *umimd;\n\tmimd_t\t\tkmimd;\n\tuint8_t\t\topcode;\n\tuint8_t\t\tsubopcode;\n\n\tif (old_ioctl)\n\t\tgoto old_packet;\n\telse\n\t\tgoto new_packet;\n\nnew_packet:\n\treturn (-ENOTSUPP);\n\nold_packet:\n\t*rval = 0;\n\tumimd = arg;\n\n\tif (copy_from_user(&kmimd, umimd, sizeof(mimd_t)))\n\t\treturn (-EFAULT);\n\n\topcode\t\t= kmimd.ui.fcs.opcode;\n\tsubopcode\t= kmimd.ui.fcs.subopcode;\n\n\t \n\tif (opcode != 0x82)\n\t\treturn 1;\n\n\tswitch (subopcode) {\n\n\tcase MEGAIOC_QDRVRVER:\n\n\t\tif (copy_to_user(kmimd.data, &drvr_ver, sizeof(uint32_t)))\n\t\t\treturn (-EFAULT);\n\n\t\treturn 0;\n\n\tcase MEGAIOC_QNADAP:\n\n\t\t*rval = adapters_count_g;\n\n\t\tif (copy_to_user(kmimd.data, &adapters_count_g,\n\t\t\t\tsizeof(uint32_t)))\n\t\t\treturn (-EFAULT);\n\n\t\treturn 0;\n\n\tdefault:\n\t\t \n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n \n\nstatic int\nmimd_to_kioc(mimd_t __user *umimd, mraid_mmadp_t *adp, uioc_t *kioc)\n{\n\tmbox64_t\t\t*mbox64;\n\tmbox_t\t\t\t*mbox;\n\tmraid_passthru_t\t*pthru32;\n\tuint32_t\t\tadapno;\n\tuint8_t\t\t\topcode;\n\tuint8_t\t\t\tsubopcode;\n\tmimd_t\t\t\tmimd;\n\n\tif (copy_from_user(&mimd, umimd, sizeof(mimd_t)))\n\t\treturn (-EFAULT);\n\n\t \n\tif ((mimd.mbox[0] == MBOXCMD_PASSTHRU64) ||\n\t\t\t(mimd.mbox[0] == MBOXCMD_EXTPTHRU))\n\t\treturn (-EINVAL);\n\n\topcode\t\t= mimd.ui.fcs.opcode;\n\tsubopcode\t= mimd.ui.fcs.subopcode;\n\tadapno\t\t= GETADAP(mimd.ui.fcs.adapno);\n\n\tif (adapno >= adapters_count_g)\n\t\treturn (-ENODEV);\n\n\tkioc->adapno\t= adapno;\n\tkioc->mb_type\t= MBOX_LEGACY;\n\tkioc->app_type\t= APPTYPE_MIMD;\n\n\tswitch (opcode) {\n\n\tcase 0x82:\n\n\t\tif (subopcode == MEGAIOC_QADAPINFO) {\n\n\t\t\tkioc->opcode\t= GET_ADAP_INFO;\n\t\t\tkioc->data_dir\t= UIOC_RD;\n\t\t\tkioc->xferlen\t= sizeof(mraid_hba_info_t);\n\n\t\t\tif (mraid_mm_attach_buf(adp, kioc, kioc->xferlen))\n\t\t\t\treturn (-ENOMEM);\n\t\t}\n\t\telse {\n\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\t\"megaraid cmm: Invalid subop\\n\"));\n\t\t\treturn (-EINVAL);\n\t\t}\n\n\t\tbreak;\n\n\tcase 0x81:\n\n\t\tkioc->opcode\t\t= MBOX_CMD;\n\t\tkioc->xferlen\t\t= mimd.ui.fcs.length;\n\t\tkioc->user_data_len\t= kioc->xferlen;\n\t\tkioc->user_data\t\t= mimd.ui.fcs.buffer;\n\n\t\tif (mraid_mm_attach_buf(adp, kioc, kioc->xferlen))\n\t\t\treturn (-ENOMEM);\n\n\t\tif (mimd.outlen) kioc->data_dir  = UIOC_RD;\n\t\tif (mimd.inlen) kioc->data_dir |= UIOC_WR;\n\n\t\tbreak;\n\n\tcase 0x80:\n\n\t\tkioc->opcode\t\t= MBOX_CMD;\n\t\tkioc->xferlen\t\t= (mimd.outlen > mimd.inlen) ?\n\t\t\t\t\t\tmimd.outlen : mimd.inlen;\n\t\tkioc->user_data_len\t= kioc->xferlen;\n\t\tkioc->user_data\t\t= mimd.data;\n\n\t\tif (mraid_mm_attach_buf(adp, kioc, kioc->xferlen))\n\t\t\treturn (-ENOMEM);\n\n\t\tif (mimd.outlen) kioc->data_dir  = UIOC_RD;\n\t\tif (mimd.inlen) kioc->data_dir |= UIOC_WR;\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn (-EINVAL);\n\t}\n\n\t \n\tif (opcode == 0x82)\n\t\treturn 0;\n\n\t \n\tmbox64\t= (mbox64_t *)((unsigned long)kioc->cmdbuf);\n\tmbox\t= &mbox64->mbox32;\n\tmemcpy(mbox, mimd.mbox, 14);\n\n\tif (mbox->cmd != MBOXCMD_PASSTHRU) {\t\n\n\t\tmbox->xferaddr\t= (uint32_t)kioc->buf_paddr;\n\n\t\tif (kioc->data_dir & UIOC_WR) {\n\t\t\tif (copy_from_user(kioc->buf_vaddr, kioc->user_data,\n\t\t\t\t\t\t\tkioc->xferlen)) {\n\t\t\t\treturn (-EFAULT);\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tpthru32\t\t\t= kioc->pthru32;\n\tkioc->user_pthru\t= &umimd->pthru;\n\tmbox->xferaddr\t\t= (uint32_t)kioc->pthru32_h;\n\n\tif (copy_from_user(pthru32, kioc->user_pthru,\n\t\t\tsizeof(mraid_passthru_t))) {\n\t\treturn (-EFAULT);\n\t}\n\n\tpthru32->dataxferaddr\t= kioc->buf_paddr;\n\tif (kioc->data_dir & UIOC_WR) {\n\t\tif (pthru32->dataxferlen > kioc->xferlen)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(kioc->buf_vaddr, kioc->user_data,\n\t\t\t\t\t\tpthru32->dataxferlen)) {\n\t\t\treturn (-EFAULT);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmraid_mm_attach_buf(mraid_mmadp_t *adp, uioc_t *kioc, int xferlen)\n{\n\tmm_dmapool_t\t*pool;\n\tint\t\tright_pool = -1;\n\tunsigned long\tflags;\n\tint\t\ti;\n\n\tkioc->pool_index\t= -1;\n\tkioc->buf_vaddr\t\t= NULL;\n\tkioc->buf_paddr\t\t= 0;\n\tkioc->free_buf\t\t= 0;\n\n\t \n\n\tfor (i = 0; i < MAX_DMA_POOLS; i++) {\n\n\t\tpool = &adp->dma_pool_list[i];\n\n\t\tif (xferlen > pool->buf_size)\n\t\t\tcontinue;\n\n\t\tif (right_pool == -1)\n\t\t\tright_pool = i;\n\n\t\tspin_lock_irqsave(&pool->lock, flags);\n\n\t\tif (!pool->in_use) {\n\n\t\t\tpool->in_use\t\t= 1;\n\t\t\tkioc->pool_index\t= i;\n\t\t\tkioc->buf_vaddr\t\t= pool->vaddr;\n\t\t\tkioc->buf_paddr\t\t= pool->paddr;\n\n\t\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t \n\tif (right_pool == -1)\n\t\treturn -EINVAL;\n\n\t \n\tpool = &adp->dma_pool_list[right_pool];\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\n\tkioc->pool_index\t= right_pool;\n\tkioc->free_buf\t\t= 1;\n\tkioc->buf_vaddr\t\t= dma_pool_alloc(pool->handle, GFP_ATOMIC,\n\t\t\t\t\t\t\t&kioc->buf_paddr);\n\tspin_unlock_irqrestore(&pool->lock, flags);\n\n\tif (!kioc->buf_vaddr)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstatic uioc_t *\nmraid_mm_alloc_kioc(mraid_mmadp_t *adp)\n{\n\tuioc_t\t\t\t*kioc;\n\tstruct list_head*\thead;\n\tunsigned long\t\tflags;\n\n\tdown(&adp->kioc_semaphore);\n\n\tspin_lock_irqsave(&adp->kioc_pool_lock, flags);\n\n\thead = &adp->kioc_pool;\n\n\tif (list_empty(head)) {\n\t\tup(&adp->kioc_semaphore);\n\t\tspin_unlock_irqrestore(&adp->kioc_pool_lock, flags);\n\n\t\tcon_log(CL_ANN, (\"megaraid cmm: kioc list empty!\\n\"));\n\t\treturn NULL;\n\t}\n\n\tkioc = list_entry(head->next, uioc_t, list);\n\tlist_del_init(&kioc->list);\n\n\tspin_unlock_irqrestore(&adp->kioc_pool_lock, flags);\n\n\tmemset((caddr_t)(unsigned long)kioc->cmdbuf, 0, sizeof(mbox64_t));\n\tmemset((caddr_t) kioc->pthru32, 0, sizeof(mraid_passthru_t));\n\n\tkioc->buf_vaddr\t\t= NULL;\n\tkioc->buf_paddr\t\t= 0;\n\tkioc->pool_index\t=-1;\n\tkioc->free_buf\t\t= 0;\n\tkioc->user_data\t\t= NULL;\n\tkioc->user_data_len\t= 0;\n\tkioc->user_pthru\t= NULL;\n\tkioc->timedout\t\t= 0;\n\n\treturn kioc;\n}\n\n \nstatic void\nmraid_mm_dealloc_kioc(mraid_mmadp_t *adp, uioc_t *kioc)\n{\n\tmm_dmapool_t\t*pool;\n\tunsigned long\tflags;\n\n\tif (kioc->pool_index != -1) {\n\t\tpool = &adp->dma_pool_list[kioc->pool_index];\n\n\t\t \n\t\tspin_lock_irqsave(&pool->lock, flags);\n\n\t\t \n\t\tif (kioc->free_buf == 1)\n\t\t\tdma_pool_free(pool->handle, kioc->buf_vaddr, \n\t\t\t\t\t\t\tkioc->buf_paddr);\n\t\telse\n\t\t\tpool->in_use = 0;\n\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t}\n\n\t \n\tspin_lock_irqsave(&adp->kioc_pool_lock, flags);\n\tlist_add(&kioc->list, &adp->kioc_pool);\n\tspin_unlock_irqrestore(&adp->kioc_pool_lock, flags);\n\n\t \n\tup(&adp->kioc_semaphore);\n\n\treturn;\n}\n\n \nstatic int\nlld_ioctl(mraid_mmadp_t *adp, uioc_t *kioc)\n{\n\tint\t\t\trval;\n\tstruct uioc_timeout\ttimeout = { };\n\n\tkioc->status\t= -ENODATA;\n\trval\t\t= adp->issue_uioc(adp->drvr_data, kioc, IOCTL_ISSUE);\n\n\tif (rval) return rval;\n\n\t \n\tif (adp->timeout > 0) {\n\t\ttimeout.uioc = kioc;\n\t\ttimer_setup_on_stack(&timeout.timer, lld_timedout, 0);\n\n\t\ttimeout.timer.expires\t= jiffies + adp->timeout * HZ;\n\n\t\tadd_timer(&timeout.timer);\n\t}\n\n\t \n\twait_event(wait_q, (kioc->status != -ENODATA));\n\tif (timeout.timer.function) {\n\t\tdel_timer_sync(&timeout.timer);\n\t\tdestroy_timer_on_stack(&timeout.timer);\n\t}\n\n\t \n\tif (kioc->timedout) {\n\t\tadp->quiescent = 0;\n\t}\n\n\treturn kioc->status;\n}\n\n\n \nstatic void\nioctl_done(uioc_t *kioc)\n{\n\tuint32_t\tadapno;\n\tint\t\titerator;\n\tmraid_mmadp_t*\tadapter;\n\tbool\t\tis_found;\n\n\t \n\tif (kioc->status == -ENODATA) {\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid cmm: lld didn't change status!\\n\"));\n\n\t\tkioc->status = -EINVAL;\n\t}\n\n\t \n\tif (kioc->timedout) {\n\t\titerator\t= 0;\n\t\tadapter\t\t= NULL;\n\t\tadapno\t\t= kioc->adapno;\n\t\tis_found\t= false;\n\n\t\tcon_log(CL_ANN, ( KERN_WARNING \"megaraid cmm: completed \"\n\t\t\t\t\t\"ioctl that was timedout before\\n\"));\n\n\t\tlist_for_each_entry(adapter, &adapters_list_g, list) {\n\t\t\tif (iterator++ == adapno) {\n\t\t\t\tis_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tkioc->timedout = 0;\n\n\t\tif (is_found)\n\t\t\tmraid_mm_dealloc_kioc( adapter, kioc );\n\n\t}\n\telse {\n\t\twake_up(&wait_q);\n\t}\n}\n\n\n \nstatic void\nlld_timedout(struct timer_list *t)\n{\n\tstruct uioc_timeout *timeout = from_timer(timeout, t, timer);\n\tuioc_t *kioc\t= timeout->uioc;\n\n\tkioc->status \t= -ETIME;\n\tkioc->timedout\t= 1;\n\n\tcon_log(CL_ANN, (KERN_WARNING \"megaraid cmm: ioctl timed out\\n\"));\n\n\twake_up(&wait_q);\n}\n\n\n \nstatic int\nkioc_to_mimd(uioc_t *kioc, mimd_t __user *mimd)\n{\n\tmimd_t\t\t\tkmimd;\n\tuint8_t\t\t\topcode;\n\tuint8_t\t\t\tsubopcode;\n\n\tmbox64_t\t\t*mbox64;\n\tmraid_passthru_t\t__user *upthru32;\n\tmraid_passthru_t\t*kpthru32;\n\tmcontroller_t\t\tcinfo;\n\tmraid_hba_info_t\t*hinfo;\n\n\n\tif (copy_from_user(&kmimd, mimd, sizeof(mimd_t)))\n\t\treturn (-EFAULT);\n\n\topcode\t\t= kmimd.ui.fcs.opcode;\n\tsubopcode\t= kmimd.ui.fcs.subopcode;\n\n\tif (opcode == 0x82) {\n\t\tswitch (subopcode) {\n\n\t\tcase MEGAIOC_QADAPINFO:\n\n\t\t\thinfo = (mraid_hba_info_t *)(unsigned long)\n\t\t\t\t\tkioc->buf_vaddr;\n\n\t\t\thinfo_to_cinfo(hinfo, &cinfo);\n\n\t\t\tif (copy_to_user(kmimd.data, &cinfo, sizeof(cinfo)))\n\t\t\t\treturn (-EFAULT);\n\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\treturn (-EINVAL);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tmbox64 = (mbox64_t *)(unsigned long)kioc->cmdbuf;\n\n\tif (kioc->user_pthru) {\n\n\t\tupthru32 = kioc->user_pthru;\n\t\tkpthru32 = kioc->pthru32;\n\n\t\tif (copy_to_user(&upthru32->scsistatus,\n\t\t\t\t\t&kpthru32->scsistatus,\n\t\t\t\t\tsizeof(uint8_t))) {\n\t\t\treturn (-EFAULT);\n\t\t}\n\t}\n\n\tif (kioc->user_data) {\n\t\tif (copy_to_user(kioc->user_data, kioc->buf_vaddr,\n\t\t\t\t\tkioc->user_data_len)) {\n\t\t\treturn (-EFAULT);\n\t\t}\n\t}\n\n\tif (copy_to_user(&mimd->mbox[17],\n\t\t\t&mbox64->mbox32.status, sizeof(uint8_t))) {\n\t\treturn (-EFAULT);\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic void\nhinfo_to_cinfo(mraid_hba_info_t *hinfo, mcontroller_t *cinfo)\n{\n\tif (!hinfo || !cinfo)\n\t\treturn;\n\n\tcinfo->base\t\t= hinfo->baseport;\n\tcinfo->irq\t\t= hinfo->irq;\n\tcinfo->numldrv\t\t= hinfo->num_ldrv;\n\tcinfo->pcibus\t\t= hinfo->pci_bus;\n\tcinfo->pcidev\t\t= hinfo->pci_slot;\n\tcinfo->pcifun\t\t= PCI_FUNC(hinfo->pci_dev_fn);\n\tcinfo->pciid\t\t= hinfo->pci_device_id;\n\tcinfo->pcivendor\t= hinfo->pci_vendor_id;\n\tcinfo->pcislot\t\t= hinfo->pci_slot;\n\tcinfo->uid\t\t= hinfo->unique_id;\n}\n\n\n \nint\nmraid_mm_register_adp(mraid_mmadp_t *lld_adp)\n{\n\tmraid_mmadp_t\t*adapter;\n\tmbox64_t\t*mbox_list;\n\tuioc_t\t\t*kioc;\n\tuint32_t\trval;\n\tint\t\ti;\n\n\n\tif (lld_adp->drvr_type != DRVRTYPE_MBOX)\n\t\treturn (-EINVAL);\n\n\tadapter = kzalloc(sizeof(mraid_mmadp_t), GFP_KERNEL);\n\n\tif (!adapter)\n\t\treturn -ENOMEM;\n\n\n\tadapter->unique_id\t= lld_adp->unique_id;\n\tadapter->drvr_type\t= lld_adp->drvr_type;\n\tadapter->drvr_data\t= lld_adp->drvr_data;\n\tadapter->pdev\t\t= lld_adp->pdev;\n\tadapter->issue_uioc\t= lld_adp->issue_uioc;\n\tadapter->timeout\t= lld_adp->timeout;\n\tadapter->max_kioc\t= lld_adp->max_kioc;\n\tadapter->quiescent\t= 1;\n\n\t \n\tadapter->kioc_list\t= kmalloc_array(lld_adp->max_kioc,\n\t\t\t\t\t\t  sizeof(uioc_t),\n\t\t\t\t\t\t  GFP_KERNEL);\n\tadapter->mbox_list\t= kmalloc_array(lld_adp->max_kioc,\n\t\t\t\t\t\t  sizeof(mbox64_t),\n\t\t\t\t\t\t  GFP_KERNEL);\n\tadapter->pthru_dma_pool = dma_pool_create(\"megaraid mm pthru pool\",\n\t\t\t\t\t\t&adapter->pdev->dev,\n\t\t\t\t\t\tsizeof(mraid_passthru_t),\n\t\t\t\t\t\t16, 0);\n\n\tif (!adapter->kioc_list || !adapter->mbox_list ||\n\t\t\t!adapter->pthru_dma_pool) {\n\n\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\"megaraid cmm: out of memory, %s %d\\n\", __func__,\n\t\t\t__LINE__));\n\n\t\trval = (-ENOMEM);\n\n\t\tgoto memalloc_error;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&adapter->kioc_pool);\n\tspin_lock_init(&adapter->kioc_pool_lock);\n\tsema_init(&adapter->kioc_semaphore, lld_adp->max_kioc);\n\n\tmbox_list\t= (mbox64_t *)adapter->mbox_list;\n\n\tfor (i = 0; i < lld_adp->max_kioc; i++) {\n\n\t\tkioc\t\t= adapter->kioc_list + i;\n\t\tkioc->cmdbuf\t= (uint64_t)(unsigned long)(mbox_list + i);\n\t\tkioc->pthru32\t= dma_pool_alloc(adapter->pthru_dma_pool,\n\t\t\t\t\t\tGFP_KERNEL, &kioc->pthru32_h);\n\n\t\tif (!kioc->pthru32) {\n\n\t\t\tcon_log(CL_ANN, (KERN_WARNING\n\t\t\t\t\"megaraid cmm: out of memory, %s %d\\n\",\n\t\t\t\t\t__func__, __LINE__));\n\n\t\t\trval = (-ENOMEM);\n\n\t\t\tgoto pthru_dma_pool_error;\n\t\t}\n\n\t\tlist_add_tail(&kioc->list, &adapter->kioc_pool);\n\t}\n\n\t \n\tif ((rval = mraid_mm_setup_dma_pools(adapter)) != 0) {\n\t\tgoto dma_pool_error;\n\t}\n\n\tlist_add_tail(&adapter->list, &adapters_list_g);\n\n\tadapters_count_g++;\n\n\treturn 0;\n\ndma_pool_error:\n\t \n\npthru_dma_pool_error:\n\n\tfor (i = 0; i < lld_adp->max_kioc; i++) {\n\t\tkioc = adapter->kioc_list + i;\n\t\tif (kioc->pthru32) {\n\t\t\tdma_pool_free(adapter->pthru_dma_pool, kioc->pthru32,\n\t\t\t\tkioc->pthru32_h);\n\t\t}\n\t}\n\nmemalloc_error:\n\n\tkfree(adapter->kioc_list);\n\tkfree(adapter->mbox_list);\n\n\tdma_pool_destroy(adapter->pthru_dma_pool);\n\n\tkfree(adapter);\n\n\treturn rval;\n}\n\n\n \nuint32_t\nmraid_mm_adapter_app_handle(uint32_t unique_id)\n{\n\tmraid_mmadp_t\t*adapter;\n\tmraid_mmadp_t\t*tmp;\n\tint\t\tindex = 0;\n\n\tlist_for_each_entry_safe(adapter, tmp, &adapters_list_g, list) {\n\n\t\tif (adapter->unique_id == unique_id) {\n\n\t\t\treturn MKADAP(index);\n\t\t}\n\n\t\tindex++;\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int\nmraid_mm_setup_dma_pools(mraid_mmadp_t *adp)\n{\n\tmm_dmapool_t\t*pool;\n\tint\t\tbufsize;\n\tint\t\ti;\n\n\t \n\tbufsize = MRAID_MM_INIT_BUFF_SIZE;\n\n\tfor (i = 0; i < MAX_DMA_POOLS; i++){\n\n\t\tpool = &adp->dma_pool_list[i];\n\n\t\tpool->buf_size = bufsize;\n\t\tspin_lock_init(&pool->lock);\n\n\t\tpool->handle = dma_pool_create(\"megaraid mm data buffer\",\n\t\t\t\t\t\t&adp->pdev->dev, bufsize,\n\t\t\t\t\t\t16, 0);\n\n\t\tif (!pool->handle) {\n\t\t\tgoto dma_pool_setup_error;\n\t\t}\n\n\t\tpool->vaddr = dma_pool_alloc(pool->handle, GFP_KERNEL,\n\t\t\t\t\t\t\t&pool->paddr);\n\n\t\tif (!pool->vaddr)\n\t\t\tgoto dma_pool_setup_error;\n\n\t\tbufsize = bufsize * 2;\n\t}\n\n\treturn 0;\n\ndma_pool_setup_error:\n\n\tmraid_mm_teardown_dma_pools(adp);\n\treturn (-ENOMEM);\n}\n\n\n \nint\nmraid_mm_unregister_adp(uint32_t unique_id)\n{\n\tmraid_mmadp_t\t*adapter;\n\tmraid_mmadp_t\t*tmp;\n\n\tlist_for_each_entry_safe(adapter, tmp, &adapters_list_g, list) {\n\n\n\t\tif (adapter->unique_id == unique_id) {\n\n\t\t\tadapters_count_g--;\n\n\t\t\tlist_del_init(&adapter->list);\n\n\t\t\tmraid_mm_free_adp_resources(adapter);\n\n\t\t\tkfree(adapter);\n\n\t\t\tcon_log(CL_ANN, (\n\t\t\t\t\"megaraid cmm: Unregistered one adapter:%#x\\n\",\n\t\t\t\tunique_id));\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn (-ENODEV);\n}\n\n \nstatic void\nmraid_mm_free_adp_resources(mraid_mmadp_t *adp)\n{\n\tuioc_t\t*kioc;\n\tint\ti;\n\n\tmraid_mm_teardown_dma_pools(adp);\n\n\tfor (i = 0; i < adp->max_kioc; i++) {\n\n\t\tkioc = adp->kioc_list + i;\n\n\t\tdma_pool_free(adp->pthru_dma_pool, kioc->pthru32,\n\t\t\t\tkioc->pthru32_h);\n\t}\n\n\tkfree(adp->kioc_list);\n\tkfree(adp->mbox_list);\n\n\tdma_pool_destroy(adp->pthru_dma_pool);\n\n\n\treturn;\n}\n\n\n \nstatic void\nmraid_mm_teardown_dma_pools(mraid_mmadp_t *adp)\n{\n\tint\t\ti;\n\tmm_dmapool_t\t*pool;\n\n\tfor (i = 0; i < MAX_DMA_POOLS; i++) {\n\n\t\tpool = &adp->dma_pool_list[i];\n\n\t\tif (pool->handle) {\n\n\t\t\tif (pool->vaddr)\n\t\t\t\tdma_pool_free(pool->handle, pool->vaddr,\n\t\t\t\t\t\t\tpool->paddr);\n\n\t\t\tdma_pool_destroy(pool->handle);\n\t\t\tpool->handle = NULL;\n\t\t}\n\t}\n\n\treturn;\n}\n\n \nstatic int __init\nmraid_mm_init(void)\n{\n\tint err;\n\n\t\n\tcon_log(CL_ANN, (KERN_INFO \"megaraid cmm: %s %s\\n\",\n\t\tLSI_COMMON_MOD_VERSION, LSI_COMMON_MOD_EXT_VERSION));\n\n\terr = misc_register(&megaraid_mm_dev);\n\tif (err < 0) {\n\t\tcon_log(CL_ANN, (\"megaraid cmm: cannot register misc device\\n\"));\n\t\treturn err;\n\t}\n\n\tinit_waitqueue_head(&wait_q);\n\n\tINIT_LIST_HEAD(&adapters_list_g);\n\n\treturn 0;\n}\n\n\n \nstatic void __exit\nmraid_mm_exit(void)\n{\n\tcon_log(CL_DLEVEL1 , (\"exiting common mod\\n\"));\n\n\tmisc_deregister(&megaraid_mm_dev);\n}\n\nmodule_init(mraid_mm_init);\nmodule_exit(mraid_mm_exit);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}