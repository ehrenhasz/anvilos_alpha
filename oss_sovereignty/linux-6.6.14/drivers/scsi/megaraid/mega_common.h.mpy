{
  "module_name": "mega_common.h",
  "hash_id": "59bd87b5e67b25880156a7d50624820b281e6dbfaa0bfd66fc768acd2939608e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/megaraid/mega_common.h",
  "human_readable_source": " \n \n\n#ifndef _MEGA_COMMON_H_\n#define _MEGA_COMMON_H_\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/list.h>\n#include <linux/moduleparam.h>\n#include <linux/dma-mapping.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n\n\n#define LSI_MAX_CHANNELS\t\t16\n#define LSI_MAX_LOGICAL_DRIVES_64LD\t(64+1)\n\n#define HBA_SIGNATURE_64_BIT\t\t0x299\n#define PCI_CONF_AMISIG64\t\t0xa4\n\n#define MEGA_SCSI_INQ_EVPD\t\t1\n#define MEGA_INVALID_FIELD_IN_CDB\t0x24\n\n\n \ntypedef struct {\n\tcaddr_t\t\t\tccb;\n\tstruct list_head\tlist;\n\tunsigned long\t\tgp;\n\tunsigned int\t\tsno;\n\tstruct scsi_cmnd\t*scp;\n\tuint32_t\t\tstate;\n\tuint32_t\t\tdma_direction;\n\tuint32_t\t\tdma_type;\n\tuint16_t\t\tdev_channel;\n\tuint16_t\t\tdev_target;\n\tuint32_t\t\tstatus;\n} scb_t;\n\n \n#define SCB_FREE\t0x0000\t \n#define SCB_ACTIVE\t0x0001\t \n#define SCB_PENDQ\t0x0002\t \n#define SCB_ISSUED\t0x0004\t \n#define SCB_ABORT\t0x0008\t \n#define SCB_RESET\t0x0010\t \n\n \n#define MRAID_DMA_NONE\t0x0000\t \n#define MRAID_DMA_WSG\t0x0001\t \n#define MRAID_DMA_WBUF\t0x0002\t \n\n\n \n\n\n#define VERSION_SIZE\t16\n\ntypedef struct {\n\tstruct tasklet_struct\tdpc_h;\n\tstruct pci_dev\t\t*pdev;\n\tstruct Scsi_Host\t*host;\n\tspinlock_t\t\tlock;\n\tuint8_t\t\t\tquiescent;\n\tint\t\t\toutstanding_cmds;\n\tscb_t\t\t\t*kscb_list;\n\tstruct list_head\tkscb_pool;\n\tspinlock_t\t\tkscb_pool_lock;\n\tstruct list_head\tpend_list;\n\tspinlock_t\t\tpend_list_lock;\n\tstruct list_head\tcompleted_list;\n\tspinlock_t\t\tcompleted_list_lock;\n\tuint16_t\t\tsglen;\n\tint\t\t\tdevice_ids[LSI_MAX_CHANNELS]\n\t\t\t\t\t[LSI_MAX_LOGICAL_DRIVES_64LD];\n\tcaddr_t\t\t\traid_device;\n\tuint8_t\t\t\tmax_channel;\n\tuint16_t\t\tmax_target;\n\tuint8_t\t\t\tmax_lun;\n\n\tuint32_t\t\tunique_id;\n\tint\t\t\tirq;\n\tuint8_t\t\t\tito;\n\tcaddr_t\t\t\tibuf;\n\tdma_addr_t\t\tibuf_dma_h;\n\tscb_t\t\t\t*uscb_list;\n\tstruct list_head\tuscb_pool;\n\tspinlock_t\t\tuscb_pool_lock;\n\tint\t\t\tmax_cmds;\n\tuint8_t\t\t\tfw_version[VERSION_SIZE];\n\tuint8_t\t\t\tbios_version[VERSION_SIZE];\n\tuint8_t\t\t\tmax_cdb_sz;\n\tuint8_t\t\t\tha;\n\tuint16_t\t\tinit_id;\n\tuint16_t\t\tmax_sectors;\n\tuint16_t\t\tcmd_per_lun;\n\tatomic_t\t\tbeing_detached;\n} adapter_t;\n\n#define SCSI_FREE_LIST_LOCK(adapter)\t(&adapter->kscb_pool_lock)\n#define USER_FREE_LIST_LOCK(adapter)\t(&adapter->uscb_pool_lock)\n#define PENDING_LIST_LOCK(adapter)\t(&adapter->pend_list_lock)\n#define COMPLETED_LIST_LOCK(adapter)\t(&adapter->completed_list_lock)\n\n\n\n#define SCP2HOST(scp)\t\t\t(scp)->device->host\t\n#define SCP2HOSTDATA(scp)\t\tSCP2HOST(scp)->hostdata\t\n#define SCP2CHANNEL(scp)\t\t(scp)->device->channel\t\n#define SCP2TARGET(scp)\t\t\t(scp)->device->id\t\n#define SCP2LUN(scp)\t\t\t(u32)(scp)->device->lun\t\n\n\n#define SCSIHOST2ADAP(host)\t(((caddr_t *)(host->hostdata))[0])\n#define SCP2ADAPTER(scp)\t(adapter_t *)SCSIHOST2ADAP(SCP2HOST(scp))\n\n\n#define MRAID_IS_LOGICAL(adp, scp)\t\\\n\t(SCP2CHANNEL(scp) == (adp)->max_channel) ? 1 : 0\n\n#define MRAID_IS_LOGICAL_SDEV(adp, sdev)\t\\\n\t(sdev->channel == (adp)->max_channel) ? 1 : 0\n\n \n#define MRAID_GET_DEVICE_MAP(adp, scp, p_chan, target, islogical)\t\\\n\t \t\t\t\t\t\t\t\t\\\n\tislogical = MRAID_IS_LOGICAL(adp, scp);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\t\t\t\\\n\tif (islogical) {\t\t\t\t\t\t\\\n\t\tp_chan = 0xFF;\t\t\t\t\t\t\\\n\t\ttarget =\t\t\t\t\t\t\\\n\t\t(adp)->device_ids[(adp)->max_channel][SCP2TARGET(scp)];\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\telse {\t\t\t\t\t\t\t\t\\\n\t\tp_chan = ((adp)->device_ids[SCP2CHANNEL(scp)]\t\t\\\n\t\t\t\t\t[SCP2TARGET(scp)] >> 8) & 0xFF;\t\\\n\t\ttarget = ((adp)->device_ids[SCP2CHANNEL(scp)]\t\t\\\n\t\t\t\t\t[SCP2TARGET(scp)] & 0xFF);\t\\\n\t}\n\n \n#define LSI_DBGLVL mraid_debug_level\t\n \t\t\t\t\t\n\n#ifdef DEBUG\n#if defined (_ASSERT_PANIC)\n#define ASSERT_ACTION\tpanic\n#else\n#define ASSERT_ACTION\tprintk\n#endif\n\n#define ASSERT(expression)\t\t\t\t\t\t\\\n\tif (!(expression)) {\t\t\t\t\t\t\\\n\tASSERT_ACTION(\"assertion failed:(%s), file: %s, line: %d:%s\\n\",\t\\\n\t\t\t#expression, __FILE__, __LINE__, __func__);\t\\\n\t}\n#else\n#define ASSERT(expression)\n#endif\n\n \nstruct mraid_pci_blk {\n\tcaddr_t\t\tvaddr;\n\tdma_addr_t\tdma_addr;\n};\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}