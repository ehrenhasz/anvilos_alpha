{
  "module_name": "megaraid_sas_fp.c",
  "hash_id": "a8f19900e9f0511bbc1f0f1d716d38afdfb335aa1d0e760056782bd311daece0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/megaraid/megaraid_sas_fp.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/uio.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/poll.h>\n#include <linux/irq_poll.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n\n#include \"megaraid_sas_fusion.h\"\n#include \"megaraid_sas.h\"\n#include <asm/div64.h>\n\n#define LB_PENDING_CMDS_DEFAULT 4\nstatic unsigned int lb_pending_cmds = LB_PENDING_CMDS_DEFAULT;\nmodule_param(lb_pending_cmds, int, 0444);\nMODULE_PARM_DESC(lb_pending_cmds, \"Change raid-1 load balancing outstanding \"\n\t\"threshold. Valid Values are 1-128. Default: 4\");\n\n\n#define ABS_DIFF(a, b)   (((a) > (b)) ? ((a) - (b)) : ((b) - (a)))\n#define MR_LD_STATE_OPTIMAL 3\n\n#define SPAN_ROW_SIZE(map, ld, index_) (MR_LdSpanPtrGet(ld, index_, map)->spanRowSize)\n#define SPAN_ROW_DATA_SIZE(map_, ld, index_)   (MR_LdSpanPtrGet(ld, index_, map)->spanRowDataSize)\n#define SPAN_INVALID  0xff\n\n \nstatic void mr_update_span_set(struct MR_DRV_RAID_MAP_ALL *map,\n\tPLD_SPAN_INFO ldSpanInfo);\nstatic u8 mr_spanset_get_phy_params(struct megasas_instance *instance, u32 ld,\n\tu64 stripRow, u16 stripRef, struct IO_REQUEST_INFO *io_info,\n\tstruct RAID_CONTEXT *pRAID_Context, struct MR_DRV_RAID_MAP_ALL *map);\nstatic u64 get_row_from_strip(struct megasas_instance *instance, u32 ld,\n\tu64 strip, struct MR_DRV_RAID_MAP_ALL *map);\n\nu32 mega_mod64(u64 dividend, u32 divisor)\n{\n\tu64 d;\n\tu32 remainder;\n\n\tif (!divisor)\n\t\tprintk(KERN_ERR \"megasas : DIVISOR is zero, in div fn\\n\");\n\td = dividend;\n\tremainder = do_div(d, divisor);\n\treturn remainder;\n}\n\n \nstatic u64 mega_div64_32(uint64_t dividend, uint32_t divisor)\n{\n\tu64 d = dividend;\n\n\tif (!divisor)\n\t\tprintk(KERN_ERR \"megasas : DIVISOR is zero in mod fn\\n\");\n\n\tdo_div(d, divisor);\n\n\treturn d;\n}\n\nstruct MR_LD_RAID *MR_LdRaidGet(u32 ld, struct MR_DRV_RAID_MAP_ALL *map)\n{\n\treturn &map->raidMap.ldSpanMap[ld].ldRaid;\n}\n\nstatic struct MR_SPAN_BLOCK_INFO *MR_LdSpanInfoGet(u32 ld,\n\t\t\t\t\t\t   struct MR_DRV_RAID_MAP_ALL\n\t\t\t\t\t\t   *map)\n{\n\treturn &map->raidMap.ldSpanMap[ld].spanBlock[0];\n}\n\nstatic u8 MR_LdDataArmGet(u32 ld, u32 armIdx, struct MR_DRV_RAID_MAP_ALL *map)\n{\n\treturn map->raidMap.ldSpanMap[ld].dataArmMap[armIdx];\n}\n\nu16 MR_ArPdGet(u32 ar, u32 arm, struct MR_DRV_RAID_MAP_ALL *map)\n{\n\treturn le16_to_cpu(map->raidMap.arMapInfo[ar].pd[arm]);\n}\n\nu16 MR_LdSpanArrayGet(u32 ld, u32 span, struct MR_DRV_RAID_MAP_ALL *map)\n{\n\treturn le16_to_cpu(map->raidMap.ldSpanMap[ld].spanBlock[span].span.arrayRef);\n}\n\n__le16 MR_PdDevHandleGet(u32 pd, struct MR_DRV_RAID_MAP_ALL *map)\n{\n\treturn map->raidMap.devHndlInfo[pd].curDevHdl;\n}\n\nstatic u8 MR_PdInterfaceTypeGet(u32 pd, struct MR_DRV_RAID_MAP_ALL *map)\n{\n\treturn map->raidMap.devHndlInfo[pd].interfaceType;\n}\n\nu16 MR_GetLDTgtId(u32 ld, struct MR_DRV_RAID_MAP_ALL *map)\n{\n\treturn le16_to_cpu(map->raidMap.ldSpanMap[ld].ldRaid.targetId);\n}\n\nu16 MR_TargetIdToLdGet(u32 ldTgtId, struct MR_DRV_RAID_MAP_ALL *map)\n{\n\treturn map->raidMap.ldTgtIdToLd[ldTgtId];\n}\n\nstatic struct MR_LD_SPAN *MR_LdSpanPtrGet(u32 ld, u32 span,\n\t\t\t\t\t  struct MR_DRV_RAID_MAP_ALL *map)\n{\n\treturn &map->raidMap.ldSpanMap[ld].spanBlock[span].span;\n}\n\n \nstatic int MR_PopulateDrvRaidMap(struct megasas_instance *instance, u64 map_id)\n{\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tstruct MR_FW_RAID_MAP_ALL     *fw_map_old    = NULL;\n\tstruct MR_FW_RAID_MAP         *pFwRaidMap    = NULL;\n\tint i, j;\n\tu16 ld_count;\n\tstruct MR_FW_RAID_MAP_DYNAMIC *fw_map_dyn;\n\tstruct MR_FW_RAID_MAP_EXT *fw_map_ext;\n\tstruct MR_RAID_MAP_DESC_TABLE *desc_table;\n\n\n\tstruct MR_DRV_RAID_MAP_ALL *drv_map =\n\t\t\tfusion->ld_drv_map[(map_id & 1)];\n\tstruct MR_DRV_RAID_MAP *pDrvRaidMap = &drv_map->raidMap;\n\tvoid *raid_map_data = NULL;\n\n\tmemset(drv_map, 0, fusion->drv_map_sz);\n\tmemset(pDrvRaidMap->ldTgtIdToLd,\n\t       0xff, (sizeof(u16) * MAX_LOGICAL_DRIVES_DYN));\n\n\tif (instance->max_raid_mapsize) {\n\t\tfw_map_dyn = fusion->ld_map[(map_id & 1)];\n\t\tdesc_table =\n\t\t(struct MR_RAID_MAP_DESC_TABLE *)((void *)fw_map_dyn + le32_to_cpu(fw_map_dyn->desc_table_offset));\n\t\tif (desc_table != fw_map_dyn->raid_map_desc_table)\n\t\t\tdev_dbg(&instance->pdev->dev, \"offsets of desc table are not matching desc %p original %p\\n\",\n\t\t\t\tdesc_table, fw_map_dyn->raid_map_desc_table);\n\n\t\tld_count = (u16)le16_to_cpu(fw_map_dyn->ld_count);\n\t\tpDrvRaidMap->ldCount = (__le16)cpu_to_le16(ld_count);\n\t\tpDrvRaidMap->fpPdIoTimeoutSec =\n\t\t\tfw_map_dyn->fp_pd_io_timeout_sec;\n\t\tpDrvRaidMap->totalSize =\n\t\t\tcpu_to_le32(sizeof(struct MR_DRV_RAID_MAP_ALL));\n\t\t \n\t\traid_map_data = (void *)fw_map_dyn +\n\t\t\tle32_to_cpu(fw_map_dyn->desc_table_offset) +\n\t\t\tle32_to_cpu(fw_map_dyn->desc_table_size);\n\n\t\tfor (i = 0; i < le32_to_cpu(fw_map_dyn->desc_table_num_elements); ++i) {\n\t\t\tswitch (le32_to_cpu(desc_table->raid_map_desc_type)) {\n\t\t\tcase RAID_MAP_DESC_TYPE_DEVHDL_INFO:\n\t\t\t\tfw_map_dyn->dev_hndl_info =\n\t\t\t\t(struct MR_DEV_HANDLE_INFO *)(raid_map_data + le32_to_cpu(desc_table->raid_map_desc_offset));\n\t\t\t\tmemcpy(pDrvRaidMap->devHndlInfo,\n\t\t\t\t\tfw_map_dyn->dev_hndl_info,\n\t\t\t\t\tsizeof(struct MR_DEV_HANDLE_INFO) *\n\t\t\t\t\tle32_to_cpu(desc_table->raid_map_desc_elements));\n\t\t\tbreak;\n\t\t\tcase RAID_MAP_DESC_TYPE_TGTID_INFO:\n\t\t\t\tfw_map_dyn->ld_tgt_id_to_ld =\n\t\t\t\t\t(u16 *)(raid_map_data +\n\t\t\t\t\tle32_to_cpu(desc_table->raid_map_desc_offset));\n\t\t\t\tfor (j = 0; j < le32_to_cpu(desc_table->raid_map_desc_elements); j++) {\n\t\t\t\t\tpDrvRaidMap->ldTgtIdToLd[j] =\n\t\t\t\t\t\tle16_to_cpu(fw_map_dyn->ld_tgt_id_to_ld[j]);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase RAID_MAP_DESC_TYPE_ARRAY_INFO:\n\t\t\t\tfw_map_dyn->ar_map_info =\n\t\t\t\t\t(struct MR_ARRAY_INFO *)\n\t\t\t\t\t(raid_map_data + le32_to_cpu(desc_table->raid_map_desc_offset));\n\t\t\t\tmemcpy(pDrvRaidMap->arMapInfo,\n\t\t\t\t       fw_map_dyn->ar_map_info,\n\t\t\t\t       sizeof(struct MR_ARRAY_INFO) *\n\t\t\t\t       le32_to_cpu(desc_table->raid_map_desc_elements));\n\t\t\tbreak;\n\t\t\tcase RAID_MAP_DESC_TYPE_SPAN_INFO:\n\t\t\t\tfw_map_dyn->ld_span_map =\n\t\t\t\t\t(struct MR_LD_SPAN_MAP *)\n\t\t\t\t\t(raid_map_data +\n\t\t\t\t\tle32_to_cpu(desc_table->raid_map_desc_offset));\n\t\t\t\tmemcpy(pDrvRaidMap->ldSpanMap,\n\t\t\t\t       fw_map_dyn->ld_span_map,\n\t\t\t\t       sizeof(struct MR_LD_SPAN_MAP) *\n\t\t\t\t       le32_to_cpu(desc_table->raid_map_desc_elements));\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_dbg(&instance->pdev->dev, \"wrong number of desctableElements %d\\n\",\n\t\t\t\t\tfw_map_dyn->desc_table_num_elements);\n\t\t\t}\n\t\t\t++desc_table;\n\t\t}\n\n\t} else if (instance->supportmax256vd) {\n\t\tfw_map_ext =\n\t\t\t(struct MR_FW_RAID_MAP_EXT *)fusion->ld_map[(map_id & 1)];\n\t\tld_count = (u16)le16_to_cpu(fw_map_ext->ldCount);\n\t\tif (ld_count > MAX_LOGICAL_DRIVES_EXT) {\n\t\t\tdev_dbg(&instance->pdev->dev, \"megaraid_sas: LD count exposed in RAID map in not valid\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tpDrvRaidMap->ldCount = (__le16)cpu_to_le16(ld_count);\n\t\tpDrvRaidMap->fpPdIoTimeoutSec = fw_map_ext->fpPdIoTimeoutSec;\n\t\tfor (i = 0; i < (MAX_LOGICAL_DRIVES_EXT); i++)\n\t\t\tpDrvRaidMap->ldTgtIdToLd[i] =\n\t\t\t\t(u16)fw_map_ext->ldTgtIdToLd[i];\n\t\tmemcpy(pDrvRaidMap->ldSpanMap, fw_map_ext->ldSpanMap,\n\t\t       sizeof(struct MR_LD_SPAN_MAP) * ld_count);\n\t\tmemcpy(pDrvRaidMap->arMapInfo, fw_map_ext->arMapInfo,\n\t\t       sizeof(struct MR_ARRAY_INFO) * MAX_API_ARRAYS_EXT);\n\t\tmemcpy(pDrvRaidMap->devHndlInfo, fw_map_ext->devHndlInfo,\n\t\t       sizeof(struct MR_DEV_HANDLE_INFO) *\n\t\t       MAX_RAIDMAP_PHYSICAL_DEVICES);\n\n\t\t \n\t\tpDrvRaidMap->totalSize =\n\t\t\tcpu_to_le32(sizeof(struct MR_FW_RAID_MAP_EXT));\n\t} else {\n\t\tfw_map_old = (struct MR_FW_RAID_MAP_ALL *)\n\t\t\t\tfusion->ld_map[(map_id & 1)];\n\t\tpFwRaidMap = &fw_map_old->raidMap;\n\t\tld_count = (u16)le32_to_cpu(pFwRaidMap->ldCount);\n\t\tif (ld_count > MAX_LOGICAL_DRIVES) {\n\t\t\tdev_dbg(&instance->pdev->dev,\n\t\t\t\t\"LD count exposed in RAID map in not valid\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tpDrvRaidMap->totalSize = pFwRaidMap->totalSize;\n\t\tpDrvRaidMap->ldCount = (__le16)cpu_to_le16(ld_count);\n\t\tpDrvRaidMap->fpPdIoTimeoutSec = pFwRaidMap->fpPdIoTimeoutSec;\n\t\tfor (i = 0; i < MAX_RAIDMAP_LOGICAL_DRIVES + MAX_RAIDMAP_VIEWS; i++)\n\t\t\tpDrvRaidMap->ldTgtIdToLd[i] =\n\t\t\t\t(u8)pFwRaidMap->ldTgtIdToLd[i];\n\t\tfor (i = 0; i < ld_count; i++) {\n\t\t\tpDrvRaidMap->ldSpanMap[i] = pFwRaidMap->ldSpanMap[i];\n\t\t}\n\t\tmemcpy(pDrvRaidMap->arMapInfo, pFwRaidMap->arMapInfo,\n\t\t\tsizeof(struct MR_ARRAY_INFO) * MAX_RAIDMAP_ARRAYS);\n\t\tmemcpy(pDrvRaidMap->devHndlInfo, pFwRaidMap->devHndlInfo,\n\t\t\tsizeof(struct MR_DEV_HANDLE_INFO) *\n\t\t\tMAX_RAIDMAP_PHYSICAL_DEVICES);\n\t}\n\n\treturn 0;\n}\n\n \nu8 MR_ValidateMapInfo(struct megasas_instance *instance, u64 map_id)\n{\n\tstruct fusion_context *fusion;\n\tstruct MR_DRV_RAID_MAP_ALL *drv_map;\n\tstruct MR_DRV_RAID_MAP *pDrvRaidMap;\n\tstruct LD_LOAD_BALANCE_INFO *lbInfo;\n\tPLD_SPAN_INFO ldSpanInfo;\n\tstruct MR_LD_RAID         *raid;\n\tu16 num_lds, i;\n\tu16 ld;\n\tu32 expected_size;\n\n\tif (MR_PopulateDrvRaidMap(instance, map_id))\n\t\treturn 0;\n\n\tfusion = instance->ctrl_context;\n\tdrv_map = fusion->ld_drv_map[(map_id & 1)];\n\tpDrvRaidMap = &drv_map->raidMap;\n\n\tlbInfo = fusion->load_balance_info;\n\tldSpanInfo = fusion->log_to_span;\n\n\tif (instance->max_raid_mapsize)\n\t\texpected_size = sizeof(struct MR_DRV_RAID_MAP_ALL);\n\telse if (instance->supportmax256vd)\n\t\texpected_size = sizeof(struct MR_FW_RAID_MAP_EXT);\n\telse\n\t\texpected_size = struct_size_t(struct MR_FW_RAID_MAP,\n\t\t\t\t\t      ldSpanMap,\n\t\t\t\t\t      le16_to_cpu(pDrvRaidMap->ldCount));\n\n\tif (le32_to_cpu(pDrvRaidMap->totalSize) != expected_size) {\n\t\tdev_dbg(&instance->pdev->dev, \"megasas: map info structure size 0x%x\",\n\t\t\tle32_to_cpu(pDrvRaidMap->totalSize));\n\t\tdev_dbg(&instance->pdev->dev, \"is not matching expected size 0x%x\\n\",\n\t\t\t(unsigned int)expected_size);\n\t\tdev_err(&instance->pdev->dev, \"megasas: span map %x, pDrvRaidMap->totalSize : %x\\n\",\n\t\t\t(unsigned int)sizeof(struct MR_LD_SPAN_MAP),\n\t\t\tle32_to_cpu(pDrvRaidMap->totalSize));\n\t\treturn 0;\n\t}\n\n\tif (instance->UnevenSpanSupport)\n\t\tmr_update_span_set(drv_map, ldSpanInfo);\n\n\tif (lbInfo)\n\t\tmr_update_load_balance_params(drv_map, lbInfo);\n\n\tnum_lds = le16_to_cpu(drv_map->raidMap.ldCount);\n\n\tmemcpy(instance->ld_ids_prev,\n\t       instance->ld_ids_from_raidmap,\n\t       sizeof(instance->ld_ids_from_raidmap));\n\tmemset(instance->ld_ids_from_raidmap, 0xff, MEGASAS_MAX_LD_IDS);\n\t \n\tfor (i = 0; (num_lds > 0) && (i < MAX_LOGICAL_DRIVES_EXT); i++) {\n\t\tld = MR_TargetIdToLdGet(i, drv_map);\n\n\t\t \n\t\tif (ld >= MEGASAS_MAX_SUPPORTED_LD_IDS)\n\t\t\tcontinue;\n\n\t\traid = MR_LdRaidGet(ld, drv_map);\n\t\tle32_to_cpus((u32 *)&raid->capability);\n\t\tinstance->ld_ids_from_raidmap[i] = i;\n\t\tnum_lds--;\n\t}\n\n\treturn 1;\n}\n\nstatic u32 MR_GetSpanBlock(u32 ld, u64 row, u64 *span_blk,\n\t\t    struct MR_DRV_RAID_MAP_ALL *map)\n{\n\tstruct MR_SPAN_BLOCK_INFO *pSpanBlock = MR_LdSpanInfoGet(ld, map);\n\tstruct MR_QUAD_ELEMENT    *quad;\n\tstruct MR_LD_RAID         *raid = MR_LdRaidGet(ld, map);\n\tu32                span, j;\n\n\tfor (span = 0; span < raid->spanDepth; span++, pSpanBlock++) {\n\n\t\tfor (j = 0; j < le32_to_cpu(pSpanBlock->block_span_info.noElements); j++) {\n\t\t\tquad = &pSpanBlock->block_span_info.quad[j];\n\n\t\t\tif (le32_to_cpu(quad->diff) == 0)\n\t\t\t\treturn SPAN_INVALID;\n\t\t\tif (le64_to_cpu(quad->logStart) <= row && row <=\n\t\t\t\tle64_to_cpu(quad->logEnd) && (mega_mod64(row - le64_to_cpu(quad->logStart),\n\t\t\t\tle32_to_cpu(quad->diff))) == 0) {\n\t\t\t\tif (span_blk != NULL) {\n\t\t\t\t\tu64  blk;\n\t\t\t\t\tblk =  mega_div64_32((row-le64_to_cpu(quad->logStart)), le32_to_cpu(quad->diff));\n\n\t\t\t\t\tblk = (blk + le64_to_cpu(quad->offsetInSpan)) << raid->stripeShift;\n\t\t\t\t\t*span_blk = blk;\n\t\t\t\t}\n\t\t\t\treturn span;\n\t\t\t}\n\t\t}\n\t}\n\treturn SPAN_INVALID;\n}\n\n \n\nstatic u32 mr_spanset_get_span_block(struct megasas_instance *instance,\n\t\tu32 ld, u64 row, u64 *span_blk, struct MR_DRV_RAID_MAP_ALL *map)\n{\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tstruct MR_LD_RAID         *raid = MR_LdRaidGet(ld, map);\n\tLD_SPAN_SET *span_set;\n\tstruct MR_QUAD_ELEMENT    *quad;\n\tu32    span, info;\n\tPLD_SPAN_INFO ldSpanInfo = fusion->log_to_span;\n\n\tfor (info = 0; info < MAX_QUAD_DEPTH; info++) {\n\t\tspan_set = &(ldSpanInfo[ld].span_set[info]);\n\n\t\tif (span_set->span_row_data_width == 0)\n\t\t\tbreak;\n\n\t\tif (row > span_set->data_row_end)\n\t\t\tcontinue;\n\n\t\tfor (span = 0; span < raid->spanDepth; span++)\n\t\t\tif (le32_to_cpu(map->raidMap.ldSpanMap[ld].spanBlock[span].\n\t\t\t\tblock_span_info.noElements) >= info+1) {\n\t\t\t\tquad = &map->raidMap.ldSpanMap[ld].\n\t\t\t\t\tspanBlock[span].\n\t\t\t\t\tblock_span_info.quad[info];\n\t\t\t\tif (le32_to_cpu(quad->diff) == 0)\n\t\t\t\t\treturn SPAN_INVALID;\n\t\t\t\tif (le64_to_cpu(quad->logStart) <= row  &&\n\t\t\t\t\trow <= le64_to_cpu(quad->logEnd)  &&\n\t\t\t\t\t(mega_mod64(row - le64_to_cpu(quad->logStart),\n\t\t\t\t\t\tle32_to_cpu(quad->diff))) == 0) {\n\t\t\t\t\tif (span_blk != NULL) {\n\t\t\t\t\t\tu64  blk;\n\t\t\t\t\t\tblk = mega_div64_32\n\t\t\t\t\t\t    ((row - le64_to_cpu(quad->logStart)),\n\t\t\t\t\t\t    le32_to_cpu(quad->diff));\n\t\t\t\t\t\tblk = (blk + le64_to_cpu(quad->offsetInSpan))\n\t\t\t\t\t\t\t << raid->stripeShift;\n\t\t\t\t\t\t*span_blk = blk;\n\t\t\t\t\t}\n\t\t\t\t\treturn span;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn SPAN_INVALID;\n}\n\n \n\nstatic u64  get_row_from_strip(struct megasas_instance *instance,\n\tu32 ld, u64 strip, struct MR_DRV_RAID_MAP_ALL *map)\n{\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tstruct MR_LD_RAID\t*raid = MR_LdRaidGet(ld, map);\n\tLD_SPAN_SET\t*span_set;\n\tPLD_SPAN_INFO\tldSpanInfo = fusion->log_to_span;\n\tu32\t\tinfo, strip_offset, span, span_offset;\n\tu64\t\tspan_set_Strip, span_set_Row, retval;\n\n\tfor (info = 0; info < MAX_QUAD_DEPTH; info++) {\n\t\tspan_set = &(ldSpanInfo[ld].span_set[info]);\n\n\t\tif (span_set->span_row_data_width == 0)\n\t\t\tbreak;\n\t\tif (strip > span_set->data_strip_end)\n\t\t\tcontinue;\n\n\t\tspan_set_Strip = strip - span_set->data_strip_start;\n\t\tstrip_offset = mega_mod64(span_set_Strip,\n\t\t\t\tspan_set->span_row_data_width);\n\t\tspan_set_Row = mega_div64_32(span_set_Strip,\n\t\t\t\tspan_set->span_row_data_width) * span_set->diff;\n\t\tfor (span = 0, span_offset = 0; span < raid->spanDepth; span++)\n\t\t\tif (le32_to_cpu(map->raidMap.ldSpanMap[ld].spanBlock[span].\n\t\t\t\tblock_span_info.noElements) >= info+1) {\n\t\t\t\tif (strip_offset >=\n\t\t\t\t\tspan_set->strip_offset[span])\n\t\t\t\t\tspan_offset++;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\tretval = (span_set->data_row_start + span_set_Row +\n\t\t\t\t(span_offset - 1));\n\t\treturn retval;\n\t}\n\treturn -1LLU;\n}\n\n\n \n\nstatic u64 get_strip_from_row(struct megasas_instance *instance,\n\t\tu32 ld, u64 row, struct MR_DRV_RAID_MAP_ALL *map)\n{\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tstruct MR_LD_RAID         *raid = MR_LdRaidGet(ld, map);\n\tLD_SPAN_SET *span_set;\n\tstruct MR_QUAD_ELEMENT    *quad;\n\tPLD_SPAN_INFO ldSpanInfo = fusion->log_to_span;\n\tu32    span, info;\n\tu64  strip;\n\n\tfor (info = 0; info < MAX_QUAD_DEPTH; info++) {\n\t\tspan_set = &(ldSpanInfo[ld].span_set[info]);\n\n\t\tif (span_set->span_row_data_width == 0)\n\t\t\tbreak;\n\t\tif (row > span_set->data_row_end)\n\t\t\tcontinue;\n\n\t\tfor (span = 0; span < raid->spanDepth; span++)\n\t\t\tif (le32_to_cpu(map->raidMap.ldSpanMap[ld].spanBlock[span].\n\t\t\t\tblock_span_info.noElements) >= info+1) {\n\t\t\t\tquad = &map->raidMap.ldSpanMap[ld].\n\t\t\t\t\tspanBlock[span].block_span_info.quad[info];\n\t\t\t\tif (le64_to_cpu(quad->logStart) <= row  &&\n\t\t\t\t\trow <= le64_to_cpu(quad->logEnd)  &&\n\t\t\t\t\tmega_mod64((row - le64_to_cpu(quad->logStart)),\n\t\t\t\t\tle32_to_cpu(quad->diff)) == 0) {\n\t\t\t\t\tstrip = mega_div64_32\n\t\t\t\t\t\t(((row - span_set->data_row_start)\n\t\t\t\t\t\t\t- le64_to_cpu(quad->logStart)),\n\t\t\t\t\t\t\tle32_to_cpu(quad->diff));\n\t\t\t\t\tstrip *= span_set->span_row_data_width;\n\t\t\t\t\tstrip += span_set->data_strip_start;\n\t\t\t\t\tstrip += span_set->strip_offset[span];\n\t\t\t\t\treturn strip;\n\t\t\t\t}\n\t\t\t}\n\t}\n\tdev_err(&instance->pdev->dev, \"get_strip_from_row\"\n\t\t\"returns invalid strip for ld=%x, row=%lx\\n\",\n\t\tld, (long unsigned int)row);\n\treturn -1;\n}\n\n \n\nstatic u32 get_arm_from_strip(struct megasas_instance *instance,\n\tu32 ld, u64 strip, struct MR_DRV_RAID_MAP_ALL *map)\n{\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tstruct MR_LD_RAID         *raid = MR_LdRaidGet(ld, map);\n\tLD_SPAN_SET *span_set;\n\tPLD_SPAN_INFO ldSpanInfo = fusion->log_to_span;\n\tu32    info, strip_offset, span, span_offset, retval;\n\n\tfor (info = 0 ; info < MAX_QUAD_DEPTH; info++) {\n\t\tspan_set = &(ldSpanInfo[ld].span_set[info]);\n\n\t\tif (span_set->span_row_data_width == 0)\n\t\t\tbreak;\n\t\tif (strip > span_set->data_strip_end)\n\t\t\tcontinue;\n\n\t\tstrip_offset = (uint)mega_mod64\n\t\t\t\t((strip - span_set->data_strip_start),\n\t\t\t\tspan_set->span_row_data_width);\n\n\t\tfor (span = 0, span_offset = 0; span < raid->spanDepth; span++)\n\t\t\tif (le32_to_cpu(map->raidMap.ldSpanMap[ld].spanBlock[span].\n\t\t\t\tblock_span_info.noElements) >= info+1) {\n\t\t\t\tif (strip_offset >=\n\t\t\t\t\tspan_set->strip_offset[span])\n\t\t\t\t\tspan_offset =\n\t\t\t\t\t\tspan_set->strip_offset[span];\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\tretval = (strip_offset - span_offset);\n\t\treturn retval;\n\t}\n\n\tdev_err(&instance->pdev->dev, \"get_arm_from_strip\"\n\t\t\"returns invalid arm for ld=%x strip=%lx\\n\",\n\t\tld, (long unsigned int)strip);\n\n\treturn -1;\n}\n\n \nstatic u8 get_arm(struct megasas_instance *instance, u32 ld, u8 span, u64 stripe,\n\t\tstruct MR_DRV_RAID_MAP_ALL *map)\n{\n\tstruct MR_LD_RAID  *raid = MR_LdRaidGet(ld, map);\n\t \n\tu32    arm = 0;\n\n\tswitch (raid->level) {\n\tcase 0:\n\tcase 5:\n\tcase 6:\n\t\tarm = mega_mod64(stripe, SPAN_ROW_SIZE(map, ld, span));\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tarm = get_arm_from_strip(instance, ld, stripe, map);\n\t\tif (arm != -1U)\n\t\t\tarm *= 2;\n\t\tbreak;\n\t}\n\n\treturn arm;\n}\n\n\n \nstatic u8 mr_spanset_get_phy_params(struct megasas_instance *instance, u32 ld,\n\t\tu64 stripRow, u16 stripRef, struct IO_REQUEST_INFO *io_info,\n\t\tstruct RAID_CONTEXT *pRAID_Context,\n\t\tstruct MR_DRV_RAID_MAP_ALL *map)\n{\n\tstruct MR_LD_RAID  *raid = MR_LdRaidGet(ld, map);\n\tu32     pd, arRef, r1_alt_pd;\n\tu8      physArm, span;\n\tu64     row;\n\tu8\tretval = true;\n\tu64\t*pdBlock = &io_info->pdBlock;\n\t__le16\t*pDevHandle = &io_info->devHandle;\n\tu8\t*pPdInterface = &io_info->pd_interface;\n\tu32\tlogArm, rowMod, armQ, arm;\n\n\t*pDevHandle = cpu_to_le16(MR_DEVHANDLE_INVALID);\n\n\t \n\trow\t    = io_info->start_row;\n\tspan\t    = io_info->start_span;\n\n\n\tif (raid->level == 6) {\n\t\tlogArm = get_arm_from_strip(instance, ld, stripRow, map);\n\t\tif (logArm == -1U)\n\t\t\treturn false;\n\t\trowMod = mega_mod64(row, SPAN_ROW_SIZE(map, ld, span));\n\t\tarmQ = SPAN_ROW_SIZE(map, ld, span) - 1 - rowMod;\n\t\tarm = armQ + 1 + logArm;\n\t\tif (arm >= SPAN_ROW_SIZE(map, ld, span))\n\t\t\tarm -= SPAN_ROW_SIZE(map, ld, span);\n\t\tphysArm = (u8)arm;\n\t} else\n\t\t \n\t\tphysArm = get_arm(instance, ld, span, stripRow, map);\n\tif (physArm == 0xFF)\n\t\treturn false;\n\n\tarRef       = MR_LdSpanArrayGet(ld, span, map);\n\tpd          = MR_ArPdGet(arRef, physArm, map);\n\n\tif (pd != MR_PD_INVALID) {\n\t\t*pDevHandle = MR_PdDevHandleGet(pd, map);\n\t\t*pPdInterface = MR_PdInterfaceTypeGet(pd, map);\n\t\t \n\t\tif ((instance->adapter_type >= VENTURA_SERIES) &&\n\t\t    (raid->level == 1) &&\n\t\t    !io_info->isRead) {\n\t\t\tr1_alt_pd = MR_ArPdGet(arRef, physArm + 1, map);\n\t\t\tif (r1_alt_pd != MR_PD_INVALID)\n\t\t\t\tio_info->r1_alt_dev_handle =\n\t\t\t\tMR_PdDevHandleGet(r1_alt_pd, map);\n\t\t}\n\t} else {\n\t\tif ((raid->level >= 5) &&\n\t\t\t((instance->adapter_type == THUNDERBOLT_SERIES)  ||\n\t\t\t((instance->adapter_type == INVADER_SERIES) &&\n\t\t\t(raid->regTypeReqOnRead != REGION_TYPE_UNUSED))))\n\t\t\tpRAID_Context->reg_lock_flags = REGION_TYPE_EXCLUSIVE;\n\t\telse if (raid->level == 1) {\n\t\t\tphysArm = physArm + 1;\n\t\t\tpd = MR_ArPdGet(arRef, physArm, map);\n\t\t\tif (pd != MR_PD_INVALID) {\n\t\t\t\t*pDevHandle = MR_PdDevHandleGet(pd, map);\n\t\t\t\t*pPdInterface = MR_PdInterfaceTypeGet(pd, map);\n\t\t\t}\n\t\t}\n\t}\n\n\t*pdBlock += stripRef + le64_to_cpu(MR_LdSpanPtrGet(ld, span, map)->startBlk);\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\t((struct RAID_CONTEXT_G35 *)pRAID_Context)->span_arm =\n\t\t\t(span << RAID_CTX_SPANARM_SPAN_SHIFT) | physArm;\n\t\tio_info->span_arm =\n\t\t\t(span << RAID_CTX_SPANARM_SPAN_SHIFT) | physArm;\n\t} else {\n\t\tpRAID_Context->span_arm =\n\t\t\t(span << RAID_CTX_SPANARM_SPAN_SHIFT) | physArm;\n\t\tio_info->span_arm = pRAID_Context->span_arm;\n\t}\n\tio_info->pd_after_lb = pd;\n\treturn retval;\n}\n\n \nstatic u8 MR_GetPhyParams(struct megasas_instance *instance, u32 ld, u64 stripRow,\n\t\tu16 stripRef, struct IO_REQUEST_INFO *io_info,\n\t\tstruct RAID_CONTEXT *pRAID_Context,\n\t\tstruct MR_DRV_RAID_MAP_ALL *map)\n{\n\tstruct MR_LD_RAID  *raid = MR_LdRaidGet(ld, map);\n\tu32         pd, arRef, r1_alt_pd;\n\tu8          physArm, span;\n\tu64         row;\n\tu8\t    retval = true;\n\tu64\t    *pdBlock = &io_info->pdBlock;\n\t__le16\t    *pDevHandle = &io_info->devHandle;\n\tu8\t    *pPdInterface = &io_info->pd_interface;\n\n\t*pDevHandle = cpu_to_le16(MR_DEVHANDLE_INVALID);\n\n\trow =  mega_div64_32(stripRow, raid->rowDataSize);\n\n\tif (raid->level == 6) {\n\t\t \n\t\tu32 logArm =  mega_mod64(stripRow, raid->rowDataSize);\n\t\tu32 rowMod, armQ, arm;\n\n\t\tif (raid->rowSize == 0)\n\t\t\treturn false;\n\t\t \n\t\trowMod = mega_mod64(row, raid->rowSize);\n\t\tarmQ = raid->rowSize-1-rowMod;  \n\t\tarm = armQ+1+logArm;  \n\t\tif (arm >= raid->rowSize)  \n\t\t\tarm -= raid->rowSize;\n\t\tphysArm = (u8)arm;\n\t} else  {\n\t\tif (raid->modFactor == 0)\n\t\t\treturn false;\n\t\tphysArm = MR_LdDataArmGet(ld,  mega_mod64(stripRow,\n\t\t\t\t\t\t\t  raid->modFactor),\n\t\t\t\t\t  map);\n\t}\n\n\tif (raid->spanDepth == 1) {\n\t\tspan = 0;\n\t\t*pdBlock = row << raid->stripeShift;\n\t} else {\n\t\tspan = (u8)MR_GetSpanBlock(ld, row, pdBlock, map);\n\t\tif (span == SPAN_INVALID)\n\t\t\treturn false;\n\t}\n\n\t \n\tarRef       = MR_LdSpanArrayGet(ld, span, map);\n\tpd          = MR_ArPdGet(arRef, physArm, map);  \n\n\tif (pd != MR_PD_INVALID) {\n\t\t \n\t\t*pDevHandle = MR_PdDevHandleGet(pd, map);\n\t\t*pPdInterface = MR_PdInterfaceTypeGet(pd, map);\n\t\t \n\t\tif ((instance->adapter_type >= VENTURA_SERIES) &&\n\t\t    (raid->level == 1) &&\n\t\t    !io_info->isRead) {\n\t\t\tr1_alt_pd = MR_ArPdGet(arRef, physArm + 1, map);\n\t\t\tif (r1_alt_pd != MR_PD_INVALID)\n\t\t\t\tio_info->r1_alt_dev_handle =\n\t\t\t\t\tMR_PdDevHandleGet(r1_alt_pd, map);\n\t\t}\n\t} else {\n\t\tif ((raid->level >= 5) &&\n\t\t\t((instance->adapter_type == THUNDERBOLT_SERIES)  ||\n\t\t\t((instance->adapter_type == INVADER_SERIES) &&\n\t\t\t(raid->regTypeReqOnRead != REGION_TYPE_UNUSED))))\n\t\t\tpRAID_Context->reg_lock_flags = REGION_TYPE_EXCLUSIVE;\n\t\telse if (raid->level == 1) {\n\t\t\t \n\t\t\tphysArm = physArm + 1;\n\t\t\tpd = MR_ArPdGet(arRef, physArm, map);\n\t\t\tif (pd != MR_PD_INVALID) {\n\t\t\t\t \n\t\t\t\t*pDevHandle = MR_PdDevHandleGet(pd, map);\n\t\t\t\t*pPdInterface = MR_PdInterfaceTypeGet(pd, map);\n\t\t\t}\n\t\t}\n\t}\n\n\t*pdBlock += stripRef + le64_to_cpu(MR_LdSpanPtrGet(ld, span, map)->startBlk);\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\t((struct RAID_CONTEXT_G35 *)pRAID_Context)->span_arm =\n\t\t\t\t(span << RAID_CTX_SPANARM_SPAN_SHIFT) | physArm;\n\t\tio_info->span_arm =\n\t\t\t\t(span << RAID_CTX_SPANARM_SPAN_SHIFT) | physArm;\n\t} else {\n\t\tpRAID_Context->span_arm =\n\t\t\t(span << RAID_CTX_SPANARM_SPAN_SHIFT) | physArm;\n\t\tio_info->span_arm = pRAID_Context->span_arm;\n\t}\n\tio_info->pd_after_lb = pd;\n\treturn retval;\n}\n\n \nstatic void mr_get_phy_params_r56_rmw(struct megasas_instance *instance,\n\t\t\t    u32 ld, u64 stripNo,\n\t\t\t    struct IO_REQUEST_INFO *io_info,\n\t\t\t    struct RAID_CONTEXT_G35 *pRAID_Context,\n\t\t\t    struct MR_DRV_RAID_MAP_ALL *map)\n{\n\tstruct MR_LD_RAID  *raid = MR_LdRaidGet(ld, map);\n\tu8          span, dataArms, arms, dataArm, logArm;\n\ts8          rightmostParityArm, PParityArm;\n\tu64         rowNum;\n\tu64 *pdBlock = &io_info->pdBlock;\n\n\tdataArms = raid->rowDataSize;\n\tarms = raid->rowSize;\n\n\trowNum =  mega_div64_32(stripNo, dataArms);\n\t \n\trightmostParityArm = (arms - 1) - mega_mod64(rowNum, arms);\n\n\t \n\tlogArm =  mega_mod64(stripNo, dataArms);\n\t \n\tdataArm = mega_mod64((rightmostParityArm + 1 + logArm), arms);\n\n\tif (raid->spanDepth == 1) {\n\t\tspan = 0;\n\t} else {\n\t\tspan = (u8)MR_GetSpanBlock(ld, rowNum, pdBlock, map);\n\t\tif (span == SPAN_INVALID)\n\t\t\treturn;\n\t}\n\n\tif (raid->level == 6) {\n\t\t \n\t\tPParityArm = (arms - 2) - mega_mod64(rowNum, arms);\n\n\t\tif (PParityArm < 0)\n\t\t\tPParityArm += arms;\n\n\t\t \n\t\tpRAID_Context->flow_specific.r56_arm_map = rightmostParityArm;\n\t\tpRAID_Context->flow_specific.r56_arm_map |=\n\t\t\t\t    (u16)(PParityArm << RAID_CTX_R56_P_ARM_SHIFT);\n\t} else {\n\t\tpRAID_Context->flow_specific.r56_arm_map |=\n\t\t\t\t    (u16)(rightmostParityArm << RAID_CTX_R56_P_ARM_SHIFT);\n\t}\n\n\tpRAID_Context->reg_lock_row_lba = cpu_to_le64(rowNum);\n\tpRAID_Context->flow_specific.r56_arm_map |=\n\t\t\t\t   (u16)(logArm << RAID_CTX_R56_LOG_ARM_SHIFT);\n\tcpu_to_le16s(&pRAID_Context->flow_specific.r56_arm_map);\n\tpRAID_Context->span_arm = (span << RAID_CTX_SPANARM_SPAN_SHIFT) | dataArm;\n\tpRAID_Context->raid_flags = (MR_RAID_FLAGS_IO_SUB_TYPE_R56_DIV_OFFLOAD <<\n\t\t\t\t    MR_RAID_CTX_RAID_FLAGS_IO_SUB_TYPE_SHIFT);\n\n\treturn;\n}\n\n \nu8\nMR_BuildRaidContext(struct megasas_instance *instance,\n\t\t    struct IO_REQUEST_INFO *io_info,\n\t\t    struct RAID_CONTEXT *pRAID_Context,\n\t\t    struct MR_DRV_RAID_MAP_ALL *map, u8 **raidLUN)\n{\n\tstruct fusion_context *fusion;\n\tstruct MR_LD_RAID  *raid;\n\tu32         stripSize, stripe_mask;\n\tu64         endLba, endStrip, endRow, start_row, start_strip;\n\tu64         regStart;\n\tu32         regSize;\n\tu8          num_strips, numRows;\n\tu16         ref_in_start_stripe, ref_in_end_stripe;\n\tu64         ldStartBlock;\n\tu32         numBlocks, ldTgtId;\n\tu8          isRead;\n\tu8\t    retval = 0;\n\tu8\t    startlba_span = SPAN_INVALID;\n\tu64 *pdBlock = &io_info->pdBlock;\n\tu16\t    ld;\n\n\tldStartBlock = io_info->ldStartBlock;\n\tnumBlocks = io_info->numBlocks;\n\tldTgtId = io_info->ldTgtId;\n\tisRead = io_info->isRead;\n\tio_info->IoforUnevenSpan = 0;\n\tio_info->start_span\t= SPAN_INVALID;\n\tfusion = instance->ctrl_context;\n\n\tld = MR_TargetIdToLdGet(ldTgtId, map);\n\traid = MR_LdRaidGet(ld, map);\n\t \n\tio_info->ra_capable = raid->capability.ra_capable;\n\n\t \n\tif (raid->rowDataSize == 0) {\n\t\tif (MR_LdSpanPtrGet(ld, 0, map)->spanRowDataSize == 0)\n\t\t\treturn false;\n\t\telse if (instance->UnevenSpanSupport) {\n\t\t\tio_info->IoforUnevenSpan = 1;\n\t\t} else {\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\"raid->rowDataSize is 0, but has SPAN[0]\"\n\t\t\t\t\"rowDataSize = 0x%0x,\"\n\t\t\t\t\"but there is _NO_ UnevenSpanSupport\\n\",\n\t\t\t\tMR_LdSpanPtrGet(ld, 0, map)->spanRowDataSize);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstripSize = 1 << raid->stripeShift;\n\tstripe_mask = stripSize-1;\n\n\tio_info->data_arms = raid->rowDataSize;\n\n\t \n\tstart_strip         = ldStartBlock >> raid->stripeShift;\n\tref_in_start_stripe = (u16)(ldStartBlock & stripe_mask);\n\tendLba              = ldStartBlock + numBlocks - 1;\n\tref_in_end_stripe   = (u16)(endLba & stripe_mask);\n\tendStrip            = endLba >> raid->stripeShift;\n\tnum_strips          = (u8)(endStrip - start_strip + 1);  \n\n\tif (io_info->IoforUnevenSpan) {\n\t\tstart_row = get_row_from_strip(instance, ld, start_strip, map);\n\t\tendRow\t  = get_row_from_strip(instance, ld, endStrip, map);\n\t\tif (start_row == -1ULL || endRow == -1ULL) {\n\t\t\tdev_info(&instance->pdev->dev, \"return from %s %d.\"\n\t\t\t\t\"Send IO w/o region lock.\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (raid->spanDepth == 1) {\n\t\t\tstartlba_span = 0;\n\t\t\t*pdBlock = start_row << raid->stripeShift;\n\t\t} else\n\t\t\tstartlba_span = (u8)mr_spanset_get_span_block(instance,\n\t\t\t\t\t\tld, start_row, pdBlock, map);\n\t\tif (startlba_span == SPAN_INVALID) {\n\t\t\tdev_info(&instance->pdev->dev, \"return from %s %d\"\n\t\t\t\t\"for row 0x%llx,start strip %llx\"\n\t\t\t\t\"endSrip %llx\\n\", __func__, __LINE__,\n\t\t\t\t(unsigned long long)start_row,\n\t\t\t\t(unsigned long long)start_strip,\n\t\t\t\t(unsigned long long)endStrip);\n\t\t\treturn false;\n\t\t}\n\t\tio_info->start_span\t= startlba_span;\n\t\tio_info->start_row\t= start_row;\n\t} else {\n\t\tstart_row = mega_div64_32(start_strip, raid->rowDataSize);\n\t\tendRow    = mega_div64_32(endStrip, raid->rowDataSize);\n\t}\n\tnumRows = (u8)(endRow - start_row + 1);\n\n\t \n\n\t \n\tregStart            = start_row << raid->stripeShift;\n\t \n\tregSize             = stripSize;\n\n\tio_info->do_fp_rlbypass = raid->capability.fpBypassRegionLock;\n\n\t \n\tif (raid->capability.fpCapable) {\n\t\tif (isRead)\n\t\t\tio_info->fpOkForIo = (raid->capability.fpReadCapable &&\n\t\t\t\t\t      ((num_strips == 1) ||\n\t\t\t\t\t       raid->capability.\n\t\t\t\t\t       fpReadAcrossStripe));\n\t\telse\n\t\t\tio_info->fpOkForIo = (raid->capability.fpWriteCapable &&\n\t\t\t\t\t      ((num_strips == 1) ||\n\t\t\t\t\t       raid->capability.\n\t\t\t\t\t       fpWriteAcrossStripe));\n\t} else\n\t\tio_info->fpOkForIo = false;\n\n\tif (numRows == 1) {\n\t\t \n\t\tif (num_strips == 1) {\n\t\t\tregStart += ref_in_start_stripe;\n\t\t\tregSize = numBlocks;\n\t\t}\n\t\t \n\t} else if (io_info->IoforUnevenSpan == 0) {\n\t\t \n\t\tif (start_strip == (start_row + 1) * raid->rowDataSize - 1) {\n\t\t\tregStart += ref_in_start_stripe;\n\t\t\t \n\t\t\tregSize = stripSize - ref_in_start_stripe;\n\t\t}\n\n\t\t \n\t\tif (numRows > 2)\n\t\t\tregSize += (numRows-2) << raid->stripeShift;\n\n\t\t \n\t\tif (endStrip == endRow*raid->rowDataSize)\n\t\t\tregSize += ref_in_end_stripe+1;\n\t\telse\n\t\t\tregSize += stripSize;\n\t} else {\n\t\t \n\t\tif (start_strip == (get_strip_from_row(instance, ld, start_row, map) +\n\t\t\t\tSPAN_ROW_DATA_SIZE(map, ld, startlba_span) - 1)) {\n\t\t\tregStart += ref_in_start_stripe;\n\t\t\t \n\t\t\tregSize = stripSize - ref_in_start_stripe;\n\t\t}\n\t\t \n\n\t\tif (numRows > 2)\n\t\t\t \n\t\t\tregSize += (numRows-2) << raid->stripeShift;\n\n\t\t \n\t\tif (endStrip == get_strip_from_row(instance, ld, endRow, map))\n\t\t\tregSize += ref_in_end_stripe + 1;\n\t\telse\n\t\t\tregSize += stripSize;\n\t}\n\n\tpRAID_Context->timeout_value =\n\t\tcpu_to_le16(raid->fpIoTimeoutForLd ?\n\t\t\t    raid->fpIoTimeoutForLd :\n\t\t\t    map->raidMap.fpPdIoTimeoutSec);\n\tif (instance->adapter_type == INVADER_SERIES)\n\t\tpRAID_Context->reg_lock_flags = (isRead) ?\n\t\t\traid->regTypeReqOnRead : raid->regTypeReqOnWrite;\n\telse if (instance->adapter_type == THUNDERBOLT_SERIES)\n\t\tpRAID_Context->reg_lock_flags = (isRead) ?\n\t\t\tREGION_TYPE_SHARED_READ : raid->regTypeReqOnWrite;\n\tpRAID_Context->virtual_disk_tgt_id = raid->targetId;\n\tpRAID_Context->reg_lock_row_lba    = cpu_to_le64(regStart);\n\tpRAID_Context->reg_lock_length    = cpu_to_le32(regSize);\n\tpRAID_Context->config_seq_num\t= raid->seqNum;\n\t \n\t*raidLUN = raid->LUN;\n\n\t \n\tif (fusion->r56_div_offload && (raid->level >= 5) && !isRead) {\n\t\tmr_get_phy_params_r56_rmw(instance, ld, start_strip, io_info,\n\t\t\t\t       (struct RAID_CONTEXT_G35 *)pRAID_Context,\n\t\t\t\t       map);\n\t\treturn true;\n\t}\n\n\t \n\tif (io_info->fpOkForIo) {\n\t\tretval = io_info->IoforUnevenSpan ?\n\t\t\t\tmr_spanset_get_phy_params(instance, ld,\n\t\t\t\t\tstart_strip, ref_in_start_stripe,\n\t\t\t\t\tio_info, pRAID_Context, map) :\n\t\t\t\tMR_GetPhyParams(instance, ld, start_strip,\n\t\t\t\t\tref_in_start_stripe, io_info,\n\t\t\t\t\tpRAID_Context, map);\n\t\t \n\t\tif (io_info->devHandle == MR_DEVHANDLE_INVALID)\n\t\t\tio_info->fpOkForIo = false;\n\t\treturn retval;\n\t} else if (isRead) {\n\t\tuint stripIdx;\n\t\tfor (stripIdx = 0; stripIdx < num_strips; stripIdx++) {\n\t\t\tretval = io_info->IoforUnevenSpan ?\n\t\t\t\tmr_spanset_get_phy_params(instance, ld,\n\t\t\t\t    start_strip + stripIdx,\n\t\t\t\t    ref_in_start_stripe, io_info,\n\t\t\t\t    pRAID_Context, map) :\n\t\t\t\tMR_GetPhyParams(instance, ld,\n\t\t\t\t    start_strip + stripIdx, ref_in_start_stripe,\n\t\t\t\t    io_info, pRAID_Context, map);\n\t\t\tif (!retval)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn true;\n}\n\n \nvoid mr_update_span_set(struct MR_DRV_RAID_MAP_ALL *map,\n\tPLD_SPAN_INFO ldSpanInfo)\n{\n\tu8   span, count;\n\tu32  element, span_row_width;\n\tu64  span_row;\n\tstruct MR_LD_RAID *raid;\n\tLD_SPAN_SET *span_set, *span_set_prev;\n\tstruct MR_QUAD_ELEMENT    *quad;\n\tint ldCount;\n\tu16 ld;\n\n\n\tfor (ldCount = 0; ldCount < MAX_LOGICAL_DRIVES_EXT; ldCount++) {\n\t\tld = MR_TargetIdToLdGet(ldCount, map);\n\t\tif (ld >= (MAX_LOGICAL_DRIVES_EXT - 1))\n\t\t\tcontinue;\n\t\traid = MR_LdRaidGet(ld, map);\n\t\tfor (element = 0; element < MAX_QUAD_DEPTH; element++) {\n\t\t\tfor (span = 0; span < raid->spanDepth; span++) {\n\t\t\t\tif (le32_to_cpu(map->raidMap.ldSpanMap[ld].spanBlock[span].\n\t\t\t\t\tblock_span_info.noElements) <\n\t\t\t\t\telement + 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tspan_set = &(ldSpanInfo[ld].span_set[element]);\n\t\t\t\tquad = &map->raidMap.ldSpanMap[ld].\n\t\t\t\t\tspanBlock[span].block_span_info.\n\t\t\t\t\tquad[element];\n\n\t\t\t\tspan_set->diff = le32_to_cpu(quad->diff);\n\n\t\t\t\tfor (count = 0, span_row_width = 0;\n\t\t\t\t\tcount < raid->spanDepth; count++) {\n\t\t\t\t\tif (le32_to_cpu(map->raidMap.ldSpanMap[ld].\n\t\t\t\t\t\tspanBlock[count].\n\t\t\t\t\t\tblock_span_info.\n\t\t\t\t\t\tnoElements) >= element + 1) {\n\t\t\t\t\t\tspan_set->strip_offset[count] =\n\t\t\t\t\t\t\tspan_row_width;\n\t\t\t\t\t\tspan_row_width +=\n\t\t\t\t\t\t\tMR_LdSpanPtrGet\n\t\t\t\t\t\t\t(ld, count, map)->spanRowDataSize;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tspan_set->span_row_data_width = span_row_width;\n\t\t\t\tspan_row = mega_div64_32(((le64_to_cpu(quad->logEnd) -\n\t\t\t\t\tle64_to_cpu(quad->logStart)) + le32_to_cpu(quad->diff)),\n\t\t\t\t\tle32_to_cpu(quad->diff));\n\n\t\t\t\tif (element == 0) {\n\t\t\t\t\tspan_set->log_start_lba = 0;\n\t\t\t\t\tspan_set->log_end_lba =\n\t\t\t\t\t\t((span_row << raid->stripeShift)\n\t\t\t\t\t\t* span_row_width) - 1;\n\n\t\t\t\t\tspan_set->span_row_start = 0;\n\t\t\t\t\tspan_set->span_row_end = span_row - 1;\n\n\t\t\t\t\tspan_set->data_strip_start = 0;\n\t\t\t\t\tspan_set->data_strip_end =\n\t\t\t\t\t\t(span_row * span_row_width) - 1;\n\n\t\t\t\t\tspan_set->data_row_start = 0;\n\t\t\t\t\tspan_set->data_row_end =\n\t\t\t\t\t\t(span_row * le32_to_cpu(quad->diff)) - 1;\n\t\t\t\t} else {\n\t\t\t\t\tspan_set_prev = &(ldSpanInfo[ld].\n\t\t\t\t\t\t\tspan_set[element - 1]);\n\t\t\t\t\tspan_set->log_start_lba =\n\t\t\t\t\t\tspan_set_prev->log_end_lba + 1;\n\t\t\t\t\tspan_set->log_end_lba =\n\t\t\t\t\t\tspan_set->log_start_lba +\n\t\t\t\t\t\t((span_row << raid->stripeShift)\n\t\t\t\t\t\t* span_row_width) - 1;\n\n\t\t\t\t\tspan_set->span_row_start =\n\t\t\t\t\t\tspan_set_prev->span_row_end + 1;\n\t\t\t\t\tspan_set->span_row_end =\n\t\t\t\t\tspan_set->span_row_start + span_row - 1;\n\n\t\t\t\t\tspan_set->data_strip_start =\n\t\t\t\t\tspan_set_prev->data_strip_end + 1;\n\t\t\t\t\tspan_set->data_strip_end =\n\t\t\t\t\t\tspan_set->data_strip_start +\n\t\t\t\t\t\t(span_row * span_row_width) - 1;\n\n\t\t\t\t\tspan_set->data_row_start =\n\t\t\t\t\t\tspan_set_prev->data_row_end + 1;\n\t\t\t\t\tspan_set->data_row_end =\n\t\t\t\t\t\tspan_set->data_row_start +\n\t\t\t\t\t\t(span_row * le32_to_cpu(quad->diff)) - 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tif (span == raid->spanDepth)\n\t\t\tbreak;\n\t    }\n\t}\n}\n\nvoid mr_update_load_balance_params(struct MR_DRV_RAID_MAP_ALL *drv_map,\n\tstruct LD_LOAD_BALANCE_INFO *lbInfo)\n{\n\tint ldCount;\n\tu16 ld;\n\tstruct MR_LD_RAID *raid;\n\n\tif (lb_pending_cmds > 128 || lb_pending_cmds < 1)\n\t\tlb_pending_cmds = LB_PENDING_CMDS_DEFAULT;\n\n\tfor (ldCount = 0; ldCount < MAX_LOGICAL_DRIVES_EXT; ldCount++) {\n\t\tld = MR_TargetIdToLdGet(ldCount, drv_map);\n\t\tif (ld >= MAX_LOGICAL_DRIVES_EXT - 1) {\n\t\t\tlbInfo[ldCount].loadBalanceFlag = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\traid = MR_LdRaidGet(ld, drv_map);\n\t\tif ((raid->level != 1) ||\n\t\t\t(raid->ldState != MR_LD_STATE_OPTIMAL)) {\n\t\t\tlbInfo[ldCount].loadBalanceFlag = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tlbInfo[ldCount].loadBalanceFlag = 1;\n\t}\n}\n\nstatic u8 megasas_get_best_arm_pd(struct megasas_instance *instance,\n\t\t\t   struct LD_LOAD_BALANCE_INFO *lbInfo,\n\t\t\t   struct IO_REQUEST_INFO *io_info,\n\t\t\t   struct MR_DRV_RAID_MAP_ALL *drv_map)\n{\n\tstruct MR_LD_RAID  *raid;\n\tu16\tpd1_dev_handle;\n\tu16     pend0, pend1, ld;\n\tu64     diff0, diff1;\n\tu8      bestArm, pd0, pd1, span, arm;\n\tu32     arRef, span_row_size;\n\n\tu64 block = io_info->ldStartBlock;\n\tu32 count = io_info->numBlocks;\n\n\tspan = ((io_info->span_arm & RAID_CTX_SPANARM_SPAN_MASK)\n\t\t\t>> RAID_CTX_SPANARM_SPAN_SHIFT);\n\tarm = (io_info->span_arm & RAID_CTX_SPANARM_ARM_MASK);\n\n\tld = MR_TargetIdToLdGet(io_info->ldTgtId, drv_map);\n\traid = MR_LdRaidGet(ld, drv_map);\n\tspan_row_size = instance->UnevenSpanSupport ?\n\t\t\tSPAN_ROW_SIZE(drv_map, ld, span) : raid->rowSize;\n\n\tarRef = MR_LdSpanArrayGet(ld, span, drv_map);\n\tpd0 = MR_ArPdGet(arRef, arm, drv_map);\n\tpd1 = MR_ArPdGet(arRef, (arm + 1) >= span_row_size ?\n\t\t(arm + 1 - span_row_size) : arm + 1, drv_map);\n\n\t \n\n\tpd1_dev_handle = MR_PdDevHandleGet(pd1, drv_map);\n\n\tif (pd1_dev_handle == MR_DEVHANDLE_INVALID) {\n\t\tbestArm = arm;\n\t} else {\n\t\t \n\t\tpend0 = atomic_read(&lbInfo->scsi_pending_cmds[pd0]);\n\t\tpend1 = atomic_read(&lbInfo->scsi_pending_cmds[pd1]);\n\n\t\t \n\t\tdiff0 = ABS_DIFF(block, lbInfo->last_accessed_block[pd0]);\n\t\tdiff1 = ABS_DIFF(block, lbInfo->last_accessed_block[pd1]);\n\t\tbestArm = (diff0 <= diff1 ? arm : arm ^ 1);\n\n\t\t \n\t\tif ((bestArm == arm && pend0 > pend1 + lb_pending_cmds)  ||\n\t\t    (bestArm != arm && pend1 > pend0 + lb_pending_cmds))\n\t\t\tbestArm ^= 1;\n\n\t\t \n\t\tio_info->span_arm =\n\t\t\t(span << RAID_CTX_SPANARM_SPAN_SHIFT) | bestArm;\n\t\tio_info->pd_after_lb = (bestArm == arm) ? pd0 : pd1;\n\t}\n\n\tlbInfo->last_accessed_block[io_info->pd_after_lb] = block + count - 1;\n\treturn io_info->pd_after_lb;\n}\n\n__le16 get_updated_dev_handle(struct megasas_instance *instance,\n\t\t\t      struct LD_LOAD_BALANCE_INFO *lbInfo,\n\t\t\t      struct IO_REQUEST_INFO *io_info,\n\t\t\t      struct MR_DRV_RAID_MAP_ALL *drv_map)\n{\n\tu8 arm_pd;\n\t__le16 devHandle;\n\n\t \n\tarm_pd  = megasas_get_best_arm_pd(instance, lbInfo, io_info, drv_map);\n\tdevHandle = MR_PdDevHandleGet(arm_pd, drv_map);\n\tio_info->pd_interface = MR_PdInterfaceTypeGet(arm_pd, drv_map);\n\tatomic_inc(&lbInfo->scsi_pending_cmds[arm_pd]);\n\n\treturn devHandle;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}