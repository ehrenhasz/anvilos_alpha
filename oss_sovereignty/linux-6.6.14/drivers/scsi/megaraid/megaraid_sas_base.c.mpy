{
  "module_name": "megaraid_sas_base.c",
  "hash_id": "c4a8060da82e66148fc3030d5cdb629d5d348263004e57eddb52977ee9462908",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/megaraid/megaraid_sas_base.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/uio.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/vmalloc.h>\n#include <linux/irq_poll.h>\n#include <linux/blk-mq-pci.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_dbg.h>\n#include \"megaraid_sas_fusion.h\"\n#include \"megaraid_sas.h\"\n\n \nstatic unsigned int max_sectors;\nmodule_param_named(max_sectors, max_sectors, int, 0444);\nMODULE_PARM_DESC(max_sectors,\n\t\"Maximum number of sectors per IO command\");\n\nstatic int msix_disable;\nmodule_param(msix_disable, int, 0444);\nMODULE_PARM_DESC(msix_disable, \"Disable MSI-X interrupt handling. Default: 0\");\n\nstatic unsigned int msix_vectors;\nmodule_param(msix_vectors, int, 0444);\nMODULE_PARM_DESC(msix_vectors, \"MSI-X max vector count. Default: Set by FW\");\n\nstatic int allow_vf_ioctls;\nmodule_param(allow_vf_ioctls, int, 0444);\nMODULE_PARM_DESC(allow_vf_ioctls, \"Allow ioctls in SR-IOV VF mode. Default: 0\");\n\nstatic unsigned int throttlequeuedepth = MEGASAS_THROTTLE_QUEUE_DEPTH;\nmodule_param(throttlequeuedepth, int, 0444);\nMODULE_PARM_DESC(throttlequeuedepth,\n\t\"Adapter queue depth when throttled due to I/O timeout. Default: 16\");\n\nunsigned int resetwaittime = MEGASAS_RESET_WAIT_TIME;\nmodule_param(resetwaittime, int, 0444);\nMODULE_PARM_DESC(resetwaittime, \"Wait time in (1-180s) after I/O timeout before resetting adapter. Default: 180s\");\n\nstatic int smp_affinity_enable = 1;\nmodule_param(smp_affinity_enable, int, 0444);\nMODULE_PARM_DESC(smp_affinity_enable, \"SMP affinity feature enable/disable Default: enable(1)\");\n\nstatic int rdpq_enable = 1;\nmodule_param(rdpq_enable, int, 0444);\nMODULE_PARM_DESC(rdpq_enable, \"Allocate reply queue in chunks for large queue depth enable/disable Default: enable(1)\");\n\nunsigned int dual_qdepth_disable;\nmodule_param(dual_qdepth_disable, int, 0444);\nMODULE_PARM_DESC(dual_qdepth_disable, \"Disable dual queue depth feature. Default: 0\");\n\nstatic unsigned int scmd_timeout = MEGASAS_DEFAULT_CMD_TIMEOUT;\nmodule_param(scmd_timeout, int, 0444);\nMODULE_PARM_DESC(scmd_timeout, \"scsi command timeout (10-90s), default 90s. See megasas_reset_timer.\");\n\nint perf_mode = -1;\nmodule_param(perf_mode, int, 0444);\nMODULE_PARM_DESC(perf_mode, \"Performance mode (only for Aero adapters), options:\\n\\t\\t\"\n\t\t\"0 - balanced: High iops and low latency queues are allocated &\\n\\t\\t\"\n\t\t\"interrupt coalescing is enabled only on high iops queues\\n\\t\\t\"\n\t\t\"1 - iops: High iops queues are not allocated &\\n\\t\\t\"\n\t\t\"interrupt coalescing is enabled on all queues\\n\\t\\t\"\n\t\t\"2 - latency: High iops queues are not allocated &\\n\\t\\t\"\n\t\t\"interrupt coalescing is disabled on all queues\\n\\t\\t\"\n\t\t\"default mode is 'balanced'\"\n\t\t);\n\nint event_log_level = MFI_EVT_CLASS_CRITICAL;\nmodule_param(event_log_level, int, 0644);\nMODULE_PARM_DESC(event_log_level, \"Asynchronous event logging level- range is: -2(CLASS_DEBUG) to 4(CLASS_DEAD), Default: 2(CLASS_CRITICAL)\");\n\nunsigned int enable_sdev_max_qd;\nmodule_param(enable_sdev_max_qd, int, 0444);\nMODULE_PARM_DESC(enable_sdev_max_qd, \"Enable sdev max qd as can_queue. Default: 0\");\n\nint poll_queues;\nmodule_param(poll_queues, int, 0444);\nMODULE_PARM_DESC(poll_queues, \"Number of queues to be use for io_uring poll mode.\\n\\t\\t\"\n\t\t\"This parameter is effective only if host_tagset_enable=1 &\\n\\t\\t\"\n\t\t\"It is not applicable for MFI_SERIES. &\\n\\t\\t\"\n\t\t\"Driver will work in latency mode. &\\n\\t\\t\"\n\t\t\"High iops queues are not allocated &\\n\\t\\t\"\n\t\t);\n\nint host_tagset_enable = 1;\nmodule_param(host_tagset_enable, int, 0444);\nMODULE_PARM_DESC(host_tagset_enable, \"Shared host tagset enable/disable Default: enable(1)\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(MEGASAS_VERSION);\nMODULE_AUTHOR(\"megaraidlinux.pdl@broadcom.com\");\nMODULE_DESCRIPTION(\"Broadcom MegaRAID SAS Driver\");\n\nint megasas_transition_to_ready(struct megasas_instance *instance, int ocr);\nstatic int megasas_get_pd_list(struct megasas_instance *instance);\nstatic int megasas_ld_list_query(struct megasas_instance *instance,\n\t\t\t\t u8 query_type);\nstatic int megasas_issue_init_mfi(struct megasas_instance *instance);\nstatic int megasas_register_aen(struct megasas_instance *instance,\n\t\t\t\tu32 seq_num, u32 class_locale_word);\nstatic void megasas_get_pd_info(struct megasas_instance *instance,\n\t\t\t\tstruct scsi_device *sdev);\nstatic void\nmegasas_set_ld_removed_by_fw(struct megasas_instance *instance);\n\n \nstatic struct pci_device_id megasas_pci_table[] = {\n\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1064R)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1078R)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1078DE)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1078GEN2)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS0079GEN2)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS0073SKINNY)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS0071SKINNY)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_VERDE_ZCR)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_DELL, PCI_DEVICE_ID_DELL_PERC5)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_FUSION)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_PLASMA)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_INVADER)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_FURY)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_INTRUDER)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_INTRUDER_24)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CUTLASS_52)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CUTLASS_53)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_VENTURA)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CRUSADER)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_HARPOON)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_TOMCAT)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_VENTURA_4PORT)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CRUSADER_4PORT)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E1)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E2)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E5)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E6)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E0)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E3)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E4)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E7)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, megasas_pci_table);\n\nstatic int megasas_mgmt_majorno;\nstruct megasas_mgmt_info megasas_mgmt_info;\nstatic struct fasync_struct *megasas_async_queue;\nstatic DEFINE_MUTEX(megasas_async_queue_mutex);\n\nstatic int megasas_poll_wait_aen;\nstatic DECLARE_WAIT_QUEUE_HEAD(megasas_poll_wait);\nstatic u32 support_poll_for_event;\nu32 megasas_dbg_lvl;\nstatic u32 support_device_change;\nstatic bool support_nvme_encapsulation;\nstatic bool support_pci_lane_margining;\n\n \nstatic DEFINE_SPINLOCK(poll_aen_lock);\n\nextern struct dentry *megasas_debugfs_root;\nextern int megasas_blk_mq_poll(struct Scsi_Host *shost, unsigned int queue_num);\n\nvoid\nmegasas_complete_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd,\n\t\t     u8 alt_status);\nstatic u32\nmegasas_read_fw_status_reg_gen2(struct megasas_instance *instance);\nstatic int\nmegasas_adp_reset_gen2(struct megasas_instance *instance,\n\t\t       struct megasas_register_set __iomem *reg_set);\nstatic irqreturn_t megasas_isr(int irq, void *devp);\nstatic u32\nmegasas_init_adapter_mfi(struct megasas_instance *instance);\nu32\nmegasas_build_and_issue_cmd(struct megasas_instance *instance,\n\t\t\t    struct scsi_cmnd *scmd);\nstatic void megasas_complete_cmd_dpc(unsigned long instance_addr);\nint\nwait_and_poll(struct megasas_instance *instance, struct megasas_cmd *cmd,\n\tint seconds);\nvoid megasas_fusion_ocr_wq(struct work_struct *work);\nstatic int megasas_get_ld_vf_affiliation(struct megasas_instance *instance,\n\t\t\t\t\t int initial);\nstatic int\nmegasas_set_dma_mask(struct megasas_instance *instance);\nstatic int\nmegasas_alloc_ctrl_mem(struct megasas_instance *instance);\nstatic inline void\nmegasas_free_ctrl_mem(struct megasas_instance *instance);\nstatic inline int\nmegasas_alloc_ctrl_dma_buffers(struct megasas_instance *instance);\nstatic inline void\nmegasas_free_ctrl_dma_buffers(struct megasas_instance *instance);\nstatic inline void\nmegasas_init_ctrl_params(struct megasas_instance *instance);\n\nu32 megasas_readl(struct megasas_instance *instance,\n\t\t  const volatile void __iomem *addr)\n{\n\tu32 i = 0, ret_val;\n\t \n\tif (instance->adapter_type == AERO_SERIES) {\n\t\tdo {\n\t\t\tret_val = readl(addr);\n\t\t\ti++;\n\t\t} while (ret_val == 0 && i < 30);\n\t\treturn ret_val;\n\t} else {\n\t\treturn readl(addr);\n\t}\n}\n\n \nvoid megasas_set_dma_settings(struct megasas_instance *instance,\n\t\t\t      struct megasas_dcmd_frame *dcmd,\n\t\t\t      dma_addr_t dma_addr, u32 dma_len)\n{\n\tif (instance->consistent_mask_64bit) {\n\t\tdcmd->sgl.sge64[0].phys_addr = cpu_to_le64(dma_addr);\n\t\tdcmd->sgl.sge64[0].length = cpu_to_le32(dma_len);\n\t\tdcmd->flags = cpu_to_le16(dcmd->flags | MFI_FRAME_SGL64);\n\n\t} else {\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\t\tcpu_to_le32(lower_32_bits(dma_addr));\n\t\tdcmd->sgl.sge32[0].length = cpu_to_le32(dma_len);\n\t\tdcmd->flags = cpu_to_le16(dcmd->flags);\n\t}\n}\n\nstatic void\nmegasas_issue_dcmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tinstance->instancet->fire_cmd(instance,\n\t\tcmd->frame_phys_addr, 0, instance->reg_set);\n\treturn;\n}\n\n \nstruct megasas_cmd *megasas_get_cmd(struct megasas_instance\n\t\t\t\t\t\t  *instance)\n{\n\tunsigned long flags;\n\tstruct megasas_cmd *cmd = NULL;\n\n\tspin_lock_irqsave(&instance->mfi_pool_lock, flags);\n\n\tif (!list_empty(&instance->cmd_pool)) {\n\t\tcmd = list_entry((&instance->cmd_pool)->next,\n\t\t\t\t struct megasas_cmd, list);\n\t\tlist_del_init(&cmd->list);\n\t} else {\n\t\tdev_err(&instance->pdev->dev, \"Command pool empty!\\n\");\n\t}\n\n\tspin_unlock_irqrestore(&instance->mfi_pool_lock, flags);\n\treturn cmd;\n}\n\n \nvoid\nmegasas_return_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tunsigned long flags;\n\tu32 blk_tags;\n\tstruct megasas_cmd_fusion *cmd_fusion;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\t \n\tif (cmd->flags & DRV_DCMD_POLLED_MODE)\n\t\treturn;\n\n\tspin_lock_irqsave(&instance->mfi_pool_lock, flags);\n\n\tif (fusion) {\n\t\tblk_tags = instance->max_scsi_cmds + cmd->index;\n\t\tcmd_fusion = fusion->cmd_list[blk_tags];\n\t\tmegasas_return_cmd_fusion(instance, cmd_fusion);\n\t}\n\tcmd->scmd = NULL;\n\tcmd->frame_count = 0;\n\tcmd->flags = 0;\n\tmemset(cmd->frame, 0, instance->mfi_frame_size);\n\tcmd->frame->io.context = cpu_to_le32(cmd->index);\n\tif (!fusion && reset_devices)\n\t\tcmd->frame->hdr.cmd = MFI_CMD_INVALID;\n\tlist_add(&cmd->list, (&instance->cmd_pool)->next);\n\n\tspin_unlock_irqrestore(&instance->mfi_pool_lock, flags);\n\n}\n\nstatic const char *\nformat_timestamp(uint32_t timestamp)\n{\n\tstatic char buffer[32];\n\n\tif ((timestamp & 0xff000000) == 0xff000000)\n\t\tsnprintf(buffer, sizeof(buffer), \"boot + %us\", timestamp &\n\t\t0x00ffffff);\n\telse\n\t\tsnprintf(buffer, sizeof(buffer), \"%us\", timestamp);\n\treturn buffer;\n}\n\nstatic const char *\nformat_class(int8_t class)\n{\n\tstatic char buffer[6];\n\n\tswitch (class) {\n\tcase MFI_EVT_CLASS_DEBUG:\n\t\treturn \"debug\";\n\tcase MFI_EVT_CLASS_PROGRESS:\n\t\treturn \"progress\";\n\tcase MFI_EVT_CLASS_INFO:\n\t\treturn \"info\";\n\tcase MFI_EVT_CLASS_WARNING:\n\t\treturn \"WARN\";\n\tcase MFI_EVT_CLASS_CRITICAL:\n\t\treturn \"CRIT\";\n\tcase MFI_EVT_CLASS_FATAL:\n\t\treturn \"FATAL\";\n\tcase MFI_EVT_CLASS_DEAD:\n\t\treturn \"DEAD\";\n\tdefault:\n\t\tsnprintf(buffer, sizeof(buffer), \"%d\", class);\n\t\treturn buffer;\n\t}\n}\n\n \nstatic void\nmegasas_decode_evt(struct megasas_instance *instance)\n{\n\tstruct megasas_evt_detail *evt_detail = instance->evt_detail;\n\tunion megasas_evt_class_locale class_locale;\n\tclass_locale.word = le32_to_cpu(evt_detail->cl.word);\n\n\tif ((event_log_level < MFI_EVT_CLASS_DEBUG) ||\n\t    (event_log_level > MFI_EVT_CLASS_DEAD)) {\n\t\tprintk(KERN_WARNING \"megaraid_sas: provided event log level is out of range, setting it to default 2(CLASS_CRITICAL), permissible range is: -2 to 4\\n\");\n\t\tevent_log_level = MFI_EVT_CLASS_CRITICAL;\n\t}\n\n\tif (class_locale.members.class >= event_log_level)\n\t\tdev_info(&instance->pdev->dev, \"%d (%s/0x%04x/%s) - %s\\n\",\n\t\t\tle32_to_cpu(evt_detail->seq_num),\n\t\t\tformat_timestamp(le32_to_cpu(evt_detail->time_stamp)),\n\t\t\t(class_locale.members.locale),\n\t\t\tformat_class(class_locale.members.class),\n\t\t\tevt_detail->description);\n\n\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"evt_detail.args.ld.target_id/index %d/%d\\n\",\n\t\t\t evt_detail->args.ld.target_id, evt_detail->args.ld.ld_index);\n\n}\n\n \n\n \nstatic inline void\nmegasas_enable_intr_xscale(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0, &(regs)->outbound_intr_mask);\n\n\t \n\treadl(&regs->outbound_intr_mask);\n}\n\n \nstatic inline void\nmegasas_disable_intr_xscale(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0x1f;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t \n\treadl(&regs->outbound_intr_mask);\n}\n\n \nstatic u32\nmegasas_read_fw_status_reg_xscale(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_msg_0);\n}\n \nstatic int\nmegasas_clear_intr_xscale(struct megasas_instance *instance)\n{\n\tu32 status;\n\tu32 mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t \n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (status & MFI_OB_INTR_STATUS_MASK)\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\tif (status & MFI_XSCALE_OMR0_CHANGE_INTERRUPT)\n\t\tmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\n\t \n\tif (mfiStatus)\n\t\twritel(status, &regs->outbound_intr_status);\n\n\t \n\treadl(&regs->outbound_intr_status);\n\n\treturn mfiStatus;\n}\n\n \nstatic inline void\nmegasas_fire_cmd_xscale(struct megasas_instance *instance,\n\t\tdma_addr_t frame_phys_addr,\n\t\tu32 frame_count,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel((frame_phys_addr >> 3)|(frame_count),\n\t       &(regs)->inbound_queue_port);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n \nstatic int\nmegasas_adp_reset_xscale(struct megasas_instance *instance,\n\tstruct megasas_register_set __iomem *regs)\n{\n\tu32 i;\n\tu32 pcidata;\n\n\twritel(MFI_ADP_RESET, &regs->inbound_doorbell);\n\n\tfor (i = 0; i < 3; i++)\n\t\tmsleep(1000);  \n\tpcidata  = 0;\n\tpci_read_config_dword(instance->pdev, MFI_1068_PCSR_OFFSET, &pcidata);\n\tdev_notice(&instance->pdev->dev, \"pcidata = %x\\n\", pcidata);\n\tif (pcidata & 0x2) {\n\t\tdev_notice(&instance->pdev->dev, \"mfi 1068 offset read=%x\\n\", pcidata);\n\t\tpcidata &= ~0x2;\n\t\tpci_write_config_dword(instance->pdev,\n\t\t\t\tMFI_1068_PCSR_OFFSET, pcidata);\n\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tmsleep(1000);  \n\n\t\tpcidata  = 0;\n\t\tpci_read_config_dword(instance->pdev,\n\t\t\t\tMFI_1068_FW_HANDSHAKE_OFFSET, &pcidata);\n\t\tdev_notice(&instance->pdev->dev, \"1068 offset handshake read=%x\\n\", pcidata);\n\t\tif ((pcidata & 0xffff0000) == MFI_1068_FW_READY) {\n\t\t\tdev_notice(&instance->pdev->dev, \"1068 offset pcidt=%x\\n\", pcidata);\n\t\t\tpcidata = 0;\n\t\t\tpci_write_config_dword(instance->pdev,\n\t\t\t\tMFI_1068_FW_HANDSHAKE_OFFSET, pcidata);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int\nmegasas_check_reset_xscale(struct megasas_instance *instance,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif ((atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) &&\n\t    (le32_to_cpu(*instance->consumer) ==\n\t\tMEGASAS_ADPRESET_INPROG_SIGN))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_xscale = {\n\n\t.fire_cmd = megasas_fire_cmd_xscale,\n\t.enable_intr = megasas_enable_intr_xscale,\n\t.disable_intr = megasas_disable_intr_xscale,\n\t.clear_intr = megasas_clear_intr_xscale,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_xscale,\n\t.adp_reset = megasas_adp_reset_xscale,\n\t.check_reset = megasas_check_reset_xscale,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n \n\n \n\n \nstatic inline void\nmegasas_enable_intr_ppc(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0xFFFFFFFF, &(regs)->outbound_doorbell_clear);\n\n\twritel(~0x80000000, &(regs)->outbound_intr_mask);\n\n\t \n\treadl(&regs->outbound_intr_mask);\n}\n\n \nstatic inline void\nmegasas_disable_intr_ppc(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0xFFFFFFFF;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t \n\treadl(&regs->outbound_intr_mask);\n}\n\n \nstatic u32\nmegasas_read_fw_status_reg_ppc(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_scratch_pad_0);\n}\n\n \nstatic int\nmegasas_clear_intr_ppc(struct megasas_instance *instance)\n{\n\tu32 status, mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t \n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (status & MFI_REPLY_1078_MESSAGE_INTERRUPT)\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\n\tif (status & MFI_G2_OUTBOUND_DOORBELL_CHANGE_INTERRUPT)\n\t\tmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\n\t \n\twritel(status, &regs->outbound_doorbell_clear);\n\n\t \n\treadl(&regs->outbound_doorbell_clear);\n\n\treturn mfiStatus;\n}\n\n \nstatic inline void\nmegasas_fire_cmd_ppc(struct megasas_instance *instance,\n\t\tdma_addr_t frame_phys_addr,\n\t\tu32 frame_count,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel((frame_phys_addr | (frame_count<<1))|1,\n\t\t\t&(regs)->inbound_queue_port);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n \nstatic int\nmegasas_check_reset_ppc(struct megasas_instance *instance,\n\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_ppc = {\n\n\t.fire_cmd = megasas_fire_cmd_ppc,\n\t.enable_intr = megasas_enable_intr_ppc,\n\t.disable_intr = megasas_disable_intr_ppc,\n\t.clear_intr = megasas_clear_intr_ppc,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_ppc,\n\t.adp_reset = megasas_adp_reset_xscale,\n\t.check_reset = megasas_check_reset_ppc,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n \nstatic inline void\nmegasas_enable_intr_skinny(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0xFFFFFFFF, &(regs)->outbound_intr_mask);\n\n\twritel(~MFI_SKINNY_ENABLE_INTERRUPT_MASK, &(regs)->outbound_intr_mask);\n\n\t \n\treadl(&regs->outbound_intr_mask);\n}\n\n \nstatic inline void\nmegasas_disable_intr_skinny(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0xFFFFFFFF;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t \n\treadl(&regs->outbound_intr_mask);\n}\n\n \nstatic u32\nmegasas_read_fw_status_reg_skinny(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_scratch_pad_0);\n}\n\n \nstatic int\nmegasas_clear_intr_skinny(struct megasas_instance *instance)\n{\n\tu32 status;\n\tu32 mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t \n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (!(status & MFI_SKINNY_ENABLE_INTERRUPT_MASK)) {\n\t\treturn 0;\n\t}\n\n\t \n\tif ((megasas_read_fw_status_reg_skinny(instance) & MFI_STATE_MASK) ==\n\t    MFI_STATE_FAULT) {\n\t\tmfiStatus = MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\t} else\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\n\t \n\twritel(status, &regs->outbound_intr_status);\n\n\t \n\treadl(&regs->outbound_intr_status);\n\n\treturn mfiStatus;\n}\n\n \nstatic inline void\nmegasas_fire_cmd_skinny(struct megasas_instance *instance,\n\t\t\tdma_addr_t frame_phys_addr,\n\t\t\tu32 frame_count,\n\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel(upper_32_bits(frame_phys_addr),\n\t       &(regs)->inbound_high_queue_port);\n\twritel((lower_32_bits(frame_phys_addr) | (frame_count<<1))|1,\n\t       &(regs)->inbound_low_queue_port);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n \nstatic int\nmegasas_check_reset_skinny(struct megasas_instance *instance,\n\t\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_skinny = {\n\n\t.fire_cmd = megasas_fire_cmd_skinny,\n\t.enable_intr = megasas_enable_intr_skinny,\n\t.disable_intr = megasas_disable_intr_skinny,\n\t.clear_intr = megasas_clear_intr_skinny,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_skinny,\n\t.adp_reset = megasas_adp_reset_gen2,\n\t.check_reset = megasas_check_reset_skinny,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n\n \n\n \nstatic inline void\nmegasas_enable_intr_gen2(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0xFFFFFFFF, &(regs)->outbound_doorbell_clear);\n\n\t \n\twritel(~MFI_GEN2_ENABLE_INTERRUPT_MASK, &(regs)->outbound_intr_mask);\n\n\t \n\treadl(&regs->outbound_intr_mask);\n}\n\n \nstatic inline void\nmegasas_disable_intr_gen2(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0xFFFFFFFF;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t \n\treadl(&regs->outbound_intr_mask);\n}\n\n \nstatic u32\nmegasas_read_fw_status_reg_gen2(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_scratch_pad_0);\n}\n\n \nstatic int\nmegasas_clear_intr_gen2(struct megasas_instance *instance)\n{\n\tu32 status;\n\tu32 mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t \n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (status & MFI_INTR_FLAG_REPLY_MESSAGE) {\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\t}\n\tif (status & MFI_G2_OUTBOUND_DOORBELL_CHANGE_INTERRUPT) {\n\t\tmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\t}\n\n\t \n\tif (mfiStatus)\n\t\twritel(status, &regs->outbound_doorbell_clear);\n\n\t \n\treadl(&regs->outbound_intr_status);\n\n\treturn mfiStatus;\n}\n\n \nstatic inline void\nmegasas_fire_cmd_gen2(struct megasas_instance *instance,\n\t\t\tdma_addr_t frame_phys_addr,\n\t\t\tu32 frame_count,\n\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel((frame_phys_addr | (frame_count<<1))|1,\n\t\t\t&(regs)->inbound_queue_port);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n \nstatic int\nmegasas_adp_reset_gen2(struct megasas_instance *instance,\n\t\t\tstruct megasas_register_set __iomem *reg_set)\n{\n\tu32 retry = 0 ;\n\tu32 HostDiag;\n\tu32 __iomem *seq_offset = &reg_set->seq_offset;\n\tu32 __iomem *hostdiag_offset = &reg_set->host_diag;\n\n\tif (instance->instancet == &megasas_instance_template_skinny) {\n\t\tseq_offset = &reg_set->fusion_seq_offset;\n\t\thostdiag_offset = &reg_set->fusion_host_diag;\n\t}\n\n\twritel(0, seq_offset);\n\twritel(4, seq_offset);\n\twritel(0xb, seq_offset);\n\twritel(2, seq_offset);\n\twritel(7, seq_offset);\n\twritel(0xd, seq_offset);\n\n\tmsleep(1000);\n\n\tHostDiag = (u32)readl(hostdiag_offset);\n\n\twhile (!(HostDiag & DIAG_WRITE_ENABLE)) {\n\t\tmsleep(100);\n\t\tHostDiag = (u32)readl(hostdiag_offset);\n\t\tdev_notice(&instance->pdev->dev, \"RESETGEN2: retry=%x, hostdiag=%x\\n\",\n\t\t\t\t\tretry, HostDiag);\n\n\t\tif (retry++ >= 100)\n\t\t\treturn 1;\n\n\t}\n\n\tdev_notice(&instance->pdev->dev, \"ADP_RESET_GEN2: HostDiag=%x\\n\", HostDiag);\n\n\twritel((HostDiag | DIAG_RESET_ADAPTER), hostdiag_offset);\n\n\tssleep(10);\n\n\tHostDiag = (u32)readl(hostdiag_offset);\n\twhile (HostDiag & DIAG_RESET_ADAPTER) {\n\t\tmsleep(100);\n\t\tHostDiag = (u32)readl(hostdiag_offset);\n\t\tdev_notice(&instance->pdev->dev, \"RESET_GEN2: retry=%x, hostdiag=%x\\n\",\n\t\t\t\tretry, HostDiag);\n\n\t\tif (retry++ >= 1000)\n\t\t\treturn 1;\n\n\t}\n\treturn 0;\n}\n\n \nstatic int\nmegasas_check_reset_gen2(struct megasas_instance *instance,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_gen2 = {\n\n\t.fire_cmd = megasas_fire_cmd_gen2,\n\t.enable_intr = megasas_enable_intr_gen2,\n\t.disable_intr = megasas_disable_intr_gen2,\n\t.clear_intr = megasas_clear_intr_gen2,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_gen2,\n\t.adp_reset = megasas_adp_reset_gen2,\n\t.check_reset = megasas_check_reset_gen2,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n \n\n \nextern struct megasas_instance_template megasas_instance_template_fusion;\n\n \nint\nmegasas_issue_polled(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tstruct megasas_header *frame_hdr = &cmd->frame->hdr;\n\n\tframe_hdr->cmd_status = MFI_STAT_INVALID_STATUS;\n\tframe_hdr->flags |= cpu_to_le16(MFI_FRAME_DONT_POST_IN_REPLY_QUEUE);\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn DCMD_INIT;\n\t}\n\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\treturn wait_and_poll(instance, cmd, instance->requestorId ?\n\t\t\tMEGASAS_ROUTINE_WAIT_TIME_VF : MFI_IO_TIMEOUT_SECS);\n}\n\n \nint\nmegasas_issue_blocked_cmd(struct megasas_instance *instance,\n\t\t\t  struct megasas_cmd *cmd, int timeout)\n{\n\tint ret = 0;\n\tcmd->cmd_status_drv = DCMD_INIT;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn DCMD_INIT;\n\t}\n\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\tif (timeout) {\n\t\tret = wait_event_timeout(instance->int_cmd_wait_q,\n\t\tcmd->cmd_status_drv != DCMD_INIT, timeout * HZ);\n\t\tif (!ret) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"DCMD(opcode: 0x%x) is timed out, func:%s\\n\",\n\t\t\t\tcmd->frame->dcmd.opcode, __func__);\n\t\t\treturn DCMD_TIMEOUT;\n\t\t}\n\t} else\n\t\twait_event(instance->int_cmd_wait_q,\n\t\t\t\tcmd->cmd_status_drv != DCMD_INIT);\n\n\treturn cmd->cmd_status_drv;\n}\n\n \nstatic int\nmegasas_issue_blocked_abort_cmd(struct megasas_instance *instance,\n\t\t\t\tstruct megasas_cmd *cmd_to_abort, int timeout)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_abort_frame *abort_fr;\n\tint ret = 0;\n\tu32 opcode;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn -1;\n\n\tabort_fr = &cmd->frame->abort;\n\n\t \n\tabort_fr->cmd = MFI_CMD_ABORT;\n\tabort_fr->cmd_status = MFI_STAT_INVALID_STATUS;\n\tabort_fr->flags = cpu_to_le16(0);\n\tabort_fr->abort_context = cpu_to_le32(cmd_to_abort->index);\n\tabort_fr->abort_mfi_phys_addr_lo =\n\t\tcpu_to_le32(lower_32_bits(cmd_to_abort->frame_phys_addr));\n\tabort_fr->abort_mfi_phys_addr_hi =\n\t\tcpu_to_le32(upper_32_bits(cmd_to_abort->frame_phys_addr));\n\n\tcmd->sync_cmd = 1;\n\tcmd->cmd_status_drv = DCMD_INIT;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn DCMD_INIT;\n\t}\n\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\tif (timeout) {\n\t\tret = wait_event_timeout(instance->abort_cmd_wait_q,\n\t\tcmd->cmd_status_drv != DCMD_INIT, timeout * HZ);\n\t\tif (!ret) {\n\t\t\topcode = cmd_to_abort->frame->dcmd.opcode;\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Abort(to be aborted DCMD opcode: 0x%x) is timed out func:%s\\n\",\n\t\t\t\topcode,  __func__);\n\t\t\treturn DCMD_TIMEOUT;\n\t\t}\n\t} else\n\t\twait_event(instance->abort_cmd_wait_q,\n\t\tcmd->cmd_status_drv != DCMD_INIT);\n\n\tcmd->sync_cmd = 0;\n\n\tmegasas_return_cmd(instance, cmd);\n\treturn cmd->cmd_status_drv;\n}\n\n \nstatic int\nmegasas_make_sgl32(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   union megasas_sgl *mfi_sgl)\n{\n\tint i;\n\tint sge_count;\n\tstruct scatterlist *os_sgl;\n\n\tsge_count = scsi_dma_map(scp);\n\tBUG_ON(sge_count < 0);\n\n\tif (sge_count) {\n\t\tscsi_for_each_sg(scp, os_sgl, sge_count, i) {\n\t\t\tmfi_sgl->sge32[i].length = cpu_to_le32(sg_dma_len(os_sgl));\n\t\t\tmfi_sgl->sge32[i].phys_addr = cpu_to_le32(sg_dma_address(os_sgl));\n\t\t}\n\t}\n\treturn sge_count;\n}\n\n \nstatic int\nmegasas_make_sgl64(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   union megasas_sgl *mfi_sgl)\n{\n\tint i;\n\tint sge_count;\n\tstruct scatterlist *os_sgl;\n\n\tsge_count = scsi_dma_map(scp);\n\tBUG_ON(sge_count < 0);\n\n\tif (sge_count) {\n\t\tscsi_for_each_sg(scp, os_sgl, sge_count, i) {\n\t\t\tmfi_sgl->sge64[i].length = cpu_to_le32(sg_dma_len(os_sgl));\n\t\t\tmfi_sgl->sge64[i].phys_addr = cpu_to_le64(sg_dma_address(os_sgl));\n\t\t}\n\t}\n\treturn sge_count;\n}\n\n \nstatic int\nmegasas_make_sgl_skinny(struct megasas_instance *instance,\n\t\tstruct scsi_cmnd *scp, union megasas_sgl *mfi_sgl)\n{\n\tint i;\n\tint sge_count;\n\tstruct scatterlist *os_sgl;\n\n\tsge_count = scsi_dma_map(scp);\n\n\tif (sge_count) {\n\t\tscsi_for_each_sg(scp, os_sgl, sge_count, i) {\n\t\t\tmfi_sgl->sge_skinny[i].length =\n\t\t\t\tcpu_to_le32(sg_dma_len(os_sgl));\n\t\t\tmfi_sgl->sge_skinny[i].phys_addr =\n\t\t\t\tcpu_to_le64(sg_dma_address(os_sgl));\n\t\t\tmfi_sgl->sge_skinny[i].flag = cpu_to_le32(0);\n\t\t}\n\t}\n\treturn sge_count;\n}\n\n  \n\nstatic u32 megasas_get_frame_count(struct megasas_instance *instance,\n\t\t\tu8 sge_count, u8 frame_type)\n{\n\tint num_cnt;\n\tint sge_bytes;\n\tu32 sge_sz;\n\tu32 frame_count = 0;\n\n\tsge_sz = (IS_DMA64) ? sizeof(struct megasas_sge64) :\n\t    sizeof(struct megasas_sge32);\n\n\tif (instance->flag_ieee) {\n\t\tsge_sz = sizeof(struct megasas_sge_skinny);\n\t}\n\n\t \n\tif (unlikely(frame_type == PTHRU_FRAME)) {\n\t\tif (instance->flag_ieee == 1) {\n\t\t\tnum_cnt = sge_count - 1;\n\t\t} else if (IS_DMA64)\n\t\t\tnum_cnt = sge_count - 1;\n\t\telse\n\t\t\tnum_cnt = sge_count - 2;\n\t} else {\n\t\tif (instance->flag_ieee == 1) {\n\t\t\tnum_cnt = sge_count - 1;\n\t\t} else if (IS_DMA64)\n\t\t\tnum_cnt = sge_count - 2;\n\t\telse\n\t\t\tnum_cnt = sge_count - 3;\n\t}\n\n\tif (num_cnt > 0) {\n\t\tsge_bytes = sge_sz * num_cnt;\n\n\t\tframe_count = (sge_bytes / MEGAMFI_FRAME_SIZE) +\n\t\t    ((sge_bytes % MEGAMFI_FRAME_SIZE) ? 1 : 0) ;\n\t}\n\t \n\tframe_count += 1;\n\n\tif (frame_count > 7)\n\t\tframe_count = 8;\n\treturn frame_count;\n}\n\n \nstatic int\nmegasas_build_dcdb(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   struct megasas_cmd *cmd)\n{\n\tu32 is_logical;\n\tu32 device_id;\n\tu16 flags = 0;\n\tstruct megasas_pthru_frame *pthru;\n\n\tis_logical = MEGASAS_IS_LOGICAL(scp->device);\n\tdevice_id = MEGASAS_DEV_INDEX(scp);\n\tpthru = (struct megasas_pthru_frame *)cmd->frame;\n\n\tif (scp->sc_data_direction == DMA_TO_DEVICE)\n\t\tflags = MFI_FRAME_DIR_WRITE;\n\telse if (scp->sc_data_direction == DMA_FROM_DEVICE)\n\t\tflags = MFI_FRAME_DIR_READ;\n\telse if (scp->sc_data_direction == DMA_NONE)\n\t\tflags = MFI_FRAME_DIR_NONE;\n\n\tif (instance->flag_ieee == 1) {\n\t\tflags |= MFI_FRAME_IEEE;\n\t}\n\n\t \n\tpthru->cmd = (is_logical) ? MFI_CMD_LD_SCSI_IO : MFI_CMD_PD_SCSI_IO;\n\tpthru->cmd_status = 0x0;\n\tpthru->scsi_status = 0x0;\n\tpthru->target_id = device_id;\n\tpthru->lun = scp->device->lun;\n\tpthru->cdb_len = scp->cmd_len;\n\tpthru->timeout = 0;\n\tpthru->pad_0 = 0;\n\tpthru->flags = cpu_to_le16(flags);\n\tpthru->data_xfer_len = cpu_to_le32(scsi_bufflen(scp));\n\n\tmemcpy(pthru->cdb, scp->cmnd, scp->cmd_len);\n\n\t \n\tif (scp->device->type == TYPE_TAPE) {\n\t\tif (scsi_cmd_to_rq(scp)->timeout / HZ > 0xFFFF)\n\t\t\tpthru->timeout = cpu_to_le16(0xFFFF);\n\t\telse\n\t\t\tpthru->timeout = cpu_to_le16(scsi_cmd_to_rq(scp)->timeout / HZ);\n\t}\n\n\t \n\tif (instance->flag_ieee == 1) {\n\t\tpthru->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tpthru->sge_count = megasas_make_sgl_skinny(instance, scp,\n\t\t\t\t\t\t      &pthru->sgl);\n\t} else if (IS_DMA64) {\n\t\tpthru->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tpthru->sge_count = megasas_make_sgl64(instance, scp,\n\t\t\t\t\t\t      &pthru->sgl);\n\t} else\n\t\tpthru->sge_count = megasas_make_sgl32(instance, scp,\n\t\t\t\t\t\t      &pthru->sgl);\n\n\tif (pthru->sge_count > instance->max_num_sge) {\n\t\tdev_err(&instance->pdev->dev, \"DCDB too many SGE NUM=%x\\n\",\n\t\t\tpthru->sge_count);\n\t\treturn 0;\n\t}\n\n\t \n\tpthru->sense_len = SCSI_SENSE_BUFFERSIZE;\n\tpthru->sense_buf_phys_addr_hi =\n\t\tcpu_to_le32(upper_32_bits(cmd->sense_phys_addr));\n\tpthru->sense_buf_phys_addr_lo =\n\t\tcpu_to_le32(lower_32_bits(cmd->sense_phys_addr));\n\n\t \n\tcmd->frame_count = megasas_get_frame_count(instance, pthru->sge_count,\n\t\t\t\t\t\t\tPTHRU_FRAME);\n\n\treturn cmd->frame_count;\n}\n\n \nstatic int\nmegasas_build_ldio(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   struct megasas_cmd *cmd)\n{\n\tu32 device_id;\n\tu8 sc = scp->cmnd[0];\n\tu16 flags = 0;\n\tstruct megasas_io_frame *ldio;\n\n\tdevice_id = MEGASAS_DEV_INDEX(scp);\n\tldio = (struct megasas_io_frame *)cmd->frame;\n\n\tif (scp->sc_data_direction == DMA_TO_DEVICE)\n\t\tflags = MFI_FRAME_DIR_WRITE;\n\telse if (scp->sc_data_direction == DMA_FROM_DEVICE)\n\t\tflags = MFI_FRAME_DIR_READ;\n\n\tif (instance->flag_ieee == 1) {\n\t\tflags |= MFI_FRAME_IEEE;\n\t}\n\n\t \n\tldio->cmd = (sc & 0x02) ? MFI_CMD_LD_WRITE : MFI_CMD_LD_READ;\n\tldio->cmd_status = 0x0;\n\tldio->scsi_status = 0x0;\n\tldio->target_id = device_id;\n\tldio->timeout = 0;\n\tldio->reserved_0 = 0;\n\tldio->pad_0 = 0;\n\tldio->flags = cpu_to_le16(flags);\n\tldio->start_lba_hi = 0;\n\tldio->access_byte = (scp->cmd_len != 6) ? scp->cmnd[1] : 0;\n\n\t \n\tif (scp->cmd_len == 6) {\n\t\tldio->lba_count = cpu_to_le32((u32) scp->cmnd[4]);\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[1] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[2] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[3]);\n\n\t\tldio->start_lba_lo &= cpu_to_le32(0x1FFFFF);\n\t}\n\n\t \n\telse if (scp->cmd_len == 10) {\n\t\tldio->lba_count = cpu_to_le32((u32) scp->cmnd[8] |\n\t\t\t\t\t      ((u32) scp->cmnd[7] << 8));\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[2] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[3] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[4] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[5]);\n\t}\n\n\t \n\telse if (scp->cmd_len == 12) {\n\t\tldio->lba_count = cpu_to_le32(((u32) scp->cmnd[6] << 24) |\n\t\t\t\t\t      ((u32) scp->cmnd[7] << 16) |\n\t\t\t\t\t      ((u32) scp->cmnd[8] << 8) |\n\t\t\t\t\t      (u32) scp->cmnd[9]);\n\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[2] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[3] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[4] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[5]);\n\t}\n\n\t \n\telse if (scp->cmd_len == 16) {\n\t\tldio->lba_count = cpu_to_le32(((u32) scp->cmnd[10] << 24) |\n\t\t\t\t\t      ((u32) scp->cmnd[11] << 16) |\n\t\t\t\t\t      ((u32) scp->cmnd[12] << 8) |\n\t\t\t\t\t      (u32) scp->cmnd[13]);\n\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[6] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[7] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[8] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[9]);\n\n\t\tldio->start_lba_hi = cpu_to_le32(((u32) scp->cmnd[2] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[3] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[4] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[5]);\n\n\t}\n\n\t \n\tif (instance->flag_ieee) {\n\t\tldio->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tldio->sge_count = megasas_make_sgl_skinny(instance, scp,\n\t\t\t\t\t      &ldio->sgl);\n\t} else if (IS_DMA64) {\n\t\tldio->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tldio->sge_count = megasas_make_sgl64(instance, scp, &ldio->sgl);\n\t} else\n\t\tldio->sge_count = megasas_make_sgl32(instance, scp, &ldio->sgl);\n\n\tif (ldio->sge_count > instance->max_num_sge) {\n\t\tdev_err(&instance->pdev->dev, \"build_ld_io: sge_count = %x\\n\",\n\t\t\tldio->sge_count);\n\t\treturn 0;\n\t}\n\n\t \n\tldio->sense_len = SCSI_SENSE_BUFFERSIZE;\n\tldio->sense_buf_phys_addr_hi = 0;\n\tldio->sense_buf_phys_addr_lo = cpu_to_le32(cmd->sense_phys_addr);\n\n\t \n\tcmd->frame_count = megasas_get_frame_count(instance,\n\t\t\tldio->sge_count, IO_FRAME);\n\n\treturn cmd->frame_count;\n}\n\n \ninline int megasas_cmd_type(struct scsi_cmnd *cmd)\n{\n\tint ret;\n\n\tswitch (cmd->cmnd[0]) {\n\tcase READ_10:\n\tcase WRITE_10:\n\tcase READ_12:\n\tcase WRITE_12:\n\tcase READ_6:\n\tcase WRITE_6:\n\tcase READ_16:\n\tcase WRITE_16:\n\t\tret = (MEGASAS_IS_LOGICAL(cmd->device)) ?\n\t\t\tREAD_WRITE_LDIO : READ_WRITE_SYSPDIO;\n\t\tbreak;\n\tdefault:\n\t\tret = (MEGASAS_IS_LOGICAL(cmd->device)) ?\n\t\t\tNON_READ_WRITE_LDIO : NON_READ_WRITE_SYSPDIO;\n\t}\n\treturn ret;\n}\n\n  \nstatic inline void\nmegasas_dump_pending_frames(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tint i,n;\n\tunion megasas_sgl *mfi_sgl;\n\tstruct megasas_io_frame *ldio;\n\tstruct megasas_pthru_frame *pthru;\n\tu32 sgcount;\n\tu16 max_cmd = instance->max_fw_cmds;\n\n\tdev_err(&instance->pdev->dev, \"[%d]: Dumping Frame Phys Address of all pending cmds in FW\\n\",instance->host->host_no);\n\tdev_err(&instance->pdev->dev, \"[%d]: Total OS Pending cmds : %d\\n\",instance->host->host_no,atomic_read(&instance->fw_outstanding));\n\tif (IS_DMA64)\n\t\tdev_err(&instance->pdev->dev, \"[%d]: 64 bit SGLs were sent to FW\\n\",instance->host->host_no);\n\telse\n\t\tdev_err(&instance->pdev->dev, \"[%d]: 32 bit SGLs were sent to FW\\n\",instance->host->host_no);\n\n\tdev_err(&instance->pdev->dev, \"[%d]: Pending OS cmds in FW : \\n\",instance->host->host_no);\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tif (!cmd->scmd)\n\t\t\tcontinue;\n\t\tdev_err(&instance->pdev->dev, \"[%d]: Frame addr :0x%08lx : \",instance->host->host_no,(unsigned long)cmd->frame_phys_addr);\n\t\tif (megasas_cmd_type(cmd->scmd) == READ_WRITE_LDIO) {\n\t\t\tldio = (struct megasas_io_frame *)cmd->frame;\n\t\t\tmfi_sgl = &ldio->sgl;\n\t\t\tsgcount = ldio->sge_count;\n\t\t\tdev_err(&instance->pdev->dev, \"[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x,\"\n\t\t\t\" lba lo : 0x%x, lba_hi : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x\\n\",\n\t\t\tinstance->host->host_no, cmd->frame_count, ldio->cmd, ldio->target_id,\n\t\t\tle32_to_cpu(ldio->start_lba_lo), le32_to_cpu(ldio->start_lba_hi),\n\t\t\tle32_to_cpu(ldio->sense_buf_phys_addr_lo), sgcount);\n\t\t} else {\n\t\t\tpthru = (struct megasas_pthru_frame *) cmd->frame;\n\t\t\tmfi_sgl = &pthru->sgl;\n\t\t\tsgcount = pthru->sge_count;\n\t\t\tdev_err(&instance->pdev->dev, \"[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x, \"\n\t\t\t\"lun : 0x%x, cdb_len : 0x%x, data xfer len : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x\\n\",\n\t\t\tinstance->host->host_no, cmd->frame_count, pthru->cmd, pthru->target_id,\n\t\t\tpthru->lun, pthru->cdb_len, le32_to_cpu(pthru->data_xfer_len),\n\t\t\tle32_to_cpu(pthru->sense_buf_phys_addr_lo), sgcount);\n\t\t}\n\t\tif (megasas_dbg_lvl & MEGASAS_DBG_LVL) {\n\t\t\tfor (n = 0; n < sgcount; n++) {\n\t\t\t\tif (IS_DMA64)\n\t\t\t\t\tdev_err(&instance->pdev->dev, \"sgl len : 0x%x, sgl addr : 0x%llx\\n\",\n\t\t\t\t\t\tle32_to_cpu(mfi_sgl->sge64[n].length),\n\t\t\t\t\t\tle64_to_cpu(mfi_sgl->sge64[n].phys_addr));\n\t\t\t\telse\n\t\t\t\t\tdev_err(&instance->pdev->dev, \"sgl len : 0x%x, sgl addr : 0x%x\\n\",\n\t\t\t\t\t\tle32_to_cpu(mfi_sgl->sge32[n].length),\n\t\t\t\t\t\tle32_to_cpu(mfi_sgl->sge32[n].phys_addr));\n\t\t\t}\n\t\t}\n\t}  \n\tdev_err(&instance->pdev->dev, \"[%d]: Pending Internal cmds in FW : \\n\",instance->host->host_no);\n\tfor (i = 0; i < max_cmd; i++) {\n\n\t\tcmd = instance->cmd_list[i];\n\n\t\tif (cmd->sync_cmd == 1)\n\t\t\tdev_err(&instance->pdev->dev, \"0x%08lx : \", (unsigned long)cmd->frame_phys_addr);\n\t}\n\tdev_err(&instance->pdev->dev, \"[%d]: Dumping Done\\n\\n\",instance->host->host_no);\n}\n\nu32\nmegasas_build_and_issue_cmd(struct megasas_instance *instance,\n\t\t\t    struct scsi_cmnd *scmd)\n{\n\tstruct megasas_cmd *cmd;\n\tu32 frame_count;\n\n\tcmd = megasas_get_cmd(instance);\n\tif (!cmd)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\t \n\tif (megasas_cmd_type(scmd) == READ_WRITE_LDIO)\n\t\tframe_count = megasas_build_ldio(instance, scmd, cmd);\n\telse\n\t\tframe_count = megasas_build_dcdb(instance, scmd, cmd);\n\n\tif (!frame_count)\n\t\tgoto out_return_cmd;\n\n\tcmd->scmd = scmd;\n\tmegasas_priv(scmd)->cmd_priv = cmd;\n\n\t \n\tatomic_inc(&instance->fw_outstanding);\n\n\tinstance->instancet->fire_cmd(instance, cmd->frame_phys_addr,\n\t\t\t\tcmd->frame_count-1, instance->reg_set);\n\n\treturn 0;\nout_return_cmd:\n\tmegasas_return_cmd(instance, cmd);\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n}\n\n\n \nstatic int\nmegasas_queue_command(struct Scsi_Host *shost, struct scsi_cmnd *scmd)\n{\n\tstruct megasas_instance *instance;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\tu32 ld_tgt_id;\n\n\tinstance = (struct megasas_instance *)\n\t    scmd->device->host->hostdata;\n\n\tif (instance->unload == 1) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tif (instance->issuepend_done == 0)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\n\t \n\tif (atomic_read(&instance->adprecovery) == MEGASAS_ADPRESET_SM_INFAULT) {\n\t\tif (megasas_check_mpio_paths(instance, scmd) ==\n\t\t    (DID_REQUEUE << 16)) {\n\t\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t\t} else {\n\t\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\t\tscsi_done(scmd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmr_device_priv_data = scmd->device->hostdata;\n\tif (!mr_device_priv_data ||\n\t    (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tif (MEGASAS_IS_LOGICAL(scmd->device)) {\n\t\tld_tgt_id = MEGASAS_TARGET_ID(scmd->device);\n\t\tif (instance->ld_tgtid_status[ld_tgt_id] == LD_TARGET_ID_DELETED) {\n\t\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\t\tscsi_done(scmd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tif (mr_device_priv_data->tm_busy)\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\n\n\tscmd->result = 0;\n\n\tif (MEGASAS_IS_LOGICAL(scmd->device) &&\n\t    (scmd->device->id >= instance->fw_supported_vd_count ||\n\t\tscmd->device->lun)) {\n\t\tscmd->result = DID_BAD_TARGET << 16;\n\t\tgoto out_done;\n\t}\n\n\tif ((scmd->cmnd[0] == SYNCHRONIZE_CACHE) &&\n\t    MEGASAS_IS_LOGICAL(scmd->device) &&\n\t    (!instance->fw_sync_cache_support)) {\n\t\tscmd->result = DID_OK << 16;\n\t\tgoto out_done;\n\t}\n\n\treturn instance->instancet->build_and_issue_cmd(instance, scmd);\n\n out_done:\n\tscsi_done(scmd);\n\treturn 0;\n}\n\nstatic struct megasas_instance *megasas_lookup_instance(u16 host_no)\n{\n\tint i;\n\n\tfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\n\n\t\tif ((megasas_mgmt_info.instance[i]) &&\n\t\t    (megasas_mgmt_info.instance[i]->host->host_no == host_no))\n\t\t\treturn megasas_mgmt_info.instance[i];\n\t}\n\n\treturn NULL;\n}\n\n \nvoid megasas_set_dynamic_target_properties(struct scsi_device *sdev,\n\t\t\t\t\t   bool is_target_prop)\n{\n\tu16 pd_index = 0, ld;\n\tu32 device_id;\n\tstruct megasas_instance *instance;\n\tstruct fusion_context *fusion;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\tstruct MR_PD_CFG_SEQ_NUM_SYNC *pd_sync;\n\tstruct MR_LD_RAID *raid;\n\tstruct MR_DRV_RAID_MAP_ALL *local_map_ptr;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tfusion = instance->ctrl_context;\n\tmr_device_priv_data = sdev->hostdata;\n\n\tif (!fusion || !mr_device_priv_data)\n\t\treturn;\n\n\tif (MEGASAS_IS_LOGICAL(sdev)) {\n\t\tdevice_id = ((sdev->channel % 2) * MEGASAS_MAX_DEV_PER_CHANNEL)\n\t\t\t\t\t+ sdev->id;\n\t\tlocal_map_ptr = fusion->ld_drv_map[(instance->map_id & 1)];\n\t\tld = MR_TargetIdToLdGet(device_id, local_map_ptr);\n\t\tif (ld >= instance->fw_supported_vd_count)\n\t\t\treturn;\n\t\traid = MR_LdRaidGet(ld, local_map_ptr);\n\n\t\tif (raid->capability.ldPiMode == MR_PROT_INFO_TYPE_CONTROLLER)\n\t\t\tblk_queue_update_dma_alignment(sdev->request_queue, 0x7);\n\n\t\tmr_device_priv_data->is_tm_capable =\n\t\t\traid->capability.tmCapable;\n\n\t\tif (!raid->flags.isEPD)\n\t\t\tsdev->no_write_same = 1;\n\n\t} else if (instance->use_seqnum_jbod_fp) {\n\t\tpd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\n\t\t\tsdev->id;\n\t\tpd_sync = (void *)fusion->pd_seq_sync\n\t\t\t\t[(instance->pd_seq_map_id - 1) & 1];\n\t\tmr_device_priv_data->is_tm_capable =\n\t\t\tpd_sync->seq[pd_index].capability.tmCapable;\n\t}\n\n\tif (is_target_prop && instance->tgt_prop->reset_tmo) {\n\t\t \n\t\tmr_device_priv_data->target_reset_tmo =\n\t\t\tmin_t(u8, instance->max_reset_tmo,\n\t\t\t      instance->tgt_prop->reset_tmo);\n\t\tmr_device_priv_data->task_abort_tmo = instance->task_abort_tmo;\n\t} else {\n\t\tmr_device_priv_data->target_reset_tmo =\n\t\t\t\t\t\tMEGASAS_DEFAULT_TM_TIMEOUT;\n\t\tmr_device_priv_data->task_abort_tmo =\n\t\t\t\t\t\tMEGASAS_DEFAULT_TM_TIMEOUT;\n\t}\n}\n\n \nstatic inline void\nmegasas_set_nvme_device_properties(struct scsi_device *sdev, u32 max_io_size)\n{\n\tstruct megasas_instance *instance;\n\tu32 mr_nvme_pg_size;\n\n\tinstance = (struct megasas_instance *)sdev->host->hostdata;\n\tmr_nvme_pg_size = max_t(u32, instance->nvme_page_size,\n\t\t\t\tMR_DEFAULT_NVME_PAGE_SIZE);\n\n\tblk_queue_max_hw_sectors(sdev->request_queue, (max_io_size / 512));\n\n\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES, sdev->request_queue);\n\tblk_queue_virt_boundary(sdev->request_queue, mr_nvme_pg_size - 1);\n}\n\n \nstatic void megasas_set_fw_assisted_qd(struct scsi_device *sdev,\n\t\t\t\t\t\t bool is_target_prop)\n{\n\tu8 interface_type;\n\tu32 device_qd = MEGASAS_DEFAULT_CMD_PER_LUN;\n\tu32 tgt_device_qd;\n\tstruct megasas_instance *instance;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tmr_device_priv_data = sdev->hostdata;\n\tinterface_type  = mr_device_priv_data->interface_type;\n\n\tswitch (interface_type) {\n\tcase SAS_PD:\n\t\tdevice_qd = MEGASAS_SAS_QD;\n\t\tbreak;\n\tcase SATA_PD:\n\t\tdevice_qd = MEGASAS_SATA_QD;\n\t\tbreak;\n\tcase NVME_PD:\n\t\tdevice_qd = MEGASAS_NVME_QD;\n\t\tbreak;\n\t}\n\n\tif (is_target_prop) {\n\t\ttgt_device_qd = le32_to_cpu(instance->tgt_prop->device_qdepth);\n\t\tif (tgt_device_qd)\n\t\t\tdevice_qd = min(instance->host->can_queue,\n\t\t\t\t\t(int)tgt_device_qd);\n\t}\n\n\tif (instance->enable_sdev_max_qd && interface_type != UNKNOWN_DRIVE)\n\t\tdevice_qd = instance->host->can_queue;\n\n\tscsi_change_queue_depth(sdev, device_qd);\n}\n\n \nstatic void megasas_set_static_target_properties(struct scsi_device *sdev,\n\t\t\t\t\t\t bool is_target_prop)\n{\n\tu32 max_io_size_kb = MR_DEFAULT_NVME_MDTS_KB;\n\tstruct megasas_instance *instance;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\n\t \n\tblk_queue_rq_timeout(sdev->request_queue, scmd_timeout * HZ);\n\n\t \n\tif (is_target_prop)\n\t\tmax_io_size_kb = le32_to_cpu(instance->tgt_prop->max_io_size_kb);\n\n\tif (instance->nvme_page_size && max_io_size_kb)\n\t\tmegasas_set_nvme_device_properties(sdev, (max_io_size_kb << 10));\n\n\tmegasas_set_fw_assisted_qd(sdev, is_target_prop);\n}\n\n\nstatic int megasas_slave_configure(struct scsi_device *sdev)\n{\n\tu16 pd_index = 0;\n\tstruct megasas_instance *instance;\n\tint ret_target_prop = DCMD_FAILED;\n\tbool is_target_prop = false;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tif (instance->pd_list_not_supported) {\n\t\tif (!MEGASAS_IS_LOGICAL(sdev) && sdev->type == TYPE_DISK) {\n\t\t\tpd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\n\t\t\t\tsdev->id;\n\t\t\tif (instance->pd_list[pd_index].driveState !=\n\t\t\t\tMR_PD_STATE_SYSTEM)\n\t\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tmutex_lock(&instance->reset_mutex);\n\t \n\tif ((instance->pd_info) && !MEGASAS_IS_LOGICAL(sdev))\n\t\tmegasas_get_pd_info(instance, sdev);\n\n\t \n\tif ((instance->tgt_prop) && (instance->nvme_page_size))\n\t\tret_target_prop = megasas_get_target_prop(instance, sdev);\n\n\tis_target_prop = (ret_target_prop == DCMD_SUCCESS) ? true : false;\n\tmegasas_set_static_target_properties(sdev, is_target_prop);\n\n\t \n\tmegasas_set_dynamic_target_properties(sdev, is_target_prop);\n\n\tmutex_unlock(&instance->reset_mutex);\n\n\treturn 0;\n}\n\nstatic int megasas_slave_alloc(struct scsi_device *sdev)\n{\n\tu16 pd_index = 0, ld_tgt_id;\n\tstruct megasas_instance *instance ;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tif (!MEGASAS_IS_LOGICAL(sdev)) {\n\t\t \n\t\tpd_index =\n\t\t\t(sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\n\t\t\tsdev->id;\n\t\tif ((instance->pd_list_not_supported ||\n\t\t\tinstance->pd_list[pd_index].driveState ==\n\t\t\tMR_PD_STATE_SYSTEM)) {\n\t\t\tgoto scan_target;\n\t\t}\n\t\treturn -ENXIO;\n\t} else if (!MEGASAS_IS_LUN_VALID(sdev)) {\n\t\tsdev_printk(KERN_INFO, sdev, \"%s: invalid LUN\\n\", __func__);\n\t\treturn -ENXIO;\n\t}\n\nscan_target:\n\tmr_device_priv_data = kzalloc(sizeof(*mr_device_priv_data),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!mr_device_priv_data)\n\t\treturn -ENOMEM;\n\n\tif (MEGASAS_IS_LOGICAL(sdev)) {\n\t\tld_tgt_id = MEGASAS_TARGET_ID(sdev);\n\t\tinstance->ld_tgtid_status[ld_tgt_id] = LD_TARGET_ID_ACTIVE;\n\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\tsdev_printk(KERN_INFO, sdev, \"LD target ID %d created.\\n\", ld_tgt_id);\n\t}\n\n\tsdev->hostdata = mr_device_priv_data;\n\n\tatomic_set(&mr_device_priv_data->r1_ldio_hint,\n\t\t   instance->r1_ldio_hint_default);\n\treturn 0;\n}\n\nstatic void megasas_slave_destroy(struct scsi_device *sdev)\n{\n\tu16 ld_tgt_id;\n\tstruct megasas_instance *instance;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\n\tif (MEGASAS_IS_LOGICAL(sdev)) {\n\t\tif (!MEGASAS_IS_LUN_VALID(sdev)) {\n\t\t\tsdev_printk(KERN_INFO, sdev, \"%s: invalid LUN\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tld_tgt_id = MEGASAS_TARGET_ID(sdev);\n\t\tinstance->ld_tgtid_status[ld_tgt_id] = LD_TARGET_ID_DELETED;\n\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"LD target ID %d removed from OS stack\\n\", ld_tgt_id);\n\t}\n\n\tkfree(sdev->hostdata);\n\tsdev->hostdata = NULL;\n}\n\n \nstatic void megasas_complete_outstanding_ioctls(struct megasas_instance *instance)\n{\n\tint i;\n\tstruct megasas_cmd *cmd_mfi;\n\tstruct megasas_cmd_fusion *cmd_fusion;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\t \n\tif (fusion) {\n\t\tfor (i = 0; i < instance->max_fw_cmds; i++) {\n\t\t\tcmd_fusion = fusion->cmd_list[i];\n\t\t\tif (cmd_fusion->sync_cmd_idx != (u32)ULONG_MAX) {\n\t\t\t\tcmd_mfi = instance->cmd_list[cmd_fusion->sync_cmd_idx];\n\t\t\t\tif (cmd_mfi->sync_cmd &&\n\t\t\t\t    (cmd_mfi->frame->hdr.cmd != MFI_CMD_ABORT)) {\n\t\t\t\t\tcmd_mfi->frame->hdr.cmd_status =\n\t\t\t\t\t\t\tMFI_STAT_WRONG_STATE;\n\t\t\t\t\tmegasas_complete_cmd(instance,\n\t\t\t\t\t\t\t     cmd_mfi, DID_OK);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < instance->max_fw_cmds; i++) {\n\t\t\tcmd_mfi = instance->cmd_list[i];\n\t\t\tif (cmd_mfi->sync_cmd && cmd_mfi->frame->hdr.cmd !=\n\t\t\t\tMFI_CMD_ABORT)\n\t\t\t\tmegasas_complete_cmd(instance, cmd_mfi, DID_OK);\n\t\t}\n\t}\n}\n\n\nvoid megaraid_sas_kill_hba(struct megasas_instance *instance)\n{\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_warn(&instance->pdev->dev,\n\t\t\t \"Adapter already dead, skipping kill HBA\\n\");\n\t\treturn;\n\t}\n\n\t \n\tatomic_set(&instance->adprecovery, MEGASAS_HW_CRITICAL_ERROR);\n\t \n\tmsleep(1000);\n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\n\t\t(instance->adapter_type != MFI_SERIES)) {\n\t\tif (!instance->requestorId) {\n\t\t\twritel(MFI_STOP_ADP, &instance->reg_set->doorbell);\n\t\t\t \n\t\t\treadl(&instance->reg_set->doorbell);\n\t\t}\n\t\tif (instance->requestorId && instance->peerIsPresent)\n\t\t\tmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\n\t} else {\n\t\twritel(MFI_STOP_ADP,\n\t\t\t&instance->reg_set->inbound_doorbell);\n\t}\n\t \n\tmegasas_complete_outstanding_ioctls(instance);\n}\n\n  \nvoid\nmegasas_check_and_restore_queue_depth(struct megasas_instance *instance)\n{\n\tunsigned long flags;\n\n\tif (instance->flag & MEGASAS_FW_BUSY\n\t    && time_after(jiffies, instance->last_time + 5 * HZ)\n\t    && atomic_read(&instance->fw_outstanding) <\n\t    instance->throttlequeuedepth + 1) {\n\n\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\t\tinstance->flag &= ~MEGASAS_FW_BUSY;\n\n\t\tinstance->host->can_queue = instance->cur_can_queue;\n\t\tspin_unlock_irqrestore(instance->host->host_lock, flags);\n\t}\n}\n\n \nstatic void megasas_complete_cmd_dpc(unsigned long instance_addr)\n{\n\tu32 producer;\n\tu32 consumer;\n\tu32 context;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_instance *instance =\n\t\t\t\t(struct megasas_instance *)instance_addr;\n\tunsigned long flags;\n\n\t \n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)\n\t\treturn;\n\n\tspin_lock_irqsave(&instance->completion_lock, flags);\n\n\tproducer = le32_to_cpu(*instance->producer);\n\tconsumer = le32_to_cpu(*instance->consumer);\n\n\twhile (consumer != producer) {\n\t\tcontext = le32_to_cpu(instance->reply_queue[consumer]);\n\t\tif (context >= instance->max_fw_cmds) {\n\t\t\tdev_err(&instance->pdev->dev, \"Unexpected context value %x\\n\",\n\t\t\t\tcontext);\n\t\t\tBUG();\n\t\t}\n\n\t\tcmd = instance->cmd_list[context];\n\n\t\tmegasas_complete_cmd(instance, cmd, DID_OK);\n\n\t\tconsumer++;\n\t\tif (consumer == (instance->max_fw_cmds + 1)) {\n\t\t\tconsumer = 0;\n\t\t}\n\t}\n\n\t*instance->consumer = cpu_to_le32(producer);\n\n\tspin_unlock_irqrestore(&instance->completion_lock, flags);\n\n\t \n\tmegasas_check_and_restore_queue_depth(instance);\n}\n\nstatic void megasas_sriov_heartbeat_handler(struct timer_list *t);\n\n \nvoid megasas_start_timer(struct megasas_instance *instance)\n{\n\tstruct timer_list *timer = &instance->sriov_heartbeat_timer;\n\n\ttimer_setup(timer, megasas_sriov_heartbeat_handler, 0);\n\ttimer->expires = jiffies + MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF;\n\tadd_timer(timer);\n}\n\nstatic void\nmegasas_internal_reset_defer_cmds(struct megasas_instance *instance);\n\nstatic void\nprocess_fw_state_change_wq(struct work_struct *work);\n\nstatic void megasas_do_ocr(struct megasas_instance *instance)\n{\n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||\n\t(instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||\n\t(instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR)) {\n\t\t*instance->consumer = cpu_to_le32(MEGASAS_ADPRESET_INPROG_SIGN);\n\t}\n\tinstance->instancet->disable_intr(instance);\n\tatomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_INFAULT);\n\tinstance->issuepend_done = 0;\n\n\tatomic_set(&instance->fw_outstanding, 0);\n\tmegasas_internal_reset_defer_cmds(instance);\n\tprocess_fw_state_change_wq(&instance->work_init);\n}\n\nstatic int megasas_get_ld_vf_affiliation_111(struct megasas_instance *instance,\n\t\t\t\t\t    int initial)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_VF_AFFILIATION_111 *new_affiliation_111 = NULL;\n\tdma_addr_t new_affiliation_111_h;\n\tint ld, retval = 0;\n\tu8 thisVf;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_get_ld_vf_affiliation_111:\"\n\t\t       \"Failed to get cmd for scsi%d\\n\",\n\t\t\tinstance->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tif (!instance->vf_affiliation_111) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Couldn't get LD/VF \"\n\t\t       \"affiliation for scsi%d\\n\", instance->host->host_no);\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (initial)\n\t\t\tmemset(instance->vf_affiliation_111, 0,\n\t\t\t       sizeof(struct MR_LD_VF_AFFILIATION_111));\n\telse {\n\t\tnew_affiliation_111 =\n\t\t\tdma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t   sizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t\t   &new_affiliation_111_h, GFP_KERNEL);\n\t\tif (!new_affiliation_111) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SR-IOV: Couldn't allocate \"\n\t\t\t       \"memory for new affiliation for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_BOTH);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len =\n\t\tcpu_to_le32(sizeof(struct MR_LD_VF_AFFILIATION_111));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_VF_MAP_GET_ALL_LDS_111);\n\n\tif (initial)\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(instance->vf_affiliation_111_h);\n\telse\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(new_affiliation_111_h);\n\n\tdcmd->sgl.sge32[0].length = cpu_to_le32(\n\t\tsizeof(struct MR_LD_VF_AFFILIATION_111));\n\n\tdev_warn(&instance->pdev->dev, \"SR-IOV: Getting LD/VF affiliation for \"\n\t       \"scsi%d\\n\", instance->host->host_no);\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, 0) != DCMD_SUCCESS) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: LD/VF affiliation DCMD\"\n\t\t       \" failed with status 0x%x for scsi%d\\n\",\n\t\t       dcmd->cmd_status, instance->host->host_no);\n\t\tretval = 1;  \n\t\tgoto out;\n\t}\n\n\tif (!initial) {\n\t\tthisVf = new_affiliation_111->thisVf;\n\t\tfor (ld = 0 ; ld < new_affiliation_111->vdCount; ld++)\n\t\t\tif (instance->vf_affiliation_111->map[ld].policy[thisVf] !=\n\t\t\t    new_affiliation_111->map[ld].policy[thisVf]) {\n\t\t\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: \"\n\t\t\t\t       \"Got new LD/VF affiliation for scsi%d\\n\",\n\t\t\t\t       instance->host->host_no);\n\t\t\t\tmemcpy(instance->vf_affiliation_111,\n\t\t\t\t       new_affiliation_111,\n\t\t\t\t       sizeof(struct MR_LD_VF_AFFILIATION_111));\n\t\t\t\tretval = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t}\nout:\n\tif (new_affiliation_111) {\n\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t    new_affiliation_111,\n\t\t\t\t    new_affiliation_111_h);\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn retval;\n}\n\nstatic int megasas_get_ld_vf_affiliation_12(struct megasas_instance *instance,\n\t\t\t\t\t    int initial)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_VF_AFFILIATION *new_affiliation = NULL;\n\tstruct MR_LD_VF_MAP *newmap = NULL, *savedmap = NULL;\n\tdma_addr_t new_affiliation_h;\n\tint i, j, retval = 0, found = 0, doscan = 0;\n\tu8 thisVf;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_get_ld_vf_affiliation12: \"\n\t\t       \"Failed to get cmd for scsi%d\\n\",\n\t\t       instance->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tif (!instance->vf_affiliation) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Couldn't get LD/VF \"\n\t\t       \"affiliation for scsi%d\\n\", instance->host->host_no);\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (initial)\n\t\tmemset(instance->vf_affiliation, 0, (MAX_LOGICAL_DRIVES + 1) *\n\t\t       sizeof(struct MR_LD_VF_AFFILIATION));\n\telse {\n\t\tnew_affiliation =\n\t\t\tdma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t   (MAX_LOGICAL_DRIVES + 1) * sizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t\t   &new_affiliation_h, GFP_KERNEL);\n\t\tif (!new_affiliation) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SR-IOV: Couldn't allocate \"\n\t\t\t       \"memory for new affiliation for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_BOTH);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32((MAX_LOGICAL_DRIVES + 1) *\n\t\tsizeof(struct MR_LD_VF_AFFILIATION));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_VF_MAP_GET_ALL_LDS);\n\n\tif (initial)\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(instance->vf_affiliation_h);\n\telse\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(new_affiliation_h);\n\n\tdcmd->sgl.sge32[0].length = cpu_to_le32((MAX_LOGICAL_DRIVES + 1) *\n\t\tsizeof(struct MR_LD_VF_AFFILIATION));\n\n\tdev_warn(&instance->pdev->dev, \"SR-IOV: Getting LD/VF affiliation for \"\n\t       \"scsi%d\\n\", instance->host->host_no);\n\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, 0) != DCMD_SUCCESS) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: LD/VF affiliation DCMD\"\n\t\t       \" failed with status 0x%x for scsi%d\\n\",\n\t\t       dcmd->cmd_status, instance->host->host_no);\n\t\tretval = 1;  \n\t\tgoto out;\n\t}\n\n\tif (!initial) {\n\t\tif (!new_affiliation->ldCount) {\n\t\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Got new LD/VF \"\n\t\t\t       \"affiliation for passive path for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tretval = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tnewmap = new_affiliation->map;\n\t\tsavedmap = instance->vf_affiliation->map;\n\t\tthisVf = new_affiliation->thisVf;\n\t\tfor (i = 0 ; i < new_affiliation->ldCount; i++) {\n\t\t\tfound = 0;\n\t\t\tfor (j = 0; j < instance->vf_affiliation->ldCount;\n\t\t\t     j++) {\n\t\t\t\tif (newmap->ref.targetId ==\n\t\t\t\t    savedmap->ref.targetId) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif (newmap->policy[thisVf] !=\n\t\t\t\t\t    savedmap->policy[thisVf]) {\n\t\t\t\t\t\tdoscan = 1;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsavedmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t\t((unsigned char *)savedmap +\n\t\t\t\t\t savedmap->size);\n\t\t\t}\n\t\t\tif (!found && newmap->policy[thisVf] !=\n\t\t\t    MR_LD_ACCESS_HIDDEN) {\n\t\t\t\tdoscan = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnewmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t((unsigned char *)newmap + newmap->size);\n\t\t}\n\n\t\tnewmap = new_affiliation->map;\n\t\tsavedmap = instance->vf_affiliation->map;\n\n\t\tfor (i = 0 ; i < instance->vf_affiliation->ldCount; i++) {\n\t\t\tfound = 0;\n\t\t\tfor (j = 0 ; j < new_affiliation->ldCount; j++) {\n\t\t\t\tif (savedmap->ref.targetId ==\n\t\t\t\t    newmap->ref.targetId) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif (savedmap->policy[thisVf] !=\n\t\t\t\t\t    newmap->policy[thisVf]) {\n\t\t\t\t\t\tdoscan = 1;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnewmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t\t((unsigned char *)newmap +\n\t\t\t\t\t newmap->size);\n\t\t\t}\n\t\t\tif (!found && savedmap->policy[thisVf] !=\n\t\t\t    MR_LD_ACCESS_HIDDEN) {\n\t\t\t\tdoscan = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsavedmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t((unsigned char *)savedmap +\n\t\t\t\t savedmap->size);\n\t\t}\n\t}\nout:\n\tif (doscan) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Got new LD/VF \"\n\t\t       \"affiliation for scsi%d\\n\", instance->host->host_no);\n\t\tmemcpy(instance->vf_affiliation, new_affiliation,\n\t\t       new_affiliation->size);\n\t\tretval = 1;\n\t}\n\n\tif (new_affiliation)\n\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t    (MAX_LOGICAL_DRIVES + 1) *\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t    new_affiliation, new_affiliation_h);\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn retval;\n}\n\n \nstatic int megasas_get_ld_vf_affiliation(struct megasas_instance *instance,\n\tint initial)\n{\n\tint retval;\n\n\tif (instance->PlasmaFW111)\n\t\tretval = megasas_get_ld_vf_affiliation_111(instance, initial);\n\telse\n\t\tretval = megasas_get_ld_vf_affiliation_12(instance, initial);\n\treturn retval;\n}\n\n \nint megasas_sriov_start_heartbeat(struct megasas_instance *instance,\n\t\t\t\t\t int initial)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tint retval = 0;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_sriov_start_heartbeat: \"\n\t\t       \"Failed to get cmd for scsi%d\\n\",\n\t\t       instance->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tif (initial) {\n\t\tinstance->hb_host_mem =\n\t\t\tdma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t   sizeof(struct MR_CTRL_HB_HOST_MEM),\n\t\t\t\t\t   &instance->hb_host_mem_h,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!instance->hb_host_mem) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SR-IOV: Couldn't allocate\"\n\t\t\t       \" memory for heartbeat host memory for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.s[0] = cpu_to_le16(sizeof(struct MR_CTRL_HB_HOST_MEM));\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_BOTH);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_CTRL_HB_HOST_MEM));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_SHARED_HOST_MEM_ALLOC);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->hb_host_mem_h,\n\t\t\t\t sizeof(struct MR_CTRL_HB_HOST_MEM));\n\n\tdev_warn(&instance->pdev->dev, \"SR-IOV: Starting heartbeat for scsi%d\\n\",\n\t       instance->host->host_no);\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tretval = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\tMEGASAS_ROUTINE_WAIT_TIME_VF);\n\telse\n\t\tretval = megasas_issue_polled(instance, cmd);\n\n\tif (retval) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: MR_DCMD_CTRL_SHARED_HOST\"\n\t\t\t\"_MEM_ALLOC DCMD %s for scsi%d\\n\",\n\t\t\t(dcmd->cmd_status == MFI_STAT_INVALID_STATUS) ?\n\t\t\t\"timed out\" : \"failed\", instance->host->host_no);\n\t\tretval = 1;\n\t}\n\nout:\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn retval;\n}\n\n \nstatic void megasas_sriov_heartbeat_handler(struct timer_list *t)\n{\n\tstruct megasas_instance *instance =\n\t\tfrom_timer(instance, t, sriov_heartbeat_timer);\n\n\tif (instance->hb_host_mem->HB.fwCounter !=\n\t    instance->hb_host_mem->HB.driverCounter) {\n\t\tinstance->hb_host_mem->HB.driverCounter =\n\t\t\tinstance->hb_host_mem->HB.fwCounter;\n\t\tmod_timer(&instance->sriov_heartbeat_timer,\n\t\t\t  jiffies + MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF);\n\t} else {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Heartbeat never \"\n\t\t       \"completed for scsi%d\\n\", instance->host->host_no);\n\t\tschedule_work(&instance->work_init);\n\t}\n}\n\n \nstatic int megasas_wait_for_outstanding(struct megasas_instance *instance)\n{\n\tint i, sl, outstanding;\n\tu32 reset_index;\n\tu32 wait_time = MEGASAS_RESET_WAIT_TIME;\n\tunsigned long flags;\n\tstruct list_head clist_local;\n\tstruct megasas_cmd *reset_cmd;\n\tu32 fw_state;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_info(&instance->pdev->dev, \"%s:%d HBA is killed.\\n\",\n\t\t__func__, __LINE__);\n\t\treturn FAILED;\n\t}\n\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {\n\n\t\tINIT_LIST_HEAD(&clist_local);\n\t\tspin_lock_irqsave(&instance->hba_lock, flags);\n\t\tlist_splice_init(&instance->internal_reset_pending_q,\n\t\t\t\t&clist_local);\n\t\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\n\t\tdev_notice(&instance->pdev->dev, \"HBA reset wait ...\\n\");\n\t\tfor (i = 0; i < wait_time; i++) {\n\t\t\tmsleep(1000);\n\t\t\tif (atomic_read(&instance->adprecovery) == MEGASAS_HBA_OPERATIONAL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {\n\t\t\tdev_notice(&instance->pdev->dev, \"reset: Stopping HBA.\\n\");\n\t\t\tatomic_set(&instance->adprecovery, MEGASAS_HW_CRITICAL_ERROR);\n\t\t\treturn FAILED;\n\t\t}\n\n\t\treset_index = 0;\n\t\twhile (!list_empty(&clist_local)) {\n\t\t\treset_cmd = list_entry((&clist_local)->next,\n\t\t\t\t\t\tstruct megasas_cmd, list);\n\t\t\tlist_del_init(&reset_cmd->list);\n\t\t\tif (reset_cmd->scmd) {\n\t\t\t\treset_cmd->scmd->result = DID_REQUEUE << 16;\n\t\t\t\tdev_notice(&instance->pdev->dev, \"%d:%p reset [%02x]\\n\",\n\t\t\t\t\treset_index, reset_cmd,\n\t\t\t\t\treset_cmd->scmd->cmnd[0]);\n\n\t\t\t\tscsi_done(reset_cmd->scmd);\n\t\t\t\tmegasas_return_cmd(instance, reset_cmd);\n\t\t\t} else if (reset_cmd->sync_cmd) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"%p synch cmds\"\n\t\t\t\t\t\t\"reset queue\\n\",\n\t\t\t\t\t\treset_cmd);\n\n\t\t\t\treset_cmd->cmd_status_drv = DCMD_INIT;\n\t\t\t\tinstance->instancet->fire_cmd(instance,\n\t\t\t\t\t\treset_cmd->frame_phys_addr,\n\t\t\t\t\t\t0, instance->reg_set);\n\t\t\t} else {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"%p unexpected\"\n\t\t\t\t\t\"cmds lst\\n\",\n\t\t\t\t\treset_cmd);\n\t\t\t}\n\t\t\treset_index++;\n\t\t}\n\n\t\treturn SUCCESS;\n\t}\n\n\tfor (i = 0; i < resetwaittime; i++) {\n\t\toutstanding = atomic_read(&instance->fw_outstanding);\n\n\t\tif (!outstanding)\n\t\t\tbreak;\n\n\t\tif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\n\t\t\tdev_notice(&instance->pdev->dev, \"[%2d]waiting for %d \"\n\t\t\t       \"commands to complete\\n\",i,outstanding);\n\t\t\t \n\t\t\tmegasas_complete_cmd_dpc((unsigned long)instance);\n\t\t}\n\n\t\tmsleep(1000);\n\t}\n\n\ti = 0;\n\toutstanding = atomic_read(&instance->fw_outstanding);\n\tfw_state = instance->instancet->read_fw_status_reg(instance) & MFI_STATE_MASK;\n\n\tif ((!outstanding && (fw_state == MFI_STATE_OPERATIONAL)))\n\t\tgoto no_outstanding;\n\n\tif (instance->disableOnlineCtrlReset)\n\t\tgoto kill_hba_and_failed;\n\tdo {\n\t\tif ((fw_state == MFI_STATE_FAULT) || atomic_read(&instance->fw_outstanding)) {\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\"%s:%d waiting_for_outstanding: before issue OCR. FW state = 0x%x, outstanding 0x%x\\n\",\n\t\t\t\t__func__, __LINE__, fw_state, atomic_read(&instance->fw_outstanding));\n\t\t\tif (i == 3)\n\t\t\t\tgoto kill_hba_and_failed;\n\t\t\tmegasas_do_ocr(instance);\n\n\t\t\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\t\t\tdev_info(&instance->pdev->dev, \"%s:%d OCR failed and HBA is killed.\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\t\treturn FAILED;\n\t\t\t}\n\t\t\tdev_info(&instance->pdev->dev, \"%s:%d waiting_for_outstanding: after issue OCR.\\n\",\n\t\t\t\t__func__, __LINE__);\n\n\t\t\tfor (sl = 0; sl < 10; sl++)\n\t\t\t\tmsleep(500);\n\n\t\t\toutstanding = atomic_read(&instance->fw_outstanding);\n\n\t\t\tfw_state = instance->instancet->read_fw_status_reg(instance) & MFI_STATE_MASK;\n\t\t\tif ((!outstanding && (fw_state == MFI_STATE_OPERATIONAL)))\n\t\t\t\tgoto no_outstanding;\n\t\t}\n\t\ti++;\n\t} while (i <= 3);\n\nno_outstanding:\n\n\tdev_info(&instance->pdev->dev, \"%s:%d no more pending commands remain after reset handling.\\n\",\n\t\t__func__, __LINE__);\n\treturn SUCCESS;\n\nkill_hba_and_failed:\n\n\t \n\tdev_info(&instance->pdev->dev, \"%s:%d killing adapter scsi%d\"\n\t\t\" disableOnlineCtrlReset %d fw_outstanding %d \\n\",\n\t\t__func__, __LINE__, instance->host->host_no, instance->disableOnlineCtrlReset,\n\t\tatomic_read(&instance->fw_outstanding));\n\tmegasas_dump_pending_frames(instance);\n\tmegaraid_sas_kill_hba(instance);\n\n\treturn FAILED;\n}\n\n \nstatic int megasas_generic_reset(struct scsi_cmnd *scmd)\n{\n\tint ret_val;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tscmd_printk(KERN_NOTICE, scmd, \"megasas: RESET cmd=%x retries=%x\\n\",\n\t\t scmd->cmnd[0], scmd->retries);\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"cannot recover from previous reset failures\\n\");\n\t\treturn FAILED;\n\t}\n\n\tret_val = megasas_wait_for_outstanding(instance);\n\tif (ret_val == SUCCESS)\n\t\tdev_notice(&instance->pdev->dev, \"reset successful\\n\");\n\telse\n\t\tdev_err(&instance->pdev->dev, \"failed to do reset\\n\");\n\n\treturn ret_val;\n}\n\n \nstatic enum scsi_timeout_action megasas_reset_timer(struct scsi_cmnd *scmd)\n{\n\tstruct megasas_instance *instance;\n\tunsigned long flags;\n\n\tif (time_after(jiffies, scmd->jiffies_at_alloc +\n\t\t\t\t(scmd_timeout * 2) * HZ)) {\n\t\treturn SCSI_EH_NOT_HANDLED;\n\t}\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\tif (!(instance->flag & MEGASAS_FW_BUSY)) {\n\t\t \n\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\n\t\tinstance->host->can_queue = instance->throttlequeuedepth;\n\t\tinstance->last_time = jiffies;\n\t\tinstance->flag |= MEGASAS_FW_BUSY;\n\n\t\tspin_unlock_irqrestore(instance->host->host_lock, flags);\n\t}\n\treturn SCSI_EH_RESET_TIMER;\n}\n\n \ninline void\nmegasas_dump(void *buf, int sz, int format)\n{\n\tint i;\n\t__le32 *buf_loc = (__le32 *)buf;\n\n\tfor (i = 0; i < (sz / sizeof(__le32)); i++) {\n\t\tif ((i % format) == 0) {\n\t\t\tif (i != 0)\n\t\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_CONT \"%08x: \", (i * 4));\n\t\t}\n\t\tprintk(KERN_CONT \"%08x \", le32_to_cpu(buf_loc[i]));\n\t}\n\tprintk(KERN_CONT \"\\n\");\n}\n\n \ninline void\nmegasas_dump_reg_set(void __iomem *reg_set)\n{\n\tunsigned int i, sz = 256;\n\tu32 __iomem *reg = (u32 __iomem *)reg_set;\n\n\tfor (i = 0; i < (sz / sizeof(u32)); i++)\n\t\tprintk(\"%08x: %08x\\n\", (i * 4), readl(&reg[i]));\n}\n\n \nvoid\nmegasas_dump_fusion_io(struct scsi_cmnd *scmd)\n{\n\tstruct megasas_cmd_fusion *cmd = megasas_priv(scmd)->cmd_priv;\n\tunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tscmd_printk(KERN_INFO, scmd,\n\t\t    \"scmd: (0x%p)  retries: 0x%x  allowed: 0x%x\\n\",\n\t\t    scmd, scmd->retries, scmd->allowed);\n\tscsi_print_command(scmd);\n\n\tif (cmd) {\n\t\treq_desc = (union MEGASAS_REQUEST_DESCRIPTOR_UNION *)cmd->request_desc;\n\t\tscmd_printk(KERN_INFO, scmd, \"Request descriptor details:\\n\");\n\t\tscmd_printk(KERN_INFO, scmd,\n\t\t\t    \"RequestFlags:0x%x  MSIxIndex:0x%x  SMID:0x%x  LMID:0x%x  DevHandle:0x%x\\n\",\n\t\t\t    req_desc->SCSIIO.RequestFlags,\n\t\t\t    req_desc->SCSIIO.MSIxIndex, req_desc->SCSIIO.SMID,\n\t\t\t    req_desc->SCSIIO.LMID, req_desc->SCSIIO.DevHandle);\n\n\t\tprintk(KERN_INFO \"IO request frame:\\n\");\n\t\tmegasas_dump(cmd->io_request,\n\t\t\t     MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE, 8);\n\t\tprintk(KERN_INFO \"Chain frame:\\n\");\n\t\tmegasas_dump(cmd->sg_frame,\n\t\t\t     instance->max_chain_frame_sz, 8);\n\t}\n\n}\n\n \nstatic inline ssize_t\nmegasas_dump_sys_regs(void __iomem *reg_set, char *buf)\n{\n\tunsigned int i, sz = 256;\n\tint bytes_wrote = 0;\n\tchar *loc = (char *)buf;\n\tu32 __iomem *reg = (u32 __iomem *)reg_set;\n\n\tfor (i = 0; i < sz / sizeof(u32); i++) {\n\t\tbytes_wrote += scnprintf(loc + bytes_wrote,\n\t\t\t\t\t PAGE_SIZE - bytes_wrote,\n\t\t\t\t\t \"%08x: %08x\\n\", (i * 4),\n\t\t\t\t\t readl(&reg[i]));\n\t}\n\treturn bytes_wrote;\n}\n\n \nstatic int megasas_reset_bus_host(struct scsi_cmnd *scmd)\n{\n\tint ret;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tscmd_printk(KERN_INFO, scmd,\n\t\t\"OCR is requested due to IO timeout!!\\n\");\n\n\tscmd_printk(KERN_INFO, scmd,\n\t\t\"SCSI host state: %d  SCSI host busy: %d  FW outstanding: %d\\n\",\n\t\tscmd->device->host->shost_state,\n\t\tscsi_host_busy(scmd->device->host),\n\t\tatomic_read(&instance->fw_outstanding));\n\t \n\tif (instance->adapter_type == MFI_SERIES) {\n\t\tret = megasas_generic_reset(scmd);\n\t} else {\n\t\tmegasas_dump_fusion_io(scmd);\n\t\tret = megasas_reset_fusion(scmd->device->host,\n\t\t\t\tSCSIIO_TIMEOUT_OCR);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int megasas_task_abort(struct scsi_cmnd *scmd)\n{\n\tint ret;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tret = megasas_task_abort_fusion(scmd);\n\telse {\n\t\tsdev_printk(KERN_NOTICE, scmd->device, \"TASK ABORT not supported\\n\");\n\t\tret = FAILED;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int megasas_reset_target(struct scsi_cmnd *scmd)\n{\n\tint ret;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tret = megasas_reset_target_fusion(scmd);\n\telse {\n\t\tsdev_printk(KERN_NOTICE, scmd->device, \"TARGET RESET not supported\\n\");\n\t\tret = FAILED;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\nmegasas_bios_param(struct scsi_device *sdev, struct block_device *bdev,\n\t\t sector_t capacity, int geom[])\n{\n\tint heads;\n\tint sectors;\n\tsector_t cylinders;\n\tunsigned long tmp;\n\n\t \n\theads = 64;\n\tsectors = 32;\n\n\ttmp = heads * sectors;\n\tcylinders = capacity;\n\n\tsector_div(cylinders, tmp);\n\n\t \n\n\tif (capacity >= 0x200000) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\ttmp = heads*sectors;\n\t\tcylinders = capacity;\n\t\tsector_div(cylinders, tmp);\n\t}\n\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\n\treturn 0;\n}\n\nstatic void megasas_map_queues(struct Scsi_Host *shost)\n{\n\tstruct megasas_instance *instance;\n\tint qoff = 0, offset;\n\tstruct blk_mq_queue_map *map;\n\n\tinstance = (struct megasas_instance *)shost->hostdata;\n\n\tif (shost->nr_hw_queues == 1)\n\t\treturn;\n\n\toffset = instance->low_latency_index_start;\n\n\t \n\tmap = &shost->tag_set.map[HCTX_TYPE_DEFAULT];\n\tmap->nr_queues = instance->msix_vectors - offset;\n\tmap->queue_offset = 0;\n\tblk_mq_pci_map_queues(map, instance->pdev, offset);\n\tqoff += map->nr_queues;\n\toffset += map->nr_queues;\n\n\t \n\tshost->tag_set.map[HCTX_TYPE_READ].nr_queues = 0;\n\n\t \n\tmap = &shost->tag_set.map[HCTX_TYPE_POLL];\n\tmap->nr_queues = instance->iopoll_q_count;\n\tif (map->nr_queues) {\n\t\t \n\t\tmap->queue_offset = qoff;\n\t\tblk_mq_map_queues(map);\n\t}\n}\n\nstatic void megasas_aen_polling(struct work_struct *work);\n\n \nstatic void\nmegasas_service_aen(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tunsigned long flags;\n\n\t \n\tif ((!cmd->abort_aen) && (instance->unload == 0)) {\n\t\tspin_lock_irqsave(&poll_aen_lock, flags);\n\t\tmegasas_poll_wait_aen = 1;\n\t\tspin_unlock_irqrestore(&poll_aen_lock, flags);\n\t\twake_up(&megasas_poll_wait);\n\t\tkill_fasync(&megasas_async_queue, SIGIO, POLL_IN);\n\t}\n\telse\n\t\tcmd->abort_aen = 0;\n\n\tinstance->aen_cmd = NULL;\n\n\tmegasas_return_cmd(instance, cmd);\n\n\tif ((instance->unload == 0) &&\n\t\t((instance->issuepend_done == 1))) {\n\t\tstruct megasas_aen_event *ev;\n\n\t\tev = kzalloc(sizeof(*ev), GFP_ATOMIC);\n\t\tif (!ev) {\n\t\t\tdev_err(&instance->pdev->dev, \"megasas_service_aen: out of memory\\n\");\n\t\t} else {\n\t\t\tev->instance = instance;\n\t\t\tinstance->ev = ev;\n\t\t\tINIT_DELAYED_WORK(&ev->hotplug_work,\n\t\t\t\t\t  megasas_aen_polling);\n\t\t\tschedule_delayed_work(&ev->hotplug_work, 0);\n\t\t}\n\t}\n}\n\nstatic ssize_t\nfw_crash_buffer_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\tint val = 0;\n\n\tif (kstrtoint(buf, 0, &val) != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&instance->crashdump_lock);\n\tinstance->fw_crash_buffer_offset = val;\n\tmutex_unlock(&instance->crashdump_lock);\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nfw_crash_buffer_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\tu32 size;\n\tunsigned long dmachunk = CRASH_DMA_BUF_SIZE;\n\tunsigned long chunk_left_bytes;\n\tunsigned long src_addr;\n\tu32 buff_offset;\n\n\tmutex_lock(&instance->crashdump_lock);\n\tbuff_offset = instance->fw_crash_buffer_offset;\n\tif (!instance->crash_dump_buf ||\n\t\t!((instance->fw_crash_state == AVAILABLE) ||\n\t\t(instance->fw_crash_state == COPYING))) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Firmware crash dump is not available\\n\");\n\t\tmutex_unlock(&instance->crashdump_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (buff_offset > (instance->fw_crash_buffer_size * dmachunk)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Firmware crash dump offset is out of range\\n\");\n\t\tmutex_unlock(&instance->crashdump_lock);\n\t\treturn 0;\n\t}\n\n\tsize = (instance->fw_crash_buffer_size * dmachunk) - buff_offset;\n\tchunk_left_bytes = dmachunk - (buff_offset % dmachunk);\n\tsize = (size > chunk_left_bytes) ? chunk_left_bytes : size;\n\tsize = (size >= PAGE_SIZE) ? (PAGE_SIZE - 1) : size;\n\n\tsrc_addr = (unsigned long)instance->crash_buf[buff_offset / dmachunk] +\n\t\t(buff_offset % dmachunk);\n\tmemcpy(buf, (void *)src_addr, size);\n\tmutex_unlock(&instance->crashdump_lock);\n\n\treturn size;\n}\n\nstatic ssize_t\nfw_crash_buffer_size_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%ld\\n\", (unsigned long)\n\t\t((instance->fw_crash_buffer_size) * 1024 * 1024)/PAGE_SIZE);\n}\n\nstatic ssize_t\nfw_crash_state_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\tint val = 0;\n\n\tif (kstrtoint(buf, 0, &val) != 0)\n\t\treturn -EINVAL;\n\n\tif ((val <= AVAILABLE || val > COPY_ERROR)) {\n\t\tdev_err(&instance->pdev->dev, \"application updates invalid \"\n\t\t\t\"firmware crash state\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinstance->fw_crash_state = val;\n\n\tif ((val == COPIED) || (val == COPY_ERROR)) {\n\t\tmutex_lock(&instance->crashdump_lock);\n\t\tmegasas_free_host_crash_buffer(instance);\n\t\tmutex_unlock(&instance->crashdump_lock);\n\t\tif (val == COPY_ERROR)\n\t\t\tdev_info(&instance->pdev->dev, \"application failed to \"\n\t\t\t\t\"copy Firmware crash dump\\n\");\n\t\telse\n\t\t\tdev_info(&instance->pdev->dev, \"Firmware crash dump \"\n\t\t\t\t\"copied successfully\\n\");\n\t}\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nfw_crash_state_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", instance->fw_crash_state);\n}\n\nstatic ssize_t\npage_size_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%ld\\n\", (unsigned long)PAGE_SIZE - 1);\n}\n\nstatic ssize_t\nldio_outstanding_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance = (struct megasas_instance *)shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", atomic_read(&instance->ldio_outstanding));\n}\n\nstatic ssize_t\nfw_cmds_outstanding_show(struct device *cdev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance = (struct megasas_instance *)shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", atomic_read(&instance->fw_outstanding));\n}\n\nstatic ssize_t\nenable_sdev_max_qd_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance = (struct megasas_instance *)shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", instance->enable_sdev_max_qd);\n}\n\nstatic ssize_t\nenable_sdev_max_qd_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance = (struct megasas_instance *)shost->hostdata;\n\tu32 val = 0;\n\tbool is_target_prop;\n\tint ret_target_prop = DCMD_FAILED;\n\tstruct scsi_device *sdev;\n\n\tif (kstrtou32(buf, 0, &val) != 0) {\n\t\tpr_err(\"megasas: could not set enable_sdev_max_qd\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&instance->reset_mutex);\n\tif (val)\n\t\tinstance->enable_sdev_max_qd = true;\n\telse\n\t\tinstance->enable_sdev_max_qd = false;\n\n\tshost_for_each_device(sdev, shost) {\n\t\tret_target_prop = megasas_get_target_prop(instance, sdev);\n\t\tis_target_prop = (ret_target_prop == DCMD_SUCCESS) ? true : false;\n\t\tmegasas_set_fw_assisted_qd(sdev, is_target_prop);\n\t}\n\tmutex_unlock(&instance->reset_mutex);\n\n\treturn strlen(buf);\n}\n\nstatic ssize_t\ndump_system_regs_show(struct device *cdev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t\t(struct megasas_instance *)shost->hostdata;\n\n\treturn megasas_dump_sys_regs(instance->reg_set, buf);\n}\n\nstatic ssize_t\nraid_map_id_show(struct device *cdev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t\t(struct megasas_instance *)shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%ld\\n\",\n\t\t\t(unsigned long)instance->map_id);\n}\n\nstatic DEVICE_ATTR_RW(fw_crash_buffer);\nstatic DEVICE_ATTR_RO(fw_crash_buffer_size);\nstatic DEVICE_ATTR_RW(fw_crash_state);\nstatic DEVICE_ATTR_RO(page_size);\nstatic DEVICE_ATTR_RO(ldio_outstanding);\nstatic DEVICE_ATTR_RO(fw_cmds_outstanding);\nstatic DEVICE_ATTR_RW(enable_sdev_max_qd);\nstatic DEVICE_ATTR_RO(dump_system_regs);\nstatic DEVICE_ATTR_RO(raid_map_id);\n\nstatic struct attribute *megaraid_host_attrs[] = {\n\t&dev_attr_fw_crash_buffer_size.attr,\n\t&dev_attr_fw_crash_buffer.attr,\n\t&dev_attr_fw_crash_state.attr,\n\t&dev_attr_page_size.attr,\n\t&dev_attr_ldio_outstanding.attr,\n\t&dev_attr_fw_cmds_outstanding.attr,\n\t&dev_attr_enable_sdev_max_qd.attr,\n\t&dev_attr_dump_system_regs.attr,\n\t&dev_attr_raid_map_id.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(megaraid_host);\n\n \nstatic const struct scsi_host_template megasas_template = {\n\n\t.module = THIS_MODULE,\n\t.name = \"Avago SAS based MegaRAID driver\",\n\t.proc_name = \"megaraid_sas\",\n\t.slave_configure = megasas_slave_configure,\n\t.slave_alloc = megasas_slave_alloc,\n\t.slave_destroy = megasas_slave_destroy,\n\t.queuecommand = megasas_queue_command,\n\t.eh_target_reset_handler = megasas_reset_target,\n\t.eh_abort_handler = megasas_task_abort,\n\t.eh_host_reset_handler = megasas_reset_bus_host,\n\t.eh_timed_out = megasas_reset_timer,\n\t.shost_groups = megaraid_host_groups,\n\t.bios_param = megasas_bios_param,\n\t.map_queues = megasas_map_queues,\n\t.mq_poll = megasas_blk_mq_poll,\n\t.change_queue_depth = scsi_change_queue_depth,\n\t.max_segment_size = 0xffffffff,\n\t.cmd_size = sizeof(struct megasas_cmd_priv),\n};\n\n \nstatic void\nmegasas_complete_int_cmd(struct megasas_instance *instance,\n\t\t\t struct megasas_cmd *cmd)\n{\n\tif (cmd->cmd_status_drv == DCMD_INIT)\n\t\tcmd->cmd_status_drv =\n\t\t(cmd->frame->io.cmd_status == MFI_STAT_OK) ?\n\t\tDCMD_SUCCESS : DCMD_FAILED;\n\n\twake_up(&instance->int_cmd_wait_q);\n}\n\n \nstatic void\nmegasas_complete_abort(struct megasas_instance *instance,\n\t\t       struct megasas_cmd *cmd)\n{\n\tif (cmd->sync_cmd) {\n\t\tcmd->sync_cmd = 0;\n\t\tcmd->cmd_status_drv = DCMD_SUCCESS;\n\t\twake_up(&instance->abort_cmd_wait_q);\n\t}\n}\n\nstatic void\nmegasas_set_ld_removed_by_fw(struct megasas_instance *instance)\n{\n\tuint i;\n\n\tfor (i = 0; (i < MEGASAS_MAX_LD_IDS); i++) {\n\t\tif (instance->ld_ids_prev[i] != 0xff &&\n\t\t    instance->ld_ids_from_raidmap[i] == 0xff) {\n\t\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t \"LD target ID %d removed from RAID map\\n\", i);\n\t\t\tinstance->ld_tgtid_status[i] = LD_TARGET_ID_DELETED;\n\t\t}\n\t}\n}\n\n \nvoid\nmegasas_complete_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd,\n\t\t     u8 alt_status)\n{\n\tint exception = 0;\n\tstruct megasas_header *hdr = &cmd->frame->hdr;\n\tunsigned long flags;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tu32 opcode, status;\n\n\t \n\tcmd->retry_for_fw_reset = 0;\n\n\tif (cmd->scmd)\n\t\tmegasas_priv(cmd->scmd)->cmd_priv = NULL;\n\n\tswitch (hdr->cmd) {\n\tcase MFI_CMD_INVALID:\n\t\t \n\t\tdev_warn(&instance->pdev->dev, \"MFI_CMD_INVALID command \"\n\t\t       \"completed\\n\");\n\t\tdev_warn(&instance->pdev->dev, \"If you have a controller \"\n\t\t       \"other than PERC5, please upgrade your firmware\\n\");\n\t\tbreak;\n\tcase MFI_CMD_PD_SCSI_IO:\n\tcase MFI_CMD_LD_SCSI_IO:\n\n\t\t \n\t\tif (cmd->sync_cmd) {\n\t\t\tcmd->sync_cmd = 0;\n\t\t\tmegasas_complete_int_cmd(instance, cmd);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tcase MFI_CMD_LD_READ:\n\tcase MFI_CMD_LD_WRITE:\n\n\t\tif (alt_status) {\n\t\t\tcmd->scmd->result = alt_status << 16;\n\t\t\texception = 1;\n\t\t}\n\n\t\tif (exception) {\n\n\t\t\tatomic_dec(&instance->fw_outstanding);\n\n\t\t\tscsi_dma_unmap(cmd->scmd);\n\t\t\tscsi_done(cmd->scmd);\n\t\t\tmegasas_return_cmd(instance, cmd);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (hdr->cmd_status) {\n\n\t\tcase MFI_STAT_OK:\n\t\t\tcmd->scmd->result = DID_OK << 16;\n\t\t\tbreak;\n\n\t\tcase MFI_STAT_SCSI_IO_FAILED:\n\t\tcase MFI_STAT_LD_INIT_IN_PROGRESS:\n\t\t\tcmd->scmd->result =\n\t\t\t    (DID_ERROR << 16) | hdr->scsi_status;\n\t\t\tbreak;\n\n\t\tcase MFI_STAT_SCSI_DONE_WITH_ERROR:\n\n\t\t\tcmd->scmd->result = (DID_OK << 16) | hdr->scsi_status;\n\n\t\t\tif (hdr->scsi_status == SAM_STAT_CHECK_CONDITION) {\n\t\t\t\tmemset(cmd->scmd->sense_buffer, 0,\n\t\t\t\t       SCSI_SENSE_BUFFERSIZE);\n\t\t\t\tmemcpy(cmd->scmd->sense_buffer, cmd->sense,\n\t\t\t\t       hdr->sense_len);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase MFI_STAT_LD_OFFLINE:\n\t\tcase MFI_STAT_DEVICE_NOT_FOUND:\n\t\t\tcmd->scmd->result = DID_BAD_TARGET << 16;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"MFI FW status %#x\\n\",\n\t\t\t       hdr->cmd_status);\n\t\t\tcmd->scmd->result = DID_ERROR << 16;\n\t\t\tbreak;\n\t\t}\n\n\t\tatomic_dec(&instance->fw_outstanding);\n\n\t\tscsi_dma_unmap(cmd->scmd);\n\t\tscsi_done(cmd->scmd);\n\t\tmegasas_return_cmd(instance, cmd);\n\n\t\tbreak;\n\n\tcase MFI_CMD_SMP:\n\tcase MFI_CMD_STP:\n\tcase MFI_CMD_NVME:\n\tcase MFI_CMD_TOOLBOX:\n\t\tmegasas_complete_int_cmd(instance, cmd);\n\t\tbreak;\n\n\tcase MFI_CMD_DCMD:\n\t\topcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n\t\t \n\t\tif ((opcode == MR_DCMD_LD_MAP_GET_INFO)\n\t\t\t&& (cmd->frame->dcmd.mbox.b[1] == 1)) {\n\t\t\tfusion->fast_path_io = 0;\n\t\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\t\t\tstatus = cmd->frame->hdr.cmd_status;\n\t\t\tinstance->map_update_cmd = NULL;\n\t\t\tif (status != MFI_STAT_OK) {\n\t\t\t\tif (status != MFI_STAT_NOT_FOUND)\n\t\t\t\t\tdev_warn(&instance->pdev->dev, \"map syncfailed, status = 0x%x\\n\",\n\t\t\t\t\t       cmd->frame->hdr.cmd_status);\n\t\t\t\telse {\n\t\t\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\tinstance->host->host_lock,\n\t\t\t\t\t\tflags);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmegasas_return_cmd(instance, cmd);\n\n\t\t\t \n\t\t\tif (status == MFI_STAT_OK &&\n\t\t\t    (MR_ValidateMapInfo(instance, (instance->map_id + 1)))) {\n\t\t\t\tinstance->map_id++;\n\t\t\t\tfusion->fast_path_io = 1;\n\t\t\t} else {\n\t\t\t\tfusion->fast_path_io = 0;\n\t\t\t}\n\n\t\t\tif (instance->adapter_type >= INVADER_SERIES)\n\t\t\t\tmegasas_set_ld_removed_by_fw(instance);\n\n\t\t\tmegasas_sync_map_info(instance);\n\t\t\tspin_unlock_irqrestore(instance->host->host_lock,\n\t\t\t\t\t       flags);\n\n\t\t\tbreak;\n\t\t}\n\t\tif (opcode == MR_DCMD_CTRL_EVENT_GET_INFO ||\n\t\t    opcode == MR_DCMD_CTRL_EVENT_GET) {\n\t\t\tspin_lock_irqsave(&poll_aen_lock, flags);\n\t\t\tmegasas_poll_wait_aen = 0;\n\t\t\tspin_unlock_irqrestore(&poll_aen_lock, flags);\n\t\t}\n\n\t\t \n\t\tif ((opcode == MR_DCMD_SYSTEM_PD_MAP_GET_INFO) &&\n\t\t\t(cmd->frame->dcmd.mbox.b[0] == 1)) {\n\n\t\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\t\t\tstatus = cmd->frame->hdr.cmd_status;\n\t\t\tinstance->jbod_seq_cmd = NULL;\n\t\t\tmegasas_return_cmd(instance, cmd);\n\n\t\t\tif (status == MFI_STAT_OK) {\n\t\t\t\tinstance->pd_seq_map_id++;\n\t\t\t\t \n\t\t\t\tif (megasas_sync_pd_seq_num(instance, true))\n\t\t\t\t\tinstance->use_seqnum_jbod_fp = false;\n\t\t\t} else\n\t\t\t\tinstance->use_seqnum_jbod_fp = false;\n\n\t\t\tspin_unlock_irqrestore(instance->host->host_lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (opcode == MR_DCMD_CTRL_EVENT_WAIT)\n\t\t\tmegasas_service_aen(instance, cmd);\n\t\telse\n\t\t\tmegasas_complete_int_cmd(instance, cmd);\n\n\t\tbreak;\n\n\tcase MFI_CMD_ABORT:\n\t\t \n\t\tmegasas_complete_abort(instance, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_info(&instance->pdev->dev, \"Unknown command completed! [0x%X]\\n\",\n\t\t       hdr->cmd);\n\t\tmegasas_complete_int_cmd(instance, cmd);\n\t\tbreak;\n\t}\n}\n\n \nstatic inline void\nmegasas_issue_pending_cmds_again(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct list_head clist_local;\n\tunion megasas_evt_class_locale class_locale;\n\tunsigned long flags;\n\tu32 seq_num;\n\n\tINIT_LIST_HEAD(&clist_local);\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\tlist_splice_init(&instance->internal_reset_pending_q, &clist_local);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\n\twhile (!list_empty(&clist_local)) {\n\t\tcmd = list_entry((&clist_local)->next,\n\t\t\t\t\tstruct megasas_cmd, list);\n\t\tlist_del_init(&cmd->list);\n\n\t\tif (cmd->sync_cmd || cmd->scmd) {\n\t\t\tdev_notice(&instance->pdev->dev, \"command %p, %p:%d\"\n\t\t\t\t\"detected to be pending while HBA reset\\n\",\n\t\t\t\t\tcmd, cmd->scmd, cmd->sync_cmd);\n\n\t\t\tcmd->retry_for_fw_reset++;\n\n\t\t\tif (cmd->retry_for_fw_reset == 3) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"cmd %p, %p:%d\"\n\t\t\t\t\t\"was tried multiple times during reset.\"\n\t\t\t\t\t\"Shutting down the HBA\\n\",\n\t\t\t\t\tcmd, cmd->scmd, cmd->sync_cmd);\n\t\t\t\tinstance->instancet->disable_intr(instance);\n\t\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (cmd->sync_cmd == 1) {\n\t\t\tif (cmd->scmd) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"unexpected\"\n\t\t\t\t\t\"cmd attached to internal command!\\n\");\n\t\t\t}\n\t\t\tdev_notice(&instance->pdev->dev, \"%p synchronous cmd\"\n\t\t\t\t\t\t\"on the internal reset queue,\"\n\t\t\t\t\t\t\"issue it again.\\n\", cmd);\n\t\t\tcmd->cmd_status_drv = DCMD_INIT;\n\t\t\tinstance->instancet->fire_cmd(instance,\n\t\t\t\t\t\t\tcmd->frame_phys_addr,\n\t\t\t\t\t\t\t0, instance->reg_set);\n\t\t} else if (cmd->scmd) {\n\t\t\tdev_notice(&instance->pdev->dev, \"%p scsi cmd [%02x]\"\n\t\t\t\"detected on the internal queue, issue again.\\n\",\n\t\t\tcmd, cmd->scmd->cmnd[0]);\n\n\t\t\tatomic_inc(&instance->fw_outstanding);\n\t\t\tinstance->instancet->fire_cmd(instance,\n\t\t\t\t\tcmd->frame_phys_addr,\n\t\t\t\t\tcmd->frame_count-1, instance->reg_set);\n\t\t} else {\n\t\t\tdev_notice(&instance->pdev->dev, \"%p unexpected cmd on the\"\n\t\t\t\t\"internal reset defer list while re-issue!!\\n\",\n\t\t\t\tcmd);\n\t\t}\n\t}\n\n\tif (instance->aen_cmd) {\n\t\tdev_notice(&instance->pdev->dev, \"aen_cmd in def process\\n\");\n\t\tmegasas_return_cmd(instance, instance->aen_cmd);\n\n\t\tinstance->aen_cmd = NULL;\n\t}\n\n\t \n\tseq_num = instance->last_seq_num;\n\tclass_locale.members.reserved = 0;\n\tclass_locale.members.locale = MR_EVT_LOCALE_ALL;\n\tclass_locale.members.class = MR_EVT_CLASS_DEBUG;\n\n\tmegasas_register_aen(instance, seq_num, class_locale.word);\n}\n\n \nstatic void\nmegasas_internal_reset_defer_cmds(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tint i;\n\tu16 max_cmd = instance->max_fw_cmds;\n\tu32 defer_index;\n\tunsigned long flags;\n\n\tdefer_index = 0;\n\tspin_lock_irqsave(&instance->mfi_pool_lock, flags);\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tif (cmd->sync_cmd == 1 || cmd->scmd) {\n\t\t\tdev_notice(&instance->pdev->dev, \"moving cmd[%d]:%p:%d:%p\"\n\t\t\t\t\t\"on the defer queue as internal\\n\",\n\t\t\t\tdefer_index, cmd, cmd->sync_cmd, cmd->scmd);\n\n\t\t\tif (!list_empty(&cmd->list)) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"ERROR while\"\n\t\t\t\t\t\" moving this cmd:%p, %d %p, it was\"\n\t\t\t\t\t\"discovered on some list?\\n\",\n\t\t\t\t\tcmd, cmd->sync_cmd, cmd->scmd);\n\n\t\t\t\tlist_del_init(&cmd->list);\n\t\t\t}\n\t\t\tdefer_index++;\n\t\t\tlist_add_tail(&cmd->list,\n\t\t\t\t&instance->internal_reset_pending_q);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&instance->mfi_pool_lock, flags);\n}\n\n\nstatic void\nprocess_fw_state_change_wq(struct work_struct *work)\n{\n\tstruct megasas_instance *instance =\n\t\tcontainer_of(work, struct megasas_instance, work_init);\n\tu32 wait;\n\tunsigned long flags;\n\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_ADPRESET_SM_INFAULT) {\n\t\tdev_notice(&instance->pdev->dev, \"error, recovery st %x\\n\",\n\t\t\t   atomic_read(&instance->adprecovery));\n\t\treturn ;\n\t}\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_ADPRESET_SM_INFAULT) {\n\t\tdev_notice(&instance->pdev->dev, \"FW detected to be in fault\"\n\t\t\t\t\t\"state, restarting it...\\n\");\n\n\t\tinstance->instancet->disable_intr(instance);\n\t\tatomic_set(&instance->fw_outstanding, 0);\n\n\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\tinstance->instancet->adp_reset(instance, instance->reg_set);\n\t\tatomic_set(&instance->fw_reset_no_pci_access, 0);\n\n\t\tdev_notice(&instance->pdev->dev, \"FW restarted successfully,\"\n\t\t\t\t\t\"initiating next stage...\\n\");\n\n\t\tdev_notice(&instance->pdev->dev, \"HBA recovery state machine,\"\n\t\t\t\t\t\"state 2 starting...\\n\");\n\n\t\t \n\t\tfor (wait = 0; wait < 30; wait++) {\n\t\t\tmsleep(1000);\n\t\t}\n\n\t\tif (megasas_transition_to_ready(instance, 1)) {\n\t\t\tdev_notice(&instance->pdev->dev, \"adapter not ready\\n\");\n\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\treturn ;\n\t\t}\n\n\t\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||\n\t\t\t(instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||\n\t\t\t(instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR)\n\t\t\t) {\n\t\t\t*instance->consumer = *instance->producer;\n\t\t} else {\n\t\t\t*instance->consumer = 0;\n\t\t\t*instance->producer = 0;\n\t\t}\n\n\t\tmegasas_issue_init_mfi(instance);\n\n\t\tspin_lock_irqsave(&instance->hba_lock, flags);\n\t\tatomic_set(&instance->adprecovery, MEGASAS_HBA_OPERATIONAL);\n\t\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\t\tinstance->instancet->enable_intr(instance);\n\n\t\tmegasas_issue_pending_cmds_again(instance);\n\t\tinstance->issuepend_done = 1;\n\t}\n}\n\n \nstatic int\nmegasas_deplete_reply_queue(struct megasas_instance *instance,\n\t\t\t\t\tu8 alt_status)\n{\n\tu32 mfiStatus;\n\tu32 fw_state;\n\n\tif (instance->instancet->check_reset(instance, instance->reg_set) == 1)\n\t\treturn IRQ_HANDLED;\n\n\tmfiStatus = instance->instancet->clear_intr(instance);\n\tif (mfiStatus == 0) {\n\t\t \n\t\tif (!instance->msix_vectors)\n\t\t\treturn IRQ_NONE;\n\t}\n\n\tinstance->mfiStatus = mfiStatus;\n\n\tif ((mfiStatus & MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE)) {\n\t\tfw_state = instance->instancet->read_fw_status_reg(\n\t\t\t\tinstance) & MFI_STATE_MASK;\n\n\t\tif (fw_state != MFI_STATE_FAULT) {\n\t\t\tdev_notice(&instance->pdev->dev, \"fw state:%x\\n\",\n\t\t\t\t\t\tfw_state);\n\t\t}\n\n\t\tif ((fw_state == MFI_STATE_FAULT) &&\n\t\t\t\t(instance->disableOnlineCtrlReset == 0)) {\n\t\t\tdev_notice(&instance->pdev->dev, \"wait adp restart\\n\");\n\n\t\t\tif ((instance->pdev->device ==\n\t\t\t\t\tPCI_DEVICE_ID_LSI_SAS1064R) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t\tPCI_DEVICE_ID_DELL_PERC5) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t\tPCI_DEVICE_ID_LSI_VERDE_ZCR)) {\n\n\t\t\t\t*instance->consumer =\n\t\t\t\t\tcpu_to_le32(MEGASAS_ADPRESET_INPROG_SIGN);\n\t\t\t}\n\n\n\t\t\tinstance->instancet->disable_intr(instance);\n\t\t\tatomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_INFAULT);\n\t\t\tinstance->issuepend_done = 0;\n\n\t\t\tatomic_set(&instance->fw_outstanding, 0);\n\t\t\tmegasas_internal_reset_defer_cmds(instance);\n\n\t\t\tdev_notice(&instance->pdev->dev, \"fwState=%x, stage:%d\\n\",\n\t\t\t\t\tfw_state, atomic_read(&instance->adprecovery));\n\n\t\t\tschedule_work(&instance->work_init);\n\t\t\treturn IRQ_HANDLED;\n\n\t\t} else {\n\t\t\tdev_notice(&instance->pdev->dev, \"fwstate:%x, dis_OCR=%x\\n\",\n\t\t\t\tfw_state, instance->disableOnlineCtrlReset);\n\t\t}\n\t}\n\n\ttasklet_schedule(&instance->isr_tasklet);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t megasas_isr(int irq, void *devp)\n{\n\tstruct megasas_irq_context *irq_context = devp;\n\tstruct megasas_instance *instance = irq_context->instance;\n\tunsigned long flags;\n\tirqreturn_t rc;\n\n\tif (atomic_read(&instance->fw_reset_no_pci_access))\n\t\treturn IRQ_HANDLED;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\trc = megasas_deplete_reply_queue(instance, DID_OK);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\n\treturn rc;\n}\n\n \nint\nmegasas_transition_to_ready(struct megasas_instance *instance, int ocr)\n{\n\tint i;\n\tu8 max_wait;\n\tu32 fw_state;\n\tu32 abs_state, curr_abs_state;\n\n\tabs_state = instance->instancet->read_fw_status_reg(instance);\n\tfw_state = abs_state & MFI_STATE_MASK;\n\n\tif (fw_state != MFI_STATE_READY)\n\t\tdev_info(&instance->pdev->dev, \"Waiting for FW to come to ready\"\n\t\t       \" state\\n\");\n\n\twhile (fw_state != MFI_STATE_READY) {\n\n\t\tswitch (fw_state) {\n\n\t\tcase MFI_STATE_FAULT:\n\t\t\tdev_printk(KERN_ERR, &instance->pdev->dev,\n\t\t\t\t   \"FW in FAULT state, Fault code:0x%x subcode:0x%x func:%s\\n\",\n\t\t\t\t   abs_state & MFI_STATE_FAULT_CODE,\n\t\t\t\t   abs_state & MFI_STATE_FAULT_SUBCODE, __func__);\n\t\t\tif (ocr) {\n\t\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"System Register set:\\n\");\n\t\t\t\tmegasas_dump_reg_set(instance->reg_set);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\tcase MFI_STATE_WAIT_HANDSHAKE:\n\t\t\t \n\t\t\tif ((instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t PCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\n\t\t\t\t(instance->adapter_type != MFI_SERIES))\n\t\t\t\twritel(\n\t\t\t\t  MFI_INIT_CLEAR_HANDSHAKE|MFI_INIT_HOTPLUG,\n\t\t\t\t  &instance->reg_set->doorbell);\n\t\t\telse\n\t\t\t\twritel(\n\t\t\t\t    MFI_INIT_CLEAR_HANDSHAKE|MFI_INIT_HOTPLUG,\n\t\t\t\t\t&instance->reg_set->inbound_doorbell);\n\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_BOOT_MESSAGE_PENDING:\n\t\t\tif ((instance->pdev->device ==\n\t\t\t     PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t PCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\n\t\t\t\t(instance->adapter_type != MFI_SERIES))\n\t\t\t\twritel(MFI_INIT_HOTPLUG,\n\t\t\t\t       &instance->reg_set->doorbell);\n\t\t\telse\n\t\t\t\twritel(MFI_INIT_HOTPLUG,\n\t\t\t\t\t&instance->reg_set->inbound_doorbell);\n\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_OPERATIONAL:\n\t\t\t \n\t\t\tinstance->instancet->disable_intr(instance);\n\t\t\tif ((instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0071SKINNY)  ||\n\t\t\t\t(instance->adapter_type != MFI_SERIES)) {\n\t\t\t\twritel(MFI_RESET_FLAGS,\n\t\t\t\t\t&instance->reg_set->doorbell);\n\n\t\t\t\tif (instance->adapter_type != MFI_SERIES) {\n\t\t\t\t\tfor (i = 0; i < (10 * 1000); i += 20) {\n\t\t\t\t\t\tif (megasas_readl(\n\t\t\t\t\t\t\t    instance,\n\t\t\t\t\t\t\t    &instance->\n\t\t\t\t\t\t\t    reg_set->\n\t\t\t\t\t\t\t    doorbell) & 1)\n\t\t\t\t\t\t\tmsleep(20);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\twritel(MFI_RESET_FLAGS,\n\t\t\t\t\t&instance->reg_set->inbound_doorbell);\n\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_UNDEFINED:\n\t\t\t \n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_BB_INIT:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_FW_INIT:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_FW_INIT_2:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_DEVICE_SCAN:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_FLUSH_CACHE:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Unknown state 0x%x\\n\",\n\t\t\t       fw_state);\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"System Register set:\\n\");\n\t\t\tmegasas_dump_reg_set(instance->reg_set);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < max_wait * 50; i++) {\n\t\t\tcurr_abs_state = instance->instancet->\n\t\t\t\tread_fw_status_reg(instance);\n\n\t\t\tif (abs_state == curr_abs_state) {\n\t\t\t\tmsleep(20);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (curr_abs_state == abs_state) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"FW state [%d] hasn't changed \"\n\t\t\t       \"in %d secs\\n\", fw_state, max_wait);\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"System Register set:\\n\");\n\t\t\tmegasas_dump_reg_set(instance->reg_set);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tabs_state = curr_abs_state;\n\t\tfw_state = curr_abs_state & MFI_STATE_MASK;\n\t}\n\tdev_info(&instance->pdev->dev, \"FW now in Ready state\\n\");\n\n\treturn 0;\n}\n\n \nstatic void megasas_teardown_frame_pool(struct megasas_instance *instance)\n{\n\tint i;\n\tu16 max_cmd = instance->max_mfi_cmds;\n\tstruct megasas_cmd *cmd;\n\n\tif (!instance->frame_dma_pool)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < max_cmd; i++) {\n\n\t\tcmd = instance->cmd_list[i];\n\n\t\tif (cmd->frame)\n\t\t\tdma_pool_free(instance->frame_dma_pool, cmd->frame,\n\t\t\t\t      cmd->frame_phys_addr);\n\n\t\tif (cmd->sense)\n\t\t\tdma_pool_free(instance->sense_dma_pool, cmd->sense,\n\t\t\t\t      cmd->sense_phys_addr);\n\t}\n\n\t \n\tdma_pool_destroy(instance->frame_dma_pool);\n\tdma_pool_destroy(instance->sense_dma_pool);\n\n\tinstance->frame_dma_pool = NULL;\n\tinstance->sense_dma_pool = NULL;\n}\n\n \nstatic int megasas_create_frame_pool(struct megasas_instance *instance)\n{\n\tint i;\n\tu16 max_cmd;\n\tu32 frame_count;\n\tstruct megasas_cmd *cmd;\n\n\tmax_cmd = instance->max_mfi_cmds;\n\n\t \n\tframe_count = (instance->adapter_type == MFI_SERIES) ?\n\t\t\t(15 + 1) : (3 + 1);\n\tinstance->mfi_frame_size = MEGAMFI_FRAME_SIZE * frame_count;\n\t \n\tinstance->frame_dma_pool = dma_pool_create(\"megasas frame pool\",\n\t\t\t\t\t&instance->pdev->dev,\n\t\t\t\t\tinstance->mfi_frame_size, 256, 0);\n\n\tif (!instance->frame_dma_pool) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"failed to setup frame pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->sense_dma_pool = dma_pool_create(\"megasas sense pool\",\n\t\t\t\t\t\t   &instance->pdev->dev, 128,\n\t\t\t\t\t\t   4, 0);\n\n\tif (!instance->sense_dma_pool) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"failed to setup sense pool\\n\");\n\n\t\tdma_pool_destroy(instance->frame_dma_pool);\n\t\tinstance->frame_dma_pool = NULL;\n\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i < max_cmd; i++) {\n\n\t\tcmd = instance->cmd_list[i];\n\n\t\tcmd->frame = dma_pool_zalloc(instance->frame_dma_pool,\n\t\t\t\t\t    GFP_KERNEL, &cmd->frame_phys_addr);\n\n\t\tcmd->sense = dma_pool_alloc(instance->sense_dma_pool,\n\t\t\t\t\t    GFP_KERNEL, &cmd->sense_phys_addr);\n\n\t\t \n\t\tif (!cmd->frame || !cmd->sense) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"dma_pool_alloc failed\\n\");\n\t\t\tmegasas_teardown_frame_pool(instance);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcmd->frame->io.context = cpu_to_le32(cmd->index);\n\t\tcmd->frame->io.pad_0 = 0;\n\t\tif ((instance->adapter_type == MFI_SERIES) && reset_devices)\n\t\t\tcmd->frame->hdr.cmd = MFI_CMD_INVALID;\n\t}\n\n\treturn 0;\n}\n\n \nvoid megasas_free_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\n\t \n\tmegasas_teardown_frame_pool(instance);\n\n\t \n\tfor (i = 0; i < instance->max_mfi_cmds; i++)\n\n\t\tkfree(instance->cmd_list[i]);\n\n\t \n\tkfree(instance->cmd_list);\n\tinstance->cmd_list = NULL;\n\n\tINIT_LIST_HEAD(&instance->cmd_pool);\n}\n\n \nint megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\n\tmax_cmd = instance->max_mfi_cmds;\n\n\t \n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!instance->cmd_list[i]) {\n\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n\n\t \n\tif (megasas_create_frame_pool(instance)) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n\t\tmegasas_free_cmds(instance);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \ninline int\ndcmd_timeout_ocr_possible(struct megasas_instance *instance) {\n\n\tif (instance->adapter_type == MFI_SERIES)\n\t\treturn KILL_ADAPTER;\n\telse if (instance->unload ||\n\t\t\ttest_bit(MEGASAS_FUSION_OCR_NOT_POSSIBLE,\n\t\t\t\t &instance->reset_flags))\n\t\treturn IGNORE_TIMEOUT;\n\telse\n\t\treturn INITIATE_OCR;\n}\n\nstatic void\nmegasas_get_pd_info(struct megasas_instance *instance, struct scsi_device *sdev)\n{\n\tint ret;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\tu16 device_id = 0;\n\n\tdevice_id = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) + sdev->id;\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_err(&instance->pdev->dev, \"Failed to get cmd %s\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(instance->pd_info, 0, sizeof(*instance->pd_info));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.s[0] = cpu_to_le16(device_id);\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0xFF;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_PD_INFO));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_PD_GET_INFO);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->pd_info_h,\n\t\t\t\t sizeof(struct MR_PD_INFO));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\tmr_device_priv_data = sdev->hostdata;\n\t\tle16_to_cpus((u16 *)&instance->pd_info->state.ddf.pdType);\n\t\tmr_device_priv_data->interface_type =\n\t\t\t\tinstance->pd_info->state.ddf.pdType.intf;\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn;\n}\n \nstatic int\nmegasas_get_pd_list(struct megasas_instance *instance)\n{\n\tint ret = 0, pd_index = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_PD_LIST *ci;\n\tstruct MR_PD_ADDRESS *pd_addr;\n\n\tif (instance->pd_list_not_supported) {\n\t\tdev_info(&instance->pdev->dev, \"MR_DCMD_PD_LIST_QUERY \"\n\t\t\"not supported by firmware\\n\");\n\t\treturn ret;\n\t}\n\n\tci = instance->pd_list_buf;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"(get_pd_list): Failed to get cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.b[0] = MR_PD_QUERY_TYPE_EXPOSED_TO_HOST;\n\tdcmd->mbox.b[1] = 0;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_PD_LIST_QUERY);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->pd_list_buf_h,\n\t\t\t\t (MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST)));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\tMFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_FAILED:\n\t\tdev_info(&instance->pdev->dev, \"MR_DCMD_PD_LIST_QUERY \"\n\t\t\t\"failed/not supported by firmware\\n\");\n\n\t\tif (instance->adapter_type != MFI_SERIES)\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\telse\n\t\t\tinstance->pd_list_not_supported = 1;\n\t\tbreak;\n\tcase DCMD_TIMEOUT:\n\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\t \n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d \\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase DCMD_SUCCESS:\n\t\tpd_addr = ci->addr;\n\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\tdev_info(&instance->pdev->dev, \"%s, sysPD count: 0x%x\\n\",\n\t\t\t\t __func__, le32_to_cpu(ci->count));\n\n\t\tif ((le32_to_cpu(ci->count) >\n\t\t\t(MEGASAS_MAX_PD_CHANNELS * MEGASAS_MAX_DEV_PER_CHANNEL)))\n\t\t\tbreak;\n\n\t\tmemset(instance->local_pd_list, 0,\n\t\t\t\tMEGASAS_MAX_PD * sizeof(struct megasas_pd_list));\n\n\t\tfor (pd_index = 0; pd_index < le32_to_cpu(ci->count); pd_index++) {\n\t\t\tinstance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].tid\t=\n\t\t\t\t\tle16_to_cpu(pd_addr->deviceId);\n\t\t\tinstance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].driveType\t=\n\t\t\t\t\tpd_addr->scsiDevType;\n\t\t\tinstance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].driveState\t=\n\t\t\t\t\tMR_PD_STATE_SYSTEM;\n\t\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t \"PD%d: targetID: 0x%03x deviceType:0x%x\\n\",\n\t\t\t\t\t pd_index, le16_to_cpu(pd_addr->deviceId),\n\t\t\t\t\t pd_addr->scsiDevType);\n\t\t\tpd_addr++;\n\t\t}\n\n\t\tmemcpy(instance->pd_list, instance->local_pd_list,\n\t\t\tsizeof(instance->pd_list));\n\t\tbreak;\n\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n \nstatic int\nmegasas_get_ld_list(struct megasas_instance *instance)\n{\n\tint ret = 0, ld_index = 0, ids = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_LIST *ci;\n\tdma_addr_t ci_h = 0;\n\tu32 ld_count;\n\n\tci = instance->ld_list_buf;\n\tci_h = instance->ld_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_get_ld_list: Failed to get cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tif (instance->supportmax256vd)\n\t\tdcmd->mbox.b[0] = 1;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_LD_LIST));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_GET_LIST);\n\tdcmd->pad_0  = 0;\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct MR_LD_LIST));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\tMFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tld_count = le32_to_cpu(ci->ldCount);\n\n\tswitch (ret) {\n\tcase DCMD_FAILED:\n\t\tmegaraid_sas_kill_hba(instance);\n\t\tbreak;\n\tcase DCMD_TIMEOUT:\n\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\t \n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase DCMD_SUCCESS:\n\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\tdev_info(&instance->pdev->dev, \"%s, LD count: 0x%x\\n\",\n\t\t\t\t __func__, ld_count);\n\n\t\tif (ld_count > instance->fw_supported_vd_count)\n\t\t\tbreak;\n\n\t\tmemset(instance->ld_ids, 0xff, MAX_LOGICAL_DRIVES_EXT);\n\n\t\tfor (ld_index = 0; ld_index < ld_count; ld_index++) {\n\t\t\tif (ci->ldList[ld_index].state != 0) {\n\t\t\t\tids = ci->ldList[ld_index].ref.targetId;\n\t\t\t\tinstance->ld_ids[ids] = ci->ldList[ld_index].ref.targetId;\n\t\t\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t\t \"LD%d: targetID: 0x%03x\\n\",\n\t\t\t\t\t\t ld_index, ids);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n \nstatic int\nmegasas_ld_list_query(struct megasas_instance *instance, u8 query_type)\n{\n\tint ret = 0, ld_index = 0, ids = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_TARGETID_LIST *ci;\n\tdma_addr_t ci_h = 0;\n\tu32 tgtid_count;\n\n\tci = instance->ld_targetid_list_buf;\n\tci_h = instance->ld_targetid_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_warn(&instance->pdev->dev,\n\t\t         \"megasas_ld_list_query: Failed to get cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.b[0] = query_type;\n\tif (instance->supportmax256vd)\n\t\tdcmd->mbox.b[2] = 1;\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_LD_TARGETID_LIST));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_LIST_QUERY);\n\tdcmd->pad_0  = 0;\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct MR_LD_TARGETID_LIST));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_FAILED:\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t\"DCMD not supported by firmware - %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\tret = megasas_get_ld_list(instance);\n\t\tbreak;\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\t \n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase DCMD_SUCCESS:\n\t\ttgtid_count = le32_to_cpu(ci->count);\n\n\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\tdev_info(&instance->pdev->dev, \"%s, LD count: 0x%x\\n\",\n\t\t\t\t __func__, tgtid_count);\n\n\t\tif ((tgtid_count > (instance->fw_supported_vd_count)))\n\t\t\tbreak;\n\n\t\tmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\n\t\tfor (ld_index = 0; ld_index < tgtid_count; ld_index++) {\n\t\t\tids = ci->targetId[ld_index];\n\t\t\tinstance->ld_ids[ids] = ci->targetId[ld_index];\n\t\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\t\tdev_info(&instance->pdev->dev, \"LD%d: targetID: 0x%03x\\n\",\n\t\t\t\t\t ld_index, ci->targetId[ld_index]);\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n \nstatic int\nmegasas_host_device_list_query(struct megasas_instance *instance,\n\t\t\t       bool is_probe)\n{\n\tint ret, i, target_id;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_HOST_DEVICE_LIST *ci;\n\tu32 count;\n\tdma_addr_t ci_h;\n\n\tci = instance->host_device_list_buf;\n\tci_h = instance->host_device_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_warn(&instance->pdev->dev,\n\t\t\t \"%s: failed to get cmd\\n\",\n\t\t\t __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.b[0] = is_probe ? 0 : 1;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(HOST_DEVICE_LIST_SZ);\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_DEVICE_LIST_GET);\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h, HOST_DEVICE_LIST_SZ);\n\n\tif (!instance->mask_interrupts) {\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_SECS);\n\t} else {\n\t\tret = megasas_issue_polled(instance, cmd);\n\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t}\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\t \n\t\tcount = le32_to_cpu(ci->count);\n\n\t\tif (count > (MEGASAS_MAX_PD + MAX_LOGICAL_DRIVES_EXT))\n\t\t\tbreak;\n\n\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\tdev_info(&instance->pdev->dev, \"%s, Device count: 0x%x\\n\",\n\t\t\t\t __func__, count);\n\n\t\tmemset(instance->local_pd_list, 0,\n\t\t       MEGASAS_MAX_PD * sizeof(struct megasas_pd_list));\n\t\tmemset(instance->ld_ids, 0xff, MAX_LOGICAL_DRIVES_EXT);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\ttarget_id = le16_to_cpu(ci->host_device_list[i].target_id);\n\t\t\tif (ci->host_device_list[i].flags.u.bits.is_sys_pd) {\n\t\t\t\tinstance->local_pd_list[target_id].tid = target_id;\n\t\t\t\tinstance->local_pd_list[target_id].driveType =\n\t\t\t\t\t\tci->host_device_list[i].scsi_type;\n\t\t\t\tinstance->local_pd_list[target_id].driveState =\n\t\t\t\t\t\tMR_PD_STATE_SYSTEM;\n\t\t\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t\t \"Device %d: PD targetID: 0x%03x deviceType:0x%x\\n\",\n\t\t\t\t\t\t i, target_id, ci->host_device_list[i].scsi_type);\n\t\t\t} else {\n\t\t\t\tinstance->ld_ids[target_id] = target_id;\n\t\t\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t\t \"Device %d: LD targetID: 0x%03x\\n\",\n\t\t\t\t\t\t i, target_id);\n\t\t\t}\n\t\t}\n\n\t\tmemcpy(instance->pd_list, instance->local_pd_list,\n\t\t       sizeof(instance->pd_list));\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t __func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DCMD_FAILED:\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"%s: MR_DCMD_CTRL_DEVICE_LIST_GET failed\\n\",\n\t\t\t__func__);\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n \nstatic void megasas_update_ext_vd_details(struct megasas_instance *instance)\n{\n\tstruct fusion_context *fusion;\n\tu32 ventura_map_sz = 0;\n\n\tfusion = instance->ctrl_context;\n\t \n\tif (!fusion)\n\t\treturn;\n\n\tinstance->supportmax256vd =\n\t\tinstance->ctrl_info_buf->adapterOperations3.supportMaxExtLDs;\n\t \n\tif (instance->ctrl_info_buf->max_lds > 64)\n\t\tinstance->supportmax256vd = 1;\n\n\tinstance->drv_supported_vd_count = MEGASAS_MAX_LD_CHANNELS\n\t\t\t\t\t* MEGASAS_MAX_DEV_PER_CHANNEL;\n\tinstance->drv_supported_pd_count = MEGASAS_MAX_PD_CHANNELS\n\t\t\t\t\t* MEGASAS_MAX_DEV_PER_CHANNEL;\n\tif (instance->supportmax256vd) {\n\t\tinstance->fw_supported_vd_count = MAX_LOGICAL_DRIVES_EXT;\n\t\tinstance->fw_supported_pd_count = MAX_PHYSICAL_DEVICES;\n\t} else {\n\t\tinstance->fw_supported_vd_count = MAX_LOGICAL_DRIVES;\n\t\tinstance->fw_supported_pd_count = MAX_PHYSICAL_DEVICES;\n\t}\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"FW provided supportMaxExtLDs: %d\\tmax_lds: %d\\n\",\n\t\tinstance->ctrl_info_buf->adapterOperations3.supportMaxExtLDs ? 1 : 0,\n\t\tinstance->ctrl_info_buf->max_lds);\n\n\tif (instance->max_raid_mapsize) {\n\t\tventura_map_sz = instance->max_raid_mapsize *\n\t\t\t\t\t\tMR_MIN_MAP_SIZE;  \n\t\tfusion->current_map_sz = ventura_map_sz;\n\t\tfusion->max_map_sz = ventura_map_sz;\n\t} else {\n\t\tfusion->old_map_sz =\n\t\t\tstruct_size_t(struct MR_FW_RAID_MAP, ldSpanMap,\n\t\t\t\t      instance->fw_supported_vd_count);\n\t\tfusion->new_map_sz =  sizeof(struct MR_FW_RAID_MAP_EXT);\n\n\t\tfusion->max_map_sz =\n\t\t\tmax(fusion->old_map_sz, fusion->new_map_sz);\n\n\t\tif (instance->supportmax256vd)\n\t\t\tfusion->current_map_sz = fusion->new_map_sz;\n\t\telse\n\t\t\tfusion->current_map_sz = fusion->old_map_sz;\n\t}\n\t \n\tfusion->drv_map_sz = sizeof(struct MR_DRV_RAID_MAP_ALL);\n}\n\n \nvoid megasas_get_snapdump_properties(struct megasas_instance *instance)\n{\n\tint ret = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_SNAPDUMP_PROPERTIES *ci;\n\tdma_addr_t ci_h = 0;\n\n\tci = instance->snapdump_prop;\n\tci_h = instance->snapdump_prop_h;\n\n\tif (!ci)\n\t\treturn;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_dbg(&instance->pdev->dev, \"Failed to get a free cmd\\n\");\n\t\treturn;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_SNAPDUMP_PROPERTIES));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_SNAPDUMP_GET_PROPERTIES);\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct MR_SNAPDUMP_PROPERTIES));\n\n\tif (!instance->mask_interrupts) {\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_SECS);\n\t} else {\n\t\tret = megasas_issue_polled(instance, cmd);\n\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t}\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\tinstance->snapdump_wait_time =\n\t\t\tmin_t(u8, ci->trigger_min_num_sec_before_ocr,\n\t\t\t\tMEGASAS_MAX_SNAP_DUMP_WAIT_TIME);\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n}\n\n \nint\nmegasas_get_ctrl_info(struct megasas_instance *instance)\n{\n\tint ret = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct megasas_ctrl_info *ci;\n\tdma_addr_t ci_h = 0;\n\n\tci = instance->ctrl_info_buf;\n\tci_h = instance->ctrl_info_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to get a free cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct megasas_ctrl_info));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_GET_INFO);\n\tdcmd->mbox.b[0] = 1;\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct megasas_ctrl_info));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts) {\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\t} else {\n\t\tret = megasas_issue_polled(instance, cmd);\n\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t}\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\t \n\t\tle32_to_cpus((u32 *)&ci->properties.OnOffProperties);\n\t\tle16_to_cpus((u16 *)&ci->properties.on_off_properties2);\n\t\tle32_to_cpus((u32 *)&ci->adapterOperations2);\n\t\tle32_to_cpus((u32 *)&ci->adapterOperations3);\n\t\tle16_to_cpus((u16 *)&ci->adapter_operations4);\n\t\tle32_to_cpus((u32 *)&ci->adapter_operations5);\n\n\t\t \n\t\tmegasas_update_ext_vd_details(instance);\n\t\tinstance->support_seqnum_jbod_fp =\n\t\t\tci->adapterOperations3.useSeqNumJbodFP;\n\t\tinstance->support_morethan256jbod =\n\t\t\tci->adapter_operations4.support_pd_map_target_id;\n\t\tinstance->support_nvme_passthru =\n\t\t\tci->adapter_operations4.support_nvme_passthru;\n\t\tinstance->support_pci_lane_margining =\n\t\t\tci->adapter_operations5.support_pci_lane_margining;\n\t\tinstance->task_abort_tmo = ci->TaskAbortTO;\n\t\tinstance->max_reset_tmo = ci->MaxResetTO;\n\n\t\t \n\t\tinstance->is_imr = (ci->memory_size ? 0 : 1);\n\n\t\tinstance->snapdump_wait_time =\n\t\t\t(ci->properties.on_off_properties2.enable_snap_dump ?\n\t\t\t MEGASAS_DEFAULT_SNAP_DUMP_WAIT_TIME : 0);\n\n\t\tinstance->enable_fw_dev_list =\n\t\t\tci->properties.on_off_properties2.enable_fw_dev_list;\n\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t\"controller type\\t: %s(%dMB)\\n\",\n\t\t\tinstance->is_imr ? \"iMR\" : \"MR\",\n\t\t\tle16_to_cpu(ci->memory_size));\n\n\t\tinstance->disableOnlineCtrlReset =\n\t\t\tci->properties.OnOffProperties.disableOnlineCtrlReset;\n\t\tinstance->secure_jbod_support =\n\t\t\tci->adapterOperations3.supportSecurityonJBOD;\n\t\tdev_info(&instance->pdev->dev, \"Online Controller Reset(OCR)\\t: %s\\n\",\n\t\t\tinstance->disableOnlineCtrlReset ? \"Disabled\" : \"Enabled\");\n\t\tdev_info(&instance->pdev->dev, \"Secure JBOD support\\t: %s\\n\",\n\t\t\tinstance->secure_jbod_support ? \"Yes\" : \"No\");\n\t\tdev_info(&instance->pdev->dev, \"NVMe passthru support\\t: %s\\n\",\n\t\t\t instance->support_nvme_passthru ? \"Yes\" : \"No\");\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"FW provided TM TaskAbort/Reset timeout\\t: %d secs/%d secs\\n\",\n\t\t\t instance->task_abort_tmo, instance->max_reset_tmo);\n\t\tdev_info(&instance->pdev->dev, \"JBOD sequence map support\\t: %s\\n\",\n\t\t\t instance->support_seqnum_jbod_fp ? \"Yes\" : \"No\");\n\t\tdev_info(&instance->pdev->dev, \"PCI Lane Margining support\\t: %s\\n\",\n\t\t\t instance->support_pci_lane_margining ? \"Yes\" : \"No\");\n\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DCMD_FAILED:\n\t\tmegaraid_sas_kill_hba(instance);\n\t\tbreak;\n\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n \nint megasas_set_crash_dump_params(struct megasas_instance *instance,\n\tu8 crash_buf_state)\n{\n\tint ret = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_err(&instance->pdev->dev, \"Failed to get a free cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\tdcmd->mbox.b[0] = crash_buf_state;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_NONE;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(CRASH_DMA_BUF_SIZE);\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_SET_CRASH_DUMP_PARAMS);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->crash_dump_h,\n\t\t\t\t CRASH_DMA_BUF_SIZE);\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tif (ret == DCMD_TIMEOUT) {\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n \nstatic int\nmegasas_issue_init_mfi(struct megasas_instance *instance)\n{\n\t__le32 context;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_init_frame *init_frame;\n\tstruct megasas_init_queue_info *initq_info;\n\tdma_addr_t init_frame_h;\n\tdma_addr_t initq_info_h;\n\n\t \n\tcmd = megasas_get_cmd(instance);\n\n\tinit_frame = (struct megasas_init_frame *)cmd->frame;\n\tinitq_info = (struct megasas_init_queue_info *)\n\t\t((unsigned long)init_frame + 64);\n\n\tinit_frame_h = cmd->frame_phys_addr;\n\tinitq_info_h = init_frame_h + 64;\n\n\tcontext = init_frame->context;\n\tmemset(init_frame, 0, MEGAMFI_FRAME_SIZE);\n\tmemset(initq_info, 0, sizeof(struct megasas_init_queue_info));\n\tinit_frame->context = context;\n\n\tinitq_info->reply_queue_entries = cpu_to_le32(instance->max_fw_cmds + 1);\n\tinitq_info->reply_queue_start_phys_addr_lo = cpu_to_le32(instance->reply_queue_h);\n\n\tinitq_info->producer_index_phys_addr_lo = cpu_to_le32(instance->producer_h);\n\tinitq_info->consumer_index_phys_addr_lo = cpu_to_le32(instance->consumer_h);\n\n\tinit_frame->cmd = MFI_CMD_INIT;\n\tinit_frame->cmd_status = MFI_STAT_INVALID_STATUS;\n\tinit_frame->queue_info_new_phys_addr_lo =\n\t\tcpu_to_le32(lower_32_bits(initq_info_h));\n\tinit_frame->queue_info_new_phys_addr_hi =\n\t\tcpu_to_le32(upper_32_bits(initq_info_h));\n\n\tinit_frame->data_xfer_len = cpu_to_le32(sizeof(struct megasas_init_queue_info));\n\n\t \n\tinstance->instancet->disable_intr(instance);\n\n\t \n\n\tif (megasas_issue_polled(instance, cmd)) {\n\t\tdev_err(&instance->pdev->dev, \"Failed to init firmware\\n\");\n\t\tmegasas_return_cmd(instance, cmd);\n\t\tgoto fail_fw_init;\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn 0;\n\nfail_fw_init:\n\treturn -EINVAL;\n}\n\nstatic u32\nmegasas_init_adapter_mfi(struct megasas_instance *instance)\n{\n\tu32 context_sz;\n\tu32 reply_q_sz;\n\n\t \n\tinstance->max_fw_cmds = instance->instancet->read_fw_status_reg(instance) & 0x00FFFF;\n\t \n\tinstance->max_fw_cmds = instance->max_fw_cmds-1;\n\tinstance->max_mfi_cmds = instance->max_fw_cmds;\n\tinstance->max_num_sge = (instance->instancet->read_fw_status_reg(instance) & 0xFF0000) >>\n\t\t\t\t\t0x10;\n\t \n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY)) {\n\t\tinstance->max_scsi_cmds = (instance->max_fw_cmds -\n\t\t\tMEGASAS_SKINNY_INT_CMDS);\n\t\tsema_init(&instance->ioctl_sem, MEGASAS_SKINNY_INT_CMDS);\n\t} else {\n\t\tinstance->max_scsi_cmds = (instance->max_fw_cmds -\n\t\t\tMEGASAS_INT_CMDS);\n\t\tsema_init(&instance->ioctl_sem, (MEGASAS_MFI_IOCTL_CMDS));\n\t}\n\n\tinstance->cur_can_queue = instance->max_scsi_cmds;\n\t \n\tif (megasas_alloc_cmds(instance))\n\t\tgoto fail_alloc_cmds;\n\n\t \n\tcontext_sz = sizeof(u32);\n\treply_q_sz = context_sz * (instance->max_fw_cmds + 1);\n\n\tinstance->reply_queue = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\treply_q_sz, &instance->reply_queue_h, GFP_KERNEL);\n\n\tif (!instance->reply_queue) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Out of DMA mem for reply queue\\n\");\n\t\tgoto fail_reply_queue;\n\t}\n\n\tif (megasas_issue_init_mfi(instance))\n\t\tgoto fail_fw_init;\n\n\tif (megasas_get_ctrl_info(instance)) {\n\t\tdev_err(&instance->pdev->dev, \"(%d): Could get controller info \"\n\t\t\t\"Fail from %s %d\\n\", instance->unique_id,\n\t\t\t__func__, __LINE__);\n\t\tgoto fail_fw_init;\n\t}\n\n\tinstance->fw_support_ieee = 0;\n\tinstance->fw_support_ieee =\n\t\t(instance->instancet->read_fw_status_reg(instance) &\n\t\t0x04000000);\n\n\tdev_notice(&instance->pdev->dev, \"megasas_init_mfi: fw_support_ieee=%d\",\n\t\t\tinstance->fw_support_ieee);\n\n\tif (instance->fw_support_ieee)\n\t\tinstance->flag_ieee = 1;\n\n\treturn 0;\n\nfail_fw_init:\n\n\tdma_free_coherent(&instance->pdev->dev, reply_q_sz,\n\t\t\t    instance->reply_queue, instance->reply_queue_h);\nfail_reply_queue:\n\tmegasas_free_cmds(instance);\n\nfail_alloc_cmds:\n\treturn 1;\n}\n\nstatic\nvoid megasas_setup_irq_poll(struct megasas_instance *instance)\n{\n\tstruct megasas_irq_context *irq_ctx;\n\tu32 count, i;\n\n\tcount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tirq_ctx = &instance->irq_context[i];\n\t\tirq_ctx->os_irq = pci_irq_vector(instance->pdev, i);\n\t\tirq_ctx->irq_poll_scheduled = false;\n\t\tirq_poll_init(&irq_ctx->irqpoll,\n\t\t\t      instance->threshold_reply_count,\n\t\t\t      megasas_irqpoll);\n\t}\n}\n\n \nstatic int\nmegasas_setup_irqs_ioapic(struct megasas_instance *instance)\n{\n\tstruct pci_dev *pdev;\n\n\tpdev = instance->pdev;\n\tinstance->irq_context[0].instance = instance;\n\tinstance->irq_context[0].MSIxIndex = 0;\n\tsnprintf(instance->irq_context->name, MEGASAS_MSIX_NAME_LEN, \"%s%u\",\n\t\t\"megasas\", instance->host->host_no);\n\tif (request_irq(pci_irq_vector(pdev, 0),\n\t\t\tinstance->instancet->service_isr, IRQF_SHARED,\n\t\t\tinstance->irq_context->name, &instance->irq_context[0])) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to register IRQ from %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\treturn -1;\n\t}\n\tinstance->perf_mode = MR_LATENCY_PERF_MODE;\n\tinstance->low_latency_index_start = 0;\n\treturn 0;\n}\n\n \nstatic int\nmegasas_setup_irqs_msix(struct megasas_instance *instance, u8 is_probe)\n{\n\tint i, j;\n\tstruct pci_dev *pdev;\n\n\tpdev = instance->pdev;\n\n\t \n\tfor (i = 0; i < instance->msix_vectors; i++) {\n\t\tinstance->irq_context[i].instance = instance;\n\t\tinstance->irq_context[i].MSIxIndex = i;\n\t\tsnprintf(instance->irq_context[i].name, MEGASAS_MSIX_NAME_LEN, \"%s%u-msix%u\",\n\t\t\t\"megasas\", instance->host->host_no, i);\n\t\tif (request_irq(pci_irq_vector(pdev, i),\n\t\t\tinstance->instancet->service_isr, 0, instance->irq_context[i].name,\n\t\t\t&instance->irq_context[i])) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to register IRQ for vector %d.\\n\", i);\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tif (j < instance->low_latency_index_start)\n\t\t\t\t\tirq_update_affinity_hint(\n\t\t\t\t\t\tpci_irq_vector(pdev, j), NULL);\n\t\t\t\tfree_irq(pci_irq_vector(pdev, j),\n\t\t\t\t\t &instance->irq_context[j]);\n\t\t\t}\n\t\t\t \n\t\t\tinstance->msix_vectors = 0;\n\t\t\tinstance->msix_load_balance = false;\n\t\t\tif (is_probe) {\n\t\t\t\tpci_free_irq_vectors(instance->pdev);\n\t\t\t\treturn megasas_setup_irqs_ioapic(instance);\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nmegasas_destroy_irqs(struct megasas_instance *instance) {\n\n\tint i;\n\tint count;\n\tstruct megasas_irq_context *irq_ctx;\n\n\tcount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\n\tif (instance->adapter_type != MFI_SERIES) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tirq_ctx = &instance->irq_context[i];\n\t\t\tirq_poll_disable(&irq_ctx->irqpoll);\n\t\t}\n\t}\n\n\tif (instance->msix_vectors)\n\t\tfor (i = 0; i < instance->msix_vectors; i++) {\n\t\t\tif (i < instance->low_latency_index_start)\n\t\t\t\tirq_update_affinity_hint(\n\t\t\t\t    pci_irq_vector(instance->pdev, i), NULL);\n\t\t\tfree_irq(pci_irq_vector(instance->pdev, i),\n\t\t\t\t &instance->irq_context[i]);\n\t\t}\n\telse\n\t\tfree_irq(pci_irq_vector(instance->pdev, 0),\n\t\t\t &instance->irq_context[0]);\n}\n\n \nvoid\nmegasas_setup_jbod_map(struct megasas_instance *instance)\n{\n\tint i;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tsize_t pd_seq_map_sz;\n\n\tpd_seq_map_sz = struct_size_t(struct MR_PD_CFG_SEQ_NUM_SYNC, seq,\n\t\t\t\t      MAX_PHYSICAL_DEVICES);\n\n\tinstance->use_seqnum_jbod_fp =\n\t\tinstance->support_seqnum_jbod_fp;\n\tif (reset_devices || !fusion ||\n\t\t!instance->support_seqnum_jbod_fp) {\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t\"JBOD sequence map is disabled %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\tinstance->use_seqnum_jbod_fp = false;\n\t\treturn;\n\t}\n\n\tif (fusion->pd_seq_sync[0])\n\t\tgoto skip_alloc;\n\n\tfor (i = 0; i < JBOD_MAPS_COUNT; i++) {\n\t\tfusion->pd_seq_sync[i] = dma_alloc_coherent\n\t\t\t(&instance->pdev->dev, pd_seq_map_sz,\n\t\t\t&fusion->pd_seq_phys[i], GFP_KERNEL);\n\t\tif (!fusion->pd_seq_sync[i]) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate memory from %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tif (i == 1) {\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tpd_seq_map_sz, fusion->pd_seq_sync[0],\n\t\t\t\t\tfusion->pd_seq_phys[0]);\n\t\t\t\tfusion->pd_seq_sync[0] = NULL;\n\t\t\t}\n\t\t\tinstance->use_seqnum_jbod_fp = false;\n\t\t\treturn;\n\t\t}\n\t}\n\nskip_alloc:\n\tif (!megasas_sync_pd_seq_num(instance, false) &&\n\t\t!megasas_sync_pd_seq_num(instance, true))\n\t\tinstance->use_seqnum_jbod_fp = true;\n\telse\n\t\tinstance->use_seqnum_jbod_fp = false;\n}\n\nstatic void megasas_setup_reply_map(struct megasas_instance *instance)\n{\n\tconst struct cpumask *mask;\n\tunsigned int queue, cpu, low_latency_index_start;\n\n\tlow_latency_index_start = instance->low_latency_index_start;\n\n\tfor (queue = low_latency_index_start; queue < instance->msix_vectors; queue++) {\n\t\tmask = pci_irq_get_affinity(instance->pdev, queue);\n\t\tif (!mask)\n\t\t\tgoto fallback;\n\n\t\tfor_each_cpu(cpu, mask)\n\t\t\tinstance->reply_map[cpu] = queue;\n\t}\n\treturn;\n\nfallback:\n\tqueue = low_latency_index_start;\n\tfor_each_possible_cpu(cpu) {\n\t\tinstance->reply_map[cpu] = queue;\n\t\tif (queue == (instance->msix_vectors - 1))\n\t\t\tqueue = low_latency_index_start;\n\t\telse\n\t\t\tqueue++;\n\t}\n}\n\n \nstatic\nint megasas_get_device_list(struct megasas_instance *instance)\n{\n\tif (instance->enable_fw_dev_list) {\n\t\tif (megasas_host_device_list_query(instance, true))\n\t\t\treturn FAILED;\n\t} else {\n\t\tif (megasas_get_pd_list(instance) < 0) {\n\t\t\tdev_err(&instance->pdev->dev, \"failed to get PD list\\n\");\n\t\t\treturn FAILED;\n\t\t}\n\n\t\tif (megasas_ld_list_query(instance,\n\t\t\t\t\t  MR_LD_QUERY_TYPE_EXPOSED_TO_HOST)) {\n\t\t\tdev_err(&instance->pdev->dev, \"failed to get LD list\\n\");\n\t\t\treturn FAILED;\n\t\t}\n\t}\n\n\treturn SUCCESS;\n}\n\n \nstatic inline void\nmegasas_set_high_iops_queue_affinity_and_hint(struct megasas_instance *instance)\n{\n\tint i;\n\tunsigned int irq;\n\tconst struct cpumask *mask;\n\n\tif (instance->perf_mode == MR_BALANCED_PERF_MODE) {\n\t\tmask = cpumask_of_node(dev_to_node(&instance->pdev->dev));\n\n\t\tfor (i = 0; i < instance->low_latency_index_start; i++) {\n\t\t\tirq = pci_irq_vector(instance->pdev, i);\n\t\t\tirq_set_affinity_and_hint(irq, mask);\n\t\t}\n\t}\n}\n\nstatic int\n__megasas_alloc_irq_vectors(struct megasas_instance *instance)\n{\n\tint i, irq_flags;\n\tstruct irq_affinity desc = { .pre_vectors = instance->low_latency_index_start };\n\tstruct irq_affinity *descp = &desc;\n\n\tirq_flags = PCI_IRQ_MSIX;\n\n\tif (instance->smp_affinity_enable)\n\t\tirq_flags |= PCI_IRQ_AFFINITY | PCI_IRQ_ALL_TYPES;\n\telse\n\t\tdescp = NULL;\n\n\t \n\ti = pci_alloc_irq_vectors_affinity(instance->pdev,\n\t\tinstance->low_latency_index_start,\n\t\tinstance->msix_vectors - instance->iopoll_q_count, irq_flags, descp);\n\n\treturn i;\n}\n\n \nstatic void\nmegasas_alloc_irq_vectors(struct megasas_instance *instance)\n{\n\tint i;\n\tunsigned int num_msix_req;\n\n\tinstance->iopoll_q_count = 0;\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t\tpoll_queues) {\n\n\t\tinstance->perf_mode = MR_LATENCY_PERF_MODE;\n\t\tinstance->low_latency_index_start = 1;\n\n\t\t \n\t\tif (instance->msix_vectors > (poll_queues + 2))\n\t\t\tinstance->iopoll_q_count = poll_queues;\n\t\telse\n\t\t\tinstance->iopoll_q_count = 0;\n\n\t\tnum_msix_req = num_online_cpus() + instance->low_latency_index_start;\n\t\tinstance->msix_vectors = min(num_msix_req,\n\t\t\t\tinstance->msix_vectors);\n\n\t}\n\n\ti = __megasas_alloc_irq_vectors(instance);\n\n\tif (((instance->perf_mode == MR_BALANCED_PERF_MODE)\n\t\t|| instance->iopoll_q_count) &&\n\t    (i != (instance->msix_vectors - instance->iopoll_q_count))) {\n\t\tif (instance->msix_vectors)\n\t\t\tpci_free_irq_vectors(instance->pdev);\n\t\t \n\t\tinstance->perf_mode = MR_LATENCY_PERF_MODE;\n\t\tinstance->low_latency_index_start = 1;\n\t\tnum_msix_req = num_online_cpus() + instance->low_latency_index_start;\n\n\t\tinstance->msix_vectors = min(num_msix_req,\n\t\t\t\tinstance->msix_vectors);\n\n\t\tinstance->iopoll_q_count = 0;\n\t\ti = __megasas_alloc_irq_vectors(instance);\n\n\t}\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"requested/available msix %d/%d poll_queue %d\\n\",\n\t\t\tinstance->msix_vectors - instance->iopoll_q_count,\n\t\t\ti, instance->iopoll_q_count);\n\n\tif (i > 0)\n\t\tinstance->msix_vectors = i;\n\telse\n\t\tinstance->msix_vectors = 0;\n\n\tif (instance->smp_affinity_enable)\n\t\tmegasas_set_high_iops_queue_affinity_and_hint(instance);\n}\n\n \n\nstatic int megasas_init_fw(struct megasas_instance *instance)\n{\n\tu32 max_sectors_1;\n\tu32 max_sectors_2, tmp_sectors, msix_enable;\n\tu32 scratch_pad_1, scratch_pad_2, scratch_pad_3, status_reg;\n\tresource_size_t base_addr;\n\tvoid *base_addr_phys;\n\tstruct megasas_ctrl_info *ctrl_info = NULL;\n\tunsigned long bar_list;\n\tint i, j, loop;\n\tstruct IOV_111 *iovPtr;\n\tstruct fusion_context *fusion;\n\tbool intr_coalescing;\n\tunsigned int num_msix_req;\n\tu16 lnksta, speed;\n\n\tfusion = instance->ctrl_context;\n\n\t \n\tbar_list = pci_select_bars(instance->pdev, IORESOURCE_MEM);\n\tinstance->bar = find_first_bit(&bar_list, BITS_PER_LONG);\n\tif (pci_request_selected_regions(instance->pdev, 1<<instance->bar,\n\t\t\t\t\t \"megasas: LSI\")) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"IO memory region busy!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tbase_addr = pci_resource_start(instance->pdev, instance->bar);\n\tinstance->reg_set = ioremap(base_addr, 8192);\n\n\tif (!instance->reg_set) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to map IO mem\\n\");\n\t\tgoto fail_ioremap;\n\t}\n\n\tbase_addr_phys = &base_addr;\n\tdev_printk(KERN_DEBUG, &instance->pdev->dev,\n\t\t   \"BAR:0x%lx  BAR's base_addr(phys):%pa  mapped virt_addr:0x%p\\n\",\n\t\t   instance->bar, base_addr_phys, instance->reg_set);\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tinstance->instancet = &megasas_instance_template_fusion;\n\telse {\n\t\tswitch (instance->pdev->device) {\n\t\tcase PCI_DEVICE_ID_LSI_SAS1078R:\n\t\tcase PCI_DEVICE_ID_LSI_SAS1078DE:\n\t\t\tinstance->instancet = &megasas_instance_template_ppc;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_SAS1078GEN2:\n\t\tcase PCI_DEVICE_ID_LSI_SAS0079GEN2:\n\t\t\tinstance->instancet = &megasas_instance_template_gen2;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_SAS0073SKINNY:\n\t\tcase PCI_DEVICE_ID_LSI_SAS0071SKINNY:\n\t\t\tinstance->instancet = &megasas_instance_template_skinny;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_SAS1064R:\n\t\tcase PCI_DEVICE_ID_DELL_PERC5:\n\t\tdefault:\n\t\t\tinstance->instancet = &megasas_instance_template_xscale;\n\t\t\tinstance->pd_list_not_supported = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (megasas_transition_to_ready(instance, 0)) {\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"Failed to transition controller to ready from %s!\\n\",\n\t\t\t __func__);\n\t\tif (instance->adapter_type != MFI_SERIES) {\n\t\t\tstatus_reg = instance->instancet->read_fw_status_reg(\n\t\t\t\t\tinstance);\n\t\t\tif (status_reg & MFI_RESET_ADAPTER) {\n\t\t\t\tif (megasas_adp_reset_wait_for_ready\n\t\t\t\t\t(instance, true, 0) == FAILED)\n\t\t\t\t\tgoto fail_ready_state;\n\t\t\t} else {\n\t\t\t\tgoto fail_ready_state;\n\t\t\t}\n\t\t} else {\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\t\tinstance->instancet->adp_reset\n\t\t\t\t(instance, instance->reg_set);\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 0);\n\n\t\t\t \n\t\t\tssleep(30);\n\n\t\t\tif (megasas_transition_to_ready(instance, 0))\n\t\t\t\tgoto fail_ready_state;\n\t\t}\n\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"FW restarted successfully from %s!\\n\",\n\t\t\t __func__);\n\t}\n\n\tmegasas_init_ctrl_params(instance);\n\n\tif (megasas_set_dma_mask(instance))\n\t\tgoto fail_ready_state;\n\n\tif (megasas_alloc_ctrl_mem(instance))\n\t\tgoto fail_alloc_dma_buf;\n\n\tif (megasas_alloc_ctrl_dma_buffers(instance))\n\t\tgoto fail_alloc_dma_buf;\n\n\tfusion = instance->ctrl_context;\n\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tscratch_pad_2 =\n\t\t\tmegasas_readl(instance,\n\t\t\t\t      &instance->reg_set->outbound_scratch_pad_2);\n\t\tinstance->max_raid_mapsize = ((scratch_pad_2 >>\n\t\t\tMR_MAX_RAID_MAP_SIZE_OFFSET_SHIFT) &\n\t\t\tMR_MAX_RAID_MAP_SIZE_MASK);\n\t}\n\n\tinstance->enable_sdev_max_qd = enable_sdev_max_qd;\n\n\tswitch (instance->adapter_type) {\n\tcase VENTURA_SERIES:\n\t\tfusion->pcie_bw_limitation = true;\n\t\tbreak;\n\tcase AERO_SERIES:\n\t\tfusion->r56_div_offload = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tmsix_enable = (instance->instancet->read_fw_status_reg(instance) &\n\t\t       0x4000000) >> 0x1a;\n\tif (msix_enable && !msix_disable) {\n\n\t\tscratch_pad_1 = megasas_readl\n\t\t\t(instance, &instance->reg_set->outbound_scratch_pad_1);\n\t\t \n\t\tif (fusion) {\n\t\t\tif (instance->adapter_type == THUNDERBOLT_SERIES) {\n\t\t\t\t \n\t\t\t\tinstance->msix_vectors = (scratch_pad_1\n\t\t\t\t\t& MR_MAX_REPLY_QUEUES_OFFSET) + 1;\n\t\t\t} else {\n\t\t\t\tinstance->msix_vectors = ((scratch_pad_1\n\t\t\t\t\t& MR_MAX_REPLY_QUEUES_EXT_OFFSET)\n\t\t\t\t\t>> MR_MAX_REPLY_QUEUES_EXT_OFFSET_SHIFT) + 1;\n\n\t\t\t\t \n\t\t\t\tswitch (instance->adapter_type) {\n\t\t\t\tcase INVADER_SERIES:\n\t\t\t\t\tif (instance->msix_vectors > 8)\n\t\t\t\t\t\tinstance->msix_combined = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase AERO_SERIES:\n\t\t\t\tcase VENTURA_SERIES:\n\t\t\t\t\tif (instance->msix_vectors > 16)\n\t\t\t\t\t\tinstance->msix_combined = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (rdpq_enable)\n\t\t\t\t\tinstance->is_rdpq = (scratch_pad_1 & MR_RDPQ_MODE_OFFSET) ?\n\t\t\t\t\t\t\t\t1 : 0;\n\n\t\t\t\tif (instance->adapter_type >= INVADER_SERIES &&\n\t\t\t\t    !instance->msix_combined) {\n\t\t\t\t\tinstance->msix_load_balance = true;\n\t\t\t\t\tinstance->smp_affinity_enable = false;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tfor (loop = 1; loop < MR_MAX_MSIX_REG_ARRAY; loop++) {\n\t\t\t\t\tinstance->reply_post_host_index_addr[loop] =\n\t\t\t\t\t\t(u32 __iomem *)\n\t\t\t\t\t\t((u8 __iomem *)instance->reg_set +\n\t\t\t\t\t\tMPI2_SUP_REPLY_POST_HOST_INDEX_OFFSET\n\t\t\t\t\t\t+ (loop * 0x10));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t \"firmware supports msix\\t: (%d)\",\n\t\t\t\t instance->msix_vectors);\n\t\t\tif (msix_vectors)\n\t\t\t\tinstance->msix_vectors = min(msix_vectors,\n\t\t\t\t\tinstance->msix_vectors);\n\t\t} else  \n\t\t\tinstance->msix_vectors = 1;\n\n\n\t\t \n\n\t\tintr_coalescing = (scratch_pad_1 & MR_INTR_COALESCING_SUPPORT_OFFSET) ?\n\t\t\t\t\t\t\t\ttrue : false;\n\t\tif (intr_coalescing &&\n\t\t\t(num_online_cpus() >= MR_HIGH_IOPS_QUEUE_COUNT) &&\n\t\t\t(instance->msix_vectors == MEGASAS_MAX_MSIX_QUEUES))\n\t\t\tinstance->perf_mode = MR_BALANCED_PERF_MODE;\n\t\telse\n\t\t\tinstance->perf_mode = MR_LATENCY_PERF_MODE;\n\n\n\t\tif (instance->adapter_type == AERO_SERIES) {\n\t\t\tpcie_capability_read_word(instance->pdev, PCI_EXP_LNKSTA, &lnksta);\n\t\t\tspeed = lnksta & PCI_EXP_LNKSTA_CLS;\n\n\t\t\t \n\t\t\tif (speed < 0x4) {\n\t\t\t\tinstance->perf_mode = MR_LATENCY_PERF_MODE;\n\t\t\t\tfusion->pcie_bw_limitation = true;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((perf_mode >= MR_BALANCED_PERF_MODE) &&\n\t\t\t\t(perf_mode <= MR_LATENCY_PERF_MODE))\n\t\t\t\tinstance->perf_mode = perf_mode;\n\t\t\t \n\t\t\tif (!intr_coalescing)\n\t\t\t\tinstance->perf_mode = MR_LATENCY_PERF_MODE;\n\n\t\t}\n\n\t\tif (instance->perf_mode == MR_BALANCED_PERF_MODE)\n\t\t\tinstance->low_latency_index_start =\n\t\t\t\tMR_HIGH_IOPS_QUEUE_COUNT;\n\t\telse\n\t\t\tinstance->low_latency_index_start = 1;\n\n\t\tnum_msix_req = num_online_cpus() + instance->low_latency_index_start;\n\n\t\tinstance->msix_vectors = min(num_msix_req,\n\t\t\t\tinstance->msix_vectors);\n\n\t\tmegasas_alloc_irq_vectors(instance);\n\t\tif (!instance->msix_vectors)\n\t\t\tinstance->msix_load_balance = false;\n\t}\n\t \n\tif (instance->msix_combined) {\n\t\tinstance->reply_post_host_index_addr[0] =\n\t\t\t\t(u32 *)((u8 *)instance->reg_set +\n\t\t\t\tMPI2_SUP_REPLY_POST_HOST_INDEX_OFFSET);\n\t} else {\n\t\tinstance->reply_post_host_index_addr[0] =\n\t\t\t(u32 *)((u8 *)instance->reg_set +\n\t\t\tMPI2_REPLY_POST_HOST_INDEX_OFFSET);\n\t}\n\n\tif (!instance->msix_vectors) {\n\t\ti = pci_alloc_irq_vectors(instance->pdev, 1, 1, PCI_IRQ_LEGACY);\n\t\tif (i < 0)\n\t\t\tgoto fail_init_adapter;\n\t}\n\n\tmegasas_setup_reply_map(instance);\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"current msix/online cpus\\t: (%d/%d)\\n\",\n\t\tinstance->msix_vectors, (unsigned int)num_online_cpus());\n\tdev_info(&instance->pdev->dev,\n\t\t\"RDPQ mode\\t: (%s)\\n\", instance->is_rdpq ? \"enabled\" : \"disabled\");\n\n\ttasklet_init(&instance->isr_tasklet, instance->instancet->tasklet,\n\t\t(unsigned long)instance);\n\n\t \n\tinstance->fw_supported_vd_count = MAX_LOGICAL_DRIVES;\n\tinstance->fw_supported_pd_count = MAX_PHYSICAL_DEVICES;\n\t \n\tif (instance->instancet->init_adapter(instance))\n\t\tgoto fail_init_adapter;\n\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tscratch_pad_3 =\n\t\t\tmegasas_readl(instance,\n\t\t\t\t      &instance->reg_set->outbound_scratch_pad_3);\n\t\tif ((scratch_pad_3 & MR_NVME_PAGE_SIZE_MASK) >=\n\t\t\tMR_DEFAULT_NVME_PAGE_SHIFT)\n\t\t\tinstance->nvme_page_size =\n\t\t\t\t(1 << (scratch_pad_3 & MR_NVME_PAGE_SIZE_MASK));\n\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"NVME page size\\t: (%d)\\n\", instance->nvme_page_size);\n\t}\n\n\tif (instance->msix_vectors ?\n\t\tmegasas_setup_irqs_msix(instance, 1) :\n\t\tmegasas_setup_irqs_ioapic(instance))\n\t\tgoto fail_init_adapter;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_setup_irq_poll(instance);\n\n\tinstance->instancet->enable_intr(instance);\n\n\tdev_info(&instance->pdev->dev, \"INIT adapter done\\n\");\n\n\tmegasas_setup_jbod_map(instance);\n\n\tif (megasas_get_device_list(instance) != SUCCESS) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"%s: megasas_get_device_list failed\\n\",\n\t\t\t__func__);\n\t\tgoto fail_get_ld_pd_list;\n\t}\n\n\t \n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tfusion->stream_detect_by_ld =\n\t\t\tkcalloc(MAX_LOGICAL_DRIVES_EXT,\n\t\t\t\tsizeof(struct LD_STREAM_DETECT *),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!fusion->stream_detect_by_ld) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"unable to allocate stream detection for pool of LDs\\n\");\n\t\t\tgoto fail_get_ld_pd_list;\n\t\t}\n\t\tfor (i = 0; i < MAX_LOGICAL_DRIVES_EXT; ++i) {\n\t\t\tfusion->stream_detect_by_ld[i] =\n\t\t\t\tkzalloc(sizeof(struct LD_STREAM_DETECT),\n\t\t\t\tGFP_KERNEL);\n\t\t\tif (!fusion->stream_detect_by_ld[i]) {\n\t\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\t\"unable to allocate stream detect by LD\\n \");\n\t\t\t\tfor (j = 0; j < i; ++j)\n\t\t\t\t\tkfree(fusion->stream_detect_by_ld[j]);\n\t\t\t\tkfree(fusion->stream_detect_by_ld);\n\t\t\t\tfusion->stream_detect_by_ld = NULL;\n\t\t\t\tgoto fail_get_ld_pd_list;\n\t\t\t}\n\t\t\tfusion->stream_detect_by_ld[i]->mru_bit_map\n\t\t\t\t= MR_STREAM_BITMAP;\n\t\t}\n\t}\n\n\t \n\ttmp_sectors = 0;\n\tctrl_info = instance->ctrl_info_buf;\n\n\tmax_sectors_1 = (1 << ctrl_info->stripe_sz_ops.min) *\n\t\tle16_to_cpu(ctrl_info->max_strips_per_io);\n\tmax_sectors_2 = le32_to_cpu(ctrl_info->max_request_size);\n\n\ttmp_sectors = min_t(u32, max_sectors_1, max_sectors_2);\n\n\tinstance->peerIsPresent = ctrl_info->cluster.peerIsPresent;\n\tinstance->passive = ctrl_info->cluster.passive;\n\tmemcpy(instance->clusterId, ctrl_info->clusterId, sizeof(instance->clusterId));\n\tinstance->UnevenSpanSupport =\n\t\tctrl_info->adapterOperations2.supportUnevenSpans;\n\tif (instance->UnevenSpanSupport) {\n\t\tstruct fusion_context *fusion = instance->ctrl_context;\n\t\tif (MR_ValidateMapInfo(instance, instance->map_id))\n\t\t\tfusion->fast_path_io = 1;\n\t\telse\n\t\t\tfusion->fast_path_io = 0;\n\n\t}\n\tif (ctrl_info->host_interface.SRIOV) {\n\t\tinstance->requestorId = ctrl_info->iov.requestorId;\n\t\tif (instance->pdev->device == PCI_DEVICE_ID_LSI_PLASMA) {\n\t\t\tif (!ctrl_info->adapterOperations2.activePassive)\n\t\t\t    instance->PlasmaFW111 = 1;\n\n\t\t\tdev_info(&instance->pdev->dev, \"SR-IOV: firmware type: %s\\n\",\n\t\t\t    instance->PlasmaFW111 ? \"1.11\" : \"new\");\n\n\t\t\tif (instance->PlasmaFW111) {\n\t\t\t    iovPtr = (struct IOV_111 *)\n\t\t\t\t((unsigned char *)ctrl_info + IOV_111_OFFSET);\n\t\t\t    instance->requestorId = iovPtr->requestorId;\n\t\t\t}\n\t\t}\n\t\tdev_info(&instance->pdev->dev, \"SRIOV: VF requestorId %d\\n\",\n\t\t\tinstance->requestorId);\n\t}\n\n\tinstance->crash_dump_fw_support =\n\t\tctrl_info->adapterOperations3.supportCrashDump;\n\tinstance->crash_dump_drv_support =\n\t\t(instance->crash_dump_fw_support &&\n\t\tinstance->crash_dump_buf);\n\tif (instance->crash_dump_drv_support)\n\t\tmegasas_set_crash_dump_params(instance,\n\t\t\tMR_CRASH_BUF_TURN_OFF);\n\n\telse {\n\t\tif (instance->crash_dump_buf)\n\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\tCRASH_DMA_BUF_SIZE,\n\t\t\t\tinstance->crash_dump_buf,\n\t\t\t\tinstance->crash_dump_h);\n\t\tinstance->crash_dump_buf = NULL;\n\t}\n\n\tif (instance->snapdump_wait_time) {\n\t\tmegasas_get_snapdump_properties(instance);\n\t\tdev_info(&instance->pdev->dev, \"Snap dump wait time\\t: %d\\n\",\n\t\t\t instance->snapdump_wait_time);\n\t}\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"pci id\\t\\t: (0x%04x)/(0x%04x)/(0x%04x)/(0x%04x)\\n\",\n\t\tle16_to_cpu(ctrl_info->pci.vendor_id),\n\t\tle16_to_cpu(ctrl_info->pci.device_id),\n\t\tle16_to_cpu(ctrl_info->pci.sub_vendor_id),\n\t\tle16_to_cpu(ctrl_info->pci.sub_device_id));\n\tdev_info(&instance->pdev->dev, \"unevenspan support\t: %s\\n\",\n\t\tinstance->UnevenSpanSupport ? \"yes\" : \"no\");\n\tdev_info(&instance->pdev->dev, \"firmware crash dump\t: %s\\n\",\n\t\tinstance->crash_dump_drv_support ? \"yes\" : \"no\");\n\tdev_info(&instance->pdev->dev, \"JBOD sequence map\t: %s\\n\",\n\t\tinstance->use_seqnum_jbod_fp ? \"enabled\" : \"disabled\");\n\n\tinstance->max_sectors_per_req = instance->max_num_sge *\n\t\t\t\t\t\tSGE_BUFFER_SIZE / 512;\n\tif (tmp_sectors && (instance->max_sectors_per_req > tmp_sectors))\n\t\tinstance->max_sectors_per_req = tmp_sectors;\n\n\t \n\tif (throttlequeuedepth &&\n\t\t\tthrottlequeuedepth <= instance->max_scsi_cmds)\n\t\tinstance->throttlequeuedepth = throttlequeuedepth;\n\telse\n\t\tinstance->throttlequeuedepth =\n\t\t\t\tMEGASAS_THROTTLE_QUEUE_DEPTH;\n\n\tif ((resetwaittime < 1) ||\n\t    (resetwaittime > MEGASAS_RESET_WAIT_TIME))\n\t\tresetwaittime = MEGASAS_RESET_WAIT_TIME;\n\n\tif ((scmd_timeout < 10) || (scmd_timeout > MEGASAS_DEFAULT_CMD_TIMEOUT))\n\t\tscmd_timeout = MEGASAS_DEFAULT_CMD_TIMEOUT;\n\n\t \n\tif (instance->requestorId) {\n\t\tif (!megasas_sriov_start_heartbeat(instance, 1)) {\n\t\t\tmegasas_start_timer(instance);\n\t\t} else {\n\t\t\tinstance->skip_heartbeat_timer_del = 1;\n\t\t\tgoto fail_get_ld_pd_list;\n\t\t}\n\t}\n\n\t \n\tif (instance->adapter_type != MFI_SERIES)\n\t\tif (megasas_fusion_start_watchdog(instance) != SUCCESS)\n\t\t\tgoto fail_start_watchdog;\n\n\treturn 0;\n\nfail_start_watchdog:\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\nfail_get_ld_pd_list:\n\tinstance->instancet->disable_intr(instance);\n\tmegasas_destroy_irqs(instance);\nfail_init_adapter:\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n\tinstance->msix_vectors = 0;\nfail_alloc_dma_buf:\n\tmegasas_free_ctrl_dma_buffers(instance);\n\tmegasas_free_ctrl_mem(instance);\nfail_ready_state:\n\tiounmap(instance->reg_set);\n\nfail_ioremap:\n\tpci_release_selected_regions(instance->pdev, 1<<instance->bar);\n\n\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t__func__, __LINE__);\n\treturn -EINVAL;\n}\n\n \nstatic void megasas_release_mfi(struct megasas_instance *instance)\n{\n\tu32 reply_q_sz = sizeof(u32) *(instance->max_mfi_cmds + 1);\n\n\tif (instance->reply_queue)\n\t\tdma_free_coherent(&instance->pdev->dev, reply_q_sz,\n\t\t\t    instance->reply_queue, instance->reply_queue_h);\n\n\tmegasas_free_cmds(instance);\n\n\tiounmap(instance->reg_set);\n\n\tpci_release_selected_regions(instance->pdev, 1<<instance->bar);\n}\n\n \nstatic int\nmegasas_get_seq_num(struct megasas_instance *instance,\n\t\t    struct megasas_evt_log_info *eli)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct megasas_evt_log_info *el_info;\n\tdma_addr_t el_info_h = 0;\n\tint ret;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\tel_info = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t     sizeof(struct megasas_evt_log_info),\n\t\t\t\t     &el_info_h, GFP_KERNEL);\n\tif (!el_info) {\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct megasas_evt_log_info));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_EVENT_GET_INFO);\n\n\tmegasas_set_dma_settings(instance, dcmd, el_info_h,\n\t\t\t\t sizeof(struct megasas_evt_log_info));\n\n\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\tif (ret != DCMD_SUCCESS) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\tgoto dcmd_failed;\n\t}\n\n\t \n\teli->newest_seq_num = el_info->newest_seq_num;\n\teli->oldest_seq_num = el_info->oldest_seq_num;\n\teli->clear_seq_num = el_info->clear_seq_num;\n\teli->shutdown_seq_num = el_info->shutdown_seq_num;\n\teli->boot_seq_num = el_info->boot_seq_num;\n\ndcmd_failed:\n\tdma_free_coherent(&instance->pdev->dev,\n\t\t\tsizeof(struct megasas_evt_log_info),\n\t\t\tel_info, el_info_h);\n\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n \nstatic int\nmegasas_register_aen(struct megasas_instance *instance, u32 seq_num,\n\t\t     u32 class_locale_word)\n{\n\tint ret_val;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tunion megasas_evt_class_locale curr_aen;\n\tunion megasas_evt_class_locale prev_aen;\n\n\t \n\n\tcurr_aen.word = class_locale_word;\n\n\tif (instance->aen_cmd) {\n\n\t\tprev_aen.word =\n\t\t\tle32_to_cpu(instance->aen_cmd->frame->dcmd.mbox.w[1]);\n\n\t\tif ((curr_aen.members.class < MFI_EVT_CLASS_DEBUG) ||\n\t\t    (curr_aen.members.class > MFI_EVT_CLASS_DEAD)) {\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t \"%s %d out of range class %d send by application\\n\",\n\t\t\t\t __func__, __LINE__, curr_aen.members.class);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif ((prev_aen.members.class <= curr_aen.members.class) &&\n\t\t    !((prev_aen.members.locale & curr_aen.members.locale) ^\n\t\t      curr_aen.members.locale)) {\n\t\t\t \n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcurr_aen.members.locale |= prev_aen.members.locale;\n\n\t\t\tif (prev_aen.members.class < curr_aen.members.class)\n\t\t\t\tcurr_aen.members.class = prev_aen.members.class;\n\n\t\t\tinstance->aen_cmd->abort_aen = 1;\n\t\t\tret_val = megasas_issue_blocked_abort_cmd(instance,\n\t\t\t\t\t\t\t\t  instance->\n\t\t\t\t\t\t\t\t  aen_cmd, 30);\n\n\t\t\tif (ret_val) {\n\t\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to abort \"\n\t\t\t\t       \"previous AEN command\\n\");\n\t\t\t\treturn ret_val;\n\t\t\t}\n\t\t}\n\t}\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(instance->evt_detail, 0, sizeof(struct megasas_evt_detail));\n\n\t \n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct megasas_evt_detail));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_EVENT_WAIT);\n\tdcmd->mbox.w[0] = cpu_to_le32(seq_num);\n\tinstance->last_seq_num = seq_num;\n\tdcmd->mbox.w[1] = cpu_to_le32(curr_aen.word);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->evt_detail_h,\n\t\t\t\t sizeof(struct megasas_evt_detail));\n\n\tif (instance->aen_cmd != NULL) {\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn 0;\n\t}\n\n\t \n\tinstance->aen_cmd = cmd;\n\n\t \n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\treturn 0;\n}\n\n \nint\nmegasas_get_target_prop(struct megasas_instance *instance,\n\t\t\tstruct scsi_device *sdev)\n{\n\tint ret;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tu16 targetId = ((sdev->channel % 2) * MEGASAS_MAX_DEV_PER_CHANNEL) +\n\t\t\tsdev->id;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to get cmd %s\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(instance->tgt_prop, 0, sizeof(*instance->tgt_prop));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\tdcmd->mbox.b[0] = MEGASAS_IS_LOGICAL(sdev);\n\n\tdcmd->mbox.s[1] = cpu_to_le16(targetId);\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0xFF;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len =\n\t\tcpu_to_le32(sizeof(struct MR_TARGET_PROPERTIES));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_DRV_GET_TARGET_PROP);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->tgt_prop_h,\n\t\t\t\t sizeof(struct MR_TARGET_PROPERTIES));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance,\n\t\t\t\t\t\tcmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t     MFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t __func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tmegasas_return_cmd(instance, cmd);\n\t}\n\tif (ret != DCMD_SUCCESS)\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return from %s %d return value %d\\n\",\n\t\t\t__func__, __LINE__, ret);\n\n\treturn ret;\n}\n\n \nstatic int megasas_start_aen(struct megasas_instance *instance)\n{\n\tstruct megasas_evt_log_info eli;\n\tunion megasas_evt_class_locale class_locale;\n\n\t \n\tmemset(&eli, 0, sizeof(eli));\n\n\tif (megasas_get_seq_num(instance, &eli))\n\t\treturn -1;\n\n\t \n\tclass_locale.members.reserved = 0;\n\tclass_locale.members.locale = MR_EVT_LOCALE_ALL;\n\tclass_locale.members.class = MR_EVT_CLASS_DEBUG;\n\n\treturn megasas_register_aen(instance,\n\t\t\tle32_to_cpu(eli.newest_seq_num) + 1,\n\t\t\tclass_locale.word);\n}\n\n \nstatic int megasas_io_attach(struct megasas_instance *instance)\n{\n\tstruct Scsi_Host *host = instance->host;\n\n\t \n\thost->unique_id = instance->unique_id;\n\thost->can_queue = instance->max_scsi_cmds;\n\thost->this_id = instance->init_id;\n\thost->sg_tablesize = instance->max_num_sge;\n\n\tif (instance->fw_support_ieee)\n\t\tinstance->max_sectors_per_req = MEGASAS_MAX_SECTORS_IEEE;\n\n\t \n\tif (max_sectors && max_sectors < instance->max_sectors_per_req)\n\t\tinstance->max_sectors_per_req = max_sectors;\n\telse {\n\t\tif (max_sectors) {\n\t\t\tif (((instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS1078GEN2) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0079GEN2)) &&\n\t\t\t\t(max_sectors <= MEGASAS_MAX_SECTORS)) {\n\t\t\t\tinstance->max_sectors_per_req = max_sectors;\n\t\t\t} else {\n\t\t\tdev_info(&instance->pdev->dev, \"max_sectors should be > 0\"\n\t\t\t\t\"and <= %d (or < 1MB for GEN2 controller)\\n\",\n\t\t\t\tinstance->max_sectors_per_req);\n\t\t\t}\n\t\t}\n\t}\n\n\thost->max_sectors = instance->max_sectors_per_req;\n\thost->cmd_per_lun = MEGASAS_DEFAULT_CMD_PER_LUN;\n\thost->max_channel = MEGASAS_MAX_CHANNELS - 1;\n\thost->max_id = MEGASAS_MAX_DEV_PER_CHANNEL;\n\thost->max_lun = MEGASAS_MAX_LUN;\n\thost->max_cmd_len = 16;\n\n\t \n\n\thost->host_tagset = 0;\n\thost->nr_hw_queues = 1;\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t\t(instance->msix_vectors > instance->low_latency_index_start) &&\n\t\thost_tagset_enable &&\n\t\tinstance->smp_affinity_enable) {\n\t\thost->host_tagset = 1;\n\t\thost->nr_hw_queues = instance->msix_vectors -\n\t\t\tinstance->low_latency_index_start + instance->iopoll_q_count;\n\t\tif (instance->iopoll_q_count)\n\t\t\thost->nr_maps = 3;\n\t} else {\n\t\tinstance->iopoll_q_count = 0;\n\t}\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"Max firmware commands: %d shared with default \"\n\t\t\"hw_queues = %d poll_queues %d\\n\", instance->max_fw_cmds,\n\t\thost->nr_hw_queues - instance->iopoll_q_count,\n\t\tinstance->iopoll_q_count);\n\t \n\tif (scsi_add_host(host, &instance->pdev->dev)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to add host from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmegasas_set_dma_mask(struct megasas_instance *instance)\n{\n\tu64 consistent_mask;\n\tstruct pci_dev *pdev;\n\tu32 scratch_pad_1;\n\n\tpdev = instance->pdev;\n\tconsistent_mask = (instance->adapter_type >= VENTURA_SERIES) ?\n\t\t\t\tDMA_BIT_MASK(63) : DMA_BIT_MASK(32);\n\n\tif (IS_DMA64) {\n\t\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(63)) &&\n\t\t    dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)))\n\t\t\tgoto fail_set_dma_mask;\n\n\t\tif ((*pdev->dev.dma_mask == DMA_BIT_MASK(63)) &&\n\t\t    (dma_set_coherent_mask(&pdev->dev, consistent_mask) &&\n\t\t     dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)))) {\n\t\t\t \n\t\t\tscratch_pad_1 = megasas_readl\n\t\t\t\t(instance, &instance->reg_set->outbound_scratch_pad_1);\n\n\t\t\tif (!(scratch_pad_1 & MR_CAN_HANDLE_64_BIT_DMA_OFFSET))\n\t\t\t\tgoto fail_set_dma_mask;\n\t\t\telse if (dma_set_mask_and_coherent(&pdev->dev,\n\t\t\t\t\t\t\t   DMA_BIT_MASK(63)))\n\t\t\t\tgoto fail_set_dma_mask;\n\t\t}\n\t} else if (dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)))\n\t\tgoto fail_set_dma_mask;\n\n\tif (pdev->dev.coherent_dma_mask == DMA_BIT_MASK(32))\n\t\tinstance->consistent_mask_64bit = false;\n\telse\n\t\tinstance->consistent_mask_64bit = true;\n\n\tdev_info(&pdev->dev, \"%s bit DMA mask and %s bit consistent mask\\n\",\n\t\t ((*pdev->dev.dma_mask == DMA_BIT_MASK(63)) ? \"63\" : \"32\"),\n\t\t (instance->consistent_mask_64bit ? \"63\" : \"32\"));\n\n\treturn 0;\n\nfail_set_dma_mask:\n\tdev_err(&pdev->dev, \"Failed to set DMA mask\\n\");\n\treturn -1;\n\n}\n\n \nstatic inline void megasas_set_adapter_type(struct megasas_instance *instance)\n{\n\tif ((instance->pdev->vendor == PCI_VENDOR_ID_DELL) &&\n\t    (instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5)) {\n\t\tinstance->adapter_type = MFI_SERIES;\n\t} else {\n\t\tswitch (instance->pdev->device) {\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E1:\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E2:\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E5:\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E6:\n\t\t\tinstance->adapter_type = AERO_SERIES;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_VENTURA:\n\t\tcase PCI_DEVICE_ID_LSI_CRUSADER:\n\t\tcase PCI_DEVICE_ID_LSI_HARPOON:\n\t\tcase PCI_DEVICE_ID_LSI_TOMCAT:\n\t\tcase PCI_DEVICE_ID_LSI_VENTURA_4PORT:\n\t\tcase PCI_DEVICE_ID_LSI_CRUSADER_4PORT:\n\t\t\tinstance->adapter_type = VENTURA_SERIES;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_FUSION:\n\t\tcase PCI_DEVICE_ID_LSI_PLASMA:\n\t\t\tinstance->adapter_type = THUNDERBOLT_SERIES;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_INVADER:\n\t\tcase PCI_DEVICE_ID_LSI_INTRUDER:\n\t\tcase PCI_DEVICE_ID_LSI_INTRUDER_24:\n\t\tcase PCI_DEVICE_ID_LSI_CUTLASS_52:\n\t\tcase PCI_DEVICE_ID_LSI_CUTLASS_53:\n\t\tcase PCI_DEVICE_ID_LSI_FURY:\n\t\t\tinstance->adapter_type = INVADER_SERIES;\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tinstance->adapter_type = MFI_SERIES;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic inline int megasas_alloc_mfi_ctrl_mem(struct megasas_instance *instance)\n{\n\tinstance->producer = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\tsizeof(u32), &instance->producer_h, GFP_KERNEL);\n\tinstance->consumer = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\tsizeof(u32), &instance->consumer_h, GFP_KERNEL);\n\n\tif (!instance->producer || !instance->consumer) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to allocate memory for producer, consumer\\n\");\n\t\treturn -1;\n\t}\n\n\t*instance->producer = 0;\n\t*instance->consumer = 0;\n\treturn 0;\n}\n\n \nstatic int megasas_alloc_ctrl_mem(struct megasas_instance *instance)\n{\n\tinstance->reply_map = kcalloc(nr_cpu_ids, sizeof(unsigned int),\n\t\t\t\t      GFP_KERNEL);\n\tif (!instance->reply_map)\n\t\treturn -ENOMEM;\n\n\tswitch (instance->adapter_type) {\n\tcase MFI_SERIES:\n\t\tif (megasas_alloc_mfi_ctrl_mem(instance))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase AERO_SERIES:\n\tcase VENTURA_SERIES:\n\tcase THUNDERBOLT_SERIES:\n\tcase INVADER_SERIES:\n\t\tif (megasas_alloc_fusion_context(instance))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline void megasas_free_ctrl_mem(struct megasas_instance *instance)\n{\n\tkfree(instance->reply_map);\n\tif (instance->adapter_type == MFI_SERIES) {\n\t\tif (instance->producer)\n\t\t\tdma_free_coherent(&instance->pdev->dev, sizeof(u32),\n\t\t\t\t\t    instance->producer,\n\t\t\t\t\t    instance->producer_h);\n\t\tif (instance->consumer)\n\t\t\tdma_free_coherent(&instance->pdev->dev, sizeof(u32),\n\t\t\t\t\t    instance->consumer,\n\t\t\t\t\t    instance->consumer_h);\n\t} else {\n\t\tmegasas_free_fusion_context(instance);\n\t}\n}\n\n \nstatic inline\nint megasas_alloc_ctrl_dma_buffers(struct megasas_instance *instance)\n{\n\tstruct pci_dev *pdev = instance->pdev;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\tinstance->evt_detail = dma_alloc_coherent(&pdev->dev,\n\t\t\tsizeof(struct megasas_evt_detail),\n\t\t\t&instance->evt_detail_h, GFP_KERNEL);\n\n\tif (!instance->evt_detail) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to allocate event detail buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (fusion) {\n\t\tfusion->ioc_init_request =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t   sizeof(struct MPI2_IOC_INIT_REQUEST),\n\t\t\t\t\t   &fusion->ioc_init_request_phys,\n\t\t\t\t\t   GFP_KERNEL);\n\n\t\tif (!fusion->ioc_init_request) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to allocate ioc init request\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tinstance->snapdump_prop = dma_alloc_coherent(&pdev->dev,\n\t\t\t\tsizeof(struct MR_SNAPDUMP_PROPERTIES),\n\t\t\t\t&instance->snapdump_prop_h, GFP_KERNEL);\n\n\t\tif (!instance->snapdump_prop)\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to allocate snapdump properties buffer\\n\");\n\n\t\tinstance->host_device_list_buf = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t\tHOST_DEVICE_LIST_SZ,\n\t\t\t\t\t\t\t&instance->host_device_list_buf_h,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!instance->host_device_list_buf) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to allocate targetid list buffer\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t}\n\n\tinstance->pd_list_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t     MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST),\n\t\t\t\t     &instance->pd_list_buf_h, GFP_KERNEL);\n\n\tif (!instance->pd_list_buf) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate PD list buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->ctrl_info_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t     sizeof(struct megasas_ctrl_info),\n\t\t\t\t     &instance->ctrl_info_buf_h, GFP_KERNEL);\n\n\tif (!instance->ctrl_info_buf) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to allocate controller info buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->ld_list_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t     sizeof(struct MR_LD_LIST),\n\t\t\t\t     &instance->ld_list_buf_h, GFP_KERNEL);\n\n\tif (!instance->ld_list_buf) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate LD list buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->ld_targetid_list_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\tsizeof(struct MR_LD_TARGETID_LIST),\n\t\t\t\t&instance->ld_targetid_list_buf_h, GFP_KERNEL);\n\n\tif (!instance->ld_targetid_list_buf) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to allocate LD targetid list buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!reset_devices) {\n\t\tinstance->system_info_buf =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_DRV_SYSTEM_INFO),\n\t\t\t\t\t&instance->system_info_h, GFP_KERNEL);\n\t\tinstance->pd_info =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_PD_INFO),\n\t\t\t\t\t&instance->pd_info_h, GFP_KERNEL);\n\t\tinstance->tgt_prop =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_TARGET_PROPERTIES),\n\t\t\t\t\t&instance->tgt_prop_h, GFP_KERNEL);\n\t\tinstance->crash_dump_buf =\n\t\t\tdma_alloc_coherent(&pdev->dev, CRASH_DMA_BUF_SIZE,\n\t\t\t\t\t&instance->crash_dump_h, GFP_KERNEL);\n\n\t\tif (!instance->system_info_buf)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate system info buffer\\n\");\n\n\t\tif (!instance->pd_info)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate pd_info buffer\\n\");\n\n\t\tif (!instance->tgt_prop)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate tgt_prop buffer\\n\");\n\n\t\tif (!instance->crash_dump_buf)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate crash dump buffer\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline\nvoid megasas_free_ctrl_dma_buffers(struct megasas_instance *instance)\n{\n\tstruct pci_dev *pdev = instance->pdev;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\tif (instance->evt_detail)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct megasas_evt_detail),\n\t\t\t\t    instance->evt_detail,\n\t\t\t\t    instance->evt_detail_h);\n\n\tif (fusion && fusion->ioc_init_request)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  sizeof(struct MPI2_IOC_INIT_REQUEST),\n\t\t\t\t  fusion->ioc_init_request,\n\t\t\t\t  fusion->ioc_init_request_phys);\n\n\tif (instance->pd_list_buf)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t    MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST),\n\t\t\t\t    instance->pd_list_buf,\n\t\t\t\t    instance->pd_list_buf_h);\n\n\tif (instance->ld_list_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_LD_LIST),\n\t\t\t\t    instance->ld_list_buf,\n\t\t\t\t    instance->ld_list_buf_h);\n\n\tif (instance->ld_targetid_list_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_LD_TARGETID_LIST),\n\t\t\t\t    instance->ld_targetid_list_buf,\n\t\t\t\t    instance->ld_targetid_list_buf_h);\n\n\tif (instance->ctrl_info_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct megasas_ctrl_info),\n\t\t\t\t    instance->ctrl_info_buf,\n\t\t\t\t    instance->ctrl_info_buf_h);\n\n\tif (instance->system_info_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_DRV_SYSTEM_INFO),\n\t\t\t\t    instance->system_info_buf,\n\t\t\t\t    instance->system_info_h);\n\n\tif (instance->pd_info)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_PD_INFO),\n\t\t\t\t    instance->pd_info, instance->pd_info_h);\n\n\tif (instance->tgt_prop)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_TARGET_PROPERTIES),\n\t\t\t\t    instance->tgt_prop, instance->tgt_prop_h);\n\n\tif (instance->crash_dump_buf)\n\t\tdma_free_coherent(&pdev->dev, CRASH_DMA_BUF_SIZE,\n\t\t\t\t    instance->crash_dump_buf,\n\t\t\t\t    instance->crash_dump_h);\n\n\tif (instance->snapdump_prop)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  sizeof(struct MR_SNAPDUMP_PROPERTIES),\n\t\t\t\t  instance->snapdump_prop,\n\t\t\t\t  instance->snapdump_prop_h);\n\n\tif (instance->host_device_list_buf)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  HOST_DEVICE_LIST_SZ,\n\t\t\t\t  instance->host_device_list_buf,\n\t\t\t\t  instance->host_device_list_buf_h);\n\n}\n\n \nstatic inline void megasas_init_ctrl_params(struct megasas_instance *instance)\n{\n\tinstance->fw_crash_state = UNAVAILABLE;\n\n\tmegasas_poll_wait_aen = 0;\n\tinstance->issuepend_done = 1;\n\tatomic_set(&instance->adprecovery, MEGASAS_HBA_OPERATIONAL);\n\n\t \n\tINIT_LIST_HEAD(&instance->cmd_pool);\n\tINIT_LIST_HEAD(&instance->internal_reset_pending_q);\n\n\tatomic_set(&instance->fw_outstanding, 0);\n\tatomic64_set(&instance->total_io_count, 0);\n\n\tinit_waitqueue_head(&instance->int_cmd_wait_q);\n\tinit_waitqueue_head(&instance->abort_cmd_wait_q);\n\n\tmutex_init(&instance->crashdump_lock);\n\tspin_lock_init(&instance->mfi_pool_lock);\n\tspin_lock_init(&instance->hba_lock);\n\tspin_lock_init(&instance->stream_lock);\n\tspin_lock_init(&instance->completion_lock);\n\n\tmutex_init(&instance->reset_mutex);\n\n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t    (instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY))\n\t\tinstance->flag_ieee = 1;\n\n\tinstance->flag = 0;\n\tinstance->unload = 1;\n\tinstance->last_time = 0;\n\tinstance->disableOnlineCtrlReset = 1;\n\tinstance->UnevenSpanSupport = 0;\n\tinstance->smp_affinity_enable = smp_affinity_enable ? true : false;\n\tinstance->msix_load_balance = false;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tINIT_WORK(&instance->work_init, megasas_fusion_ocr_wq);\n\telse\n\t\tINIT_WORK(&instance->work_init, process_fw_state_change_wq);\n}\n\n \nstatic int megasas_probe_one(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *id)\n{\n\tint rval, pos;\n\tstruct Scsi_Host *host;\n\tstruct megasas_instance *instance;\n\tu16 control = 0;\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_LSI_AERO_10E0:\n\tcase PCI_DEVICE_ID_LSI_AERO_10E3:\n\tcase PCI_DEVICE_ID_LSI_AERO_10E4:\n\tcase PCI_DEVICE_ID_LSI_AERO_10E7:\n\t\tdev_err(&pdev->dev, \"Adapter is in non secure mode\\n\");\n\t\treturn 1;\n\tcase PCI_DEVICE_ID_LSI_AERO_10E1:\n\tcase PCI_DEVICE_ID_LSI_AERO_10E5:\n\t\tdev_info(&pdev->dev, \"Adapter is in configurable secure mode\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tif (reset_devices) {\n\t\tpos = pci_find_capability(pdev, PCI_CAP_ID_MSIX);\n\t\tif (pos) {\n\t\t\tpci_read_config_word(pdev, pos + PCI_MSIX_FLAGS,\n\t\t\t\t\t     &control);\n\t\t\tif (control & PCI_MSIX_FLAGS_ENABLE) {\n\t\t\t\tdev_info(&pdev->dev, \"resetting MSI-X\\n\");\n\t\t\t\tpci_write_config_word(pdev,\n\t\t\t\t\t\t      pos + PCI_MSIX_FLAGS,\n\t\t\t\t\t\t      control &\n\t\t\t\t\t\t      ~PCI_MSIX_FLAGS_ENABLE);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\trval = pci_enable_device_mem(pdev);\n\n\tif (rval) {\n\t\treturn rval;\n\t}\n\n\tpci_set_master(pdev);\n\n\thost = scsi_host_alloc(&megasas_template,\n\t\t\t       sizeof(struct megasas_instance));\n\n\tif (!host) {\n\t\tdev_printk(KERN_DEBUG, &pdev->dev, \"scsi_host_alloc failed\\n\");\n\t\tgoto fail_alloc_instance;\n\t}\n\n\tinstance = (struct megasas_instance *)host->hostdata;\n\tmemset(instance, 0, sizeof(*instance));\n\tatomic_set(&instance->fw_reset_no_pci_access, 0);\n\n\t \n\tinstance->pdev = pdev;\n\tinstance->host = host;\n\tinstance->unique_id = pci_dev_id(pdev);\n\tinstance->init_id = MEGASAS_DEFAULT_INIT_ID;\n\n\tmegasas_set_adapter_type(instance);\n\n\t \n\tif (megasas_init_fw(instance))\n\t\tgoto fail_init_mfi;\n\n\tif (instance->requestorId) {\n\t\tif (instance->PlasmaFW111) {\n\t\t\tinstance->vf_affiliation_111 =\n\t\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t\t&instance->vf_affiliation_111_h,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!instance->vf_affiliation_111)\n\t\t\t\tdev_warn(&pdev->dev, \"Can't allocate \"\n\t\t\t\t       \"memory for VF affiliation buffer\\n\");\n\t\t} else {\n\t\t\tinstance->vf_affiliation =\n\t\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t(MAX_LOGICAL_DRIVES + 1) *\n\t\t\t\t\tsizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t\t&instance->vf_affiliation_h,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!instance->vf_affiliation)\n\t\t\t\tdev_warn(&pdev->dev, \"Can't allocate \"\n\t\t\t\t       \"memory for VF affiliation buffer\\n\");\n\t\t}\n\t}\n\n\t \n\tpci_set_drvdata(pdev, instance);\n\n\t \n\tmegasas_mgmt_info.count++;\n\tmegasas_mgmt_info.instance[megasas_mgmt_info.max_index] = instance;\n\tmegasas_mgmt_info.max_index++;\n\n\t \n\tif (megasas_io_attach(instance))\n\t\tgoto fail_io_attach;\n\n\tinstance->unload = 0;\n\t \n\tif (!instance->enable_fw_dev_list ||\n\t    (instance->host_device_list_buf->count > 0))\n\t\tscsi_scan_host(host);\n\n\t \n\tif (megasas_start_aen(instance)) {\n\t\tdev_printk(KERN_DEBUG, &pdev->dev, \"start aen failed\\n\");\n\t\tgoto fail_start_aen;\n\t}\n\n\tmegasas_setup_debugfs(instance);\n\n\t \n\tif (instance->requestorId)\n\t\tmegasas_get_ld_vf_affiliation(instance, 1);\n\n\treturn 0;\n\nfail_start_aen:\n\tinstance->unload = 1;\n\tscsi_remove_host(instance->host);\nfail_io_attach:\n\tmegasas_mgmt_info.count--;\n\tmegasas_mgmt_info.max_index--;\n\tmegasas_mgmt_info.instance[megasas_mgmt_info.max_index] = NULL;\n\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\n\n\tinstance->instancet->disable_intr(instance);\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_release_fusion(instance);\n\telse\n\t\tmegasas_release_mfi(instance);\n\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n\tinstance->msix_vectors = 0;\n\n\tif (instance->fw_crash_state != UNAVAILABLE)\n\t\tmegasas_free_host_crash_buffer(instance);\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_fusion_stop_watchdog(instance);\nfail_init_mfi:\n\tscsi_host_put(host);\nfail_alloc_instance:\n\tpci_disable_device(pdev);\n\n\treturn -ENODEV;\n}\n\n \nstatic void megasas_flush_cache(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)\n\t\treturn;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn;\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 0;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_NONE);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = 0;\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_CACHE_FLUSH);\n\tdcmd->mbox.b[0] = MR_FLUSH_CTRL_CACHE | MR_FLUSH_DISK_CACHE;\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS)\n\t\t\t!= DCMD_SUCCESS) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return from %s %d\\n\", __func__, __LINE__);\n\t\treturn;\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n}\n\n \nstatic void megasas_shutdown_controller(struct megasas_instance *instance,\n\t\t\t\t\tu32 opcode)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)\n\t\treturn;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn;\n\n\tif (instance->aen_cmd)\n\t\tmegasas_issue_blocked_abort_cmd(instance,\n\t\t\tinstance->aen_cmd, MFI_IO_TIMEOUT_SECS);\n\tif (instance->map_update_cmd)\n\t\tmegasas_issue_blocked_abort_cmd(instance,\n\t\t\tinstance->map_update_cmd, MFI_IO_TIMEOUT_SECS);\n\tif (instance->jbod_seq_cmd)\n\t\tmegasas_issue_blocked_abort_cmd(instance,\n\t\t\tinstance->jbod_seq_cmd, MFI_IO_TIMEOUT_SECS);\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 0;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_NONE);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = 0;\n\tdcmd->opcode = cpu_to_le32(opcode);\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS)\n\t\t\t!= DCMD_SUCCESS) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return from %s %d\\n\", __func__, __LINE__);\n\t\treturn;\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n}\n\n \nstatic int __maybe_unused\nmegasas_suspend(struct device *dev)\n{\n\tstruct megasas_instance *instance;\n\n\tinstance = dev_get_drvdata(dev);\n\n\tif (!instance)\n\t\treturn 0;\n\n\tinstance->unload = 1;\n\n\tdev_info(dev, \"%s is called\\n\", __func__);\n\n\t \n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\n\n\t \n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_fusion_stop_watchdog(instance);\n\n\tmegasas_flush_cache(instance);\n\tmegasas_shutdown_controller(instance, MR_DCMD_HIBERNATE_SHUTDOWN);\n\n\t \n\tif (instance->ev != NULL) {\n\t\tstruct megasas_aen_event *ev = instance->ev;\n\t\tcancel_delayed_work_sync(&ev->hotplug_work);\n\t\tinstance->ev = NULL;\n\t}\n\n\ttasklet_kill(&instance->isr_tasklet);\n\n\tpci_set_drvdata(instance->pdev, instance);\n\tinstance->instancet->disable_intr(instance);\n\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused\nmegasas_resume(struct device *dev)\n{\n\tint rval;\n\tstruct Scsi_Host *host;\n\tstruct megasas_instance *instance;\n\tu32 status_reg;\n\n\tinstance = dev_get_drvdata(dev);\n\n\tif (!instance)\n\t\treturn 0;\n\n\thost = instance->host;\n\n\tdev_info(dev, \"%s is called\\n\", __func__);\n\n\t \n\n\tif (megasas_transition_to_ready(instance, 0)) {\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"Failed to transition controller to ready from %s!\\n\",\n\t\t\t __func__);\n\t\tif (instance->adapter_type != MFI_SERIES) {\n\t\t\tstatus_reg =\n\t\t\t\tinstance->instancet->read_fw_status_reg(instance);\n\t\t\tif (!(status_reg & MFI_RESET_ADAPTER) ||\n\t\t\t\t((megasas_adp_reset_wait_for_ready\n\t\t\t\t(instance, true, 0)) == FAILED))\n\t\t\t\tgoto fail_ready_state;\n\t\t} else {\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\t\tinstance->instancet->adp_reset\n\t\t\t\t(instance, instance->reg_set);\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 0);\n\n\t\t\t \n\t\t\tssleep(30);\n\n\t\t\tif (megasas_transition_to_ready(instance, 0))\n\t\t\t\tgoto fail_ready_state;\n\t\t}\n\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"FW restarted successfully from %s!\\n\",\n\t\t\t __func__);\n\t}\n\tif (megasas_set_dma_mask(instance))\n\t\tgoto fail_set_dma_mask;\n\n\t \n\n\tatomic_set(&instance->fw_outstanding, 0);\n\tatomic_set(&instance->ldio_outstanding, 0);\n\n\t \n\tif (instance->msix_vectors)\n\t\tmegasas_alloc_irq_vectors(instance);\n\n\tif (!instance->msix_vectors) {\n\t\trval = pci_alloc_irq_vectors(instance->pdev, 1, 1,\n\t\t\t\t\t     PCI_IRQ_LEGACY);\n\t\tif (rval < 0)\n\t\t\tgoto fail_reenable_msix;\n\t}\n\n\tmegasas_setup_reply_map(instance);\n\n\tif (instance->adapter_type != MFI_SERIES) {\n\t\tmegasas_reset_reply_desc(instance);\n\t\tif (megasas_ioc_init_fusion(instance)) {\n\t\t\tmegasas_free_cmds(instance);\n\t\t\tmegasas_free_cmds_fusion(instance);\n\t\t\tgoto fail_init_mfi;\n\t\t}\n\t\tif (!megasas_get_map_info(instance))\n\t\t\tmegasas_sync_map_info(instance);\n\t} else {\n\t\t*instance->producer = 0;\n\t\t*instance->consumer = 0;\n\t\tif (megasas_issue_init_mfi(instance))\n\t\t\tgoto fail_init_mfi;\n\t}\n\n\tif (megasas_get_ctrl_info(instance) != DCMD_SUCCESS)\n\t\tgoto fail_init_mfi;\n\n\ttasklet_init(&instance->isr_tasklet, instance->instancet->tasklet,\n\t\t     (unsigned long)instance);\n\n\tif (instance->msix_vectors ?\n\t\t\tmegasas_setup_irqs_msix(instance, 0) :\n\t\t\tmegasas_setup_irqs_ioapic(instance))\n\t\tgoto fail_init_mfi;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_setup_irq_poll(instance);\n\n\t \n\tif (instance->requestorId) {\n\t\tif (!megasas_sriov_start_heartbeat(instance, 0))\n\t\t\tmegasas_start_timer(instance);\n\t\telse {\n\t\t\tinstance->skip_heartbeat_timer_del = 1;\n\t\t\tgoto fail_init_mfi;\n\t\t}\n\t}\n\n\tinstance->instancet->enable_intr(instance);\n\tmegasas_setup_jbod_map(instance);\n\tinstance->unload = 0;\n\n\t \n\tif (megasas_start_aen(instance))\n\t\tdev_err(&instance->pdev->dev, \"Start AEN failed\\n\");\n\n\t \n\tif (instance->adapter_type != MFI_SERIES)\n\t\tif (megasas_fusion_start_watchdog(instance) != SUCCESS)\n\t\t\tgoto fail_start_watchdog;\n\n\treturn 0;\n\nfail_start_watchdog:\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\nfail_init_mfi:\n\tmegasas_free_ctrl_dma_buffers(instance);\n\tmegasas_free_ctrl_mem(instance);\n\tscsi_host_put(host);\n\nfail_reenable_msix:\nfail_set_dma_mask:\nfail_ready_state:\n\n\treturn -ENODEV;\n}\n\nstatic inline int\nmegasas_wait_for_adapter_operational(struct megasas_instance *instance)\n{\n\tint wait_time = MEGASAS_RESET_WAIT_TIME * 2;\n\tint i;\n\tu8 adp_state;\n\n\tfor (i = 0; i < wait_time; i++) {\n\t\tadp_state = atomic_read(&instance->adprecovery);\n\t\tif ((adp_state == MEGASAS_HBA_OPERATIONAL) ||\n\t\t    (adp_state == MEGASAS_HW_CRITICAL_ERROR))\n\t\t\tbreak;\n\n\t\tif (!(i % MEGASAS_RESET_NOTICE_INTERVAL))\n\t\t\tdev_notice(&instance->pdev->dev, \"waiting for controller reset to finish\\n\");\n\n\t\tmsleep(1000);\n\t}\n\n\tif (adp_state != MEGASAS_HBA_OPERATIONAL) {\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"%s HBA failed to become operational, adp_state %d\\n\",\n\t\t\t __func__, adp_state);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void megasas_detach_one(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct Scsi_Host *host;\n\tstruct megasas_instance *instance;\n\tstruct fusion_context *fusion;\n\tsize_t pd_seq_map_sz;\n\n\tinstance = pci_get_drvdata(pdev);\n\n\tif (!instance)\n\t\treturn;\n\n\thost = instance->host;\n\tfusion = instance->ctrl_context;\n\n\t \n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\n\n\t \n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_fusion_stop_watchdog(instance);\n\n\tif (instance->fw_crash_state != UNAVAILABLE)\n\t\tmegasas_free_host_crash_buffer(instance);\n\tscsi_remove_host(instance->host);\n\tinstance->unload = 1;\n\n\tif (megasas_wait_for_adapter_operational(instance))\n\t\tgoto skip_firing_dcmds;\n\n\tmegasas_flush_cache(instance);\n\tmegasas_shutdown_controller(instance, MR_DCMD_CTRL_SHUTDOWN);\n\nskip_firing_dcmds:\n\t \n\tif (instance->ev != NULL) {\n\t\tstruct megasas_aen_event *ev = instance->ev;\n\t\tcancel_delayed_work_sync(&ev->hotplug_work);\n\t\tinstance->ev = NULL;\n\t}\n\n\t \n\twake_up_all(&instance->int_cmd_wait_q);\n\n\ttasklet_kill(&instance->isr_tasklet);\n\n\t \n\tfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\n\t\tif (megasas_mgmt_info.instance[i] == instance) {\n\t\t\tmegasas_mgmt_info.count--;\n\t\t\tmegasas_mgmt_info.instance[i] = NULL;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinstance->instancet->disable_intr(instance);\n\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tfor (i = 0; i < MAX_LOGICAL_DRIVES_EXT; ++i)\n\t\t\tkfree(fusion->stream_detect_by_ld[i]);\n\t\tkfree(fusion->stream_detect_by_ld);\n\t\tfusion->stream_detect_by_ld = NULL;\n\t}\n\n\n\tif (instance->adapter_type != MFI_SERIES) {\n\t\tmegasas_release_fusion(instance);\n\t\tpd_seq_map_sz =\n\t\t\tstruct_size_t(struct MR_PD_CFG_SEQ_NUM_SYNC,\n\t\t\t\t      seq, MAX_PHYSICAL_DEVICES);\n\t\tfor (i = 0; i < 2 ; i++) {\n\t\t\tif (fusion->ld_map[i])\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\t\t  fusion->max_map_sz,\n\t\t\t\t\t\t  fusion->ld_map[i],\n\t\t\t\t\t\t  fusion->ld_map_phys[i]);\n\t\t\tif (fusion->ld_drv_map[i]) {\n\t\t\t\tif (is_vmalloc_addr(fusion->ld_drv_map[i]))\n\t\t\t\t\tvfree(fusion->ld_drv_map[i]);\n\t\t\t\telse\n\t\t\t\t\tfree_pages((ulong)fusion->ld_drv_map[i],\n\t\t\t\t\t\t   fusion->drv_map_pages);\n\t\t\t}\n\n\t\t\tif (fusion->pd_seq_sync[i])\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tpd_seq_map_sz,\n\t\t\t\t\tfusion->pd_seq_sync[i],\n\t\t\t\t\tfusion->pd_seq_phys[i]);\n\t\t}\n\t} else {\n\t\tmegasas_release_mfi(instance);\n\t}\n\n\tif (instance->vf_affiliation)\n\t\tdma_free_coherent(&pdev->dev, (MAX_LOGICAL_DRIVES + 1) *\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t    instance->vf_affiliation,\n\t\t\t\t    instance->vf_affiliation_h);\n\n\tif (instance->vf_affiliation_111)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t    instance->vf_affiliation_111,\n\t\t\t\t    instance->vf_affiliation_111_h);\n\n\tif (instance->hb_host_mem)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_CTRL_HB_HOST_MEM),\n\t\t\t\t    instance->hb_host_mem,\n\t\t\t\t    instance->hb_host_mem_h);\n\n\tmegasas_free_ctrl_dma_buffers(instance);\n\n\tmegasas_free_ctrl_mem(instance);\n\n\tmegasas_destroy_debugfs(instance);\n\n\tscsi_host_put(host);\n\n\tpci_disable_device(pdev);\n}\n\n \nstatic void megasas_shutdown(struct pci_dev *pdev)\n{\n\tstruct megasas_instance *instance = pci_get_drvdata(pdev);\n\n\tif (!instance)\n\t\treturn;\n\n\tinstance->unload = 1;\n\n\tif (megasas_wait_for_adapter_operational(instance))\n\t\tgoto skip_firing_dcmds;\n\n\tmegasas_flush_cache(instance);\n\tmegasas_shutdown_controller(instance, MR_DCMD_CTRL_SHUTDOWN);\n\nskip_firing_dcmds:\n\tinstance->instancet->disable_intr(instance);\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n}\n\n \nstatic int megasas_mgmt_open(struct inode *inode, struct file *filep)\n{\n\t \n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\n \nstatic int megasas_mgmt_fasync(int fd, struct file *filep, int mode)\n{\n\tint rc;\n\n\tmutex_lock(&megasas_async_queue_mutex);\n\n\trc = fasync_helper(fd, filep, mode, &megasas_async_queue);\n\n\tmutex_unlock(&megasas_async_queue_mutex);\n\n\tif (rc >= 0) {\n\t\t \n\t\tfilep->private_data = filep;\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_DEBUG \"megasas: fasync_helper failed [%d]\\n\", rc);\n\n\treturn rc;\n}\n\n \nstatic __poll_t megasas_mgmt_poll(struct file *file, poll_table *wait)\n{\n\t__poll_t mask;\n\tunsigned long flags;\n\n\tpoll_wait(file, &megasas_poll_wait, wait);\n\tspin_lock_irqsave(&poll_aen_lock, flags);\n\tif (megasas_poll_wait_aen)\n\t\tmask = (EPOLLIN | EPOLLRDNORM);\n\telse\n\t\tmask = 0;\n\tmegasas_poll_wait_aen = 0;\n\tspin_unlock_irqrestore(&poll_aen_lock, flags);\n\treturn mask;\n}\n\n \n\nstatic int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)\n{\n\tstruct megasas_instance *local_instance;\n\tint i, error = 0;\n\tint crash_support;\n\n\tcrash_support = cmd->frame->dcmd.mbox.w[0];\n\n\tfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\n\t\tlocal_instance = megasas_mgmt_info.instance[i];\n\t\tif (local_instance && local_instance->crash_dump_drv_support) {\n\t\t\tif ((atomic_read(&local_instance->adprecovery) ==\n\t\t\t\tMEGASAS_HBA_OPERATIONAL) &&\n\t\t\t\t!megasas_set_crash_dump_params(local_instance,\n\t\t\t\t\tcrash_support)) {\n\t\t\t\tlocal_instance->crash_dump_app_support =\n\t\t\t\t\tcrash_support;\n\t\t\t\tdev_info(&local_instance->pdev->dev,\n\t\t\t\t\t\"Application firmware crash \"\n\t\t\t\t\t\"dump mode set success\\n\");\n\t\t\t\terror = 0;\n\t\t\t} else {\n\t\t\t\tdev_info(&local_instance->pdev->dev,\n\t\t\t\t\t\"Application firmware crash \"\n\t\t\t\t\t\"dump mode set failed\\n\");\n\t\t\t\terror = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn error;\n}\n\n \nstatic int\nmegasas_mgmt_fw_ioctl(struct megasas_instance *instance,\n\t\t      struct megasas_iocpacket __user * user_ioc,\n\t\t      struct megasas_iocpacket *ioc)\n{\n\tstruct megasas_sge64 *kern_sge64 = NULL;\n\tstruct megasas_sge32 *kern_sge32 = NULL;\n\tstruct megasas_cmd *cmd;\n\tvoid *kbuff_arr[MAX_IOCTL_SGE];\n\tdma_addr_t buf_handle = 0;\n\tint error = 0, i;\n\tvoid *sense = NULL;\n\tdma_addr_t sense_handle;\n\tvoid *sense_ptr;\n\tu32 opcode = 0;\n\tint ret = DCMD_SUCCESS;\n\n\tmemset(kbuff_arr, 0, sizeof(kbuff_arr));\n\n\tif (ioc->sge_count > MAX_IOCTL_SGE) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SGE count [%d] >  max limit [%d]\\n\",\n\t\t       ioc->sge_count, MAX_IOCTL_SGE);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((ioc->frame.hdr.cmd >= MFI_CMD_OP_COUNT) ||\n\t    ((ioc->frame.hdr.cmd == MFI_CMD_NVME) &&\n\t    !instance->support_nvme_passthru) ||\n\t    ((ioc->frame.hdr.cmd == MFI_CMD_TOOLBOX) &&\n\t    !instance->support_pci_lane_margining)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Received invalid ioctl command 0x%x\\n\",\n\t\t\tioc->frame.hdr.cmd);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tcmd = megasas_get_cmd(instance);\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to get a cmd packet\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmemcpy(cmd->frame, ioc->frame.raw, 2 * MEGAMFI_FRAME_SIZE);\n\tcmd->frame->hdr.context = cpu_to_le32(cmd->index);\n\tcmd->frame->hdr.pad_0 = 0;\n\n\tcmd->frame->hdr.flags &= (~MFI_FRAME_IEEE);\n\n\tif (instance->consistent_mask_64bit)\n\t\tcmd->frame->hdr.flags |= cpu_to_le16((MFI_FRAME_SGL64 |\n\t\t\t\t       MFI_FRAME_SENSE64));\n\telse\n\t\tcmd->frame->hdr.flags &= cpu_to_le16(~(MFI_FRAME_SGL64 |\n\t\t\t\t\t       MFI_FRAME_SENSE64));\n\n\tif (cmd->frame->hdr.cmd == MFI_CMD_DCMD)\n\t\topcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n\n\tif (opcode == MR_DCMD_CTRL_SHUTDOWN) {\n\t\tmutex_lock(&instance->reset_mutex);\n\t\tif (megasas_get_ctrl_info(instance) != DCMD_SUCCESS) {\n\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\treturn -1;\n\t\t}\n\t\tmutex_unlock(&instance->reset_mutex);\n\t}\n\n\tif (opcode == MR_DRIVER_SET_APP_CRASHDUMP_MODE) {\n\t\terror = megasas_set_crash_dump_params_ioctl(cmd);\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn error;\n\t}\n\n\t \n\tif (instance->consistent_mask_64bit)\n\t\tkern_sge64 = (struct megasas_sge64 *)\n\t\t\t((unsigned long)cmd->frame + ioc->sgl_off);\n\telse\n\t\tkern_sge32 = (struct megasas_sge32 *)\n\t\t\t((unsigned long)cmd->frame + ioc->sgl_off);\n\n\t \n\tfor (i = 0; i < ioc->sge_count; i++) {\n\t\tif (!ioc->sgl[i].iov_len)\n\t\t\tcontinue;\n\n\t\tkbuff_arr[i] = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t\t    ioc->sgl[i].iov_len,\n\t\t\t\t\t\t    &buf_handle, GFP_KERNEL);\n\t\tif (!kbuff_arr[i]) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to alloc \"\n\t\t\t       \"kernel SGL buffer for IOCTL\\n\");\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (instance->consistent_mask_64bit) {\n\t\t\tkern_sge64[i].phys_addr = cpu_to_le64(buf_handle);\n\t\t\tkern_sge64[i].length = cpu_to_le32(ioc->sgl[i].iov_len);\n\t\t} else {\n\t\t\tkern_sge32[i].phys_addr = cpu_to_le32(buf_handle);\n\t\t\tkern_sge32[i].length = cpu_to_le32(ioc->sgl[i].iov_len);\n\t\t}\n\n\t\t \n\t\tif (copy_from_user(kbuff_arr[i], ioc->sgl[i].iov_base,\n\t\t\t\t   (u32) (ioc->sgl[i].iov_len))) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ioc->sense_len) {\n\t\t \n\t\tif (ioc->sense_off >\n\t\t    (sizeof(union megasas_frame) - sizeof(__le64))) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsense = dma_alloc_coherent(&instance->pdev->dev, ioc->sense_len,\n\t\t\t\t\t     &sense_handle, GFP_KERNEL);\n\t\tif (!sense) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tsense_ptr = (void *)cmd->frame + ioc->sense_off;\n\t\tput_unaligned_le64(sense_handle, sense_ptr);\n\t}\n\n\t \n\tcmd->sync_cmd = 1;\n\n\tret = megasas_issue_blocked_cmd(instance, cmd, 0);\n\tswitch (ret) {\n\tcase DCMD_INIT:\n\tcase DCMD_BUSY:\n\t\tcmd->sync_cmd = 0;\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return -EBUSY from %s %d cmd 0x%x opcode 0x%x cmd->cmd_status_drv 0x%x\\n\",\n\t\t\t __func__, __LINE__, cmd->frame->hdr.cmd, opcode,\n\t\t\t cmd->cmd_status_drv);\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tcmd->sync_cmd = 0;\n\n\tif (instance->unload == 1) {\n\t\tdev_info(&instance->pdev->dev, \"Driver unload is in progress \"\n\t\t\t\"don't submit data to application\\n\");\n\t\tgoto out;\n\t}\n\t \n\tfor (i = 0; i < ioc->sge_count; i++) {\n\t\tif (copy_to_user(ioc->sgl[i].iov_base, kbuff_arr[i],\n\t\t\t\t ioc->sgl[i].iov_len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (ioc->sense_len) {\n\t\tvoid __user *uptr;\n\t\t \n\t\tsense_ptr = (void *)ioc->frame.raw + ioc->sense_off;\n\t\tif (in_compat_syscall())\n\t\t\tuptr = compat_ptr(get_unaligned((compat_uptr_t *)\n\t\t\t\t\t\t\tsense_ptr));\n\t\telse\n\t\t\tuptr = get_unaligned((void __user **)sense_ptr);\n\n\t\tif (copy_to_user(uptr, sense, ioc->sense_len)) {\n\t\t\tdev_err(&instance->pdev->dev, \"Failed to copy out to user \"\n\t\t\t\t\t\"sense data\\n\");\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (copy_to_user(&user_ioc->frame.hdr.cmd_status,\n\t\t\t &cmd->frame->hdr.cmd_status, sizeof(u8))) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error copying out cmd_status\\n\");\n\t\terror = -EFAULT;\n\t}\n\nout:\n\tif (sense) {\n\t\tdma_free_coherent(&instance->pdev->dev, ioc->sense_len,\n\t\t\t\t    sense, sense_handle);\n\t}\n\n\tfor (i = 0; i < ioc->sge_count; i++) {\n\t\tif (kbuff_arr[i]) {\n\t\t\tif (instance->consistent_mask_64bit)\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tle32_to_cpu(kern_sge64[i].length),\n\t\t\t\t\tkbuff_arr[i],\n\t\t\t\t\tle64_to_cpu(kern_sge64[i].phys_addr));\n\t\t\telse\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tle32_to_cpu(kern_sge32[i].length),\n\t\t\t\t\tkbuff_arr[i],\n\t\t\t\t\tle32_to_cpu(kern_sge32[i].phys_addr));\n\t\t\tkbuff_arr[i] = NULL;\n\t\t}\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n\treturn error;\n}\n\nstatic struct megasas_iocpacket *\nmegasas_compat_iocpacket_get_user(void __user *arg)\n{\n\tstruct megasas_iocpacket *ioc;\n\tstruct compat_megasas_iocpacket __user *cioc = arg;\n\tsize_t size;\n\tint err = -EFAULT;\n\tint i;\n\n\tioc = kzalloc(sizeof(*ioc), GFP_KERNEL);\n\tif (!ioc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsize = offsetof(struct megasas_iocpacket, frame) + sizeof(ioc->frame);\n\tif (copy_from_user(ioc, arg, size))\n\t\tgoto out;\n\n\tfor (i = 0; i < MAX_IOCTL_SGE; i++) {\n\t\tcompat_uptr_t iov_base;\n\n\t\tif (get_user(iov_base, &cioc->sgl[i].iov_base) ||\n\t\t    get_user(ioc->sgl[i].iov_len, &cioc->sgl[i].iov_len))\n\t\t\tgoto out;\n\n\t\tioc->sgl[i].iov_base = compat_ptr(iov_base);\n\t}\n\n\treturn ioc;\nout:\n\tkfree(ioc);\n\treturn ERR_PTR(err);\n}\n\nstatic int megasas_mgmt_ioctl_fw(struct file *file, unsigned long arg)\n{\n\tstruct megasas_iocpacket __user *user_ioc =\n\t    (struct megasas_iocpacket __user *)arg;\n\tstruct megasas_iocpacket *ioc;\n\tstruct megasas_instance *instance;\n\tint error;\n\n\tif (in_compat_syscall())\n\t\tioc = megasas_compat_iocpacket_get_user(user_ioc);\n\telse\n\t\tioc = memdup_user(user_ioc, sizeof(struct megasas_iocpacket));\n\n\tif (IS_ERR(ioc))\n\t\treturn PTR_ERR(ioc);\n\n\tinstance = megasas_lookup_instance(ioc->host_no);\n\tif (!instance) {\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\t \n\tif (instance->requestorId && !allow_vf_ioctls) {\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Controller in crit error\\n\");\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif (instance->unload == 1) {\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif (down_interruptible(&instance->ioctl_sem)) {\n\t\terror = -ERESTARTSYS;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif  (megasas_wait_for_adapter_operational(instance)) {\n\t\terror = -ENODEV;\n\t\tgoto out_up;\n\t}\n\n\terror = megasas_mgmt_fw_ioctl(instance, user_ioc, ioc);\nout_up:\n\tup(&instance->ioctl_sem);\n\nout_kfree_ioc:\n\tkfree(ioc);\n\treturn error;\n}\n\nstatic int megasas_mgmt_ioctl_aen(struct file *file, unsigned long arg)\n{\n\tstruct megasas_instance *instance;\n\tstruct megasas_aen aen;\n\tint error;\n\n\tif (file->private_data != file) {\n\t\tprintk(KERN_DEBUG \"megasas: fasync_helper was not \"\n\t\t       \"called first\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&aen, (void __user *)arg, sizeof(aen)))\n\t\treturn -EFAULT;\n\n\tinstance = megasas_lookup_instance(aen.host_no);\n\n\tif (!instance)\n\t\treturn -ENODEV;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\treturn -ENODEV;\n\t}\n\n\tif (instance->unload == 1) {\n\t\treturn -ENODEV;\n\t}\n\n\tif  (megasas_wait_for_adapter_operational(instance))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&instance->reset_mutex);\n\terror = megasas_register_aen(instance, aen.seq_num,\n\t\t\t\t     aen.class_locale_word);\n\tmutex_unlock(&instance->reset_mutex);\n\treturn error;\n}\n\n \nstatic long\nmegasas_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase MEGASAS_IOC_FIRMWARE:\n\t\treturn megasas_mgmt_ioctl_fw(file, arg);\n\n\tcase MEGASAS_IOC_GET_AEN:\n\t\treturn megasas_mgmt_ioctl_aen(file, arg);\n\t}\n\n\treturn -ENOTTY;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long\nmegasas_mgmt_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase MEGASAS_IOC_FIRMWARE32:\n\t\treturn megasas_mgmt_ioctl_fw(file, arg);\n\tcase MEGASAS_IOC_GET_AEN:\n\t\treturn megasas_mgmt_ioctl_aen(file, arg);\n\t}\n\n\treturn -ENOTTY;\n}\n#endif\n\n \nstatic const struct file_operations megasas_mgmt_fops = {\n\t.owner = THIS_MODULE,\n\t.open = megasas_mgmt_open,\n\t.fasync = megasas_mgmt_fasync,\n\t.unlocked_ioctl = megasas_mgmt_ioctl,\n\t.poll = megasas_mgmt_poll,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = megasas_mgmt_compat_ioctl,\n#endif\n\t.llseek = noop_llseek,\n};\n\nstatic SIMPLE_DEV_PM_OPS(megasas_pm_ops, megasas_suspend, megasas_resume);\n\n \nstatic struct pci_driver megasas_pci_driver = {\n\n\t.name = \"megaraid_sas\",\n\t.id_table = megasas_pci_table,\n\t.probe = megasas_probe_one,\n\t.remove = megasas_detach_one,\n\t.driver.pm = &megasas_pm_ops,\n\t.shutdown = megasas_shutdown,\n};\n\n \nstatic ssize_t version_show(struct device_driver *dd, char *buf)\n{\n\treturn snprintf(buf, strlen(MEGASAS_VERSION) + 2, \"%s\\n\",\n\t\t\tMEGASAS_VERSION);\n}\nstatic DRIVER_ATTR_RO(version);\n\nstatic ssize_t release_date_show(struct device_driver *dd, char *buf)\n{\n\treturn snprintf(buf, strlen(MEGASAS_RELDATE) + 2, \"%s\\n\",\n\t\tMEGASAS_RELDATE);\n}\nstatic DRIVER_ATTR_RO(release_date);\n\nstatic ssize_t support_poll_for_event_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_poll_for_event);\n}\nstatic DRIVER_ATTR_RO(support_poll_for_event);\n\nstatic ssize_t support_device_change_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_device_change);\n}\nstatic DRIVER_ATTR_RO(support_device_change);\n\nstatic ssize_t dbg_lvl_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", megasas_dbg_lvl);\n}\n\nstatic ssize_t dbg_lvl_store(struct device_driver *dd, const char *buf,\n\t\t\t     size_t count)\n{\n\tint retval = count;\n\n\tif (sscanf(buf, \"%u\", &megasas_dbg_lvl) < 1) {\n\t\tprintk(KERN_ERR \"megasas: could not set dbg_lvl\\n\");\n\t\tretval = -EINVAL;\n\t}\n\treturn retval;\n}\nstatic DRIVER_ATTR_RW(dbg_lvl);\n\nstatic ssize_t\nsupport_nvme_encapsulation_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_nvme_encapsulation);\n}\n\nstatic DRIVER_ATTR_RO(support_nvme_encapsulation);\n\nstatic ssize_t\nsupport_pci_lane_margining_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_pci_lane_margining);\n}\n\nstatic DRIVER_ATTR_RO(support_pci_lane_margining);\n\nstatic inline void megasas_remove_scsi_device(struct scsi_device *sdev)\n{\n\tsdev_printk(KERN_INFO, sdev, \"SCSI device is removed\\n\");\n\tscsi_remove_device(sdev);\n\tscsi_device_put(sdev);\n}\n\n \nstatic\nint megasas_update_device_list(struct megasas_instance *instance,\n\t\t\t       int event_type)\n{\n\tint dcmd_ret;\n\n\tif (instance->enable_fw_dev_list) {\n\t\treturn megasas_host_device_list_query(instance, false);\n\t} else {\n\t\tif (event_type & SCAN_PD_CHANNEL) {\n\t\t\tdcmd_ret = megasas_get_pd_list(instance);\n\t\t\tif (dcmd_ret != DCMD_SUCCESS)\n\t\t\t\treturn dcmd_ret;\n\t\t}\n\n\t\tif (event_type & SCAN_VD_CHANNEL) {\n\t\t\tif (!instance->requestorId ||\n\t\t\tmegasas_get_ld_vf_affiliation(instance, 0)) {\n\t\t\t\treturn megasas_ld_list_query(instance,\n\t\t\t\t\t\tMR_LD_QUERY_TYPE_EXPOSED_TO_HOST);\n\t\t\t}\n\t\t}\n\t}\n\treturn DCMD_SUCCESS;\n}\n\n \nstatic\nvoid megasas_add_remove_devices(struct megasas_instance *instance,\n\t\t\t\tint scan_type)\n{\n\tint i, j;\n\tu16 pd_index = 0;\n\tu16 ld_index = 0;\n\tu16 channel = 0, id = 0;\n\tstruct Scsi_Host *host;\n\tstruct scsi_device *sdev1;\n\tstruct MR_HOST_DEVICE_LIST *targetid_list = NULL;\n\tstruct MR_HOST_DEVICE_LIST_ENTRY *targetid_entry = NULL;\n\n\thost = instance->host;\n\n\tif (instance->enable_fw_dev_list) {\n\t\ttargetid_list = instance->host_device_list_buf;\n\t\tfor (i = 0; i < targetid_list->count; i++) {\n\t\t\ttargetid_entry = &targetid_list->host_device_list[i];\n\t\t\tif (targetid_entry->flags.u.bits.is_sys_pd) {\n\t\t\t\tchannel = le16_to_cpu(targetid_entry->target_id) /\n\t\t\t\t\t\tMEGASAS_MAX_DEV_PER_CHANNEL;\n\t\t\t\tid = le16_to_cpu(targetid_entry->target_id) %\n\t\t\t\t\t\tMEGASAS_MAX_DEV_PER_CHANNEL;\n\t\t\t} else {\n\t\t\t\tchannel = MEGASAS_MAX_PD_CHANNELS +\n\t\t\t\t\t  (le16_to_cpu(targetid_entry->target_id) /\n\t\t\t\t\t   MEGASAS_MAX_DEV_PER_CHANNEL);\n\t\t\t\tid = le16_to_cpu(targetid_entry->target_id) %\n\t\t\t\t\t\tMEGASAS_MAX_DEV_PER_CHANNEL;\n\t\t\t}\n\t\t\tsdev1 = scsi_device_lookup(host, channel, id, 0);\n\t\t\tif (!sdev1) {\n\t\t\t\tscsi_add_device(host, channel, id, 0);\n\t\t\t} else {\n\t\t\t\tscsi_device_put(sdev1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (scan_type & SCAN_PD_CHANNEL) {\n\t\tfor (i = 0; i < MEGASAS_MAX_PD_CHANNELS; i++) {\n\t\t\tfor (j = 0; j < MEGASAS_MAX_DEV_PER_CHANNEL; j++) {\n\t\t\t\tpd_index = i * MEGASAS_MAX_DEV_PER_CHANNEL + j;\n\t\t\t\tsdev1 = scsi_device_lookup(host, i, j, 0);\n\t\t\t\tif (instance->pd_list[pd_index].driveState ==\n\t\t\t\t\t\t\tMR_PD_STATE_SYSTEM) {\n\t\t\t\t\tif (!sdev1)\n\t\t\t\t\t\tscsi_add_device(host, i, j, 0);\n\t\t\t\t\telse\n\t\t\t\t\t\tscsi_device_put(sdev1);\n\t\t\t\t} else {\n\t\t\t\t\tif (sdev1)\n\t\t\t\t\t\tmegasas_remove_scsi_device(sdev1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (scan_type & SCAN_VD_CHANNEL) {\n\t\tfor (i = 0; i < MEGASAS_MAX_LD_CHANNELS; i++) {\n\t\t\tfor (j = 0; j < MEGASAS_MAX_DEV_PER_CHANNEL; j++) {\n\t\t\t\tld_index = (i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;\n\t\t\t\tsdev1 = scsi_device_lookup(host,\n\t\t\t\t\t\tMEGASAS_MAX_PD_CHANNELS + i, j, 0);\n\t\t\t\tif (instance->ld_ids[ld_index] != 0xff) {\n\t\t\t\t\tif (!sdev1)\n\t\t\t\t\t\tscsi_add_device(host, MEGASAS_MAX_PD_CHANNELS + i, j, 0);\n\t\t\t\t\telse\n\t\t\t\t\t\tscsi_device_put(sdev1);\n\t\t\t\t} else {\n\t\t\t\t\tif (sdev1)\n\t\t\t\t\t\tmegasas_remove_scsi_device(sdev1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nstatic void\nmegasas_aen_polling(struct work_struct *work)\n{\n\tstruct megasas_aen_event *ev =\n\t\tcontainer_of(work, struct megasas_aen_event, hotplug_work.work);\n\tstruct megasas_instance *instance = ev->instance;\n\tunion megasas_evt_class_locale class_locale;\n\tint event_type = 0;\n\tu32 seq_num;\n\tu16 ld_target_id;\n\tint error;\n\tu8  dcmd_ret = DCMD_SUCCESS;\n\tstruct scsi_device *sdev1;\n\n\tif (!instance) {\n\t\tprintk(KERN_ERR \"invalid instance!\\n\");\n\t\tkfree(ev);\n\t\treturn;\n\t}\n\n\t \n\tmutex_lock(&instance->reset_mutex);\n\n\tinstance->ev = NULL;\n\tif (instance->evt_detail) {\n\t\tmegasas_decode_evt(instance);\n\n\t\tswitch (le32_to_cpu(instance->evt_detail->code)) {\n\n\t\tcase MR_EVT_PD_INSERTED:\n\t\tcase MR_EVT_PD_REMOVED:\n\t\t\tevent_type = SCAN_PD_CHANNEL;\n\t\t\tbreak;\n\n\t\tcase MR_EVT_LD_OFFLINE:\n\t\tcase MR_EVT_LD_DELETED:\n\t\t\tld_target_id = instance->evt_detail->args.ld.target_id;\n\t\t\tsdev1 = scsi_device_lookup(instance->host,\n\t\t\t\t\t\t   MEGASAS_MAX_PD_CHANNELS +\n\t\t\t\t\t\t   (ld_target_id / MEGASAS_MAX_DEV_PER_CHANNEL),\n\t\t\t\t\t\t   (ld_target_id % MEGASAS_MAX_DEV_PER_CHANNEL),\n\t\t\t\t\t\t   0);\n\t\t\tif (sdev1)\n\t\t\t\tmegasas_remove_scsi_device(sdev1);\n\n\t\t\tevent_type = SCAN_VD_CHANNEL;\n\t\t\tbreak;\n\t\tcase MR_EVT_LD_CREATED:\n\t\t\tevent_type = SCAN_VD_CHANNEL;\n\t\t\tbreak;\n\n\t\tcase MR_EVT_CFG_CLEARED:\n\t\tcase MR_EVT_CTRL_HOST_BUS_SCAN_REQUESTED:\n\t\tcase MR_EVT_FOREIGN_CFG_IMPORTED:\n\t\tcase MR_EVT_LD_STATE_CHANGE:\n\t\t\tevent_type = SCAN_PD_CHANNEL | SCAN_VD_CHANNEL;\n\t\t\tdev_info(&instance->pdev->dev, \"scanning for scsi%d...\\n\",\n\t\t\t\tinstance->host->host_no);\n\t\t\tbreak;\n\n\t\tcase MR_EVT_CTRL_PROP_CHANGED:\n\t\t\tdcmd_ret = megasas_get_ctrl_info(instance);\n\t\t\tif (dcmd_ret == DCMD_SUCCESS &&\n\t\t\t    instance->snapdump_wait_time) {\n\t\t\t\tmegasas_get_snapdump_properties(instance);\n\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t \"Snap dump wait time\\t: %d\\n\",\n\t\t\t\t\t instance->snapdump_wait_time);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tevent_type = 0;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdev_err(&instance->pdev->dev, \"invalid evt_detail!\\n\");\n\t\tmutex_unlock(&instance->reset_mutex);\n\t\tkfree(ev);\n\t\treturn;\n\t}\n\n\tif (event_type)\n\t\tdcmd_ret = megasas_update_device_list(instance, event_type);\n\n\tmutex_unlock(&instance->reset_mutex);\n\n\tif (event_type && dcmd_ret == DCMD_SUCCESS)\n\t\tmegasas_add_remove_devices(instance, event_type);\n\n\tif (dcmd_ret == DCMD_SUCCESS)\n\t\tseq_num = le32_to_cpu(instance->evt_detail->seq_num) + 1;\n\telse\n\t\tseq_num = instance->last_seq_num;\n\n\t \n\tclass_locale.members.reserved = 0;\n\tclass_locale.members.locale = MR_EVT_LOCALE_ALL;\n\tclass_locale.members.class = MR_EVT_CLASS_DEBUG;\n\n\tif (instance->aen_cmd != NULL) {\n\t\tkfree(ev);\n\t\treturn;\n\t}\n\n\tmutex_lock(&instance->reset_mutex);\n\terror = megasas_register_aen(instance, seq_num,\n\t\t\t\t\tclass_locale.word);\n\tif (error)\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"register aen failed error %x\\n\", error);\n\n\tmutex_unlock(&instance->reset_mutex);\n\tkfree(ev);\n}\n\n \nstatic int __init megasas_init(void)\n{\n\tint rval;\n\n\t \n\tif (reset_devices) {\n\t\tmsix_vectors = 1;\n\t\trdpq_enable = 0;\n\t\tdual_qdepth_disable = 1;\n\t\tpoll_queues = 0;\n\t}\n\n\t \n\tpr_info(\"megasas: %s\\n\", MEGASAS_VERSION);\n\n\tmegasas_dbg_lvl = 0;\n\tsupport_poll_for_event = 2;\n\tsupport_device_change = 1;\n\tsupport_nvme_encapsulation = true;\n\tsupport_pci_lane_margining = true;\n\n\tmemset(&megasas_mgmt_info, 0, sizeof(megasas_mgmt_info));\n\n\t \n\trval = register_chrdev(0, \"megaraid_sas_ioctl\", &megasas_mgmt_fops);\n\n\tif (rval < 0) {\n\t\tprintk(KERN_DEBUG \"megasas: failed to open device node\\n\");\n\t\treturn rval;\n\t}\n\n\tmegasas_mgmt_majorno = rval;\n\n\tmegasas_init_debugfs();\n\n\t \n\trval = pci_register_driver(&megasas_pci_driver);\n\n\tif (rval) {\n\t\tprintk(KERN_DEBUG \"megasas: PCI hotplug registration failed \\n\");\n\t\tgoto err_pcidrv;\n\t}\n\n\tif ((event_log_level < MFI_EVT_CLASS_DEBUG) ||\n\t    (event_log_level > MFI_EVT_CLASS_DEAD)) {\n\t\tpr_warn(\"megaraid_sas: provided event log level is out of range, setting it to default 2(CLASS_CRITICAL), permissible range is: -2 to 4\\n\");\n\t\tevent_log_level = MFI_EVT_CLASS_CRITICAL;\n\t}\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_version);\n\tif (rval)\n\t\tgoto err_dcf_attr_ver;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_release_date);\n\tif (rval)\n\t\tgoto err_dcf_rel_date;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t&driver_attr_support_poll_for_event);\n\tif (rval)\n\t\tgoto err_dcf_support_poll_for_event;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_dbg_lvl);\n\tif (rval)\n\t\tgoto err_dcf_dbg_lvl;\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t&driver_attr_support_device_change);\n\tif (rval)\n\t\tgoto err_dcf_support_device_change;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_support_nvme_encapsulation);\n\tif (rval)\n\t\tgoto err_dcf_support_nvme_encapsulation;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_support_pci_lane_margining);\n\tif (rval)\n\t\tgoto err_dcf_support_pci_lane_margining;\n\n\treturn rval;\n\nerr_dcf_support_pci_lane_margining:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_support_nvme_encapsulation);\n\nerr_dcf_support_nvme_encapsulation:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_support_device_change);\n\nerr_dcf_support_device_change:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_dbg_lvl);\nerr_dcf_dbg_lvl:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t&driver_attr_support_poll_for_event);\nerr_dcf_support_poll_for_event:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_release_date);\nerr_dcf_rel_date:\n\tdriver_remove_file(&megasas_pci_driver.driver, &driver_attr_version);\nerr_dcf_attr_ver:\n\tpci_unregister_driver(&megasas_pci_driver);\nerr_pcidrv:\n\tmegasas_exit_debugfs();\n\tunregister_chrdev(megasas_mgmt_majorno, \"megaraid_sas_ioctl\");\n\treturn rval;\n}\n\n \nstatic void __exit megasas_exit(void)\n{\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_dbg_lvl);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t&driver_attr_support_poll_for_event);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t&driver_attr_support_device_change);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_release_date);\n\tdriver_remove_file(&megasas_pci_driver.driver, &driver_attr_version);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_support_nvme_encapsulation);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_support_pci_lane_margining);\n\n\tpci_unregister_driver(&megasas_pci_driver);\n\tmegasas_exit_debugfs();\n\tunregister_chrdev(megasas_mgmt_majorno, \"megaraid_sas_ioctl\");\n}\n\nmodule_init(megasas_init);\nmodule_exit(megasas_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}