{
  "module_name": "scsi_dh_emc.c",
  "hash_id": "60d62ba8e091e00cd5957c8f7db42925ba72a7ee0dd949d0ac32167f1f9d9f08",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/device_handler/scsi_dh_emc.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/module.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_dh.h>\n#include <scsi/scsi_device.h>\n\n#define CLARIION_NAME\t\t\t\"emc\"\n\n#define CLARIION_TRESPASS_PAGE\t\t0x22\n#define CLARIION_BUFFER_SIZE\t\t0xFC\n#define CLARIION_TIMEOUT\t\t(60 * HZ)\n#define CLARIION_RETRIES\t\t3\n#define CLARIION_UNBOUND_LU\t\t-1\n#define CLARIION_SP_A\t\t\t0\n#define CLARIION_SP_B\t\t\t1\n\n \n#define CLARIION_SHORT_TRESPASS\t\t1\n#define CLARIION_HONOR_RESERVATIONS\t2\n\n \n#define CLARIION_LUN_UNINITIALIZED\t-1\n#define CLARIION_LUN_UNBOUND\t\t0\n#define CLARIION_LUN_BOUND\t\t1\n#define CLARIION_LUN_OWNED\t\t2\n\nstatic unsigned char long_trespass[] = {\n\t0, 0, 0, 0, 0, 0, 0, 0,\n\tCLARIION_TRESPASS_PAGE,\t \n\t0x09,\t\t\t \n\t0x01,\t\t\t \n\t0xff, 0xff,\t\t \n\t0, 0, 0, 0, 0, 0\t \n};\n\nstatic unsigned char short_trespass[] = {\n\t0, 0, 0, 0,\n\tCLARIION_TRESPASS_PAGE,\t \n\t0x02,\t\t\t \n\t0x01,\t\t\t \n\t0xff,\t\t\t \n};\n\nstatic const char * lun_state[] =\n{\n    \"not bound\",\n    \"bound\",\n    \"owned\",\n};\n\nstruct clariion_dh_data {\n\t \n\tunsigned flags;\n\t \n\tunsigned char buffer[CLARIION_BUFFER_SIZE];\n\t \n\tint lun_state;\n\t \n\tint port;\n\t \n\tint default_sp;\n\t \n\tint current_sp;\n};\n\n \nstatic int trespass_endio(struct scsi_device *sdev,\n\t\t\t  struct scsi_sense_hdr *sshdr)\n{\n\tint err = SCSI_DH_IO;\n\n\tsdev_printk(KERN_ERR, sdev, \"%s: Found valid sense data 0x%2x, \"\n\t\t    \"0x%2x, 0x%2x while sending CLARiiON trespass \"\n\t\t    \"command.\\n\", CLARIION_NAME, sshdr->sense_key,\n\t\t    sshdr->asc, sshdr->ascq);\n\n\tif (sshdr->sense_key == 0x05 && sshdr->asc == 0x04 &&\n\t    sshdr->ascq == 0x00) {\n\t\t \n\t\tsdev_printk(KERN_INFO, sdev, \"%s: Array Based Copy in \"\n\t\t\t    \"progress while sending CLARiiON trespass \"\n\t\t\t    \"command.\\n\", CLARIION_NAME);\n\t\terr = SCSI_DH_DEV_TEMP_BUSY;\n\t} else if (sshdr->sense_key == 0x02 && sshdr->asc == 0x04 &&\n\t\t   sshdr->ascq == 0x03) {\n\t\t \n\t\tsdev_printk(KERN_INFO, sdev, \"%s: Detected in-progress \"\n\t\t\t    \"ucode upgrade NDU operation while sending \"\n\t\t\t    \"CLARiiON trespass command.\\n\", CLARIION_NAME);\n\t\terr = SCSI_DH_DEV_TEMP_BUSY;\n\t} else\n\t\terr = SCSI_DH_DEV_FAILED;\n\treturn err;\n}\n\nstatic int parse_sp_info_reply(struct scsi_device *sdev,\n\t\t\t       struct clariion_dh_data *csdev)\n{\n\tint err = SCSI_DH_OK;\n\n\t \n\tif (csdev->buffer[48] != 0) {\n\t\tsdev_printk(KERN_NOTICE, sdev, \"%s: Detected in-progress \"\n\t\t\t    \"ucode upgrade NDU operation while finding \"\n\t\t\t    \"current active SP.\", CLARIION_NAME);\n\t\terr = SCSI_DH_DEV_TEMP_BUSY;\n\t\tgoto out;\n\t}\n\tif (csdev->buffer[4] > 2) {\n\t\t \n\t\tsdev_printk(KERN_NOTICE, sdev,\n\t\t\t    \"%s: invalid VPD page 0xC0 format\\n\",\n\t\t\t    CLARIION_NAME);\n\t\terr = SCSI_DH_NOSYS;\n\t\tgoto out;\n\t}\n\tswitch (csdev->buffer[28] & 0x0f) {\n\tcase 6:\n\t\tsdev_printk(KERN_NOTICE, sdev,\n\t\t\t    \"%s: ALUA failover mode detected\\n\",\n\t\t\t    CLARIION_NAME);\n\t\tbreak;\n\tcase 4:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t    \"%s: Invalid failover mode %d\\n\",\n\t\t\t    CLARIION_NAME, csdev->buffer[28] & 0x0f);\n\t\terr = SCSI_DH_NOSYS;\n\t\tgoto out;\n\t}\n\n\tcsdev->default_sp = csdev->buffer[5];\n\tcsdev->lun_state = csdev->buffer[4];\n\tcsdev->current_sp = csdev->buffer[8];\n\tcsdev->port = csdev->buffer[7];\n\tif (csdev->lun_state == CLARIION_LUN_OWNED)\n\t\tsdev->access_state = SCSI_ACCESS_STATE_OPTIMAL;\n\telse\n\t\tsdev->access_state = SCSI_ACCESS_STATE_STANDBY;\n\tif (csdev->default_sp == csdev->current_sp)\n\t\tsdev->access_state |= SCSI_ACCESS_STATE_PREFERRED;\nout:\n\treturn err;\n}\n\n#define emc_default_str \"FC (Legacy)\"\n\nstatic char * parse_sp_model(struct scsi_device *sdev, unsigned char *buffer)\n{\n\tunsigned char len = buffer[4] + 5;\n\tchar *sp_model = NULL;\n\tunsigned char sp_len, serial_len;\n\n\tif (len < 160) {\n\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t    \"%s: Invalid information section length %d\\n\",\n\t\t\t    CLARIION_NAME, len);\n\t\t \n\t\tif (!strncmp(buffer + 8, \"DGC\", 3)) {\n\t\t\t \n\t\t\tsp_model = emc_default_str;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tserial_len = buffer[160];\n\tif (serial_len == 0 || serial_len + 161 > len) {\n\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t    \"%s: Invalid array serial number length %d\\n\",\n\t\t\t    CLARIION_NAME, serial_len);\n\t\tgoto out;\n\t}\n\tsp_len = buffer[99];\n\tif (sp_len == 0 || serial_len + sp_len + 161 > len) {\n\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t    \"%s: Invalid model number length %d\\n\",\n\t\t\t    CLARIION_NAME, sp_len);\n\t\tgoto out;\n\t}\n\tsp_model = &buffer[serial_len + 161];\n\t \n\twhile (sp_len > 1 && sp_model[sp_len - 1] == ' ')\n\t\tsp_len--;\n\n\tsp_model[sp_len] = '\\0';\n\nout:\n\treturn sp_model;\n}\n\nstatic int send_trespass_cmd(struct scsi_device *sdev,\n\t\t\t    struct clariion_dh_data *csdev)\n{\n\tunsigned char *page22;\n\tunsigned char cdb[MAX_COMMAND_SIZE];\n\tint err, res = SCSI_DH_OK, len;\n\tstruct scsi_sense_hdr sshdr;\n\tblk_opf_t opf = REQ_OP_DRV_OUT | REQ_FAILFAST_DEV |\n\t\t\t\tREQ_FAILFAST_TRANSPORT | REQ_FAILFAST_DRIVER;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\n\tif (csdev->flags & CLARIION_SHORT_TRESPASS) {\n\t\tpage22 = short_trespass;\n\t\tif (!(csdev->flags & CLARIION_HONOR_RESERVATIONS))\n\t\t\t \n\t\t\tpage22[6] |= 0x80;\n\t\tlen = sizeof(short_trespass);\n\t\tcdb[0] = MODE_SELECT;\n\t\tcdb[1] = 0x10;\n\t\tcdb[4] = len;\n\t} else {\n\t\tpage22 = long_trespass;\n\t\tif (!(csdev->flags & CLARIION_HONOR_RESERVATIONS))\n\t\t\t \n\t\t\tpage22[10] |= 0x80;\n\t\tlen = sizeof(long_trespass);\n\t\tcdb[0] = MODE_SELECT_10;\n\t\tcdb[8] = len;\n\t}\n\tBUG_ON((len > CLARIION_BUFFER_SIZE));\n\tmemcpy(csdev->buffer, page22, len);\n\n\terr = scsi_execute_cmd(sdev, cdb, opf, csdev->buffer, len,\n\t\t\t       CLARIION_TIMEOUT * HZ, CLARIION_RETRIES,\n\t\t\t       &exec_args);\n\tif (err) {\n\t\tif (scsi_sense_valid(&sshdr))\n\t\t\tres = trespass_endio(sdev, &sshdr);\n\t\telse {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"%s: failed to send MODE SELECT: %x\\n\",\n\t\t\t\t    CLARIION_NAME, err);\n\t\t\tres = SCSI_DH_IO;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic enum scsi_disposition clariion_check_sense(struct scsi_device *sdev,\n\t\t\t\t\tstruct scsi_sense_hdr *sense_hdr)\n{\n\tswitch (sense_hdr->sense_key) {\n\tcase NOT_READY:\n\t\tif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x03)\n\t\t\t \n\t\t\treturn SUCCESS;\n\t\tbreak;\n\tcase ILLEGAL_REQUEST:\n\t\tif (sense_hdr->asc == 0x25 && sense_hdr->ascq == 0x01)\n\t\t\t \n\t\t\treturn SUCCESS;\n\t\tbreak;\n\tcase UNIT_ATTENTION:\n\t\tif (sense_hdr->asc == 0x29 && sense_hdr->ascq == 0x00)\n\t\t\t \n\t\t\treturn ADD_TO_MLQUEUE;\n\t\tbreak;\n\t}\n\n\treturn SCSI_RETURN_NOT_HANDLED;\n}\n\nstatic blk_status_t clariion_prep_fn(struct scsi_device *sdev,\n\t\tstruct request *req)\n{\n\tstruct clariion_dh_data *h = sdev->handler_data;\n\n\tif (h->lun_state != CLARIION_LUN_OWNED) {\n\t\treq->rq_flags |= RQF_QUIET;\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\treturn BLK_STS_OK;\n}\n\nstatic int clariion_std_inquiry(struct scsi_device *sdev,\n\t\t\t\tstruct clariion_dh_data *csdev)\n{\n\tint err = SCSI_DH_OK;\n\tchar *sp_model;\n\n\tsp_model = parse_sp_model(sdev, sdev->inquiry);\n\tif (!sp_model) {\n\t\terr = SCSI_DH_DEV_UNSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!strlen(sp_model) || !strncmp(sp_model, \"FC\",2))\n\t\tcsdev->flags |= CLARIION_SHORT_TRESPASS;\n\n\tsdev_printk(KERN_INFO, sdev,\n\t\t    \"%s: detected Clariion %s, flags %x\\n\",\n\t\t    CLARIION_NAME, sp_model, csdev->flags);\nout:\n\treturn err;\n}\n\nstatic int clariion_send_inquiry(struct scsi_device *sdev,\n\t\t\t\t struct clariion_dh_data *csdev)\n{\n\tint err = SCSI_DH_IO;\n\n\tif (!scsi_get_vpd_page(sdev, 0xC0, csdev->buffer,\n\t\t\t       CLARIION_BUFFER_SIZE))\n\t\terr = parse_sp_info_reply(sdev, csdev);\n\n\treturn err;\n}\n\nstatic int clariion_activate(struct scsi_device *sdev,\n\t\t\t\tactivate_complete fn, void *data)\n{\n\tstruct clariion_dh_data *csdev = sdev->handler_data;\n\tint result;\n\n\tresult = clariion_send_inquiry(sdev, csdev);\n\tif (result != SCSI_DH_OK)\n\t\tgoto done;\n\n\tif (csdev->lun_state == CLARIION_LUN_OWNED)\n\t\tgoto done;\n\n\tresult = send_trespass_cmd(sdev, csdev);\n\tif (result != SCSI_DH_OK)\n\t\tgoto done;\n\tsdev_printk(KERN_INFO, sdev,\"%s: %s trespass command sent\\n\",\n\t\t    CLARIION_NAME,\n\t\t    csdev->flags&CLARIION_SHORT_TRESPASS?\"short\":\"long\" );\n\n\t \n\tresult = clariion_send_inquiry(sdev, csdev);\n\tif (result != SCSI_DH_OK)\n\t\tgoto done;\n\ndone:\n\tsdev_printk(KERN_INFO, sdev,\n\t\t    \"%s: at SP %c Port %d (%s, default SP %c)\\n\",\n\t\t    CLARIION_NAME, csdev->current_sp + 'A',\n\t\t    csdev->port, lun_state[csdev->lun_state],\n\t\t    csdev->default_sp + 'A');\n\n\tif (fn)\n\t\tfn(data, result);\n\treturn 0;\n}\n \nstatic int clariion_set_params(struct scsi_device *sdev, const char *params)\n{\n\tstruct clariion_dh_data *csdev = sdev->handler_data;\n\tunsigned int hr = 0, st = 0, argc;\n\tconst char *p = params;\n\tint result = SCSI_DH_OK;\n\n\tif ((sscanf(params, \"%u\", &argc) != 1) || (argc != 2))\n\t\treturn -EINVAL;\n\n\twhile (*p++)\n\t\t;\n\tif ((sscanf(p, \"%u\", &st) != 1) || (st > 1))\n\t\treturn -EINVAL;\n\n\twhile (*p++)\n\t\t;\n\tif ((sscanf(p, \"%u\", &hr) != 1) || (hr > 1))\n\t\treturn -EINVAL;\n\n\tif (st)\n\t\tcsdev->flags |= CLARIION_SHORT_TRESPASS;\n\telse\n\t\tcsdev->flags &= ~CLARIION_SHORT_TRESPASS;\n\n\tif (hr)\n\t\tcsdev->flags |= CLARIION_HONOR_RESERVATIONS;\n\telse\n\t\tcsdev->flags &= ~CLARIION_HONOR_RESERVATIONS;\n\n\t \n\tif (csdev->lun_state != CLARIION_LUN_OWNED)\n\t\tgoto done;\n\n\tcsdev->lun_state = CLARIION_LUN_UNINITIALIZED;\n\tresult = send_trespass_cmd(sdev, csdev);\n\tif (result != SCSI_DH_OK)\n\t\tgoto done;\n\n\t \n\tresult = clariion_send_inquiry(sdev, csdev);\n\ndone:\n\treturn result;\n}\n\nstatic int clariion_bus_attach(struct scsi_device *sdev)\n{\n\tstruct clariion_dh_data *h;\n\tint err;\n\n\th = kzalloc(sizeof(*h) , GFP_KERNEL);\n\tif (!h)\n\t\treturn SCSI_DH_NOMEM;\n\th->lun_state = CLARIION_LUN_UNINITIALIZED;\n\th->default_sp = CLARIION_UNBOUND_LU;\n\th->current_sp = CLARIION_UNBOUND_LU;\n\n\terr = clariion_std_inquiry(sdev, h);\n\tif (err != SCSI_DH_OK)\n\t\tgoto failed;\n\n\terr = clariion_send_inquiry(sdev, h);\n\tif (err != SCSI_DH_OK)\n\t\tgoto failed;\n\n\tsdev_printk(KERN_INFO, sdev,\n\t\t    \"%s: connected to SP %c Port %d (%s, default SP %c)\\n\",\n\t\t    CLARIION_NAME, h->current_sp + 'A',\n\t\t    h->port, lun_state[h->lun_state],\n\t\t    h->default_sp + 'A');\n\n\tsdev->handler_data = h;\n\treturn SCSI_DH_OK;\n\nfailed:\n\tkfree(h);\n\treturn err;\n}\n\nstatic void clariion_bus_detach(struct scsi_device *sdev)\n{\n\tkfree(sdev->handler_data);\n\tsdev->handler_data = NULL;\n}\n\nstatic struct scsi_device_handler clariion_dh = {\n\t.name\t\t= CLARIION_NAME,\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= clariion_bus_attach,\n\t.detach\t\t= clariion_bus_detach,\n\t.check_sense\t= clariion_check_sense,\n\t.activate\t= clariion_activate,\n\t.prep_fn\t= clariion_prep_fn,\n\t.set_params\t= clariion_set_params,\n};\n\nstatic int __init clariion_init(void)\n{\n\tint r;\n\n\tr = scsi_register_device_handler(&clariion_dh);\n\tif (r != 0)\n\t\tprintk(KERN_ERR \"%s: Failed to register scsi device handler.\",\n\t\t\tCLARIION_NAME);\n\treturn r;\n}\n\nstatic void __exit clariion_exit(void)\n{\n\tscsi_unregister_device_handler(&clariion_dh);\n}\n\nmodule_init(clariion_init);\nmodule_exit(clariion_exit);\n\nMODULE_DESCRIPTION(\"EMC CX/AX/FC-family driver\");\nMODULE_AUTHOR(\"Mike Christie <michaelc@cs.wisc.edu>, Chandra Seetharaman <sekharan@us.ibm.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}