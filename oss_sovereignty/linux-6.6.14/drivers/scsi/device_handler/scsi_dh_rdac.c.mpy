{
  "module_name": "scsi_dh_rdac.c",
  "hash_id": "e7a6b34d01dea23572c688485cf9d3daa16e1b8cb22e6ec23d90f0f36dd0bcb5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/device_handler/scsi_dh_rdac.c",
  "human_readable_source": " \n#include <scsi/scsi.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_dh.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define RDAC_NAME \"rdac\"\n#define RDAC_RETRY_COUNT 5\n\n \n#define RDAC_QUIESCENCE_TIME 20\n \n#define RDAC_PAGE_CODE_REDUNDANT_CONTROLLER 0x2c\n\n \n#define RDAC_MODE_TRANSFER_SPECIFIED_LUNS\t0x02\n\n \n#define RDAC_FORCED_QUIESENCE 0x02\n\n#define RDAC_TIMEOUT\t(60 * HZ)\n#define RDAC_RETRIES\t3\n\nstruct rdac_mode_6_hdr {\n\tu8\tdata_len;\n\tu8\tmedium_type;\n\tu8\tdevice_params;\n\tu8\tblock_desc_len;\n};\n\nstruct rdac_mode_10_hdr {\n\tu16\tdata_len;\n\tu8\tmedium_type;\n\tu8\tdevice_params;\n\tu16\treserved;\n\tu16\tblock_desc_len;\n};\n\nstruct rdac_mode_common {\n\tu8\tcontroller_serial[16];\n\tu8\talt_controller_serial[16];\n\tu8\trdac_mode[2];\n\tu8\talt_rdac_mode[2];\n\tu8\tquiescence_timeout;\n\tu8\trdac_options;\n};\n\nstruct rdac_pg_legacy {\n\tstruct rdac_mode_6_hdr hdr;\n\tu8\tpage_code;\n\tu8\tpage_len;\n\tstruct rdac_mode_common common;\n#define MODE6_MAX_LUN\t32\n\tu8\tlun_table[MODE6_MAX_LUN];\n\tu8\treserved2[32];\n\tu8\treserved3;\n\tu8\treserved4;\n};\n\nstruct rdac_pg_expanded {\n\tstruct rdac_mode_10_hdr hdr;\n\tu8\tpage_code;\n\tu8\tsubpage_code;\n\tu8\tpage_len[2];\n\tstruct rdac_mode_common common;\n\tu8\tlun_table[256];\n\tu8\treserved3;\n\tu8\treserved4;\n};\n\nstruct c9_inquiry {\n\tu8\tperipheral_info;\n\tu8\tpage_code;\t \n\tu8\treserved1;\n\tu8\tpage_len;\n\tu8\tpage_id[4];\t \n\tu8\tavte_cvp;\n\tu8\tpath_prio;\n\tu8\treserved2[38];\n};\n\n#define SUBSYS_ID_LEN\t16\n#define SLOT_ID_LEN\t2\n#define ARRAY_LABEL_LEN\t31\n\nstruct c4_inquiry {\n\tu8\tperipheral_info;\n\tu8\tpage_code;\t \n\tu8\treserved1;\n\tu8\tpage_len;\n\tu8\tpage_id[4];\t \n\tu8\tsubsys_id[SUBSYS_ID_LEN];\n\tu8\trevision[4];\n\tu8\tslot_id[SLOT_ID_LEN];\n\tu8\treserved[2];\n};\n\n#define UNIQUE_ID_LEN 16\nstruct c8_inquiry {\n\tu8\tperipheral_info;\n\tu8\tpage_code;  \n\tu8\treserved1;\n\tu8\tpage_len;\n\tu8\tpage_id[4];  \n\tu8\treserved2[3];\n\tu8\tvol_uniq_id_len;\n\tu8\tvol_uniq_id[16];\n\tu8\tvol_user_label_len;\n\tu8\tvol_user_label[60];\n\tu8\tarray_uniq_id_len;\n\tu8\tarray_unique_id[UNIQUE_ID_LEN];\n\tu8\tarray_user_label_len;\n\tu8\tarray_user_label[60];\n\tu8\tlun[8];\n};\n\nstruct rdac_controller {\n\tu8\t\t\tarray_id[UNIQUE_ID_LEN];\n\tint\t\t\tuse_ms10;\n\tstruct kref\t\tkref;\n\tstruct list_head\tnode;  \n\tunion\t\t\t{\n\t\tstruct rdac_pg_legacy legacy;\n\t\tstruct rdac_pg_expanded expanded;\n\t} mode_select;\n\tu8\tindex;\n\tu8\tarray_name[ARRAY_LABEL_LEN];\n\tstruct Scsi_Host\t*host;\n\tspinlock_t\t\tms_lock;\n\tint\t\t\tms_queued;\n\tstruct work_struct\tms_work;\n\tstruct scsi_device\t*ms_sdev;\n\tstruct list_head\tms_head;\n\tstruct list_head\tdh_list;\n};\n\nstruct c2_inquiry {\n\tu8\tperipheral_info;\n\tu8\tpage_code;\t \n\tu8\treserved1;\n\tu8\tpage_len;\n\tu8\tpage_id[4];\t \n\tu8\tsw_version[3];\n\tu8\tsw_date[3];\n\tu8\tfeatures_enabled;\n\tu8\tmax_lun_supported;\n\tu8\tpartitions[239];  \n};\n\nstruct rdac_dh_data {\n\tstruct list_head\tnode;\n\tstruct rdac_controller\t*ctlr;\n\tstruct scsi_device\t*sdev;\n#define UNINITIALIZED_LUN\t(1 << 8)\n\tunsigned\t\tlun;\n\n#define RDAC_MODE\t\t0\n#define RDAC_MODE_AVT\t\t1\n#define RDAC_MODE_IOSHIP\t2\n\tunsigned char\t\tmode;\n\n#define RDAC_STATE_ACTIVE\t0\n#define RDAC_STATE_PASSIVE\t1\n\tunsigned char\t\tstate;\n\n#define RDAC_LUN_UNOWNED\t0\n#define RDAC_LUN_OWNED\t\t1\n\tchar\t\t\tlun_state;\n\n#define RDAC_PREFERRED\t\t0\n#define RDAC_NON_PREFERRED\t1\n\tchar\t\t\tpreferred;\n\n\tunion\t\t\t{\n\t\tstruct c2_inquiry c2;\n\t\tstruct c4_inquiry c4;\n\t\tstruct c8_inquiry c8;\n\t\tstruct c9_inquiry c9;\n\t} inq;\n};\n\nstatic const char *mode[] = {\n\t\"RDAC\",\n\t\"AVT\",\n\t\"IOSHIP\",\n};\nstatic const char *lun_state[] =\n{\n\t\"unowned\",\n\t\"owned\",\n};\n\nstruct rdac_queue_data {\n\tstruct list_head\tentry;\n\tstruct rdac_dh_data\t*h;\n\tactivate_complete\tcallback_fn;\n\tvoid\t\t\t*callback_data;\n};\n\nstatic LIST_HEAD(ctlr_list);\nstatic DEFINE_SPINLOCK(list_lock);\nstatic struct workqueue_struct *kmpath_rdacd;\nstatic void send_mode_select(struct work_struct *work);\n\n \nstatic int rdac_logging = 1;\nmodule_param(rdac_logging, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(rdac_logging, \"A bit mask of rdac logging levels, \"\n\t\t\"Default is 1 - failover logging enabled, \"\n\t\t\"set it to 0xF to enable all the logs\");\n\n#define RDAC_LOG_FAILOVER\t0\n#define RDAC_LOG_SENSE\t\t2\n\n#define RDAC_LOG_BITS\t\t2\n\n#define RDAC_LOG_LEVEL(SHIFT)  \\\n\t((rdac_logging >> (SHIFT)) & ((1 << (RDAC_LOG_BITS)) - 1))\n\n#define RDAC_LOG(SHIFT, sdev, f, arg...) \\\ndo { \\\n\tif (unlikely(RDAC_LOG_LEVEL(SHIFT))) \\\n\t\tsdev_printk(KERN_INFO, sdev, RDAC_NAME \": \" f \"\\n\", ## arg); \\\n} while (0);\n\nstatic unsigned int rdac_failover_get(struct rdac_controller *ctlr,\n\t\t\t\t      struct list_head *list,\n\t\t\t\t      unsigned char *cdb)\n{\n\tstruct rdac_mode_common *common;\n\tunsigned data_size;\n\tstruct rdac_queue_data *qdata;\n\tu8 *lun_table;\n\n\tif (ctlr->use_ms10) {\n\t\tstruct rdac_pg_expanded *rdac_pg;\n\n\t\tdata_size = sizeof(struct rdac_pg_expanded);\n\t\trdac_pg = &ctlr->mode_select.expanded;\n\t\tmemset(rdac_pg, 0, data_size);\n\t\tcommon = &rdac_pg->common;\n\t\trdac_pg->page_code = RDAC_PAGE_CODE_REDUNDANT_CONTROLLER + 0x40;\n\t\trdac_pg->subpage_code = 0x1;\n\t\trdac_pg->page_len[0] = 0x01;\n\t\trdac_pg->page_len[1] = 0x28;\n\t\tlun_table = rdac_pg->lun_table;\n\t} else {\n\t\tstruct rdac_pg_legacy *rdac_pg;\n\n\t\tdata_size = sizeof(struct rdac_pg_legacy);\n\t\trdac_pg = &ctlr->mode_select.legacy;\n\t\tmemset(rdac_pg, 0, data_size);\n\t\tcommon = &rdac_pg->common;\n\t\trdac_pg->page_code = RDAC_PAGE_CODE_REDUNDANT_CONTROLLER;\n\t\trdac_pg->page_len = 0x68;\n\t\tlun_table = rdac_pg->lun_table;\n\t}\n\tcommon->rdac_mode[1] = RDAC_MODE_TRANSFER_SPECIFIED_LUNS;\n\tcommon->quiescence_timeout = RDAC_QUIESCENCE_TIME;\n\tcommon->rdac_options = RDAC_FORCED_QUIESENCE;\n\n\tlist_for_each_entry(qdata, list, entry) {\n\t\tlun_table[qdata->h->lun] = 0x81;\n\t}\n\n\t \n\tif (ctlr->use_ms10) {\n\t\tcdb[0] = MODE_SELECT_10;\n\t\tcdb[7] = data_size >> 8;\n\t\tcdb[8] = data_size & 0xff;\n\t} else {\n\t\tcdb[0] = MODE_SELECT;\n\t\tcdb[4] = data_size;\n\t}\n\n\treturn data_size;\n}\n\nstatic void release_controller(struct kref *kref)\n{\n\tstruct rdac_controller *ctlr;\n\tctlr = container_of(kref, struct rdac_controller, kref);\n\n\tlist_del(&ctlr->node);\n\tkfree(ctlr);\n}\n\nstatic struct rdac_controller *get_controller(int index, char *array_name,\n\t\t\tu8 *array_id, struct scsi_device *sdev)\n{\n\tstruct rdac_controller *ctlr, *tmp;\n\n\tlist_for_each_entry(tmp, &ctlr_list, node) {\n\t\tif ((memcmp(tmp->array_id, array_id, UNIQUE_ID_LEN) == 0) &&\n\t\t\t  (tmp->index == index) &&\n\t\t\t  (tmp->host == sdev->host)) {\n\t\t\tkref_get(&tmp->kref);\n\t\t\treturn tmp;\n\t\t}\n\t}\n\tctlr = kmalloc(sizeof(*ctlr), GFP_ATOMIC);\n\tif (!ctlr)\n\t\treturn NULL;\n\n\t \n\tmemcpy(ctlr->array_id, array_id, UNIQUE_ID_LEN);\n\tctlr->index = index;\n\tctlr->host = sdev->host;\n\tmemcpy(ctlr->array_name, array_name, ARRAY_LABEL_LEN);\n\n\tkref_init(&ctlr->kref);\n\tctlr->use_ms10 = -1;\n\tctlr->ms_queued = 0;\n\tctlr->ms_sdev = NULL;\n\tspin_lock_init(&ctlr->ms_lock);\n\tINIT_WORK(&ctlr->ms_work, send_mode_select);\n\tINIT_LIST_HEAD(&ctlr->ms_head);\n\tlist_add(&ctlr->node, &ctlr_list);\n\tINIT_LIST_HEAD(&ctlr->dh_list);\n\n\treturn ctlr;\n}\n\nstatic int get_lun_info(struct scsi_device *sdev, struct rdac_dh_data *h,\n\t\t\tchar *array_name, u8 *array_id)\n{\n\tint err = SCSI_DH_IO, i;\n\tstruct c8_inquiry *inqp = &h->inq.c8;\n\n\tif (!scsi_get_vpd_page(sdev, 0xC8, (unsigned char *)inqp,\n\t\t\t       sizeof(struct c8_inquiry))) {\n\t\tif (inqp->page_code != 0xc8)\n\t\t\treturn SCSI_DH_NOSYS;\n\t\tif (inqp->page_id[0] != 'e' || inqp->page_id[1] != 'd' ||\n\t\t    inqp->page_id[2] != 'i' || inqp->page_id[3] != 'd')\n\t\t\treturn SCSI_DH_NOSYS;\n\t\th->lun = inqp->lun[7];  \n\n\t\tfor(i=0; i<ARRAY_LABEL_LEN-1; ++i)\n\t\t\t*(array_name+i) = inqp->array_user_label[(2*i)+1];\n\n\t\t*(array_name+ARRAY_LABEL_LEN-1) = '\\0';\n\t\tmemset(array_id, 0, UNIQUE_ID_LEN);\n\t\tmemcpy(array_id, inqp->array_unique_id, inqp->array_uniq_id_len);\n\t\terr = SCSI_DH_OK;\n\t}\n\treturn err;\n}\n\nstatic int check_ownership(struct scsi_device *sdev, struct rdac_dh_data *h)\n{\n\tint err = SCSI_DH_IO, access_state;\n\tstruct rdac_dh_data *tmp;\n\tstruct c9_inquiry *inqp = &h->inq.c9;\n\n\th->state = RDAC_STATE_ACTIVE;\n\tif (!scsi_get_vpd_page(sdev, 0xC9, (unsigned char *)inqp,\n\t\t\t       sizeof(struct c9_inquiry))) {\n\t\t \n\t\tif ((inqp->avte_cvp >> 5) & 0x1)\n\t\t\th->mode = RDAC_MODE_IOSHIP;  \n\t\telse if (inqp->avte_cvp >> 7)\n\t\t\th->mode = RDAC_MODE_AVT;  \n\t\telse\n\t\t\th->mode = RDAC_MODE;  \n\n\t\t \n\t\tif (inqp->avte_cvp & 0x1) {\n\t\t\th->lun_state = RDAC_LUN_OWNED;\n\t\t\taccess_state = SCSI_ACCESS_STATE_OPTIMAL;\n\t\t} else {\n\t\t\th->lun_state = RDAC_LUN_UNOWNED;\n\t\t\tif (h->mode == RDAC_MODE) {\n\t\t\t\th->state = RDAC_STATE_PASSIVE;\n\t\t\t\taccess_state = SCSI_ACCESS_STATE_STANDBY;\n\t\t\t} else\n\t\t\t\taccess_state = SCSI_ACCESS_STATE_ACTIVE;\n\t\t}\n\n\t\t \n\t\tif (inqp->path_prio & 0x1) {\n\t\t\th->preferred = RDAC_PREFERRED;\n\t\t\taccess_state |= SCSI_ACCESS_STATE_PREFERRED;\n\t\t} else\n\t\t\th->preferred = RDAC_NON_PREFERRED;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &h->ctlr->dh_list, node) {\n\t\t\t \n\t\t\tBUG_ON(!tmp->sdev);\n\t\t\ttmp->sdev->access_state = access_state;\n\t\t}\n\t\trcu_read_unlock();\n\t\terr = SCSI_DH_OK;\n\t}\n\n\treturn err;\n}\n\nstatic int initialize_controller(struct scsi_device *sdev,\n\t\tstruct rdac_dh_data *h, char *array_name, u8 *array_id)\n{\n\tint err = SCSI_DH_IO, index;\n\tstruct c4_inquiry *inqp = &h->inq.c4;\n\n\tif (!scsi_get_vpd_page(sdev, 0xC4, (unsigned char *)inqp,\n\t\t\t       sizeof(struct c4_inquiry))) {\n\t\t \n\t\tif (inqp->slot_id[1] == 0x31)\n\t\t\tindex = 0;\n\t\telse\n\t\t\tindex = 1;\n\n\t\tspin_lock(&list_lock);\n\t\th->ctlr = get_controller(index, array_name, array_id, sdev);\n\t\tif (!h->ctlr)\n\t\t\terr = SCSI_DH_RES_TEMP_UNAVAIL;\n\t\telse {\n\t\t\th->sdev = sdev;\n\t\t\tlist_add_rcu(&h->node, &h->ctlr->dh_list);\n\t\t}\n\t\tspin_unlock(&list_lock);\n\t\terr = SCSI_DH_OK;\n\t}\n\treturn err;\n}\n\nstatic int set_mode_select(struct scsi_device *sdev, struct rdac_dh_data *h)\n{\n\tint err = SCSI_DH_IO;\n\tstruct c2_inquiry *inqp = &h->inq.c2;\n\n\tif (!scsi_get_vpd_page(sdev, 0xC2, (unsigned char *)inqp,\n\t\t\t       sizeof(struct c2_inquiry))) {\n\t\t \n\t\tif (inqp->max_lun_supported >= MODE6_MAX_LUN)\n\t\t\th->ctlr->use_ms10 = 1;\n\t\telse\n\t\t\th->ctlr->use_ms10 = 0;\n\t\terr = SCSI_DH_OK;\n\t}\n\treturn err;\n}\n\nstatic int mode_select_handle_sense(struct scsi_device *sdev,\n\t\t\t\t    struct scsi_sense_hdr *sense_hdr)\n{\n\tint err = SCSI_DH_IO;\n\tstruct rdac_dh_data *h = sdev->handler_data;\n\n\tif (!scsi_sense_valid(sense_hdr))\n\t\tgoto done;\n\n\tswitch (sense_hdr->sense_key) {\n\tcase NO_SENSE:\n\tcase ABORTED_COMMAND:\n\tcase UNIT_ATTENTION:\n\t\terr = SCSI_DH_RETRY;\n\t\tbreak;\n\tcase NOT_READY:\n\t\tif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x01)\n\t\t\t \n\t\t\terr = SCSI_DH_RETRY;\n\t\tbreak;\n\tcase ILLEGAL_REQUEST:\n\t\tif (sense_hdr->asc == 0x91 && sense_hdr->ascq == 0x36)\n\t\t\t \n\t\t\terr = SCSI_DH_IMM_RETRY;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tRDAC_LOG(RDAC_LOG_FAILOVER, sdev, \"array %s, ctlr %d, \"\n\t\t\"MODE_SELECT returned with sense %02x/%02x/%02x\",\n\t\t(char *) h->ctlr->array_name, h->ctlr->index,\n\t\tsense_hdr->sense_key, sense_hdr->asc, sense_hdr->ascq);\n\ndone:\n\treturn err;\n}\n\nstatic void send_mode_select(struct work_struct *work)\n{\n\tstruct rdac_controller *ctlr =\n\t\tcontainer_of(work, struct rdac_controller, ms_work);\n\tstruct scsi_device *sdev = ctlr->ms_sdev;\n\tstruct rdac_dh_data *h = sdev->handler_data;\n\tint err = SCSI_DH_OK, retry_cnt = RDAC_RETRY_COUNT;\n\tstruct rdac_queue_data *tmp, *qdata;\n\tLIST_HEAD(list);\n\tunsigned char cdb[MAX_COMMAND_SIZE];\n\tstruct scsi_sense_hdr sshdr;\n\tunsigned int data_size;\n\tblk_opf_t opf = REQ_OP_DRV_OUT | REQ_FAILFAST_DEV |\n\t\t\t\tREQ_FAILFAST_TRANSPORT | REQ_FAILFAST_DRIVER;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\n\tspin_lock(&ctlr->ms_lock);\n\tlist_splice_init(&ctlr->ms_head, &list);\n\tctlr->ms_queued = 0;\n\tctlr->ms_sdev = NULL;\n\tspin_unlock(&ctlr->ms_lock);\n\n retry:\n\tmemset(cdb, 0, sizeof(cdb));\n\n\tdata_size = rdac_failover_get(ctlr, &list, cdb);\n\n\tRDAC_LOG(RDAC_LOG_FAILOVER, sdev, \"array %s, ctlr %d, \"\n\t\t\"%s MODE_SELECT command\",\n\t\t(char *) h->ctlr->array_name, h->ctlr->index,\n\t\t(retry_cnt == RDAC_RETRY_COUNT) ? \"queueing\" : \"retrying\");\n\n\tif (scsi_execute_cmd(sdev, cdb, opf, &h->ctlr->mode_select, data_size,\n\t\t\t     RDAC_TIMEOUT * HZ, RDAC_RETRIES, &exec_args)) {\n\t\terr = mode_select_handle_sense(sdev, &sshdr);\n\t\tif (err == SCSI_DH_RETRY && retry_cnt--)\n\t\t\tgoto retry;\n\t\tif (err == SCSI_DH_IMM_RETRY)\n\t\t\tgoto retry;\n\t}\n\tif (err == SCSI_DH_OK) {\n\t\th->state = RDAC_STATE_ACTIVE;\n\t\tRDAC_LOG(RDAC_LOG_FAILOVER, sdev, \"array %s, ctlr %d, \"\n\t\t\t\t\"MODE_SELECT completed\",\n\t\t\t\t(char *) h->ctlr->array_name, h->ctlr->index);\n\t}\n\n\tlist_for_each_entry_safe(qdata, tmp, &list, entry) {\n\t\tlist_del(&qdata->entry);\n\t\tif (err == SCSI_DH_OK)\n\t\t\tqdata->h->state = RDAC_STATE_ACTIVE;\n\t\tif (qdata->callback_fn)\n\t\t\tqdata->callback_fn(qdata->callback_data, err);\n\t\tkfree(qdata);\n\t}\n\treturn;\n}\n\nstatic int queue_mode_select(struct scsi_device *sdev,\n\t\t\t\tactivate_complete fn, void *data)\n{\n\tstruct rdac_queue_data *qdata;\n\tstruct rdac_controller *ctlr;\n\n\tqdata = kzalloc(sizeof(*qdata), GFP_KERNEL);\n\tif (!qdata)\n\t\treturn SCSI_DH_RETRY;\n\n\tqdata->h = sdev->handler_data;\n\tqdata->callback_fn = fn;\n\tqdata->callback_data = data;\n\n\tctlr = qdata->h->ctlr;\n\tspin_lock(&ctlr->ms_lock);\n\tlist_add_tail(&qdata->entry, &ctlr->ms_head);\n\tif (!ctlr->ms_queued) {\n\t\tctlr->ms_queued = 1;\n\t\tctlr->ms_sdev = sdev;\n\t\tqueue_work(kmpath_rdacd, &ctlr->ms_work);\n\t}\n\tspin_unlock(&ctlr->ms_lock);\n\treturn SCSI_DH_OK;\n}\n\nstatic int rdac_activate(struct scsi_device *sdev,\n\t\t\tactivate_complete fn, void *data)\n{\n\tstruct rdac_dh_data *h = sdev->handler_data;\n\tint err = SCSI_DH_OK;\n\tint act = 0;\n\n\terr = check_ownership(sdev, h);\n\tif (err != SCSI_DH_OK)\n\t\tgoto done;\n\n\tswitch (h->mode) {\n\tcase RDAC_MODE:\n\t\tif (h->lun_state == RDAC_LUN_UNOWNED)\n\t\t\tact = 1;\n\t\tbreak;\n\tcase RDAC_MODE_IOSHIP:\n\t\tif ((h->lun_state == RDAC_LUN_UNOWNED) &&\n\t\t    (h->preferred == RDAC_PREFERRED))\n\t\t\tact = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (act) {\n\t\terr = queue_mode_select(sdev, fn, data);\n\t\tif (err == SCSI_DH_OK)\n\t\t\treturn 0;\n\t}\ndone:\n\tif (fn)\n\t\tfn(data, err);\n\treturn 0;\n}\n\nstatic blk_status_t rdac_prep_fn(struct scsi_device *sdev, struct request *req)\n{\n\tstruct rdac_dh_data *h = sdev->handler_data;\n\n\tif (h->state != RDAC_STATE_ACTIVE) {\n\t\treq->rq_flags |= RQF_QUIET;\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\treturn BLK_STS_OK;\n}\n\nstatic enum scsi_disposition rdac_check_sense(struct scsi_device *sdev,\n\t\t\t\t\t      struct scsi_sense_hdr *sense_hdr)\n{\n\tstruct rdac_dh_data *h = sdev->handler_data;\n\n\tRDAC_LOG(RDAC_LOG_SENSE, sdev, \"array %s, ctlr %d, \"\n\t\t\t\"I/O returned with sense %02x/%02x/%02x\",\n\t\t\t(char *) h->ctlr->array_name, h->ctlr->index,\n\t\t\tsense_hdr->sense_key, sense_hdr->asc, sense_hdr->ascq);\n\n\tswitch (sense_hdr->sense_key) {\n\tcase NOT_READY:\n\t\tif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x01)\n\t\t\t \n\t\t\treturn ADD_TO_MLQUEUE;\n\t\tif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x81)\n\t\t\t \n\t\t\treturn SUCCESS;\n\t\tif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0xA1)\n\t\t\t \n\t\t\treturn ADD_TO_MLQUEUE;\n\t\tif (sense_hdr->asc == 0xA1  && sense_hdr->ascq == 0x02)\n\t\t\t \n\t\t\treturn ADD_TO_MLQUEUE;\n\t\tbreak;\n\tcase ILLEGAL_REQUEST:\n\t\tif (sense_hdr->asc == 0x94 && sense_hdr->ascq == 0x01) {\n\t\t\t \n\t\t\th->state = RDAC_STATE_PASSIVE;\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tbreak;\n\tcase UNIT_ATTENTION:\n\t\tif (sense_hdr->asc == 0x29 && sense_hdr->ascq == 0x00)\n\t\t\t \n\t\t\treturn ADD_TO_MLQUEUE;\n\t\tif (sense_hdr->asc == 0x8b && sense_hdr->ascq == 0x02)\n\t\t\t \n\t\t\treturn ADD_TO_MLQUEUE;\n\t\tbreak;\n\t}\n\t \n\treturn SCSI_RETURN_NOT_HANDLED;\n}\n\nstatic int rdac_bus_attach(struct scsi_device *sdev)\n{\n\tstruct rdac_dh_data *h;\n\tint err;\n\tchar array_name[ARRAY_LABEL_LEN];\n\tchar array_id[UNIQUE_ID_LEN];\n\n\th = kzalloc(sizeof(*h) , GFP_KERNEL);\n\tif (!h)\n\t\treturn SCSI_DH_NOMEM;\n\th->lun = UNINITIALIZED_LUN;\n\th->state = RDAC_STATE_ACTIVE;\n\n\terr = get_lun_info(sdev, h, array_name, array_id);\n\tif (err != SCSI_DH_OK)\n\t\tgoto failed;\n\n\terr = initialize_controller(sdev, h, array_name, array_id);\n\tif (err != SCSI_DH_OK)\n\t\tgoto failed;\n\n\terr = check_ownership(sdev, h);\n\tif (err != SCSI_DH_OK)\n\t\tgoto clean_ctlr;\n\n\terr = set_mode_select(sdev, h);\n\tif (err != SCSI_DH_OK)\n\t\tgoto clean_ctlr;\n\n\tsdev_printk(KERN_NOTICE, sdev,\n\t\t    \"%s: LUN %d (%s) (%s)\\n\",\n\t\t    RDAC_NAME, h->lun, mode[(int)h->mode],\n\t\t    lun_state[(int)h->lun_state]);\n\n\tsdev->handler_data = h;\n\treturn SCSI_DH_OK;\n\nclean_ctlr:\n\tspin_lock(&list_lock);\n\tkref_put(&h->ctlr->kref, release_controller);\n\tspin_unlock(&list_lock);\n\nfailed:\n\tkfree(h);\n\treturn err;\n}\n\nstatic void rdac_bus_detach( struct scsi_device *sdev )\n{\n\tstruct rdac_dh_data *h = sdev->handler_data;\n\n\tif (h->ctlr && h->ctlr->ms_queued)\n\t\tflush_workqueue(kmpath_rdacd);\n\n\tspin_lock(&list_lock);\n\tif (h->ctlr) {\n\t\tlist_del_rcu(&h->node);\n\t\tkref_put(&h->ctlr->kref, release_controller);\n\t}\n\tspin_unlock(&list_lock);\n\tsdev->handler_data = NULL;\n\tsynchronize_rcu();\n\tkfree(h);\n}\n\nstatic struct scsi_device_handler rdac_dh = {\n\t.name = RDAC_NAME,\n\t.module = THIS_MODULE,\n\t.prep_fn = rdac_prep_fn,\n\t.check_sense = rdac_check_sense,\n\t.attach = rdac_bus_attach,\n\t.detach = rdac_bus_detach,\n\t.activate = rdac_activate,\n};\n\nstatic int __init rdac_init(void)\n{\n\tint r;\n\n\tr = scsi_register_device_handler(&rdac_dh);\n\tif (r != 0) {\n\t\tprintk(KERN_ERR \"Failed to register scsi device handler.\");\n\t\tgoto done;\n\t}\n\n\t \n\tkmpath_rdacd = create_singlethread_workqueue(\"kmpath_rdacd\");\n\tif (!kmpath_rdacd) {\n\t\tscsi_unregister_device_handler(&rdac_dh);\n\t\tprintk(KERN_ERR \"kmpath_rdacd creation failed.\\n\");\n\n\t\tr = -EINVAL;\n\t}\ndone:\n\treturn r;\n}\n\nstatic void __exit rdac_exit(void)\n{\n\tdestroy_workqueue(kmpath_rdacd);\n\tscsi_unregister_device_handler(&rdac_dh);\n}\n\nmodule_init(rdac_init);\nmodule_exit(rdac_exit);\n\nMODULE_DESCRIPTION(\"Multipath LSI/Engenio/NetApp E-Series RDAC driver\");\nMODULE_AUTHOR(\"Mike Christie, Chandra Seetharaman\");\nMODULE_VERSION(\"01.00.0000.0000\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}