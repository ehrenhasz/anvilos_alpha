{
  "module_name": "scsi_dh_hp_sw.c",
  "hash_id": "fac7e6efab15e888ce516ecdba77393e2a8e09b4823868760dedaca7085a6da7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/device_handler/scsi_dh_hp_sw.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_dh.h>\n\n#define HP_SW_NAME\t\t\t\"hp_sw\"\n\n#define HP_SW_TIMEOUT\t\t\t(60 * HZ)\n#define HP_SW_RETRIES\t\t\t3\n\n#define HP_SW_PATH_UNINITIALIZED\t-1\n#define HP_SW_PATH_ACTIVE\t\t0\n#define HP_SW_PATH_PASSIVE\t\t1\n\nstruct hp_sw_dh_data {\n\tint path_state;\n\tint retries;\n\tint retry_cnt;\n\tstruct scsi_device *sdev;\n};\n\nstatic int hp_sw_start_stop(struct hp_sw_dh_data *);\n\n \nstatic int tur_done(struct scsi_device *sdev, struct hp_sw_dh_data *h,\n\t\t    struct scsi_sense_hdr *sshdr)\n{\n\tint ret = SCSI_DH_IO;\n\n\tswitch (sshdr->sense_key) {\n\tcase UNIT_ATTENTION:\n\t\tret = SCSI_DH_IMM_RETRY;\n\t\tbreak;\n\tcase NOT_READY:\n\t\tif (sshdr->asc == 0x04 && sshdr->ascq == 2) {\n\t\t\t \n\t\t\th->path_state = HP_SW_PATH_PASSIVE;\n\t\t\tret = SCSI_DH_OK;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t   \"%s: sending tur failed, sense %x/%x/%x\\n\",\n\t\t\t   HP_SW_NAME, sshdr->sense_key, sshdr->asc,\n\t\t\t   sshdr->ascq);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic int hp_sw_tur(struct scsi_device *sdev, struct hp_sw_dh_data *h)\n{\n\tunsigned char cmd[6] = { TEST_UNIT_READY };\n\tstruct scsi_sense_hdr sshdr;\n\tint ret = SCSI_DH_OK, res;\n\tblk_opf_t opf = REQ_OP_DRV_IN | REQ_FAILFAST_DEV |\n\t\t\t\tREQ_FAILFAST_TRANSPORT | REQ_FAILFAST_DRIVER;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\nretry:\n\tres = scsi_execute_cmd(sdev, cmd, opf, NULL, 0, HP_SW_TIMEOUT,\n\t\t\t       HP_SW_RETRIES, &exec_args);\n\tif (res) {\n\t\tif (scsi_sense_valid(&sshdr))\n\t\t\tret = tur_done(sdev, h, &sshdr);\n\t\telse {\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t    \"%s: sending tur failed with %x\\n\",\n\t\t\t\t    HP_SW_NAME, res);\n\t\t\tret = SCSI_DH_IO;\n\t\t}\n\t} else {\n\t\th->path_state = HP_SW_PATH_ACTIVE;\n\t\tret = SCSI_DH_OK;\n\t}\n\tif (ret == SCSI_DH_IMM_RETRY)\n\t\tgoto retry;\n\n\treturn ret;\n}\n\n \nstatic int hp_sw_start_stop(struct hp_sw_dh_data *h)\n{\n\tunsigned char cmd[6] = { START_STOP, 0, 0, 0, 1, 0 };\n\tstruct scsi_sense_hdr sshdr;\n\tstruct scsi_device *sdev = h->sdev;\n\tint res, rc = SCSI_DH_OK;\n\tint retry_cnt = HP_SW_RETRIES;\n\tblk_opf_t opf = REQ_OP_DRV_IN | REQ_FAILFAST_DEV |\n\t\t\t\tREQ_FAILFAST_TRANSPORT | REQ_FAILFAST_DRIVER;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\nretry:\n\tres = scsi_execute_cmd(sdev, cmd, opf, NULL, 0, HP_SW_TIMEOUT,\n\t\t\t       HP_SW_RETRIES, &exec_args);\n\tif (res) {\n\t\tif (!scsi_sense_valid(&sshdr)) {\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t    \"%s: sending start_stop_unit failed, \"\n\t\t\t\t    \"no sense available\\n\", HP_SW_NAME);\n\t\t\treturn SCSI_DH_IO;\n\t\t}\n\t\tswitch (sshdr.sense_key) {\n\t\tcase NOT_READY:\n\t\t\tif (sshdr.asc == 0x04 && sshdr.ascq == 3) {\n\t\t\t\t \n\t\t\t\tif (--retry_cnt)\n\t\t\t\t\tgoto retry;\n\t\t\t\trc = SCSI_DH_RETRY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t    \"%s: sending start_stop_unit failed, \"\n\t\t\t\t    \"sense %x/%x/%x\\n\", HP_SW_NAME,\n\t\t\t\t    sshdr.sense_key, sshdr.asc, sshdr.ascq);\n\t\t\trc = SCSI_DH_IO;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic blk_status_t hp_sw_prep_fn(struct scsi_device *sdev, struct request *req)\n{\n\tstruct hp_sw_dh_data *h = sdev->handler_data;\n\n\tif (h->path_state != HP_SW_PATH_ACTIVE) {\n\t\treq->rq_flags |= RQF_QUIET;\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\treturn BLK_STS_OK;\n}\n\n \nstatic int hp_sw_activate(struct scsi_device *sdev,\n\t\t\t\tactivate_complete fn, void *data)\n{\n\tint ret = SCSI_DH_OK;\n\tstruct hp_sw_dh_data *h = sdev->handler_data;\n\n\tret = hp_sw_tur(sdev, h);\n\n\tif (ret == SCSI_DH_OK && h->path_state == HP_SW_PATH_PASSIVE)\n\t\tret = hp_sw_start_stop(h);\n\n\tif (fn)\n\t\tfn(data, ret);\n\treturn 0;\n}\n\nstatic int hp_sw_bus_attach(struct scsi_device *sdev)\n{\n\tstruct hp_sw_dh_data *h;\n\tint ret;\n\n\th = kzalloc(sizeof(*h), GFP_KERNEL);\n\tif (!h)\n\t\treturn SCSI_DH_NOMEM;\n\th->path_state = HP_SW_PATH_UNINITIALIZED;\n\th->retries = HP_SW_RETRIES;\n\th->sdev = sdev;\n\n\tret = hp_sw_tur(sdev, h);\n\tif (ret != SCSI_DH_OK)\n\t\tgoto failed;\n\tif (h->path_state == HP_SW_PATH_UNINITIALIZED) {\n\t\tret = SCSI_DH_NOSYS;\n\t\tgoto failed;\n\t}\n\n\tsdev_printk(KERN_INFO, sdev, \"%s: attached to %s path\\n\",\n\t\t    HP_SW_NAME, h->path_state == HP_SW_PATH_ACTIVE?\n\t\t    \"active\":\"passive\");\n\n\tsdev->handler_data = h;\n\treturn SCSI_DH_OK;\nfailed:\n\tkfree(h);\n\treturn ret;\n}\n\nstatic void hp_sw_bus_detach( struct scsi_device *sdev )\n{\n\tkfree(sdev->handler_data);\n\tsdev->handler_data = NULL;\n}\n\nstatic struct scsi_device_handler hp_sw_dh = {\n\t.name\t\t= HP_SW_NAME,\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= hp_sw_bus_attach,\n\t.detach\t\t= hp_sw_bus_detach,\n\t.activate\t= hp_sw_activate,\n\t.prep_fn\t= hp_sw_prep_fn,\n};\n\nstatic int __init hp_sw_init(void)\n{\n\treturn scsi_register_device_handler(&hp_sw_dh);\n}\n\nstatic void __exit hp_sw_exit(void)\n{\n\tscsi_unregister_device_handler(&hp_sw_dh);\n}\n\nmodule_init(hp_sw_init);\nmodule_exit(hp_sw_exit);\n\nMODULE_DESCRIPTION(\"HP Active/Passive driver\");\nMODULE_AUTHOR(\"Mike Christie <michaelc@cs.wisc.edu\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}