{
  "module_name": "scsi_dh_alua.c",
  "hash_id": "ba9fc142ebdc8e28fe9dfa82654101c2b800efe6ea019c9f4372a71dacf73284",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/device_handler/scsi_dh_alua.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <asm/unaligned.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_proto.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_dh.h>\n\n#define ALUA_DH_NAME \"alua\"\n#define ALUA_DH_VER \"2.0\"\n\n#define TPGS_SUPPORT_NONE\t\t0x00\n#define TPGS_SUPPORT_OPTIMIZED\t\t0x01\n#define TPGS_SUPPORT_NONOPTIMIZED\t0x02\n#define TPGS_SUPPORT_STANDBY\t\t0x04\n#define TPGS_SUPPORT_UNAVAILABLE\t0x08\n#define TPGS_SUPPORT_LBA_DEPENDENT\t0x10\n#define TPGS_SUPPORT_OFFLINE\t\t0x40\n#define TPGS_SUPPORT_TRANSITION\t\t0x80\n#define TPGS_SUPPORT_ALL\t\t0xdf\n\n#define RTPG_FMT_MASK\t\t\t0x70\n#define RTPG_FMT_EXT_HDR\t\t0x10\n\n#define TPGS_MODE_UNINITIALIZED\t\t -1\n#define TPGS_MODE_NONE\t\t\t0x0\n#define TPGS_MODE_IMPLICIT\t\t0x1\n#define TPGS_MODE_EXPLICIT\t\t0x2\n\n#define ALUA_RTPG_SIZE\t\t\t128\n#define ALUA_FAILOVER_TIMEOUT\t\t60\n#define ALUA_FAILOVER_RETRIES\t\t5\n#define ALUA_RTPG_DELAY_MSECS\t\t5\n#define ALUA_RTPG_RETRY_DELAY\t\t2\n\n \n#define ALUA_OPTIMIZE_STPG\t\t0x01\n#define ALUA_RTPG_EXT_HDR_UNSUPP\t0x02\n \n#define ALUA_PG_RUN_RTPG\t\t0x10\n#define ALUA_PG_RUN_STPG\t\t0x20\n#define ALUA_PG_RUNNING\t\t\t0x40\n\nstatic uint optimize_stpg;\nmodule_param(optimize_stpg, uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(optimize_stpg, \"Allow use of a non-optimized path, rather than sending a STPG, when implicit TPGS is supported (0=No,1=Yes). Default is 0.\");\n\nstatic LIST_HEAD(port_group_list);\nstatic DEFINE_SPINLOCK(port_group_lock);\nstatic struct workqueue_struct *kaluad_wq;\n\nstruct alua_port_group {\n\tstruct kref\t\tkref;\n\tstruct rcu_head\t\trcu;\n\tstruct list_head\tnode;\n\tstruct list_head\tdh_list;\n\tunsigned char\t\tdevice_id_str[256];\n\tint\t\t\tdevice_id_len;\n\tint\t\t\tgroup_id;\n\tint\t\t\ttpgs;\n\tint\t\t\tstate;\n\tint\t\t\tpref;\n\tint\t\t\tvalid_states;\n\tunsigned\t\tflags;  \n\tunsigned char\t\ttransition_tmo;\n\tunsigned long\t\texpiry;\n\tunsigned long\t\tinterval;\n\tstruct delayed_work\trtpg_work;\n\tspinlock_t\t\tlock;\n\tstruct list_head\trtpg_list;\n\tstruct scsi_device\t*rtpg_sdev;\n};\n\nstruct alua_dh_data {\n\tstruct list_head\tnode;\n\tstruct alua_port_group __rcu *pg;\n\tint\t\t\tgroup_id;\n\tspinlock_t\t\tpg_lock;\n\tstruct scsi_device\t*sdev;\n\tint\t\t\tinit_error;\n\tstruct mutex\t\tinit_mutex;\n\tbool\t\t\tdisabled;\n};\n\nstruct alua_queue_data {\n\tstruct list_head\tentry;\n\tactivate_complete\tcallback_fn;\n\tvoid\t\t\t*callback_data;\n};\n\n#define ALUA_POLICY_SWITCH_CURRENT\t0\n#define ALUA_POLICY_SWITCH_ALL\t\t1\n\nstatic void alua_rtpg_work(struct work_struct *work);\nstatic bool alua_rtpg_queue(struct alua_port_group *pg,\n\t\t\t    struct scsi_device *sdev,\n\t\t\t    struct alua_queue_data *qdata, bool force);\nstatic void alua_check(struct scsi_device *sdev, bool force);\n\nstatic void release_port_group(struct kref *kref)\n{\n\tstruct alua_port_group *pg;\n\n\tpg = container_of(kref, struct alua_port_group, kref);\n\tif (pg->rtpg_sdev)\n\t\tflush_delayed_work(&pg->rtpg_work);\n\tspin_lock(&port_group_lock);\n\tlist_del(&pg->node);\n\tspin_unlock(&port_group_lock);\n\tkfree_rcu(pg, rcu);\n}\n\n \nstatic int submit_rtpg(struct scsi_device *sdev, unsigned char *buff,\n\t\t       int bufflen, struct scsi_sense_hdr *sshdr, int flags)\n{\n\tu8 cdb[MAX_COMMAND_SIZE];\n\tblk_opf_t opf = REQ_OP_DRV_IN | REQ_FAILFAST_DEV |\n\t\t\t\tREQ_FAILFAST_TRANSPORT | REQ_FAILFAST_DRIVER;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = sshdr,\n\t};\n\n\t \n\tmemset(cdb, 0x0, MAX_COMMAND_SIZE);\n\tcdb[0] = MAINTENANCE_IN;\n\tif (!(flags & ALUA_RTPG_EXT_HDR_UNSUPP))\n\t\tcdb[1] = MI_REPORT_TARGET_PGS | MI_EXT_HDR_PARAM_FMT;\n\telse\n\t\tcdb[1] = MI_REPORT_TARGET_PGS;\n\tput_unaligned_be32(bufflen, &cdb[6]);\n\n\treturn scsi_execute_cmd(sdev, cdb, opf, buff, bufflen,\n\t\t\t\tALUA_FAILOVER_TIMEOUT * HZ,\n\t\t\t\tALUA_FAILOVER_RETRIES, &exec_args);\n}\n\n \nstatic int submit_stpg(struct scsi_device *sdev, int group_id,\n\t\t       struct scsi_sense_hdr *sshdr)\n{\n\tu8 cdb[MAX_COMMAND_SIZE];\n\tunsigned char stpg_data[8];\n\tint stpg_len = 8;\n\tblk_opf_t opf = REQ_OP_DRV_OUT | REQ_FAILFAST_DEV |\n\t\t\t\tREQ_FAILFAST_TRANSPORT | REQ_FAILFAST_DRIVER;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = sshdr,\n\t};\n\n\t \n\tmemset(stpg_data, 0, stpg_len);\n\tstpg_data[4] = SCSI_ACCESS_STATE_OPTIMAL;\n\tput_unaligned_be16(group_id, &stpg_data[6]);\n\n\t \n\tmemset(cdb, 0x0, MAX_COMMAND_SIZE);\n\tcdb[0] = MAINTENANCE_OUT;\n\tcdb[1] = MO_SET_TARGET_PGS;\n\tput_unaligned_be32(stpg_len, &cdb[6]);\n\n\treturn scsi_execute_cmd(sdev, cdb, opf, stpg_data,\n\t\t\t\tstpg_len, ALUA_FAILOVER_TIMEOUT * HZ,\n\t\t\t\tALUA_FAILOVER_RETRIES, &exec_args);\n}\n\nstatic struct alua_port_group *alua_find_get_pg(char *id_str, size_t id_size,\n\t\t\t\t\t\tint group_id)\n{\n\tstruct alua_port_group *pg;\n\n\tif (!id_str || !id_size || !strlen(id_str))\n\t\treturn NULL;\n\n\tlist_for_each_entry(pg, &port_group_list, node) {\n\t\tif (pg->group_id != group_id)\n\t\t\tcontinue;\n\t\tif (!pg->device_id_len || pg->device_id_len != id_size)\n\t\t\tcontinue;\n\t\tif (strncmp(pg->device_id_str, id_str, id_size))\n\t\t\tcontinue;\n\t\tif (!kref_get_unless_zero(&pg->kref))\n\t\t\tcontinue;\n\t\treturn pg;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct alua_port_group *alua_alloc_pg(struct scsi_device *sdev,\n\t\t\t\t\t     int group_id, int tpgs)\n{\n\tstruct alua_port_group *pg, *tmp_pg;\n\n\tpg = kzalloc(sizeof(struct alua_port_group), GFP_KERNEL);\n\tif (!pg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpg->device_id_len = scsi_vpd_lun_id(sdev, pg->device_id_str,\n\t\t\t\t\t    sizeof(pg->device_id_str));\n\tif (pg->device_id_len <= 0) {\n\t\t \n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"%s: No device descriptors found\\n\",\n\t\t\t    ALUA_DH_NAME);\n\t\tpg->device_id_str[0] = '\\0';\n\t\tpg->device_id_len = 0;\n\t}\n\tpg->group_id = group_id;\n\tpg->tpgs = tpgs;\n\tpg->state = SCSI_ACCESS_STATE_OPTIMAL;\n\tpg->valid_states = TPGS_SUPPORT_ALL;\n\tif (optimize_stpg)\n\t\tpg->flags |= ALUA_OPTIMIZE_STPG;\n\tkref_init(&pg->kref);\n\tINIT_DELAYED_WORK(&pg->rtpg_work, alua_rtpg_work);\n\tINIT_LIST_HEAD(&pg->rtpg_list);\n\tINIT_LIST_HEAD(&pg->node);\n\tINIT_LIST_HEAD(&pg->dh_list);\n\tspin_lock_init(&pg->lock);\n\n\tspin_lock(&port_group_lock);\n\ttmp_pg = alua_find_get_pg(pg->device_id_str, pg->device_id_len,\n\t\t\t\t  group_id);\n\tif (tmp_pg) {\n\t\tspin_unlock(&port_group_lock);\n\t\tkfree(pg);\n\t\treturn tmp_pg;\n\t}\n\n\tlist_add(&pg->node, &port_group_list);\n\tspin_unlock(&port_group_lock);\n\n\treturn pg;\n}\n\n \nstatic int alua_check_tpgs(struct scsi_device *sdev)\n{\n\tint tpgs = TPGS_MODE_NONE;\n\n\t \n\tif (sdev->type != TYPE_DISK) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"%s: disable for non-disk devices\\n\",\n\t\t\t    ALUA_DH_NAME);\n\t\treturn tpgs;\n\t}\n\n\ttpgs = scsi_device_tpgs(sdev);\n\tswitch (tpgs) {\n\tcase TPGS_MODE_EXPLICIT|TPGS_MODE_IMPLICIT:\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"%s: supports implicit and explicit TPGS\\n\",\n\t\t\t    ALUA_DH_NAME);\n\t\tbreak;\n\tcase TPGS_MODE_EXPLICIT:\n\t\tsdev_printk(KERN_INFO, sdev, \"%s: supports explicit TPGS\\n\",\n\t\t\t    ALUA_DH_NAME);\n\t\tbreak;\n\tcase TPGS_MODE_IMPLICIT:\n\t\tsdev_printk(KERN_INFO, sdev, \"%s: supports implicit TPGS\\n\",\n\t\t\t    ALUA_DH_NAME);\n\t\tbreak;\n\tcase TPGS_MODE_NONE:\n\t\tsdev_printk(KERN_INFO, sdev, \"%s: not supported\\n\",\n\t\t\t    ALUA_DH_NAME);\n\t\tbreak;\n\tdefault:\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"%s: unsupported TPGS setting %d\\n\",\n\t\t\t    ALUA_DH_NAME, tpgs);\n\t\ttpgs = TPGS_MODE_NONE;\n\t\tbreak;\n\t}\n\n\treturn tpgs;\n}\n\n \nstatic int alua_check_vpd(struct scsi_device *sdev, struct alua_dh_data *h,\n\t\t\t  int tpgs)\n{\n\tint rel_port = -1, group_id;\n\tstruct alua_port_group *pg, *old_pg = NULL;\n\tbool pg_updated = false;\n\tunsigned long flags;\n\n\tgroup_id = scsi_vpd_tpg_id(sdev, &rel_port);\n\tif (group_id < 0) {\n\t\t \n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"%s: No target port descriptors found\\n\",\n\t\t\t    ALUA_DH_NAME);\n\t\treturn SCSI_DH_DEV_UNSUPP;\n\t}\n\n\tpg = alua_alloc_pg(sdev, group_id, tpgs);\n\tif (IS_ERR(pg)) {\n\t\tif (PTR_ERR(pg) == -ENOMEM)\n\t\t\treturn SCSI_DH_NOMEM;\n\t\treturn SCSI_DH_DEV_UNSUPP;\n\t}\n\tif (pg->device_id_len)\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"%s: device %s port group %x rel port %x\\n\",\n\t\t\t    ALUA_DH_NAME, pg->device_id_str,\n\t\t\t    group_id, rel_port);\n\telse\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"%s: port group %x rel port %x\\n\",\n\t\t\t    ALUA_DH_NAME, group_id, rel_port);\n\n\tkref_get(&pg->kref);\n\n\t \n\tspin_lock(&h->pg_lock);\n\told_pg = rcu_dereference_protected(h->pg, lockdep_is_held(&h->pg_lock));\n\tif (old_pg != pg) {\n\t\t \n\t\tif (h->pg) {\n\t\t\tspin_lock_irqsave(&old_pg->lock, flags);\n\t\t\tlist_del_rcu(&h->node);\n\t\t\tspin_unlock_irqrestore(&old_pg->lock, flags);\n\t\t}\n\t\trcu_assign_pointer(h->pg, pg);\n\t\tpg_updated = true;\n\t}\n\n\tspin_lock_irqsave(&pg->lock, flags);\n\tif (pg_updated)\n\t\tlist_add_rcu(&h->node, &pg->dh_list);\n\tspin_unlock_irqrestore(&pg->lock, flags);\n\n\tspin_unlock(&h->pg_lock);\n\n\talua_rtpg_queue(pg, sdev, NULL, true);\n\tkref_put(&pg->kref, release_port_group);\n\n\tif (old_pg)\n\t\tkref_put(&old_pg->kref, release_port_group);\n\n\treturn SCSI_DH_OK;\n}\n\nstatic char print_alua_state(unsigned char state)\n{\n\tswitch (state) {\n\tcase SCSI_ACCESS_STATE_OPTIMAL:\n\t\treturn 'A';\n\tcase SCSI_ACCESS_STATE_ACTIVE:\n\t\treturn 'N';\n\tcase SCSI_ACCESS_STATE_STANDBY:\n\t\treturn 'S';\n\tcase SCSI_ACCESS_STATE_UNAVAILABLE:\n\t\treturn 'U';\n\tcase SCSI_ACCESS_STATE_LBA:\n\t\treturn 'L';\n\tcase SCSI_ACCESS_STATE_OFFLINE:\n\t\treturn 'O';\n\tcase SCSI_ACCESS_STATE_TRANSITIONING:\n\t\treturn 'T';\n\tdefault:\n\t\treturn 'X';\n\t}\n}\n\nstatic enum scsi_disposition alua_check_sense(struct scsi_device *sdev,\n\t\t\t\t\t      struct scsi_sense_hdr *sense_hdr)\n{\n\tstruct alua_dh_data *h = sdev->handler_data;\n\tstruct alua_port_group *pg;\n\n\tswitch (sense_hdr->sense_key) {\n\tcase NOT_READY:\n\t\tif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x0a) {\n\t\t\t \n\t\t\trcu_read_lock();\n\t\t\tpg = rcu_dereference(h->pg);\n\t\t\tif (pg)\n\t\t\t\tpg->state = SCSI_ACCESS_STATE_TRANSITIONING;\n\t\t\trcu_read_unlock();\n\t\t\talua_check(sdev, false);\n\t\t\treturn NEEDS_RETRY;\n\t\t}\n\t\tbreak;\n\tcase UNIT_ATTENTION:\n\t\tif (sense_hdr->asc == 0x29 && sense_hdr->ascq == 0x00) {\n\t\t\t \n\t\t\talua_check(sdev, true);\n\t\t\treturn ADD_TO_MLQUEUE;\n\t\t}\n\t\tif (sense_hdr->asc == 0x29 && sense_hdr->ascq == 0x04)\n\t\t\t \n\t\t\treturn ADD_TO_MLQUEUE;\n\t\tif (sense_hdr->asc == 0x2a && sense_hdr->ascq == 0x01)\n\t\t\t \n\t\t\treturn ADD_TO_MLQUEUE;\n\t\tif (sense_hdr->asc == 0x2a && sense_hdr->ascq == 0x06) {\n\t\t\t \n\t\t\talua_check(sdev, true);\n\t\t\treturn ADD_TO_MLQUEUE;\n\t\t}\n\t\tif (sense_hdr->asc == 0x2a && sense_hdr->ascq == 0x07) {\n\t\t\t \n\t\t\talua_check(sdev, true);\n\t\t\treturn ADD_TO_MLQUEUE;\n\t\t}\n\t\tif (sense_hdr->asc == 0x3f && sense_hdr->ascq == 0x03)\n\t\t\t \n\t\t\treturn ADD_TO_MLQUEUE;\n\t\tif (sense_hdr->asc == 0x3f && sense_hdr->ascq == 0x0e)\n\t\t\t \n\t\t\treturn ADD_TO_MLQUEUE;\n\t\tbreak;\n\t}\n\n\treturn SCSI_RETURN_NOT_HANDLED;\n}\n\n \nstatic int alua_tur(struct scsi_device *sdev)\n{\n\tstruct scsi_sense_hdr sense_hdr;\n\tint retval;\n\n\tretval = scsi_test_unit_ready(sdev, ALUA_FAILOVER_TIMEOUT * HZ,\n\t\t\t\t      ALUA_FAILOVER_RETRIES, &sense_hdr);\n\tif (sense_hdr.sense_key == NOT_READY &&\n\t    sense_hdr.asc == 0x04 && sense_hdr.ascq == 0x0a)\n\t\treturn SCSI_DH_RETRY;\n\telse if (retval)\n\t\treturn SCSI_DH_IO;\n\telse\n\t\treturn SCSI_DH_OK;\n}\n\n \nstatic int alua_rtpg(struct scsi_device *sdev, struct alua_port_group *pg)\n{\n\tstruct scsi_sense_hdr sense_hdr;\n\tstruct alua_port_group *tmp_pg;\n\tint len, k, off, bufflen = ALUA_RTPG_SIZE;\n\tint group_id_old, state_old, pref_old, valid_states_old;\n\tunsigned char *desc, *buff;\n\tunsigned err;\n\tint retval;\n\tunsigned int tpg_desc_tbl_off;\n\tunsigned char orig_transition_tmo;\n\tunsigned long flags;\n\tbool transitioning_sense = false;\n\n\tgroup_id_old = pg->group_id;\n\tstate_old = pg->state;\n\tpref_old = pg->pref;\n\tvalid_states_old = pg->valid_states;\n\n\tif (!pg->expiry) {\n\t\tunsigned long transition_tmo = ALUA_FAILOVER_TIMEOUT * HZ;\n\n\t\tif (pg->transition_tmo)\n\t\t\ttransition_tmo = pg->transition_tmo * HZ;\n\n\t\tpg->expiry = round_jiffies_up(jiffies + transition_tmo);\n\t}\n\n\tbuff = kzalloc(bufflen, GFP_KERNEL);\n\tif (!buff)\n\t\treturn SCSI_DH_DEV_TEMP_BUSY;\n\n retry:\n\terr = 0;\n\tretval = submit_rtpg(sdev, buff, bufflen, &sense_hdr, pg->flags);\n\n\tif (retval) {\n\t\t \n\t\tif ((pg->valid_states & ~TPGS_SUPPORT_OPTIMIZED) == 0) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"%s: ignoring rtpg result %d\\n\",\n\t\t\t\t    ALUA_DH_NAME, retval);\n\t\t\tkfree(buff);\n\t\t\treturn SCSI_DH_OK;\n\t\t}\n\t\tif (retval < 0 || !scsi_sense_valid(&sense_hdr)) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"%s: rtpg failed, result %d\\n\",\n\t\t\t\t    ALUA_DH_NAME, retval);\n\t\t\tkfree(buff);\n\t\t\tif (retval < 0)\n\t\t\t\treturn SCSI_DH_DEV_TEMP_BUSY;\n\t\t\tif (host_byte(retval) == DID_NO_CONNECT)\n\t\t\t\treturn SCSI_DH_RES_TEMP_UNAVAIL;\n\t\t\treturn SCSI_DH_IO;\n\t\t}\n\n\t\t \n\t\tif (!(pg->flags & ALUA_RTPG_EXT_HDR_UNSUPP) &&\n\t\t    sense_hdr.sense_key == ILLEGAL_REQUEST) {\n\t\t\tpg->flags |= ALUA_RTPG_EXT_HDR_UNSUPP;\n\t\t\tgoto retry;\n\t\t}\n\t\t \n\t\tif (sense_hdr.sense_key == NOT_READY &&\n\t\t    sense_hdr.asc == 0x04 && sense_hdr.ascq == 0x0a) {\n\t\t\ttransitioning_sense = true;\n\t\t\tgoto skip_rtpg;\n\t\t}\n\t\t \n\t\tif (sense_hdr.sense_key == UNIT_ATTENTION)\n\t\t\terr = SCSI_DH_RETRY;\n\t\tif (err == SCSI_DH_RETRY &&\n\t\t    pg->expiry != 0 && time_before(jiffies, pg->expiry)) {\n\t\t\tsdev_printk(KERN_ERR, sdev, \"%s: rtpg retry\\n\",\n\t\t\t\t    ALUA_DH_NAME);\n\t\t\tscsi_print_sense_hdr(sdev, ALUA_DH_NAME, &sense_hdr);\n\t\t\tkfree(buff);\n\t\t\treturn err;\n\t\t}\n\t\tsdev_printk(KERN_ERR, sdev, \"%s: rtpg failed\\n\",\n\t\t\t    ALUA_DH_NAME);\n\t\tscsi_print_sense_hdr(sdev, ALUA_DH_NAME, &sense_hdr);\n\t\tkfree(buff);\n\t\tpg->expiry = 0;\n\t\treturn SCSI_DH_IO;\n\t}\n\n\tlen = get_unaligned_be32(&buff[0]) + 4;\n\n\tif (len > bufflen) {\n\t\t \n\t\tkfree(buff);\n\t\tbufflen = len;\n\t\tbuff = kmalloc(bufflen, GFP_KERNEL);\n\t\tif (!buff) {\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t    \"%s: kmalloc buffer failed\\n\",__func__);\n\t\t\t \n\t\t\tpg->expiry = 0;\n\t\t\treturn SCSI_DH_DEV_TEMP_BUSY;\n\t\t}\n\t\tgoto retry;\n\t}\n\n\torig_transition_tmo = pg->transition_tmo;\n\tif ((buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR && buff[5] != 0)\n\t\tpg->transition_tmo = buff[5];\n\telse\n\t\tpg->transition_tmo = ALUA_FAILOVER_TIMEOUT;\n\n\tif (orig_transition_tmo != pg->transition_tmo) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"%s: transition timeout set to %d seconds\\n\",\n\t\t\t    ALUA_DH_NAME, pg->transition_tmo);\n\t\tpg->expiry = jiffies + pg->transition_tmo * HZ;\n\t}\n\n\tif ((buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR)\n\t\ttpg_desc_tbl_off = 8;\n\telse\n\t\ttpg_desc_tbl_off = 4;\n\n\tfor (k = tpg_desc_tbl_off, desc = buff + tpg_desc_tbl_off;\n\t     k < len;\n\t     k += off, desc += off) {\n\t\tu16 group_id = get_unaligned_be16(&desc[2]);\n\n\t\tspin_lock_irqsave(&port_group_lock, flags);\n\t\ttmp_pg = alua_find_get_pg(pg->device_id_str, pg->device_id_len,\n\t\t\t\t\t  group_id);\n\t\tspin_unlock_irqrestore(&port_group_lock, flags);\n\t\tif (tmp_pg) {\n\t\t\tif (spin_trylock_irqsave(&tmp_pg->lock, flags)) {\n\t\t\t\tif ((tmp_pg == pg) ||\n\t\t\t\t    !(tmp_pg->flags & ALUA_PG_RUNNING)) {\n\t\t\t\t\tstruct alua_dh_data *h;\n\n\t\t\t\t\ttmp_pg->state = desc[0] & 0x0f;\n\t\t\t\t\ttmp_pg->pref = desc[0] >> 7;\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\tlist_for_each_entry_rcu(h,\n\t\t\t\t\t\t&tmp_pg->dh_list, node) {\n\t\t\t\t\t\tif (!h->sdev)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\th->sdev->access_state = desc[0];\n\t\t\t\t\t}\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t}\n\t\t\t\tif (tmp_pg == pg)\n\t\t\t\t\ttmp_pg->valid_states = desc[1];\n\t\t\t\tspin_unlock_irqrestore(&tmp_pg->lock, flags);\n\t\t\t}\n\t\t\tkref_put(&tmp_pg->kref, release_port_group);\n\t\t}\n\t\toff = 8 + (desc[7] * 4);\n\t}\n\n skip_rtpg:\n\tspin_lock_irqsave(&pg->lock, flags);\n\tif (transitioning_sense)\n\t\tpg->state = SCSI_ACCESS_STATE_TRANSITIONING;\n\n\tif (group_id_old != pg->group_id || state_old != pg->state ||\n\t\tpref_old != pg->pref || valid_states_old != pg->valid_states)\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\"%s: port group %02x state %c %s supports %c%c%c%c%c%c%c\\n\",\n\t\t\tALUA_DH_NAME, pg->group_id, print_alua_state(pg->state),\n\t\t\tpg->pref ? \"preferred\" : \"non-preferred\",\n\t\t\tpg->valid_states&TPGS_SUPPORT_TRANSITION?'T':'t',\n\t\t\tpg->valid_states&TPGS_SUPPORT_OFFLINE?'O':'o',\n\t\t\tpg->valid_states&TPGS_SUPPORT_LBA_DEPENDENT?'L':'l',\n\t\t\tpg->valid_states&TPGS_SUPPORT_UNAVAILABLE?'U':'u',\n\t\t\tpg->valid_states&TPGS_SUPPORT_STANDBY?'S':'s',\n\t\t\tpg->valid_states&TPGS_SUPPORT_NONOPTIMIZED?'N':'n',\n\t\t\tpg->valid_states&TPGS_SUPPORT_OPTIMIZED?'A':'a');\n\n\tswitch (pg->state) {\n\tcase SCSI_ACCESS_STATE_TRANSITIONING:\n\t\tif (time_before(jiffies, pg->expiry)) {\n\t\t\t \n\t\t\tpg->interval = ALUA_RTPG_RETRY_DELAY;\n\t\t\terr = SCSI_DH_RETRY;\n\t\t} else {\n\t\t\tstruct alua_dh_data *h;\n\n\t\t\t \n\t\t\terr = SCSI_DH_IO;\n\t\t\tpg->state = SCSI_ACCESS_STATE_STANDBY;\n\t\t\tpg->expiry = 0;\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(h, &pg->dh_list, node) {\n\t\t\t\tif (!h->sdev)\n\t\t\t\t\tcontinue;\n\t\t\t\th->sdev->access_state =\n\t\t\t\t\t(pg->state & SCSI_ACCESS_STATE_MASK);\n\t\t\t\tif (pg->pref)\n\t\t\t\t\th->sdev->access_state |=\n\t\t\t\t\t\tSCSI_ACCESS_STATE_PREFERRED;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t}\n\t\tbreak;\n\tcase SCSI_ACCESS_STATE_OFFLINE:\n\t\t \n\t\terr = SCSI_DH_DEV_OFFLINED;\n\t\tpg->expiry = 0;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\terr = SCSI_DH_OK;\n\t\tpg->expiry = 0;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&pg->lock, flags);\n\tkfree(buff);\n\treturn err;\n}\n\n \nstatic unsigned alua_stpg(struct scsi_device *sdev, struct alua_port_group *pg)\n{\n\tint retval;\n\tstruct scsi_sense_hdr sense_hdr;\n\n\tif (!(pg->tpgs & TPGS_MODE_EXPLICIT)) {\n\t\t \n\t\treturn SCSI_DH_RETRY;\n\t}\n\tswitch (pg->state) {\n\tcase SCSI_ACCESS_STATE_OPTIMAL:\n\t\treturn SCSI_DH_OK;\n\tcase SCSI_ACCESS_STATE_ACTIVE:\n\t\tif ((pg->flags & ALUA_OPTIMIZE_STPG) &&\n\t\t    !pg->pref &&\n\t\t    (pg->tpgs & TPGS_MODE_IMPLICIT))\n\t\t\treturn SCSI_DH_OK;\n\t\tbreak;\n\tcase SCSI_ACCESS_STATE_STANDBY:\n\tcase SCSI_ACCESS_STATE_UNAVAILABLE:\n\t\tbreak;\n\tcase SCSI_ACCESS_STATE_OFFLINE:\n\t\treturn SCSI_DH_IO;\n\tcase SCSI_ACCESS_STATE_TRANSITIONING:\n\t\tbreak;\n\tdefault:\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"%s: stpg failed, unhandled TPGS state %d\",\n\t\t\t    ALUA_DH_NAME, pg->state);\n\t\treturn SCSI_DH_NOSYS;\n\t}\n\tretval = submit_stpg(sdev, pg->group_id, &sense_hdr);\n\n\tif (retval) {\n\t\tif (retval < 0 || !scsi_sense_valid(&sense_hdr)) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"%s: stpg failed, result %d\",\n\t\t\t\t    ALUA_DH_NAME, retval);\n\t\t\tif (retval < 0)\n\t\t\t\treturn SCSI_DH_DEV_TEMP_BUSY;\n\t\t} else {\n\t\t\tsdev_printk(KERN_INFO, sdev, \"%s: stpg failed\\n\",\n\t\t\t\t    ALUA_DH_NAME);\n\t\t\tscsi_print_sense_hdr(sdev, ALUA_DH_NAME, &sense_hdr);\n\t\t}\n\t}\n\t \n\treturn SCSI_DH_RETRY;\n}\n\n \nstatic struct scsi_device * __must_check\nalua_rtpg_select_sdev(struct alua_port_group *pg)\n{\n\tstruct alua_dh_data *h;\n\tstruct scsi_device *sdev = NULL, *prev_sdev;\n\n\tlockdep_assert_held(&pg->lock);\n\tif (WARN_ON(!pg->rtpg_sdev))\n\t\treturn NULL;\n\n\t \n\trcu_read_lock();\n\tlist_for_each_entry_rcu(h, &pg->dh_list, node) {\n\t\tif (!h->sdev)\n\t\t\tcontinue;\n\t\tif (h->sdev == pg->rtpg_sdev) {\n\t\t\th->disabled = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif (rcu_dereference(h->pg) == pg &&\n\t\t    !h->disabled &&\n\t\t    !scsi_device_get(h->sdev)) {\n\t\t\tsdev = h->sdev;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!sdev) {\n\t\tpr_warn(\"%s: no device found for rtpg\\n\",\n\t\t\t(pg->device_id_len ?\n\t\t\t (char *)pg->device_id_str : \"(nameless PG)\"));\n\t\treturn NULL;\n\t}\n\n\tsdev_printk(KERN_INFO, sdev, \"rtpg retry on different device\\n\");\n\n\tprev_sdev = pg->rtpg_sdev;\n\tpg->rtpg_sdev = sdev;\n\n\treturn prev_sdev;\n}\n\nstatic void alua_rtpg_work(struct work_struct *work)\n{\n\tstruct alua_port_group *pg =\n\t\tcontainer_of(work, struct alua_port_group, rtpg_work.work);\n\tstruct scsi_device *sdev, *prev_sdev = NULL;\n\tLIST_HEAD(qdata_list);\n\tint err = SCSI_DH_OK;\n\tstruct alua_queue_data *qdata, *tmp;\n\tstruct alua_dh_data *h;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pg->lock, flags);\n\tsdev = pg->rtpg_sdev;\n\tif (!sdev) {\n\t\tWARN_ON(pg->flags & ALUA_PG_RUN_RTPG);\n\t\tWARN_ON(pg->flags & ALUA_PG_RUN_STPG);\n\t\tspin_unlock_irqrestore(&pg->lock, flags);\n\t\tkref_put(&pg->kref, release_port_group);\n\t\treturn;\n\t}\n\tpg->flags |= ALUA_PG_RUNNING;\n\tif (pg->flags & ALUA_PG_RUN_RTPG) {\n\t\tint state = pg->state;\n\n\t\tpg->flags &= ~ALUA_PG_RUN_RTPG;\n\t\tspin_unlock_irqrestore(&pg->lock, flags);\n\t\tif (state == SCSI_ACCESS_STATE_TRANSITIONING) {\n\t\t\tif (alua_tur(sdev) == SCSI_DH_RETRY) {\n\t\t\t\tspin_lock_irqsave(&pg->lock, flags);\n\t\t\t\tpg->flags &= ~ALUA_PG_RUNNING;\n\t\t\t\tpg->flags |= ALUA_PG_RUN_RTPG;\n\t\t\t\tif (!pg->interval)\n\t\t\t\t\tpg->interval = ALUA_RTPG_RETRY_DELAY;\n\t\t\t\tspin_unlock_irqrestore(&pg->lock, flags);\n\t\t\t\tqueue_delayed_work(kaluad_wq, &pg->rtpg_work,\n\t\t\t\t\t\t   pg->interval * HZ);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t}\n\t\terr = alua_rtpg(sdev, pg);\n\t\tspin_lock_irqsave(&pg->lock, flags);\n\n\t\t \n\t\tif (err == SCSI_DH_RES_TEMP_UNAVAIL &&\n\t\t    (prev_sdev = alua_rtpg_select_sdev(pg)))\n\t\t\terr = SCSI_DH_IMM_RETRY;\n\n\t\tif (err == SCSI_DH_RETRY || err == SCSI_DH_IMM_RETRY ||\n\t\t    pg->flags & ALUA_PG_RUN_RTPG) {\n\t\t\tpg->flags &= ~ALUA_PG_RUNNING;\n\t\t\tif (err == SCSI_DH_IMM_RETRY)\n\t\t\t\tpg->interval = 0;\n\t\t\telse if (!pg->interval && !(pg->flags & ALUA_PG_RUN_RTPG))\n\t\t\t\tpg->interval = ALUA_RTPG_RETRY_DELAY;\n\t\t\tpg->flags |= ALUA_PG_RUN_RTPG;\n\t\t\tspin_unlock_irqrestore(&pg->lock, flags);\n\t\t\tgoto queue_rtpg;\n\t\t}\n\t\tif (err != SCSI_DH_OK)\n\t\t\tpg->flags &= ~ALUA_PG_RUN_STPG;\n\t}\n\tif (pg->flags & ALUA_PG_RUN_STPG) {\n\t\tpg->flags &= ~ALUA_PG_RUN_STPG;\n\t\tspin_unlock_irqrestore(&pg->lock, flags);\n\t\terr = alua_stpg(sdev, pg);\n\t\tspin_lock_irqsave(&pg->lock, flags);\n\t\tif (err == SCSI_DH_RETRY || pg->flags & ALUA_PG_RUN_RTPG) {\n\t\t\tpg->flags |= ALUA_PG_RUN_RTPG;\n\t\t\tpg->interval = 0;\n\t\t\tpg->flags &= ~ALUA_PG_RUNNING;\n\t\t\tspin_unlock_irqrestore(&pg->lock, flags);\n\t\t\tgoto queue_rtpg;\n\t\t}\n\t}\n\n\tlist_splice_init(&pg->rtpg_list, &qdata_list);\n\t \n\tlist_for_each_entry(h, &pg->dh_list, node)\n\t\th->disabled = false;\n\tpg->rtpg_sdev = NULL;\n\tspin_unlock_irqrestore(&pg->lock, flags);\n\n\tif (prev_sdev)\n\t\tscsi_device_put(prev_sdev);\n\n\tlist_for_each_entry_safe(qdata, tmp, &qdata_list, entry) {\n\t\tlist_del(&qdata->entry);\n\t\tif (qdata->callback_fn)\n\t\t\tqdata->callback_fn(qdata->callback_data, err);\n\t\tkfree(qdata);\n\t}\n\tspin_lock_irqsave(&pg->lock, flags);\n\tpg->flags &= ~ALUA_PG_RUNNING;\n\tspin_unlock_irqrestore(&pg->lock, flags);\n\tscsi_device_put(sdev);\n\tkref_put(&pg->kref, release_port_group);\n\treturn;\n\nqueue_rtpg:\n\tif (prev_sdev)\n\t\tscsi_device_put(prev_sdev);\n\tqueue_delayed_work(kaluad_wq, &pg->rtpg_work, pg->interval * HZ);\n}\n\n \nstatic bool alua_rtpg_queue(struct alua_port_group *pg,\n\t\t\t    struct scsi_device *sdev,\n\t\t\t    struct alua_queue_data *qdata, bool force)\n{\n\tint start_queue = 0;\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(!pg) || scsi_device_get(sdev))\n\t\treturn false;\n\n\tspin_lock_irqsave(&pg->lock, flags);\n\tif (qdata) {\n\t\tlist_add_tail(&qdata->entry, &pg->rtpg_list);\n\t\tpg->flags |= ALUA_PG_RUN_STPG;\n\t\tforce = true;\n\t}\n\tif (pg->rtpg_sdev == NULL) {\n\t\tstruct alua_dh_data *h = sdev->handler_data;\n\n\t\trcu_read_lock();\n\t\tif (h && rcu_dereference(h->pg) == pg) {\n\t\t\tpg->interval = 0;\n\t\t\tpg->flags |= ALUA_PG_RUN_RTPG;\n\t\t\tkref_get(&pg->kref);\n\t\t\tpg->rtpg_sdev = sdev;\n\t\t\tstart_queue = 1;\n\t\t}\n\t\trcu_read_unlock();\n\t} else if (!(pg->flags & ALUA_PG_RUN_RTPG) && force) {\n\t\tpg->flags |= ALUA_PG_RUN_RTPG;\n\t\t \n\t\tif (!(pg->flags & ALUA_PG_RUNNING)) {\n\t\t\tkref_get(&pg->kref);\n\t\t\tstart_queue = 1;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pg->lock, flags);\n\n\tif (start_queue) {\n\t\tif (queue_delayed_work(kaluad_wq, &pg->rtpg_work,\n\t\t\t\tmsecs_to_jiffies(ALUA_RTPG_DELAY_MSECS)))\n\t\t\tsdev = NULL;\n\t\telse\n\t\t\tkref_put(&pg->kref, release_port_group);\n\t}\n\tif (sdev)\n\t\tscsi_device_put(sdev);\n\n\treturn true;\n}\n\n \nstatic int alua_initialize(struct scsi_device *sdev, struct alua_dh_data *h)\n{\n\tint err = SCSI_DH_DEV_UNSUPP, tpgs;\n\n\tmutex_lock(&h->init_mutex);\n\th->disabled = false;\n\ttpgs = alua_check_tpgs(sdev);\n\tif (tpgs != TPGS_MODE_NONE)\n\t\terr = alua_check_vpd(sdev, h, tpgs);\n\th->init_error = err;\n\tmutex_unlock(&h->init_mutex);\n\treturn err;\n}\n \nstatic int alua_set_params(struct scsi_device *sdev, const char *params)\n{\n\tstruct alua_dh_data *h = sdev->handler_data;\n\tstruct alua_port_group *pg = NULL;\n\tunsigned int optimize = 0, argc;\n\tconst char *p = params;\n\tint result = SCSI_DH_OK;\n\tunsigned long flags;\n\n\tif ((sscanf(params, \"%u\", &argc) != 1) || (argc != 1))\n\t\treturn -EINVAL;\n\n\twhile (*p++)\n\t\t;\n\tif ((sscanf(p, \"%u\", &optimize) != 1) || (optimize > 1))\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tpg = rcu_dereference(h->pg);\n\tif (!pg) {\n\t\trcu_read_unlock();\n\t\treturn -ENXIO;\n\t}\n\tspin_lock_irqsave(&pg->lock, flags);\n\tif (optimize)\n\t\tpg->flags |= ALUA_OPTIMIZE_STPG;\n\telse\n\t\tpg->flags &= ~ALUA_OPTIMIZE_STPG;\n\tspin_unlock_irqrestore(&pg->lock, flags);\n\trcu_read_unlock();\n\n\treturn result;\n}\n\n \nstatic int alua_activate(struct scsi_device *sdev,\n\t\t\tactivate_complete fn, void *data)\n{\n\tstruct alua_dh_data *h = sdev->handler_data;\n\tint err = SCSI_DH_OK;\n\tstruct alua_queue_data *qdata;\n\tstruct alua_port_group *pg;\n\n\tqdata = kzalloc(sizeof(*qdata), GFP_KERNEL);\n\tif (!qdata) {\n\t\terr = SCSI_DH_RES_TEMP_UNAVAIL;\n\t\tgoto out;\n\t}\n\tqdata->callback_fn = fn;\n\tqdata->callback_data = data;\n\n\tmutex_lock(&h->init_mutex);\n\trcu_read_lock();\n\tpg = rcu_dereference(h->pg);\n\tif (!pg || !kref_get_unless_zero(&pg->kref)) {\n\t\trcu_read_unlock();\n\t\tkfree(qdata);\n\t\terr = h->init_error;\n\t\tmutex_unlock(&h->init_mutex);\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n\tmutex_unlock(&h->init_mutex);\n\n\tif (alua_rtpg_queue(pg, sdev, qdata, true)) {\n\t\tfn = NULL;\n\t} else {\n\t\tkfree(qdata);\n\t\terr = SCSI_DH_DEV_OFFLINED;\n\t}\n\tkref_put(&pg->kref, release_port_group);\nout:\n\tif (fn)\n\t\tfn(data, err);\n\treturn 0;\n}\n\n \nstatic void alua_check(struct scsi_device *sdev, bool force)\n{\n\tstruct alua_dh_data *h = sdev->handler_data;\n\tstruct alua_port_group *pg;\n\n\trcu_read_lock();\n\tpg = rcu_dereference(h->pg);\n\tif (!pg || !kref_get_unless_zero(&pg->kref)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\talua_rtpg_queue(pg, sdev, NULL, force);\n\tkref_put(&pg->kref, release_port_group);\n}\n\n \nstatic blk_status_t alua_prep_fn(struct scsi_device *sdev, struct request *req)\n{\n\tstruct alua_dh_data *h = sdev->handler_data;\n\tstruct alua_port_group *pg;\n\tunsigned char state = SCSI_ACCESS_STATE_OPTIMAL;\n\n\trcu_read_lock();\n\tpg = rcu_dereference(h->pg);\n\tif (pg)\n\t\tstate = pg->state;\n\trcu_read_unlock();\n\n\tswitch (state) {\n\tcase SCSI_ACCESS_STATE_OPTIMAL:\n\tcase SCSI_ACCESS_STATE_ACTIVE:\n\tcase SCSI_ACCESS_STATE_LBA:\n\tcase SCSI_ACCESS_STATE_TRANSITIONING:\n\t\treturn BLK_STS_OK;\n\tdefault:\n\t\treq->rq_flags |= RQF_QUIET;\n\t\treturn BLK_STS_IOERR;\n\t}\n}\n\nstatic void alua_rescan(struct scsi_device *sdev)\n{\n\tstruct alua_dh_data *h = sdev->handler_data;\n\n\talua_initialize(sdev, h);\n}\n\n \nstatic int alua_bus_attach(struct scsi_device *sdev)\n{\n\tstruct alua_dh_data *h;\n\tint err;\n\n\th = kzalloc(sizeof(*h) , GFP_KERNEL);\n\tif (!h)\n\t\treturn SCSI_DH_NOMEM;\n\tspin_lock_init(&h->pg_lock);\n\trcu_assign_pointer(h->pg, NULL);\n\th->init_error = SCSI_DH_OK;\n\th->sdev = sdev;\n\tINIT_LIST_HEAD(&h->node);\n\n\tmutex_init(&h->init_mutex);\n\terr = alua_initialize(sdev, h);\n\tif (err != SCSI_DH_OK && err != SCSI_DH_DEV_OFFLINED)\n\t\tgoto failed;\n\n\tsdev->handler_data = h;\n\treturn SCSI_DH_OK;\nfailed:\n\tkfree(h);\n\treturn err;\n}\n\n \nstatic void alua_bus_detach(struct scsi_device *sdev)\n{\n\tstruct alua_dh_data *h = sdev->handler_data;\n\tstruct alua_port_group *pg;\n\n\tspin_lock(&h->pg_lock);\n\tpg = rcu_dereference_protected(h->pg, lockdep_is_held(&h->pg_lock));\n\trcu_assign_pointer(h->pg, NULL);\n\tspin_unlock(&h->pg_lock);\n\tif (pg) {\n\t\tspin_lock_irq(&pg->lock);\n\t\tlist_del_rcu(&h->node);\n\t\tspin_unlock_irq(&pg->lock);\n\t\tkref_put(&pg->kref, release_port_group);\n\t}\n\tsdev->handler_data = NULL;\n\tsynchronize_rcu();\n\tkfree(h);\n}\n\nstatic struct scsi_device_handler alua_dh = {\n\t.name = ALUA_DH_NAME,\n\t.module = THIS_MODULE,\n\t.attach = alua_bus_attach,\n\t.detach = alua_bus_detach,\n\t.prep_fn = alua_prep_fn,\n\t.check_sense = alua_check_sense,\n\t.activate = alua_activate,\n\t.rescan = alua_rescan,\n\t.set_params = alua_set_params,\n};\n\nstatic int __init alua_init(void)\n{\n\tint r;\n\n\tkaluad_wq = alloc_workqueue(\"kaluad\", WQ_MEM_RECLAIM, 0);\n\tif (!kaluad_wq)\n\t\treturn -ENOMEM;\n\n\tr = scsi_register_device_handler(&alua_dh);\n\tif (r != 0) {\n\t\tprintk(KERN_ERR \"%s: Failed to register scsi device handler\",\n\t\t\tALUA_DH_NAME);\n\t\tdestroy_workqueue(kaluad_wq);\n\t}\n\treturn r;\n}\n\nstatic void __exit alua_exit(void)\n{\n\tscsi_unregister_device_handler(&alua_dh);\n\tdestroy_workqueue(kaluad_wq);\n}\n\nmodule_init(alua_init);\nmodule_exit(alua_exit);\n\nMODULE_DESCRIPTION(\"DM Multipath ALUA support\");\nMODULE_AUTHOR(\"Hannes Reinecke <hare@suse.de>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(ALUA_DH_VER);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}