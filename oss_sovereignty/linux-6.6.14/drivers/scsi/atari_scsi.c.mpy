{
  "module_name": "atari_scsi.c",
  "hash_id": "2c1cc5f854ff9c4157a49940a4aec7cc42125515ff473c6a5d4292b50a2dd646",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/atari_scsi.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/blkdev.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/bitops.h>\n#include <linux/wait.h>\n#include <linux/platform_device.h>\n\n#include <asm/setup.h>\n#include <asm/atarihw.h>\n#include <asm/atariints.h>\n#include <asm/atari_stdma.h>\n#include <asm/atari_stram.h>\n#include <asm/io.h>\n\n#include <scsi/scsi_host.h>\n\n#define DMA_MIN_SIZE                    32\n\n \n\n#define NCR5380_implementation_fields    \n\nstatic u8 (*atari_scsi_reg_read)(unsigned int);\nstatic void (*atari_scsi_reg_write)(unsigned int, u8);\n\n#define NCR5380_read(reg)               atari_scsi_reg_read(reg)\n#define NCR5380_write(reg, value)       atari_scsi_reg_write(reg, value)\n\n#define NCR5380_queue_command           atari_scsi_queue_command\n#define NCR5380_abort                   atari_scsi_abort\n#define NCR5380_info                    atari_scsi_info\n\n#define NCR5380_dma_xfer_len            atari_scsi_dma_xfer_len\n#define NCR5380_dma_recv_setup          atari_scsi_dma_recv_setup\n#define NCR5380_dma_send_setup          atari_scsi_dma_send_setup\n#define NCR5380_dma_residual            atari_scsi_dma_residual\n\n#define NCR5380_acquire_dma_irq(instance)      falcon_get_lock(instance)\n#define NCR5380_release_dma_irq(instance)      falcon_release_lock()\n\n#include \"NCR5380.h\"\n\n\n#define\tIS_A_TT()\tATARIHW_PRESENT(TT_SCSI)\n\n#define\tSCSI_DMA_WRITE_P(elt,val)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tunsigned long v = val;\t\t\t\t\\\n\t\ttt_scsi_dma.elt##_lo = v & 0xff;\t\t\\\n\t\tv >>= 8;\t\t\t\t\t\\\n\t\ttt_scsi_dma.elt##_lmd = v & 0xff;\t\t\\\n\t\tv >>= 8;\t\t\t\t\t\\\n\t\ttt_scsi_dma.elt##_hmd = v & 0xff;\t\t\\\n\t\tv >>= 8;\t\t\t\t\t\\\n\t\ttt_scsi_dma.elt##_hi = v & 0xff;\t\t\\\n\t} while(0)\n\n#define\tSCSI_DMA_READ_P(elt)\t\t\t\t\t\\\n\t(((((((unsigned long)tt_scsi_dma.elt##_hi << 8) |\t\\\n\t     (unsigned long)tt_scsi_dma.elt##_hmd) << 8) |\t\\\n\t   (unsigned long)tt_scsi_dma.elt##_lmd) << 8) |\t\\\n\t (unsigned long)tt_scsi_dma.elt##_lo)\n\n\nstatic inline void SCSI_DMA_SETADR(unsigned long adr)\n{\n\tst_dma.dma_lo = (unsigned char)adr;\n\tMFPDELAY();\n\tadr >>= 8;\n\tst_dma.dma_md = (unsigned char)adr;\n\tMFPDELAY();\n\tadr >>= 8;\n\tst_dma.dma_hi = (unsigned char)adr;\n\tMFPDELAY();\n}\n\nstatic inline unsigned long SCSI_DMA_GETADR(void)\n{\n\tunsigned long adr;\n\tadr = st_dma.dma_lo;\n\tMFPDELAY();\n\tadr |= (st_dma.dma_md & 0xff) << 8;\n\tMFPDELAY();\n\tadr |= (st_dma.dma_hi & 0xff) << 16;\n\tMFPDELAY();\n\treturn adr;\n}\n\nstatic void atari_scsi_fetch_restbytes(void);\n\nstatic unsigned long\tatari_dma_residual, atari_dma_startaddr;\nstatic short\t\tatari_dma_active;\n \nstatic char\t\t*atari_dma_buffer;\n \nstatic unsigned long\tatari_dma_phys_buffer;\n \nstatic char\t\t*atari_dma_orig_addr;\n \n#define\tSTRAM_BUFFER_SIZE\t(4096)\n \nstatic unsigned long\tatari_dma_stram_mask;\n#define STRAM_ADDR(a)\t(((a) & atari_dma_stram_mask) == 0)\n\nstatic int setup_can_queue = -1;\nmodule_param(setup_can_queue, int, 0);\nstatic int setup_cmd_per_lun = -1;\nmodule_param(setup_cmd_per_lun, int, 0);\nstatic int setup_sg_tablesize = -1;\nmodule_param(setup_sg_tablesize, int, 0);\nstatic int setup_hostid = -1;\nmodule_param(setup_hostid, int, 0);\nstatic int setup_toshiba_delay = -1;\nmodule_param(setup_toshiba_delay, int, 0);\n\n\nstatic int scsi_dma_is_ignored_buserr(unsigned char dma_stat)\n{\n\tint i;\n\tunsigned long addr = SCSI_DMA_READ_P(dma_addr), end_addr;\n\n\tif (dma_stat & 0x01) {\n\n\t\t \n\n\t\tfor (i = 0; i < m68k_num_memory; ++i) {\n\t\t\tend_addr = m68k_memory[i].addr + m68k_memory[i].size;\n\t\t\tif (end_addr <= addr && addr <= end_addr + 4)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nstatic irqreturn_t scsi_tt_intr(int irq, void *dev)\n{\n\tstruct Scsi_Host *instance = dev;\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tint dma_stat;\n\n\tdma_stat = tt_scsi_dma.dma_ctrl;\n\n\tdsprintk(NDEBUG_INTR, instance, \"NCR5380 interrupt, DMA status = %02x\\n\",\n\t         dma_stat & 0xff);\n\n\t \n\tif (dma_stat & 0x80) {\n\t\tif (!scsi_dma_is_ignored_buserr(dma_stat)) {\n\t\t\tprintk(KERN_ERR \"SCSI DMA caused bus error near 0x%08lx\\n\",\n\t\t\t       SCSI_DMA_READ_P(dma_addr));\n\t\t\tprintk(KERN_CRIT \"SCSI DMA bus error -- bad DMA programming!\");\n\t\t}\n\t}\n\n\t \n\tif ((dma_stat & 0x02) && !(dma_stat & 0x40)) {\n\t\tatari_dma_residual = hostdata->dma_len -\n\t\t\t(SCSI_DMA_READ_P(dma_addr) - atari_dma_startaddr);\n\n\t\tdprintk(NDEBUG_DMA, \"SCSI DMA: There are %ld residual bytes.\\n\",\n\t\t\t   atari_dma_residual);\n\n\t\tif ((signed int)atari_dma_residual < 0)\n\t\t\tatari_dma_residual = 0;\n\t\tif ((dma_stat & 1) == 0) {\n\t\t\t \n\t\t\tatari_scsi_fetch_restbytes();\n\t\t} else {\n\t\t\t \n\t\t\tif (atari_dma_residual & 0x1ff) {\n\t\t\t\tdprintk(NDEBUG_DMA, \"SCSI DMA: DMA bug corrected, \"\n\t\t\t\t\t   \"difference %ld bytes\\n\",\n\t\t\t\t\t   512 - (atari_dma_residual & 0x1ff));\n\t\t\t\tatari_dma_residual = (atari_dma_residual + 511) & ~0x1ff;\n\t\t\t}\n\t\t}\n\t\ttt_scsi_dma.dma_ctrl = 0;\n\t}\n\n\t \n\tif (dma_stat & 0x40) {\n\t\tatari_dma_residual = 0;\n\t\tif ((dma_stat & 1) == 0)\n\t\t\tatari_scsi_fetch_restbytes();\n\t\ttt_scsi_dma.dma_ctrl = 0;\n\t}\n\n\tNCR5380_intr(irq, dev);\n\n\treturn IRQ_HANDLED;\n}\n\n\nstatic irqreturn_t scsi_falcon_intr(int irq, void *dev)\n{\n\tstruct Scsi_Host *instance = dev;\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tint dma_stat;\n\n\t \n\tst_dma.dma_mode_status = 0x90;\n\tdma_stat = st_dma.dma_mode_status;\n\n\t \n\tif (!(dma_stat & 0x01)) {\n\t\t \n\t\tprintk(KERN_CRIT \"SCSI DMA error near 0x%08lx!\\n\", SCSI_DMA_GETADR());\n\t}\n\n\t \n\tif (atari_dma_active && (dma_stat & 0x02)) {\n\t\tunsigned long transferred;\n\n\t\ttransferred = SCSI_DMA_GETADR() - atari_dma_startaddr;\n\t\t \n\t\tif (transferred & 15)\n\t\t\tprintk(KERN_ERR \"SCSI DMA error: %ld bytes lost in \"\n\t\t\t       \"ST-DMA fifo\\n\", transferred & 15);\n\n\t\tatari_dma_residual = hostdata->dma_len - transferred;\n\t\tdprintk(NDEBUG_DMA, \"SCSI DMA: There are %ld residual bytes.\\n\",\n\t\t\t   atari_dma_residual);\n\t} else\n\t\tatari_dma_residual = 0;\n\tatari_dma_active = 0;\n\n\tif (atari_dma_orig_addr) {\n\t\t \n\t\tmemcpy(atari_dma_orig_addr, phys_to_virt(atari_dma_startaddr),\n\t\t       hostdata->dma_len - atari_dma_residual);\n\t\tatari_dma_orig_addr = NULL;\n\t}\n\n\tNCR5380_intr(irq, dev);\n\n\treturn IRQ_HANDLED;\n}\n\n\nstatic void atari_scsi_fetch_restbytes(void)\n{\n\tint nr;\n\tchar *src, *dst;\n\tunsigned long phys_dst;\n\n\t \n\tphys_dst = SCSI_DMA_READ_P(dma_addr);\n\tnr = phys_dst & 3;\n\tif (nr) {\n\t\t \n\t\tphys_dst ^= nr;\n\t\tdprintk(NDEBUG_DMA, \"SCSI DMA: there are %d rest bytes for phys addr 0x%08lx\",\n\t\t\t   nr, phys_dst);\n\t\t \n\t\tdst = phys_to_virt(phys_dst);\n\t\tdprintk(NDEBUG_DMA, \" = virt addr %p\\n\", dst);\n\t\tfor (src = (char *)&tt_scsi_dma.dma_restdata; nr != 0; --nr)\n\t\t\t*dst++ = *src++;\n\t}\n}\n\n\n \n\nstatic void falcon_release_lock(void)\n{\n\tif (IS_A_TT())\n\t\treturn;\n\n\tif (stdma_is_locked_by(scsi_falcon_intr))\n\t\tstdma_release();\n}\n\n \n\nstatic int falcon_get_lock(struct Scsi_Host *instance)\n{\n\tif (IS_A_TT())\n\t\treturn 1;\n\n\tif (stdma_is_locked_by(scsi_falcon_intr))\n\t\treturn 1;\n\n\t \n\treturn stdma_try_lock(scsi_falcon_intr, instance);\n}\n\n#ifndef MODULE\nstatic int __init atari_scsi_setup(char *str)\n{\n\t \n\tint ints[8];\n\n\tget_options(str, ARRAY_SIZE(ints), ints);\n\n\tif (ints[0] < 1) {\n\t\tprintk(\"atari_scsi_setup: no arguments!\\n\");\n\t\treturn 0;\n\t}\n\tif (ints[0] >= 1)\n\t\tsetup_can_queue = ints[1];\n\tif (ints[0] >= 2)\n\t\tsetup_cmd_per_lun = ints[2];\n\tif (ints[0] >= 3)\n\t\tsetup_sg_tablesize = ints[3];\n\tif (ints[0] >= 4)\n\t\tsetup_hostid = ints[4];\n\t \n\t \n\tif (ints[0] >= 7)\n\t\tsetup_toshiba_delay = ints[7];\n\n\treturn 1;\n}\n\n__setup(\"atascsi=\", atari_scsi_setup);\n#endif  \n\nstatic unsigned long atari_scsi_dma_setup(struct NCR5380_hostdata *hostdata,\n\t\t\t\t\t  void *data, unsigned long count,\n\t\t\t\t\t  int dir)\n{\n\tunsigned long addr = virt_to_phys(data);\n\n\tdprintk(NDEBUG_DMA, \"scsi%d: setting up dma, data = %p, phys = %lx, count = %ld, dir = %d\\n\",\n\t        hostdata->host->host_no, data, addr, count, dir);\n\n\tif (!IS_A_TT() && !STRAM_ADDR(addr)) {\n\t\t \n\t\tif (dir)\n\t\t\tmemcpy(atari_dma_buffer, data, count);\n\t\telse\n\t\t\tatari_dma_orig_addr = data;\n\t\taddr = atari_dma_phys_buffer;\n\t}\n\n\tatari_dma_startaddr = addr;\t \n\n\t \n\tdma_cache_maintenance(addr, count, dir);\n\n\tif (IS_A_TT()) {\n\t\ttt_scsi_dma.dma_ctrl = dir;\n\t\tSCSI_DMA_WRITE_P(dma_addr, addr);\n\t\tSCSI_DMA_WRITE_P(dma_cnt, count);\n\t\ttt_scsi_dma.dma_ctrl = dir | 2;\n\t} else {  \n\n\t\t \n\t\tSCSI_DMA_SETADR(addr);\n\n\t\t \n\t\tdir <<= 8;\n\t\tst_dma.dma_mode_status = 0x90 | dir;\n\t\tst_dma.dma_mode_status = 0x90 | (dir ^ 0x100);\n\t\tst_dma.dma_mode_status = 0x90 | dir;\n\t\tudelay(40);\n\t\t \n\t\tst_dma.fdc_acces_seccount = (count + (dir ? 511 : 0)) >> 9;\n\t\tudelay(40);\n\t\tst_dma.dma_mode_status = 0x10 | dir;\n\t\tudelay(40);\n\t\t \n\t\tatari_dma_active = 1;\n\t}\n\n\treturn count;\n}\n\nstatic inline int atari_scsi_dma_recv_setup(struct NCR5380_hostdata *hostdata,\n                                            unsigned char *data, int count)\n{\n\treturn atari_scsi_dma_setup(hostdata, data, count, 0);\n}\n\nstatic inline int atari_scsi_dma_send_setup(struct NCR5380_hostdata *hostdata,\n                                            unsigned char *data, int count)\n{\n\treturn atari_scsi_dma_setup(hostdata, data, count, 1);\n}\n\nstatic int atari_scsi_dma_residual(struct NCR5380_hostdata *hostdata)\n{\n\treturn atari_dma_residual;\n}\n\n\n#define\tCMD_SURELY_BLOCK_MODE\t0\n#define\tCMD_SURELY_BYTE_MODE\t1\n#define\tCMD_MODE_UNKNOWN\t\t2\n\nstatic int falcon_classify_cmd(struct scsi_cmnd *cmd)\n{\n\tunsigned char opcode = cmd->cmnd[0];\n\n\tif (opcode == READ_DEFECT_DATA || opcode == READ_LONG ||\n\t    opcode == READ_BUFFER)\n\t\treturn CMD_SURELY_BYTE_MODE;\n\telse if (opcode == READ_6 || opcode == READ_10 ||\n\t\t opcode == 0xa8   || opcode == READ_REVERSE ||\n\t\t opcode == RECOVER_BUFFERED_DATA) {\n\t\t \n\t\tif (cmd->device->type == TYPE_TAPE && !(cmd->cmnd[1] & 1))\n\t\t\treturn CMD_SURELY_BYTE_MODE;\n\t\telse\n\t\t\treturn CMD_SURELY_BLOCK_MODE;\n\t} else\n\t\treturn CMD_MODE_UNKNOWN;\n}\n\n\n \n\nstatic int atari_scsi_dma_xfer_len(struct NCR5380_hostdata *hostdata,\n                                   struct scsi_cmnd *cmd)\n{\n\tint wanted_len = NCR5380_to_ncmd(cmd)->this_residual;\n\tint possible_len, limit;\n\n\tif (wanted_len < DMA_MIN_SIZE)\n\t\treturn 0;\n\n\tif (IS_A_TT())\n\t\t \n\t\treturn wanted_len;\n\n\t \n\n\tif (cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\t \n\t\tpossible_len = wanted_len;\n\t} else {\n\t\t \n\t\tif (wanted_len & 0x1ff)\n\t\t\tpossible_len = 0;\n\t\telse {\n\t\t\t \n\t\t\tswitch (falcon_classify_cmd(cmd)) {\n\t\t\tcase CMD_SURELY_BLOCK_MODE:\n\t\t\t\tpossible_len = wanted_len;\n\t\t\t\tbreak;\n\t\t\tcase CMD_SURELY_BYTE_MODE:\n\t\t\t\tpossible_len = 0;  \n\t\t\t\tbreak;\n\t\t\tcase CMD_MODE_UNKNOWN:\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tpossible_len = (wanted_len < 1024) ? 0 : wanted_len;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tlimit = (atari_dma_buffer && !STRAM_ADDR(virt_to_phys(NCR5380_to_ncmd(cmd)->ptr))) ?\n\t\t    STRAM_BUFFER_SIZE : 255*512;\n\tif (possible_len > limit)\n\t\tpossible_len = limit;\n\n\tif (possible_len != wanted_len)\n\t\tdprintk(NDEBUG_DMA, \"DMA transfer now %d bytes instead of %d\\n\",\n\t\t        possible_len, wanted_len);\n\n\treturn possible_len;\n}\n\n\n \n\nstatic u8 atari_scsi_tt_reg_read(unsigned int reg)\n{\n\treturn tt_scsi_regp[reg * 2];\n}\n\nstatic void atari_scsi_tt_reg_write(unsigned int reg, u8 value)\n{\n\ttt_scsi_regp[reg * 2] = value;\n}\n\nstatic u8 atari_scsi_falcon_reg_read(unsigned int reg)\n{\n\tunsigned long flags;\n\tu8 result;\n\n\treg += 0x88;\n\tlocal_irq_save(flags);\n\tdma_wd.dma_mode_status = (u_short)reg;\n\tresult = (u8)dma_wd.fdc_acces_seccount;\n\tlocal_irq_restore(flags);\n\treturn result;\n}\n\nstatic void atari_scsi_falcon_reg_write(unsigned int reg, u8 value)\n{\n\tunsigned long flags;\n\n\treg += 0x88;\n\tlocal_irq_save(flags);\n\tdma_wd.dma_mode_status = (u_short)reg;\n\tdma_wd.fdc_acces_seccount = (u_short)value;\n\tlocal_irq_restore(flags);\n}\n\n\n#include \"NCR5380.c\"\n\nstatic int atari_scsi_host_reset(struct scsi_cmnd *cmd)\n{\n\tint rv;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\t \n\tif (IS_A_TT()) {\n\t\ttt_scsi_dma.dma_ctrl = 0;\n\t} else {\n\t\tif (stdma_is_locked_by(scsi_falcon_intr))\n\t\t\tst_dma.dma_mode_status = 0x90;\n\t\tatari_dma_active = 0;\n\t\tatari_dma_orig_addr = NULL;\n\t}\n\n\trv = NCR5380_host_reset(cmd);\n\n\t \n\n\tlocal_irq_restore(flags);\n\n\treturn rv;\n}\n\n#define DRV_MODULE_NAME         \"atari_scsi\"\n#define PFX                     DRV_MODULE_NAME \": \"\n\nstatic struct scsi_host_template atari_scsi_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.proc_name\t\t= DRV_MODULE_NAME,\n\t.name\t\t\t= \"Atari native SCSI\",\n\t.info\t\t\t= atari_scsi_info,\n\t.queuecommand\t\t= atari_scsi_queue_command,\n\t.eh_abort_handler\t= atari_scsi_abort,\n\t.eh_host_reset_handler\t= atari_scsi_host_reset,\n\t.this_id\t\t= 7,\n\t.cmd_per_lun\t\t= 2,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n\t.cmd_size\t\t= sizeof(struct NCR5380_cmd),\n};\n\nstatic int __init atari_scsi_probe(struct platform_device *pdev)\n{\n\tstruct Scsi_Host *instance;\n\tint error;\n\tstruct resource *irq;\n\tint host_flags = 0;\n\n\tirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (!irq)\n\t\treturn -ENODEV;\n\n\tif (ATARIHW_PRESENT(TT_SCSI)) {\n\t\tatari_scsi_reg_read  = atari_scsi_tt_reg_read;\n\t\tatari_scsi_reg_write = atari_scsi_tt_reg_write;\n\t} else {\n\t\tatari_scsi_reg_read  = atari_scsi_falcon_reg_read;\n\t\tatari_scsi_reg_write = atari_scsi_falcon_reg_write;\n\t}\n\n\tif (ATARIHW_PRESENT(TT_SCSI)) {\n\t\tatari_scsi_template.can_queue    = 16;\n\t\tatari_scsi_template.sg_tablesize = SG_ALL;\n\t} else {\n\t\tatari_scsi_template.can_queue    = 1;\n\t\tatari_scsi_template.sg_tablesize = 1;\n\t}\n\n\tif (setup_can_queue > 0)\n\t\tatari_scsi_template.can_queue = setup_can_queue;\n\n\tif (setup_cmd_per_lun > 0)\n\t\tatari_scsi_template.cmd_per_lun = setup_cmd_per_lun;\n\n\t \n\tif (ATARIHW_PRESENT(TT_SCSI) && setup_sg_tablesize > 0)\n\t\tatari_scsi_template.sg_tablesize = setup_sg_tablesize;\n\n\tif (setup_hostid >= 0) {\n\t\tatari_scsi_template.this_id = setup_hostid & 7;\n\t} else if (IS_REACHABLE(CONFIG_NVRAM)) {\n\t\t \n\t\tif (ATARIHW_PRESENT(TT_CLK)) {\n\t\t\tunsigned char b;\n\t\t\tloff_t offset = 16;\n\t\t\tssize_t count = nvram_read(&b, 1, &offset);\n\n\t\t\t \n\t\t\tif ((count == 1) && (b & 0x80))\n\t\t\t\tatari_scsi_template.this_id = b & 7;\n\t\t}\n\t}\n\n\t \n\tif (ATARIHW_PRESENT(ST_SCSI) && !ATARIHW_PRESENT(EXTD_DMA) &&\n\t    m68k_realnum_memory > 1) {\n\t\tatari_dma_buffer = atari_stram_alloc(STRAM_BUFFER_SIZE, \"SCSI\");\n\t\tif (!atari_dma_buffer) {\n\t\t\tpr_err(PFX \"can't allocate ST-RAM double buffer\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tatari_dma_phys_buffer = atari_stram_to_phys(atari_dma_buffer);\n\t\tatari_dma_orig_addr = NULL;\n\t}\n\n\tinstance = scsi_host_alloc(&atari_scsi_template,\n\t                           sizeof(struct NCR5380_hostdata));\n\tif (!instance) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_alloc;\n\t}\n\n\tinstance->irq = irq->start;\n\n\thost_flags |= IS_A_TT() ? 0 : FLAG_LATE_DMA_SETUP;\n\thost_flags |= setup_toshiba_delay > 0 ? FLAG_TOSHIBA_DELAY : 0;\n\n\terror = NCR5380_init(instance, host_flags);\n\tif (error)\n\t\tgoto fail_init;\n\n\tif (IS_A_TT()) {\n\t\terror = request_irq(instance->irq, scsi_tt_intr, 0,\n\t\t                    \"NCR5380\", instance);\n\t\tif (error) {\n\t\t\tpr_err(PFX \"request irq %d failed, aborting\\n\",\n\t\t\t       instance->irq);\n\t\t\tgoto fail_irq;\n\t\t}\n\t\ttt_mfp.active_edge |= 0x80;\t \n\n\t\ttt_scsi_dma.dma_ctrl = 0;\n\t\tatari_dma_residual = 0;\n\n\t\t \n\t\tif (MACH_IS_MEDUSA) {\n\t\t\tstruct NCR5380_hostdata *hostdata =\n\t\t\t\tshost_priv(instance);\n\n\t\t\thostdata->read_overruns = 4;\n\t\t}\n\t} else {\n\t\t \n\t\tatari_dma_residual = 0;\n\t\tatari_dma_active = 0;\n\t\tatari_dma_stram_mask = (ATARIHW_PRESENT(EXTD_DMA) ? 0x00000000\n\t\t\t\t\t: 0xff000000);\n\t}\n\n\tNCR5380_maybe_reset_bus(instance);\n\n\terror = scsi_add_host(instance, NULL);\n\tif (error)\n\t\tgoto fail_host;\n\n\tplatform_set_drvdata(pdev, instance);\n\n\tscsi_scan_host(instance);\n\treturn 0;\n\nfail_host:\n\tif (IS_A_TT())\n\t\tfree_irq(instance->irq, instance);\nfail_irq:\n\tNCR5380_exit(instance);\nfail_init:\n\tscsi_host_put(instance);\nfail_alloc:\n\tif (atari_dma_buffer)\n\t\tatari_stram_free(atari_dma_buffer);\n\treturn error;\n}\n\nstatic int __exit atari_scsi_remove(struct platform_device *pdev)\n{\n\tstruct Scsi_Host *instance = platform_get_drvdata(pdev);\n\n\tscsi_remove_host(instance);\n\tif (IS_A_TT())\n\t\tfree_irq(instance->irq, instance);\n\tNCR5380_exit(instance);\n\tscsi_host_put(instance);\n\tif (atari_dma_buffer)\n\t\tatari_stram_free(atari_dma_buffer);\n\treturn 0;\n}\n\nstatic struct platform_driver atari_scsi_driver = {\n\t.remove = __exit_p(atari_scsi_remove),\n\t.driver = {\n\t\t.name\t= DRV_MODULE_NAME,\n\t},\n};\n\nmodule_platform_driver_probe(atari_scsi_driver, atari_scsi_probe);\n\nMODULE_ALIAS(\"platform:\" DRV_MODULE_NAME);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}