{
  "module_name": "atp870u.c",
  "hash_id": "f98192212969c32c467eb578bd66e0288d13ba5469e1918e228778d477d91a9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/atp870u.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n\n#include \"atp870u.h\"\n\nstatic const struct scsi_host_template atp870u_template;\nstatic void send_s870(struct atp_unit *dev,unsigned char c);\nstatic void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip,\n\t\t   unsigned char lvdmode);\n\nstatic inline void atp_writeb_base(struct atp_unit *atp, u8 reg, u8 val)\n{\n\toutb(val, atp->baseport + reg);\n}\n\nstatic inline void atp_writew_base(struct atp_unit *atp, u8 reg, u16 val)\n{\n\toutw(val, atp->baseport + reg);\n}\n\nstatic inline void atp_writeb_io(struct atp_unit *atp, u8 channel, u8 reg, u8 val)\n{\n\toutb(val, atp->ioport[channel] + reg);\n}\n\nstatic inline void atp_writew_io(struct atp_unit *atp, u8 channel, u8 reg, u16 val)\n{\n\toutw(val, atp->ioport[channel] + reg);\n}\n\nstatic inline void atp_writeb_pci(struct atp_unit *atp, u8 channel, u8 reg, u8 val)\n{\n\toutb(val, atp->pciport[channel] + reg);\n}\n\nstatic inline void atp_writel_pci(struct atp_unit *atp, u8 channel, u8 reg, u32 val)\n{\n\toutl(val, atp->pciport[channel] + reg);\n}\n\nstatic inline u8 atp_readb_base(struct atp_unit *atp, u8 reg)\n{\n\treturn inb(atp->baseport + reg);\n}\n\nstatic inline u16 atp_readw_base(struct atp_unit *atp, u8 reg)\n{\n\treturn inw(atp->baseport + reg);\n}\n\nstatic inline u32 atp_readl_base(struct atp_unit *atp, u8 reg)\n{\n\treturn inl(atp->baseport + reg);\n}\n\nstatic inline u8 atp_readb_io(struct atp_unit *atp, u8 channel, u8 reg)\n{\n\treturn inb(atp->ioport[channel] + reg);\n}\n\nstatic inline u16 atp_readw_io(struct atp_unit *atp, u8 channel, u8 reg)\n{\n\treturn inw(atp->ioport[channel] + reg);\n}\n\nstatic inline u8 atp_readb_pci(struct atp_unit *atp, u8 channel, u8 reg)\n{\n\treturn inb(atp->pciport[channel] + reg);\n}\n\nstatic inline bool is880(struct atp_unit *atp)\n{\n\treturn atp->pdev->device == ATP880_DEVID1 ||\n\t       atp->pdev->device == ATP880_DEVID2;\n}\n\nstatic inline bool is885(struct atp_unit *atp)\n{\n\treturn atp->pdev->device == ATP885_DEVID;\n}\n\nstatic irqreturn_t atp870u_intr_handle(int irq, void *dev_id)\n{\n\tunsigned long flags;\n\tunsigned short int id;\n\tunsigned char i, j, c, target_id, lun,cmdp;\n\tunsigned char *prd;\n\tstruct scsi_cmnd *workreq;\n\tunsigned long adrcnt, k;\n#ifdef ED_DBGP\n\tunsigned long l;\n#endif\n\tstruct Scsi_Host *host = dev_id;\n\tstruct atp_unit *dev = (struct atp_unit *)&host->hostdata;\n\n\tfor (c = 0; c < 2; c++) {\n\t\tj = atp_readb_io(dev, c, 0x1f);\n\t\tif ((j & 0x80) != 0)\n\t\t\tbreak;\n\t\tdev->in_int[c] = 0;\n\t}\n\tif ((j & 0x80) == 0)\n\t\treturn IRQ_NONE;\n#ifdef ED_DBGP\n\tprintk(\"atp870u_intr_handle enter\\n\");\n#endif\n\tdev->in_int[c] = 1;\n\tcmdp = atp_readb_io(dev, c, 0x10);\n\tif (dev->working[c] != 0) {\n\t\tif (is885(dev)) {\n\t\t\tif ((atp_readb_io(dev, c, 0x16) & 0x80) == 0)\n\t\t\t\tatp_writeb_io(dev, c, 0x16,\n\t\t\t\t\t      (atp_readb_io(dev, c, 0x16) | 0x80));\n\t\t}\n\t\tif ((atp_readb_pci(dev, c, 0x00) & 0x08) != 0)\n\t\t{\n\t\t\tfor (k=0; k < 1000; k++) {\n\t\t\t\tif ((atp_readb_pci(dev, c, 2) & 0x08) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif ((atp_readb_pci(dev, c, 2) & 0x01) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tatp_writeb_pci(dev, c, 0, 0x00);\n\n\t\ti = atp_readb_io(dev, c, 0x17);\n\n\t\tif (is885(dev))\n\t\t\tatp_writeb_pci(dev, c, 2, 0x06);\n\n\t\ttarget_id = atp_readb_io(dev, c, 0x15);\n\n\t\t \n\n\t\tif ((target_id & 0x40) != 0) {\n\t\t\ttarget_id = (target_id & 0x07) | 0x08;\n\t\t} else {\n\t\t\ttarget_id &= 0x07;\n\t\t}\n\n\t\tif ((j & 0x40) != 0) {\n\t\t     if (dev->last_cmd[c] == 0xff) {\n\t\t\tdev->last_cmd[c] = target_id;\n\t\t     }\n\t\t     dev->last_cmd[c] |= 0x40;\n\t\t}\n\t\tif (is885(dev))\n\t\t\tdev->r1f[c][target_id] |= j;\n#ifdef ED_DBGP\n\t\tprintk(\"atp870u_intr_handle status = %x\\n\",i);\n#endif\n\t\tif (i == 0x85) {\n\t\t\tif ((dev->last_cmd[c] & 0xf0) != 0x40) {\n\t\t\t   dev->last_cmd[c] = 0xff;\n\t\t\t}\n\t\t\tif (is885(dev)) {\n\t\t\t\tadrcnt = 0;\n\t\t\t\t((unsigned char *) &adrcnt)[2] =\n\t\t\t\t\tatp_readb_io(dev, c, 0x12);\n\t\t\t\t((unsigned char *) &adrcnt)[1] =\n\t\t\t\t\tatp_readb_io(dev, c, 0x13);\n\t\t\t\t((unsigned char *) &adrcnt)[0] =\n\t\t\t\t\tatp_readb_io(dev, c, 0x14);\n\t\t\t\tif (dev->id[c][target_id].last_len != adrcnt) {\n\t\t\t\t\tk = dev->id[c][target_id].last_len;\n\t\t\t\t\tk -= adrcnt;\n\t\t\t\t\tdev->id[c][target_id].tran_len = k;\n\t\t\t\t\tdev->id[c][target_id].last_len = adrcnt;\n\t\t\t\t}\n#ifdef ED_DBGP\n\t\t\t\tprintk(\"dev->id[c][target_id].last_len = %d \"\n\t\t\t\t       \"dev->id[c][target_id].tran_len = %d\\n\",\n\t\t\t\t       dev->id[c][target_id].last_len,\n\t\t\t\t       dev->id[c][target_id].tran_len);\n#endif\n\t\t\t}\n\n\t\t\t \n\t\t\tif (dev->wide_id[c] != 0) {\n\t\t\t\tatp_writeb_io(dev, c, 0x1b, 0x01);\n\t\t\t\twhile ((atp_readb_io(dev, c, 0x1b) & 0x01) != 0x01)\n\t\t\t\t\tatp_writeb_io(dev, c, 0x1b, 0x01);\n\t\t\t}\n\t\t\t \n\t\t\tspin_lock_irqsave(dev->host->host_lock, flags);\n\t\t\tif (((dev->quhd[c] != dev->quend[c]) ||\n\t\t\t     (dev->last_cmd[c] != 0xff)) &&\n\t\t\t    (dev->in_snd[c] == 0)) {\n#ifdef ED_DBGP\n\t\t\t\tprintk(\"Call sent_s870\\n\");\n#endif\n\t\t\t\tsend_s870(dev,c);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(dev->host->host_lock, flags);\n\t\t\t \n\t\t\tdev->in_int[c] = 0;\n#ifdef ED_DBGP\n\t\t\t\tprintk(\"Status 0x85 return\\n\");\n#endif\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tif (i == 0x40) {\n\t\t     dev->last_cmd[c] |= 0x40;\n\t\t     dev->in_int[c] = 0;\n\t\t     return IRQ_HANDLED;\n\t\t}\n\n\t\tif (i == 0x21) {\n\t\t\tif ((dev->last_cmd[c] & 0xf0) != 0x40) {\n\t\t\t   dev->last_cmd[c] = 0xff;\n\t\t\t}\n\t\t\tadrcnt = 0;\n\t\t\t((unsigned char *) &adrcnt)[2] =\n\t\t\t\tatp_readb_io(dev, c, 0x12);\n\t\t\t((unsigned char *) &adrcnt)[1] =\n\t\t\t\tatp_readb_io(dev, c, 0x13);\n\t\t\t((unsigned char *) &adrcnt)[0] =\n\t\t\t\tatp_readb_io(dev, c, 0x14);\n\t\t\tk = dev->id[c][target_id].last_len;\n\t\t\tk -= adrcnt;\n\t\t\tdev->id[c][target_id].tran_len = k;\n\t\t\tdev->id[c][target_id].last_len = adrcnt;\n\t\t\tatp_writeb_io(dev, c, 0x10, 0x41);\n\t\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\t\t\tdev->in_int[c] = 0;\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tif (is885(dev)) {\n\t\t\tif ((i == 0x4c) || (i == 0x4d) || (i == 0x8c) || (i == 0x8d)) {\n\t\t\t\tif ((i == 0x4c) || (i == 0x8c))\n\t\t\t\t\ti=0x48;\n\t\t\t\telse\n\t\t\t\t\ti=0x49;\n\t\t\t}\n\t\t}\n\t\tif ((i == 0x80) || (i == 0x8f)) {\n#ifdef ED_DBGP\n\t\t\tprintk(KERN_DEBUG \"Device reselect\\n\");\n#endif\n\t\t\tlun = 0;\n\t\t\tif (cmdp == 0x44 || i == 0x80)\n\t\t\t\tlun = atp_readb_io(dev, c, 0x1d) & 0x07;\n\t\t\telse {\n\t\t\t\tif ((dev->last_cmd[c] & 0xf0) != 0x40) {\n\t\t\t\t   dev->last_cmd[c] = 0xff;\n\t\t\t\t}\n\t\t\t\tif (cmdp == 0x41) {\n#ifdef ED_DBGP\n\t\t\t\t\tprintk(\"cmdp = 0x41\\n\");\n#endif\n\t\t\t\t\tadrcnt = 0;\n\t\t\t\t\t((unsigned char *) &adrcnt)[2] =\n\t\t\t\t\t\tatp_readb_io(dev, c, 0x12);\n\t\t\t\t\t((unsigned char *) &adrcnt)[1] =\n\t\t\t\t\t\tatp_readb_io(dev, c, 0x13);\n\t\t\t\t\t((unsigned char *) &adrcnt)[0] =\n\t\t\t\t\t\tatp_readb_io(dev, c, 0x14);\n\t\t\t\t\tk = dev->id[c][target_id].last_len;\n\t\t\t\t\tk -= adrcnt;\n\t\t\t\t\tdev->id[c][target_id].tran_len = k;\n\t\t\t\t\tdev->id[c][target_id].last_len = adrcnt;\n\t\t\t\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\t\t\t\t\tdev->in_int[c] = 0;\n\t\t\t\t\treturn IRQ_HANDLED;\n\t\t\t\t} else {\n#ifdef ED_DBGP\n\t\t\t\t\tprintk(\"cmdp != 0x41\\n\");\n#endif\n\t\t\t\t\tatp_writeb_io(dev, c, 0x10, 0x46);\n\t\t\t\t\tdev->id[c][target_id].dirct = 0x00;\n\t\t\t\t\tatp_writeb_io(dev, c, 0x12, 0x00);\n\t\t\t\t\tatp_writeb_io(dev, c, 0x13, 0x00);\n\t\t\t\t\tatp_writeb_io(dev, c, 0x14, 0x00);\n\t\t\t\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\t\t\t\t\tdev->in_int[c] = 0;\n\t\t\t\t\treturn IRQ_HANDLED;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dev->last_cmd[c] != 0xff) {\n\t\t\t   dev->last_cmd[c] |= 0x40;\n\t\t\t}\n\t\t\tif (is885(dev)) {\n\t\t\t\tj = atp_readb_base(dev, 0x29) & 0xfe;\n\t\t\t\tatp_writeb_base(dev, 0x29, j);\n\t\t\t} else\n\t\t\t\tatp_writeb_io(dev, c, 0x10, 0x45);\n\n\t\t\ttarget_id = atp_readb_io(dev, c, 0x16);\n\t\t\t \n\t\t\tif ((target_id & 0x10) != 0) {\n\t\t\t\ttarget_id = (target_id & 0x07) | 0x08;\n\t\t\t} else {\n\t\t\t\ttarget_id &= 0x07;\n\t\t\t}\n\t\t\tif (is885(dev))\n\t\t\t\tatp_writeb_io(dev, c, 0x10, 0x45);\n\t\t\tworkreq = dev->id[c][target_id].curr_req;\n#ifdef ED_DBGP\n\t\t\tscmd_printk(KERN_DEBUG, workreq, \"CDB\");\n\t\t\tfor (l = 0; l < workreq->cmd_len; l++)\n\t\t\t\tprintk(KERN_DEBUG \" %x\",workreq->cmnd[l]);\n\t\t\tprintk(\"\\n\");\n#endif\n\n\t\t\tatp_writeb_io(dev, c, 0x0f, lun);\n\t\t\tatp_writeb_io(dev, c, 0x11, dev->id[c][target_id].devsp);\n\t\t\tadrcnt = dev->id[c][target_id].tran_len;\n\t\t\tk = dev->id[c][target_id].last_len;\n\n\t\t\tatp_writeb_io(dev, c, 0x12, ((unsigned char *) &k)[2]);\n\t\t\tatp_writeb_io(dev, c, 0x13, ((unsigned char *) &k)[1]);\n\t\t\tatp_writeb_io(dev, c, 0x14, ((unsigned char *) &k)[0]);\n#ifdef ED_DBGP\n\t\t\tprintk(\"k %x, k[0] 0x%x k[1] 0x%x k[2] 0x%x\\n\", k,\n\t\t\t       atp_readb_io(dev, c, 0x14),\n\t\t\t       atp_readb_io(dev, c, 0x13),\n\t\t\t       atp_readb_io(dev, c, 0x12));\n#endif\n\t\t\t \n\t\t\tj = target_id;\n\t\t\tif (target_id > 7) {\n\t\t\t\tj = (j & 0x07) | 0x40;\n\t\t\t}\n\t\t\t \n\t\t\tj |= dev->id[c][target_id].dirct;\n\t\t\tatp_writeb_io(dev, c, 0x15, j);\n\t\t\tatp_writeb_io(dev, c, 0x16, 0x80);\n\n\t\t\t \n\t\t\tif (is885(dev)) {\n\t\t\t\ti = atp_readb_pci(dev, c, 1) & 0xf3;\n\t\t\t\t\n\t\t\t\tif ((workreq->cmnd[0] == READ_6) ||\n\t\t\t\t    (workreq->cmnd[0] == READ_10) ||\n\t\t\t\t    (workreq->cmnd[0] == WRITE_6) ||\n\t\t\t\t    (workreq->cmnd[0] == WRITE_10)) {\n\t\t\t\t   i |= 0x0c;\n\t\t\t\t}\n\t\t\t\tatp_writeb_pci(dev, c, 1, i);\n\t\t\t} else if (is880(dev)) {\n\t\t\t\tif ((workreq->cmnd[0] == READ_6) ||\n\t\t\t\t    (workreq->cmnd[0] == READ_10) ||\n\t\t\t\t    (workreq->cmnd[0] == WRITE_6) ||\n\t\t\t\t    (workreq->cmnd[0] == WRITE_10))\n\t\t\t\t\tatp_writeb_base(dev, 0x3b,\n\t\t\t\t\t\t\t(atp_readb_base(dev, 0x3b) & 0x3f) | 0xc0);\n\t\t\t\telse\n\t\t\t\t\tatp_writeb_base(dev, 0x3b,\n\t\t\t\t\t\t\tatp_readb_base(dev, 0x3b) & 0x3f);\n\t\t\t} else {\n\t\t\t\tif ((workreq->cmnd[0] == READ_6) ||\n\t\t\t\t    (workreq->cmnd[0] == READ_10) ||\n\t\t\t\t    (workreq->cmnd[0] == WRITE_6) ||\n\t\t\t\t    (workreq->cmnd[0] == WRITE_10))\n\t\t\t\t\tatp_writeb_base(dev, 0x3a,\n\t\t\t\t\t\t\t(atp_readb_base(dev, 0x3a) & 0xf3) | 0x08);\n\t\t\t\telse\n\t\t\t\t\tatp_writeb_base(dev, 0x3a,\n\t\t\t\t\t\t\tatp_readb_base(dev, 0x3a) & 0xf3);\n\t\t\t}\n\t\t\tj = 0;\n\t\t\tid = 1;\n\t\t\tid = id << target_id;\n\t\t\t \n\t\t\tif ((id & dev->wide_id[c]) != 0) {\n\t\t\t\tj |= 0x01;\n\t\t\t}\n\t\t\tatp_writeb_io(dev, c, 0x1b, j);\n\t\t\twhile ((atp_readb_io(dev, c, 0x1b) & 0x01) != j)\n\t\t\t\tatp_writeb_io(dev, c, 0x1b, j);\n\t\t\tif (dev->id[c][target_id].last_len == 0) {\n\t\t\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\t\t\t\tdev->in_int[c] = 0;\n#ifdef ED_DBGP\n\t\t\t\tprintk(\"dev->id[c][target_id].last_len = 0\\n\");\n#endif\n\t\t\t\treturn IRQ_HANDLED;\n\t\t\t}\n#ifdef ED_DBGP\n\t\t\tprintk(\"target_id = %d adrcnt = %d\\n\",target_id,adrcnt);\n#endif\n\t\t\tprd = dev->id[c][target_id].prd_pos;\n\t\t\twhile (adrcnt != 0) {\n\t\t\t\tid = ((unsigned short int *)prd)[2];\n\t\t\t\tif (id == 0) {\n\t\t\t\t\tk = 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\tk = id;\n\t\t\t\t}\n\t\t\t\tif (k > adrcnt) {\n\t\t\t\t\t((unsigned short int *)prd)[2] =\n\t\t\t\t\t\t(unsigned short int)(k - adrcnt);\n\t\t\t\t\t((unsigned long *)prd)[0] += adrcnt;\n\t\t\t\t\tadrcnt = 0;\n\t\t\t\t\tdev->id[c][target_id].prd_pos = prd;\n\t\t\t\t} else {\n\t\t\t\t\tadrcnt -= k;\n\t\t\t\t\tdev->id[c][target_id].prdaddr += 0x08;\n\t\t\t\t\tprd += 0x08;\n\t\t\t\t\tif (adrcnt == 0) {\n\t\t\t\t\t\tdev->id[c][target_id].prd_pos = prd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tatp_writel_pci(dev, c, 0x04, dev->id[c][target_id].prdaddr);\n#ifdef ED_DBGP\n\t\t\tprintk(\"dev->id[%d][%d].prdaddr 0x%8x\\n\",\n\t\t\t       c, target_id, dev->id[c][target_id].prdaddr);\n#endif\n\t\t\tif (!is885(dev)) {\n\t\t\t\tatp_writeb_pci(dev, c, 2, 0x06);\n\t\t\t\tatp_writeb_pci(dev, c, 2, 0x00);\n\t\t\t}\n\t\t\t \n\t\t\tif (dev->id[c][target_id].dirct != 0) {\n\t\t\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\t\t\t\tatp_writeb_pci(dev, c, 0, 0x01);\n\t\t\t\tdev->in_int[c] = 0;\n#ifdef ED_DBGP\n\t\t\t\tprintk(\"status 0x80 return dirct != 0\\n\");\n#endif\n\t\t\t\treturn IRQ_HANDLED;\n\t\t\t}\n\t\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\t\t\tatp_writeb_pci(dev, c, 0, 0x09);\n\t\t\tdev->in_int[c] = 0;\n#ifdef ED_DBGP\n\t\t\tprintk(\"status 0x80 return dirct = 0\\n\");\n#endif\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\t \n\n\t\tworkreq = dev->id[c][target_id].curr_req;\n\n\t\tif (i == 0x42 || i == 0x16) {\n\t\t\tif ((dev->last_cmd[c] & 0xf0) != 0x40) {\n\t\t\t   dev->last_cmd[c] = 0xff;\n\t\t\t}\n\t\t\tif (i == 0x16) {\n\t\t\t\tworkreq->result = atp_readb_io(dev, c, 0x0f);\n\t\t\t\tif (((dev->r1f[c][target_id] & 0x10) != 0) && is885(dev)) {\n\t\t\t\t\tprintk(KERN_WARNING \"AEC67162 CRC ERROR !\\n\");\n\t\t\t\t\tworkreq->result = SAM_STAT_CHECK_CONDITION;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tworkreq->result = SAM_STAT_CHECK_CONDITION;\n\n\t\t\tif (is885(dev)) {\n\t\t\t\tj = atp_readb_base(dev, 0x29) | 0x01;\n\t\t\t\tatp_writeb_base(dev, 0x29, j);\n\t\t\t}\n\t\t\t \n\t\t\tscsi_dma_unmap(workreq);\n\n\t\t\tspin_lock_irqsave(dev->host->host_lock, flags);\n\t\t\tscsi_done(workreq);\n#ifdef ED_DBGP\n\t\t\t   printk(\"workreq->scsi_done\\n\");\n#endif\n\t\t\t \n\t\t\tdev->id[c][target_id].curr_req = NULL;\n\t\t\tdev->working[c]--;\n\t\t\tspin_unlock_irqrestore(dev->host->host_lock, flags);\n\t\t\t \n\t\t\tif (dev->wide_id[c] != 0) {\n\t\t\t\tatp_writeb_io(dev, c, 0x1b, 0x01);\n\t\t\t\twhile ((atp_readb_io(dev, c, 0x1b) & 0x01) != 0x01)\n\t\t\t\t\tatp_writeb_io(dev, c, 0x1b, 0x01);\n\t\t\t}\n\t\t\t \n\t\t\tspin_lock_irqsave(dev->host->host_lock, flags);\n\t\t\tif (((dev->last_cmd[c] != 0xff) ||\n\t\t\t     (dev->quhd[c] != dev->quend[c])) &&\n\t\t\t    (dev->in_snd[c] == 0)) {\n#ifdef ED_DBGP\n\t\t\t   printk(\"Call sent_s870(scsi_done)\\n\");\n#endif\n\t\t\t   send_s870(dev,c);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(dev->host->host_lock, flags);\n\t\t\tdev->in_int[c] = 0;\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\tif ((dev->last_cmd[c] & 0xf0) != 0x40) {\n\t\t   dev->last_cmd[c] = 0xff;\n\t\t}\n\t\tif (i == 0x4f) {\n\t\t\ti = 0x89;\n\t\t}\n\t\ti &= 0x0f;\n\t\tif (i == 0x09) {\n\t\t\tatp_writel_pci(dev, c, 4, dev->id[c][target_id].prdaddr);\n\t\t\tatp_writeb_pci(dev, c, 2, 0x06);\n\t\t\tatp_writeb_pci(dev, c, 2, 0x00);\n\t\t\tatp_writeb_io(dev, c, 0x10, 0x41);\n\t\t\tif (is885(dev)) {\n\t\t\t\tk = dev->id[c][target_id].last_len;\n\t\t\t\tatp_writeb_io(dev, c, 0x12,\n\t\t\t\t\t      ((unsigned char *) (&k))[2]);\n\t\t\t\tatp_writeb_io(dev, c, 0x13,\n\t\t\t\t\t      ((unsigned char *) (&k))[1]);\n\t\t\t\tatp_writeb_io(dev, c, 0x14,\n\t\t\t\t\t      ((unsigned char *) (&k))[0]);\n\t\t\t\tdev->id[c][target_id].dirct = 0x00;\n\t\t\t} else {\n\t\t\t\tdev->id[c][target_id].dirct = 0x00;\n\t\t\t}\n\t\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\t\t\tatp_writeb_pci(dev, c, 0, 0x09);\n\t\t\tdev->in_int[c] = 0;\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\tif (i == 0x08) {\n\t\t\tatp_writel_pci(dev, c, 4, dev->id[c][target_id].prdaddr);\n\t\t\tatp_writeb_pci(dev, c, 2, 0x06);\n\t\t\tatp_writeb_pci(dev, c, 2, 0x00);\n\t\t\tatp_writeb_io(dev, c, 0x10, 0x41);\n\t\t\tif (is885(dev)) {\n\t\t\t\tk = dev->id[c][target_id].last_len;\n\t\t\t\tatp_writeb_io(dev, c, 0x12,\n\t\t\t\t\t      ((unsigned char *) (&k))[2]);\n\t\t\t\tatp_writeb_io(dev, c, 0x13,\n\t\t\t\t\t      ((unsigned char *) (&k))[1]);\n\t\t\t\tatp_writeb_io(dev, c, 0x14,\n\t\t\t\t\t      ((unsigned char *) (&k))[0]);\n\t\t\t}\n\t\t\tatp_writeb_io(dev, c, 0x15,\n\t\t\t\t      atp_readb_io(dev, c, 0x15) | 0x20);\n\t\t\tdev->id[c][target_id].dirct = 0x20;\n\t\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\t\t\tatp_writeb_pci(dev, c, 0, 0x01);\n\t\t\tdev->in_int[c] = 0;\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\tif (i == 0x0a)\n\t\t\tatp_writeb_io(dev, c, 0x10, 0x30);\n\t\telse\n\t\t\tatp_writeb_io(dev, c, 0x10, 0x46);\n\t\tdev->id[c][target_id].dirct = 0x00;\n\t\tatp_writeb_io(dev, c, 0x12, 0x00);\n\t\tatp_writeb_io(dev, c, 0x13, 0x00);\n\t\tatp_writeb_io(dev, c, 0x14, 0x00);\n\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\t}\n\tdev->in_int[c] = 0;\n\n\treturn IRQ_HANDLED;\n}\n \nstatic int atp870u_queuecommand_lck(struct scsi_cmnd *req_p)\n{\n\tvoid (*done)(struct scsi_cmnd *) = scsi_done;\n\tunsigned char c;\n\tunsigned int m;\n\tstruct atp_unit *dev;\n\tstruct Scsi_Host *host;\n\n\tc = scmd_channel(req_p);\n\treq_p->sense_buffer[0]=0;\n\tscsi_set_resid(req_p, 0);\n\tif (scmd_channel(req_p) > 1) {\n\t\treq_p->result = DID_BAD_TARGET << 16;\n\t\tdone(req_p);\n#ifdef ED_DBGP\n\t\tprintk(\"atp870u_queuecommand : req_p->device->channel > 1\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\thost = req_p->device->host;\n\tdev = (struct atp_unit *)&host->hostdata;\n\n\tm = 1;\n\tm = m << scmd_id(req_p);\n\n\t \n\n\tif ((m & dev->active_id[c]) == 0) {\n\t\treq_p->result = DID_BAD_TARGET << 16;\n\t\tdone(req_p);\n\t\treturn 0;\n\t}\n\n\t \n\tdev->quend[c]++;\n\tif (dev->quend[c] >= qcnt) {\n\t\tdev->quend[c] = 0;\n\t}\n\n\t \n\tif (dev->quhd[c] == dev->quend[c]) {\n\t\tif (dev->quend[c] == 0) {\n\t\t\tdev->quend[c] = qcnt;\n\t\t}\n#ifdef ED_DBGP\n\t\tprintk(\"atp870u_queuecommand : dev->quhd[c] == dev->quend[c]\\n\");\n#endif\n\t\tdev->quend[c]--;\n\t\treq_p->result = DID_BUS_BUSY << 16;\n\t\tdone(req_p);\n\t\treturn 0;\n\t}\n\tdev->quereq[c][dev->quend[c]] = req_p;\n#ifdef ED_DBGP\n\tprintk(\"dev->ioport[c] = %x atp_readb_io(dev, c, 0x1c) = %x \"\n\t       \"dev->in_int[%d] = %d dev->in_snd[%d] = %d\\n\",\n\t       dev->ioport[c], atp_readb_io(dev, c, 0x1c), c,\n\t       dev->in_int[c],c,dev->in_snd[c]);\n#endif\n\tif ((atp_readb_io(dev, c, 0x1c) == 0) &&\n\t    (dev->in_int[c] == 0) &&\n\t    (dev->in_snd[c] == 0)) {\n#ifdef ED_DBGP\n\t\tprintk(\"Call sent_s870(atp870u_queuecommand)\\n\");\n#endif\n\t\tsend_s870(dev,c);\n\t}\n#ifdef ED_DBGP\n\tprintk(\"atp870u_queuecommand : exit\\n\");\n#endif\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(atp870u_queuecommand)\n\n \nstatic void send_s870(struct atp_unit *dev, unsigned char c)\n{\n\tstruct scsi_cmnd *workreq = NULL;\n\tunsigned int i;\n\tunsigned char  j, target_id;\n\tunsigned char *prd;\n\tunsigned short int w;\n\tunsigned long l, bttl = 0;\n\tunsigned long  sg_count;\n\n\tif (dev->in_snd[c] != 0) {\n#ifdef ED_DBGP\n\t\tprintk(\"cmnd in_snd\\n\");\n#endif\n\t\treturn;\n\t}\n#ifdef ED_DBGP\n\tprintk(\"Sent_s870 enter\\n\");\n#endif\n\tdev->in_snd[c] = 1;\n\tif ((dev->last_cmd[c] != 0xff) && ((dev->last_cmd[c] & 0x40) != 0)) {\n\t\tdev->last_cmd[c] &= 0x0f;\n\t\tworkreq = dev->id[c][dev->last_cmd[c]].curr_req;\n\t\tif (!workreq) {\n\t\t\tdev->last_cmd[c] = 0xff;\n\t\t\tif (dev->quhd[c] == dev->quend[c]) {\n\t\t\t\tdev->in_snd[c] = 0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (!workreq) {\n\t\tif ((dev->last_cmd[c] != 0xff) && (dev->working[c] != 0)) {\n\t\t\tdev->in_snd[c] = 0;\n\t\t\treturn;\n\t\t}\n\t\tdev->working[c]++;\n\t\tj = dev->quhd[c];\n\t\tdev->quhd[c]++;\n\t\tif (dev->quhd[c] >= qcnt)\n\t\t\tdev->quhd[c] = 0;\n\t\tworkreq = dev->quereq[c][dev->quhd[c]];\n\t\tif (dev->id[c][scmd_id(workreq)].curr_req != NULL) {\n\t\t\tdev->quhd[c] = j;\n\t\t\tdev->working[c]--;\n\t\t\tdev->in_snd[c] = 0;\n\t\t\treturn;\n\t\t}\n\t\tdev->id[c][scmd_id(workreq)].curr_req = workreq;\n\t\tdev->last_cmd[c] = scmd_id(workreq);\n\t}\n\tif ((atp_readb_io(dev, c, 0x1f) & 0xb0) != 0 ||\n\t    atp_readb_io(dev, c, 0x1c) != 0) {\n#ifdef ED_DBGP\n\t\tprintk(\"Abort to Send\\n\");\n#endif\n\t\tdev->last_cmd[c] |= 0x40;\n\t\tdev->in_snd[c] = 0;\n\t\treturn;\n\t}\n#ifdef ED_DBGP\n\tprintk(\"OK to Send\\n\");\n\tscmd_printk(KERN_DEBUG, workreq, \"CDB\");\n\tfor(i=0;i<workreq->cmd_len;i++) {\n\t\tprintk(\" %x\",workreq->cmnd[i]);\n\t}\n\tprintk(\"\\n\");\n#endif\n\tl = scsi_bufflen(workreq);\n\n\tif (is885(dev)) {\n\t\tj = atp_readb_base(dev, 0x29) & 0xfe;\n\t\tatp_writeb_base(dev, 0x29, j);\n\t\tdev->r1f[c][scmd_id(workreq)] = 0;\n\t}\n\n\tif (workreq->cmnd[0] == READ_CAPACITY) {\n\t\tif (l > 8)\n\t\t\tl = 8;\n\t}\n\tif (workreq->cmnd[0] == TEST_UNIT_READY) {\n\t\tl = 0;\n\t}\n\n\tj = 0;\n\ttarget_id = scmd_id(workreq);\n\n\t \n\tw = 1;\n\tw = w << target_id;\n\tif ((w & dev->wide_id[c]) != 0) {\n\t\tj |= 0x01;\n\t}\n\tatp_writeb_io(dev, c, 0x1b, j);\n\twhile ((atp_readb_io(dev, c, 0x1b) & 0x01) != j) {\n\t\tatp_writeb_pci(dev, c, 0x1b, j);\n#ifdef ED_DBGP\n\t\tprintk(\"send_s870 while loop 1\\n\");\n#endif\n\t}\n\t \n\n\tatp_writeb_io(dev, c, 0x00, workreq->cmd_len);\n\tatp_writeb_io(dev, c, 0x01, 0x2c);\n\tif (is885(dev))\n\t\tatp_writeb_io(dev, c, 0x02, 0x7f);\n\telse\n\t\tatp_writeb_io(dev, c, 0x02, 0xcf);\n\tfor (i = 0; i < workreq->cmd_len; i++)\n\t\tatp_writeb_io(dev, c, 0x03 + i, workreq->cmnd[i]);\n\tatp_writeb_io(dev, c, 0x0f, workreq->device->lun);\n\t \n\tatp_writeb_io(dev, c, 0x11, dev->id[c][target_id].devsp);\n#ifdef ED_DBGP\n\tprintk(\"dev->id[%d][%d].devsp = %2x\\n\",c,target_id,\n\t       dev->id[c][target_id].devsp);\n#endif\n\n\tsg_count = scsi_dma_map(workreq);\n\t \n\tatp_writeb_io(dev, c, 0x12, ((unsigned char *) (&l))[2]);\n\tatp_writeb_io(dev, c, 0x13, ((unsigned char *) (&l))[1]);\n\tatp_writeb_io(dev, c, 0x14, ((unsigned char *) (&l))[0]);\n\tj = target_id;\n\tdev->id[c][j].last_len = l;\n\tdev->id[c][j].tran_len = 0;\n#ifdef ED_DBGP\n\tprintk(\"dev->id[%2d][%2d].last_len = %d\\n\",c,j,dev->id[c][j].last_len);\n#endif\n\t \n\tif ((j & 0x08) != 0) {\n\t\tj = (j & 0x07) | 0x40;\n\t}\n\t \n\tif (workreq->sc_data_direction == DMA_TO_DEVICE)\n\t\tatp_writeb_io(dev, c, 0x15, j | 0x20);\n\telse\n\t\tatp_writeb_io(dev, c, 0x15, j);\n\tatp_writeb_io(dev, c, 0x16, atp_readb_io(dev, c, 0x16) | 0x80);\n\tatp_writeb_io(dev, c, 0x16, 0x80);\n\tdev->id[c][target_id].dirct = 0;\n\tif (l == 0) {\n\t\tif (atp_readb_io(dev, c, 0x1c) == 0) {\n#ifdef ED_DBGP\n\t\t\tprintk(\"change SCSI_CMD_REG 0x08\\n\");\n#endif\n\t\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\t\t} else\n\t\t\tdev->last_cmd[c] |= 0x40;\n\t\tdev->in_snd[c] = 0;\n\t\treturn;\n\t}\n\tprd = dev->id[c][target_id].prd_table;\n\tdev->id[c][target_id].prd_pos = prd;\n\n\t \n\n\tif (l) {\n\t\tstruct scatterlist *sgpnt;\n\t\ti = 0;\n\t\tscsi_for_each_sg(workreq, sgpnt, sg_count, j) {\n\t\t\tbttl = sg_dma_address(sgpnt);\n\t\t\tl=sg_dma_len(sgpnt);\n#ifdef ED_DBGP\n\t\t\tprintk(\"1. bttl %x, l %x\\n\",bttl, l);\n#endif\n\t\t\twhile (l > 0x10000) {\n\t\t\t\t(((u16 *) (prd))[i + 3]) = 0x0000;\n\t\t\t\t(((u16 *) (prd))[i + 2]) = 0x0000;\n\t\t\t\t(((u32 *) (prd))[i >> 1]) = cpu_to_le32(bttl);\n\t\t\t\tl -= 0x10000;\n\t\t\t\tbttl += 0x10000;\n\t\t\t\ti += 0x04;\n\t\t\t}\n\t\t\t(((u32 *) (prd))[i >> 1]) = cpu_to_le32(bttl);\n\t\t\t(((u16 *) (prd))[i + 2]) = cpu_to_le16(l);\n\t\t\t(((u16 *) (prd))[i + 3]) = 0;\n\t\t\ti += 0x04;\n\t\t}\n\t\t(((u16 *) (prd))[i - 1]) = cpu_to_le16(0x8000);\n#ifdef ED_DBGP\n\t\tprintk(\"prd %4x %4x %4x %4x\\n\",\n\t\t       (((unsigned short int *)prd)[0]),\n\t\t       (((unsigned short int *)prd)[1]),\n\t\t       (((unsigned short int *)prd)[2]),\n\t\t       (((unsigned short int *)prd)[3]));\n\t\tprintk(\"2. bttl %x, l %x\\n\",bttl, l);\n#endif\n\t}\n#ifdef ED_DBGP\n\tprintk(\"send_s870: prdaddr_2 0x%8x target_id %d\\n\",\n\t       dev->id[c][target_id].prdaddr,target_id);\n#endif\n\tdev->id[c][target_id].prdaddr = dev->id[c][target_id].prd_bus;\n\tatp_writel_pci(dev, c, 4, dev->id[c][target_id].prdaddr);\n\tatp_writeb_pci(dev, c, 2, 0x06);\n\tatp_writeb_pci(dev, c, 2, 0x00);\n\tif (is885(dev)) {\n\t\tj = atp_readb_pci(dev, c, 1) & 0xf3;\n\t\tif ((workreq->cmnd[0] == READ_6) ||\n\t\t    (workreq->cmnd[0] == READ_10) ||\n\t\t    (workreq->cmnd[0] == WRITE_6) ||\n\t\t    (workreq->cmnd[0] == WRITE_10)) {\n\t\t\tj |= 0x0c;\n\t\t}\n\t\tatp_writeb_pci(dev, c, 1, j);\n\t} else if (is880(dev)) {\n\t\tif ((workreq->cmnd[0] == READ_6) ||\n\t\t    (workreq->cmnd[0] == READ_10) ||\n\t\t    (workreq->cmnd[0] == WRITE_6) ||\n\t\t    (workreq->cmnd[0] == WRITE_10))\n\t\t\tatp_writeb_base(dev, 0x3b,\n\t\t\t\t\t(atp_readb_base(dev, 0x3b) & 0x3f) | 0xc0);\n\t\telse\n\t\t\tatp_writeb_base(dev, 0x3b,\n\t\t\t\t\tatp_readb_base(dev, 0x3b) & 0x3f);\n\t} else {\n\t\tif ((workreq->cmnd[0] == READ_6) ||\n\t\t    (workreq->cmnd[0] == READ_10) ||\n\t\t    (workreq->cmnd[0] == WRITE_6) ||\n\t\t    (workreq->cmnd[0] == WRITE_10))\n\t\t\tatp_writeb_base(dev, 0x3a,\n\t\t\t\t\t(atp_readb_base(dev, 0x3a) & 0xf3) | 0x08);\n\t\telse\n\t\t\tatp_writeb_base(dev, 0x3a,\n\t\t\t\t\tatp_readb_base(dev, 0x3a) & 0xf3);\n\t}\n\n\tif(workreq->sc_data_direction == DMA_TO_DEVICE) {\n\t\tdev->id[c][target_id].dirct = 0x20;\n\t\tif (atp_readb_io(dev, c, 0x1c) == 0) {\n\t\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\t\t\tatp_writeb_pci(dev, c, 0, 0x01);\n#ifdef ED_DBGP\n\t\tprintk( \"start DMA(to target)\\n\");\n#endif\n\t\t} else {\n\t\t\tdev->last_cmd[c] |= 0x40;\n\t\t}\n\t\tdev->in_snd[c] = 0;\n\t\treturn;\n\t}\n\tif (atp_readb_io(dev, c, 0x1c) == 0) {\n\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\t\tatp_writeb_pci(dev, c, 0, 0x09);\n#ifdef ED_DBGP\n\t\tprintk( \"start DMA(to host)\\n\");\n#endif\n\t} else {\n\t\tdev->last_cmd[c] |= 0x40;\n\t}\n\tdev->in_snd[c] = 0;\n\treturn;\n\n}\n\nstatic unsigned char fun_scam(struct atp_unit *dev, unsigned short int *val)\n{\n\tunsigned short int i, k;\n\tunsigned char j;\n\n\tatp_writew_io(dev, 0, 0x1c, *val);\n\tfor (i = 0; i < 10; i++) {\t \n\t\tk = atp_readw_io(dev, 0, 0x1c);\n\t\tj = (unsigned char) (k >> 8);\n\t\tif ((k & 0x8000) != 0)\t \n\t\t\ti = 0;\n\t}\n\t*val |= 0x4000;\t\t \n\tatp_writew_io(dev, 0, 0x1c, *val);\n\t*val &= 0xdfff;\t\t \n\tatp_writew_io(dev, 0, 0x1c, *val);\n\tfor (i = 0; i < 10; i++) {\t \n\t\tif ((atp_readw_io(dev, 0, 0x1c) & 0x2000) != 0)\t \n\t\t\ti = 0;\n\t}\n\t*val |= 0x8000;\t\t \n\t*val &= 0xe0ff;\n\tatp_writew_io(dev, 0, 0x1c, *val);\n\t*val &= 0xbfff;\t\t \n\tatp_writew_io(dev, 0, 0x1c, *val);\n\tfor (i = 0; i < 10; i++) {\t \n\t\tif ((atp_readw_io(dev, 0, 0x1c) & 0x4000) != 0)\t \n\t\t\ti = 0;\n\t}\n\n\treturn j;\n}\n\nstatic void tscam(struct Scsi_Host *host, bool wide_chip, u8 scam_on)\n{\n\n\tunsigned char i, j, k;\n\tunsigned long n;\n\tunsigned short int m, assignid_map, val;\n\tunsigned char mbuf[33], quintet[2];\n\tstruct atp_unit *dev = (struct atp_unit *)&host->hostdata;\n\tstatic unsigned char g2q_tab[8] = {\n\t\t0x38, 0x31, 0x32, 0x2b, 0x34, 0x2d, 0x2e, 0x27\n\t};\n\n \n\n\tatp_writeb_io(dev, 0, 1, 0x08);\n\tatp_writeb_io(dev, 0, 2, 0x7f);\n\tatp_writeb_io(dev, 0, 0x11, 0x20);\n\n\tif ((scam_on & 0x40) == 0) {\n\t\treturn;\n\t}\n\tm = 1;\n\tm <<= dev->host_id[0];\n\tj = 16;\n\tif (!wide_chip) {\n\t\tm |= 0xff00;\n\t\tj = 8;\n\t}\n\tassignid_map = m;\n\tatp_writeb_io(dev, 0, 0x02, 0x02);\t \n\tatp_writeb_io(dev, 0, 0x03, 0);\n\tatp_writeb_io(dev, 0, 0x04, 0);\n\tatp_writeb_io(dev, 0, 0x05, 0);\n\tatp_writeb_io(dev, 0, 0x06, 0);\n\tatp_writeb_io(dev, 0, 0x07, 0);\n\tatp_writeb_io(dev, 0, 0x08, 0);\n\n\tfor (i = 0; i < j; i++) {\n\t\tm = 1;\n\t\tm = m << i;\n\t\tif ((m & assignid_map) != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tatp_writeb_io(dev, 0, 0x0f, 0);\n\t\tatp_writeb_io(dev, 0, 0x12, 0);\n\t\tatp_writeb_io(dev, 0, 0x13, 0);\n\t\tatp_writeb_io(dev, 0, 0x14, 0);\n\t\tif (i > 7) {\n\t\t\tk = (i & 0x07) | 0x40;\n\t\t} else {\n\t\t\tk = i;\n\t\t}\n\t\tatp_writeb_io(dev, 0, 0x15, k);\n\t\tif (wide_chip)\n\t\t\tatp_writeb_io(dev, 0, 0x1b, 0x01);\n\t\telse\n\t\t\tatp_writeb_io(dev, 0, 0x1b, 0x00);\n\t\tdo {\n\t\t\tatp_writeb_io(dev, 0, 0x18, 0x09);\n\n\t\t\twhile ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)\n\t\t\t\tcpu_relax();\n\t\t\tk = atp_readb_io(dev, 0, 0x17);\n\t\t\tif ((k == 0x85) || (k == 0x42))\n\t\t\t\tbreak;\n\t\t\tif (k != 0x16)\n\t\t\t\tatp_writeb_io(dev, 0, 0x10, 0x41);\n\t\t} while (k != 0x16);\n\t\tif ((k == 0x85) || (k == 0x42))\n\t\t\tcontinue;\n\t\tassignid_map |= m;\n\n\t}\n\tatp_writeb_io(dev, 0, 0x02, 0x7f);\n\tatp_writeb_io(dev, 0, 0x1b, 0x02);\n\n\tudelay(2);\n\n\tval = 0x0080;\t\t \n\tatp_writew_io(dev, 0, 0x1c, val);\n\tval |= 0x0040;\t\t \n\tatp_writew_io(dev, 0, 0x1c, val);\n\tval |= 0x0004;\t\t \n\tatp_writew_io(dev, 0, 0x1c, val);\n\tudelay(2);\t\t \n\tval &= 0x007f;\t\t \n\tatp_writew_io(dev, 0, 0x1c, val);\n\tmsleep(128);\n\tval &= 0x00fb;\t\t \n\tatp_writew_io(dev, 0, 0x1c, val);\n\twhile ((atp_readb_io(dev, 0, 0x1c) & 0x04) != 0)\n\t\t;\n\tudelay(2);\n\tudelay(100);\n\tfor (n = 0; n < 0x30000; n++)\n\t\tif ((atp_readb_io(dev, 0, 0x1c) & 0x80) != 0)\t \n\t\t\tbreak;\n\tif (n < 0x30000)\n\t\tfor (n = 0; n < 0x30000; n++)\n\t\t\tif ((atp_readb_io(dev, 0, 0x1c) & 0x81) == 0x0081) {\n\t\t\t\tudelay(2);\n\t\t\t\tval |= 0x8003;\t\t \n\t\t\t\tatp_writew_io(dev, 0, 0x1c, val);\n\t\t\t\tudelay(2);\n\t\t\t\tval &= 0x00bf;\t\t \n\t\t\t\tatp_writew_io(dev, 0, 0x1c, val);\n\t\t\t\tudelay(2);\n\t\t\t\tbreak;\n\t\t\t}\n\twhile (1) {\n\t \n\tmdelay(2);\n\tudelay(48);\n\tif ((atp_readb_io(dev, 0, 0x1c) & 0x80) == 0x00) {\t \n\t\tatp_writew_io(dev, 0, 0x1c, 0);\n\t\tatp_writeb_io(dev, 0, 0x1b, 0);\n\t\tatp_writeb_io(dev, 0, 0x15, 0);\n\t\tatp_writeb_io(dev, 0, 0x18, 0x09);\n\t\twhile ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0)\n\t\t\tcpu_relax();\n\t\tatp_readb_io(dev, 0, 0x17);\n\t\treturn;\n\t}\n\tval &= 0x00ff;\t\t \n\tval |= 0x3f00;\n\tfun_scam(dev, &val);\n\tudelay(2);\n\tval &= 0x00ff;\t\t \n\tval |= 0x2000;\n\tfun_scam(dev, &val);\n\tudelay(2);\n\ti = 8;\n\tj = 0;\n\n\twhile (1) {\n\t\tif ((atp_readw_io(dev, 0, 0x1c) & 0x2000) == 0)\n\t\t\tcontinue;\n\t\tudelay(2);\n\t\tval &= 0x00ff;\t\t \n\t\tval |= 0x2000;\n\t\tk = fun_scam(dev, &val);\n\t\tif ((k & 0x03) == 0)\n\t\t\tbreak;\n\t\tmbuf[j] <<= 0x01;\n\t\tmbuf[j] &= 0xfe;\n\t\tif ((k & 0x02) != 0)\n\t\t\tmbuf[j] |= 0x01;\n\t\ti--;\n\t\tif (i > 0)\n\t\t\tcontinue;\n\t\tj++;\n\t\ti = 8;\n\t}\n\n\t \n \n\ti = 15;\n\tj = mbuf[0];\n\tif ((j & 0x20) != 0) {\t \n\t\ti = 7;\n\t}\n\tif ((j & 0x06) != 0) {\t \n\t\tk = mbuf[1];\n\t\twhile (1) {\n\t\t\tm = 1;\n\t\t\tm <<= k;\n\t\t\tif ((m & assignid_map) == 0)\n\t\t\t\tbreak;\n\t\t\tif (k > 0)\n\t\t\t\tk--;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif ((m & assignid_map) != 0) {\t \n\t\tk = i;\t\t\t \n\t\twhile (1) {\n\t\t\tm = 1;\n\t\t\tm <<= k;\n\t\t\tif ((m & assignid_map) == 0)\n\t\t\t\tbreak;\n\t\t\tif (k > 0)\n\t\t\t\tk--;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tassignid_map |= m;\n\tif (k < 8) {\n\t\tquintet[0] = 0x38;\t \n\t} else {\n\t\tquintet[0] = 0x31;\t \n\t}\n\tk &= 0x07;\n\tquintet[1] = g2q_tab[k];\n\n\tval &= 0x00ff;\t\t \n\tm = quintet[0] << 8;\n\tval |= m;\n\tfun_scam(dev, &val);\n\tval &= 0x00ff;\t\t \n\tm = quintet[1] << 8;\n\tval |= m;\n\tfun_scam(dev, &val);\n\n\t}\n}\n\nstatic void atp870u_free_tables(struct Scsi_Host *host)\n{\n\tstruct atp_unit *atp_dev = (struct atp_unit *)&host->hostdata;\n\tint j, k;\n\tfor (j=0; j < 2; j++) {\n\t\tfor (k = 0; k < 16; k++) {\n\t\t\tif (!atp_dev->id[j][k].prd_table)\n\t\t\t\tcontinue;\n\t\t\tdma_free_coherent(&atp_dev->pdev->dev, 1024,\n\t\t\t\t\t  atp_dev->id[j][k].prd_table,\n\t\t\t\t\t  atp_dev->id[j][k].prd_bus);\n\t\t\tatp_dev->id[j][k].prd_table = NULL;\n\t\t}\n\t}\n}\n\nstatic int atp870u_init_tables(struct Scsi_Host *host)\n{\n\tstruct atp_unit *atp_dev = (struct atp_unit *)&host->hostdata;\n\tint c,k;\n\tfor(c=0;c < 2;c++) {\n\t\tfor(k=0;k<16;k++) {\n\t\t\tatp_dev->id[c][k].prd_table =\n\t\t\t\tdma_alloc_coherent(&atp_dev->pdev->dev, 1024,\n\t\t\t\t\t\t   &(atp_dev->id[c][k].prd_bus),\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!atp_dev->id[c][k].prd_table) {\n\t\t\t\tprintk(\"atp870u_init_tables fail\\n\");\n\t\t\t\tatp870u_free_tables(host);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tatp_dev->id[c][k].prdaddr = atp_dev->id[c][k].prd_bus;\n\t\t\tatp_dev->id[c][k].devsp=0x20;\n\t\t\tatp_dev->id[c][k].devtype = 0x7f;\n\t\t\tatp_dev->id[c][k].curr_req = NULL;\n\t\t}\n\n\t\tatp_dev->active_id[c] = 0;\n\t\tatp_dev->wide_id[c] = 0;\n\t\tatp_dev->host_id[c] = 0x07;\n\t\tatp_dev->quhd[c] = 0;\n\t\tatp_dev->quend[c] = 0;\n\t\tatp_dev->last_cmd[c] = 0xff;\n\t\tatp_dev->in_snd[c] = 0;\n\t\tatp_dev->in_int[c] = 0;\n\n\t\tfor (k = 0; k < qcnt; k++) {\n\t\t\tatp_dev->quereq[c][k] = NULL;\n\t\t}\n\t\tfor (k = 0; k < 16; k++) {\n\t\t\t   atp_dev->id[c][k].curr_req = NULL;\n\t\t\t   atp_dev->sp[c][k] = 0x04;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void atp_set_host_id(struct atp_unit *atp, u8 c, u8 host_id)\n{\n\tatp_writeb_io(atp, c, 0, host_id | 0x08);\n\tatp_writeb_io(atp, c, 0x18, 0);\n\twhile ((atp_readb_io(atp, c, 0x1f) & 0x80) == 0)\n\t\tmdelay(1);\n\tatp_readb_io(atp, c, 0x17);\n\tatp_writeb_io(atp, c, 1, 8);\n\tatp_writeb_io(atp, c, 2, 0x7f);\n\tatp_writeb_io(atp, c, 0x11, 0x20);\n}\n\nstatic void atp870_init(struct Scsi_Host *shpnt)\n{\n\tstruct atp_unit *atpdev = shost_priv(shpnt);\n\tstruct pci_dev *pdev = atpdev->pdev;\n\tunsigned char k, host_id;\n\tu8 scam_on;\n\tbool wide_chip =\n\t\t(pdev->device == PCI_DEVICE_ID_ARTOP_AEC7610 &&\n\t\t pdev->revision == 4) ||\n\t\t(pdev->device == PCI_DEVICE_ID_ARTOP_AEC7612UW) ||\n\t\t(pdev->device == PCI_DEVICE_ID_ARTOP_AEC7612SUW);\n\n\tpci_read_config_byte(pdev, 0x49, &host_id);\n\n\tdev_info(&pdev->dev, \"ACARD AEC-671X PCI Ultra/W SCSI-2/3 \"\n\t\t \"Host Adapter: IO:%lx, IRQ:%d.\\n\",\n\t\t shpnt->io_port, shpnt->irq);\n\n\tatpdev->ioport[0] = shpnt->io_port;\n\tatpdev->pciport[0] = shpnt->io_port + 0x20;\n\thost_id &= 0x07;\n\tatpdev->host_id[0] = host_id;\n\tscam_on = atp_readb_pci(atpdev, 0, 2);\n\tatpdev->global_map[0] = atp_readb_base(atpdev, 0x2d);\n\tatpdev->ultra_map[0] = atp_readw_base(atpdev, 0x2e);\n\n\tif (atpdev->ultra_map[0] == 0) {\n\t\tscam_on = 0x00;\n\t\tatpdev->global_map[0] = 0x20;\n\t\tatpdev->ultra_map[0] = 0xffff;\n\t}\n\n\tif (pdev->revision > 0x07)\t \n\t\tatp_writeb_base(atpdev, 0x3e, 0x00);  \n\n\tk = (atp_readb_base(atpdev, 0x3a) & 0xf3) | 0x10;\n\tatp_writeb_base(atpdev, 0x3a, k);\n\tatp_writeb_base(atpdev, 0x3a, k & 0xdf);\n\tmsleep(32);\n\tatp_writeb_base(atpdev, 0x3a, k);\n\tmsleep(32);\n\tatp_set_host_id(atpdev, 0, host_id);\n\n\ttscam(shpnt, wide_chip, scam_on);\n\tatp_writeb_base(atpdev, 0x3a, atp_readb_base(atpdev, 0x3a) | 0x10);\n\tatp_is(atpdev, 0, wide_chip, 0);\n\tatp_writeb_base(atpdev, 0x3a, atp_readb_base(atpdev, 0x3a) & 0xef);\n\tatp_writeb_base(atpdev, 0x3b, atp_readb_base(atpdev, 0x3b) | 0x20);\n\tshpnt->max_id = wide_chip ? 16 : 8;\n\tshpnt->this_id = host_id;\n}\n\nstatic void atp880_init(struct Scsi_Host *shpnt)\n{\n\tstruct atp_unit *atpdev = shost_priv(shpnt);\n\tstruct pci_dev *pdev = atpdev->pdev;\n\tunsigned char k, m, host_id;\n\tunsigned int n;\n\n\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);\n\n\tatpdev->ioport[0] = shpnt->io_port + 0x40;\n\tatpdev->pciport[0] = shpnt->io_port + 0x28;\n\n\thost_id = atp_readb_base(atpdev, 0x39) >> 4;\n\n\tdev_info(&pdev->dev, \"ACARD AEC-67160 PCI Ultra3 LVD \"\n\t\t \"Host Adapter: IO:%lx, IRQ:%d.\\n\",\n\t\t shpnt->io_port, shpnt->irq);\n\tatpdev->host_id[0] = host_id;\n\n\tatpdev->global_map[0] = atp_readb_base(atpdev, 0x35);\n\tatpdev->ultra_map[0] = atp_readw_base(atpdev, 0x3c);\n\n\tn = 0x3f09;\n\twhile (n < 0x4000) {\n\t\tm = 0;\n\t\tatp_writew_base(atpdev, 0x34, n);\n\t\tn += 0x0002;\n\t\tif (atp_readb_base(atpdev, 0x30) == 0xff)\n\t\t\tbreak;\n\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);\n\t\tatp_writew_base(atpdev, 0x34, n);\n\t\tn += 0x0002;\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);\n\t\tatp_writew_base(atpdev, 0x34, n);\n\t\tn += 0x0002;\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);\n\t\tatp_writew_base(atpdev, 0x34, n);\n\t\tn += 0x0002;\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);\n\t\tatpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);\n\t\tn += 0x0018;\n\t}\n\tatp_writew_base(atpdev, 0x34, 0);\n\tatpdev->ultra_map[0] = 0;\n\tatpdev->async[0] = 0;\n\tfor (k = 0; k < 16; k++) {\n\t\tn = 1 << k;\n\t\tif (atpdev->sp[0][k] > 1)\n\t\t\tatpdev->ultra_map[0] |= n;\n\t\telse\n\t\t\tif (atpdev->sp[0][k] == 0)\n\t\t\t\tatpdev->async[0] |= n;\n\t}\n\tatpdev->async[0] = ~(atpdev->async[0]);\n\tatp_writeb_base(atpdev, 0x35, atpdev->global_map[0]);\n\n\tk = atp_readb_base(atpdev, 0x38) & 0x80;\n\tatp_writeb_base(atpdev, 0x38, k);\n\tatp_writeb_base(atpdev, 0x3b, 0x20);\n\tmsleep(32);\n\tatp_writeb_base(atpdev, 0x3b, 0);\n\tmsleep(32);\n\tatp_readb_io(atpdev, 0, 0x1b);\n\tatp_readb_io(atpdev, 0, 0x17);\n\n\tatp_set_host_id(atpdev, 0, host_id);\n\n\ttscam(shpnt, true, atp_readb_base(atpdev, 0x22));\n\tatp_is(atpdev, 0, true, atp_readb_base(atpdev, 0x3f) & 0x40);\n\tatp_writeb_base(atpdev, 0x38, 0xb0);\n\tshpnt->max_id = 16;\n\tshpnt->this_id = host_id;\n}\n\nstatic void atp885_init(struct Scsi_Host *shpnt)\n{\n\tstruct atp_unit *atpdev = shost_priv(shpnt);\n\tstruct pci_dev *pdev = atpdev->pdev;\n\tunsigned char k, m, c;\n\tunsigned int n;\n\tunsigned char setupdata[2][16];\n\n\tdev_info(&pdev->dev, \"ACARD AEC-67162 PCI Ultra3 LVD \"\n\t\t \"Host Adapter: IO:%lx, IRQ:%d.\\n\",\n\t\t shpnt->io_port, shpnt->irq);\n\n\tatpdev->ioport[0] = shpnt->io_port + 0x80;\n\tatpdev->ioport[1] = shpnt->io_port + 0xc0;\n\tatpdev->pciport[0] = shpnt->io_port + 0x40;\n\tatpdev->pciport[1] = shpnt->io_port + 0x50;\n\n\tc = atp_readb_base(atpdev, 0x29);\n\tatp_writeb_base(atpdev, 0x29, c | 0x04);\n\n\tn = 0x1f80;\n\twhile (n < 0x2000) {\n\t\tatp_writew_base(atpdev, 0x3c, n);\n\t\tif (atp_readl_base(atpdev, 0x38) == 0xffffffff)\n\t\t\tbreak;\n\t\tfor (m = 0; m < 2; m++) {\n\t\t\tatpdev->global_map[m] = 0;\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tatp_writew_base(atpdev, 0x3c, n++);\n\t\t\t\t((u32 *)&setupdata[m][0])[k] =\n\t\t\t\t\tatp_readl_base(atpdev, 0x38);\n\t\t\t}\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tatp_writew_base(atpdev, 0x3c, n++);\n\t\t\t\t((u32 *)&atpdev->sp[m][0])[k] =\n\t\t\t\t\tatp_readl_base(atpdev, 0x38);\n\t\t\t}\n\t\t\tn += 8;\n\t\t}\n\t}\n\tc = atp_readb_base(atpdev, 0x29);\n\tatp_writeb_base(atpdev, 0x29, c & 0xfb);\n\tfor (c = 0; c < 2; c++) {\n\t\tatpdev->ultra_map[c] = 0;\n\t\tatpdev->async[c] = 0;\n\t\tfor (k = 0; k < 16; k++) {\n\t\t\tn = 1 << k;\n\t\t\tif (atpdev->sp[c][k] > 1)\n\t\t\t\tatpdev->ultra_map[c] |= n;\n\t\t\telse\n\t\t\t\tif (atpdev->sp[c][k] == 0)\n\t\t\t\t\tatpdev->async[c] |= n;\n\t\t}\n\t\tatpdev->async[c] = ~(atpdev->async[c]);\n\n\t\tif (atpdev->global_map[c] == 0) {\n\t\t\tk = setupdata[c][1];\n\t\t\tif ((k & 0x40) != 0)\n\t\t\t\tatpdev->global_map[c] |= 0x20;\n\t\t\tk &= 0x07;\n\t\t\tatpdev->global_map[c] |= k;\n\t\t\tif ((setupdata[c][2] & 0x04) != 0)\n\t\t\t\tatpdev->global_map[c] |= 0x08;\n\t\t\tatpdev->host_id[c] = setupdata[c][0] & 0x07;\n\t\t}\n\t}\n\n\tk = atp_readb_base(atpdev, 0x28) & 0x8f;\n\tk |= 0x10;\n\tatp_writeb_base(atpdev, 0x28, k);\n\tatp_writeb_pci(atpdev, 0, 1, 0x80);\n\tatp_writeb_pci(atpdev, 1, 1, 0x80);\n\tmsleep(100);\n\tatp_writeb_pci(atpdev, 0, 1, 0);\n\tatp_writeb_pci(atpdev, 1, 1, 0);\n\tmsleep(1000);\n\tatp_readb_io(atpdev, 0, 0x1b);\n\tatp_readb_io(atpdev, 0, 0x17);\n\tatp_readb_io(atpdev, 1, 0x1b);\n\tatp_readb_io(atpdev, 1, 0x17);\n\n\tk = atpdev->host_id[0];\n\tif (k > 7)\n\t\tk = (k & 0x07) | 0x40;\n\tatp_set_host_id(atpdev, 0, k);\n\n\tk = atpdev->host_id[1];\n\tif (k > 7)\n\t\tk = (k & 0x07) | 0x40;\n\tatp_set_host_id(atpdev, 1, k);\n\n\tmsleep(600);  \n\tdev_info(&pdev->dev, \"Scanning Channel A SCSI Device ...\\n\");\n\tatp_is(atpdev, 0, true, atp_readb_io(atpdev, 0, 0x1b) >> 7);\n\tatp_writeb_io(atpdev, 0, 0x16, 0x80);\n\tdev_info(&pdev->dev, \"Scanning Channel B SCSI Device ...\\n\");\n\tatp_is(atpdev, 1, true, atp_readb_io(atpdev, 1, 0x1b) >> 7);\n\tatp_writeb_io(atpdev, 1, 0x16, 0x80);\n\tk = atp_readb_base(atpdev, 0x28) & 0xcf;\n\tk |= 0xc0;\n\tatp_writeb_base(atpdev, 0x28, k);\n\tk = atp_readb_base(atpdev, 0x1f) | 0x80;\n\tatp_writeb_base(atpdev, 0x1f, k);\n\tk = atp_readb_base(atpdev, 0x29) | 0x01;\n\tatp_writeb_base(atpdev, 0x29, k);\n\tshpnt->max_id = 16;\n\tshpnt->max_lun = (atpdev->global_map[0] & 0x07) + 1;\n\tshpnt->max_channel = 1;\n\tshpnt->this_id = atpdev->host_id[0];\n}\n\n \nstatic int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct Scsi_Host *shpnt = NULL;\n\tstruct atp_unit *atpdev;\n\tint err;\n\n\tif (ent->device == PCI_DEVICE_ID_ARTOP_AEC7610 && pdev->revision < 2) {\n\t\tdev_err(&pdev->dev, \"ATP850S chips (AEC6710L/F cards) are not supported.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\tgoto fail;\n\n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tprintk(KERN_ERR \"atp870u: DMA mask required but not available.\\n\");\n\t\terr = -EIO;\n\t\tgoto disable_device;\n\t}\n\n\terr = pci_request_regions(pdev, \"atp870u\");\n\tif (err)\n\t\tgoto disable_device;\n\tpci_set_master(pdev);\n\n\terr = -ENOMEM;\n\tshpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));\n\tif (!shpnt)\n\t\tgoto release_region;\n\n\tatpdev = shost_priv(shpnt);\n\n\tatpdev->host = shpnt;\n\tatpdev->pdev = pdev;\n\tpci_set_drvdata(pdev, atpdev);\n\n\tshpnt->io_port = pci_resource_start(pdev, 0);\n\tshpnt->io_port &= 0xfffffff8;\n\tshpnt->n_io_port = pci_resource_len(pdev, 0);\n\tatpdev->baseport = shpnt->io_port;\n\tshpnt->unique_id = shpnt->io_port;\n\tshpnt->irq = pdev->irq;\n\n\terr = atp870u_init_tables(shpnt);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Unable to allocate tables for Acard controller\\n\");\n\t\tgoto unregister;\n\t}\n\n\tif (is880(atpdev))\n\t\tatp880_init(shpnt);\n\telse if (is885(atpdev))\n\t\tatp885_init(shpnt);\n\telse\n\t\tatp870_init(shpnt);\n\n\terr = request_irq(shpnt->irq, atp870u_intr_handle, IRQF_SHARED, \"atp870u\", shpnt);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Unable to allocate IRQ %d.\\n\", shpnt->irq);\n\t\tgoto free_tables;\n\t}\n\n\terr = scsi_add_host(shpnt, &pdev->dev);\n\tif (err)\n\t\tgoto scsi_add_fail;\n\tscsi_scan_host(shpnt);\n\n\treturn 0;\n\nscsi_add_fail:\n\tfree_irq(shpnt->irq, shpnt);\nfree_tables:\n\tatp870u_free_tables(shpnt);\nunregister:\n\tscsi_host_put(shpnt);\nrelease_region:\n\tpci_release_regions(pdev);\ndisable_device:\n\tpci_disable_device(pdev);\nfail:\n\treturn err;\n}\n\n \n\nstatic int atp870u_abort(struct scsi_cmnd * SCpnt)\n{\n\tunsigned char  j, k, c;\n\tstruct scsi_cmnd *workrequ;\n\tstruct atp_unit *dev;\n\tstruct Scsi_Host *host;\n\thost = SCpnt->device->host;\n\n\tdev = (struct atp_unit *)&host->hostdata;\n\tc = scmd_channel(SCpnt);\n\tprintk(\" atp870u: abort Channel = %x \\n\", c);\n\tprintk(\"working=%x last_cmd=%x \", dev->working[c], dev->last_cmd[c]);\n\tprintk(\" quhdu=%x quendu=%x \", dev->quhd[c], dev->quend[c]);\n\tfor (j = 0; j < 0x18; j++) {\n\t\tprintk(\" r%2x=%2x\", j, atp_readb_io(dev, c, j));\n\t}\n\tprintk(\" r1c=%2x\", atp_readb_io(dev, c, 0x1c));\n\tprintk(\" r1f=%2x in_snd=%2x \", atp_readb_io(dev, c, 0x1f), dev->in_snd[c]);\n\tprintk(\" d00=%2x\", atp_readb_pci(dev, c, 0x00));\n\tprintk(\" d02=%2x\", atp_readb_pci(dev, c, 0x02));\n\tfor(j=0;j<16;j++) {\n\t   if (dev->id[c][j].curr_req != NULL) {\n\t\tworkrequ = dev->id[c][j].curr_req;\n\t\tprintk(\"\\n que cdb= \");\n\t\tfor (k=0; k < workrequ->cmd_len; k++) {\n\t\t    printk(\" %2x \",workrequ->cmnd[k]);\n\t\t}\n\t\tprintk(\" last_lenu= %x \",(unsigned int)dev->id[c][j].last_len);\n\t   }\n\t}\n\treturn SUCCESS;\n}\n\nstatic const char *atp870u_info(struct Scsi_Host *notused)\n{\n\tstatic char buffer[128];\n\n\tstrcpy(buffer, \"ACARD AEC-6710/6712/67160 PCI Ultra/W/LVD SCSI-3 Adapter Driver V2.6+ac \");\n\n\treturn buffer;\n}\n\nstatic int atp870u_show_info(struct seq_file *m, struct Scsi_Host *HBAptr)\n{\n\tseq_puts(m, \"ACARD AEC-671X Driver Version: 2.6+ac\\n\\n\"\n\t\t\"Adapter Configuration:\\n\");\n\tseq_printf(m, \"               Base IO: %#.4lx\\n\", HBAptr->io_port);\n\tseq_printf(m, \"                   IRQ: %d\\n\", HBAptr->irq);\n\treturn 0;\n}\n\n\nstatic int atp870u_biosparam(struct scsi_device *disk, struct block_device *dev,\n\t\t\tsector_t capacity, int *ip)\n{\n\tint heads, sectors, cylinders;\n\n\theads = 64;\n\tsectors = 32;\n\tcylinders = (unsigned long)capacity / (heads * sectors);\n\tif (cylinders > 1024) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\tcylinders = (unsigned long)capacity / (heads * sectors);\n\t}\n\tip[0] = heads;\n\tip[1] = sectors;\n\tip[2] = cylinders;\n\n\treturn 0;\n}\n\nstatic void atp870u_remove (struct pci_dev *pdev)\n{\n\tstruct atp_unit *devext = pci_get_drvdata(pdev);\n\tstruct Scsi_Host *pshost = devext->host;\n\n\tscsi_remove_host(pshost);\n\tfree_irq(pshost->irq, pshost);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tatp870u_free_tables(pshost);\n\tscsi_host_put(pshost);\n}\nMODULE_LICENSE(\"GPL\");\n\nstatic const struct scsi_host_template atp870u_template = {\n     .module\t\t\t= THIS_MODULE,\n     .name\t\t\t= \"atp870u\"\t\t ,\n     .proc_name\t\t\t= \"atp870u\",\n     .show_info\t\t\t= atp870u_show_info,\n     .info\t\t\t= atp870u_info\t\t ,\n     .queuecommand\t\t= atp870u_queuecommand\t ,\n     .eh_abort_handler\t\t= atp870u_abort\t\t ,\n     .bios_param\t\t= atp870u_biosparam\t ,\n     .can_queue\t\t\t= qcnt\t\t\t ,\n     .this_id\t\t\t= 7\t\t\t ,\n     .sg_tablesize\t\t= ATP870U_SCATTER\t ,\n     .max_sectors\t\t= ATP870U_MAX_SECTORS,\n};\n\nstatic struct pci_device_id atp870u_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, ATP885_DEVID)\t\t\t  },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, ATP880_DEVID1)\t\t  },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, ATP880_DEVID2)\t\t  },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7610)    },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7612UW)  },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7612U)   },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7612S)   },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7612D)\t  },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7612SUW) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_8060)\t  },\n\t{ 0, },\n};\n\nMODULE_DEVICE_TABLE(pci, atp870u_id_table);\n\nstatic struct pci_driver atp870u_driver = {\n\t.id_table\t= atp870u_id_table,\n\t.name\t\t= \"atp870u\",\n\t.probe\t\t= atp870u_probe,\n\t.remove\t\t= atp870u_remove,\n};\n\nmodule_pci_driver(atp870u_driver);\n\nstatic void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip,\n\t\t   unsigned char lvdmode)\n{\n\tunsigned char i, j, k, rmb, n;\n\tunsigned short int m;\n\tstatic unsigned char mbuf[512];\n\tstatic unsigned char satn[9] = { 0, 0, 0, 0, 0, 0, 0, 6, 6 };\n\tstatic unsigned char inqd[9] = { 0x12, 0, 0, 0, 0x24, 0, 0, 0x24, 6 };\n\tstatic unsigned char synn[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };\n\tunsigned char synu[6] = { 0x80, 1, 3, 1, 0x0a, 0x0e };\n\tstatic unsigned char synw[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };\n\tstatic unsigned char synw_870[6] = { 0x80, 1, 3, 1, 0x0c, 0x07 };\n\tunsigned char synuw[6] = { 0x80, 1, 3, 1, 0x0a, 0x0e };\n\tstatic unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };\n\tstatic unsigned char u3[9] = { 0x80, 1, 6, 4, 0x09, 00, 0x0e, 0x01, 0x02 };\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (!wide_chip && (i > 7))\n\t\t\tbreak;\n\t\tm = 1;\n\t\tm = m << i;\n\t\tif ((m & dev->active_id[c]) != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == dev->host_id[c]) {\n\t\t\tprintk(KERN_INFO \"         ID: %2d  Host Adapter\\n\", dev->host_id[c]);\n\t\t\tcontinue;\n\t\t}\n\t\tatp_writeb_io(dev, c, 0x1b, wide_chip ? 0x01 : 0x00);\n\t\tatp_writeb_io(dev, c, 1, 0x08);\n\t\tatp_writeb_io(dev, c, 2, 0x7f);\n\t\tatp_writeb_io(dev, c, 3, satn[0]);\n\t\tatp_writeb_io(dev, c, 4, satn[1]);\n\t\tatp_writeb_io(dev, c, 5, satn[2]);\n\t\tatp_writeb_io(dev, c, 6, satn[3]);\n\t\tatp_writeb_io(dev, c, 7, satn[4]);\n\t\tatp_writeb_io(dev, c, 8, satn[5]);\n\t\tatp_writeb_io(dev, c, 0x0f, 0);\n\t\tatp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);\n\t\tatp_writeb_io(dev, c, 0x12, 0);\n\t\tatp_writeb_io(dev, c, 0x13, satn[6]);\n\t\tatp_writeb_io(dev, c, 0x14, satn[7]);\n\t\tj = i;\n\t\tif ((j & 0x08) != 0) {\n\t\t\tj = (j & 0x07) | 0x40;\n\t\t}\n\t\tatp_writeb_io(dev, c, 0x15, j);\n\t\tatp_writeb_io(dev, c, 0x18, satn[8]);\n\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\n\t\t\tcpu_relax();\n\n\t\tif (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)\n\t\t\tcontinue;\n\n\t\twhile (atp_readb_io(dev, c, 0x17) != 0x8e)\n\t\t\tcpu_relax();\n\n\t\tdev->active_id[c] |= m;\n\n\t\tatp_writeb_io(dev, c, 0x10, 0x30);\n\t\tif (is885(dev) || is880(dev))\n\t\t\tatp_writeb_io(dev, c, 0x14, 0x00);\n\t\telse  \n\t\t\tatp_writeb_io(dev, c, 0x04, 0x00);\n\nphase_cmd:\n\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\n\t\t\tcpu_relax();\n\n\t\tj = atp_readb_io(dev, c, 0x17);\n\t\tif (j != 0x16) {\n\t\t\tatp_writeb_io(dev, c, 0x10, 0x41);\n\t\t\tgoto phase_cmd;\n\t\t}\nsel_ok:\n\t\tatp_writeb_io(dev, c, 3, inqd[0]);\n\t\tatp_writeb_io(dev, c, 4, inqd[1]);\n\t\tatp_writeb_io(dev, c, 5, inqd[2]);\n\t\tatp_writeb_io(dev, c, 6, inqd[3]);\n\t\tatp_writeb_io(dev, c, 7, inqd[4]);\n\t\tatp_writeb_io(dev, c, 8, inqd[5]);\n\t\tatp_writeb_io(dev, c, 0x0f, 0);\n\t\tatp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);\n\t\tatp_writeb_io(dev, c, 0x12, 0);\n\t\tatp_writeb_io(dev, c, 0x13, inqd[6]);\n\t\tatp_writeb_io(dev, c, 0x14, inqd[7]);\n\t\tatp_writeb_io(dev, c, 0x18, inqd[8]);\n\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\n\t\t\tcpu_relax();\n\n\t\tif (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)\n\t\t\tcontinue;\n\n\t\twhile (atp_readb_io(dev, c, 0x17) != 0x8e)\n\t\t\tcpu_relax();\n\n\t\tif (wide_chip)\n\t\t\tatp_writeb_io(dev, c, 0x1b, 0x00);\n\n\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\t\tj = 0;\nrd_inq_data:\n\t\tk = atp_readb_io(dev, c, 0x1f);\n\t\tif ((k & 0x01) != 0) {\n\t\t\tmbuf[j++] = atp_readb_io(dev, c, 0x19);\n\t\t\tgoto rd_inq_data;\n\t\t}\n\t\tif ((k & 0x80) == 0) {\n\t\t\tgoto rd_inq_data;\n\t\t}\n\t\tj = atp_readb_io(dev, c, 0x17);\n\t\tif (j == 0x16) {\n\t\t\tgoto inq_ok;\n\t\t}\n\t\tatp_writeb_io(dev, c, 0x10, 0x46);\n\t\tatp_writeb_io(dev, c, 0x12, 0);\n\t\tatp_writeb_io(dev, c, 0x13, 0);\n\t\tatp_writeb_io(dev, c, 0x14, 0);\n\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\n\t\t\tcpu_relax();\n\n\t\tif (atp_readb_io(dev, c, 0x17) != 0x16)\n\t\t\tgoto sel_ok;\n\ninq_ok:\n\t\tmbuf[36] = 0;\n\t\tprintk(KERN_INFO \"         ID: %2d  %s\\n\", i, &mbuf[8]);\n\t\tdev->id[c][i].devtype = mbuf[0];\n\t\trmb = mbuf[1];\n\t\tn = mbuf[7];\n\t\tif (!wide_chip)\n\t\t\tgoto not_wide;\n\t\tif ((mbuf[7] & 0x60) == 0) {\n\t\t\tgoto not_wide;\n\t\t}\n\t\tif (is885(dev) || is880(dev)) {\n\t\t\tif ((i < 8) && ((dev->global_map[c] & 0x20) == 0))\n\t\t\t\tgoto not_wide;\n\t\t} else {  \n\t\t\tif ((dev->global_map[c] & 0x20) == 0)\n\t\t\t\tgoto not_wide;\n\t\t}\n\t\tif (lvdmode == 0) {\n\t\t\tgoto chg_wide;\n\t\t}\n\t\tif (dev->sp[c][i] != 0x04)\t\n\t\t{\n\t\t\tgoto chg_wide;\n\t\t}\n\n\t\tatp_writeb_io(dev, c, 0x1b, 0x01);\n\t\tatp_writeb_io(dev, c, 3, satn[0]);\n\t\tatp_writeb_io(dev, c, 4, satn[1]);\n\t\tatp_writeb_io(dev, c, 5, satn[2]);\n\t\tatp_writeb_io(dev, c, 6, satn[3]);\n\t\tatp_writeb_io(dev, c, 7, satn[4]);\n\t\tatp_writeb_io(dev, c, 8, satn[5]);\n\t\tatp_writeb_io(dev, c, 0x0f, 0);\n\t\tatp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);\n\t\tatp_writeb_io(dev, c, 0x12, 0);\n\t\tatp_writeb_io(dev, c, 0x13, satn[6]);\n\t\tatp_writeb_io(dev, c, 0x14, satn[7]);\n\t\tatp_writeb_io(dev, c, 0x18, satn[8]);\n\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\n\t\t\tcpu_relax();\n\n\t\tif (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)\n\t\t\tcontinue;\n\n\t\twhile (atp_readb_io(dev, c, 0x17) != 0x8e)\n\t\t\tcpu_relax();\n\ntry_u3:\n\t\tj = 0;\n\t\tatp_writeb_io(dev, c, 0x14, 0x09);\n\t\tatp_writeb_io(dev, c, 0x18, 0x20);\n\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {\n\t\t\tif ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)\n\t\t\t\tatp_writeb_io(dev, c, 0x19, u3[j++]);\n\t\t\tcpu_relax();\n\t\t}\n\n\t\twhile ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)\n\t\t\tcpu_relax();\n\n\t\tj = atp_readb_io(dev, c, 0x17) & 0x0f;\n\t\tif (j == 0x0f) {\n\t\t\tgoto u3p_in;\n\t\t}\n\t\tif (j == 0x0a) {\n\t\t\tgoto u3p_cmd;\n\t\t}\n\t\tif (j == 0x0e) {\n\t\t\tgoto try_u3;\n\t\t}\n\t\tcontinue;\nu3p_out:\n\t\tatp_writeb_io(dev, c, 0x18, 0x20);\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {\n\t\t\tif ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)\n\t\t\t\tatp_writeb_io(dev, c, 0x19, 0);\n\t\t\tcpu_relax();\n\t\t}\n\t\tj = atp_readb_io(dev, c, 0x17) & 0x0f;\n\t\tif (j == 0x0f) {\n\t\t\tgoto u3p_in;\n\t\t}\n\t\tif (j == 0x0a) {\n\t\t\tgoto u3p_cmd;\n\t\t}\n\t\tif (j == 0x0e) {\n\t\t\tgoto u3p_out;\n\t\t}\n\t\tcontinue;\nu3p_in:\n\t\tatp_writeb_io(dev, c, 0x14, 0x09);\n\t\tatp_writeb_io(dev, c, 0x18, 0x20);\n\t\tk = 0;\nu3p_in1:\n\t\tj = atp_readb_io(dev, c, 0x1f);\n\t\tif ((j & 0x01) != 0) {\n\t\t\tmbuf[k++] = atp_readb_io(dev, c, 0x19);\n\t\t\tgoto u3p_in1;\n\t\t}\n\t\tif ((j & 0x80) == 0x00) {\n\t\t\tgoto u3p_in1;\n\t\t}\n\t\tj = atp_readb_io(dev, c, 0x17) & 0x0f;\n\t\tif (j == 0x0f) {\n\t\t\tgoto u3p_in;\n\t\t}\n\t\tif (j == 0x0a) {\n\t\t\tgoto u3p_cmd;\n\t\t}\n\t\tif (j == 0x0e) {\n\t\t\tgoto u3p_out;\n\t\t}\n\t\tcontinue;\nu3p_cmd:\n\t\tatp_writeb_io(dev, c, 0x10, 0x30);\n\t\tatp_writeb_io(dev, c, 0x14, 0x00);\n\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00);\n\n\t\tj = atp_readb_io(dev, c, 0x17);\n\t\tif (j != 0x16) {\n\t\t\tif (j == 0x4e) {\n\t\t\t\tgoto u3p_out;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (mbuf[0] != 0x01) {\n\t\t\tgoto chg_wide;\n\t\t}\n\t\tif (mbuf[1] != 0x06) {\n\t\t\tgoto chg_wide;\n\t\t}\n\t\tif (mbuf[2] != 0x04) {\n\t\t\tgoto chg_wide;\n\t\t}\n\t\tif (mbuf[3] == 0x09) {\n\t\t\tm = 1;\n\t\t\tm = m << i;\n\t\t\tdev->wide_id[c] |= m;\n\t\t\tdev->id[c][i].devsp = 0xce;\n#ifdef ED_DBGP\n\t\t\tprintk(\"dev->id[%2d][%2d].devsp = %2x\\n\",\n\t\t\t       c, i, dev->id[c][i].devsp);\n#endif\n\t\t\tcontinue;\n\t\t}\nchg_wide:\n\t\tatp_writeb_io(dev, c, 0x1b, 0x01);\n\t\tatp_writeb_io(dev, c, 3, satn[0]);\n\t\tatp_writeb_io(dev, c, 4, satn[1]);\n\t\tatp_writeb_io(dev, c, 5, satn[2]);\n\t\tatp_writeb_io(dev, c, 6, satn[3]);\n\t\tatp_writeb_io(dev, c, 7, satn[4]);\n\t\tatp_writeb_io(dev, c, 8, satn[5]);\n\t\tatp_writeb_io(dev, c, 0x0f, 0);\n\t\tatp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);\n\t\tatp_writeb_io(dev, c, 0x12, 0);\n\t\tatp_writeb_io(dev, c, 0x13, satn[6]);\n\t\tatp_writeb_io(dev, c, 0x14, satn[7]);\n\t\tatp_writeb_io(dev, c, 0x18, satn[8]);\n\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\n\t\t\tcpu_relax();\n\n\t\tif (atp_readb_io(dev, c, 0x17) != 0x11 &&\n\t\t    atp_readb_io(dev, c, 0x17) != 0x8e)\n\t\t\tcontinue;\n\n\t\twhile (atp_readb_io(dev, c, 0x17) != 0x8e)\n\t\t\tcpu_relax();\n\ntry_wide:\n\t\tj = 0;\n\t\tatp_writeb_io(dev, c, 0x14, 0x05);\n\t\tatp_writeb_io(dev, c, 0x18, 0x20);\n\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {\n\t\t\tif ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)\n\t\t\t\tatp_writeb_io(dev, c, 0x19, wide[j++]);\n\t\t\tcpu_relax();\n\t\t}\n\n\t\twhile ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)\n\t\t\tcpu_relax();\n\n\t\tj = atp_readb_io(dev, c, 0x17) & 0x0f;\n\t\tif (j == 0x0f) {\n\t\t\tgoto widep_in;\n\t\t}\n\t\tif (j == 0x0a) {\n\t\t\tgoto widep_cmd;\n\t\t}\n\t\tif (j == 0x0e) {\n\t\t\tgoto try_wide;\n\t\t}\n\t\tcontinue;\nwidep_out:\n\t\tatp_writeb_io(dev, c, 0x18, 0x20);\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {\n\t\t\tif ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)\n\t\t\t\tatp_writeb_io(dev, c, 0x19, 0);\n\t\t\tcpu_relax();\n\t\t}\n\t\tj = atp_readb_io(dev, c, 0x17) & 0x0f;\n\t\tif (j == 0x0f) {\n\t\t\tgoto widep_in;\n\t\t}\n\t\tif (j == 0x0a) {\n\t\t\tgoto widep_cmd;\n\t\t}\n\t\tif (j == 0x0e) {\n\t\t\tgoto widep_out;\n\t\t}\n\t\tcontinue;\nwidep_in:\n\t\tatp_writeb_io(dev, c, 0x14, 0xff);\n\t\tatp_writeb_io(dev, c, 0x18, 0x20);\n\t\tk = 0;\nwidep_in1:\n\t\tj = atp_readb_io(dev, c, 0x1f);\n\t\tif ((j & 0x01) != 0) {\n\t\t\tmbuf[k++] = atp_readb_io(dev, c, 0x19);\n\t\t\tgoto widep_in1;\n\t\t}\n\t\tif ((j & 0x80) == 0x00) {\n\t\t\tgoto widep_in1;\n\t\t}\n\t\tj = atp_readb_io(dev, c, 0x17) & 0x0f;\n\t\tif (j == 0x0f) {\n\t\t\tgoto widep_in;\n\t\t}\n\t\tif (j == 0x0a) {\n\t\t\tgoto widep_cmd;\n\t\t}\n\t\tif (j == 0x0e) {\n\t\t\tgoto widep_out;\n\t\t}\n\t\tcontinue;\nwidep_cmd:\n\t\tatp_writeb_io(dev, c, 0x10, 0x30);\n\t\tatp_writeb_io(dev, c, 0x14, 0x00);\n\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\n\t\t\tcpu_relax();\n\n\t\tj = atp_readb_io(dev, c, 0x17);\n\t\tif (j != 0x16) {\n\t\t\tif (j == 0x4e) {\n\t\t\t\tgoto widep_out;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (mbuf[0] != 0x01) {\n\t\t\tgoto not_wide;\n\t\t}\n\t\tif (mbuf[1] != 0x02) {\n\t\t\tgoto not_wide;\n\t\t}\n\t\tif (mbuf[2] != 0x03) {\n\t\t\tgoto not_wide;\n\t\t}\n\t\tif (mbuf[3] != 0x01) {\n\t\t\tgoto not_wide;\n\t\t}\n\t\tm = 1;\n\t\tm = m << i;\n\t\tdev->wide_id[c] |= m;\nnot_wide:\n\t\tif ((dev->id[c][i].devtype == 0x00) ||\n\t\t    (dev->id[c][i].devtype == 0x07) ||\n\t\t    ((dev->id[c][i].devtype == 0x05) && ((n & 0x10) != 0))) {\n\t\t\tm = 1;\n\t\t\tm = m << i;\n\t\t\tif ((dev->async[c] & m) != 0) {\n\t\t\t\tgoto set_sync;\n\t\t\t}\n\t\t}\n\t\tcontinue;\nset_sync:\n\t\tif ((!is885(dev) && !is880(dev)) || (dev->sp[c][i] == 0x02)) {\n\t\t\tsynu[4] = 0x0c;\n\t\t\tsynuw[4] = 0x0c;\n\t\t} else {\n\t\t\tif (dev->sp[c][i] >= 0x03) {\n\t\t\t\tsynu[4] = 0x0a;\n\t\t\t\tsynuw[4] = 0x0a;\n\t\t\t}\n\t\t}\n\t\tj = 0;\n\t\tif ((m & dev->wide_id[c]) != 0) {\n\t\t\tj |= 0x01;\n\t\t}\n\t\tatp_writeb_io(dev, c, 0x1b, j);\n\t\tatp_writeb_io(dev, c, 3, satn[0]);\n\t\tatp_writeb_io(dev, c, 4, satn[1]);\n\t\tatp_writeb_io(dev, c, 5, satn[2]);\n\t\tatp_writeb_io(dev, c, 6, satn[3]);\n\t\tatp_writeb_io(dev, c, 7, satn[4]);\n\t\tatp_writeb_io(dev, c, 8, satn[5]);\n\t\tatp_writeb_io(dev, c, 0x0f, 0);\n\t\tatp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);\n\t\tatp_writeb_io(dev, c, 0x12, 0);\n\t\tatp_writeb_io(dev, c, 0x13, satn[6]);\n\t\tatp_writeb_io(dev, c, 0x14, satn[7]);\n\t\tatp_writeb_io(dev, c, 0x18, satn[8]);\n\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\n\t\t\tcpu_relax();\n\n\t\tif (atp_readb_io(dev, c, 0x17) != 0x11 &&\n\t\t    atp_readb_io(dev, c, 0x17) != 0x8e)\n\t\t\tcontinue;\n\n\t\twhile (atp_readb_io(dev, c, 0x17) != 0x8e)\n\t\t\tcpu_relax();\n\ntry_sync:\n\t\tj = 0;\n\t\tatp_writeb_io(dev, c, 0x14, 0x06);\n\t\tatp_writeb_io(dev, c, 0x18, 0x20);\n\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {\n\t\t\tif ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0) {\n\t\t\t\tif ((m & dev->wide_id[c]) != 0) {\n\t\t\t\t\tif (is885(dev) || is880(dev)) {\n\t\t\t\t\t\tif ((m & dev->ultra_map[c]) != 0) {\n\t\t\t\t\t\t\tatp_writeb_io(dev, c, 0x19, synuw[j++]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tatp_writeb_io(dev, c, 0x19, synw[j++]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tatp_writeb_io(dev, c, 0x19, synw_870[j++]);\n\t\t\t\t} else {\n\t\t\t\t\tif ((m & dev->ultra_map[c]) != 0) {\n\t\t\t\t\t\tatp_writeb_io(dev, c, 0x19, synu[j++]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tatp_writeb_io(dev, c, 0x19, synn[j++]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)\n\t\t\tcpu_relax();\n\n\t\tj = atp_readb_io(dev, c, 0x17) & 0x0f;\n\t\tif (j == 0x0f) {\n\t\t\tgoto phase_ins;\n\t\t}\n\t\tif (j == 0x0a) {\n\t\t\tgoto phase_cmds;\n\t\t}\n\t\tif (j == 0x0e) {\n\t\t\tgoto try_sync;\n\t\t}\n\t\tcontinue;\nphase_outs:\n\t\tatp_writeb_io(dev, c, 0x18, 0x20);\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00) {\n\t\t\tif ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0x00)\n\t\t\t\tatp_writeb_io(dev, c, 0x19, 0x00);\n\t\t\tcpu_relax();\n\t\t}\n\t\tj = atp_readb_io(dev, c, 0x17);\n\t\tif (j == 0x85) {\n\t\t\tgoto tar_dcons;\n\t\t}\n\t\tj &= 0x0f;\n\t\tif (j == 0x0f) {\n\t\t\tgoto phase_ins;\n\t\t}\n\t\tif (j == 0x0a) {\n\t\t\tgoto phase_cmds;\n\t\t}\n\t\tif (j == 0x0e) {\n\t\t\tgoto phase_outs;\n\t\t}\n\t\tcontinue;\nphase_ins:\n\t\tif (is885(dev) || is880(dev))\n\t\t\tatp_writeb_io(dev, c, 0x14, 0x06);\n\t\telse\n\t\t\tatp_writeb_io(dev, c, 0x14, 0xff);\n\t\tatp_writeb_io(dev, c, 0x18, 0x20);\n\t\tk = 0;\nphase_ins1:\n\t\tj = atp_readb_io(dev, c, 0x1f);\n\t\tif ((j & 0x01) != 0x00) {\n\t\t\tmbuf[k++] = atp_readb_io(dev, c, 0x19);\n\t\t\tgoto phase_ins1;\n\t\t}\n\t\tif ((j & 0x80) == 0x00) {\n\t\t\tgoto phase_ins1;\n\t\t}\n\n\t\twhile ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00);\n\n\t\tj = atp_readb_io(dev, c, 0x17);\n\t\tif (j == 0x85) {\n\t\t\tgoto tar_dcons;\n\t\t}\n\t\tj &= 0x0f;\n\t\tif (j == 0x0f) {\n\t\t\tgoto phase_ins;\n\t\t}\n\t\tif (j == 0x0a) {\n\t\t\tgoto phase_cmds;\n\t\t}\n\t\tif (j == 0x0e) {\n\t\t\tgoto phase_outs;\n\t\t}\n\t\tcontinue;\nphase_cmds:\n\t\tatp_writeb_io(dev, c, 0x10, 0x30);\ntar_dcons:\n\t\tatp_writeb_io(dev, c, 0x14, 0x00);\n\t\tatp_writeb_io(dev, c, 0x18, 0x08);\n\n\t\twhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\n\t\t\tcpu_relax();\n\n\t\tj = atp_readb_io(dev, c, 0x17);\n\t\tif (j != 0x16) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (mbuf[0] != 0x01) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (mbuf[1] != 0x03) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (mbuf[4] == 0x00) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (mbuf[3] > 0x64) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (is885(dev) || is880(dev)) {\n\t\t\tif (mbuf[4] > 0x0e) {\n\t\t\t\tmbuf[4] = 0x0e;\n\t\t\t}\n\t\t} else {\n\t\t\tif (mbuf[4] > 0x0c) {\n\t\t\t\tmbuf[4] = 0x0c;\n\t\t\t}\n\t\t}\n\t\tdev->id[c][i].devsp = mbuf[4];\n\t\tif (is885(dev) || is880(dev))\n\t\t\tif (mbuf[3] < 0x0c) {\n\t\t\t\tj = 0xb0;\n\t\t\t\tgoto set_syn_ok;\n\t\t\t}\n\t\tif ((mbuf[3] < 0x0d) && (rmb == 0)) {\n\t\t\tj = 0xa0;\n\t\t\tgoto set_syn_ok;\n\t\t}\n\t\tif (mbuf[3] < 0x1a) {\n\t\t\tj = 0x20;\n\t\t\tgoto set_syn_ok;\n\t\t}\n\t\tif (mbuf[3] < 0x33) {\n\t\t\tj = 0x40;\n\t\t\tgoto set_syn_ok;\n\t\t}\n\t\tif (mbuf[3] < 0x4c) {\n\t\t\tj = 0x50;\n\t\t\tgoto set_syn_ok;\n\t\t}\n\t\tj = 0x60;\nset_syn_ok:\n\t\tdev->id[c][i].devsp = (dev->id[c][i].devsp & 0x0f) | j;\n#ifdef ED_DBGP\n\t\tprintk(\"dev->id[%2d][%2d].devsp = %2x\\n\",\n\t\t       c,i,dev->id[c][i].devsp);\n#endif\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}