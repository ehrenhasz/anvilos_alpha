{
  "module_name": "hosts.c",
  "hash_id": "bcf6497cf105969f183eea600df61853a38e445c764137467b3b31d89a9ffcf8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/hosts.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/completion.h>\n#include <linux/transport_class.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/idr.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_cmnd.h>\n\n#include \"scsi_priv.h\"\n#include \"scsi_logging.h\"\n\n\nstatic int shost_eh_deadline = -1;\n\nmodule_param_named(eh_deadline, shost_eh_deadline, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(eh_deadline,\n\t\t \"SCSI EH timeout in seconds (should be between 0 and 2^31-1)\");\n\nstatic DEFINE_IDA(host_index_ida);\n\n\nstatic void scsi_host_cls_release(struct device *dev)\n{\n\tput_device(&class_to_shost(dev)->shost_gendev);\n}\n\nstatic struct class shost_class = {\n\t.name\t\t= \"scsi_host\",\n\t.dev_release\t= scsi_host_cls_release,\n\t.dev_groups\t= scsi_shost_groups,\n};\n\n \nint scsi_host_set_state(struct Scsi_Host *shost, enum scsi_host_state state)\n{\n\tenum scsi_host_state oldstate = shost->shost_state;\n\n\tif (state == oldstate)\n\t\treturn 0;\n\n\tswitch (state) {\n\tcase SHOST_CREATED:\n\t\t \n\t\tgoto illegal;\n\n\tcase SHOST_RUNNING:\n\t\tswitch (oldstate) {\n\t\tcase SHOST_CREATED:\n\t\tcase SHOST_RECOVERY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto illegal;\n\t\t}\n\t\tbreak;\n\n\tcase SHOST_RECOVERY:\n\t\tswitch (oldstate) {\n\t\tcase SHOST_RUNNING:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto illegal;\n\t\t}\n\t\tbreak;\n\n\tcase SHOST_CANCEL:\n\t\tswitch (oldstate) {\n\t\tcase SHOST_CREATED:\n\t\tcase SHOST_RUNNING:\n\t\tcase SHOST_CANCEL_RECOVERY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto illegal;\n\t\t}\n\t\tbreak;\n\n\tcase SHOST_DEL:\n\t\tswitch (oldstate) {\n\t\tcase SHOST_CANCEL:\n\t\tcase SHOST_DEL_RECOVERY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto illegal;\n\t\t}\n\t\tbreak;\n\n\tcase SHOST_CANCEL_RECOVERY:\n\t\tswitch (oldstate) {\n\t\tcase SHOST_CANCEL:\n\t\tcase SHOST_RECOVERY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto illegal;\n\t\t}\n\t\tbreak;\n\n\tcase SHOST_DEL_RECOVERY:\n\t\tswitch (oldstate) {\n\t\tcase SHOST_CANCEL_RECOVERY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto illegal;\n\t\t}\n\t\tbreak;\n\t}\n\tshost->shost_state = state;\n\treturn 0;\n\n illegal:\n\tSCSI_LOG_ERROR_RECOVERY(1,\n\t\t\t\tshost_printk(KERN_ERR, shost,\n\t\t\t\t\t     \"Illegal host state transition\"\n\t\t\t\t\t     \"%s->%s\\n\",\n\t\t\t\t\t     scsi_host_state_name(oldstate),\n\t\t\t\t\t     scsi_host_state_name(state)));\n\treturn -EINVAL;\n}\n\n \nvoid scsi_remove_host(struct Scsi_Host *shost)\n{\n\tunsigned long flags;\n\n\tmutex_lock(&shost->scan_mutex);\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (scsi_host_set_state(shost, SHOST_CANCEL))\n\t\tif (scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY)) {\n\t\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\t\tmutex_unlock(&shost->scan_mutex);\n\t\t\treturn;\n\t\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tscsi_autopm_get_host(shost);\n\tflush_workqueue(shost->tmf_work_q);\n\tscsi_forget_host(shost);\n\tmutex_unlock(&shost->scan_mutex);\n\tscsi_proc_host_rm(shost);\n\tscsi_proc_hostdir_rm(shost->hostt);\n\n\t \n\tkref_put(&shost->tagset_refcnt, scsi_mq_free_tags);\n\twait_for_completion(&shost->tagset_freed);\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (scsi_host_set_state(shost, SHOST_DEL))\n\t\tBUG_ON(scsi_host_set_state(shost, SHOST_DEL_RECOVERY));\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\ttransport_unregister_device(&shost->shost_gendev);\n\tdevice_unregister(&shost->shost_dev);\n\tdevice_del(&shost->shost_gendev);\n}\nEXPORT_SYMBOL(scsi_remove_host);\n\n \nint scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,\n\t\t\t   struct device *dma_dev)\n{\n\tconst struct scsi_host_template *sht = shost->hostt;\n\tint error = -EINVAL;\n\n\tshost_printk(KERN_INFO, shost, \"%s\\n\",\n\t\t\tsht->info ? sht->info(shost) : sht->name);\n\n\tif (!shost->can_queue) {\n\t\tshost_printk(KERN_ERR, shost,\n\t\t\t     \"can_queue = 0 no longer supported\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tshost->cmd_per_lun = min_t(int, shost->cmd_per_lun,\n\t\t\t\t   shost->can_queue);\n\n\terror = scsi_init_sense_cache(shost);\n\tif (error)\n\t\tgoto fail;\n\n\tif (!shost->shost_gendev.parent)\n\t\tshost->shost_gendev.parent = dev ? dev : &platform_bus;\n\tif (!dma_dev)\n\t\tdma_dev = shost->shost_gendev.parent;\n\n\tshost->dma_dev = dma_dev;\n\n\tif (dma_dev->dma_mask) {\n\t\tshost->max_sectors = min_t(unsigned int, shost->max_sectors,\n\t\t\t\tdma_max_mapping_size(dma_dev) >> SECTOR_SHIFT);\n\t}\n\n\terror = scsi_mq_setup_tags(shost);\n\tif (error)\n\t\tgoto fail;\n\n\tkref_init(&shost->tagset_refcnt);\n\tinit_completion(&shost->tagset_freed);\n\n\t \n\tpm_runtime_get_noresume(&shost->shost_gendev);\n\tpm_runtime_set_active(&shost->shost_gendev);\n\tpm_runtime_enable(&shost->shost_gendev);\n\tdevice_enable_async_suspend(&shost->shost_gendev);\n\n\terror = device_add(&shost->shost_gendev);\n\tif (error)\n\t\tgoto out_disable_runtime_pm;\n\n\tscsi_host_set_state(shost, SHOST_RUNNING);\n\tget_device(shost->shost_gendev.parent);\n\n\tdevice_enable_async_suspend(&shost->shost_dev);\n\n\tget_device(&shost->shost_gendev);\n\terror = device_add(&shost->shost_dev);\n\tif (error)\n\t\tgoto out_del_gendev;\n\n\tif (shost->transportt->host_size) {\n\t\tshost->shost_data = kzalloc(shost->transportt->host_size,\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (shost->shost_data == NULL) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_del_dev;\n\t\t}\n\t}\n\n\tif (shost->transportt->create_work_queue) {\n\t\tsnprintf(shost->work_q_name, sizeof(shost->work_q_name),\n\t\t\t \"scsi_wq_%d\", shost->host_no);\n\t\tshost->work_q = alloc_workqueue(\"%s\",\n\t\t\tWQ_SYSFS | __WQ_LEGACY | WQ_MEM_RECLAIM | WQ_UNBOUND,\n\t\t\t1, shost->work_q_name);\n\n\t\tif (!shost->work_q) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_del_dev;\n\t\t}\n\t}\n\n\terror = scsi_sysfs_add_host(shost);\n\tif (error)\n\t\tgoto out_del_dev;\n\n\tscsi_proc_host_add(shost);\n\tscsi_autopm_put_host(shost);\n\treturn error;\n\n\t \n out_del_dev:\n\tdevice_del(&shost->shost_dev);\n out_del_gendev:\n\t \n\tput_device(&shost->shost_dev);\n\tdevice_del(&shost->shost_gendev);\n out_disable_runtime_pm:\n\tdevice_disable_async_suspend(&shost->shost_gendev);\n\tpm_runtime_disable(&shost->shost_gendev);\n\tpm_runtime_set_suspended(&shost->shost_gendev);\n\tpm_runtime_put_noidle(&shost->shost_gendev);\n\tkref_put(&shost->tagset_refcnt, scsi_mq_free_tags);\n fail:\n\treturn error;\n}\nEXPORT_SYMBOL(scsi_add_host_with_dma);\n\nstatic void scsi_host_dev_release(struct device *dev)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(dev);\n\tstruct device *parent = dev->parent;\n\n\t \n\trcu_barrier();\n\n\tif (shost->tmf_work_q)\n\t\tdestroy_workqueue(shost->tmf_work_q);\n\tif (shost->ehandler)\n\t\tkthread_stop(shost->ehandler);\n\tif (shost->work_q)\n\t\tdestroy_workqueue(shost->work_q);\n\n\tif (shost->shost_state == SHOST_CREATED) {\n\t\t \n\t\tkfree(dev_name(&shost->shost_dev));\n\t}\n\n\tkfree(shost->shost_data);\n\n\tida_free(&host_index_ida, shost->host_no);\n\n\tif (shost->shost_state != SHOST_CREATED)\n\t\tput_device(parent);\n\tkfree(shost);\n}\n\nstatic struct device_type scsi_host_type = {\n\t.name =\t\t\"scsi_host\",\n\t.release =\tscsi_host_dev_release,\n};\n\n \nstruct Scsi_Host *scsi_host_alloc(const struct scsi_host_template *sht, int privsize)\n{\n\tstruct Scsi_Host *shost;\n\tint index;\n\n\tshost = kzalloc(sizeof(struct Scsi_Host) + privsize, GFP_KERNEL);\n\tif (!shost)\n\t\treturn NULL;\n\n\tshost->host_lock = &shost->default_lock;\n\tspin_lock_init(shost->host_lock);\n\tshost->shost_state = SHOST_CREATED;\n\tINIT_LIST_HEAD(&shost->__devices);\n\tINIT_LIST_HEAD(&shost->__targets);\n\tINIT_LIST_HEAD(&shost->eh_abort_list);\n\tINIT_LIST_HEAD(&shost->eh_cmd_q);\n\tINIT_LIST_HEAD(&shost->starved_list);\n\tinit_waitqueue_head(&shost->host_wait);\n\tmutex_init(&shost->scan_mutex);\n\n\tindex = ida_alloc(&host_index_ida, GFP_KERNEL);\n\tif (index < 0) {\n\t\tkfree(shost);\n\t\treturn NULL;\n\t}\n\tshost->host_no = index;\n\n\tshost->dma_channel = 0xff;\n\n\t \n\tshost->max_channel = 0;\n\tshost->max_id = 8;\n\tshost->max_lun = 8;\n\n\t \n\tshost->transportt = &blank_transport_template;\n\n\t \n\tshost->max_cmd_len = 12;\n\tshost->hostt = sht;\n\tshost->this_id = sht->this_id;\n\tshost->can_queue = sht->can_queue;\n\tshost->sg_tablesize = sht->sg_tablesize;\n\tshost->sg_prot_tablesize = sht->sg_prot_tablesize;\n\tshost->cmd_per_lun = sht->cmd_per_lun;\n\tshost->no_write_same = sht->no_write_same;\n\tshost->host_tagset = sht->host_tagset;\n\tshost->queuecommand_may_block = sht->queuecommand_may_block;\n\n\tif (shost_eh_deadline == -1 || !sht->eh_host_reset_handler)\n\t\tshost->eh_deadline = -1;\n\telse if ((ulong) shost_eh_deadline * HZ > INT_MAX) {\n\t\tshost_printk(KERN_WARNING, shost,\n\t\t\t     \"eh_deadline %u too large, setting to %u\\n\",\n\t\t\t     shost_eh_deadline, INT_MAX / HZ);\n\t\tshost->eh_deadline = INT_MAX;\n\t} else\n\t\tshost->eh_deadline = shost_eh_deadline * HZ;\n\n\tif (sht->supported_mode == MODE_UNKNOWN)\n\t\t \n\t\tshost->active_mode = MODE_INITIATOR;\n\telse\n\t\tshost->active_mode = sht->supported_mode;\n\n\tif (sht->max_host_blocked)\n\t\tshost->max_host_blocked = sht->max_host_blocked;\n\telse\n\t\tshost->max_host_blocked = SCSI_DEFAULT_HOST_BLOCKED;\n\n\t \n\tif (sht->max_sectors)\n\t\tshost->max_sectors = sht->max_sectors;\n\telse\n\t\tshost->max_sectors = SCSI_DEFAULT_MAX_SECTORS;\n\n\tif (sht->max_segment_size)\n\t\tshost->max_segment_size = sht->max_segment_size;\n\telse\n\t\tshost->max_segment_size = BLK_MAX_SEGMENT_SIZE;\n\n\t \n\tif (sht->dma_boundary)\n\t\tshost->dma_boundary = sht->dma_boundary;\n\telse\n\t\tshost->dma_boundary = 0xffffffff;\n\n\tif (sht->virt_boundary_mask)\n\t\tshost->virt_boundary_mask = sht->virt_boundary_mask;\n\n\tdevice_initialize(&shost->shost_gendev);\n\tdev_set_name(&shost->shost_gendev, \"host%d\", shost->host_no);\n\tshost->shost_gendev.bus = &scsi_bus_type;\n\tshost->shost_gendev.type = &scsi_host_type;\n\tscsi_enable_async_suspend(&shost->shost_gendev);\n\n\tdevice_initialize(&shost->shost_dev);\n\tshost->shost_dev.parent = &shost->shost_gendev;\n\tshost->shost_dev.class = &shost_class;\n\tdev_set_name(&shost->shost_dev, \"host%d\", shost->host_no);\n\tshost->shost_dev.groups = sht->shost_groups;\n\n\tshost->ehandler = kthread_run(scsi_error_handler, shost,\n\t\t\t\"scsi_eh_%d\", shost->host_no);\n\tif (IS_ERR(shost->ehandler)) {\n\t\tshost_printk(KERN_WARNING, shost,\n\t\t\t\"error handler thread failed to spawn, error = %ld\\n\",\n\t\t\tPTR_ERR(shost->ehandler));\n\t\tshost->ehandler = NULL;\n\t\tgoto fail;\n\t}\n\n\tshost->tmf_work_q = alloc_workqueue(\"scsi_tmf_%d\",\n\t\t\t\t\tWQ_UNBOUND | WQ_MEM_RECLAIM | WQ_SYSFS,\n\t\t\t\t\t   1, shost->host_no);\n\tif (!shost->tmf_work_q) {\n\t\tshost_printk(KERN_WARNING, shost,\n\t\t\t     \"failed to create tmf workq\\n\");\n\t\tgoto fail;\n\t}\n\tif (scsi_proc_hostdir_add(shost->hostt) < 0)\n\t\tgoto fail;\n\treturn shost;\n fail:\n\t \n\tput_device(&shost->shost_gendev);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(scsi_host_alloc);\n\nstatic int __scsi_host_match(struct device *dev, const void *data)\n{\n\tstruct Scsi_Host *p;\n\tconst unsigned int *hostnum = data;\n\n\tp = class_to_shost(dev);\n\treturn p->host_no == *hostnum;\n}\n\n \nstruct Scsi_Host *scsi_host_lookup(unsigned int hostnum)\n{\n\tstruct device *cdev;\n\tstruct Scsi_Host *shost = NULL;\n\n\tcdev = class_find_device(&shost_class, NULL, &hostnum,\n\t\t\t\t __scsi_host_match);\n\tif (cdev) {\n\t\tshost = scsi_host_get(class_to_shost(cdev));\n\t\tput_device(cdev);\n\t}\n\treturn shost;\n}\nEXPORT_SYMBOL(scsi_host_lookup);\n\n \nstruct Scsi_Host *scsi_host_get(struct Scsi_Host *shost)\n{\n\tif ((shost->shost_state == SHOST_DEL) ||\n\t\t!get_device(&shost->shost_gendev))\n\t\treturn NULL;\n\treturn shost;\n}\nEXPORT_SYMBOL(scsi_host_get);\n\nstatic bool scsi_host_check_in_flight(struct request *rq, void *data)\n{\n\tint *count = data;\n\tstruct scsi_cmnd *cmd = blk_mq_rq_to_pdu(rq);\n\n\tif (test_bit(SCMD_STATE_INFLIGHT, &cmd->state))\n\t\t(*count)++;\n\n\treturn true;\n}\n\n \nint scsi_host_busy(struct Scsi_Host *shost)\n{\n\tint cnt = 0;\n\n\tblk_mq_tagset_busy_iter(&shost->tag_set,\n\t\t\t\tscsi_host_check_in_flight, &cnt);\n\treturn cnt;\n}\nEXPORT_SYMBOL(scsi_host_busy);\n\n \nvoid scsi_host_put(struct Scsi_Host *shost)\n{\n\tput_device(&shost->shost_gendev);\n}\nEXPORT_SYMBOL(scsi_host_put);\n\nint scsi_init_hosts(void)\n{\n\treturn class_register(&shost_class);\n}\n\nvoid scsi_exit_hosts(void)\n{\n\tclass_unregister(&shost_class);\n\tida_destroy(&host_index_ida);\n}\n\nint scsi_is_host_device(const struct device *dev)\n{\n\treturn dev->type == &scsi_host_type;\n}\nEXPORT_SYMBOL(scsi_is_host_device);\n\n \nint scsi_queue_work(struct Scsi_Host *shost, struct work_struct *work)\n{\n\tif (unlikely(!shost->work_q)) {\n\t\tshost_printk(KERN_ERR, shost,\n\t\t\t\"ERROR: Scsi host '%s' attempted to queue scsi-work, \"\n\t\t\t\"when no workqueue created.\\n\", shost->hostt->name);\n\t\tdump_stack();\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn queue_work(shost->work_q, work);\n}\nEXPORT_SYMBOL_GPL(scsi_queue_work);\n\n \nvoid scsi_flush_work(struct Scsi_Host *shost)\n{\n\tif (!shost->work_q) {\n\t\tshost_printk(KERN_ERR, shost,\n\t\t\t\"ERROR: Scsi host '%s' attempted to flush scsi-work, \"\n\t\t\t\"when no workqueue created.\\n\", shost->hostt->name);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\tflush_workqueue(shost->work_q);\n}\nEXPORT_SYMBOL_GPL(scsi_flush_work);\n\nstatic bool complete_all_cmds_iter(struct request *rq, void *data)\n{\n\tstruct scsi_cmnd *scmd = blk_mq_rq_to_pdu(rq);\n\tenum scsi_host_status status = *(enum scsi_host_status *)data;\n\n\tscsi_dma_unmap(scmd);\n\tscmd->result = 0;\n\tset_host_byte(scmd, status);\n\tscsi_done(scmd);\n\treturn true;\n}\n\n \nvoid scsi_host_complete_all_commands(struct Scsi_Host *shost,\n\t\t\t\t     enum scsi_host_status status)\n{\n\tblk_mq_tagset_busy_iter(&shost->tag_set, complete_all_cmds_iter,\n\t\t\t\t&status);\n}\nEXPORT_SYMBOL_GPL(scsi_host_complete_all_commands);\n\nstruct scsi_host_busy_iter_data {\n\tbool (*fn)(struct scsi_cmnd *, void *);\n\tvoid *priv;\n};\n\nstatic bool __scsi_host_busy_iter_fn(struct request *req, void *priv)\n{\n\tstruct scsi_host_busy_iter_data *iter_data = priv;\n\tstruct scsi_cmnd *sc = blk_mq_rq_to_pdu(req);\n\n\treturn iter_data->fn(sc, iter_data->priv);\n}\n\n \nvoid scsi_host_busy_iter(struct Scsi_Host *shost,\n\t\t\t bool (*fn)(struct scsi_cmnd *, void *),\n\t\t\t void *priv)\n{\n\tstruct scsi_host_busy_iter_data iter_data = {\n\t\t.fn = fn,\n\t\t.priv = priv,\n\t};\n\n\tblk_mq_tagset_busy_iter(&shost->tag_set, __scsi_host_busy_iter_fn,\n\t\t\t\t&iter_data);\n}\nEXPORT_SYMBOL_GPL(scsi_host_busy_iter);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}