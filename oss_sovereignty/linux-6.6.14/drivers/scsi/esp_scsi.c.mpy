{
  "module_name": "esp_scsi.c",
  "hash_id": "20ee06ff114bfa7ff9d71c105c70d32d9321883f8119dce7d214eece914eba2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/esp_scsi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/list.h>\n#include <linux/completion.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/irqreturn.h>\n\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <asm/dma.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_transport_spi.h>\n\n#include \"esp_scsi.h\"\n\n#define DRV_MODULE_NAME\t\t\"esp\"\n#define PFX DRV_MODULE_NAME\t\": \"\n#define DRV_VERSION\t\t\"2.000\"\n#define DRV_MODULE_RELDATE\t\"April 19, 2007\"\n\n \nstatic int esp_bus_reset_settle = 3;\n\nstatic u32 esp_debug;\n#define ESP_DEBUG_INTR\t\t0x00000001\n#define ESP_DEBUG_SCSICMD\t0x00000002\n#define ESP_DEBUG_RESET\t\t0x00000004\n#define ESP_DEBUG_MSGIN\t\t0x00000008\n#define ESP_DEBUG_MSGOUT\t0x00000010\n#define ESP_DEBUG_CMDDONE\t0x00000020\n#define ESP_DEBUG_DISCONNECT\t0x00000040\n#define ESP_DEBUG_DATASTART\t0x00000080\n#define ESP_DEBUG_DATADONE\t0x00000100\n#define ESP_DEBUG_RECONNECT\t0x00000200\n#define ESP_DEBUG_AUTOSENSE\t0x00000400\n#define ESP_DEBUG_EVENT\t\t0x00000800\n#define ESP_DEBUG_COMMAND\t0x00001000\n\n#define esp_log_intr(f, a...) \\\ndo {\tif (esp_debug & ESP_DEBUG_INTR) \\\n\t\tshost_printk(KERN_DEBUG, esp->host, f, ## a);\t\\\n} while (0)\n\n#define esp_log_reset(f, a...) \\\ndo {\tif (esp_debug & ESP_DEBUG_RESET) \\\n\t\tshost_printk(KERN_DEBUG, esp->host, f, ## a);\t\\\n} while (0)\n\n#define esp_log_msgin(f, a...) \\\ndo {\tif (esp_debug & ESP_DEBUG_MSGIN) \\\n\t\tshost_printk(KERN_DEBUG, esp->host, f, ## a);\t\\\n} while (0)\n\n#define esp_log_msgout(f, a...) \\\ndo {\tif (esp_debug & ESP_DEBUG_MSGOUT) \\\n\t\tshost_printk(KERN_DEBUG, esp->host, f, ## a);\t\\\n} while (0)\n\n#define esp_log_cmddone(f, a...) \\\ndo {\tif (esp_debug & ESP_DEBUG_CMDDONE) \\\n\t\tshost_printk(KERN_DEBUG, esp->host, f, ## a);\t\\\n} while (0)\n\n#define esp_log_disconnect(f, a...) \\\ndo {\tif (esp_debug & ESP_DEBUG_DISCONNECT) \\\n\t\tshost_printk(KERN_DEBUG, esp->host, f, ## a);\t\\\n} while (0)\n\n#define esp_log_datastart(f, a...) \\\ndo {\tif (esp_debug & ESP_DEBUG_DATASTART) \\\n\t\tshost_printk(KERN_DEBUG, esp->host, f, ## a);\t\\\n} while (0)\n\n#define esp_log_datadone(f, a...) \\\ndo {\tif (esp_debug & ESP_DEBUG_DATADONE) \\\n\t\tshost_printk(KERN_DEBUG, esp->host, f, ## a);\t\\\n} while (0)\n\n#define esp_log_reconnect(f, a...) \\\ndo {\tif (esp_debug & ESP_DEBUG_RECONNECT) \\\n\t\tshost_printk(KERN_DEBUG, esp->host, f, ## a);\t\\\n} while (0)\n\n#define esp_log_autosense(f, a...) \\\ndo {\tif (esp_debug & ESP_DEBUG_AUTOSENSE) \\\n\t\tshost_printk(KERN_DEBUG, esp->host, f, ## a);\t\\\n} while (0)\n\n#define esp_log_event(f, a...) \\\ndo {   if (esp_debug & ESP_DEBUG_EVENT)\t\\\n\t\tshost_printk(KERN_DEBUG, esp->host, f, ## a);\t\\\n} while (0)\n\n#define esp_log_command(f, a...) \\\ndo {   if (esp_debug & ESP_DEBUG_COMMAND)\t\\\n\t\tshost_printk(KERN_DEBUG, esp->host, f, ## a);\t\\\n} while (0)\n\n#define esp_read8(REG)\t\tesp->ops->esp_read8(esp, REG)\n#define esp_write8(VAL,REG)\tesp->ops->esp_write8(esp, VAL, REG)\n\nstatic void esp_log_fill_regs(struct esp *esp,\n\t\t\t      struct esp_event_ent *p)\n{\n\tp->sreg = esp->sreg;\n\tp->seqreg = esp->seqreg;\n\tp->sreg2 = esp->sreg2;\n\tp->ireg = esp->ireg;\n\tp->select_state = esp->select_state;\n\tp->event = esp->event;\n}\n\nvoid scsi_esp_cmd(struct esp *esp, u8 val)\n{\n\tstruct esp_event_ent *p;\n\tint idx = esp->esp_event_cur;\n\n\tp = &esp->esp_event_log[idx];\n\tp->type = ESP_EVENT_TYPE_CMD;\n\tp->val = val;\n\tesp_log_fill_regs(esp, p);\n\n\tesp->esp_event_cur = (idx + 1) & (ESP_EVENT_LOG_SZ - 1);\n\n\tesp_log_command(\"cmd[%02x]\\n\", val);\n\tesp_write8(val, ESP_CMD);\n}\nEXPORT_SYMBOL(scsi_esp_cmd);\n\nstatic void esp_send_dma_cmd(struct esp *esp, int len, int max_len, int cmd)\n{\n\tif (esp->flags & ESP_FLAG_USE_FIFO) {\n\t\tint i;\n\n\t\tscsi_esp_cmd(esp, ESP_CMD_FLUSH);\n\t\tfor (i = 0; i < len; i++)\n\t\t\tesp_write8(esp->command_block[i], ESP_FDATA);\n\t\tscsi_esp_cmd(esp, cmd);\n\t} else {\n\t\tif (esp->rev == FASHME)\n\t\t\tscsi_esp_cmd(esp, ESP_CMD_FLUSH);\n\t\tcmd |= ESP_CMD_DMA;\n\t\tesp->ops->send_dma_cmd(esp, esp->command_block_dma,\n\t\t\t\t       len, max_len, 0, cmd);\n\t}\n}\n\nstatic void esp_event(struct esp *esp, u8 val)\n{\n\tstruct esp_event_ent *p;\n\tint idx = esp->esp_event_cur;\n\n\tp = &esp->esp_event_log[idx];\n\tp->type = ESP_EVENT_TYPE_EVENT;\n\tp->val = val;\n\tesp_log_fill_regs(esp, p);\n\n\tesp->esp_event_cur = (idx + 1) & (ESP_EVENT_LOG_SZ - 1);\n\n\tesp->event = val;\n}\n\nstatic void esp_dump_cmd_log(struct esp *esp)\n{\n\tint idx = esp->esp_event_cur;\n\tint stop = idx;\n\n\tshost_printk(KERN_INFO, esp->host, \"Dumping command log\\n\");\n\tdo {\n\t\tstruct esp_event_ent *p = &esp->esp_event_log[idx];\n\n\t\tshost_printk(KERN_INFO, esp->host,\n\t\t\t     \"ent[%d] %s val[%02x] sreg[%02x] seqreg[%02x] \"\n\t\t\t     \"sreg2[%02x] ireg[%02x] ss[%02x] event[%02x]\\n\",\n\t\t\t     idx,\n\t\t\t     p->type == ESP_EVENT_TYPE_CMD ? \"CMD\" : \"EVENT\",\n\t\t\t     p->val, p->sreg, p->seqreg,\n\t\t\t     p->sreg2, p->ireg, p->select_state, p->event);\n\n\t\tidx = (idx + 1) & (ESP_EVENT_LOG_SZ - 1);\n\t} while (idx != stop);\n}\n\nstatic void esp_flush_fifo(struct esp *esp)\n{\n\tscsi_esp_cmd(esp, ESP_CMD_FLUSH);\n\tif (esp->rev == ESP236) {\n\t\tint lim = 1000;\n\n\t\twhile (esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES) {\n\t\t\tif (--lim == 0) {\n\t\t\t\tshost_printk(KERN_ALERT, esp->host,\n\t\t\t\t\t     \"ESP_FF_BYTES will not clear!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(1);\n\t\t}\n\t}\n}\n\nstatic void hme_read_fifo(struct esp *esp)\n{\n\tint fcnt = esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES;\n\tint idx = 0;\n\n\twhile (fcnt--) {\n\t\tesp->fifo[idx++] = esp_read8(ESP_FDATA);\n\t\tesp->fifo[idx++] = esp_read8(ESP_FDATA);\n\t}\n\tif (esp->sreg2 & ESP_STAT2_F1BYTE) {\n\t\tesp_write8(0, ESP_FDATA);\n\t\tesp->fifo[idx++] = esp_read8(ESP_FDATA);\n\t\tscsi_esp_cmd(esp, ESP_CMD_FLUSH);\n\t}\n\tesp->fifo_cnt = idx;\n}\n\nstatic void esp_set_all_config3(struct esp *esp, u8 val)\n{\n\tint i;\n\n\tfor (i = 0; i < ESP_MAX_TARGET; i++)\n\t\tesp->target[i].esp_config3 = val;\n}\n\n \nstatic void esp_reset_esp(struct esp *esp)\n{\n\t \n\tscsi_esp_cmd(esp, ESP_CMD_RC);\n\tscsi_esp_cmd(esp, ESP_CMD_NULL | ESP_CMD_DMA);\n\tif (esp->rev == FAST)\n\t\tesp_write8(ESP_CONFIG2_FENAB, ESP_CFG2);\n\tscsi_esp_cmd(esp, ESP_CMD_NULL | ESP_CMD_DMA);\n\n\t \n\tesp->max_period = ((35 * esp->ccycle) / 1000);\n\tif (esp->rev == FAST) {\n\t\tu8 family_code = ESP_FAMILY(esp_read8(ESP_UID));\n\n\t\tif (family_code == ESP_UID_F236) {\n\t\t\tesp->rev = FAS236;\n\t\t} else if (family_code == ESP_UID_HME) {\n\t\t\tesp->rev = FASHME;  \n\t\t} else if (family_code == ESP_UID_FSC) {\n\t\t\tesp->rev = FSC;\n\t\t\t \n\t\t\tesp_write8(ESP_CONFIG4_RADE, ESP_CFG4);\n\t\t} else {\n\t\t\tesp->rev = FAS100A;\n\t\t}\n\t\tesp->min_period = ((4 * esp->ccycle) / 1000);\n\t} else {\n\t\tesp->min_period = ((5 * esp->ccycle) / 1000);\n\t}\n\tif (esp->rev == FAS236) {\n\t\t \n\t\tu8 config4 = ESP_CONFIG4_GE1;\n\t\tesp_write8(config4, ESP_CFG4);\n\t\tconfig4 = esp_read8(ESP_CFG4);\n\t\tif (config4 & ESP_CONFIG4_GE1) {\n\t\t\tesp->rev = PCSCSI;\n\t\t\tesp_write8(esp->config4, ESP_CFG4);\n\t\t}\n\t}\n\tesp->max_period = (esp->max_period + 3)>>2;\n\tesp->min_period = (esp->min_period + 3)>>2;\n\n\tesp_write8(esp->config1, ESP_CFG1);\n\tswitch (esp->rev) {\n\tcase ESP100:\n\t\t \n\t\tbreak;\n\n\tcase ESP100A:\n\t\tesp_write8(esp->config2, ESP_CFG2);\n\t\tbreak;\n\n\tcase ESP236:\n\t\t \n\t\tesp_write8(esp->config2, ESP_CFG2);\n\t\tesp->prev_cfg3 = esp->target[0].esp_config3;\n\t\tesp_write8(esp->prev_cfg3, ESP_CFG3);\n\t\tbreak;\n\n\tcase FASHME:\n\t\tesp->config2 |= (ESP_CONFIG2_HME32 | ESP_CONFIG2_HMEFENAB);\n\t\tfallthrough;\n\n\tcase FAS236:\n\tcase PCSCSI:\n\tcase FSC:\n\t\tesp_write8(esp->config2, ESP_CFG2);\n\t\tif (esp->rev == FASHME) {\n\t\t\tu8 cfg3 = esp->target[0].esp_config3;\n\n\t\t\tcfg3 |= ESP_CONFIG3_FCLOCK | ESP_CONFIG3_OBPUSH;\n\t\t\tif (esp->scsi_id >= 8)\n\t\t\t\tcfg3 |= ESP_CONFIG3_IDBIT3;\n\t\t\tesp_set_all_config3(esp, cfg3);\n\t\t} else {\n\t\t\tu32 cfg3 = esp->target[0].esp_config3;\n\n\t\t\tcfg3 |= ESP_CONFIG3_FCLK;\n\t\t\tesp_set_all_config3(esp, cfg3);\n\t\t}\n\t\tesp->prev_cfg3 = esp->target[0].esp_config3;\n\t\tesp_write8(esp->prev_cfg3, ESP_CFG3);\n\t\tif (esp->rev == FASHME) {\n\t\t\tesp->radelay = 80;\n\t\t} else {\n\t\t\tif (esp->flags & ESP_FLAG_DIFFERENTIAL)\n\t\t\t\tesp->radelay = 0;\n\t\t\telse\n\t\t\t\tesp->radelay = 96;\n\t\t}\n\t\tbreak;\n\n\tcase FAS100A:\n\t\t \n\t\tesp_write8(esp->config2, ESP_CFG2);\n\t\tesp_set_all_config3(esp,\n\t\t\t\t    (esp->target[0].esp_config3 |\n\t\t\t\t     ESP_CONFIG3_FCLOCK));\n\t\tesp->prev_cfg3 = esp->target[0].esp_config3;\n\t\tesp_write8(esp->prev_cfg3, ESP_CFG3);\n\t\tesp->radelay = 32;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tesp_write8(esp->cfact, ESP_CFACT);\n\n\tesp->prev_stp = 0;\n\tesp_write8(esp->prev_stp, ESP_STP);\n\n\tesp->prev_soff = 0;\n\tesp_write8(esp->prev_soff, ESP_SOFF);\n\n\tesp_write8(esp->neg_defp, ESP_TIMEO);\n\n\t \n\tesp_read8(ESP_INTRPT);\n\tudelay(100);\n}\n\nstatic void esp_map_dma(struct esp *esp, struct scsi_cmnd *cmd)\n{\n\tstruct esp_cmd_priv *spriv = ESP_CMD_PRIV(cmd);\n\tstruct scatterlist *sg = scsi_sglist(cmd);\n\tint total = 0, i;\n\tstruct scatterlist *s;\n\n\tif (cmd->sc_data_direction == DMA_NONE)\n\t\treturn;\n\n\tif (esp->flags & ESP_FLAG_NO_DMA_MAP) {\n\t\t \n\t\tspriv->num_sg = scsi_sg_count(cmd);\n\n\t\tscsi_for_each_sg(cmd, s, spriv->num_sg, i) {\n\t\t\ts->dma_address = (uintptr_t)sg_virt(s);\n\t\t\ttotal += sg_dma_len(s);\n\t\t}\n\t} else {\n\t\tspriv->num_sg = scsi_dma_map(cmd);\n\t\tscsi_for_each_sg(cmd, s, spriv->num_sg, i)\n\t\t\ttotal += sg_dma_len(s);\n\t}\n\tspriv->cur_residue = sg_dma_len(sg);\n\tspriv->prv_sg = NULL;\n\tspriv->cur_sg = sg;\n\tspriv->tot_residue = total;\n}\n\nstatic dma_addr_t esp_cur_dma_addr(struct esp_cmd_entry *ent,\n\t\t\t\t   struct scsi_cmnd *cmd)\n{\n\tstruct esp_cmd_priv *p = ESP_CMD_PRIV(cmd);\n\n\tif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\n\t\treturn ent->sense_dma +\n\t\t\t(ent->sense_ptr - cmd->sense_buffer);\n\t}\n\n\treturn sg_dma_address(p->cur_sg) +\n\t\t(sg_dma_len(p->cur_sg) -\n\t\t p->cur_residue);\n}\n\nstatic unsigned int esp_cur_dma_len(struct esp_cmd_entry *ent,\n\t\t\t\t    struct scsi_cmnd *cmd)\n{\n\tstruct esp_cmd_priv *p = ESP_CMD_PRIV(cmd);\n\n\tif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\n\t\treturn SCSI_SENSE_BUFFERSIZE -\n\t\t\t(ent->sense_ptr - cmd->sense_buffer);\n\t}\n\treturn p->cur_residue;\n}\n\nstatic void esp_advance_dma(struct esp *esp, struct esp_cmd_entry *ent,\n\t\t\t    struct scsi_cmnd *cmd, unsigned int len)\n{\n\tstruct esp_cmd_priv *p = ESP_CMD_PRIV(cmd);\n\n\tif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\n\t\tent->sense_ptr += len;\n\t\treturn;\n\t}\n\n\tp->cur_residue -= len;\n\tp->tot_residue -= len;\n\tif (p->cur_residue < 0 || p->tot_residue < 0) {\n\t\tshost_printk(KERN_ERR, esp->host,\n\t\t\t     \"Data transfer overflow.\\n\");\n\t\tshost_printk(KERN_ERR, esp->host,\n\t\t\t     \"cur_residue[%d] tot_residue[%d] len[%u]\\n\",\n\t\t\t     p->cur_residue, p->tot_residue, len);\n\t\tp->cur_residue = 0;\n\t\tp->tot_residue = 0;\n\t}\n\tif (!p->cur_residue && p->tot_residue) {\n\t\tp->prv_sg = p->cur_sg;\n\t\tp->cur_sg = sg_next(p->cur_sg);\n\t\tp->cur_residue = sg_dma_len(p->cur_sg);\n\t}\n}\n\nstatic void esp_unmap_dma(struct esp *esp, struct scsi_cmnd *cmd)\n{\n\tif (!(esp->flags & ESP_FLAG_NO_DMA_MAP))\n\t\tscsi_dma_unmap(cmd);\n}\n\nstatic void esp_save_pointers(struct esp *esp, struct esp_cmd_entry *ent)\n{\n\tstruct scsi_cmnd *cmd = ent->cmd;\n\tstruct esp_cmd_priv *spriv = ESP_CMD_PRIV(cmd);\n\n\tif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\n\t\tent->saved_sense_ptr = ent->sense_ptr;\n\t\treturn;\n\t}\n\tent->saved_cur_residue = spriv->cur_residue;\n\tent->saved_prv_sg = spriv->prv_sg;\n\tent->saved_cur_sg = spriv->cur_sg;\n\tent->saved_tot_residue = spriv->tot_residue;\n}\n\nstatic void esp_restore_pointers(struct esp *esp, struct esp_cmd_entry *ent)\n{\n\tstruct scsi_cmnd *cmd = ent->cmd;\n\tstruct esp_cmd_priv *spriv = ESP_CMD_PRIV(cmd);\n\n\tif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\n\t\tent->sense_ptr = ent->saved_sense_ptr;\n\t\treturn;\n\t}\n\tspriv->cur_residue = ent->saved_cur_residue;\n\tspriv->prv_sg = ent->saved_prv_sg;\n\tspriv->cur_sg = ent->saved_cur_sg;\n\tspriv->tot_residue = ent->saved_tot_residue;\n}\n\nstatic void esp_write_tgt_config3(struct esp *esp, int tgt)\n{\n\tif (esp->rev > ESP100A) {\n\t\tu8 val = esp->target[tgt].esp_config3;\n\n\t\tif (val != esp->prev_cfg3) {\n\t\t\tesp->prev_cfg3 = val;\n\t\t\tesp_write8(val, ESP_CFG3);\n\t\t}\n\t}\n}\n\nstatic void esp_write_tgt_sync(struct esp *esp, int tgt)\n{\n\tu8 off = esp->target[tgt].esp_offset;\n\tu8 per = esp->target[tgt].esp_period;\n\n\tif (off != esp->prev_soff) {\n\t\tesp->prev_soff = off;\n\t\tesp_write8(off, ESP_SOFF);\n\t}\n\tif (per != esp->prev_stp) {\n\t\tesp->prev_stp = per;\n\t\tesp_write8(per, ESP_STP);\n\t}\n}\n\nstatic u32 esp_dma_length_limit(struct esp *esp, u32 dma_addr, u32 dma_len)\n{\n\tif (esp->rev == FASHME) {\n\t\t \n\t\tif (dma_len > (1U << 24))\n\t\t\tdma_len = (1U << 24);\n\t} else {\n\t\tu32 base, end;\n\n\t\t \n\t\tif (dma_len > (1U << 16))\n\t\t\tdma_len = (1U << 16);\n\n\t\t \n\t\tbase = dma_addr & ((1U << 24) - 1U);\n\t\tend = base + dma_len;\n\t\tif (end > (1U << 24))\n\t\t\tend = (1U <<24);\n\t\tdma_len = end - base;\n\t}\n\treturn dma_len;\n}\n\nstatic int esp_need_to_nego_wide(struct esp_target_data *tp)\n{\n\tstruct scsi_target *target = tp->starget;\n\n\treturn spi_width(target) != tp->nego_goal_width;\n}\n\nstatic int esp_need_to_nego_sync(struct esp_target_data *tp)\n{\n\tstruct scsi_target *target = tp->starget;\n\n\t \n\tif (!spi_offset(target) && !tp->nego_goal_offset)\n\t\treturn 0;\n\n\tif (spi_offset(target) == tp->nego_goal_offset &&\n\t    spi_period(target) == tp->nego_goal_period)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int esp_alloc_lun_tag(struct esp_cmd_entry *ent,\n\t\t\t     struct esp_lun_data *lp)\n{\n\tif (!ent->orig_tag[0]) {\n\t\t \n\t\tif (lp->non_tagged_cmd)\n\t\t\treturn -EBUSY;\n\n\t\tif (lp->hold) {\n\t\t\t \n\t\t\tif (lp->num_tagged)\n\t\t\t\treturn -EBUSY;\n\n\t\t\t \n\t\t\tlp->hold = 0;\n\t\t} else if (lp->num_tagged) {\n\t\t\t \n\t\t\tlp->hold = 1;\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tlp->non_tagged_cmd = ent;\n\t\treturn 0;\n\t}\n\n\t \n\tif (lp->non_tagged_cmd || lp->hold)\n\t\treturn -EBUSY;\n\n\tBUG_ON(lp->tagged_cmds[ent->orig_tag[1]]);\n\n\tlp->tagged_cmds[ent->orig_tag[1]] = ent;\n\tlp->num_tagged++;\n\n\treturn 0;\n}\n\nstatic void esp_free_lun_tag(struct esp_cmd_entry *ent,\n\t\t\t     struct esp_lun_data *lp)\n{\n\tif (ent->orig_tag[0]) {\n\t\tBUG_ON(lp->tagged_cmds[ent->orig_tag[1]] != ent);\n\t\tlp->tagged_cmds[ent->orig_tag[1]] = NULL;\n\t\tlp->num_tagged--;\n\t} else {\n\t\tBUG_ON(lp->non_tagged_cmd != ent);\n\t\tlp->non_tagged_cmd = NULL;\n\t}\n}\n\nstatic void esp_map_sense(struct esp *esp, struct esp_cmd_entry *ent)\n{\n\tent->sense_ptr = ent->cmd->sense_buffer;\n\tif (esp->flags & ESP_FLAG_NO_DMA_MAP) {\n\t\tent->sense_dma = (uintptr_t)ent->sense_ptr;\n\t\treturn;\n\t}\n\n\tent->sense_dma = dma_map_single(esp->dev, ent->sense_ptr,\n\t\t\t\t\tSCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\n}\n\nstatic void esp_unmap_sense(struct esp *esp, struct esp_cmd_entry *ent)\n{\n\tif (!(esp->flags & ESP_FLAG_NO_DMA_MAP))\n\t\tdma_unmap_single(esp->dev, ent->sense_dma,\n\t\t\t\t SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\n\tent->sense_ptr = NULL;\n}\n\n \nstatic void esp_autosense(struct esp *esp, struct esp_cmd_entry *ent)\n{\n\tstruct scsi_cmnd *cmd = ent->cmd;\n\tstruct scsi_device *dev = cmd->device;\n\tint tgt, lun;\n\tu8 *p, val;\n\n\ttgt = dev->id;\n\tlun = dev->lun;\n\n\n\tif (!ent->sense_ptr) {\n\t\tesp_log_autosense(\"Doing auto-sense for tgt[%d] lun[%d]\\n\",\n\t\t\t\t  tgt, lun);\n\t\tesp_map_sense(esp, ent);\n\t}\n\tent->saved_sense_ptr = ent->sense_ptr;\n\n\tesp->active_cmd = ent;\n\n\tp = esp->command_block;\n\tesp->msg_out_len = 0;\n\n\t*p++ = IDENTIFY(0, lun);\n\t*p++ = REQUEST_SENSE;\n\t*p++ = ((dev->scsi_level <= SCSI_2) ?\n\t\t(lun << 5) : 0);\n\t*p++ = 0;\n\t*p++ = 0;\n\t*p++ = SCSI_SENSE_BUFFERSIZE;\n\t*p++ = 0;\n\n\tesp->select_state = ESP_SELECT_BASIC;\n\n\tval = tgt;\n\tif (esp->rev == FASHME)\n\t\tval |= ESP_BUSID_RESELID | ESP_BUSID_CTR32BIT;\n\tesp_write8(val, ESP_BUSID);\n\n\tesp_write_tgt_sync(esp, tgt);\n\tesp_write_tgt_config3(esp, tgt);\n\n\tval = (p - esp->command_block);\n\n\tesp_send_dma_cmd(esp, val, 16, ESP_CMD_SELA);\n}\n\nstatic struct esp_cmd_entry *find_and_prep_issuable_command(struct esp *esp)\n{\n\tstruct esp_cmd_entry *ent;\n\n\tlist_for_each_entry(ent, &esp->queued_cmds, list) {\n\t\tstruct scsi_cmnd *cmd = ent->cmd;\n\t\tstruct scsi_device *dev = cmd->device;\n\t\tstruct esp_lun_data *lp = dev->hostdata;\n\n\t\tif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\n\t\t\tent->tag[0] = 0;\n\t\t\tent->tag[1] = 0;\n\t\t\treturn ent;\n\t\t}\n\n\t\tif (!spi_populate_tag_msg(&ent->tag[0], cmd)) {\n\t\t\tent->tag[0] = 0;\n\t\t\tent->tag[1] = 0;\n\t\t}\n\t\tent->orig_tag[0] = ent->tag[0];\n\t\tent->orig_tag[1] = ent->tag[1];\n\n\t\tif (esp_alloc_lun_tag(ent, lp) < 0)\n\t\t\tcontinue;\n\n\t\treturn ent;\n\t}\n\n\treturn NULL;\n}\n\nstatic void esp_maybe_execute_command(struct esp *esp)\n{\n\tstruct esp_target_data *tp;\n\tstruct scsi_device *dev;\n\tstruct scsi_cmnd *cmd;\n\tstruct esp_cmd_entry *ent;\n\tbool select_and_stop = false;\n\tint tgt, lun, i;\n\tu32 val, start_cmd;\n\tu8 *p;\n\n\tif (esp->active_cmd ||\n\t    (esp->flags & ESP_FLAG_RESETTING))\n\t\treturn;\n\n\tent = find_and_prep_issuable_command(esp);\n\tif (!ent)\n\t\treturn;\n\n\tif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\n\t\tesp_autosense(esp, ent);\n\t\treturn;\n\t}\n\n\tcmd = ent->cmd;\n\tdev = cmd->device;\n\ttgt = dev->id;\n\tlun = dev->lun;\n\ttp = &esp->target[tgt];\n\n\tlist_move(&ent->list, &esp->active_cmds);\n\n\tesp->active_cmd = ent;\n\n\tesp_map_dma(esp, cmd);\n\tesp_save_pointers(esp, ent);\n\n\tif (!(cmd->cmd_len == 6 || cmd->cmd_len == 10 || cmd->cmd_len == 12))\n\t\tselect_and_stop = true;\n\n\tp = esp->command_block;\n\n\tesp->msg_out_len = 0;\n\tif (tp->flags & ESP_TGT_CHECK_NEGO) {\n\t\t \n\t\tif (tp->flags & ESP_TGT_BROKEN) {\n\t\t\ttp->flags &= ~ESP_TGT_DISCONNECT;\n\t\t\ttp->nego_goal_period = 0;\n\t\t\ttp->nego_goal_offset = 0;\n\t\t\ttp->nego_goal_width = 0;\n\t\t\ttp->nego_goal_tags = 0;\n\t\t}\n\n\t\t \n\t\tif (spi_width(tp->starget) == tp->nego_goal_width &&\n\t\t    spi_period(tp->starget) == tp->nego_goal_period &&\n\t\t    spi_offset(tp->starget) == tp->nego_goal_offset) {\n\t\t\ttp->flags &= ~ESP_TGT_CHECK_NEGO;\n\t\t\tgoto build_identify;\n\t\t}\n\n\t\tif (esp->rev == FASHME && esp_need_to_nego_wide(tp)) {\n\t\t\tesp->msg_out_len =\n\t\t\t\tspi_populate_width_msg(&esp->msg_out[0],\n\t\t\t\t\t\t       (tp->nego_goal_width ?\n\t\t\t\t\t\t\t1 : 0));\n\t\t\ttp->flags |= ESP_TGT_NEGO_WIDE;\n\t\t} else if (esp_need_to_nego_sync(tp)) {\n\t\t\tesp->msg_out_len =\n\t\t\t\tspi_populate_sync_msg(&esp->msg_out[0],\n\t\t\t\t\t\t      tp->nego_goal_period,\n\t\t\t\t\t\t      tp->nego_goal_offset);\n\t\t\ttp->flags |= ESP_TGT_NEGO_SYNC;\n\t\t} else {\n\t\t\ttp->flags &= ~ESP_TGT_CHECK_NEGO;\n\t\t}\n\n\t\t \n\t\tif (esp->msg_out_len)\n\t\t\tselect_and_stop = true;\n\t}\n\nbuild_identify:\n\t*p++ = IDENTIFY(tp->flags & ESP_TGT_DISCONNECT, lun);\n\n\tif (ent->tag[0] && esp->rev == ESP100) {\n\t\t \n\t\tselect_and_stop = true;\n\t}\n\n\tif (select_and_stop) {\n\t\tesp->cmd_bytes_left = cmd->cmd_len;\n\t\tesp->cmd_bytes_ptr = &cmd->cmnd[0];\n\n\t\tif (ent->tag[0]) {\n\t\t\tfor (i = esp->msg_out_len - 1;\n\t\t\t     i >= 0; i--)\n\t\t\t\tesp->msg_out[i + 2] = esp->msg_out[i];\n\t\t\tesp->msg_out[0] = ent->tag[0];\n\t\t\tesp->msg_out[1] = ent->tag[1];\n\t\t\tesp->msg_out_len += 2;\n\t\t}\n\n\t\tstart_cmd = ESP_CMD_SELAS;\n\t\tesp->select_state = ESP_SELECT_MSGOUT;\n\t} else {\n\t\tstart_cmd = ESP_CMD_SELA;\n\t\tif (ent->tag[0]) {\n\t\t\t*p++ = ent->tag[0];\n\t\t\t*p++ = ent->tag[1];\n\n\t\t\tstart_cmd = ESP_CMD_SA3;\n\t\t}\n\n\t\tfor (i = 0; i < cmd->cmd_len; i++)\n\t\t\t*p++ = cmd->cmnd[i];\n\n\t\tesp->select_state = ESP_SELECT_BASIC;\n\t}\n\tval = tgt;\n\tif (esp->rev == FASHME)\n\t\tval |= ESP_BUSID_RESELID | ESP_BUSID_CTR32BIT;\n\tesp_write8(val, ESP_BUSID);\n\n\tesp_write_tgt_sync(esp, tgt);\n\tesp_write_tgt_config3(esp, tgt);\n\n\tval = (p - esp->command_block);\n\n\tif (esp_debug & ESP_DEBUG_SCSICMD) {\n\t\tprintk(\"ESP: tgt[%d] lun[%d] scsi_cmd [ \", tgt, lun);\n\t\tfor (i = 0; i < cmd->cmd_len; i++)\n\t\t\tprintk(\"%02x \", cmd->cmnd[i]);\n\t\tprintk(\"]\\n\");\n\t}\n\n\tesp_send_dma_cmd(esp, val, 16, start_cmd);\n}\n\nstatic struct esp_cmd_entry *esp_get_ent(struct esp *esp)\n{\n\tstruct list_head *head = &esp->esp_cmd_pool;\n\tstruct esp_cmd_entry *ret;\n\n\tif (list_empty(head)) {\n\t\tret = kzalloc(sizeof(struct esp_cmd_entry), GFP_ATOMIC);\n\t} else {\n\t\tret = list_entry(head->next, struct esp_cmd_entry, list);\n\t\tlist_del(&ret->list);\n\t\tmemset(ret, 0, sizeof(*ret));\n\t}\n\treturn ret;\n}\n\nstatic void esp_put_ent(struct esp *esp, struct esp_cmd_entry *ent)\n{\n\tlist_add(&ent->list, &esp->esp_cmd_pool);\n}\n\nstatic void esp_cmd_is_done(struct esp *esp, struct esp_cmd_entry *ent,\n\t\t\t    struct scsi_cmnd *cmd, unsigned char host_byte)\n{\n\tstruct scsi_device *dev = cmd->device;\n\tint tgt = dev->id;\n\tint lun = dev->lun;\n\n\tesp->active_cmd = NULL;\n\tesp_unmap_dma(esp, cmd);\n\tesp_free_lun_tag(ent, dev->hostdata);\n\tcmd->result = 0;\n\tset_host_byte(cmd, host_byte);\n\tif (host_byte == DID_OK)\n\t\tset_status_byte(cmd, ent->status);\n\n\tif (ent->eh_done) {\n\t\tcomplete(ent->eh_done);\n\t\tent->eh_done = NULL;\n\t}\n\n\tif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\n\t\tesp_unmap_sense(esp, ent);\n\n\t\t \n\t\tcmd->result = SAM_STAT_CHECK_CONDITION;\n\n\t\tent->flags &= ~ESP_CMD_FLAG_AUTOSENSE;\n\t\tif (esp_debug & ESP_DEBUG_AUTOSENSE) {\n\t\t\tint i;\n\n\t\t\tprintk(\"esp%d: tgt[%d] lun[%d] AUTO SENSE[ \",\n\t\t\t       esp->host->unique_id, tgt, lun);\n\t\t\tfor (i = 0; i < 18; i++)\n\t\t\t\tprintk(\"%02x \", cmd->sense_buffer[i]);\n\t\t\tprintk(\"]\\n\");\n\t\t}\n\t}\n\n\tscsi_done(cmd);\n\n\tlist_del(&ent->list);\n\tesp_put_ent(esp, ent);\n\n\tesp_maybe_execute_command(esp);\n}\n\nstatic void esp_event_queue_full(struct esp *esp, struct esp_cmd_entry *ent)\n{\n\tstruct scsi_device *dev = ent->cmd->device;\n\tstruct esp_lun_data *lp = dev->hostdata;\n\n\tscsi_track_queue_full(dev, lp->num_tagged - 1);\n}\n\nstatic int esp_queuecommand_lck(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_device *dev = cmd->device;\n\tstruct esp *esp = shost_priv(dev->host);\n\tstruct esp_cmd_priv *spriv;\n\tstruct esp_cmd_entry *ent;\n\n\tent = esp_get_ent(esp);\n\tif (!ent)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tent->cmd = cmd;\n\n\tspriv = ESP_CMD_PRIV(cmd);\n\tspriv->num_sg = 0;\n\n\tlist_add_tail(&ent->list, &esp->queued_cmds);\n\n\tesp_maybe_execute_command(esp);\n\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(esp_queuecommand)\n\nstatic int esp_check_gross_error(struct esp *esp)\n{\n\tif (esp->sreg & ESP_STAT_SPAM) {\n\t\t \n\t\tshost_printk(KERN_ERR, esp->host,\n\t\t\t     \"Gross error sreg[%02x]\\n\", esp->sreg);\n\t\t \n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int esp_check_spur_intr(struct esp *esp)\n{\n\tswitch (esp->rev) {\n\tcase ESP100:\n\tcase ESP100A:\n\t\t \n\t\tesp->sreg &= ~ESP_STAT_INTR;\n\t\tbreak;\n\n\tdefault:\n\t\tif (!(esp->sreg & ESP_STAT_INTR)) {\n\t\t\tif (esp->ireg & ESP_INTR_SR)\n\t\t\t\treturn 1;\n\n\t\t\t \n\t\t\tif (!esp->ops->dma_error(esp)) {\n\t\t\t\tshost_printk(KERN_ERR, esp->host,\n\t\t\t\t\t     \"Spurious irq, sreg=%02x.\\n\",\n\t\t\t\t\t     esp->sreg);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tshost_printk(KERN_ERR, esp->host, \"DMA error\\n\");\n\n\t\t\t \n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void esp_schedule_reset(struct esp *esp)\n{\n\tesp_log_reset(\"esp_schedule_reset() from %ps\\n\",\n\t\t      __builtin_return_address(0));\n\tesp->flags |= ESP_FLAG_RESETTING;\n\tesp_event(esp, ESP_EVENT_RESET);\n}\n\n \nstatic struct esp_cmd_entry *esp_reconnect_with_tag(struct esp *esp,\n\t\t\t\t\t\t    struct esp_lun_data *lp)\n{\n\tstruct esp_cmd_entry *ent;\n\tint i;\n\n\tif (!lp->num_tagged) {\n\t\tshost_printk(KERN_ERR, esp->host,\n\t\t\t     \"Reconnect w/num_tagged==0\\n\");\n\t\treturn NULL;\n\t}\n\n\tesp_log_reconnect(\"reconnect tag, \");\n\n\tfor (i = 0; i < ESP_QUICKIRQ_LIMIT; i++) {\n\t\tif (esp->ops->irq_pending(esp))\n\t\t\tbreak;\n\t}\n\tif (i == ESP_QUICKIRQ_LIMIT) {\n\t\tshost_printk(KERN_ERR, esp->host,\n\t\t\t     \"Reconnect IRQ1 timeout\\n\");\n\t\treturn NULL;\n\t}\n\n\tesp->sreg = esp_read8(ESP_STATUS);\n\tesp->ireg = esp_read8(ESP_INTRPT);\n\n\tesp_log_reconnect(\"IRQ(%d:%x:%x), \",\n\t\t\t  i, esp->ireg, esp->sreg);\n\n\tif (esp->ireg & ESP_INTR_DC) {\n\t\tshost_printk(KERN_ERR, esp->host,\n\t\t\t     \"Reconnect, got disconnect.\\n\");\n\t\treturn NULL;\n\t}\n\n\tif ((esp->sreg & ESP_STAT_PMASK) != ESP_MIP) {\n\t\tshost_printk(KERN_ERR, esp->host,\n\t\t\t     \"Reconnect, not MIP sreg[%02x].\\n\", esp->sreg);\n\t\treturn NULL;\n\t}\n\n\t \n\tesp->command_block[0] = 0xff;\n\tesp->command_block[1] = 0xff;\n\tesp->ops->send_dma_cmd(esp, esp->command_block_dma,\n\t\t\t       2, 2, 1, ESP_CMD_DMA | ESP_CMD_TI);\n\n\t \n\tscsi_esp_cmd(esp, ESP_CMD_MOK);\n\n\tfor (i = 0; i < ESP_RESELECT_TAG_LIMIT; i++) {\n\t\tif (esp->ops->irq_pending(esp)) {\n\t\t\tesp->sreg = esp_read8(ESP_STATUS);\n\t\t\tesp->ireg = esp_read8(ESP_INTRPT);\n\t\t\tif (esp->ireg & ESP_INTR_FDONE)\n\t\t\t\tbreak;\n\t\t}\n\t\tudelay(1);\n\t}\n\tif (i == ESP_RESELECT_TAG_LIMIT) {\n\t\tshost_printk(KERN_ERR, esp->host, \"Reconnect IRQ2 timeout\\n\");\n\t\treturn NULL;\n\t}\n\tesp->ops->dma_drain(esp);\n\tesp->ops->dma_invalidate(esp);\n\n\tesp_log_reconnect(\"IRQ2(%d:%x:%x) tag[%x:%x]\\n\",\n\t\t\t  i, esp->ireg, esp->sreg,\n\t\t\t  esp->command_block[0],\n\t\t\t  esp->command_block[1]);\n\n\tif (esp->command_block[0] < SIMPLE_QUEUE_TAG ||\n\t    esp->command_block[0] > ORDERED_QUEUE_TAG) {\n\t\tshost_printk(KERN_ERR, esp->host,\n\t\t\t     \"Reconnect, bad tag type %02x.\\n\",\n\t\t\t     esp->command_block[0]);\n\t\treturn NULL;\n\t}\n\n\tent = lp->tagged_cmds[esp->command_block[1]];\n\tif (!ent) {\n\t\tshost_printk(KERN_ERR, esp->host,\n\t\t\t     \"Reconnect, no entry for tag %02x.\\n\",\n\t\t\t     esp->command_block[1]);\n\t\treturn NULL;\n\t}\n\n\treturn ent;\n}\n\nstatic int esp_reconnect(struct esp *esp)\n{\n\tstruct esp_cmd_entry *ent;\n\tstruct esp_target_data *tp;\n\tstruct esp_lun_data *lp;\n\tstruct scsi_device *dev;\n\tint target, lun;\n\n\tBUG_ON(esp->active_cmd);\n\tif (esp->rev == FASHME) {\n\t\t \n\t\ttarget = esp->fifo[0];\n\t\tlun = esp->fifo[1] & 0x7;\n\t} else {\n\t\tu8 bits = esp_read8(ESP_FDATA);\n\n\t\t \n\t\tif (!(bits & esp->scsi_id_mask))\n\t\t\tgoto do_reset;\n\t\tbits &= ~esp->scsi_id_mask;\n\t\tif (!bits || (bits & (bits - 1)))\n\t\t\tgoto do_reset;\n\n\t\ttarget = ffs(bits) - 1;\n\t\tlun = (esp_read8(ESP_FDATA) & 0x7);\n\n\t\tscsi_esp_cmd(esp, ESP_CMD_FLUSH);\n\t\tif (esp->rev == ESP100) {\n\t\t\tu8 ireg = esp_read8(ESP_INTRPT);\n\t\t\t \n\t\t\tif (ireg & ESP_INTR_SR)\n\t\t\t\tgoto do_reset;\n\t\t}\n\t\tscsi_esp_cmd(esp, ESP_CMD_NULL);\n\t}\n\n\tesp_write_tgt_sync(esp, target);\n\tesp_write_tgt_config3(esp, target);\n\n\tscsi_esp_cmd(esp, ESP_CMD_MOK);\n\n\tif (esp->rev == FASHME)\n\t\tesp_write8(target | ESP_BUSID_RESELID | ESP_BUSID_CTR32BIT,\n\t\t\t   ESP_BUSID);\n\n\ttp = &esp->target[target];\n\tdev = __scsi_device_lookup_by_target(tp->starget, lun);\n\tif (!dev) {\n\t\tshost_printk(KERN_ERR, esp->host,\n\t\t\t     \"Reconnect, no lp tgt[%u] lun[%u]\\n\",\n\t\t\t     target, lun);\n\t\tgoto do_reset;\n\t}\n\tlp = dev->hostdata;\n\n\tent = lp->non_tagged_cmd;\n\tif (!ent) {\n\t\tent = esp_reconnect_with_tag(esp, lp);\n\t\tif (!ent)\n\t\t\tgoto do_reset;\n\t}\n\n\tesp->active_cmd = ent;\n\n\tesp_event(esp, ESP_EVENT_CHECK_PHASE);\n\tesp_restore_pointers(esp, ent);\n\tesp->flags |= ESP_FLAG_QUICKIRQ_CHECK;\n\treturn 1;\n\ndo_reset:\n\tesp_schedule_reset(esp);\n\treturn 0;\n}\n\nstatic int esp_finish_select(struct esp *esp)\n{\n\tstruct esp_cmd_entry *ent;\n\tstruct scsi_cmnd *cmd;\n\n\t \n\tesp->select_state = ESP_SELECT_NONE;\n\n\tesp->seqreg = esp_read8(ESP_SSTEP) & ESP_STEP_VBITS;\n\tent = esp->active_cmd;\n\tcmd = ent->cmd;\n\n\tif (esp->ops->dma_error(esp)) {\n\t\t \n\t\tesp_schedule_reset(esp);\n\t\tesp_cmd_is_done(esp, ent, cmd, DID_ERROR);\n\t\treturn 0;\n\t}\n\n\tesp->ops->dma_invalidate(esp);\n\n\tif (esp->ireg == (ESP_INTR_RSEL | ESP_INTR_FDONE)) {\n\t\tstruct esp_target_data *tp = &esp->target[cmd->device->id];\n\n\t\t \n\t\tif (!(ent->flags & ESP_CMD_FLAG_AUTOSENSE)) {\n\t\t\tesp_unmap_dma(esp, cmd);\n\t\t\tesp_free_lun_tag(ent, cmd->device->hostdata);\n\t\t\ttp->flags &= ~(ESP_TGT_NEGO_SYNC | ESP_TGT_NEGO_WIDE);\n\t\t\tesp->cmd_bytes_ptr = NULL;\n\t\t\tesp->cmd_bytes_left = 0;\n\t\t} else {\n\t\t\tesp_unmap_sense(esp, ent);\n\t\t}\n\n\t\t \n\t\tlist_move(&ent->list, &esp->queued_cmds);\n\t\tesp->active_cmd = NULL;\n\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (esp->ireg == ESP_INTR_DC) {\n\t\tstruct scsi_device *dev = cmd->device;\n\n\t\t \n\t\tesp->target[dev->id].flags |= ESP_TGT_CHECK_NEGO;\n\n\t\tscsi_esp_cmd(esp, ESP_CMD_ESEL);\n\t\tesp_cmd_is_done(esp, ent, cmd, DID_BAD_TARGET);\n\t\treturn 1;\n\t}\n\n\tif (esp->ireg == (ESP_INTR_FDONE | ESP_INTR_BSERV)) {\n\t\t \n\t\tif (esp->rev <= ESP236) {\n\t\t\tint fcnt = esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES;\n\n\t\t\tscsi_esp_cmd(esp, ESP_CMD_NULL);\n\n\t\t\tif (!fcnt &&\n\t\t\t    (!esp->prev_soff ||\n\t\t\t     ((esp->sreg & ESP_STAT_PMASK) != ESP_DIP)))\n\t\t\t\tesp_flush_fifo(esp);\n\t\t}\n\n\t\t \n\t\tesp_event(esp, ESP_EVENT_CHECK_PHASE);\n\t\treturn 0;\n\t}\n\n\tshost_printk(KERN_INFO, esp->host,\n\t\t     \"Unexpected selection completion ireg[%x]\\n\", esp->ireg);\n\tesp_schedule_reset(esp);\n\treturn 0;\n}\n\nstatic int esp_data_bytes_sent(struct esp *esp, struct esp_cmd_entry *ent,\n\t\t\t       struct scsi_cmnd *cmd)\n{\n\tint fifo_cnt, ecount, bytes_sent, flush_fifo;\n\n\tfifo_cnt = esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES;\n\tif (esp->prev_cfg3 & ESP_CONFIG3_EWIDE)\n\t\tfifo_cnt <<= 1;\n\n\tecount = 0;\n\tif (!(esp->sreg & ESP_STAT_TCNT)) {\n\t\tecount = ((unsigned int)esp_read8(ESP_TCLOW) |\n\t\t\t  (((unsigned int)esp_read8(ESP_TCMED)) << 8));\n\t\tif (esp->rev == FASHME)\n\t\t\tecount |= ((unsigned int)esp_read8(FAS_RLO)) << 16;\n\t\tif (esp->rev == PCSCSI && (esp->config2 & ESP_CONFIG2_FENAB))\n\t\t\tecount |= ((unsigned int)esp_read8(ESP_TCHI)) << 16;\n\t}\n\n\tbytes_sent = esp->data_dma_len;\n\tbytes_sent -= ecount;\n\tbytes_sent -= esp->send_cmd_residual;\n\n\t \n\tif (fifo_cnt == 1 && ent->flags & ESP_CMD_FLAG_RESIDUAL) {\n\t\tsize_t count = 1;\n\t\tsize_t offset = bytes_sent;\n\t\tu8 bval = esp_read8(ESP_FDATA);\n\n\t\tif (ent->flags & ESP_CMD_FLAG_AUTOSENSE)\n\t\t\tent->sense_ptr[bytes_sent] = bval;\n\t\telse {\n\t\t\tstruct esp_cmd_priv *p = ESP_CMD_PRIV(cmd);\n\t\t\tu8 *ptr;\n\n\t\t\tptr = scsi_kmap_atomic_sg(p->cur_sg, p->num_sg,\n\t\t\t\t\t\t  &offset, &count);\n\t\t\tif (likely(ptr)) {\n\t\t\t\t*(ptr + offset) = bval;\n\t\t\t\tscsi_kunmap_atomic_sg(ptr);\n\t\t\t}\n\t\t}\n\t\tbytes_sent += fifo_cnt;\n\t\tent->flags &= ~ESP_CMD_FLAG_RESIDUAL;\n\t}\n\tif (!(ent->flags & ESP_CMD_FLAG_WRITE))\n\t\tbytes_sent -= fifo_cnt;\n\n\tflush_fifo = 0;\n\tif (!esp->prev_soff) {\n\t\t \n\t\tflush_fifo = 1;\n\t} else {\n\t\tif (esp->rev == ESP100) {\n\t\t\tu32 fflags, phase;\n\n\t\t\t \n\t\t\tesp->sreg = esp_read8(ESP_STATUS);\n\t\t\tphase = esp->sreg & ESP_STAT_PMASK;\n\t\t\tfflags = esp_read8(ESP_FFLAGS);\n\n\t\t\tif ((phase == ESP_DOP &&\n\t\t\t     (fflags & ESP_FF_ONOTZERO)) ||\n\t\t\t    (phase == ESP_DIP &&\n\t\t\t     (fflags & ESP_FF_FBYTES)))\n\t\t\t\treturn -1;\n\t\t}\n\t\tif (!(ent->flags & ESP_CMD_FLAG_WRITE))\n\t\t\tflush_fifo = 1;\n\t}\n\n\tif (flush_fifo)\n\t\tesp_flush_fifo(esp);\n\n\treturn bytes_sent;\n}\n\nstatic void esp_setsync(struct esp *esp, struct esp_target_data *tp,\n\t\t\tu8 scsi_period, u8 scsi_offset,\n\t\t\tu8 esp_stp, u8 esp_soff)\n{\n\tspi_period(tp->starget) = scsi_period;\n\tspi_offset(tp->starget) = scsi_offset;\n\tspi_width(tp->starget) = (tp->flags & ESP_TGT_WIDE) ? 1 : 0;\n\n\tif (esp_soff) {\n\t\tesp_stp &= 0x1f;\n\t\tesp_soff |= esp->radelay;\n\t\tif (esp->rev >= FAS236) {\n\t\t\tu8 bit = ESP_CONFIG3_FSCSI;\n\t\t\tif (esp->rev >= FAS100A)\n\t\t\t\tbit = ESP_CONFIG3_FAST;\n\n\t\t\tif (scsi_period < 50) {\n\t\t\t\tif (esp->rev == FASHME)\n\t\t\t\t\tesp_soff &= ~esp->radelay;\n\t\t\t\ttp->esp_config3 |= bit;\n\t\t\t} else {\n\t\t\t\ttp->esp_config3 &= ~bit;\n\t\t\t}\n\t\t\tesp->prev_cfg3 = tp->esp_config3;\n\t\t\tesp_write8(esp->prev_cfg3, ESP_CFG3);\n\t\t}\n\t}\n\n\ttp->esp_period = esp->prev_stp = esp_stp;\n\ttp->esp_offset = esp->prev_soff = esp_soff;\n\n\tesp_write8(esp_soff, ESP_SOFF);\n\tesp_write8(esp_stp, ESP_STP);\n\n\ttp->flags &= ~(ESP_TGT_NEGO_SYNC | ESP_TGT_CHECK_NEGO);\n\n\tspi_display_xfer_agreement(tp->starget);\n}\n\nstatic void esp_msgin_reject(struct esp *esp)\n{\n\tstruct esp_cmd_entry *ent = esp->active_cmd;\n\tstruct scsi_cmnd *cmd = ent->cmd;\n\tstruct esp_target_data *tp;\n\tint tgt;\n\n\ttgt = cmd->device->id;\n\ttp = &esp->target[tgt];\n\n\tif (tp->flags & ESP_TGT_NEGO_WIDE) {\n\t\ttp->flags &= ~(ESP_TGT_NEGO_WIDE | ESP_TGT_WIDE);\n\n\t\tif (!esp_need_to_nego_sync(tp)) {\n\t\t\ttp->flags &= ~ESP_TGT_CHECK_NEGO;\n\t\t\tscsi_esp_cmd(esp, ESP_CMD_RATN);\n\t\t} else {\n\t\t\tesp->msg_out_len =\n\t\t\t\tspi_populate_sync_msg(&esp->msg_out[0],\n\t\t\t\t\t\t      tp->nego_goal_period,\n\t\t\t\t\t\t      tp->nego_goal_offset);\n\t\t\ttp->flags |= ESP_TGT_NEGO_SYNC;\n\t\t\tscsi_esp_cmd(esp, ESP_CMD_SATN);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (tp->flags & ESP_TGT_NEGO_SYNC) {\n\t\ttp->flags &= ~(ESP_TGT_NEGO_SYNC | ESP_TGT_CHECK_NEGO);\n\t\ttp->esp_period = 0;\n\t\ttp->esp_offset = 0;\n\t\tesp_setsync(esp, tp, 0, 0, 0, 0);\n\t\tscsi_esp_cmd(esp, ESP_CMD_RATN);\n\t\treturn;\n\t}\n\n\tshost_printk(KERN_INFO, esp->host, \"Unexpected MESSAGE REJECT\\n\");\n\tesp_schedule_reset(esp);\n}\n\nstatic void esp_msgin_sdtr(struct esp *esp, struct esp_target_data *tp)\n{\n\tu8 period = esp->msg_in[3];\n\tu8 offset = esp->msg_in[4];\n\tu8 stp;\n\n\tif (!(tp->flags & ESP_TGT_NEGO_SYNC))\n\t\tgoto do_reject;\n\n\tif (offset > 15)\n\t\tgoto do_reject;\n\n\tif (offset) {\n\t\tint one_clock;\n\n\t\tif (period > esp->max_period) {\n\t\t\tperiod = offset = 0;\n\t\t\tgoto do_sdtr;\n\t\t}\n\t\tif (period < esp->min_period)\n\t\t\tgoto do_reject;\n\n\t\tone_clock = esp->ccycle / 1000;\n\t\tstp = DIV_ROUND_UP(period << 2, one_clock);\n\t\tif (stp && esp->rev >= FAS236) {\n\t\t\tif (stp >= 50)\n\t\t\t\tstp--;\n\t\t}\n\t} else {\n\t\tstp = 0;\n\t}\n\n\tesp_setsync(esp, tp, period, offset, stp, offset);\n\treturn;\n\ndo_reject:\n\tesp->msg_out[0] = MESSAGE_REJECT;\n\tesp->msg_out_len = 1;\n\tscsi_esp_cmd(esp, ESP_CMD_SATN);\n\treturn;\n\ndo_sdtr:\n\ttp->nego_goal_period = period;\n\ttp->nego_goal_offset = offset;\n\tesp->msg_out_len =\n\t\tspi_populate_sync_msg(&esp->msg_out[0],\n\t\t\t\t      tp->nego_goal_period,\n\t\t\t\t      tp->nego_goal_offset);\n\tscsi_esp_cmd(esp, ESP_CMD_SATN);\n}\n\nstatic void esp_msgin_wdtr(struct esp *esp, struct esp_target_data *tp)\n{\n\tint size = 8 << esp->msg_in[3];\n\tu8 cfg3;\n\n\tif (esp->rev != FASHME)\n\t\tgoto do_reject;\n\n\tif (size != 8 && size != 16)\n\t\tgoto do_reject;\n\n\tif (!(tp->flags & ESP_TGT_NEGO_WIDE))\n\t\tgoto do_reject;\n\n\tcfg3 = tp->esp_config3;\n\tif (size == 16) {\n\t\ttp->flags |= ESP_TGT_WIDE;\n\t\tcfg3 |= ESP_CONFIG3_EWIDE;\n\t} else {\n\t\ttp->flags &= ~ESP_TGT_WIDE;\n\t\tcfg3 &= ~ESP_CONFIG3_EWIDE;\n\t}\n\ttp->esp_config3 = cfg3;\n\tesp->prev_cfg3 = cfg3;\n\tesp_write8(cfg3, ESP_CFG3);\n\n\ttp->flags &= ~ESP_TGT_NEGO_WIDE;\n\n\tspi_period(tp->starget) = 0;\n\tspi_offset(tp->starget) = 0;\n\tif (!esp_need_to_nego_sync(tp)) {\n\t\ttp->flags &= ~ESP_TGT_CHECK_NEGO;\n\t\tscsi_esp_cmd(esp, ESP_CMD_RATN);\n\t} else {\n\t\tesp->msg_out_len =\n\t\t\tspi_populate_sync_msg(&esp->msg_out[0],\n\t\t\t\t\t      tp->nego_goal_period,\n\t\t\t\t\t      tp->nego_goal_offset);\n\t\ttp->flags |= ESP_TGT_NEGO_SYNC;\n\t\tscsi_esp_cmd(esp, ESP_CMD_SATN);\n\t}\n\treturn;\n\ndo_reject:\n\tesp->msg_out[0] = MESSAGE_REJECT;\n\tesp->msg_out_len = 1;\n\tscsi_esp_cmd(esp, ESP_CMD_SATN);\n}\n\nstatic void esp_msgin_extended(struct esp *esp)\n{\n\tstruct esp_cmd_entry *ent = esp->active_cmd;\n\tstruct scsi_cmnd *cmd = ent->cmd;\n\tstruct esp_target_data *tp;\n\tint tgt = cmd->device->id;\n\n\ttp = &esp->target[tgt];\n\tif (esp->msg_in[2] == EXTENDED_SDTR) {\n\t\tesp_msgin_sdtr(esp, tp);\n\t\treturn;\n\t}\n\tif (esp->msg_in[2] == EXTENDED_WDTR) {\n\t\tesp_msgin_wdtr(esp, tp);\n\t\treturn;\n\t}\n\n\tshost_printk(KERN_INFO, esp->host,\n\t\t     \"Unexpected extended msg type %x\\n\", esp->msg_in[2]);\n\n\tesp->msg_out[0] = MESSAGE_REJECT;\n\tesp->msg_out_len = 1;\n\tscsi_esp_cmd(esp, ESP_CMD_SATN);\n}\n\n \nstatic int esp_msgin_process(struct esp *esp)\n{\n\tu8 msg0 = esp->msg_in[0];\n\tint len = esp->msg_in_len;\n\n\tif (msg0 & 0x80) {\n\t\t \n\t\tshost_printk(KERN_INFO, esp->host,\n\t\t\t     \"Unexpected msgin identify\\n\");\n\t\treturn 0;\n\t}\n\n\tswitch (msg0) {\n\tcase EXTENDED_MESSAGE:\n\t\tif (len == 1)\n\t\t\treturn 1;\n\t\tif (len < esp->msg_in[1] + 2)\n\t\t\treturn 1;\n\t\tesp_msgin_extended(esp);\n\t\treturn 0;\n\n\tcase IGNORE_WIDE_RESIDUE: {\n\t\tstruct esp_cmd_entry *ent;\n\t\tstruct esp_cmd_priv *spriv;\n\t\tif (len == 1)\n\t\t\treturn 1;\n\n\t\tif (esp->msg_in[1] != 1)\n\t\t\tgoto do_reject;\n\n\t\tent = esp->active_cmd;\n\t\tspriv = ESP_CMD_PRIV(ent->cmd);\n\n\t\tif (spriv->cur_residue == sg_dma_len(spriv->cur_sg)) {\n\t\t\tspriv->cur_sg = spriv->prv_sg;\n\t\t\tspriv->cur_residue = 1;\n\t\t} else\n\t\t\tspriv->cur_residue++;\n\t\tspriv->tot_residue++;\n\t\treturn 0;\n\t}\n\tcase NOP:\n\t\treturn 0;\n\tcase RESTORE_POINTERS:\n\t\tesp_restore_pointers(esp, esp->active_cmd);\n\t\treturn 0;\n\tcase SAVE_POINTERS:\n\t\tesp_save_pointers(esp, esp->active_cmd);\n\t\treturn 0;\n\n\tcase COMMAND_COMPLETE:\n\tcase DISCONNECT: {\n\t\tstruct esp_cmd_entry *ent = esp->active_cmd;\n\n\t\tent->message = msg0;\n\t\tesp_event(esp, ESP_EVENT_FREE_BUS);\n\t\tesp->flags |= ESP_FLAG_QUICKIRQ_CHECK;\n\t\treturn 0;\n\t}\n\tcase MESSAGE_REJECT:\n\t\tesp_msgin_reject(esp);\n\t\treturn 0;\n\n\tdefault:\n\tdo_reject:\n\t\tesp->msg_out[0] = MESSAGE_REJECT;\n\t\tesp->msg_out_len = 1;\n\t\tscsi_esp_cmd(esp, ESP_CMD_SATN);\n\t\treturn 0;\n\t}\n}\n\nstatic int esp_process_event(struct esp *esp)\n{\n\tint write, i;\n\nagain:\n\twrite = 0;\n\tesp_log_event(\"process event %d phase %x\\n\",\n\t\t      esp->event, esp->sreg & ESP_STAT_PMASK);\n\tswitch (esp->event) {\n\tcase ESP_EVENT_CHECK_PHASE:\n\t\tswitch (esp->sreg & ESP_STAT_PMASK) {\n\t\tcase ESP_DOP:\n\t\t\tesp_event(esp, ESP_EVENT_DATA_OUT);\n\t\t\tbreak;\n\t\tcase ESP_DIP:\n\t\t\tesp_event(esp, ESP_EVENT_DATA_IN);\n\t\t\tbreak;\n\t\tcase ESP_STATP:\n\t\t\tesp_flush_fifo(esp);\n\t\t\tscsi_esp_cmd(esp, ESP_CMD_ICCSEQ);\n\t\t\tesp_event(esp, ESP_EVENT_STATUS);\n\t\t\tesp->flags |= ESP_FLAG_QUICKIRQ_CHECK;\n\t\t\treturn 1;\n\n\t\tcase ESP_MOP:\n\t\t\tesp_event(esp, ESP_EVENT_MSGOUT);\n\t\t\tbreak;\n\n\t\tcase ESP_MIP:\n\t\t\tesp_event(esp, ESP_EVENT_MSGIN);\n\t\t\tbreak;\n\n\t\tcase ESP_CMDP:\n\t\t\tesp_event(esp, ESP_EVENT_CMD_START);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tshost_printk(KERN_INFO, esp->host,\n\t\t\t\t     \"Unexpected phase, sreg=%02x\\n\",\n\t\t\t\t     esp->sreg);\n\t\t\tesp_schedule_reset(esp);\n\t\t\treturn 0;\n\t\t}\n\t\tgoto again;\n\n\tcase ESP_EVENT_DATA_IN:\n\t\twrite = 1;\n\t\tfallthrough;\n\n\tcase ESP_EVENT_DATA_OUT: {\n\t\tstruct esp_cmd_entry *ent = esp->active_cmd;\n\t\tstruct scsi_cmnd *cmd = ent->cmd;\n\t\tdma_addr_t dma_addr = esp_cur_dma_addr(ent, cmd);\n\t\tunsigned int dma_len = esp_cur_dma_len(ent, cmd);\n\n\t\tif (esp->rev == ESP100)\n\t\t\tscsi_esp_cmd(esp, ESP_CMD_NULL);\n\n\t\tif (write)\n\t\t\tent->flags |= ESP_CMD_FLAG_WRITE;\n\t\telse\n\t\t\tent->flags &= ~ESP_CMD_FLAG_WRITE;\n\n\t\tif (esp->ops->dma_length_limit)\n\t\t\tdma_len = esp->ops->dma_length_limit(esp, dma_addr,\n\t\t\t\t\t\t\t     dma_len);\n\t\telse\n\t\t\tdma_len = esp_dma_length_limit(esp, dma_addr, dma_len);\n\n\t\tesp->data_dma_len = dma_len;\n\n\t\tif (!dma_len) {\n\t\t\tshost_printk(KERN_ERR, esp->host,\n\t\t\t\t     \"DMA length is zero!\\n\");\n\t\t\tshost_printk(KERN_ERR, esp->host,\n\t\t\t\t     \"cur adr[%08llx] len[%08x]\\n\",\n\t\t\t\t     (unsigned long long)esp_cur_dma_addr(ent, cmd),\n\t\t\t\t     esp_cur_dma_len(ent, cmd));\n\t\t\tesp_schedule_reset(esp);\n\t\t\treturn 0;\n\t\t}\n\n\t\tesp_log_datastart(\"start data addr[%08llx] len[%u] write(%d)\\n\",\n\t\t\t\t  (unsigned long long)dma_addr, dma_len, write);\n\n\t\tesp->ops->send_dma_cmd(esp, dma_addr, dma_len, dma_len,\n\t\t\t\t       write, ESP_CMD_DMA | ESP_CMD_TI);\n\t\tesp_event(esp, ESP_EVENT_DATA_DONE);\n\t\tbreak;\n\t}\n\tcase ESP_EVENT_DATA_DONE: {\n\t\tstruct esp_cmd_entry *ent = esp->active_cmd;\n\t\tstruct scsi_cmnd *cmd = ent->cmd;\n\t\tint bytes_sent;\n\n\t\tif (esp->ops->dma_error(esp)) {\n\t\t\tshost_printk(KERN_INFO, esp->host,\n\t\t\t\t     \"data done, DMA error, resetting\\n\");\n\t\t\tesp_schedule_reset(esp);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (ent->flags & ESP_CMD_FLAG_WRITE) {\n\t\t\t \n\n\t\t\tesp->ops->dma_drain(esp);\n\t\t}\n\t\tesp->ops->dma_invalidate(esp);\n\n\t\tif (esp->ireg != ESP_INTR_BSERV) {\n\t\t\t \n\t\t\tshost_printk(KERN_INFO, esp->host,\n\t\t\t\t     \"data done, not BSERV, resetting\\n\");\n\t\t\tesp_schedule_reset(esp);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbytes_sent = esp_data_bytes_sent(esp, ent, cmd);\n\n\t\tesp_log_datadone(\"data done flgs[%x] sent[%d]\\n\",\n\t\t\t\t ent->flags, bytes_sent);\n\n\t\tif (bytes_sent < 0) {\n\t\t\t \n\t\t\tesp_schedule_reset(esp);\n\t\t\treturn 0;\n\t\t}\n\n\t\tesp_advance_dma(esp, ent, cmd, bytes_sent);\n\t\tesp_event(esp, ESP_EVENT_CHECK_PHASE);\n\t\tgoto again;\n\t}\n\n\tcase ESP_EVENT_STATUS: {\n\t\tstruct esp_cmd_entry *ent = esp->active_cmd;\n\n\t\tif (esp->ireg & ESP_INTR_FDONE) {\n\t\t\tent->status = esp_read8(ESP_FDATA);\n\t\t\tent->message = esp_read8(ESP_FDATA);\n\t\t\tscsi_esp_cmd(esp, ESP_CMD_MOK);\n\t\t} else if (esp->ireg == ESP_INTR_BSERV) {\n\t\t\tent->status = esp_read8(ESP_FDATA);\n\t\t\tent->message = 0xff;\n\t\t\tesp_event(esp, ESP_EVENT_MSGIN);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (ent->message != COMMAND_COMPLETE) {\n\t\t\tshost_printk(KERN_INFO, esp->host,\n\t\t\t\t     \"Unexpected message %x in status\\n\",\n\t\t\t\t     ent->message);\n\t\t\tesp_schedule_reset(esp);\n\t\t\treturn 0;\n\t\t}\n\n\t\tesp_event(esp, ESP_EVENT_FREE_BUS);\n\t\tesp->flags |= ESP_FLAG_QUICKIRQ_CHECK;\n\t\tbreak;\n\t}\n\tcase ESP_EVENT_FREE_BUS: {\n\t\tstruct esp_cmd_entry *ent = esp->active_cmd;\n\t\tstruct scsi_cmnd *cmd = ent->cmd;\n\n\t\tif (ent->message == COMMAND_COMPLETE ||\n\t\t    ent->message == DISCONNECT)\n\t\t\tscsi_esp_cmd(esp, ESP_CMD_ESEL);\n\n\t\tif (ent->message == COMMAND_COMPLETE) {\n\t\t\tesp_log_cmddone(\"Command done status[%x] message[%x]\\n\",\n\t\t\t\t\tent->status, ent->message);\n\t\t\tif (ent->status == SAM_STAT_TASK_SET_FULL)\n\t\t\t\tesp_event_queue_full(esp, ent);\n\n\t\t\tif (ent->status == SAM_STAT_CHECK_CONDITION &&\n\t\t\t    !(ent->flags & ESP_CMD_FLAG_AUTOSENSE)) {\n\t\t\t\tent->flags |= ESP_CMD_FLAG_AUTOSENSE;\n\t\t\t\tesp_autosense(esp, ent);\n\t\t\t} else {\n\t\t\t\tesp_cmd_is_done(esp, ent, cmd, DID_OK);\n\t\t\t}\n\t\t} else if (ent->message == DISCONNECT) {\n\t\t\tesp_log_disconnect(\"Disconnecting tgt[%d] tag[%x:%x]\\n\",\n\t\t\t\t\t   cmd->device->id,\n\t\t\t\t\t   ent->tag[0], ent->tag[1]);\n\n\t\t\tesp->active_cmd = NULL;\n\t\t\tesp_maybe_execute_command(esp);\n\t\t} else {\n\t\t\tshost_printk(KERN_INFO, esp->host,\n\t\t\t\t     \"Unexpected message %x in freebus\\n\",\n\t\t\t\t     ent->message);\n\t\t\tesp_schedule_reset(esp);\n\t\t\treturn 0;\n\t\t}\n\t\tif (esp->active_cmd)\n\t\t\tesp->flags |= ESP_FLAG_QUICKIRQ_CHECK;\n\t\tbreak;\n\t}\n\tcase ESP_EVENT_MSGOUT: {\n\t\tscsi_esp_cmd(esp, ESP_CMD_FLUSH);\n\n\t\tif (esp_debug & ESP_DEBUG_MSGOUT) {\n\t\t\tint i;\n\t\t\tprintk(\"ESP: Sending message [ \");\n\t\t\tfor (i = 0; i < esp->msg_out_len; i++)\n\t\t\t\tprintk(\"%02x \", esp->msg_out[i]);\n\t\t\tprintk(\"]\\n\");\n\t\t}\n\n\t\tif (esp->rev == FASHME) {\n\t\t\tint i;\n\n\t\t\t \n\t\t\tfor (i = 0; i < esp->msg_out_len; i++) {\n\t\t\t\tesp_write8(esp->msg_out[i], ESP_FDATA);\n\t\t\t\tesp_write8(0, ESP_FDATA);\n\t\t\t}\n\t\t\tscsi_esp_cmd(esp, ESP_CMD_TI);\n\t\t} else {\n\t\t\tif (esp->msg_out_len == 1) {\n\t\t\t\tesp_write8(esp->msg_out[0], ESP_FDATA);\n\t\t\t\tscsi_esp_cmd(esp, ESP_CMD_TI);\n\t\t\t} else if (esp->flags & ESP_FLAG_USE_FIFO) {\n\t\t\t\tfor (i = 0; i < esp->msg_out_len; i++)\n\t\t\t\t\tesp_write8(esp->msg_out[i], ESP_FDATA);\n\t\t\t\tscsi_esp_cmd(esp, ESP_CMD_TI);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmemcpy(esp->command_block,\n\t\t\t\t       esp->msg_out,\n\t\t\t\t       esp->msg_out_len);\n\n\t\t\t\tesp->ops->send_dma_cmd(esp,\n\t\t\t\t\t\t       esp->command_block_dma,\n\t\t\t\t\t\t       esp->msg_out_len,\n\t\t\t\t\t\t       esp->msg_out_len,\n\t\t\t\t\t\t       0,\n\t\t\t\t\t\t       ESP_CMD_DMA|ESP_CMD_TI);\n\t\t\t}\n\t\t}\n\t\tesp_event(esp, ESP_EVENT_MSGOUT_DONE);\n\t\tbreak;\n\t}\n\tcase ESP_EVENT_MSGOUT_DONE:\n\t\tif (esp->rev == FASHME) {\n\t\t\tscsi_esp_cmd(esp, ESP_CMD_FLUSH);\n\t\t} else {\n\t\t\tif (esp->msg_out_len > 1)\n\t\t\t\tesp->ops->dma_invalidate(esp);\n\n\t\t\t \n\t\t\tif (!(esp->ireg & ESP_INTR_DC))\n\t\t\t\tscsi_esp_cmd(esp, ESP_CMD_NULL);\n\t\t}\n\n\t\tesp->msg_out_len = 0;\n\n\t\tesp_event(esp, ESP_EVENT_CHECK_PHASE);\n\t\tgoto again;\n\tcase ESP_EVENT_MSGIN:\n\t\tif (esp->ireg & ESP_INTR_BSERV) {\n\t\t\tif (esp->rev == FASHME) {\n\t\t\t\tif (!(esp_read8(ESP_STATUS2) &\n\t\t\t\t      ESP_STAT2_FEMPTY))\n\t\t\t\t\tscsi_esp_cmd(esp, ESP_CMD_FLUSH);\n\t\t\t} else {\n\t\t\t\tscsi_esp_cmd(esp, ESP_CMD_FLUSH);\n\t\t\t\tif (esp->rev == ESP100)\n\t\t\t\t\tscsi_esp_cmd(esp, ESP_CMD_NULL);\n\t\t\t}\n\t\t\tscsi_esp_cmd(esp, ESP_CMD_TI);\n\t\t\tesp->flags |= ESP_FLAG_QUICKIRQ_CHECK;\n\t\t\treturn 1;\n\t\t}\n\t\tif (esp->ireg & ESP_INTR_FDONE) {\n\t\t\tu8 val;\n\n\t\t\tif (esp->rev == FASHME)\n\t\t\t\tval = esp->fifo[0];\n\t\t\telse\n\t\t\t\tval = esp_read8(ESP_FDATA);\n\t\t\tesp->msg_in[esp->msg_in_len++] = val;\n\n\t\t\tesp_log_msgin(\"Got msgin byte %x\\n\", val);\n\n\t\t\tif (!esp_msgin_process(esp))\n\t\t\t\tesp->msg_in_len = 0;\n\n\t\t\tif (esp->rev == FASHME)\n\t\t\t\tscsi_esp_cmd(esp, ESP_CMD_FLUSH);\n\n\t\t\tscsi_esp_cmd(esp, ESP_CMD_MOK);\n\n\t\t\t \n\t\t\tif (esp->event == ESP_EVENT_RESET)\n\t\t\t\treturn 0;\n\n\t\t\tif (esp->event != ESP_EVENT_FREE_BUS)\n\t\t\t\tesp_event(esp, ESP_EVENT_CHECK_PHASE);\n\t\t} else {\n\t\t\tshost_printk(KERN_INFO, esp->host,\n\t\t\t\t     \"MSGIN neither BSERV not FDON, resetting\");\n\t\t\tesp_schedule_reset(esp);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase ESP_EVENT_CMD_START:\n\t\tmemcpy(esp->command_block, esp->cmd_bytes_ptr,\n\t\t       esp->cmd_bytes_left);\n\t\tesp_send_dma_cmd(esp, esp->cmd_bytes_left, 16, ESP_CMD_TI);\n\t\tesp_event(esp, ESP_EVENT_CMD_DONE);\n\t\tesp->flags |= ESP_FLAG_QUICKIRQ_CHECK;\n\t\tbreak;\n\tcase ESP_EVENT_CMD_DONE:\n\t\tesp->ops->dma_invalidate(esp);\n\t\tif (esp->ireg & ESP_INTR_BSERV) {\n\t\t\tesp_event(esp, ESP_EVENT_CHECK_PHASE);\n\t\t\tgoto again;\n\t\t}\n\t\tesp_schedule_reset(esp);\n\t\treturn 0;\n\n\tcase ESP_EVENT_RESET:\n\t\tscsi_esp_cmd(esp, ESP_CMD_RS);\n\t\tbreak;\n\n\tdefault:\n\t\tshost_printk(KERN_INFO, esp->host,\n\t\t\t     \"Unexpected event %x, resetting\\n\", esp->event);\n\t\tesp_schedule_reset(esp);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void esp_reset_cleanup_one(struct esp *esp, struct esp_cmd_entry *ent)\n{\n\tstruct scsi_cmnd *cmd = ent->cmd;\n\n\tesp_unmap_dma(esp, cmd);\n\tesp_free_lun_tag(ent, cmd->device->hostdata);\n\tcmd->result = DID_RESET << 16;\n\n\tif (ent->flags & ESP_CMD_FLAG_AUTOSENSE)\n\t\tesp_unmap_sense(esp, ent);\n\n\tscsi_done(cmd);\n\tlist_del(&ent->list);\n\tesp_put_ent(esp, ent);\n}\n\nstatic void esp_clear_hold(struct scsi_device *dev, void *data)\n{\n\tstruct esp_lun_data *lp = dev->hostdata;\n\n\tBUG_ON(lp->num_tagged);\n\tlp->hold = 0;\n}\n\nstatic void esp_reset_cleanup(struct esp *esp)\n{\n\tstruct esp_cmd_entry *ent, *tmp;\n\tint i;\n\n\tlist_for_each_entry_safe(ent, tmp, &esp->queued_cmds, list) {\n\t\tstruct scsi_cmnd *cmd = ent->cmd;\n\n\t\tlist_del(&ent->list);\n\t\tcmd->result = DID_RESET << 16;\n\t\tscsi_done(cmd);\n\t\tesp_put_ent(esp, ent);\n\t}\n\n\tlist_for_each_entry_safe(ent, tmp, &esp->active_cmds, list) {\n\t\tif (ent == esp->active_cmd)\n\t\t\tesp->active_cmd = NULL;\n\t\tesp_reset_cleanup_one(esp, ent);\n\t}\n\n\tBUG_ON(esp->active_cmd != NULL);\n\n\t \n\tfor (i = 0; i < ESP_MAX_TARGET; i++) {\n\t\tstruct esp_target_data *tp = &esp->target[i];\n\n\t\ttp->esp_period = 0;\n\t\ttp->esp_offset = 0;\n\t\ttp->esp_config3 &= ~(ESP_CONFIG3_EWIDE |\n\t\t\t\t     ESP_CONFIG3_FSCSI |\n\t\t\t\t     ESP_CONFIG3_FAST);\n\t\ttp->flags &= ~ESP_TGT_WIDE;\n\t\ttp->flags |= ESP_TGT_CHECK_NEGO;\n\n\t\tif (tp->starget)\n\t\t\t__starget_for_each_device(tp->starget, NULL,\n\t\t\t\t\t\t  esp_clear_hold);\n\t}\n\tesp->flags &= ~ESP_FLAG_RESETTING;\n}\n\n \nstatic void __esp_interrupt(struct esp *esp)\n{\n\tint finish_reset, intr_done;\n\tu8 phase;\n\n        \n\tesp->sreg = esp_read8(ESP_STATUS);\n\tesp->seqreg = esp_read8(ESP_SSTEP);\n\tesp->ireg = esp_read8(ESP_INTRPT);\n\n\tif (esp->flags & ESP_FLAG_RESETTING) {\n\t\tfinish_reset = 1;\n\t} else {\n\t\tif (esp_check_gross_error(esp))\n\t\t\treturn;\n\n\t\tfinish_reset = esp_check_spur_intr(esp);\n\t\tif (finish_reset < 0)\n\t\t\treturn;\n\t}\n\n\tif (esp->ireg & ESP_INTR_SR)\n\t\tfinish_reset = 1;\n\n\tif (finish_reset) {\n\t\tesp_reset_cleanup(esp);\n\t\tif (esp->eh_reset) {\n\t\t\tcomplete(esp->eh_reset);\n\t\t\tesp->eh_reset = NULL;\n\t\t}\n\t\treturn;\n\t}\n\n\tphase = (esp->sreg & ESP_STAT_PMASK);\n\tif (esp->rev == FASHME) {\n\t\tif (((phase != ESP_DIP && phase != ESP_DOP) &&\n\t\t     esp->select_state == ESP_SELECT_NONE &&\n\t\t     esp->event != ESP_EVENT_STATUS &&\n\t\t     esp->event != ESP_EVENT_DATA_DONE) ||\n\t\t    (esp->ireg & ESP_INTR_RSEL)) {\n\t\t\tesp->sreg2 = esp_read8(ESP_STATUS2);\n\t\t\tif (!(esp->sreg2 & ESP_STAT2_FEMPTY) ||\n\t\t\t    (esp->sreg2 & ESP_STAT2_F1BYTE))\n\t\t\t\thme_read_fifo(esp);\n\t\t}\n\t}\n\n\tesp_log_intr(\"intr sreg[%02x] seqreg[%02x] \"\n\t\t     \"sreg2[%02x] ireg[%02x]\\n\",\n\t\t     esp->sreg, esp->seqreg, esp->sreg2, esp->ireg);\n\n\tintr_done = 0;\n\n\tif (esp->ireg & (ESP_INTR_S | ESP_INTR_SATN | ESP_INTR_IC)) {\n\t\tshost_printk(KERN_INFO, esp->host,\n\t\t\t     \"unexpected IREG %02x\\n\", esp->ireg);\n\t\tif (esp->ireg & ESP_INTR_IC)\n\t\t\tesp_dump_cmd_log(esp);\n\n\t\tesp_schedule_reset(esp);\n\t} else {\n\t\tif (esp->ireg & ESP_INTR_RSEL) {\n\t\t\tif (esp->active_cmd)\n\t\t\t\t(void) esp_finish_select(esp);\n\t\t\tintr_done = esp_reconnect(esp);\n\t\t} else {\n\t\t\t \n\t\t\tif (esp->select_state != ESP_SELECT_NONE)\n\t\t\t\tintr_done = esp_finish_select(esp);\n\t\t}\n\t}\n\twhile (!intr_done)\n\t\tintr_done = esp_process_event(esp);\n}\n\nirqreturn_t scsi_esp_intr(int irq, void *dev_id)\n{\n\tstruct esp *esp = dev_id;\n\tunsigned long flags;\n\tirqreturn_t ret;\n\n\tspin_lock_irqsave(esp->host->host_lock, flags);\n\tret = IRQ_NONE;\n\tif (esp->ops->irq_pending(esp)) {\n\t\tret = IRQ_HANDLED;\n\t\tfor (;;) {\n\t\t\tint i;\n\n\t\t\t__esp_interrupt(esp);\n\t\t\tif (!(esp->flags & ESP_FLAG_QUICKIRQ_CHECK))\n\t\t\t\tbreak;\n\t\t\tesp->flags &= ~ESP_FLAG_QUICKIRQ_CHECK;\n\n\t\t\tfor (i = 0; i < ESP_QUICKIRQ_LIMIT; i++) {\n\t\t\t\tif (esp->ops->irq_pending(esp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == ESP_QUICKIRQ_LIMIT)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(esp->host->host_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(scsi_esp_intr);\n\nstatic void esp_get_revision(struct esp *esp)\n{\n\tu8 val;\n\n\tesp->config1 = (ESP_CONFIG1_PENABLE | (esp->scsi_id & 7));\n\tif (esp->config2 == 0) {\n\t\tesp->config2 = (ESP_CONFIG2_SCSI2ENAB | ESP_CONFIG2_REGPARITY);\n\t\tesp_write8(esp->config2, ESP_CFG2);\n\n\t\tval = esp_read8(ESP_CFG2);\n\t\tval &= ~ESP_CONFIG2_MAGIC;\n\n\t\tesp->config2 = 0;\n\t\tif (val != (ESP_CONFIG2_SCSI2ENAB | ESP_CONFIG2_REGPARITY)) {\n\t\t\t \n\t\t\tesp->rev = ESP100;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tesp_set_all_config3(esp, 5);\n\tesp->prev_cfg3 = 5;\n\tesp_write8(esp->config2, ESP_CFG2);\n\tesp_write8(0, ESP_CFG3);\n\tesp_write8(esp->prev_cfg3, ESP_CFG3);\n\n\tval = esp_read8(ESP_CFG3);\n\tif (val != 5) {\n\t\t \n\t\tesp->rev = ESP100A;\n\t} else {\n\t\tesp_set_all_config3(esp, 0);\n\t\tesp->prev_cfg3 = 0;\n\t\tesp_write8(esp->prev_cfg3, ESP_CFG3);\n\n\t\t \n\t\tif (esp->cfact == 0 || esp->cfact > ESP_CCF_F5) {\n\t\t\tesp->rev = FAST;\n\t\t\tesp->sync_defp = SYNC_DEFP_FAST;\n\t\t} else {\n\t\t\tesp->rev = ESP236;\n\t\t}\n\t}\n}\n\nstatic void esp_init_swstate(struct esp *esp)\n{\n\tint i;\n\n\tINIT_LIST_HEAD(&esp->queued_cmds);\n\tINIT_LIST_HEAD(&esp->active_cmds);\n\tINIT_LIST_HEAD(&esp->esp_cmd_pool);\n\n\t \n\tfor (i = 0 ; i < ESP_MAX_TARGET; i++) {\n\t\tesp->target[i].flags = 0;\n\t\tesp->target[i].nego_goal_period = 0;\n\t\tesp->target[i].nego_goal_offset = 0;\n\t\tesp->target[i].nego_goal_width = 0;\n\t\tesp->target[i].nego_goal_tags = 0;\n\t}\n}\n\n \nstatic void esp_bootup_reset(struct esp *esp)\n{\n\tu8 val;\n\n\t \n\tesp->ops->reset_dma(esp);\n\n\t \n\tesp_reset_esp(esp);\n\n\t \n\tval = esp_read8(ESP_CFG1);\n\tval |= ESP_CONFIG1_SRRDISAB;\n\tesp_write8(val, ESP_CFG1);\n\n\tscsi_esp_cmd(esp, ESP_CMD_RS);\n\tudelay(400);\n\n\tesp_write8(esp->config1, ESP_CFG1);\n\n\t \n\tesp_read8(ESP_INTRPT);\n}\n\nstatic void esp_set_clock_params(struct esp *esp)\n{\n\tint fhz;\n\tu8 ccf;\n\n\t \n\tfhz = esp->cfreq;\n\n\tccf = ((fhz / 1000000) + 4) / 5;\n\tif (ccf == 1)\n\t\tccf = 2;\n\n\t \n\tif (fhz <= 5000000 || ccf < 1 || ccf > 8) {\n\t\tfhz = 20000000;\n\t\tccf = 4;\n\t}\n\n\tesp->cfact = (ccf == 8 ? 0 : ccf);\n\tesp->cfreq = fhz;\n\tesp->ccycle = ESP_HZ_TO_CYCLE(fhz);\n\tesp->ctick = ESP_TICK(ccf, esp->ccycle);\n\tesp->neg_defp = ESP_NEG_DEFP(fhz, ccf);\n\tesp->sync_defp = SYNC_DEFP_SLOW;\n}\n\nstatic const char *esp_chip_names[] = {\n\t\"ESP100\",\n\t\"ESP100A\",\n\t\"ESP236\",\n\t\"FAS236\",\n\t\"AM53C974\",\n\t\"53CF9x-2\",\n\t\"FAS100A\",\n\t\"FAST\",\n\t\"FASHME\",\n};\n\nstatic struct scsi_transport_template *esp_transport_template;\n\nint scsi_esp_register(struct esp *esp)\n{\n\tstatic int instance;\n\tint err;\n\n\tif (!esp->num_tags)\n\t\tesp->num_tags = ESP_DEFAULT_TAGS;\n\tesp->host->transportt = esp_transport_template;\n\tesp->host->max_lun = ESP_MAX_LUN;\n\tesp->host->cmd_per_lun = 2;\n\tesp->host->unique_id = instance;\n\n\tesp_set_clock_params(esp);\n\n\tesp_get_revision(esp);\n\n\tesp_init_swstate(esp);\n\n\tesp_bootup_reset(esp);\n\n\tdev_printk(KERN_INFO, esp->dev, \"esp%u: regs[%1p:%1p] irq[%u]\\n\",\n\t\t   esp->host->unique_id, esp->regs, esp->dma_regs,\n\t\t   esp->host->irq);\n\tdev_printk(KERN_INFO, esp->dev,\n\t\t   \"esp%u: is a %s, %u MHz (ccf=%u), SCSI ID %u\\n\",\n\t\t   esp->host->unique_id, esp_chip_names[esp->rev],\n\t\t   esp->cfreq / 1000000, esp->cfact, esp->scsi_id);\n\n\t \n\tssleep(esp_bus_reset_settle);\n\n\terr = scsi_add_host(esp->host, esp->dev);\n\tif (err)\n\t\treturn err;\n\n\tinstance++;\n\n\tscsi_scan_host(esp->host);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(scsi_esp_register);\n\nvoid scsi_esp_unregister(struct esp *esp)\n{\n\tscsi_remove_host(esp->host);\n}\nEXPORT_SYMBOL(scsi_esp_unregister);\n\nstatic int esp_target_alloc(struct scsi_target *starget)\n{\n\tstruct esp *esp = shost_priv(dev_to_shost(&starget->dev));\n\tstruct esp_target_data *tp = &esp->target[starget->id];\n\n\ttp->starget = starget;\n\n\treturn 0;\n}\n\nstatic void esp_target_destroy(struct scsi_target *starget)\n{\n\tstruct esp *esp = shost_priv(dev_to_shost(&starget->dev));\n\tstruct esp_target_data *tp = &esp->target[starget->id];\n\n\ttp->starget = NULL;\n}\n\nstatic int esp_slave_alloc(struct scsi_device *dev)\n{\n\tstruct esp *esp = shost_priv(dev->host);\n\tstruct esp_target_data *tp = &esp->target[dev->id];\n\tstruct esp_lun_data *lp;\n\n\tlp = kzalloc(sizeof(*lp), GFP_KERNEL);\n\tif (!lp)\n\t\treturn -ENOMEM;\n\tdev->hostdata = lp;\n\n\tspi_min_period(tp->starget) = esp->min_period;\n\tspi_max_offset(tp->starget) = 15;\n\n\tif (esp->flags & ESP_FLAG_WIDE_CAPABLE)\n\t\tspi_max_width(tp->starget) = 1;\n\telse\n\t\tspi_max_width(tp->starget) = 0;\n\n\treturn 0;\n}\n\nstatic int esp_slave_configure(struct scsi_device *dev)\n{\n\tstruct esp *esp = shost_priv(dev->host);\n\tstruct esp_target_data *tp = &esp->target[dev->id];\n\n\tif (dev->tagged_supported)\n\t\tscsi_change_queue_depth(dev, esp->num_tags);\n\n\ttp->flags |= ESP_TGT_DISCONNECT;\n\n\tif (!spi_initial_dv(dev->sdev_target))\n\t\tspi_dv_device(dev);\n\n\treturn 0;\n}\n\nstatic void esp_slave_destroy(struct scsi_device *dev)\n{\n\tstruct esp_lun_data *lp = dev->hostdata;\n\n\tkfree(lp);\n\tdev->hostdata = NULL;\n}\n\nstatic int esp_eh_abort_handler(struct scsi_cmnd *cmd)\n{\n\tstruct esp *esp = shost_priv(cmd->device->host);\n\tstruct esp_cmd_entry *ent, *tmp;\n\tstruct completion eh_done;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(esp->host->host_lock, flags);\n\tshost_printk(KERN_ERR, esp->host, \"Aborting command [%p:%02x]\\n\",\n\t\t     cmd, cmd->cmnd[0]);\n\tent = esp->active_cmd;\n\tif (ent)\n\t\tshost_printk(KERN_ERR, esp->host,\n\t\t\t     \"Current command [%p:%02x]\\n\",\n\t\t\t     ent->cmd, ent->cmd->cmnd[0]);\n\tlist_for_each_entry(ent, &esp->queued_cmds, list) {\n\t\tshost_printk(KERN_ERR, esp->host, \"Queued command [%p:%02x]\\n\",\n\t\t\t     ent->cmd, ent->cmd->cmnd[0]);\n\t}\n\tlist_for_each_entry(ent, &esp->active_cmds, list) {\n\t\tshost_printk(KERN_ERR, esp->host, \" Active command [%p:%02x]\\n\",\n\t\t\t     ent->cmd, ent->cmd->cmnd[0]);\n\t}\n\tesp_dump_cmd_log(esp);\n\tspin_unlock_irqrestore(esp->host->host_lock, flags);\n\n\tspin_lock_irqsave(esp->host->host_lock, flags);\n\n\tent = NULL;\n\tlist_for_each_entry(tmp, &esp->queued_cmds, list) {\n\t\tif (tmp->cmd == cmd) {\n\t\t\tent = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ent) {\n\t\t \n\t\tlist_del(&ent->list);\n\n\t\tcmd->result = DID_ABORT << 16;\n\t\tscsi_done(cmd);\n\n\t\tesp_put_ent(esp, ent);\n\n\t\tgoto out_success;\n\t}\n\n\tinit_completion(&eh_done);\n\n\tent = esp->active_cmd;\n\tif (ent && ent->cmd == cmd) {\n\t\t \n\t\tif (esp->msg_out_len)\n\t\t\tgoto out_failure;\n\n\t\t \n\t\tesp->msg_out[0] = ABORT_TASK_SET;\n\t\tesp->msg_out_len = 1;\n\t\tent->eh_done = &eh_done;\n\n\t\tscsi_esp_cmd(esp, ESP_CMD_SATN);\n\t} else {\n\t\t \n\t\tgoto out_failure;\n\t}\n\n\tspin_unlock_irqrestore(esp->host->host_lock, flags);\n\n\tif (!wait_for_completion_timeout(&eh_done, 5 * HZ)) {\n\t\tspin_lock_irqsave(esp->host->host_lock, flags);\n\t\tent->eh_done = NULL;\n\t\tspin_unlock_irqrestore(esp->host->host_lock, flags);\n\n\t\treturn FAILED;\n\t}\n\n\treturn SUCCESS;\n\nout_success:\n\tspin_unlock_irqrestore(esp->host->host_lock, flags);\n\treturn SUCCESS;\n\nout_failure:\n\t \n\tspin_unlock_irqrestore(esp->host->host_lock, flags);\n\treturn FAILED;\n}\n\nstatic int esp_eh_bus_reset_handler(struct scsi_cmnd *cmd)\n{\n\tstruct esp *esp = shost_priv(cmd->device->host);\n\tstruct completion eh_reset;\n\tunsigned long flags;\n\n\tinit_completion(&eh_reset);\n\n\tspin_lock_irqsave(esp->host->host_lock, flags);\n\n\tesp->eh_reset = &eh_reset;\n\n\t \n\tesp->flags |= ESP_FLAG_RESETTING;\n\tscsi_esp_cmd(esp, ESP_CMD_RS);\n\n\tspin_unlock_irqrestore(esp->host->host_lock, flags);\n\n\tssleep(esp_bus_reset_settle);\n\n\tif (!wait_for_completion_timeout(&eh_reset, 5 * HZ)) {\n\t\tspin_lock_irqsave(esp->host->host_lock, flags);\n\t\tesp->eh_reset = NULL;\n\t\tspin_unlock_irqrestore(esp->host->host_lock, flags);\n\n\t\treturn FAILED;\n\t}\n\n\treturn SUCCESS;\n}\n\n \nstatic int esp_eh_host_reset_handler(struct scsi_cmnd *cmd)\n{\n\tstruct esp *esp = shost_priv(cmd->device->host);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(esp->host->host_lock, flags);\n\tesp_bootup_reset(esp);\n\tesp_reset_cleanup(esp);\n\tspin_unlock_irqrestore(esp->host->host_lock, flags);\n\n\tssleep(esp_bus_reset_settle);\n\n\treturn SUCCESS;\n}\n\nstatic const char *esp_info(struct Scsi_Host *host)\n{\n\treturn \"esp\";\n}\n\nconst struct scsi_host_template scsi_esp_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"esp\",\n\t.info\t\t\t= esp_info,\n\t.queuecommand\t\t= esp_queuecommand,\n\t.target_alloc\t\t= esp_target_alloc,\n\t.target_destroy\t\t= esp_target_destroy,\n\t.slave_alloc\t\t= esp_slave_alloc,\n\t.slave_configure\t= esp_slave_configure,\n\t.slave_destroy\t\t= esp_slave_destroy,\n\t.eh_abort_handler\t= esp_eh_abort_handler,\n\t.eh_bus_reset_handler\t= esp_eh_bus_reset_handler,\n\t.eh_host_reset_handler\t= esp_eh_host_reset_handler,\n\t.can_queue\t\t= 7,\n\t.this_id\t\t= 7,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.max_sectors\t\t= 0xffff,\n\t.skip_settle_delay\t= 1,\n\t.cmd_size\t\t= sizeof(struct esp_cmd_priv),\n};\nEXPORT_SYMBOL(scsi_esp_template);\n\nstatic void esp_get_signalling(struct Scsi_Host *host)\n{\n\tstruct esp *esp = shost_priv(host);\n\tenum spi_signal_type type;\n\n\tif (esp->flags & ESP_FLAG_DIFFERENTIAL)\n\t\ttype = SPI_SIGNAL_HVD;\n\telse\n\t\ttype = SPI_SIGNAL_SE;\n\n\tspi_signalling(host) = type;\n}\n\nstatic void esp_set_offset(struct scsi_target *target, int offset)\n{\n\tstruct Scsi_Host *host = dev_to_shost(target->dev.parent);\n\tstruct esp *esp = shost_priv(host);\n\tstruct esp_target_data *tp = &esp->target[target->id];\n\n\tif (esp->flags & ESP_FLAG_DISABLE_SYNC)\n\t\ttp->nego_goal_offset = 0;\n\telse\n\t\ttp->nego_goal_offset = offset;\n\ttp->flags |= ESP_TGT_CHECK_NEGO;\n}\n\nstatic void esp_set_period(struct scsi_target *target, int period)\n{\n\tstruct Scsi_Host *host = dev_to_shost(target->dev.parent);\n\tstruct esp *esp = shost_priv(host);\n\tstruct esp_target_data *tp = &esp->target[target->id];\n\n\ttp->nego_goal_period = period;\n\ttp->flags |= ESP_TGT_CHECK_NEGO;\n}\n\nstatic void esp_set_width(struct scsi_target *target, int width)\n{\n\tstruct Scsi_Host *host = dev_to_shost(target->dev.parent);\n\tstruct esp *esp = shost_priv(host);\n\tstruct esp_target_data *tp = &esp->target[target->id];\n\n\ttp->nego_goal_width = (width ? 1 : 0);\n\ttp->flags |= ESP_TGT_CHECK_NEGO;\n}\n\nstatic struct spi_function_template esp_transport_ops = {\n\t.set_offset\t\t= esp_set_offset,\n\t.show_offset\t\t= 1,\n\t.set_period\t\t= esp_set_period,\n\t.show_period\t\t= 1,\n\t.set_width\t\t= esp_set_width,\n\t.show_width\t\t= 1,\n\t.get_signalling\t\t= esp_get_signalling,\n};\n\nstatic int __init esp_init(void)\n{\n\tesp_transport_template = spi_attach_transport(&esp_transport_ops);\n\tif (!esp_transport_template)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void __exit esp_exit(void)\n{\n\tspi_release_transport(esp_transport_template);\n}\n\nMODULE_DESCRIPTION(\"ESP SCSI driver core\");\nMODULE_AUTHOR(\"David S. Miller (davem@davemloft.net)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n\nmodule_param(esp_bus_reset_settle, int, 0);\nMODULE_PARM_DESC(esp_bus_reset_settle,\n\t\t \"ESP scsi bus reset delay in seconds\");\n\nmodule_param(esp_debug, int, 0);\nMODULE_PARM_DESC(esp_debug,\n\"ESP bitmapped debugging message enable value:\\n\"\n\"\t0x00000001\tLog interrupt events\\n\"\n\"\t0x00000002\tLog scsi commands\\n\"\n\"\t0x00000004\tLog resets\\n\"\n\"\t0x00000008\tLog message in events\\n\"\n\"\t0x00000010\tLog message out events\\n\"\n\"\t0x00000020\tLog command completion\\n\"\n\"\t0x00000040\tLog disconnects\\n\"\n\"\t0x00000080\tLog data start\\n\"\n\"\t0x00000100\tLog data done\\n\"\n\"\t0x00000200\tLog reconnects\\n\"\n\"\t0x00000400\tLog auto-sense data\\n\"\n);\n\nmodule_init(esp_init);\nmodule_exit(esp_exit);\n\n#ifdef CONFIG_SCSI_ESP_PIO\nstatic inline unsigned int esp_wait_for_fifo(struct esp *esp)\n{\n\tint i = 500000;\n\n\tdo {\n\t\tunsigned int fbytes = esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES;\n\n\t\tif (fbytes)\n\t\t\treturn fbytes;\n\n\t\tudelay(1);\n\t} while (--i);\n\n\tshost_printk(KERN_ERR, esp->host, \"FIFO is empty. sreg [%02x]\\n\",\n\t\t     esp_read8(ESP_STATUS));\n\treturn 0;\n}\n\nstatic inline int esp_wait_for_intr(struct esp *esp)\n{\n\tint i = 500000;\n\n\tdo {\n\t\tesp->sreg = esp_read8(ESP_STATUS);\n\t\tif (esp->sreg & ESP_STAT_INTR)\n\t\t\treturn 0;\n\n\t\tudelay(1);\n\t} while (--i);\n\n\tshost_printk(KERN_ERR, esp->host, \"IRQ timeout. sreg [%02x]\\n\",\n\t\t     esp->sreg);\n\treturn 1;\n}\n\n#define ESP_FIFO_SIZE 16\n\nvoid esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,\n\t\t      u32 dma_count, int write, u8 cmd)\n{\n\tu8 phase = esp->sreg & ESP_STAT_PMASK;\n\n\tcmd &= ~ESP_CMD_DMA;\n\tesp->send_cmd_error = 0;\n\n\tif (write) {\n\t\tu8 *dst = (u8 *)addr;\n\t\tu8 mask = ~(phase == ESP_MIP ? ESP_INTR_FDONE : ESP_INTR_BSERV);\n\n\t\tscsi_esp_cmd(esp, cmd);\n\n\t\twhile (1) {\n\t\t\tif (!esp_wait_for_fifo(esp))\n\t\t\t\tbreak;\n\n\t\t\t*dst++ = readb(esp->fifo_reg);\n\t\t\t--esp_count;\n\n\t\t\tif (!esp_count)\n\t\t\t\tbreak;\n\n\t\t\tif (esp_wait_for_intr(esp)) {\n\t\t\t\tesp->send_cmd_error = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((esp->sreg & ESP_STAT_PMASK) != phase)\n\t\t\t\tbreak;\n\n\t\t\tesp->ireg = esp_read8(ESP_INTRPT);\n\t\t\tif (esp->ireg & mask) {\n\t\t\t\tesp->send_cmd_error = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (phase == ESP_MIP)\n\t\t\t\tesp_write8(ESP_CMD_MOK, ESP_CMD);\n\n\t\t\tesp_write8(ESP_CMD_TI, ESP_CMD);\n\t\t}\n\t} else {\n\t\tunsigned int n = ESP_FIFO_SIZE;\n\t\tu8 *src = (u8 *)addr;\n\n\t\tscsi_esp_cmd(esp, ESP_CMD_FLUSH);\n\n\t\tif (n > esp_count)\n\t\t\tn = esp_count;\n\t\twritesb(esp->fifo_reg, src, n);\n\t\tsrc += n;\n\t\tesp_count -= n;\n\n\t\tscsi_esp_cmd(esp, cmd);\n\n\t\twhile (esp_count) {\n\t\t\tif (esp_wait_for_intr(esp)) {\n\t\t\t\tesp->send_cmd_error = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((esp->sreg & ESP_STAT_PMASK) != phase)\n\t\t\t\tbreak;\n\n\t\t\tesp->ireg = esp_read8(ESP_INTRPT);\n\t\t\tif (esp->ireg & ~ESP_INTR_BSERV) {\n\t\t\t\tesp->send_cmd_error = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn = ESP_FIFO_SIZE -\n\t\t\t    (esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES);\n\n\t\t\tif (n > esp_count)\n\t\t\t\tn = esp_count;\n\t\t\twritesb(esp->fifo_reg, src, n);\n\t\t\tsrc += n;\n\t\t\tesp_count -= n;\n\n\t\t\tesp_write8(ESP_CMD_TI, ESP_CMD);\n\t\t}\n\t}\n\n\tesp->send_cmd_residual = esp_count;\n}\nEXPORT_SYMBOL(esp_send_pio_cmd);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}