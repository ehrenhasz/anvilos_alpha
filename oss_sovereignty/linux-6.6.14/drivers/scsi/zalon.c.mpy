{
  "module_name": "zalon.c",
  "hash_id": "4bd109fc70a2de0bfc5fa8e869cb9861156085f5777aca288ba4ca0b5b27a3c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/zalon.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <asm/hardware.h>\n#include <asm/io.h>\n\n#include \"../parisc/gsc.h\"\n\n#include \"ncr53c8xx.h\"\n\nMODULE_AUTHOR(\"Richard Hirst\");\nMODULE_DESCRIPTION(\"Bluefish/Zalon 720 SCSI Driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define GSC_SCSI_ZALON_OFFSET 0x800\n\n#define IO_MODULE_EIM\t\t(1*4)\n#define IO_MODULE_DC_ADATA\t(2*4)\n#define IO_MODULE_II_CDATA\t(3*4)\n#define IO_MODULE_IO_COMMAND\t(12*4)\n#define IO_MODULE_IO_STATUS\t(13*4)\n\n#define IOSTATUS_RY\t\t0x40\n#define IOSTATUS_FE\t\t0x80\n#define IOIIDATA_SMINT5L\t0x40000000\n#define IOIIDATA_MINT5EN\t0x20000000\n#define IOIIDATA_PACKEN\t\t0x10000000\n#define IOIIDATA_PREFETCHEN\t0x08000000\n#define IOIIDATA_IOII\t\t0x00000020\n\n#define CMD_RESET\t\t5\n\nstatic struct ncr_chip zalon720_chip __initdata = {\n\t.revision_id =\t0x0f,\n\t.burst_max =\t3,\n\t.offset_max =\t8,\n\t.nr_divisor =\t4,\n\t.features =\tFE_WIDE | FE_DIFF | FE_EHP| FE_MUX | FE_EA,\n};\n\n\n\n#if 0\n \n \n\nstatic u8 iodc_data[32] __attribute__ ((aligned (64)));\nstatic unsigned long pdc_result[32] __attribute__ ((aligned (16))) ={0,0,0,0};\n\nstatic int \nlasi_scsi_clock(void * hpa, int defaultclock)\n{\n\tint clock, status;\n\n\tstatus = pdc_iodc_read(&pdc_result, hpa, 0, &iodc_data, 32 );\n\tif (status == PDC_RET_OK) {\n\t\tclock = (int) pdc_result[16];\n\t} else {\n\t\tprintk(KERN_WARNING \"%s: pdc_iodc_read returned %d\\n\", __func__, status);\n\t\tclock = defaultclock; \n\t}\n\n\tprintk(KERN_DEBUG \"%s: SCSI clock %d\\n\", __func__, clock);\n \treturn clock;\n}\n#endif\n\nstatic struct scsi_host_template zalon7xx_template = {\n\t.module\t\t= THIS_MODULE,\n\t.proc_name\t= \"zalon7xx\",\n\t.cmd_size\t= sizeof(struct ncr_cmd_priv),\n};\n\nstatic int __init\nzalon_probe(struct parisc_device *dev)\n{\n\tstruct gsc_irq gsc_irq;\n\tu32 zalon_vers;\n\tint error = -ENODEV;\n\tvoid __iomem *zalon = ioremap(dev->hpa.start, 4096);\n\tvoid __iomem *io_port = zalon + GSC_SCSI_ZALON_OFFSET;\n\tstatic int unit = 0;\n\tstruct Scsi_Host *host;\n\tstruct ncr_device device;\n\n\t__raw_writel(CMD_RESET, zalon + IO_MODULE_IO_COMMAND);\n\twhile (!(__raw_readl(zalon + IO_MODULE_IO_STATUS) & IOSTATUS_RY))\n\t\tcpu_relax();\n\t__raw_writel(IOIIDATA_MINT5EN | IOIIDATA_PACKEN | IOIIDATA_PREFETCHEN,\n\t\tzalon + IO_MODULE_II_CDATA);\n\n\t \n\tzalon_vers = (__raw_readl(zalon + IO_MODULE_II_CDATA) >> 24) & 0x07;\n\n\t \n\tdev->irq = gsc_alloc_irq(&gsc_irq);\n\n\tprintk(KERN_INFO \"%s: Zalon version %d, IRQ %d\\n\", __func__,\n\t\tzalon_vers, dev->irq);\n\n\t__raw_writel(gsc_irq.txn_addr | gsc_irq.txn_data, zalon + IO_MODULE_EIM);\n\n\tif (zalon_vers == 0)\n\t\tprintk(KERN_WARNING \"%s: Zalon 1.1 or earlier\\n\", __func__);\n\n\tmemset(&device, 0, sizeof(struct ncr_device));\n\n\t \n\t__raw_writeb(0x20, io_port + 0x38);  \n\t__raw_writeb(0x04, io_port + 0x1b);  \n\t__raw_writeb(0x80, io_port + 0x22);  \n\n\t \n\tdevice.chip\t\t= zalon720_chip;\n\tdevice.host_id\t\t= 7;\n\tdevice.dev\t\t= &dev->dev;\n\tdevice.slot.base\t= dev->hpa.start + GSC_SCSI_ZALON_OFFSET;\n\tdevice.slot.base_v\t= io_port;\n\tdevice.slot.irq\t\t= dev->irq;\n\tdevice.differential\t= 2;\n\n\thost = ncr_attach(&zalon7xx_template, unit, &device);\n\tif (!host)\n\t\treturn -ENODEV;\n\n\tif (request_irq(dev->irq, ncr53c8xx_intr, IRQF_SHARED, \"zalon\", host)) {\n\t  dev_printk(KERN_ERR, &dev->dev, \"irq problem with %d, detaching\\n \",\n\t\t     dev->irq);\n\t\tgoto fail;\n\t}\n\n\tunit++;\n\n\tdev_set_drvdata(&dev->dev, host);\n\n\terror = scsi_add_host(host, &dev->dev);\n\tif (error)\n\t\tgoto fail_free_irq;\n\n\tscsi_scan_host(host);\n\treturn 0;\n\n fail_free_irq:\n\tfree_irq(dev->irq, host);\n fail:\n\tncr53c8xx_release(host);\n\treturn error;\n}\n\nstatic const struct parisc_device_id zalon_tbl[] __initconst = {\n\t{ HPHW_A_DMA, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x00089 }, \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(parisc, zalon_tbl);\n\nstatic void __exit zalon_remove(struct parisc_device *dev)\n{\n\tstruct Scsi_Host *host = dev_get_drvdata(&dev->dev);\n\n\tscsi_remove_host(host);\n\tncr53c8xx_release(host);\n\tfree_irq(dev->irq, host);\n}\n\nstatic struct parisc_driver zalon_driver __refdata = {\n\t.name =\t\t\"zalon\",\n\t.id_table =\tzalon_tbl,\n\t.probe =\tzalon_probe,\n\t.remove =\t__exit_p(zalon_remove),\n};\n\nstatic int __init zalon7xx_init(void)\n{\n\tint ret = ncr53c8xx_init();\n\tif (!ret)\n\t\tret = register_parisc_driver(&zalon_driver);\n\tif (ret)\n\t\tncr53c8xx_exit();\n\treturn ret;\n}\n\nstatic void __exit zalon7xx_exit(void)\n{\n\tunregister_parisc_driver(&zalon_driver);\n\tncr53c8xx_exit();\n}\n\nmodule_init(zalon7xx_init);\nmodule_exit(zalon7xx_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}