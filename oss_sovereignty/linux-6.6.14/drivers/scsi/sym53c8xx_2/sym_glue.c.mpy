{
  "module_name": "sym_glue.c",
  "hash_id": "75e0cf3a4ee9a9a922a11e636f54fc791e665713d6d8036806535d806d7496d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sym53c8xx_2/sym_glue.c",
  "human_readable_source": "\n \n#include <linux/ctype.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/spinlock.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_transport.h>\n\n#include \"sym_glue.h\"\n#include \"sym_nvram.h\"\n\n#define NAME53C\t\t\"sym53c\"\n#define NAME53C8XX\t\"sym53c8xx\"\n\nstruct sym_driver_setup sym_driver_setup = SYM_LINUX_DRIVER_SETUP;\nunsigned int sym_debug_flags = 0;\n\nstatic char *excl_string;\nstatic char *safe_string;\nmodule_param_named(cmd_per_lun, sym_driver_setup.max_tag, ushort, 0);\nmodule_param_named(burst, sym_driver_setup.burst_order, byte, 0);\nmodule_param_named(led, sym_driver_setup.scsi_led, byte, 0);\nmodule_param_named(diff, sym_driver_setup.scsi_diff, byte, 0);\nmodule_param_named(irqm, sym_driver_setup.irq_mode, byte, 0);\nmodule_param_named(buschk, sym_driver_setup.scsi_bus_check, byte, 0);\nmodule_param_named(hostid, sym_driver_setup.host_id, byte, 0);\nmodule_param_named(verb, sym_driver_setup.verbose, byte, 0);\nmodule_param_named(debug, sym_debug_flags, uint, 0);\nmodule_param_named(settle, sym_driver_setup.settle_delay, byte, 0);\nmodule_param_named(nvram, sym_driver_setup.use_nvram, byte, 0);\nmodule_param_named(excl, excl_string, charp, 0);\nmodule_param_named(safe, safe_string, charp, 0);\n\nMODULE_PARM_DESC(cmd_per_lun, \"The maximum number of tags to use by default\");\nMODULE_PARM_DESC(burst, \"Maximum burst.  0 to disable, 255 to read from registers\");\nMODULE_PARM_DESC(led, \"Set to 1 to enable LED support\");\nMODULE_PARM_DESC(diff, \"0 for no differential mode, 1 for BIOS, 2 for always, 3 for not GPIO3\");\nMODULE_PARM_DESC(irqm, \"0 for open drain, 1 to leave alone, 2 for totem pole\");\nMODULE_PARM_DESC(buschk, \"0 to not check, 1 for detach on error, 2 for warn on error\");\nMODULE_PARM_DESC(hostid, \"The SCSI ID to use for the host adapters\");\nMODULE_PARM_DESC(verb, \"0 for minimal verbosity, 1 for normal, 2 for excessive\");\nMODULE_PARM_DESC(debug, \"Set bits to enable debugging\");\nMODULE_PARM_DESC(settle, \"Settle delay in seconds.  Default 3\");\nMODULE_PARM_DESC(nvram, \"Option currently not used\");\nMODULE_PARM_DESC(excl, \"List ioport addresses here to prevent controllers from being attached\");\nMODULE_PARM_DESC(safe, \"Set other settings to a \\\"safe mode\\\"\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(SYM_VERSION);\nMODULE_AUTHOR(\"Matthew Wilcox <matthew@wil.cx>\");\nMODULE_DESCRIPTION(\"NCR, Symbios and LSI 8xx and 1010 PCI SCSI adapters\");\n\nstatic void sym2_setup_params(void)\n{\n\tchar *p = excl_string;\n\tint xi = 0;\n\n\twhile (p && (xi < 8)) {\n\t\tchar *next_p;\n\t\tint val = (int) simple_strtoul(p, &next_p, 0);\n\t\tsym_driver_setup.excludes[xi++] = val;\n\t\tp = next_p;\n\t}\n\n\tif (safe_string) {\n\t\tif (*safe_string == 'y') {\n\t\t\tsym_driver_setup.max_tag = 0;\n\t\t\tsym_driver_setup.burst_order = 0;\n\t\t\tsym_driver_setup.scsi_led = 0;\n\t\t\tsym_driver_setup.scsi_diff = 1;\n\t\t\tsym_driver_setup.irq_mode = 0;\n\t\t\tsym_driver_setup.scsi_bus_check = 2;\n\t\t\tsym_driver_setup.host_id = 7;\n\t\t\tsym_driver_setup.verbose = 2;\n\t\t\tsym_driver_setup.settle_delay = 10;\n\t\t\tsym_driver_setup.use_nvram = 1;\n\t\t} else if (*safe_string != 'n') {\n\t\t\tprintk(KERN_WARNING NAME53C8XX \"Ignoring parameter %s\"\n\t\t\t\t\t\" passed to safe option\", safe_string);\n\t\t}\n\t}\n}\n\nstatic struct scsi_transport_template *sym2_transport_template = NULL;\n\n \nstruct sym_ucmd {\t\t \n\tstruct completion *eh_done;\t\t \n};\n\n#define SYM_UCMD_PTR(cmd)  ((struct sym_ucmd *)scsi_cmd_priv(cmd))\n#define SYM_SOFTC_PTR(cmd) sym_get_hcb(cmd->device->host)\n\n \nvoid sym_xpt_done(struct sym_hcb *np, struct scsi_cmnd *cmd)\n{\n\tstruct sym_ucmd *ucmd = SYM_UCMD_PTR(cmd);\n\n\tif (ucmd->eh_done)\n\t\tcomplete(ucmd->eh_done);\n\n\tscsi_dma_unmap(cmd);\n\tscsi_done(cmd);\n}\n\n \nvoid sym_xpt_async_bus_reset(struct sym_hcb *np)\n{\n\tprintf_notice(\"%s: SCSI BUS has been reset.\\n\", sym_name(np));\n\tnp->s.settle_time = jiffies + sym_driver_setup.settle_delay * HZ;\n\tnp->s.settle_time_valid = 1;\n\tif (sym_verbose >= 2)\n\t\tprintf_info(\"%s: command processing suspended for %d seconds\\n\",\n\t\t\t    sym_name(np), sym_driver_setup.settle_delay);\n}\n\n \nstatic int sym_xerr_cam_status(int cam_status, int x_status)\n{\n\tif (x_status) {\n\t\tif (x_status & XE_PARITY_ERR)\n\t\t\tcam_status = DID_PARITY;\n\t\telse\n\t\t\tcam_status = DID_ERROR;\n\t}\n\treturn cam_status;\n}\n\n \nvoid sym_set_cam_result_error(struct sym_hcb *np, struct sym_ccb *cp, int resid)\n{\n\tstruct scsi_cmnd *cmd = cp->cmd;\n\tu_int cam_status, scsi_status;\n\n\tcam_status  = DID_OK;\n\tscsi_status = cp->ssss_status;\n\n\tif (cp->host_flags & HF_SENSE) {\n\t\tscsi_status = cp->sv_scsi_status;\n\t\tresid = cp->sv_resid;\n\t\tif (sym_verbose && cp->sv_xerr_status)\n\t\t\tsym_print_xerr(cmd, cp->sv_xerr_status);\n\t\tif (cp->host_status == HS_COMPLETE &&\n\t\t    cp->ssss_status == S_GOOD &&\n\t\t    cp->xerr_status == 0) {\n\t\t\tcam_status = sym_xerr_cam_status(DID_OK,\n\t\t\t\t\t\t\t cp->sv_xerr_status);\n\t\t\t \n\t\t\tmemset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\n\t\t\tmemcpy(cmd->sense_buffer, cp->sns_bbuf,\n\t\t\t       min(SCSI_SENSE_BUFFERSIZE, SYM_SNS_BBUF_LEN));\n#if 0\n\t\t\t \n\t\t\tif (1) {\n\t\t\t\tu_char *p;\n\t\t\t\tp  = (u_char *) cmd->sense_data;\n\t\t\t\tif (p[0]==0x70 && p[2]==0x6 && p[12]==0x29)\n\t\t\t\t\tsym_clear_tasks(np, DID_ABORT,\n\t\t\t\t\t\t\tcp->target,cp->lun, -1);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\t \n\t\t\tsym_reset_scsi_target(np, cmd->device->id);\n\t\t\tcam_status = DID_ERROR;\n\t\t}\n\t} else if (cp->host_status == HS_COMPLETE) \t \n\t\tcam_status = DID_OK;\n\telse if (cp->host_status == HS_SEL_TIMEOUT)\t \n\t\tcam_status = DID_NO_CONNECT;\n\telse if (cp->host_status == HS_UNEXPECTED)\t \n\t\tcam_status = DID_ERROR;\n\telse {\t\t\t\t\t\t \n\t\tif (sym_verbose) {\n\t\t\tsym_print_addr(cmd, \"COMMAND FAILED (%x %x %x).\\n\",\n\t\t\t\tcp->host_status, cp->ssss_status,\n\t\t\t\tcp->xerr_status);\n\t\t}\n\t\t \n\t\tcam_status = sym_xerr_cam_status(DID_ERROR, cp->xerr_status);\n\t}\n\tscsi_set_resid(cmd, resid);\n\tcmd->result = (cam_status << 16) | scsi_status;\n}\n\nstatic int sym_scatter(struct sym_hcb *np, struct sym_ccb *cp, struct scsi_cmnd *cmd)\n{\n\tint segment;\n\tint use_sg;\n\n\tcp->data_len = 0;\n\n\tuse_sg = scsi_dma_map(cmd);\n\tif (use_sg > 0) {\n\t\tstruct scatterlist *sg;\n\t\tstruct sym_tcb *tp = &np->target[cp->target];\n\t\tstruct sym_tblmove *data;\n\n\t\tif (use_sg > SYM_CONF_MAX_SG) {\n\t\t\tscsi_dma_unmap(cmd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdata = &cp->phys.data[SYM_CONF_MAX_SG - use_sg];\n\n\t\tscsi_for_each_sg(cmd, sg, use_sg, segment) {\n\t\t\tdma_addr_t baddr = sg_dma_address(sg);\n\t\t\tunsigned int len = sg_dma_len(sg);\n\n\t\t\tif ((len & 1) && (tp->head.wval & EWS)) {\n\t\t\t\tlen++;\n\t\t\t\tcp->odd_byte_adjustment++;\n\t\t\t}\n\n\t\t\tsym_build_sge(np, &data[segment], baddr, len);\n\t\t\tcp->data_len += len;\n\t\t}\n\t} else {\n\t\tsegment = -2;\n\t}\n\n\treturn segment;\n}\n\n \nstatic int sym_queue_command(struct sym_hcb *np, struct scsi_cmnd *cmd)\n{\n\tstruct scsi_device *sdev = cmd->device;\n\tstruct sym_tcb *tp;\n\tstruct sym_lcb *lp;\n\tstruct sym_ccb *cp;\n\tint\torder;\n\n\t \n\ttp = &np->target[sdev->id];\n\n\t \n\tlp = sym_lp(tp, sdev->lun);\n\torder = (lp && lp->s.reqtags) ? M_SIMPLE_TAG : 0;\n\n\t \n\tcp = sym_get_ccb(np, cmd, order);\n\tif (!cp)\n\t\treturn 1;\t \n\tsym_queue_scsiio(np, cmd, cp);\n\treturn 0;\n}\n\n \nstatic inline int sym_setup_cdb(struct sym_hcb *np, struct scsi_cmnd *cmd, struct sym_ccb *cp)\n{\n\tmemcpy(cp->cdb_buf, cmd->cmnd, cmd->cmd_len);\n\n\tcp->phys.cmd.addr = CCB_BA(cp, cdb_buf[0]);\n\tcp->phys.cmd.size = cpu_to_scr(cmd->cmd_len);\n\n\treturn 0;\n}\n\n \nint sym_setup_data_and_start(struct sym_hcb *np, struct scsi_cmnd *cmd, struct sym_ccb *cp)\n{\n\tu32 lastp, goalp;\n\tint dir;\n\n\t \n\tif (sym_setup_cdb(np, cmd, cp))\n\t\tgoto out_abort;\n\n\t \n\tdir = cmd->sc_data_direction;\n\tif (dir != DMA_NONE) {\n\t\tcp->segments = sym_scatter(np, cp, cmd);\n\t\tif (cp->segments < 0) {\n\t\t\tsym_set_cam_status(cmd, DID_ERROR);\n\t\t\tgoto out_abort;\n\t\t}\n\n\t\t \n\t\tif (!cp->segments)\n\t\t\tdir = DMA_NONE;\n\t} else {\n\t\tcp->data_len = 0;\n\t\tcp->segments = 0;\n\t}\n\n\t \n\tswitch (dir) {\n\tcase DMA_BIDIRECTIONAL:\n\t\tscmd_printk(KERN_INFO, cmd, \"got DMA_BIDIRECTIONAL command\");\n\t\tsym_set_cam_status(cmd, DID_ERROR);\n\t\tgoto out_abort;\n\tcase DMA_TO_DEVICE:\n\t\tgoalp = SCRIPTA_BA(np, data_out2) + 8;\n\t\tlastp = goalp - 8 - (cp->segments * (2*4));\n\t\tbreak;\n\tcase DMA_FROM_DEVICE:\n\t\tcp->host_flags |= HF_DATA_IN;\n\t\tgoalp = SCRIPTA_BA(np, data_in2) + 8;\n\t\tlastp = goalp - 8 - (cp->segments * (2*4));\n\t\tbreak;\n\tcase DMA_NONE:\n\tdefault:\n\t\tlastp = goalp = SCRIPTB_BA(np, no_data);\n\t\tbreak;\n\t}\n\n\t \n\tcp->phys.head.lastp = cpu_to_scr(lastp);\n\tcp->phys.head.savep = cpu_to_scr(lastp);\n\tcp->startp\t    = cp->phys.head.savep;\n\tcp->goalp\t    = cpu_to_scr(goalp);\n\n\t \n#if 0\n\tswitch (cp->cdb_buf[0]) {\n\tcase 0x0A: case 0x2A: case 0xAA:\n\t\tpanic(\"XXXXXXXXXXXXX WRITE NOT YET ALLOWED XXXXXXXXXXXXXX\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n\n\t \n\tsym_put_start_queue(np, cp);\n\treturn 0;\n\nout_abort:\n\tsym_free_ccb(np, cp);\n\tsym_xpt_done(np, cmd);\n\treturn 0;\n}\n\n\n \nstatic void sym_timer(struct sym_hcb *np)\n{\n\tunsigned long thistime = jiffies;\n\n\t \n\tnp->s.timer.expires = thistime + SYM_CONF_TIMER_INTERVAL;\n\tadd_timer(&np->s.timer);\n\n\t \n\tif (np->s.settle_time_valid) {\n\t\tif (time_before_eq(np->s.settle_time, thistime)) {\n\t\t\tif (sym_verbose >= 2 )\n\t\t\t\tprintk(\"%s: command processing resumed\\n\",\n\t\t\t\t       sym_name(np));\n\t\t\tnp->s.settle_time_valid = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (np->s.lasttime + 4*HZ < thistime) {\n\t\tnp->s.lasttime = thistime;\n\t}\n\n#ifdef SYM_CONF_PCIQ_MAY_MISS_COMPLETIONS\n\t \n\tsym_wakeup_done(np);\n#endif\n}\n\n\n \nvoid sym_log_bus_error(struct Scsi_Host *shost)\n{\n\tstruct sym_data *sym_data = shost_priv(shost);\n\tstruct pci_dev *pdev = sym_data->pdev;\n\tunsigned short pci_sts;\n\tpci_read_config_word(pdev, PCI_STATUS, &pci_sts);\n\tif (pci_sts & 0xf900) {\n\t\tpci_write_config_word(pdev, PCI_STATUS, pci_sts);\n\t\tshost_printk(KERN_WARNING, shost,\n\t\t\t\"PCI bus error: status = 0x%04x\\n\", pci_sts & 0xf900);\n\t}\n}\n\n \nstatic int sym53c8xx_queue_command_lck(struct scsi_cmnd *cmd)\n{\n\tstruct sym_hcb *np = SYM_SOFTC_PTR(cmd);\n\tstruct sym_ucmd *ucp = SYM_UCMD_PTR(cmd);\n\tint sts = 0;\n\n\tmemset(ucp, 0, sizeof(*ucp));\n\n\t \n\tif (np->s.settle_time_valid && scsi_cmd_to_rq(cmd)->timeout) {\n\t\tunsigned long tlimit = jiffies + scsi_cmd_to_rq(cmd)->timeout;\n\t\ttlimit -= SYM_CONF_TIMER_INTERVAL*2;\n\t\tif (time_after(np->s.settle_time, tlimit)) {\n\t\t\tnp->s.settle_time = tlimit;\n\t\t}\n\t}\n\n\tif (np->s.settle_time_valid)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tsts = sym_queue_command(np, cmd);\n\tif (sts)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(sym53c8xx_queue_command)\n\n \nstatic irqreturn_t sym53c8xx_intr(int irq, void *dev_id)\n{\n\tstruct Scsi_Host *shost = dev_id;\n\tstruct sym_data *sym_data = shost_priv(shost);\n\tirqreturn_t result;\n\n\t \n\tif (pci_channel_offline(sym_data->pdev))\n\t\treturn IRQ_NONE;\n\n\tif (DEBUG_FLAGS & DEBUG_TINY) printf_debug (\"[\");\n\n\tspin_lock(shost->host_lock);\n\tresult = sym_interrupt(shost);\n\tspin_unlock(shost->host_lock);\n\n\tif (DEBUG_FLAGS & DEBUG_TINY) printf_debug (\"]\\n\");\n\n\treturn result;\n}\n\n \nstatic void sym53c8xx_timer(struct timer_list *t)\n{\n\tstruct sym_hcb *np = from_timer(np, t, s.timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(np->s.host->host_lock, flags);\n\tsym_timer(np);\n\tspin_unlock_irqrestore(np->s.host->host_lock, flags);\n}\n\n\n \n#define SYM_EH_ABORT\t\t0\n#define SYM_EH_DEVICE_RESET\t1\n#define SYM_EH_BUS_RESET\t2\n#define SYM_EH_HOST_RESET\t3\n\n \nstatic int sym_eh_handler(int op, char *opname, struct scsi_cmnd *cmd)\n{\n\tstruct sym_ucmd *ucmd = SYM_UCMD_PTR(cmd);\n\tstruct Scsi_Host *shost = cmd->device->host;\n\tstruct sym_data *sym_data = shost_priv(shost);\n\tstruct pci_dev *pdev = sym_data->pdev;\n\tstruct sym_hcb *np = sym_data->ncb;\n\tSYM_QUEHEAD *qp;\n\tint cmd_queued = 0;\n\tint sts = -1;\n\tstruct completion eh_done;\n\n\tscmd_printk(KERN_WARNING, cmd, \"%s operation started\\n\", opname);\n\n\t \n#define WAIT_FOR_PCI_RECOVERY\t35\n\tif (pci_channel_offline(pdev)) {\n\t\tint finished_reset = 0;\n\t\tinit_completion(&eh_done);\n\t\tspin_lock_irq(shost->host_lock);\n\t\t \n\t\tif (pci_channel_offline(pdev)) {\n\t\t\tBUG_ON(sym_data->io_reset);\n\t\t\tsym_data->io_reset = &eh_done;\n\t\t} else {\n\t\t\tfinished_reset = 1;\n\t\t}\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tif (!finished_reset)\n\t\t\tfinished_reset = wait_for_completion_timeout\n\t\t\t\t\t\t(sym_data->io_reset,\n\t\t\t\t\t\tWAIT_FOR_PCI_RECOVERY*HZ);\n\t\tspin_lock_irq(shost->host_lock);\n\t\tsym_data->io_reset = NULL;\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tif (!finished_reset)\n\t\t\treturn SCSI_FAILED;\n\t}\n\n\tspin_lock_irq(shost->host_lock);\n\t \n\tFOR_EACH_QUEUED_ELEMENT(&np->busy_ccbq, qp) {\n\t\tstruct sym_ccb *cp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\n\t\tif (cp->cmd == cmd) {\n\t\t\tcmd_queued = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tsts = -1;\n\tswitch(op) {\n\tcase SYM_EH_ABORT:\n\t\tsts = sym_abort_scsiio(np, cmd, 1);\n\t\tbreak;\n\tcase SYM_EH_DEVICE_RESET:\n\t\tsts = sym_reset_scsi_target(np, cmd->device->id);\n\t\tbreak;\n\tcase SYM_EH_BUS_RESET:\n\t\tsym_reset_scsi_bus(np, 1);\n\t\tsts = 0;\n\t\tbreak;\n\tcase SYM_EH_HOST_RESET:\n\t\tsym_reset_scsi_bus(np, 0);\n\t\tsym_start_up(shost, 1);\n\t\tsts = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (sts)\n\t\tcmd_queued = 0;\n\n\tif (cmd_queued) {\n\t\tinit_completion(&eh_done);\n\t\tucmd->eh_done = &eh_done;\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tif (!wait_for_completion_timeout(&eh_done, 5*HZ)) {\n\t\t\tucmd->eh_done = NULL;\n\t\t\tsts = -2;\n\t\t}\n\t} else {\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n\n\tdev_warn(&cmd->device->sdev_gendev, \"%s operation %s.\\n\", opname,\n\t\t\tsts==0 ? \"complete\" :sts==-2 ? \"timed-out\" : \"failed\");\n\treturn sts ? SCSI_FAILED : SCSI_SUCCESS;\n}\n\n\n \nstatic int sym53c8xx_eh_abort_handler(struct scsi_cmnd *cmd)\n{\n\treturn sym_eh_handler(SYM_EH_ABORT, \"ABORT\", cmd);\n}\n\nstatic int sym53c8xx_eh_device_reset_handler(struct scsi_cmnd *cmd)\n{\n\treturn sym_eh_handler(SYM_EH_DEVICE_RESET, \"DEVICE RESET\", cmd);\n}\n\nstatic int sym53c8xx_eh_bus_reset_handler(struct scsi_cmnd *cmd)\n{\n\treturn sym_eh_handler(SYM_EH_BUS_RESET, \"BUS RESET\", cmd);\n}\n\nstatic int sym53c8xx_eh_host_reset_handler(struct scsi_cmnd *cmd)\n{\n\treturn sym_eh_handler(SYM_EH_HOST_RESET, \"HOST RESET\", cmd);\n}\n\n \nstatic void sym_tune_dev_queuing(struct sym_tcb *tp, int lun, u_short reqtags)\n{\n\tstruct sym_lcb *lp = sym_lp(tp, lun);\n\tu_short\toldtags;\n\n\tif (!lp)\n\t\treturn;\n\n\toldtags = lp->s.reqtags;\n\n\tif (reqtags > lp->s.scdev_depth)\n\t\treqtags = lp->s.scdev_depth;\n\n\tlp->s.reqtags     = reqtags;\n\n\tif (reqtags != oldtags) {\n\t\tdev_info(&tp->starget->dev,\n\t\t         \"tagged command queuing %s, command queue depth %d.\\n\",\n\t\t          lp->s.reqtags ? \"enabled\" : \"disabled\", reqtags);\n\t}\n}\n\nstatic int sym53c8xx_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct sym_hcb *np = sym_get_hcb(sdev->host);\n\tstruct sym_tcb *tp = &np->target[sdev->id];\n\tstruct sym_lcb *lp;\n\tunsigned long flags;\n\tint error;\n\n\tif (sdev->id >= SYM_CONF_MAX_TARGET || sdev->lun >= SYM_CONF_MAX_LUN)\n\t\treturn -ENXIO;\n\n\tspin_lock_irqsave(np->s.host->host_lock, flags);\n\n\t \n\n\tif (tp->usrflags & SYM_SCAN_BOOT_DISABLED) {\n\t\ttp->usrflags &= ~SYM_SCAN_BOOT_DISABLED;\n\t\tstarget_printk(KERN_INFO, sdev->sdev_target,\n\t\t\t\t\"Scan at boot disabled in NVRAM\\n\");\n\t\terror = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tif (tp->usrflags & SYM_SCAN_LUNS_DISABLED) {\n\t\tif (sdev->lun != 0) {\n\t\t\terror = -ENXIO;\n\t\t\tgoto out;\n\t\t}\n\t\tstarget_printk(KERN_INFO, sdev->sdev_target,\n\t\t\t\t\"Multiple LUNs disabled in NVRAM\\n\");\n\t}\n\n\tlp = sym_alloc_lcb(np, sdev->id, sdev->lun);\n\tif (!lp) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (tp->nlcb == 1)\n\t\ttp->starget = sdev->sdev_target;\n\n\tspi_min_period(tp->starget) = tp->usr_period;\n\tspi_max_width(tp->starget) = tp->usr_width;\n\n\terror = 0;\nout:\n\tspin_unlock_irqrestore(np->s.host->host_lock, flags);\n\n\treturn error;\n}\n\n \nstatic int sym53c8xx_slave_configure(struct scsi_device *sdev)\n{\n\tstruct sym_hcb *np = sym_get_hcb(sdev->host);\n\tstruct sym_tcb *tp = &np->target[sdev->id];\n\tstruct sym_lcb *lp = sym_lp(tp, sdev->lun);\n\tint reqtags, depth_to_use;\n\n\t \n\tlp->curr_flags = lp->user_flags;\n\n\t \n\treqtags = sym_driver_setup.max_tag;\n\tif (reqtags > tp->usrtags)\n\t\treqtags = tp->usrtags;\n\tif (!sdev->tagged_supported)\n\t\treqtags = 0;\n\tif (reqtags > SYM_CONF_MAX_TAG)\n\t\treqtags = SYM_CONF_MAX_TAG;\n\tdepth_to_use = reqtags ? reqtags : 1;\n\tscsi_change_queue_depth(sdev, depth_to_use);\n\tlp->s.scdev_depth = depth_to_use;\n\tsym_tune_dev_queuing(tp, sdev->lun, reqtags);\n\n\tif (!spi_initial_dv(sdev->sdev_target))\n\t\tspi_dv_device(sdev);\n\n\treturn 0;\n}\n\nstatic void sym53c8xx_slave_destroy(struct scsi_device *sdev)\n{\n\tstruct sym_hcb *np = sym_get_hcb(sdev->host);\n\tstruct sym_tcb *tp = &np->target[sdev->id];\n\tstruct sym_lcb *lp = sym_lp(tp, sdev->lun);\n\tunsigned long flags;\n\n\t \n\tif (!lp)\n\t\treturn;\n\n\tspin_lock_irqsave(np->s.host->host_lock, flags);\n\n\tif (lp->busy_itlq || lp->busy_itl) {\n\t\t \n\t\tstarget_printk(KERN_WARNING, tp->starget,\n\t\t\t       \"Removing busy LCB (%d)\\n\", (u8)sdev->lun);\n\t\tsym_reset_scsi_bus(np, 1);\n\t}\n\n\tif (sym_free_lcb(np, sdev->id, sdev->lun) == 0) {\n\t\t \n\t\ttp->head.sval        = 0;\n\t\ttp->head.wval        = np->rv_scntl3;\n\t\ttp->head.uval        = 0;\n\t\ttp->tgoal.check_nego = 1;\n\t\ttp->starget\t     = NULL;\n\t}\n\n\tspin_unlock_irqrestore(np->s.host->host_lock, flags);\n}\n\n \nstatic const char *sym53c8xx_info (struct Scsi_Host *host)\n{\n\treturn SYM_DRIVER_NAME;\n}\n\n\n#ifdef SYM_LINUX_PROC_INFO_SUPPORT\n \n\n#ifdef SYM_LINUX_USER_COMMAND_SUPPORT\n\nstruct\tsym_usrcmd {\n\tu_long\ttarget;\n\tu_long\tlun;\n\tu_long\tdata;\n\tu_long\tcmd;\n};\n\n#define UC_SETSYNC      10\n#define UC_SETTAGS\t11\n#define UC_SETDEBUG\t12\n#define UC_SETWIDE\t14\n#define UC_SETFLAG\t15\n#define UC_SETVERBOSE\t17\n#define UC_RESETDEV\t18\n#define UC_CLEARDEV\t19\n\nstatic void sym_exec_user_command (struct sym_hcb *np, struct sym_usrcmd *uc)\n{\n\tstruct sym_tcb *tp;\n\tint t, l;\n\n\tswitch (uc->cmd) {\n\tcase 0: return;\n\n#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT\n\tcase UC_SETDEBUG:\n\t\tsym_debug_flags = uc->data;\n\t\tbreak;\n#endif\n\tcase UC_SETVERBOSE:\n\t\tnp->verbose = uc->data;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tfor (t = 0; t < SYM_CONF_MAX_TARGET; t++) {\n\t\t\tif (!((uc->target >> t) & 1))\n\t\t\t\tcontinue;\n\t\t\ttp = &np->target[t];\n\t\t\tif (!tp->nlcb)\n\t\t\t\tcontinue;\n\n\t\t\tswitch (uc->cmd) {\n\n\t\t\tcase UC_SETSYNC:\n\t\t\t\tif (!uc->data || uc->data >= 255) {\n\t\t\t\t\ttp->tgoal.iu = tp->tgoal.dt =\n\t\t\t\t\t\ttp->tgoal.qas = 0;\n\t\t\t\t\ttp->tgoal.offset = 0;\n\t\t\t\t} else if (uc->data <= 9 && np->minsync_dt) {\n\t\t\t\t\tif (uc->data < np->minsync_dt)\n\t\t\t\t\t\tuc->data = np->minsync_dt;\n\t\t\t\t\ttp->tgoal.iu = tp->tgoal.dt =\n\t\t\t\t\t\ttp->tgoal.qas = 1;\n\t\t\t\t\ttp->tgoal.width = 1;\n\t\t\t\t\ttp->tgoal.period = uc->data;\n\t\t\t\t\ttp->tgoal.offset = np->maxoffs_dt;\n\t\t\t\t} else {\n\t\t\t\t\tif (uc->data < np->minsync)\n\t\t\t\t\t\tuc->data = np->minsync;\n\t\t\t\t\ttp->tgoal.iu = tp->tgoal.dt =\n\t\t\t\t\t\ttp->tgoal.qas = 0;\n\t\t\t\t\ttp->tgoal.period = uc->data;\n\t\t\t\t\ttp->tgoal.offset = np->maxoffs;\n\t\t\t\t}\n\t\t\t\ttp->tgoal.check_nego = 1;\n\t\t\t\tbreak;\n\t\t\tcase UC_SETWIDE:\n\t\t\t\ttp->tgoal.width = uc->data ? 1 : 0;\n\t\t\t\ttp->tgoal.check_nego = 1;\n\t\t\t\tbreak;\n\t\t\tcase UC_SETTAGS:\n\t\t\t\tfor (l = 0; l < SYM_CONF_MAX_LUN; l++)\n\t\t\t\t\tsym_tune_dev_queuing(tp, l, uc->data);\n\t\t\t\tbreak;\n\t\t\tcase UC_RESETDEV:\n\t\t\t\ttp->to_reset = 1;\n\t\t\t\tnp->istat_sem = SEM;\n\t\t\t\tOUTB(np, nc_istat, SIGP|SEM);\n\t\t\t\tbreak;\n\t\t\tcase UC_CLEARDEV:\n\t\t\t\tfor (l = 0; l < SYM_CONF_MAX_LUN; l++) {\n\t\t\t\t\tstruct sym_lcb *lp = sym_lp(tp, l);\n\t\t\t\t\tif (lp) lp->to_clear = 1;\n\t\t\t\t}\n\t\t\t\tnp->istat_sem = SEM;\n\t\t\t\tOUTB(np, nc_istat, SIGP|SEM);\n\t\t\t\tbreak;\n\t\t\tcase UC_SETFLAG:\n\t\t\t\ttp->usrflags = uc->data;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int sym_skip_spaces(char *ptr, int len)\n{\n\tint cnt, c;\n\n\tfor (cnt = len; cnt > 0 && (c = *ptr++) && isspace(c); cnt--);\n\n\treturn (len - cnt);\n}\n\nstatic int get_int_arg(char *ptr, int len, u_long *pv)\n{\n\tchar *end;\n\n\t*pv = simple_strtoul(ptr, &end, 10);\n\treturn (end - ptr);\n}\n\nstatic int is_keyword(char *ptr, int len, char *verb)\n{\n\tint verb_len = strlen(verb);\n\n\tif (len >= verb_len && !memcmp(verb, ptr, verb_len))\n\t\treturn verb_len;\n\telse\n\t\treturn 0;\n}\n\n#define SKIP_SPACES(ptr, len)\t\t\t\t\t\t\\\n\tif ((arg_len = sym_skip_spaces(ptr, len)) < 1)\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\tptr += arg_len; len -= arg_len;\n\n#define GET_INT_ARG(ptr, len, v)\t\t\t\t\t\\\n\tif (!(arg_len = get_int_arg(ptr, len, &(v))))\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\tptr += arg_len; len -= arg_len;\n\n\n \n\nstatic int sym_user_command(struct Scsi_Host *shost, char *buffer, int length)\n{\n\tstruct sym_hcb *np = sym_get_hcb(shost);\n\tchar *ptr\t= buffer;\n\tint len\t\t= length;\n\tstruct sym_usrcmd cmd, *uc = &cmd;\n\tint\t\targ_len;\n\tu_long \t\ttarget;\n\n\tmemset(uc, 0, sizeof(*uc));\n\n\tif (len > 0 && ptr[len-1] == '\\n')\n\t\t--len;\n\n\tif\t((arg_len = is_keyword(ptr, len, \"setsync\")) != 0)\n\t\tuc->cmd = UC_SETSYNC;\n\telse if\t((arg_len = is_keyword(ptr, len, \"settags\")) != 0)\n\t\tuc->cmd = UC_SETTAGS;\n\telse if\t((arg_len = is_keyword(ptr, len, \"setverbose\")) != 0)\n\t\tuc->cmd = UC_SETVERBOSE;\n\telse if\t((arg_len = is_keyword(ptr, len, \"setwide\")) != 0)\n\t\tuc->cmd = UC_SETWIDE;\n#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT\n\telse if\t((arg_len = is_keyword(ptr, len, \"setdebug\")) != 0)\n\t\tuc->cmd = UC_SETDEBUG;\n#endif\n\telse if\t((arg_len = is_keyword(ptr, len, \"setflag\")) != 0)\n\t\tuc->cmd = UC_SETFLAG;\n\telse if\t((arg_len = is_keyword(ptr, len, \"resetdev\")) != 0)\n\t\tuc->cmd = UC_RESETDEV;\n\telse if\t((arg_len = is_keyword(ptr, len, \"cleardev\")) != 0)\n\t\tuc->cmd = UC_CLEARDEV;\n\telse\n\t\targ_len = 0;\n\n#ifdef DEBUG_PROC_INFO\nprintk(\"sym_user_command: arg_len=%d, cmd=%ld\\n\", arg_len, uc->cmd);\n#endif\n\n\tif (!arg_len)\n\t\treturn -EINVAL;\n\tptr += arg_len; len -= arg_len;\n\n\tswitch(uc->cmd) {\n\tcase UC_SETSYNC:\n\tcase UC_SETTAGS:\n\tcase UC_SETWIDE:\n\tcase UC_SETFLAG:\n\tcase UC_RESETDEV:\n\tcase UC_CLEARDEV:\n\t\tSKIP_SPACES(ptr, len);\n\t\tif ((arg_len = is_keyword(ptr, len, \"all\")) != 0) {\n\t\t\tptr += arg_len; len -= arg_len;\n\t\t\tuc->target = ~0;\n\t\t} else {\n\t\t\tGET_INT_ARG(ptr, len, target);\n\t\t\tuc->target = (1<<target);\n#ifdef DEBUG_PROC_INFO\nprintk(\"sym_user_command: target=%ld\\n\", target);\n#endif\n\t\t}\n\t\tbreak;\n\t}\n\n\tswitch(uc->cmd) {\n\tcase UC_SETVERBOSE:\n\tcase UC_SETSYNC:\n\tcase UC_SETTAGS:\n\tcase UC_SETWIDE:\n\t\tSKIP_SPACES(ptr, len);\n\t\tGET_INT_ARG(ptr, len, uc->data);\n#ifdef DEBUG_PROC_INFO\nprintk(\"sym_user_command: data=%ld\\n\", uc->data);\n#endif\n\t\tbreak;\n#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT\n\tcase UC_SETDEBUG:\n\t\twhile (len > 0) {\n\t\t\tSKIP_SPACES(ptr, len);\n\t\t\tif\t((arg_len = is_keyword(ptr, len, \"alloc\")))\n\t\t\t\tuc->data |= DEBUG_ALLOC;\n\t\t\telse if\t((arg_len = is_keyword(ptr, len, \"phase\")))\n\t\t\t\tuc->data |= DEBUG_PHASE;\n\t\t\telse if\t((arg_len = is_keyword(ptr, len, \"queue\")))\n\t\t\t\tuc->data |= DEBUG_QUEUE;\n\t\t\telse if\t((arg_len = is_keyword(ptr, len, \"result\")))\n\t\t\t\tuc->data |= DEBUG_RESULT;\n\t\t\telse if\t((arg_len = is_keyword(ptr, len, \"scatter\")))\n\t\t\t\tuc->data |= DEBUG_SCATTER;\n\t\t\telse if\t((arg_len = is_keyword(ptr, len, \"script\")))\n\t\t\t\tuc->data |= DEBUG_SCRIPT;\n\t\t\telse if\t((arg_len = is_keyword(ptr, len, \"tiny\")))\n\t\t\t\tuc->data |= DEBUG_TINY;\n\t\t\telse if\t((arg_len = is_keyword(ptr, len, \"timing\")))\n\t\t\t\tuc->data |= DEBUG_TIMING;\n\t\t\telse if\t((arg_len = is_keyword(ptr, len, \"nego\")))\n\t\t\t\tuc->data |= DEBUG_NEGO;\n\t\t\telse if\t((arg_len = is_keyword(ptr, len, \"tags\")))\n\t\t\t\tuc->data |= DEBUG_TAGS;\n\t\t\telse if\t((arg_len = is_keyword(ptr, len, \"pointer\")))\n\t\t\t\tuc->data |= DEBUG_POINTER;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tptr += arg_len; len -= arg_len;\n\t\t}\n#ifdef DEBUG_PROC_INFO\nprintk(\"sym_user_command: data=%ld\\n\", uc->data);\n#endif\n\t\tbreak;\n#endif  \n\tcase UC_SETFLAG:\n\t\twhile (len > 0) {\n\t\t\tSKIP_SPACES(ptr, len);\n\t\t\tif\t((arg_len = is_keyword(ptr, len, \"no_disc\")))\n\t\t\t\tuc->data &= ~SYM_DISC_ENABLED;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tptr += arg_len; len -= arg_len;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (len)\n\t\treturn -EINVAL;\n\telse {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(shost->host_lock, flags);\n\t\tsym_exec_user_command(np, uc);\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t}\n\treturn length;\n}\n\n#endif\t \n\n\n \nstatic int sym_show_info(struct seq_file *m, struct Scsi_Host *shost)\n{\n#ifdef SYM_LINUX_USER_INFO_SUPPORT\n\tstruct sym_data *sym_data = shost_priv(shost);\n\tstruct pci_dev *pdev = sym_data->pdev;\n\tstruct sym_hcb *np = sym_data->ncb;\n\n\tseq_printf(m, \"Chip \" NAME53C \"%s, device id 0x%x, \"\n\t\t \"revision id 0x%x\\n\", np->s.chip_name,\n\t\t pdev->device, pdev->revision);\n\tseq_printf(m, \"At PCI address %s, IRQ %u\\n\",\n\t\t\t pci_name(pdev), pdev->irq);\n\tseq_printf(m, \"Min. period factor %d, %s SCSI BUS%s\\n\",\n\t\t (int) (np->minsync_dt ? np->minsync_dt : np->minsync),\n\t\t np->maxwide ? \"Wide\" : \"Narrow\",\n\t\t np->minsync_dt ? \", DT capable\" : \"\");\n\n\tseq_printf(m, \"Max. started commands %d, \"\n\t\t \"max. commands per LUN %d\\n\",\n\t\t SYM_CONF_MAX_START, SYM_CONF_MAX_TAG);\n\n\treturn 0;\n#else\n\treturn -EINVAL;\n#endif  \n}\n\n#endif  \n\n \nstatic void sym_iounmap_device(struct sym_device *device)\n{\n\tif (device->s.ioaddr)\n\t\tpci_iounmap(device->pdev, device->s.ioaddr);\n\tif (device->s.ramaddr)\n\t\tpci_iounmap(device->pdev, device->s.ramaddr);\n}\n\n \nstatic void sym_free_resources(struct sym_hcb *np, struct pci_dev *pdev,\n\t\tint do_free_irq)\n{\n\t \n\tif (do_free_irq)\n\t\tfree_irq(pdev->irq, np->s.host);\n\tif (np->s.ioaddr)\n\t\tpci_iounmap(pdev, np->s.ioaddr);\n\tif (np->s.ramaddr)\n\t\tpci_iounmap(pdev, np->s.ramaddr);\n\t \n\tsym_hcb_free(np);\n\n\tsym_mfree_dma(np, sizeof(*np), \"HCB\");\n}\n\n \nstatic struct Scsi_Host *sym_attach(const struct scsi_host_template *tpnt, int unit,\n\t\t\t\t    struct sym_device *dev)\n{\n\tstruct sym_data *sym_data;\n\tstruct sym_hcb *np = NULL;\n\tstruct Scsi_Host *shost = NULL;\n\tstruct pci_dev *pdev = dev->pdev;\n\tunsigned long flags;\n\tstruct sym_fw *fw;\n\tint do_free_irq = 0;\n\n\tprintk(KERN_INFO \"sym%d: <%s> rev 0x%x at pci %s irq %u\\n\",\n\t\tunit, dev->chip.name, pdev->revision, pci_name(pdev),\n\t\tpdev->irq);\n\n\t \n\tfw = sym_find_firmware(&dev->chip);\n\tif (!fw)\n\t\tgoto attach_failed;\n\n\tshost = scsi_host_alloc(tpnt, sizeof(*sym_data));\n\tif (!shost)\n\t\tgoto attach_failed;\n\tsym_data = shost_priv(shost);\n\n\t \n\tnp = __sym_calloc_dma(&pdev->dev, sizeof(*np), \"HCB\");\n\tif (!np)\n\t\tgoto attach_failed;\n\tnp->bus_dmat = &pdev->dev;  \n\tsym_data->ncb = np;\n\tsym_data->pdev = pdev;\n\tnp->s.host = shost;\n\n\tpci_set_drvdata(pdev, shost);\n\n\t \n\tnp->hcb_ba\t= vtobus(np);\n\tnp->verbose\t= sym_driver_setup.verbose;\n\tnp->s.unit\t= unit;\n\tnp->features\t= dev->chip.features;\n\tnp->clock_divn\t= dev->chip.nr_divisor;\n\tnp->maxoffs\t= dev->chip.offset_max;\n\tnp->maxburst\t= dev->chip.burst_max;\n\tnp->myaddr\t= dev->host_id;\n\tnp->mmio_ba\t= (u32)dev->mmio_base;\n\tnp->ram_ba\t= (u32)dev->ram_base;\n\tnp->s.ioaddr\t= dev->s.ioaddr;\n\tnp->s.ramaddr\t= dev->s.ramaddr;\n\n\t \n\tstrscpy(np->s.chip_name, dev->chip.name, sizeof(np->s.chip_name));\n\tsprintf(np->s.inst_name, \"sym%d\", np->s.unit);\n\n\tif ((SYM_CONF_DMA_ADDRESSING_MODE > 0) && (np->features & FE_DAC) &&\n\t\t\t!dma_set_mask(&pdev->dev, DMA_DAC_MASK)) {\n\t\tset_dac(np);\n\t} else if (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tprintf_warning(\"%s: No suitable DMA available\\n\", sym_name(np));\n\t\tgoto attach_failed;\n\t}\n\n\tif (sym_hcb_attach(shost, fw, dev->nvram))\n\t\tgoto attach_failed;\n\n\t \n\tif (request_irq(pdev->irq, sym53c8xx_intr, IRQF_SHARED, NAME53C8XX,\n\t\t\tshost)) {\n\t\tprintf_err(\"%s: request irq %u failure\\n\",\n\t\t\tsym_name(np), pdev->irq);\n\t\tgoto attach_failed;\n\t}\n\tdo_free_irq = 1;\n\n\t \n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (sym_reset_scsi_bus(np, 0))\n\t\tgoto reset_failed;\n\n\t \n\tsym_start_up(shost, 1);\n\n\t \n\ttimer_setup(&np->s.timer, sym53c8xx_timer, 0);\n\tnp->s.lasttime=0;\n\tsym_timer (np);\n\n\t \n\tshost->max_channel\t= 0;\n\tshost->this_id\t\t= np->myaddr;\n\tshost->max_id\t\t= np->maxwide ? 16 : 8;\n\tshost->max_lun\t\t= SYM_CONF_MAX_LUN;\n\tshost->unique_id\t= pci_resource_start(pdev, 0);\n\tshost->cmd_per_lun\t= SYM_CONF_MAX_TAG;\n\tshost->can_queue\t= (SYM_CONF_MAX_START-2);\n\tshost->sg_tablesize\t= SYM_CONF_MAX_SG;\n\tshost->max_cmd_len\t= 16;\n\tBUG_ON(sym2_transport_template == NULL);\n\tshost->transportt\t= sym2_transport_template;\n\n\t \n\tif (pdev->device == PCI_DEVICE_ID_NCR_53C896 && pdev->revision < 2)\n\t\tshost->dma_boundary = 0xFFFFFF;\n\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\treturn shost;\n\n reset_failed:\n\tprintf_err(\"%s: FATAL ERROR: CHECK SCSI BUS - CABLES, \"\n\t\t   \"TERMINATION, DEVICE POWER etc.!\\n\", sym_name(np));\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n attach_failed:\n\tprintf_info(\"sym%d: giving up ...\\n\", unit);\n\tif (np)\n\t\tsym_free_resources(np, pdev, do_free_irq);\n\telse\n\t\tsym_iounmap_device(dev);\n\tif (shost)\n\t\tscsi_host_put(shost);\n\n\treturn NULL;\n}\n\n\n \n#if SYM_CONF_NVRAM_SUPPORT\nstatic void sym_get_nvram(struct sym_device *devp, struct sym_nvram *nvp)\n{\n\tdevp->nvram = nvp;\n\tnvp->type = 0;\n\n\tsym_read_nvram(devp, nvp);\n}\n#else\nstatic inline void sym_get_nvram(struct sym_device *devp, struct sym_nvram *nvp)\n{\n}\n#endif\t \n\nstatic int sym_check_supported(struct sym_device *device)\n{\n\tstruct sym_chip *chip;\n\tstruct pci_dev *pdev = device->pdev;\n\tunsigned long io_port = pci_resource_start(pdev, 0);\n\tint i;\n\n\t \n\tif (io_port) {\n\t\tfor (i = 0 ; i < 8 ; i++) {\n\t\t\tif (sym_driver_setup.excludes[i] == io_port)\n\t\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tchip = sym_lookup_chip_table(pdev->device, pdev->revision);\n\tif (!chip) {\n\t\tdev_info(&pdev->dev, \"device not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\tmemcpy(&device->chip, chip, sizeof(device->chip));\n\n\treturn 0;\n}\n\n \nstatic int sym_check_raid(struct sym_device *device)\n{\n\tunsigned int ram_size, ram_val;\n\n\tif (!device->s.ramaddr)\n\t\treturn 0;\n\n\tif (device->chip.features & FE_RAM8K)\n\t\tram_size = 8192;\n\telse\n\t\tram_size = 4096;\n\n\tram_val = readl(device->s.ramaddr + ram_size - 16);\n\tif (ram_val != 0x52414944)\n\t\treturn 0;\n\n\tdev_info(&device->pdev->dev,\n\t\t\t\"not initializing, driven by RAID controller.\\n\");\n\treturn -ENODEV;\n}\n\nstatic int sym_set_workarounds(struct sym_device *device)\n{\n\tstruct sym_chip *chip = &device->chip;\n\tstruct pci_dev *pdev = device->pdev;\n\tu_short status_reg;\n\n\t \n\tif (pdev->device == PCI_DEVICE_ID_NCR_53C896 && pdev->revision < 0x4) {\n\t\tchip->features\t|= (FE_WRIE | FE_CLSE);\n\t}\n\n\t \n\tif (chip->features & FE_WRIE) {\n\t\tif (pci_set_mwi(pdev))\n\t\t\treturn -ENODEV;\n\t}\n\n\t \n\tpci_read_config_word(pdev, PCI_STATUS, &status_reg);\n\tif (chip->features & FE_66MHZ) {\n\t\tif (!(status_reg & PCI_STATUS_66MHZ))\n\t\t\tchip->features &= ~FE_66MHZ;\n\t} else {\n\t\tif (status_reg & PCI_STATUS_66MHZ) {\n\t\t\tstatus_reg = PCI_STATUS_66MHZ;\n\t\t\tpci_write_config_word(pdev, PCI_STATUS, status_reg);\n\t\t\tpci_read_config_word(pdev, PCI_STATUS, &status_reg);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sym_iomap_device(struct sym_device *device)\n{\n\tstruct pci_dev *pdev = device->pdev;\n\tstruct pci_bus_region bus_addr;\n\tint i = 2;\n\n\tpcibios_resource_to_bus(pdev->bus, &bus_addr, &pdev->resource[1]);\n\tdevice->mmio_base = bus_addr.start;\n\n\tif (device->chip.features & FE_RAM) {\n\t\t \n\t\tif (!pdev->resource[i].flags)\n\t\t\ti++;\n\t\tpcibios_resource_to_bus(pdev->bus, &bus_addr,\n\t\t\t\t\t&pdev->resource[i]);\n\t\tdevice->ram_base = bus_addr.start;\n\t}\n\n#ifdef CONFIG_SCSI_SYM53C8XX_MMIO\n\tif (device->mmio_base)\n\t\tdevice->s.ioaddr = pci_iomap(pdev, 1,\n\t\t\t\t\t\tpci_resource_len(pdev, 1));\n#endif\n\tif (!device->s.ioaddr)\n\t\tdevice->s.ioaddr = pci_iomap(pdev, 0,\n\t\t\t\t\t\tpci_resource_len(pdev, 0));\n\tif (!device->s.ioaddr) {\n\t\tdev_err(&pdev->dev, \"could not map registers; giving up.\\n\");\n\t\treturn -EIO;\n\t}\n\tif (device->ram_base) {\n\t\tdevice->s.ramaddr = pci_iomap(pdev, i,\n\t\t\t\t\t\tpci_resource_len(pdev, i));\n\t\tif (!device->s.ramaddr) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\"could not map SRAM; continuing anyway.\\n\");\n\t\t\tdevice->ram_base = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void sym_config_pqs(struct pci_dev *pdev, struct sym_device *sym_dev)\n{\n\tint slot;\n\tu8 tmp;\n\n\tfor (slot = 0; slot < 256; slot++) {\n\t\tstruct pci_dev *memc = pci_get_slot(pdev->bus, slot);\n\n\t\tif (!memc || memc->vendor != 0x101a || memc->device == 0x0009) {\n\t\t\tpci_dev_put(memc);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tpci_read_config_byte(memc, 0x44, &tmp);\n\t\tif ((tmp & 0x2) == 0) {\n\t\t\ttmp |= 0x2;\n\t\t\tpci_write_config_byte(memc, 0x44, tmp);\n\t\t}\n\n\t\t \n\t\tpci_read_config_byte(memc, 0x45, &tmp);\n\t\tif ((tmp & 0x4) == 0) {\n\t\t\ttmp |= 0x4;\n\t\t\tpci_write_config_byte(memc, 0x45, tmp);\n\t\t}\n\n\t\tpci_dev_put(memc);\n\t\tbreak;\n\t}\n\n\tpci_read_config_byte(pdev, 0x84, &tmp);\n\tsym_dev->host_id = tmp;\n}\n\n \nstatic int sym_detach(struct Scsi_Host *shost, struct pci_dev *pdev)\n{\n\tstruct sym_hcb *np = sym_get_hcb(shost);\n\tprintk(\"%s: detaching ...\\n\", sym_name(np));\n\n\tdel_timer_sync(&np->s.timer);\n\n\t \n\tprintk(\"%s: resetting chip\\n\", sym_name(np));\n\tOUTB(np, nc_istat, SRST);\n\tINB(np, nc_mbox1);\n\tudelay(10);\n\tOUTB(np, nc_istat, 0);\n\n\tsym_free_resources(np, pdev, 1);\n\tscsi_host_put(shost);\n\n\treturn 1;\n}\n\n \nstatic const struct scsi_host_template sym2_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"sym53c8xx\",\n\t.info\t\t\t= sym53c8xx_info, \n\t.cmd_size\t\t= sizeof(struct sym_ucmd),\n\t.queuecommand\t\t= sym53c8xx_queue_command,\n\t.slave_alloc\t\t= sym53c8xx_slave_alloc,\n\t.slave_configure\t= sym53c8xx_slave_configure,\n\t.slave_destroy\t\t= sym53c8xx_slave_destroy,\n\t.eh_abort_handler\t= sym53c8xx_eh_abort_handler,\n\t.eh_device_reset_handler = sym53c8xx_eh_device_reset_handler,\n\t.eh_bus_reset_handler\t= sym53c8xx_eh_bus_reset_handler,\n\t.eh_host_reset_handler\t= sym53c8xx_eh_host_reset_handler,\n\t.this_id\t\t= 7,\n\t.max_sectors\t\t= 0xFFFF,\n#ifdef SYM_LINUX_PROC_INFO_SUPPORT\n\t.show_info\t\t= sym_show_info,\n#ifdef\tSYM_LINUX_USER_COMMAND_SUPPORT\n\t.write_info\t\t= sym_user_command,\n#endif\n\t.proc_name\t\t= NAME53C8XX,\n#endif\n};\n\nstatic int attach_count;\n\nstatic int sym2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct sym_device sym_dev;\n\tstruct sym_nvram nvram;\n\tstruct Scsi_Host *shost;\n\tint do_iounmap = 0;\n\tint do_disable_device = 1;\n\n\tmemset(&sym_dev, 0, sizeof(sym_dev));\n\tmemset(&nvram, 0, sizeof(nvram));\n\tsym_dev.pdev = pdev;\n\tsym_dev.host_id = SYM_SETUP_HOST_ID;\n\n\tif (pci_enable_device(pdev))\n\t\tgoto leave;\n\n\tpci_set_master(pdev);\n\n\tif (pci_request_regions(pdev, NAME53C8XX))\n\t\tgoto disable;\n\n\tif (sym_check_supported(&sym_dev))\n\t\tgoto free;\n\n\tif (sym_iomap_device(&sym_dev))\n\t\tgoto free;\n\tdo_iounmap = 1;\n\n\tif (sym_check_raid(&sym_dev)) {\n\t\tdo_disable_device = 0;\t \n\t\tgoto free;\n\t}\n\n\tif (sym_set_workarounds(&sym_dev))\n\t\tgoto free;\n\n\tsym_config_pqs(pdev, &sym_dev);\n\n\tsym_get_nvram(&sym_dev, &nvram);\n\n\tdo_iounmap = 0;  \n\tshost = sym_attach(&sym2_template, attach_count, &sym_dev);\n\tif (!shost)\n\t\tgoto free;\n\n\tif (scsi_add_host(shost, &pdev->dev))\n\t\tgoto detach;\n\tscsi_scan_host(shost);\n\n\tattach_count++;\n\n\treturn 0;\n\n detach:\n\tsym_detach(pci_get_drvdata(pdev), pdev);\n free:\n\tif (do_iounmap)\n\t\tsym_iounmap_device(&sym_dev);\n\tpci_release_regions(pdev);\n disable:\n\tif (do_disable_device)\n\t\tpci_disable_device(pdev);\n leave:\n\treturn -ENODEV;\n}\n\nstatic void sym2_remove(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost = pci_get_drvdata(pdev);\n\n\tscsi_remove_host(shost);\n\tsym_detach(shost, pdev);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\n\tattach_count--;\n}\n\n \nstatic pci_ers_result_t sym2_io_error_detected(struct pci_dev *pdev,\n                                         pci_channel_state_t state)\n{\n\t \n\tif (state == pci_channel_io_perm_failure) {\n\t\tsym2_remove(pdev);\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\tdisable_irq(pdev->irq);\n\tpci_disable_device(pdev);\n\n\t \n\treturn PCI_ERS_RESULT_CAN_RECOVER;\n}\n\n \nstatic pci_ers_result_t sym2_io_slot_dump(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost = pci_get_drvdata(pdev);\n\n\tsym_dump_registers(shost);\n\n\t \n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n \nstatic void sym2_reset_workarounds(struct pci_dev *pdev)\n{\n\tu_short status_reg;\n\tstruct sym_chip *chip;\n\n\tchip = sym_lookup_chip_table(pdev->device, pdev->revision);\n\n\t \n\tpci_read_config_word(pdev, PCI_STATUS, &status_reg);\n\tif (!(chip->features & FE_66MHZ) && (status_reg & PCI_STATUS_66MHZ)) {\n\t\tstatus_reg = PCI_STATUS_66MHZ;\n\t\tpci_write_config_word(pdev, PCI_STATUS, status_reg);\n\t\tpci_read_config_word(pdev, PCI_STATUS, &status_reg);\n\t}\n}\n\n \nstatic pci_ers_result_t sym2_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost = pci_get_drvdata(pdev);\n\tstruct sym_hcb *np = sym_get_hcb(shost);\n\n\tprintk(KERN_INFO \"%s: recovering from a PCI slot reset\\n\",\n\t          sym_name(np));\n\n\tif (pci_enable_device(pdev)) {\n\t\tprintk(KERN_ERR \"%s: Unable to enable after PCI reset\\n\",\n\t\t        sym_name(np));\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\tpci_set_master(pdev);\n\tenable_irq(pdev->irq);\n\n\t \n\tif (np->features & FE_WRIE) {\n\t\tif (pci_set_mwi(pdev))\n\t\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\t \n\tsym2_reset_workarounds(pdev);\n\n\t \n\tif (PCI_FUNC(pdev->devfn) == 0) {\n\t\tif (sym_reset_scsi_bus(np, 0)) {\n\t\t\tprintk(KERN_ERR \"%s: Unable to reset scsi host\\n\",\n\t\t\t        sym_name(np));\n\t\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t\tsym_start_up(shost, 1);\n\t}\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\n \nstatic void sym2_io_resume(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost = pci_get_drvdata(pdev);\n\tstruct sym_data *sym_data = shost_priv(shost);\n\n\tspin_lock_irq(shost->host_lock);\n\tif (sym_data->io_reset)\n\t\tcomplete(sym_data->io_reset);\n\tspin_unlock_irq(shost->host_lock);\n}\n\nstatic void sym2_get_signalling(struct Scsi_Host *shost)\n{\n\tstruct sym_hcb *np = sym_get_hcb(shost);\n\tenum spi_signal_type type;\n\n\tswitch (np->scsi_mode) {\n\tcase SMODE_SE:\n\t\ttype = SPI_SIGNAL_SE;\n\t\tbreak;\n\tcase SMODE_LVD:\n\t\ttype = SPI_SIGNAL_LVD;\n\t\tbreak;\n\tcase SMODE_HVD:\n\t\ttype = SPI_SIGNAL_HVD;\n\t\tbreak;\n\tdefault:\n\t\ttype = SPI_SIGNAL_UNKNOWN;\n\t\tbreak;\n\t}\n\tspi_signalling(shost) = type;\n}\n\nstatic void sym2_set_offset(struct scsi_target *starget, int offset)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct sym_hcb *np = sym_get_hcb(shost);\n\tstruct sym_tcb *tp = &np->target[starget->id];\n\n\ttp->tgoal.offset = offset;\n\ttp->tgoal.check_nego = 1;\n}\n\nstatic void sym2_set_period(struct scsi_target *starget, int period)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct sym_hcb *np = sym_get_hcb(shost);\n\tstruct sym_tcb *tp = &np->target[starget->id];\n\n\t \n\tif (period <= np->minsync && spi_width(starget))\n\t\ttp->tgoal.dt = 1;\n\n\ttp->tgoal.period = period;\n\ttp->tgoal.check_nego = 1;\n}\n\nstatic void sym2_set_width(struct scsi_target *starget, int width)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct sym_hcb *np = sym_get_hcb(shost);\n\tstruct sym_tcb *tp = &np->target[starget->id];\n\n\t \n\tif (width == 0)\n\t\ttp->tgoal.iu = tp->tgoal.dt = tp->tgoal.qas = 0;\n\n\ttp->tgoal.width = width;\n\ttp->tgoal.check_nego = 1;\n}\n\nstatic void sym2_set_dt(struct scsi_target *starget, int dt)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct sym_hcb *np = sym_get_hcb(shost);\n\tstruct sym_tcb *tp = &np->target[starget->id];\n\n\t \n\tif (dt)\n\t\ttp->tgoal.dt = 1;\n\telse\n\t\ttp->tgoal.iu = tp->tgoal.dt = tp->tgoal.qas = 0;\n\ttp->tgoal.check_nego = 1;\n}\n\n#if 0\nstatic void sym2_set_iu(struct scsi_target *starget, int iu)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct sym_hcb *np = sym_get_hcb(shost);\n\tstruct sym_tcb *tp = &np->target[starget->id];\n\n\tif (iu)\n\t\ttp->tgoal.iu = tp->tgoal.dt = 1;\n\telse\n\t\ttp->tgoal.iu = 0;\n\ttp->tgoal.check_nego = 1;\n}\n\nstatic void sym2_set_qas(struct scsi_target *starget, int qas)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct sym_hcb *np = sym_get_hcb(shost);\n\tstruct sym_tcb *tp = &np->target[starget->id];\n\n\tif (qas)\n\t\ttp->tgoal.dt = tp->tgoal.qas = 1;\n\telse\n\t\ttp->tgoal.qas = 0;\n\ttp->tgoal.check_nego = 1;\n}\n#endif\n\nstatic struct spi_function_template sym2_transport_functions = {\n\t.set_offset\t= sym2_set_offset,\n\t.show_offset\t= 1,\n\t.set_period\t= sym2_set_period,\n\t.show_period\t= 1,\n\t.set_width\t= sym2_set_width,\n\t.show_width\t= 1,\n\t.set_dt\t\t= sym2_set_dt,\n\t.show_dt\t= 1,\n#if 0\n\t.set_iu\t\t= sym2_set_iu,\n\t.show_iu\t= 1,\n\t.set_qas\t= sym2_set_qas,\n\t.show_qas\t= 1,\n#endif\n\t.get_signalling\t= sym2_get_signalling,\n};\n\nstatic struct pci_device_id sym2_id_table[] = {\n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_NCR_53C810,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_NCR_53C820,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },  \n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_NCR_53C825,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_NCR_53C815,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_53C810AP,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },  \n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_NCR_53C860,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_53C1510,\n\t  PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_STORAGE_SCSI<<8,  0xffff00, 0UL },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_NCR_53C896,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_NCR_53C895,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_NCR_53C885,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_NCR_53C875,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_NCR_53C1510,\n\t  PCI_ANY_ID, PCI_ANY_ID,  PCI_CLASS_STORAGE_SCSI<<8,  0xffff00, 0UL },  \n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_53C895A,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_53C875A,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_53C1010_33,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_53C1010_66,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },\n\t{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_NCR_53C875J,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, sym2_id_table);\n\nstatic const struct pci_error_handlers sym2_err_handler = {\n\t.error_detected\t= sym2_io_error_detected,\n\t.mmio_enabled\t= sym2_io_slot_dump,\n\t.slot_reset\t= sym2_io_slot_reset,\n\t.resume\t\t= sym2_io_resume,\n};\n\nstatic struct pci_driver sym2_driver = {\n\t.name\t\t= NAME53C8XX,\n\t.id_table\t= sym2_id_table,\n\t.probe\t\t= sym2_probe,\n\t.remove\t\t= sym2_remove,\n\t.err_handler \t= &sym2_err_handler,\n};\n\nstatic int __init sym2_init(void)\n{\n\tint error;\n\n\tsym2_setup_params();\n\tsym2_transport_template = spi_attach_transport(&sym2_transport_functions);\n\tif (!sym2_transport_template)\n\t\treturn -ENODEV;\n\n\terror = pci_register_driver(&sym2_driver);\n\tif (error)\n\t\tspi_release_transport(sym2_transport_template);\n\treturn error;\n}\n\nstatic void __exit sym2_exit(void)\n{\n\tpci_unregister_driver(&sym2_driver);\n\tspi_release_transport(sym2_transport_template);\n}\n\nmodule_init(sym2_init);\nmodule_exit(sym2_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}