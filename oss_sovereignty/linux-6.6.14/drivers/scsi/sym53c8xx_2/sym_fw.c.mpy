{
  "module_name": "sym_fw.c",
  "hash_id": "971d50e47ffa07885e1206957205f0b4a247191e40c621e1769d09995276a0ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sym53c8xx_2/sym_fw.c",
  "human_readable_source": "\n \n\n#include \"sym_glue.h\"\n\n \n#define\tSYM_GEN_A(s, label)\t((short) offsetof(s, label)),\n#define\tSYM_GEN_B(s, label)\t((short) offsetof(s, label)),\n#define\tSYM_GEN_Z(s, label)\t((short) offsetof(s, label)),\n#define\tPADDR_A(label)\t\tSYM_GEN_PADDR_A(struct SYM_FWA_SCR, label)\n#define\tPADDR_B(label)\t\tSYM_GEN_PADDR_B(struct SYM_FWB_SCR, label)\n\n\n#if\tSYM_CONF_GENERIC_SUPPORT\n \n#define\tSYM_FWA_SCR\t\tsym_fw1a_scr\n#define\tSYM_FWB_SCR\t\tsym_fw1b_scr\n#define\tSYM_FWZ_SCR\t\tsym_fw1z_scr\n#include \"sym_fw1.h\"\nstatic struct sym_fwa_ofs sym_fw1a_ofs = {\n\tSYM_GEN_FW_A(struct SYM_FWA_SCR)\n};\nstatic struct sym_fwb_ofs sym_fw1b_ofs = {\n\tSYM_GEN_FW_B(struct SYM_FWB_SCR)\n};\nstatic struct sym_fwz_ofs sym_fw1z_ofs = {\n\tSYM_GEN_FW_Z(struct SYM_FWZ_SCR)\n};\n#undef\tSYM_FWA_SCR\n#undef\tSYM_FWB_SCR\n#undef\tSYM_FWZ_SCR\n#endif\t \n\n \n#define\tSYM_FWA_SCR\t\tsym_fw2a_scr\n#define\tSYM_FWB_SCR\t\tsym_fw2b_scr\n#define\tSYM_FWZ_SCR\t\tsym_fw2z_scr\n#include \"sym_fw2.h\"\nstatic struct sym_fwa_ofs sym_fw2a_ofs = {\n\tSYM_GEN_FW_A(struct SYM_FWA_SCR)\n};\nstatic struct sym_fwb_ofs sym_fw2b_ofs = {\n\tSYM_GEN_FW_B(struct SYM_FWB_SCR)\n\tSYM_GEN_B(struct SYM_FWB_SCR, start64)\n\tSYM_GEN_B(struct SYM_FWB_SCR, pm_handle)\n};\nstatic struct sym_fwz_ofs sym_fw2z_ofs = {\n\tSYM_GEN_FW_Z(struct SYM_FWZ_SCR)\n};\n#undef\tSYM_FWA_SCR\n#undef\tSYM_FWB_SCR\n#undef\tSYM_FWZ_SCR\n\n#undef\tSYM_GEN_A\n#undef\tSYM_GEN_B\n#undef\tSYM_GEN_Z\n#undef\tPADDR_A\n#undef\tPADDR_B\n\n#if\tSYM_CONF_GENERIC_SUPPORT\n \nstatic void\nsym_fw1_patch(struct Scsi_Host *shost)\n{\n\tstruct sym_hcb *np = sym_get_hcb(shost);\n\tstruct sym_fw1a_scr *scripta0;\n\tstruct sym_fw1b_scr *scriptb0;\n\n\tscripta0 = (struct sym_fw1a_scr *) np->scripta0;\n\tscriptb0 = (struct sym_fw1b_scr *) np->scriptb0;\n\n\t \n\tif (!(np->features & FE_LED0)) {\n\t\tscripta0->idle[0]\t= cpu_to_scr(SCR_NO_OP);\n\t\tscripta0->reselected[0]\t= cpu_to_scr(SCR_NO_OP);\n\t\tscripta0->start[0]\t= cpu_to_scr(SCR_NO_OP);\n\t}\n\n#ifdef SYM_CONF_IARB_SUPPORT\n\t \n\tif (!SYM_CONF_SET_IARB_ON_ARB_LOST)\n\t\tscripta0->ungetjob[0] = cpu_to_scr(SCR_NO_OP);\n#endif\n\t \n\tscriptb0->startpos[0]\t= cpu_to_scr(np->squeue_ba);\n\tscriptb0->done_pos[0]\t= cpu_to_scr(np->dqueue_ba);\n\tscriptb0->targtbl[0]\t= cpu_to_scr(np->targtbl_ba);\n}\n#endif\t \n\n \nstatic void\nsym_fw2_patch(struct Scsi_Host *shost)\n{\n\tstruct sym_data *sym_data = shost_priv(shost);\n\tstruct pci_dev *pdev = sym_data->pdev;\n\tstruct sym_hcb *np = sym_data->ncb;\n\tstruct sym_fw2a_scr *scripta0;\n\tstruct sym_fw2b_scr *scriptb0;\n\n\tscripta0 = (struct sym_fw2a_scr *) np->scripta0;\n\tscriptb0 = (struct sym_fw2b_scr *) np->scriptb0;\n\n\t \n\tif (!(np->features & FE_LED0)) {\n\t\tscripta0->idle[0]\t= cpu_to_scr(SCR_NO_OP);\n\t\tscripta0->reselected[0]\t= cpu_to_scr(SCR_NO_OP);\n\t\tscripta0->start[0]\t= cpu_to_scr(SCR_NO_OP);\n\t}\n\n#if   SYM_CONF_DMA_ADDRESSING_MODE == 2\n\t \n\tif (!use_dac(np)) {\n\t\tscripta0->is_dmap_dirty[0] = cpu_to_scr(SCR_NO_OP);\n\t\tscripta0->is_dmap_dirty[1] = 0;\n\t\tscripta0->is_dmap_dirty[2] = cpu_to_scr(SCR_NO_OP);\n\t\tscripta0->is_dmap_dirty[3] = 0;\n\t}\n#endif\n\n#ifdef SYM_CONF_IARB_SUPPORT\n\t \n\tif (!SYM_CONF_SET_IARB_ON_ARB_LOST)\n\t\tscripta0->ungetjob[0] = cpu_to_scr(SCR_NO_OP);\n#endif\n\t \n\tscriptb0->startpos[0]\t= cpu_to_scr(np->squeue_ba);\n\tscriptb0->done_pos[0]\t= cpu_to_scr(np->dqueue_ba);\n\tscriptb0->targtbl[0]\t= cpu_to_scr(np->targtbl_ba);\n\n\t \n\tif (!(np->features & FE_C10)) {\n\t\tscripta0->resel_scntl4[0] = cpu_to_scr(SCR_NO_OP);\n\t\tscripta0->resel_scntl4[1] = cpu_to_scr(0);\n\t}\n\n\t \n\tif (!(pdev->device == PCI_DEVICE_ID_LSI_53C1010_66 &&\n\t      pdev->revision < 0x1 &&\n\t      np->pciclk_khz < 60000)) {\n\t\tscripta0->datao_phase[0] = cpu_to_scr(SCR_NO_OP);\n\t\tscripta0->datao_phase[1] = cpu_to_scr(0);\n\t}\n\tif (!(pdev->device == PCI_DEVICE_ID_LSI_53C1010_33  )) {\n\t\tscripta0->sel_done[0] = cpu_to_scr(SCR_NO_OP);\n\t\tscripta0->sel_done[1] = cpu_to_scr(0);\n\t}\n\n\t \n\tscriptb0->pm0_data_addr[0] =\n\t\tcpu_to_scr(np->scripta_ba + \n\t\t\t   offsetof(struct sym_fw2a_scr, pm0_data));\n\tscriptb0->pm1_data_addr[0] =\n\t\tcpu_to_scr(np->scripta_ba + \n\t\t\t   offsetof(struct sym_fw2a_scr, pm1_data));\n}\n\n \nstatic void\nsym_fw_fill_data (u32 *in, u32 *out)\n{\n\tint\ti;\n\n\tfor (i = 0; i < SYM_CONF_MAX_SG; i++) {\n\t\t*in++  = SCR_CHMOV_TBL ^ SCR_DATA_IN;\n\t\t*in++  = offsetof (struct sym_dsb, data[i]);\n\t\t*out++ = SCR_CHMOV_TBL ^ SCR_DATA_OUT;\n\t\t*out++ = offsetof (struct sym_dsb, data[i]);\n\t}\n}\n\n \nstatic void \nsym_fw_setup_bus_addresses(struct sym_hcb *np, struct sym_fw *fw)\n{\n\tu32 *pa;\n\tu_short *po;\n\tint i;\n\n\t \n\tpo = (u_short *) fw->a_ofs;\n\tpa = (u32 *) &np->fwa_bas;\n\tfor (i = 0 ; i < sizeof(np->fwa_bas)/sizeof(u32) ; i++)\n\t\tpa[i] = np->scripta_ba + po[i];\n\n\t \n\tpo = (u_short *) fw->b_ofs;\n\tpa = (u32 *) &np->fwb_bas;\n\tfor (i = 0 ; i < sizeof(np->fwb_bas)/sizeof(u32) ; i++)\n\t\tpa[i] = np->scriptb_ba + po[i];\n\n\t \n\tpo = (u_short *) fw->z_ofs;\n\tpa = (u32 *) &np->fwz_bas;\n\tfor (i = 0 ; i < sizeof(np->fwz_bas)/sizeof(u32) ; i++)\n\t\tpa[i] = np->scriptz_ba + po[i];\n}\n\n#if\tSYM_CONF_GENERIC_SUPPORT\n \nstatic void \nsym_fw1_setup(struct sym_hcb *np, struct sym_fw *fw)\n{\n\tstruct sym_fw1a_scr *scripta0;\n\n\tscripta0 = (struct sym_fw1a_scr *) np->scripta0;\n\n\t \n\tsym_fw_fill_data(scripta0->data_in, scripta0->data_out);\n\n\t \n\tsym_fw_setup_bus_addresses(np, fw);\n}\n#endif\t \n\n \nstatic void \nsym_fw2_setup(struct sym_hcb *np, struct sym_fw *fw)\n{\n\tstruct sym_fw2a_scr *scripta0;\n\n\tscripta0 = (struct sym_fw2a_scr *) np->scripta0;\n\n\t \n\tsym_fw_fill_data(scripta0->data_in, scripta0->data_out);\n\n\t \n\tsym_fw_setup_bus_addresses(np, fw);\n}\n\n \n#if\tSYM_CONF_GENERIC_SUPPORT\nstatic struct sym_fw sym_fw1 = SYM_FW_ENTRY(sym_fw1, \"NCR-generic\");\n#endif\t \nstatic struct sym_fw sym_fw2 = SYM_FW_ENTRY(sym_fw2, \"LOAD/STORE-based\");\n\n \nstruct sym_fw * \nsym_find_firmware(struct sym_chip *chip)\n{\n\tif (chip->features & FE_LDSTR)\n\t\treturn &sym_fw2;\n#if\tSYM_CONF_GENERIC_SUPPORT\n\telse if (!(chip->features & (FE_PFEN|FE_NOPM|FE_DAC)))\n\t\treturn &sym_fw1;\n#endif\n\telse\n\t\treturn NULL;\n}\n\n \nvoid sym_fw_bind_script(struct sym_hcb *np, u32 *start, int len)\n{\n\tu32 opcode, new, old, tmp1, tmp2;\n\tu32 *end, *cur;\n\tint relocs;\n\n\tcur = start;\n\tend = start + len/4;\n\n\twhile (cur < end) {\n\n\t\topcode = *cur;\n\n\t\t \n\t\tif (opcode == 0) {\n\t\t\tprintf (\"%s: ERROR0 IN SCRIPT at %d.\\n\",\n\t\t\t\tsym_name(np), (int) (cur-start));\n\t\t\t++cur;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (opcode == SCR_DATA_ZERO) {\n\t\t\t*cur++ = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (DEBUG_FLAGS & DEBUG_SCRIPT)\n\t\t\tprintf (\"%d:  <%x>\\n\", (int) (cur-start),\n\t\t\t\t(unsigned)opcode);\n\n\t\t \n\t\tswitch (opcode >> 28) {\n\t\tcase 0xf:\n\t\t\t \n\t\t\trelocs = 0;\n\t\t\tbreak;\n\t\tcase 0xe:\n\t\t\t \n\t\t\trelocs = 1;\n\t\t\tbreak;\n\t\tcase 0xc:\n\t\t\t \n\t\t\trelocs = 2;\n\t\t\ttmp1 = cur[1];\n\t\t\ttmp2 = cur[2];\n\t\t\tif ((tmp1 ^ tmp2) & 3) {\n\t\t\t\tprintf (\"%s: ERROR1 IN SCRIPT at %d.\\n\",\n\t\t\t\t\tsym_name(np), (int) (cur-start));\n\t\t\t}\n\t\t\t \n\t\t\tif ((opcode & SCR_NO_FLUSH) &&\n\t\t\t    !(np->features & FE_PFEN)) {\n\t\t\t\topcode = (opcode & ~SCR_NO_FLUSH);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x0:\n\t\t\t \n\t\t\tif (!(np->features & FE_WIDE))\n\t\t\t\topcode = (opcode | OPC_MOVE);\n\t\t\trelocs = 1;\n\t\t\tbreak;\n\t\tcase 0x1:\n\t\t\t \n\t\t\tif (!(np->features & FE_WIDE))\n\t\t\t\topcode = (opcode | OPC_MOVE);\n\t\t\trelocs = 0;\n\t\t\tbreak;\n#ifdef SYM_CONF_TARGET_ROLE_SUPPORT\n\t\tcase 0x2:\n\t\t\t \n\t\t\topcode &= ~0x20000000;\n\t\t\tif (!(np->features & FE_WIDE))\n\t\t\t\topcode = (opcode & ~OPC_TCHMOVE);\n\t\t\trelocs = 1;\n\t\t\tbreak;\n\t\tcase 0x3:\n\t\t\t \n\t\t\topcode &= ~0x20000000;\n\t\t\tif (!(np->features & FE_WIDE))\n\t\t\t\topcode = (opcode & ~OPC_TCHMOVE);\n\t\t\trelocs = 0;\n\t\t\tbreak;\n#endif\n\t\tcase 0x8:\n\t\t\t \n\t\t\tif (opcode & 0x00800000)\n\t\t\t\trelocs = 0;\n\t\t\telse if ((opcode & 0xf8400000) == 0x80400000) \n\t\t\t\trelocs = 2;\n\t\t\telse\n\t\t\t\trelocs = 1;\n\t\t\tbreak;\n\t\tcase 0x4:\n\t\tcase 0x5:\n\t\tcase 0x6:\n\t\tcase 0x7:\n\t\t\trelocs = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trelocs = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\t*cur++ = cpu_to_scr(opcode);\n\n\t\t \n\t\tif (!relocs) {\n\t\t\t*cur = cpu_to_scr(*cur);\n\t\t\t++cur;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\twhile (relocs--) {\n\t\t\told = *cur;\n\n\t\t\tswitch (old & RELOC_MASK) {\n\t\t\tcase RELOC_REGISTER:\n\t\t\t\tnew = (old & ~RELOC_MASK) + np->mmio_ba;\n\t\t\t\tbreak;\n\t\t\tcase RELOC_LABEL_A:\n\t\t\t\tnew = (old & ~RELOC_MASK) + np->scripta_ba;\n\t\t\t\tbreak;\n\t\t\tcase RELOC_LABEL_B:\n\t\t\t\tnew = (old & ~RELOC_MASK) + np->scriptb_ba;\n\t\t\t\tbreak;\n\t\t\tcase RELOC_SOFTC:\n\t\t\t\tnew = (old & ~RELOC_MASK) + np->hcb_ba;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\t \n\t\t\t\tif (old == 0) {\n\t\t\t\t\tnew = old;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tnew = 0;\n\t\t\t\tpanic(\"sym_fw_bind_script: \"\n\t\t\t\t      \"weird relocation %x\\n\", old);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t*cur++ = cpu_to_scr(new);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}