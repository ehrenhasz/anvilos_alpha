{
  "module_name": "sym_malloc.c",
  "hash_id": "18d8e61a463c8a8a520a136153e781e49da704269a0d6ed565ad8cb6585ebbe8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sym53c8xx_2/sym_malloc.c",
  "human_readable_source": "\n \n\n#include \"sym_glue.h\"\n\n \nstatic void *___sym_malloc(m_pool_p mp, int size)\n{\n\tint i = 0;\n\tint s = (1 << SYM_MEM_SHIFT);\n\tint j;\n\tvoid *a;\n\tm_link_p h = mp->h;\n\n\tif (size > SYM_MEM_CLUSTER_SIZE)\n\t\treturn NULL;\n\n\twhile (size > s) {\n\t\ts <<= 1;\n\t\t++i;\n\t}\n\n\tj = i;\n\twhile (!h[j].next) {\n\t\tif (s == SYM_MEM_CLUSTER_SIZE) {\n\t\t\th[j].next = (m_link_p) M_GET_MEM_CLUSTER();\n\t\t\tif (h[j].next)\n\t\t\t\th[j].next->next = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t++j;\n\t\ts <<= 1;\n\t}\n\ta = h[j].next;\n\tif (a) {\n\t\th[j].next = h[j].next->next;\n\t\twhile (j > i) {\n\t\t\tj -= 1;\n\t\t\ts >>= 1;\n\t\t\th[j].next = (m_link_p) (a+s);\n\t\t\th[j].next->next = NULL;\n\t\t}\n\t}\n#ifdef DEBUG\n\tprintf(\"___sym_malloc(%d) = %p\\n\", size, (void *) a);\n#endif\n\treturn a;\n}\n\n \nstatic void ___sym_mfree(m_pool_p mp, void *ptr, int size)\n{\n\tint i = 0;\n\tint s = (1 << SYM_MEM_SHIFT);\n\tm_link_p q;\n\tunsigned long a, b;\n\tm_link_p h = mp->h;\n\n#ifdef DEBUG\n\tprintf(\"___sym_mfree(%p, %d)\\n\", ptr, size);\n#endif\n\n\tif (size > SYM_MEM_CLUSTER_SIZE)\n\t\treturn;\n\n\twhile (size > s) {\n\t\ts <<= 1;\n\t\t++i;\n\t}\n\n\ta = (unsigned long)ptr;\n\n\twhile (1) {\n\t\tif (s == SYM_MEM_CLUSTER_SIZE) {\n#ifdef SYM_MEM_FREE_UNUSED\n\t\t\tM_FREE_MEM_CLUSTER((void *)a);\n#else\n\t\t\t((m_link_p) a)->next = h[i].next;\n\t\t\th[i].next = (m_link_p) a;\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tb = a ^ s;\n\t\tq = &h[i];\n\t\twhile (q->next && q->next != (m_link_p) b) {\n\t\t\tq = q->next;\n\t\t}\n\t\tif (!q->next) {\n\t\t\t((m_link_p) a)->next = h[i].next;\n\t\t\th[i].next = (m_link_p) a;\n\t\t\tbreak;\n\t\t}\n\t\tq->next = q->next->next;\n\t\ta = a & b;\n\t\ts <<= 1;\n\t\t++i;\n\t}\n}\n\n \nstatic void *__sym_calloc2(m_pool_p mp, int size, char *name, int uflags)\n{\n\tvoid *p;\n\n\tp = ___sym_malloc(mp, size);\n\n\tif (DEBUG_FLAGS & DEBUG_ALLOC) {\n\t\tprintf (\"new %-10s[%4d] @%p.\\n\", name, size, p);\n\t}\n\n\tif (p)\n\t\tmemset(p, 0, size);\n\telse if (uflags & SYM_MEM_WARN)\n\t\tprintf (\"__sym_calloc2: failed to allocate %s[%d]\\n\", name, size);\n\treturn p;\n}\n#define __sym_calloc(mp, s, n)\t__sym_calloc2(mp, s, n, SYM_MEM_WARN)\n\n \nstatic void __sym_mfree(m_pool_p mp, void *ptr, int size, char *name)\n{\n\tif (DEBUG_FLAGS & DEBUG_ALLOC)\n\t\tprintf (\"freeing %-10s[%4d] @%p.\\n\", name, size, ptr);\n\n\t___sym_mfree(mp, ptr, size);\n}\n\n \nstatic void *___mp0_get_mem_cluster(m_pool_p mp)\n{\n\tvoid *m = sym_get_mem_cluster();\n\tif (m)\n\t\t++mp->nump;\n\treturn m;\n}\n\n#ifdef\tSYM_MEM_FREE_UNUSED\nstatic void ___mp0_free_mem_cluster(m_pool_p mp, void *m)\n{\n\tsym_free_mem_cluster(m);\n\t--mp->nump;\n}\n#else\n#define ___mp0_free_mem_cluster NULL\n#endif\n\nstatic struct sym_m_pool mp0 = {\n\tNULL,\n\t___mp0_get_mem_cluster,\n\t___mp0_free_mem_cluster\n};\n\n \n \nstatic void * ___get_dma_mem_cluster(m_pool_p mp)\n{\n\tm_vtob_p vbp;\n\tvoid *vaddr;\n\n\tvbp = __sym_calloc(&mp0, sizeof(*vbp), \"VTOB\");\n\tif (!vbp)\n\t\tgoto out_err;\n\n\tvaddr = sym_m_get_dma_mem_cluster(mp, vbp);\n\tif (vaddr) {\n\t\tint hc = VTOB_HASH_CODE(vaddr);\n\t\tvbp->next = mp->vtob[hc];\n\t\tmp->vtob[hc] = vbp;\n\t\t++mp->nump;\n\t}\n\treturn vaddr;\nout_err:\n\treturn NULL;\n}\n\n#ifdef\tSYM_MEM_FREE_UNUSED\n \nstatic void ___free_dma_mem_cluster(m_pool_p mp, void *m)\n{\n\tm_vtob_p *vbpp, vbp;\n\tint hc = VTOB_HASH_CODE(m);\n\n\tvbpp = &mp->vtob[hc];\n\twhile (*vbpp && (*vbpp)->vaddr != m)\n\t\tvbpp = &(*vbpp)->next;\n\tif (*vbpp) {\n\t\tvbp = *vbpp;\n\t\t*vbpp = (*vbpp)->next;\n\t\tsym_m_free_dma_mem_cluster(mp, vbp);\n\t\t__sym_mfree(&mp0, vbp, sizeof(*vbp), \"VTOB\");\n\t\t--mp->nump;\n\t}\n}\n#endif\n\n \nstatic inline m_pool_p ___get_dma_pool(m_pool_ident_t dev_dmat)\n{\n\tm_pool_p mp;\n\tfor (mp = mp0.next;\n\t\tmp && !sym_m_pool_match(mp->dev_dmat, dev_dmat);\n\t\t\tmp = mp->next);\n\treturn mp;\n}\n\n \nstatic m_pool_p ___cre_dma_pool(m_pool_ident_t dev_dmat)\n{\n\tm_pool_p mp = __sym_calloc(&mp0, sizeof(*mp), \"MPOOL\");\n\tif (mp) {\n\t\tmp->dev_dmat = dev_dmat;\n\t\tmp->get_mem_cluster = ___get_dma_mem_cluster;\n#ifdef\tSYM_MEM_FREE_UNUSED\n\t\tmp->free_mem_cluster = ___free_dma_mem_cluster;\n#endif\n\t\tmp->next = mp0.next;\n\t\tmp0.next = mp;\n\t\treturn mp;\n\t}\n\treturn NULL;\n}\n\n#ifdef\tSYM_MEM_FREE_UNUSED\n \nstatic void ___del_dma_pool(m_pool_p p)\n{\n\tm_pool_p *pp = &mp0.next;\n\n\twhile (*pp && *pp != p)\n\t\tpp = &(*pp)->next;\n\tif (*pp) {\n\t\t*pp = (*pp)->next;\n\t\t__sym_mfree(&mp0, p, sizeof(*p), \"MPOOL\");\n\t}\n}\n#endif\n\n \nstatic DEFINE_SPINLOCK(sym53c8xx_lock);\n\n \nvoid *__sym_calloc_dma(m_pool_ident_t dev_dmat, int size, char *name)\n{\n\tunsigned long flags;\n\tm_pool_p mp;\n\tvoid *m = NULL;\n\n\tspin_lock_irqsave(&sym53c8xx_lock, flags);\n\tmp = ___get_dma_pool(dev_dmat);\n\tif (!mp)\n\t\tmp = ___cre_dma_pool(dev_dmat);\n\tif (!mp)\n\t\tgoto out;\n\tm = __sym_calloc(mp, size, name);\n#ifdef\tSYM_MEM_FREE_UNUSED\n\tif (!mp->nump)\n\t\t___del_dma_pool(mp);\n#endif\n\n out:\n\tspin_unlock_irqrestore(&sym53c8xx_lock, flags);\n\treturn m;\n}\n\nvoid __sym_mfree_dma(m_pool_ident_t dev_dmat, void *m, int size, char *name)\n{\n\tunsigned long flags;\n\tm_pool_p mp;\n\n\tspin_lock_irqsave(&sym53c8xx_lock, flags);\n\tmp = ___get_dma_pool(dev_dmat);\n\tif (!mp)\n\t\tgoto out;\n\t__sym_mfree(mp, m, size, name);\n#ifdef\tSYM_MEM_FREE_UNUSED\n\tif (!mp->nump)\n\t\t___del_dma_pool(mp);\n#endif\n out:\n\tspin_unlock_irqrestore(&sym53c8xx_lock, flags);\n}\n\n \ndma_addr_t __vtobus(m_pool_ident_t dev_dmat, void *m)\n{\n\tunsigned long flags;\n\tm_pool_p mp;\n\tint hc = VTOB_HASH_CODE(m);\n\tm_vtob_p vp = NULL;\n\tvoid *a = (void *)((unsigned long)m & ~SYM_MEM_CLUSTER_MASK);\n\tdma_addr_t b;\n\n\tspin_lock_irqsave(&sym53c8xx_lock, flags);\n\tmp = ___get_dma_pool(dev_dmat);\n\tif (mp) {\n\t\tvp = mp->vtob[hc];\n\t\twhile (vp && vp->vaddr != a)\n\t\t\tvp = vp->next;\n\t}\n\tif (!vp)\n\t\tpanic(\"sym: VTOBUS FAILED!\\n\");\n\tb = vp->baddr + (m - a);\n\tspin_unlock_irqrestore(&sym53c8xx_lock, flags);\n\treturn b;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}