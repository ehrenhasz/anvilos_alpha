{
  "module_name": "sym_nvram.c",
  "hash_id": "ca33c56efac5b2096ee392f74f8bb940b412dc607ab2b4abce9aab991edebb32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sym53c8xx_2/sym_nvram.c",
  "human_readable_source": "\n \n\n#include \"sym_glue.h\"\n#include \"sym_nvram.h\"\n\n#ifdef\tSYM_CONF_DEBUG_NVRAM\nstatic u_char Tekram_boot_delay[7] = {3, 5, 10, 20, 30, 60, 120};\n#endif\n\n \nvoid sym_nvram_setup_host(struct Scsi_Host *shost, struct sym_hcb *np, struct sym_nvram *nvram)\n{\n\t \n\tswitch (nvram->type) {\n\tcase SYM_SYMBIOS_NVRAM:\n\t\tif (!(nvram->data.Symbios.flags & SYMBIOS_PARITY_ENABLE))\n\t\t\tnp->rv_scntl0  &= ~0x0a;\n\t\tnp->myaddr = nvram->data.Symbios.host_id & 0x0f;\n\t\tif (nvram->data.Symbios.flags & SYMBIOS_VERBOSE_MSGS)\n\t\t\tnp->verbose += 1;\n\t\tif (nvram->data.Symbios.flags1 & SYMBIOS_SCAN_HI_LO)\n\t\t\tshost->reverse_ordering = 1;\n\t\tif (nvram->data.Symbios.flags2 & SYMBIOS_AVOID_BUS_RESET)\n\t\t\tnp->usrflags |= SYM_AVOID_BUS_RESET;\n\t\tbreak;\n\tcase SYM_TEKRAM_NVRAM:\n\t\tnp->myaddr = nvram->data.Tekram.host_id & 0x0f;\n\t\tbreak;\n#ifdef CONFIG_PARISC\n\tcase SYM_PARISC_PDC:\n\t\tif (nvram->data.parisc.host_id != -1)\n\t\t\tnp->myaddr = nvram->data.parisc.host_id;\n\t\tif (nvram->data.parisc.factor != -1)\n\t\t\tnp->minsync = nvram->data.parisc.factor;\n\t\tif (nvram->data.parisc.width != -1)\n\t\t\tnp->maxwide = nvram->data.parisc.width;\n\t\tswitch (nvram->data.parisc.mode) {\n\t\t\tcase 0: np->scsi_mode = SMODE_SE; break;\n\t\t\tcase 1: np->scsi_mode = SMODE_HVD; break;\n\t\t\tcase 2: np->scsi_mode = SMODE_LVD; break;\n\t\t\tdefault: break;\n\t\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nsym_Symbios_setup_target(struct sym_tcb *tp, int target, Symbios_nvram *nvram)\n{\n\tSymbios_target *tn = &nvram->target[target];\n\n\tif (!(tn->flags & SYMBIOS_QUEUE_TAGS_ENABLED))\n\t\ttp->usrtags = 0;\n\tif (!(tn->flags & SYMBIOS_DISCONNECT_ENABLE))\n\t\ttp->usrflags &= ~SYM_DISC_ENABLED;\n\tif (!(tn->flags & SYMBIOS_SCAN_AT_BOOT_TIME))\n\t\ttp->usrflags |= SYM_SCAN_BOOT_DISABLED;\n\tif (!(tn->flags & SYMBIOS_SCAN_LUNS))\n\t\ttp->usrflags |= SYM_SCAN_LUNS_DISABLED;\n\ttp->usr_period = (tn->sync_period + 3) / 4;\n\ttp->usr_width = (tn->bus_width == 0x8) ? 0 : 1;\n}\n\nstatic const unsigned char Tekram_sync[16] = {\n\t25, 31, 37, 43, 50, 62, 75, 125, 12, 15, 18, 21, 6, 7, 9, 10\n};\n\n \nstatic void\nsym_Tekram_setup_target(struct sym_tcb *tp, int target, Tekram_nvram *nvram)\n{\n\tstruct Tekram_target *tn = &nvram->target[target];\n\n\tif (tn->flags & TEKRAM_TAGGED_COMMANDS) {\n\t\ttp->usrtags = 2 << nvram->max_tags_index;\n\t}\n\n\tif (tn->flags & TEKRAM_DISCONNECT_ENABLE)\n\t\ttp->usrflags |= SYM_DISC_ENABLED;\n \n\tif (tn->flags & TEKRAM_SYNC_NEGO)\n\t\ttp->usr_period = Tekram_sync[tn->sync_index & 0xf];\n\ttp->usr_width = (tn->flags & TEKRAM_WIDE_NEGO) ? 1 : 0;\n}\n\n \nvoid sym_nvram_setup_target(struct sym_tcb *tp, int target, struct sym_nvram *nvp)\n{\n\tswitch (nvp->type) {\n\tcase SYM_SYMBIOS_NVRAM:\n\t\tsym_Symbios_setup_target(tp, target, &nvp->data.Symbios);\n\t\tbreak;\n\tcase SYM_TEKRAM_NVRAM:\n\t\tsym_Tekram_setup_target(tp, target, &nvp->data.Tekram);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#ifdef\tSYM_CONF_DEBUG_NVRAM\n \nstatic void sym_display_Symbios_nvram(struct sym_device *np, Symbios_nvram *nvram)\n{\n\tint i;\n\n\t \n\tprintf(\"%s: HOST ID=%d%s%s%s%s%s%s\\n\",\n\t\tsym_name(np), nvram->host_id & 0x0f,\n\t\t(nvram->flags  & SYMBIOS_SCAM_ENABLE)\t? \" SCAM\"\t:\"\",\n\t\t(nvram->flags  & SYMBIOS_PARITY_ENABLE)\t? \" PARITY\"\t:\"\",\n\t\t(nvram->flags  & SYMBIOS_VERBOSE_MSGS)\t? \" VERBOSE\"\t:\"\", \n\t\t(nvram->flags  & SYMBIOS_CHS_MAPPING)\t? \" CHS_ALT\"\t:\"\", \n\t\t(nvram->flags2 & SYMBIOS_AVOID_BUS_RESET)?\" NO_RESET\"\t:\"\",\n\t\t(nvram->flags1 & SYMBIOS_SCAN_HI_LO)\t? \" HI_LO\"\t:\"\");\n\n\t \n\tfor (i = 0 ; i < 15 ; i++) {\n\t\tstruct Symbios_target *tn = &nvram->target[i];\n\t\tprintf(\"%s-%d:%s%s%s%s WIDTH=%d SYNC=%d TMO=%d\\n\",\n\t\tsym_name(np), i,\n\t\t(tn->flags & SYMBIOS_DISCONNECT_ENABLE)\t? \" DISC\"\t: \"\",\n\t\t(tn->flags & SYMBIOS_SCAN_AT_BOOT_TIME)\t? \" SCAN_BOOT\"\t: \"\",\n\t\t(tn->flags & SYMBIOS_SCAN_LUNS)\t\t? \" SCAN_LUNS\"\t: \"\",\n\t\t(tn->flags & SYMBIOS_QUEUE_TAGS_ENABLED)? \" TCQ\"\t: \"\",\n\t\ttn->bus_width,\n\t\ttn->sync_period / 4,\n\t\ttn->timeout);\n\t}\n}\n\n \nstatic void sym_display_Tekram_nvram(struct sym_device *np, Tekram_nvram *nvram)\n{\n\tint i, tags, boot_delay;\n\tchar *rem;\n\n\t \n\ttags = 2 << nvram->max_tags_index;\n\tboot_delay = 0;\n\tif (nvram->boot_delay_index < 6)\n\t\tboot_delay = Tekram_boot_delay[nvram->boot_delay_index];\n\tswitch ((nvram->flags & TEKRAM_REMOVABLE_FLAGS) >> 6) {\n\tdefault:\n\tcase 0:\trem = \"\";\t\t\tbreak;\n\tcase 1: rem = \" REMOVABLE=boot device\";\tbreak;\n\tcase 2: rem = \" REMOVABLE=all\";\t\tbreak;\n\t}\n\n\tprintf(\"%s: HOST ID=%d%s%s%s%s%s%s%s%s%s BOOT DELAY=%d tags=%d\\n\",\n\t\tsym_name(np), nvram->host_id & 0x0f,\n\t\t(nvram->flags1 & SYMBIOS_SCAM_ENABLE)\t? \" SCAM\"\t:\"\",\n\t\t(nvram->flags & TEKRAM_MORE_THAN_2_DRIVES) ? \" >2DRIVES\":\"\",\n\t\t(nvram->flags & TEKRAM_DRIVES_SUP_1GB)\t? \" >1GB\"\t:\"\",\n\t\t(nvram->flags & TEKRAM_RESET_ON_POWER_ON) ? \" RESET\"\t:\"\",\n\t\t(nvram->flags & TEKRAM_ACTIVE_NEGATION)\t? \" ACT_NEG\"\t:\"\",\n\t\t(nvram->flags & TEKRAM_IMMEDIATE_SEEK)\t? \" IMM_SEEK\"\t:\"\",\n\t\t(nvram->flags & TEKRAM_SCAN_LUNS)\t? \" SCAN_LUNS\"\t:\"\",\n\t\t(nvram->flags1 & TEKRAM_F2_F6_ENABLED)\t? \" F2_F6\"\t:\"\",\n\t\trem, boot_delay, tags);\n\n\t \n\tfor (i = 0; i <= 15; i++) {\n\t\tint sync, j;\n\t\tstruct Tekram_target *tn = &nvram->target[i];\n\t\tj = tn->sync_index & 0xf;\n\t\tsync = Tekram_sync[j];\n\t\tprintf(\"%s-%d:%s%s%s%s%s%s PERIOD=%d\\n\",\n\t\tsym_name(np), i,\n\t\t(tn->flags & TEKRAM_PARITY_CHECK)\t? \" PARITY\"\t: \"\",\n\t\t(tn->flags & TEKRAM_SYNC_NEGO)\t\t? \" SYNC\"\t: \"\",\n\t\t(tn->flags & TEKRAM_DISCONNECT_ENABLE)\t? \" DISC\"\t: \"\",\n\t\t(tn->flags & TEKRAM_START_CMD)\t\t? \" START\"\t: \"\",\n\t\t(tn->flags & TEKRAM_TAGGED_COMMANDS)\t? \" TCQ\"\t: \"\",\n\t\t(tn->flags & TEKRAM_WIDE_NEGO)\t\t? \" WIDE\"\t: \"\",\n\t\tsync);\n\t}\n}\n#else\nstatic void sym_display_Symbios_nvram(struct sym_device *np, Symbios_nvram *nvram) { (void)np; (void)nvram; }\nstatic void sym_display_Tekram_nvram(struct sym_device *np, Tekram_nvram *nvram) { (void)np; (void)nvram; }\n#endif\t \n\n\n \n\n#define SET_BIT 0\n#define CLR_BIT 1\n#define SET_CLK 2\n#define CLR_CLK 3\n\n \nstatic void S24C16_set_bit(struct sym_device *np, u_char write_bit, u_char *gpreg, \n\t\t\t  int bit_mode)\n{\n\tudelay(5);\n\tswitch (bit_mode) {\n\tcase SET_BIT:\n\t\t*gpreg |= write_bit;\n\t\tbreak;\n\tcase CLR_BIT:\n\t\t*gpreg &= 0xfe;\n\t\tbreak;\n\tcase SET_CLK:\n\t\t*gpreg |= 0x02;\n\t\tbreak;\n\tcase CLR_CLK:\n\t\t*gpreg &= 0xfd;\n\t\tbreak;\n\n\t}\n\tOUTB(np, nc_gpreg, *gpreg);\n\tINB(np, nc_mbox1);\n\tudelay(5);\n}\n\n \nstatic void S24C16_start(struct sym_device *np, u_char *gpreg)\n{\n\tS24C16_set_bit(np, 1, gpreg, SET_BIT);\n\tS24C16_set_bit(np, 0, gpreg, SET_CLK);\n\tS24C16_set_bit(np, 0, gpreg, CLR_BIT);\n\tS24C16_set_bit(np, 0, gpreg, CLR_CLK);\n}\n\n \nstatic void S24C16_stop(struct sym_device *np, u_char *gpreg)\n{\n\tS24C16_set_bit(np, 0, gpreg, SET_CLK);\n\tS24C16_set_bit(np, 1, gpreg, SET_BIT);\n}\n\n \nstatic void S24C16_do_bit(struct sym_device *np, u_char *read_bit, u_char write_bit, \n\t\t\t u_char *gpreg)\n{\n\tS24C16_set_bit(np, write_bit, gpreg, SET_BIT);\n\tS24C16_set_bit(np, 0, gpreg, SET_CLK);\n\tif (read_bit)\n\t\t*read_bit = INB(np, nc_gpreg);\n\tS24C16_set_bit(np, 0, gpreg, CLR_CLK);\n\tS24C16_set_bit(np, 0, gpreg, CLR_BIT);\n}\n\n \nstatic void S24C16_write_ack(struct sym_device *np, u_char write_bit, u_char *gpreg, \n\t\t\t    u_char *gpcntl)\n{\n\tOUTB(np, nc_gpcntl, *gpcntl & 0xfe);\n\tS24C16_do_bit(np, NULL, write_bit, gpreg);\n\tOUTB(np, nc_gpcntl, *gpcntl);\n}\n\n \nstatic void S24C16_read_ack(struct sym_device *np, u_char *read_bit, u_char *gpreg, \n\t\t\t   u_char *gpcntl)\n{\n\tOUTB(np, nc_gpcntl, *gpcntl | 0x01);\n\tS24C16_do_bit(np, read_bit, 1, gpreg);\n\tOUTB(np, nc_gpcntl, *gpcntl);\n}\n\n \nstatic void S24C16_write_byte(struct sym_device *np, u_char *ack_data, u_char write_data, \n\t\t\t     u_char *gpreg, u_char *gpcntl)\n{\n\tint x;\n\t\n\tfor (x = 0; x < 8; x++)\n\t\tS24C16_do_bit(np, NULL, (write_data >> (7 - x)) & 0x01, gpreg);\n\t\t\n\tS24C16_read_ack(np, ack_data, gpreg, gpcntl);\n}\n\n \nstatic void S24C16_read_byte(struct sym_device *np, u_char *read_data, u_char ack_data, \n\t\t\t    u_char *gpreg, u_char *gpcntl)\n{\n\tint x;\n\tu_char read_bit;\n\n\t*read_data = 0;\n\tfor (x = 0; x < 8; x++) {\n\t\tS24C16_do_bit(np, &read_bit, 1, gpreg);\n\t\t*read_data |= ((read_bit & 0x01) << (7 - x));\n\t}\n\n\tS24C16_write_ack(np, ack_data, gpreg, gpcntl);\n}\n\n#ifdef SYM_CONF_NVRAM_WRITE_SUPPORT\n \nstatic int sym_write_S24C16_nvram(struct sym_device *np, int offset,\n\t\tu_char *data, int len)\n{\n\tu_char\tgpcntl, gpreg;\n\tu_char\told_gpcntl, old_gpreg;\n\tu_char\tack_data;\n\tint\tx;\n\n\t \n\told_gpreg\t= INB(np, nc_gpreg);\n\told_gpcntl\t= INB(np, nc_gpcntl);\n\tgpcntl\t\t= old_gpcntl & 0x1c;\n\n\t \n\tOUTB(np, nc_gpreg,  old_gpreg);\n\tOUTB(np, nc_gpcntl, gpcntl);\n\n\t \n\tgpreg = old_gpreg;\n\tS24C16_set_bit(np, 0, &gpreg, CLR_CLK);\n\tS24C16_set_bit(np, 0, &gpreg, CLR_BIT);\n\t\t\n\t \n\tS24C16_stop(np, &gpreg);\n\n\t \n\tfor (x = 0; x < len ; x += 16) {\n\t\tdo {\n\t\t\tS24C16_start(np, &gpreg);\n\t\t\tS24C16_write_byte(np, &ack_data,\n\t\t\t\t\t  0xa0 | (((offset+x) >> 7) & 0x0e),\n\t\t\t\t\t  &gpreg, &gpcntl);\n\t\t} while (ack_data & 0x01);\n\n\t\tS24C16_write_byte(np, &ack_data, (offset+x) & 0xff, \n\t\t\t\t  &gpreg, &gpcntl);\n\n\t\tfor (y = 0; y < 16; y++)\n\t\t\tS24C16_write_byte(np, &ack_data, data[x+y], \n\t\t\t\t\t  &gpreg, &gpcntl);\n\t\tS24C16_stop(np, &gpreg);\n\t}\n\n\t \n\tOUTB(np, nc_gpcntl, old_gpcntl);\n\tOUTB(np, nc_gpreg,  old_gpreg);\n\n\treturn 0;\n}\n#endif  \n\n \nstatic int sym_read_S24C16_nvram(struct sym_device *np, int offset, u_char *data, int len)\n{\n\tu_char\tgpcntl, gpreg;\n\tu_char\told_gpcntl, old_gpreg;\n\tu_char\tack_data;\n\tint\tretv = 1;\n\tint\tx;\n\n\t \n\told_gpreg\t= INB(np, nc_gpreg);\n\told_gpcntl\t= INB(np, nc_gpcntl);\n\tgpcntl\t\t= old_gpcntl & 0x1c;\n\n\t \n\tOUTB(np, nc_gpreg,  old_gpreg);\n\tOUTB(np, nc_gpcntl, gpcntl);\n\n\t \n\tgpreg = old_gpreg;\n\tS24C16_set_bit(np, 0, &gpreg, CLR_CLK);\n\tS24C16_set_bit(np, 0, &gpreg, CLR_BIT);\n\t\t\n\t \n\tS24C16_stop(np, &gpreg);\n\t\n\t \n\tS24C16_start(np, &gpreg);\n\n\t \n\tS24C16_write_byte(np, &ack_data,\n\t\t0xa0 | ((offset >> 7) & 0x0e), &gpreg, &gpcntl);\n\tif (ack_data & 0x01)\n\t\tgoto out;\n\n\t \n\tS24C16_write_byte(np, &ack_data,\n\t\toffset & 0xff, &gpreg, &gpcntl);\n\tif (ack_data & 0x01)\n\t\tgoto out;\n\n\t \n\tS24C16_start(np, &gpreg);\n\t\n\t \n\tS24C16_write_byte(np, &ack_data,\n\t\t0xa1 | ((offset >> 7) & 0x0e), &gpreg, &gpcntl);\n\tif (ack_data & 0x01)\n\t\tgoto out;\n\n\t \n\tgpcntl |= 0x01;\n\tOUTB(np, nc_gpcntl, gpcntl);\n\t\t\n\t \n\tfor (x = 0; x < len; x++) \n\t\tS24C16_read_byte(np, &data[x], (x == (len-1)), &gpreg, &gpcntl);\n\n\t \n\tgpcntl &= 0xfe;\n\tOUTB(np, nc_gpcntl, gpcntl);\n\tS24C16_stop(np, &gpreg);\n\tretv = 0;\nout:\n\t \n\tOUTB(np, nc_gpcntl, old_gpcntl);\n\tOUTB(np, nc_gpreg,  old_gpreg);\n\n\treturn retv;\n}\n\n#undef SET_BIT\n#undef CLR_BIT\n#undef SET_CLK\n#undef CLR_CLK\n\n \nstatic int sym_read_Symbios_nvram(struct sym_device *np, Symbios_nvram *nvram)\n{\n\tstatic u_char Symbios_trailer[6] = {0xfe, 0xfe, 0, 0, 0, 0};\n\tu_char *data = (u_char *) nvram;\n\tint len  = sizeof(*nvram);\n\tu_short\tcsum;\n\tint x;\n\n\t \n\tif (sym_read_S24C16_nvram (np, SYMBIOS_NVRAM_ADDRESS, data, len))\n\t\treturn 1;\n\n\t \n\tif (nvram->type != 0 ||\n\t    memcmp(nvram->trailer, Symbios_trailer, 6) ||\n\t    nvram->byte_count != len - 12)\n\t\treturn 1;\n\n\t \n\tfor (x = 6, csum = 0; x < len - 6; x++)\n\t\tcsum += data[x];\n\tif (csum != nvram->checksum)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \n\n \nstatic void T93C46_Clk(struct sym_device *np, u_char *gpreg)\n{\n\tOUTB(np, nc_gpreg, *gpreg | 0x04);\n\tINB(np, nc_mbox1);\n\tudelay(2);\n\tOUTB(np, nc_gpreg, *gpreg);\n}\n\n \nstatic void T93C46_Read_Bit(struct sym_device *np, u_char *read_bit, u_char *gpreg)\n{\n\tudelay(2);\n\tT93C46_Clk(np, gpreg);\n\t*read_bit = INB(np, nc_gpreg);\n}\n\n \nstatic void T93C46_Write_Bit(struct sym_device *np, u_char write_bit, u_char *gpreg)\n{\n\tif (write_bit & 0x01)\n\t\t*gpreg |= 0x02;\n\telse\n\t\t*gpreg &= 0xfd;\n\t\t\n\t*gpreg |= 0x10;\n\t\t\n\tOUTB(np, nc_gpreg, *gpreg);\n\tINB(np, nc_mbox1);\n\tudelay(2);\n\n\tT93C46_Clk(np, gpreg);\n}\n\n \nstatic void T93C46_Stop(struct sym_device *np, u_char *gpreg)\n{\n\t*gpreg &= 0xef;\n\tOUTB(np, nc_gpreg, *gpreg);\n\tINB(np, nc_mbox1);\n\tudelay(2);\n\n\tT93C46_Clk(np, gpreg);\n}\n\n \nstatic void T93C46_Send_Command(struct sym_device *np, u_short write_data, \n\t\t\t\tu_char *read_bit, u_char *gpreg)\n{\n\tint x;\n\n\t \n\tfor (x = 0; x < 9; x++)\n\t\tT93C46_Write_Bit(np, (u_char) (write_data >> (8 - x)), gpreg);\n\n\t*read_bit = INB(np, nc_gpreg);\n}\n\n \nstatic void T93C46_Read_Word(struct sym_device *np,\n\t\tunsigned short *nvram_data, unsigned char *gpreg)\n{\n\tint x;\n\tu_char read_bit;\n\n\t*nvram_data = 0;\n\tfor (x = 0; x < 16; x++) {\n\t\tT93C46_Read_Bit(np, &read_bit, gpreg);\n\n\t\tif (read_bit & 0x01)\n\t\t\t*nvram_data |=  (0x01 << (15 - x));\n\t\telse\n\t\t\t*nvram_data &= ~(0x01 << (15 - x));\n\t}\n}\n\n \nstatic int T93C46_Read_Data(struct sym_device *np, unsigned short *data,\n\t\tint len, unsigned char *gpreg)\n{\n\tint x;\n\n\tfor (x = 0; x < len; x++)  {\n\t\tunsigned char read_bit;\n\t\t \n\t\tT93C46_Send_Command(np, 0x180 | x, &read_bit, gpreg);\n\t\tif (read_bit & 0x01)\n\t\t\treturn 1;  \n\t\tT93C46_Read_Word(np, &data[x], gpreg);\n\t\tT93C46_Stop(np, gpreg);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sym_read_T93C46_nvram(struct sym_device *np, Tekram_nvram *nvram)\n{\n\tu_char gpcntl, gpreg;\n\tu_char old_gpcntl, old_gpreg;\n\tint retv;\n\n\t \n\told_gpreg\t= INB(np, nc_gpreg);\n\told_gpcntl\t= INB(np, nc_gpcntl);\n\n\t \n\tgpreg = old_gpreg & 0xe9;\n\tOUTB(np, nc_gpreg, gpreg);\n\tgpcntl = (old_gpcntl & 0xe9) | 0x09;\n\tOUTB(np, nc_gpcntl, gpcntl);\n\n\t \n\tretv = T93C46_Read_Data(np, (u_short *) nvram,\n\t\t\t\tsizeof(*nvram) / sizeof(short), &gpreg);\n\t\n\t \n\tOUTB(np, nc_gpcntl, old_gpcntl);\n\tOUTB(np, nc_gpreg,  old_gpreg);\n\n\treturn retv;\n}\n\n \nstatic int sym_read_Tekram_nvram (struct sym_device *np, Tekram_nvram *nvram)\n{\n\tu_char *data = (u_char *) nvram;\n\tint len = sizeof(*nvram);\n\tu_short\tcsum;\n\tint x;\n\n\tswitch (np->pdev->device) {\n\tcase PCI_DEVICE_ID_NCR_53C885:\n\tcase PCI_DEVICE_ID_NCR_53C895:\n\tcase PCI_DEVICE_ID_NCR_53C896:\n\t\tx = sym_read_S24C16_nvram(np, TEKRAM_24C16_NVRAM_ADDRESS,\n\t\t\t\t\t  data, len);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_NCR_53C875:\n\t\tx = sym_read_S24C16_nvram(np, TEKRAM_24C16_NVRAM_ADDRESS,\n\t\t\t\t\t  data, len);\n\t\tif (!x)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tx = sym_read_T93C46_nvram(np, nvram);\n\t\tbreak;\n\t}\n\tif (x)\n\t\treturn 1;\n\n\t \n\tfor (x = 0, csum = 0; x < len - 1; x += 2)\n\t\tcsum += data[x] + (data[x+1] << 8);\n\tif (csum != 0x1234)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PARISC\n \nstatic int sym_read_parisc_pdc(struct sym_device *np, struct pdc_initiator *pdc)\n{\n\tstruct hardware_path hwpath;\n\tget_pci_node_path(np->pdev, &hwpath);\n\tif (!pdc_get_initiator(&hwpath, pdc))\n\t\treturn 0;\n\n\treturn SYM_PARISC_PDC;\n}\n#else\nstatic inline int sym_read_parisc_pdc(struct sym_device *np,\n\t\t\t\t\tstruct pdc_initiator *x)\n{\n\treturn 0;\n}\n#endif\n\n \nint sym_read_nvram(struct sym_device *np, struct sym_nvram *nvp)\n{\n\tif (!sym_read_Symbios_nvram(np, &nvp->data.Symbios)) {\n\t\tnvp->type = SYM_SYMBIOS_NVRAM;\n\t\tsym_display_Symbios_nvram(np, &nvp->data.Symbios);\n\t} else if (!sym_read_Tekram_nvram(np, &nvp->data.Tekram)) {\n\t\tnvp->type = SYM_TEKRAM_NVRAM;\n\t\tsym_display_Tekram_nvram(np, &nvp->data.Tekram);\n\t} else {\n\t\tnvp->type = sym_read_parisc_pdc(np, &nvp->data.parisc);\n\t}\n\treturn nvp->type;\n}\n\nchar *sym_nvram_type(struct sym_nvram *nvp)\n{\n\tswitch (nvp->type) {\n\tcase SYM_SYMBIOS_NVRAM:\n\t\treturn \"Symbios NVRAM\";\n\tcase SYM_TEKRAM_NVRAM:\n\t\treturn \"Tekram NVRAM\";\n\tcase SYM_PARISC_PDC:\n\t\treturn \"PA-RISC Firmware\";\n\tdefault:\n\t\treturn \"No NVRAM\";\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}