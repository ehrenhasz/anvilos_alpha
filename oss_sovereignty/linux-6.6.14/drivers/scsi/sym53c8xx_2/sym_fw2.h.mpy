{
  "module_name": "sym_fw2.h",
  "hash_id": "fc33fb4e979915e79b253e9f58a7975603bb37afe3db458a7e72c346530170c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sym53c8xx_2/sym_fw2.h",
  "human_readable_source": " \n \n\n \n\n \nstruct SYM_FWA_SCR {\n\tu32 start\t\t[ 14];\n\tu32 getjob_begin\t[  4];\n\tu32 getjob_end\t\t[  4];\n#ifdef SYM_CONF_TARGET_ROLE_SUPPORT\n\tu32 select\t\t[  6];\n#else\n\tu32 select\t\t[  4];\n#endif\n#if\tSYM_CONF_DMA_ADDRESSING_MODE == 2\n\tu32 is_dmap_dirty\t[  4];\n#endif\n\tu32 wf_sel_done\t\t[  2];\n\tu32 sel_done\t\t[  2];\n\tu32 send_ident\t\t[  2];\n#ifdef SYM_CONF_IARB_SUPPORT\n\tu32 select2\t\t[  8];\n#else\n\tu32 select2\t\t[  2];\n#endif\n\tu32 command\t\t[  2];\n\tu32 dispatch\t\t[ 28];\n\tu32 sel_no_cmd\t\t[ 10];\n\tu32 init\t\t[  6];\n\tu32 clrack\t\t[  4];\n\tu32 datai_done\t\t[ 10];\n\tu32 datai_done_wsr\t[ 20];\n\tu32 datao_done\t\t[ 10];\n\tu32 datao_done_wss\t[  6];\n\tu32 datai_phase\t\t[  4];\n\tu32 datao_phase\t\t[  6];\n\tu32 msg_in\t\t[  2];\n\tu32 msg_in2\t\t[ 10];\n#ifdef SYM_CONF_IARB_SUPPORT\n\tu32 status\t\t[ 14];\n#else\n\tu32 status\t\t[ 10];\n#endif\n\tu32 complete\t\t[  6];\n\tu32 complete2\t\t[ 12];\n\tu32 done\t\t[ 14];\n\tu32 done_end\t\t[  2];\n\tu32 complete_error\t[  4];\n\tu32 save_dp\t\t[ 12];\n\tu32 restore_dp\t\t[  8];\n\tu32 disconnect\t\t[ 12];\n#ifdef SYM_CONF_IARB_SUPPORT\n\tu32 idle\t\t[  4];\n#else\n\tu32 idle\t\t[  2];\n#endif\n#ifdef SYM_CONF_IARB_SUPPORT\n\tu32 ungetjob\t\t[  6];\n#else\n\tu32 ungetjob\t\t[  4];\n#endif\n#ifdef SYM_CONF_TARGET_ROLE_SUPPORT\n\tu32 reselect\t\t[  4];\n#else\n\tu32 reselect\t\t[  2];\n#endif\n\tu32 reselected\t\t[ 22];\n\tu32 resel_scntl4\t[ 20];\n\tu32 resel_lun0\t\t[  6];\n#if   SYM_CONF_MAX_TASK*4 > 512\n\tu32 resel_tag\t\t[ 26];\n#elif SYM_CONF_MAX_TASK*4 > 256\n\tu32 resel_tag\t\t[ 20];\n#else\n\tu32 resel_tag\t\t[ 16];\n#endif\n\tu32 resel_dsa\t\t[  2];\n\tu32 resel_dsa1\t\t[  4];\n\tu32 resel_no_tag\t[  6];\n\tu32 data_in\t\t[SYM_CONF_MAX_SG * 2];\n\tu32 data_in2\t\t[  4];\n\tu32 data_out\t\t[SYM_CONF_MAX_SG * 2];\n\tu32 data_out2\t\t[  4];\n\tu32 pm0_data\t\t[ 12];\n\tu32 pm0_data_out\t[  6];\n\tu32 pm0_data_end\t[  6];\n\tu32 pm1_data\t\t[ 12];\n\tu32 pm1_data_out\t[  6];\n\tu32 pm1_data_end\t[  6];\n};\n\n \nstruct SYM_FWB_SCR {\n\tu32 start64\t\t[  2];\n\tu32 no_data\t\t[  2];\n#ifdef SYM_CONF_TARGET_ROLE_SUPPORT\n\tu32 sel_for_abort\t[ 18];\n#else\n\tu32 sel_for_abort\t[ 16];\n#endif\n\tu32 sel_for_abort_1\t[  2];\n\tu32 msg_in_etc\t\t[ 12];\n\tu32 msg_received\t[  4];\n\tu32 msg_weird_seen\t[  4];\n\tu32 msg_extended\t[ 20];\n\tu32 msg_bad\t\t[  6];\n\tu32 msg_weird\t\t[  4];\n\tu32 msg_weird1\t\t[  8];\n\n\tu32 wdtr_resp\t\t[  6];\n\tu32 send_wdtr\t\t[  4];\n\tu32 sdtr_resp\t\t[  6];\n\tu32 send_sdtr\t\t[  4];\n\tu32 ppr_resp\t\t[  6];\n\tu32 send_ppr\t\t[  4];\n\tu32 nego_bad_phase\t[  4];\n\tu32 msg_out\t\t[  4];\n\tu32 msg_out_done\t[  4];\n\tu32 data_ovrun\t\t[  2];\n\tu32 data_ovrun1\t\t[ 22];\n\tu32 data_ovrun2\t\t[  8];\n\tu32 abort_resel\t\t[ 16];\n\tu32 resend_ident\t[  4];\n\tu32 ident_break\t\t[  4];\n\tu32 ident_break_atn\t[  4];\n\tu32 sdata_in\t\t[  6];\n\tu32 resel_bad_lun\t[  4];\n\tu32 bad_i_t_l\t\t[  4];\n\tu32 bad_i_t_l_q\t\t[  4];\n\tu32 bad_status\t\t[  6];\n\tu32 pm_handle\t\t[ 20];\n\tu32 pm_handle1\t\t[  4];\n\tu32 pm_save\t\t[  4];\n\tu32 pm0_save\t\t[ 12];\n\tu32 pm_save_end\t\t[  4];\n\tu32 pm1_save\t\t[ 14];\n\n\t \n\tu32 pm_wsr_handle\t[ 38];\n\tu32 wsr_ma_helper\t[  4];\n\n\t \n\tu32 zero\t\t[  1];\n\tu32 scratch\t\t[  1];\n\tu32 pm0_data_addr\t[  1];\n\tu32 pm1_data_addr\t[  1];\n\tu32 done_pos\t\t[  1];\n\tu32 startpos\t\t[  1];\n\tu32 targtbl\t\t[  1];\n};\n\n \nstruct SYM_FWZ_SCR {\n\tu32 snooptest\t\t[  6];\n\tu32 snoopend\t\t[  2];\n};\n\nstatic struct SYM_FWA_SCR SYM_FWA_SCR = {\n  {\n\t \n\tSCR_REG_REG (gpreg, SCR_AND, 0xfe),\n\t\t0,\n\t \n\tSCR_FROM_REG (ctest2),\n\t\t0,\n\t \n\tSCR_FROM_REG (istat),\n\t\t0,\n\t \n\tSCR_LOAD_ABS (scratcha, 4),\n\t\tPADDR_B (startpos),\n\tSCR_INT ^ IFTRUE (MASK (SEM, SEM)),\n\t\tSIR_SCRIPT_STOPPED,\n\t \n\tSCR_LOAD_ABS (dsa, 4),\n\t\tPADDR_B (startpos),\n\tSCR_LOAD_REL (temp, 4),\n\t\t4,\n} ,{\n\tSCR_STORE_ABS (temp, 4),\n\t\tPADDR_B (startpos),\n\tSCR_LOAD_REL (dsa, 4),\n\t\t0,\n} ,{\n\tSCR_LOAD_REL (temp, 4),\n\t\t0,\n\tSCR_RETURN,\n\t\t0,\n} ,{\n\t \n#ifdef SYM_CONF_TARGET_ROLE_SUPPORT\n\tSCR_CLR (SCR_TRG),\n\t\t0,\n#endif\n\t \n\tSCR_SEL_TBL_ATN ^ offsetof (struct sym_dsb, select),\n\t\tPADDR_A (ungetjob),\n\t \n\t \n\tSCR_LOAD_REL (scr0, 4),\n\t\toffsetof (struct sym_ccb, phys.head.status),\n\t \n#if\tSYM_CONF_DMA_ADDRESSING_MODE == 2\n} ,{\n\tSCR_FROM_REG (HX_REG),\n\t\t0,\n\tSCR_INT ^ IFTRUE (MASK (HX_DMAP_DIRTY, HX_DMAP_DIRTY)),\n\t\tSIR_DMAP_DIRTY,\n#endif\n} ,{\n\tSCR_INT ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\tSIR_SEL_ATN_NO_MSG_OUT,\n} ,{\n\t \n\tSCR_LOAD_REL (scntl3, 1),\n\t\toffsetof(struct sym_dsb, select.sel_scntl3),\n} ,{\n\t \n\tSCR_MOVE_TBL ^ SCR_MSG_OUT,\n\t\toffsetof (struct sym_dsb, smsg),\n} ,{\n#ifdef SYM_CONF_IARB_SUPPORT\n\t \n\tSCR_FROM_REG (HF_REG),\n\t\t0,\n\tSCR_JUMPR ^ IFFALSE (MASK (HF_HINT_IARB, HF_HINT_IARB)),\n\t\t8,\n\tSCR_REG_REG (scntl1, SCR_OR, IARB),\n\t\t0,\n#endif\n\t \n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_COMMAND)),\n\t\tPADDR_A (sel_no_cmd),\n} ,{\n\t \n\tSCR_MOVE_TBL ^ SCR_COMMAND,\n\t\toffsetof (struct sym_dsb, cmd),\n} ,{\n\t \n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_IN)),\n\t\tPADDR_A (msg_in),\n\tSCR_JUMP ^ IFTRUE (IF (SCR_DATA_OUT)),\n\t\tPADDR_A (datao_phase),\n\tSCR_JUMP ^ IFTRUE (IF (SCR_DATA_IN)),\n\t\tPADDR_A (datai_phase),\n\tSCR_JUMP ^ IFTRUE (IF (SCR_STATUS)),\n\t\tPADDR_A (status),\n\tSCR_JUMP ^ IFTRUE (IF (SCR_COMMAND)),\n\t\tPADDR_A (command),\n\tSCR_JUMP ^ IFTRUE (IF (SCR_MSG_OUT)),\n\t\tPADDR_B (msg_out),\n\t \n\tSCR_JUMPR ^ IFFALSE (WHEN (SCR_ILG_OUT)),\n\t\t16,\n\tSCR_MOVE_ABS (1) ^ SCR_ILG_OUT,\n\t\tHADDR_1 (scratch),\n\tSCR_JUMPR ^ IFTRUE (WHEN (SCR_ILG_OUT)),\n\t\t-16,\n\tSCR_JUMPR ^ IFFALSE (WHEN (SCR_ILG_IN)),\n\t\t16,\n\tSCR_MOVE_ABS (1) ^ SCR_ILG_IN,\n\t\tHADDR_1 (scratch),\n\tSCR_JUMPR ^ IFTRUE (WHEN (SCR_ILG_IN)),\n\t\t-16,\n\tSCR_INT,\n\t\tSIR_BAD_PHASE,\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_OUT)),\n\t\tPADDR_B (resend_ident),\n\t \n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_IN)),\n\t\tPADDR_A (dispatch),\n\tSCR_FROM_REG (HS_REG),\n\t\t0,\n\tSCR_INT ^ IFTRUE (DATA (HS_NEGOTIATE)),\n\t\tSIR_NEGO_FAILED,\n\t \n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_FROM_REG (sstat0),\n\t\t0,\n\tSCR_JUMPR ^ IFTRUE (MASK (IRST, IRST)),\n\t\t-16,\n\tSCR_JUMP,\n\t\tPADDR_A (start),\n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_STORE_REL (temp, 4),\n\t\toffsetof (struct sym_ccb, phys.head.lastp),\n\t \n\tSCR_FROM_REG (scntl2),\n\t\t0,\n\tSCR_JUMP ^ IFTRUE (MASK (WSR, WSR)),\n\t\tPADDR_A (datai_done_wsr),\n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_STATUS)),\n\t\tPADDR_A (status),\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_REG_REG (scntl2, SCR_OR, WSR),\n\t\t0,\n\t \n\tSCR_INT ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tSIR_SWIDE_OVERRUN,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR_A (dispatch),\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tHADDR_1 (msgin[0]),\n\tSCR_INT ^ IFFALSE (DATA (M_IGN_RESIDUE)),\n\t\tSIR_SWIDE_OVERRUN,\n\tSCR_JUMP ^ IFFALSE (DATA (M_IGN_RESIDUE)),\n\t\tPADDR_A (msg_in2),\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tHADDR_1 (msgin[1]),\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_STORE_REL (temp, 4),\n\t\toffsetof (struct sym_ccb, phys.head.lastp),\n\t \n\tSCR_FROM_REG (scntl2),\n\t\t0,\n\tSCR_JUMP ^ IFTRUE (MASK (WSS, WSS)),\n\t\tPADDR_A (datao_done_wss),\n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_STATUS)),\n\t\tPADDR_A (status),\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_REG_REG (scntl2, SCR_OR, WSS),\n\t\t0,\n\t \n\tSCR_INT,\n\t\tSIR_SODL_UNDERRUN,\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_LOAD_REL (temp, 4),\n\t\toffsetof (struct sym_ccb, phys.head.lastp),\n\tSCR_RETURN,\n\t\t0,\n} ,{\n\t \n\tSCR_REG_REG (scntl4, SCR_OR, (XCLKH_DT|XCLKH_ST)),\n\t\t0,\n\t \n\tSCR_LOAD_REL (temp, 4),\n\t\toffsetof (struct sym_ccb, phys.head.lastp),\n\tSCR_RETURN,\n\t\t0,\n} ,{\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tHADDR_1 (msgin[0]),\n} ,{\n\t \n\tSCR_JUMP ^ IFTRUE (DATA (M_COMPLETE)),\n\t\tPADDR_A (complete),\n\tSCR_JUMP ^ IFTRUE (DATA (M_DISCONNECT)),\n\t\tPADDR_A (disconnect),\n\tSCR_JUMP ^ IFTRUE (DATA (M_SAVE_DP)),\n\t\tPADDR_A (save_dp),\n\tSCR_JUMP ^ IFTRUE (DATA (M_RESTORE_DP)),\n\t\tPADDR_A (restore_dp),\n\t \n\tSCR_JUMP,\n\t\tPADDR_B (msg_in_etc),\n} ,{\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_STATUS,\n\t\tHADDR_1 (scratch),\n#ifdef SYM_CONF_IARB_SUPPORT\n\t \n\tSCR_JUMPR ^ IFTRUE (DATA (S_GOOD)),\n\t\t8,\n\tSCR_REG_REG (scntl1, SCR_AND, ~IARB),\n\t\t0,\n#endif\n\t \n\tSCR_TO_REG (SS_REG),\n\t\t0,\n\tSCR_LOAD_REG (HS_REG, HS_COMPLETE),\n\t\t0,\n\t \n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_IN)),\n\t\tPADDR_A (msg_in),\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\t \n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\t \n\tSCR_WAIT_DISC,\n\t\t0,\n} ,{\n\t \n\tSCR_STORE_REL (scr0, 4),\n\t\toffsetof (struct sym_ccb, phys.head.status),\n\t \n\tSCR_LOAD_REL (scr0, 4),\t \n\t\toffsetof (struct sym_ccb, phys.head.status),\n\n\t \n\tSCR_FROM_REG (SS_REG),\n\t\t0,\n\tSCR_CALL ^ IFFALSE (DATA (S_GOOD)),\n\t\tPADDR_B (bad_status),\n\t \n\tSCR_FROM_REG (HF_REG),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (MASK (0 ,(HF_SENSE|HF_EXT_ERR))),\n\t\tPADDR_A (complete_error),\n} ,{\n\t \n\tSCR_STORE_ABS (dsa, 4),\n\t\tPADDR_B (scratch),\n\tSCR_LOAD_ABS (dsa, 4),\n\t\tPADDR_B (done_pos),\n\tSCR_LOAD_ABS (scratcha, 4),\n\t\tPADDR_B (scratch),\n\tSCR_STORE_REL (scratcha, 4),\n\t\t0,\n\t \n\tSCR_LOAD_REL (scratcha, 4),\n\t\t4,\n\tSCR_INT_FLY,\n\t\t0,\n\tSCR_STORE_ABS (scratcha, 4),\n\t\tPADDR_B (done_pos),\n} ,{\n\tSCR_JUMP,\n\t\tPADDR_A (start),\n} ,{\n\tSCR_LOAD_ABS (scratcha, 4),\n\t\tPADDR_B (startpos),\n\tSCR_INT,\n\t\tSIR_COMPLETE_ERROR,\n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\t \n\tSCR_REG_REG (HF_REG, SCR_OR, HF_DP_SAVED),\n\t\t0,\n\t \n\tSCR_LOAD_REL (scratcha, 4),\n\t\toffsetof (struct sym_ccb, phys.head.lastp),\n\tSCR_STORE_REL (scratcha, 4),\n\t\toffsetof (struct sym_ccb, phys.head.savep),\n\t \n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_IN)),\n\t\tPADDR_A (msg_in),\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\t \n\tSCR_LOAD_REL  (scratcha, 4),\n\t\toffsetof (struct sym_ccb, phys.head.savep),\n\tSCR_STORE_REL (scratcha, 4),\n\t\toffsetof (struct sym_ccb, phys.head.lastp),\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\t \n\tSCR_WAIT_DISC,\n\t\t0,\n\t \n\tSCR_LOAD_REG (HS_REG, HS_DISCONNECT),\n\t\t0,\n\t \n\tSCR_STORE_REL (scr0, 4),\n\t\toffsetof (struct sym_ccb, phys.head.status),\n\tSCR_JUMP,\n\t\tPADDR_A (start),\n} ,{\n\t \n\tSCR_REG_REG (gpreg, SCR_OR, 0x01),\n\t\t0,\n#ifdef SYM_CONF_IARB_SUPPORT\n\tSCR_JUMPR,\n\t\t8,\n#endif\n} ,{\n#ifdef SYM_CONF_IARB_SUPPORT\n\t \n\tSCR_REG_REG (scntl1, SCR_OR, IARB),\n\t\t0,\n#endif\n\t \n\tSCR_LOAD_REG (dsa, 0xff),\n\t\t0,\n\tSCR_STORE_ABS (scratcha, 4),\n\t\tPADDR_B (startpos),\n} ,{\n#ifdef SYM_CONF_TARGET_ROLE_SUPPORT\n\t \n\tSCR_CLR (SCR_TRG),\n\t\t0,\n#endif\n\t \n\tSCR_WAIT_RESEL,\n\t\tPADDR_A(start),\n} ,{\n\t \n\tSCR_REG_REG (gpreg, SCR_AND, 0xfe),\n\t\t0,\n\t \n\tSCR_REG_SFBR (ssid, SCR_AND, 0x8F),\n\t\t0,\n\tSCR_TO_REG (sdid),\n\t\t0,\n\t \n\tSCR_LOAD_ABS (dsa, 4),\n\t\tPADDR_B (targtbl),\n\tSCR_SFBR_REG (dsa, SCR_SHL, 0),\n\t\t0,\n\tSCR_REG_REG (dsa, SCR_SHL, 0),\n\t\t0,\n\tSCR_REG_REG (dsa, SCR_AND, 0x3c),\n\t\t0,\n\tSCR_LOAD_REL (dsa, 4),\n\t\t0,\n\t \n\tSCR_INT ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tSIR_RESEL_NO_MSG_IN,\n\t \n\tSCR_LOAD_REL (scntl3, 1),\n\t\toffsetof(struct sym_tcb, head.wval),\n\tSCR_LOAD_REL (sxfer, 1),\n\t\toffsetof(struct sym_tcb, head.sval),\n} ,{\n\t \n\tSCR_LOAD_REL (scntl4, 1),\n\t\toffsetof(struct sym_tcb, head.uval),\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tHADDR_1 (msgin),\n\t \n\tSCR_JUMP ^ IFTRUE (MASK (0x80, 0xbf)),\n\t\tPADDR_A (resel_lun0),\n\t \n\tSCR_INT ^ IFFALSE (MASK (0x80, 0x80)),\n\t\tSIR_RESEL_NO_IDENTIFY,\n\t \n\tSCR_LOAD_REL (dsa, 4),\n\t\toffsetof(struct sym_tcb, head.luntbl_sa),\n\tSCR_SFBR_REG (dsa, SCR_SHL, 0),\n\t\t0,\n\tSCR_REG_REG (dsa, SCR_SHL, 0),\n\t\t0,\n\tSCR_REG_REG (dsa, SCR_AND, 0xfc),\n\t\t0,\n\tSCR_LOAD_REL (dsa, 4),\n\t\t0,\n\tSCR_JUMPR,\n\t\t8,\n} ,{\n\t \n\tSCR_LOAD_REL (dsa, 4),\n\t\toffsetof(struct sym_tcb, head.lun0_sa),\n\t \n\tSCR_LOAD_REL (temp, 4),\n\t\toffsetof(struct sym_lcb, head.resel_sa),\n\tSCR_RETURN,\n\t\t0,\n\t \n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\t \n\tSCR_MOVE_ABS (2) ^ SCR_MSG_IN,\n\t\tHADDR_1 (msgin),\n\t \n\tSCR_LOAD_REL (dsa, 4),\n\t\toffsetof(struct sym_lcb, head.itlq_tbl_sa),\n\t \n\tSCR_REG_SFBR (sidl, SCR_SHL, 0),\n\t\t0,\n#if SYM_CONF_MAX_TASK*4 > 512\n\tSCR_JUMPR ^ IFFALSE (CARRYSET),\n\t\t8,\n\tSCR_REG_REG (dsa1, SCR_OR, 2),\n\t\t0,\n\tSCR_REG_REG (sfbr, SCR_SHL, 0),\n\t\t0,\n\tSCR_JUMPR ^ IFFALSE (CARRYSET),\n\t\t8,\n\tSCR_REG_REG (dsa1, SCR_OR, 1),\n\t\t0,\n#elif SYM_CONF_MAX_TASK*4 > 256\n\tSCR_JUMPR ^ IFFALSE (CARRYSET),\n\t\t8,\n\tSCR_REG_REG (dsa1, SCR_OR, 1),\n\t\t0,\n#endif\n\t \n\tSCR_SFBR_REG (dsa, SCR_AND, 0xfc),\n\t\t0,\n\tSCR_LOAD_REL (dsa, 4),\n\t\t0,\n\tSCR_LOAD_REL (temp, 4),\n\t\toffsetof(struct sym_ccb, phys.head.go.restart),\n\tSCR_RETURN,\n\t\t0,\n\t \n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n} ,{\n\t \n\tSCR_LOAD_REL (scr0, 4),\n\t\toffsetof (struct sym_ccb, phys.head.status),\n\t \n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_LOAD_REL (dsa, 4),\n\t\toffsetof(struct sym_lcb, head.itl_task_sa),\n\t \n\tSCR_LOAD_REL (temp, 4),\n\t\toffsetof(struct sym_ccb, phys.head.go.restart),\n\tSCR_RETURN,\n\t\t0,\n\t \n} ,{\n \n0\n} ,{\n\tSCR_CALL,\n\t\tPADDR_A (datai_done),\n\tSCR_JUMP,\n\t\tPADDR_B (data_ovrun),\n} ,{\n \n0\n} ,{\n\tSCR_CALL,\n\t\tPADDR_A (datao_done),\n\tSCR_JUMP,\n\t\tPADDR_B (data_ovrun),\n} ,{\n\t \n\tSCR_FROM_REG (HF_REG),\n\t\t0,\n\t \n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN)),\n\t\tPADDR_A (pm0_data_out),\n\t \n\tSCR_JUMP ^ IFFALSE (MASK (HF_DATA_IN, HF_DATA_IN)),\n\t\tPADDR_B (data_ovrun),\n\t \n\tSCR_REG_REG (HF_REG, SCR_OR, HF_IN_PM0),\n\t\t0,\n\t \n\tSCR_CHMOV_TBL ^ SCR_DATA_IN,\n\t\toffsetof (struct sym_ccb, phys.pm0.sg),\n\tSCR_JUMP,\n\t\tPADDR_A (pm0_data_end),\n} ,{\n\t \n\tSCR_JUMP ^ IFTRUE (MASK (HF_DATA_IN, HF_DATA_IN)),\n\t\tPADDR_B (data_ovrun),\n\t \n\tSCR_REG_REG (HF_REG, SCR_OR, HF_IN_PM0),\n\t\t0,\n\t \n\tSCR_CHMOV_TBL ^ SCR_DATA_OUT,\n\t\toffsetof (struct sym_ccb, phys.pm0.sg),\n} ,{\n\t \n\tSCR_REG_REG (HF_REG, SCR_AND, (~HF_IN_PM0)),\n\t\t0,\n\t \n\tSCR_LOAD_REL (temp, 4),\n\t\toffsetof (struct sym_ccb, phys.pm0.ret),\n\tSCR_RETURN,\n\t\t0,\n} ,{\n\t \n\tSCR_FROM_REG (HF_REG),\n\t\t0,\n\t \n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN)),\n\t\tPADDR_A (pm1_data_out),\n\t \n\tSCR_JUMP ^ IFFALSE (MASK (HF_DATA_IN, HF_DATA_IN)),\n\t\tPADDR_B (data_ovrun),\n\t \n\tSCR_REG_REG (HF_REG, SCR_OR, HF_IN_PM1),\n\t\t0,\n\t \n\tSCR_CHMOV_TBL ^ SCR_DATA_IN,\n\t\toffsetof (struct sym_ccb, phys.pm1.sg),\n\tSCR_JUMP,\n\t\tPADDR_A (pm1_data_end),\n} ,{\n\t \n\tSCR_JUMP ^ IFTRUE (MASK (HF_DATA_IN, HF_DATA_IN)),\n\t\tPADDR_B (data_ovrun),\n\t \n\tSCR_REG_REG (HF_REG, SCR_OR, HF_IN_PM1),\n\t\t0,\n\t \n\tSCR_CHMOV_TBL ^ SCR_DATA_OUT,\n\t\toffsetof (struct sym_ccb, phys.pm1.sg),\n} ,{\n\t \n\tSCR_REG_REG (HF_REG, SCR_AND, (~HF_IN_PM1)),\n\t\t0,\n\t \n\tSCR_LOAD_REL (temp, 4),\n\t\toffsetof (struct sym_ccb, phys.pm1.ret),\n\tSCR_RETURN,\n\t\t0,\n} \n};\n\nstatic struct SYM_FWB_SCR SYM_FWB_SCR = {\n  {\n\t \n\tSCR_JUMP,\n\t\tPADDR_A (init),\n} ,{\n\tSCR_JUMP,\n\t\tPADDR_B (data_ovrun),\n} ,{\n\t \n#ifdef SYM_CONF_TARGET_ROLE_SUPPORT\n\t \n\tSCR_CLR (SCR_TRG),\n\t\t0,\n#endif\n\t \n\tSCR_SEL_TBL_ATN ^ offsetof (struct sym_hcb, abrt_sel),\n\t\tPADDR_A (reselect),\n\t \n\tSCR_JUMPR ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\t-8,\n\t \n\tSCR_INT,\n\t\tSIR_TARGET_SELECTED,\n\t \n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\tSCR_MOVE_TBL ^ SCR_MSG_OUT,\n\t\toffsetof (struct sym_hcb, abrt_tbl),\n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\tSCR_WAIT_DISC,\n\t\t0,\n\t \n\tSCR_INT,\n\t\tSIR_ABORT_SENT,\n} ,{\n\t \n\tSCR_JUMP,\n\t\tPADDR_A (start),\n} ,{\n\t \n\tSCR_JUMP ^ IFTRUE (DATA (M_EXTENDED)),\n\t\tPADDR_B (msg_extended),\n\t \n\tSCR_JUMP ^ IFTRUE (MASK (0x00, 0xf0)),\n\t\tPADDR_B (msg_received),\n\tSCR_JUMP ^ IFTRUE (MASK (0x10, 0xf0)),\n\t\tPADDR_B (msg_received),\n\t \n\tSCR_JUMP ^ IFFALSE (MASK (0x20, 0xf0)),\n\t\tPADDR_B (msg_weird_seen),\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tHADDR_1 (msgin[1]),\n} ,{\n\tSCR_LOAD_REL (scratcha, 4),\t \n\t\t0,\n\tSCR_INT,\n\t\tSIR_MSG_RECEIVED,\n} ,{\n\tSCR_LOAD_REL (scratcha, 4),\t \n\t\t0,\n\tSCR_INT,\n\t\tSIR_MSG_WEIRD,\n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tHADDR_1 (msgin[1]),\n\t \n\tSCR_JUMP ^ IFTRUE (DATA (0)),\n\t\tPADDR_B (msg_weird_seen),\n\tSCR_TO_REG (scratcha),\n\t\t0,\n\tSCR_REG_REG (sfbr, SCR_ADD, (256-8)),\n\t\t0,\n\tSCR_JUMP ^ IFTRUE (CARRYSET),\n\t\tPADDR_B (msg_weird_seen),\n\t \n\tSCR_STORE_REL (scratcha, 1),\n\t\toffsetof (struct sym_dsb, smsg_ext.size),\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_MOVE_TBL ^ SCR_MSG_IN,\n\t\toffsetof (struct sym_dsb, smsg_ext),\n\tSCR_JUMP,\n\t\tPADDR_B (msg_received),\n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_REJECT_TO_SEND,\n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR_A (clrack),\n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_REJECT_TO_SEND,\n\tSCR_SET (SCR_ATN),\n\t\t0,\n} ,{\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR_A (dispatch),\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tHADDR_1 (scratch),\n\tSCR_JUMP,\n\t\tPADDR_B (msg_weird1),\n} ,{\n\t \n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\tPADDR_B (nego_bad_phase),\n} ,{\n\t \n\tSCR_MOVE_ABS (4) ^ SCR_MSG_OUT,\n\t\tHADDR_1 (msgout),\n\tSCR_JUMP,\n\t\tPADDR_B (msg_out_done),\n} ,{\n\t \n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\tPADDR_B (nego_bad_phase),\n} ,{\n\t \n\tSCR_MOVE_ABS (5) ^ SCR_MSG_OUT,\n\t\tHADDR_1 (msgout),\n\tSCR_JUMP,\n\t\tPADDR_B (msg_out_done),\n} ,{\n\t \n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\tPADDR_B (nego_bad_phase),\n} ,{\n\t \n\tSCR_MOVE_ABS (8) ^ SCR_MSG_OUT,\n\t\tHADDR_1 (msgout),\n\tSCR_JUMP,\n\t\tPADDR_B (msg_out_done),\n} ,{\n\tSCR_INT,\n\t\tSIR_NEGO_PROTO,\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_OUT,\n\t\tHADDR_1 (msgout),\n\t \n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_OUT)),\n\t\tPADDR_B (msg_out),\n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_MSG_OUT_DONE,\n\t \n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_LOAD_ABS (scratcha, 4),\n\t\tPADDR_B (zero),\n} ,{\n\t \n\tSCR_JUMPR ^ IFFALSE (WHEN (SCR_DATA_OUT)),\n\t\t16,\n\tSCR_CHMOV_ABS (1) ^ SCR_DATA_OUT,\n\t\tHADDR_1 (scratch),\n\tSCR_JUMP,\n\t\tPADDR_B (data_ovrun2),\n\t \n\tSCR_FROM_REG (scntl2),\n\t\t0,\n\tSCR_JUMPR ^ IFFALSE (MASK (WSR, WSR)),\n\t\t16,\n\tSCR_REG_REG (scntl2, SCR_OR, WSR),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR_B (data_ovrun2),\n\t \n\tSCR_JUMPR ^ IFTRUE (WHEN (SCR_DATA_IN)),\n\t\t16,\n\tSCR_INT,\n\t\tSIR_DATA_OVERRUN,\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n\tSCR_CHMOV_ABS (1) ^ SCR_DATA_IN,\n\t\tHADDR_1 (scratch),\n} ,{\n\t \n\tSCR_REG_REG (scratcha,  SCR_ADD,  0x01),\n\t\t0,\n\tSCR_REG_REG (scratcha1, SCR_ADDC, 0),\n\t\t0,\n\tSCR_REG_REG (scratcha2, SCR_ADDC, 0),\n\t\t0,\n\t \n\tSCR_JUMP,\n\t\tPADDR_B (data_ovrun1),\n} ,{\n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\t \n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_OUT,\n\t\tHADDR_1 (msgout),\n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\tSCR_WAIT_DISC,\n\t\t0,\n\tSCR_INT,\n\t\tSIR_RESEL_ABORTED,\n\tSCR_JUMP,\n\t\tPADDR_A (start),\n} ,{\n\t \n\tSCR_SET (SCR_ATN),  \n\t\t0,          \n\tSCR_JUMP,\n\t\tPADDR_A (send_ident),\n} ,{\n\tSCR_CLR (SCR_ATN),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR_A (select2),\n} ,{\n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR_A (select2),\n} ,{\n\tSCR_CHMOV_TBL ^ SCR_DATA_IN,\n\t\toffsetof (struct sym_dsb, sense),\n\tSCR_CALL,\n\t\tPADDR_A (datai_done),\n\tSCR_JUMP,\n\t\tPADDR_B (data_ovrun),\n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_RESEL_BAD_LUN,\n\tSCR_JUMP,\n\t\tPADDR_B (abort_resel),\n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_RESEL_BAD_I_T_L,\n\tSCR_JUMP,\n\t\tPADDR_B (abort_resel),\n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_RESEL_BAD_I_T_L_Q,\n\tSCR_JUMP,\n\t\tPADDR_B (abort_resel),\n} ,{\n\t \n\tSCR_LOAD_ABS (scratcha, 4),\n\t\tPADDR_B (startpos),\n\tSCR_INT ^ IFFALSE (DATA (S_COND_MET)),\n\t\tSIR_BAD_SCSI_STATUS,\n\tSCR_RETURN,\n\t\t0,\n} ,{\n\t \n\t \n\tSCR_FROM_REG (HF_REG),\n\t\t0,\n\t \n\tSCR_JUMP ^ IFTRUE (MASK (0, (HF_IN_PM0 | HF_IN_PM1 | HF_DP_SAVED))),\n\t\tPADDR_B (pm_handle1),\n\t \n\tSCR_JUMPR ^ IFFALSE (MASK (HF_DP_SAVED, HF_DP_SAVED)),\n\t\t8,\n\tSCR_REG_REG (sfbr, SCR_XOR, HF_ACT_PM),\n\t\t0,\n\t \n\tSCR_JUMP ^ IFTRUE (MASK (0, (HF_IN_PM0 | HF_IN_PM1))),\n\t\tPADDR_B (pm_handle1),\n\tSCR_JUMPR ^ IFFALSE (MASK (HF_IN_PM0, HF_IN_PM0)),\n\t\t16,\n\tSCR_LOAD_REL (ia, 4),\n\t\toffsetof(struct sym_ccb, phys.pm0.ret),\n\tSCR_JUMP,\n\t\tPADDR_B (pm_save),\n\tSCR_LOAD_REL (ia, 4),\n\t\toffsetof(struct sym_ccb, phys.pm1.ret),\n\tSCR_JUMP,\n\t\tPADDR_B (pm_save),\n} ,{\n\t \n\tSCR_REG_REG (ia, SCR_ADD, 8),\n\t\t0,\n\tSCR_REG_REG (ia1, SCR_ADDC, 0),\n\t\t0,\n} ,{\n\t \n\tSCR_SFBR_REG (HF_REG, SCR_AND, (~(HF_IN_PM0|HF_IN_PM1|HF_DP_SAVED))),\n\t\t0,\n\t \n\tSCR_JUMP ^ IFTRUE (MASK (HF_ACT_PM, HF_ACT_PM)),\n\t\tPADDR_B (pm1_save),\n} ,{\n\tSCR_STORE_REL (ia, 4),\n\t\toffsetof(struct sym_ccb, phys.pm0.ret),\n\t \n\tSCR_FROM_REG (scntl2),\n\t\t0,\n\tSCR_CALL ^ IFTRUE (MASK (WSR, WSR)),\n\t\tPADDR_B (pm_wsr_handle),\n\t \n\tSCR_STORE_REL (rbc, 4),\n\t\toffsetof(struct sym_ccb, phys.pm0.sg.size),\n\tSCR_STORE_REL (ua, 4),\n\t\toffsetof(struct sym_ccb, phys.pm0.sg.addr),\n\t \n\tSCR_LOAD_ABS (ia, 4),\n\t\tPADDR_B (pm0_data_addr),\n} ,{\n\tSCR_STORE_REL (ia, 4),\n\t\toffsetof(struct sym_ccb, phys.head.lastp),\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\tSCR_STORE_REL (ia, 4),\n\t\toffsetof(struct sym_ccb, phys.pm1.ret),\n\t \n\tSCR_FROM_REG (scntl2),\n\t\t0,\n\tSCR_CALL ^ IFTRUE (MASK (WSR, WSR)),\n\t\tPADDR_B (pm_wsr_handle),\n\t \n\tSCR_STORE_REL (rbc, 4),\n\t\toffsetof(struct sym_ccb, phys.pm1.sg.size),\n\tSCR_STORE_REL (ua, 4),\n\t\toffsetof(struct sym_ccb, phys.pm1.sg.addr),\n\t \n\tSCR_LOAD_ABS (ia, 4),\n\t\tPADDR_B (pm1_data_addr),\n\tSCR_JUMP,\n\t\tPADDR_B (pm_save_end),\n} ,{\n\t \n\tSCR_STORE_REL (ua, 4),\n\t\toffsetof (struct sym_ccb, phys.wresid.addr),\n\t \n\tSCR_REG_REG (ua, SCR_ADD, 1),\n\t\t0,\n\tSCR_REG_REG (ua1, SCR_ADDC, 0),\n\t\t0,\n\tSCR_REG_REG (ua2, SCR_ADDC, 0),\n\t\t0,\n\tSCR_REG_REG (ua3, SCR_ADDC, 0),\n\t\t0,\n\t \n\tSCR_LOAD_ABS (scratcha, 4),\n\t\tPADDR_B (zero),\n\tSCR_REG_REG (scratcha, SCR_OR, 1),\n\t\t0,\n\tSCR_FROM_REG (rbc3),\n\t\t0,\n\tSCR_TO_REG (scratcha3),\n\t\t0,\n\t \n\tSCR_STORE_REL (scratcha, 4),\n\t\toffsetof (struct sym_ccb, phys.wresid.size),\n\t \n\tSCR_JUMPR ^ IFFALSE (WHEN (SCR_DATA_IN)),\n\t\t0,\n\t \n\tSCR_CHMOV_TBL ^ SCR_DATA_IN,\n\t\toffsetof (struct sym_ccb, phys.wresid),\n\t \n\tSCR_FROM_REG (rbc),\n\t\t0,\n\tSCR_RETURN ^ IFFALSE (DATA (0)),\n\t\t0,\n\tSCR_FROM_REG (rbc1),\n\t\t0,\n\tSCR_RETURN ^ IFFALSE (DATA (0)),\n\t\t0,\n\tSCR_FROM_REG (rbc2),\n\t\t0,\n\tSCR_RETURN ^ IFFALSE (DATA (0)),\n\t\t0,\n\t \n\tSCR_JUMP,\n\t\tPADDR_B (pm_save_end),\n} ,{\n\t \n\tSCR_CHMOV_TBL ^ SCR_DATA_IN,\n\t\toffsetof (struct sym_ccb, phys.wresid),\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n\n} ,{\n\tSCR_DATA_ZERO,\n} ,{\n\tSCR_DATA_ZERO,\n} ,{\n\tSCR_DATA_ZERO,\n} ,{\n\tSCR_DATA_ZERO,\n} ,{\n\tSCR_DATA_ZERO,\n} ,{\n\tSCR_DATA_ZERO,\n} ,{\n\tSCR_DATA_ZERO,\n} \n};\n\nstatic struct SYM_FWZ_SCR SYM_FWZ_SCR = {\n  {\n\t \n\tSCR_LOAD_REL (scratcha, 4),\n\t\toffsetof(struct sym_hcb, scratch),\n\t \n\tSCR_STORE_REL (temp, 4),\n\t\toffsetof(struct sym_hcb, scratch),\n\t \n\tSCR_LOAD_REL (temp, 4),\n\t\toffsetof(struct sym_hcb, scratch),\n} ,{\n\t \n\tSCR_INT,\n\t\t99,\n} \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}