{
  "module_name": "sym_fw1.h",
  "hash_id": "c9698294739df913ac0204c2ec13cd92c86548ab4410cdb3addb2c8d3917685d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sym53c8xx_2/sym_fw1.h",
  "human_readable_source": " \n \n\n \n\n \nstruct SYM_FWA_SCR {\n\tu32 start\t\t[ 11];\n\tu32 getjob_begin\t[  4];\n\tu32 _sms_a10\t\t[  5];\n\tu32 getjob_end\t\t[  4];\n\tu32 _sms_a20\t\t[  4];\n#ifdef SYM_CONF_TARGET_ROLE_SUPPORT\n\tu32 select\t\t[  8];\n#else\n\tu32 select\t\t[  6];\n#endif\n\tu32 _sms_a30\t\t[  5];\n\tu32 wf_sel_done\t\t[  2];\n\tu32 send_ident\t\t[  2];\n#ifdef SYM_CONF_IARB_SUPPORT\n\tu32 select2\t\t[  8];\n#else\n\tu32 select2\t\t[  2];\n#endif\n\tu32 command\t\t[  2];\n\tu32 dispatch\t\t[ 28];\n\tu32 sel_no_cmd\t\t[ 10];\n\tu32 init\t\t[  6];\n\tu32 clrack\t\t[  4];\n\tu32 datai_done\t\t[ 11];\n\tu32 datai_done_wsr\t[ 20];\n\tu32 datao_done\t\t[ 11];\n\tu32 datao_done_wss\t[  6];\n\tu32 datai_phase\t\t[  5];\n\tu32 datao_phase\t\t[  5];\n\tu32 msg_in\t\t[  2];\n\tu32 msg_in2\t\t[ 10];\n#ifdef SYM_CONF_IARB_SUPPORT\n\tu32 status\t\t[ 14];\n#else\n\tu32 status\t\t[ 10];\n#endif\n\tu32 complete\t\t[  6];\n\tu32 complete2\t\t[  8];\n\tu32 _sms_a40\t\t[ 12];\n\tu32 done\t\t[  5];\n\tu32 _sms_a50\t\t[  5];\n\tu32 _sms_a60\t\t[  2];\n\tu32 done_end\t\t[  4];\n\tu32 complete_error\t[  5];\n\tu32 save_dp\t\t[ 11];\n\tu32 restore_dp\t\t[  7];\n\tu32 disconnect\t\t[ 11];\n\tu32 disconnect2\t\t[  5];\n\tu32 _sms_a65\t\t[  3];\n#ifdef SYM_CONF_IARB_SUPPORT\n\tu32 idle\t\t[  4];\n#else\n\tu32 idle\t\t[  2];\n#endif\n#ifdef SYM_CONF_IARB_SUPPORT\n\tu32 ungetjob\t\t[  7];\n#else\n\tu32 ungetjob\t\t[  5];\n#endif\n#ifdef SYM_CONF_TARGET_ROLE_SUPPORT\n\tu32 reselect\t\t[  4];\n#else\n\tu32 reselect\t\t[  2];\n#endif\n\tu32 reselected\t\t[ 19];\n\tu32 _sms_a70\t\t[  6];\n\tu32 _sms_a80\t\t[  4];\n\tu32 reselected1\t\t[ 25];\n\tu32 _sms_a90\t\t[  4];\n\tu32 resel_lun0\t\t[  7];\n\tu32 _sms_a100\t\t[  4];\n\tu32 resel_tag\t\t[  8];\n#if   SYM_CONF_MAX_TASK*4 > 512\n\tu32 _sms_a110\t\t[ 23];\n#elif SYM_CONF_MAX_TASK*4 > 256\n\tu32 _sms_a110\t\t[ 17];\n#else\n\tu32 _sms_a110\t\t[ 13];\n#endif\n\tu32 _sms_a120\t\t[  2];\n\tu32 resel_go\t\t[  4];\n\tu32 _sms_a130\t\t[  7];\n\tu32 resel_dsa\t\t[  2];\n\tu32 resel_dsa1\t\t[  4];\n\tu32 _sms_a140\t\t[  7];\n\tu32 resel_no_tag\t[  4];\n\tu32 _sms_a145\t\t[  7];\n\tu32 data_in\t\t[SYM_CONF_MAX_SG * 2];\n\tu32 data_in2\t\t[  4];\n\tu32 data_out\t\t[SYM_CONF_MAX_SG * 2];\n\tu32 data_out2\t\t[  4];\n\tu32 pm0_data\t\t[ 12];\n\tu32 pm0_data_out\t[  6];\n\tu32 pm0_data_end\t[  7];\n\tu32 pm_data_end\t\t[  4];\n\tu32 _sms_a150\t\t[  4];\n\tu32 pm1_data\t\t[ 12];\n\tu32 pm1_data_out\t[  6];\n\tu32 pm1_data_end\t[  9];\n};\n\n \nstruct SYM_FWB_SCR {\n\tu32 no_data\t\t[  2];\n#ifdef SYM_CONF_TARGET_ROLE_SUPPORT\n\tu32 sel_for_abort\t[ 18];\n#else\n\tu32 sel_for_abort\t[ 16];\n#endif\n\tu32 sel_for_abort_1\t[  2];\n\tu32 msg_in_etc\t\t[ 12];\n\tu32 msg_received\t[  5];\n\tu32 msg_weird_seen\t[  5];\n\tu32 msg_extended\t[ 17];\n\tu32 _sms_b10\t\t[  4];\n\tu32 msg_bad\t\t[  6];\n\tu32 msg_weird\t\t[  4];\n\tu32 msg_weird1\t\t[  8];\n\tu32 wdtr_resp\t\t[  6];\n\tu32 send_wdtr\t\t[  4];\n\tu32 sdtr_resp\t\t[  6];\n\tu32 send_sdtr\t\t[  4];\n\tu32 ppr_resp\t\t[  6];\n\tu32 send_ppr\t\t[  4];\n\tu32 nego_bad_phase\t[  4];\n\tu32 msg_out\t\t[  4];\n\tu32 msg_out_done\t[  4];\n\tu32 data_ovrun\t\t[  3];\n\tu32 data_ovrun1\t\t[ 22];\n\tu32 data_ovrun2\t\t[  8];\n\tu32 abort_resel\t\t[ 16];\n\tu32 resend_ident\t[  4];\n\tu32 ident_break\t\t[  4];\n\tu32 ident_break_atn\t[  4];\n\tu32 sdata_in\t\t[  6];\n\tu32 resel_bad_lun\t[  4];\n\tu32 bad_i_t_l\t\t[  4];\n\tu32 bad_i_t_l_q\t\t[  4];\n\tu32 bad_status\t\t[  7];\n\tu32 wsr_ma_helper\t[  4];\n\n\t \n\tu32 zero\t\t[  1];\n\tu32 scratch\t\t[  1];\n\tu32 scratch1\t\t[  1];\n\tu32 prev_done\t\t[  1];\n\tu32 done_pos\t\t[  1];\n\tu32 nextjob\t\t[  1];\n\tu32 startpos\t\t[  1];\n\tu32 targtbl\t\t[  1];\n};\n\n \nstruct SYM_FWZ_SCR {\n\tu32 snooptest\t\t[  9];\n\tu32 snoopend\t\t[  2];\n};\n\nstatic struct SYM_FWA_SCR SYM_FWA_SCR = {\n  {\n\t \n\tSCR_REG_REG (gpreg, SCR_AND, 0xfe),\n\t\t0,\n\t \n\tSCR_FROM_REG (ctest2),\n\t\t0,\n\t \n\tSCR_FROM_REG (istat),\n\t\t0,\n\t \n\tSCR_COPY (4),\n\t\tPADDR_B (startpos),\n\t\tRADDR_1 (scratcha),\n\tSCR_INT ^ IFTRUE (MASK (SEM, SEM)),\n\t\tSIR_SCRIPT_STOPPED,\n\t \n} ,{\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (scratcha),\n\t\tPADDR_A (_sms_a10),\n\tSCR_COPY (8),\n} ,{\n\t\t0,\n\t\tPADDR_B (nextjob),\n\t \n\tSCR_COPY (4),\n\t\tPADDR_B (nextjob),\n\t\tRADDR_1 (dsa),\n} ,{\n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n\t\tPADDR_A (_sms_a20),\n\tSCR_COPY (4),\n} ,{\n\t\t0,\n\t\tRADDR_1 (temp),\n\tSCR_RETURN,\n\t\t0,\n} ,{\n\t \n#ifdef SYM_CONF_TARGET_ROLE_SUPPORT\n\tSCR_CLR (SCR_TRG),\n\t\t0,\n#endif\n\t \n\tSCR_SEL_TBL_ATN ^ offsetof (struct sym_dsb, select),\n\t\tPADDR_A (ungetjob),\n\t \n\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n\t\tPADDR_A (_sms_a30),\n\tSCR_COPY (sizeof(struct sym_ccbh)),\n} ,{\n\t\t0,\n\t\tHADDR_1 (ccb_head),\n\t \n\tSCR_COPY (4),\n\t\tHADDR_1 (ccb_head.status),\n\t\tRADDR_1 (scr0),\n} ,{\n\tSCR_INT ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\tSIR_SEL_ATN_NO_MSG_OUT,\n} ,{\n\t \n\tSCR_MOVE_TBL ^ SCR_MSG_OUT,\n\t\toffsetof (struct sym_dsb, smsg),\n} ,{\n#ifdef SYM_CONF_IARB_SUPPORT\n\t \n\tSCR_FROM_REG (HF_REG),\n\t\t0,\n\tSCR_JUMPR ^ IFFALSE (MASK (HF_HINT_IARB, HF_HINT_IARB)),\n\t\t8,\n\tSCR_REG_REG (scntl1, SCR_OR, IARB),\n\t\t0,\n#endif\n\t \n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_COMMAND)),\n\t\tPADDR_A (sel_no_cmd),\n} ,{\n\t \n\tSCR_MOVE_TBL ^ SCR_COMMAND,\n\t\toffsetof (struct sym_dsb, cmd),\n} ,{\n\t \n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_IN)),\n\t\tPADDR_A (msg_in),\n\tSCR_JUMP ^ IFTRUE (IF (SCR_DATA_OUT)),\n\t\tPADDR_A (datao_phase),\n\tSCR_JUMP ^ IFTRUE (IF (SCR_DATA_IN)),\n\t\tPADDR_A (datai_phase),\n\tSCR_JUMP ^ IFTRUE (IF (SCR_STATUS)),\n\t\tPADDR_A (status),\n\tSCR_JUMP ^ IFTRUE (IF (SCR_COMMAND)),\n\t\tPADDR_A (command),\n\tSCR_JUMP ^ IFTRUE (IF (SCR_MSG_OUT)),\n\t\tPADDR_B (msg_out),\n\t \n\tSCR_JUMPR ^ IFFALSE (WHEN (SCR_ILG_OUT)),\n\t\t16,\n\tSCR_MOVE_ABS (1) ^ SCR_ILG_OUT,\n\t\tHADDR_1 (scratch),\n\tSCR_JUMPR ^ IFTRUE (WHEN (SCR_ILG_OUT)),\n\t\t-16,\n\tSCR_JUMPR ^ IFFALSE (WHEN (SCR_ILG_IN)),\n\t\t16,\n\tSCR_MOVE_ABS (1) ^ SCR_ILG_IN,\n\t\tHADDR_1 (scratch),\n\tSCR_JUMPR ^ IFTRUE (WHEN (SCR_ILG_IN)),\n\t\t-16,\n\tSCR_INT,\n\t\tSIR_BAD_PHASE,\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_OUT)),\n\t\tPADDR_B (resend_ident),\n\t \n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_IN)),\n\t\tPADDR_A (dispatch),\n\tSCR_FROM_REG (HS_REG),\n\t\t0,\n\tSCR_INT ^ IFTRUE (DATA (HS_NEGOTIATE)),\n\t\tSIR_NEGO_FAILED,\n\t \n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_FROM_REG (sstat0),\n\t\t0,\n\tSCR_JUMPR ^ IFTRUE (MASK (IRST, IRST)),\n\t\t-16,\n\tSCR_JUMP,\n\t\tPADDR_A (start),\n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (temp),\n\t\tHADDR_1 (ccb_head.lastp),\n\t \n\tSCR_FROM_REG (scntl2),\n\t\t0,\n\tSCR_JUMP ^ IFTRUE (MASK (WSR, WSR)),\n\t\tPADDR_A (datai_done_wsr),\n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_STATUS)),\n\t\tPADDR_A (status),\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_REG_REG (scntl2, SCR_OR, WSR),\n\t\t0,\n\t \n\tSCR_INT ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tSIR_SWIDE_OVERRUN,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR_A (dispatch),\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tHADDR_1 (msgin[0]),\n\tSCR_INT ^ IFFALSE (DATA (M_IGN_RESIDUE)),\n\t\tSIR_SWIDE_OVERRUN,\n\tSCR_JUMP ^ IFFALSE (DATA (M_IGN_RESIDUE)),\n\t\tPADDR_A (msg_in2),\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tHADDR_1 (msgin[1]),\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (temp),\n\t\tHADDR_1 (ccb_head.lastp),\n\t \n\tSCR_FROM_REG (scntl2),\n\t\t0,\n\tSCR_JUMP ^ IFTRUE (MASK (WSS, WSS)),\n\t\tPADDR_A (datao_done_wss),\n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_STATUS)),\n\t\tPADDR_A (status),\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_REG_REG (scntl2, SCR_OR, WSS),\n\t\t0,\n\t \n\tSCR_INT,\n\t\tSIR_SODL_UNDERRUN,\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tHADDR_1 (ccb_head.lastp),\n\t\tRADDR_1 (temp),\n\tSCR_RETURN,\n\t\t0,\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tHADDR_1 (ccb_head.lastp),\n\t\tRADDR_1 (temp),\n\tSCR_RETURN,\n\t\t0,\n} ,{\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tHADDR_1 (msgin[0]),\n} ,{\n\t \n\tSCR_JUMP ^ IFTRUE (DATA (M_COMPLETE)),\n\t\tPADDR_A (complete),\n\tSCR_JUMP ^ IFTRUE (DATA (M_DISCONNECT)),\n\t\tPADDR_A (disconnect),\n\tSCR_JUMP ^ IFTRUE (DATA (M_SAVE_DP)),\n\t\tPADDR_A (save_dp),\n\tSCR_JUMP ^ IFTRUE (DATA (M_RESTORE_DP)),\n\t\tPADDR_A (restore_dp),\n\t \n\tSCR_JUMP,\n\t\tPADDR_B (msg_in_etc),\n} ,{\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_STATUS,\n\t\tHADDR_1 (scratch),\n#ifdef SYM_CONF_IARB_SUPPORT\n\t \n\tSCR_JUMPR ^ IFTRUE (DATA (S_GOOD)),\n\t\t8,\n\tSCR_REG_REG (scntl1, SCR_AND, ~IARB),\n\t\t0,\n#endif\n\t \n\tSCR_TO_REG (SS_REG),\n\t\t0,\n\tSCR_LOAD_REG (HS_REG, HS_COMPLETE),\n\t\t0,\n\t \n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_IN)),\n\t\tPADDR_A (msg_in),\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\t \n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\t \n\tSCR_WAIT_DISC,\n\t\t0,\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (scr0),\n\t\tHADDR_1 (ccb_head.status),\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n\t\tPADDR_A (_sms_a40),\n\tSCR_COPY (sizeof(struct sym_ccbh)),\n\t\tHADDR_1 (ccb_head),\n} ,{\n\t\t0,\n\t \n\tSCR_COPY (4),\t\t\t \n\t\tHADDR_1 (ccb_head.status),\n\t\tRADDR_1 (scr0),\n\t \n\tSCR_FROM_REG (SS_REG),\n\t\t0,\n\tSCR_CALL ^ IFFALSE (DATA (S_GOOD)),\n\t\tPADDR_B (bad_status),\n\t \n\tSCR_FROM_REG (HF_REG),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (MASK (0 ,(HF_SENSE|HF_EXT_ERR))),\n\t\tPADDR_A (complete_error),\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tPADDR_B (done_pos),\n\t\tPADDR_A (_sms_a50),\n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n} ,{\n\t\t0,\n\tSCR_COPY (4),\n\t\tPADDR_B (done_pos),\n\t\tPADDR_A (_sms_a60),\n\t \n\tSCR_COPY (8),\n} ,{\n\t\t0,\n\t\tPADDR_B (prev_done),\n} ,{\n\tSCR_INT_FLY,\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR_A (start),\n} ,{\n\tSCR_COPY (4),\n\t\tPADDR_B (startpos),\n\t\tRADDR_1 (scratcha),\n\tSCR_INT,\n\t\tSIR_COMPLETE_ERROR,\n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\t \n\tSCR_REG_REG (HF_REG, SCR_OR, HF_DP_SAVED),\n\t\t0,\n\t \n\tSCR_COPY (4),\n\t\tHADDR_1 (ccb_head.lastp),\n\t\tHADDR_1 (ccb_head.savep),\n\t \n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_IN)),\n\t\tPADDR_A (msg_in),\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\t \n\tSCR_COPY (4),\n\t\tHADDR_1 (ccb_head.savep),\n\t\tHADDR_1 (ccb_head.lastp),\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\t \n\tSCR_WAIT_DISC,\n\t\t0,\n\t \n\tSCR_LOAD_REG (HS_REG, HS_DISCONNECT),\n\t\t0,\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (scr0),\n\t\tHADDR_1 (ccb_head.status),\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n\t\tPADDR_A (_sms_a65),\n\tSCR_COPY (sizeof(struct sym_ccbh)),\n\t\tHADDR_1 (ccb_head),\n} ,{\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR_A (start),\n} ,{\n\t \n\tSCR_REG_REG (gpreg, SCR_OR, 0x01),\n\t\t0,\n#ifdef SYM_CONF_IARB_SUPPORT\n\tSCR_JUMPR,\n\t\t8,\n#endif\n} ,{\n#ifdef SYM_CONF_IARB_SUPPORT\n\t \n\tSCR_REG_REG (scntl1, SCR_OR, IARB),\n\t\t0,\n#endif\n\t \n\tSCR_LOAD_REG (dsa, 0xff),\n\t\t0,\n\tSCR_COPY (4),\n\t\tRADDR_1 (scratcha),\n\t\tPADDR_B (startpos),\n} ,{\n#ifdef SYM_CONF_TARGET_ROLE_SUPPORT\n\t \n\tSCR_CLR (SCR_TRG),\n\t\t0,\n#endif\n\t \n\tSCR_WAIT_RESEL,\n\t\tPADDR_A(start),\n} ,{\n\t \n\tSCR_REG_REG (gpreg, SCR_AND, 0xfe),\n\t\t0,\n\t \n\tSCR_REG_SFBR (ssid, SCR_AND, 0x8F),\n\t\t0,\n\tSCR_TO_REG (sdid),\n\t\t0,\n\t \n\tSCR_COPY (4),\n\t\tPADDR_B (targtbl),\n\t\tRADDR_1 (dsa),\n\tSCR_SFBR_REG (dsa, SCR_SHL, 0),\n\t\t0,\n\tSCR_REG_REG (dsa, SCR_SHL, 0),\n\t\t0,\n\tSCR_REG_REG (dsa, SCR_AND, 0x3c),\n\t\t0,\n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n\t\tPADDR_A (_sms_a70),\n\tSCR_COPY (4),\n} ,{\n\t\t0,\n\t\tRADDR_1 (dsa),\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n\t\tPADDR_A (_sms_a80),\n\tSCR_COPY (sizeof(struct sym_tcbh)),\n} ,{\n\t\t0,\n\t\tHADDR_1 (tcb_head),\n\t \n\tSCR_INT ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tSIR_RESEL_NO_MSG_IN,\n} ,{\n\t \n\tSCR_COPY (1),\n\t\tHADDR_1 (tcb_head.wval),\n\t\tRADDR_1 (scntl3),\n\tSCR_COPY (1),\n\t\tHADDR_1 (tcb_head.sval),\n\t\tRADDR_1 (sxfer),\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tHADDR_1 (msgin),\n\t \n\tSCR_JUMP ^ IFTRUE (MASK (0x80, 0xbf)),\n\t\tPADDR_A (resel_lun0),\n\t \n\tSCR_INT ^ IFFALSE (MASK (0x80, 0x80)),\n\t\tSIR_RESEL_NO_IDENTIFY,\n\t \n\tSCR_COPY (4),\n\t\tHADDR_1 (tcb_head.luntbl_sa),\n\t\tRADDR_1 (dsa),\n\tSCR_SFBR_REG (dsa, SCR_SHL, 0),\n\t\t0,\n\tSCR_REG_REG (dsa, SCR_SHL, 0),\n\t\t0,\n\tSCR_REG_REG (dsa, SCR_AND, 0xfc),\n\t\t0,\n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n\t\tPADDR_A (_sms_a90),\n\tSCR_COPY (4),\n} ,{\n\t\t0,\n\t\tRADDR_1 (dsa),\n\tSCR_JUMPR,\n\t\t12,\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tHADDR_1 (tcb_head.lun0_sa),\n\t\tRADDR_1 (dsa),\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n\t\tPADDR_A (_sms_a100),\n\tSCR_COPY (4),\n} ,{\n\t\t0,\n\t\tRADDR_1 (temp),\n\tSCR_RETURN,\n\t\t0,\n\t \n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\t \n\tSCR_MOVE_ABS (2) ^ SCR_MSG_IN,\n\t\tHADDR_1 (msgin),\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n\t\tPADDR_A (_sms_a110),\n\tSCR_COPY (sizeof(struct sym_lcbh)),\n} ,{\n\t\t0,\n\t\tHADDR_1 (lcb_head),\n\t \n\tSCR_COPY (4),\n\t\tHADDR_1 (lcb_head.itlq_tbl_sa),\n\t\tRADDR_1 (dsa),\n\t \n\tSCR_REG_SFBR (sidl, SCR_SHL, 0),\n\t\t0,\n#if SYM_CONF_MAX_TASK*4 > 512\n\tSCR_JUMPR ^ IFFALSE (CARRYSET),\n\t\t8,\n\tSCR_REG_REG (dsa1, SCR_OR, 2),\n\t\t0,\n\tSCR_REG_REG (sfbr, SCR_SHL, 0),\n\t\t0,\n\tSCR_JUMPR ^ IFFALSE (CARRYSET),\n\t\t8,\n\tSCR_REG_REG (dsa1, SCR_OR, 1),\n\t\t0,\n#elif SYM_CONF_MAX_TASK*4 > 256\n\tSCR_JUMPR ^ IFFALSE (CARRYSET),\n\t\t8,\n\tSCR_REG_REG (dsa1, SCR_OR, 1),\n\t\t0,\n#endif\n\t \n\tSCR_SFBR_REG (dsa, SCR_AND, 0xfc),\n\t\t0,\n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n\t\tPADDR_A (_sms_a120),\n\tSCR_COPY (4),\n} ,{\n\t\t0,\n\t\tRADDR_1 (dsa),\n} ,{\n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n\t\tPADDR_A (_sms_a130),\n\t \n\tSCR_COPY (8),\n} ,{\n\t\t0,\n\t\tPADDR_B (scratch),\n\tSCR_COPY (4),\n\t\tPADDR_B (scratch1),  \n\t\tRADDR_1 (temp),\n\tSCR_RETURN,\n\t\t0,\n\t \n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n\t\tPADDR_A (_sms_a140),\n\tSCR_COPY (sizeof(struct sym_ccbh)),\n} ,{\n\t\t0,\n\t\tHADDR_1 (ccb_head),\n\t \n\tSCR_COPY (4),\n\t\tHADDR_1 (ccb_head.status),\n\t\tRADDR_1 (scr0),\n\t \n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n\t\tPADDR_A (_sms_a145),\n\tSCR_COPY (sizeof(struct sym_lcbh)),\n} ,{\n\t\t0,\n\t\tHADDR_1 (lcb_head),\n\t \n\tSCR_COPY (4),\n\t\tHADDR_1 (lcb_head.itl_task_sa),\n\t\tRADDR_1 (dsa),\n\tSCR_JUMP,\n\t\tPADDR_A (resel_go),\n} ,{\n \n0\n} ,{\n\tSCR_CALL,\n\t\tPADDR_A (datai_done),\n\tSCR_JUMP,\n\t\tPADDR_B (data_ovrun),\n} ,{\n \n0\n} ,{\n\tSCR_CALL,\n\t\tPADDR_A (datao_done),\n\tSCR_JUMP,\n\t\tPADDR_B (data_ovrun),\n} ,{\n\t \n\tSCR_FROM_REG (HF_REG),\n\t\t0,\n\t \n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN)),\n\t\tPADDR_A (pm0_data_out),\n\t \n\tSCR_JUMP ^ IFFALSE (MASK (HF_DATA_IN, HF_DATA_IN)),\n\t\tPADDR_B (data_ovrun),\n\t \n\tSCR_REG_REG (HF_REG, SCR_OR, HF_IN_PM0),\n\t\t0,\n\t \n\tSCR_CHMOV_TBL ^ SCR_DATA_IN,\n\t\toffsetof (struct sym_ccb, phys.pm0.sg),\n\tSCR_JUMP,\n\t\tPADDR_A (pm0_data_end),\n} ,{\n\t \n\tSCR_JUMP ^ IFTRUE (MASK (HF_DATA_IN, HF_DATA_IN)),\n\t\tPADDR_B (data_ovrun),\n\t \n\tSCR_REG_REG (HF_REG, SCR_OR, HF_IN_PM0),\n\t\t0,\n\t \n\tSCR_CHMOV_TBL ^ SCR_DATA_OUT,\n\t\toffsetof (struct sym_ccb, phys.pm0.sg),\n} ,{\n\t \n\tSCR_REG_REG (HF_REG, SCR_AND, (~HF_IN_PM0)),\n\t\t0,\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n\t\tRADDR_1 (scratcha),\n\tSCR_REG_REG (scratcha, SCR_ADD, offsetof (struct sym_ccb,phys.pm0.ret)),\n\t\t0,\n} ,{\n\tSCR_COPY (4),\n\t\tRADDR_1 (scratcha),\n\t\tPADDR_A (_sms_a150),\n\tSCR_COPY (4),\n} ,{\n\t\t0,\n\t\tRADDR_1 (temp),\n\tSCR_RETURN,\n\t\t0,\n} ,{\n\t \n\tSCR_FROM_REG (HF_REG),\n\t\t0,\n\t \n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN)),\n\t\tPADDR_A (pm1_data_out),\n\t \n\tSCR_JUMP ^ IFFALSE (MASK (HF_DATA_IN, HF_DATA_IN)),\n\t\tPADDR_B (data_ovrun),\n\t \n\tSCR_REG_REG (HF_REG, SCR_OR, HF_IN_PM1),\n\t\t0,\n\t \n\tSCR_CHMOV_TBL ^ SCR_DATA_IN,\n\t\toffsetof (struct sym_ccb, phys.pm1.sg),\n\tSCR_JUMP,\n\t\tPADDR_A (pm1_data_end),\n} ,{\n\t \n\tSCR_JUMP ^ IFTRUE (MASK (HF_DATA_IN, HF_DATA_IN)),\n\t\tPADDR_B (data_ovrun),\n\t \n\tSCR_REG_REG (HF_REG, SCR_OR, HF_IN_PM1),\n\t\t0,\n\t \n\tSCR_CHMOV_TBL ^ SCR_DATA_OUT,\n\t\toffsetof (struct sym_ccb, phys.pm1.sg),\n} ,{\n\t \n\tSCR_REG_REG (HF_REG, SCR_AND, (~HF_IN_PM1)),\n\t\t0,\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (dsa),\n\t\tRADDR_1 (scratcha),\n\tSCR_REG_REG (scratcha, SCR_ADD, offsetof (struct sym_ccb,phys.pm1.ret)),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR_A (pm_data_end),\n} \n};\n\nstatic struct SYM_FWB_SCR SYM_FWB_SCR = {\n  {\n\tSCR_JUMP,\n\t\tPADDR_B (data_ovrun),\n} ,{\n\t \n\n#ifdef SYM_CONF_TARGET_ROLE_SUPPORT\n\t \n\tSCR_CLR (SCR_TRG),\n\t\t0,\n#endif\n\t \n\tSCR_SEL_TBL_ATN ^ offsetof (struct sym_hcb, abrt_sel),\n\t\tPADDR_A (reselect),\n\t \n\tSCR_JUMPR ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\t-8,\n\t \n\tSCR_INT,\n\t\tSIR_TARGET_SELECTED,\n\t \n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\tSCR_MOVE_TBL ^ SCR_MSG_OUT,\n\t\toffsetof (struct sym_hcb, abrt_tbl),\n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\tSCR_WAIT_DISC,\n\t\t0,\n\t \n\tSCR_INT,\n\t\tSIR_ABORT_SENT,\n} ,{\n\t \n\tSCR_JUMP,\n\t\tPADDR_A (start),\n} ,{\n\t \n\tSCR_JUMP ^ IFTRUE (DATA (M_EXTENDED)),\n\t\tPADDR_B (msg_extended),\n\t \n\tSCR_JUMP ^ IFTRUE (MASK (0x00, 0xf0)),\n\t\tPADDR_B (msg_received),\n\tSCR_JUMP ^ IFTRUE (MASK (0x10, 0xf0)),\n\t\tPADDR_B (msg_received),\n\t \n\tSCR_JUMP ^ IFFALSE (MASK (0x20, 0xf0)),\n\t\tPADDR_B (msg_weird_seen),\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tHADDR_1 (msgin[1]),\n} ,{\n\tSCR_COPY (4),\t\t\t \n\t\tHADDR_1 (scratch),\n\t\tRADDR_1 (scratcha),\n\tSCR_INT,\n\t\tSIR_MSG_RECEIVED,\n} ,{\n\tSCR_COPY (4),\t\t\t \n\t\tHADDR_1 (scratch),\n\t\tRADDR_1 (scratcha),\n\tSCR_INT,\n\t\tSIR_MSG_WEIRD,\n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tHADDR_1 (msgin[1]),\n\t \n\tSCR_JUMP ^ IFTRUE (DATA (0)),\n\t\tPADDR_B (msg_weird_seen),\n\tSCR_TO_REG (scratcha),\n\t\t0,\n\tSCR_REG_REG (sfbr, SCR_ADD, (256-8)),\n\t\t0,\n\tSCR_JUMP ^ IFTRUE (CARRYSET),\n\t\tPADDR_B (msg_weird_seen),\n\t \n\tSCR_COPY (1),\n\t\tRADDR_1 (scratcha),\n\t\tPADDR_B (_sms_b10),\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n} ,{\n\tSCR_MOVE_ABS (0) ^ SCR_MSG_IN,\n\t\tHADDR_1 (msgin[2]),\n\tSCR_JUMP,\n\t\tPADDR_B (msg_received),\n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_REJECT_TO_SEND,\n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR_A (clrack),\n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_REJECT_TO_SEND,\n\tSCR_SET (SCR_ATN),\n\t\t0,\n} ,{\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR_A (dispatch),\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tHADDR_1 (scratch),\n\tSCR_JUMP,\n\t\tPADDR_B (msg_weird1),\n} ,{\n\t \n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\tPADDR_B (nego_bad_phase),\n} ,{\n\t \n\tSCR_MOVE_ABS (4) ^ SCR_MSG_OUT,\n\t\tHADDR_1 (msgout),\n\tSCR_JUMP,\n\t\tPADDR_B (msg_out_done),\n} ,{\n\t \n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\tPADDR_B (nego_bad_phase),\n} ,{\n\t \n\tSCR_MOVE_ABS (5) ^ SCR_MSG_OUT,\n\t\tHADDR_1 (msgout),\n\tSCR_JUMP,\n\t\tPADDR_B (msg_out_done),\n} ,{\n\t \n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\tPADDR_B (nego_bad_phase),\n} ,{\n\t \n\tSCR_MOVE_ABS (8) ^ SCR_MSG_OUT,\n\t\tHADDR_1 (msgout),\n\tSCR_JUMP,\n\t\tPADDR_B (msg_out_done),\n} ,{\n\tSCR_INT,\n\t\tSIR_NEGO_PROTO,\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_OUT,\n\t\tHADDR_1 (msgout),\n\t \n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_OUT)),\n\t\tPADDR_B (msg_out),\n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_MSG_OUT_DONE,\n\t \n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tPADDR_B (zero),\n\t\tRADDR_1 (scratcha),\n} ,{\n\t \n\tSCR_JUMPR ^ IFFALSE (WHEN (SCR_DATA_OUT)),\n\t\t16,\n\tSCR_CHMOV_ABS (1) ^ SCR_DATA_OUT,\n\t\tHADDR_1 (scratch),\n\tSCR_JUMP,\n\t\tPADDR_B (data_ovrun2),\n\t \n\tSCR_FROM_REG (scntl2),\n\t\t0,\n\tSCR_JUMPR ^ IFFALSE (MASK (WSR, WSR)),\n\t\t16,\n\tSCR_REG_REG (scntl2, SCR_OR, WSR),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR_B (data_ovrun2),\n\t \n\tSCR_JUMPR ^ IFTRUE (WHEN (SCR_DATA_IN)),\n\t\t16,\n\tSCR_INT,\n\t\tSIR_DATA_OVERRUN,\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n\tSCR_CHMOV_ABS (1) ^ SCR_DATA_IN,\n\t\tHADDR_1 (scratch),\n} ,{\n\t \n\tSCR_REG_REG (scratcha,  SCR_ADD,  0x01),\n\t\t0,\n\tSCR_REG_REG (scratcha1, SCR_ADDC, 0),\n\t\t0,\n\tSCR_REG_REG (scratcha2, SCR_ADDC, 0),\n\t\t0,\n\t \n\tSCR_JUMP,\n\t\tPADDR_B (data_ovrun1),\n} ,{\n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\t \n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_OUT,\n\t\tHADDR_1 (msgout),\n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\tSCR_WAIT_DISC,\n\t\t0,\n\tSCR_INT,\n\t\tSIR_RESEL_ABORTED,\n\tSCR_JUMP,\n\t\tPADDR_A (start),\n} ,{\n\t \n\tSCR_SET (SCR_ATN),  \n\t\t0,          \n\tSCR_JUMP,\n\t\tPADDR_A (send_ident),\n} ,{\n\tSCR_CLR (SCR_ATN),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR_A (select2),\n} ,{\n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR_A (select2),\n} ,{\n\tSCR_CHMOV_TBL ^ SCR_DATA_IN,\n\t\toffsetof (struct sym_dsb, sense),\n\tSCR_CALL,\n\t\tPADDR_A (datai_done),\n\tSCR_JUMP,\n\t\tPADDR_B (data_ovrun),\n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_RESEL_BAD_LUN,\n\tSCR_JUMP,\n\t\tPADDR_B (abort_resel),\n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_RESEL_BAD_I_T_L,\n\tSCR_JUMP,\n\t\tPADDR_B (abort_resel),\n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_RESEL_BAD_I_T_L_Q,\n\tSCR_JUMP,\n\t\tPADDR_B (abort_resel),\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tPADDR_B (startpos),\n\t\tRADDR_1 (scratcha),\n\tSCR_INT ^ IFFALSE (DATA (S_COND_MET)),\n\t\tSIR_BAD_SCSI_STATUS,\n\tSCR_RETURN,\n\t\t0,\n} ,{\n\t \n\tSCR_CHMOV_TBL ^ SCR_DATA_IN,\n\t\toffsetof (struct sym_ccb, phys.wresid),\n\tSCR_JUMP,\n\t\tPADDR_A (dispatch),\n\n} ,{\n\tSCR_DATA_ZERO,\n} ,{\n\tSCR_DATA_ZERO,  \n} ,{\n\tSCR_DATA_ZERO,\n} ,{\n\tSCR_DATA_ZERO,  \n} ,{\n\tSCR_DATA_ZERO,\n} ,{\n\tSCR_DATA_ZERO,  \n} ,{\n\tSCR_DATA_ZERO,\n} ,{\n\tSCR_DATA_ZERO,\n} \n};\n\nstatic struct SYM_FWZ_SCR SYM_FWZ_SCR = {\n  {\n\t \n\tSCR_COPY (4),\n\t\tHADDR_1 (scratch),\n\t\tRADDR_1 (scratcha),\n\t \n\tSCR_COPY (4),\n\t\tRADDR_1 (temp),\n\t\tHADDR_1 (scratch),\n\t \n\tSCR_COPY (4),\n\t\tHADDR_1 (scratch),\n\t\tRADDR_1 (temp),\n} ,{\n\t \n\tSCR_INT,\n\t\t99,\n} \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}