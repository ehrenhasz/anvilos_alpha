{
  "module_name": "sym_misc.h",
  "hash_id": "e4f56f52b5213d63e7e1948e35997f4c9e4885fa86854375f0f818c6172e6319",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sym53c8xx_2/sym_misc.h",
  "human_readable_source": " \n \n\n#ifndef SYM_MISC_H\n#define SYM_MISC_H\n\n \ntypedef struct sym_quehead {\n\tstruct sym_quehead *flink;\t \n\tstruct sym_quehead *blink;\t \n} SYM_QUEHEAD;\n\n#define sym_que_init(ptr) do { \\\n\t(ptr)->flink = (ptr); (ptr)->blink = (ptr); \\\n} while (0)\n\nstatic inline struct sym_quehead *sym_que_first(struct sym_quehead *head)\n{\n\treturn (head->flink == head) ? 0 : head->flink;\n}\n\nstatic inline struct sym_quehead *sym_que_last(struct sym_quehead *head)\n{\n\treturn (head->blink == head) ? 0 : head->blink;\n}\n\nstatic inline void __sym_que_add(struct sym_quehead * new,\n\tstruct sym_quehead * blink,\n\tstruct sym_quehead * flink)\n{\n\tflink->blink\t= new;\n\tnew->flink\t= flink;\n\tnew->blink\t= blink;\n\tblink->flink\t= new;\n}\n\nstatic inline void __sym_que_del(struct sym_quehead * blink,\n\tstruct sym_quehead * flink)\n{\n\tflink->blink = blink;\n\tblink->flink = flink;\n}\n\nstatic inline int sym_que_empty(struct sym_quehead *head)\n{\n\treturn head->flink == head;\n}\n\nstatic inline void sym_que_splice(struct sym_quehead *list,\n\tstruct sym_quehead *head)\n{\n\tstruct sym_quehead *first = list->flink;\n\n\tif (first != list) {\n\t\tstruct sym_quehead *last = list->blink;\n\t\tstruct sym_quehead *at   = head->flink;\n\n\t\tfirst->blink = head;\n\t\thead->flink  = first;\n\n\t\tlast->flink = at;\n\t\tat->blink   = last;\n\t}\n}\n\nstatic inline void sym_que_move(struct sym_quehead *orig,\n\tstruct sym_quehead *dest)\n{\n\tstruct sym_quehead *first, *last;\n\n\tfirst = orig->flink;\n\tif (first != orig) {\n\t\tfirst->blink = dest;\n\t\tdest->flink  = first;\n\t\tlast = orig->blink;\n\t\tlast->flink  = dest;\n\t\tdest->blink  = last;\n\t\torig->flink  = orig;\n\t\torig->blink  = orig;\n\t} else {\n\t\tdest->flink  = dest;\n\t\tdest->blink  = dest;\n\t}\n}\n\n#define sym_que_entry(ptr, type, member) container_of(ptr, type, member)\n\n#define sym_insque(new, pos)\t\t__sym_que_add(new, pos, (pos)->flink)\n\n#define sym_remque(el)\t\t\t__sym_que_del((el)->blink, (el)->flink)\n\n#define sym_insque_head(new, head)\t__sym_que_add(new, head, (head)->flink)\n\nstatic inline struct sym_quehead *sym_remque_head(struct sym_quehead *head)\n{\n\tstruct sym_quehead *elem = head->flink;\n\n\tif (elem != head)\n\t\t__sym_que_del(head, elem->flink);\n\telse\n\t\telem = NULL;\n\treturn elem;\n}\n\n#define sym_insque_tail(new, head)\t__sym_que_add(new, (head)->blink, head)\n\nstatic inline struct sym_quehead *sym_remque_tail(struct sym_quehead *head)\n{\n\tstruct sym_quehead *elem = head->blink;\n\n\tif (elem != head)\n\t\t__sym_que_del(elem->blink, head);\n\telse\n\t\telem = 0;\n\treturn elem;\n}\n\n \n#define FOR_EACH_QUEUED_ELEMENT(head, qp) \\\n\tfor (qp = (head)->flink; qp != (head); qp = qp->flink)\n \n#define sym_qptr(p)\t((struct sym_quehead *) (p))\n\n  \n#define sym_set_bit(p, n)\t(((u32 *)(p))[(n)>>5] |=  (1<<((n)&0x1f)))\n#define sym_clr_bit(p, n)\t(((u32 *)(p))[(n)>>5] &= ~(1<<((n)&0x1f)))\n#define sym_is_bit(p, n)\t(((u32 *)(p))[(n)>>5] &   (1<<((n)&0x1f)))\n\n \n#define _U_(a,m)\t(a)<=(1<<m)?m:\n\n \n#define _LGRU16_(a) \\\n( \\\n _U_(a, 0)_U_(a, 1)_U_(a, 2)_U_(a, 3)_U_(a, 4)_U_(a, 5)_U_(a, 6)_U_(a, 7) \\\n _U_(a, 8)_U_(a, 9)_U_(a,10)_U_(a,11)_U_(a,12)_U_(a,13)_U_(a,14)_U_(a,15) \\\n 16)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}