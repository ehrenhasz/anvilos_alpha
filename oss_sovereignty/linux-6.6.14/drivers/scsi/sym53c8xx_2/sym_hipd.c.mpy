{
  "module_name": "sym_hipd.c",
  "hash_id": "018f08d6e1d0c5a9f94ee4dbf8a3dcaf08b33f7bee16081f7aa643d55f3b0b9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sym53c8xx_2/sym_hipd.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <asm/param.h>\t\t \n\n#include \"sym_glue.h\"\n#include \"sym_nvram.h\"\n\n#if 0\n#define SYM_DEBUG_GENERIC_SUPPORT\n#endif\n\n \nstatic void sym_int_ma (struct sym_hcb *np);\nstatic void sym_int_sir(struct sym_hcb *);\nstatic struct sym_ccb *sym_alloc_ccb(struct sym_hcb *np);\nstatic struct sym_ccb *sym_ccb_from_dsa(struct sym_hcb *np, u32 dsa);\nstatic void sym_alloc_lcb_tags (struct sym_hcb *np, u_char tn, u_char ln);\nstatic void sym_complete_error (struct sym_hcb *np, struct sym_ccb *cp);\nstatic void sym_complete_ok (struct sym_hcb *np, struct sym_ccb *cp);\nstatic int sym_compute_residual(struct sym_hcb *np, struct sym_ccb *cp);\n\n \nstatic void sym_printl_hex(u_char *p, int n)\n{\n\twhile (n-- > 0)\n\t\tprintf (\" %x\", *p++);\n\tprintf (\".\\n\");\n}\n\nstatic void sym_print_msg(struct sym_ccb *cp, char *label, u_char *msg)\n{\n\tsym_print_addr(cp->cmd, \"%s: \", label);\n\n\tspi_print_msg(msg);\n\tprintf(\"\\n\");\n}\n\nstatic void sym_print_nego_msg(struct sym_hcb *np, int target, char *label, u_char *msg)\n{\n\tstruct sym_tcb *tp = &np->target[target];\n\tdev_info(&tp->starget->dev, \"%s: \", label);\n\n\tspi_print_msg(msg);\n\tprintf(\"\\n\");\n}\n\n \nvoid sym_print_xerr(struct scsi_cmnd *cmd, int x_status)\n{\n\tif (x_status & XE_PARITY_ERR) {\n\t\tsym_print_addr(cmd, \"unrecovered SCSI parity error.\\n\");\n\t}\n\tif (x_status & XE_EXTRA_DATA) {\n\t\tsym_print_addr(cmd, \"extraneous data discarded.\\n\");\n\t}\n\tif (x_status & XE_BAD_PHASE) {\n\t\tsym_print_addr(cmd, \"illegal scsi phase (4/5).\\n\");\n\t}\n\tif (x_status & XE_SODL_UNRUN) {\n\t\tsym_print_addr(cmd, \"ODD transfer in DATA OUT phase.\\n\");\n\t}\n\tif (x_status & XE_SWIDE_OVRUN) {\n\t\tsym_print_addr(cmd, \"ODD transfer in DATA IN phase.\\n\");\n\t}\n}\n\n \nstatic char *sym_scsi_bus_mode(int mode)\n{\n\tswitch(mode) {\n\tcase SMODE_HVD:\treturn \"HVD\";\n\tcase SMODE_SE:\treturn \"SE\";\n\tcase SMODE_LVD: return \"LVD\";\n\t}\n\treturn \"??\";\n}\n\n \nstatic void sym_chip_reset (struct sym_hcb *np)\n{\n\tOUTB(np, nc_istat, SRST);\n\tINB(np, nc_mbox1);\n\tudelay(10);\n\tOUTB(np, nc_istat, 0);\n\tINB(np, nc_mbox1);\n\tudelay(2000);\t \n}\n\n \nstatic void sym_soft_reset (struct sym_hcb *np)\n{\n\tu_char istat = 0;\n\tint i;\n\n\tif (!(np->features & FE_ISTAT1) || !(INB(np, nc_istat1) & SCRUN))\n\t\tgoto do_chip_reset;\n\n\tOUTB(np, nc_istat, CABRT);\n\tfor (i = 100000 ; i ; --i) {\n\t\tistat = INB(np, nc_istat);\n\t\tif (istat & SIP) {\n\t\t\tINW(np, nc_sist);\n\t\t}\n\t\telse if (istat & DIP) {\n\t\t\tif (INB(np, nc_dstat) & ABRT)\n\t\t\t\tbreak;\n\t\t}\n\t\tudelay(5);\n\t}\n\tOUTB(np, nc_istat, 0);\n\tif (!i)\n\t\tprintf(\"%s: unable to abort current chip operation, \"\n\t\t       \"ISTAT=0x%02x.\\n\", sym_name(np), istat);\ndo_chip_reset:\n\tsym_chip_reset(np);\n}\n\n \nstatic void sym_start_reset(struct sym_hcb *np)\n{\n\tsym_reset_scsi_bus(np, 1);\n}\n \nint sym_reset_scsi_bus(struct sym_hcb *np, int enab_int)\n{\n\tu32 term;\n\tint retv = 0;\n\n\tsym_soft_reset(np);\t \n\tif (enab_int)\n\t\tOUTW(np, nc_sien, RST);\n\t \n\tOUTB(np, nc_stest3, TE);\n\tOUTB(np, nc_dcntl, (np->rv_dcntl & IRQM));\n\tOUTB(np, nc_scntl1, CRST);\n\tINB(np, nc_mbox1);\n\tudelay(200);\n\n\tif (!SYM_SETUP_SCSI_BUS_CHECK)\n\t\tgoto out;\n\t \n\tterm =\tINB(np, nc_sstat0);\n\tterm =\t((term & 2) << 7) + ((term & 1) << 17);\t \n\tterm |= ((INB(np, nc_sstat2) & 0x01) << 26) |\t \n\t\t((INW(np, nc_sbdl) & 0xff)   << 9)  |\t \n\t\t((INW(np, nc_sbdl) & 0xff00) << 10) |\t \n\t\tINB(np, nc_sbcl);\t \n\n\tif (!np->maxwide)\n\t\tterm &= 0x3ffff;\n\n\tif (term != (2<<7)) {\n\t\tprintf(\"%s: suspicious SCSI data while resetting the BUS.\\n\",\n\t\t\tsym_name(np));\n\t\tprintf(\"%s: %sdp0,d7-0,rst,req,ack,bsy,sel,atn,msg,c/d,i/o = \"\n\t\t\t\"0x%lx, expecting 0x%lx\\n\",\n\t\t\tsym_name(np),\n\t\t\t(np->features & FE_WIDE) ? \"dp1,d15-8,\" : \"\",\n\t\t\t(u_long)term, (u_long)(2<<7));\n\t\tif (SYM_SETUP_SCSI_BUS_CHECK == 1)\n\t\t\tretv = 1;\n\t}\nout:\n\tOUTB(np, nc_scntl1, 0);\n\treturn retv;\n}\n\n \nstatic void sym_selectclock(struct sym_hcb *np, u_char scntl3)\n{\n\t \n\tif (np->multiplier <= 1) {\n\t\tOUTB(np, nc_scntl3, scntl3);\n\t\treturn;\n\t}\n\n\tif (sym_verbose >= 2)\n\t\tprintf (\"%s: enabling clock multiplier\\n\", sym_name(np));\n\n\tOUTB(np, nc_stest1, DBLEN);\t    \n\t \n\tif (np->features & FE_LCKFRQ) {\n\t\tint i = 20;\n\t\twhile (!(INB(np, nc_stest4) & LCKFRQ) && --i > 0)\n\t\t\tudelay(20);\n\t\tif (!i)\n\t\t\tprintf(\"%s: the chip cannot lock the frequency\\n\",\n\t\t\t\tsym_name(np));\n\t} else {\n\t\tINB(np, nc_mbox1);\n\t\tudelay(50+10);\n\t}\n\tOUTB(np, nc_stest3, HSC);\t\t \n\tOUTB(np, nc_scntl3, scntl3);\n\tOUTB(np, nc_stest1, (DBLEN|DBLSEL)); \n\tOUTB(np, nc_stest3, 0x00);\t\t \n}\n\n\n \n\n \nstatic unsigned getfreq (struct sym_hcb *np, int gen)\n{\n\tunsigned int ms = 0;\n\tunsigned int f;\n\n\t \n\tOUTW(np, nc_sien, 0);\t \n\tINW(np, nc_sist);\t \n\tOUTB(np, nc_dien, 0);\t \n\tINW(np, nc_sist);\t \n\t \n\tif (np->features & FE_C10) {\n\t\tOUTW(np, nc_sien, GEN);\n\t\tOUTB(np, nc_istat1, SIRQD);\n\t}\n\tOUTB(np, nc_scntl3, 4);\t    \n\tOUTB(np, nc_stime1, 0);\t    \n\tOUTB(np, nc_stime1, gen);   \n\twhile (!(INW(np, nc_sist) & GEN) && ms++ < 100000)\n\t\tudelay(1000/4);     \n\tOUTB(np, nc_stime1, 0);     \n\t \n\tif (np->features & FE_C10) {\n\t\tOUTW(np, nc_sien, 0);\n\t\tOUTB(np, nc_istat1, 0);\n\t}\n \t \n \tOUTB(np, nc_scntl3, 0);\n\n  \t \n\tf = ms ? ((1 << gen) * (4340*4)) / ms : 0;\n\n\t \n\tif (np->features & FE_C10)\n\t\tf = (f * 2) / 3;\n\n\tif (sym_verbose >= 2)\n\t\tprintf (\"%s: Delay (GEN=%d): %u msec, %u KHz\\n\",\n\t\t\tsym_name(np), gen, ms/4, f);\n\n\treturn f;\n}\n\nstatic unsigned sym_getfreq (struct sym_hcb *np)\n{\n\tu_int f1, f2;\n\tint gen = 8;\n\n\tgetfreq (np, gen);\t \n\tf1 = getfreq (np, gen);\n\tf2 = getfreq (np, gen);\n\tif (f1 > f2) f1 = f2;\t\t \n\treturn f1;\n}\n\n \nstatic void sym_getclock (struct sym_hcb *np, int mult)\n{\n\tunsigned char scntl3 = np->sv_scntl3;\n\tunsigned char stest1 = np->sv_stest1;\n\tunsigned f1;\n\n\tnp->multiplier = 1;\n\tf1 = 40000;\n\t \n\tif (mult > 1 && (stest1 & (DBLEN+DBLSEL)) == DBLEN+DBLSEL) {\n\t\tif (sym_verbose >= 2)\n\t\t\tprintf (\"%s: clock multiplier found\\n\", sym_name(np));\n\t\tnp->multiplier = mult;\n\t}\n\n\t \n\tif (np->multiplier != mult || (scntl3 & 7) < 3 || !(scntl3 & 1)) {\n\t\tOUTB(np, nc_stest1, 0);\t\t \n\t\tf1 = sym_getfreq (np);\n\n\t\tif (sym_verbose)\n\t\t\tprintf (\"%s: chip clock is %uKHz\\n\", sym_name(np), f1);\n\n\t\tif\t(f1 <\t45000)\t\tf1 =  40000;\n\t\telse if (f1 <\t55000)\t\tf1 =  50000;\n\t\telse\t\t\t\tf1 =  80000;\n\n\t\tif (f1 < 80000 && mult > 1) {\n\t\t\tif (sym_verbose >= 2)\n\t\t\t\tprintf (\"%s: clock multiplier assumed\\n\",\n\t\t\t\t\tsym_name(np));\n\t\t\tnp->multiplier\t= mult;\n\t\t}\n\t} else {\n\t\tif\t((scntl3 & 7) == 3)\tf1 =  40000;\n\t\telse if\t((scntl3 & 7) == 5)\tf1 =  80000;\n\t\telse \t\t\t\tf1 = 160000;\n\n\t\tf1 /= np->multiplier;\n\t}\n\n\t \n\tf1\t\t*= np->multiplier;\n\tnp->clock_khz\t= f1;\n}\n\n \nstatic int sym_getpciclock (struct sym_hcb *np)\n{\n\tint f = 0;\n\n\t \n#if 1\n\tif (np->features & FE_66MHZ) {\n#else\n\tif (1) {\n#endif\n\t\tOUTB(np, nc_stest1, SCLK);  \n\t\tf = sym_getfreq(np);\n\t\tOUTB(np, nc_stest1, 0);\n\t}\n\tnp->pciclk_khz = f;\n\n\treturn f;\n}\n\n \n#define _5M 5000000\nstatic const u32 div_10M[] = {2*_5M, 3*_5M, 4*_5M, 6*_5M, 8*_5M, 12*_5M, 16*_5M};\n\n \nstatic int \nsym_getsync(struct sym_hcb *np, u_char dt, u_char sfac, u_char *divp, u_char *fakp)\n{\n\tu32\tclk = np->clock_khz;\t \n\tint\tdiv = np->clock_divn;\t \n\tu32\tfak;\t\t\t \n\tu32\tper;\t\t\t \n\tu32\tkpc;\t\t\t \n\tint\tret;\n\n\t \n\tif (dt && sfac <= 9)\tper = 125;\n\telse if\t(sfac <= 10)\tper = 250;\n\telse if\t(sfac == 11)\tper = 303;\n\telse if\t(sfac == 12)\tper = 500;\n\telse\t\t\tper = 40 * sfac;\n\tret = per;\n\n\tkpc = per * clk;\n\tif (dt)\n\t\tkpc <<= 1;\n\n\t \n#if 1\n\tif ((np->features & (FE_C10|FE_U3EN)) == FE_C10) {\n\t\t \n\t\twhile (div > 0) {\n\t\t\t--div;\n\t\t\tif (kpc > (div_10M[div] << 2)) {\n\t\t\t\t++div;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfak = 0;\t\t\t \n\t\tif (div == np->clock_divn) {\t \n\t\t\tret = -1;\n\t\t}\n\t\t*divp = div;\n\t\t*fakp = fak;\n\t\treturn ret;\n\t}\n#endif\n\n\t \n\twhile (--div > 0)\n\t\tif (kpc >= (div_10M[div] << 2)) break;\n\n\t \n\tif (dt) {\n\t\tfak = (kpc - 1) / (div_10M[div] << 1) + 1 - 2;\n\t\t \n\t} else {\n\t\tfak = (kpc - 1) / div_10M[div] + 1 - 4;\n\t\t \n\t}\n\n\t \n\tif (fak > 2) {\n\t\tfak = 2;\n\t\tret = -1;\n\t}\n\n\t \n\t*divp = div;\n\t*fakp = fak;\n\n\treturn ret;\n}\n\n \n\n \n#define burst_length(bc) (!(bc))? 0 : 1 << (bc)\n\n \n#define burst_code(dmode, ctest4, ctest5) \\\n\t(ctest4) & 0x80? 0 : (((dmode) & 0xc0) >> 6) + ((ctest5) & 0x04) + 1\n\n \nstatic inline void sym_init_burst(struct sym_hcb *np, u_char bc)\n{\n\tnp->rv_ctest4\t&= ~0x80;\n\tnp->rv_dmode\t&= ~(0x3 << 6);\n\tnp->rv_ctest5\t&= ~0x4;\n\n\tif (!bc) {\n\t\tnp->rv_ctest4\t|= 0x80;\n\t}\n\telse {\n\t\t--bc;\n\t\tnp->rv_dmode\t|= ((bc & 0x3) << 6);\n\t\tnp->rv_ctest5\t|= (bc & 0x4);\n\t}\n}\n\n \nstatic void sym_save_initial_setting (struct sym_hcb *np)\n{\n\tnp->sv_scntl0\t= INB(np, nc_scntl0) & 0x0a;\n\tnp->sv_scntl3\t= INB(np, nc_scntl3) & 0x07;\n\tnp->sv_dmode\t= INB(np, nc_dmode)  & 0xce;\n\tnp->sv_dcntl\t= INB(np, nc_dcntl)  & 0xa8;\n\tnp->sv_ctest3\t= INB(np, nc_ctest3) & 0x01;\n\tnp->sv_ctest4\t= INB(np, nc_ctest4) & 0x80;\n\tnp->sv_gpcntl\t= INB(np, nc_gpcntl);\n\tnp->sv_stest1\t= INB(np, nc_stest1);\n\tnp->sv_stest2\t= INB(np, nc_stest2) & 0x20;\n\tnp->sv_stest4\t= INB(np, nc_stest4);\n\tif (np->features & FE_C10) {\t \n\t\tnp->sv_scntl4\t= INB(np, nc_scntl4);\n\t\tnp->sv_ctest5\t= INB(np, nc_ctest5) & 0x04;\n\t}\n\telse\n\t\tnp->sv_ctest5\t= INB(np, nc_ctest5) & 0x24;\n}\n\n \nstatic void sym_set_bus_mode(struct sym_hcb *np, struct sym_nvram *nvram)\n{\n\tif (np->scsi_mode)\n\t\treturn;\n\n\tnp->scsi_mode = SMODE_SE;\n\tif (np->features & (FE_ULTRA2|FE_ULTRA3))\n\t\tnp->scsi_mode = (np->sv_stest4 & SMODE);\n\telse if\t(np->features & FE_DIFF) {\n\t\tif (SYM_SETUP_SCSI_DIFF == 1) {\n\t\t\tif (np->sv_scntl3) {\n\t\t\t\tif (np->sv_stest2 & 0x20)\n\t\t\t\t\tnp->scsi_mode = SMODE_HVD;\n\t\t\t} else if (nvram->type == SYM_SYMBIOS_NVRAM) {\n\t\t\t\tif (!(INB(np, nc_gpreg) & 0x08))\n\t\t\t\t\tnp->scsi_mode = SMODE_HVD;\n\t\t\t}\n\t\t} else if (SYM_SETUP_SCSI_DIFF == 2)\n\t\t\tnp->scsi_mode = SMODE_HVD;\n\t}\n\tif (np->scsi_mode == SMODE_HVD)\n\t\tnp->rv_stest2 |= 0x20;\n}\n\n \nstatic int sym_prepare_setting(struct Scsi_Host *shost, struct sym_hcb *np, struct sym_nvram *nvram)\n{\n\tstruct sym_data *sym_data = shost_priv(shost);\n\tstruct pci_dev *pdev = sym_data->pdev;\n\tu_char\tburst_max;\n\tu32\tperiod;\n\tint i;\n\n\tnp->maxwide = (np->features & FE_WIDE) ? 1 : 0;\n\n\t \n\tif\t(np->features & (FE_ULTRA3 | FE_ULTRA2))\n\t\tnp->clock_khz = 160000;\n\telse if\t(np->features & FE_ULTRA)\n\t\tnp->clock_khz = 80000;\n\telse\n\t\tnp->clock_khz = 40000;\n\n\t \n\tif\t(np->features & FE_QUAD)\n\t\tnp->multiplier\t= 4;\n\telse if\t(np->features & FE_DBLR)\n\t\tnp->multiplier\t= 2;\n\telse\n\t\tnp->multiplier\t= 1;\n\n\t \n\tif (np->features & FE_VARCLK)\n\t\tsym_getclock(np, np->multiplier);\n\n\t \n\ti = np->clock_divn - 1;\n\twhile (--i >= 0) {\n\t\tif (10ul * SYM_CONF_MIN_ASYNC * np->clock_khz > div_10M[i]) {\n\t\t\t++i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tnp->rv_scntl3 = i+1;\n\n\t \n\tif (np->features & FE_C10)\n\t\tnp->rv_scntl3 = 0;\n\n\t \n\tperiod = (4 * div_10M[0] + np->clock_khz - 1) / np->clock_khz;\n\n\tif\t(period <= 250)\t\tnp->minsync = 10;\n\telse if\t(period <= 303)\t\tnp->minsync = 11;\n\telse if\t(period <= 500)\t\tnp->minsync = 12;\n\telse\t\t\t\tnp->minsync = (period + 40 - 1) / 40;\n\n\t \n\tif\t(np->minsync < 25 &&\n\t\t !(np->features & (FE_ULTRA|FE_ULTRA2|FE_ULTRA3)))\n\t\tnp->minsync = 25;\n\telse if\t(np->minsync < 12 &&\n\t\t !(np->features & (FE_ULTRA2|FE_ULTRA3)))\n\t\tnp->minsync = 12;\n\n\t \n\tperiod = div64_ul(11 * div_10M[np->clock_divn - 1], 4 * np->clock_khz);\n\tnp->maxsync = period > 2540 ? 254 : period / 10;\n\n\t \n\tif ((np->features & (FE_C10|FE_ULTRA3)) == (FE_C10|FE_ULTRA3)) {\n\t\tif (np->clock_khz == 160000) {\n\t\t\tnp->minsync_dt = 9;\n\t\t\tnp->maxsync_dt = 50;\n\t\t\tnp->maxoffs_dt = nvram->type ? 62 : 31;\n\t\t}\n\t}\n\t\n\t \n\tif (np->features & FE_DAC) {\n\t\tif (!use_dac(np))\n\t\t\tnp->rv_ccntl1 |= (DDAC);\n\t\telse if (SYM_CONF_DMA_ADDRESSING_MODE == 1)\n\t\t\tnp->rv_ccntl1 |= (XTIMOD | EXTIBMV);\n\t\telse if (SYM_CONF_DMA_ADDRESSING_MODE == 2)\n\t\t\tnp->rv_ccntl1 |= (0 | EXTIBMV);\n\t}\n\n\t \n\tif (np->features & FE_NOPM)\n\t\tnp->rv_ccntl0\t|= (ENPMJ);\n\n \t \n\tif (pdev->device == PCI_DEVICE_ID_LSI_53C1010_33 &&\n\t    pdev->revision < 0x1)\n\t\tnp->rv_ccntl0\t|=  DILS;\n\n\t \n\tburst_max\t= SYM_SETUP_BURST_ORDER;\n\tif (burst_max == 255)\n\t\tburst_max = burst_code(np->sv_dmode, np->sv_ctest4,\n\t\t\t\t       np->sv_ctest5);\n\tif (burst_max > 7)\n\t\tburst_max = 7;\n\tif (burst_max > np->maxburst)\n\t\tburst_max = np->maxburst;\n\n\t \n\tif ((pdev->device == PCI_DEVICE_ID_NCR_53C810 &&\n\t     pdev->revision >= 0x10 && pdev->revision <= 0x11) ||\n\t    (pdev->device == PCI_DEVICE_ID_NCR_53C860 &&\n\t     pdev->revision <= 0x1))\n\t\tnp->features &= ~(FE_WRIE|FE_ERL|FE_ERMP);\n\n\t \n\tif (np->features & FE_ERL)\n\t\tnp->rv_dmode\t|= ERL;\t\t \n\tif (np->features & FE_BOF)\n\t\tnp->rv_dmode\t|= BOF;\t\t \n\tif (np->features & FE_ERMP)\n\t\tnp->rv_dmode\t|= ERMP;\t \n#if 1\n\tif ((np->features & FE_PFEN) && !np->ram_ba)\n#else\n\tif (np->features & FE_PFEN)\n#endif\n\t\tnp->rv_dcntl\t|= PFEN;\t \n\tif (np->features & FE_CLSE)\n\t\tnp->rv_dcntl\t|= CLSE;\t \n\tif (np->features & FE_WRIE)\n\t\tnp->rv_ctest3\t|= WRIE;\t \n\tif (np->features & FE_DFS)\n\t\tnp->rv_ctest5\t|= DFS;\t\t \n\n\t \n\tnp->rv_ctest4\t|= MPEE;  \n\tnp->rv_scntl0\t|= 0x0a;  \n\n\t \n\tnp->myaddr = 255;\n\tnp->scsi_mode = 0;\n\tsym_nvram_setup_host(shost, np, nvram);\n\n\t \n\tif (np->myaddr == 255) {\n\t\tnp->myaddr = INB(np, nc_scid) & 0x07;\n\t\tif (!np->myaddr)\n\t\t\tnp->myaddr = SYM_SETUP_HOST_ID;\n\t}\n\n\t \n\tsym_init_burst(np, burst_max);\n\n\tsym_set_bus_mode(np, nvram);\n\n\t \n\tif ((SYM_SETUP_SCSI_LED || \n\t     (nvram->type == SYM_SYMBIOS_NVRAM ||\n\t      (nvram->type == SYM_TEKRAM_NVRAM &&\n\t       pdev->device == PCI_DEVICE_ID_NCR_53C895))) &&\n\t    !(np->features & FE_LEDC) && !(np->sv_gpcntl & 0x01))\n\t\tnp->features |= FE_LED0;\n\n\t \n\tswitch(SYM_SETUP_IRQ_MODE & 3) {\n\tcase 2:\n\t\tnp->rv_dcntl\t|= IRQM;\n\t\tbreak;\n\tcase 1:\n\t\tnp->rv_dcntl\t|= (np->sv_dcntl & IRQM);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0 ; i < SYM_CONF_MAX_TARGET ; i++) {\n\t\tstruct sym_tcb *tp = &np->target[i];\n\n\t\ttp->usrflags |= (SYM_DISC_ENABLED | SYM_TAGS_ENABLED);\n\t\ttp->usrtags = SYM_SETUP_MAX_TAG;\n\t\ttp->usr_width = np->maxwide;\n\t\ttp->usr_period = 9;\n\n\t\tsym_nvram_setup_target(tp, i, nvram);\n\n\t\tif (!tp->usrtags)\n\t\t\ttp->usrflags &= ~SYM_TAGS_ENABLED;\n\t}\n\n\t \n\tprintf(\"%s: %s, ID %d, Fast-%d, %s, %s\\n\", sym_name(np),\n\t\tsym_nvram_type(nvram), np->myaddr,\n\t\t(np->features & FE_ULTRA3) ? 80 : \n\t\t(np->features & FE_ULTRA2) ? 40 : \n\t\t(np->features & FE_ULTRA)  ? 20 : 10,\n\t\tsym_scsi_bus_mode(np->scsi_mode),\n\t\t(np->rv_scntl0 & 0xa)\t? \"parity checking\" : \"NO parity\");\n\t \n\tif (sym_verbose) {\n\t\tprintf(\"%s: %s IRQ line driver%s\\n\",\n\t\t\tsym_name(np),\n\t\t\tnp->rv_dcntl & IRQM ? \"totem pole\" : \"open drain\",\n\t\t\tnp->ram_ba ? \", using on-chip SRAM\" : \"\");\n\t\tprintf(\"%s: using %s firmware.\\n\", sym_name(np), np->fw_name);\n\t\tif (np->features & FE_NOPM)\n\t\t\tprintf(\"%s: handling phase mismatch from SCRIPTS.\\n\", \n\t\t\t       sym_name(np));\n\t}\n\t \n\tif (sym_verbose >= 2) {\n\t\tprintf (\"%s: initial SCNTL3/DMODE/DCNTL/CTEST3/4/5 = \"\n\t\t\t\"(hex) %02x/%02x/%02x/%02x/%02x/%02x\\n\",\n\t\t\tsym_name(np), np->sv_scntl3, np->sv_dmode, np->sv_dcntl,\n\t\t\tnp->sv_ctest3, np->sv_ctest4, np->sv_ctest5);\n\n\t\tprintf (\"%s: final   SCNTL3/DMODE/DCNTL/CTEST3/4/5 = \"\n\t\t\t\"(hex) %02x/%02x/%02x/%02x/%02x/%02x\\n\",\n\t\t\tsym_name(np), np->rv_scntl3, np->rv_dmode, np->rv_dcntl,\n\t\t\tnp->rv_ctest3, np->rv_ctest4, np->rv_ctest5);\n\t}\n\n\treturn 0;\n}\n\n \n#ifdef CONFIG_SCSI_SYM53C8XX_MMIO\nstatic int sym_regtest(struct sym_hcb *np)\n{\n\tregister volatile u32 data;\n\t \n\tdata = 0xffffffff;\n\tOUTL(np, nc_dstat, data);\n\tdata = INL(np, nc_dstat);\n#if 1\n\tif (data == 0xffffffff) {\n#else\n\tif ((data & 0xe2f0fffd) != 0x02000080) {\n#endif\n\t\tprintf (\"CACHE TEST FAILED: reg dstat-sstat2 readback %x.\\n\",\n\t\t\t(unsigned) data);\n\t\treturn 0x10;\n\t}\n\treturn 0;\n}\n#else\nstatic inline int sym_regtest(struct sym_hcb *np)\n{\n\treturn 0;\n}\n#endif\n\nstatic int sym_snooptest(struct sym_hcb *np)\n{\n\tu32 sym_rd, sym_wr, sym_bk, host_rd, host_wr, pc, dstat;\n\tint i, err;\n\n\terr = sym_regtest(np);\n\tif (err)\n\t\treturn err;\nrestart_test:\n\t \n\tOUTB(np, nc_ctest4, (np->rv_ctest4 & MPEE));\n\t \n\tpc  = SCRIPTZ_BA(np, snooptest);\n\thost_wr = 1;\n\tsym_wr  = 2;\n\t \n\tnp->scratch = cpu_to_scr(host_wr);\n\tOUTL(np, nc_temp, sym_wr);\n\t \n\tOUTL(np, nc_dsa, np->hcb_ba);\n\tOUTL_DSP(np, pc);\n\t \n\tfor (i=0; i<SYM_SNOOP_TIMEOUT; i++)\n\t\tif (INB(np, nc_istat) & (INTF|SIP|DIP))\n\t\t\tbreak;\n\tif (i>=SYM_SNOOP_TIMEOUT) {\n\t\tprintf (\"CACHE TEST FAILED: timeout.\\n\");\n\t\treturn (0x20);\n\t}\n\t \n\tdstat = INB(np, nc_dstat);\n#if 1\t \n\tif ((dstat & MDPE) && (np->rv_ctest4 & MPEE)) {\n\t\tprintf (\"%s: PCI DATA PARITY ERROR DETECTED - \"\n\t\t\t\"DISABLING MASTER DATA PARITY CHECKING.\\n\",\n\t\t\tsym_name(np));\n\t\tnp->rv_ctest4 &= ~MPEE;\n\t\tgoto restart_test;\n\t}\n#endif\n\tif (dstat & (MDPE|BF|IID)) {\n\t\tprintf (\"CACHE TEST FAILED: DMA error (dstat=0x%02x).\", dstat);\n\t\treturn (0x80);\n\t}\n\t \n\tpc = INL(np, nc_dsp);\n\t \n\thost_rd = scr_to_cpu(np->scratch);\n\tsym_rd  = INL(np, nc_scratcha);\n\tsym_bk  = INL(np, nc_temp);\n\t \n\tif (pc != SCRIPTZ_BA(np, snoopend)+8) {\n\t\tprintf (\"CACHE TEST FAILED: script execution failed.\\n\");\n\t\tprintf (\"start=%08lx, pc=%08lx, end=%08lx\\n\", \n\t\t\t(u_long) SCRIPTZ_BA(np, snooptest), (u_long) pc,\n\t\t\t(u_long) SCRIPTZ_BA(np, snoopend) +8);\n\t\treturn (0x40);\n\t}\n\t \n\tif (host_wr != sym_rd) {\n\t\tprintf (\"CACHE TEST FAILED: host wrote %d, chip read %d.\\n\",\n\t\t\t(int) host_wr, (int) sym_rd);\n\t\terr |= 1;\n\t}\n\tif (host_rd != sym_wr) {\n\t\tprintf (\"CACHE TEST FAILED: chip wrote %d, host read %d.\\n\",\n\t\t\t(int) sym_wr, (int) host_rd);\n\t\terr |= 2;\n\t}\n\tif (sym_bk != sym_wr) {\n\t\tprintf (\"CACHE TEST FAILED: chip wrote %d, read back %d.\\n\",\n\t\t\t(int) sym_wr, (int) sym_bk);\n\t\terr |= 4;\n\t}\n\n\treturn err;\n}\n\n \nstatic void sym_log_hard_error(struct Scsi_Host *shost, u_short sist, u_char dstat)\n{\n\tstruct sym_hcb *np = sym_get_hcb(shost);\n\tu32\tdsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL(np, nc_dsp);\n\n\tif\t(dsp > np->scripta_ba &&\n\t\t dsp <= np->scripta_ba + np->scripta_sz) {\n\t\tscript_ofs\t= dsp - np->scripta_ba;\n\t\tscript_size\t= np->scripta_sz;\n\t\tscript_base\t= (u_char *) np->scripta0;\n\t\tscript_name\t= \"scripta\";\n\t}\n\telse if (np->scriptb_ba < dsp && \n\t\t dsp <= np->scriptb_ba + np->scriptb_sz) {\n\t\tscript_ofs\t= dsp - np->scriptb_ba;\n\t\tscript_size\t= np->scriptb_sz;\n\t\tscript_base\t= (u_char *) np->scriptb0;\n\t\tscript_name\t= \"scriptb\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= NULL;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x/%x) @ (%s %x:%08x).\\n\",\n\t\tsym_name(np), (unsigned)INB(np, nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB(np, nc_socl), (unsigned)INB(np, nc_sbcl),\n\t\t(unsigned)INB(np, nc_sbdl), (unsigned)INB(np, nc_sxfer),\n\t\t(unsigned)INB(np, nc_scntl3),\n\t\t(np->features & FE_C10) ?  (unsigned)INB(np, nc_scntl4) : 0,\n\t\tscript_name, script_ofs,   (unsigned)INL(np, nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", sym_name(np),\n\t\t\tscr_to_cpu((int) *(u32 *)(script_base + script_ofs)));\n\t}\n\n\tprintf(\"%s: regdump:\", sym_name(np));\n\tfor (i = 0; i < 24; i++)\n\t\tprintf(\" %02x\", (unsigned)INB_OFF(np, i));\n\tprintf(\".\\n\");\n\n\t \n\tif (dstat & (MDPE|BF))\n\t\tsym_log_bus_error(shost);\n}\n\nvoid sym_dump_registers(struct Scsi_Host *shost)\n{\n\tstruct sym_hcb *np = sym_get_hcb(shost);\n\tu_short sist;\n\tu_char dstat;\n\n\tsist = INW(np, nc_sist);\n\tdstat = INB(np, nc_dstat);\n\tsym_log_hard_error(shost, sist, dstat);\n}\n\nstatic struct sym_chip sym_dev_table[] = {\n {PCI_DEVICE_ID_NCR_53C810, 0x0f, \"810\", 4, 8, 4, 64,\n FE_ERL}\n ,\n#ifdef SYM_DEBUG_GENERIC_SUPPORT\n {PCI_DEVICE_ID_NCR_53C810, 0xff, \"810a\", 4,  8, 4, 1,\n FE_BOF}\n ,\n#else\n {PCI_DEVICE_ID_NCR_53C810, 0xff, \"810a\", 4,  8, 4, 1,\n FE_CACHE_SET|FE_LDSTR|FE_PFEN|FE_BOF}\n ,\n#endif\n {PCI_DEVICE_ID_NCR_53C815, 0xff, \"815\", 4,  8, 4, 64,\n FE_BOF|FE_ERL}\n ,\n {PCI_DEVICE_ID_NCR_53C825, 0x0f, \"825\", 6,  8, 4, 64,\n FE_WIDE|FE_BOF|FE_ERL|FE_DIFF}\n ,\n {PCI_DEVICE_ID_NCR_53C825, 0xff, \"825a\", 6,  8, 4, 2,\n FE_WIDE|FE_CACHE0_SET|FE_BOF|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM|FE_DIFF}\n ,\n {PCI_DEVICE_ID_NCR_53C860, 0xff, \"860\", 4,  8, 5, 1,\n FE_ULTRA|FE_CACHE_SET|FE_BOF|FE_LDSTR|FE_PFEN}\n ,\n {PCI_DEVICE_ID_NCR_53C875, 0x01, \"875\", 6, 16, 5, 2,\n FE_WIDE|FE_ULTRA|FE_CACHE0_SET|FE_BOF|FE_DFS|FE_LDSTR|FE_PFEN|\n FE_RAM|FE_DIFF|FE_VARCLK}\n ,\n {PCI_DEVICE_ID_NCR_53C875, 0xff, \"875\", 6, 16, 5, 2,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE0_SET|FE_BOF|FE_DFS|FE_LDSTR|FE_PFEN|\n FE_RAM|FE_DIFF|FE_VARCLK}\n ,\n {PCI_DEVICE_ID_NCR_53C875J, 0xff, \"875J\", 6, 16, 5, 2,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE0_SET|FE_BOF|FE_DFS|FE_LDSTR|FE_PFEN|\n FE_RAM|FE_DIFF|FE_VARCLK}\n ,\n {PCI_DEVICE_ID_NCR_53C885, 0xff, \"885\", 6, 16, 5, 2,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE0_SET|FE_BOF|FE_DFS|FE_LDSTR|FE_PFEN|\n FE_RAM|FE_DIFF|FE_VARCLK}\n ,\n#ifdef SYM_DEBUG_GENERIC_SUPPORT\n {PCI_DEVICE_ID_NCR_53C895, 0xff, \"895\", 6, 31, 7, 2,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_BOF|FE_DFS|\n FE_RAM|FE_LCKFRQ}\n ,\n#else\n {PCI_DEVICE_ID_NCR_53C895, 0xff, \"895\", 6, 31, 7, 2,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_BOF|FE_DFS|FE_LDSTR|FE_PFEN|\n FE_RAM|FE_LCKFRQ}\n ,\n#endif\n {PCI_DEVICE_ID_NCR_53C896, 0xff, \"896\", 6, 31, 7, 4,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_BOF|FE_DFS|FE_LDSTR|FE_PFEN|\n FE_RAM|FE_RAM8K|FE_64BIT|FE_DAC|FE_IO256|FE_NOPM|FE_LEDC|FE_LCKFRQ}\n ,\n {PCI_DEVICE_ID_LSI_53C895A, 0xff, \"895a\", 6, 31, 7, 4,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_BOF|FE_DFS|FE_LDSTR|FE_PFEN|\n FE_RAM|FE_RAM8K|FE_DAC|FE_IO256|FE_NOPM|FE_LEDC|FE_LCKFRQ}\n ,\n {PCI_DEVICE_ID_LSI_53C875A, 0xff, \"875a\", 6, 31, 7, 4,\n FE_WIDE|FE_ULTRA|FE_QUAD|FE_CACHE_SET|FE_BOF|FE_DFS|FE_LDSTR|FE_PFEN|\n FE_RAM|FE_DAC|FE_IO256|FE_NOPM|FE_LEDC|FE_LCKFRQ}\n ,\n {PCI_DEVICE_ID_LSI_53C1010_33, 0x00, \"1010-33\", 6, 31, 7, 8,\n FE_WIDE|FE_ULTRA3|FE_QUAD|FE_CACHE_SET|FE_BOF|FE_DFBC|FE_LDSTR|FE_PFEN|\n FE_RAM|FE_RAM8K|FE_64BIT|FE_DAC|FE_IO256|FE_NOPM|FE_LEDC|FE_CRC|\n FE_C10}\n ,\n {PCI_DEVICE_ID_LSI_53C1010_33, 0xff, \"1010-33\", 6, 31, 7, 8,\n FE_WIDE|FE_ULTRA3|FE_QUAD|FE_CACHE_SET|FE_BOF|FE_DFBC|FE_LDSTR|FE_PFEN|\n FE_RAM|FE_RAM8K|FE_64BIT|FE_DAC|FE_IO256|FE_NOPM|FE_LEDC|FE_CRC|\n FE_C10|FE_U3EN}\n ,\n {PCI_DEVICE_ID_LSI_53C1010_66, 0xff, \"1010-66\", 6, 31, 7, 8,\n FE_WIDE|FE_ULTRA3|FE_QUAD|FE_CACHE_SET|FE_BOF|FE_DFBC|FE_LDSTR|FE_PFEN|\n FE_RAM|FE_RAM8K|FE_64BIT|FE_DAC|FE_IO256|FE_NOPM|FE_LEDC|FE_66MHZ|FE_CRC|\n FE_C10|FE_U3EN}\n ,\n {PCI_DEVICE_ID_LSI_53C1510, 0xff, \"1510d\", 6, 31, 7, 4,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_BOF|FE_DFS|FE_LDSTR|FE_PFEN|\n FE_RAM|FE_IO256|FE_LEDC}\n};\n\n#define sym_num_devs (ARRAY_SIZE(sym_dev_table))\n\n \nstruct sym_chip *\nsym_lookup_chip_table (u_short device_id, u_char revision)\n{\n\tstruct\tsym_chip *chip;\n\tint\ti;\n\n\tfor (i = 0; i < sym_num_devs; i++) {\n\t\tchip = &sym_dev_table[i];\n\t\tif (device_id != chip->device_id)\n\t\t\tcontinue;\n\t\tif (revision > chip->revision_id)\n\t\t\tcontinue;\n\t\treturn chip;\n\t}\n\n\treturn NULL;\n}\n\n#if SYM_CONF_DMA_ADDRESSING_MODE == 2\n \nint sym_lookup_dmap(struct sym_hcb *np, u32 h, int s)\n{\n\tint i;\n\n\tif (!use_dac(np))\n\t\tgoto weird;\n\n\t \n\tfor (i = SYM_DMAP_SIZE-1; i > 0; i--) {\n\t\tif (h == np->dmap_bah[i])\n\t\t\treturn i;\n\t}\n\t \n\tif (!np->dmap_bah[s])\n\t\tgoto new;\n\t \n\tfor (s = SYM_DMAP_SIZE-1; s > 0; s--) {\n\t\tif (!np->dmap_bah[s])\n\t\t\tgoto new;\n\t}\nweird:\n\tpanic(\"sym: ran out of 64 bit DMA segment registers\");\n\treturn -1;\nnew:\n\tnp->dmap_bah[s] = h;\n\tnp->dmap_dirty = 1;\n\treturn s;\n}\n\n \nstatic void sym_update_dmap_regs(struct sym_hcb *np)\n{\n\tint o, i;\n\n\tif (!np->dmap_dirty)\n\t\treturn;\n\to = offsetof(struct sym_reg, nc_scrx[0]);\n\tfor (i = 0; i < SYM_DMAP_SIZE; i++) {\n\t\tOUTL_OFF(np, o, np->dmap_bah[i]);\n\t\to += 4;\n\t}\n\tnp->dmap_dirty = 0;\n}\n#endif\n\n \nstatic void sym_check_goals(struct sym_hcb *np, struct scsi_target *starget,\n\t\tstruct sym_trans *goal)\n{\n\tif (!spi_support_wide(starget))\n\t\tgoal->width = 0;\n\n\tif (!spi_support_sync(starget)) {\n\t\tgoal->iu = 0;\n\t\tgoal->dt = 0;\n\t\tgoal->qas = 0;\n\t\tgoal->offset = 0;\n\t\treturn;\n\t}\n\n\tif (spi_support_dt(starget)) {\n\t\tif (spi_support_dt_only(starget))\n\t\t\tgoal->dt = 1;\n\n\t\tif (goal->offset == 0)\n\t\t\tgoal->dt = 0;\n\t} else {\n\t\tgoal->dt = 0;\n\t}\n\n\t \n\tif ((np->scsi_mode != SMODE_LVD) || !(np->features & FE_U3EN))\n\t\tgoal->dt = 0;\n\n\tif (goal->dt) {\n\t\t \n\t\tgoal->width = 1;\n\t\tif (goal->offset > np->maxoffs_dt)\n\t\t\tgoal->offset = np->maxoffs_dt;\n\t\tif (goal->period < np->minsync_dt)\n\t\t\tgoal->period = np->minsync_dt;\n\t\tif (goal->period > np->maxsync_dt)\n\t\t\tgoal->period = np->maxsync_dt;\n\t} else {\n\t\tgoal->iu = goal->qas = 0;\n\t\tif (goal->offset > np->maxoffs)\n\t\t\tgoal->offset = np->maxoffs;\n\t\tif (goal->period < np->minsync)\n\t\t\tgoal->period = np->minsync;\n\t\tif (goal->period > np->maxsync)\n\t\t\tgoal->period = np->maxsync;\n\t}\n}\n\n \nstatic int sym_prepare_nego(struct sym_hcb *np, struct sym_ccb *cp, u_char *msgptr)\n{\n\tstruct sym_tcb *tp = &np->target[cp->target];\n\tstruct scsi_target *starget = tp->starget;\n\tstruct sym_trans *goal = &tp->tgoal;\n\tint msglen = 0;\n\tint nego;\n\n\tsym_check_goals(np, starget, goal);\n\n\t \n\tif (goal->renego == NS_PPR || (goal->offset &&\n\t    (goal->iu || goal->dt || goal->qas || (goal->period < 0xa)))) {\n\t\tnego = NS_PPR;\n\t} else if (goal->renego == NS_WIDE || goal->width) {\n\t\tnego = NS_WIDE;\n\t} else if (goal->renego == NS_SYNC || goal->offset) {\n\t\tnego = NS_SYNC;\n\t} else {\n\t\tgoal->check_nego = 0;\n\t\tnego = 0;\n\t}\n\n\tswitch (nego) {\n\tcase NS_SYNC:\n\t\tmsglen += spi_populate_sync_msg(msgptr + msglen, goal->period,\n\t\t\t\tgoal->offset);\n\t\tbreak;\n\tcase NS_WIDE:\n\t\tmsglen += spi_populate_width_msg(msgptr + msglen, goal->width);\n\t\tbreak;\n\tcase NS_PPR:\n\t\tmsglen += spi_populate_ppr_msg(msgptr + msglen, goal->period,\n\t\t\t\tgoal->offset, goal->width,\n\t\t\t\t(goal->iu ? PPR_OPT_IU : 0) |\n\t\t\t\t\t(goal->dt ? PPR_OPT_DT : 0) |\n\t\t\t\t\t(goal->qas ? PPR_OPT_QAS : 0));\n\t\tbreak;\n\t}\n\n\tcp->nego_status = nego;\n\n\tif (nego) {\n\t\ttp->nego_cp = cp;  \n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tsym_print_nego_msg(np, cp->target, \n\t\t\t\t\t  nego == NS_SYNC ? \"sync msgout\" :\n\t\t\t\t\t  nego == NS_WIDE ? \"wide msgout\" :\n\t\t\t\t\t  \"ppr msgout\", msgptr);\n\t\t}\n\t}\n\n\treturn msglen;\n}\n\n \nvoid sym_put_start_queue(struct sym_hcb *np, struct sym_ccb *cp)\n{\n\tu_short\tqidx;\n\n#ifdef SYM_CONF_IARB_SUPPORT\n\t \n\tif (np->last_cp && np->iarb_count < np->iarb_max) {\n\t\tnp->last_cp->host_flags |= HF_HINT_IARB;\n\t\t++np->iarb_count;\n\t}\n\telse\n\t\tnp->iarb_count = 0;\n\tnp->last_cp = cp;\n#endif\n\n#if   SYM_CONF_DMA_ADDRESSING_MODE == 2\n\t \n\tif (np->dmap_dirty)\n\t\tcp->host_xflags |= HX_DMAP_DIRTY;\n#endif\n\n\t \n\tqidx = np->squeueput + 2;\n\tif (qidx >= MAX_QUEUE*2) qidx = 0;\n\n\tnp->squeue [qidx]\t   = cpu_to_scr(np->idletask_ba);\n\tMEMORY_WRITE_BARRIER();\n\tnp->squeue [np->squeueput] = cpu_to_scr(cp->ccb_ba);\n\n\tnp->squeueput = qidx;\n\n\tif (DEBUG_FLAGS & DEBUG_QUEUE)\n\t\tscmd_printk(KERN_DEBUG, cp->cmd, \"queuepos=%d\\n\",\n\t\t\t\t\t\t\tnp->squeueput);\n\n\t \n\tMEMORY_WRITE_BARRIER();\n\tOUTB(np, nc_istat, SIGP|np->istat_sem);\n}\n\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n \nvoid sym_start_next_ccbs(struct sym_hcb *np, struct sym_lcb *lp, int maxn)\n{\n\tSYM_QUEHEAD *qp;\n\tstruct sym_ccb *cp;\n\n\t \n\tassert(!lp->started_tags || !lp->started_no_tag);\n\n\t \n\twhile (maxn--) {\n\t\tqp = sym_remque_head(&lp->waiting_ccbq);\n\t\tif (!qp)\n\t\t\tbreak;\n\t\tcp = sym_que_entry(qp, struct sym_ccb, link2_ccbq);\n\t\tif (cp->tag != NO_TAG) {\n\t\t\tif (lp->started_no_tag ||\n\t\t\t    lp->started_tags >= lp->started_max) {\n\t\t\t\tsym_insque_head(qp, &lp->waiting_ccbq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlp->itlq_tbl[cp->tag] = cpu_to_scr(cp->ccb_ba);\n\t\t\tlp->head.resel_sa =\n\t\t\t\tcpu_to_scr(SCRIPTA_BA(np, resel_tag));\n\t\t\t++lp->started_tags;\n\t\t} else {\n\t\t\tif (lp->started_no_tag || lp->started_tags) {\n\t\t\t\tsym_insque_head(qp, &lp->waiting_ccbq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlp->head.itl_task_sa = cpu_to_scr(cp->ccb_ba);\n\t\t\tlp->head.resel_sa =\n\t\t\t      cpu_to_scr(SCRIPTA_BA(np, resel_no_tag));\n\t\t\t++lp->started_no_tag;\n\t\t}\n\t\tcp->started = 1;\n\t\tsym_insque_tail(qp, &lp->started_ccbq);\n\t\tsym_put_start_queue(np, cp);\n\t}\n}\n#endif  \n\n \nstatic int sym_wakeup_done (struct sym_hcb *np)\n{\n\tstruct sym_ccb *cp;\n\tint i, n;\n\tu32 dsa;\n\n\tn = 0;\n\ti = np->dqueueget;\n\n\t \n\twhile (1) {\n\t\tdsa = scr_to_cpu(np->dqueue[i]);\n\t\tif (!dsa)\n\t\t\tbreak;\n\t\tnp->dqueue[i] = 0;\n\t\tif ((i = i+2) >= MAX_QUEUE*2)\n\t\t\ti = 0;\n\n\t\tcp = sym_ccb_from_dsa(np, dsa);\n\t\tif (cp) {\n\t\t\tMEMORY_READ_BARRIER();\n\t\t\tsym_complete_ok (np, cp);\n\t\t\t++n;\n\t\t}\n\t\telse\n\t\t\tprintf (\"%s: bad DSA (%x) in done queue.\\n\",\n\t\t\t\tsym_name(np), (u_int) dsa);\n\t}\n\tnp->dqueueget = i;\n\n\treturn n;\n}\n\n \nstatic void sym_flush_comp_queue(struct sym_hcb *np, int cam_status)\n{\n\tSYM_QUEHEAD *qp;\n\tstruct sym_ccb *cp;\n\n\twhile ((qp = sym_remque_head(&np->comp_ccbq)) != NULL) {\n\t\tstruct scsi_cmnd *cmd;\n\t\tcp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\n\t\tsym_insque_tail(&cp->link_ccbq, &np->busy_ccbq);\n\t\t \n\t\tif (cp->host_status == HS_WAIT)\n\t\t\tcontinue;\n\t\tcmd = cp->cmd;\n\t\tif (cam_status)\n\t\t\tsym_set_cam_status(cmd, cam_status);\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\t\tif (sym_get_cam_status(cmd) == DID_SOFT_ERROR) {\n\t\t\tstruct sym_tcb *tp = &np->target[cp->target];\n\t\t\tstruct sym_lcb *lp = sym_lp(tp, cp->lun);\n\t\t\tif (lp) {\n\t\t\t\tsym_remque(&cp->link2_ccbq);\n\t\t\t\tsym_insque_tail(&cp->link2_ccbq,\n\t\t\t\t                &lp->waiting_ccbq);\n\t\t\t\tif (cp->started) {\n\t\t\t\t\tif (cp->tag != NO_TAG)\n\t\t\t\t\t\t--lp->started_tags;\n\t\t\t\t\telse\n\t\t\t\t\t\t--lp->started_no_tag;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcp->started = 0;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tsym_free_ccb(np, cp);\n\t\tsym_xpt_done(np, cmd);\n\t}\n}\n\n \nstatic void sym_flush_busy_queue (struct sym_hcb *np, int cam_status)\n{\n\t \n\tsym_que_splice(&np->busy_ccbq, &np->comp_ccbq);\n\tsym_que_init(&np->busy_ccbq);\n\tsym_flush_comp_queue(np, cam_status);\n}\n\n \nvoid sym_start_up(struct Scsi_Host *shost, int reason)\n{\n\tstruct sym_data *sym_data = shost_priv(shost);\n\tstruct pci_dev *pdev = sym_data->pdev;\n\tstruct sym_hcb *np = sym_data->ncb;\n \tint\ti;\n\tu32\tphys;\n\n \t \n\tif (reason == 1)\n\t\tsym_soft_reset(np);\n\telse {\n\t\tOUTB(np, nc_stest3, TE|CSF);\n\t\tOUTONB(np, nc_ctest3, CLF);\n\t}\n \n\t \n\tphys = np->squeue_ba;\n\tfor (i = 0; i < MAX_QUEUE*2; i += 2) {\n\t\tnp->squeue[i]   = cpu_to_scr(np->idletask_ba);\n\t\tnp->squeue[i+1] = cpu_to_scr(phys + (i+2)*4);\n\t}\n\tnp->squeue[MAX_QUEUE*2-1] = cpu_to_scr(phys);\n\n\t \n\tnp->squeueput = 0;\n\n\t \n\tphys = np->dqueue_ba;\n\tfor (i = 0; i < MAX_QUEUE*2; i += 2) {\n\t\tnp->dqueue[i]   = 0;\n\t\tnp->dqueue[i+1] = cpu_to_scr(phys + (i+2)*4);\n\t}\n\tnp->dqueue[MAX_QUEUE*2-1] = cpu_to_scr(phys);\n\n\t \n\tnp->dqueueget = 0;\n\n\t \n\tnp->fw_patch(shost);\n\n\t \n\tsym_flush_busy_queue(np, DID_RESET);\n\n\t \n\tOUTB(np, nc_istat,  0x00);\t\t\t \n\tINB(np, nc_mbox1);\n\tudelay(2000);  \n\n\tOUTB(np, nc_scntl0, np->rv_scntl0 | 0xc0);\n\t\t\t\t\t \n\tOUTB(np, nc_scntl1, 0x00);\t\t \n\n\tsym_selectclock(np, np->rv_scntl3);\t \n\n\tOUTB(np, nc_scid  , RRE|np->myaddr);\t \n\tOUTW(np, nc_respid, 1ul<<np->myaddr);\t \n\tOUTB(np, nc_istat , SIGP\t);\t\t \n\tOUTB(np, nc_dmode , np->rv_dmode);\t\t \n\tOUTB(np, nc_ctest5, np->rv_ctest5);\t \n\n\tOUTB(np, nc_dcntl , NOCOM|np->rv_dcntl);\t \n\tOUTB(np, nc_ctest3, np->rv_ctest3);\t \n\tOUTB(np, nc_ctest4, np->rv_ctest4);\t \n\n\t \n\tif (np->features & FE_C10)\n\t\tOUTB(np, nc_stest2, np->rv_stest2);\n\telse\n\t\tOUTB(np, nc_stest2, EXT|np->rv_stest2);\n\n\tOUTB(np, nc_stest3, TE);\t\t\t \n\tOUTB(np, nc_stime0, 0x0c);\t\t\t \n\n\t \n\tif (pdev->device == PCI_DEVICE_ID_LSI_53C1010_66)\n\t\tOUTB(np, nc_aipcntl1, DISAIP);\n\n\t \n\tif (pdev->device == PCI_DEVICE_ID_LSI_53C1010_33 &&\n\t    pdev->revision < 1)\n\t\tOUTB(np, nc_stest1, INB(np, nc_stest1) | 0x30);\n\n\t \n\tif (pdev->device == PCI_DEVICE_ID_NCR_53C875)\n\t\tOUTB(np, nc_ctest0, (1<<5));\n\telse if (pdev->device == PCI_DEVICE_ID_NCR_53C896)\n\t\tnp->rv_ccntl0 |= DPR;\n\n\t \n\tif (np->features & (FE_DAC|FE_NOPM)) {\n\t\tOUTB(np, nc_ccntl0, np->rv_ccntl0);\n\t\tOUTB(np, nc_ccntl1, np->rv_ccntl1);\n\t}\n\n#if\tSYM_CONF_DMA_ADDRESSING_MODE == 2\n\t \n\tif (use_dac(np)) {\n\t\tnp->dmap_bah[0] = 0;\t \n\t\tOUTL(np, nc_scrx[0], np->dmap_bah[0]);\n\t\tOUTL(np, nc_drs, np->dmap_bah[0]);\n\t}\n#endif\n\n\t \n\tif (np->features & FE_NOPM) {\n\t\tOUTL(np, nc_pmjad1, SCRIPTB_BA(np, pm_handle));\n\t\tOUTL(np, nc_pmjad2, SCRIPTB_BA(np, pm_handle));\n\t}\n\n\t \n\tif (np->features & FE_LED0)\n\t\tOUTB(np, nc_gpcntl, INB(np, nc_gpcntl) & ~0x01);\n\telse if (np->features & FE_LEDC)\n\t\tOUTB(np, nc_gpcntl, (INB(np, nc_gpcntl) & ~0x41) | 0x20);\n\n\t \n\tOUTW(np, nc_sien , STO|HTH|MA|SGE|UDC|RST|PAR);\n\tOUTB(np, nc_dien , MDPE|BF|SSI|SIR|IID);\n\n\t \n\tif (np->features & (FE_ULTRA2|FE_ULTRA3)) {\n\t\tOUTONW(np, nc_sien, SBMC);\n\t\tif (reason == 0) {\n\t\t\tINB(np, nc_mbox1);\n\t\t\tmdelay(100);\n\t\t\tINW(np, nc_sist);\n\t\t}\n\t\tnp->scsi_mode = INB(np, nc_stest4) & SMODE;\n\t}\n\n\t \n\tfor (i=0;i<SYM_CONF_MAX_TARGET;i++) {\n\t\tstruct sym_tcb *tp = &np->target[i];\n\n\t\ttp->to_reset  = 0;\n\t\ttp->head.sval = 0;\n\t\ttp->head.wval = np->rv_scntl3;\n\t\ttp->head.uval = 0;\n\t\tif (tp->lun0p)\n\t\t\ttp->lun0p->to_clear = 0;\n\t\tif (tp->lunmp) {\n\t\t\tint ln;\n\n\t\t\tfor (ln = 1; ln < SYM_CONF_MAX_LUN; ln++)\n\t\t\t\tif (tp->lunmp[ln])\n\t\t\t\t\ttp->lunmp[ln]->to_clear = 0;\n\t\t}\n\t}\n\n\t \n\tphys = SCRIPTA_BA(np, init);\n\tif (np->ram_ba) {\n\t\tif (sym_verbose >= 2)\n\t\t\tprintf(\"%s: Downloading SCSI SCRIPTS.\\n\", sym_name(np));\n\t\tmemcpy_toio(np->s.ramaddr, np->scripta0, np->scripta_sz);\n\t\tif (np->features & FE_RAM8K) {\n\t\t\tmemcpy_toio(np->s.ramaddr + 4096, np->scriptb0, np->scriptb_sz);\n\t\t\tphys = scr_to_cpu(np->scr_ram_seg);\n\t\t\tOUTL(np, nc_mmws, phys);\n\t\t\tOUTL(np, nc_mmrs, phys);\n\t\t\tOUTL(np, nc_sfs,  phys);\n\t\t\tphys = SCRIPTB_BA(np, start64);\n\t\t}\n\t}\n\n\tnp->istat_sem = 0;\n\n\tOUTL(np, nc_dsa, np->hcb_ba);\n\tOUTL_DSP(np, phys);\n\n\t \n\tif (reason != 0)\n\t\tsym_xpt_async_bus_reset(np);\n}\n\n \nstatic void sym_settrans(struct sym_hcb *np, int target, u_char opts, u_char ofs,\n\t\t\t u_char per, u_char wide, u_char div, u_char fak)\n{\n\tSYM_QUEHEAD *qp;\n\tu_char sval, wval, uval;\n\tstruct sym_tcb *tp = &np->target[target];\n\n\tassert(target == (INB(np, nc_sdid) & 0x0f));\n\n\tsval = tp->head.sval;\n\twval = tp->head.wval;\n\tuval = tp->head.uval;\n\n#if 0\n\tprintf(\"XXXX sval=%x wval=%x uval=%x (%x)\\n\", \n\t\tsval, wval, uval, np->rv_scntl3);\n#endif\n\t \n\tif (!(np->features & FE_C10))\n\t\tsval = (sval & ~0x1f) | ofs;\n\telse\n\t\tsval = (sval & ~0x3f) | ofs;\n\n\t \n\tif (ofs != 0) {\n\t\twval = (wval & ~0x70) | ((div+1) << 4);\n\t\tif (!(np->features & FE_C10))\n\t\t\tsval = (sval & ~0xe0) | (fak << 5);\n\t\telse {\n\t\t\tuval = uval & ~(XCLKH_ST|XCLKH_DT|XCLKS_ST|XCLKS_DT);\n\t\t\tif (fak >= 1) uval |= (XCLKH_ST|XCLKH_DT);\n\t\t\tif (fak >= 2) uval |= (XCLKS_ST|XCLKS_DT);\n\t\t}\n\t}\n\n\t \n\twval = wval & ~EWS;\n\tif (wide != 0)\n\t\twval |= EWS;\n\n\t \n\tif (np->features & FE_C10) {\n\t\tuval = uval & ~(U3EN|AIPCKEN);\n\t\tif (opts)\t{\n\t\t\tassert(np->features & FE_U3EN);\n\t\t\tuval |= U3EN;\n\t\t}\n\t} else {\n\t\twval = wval & ~ULTRA;\n\t\tif (per <= 12)\twval |= ULTRA;\n\t}\n\n\t \n\tif (tp->head.sval == sval && \n\t    tp->head.wval == wval &&\n\t    tp->head.uval == uval)\n\t\treturn;\n\ttp->head.sval = sval;\n\ttp->head.wval = wval;\n\ttp->head.uval = uval;\n\n\t \n\tif (per < 50 && !(np->features & FE_C10))\n\t\tOUTOFFB(np, nc_stest2, EXT);\n\n\t \n\tOUTB(np, nc_sxfer,  tp->head.sval);\n\tOUTB(np, nc_scntl3, tp->head.wval);\n\n\tif (np->features & FE_C10) {\n\t\tOUTB(np, nc_scntl4, tp->head.uval);\n\t}\n\n\t \n\tFOR_EACH_QUEUED_ELEMENT(&np->busy_ccbq, qp) {\n\t\tstruct sym_ccb *cp;\n\t\tcp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\n\t\tif (cp->target != target)\n\t\t\tcontinue;\n\t\tcp->phys.select.sel_scntl3 = tp->head.wval;\n\t\tcp->phys.select.sel_sxfer  = tp->head.sval;\n\t\tif (np->features & FE_C10) {\n\t\t\tcp->phys.select.sel_scntl4 = tp->head.uval;\n\t\t}\n\t}\n}\n\nstatic void sym_announce_transfer_rate(struct sym_tcb *tp)\n{\n\tstruct scsi_target *starget = tp->starget;\n\n\tif (tp->tprint.period != spi_period(starget) ||\n\t    tp->tprint.offset != spi_offset(starget) ||\n\t    tp->tprint.width != spi_width(starget) ||\n\t    tp->tprint.iu != spi_iu(starget) ||\n\t    tp->tprint.dt != spi_dt(starget) ||\n\t    tp->tprint.qas != spi_qas(starget) ||\n\t    !tp->tprint.check_nego) {\n\t\ttp->tprint.period = spi_period(starget);\n\t\ttp->tprint.offset = spi_offset(starget);\n\t\ttp->tprint.width = spi_width(starget);\n\t\ttp->tprint.iu = spi_iu(starget);\n\t\ttp->tprint.dt = spi_dt(starget);\n\t\ttp->tprint.qas = spi_qas(starget);\n\t\ttp->tprint.check_nego = 1;\n\n\t\tspi_display_xfer_agreement(starget);\n\t}\n}\n\n \nstatic void sym_setwide(struct sym_hcb *np, int target, u_char wide)\n{\n\tstruct sym_tcb *tp = &np->target[target];\n\tstruct scsi_target *starget = tp->starget;\n\n\tsym_settrans(np, target, 0, 0, 0, wide, 0, 0);\n\n\tif (wide)\n\t\ttp->tgoal.renego = NS_WIDE;\n\telse\n\t\ttp->tgoal.renego = 0;\n\ttp->tgoal.check_nego = 0;\n\ttp->tgoal.width = wide;\n\tspi_offset(starget) = 0;\n\tspi_period(starget) = 0;\n\tspi_width(starget) = wide;\n\tspi_iu(starget) = 0;\n\tspi_dt(starget) = 0;\n\tspi_qas(starget) = 0;\n\n\tif (sym_verbose >= 3)\n\t\tsym_announce_transfer_rate(tp);\n}\n\n \nstatic void\nsym_setsync(struct sym_hcb *np, int target,\n            u_char ofs, u_char per, u_char div, u_char fak)\n{\n\tstruct sym_tcb *tp = &np->target[target];\n\tstruct scsi_target *starget = tp->starget;\n\tu_char wide = (tp->head.wval & EWS) ? BUS_16_BIT : BUS_8_BIT;\n\n\tsym_settrans(np, target, 0, ofs, per, wide, div, fak);\n\n\tif (wide)\n\t\ttp->tgoal.renego = NS_WIDE;\n\telse if (ofs)\n\t\ttp->tgoal.renego = NS_SYNC;\n\telse\n\t\ttp->tgoal.renego = 0;\n\tspi_period(starget) = per;\n\tspi_offset(starget) = ofs;\n\tspi_iu(starget) = spi_dt(starget) = spi_qas(starget) = 0;\n\n\tif (!tp->tgoal.dt && !tp->tgoal.iu && !tp->tgoal.qas) {\n\t\ttp->tgoal.period = per;\n\t\ttp->tgoal.offset = ofs;\n\t\ttp->tgoal.check_nego = 0;\n\t}\n\n\tsym_announce_transfer_rate(tp);\n}\n\n \nstatic void \nsym_setpprot(struct sym_hcb *np, int target, u_char opts, u_char ofs,\n             u_char per, u_char wide, u_char div, u_char fak)\n{\n\tstruct sym_tcb *tp = &np->target[target];\n\tstruct scsi_target *starget = tp->starget;\n\n\tsym_settrans(np, target, opts, ofs, per, wide, div, fak);\n\n\tif (wide || ofs)\n\t\ttp->tgoal.renego = NS_PPR;\n\telse\n\t\ttp->tgoal.renego = 0;\n\tspi_width(starget) = tp->tgoal.width = wide;\n\tspi_period(starget) = tp->tgoal.period = per;\n\tspi_offset(starget) = tp->tgoal.offset = ofs;\n\tspi_iu(starget) = tp->tgoal.iu = !!(opts & PPR_OPT_IU);\n\tspi_dt(starget) = tp->tgoal.dt = !!(opts & PPR_OPT_DT);\n\tspi_qas(starget) = tp->tgoal.qas = !!(opts & PPR_OPT_QAS);\n\ttp->tgoal.check_nego = 0;\n\n\tsym_announce_transfer_rate(tp);\n}\n\n \nstatic void sym_recover_scsi_int (struct sym_hcb *np, u_char hsts)\n{\n\tu32\tdsp\t= INL(np, nc_dsp);\n\tu32\tdsa\t= INL(np, nc_dsa);\n\tstruct sym_ccb *cp\t= sym_ccb_from_dsa(np, dsa);\n\n\t \n\tif ((!(dsp > SCRIPTA_BA(np, getjob_begin) &&\n\t       dsp < SCRIPTA_BA(np, getjob_end) + 1)) &&\n\t    (!(dsp > SCRIPTA_BA(np, ungetjob) &&\n\t       dsp < SCRIPTA_BA(np, reselect) + 1)) &&\n\t    (!(dsp > SCRIPTB_BA(np, sel_for_abort) &&\n\t       dsp < SCRIPTB_BA(np, sel_for_abort_1) + 1)) &&\n\t    (!(dsp > SCRIPTA_BA(np, done) &&\n\t       dsp < SCRIPTA_BA(np, done_end) + 1))) {\n\t\tOUTB(np, nc_ctest3, np->rv_ctest3 | CLF);  \n\t\tOUTB(np, nc_stest3, TE|CSF);\t\t \n\t\t \n\t\tif (cp) {\n\t\t\tcp->host_status = hsts;\n\t\t\tOUTL_DSP(np, SCRIPTA_BA(np, complete_error));\n\t\t}\n\t\t \n\t\telse {\n\t\t\tOUTL(np, nc_dsa, 0xffffff);\n\t\t\tOUTL_DSP(np, SCRIPTA_BA(np, start));\n\t\t}\n\t}\n\telse\n\t\tgoto reset_all;\n\n\treturn;\n\nreset_all:\n\tsym_start_reset(np);\n}\n\n \nstatic void sym_int_sto (struct sym_hcb *np)\n{\n\tu32 dsp\t= INL(np, nc_dsp);\n\n\tif (DEBUG_FLAGS & DEBUG_TINY) printf (\"T\");\n\n\tif (dsp == SCRIPTA_BA(np, wf_sel_done) + 8)\n\t\tsym_recover_scsi_int(np, HS_SEL_TIMEOUT);\n\telse\n\t\tsym_start_reset(np);\n}\n\n \nstatic void sym_int_udc (struct sym_hcb *np)\n{\n\tprintf (\"%s: unexpected disconnect\\n\", sym_name(np));\n\tsym_recover_scsi_int(np, HS_UNEXPECTED);\n}\n\n \nstatic void sym_int_sbmc(struct Scsi_Host *shost)\n{\n\tstruct sym_hcb *np = sym_get_hcb(shost);\n\tu_char scsi_mode = INB(np, nc_stest4) & SMODE;\n\n\t \n\tprintf(\"%s: SCSI BUS mode change from %s to %s.\\n\", sym_name(np),\n\t\tsym_scsi_bus_mode(np->scsi_mode), sym_scsi_bus_mode(scsi_mode));\n\n\t \n\tsym_start_up(shost, 2);\n}\n\n \nstatic void sym_int_par (struct sym_hcb *np, u_short sist)\n{\n\tu_char\thsts\t= INB(np, HS_PRT);\n\tu32\tdsp\t= INL(np, nc_dsp);\n\tu32\tdbc\t= INL(np, nc_dbc);\n\tu32\tdsa\t= INL(np, nc_dsa);\n\tu_char\tsbcl\t= INB(np, nc_sbcl);\n\tu_char\tcmd\t= dbc >> 24;\n\tint phase\t= cmd & 7;\n\tstruct sym_ccb *cp\t= sym_ccb_from_dsa(np, dsa);\n\n\tif (printk_ratelimit())\n\t\tprintf(\"%s: SCSI parity error detected: SCR1=%d DBC=%x SBCL=%x\\n\",\n\t\t\tsym_name(np), hsts, dbc, sbcl);\n\n\t \n\tif (!(INB(np, nc_scntl1) & ISCON)) {\n\t\tsym_recover_scsi_int(np, HS_UNEXPECTED);\n\t\treturn;\n\t}\n\n\t \n\tif (!cp)\n\t\tgoto reset_all;\n\n\t \n\tif ((cmd & 0xc0) || !(phase & 1) || !(sbcl & 0x8))\n\t\tgoto reset_all;\n\n\t \n\tOUTONB(np, HF_PRT, HF_EXT_ERR);\n\tcp->xerr_status |= XE_PARITY_ERR;\n\n\t \n\tnp->msgout[0] = (phase == 7) ? M_PARITY : M_ID_ERROR;\n\n\t \n\tif (phase == 1 || phase == 5) {\n\t\t \n\t\tif (dsp == SCRIPTB_BA(np, pm_handle))\n\t\t\tOUTL_DSP(np, dsp);\n\t\t \n\t\telse if (sist & MA)\n\t\t\tsym_int_ma (np);\n\t\t \n\t\telse {\n\t\t\tsym_set_script_dp (np, cp, dsp);\n\t\t\tOUTL_DSP(np, SCRIPTA_BA(np, dispatch));\n\t\t}\n\t}\n\telse if (phase == 7)\t \n#if 1\t\t\t\t \n\t\tgoto reset_all;  \n#else\n\t\tOUTL_DSP(np, SCRIPTA_BA(np, clrack));\n#endif\n\telse\n\t\tOUTL_DSP(np, SCRIPTA_BA(np, dispatch));\n\treturn;\n\nreset_all:\n\tsym_start_reset(np);\n\treturn;\n}\n\n \nstatic void sym_int_ma (struct sym_hcb *np)\n{\n\tu32\tdbc;\n\tu32\trest;\n\tu32\tdsp;\n\tu32\tdsa;\n\tu32\tnxtdsp;\n\tu32\t*vdsp;\n\tu32\toadr, olen;\n\tu32\t*tblp;\n        u32\tnewcmd;\n\tu_int\tdelta;\n\tu_char\tcmd;\n\tu_char\thflags, hflags0;\n\tstruct\tsym_pmc *pm;\n\tstruct sym_ccb *cp;\n\n\tdsp\t= INL(np, nc_dsp);\n\tdbc\t= INL(np, nc_dbc);\n\tdsa\t= INL(np, nc_dsa);\n\n\tcmd\t= dbc >> 24;\n\trest\t= dbc & 0xffffff;\n\tdelta\t= 0;\n\n\t \n\tcp = sym_ccb_from_dsa(np, dsa);\n\n\t \n\tif ((cmd & 7) != 1 && (cmd & 7) != 5) {\n\t\tu_char ss0, ss2;\n\n\t\tif (np->features & FE_DFBC)\n\t\t\tdelta = INW(np, nc_dfbc);\n\t\telse {\n\t\t\tu32 dfifo;\n\n\t\t\t \n\t\t\tdfifo = INL(np, nc_dfifo);\n\n\t\t\t \n\t\t\tif (dfifo & (DFS << 16))\n\t\t\t\tdelta = ((((dfifo >> 8) & 0x300) |\n\t\t\t\t          (dfifo & 0xff)) - rest) & 0x3ff;\n\t\t\telse\n\t\t\t\tdelta = ((dfifo & 0xff) - rest) & 0x7f;\n\t\t}\n\n\t\t \n\t\trest += delta;\n\t\tss0  = INB(np, nc_sstat0);\n\t\tif (ss0 & OLF) rest++;\n\t\tif (!(np->features & FE_C10))\n\t\t\tif (ss0 & ORF) rest++;\n\t\tif (cp && (cp->phys.select.sel_scntl3 & EWS)) {\n\t\t\tss2 = INB(np, nc_sstat2);\n\t\t\tif (ss2 & OLF1) rest++;\n\t\t\tif (!(np->features & FE_C10))\n\t\t\t\tif (ss2 & ORF1) rest++;\n\t\t}\n\n\t\t \n\t\tOUTB(np, nc_ctest3, np->rv_ctest3 | CLF);\t \n\t\tOUTB(np, nc_stest3, TE|CSF);\t\t \n\t}\n\n\t \n\tif (DEBUG_FLAGS & (DEBUG_TINY|DEBUG_PHASE))\n\t\tprintf (\"P%x%x RL=%d D=%d \", cmd&7, INB(np, nc_sbcl)&7,\n\t\t\t(unsigned) rest, (unsigned) delta);\n\n\t \n\tvdsp\t= NULL;\n\tnxtdsp\t= 0;\n\tif\t(dsp >  np->scripta_ba &&\n\t\t dsp <= np->scripta_ba + np->scripta_sz) {\n\t\tvdsp = (u32 *)((char*)np->scripta0 + (dsp-np->scripta_ba-8));\n\t\tnxtdsp = dsp;\n\t}\n\telse if\t(dsp >  np->scriptb_ba &&\n\t\t dsp <= np->scriptb_ba + np->scriptb_sz) {\n\t\tvdsp = (u32 *)((char*)np->scriptb0 + (dsp-np->scriptb_ba-8));\n\t\tnxtdsp = dsp;\n\t}\n\n\t \n\tif (DEBUG_FLAGS & DEBUG_PHASE) {\n\t\tprintf (\"\\nCP=%p DSP=%x NXT=%x VDSP=%p CMD=%x \",\n\t\t\tcp, (unsigned)dsp, (unsigned)nxtdsp, vdsp, cmd);\n\t}\n\n\tif (!vdsp) {\n\t\tprintf (\"%s: interrupted SCRIPT address not found.\\n\", \n\t\t\tsym_name (np));\n\t\tgoto reset_all;\n\t}\n\n\tif (!cp) {\n\t\tprintf (\"%s: SCSI phase error fixup: CCB already dequeued.\\n\", \n\t\t\tsym_name (np));\n\t\tgoto reset_all;\n\t}\n\n\t \n\toadr = scr_to_cpu(vdsp[1]);\n\n\tif (cmd & 0x10) {\t \n\t\ttblp = (u32 *) ((char*) &cp->phys + oadr);\n\t\tolen = scr_to_cpu(tblp[0]);\n\t\toadr = scr_to_cpu(tblp[1]);\n\t} else {\n\t\ttblp = (u32 *) 0;\n\t\tolen = scr_to_cpu(vdsp[0]) & 0xffffff;\n\t}\n\n\tif (DEBUG_FLAGS & DEBUG_PHASE) {\n\t\tprintf (\"OCMD=%x\\nTBLP=%p OLEN=%x OADR=%x\\n\",\n\t\t\t(unsigned) (scr_to_cpu(vdsp[0]) >> 24),\n\t\t\ttblp,\n\t\t\t(unsigned) olen,\n\t\t\t(unsigned) oadr);\n\t}\n\n\t \n\tif (((cmd & 2) ? cmd : (cmd & ~4)) != (scr_to_cpu(vdsp[0]) >> 24)) {\n\t\tsym_print_addr(cp->cmd,\n\t\t\t\"internal error: cmd=%02x != %02x=(vdsp[0] >> 24)\\n\",\n\t\t\tcmd, scr_to_cpu(vdsp[0]) >> 24);\n\n\t\tgoto reset_all;\n\t}\n\n\t \n\tif (cmd & 2) {\n\t\tsym_print_addr(cp->cmd,\n\t\t\t\"phase change %x-%x %d@%08x resid=%d.\\n\",\n\t\t\tcmd&7, INB(np, nc_sbcl)&7, (unsigned)olen,\n\t\t\t(unsigned)oadr, (unsigned)rest);\n\t\tgoto unexpected_phase;\n\t}\n\n\t \n\thflags0 = INB(np, HF_PRT);\n\thflags = hflags0;\n\n\tif (hflags & (HF_IN_PM0 | HF_IN_PM1 | HF_DP_SAVED)) {\n\t\tif (hflags & HF_IN_PM0)\n\t\t\tnxtdsp = scr_to_cpu(cp->phys.pm0.ret);\n\t\telse if\t(hflags & HF_IN_PM1)\n\t\t\tnxtdsp = scr_to_cpu(cp->phys.pm1.ret);\n\n\t\tif (hflags & HF_DP_SAVED)\n\t\t\thflags ^= HF_ACT_PM;\n\t}\n\n\tif (!(hflags & HF_ACT_PM)) {\n\t\tpm = &cp->phys.pm0;\n\t\tnewcmd = SCRIPTA_BA(np, pm0_data);\n\t}\n\telse {\n\t\tpm = &cp->phys.pm1;\n\t\tnewcmd = SCRIPTA_BA(np, pm1_data);\n\t}\n\n\thflags &= ~(HF_IN_PM0 | HF_IN_PM1 | HF_DP_SAVED);\n\tif (hflags != hflags0)\n\t\tOUTB(np, HF_PRT, hflags);\n\n\t \n\tpm->sg.addr = cpu_to_scr(oadr + olen - rest);\n\tpm->sg.size = cpu_to_scr(rest);\n\tpm->ret     = cpu_to_scr(nxtdsp);\n\n\t \n\tnxtdsp = SCRIPTA_BA(np, dispatch);\n\tif ((cmd & 7) == 1 && cp && (cp->phys.select.sel_scntl3 & EWS) &&\n\t    (INB(np, nc_scntl2) & WSR)) {\n\t\tu32 tmp;\n\n\t\t \n\t\ttmp = scr_to_cpu(pm->sg.addr);\n\t\tcp->phys.wresid.addr = cpu_to_scr(tmp);\n\t\tpm->sg.addr = cpu_to_scr(tmp + 1);\n\t\ttmp = scr_to_cpu(pm->sg.size);\n\t\tcp->phys.wresid.size = cpu_to_scr((tmp&0xff000000) | 1);\n\t\tpm->sg.size = cpu_to_scr(tmp - 1);\n\n\t\t \n\t\tif ((tmp&0xffffff) == 1)\n\t\t\tnewcmd = pm->ret;\n\n\t\t \n\t\tnxtdsp = SCRIPTB_BA(np, wsr_ma_helper);\n\t}\n\n\tif (DEBUG_FLAGS & DEBUG_PHASE) {\n\t\tsym_print_addr(cp->cmd, \"PM %x %x %x / %x %x %x.\\n\",\n\t\t\thflags0, hflags, newcmd,\n\t\t\t(unsigned)scr_to_cpu(pm->sg.addr),\n\t\t\t(unsigned)scr_to_cpu(pm->sg.size),\n\t\t\t(unsigned)scr_to_cpu(pm->ret));\n\t}\n\n\t \n\tsym_set_script_dp (np, cp, newcmd);\n\tOUTL_DSP(np, nxtdsp);\n\treturn;\n\n\t \nunexpected_phase:\n\tdsp -= 8;\n\tnxtdsp = 0;\n\n\tswitch (cmd & 7) {\n\tcase 2:\t \n\t\tnxtdsp = SCRIPTA_BA(np, dispatch);\n\t\tbreak;\n#if 0\n\tcase 3:\t \n\t\tnxtdsp = SCRIPTA_BA(np, dispatch);\n\t\tbreak;\n#endif\n\tcase 6:\t \n\t\t \n\t\tif\t(dsp == SCRIPTA_BA(np, send_ident)) {\n\t\t\tif (cp->tag != NO_TAG && olen - rest <= 3) {\n\t\t\t\tcp->host_status = HS_BUSY;\n\t\t\t\tnp->msgout[0] = IDENTIFY(0, cp->lun);\n\t\t\t\tnxtdsp = SCRIPTB_BA(np, ident_break_atn);\n\t\t\t}\n\t\t\telse\n\t\t\t\tnxtdsp = SCRIPTB_BA(np, ident_break);\n\t\t}\n\t\telse if\t(dsp == SCRIPTB_BA(np, send_wdtr) ||\n\t\t\t dsp == SCRIPTB_BA(np, send_sdtr) ||\n\t\t\t dsp == SCRIPTB_BA(np, send_ppr)) {\n\t\t\tnxtdsp = SCRIPTB_BA(np, nego_bad_phase);\n\t\t\tif (dsp == SCRIPTB_BA(np, send_ppr)) {\n\t\t\t\tstruct scsi_device *dev = cp->cmd->device;\n\t\t\t\tdev->ppr = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n#if 0\n\tcase 7:\t \n\t\tnxtdsp = SCRIPTA_BA(np, clrack);\n\t\tbreak;\n#endif\n\t}\n\n\tif (nxtdsp) {\n\t\tOUTL_DSP(np, nxtdsp);\n\t\treturn;\n\t}\n\nreset_all:\n\tsym_start_reset(np);\n}\n\n \n\nirqreturn_t sym_interrupt(struct Scsi_Host *shost)\n{\n\tstruct sym_data *sym_data = shost_priv(shost);\n\tstruct sym_hcb *np = sym_data->ncb;\n\tstruct pci_dev *pdev = sym_data->pdev;\n\tu_char\tistat, istatc;\n\tu_char\tdstat;\n\tu_short\tsist;\n\n\t \n\tistat = INB(np, nc_istat);\n\tif (istat & INTF) {\n\t\tOUTB(np, nc_istat, (istat & SIGP) | INTF | np->istat_sem);\n\t\tistat |= INB(np, nc_istat);\t\t \n\t\tif (DEBUG_FLAGS & DEBUG_TINY) printf (\"F \");\n\t\tsym_wakeup_done(np);\n\t}\n\n\tif (!(istat & (SIP|DIP)))\n\t\treturn (istat & INTF) ? IRQ_HANDLED : IRQ_NONE;\n\n#if 0\t \n\tif (istat & CABRT)\n\t\tOUTB(np, nc_istat, CABRT);\n#endif\n\n\t \n\tsist\t= 0;\n\tdstat\t= 0;\n\tistatc\t= istat;\n\tdo {\n\t\tif (istatc & SIP)\n\t\t\tsist  |= INW(np, nc_sist);\n\t\tif (istatc & DIP)\n\t\t\tdstat |= INB(np, nc_dstat);\n\t\tistatc = INB(np, nc_istat);\n\t\tistat |= istatc;\n\n\t\t \n\t\tif (unlikely(sist == 0xffff && dstat == 0xff)) {\n\t\t\tif (pci_channel_offline(pdev))\n\t\t\t\treturn IRQ_NONE;\n\t\t}\n\t} while (istatc & (SIP|DIP));\n\n\tif (DEBUG_FLAGS & DEBUG_TINY)\n\t\tprintf (\"<%d|%x:%x|%x:%x>\",\n\t\t\t(int)INB(np, nc_scr0),\n\t\t\tdstat,sist,\n\t\t\t(unsigned)INL(np, nc_dsp),\n\t\t\t(unsigned)INL(np, nc_dbc));\n\t \n\tMEMORY_READ_BARRIER();\n\n\t \n\tif (!(sist  & (STO|GEN|HTH|SGE|UDC|SBMC|RST)) &&\n\t    !(dstat & (MDPE|BF|ABRT|IID))) {\n\t\tif\t(sist & PAR)\tsym_int_par (np, sist);\n\t\telse if (sist & MA)\tsym_int_ma (np);\n\t\telse if (dstat & SIR)\tsym_int_sir(np);\n\t\telse if (dstat & SSI)\tOUTONB_STD();\n\t\telse\t\t\tgoto unknown_int;\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (sist & RST) {\n\t\tprintf(\"%s: SCSI BUS reset detected.\\n\", sym_name(np));\n\t\tsym_start_up(shost, 1);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tOUTB(np, nc_ctest3, np->rv_ctest3 | CLF);\t \n\tOUTB(np, nc_stest3, TE|CSF);\t\t \n\n\tif (!(sist  & (GEN|HTH|SGE)) &&\n\t    !(dstat & (MDPE|BF|ABRT|IID))) {\n\t\tif\t(sist & SBMC)\tsym_int_sbmc(shost);\n\t\telse if (sist & STO)\tsym_int_sto (np);\n\t\telse if (sist & UDC)\tsym_int_udc (np);\n\t\telse\t\t\tgoto unknown_int;\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\n\tsym_log_hard_error(shost, sist, dstat);\n\n\tif ((sist & (GEN|HTH|SGE)) ||\n\t\t(dstat & (MDPE|BF|ABRT|IID))) {\n\t\tsym_start_reset(np);\n\t\treturn IRQ_HANDLED;\n\t}\n\nunknown_int:\n\t \n\tprintf(\t\"%s: unknown interrupt(s) ignored, \"\n\t\t\"ISTAT=0x%x DSTAT=0x%x SIST=0x%x\\n\",\n\t\tsym_name(np), istat, dstat, sist);\n\treturn IRQ_NONE;\n}\n\n \nstatic int \nsym_dequeue_from_squeue(struct sym_hcb *np, int i, int target, int lun, int task)\n{\n\tint j;\n\tstruct sym_ccb *cp;\n\n\t \n\tassert((i >= 0) && (i < 2*MAX_QUEUE));\n\n\t \n\tj = i;\n\twhile (i != np->squeueput) {\n\t\tcp = sym_ccb_from_dsa(np, scr_to_cpu(np->squeue[i]));\n\t\tassert(cp);\n#ifdef SYM_CONF_IARB_SUPPORT\n\t\t \n\t\tcp->host_flags &= ~HF_HINT_IARB;\n#endif\n\t\tif ((target == -1 || cp->target == target) &&\n\t\t    (lun    == -1 || cp->lun    == lun)    &&\n\t\t    (task   == -1 || cp->tag    == task)) {\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\t\t\tsym_set_cam_status(cp->cmd, DID_SOFT_ERROR);\n#else\n\t\t\tsym_set_cam_status(cp->cmd, DID_REQUEUE);\n#endif\n\t\t\tsym_remque(&cp->link_ccbq);\n\t\t\tsym_insque_tail(&cp->link_ccbq, &np->comp_ccbq);\n\t\t}\n\t\telse {\n\t\t\tif (i != j)\n\t\t\t\tnp->squeue[j] = np->squeue[i];\n\t\t\tif ((j += 2) >= MAX_QUEUE*2) j = 0;\n\t\t}\n\t\tif ((i += 2) >= MAX_QUEUE*2) i = 0;\n\t}\n\tif (i != j)\t\t \n\t\tnp->squeue[j] = np->squeue[i];\n\tnp->squeueput = j;\t \n\n\treturn (i - j) / 2;\n}\n\n \nstatic void sym_sir_bad_scsi_status(struct sym_hcb *np, int num, struct sym_ccb *cp)\n{\n\tu32\t\tstartp;\n\tu_char\t\ts_status = cp->ssss_status;\n\tu_char\t\th_flags  = cp->host_flags;\n\tint\t\tmsglen;\n\tint\t\ti;\n\n\t \n\ti = (INL(np, nc_scratcha) - np->squeue_ba) / 4;\n\n\t \n#ifdef SYM_CONF_IARB_SUPPORT\n\tif (np->last_cp)\n\t\tnp->last_cp = 0;\n#endif\n\n\t \n\tswitch(s_status) {\n\tcase S_BUSY:\n\tcase S_QUEUE_FULL:\n\t\tif (sym_verbose >= 2) {\n\t\t\tsym_print_addr(cp->cmd, \"%s\\n\",\n\t\t\t        s_status == S_BUSY ? \"BUSY\" : \"QUEUE FULL\\n\");\n\t\t}\n\t\tfallthrough;\n\tdefault:\t \n\t\tsym_complete_error (np, cp);\n\t\tbreak;\n\tcase S_TERMINATED:\n\tcase S_CHECK_COND:\n\t\t \n\t\tif (h_flags & HF_SENSE) {\n\t\t\tsym_complete_error (np, cp);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tsym_dequeue_from_squeue(np, i, cp->target, cp->lun, -1);\n\t\tOUTL_DSP(np, SCRIPTA_BA(np, start));\n\n \t\t \n\t\tcp->sv_scsi_status = cp->ssss_status;\n\t\tcp->sv_xerr_status = cp->xerr_status;\n\t\tcp->sv_resid = sym_compute_residual(np, cp);\n\n\t\t \n\n\t\tcp->scsi_smsg2[0] = IDENTIFY(0, cp->lun);\n\t\tmsglen = 1;\n\n\t\t \n\t\tcp->nego_status = 0;\n\t\tmsglen += sym_prepare_nego(np, cp, &cp->scsi_smsg2[msglen]);\n\t\t \n\t\tcp->phys.smsg.addr\t= CCB_BA(cp, scsi_smsg2);\n\t\tcp->phys.smsg.size\t= cpu_to_scr(msglen);\n\n\t\t \n\t\tcp->phys.cmd.addr\t= CCB_BA(cp, sensecmd);\n\t\tcp->phys.cmd.size\t= cpu_to_scr(6);\n\n\t\t \n\t\tcp->sensecmd[0]\t\t= REQUEST_SENSE;\n\t\tcp->sensecmd[1]\t\t= 0;\n\t\tif (cp->cmd->device->scsi_level <= SCSI_2 && cp->lun <= 7)\n\t\t\tcp->sensecmd[1]\t= cp->lun << 5;\n\t\tcp->sensecmd[4]\t\t= SYM_SNS_BBUF_LEN;\n\t\tcp->data_len\t\t= SYM_SNS_BBUF_LEN;\n\n\t\t \n\t\tmemset(cp->sns_bbuf, 0, SYM_SNS_BBUF_LEN);\n\t\tcp->phys.sense.addr\t= CCB_BA(cp, sns_bbuf);\n\t\tcp->phys.sense.size\t= cpu_to_scr(SYM_SNS_BBUF_LEN);\n\n\t\t \n\t\tstartp = SCRIPTB_BA(np, sdata_in);\n\n\t\tcp->phys.head.savep\t= cpu_to_scr(startp);\n\t\tcp->phys.head.lastp\t= cpu_to_scr(startp);\n\t\tcp->startp\t\t= cpu_to_scr(startp);\n\t\tcp->goalp\t\t= cpu_to_scr(startp + 16);\n\n\t\tcp->host_xflags = 0;\n\t\tcp->host_status\t= cp->nego_status ? HS_NEGOTIATE : HS_BUSY;\n\t\tcp->ssss_status = S_ILLEGAL;\n\t\tcp->host_flags\t= (HF_SENSE|HF_DATA_IN);\n\t\tcp->xerr_status = 0;\n\t\tcp->extra_bytes = 0;\n\n\t\tcp->phys.head.go.start = cpu_to_scr(SCRIPTA_BA(np, select));\n\n\t\t \n\t\tsym_put_start_queue(np, cp);\n\n\t\t \n\t\tsym_flush_comp_queue(np, 0);\n\t\tbreak;\n\t}\n}\n\n \nint sym_clear_tasks(struct sym_hcb *np, int cam_status, int target, int lun, int task)\n{\n\tSYM_QUEHEAD qtmp, *qp;\n\tint i = 0;\n\tstruct sym_ccb *cp;\n\n\t \n\tsym_que_init(&qtmp);\n\tsym_que_splice(&np->busy_ccbq, &qtmp);\n\tsym_que_init(&np->busy_ccbq);\n\n\t \n\twhile ((qp = sym_remque_head(&qtmp)) != NULL) {\n\t\tstruct scsi_cmnd *cmd;\n\t\tcp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\n\t\tcmd = cp->cmd;\n\t\tif (cp->host_status != HS_DISCONNECT ||\n\t\t    cp->target != target\t     ||\n\t\t    (lun  != -1 && cp->lun != lun)   ||\n\t\t    (task != -1 && \n\t\t\t(cp->tag != NO_TAG && cp->scsi_smsg[2] != task))) {\n\t\t\tsym_insque_tail(&cp->link_ccbq, &np->busy_ccbq);\n\t\t\tcontinue;\n\t\t}\n\t\tsym_insque_tail(&cp->link_ccbq, &np->comp_ccbq);\n\n\t\t \n\t\tif (sym_get_cam_status(cmd) != DID_TIME_OUT)\n\t\t\tsym_set_cam_status(cmd, cam_status);\n\t\t++i;\n#if 0\nprintf(\"XXXX TASK @%p CLEARED\\n\", cp);\n#endif\n\t}\n\treturn i;\n}\n\n \nstatic void sym_sir_task_recovery(struct sym_hcb *np, int num)\n{\n\tSYM_QUEHEAD *qp;\n\tstruct sym_ccb *cp;\n\tstruct sym_tcb *tp = NULL;  \n\tstruct scsi_target *starget;\n\tint target=-1, lun=-1, task;\n\tint i, k;\n\n\tswitch(num) {\n\t \n\tcase SIR_SCRIPT_STOPPED:\n\t\t \n\t\tfor (i = 0 ; i < SYM_CONF_MAX_TARGET ; i++) {\n\t\t\ttp = &np->target[i];\n\t\t\tif (tp->to_reset || \n\t\t\t    (tp->lun0p && tp->lun0p->to_clear)) {\n\t\t\t\ttarget = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!tp->lunmp)\n\t\t\t\tcontinue;\n\t\t\tfor (k = 1 ; k < SYM_CONF_MAX_LUN ; k++) {\n\t\t\t\tif (tp->lunmp[k] && tp->lunmp[k]->to_clear) {\n\t\t\t\t\ttarget\t= i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (target != -1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (target == -1) {\n\t\t\tFOR_EACH_QUEUED_ELEMENT(&np->busy_ccbq, qp) {\n\t\t\t\tcp = sym_que_entry(qp,struct sym_ccb,link_ccbq);\n\t\t\t\tif (cp->host_status != HS_DISCONNECT)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (cp->to_abort) {\n\t\t\t\t\ttarget = cp->target;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (target != -1) {\n\t\t\ttp = &np->target[target];\n\t\t\tnp->abrt_sel.sel_id\t= target;\n\t\t\tnp->abrt_sel.sel_scntl3 = tp->head.wval;\n\t\t\tnp->abrt_sel.sel_sxfer  = tp->head.sval;\n\t\t\tOUTL(np, nc_dsa, np->hcb_ba);\n\t\t\tOUTL_DSP(np, SCRIPTB_BA(np, sel_for_abort));\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\ti = 0;\n\t\tcp = NULL;\n\t\tFOR_EACH_QUEUED_ELEMENT(&np->busy_ccbq, qp) {\n\t\t\tcp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\n\t\t\tif (cp->host_status != HS_BUSY &&\n\t\t\t    cp->host_status != HS_NEGOTIATE)\n\t\t\t\tcontinue;\n\t\t\tif (!cp->to_abort)\n\t\t\t\tcontinue;\n#ifdef SYM_CONF_IARB_SUPPORT\n\t\t\t \n\t\t\tif (cp == np->last_cp) {\n\t\t\t\tcp->to_abort = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\ti = 1;\t \n\t\t\tbreak;\n\t\t}\n\t\tif (!i) {\n\t\t\t \n\t\t\tnp->istat_sem = 0;\n\t\t\tOUTB(np, nc_istat, SIGP);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\ti = (INL(np, nc_scratcha) - np->squeue_ba) / 4;\n\t\ti = sym_dequeue_from_squeue(np, i, cp->target, cp->lun, -1);\n\n\t\t \n#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\t\tassert(i && sym_get_cam_status(cp->cmd) == DID_SOFT_ERROR);\n#else\n\t\tsym_remque(&cp->link_ccbq);\n\t\tsym_insque_tail(&cp->link_ccbq, &np->comp_ccbq);\n#endif\n\t\t \n\t\tif (cp->to_abort == 2)\n\t\t\tsym_set_cam_status(cp->cmd, DID_TIME_OUT);\n\t\telse\n\t\t\tsym_set_cam_status(cp->cmd, DID_ABORT);\n\n\t\t \n\t\tsym_flush_comp_queue(np, 0);\n\t\tbreak;\n\t \n\tcase SIR_TARGET_SELECTED:\n\t\ttarget = INB(np, nc_sdid) & 0xf;\n\t\ttp = &np->target[target];\n\n\t\tnp->abrt_tbl.addr = cpu_to_scr(vtobus(np->abrt_msg));\n\n\t\t \n\t\tif (tp->to_reset) {\n\t\t\tnp->abrt_msg[0] = M_RESET;\n\t\t\tnp->abrt_tbl.size = 1;\n\t\t\ttp->to_reset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (tp->lun0p && tp->lun0p->to_clear)\n\t\t\tlun = 0;\n\t\telse if (tp->lunmp) {\n\t\t\tfor (k = 1 ; k < SYM_CONF_MAX_LUN ; k++) {\n\t\t\t\tif (tp->lunmp[k] && tp->lunmp[k]->to_clear) {\n\t\t\t\t\tlun = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (lun != -1) {\n\t\t\tstruct sym_lcb *lp = sym_lp(tp, lun);\n\t\t\tlp->to_clear = 0;  \n\t\t\tnp->abrt_msg[0] = IDENTIFY(0, lun);\n\t\t\tnp->abrt_msg[1] = M_ABORT;\n\t\t\tnp->abrt_tbl.size = 2;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\ti = 0;\n\t\tcp = NULL;\n\t\tFOR_EACH_QUEUED_ELEMENT(&np->busy_ccbq, qp) {\n\t\t\tcp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\n\t\t\tif (cp->host_status != HS_DISCONNECT)\n\t\t\t\tcontinue;\n\t\t\tif (cp->target != target)\n\t\t\t\tcontinue;\n\t\t\tif (!cp->to_abort)\n\t\t\t\tcontinue;\n\t\t\ti = 1;\t \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!i) {\n\t\t\tnp->abrt_msg[0] = M_ABORT;\n\t\t\tnp->abrt_tbl.size = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tnp->abrt_msg[0] = IDENTIFY(0, cp->lun);\n\n\t\t \n\t\tif (cp->tag == NO_TAG) {\n\t\t\tnp->abrt_msg[1] = M_ABORT;\n\t\t\tnp->abrt_tbl.size = 2;\n\t\t} else {\n\t\t\tnp->abrt_msg[1] = cp->scsi_smsg[1];\n\t\t\tnp->abrt_msg[2] = cp->scsi_smsg[2];\n\t\t\tnp->abrt_msg[3] = M_ABORT_TAG;\n\t\t\tnp->abrt_tbl.size = 4;\n\t\t}\n\t\t \n\t\tif (cp->to_abort == 2)\n\t\t\tsym_set_cam_status(cp->cmd, DID_TIME_OUT);\n\t\tcp->to_abort = 0;  \n\t\tbreak;\n\n\t \n\tcase SIR_ABORT_SENT:\n\t\ttarget = INB(np, nc_sdid) & 0xf;\n\t\ttp = &np->target[target];\n\t\tstarget = tp->starget;\n\t\t\n\t\t \n\t\tif (np->abrt_msg[0] == M_ABORT)\n\t\t\tbreak;\n\n\t\t \n\t\tlun = -1;\n\t\ttask = -1;\n\t\tif (np->abrt_msg[0] == M_RESET) {\n\t\t\ttp->head.sval = 0;\n\t\t\ttp->head.wval = np->rv_scntl3;\n\t\t\ttp->head.uval = 0;\n\t\t\tspi_period(starget) = 0;\n\t\t\tspi_offset(starget) = 0;\n\t\t\tspi_width(starget) = 0;\n\t\t\tspi_iu(starget) = 0;\n\t\t\tspi_dt(starget) = 0;\n\t\t\tspi_qas(starget) = 0;\n\t\t\ttp->tgoal.check_nego = 1;\n\t\t\ttp->tgoal.renego = 0;\n\t\t}\n\n\t\t \n\t\telse {\n\t\t\tlun = np->abrt_msg[0] & 0x3f;\n\t\t\tif (np->abrt_msg[1] == M_ABORT_TAG)\n\t\t\t\ttask = np->abrt_msg[2];\n\t\t}\n\n\t\t \n\t\ti = (INL(np, nc_scratcha) - np->squeue_ba) / 4;\n\t\tsym_dequeue_from_squeue(np, i, target, lun, -1);\n\t\tsym_clear_tasks(np, DID_ABORT, target, lun, task);\n\t\tsym_flush_comp_queue(np, 0);\n\n \t\t \n\t\tif (np->abrt_msg[0] == M_RESET)\n\t\t\tstarget_printk(KERN_NOTICE, starget,\n\t\t\t\t\t\t\t\"has been reset\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tif (num == SIR_TARGET_SELECTED) {\n\t\tdev_info(&tp->starget->dev, \"control msgout:\");\n\t\tsym_printl_hex(np->abrt_msg, np->abrt_tbl.size);\n\t\tnp->abrt_tbl.size = cpu_to_scr(np->abrt_tbl.size);\n\t}\n\n\t \n\tOUTONB_STD();\n}\n\n \n\nstatic int sym_evaluate_dp(struct sym_hcb *np, struct sym_ccb *cp, u32 scr, int *ofs)\n{\n\tu32\tdp_scr;\n\tint\tdp_ofs, dp_sg, dp_sgmin;\n\tint\ttmp;\n\tstruct sym_pmc *pm;\n\n\t \n\tdp_scr = scr;\n\tdp_ofs = *ofs;\n\tif\t(dp_scr == SCRIPTA_BA(np, pm0_data))\n\t\tpm = &cp->phys.pm0;\n\telse if (dp_scr == SCRIPTA_BA(np, pm1_data))\n\t\tpm = &cp->phys.pm1;\n\telse\n\t\tpm = NULL;\n\n\tif (pm) {\n\t\tdp_scr  = scr_to_cpu(pm->ret);\n\t\tdp_ofs -= scr_to_cpu(pm->sg.size) & 0x00ffffff;\n\t}\n\n\t \n\tif (cp->host_flags & HF_SENSE) {\n\t\t*ofs = dp_ofs;\n\t\treturn 0;\n\t}\n\n\t \n\ttmp = scr_to_cpu(cp->goalp);\n\tdp_sg = SYM_CONF_MAX_SG;\n\tif (dp_scr != tmp)\n\t\tdp_sg -= (tmp - 8 - (int)dp_scr) / (2*4);\n\tdp_sgmin = SYM_CONF_MAX_SG - cp->segments;\n\n\t \n\tif (dp_ofs < 0) {\n\t\tint n;\n\t\twhile (dp_sg > dp_sgmin) {\n\t\t\t--dp_sg;\n\t\t\ttmp = scr_to_cpu(cp->phys.data[dp_sg].size);\n\t\t\tn = dp_ofs + (tmp & 0xffffff);\n\t\t\tif (n > 0) {\n\t\t\t\t++dp_sg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdp_ofs = n;\n\t\t}\n\t}\n\telse if (dp_ofs > 0) {\n\t\twhile (dp_sg < SYM_CONF_MAX_SG) {\n\t\t\ttmp = scr_to_cpu(cp->phys.data[dp_sg].size);\n\t\t\tdp_ofs -= (tmp & 0xffffff);\n\t\t\t++dp_sg;\n\t\t\tif (dp_ofs <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif\t(dp_sg < dp_sgmin || (dp_sg == dp_sgmin && dp_ofs < 0))\n\t\tgoto out_err;\n\telse if\t(dp_sg > SYM_CONF_MAX_SG ||\n\t\t (dp_sg == SYM_CONF_MAX_SG && dp_ofs > 0))\n\t\tgoto out_err;\n\n\t \n\tif (dp_sg > cp->ext_sg ||\n            (dp_sg == cp->ext_sg && dp_ofs > cp->ext_ofs)) {\n\t\tcp->ext_sg  = dp_sg;\n\t\tcp->ext_ofs = dp_ofs;\n\t}\n\n\t \n\t*ofs = dp_ofs;\n\treturn dp_sg;\n\nout_err:\n\treturn -1;\n}\n\n \n\nstatic void sym_modify_dp(struct sym_hcb *np, struct sym_tcb *tp, struct sym_ccb *cp, int ofs)\n{\n\tint dp_ofs\t= ofs;\n\tu32\tdp_scr\t= sym_get_script_dp (np, cp);\n\tu32\tdp_ret;\n\tu32\ttmp;\n\tu_char\thflags;\n\tint\tdp_sg;\n\tstruct\tsym_pmc *pm;\n\n\t \n\tif (cp->host_flags & HF_SENSE)\n\t\tgoto out_reject;\n\n\t \n\tdp_sg = sym_evaluate_dp(np, cp, dp_scr, &dp_ofs);\n\tif (dp_sg < 0)\n\t\tgoto out_reject;\n\n\t \n\tdp_ret = cpu_to_scr(cp->goalp);\n\tdp_ret = dp_ret - 8 - (SYM_CONF_MAX_SG - dp_sg) * (2*4);\n\n\t \n\tif (dp_ofs == 0) {\n\t\tdp_scr = dp_ret;\n\t\tgoto out_ok;\n\t}\n\n\t \n\thflags = INB(np, HF_PRT);\n\n\tif (hflags & HF_DP_SAVED)\n\t\thflags ^= HF_ACT_PM;\n\n\tif (!(hflags & HF_ACT_PM)) {\n\t\tpm  = &cp->phys.pm0;\n\t\tdp_scr = SCRIPTA_BA(np, pm0_data);\n\t}\n\telse {\n\t\tpm = &cp->phys.pm1;\n\t\tdp_scr = SCRIPTA_BA(np, pm1_data);\n\t}\n\n\thflags &= ~(HF_DP_SAVED);\n\n\tOUTB(np, HF_PRT, hflags);\n\n\t \n\tpm->ret = cpu_to_scr(dp_ret);\n\ttmp  = scr_to_cpu(cp->phys.data[dp_sg-1].addr);\n\ttmp += scr_to_cpu(cp->phys.data[dp_sg-1].size) + dp_ofs;\n\tpm->sg.addr = cpu_to_scr(tmp);\n\tpm->sg.size = cpu_to_scr(-dp_ofs);\n\nout_ok:\n\tsym_set_script_dp (np, cp, dp_scr);\n\tOUTL_DSP(np, SCRIPTA_BA(np, clrack));\n\treturn;\n\nout_reject:\n\tOUTL_DSP(np, SCRIPTB_BA(np, msg_bad));\n}\n\n\n \n\nint sym_compute_residual(struct sym_hcb *np, struct sym_ccb *cp)\n{\n\tint dp_sg, resid = 0;\n\tint dp_ofs = 0;\n\n\t \n\tif (cp->xerr_status & (XE_EXTRA_DATA|XE_SODL_UNRUN|XE_SWIDE_OVRUN)) {\n\t\tif (cp->xerr_status & XE_EXTRA_DATA)\n\t\t\tresid -= cp->extra_bytes;\n\t\tif (cp->xerr_status & XE_SODL_UNRUN)\n\t\t\t++resid;\n\t\tif (cp->xerr_status & XE_SWIDE_OVRUN)\n\t\t\t--resid;\n\t}\n\n\t \n\tif (cp->phys.head.lastp == cp->goalp)\n\t\treturn resid;\n\n\t \n\tif (cp->startp == cp->phys.head.lastp ||\n\t    sym_evaluate_dp(np, cp, scr_to_cpu(cp->phys.head.lastp),\n\t\t\t    &dp_ofs) < 0) {\n\t\treturn cp->data_len - cp->odd_byte_adjustment;\n\t}\n\n\t \n\tif (cp->host_flags & HF_SENSE) {\n\t\treturn -dp_ofs;\n\t}\n\n\t \n\tresid = -cp->ext_ofs;\n\tfor (dp_sg = cp->ext_sg; dp_sg < SYM_CONF_MAX_SG; ++dp_sg) {\n\t\tu_int tmp = scr_to_cpu(cp->phys.data[dp_sg].size);\n\t\tresid += (tmp & 0xffffff);\n\t}\n\n\tresid -= cp->odd_byte_adjustment;\n\n\t \n\treturn resid;\n}\n\n \n\n \nstatic int  \nsym_sync_nego_check(struct sym_hcb *np, int req, struct sym_ccb *cp)\n{\n\tint target = cp->target;\n\tu_char\tchg, ofs, per, fak, div;\n\n\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\tsym_print_nego_msg(np, target, \"sync msgin\", np->msgin);\n\t}\n\n\t \n\tchg = 0;\n\tper = np->msgin[3];\n\tofs = np->msgin[4];\n\n\t \n\tif (ofs) {\n\t\tif (ofs > np->maxoffs)\n\t\t\t{chg = 1; ofs = np->maxoffs;}\n\t}\n\n\tif (ofs) {\n\t\tif (per < np->minsync)\n\t\t\t{chg = 1; per = np->minsync;}\n\t}\n\n\t \n\tdiv = fak = 0;\n\tif (ofs && sym_getsync(np, 0, per, &div, &fak) < 0)\n\t\tgoto reject_it;\n\n\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\tsym_print_addr(cp->cmd,\n\t\t\t\t\"sdtr: ofs=%d per=%d div=%d fak=%d chg=%d.\\n\",\n\t\t\t\tofs, per, div, fak, chg);\n\t}\n\n\t \n\tif (!req && chg)\n\t\tgoto reject_it;\n\n\t \n\tsym_setsync (np, target, ofs, per, div, fak);\n\n\t \n\tif (!req)\n\t\treturn 0;\n\n\t \n\tspi_populate_sync_msg(np->msgout, per, ofs);\n\n\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\tsym_print_nego_msg(np, target, \"sync msgout\", np->msgout);\n\t}\n\n\tnp->msgin [0] = M_NOOP;\n\n\treturn 0;\n\nreject_it:\n\tsym_setsync (np, target, 0, 0, 0, 0);\n\treturn -1;\n}\n\nstatic void sym_sync_nego(struct sym_hcb *np, struct sym_tcb *tp, struct sym_ccb *cp)\n{\n\tint req = 1;\n\tint result;\n\n\t \n\tif (INB(np, HS_PRT) == HS_NEGOTIATE) {\n\t\tOUTB(np, HS_PRT, HS_BUSY);\n\t\tif (cp->nego_status && cp->nego_status != NS_SYNC)\n\t\t\tgoto reject_it;\n\t\treq = 0;\n\t}\n\n\t \n\tresult = sym_sync_nego_check(np, req, cp);\n\tif (result)\t \n\t\tgoto reject_it;\n\tif (req) {\t \n\t\tcp->nego_status = NS_SYNC;\n\t\tOUTL_DSP(np, SCRIPTB_BA(np, sdtr_resp));\n\t}\n\telse\t\t \n\t\tOUTL_DSP(np, SCRIPTA_BA(np, clrack));\n\treturn;\n\nreject_it:\n\tOUTL_DSP(np, SCRIPTB_BA(np, msg_bad));\n}\n\n \nstatic int \nsym_ppr_nego_check(struct sym_hcb *np, int req, int target)\n{\n\tstruct sym_tcb *tp = &np->target[target];\n\tunsigned char fak, div;\n\tint dt, chg = 0;\n\n\tunsigned char per = np->msgin[3];\n\tunsigned char ofs = np->msgin[5];\n\tunsigned char wide = np->msgin[6];\n\tunsigned char opts = np->msgin[7] & PPR_OPT_MASK;\n\n\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\tsym_print_nego_msg(np, target, \"ppr msgin\", np->msgin);\n\t}\n\n\t \n\tif (wide > np->maxwide) {\n\t\tchg = 1;\n\t\twide = np->maxwide;\n\t}\n\tif (!wide || !(np->features & FE_U3EN))\n\t\topts = 0;\n\n\tif (opts != (np->msgin[7] & PPR_OPT_MASK))\n\t\tchg = 1;\n\n\tdt = opts & PPR_OPT_DT;\n\n\tif (ofs) {\n\t\tunsigned char maxoffs = dt ? np->maxoffs_dt : np->maxoffs;\n\t\tif (ofs > maxoffs) {\n\t\t\tchg = 1;\n\t\t\tofs = maxoffs;\n\t\t}\n\t}\n\n\tif (ofs) {\n\t\tunsigned char minsync = dt ? np->minsync_dt : np->minsync;\n\t\tif (per < minsync) {\n\t\t\tchg = 1;\n\t\t\tper = minsync;\n\t\t}\n\t}\n\n\t \n\tdiv = fak = 0;\n\tif (ofs && sym_getsync(np, dt, per, &div, &fak) < 0)\n\t\tgoto reject_it;\n\n\t \n\tif (!req && chg)\n\t\tgoto reject_it;\n\n\t \n\tsym_setpprot(np, target, opts, ofs, per, wide, div, fak);\n\n\t \n\tif (!req)\n\t\treturn 0;\n\n\t \n\tspi_populate_ppr_msg(np->msgout, per, ofs, wide, opts);\n\n\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\tsym_print_nego_msg(np, target, \"ppr msgout\", np->msgout);\n\t}\n\n\tnp->msgin [0] = M_NOOP;\n\n\treturn 0;\n\nreject_it:\n\tsym_setpprot (np, target, 0, 0, 0, 0, 0, 0);\n\t \n\tif (!req && !opts) {\n\t\ttp->tgoal.period = per;\n\t\ttp->tgoal.offset = ofs;\n\t\ttp->tgoal.width = wide;\n\t\ttp->tgoal.iu = tp->tgoal.dt = tp->tgoal.qas = 0;\n\t\ttp->tgoal.check_nego = 1;\n\t}\n\treturn -1;\n}\n\nstatic void sym_ppr_nego(struct sym_hcb *np, struct sym_tcb *tp, struct sym_ccb *cp)\n{\n\tint req = 1;\n\tint result;\n\n\t \n\tif (INB(np, HS_PRT) == HS_NEGOTIATE) {\n\t\tOUTB(np, HS_PRT, HS_BUSY);\n\t\tif (cp->nego_status && cp->nego_status != NS_PPR)\n\t\t\tgoto reject_it;\n\t\treq = 0;\n\t}\n\n\t \n\tresult = sym_ppr_nego_check(np, req, cp->target);\n\tif (result)\t \n\t\tgoto reject_it;\n\tif (req) {\t \n\t\tcp->nego_status = NS_PPR;\n\t\tOUTL_DSP(np, SCRIPTB_BA(np, ppr_resp));\n\t}\n\telse\t\t \n\t\tOUTL_DSP(np, SCRIPTA_BA(np, clrack));\n\treturn;\n\nreject_it:\n\tOUTL_DSP(np, SCRIPTB_BA(np, msg_bad));\n}\n\n \nstatic int  \nsym_wide_nego_check(struct sym_hcb *np, int req, struct sym_ccb *cp)\n{\n\tint target = cp->target;\n\tu_char\tchg, wide;\n\n\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\tsym_print_nego_msg(np, target, \"wide msgin\", np->msgin);\n\t}\n\n\t \n\tchg  = 0;\n\twide = np->msgin[3];\n\n\t \n\tif (wide > np->maxwide) {\n\t\tchg = 1;\n\t\twide = np->maxwide;\n\t}\n\n\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\tsym_print_addr(cp->cmd, \"wdtr: wide=%d chg=%d.\\n\",\n\t\t\t\twide, chg);\n\t}\n\n\t \n\tif (!req && chg)\n\t\tgoto reject_it;\n\n\t \n\tsym_setwide (np, target, wide);\n\n\t \n\tif (!req)\n\t\treturn 0;\n\n\t \n\tspi_populate_width_msg(np->msgout, wide);\n\n\tnp->msgin [0] = M_NOOP;\n\n\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\tsym_print_nego_msg(np, target, \"wide msgout\", np->msgout);\n\t}\n\n\treturn 0;\n\nreject_it:\n\treturn -1;\n}\n\nstatic void sym_wide_nego(struct sym_hcb *np, struct sym_tcb *tp, struct sym_ccb *cp)\n{\n\tint req = 1;\n\tint result;\n\n\t \n\tif (INB(np, HS_PRT) == HS_NEGOTIATE) {\n\t\tOUTB(np, HS_PRT, HS_BUSY);\n\t\tif (cp->nego_status && cp->nego_status != NS_WIDE)\n\t\t\tgoto reject_it;\n\t\treq = 0;\n\t}\n\n\t \n\tresult = sym_wide_nego_check(np, req, cp);\n\tif (result)\t \n\t\tgoto reject_it;\n\tif (req) {\t \n\t\tcp->nego_status = NS_WIDE;\n\t\tOUTL_DSP(np, SCRIPTB_BA(np, wdtr_resp));\n\t} else {\t\t \n\t\t \n\t\tif (tp->tgoal.offset) {\n\t\t\tspi_populate_sync_msg(np->msgout, tp->tgoal.period,\n\t\t\t\t\ttp->tgoal.offset);\n\n\t\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\t\tsym_print_nego_msg(np, cp->target,\n\t\t\t\t                   \"sync msgout\", np->msgout);\n\t\t\t}\n\n\t\t\tcp->nego_status = NS_SYNC;\n\t\t\tOUTB(np, HS_PRT, HS_NEGOTIATE);\n\t\t\tOUTL_DSP(np, SCRIPTB_BA(np, sdtr_resp));\n\t\t\treturn;\n\t\t} else\n\t\t\tOUTL_DSP(np, SCRIPTA_BA(np, clrack));\n\t}\n\n\treturn;\n\nreject_it:\n\tOUTL_DSP(np, SCRIPTB_BA(np, msg_bad));\n}\n\n \nstatic void sym_nego_default(struct sym_hcb *np, struct sym_tcb *tp, struct sym_ccb *cp)\n{\n\tswitch (cp->nego_status) {\n\tcase NS_PPR:\n#if 0\n\t\tsym_setpprot (np, cp->target, 0, 0, 0, 0, 0, 0);\n#else\n\t\tif (tp->tgoal.period < np->minsync)\n\t\t\ttp->tgoal.period = np->minsync;\n\t\tif (tp->tgoal.offset > np->maxoffs)\n\t\t\ttp->tgoal.offset = np->maxoffs;\n\t\ttp->tgoal.iu = tp->tgoal.dt = tp->tgoal.qas = 0;\n\t\ttp->tgoal.check_nego = 1;\n#endif\n\t\tbreak;\n\tcase NS_SYNC:\n\t\tsym_setsync (np, cp->target, 0, 0, 0, 0);\n\t\tbreak;\n\tcase NS_WIDE:\n\t\tsym_setwide (np, cp->target, 0);\n\t\tbreak;\n\t}\n\tnp->msgin [0] = M_NOOP;\n\tnp->msgout[0] = M_NOOP;\n\tcp->nego_status = 0;\n}\n\n \nstatic void sym_nego_rejected(struct sym_hcb *np, struct sym_tcb *tp, struct sym_ccb *cp)\n{\n\tsym_nego_default(np, tp, cp);\n\tOUTB(np, HS_PRT, HS_BUSY);\n}\n\n#define sym_printk(lvl, tp, cp, fmt, v...) do { \\\n\tif (cp)\t\t\t\t\t\t\t\\\n\t\tscmd_printk(lvl, cp->cmd, fmt, ##v);\t\t\\\n\telse\t\t\t\t\t\t\t\\\n\t\tstarget_printk(lvl, tp->starget, fmt, ##v);\t\\\n} while (0)\n\n \nstatic void sym_int_sir(struct sym_hcb *np)\n{\n\tu_char\tnum\t= INB(np, nc_dsps);\n\tu32\tdsa\t= INL(np, nc_dsa);\n\tstruct sym_ccb *cp\t= sym_ccb_from_dsa(np, dsa);\n\tu_char\ttarget\t= INB(np, nc_sdid) & 0x0f;\n\tstruct sym_tcb *tp\t= &np->target[target];\n\tint\ttmp;\n\n\tif (DEBUG_FLAGS & DEBUG_TINY) printf (\"I#%d\", num);\n\n\tswitch (num) {\n#if   SYM_CONF_DMA_ADDRESSING_MODE == 2\n\t \n\tcase SIR_DMAP_DIRTY:\n\t\tsym_update_dmap_regs(np);\n\t\tgoto out;\n#endif\n\t \n\tcase SIR_COMPLETE_ERROR:\n\t\tsym_complete_error(np, cp);\n\t\treturn;\n\t \n\tcase SIR_SCRIPT_STOPPED:\n\tcase SIR_TARGET_SELECTED:\n\tcase SIR_ABORT_SENT:\n\t\tsym_sir_task_recovery(np, num);\n\t\treturn;\n\t \n\tcase SIR_SEL_ATN_NO_MSG_OUT:\n\t\tsym_printk(KERN_WARNING, tp, cp,\n\t\t\t\t\"No MSG OUT phase after selection with ATN\\n\");\n\t\tgoto out_stuck;\n\t \n\tcase SIR_RESEL_NO_MSG_IN:\n\t\tsym_printk(KERN_WARNING, tp, cp,\n\t\t\t\t\"No MSG IN phase after reselection\\n\");\n\t\tgoto out_stuck;\n\t \n\tcase SIR_RESEL_NO_IDENTIFY:\n\t\tsym_printk(KERN_WARNING, tp, cp,\n\t\t\t\t\"No IDENTIFY after reselection\\n\");\n\t\tgoto out_stuck;\n\t \n\tcase SIR_RESEL_BAD_LUN:\n\t\tnp->msgout[0] = M_RESET;\n\t\tgoto out;\n\t \n\tcase SIR_RESEL_BAD_I_T_L:\n\t\tnp->msgout[0] = M_ABORT;\n\t\tgoto out;\n\t \n\tcase SIR_RESEL_BAD_I_T_L_Q:\n\t\tnp->msgout[0] = M_ABORT_TAG;\n\t\tgoto out;\n\t \n\tcase SIR_RESEL_ABORTED:\n\t\tnp->lastmsg = np->msgout[0];\n\t\tnp->msgout[0] = M_NOOP;\n\t\tsym_printk(KERN_WARNING, tp, cp,\n\t\t\t\"message %x sent on bad reselection\\n\", np->lastmsg);\n\t\tgoto out;\n\t \n\tcase SIR_MSG_OUT_DONE:\n\t\tnp->lastmsg = np->msgout[0];\n\t\tnp->msgout[0] = M_NOOP;\n\t\t \n\t\tif (np->lastmsg == M_PARITY || np->lastmsg == M_ID_ERROR) {\n\t\t\tif (cp) {\n\t\t\t\tcp->xerr_status &= ~XE_PARITY_ERR;\n\t\t\t\tif (!cp->xerr_status)\n\t\t\t\t\tOUTOFFB(np, HF_PRT, HF_EXT_ERR);\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t \n\tcase SIR_BAD_SCSI_STATUS:\n\t\tif (!cp)\n\t\t\tgoto out;\n\t\tsym_sir_bad_scsi_status(np, num, cp);\n\t\treturn;\n\t \n\tcase SIR_REJECT_TO_SEND:\n\t\tsym_print_msg(cp, \"M_REJECT to send for \", np->msgin);\n\t\tnp->msgout[0] = M_REJECT;\n\t\tgoto out;\n\t \n\tcase SIR_SWIDE_OVERRUN:\n\t\tif (cp) {\n\t\t\tOUTONB(np, HF_PRT, HF_EXT_ERR);\n\t\t\tcp->xerr_status |= XE_SWIDE_OVRUN;\n\t\t}\n\t\tgoto out;\n\t \n\tcase SIR_SODL_UNDERRUN:\n\t\tif (cp) {\n\t\t\tOUTONB(np, HF_PRT, HF_EXT_ERR);\n\t\t\tcp->xerr_status |= XE_SODL_UNRUN;\n\t\t}\n\t\tgoto out;\n\t \n\tcase SIR_DATA_OVERRUN:\n\t\tif (cp) {\n\t\t\tOUTONB(np, HF_PRT, HF_EXT_ERR);\n\t\t\tcp->xerr_status |= XE_EXTRA_DATA;\n\t\t\tcp->extra_bytes += INL(np, nc_scratcha);\n\t\t}\n\t\tgoto out;\n\t \n\tcase SIR_BAD_PHASE:\n\t\tif (cp) {\n\t\t\tOUTONB(np, HF_PRT, HF_EXT_ERR);\n\t\t\tcp->xerr_status |= XE_BAD_PHASE;\n\t\t}\n\t\tgoto out;\n\t \n\tcase SIR_MSG_RECEIVED:\n\t\tif (!cp)\n\t\t\tgoto out_stuck;\n\t\tswitch (np->msgin [0]) {\n\t\t \n\t\tcase M_EXTENDED:\n\t\t\tswitch (np->msgin [2]) {\n\t\t\tcase M_X_MODIFY_DP:\n\t\t\t\tif (DEBUG_FLAGS & DEBUG_POINTER)\n\t\t\t\t\tsym_print_msg(cp, \"extended msg \",\n\t\t\t\t\t\t      np->msgin);\n\t\t\t\ttmp = (np->msgin[3]<<24) + (np->msgin[4]<<16) + \n\t\t\t\t      (np->msgin[5]<<8)  + (np->msgin[6]);\n\t\t\t\tsym_modify_dp(np, tp, cp, tmp);\n\t\t\t\treturn;\n\t\t\tcase M_X_SYNC_REQ:\n\t\t\t\tsym_sync_nego(np, tp, cp);\n\t\t\t\treturn;\n\t\t\tcase M_X_PPR_REQ:\n\t\t\t\tsym_ppr_nego(np, tp, cp);\n\t\t\t\treturn;\n\t\t\tcase M_X_WIDE_REQ:\n\t\t\t\tsym_wide_nego(np, tp, cp);\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\tgoto out_reject;\n\t\t\t}\n\t\t\tbreak;\n\t\t \n\t\tcase M_IGN_RESIDUE:\n\t\t\tif (DEBUG_FLAGS & DEBUG_POINTER)\n\t\t\t\tsym_print_msg(cp, \"1 or 2 byte \", np->msgin);\n\t\t\tif (cp->host_flags & HF_SENSE)\n\t\t\t\tOUTL_DSP(np, SCRIPTA_BA(np, clrack));\n\t\t\telse\n\t\t\t\tsym_modify_dp(np, tp, cp, -1);\n\t\t\treturn;\n\t\tcase M_REJECT:\n\t\t\tif (INB(np, HS_PRT) == HS_NEGOTIATE)\n\t\t\t\tsym_nego_rejected(np, tp, cp);\n\t\t\telse {\n\t\t\t\tsym_print_addr(cp->cmd,\n\t\t\t\t\t\"M_REJECT received (%x:%x).\\n\",\n\t\t\t\t\tscr_to_cpu(np->lastmsg), np->msgout[0]);\n\t\t\t}\n\t\t\tgoto out_clrack;\n\t\tdefault:\n\t\t\tgoto out_reject;\n\t\t}\n\t\tbreak;\n\t \n\tcase SIR_MSG_WEIRD:\n\t\tsym_print_msg(cp, \"WEIRD message received\", np->msgin);\n\t\tOUTL_DSP(np, SCRIPTB_BA(np, msg_weird));\n\t\treturn;\n\t \n\tcase SIR_NEGO_FAILED:\n\t\tOUTB(np, HS_PRT, HS_BUSY);\n\t \n\t\tfallthrough;\n\tcase SIR_NEGO_PROTO:\n\t\tsym_nego_default(np, tp, cp);\n\t\tgoto out;\n\t}\n\nout:\n\tOUTONB_STD();\n\treturn;\nout_reject:\n\tOUTL_DSP(np, SCRIPTB_BA(np, msg_bad));\n\treturn;\nout_clrack:\n\tOUTL_DSP(np, SCRIPTA_BA(np, clrack));\n\treturn;\nout_stuck:\n\treturn;\n}\n\n \nstruct sym_ccb *sym_get_ccb (struct sym_hcb *np, struct scsi_cmnd *cmd, u_char tag_order)\n{\n\tu_char tn = cmd->device->id;\n\tu_char ln = cmd->device->lun;\n\tstruct sym_tcb *tp = &np->target[tn];\n\tstruct sym_lcb *lp = sym_lp(tp, ln);\n\tu_short tag = NO_TAG;\n\tSYM_QUEHEAD *qp;\n\tstruct sym_ccb *cp = NULL;\n\n\t \n\tif (sym_que_empty(&np->free_ccbq))\n\t\tsym_alloc_ccb(np);\n\tqp = sym_remque_head(&np->free_ccbq);\n\tif (!qp)\n\t\tgoto out;\n\tcp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\n\n\t{\n\t\t \n\t\tif (tag_order) {\n\t\t\t \n#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\t\t\tif (lp->busy_itl != 0)\n\t\t\t\tgoto out_free;\n#endif\n\t\t\t \n\t\t\tif (!lp->cb_tags) {\n\t\t\t\tsym_alloc_lcb_tags(np, tn, ln);\n\t\t\t\tif (!lp->cb_tags)\n\t\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t \n\t\t\tif (lp->busy_itlq < SYM_CONF_MAX_TASK) {\n\t\t\t\ttag = lp->cb_tags[lp->ia_tag];\n\t\t\t\tif (++lp->ia_tag == SYM_CONF_MAX_TASK)\n\t\t\t\t\tlp->ia_tag = 0;\n\t\t\t\t++lp->busy_itlq;\n#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\t\t\t\tlp->itlq_tbl[tag] = cpu_to_scr(cp->ccb_ba);\n\t\t\t\tlp->head.resel_sa =\n\t\t\t\t\tcpu_to_scr(SCRIPTA_BA(np, resel_tag));\n#endif\n#ifdef SYM_OPT_LIMIT_COMMAND_REORDERING\n\t\t\t\tcp->tags_si = lp->tags_si;\n\t\t\t\t++lp->tags_sum[cp->tags_si];\n\t\t\t\t++lp->tags_since;\n#endif\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto out_free;\n\t\t}\n\t\t \n\t\telse {\n\t\t\t \n#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\t\t\tif (lp->busy_itl != 0 || lp->busy_itlq != 0)\n\t\t\t\tgoto out_free;\n#endif\n\t\t\t \n\t\t\t++lp->busy_itl;\n#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\t\t\tif (lp->busy_itl == 1) {\n\t\t\t\tlp->head.itl_task_sa = cpu_to_scr(cp->ccb_ba);\n\t\t\t\tlp->head.resel_sa =\n\t\t\t\t      cpu_to_scr(SCRIPTA_BA(np, resel_no_tag));\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto out_free;\n#endif\n\t\t}\n\t}\n\t \n\tsym_insque_tail(&cp->link_ccbq, &np->busy_ccbq);\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\tif (lp) {\n\t\tsym_remque(&cp->link2_ccbq);\n\t\tsym_insque_tail(&cp->link2_ccbq, &lp->waiting_ccbq);\n\t}\n\n#endif\n\tcp->to_abort = 0;\n\tcp->odd_byte_adjustment = 0;\n\tcp->tag\t   = tag;\n\tcp->order  = tag_order;\n\tcp->target = tn;\n\tcp->lun    = ln;\n\n\tif (DEBUG_FLAGS & DEBUG_TAGS) {\n\t\tsym_print_addr(cmd, \"ccb @%p using tag %d.\\n\", cp, tag);\n\t}\n\nout:\n\treturn cp;\nout_free:\n\tsym_insque_head(&cp->link_ccbq, &np->free_ccbq);\n\treturn NULL;\n}\n\n \nvoid sym_free_ccb (struct sym_hcb *np, struct sym_ccb *cp)\n{\n\tstruct sym_tcb *tp = &np->target[cp->target];\n\tstruct sym_lcb *lp = sym_lp(tp, cp->lun);\n\n\tif (DEBUG_FLAGS & DEBUG_TAGS) {\n\t\tsym_print_addr(cp->cmd, \"ccb @%p freeing tag %d.\\n\",\n\t\t\t\tcp, cp->tag);\n\t}\n\n\t \n\tif (lp) {\n\t\t \n\t\tif (cp->tag != NO_TAG) {\n#ifdef SYM_OPT_LIMIT_COMMAND_REORDERING\n\t\t\t--lp->tags_sum[cp->tags_si];\n#endif\n\t\t\t \n\t\t\tlp->cb_tags[lp->if_tag] = cp->tag;\n\t\t\tif (++lp->if_tag == SYM_CONF_MAX_TASK)\n\t\t\t\tlp->if_tag = 0;\n\t\t\t \n\t\t\tlp->itlq_tbl[cp->tag] = cpu_to_scr(np->bad_itlq_ba);\n\t\t\t--lp->busy_itlq;\n\t\t} else {\t \n\t\t\t \n\t\t\tlp->head.itl_task_sa = cpu_to_scr(np->bad_itl_ba);\n\t\t\t--lp->busy_itl;\n\t\t}\n\t\t \n\t\tif (lp->busy_itlq == 0 && lp->busy_itl == 0)\n\t\t\tlp->head.resel_sa =\n\t\t\t\tcpu_to_scr(SCRIPTB_BA(np, resel_bad_lun));\n\t}\n\n\t \n\tif (cp == tp->nego_cp)\n\t\ttp->nego_cp = NULL;\n\n#ifdef SYM_CONF_IARB_SUPPORT\n\t \n\tif (cp == np->last_cp)\n\t\tnp->last_cp = 0;\n#endif\n\n\t \n\tcp->cmd = NULL;\n\tcp->host_status = HS_IDLE;\n\tsym_remque(&cp->link_ccbq);\n\tsym_insque_head(&cp->link_ccbq, &np->free_ccbq);\n\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\tif (lp) {\n\t\tsym_remque(&cp->link2_ccbq);\n\t\tsym_insque_tail(&cp->link2_ccbq, &np->dummy_ccbq);\n\t\tif (cp->started) {\n\t\t\tif (cp->tag != NO_TAG)\n\t\t\t\t--lp->started_tags;\n\t\t\telse\n\t\t\t\t--lp->started_no_tag;\n\t\t}\n\t}\n\tcp->started = 0;\n#endif\n}\n\n \nstatic struct sym_ccb *sym_alloc_ccb(struct sym_hcb *np)\n{\n\tstruct sym_ccb *cp = NULL;\n\tint hcode;\n\n\t \n\tif (np->actccbs >= SYM_CONF_MAX_START)\n\t\treturn NULL;\n\n\t \n\tcp = sym_calloc_dma(sizeof(struct sym_ccb), \"CCB\");\n\tif (!cp)\n\t\tgoto out_free;\n\n\t \n\tnp->actccbs++;\n\n\t \n\tcp->ccb_ba = vtobus(cp);\n\n\t \n\thcode = CCB_HASH_CODE(cp->ccb_ba);\n\tcp->link_ccbh = np->ccbh[hcode];\n\tnp->ccbh[hcode] = cp;\n\n\t \n\tcp->phys.head.go.start   = cpu_to_scr(SCRIPTA_BA(np, idle));\n\tcp->phys.head.go.restart = cpu_to_scr(SCRIPTB_BA(np, bad_i_t_l));\n\n \t \n\tcp->phys.smsg_ext.addr = cpu_to_scr(HCB_BA(np, msgin[2]));\n\n\t \n\tsym_insque_head(&cp->link_ccbq, &np->free_ccbq);\n\n\t \n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\tsym_insque_head(&cp->link2_ccbq, &np->dummy_ccbq);\n#endif\n\treturn cp;\nout_free:\n\tif (cp)\n\t\tsym_mfree_dma(cp, sizeof(*cp), \"CCB\");\n\treturn NULL;\n}\n\n \nstatic struct sym_ccb *sym_ccb_from_dsa(struct sym_hcb *np, u32 dsa)\n{\n\tint hcode;\n\tstruct sym_ccb *cp;\n\n\thcode = CCB_HASH_CODE(dsa);\n\tcp = np->ccbh[hcode];\n\twhile (cp) {\n\t\tif (cp->ccb_ba == dsa)\n\t\t\tbreak;\n\t\tcp = cp->link_ccbh;\n\t}\n\n\treturn cp;\n}\n\n \nstatic void sym_init_tcb (struct sym_hcb *np, u_char tn)\n{\n#if 0\t \n\t \t\n\tassert (((offsetof(struct sym_reg, nc_sxfer) ^\n\t\toffsetof(struct sym_tcb, head.sval)) &3) == 0);\n\tassert (((offsetof(struct sym_reg, nc_scntl3) ^\n\t\toffsetof(struct sym_tcb, head.wval)) &3) == 0);\n#endif\n}\n\n \nstruct sym_lcb *sym_alloc_lcb (struct sym_hcb *np, u_char tn, u_char ln)\n{\n\tstruct sym_tcb *tp = &np->target[tn];\n\tstruct sym_lcb *lp = NULL;\n\n\t \n\tsym_init_tcb (np, tn);\n\n\t \n\tif (ln && !tp->luntbl) {\n\t\ttp->luntbl = sym_calloc_dma(256, \"LUNTBL\");\n\t\tif (!tp->luntbl)\n\t\t\tgoto fail;\n\t\tmemset32(tp->luntbl, cpu_to_scr(vtobus(&np->badlun_sa)), 64);\n\t\ttp->head.luntbl_sa = cpu_to_scr(vtobus(tp->luntbl));\n\t}\n\n\t \n\tif (ln && !tp->lunmp) {\n\t\ttp->lunmp = kcalloc(SYM_CONF_MAX_LUN, sizeof(struct sym_lcb *),\n\t\t\t\tGFP_ATOMIC);\n\t\tif (!tp->lunmp)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tlp = sym_calloc_dma(sizeof(struct sym_lcb), \"LCB\");\n\tif (!lp)\n\t\tgoto fail;\n\tif (ln) {\n\t\ttp->lunmp[ln] = lp;\n\t\ttp->luntbl[ln] = cpu_to_scr(vtobus(lp));\n\t}\n\telse {\n\t\ttp->lun0p = lp;\n\t\ttp->head.lun0_sa = cpu_to_scr(vtobus(lp));\n\t}\n\ttp->nlcb++;\n\n\t \n\tlp->head.itl_task_sa = cpu_to_scr(np->bad_itl_ba);\n\n\t \n\tlp->head.resel_sa = cpu_to_scr(SCRIPTB_BA(np, resel_bad_lun));\n\n\t \n\tlp->user_flags = tp->usrflags & (SYM_DISC_ENABLED | SYM_TAGS_ENABLED);\n\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\t \n\tsym_que_init(&lp->waiting_ccbq);\n\tsym_que_init(&lp->started_ccbq);\n\tlp->started_max   = SYM_CONF_MAX_TASK;\n\tlp->started_limit = SYM_CONF_MAX_TASK;\n#endif\n\nfail:\n\treturn lp;\n}\n\n \nstatic void sym_alloc_lcb_tags (struct sym_hcb *np, u_char tn, u_char ln)\n{\n\tstruct sym_tcb *tp = &np->target[tn];\n\tstruct sym_lcb *lp = sym_lp(tp, ln);\n\tint i;\n\n\t \n\tlp->itlq_tbl = sym_calloc_dma(SYM_CONF_MAX_TASK*4, \"ITLQ_TBL\");\n\tif (!lp->itlq_tbl)\n\t\tgoto fail;\n\tlp->cb_tags = kcalloc(SYM_CONF_MAX_TASK, 1, GFP_ATOMIC);\n\tif (!lp->cb_tags) {\n\t\tsym_mfree_dma(lp->itlq_tbl, SYM_CONF_MAX_TASK*4, \"ITLQ_TBL\");\n\t\tlp->itlq_tbl = NULL;\n\t\tgoto fail;\n\t}\n\n\t \n\tmemset32(lp->itlq_tbl, cpu_to_scr(np->notask_ba), SYM_CONF_MAX_TASK);\n\n\t \n\tfor (i = 0 ; i < SYM_CONF_MAX_TASK ; i++)\n\t\tlp->cb_tags[i] = i;\n\n\t \n\tlp->head.itlq_tbl_sa = cpu_to_scr(vtobus(lp->itlq_tbl));\n\n\treturn;\nfail:\n\treturn;\n}\n\n \nint sym_free_lcb(struct sym_hcb *np, u_char tn, u_char ln)\n{\n\tstruct sym_tcb *tp = &np->target[tn];\n\tstruct sym_lcb *lp = sym_lp(tp, ln);\n\n\ttp->nlcb--;\n\n\tif (ln) {\n\t\tif (!tp->nlcb) {\n\t\t\tkfree(tp->lunmp);\n\t\t\tsym_mfree_dma(tp->luntbl, 256, \"LUNTBL\");\n\t\t\ttp->lunmp = NULL;\n\t\t\ttp->luntbl = NULL;\n\t\t\ttp->head.luntbl_sa = cpu_to_scr(vtobus(np->badluntbl));\n\t\t} else {\n\t\t\ttp->luntbl[ln] = cpu_to_scr(vtobus(&np->badlun_sa));\n\t\t\ttp->lunmp[ln] = NULL;\n\t\t}\n\t} else {\n\t\ttp->lun0p = NULL;\n\t\ttp->head.lun0_sa = cpu_to_scr(vtobus(&np->badlun_sa));\n\t}\n\n\tif (lp->itlq_tbl) {\n\t\tsym_mfree_dma(lp->itlq_tbl, SYM_CONF_MAX_TASK*4, \"ITLQ_TBL\");\n\t\tkfree(lp->cb_tags);\n\t}\n\n\tsym_mfree_dma(lp, sizeof(*lp), \"LCB\");\n\n\treturn tp->nlcb;\n}\n\n \nint sym_queue_scsiio(struct sym_hcb *np, struct scsi_cmnd *cmd, struct sym_ccb *cp)\n{\n\tstruct scsi_device *sdev = cmd->device;\n\tstruct sym_tcb *tp;\n\tstruct sym_lcb *lp;\n\tu_char\t*msgptr;\n\tu_int   msglen;\n\tint can_disconnect;\n\n\t \n\tcp->cmd = cmd;\n\n\t \n\ttp = &np->target[cp->target];\n\n\t \n\tlp = sym_lp(tp, sdev->lun);\n\n\tcan_disconnect = (cp->tag != NO_TAG) ||\n\t\t(lp && (lp->curr_flags & SYM_DISC_ENABLED));\n\n\tmsgptr = cp->scsi_smsg;\n\tmsglen = 0;\n\tmsgptr[msglen++] = IDENTIFY(can_disconnect, sdev->lun);\n\n\t \n\tif (cp->tag != NO_TAG) {\n\t\tu_char order = cp->order;\n\n\t\tswitch(order) {\n\t\tcase M_ORDERED_TAG:\n\t\t\tbreak;\n\t\tcase M_HEAD_TAG:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\torder = M_SIMPLE_TAG;\n\t\t}\n#ifdef SYM_OPT_LIMIT_COMMAND_REORDERING\n\t\t \n\t\tif (lp && lp->tags_since > 3*SYM_CONF_MAX_TAG) {\n\t\t\tlp->tags_si = !(lp->tags_si);\n\t\t\tif (lp->tags_sum[lp->tags_si]) {\n\t\t\t\torder = M_ORDERED_TAG;\n\t\t\t\tif ((DEBUG_FLAGS & DEBUG_TAGS)||sym_verbose>1) {\n\t\t\t\t\tsym_print_addr(cmd,\n\t\t\t\t\t\t\"ordered tag forced.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tlp->tags_since = 0;\n\t\t}\n#endif\n\t\tmsgptr[msglen++] = order;\n\n\t\t \n#if SYM_CONF_MAX_TASK > (512/4)\n\t\tmsgptr[msglen++] = cp->tag;\n#else\n\t\tmsgptr[msglen++] = (cp->tag << 1) + 1;\n#endif\n\t}\n\n\t \n\tcp->nego_status = 0;\n\tif ((tp->tgoal.check_nego ||\n\t     cmd->cmnd[0] == INQUIRY || cmd->cmnd[0] == REQUEST_SENSE) &&\n\t    !tp->nego_cp && lp) {\n\t\tmsglen += sym_prepare_nego(np, cp, msgptr + msglen);\n\t}\n\n\t \n\tcp->phys.head.go.start   = cpu_to_scr(SCRIPTA_BA(np, select));\n\tcp->phys.head.go.restart = cpu_to_scr(SCRIPTA_BA(np, resel_dsa));\n\n\t \n\tcp->phys.select.sel_id\t\t= cp->target;\n\tcp->phys.select.sel_scntl3\t= tp->head.wval;\n\tcp->phys.select.sel_sxfer\t= tp->head.sval;\n\tcp->phys.select.sel_scntl4\t= tp->head.uval;\n\n\t \n\tcp->phys.smsg.addr\t= CCB_BA(cp, scsi_smsg);\n\tcp->phys.smsg.size\t= cpu_to_scr(msglen);\n\n\t \n\tcp->host_xflags\t\t= 0;\n\tcp->host_status\t\t= cp->nego_status ? HS_NEGOTIATE : HS_BUSY;\n\tcp->ssss_status\t\t= S_ILLEGAL;\n\tcp->xerr_status\t\t= 0;\n\tcp->host_flags\t\t= 0;\n\tcp->extra_bytes\t\t= 0;\n\n\t \n\tcp->ext_sg  = -1;\n\tcp->ext_ofs = 0;\n\n\t \n\treturn sym_setup_data_and_start(np, cmd, cp);\n}\n\n \nint sym_reset_scsi_target(struct sym_hcb *np, int target)\n{\n\tstruct sym_tcb *tp;\n\n\tif (target == np->myaddr || (u_int)target >= SYM_CONF_MAX_TARGET)\n\t\treturn -1;\n\n\ttp = &np->target[target];\n\ttp->to_reset = 1;\n\n\tnp->istat_sem = SEM;\n\tOUTB(np, nc_istat, SIGP|SEM);\n\n\treturn 0;\n}\n\n \nstatic int sym_abort_ccb(struct sym_hcb *np, struct sym_ccb *cp, int timed_out)\n{\n\t \n\tif (!cp || !cp->host_status || cp->host_status == HS_WAIT)\n\t\treturn -1;\n\n\t \n\tif (cp->to_abort) {\n\t\tsym_reset_scsi_bus(np, 1);\n\t\treturn 0;\n\t}\n\n\t \n\tcp->to_abort = timed_out ? 2 : 1;\n\n\t \n\tnp->istat_sem = SEM;\n\tOUTB(np, nc_istat, SIGP|SEM);\n\treturn 0;\n}\n\nint sym_abort_scsiio(struct sym_hcb *np, struct scsi_cmnd *cmd, int timed_out)\n{\n\tstruct sym_ccb *cp;\n\tSYM_QUEHEAD *qp;\n\n\t \n\tcp = NULL;\n\tFOR_EACH_QUEUED_ELEMENT(&np->busy_ccbq, qp) {\n\t\tstruct sym_ccb *cp2 = sym_que_entry(qp, struct sym_ccb, link_ccbq);\n\t\tif (cp2->cmd == cmd) {\n\t\t\tcp = cp2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sym_abort_ccb(np, cp, timed_out);\n}\n\n \nvoid sym_complete_error(struct sym_hcb *np, struct sym_ccb *cp)\n{\n\tstruct scsi_device *sdev;\n\tstruct scsi_cmnd *cmd;\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\tstruct sym_tcb *tp;\n\tstruct sym_lcb *lp;\n#endif\n\tint resid;\n\tint i;\n\n\t \n\tif (!cp || !cp->cmd)\n\t\treturn;\n\n\tcmd = cp->cmd;\n\tsdev = cmd->device;\n\tif (DEBUG_FLAGS & (DEBUG_TINY|DEBUG_RESULT)) {\n\t\tdev_info(&sdev->sdev_gendev, \"CCB=%p STAT=%x/%x/%x\\n\", cp,\n\t\t\tcp->host_status, cp->ssss_status, cp->host_flags);\n\t}\n\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\t \n\ttp = &np->target[cp->target];\n\tlp = sym_lp(tp, sdev->lun);\n#endif\n\n\t \n\tif (cp->xerr_status) {\n\t\tif (sym_verbose)\n\t\t\tsym_print_xerr(cmd, cp->xerr_status);\n\t\tif (cp->host_status == HS_COMPLETE)\n\t\t\tcp->host_status = HS_COMP_ERR;\n\t}\n\n\t \n\tresid = sym_compute_residual(np, cp);\n\n\tif (!SYM_SETUP_RESIDUAL_SUPPORT) { \n\t\tresid  = 0;\t\t  \n\t\tcp->sv_resid = 0;\n\t}\n#ifdef DEBUG_2_0_X\nif (resid)\n\tprintf(\"XXXX RESID= %d - 0x%x\\n\", resid, resid);\n#endif\n\n\t \n\ti = (INL(np, nc_scratcha) - np->squeue_ba) / 4;\n\ti = sym_dequeue_from_squeue(np, i, cp->target, sdev->lun, -1);\n\n\t \n\tOUTL_DSP(np, SCRIPTA_BA(np, start));\n\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\tif (cp->host_status == HS_COMPLETE &&\n\t    cp->ssss_status == S_QUEUE_FULL) {\n\t\tif (!lp || lp->started_tags - i < 2)\n\t\t\tgoto weirdness;\n\t\t \n\t\tlp->started_max = lp->started_tags - i - 1;\n\t\tlp->num_sgood = 0;\n\n\t\tif (sym_verbose >= 2) {\n\t\t\tsym_print_addr(cmd, \" queue depth is now %d\\n\",\n\t\t\t\t\tlp->started_max);\n\t\t}\n\n\t\t \n\t\tcp->host_status = HS_BUSY;\n\t\tcp->ssss_status = S_ILLEGAL;\n\n\t\t \n\t\tsym_set_cam_status(cmd, DID_SOFT_ERROR);\n\t\tgoto finish;\n\t}\nweirdness:\n#endif\n\t \n\tsym_set_cam_result_error(np, cp, resid);\n\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\nfinish:\n#endif\n\t \n\tsym_remque(&cp->link_ccbq);\n\tsym_insque_head(&cp->link_ccbq, &np->comp_ccbq);\n\n\t \n\tsym_flush_comp_queue(np, 0);\n\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\t \n\tsym_start_next_ccbs(np, lp, 1);\n#endif\n}\n\n \nvoid sym_complete_ok (struct sym_hcb *np, struct sym_ccb *cp)\n{\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\tstruct sym_tcb *tp;\n\tstruct sym_lcb *lp;\n#endif\n\tstruct scsi_cmnd *cmd;\n\tint resid;\n\n\t \n\tif (!cp || !cp->cmd)\n\t\treturn;\n\tassert (cp->host_status == HS_COMPLETE);\n\n\t \n\tcmd = cp->cmd;\n\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\t \n\ttp = &np->target[cp->target];\n\tlp = sym_lp(tp, cp->lun);\n#endif\n\n\t \n\tresid = 0;\n\tif (cp->phys.head.lastp != cp->goalp)\n\t\tresid = sym_compute_residual(np, cp);\n\n\t \n\tif (!SYM_SETUP_RESIDUAL_SUPPORT)\n\t\tresid  = 0;\n#ifdef DEBUG_2_0_X\nif (resid)\n\tprintf(\"XXXX RESID= %d - 0x%x\\n\", resid, resid);\n#endif\n\n\t \n\tsym_set_cam_result_ok(cp, cmd, resid);\n\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\t \n\tif (lp && lp->started_max < lp->started_limit) {\n\t\t++lp->num_sgood;\n\t\tif (lp->num_sgood >= 200) {\n\t\t\tlp->num_sgood = 0;\n\t\t\t++lp->started_max;\n\t\t\tif (sym_verbose >= 2) {\n\t\t\t\tsym_print_addr(cmd, \" queue depth is now %d\\n\",\n\t\t\t\t       lp->started_max);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\t \n\tsym_free_ccb (np, cp);\n\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\t \n\tif (!sym_que_empty(&lp->waiting_ccbq))\n\t\tsym_start_next_ccbs(np, lp, 2);\n#endif\n\t \n\tsym_xpt_done(np, cmd);\n}\n\n \nint sym_hcb_attach(struct Scsi_Host *shost, struct sym_fw *fw, struct sym_nvram *nvram)\n{\n\tstruct sym_hcb *np = sym_get_hcb(shost);\n\tint i;\n\n\t \n\tnp->scripta_sz\t = fw->a_size;\n\tnp->scriptb_sz\t = fw->b_size;\n\tnp->scriptz_sz\t = fw->z_size;\n\tnp->fw_setup\t = fw->setup;\n\tnp->fw_patch\t = fw->patch;\n\tnp->fw_name\t = fw->name;\n\n\t \n\tsym_save_initial_setting (np);\n\n\t \n\tsym_chip_reset(np);\n\n\t \n\tsym_prepare_setting(shost, np, nvram);\n\n\t \n\ti = sym_getpciclock(np);\n\tif (i > 37000 && !(np->features & FE_66MHZ))\n\t\tprintf(\"%s: PCI BUS clock seems too high: %u KHz.\\n\",\n\t\t\tsym_name(np), i);\n\n\t \n\tnp->squeue = sym_calloc_dma(sizeof(u32)*(MAX_QUEUE*2),\"SQUEUE\");\n\tif (!np->squeue)\n\t\tgoto attach_failed;\n\tnp->squeue_ba = vtobus(np->squeue);\n\n\t \n\tnp->dqueue = sym_calloc_dma(sizeof(u32)*(MAX_QUEUE*2),\"DQUEUE\");\n\tif (!np->dqueue)\n\t\tgoto attach_failed;\n\tnp->dqueue_ba = vtobus(np->dqueue);\n\n\t \n\tnp->targtbl = sym_calloc_dma(256, \"TARGTBL\");\n\tif (!np->targtbl)\n\t\tgoto attach_failed;\n\tnp->targtbl_ba = vtobus(np->targtbl);\n\n\t \n\tnp->scripta0 = sym_calloc_dma(np->scripta_sz, \"SCRIPTA0\");\n\tnp->scriptb0 = sym_calloc_dma(np->scriptb_sz, \"SCRIPTB0\");\n\tnp->scriptz0 = sym_calloc_dma(np->scriptz_sz, \"SCRIPTZ0\");\n\tif (!np->scripta0 || !np->scriptb0 || !np->scriptz0)\n\t\tgoto attach_failed;\n\n\t \n\tnp->ccbh = kcalloc(CCB_HASH_SIZE, sizeof(*np->ccbh), GFP_KERNEL);\n\tif (!np->ccbh)\n\t\tgoto attach_failed;\n\n\t \n\tsym_que_init(&np->free_ccbq);\n\tsym_que_init(&np->busy_ccbq);\n\tsym_que_init(&np->comp_ccbq);\n\n\t \n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\n\tsym_que_init(&np->dummy_ccbq);\n#endif\n\t \n\tif (!sym_alloc_ccb(np))\n\t\tgoto attach_failed;\n\n\t \n\tnp->scripta_ba\t= vtobus(np->scripta0);\n\tnp->scriptb_ba\t= vtobus(np->scriptb0);\n\tnp->scriptz_ba\t= vtobus(np->scriptz0);\n\n\tif (np->ram_ba) {\n\t\tnp->scripta_ba = np->ram_ba;\n\t\tif (np->features & FE_RAM8K) {\n\t\t\tnp->scriptb_ba = np->scripta_ba + 4096;\n#if 0\t \n\t\t\tnp->scr_ram_seg = cpu_to_scr(np->scripta_ba >> 32);\n#endif\n\t\t}\n\t}\n\n\t \n\tmemcpy(np->scripta0, fw->a_base, np->scripta_sz);\n\tmemcpy(np->scriptb0, fw->b_base, np->scriptb_sz);\n\tmemcpy(np->scriptz0, fw->z_base, np->scriptz_sz);\n\n\t \n\tnp->fw_setup(np, fw);\n\n\t \n\tsym_fw_bind_script(np, (u32 *) np->scripta0, np->scripta_sz);\n\tsym_fw_bind_script(np, (u32 *) np->scriptb0, np->scriptb_sz);\n\tsym_fw_bind_script(np, (u32 *) np->scriptz0, np->scriptz_sz);\n\n#ifdef SYM_CONF_IARB_SUPPORT\n\t \n#ifdef\tSYM_SETUP_IARB_MAX\n\tnp->iarb_max = SYM_SETUP_IARB_MAX;\n#else\n\tnp->iarb_max = 4;\n#endif\n#endif\n\n\t \n\tnp->idletask.start\t= cpu_to_scr(SCRIPTA_BA(np, idle));\n\tnp->idletask.restart\t= cpu_to_scr(SCRIPTB_BA(np, bad_i_t_l));\n\tnp->idletask_ba\t\t= vtobus(&np->idletask);\n\n\tnp->notask.start\t= cpu_to_scr(SCRIPTA_BA(np, idle));\n\tnp->notask.restart\t= cpu_to_scr(SCRIPTB_BA(np, bad_i_t_l));\n\tnp->notask_ba\t\t= vtobus(&np->notask);\n\n\tnp->bad_itl.start\t= cpu_to_scr(SCRIPTA_BA(np, idle));\n\tnp->bad_itl.restart\t= cpu_to_scr(SCRIPTB_BA(np, bad_i_t_l));\n\tnp->bad_itl_ba\t\t= vtobus(&np->bad_itl);\n\n\tnp->bad_itlq.start\t= cpu_to_scr(SCRIPTA_BA(np, idle));\n\tnp->bad_itlq.restart\t= cpu_to_scr(SCRIPTB_BA(np,bad_i_t_l_q));\n\tnp->bad_itlq_ba\t\t= vtobus(&np->bad_itlq);\n\n\t \n\tnp->badluntbl = sym_calloc_dma(256, \"BADLUNTBL\");\n\tif (!np->badluntbl)\n\t\tgoto attach_failed;\n\n\tnp->badlun_sa = cpu_to_scr(SCRIPTB_BA(np, resel_bad_lun));\n\tmemset32(np->badluntbl, cpu_to_scr(vtobus(&np->badlun_sa)), 64);\n\n\t \n\tfor (i = 0 ; i < SYM_CONF_MAX_TARGET ; i++) {\n\t\tnp->targtbl[i] = cpu_to_scr(vtobus(&np->target[i]));\n\t\tnp->target[i].head.luntbl_sa =\n\t\t\t\tcpu_to_scr(vtobus(np->badluntbl));\n\t\tnp->target[i].head.lun0_sa =\n\t\t\t\tcpu_to_scr(vtobus(&np->badlun_sa));\n\t}\n\n\t \n\tif (sym_snooptest (np)) {\n\t\tprintf(\"%s: CACHE INCORRECTLY CONFIGURED.\\n\", sym_name(np));\n\t\tgoto attach_failed;\n\t}\n\n\t \n\treturn 0;\n\nattach_failed:\n\treturn -ENXIO;\n}\n\n \nvoid sym_hcb_free(struct sym_hcb *np)\n{\n\tSYM_QUEHEAD *qp;\n\tstruct sym_ccb *cp;\n\tstruct sym_tcb *tp;\n\tint target;\n\n\tif (np->scriptz0)\n\t\tsym_mfree_dma(np->scriptz0, np->scriptz_sz, \"SCRIPTZ0\");\n\tif (np->scriptb0)\n\t\tsym_mfree_dma(np->scriptb0, np->scriptb_sz, \"SCRIPTB0\");\n\tif (np->scripta0)\n\t\tsym_mfree_dma(np->scripta0, np->scripta_sz, \"SCRIPTA0\");\n\tif (np->squeue)\n\t\tsym_mfree_dma(np->squeue, sizeof(u32)*(MAX_QUEUE*2), \"SQUEUE\");\n\tif (np->dqueue)\n\t\tsym_mfree_dma(np->dqueue, sizeof(u32)*(MAX_QUEUE*2), \"DQUEUE\");\n\n\tif (np->actccbs) {\n\t\twhile ((qp = sym_remque_head(&np->free_ccbq)) != NULL) {\n\t\t\tcp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\n\t\t\tsym_mfree_dma(cp, sizeof(*cp), \"CCB\");\n\t\t}\n\t}\n\tkfree(np->ccbh);\n\n\tif (np->badluntbl)\n\t\tsym_mfree_dma(np->badluntbl, 256,\"BADLUNTBL\");\n\n\tfor (target = 0; target < SYM_CONF_MAX_TARGET ; target++) {\n\t\ttp = &np->target[target];\n\t\tif (tp->luntbl)\n\t\t\tsym_mfree_dma(tp->luntbl, 256, \"LUNTBL\");\n#if SYM_CONF_MAX_LUN > 1\n\t\tkfree(tp->lunmp);\n#endif \n\t}\n\tif (np->targtbl)\n\t\tsym_mfree_dma(np->targtbl, 256, \"TARGTBL\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}