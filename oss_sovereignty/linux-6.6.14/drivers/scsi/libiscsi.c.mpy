{
  "module_name": "libiscsi.c",
  "hash_id": "94e09e97ccf5875a63dcd5cdb4dc1c7fe0acd06560ff599f64de2adc81915c2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libiscsi.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/kfifo.h>\n#include <linux/delay.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/module.h>\n#include <asm/unaligned.h>\n#include <net/tcp.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi.h>\n#include <scsi/iscsi_proto.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_iscsi.h>\n#include <scsi/libiscsi.h>\n#include <trace/events/iscsi.h>\n\nstatic int iscsi_dbg_lib_conn;\nmodule_param_named(debug_libiscsi_conn, iscsi_dbg_lib_conn, int,\n\t\t   S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug_libiscsi_conn,\n\t\t \"Turn on debugging for connections in libiscsi module. \"\n\t\t \"Set to 1 to turn on, and zero to turn off. Default is off.\");\n\nstatic int iscsi_dbg_lib_session;\nmodule_param_named(debug_libiscsi_session, iscsi_dbg_lib_session, int,\n\t\t   S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug_libiscsi_session,\n\t\t \"Turn on debugging for sessions in libiscsi module. \"\n\t\t \"Set to 1 to turn on, and zero to turn off. Default is off.\");\n\nstatic int iscsi_dbg_lib_eh;\nmodule_param_named(debug_libiscsi_eh, iscsi_dbg_lib_eh, int,\n\t\t   S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug_libiscsi_eh,\n\t\t \"Turn on debugging for error handling in libiscsi module. \"\n\t\t \"Set to 1 to turn on, and zero to turn off. Default is off.\");\n\n#define ISCSI_DBG_CONN(_conn, dbg_fmt, arg...)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (iscsi_dbg_lib_conn)\t\t\t\t\\\n\t\t\tiscsi_conn_printk(KERN_INFO, _conn,\t\\\n\t\t\t\t\t     \"%s \" dbg_fmt,\t\\\n\t\t\t\t\t     __func__, ##arg);\t\\\n\t\tiscsi_dbg_trace(trace_iscsi_dbg_conn,\t\t\\\n\t\t\t\t&(_conn)->cls_conn->dev,\t\\\n\t\t\t\t\"%s \" dbg_fmt, __func__, ##arg);\\\n\t} while (0);\n\n#define ISCSI_DBG_SESSION(_session, dbg_fmt, arg...)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (iscsi_dbg_lib_session)\t\t\t\t\\\n\t\t\tiscsi_session_printk(KERN_INFO, _session,\t\\\n\t\t\t\t\t     \"%s \" dbg_fmt,\t\t\\\n\t\t\t\t\t     __func__, ##arg);\t\t\\\n\t\tiscsi_dbg_trace(trace_iscsi_dbg_session, \t\t\\\n\t\t\t\t&(_session)->cls_session->dev,\t\t\\\n\t\t\t\t\"%s \" dbg_fmt, __func__, ##arg);\t\\\n\t} while (0);\n\n#define ISCSI_DBG_EH(_session, dbg_fmt, arg...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (iscsi_dbg_lib_eh)\t\t\t\t\t\\\n\t\t\tiscsi_session_printk(KERN_INFO, _session,\t\\\n\t\t\t\t\t     \"%s \" dbg_fmt,\t\t\\\n\t\t\t\t\t     __func__, ##arg);\t\t\\\n\t\tiscsi_dbg_trace(trace_iscsi_dbg_eh,\t\t\t\\\n\t\t\t\t&(_session)->cls_session->dev,\t\t\\\n\t\t\t\t\"%s \" dbg_fmt, __func__, ##arg);\t\\\n\t} while (0);\n\n#define ISCSI_CMD_COMPL_WAIT 5\n\ninline void iscsi_conn_queue_xmit(struct iscsi_conn *conn)\n{\n\tstruct Scsi_Host *shost = conn->session->host;\n\tstruct iscsi_host *ihost = shost_priv(shost);\n\n\tif (ihost->workq)\n\t\tqueue_work(ihost->workq, &conn->xmitwork);\n}\nEXPORT_SYMBOL_GPL(iscsi_conn_queue_xmit);\n\ninline void iscsi_conn_queue_recv(struct iscsi_conn *conn)\n{\n\tstruct Scsi_Host *shost = conn->session->host;\n\tstruct iscsi_host *ihost = shost_priv(shost);\n\n\tif (ihost->workq && !test_bit(ISCSI_CONN_FLAG_SUSPEND_RX, &conn->flags))\n\t\tqueue_work(ihost->workq, &conn->recvwork);\n}\nEXPORT_SYMBOL_GPL(iscsi_conn_queue_recv);\n\nstatic void __iscsi_update_cmdsn(struct iscsi_session *session,\n\t\t\t\t uint32_t exp_cmdsn, uint32_t max_cmdsn)\n{\n\t \n\tif (iscsi_sna_lt(max_cmdsn, exp_cmdsn - 1))\n\t\treturn;\n\n\tif (exp_cmdsn != session->exp_cmdsn &&\n\t    !iscsi_sna_lt(exp_cmdsn, session->exp_cmdsn))\n\t\tsession->exp_cmdsn = exp_cmdsn;\n\n\tif (max_cmdsn != session->max_cmdsn &&\n\t    !iscsi_sna_lt(max_cmdsn, session->max_cmdsn))\n\t\tsession->max_cmdsn = max_cmdsn;\n}\n\nvoid iscsi_update_cmdsn(struct iscsi_session *session, struct iscsi_nopin *hdr)\n{\n\t__iscsi_update_cmdsn(session, be32_to_cpu(hdr->exp_cmdsn),\n\t\t\t     be32_to_cpu(hdr->max_cmdsn));\n}\nEXPORT_SYMBOL_GPL(iscsi_update_cmdsn);\n\n \nvoid iscsi_prep_data_out_pdu(struct iscsi_task *task, struct iscsi_r2t_info *r2t,\n\t\t\t   struct iscsi_data *hdr)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tunsigned int left = r2t->data_length - r2t->sent;\n\n\ttask->hdr_len = sizeof(struct iscsi_data);\n\n\tmemset(hdr, 0, sizeof(struct iscsi_data));\n\thdr->ttt = r2t->ttt;\n\thdr->datasn = cpu_to_be32(r2t->datasn);\n\tr2t->datasn++;\n\thdr->opcode = ISCSI_OP_SCSI_DATA_OUT;\n\thdr->lun = task->lun;\n\thdr->itt = task->hdr_itt;\n\thdr->exp_statsn = r2t->exp_statsn;\n\thdr->offset = cpu_to_be32(r2t->data_offset + r2t->sent);\n\tif (left > conn->max_xmit_dlength) {\n\t\thton24(hdr->dlength, conn->max_xmit_dlength);\n\t\tr2t->data_count = conn->max_xmit_dlength;\n\t\thdr->flags = 0;\n\t} else {\n\t\thton24(hdr->dlength, left);\n\t\tr2t->data_count = left;\n\t\thdr->flags = ISCSI_FLAG_CMD_FINAL;\n\t}\n\tconn->dataout_pdus_cnt++;\n}\nEXPORT_SYMBOL_GPL(iscsi_prep_data_out_pdu);\n\nstatic int iscsi_add_hdr(struct iscsi_task *task, unsigned len)\n{\n\tunsigned exp_len = task->hdr_len + len;\n\n\tif (exp_len > task->hdr_max) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tWARN_ON(len & (ISCSI_PAD_LEN - 1));  \n\ttask->hdr_len = exp_len;\n\treturn 0;\n}\n\n \nstatic int iscsi_prep_ecdb_ahs(struct iscsi_task *task)\n{\n\tstruct scsi_cmnd *cmd = task->sc;\n\tunsigned rlen, pad_len;\n\tunsigned short ahslength;\n\tstruct iscsi_ecdb_ahdr *ecdb_ahdr;\n\tint rc;\n\n\tecdb_ahdr = iscsi_next_hdr(task);\n\trlen = cmd->cmd_len - ISCSI_CDB_SIZE;\n\n\tBUG_ON(rlen > sizeof(ecdb_ahdr->ecdb));\n\tahslength = rlen + sizeof(ecdb_ahdr->reserved);\n\n\tpad_len = iscsi_padding(rlen);\n\n\trc = iscsi_add_hdr(task, sizeof(ecdb_ahdr->ahslength) +\n\t                   sizeof(ecdb_ahdr->ahstype) + ahslength + pad_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pad_len)\n\t\tmemset(&ecdb_ahdr->ecdb[rlen], 0, pad_len);\n\n\tecdb_ahdr->ahslength = cpu_to_be16(ahslength);\n\tecdb_ahdr->ahstype = ISCSI_AHSTYPE_CDB;\n\tecdb_ahdr->reserved = 0;\n\tmemcpy(ecdb_ahdr->ecdb, cmd->cmnd + ISCSI_CDB_SIZE, rlen);\n\n\tISCSI_DBG_SESSION(task->conn->session,\n\t\t\t  \"iscsi_prep_ecdb_ahs: varlen_cdb_len %d \"\n\t\t          \"rlen %d pad_len %d ahs_length %d iscsi_headers_size \"\n\t\t          \"%u\\n\", cmd->cmd_len, rlen, pad_len, ahslength,\n\t\t          task->hdr_len);\n\treturn 0;\n}\n\n \nstatic int iscsi_check_tmf_restrictions(struct iscsi_task *task, int opcode)\n{\n\tstruct iscsi_session *session = task->conn->session;\n\tstruct iscsi_tm *tmf = &session->tmhdr;\n\tu64 hdr_lun;\n\n\tif (session->tmf_state == TMF_INITIAL)\n\t\treturn 0;\n\n\tif ((tmf->opcode & ISCSI_OPCODE_MASK) != ISCSI_OP_SCSI_TMFUNC)\n\t\treturn 0;\n\n\tswitch (ISCSI_TM_FUNC_VALUE(tmf)) {\n\tcase ISCSI_TM_FUNC_LOGICAL_UNIT_RESET:\n\t\t \n\t\thdr_lun = scsilun_to_int(&tmf->lun);\n\t\tif (hdr_lun != task->sc->device->lun)\n\t\t\treturn 0;\n\t\tfallthrough;\n\tcase ISCSI_TM_FUNC_TARGET_WARM_RESET:\n\t\t \n\t\tif (opcode != ISCSI_OP_SCSI_DATA_OUT) {\n\t\t\tiscsi_session_printk(KERN_INFO, session,\n\t\t\t\t\t     \"task [op %x itt 0x%x/0x%x] rejected.\\n\",\n\t\t\t\t\t     opcode, task->itt, task->hdr_itt);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t \n\t\tif (session->fast_abort) {\n\t\t\tiscsi_session_printk(KERN_INFO, session,\n\t\t\t\t\t     \"task [op %x itt 0x%x/0x%x] fast abort.\\n\",\n\t\t\t\t\t     opcode, task->itt, task->hdr_itt);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tbreak;\n\tcase ISCSI_TM_FUNC_ABORT_TASK:\n\t\t \n\t\tif (opcode == ISCSI_OP_SCSI_DATA_OUT &&\n\t\t    task->hdr_itt == tmf->rtt) {\n\t\t\tISCSI_DBG_SESSION(session,\n\t\t\t\t\t  \"Preventing task %x/%x from sending \"\n\t\t\t\t\t  \"data-out due to abort task in \"\n\t\t\t\t\t  \"progress\\n\", task->itt,\n\t\t\t\t\t  task->hdr_itt);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct iscsi_session *session = conn->session;\n\tstruct scsi_cmnd *sc = task->sc;\n\tstruct iscsi_scsi_req *hdr;\n\tunsigned hdrlength, cmd_len, transfer_length;\n\titt_t itt;\n\tint rc;\n\n\trc = iscsi_check_tmf_restrictions(task, ISCSI_OP_SCSI_CMD);\n\tif (rc)\n\t\treturn rc;\n\n\tif (conn->session->tt->alloc_pdu) {\n\t\trc = conn->session->tt->alloc_pdu(task, ISCSI_OP_SCSI_CMD);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\thdr = (struct iscsi_scsi_req *)task->hdr;\n\titt = hdr->itt;\n\tmemset(hdr, 0, sizeof(*hdr));\n\n\tif (session->tt->parse_pdu_itt)\n\t\thdr->itt = task->hdr_itt = itt;\n\telse\n\t\thdr->itt = task->hdr_itt = build_itt(task->itt,\n\t\t\t\t\t\t     task->conn->session->age);\n\ttask->hdr_len = 0;\n\trc = iscsi_add_hdr(task, sizeof(*hdr));\n\tif (rc)\n\t\treturn rc;\n\thdr->opcode = ISCSI_OP_SCSI_CMD;\n\thdr->flags = ISCSI_ATTR_SIMPLE;\n\tint_to_scsilun(sc->device->lun, &hdr->lun);\n\ttask->lun = hdr->lun;\n\thdr->exp_statsn = cpu_to_be32(conn->exp_statsn);\n\tcmd_len = sc->cmd_len;\n\tif (cmd_len < ISCSI_CDB_SIZE)\n\t\tmemset(&hdr->cdb[cmd_len], 0, ISCSI_CDB_SIZE - cmd_len);\n\telse if (cmd_len > ISCSI_CDB_SIZE) {\n\t\trc = iscsi_prep_ecdb_ahs(task);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcmd_len = ISCSI_CDB_SIZE;\n\t}\n\tmemcpy(hdr->cdb, sc->cmnd, cmd_len);\n\n\ttask->imm_count = 0;\n\tif (scsi_get_prot_op(sc) != SCSI_PROT_NORMAL)\n\t\ttask->protected = true;\n\n\ttransfer_length = scsi_transfer_length(sc);\n\thdr->data_length = cpu_to_be32(transfer_length);\n\tif (sc->sc_data_direction == DMA_TO_DEVICE) {\n\t\tstruct iscsi_r2t_info *r2t = &task->unsol_r2t;\n\n\t\thdr->flags |= ISCSI_FLAG_CMD_WRITE;\n\t\t \n\t\tmemset(r2t, 0, sizeof(*r2t));\n\n\t\tif (session->imm_data_en) {\n\t\t\tif (transfer_length >= session->first_burst)\n\t\t\t\ttask->imm_count = min(session->first_burst,\n\t\t\t\t\t\t\tconn->max_xmit_dlength);\n\t\t\telse\n\t\t\t\ttask->imm_count = min(transfer_length,\n\t\t\t\t\t\t      conn->max_xmit_dlength);\n\t\t\thton24(hdr->dlength, task->imm_count);\n\t\t} else\n\t\t\tzero_data(hdr->dlength);\n\n\t\tif (!session->initial_r2t_en) {\n\t\t\tr2t->data_length = min(session->first_burst,\n\t\t\t\t\t       transfer_length) -\n\t\t\t\t\t       task->imm_count;\n\t\t\tr2t->data_offset = task->imm_count;\n\t\t\tr2t->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);\n\t\t\tr2t->exp_statsn = cpu_to_be32(conn->exp_statsn);\n\t\t}\n\n\t\tif (!task->unsol_r2t.data_length)\n\t\t\t \n\t\t\thdr->flags |= ISCSI_FLAG_CMD_FINAL;\n\t} else {\n\t\thdr->flags |= ISCSI_FLAG_CMD_FINAL;\n\t\tzero_data(hdr->dlength);\n\n\t\tif (sc->sc_data_direction == DMA_FROM_DEVICE)\n\t\t\thdr->flags |= ISCSI_FLAG_CMD_READ;\n\t}\n\n\t \n\thdrlength = task->hdr_len - sizeof(*hdr);\n\n\tWARN_ON(hdrlength & (ISCSI_PAD_LEN-1));\n\thdrlength /= ISCSI_PAD_LEN;\n\n\tWARN_ON(hdrlength >= 256);\n\thdr->hlength = hdrlength & 0xFF;\n\thdr->cmdsn = task->cmdsn = cpu_to_be32(session->cmdsn);\n\n\tif (session->tt->init_task && session->tt->init_task(task))\n\t\treturn -EIO;\n\n\ttask->state = ISCSI_TASK_RUNNING;\n\tsession->cmdsn++;\n\n\tconn->scsicmd_pdus_cnt++;\n\tISCSI_DBG_SESSION(session, \"iscsi prep [%s cid %d sc %p cdb 0x%x \"\n\t\t\t  \"itt 0x%x len %d cmdsn %d win %d]\\n\",\n\t\t\t  sc->sc_data_direction == DMA_TO_DEVICE ?\n\t\t\t  \"write\" : \"read\", conn->id, sc, sc->cmnd[0],\n\t\t\t  task->itt, transfer_length,\n\t\t\t  session->cmdsn,\n\t\t\t  session->max_cmdsn - session->exp_cmdsn + 1);\n\treturn 0;\n}\n\n \nstatic void iscsi_free_task(struct iscsi_task *task)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct iscsi_session *session = conn->session;\n\tstruct scsi_cmnd *sc = task->sc;\n\tint oldstate = task->state;\n\n\tISCSI_DBG_SESSION(session, \"freeing task itt 0x%x state %d sc %p\\n\",\n\t\t\t  task->itt, task->state, task->sc);\n\n\tsession->tt->cleanup_task(task);\n\ttask->state = ISCSI_TASK_FREE;\n\ttask->sc = NULL;\n\t \n\tif (conn->login_task == task)\n\t\treturn;\n\n\tkfifo_in(&session->cmdpool.queue, (void*)&task, sizeof(void*));\n\n\tif (sc) {\n\t\t \n\t\tiscsi_cmd(sc)->task = NULL;\n\t\t \n\t\tif (oldstate != ISCSI_TASK_REQUEUE_SCSIQ)\n\t\t\tscsi_done(sc);\n\t}\n}\n\nbool iscsi_get_task(struct iscsi_task *task)\n{\n\treturn refcount_inc_not_zero(&task->refcount);\n}\nEXPORT_SYMBOL_GPL(iscsi_get_task);\n\n \nvoid __iscsi_put_task(struct iscsi_task *task)\n{\n\tif (refcount_dec_and_test(&task->refcount))\n\t\tiscsi_free_task(task);\n}\nEXPORT_SYMBOL_GPL(__iscsi_put_task);\n\nvoid iscsi_put_task(struct iscsi_task *task)\n{\n\tstruct iscsi_session *session = task->conn->session;\n\n\tif (refcount_dec_and_test(&task->refcount)) {\n\t\tspin_lock_bh(&session->back_lock);\n\t\tiscsi_free_task(task);\n\t\tspin_unlock_bh(&session->back_lock);\n\t}\n}\nEXPORT_SYMBOL_GPL(iscsi_put_task);\n\n \nstatic void iscsi_complete_task(struct iscsi_task *task, int state)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\n\tISCSI_DBG_SESSION(conn->session,\n\t\t\t  \"complete task itt 0x%x state %d sc %p\\n\",\n\t\t\t  task->itt, task->state, task->sc);\n\tif (task->state == ISCSI_TASK_COMPLETED ||\n\t    task->state == ISCSI_TASK_ABRT_TMF ||\n\t    task->state == ISCSI_TASK_ABRT_SESS_RECOV ||\n\t    task->state == ISCSI_TASK_REQUEUE_SCSIQ)\n\t\treturn;\n\tWARN_ON_ONCE(task->state == ISCSI_TASK_FREE);\n\ttask->state = state;\n\n\tif (READ_ONCE(conn->ping_task) == task)\n\t\tWRITE_ONCE(conn->ping_task, NULL);\n\n\t \n\t__iscsi_put_task(task);\n}\n\n \nvoid iscsi_complete_scsi_task(struct iscsi_task *task,\n\t\t\t      uint32_t exp_cmdsn, uint32_t max_cmdsn)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\n\tISCSI_DBG_SESSION(conn->session, \"[itt 0x%x]\\n\", task->itt);\n\n\tconn->last_recv = jiffies;\n\t__iscsi_update_cmdsn(conn->session, exp_cmdsn, max_cmdsn);\n\tiscsi_complete_task(task, ISCSI_TASK_COMPLETED);\n}\nEXPORT_SYMBOL_GPL(iscsi_complete_scsi_task);\n\n \nstatic bool cleanup_queued_task(struct iscsi_task *task)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tbool early_complete = false;\n\n\t \n\tif (task->state == ISCSI_TASK_COMPLETED)\n\t\tearly_complete = true;\n\n\tif (!list_empty(&task->running)) {\n\t\tlist_del_init(&task->running);\n\t\t \n\t\tif (task->state == ISCSI_TASK_RUNNING ||\n\t\t    task->state == ISCSI_TASK_COMPLETED)\n\t\t\t__iscsi_put_task(task);\n\t}\n\n\tif (conn->session->running_aborted_task == task) {\n\t\tconn->session->running_aborted_task = NULL;\n\t\t__iscsi_put_task(task);\n\t}\n\n\tif (conn->task == task) {\n\t\tconn->task = NULL;\n\t\t__iscsi_put_task(task);\n\t}\n\n\treturn early_complete;\n}\n\n \nstatic void __fail_scsi_task(struct iscsi_task *task, int err)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct scsi_cmnd *sc;\n\tint state;\n\n\tif (cleanup_queued_task(task))\n\t\treturn;\n\n\tif (task->state == ISCSI_TASK_PENDING) {\n\t\t \n\t\tconn->session->queued_cmdsn--;\n\t\t \n\t\tstate = ISCSI_TASK_COMPLETED;\n\t} else if (err == DID_TRANSPORT_DISRUPTED)\n\t\tstate = ISCSI_TASK_ABRT_SESS_RECOV;\n\telse\n\t\tstate = ISCSI_TASK_ABRT_TMF;\n\n\tsc = task->sc;\n\tsc->result = err << 16;\n\tscsi_set_resid(sc, scsi_bufflen(sc));\n\tiscsi_complete_task(task, state);\n}\n\nstatic void fail_scsi_task(struct iscsi_task *task, int err)\n{\n\tstruct iscsi_session *session = task->conn->session;\n\n\tspin_lock_bh(&session->back_lock);\n\t__fail_scsi_task(task, err);\n\tspin_unlock_bh(&session->back_lock);\n}\n\nstatic int iscsi_prep_mgmt_task(struct iscsi_conn *conn,\n\t\t\t\tstruct iscsi_task *task)\n{\n\tstruct iscsi_session *session = conn->session;\n\tstruct iscsi_hdr *hdr = task->hdr;\n\tstruct iscsi_nopout *nop = (struct iscsi_nopout *)hdr;\n\tuint8_t opcode = hdr->opcode & ISCSI_OPCODE_MASK;\n\n\tif (conn->session->state == ISCSI_STATE_LOGGING_OUT)\n\t\treturn -ENOTCONN;\n\n\tif (opcode != ISCSI_OP_LOGIN && opcode != ISCSI_OP_TEXT)\n\t\tnop->exp_statsn = cpu_to_be32(conn->exp_statsn);\n\t \n\tnop->cmdsn = cpu_to_be32(session->cmdsn);\n\tif (hdr->itt != RESERVED_ITT) {\n\t\t \n\t\tif (conn->c_stage == ISCSI_CONN_STARTED &&\n\t\t    !(hdr->opcode & ISCSI_OP_IMMEDIATE)) {\n\t\t\tsession->queued_cmdsn++;\n\t\t\tsession->cmdsn++;\n\t\t}\n\t}\n\n\tif (session->tt->init_task && session->tt->init_task(task))\n\t\treturn -EIO;\n\n\tif ((hdr->opcode & ISCSI_OPCODE_MASK) == ISCSI_OP_LOGOUT)\n\t\tsession->state = ISCSI_STATE_LOGGING_OUT;\n\n\ttask->state = ISCSI_TASK_RUNNING;\n\tISCSI_DBG_SESSION(session, \"mgmtpdu [op 0x%x hdr->itt 0x%x \"\n\t\t\t  \"datalen %d]\\n\", hdr->opcode & ISCSI_OPCODE_MASK,\n\t\t\t  hdr->itt, task->data_count);\n\treturn 0;\n}\n\n \nstatic struct iscsi_task *\niscsi_alloc_mgmt_task(struct iscsi_conn *conn, struct iscsi_hdr *hdr,\n\t\t      char *data, uint32_t data_size)\n{\n\tstruct iscsi_session *session = conn->session;\n\tuint8_t opcode = hdr->opcode & ISCSI_OPCODE_MASK;\n\tstruct iscsi_task *task;\n\titt_t itt;\n\n\tif (session->state == ISCSI_STATE_TERMINATE ||\n\t    !test_bit(ISCSI_CONN_FLAG_BOUND, &conn->flags))\n\t\treturn NULL;\n\n\tif (opcode == ISCSI_OP_LOGIN || opcode == ISCSI_OP_TEXT) {\n\t\t \n\t\tif (conn->login_task->state != ISCSI_TASK_FREE) {\n\t\t\tiscsi_conn_printk(KERN_ERR, conn, \"Login/Text in \"\n\t\t\t\t\t  \"progress. Cannot start new task.\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (data_size > ISCSI_DEF_MAX_RECV_SEG_LEN) {\n\t\t\tiscsi_conn_printk(KERN_ERR, conn, \"Invalid buffer len of %u for login task. Max len is %u\\n\", data_size, ISCSI_DEF_MAX_RECV_SEG_LEN);\n\t\t\treturn NULL;\n\t\t}\n\n\t\ttask = conn->login_task;\n\t} else {\n\t\tif (session->state != ISCSI_STATE_LOGGED_IN)\n\t\t\treturn NULL;\n\n\t\tif (data_size != 0) {\n\t\t\tiscsi_conn_printk(KERN_ERR, conn, \"Can not send data buffer of len %u for op 0x%x\\n\", data_size, opcode);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tBUG_ON(conn->c_stage == ISCSI_CONN_INITIAL_STAGE);\n\t\tBUG_ON(conn->c_stage == ISCSI_CONN_STOPPED);\n\n\t\tif (!kfifo_out(&session->cmdpool.queue,\n\t\t\t\t (void*)&task, sizeof(void*)))\n\t\t\treturn NULL;\n\t}\n\t \n\trefcount_set(&task->refcount, 1);\n\ttask->conn = conn;\n\ttask->sc = NULL;\n\tINIT_LIST_HEAD(&task->running);\n\ttask->state = ISCSI_TASK_PENDING;\n\n\tif (data_size) {\n\t\tmemcpy(task->data, data, data_size);\n\t\ttask->data_count = data_size;\n\t} else\n\t\ttask->data_count = 0;\n\n\tif (conn->session->tt->alloc_pdu) {\n\t\tif (conn->session->tt->alloc_pdu(task, hdr->opcode)) {\n\t\t\tiscsi_conn_printk(KERN_ERR, conn, \"Could not allocate \"\n\t\t\t\t\t \"pdu for mgmt task.\\n\");\n\t\t\tgoto free_task;\n\t\t}\n\t}\n\n\titt = task->hdr->itt;\n\ttask->hdr_len = sizeof(struct iscsi_hdr);\n\tmemcpy(task->hdr, hdr, sizeof(struct iscsi_hdr));\n\n\tif (hdr->itt != RESERVED_ITT) {\n\t\tif (session->tt->parse_pdu_itt)\n\t\t\ttask->hdr->itt = itt;\n\t\telse\n\t\t\ttask->hdr->itt = build_itt(task->itt,\n\t\t\t\t\t\t   task->conn->session->age);\n\t}\n\n\treturn task;\n\nfree_task:\n\tiscsi_put_task(task);\n\treturn NULL;\n}\n\n \nstatic int iscsi_send_mgmt_task(struct iscsi_task *task)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct iscsi_session *session = conn->session;\n\tstruct iscsi_host *ihost = shost_priv(conn->session->host);\n\tint rc = 0;\n\n\tif (!ihost->workq) {\n\t\trc = iscsi_prep_mgmt_task(conn, task);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = session->tt->xmit_task(task);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tlist_add_tail(&task->running, &conn->mgmtqueue);\n\t\tiscsi_conn_queue_xmit(conn);\n\t}\n\n\treturn 0;\n}\n\nstatic int __iscsi_conn_send_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,\n\t\t\t\t char *data, uint32_t data_size)\n{\n\tstruct iscsi_task *task;\n\tint rc;\n\n\ttask = iscsi_alloc_mgmt_task(conn, hdr, data, data_size);\n\tif (!task)\n\t\treturn -ENOMEM;\n\n\trc = iscsi_send_mgmt_task(task);\n\tif (rc)\n\t\tiscsi_put_task(task);\n\treturn rc;\n}\n\nint iscsi_conn_send_pdu(struct iscsi_cls_conn *cls_conn, struct iscsi_hdr *hdr,\n\t\t\tchar *data, uint32_t data_size)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\tint err = 0;\n\n\tspin_lock_bh(&session->frwd_lock);\n\tif (__iscsi_conn_send_pdu(conn, hdr, data, data_size))\n\t\terr = -EPERM;\n\tspin_unlock_bh(&session->frwd_lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(iscsi_conn_send_pdu);\n\n \nstatic void iscsi_scsi_cmd_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr,\n\t\t\t       struct iscsi_task *task, char *data,\n\t\t\t       int datalen)\n{\n\tstruct iscsi_scsi_rsp *rhdr = (struct iscsi_scsi_rsp *)hdr;\n\tstruct iscsi_session *session = conn->session;\n\tstruct scsi_cmnd *sc = task->sc;\n\n\tiscsi_update_cmdsn(session, (struct iscsi_nopin*)rhdr);\n\tconn->exp_statsn = be32_to_cpu(rhdr->statsn) + 1;\n\n\tsc->result = (DID_OK << 16) | rhdr->cmd_status;\n\n\tif (task->protected) {\n\t\tsector_t sector;\n\t\tu8 ascq;\n\n\t\t \n\t\tBUG_ON(!session->tt->check_protection);\n\n\t\tascq = session->tt->check_protection(task, &sector);\n\t\tif (ascq) {\n\t\t\tscsi_build_sense(sc, 1, ILLEGAL_REQUEST, 0x10, ascq);\n\t\t\tscsi_set_sense_information(sc->sense_buffer,\n\t\t\t\t\t\t   SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t\t\t   sector);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (rhdr->response != ISCSI_STATUS_CMD_COMPLETED) {\n\t\tsc->result = DID_ERROR << 16;\n\t\tgoto out;\n\t}\n\n\tif (rhdr->cmd_status == SAM_STAT_CHECK_CONDITION) {\n\t\tuint16_t senselen;\n\n\t\tif (datalen < 2) {\ninvalid_datalen:\n\t\t\tiscsi_conn_printk(KERN_ERR,  conn,\n\t\t\t\t\t \"Got CHECK_CONDITION but invalid data \"\n\t\t\t\t\t \"buffer size of %d\\n\", datalen);\n\t\t\tsc->result = DID_BAD_TARGET << 16;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsenselen = get_unaligned_be16(data);\n\t\tif (datalen < senselen)\n\t\t\tgoto invalid_datalen;\n\n\t\tmemcpy(sc->sense_buffer, data + 2,\n\t\t       min_t(uint16_t, senselen, SCSI_SENSE_BUFFERSIZE));\n\t\tISCSI_DBG_SESSION(session, \"copied %d bytes of sense\\n\",\n\t\t\t\t  min_t(uint16_t, senselen,\n\t\t\t\t  SCSI_SENSE_BUFFERSIZE));\n\t}\n\n\tif (rhdr->flags & (ISCSI_FLAG_CMD_BIDI_UNDERFLOW |\n\t\t\t   ISCSI_FLAG_CMD_BIDI_OVERFLOW)) {\n\t\tsc->result = (DID_BAD_TARGET << 16) | rhdr->cmd_status;\n\t}\n\n\tif (rhdr->flags & (ISCSI_FLAG_CMD_UNDERFLOW |\n\t                   ISCSI_FLAG_CMD_OVERFLOW)) {\n\t\tint res_count = be32_to_cpu(rhdr->residual_count);\n\n\t\tif (res_count > 0 &&\n\t\t    (rhdr->flags & ISCSI_FLAG_CMD_OVERFLOW ||\n\t\t     res_count <= scsi_bufflen(sc)))\n\t\t\t \n\t\t\tscsi_set_resid(sc, res_count);\n\t\telse\n\t\t\tsc->result = (DID_BAD_TARGET << 16) | rhdr->cmd_status;\n\t}\nout:\n\tISCSI_DBG_SESSION(session, \"cmd rsp done [sc %p res %d itt 0x%x]\\n\",\n\t\t\t  sc, sc->result, task->itt);\n\tconn->scsirsp_pdus_cnt++;\n\tiscsi_complete_task(task, ISCSI_TASK_COMPLETED);\n}\n\n \nstatic void\niscsi_data_in_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr,\n\t\t  struct iscsi_task *task)\n{\n\tstruct iscsi_data_rsp *rhdr = (struct iscsi_data_rsp *)hdr;\n\tstruct scsi_cmnd *sc = task->sc;\n\n\tif (!(rhdr->flags & ISCSI_FLAG_DATA_STATUS))\n\t\treturn;\n\n\tiscsi_update_cmdsn(conn->session, (struct iscsi_nopin *)hdr);\n\tsc->result = (DID_OK << 16) | rhdr->cmd_status;\n\tconn->exp_statsn = be32_to_cpu(rhdr->statsn) + 1;\n\tif (rhdr->flags & (ISCSI_FLAG_DATA_UNDERFLOW |\n\t                   ISCSI_FLAG_DATA_OVERFLOW)) {\n\t\tint res_count = be32_to_cpu(rhdr->residual_count);\n\n\t\tif (res_count > 0 &&\n\t\t    (rhdr->flags & ISCSI_FLAG_CMD_OVERFLOW ||\n\t\t     res_count <= sc->sdb.length))\n\t\t\tscsi_set_resid(sc, res_count);\n\t\telse\n\t\t\tsc->result = (DID_BAD_TARGET << 16) | rhdr->cmd_status;\n\t}\n\n\tISCSI_DBG_SESSION(conn->session, \"data in with status done \"\n\t\t\t  \"[sc %p res %d itt 0x%x]\\n\",\n\t\t\t  sc, sc->result, task->itt);\n\tconn->scsirsp_pdus_cnt++;\n\tiscsi_complete_task(task, ISCSI_TASK_COMPLETED);\n}\n\nstatic void iscsi_tmf_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr)\n{\n\tstruct iscsi_tm_rsp *tmf = (struct iscsi_tm_rsp *)hdr;\n\tstruct iscsi_session *session = conn->session;\n\n\tconn->exp_statsn = be32_to_cpu(hdr->statsn) + 1;\n\tconn->tmfrsp_pdus_cnt++;\n\n\tif (session->tmf_state != TMF_QUEUED)\n\t\treturn;\n\n\tif (tmf->response == ISCSI_TMF_RSP_COMPLETE)\n\t\tsession->tmf_state = TMF_SUCCESS;\n\telse if (tmf->response == ISCSI_TMF_RSP_NO_TASK)\n\t\tsession->tmf_state = TMF_NOT_FOUND;\n\telse\n\t\tsession->tmf_state = TMF_FAILED;\n\twake_up(&session->ehwait);\n}\n\nstatic int iscsi_send_nopout(struct iscsi_conn *conn, struct iscsi_nopin *rhdr)\n{\n        struct iscsi_nopout hdr;\n\tstruct iscsi_task *task;\n\n\tif (!rhdr) {\n\t\tif (READ_ONCE(conn->ping_task))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmemset(&hdr, 0, sizeof(struct iscsi_nopout));\n\thdr.opcode = ISCSI_OP_NOOP_OUT | ISCSI_OP_IMMEDIATE;\n\thdr.flags = ISCSI_FLAG_CMD_FINAL;\n\n\tif (rhdr) {\n\t\thdr.lun = rhdr->lun;\n\t\thdr.ttt = rhdr->ttt;\n\t\thdr.itt = RESERVED_ITT;\n\t} else\n\t\thdr.ttt = RESERVED_ITT;\n\n\ttask = iscsi_alloc_mgmt_task(conn, (struct iscsi_hdr *)&hdr, NULL, 0);\n\tif (!task)\n\t\treturn -ENOMEM;\n\n\tif (!rhdr)\n\t\tWRITE_ONCE(conn->ping_task, task);\n\n\tif (iscsi_send_mgmt_task(task)) {\n\t\tif (!rhdr)\n\t\t\tWRITE_ONCE(conn->ping_task, NULL);\n\t\tiscsi_put_task(task);\n\n\t\tiscsi_conn_printk(KERN_ERR, conn, \"Could not send nopout\\n\");\n\t\treturn -EIO;\n\t} else if (!rhdr) {\n\t\t \n\t\tconn->last_ping = jiffies;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int iscsi_nop_out_rsp(struct iscsi_task *task,\n\t\t\t     struct iscsi_nopin *nop, char *data, int datalen)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tint rc = 0;\n\n\tif (READ_ONCE(conn->ping_task) != task) {\n\t\t \n\t\tif (iscsi_recv_pdu(conn->cls_conn, (struct iscsi_hdr *)nop,\n\t\t\t\t   data, datalen))\n\t\t\trc = ISCSI_ERR_CONN_FAILED;\n\t} else\n\t\tmod_timer(&conn->transport_timer, jiffies + conn->recv_timeout);\n\tiscsi_complete_task(task, ISCSI_TASK_COMPLETED);\n\treturn rc;\n}\n\nstatic int iscsi_handle_reject(struct iscsi_conn *conn, struct iscsi_hdr *hdr,\n\t\t\t       char *data, int datalen)\n{\n\tstruct iscsi_reject *reject = (struct iscsi_reject *)hdr;\n\tstruct iscsi_hdr rejected_pdu;\n\tint opcode, rc = 0;\n\n\tconn->exp_statsn = be32_to_cpu(reject->statsn) + 1;\n\n\tif (ntoh24(reject->dlength) > datalen ||\n\t    ntoh24(reject->dlength) < sizeof(struct iscsi_hdr)) {\n\t\tiscsi_conn_printk(KERN_ERR, conn, \"Cannot handle rejected \"\n\t\t\t\t  \"pdu. Invalid data length (pdu dlength \"\n\t\t\t\t  \"%u, datalen %d\\n\", ntoh24(reject->dlength),\n\t\t\t\t  datalen);\n\t\treturn ISCSI_ERR_PROTO;\n\t}\n\tmemcpy(&rejected_pdu, data, sizeof(struct iscsi_hdr));\n\topcode = rejected_pdu.opcode & ISCSI_OPCODE_MASK;\n\n\tswitch (reject->reason) {\n\tcase ISCSI_REASON_DATA_DIGEST_ERROR:\n\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t  \"pdu (op 0x%x itt 0x%x) rejected \"\n\t\t\t\t  \"due to DataDigest error.\\n\",\n\t\t\t\t  opcode, rejected_pdu.itt);\n\t\tbreak;\n\tcase ISCSI_REASON_IMM_CMD_REJECT:\n\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t  \"pdu (op 0x%x itt 0x%x) rejected. Too many \"\n\t\t\t\t  \"immediate commands.\\n\",\n\t\t\t\t  opcode, rejected_pdu.itt);\n\t\t \n\t\tif (opcode != ISCSI_OP_NOOP_OUT)\n\t\t\treturn 0;\n\n\t\tif (rejected_pdu.itt == cpu_to_be32(ISCSI_RESERVED_TAG)) {\n\t\t\t \n\t\t\t \n\t\t\tspin_unlock(&conn->session->back_lock);\n\t\t\tspin_lock(&conn->session->frwd_lock);\n\t\t\tiscsi_send_nopout(conn,\n\t\t\t\t\t  (struct iscsi_nopin*)&rejected_pdu);\n\t\t\tspin_unlock(&conn->session->frwd_lock);\n\t\t\tspin_lock(&conn->session->back_lock);\n\t\t} else {\n\t\t\tstruct iscsi_task *task;\n\t\t\t \n\t\t\ttask = iscsi_itt_to_task(conn, rejected_pdu.itt);\n\t\t\tif (!task) {\n\t\t\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t\t\t \"Invalid pdu reject. Could \"\n\t\t\t\t\t\t \"not lookup rejected task.\\n\");\n\t\t\t\trc = ISCSI_ERR_BAD_ITT;\n\t\t\t} else\n\t\t\t\trc = iscsi_nop_out_rsp(task,\n\t\t\t\t\t(struct iscsi_nopin*)&rejected_pdu,\n\t\t\t\t\tNULL, 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t  \"pdu (op 0x%x itt 0x%x) rejected. Reason \"\n\t\t\t\t  \"code 0x%x\\n\", rejected_pdu.opcode,\n\t\t\t\t  rejected_pdu.itt, reject->reason);\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\n \nstruct iscsi_task *iscsi_itt_to_task(struct iscsi_conn *conn, itt_t itt)\n{\n\tstruct iscsi_session *session = conn->session;\n\tint i;\n\n\tif (itt == RESERVED_ITT)\n\t\treturn NULL;\n\n\tif (session->tt->parse_pdu_itt)\n\t\tsession->tt->parse_pdu_itt(conn, itt, &i, NULL);\n\telse\n\t\ti = get_itt(itt);\n\tif (i >= session->cmds_max)\n\t\treturn NULL;\n\n\treturn session->cmds[i];\n}\nEXPORT_SYMBOL_GPL(iscsi_itt_to_task);\n\n \nint __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,\n\t\t\t char *data, int datalen)\n{\n\tstruct iscsi_session *session = conn->session;\n\tint opcode = hdr->opcode & ISCSI_OPCODE_MASK, rc = 0;\n\tstruct iscsi_task *task;\n\tuint32_t itt;\n\n\tconn->last_recv = jiffies;\n\trc = iscsi_verify_itt(conn, hdr->itt);\n\tif (rc)\n\t\treturn rc;\n\n\tif (hdr->itt != RESERVED_ITT)\n\t\titt = get_itt(hdr->itt);\n\telse\n\t\titt = ~0U;\n\n\tISCSI_DBG_SESSION(session, \"[op 0x%x cid %d itt 0x%x len %d]\\n\",\n\t\t\t  opcode, conn->id, itt, datalen);\n\n\tif (itt == ~0U) {\n\t\tiscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);\n\n\t\tswitch(opcode) {\n\t\tcase ISCSI_OP_NOOP_IN:\n\t\t\tif (datalen) {\n\t\t\t\trc = ISCSI_ERR_PROTO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (hdr->ttt == cpu_to_be32(ISCSI_RESERVED_TAG))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tspin_unlock(&session->back_lock);\n\t\t\tspin_lock(&session->frwd_lock);\n\t\t\tiscsi_send_nopout(conn, (struct iscsi_nopin*)hdr);\n\t\t\tspin_unlock(&session->frwd_lock);\n\t\t\tspin_lock(&session->back_lock);\n\t\t\tbreak;\n\t\tcase ISCSI_OP_REJECT:\n\t\t\trc = iscsi_handle_reject(conn, hdr, data, datalen);\n\t\t\tbreak;\n\t\tcase ISCSI_OP_ASYNC_EVENT:\n\t\t\tconn->exp_statsn = be32_to_cpu(hdr->statsn) + 1;\n\t\t\tif (iscsi_recv_pdu(conn->cls_conn, hdr, data, datalen))\n\t\t\t\trc = ISCSI_ERR_CONN_FAILED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = ISCSI_ERR_BAD_OPCODE;\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tswitch(opcode) {\n\tcase ISCSI_OP_SCSI_CMD_RSP:\n\tcase ISCSI_OP_SCSI_DATA_IN:\n\t\ttask = iscsi_itt_to_ctask(conn, hdr->itt);\n\t\tif (!task)\n\t\t\treturn ISCSI_ERR_BAD_ITT;\n\t\ttask->last_xfer = jiffies;\n\t\tbreak;\n\tcase ISCSI_OP_R2T:\n\t\t \n\t\treturn 0;\n\tcase ISCSI_OP_LOGOUT_RSP:\n\tcase ISCSI_OP_LOGIN_RSP:\n\tcase ISCSI_OP_TEXT_RSP:\n\tcase ISCSI_OP_SCSI_TMFUNC_RSP:\n\tcase ISCSI_OP_NOOP_IN:\n\t\ttask = iscsi_itt_to_task(conn, hdr->itt);\n\t\tif (!task)\n\t\t\treturn ISCSI_ERR_BAD_ITT;\n\t\tbreak;\n\tdefault:\n\t\treturn ISCSI_ERR_BAD_OPCODE;\n\t}\n\n\tswitch(opcode) {\n\tcase ISCSI_OP_SCSI_CMD_RSP:\n\t\tiscsi_scsi_cmd_rsp(conn, hdr, task, data, datalen);\n\t\tbreak;\n\tcase ISCSI_OP_SCSI_DATA_IN:\n\t\tiscsi_data_in_rsp(conn, hdr, task);\n\t\tbreak;\n\tcase ISCSI_OP_LOGOUT_RSP:\n\t\tiscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);\n\t\tif (datalen) {\n\t\t\trc = ISCSI_ERR_PROTO;\n\t\t\tbreak;\n\t\t}\n\t\tconn->exp_statsn = be32_to_cpu(hdr->statsn) + 1;\n\t\tgoto recv_pdu;\n\tcase ISCSI_OP_LOGIN_RSP:\n\tcase ISCSI_OP_TEXT_RSP:\n\t\tiscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);\n\t\t \n\t\tgoto recv_pdu;\n\tcase ISCSI_OP_SCSI_TMFUNC_RSP:\n\t\tiscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);\n\t\tif (datalen) {\n\t\t\trc = ISCSI_ERR_PROTO;\n\t\t\tbreak;\n\t\t}\n\n\t\tiscsi_tmf_rsp(conn, hdr);\n\t\tiscsi_complete_task(task, ISCSI_TASK_COMPLETED);\n\t\tbreak;\n\tcase ISCSI_OP_NOOP_IN:\n\t\tiscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);\n\t\tif (hdr->ttt != cpu_to_be32(ISCSI_RESERVED_TAG) || datalen) {\n\t\t\trc = ISCSI_ERR_PROTO;\n\t\t\tbreak;\n\t\t}\n\t\tconn->exp_statsn = be32_to_cpu(hdr->statsn) + 1;\n\n\t\trc = iscsi_nop_out_rsp(task, (struct iscsi_nopin*)hdr,\n\t\t\t\t       data, datalen);\n\t\tbreak;\n\tdefault:\n\t\trc = ISCSI_ERR_BAD_OPCODE;\n\t\tbreak;\n\t}\n\nout:\n\treturn rc;\nrecv_pdu:\n\tif (iscsi_recv_pdu(conn->cls_conn, hdr, data, datalen))\n\t\trc = ISCSI_ERR_CONN_FAILED;\n\tiscsi_complete_task(task, ISCSI_TASK_COMPLETED);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(__iscsi_complete_pdu);\n\nint iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,\n\t\t       char *data, int datalen)\n{\n\tint rc;\n\n\tspin_lock(&conn->session->back_lock);\n\trc = __iscsi_complete_pdu(conn, hdr, data, datalen);\n\tspin_unlock(&conn->session->back_lock);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(iscsi_complete_pdu);\n\nint iscsi_verify_itt(struct iscsi_conn *conn, itt_t itt)\n{\n\tstruct iscsi_session *session = conn->session;\n\tint age = 0, i = 0;\n\n\tif (itt == RESERVED_ITT)\n\t\treturn 0;\n\n\tif (session->tt->parse_pdu_itt)\n\t\tsession->tt->parse_pdu_itt(conn, itt, &i, &age);\n\telse {\n\t\ti = get_itt(itt);\n\t\tage = ((__force u32)itt >> ISCSI_AGE_SHIFT) & ISCSI_AGE_MASK;\n\t}\n\n\tif (age != session->age) {\n\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t  \"received itt %x expected session age (%x)\\n\",\n\t\t\t\t  (__force u32)itt, session->age);\n\t\treturn ISCSI_ERR_BAD_ITT;\n\t}\n\n\tif (i >= session->cmds_max) {\n\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t  \"received invalid itt index %u (max cmds \"\n\t\t\t\t   \"%u.\\n\", i, session->cmds_max);\n\t\treturn ISCSI_ERR_BAD_ITT;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iscsi_verify_itt);\n\n \nstruct iscsi_task *iscsi_itt_to_ctask(struct iscsi_conn *conn, itt_t itt)\n{\n\tstruct iscsi_task *task;\n\n\tif (iscsi_verify_itt(conn, itt))\n\t\treturn NULL;\n\n\ttask = iscsi_itt_to_task(conn, itt);\n\tif (!task || !task->sc)\n\t\treturn NULL;\n\n\tif (iscsi_cmd(task->sc)->age != conn->session->age) {\n\t\tiscsi_session_printk(KERN_ERR, conn->session,\n\t\t\t\t  \"task's session age %d, expected %d\\n\",\n\t\t\t\t  iscsi_cmd(task->sc)->age, conn->session->age);\n\t\treturn NULL;\n\t}\n\n\treturn task;\n}\nEXPORT_SYMBOL_GPL(iscsi_itt_to_ctask);\n\nvoid iscsi_session_failure(struct iscsi_session *session,\n\t\t\t   enum iscsi_err err)\n{\n\tstruct iscsi_conn *conn;\n\n\tspin_lock_bh(&session->frwd_lock);\n\tconn = session->leadconn;\n\tif (session->state == ISCSI_STATE_TERMINATE || !conn) {\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\treturn;\n\t}\n\n\tiscsi_get_conn(conn->cls_conn);\n\tspin_unlock_bh(&session->frwd_lock);\n\t \n\tif (err == ISCSI_ERR_INVALID_HOST)\n\t\tiscsi_conn_error_event(conn->cls_conn, err);\n\telse\n\t\tiscsi_conn_failure(conn, err);\n\tiscsi_put_conn(conn->cls_conn);\n}\nEXPORT_SYMBOL_GPL(iscsi_session_failure);\n\nstatic bool iscsi_set_conn_failed(struct iscsi_conn *conn)\n{\n\tstruct iscsi_session *session = conn->session;\n\n\tif (session->state == ISCSI_STATE_FAILED)\n\t\treturn false;\n\n\tif (conn->stop_stage == 0)\n\t\tsession->state = ISCSI_STATE_FAILED;\n\n\tset_bit(ISCSI_CONN_FLAG_SUSPEND_TX, &conn->flags);\n\tset_bit(ISCSI_CONN_FLAG_SUSPEND_RX, &conn->flags);\n\treturn true;\n}\n\nvoid iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err)\n{\n\tstruct iscsi_session *session = conn->session;\n\tbool needs_evt;\n\n\tspin_lock_bh(&session->frwd_lock);\n\tneeds_evt = iscsi_set_conn_failed(conn);\n\tspin_unlock_bh(&session->frwd_lock);\n\n\tif (needs_evt)\n\t\tiscsi_conn_error_event(conn->cls_conn, err);\n}\nEXPORT_SYMBOL_GPL(iscsi_conn_failure);\n\nstatic int iscsi_check_cmdsn_window_closed(struct iscsi_conn *conn)\n{\n\tstruct iscsi_session *session = conn->session;\n\n\t \n\tif (!iscsi_sna_lte(session->queued_cmdsn, session->max_cmdsn)) {\n\t\tISCSI_DBG_SESSION(session, \"iSCSI CmdSN closed. ExpCmdSn \"\n\t\t\t\t  \"%u MaxCmdSN %u CmdSN %u/%u\\n\",\n\t\t\t\t  session->exp_cmdsn, session->max_cmdsn,\n\t\t\t\t  session->cmdsn, session->queued_cmdsn);\n\t\treturn -ENOSPC;\n\t}\n\treturn 0;\n}\n\nstatic int iscsi_xmit_task(struct iscsi_conn *conn, struct iscsi_task *task,\n\t\t\t   bool was_requeue)\n{\n\tint rc;\n\n\tif (!conn->task) {\n\t\t \n\t\tif (!iscsi_get_task(task)) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t \n\t\tconn->task = NULL;\n\t}\n\n\t \n\tif (was_requeue)\n\t\tiscsi_put_task(task);\n\n\t \n\tif (test_bit(ISCSI_CONN_FLAG_SUSPEND_TX, &conn->flags)) {\n\t\t \n\t\tconn->task = task;\n\t\treturn -ENODATA;\n\t}\n\n\tspin_unlock_bh(&conn->session->frwd_lock);\n\trc = conn->session->tt->xmit_task(task);\n\tspin_lock_bh(&conn->session->frwd_lock);\n\tif (!rc) {\n\t\t \n\t\ttask->last_xfer = jiffies;\n\t} else {\n\t\t \n\t\tiscsi_get_task(task);\n\t\tconn->task = task;\n\t}\n\n\tiscsi_put_task(task);\n\treturn rc;\n}\n\n \nvoid iscsi_requeue_task(struct iscsi_task *task)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\n\t \n\tspin_lock_bh(&conn->session->frwd_lock);\n\tif (list_empty(&task->running)) {\n\t\tlist_add_tail(&task->running, &conn->requeue);\n\t} else {\n\t\t \n\t\tiscsi_put_task(task);\n\t}\n\tiscsi_conn_queue_xmit(conn);\n\tspin_unlock_bh(&conn->session->frwd_lock);\n}\nEXPORT_SYMBOL_GPL(iscsi_requeue_task);\n\n \nstatic int iscsi_data_xmit(struct iscsi_conn *conn)\n{\n\tstruct iscsi_task *task;\n\tint rc = 0;\n\n\tspin_lock_bh(&conn->session->frwd_lock);\n\tif (test_bit(ISCSI_CONN_FLAG_SUSPEND_TX, &conn->flags)) {\n\t\tISCSI_DBG_SESSION(conn->session, \"Tx suspended!\\n\");\n\t\tspin_unlock_bh(&conn->session->frwd_lock);\n\t\treturn -ENODATA;\n\t}\n\n\tif (conn->task) {\n\t\trc = iscsi_xmit_task(conn, conn->task, false);\n\t        if (rc)\n\t\t        goto done;\n\t}\n\n\t \ncheck_mgmt:\n\twhile (!list_empty(&conn->mgmtqueue)) {\n\t\ttask = list_entry(conn->mgmtqueue.next, struct iscsi_task,\n\t\t\t\t  running);\n\t\tlist_del_init(&task->running);\n\t\tif (iscsi_prep_mgmt_task(conn, task)) {\n\t\t\t \n\t\t\tspin_lock_bh(&conn->session->back_lock);\n\t\t\t__iscsi_put_task(task);\n\t\t\tspin_unlock_bh(&conn->session->back_lock);\n\t\t\tcontinue;\n\t\t}\n\t\trc = iscsi_xmit_task(conn, task, false);\n\t\tif (rc)\n\t\t\tgoto done;\n\t}\n\ncheck_requeue:\n\twhile (!list_empty(&conn->requeue)) {\n\t\t \n\t\tif (conn->session->state == ISCSI_STATE_LOGGING_OUT)\n\t\t\tbreak;\n\n\t\ttask = list_entry(conn->requeue.next, struct iscsi_task,\n\t\t\t\t  running);\n\n\t\tif (iscsi_check_tmf_restrictions(task, ISCSI_OP_SCSI_DATA_OUT))\n\t\t\tbreak;\n\n\t\tlist_del_init(&task->running);\n\t\trc = iscsi_xmit_task(conn, task, true);\n\t\tif (rc)\n\t\t\tgoto done;\n\t\tif (!list_empty(&conn->mgmtqueue))\n\t\t\tgoto check_mgmt;\n\t}\n\n\t \n\twhile (!list_empty(&conn->cmdqueue)) {\n\t\ttask = list_entry(conn->cmdqueue.next, struct iscsi_task,\n\t\t\t\t  running);\n\t\tlist_del_init(&task->running);\n\t\tif (conn->session->state == ISCSI_STATE_LOGGING_OUT) {\n\t\t\tfail_scsi_task(task, DID_IMM_RETRY);\n\t\t\tcontinue;\n\t\t}\n\t\trc = iscsi_prep_scsi_cmd_pdu(task);\n\t\tif (rc) {\n\t\t\tif (rc == -ENOMEM || rc == -EACCES)\n\t\t\t\tfail_scsi_task(task, DID_IMM_RETRY);\n\t\t\telse\n\t\t\t\tfail_scsi_task(task, DID_ABORT);\n\t\t\tcontinue;\n\t\t}\n\t\trc = iscsi_xmit_task(conn, task, false);\n\t\tif (rc)\n\t\t\tgoto done;\n\t\t \n\t\tif (!list_empty(&conn->mgmtqueue))\n\t\t\tgoto check_mgmt;\n\t\tif (!list_empty(&conn->requeue))\n\t\t\tgoto check_requeue;\n\t}\n\n\tspin_unlock_bh(&conn->session->frwd_lock);\n\treturn -ENODATA;\n\ndone:\n\tspin_unlock_bh(&conn->session->frwd_lock);\n\treturn rc;\n}\n\nstatic void iscsi_xmitworker(struct work_struct *work)\n{\n\tstruct iscsi_conn *conn =\n\t\tcontainer_of(work, struct iscsi_conn, xmitwork);\n\tint rc;\n\t \n\tdo {\n\t\trc = iscsi_data_xmit(conn);\n\t} while (rc >= 0 || rc == -EAGAIN);\n}\n\nstatic inline struct iscsi_task *iscsi_alloc_task(struct iscsi_conn *conn,\n\t\t\t\t\t\t  struct scsi_cmnd *sc)\n{\n\tstruct iscsi_task *task;\n\n\tif (!kfifo_out(&conn->session->cmdpool.queue,\n\t\t\t (void *) &task, sizeof(void *)))\n\t\treturn NULL;\n\n\tiscsi_cmd(sc)->age = conn->session->age;\n\tiscsi_cmd(sc)->task = task;\n\n\trefcount_set(&task->refcount, 1);\n\ttask->state = ISCSI_TASK_PENDING;\n\ttask->conn = conn;\n\ttask->sc = sc;\n\ttask->have_checked_conn = false;\n\ttask->last_timeout = jiffies;\n\ttask->last_xfer = jiffies;\n\ttask->protected = false;\n\tINIT_LIST_HEAD(&task->running);\n\treturn task;\n}\n\nenum {\n\tFAILURE_BAD_HOST = 1,\n\tFAILURE_SESSION_FAILED,\n\tFAILURE_SESSION_FREED,\n\tFAILURE_WINDOW_CLOSED,\n\tFAILURE_OOM,\n\tFAILURE_SESSION_TERMINATE,\n\tFAILURE_SESSION_IN_RECOVERY,\n\tFAILURE_SESSION_RECOVERY_TIMEOUT,\n\tFAILURE_SESSION_LOGGING_OUT,\n\tFAILURE_SESSION_NOT_READY,\n};\n\nint iscsi_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *sc)\n{\n\tstruct iscsi_cls_session *cls_session;\n\tstruct iscsi_host *ihost;\n\tint reason = 0;\n\tstruct iscsi_session *session;\n\tstruct iscsi_conn *conn;\n\tstruct iscsi_task *task = NULL;\n\n\tsc->result = 0;\n\tiscsi_cmd(sc)->task = NULL;\n\n\tihost = shost_priv(host);\n\n\tcls_session = starget_to_session(scsi_target(sc->device));\n\tsession = cls_session->dd_data;\n\tspin_lock_bh(&session->frwd_lock);\n\n\treason = iscsi_session_chkready(cls_session);\n\tif (reason) {\n\t\tsc->result = reason;\n\t\tgoto fault;\n\t}\n\n\tif (session->state != ISCSI_STATE_LOGGED_IN) {\n\t\t \n\t\tswitch (session->state) {\n\t\tcase ISCSI_STATE_FAILED:\n\t\t\t \n\t\t\tif (unlikely(system_state != SYSTEM_RUNNING)) {\n\t\t\t\treason = FAILURE_SESSION_FAILED;\n\t\t\t\tsc->result = DID_NO_CONNECT << 16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase ISCSI_STATE_IN_RECOVERY:\n\t\t\treason = FAILURE_SESSION_IN_RECOVERY;\n\t\t\tsc->result = DID_IMM_RETRY << 16;\n\t\t\tbreak;\n\t\tcase ISCSI_STATE_LOGGING_OUT:\n\t\t\treason = FAILURE_SESSION_LOGGING_OUT;\n\t\t\tsc->result = DID_IMM_RETRY << 16;\n\t\t\tbreak;\n\t\tcase ISCSI_STATE_RECOVERY_FAILED:\n\t\t\treason = FAILURE_SESSION_RECOVERY_TIMEOUT;\n\t\t\tsc->result = DID_TRANSPORT_FAILFAST << 16;\n\t\t\tbreak;\n\t\tcase ISCSI_STATE_TERMINATE:\n\t\t\treason = FAILURE_SESSION_TERMINATE;\n\t\t\tsc->result = DID_NO_CONNECT << 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treason = FAILURE_SESSION_FREED;\n\t\t\tsc->result = DID_NO_CONNECT << 16;\n\t\t}\n\t\tgoto fault;\n\t}\n\n\tconn = session->leadconn;\n\tif (!conn) {\n\t\treason = FAILURE_SESSION_FREED;\n\t\tsc->result = DID_NO_CONNECT << 16;\n\t\tgoto fault;\n\t}\n\n\tif (test_bit(ISCSI_CONN_FLAG_SUSPEND_TX, &conn->flags)) {\n\t\treason = FAILURE_SESSION_IN_RECOVERY;\n\t\tsc->result = DID_REQUEUE << 16;\n\t\tgoto fault;\n\t}\n\n\tif (iscsi_check_cmdsn_window_closed(conn)) {\n\t\treason = FAILURE_WINDOW_CLOSED;\n\t\tgoto reject;\n\t}\n\n\ttask = iscsi_alloc_task(conn, sc);\n\tif (!task) {\n\t\treason = FAILURE_OOM;\n\t\tgoto reject;\n\t}\n\n\tif (!ihost->workq) {\n\t\treason = iscsi_prep_scsi_cmd_pdu(task);\n\t\tif (reason) {\n\t\t\tif (reason == -ENOMEM ||  reason == -EACCES) {\n\t\t\t\treason = FAILURE_OOM;\n\t\t\t\tgoto prepd_reject;\n\t\t\t} else {\n\t\t\t\tsc->result = DID_ABORT << 16;\n\t\t\t\tgoto prepd_fault;\n\t\t\t}\n\t\t}\n\t\tif (session->tt->xmit_task(task)) {\n\t\t\tsession->cmdsn--;\n\t\t\treason = FAILURE_SESSION_NOT_READY;\n\t\t\tgoto prepd_reject;\n\t\t}\n\t} else {\n\t\tlist_add_tail(&task->running, &conn->cmdqueue);\n\t\tiscsi_conn_queue_xmit(conn);\n\t}\n\n\tsession->queued_cmdsn++;\n\tspin_unlock_bh(&session->frwd_lock);\n\treturn 0;\n\nprepd_reject:\n\tspin_lock_bh(&session->back_lock);\n\tiscsi_complete_task(task, ISCSI_TASK_REQUEUE_SCSIQ);\n\tspin_unlock_bh(&session->back_lock);\nreject:\n\tspin_unlock_bh(&session->frwd_lock);\n\tISCSI_DBG_SESSION(session, \"cmd 0x%x rejected (%d)\\n\",\n\t\t\t  sc->cmnd[0], reason);\n\treturn SCSI_MLQUEUE_TARGET_BUSY;\n\nprepd_fault:\n\tspin_lock_bh(&session->back_lock);\n\tiscsi_complete_task(task, ISCSI_TASK_REQUEUE_SCSIQ);\n\tspin_unlock_bh(&session->back_lock);\nfault:\n\tspin_unlock_bh(&session->frwd_lock);\n\tISCSI_DBG_SESSION(session, \"iscsi: cmd 0x%x is not queued (%d)\\n\",\n\t\t\t  sc->cmnd[0], reason);\n\tscsi_set_resid(sc, scsi_bufflen(sc));\n\tscsi_done(sc);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iscsi_queuecommand);\n\nint iscsi_target_alloc(struct scsi_target *starget)\n{\n\tstruct iscsi_cls_session *cls_session = starget_to_session(starget);\n\tstruct iscsi_session *session = cls_session->dd_data;\n\n\tstarget->can_queue = session->scsi_cmds_max;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iscsi_target_alloc);\n\nstatic void iscsi_tmf_timedout(struct timer_list *t)\n{\n\tstruct iscsi_session *session = from_timer(session, t, tmf_timer);\n\n\tspin_lock(&session->frwd_lock);\n\tif (session->tmf_state == TMF_QUEUED) {\n\t\tsession->tmf_state = TMF_TIMEDOUT;\n\t\tISCSI_DBG_EH(session, \"tmf timedout\\n\");\n\t\t \n\t\twake_up(&session->ehwait);\n\t}\n\tspin_unlock(&session->frwd_lock);\n}\n\nstatic int iscsi_exec_task_mgmt_fn(struct iscsi_conn *conn,\n\t\t\t\t   struct iscsi_tm *hdr, int age,\n\t\t\t\t   int timeout)\n\t__must_hold(&session->frwd_lock)\n{\n\tstruct iscsi_session *session = conn->session;\n\n\tif (__iscsi_conn_send_pdu(conn, (struct iscsi_hdr *)hdr, NULL, 0)) {\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\tiscsi_conn_printk(KERN_ERR, conn, \"Could not send TMF.\\n\");\n\t\tiscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);\n\t\tspin_lock_bh(&session->frwd_lock);\n\t\treturn -EPERM;\n\t}\n\tconn->tmfcmd_pdus_cnt++;\n\tsession->tmf_timer.expires = timeout * HZ + jiffies;\n\tadd_timer(&session->tmf_timer);\n\tISCSI_DBG_EH(session, \"tmf set timeout\\n\");\n\n\tspin_unlock_bh(&session->frwd_lock);\n\tmutex_unlock(&session->eh_mutex);\n\n\t \n\twait_event_interruptible(session->ehwait, age != session->age ||\n\t\t\t\t session->state != ISCSI_STATE_LOGGED_IN ||\n\t\t\t\t session->tmf_state != TMF_QUEUED);\n\tif (signal_pending(current))\n\t\tflush_signals(current);\n\tdel_timer_sync(&session->tmf_timer);\n\n\tmutex_lock(&session->eh_mutex);\n\tspin_lock_bh(&session->frwd_lock);\n\t \n\tif (age != session->age ||\n\t    session->state != ISCSI_STATE_LOGGED_IN)\n\t\treturn -ENOTCONN;\n\treturn 0;\n}\n\n \nstatic void fail_scsi_tasks(struct iscsi_conn *conn, u64 lun, int error)\n{\n\tstruct iscsi_session *session = conn->session;\n\tstruct iscsi_task *task;\n\tint i;\n\nrestart_cmd_loop:\n\tspin_lock_bh(&session->back_lock);\n\tfor (i = 0; i < session->cmds_max; i++) {\n\t\ttask = session->cmds[i];\n\t\tif (!task->sc || task->state == ISCSI_TASK_FREE)\n\t\t\tcontinue;\n\n\t\tif (lun != -1 && lun != task->sc->device->lun)\n\t\t\tcontinue;\n\t\t \n\t\tif (!iscsi_get_task(task)) {\n\t\t\tspin_unlock_bh(&session->back_lock);\n\t\t\tspin_unlock_bh(&session->frwd_lock);\n\t\t\tudelay(ISCSI_CMD_COMPL_WAIT);\n\t\t\tspin_lock_bh(&session->frwd_lock);\n\t\t\tgoto restart_cmd_loop;\n\t\t}\n\n\t\tISCSI_DBG_SESSION(session,\n\t\t\t\t  \"failing sc %p itt 0x%x state %d\\n\",\n\t\t\t\t  task->sc, task->itt, task->state);\n\t\t__fail_scsi_task(task, error);\n\t\t__iscsi_put_task(task);\n\t}\n\tspin_unlock_bh(&session->back_lock);\n}\n\n \nvoid iscsi_suspend_queue(struct iscsi_conn *conn)\n{\n\tspin_lock_bh(&conn->session->frwd_lock);\n\tset_bit(ISCSI_CONN_FLAG_SUSPEND_TX, &conn->flags);\n\tspin_unlock_bh(&conn->session->frwd_lock);\n}\nEXPORT_SYMBOL_GPL(iscsi_suspend_queue);\n\n \nvoid iscsi_suspend_tx(struct iscsi_conn *conn)\n{\n\tstruct Scsi_Host *shost = conn->session->host;\n\tstruct iscsi_host *ihost = shost_priv(shost);\n\n\tset_bit(ISCSI_CONN_FLAG_SUSPEND_TX, &conn->flags);\n\tif (ihost->workq)\n\t\tflush_work(&conn->xmitwork);\n}\nEXPORT_SYMBOL_GPL(iscsi_suspend_tx);\n\nstatic void iscsi_start_tx(struct iscsi_conn *conn)\n{\n\tclear_bit(ISCSI_CONN_FLAG_SUSPEND_TX, &conn->flags);\n\tiscsi_conn_queue_xmit(conn);\n}\n\n \nvoid iscsi_suspend_rx(struct iscsi_conn *conn)\n{\n\tstruct Scsi_Host *shost = conn->session->host;\n\tstruct iscsi_host *ihost = shost_priv(shost);\n\n\tset_bit(ISCSI_CONN_FLAG_SUSPEND_RX, &conn->flags);\n\tif (ihost->workq)\n\t\tflush_work(&conn->recvwork);\n}\nEXPORT_SYMBOL_GPL(iscsi_suspend_rx);\n\n \nstatic int iscsi_has_ping_timed_out(struct iscsi_conn *conn)\n{\n\tif (READ_ONCE(conn->ping_task) &&\n\t    time_before_eq(conn->last_recv + (conn->recv_timeout * HZ) +\n\t\t\t   (conn->ping_timeout * HZ), jiffies))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nenum scsi_timeout_action iscsi_eh_cmd_timed_out(struct scsi_cmnd *sc)\n{\n\tenum scsi_timeout_action rc = SCSI_EH_NOT_HANDLED;\n\tstruct iscsi_task *task = NULL, *running_task;\n\tstruct iscsi_cls_session *cls_session;\n\tstruct iscsi_session *session;\n\tstruct iscsi_conn *conn;\n\tint i;\n\n\tcls_session = starget_to_session(scsi_target(sc->device));\n\tsession = cls_session->dd_data;\n\n\tISCSI_DBG_EH(session, \"scsi cmd %p timedout\\n\", sc);\n\n\tspin_lock_bh(&session->frwd_lock);\n\tspin_lock(&session->back_lock);\n\ttask = iscsi_cmd(sc)->task;\n\tif (!task) {\n\t\t \n\t\trc = SCSI_EH_NOT_HANDLED;\n\t\tspin_unlock(&session->back_lock);\n\t\tgoto done;\n\t}\n\tif (!iscsi_get_task(task)) {\n\t\t \n\t\trc = SCSI_EH_RESET_TIMER;\n\t\ttask = NULL;\n\t\tspin_unlock(&session->back_lock);\n\t\tgoto done;\n\t}\n\tspin_unlock(&session->back_lock);\n\n\tif (session->state != ISCSI_STATE_LOGGED_IN) {\n\t\t \n\t\tif (unlikely(system_state != SYSTEM_RUNNING)) {\n\t\t\tsc->result = DID_NO_CONNECT << 16;\n\t\t\tISCSI_DBG_EH(session, \"sc on shutdown, handled\\n\");\n\t\t\trc = SCSI_EH_NOT_HANDLED;\n\t\t\tgoto done;\n\t\t}\n\t\t \n\t\trc = SCSI_EH_RESET_TIMER;\n\t\tgoto done;\n\t}\n\n\tconn = session->leadconn;\n\tif (!conn) {\n\t\t \n\t\trc = SCSI_EH_RESET_TIMER;\n\t\tgoto done;\n\t}\n\n\t \n\tif (time_after(task->last_xfer, task->last_timeout)) {\n\t\tISCSI_DBG_EH(session, \"Command making progress. Asking \"\n\t\t\t     \"scsi-ml for more time to complete. \"\n\t\t\t     \"Last data xfer at %lu. Last timeout was at \"\n\t\t\t     \"%lu\\n.\", task->last_xfer, task->last_timeout);\n\t\ttask->have_checked_conn = false;\n\t\trc = SCSI_EH_RESET_TIMER;\n\t\tgoto done;\n\t}\n\n\tif (!conn->recv_timeout && !conn->ping_timeout)\n\t\tgoto done;\n\t \n\tif (iscsi_has_ping_timed_out(conn)) {\n\t\trc = SCSI_EH_RESET_TIMER;\n\t\tgoto done;\n\t}\n\n\tspin_lock(&session->back_lock);\n\tfor (i = 0; i < conn->session->cmds_max; i++) {\n\t\trunning_task = conn->session->cmds[i];\n\t\tif (!running_task->sc || running_task == task ||\n\t\t     running_task->state != ISCSI_TASK_RUNNING)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (time_after(running_task->sc->jiffies_at_alloc,\n\t\t\t       task->sc->jiffies_at_alloc))\n\t\t\tcontinue;\n\n\t\tif (time_after(running_task->last_xfer, task->last_timeout)) {\n\t\t\t \n\t\t\tISCSI_DBG_EH(session, \"Command has not made progress \"\n\t\t\t\t     \"but commands ahead of it have. \"\n\t\t\t\t     \"Asking scsi-ml for more time to \"\n\t\t\t\t     \"complete. Our last xfer vs running task \"\n\t\t\t\t     \"last xfer %lu/%lu. Last check %lu.\\n\",\n\t\t\t\t     task->last_xfer, running_task->last_xfer,\n\t\t\t\t     task->last_timeout);\n\t\t\tspin_unlock(&session->back_lock);\n\t\t\trc = SCSI_EH_RESET_TIMER;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tspin_unlock(&session->back_lock);\n\n\t \n\tif (task->have_checked_conn)\n\t\tgoto done;\n\n\t \n\tif (READ_ONCE(conn->ping_task)) {\n\t\ttask->have_checked_conn = true;\n\t\trc = SCSI_EH_RESET_TIMER;\n\t\tgoto done;\n\t}\n\n\t \n\tiscsi_send_nopout(conn, NULL);\n\ttask->have_checked_conn = true;\n\trc = SCSI_EH_RESET_TIMER;\n\ndone:\n\tspin_unlock_bh(&session->frwd_lock);\n\n\tif (task) {\n\t\ttask->last_timeout = jiffies;\n\t\tiscsi_put_task(task);\n\t}\n\tISCSI_DBG_EH(session, \"return %s\\n\", rc == SCSI_EH_RESET_TIMER ?\n\t\t     \"timer reset\" : \"shutdown or nh\");\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(iscsi_eh_cmd_timed_out);\n\nstatic void iscsi_check_transport_timeouts(struct timer_list *t)\n{\n\tstruct iscsi_conn *conn = from_timer(conn, t, transport_timer);\n\tstruct iscsi_session *session = conn->session;\n\tunsigned long recv_timeout, next_timeout = 0, last_recv;\n\n\tspin_lock(&session->frwd_lock);\n\tif (session->state != ISCSI_STATE_LOGGED_IN)\n\t\tgoto done;\n\n\trecv_timeout = conn->recv_timeout;\n\tif (!recv_timeout)\n\t\tgoto done;\n\n\trecv_timeout *= HZ;\n\tlast_recv = conn->last_recv;\n\n\tif (iscsi_has_ping_timed_out(conn)) {\n\t\tiscsi_conn_printk(KERN_ERR, conn, \"ping timeout of %d secs \"\n\t\t\t\t  \"expired, recv timeout %d, last rx %lu, \"\n\t\t\t\t  \"last ping %lu, now %lu\\n\",\n\t\t\t\t  conn->ping_timeout, conn->recv_timeout,\n\t\t\t\t  last_recv, conn->last_ping, jiffies);\n\t\tspin_unlock(&session->frwd_lock);\n\t\tiscsi_conn_failure(conn, ISCSI_ERR_NOP_TIMEDOUT);\n\t\treturn;\n\t}\n\n\tif (time_before_eq(last_recv + recv_timeout, jiffies)) {\n\t\t \n\t\tISCSI_DBG_CONN(conn, \"Sending nopout as ping\\n\");\n\t\tif (iscsi_send_nopout(conn, NULL))\n\t\t\tnext_timeout = jiffies + (1 * HZ);\n\t\telse\n\t\t\tnext_timeout = conn->last_ping + (conn->ping_timeout * HZ);\n\t} else\n\t\tnext_timeout = last_recv + recv_timeout;\n\n\tISCSI_DBG_CONN(conn, \"Setting next tmo %lu\\n\", next_timeout);\n\tmod_timer(&conn->transport_timer, next_timeout);\ndone:\n\tspin_unlock(&session->frwd_lock);\n}\n\n \nvoid iscsi_conn_unbind(struct iscsi_cls_conn *cls_conn, bool is_active)\n{\n\tstruct iscsi_session *session;\n\tstruct iscsi_conn *conn;\n\n\tif (!cls_conn)\n\t\treturn;\n\n\tconn = cls_conn->dd_data;\n\tsession = conn->session;\n\t \n\tmutex_lock(&session->eh_mutex);\n\n\tiscsi_suspend_queue(conn);\n\tiscsi_suspend_tx(conn);\n\n\tspin_lock_bh(&session->frwd_lock);\n\tclear_bit(ISCSI_CONN_FLAG_BOUND, &conn->flags);\n\n\tif (!is_active) {\n\t\t \n\t\tif (session->state == ISCSI_STATE_LOGGED_IN)\n\t\t\tiscsi_set_conn_failed(conn);\n\t}\n\tspin_unlock_bh(&session->frwd_lock);\n\tmutex_unlock(&session->eh_mutex);\n}\nEXPORT_SYMBOL_GPL(iscsi_conn_unbind);\n\nstatic void iscsi_prep_abort_task_pdu(struct iscsi_task *task,\n\t\t\t\t      struct iscsi_tm *hdr)\n{\n\tmemset(hdr, 0, sizeof(*hdr));\n\thdr->opcode = ISCSI_OP_SCSI_TMFUNC | ISCSI_OP_IMMEDIATE;\n\thdr->flags = ISCSI_TM_FUNC_ABORT_TASK & ISCSI_FLAG_TM_FUNC_MASK;\n\thdr->flags |= ISCSI_FLAG_CMD_FINAL;\n\thdr->lun = task->lun;\n\thdr->rtt = task->hdr_itt;\n\thdr->refcmdsn = task->cmdsn;\n}\n\nint iscsi_eh_abort(struct scsi_cmnd *sc)\n{\n\tstruct iscsi_cls_session *cls_session;\n\tstruct iscsi_session *session;\n\tstruct iscsi_conn *conn;\n\tstruct iscsi_task *task;\n\tstruct iscsi_tm *hdr;\n\tint age;\n\n\tcls_session = starget_to_session(scsi_target(sc->device));\n\tsession = cls_session->dd_data;\n\n\tISCSI_DBG_EH(session, \"aborting sc %p\\n\", sc);\n\ncompletion_check:\n\tmutex_lock(&session->eh_mutex);\n\tspin_lock_bh(&session->frwd_lock);\n\t \n\tif (!iscsi_cmd(sc)->task) {\n\t\tISCSI_DBG_EH(session, \"sc never reached iscsi layer or \"\n\t\t\t\t      \"it completed.\\n\");\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\tmutex_unlock(&session->eh_mutex);\n\t\treturn SUCCESS;\n\t}\n\n\t \n\tif (!session->leadconn || session->state != ISCSI_STATE_LOGGED_IN ||\n\t    iscsi_cmd(sc)->age != session->age) {\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\tmutex_unlock(&session->eh_mutex);\n\t\tISCSI_DBG_EH(session, \"failing abort due to dropped \"\n\t\t\t\t  \"session.\\n\");\n\t\treturn FAILED;\n\t}\n\n\tspin_lock(&session->back_lock);\n\ttask = iscsi_cmd(sc)->task;\n\tif (!task || !task->sc) {\n\t\t \n\t\tISCSI_DBG_EH(session, \"sc completed while abort in progress\\n\");\n\n\t\tspin_unlock(&session->back_lock);\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\tmutex_unlock(&session->eh_mutex);\n\t\treturn SUCCESS;\n\t}\n\n\tif (!iscsi_get_task(task)) {\n\t\tspin_unlock(&session->back_lock);\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\tmutex_unlock(&session->eh_mutex);\n\t\t \n\t\tudelay(ISCSI_CMD_COMPL_WAIT);\n\t\tgoto completion_check;\n\t}\n\n\tISCSI_DBG_EH(session, \"aborting [sc %p itt 0x%x]\\n\", sc, task->itt);\n\tconn = session->leadconn;\n\tiscsi_get_conn(conn->cls_conn);\n\tconn->eh_abort_cnt++;\n\tage = session->age;\n\tspin_unlock(&session->back_lock);\n\n\tif (task->state == ISCSI_TASK_PENDING) {\n\t\tfail_scsi_task(task, DID_ABORT);\n\t\tgoto success;\n\t}\n\n\t \n\tif (session->tmf_state != TMF_INITIAL)\n\t\tgoto failed;\n\tsession->tmf_state = TMF_QUEUED;\n\n\thdr = &session->tmhdr;\n\tiscsi_prep_abort_task_pdu(task, hdr);\n\n\tif (iscsi_exec_task_mgmt_fn(conn, hdr, age, session->abort_timeout))\n\t\tgoto failed;\n\n\tswitch (session->tmf_state) {\n\tcase TMF_SUCCESS:\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\t \n\t\tiscsi_suspend_tx(conn);\n\t\t \n\t\tspin_lock_bh(&session->frwd_lock);\n\t\tfail_scsi_task(task, DID_ABORT);\n\t\tsession->tmf_state = TMF_INITIAL;\n\t\tmemset(hdr, 0, sizeof(*hdr));\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\tiscsi_start_tx(conn);\n\t\tgoto success_unlocked;\n\tcase TMF_TIMEDOUT:\n\t\tsession->running_aborted_task = task;\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\tiscsi_conn_failure(conn, ISCSI_ERR_SCSI_EH_SESSION_RST);\n\t\tgoto failed_unlocked;\n\tcase TMF_NOT_FOUND:\n\t\tif (iscsi_task_is_completed(task)) {\n\t\t\tsession->tmf_state = TMF_INITIAL;\n\t\t\tmemset(hdr, 0, sizeof(*hdr));\n\t\t\t \n\t\t\tISCSI_DBG_EH(session, \"sc completed while abort\tin \"\n\t\t\t\t\t      \"progress\\n\");\n\t\t\tgoto success;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tsession->tmf_state = TMF_INITIAL;\n\t\tgoto failed;\n\t}\n\nsuccess:\n\tspin_unlock_bh(&session->frwd_lock);\nsuccess_unlocked:\n\tISCSI_DBG_EH(session, \"abort success [sc %p itt 0x%x]\\n\",\n\t\t     sc, task->itt);\n\tiscsi_put_task(task);\n\tiscsi_put_conn(conn->cls_conn);\n\tmutex_unlock(&session->eh_mutex);\n\treturn SUCCESS;\n\nfailed:\n\tspin_unlock_bh(&session->frwd_lock);\nfailed_unlocked:\n\tISCSI_DBG_EH(session, \"abort failed [sc %p itt 0x%x]\\n\", sc,\n\t\t     task ? task->itt : 0);\n\t \n\tif (!session->running_aborted_task)\n\t\tiscsi_put_task(task);\n\n\tiscsi_put_conn(conn->cls_conn);\n\tmutex_unlock(&session->eh_mutex);\n\treturn FAILED;\n}\nEXPORT_SYMBOL_GPL(iscsi_eh_abort);\n\nstatic void iscsi_prep_lun_reset_pdu(struct scsi_cmnd *sc, struct iscsi_tm *hdr)\n{\n\tmemset(hdr, 0, sizeof(*hdr));\n\thdr->opcode = ISCSI_OP_SCSI_TMFUNC | ISCSI_OP_IMMEDIATE;\n\thdr->flags = ISCSI_TM_FUNC_LOGICAL_UNIT_RESET & ISCSI_FLAG_TM_FUNC_MASK;\n\thdr->flags |= ISCSI_FLAG_CMD_FINAL;\n\tint_to_scsilun(sc->device->lun, &hdr->lun);\n\thdr->rtt = RESERVED_ITT;\n}\n\nint iscsi_eh_device_reset(struct scsi_cmnd *sc)\n{\n\tstruct iscsi_cls_session *cls_session;\n\tstruct iscsi_session *session;\n\tstruct iscsi_conn *conn;\n\tstruct iscsi_tm *hdr;\n\tint rc = FAILED;\n\n\tcls_session = starget_to_session(scsi_target(sc->device));\n\tsession = cls_session->dd_data;\n\n\tISCSI_DBG_EH(session, \"LU Reset [sc %p lun %llu]\\n\", sc,\n\t\t     sc->device->lun);\n\n\tmutex_lock(&session->eh_mutex);\n\tspin_lock_bh(&session->frwd_lock);\n\t \n\tif (!session->leadconn || session->state != ISCSI_STATE_LOGGED_IN)\n\t\tgoto unlock;\n\tconn = session->leadconn;\n\n\t \n\tif (session->tmf_state != TMF_INITIAL)\n\t\tgoto unlock;\n\tsession->tmf_state = TMF_QUEUED;\n\n\thdr = &session->tmhdr;\n\tiscsi_prep_lun_reset_pdu(sc, hdr);\n\n\tif (iscsi_exec_task_mgmt_fn(conn, hdr, session->age,\n\t\t\t\t    session->lu_reset_timeout)) {\n\t\trc = FAILED;\n\t\tgoto unlock;\n\t}\n\n\tswitch (session->tmf_state) {\n\tcase TMF_SUCCESS:\n\t\tbreak;\n\tcase TMF_TIMEDOUT:\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\tiscsi_conn_failure(conn, ISCSI_ERR_SCSI_EH_SESSION_RST);\n\t\tgoto done;\n\tdefault:\n\t\tsession->tmf_state = TMF_INITIAL;\n\t\tgoto unlock;\n\t}\n\n\trc = SUCCESS;\n\tspin_unlock_bh(&session->frwd_lock);\n\n\tiscsi_suspend_tx(conn);\n\n\tspin_lock_bh(&session->frwd_lock);\n\tmemset(hdr, 0, sizeof(*hdr));\n\tfail_scsi_tasks(conn, sc->device->lun, DID_ERROR);\n\tsession->tmf_state = TMF_INITIAL;\n\tspin_unlock_bh(&session->frwd_lock);\n\n\tiscsi_start_tx(conn);\n\tgoto done;\n\nunlock:\n\tspin_unlock_bh(&session->frwd_lock);\ndone:\n\tISCSI_DBG_EH(session, \"dev reset result = %s\\n\",\n\t\t     rc == SUCCESS ? \"SUCCESS\" : \"FAILED\");\n\tmutex_unlock(&session->eh_mutex);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(iscsi_eh_device_reset);\n\nvoid iscsi_session_recovery_timedout(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *session = cls_session->dd_data;\n\n\tspin_lock_bh(&session->frwd_lock);\n\tif (session->state != ISCSI_STATE_LOGGED_IN) {\n\t\tsession->state = ISCSI_STATE_RECOVERY_FAILED;\n\t\twake_up(&session->ehwait);\n\t}\n\tspin_unlock_bh(&session->frwd_lock);\n}\nEXPORT_SYMBOL_GPL(iscsi_session_recovery_timedout);\n\n \nint iscsi_eh_session_reset(struct scsi_cmnd *sc)\n{\n\tstruct iscsi_cls_session *cls_session;\n\tstruct iscsi_session *session;\n\tstruct iscsi_conn *conn;\n\n\tcls_session = starget_to_session(scsi_target(sc->device));\n\tsession = cls_session->dd_data;\n\n\tmutex_lock(&session->eh_mutex);\n\tspin_lock_bh(&session->frwd_lock);\n\tif (session->state == ISCSI_STATE_TERMINATE) {\nfailed:\n\t\tISCSI_DBG_EH(session,\n\t\t\t     \"failing session reset: Could not log back into \"\n\t\t\t     \"%s [age %d]\\n\", session->targetname,\n\t\t\t     session->age);\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\tmutex_unlock(&session->eh_mutex);\n\t\treturn FAILED;\n\t}\n\n\tconn = session->leadconn;\n\tiscsi_get_conn(conn->cls_conn);\n\n\tspin_unlock_bh(&session->frwd_lock);\n\tmutex_unlock(&session->eh_mutex);\n\n\tiscsi_conn_failure(conn, ISCSI_ERR_SCSI_EH_SESSION_RST);\n\tiscsi_put_conn(conn->cls_conn);\n\n\tISCSI_DBG_EH(session, \"wait for relogin\\n\");\n\twait_event_interruptible(session->ehwait,\n\t\t\t\t session->state == ISCSI_STATE_TERMINATE ||\n\t\t\t\t session->state == ISCSI_STATE_LOGGED_IN ||\n\t\t\t\t session->state == ISCSI_STATE_RECOVERY_FAILED);\n\tif (signal_pending(current))\n\t\tflush_signals(current);\n\n\tmutex_lock(&session->eh_mutex);\n\tspin_lock_bh(&session->frwd_lock);\n\tif (session->state == ISCSI_STATE_LOGGED_IN) {\n\t\tISCSI_DBG_EH(session,\n\t\t\t     \"session reset succeeded for %s,%s\\n\",\n\t\t\t     session->targetname, conn->persistent_address);\n\t} else\n\t\tgoto failed;\n\tspin_unlock_bh(&session->frwd_lock);\n\tmutex_unlock(&session->eh_mutex);\n\treturn SUCCESS;\n}\nEXPORT_SYMBOL_GPL(iscsi_eh_session_reset);\n\nstatic void iscsi_prep_tgt_reset_pdu(struct scsi_cmnd *sc, struct iscsi_tm *hdr)\n{\n\tmemset(hdr, 0, sizeof(*hdr));\n\thdr->opcode = ISCSI_OP_SCSI_TMFUNC | ISCSI_OP_IMMEDIATE;\n\thdr->flags = ISCSI_TM_FUNC_TARGET_WARM_RESET & ISCSI_FLAG_TM_FUNC_MASK;\n\thdr->flags |= ISCSI_FLAG_CMD_FINAL;\n\thdr->rtt = RESERVED_ITT;\n}\n\n \nstatic int iscsi_eh_target_reset(struct scsi_cmnd *sc)\n{\n\tstruct iscsi_cls_session *cls_session;\n\tstruct iscsi_session *session;\n\tstruct iscsi_conn *conn;\n\tstruct iscsi_tm *hdr;\n\tint rc = FAILED;\n\n\tcls_session = starget_to_session(scsi_target(sc->device));\n\tsession = cls_session->dd_data;\n\n\tISCSI_DBG_EH(session, \"tgt Reset [sc %p tgt %s]\\n\", sc,\n\t\t     session->targetname);\n\n\tmutex_lock(&session->eh_mutex);\n\tspin_lock_bh(&session->frwd_lock);\n\t \n\tif (!session->leadconn || session->state != ISCSI_STATE_LOGGED_IN)\n\t\tgoto unlock;\n\tconn = session->leadconn;\n\n\t \n\tif (session->tmf_state != TMF_INITIAL)\n\t\tgoto unlock;\n\tsession->tmf_state = TMF_QUEUED;\n\n\thdr = &session->tmhdr;\n\tiscsi_prep_tgt_reset_pdu(sc, hdr);\n\n\tif (iscsi_exec_task_mgmt_fn(conn, hdr, session->age,\n\t\t\t\t    session->tgt_reset_timeout)) {\n\t\trc = FAILED;\n\t\tgoto unlock;\n\t}\n\n\tswitch (session->tmf_state) {\n\tcase TMF_SUCCESS:\n\t\tbreak;\n\tcase TMF_TIMEDOUT:\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\tiscsi_conn_failure(conn, ISCSI_ERR_SCSI_EH_SESSION_RST);\n\t\tgoto done;\n\tdefault:\n\t\tsession->tmf_state = TMF_INITIAL;\n\t\tgoto unlock;\n\t}\n\n\trc = SUCCESS;\n\tspin_unlock_bh(&session->frwd_lock);\n\n\tiscsi_suspend_tx(conn);\n\n\tspin_lock_bh(&session->frwd_lock);\n\tmemset(hdr, 0, sizeof(*hdr));\n\tfail_scsi_tasks(conn, -1, DID_ERROR);\n\tsession->tmf_state = TMF_INITIAL;\n\tspin_unlock_bh(&session->frwd_lock);\n\n\tiscsi_start_tx(conn);\n\tgoto done;\n\nunlock:\n\tspin_unlock_bh(&session->frwd_lock);\ndone:\n\tISCSI_DBG_EH(session, \"tgt %s reset result = %s\\n\", session->targetname,\n\t\t     rc == SUCCESS ? \"SUCCESS\" : \"FAILED\");\n\tmutex_unlock(&session->eh_mutex);\n\treturn rc;\n}\n\n \nint iscsi_eh_recover_target(struct scsi_cmnd *sc)\n{\n\tint rc;\n\n\trc = iscsi_eh_target_reset(sc);\n\tif (rc == FAILED)\n\t\trc = iscsi_eh_session_reset(sc);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(iscsi_eh_recover_target);\n\n \nint\niscsi_pool_init(struct iscsi_pool *q, int max, void ***items, int item_size)\n{\n\tint i, num_arrays = 1;\n\n\tmemset(q, 0, sizeof(*q));\n\n\tq->max = max;\n\n\t \n\tif (items)\n\t\tnum_arrays++;\n\tq->pool = kvcalloc(num_arrays * max, sizeof(void *), GFP_KERNEL);\n\tif (q->pool == NULL)\n\t\treturn -ENOMEM;\n\n\tkfifo_init(&q->queue, (void*)q->pool, max * sizeof(void*));\n\n\tfor (i = 0; i < max; i++) {\n\t\tq->pool[i] = kzalloc(item_size, GFP_KERNEL);\n\t\tif (q->pool[i] == NULL) {\n\t\t\tq->max = i;\n\t\t\tgoto enomem;\n\t\t}\n\t\tkfifo_in(&q->queue, (void*)&q->pool[i], sizeof(void*));\n\t}\n\n\tif (items) {\n\t\t*items = q->pool + max;\n\t\tmemcpy(*items, q->pool, max * sizeof(void *));\n\t}\n\n\treturn 0;\n\nenomem:\n\tiscsi_pool_free(q);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(iscsi_pool_init);\n\nvoid iscsi_pool_free(struct iscsi_pool *q)\n{\n\tint i;\n\n\tfor (i = 0; i < q->max; i++)\n\t\tkfree(q->pool[i]);\n\tkvfree(q->pool);\n}\nEXPORT_SYMBOL_GPL(iscsi_pool_free);\n\nint iscsi_host_get_max_scsi_cmds(struct Scsi_Host *shost,\n\t\t\t\t uint16_t requested_cmds_max)\n{\n\tint scsi_cmds, total_cmds = requested_cmds_max;\n\ncheck:\n\tif (!total_cmds)\n\t\ttotal_cmds = ISCSI_DEF_XMIT_CMDS_MAX;\n\t \n\tif (total_cmds < ISCSI_TOTAL_CMDS_MIN) {\n\t\tprintk(KERN_ERR \"iscsi: invalid max cmds of %d. Must be a power of two that is at least %d.\\n\",\n\t\t       total_cmds, ISCSI_TOTAL_CMDS_MIN);\n\t\treturn -EINVAL;\n\t}\n\n\tif (total_cmds > ISCSI_TOTAL_CMDS_MAX) {\n\t\tprintk(KERN_INFO \"iscsi: invalid max cmds of %d. Must be a power of 2 less than or equal to %d. Using %d.\\n\",\n\t\t       requested_cmds_max, ISCSI_TOTAL_CMDS_MAX,\n\t\t       ISCSI_TOTAL_CMDS_MAX);\n\t\ttotal_cmds = ISCSI_TOTAL_CMDS_MAX;\n\t}\n\n\tif (!is_power_of_2(total_cmds)) {\n\t\ttotal_cmds = rounddown_pow_of_two(total_cmds);\n\t\tif (total_cmds < ISCSI_TOTAL_CMDS_MIN) {\n\t\t\tprintk(KERN_ERR \"iscsi: invalid max cmds of %d. Must be a power of 2 greater than %d.\\n\", requested_cmds_max, ISCSI_TOTAL_CMDS_MIN);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprintk(KERN_INFO \"iscsi: invalid max cmds %d. Must be a power of 2. Rounding max cmds down to %d.\\n\",\n\t\t       requested_cmds_max, total_cmds);\n\t}\n\n\tscsi_cmds = total_cmds - ISCSI_MGMT_CMDS_MAX;\n\tif (shost->can_queue && scsi_cmds > shost->can_queue) {\n\t\ttotal_cmds = shost->can_queue;\n\n\t\tprintk(KERN_INFO \"iscsi: requested max cmds %u is higher than driver limit. Using driver limit %u\\n\",\n\t\t       requested_cmds_max, shost->can_queue);\n\t\tgoto check;\n\t}\n\n\treturn scsi_cmds;\n}\nEXPORT_SYMBOL_GPL(iscsi_host_get_max_scsi_cmds);\n\n \nint iscsi_host_add(struct Scsi_Host *shost, struct device *pdev)\n{\n\tif (!shost->can_queue)\n\t\tshost->can_queue = ISCSI_DEF_XMIT_CMDS_MAX;\n\n\tif (!shost->cmd_per_lun)\n\t\tshost->cmd_per_lun = ISCSI_DEF_CMD_PER_LUN;\n\n\treturn scsi_add_host(shost, pdev);\n}\nEXPORT_SYMBOL_GPL(iscsi_host_add);\n\n \nstruct Scsi_Host *iscsi_host_alloc(const struct scsi_host_template *sht,\n\t\t\t\t   int dd_data_size, bool xmit_can_sleep)\n{\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_host *ihost;\n\n\tshost = scsi_host_alloc(sht, sizeof(struct iscsi_host) + dd_data_size);\n\tif (!shost)\n\t\treturn NULL;\n\tihost = shost_priv(shost);\n\n\tif (xmit_can_sleep) {\n\t\tihost->workq = alloc_workqueue(\"iscsi_q_%d\",\n\t\t\tWQ_SYSFS | __WQ_LEGACY | WQ_MEM_RECLAIM | WQ_UNBOUND,\n\t\t\t1, shost->host_no);\n\t\tif (!ihost->workq)\n\t\t\tgoto free_host;\n\t}\n\n\tspin_lock_init(&ihost->lock);\n\tihost->state = ISCSI_HOST_SETUP;\n\tihost->num_sessions = 0;\n\tinit_waitqueue_head(&ihost->session_removal_wq);\n\treturn shost;\n\nfree_host:\n\tscsi_host_put(shost);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(iscsi_host_alloc);\n\nstatic void iscsi_notify_host_removed(struct iscsi_cls_session *cls_session)\n{\n\tiscsi_session_failure(cls_session->dd_data, ISCSI_ERR_INVALID_HOST);\n}\n\n \nvoid iscsi_host_remove(struct Scsi_Host *shost, bool is_shutdown)\n{\n\tstruct iscsi_host *ihost = shost_priv(shost);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ihost->lock, flags);\n\tihost->state = ISCSI_HOST_REMOVED;\n\tspin_unlock_irqrestore(&ihost->lock, flags);\n\n\tif (!is_shutdown)\n\t\tiscsi_host_for_each_session(shost, iscsi_notify_host_removed);\n\telse\n\t\tiscsi_host_for_each_session(shost, iscsi_force_destroy_session);\n\n\twait_event_interruptible(ihost->session_removal_wq,\n\t\t\t\t ihost->num_sessions == 0);\n\tif (signal_pending(current))\n\t\tflush_signals(current);\n\n\tscsi_remove_host(shost);\n}\nEXPORT_SYMBOL_GPL(iscsi_host_remove);\n\nvoid iscsi_host_free(struct Scsi_Host *shost)\n{\n\tstruct iscsi_host *ihost = shost_priv(shost);\n\n\tif (ihost->workq)\n\t\tdestroy_workqueue(ihost->workq);\n\n\tkfree(ihost->netdev);\n\tkfree(ihost->hwaddress);\n\tkfree(ihost->initiatorname);\n\tscsi_host_put(shost);\n}\nEXPORT_SYMBOL_GPL(iscsi_host_free);\n\nstatic void iscsi_host_dec_session_cnt(struct Scsi_Host *shost)\n{\n\tstruct iscsi_host *ihost = shost_priv(shost);\n\tunsigned long flags;\n\n\tshost = scsi_host_get(shost);\n\tif (!shost) {\n\t\tprintk(KERN_ERR \"Invalid state. Cannot notify host removal \"\n\t\t      \"of session teardown event because host already \"\n\t\t      \"removed.\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&ihost->lock, flags);\n\tihost->num_sessions--;\n\tif (ihost->num_sessions == 0)\n\t\twake_up(&ihost->session_removal_wq);\n\tspin_unlock_irqrestore(&ihost->lock, flags);\n\tscsi_host_put(shost);\n}\n\n \nstruct iscsi_cls_session *\niscsi_session_setup(struct iscsi_transport *iscsit, struct Scsi_Host *shost,\n\t\t    uint16_t cmds_max, int dd_size, int cmd_task_size,\n\t\t    uint32_t initial_cmdsn, unsigned int id)\n{\n\tstruct iscsi_host *ihost = shost_priv(shost);\n\tstruct iscsi_session *session;\n\tstruct iscsi_cls_session *cls_session;\n\tint cmd_i, scsi_cmds;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ihost->lock, flags);\n\tif (ihost->state == ISCSI_HOST_REMOVED) {\n\t\tspin_unlock_irqrestore(&ihost->lock, flags);\n\t\treturn NULL;\n\t}\n\tihost->num_sessions++;\n\tspin_unlock_irqrestore(&ihost->lock, flags);\n\n\tscsi_cmds = iscsi_host_get_max_scsi_cmds(shost, cmds_max);\n\tif (scsi_cmds < 0)\n\t\tgoto dec_session_count;\n\n\tcls_session = iscsi_alloc_session(shost, iscsit,\n\t\t\t\t\t  sizeof(struct iscsi_session) +\n\t\t\t\t\t  dd_size);\n\tif (!cls_session)\n\t\tgoto dec_session_count;\n\tsession = cls_session->dd_data;\n\tsession->cls_session = cls_session;\n\tsession->host = shost;\n\tsession->state = ISCSI_STATE_FREE;\n\tsession->fast_abort = 1;\n\tsession->tgt_reset_timeout = 30;\n\tsession->lu_reset_timeout = 15;\n\tsession->abort_timeout = 10;\n\tsession->scsi_cmds_max = scsi_cmds;\n\tsession->cmds_max = scsi_cmds + ISCSI_MGMT_CMDS_MAX;\n\tsession->queued_cmdsn = session->cmdsn = initial_cmdsn;\n\tsession->exp_cmdsn = initial_cmdsn + 1;\n\tsession->max_cmdsn = initial_cmdsn + 1;\n\tsession->max_r2t = 1;\n\tsession->tt = iscsit;\n\tsession->dd_data = cls_session->dd_data + sizeof(*session);\n\n\tsession->tmf_state = TMF_INITIAL;\n\ttimer_setup(&session->tmf_timer, iscsi_tmf_timedout, 0);\n\tmutex_init(&session->eh_mutex);\n\tinit_waitqueue_head(&session->ehwait);\n\n\tspin_lock_init(&session->frwd_lock);\n\tspin_lock_init(&session->back_lock);\n\n\t \n\tif (iscsi_pool_init(&session->cmdpool, session->cmds_max,\n\t\t\t    (void***)&session->cmds,\n\t\t\t    cmd_task_size + sizeof(struct iscsi_task)))\n\t\tgoto cmdpool_alloc_fail;\n\n\t \n\tfor (cmd_i = 0; cmd_i < session->cmds_max; cmd_i++) {\n\t\tstruct iscsi_task *task = session->cmds[cmd_i];\n\n\t\tif (cmd_task_size)\n\t\t\ttask->dd_data = &task[1];\n\t\ttask->itt = cmd_i;\n\t\ttask->state = ISCSI_TASK_FREE;\n\t\tINIT_LIST_HEAD(&task->running);\n\t}\n\n\tif (!try_module_get(iscsit->owner))\n\t\tgoto module_get_fail;\n\n\tif (iscsi_add_session(cls_session, id))\n\t\tgoto cls_session_fail;\n\n\treturn cls_session;\n\ncls_session_fail:\n\tmodule_put(iscsit->owner);\nmodule_get_fail:\n\tiscsi_pool_free(&session->cmdpool);\ncmdpool_alloc_fail:\n\tiscsi_free_session(cls_session);\ndec_session_count:\n\tiscsi_host_dec_session_cnt(shost);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(iscsi_session_setup);\n\n \nvoid iscsi_session_remove(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *session = cls_session->dd_data;\n\tstruct Scsi_Host *shost = session->host;\n\n\tiscsi_remove_session(cls_session);\n\t \n\tiscsi_host_dec_session_cnt(shost);\n}\nEXPORT_SYMBOL_GPL(iscsi_session_remove);\n\n \nvoid iscsi_session_free(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *session = cls_session->dd_data;\n\tstruct module *owner = cls_session->transport->owner;\n\n\tiscsi_pool_free(&session->cmdpool);\n\tkfree(session->password);\n\tkfree(session->password_in);\n\tkfree(session->username);\n\tkfree(session->username_in);\n\tkfree(session->targetname);\n\tkfree(session->targetalias);\n\tkfree(session->initiatorname);\n\tkfree(session->boot_root);\n\tkfree(session->boot_nic);\n\tkfree(session->boot_target);\n\tkfree(session->ifacename);\n\tkfree(session->portal_type);\n\tkfree(session->discovery_parent_type);\n\n\tiscsi_free_session(cls_session);\n\tmodule_put(owner);\n}\nEXPORT_SYMBOL_GPL(iscsi_session_free);\n\n \nvoid iscsi_session_teardown(struct iscsi_cls_session *cls_session)\n{\n\tiscsi_session_remove(cls_session);\n\tiscsi_session_free(cls_session);\n}\nEXPORT_SYMBOL_GPL(iscsi_session_teardown);\n\n \nstruct iscsi_cls_conn *\niscsi_conn_setup(struct iscsi_cls_session *cls_session, int dd_size,\n\t\t uint32_t conn_idx)\n{\n\tstruct iscsi_session *session = cls_session->dd_data;\n\tstruct iscsi_conn *conn;\n\tstruct iscsi_cls_conn *cls_conn;\n\tchar *data;\n\tint err;\n\n\tcls_conn = iscsi_alloc_conn(cls_session, sizeof(*conn) + dd_size,\n\t\t\t\t     conn_idx);\n\tif (!cls_conn)\n\t\treturn NULL;\n\tconn = cls_conn->dd_data;\n\n\tconn->dd_data = cls_conn->dd_data + sizeof(*conn);\n\tconn->session = session;\n\tconn->cls_conn = cls_conn;\n\tconn->c_stage = ISCSI_CONN_INITIAL_STAGE;\n\tconn->id = conn_idx;\n\tconn->exp_statsn = 0;\n\n\ttimer_setup(&conn->transport_timer, iscsi_check_transport_timeouts, 0);\n\n\tINIT_LIST_HEAD(&conn->mgmtqueue);\n\tINIT_LIST_HEAD(&conn->cmdqueue);\n\tINIT_LIST_HEAD(&conn->requeue);\n\tINIT_WORK(&conn->xmitwork, iscsi_xmitworker);\n\n\t \n\tspin_lock_bh(&session->frwd_lock);\n\tif (!kfifo_out(&session->cmdpool.queue,\n                         (void*)&conn->login_task,\n\t\t\t sizeof(void*))) {\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\tgoto login_task_alloc_fail;\n\t}\n\tspin_unlock_bh(&session->frwd_lock);\n\n\tdata = (char *) __get_free_pages(GFP_KERNEL,\n\t\t\t\t\t get_order(ISCSI_DEF_MAX_RECV_SEG_LEN));\n\tif (!data)\n\t\tgoto login_task_data_alloc_fail;\n\tconn->login_task->data = conn->data = data;\n\n\terr = iscsi_add_conn(cls_conn);\n\tif (err)\n\t\tgoto login_task_add_dev_fail;\n\n\treturn cls_conn;\n\nlogin_task_add_dev_fail:\n\tfree_pages((unsigned long) conn->data,\n\t\t   get_order(ISCSI_DEF_MAX_RECV_SEG_LEN));\n\nlogin_task_data_alloc_fail:\n\tkfifo_in(&session->cmdpool.queue, (void*)&conn->login_task,\n\t\t    sizeof(void*));\nlogin_task_alloc_fail:\n\tiscsi_put_conn(cls_conn);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(iscsi_conn_setup);\n\n \nvoid iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\n\tiscsi_remove_conn(cls_conn);\n\n\tdel_timer_sync(&conn->transport_timer);\n\n\tmutex_lock(&session->eh_mutex);\n\tspin_lock_bh(&session->frwd_lock);\n\tconn->c_stage = ISCSI_CONN_CLEANUP_WAIT;\n\tif (session->leadconn == conn) {\n\t\t \n\t\tsession->state = ISCSI_STATE_TERMINATE;\n\t\twake_up(&session->ehwait);\n\t}\n\tspin_unlock_bh(&session->frwd_lock);\n\n\t \n\tiscsi_suspend_tx(conn);\n\n\tspin_lock_bh(&session->frwd_lock);\n\tfree_pages((unsigned long) conn->data,\n\t\t   get_order(ISCSI_DEF_MAX_RECV_SEG_LEN));\n\tkfree(conn->persistent_address);\n\tkfree(conn->local_ipaddr);\n\t \n\tspin_lock_bh(&session->back_lock);\n\tkfifo_in(&session->cmdpool.queue, (void*)&conn->login_task,\n\t\t    sizeof(void*));\n\tspin_unlock_bh(&session->back_lock);\n\tif (session->leadconn == conn)\n\t\tsession->leadconn = NULL;\n\tspin_unlock_bh(&session->frwd_lock);\n\tmutex_unlock(&session->eh_mutex);\n\n\tiscsi_put_conn(cls_conn);\n}\nEXPORT_SYMBOL_GPL(iscsi_conn_teardown);\n\nint iscsi_conn_start(struct iscsi_cls_conn *cls_conn)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\n\tif (!session) {\n\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t  \"can't start unbound connection\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif ((session->imm_data_en || !session->initial_r2t_en) &&\n\t     session->first_burst > session->max_burst) {\n\t\tiscsi_conn_printk(KERN_INFO, conn, \"invalid burst lengths: \"\n\t\t\t\t  \"first_burst %d max_burst %d\\n\",\n\t\t\t\t  session->first_burst, session->max_burst);\n\t\treturn -EINVAL;\n\t}\n\n\tif (conn->ping_timeout && !conn->recv_timeout) {\n\t\tiscsi_conn_printk(KERN_ERR, conn, \"invalid recv timeout of \"\n\t\t\t\t  \"zero. Using 5 seconds\\n.\");\n\t\tconn->recv_timeout = 5;\n\t}\n\n\tif (conn->recv_timeout && !conn->ping_timeout) {\n\t\tiscsi_conn_printk(KERN_ERR, conn, \"invalid ping timeout of \"\n\t\t\t\t  \"zero. Using 5 seconds.\\n\");\n\t\tconn->ping_timeout = 5;\n\t}\n\n\tspin_lock_bh(&session->frwd_lock);\n\tconn->c_stage = ISCSI_CONN_STARTED;\n\tsession->state = ISCSI_STATE_LOGGED_IN;\n\tsession->queued_cmdsn = session->cmdsn;\n\n\tconn->last_recv = jiffies;\n\tconn->last_ping = jiffies;\n\tif (conn->recv_timeout && conn->ping_timeout)\n\t\tmod_timer(&conn->transport_timer,\n\t\t\t  jiffies + (conn->recv_timeout * HZ));\n\n\tswitch(conn->stop_stage) {\n\tcase STOP_CONN_RECOVER:\n\t\t \n\t\tconn->stop_stage = 0;\n\t\tsession->tmf_state = TMF_INITIAL;\n\t\tsession->age++;\n\t\tif (session->age == 16)\n\t\t\tsession->age = 0;\n\t\tbreak;\n\tcase STOP_CONN_TERM:\n\t\tconn->stop_stage = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock_bh(&session->frwd_lock);\n\n\tiscsi_unblock_session(session->cls_session);\n\twake_up(&session->ehwait);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iscsi_conn_start);\n\nstatic void\nfail_mgmt_tasks(struct iscsi_session *session, struct iscsi_conn *conn)\n{\n\tstruct iscsi_task *task;\n\tint i, state;\n\n\tfor (i = 0; i < conn->session->cmds_max; i++) {\n\t\ttask = conn->session->cmds[i];\n\t\tif (task->sc)\n\t\t\tcontinue;\n\n\t\tif (task->state == ISCSI_TASK_FREE)\n\t\t\tcontinue;\n\n\t\tISCSI_DBG_SESSION(conn->session,\n\t\t\t\t  \"failing mgmt itt 0x%x state %d\\n\",\n\t\t\t\t  task->itt, task->state);\n\n\t\tspin_lock_bh(&session->back_lock);\n\t\tif (cleanup_queued_task(task)) {\n\t\t\tspin_unlock_bh(&session->back_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstate = ISCSI_TASK_ABRT_SESS_RECOV;\n\t\tif (task->state == ISCSI_TASK_PENDING)\n\t\t\tstate = ISCSI_TASK_COMPLETED;\n\t\tiscsi_complete_task(task, state);\n\t\tspin_unlock_bh(&session->back_lock);\n\t}\n}\n\nvoid iscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\tint old_stop_stage;\n\n\tmutex_lock(&session->eh_mutex);\n\tspin_lock_bh(&session->frwd_lock);\n\tif (conn->stop_stage == STOP_CONN_TERM) {\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t\tmutex_unlock(&session->eh_mutex);\n\t\treturn;\n\t}\n\n\t \n\tif (flag == STOP_CONN_TERM)\n\t\tsession->state = ISCSI_STATE_TERMINATE;\n\telse if (conn->stop_stage != STOP_CONN_RECOVER)\n\t\tsession->state = ISCSI_STATE_IN_RECOVERY;\n\n\told_stop_stage = conn->stop_stage;\n\tconn->stop_stage = flag;\n\tspin_unlock_bh(&session->frwd_lock);\n\n\tdel_timer_sync(&conn->transport_timer);\n\tiscsi_suspend_tx(conn);\n\n\tspin_lock_bh(&session->frwd_lock);\n\tconn->c_stage = ISCSI_CONN_STOPPED;\n\tspin_unlock_bh(&session->frwd_lock);\n\n\t \n\tif (flag == STOP_CONN_RECOVER) {\n\t\tconn->hdrdgst_en = 0;\n\t\tconn->datadgst_en = 0;\n\t\tif (session->state == ISCSI_STATE_IN_RECOVERY &&\n\t\t    old_stop_stage != STOP_CONN_RECOVER) {\n\t\t\tISCSI_DBG_SESSION(session, \"blocking session\\n\");\n\t\t\tiscsi_block_session(session->cls_session);\n\t\t}\n\t}\n\n\t \n\tspin_lock_bh(&session->frwd_lock);\n\tfail_scsi_tasks(conn, -1, DID_TRANSPORT_DISRUPTED);\n\tfail_mgmt_tasks(session, conn);\n\tmemset(&session->tmhdr, 0, sizeof(session->tmhdr));\n\tspin_unlock_bh(&session->frwd_lock);\n\tmutex_unlock(&session->eh_mutex);\n}\nEXPORT_SYMBOL_GPL(iscsi_conn_stop);\n\nint iscsi_conn_bind(struct iscsi_cls_session *cls_session,\n\t\t    struct iscsi_cls_conn *cls_conn, int is_leading)\n{\n\tstruct iscsi_session *session = cls_session->dd_data;\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\n\tspin_lock_bh(&session->frwd_lock);\n\tif (is_leading)\n\t\tsession->leadconn = conn;\n\n\tset_bit(ISCSI_CONN_FLAG_BOUND, &conn->flags);\n\tspin_unlock_bh(&session->frwd_lock);\n\n\t \n\tspin_lock_bh(&session->back_lock);\n\tsession->max_cmdsn = session->exp_cmdsn = session->cmdsn + 1;\n\tspin_unlock_bh(&session->back_lock);\n\t \n\tclear_bit(ISCSI_CONN_FLAG_SUSPEND_RX, &conn->flags);\n\tclear_bit(ISCSI_CONN_FLAG_SUSPEND_TX, &conn->flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iscsi_conn_bind);\n\nint iscsi_switch_str_param(char **param, char *new_val_buf)\n{\n\tchar *new_val;\n\n\tif (*param) {\n\t\tif (!strcmp(*param, new_val_buf))\n\t\t\treturn 0;\n\t}\n\n\tnew_val = kstrdup(new_val_buf, GFP_NOIO);\n\tif (!new_val)\n\t\treturn -ENOMEM;\n\n\tkfree(*param);\n\t*param = new_val;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iscsi_switch_str_param);\n\nint iscsi_set_param(struct iscsi_cls_conn *cls_conn,\n\t\t    enum iscsi_param param, char *buf, int buflen)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\tint val;\n\n\tswitch(param) {\n\tcase ISCSI_PARAM_FAST_ABORT:\n\t\tsscanf(buf, \"%d\", &session->fast_abort);\n\t\tbreak;\n\tcase ISCSI_PARAM_ABORT_TMO:\n\t\tsscanf(buf, \"%d\", &session->abort_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_LU_RESET_TMO:\n\t\tsscanf(buf, \"%d\", &session->lu_reset_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_TGT_RESET_TMO:\n\t\tsscanf(buf, \"%d\", &session->tgt_reset_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_PING_TMO:\n\t\tsscanf(buf, \"%d\", &conn->ping_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_RECV_TMO:\n\t\tsscanf(buf, \"%d\", &conn->recv_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_RECV_DLENGTH:\n\t\tsscanf(buf, \"%d\", &conn->max_recv_dlength);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_XMIT_DLENGTH:\n\t\tsscanf(buf, \"%d\", &conn->max_xmit_dlength);\n\t\tbreak;\n\tcase ISCSI_PARAM_HDRDGST_EN:\n\t\tsscanf(buf, \"%d\", &conn->hdrdgst_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DATADGST_EN:\n\t\tsscanf(buf, \"%d\", &conn->datadgst_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_INITIAL_R2T_EN:\n\t\tsscanf(buf, \"%d\", &session->initial_r2t_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_R2T:\n\t\tsscanf(buf, \"%hu\", &session->max_r2t);\n\t\tbreak;\n\tcase ISCSI_PARAM_IMM_DATA_EN:\n\t\tsscanf(buf, \"%d\", &session->imm_data_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_FIRST_BURST:\n\t\tsscanf(buf, \"%d\", &session->first_burst);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_BURST:\n\t\tsscanf(buf, \"%d\", &session->max_burst);\n\t\tbreak;\n\tcase ISCSI_PARAM_PDU_INORDER_EN:\n\t\tsscanf(buf, \"%d\", &session->pdu_inorder_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DATASEQ_INORDER_EN:\n\t\tsscanf(buf, \"%d\", &session->dataseq_inorder_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_ERL:\n\t\tsscanf(buf, \"%d\", &session->erl);\n\t\tbreak;\n\tcase ISCSI_PARAM_EXP_STATSN:\n\t\tsscanf(buf, \"%u\", &conn->exp_statsn);\n\t\tbreak;\n\tcase ISCSI_PARAM_USERNAME:\n\t\treturn iscsi_switch_str_param(&session->username, buf);\n\tcase ISCSI_PARAM_USERNAME_IN:\n\t\treturn iscsi_switch_str_param(&session->username_in, buf);\n\tcase ISCSI_PARAM_PASSWORD:\n\t\treturn iscsi_switch_str_param(&session->password, buf);\n\tcase ISCSI_PARAM_PASSWORD_IN:\n\t\treturn iscsi_switch_str_param(&session->password_in, buf);\n\tcase ISCSI_PARAM_TARGET_NAME:\n\t\treturn iscsi_switch_str_param(&session->targetname, buf);\n\tcase ISCSI_PARAM_TARGET_ALIAS:\n\t\treturn iscsi_switch_str_param(&session->targetalias, buf);\n\tcase ISCSI_PARAM_TPGT:\n\t\tsscanf(buf, \"%d\", &session->tpgt);\n\t\tbreak;\n\tcase ISCSI_PARAM_PERSISTENT_PORT:\n\t\tsscanf(buf, \"%d\", &conn->persistent_port);\n\t\tbreak;\n\tcase ISCSI_PARAM_PERSISTENT_ADDRESS:\n\t\treturn iscsi_switch_str_param(&conn->persistent_address, buf);\n\tcase ISCSI_PARAM_IFACE_NAME:\n\t\treturn iscsi_switch_str_param(&session->ifacename, buf);\n\tcase ISCSI_PARAM_INITIATOR_NAME:\n\t\treturn iscsi_switch_str_param(&session->initiatorname, buf);\n\tcase ISCSI_PARAM_BOOT_ROOT:\n\t\treturn iscsi_switch_str_param(&session->boot_root, buf);\n\tcase ISCSI_PARAM_BOOT_NIC:\n\t\treturn iscsi_switch_str_param(&session->boot_nic, buf);\n\tcase ISCSI_PARAM_BOOT_TARGET:\n\t\treturn iscsi_switch_str_param(&session->boot_target, buf);\n\tcase ISCSI_PARAM_PORTAL_TYPE:\n\t\treturn iscsi_switch_str_param(&session->portal_type, buf);\n\tcase ISCSI_PARAM_DISCOVERY_PARENT_TYPE:\n\t\treturn iscsi_switch_str_param(&session->discovery_parent_type,\n\t\t\t\t\t      buf);\n\tcase ISCSI_PARAM_DISCOVERY_SESS:\n\t\tsscanf(buf, \"%d\", &val);\n\t\tsession->discovery_sess = !!val;\n\t\tbreak;\n\tcase ISCSI_PARAM_LOCAL_IPADDR:\n\t\treturn iscsi_switch_str_param(&conn->local_ipaddr, buf);\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iscsi_set_param);\n\nint iscsi_session_get_param(struct iscsi_cls_session *cls_session,\n\t\t\t    enum iscsi_param param, char *buf)\n{\n\tstruct iscsi_session *session = cls_session->dd_data;\n\tint len;\n\n\tswitch(param) {\n\tcase ISCSI_PARAM_FAST_ABORT:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->fast_abort);\n\t\tbreak;\n\tcase ISCSI_PARAM_ABORT_TMO:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->abort_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_LU_RESET_TMO:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->lu_reset_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_TGT_RESET_TMO:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->tgt_reset_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_INITIAL_R2T_EN:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->initial_r2t_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_R2T:\n\t\tlen = sysfs_emit(buf, \"%hu\\n\", session->max_r2t);\n\t\tbreak;\n\tcase ISCSI_PARAM_IMM_DATA_EN:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->imm_data_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_FIRST_BURST:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->first_burst);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_BURST:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->max_burst);\n\t\tbreak;\n\tcase ISCSI_PARAM_PDU_INORDER_EN:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->pdu_inorder_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DATASEQ_INORDER_EN:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->dataseq_inorder_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DEF_TASKMGMT_TMO:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->def_taskmgmt_tmo);\n\t\tbreak;\n\tcase ISCSI_PARAM_ERL:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->erl);\n\t\tbreak;\n\tcase ISCSI_PARAM_TARGET_NAME:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->targetname);\n\t\tbreak;\n\tcase ISCSI_PARAM_TARGET_ALIAS:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->targetalias);\n\t\tbreak;\n\tcase ISCSI_PARAM_TPGT:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->tpgt);\n\t\tbreak;\n\tcase ISCSI_PARAM_USERNAME:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->username);\n\t\tbreak;\n\tcase ISCSI_PARAM_USERNAME_IN:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->username_in);\n\t\tbreak;\n\tcase ISCSI_PARAM_PASSWORD:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->password);\n\t\tbreak;\n\tcase ISCSI_PARAM_PASSWORD_IN:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->password_in);\n\t\tbreak;\n\tcase ISCSI_PARAM_IFACE_NAME:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->ifacename);\n\t\tbreak;\n\tcase ISCSI_PARAM_INITIATOR_NAME:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->initiatorname);\n\t\tbreak;\n\tcase ISCSI_PARAM_BOOT_ROOT:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->boot_root);\n\t\tbreak;\n\tcase ISCSI_PARAM_BOOT_NIC:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->boot_nic);\n\t\tbreak;\n\tcase ISCSI_PARAM_BOOT_TARGET:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->boot_target);\n\t\tbreak;\n\tcase ISCSI_PARAM_AUTO_SND_TGT_DISABLE:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->auto_snd_tgt_disable);\n\t\tbreak;\n\tcase ISCSI_PARAM_DISCOVERY_SESS:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_sess);\n\t\tbreak;\n\tcase ISCSI_PARAM_PORTAL_TYPE:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->portal_type);\n\t\tbreak;\n\tcase ISCSI_PARAM_CHAP_AUTH_EN:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->chap_auth_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DISCOVERY_LOGOUT_EN:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_logout_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_BIDI_CHAP_EN:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->bidi_chap_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DISCOVERY_AUTH_OPTIONAL:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_auth_optional);\n\t\tbreak;\n\tcase ISCSI_PARAM_DEF_TIME2WAIT:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->time2wait);\n\t\tbreak;\n\tcase ISCSI_PARAM_DEF_TIME2RETAIN:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->time2retain);\n\t\tbreak;\n\tcase ISCSI_PARAM_TSID:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->tsid);\n\t\tbreak;\n\tcase ISCSI_PARAM_ISID:\n\t\tlen = sysfs_emit(buf, \"%02x%02x%02x%02x%02x%02x\\n\",\n\t\t\t      session->isid[0], session->isid[1],\n\t\t\t      session->isid[2], session->isid[3],\n\t\t\t      session->isid[4], session->isid[5]);\n\t\tbreak;\n\tcase ISCSI_PARAM_DISCOVERY_PARENT_IDX:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_parent_idx);\n\t\tbreak;\n\tcase ISCSI_PARAM_DISCOVERY_PARENT_TYPE:\n\t\tif (session->discovery_parent_type)\n\t\t\tlen = sysfs_emit(buf, \"%s\\n\",\n\t\t\t\t      session->discovery_parent_type);\n\t\telse\n\t\t\tlen = sysfs_emit(buf, \"\\n\");\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(iscsi_session_get_param);\n\nint iscsi_conn_get_addr_param(struct sockaddr_storage *addr,\n\t\t\t      enum iscsi_param param, char *buf)\n{\n\tstruct sockaddr_in6 *sin6 = NULL;\n\tstruct sockaddr_in *sin = NULL;\n\tint len;\n\n\tswitch (addr->ss_family) {\n\tcase AF_INET:\n\t\tsin = (struct sockaddr_in *)addr;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsin6 = (struct sockaddr_in6 *)addr;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (param) {\n\tcase ISCSI_PARAM_CONN_ADDRESS:\n\tcase ISCSI_HOST_PARAM_IPADDRESS:\n\t\tif (sin)\n\t\t\tlen = sysfs_emit(buf, \"%pI4\\n\", &sin->sin_addr.s_addr);\n\t\telse\n\t\t\tlen = sysfs_emit(buf, \"%pI6\\n\", &sin6->sin6_addr);\n\t\tbreak;\n\tcase ISCSI_PARAM_CONN_PORT:\n\tcase ISCSI_PARAM_LOCAL_PORT:\n\t\tif (sin)\n\t\t\tlen = sysfs_emit(buf, \"%hu\\n\", be16_to_cpu(sin->sin_port));\n\t\telse\n\t\t\tlen = sysfs_emit(buf, \"%hu\\n\",\n\t\t\t\t      be16_to_cpu(sin6->sin6_port));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(iscsi_conn_get_addr_param);\n\nint iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,\n\t\t\t enum iscsi_param param, char *buf)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tint len;\n\n\tswitch(param) {\n\tcase ISCSI_PARAM_PING_TMO:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->ping_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_RECV_TMO:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->recv_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_RECV_DLENGTH:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->max_recv_dlength);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_XMIT_DLENGTH:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->max_xmit_dlength);\n\t\tbreak;\n\tcase ISCSI_PARAM_HDRDGST_EN:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", conn->hdrdgst_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DATADGST_EN:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", conn->datadgst_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_IFMARKER_EN:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", conn->ifmarker_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_OFMARKER_EN:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", conn->ofmarker_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_EXP_STATSN:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->exp_statsn);\n\t\tbreak;\n\tcase ISCSI_PARAM_PERSISTENT_PORT:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", conn->persistent_port);\n\t\tbreak;\n\tcase ISCSI_PARAM_PERSISTENT_ADDRESS:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", conn->persistent_address);\n\t\tbreak;\n\tcase ISCSI_PARAM_STATSN:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->statsn);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_SEGMENT_SIZE:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->max_segment_size);\n\t\tbreak;\n\tcase ISCSI_PARAM_KEEPALIVE_TMO:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->keepalive_tmo);\n\t\tbreak;\n\tcase ISCSI_PARAM_LOCAL_PORT:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->local_port);\n\t\tbreak;\n\tcase ISCSI_PARAM_TCP_TIMESTAMP_STAT:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->tcp_timestamp_stat);\n\t\tbreak;\n\tcase ISCSI_PARAM_TCP_NAGLE_DISABLE:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->tcp_nagle_disable);\n\t\tbreak;\n\tcase ISCSI_PARAM_TCP_WSF_DISABLE:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->tcp_wsf_disable);\n\t\tbreak;\n\tcase ISCSI_PARAM_TCP_TIMER_SCALE:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->tcp_timer_scale);\n\t\tbreak;\n\tcase ISCSI_PARAM_TCP_TIMESTAMP_EN:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->tcp_timestamp_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_IP_FRAGMENT_DISABLE:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->fragment_disable);\n\t\tbreak;\n\tcase ISCSI_PARAM_IPV4_TOS:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->ipv4_tos);\n\t\tbreak;\n\tcase ISCSI_PARAM_IPV6_TC:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->ipv6_traffic_class);\n\t\tbreak;\n\tcase ISCSI_PARAM_IPV6_FLOW_LABEL:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->ipv6_flow_label);\n\t\tbreak;\n\tcase ISCSI_PARAM_IS_FW_ASSIGNED_IPV6:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->is_fw_assigned_ipv6);\n\t\tbreak;\n\tcase ISCSI_PARAM_TCP_XMIT_WSF:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->tcp_xmit_wsf);\n\t\tbreak;\n\tcase ISCSI_PARAM_TCP_RECV_WSF:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", conn->tcp_recv_wsf);\n\t\tbreak;\n\tcase ISCSI_PARAM_LOCAL_IPADDR:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", conn->local_ipaddr);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(iscsi_conn_get_param);\n\nint iscsi_host_get_param(struct Scsi_Host *shost, enum iscsi_host_param param,\n\t\t\t char *buf)\n{\n\tstruct iscsi_host *ihost = shost_priv(shost);\n\tint len;\n\n\tswitch (param) {\n\tcase ISCSI_HOST_PARAM_NETDEV_NAME:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", ihost->netdev);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", ihost->hwaddress);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_INITIATOR_NAME:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", ihost->initiatorname);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(iscsi_host_get_param);\n\nint iscsi_host_set_param(struct Scsi_Host *shost, enum iscsi_host_param param,\n\t\t\t char *buf, int buflen)\n{\n\tstruct iscsi_host *ihost = shost_priv(shost);\n\n\tswitch (param) {\n\tcase ISCSI_HOST_PARAM_NETDEV_NAME:\n\t\treturn iscsi_switch_str_param(&ihost->netdev, buf);\n\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\treturn iscsi_switch_str_param(&ihost->hwaddress, buf);\n\tcase ISCSI_HOST_PARAM_INITIATOR_NAME:\n\t\treturn iscsi_switch_str_param(&ihost->initiatorname, buf);\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iscsi_host_set_param);\n\nMODULE_AUTHOR(\"Mike Christie\");\nMODULE_DESCRIPTION(\"iSCSI library functions\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}