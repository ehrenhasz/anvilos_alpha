{
  "module_name": "fnic_debugfs.c",
  "hash_id": "3377bfd68a5cb4aec34c536cdb195eb5f19be857f283ece3b4e17209f54686a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/fnic/fnic_debugfs.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include \"fnic.h\"\n\nstatic struct dentry *fnic_trace_debugfs_root;\nstatic struct dentry *fnic_trace_debugfs_file;\nstatic struct dentry *fnic_trace_enable;\nstatic struct dentry *fnic_stats_debugfs_root;\n\nstatic struct dentry *fnic_fc_trace_debugfs_file;\nstatic struct dentry *fnic_fc_rdata_trace_debugfs_file;\nstatic struct dentry *fnic_fc_trace_enable;\nstatic struct dentry *fnic_fc_trace_clear;\n\nstruct fc_trace_flag_type {\n\tu8 fc_row_file;\n\tu8 fc_normal_file;\n\tu8 fnic_trace;\n\tu8 fc_trace;\n\tu8 fc_clear;\n};\n\nstatic struct fc_trace_flag_type *fc_trc_flag;\n\n \nint fnic_debugfs_init(void)\n{\n\tfnic_trace_debugfs_root = debugfs_create_dir(\"fnic\", NULL);\n\n\tfnic_stats_debugfs_root = debugfs_create_dir(\"statistics\",\n\t\t\t\t\t\tfnic_trace_debugfs_root);\n\n\t \n\tfc_trc_flag = vmalloc(sizeof(struct fc_trace_flag_type));\n\n\tif (fc_trc_flag) {\n\t\tfc_trc_flag->fc_row_file = 0;\n\t\tfc_trc_flag->fc_normal_file = 1;\n\t\tfc_trc_flag->fnic_trace = 2;\n\t\tfc_trc_flag->fc_trace = 3;\n\t\tfc_trc_flag->fc_clear = 4;\n\t\treturn 0;\n\t}\n\n\treturn -ENOMEM;\n}\n\n \nvoid fnic_debugfs_terminate(void)\n{\n\tdebugfs_remove(fnic_stats_debugfs_root);\n\tfnic_stats_debugfs_root = NULL;\n\n\tdebugfs_remove(fnic_trace_debugfs_root);\n\tfnic_trace_debugfs_root = NULL;\n\n\tvfree(fc_trc_flag);\n}\n\n \nstatic ssize_t fnic_trace_ctrl_read(struct file *filp,\n\t\t\t\t  char __user *ubuf,\n\t\t\t\t  size_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\n\tint len;\n\tu8 *trace_type;\n\tlen = 0;\n\ttrace_type = (u8 *)filp->private_data;\n\tif (*trace_type == fc_trc_flag->fnic_trace)\n\t\tlen = sprintf(buf, \"%d\\n\", fnic_tracing_enabled);\n\telse if (*trace_type == fc_trc_flag->fc_trace)\n\t\tlen = sprintf(buf, \"%d\\n\", fnic_fc_tracing_enabled);\n\telse if (*trace_type == fc_trc_flag->fc_clear)\n\t\tlen = sprintf(buf, \"%d\\n\", fnic_fc_trace_cleared);\n\telse\n\t\tpr_err(\"fnic: Cannot read to any debugfs file\\n\");\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, len);\n}\n\n \nstatic ssize_t fnic_trace_ctrl_write(struct file *filp,\n\t\t\t\t  const char __user *ubuf,\n\t\t\t\t  size_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\n\tunsigned long val;\n\tint ret;\n\tu8 *trace_type;\n\ttrace_type = (u8 *)filp->private_data;\n\n\tif (cnt >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&buf, ubuf, cnt))\n\t\treturn -EFAULT;\n\n\tbuf[cnt] = 0;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (*trace_type == fc_trc_flag->fnic_trace)\n\t\tfnic_tracing_enabled = val;\n\telse if (*trace_type == fc_trc_flag->fc_trace)\n\t\tfnic_fc_tracing_enabled = val;\n\telse if (*trace_type == fc_trc_flag->fc_clear)\n\t\tfnic_fc_trace_cleared = val;\n\telse\n\t\tpr_err(\"fnic: cannot write to any debugfs file\\n\");\n\n\t(*ppos)++;\n\n\treturn cnt;\n}\n\nstatic const struct file_operations fnic_trace_ctrl_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = fnic_trace_ctrl_read,\n\t.write = fnic_trace_ctrl_write,\n};\n\n \nstatic int fnic_trace_debugfs_open(struct inode *inode,\n\t\t\t\t  struct file *file)\n{\n\tfnic_dbgfs_t *fnic_dbg_prt;\n\tu8 *rdata_ptr;\n\trdata_ptr = (u8 *)inode->i_private;\n\tfnic_dbg_prt = kzalloc(sizeof(fnic_dbgfs_t), GFP_KERNEL);\n\tif (!fnic_dbg_prt)\n\t\treturn -ENOMEM;\n\n\tif (*rdata_ptr == fc_trc_flag->fnic_trace) {\n\t\tfnic_dbg_prt->buffer = vzalloc(array3_size(3, trace_max_pages,\n\t\t\t\t\t\t\t   PAGE_SIZE));\n\t\tif (!fnic_dbg_prt->buffer) {\n\t\t\tkfree(fnic_dbg_prt);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfnic_dbg_prt->buffer_len = fnic_get_trace_data(fnic_dbg_prt);\n\t} else {\n\t\tfnic_dbg_prt->buffer =\n\t\t\tvzalloc(array3_size(3, fnic_fc_trace_max_pages,\n\t\t\t\t\t    PAGE_SIZE));\n\t\tif (!fnic_dbg_prt->buffer) {\n\t\t\tkfree(fnic_dbg_prt);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfnic_dbg_prt->buffer_len =\n\t\t\tfnic_fc_trace_get_data(fnic_dbg_prt, *rdata_ptr);\n\t}\n\tfile->private_data = fnic_dbg_prt;\n\n\treturn 0;\n}\n\n \nstatic loff_t fnic_trace_debugfs_lseek(struct file *file,\n\t\t\t\t\tloff_t offset,\n\t\t\t\t\tint howto)\n{\n\tfnic_dbgfs_t *fnic_dbg_prt = file->private_data;\n\treturn fixed_size_llseek(file, offset, howto,\n\t\t\t\tfnic_dbg_prt->buffer_len);\n}\n\n \nstatic ssize_t fnic_trace_debugfs_read(struct file *file,\n\t\t\t\t\tchar __user *ubuf,\n\t\t\t\t\tsize_t nbytes,\n\t\t\t\t\tloff_t *pos)\n{\n\tfnic_dbgfs_t *fnic_dbg_prt = file->private_data;\n\tint rc = 0;\n\trc = simple_read_from_buffer(ubuf, nbytes, pos,\n\t\t\t\t  fnic_dbg_prt->buffer,\n\t\t\t\t  fnic_dbg_prt->buffer_len);\n\treturn rc;\n}\n\n \nstatic int fnic_trace_debugfs_release(struct inode *inode,\n\t\t\t\t\t  struct file *file)\n{\n\tfnic_dbgfs_t *fnic_dbg_prt = file->private_data;\n\n\tvfree(fnic_dbg_prt->buffer);\n\tkfree(fnic_dbg_prt);\n\treturn 0;\n}\n\nstatic const struct file_operations fnic_trace_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.open = fnic_trace_debugfs_open,\n\t.llseek = fnic_trace_debugfs_lseek,\n\t.read = fnic_trace_debugfs_read,\n\t.release = fnic_trace_debugfs_release,\n};\n\n \nvoid fnic_trace_debugfs_init(void)\n{\n\tfnic_trace_enable = debugfs_create_file(\"tracing_enable\",\n\t\t\t\t\tS_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\t\tfnic_trace_debugfs_root,\n\t\t\t\t\t&(fc_trc_flag->fnic_trace),\n\t\t\t\t\t&fnic_trace_ctrl_fops);\n\n\tfnic_trace_debugfs_file = debugfs_create_file(\"trace\",\n\t\t\t\t\tS_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\t\tfnic_trace_debugfs_root,\n\t\t\t\t\t&(fc_trc_flag->fnic_trace),\n\t\t\t\t\t&fnic_trace_debugfs_fops);\n}\n\n \nvoid fnic_trace_debugfs_terminate(void)\n{\n\tdebugfs_remove(fnic_trace_debugfs_file);\n\tfnic_trace_debugfs_file = NULL;\n\n\tdebugfs_remove(fnic_trace_enable);\n\tfnic_trace_enable = NULL;\n}\n\n \n\nvoid fnic_fc_trace_debugfs_init(void)\n{\n\tfnic_fc_trace_enable = debugfs_create_file(\"fc_trace_enable\",\n\t\t\t\t\tS_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\t\tfnic_trace_debugfs_root,\n\t\t\t\t\t&(fc_trc_flag->fc_trace),\n\t\t\t\t\t&fnic_trace_ctrl_fops);\n\n\tfnic_fc_trace_clear = debugfs_create_file(\"fc_trace_clear\",\n\t\t\t\t\tS_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\t\tfnic_trace_debugfs_root,\n\t\t\t\t\t&(fc_trc_flag->fc_clear),\n\t\t\t\t\t&fnic_trace_ctrl_fops);\n\n\tfnic_fc_rdata_trace_debugfs_file =\n\t\tdebugfs_create_file(\"fc_trace_rdata\",\n\t\t\t\t    S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\t    fnic_trace_debugfs_root,\n\t\t\t\t    &(fc_trc_flag->fc_normal_file),\n\t\t\t\t    &fnic_trace_debugfs_fops);\n\n\tfnic_fc_trace_debugfs_file =\n\t\tdebugfs_create_file(\"fc_trace\",\n\t\t\t\t    S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\t    fnic_trace_debugfs_root,\n\t\t\t\t    &(fc_trc_flag->fc_row_file),\n\t\t\t\t    &fnic_trace_debugfs_fops);\n}\n\n \n\nvoid fnic_fc_trace_debugfs_terminate(void)\n{\n\tdebugfs_remove(fnic_fc_trace_debugfs_file);\n\tfnic_fc_trace_debugfs_file = NULL;\n\n\tdebugfs_remove(fnic_fc_rdata_trace_debugfs_file);\n\tfnic_fc_rdata_trace_debugfs_file = NULL;\n\n\tdebugfs_remove(fnic_fc_trace_enable);\n\tfnic_fc_trace_enable = NULL;\n\n\tdebugfs_remove(fnic_fc_trace_clear);\n\tfnic_fc_trace_clear = NULL;\n}\n\n \nstatic int fnic_reset_stats_open(struct inode *inode, struct file *file)\n{\n\tstruct stats_debug_info *debug;\n\n\tdebug = kzalloc(sizeof(struct stats_debug_info), GFP_KERNEL);\n\tif (!debug)\n\t\treturn -ENOMEM;\n\n\tdebug->i_private = inode->i_private;\n\n\tfile->private_data = debug;\n\n\treturn 0;\n}\n\n \nstatic ssize_t fnic_reset_stats_read(struct file *file,\n\t\t\t\t\tchar __user *ubuf,\n\t\t\t\t\tsize_t cnt, loff_t *ppos)\n{\n\tstruct stats_debug_info *debug = file->private_data;\n\tstruct fnic *fnic = (struct fnic *)debug->i_private;\n\tchar buf[64];\n\tint len;\n\n\tlen = sprintf(buf, \"%u\\n\", fnic->reset_stats);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, len);\n}\n\n \nstatic ssize_t fnic_reset_stats_write(struct file *file,\n\t\t\t\t\tconst char __user *ubuf,\n\t\t\t\t\tsize_t cnt, loff_t *ppos)\n{\n\tstruct stats_debug_info *debug = file->private_data;\n\tstruct fnic *fnic = (struct fnic *)debug->i_private;\n\tstruct fnic_stats *stats = &fnic->fnic_stats;\n\tu64 *io_stats_p = (u64 *)&stats->io_stats;\n\tu64 *fw_stats_p = (u64 *)&stats->fw_stats;\n\tchar buf[64];\n\tunsigned long val;\n\tint ret;\n\n\tif (cnt >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&buf, ubuf, cnt))\n\t\treturn -EFAULT;\n\n\tbuf[cnt] = 0;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfnic->reset_stats = val;\n\n\tif (fnic->reset_stats) {\n\t\t \n\t\tatomic64_set(&fnic->io_cmpl_skip,\n\t\t\tatomic64_read(&stats->io_stats.active_ios));\n\t\tmemset(&stats->abts_stats, 0, sizeof(struct abort_stats));\n\t\tmemset(&stats->term_stats, 0,\n\t\t\tsizeof(struct terminate_stats));\n\t\tmemset(&stats->reset_stats, 0, sizeof(struct reset_stats));\n\t\tmemset(&stats->misc_stats, 0, sizeof(struct misc_stats));\n\t\tmemset(&stats->vlan_stats, 0, sizeof(struct vlan_stats));\n\t\tmemset(io_stats_p+1, 0,\n\t\t\tsizeof(struct io_path_stats) - sizeof(u64));\n\t\tmemset(fw_stats_p+1, 0,\n\t\t\tsizeof(struct fw_stats) - sizeof(u64));\n\t\tktime_get_real_ts64(&stats->stats_timestamps.last_reset_time);\n\t}\n\n\t(*ppos)++;\n\treturn cnt;\n}\n\n \nstatic int fnic_reset_stats_release(struct inode *inode,\n\t\t\t\t\tstruct file *file)\n{\n\tstruct stats_debug_info *debug = file->private_data;\n\tkfree(debug);\n\treturn 0;\n}\n\n \nstatic int fnic_stats_debugfs_open(struct inode *inode,\n\t\t\t\t\tstruct file *file)\n{\n\tstruct fnic *fnic = inode->i_private;\n\tstruct fnic_stats *fnic_stats = &fnic->fnic_stats;\n\tstruct stats_debug_info *debug;\n\tint buf_size = 2 * PAGE_SIZE;\n\n\tdebug = kzalloc(sizeof(struct stats_debug_info), GFP_KERNEL);\n\tif (!debug)\n\t\treturn -ENOMEM;\n\n\tdebug->debug_buffer = vmalloc(buf_size);\n\tif (!debug->debug_buffer) {\n\t\tkfree(debug);\n\t\treturn -ENOMEM;\n\t}\n\n\tdebug->buf_size = buf_size;\n\tmemset((void *)debug->debug_buffer, 0, buf_size);\n\tdebug->buffer_len = fnic_get_stats_data(debug, fnic_stats);\n\n\tfile->private_data = debug;\n\n\treturn 0;\n}\n\n \nstatic ssize_t fnic_stats_debugfs_read(struct file *file,\n\t\t\t\t\tchar __user *ubuf,\n\t\t\t\t\tsize_t nbytes,\n\t\t\t\t\tloff_t *pos)\n{\n\tstruct stats_debug_info *debug = file->private_data;\n\tint rc = 0;\n\trc = simple_read_from_buffer(ubuf, nbytes, pos,\n\t\t\t\t\tdebug->debug_buffer,\n\t\t\t\t\tdebug->buffer_len);\n\treturn rc;\n}\n\n \nstatic int fnic_stats_debugfs_release(struct inode *inode,\n\t\t\t\t\tstruct file *file)\n{\n\tstruct stats_debug_info *debug = file->private_data;\n\tvfree(debug->debug_buffer);\n\tkfree(debug);\n\treturn 0;\n}\n\nstatic const struct file_operations fnic_stats_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.open = fnic_stats_debugfs_open,\n\t.read = fnic_stats_debugfs_read,\n\t.release = fnic_stats_debugfs_release,\n};\n\nstatic const struct file_operations fnic_reset_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.open = fnic_reset_stats_open,\n\t.read = fnic_reset_stats_read,\n\t.write = fnic_reset_stats_write,\n\t.release = fnic_reset_stats_release,\n};\n\n \nvoid fnic_stats_debugfs_init(struct fnic *fnic)\n{\n\tchar name[16];\n\n\tsnprintf(name, sizeof(name), \"host%d\", fnic->lport->host->host_no);\n\n\tfnic->fnic_stats_debugfs_host = debugfs_create_dir(name,\n\t\t\t\t\t\tfnic_stats_debugfs_root);\n\n\tfnic->fnic_stats_debugfs_file = debugfs_create_file(\"stats\",\n\t\t\t\t\t\tS_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\t\t\tfnic->fnic_stats_debugfs_host,\n\t\t\t\t\t\tfnic,\n\t\t\t\t\t\t&fnic_stats_debugfs_fops);\n\n\tfnic->fnic_reset_debugfs_file = debugfs_create_file(\"reset_stats\",\n\t\t\t\t\t\tS_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\t\t\tfnic->fnic_stats_debugfs_host,\n\t\t\t\t\t\tfnic,\n\t\t\t\t\t\t&fnic_reset_debugfs_fops);\n}\n\n \nvoid fnic_stats_debugfs_remove(struct fnic *fnic)\n{\n\tif (!fnic)\n\t\treturn;\n\n\tdebugfs_remove(fnic->fnic_stats_debugfs_file);\n\tfnic->fnic_stats_debugfs_file = NULL;\n\n\tdebugfs_remove(fnic->fnic_reset_debugfs_file);\n\tfnic->fnic_reset_debugfs_file = NULL;\n\n\tdebugfs_remove(fnic->fnic_stats_debugfs_host);\n\tfnic->fnic_stats_debugfs_host = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}