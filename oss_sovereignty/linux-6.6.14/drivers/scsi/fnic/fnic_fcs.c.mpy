{
  "module_name": "fnic_fcs.c",
  "hash_id": "bfe61199526edaa2095e6ceb1d4adb88399a1ee1cfb0fcc71171642db122854b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/fnic/fnic_fcs.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/workqueue.h>\n#include <scsi/fc/fc_fip.h>\n#include <scsi/fc/fc_els.h>\n#include <scsi/fc/fc_fcoe.h>\n#include <scsi/fc_frame.h>\n#include <scsi/libfc.h>\n#include \"fnic_io.h\"\n#include \"fnic.h\"\n#include \"fnic_fip.h\"\n#include \"cq_enet_desc.h\"\n#include \"cq_exch_desc.h\"\n\nstatic u8 fcoe_all_fcfs[ETH_ALEN] = FIP_ALL_FCF_MACS;\nstruct workqueue_struct *fnic_fip_queue;\nstruct workqueue_struct *fnic_event_queue;\n\nstatic void fnic_set_eth_mode(struct fnic *);\nstatic void fnic_fcoe_send_vlan_req(struct fnic *fnic);\nstatic void fnic_fcoe_start_fcf_disc(struct fnic *fnic);\nstatic void fnic_fcoe_process_vlan_resp(struct fnic *fnic, struct sk_buff *);\nstatic int fnic_fcoe_vlan_check(struct fnic *fnic, u16 flag);\nstatic int fnic_fcoe_handle_fip_frame(struct fnic *fnic, struct sk_buff *skb);\n\nvoid fnic_handle_link(struct work_struct *work)\n{\n\tstruct fnic *fnic = container_of(work, struct fnic, link_work);\n\tunsigned long flags;\n\tint old_link_status;\n\tu32 old_link_down_cnt;\n\tu64 old_port_speed, new_port_speed;\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\n\tfnic->link_events = 1;       \n\n\tif (fnic->stop_rx_link_events) {\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\treturn;\n\t}\n\n\told_link_down_cnt = fnic->link_down_cnt;\n\told_link_status = fnic->link_status;\n\told_port_speed = atomic64_read(\n\t\t\t&fnic->fnic_stats.misc_stats.current_port_speed);\n\n\tfnic->link_status = vnic_dev_link_status(fnic->vdev);\n\tfnic->link_down_cnt = vnic_dev_link_down_cnt(fnic->vdev);\n\n\tnew_port_speed = vnic_dev_port_speed(fnic->vdev);\n\tatomic64_set(&fnic->fnic_stats.misc_stats.current_port_speed,\n\t\t\tnew_port_speed);\n\tif (old_port_speed != new_port_speed)\n\t\tFNIC_MAIN_DBG(KERN_INFO, fnic->lport->host,\n\t\t\t\t\"Current vnic speed set to :  %llu\\n\",\n\t\t\t\tnew_port_speed);\n\n\tswitch (vnic_dev_port_speed(fnic->vdev)) {\n\tcase DCEM_PORTSPEED_10G:\n\t\tfc_host_speed(fnic->lport->host)   = FC_PORTSPEED_10GBIT;\n\t\tfnic->lport->link_supported_speeds = FC_PORTSPEED_10GBIT;\n\t\tbreak;\n\tcase DCEM_PORTSPEED_20G:\n\t\tfc_host_speed(fnic->lport->host)   = FC_PORTSPEED_20GBIT;\n\t\tfnic->lport->link_supported_speeds = FC_PORTSPEED_20GBIT;\n\t\tbreak;\n\tcase DCEM_PORTSPEED_25G:\n\t\tfc_host_speed(fnic->lport->host)   = FC_PORTSPEED_25GBIT;\n\t\tfnic->lport->link_supported_speeds = FC_PORTSPEED_25GBIT;\n\t\tbreak;\n\tcase DCEM_PORTSPEED_40G:\n\tcase DCEM_PORTSPEED_4x10G:\n\t\tfc_host_speed(fnic->lport->host)   = FC_PORTSPEED_40GBIT;\n\t\tfnic->lport->link_supported_speeds = FC_PORTSPEED_40GBIT;\n\t\tbreak;\n\tcase DCEM_PORTSPEED_100G:\n\t\tfc_host_speed(fnic->lport->host)   = FC_PORTSPEED_100GBIT;\n\t\tfnic->lport->link_supported_speeds = FC_PORTSPEED_100GBIT;\n\t\tbreak;\n\tdefault:\n\t\tfc_host_speed(fnic->lport->host)   = FC_PORTSPEED_UNKNOWN;\n\t\tfnic->lport->link_supported_speeds = FC_PORTSPEED_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tif (old_link_status == fnic->link_status) {\n\t\tif (!fnic->link_status) {\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\t\tfnic_fc_trace_set_data(fnic->lport->host->host_no,\n\t\t\t\tFNIC_FC_LE, \"Link Status: DOWN->DOWN\",\n\t\t\t\tstrlen(\"Link Status: DOWN->DOWN\"));\n\t\t} else {\n\t\t\tif (old_link_down_cnt != fnic->link_down_cnt) {\n\t\t\t\t \n\t\t\t\tfnic->lport->host_stats.link_failure_count++;\n\t\t\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\t\t\tfnic_fc_trace_set_data(\n\t\t\t\t\tfnic->lport->host->host_no,\n\t\t\t\t\tFNIC_FC_LE,\n\t\t\t\t\t\"Link Status:UP_DOWN_UP\",\n\t\t\t\t\tstrlen(\"Link_Status:UP_DOWN_UP\")\n\t\t\t\t\t);\n\t\t\t\tFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t\t     \"link down\\n\");\n\t\t\t\tfcoe_ctlr_link_down(&fnic->ctlr);\n\t\t\t\tif (fnic->config.flags & VFCF_FIP_CAPABLE) {\n\t\t\t\t\t \n\t\t\t\t\tfnic_fc_trace_set_data(\n\t\t\t\t\t\tfnic->lport->host->host_no,\n\t\t\t\t\t\tFNIC_FC_LE,\n\t\t\t\t\t\t\"Link Status: UP_DOWN_UP_VLAN\",\n\t\t\t\t\t\tstrlen(\n\t\t\t\t\t\t\"Link Status: UP_DOWN_UP_VLAN\")\n\t\t\t\t\t\t);\n\t\t\t\t\tfnic_fcoe_send_vlan_req(fnic);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t\t     \"link up\\n\");\n\t\t\t\tfcoe_ctlr_link_up(&fnic->ctlr);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\t\t\tfnic_fc_trace_set_data(\n\t\t\t\t\tfnic->lport->host->host_no, FNIC_FC_LE,\n\t\t\t\t\t\"Link Status: UP_UP\",\n\t\t\t\t\tstrlen(\"Link Status: UP_UP\"));\n\t\t\t}\n\t\t}\n\t} else if (fnic->link_status) {\n\t\t \n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\tif (fnic->config.flags & VFCF_FIP_CAPABLE) {\n\t\t\t \n\t\t\t\tfnic_fc_trace_set_data(\n\t\t\t\tfnic->lport->host->host_no,\n\t\t\t\tFNIC_FC_LE, \"Link Status: DOWN_UP_VLAN\",\n\t\t\t\tstrlen(\"Link Status: DOWN_UP_VLAN\"));\n\t\t\tfnic_fcoe_send_vlan_req(fnic);\n\t\t\treturn;\n\t\t}\n\t\tFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host, \"link up\\n\");\n\t\tfnic_fc_trace_set_data(fnic->lport->host->host_no, FNIC_FC_LE,\n\t\t\t\"Link Status: DOWN_UP\", strlen(\"Link Status: DOWN_UP\"));\n\t\tfcoe_ctlr_link_up(&fnic->ctlr);\n\t} else {\n\t\t \n\t\tfnic->lport->host_stats.link_failure_count++;\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\tFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host, \"link down\\n\");\n\t\tfnic_fc_trace_set_data(\n\t\t\tfnic->lport->host->host_no, FNIC_FC_LE,\n\t\t\t\"Link Status: UP_DOWN\",\n\t\t\tstrlen(\"Link Status: UP_DOWN\"));\n\t\tif (fnic->config.flags & VFCF_FIP_CAPABLE) {\n\t\t\tFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t\"deleting fip-timer during link-down\\n\");\n\t\t\tdel_timer_sync(&fnic->fip_timer);\n\t\t}\n\t\tfcoe_ctlr_link_down(&fnic->ctlr);\n\t}\n\n}\n\n \nvoid fnic_handle_frame(struct work_struct *work)\n{\n\tstruct fnic *fnic = container_of(work, struct fnic, frame_work);\n\tstruct fc_lport *lp = fnic->lport;\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct fc_frame *fp;\n\n\twhile ((skb = skb_dequeue(&fnic->frame_queue))) {\n\n\t\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\t\tif (fnic->stop_rx_link_events) {\n\t\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tfp = (struct fc_frame *)skb;\n\n\t\t \n\t\tif (fnic->state != FNIC_IN_FC_MODE &&\n\t\t    fnic->state != FNIC_IN_ETH_MODE) {\n\t\t\tskb_queue_head(&fnic->frame_queue, skb);\n\t\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\t\tfc_exch_recv(lp, fp);\n\t}\n}\n\nvoid fnic_fcoe_evlist_free(struct fnic *fnic)\n{\n\tstruct fnic_event *fevt = NULL;\n\tstruct fnic_event *next = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tif (list_empty(&fnic->evlist)) {\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_safe(fevt, next, &fnic->evlist, list) {\n\t\tlist_del(&fevt->list);\n\t\tkfree(fevt);\n\t}\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n}\n\nvoid fnic_handle_event(struct work_struct *work)\n{\n\tstruct fnic *fnic = container_of(work, struct fnic, event_work);\n\tstruct fnic_event *fevt = NULL;\n\tstruct fnic_event *next = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tif (list_empty(&fnic->evlist)) {\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_safe(fevt, next, &fnic->evlist, list) {\n\t\tif (fnic->stop_rx_link_events) {\n\t\t\tlist_del(&fevt->list);\n\t\t\tkfree(fevt);\n\t\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (fnic->state != FNIC_IN_FC_MODE &&\n\t\t    fnic->state != FNIC_IN_ETH_MODE) {\n\t\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tlist_del(&fevt->list);\n\t\tswitch (fevt->event) {\n\t\tcase FNIC_EVT_START_VLAN_DISC:\n\t\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\t\tfnic_fcoe_send_vlan_req(fnic);\n\t\t\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\t\t\tbreak;\n\t\tcase FNIC_EVT_START_FCF_DISC:\n\t\t\tFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t  \"Start FCF Discovery\\n\");\n\t\t\tfnic_fcoe_start_fcf_disc(fnic);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t  \"Unknown event 0x%x\\n\", fevt->event);\n\t\t\tbreak;\n\t\t}\n\t\tkfree(fevt);\n\t}\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n}\n\n \nstatic inline int is_fnic_fip_flogi_reject(struct fcoe_ctlr *fip,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct fc_lport *lport = fip->lp;\n\tstruct fip_header *fiph;\n\tstruct fc_frame_header *fh = NULL;\n\tstruct fip_desc *desc;\n\tstruct fip_encaps *els;\n\tu16 op;\n\tu8 els_op;\n\tu8 sub;\n\n\tsize_t rlen;\n\tsize_t dlen = 0;\n\n\tif (skb_linearize(skb))\n\t\treturn 0;\n\n\tif (skb->len < sizeof(*fiph))\n\t\treturn 0;\n\n\tfiph = (struct fip_header *)skb->data;\n\top = ntohs(fiph->fip_op);\n\tsub = fiph->fip_subcode;\n\n\tif (op != FIP_OP_LS)\n\t\treturn 0;\n\n\tif (sub != FIP_SC_REP)\n\t\treturn 0;\n\n\trlen = ntohs(fiph->fip_dl_len) * 4;\n\tif (rlen + sizeof(*fiph) > skb->len)\n\t\treturn 0;\n\n\tdesc = (struct fip_desc *)(fiph + 1);\n\tdlen = desc->fip_dlen * FIP_BPW;\n\n\tif (desc->fip_dtype == FIP_DT_FLOGI) {\n\n\t\tif (dlen < sizeof(*els) + sizeof(*fh) + 1)\n\t\t\treturn 0;\n\n\t\tels = (struct fip_encaps *)desc;\n\t\tfh = (struct fc_frame_header *)(els + 1);\n\n\t\tif (!fh)\n\t\t\treturn 0;\n\n\t\t \n\t\tels_op = *(u8 *)(fh + 1);\n\t\tif (els_op == ELS_LS_RJT) {\n\t\t\tshost_printk(KERN_INFO, lport->host,\n\t\t\t\t  \"Flogi Request Rejected by Switch\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tshost_printk(KERN_INFO, lport->host,\n\t\t\t\t\"Flogi Request Accepted by Switch\\n\");\n\t}\n\treturn 0;\n}\n\nstatic void fnic_fcoe_send_vlan_req(struct fnic *fnic)\n{\n\tstruct fcoe_ctlr *fip = &fnic->ctlr;\n\tstruct fnic_stats *fnic_stats = &fnic->fnic_stats;\n\tstruct sk_buff *skb;\n\tchar *eth_fr;\n\tstruct fip_vlan *vlan;\n\tu64 vlan_tov;\n\n\tfnic_fcoe_reset_vlans(fnic);\n\tfnic->set_vlan(fnic, 0);\n\n\tif (printk_ratelimit())\n\t\tFNIC_FCS_DBG(KERN_INFO, fnic->lport->host,\n\t\t\t  \"Sending VLAN request...\\n\");\n\n\tskb = dev_alloc_skb(sizeof(struct fip_vlan));\n\tif (!skb)\n\t\treturn;\n\n\teth_fr = (char *)skb->data;\n\tvlan = (struct fip_vlan *)eth_fr;\n\n\tmemset(vlan, 0, sizeof(*vlan));\n\tmemcpy(vlan->eth.h_source, fip->ctl_src_addr, ETH_ALEN);\n\tmemcpy(vlan->eth.h_dest, fcoe_all_fcfs, ETH_ALEN);\n\tvlan->eth.h_proto = htons(ETH_P_FIP);\n\n\tvlan->fip.fip_ver = FIP_VER_ENCAPS(FIP_VER);\n\tvlan->fip.fip_op = htons(FIP_OP_VLAN);\n\tvlan->fip.fip_subcode = FIP_SC_VL_REQ;\n\tvlan->fip.fip_dl_len = htons(sizeof(vlan->desc) / FIP_BPW);\n\n\tvlan->desc.mac.fd_desc.fip_dtype = FIP_DT_MAC;\n\tvlan->desc.mac.fd_desc.fip_dlen = sizeof(vlan->desc.mac) / FIP_BPW;\n\tmemcpy(&vlan->desc.mac.fd_mac, fip->ctl_src_addr, ETH_ALEN);\n\n\tvlan->desc.wwnn.fd_desc.fip_dtype = FIP_DT_NAME;\n\tvlan->desc.wwnn.fd_desc.fip_dlen = sizeof(vlan->desc.wwnn) / FIP_BPW;\n\tput_unaligned_be64(fip->lp->wwnn, &vlan->desc.wwnn.fd_wwn);\n\tatomic64_inc(&fnic_stats->vlan_stats.vlan_disc_reqs);\n\n\tskb_put(skb, sizeof(*vlan));\n\tskb->protocol = htons(ETH_P_FIP);\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tfip->send(fip, skb);\n\n\t \n\tvlan_tov = jiffies + msecs_to_jiffies(FCOE_CTLR_FIPVLAN_TOV);\n\tmod_timer(&fnic->fip_timer, round_jiffies(vlan_tov));\n}\n\nstatic void fnic_fcoe_process_vlan_resp(struct fnic *fnic, struct sk_buff *skb)\n{\n\tstruct fcoe_ctlr *fip = &fnic->ctlr;\n\tstruct fip_header *fiph;\n\tstruct fip_desc *desc;\n\tstruct fnic_stats *fnic_stats = &fnic->fnic_stats;\n\tu16 vid;\n\tsize_t rlen;\n\tsize_t dlen;\n\tstruct fcoe_vlan *vlan;\n\tu64 sol_time;\n\tunsigned long flags;\n\n\tFNIC_FCS_DBG(KERN_INFO, fnic->lport->host,\n\t\t  \"Received VLAN response...\\n\");\n\n\tfiph = (struct fip_header *) skb->data;\n\n\tFNIC_FCS_DBG(KERN_INFO, fnic->lport->host,\n\t\t  \"Received VLAN response... OP 0x%x SUB_OP 0x%x\\n\",\n\t\t  ntohs(fiph->fip_op), fiph->fip_subcode);\n\n\trlen = ntohs(fiph->fip_dl_len) * 4;\n\tfnic_fcoe_reset_vlans(fnic);\n\tspin_lock_irqsave(&fnic->vlans_lock, flags);\n\tdesc = (struct fip_desc *)(fiph + 1);\n\twhile (rlen > 0) {\n\t\tdlen = desc->fip_dlen * FIP_BPW;\n\t\tswitch (desc->fip_dtype) {\n\t\tcase FIP_DT_VLAN:\n\t\t\tvid = ntohs(((struct fip_vlan_desc *)desc)->fd_vlan);\n\t\t\tshost_printk(KERN_INFO, fnic->lport->host,\n\t\t\t\t  \"process_vlan_resp: FIP VLAN %d\\n\", vid);\n\t\t\tvlan = kzalloc(sizeof(*vlan), GFP_ATOMIC);\n\t\t\tif (!vlan) {\n\t\t\t\t \n\t\t\t\tspin_unlock_irqrestore(&fnic->vlans_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tvlan->vid = vid & 0x0fff;\n\t\t\tvlan->state = FIP_VLAN_AVAIL;\n\t\t\tlist_add_tail(&vlan->list, &fnic->vlans);\n\t\t\tbreak;\n\t\t}\n\t\tdesc = (struct fip_desc *)((char *)desc + dlen);\n\t\trlen -= dlen;\n\t}\n\n\t \n\tif (list_empty(&fnic->vlans)) {\n\t\t \n\t\tatomic64_inc(&fnic_stats->vlan_stats.resp_withno_vlanID);\n\t\tFNIC_FCS_DBG(KERN_INFO, fnic->lport->host,\n\t\t\t  \"No VLAN descriptors in FIP VLAN response\\n\");\n\t\tspin_unlock_irqrestore(&fnic->vlans_lock, flags);\n\t\tgoto out;\n\t}\n\n\tvlan = list_first_entry(&fnic->vlans, struct fcoe_vlan, list);\n\tfnic->set_vlan(fnic, vlan->vid);\n\tvlan->state = FIP_VLAN_SENT;  \n\tvlan->sol_count++;\n\tspin_unlock_irqrestore(&fnic->vlans_lock, flags);\n\n\t \n\tfcoe_ctlr_link_up(fip);\n\n\tsol_time = jiffies + msecs_to_jiffies(FCOE_CTLR_START_DELAY);\n\tmod_timer(&fnic->fip_timer, round_jiffies(sol_time));\nout:\n\treturn;\n}\n\nstatic void fnic_fcoe_start_fcf_disc(struct fnic *fnic)\n{\n\tunsigned long flags;\n\tstruct fcoe_vlan *vlan;\n\tu64 sol_time;\n\n\tspin_lock_irqsave(&fnic->vlans_lock, flags);\n\tvlan = list_first_entry(&fnic->vlans, struct fcoe_vlan, list);\n\tfnic->set_vlan(fnic, vlan->vid);\n\tvlan->state = FIP_VLAN_SENT;  \n\tvlan->sol_count = 1;\n\tspin_unlock_irqrestore(&fnic->vlans_lock, flags);\n\n\t \n\tfcoe_ctlr_link_up(&fnic->ctlr);\n\n\tsol_time = jiffies + msecs_to_jiffies(FCOE_CTLR_START_DELAY);\n\tmod_timer(&fnic->fip_timer, round_jiffies(sol_time));\n}\n\nstatic int fnic_fcoe_vlan_check(struct fnic *fnic, u16 flag)\n{\n\tunsigned long flags;\n\tstruct fcoe_vlan *fvlan;\n\n\tspin_lock_irqsave(&fnic->vlans_lock, flags);\n\tif (list_empty(&fnic->vlans)) {\n\t\tspin_unlock_irqrestore(&fnic->vlans_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tfvlan = list_first_entry(&fnic->vlans, struct fcoe_vlan, list);\n\tif (fvlan->state == FIP_VLAN_USED) {\n\t\tspin_unlock_irqrestore(&fnic->vlans_lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (fvlan->state == FIP_VLAN_SENT) {\n\t\tfvlan->state = FIP_VLAN_USED;\n\t\tspin_unlock_irqrestore(&fnic->vlans_lock, flags);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&fnic->vlans_lock, flags);\n\treturn -EINVAL;\n}\n\nstatic void fnic_event_enq(struct fnic *fnic, enum fnic_evt ev)\n{\n\tstruct fnic_event *fevt;\n\tunsigned long flags;\n\n\tfevt = kmalloc(sizeof(*fevt), GFP_ATOMIC);\n\tif (!fevt)\n\t\treturn;\n\n\tfevt->fnic = fnic;\n\tfevt->event = ev;\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tlist_add_tail(&fevt->list, &fnic->evlist);\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\tschedule_work(&fnic->event_work);\n}\n\nstatic int fnic_fcoe_handle_fip_frame(struct fnic *fnic, struct sk_buff *skb)\n{\n\tstruct fip_header *fiph;\n\tint ret = 1;\n\tu16 op;\n\tu8 sub;\n\n\tif (!skb || !(skb->data))\n\t\treturn -1;\n\n\tif (skb_linearize(skb))\n\t\tgoto drop;\n\n\tfiph = (struct fip_header *)skb->data;\n\top = ntohs(fiph->fip_op);\n\tsub = fiph->fip_subcode;\n\n\tif (FIP_VER_DECAPS(fiph->fip_ver) != FIP_VER)\n\t\tgoto drop;\n\n\tif (ntohs(fiph->fip_dl_len) * FIP_BPW + sizeof(*fiph) > skb->len)\n\t\tgoto drop;\n\n\tif (op == FIP_OP_DISC && sub == FIP_SC_ADV) {\n\t\tif (fnic_fcoe_vlan_check(fnic, ntohs(fiph->fip_flags)))\n\t\t\tgoto drop;\n\t\t \n\t\tret = 1;\n\t} else if (op == FIP_OP_VLAN && sub == FIP_SC_VL_NOTE) {\n\t\t \n\t\tfnic_fcoe_process_vlan_resp(fnic, skb);\n\t\tret = 0;\n\t} else if (op == FIP_OP_CTRL && sub == FIP_SC_CLR_VLINK) {\n\t\t \n\t\tfnic_event_enq(fnic, FNIC_EVT_START_VLAN_DISC);\n\t\t \n\t\tret = 1;\n\t}\ndrop:\n\treturn ret;\n}\n\nvoid fnic_handle_fip_frame(struct work_struct *work)\n{\n\tstruct fnic *fnic = container_of(work, struct fnic, fip_frame_work);\n\tstruct fnic_stats *fnic_stats = &fnic->fnic_stats;\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct ethhdr *eh;\n\n\twhile ((skb = skb_dequeue(&fnic->fip_frame_queue))) {\n\t\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\t\tif (fnic->stop_rx_link_events) {\n\t\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (fnic->state != FNIC_IN_FC_MODE &&\n\t\t    fnic->state != FNIC_IN_ETH_MODE) {\n\t\t\tskb_queue_head(&fnic->fip_frame_queue, skb);\n\t\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\teh = (struct ethhdr *)skb->data;\n\t\tif (eh->h_proto == htons(ETH_P_FIP)) {\n\t\t\tskb_pull(skb, sizeof(*eh));\n\t\t\tif (fnic_fcoe_handle_fip_frame(fnic, skb) <= 0) {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (is_fnic_fip_flogi_reject(&fnic->ctlr, skb)) {\n\t\t\t\tatomic64_inc(\n\t\t\t\t\t&fnic_stats->vlan_stats.flogi_rejects);\n\t\t\t\tshost_printk(KERN_INFO, fnic->lport->host,\n\t\t\t\t\t  \"Trigger a Link down - VLAN Disc\\n\");\n\t\t\t\tfcoe_ctlr_link_down(&fnic->ctlr);\n\t\t\t\t \n\t\t\t\tfnic_fcoe_send_vlan_req(fnic);\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfcoe_ctlr_recv(&fnic->ctlr, skb);\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\n \nstatic inline int fnic_import_rq_eth_pkt(struct fnic *fnic, struct sk_buff *skb)\n{\n\tstruct fc_frame *fp;\n\tstruct ethhdr *eh;\n\tstruct fcoe_hdr *fcoe_hdr;\n\tstruct fcoe_crc_eof *ft;\n\n\t \n\teh = (struct ethhdr *)skb->data;\n\tif (eh->h_proto == htons(ETH_P_8021Q)) {\n\t\tmemmove((u8 *)eh + VLAN_HLEN, eh, ETH_ALEN * 2);\n\t\teh = skb_pull(skb, VLAN_HLEN);\n\t\tskb_reset_mac_header(skb);\n\t}\n\tif (eh->h_proto == htons(ETH_P_FIP)) {\n\t\tif (!(fnic->config.flags & VFCF_FIP_CAPABLE)) {\n\t\t\tprintk(KERN_ERR \"Dropped FIP frame, as firmware \"\n\t\t\t\t\t\"uses non-FIP mode, Enable FIP \"\n\t\t\t\t\t\"using UCSM\\n\");\n\t\t\tgoto drop;\n\t\t}\n\t\tif ((fnic_fc_trace_set_data(fnic->lport->host->host_no,\n\t\t\tFNIC_FC_RECV|0x80, (char *)skb->data, skb->len)) != 0) {\n\t\t\tprintk(KERN_ERR \"fnic ctlr frame trace error!!!\");\n\t\t}\n\t\tskb_queue_tail(&fnic->fip_frame_queue, skb);\n\t\tqueue_work(fnic_fip_queue, &fnic->fip_frame_work);\n\t\treturn 1;\t\t \n\t}\n\tif (eh->h_proto != htons(ETH_P_FCOE))\n\t\tgoto drop;\n\tskb_set_network_header(skb, sizeof(*eh));\n\tskb_pull(skb, sizeof(*eh));\n\n\tfcoe_hdr = (struct fcoe_hdr *)skb->data;\n\tif (FC_FCOE_DECAPS_VER(fcoe_hdr) != FC_FCOE_VER)\n\t\tgoto drop;\n\n\tfp = (struct fc_frame *)skb;\n\tfc_frame_init(fp);\n\tfr_sof(fp) = fcoe_hdr->fcoe_sof;\n\tskb_pull(skb, sizeof(struct fcoe_hdr));\n\tskb_reset_transport_header(skb);\n\n\tft = (struct fcoe_crc_eof *)(skb->data + skb->len - sizeof(*ft));\n\tfr_eof(fp) = ft->fcoe_eof;\n\tskb_trim(skb, skb->len - sizeof(*ft));\n\treturn 0;\ndrop:\n\tdev_kfree_skb_irq(skb);\n\treturn -1;\n}\n\n \nvoid fnic_update_mac_locked(struct fnic *fnic, u8 *new)\n{\n\tu8 *ctl = fnic->ctlr.ctl_src_addr;\n\tu8 *data = fnic->data_src_addr;\n\n\tif (is_zero_ether_addr(new))\n\t\tnew = ctl;\n\tif (ether_addr_equal(data, new))\n\t\treturn;\n\tFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host, \"update_mac %pM\\n\", new);\n\tif (!is_zero_ether_addr(data) && !ether_addr_equal(data, ctl))\n\t\tvnic_dev_del_addr(fnic->vdev, data);\n\tmemcpy(data, new, ETH_ALEN);\n\tif (!ether_addr_equal(new, ctl))\n\t\tvnic_dev_add_addr(fnic->vdev, new);\n}\n\n \nvoid fnic_update_mac(struct fc_lport *lport, u8 *new)\n{\n\tstruct fnic *fnic = lport_priv(lport);\n\n\tspin_lock_irq(&fnic->fnic_lock);\n\tfnic_update_mac_locked(fnic, new);\n\tspin_unlock_irq(&fnic->fnic_lock);\n}\n\n \nvoid fnic_set_port_id(struct fc_lport *lport, u32 port_id, struct fc_frame *fp)\n{\n\tstruct fnic *fnic = lport_priv(lport);\n\tu8 *mac;\n\tint ret;\n\n\tFNIC_FCS_DBG(KERN_DEBUG, lport->host, \"set port_id %x fp %p\\n\",\n\t\t     port_id, fp);\n\n\t \n\tif (!port_id) {\n\t\tfnic_update_mac(lport, fnic->ctlr.ctl_src_addr);\n\t\tfnic_set_eth_mode(fnic);\n\t\treturn;\n\t}\n\n\tif (fp) {\n\t\tmac = fr_cb(fp)->granted_mac;\n\t\tif (is_zero_ether_addr(mac)) {\n\t\t\t \n\t\t\tfcoe_ctlr_recv_flogi(&fnic->ctlr, lport, fp);\n\t\t}\n\t\tfnic_update_mac(lport, mac);\n\t}\n\n\t \n\tspin_lock_irq(&fnic->fnic_lock);\n\tif (fnic->state == FNIC_IN_ETH_MODE || fnic->state == FNIC_IN_FC_MODE)\n\t\tfnic->state = FNIC_IN_ETH_TRANS_FC_MODE;\n\telse {\n\t\tFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t     \"Unexpected fnic state %s while\"\n\t\t\t     \" processing flogi resp\\n\",\n\t\t\t     fnic_state_to_str(fnic->state));\n\t\tspin_unlock_irq(&fnic->fnic_lock);\n\t\treturn;\n\t}\n\tspin_unlock_irq(&fnic->fnic_lock);\n\n\t \n\tret = fnic_flogi_reg_handler(fnic, port_id);\n\n\tif (ret < 0) {\n\t\tspin_lock_irq(&fnic->fnic_lock);\n\t\tif (fnic->state == FNIC_IN_ETH_TRANS_FC_MODE)\n\t\t\tfnic->state = FNIC_IN_ETH_MODE;\n\t\tspin_unlock_irq(&fnic->fnic_lock);\n\t}\n}\n\nstatic void fnic_rq_cmpl_frame_recv(struct vnic_rq *rq, struct cq_desc\n\t\t\t\t    *cq_desc, struct vnic_rq_buf *buf,\n\t\t\t\t    int skipped __attribute__((unused)),\n\t\t\t\t    void *opaque)\n{\n\tstruct fnic *fnic = vnic_dev_priv(rq->vdev);\n\tstruct sk_buff *skb;\n\tstruct fc_frame *fp;\n\tstruct fnic_stats *fnic_stats = &fnic->fnic_stats;\n\tu8 type, color, eop, sop, ingress_port, vlan_stripped;\n\tu8 fcoe = 0, fcoe_sof, fcoe_eof;\n\tu8 fcoe_fc_crc_ok = 1, fcoe_enc_error = 0;\n\tu8 tcp_udp_csum_ok, udp, tcp, ipv4_csum_ok;\n\tu8 ipv6, ipv4, ipv4_fragment, rss_type, csum_not_calc;\n\tu8 fcs_ok = 1, packet_error = 0;\n\tu16 q_number, completed_index, bytes_written = 0, vlan, checksum;\n\tu32 rss_hash;\n\tu16 exchange_id, tmpl;\n\tu8 sof = 0;\n\tu8 eof = 0;\n\tu32 fcp_bytes_written = 0;\n\tunsigned long flags;\n\n\tdma_unmap_single(&fnic->pdev->dev, buf->dma_addr, buf->len,\n\t\t\t DMA_FROM_DEVICE);\n\tskb = buf->os_buf;\n\tfp = (struct fc_frame *)skb;\n\tbuf->os_buf = NULL;\n\n\tcq_desc_dec(cq_desc, &type, &color, &q_number, &completed_index);\n\tif (type == CQ_DESC_TYPE_RQ_FCP) {\n\t\tcq_fcp_rq_desc_dec((struct cq_fcp_rq_desc *)cq_desc,\n\t\t\t\t   &type, &color, &q_number, &completed_index,\n\t\t\t\t   &eop, &sop, &fcoe_fc_crc_ok, &exchange_id,\n\t\t\t\t   &tmpl, &fcp_bytes_written, &sof, &eof,\n\t\t\t\t   &ingress_port, &packet_error,\n\t\t\t\t   &fcoe_enc_error, &fcs_ok, &vlan_stripped,\n\t\t\t\t   &vlan);\n\t\tskb_trim(skb, fcp_bytes_written);\n\t\tfr_sof(fp) = sof;\n\t\tfr_eof(fp) = eof;\n\n\t} else if (type == CQ_DESC_TYPE_RQ_ENET) {\n\t\tcq_enet_rq_desc_dec((struct cq_enet_rq_desc *)cq_desc,\n\t\t\t\t    &type, &color, &q_number, &completed_index,\n\t\t\t\t    &ingress_port, &fcoe, &eop, &sop,\n\t\t\t\t    &rss_type, &csum_not_calc, &rss_hash,\n\t\t\t\t    &bytes_written, &packet_error,\n\t\t\t\t    &vlan_stripped, &vlan, &checksum,\n\t\t\t\t    &fcoe_sof, &fcoe_fc_crc_ok,\n\t\t\t\t    &fcoe_enc_error, &fcoe_eof,\n\t\t\t\t    &tcp_udp_csum_ok, &udp, &tcp,\n\t\t\t\t    &ipv4_csum_ok, &ipv6, &ipv4,\n\t\t\t\t    &ipv4_fragment, &fcs_ok);\n\t\tskb_trim(skb, bytes_written);\n\t\tif (!fcs_ok) {\n\t\t\tatomic64_inc(&fnic_stats->misc_stats.frame_errors);\n\t\t\tFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t     \"fcs error.  dropping packet.\\n\");\n\t\t\tgoto drop;\n\t\t}\n\t\tif (fnic_import_rq_eth_pkt(fnic, skb))\n\t\t\treturn;\n\n\t} else {\n\t\t \n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"fnic rq_cmpl wrong cq type x%x\\n\", type);\n\t\tgoto drop;\n\t}\n\n\tif (!fcs_ok || packet_error || !fcoe_fc_crc_ok || fcoe_enc_error) {\n\t\tatomic64_inc(&fnic_stats->misc_stats.frame_errors);\n\t\tFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t     \"fnic rq_cmpl fcoe x%x fcsok x%x\"\n\t\t\t     \" pkterr x%x fcoe_fc_crc_ok x%x, fcoe_enc_err\"\n\t\t\t     \" x%x\\n\",\n\t\t\t     fcoe, fcs_ok, packet_error,\n\t\t\t     fcoe_fc_crc_ok, fcoe_enc_error);\n\t\tgoto drop;\n\t}\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tif (fnic->stop_rx_link_events) {\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\tgoto drop;\n\t}\n\tfr_dev(fp) = fnic->lport;\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\tif ((fnic_fc_trace_set_data(fnic->lport->host->host_no, FNIC_FC_RECV,\n\t\t\t\t\t(char *)skb->data, skb->len)) != 0) {\n\t\tprintk(KERN_ERR \"fnic ctlr frame trace error!!!\");\n\t}\n\n\tskb_queue_tail(&fnic->frame_queue, skb);\n\tqueue_work(fnic_event_queue, &fnic->frame_work);\n\n\treturn;\ndrop:\n\tdev_kfree_skb_irq(skb);\n}\n\nstatic int fnic_rq_cmpl_handler_cont(struct vnic_dev *vdev,\n\t\t\t\t     struct cq_desc *cq_desc, u8 type,\n\t\t\t\t     u16 q_number, u16 completed_index,\n\t\t\t\t     void *opaque)\n{\n\tstruct fnic *fnic = vnic_dev_priv(vdev);\n\n\tvnic_rq_service(&fnic->rq[q_number], cq_desc, completed_index,\n\t\t\tVNIC_RQ_RETURN_DESC, fnic_rq_cmpl_frame_recv,\n\t\t\tNULL);\n\treturn 0;\n}\n\nint fnic_rq_cmpl_handler(struct fnic *fnic, int rq_work_to_do)\n{\n\tunsigned int tot_rq_work_done = 0, cur_work_done;\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < fnic->rq_count; i++) {\n\t\tcur_work_done = vnic_cq_service(&fnic->cq[i], rq_work_to_do,\n\t\t\t\t\t\tfnic_rq_cmpl_handler_cont,\n\t\t\t\t\t\tNULL);\n\t\tif (cur_work_done) {\n\t\t\terr = vnic_rq_fill(&fnic->rq[i], fnic_alloc_rq_frame);\n\t\t\tif (err)\n\t\t\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t\t\t     \"fnic_alloc_rq_frame can't alloc\"\n\t\t\t\t\t     \" frame\\n\");\n\t\t}\n\t\ttot_rq_work_done += cur_work_done;\n\t}\n\n\treturn tot_rq_work_done;\n}\n\n \nint fnic_alloc_rq_frame(struct vnic_rq *rq)\n{\n\tstruct fnic *fnic = vnic_dev_priv(rq->vdev);\n\tstruct sk_buff *skb;\n\tu16 len;\n\tdma_addr_t pa;\n\tint r;\n\n\tlen = FC_FRAME_HEADROOM + FC_MAX_FRAME + FC_FRAME_TAILROOM;\n\tskb = dev_alloc_skb(len);\n\tif (!skb) {\n\t\tFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t     \"Unable to allocate RQ sk_buff\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reset_mac_header(skb);\n\tskb_reset_transport_header(skb);\n\tskb_reset_network_header(skb);\n\tskb_put(skb, len);\n\tpa = dma_map_single(&fnic->pdev->dev, skb->data, len, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&fnic->pdev->dev, pa)) {\n\t\tr = -ENOMEM;\n\t\tprintk(KERN_ERR \"PCI mapping failed with error %d\\n\", r);\n\t\tgoto free_skb;\n\t}\n\n\tfnic_queue_rq_desc(rq, skb, pa, len);\n\treturn 0;\n\nfree_skb:\n\tkfree_skb(skb);\n\treturn r;\n}\n\nvoid fnic_free_rq_buf(struct vnic_rq *rq, struct vnic_rq_buf *buf)\n{\n\tstruct fc_frame *fp = buf->os_buf;\n\tstruct fnic *fnic = vnic_dev_priv(rq->vdev);\n\n\tdma_unmap_single(&fnic->pdev->dev, buf->dma_addr, buf->len,\n\t\t\t DMA_FROM_DEVICE);\n\n\tdev_kfree_skb(fp_skb(fp));\n\tbuf->os_buf = NULL;\n}\n\n \nvoid fnic_eth_send(struct fcoe_ctlr *fip, struct sk_buff *skb)\n{\n\tstruct fnic *fnic = fnic_from_ctlr(fip);\n\tstruct vnic_wq *wq = &fnic->wq[0];\n\tdma_addr_t pa;\n\tstruct ethhdr *eth_hdr;\n\tstruct vlan_ethhdr *vlan_hdr;\n\tunsigned long flags;\n\n\tif (!fnic->vlan_hw_insert) {\n\t\teth_hdr = (struct ethhdr *)skb_mac_header(skb);\n\t\tvlan_hdr = skb_push(skb, sizeof(*vlan_hdr) - sizeof(*eth_hdr));\n\t\tmemcpy(vlan_hdr, eth_hdr, 2 * ETH_ALEN);\n\t\tvlan_hdr->h_vlan_proto = htons(ETH_P_8021Q);\n\t\tvlan_hdr->h_vlan_encapsulated_proto = eth_hdr->h_proto;\n\t\tvlan_hdr->h_vlan_TCI = htons(fnic->vlan_id);\n\t\tif ((fnic_fc_trace_set_data(fnic->lport->host->host_no,\n\t\t\tFNIC_FC_SEND|0x80, (char *)eth_hdr, skb->len)) != 0) {\n\t\t\tprintk(KERN_ERR \"fnic ctlr frame trace error!!!\");\n\t\t}\n\t} else {\n\t\tif ((fnic_fc_trace_set_data(fnic->lport->host->host_no,\n\t\t\tFNIC_FC_SEND|0x80, (char *)skb->data, skb->len)) != 0) {\n\t\t\tprintk(KERN_ERR \"fnic ctlr frame trace error!!!\");\n\t\t}\n\t}\n\n\tpa = dma_map_single(&fnic->pdev->dev, skb->data, skb->len,\n\t\t\tDMA_TO_DEVICE);\n\tif (dma_mapping_error(&fnic->pdev->dev, pa)) {\n\t\tprintk(KERN_ERR \"DMA mapping failed\\n\");\n\t\tgoto free_skb;\n\t}\n\n\tspin_lock_irqsave(&fnic->wq_lock[0], flags);\n\tif (!vnic_wq_desc_avail(wq))\n\t\tgoto irq_restore;\n\n\tfnic_queue_wq_eth_desc(wq, skb, pa, skb->len,\n\t\t\t       0  ,\n\t\t\t       fnic->vlan_id, 1);\n\tspin_unlock_irqrestore(&fnic->wq_lock[0], flags);\n\treturn;\n\nirq_restore:\n\tspin_unlock_irqrestore(&fnic->wq_lock[0], flags);\n\tdma_unmap_single(&fnic->pdev->dev, pa, skb->len, DMA_TO_DEVICE);\nfree_skb:\n\tkfree_skb(skb);\n}\n\n \nstatic int fnic_send_frame(struct fnic *fnic, struct fc_frame *fp)\n{\n\tstruct vnic_wq *wq = &fnic->wq[0];\n\tstruct sk_buff *skb;\n\tdma_addr_t pa;\n\tstruct ethhdr *eth_hdr;\n\tstruct vlan_ethhdr *vlan_hdr;\n\tstruct fcoe_hdr *fcoe_hdr;\n\tstruct fc_frame_header *fh;\n\tu32 tot_len, eth_hdr_len;\n\tint ret = 0;\n\tunsigned long flags;\n\n\tfh = fc_frame_header_get(fp);\n\tskb = fp_skb(fp);\n\n\tif (unlikely(fh->fh_r_ctl == FC_RCTL_ELS_REQ) &&\n\t    fcoe_ctlr_els_send(&fnic->ctlr, fnic->lport, skb))\n\t\treturn 0;\n\n\tif (!fnic->vlan_hw_insert) {\n\t\teth_hdr_len = sizeof(*vlan_hdr) + sizeof(*fcoe_hdr);\n\t\tvlan_hdr = skb_push(skb, eth_hdr_len);\n\t\teth_hdr = (struct ethhdr *)vlan_hdr;\n\t\tvlan_hdr->h_vlan_proto = htons(ETH_P_8021Q);\n\t\tvlan_hdr->h_vlan_encapsulated_proto = htons(ETH_P_FCOE);\n\t\tvlan_hdr->h_vlan_TCI = htons(fnic->vlan_id);\n\t\tfcoe_hdr = (struct fcoe_hdr *)(vlan_hdr + 1);\n\t} else {\n\t\teth_hdr_len = sizeof(*eth_hdr) + sizeof(*fcoe_hdr);\n\t\teth_hdr = skb_push(skb, eth_hdr_len);\n\t\teth_hdr->h_proto = htons(ETH_P_FCOE);\n\t\tfcoe_hdr = (struct fcoe_hdr *)(eth_hdr + 1);\n\t}\n\n\tif (fnic->ctlr.map_dest)\n\t\tfc_fcoe_set_mac(eth_hdr->h_dest, fh->fh_d_id);\n\telse\n\t\tmemcpy(eth_hdr->h_dest, fnic->ctlr.dest_addr, ETH_ALEN);\n\tmemcpy(eth_hdr->h_source, fnic->data_src_addr, ETH_ALEN);\n\n\ttot_len = skb->len;\n\tBUG_ON(tot_len % 4);\n\n\tmemset(fcoe_hdr, 0, sizeof(*fcoe_hdr));\n\tfcoe_hdr->fcoe_sof = fr_sof(fp);\n\tif (FC_FCOE_VER)\n\t\tFC_FCOE_ENCAPS_VER(fcoe_hdr, FC_FCOE_VER);\n\n\tpa = dma_map_single(&fnic->pdev->dev, eth_hdr, tot_len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(&fnic->pdev->dev, pa)) {\n\t\tret = -ENOMEM;\n\t\tprintk(KERN_ERR \"DMA map failed with error %d\\n\", ret);\n\t\tgoto free_skb_on_err;\n\t}\n\n\tif ((fnic_fc_trace_set_data(fnic->lport->host->host_no, FNIC_FC_SEND,\n\t\t\t\t(char *)eth_hdr, tot_len)) != 0) {\n\t\tprintk(KERN_ERR \"fnic ctlr frame trace error!!!\");\n\t}\n\n\tspin_lock_irqsave(&fnic->wq_lock[0], flags);\n\n\tif (!vnic_wq_desc_avail(wq)) {\n\t\tdma_unmap_single(&fnic->pdev->dev, pa, tot_len, DMA_TO_DEVICE);\n\t\tret = -1;\n\t\tgoto irq_restore;\n\t}\n\n\tfnic_queue_wq_desc(wq, skb, pa, tot_len, fr_eof(fp),\n\t\t\t   0  ,\n\t\t\t   fnic->vlan_id, 1, 1, 1);\n\nirq_restore:\n\tspin_unlock_irqrestore(&fnic->wq_lock[0], flags);\n\nfree_skb_on_err:\n\tif (ret)\n\t\tdev_kfree_skb_any(fp_skb(fp));\n\n\treturn ret;\n}\n\n \nint fnic_send(struct fc_lport *lp, struct fc_frame *fp)\n{\n\tstruct fnic *fnic = lport_priv(lp);\n\tunsigned long flags;\n\n\tif (fnic->in_remove) {\n\t\tdev_kfree_skb(fp_skb(fp));\n\t\treturn -1;\n\t}\n\n\t \n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tif (fnic->state != FNIC_IN_FC_MODE && fnic->state != FNIC_IN_ETH_MODE) {\n\t\tskb_queue_tail(&fnic->tx_queue, fp_skb(fp));\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\treturn fnic_send_frame(fnic, fp);\n}\n\n \nvoid fnic_flush_tx(struct fnic *fnic)\n{\n\tstruct sk_buff *skb;\n\tstruct fc_frame *fp;\n\n\twhile ((skb = skb_dequeue(&fnic->tx_queue))) {\n\t\tfp = (struct fc_frame *)skb;\n\t\tfnic_send_frame(fnic, fp);\n\t}\n}\n\n \nstatic void fnic_set_eth_mode(struct fnic *fnic)\n{\n\tunsigned long flags;\n\tenum fnic_state old_state;\n\tint ret;\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\nagain:\n\told_state = fnic->state;\n\tswitch (old_state) {\n\tcase FNIC_IN_FC_MODE:\n\tcase FNIC_IN_ETH_TRANS_FC_MODE:\n\tdefault:\n\t\tfnic->state = FNIC_IN_FC_TRANS_ETH_MODE;\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\t\tret = fnic_fw_reset_handler(fnic);\n\n\t\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\t\tif (fnic->state != FNIC_IN_FC_TRANS_ETH_MODE)\n\t\t\tgoto again;\n\t\tif (ret)\n\t\t\tfnic->state = old_state;\n\t\tbreak;\n\n\tcase FNIC_IN_FC_TRANS_ETH_MODE:\n\tcase FNIC_IN_ETH_MODE:\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n}\n\nstatic void fnic_wq_complete_frame_send(struct vnic_wq *wq,\n\t\t\t\t\tstruct cq_desc *cq_desc,\n\t\t\t\t\tstruct vnic_wq_buf *buf, void *opaque)\n{\n\tstruct sk_buff *skb = buf->os_buf;\n\tstruct fc_frame *fp = (struct fc_frame *)skb;\n\tstruct fnic *fnic = vnic_dev_priv(wq->vdev);\n\n\tdma_unmap_single(&fnic->pdev->dev, buf->dma_addr, buf->len,\n\t\t\t DMA_TO_DEVICE);\n\tdev_kfree_skb_irq(fp_skb(fp));\n\tbuf->os_buf = NULL;\n}\n\nstatic int fnic_wq_cmpl_handler_cont(struct vnic_dev *vdev,\n\t\t\t\t     struct cq_desc *cq_desc, u8 type,\n\t\t\t\t     u16 q_number, u16 completed_index,\n\t\t\t\t     void *opaque)\n{\n\tstruct fnic *fnic = vnic_dev_priv(vdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fnic->wq_lock[q_number], flags);\n\tvnic_wq_service(&fnic->wq[q_number], cq_desc, completed_index,\n\t\t\tfnic_wq_complete_frame_send, NULL);\n\tspin_unlock_irqrestore(&fnic->wq_lock[q_number], flags);\n\n\treturn 0;\n}\n\nint fnic_wq_cmpl_handler(struct fnic *fnic, int work_to_do)\n{\n\tunsigned int wq_work_done = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < fnic->raw_wq_count; i++) {\n\t\twq_work_done  += vnic_cq_service(&fnic->cq[fnic->rq_count+i],\n\t\t\t\t\t\t work_to_do,\n\t\t\t\t\t\t fnic_wq_cmpl_handler_cont,\n\t\t\t\t\t\t NULL);\n\t}\n\n\treturn wq_work_done;\n}\n\n\nvoid fnic_free_wq_buf(struct vnic_wq *wq, struct vnic_wq_buf *buf)\n{\n\tstruct fc_frame *fp = buf->os_buf;\n\tstruct fnic *fnic = vnic_dev_priv(wq->vdev);\n\n\tdma_unmap_single(&fnic->pdev->dev, buf->dma_addr, buf->len,\n\t\t\t DMA_TO_DEVICE);\n\n\tdev_kfree_skb(fp_skb(fp));\n\tbuf->os_buf = NULL;\n}\n\nvoid fnic_fcoe_reset_vlans(struct fnic *fnic)\n{\n\tunsigned long flags;\n\tstruct fcoe_vlan *vlan;\n\tstruct fcoe_vlan *next;\n\n\t \n\tspin_lock_irqsave(&fnic->vlans_lock, flags);\n\tif (!list_empty(&fnic->vlans)) {\n\t\tlist_for_each_entry_safe(vlan, next, &fnic->vlans, list) {\n\t\t\tlist_del(&vlan->list);\n\t\t\tkfree(vlan);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&fnic->vlans_lock, flags);\n}\n\nvoid fnic_handle_fip_timer(struct fnic *fnic)\n{\n\tunsigned long flags;\n\tstruct fcoe_vlan *vlan;\n\tstruct fnic_stats *fnic_stats = &fnic->fnic_stats;\n\tu64 sol_time;\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tif (fnic->stop_rx_link_events) {\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\tif (fnic->ctlr.mode == FIP_MODE_NON_FIP)\n\t\treturn;\n\n\tspin_lock_irqsave(&fnic->vlans_lock, flags);\n\tif (list_empty(&fnic->vlans)) {\n\t\tspin_unlock_irqrestore(&fnic->vlans_lock, flags);\n\t\t \n\t\tif (unlikely(fnic_log_level & FNIC_FCS_LOGGING))\n\t\t\tif (printk_ratelimit())\n\t\t\t\tshost_printk(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t\t\t\"Start VLAN Discovery\\n\");\n\t\tfnic_event_enq(fnic, FNIC_EVT_START_VLAN_DISC);\n\t\treturn;\n\t}\n\n\tvlan = list_first_entry(&fnic->vlans, struct fcoe_vlan, list);\n\tFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t  \"fip_timer: vlan %d state %d sol_count %d\\n\",\n\t\t  vlan->vid, vlan->state, vlan->sol_count);\n\tswitch (vlan->state) {\n\tcase FIP_VLAN_USED:\n\t\tFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t  \"FIP VLAN is selected for FC transaction\\n\");\n\t\tspin_unlock_irqrestore(&fnic->vlans_lock, flags);\n\t\tbreak;\n\tcase FIP_VLAN_FAILED:\n\t\tspin_unlock_irqrestore(&fnic->vlans_lock, flags);\n\t\t \n\t\tif (unlikely(fnic_log_level & FNIC_FCS_LOGGING))\n\t\t\tif (printk_ratelimit())\n\t\t\t\tshost_printk(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t\t  \"Start VLAN Discovery\\n\");\n\t\tfnic_event_enq(fnic, FNIC_EVT_START_VLAN_DISC);\n\t\tbreak;\n\tcase FIP_VLAN_SENT:\n\t\tif (vlan->sol_count >= FCOE_CTLR_MAX_SOL) {\n\t\t\t \n\t\t\tFNIC_FCS_DBG(KERN_INFO, fnic->lport->host,\n\t\t\t\t  \"Dequeue this VLAN ID %d from list\\n\",\n\t\t\t\t  vlan->vid);\n\t\t\tlist_del(&vlan->list);\n\t\t\tkfree(vlan);\n\t\t\tvlan = NULL;\n\t\t\tif (list_empty(&fnic->vlans)) {\n\t\t\t\t \n\t\t\t\tspin_unlock_irqrestore(&fnic->vlans_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tFNIC_FCS_DBG(KERN_INFO, fnic->lport->host,\n\t\t\t\t\t  \"fip_timer: vlan list empty, \"\n\t\t\t\t\t  \"trigger vlan disc\\n\");\n\t\t\t\tfnic_event_enq(fnic, FNIC_EVT_START_VLAN_DISC);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\tvlan = list_first_entry(&fnic->vlans, struct fcoe_vlan,\n\t\t\t\t\t\t\tlist);\n\t\t\tfnic->set_vlan(fnic, vlan->vid);\n\t\t\tvlan->state = FIP_VLAN_SENT;  \n\t\t}\n\t\tspin_unlock_irqrestore(&fnic->vlans_lock, flags);\n\t\tatomic64_inc(&fnic_stats->vlan_stats.sol_expiry_count);\n\t\tvlan->sol_count++;\n\t\tsol_time = jiffies + msecs_to_jiffies\n\t\t\t\t\t(FCOE_CTLR_START_DELAY);\n\t\tmod_timer(&fnic->fip_timer, round_jiffies(sol_time));\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}