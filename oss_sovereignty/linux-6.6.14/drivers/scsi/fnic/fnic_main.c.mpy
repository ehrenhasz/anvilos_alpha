{
  "module_name": "fnic_main.c",
  "hash_id": "95dac3e391e62132e745d458c31f3db9173c79ec41561c32ed59d950cd4ca6a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/fnic/fnic_main.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/mempool.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/skbuff.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/if_ether.h>\n#include <scsi/fc/fc_fip.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/libfc.h>\n#include <scsi/fc_frame.h>\n\n#include \"vnic_dev.h\"\n#include \"vnic_intr.h\"\n#include \"vnic_stats.h\"\n#include \"fnic_io.h\"\n#include \"fnic_fip.h\"\n#include \"fnic.h\"\n\n#define PCI_DEVICE_ID_CISCO_FNIC\t0x0045\n\n \n#define FNIC_NOTIFY_TIMER_PERIOD\t(2 * HZ)\n\nstatic struct kmem_cache *fnic_sgl_cache[FNIC_SGL_NUM_CACHES];\nstatic struct kmem_cache *fnic_io_req_cache;\nstatic LIST_HEAD(fnic_list);\nstatic DEFINE_SPINLOCK(fnic_list_lock);\n\n \nstatic struct pci_device_id fnic_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CISCO, PCI_DEVICE_ID_CISCO_FNIC) },\n\t{ 0, }\n};\n\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_AUTHOR(\"Abhijeet Joglekar <abjoglek@cisco.com>, \"\n\t      \"Joseph R. Eykholt <jeykholt@cisco.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_DEVICE_TABLE(pci, fnic_id_table);\n\nunsigned int fnic_log_level;\nmodule_param(fnic_log_level, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(fnic_log_level, \"bit mask of fnic logging levels\");\n\n\nunsigned int io_completions = FNIC_DFLT_IO_COMPLETIONS;\nmodule_param(io_completions, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(io_completions, \"Max CQ entries to process at a time\");\n\nunsigned int fnic_trace_max_pages = 16;\nmodule_param(fnic_trace_max_pages, uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(fnic_trace_max_pages, \"Total allocated memory pages \"\n\t\t\t\t\t\"for fnic trace buffer\");\n\nunsigned int fnic_fc_trace_max_pages = 64;\nmodule_param(fnic_fc_trace_max_pages, uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(fnic_fc_trace_max_pages,\n\t\t \"Total allocated memory pages for fc trace buffer\");\n\nstatic unsigned int fnic_max_qdepth = FNIC_DFLT_QUEUE_DEPTH;\nmodule_param(fnic_max_qdepth, uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(fnic_max_qdepth, \"Queue depth to report for each LUN\");\n\nstatic struct libfc_function_template fnic_transport_template = {\n\t.frame_send = fnic_send,\n\t.lport_set_port_id = fnic_set_port_id,\n\t.fcp_abort_io = fnic_empty_scsi_cleanup,\n\t.fcp_cleanup = fnic_empty_scsi_cleanup,\n\t.exch_mgr_reset = fnic_exch_mgr_reset\n};\n\nstatic int fnic_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\n\tif (!rport || fc_remote_port_chkready(rport))\n\t\treturn -ENXIO;\n\n\tscsi_change_queue_depth(sdev, fnic_max_qdepth);\n\treturn 0;\n}\n\nstatic const struct scsi_host_template fnic_host_template = {\n\t.module = THIS_MODULE,\n\t.name = DRV_NAME,\n\t.queuecommand = fnic_queuecommand,\n\t.eh_timed_out = fc_eh_timed_out,\n\t.eh_abort_handler = fnic_abort_cmd,\n\t.eh_device_reset_handler = fnic_device_reset,\n\t.eh_host_reset_handler = fnic_host_reset,\n\t.slave_alloc = fnic_slave_alloc,\n\t.change_queue_depth = scsi_change_queue_depth,\n\t.this_id = -1,\n\t.cmd_per_lun = 3,\n\t.can_queue = FNIC_DFLT_IO_REQ,\n\t.sg_tablesize = FNIC_MAX_SG_DESC_CNT,\n\t.max_sectors = 0xffff,\n\t.shost_groups = fnic_host_groups,\n\t.track_queue_depth = 1,\n\t.cmd_size = sizeof(struct fnic_cmd_priv),\n};\n\nstatic void\nfnic_set_rport_dev_loss_tmo(struct fc_rport *rport, u32 timeout)\n{\n\tif (timeout)\n\t\trport->dev_loss_tmo = timeout;\n\telse\n\t\trport->dev_loss_tmo = 1;\n}\n\nstatic void fnic_get_host_speed(struct Scsi_Host *shost);\nstatic struct scsi_transport_template *fnic_fc_transport;\nstatic struct fc_host_statistics *fnic_get_stats(struct Scsi_Host *);\nstatic void fnic_reset_host_stats(struct Scsi_Host *);\n\nstatic struct fc_function_template fnic_fc_functions = {\n\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_active_fc4s = 1,\n\t.show_host_maxframe_size = 1,\n\t.show_host_port_id = 1,\n\t.show_host_supported_speeds = 1,\n\t.get_host_speed = fnic_get_host_speed,\n\t.show_host_speed = 1,\n\t.show_host_port_type = 1,\n\t.get_host_port_state = fc_get_host_port_state,\n\t.show_host_port_state = 1,\n\t.show_host_symbolic_name = 1,\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\t.show_host_fabric_name = 1,\n\t.show_starget_node_name = 1,\n\t.show_starget_port_name = 1,\n\t.show_starget_port_id = 1,\n\t.show_rport_dev_loss_tmo = 1,\n\t.set_rport_dev_loss_tmo = fnic_set_rport_dev_loss_tmo,\n\t.issue_fc_host_lip = fnic_reset,\n\t.get_fc_host_stats = fnic_get_stats,\n\t.reset_fc_host_stats = fnic_reset_host_stats,\n\t.dd_fcrport_size = sizeof(struct fc_rport_libfc_priv),\n\t.terminate_rport_io = fnic_terminate_rport_io,\n\t.bsg_request = fc_lport_bsg_request,\n};\n\nstatic void fnic_get_host_speed(struct Scsi_Host *shost)\n{\n\tstruct fc_lport *lp = shost_priv(shost);\n\tstruct fnic *fnic = lport_priv(lp);\n\tu32 port_speed = vnic_dev_port_speed(fnic->vdev);\n\n\t \n\tswitch (port_speed) {\n\tcase DCEM_PORTSPEED_10G:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\n\t\tbreak;\n\tcase DCEM_PORTSPEED_20G:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_20GBIT;\n\t\tbreak;\n\tcase DCEM_PORTSPEED_25G:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_25GBIT;\n\t\tbreak;\n\tcase DCEM_PORTSPEED_40G:\n\tcase DCEM_PORTSPEED_4x10G:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_40GBIT;\n\t\tbreak;\n\tcase DCEM_PORTSPEED_100G:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_100GBIT;\n\t\tbreak;\n\tdefault:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\nstatic struct fc_host_statistics *fnic_get_stats(struct Scsi_Host *host)\n{\n\tint ret;\n\tstruct fc_lport *lp = shost_priv(host);\n\tstruct fnic *fnic = lport_priv(lp);\n\tstruct fc_host_statistics *stats = &lp->host_stats;\n\tstruct vnic_stats *vs;\n\tunsigned long flags;\n\n\tif (time_before(jiffies, fnic->stats_time + HZ / FNIC_STATS_RATE_LIMIT))\n\t\treturn stats;\n\tfnic->stats_time = jiffies;\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tret = vnic_dev_stats_dump(fnic->vdev, &fnic->stats);\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\tif (ret) {\n\t\tFNIC_MAIN_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t      \"fnic: Get vnic stats failed\"\n\t\t\t      \" 0x%x\", ret);\n\t\treturn stats;\n\t}\n\tvs = fnic->stats;\n\tstats->tx_frames = vs->tx.tx_unicast_frames_ok;\n\tstats->tx_words  = vs->tx.tx_unicast_bytes_ok / 4;\n\tstats->rx_frames = vs->rx.rx_unicast_frames_ok;\n\tstats->rx_words  = vs->rx.rx_unicast_bytes_ok / 4;\n\tstats->error_frames = vs->tx.tx_errors + vs->rx.rx_errors;\n\tstats->dumped_frames = vs->tx.tx_drops + vs->rx.rx_drop;\n\tstats->invalid_crc_count = vs->rx.rx_crc_errors;\n\tstats->seconds_since_last_reset =\n\t\t\t(jiffies - fnic->stats_reset_time) / HZ;\n\tstats->fcp_input_megabytes = div_u64(fnic->fcp_input_bytes, 1000000);\n\tstats->fcp_output_megabytes = div_u64(fnic->fcp_output_bytes, 1000000);\n\n\treturn stats;\n}\n\n \nvoid fnic_dump_fchost_stats(struct Scsi_Host *host,\n\t\t\t\tstruct fc_host_statistics *stats)\n{\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: seconds since last reset = %llu\\n\",\n\t\t\tstats->seconds_since_last_reset);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: tx frames\t\t= %llu\\n\",\n\t\t\tstats->tx_frames);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: tx words\t\t= %llu\\n\",\n\t\t\tstats->tx_words);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: rx frames\t\t= %llu\\n\",\n\t\t\tstats->rx_frames);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: rx words\t\t= %llu\\n\",\n\t\t\tstats->rx_words);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: lip count\t\t= %llu\\n\",\n\t\t\tstats->lip_count);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: nos count\t\t= %llu\\n\",\n\t\t\tstats->nos_count);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: error frames\t\t= %llu\\n\",\n\t\t\tstats->error_frames);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: dumped frames\t= %llu\\n\",\n\t\t\tstats->dumped_frames);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: link failure count\t= %llu\\n\",\n\t\t\tstats->link_failure_count);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: loss of sync count\t= %llu\\n\",\n\t\t\tstats->loss_of_sync_count);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: loss of signal count\t= %llu\\n\",\n\t\t\tstats->loss_of_signal_count);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: prim seq protocol err count = %llu\\n\",\n\t\t\tstats->prim_seq_protocol_err_count);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: invalid tx word count= %llu\\n\",\n\t\t\tstats->invalid_tx_word_count);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: invalid crc count\t= %llu\\n\",\n\t\t\tstats->invalid_crc_count);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: fcp input requests\t= %llu\\n\",\n\t\t\tstats->fcp_input_requests);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: fcp output requests\t= %llu\\n\",\n\t\t\tstats->fcp_output_requests);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: fcp control requests\t= %llu\\n\",\n\t\t\tstats->fcp_control_requests);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: fcp input megabytes\t= %llu\\n\",\n\t\t\tstats->fcp_input_megabytes);\n\tFNIC_MAIN_NOTE(KERN_NOTICE, host,\n\t\t\t\"fnic: fcp output megabytes\t= %llu\\n\",\n\t\t\tstats->fcp_output_megabytes);\n\treturn;\n}\n\n \nstatic void fnic_reset_host_stats(struct Scsi_Host *host)\n{\n\tint ret;\n\tstruct fc_lport *lp = shost_priv(host);\n\tstruct fnic *fnic = lport_priv(lp);\n\tstruct fc_host_statistics *stats;\n\tunsigned long flags;\n\n\t \n\tstats = fnic_get_stats(host);\n\tfnic_dump_fchost_stats(host, stats);\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tret = vnic_dev_stats_clear(fnic->vdev);\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\tif (ret) {\n\t\tFNIC_MAIN_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t\"fnic: Reset vnic stats failed\"\n\t\t\t\t\" 0x%x\", ret);\n\t\treturn;\n\t}\n\tfnic->stats_reset_time = jiffies;\n\tmemset(stats, 0, sizeof(*stats));\n\n\treturn;\n}\n\nvoid fnic_log_q_error(struct fnic *fnic)\n{\n\tunsigned int i;\n\tu32 error_status;\n\n\tfor (i = 0; i < fnic->raw_wq_count; i++) {\n\t\terror_status = ioread32(&fnic->wq[i].ctrl->error_status);\n\t\tif (error_status)\n\t\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t\t     \"WQ[%d] error_status\"\n\t\t\t\t     \" %d\\n\", i, error_status);\n\t}\n\n\tfor (i = 0; i < fnic->rq_count; i++) {\n\t\terror_status = ioread32(&fnic->rq[i].ctrl->error_status);\n\t\tif (error_status)\n\t\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t\t     \"RQ[%d] error_status\"\n\t\t\t\t     \" %d\\n\", i, error_status);\n\t}\n\n\tfor (i = 0; i < fnic->wq_copy_count; i++) {\n\t\terror_status = ioread32(&fnic->wq_copy[i].ctrl->error_status);\n\t\tif (error_status)\n\t\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t\t     \"CWQ[%d] error_status\"\n\t\t\t\t     \" %d\\n\", i, error_status);\n\t}\n}\n\nvoid fnic_handle_link_event(struct fnic *fnic)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tif (fnic->stop_rx_link_events) {\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\tqueue_work(fnic_event_queue, &fnic->link_work);\n\n}\n\nstatic int fnic_notify_set(struct fnic *fnic)\n{\n\tint err;\n\n\tswitch (vnic_dev_get_intr_mode(fnic->vdev)) {\n\tcase VNIC_DEV_INTR_MODE_INTX:\n\t\terr = vnic_dev_notify_set(fnic->vdev, FNIC_INTX_NOTIFY);\n\t\tbreak;\n\tcase VNIC_DEV_INTR_MODE_MSI:\n\t\terr = vnic_dev_notify_set(fnic->vdev, -1);\n\t\tbreak;\n\tcase VNIC_DEV_INTR_MODE_MSIX:\n\t\terr = vnic_dev_notify_set(fnic->vdev, FNIC_MSIX_ERR_NOTIFY);\n\t\tbreak;\n\tdefault:\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"Interrupt mode should be set up\"\n\t\t\t     \" before devcmd notify set %d\\n\",\n\t\t\t     vnic_dev_get_intr_mode(fnic->vdev));\n\t\terr = -1;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void fnic_notify_timer(struct timer_list *t)\n{\n\tstruct fnic *fnic = from_timer(fnic, t, notify_timer);\n\n\tfnic_handle_link_event(fnic);\n\tmod_timer(&fnic->notify_timer,\n\t\t  round_jiffies(jiffies + FNIC_NOTIFY_TIMER_PERIOD));\n}\n\nstatic void fnic_fip_notify_timer(struct timer_list *t)\n{\n\tstruct fnic *fnic = from_timer(fnic, t, fip_timer);\n\n\tfnic_handle_fip_timer(fnic);\n}\n\nstatic void fnic_notify_timer_start(struct fnic *fnic)\n{\n\tswitch (vnic_dev_get_intr_mode(fnic->vdev)) {\n\tcase VNIC_DEV_INTR_MODE_MSI:\n\t\t \n\t\tmod_timer(&fnic->notify_timer, jiffies);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic int fnic_dev_wait(struct vnic_dev *vdev,\n\t\t\t int (*start)(struct vnic_dev *, int),\n\t\t\t int (*finished)(struct vnic_dev *, int *),\n\t\t\t int arg)\n{\n\tunsigned long time;\n\tint done;\n\tint err;\n\tint count;\n\n\tcount = 0;\n\n\terr = start(vdev, arg);\n\tif (err)\n\t\treturn err;\n\n\t \n\ttime = jiffies + (HZ * 2);\n\tdo {\n\t\terr = finished(vdev, &done);\n\t\tcount++;\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (done)\n\t\t\treturn 0;\n\t\tschedule_timeout_uninterruptible(HZ / 10);\n\t} while (time_after(time, jiffies) || (count < 3));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int fnic_cleanup(struct fnic *fnic)\n{\n\tunsigned int i;\n\tint err;\n\n\tvnic_dev_disable(fnic->vdev);\n\tfor (i = 0; i < fnic->intr_count; i++)\n\t\tvnic_intr_mask(&fnic->intr[i]);\n\n\tfor (i = 0; i < fnic->rq_count; i++) {\n\t\terr = vnic_rq_disable(&fnic->rq[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tfor (i = 0; i < fnic->raw_wq_count; i++) {\n\t\terr = vnic_wq_disable(&fnic->wq[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tfor (i = 0; i < fnic->wq_copy_count; i++) {\n\t\terr = vnic_wq_copy_disable(&fnic->wq_copy[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tfnic_wq_copy_cmpl_handler(fnic, io_completions);\n\tfnic_wq_cmpl_handler(fnic, -1);\n\tfnic_rq_cmpl_handler(fnic, -1);\n\n\t \n\tfor (i = 0; i < fnic->raw_wq_count; i++)\n\t\tvnic_wq_clean(&fnic->wq[i], fnic_free_wq_buf);\n\tfor (i = 0; i < fnic->rq_count; i++)\n\t\tvnic_rq_clean(&fnic->rq[i], fnic_free_rq_buf);\n\tfor (i = 0; i < fnic->wq_copy_count; i++)\n\t\tvnic_wq_copy_clean(&fnic->wq_copy[i],\n\t\t\t\t   fnic_wq_copy_cleanup_handler);\n\n\tfor (i = 0; i < fnic->cq_count; i++)\n\t\tvnic_cq_clean(&fnic->cq[i]);\n\tfor (i = 0; i < fnic->intr_count; i++)\n\t\tvnic_intr_clean(&fnic->intr[i]);\n\n\tmempool_destroy(fnic->io_req_pool);\n\tfor (i = 0; i < FNIC_SGL_NUM_CACHES; i++)\n\t\tmempool_destroy(fnic->io_sgl_pool[i]);\n\n\treturn 0;\n}\n\nstatic void fnic_iounmap(struct fnic *fnic)\n{\n\tif (fnic->bar0.vaddr)\n\t\tiounmap(fnic->bar0.vaddr);\n}\n\n \nstatic u8 *fnic_get_mac(struct fc_lport *lport)\n{\n\tstruct fnic *fnic = lport_priv(lport);\n\n\treturn fnic->data_src_addr;\n}\n\nstatic void fnic_set_vlan(struct fnic *fnic, u16 vlan_id)\n{\n\tvnic_dev_set_default_vlan(fnic->vdev, vlan_id);\n}\n\nstatic int fnic_scsi_drv_init(struct fnic *fnic)\n{\n\tstruct Scsi_Host *host = fnic->lport->host;\n\n\t \n\tif (fnic->config.io_throttle_count != FNIC_UCSM_DFLT_THROTTLE_CNT_BLD)\n\t\thost->can_queue = min_t(u32, FNIC_MAX_IO_REQ,\n\t\t\t\t\tmax_t(u32, FNIC_MIN_IO_REQ,\n\t\t\t\t\tfnic->config.io_throttle_count));\n\n\tfnic->fnic_max_tag_id = host->can_queue;\n\thost->max_lun = fnic->config.luns_per_tgt;\n\thost->max_id = FNIC_MAX_FCP_TARGET;\n\thost->max_cmd_len = FCOE_MAX_CMD_LEN;\n\n\thost->nr_hw_queues = fnic->wq_copy_count;\n\tif (host->nr_hw_queues > 1)\n\t\tshost_printk(KERN_ERR, host,\n\t\t\t\t\"fnic: blk-mq is not supported\");\n\n\thost->nr_hw_queues = fnic->wq_copy_count = 1;\n\n\tshost_printk(KERN_INFO, host,\n\t\t\t\"fnic: can_queue: %d max_lun: %llu\",\n\t\t\thost->can_queue, host->max_lun);\n\n\tshost_printk(KERN_INFO, host,\n\t\t\t\"fnic: max_id: %d max_cmd_len: %d nr_hw_queues: %d\",\n\t\t\thost->max_id, host->max_cmd_len, host->nr_hw_queues);\n\n\treturn 0;\n}\n\nstatic int fnic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct Scsi_Host *host;\n\tstruct fc_lport *lp;\n\tstruct fnic *fnic;\n\tmempool_t *pool;\n\tint err;\n\tint i;\n\tunsigned long flags;\n\n\t \n\tlp = libfc_host_alloc(&fnic_host_template, sizeof(struct fnic));\n\tif (!lp) {\n\t\tprintk(KERN_ERR PFX \"Unable to alloc libfc local port\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\thost = lp->host;\n\tfnic = lport_priv(lp);\n\tfnic->lport = lp;\n\tfnic->ctlr.lp = lp;\n\n\tfnic->link_events = 0;\n\n\tsnprintf(fnic->name, sizeof(fnic->name) - 1, \"%s%d\", DRV_NAME,\n\t\t host->host_no);\n\n\thost->transportt = fnic_fc_transport;\n\n\tfnic_stats_debugfs_init(fnic);\n\n\t \n\tpci_set_drvdata(pdev, fnic);\n\n\tfnic->pdev = pdev;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"Cannot enable PCI device, aborting.\\n\");\n\t\tgoto err_out_free_hba;\n\t}\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"Cannot enable PCI resources, aborting\\n\");\n\t\tgoto err_out_disable_device;\n\t}\n\n\tpci_set_master(pdev);\n\n\t \n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(47));\n\tif (err) {\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t\t     \"No usable DMA configuration \"\n\t\t\t\t     \"aborting\\n\");\n\t\t\tgoto err_out_release_regions;\n\t\t}\n\t}\n\n\t \n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"BAR0 not memory-map'able, aborting.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_release_regions;\n\t}\n\n\tfnic->bar0.vaddr = pci_iomap(pdev, 0, 0);\n\tfnic->bar0.bus_addr = pci_resource_start(pdev, 0);\n\tfnic->bar0.len = pci_resource_len(pdev, 0);\n\n\tif (!fnic->bar0.vaddr) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"Cannot memory-map BAR0 res hdr, \"\n\t\t\t     \"aborting.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_release_regions;\n\t}\n\n\tfnic->vdev = vnic_dev_register(NULL, fnic, pdev, &fnic->bar0);\n\tif (!fnic->vdev) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"vNIC registration failed, \"\n\t\t\t     \"aborting.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_iounmap;\n\t}\n\n\terr = vnic_dev_cmd_init(fnic->vdev);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t\t\"vnic_dev_cmd_init() returns %d, aborting\\n\",\n\t\t\t\terr);\n\t\tgoto err_out_vnic_unregister;\n\t}\n\n\terr = fnic_dev_wait(fnic->vdev, vnic_dev_open,\n\t\t\t    vnic_dev_open_done, CMD_OPENF_RQ_ENABLE_THEN_POST);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"vNIC dev open failed, aborting.\\n\");\n\t\tgoto err_out_dev_cmd_deinit;\n\t}\n\n\terr = vnic_dev_init(fnic->vdev, 0);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"vNIC dev init failed, aborting.\\n\");\n\t\tgoto err_out_dev_close;\n\t}\n\n\terr = vnic_dev_mac_addr(fnic->vdev, fnic->ctlr.ctl_src_addr);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"vNIC get MAC addr failed \\n\");\n\t\tgoto err_out_dev_close;\n\t}\n\t \n\tmemcpy(fnic->data_src_addr, fnic->ctlr.ctl_src_addr, ETH_ALEN);\n\n\t \n\terr = fnic_get_vnic_config(fnic);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"Get vNIC configuration failed, \"\n\t\t\t     \"aborting.\\n\");\n\t\tgoto err_out_dev_close;\n\t}\n\n\tfnic_scsi_drv_init(fnic);\n\n\tfnic_get_res_counts(fnic);\n\n\terr = fnic_set_intr_mode(fnic);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"Failed to set intr mode, \"\n\t\t\t     \"aborting.\\n\");\n\t\tgoto err_out_dev_close;\n\t}\n\n\terr = fnic_alloc_vnic_resources(fnic);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"Failed to alloc vNIC resources, \"\n\t\t\t     \"aborting.\\n\");\n\t\tgoto err_out_clear_intr;\n\t}\n\n\n\t \n\tspin_lock_init(&fnic->fnic_lock);\n\n\tfor (i = 0; i < FNIC_WQ_MAX; i++)\n\t\tspin_lock_init(&fnic->wq_lock[i]);\n\n\tfor (i = 0; i < FNIC_WQ_COPY_MAX; i++) {\n\t\tspin_lock_init(&fnic->wq_copy_lock[i]);\n\t\tfnic->wq_copy_desc_low[i] = DESC_CLEAN_LOW_WATERMARK;\n\t\tfnic->fw_ack_recd[i] = 0;\n\t\tfnic->fw_ack_index[i] = -1;\n\t}\n\n\tfor (i = 0; i < FNIC_IO_LOCKS; i++)\n\t\tspin_lock_init(&fnic->io_req_lock[i]);\n\n\tspin_lock_init(&fnic->sgreset_lock);\n\n\terr = -ENOMEM;\n\tfnic->io_req_pool = mempool_create_slab_pool(2, fnic_io_req_cache);\n\tif (!fnic->io_req_pool)\n\t\tgoto err_out_free_resources;\n\n\tpool = mempool_create_slab_pool(2, fnic_sgl_cache[FNIC_SGL_CACHE_DFLT]);\n\tif (!pool)\n\t\tgoto err_out_free_ioreq_pool;\n\tfnic->io_sgl_pool[FNIC_SGL_CACHE_DFLT] = pool;\n\n\tpool = mempool_create_slab_pool(2, fnic_sgl_cache[FNIC_SGL_CACHE_MAX]);\n\tif (!pool)\n\t\tgoto err_out_free_dflt_pool;\n\tfnic->io_sgl_pool[FNIC_SGL_CACHE_MAX] = pool;\n\n\t \n\tfnic->vlan_hw_insert = 1;\n\tfnic->vlan_id = 0;\n\n\t \n\tfnic->ctlr.send = fnic_eth_send;\n\tfnic->ctlr.update_mac = fnic_update_mac;\n\tfnic->ctlr.get_src_addr = fnic_get_mac;\n\tif (fnic->config.flags & VFCF_FIP_CAPABLE) {\n\t\tshost_printk(KERN_INFO, fnic->lport->host,\n\t\t\t     \"firmware supports FIP\\n\");\n\t\t \n\t\tvnic_dev_packet_filter(fnic->vdev, 1, 1, 0, 0, 0);\n\t\tvnic_dev_add_addr(fnic->vdev, FIP_ALL_ENODE_MACS);\n\t\tvnic_dev_add_addr(fnic->vdev, fnic->ctlr.ctl_src_addr);\n\t\tfnic->set_vlan = fnic_set_vlan;\n\t\tfcoe_ctlr_init(&fnic->ctlr, FIP_MODE_AUTO);\n\t\ttimer_setup(&fnic->fip_timer, fnic_fip_notify_timer, 0);\n\t\tspin_lock_init(&fnic->vlans_lock);\n\t\tINIT_WORK(&fnic->fip_frame_work, fnic_handle_fip_frame);\n\t\tINIT_WORK(&fnic->event_work, fnic_handle_event);\n\t\tskb_queue_head_init(&fnic->fip_frame_queue);\n\t\tINIT_LIST_HEAD(&fnic->evlist);\n\t\tINIT_LIST_HEAD(&fnic->vlans);\n\t} else {\n\t\tshost_printk(KERN_INFO, fnic->lport->host,\n\t\t\t     \"firmware uses non-FIP mode\\n\");\n\t\tfcoe_ctlr_init(&fnic->ctlr, FIP_MODE_NON_FIP);\n\t\tfnic->ctlr.state = FIP_ST_NON_FIP;\n\t}\n\tfnic->state = FNIC_IN_FC_MODE;\n\n\tatomic_set(&fnic->in_flight, 0);\n\tfnic->state_flags = FNIC_FLAGS_NONE;\n\n\t \n\tfnic_set_nic_config(fnic, 0, 0, 0, 0, 0, 0, 1);\n\n\t \n\terr = fnic_notify_set(fnic);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"Failed to alloc notify buffer, aborting.\\n\");\n\t\tgoto err_out_free_max_pool;\n\t}\n\n\t \n\tif (vnic_dev_get_intr_mode(fnic->vdev) == VNIC_DEV_INTR_MODE_MSI)\n\t\ttimer_setup(&fnic->notify_timer, fnic_notify_timer, 0);\n\n\t \n\tfor (i = 0; i < fnic->rq_count; i++) {\n\t\tvnic_rq_enable(&fnic->rq[i]);\n\t\terr = vnic_rq_fill(&fnic->rq[i], fnic_alloc_rq_frame);\n\t\tif (err) {\n\t\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t\t     \"fnic_alloc_rq_frame can't alloc \"\n\t\t\t\t     \"frame\\n\");\n\t\t\tgoto err_out_free_rq_buf;\n\t\t}\n\t}\n\n\t \n\terr = scsi_add_host(lp->host, &pdev->dev);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"fnic: scsi_add_host failed...exiting\\n\");\n\t\tgoto err_out_free_rq_buf;\n\t}\n\n\t \n\n\tlp->link_up = 0;\n\n\tlp->max_retry_count = fnic->config.flogi_retries;\n\tlp->max_rport_retry_count = fnic->config.plogi_retries;\n\tlp->service_params = (FCP_SPPF_INIT_FCN | FCP_SPPF_RD_XRDY_DIS |\n\t\t\t      FCP_SPPF_CONF_COMPL);\n\tif (fnic->config.flags & VFCF_FCP_SEQ_LVL_ERR)\n\t\tlp->service_params |= FCP_SPPF_RETRY;\n\n\tlp->boot_time = jiffies;\n\tlp->e_d_tov = fnic->config.ed_tov;\n\tlp->r_a_tov = fnic->config.ra_tov;\n\tlp->link_supported_speeds = FC_PORTSPEED_10GBIT;\n\tfc_set_wwnn(lp, fnic->config.node_wwn);\n\tfc_set_wwpn(lp, fnic->config.port_wwn);\n\n\tfcoe_libfc_config(lp, &fnic->ctlr, &fnic_transport_template, 0);\n\n\tif (!fc_exch_mgr_alloc(lp, FC_CLASS_3, FCPIO_HOST_EXCH_RANGE_START,\n\t\t\t       FCPIO_HOST_EXCH_RANGE_END, NULL)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_remove_scsi_host;\n\t}\n\n\tfc_lport_init_stats(lp);\n\tfnic->stats_reset_time = jiffies;\n\n\tfc_lport_config(lp);\n\n\tif (fc_set_mfs(lp, fnic->config.maxdatafieldsize +\n\t\t       sizeof(struct fc_frame_header))) {\n\t\terr = -EINVAL;\n\t\tgoto err_out_free_exch_mgr;\n\t}\n\tfc_host_maxframe_size(lp->host) = lp->mfs;\n\tfc_host_dev_loss_tmo(lp->host) = fnic->config.port_down_timeout / 1000;\n\n\tsprintf(fc_host_symbolic_name(lp->host),\n\t\tDRV_NAME \" v\" DRV_VERSION \" over %s\", fnic->name);\n\n\tspin_lock_irqsave(&fnic_list_lock, flags);\n\tlist_add_tail(&fnic->list, &fnic_list);\n\tspin_unlock_irqrestore(&fnic_list_lock, flags);\n\n\tINIT_WORK(&fnic->link_work, fnic_handle_link);\n\tINIT_WORK(&fnic->frame_work, fnic_handle_frame);\n\tskb_queue_head_init(&fnic->frame_queue);\n\tskb_queue_head_init(&fnic->tx_queue);\n\n\t \n\tfor (i = 0; i < fnic->raw_wq_count; i++)\n\t\tvnic_wq_enable(&fnic->wq[i]);\n\tfor (i = 0; i < fnic->wq_copy_count; i++)\n\t\tvnic_wq_copy_enable(&fnic->wq_copy[i]);\n\n\tfc_fabric_login(lp);\n\n\terr = fnic_request_intr(fnic);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"Unable to request irq.\\n\");\n\t\tgoto err_out_free_exch_mgr;\n\t}\n\n\tvnic_dev_enable(fnic->vdev);\n\n\tfor (i = 0; i < fnic->intr_count; i++)\n\t\tvnic_intr_unmask(&fnic->intr[i]);\n\n\tfnic_notify_timer_start(fnic);\n\n\treturn 0;\n\nerr_out_free_exch_mgr:\n\tfc_exch_mgr_free(lp);\nerr_out_remove_scsi_host:\n\tfc_remove_host(lp->host);\n\tscsi_remove_host(lp->host);\nerr_out_free_rq_buf:\n\tfor (i = 0; i < fnic->rq_count; i++)\n\t\tvnic_rq_clean(&fnic->rq[i], fnic_free_rq_buf);\n\tvnic_dev_notify_unset(fnic->vdev);\nerr_out_free_max_pool:\n\tmempool_destroy(fnic->io_sgl_pool[FNIC_SGL_CACHE_MAX]);\nerr_out_free_dflt_pool:\n\tmempool_destroy(fnic->io_sgl_pool[FNIC_SGL_CACHE_DFLT]);\nerr_out_free_ioreq_pool:\n\tmempool_destroy(fnic->io_req_pool);\nerr_out_free_resources:\n\tfnic_free_vnic_resources(fnic);\nerr_out_clear_intr:\n\tfnic_clear_intr_mode(fnic);\nerr_out_dev_close:\n\tvnic_dev_close(fnic->vdev);\nerr_out_dev_cmd_deinit:\nerr_out_vnic_unregister:\n\tvnic_dev_unregister(fnic->vdev);\nerr_out_iounmap:\n\tfnic_iounmap(fnic);\nerr_out_release_regions:\n\tpci_release_regions(pdev);\nerr_out_disable_device:\n\tpci_disable_device(pdev);\nerr_out_free_hba:\n\tfnic_stats_debugfs_remove(fnic);\n\tscsi_host_put(lp->host);\nerr_out:\n\treturn err;\n}\n\nstatic void fnic_remove(struct pci_dev *pdev)\n{\n\tstruct fnic *fnic = pci_get_drvdata(pdev);\n\tstruct fc_lport *lp = fnic->lport;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tfnic->stop_rx_link_events = 1;\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\tif (vnic_dev_get_intr_mode(fnic->vdev) == VNIC_DEV_INTR_MODE_MSI)\n\t\tdel_timer_sync(&fnic->notify_timer);\n\n\t \n\tflush_workqueue(fnic_event_queue);\n\tskb_queue_purge(&fnic->frame_queue);\n\tskb_queue_purge(&fnic->tx_queue);\n\n\tif (fnic->config.flags & VFCF_FIP_CAPABLE) {\n\t\tdel_timer_sync(&fnic->fip_timer);\n\t\tskb_queue_purge(&fnic->fip_frame_queue);\n\t\tfnic_fcoe_reset_vlans(fnic);\n\t\tfnic_fcoe_evlist_free(fnic);\n\t}\n\n\t \n\tfc_fabric_logoff(fnic->lport);\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tfnic->in_remove = 1;\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\tfcoe_ctlr_destroy(&fnic->ctlr);\n\tfc_lport_destroy(lp);\n\tfnic_stats_debugfs_remove(fnic);\n\n\t \n\tfnic_cleanup(fnic);\n\n\tBUG_ON(!skb_queue_empty(&fnic->frame_queue));\n\tBUG_ON(!skb_queue_empty(&fnic->tx_queue));\n\n\tspin_lock_irqsave(&fnic_list_lock, flags);\n\tlist_del(&fnic->list);\n\tspin_unlock_irqrestore(&fnic_list_lock, flags);\n\n\tfc_remove_host(fnic->lport->host);\n\tscsi_remove_host(fnic->lport->host);\n\tfc_exch_mgr_free(fnic->lport);\n\tvnic_dev_notify_unset(fnic->vdev);\n\tfnic_free_intr(fnic);\n\tfnic_free_vnic_resources(fnic);\n\tfnic_clear_intr_mode(fnic);\n\tvnic_dev_close(fnic->vdev);\n\tvnic_dev_unregister(fnic->vdev);\n\tfnic_iounmap(fnic);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tscsi_host_put(lp->host);\n}\n\nstatic struct pci_driver fnic_driver = {\n\t.name = DRV_NAME,\n\t.id_table = fnic_id_table,\n\t.probe = fnic_probe,\n\t.remove = fnic_remove,\n};\n\nstatic int __init fnic_init_module(void)\n{\n\tsize_t len;\n\tint err = 0;\n\n\tprintk(KERN_INFO PFX \"%s, ver %s\\n\", DRV_DESCRIPTION, DRV_VERSION);\n\n\t \n\terr = fnic_debugfs_init();\n\tif (err < 0) {\n\t\tprintk(KERN_ERR PFX \"Failed to create fnic directory \"\n\t\t\t\t\"for tracing and stats logging\\n\");\n\t\tfnic_debugfs_terminate();\n\t}\n\n\t \n\terr = fnic_trace_buf_init();\n\tif (err < 0) {\n\t\tprintk(KERN_ERR PFX\n\t\t       \"Trace buffer initialization Failed. \"\n\t\t       \"Fnic Tracing utility is disabled\\n\");\n\t\tfnic_trace_free();\n\t}\n\n     \n\terr = fnic_fc_trace_init();\n\tif (err < 0) {\n\t\tprintk(KERN_ERR PFX \"FC trace buffer initialization Failed \"\n\t\t       \"FC frame tracing utility is disabled\\n\");\n\t\tfnic_fc_trace_free();\n\t}\n\n\t \n\tlen = sizeof(struct fnic_dflt_sgl_list);\n\tfnic_sgl_cache[FNIC_SGL_CACHE_DFLT] = kmem_cache_create\n\t\t(\"fnic_sgl_dflt\", len + FNIC_SG_DESC_ALIGN, FNIC_SG_DESC_ALIGN,\n\t\t SLAB_HWCACHE_ALIGN,\n\t\t NULL);\n\tif (!fnic_sgl_cache[FNIC_SGL_CACHE_DFLT]) {\n\t\tprintk(KERN_ERR PFX \"failed to create fnic dflt sgl slab\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_create_fnic_sgl_slab_dflt;\n\t}\n\n\t \n\tlen = sizeof(struct fnic_sgl_list);\n\tfnic_sgl_cache[FNIC_SGL_CACHE_MAX] = kmem_cache_create\n\t\t(\"fnic_sgl_max\", len + FNIC_SG_DESC_ALIGN, FNIC_SG_DESC_ALIGN,\n\t\t  SLAB_HWCACHE_ALIGN,\n\t\t  NULL);\n\tif (!fnic_sgl_cache[FNIC_SGL_CACHE_MAX]) {\n\t\tprintk(KERN_ERR PFX \"failed to create fnic max sgl slab\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_create_fnic_sgl_slab_max;\n\t}\n\n\t \n\tfnic_io_req_cache = kmem_cache_create(\"fnic_io_req\",\n\t\t\t\t\t      sizeof(struct fnic_io_req),\n\t\t\t\t\t      0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (!fnic_io_req_cache) {\n\t\tprintk(KERN_ERR PFX \"failed to create fnic io_req slab\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_create_fnic_ioreq_slab;\n\t}\n\n\tfnic_event_queue = create_singlethread_workqueue(\"fnic_event_wq\");\n\tif (!fnic_event_queue) {\n\t\tprintk(KERN_ERR PFX \"fnic work queue create failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_create_fnic_workq;\n\t}\n\n\tfnic_fip_queue = create_singlethread_workqueue(\"fnic_fip_q\");\n\tif (!fnic_fip_queue) {\n\t\tprintk(KERN_ERR PFX \"fnic FIP work queue create failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_create_fip_workq;\n\t}\n\n\tfnic_fc_transport = fc_attach_transport(&fnic_fc_functions);\n\tif (!fnic_fc_transport) {\n\t\tprintk(KERN_ERR PFX \"fc_attach_transport error\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_fc_transport;\n\t}\n\n\t \n\terr = pci_register_driver(&fnic_driver);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR PFX \"pci register error\\n\");\n\t\tgoto err_pci_register;\n\t}\n\treturn err;\n\nerr_pci_register:\n\tfc_release_transport(fnic_fc_transport);\nerr_fc_transport:\n\tdestroy_workqueue(fnic_fip_queue);\nerr_create_fip_workq:\n\tdestroy_workqueue(fnic_event_queue);\nerr_create_fnic_workq:\n\tkmem_cache_destroy(fnic_io_req_cache);\nerr_create_fnic_ioreq_slab:\n\tkmem_cache_destroy(fnic_sgl_cache[FNIC_SGL_CACHE_MAX]);\nerr_create_fnic_sgl_slab_max:\n\tkmem_cache_destroy(fnic_sgl_cache[FNIC_SGL_CACHE_DFLT]);\nerr_create_fnic_sgl_slab_dflt:\n\tfnic_trace_free();\n\tfnic_fc_trace_free();\n\tfnic_debugfs_terminate();\n\treturn err;\n}\n\nstatic void __exit fnic_cleanup_module(void)\n{\n\tpci_unregister_driver(&fnic_driver);\n\tdestroy_workqueue(fnic_event_queue);\n\tif (fnic_fip_queue)\n\t\tdestroy_workqueue(fnic_fip_queue);\n\tkmem_cache_destroy(fnic_sgl_cache[FNIC_SGL_CACHE_MAX]);\n\tkmem_cache_destroy(fnic_sgl_cache[FNIC_SGL_CACHE_DFLT]);\n\tkmem_cache_destroy(fnic_io_req_cache);\n\tfc_release_transport(fnic_fc_transport);\n\tfnic_trace_free();\n\tfnic_fc_trace_free();\n\tfnic_debugfs_terminate();\n}\n\nmodule_init(fnic_init_module);\nmodule_exit(fnic_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}