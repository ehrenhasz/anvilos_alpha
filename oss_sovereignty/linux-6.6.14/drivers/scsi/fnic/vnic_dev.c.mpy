{
  "module_name": "vnic_dev.c",
  "hash_id": "f7e3f7e54c113c558831495c32feaa05bcd362234a0900552bedd4ba6ba87207",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/fnic/vnic_dev.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/if_ether.h>\n#include <linux/slab.h>\n#include \"vnic_resource.h\"\n#include \"vnic_devcmd.h\"\n#include \"vnic_dev.h\"\n#include \"vnic_stats.h\"\n#include \"vnic_wq.h\"\n\nstruct devcmd2_controller {\n\tstruct vnic_wq_ctrl *wq_ctrl;\n\tstruct vnic_dev_ring results_ring;\n\tstruct vnic_wq wq;\n\tstruct vnic_devcmd2 *cmd_ring;\n\tstruct devcmd2_result *result;\n\tu16 next_result;\n\tu16 result_size;\n\tint color;\n};\n\nenum vnic_proxy_type {\n\tPROXY_NONE,\n\tPROXY_BY_BDF,\n\tPROXY_BY_INDEX,\n};\n\nstruct vnic_res {\n\tvoid __iomem *vaddr;\n\tunsigned int count;\n};\n\nstruct vnic_dev {\n\tvoid *priv;\n\tstruct pci_dev *pdev;\n\tstruct vnic_res res[RES_TYPE_MAX];\n\tenum vnic_dev_intr_mode intr_mode;\n\tstruct vnic_devcmd __iomem *devcmd;\n\tstruct vnic_devcmd_notify *notify;\n\tstruct vnic_devcmd_notify notify_copy;\n\tdma_addr_t notify_pa;\n\tu32 *linkstatus;\n\tdma_addr_t linkstatus_pa;\n\tstruct vnic_stats *stats;\n\tdma_addr_t stats_pa;\n\tstruct vnic_devcmd_fw_info *fw_info;\n\tdma_addr_t fw_info_pa;\n\tenum vnic_proxy_type proxy;\n\tu32 proxy_index;\n\tu64 args[VNIC_DEVCMD_NARGS];\n\tstruct devcmd2_controller *devcmd2;\n\tint (*devcmd_rtn)(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd,\n\t\t\tint wait);\n};\n\n#define VNIC_MAX_RES_HDR_SIZE \\\n\t(sizeof(struct vnic_resource_header) + \\\n\tsizeof(struct vnic_resource) * RES_TYPE_MAX)\n#define VNIC_RES_STRIDE\t128\n\nvoid *vnic_dev_priv(struct vnic_dev *vdev)\n{\n\treturn vdev->priv;\n}\n\nstatic int vnic_dev_discover_res(struct vnic_dev *vdev,\n\tstruct vnic_dev_bar *bar)\n{\n\tstruct vnic_resource_header __iomem *rh;\n\tstruct vnic_resource __iomem *r;\n\tu8 type;\n\n\tif (bar->len < VNIC_MAX_RES_HDR_SIZE) {\n\t\tprintk(KERN_ERR \"vNIC BAR0 res hdr length error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trh = bar->vaddr;\n\tif (!rh) {\n\t\tprintk(KERN_ERR \"vNIC BAR0 res hdr not mem-mapped\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ioread32(&rh->magic) != VNIC_RES_MAGIC ||\n\t    ioread32(&rh->version) != VNIC_RES_VERSION) {\n\t\tprintk(KERN_ERR \"vNIC BAR0 res magic/version error \"\n\t\t\t\"exp (%lx/%lx) curr (%x/%x)\\n\",\n\t\t\tVNIC_RES_MAGIC, VNIC_RES_VERSION,\n\t\t\tioread32(&rh->magic), ioread32(&rh->version));\n\t\treturn -EINVAL;\n\t}\n\n\tr = (struct vnic_resource __iomem *)(rh + 1);\n\n\twhile ((type = ioread8(&r->type)) != RES_TYPE_EOL) {\n\n\t\tu8 bar_num = ioread8(&r->bar);\n\t\tu32 bar_offset = ioread32(&r->bar_offset);\n\t\tu32 count = ioread32(&r->count);\n\t\tu32 len;\n\n\t\tr++;\n\n\t\tif (bar_num != 0)   \n\t\t\tcontinue;\n\n\t\tswitch (type) {\n\t\tcase RES_TYPE_WQ:\n\t\tcase RES_TYPE_RQ:\n\t\tcase RES_TYPE_CQ:\n\t\tcase RES_TYPE_INTR_CTRL:\n\t\t\t \n\t\t\tlen = count * VNIC_RES_STRIDE;\n\t\t\tif (len + bar_offset > bar->len) {\n\t\t\t\tprintk(KERN_ERR \"vNIC BAR0 resource %d \"\n\t\t\t\t\t\"out-of-bounds, offset 0x%x + \"\n\t\t\t\t\t\"size 0x%x > bar len 0x%lx\\n\",\n\t\t\t\t\ttype, bar_offset,\n\t\t\t\t\tlen,\n\t\t\t\t\tbar->len);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RES_TYPE_INTR_PBA_LEGACY:\n\t\tcase RES_TYPE_DEVCMD2:\n\t\tcase RES_TYPE_DEVCMD:\n\t\t\tlen = count;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tvdev->res[type].count = count;\n\t\tvdev->res[type].vaddr = (char __iomem *)bar->vaddr + bar_offset;\n\t}\n\n\treturn 0;\n}\n\nunsigned int vnic_dev_get_res_count(struct vnic_dev *vdev,\n\tenum vnic_res_type type)\n{\n\treturn vdev->res[type].count;\n}\n\nvoid __iomem *vnic_dev_get_res(struct vnic_dev *vdev, enum vnic_res_type type,\n\tunsigned int index)\n{\n\tif (!vdev->res[type].vaddr)\n\t\treturn NULL;\n\n\tswitch (type) {\n\tcase RES_TYPE_WQ:\n\tcase RES_TYPE_RQ:\n\tcase RES_TYPE_CQ:\n\tcase RES_TYPE_INTR_CTRL:\n\t\treturn (char __iomem *)vdev->res[type].vaddr +\n\t\t\t\t\tindex * VNIC_RES_STRIDE;\n\tdefault:\n\t\treturn (char __iomem *)vdev->res[type].vaddr;\n\t}\n}\n\nunsigned int vnic_dev_desc_ring_size(struct vnic_dev_ring *ring,\n\t\t\t\t     unsigned int desc_count,\n\t\t\t\t     unsigned int desc_size)\n{\n\t \n\n\tunsigned int count_align = 32;\n\tunsigned int desc_align = 16;\n\n\tring->base_align = 512;\n\n\tif (desc_count == 0)\n\t\tdesc_count = 4096;\n\n\tring->desc_count = ALIGN(desc_count, count_align);\n\n\tring->desc_size = ALIGN(desc_size, desc_align);\n\n\tring->size = ring->desc_count * ring->desc_size;\n\tring->size_unaligned = ring->size + ring->base_align;\n\n\treturn ring->size_unaligned;\n}\n\nvoid vnic_dev_clear_desc_ring(struct vnic_dev_ring *ring)\n{\n\tmemset(ring->descs, 0, ring->size);\n}\n\nint vnic_dev_alloc_desc_ring(struct vnic_dev *vdev, struct vnic_dev_ring *ring,\n\tunsigned int desc_count, unsigned int desc_size)\n{\n\tvnic_dev_desc_ring_size(ring, desc_count, desc_size);\n\n\tring->descs_unaligned = dma_alloc_coherent(&vdev->pdev->dev,\n\t\tring->size_unaligned,\n\t\t&ring->base_addr_unaligned, GFP_KERNEL);\n\n\tif (!ring->descs_unaligned) {\n\t\tprintk(KERN_ERR\n\t\t  \"Failed to allocate ring (size=%d), aborting\\n\",\n\t\t\t(int)ring->size);\n\t\treturn -ENOMEM;\n\t}\n\n\tring->base_addr = ALIGN(ring->base_addr_unaligned,\n\t\tring->base_align);\n\tring->descs = (u8 *)ring->descs_unaligned +\n\t\t(ring->base_addr - ring->base_addr_unaligned);\n\n\tvnic_dev_clear_desc_ring(ring);\n\n\tring->desc_avail = ring->desc_count - 1;\n\n\treturn 0;\n}\n\nvoid vnic_dev_free_desc_ring(struct vnic_dev *vdev, struct vnic_dev_ring *ring)\n{\n\tif (ring->descs) {\n\t\tdma_free_coherent(&vdev->pdev->dev,\n\t\t\tring->size_unaligned,\n\t\t\tring->descs_unaligned,\n\t\t\tring->base_addr_unaligned);\n\t\tring->descs = NULL;\n\t}\n}\n\nstatic int vnic_dev_cmd1(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd, int wait)\n{\n\tstruct vnic_devcmd __iomem *devcmd = vdev->devcmd;\n\tint delay;\n\tu32 status;\n\tstatic const int dev_cmd_err[] = {\n\t\t \n\t\t0,\t \n\t\tEINVAL,\t \n\t\tEFAULT,\t \n\t\tEPERM,\t \n\t\tEBUSY,   \n\t};\n\tint err;\n\tu64 *a0 = &vdev->args[0];\n\tu64 *a1 = &vdev->args[1];\n\n\tstatus = ioread32(&devcmd->status);\n\tif (status & STAT_BUSY) {\n\t\tprintk(KERN_ERR \"Busy devcmd %d\\n\", _CMD_N(cmd));\n\t\treturn -EBUSY;\n\t}\n\n\tif (_CMD_DIR(cmd) & _CMD_DIR_WRITE) {\n\t\twriteq(*a0, &devcmd->args[0]);\n\t\twriteq(*a1, &devcmd->args[1]);\n\t\twmb();\n\t}\n\n\tiowrite32(cmd, &devcmd->cmd);\n\n\tif ((_CMD_FLAGS(cmd) & _CMD_FLAGS_NOWAIT))\n\t\t\treturn 0;\n\n\tfor (delay = 0; delay < wait; delay++) {\n\n\t\tudelay(100);\n\n\t\tstatus = ioread32(&devcmd->status);\n\t\tif (!(status & STAT_BUSY)) {\n\n\t\t\tif (status & STAT_ERROR) {\n\t\t\t\terr = dev_cmd_err[(int)readq(&devcmd->args[0])];\n\t\t\t\tprintk(KERN_ERR \"Error %d devcmd %d\\n\",\n\t\t\t\t\terr, _CMD_N(cmd));\n\t\t\t\treturn -err;\n\t\t\t}\n\n\t\t\tif (_CMD_DIR(cmd) & _CMD_DIR_READ) {\n\t\t\t\trmb();\n\t\t\t\t*a0 = readq(&devcmd->args[0]);\n\t\t\t\t*a1 = readq(&devcmd->args[1]);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprintk(KERN_ERR \"Timedout devcmd %d\\n\", _CMD_N(cmd));\n\treturn -ETIMEDOUT;\n}\n\nstatic int vnic_dev_cmd2(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd,\n\t\tint wait)\n{\n\tstruct devcmd2_controller *dc2c = vdev->devcmd2;\n\tstruct devcmd2_result *result;\n\tu8 color;\n\tunsigned int i;\n\tint delay;\n\tint err;\n\tu32 fetch_index;\n\tu32 posted;\n\tu32 new_posted;\n\n\tposted = ioread32(&dc2c->wq_ctrl->posted_index);\n\tfetch_index = ioread32(&dc2c->wq_ctrl->fetch_index);\n\n\tif (posted == 0xFFFFFFFF || fetch_index == 0xFFFFFFFF) {\n\t\t \n\t\tpr_err(\"%s: devcmd2 invalid posted or fetch index on cmd %d\\n\",\n\t\t\t\tpci_name(vdev->pdev), _CMD_N(cmd));\n\t\tpr_err(\"%s: fetch index: %u, posted index: %u\\n\",\n\t\t\t\tpci_name(vdev->pdev), fetch_index, posted);\n\n\t\treturn -ENODEV;\n\n\t}\n\n\tnew_posted = (posted + 1) % DEVCMD2_RING_SIZE;\n\n\tif (new_posted == fetch_index) {\n\t\tpr_err(\"%s: devcmd2 wq full while issuing cmd %d\\n\",\n\t\t\t\tpci_name(vdev->pdev), _CMD_N(cmd));\n\t\tpr_err(\"%s: fetch index: %u, posted index: %u\\n\",\n\t\t\t\tpci_name(vdev->pdev), fetch_index, posted);\n\t\treturn -EBUSY;\n\n\t}\n\tdc2c->cmd_ring[posted].cmd = cmd;\n\tdc2c->cmd_ring[posted].flags = 0;\n\n\tif ((_CMD_FLAGS(cmd) & _CMD_FLAGS_NOWAIT))\n\t\tdc2c->cmd_ring[posted].flags |= DEVCMD2_FNORESULT;\n\tif (_CMD_DIR(cmd) & _CMD_DIR_WRITE) {\n\t\tfor (i = 0; i < VNIC_DEVCMD_NARGS; i++)\n\t\t\tdc2c->cmd_ring[posted].args[i] = vdev->args[i];\n\n\t}\n\n\t \n\twmb();\n\tiowrite32(new_posted, &dc2c->wq_ctrl->posted_index);\n\n\tif (dc2c->cmd_ring[posted].flags & DEVCMD2_FNORESULT)\n\t\treturn 0;\n\n\tresult = dc2c->result + dc2c->next_result;\n\tcolor = dc2c->color;\n\n\tdc2c->next_result++;\n\tif (dc2c->next_result == dc2c->result_size) {\n\t\tdc2c->next_result = 0;\n\t\tdc2c->color = dc2c->color ? 0 : 1;\n\t}\n\n\tfor (delay = 0; delay < wait; delay++) {\n\t\tudelay(100);\n\t\tif (result->color == color) {\n\t\t\tif (result->error) {\n\t\t\t\terr = -(int) result->error;\n\t\t\t\tif (err != ERR_ECMDUNKNOWN ||\n\t\t\t\t\t\tcmd != CMD_CAPABILITY)\n\t\t\t\t\tpr_err(\"%s:Error %d devcmd %d\\n\",\n\t\t\t\t\t\tpci_name(vdev->pdev),\n\t\t\t\t\t\terr, _CMD_N(cmd));\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (_CMD_DIR(cmd) & _CMD_DIR_READ) {\n\t\t\t\trmb();  \n\t\t\t\tfor (i = 0; i < VNIC_DEVCMD_NARGS; i++)\n\t\t\t\t\tvdev->args[i] = result->results[i];\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpr_err(\"%s:Timed out devcmd %d\\n\", pci_name(vdev->pdev), _CMD_N(cmd));\n\n\treturn -ETIMEDOUT;\n}\n\n\nstatic int vnic_dev_init_devcmd1(struct vnic_dev *vdev)\n{\n\tvdev->devcmd = vnic_dev_get_res(vdev, RES_TYPE_DEVCMD, 0);\n\tif (!vdev->devcmd)\n\t\treturn -ENODEV;\n\n\tvdev->devcmd_rtn = &vnic_dev_cmd1;\n\treturn 0;\n}\n\n\nstatic int vnic_dev_init_devcmd2(struct vnic_dev *vdev)\n{\n\tint err;\n\tunsigned int fetch_index;\n\n\tif (vdev->devcmd2)\n\t\treturn 0;\n\n\tvdev->devcmd2 = kzalloc(sizeof(*vdev->devcmd2), GFP_ATOMIC);\n\tif (!vdev->devcmd2)\n\t\treturn -ENOMEM;\n\n\tvdev->devcmd2->color = 1;\n\tvdev->devcmd2->result_size = DEVCMD2_RING_SIZE;\n\terr = vnic_wq_devcmd2_alloc(vdev, &vdev->devcmd2->wq,\n\t\t\t\tDEVCMD2_RING_SIZE, DEVCMD2_DESC_SIZE);\n\tif (err)\n\t\tgoto err_free_devcmd2;\n\n\tfetch_index = ioread32(&vdev->devcmd2->wq.ctrl->fetch_index);\n\tif (fetch_index == 0xFFFFFFFF) {  \n\t\tpr_err(\"error in devcmd2 init\");\n\t\terr = -ENODEV;\n\t\tgoto err_free_wq;\n\t}\n\n\t \n\tvnic_wq_init_start(&vdev->devcmd2->wq, 0, fetch_index,\n\t\t\tfetch_index, 0, 0);\n\n\tvnic_wq_enable(&vdev->devcmd2->wq);\n\n\terr = vnic_dev_alloc_desc_ring(vdev, &vdev->devcmd2->results_ring,\n\t\t\tDEVCMD2_RING_SIZE, DEVCMD2_DESC_SIZE);\n\tif (err)\n\t\tgoto err_disable_wq;\n\n\tvdev->devcmd2->result =\n\t\t(struct devcmd2_result *) vdev->devcmd2->results_ring.descs;\n\tvdev->devcmd2->cmd_ring =\n\t\t(struct vnic_devcmd2 *) vdev->devcmd2->wq.ring.descs;\n\tvdev->devcmd2->wq_ctrl = vdev->devcmd2->wq.ctrl;\n\tvdev->args[0] = (u64) vdev->devcmd2->results_ring.base_addr |\n\t\t\t\tVNIC_PADDR_TARGET;\n\tvdev->args[1] = DEVCMD2_RING_SIZE;\n\n\terr = vnic_dev_cmd2(vdev, CMD_INITIALIZE_DEVCMD2, 1000);\n\tif (err)\n\t\tgoto err_free_desc_ring;\n\n\tvdev->devcmd_rtn = &vnic_dev_cmd2;\n\n\treturn 0;\n\nerr_free_desc_ring:\n\tvnic_dev_free_desc_ring(vdev, &vdev->devcmd2->results_ring);\nerr_disable_wq:\n\tvnic_wq_disable(&vdev->devcmd2->wq);\nerr_free_wq:\n\tvnic_wq_free(&vdev->devcmd2->wq);\nerr_free_devcmd2:\n\tkfree(vdev->devcmd2);\n\tvdev->devcmd2 = NULL;\n\n\treturn err;\n}\n\n\nstatic void vnic_dev_deinit_devcmd2(struct vnic_dev *vdev)\n{\n\tvnic_dev_free_desc_ring(vdev, &vdev->devcmd2->results_ring);\n\tvnic_wq_disable(&vdev->devcmd2->wq);\n\tvnic_wq_free(&vdev->devcmd2->wq);\n\tkfree(vdev->devcmd2);\n\tvdev->devcmd2 = NULL;\n\tvdev->devcmd_rtn = &vnic_dev_cmd1;\n}\n\n\nstatic int vnic_dev_cmd_no_proxy(struct vnic_dev *vdev,\n\tenum vnic_devcmd_cmd cmd, u64 *a0, u64 *a1, int wait)\n{\n\tint err;\n\n\tvdev->args[0] = *a0;\n\tvdev->args[1] = *a1;\n\n\terr = (*vdev->devcmd_rtn)(vdev, cmd, wait);\n\n\t*a0 = vdev->args[0];\n\t*a1 = vdev->args[1];\n\n\treturn err;\n}\n\n\nint vnic_dev_cmd(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd,\n\tu64 *a0, u64 *a1, int wait)\n{\n\tmemset(vdev->args, 0, sizeof(vdev->args));\n\n\tswitch (vdev->proxy) {\n\tcase PROXY_NONE:\n\tdefault:\n\t\treturn vnic_dev_cmd_no_proxy(vdev, cmd, a0, a1, wait);\n\t}\n}\n\n\nint vnic_dev_fw_info(struct vnic_dev *vdev,\n\tstruct vnic_devcmd_fw_info **fw_info)\n{\n\tu64 a0, a1 = 0;\n\tint wait = 1000;\n\tint err = 0;\n\n\tif (!vdev->fw_info) {\n\t\tvdev->fw_info = dma_alloc_coherent(&vdev->pdev->dev,\n\t\t\tsizeof(struct vnic_devcmd_fw_info),\n\t\t\t&vdev->fw_info_pa, GFP_KERNEL);\n\t\tif (!vdev->fw_info)\n\t\t\treturn -ENOMEM;\n\n\t\ta0 = vdev->fw_info_pa;\n\n\t\t \n\t\terr = vnic_dev_cmd(vdev, CMD_MCPU_FW_INFO, &a0, &a1, wait);\n\t}\n\n\t*fw_info = vdev->fw_info;\n\n\treturn err;\n}\n\nint vnic_dev_spec(struct vnic_dev *vdev, unsigned int offset, unsigned int size,\n\tvoid *value)\n{\n\tu64 a0, a1;\n\tint wait = 1000;\n\tint err;\n\n\ta0 = offset;\n\ta1 = size;\n\n\terr = vnic_dev_cmd(vdev, CMD_DEV_SPEC, &a0, &a1, wait);\n\n\tswitch (size) {\n\tcase 1:\n\t\t*(u8 *)value = (u8)a0;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)value = (u16)a0;\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)value = (u32)a0;\n\t\tbreak;\n\tcase 8:\n\t\t*(u64 *)value = a0;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint vnic_dev_stats_clear(struct vnic_dev *vdev)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\treturn vnic_dev_cmd(vdev, CMD_STATS_CLEAR, &a0, &a1, wait);\n}\n\nint vnic_dev_stats_dump(struct vnic_dev *vdev, struct vnic_stats **stats)\n{\n\tu64 a0, a1;\n\tint wait = 1000;\n\n\tif (!vdev->stats) {\n\t\tvdev->stats = dma_alloc_coherent(&vdev->pdev->dev,\n\t\t\tsizeof(struct vnic_stats), &vdev->stats_pa, GFP_KERNEL);\n\t\tif (!vdev->stats)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t*stats = vdev->stats;\n\ta0 = vdev->stats_pa;\n\ta1 = sizeof(struct vnic_stats);\n\n\treturn vnic_dev_cmd(vdev, CMD_STATS_DUMP, &a0, &a1, wait);\n}\n\nint vnic_dev_close(struct vnic_dev *vdev)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\treturn vnic_dev_cmd(vdev, CMD_CLOSE, &a0, &a1, wait);\n}\n\nint vnic_dev_enable(struct vnic_dev *vdev)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\treturn vnic_dev_cmd(vdev, CMD_ENABLE, &a0, &a1, wait);\n}\n\nint vnic_dev_disable(struct vnic_dev *vdev)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\treturn vnic_dev_cmd(vdev, CMD_DISABLE, &a0, &a1, wait);\n}\n\nint vnic_dev_open(struct vnic_dev *vdev, int arg)\n{\n\tu64 a0 = (u32)arg, a1 = 0;\n\tint wait = 1000;\n\treturn vnic_dev_cmd(vdev, CMD_OPEN, &a0, &a1, wait);\n}\n\nint vnic_dev_open_done(struct vnic_dev *vdev, int *done)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\tint err;\n\n\t*done = 0;\n\n\terr = vnic_dev_cmd(vdev, CMD_OPEN_STATUS, &a0, &a1, wait);\n\tif (err)\n\t\treturn err;\n\n\t*done = (a0 == 0);\n\n\treturn 0;\n}\n\nint vnic_dev_soft_reset(struct vnic_dev *vdev, int arg)\n{\n\tu64 a0 = (u32)arg, a1 = 0;\n\tint wait = 1000;\n\treturn vnic_dev_cmd(vdev, CMD_SOFT_RESET, &a0, &a1, wait);\n}\n\nint vnic_dev_soft_reset_done(struct vnic_dev *vdev, int *done)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\tint err;\n\n\t*done = 0;\n\n\terr = vnic_dev_cmd(vdev, CMD_SOFT_RESET_STATUS, &a0, &a1, wait);\n\tif (err)\n\t\treturn err;\n\n\t*done = (a0 == 0);\n\n\treturn 0;\n}\n\nint vnic_dev_hang_notify(struct vnic_dev *vdev)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\treturn vnic_dev_cmd(vdev, CMD_HANG_NOTIFY, &a0, &a1, wait);\n}\n\nint vnic_dev_mac_addr(struct vnic_dev *vdev, u8 *mac_addr)\n{\n\tu64 a[2] = {};\n\tint wait = 1000;\n\tint err, i;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tmac_addr[i] = 0;\n\n\terr = vnic_dev_cmd(vdev, CMD_MAC_ADDR, &a[0], &a[1], wait);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tmac_addr[i] = ((u8 *)&a)[i];\n\n\treturn 0;\n}\n\nvoid vnic_dev_packet_filter(struct vnic_dev *vdev, int directed, int multicast,\n\tint broadcast, int promisc, int allmulti)\n{\n\tu64 a0, a1 = 0;\n\tint wait = 1000;\n\tint err;\n\n\ta0 = (directed ? CMD_PFILTER_DIRECTED : 0) |\n\t     (multicast ? CMD_PFILTER_MULTICAST : 0) |\n\t     (broadcast ? CMD_PFILTER_BROADCAST : 0) |\n\t     (promisc ? CMD_PFILTER_PROMISCUOUS : 0) |\n\t     (allmulti ? CMD_PFILTER_ALL_MULTICAST : 0);\n\n\terr = vnic_dev_cmd(vdev, CMD_PACKET_FILTER, &a0, &a1, wait);\n\tif (err)\n\t\tprintk(KERN_ERR \"Can't set packet filter\\n\");\n}\n\nvoid vnic_dev_add_addr(struct vnic_dev *vdev, u8 *addr)\n{\n\tu64 a[2] = {};\n\tint wait = 1000;\n\tint err;\n\tint i;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t((u8 *)&a)[i] = addr[i];\n\n\terr = vnic_dev_cmd(vdev, CMD_ADDR_ADD, &a[0], &a[1], wait);\n\tif (err)\n\t\tpr_err(\"Can't add addr [%pM], %d\\n\", addr, err);\n}\n\nvoid vnic_dev_del_addr(struct vnic_dev *vdev, u8 *addr)\n{\n\tu64 a[2] = {};\n\tint wait = 1000;\n\tint err;\n\tint i;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t((u8 *)&a)[i] = addr[i];\n\n\terr = vnic_dev_cmd(vdev, CMD_ADDR_DEL, &a[0], &a[1], wait);\n\tif (err)\n\t\tpr_err(\"Can't del addr [%pM], %d\\n\", addr, err);\n}\n\nint vnic_dev_notify_set(struct vnic_dev *vdev, u16 intr)\n{\n\tu64 a0, a1;\n\tint wait = 1000;\n\n\tif (!vdev->notify) {\n\t\tvdev->notify = dma_alloc_coherent(&vdev->pdev->dev,\n\t\t\tsizeof(struct vnic_devcmd_notify),\n\t\t\t&vdev->notify_pa, GFP_KERNEL);\n\t\tif (!vdev->notify)\n\t\t\treturn -ENOMEM;\n\t}\n\n\ta0 = vdev->notify_pa;\n\ta1 = ((u64)intr << 32) & 0x0000ffff00000000ULL;\n\ta1 += sizeof(struct vnic_devcmd_notify);\n\n\treturn vnic_dev_cmd(vdev, CMD_NOTIFY, &a0, &a1, wait);\n}\n\nvoid vnic_dev_notify_unset(struct vnic_dev *vdev)\n{\n\tu64 a0, a1;\n\tint wait = 1000;\n\n\ta0 = 0;   \n\ta1 = 0x0000ffff00000000ULL;  \n\ta1 += sizeof(struct vnic_devcmd_notify);\n\n\tvnic_dev_cmd(vdev, CMD_NOTIFY, &a0, &a1, wait);\n}\n\nstatic int vnic_dev_notify_ready(struct vnic_dev *vdev)\n{\n\tu32 *words;\n\tunsigned int nwords = sizeof(struct vnic_devcmd_notify) / 4;\n\tunsigned int i;\n\tu32 csum;\n\n\tif (!vdev->notify)\n\t\treturn 0;\n\n\tdo {\n\t\tcsum = 0;\n\t\tmemcpy(&vdev->notify_copy, vdev->notify,\n\t\t\tsizeof(struct vnic_devcmd_notify));\n\t\twords = (u32 *)&vdev->notify_copy;\n\t\tfor (i = 1; i < nwords; i++)\n\t\t\tcsum += words[i];\n\t} while (csum != words[0]);\n\n\treturn 1;\n}\n\nint vnic_dev_init(struct vnic_dev *vdev, int arg)\n{\n\tu64 a0 = (u32)arg, a1 = 0;\n\tint wait = 1000;\n\treturn vnic_dev_cmd(vdev, CMD_INIT, &a0, &a1, wait);\n}\n\nu16 vnic_dev_set_default_vlan(struct vnic_dev *vdev, u16 new_default_vlan)\n{\n\tu64 a0 = new_default_vlan, a1 = 0;\n\tint wait = 1000;\n\tint old_vlan = 0;\n\n\told_vlan = vnic_dev_cmd(vdev, CMD_SET_DEFAULT_VLAN, &a0, &a1, wait);\n\treturn (u16)old_vlan;\n}\n\nint vnic_dev_link_status(struct vnic_dev *vdev)\n{\n\tif (vdev->linkstatus)\n\t\treturn *vdev->linkstatus;\n\n\tif (!vnic_dev_notify_ready(vdev))\n\t\treturn 0;\n\n\treturn vdev->notify_copy.link_state;\n}\n\nu32 vnic_dev_port_speed(struct vnic_dev *vdev)\n{\n\tif (!vnic_dev_notify_ready(vdev))\n\t\treturn 0;\n\n\treturn vdev->notify_copy.port_speed;\n}\n\nu32 vnic_dev_msg_lvl(struct vnic_dev *vdev)\n{\n\tif (!vnic_dev_notify_ready(vdev))\n\t\treturn 0;\n\n\treturn vdev->notify_copy.msglvl;\n}\n\nu32 vnic_dev_mtu(struct vnic_dev *vdev)\n{\n\tif (!vnic_dev_notify_ready(vdev))\n\t\treturn 0;\n\n\treturn vdev->notify_copy.mtu;\n}\n\nu32 vnic_dev_link_down_cnt(struct vnic_dev *vdev)\n{\n\tif (!vnic_dev_notify_ready(vdev))\n\t\treturn 0;\n\n\treturn vdev->notify_copy.link_down_cnt;\n}\n\nvoid vnic_dev_set_intr_mode(struct vnic_dev *vdev,\n\tenum vnic_dev_intr_mode intr_mode)\n{\n\tvdev->intr_mode = intr_mode;\n}\n\nenum vnic_dev_intr_mode vnic_dev_get_intr_mode(\n\tstruct vnic_dev *vdev)\n{\n\treturn vdev->intr_mode;\n}\n\nvoid vnic_dev_unregister(struct vnic_dev *vdev)\n{\n\tif (vdev) {\n\t\tif (vdev->notify)\n\t\t\tdma_free_coherent(&vdev->pdev->dev,\n\t\t\t\tsizeof(struct vnic_devcmd_notify),\n\t\t\t\tvdev->notify,\n\t\t\t\tvdev->notify_pa);\n\t\tif (vdev->linkstatus)\n\t\t\tdma_free_coherent(&vdev->pdev->dev,\n\t\t\t\tsizeof(u32),\n\t\t\t\tvdev->linkstatus,\n\t\t\t\tvdev->linkstatus_pa);\n\t\tif (vdev->stats)\n\t\t\tdma_free_coherent(&vdev->pdev->dev,\n\t\t\t\tsizeof(struct vnic_stats),\n\t\t\t\tvdev->stats, vdev->stats_pa);\n\t\tif (vdev->fw_info)\n\t\t\tdma_free_coherent(&vdev->pdev->dev,\n\t\t\t\tsizeof(struct vnic_devcmd_fw_info),\n\t\t\t\tvdev->fw_info, vdev->fw_info_pa);\n\t\tif (vdev->devcmd2)\n\t\t\tvnic_dev_deinit_devcmd2(vdev);\n\t\tkfree(vdev);\n\t}\n}\n\nstruct vnic_dev *vnic_dev_register(struct vnic_dev *vdev,\n\tvoid *priv, struct pci_dev *pdev, struct vnic_dev_bar *bar)\n{\n\tif (!vdev) {\n\t\tvdev = kzalloc(sizeof(struct vnic_dev), GFP_KERNEL);\n\t\tif (!vdev)\n\t\t\treturn NULL;\n\t}\n\n\tvdev->priv = priv;\n\tvdev->pdev = pdev;\n\n\tif (vnic_dev_discover_res(vdev, bar))\n\t\tgoto err_out;\n\n\treturn vdev;\n\nerr_out:\n\tvnic_dev_unregister(vdev);\n\treturn NULL;\n}\n\nint vnic_dev_cmd_init(struct vnic_dev *vdev)\n{\n\tint err;\n\tvoid *p;\n\n\tp = vnic_dev_get_res(vdev, RES_TYPE_DEVCMD2, 0);\n\tif (p) {\n\t\tpr_err(\"fnic: DEVCMD2 resource found!\\n\");\n\t\terr = vnic_dev_init_devcmd2(vdev);\n\t} else {\n\t\tpr_err(\"fnic: DEVCMD2 not found, fall back to Devcmd\\n\");\n\t\terr = vnic_dev_init_devcmd1(vdev);\n\t}\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}