{
  "module_name": "fnic_scsi.c",
  "hash_id": "00320997e13b41cc9c4bf23f7ca01961150ba049cfa97b4f8f8e90ccc16a11a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/fnic/fnic_scsi.c",
  "human_readable_source": "\n \n#include <linux/mempool.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/workqueue.h>\n#include <linux/pci.h>\n#include <linux/scatterlist.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/fc/fc_els.h>\n#include <scsi/fc/fc_fcoe.h>\n#include <scsi/libfc.h>\n#include <scsi/fc_frame.h>\n#include \"fnic_io.h\"\n#include \"fnic.h\"\n\nconst char *fnic_state_str[] = {\n\t[FNIC_IN_FC_MODE] =           \"FNIC_IN_FC_MODE\",\n\t[FNIC_IN_FC_TRANS_ETH_MODE] = \"FNIC_IN_FC_TRANS_ETH_MODE\",\n\t[FNIC_IN_ETH_MODE] =          \"FNIC_IN_ETH_MODE\",\n\t[FNIC_IN_ETH_TRANS_FC_MODE] = \"FNIC_IN_ETH_TRANS_FC_MODE\",\n};\n\nstatic const char *fnic_ioreq_state_str[] = {\n\t[FNIC_IOREQ_NOT_INITED] = \"FNIC_IOREQ_NOT_INITED\",\n\t[FNIC_IOREQ_CMD_PENDING] = \"FNIC_IOREQ_CMD_PENDING\",\n\t[FNIC_IOREQ_ABTS_PENDING] = \"FNIC_IOREQ_ABTS_PENDING\",\n\t[FNIC_IOREQ_ABTS_COMPLETE] = \"FNIC_IOREQ_ABTS_COMPLETE\",\n\t[FNIC_IOREQ_CMD_COMPLETE] = \"FNIC_IOREQ_CMD_COMPLETE\",\n};\n\nstatic const char *fcpio_status_str[] =  {\n\t[FCPIO_SUCCESS] = \"FCPIO_SUCCESS\",  \n\t[FCPIO_INVALID_HEADER] = \"FCPIO_INVALID_HEADER\",\n\t[FCPIO_OUT_OF_RESOURCE] = \"FCPIO_OUT_OF_RESOURCE\",\n\t[FCPIO_INVALID_PARAM] = \"FCPIO_INVALID_PARAM]\",\n\t[FCPIO_REQ_NOT_SUPPORTED] = \"FCPIO_REQ_NOT_SUPPORTED\",\n\t[FCPIO_IO_NOT_FOUND] = \"FCPIO_IO_NOT_FOUND\",\n\t[FCPIO_ABORTED] = \"FCPIO_ABORTED\",  \n\t[FCPIO_TIMEOUT] = \"FCPIO_TIMEOUT\",\n\t[FCPIO_SGL_INVALID] = \"FCPIO_SGL_INVALID\",\n\t[FCPIO_MSS_INVALID] = \"FCPIO_MSS_INVALID\",\n\t[FCPIO_DATA_CNT_MISMATCH] = \"FCPIO_DATA_CNT_MISMATCH\",\n\t[FCPIO_FW_ERR] = \"FCPIO_FW_ERR\",\n\t[FCPIO_ITMF_REJECTED] = \"FCPIO_ITMF_REJECTED\",\n\t[FCPIO_ITMF_FAILED] = \"FCPIO_ITMF_FAILED\",\n\t[FCPIO_ITMF_INCORRECT_LUN] = \"FCPIO_ITMF_INCORRECT_LUN\",\n\t[FCPIO_CMND_REJECTED] = \"FCPIO_CMND_REJECTED\",\n\t[FCPIO_NO_PATH_AVAIL] = \"FCPIO_NO_PATH_AVAIL\",\n\t[FCPIO_PATH_FAILED] = \"FCPIO_PATH_FAILED\",\n\t[FCPIO_LUNMAP_CHNG_PEND] = \"FCPIO_LUNHMAP_CHNG_PEND\",\n};\n\nconst char *fnic_state_to_str(unsigned int state)\n{\n\tif (state >= ARRAY_SIZE(fnic_state_str) || !fnic_state_str[state])\n\t\treturn \"unknown\";\n\n\treturn fnic_state_str[state];\n}\n\nstatic const char *fnic_ioreq_state_to_str(unsigned int state)\n{\n\tif (state >= ARRAY_SIZE(fnic_ioreq_state_str) ||\n\t    !fnic_ioreq_state_str[state])\n\t\treturn \"unknown\";\n\n\treturn fnic_ioreq_state_str[state];\n}\n\nstatic const char *fnic_fcpio_status_to_str(unsigned int status)\n{\n\tif (status >= ARRAY_SIZE(fcpio_status_str) || !fcpio_status_str[status])\n\t\treturn \"unknown\";\n\n\treturn fcpio_status_str[status];\n}\n\nstatic void fnic_cleanup_io(struct fnic *fnic);\n\nstatic inline spinlock_t *fnic_io_lock_hash(struct fnic *fnic,\n\t\t\t\t\t    struct scsi_cmnd *sc)\n{\n\tu32 hash = scsi_cmd_to_rq(sc)->tag & (FNIC_IO_LOCKS - 1);\n\n\treturn &fnic->io_req_lock[hash];\n}\n\nstatic inline spinlock_t *fnic_io_lock_tag(struct fnic *fnic,\n\t\t\t\t\t    int tag)\n{\n\treturn &fnic->io_req_lock[tag & (FNIC_IO_LOCKS - 1)];\n}\n\n \nstatic void fnic_release_ioreq_buf(struct fnic *fnic,\n\t\t\t\t   struct fnic_io_req *io_req,\n\t\t\t\t   struct scsi_cmnd *sc)\n{\n\tif (io_req->sgl_list_pa)\n\t\tdma_unmap_single(&fnic->pdev->dev, io_req->sgl_list_pa,\n\t\t\t\t sizeof(io_req->sgl_list[0]) * io_req->sgl_cnt,\n\t\t\t\t DMA_TO_DEVICE);\n\tscsi_dma_unmap(sc);\n\n\tif (io_req->sgl_cnt)\n\t\tmempool_free(io_req->sgl_list_alloc,\n\t\t\t     fnic->io_sgl_pool[io_req->sgl_type]);\n\tif (io_req->sense_buf_pa)\n\t\tdma_unmap_single(&fnic->pdev->dev, io_req->sense_buf_pa,\n\t\t\t\t SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\n}\n\n \nstatic int free_wq_copy_descs(struct fnic *fnic, struct vnic_wq_copy *wq)\n{\n\t \n\tif (!fnic->fw_ack_recd[0])\n\t\treturn 1;\n\n\t \n\tif (wq->to_clean_index <= fnic->fw_ack_index[0])\n\t\twq->ring.desc_avail += (fnic->fw_ack_index[0]\n\t\t\t\t\t- wq->to_clean_index + 1);\n\telse\n\t\twq->ring.desc_avail += (wq->ring.desc_count\n\t\t\t\t\t- wq->to_clean_index\n\t\t\t\t\t+ fnic->fw_ack_index[0] + 1);\n\n\t \n\twq->to_clean_index =\n\t\t(fnic->fw_ack_index[0] + 1) % wq->ring.desc_count;\n\n\t \n\tfnic->fw_ack_recd[0] = 0;\n\treturn 0;\n}\n\n\n \nvoid\n__fnic_set_state_flags(struct fnic *fnic, unsigned long st_flags,\n\t\t\tunsigned long clearbits)\n{\n\tunsigned long flags = 0;\n\tunsigned long host_lock_flags = 0;\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tspin_lock_irqsave(fnic->lport->host->host_lock, host_lock_flags);\n\n\tif (clearbits)\n\t\tfnic->state_flags &= ~st_flags;\n\telse\n\t\tfnic->state_flags |= st_flags;\n\n\tspin_unlock_irqrestore(fnic->lport->host->host_lock, host_lock_flags);\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\treturn;\n}\n\n\n \nint fnic_fw_reset_handler(struct fnic *fnic)\n{\n\tstruct vnic_wq_copy *wq = &fnic->wq_copy[0];\n\tint ret = 0;\n\tunsigned long flags;\n\n\t \n\tfnic_set_state_flags(fnic, FNIC_FLAGS_FWRESET);\n\n\tskb_queue_purge(&fnic->frame_queue);\n\tskb_queue_purge(&fnic->tx_queue);\n\n\t \n\twhile (atomic_read(&fnic->in_flight))\n\t\tschedule_timeout(msecs_to_jiffies(1));\n\n\tspin_lock_irqsave(&fnic->wq_copy_lock[0], flags);\n\n\tif (vnic_wq_copy_desc_avail(wq) <= fnic->wq_copy_desc_low[0])\n\t\tfree_wq_copy_descs(fnic, wq);\n\n\tif (!vnic_wq_copy_desc_avail(wq))\n\t\tret = -EAGAIN;\n\telse {\n\t\tfnic_queue_wq_copy_desc_fw_reset(wq, SCSI_NO_TAG);\n\t\tatomic64_inc(&fnic->fnic_stats.fw_stats.active_fw_reqs);\n\t\tif (atomic64_read(&fnic->fnic_stats.fw_stats.active_fw_reqs) >\n\t\t\t  atomic64_read(&fnic->fnic_stats.fw_stats.max_fw_reqs))\n\t\t\tatomic64_set(&fnic->fnic_stats.fw_stats.max_fw_reqs,\n\t\t\t\tatomic64_read(\n\t\t\t\t  &fnic->fnic_stats.fw_stats.active_fw_reqs));\n\t}\n\n\tspin_unlock_irqrestore(&fnic->wq_copy_lock[0], flags);\n\n\tif (!ret) {\n\t\tatomic64_inc(&fnic->fnic_stats.reset_stats.fw_resets);\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t      \"Issued fw reset\\n\");\n\t} else {\n\t\tfnic_clear_state_flags(fnic, FNIC_FLAGS_FWRESET);\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t      \"Failed to issue fw reset\\n\");\n\t}\n\n\treturn ret;\n}\n\n\n \nint fnic_flogi_reg_handler(struct fnic *fnic, u32 fc_id)\n{\n\tstruct vnic_wq_copy *wq = &fnic->wq_copy[0];\n\tenum fcpio_flogi_reg_format_type format;\n\tstruct fc_lport *lp = fnic->lport;\n\tu8 gw_mac[ETH_ALEN];\n\tint ret = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fnic->wq_copy_lock[0], flags);\n\n\tif (vnic_wq_copy_desc_avail(wq) <= fnic->wq_copy_desc_low[0])\n\t\tfree_wq_copy_descs(fnic, wq);\n\n\tif (!vnic_wq_copy_desc_avail(wq)) {\n\t\tret = -EAGAIN;\n\t\tgoto flogi_reg_ioreq_end;\n\t}\n\n\tif (fnic->ctlr.map_dest) {\n\t\teth_broadcast_addr(gw_mac);\n\t\tformat = FCPIO_FLOGI_REG_DEF_DEST;\n\t} else {\n\t\tmemcpy(gw_mac, fnic->ctlr.dest_addr, ETH_ALEN);\n\t\tformat = FCPIO_FLOGI_REG_GW_DEST;\n\t}\n\n\tif ((fnic->config.flags & VFCF_FIP_CAPABLE) && !fnic->ctlr.map_dest) {\n\t\tfnic_queue_wq_copy_desc_fip_reg(wq, SCSI_NO_TAG,\n\t\t\t\t\t\tfc_id, gw_mac,\n\t\t\t\t\t\tfnic->data_src_addr,\n\t\t\t\t\t\tlp->r_a_tov, lp->e_d_tov);\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t      \"FLOGI FIP reg issued fcid %x src %pM dest %pM\\n\",\n\t\t\t      fc_id, fnic->data_src_addr, gw_mac);\n\t} else {\n\t\tfnic_queue_wq_copy_desc_flogi_reg(wq, SCSI_NO_TAG,\n\t\t\t\t\t\t  format, fc_id, gw_mac);\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t      \"FLOGI reg issued fcid %x map %d dest %pM\\n\",\n\t\t\t      fc_id, fnic->ctlr.map_dest, gw_mac);\n\t}\n\n\tatomic64_inc(&fnic->fnic_stats.fw_stats.active_fw_reqs);\n\tif (atomic64_read(&fnic->fnic_stats.fw_stats.active_fw_reqs) >\n\t\t  atomic64_read(&fnic->fnic_stats.fw_stats.max_fw_reqs))\n\t\tatomic64_set(&fnic->fnic_stats.fw_stats.max_fw_reqs,\n\t\t  atomic64_read(&fnic->fnic_stats.fw_stats.active_fw_reqs));\n\nflogi_reg_ioreq_end:\n\tspin_unlock_irqrestore(&fnic->wq_copy_lock[0], flags);\n\treturn ret;\n}\n\n \nstatic inline int fnic_queue_wq_copy_desc(struct fnic *fnic,\n\t\t\t\t\t  struct vnic_wq_copy *wq,\n\t\t\t\t\t  struct fnic_io_req *io_req,\n\t\t\t\t\t  struct scsi_cmnd *sc,\n\t\t\t\t\t  int sg_count)\n{\n\tstruct scatterlist *sg;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sc->device));\n\tstruct fc_rport_libfc_priv *rp = rport->dd_data;\n\tstruct host_sg_desc *desc;\n\tstruct misc_stats *misc_stats = &fnic->fnic_stats.misc_stats;\n\tunsigned int i;\n\tunsigned long intr_flags;\n\tint flags;\n\tu8 exch_flags;\n\tstruct scsi_lun fc_lun;\n\n\tif (sg_count) {\n\t\t \n\t\tdesc = io_req->sgl_list;\n\t\tfor_each_sg(scsi_sglist(sc), sg, sg_count, i) {\n\t\t\tdesc->addr = cpu_to_le64(sg_dma_address(sg));\n\t\t\tdesc->len = cpu_to_le32(sg_dma_len(sg));\n\t\t\tdesc->_resvd = 0;\n\t\t\tdesc++;\n\t\t}\n\n\t\tio_req->sgl_list_pa = dma_map_single(&fnic->pdev->dev,\n\t\t\t\tio_req->sgl_list,\n\t\t\t\tsizeof(io_req->sgl_list[0]) * sg_count,\n\t\t\t\tDMA_TO_DEVICE);\n\t\tif (dma_mapping_error(&fnic->pdev->dev, io_req->sgl_list_pa)) {\n\t\t\tprintk(KERN_ERR \"DMA mapping failed\\n\");\n\t\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t\t}\n\t}\n\n\tio_req->sense_buf_pa = dma_map_single(&fnic->pdev->dev,\n\t\t\t\t\t      sc->sense_buffer,\n\t\t\t\t\t      SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t\t      DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&fnic->pdev->dev, io_req->sense_buf_pa)) {\n\t\tdma_unmap_single(&fnic->pdev->dev, io_req->sgl_list_pa,\n\t\t\t\tsizeof(io_req->sgl_list[0]) * sg_count,\n\t\t\t\tDMA_TO_DEVICE);\n\t\tprintk(KERN_ERR \"DMA mapping failed\\n\");\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tint_to_scsilun(sc->device->lun, &fc_lun);\n\n\t \n\tspin_lock_irqsave(&fnic->wq_copy_lock[0], intr_flags);\n\n\tif (vnic_wq_copy_desc_avail(wq) <= fnic->wq_copy_desc_low[0])\n\t\tfree_wq_copy_descs(fnic, wq);\n\n\tif (unlikely(!vnic_wq_copy_desc_avail(wq))) {\n\t\tspin_unlock_irqrestore(&fnic->wq_copy_lock[0], intr_flags);\n\t\tFNIC_SCSI_DBG(KERN_INFO, fnic->lport->host,\n\t\t\t  \"fnic_queue_wq_copy_desc failure - no descriptors\\n\");\n\t\tatomic64_inc(&misc_stats->io_cpwq_alloc_failures);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tflags = 0;\n\tif (sc->sc_data_direction == DMA_FROM_DEVICE)\n\t\tflags = FCPIO_ICMND_RDDATA;\n\telse if (sc->sc_data_direction == DMA_TO_DEVICE)\n\t\tflags = FCPIO_ICMND_WRDATA;\n\n\texch_flags = 0;\n\tif ((fnic->config.flags & VFCF_FCP_SEQ_LVL_ERR) &&\n\t    (rp->flags & FC_RP_FLAGS_RETRY))\n\t\texch_flags |= FCPIO_ICMND_SRFLAG_RETRY;\n\n\tfnic_queue_wq_copy_desc_icmnd_16(wq, scsi_cmd_to_rq(sc)->tag,\n\t\t\t\t\t 0, exch_flags, io_req->sgl_cnt,\n\t\t\t\t\t SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t\t io_req->sgl_list_pa,\n\t\t\t\t\t io_req->sense_buf_pa,\n\t\t\t\t\t 0,  \n\t\t\t\t\t FCPIO_ICMND_PTA_SIMPLE,\n\t\t\t\t\t \t \n\t\t\t\t\t flags,\t \n\t\t\t\t\t sc->cmnd, sc->cmd_len,\n\t\t\t\t\t scsi_bufflen(sc),\n\t\t\t\t\t fc_lun.scsi_lun, io_req->port_id,\n\t\t\t\t\t rport->maxframe_size, rp->r_a_tov,\n\t\t\t\t\t rp->e_d_tov);\n\n\tatomic64_inc(&fnic->fnic_stats.fw_stats.active_fw_reqs);\n\tif (atomic64_read(&fnic->fnic_stats.fw_stats.active_fw_reqs) >\n\t\t  atomic64_read(&fnic->fnic_stats.fw_stats.max_fw_reqs))\n\t\tatomic64_set(&fnic->fnic_stats.fw_stats.max_fw_reqs,\n\t\t  atomic64_read(&fnic->fnic_stats.fw_stats.active_fw_reqs));\n\n\tspin_unlock_irqrestore(&fnic->wq_copy_lock[0], intr_flags);\n\treturn 0;\n}\n\n \nstatic int fnic_queuecommand_lck(struct scsi_cmnd *sc)\n{\n\tvoid (*done)(struct scsi_cmnd *) = scsi_done;\n\tconst int tag = scsi_cmd_to_rq(sc)->tag;\n\tstruct fc_lport *lp = shost_priv(sc->device->host);\n\tstruct fc_rport *rport;\n\tstruct fnic_io_req *io_req = NULL;\n\tstruct fnic *fnic = lport_priv(lp);\n\tstruct fnic_stats *fnic_stats = &fnic->fnic_stats;\n\tstruct vnic_wq_copy *wq;\n\tint ret;\n\tu64 cmd_trace;\n\tint sg_count = 0;\n\tunsigned long flags = 0;\n\tunsigned long ptr;\n\tspinlock_t *io_lock = NULL;\n\tint io_lock_acquired = 0;\n\tstruct fc_rport_libfc_priv *rp;\n\n\tif (unlikely(fnic_chk_state_flags_locked(fnic, FNIC_FLAGS_IO_BLOCKED)))\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tif (unlikely(fnic_chk_state_flags_locked(fnic, FNIC_FLAGS_FWRESET)))\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\trport = starget_to_rport(scsi_target(sc->device));\n\tif (!rport) {\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t\"returning DID_NO_CONNECT for IO as rport is NULL\\n\");\n\t\tsc->result = DID_NO_CONNECT << 16;\n\t\tdone(sc);\n\t\treturn 0;\n\t}\n\n\tret = fc_remote_port_chkready(rport);\n\tif (ret) {\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t\"rport is not ready\\n\");\n\t\tatomic64_inc(&fnic_stats->misc_stats.rport_not_ready);\n\t\tsc->result = ret;\n\t\tdone(sc);\n\t\treturn 0;\n\t}\n\n\trp = rport->dd_data;\n\tif (!rp || rp->rp_state == RPORT_ST_DELETE) {\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\"rport 0x%x removed, returning DID_NO_CONNECT\\n\",\n\t\t\trport->port_id);\n\n\t\tatomic64_inc(&fnic_stats->misc_stats.rport_not_ready);\n\t\tsc->result = DID_NO_CONNECT<<16;\n\t\tdone(sc);\n\t\treturn 0;\n\t}\n\n\tif (rp->rp_state != RPORT_ST_READY) {\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\"rport 0x%x in state 0x%x, returning DID_IMM_RETRY\\n\",\n\t\t\trport->port_id, rp->rp_state);\n\n\t\tsc->result = DID_IMM_RETRY << 16;\n\t\tdone(sc);\n\t\treturn 0;\n\t}\n\n\tif (lp->state != LPORT_ST_READY || !(lp->link_up))\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tatomic_inc(&fnic->in_flight);\n\n\t \n\tspin_unlock(lp->host->host_lock);\n\tfnic_priv(sc)->state = FNIC_IOREQ_NOT_INITED;\n\tfnic_priv(sc)->flags = FNIC_NO_FLAGS;\n\n\t \n\tio_req = mempool_alloc(fnic->io_req_pool, GFP_ATOMIC);\n\tif (!io_req) {\n\t\tatomic64_inc(&fnic_stats->io_stats.alloc_failures);\n\t\tret = SCSI_MLQUEUE_HOST_BUSY;\n\t\tgoto out;\n\t}\n\tmemset(io_req, 0, sizeof(*io_req));\n\n\t \n\tsg_count = scsi_dma_map(sc);\n\tif (sg_count < 0) {\n\t\tFNIC_TRACE(fnic_queuecommand, sc->device->host->host_no,\n\t\t\t  tag, sc, 0, sc->cmnd[0], sg_count, fnic_priv(sc)->state);\n\t\tmempool_free(io_req, fnic->io_req_pool);\n\t\tgoto out;\n\t}\n\n\t \n\tio_req->sgl_cnt = sg_count;\n\tio_req->sgl_type = FNIC_SGL_CACHE_DFLT;\n\tif (sg_count > FNIC_DFLT_SG_DESC_CNT)\n\t\tio_req->sgl_type = FNIC_SGL_CACHE_MAX;\n\n\tif (sg_count) {\n\t\tio_req->sgl_list =\n\t\t\tmempool_alloc(fnic->io_sgl_pool[io_req->sgl_type],\n\t\t\t\t      GFP_ATOMIC);\n\t\tif (!io_req->sgl_list) {\n\t\t\tatomic64_inc(&fnic_stats->io_stats.alloc_failures);\n\t\t\tret = SCSI_MLQUEUE_HOST_BUSY;\n\t\t\tscsi_dma_unmap(sc);\n\t\t\tmempool_free(io_req, fnic->io_req_pool);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tio_req->sgl_list_alloc = io_req->sgl_list;\n\t\tptr = (unsigned long) io_req->sgl_list;\n\t\tif (ptr % FNIC_SG_DESC_ALIGN) {\n\t\t\tio_req->sgl_list = (struct host_sg_desc *)\n\t\t\t\t(((unsigned long) ptr\n\t\t\t\t  + FNIC_SG_DESC_ALIGN - 1)\n\t\t\t\t & ~(FNIC_SG_DESC_ALIGN - 1));\n\t\t}\n\t}\n\n\t \n\n\tio_lock = fnic_io_lock_hash(fnic, sc);\n\tspin_lock_irqsave(io_lock, flags);\n\n\t \n\tio_lock_acquired = 1;\n\tio_req->port_id = rport->port_id;\n\tio_req->start_time = jiffies;\n\tfnic_priv(sc)->state = FNIC_IOREQ_CMD_PENDING;\n\tfnic_priv(sc)->io_req = io_req;\n\tfnic_priv(sc)->flags |= FNIC_IO_INITIALIZED;\n\n\t \n\twq = &fnic->wq_copy[0];\n\tret = fnic_queue_wq_copy_desc(fnic, wq, io_req, sc, sg_count);\n\tif (ret) {\n\t\t \n\t\tFNIC_TRACE(fnic_queuecommand, sc->device->host->host_no,\n\t\t\t  tag, sc, 0, 0, 0, fnic_flags_and_state(sc));\n\t\tio_req = fnic_priv(sc)->io_req;\n\t\tfnic_priv(sc)->io_req = NULL;\n\t\tfnic_priv(sc)->state = FNIC_IOREQ_CMD_COMPLETE;\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tif (io_req) {\n\t\t\tfnic_release_ioreq_buf(fnic, io_req, sc);\n\t\t\tmempool_free(io_req, fnic->io_req_pool);\n\t\t}\n\t\tatomic_dec(&fnic->in_flight);\n\t\t \n\t\tspin_lock(lp->host->host_lock);\n\t\treturn ret;\n\t} else {\n\t\tatomic64_inc(&fnic_stats->io_stats.active_ios);\n\t\tatomic64_inc(&fnic_stats->io_stats.num_ios);\n\t\tif (atomic64_read(&fnic_stats->io_stats.active_ios) >\n\t\t\t  atomic64_read(&fnic_stats->io_stats.max_active_ios))\n\t\t\tatomic64_set(&fnic_stats->io_stats.max_active_ios,\n\t\t\t     atomic64_read(&fnic_stats->io_stats.active_ios));\n\n\t\t \n\t\tfnic_priv(sc)->flags |= FNIC_IO_ISSUED;\n\t}\nout:\n\tcmd_trace = ((u64)sc->cmnd[0] << 56 | (u64)sc->cmnd[7] << 40 |\n\t\t\t(u64)sc->cmnd[8] << 32 | (u64)sc->cmnd[2] << 24 |\n\t\t\t(u64)sc->cmnd[3] << 16 | (u64)sc->cmnd[4] << 8 |\n\t\t\tsc->cmnd[5]);\n\n\tFNIC_TRACE(fnic_queuecommand, sc->device->host->host_no,\n\t\t   tag, sc, io_req, sg_count, cmd_trace,\n\t\t   fnic_flags_and_state(sc));\n\n\t \n\tif (io_lock_acquired)\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\tatomic_dec(&fnic->in_flight);\n\t \n\tspin_lock(lp->host->host_lock);\n\treturn ret;\n}\n\nDEF_SCSI_QCMD(fnic_queuecommand)\n\n \nstatic int fnic_fcpio_fw_reset_cmpl_handler(struct fnic *fnic,\n\t\t\t\t\t    struct fcpio_fw_req *desc)\n{\n\tu8 type;\n\tu8 hdr_status;\n\tstruct fcpio_tag tag;\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct reset_stats *reset_stats = &fnic->fnic_stats.reset_stats;\n\n\tfcpio_header_dec(&desc->hdr, &type, &hdr_status, &tag);\n\n\tatomic64_inc(&reset_stats->fw_reset_completions);\n\n\t \n\tfnic_cleanup_io(fnic);\n\n\tatomic64_set(&fnic->fnic_stats.fw_stats.active_fw_reqs, 0);\n\tatomic64_set(&fnic->fnic_stats.io_stats.active_ios, 0);\n\tatomic64_set(&fnic->io_cmpl_skip, 0);\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\n\t \n\tif (fnic->state == FNIC_IN_FC_TRANS_ETH_MODE) {\n\t\t \n\t\tif (!hdr_status) {\n\t\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t      \"reset cmpl success\\n\");\n\t\t\t \n\t\t\tfnic->state = FNIC_IN_ETH_MODE;\n\t\t} else {\n\t\t\tFNIC_SCSI_DBG(KERN_DEBUG,\n\t\t\t\t      fnic->lport->host,\n\t\t\t\t      \"fnic fw_reset : failed %s\\n\",\n\t\t\t\t      fnic_fcpio_status_to_str(hdr_status));\n\n\t\t\t \n\t\t\tfnic->state = FNIC_IN_FC_MODE;\n\t\t\tatomic64_inc(&reset_stats->fw_reset_failures);\n\t\t\tret = -1;\n\t\t}\n\t} else {\n\t\tFNIC_SCSI_DBG(KERN_DEBUG,\n\t\t\t      fnic->lport->host,\n\t\t\t      \"Unexpected state %s while processing\"\n\t\t\t      \" reset cmpl\\n\", fnic_state_to_str(fnic->state));\n\t\tatomic64_inc(&reset_stats->fw_reset_failures);\n\t\tret = -1;\n\t}\n\n\t \n\tif (fnic->remove_wait)\n\t\tcomplete(fnic->remove_wait);\n\n\t \n\tif (fnic->remove_wait || ret) {\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\tskb_queue_purge(&fnic->tx_queue);\n\t\tgoto reset_cmpl_handler_end;\n\t}\n\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\tfnic_flush_tx(fnic);\n\n reset_cmpl_handler_end:\n\tfnic_clear_state_flags(fnic, FNIC_FLAGS_FWRESET);\n\n\treturn ret;\n}\n\n \nstatic int fnic_fcpio_flogi_reg_cmpl_handler(struct fnic *fnic,\n\t\t\t\t\t     struct fcpio_fw_req *desc)\n{\n\tu8 type;\n\tu8 hdr_status;\n\tstruct fcpio_tag tag;\n\tint ret = 0;\n\tunsigned long flags;\n\n\tfcpio_header_dec(&desc->hdr, &type, &hdr_status, &tag);\n\n\t \n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\n\tif (fnic->state == FNIC_IN_ETH_TRANS_FC_MODE) {\n\n\t\t \n\t\tif (!hdr_status) {\n\t\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t      \"flog reg succeeded\\n\");\n\t\t\tfnic->state = FNIC_IN_FC_MODE;\n\t\t} else {\n\t\t\tFNIC_SCSI_DBG(KERN_DEBUG,\n\t\t\t\t      fnic->lport->host,\n\t\t\t\t      \"fnic flogi reg :failed %s\\n\",\n\t\t\t\t      fnic_fcpio_status_to_str(hdr_status));\n\t\t\tfnic->state = FNIC_IN_ETH_MODE;\n\t\t\tret = -1;\n\t\t}\n\t} else {\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t      \"Unexpected fnic state %s while\"\n\t\t\t      \" processing flogi reg completion\\n\",\n\t\t\t      fnic_state_to_str(fnic->state));\n\t\tret = -1;\n\t}\n\n\tif (!ret) {\n\t\tif (fnic->stop_rx_link_events) {\n\t\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\t\tgoto reg_cmpl_handler_end;\n\t\t}\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\t\tfnic_flush_tx(fnic);\n\t\tqueue_work(fnic_event_queue, &fnic->frame_work);\n\t} else {\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t}\n\nreg_cmpl_handler_end:\n\treturn ret;\n}\n\nstatic inline int is_ack_index_in_range(struct vnic_wq_copy *wq,\n\t\t\t\t\tu16 request_out)\n{\n\tif (wq->to_clean_index <= wq->to_use_index) {\n\t\t \n\t\tif (request_out < wq->to_clean_index ||\n\t\t    request_out >= wq->to_use_index)\n\t\t\treturn 0;\n\t} else {\n\t\t \n\t\tif (request_out < wq->to_clean_index &&\n\t\t    request_out >= wq->to_use_index)\n\t\t\treturn 0;\n\t}\n\t \n\treturn 1;\n}\n\n\n \nstatic inline void fnic_fcpio_ack_handler(struct fnic *fnic,\n\t\t\t\t\t  unsigned int cq_index,\n\t\t\t\t\t  struct fcpio_fw_req *desc)\n{\n\tstruct vnic_wq_copy *wq;\n\tu16 request_out = desc->u.ack.request_out;\n\tunsigned long flags;\n\tu64 *ox_id_tag = (u64 *)(void *)desc;\n\n\t \n\twq = &fnic->wq_copy[cq_index - fnic->raw_wq_count - fnic->rq_count];\n\tspin_lock_irqsave(&fnic->wq_copy_lock[0], flags);\n\n\tfnic->fnic_stats.misc_stats.last_ack_time = jiffies;\n\tif (is_ack_index_in_range(wq, request_out)) {\n\t\tfnic->fw_ack_index[0] = request_out;\n\t\tfnic->fw_ack_recd[0] = 1;\n\t} else\n\t\tatomic64_inc(\n\t\t\t&fnic->fnic_stats.misc_stats.ack_index_out_of_range);\n\n\tspin_unlock_irqrestore(&fnic->wq_copy_lock[0], flags);\n\tFNIC_TRACE(fnic_fcpio_ack_handler,\n\t\t  fnic->lport->host->host_no, 0, 0, ox_id_tag[2], ox_id_tag[3],\n\t\t  ox_id_tag[4], ox_id_tag[5]);\n}\n\n \nstatic void fnic_fcpio_icmnd_cmpl_handler(struct fnic *fnic,\n\t\t\t\t\t struct fcpio_fw_req *desc)\n{\n\tu8 type;\n\tu8 hdr_status;\n\tstruct fcpio_tag tag;\n\tu32 id;\n\tu64 xfer_len = 0;\n\tstruct fcpio_icmnd_cmpl *icmnd_cmpl;\n\tstruct fnic_io_req *io_req;\n\tstruct scsi_cmnd *sc;\n\tstruct fnic_stats *fnic_stats = &fnic->fnic_stats;\n\tunsigned long flags;\n\tspinlock_t *io_lock;\n\tu64 cmd_trace;\n\tunsigned long start_time;\n\tunsigned long io_duration_time;\n\n\t \n\tfcpio_header_dec(&desc->hdr, &type, &hdr_status, &tag);\n\tfcpio_tag_id_dec(&tag, &id);\n\ticmnd_cmpl = &desc->u.icmnd_cmpl;\n\n\tif (id >= fnic->fnic_max_tag_id) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t\"Tag out of range tag %x hdr status = %s\\n\",\n\t\t\t     id, fnic_fcpio_status_to_str(hdr_status));\n\t\treturn;\n\t}\n\n\tsc = scsi_host_find_tag(fnic->lport->host, id);\n\tWARN_ON_ONCE(!sc);\n\tif (!sc) {\n\t\tatomic64_inc(&fnic_stats->io_stats.sc_null);\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t  \"icmnd_cmpl sc is null - \"\n\t\t\t  \"hdr status = %s tag = 0x%x desc = 0x%p\\n\",\n\t\t\t  fnic_fcpio_status_to_str(hdr_status), id, desc);\n\t\tFNIC_TRACE(fnic_fcpio_icmnd_cmpl_handler,\n\t\t\t  fnic->lport->host->host_no, id,\n\t\t\t  ((u64)icmnd_cmpl->_resvd0[1] << 16 |\n\t\t\t  (u64)icmnd_cmpl->_resvd0[0]),\n\t\t\t  ((u64)hdr_status << 16 |\n\t\t\t  (u64)icmnd_cmpl->scsi_status << 8 |\n\t\t\t  (u64)icmnd_cmpl->flags), desc,\n\t\t\t  (u64)icmnd_cmpl->residual, 0);\n\t\treturn;\n\t}\n\n\tio_lock = fnic_io_lock_hash(fnic, sc);\n\tspin_lock_irqsave(io_lock, flags);\n\tio_req = fnic_priv(sc)->io_req;\n\tWARN_ON_ONCE(!io_req);\n\tif (!io_req) {\n\t\tatomic64_inc(&fnic_stats->io_stats.ioreq_null);\n\t\tfnic_priv(sc)->flags |= FNIC_IO_REQ_NULL;\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t  \"icmnd_cmpl io_req is null - \"\n\t\t\t  \"hdr status = %s tag = 0x%x sc 0x%p\\n\",\n\t\t\t  fnic_fcpio_status_to_str(hdr_status), id, sc);\n\t\treturn;\n\t}\n\tstart_time = io_req->start_time;\n\n\t \n\tio_req->io_completed = 1;\n\n\t \n\tif (fnic_priv(sc)->state == FNIC_IOREQ_ABTS_PENDING) {\n\n\t\t \n\t\tfnic_priv(sc)->flags |= FNIC_IO_DONE;\n\t\tfnic_priv(sc)->flags |= FNIC_IO_ABTS_PENDING;\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tif(FCPIO_ABORTED == hdr_status)\n\t\t\tfnic_priv(sc)->flags |= FNIC_IO_ABORTED;\n\n\t\tFNIC_SCSI_DBG(KERN_INFO, fnic->lport->host,\n\t\t\t\"icmnd_cmpl abts pending \"\n\t\t\t  \"hdr status = %s tag = 0x%x sc = 0x%p \"\n\t\t\t  \"scsi_status = %x residual = %d\\n\",\n\t\t\t  fnic_fcpio_status_to_str(hdr_status),\n\t\t\t  id, sc,\n\t\t\t  icmnd_cmpl->scsi_status,\n\t\t\t  icmnd_cmpl->residual);\n\t\treturn;\n\t}\n\n\t \n\tfnic_priv(sc)->state = FNIC_IOREQ_CMD_COMPLETE;\n\n\ticmnd_cmpl = &desc->u.icmnd_cmpl;\n\n\tswitch (hdr_status) {\n\tcase FCPIO_SUCCESS:\n\t\tsc->result = (DID_OK << 16) | icmnd_cmpl->scsi_status;\n\t\txfer_len = scsi_bufflen(sc);\n\n\t\tif (icmnd_cmpl->flags & FCPIO_ICMND_CMPL_RESID_UNDER) {\n\t\t\txfer_len -= icmnd_cmpl->residual;\n\t\t\tscsi_set_resid(sc, icmnd_cmpl->residual);\n\t\t}\n\n\t\tif (icmnd_cmpl->scsi_status == SAM_STAT_CHECK_CONDITION)\n\t\t\tatomic64_inc(&fnic_stats->misc_stats.check_condition);\n\n\t\tif (icmnd_cmpl->scsi_status == SAM_STAT_TASK_SET_FULL)\n\t\t\tatomic64_inc(&fnic_stats->misc_stats.queue_fulls);\n\t\tbreak;\n\n\tcase FCPIO_TIMEOUT:           \n\t\tatomic64_inc(&fnic_stats->misc_stats.fcpio_timeout);\n\t\tsc->result = (DID_TIME_OUT << 16) | icmnd_cmpl->scsi_status;\n\t\tbreak;\n\n\tcase FCPIO_ABORTED:           \n\t\tatomic64_inc(&fnic_stats->misc_stats.fcpio_aborted);\n\t\tsc->result = (DID_ERROR << 16) | icmnd_cmpl->scsi_status;\n\t\tbreak;\n\n\tcase FCPIO_DATA_CNT_MISMATCH:  \n\t\tatomic64_inc(&fnic_stats->misc_stats.data_count_mismatch);\n\t\tscsi_set_resid(sc, icmnd_cmpl->residual);\n\t\tsc->result = (DID_ERROR << 16) | icmnd_cmpl->scsi_status;\n\t\tbreak;\n\n\tcase FCPIO_OUT_OF_RESOURCE:   \n\t\tatomic64_inc(&fnic_stats->fw_stats.fw_out_of_resources);\n\t\tsc->result = (DID_REQUEUE << 16) | icmnd_cmpl->scsi_status;\n\t\tbreak;\n\n\tcase FCPIO_IO_NOT_FOUND:      \n\t\tatomic64_inc(&fnic_stats->io_stats.io_not_found);\n\t\tsc->result = (DID_ERROR << 16) | icmnd_cmpl->scsi_status;\n\t\tbreak;\n\n\tcase FCPIO_SGL_INVALID:       \n\t\tatomic64_inc(&fnic_stats->misc_stats.sgl_invalid);\n\t\tsc->result = (DID_ERROR << 16) | icmnd_cmpl->scsi_status;\n\t\tbreak;\n\n\tcase FCPIO_FW_ERR:            \n\t\tatomic64_inc(&fnic_stats->fw_stats.io_fw_errs);\n\t\tsc->result = (DID_ERROR << 16) | icmnd_cmpl->scsi_status;\n\t\tbreak;\n\n\tcase FCPIO_MSS_INVALID:       \n\t\tatomic64_inc(&fnic_stats->misc_stats.mss_invalid);\n\t\tsc->result = (DID_ERROR << 16) | icmnd_cmpl->scsi_status;\n\t\tbreak;\n\n\tcase FCPIO_INVALID_HEADER:    \n\tcase FCPIO_INVALID_PARAM:     \n\tcase FCPIO_REQ_NOT_SUPPORTED: \n\tdefault:\n\t\tsc->result = (DID_ERROR << 16) | icmnd_cmpl->scsi_status;\n\t\tbreak;\n\t}\n\n\t \n\tfnic_priv(sc)->io_req = NULL;\n\tfnic_priv(sc)->flags |= FNIC_IO_DONE;\n\n\tif (hdr_status != FCPIO_SUCCESS) {\n\t\tatomic64_inc(&fnic_stats->io_stats.io_failures);\n\t\tshost_printk(KERN_ERR, fnic->lport->host, \"hdr status = %s\\n\",\n\t\t\t     fnic_fcpio_status_to_str(hdr_status));\n\t}\n\n\tfnic_release_ioreq_buf(fnic, io_req, sc);\n\n\tcmd_trace = ((u64)hdr_status << 56) |\n\t\t  (u64)icmnd_cmpl->scsi_status << 48 |\n\t\t  (u64)icmnd_cmpl->flags << 40 | (u64)sc->cmnd[0] << 32 |\n\t\t  (u64)sc->cmnd[2] << 24 | (u64)sc->cmnd[3] << 16 |\n\t\t  (u64)sc->cmnd[4] << 8 | sc->cmnd[5];\n\n\tFNIC_TRACE(fnic_fcpio_icmnd_cmpl_handler,\n\t\t  sc->device->host->host_no, id, sc,\n\t\t  ((u64)icmnd_cmpl->_resvd0[1] << 56 |\n\t\t  (u64)icmnd_cmpl->_resvd0[0] << 48 |\n\t\t  jiffies_to_msecs(jiffies - start_time)),\n\t\t  desc, cmd_trace, fnic_flags_and_state(sc));\n\n\tif (sc->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tfnic->lport->host_stats.fcp_input_requests++;\n\t\tfnic->fcp_input_bytes += xfer_len;\n\t} else if (sc->sc_data_direction == DMA_TO_DEVICE) {\n\t\tfnic->lport->host_stats.fcp_output_requests++;\n\t\tfnic->fcp_output_bytes += xfer_len;\n\t} else\n\t\tfnic->lport->host_stats.fcp_control_requests++;\n\n\t \n\tscsi_done(sc);\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\tmempool_free(io_req, fnic->io_req_pool);\n\n\tatomic64_dec(&fnic_stats->io_stats.active_ios);\n\tif (atomic64_read(&fnic->io_cmpl_skip))\n\t\tatomic64_dec(&fnic->io_cmpl_skip);\n\telse\n\t\tatomic64_inc(&fnic_stats->io_stats.io_completions);\n\n\n\tio_duration_time = jiffies_to_msecs(jiffies) -\n\t\t\t\t\t\tjiffies_to_msecs(start_time);\n\n\tif(io_duration_time <= 10)\n\t\tatomic64_inc(&fnic_stats->io_stats.io_btw_0_to_10_msec);\n\telse if(io_duration_time <= 100)\n\t\tatomic64_inc(&fnic_stats->io_stats.io_btw_10_to_100_msec);\n\telse if(io_duration_time <= 500)\n\t\tatomic64_inc(&fnic_stats->io_stats.io_btw_100_to_500_msec);\n\telse if(io_duration_time <= 5000)\n\t\tatomic64_inc(&fnic_stats->io_stats.io_btw_500_to_5000_msec);\n\telse if(io_duration_time <= 10000)\n\t\tatomic64_inc(&fnic_stats->io_stats.io_btw_5000_to_10000_msec);\n\telse if(io_duration_time <= 30000)\n\t\tatomic64_inc(&fnic_stats->io_stats.io_btw_10000_to_30000_msec);\n\telse {\n\t\tatomic64_inc(&fnic_stats->io_stats.io_greater_than_30000_msec);\n\n\t\tif(io_duration_time > atomic64_read(&fnic_stats->io_stats.current_max_io_time))\n\t\t\tatomic64_set(&fnic_stats->io_stats.current_max_io_time, io_duration_time);\n\t}\n}\n\n \nstatic void fnic_fcpio_itmf_cmpl_handler(struct fnic *fnic,\n\t\t\t\t\tstruct fcpio_fw_req *desc)\n{\n\tu8 type;\n\tu8 hdr_status;\n\tstruct fcpio_tag ftag;\n\tu32 id;\n\tstruct scsi_cmnd *sc = NULL;\n\tstruct fnic_io_req *io_req;\n\tstruct fnic_stats *fnic_stats = &fnic->fnic_stats;\n\tstruct abort_stats *abts_stats = &fnic->fnic_stats.abts_stats;\n\tstruct terminate_stats *term_stats = &fnic->fnic_stats.term_stats;\n\tstruct misc_stats *misc_stats = &fnic->fnic_stats.misc_stats;\n\tunsigned long flags;\n\tspinlock_t *io_lock;\n\tunsigned long start_time;\n\tunsigned int tag;\n\n\tfcpio_header_dec(&desc->hdr, &type, &hdr_status, &ftag);\n\tfcpio_tag_id_dec(&ftag, &id);\n\n\ttag = id & FNIC_TAG_MASK;\n\tif (tag == fnic->fnic_max_tag_id) {\n\t\tif (!(id & FNIC_TAG_DEV_RST)) {\n\t\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t\t\t\t\"Tag out of range id 0x%x hdr status = %s\\n\",\n\t\t\t\t\t\tid, fnic_fcpio_status_to_str(hdr_status));\n\t\t\treturn;\n\t\t}\n\t} else if (tag > fnic->fnic_max_tag_id) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t\t\t\"Tag out of range tag 0x%x hdr status = %s\\n\",\n\t\t\t\t\ttag, fnic_fcpio_status_to_str(hdr_status));\n\t\treturn;\n\t}\n\n\tif ((tag == fnic->fnic_max_tag_id) && (id & FNIC_TAG_DEV_RST)) {\n\t\tsc = fnic->sgreset_sc;\n\t\tio_lock = &fnic->sgreset_lock;\n\t} else {\n\t\tsc = scsi_host_find_tag(fnic->lport->host, id & FNIC_TAG_MASK);\n\t\tio_lock = fnic_io_lock_hash(fnic, sc);\n\t}\n\n\tWARN_ON_ONCE(!sc);\n\tif (!sc) {\n\t\tatomic64_inc(&fnic_stats->io_stats.sc_null);\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t  \"itmf_cmpl sc is null - hdr status = %s tag = 0x%x\\n\",\n\t\t\t  fnic_fcpio_status_to_str(hdr_status), tag);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(io_lock, flags);\n\tio_req = fnic_priv(sc)->io_req;\n\tWARN_ON_ONCE(!io_req);\n\tif (!io_req) {\n\t\tatomic64_inc(&fnic_stats->io_stats.ioreq_null);\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tfnic_priv(sc)->flags |= FNIC_IO_ABT_TERM_REQ_NULL;\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t  \"itmf_cmpl io_req is null - \"\n\t\t\t  \"hdr status = %s tag = 0x%x sc 0x%p\\n\",\n\t\t\t  fnic_fcpio_status_to_str(hdr_status), tag, sc);\n\t\treturn;\n\t}\n\tstart_time = io_req->start_time;\n\n\tif ((id & FNIC_TAG_ABORT) && (id & FNIC_TAG_DEV_RST)) {\n\t\t \n\t\t \n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t      \"dev reset abts cmpl recd. id %x status %s\\n\",\n\t\t\t      id, fnic_fcpio_status_to_str(hdr_status));\n\t\tfnic_priv(sc)->state = FNIC_IOREQ_ABTS_COMPLETE;\n\t\tfnic_priv(sc)->abts_status = hdr_status;\n\t\tfnic_priv(sc)->flags |= FNIC_DEV_RST_DONE;\n\t\tif (io_req->abts_done)\n\t\t\tcomplete(io_req->abts_done);\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t} else if (id & FNIC_TAG_ABORT) {\n\t\t \n\t\tswitch (hdr_status) {\n\t\tcase FCPIO_SUCCESS:\n\t\t\tbreak;\n\t\tcase FCPIO_TIMEOUT:\n\t\t\tif (fnic_priv(sc)->flags & FNIC_IO_ABTS_ISSUED)\n\t\t\t\tatomic64_inc(&abts_stats->abort_fw_timeouts);\n\t\t\telse\n\t\t\t\tatomic64_inc(\n\t\t\t\t\t&term_stats->terminate_fw_timeouts);\n\t\t\tbreak;\n\t\tcase FCPIO_ITMF_REJECTED:\n\t\t\tFNIC_SCSI_DBG(KERN_INFO, fnic->lport->host,\n\t\t\t\t\"abort reject recd. id %d\\n\",\n\t\t\t\t(int)(id & FNIC_TAG_MASK));\n\t\t\tbreak;\n\t\tcase FCPIO_IO_NOT_FOUND:\n\t\t\tif (fnic_priv(sc)->flags & FNIC_IO_ABTS_ISSUED)\n\t\t\t\tatomic64_inc(&abts_stats->abort_io_not_found);\n\t\t\telse\n\t\t\t\tatomic64_inc(\n\t\t\t\t\t&term_stats->terminate_io_not_found);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fnic_priv(sc)->flags & FNIC_IO_ABTS_ISSUED)\n\t\t\t\tatomic64_inc(&abts_stats->abort_failures);\n\t\t\telse\n\t\t\t\tatomic64_inc(\n\t\t\t\t\t&term_stats->terminate_failures);\n\t\t\tbreak;\n\t\t}\n\t\tif (fnic_priv(sc)->state != FNIC_IOREQ_ABTS_PENDING) {\n\t\t\t \n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tfnic_priv(sc)->flags |= FNIC_IO_ABT_TERM_DONE;\n\t\tfnic_priv(sc)->abts_status = hdr_status;\n\n\t\t \n\t\tif (hdr_status == FCPIO_IO_NOT_FOUND)\n\t\t\tfnic_priv(sc)->abts_status = FCPIO_SUCCESS;\n\n\t\tif (!(fnic_priv(sc)->flags & (FNIC_IO_ABORTED | FNIC_IO_DONE)))\n\t\t\tatomic64_inc(&misc_stats->no_icmnd_itmf_cmpls);\n\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t      \"abts cmpl recd. id %d status %s\\n\",\n\t\t\t      (int)(id & FNIC_TAG_MASK),\n\t\t\t      fnic_fcpio_status_to_str(hdr_status));\n\n\t\t \n\t\tif (io_req->abts_done) {\n\t\t\tcomplete(io_req->abts_done);\n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\t} else {\n\t\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t      \"abts cmpl, completing IO\\n\");\n\t\t\tfnic_priv(sc)->io_req = NULL;\n\t\t\tsc->result = (DID_ERROR << 16);\n\n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\t\tfnic_release_ioreq_buf(fnic, io_req, sc);\n\t\t\tmempool_free(io_req, fnic->io_req_pool);\n\t\t\tFNIC_TRACE(fnic_fcpio_itmf_cmpl_handler,\n\t\t\t\t   sc->device->host->host_no, id,\n\t\t\t\t   sc,\n\t\t\t\t   jiffies_to_msecs(jiffies - start_time),\n\t\t\t\t   desc,\n\t\t\t\t   (((u64)hdr_status << 40) |\n\t\t\t\t    (u64)sc->cmnd[0] << 32 |\n\t\t\t\t    (u64)sc->cmnd[2] << 24 |\n\t\t\t\t    (u64)sc->cmnd[3] << 16 |\n\t\t\t\t    (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),\n\t\t\t\t   fnic_flags_and_state(sc));\n\t\t\tscsi_done(sc);\n\t\t\tatomic64_dec(&fnic_stats->io_stats.active_ios);\n\t\t\tif (atomic64_read(&fnic->io_cmpl_skip))\n\t\t\t\tatomic64_dec(&fnic->io_cmpl_skip);\n\t\t\telse\n\t\t\t\tatomic64_inc(&fnic_stats->io_stats.io_completions);\n\t\t}\n\t} else if (id & FNIC_TAG_DEV_RST) {\n\t\t \n\t\tfnic_priv(sc)->lr_status = hdr_status;\n\t\tif (fnic_priv(sc)->state == FNIC_IOREQ_ABTS_PENDING) {\n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\t\tfnic_priv(sc)->flags |= FNIC_DEV_RST_ABTS_PENDING;\n\t\t\tFNIC_TRACE(fnic_fcpio_itmf_cmpl_handler,\n\t\t\t\t  sc->device->host->host_no, id, sc,\n\t\t\t\t  jiffies_to_msecs(jiffies - start_time),\n\t\t\t\t  desc, 0, fnic_flags_and_state(sc));\n\t\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t\"Terminate pending \"\n\t\t\t\t\"dev reset cmpl recd. id %d status %s\\n\",\n\t\t\t\t(int)(id & FNIC_TAG_MASK),\n\t\t\t\tfnic_fcpio_status_to_str(hdr_status));\n\t\t\treturn;\n\t\t}\n\t\tif (fnic_priv(sc)->flags & FNIC_DEV_RST_TIMED_OUT) {\n\t\t\t \n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\t\tFNIC_TRACE(fnic_fcpio_itmf_cmpl_handler,\n\t\t\t\t  sc->device->host->host_no, id, sc,\n\t\t\t\t  jiffies_to_msecs(jiffies - start_time),\n\t\t\t\t  desc, 0, fnic_flags_and_state(sc));\n\t\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t\"dev reset cmpl recd after time out. \"\n\t\t\t\t\"id %d status %s\\n\",\n\t\t\t\t(int)(id & FNIC_TAG_MASK),\n\t\t\t\tfnic_fcpio_status_to_str(hdr_status));\n\t\t\treturn;\n\t\t}\n\t\tfnic_priv(sc)->state = FNIC_IOREQ_CMD_COMPLETE;\n\t\tfnic_priv(sc)->flags |= FNIC_DEV_RST_DONE;\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t      \"dev reset cmpl recd. id %d status %s\\n\",\n\t\t\t      (int)(id & FNIC_TAG_MASK),\n\t\t\t      fnic_fcpio_status_to_str(hdr_status));\n\t\tif (io_req->dr_done)\n\t\t\tcomplete(io_req->dr_done);\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t} else {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"Unexpected itmf io state %s tag %x\\n\",\n\t\t\t     fnic_ioreq_state_to_str(fnic_priv(sc)->state), id);\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t}\n\n}\n\n \nstatic int fnic_fcpio_cmpl_handler(struct vnic_dev *vdev,\n\t\t\t\t   unsigned int cq_index,\n\t\t\t\t   struct fcpio_fw_req *desc)\n{\n\tstruct fnic *fnic = vnic_dev_priv(vdev);\n\n\tswitch (desc->hdr.type) {\n\tcase FCPIO_ICMND_CMPL:  \n\tcase FCPIO_ITMF_CMPL:  \n\tcase FCPIO_FLOGI_REG_CMPL:  \n\tcase FCPIO_FLOGI_FIP_REG_CMPL:  \n\tcase FCPIO_RESET_CMPL:  \n\t\tatomic64_dec(&fnic->fnic_stats.fw_stats.active_fw_reqs);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (desc->hdr.type) {\n\tcase FCPIO_ACK:  \n\t\tfnic_fcpio_ack_handler(fnic, cq_index, desc);\n\t\tbreak;\n\n\tcase FCPIO_ICMND_CMPL:  \n\t\tfnic_fcpio_icmnd_cmpl_handler(fnic, desc);\n\t\tbreak;\n\n\tcase FCPIO_ITMF_CMPL:  \n\t\tfnic_fcpio_itmf_cmpl_handler(fnic, desc);\n\t\tbreak;\n\n\tcase FCPIO_FLOGI_REG_CMPL:  \n\tcase FCPIO_FLOGI_FIP_REG_CMPL:  \n\t\tfnic_fcpio_flogi_reg_cmpl_handler(fnic, desc);\n\t\tbreak;\n\n\tcase FCPIO_RESET_CMPL:  \n\t\tfnic_fcpio_fw_reset_cmpl_handler(fnic, desc);\n\t\tbreak;\n\n\tdefault:\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t      \"firmware completion type %d\\n\",\n\t\t\t      desc->hdr.type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nint fnic_wq_copy_cmpl_handler(struct fnic *fnic, int copy_work_to_do)\n{\n\tunsigned int wq_work_done = 0;\n\tunsigned int i, cq_index;\n\tunsigned int cur_work_done;\n\tstruct misc_stats *misc_stats = &fnic->fnic_stats.misc_stats;\n\tu64 start_jiffies = 0;\n\tu64 end_jiffies = 0;\n\tu64 delta_jiffies = 0;\n\tu64 delta_ms = 0;\n\n\tfor (i = 0; i < fnic->wq_copy_count; i++) {\n\t\tcq_index = i + fnic->raw_wq_count + fnic->rq_count;\n\n\t\tstart_jiffies = jiffies;\n\t\tcur_work_done = vnic_cq_copy_service(&fnic->cq[cq_index],\n\t\t\t\t\t\t     fnic_fcpio_cmpl_handler,\n\t\t\t\t\t\t     copy_work_to_do);\n\t\tend_jiffies = jiffies;\n\n\t\twq_work_done += cur_work_done;\n\t\tdelta_jiffies = end_jiffies - start_jiffies;\n\t\tif (delta_jiffies >\n\t\t\t(u64) atomic64_read(&misc_stats->max_isr_jiffies)) {\n\t\t\tatomic64_set(&misc_stats->max_isr_jiffies,\n\t\t\t\t\tdelta_jiffies);\n\t\t\tdelta_ms = jiffies_to_msecs(delta_jiffies);\n\t\t\tatomic64_set(&misc_stats->max_isr_time_ms, delta_ms);\n\t\t\tatomic64_set(&misc_stats->corr_work_done,\n\t\t\t\t\tcur_work_done);\n\t\t}\n\t}\n\treturn wq_work_done;\n}\n\nstatic bool fnic_cleanup_io_iter(struct scsi_cmnd *sc, void *data)\n{\n\tconst int tag = scsi_cmd_to_rq(sc)->tag;\n\tstruct fnic *fnic = data;\n\tstruct fnic_io_req *io_req;\n\tunsigned long flags = 0;\n\tspinlock_t *io_lock;\n\tunsigned long start_time = 0;\n\tstruct fnic_stats *fnic_stats = &fnic->fnic_stats;\n\n\tio_lock = fnic_io_lock_tag(fnic, tag);\n\tspin_lock_irqsave(io_lock, flags);\n\n\tio_req = fnic_priv(sc)->io_req;\n\tif ((fnic_priv(sc)->flags & FNIC_DEVICE_RESET) &&\n\t    !(fnic_priv(sc)->flags & FNIC_DEV_RST_DONE)) {\n\t\t \n\t\tfnic_priv(sc)->flags |= FNIC_DEV_RST_DONE;\n\t\tif (io_req && io_req->dr_done)\n\t\t\tcomplete(io_req->dr_done);\n\t\telse if (io_req && io_req->abts_done)\n\t\t\tcomplete(io_req->abts_done);\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\treturn true;\n\t} else if (fnic_priv(sc)->flags & FNIC_DEVICE_RESET) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\treturn true;\n\t}\n\tif (!io_req) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tgoto cleanup_scsi_cmd;\n\t}\n\n\tfnic_priv(sc)->io_req = NULL;\n\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\t \n\tstart_time = io_req->start_time;\n\tfnic_release_ioreq_buf(fnic, io_req, sc);\n\tmempool_free(io_req, fnic->io_req_pool);\n\ncleanup_scsi_cmd:\n\tsc->result = DID_TRANSPORT_DISRUPTED << 16;\n\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t      \"fnic_cleanup_io: tag:0x%x : sc:0x%p duration = %lu DID_TRANSPORT_DISRUPTED\\n\",\n\t\t      tag, sc, jiffies - start_time);\n\n\tif (atomic64_read(&fnic->io_cmpl_skip))\n\t\tatomic64_dec(&fnic->io_cmpl_skip);\n\telse\n\t\tatomic64_inc(&fnic_stats->io_stats.io_completions);\n\n\t \n\tif (!(fnic_priv(sc)->flags & FNIC_IO_ISSUED))\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"Calling done for IO not issued to fw: tag:0x%x sc:0x%p\\n\",\n\t\t\t     tag, sc);\n\n\tFNIC_TRACE(fnic_cleanup_io,\n\t\t   sc->device->host->host_no, tag, sc,\n\t\t   jiffies_to_msecs(jiffies - start_time),\n\t\t   0, ((u64)sc->cmnd[0] << 32 |\n\t\t       (u64)sc->cmnd[2] << 24 |\n\t\t       (u64)sc->cmnd[3] << 16 |\n\t\t       (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),\n\t\t   fnic_flags_and_state(sc));\n\n\tscsi_done(sc);\n\n\treturn true;\n}\n\nstatic void fnic_cleanup_io(struct fnic *fnic)\n{\n\tscsi_host_busy_iter(fnic->lport->host,\n\t\t\t    fnic_cleanup_io_iter, fnic);\n}\n\nvoid fnic_wq_copy_cleanup_handler(struct vnic_wq_copy *wq,\n\t\t\t\t  struct fcpio_host_req *desc)\n{\n\tu32 id;\n\tstruct fnic *fnic = vnic_dev_priv(wq->vdev);\n\tstruct fnic_io_req *io_req;\n\tstruct scsi_cmnd *sc;\n\tunsigned long flags;\n\tspinlock_t *io_lock;\n\tunsigned long start_time = 0;\n\n\t \n\tfcpio_tag_id_dec(&desc->hdr.tag, &id);\n\tid &= FNIC_TAG_MASK;\n\n\tif (id >= fnic->fnic_max_tag_id)\n\t\treturn;\n\n\tsc = scsi_host_find_tag(fnic->lport->host, id);\n\tif (!sc)\n\t\treturn;\n\n\tio_lock = fnic_io_lock_hash(fnic, sc);\n\tspin_lock_irqsave(io_lock, flags);\n\n\t \n\tio_req = fnic_priv(sc)->io_req;\n\n\t \n\n\tif (!io_req) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tgoto wq_copy_cleanup_scsi_cmd;\n\t}\n\n\tfnic_priv(sc)->io_req = NULL;\n\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\tstart_time = io_req->start_time;\n\tfnic_release_ioreq_buf(fnic, io_req, sc);\n\tmempool_free(io_req, fnic->io_req_pool);\n\nwq_copy_cleanup_scsi_cmd:\n\tsc->result = DID_NO_CONNECT << 16;\n\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, \"wq_copy_cleanup_handler:\"\n\t\t      \" DID_NO_CONNECT\\n\");\n\n\tFNIC_TRACE(fnic_wq_copy_cleanup_handler,\n\t\t   sc->device->host->host_no, id, sc,\n\t\t   jiffies_to_msecs(jiffies - start_time),\n\t\t   0, ((u64)sc->cmnd[0] << 32 |\n\t\t       (u64)sc->cmnd[2] << 24 | (u64)sc->cmnd[3] << 16 |\n\t\t       (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),\n\t\t   fnic_flags_and_state(sc));\n\n\tscsi_done(sc);\n}\n\nstatic inline int fnic_queue_abort_io_req(struct fnic *fnic, int tag,\n\t\t\t\t\t  u32 task_req, u8 *fc_lun,\n\t\t\t\t\t  struct fnic_io_req *io_req)\n{\n\tstruct vnic_wq_copy *wq = &fnic->wq_copy[0];\n\tstruct Scsi_Host *host = fnic->lport->host;\n\tstruct misc_stats *misc_stats = &fnic->fnic_stats.misc_stats;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(host->host_lock, flags);\n\tif (unlikely(fnic_chk_state_flags_locked(fnic,\n\t\t\t\t\t\tFNIC_FLAGS_IO_BLOCKED))) {\n\t\tspin_unlock_irqrestore(host->host_lock, flags);\n\t\treturn 1;\n\t} else\n\t\tatomic_inc(&fnic->in_flight);\n\tspin_unlock_irqrestore(host->host_lock, flags);\n\n\tspin_lock_irqsave(&fnic->wq_copy_lock[0], flags);\n\n\tif (vnic_wq_copy_desc_avail(wq) <= fnic->wq_copy_desc_low[0])\n\t\tfree_wq_copy_descs(fnic, wq);\n\n\tif (!vnic_wq_copy_desc_avail(wq)) {\n\t\tspin_unlock_irqrestore(&fnic->wq_copy_lock[0], flags);\n\t\tatomic_dec(&fnic->in_flight);\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\"fnic_queue_abort_io_req: failure: no descriptors\\n\");\n\t\tatomic64_inc(&misc_stats->abts_cpwq_alloc_failures);\n\t\treturn 1;\n\t}\n\tfnic_queue_wq_copy_desc_itmf(wq, tag | FNIC_TAG_ABORT,\n\t\t\t\t     0, task_req, tag, fc_lun, io_req->port_id,\n\t\t\t\t     fnic->config.ra_tov, fnic->config.ed_tov);\n\n\tatomic64_inc(&fnic->fnic_stats.fw_stats.active_fw_reqs);\n\tif (atomic64_read(&fnic->fnic_stats.fw_stats.active_fw_reqs) >\n\t\t  atomic64_read(&fnic->fnic_stats.fw_stats.max_fw_reqs))\n\t\tatomic64_set(&fnic->fnic_stats.fw_stats.max_fw_reqs,\n\t\t  atomic64_read(&fnic->fnic_stats.fw_stats.active_fw_reqs));\n\n\tspin_unlock_irqrestore(&fnic->wq_copy_lock[0], flags);\n\tatomic_dec(&fnic->in_flight);\n\n\treturn 0;\n}\n\nstruct fnic_rport_abort_io_iter_data {\n\tstruct fnic *fnic;\n\tu32 port_id;\n\tint term_cnt;\n};\n\nstatic bool fnic_rport_abort_io_iter(struct scsi_cmnd *sc, void *data)\n{\n\tstruct fnic_rport_abort_io_iter_data *iter_data = data;\n\tstruct fnic *fnic = iter_data->fnic;\n\tint abt_tag = scsi_cmd_to_rq(sc)->tag;\n\tstruct fnic_io_req *io_req;\n\tspinlock_t *io_lock;\n\tunsigned long flags;\n\tstruct reset_stats *reset_stats = &fnic->fnic_stats.reset_stats;\n\tstruct terminate_stats *term_stats = &fnic->fnic_stats.term_stats;\n\tstruct scsi_lun fc_lun;\n\tenum fnic_ioreq_state old_ioreq_state;\n\n\tio_lock = fnic_io_lock_tag(fnic, abt_tag);\n\tspin_lock_irqsave(io_lock, flags);\n\n\tio_req = fnic_priv(sc)->io_req;\n\n\tif (!io_req || io_req->port_id != iter_data->port_id) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\treturn true;\n\t}\n\n\tif ((fnic_priv(sc)->flags & FNIC_DEVICE_RESET) &&\n\t    !(fnic_priv(sc)->flags & FNIC_DEV_RST_ISSUED)) {\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\"fnic_rport_exch_reset dev rst not pending sc 0x%p\\n\",\n\t\t\tsc);\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\treturn true;\n\t}\n\n\t \n\tif (fnic_priv(sc)->state == FNIC_IOREQ_ABTS_PENDING) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\treturn true;\n\t}\n\tif (io_req->abts_done) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t\"fnic_rport_exch_reset: io_req->abts_done is set \"\n\t\t\t\"state is %s\\n\",\n\t\t\tfnic_ioreq_state_to_str(fnic_priv(sc)->state));\n\t}\n\n\tif (!(fnic_priv(sc)->flags & FNIC_IO_ISSUED)) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"rport_exch_reset \"\n\t\t\t     \"IO not yet issued %p tag 0x%x flags \"\n\t\t\t     \"%x state %d\\n\",\n\t\t\t     sc, abt_tag, fnic_priv(sc)->flags, fnic_priv(sc)->state);\n\t}\n\told_ioreq_state = fnic_priv(sc)->state;\n\tfnic_priv(sc)->state = FNIC_IOREQ_ABTS_PENDING;\n\tfnic_priv(sc)->abts_status = FCPIO_INVALID_CODE;\n\tif (fnic_priv(sc)->flags & FNIC_DEVICE_RESET) {\n\t\tatomic64_inc(&reset_stats->device_reset_terminates);\n\t\tabt_tag |= FNIC_TAG_DEV_RST;\n\t}\n\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t      \"fnic_rport_exch_reset dev rst sc 0x%p\\n\", sc);\n\tBUG_ON(io_req->abts_done);\n\n\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t      \"fnic_rport_reset_exch: Issuing abts\\n\");\n\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\t \n\tint_to_scsilun(sc->device->lun, &fc_lun);\n\n\tif (fnic_queue_abort_io_req(fnic, abt_tag,\n\t\t\t\t    FCPIO_ITMF_ABT_TASK_TERM,\n\t\t\t\t    fc_lun.scsi_lun, io_req)) {\n\t\t \n\t\tspin_lock_irqsave(io_lock, flags);\n\t\tif (fnic_priv(sc)->state == FNIC_IOREQ_ABTS_PENDING)\n\t\t\tfnic_priv(sc)->state = old_ioreq_state;\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t} else {\n\t\tspin_lock_irqsave(io_lock, flags);\n\t\tif (fnic_priv(sc)->flags & FNIC_DEVICE_RESET)\n\t\t\tfnic_priv(sc)->flags |= FNIC_DEV_RST_TERM_ISSUED;\n\t\telse\n\t\t\tfnic_priv(sc)->flags |= FNIC_IO_INTERNAL_TERM_ISSUED;\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tatomic64_inc(&term_stats->terminates);\n\t\titer_data->term_cnt++;\n\t}\n\treturn true;\n}\n\nstatic void fnic_rport_exch_reset(struct fnic *fnic, u32 port_id)\n{\n\tstruct terminate_stats *term_stats = &fnic->fnic_stats.term_stats;\n\tstruct fnic_rport_abort_io_iter_data iter_data = {\n\t\t.fnic = fnic,\n\t\t.port_id = port_id,\n\t\t.term_cnt = 0,\n\t};\n\n\tFNIC_SCSI_DBG(KERN_DEBUG,\n\t\t      fnic->lport->host,\n\t\t      \"fnic_rport_exch_reset called portid 0x%06x\\n\",\n\t\t      port_id);\n\n\tif (fnic->in_remove)\n\t\treturn;\n\n\tscsi_host_busy_iter(fnic->lport->host, fnic_rport_abort_io_iter,\n\t\t\t    &iter_data);\n\tif (iter_data.term_cnt > atomic64_read(&term_stats->max_terminates))\n\t\tatomic64_set(&term_stats->max_terminates, iter_data.term_cnt);\n\n}\n\nvoid fnic_terminate_rport_io(struct fc_rport *rport)\n{\n\tstruct fc_rport_libfc_priv *rdata;\n\tstruct fc_lport *lport;\n\tstruct fnic *fnic;\n\n\tif (!rport) {\n\t\tprintk(KERN_ERR \"fnic_terminate_rport_io: rport is NULL\\n\");\n\t\treturn;\n\t}\n\trdata = rport->dd_data;\n\n\tif (!rdata) {\n\t\tprintk(KERN_ERR \"fnic_terminate_rport_io: rdata is NULL\\n\");\n\t\treturn;\n\t}\n\tlport = rdata->local_port;\n\n\tif (!lport) {\n\t\tprintk(KERN_ERR \"fnic_terminate_rport_io: lport is NULL\\n\");\n\t\treturn;\n\t}\n\tfnic = lport_priv(lport);\n\tFNIC_SCSI_DBG(KERN_DEBUG,\n\t\t      fnic->lport->host, \"fnic_terminate_rport_io called\"\n\t\t      \" wwpn 0x%llx, wwnn0x%llx, rport 0x%p, portid 0x%06x\\n\",\n\t\t      rport->port_name, rport->node_name, rport,\n\t\t      rport->port_id);\n\n\tif (fnic->in_remove)\n\t\treturn;\n\n\tfnic_rport_exch_reset(fnic, rport->port_id);\n}\n\n \nint fnic_abort_cmd(struct scsi_cmnd *sc)\n{\n\tstruct request *const rq = scsi_cmd_to_rq(sc);\n\tstruct fc_lport *lp;\n\tstruct fnic *fnic;\n\tstruct fnic_io_req *io_req = NULL;\n\tstruct fc_rport *rport;\n\tspinlock_t *io_lock;\n\tunsigned long flags;\n\tunsigned long start_time = 0;\n\tint ret = SUCCESS;\n\tu32 task_req = 0;\n\tstruct scsi_lun fc_lun;\n\tstruct fnic_stats *fnic_stats;\n\tstruct abort_stats *abts_stats;\n\tstruct terminate_stats *term_stats;\n\tenum fnic_ioreq_state old_ioreq_state;\n\tconst int tag = rq->tag;\n\tunsigned long abt_issued_time;\n\tDECLARE_COMPLETION_ONSTACK(tm_done);\n\n\t \n\tfc_block_scsi_eh(sc);\n\n\t \n\tlp = shost_priv(sc->device->host);\n\n\tfnic = lport_priv(lp);\n\tfnic_stats = &fnic->fnic_stats;\n\tabts_stats = &fnic->fnic_stats.abts_stats;\n\tterm_stats = &fnic->fnic_stats.term_stats;\n\n\trport = starget_to_rport(scsi_target(sc->device));\n\tFNIC_SCSI_DBG(KERN_DEBUG,\n\t\tfnic->lport->host,\n\t\t\"Abort Cmd called FCID 0x%x, LUN 0x%llx TAG %x flags %x\\n\",\n\t\trport->port_id, sc->device->lun, tag, fnic_priv(sc)->flags);\n\n\tfnic_priv(sc)->flags = FNIC_NO_FLAGS;\n\n\tif (lp->state != LPORT_ST_READY || !(lp->link_up)) {\n\t\tret = FAILED;\n\t\tgoto fnic_abort_cmd_end;\n\t}\n\n\t \n\tio_lock = fnic_io_lock_hash(fnic, sc);\n\tspin_lock_irqsave(io_lock, flags);\n\tio_req = fnic_priv(sc)->io_req;\n\tif (!io_req) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tgoto fnic_abort_cmd_end;\n\t}\n\n\tio_req->abts_done = &tm_done;\n\n\tif (fnic_priv(sc)->state == FNIC_IOREQ_ABTS_PENDING) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tgoto wait_pending;\n\t}\n\n\tabt_issued_time = jiffies_to_msecs(jiffies) - jiffies_to_msecs(io_req->start_time);\n\tif (abt_issued_time <= 6000)\n\t\tatomic64_inc(&abts_stats->abort_issued_btw_0_to_6_sec);\n\telse if (abt_issued_time > 6000 && abt_issued_time <= 20000)\n\t\tatomic64_inc(&abts_stats->abort_issued_btw_6_to_20_sec);\n\telse if (abt_issued_time > 20000 && abt_issued_time <= 30000)\n\t\tatomic64_inc(&abts_stats->abort_issued_btw_20_to_30_sec);\n\telse if (abt_issued_time > 30000 && abt_issued_time <= 40000)\n\t\tatomic64_inc(&abts_stats->abort_issued_btw_30_to_40_sec);\n\telse if (abt_issued_time > 40000 && abt_issued_time <= 50000)\n\t\tatomic64_inc(&abts_stats->abort_issued_btw_40_to_50_sec);\n\telse if (abt_issued_time > 50000 && abt_issued_time <= 60000)\n\t\tatomic64_inc(&abts_stats->abort_issued_btw_50_to_60_sec);\n\telse\n\t\tatomic64_inc(&abts_stats->abort_issued_greater_than_60_sec);\n\n\tFNIC_SCSI_DBG(KERN_INFO, fnic->lport->host,\n\t\t\"CBD Opcode: %02x Abort issued time: %lu msec\\n\", sc->cmnd[0], abt_issued_time);\n\t \n\told_ioreq_state = fnic_priv(sc)->state;\n\tfnic_priv(sc)->state = FNIC_IOREQ_ABTS_PENDING;\n\tfnic_priv(sc)->abts_status = FCPIO_INVALID_CODE;\n\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\t \n\tif (fc_remote_port_chkready(rport) == 0)\n\t\ttask_req = FCPIO_ITMF_ABT_TASK;\n\telse {\n\t\tatomic64_inc(&fnic_stats->misc_stats.rport_not_ready);\n\t\ttask_req = FCPIO_ITMF_ABT_TASK_TERM;\n\t}\n\n\t \n\tint_to_scsilun(sc->device->lun, &fc_lun);\n\n\tif (fnic_queue_abort_io_req(fnic, tag, task_req, fc_lun.scsi_lun,\n\t\t\t\t    io_req)) {\n\t\tspin_lock_irqsave(io_lock, flags);\n\t\tif (fnic_priv(sc)->state == FNIC_IOREQ_ABTS_PENDING)\n\t\t\tfnic_priv(sc)->state = old_ioreq_state;\n\t\tio_req = fnic_priv(sc)->io_req;\n\t\tif (io_req)\n\t\t\tio_req->abts_done = NULL;\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tret = FAILED;\n\t\tgoto fnic_abort_cmd_end;\n\t}\n\tif (task_req == FCPIO_ITMF_ABT_TASK) {\n\t\tfnic_priv(sc)->flags |= FNIC_IO_ABTS_ISSUED;\n\t\tatomic64_inc(&fnic_stats->abts_stats.aborts);\n\t} else {\n\t\tfnic_priv(sc)->flags |= FNIC_IO_TERM_ISSUED;\n\t\tatomic64_inc(&fnic_stats->term_stats.terminates);\n\t}\n\n\t \n wait_pending:\n\twait_for_completion_timeout(&tm_done,\n\t\t\t\t    msecs_to_jiffies\n\t\t\t\t    (2 * fnic->config.ra_tov +\n\t\t\t\t     fnic->config.ed_tov));\n\n\t \n\tspin_lock_irqsave(io_lock, flags);\n\n\tio_req = fnic_priv(sc)->io_req;\n\tif (!io_req) {\n\t\tatomic64_inc(&fnic_stats->io_stats.ioreq_null);\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tfnic_priv(sc)->flags |= FNIC_IO_ABT_TERM_REQ_NULL;\n\t\tret = FAILED;\n\t\tgoto fnic_abort_cmd_end;\n\t}\n\tio_req->abts_done = NULL;\n\n\t \n\tif (fnic_priv(sc)->abts_status == FCPIO_INVALID_CODE) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tif (task_req == FCPIO_ITMF_ABT_TASK) {\n\t\t\tatomic64_inc(&abts_stats->abort_drv_timeouts);\n\t\t} else {\n\t\t\tatomic64_inc(&term_stats->terminate_drv_timeouts);\n\t\t}\n\t\tfnic_priv(sc)->flags |= FNIC_IO_ABT_TERM_TIMED_OUT;\n\t\tret = FAILED;\n\t\tgoto fnic_abort_cmd_end;\n\t}\n\n\t \n\n\tif (!(fnic_priv(sc)->flags & (FNIC_IO_ABORTED | FNIC_IO_DONE))) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\"Issuing Host reset due to out of order IO\\n\");\n\n\t\tret = FAILED;\n\t\tgoto fnic_abort_cmd_end;\n\t}\n\n\tfnic_priv(sc)->state = FNIC_IOREQ_ABTS_COMPLETE;\n\n\tstart_time = io_req->start_time;\n\t \n\tif (fnic_priv(sc)->abts_status == FCPIO_SUCCESS) {\n\t\tfnic_priv(sc)->io_req = NULL;\n\t} else {\n\t\tret = FAILED;\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tgoto fnic_abort_cmd_end;\n\t}\n\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\tfnic_release_ioreq_buf(fnic, io_req, sc);\n\tmempool_free(io_req, fnic->io_req_pool);\n\n\t \n\tsc->result = DID_ABORT << 16;\n\tscsi_done(sc);\n\tatomic64_dec(&fnic_stats->io_stats.active_ios);\n\tif (atomic64_read(&fnic->io_cmpl_skip))\n\t\tatomic64_dec(&fnic->io_cmpl_skip);\n\telse\n\t\tatomic64_inc(&fnic_stats->io_stats.io_completions);\n\nfnic_abort_cmd_end:\n\tFNIC_TRACE(fnic_abort_cmd, sc->device->host->host_no, tag, sc,\n\t\t  jiffies_to_msecs(jiffies - start_time),\n\t\t  0, ((u64)sc->cmnd[0] << 32 |\n\t\t  (u64)sc->cmnd[2] << 24 | (u64)sc->cmnd[3] << 16 |\n\t\t  (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),\n\t\t  fnic_flags_and_state(sc));\n\n\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t      \"Returning from abort cmd type %x %s\\n\", task_req,\n\t\t      (ret == SUCCESS) ?\n\t\t      \"SUCCESS\" : \"FAILED\");\n\treturn ret;\n}\n\nstatic inline int fnic_queue_dr_io_req(struct fnic *fnic,\n\t\t\t\t       struct scsi_cmnd *sc,\n\t\t\t\t       struct fnic_io_req *io_req)\n{\n\tstruct vnic_wq_copy *wq = &fnic->wq_copy[0];\n\tstruct Scsi_Host *host = fnic->lport->host;\n\tstruct misc_stats *misc_stats = &fnic->fnic_stats.misc_stats;\n\tstruct scsi_lun fc_lun;\n\tint ret = 0;\n\tunsigned long intr_flags;\n\tunsigned int tag = scsi_cmd_to_rq(sc)->tag;\n\n\tif (tag == SCSI_NO_TAG)\n\t\ttag = io_req->tag;\n\n\tspin_lock_irqsave(host->host_lock, intr_flags);\n\tif (unlikely(fnic_chk_state_flags_locked(fnic,\n\t\t\t\t\t\tFNIC_FLAGS_IO_BLOCKED))) {\n\t\tspin_unlock_irqrestore(host->host_lock, intr_flags);\n\t\treturn FAILED;\n\t} else\n\t\tatomic_inc(&fnic->in_flight);\n\tspin_unlock_irqrestore(host->host_lock, intr_flags);\n\n\tspin_lock_irqsave(&fnic->wq_copy_lock[0], intr_flags);\n\n\tif (vnic_wq_copy_desc_avail(wq) <= fnic->wq_copy_desc_low[0])\n\t\tfree_wq_copy_descs(fnic, wq);\n\n\tif (!vnic_wq_copy_desc_avail(wq)) {\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t  \"queue_dr_io_req failure - no descriptors\\n\");\n\t\tatomic64_inc(&misc_stats->devrst_cpwq_alloc_failures);\n\t\tret = -EAGAIN;\n\t\tgoto lr_io_req_end;\n\t}\n\n\t \n\tint_to_scsilun(sc->device->lun, &fc_lun);\n\n\ttag |= FNIC_TAG_DEV_RST;\n\tfnic_queue_wq_copy_desc_itmf(wq, tag,\n\t\t\t\t     0, FCPIO_ITMF_LUN_RESET, SCSI_NO_TAG,\n\t\t\t\t     fc_lun.scsi_lun, io_req->port_id,\n\t\t\t\t     fnic->config.ra_tov, fnic->config.ed_tov);\n\n\tatomic64_inc(&fnic->fnic_stats.fw_stats.active_fw_reqs);\n\tif (atomic64_read(&fnic->fnic_stats.fw_stats.active_fw_reqs) >\n\t\t  atomic64_read(&fnic->fnic_stats.fw_stats.max_fw_reqs))\n\t\tatomic64_set(&fnic->fnic_stats.fw_stats.max_fw_reqs,\n\t\t  atomic64_read(&fnic->fnic_stats.fw_stats.active_fw_reqs));\n\nlr_io_req_end:\n\tspin_unlock_irqrestore(&fnic->wq_copy_lock[0], intr_flags);\n\tatomic_dec(&fnic->in_flight);\n\n\treturn ret;\n}\n\nstruct fnic_pending_aborts_iter_data {\n\tstruct fnic *fnic;\n\tstruct scsi_cmnd *lr_sc;\n\tstruct scsi_device *lun_dev;\n\tint ret;\n};\n\nstatic bool fnic_pending_aborts_iter(struct scsi_cmnd *sc, void *data)\n{\n\tstruct fnic_pending_aborts_iter_data *iter_data = data;\n\tstruct fnic *fnic = iter_data->fnic;\n\tstruct scsi_device *lun_dev = iter_data->lun_dev;\n\tint abt_tag = scsi_cmd_to_rq(sc)->tag;\n\tstruct fnic_io_req *io_req;\n\tspinlock_t *io_lock;\n\tunsigned long flags;\n\tstruct scsi_lun fc_lun;\n\tDECLARE_COMPLETION_ONSTACK(tm_done);\n\tenum fnic_ioreq_state old_ioreq_state;\n\n\tif (sc == iter_data->lr_sc || sc->device != lun_dev)\n\t\treturn true;\n\n\tio_lock = fnic_io_lock_tag(fnic, abt_tag);\n\tspin_lock_irqsave(io_lock, flags);\n\tio_req = fnic_priv(sc)->io_req;\n\tif (!io_req) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\treturn true;\n\t}\n\n\t \n\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t      \"Found IO in %s on lun\\n\",\n\t\t      fnic_ioreq_state_to_str(fnic_priv(sc)->state));\n\n\tif (fnic_priv(sc)->state == FNIC_IOREQ_ABTS_PENDING) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\treturn true;\n\t}\n\tif ((fnic_priv(sc)->flags & FNIC_DEVICE_RESET) &&\n\t    (!(fnic_priv(sc)->flags & FNIC_DEV_RST_ISSUED))) {\n\t\tFNIC_SCSI_DBG(KERN_INFO, fnic->lport->host,\n\t\t\t      \"%s dev rst not pending sc 0x%p\\n\", __func__,\n\t\t\t      sc);\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\treturn true;\n\t}\n\n\tif (io_req->abts_done)\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"%s: io_req->abts_done is set state is %s\\n\",\n\t\t\t     __func__, fnic_ioreq_state_to_str(fnic_priv(sc)->state));\n\told_ioreq_state = fnic_priv(sc)->state;\n\t \n\tfnic_priv(sc)->state = FNIC_IOREQ_ABTS_PENDING;\n\n\tBUG_ON(io_req->abts_done);\n\n\tif (fnic_priv(sc)->flags & FNIC_DEVICE_RESET) {\n\t\tabt_tag |= FNIC_TAG_DEV_RST;\n\t\tFNIC_SCSI_DBG(KERN_INFO, fnic->lport->host,\n\t\t\t      \"%s: dev rst sc 0x%p\\n\", __func__, sc);\n\t}\n\n\tfnic_priv(sc)->abts_status = FCPIO_INVALID_CODE;\n\tio_req->abts_done = &tm_done;\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\t \n\tint_to_scsilun(sc->device->lun, &fc_lun);\n\n\tif (fnic_queue_abort_io_req(fnic, abt_tag,\n\t\t\t\t    FCPIO_ITMF_ABT_TASK_TERM,\n\t\t\t\t    fc_lun.scsi_lun, io_req)) {\n\t\tspin_lock_irqsave(io_lock, flags);\n\t\tio_req = fnic_priv(sc)->io_req;\n\t\tif (io_req)\n\t\t\tio_req->abts_done = NULL;\n\t\tif (fnic_priv(sc)->state == FNIC_IOREQ_ABTS_PENDING)\n\t\t\tfnic_priv(sc)->state = old_ioreq_state;\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\titer_data->ret = FAILED;\n\t\treturn false;\n\t} else {\n\t\tspin_lock_irqsave(io_lock, flags);\n\t\tif (fnic_priv(sc)->flags & FNIC_DEVICE_RESET)\n\t\t\tfnic_priv(sc)->flags |= FNIC_DEV_RST_TERM_ISSUED;\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t}\n\tfnic_priv(sc)->flags |= FNIC_IO_INTERNAL_TERM_ISSUED;\n\n\twait_for_completion_timeout(&tm_done, msecs_to_jiffies\n\t\t\t\t    (fnic->config.ed_tov));\n\n\t \n\tspin_lock_irqsave(io_lock, flags);\n\tio_req = fnic_priv(sc)->io_req;\n\tif (!io_req) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tfnic_priv(sc)->flags |= FNIC_IO_ABT_TERM_REQ_NULL;\n\t\treturn true;\n\t}\n\n\tio_req->abts_done = NULL;\n\n\t \n\tif (fnic_priv(sc)->abts_status == FCPIO_INVALID_CODE) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tfnic_priv(sc)->flags |= FNIC_IO_ABT_TERM_DONE;\n\t\titer_data->ret = FAILED;\n\t\treturn false;\n\t}\n\tfnic_priv(sc)->state = FNIC_IOREQ_ABTS_COMPLETE;\n\n\t \n\tif (sc != iter_data->lr_sc)\n\t\tfnic_priv(sc)->io_req = NULL;\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\t \n\tif (sc != iter_data->lr_sc) {\n\t\tfnic_release_ioreq_buf(fnic, io_req, sc);\n\t\tmempool_free(io_req, fnic->io_req_pool);\n\t}\n\n\t \n\t \n\tsc->result = DID_RESET << 16;\n\tscsi_done(sc);\n\n\treturn true;\n}\n\n \nstatic int fnic_clean_pending_aborts(struct fnic *fnic,\n\t\t\t\t     struct scsi_cmnd *lr_sc,\n\t\t\t\t     bool new_sc)\n\n{\n\tint ret = 0;\n\tstruct fnic_pending_aborts_iter_data iter_data = {\n\t\t.fnic = fnic,\n\t\t.lun_dev = lr_sc->device,\n\t\t.ret = SUCCESS,\n\t};\n\n\titer_data.lr_sc = lr_sc;\n\n\tscsi_host_busy_iter(fnic->lport->host,\n\t\t\t    fnic_pending_aborts_iter, &iter_data);\n\tif (iter_data.ret == FAILED) {\n\t\tret = iter_data.ret;\n\t\tgoto clean_pending_aborts_end;\n\t}\n\tschedule_timeout(msecs_to_jiffies(2 * fnic->config.ed_tov));\n\n\t \n\tif (fnic_is_abts_pending(fnic, lr_sc))\n\t\tret = 1;\n\nclean_pending_aborts_end:\n\tFNIC_SCSI_DBG(KERN_INFO, fnic->lport->host,\n\t\t\t\"%s: exit status: %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n \nint fnic_device_reset(struct scsi_cmnd *sc)\n{\n\tstruct request *rq = scsi_cmd_to_rq(sc);\n\tstruct fc_lport *lp;\n\tstruct fnic *fnic;\n\tstruct fnic_io_req *io_req = NULL;\n\tstruct fc_rport *rport;\n\tint status;\n\tint ret = FAILED;\n\tspinlock_t *io_lock;\n\tunsigned long flags;\n\tunsigned long start_time = 0;\n\tstruct scsi_lun fc_lun;\n\tstruct fnic_stats *fnic_stats;\n\tstruct reset_stats *reset_stats;\n\tint tag = rq->tag;\n\tDECLARE_COMPLETION_ONSTACK(tm_done);\n\tbool new_sc = 0;\n\n\t \n\tfc_block_scsi_eh(sc);\n\n\t \n\tlp = shost_priv(sc->device->host);\n\n\tfnic = lport_priv(lp);\n\tfnic_stats = &fnic->fnic_stats;\n\treset_stats = &fnic->fnic_stats.reset_stats;\n\n\tatomic64_inc(&reset_stats->device_resets);\n\n\trport = starget_to_rport(scsi_target(sc->device));\n\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t      \"Device reset called FCID 0x%x, LUN 0x%llx sc 0x%p\\n\",\n\t\t      rport->port_id, sc->device->lun, sc);\n\n\tif (lp->state != LPORT_ST_READY || !(lp->link_up))\n\t\tgoto fnic_device_reset_end;\n\n\t \n\tif (fc_remote_port_chkready(rport)) {\n\t\tatomic64_inc(&fnic_stats->misc_stats.rport_not_ready);\n\t\tgoto fnic_device_reset_end;\n\t}\n\n\tfnic_priv(sc)->flags = FNIC_DEVICE_RESET;\n\n\tif (unlikely(tag < 0)) {\n\t\t \n\t\tmutex_lock(&fnic->sgreset_mutex);\n\t\ttag = fnic->fnic_max_tag_id;\n\t\tnew_sc = 1;\n\t\tfnic->sgreset_sc = sc;\n\t\tio_lock = &fnic->sgreset_lock;\n\t\tFNIC_SCSI_DBG(KERN_INFO, fnic->lport->host,\n\t\t\t\"fcid: 0x%x lun: 0x%llx flags: 0x%x tag: 0x%x Issuing sgreset\\n\",\n\t\t\trport->port_id, sc->device->lun, fnic_priv(sc)->flags, tag);\n\t} else\n\t\tio_lock = fnic_io_lock_hash(fnic, sc);\n\n\tspin_lock_irqsave(io_lock, flags);\n\tio_req = fnic_priv(sc)->io_req;\n\n\t \n\tif (!io_req) {\n\t\tio_req = mempool_alloc(fnic->io_req_pool, GFP_ATOMIC);\n\t\tif (!io_req) {\n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\t\tgoto fnic_device_reset_end;\n\t\t}\n\t\tmemset(io_req, 0, sizeof(*io_req));\n\t\tio_req->port_id = rport->port_id;\n\t\tio_req->tag = tag;\n\t\tio_req->sc = sc;\n\t\tfnic_priv(sc)->io_req = io_req;\n\t}\n\tio_req->dr_done = &tm_done;\n\tfnic_priv(sc)->state = FNIC_IOREQ_CMD_PENDING;\n\tfnic_priv(sc)->lr_status = FCPIO_INVALID_CODE;\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, \"TAG %x\\n\", tag);\n\n\t \n\tif (fnic_queue_dr_io_req(fnic, sc, io_req)) {\n\t\tspin_lock_irqsave(io_lock, flags);\n\t\tio_req = fnic_priv(sc)->io_req;\n\t\tif (io_req)\n\t\t\tio_req->dr_done = NULL;\n\t\tgoto fnic_device_reset_clean;\n\t}\n\tspin_lock_irqsave(io_lock, flags);\n\tfnic_priv(sc)->flags |= FNIC_DEV_RST_ISSUED;\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\t \n\twait_for_completion_timeout(&tm_done,\n\t\t\t\t    msecs_to_jiffies(FNIC_LUN_RESET_TIMEOUT));\n\n\tspin_lock_irqsave(io_lock, flags);\n\tio_req = fnic_priv(sc)->io_req;\n\tif (!io_req) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t\"io_req is null tag 0x%x sc 0x%p\\n\", tag, sc);\n\t\tgoto fnic_device_reset_end;\n\t}\n\tio_req->dr_done = NULL;\n\n\tstatus = fnic_priv(sc)->lr_status;\n\n\t \n\tif (status == FCPIO_INVALID_CODE) {\n\t\tatomic64_inc(&reset_stats->device_reset_timeouts);\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t      \"Device reset timed out\\n\");\n\t\tfnic_priv(sc)->flags |= FNIC_DEV_RST_TIMED_OUT;\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tint_to_scsilun(sc->device->lun, &fc_lun);\n\t\t \n\t\twhile (1) {\n\t\t\tspin_lock_irqsave(io_lock, flags);\n\t\t\tif (fnic_priv(sc)->flags & FNIC_DEV_RST_TERM_ISSUED) {\n\t\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\t\tif (fnic_queue_abort_io_req(fnic,\n\t\t\t\ttag | FNIC_TAG_DEV_RST,\n\t\t\t\tFCPIO_ITMF_ABT_TASK_TERM,\n\t\t\t\tfc_lun.scsi_lun, io_req)) {\n\t\t\t\twait_for_completion_timeout(&tm_done,\n\t\t\t\tmsecs_to_jiffies(FNIC_ABT_TERM_DELAY_TIMEOUT));\n\t\t\t} else {\n\t\t\t\tspin_lock_irqsave(io_lock, flags);\n\t\t\t\tfnic_priv(sc)->flags |= FNIC_DEV_RST_TERM_ISSUED;\n\t\t\t\tfnic_priv(sc)->state = FNIC_IOREQ_ABTS_PENDING;\n\t\t\t\tio_req->abts_done = &tm_done;\n\t\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\t\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\t\"Abort and terminate issued on Device reset \"\n\t\t\t\t\"tag 0x%x sc 0x%p\\n\", tag, sc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile (1) {\n\t\t\tspin_lock_irqsave(io_lock, flags);\n\t\t\tif (!(fnic_priv(sc)->flags & FNIC_DEV_RST_DONE)) {\n\t\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\t\t\twait_for_completion_timeout(&tm_done,\n\t\t\t\tmsecs_to_jiffies(FNIC_LUN_RESET_TIMEOUT));\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tio_req = fnic_priv(sc)->io_req;\n\t\t\t\tio_req->abts_done = NULL;\n\t\t\t\tgoto fnic_device_reset_clean;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t}\n\n\t \n\tif (status != FCPIO_SUCCESS) {\n\t\tspin_lock_irqsave(io_lock, flags);\n\t\tFNIC_SCSI_DBG(KERN_DEBUG,\n\t\t\t      fnic->lport->host,\n\t\t\t      \"Device reset completed - failed\\n\");\n\t\tio_req = fnic_priv(sc)->io_req;\n\t\tgoto fnic_device_reset_clean;\n\t}\n\n\t \n\tif (fnic_clean_pending_aborts(fnic, sc, new_sc)) {\n\t\tspin_lock_irqsave(io_lock, flags);\n\t\tio_req = fnic_priv(sc)->io_req;\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t      \"Device reset failed\"\n\t\t\t      \" since could not abort all IOs\\n\");\n\t\tgoto fnic_device_reset_clean;\n\t}\n\n\t \n\tspin_lock_irqsave(io_lock, flags);\n\tio_req = fnic_priv(sc)->io_req;\n\tif (io_req)\n\t\t \n\t\tret = SUCCESS;\n\nfnic_device_reset_clean:\n\tif (io_req)\n\t\tfnic_priv(sc)->io_req = NULL;\n\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\tif (io_req) {\n\t\tstart_time = io_req->start_time;\n\t\tfnic_release_ioreq_buf(fnic, io_req, sc);\n\t\tmempool_free(io_req, fnic->io_req_pool);\n\t}\n\nfnic_device_reset_end:\n\tFNIC_TRACE(fnic_device_reset, sc->device->host->host_no, rq->tag, sc,\n\t\t  jiffies_to_msecs(jiffies - start_time),\n\t\t  0, ((u64)sc->cmnd[0] << 32 |\n\t\t  (u64)sc->cmnd[2] << 24 | (u64)sc->cmnd[3] << 16 |\n\t\t  (u64)sc->cmnd[4] << 8 | sc->cmnd[5]),\n\t\t  fnic_flags_and_state(sc));\n\n\tif (new_sc) {\n\t\tfnic->sgreset_sc = NULL;\n\t\tmutex_unlock(&fnic->sgreset_mutex);\n\t}\n\n\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t      \"Returning from device reset %s\\n\",\n\t\t      (ret == SUCCESS) ?\n\t\t      \"SUCCESS\" : \"FAILED\");\n\n\tif (ret == FAILED)\n\t\tatomic64_inc(&reset_stats->device_reset_failures);\n\n\treturn ret;\n}\n\n \nint fnic_reset(struct Scsi_Host *shost)\n{\n\tstruct fc_lport *lp;\n\tstruct fnic *fnic;\n\tint ret = 0;\n\tstruct reset_stats *reset_stats;\n\n\tlp = shost_priv(shost);\n\tfnic = lport_priv(lp);\n\treset_stats = &fnic->fnic_stats.reset_stats;\n\n\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t      \"fnic_reset called\\n\");\n\n\tatomic64_inc(&reset_stats->fnic_resets);\n\n\t \n\tret = fc_lport_reset(lp);\n\n\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t      \"Returning from fnic reset %s\\n\",\n\t\t      (ret == 0) ?\n\t\t      \"SUCCESS\" : \"FAILED\");\n\n\tif (ret == 0)\n\t\tatomic64_inc(&reset_stats->fnic_reset_completions);\n\telse\n\t\tatomic64_inc(&reset_stats->fnic_reset_failures);\n\n\treturn ret;\n}\n\n \nint fnic_host_reset(struct scsi_cmnd *sc)\n{\n\tint ret;\n\tunsigned long wait_host_tmo;\n\tstruct Scsi_Host *shost = sc->device->host;\n\tstruct fc_lport *lp = shost_priv(shost);\n\tstruct fnic *fnic = lport_priv(lp);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tif (!fnic->internal_reset_inprogress) {\n\t\tfnic->internal_reset_inprogress = true;\n\t} else {\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t\t\"host reset in progress skipping another host reset\\n\");\n\t\treturn SUCCESS;\n\t}\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\t \n\tret = (fnic_reset(shost) == 0) ? SUCCESS : FAILED;\n\tif (ret == SUCCESS) {\n\t\twait_host_tmo = jiffies + FNIC_HOST_RESET_SETTLE_TIME * HZ;\n\t\tret = FAILED;\n\t\twhile (time_before(jiffies, wait_host_tmo)) {\n\t\t\tif ((lp->state == LPORT_ST_READY) &&\n\t\t\t    (lp->link_up)) {\n\t\t\t\tret = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tssleep(1);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tfnic->internal_reset_inprogress = false;\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\treturn ret;\n}\n\n \nvoid fnic_scsi_abort_io(struct fc_lport *lp)\n{\n\tint err = 0;\n\tunsigned long flags;\n\tenum fnic_state old_state;\n\tstruct fnic *fnic = lport_priv(lp);\n\tDECLARE_COMPLETION_ONSTACK(remove_wait);\n\n\t \nretry_fw_reset:\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tif (unlikely(fnic->state == FNIC_IN_FC_TRANS_ETH_MODE) &&\n\t\t     fnic->link_events) {\n\t\t \n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\tschedule_timeout(msecs_to_jiffies(100));\n\t\tgoto retry_fw_reset;\n\t}\n\n\tfnic->remove_wait = &remove_wait;\n\told_state = fnic->state;\n\tfnic->state = FNIC_IN_FC_TRANS_ETH_MODE;\n\tfnic_update_mac_locked(fnic, fnic->ctlr.ctl_src_addr);\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\terr = fnic_fw_reset_handler(fnic);\n\tif (err) {\n\t\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\t\tif (fnic->state == FNIC_IN_FC_TRANS_ETH_MODE)\n\t\t\tfnic->state = old_state;\n\t\tfnic->remove_wait = NULL;\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\twait_for_completion_timeout(&remove_wait,\n\t\t\t\t    msecs_to_jiffies(FNIC_RMDEVICE_TIMEOUT));\n\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tfnic->remove_wait = NULL;\n\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,\n\t\t      \"fnic_scsi_abort_io %s\\n\",\n\t\t      (fnic->state == FNIC_IN_ETH_MODE) ?\n\t\t      \"SUCCESS\" : \"FAILED\");\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n}\n\n \nvoid fnic_scsi_cleanup(struct fc_lport *lp)\n{\n\tunsigned long flags;\n\tenum fnic_state old_state;\n\tstruct fnic *fnic = lport_priv(lp);\n\n\t \nretry_fw_reset:\n\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\tif (unlikely(fnic->state == FNIC_IN_FC_TRANS_ETH_MODE)) {\n\t\t \n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t\tschedule_timeout(msecs_to_jiffies(100));\n\t\tgoto retry_fw_reset;\n\t}\n\told_state = fnic->state;\n\tfnic->state = FNIC_IN_FC_TRANS_ETH_MODE;\n\tfnic_update_mac_locked(fnic, fnic->ctlr.ctl_src_addr);\n\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\n\tif (fnic_fw_reset_handler(fnic)) {\n\t\tspin_lock_irqsave(&fnic->fnic_lock, flags);\n\t\tif (fnic->state == FNIC_IN_FC_TRANS_ETH_MODE)\n\t\t\tfnic->state = old_state;\n\t\tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n\t}\n\n}\n\nvoid fnic_empty_scsi_cleanup(struct fc_lport *lp)\n{\n}\n\nvoid fnic_exch_mgr_reset(struct fc_lport *lp, u32 sid, u32 did)\n{\n\tstruct fnic *fnic = lport_priv(lp);\n\n\t \n\tif (sid)\n\t\tgoto call_fc_exch_mgr_reset;\n\n\tif (did) {\n\t\tfnic_rport_exch_reset(fnic, did);\n\t\tgoto call_fc_exch_mgr_reset;\n\t}\n\n\t \n\tif (!fnic->in_remove)\n\t\tfnic_scsi_cleanup(lp);\n\telse\n\t\tfnic_scsi_abort_io(lp);\n\n\t \ncall_fc_exch_mgr_reset:\n\tfc_exch_mgr_reset(lp, sid, did);\n\n}\n\nstatic bool fnic_abts_pending_iter(struct scsi_cmnd *sc, void *data)\n{\n\tstruct fnic_pending_aborts_iter_data *iter_data = data;\n\tstruct fnic *fnic = iter_data->fnic;\n\tint cmd_state;\n\tstruct fnic_io_req *io_req;\n\tspinlock_t *io_lock;\n\tunsigned long flags;\n\n\t \n\tif (iter_data->lr_sc && sc == iter_data->lr_sc)\n\t\treturn true;\n\tif (iter_data->lun_dev && sc->device != iter_data->lun_dev)\n\t\treturn true;\n\n\tio_lock = fnic_io_lock_hash(fnic, sc);\n\tspin_lock_irqsave(io_lock, flags);\n\n\tio_req = fnic_priv(sc)->io_req;\n\tif (!io_req) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\treturn true;\n\t}\n\n\t \n\tFNIC_SCSI_DBG(KERN_INFO, fnic->lport->host,\n\t\t      \"Found IO in %s on lun\\n\",\n\t\t      fnic_ioreq_state_to_str(fnic_priv(sc)->state));\n\tcmd_state = fnic_priv(sc)->state;\n\tspin_unlock_irqrestore(io_lock, flags);\n\tif (cmd_state == FNIC_IOREQ_ABTS_PENDING)\n\t\titer_data->ret = 1;\n\n\treturn iter_data->ret ? false : true;\n}\n\n \nint fnic_is_abts_pending(struct fnic *fnic, struct scsi_cmnd *lr_sc)\n{\n\tstruct fnic_pending_aborts_iter_data iter_data = {\n\t\t.fnic = fnic,\n\t\t.lun_dev = NULL,\n\t\t.ret = 0,\n\t};\n\n\tif (lr_sc) {\n\t\titer_data.lun_dev = lr_sc->device;\n\t\titer_data.lr_sc = lr_sc;\n\t}\n\n\t \n\tscsi_host_busy_iter(fnic->lport->host,\n\t\t\t    fnic_abts_pending_iter, &iter_data);\n\n\treturn iter_data.ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}