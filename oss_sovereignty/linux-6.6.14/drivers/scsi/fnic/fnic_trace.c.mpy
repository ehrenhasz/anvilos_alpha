{
  "module_name": "fnic_trace.c",
  "hash_id": "d85d34573726b28ea8449e61dad066b347c393cdd6625b4aa91d99f6d84cd2e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/fnic/fnic_trace.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/mempool.h>\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/kallsyms.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include \"fnic_io.h\"\n#include \"fnic.h\"\n\nunsigned int trace_max_pages;\nstatic int fnic_max_trace_entries;\n\nstatic unsigned long fnic_trace_buf_p;\nstatic DEFINE_SPINLOCK(fnic_trace_lock);\n\nstatic fnic_trace_dbg_t fnic_trace_entries;\nint fnic_tracing_enabled = 1;\n\n \n\nstatic int fc_trace_max_entries;\nstatic unsigned long fnic_fc_ctlr_trace_buf_p;\nstatic fnic_trace_dbg_t fc_trace_entries;\nint fnic_fc_tracing_enabled = 1;\nint fnic_fc_trace_cleared = 1;\nstatic DEFINE_SPINLOCK(fnic_fc_trace_lock);\n\n\n \nfnic_trace_data_t *fnic_trace_get_buf(void)\n{\n\tunsigned long fnic_buf_head;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fnic_trace_lock, flags);\n\n\t \n\tfnic_buf_head =\n\t\tfnic_trace_entries.page_offset[fnic_trace_entries.wr_idx];\n\tfnic_trace_entries.wr_idx++;\n\n\t \n\tif (fnic_trace_entries.wr_idx >= fnic_max_trace_entries)\n\t\tfnic_trace_entries.wr_idx = 0;\n\n\t \n\tif (fnic_trace_entries.wr_idx == fnic_trace_entries.rd_idx) {\n\t\tfnic_trace_entries.rd_idx++;\n\t\tif (fnic_trace_entries.rd_idx >= fnic_max_trace_entries)\n\t\t\tfnic_trace_entries.rd_idx = 0;\n\t}\n\tspin_unlock_irqrestore(&fnic_trace_lock, flags);\n\treturn (fnic_trace_data_t *)fnic_buf_head;\n}\n\n \nint fnic_get_trace_data(fnic_dbgfs_t *fnic_dbgfs_prt)\n{\n\tint rd_idx;\n\tint wr_idx;\n\tint len = 0;\n\tunsigned long flags;\n\tchar str[KSYM_SYMBOL_LEN];\n\tstruct timespec64 val;\n\tfnic_trace_data_t *tbp;\n\n\tspin_lock_irqsave(&fnic_trace_lock, flags);\n\trd_idx = fnic_trace_entries.rd_idx;\n\twr_idx = fnic_trace_entries.wr_idx;\n\tif (wr_idx < rd_idx) {\n\t\twhile (1) {\n\t\t\t \n\t\t\ttbp = (fnic_trace_data_t *)\n\t\t\t\t  fnic_trace_entries.page_offset[rd_idx];\n\t\t\tif (!tbp) {\n\t\t\t\tspin_unlock_irqrestore(&fnic_trace_lock, flags);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\tif (sizeof(unsigned long) < 8) {\n\t\t\t\tsprint_symbol(str, tbp->fnaddr.low);\n\t\t\t\tjiffies_to_timespec64(tbp->timestamp.low, &val);\n\t\t\t} else {\n\t\t\t\tsprint_symbol(str, tbp->fnaddr.val);\n\t\t\t\tjiffies_to_timespec64(tbp->timestamp.val, &val);\n\t\t\t}\n\t\t\t \n\t\t\tlen += scnprintf(fnic_dbgfs_prt->buffer + len,\n\t\t\t\t  (trace_max_pages * PAGE_SIZE * 3) - len,\n\t\t\t\t  \"%16llu.%09lu %-50s %8x %8x %16llx %16llx \"\n\t\t\t\t  \"%16llx %16llx %16llx\\n\", (u64)val.tv_sec,\n\t\t\t\t  val.tv_nsec, str, tbp->host_no, tbp->tag,\n\t\t\t\t  tbp->data[0], tbp->data[1], tbp->data[2],\n\t\t\t\t  tbp->data[3], tbp->data[4]);\n\t\t\trd_idx++;\n\t\t\t \n\t\t\tif (rd_idx > (fnic_max_trace_entries-1))\n\t\t\t\trd_idx = 0;\n\t\t\t \n\t\t\tif (rd_idx == wr_idx)\n\t\t\t\tbreak;\n\t\t}\n\t} else if (wr_idx > rd_idx) {\n\t\twhile (1) {\n\t\t\t \n\t\t\ttbp = (fnic_trace_data_t *)\n\t\t\t\t  fnic_trace_entries.page_offset[rd_idx];\n\t\t\tif (!tbp) {\n\t\t\t\tspin_unlock_irqrestore(&fnic_trace_lock, flags);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\tif (sizeof(unsigned long) < 8) {\n\t\t\t\tsprint_symbol(str, tbp->fnaddr.low);\n\t\t\t\tjiffies_to_timespec64(tbp->timestamp.low, &val);\n\t\t\t} else {\n\t\t\t\tsprint_symbol(str, tbp->fnaddr.val);\n\t\t\t\tjiffies_to_timespec64(tbp->timestamp.val, &val);\n\t\t\t}\n\t\t\t \n\t\t\tlen += scnprintf(fnic_dbgfs_prt->buffer + len,\n\t\t\t\t  (trace_max_pages * PAGE_SIZE * 3) - len,\n\t\t\t\t  \"%16llu.%09lu %-50s %8x %8x %16llx %16llx \"\n\t\t\t\t  \"%16llx %16llx %16llx\\n\", (u64)val.tv_sec,\n\t\t\t\t  val.tv_nsec, str, tbp->host_no, tbp->tag,\n\t\t\t\t  tbp->data[0], tbp->data[1], tbp->data[2],\n\t\t\t\t  tbp->data[3], tbp->data[4]);\n\t\t\trd_idx++;\n\t\t\t \n\t\t\tif (rd_idx == wr_idx)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&fnic_trace_lock, flags);\n\treturn len;\n}\n\n \nint fnic_get_stats_data(struct stats_debug_info *debug,\n\t\t\tstruct fnic_stats *stats)\n{\n\tint len = 0;\n\tint buf_size = debug->buf_size;\n\tstruct timespec64 val1, val2;\n\n\tktime_get_real_ts64(&val1);\n\tlen = scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t\"------------------------------------------\\n\"\n\t\t \"\\t\\tTime\\n\"\n\t\t\"------------------------------------------\\n\");\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t\"Current time :          [%lld:%ld]\\n\"\n\t\t\"Last stats reset time:  [%lld:%09ld]\\n\"\n\t\t\"Last stats read time:   [%lld:%ld]\\n\"\n\t\t\"delta since last reset: [%lld:%ld]\\n\"\n\t\t\"delta since last read:  [%lld:%ld]\\n\",\n\t(s64)val1.tv_sec, val1.tv_nsec,\n\t(s64)stats->stats_timestamps.last_reset_time.tv_sec,\n\tstats->stats_timestamps.last_reset_time.tv_nsec,\n\t(s64)stats->stats_timestamps.last_read_time.tv_sec,\n\tstats->stats_timestamps.last_read_time.tv_nsec,\n\t(s64)timespec64_sub(val1, stats->stats_timestamps.last_reset_time).tv_sec,\n\ttimespec64_sub(val1, stats->stats_timestamps.last_reset_time).tv_nsec,\n\t(s64)timespec64_sub(val1, stats->stats_timestamps.last_read_time).tv_sec,\n\ttimespec64_sub(val1, stats->stats_timestamps.last_read_time).tv_nsec);\n\n\tstats->stats_timestamps.last_read_time = val1;\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t  \"------------------------------------------\\n\"\n\t\t  \"\\t\\tIO Statistics\\n\"\n\t\t  \"------------------------------------------\\n\");\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t  \"Number of Active IOs: %lld\\nMaximum Active IOs: %lld\\n\"\n\t\t  \"Number of IOs: %lld\\nNumber of IO Completions: %lld\\n\"\n\t\t  \"Number of IO Failures: %lld\\nNumber of IO NOT Found: %lld\\n\"\n\t\t  \"Number of Memory alloc Failures: %lld\\n\"\n\t\t  \"Number of IOREQ Null: %lld\\n\"\n\t\t  \"Number of SCSI cmd pointer Null: %lld\\n\"\n\n\t\t  \"\\nIO completion times: \\n\"\n\t\t  \"            < 10 ms : %lld\\n\"\n\t\t  \"     10 ms - 100 ms : %lld\\n\"\n\t\t  \"    100 ms - 500 ms : %lld\\n\"\n\t\t  \"    500 ms -   5 sec: %lld\\n\"\n\t\t  \"     5 sec -  10 sec: %lld\\n\"\n\t\t  \"    10 sec -  30 sec: %lld\\n\"\n\t\t  \"            > 30 sec: %lld\\n\",\n\t\t  (u64)atomic64_read(&stats->io_stats.active_ios),\n\t\t  (u64)atomic64_read(&stats->io_stats.max_active_ios),\n\t\t  (u64)atomic64_read(&stats->io_stats.num_ios),\n\t\t  (u64)atomic64_read(&stats->io_stats.io_completions),\n\t\t  (u64)atomic64_read(&stats->io_stats.io_failures),\n\t\t  (u64)atomic64_read(&stats->io_stats.io_not_found),\n\t\t  (u64)atomic64_read(&stats->io_stats.alloc_failures),\n\t\t  (u64)atomic64_read(&stats->io_stats.ioreq_null),\n\t\t  (u64)atomic64_read(&stats->io_stats.sc_null),\n\t\t  (u64)atomic64_read(&stats->io_stats.io_btw_0_to_10_msec),\n\t\t  (u64)atomic64_read(&stats->io_stats.io_btw_10_to_100_msec),\n\t\t  (u64)atomic64_read(&stats->io_stats.io_btw_100_to_500_msec),\n\t\t  (u64)atomic64_read(&stats->io_stats.io_btw_500_to_5000_msec),\n\t\t  (u64)atomic64_read(&stats->io_stats.io_btw_5000_to_10000_msec),\n\t\t  (u64)atomic64_read(&stats->io_stats.io_btw_10000_to_30000_msec),\n\t\t  (u64)atomic64_read(&stats->io_stats.io_greater_than_30000_msec));\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t  \"\\nCurrent Max IO time : %lld\\n\",\n\t\t  (u64)atomic64_read(&stats->io_stats.current_max_io_time));\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t  \"\\n------------------------------------------\\n\"\n\t\t  \"\\t\\tAbort Statistics\\n\"\n\t\t  \"------------------------------------------\\n\");\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t  \"Number of Aborts: %lld\\n\"\n\t\t  \"Number of Abort Failures: %lld\\n\"\n\t\t  \"Number of Abort Driver Timeouts: %lld\\n\"\n\t\t  \"Number of Abort FW Timeouts: %lld\\n\"\n\t\t  \"Number of Abort IO NOT Found: %lld\\n\"\n\n\t\t  \"Abort issued times: \\n\"\n\t\t  \"            < 6 sec : %lld\\n\"\n\t\t  \"     6 sec - 20 sec : %lld\\n\"\n\t\t  \"    20 sec - 30 sec : %lld\\n\"\n\t\t  \"    30 sec - 40 sec : %lld\\n\"\n\t\t  \"    40 sec - 50 sec : %lld\\n\"\n\t\t  \"    50 sec - 60 sec : %lld\\n\"\n\t\t  \"            > 60 sec: %lld\\n\",\n\n\t\t  (u64)atomic64_read(&stats->abts_stats.aborts),\n\t\t  (u64)atomic64_read(&stats->abts_stats.abort_failures),\n\t\t  (u64)atomic64_read(&stats->abts_stats.abort_drv_timeouts),\n\t\t  (u64)atomic64_read(&stats->abts_stats.abort_fw_timeouts),\n\t\t  (u64)atomic64_read(&stats->abts_stats.abort_io_not_found),\n\t\t  (u64)atomic64_read(&stats->abts_stats.abort_issued_btw_0_to_6_sec),\n\t\t  (u64)atomic64_read(&stats->abts_stats.abort_issued_btw_6_to_20_sec),\n\t\t  (u64)atomic64_read(&stats->abts_stats.abort_issued_btw_20_to_30_sec),\n\t\t  (u64)atomic64_read(&stats->abts_stats.abort_issued_btw_30_to_40_sec),\n\t\t  (u64)atomic64_read(&stats->abts_stats.abort_issued_btw_40_to_50_sec),\n\t\t  (u64)atomic64_read(&stats->abts_stats.abort_issued_btw_50_to_60_sec),\n\t\t  (u64)atomic64_read(&stats->abts_stats.abort_issued_greater_than_60_sec));\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t  \"\\n------------------------------------------\\n\"\n\t\t  \"\\t\\tTerminate Statistics\\n\"\n\t\t  \"------------------------------------------\\n\");\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t  \"Number of Terminates: %lld\\n\"\n\t\t  \"Maximum Terminates: %lld\\n\"\n\t\t  \"Number of Terminate Driver Timeouts: %lld\\n\"\n\t\t  \"Number of Terminate FW Timeouts: %lld\\n\"\n\t\t  \"Number of Terminate IO NOT Found: %lld\\n\"\n\t\t  \"Number of Terminate Failures: %lld\\n\",\n\t\t  (u64)atomic64_read(&stats->term_stats.terminates),\n\t\t  (u64)atomic64_read(&stats->term_stats.max_terminates),\n\t\t  (u64)atomic64_read(&stats->term_stats.terminate_drv_timeouts),\n\t\t  (u64)atomic64_read(&stats->term_stats.terminate_fw_timeouts),\n\t\t  (u64)atomic64_read(&stats->term_stats.terminate_io_not_found),\n\t\t  (u64)atomic64_read(&stats->term_stats.terminate_failures));\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t  \"\\n------------------------------------------\\n\"\n\t\t  \"\\t\\tReset Statistics\\n\"\n\t\t  \"------------------------------------------\\n\");\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t  \"Number of Device Resets: %lld\\n\"\n\t\t  \"Number of Device Reset Failures: %lld\\n\"\n\t\t  \"Number of Device Reset Aborts: %lld\\n\"\n\t\t  \"Number of Device Reset Timeouts: %lld\\n\"\n\t\t  \"Number of Device Reset Terminates: %lld\\n\"\n\t\t  \"Number of FW Resets: %lld\\n\"\n\t\t  \"Number of FW Reset Completions: %lld\\n\"\n\t\t  \"Number of FW Reset Failures: %lld\\n\"\n\t\t  \"Number of Fnic Reset: %lld\\n\"\n\t\t  \"Number of Fnic Reset Completions: %lld\\n\"\n\t\t  \"Number of Fnic Reset Failures: %lld\\n\",\n\t\t  (u64)atomic64_read(&stats->reset_stats.device_resets),\n\t\t  (u64)atomic64_read(&stats->reset_stats.device_reset_failures),\n\t\t  (u64)atomic64_read(&stats->reset_stats.device_reset_aborts),\n\t\t  (u64)atomic64_read(&stats->reset_stats.device_reset_timeouts),\n\t\t  (u64)atomic64_read(\n\t\t\t  &stats->reset_stats.device_reset_terminates),\n\t\t  (u64)atomic64_read(&stats->reset_stats.fw_resets),\n\t\t  (u64)atomic64_read(&stats->reset_stats.fw_reset_completions),\n\t\t  (u64)atomic64_read(&stats->reset_stats.fw_reset_failures),\n\t\t  (u64)atomic64_read(&stats->reset_stats.fnic_resets),\n\t\t  (u64)atomic64_read(\n\t\t\t  &stats->reset_stats.fnic_reset_completions),\n\t\t  (u64)atomic64_read(&stats->reset_stats.fnic_reset_failures));\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t  \"\\n------------------------------------------\\n\"\n\t\t  \"\\t\\tFirmware Statistics\\n\"\n\t\t  \"------------------------------------------\\n\");\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t  \"Number of Active FW Requests %lld\\n\"\n\t\t  \"Maximum FW Requests: %lld\\n\"\n\t\t  \"Number of FW out of resources: %lld\\n\"\n\t\t  \"Number of FW IO errors: %lld\\n\",\n\t\t  (u64)atomic64_read(&stats->fw_stats.active_fw_reqs),\n\t\t  (u64)atomic64_read(&stats->fw_stats.max_fw_reqs),\n\t\t  (u64)atomic64_read(&stats->fw_stats.fw_out_of_resources),\n\t\t  (u64)atomic64_read(&stats->fw_stats.io_fw_errs));\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t  \"\\n------------------------------------------\\n\"\n\t\t  \"\\t\\tVlan Discovery Statistics\\n\"\n\t\t  \"------------------------------------------\\n\");\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t  \"Number of Vlan Discovery Requests Sent %lld\\n\"\n\t\t  \"Vlan Response Received with no FCF VLAN ID: %lld\\n\"\n\t\t  \"No solicitations recvd after vlan set, expiry count: %lld\\n\"\n\t\t  \"Flogi rejects count: %lld\\n\",\n\t\t  (u64)atomic64_read(&stats->vlan_stats.vlan_disc_reqs),\n\t\t  (u64)atomic64_read(&stats->vlan_stats.resp_withno_vlanID),\n\t\t  (u64)atomic64_read(&stats->vlan_stats.sol_expiry_count),\n\t\t  (u64)atomic64_read(&stats->vlan_stats.flogi_rejects));\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t  \"\\n------------------------------------------\\n\"\n\t\t  \"\\t\\tOther Important Statistics\\n\"\n\t\t  \"------------------------------------------\\n\");\n\n\tjiffies_to_timespec64(stats->misc_stats.last_isr_time, &val1);\n\tjiffies_to_timespec64(stats->misc_stats.last_ack_time, &val2);\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t  \"Last ISR time: %llu (%8llu.%09lu)\\n\"\n\t\t  \"Last ACK time: %llu (%8llu.%09lu)\\n\"\n\t\t  \"Max ISR jiffies: %llu\\n\"\n\t\t  \"Max ISR time (ms) (0 denotes < 1 ms): %llu\\n\"\n\t\t  \"Corr. work done: %llu\\n\"\n\t\t  \"Number of ISRs: %lld\\n\"\n\t\t  \"Maximum CQ Entries: %lld\\n\"\n\t\t  \"Number of ACK index out of range: %lld\\n\"\n\t\t  \"Number of data count mismatch: %lld\\n\"\n\t\t  \"Number of FCPIO Timeouts: %lld\\n\"\n\t\t  \"Number of FCPIO Aborted: %lld\\n\"\n\t\t  \"Number of SGL Invalid: %lld\\n\"\n\t\t  \"Number of Copy WQ Alloc Failures for ABTs: %lld\\n\"\n\t\t  \"Number of Copy WQ Alloc Failures for Device Reset: %lld\\n\"\n\t\t  \"Number of Copy WQ Alloc Failures for IOs: %lld\\n\"\n\t\t  \"Number of no icmnd itmf Completions: %lld\\n\"\n\t\t  \"Number of Check Conditions encountered: %lld\\n\"\n\t\t  \"Number of QUEUE Fulls: %lld\\n\"\n\t\t  \"Number of rport not ready: %lld\\n\"\n\t\t  \"Number of receive frame errors: %lld\\n\",\n\t\t  (u64)stats->misc_stats.last_isr_time,\n\t\t  (s64)val1.tv_sec, val1.tv_nsec,\n\t\t  (u64)stats->misc_stats.last_ack_time,\n\t\t  (s64)val2.tv_sec, val2.tv_nsec,\n\t\t  (u64)atomic64_read(&stats->misc_stats.max_isr_jiffies),\n\t\t  (u64)atomic64_read(&stats->misc_stats.max_isr_time_ms),\n\t\t  (u64)atomic64_read(&stats->misc_stats.corr_work_done),\n\t\t  (u64)atomic64_read(&stats->misc_stats.isr_count),\n\t\t  (u64)atomic64_read(&stats->misc_stats.max_cq_entries),\n\t\t  (u64)atomic64_read(&stats->misc_stats.ack_index_out_of_range),\n\t\t  (u64)atomic64_read(&stats->misc_stats.data_count_mismatch),\n\t\t  (u64)atomic64_read(&stats->misc_stats.fcpio_timeout),\n\t\t  (u64)atomic64_read(&stats->misc_stats.fcpio_aborted),\n\t\t  (u64)atomic64_read(&stats->misc_stats.sgl_invalid),\n\t\t  (u64)atomic64_read(\n\t\t\t  &stats->misc_stats.abts_cpwq_alloc_failures),\n\t\t  (u64)atomic64_read(\n\t\t\t  &stats->misc_stats.devrst_cpwq_alloc_failures),\n\t\t  (u64)atomic64_read(&stats->misc_stats.io_cpwq_alloc_failures),\n\t\t  (u64)atomic64_read(&stats->misc_stats.no_icmnd_itmf_cmpls),\n\t\t  (u64)atomic64_read(&stats->misc_stats.check_condition),\n\t\t  (u64)atomic64_read(&stats->misc_stats.queue_fulls),\n\t\t  (u64)atomic64_read(&stats->misc_stats.rport_not_ready),\n\t\t  (u64)atomic64_read(&stats->misc_stats.frame_errors));\n\n\tlen += scnprintf(debug->debug_buffer + len, buf_size - len,\n\t\t\t\"Firmware reported port speed: %llu\\n\",\n\t\t\t(u64)atomic64_read(\n\t\t\t\t&stats->misc_stats.current_port_speed));\n\n\treturn len;\n\n}\n\n \nint fnic_trace_buf_init(void)\n{\n\tunsigned long fnic_buf_head;\n\tint i;\n\tint err = 0;\n\n\ttrace_max_pages = fnic_trace_max_pages;\n\tfnic_max_trace_entries = (trace_max_pages * PAGE_SIZE)/\n\t\t\t\t\t  FNIC_ENTRY_SIZE_BYTES;\n\n\tfnic_trace_buf_p = (unsigned long)vcalloc(trace_max_pages, PAGE_SIZE);\n\tif (!fnic_trace_buf_p) {\n\t\tprintk(KERN_ERR PFX \"Failed to allocate memory \"\n\t\t\t\t  \"for fnic_trace_buf_p\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_fnic_trace_buf_init;\n\t}\n\n\tfnic_trace_entries.page_offset =\n\t\tvmalloc(array_size(fnic_max_trace_entries,\n\t\t\t\t   sizeof(unsigned long)));\n\tif (!fnic_trace_entries.page_offset) {\n\t\tprintk(KERN_ERR PFX \"Failed to allocate memory for\"\n\t\t\t\t  \" page_offset\\n\");\n\t\tif (fnic_trace_buf_p) {\n\t\t\tvfree((void *)fnic_trace_buf_p);\n\t\t\tfnic_trace_buf_p = 0;\n\t\t}\n\t\terr = -ENOMEM;\n\t\tgoto err_fnic_trace_buf_init;\n\t}\n\tmemset((void *)fnic_trace_entries.page_offset, 0,\n\t\t  (fnic_max_trace_entries * sizeof(unsigned long)));\n\tfnic_trace_entries.wr_idx = fnic_trace_entries.rd_idx = 0;\n\tfnic_buf_head = fnic_trace_buf_p;\n\n\t \n\tfor (i = 0; i < fnic_max_trace_entries; i++) {\n\t\tfnic_trace_entries.page_offset[i] = fnic_buf_head;\n\t\tfnic_buf_head += FNIC_ENTRY_SIZE_BYTES;\n\t}\n\tfnic_trace_debugfs_init();\n\tpr_info(\"fnic: Successfully Initialized Trace Buffer\\n\");\n\treturn err;\n\nerr_fnic_trace_buf_init:\n\treturn err;\n}\n\n \nvoid fnic_trace_free(void)\n{\n\tfnic_tracing_enabled = 0;\n\tfnic_trace_debugfs_terminate();\n\tif (fnic_trace_entries.page_offset) {\n\t\tvfree((void *)fnic_trace_entries.page_offset);\n\t\tfnic_trace_entries.page_offset = NULL;\n\t}\n\tif (fnic_trace_buf_p) {\n\t\tvfree((void *)fnic_trace_buf_p);\n\t\tfnic_trace_buf_p = 0;\n\t}\n\tprintk(KERN_INFO PFX \"Successfully Freed Trace Buffer\\n\");\n}\n\n \n\nint fnic_fc_trace_init(void)\n{\n\tunsigned long fc_trace_buf_head;\n\tint err = 0;\n\tint i;\n\n\tfc_trace_max_entries = (fnic_fc_trace_max_pages * PAGE_SIZE)/\n\t\t\t\tFC_TRC_SIZE_BYTES;\n\tfnic_fc_ctlr_trace_buf_p =\n\t\t(unsigned long)vmalloc(array_size(PAGE_SIZE,\n\t\t\t\t\t\t  fnic_fc_trace_max_pages));\n\tif (!fnic_fc_ctlr_trace_buf_p) {\n\t\tpr_err(\"fnic: Failed to allocate memory for \"\n\t\t       \"FC Control Trace Buf\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_fnic_fc_ctlr_trace_buf_init;\n\t}\n\n\tmemset((void *)fnic_fc_ctlr_trace_buf_p, 0,\n\t\t\tfnic_fc_trace_max_pages * PAGE_SIZE);\n\n\t \n\tfc_trace_entries.page_offset =\n\t\tvmalloc(array_size(fc_trace_max_entries,\n\t\t\t\t   sizeof(unsigned long)));\n\tif (!fc_trace_entries.page_offset) {\n\t\tpr_err(\"fnic:Failed to allocate memory for page_offset\\n\");\n\t\tif (fnic_fc_ctlr_trace_buf_p) {\n\t\t\tpr_err(\"fnic: Freeing FC Control Trace Buf\\n\");\n\t\t\tvfree((void *)fnic_fc_ctlr_trace_buf_p);\n\t\t\tfnic_fc_ctlr_trace_buf_p = 0;\n\t\t}\n\t\terr = -ENOMEM;\n\t\tgoto err_fnic_fc_ctlr_trace_buf_init;\n\t}\n\tmemset((void *)fc_trace_entries.page_offset, 0,\n\t       (fc_trace_max_entries * sizeof(unsigned long)));\n\n\tfc_trace_entries.rd_idx = fc_trace_entries.wr_idx = 0;\n\tfc_trace_buf_head = fnic_fc_ctlr_trace_buf_p;\n\n\t \n\tfor (i = 0; i < fc_trace_max_entries; i++) {\n\t\tfc_trace_entries.page_offset[i] = fc_trace_buf_head;\n\t\tfc_trace_buf_head += FC_TRC_SIZE_BYTES;\n\t}\n\tfnic_fc_trace_debugfs_init();\n\tpr_info(\"fnic: Successfully Initialized FC_CTLR Trace Buffer\\n\");\n\treturn err;\n\nerr_fnic_fc_ctlr_trace_buf_init:\n\treturn err;\n}\n\n \nvoid fnic_fc_trace_free(void)\n{\n\tfnic_fc_tracing_enabled = 0;\n\tfnic_fc_trace_debugfs_terminate();\n\tif (fc_trace_entries.page_offset) {\n\t\tvfree((void *)fc_trace_entries.page_offset);\n\t\tfc_trace_entries.page_offset = NULL;\n\t}\n\tif (fnic_fc_ctlr_trace_buf_p) {\n\t\tvfree((void *)fnic_fc_ctlr_trace_buf_p);\n\t\tfnic_fc_ctlr_trace_buf_p = 0;\n\t}\n\tpr_info(\"fnic:Successfully FC_CTLR Freed Trace Buffer\\n\");\n}\n\n \nint fnic_fc_trace_set_data(u32 host_no, u8 frame_type,\n\t\t\t\tchar *frame, u32 fc_trc_frame_len)\n{\n\tunsigned long flags;\n\tstruct fc_trace_hdr *fc_buf;\n\tunsigned long eth_fcoe_hdr_len;\n\tchar *fc_trace;\n\n\tif (fnic_fc_tracing_enabled == 0)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&fnic_fc_trace_lock, flags);\n\n\tif (fnic_fc_trace_cleared == 1) {\n\t\tfc_trace_entries.rd_idx = fc_trace_entries.wr_idx = 0;\n\t\tpr_info(\"fnic: Resetting the read idx\\n\");\n\t\tmemset((void *)fnic_fc_ctlr_trace_buf_p, 0,\n\t\t\t\tfnic_fc_trace_max_pages * PAGE_SIZE);\n\t\tfnic_fc_trace_cleared = 0;\n\t}\n\n\tfc_buf = (struct fc_trace_hdr *)\n\t\tfc_trace_entries.page_offset[fc_trace_entries.wr_idx];\n\n\tfc_trace_entries.wr_idx++;\n\n\tif (fc_trace_entries.wr_idx >= fc_trace_max_entries)\n\t\tfc_trace_entries.wr_idx = 0;\n\n\tif (fc_trace_entries.wr_idx == fc_trace_entries.rd_idx) {\n\t\tfc_trace_entries.rd_idx++;\n\t\tif (fc_trace_entries.rd_idx >= fc_trace_max_entries)\n\t\t\tfc_trace_entries.rd_idx = 0;\n\t}\n\n\tktime_get_real_ts64(&fc_buf->time_stamp);\n\tfc_buf->host_no = host_no;\n\tfc_buf->frame_type = frame_type;\n\n\tfc_trace = (char *)FC_TRACE_ADDRESS(fc_buf);\n\n\t \n\tif (frame_type == FNIC_FC_RECV) {\n\t\teth_fcoe_hdr_len = sizeof(struct ethhdr) +\n\t\t\t\t\tsizeof(struct fcoe_hdr);\n\t\tmemset((char *)fc_trace, 0xff, eth_fcoe_hdr_len);\n\t\t \n\t\tmemcpy((char *)(fc_trace + eth_fcoe_hdr_len), (void *)frame,\n\t\tmin_t(u8, fc_trc_frame_len,\n\t\t\t(u8)(FC_TRC_SIZE_BYTES - FC_TRC_HEADER_SIZE\n\t\t\t\t\t\t- eth_fcoe_hdr_len)));\n\t} else {\n\t\tmemcpy((char *)fc_trace, (void *)frame,\n\t\tmin_t(u8, fc_trc_frame_len,\n\t\t\t(u8)(FC_TRC_SIZE_BYTES - FC_TRC_HEADER_SIZE)));\n\t}\n\n\t \n\tfc_buf->frame_len = fc_trc_frame_len;\n\n\tspin_unlock_irqrestore(&fnic_fc_trace_lock, flags);\n\treturn 0;\n}\n\n \n\nint fnic_fc_trace_get_data(fnic_dbgfs_t *fnic_dbgfs_prt, u8 rdata_flag)\n{\n\tint rd_idx, wr_idx;\n\tunsigned long flags;\n\tint len = 0, j;\n\tstruct fc_trace_hdr *tdata;\n\tchar *fc_trace;\n\n\tspin_lock_irqsave(&fnic_fc_trace_lock, flags);\n\tif (fc_trace_entries.wr_idx == fc_trace_entries.rd_idx) {\n\t\tspin_unlock_irqrestore(&fnic_fc_trace_lock, flags);\n\t\tpr_info(\"fnic: Buffer is empty\\n\");\n\t\treturn 0;\n\t}\n\trd_idx = fc_trace_entries.rd_idx;\n\twr_idx = fc_trace_entries.wr_idx;\n\tif (rdata_flag == 0) {\n\t\tlen += scnprintf(fnic_dbgfs_prt->buffer + len,\n\t\t\t(fnic_fc_trace_max_pages * PAGE_SIZE * 3) - len,\n\t\t\t\"Time Stamp (UTC)\\t\\t\"\n\t\t\t\"Host No:   F Type:  len:     FCoE_FRAME:\\n\");\n\t}\n\n\twhile (rd_idx != wr_idx) {\n\t\ttdata = (struct fc_trace_hdr *)\n\t\t\tfc_trace_entries.page_offset[rd_idx];\n\t\tif (!tdata) {\n\t\t\tpr_info(\"fnic: Rd data is NULL\\n\");\n\t\t\tspin_unlock_irqrestore(&fnic_fc_trace_lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t\tif (rdata_flag == 0) {\n\t\t\tcopy_and_format_trace_data(tdata,\n\t\t\t\tfnic_dbgfs_prt, &len, rdata_flag);\n\t\t} else {\n\t\t\tfc_trace = (char *)tdata;\n\t\t\tfor (j = 0; j < FC_TRC_SIZE_BYTES; j++) {\n\t\t\t\tlen += scnprintf(fnic_dbgfs_prt->buffer + len,\n\t\t\t\t(fnic_fc_trace_max_pages * PAGE_SIZE * 3)\n\t\t\t\t- len, \"%02x\", fc_trace[j] & 0xff);\n\t\t\t}  \n\t\t\tlen += scnprintf(fnic_dbgfs_prt->buffer + len,\n\t\t\t\t(fnic_fc_trace_max_pages * PAGE_SIZE * 3) - len,\n\t\t\t\t\"\\n\");\n\t\t}\n\t\trd_idx++;\n\t\tif (rd_idx > (fc_trace_max_entries - 1))\n\t\t\trd_idx = 0;\n\t}\n\n\tspin_unlock_irqrestore(&fnic_fc_trace_lock, flags);\n\treturn len;\n}\n\n \n\nvoid copy_and_format_trace_data(struct fc_trace_hdr *tdata,\n\t\t\t\tfnic_dbgfs_t *fnic_dbgfs_prt, int *orig_len,\n\t\t\t\tu8 rdata_flag)\n{\n\tint j, i = 1, len;\n\tint ethhdr_len = sizeof(struct ethhdr) - 1;\n\tint fcoehdr_len = sizeof(struct fcoe_hdr);\n\tint fchdr_len = sizeof(struct fc_frame_header);\n\tint max_size = fnic_fc_trace_max_pages * PAGE_SIZE * 3;\n\tchar *fc_trace;\n\n\ttdata->frame_type = tdata->frame_type & 0x7F;\n\n\tlen = *orig_len;\n\n\tlen += scnprintf(fnic_dbgfs_prt->buffer + len, max_size - len,\n\t\t\t \"%ptTs.%09lu ns%8x       %c%8x\\t\",\n\t\t\t &tdata->time_stamp.tv_sec, tdata->time_stamp.tv_nsec,\n\t\t\t tdata->host_no, tdata->frame_type, tdata->frame_len);\n\n\tfc_trace = (char *)FC_TRACE_ADDRESS(tdata);\n\n\tfor (j = 0; j < min_t(u8, tdata->frame_len,\n\t\t(u8)(FC_TRC_SIZE_BYTES - FC_TRC_HEADER_SIZE)); j++) {\n\t\tif (tdata->frame_type == FNIC_FC_LE) {\n\t\t\tlen += scnprintf(fnic_dbgfs_prt->buffer + len,\n\t\t\t\tmax_size - len, \"%c\", fc_trace[j]);\n\t\t} else {\n\t\t\tlen += scnprintf(fnic_dbgfs_prt->buffer + len,\n\t\t\t\tmax_size - len, \"%02x\", fc_trace[j] & 0xff);\n\t\t\tlen += scnprintf(fnic_dbgfs_prt->buffer + len,\n\t\t\t\tmax_size - len, \" \");\n\t\t\tif (j == ethhdr_len ||\n\t\t\t\tj == ethhdr_len + fcoehdr_len ||\n\t\t\t\tj == ethhdr_len + fcoehdr_len + fchdr_len ||\n\t\t\t\t(i > 3 && j%fchdr_len == 0)) {\n\t\t\t\tlen += scnprintf(fnic_dbgfs_prt->buffer\n\t\t\t\t\t+ len, max_size - len,\n\t\t\t\t\t\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t}  \n\t}  \n\tlen += scnprintf(fnic_dbgfs_prt->buffer + len,\n\t\tmax_size - len, \"\\n\");\n\t*orig_len = len;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}