{
  "module_name": "vnic_rq.c",
  "hash_id": "f3235e93d5a3abc103c154278aa65c1e24647036552f31f698fcf4d18368a80a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/fnic/vnic_rq.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include \"vnic_dev.h\"\n#include \"vnic_rq.h\"\n\nstatic int vnic_rq_alloc_bufs(struct vnic_rq *rq)\n{\n\tstruct vnic_rq_buf *buf;\n\tunsigned int i, j, count = rq->ring.desc_count;\n\tunsigned int blks = VNIC_RQ_BUF_BLKS_NEEDED(count);\n\n\tfor (i = 0; i < blks; i++) {\n\t\trq->bufs[i] = kzalloc(VNIC_RQ_BUF_BLK_SZ, GFP_ATOMIC);\n\t\tif (!rq->bufs[i]) {\n\t\t\tprintk(KERN_ERR \"Failed to alloc rq_bufs\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < blks; i++) {\n\t\tbuf = rq->bufs[i];\n\t\tfor (j = 0; j < VNIC_RQ_BUF_BLK_ENTRIES; j++) {\n\t\t\tbuf->index = i * VNIC_RQ_BUF_BLK_ENTRIES + j;\n\t\t\tbuf->desc = (u8 *)rq->ring.descs +\n\t\t\t\trq->ring.desc_size * buf->index;\n\t\t\tif (buf->index + 1 == count) {\n\t\t\t\tbuf->next = rq->bufs[0];\n\t\t\t\tbreak;\n\t\t\t} else if (j + 1 == VNIC_RQ_BUF_BLK_ENTRIES) {\n\t\t\t\tbuf->next = rq->bufs[i + 1];\n\t\t\t} else {\n\t\t\t\tbuf->next = buf + 1;\n\t\t\t\tbuf++;\n\t\t\t}\n\t\t}\n\t}\n\n\trq->to_use = rq->to_clean = rq->bufs[0];\n\trq->buf_index = 0;\n\n\treturn 0;\n}\n\nvoid vnic_rq_free(struct vnic_rq *rq)\n{\n\tstruct vnic_dev *vdev;\n\tunsigned int i;\n\n\tvdev = rq->vdev;\n\n\tvnic_dev_free_desc_ring(vdev, &rq->ring);\n\n\tfor (i = 0; i < VNIC_RQ_BUF_BLKS_MAX; i++) {\n\t\tkfree(rq->bufs[i]);\n\t\trq->bufs[i] = NULL;\n\t}\n\n\trq->ctrl = NULL;\n}\n\nint vnic_rq_alloc(struct vnic_dev *vdev, struct vnic_rq *rq, unsigned int index,\n\tunsigned int desc_count, unsigned int desc_size)\n{\n\tint err;\n\n\trq->index = index;\n\trq->vdev = vdev;\n\n\trq->ctrl = vnic_dev_get_res(vdev, RES_TYPE_RQ, index);\n\tif (!rq->ctrl) {\n\t\tprintk(KERN_ERR \"Failed to hook RQ[%d] resource\\n\", index);\n\t\treturn -EINVAL;\n\t}\n\n\tvnic_rq_disable(rq);\n\n\terr = vnic_dev_alloc_desc_ring(vdev, &rq->ring, desc_count, desc_size);\n\tif (err)\n\t\treturn err;\n\n\terr = vnic_rq_alloc_bufs(rq);\n\tif (err) {\n\t\tvnic_rq_free(rq);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid vnic_rq_init(struct vnic_rq *rq, unsigned int cq_index,\n\tunsigned int error_interrupt_enable,\n\tunsigned int error_interrupt_offset)\n{\n\tu64 paddr;\n\tu32 fetch_index;\n\n\tpaddr = (u64)rq->ring.base_addr | VNIC_PADDR_TARGET;\n\twriteq(paddr, &rq->ctrl->ring_base);\n\tiowrite32(rq->ring.desc_count, &rq->ctrl->ring_size);\n\tiowrite32(cq_index, &rq->ctrl->cq_index);\n\tiowrite32(error_interrupt_enable, &rq->ctrl->error_interrupt_enable);\n\tiowrite32(error_interrupt_offset, &rq->ctrl->error_interrupt_offset);\n\tiowrite32(0, &rq->ctrl->dropped_packet_count);\n\tiowrite32(0, &rq->ctrl->error_status);\n\n\t \n\tfetch_index = ioread32(&rq->ctrl->fetch_index);\n\trq->to_use = rq->to_clean =\n\t\t&rq->bufs[fetch_index / VNIC_RQ_BUF_BLK_ENTRIES]\n\t\t\t[fetch_index % VNIC_RQ_BUF_BLK_ENTRIES];\n\tiowrite32(fetch_index, &rq->ctrl->posted_index);\n\n\trq->buf_index = 0;\n}\n\nunsigned int vnic_rq_error_status(struct vnic_rq *rq)\n{\n\treturn ioread32(&rq->ctrl->error_status);\n}\n\nvoid vnic_rq_enable(struct vnic_rq *rq)\n{\n\tiowrite32(1, &rq->ctrl->enable);\n}\n\nint vnic_rq_disable(struct vnic_rq *rq)\n{\n\tunsigned int wait;\n\n\tiowrite32(0, &rq->ctrl->enable);\n\n\t \n\tfor (wait = 0; wait < 100; wait++) {\n\t\tif (!(ioread32(&rq->ctrl->running)))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\tprintk(KERN_ERR \"Failed to disable RQ[%d]\\n\", rq->index);\n\n\treturn -ETIMEDOUT;\n}\n\nvoid vnic_rq_clean(struct vnic_rq *rq,\n\tvoid (*buf_clean)(struct vnic_rq *rq, struct vnic_rq_buf *buf))\n{\n\tstruct vnic_rq_buf *buf;\n\tu32 fetch_index;\n\n\tWARN_ON(ioread32(&rq->ctrl->enable));\n\n\tbuf = rq->to_clean;\n\n\twhile (vnic_rq_desc_used(rq) > 0) {\n\n\t\t(*buf_clean)(rq, buf);\n\n\t\tbuf = rq->to_clean = buf->next;\n\t\trq->ring.desc_avail++;\n\t}\n\n\t \n\tfetch_index = ioread32(&rq->ctrl->fetch_index);\n\trq->to_use = rq->to_clean =\n\t\t&rq->bufs[fetch_index / VNIC_RQ_BUF_BLK_ENTRIES]\n\t\t\t[fetch_index % VNIC_RQ_BUF_BLK_ENTRIES];\n\tiowrite32(fetch_index, &rq->ctrl->posted_index);\n\n\trq->buf_index = 0;\n\n\tvnic_dev_clear_desc_ring(&rq->ring);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}