{
  "module_name": "fnic_res.c",
  "hash_id": "ac45d1aa31f2671a659375e600b5a3e08f8ee6fab54e45cb5f098cf0ee86dd62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/fnic/fnic_res.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include \"wq_enet_desc.h\"\n#include \"rq_enet_desc.h\"\n#include \"cq_enet_desc.h\"\n#include \"vnic_resource.h\"\n#include \"vnic_dev.h\"\n#include \"vnic_wq.h\"\n#include \"vnic_rq.h\"\n#include \"vnic_cq.h\"\n#include \"vnic_intr.h\"\n#include \"vnic_stats.h\"\n#include \"vnic_nic.h\"\n#include \"fnic.h\"\n\nint fnic_get_vnic_config(struct fnic *fnic)\n{\n\tstruct vnic_fc_config *c = &fnic->config;\n\tint err;\n\n#define GET_CONFIG(m) \\\n\tdo { \\\n\t\terr = vnic_dev_spec(fnic->vdev, \\\n\t\t\t\t    offsetof(struct vnic_fc_config, m), \\\n\t\t\t\t    sizeof(c->m), &c->m); \\\n\t\tif (err) { \\\n\t\t\tshost_printk(KERN_ERR, fnic->lport->host, \\\n\t\t\t\t     \"Error getting %s, %d\\n\", #m, \\\n\t\t\t\t     err); \\\n\t\t\treturn err; \\\n\t\t} \\\n\t} while (0);\n\n\tGET_CONFIG(node_wwn);\n\tGET_CONFIG(port_wwn);\n\tGET_CONFIG(wq_enet_desc_count);\n\tGET_CONFIG(wq_copy_desc_count);\n\tGET_CONFIG(rq_desc_count);\n\tGET_CONFIG(maxdatafieldsize);\n\tGET_CONFIG(ed_tov);\n\tGET_CONFIG(ra_tov);\n\tGET_CONFIG(intr_timer);\n\tGET_CONFIG(intr_timer_type);\n\tGET_CONFIG(flags);\n\tGET_CONFIG(flogi_retries);\n\tGET_CONFIG(flogi_timeout);\n\tGET_CONFIG(plogi_retries);\n\tGET_CONFIG(plogi_timeout);\n\tGET_CONFIG(io_throttle_count);\n\tGET_CONFIG(link_down_timeout);\n\tGET_CONFIG(port_down_timeout);\n\tGET_CONFIG(port_down_io_retries);\n\tGET_CONFIG(luns_per_tgt);\n\n\tc->wq_enet_desc_count =\n\t\tmin_t(u32, VNIC_FNIC_WQ_DESCS_MAX,\n\t\t      max_t(u32, VNIC_FNIC_WQ_DESCS_MIN,\n\t\t\t    c->wq_enet_desc_count));\n\tc->wq_enet_desc_count = ALIGN(c->wq_enet_desc_count, 16);\n\n\tc->wq_copy_desc_count =\n\t\tmin_t(u32, VNIC_FNIC_WQ_COPY_DESCS_MAX,\n\t\t      max_t(u32, VNIC_FNIC_WQ_COPY_DESCS_MIN,\n\t\t\t    c->wq_copy_desc_count));\n\tc->wq_copy_desc_count = ALIGN(c->wq_copy_desc_count, 16);\n\n\tc->rq_desc_count =\n\t\tmin_t(u32, VNIC_FNIC_RQ_DESCS_MAX,\n\t\t      max_t(u32, VNIC_FNIC_RQ_DESCS_MIN,\n\t\t\t    c->rq_desc_count));\n\tc->rq_desc_count = ALIGN(c->rq_desc_count, 16);\n\n\tc->maxdatafieldsize =\n\t\tmin_t(u16, VNIC_FNIC_MAXDATAFIELDSIZE_MAX,\n\t\t      max_t(u16, VNIC_FNIC_MAXDATAFIELDSIZE_MIN,\n\t\t\t    c->maxdatafieldsize));\n\tc->ed_tov =\n\t\tmin_t(u32, VNIC_FNIC_EDTOV_MAX,\n\t\t      max_t(u32, VNIC_FNIC_EDTOV_MIN,\n\t\t\t    c->ed_tov));\n\n\tc->ra_tov =\n\t\tmin_t(u32, VNIC_FNIC_RATOV_MAX,\n\t\t      max_t(u32, VNIC_FNIC_RATOV_MIN,\n\t\t\t    c->ra_tov));\n\n\tc->flogi_retries =\n\t\tmin_t(u32, VNIC_FNIC_FLOGI_RETRIES_MAX, c->flogi_retries);\n\n\tc->flogi_timeout =\n\t\tmin_t(u32, VNIC_FNIC_FLOGI_TIMEOUT_MAX,\n\t\t      max_t(u32, VNIC_FNIC_FLOGI_TIMEOUT_MIN,\n\t\t\t    c->flogi_timeout));\n\n\tc->plogi_retries =\n\t\tmin_t(u32, VNIC_FNIC_PLOGI_RETRIES_MAX, c->plogi_retries);\n\n\tc->plogi_timeout =\n\t\tmin_t(u32, VNIC_FNIC_PLOGI_TIMEOUT_MAX,\n\t\t      max_t(u32, VNIC_FNIC_PLOGI_TIMEOUT_MIN,\n\t\t\t    c->plogi_timeout));\n\n\tc->io_throttle_count =\n\t\tmin_t(u32, VNIC_FNIC_IO_THROTTLE_COUNT_MAX,\n\t\t      max_t(u32, VNIC_FNIC_IO_THROTTLE_COUNT_MIN,\n\t\t\t    c->io_throttle_count));\n\n\tc->link_down_timeout =\n\t\tmin_t(u32, VNIC_FNIC_LINK_DOWN_TIMEOUT_MAX,\n\t\t      c->link_down_timeout);\n\n\tc->port_down_timeout =\n\t\tmin_t(u32, VNIC_FNIC_PORT_DOWN_TIMEOUT_MAX,\n\t\t      c->port_down_timeout);\n\n\tc->port_down_io_retries =\n\t\tmin_t(u32, VNIC_FNIC_PORT_DOWN_IO_RETRIES_MAX,\n\t\t      c->port_down_io_retries);\n\n\tc->luns_per_tgt =\n\t\tmin_t(u32, VNIC_FNIC_LUNS_PER_TARGET_MAX,\n\t\t      max_t(u32, VNIC_FNIC_LUNS_PER_TARGET_MIN,\n\t\t\t    c->luns_per_tgt));\n\n\tc->intr_timer = min_t(u16, VNIC_INTR_TIMER_MAX, c->intr_timer);\n\tc->intr_timer_type = c->intr_timer_type;\n\n\tshost_printk(KERN_INFO, fnic->lport->host,\n\t\t     \"vNIC MAC addr %pM \"\n\t\t     \"wq/wq_copy/rq %d/%d/%d\\n\",\n\t\t     fnic->ctlr.ctl_src_addr,\n\t\t     c->wq_enet_desc_count, c->wq_copy_desc_count,\n\t\t     c->rq_desc_count);\n\tshost_printk(KERN_INFO, fnic->lport->host,\n\t\t     \"vNIC node wwn %llx port wwn %llx\\n\",\n\t\t     c->node_wwn, c->port_wwn);\n\tshost_printk(KERN_INFO, fnic->lport->host,\n\t\t     \"vNIC ed_tov %d ra_tov %d\\n\",\n\t\t     c->ed_tov, c->ra_tov);\n\tshost_printk(KERN_INFO, fnic->lport->host,\n\t\t     \"vNIC mtu %d intr timer %d\\n\",\n\t\t     c->maxdatafieldsize, c->intr_timer);\n\tshost_printk(KERN_INFO, fnic->lport->host,\n\t\t     \"vNIC flags 0x%x luns per tgt %d\\n\",\n\t\t     c->flags, c->luns_per_tgt);\n\tshost_printk(KERN_INFO, fnic->lport->host,\n\t\t     \"vNIC flogi_retries %d flogi timeout %d\\n\",\n\t\t     c->flogi_retries, c->flogi_timeout);\n\tshost_printk(KERN_INFO, fnic->lport->host,\n\t\t     \"vNIC plogi retries %d plogi timeout %d\\n\",\n\t\t     c->plogi_retries, c->plogi_timeout);\n\tshost_printk(KERN_INFO, fnic->lport->host,\n\t\t     \"vNIC io throttle count %d link dn timeout %d\\n\",\n\t\t     c->io_throttle_count, c->link_down_timeout);\n\tshost_printk(KERN_INFO, fnic->lport->host,\n\t\t     \"vNIC port dn io retries %d port dn timeout %d\\n\",\n\t\t     c->port_down_io_retries, c->port_down_timeout);\n\n\treturn 0;\n}\n\nint fnic_set_nic_config(struct fnic *fnic, u8 rss_default_cpu,\n\t\t\tu8 rss_hash_type,\n\t\t\tu8 rss_hash_bits, u8 rss_base_cpu, u8 rss_enable,\n\t\t\tu8 tso_ipid_split_en, u8 ig_vlan_strip_en)\n{\n\tu64 a0, a1;\n\tu32 nic_cfg;\n\tint wait = 1000;\n\n\tvnic_set_nic_cfg(&nic_cfg, rss_default_cpu,\n\t\trss_hash_type, rss_hash_bits, rss_base_cpu,\n\t\trss_enable, tso_ipid_split_en, ig_vlan_strip_en);\n\n\ta0 = nic_cfg;\n\ta1 = 0;\n\n\treturn vnic_dev_cmd(fnic->vdev, CMD_NIC_CFG, &a0, &a1, wait);\n}\n\nvoid fnic_get_res_counts(struct fnic *fnic)\n{\n\tfnic->wq_count = vnic_dev_get_res_count(fnic->vdev, RES_TYPE_WQ);\n\tfnic->raw_wq_count = fnic->wq_count - 1;\n\tfnic->wq_copy_count = fnic->wq_count - fnic->raw_wq_count;\n\tfnic->rq_count = vnic_dev_get_res_count(fnic->vdev, RES_TYPE_RQ);\n\tfnic->cq_count = vnic_dev_get_res_count(fnic->vdev, RES_TYPE_CQ);\n\tfnic->intr_count = vnic_dev_get_res_count(fnic->vdev,\n\t\tRES_TYPE_INTR_CTRL);\n}\n\nvoid fnic_free_vnic_resources(struct fnic *fnic)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < fnic->raw_wq_count; i++)\n\t\tvnic_wq_free(&fnic->wq[i]);\n\n\tfor (i = 0; i < fnic->wq_copy_count; i++)\n\t\tvnic_wq_copy_free(&fnic->wq_copy[i]);\n\n\tfor (i = 0; i < fnic->rq_count; i++)\n\t\tvnic_rq_free(&fnic->rq[i]);\n\n\tfor (i = 0; i < fnic->cq_count; i++)\n\t\tvnic_cq_free(&fnic->cq[i]);\n\n\tfor (i = 0; i < fnic->intr_count; i++)\n\t\tvnic_intr_free(&fnic->intr[i]);\n}\n\nint fnic_alloc_vnic_resources(struct fnic *fnic)\n{\n\tenum vnic_dev_intr_mode intr_mode;\n\tunsigned int mask_on_assertion;\n\tunsigned int interrupt_offset;\n\tunsigned int error_interrupt_enable;\n\tunsigned int error_interrupt_offset;\n\tunsigned int i, cq_index;\n\tunsigned int wq_copy_cq_desc_count;\n\tint err;\n\n\tintr_mode = vnic_dev_get_intr_mode(fnic->vdev);\n\n\tshost_printk(KERN_INFO, fnic->lport->host, \"vNIC interrupt mode: %s\\n\",\n\t\t     intr_mode == VNIC_DEV_INTR_MODE_INTX ? \"legacy PCI INTx\" :\n\t\t     intr_mode == VNIC_DEV_INTR_MODE_MSI ? \"MSI\" :\n\t\t     intr_mode == VNIC_DEV_INTR_MODE_MSIX ?\n\t\t     \"MSI-X\" : \"unknown\");\n\n\tshost_printk(KERN_INFO, fnic->lport->host, \"vNIC resources avail: \"\n\t\t     \"wq %d cp_wq %d raw_wq %d rq %d cq %d intr %d\\n\",\n\t\t     fnic->wq_count, fnic->wq_copy_count, fnic->raw_wq_count,\n\t\t     fnic->rq_count, fnic->cq_count, fnic->intr_count);\n\n\t \n\tfor (i = 0; i < fnic->raw_wq_count; i++) {\n\t\terr = vnic_wq_alloc(fnic->vdev, &fnic->wq[i], i,\n\t\t\tfnic->config.wq_enet_desc_count,\n\t\t\tsizeof(struct wq_enet_desc));\n\t\tif (err)\n\t\t\tgoto err_out_cleanup;\n\t}\n\n\t \n\tfor (i = 0; i < fnic->wq_copy_count; i++) {\n\t\terr = vnic_wq_copy_alloc(fnic->vdev, &fnic->wq_copy[i],\n\t\t\t(fnic->raw_wq_count + i),\n\t\t\tfnic->config.wq_copy_desc_count,\n\t\t\tsizeof(struct fcpio_host_req));\n\t\tif (err)\n\t\t\tgoto err_out_cleanup;\n\t}\n\n\t \n\tfor (i = 0; i < fnic->rq_count; i++) {\n\t\terr = vnic_rq_alloc(fnic->vdev, &fnic->rq[i], i,\n\t\t\tfnic->config.rq_desc_count,\n\t\t\tsizeof(struct rq_enet_desc));\n\t\tif (err)\n\t\t\tgoto err_out_cleanup;\n\t}\n\n\t \n\tfor (i = 0; i < fnic->rq_count; i++) {\n\t\tcq_index = i;\n\t\terr = vnic_cq_alloc(fnic->vdev,\n\t\t\t&fnic->cq[cq_index], cq_index,\n\t\t\tfnic->config.rq_desc_count,\n\t\t\tsizeof(struct cq_enet_rq_desc));\n\t\tif (err)\n\t\t\tgoto err_out_cleanup;\n\t}\n\n\t \n\tfor (i = 0; i < fnic->raw_wq_count; i++) {\n\t\tcq_index = fnic->rq_count + i;\n\t\terr = vnic_cq_alloc(fnic->vdev, &fnic->cq[cq_index], cq_index,\n\t\t\tfnic->config.wq_enet_desc_count,\n\t\t\tsizeof(struct cq_enet_wq_desc));\n\t\tif (err)\n\t\t\tgoto err_out_cleanup;\n\t}\n\n\t \n\twq_copy_cq_desc_count = (fnic->config.wq_copy_desc_count * 3);\n\tfor (i = 0; i < fnic->wq_copy_count; i++) {\n\t\tcq_index = fnic->raw_wq_count + fnic->rq_count + i;\n\t\terr = vnic_cq_alloc(fnic->vdev, &fnic->cq[cq_index],\n\t\t\tcq_index,\n\t\t\twq_copy_cq_desc_count,\n\t\t\tsizeof(struct fcpio_fw_req));\n\t\tif (err)\n\t\t\tgoto err_out_cleanup;\n\t}\n\n\tfor (i = 0; i < fnic->intr_count; i++) {\n\t\terr = vnic_intr_alloc(fnic->vdev, &fnic->intr[i], i);\n\t\tif (err)\n\t\t\tgoto err_out_cleanup;\n\t}\n\n\tfnic->legacy_pba = vnic_dev_get_res(fnic->vdev,\n\t\t\t\tRES_TYPE_INTR_PBA_LEGACY, 0);\n\n\tif (!fnic->legacy_pba && intr_mode == VNIC_DEV_INTR_MODE_INTX) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"Failed to hook legacy pba resource\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_cleanup;\n\t}\n\n\t \n\n\tswitch (intr_mode) {\n\tcase VNIC_DEV_INTR_MODE_INTX:\n\tcase VNIC_DEV_INTR_MODE_MSIX:\n\t\terror_interrupt_enable = 1;\n\t\terror_interrupt_offset = fnic->err_intr_offset;\n\t\tbreak;\n\tdefault:\n\t\terror_interrupt_enable = 0;\n\t\terror_interrupt_offset = 0;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < fnic->rq_count; i++) {\n\t\tcq_index = i;\n\t\tvnic_rq_init(&fnic->rq[i],\n\t\t\t     cq_index,\n\t\t\t     error_interrupt_enable,\n\t\t\t     error_interrupt_offset);\n\t}\n\n\tfor (i = 0; i < fnic->raw_wq_count; i++) {\n\t\tcq_index = i + fnic->rq_count;\n\t\tvnic_wq_init(&fnic->wq[i],\n\t\t\t     cq_index,\n\t\t\t     error_interrupt_enable,\n\t\t\t     error_interrupt_offset);\n\t}\n\n\tfor (i = 0; i < fnic->wq_copy_count; i++) {\n\t\tvnic_wq_copy_init(&fnic->wq_copy[i],\n\t\t\t\t  0  ,\n\t\t\t\t  error_interrupt_enable,\n\t\t\t\t  error_interrupt_offset);\n\t}\n\n\tfor (i = 0; i < fnic->cq_count; i++) {\n\n\t\tswitch (intr_mode) {\n\t\tcase VNIC_DEV_INTR_MODE_MSIX:\n\t\t\tinterrupt_offset = i;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinterrupt_offset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tvnic_cq_init(&fnic->cq[i],\n\t\t\t0  ,\n\t\t\t1  ,\n\t\t\t0  ,\n\t\t\t0  ,\n\t\t\t1  ,\n\t\t\t1  ,\n\t\t\t1  ,\n\t\t\t0  ,\n\t\t\tinterrupt_offset,\n\t\t\t0  );\n\t}\n\n\t \n\n\tswitch (intr_mode) {\n\tcase VNIC_DEV_INTR_MODE_MSI:\n\tcase VNIC_DEV_INTR_MODE_MSIX:\n\t\tmask_on_assertion = 1;\n\t\tbreak;\n\tdefault:\n\t\tmask_on_assertion = 0;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < fnic->intr_count; i++) {\n\t\tvnic_intr_init(&fnic->intr[i],\n\t\t\tfnic->config.intr_timer,\n\t\t\tfnic->config.intr_timer_type,\n\t\t\tmask_on_assertion);\n\t}\n\n\t \n\terr = vnic_dev_stats_dump(fnic->vdev, &fnic->stats);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, fnic->lport->host,\n\t\t\t     \"vnic_dev_stats_dump failed - x%x\\n\", err);\n\t\tgoto err_out_cleanup;\n\t}\n\n\t \n\tvnic_dev_stats_clear(fnic->vdev);\n\n\treturn 0;\n\nerr_out_cleanup:\n\tfnic_free_vnic_resources(fnic);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}