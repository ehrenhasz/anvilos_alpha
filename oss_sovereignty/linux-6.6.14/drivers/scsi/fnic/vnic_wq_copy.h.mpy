{
  "module_name": "vnic_wq_copy.h",
  "hash_id": "c8692fc15642a0bd71de5c430d566e4a0a11fe5943983a2e7188a96697aecd7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/fnic/vnic_wq_copy.h",
  "human_readable_source": " \n \n#ifndef _VNIC_WQ_COPY_H_\n#define _VNIC_WQ_COPY_H_\n\n#include <linux/pci.h>\n#include \"vnic_wq.h\"\n#include \"fcpio.h\"\n\n#define\tVNIC_WQ_COPY_MAX 1\n\nstruct vnic_wq_copy {\n\tunsigned int index;\n\tstruct vnic_dev *vdev;\n\tstruct vnic_wq_ctrl __iomem *ctrl;\t \n\tstruct vnic_dev_ring ring;\n\tunsigned to_use_index;\n\tunsigned to_clean_index;\n};\n\nstatic inline unsigned int vnic_wq_copy_desc_avail(struct vnic_wq_copy *wq)\n{\n\treturn wq->ring.desc_avail;\n}\n\nstatic inline unsigned int vnic_wq_copy_desc_in_use(struct vnic_wq_copy *wq)\n{\n\treturn wq->ring.desc_count - 1 - wq->ring.desc_avail;\n}\n\nstatic inline void *vnic_wq_copy_next_desc(struct vnic_wq_copy *wq)\n{\n\tstruct fcpio_host_req *desc = wq->ring.descs;\n\treturn &desc[wq->to_use_index];\n}\n\nstatic inline void vnic_wq_copy_post(struct vnic_wq_copy *wq)\n{\n\n\t((wq->to_use_index + 1) == wq->ring.desc_count) ?\n\t\t(wq->to_use_index = 0) : (wq->to_use_index++);\n\twq->ring.desc_avail--;\n\n\t \n\twmb();\n\n\tiowrite32(wq->to_use_index, &wq->ctrl->posted_index);\n}\n\nstatic inline void vnic_wq_copy_desc_process(struct vnic_wq_copy *wq, u16 index)\n{\n\tunsigned int cnt;\n\n\tif (wq->to_clean_index <= index)\n\t\tcnt = (index - wq->to_clean_index) + 1;\n\telse\n\t\tcnt = wq->ring.desc_count - wq->to_clean_index + index + 1;\n\n\twq->to_clean_index = ((index + 1) % wq->ring.desc_count);\n\twq->ring.desc_avail += cnt;\n\n}\n\nstatic inline void vnic_wq_copy_service(struct vnic_wq_copy *wq,\n\tu16 completed_index,\n\tvoid (*q_service)(struct vnic_wq_copy *wq,\n\tstruct fcpio_host_req *wq_desc))\n{\n\tstruct fcpio_host_req *wq_desc = wq->ring.descs;\n\tunsigned int curr_index;\n\n\twhile (1) {\n\n\t\tif (q_service)\n\t\t\t(*q_service)(wq, &wq_desc[wq->to_clean_index]);\n\n\t\twq->ring.desc_avail++;\n\n\t\tcurr_index = wq->to_clean_index;\n\n\t\t \n\t\t((wq->to_clean_index + 1) == wq->ring.desc_count) ?\n\t\t\t(wq->to_clean_index = 0) : (wq->to_clean_index++);\n\n\t\tif (curr_index == completed_index)\n\t\t\tbreak;\n\n\t\t \n\t\tif ((completed_index == (u16)-1) &&\n\t\t    (wq->to_clean_index == wq->to_use_index))\n\t\t\tbreak;\n\t}\n}\n\nvoid vnic_wq_copy_enable(struct vnic_wq_copy *wq);\nint vnic_wq_copy_disable(struct vnic_wq_copy *wq);\nvoid vnic_wq_copy_free(struct vnic_wq_copy *wq);\nint vnic_wq_copy_alloc(struct vnic_dev *vdev, struct vnic_wq_copy *wq,\n\tunsigned int index, unsigned int desc_count, unsigned int desc_size);\nvoid vnic_wq_copy_init(struct vnic_wq_copy *wq, unsigned int cq_index,\n\tunsigned int error_interrupt_enable,\n\tunsigned int error_interrupt_offset);\nvoid vnic_wq_copy_clean(struct vnic_wq_copy *wq,\n\tvoid (*q_clean)(struct vnic_wq_copy *wq,\n\tstruct fcpio_host_req *wq_desc));\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}