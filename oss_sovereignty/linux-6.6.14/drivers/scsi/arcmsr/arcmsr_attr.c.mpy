{
  "module_name": "arcmsr_attr.c",
  "hash_id": "cb93c24f9586239f04676895c819aabecb6c8ad4b0b370cb2cbe12c0feb1a505",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/arcmsr/arcmsr_attr.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/circ_buf.h>\n\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport.h>\n#include \"arcmsr.h\"\n\nstatic ssize_t arcmsr_sysfs_iop_message_read(struct file *filp,\n\t\t\t\t\t     struct kobject *kobj,\n\t\t\t\t\t     struct bin_attribute *bin,\n\t\t\t\t\t     char *buf, loff_t off,\n\t\t\t\t\t     size_t count)\n{\n\tstruct device *dev = container_of(kobj,struct device,kobj);\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tstruct AdapterControlBlock *acb = (struct AdapterControlBlock *) host->hostdata;\n\tuint8_t *ptmpQbuffer;\n\tint32_t allxfer_len = 0;\n\tunsigned long flags;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\t \n\tptmpQbuffer = (uint8_t *)buf;\n\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\tif (acb->rqbuf_getIndex != acb->rqbuf_putIndex) {\n\t\tunsigned int tail = acb->rqbuf_getIndex;\n\t\tunsigned int head = acb->rqbuf_putIndex;\n\t\tunsigned int cnt_to_end = CIRC_CNT_TO_END(head, tail, ARCMSR_MAX_QBUFFER);\n\n\t\tallxfer_len = CIRC_CNT(head, tail, ARCMSR_MAX_QBUFFER);\n\t\tif (allxfer_len > ARCMSR_API_DATA_BUFLEN)\n\t\t\tallxfer_len = ARCMSR_API_DATA_BUFLEN;\n\n\t\tif (allxfer_len <= cnt_to_end)\n\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, allxfer_len);\n\t\telse {\n\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, cnt_to_end);\n\t\t\tmemcpy(ptmpQbuffer + cnt_to_end, acb->rqbuffer, allxfer_len - cnt_to_end);\n\t\t}\n\t\tacb->rqbuf_getIndex = (acb->rqbuf_getIndex + allxfer_len) % ARCMSR_MAX_QBUFFER;\n\t}\n\tif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\n\t\tstruct QBUFFER __iomem *prbuffer;\n\t\tacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\n\t\tprbuffer = arcmsr_get_iop_rqbuffer(acb);\n\t\tif (arcmsr_Read_iop_rqbuffer_data(acb, prbuffer) == 0)\n\t\t\tacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\n\t}\n\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\treturn allxfer_len;\n}\n\nstatic ssize_t arcmsr_sysfs_iop_message_write(struct file *filp,\n\t\t\t\t\t      struct kobject *kobj,\n\t\t\t\t\t      struct bin_attribute *bin,\n\t\t\t\t\t      char *buf, loff_t off,\n\t\t\t\t\t      size_t count)\n{\n\tstruct device *dev = container_of(kobj,struct device,kobj);\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tstruct AdapterControlBlock *acb = (struct AdapterControlBlock *) host->hostdata;\n\tint32_t user_len, cnt2end;\n\tuint8_t *pQbuffer, *ptmpuserbuffer;\n\tunsigned long flags;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\tif (count > ARCMSR_API_DATA_BUFLEN)\n\t\treturn -EINVAL;\n\t \n\tptmpuserbuffer = (uint8_t *)buf;\n\tuser_len = (int32_t)count;\n\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\tif (acb->wqbuf_putIndex != acb->wqbuf_getIndex) {\n\t\tarcmsr_write_ioctldata2iop(acb);\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\treturn 0;\t \n\t} else {\n\t\tpQbuffer = &acb->wqbuffer[acb->wqbuf_putIndex];\n\t\tcnt2end = ARCMSR_MAX_QBUFFER - acb->wqbuf_putIndex;\n\t\tif (user_len > cnt2end) {\n\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, cnt2end);\n\t\t\tptmpuserbuffer += cnt2end;\n\t\t\tuser_len -= cnt2end;\n\t\t\tacb->wqbuf_putIndex = 0;\n\t\t\tpQbuffer = acb->wqbuffer;\n\t\t}\n\t\tmemcpy(pQbuffer, ptmpuserbuffer, user_len);\n\t\tacb->wqbuf_putIndex += user_len;\n\t\tacb->wqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\n\t\tif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_CLEARED) {\n\t\t\tacb->acb_flags &=\n\t\t\t\t~ACB_F_MESSAGE_WQBUFFER_CLEARED;\n\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\treturn count;\n\t}\n}\n\nstatic ssize_t arcmsr_sysfs_iop_message_clear(struct file *filp,\n\t\t\t\t\t      struct kobject *kobj,\n\t\t\t\t\t      struct bin_attribute *bin,\n\t\t\t\t\t      char *buf, loff_t off,\n\t\t\t\t\t      size_t count)\n{\n\tstruct device *dev = container_of(kobj,struct device,kobj);\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tstruct AdapterControlBlock *acb = (struct AdapterControlBlock *) host->hostdata;\n\tuint8_t *pQbuffer;\n\tunsigned long flags;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\tacb->acb_flags |=\n\t\t(ACB_F_MESSAGE_WQBUFFER_CLEARED\n\t\t| ACB_F_MESSAGE_RQBUFFER_CLEARED\n\t\t| ACB_F_MESSAGE_WQBUFFER_READED);\n\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\tacb->rqbuf_getIndex = 0;\n\tacb->rqbuf_putIndex = 0;\n\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\tacb->wqbuf_getIndex = 0;\n\tacb->wqbuf_putIndex = 0;\n\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\tpQbuffer = acb->rqbuffer;\n\tmemset(pQbuffer, 0, sizeof (struct QBUFFER));\n\tpQbuffer = acb->wqbuffer;\n\tmemset(pQbuffer, 0, sizeof (struct QBUFFER));\n\treturn 1;\n}\n\nstatic const struct bin_attribute arcmsr_sysfs_message_read_attr = {\n\t.attr = {\n\t\t.name = \"mu_read\",\n\t\t.mode = S_IRUSR ,\n\t},\n\t.size = ARCMSR_API_DATA_BUFLEN,\n\t.read = arcmsr_sysfs_iop_message_read,\n};\n\nstatic const struct bin_attribute arcmsr_sysfs_message_write_attr = {\n\t.attr = {\n\t\t.name = \"mu_write\",\n\t\t.mode = S_IWUSR,\n\t},\n\t.size = ARCMSR_API_DATA_BUFLEN,\n\t.write = arcmsr_sysfs_iop_message_write,\n};\n\nstatic const struct bin_attribute arcmsr_sysfs_message_clear_attr = {\n\t.attr = {\n\t\t.name = \"mu_clear\",\n\t\t.mode = S_IWUSR,\n\t},\n\t.size = 1,\n\t.write = arcmsr_sysfs_iop_message_clear,\n};\n\nint arcmsr_alloc_sysfs_attr(struct AdapterControlBlock *acb)\n{\n\tstruct Scsi_Host *host = acb->host;\n\tint error;\n\n\terror = sysfs_create_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_read_attr);\n\tif (error) {\n\t\tprintk(KERN_ERR \"arcmsr: alloc sysfs mu_read failed\\n\");\n\t\tgoto error_bin_file_message_read;\n\t}\n\terror = sysfs_create_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_write_attr);\n\tif (error) {\n\t\tprintk(KERN_ERR \"arcmsr: alloc sysfs mu_write failed\\n\");\n\t\tgoto error_bin_file_message_write;\n\t}\n\terror = sysfs_create_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_clear_attr);\n\tif (error) {\n\t\tprintk(KERN_ERR \"arcmsr: alloc sysfs mu_clear failed\\n\");\n\t\tgoto error_bin_file_message_clear;\n\t}\n\treturn 0;\nerror_bin_file_message_clear:\n\tsysfs_remove_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_write_attr);\nerror_bin_file_message_write:\n\tsysfs_remove_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_read_attr);\nerror_bin_file_message_read:\n\treturn error;\n}\n\nvoid arcmsr_free_sysfs_attr(struct AdapterControlBlock *acb)\n{\n\tstruct Scsi_Host *host = acb->host;\n\n\tsysfs_remove_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_clear_attr);\n\tsysfs_remove_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_write_attr);\n\tsysfs_remove_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_read_attr);\n}\n\n\nstatic ssize_t\narcmsr_attr_host_driver_version(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"%s\\n\",\n\t\t\tARCMSR_DRIVER_VERSION);\n}\n\nstatic ssize_t\narcmsr_attr_host_driver_posted_cmd(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *) host->hostdata;\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"%4d\\n\",\n\t\t\tatomic_read(&acb->ccboutstandingcount));\n}\n\nstatic ssize_t\narcmsr_attr_host_driver_reset(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *) host->hostdata;\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"%4d\\n\",\n\t\t\tacb->num_resets);\n}\n\nstatic ssize_t\narcmsr_attr_host_driver_abort(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *) host->hostdata;\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"%4d\\n\",\n\t\t\tacb->num_aborts);\n}\n\nstatic ssize_t\narcmsr_attr_host_fw_model(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *) host->hostdata;\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"%s\\n\",\n\t\t\tacb->firm_model);\n}\n\nstatic ssize_t\narcmsr_attr_host_fw_version(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tstruct AdapterControlBlock *acb =\n\t\t\t(struct AdapterControlBlock *) host->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"%s\\n\",\n\t\t\tacb->firm_version);\n}\n\nstatic ssize_t\narcmsr_attr_host_fw_request_len(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *) host->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"%4d\\n\",\n\t\t\tacb->firm_request_len);\n}\n\nstatic ssize_t\narcmsr_attr_host_fw_numbers_queue(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *) host->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"%4d\\n\",\n\t\t\tacb->firm_numbers_queue);\n}\n\nstatic ssize_t\narcmsr_attr_host_fw_sdram_size(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *) host->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"%4d\\n\",\n\t\t\tacb->firm_sdram_size);\n}\n\nstatic ssize_t\narcmsr_attr_host_fw_hd_channels(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *) host->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"%4d\\n\",\n\t\t\tacb->firm_hd_channels);\n}\n\nstatic DEVICE_ATTR(host_driver_version, S_IRUGO, arcmsr_attr_host_driver_version, NULL);\nstatic DEVICE_ATTR(host_driver_posted_cmd, S_IRUGO, arcmsr_attr_host_driver_posted_cmd, NULL);\nstatic DEVICE_ATTR(host_driver_reset, S_IRUGO, arcmsr_attr_host_driver_reset, NULL);\nstatic DEVICE_ATTR(host_driver_abort, S_IRUGO, arcmsr_attr_host_driver_abort, NULL);\nstatic DEVICE_ATTR(host_fw_model, S_IRUGO, arcmsr_attr_host_fw_model, NULL);\nstatic DEVICE_ATTR(host_fw_version, S_IRUGO, arcmsr_attr_host_fw_version, NULL);\nstatic DEVICE_ATTR(host_fw_request_len, S_IRUGO, arcmsr_attr_host_fw_request_len, NULL);\nstatic DEVICE_ATTR(host_fw_numbers_queue, S_IRUGO, arcmsr_attr_host_fw_numbers_queue, NULL);\nstatic DEVICE_ATTR(host_fw_sdram_size, S_IRUGO, arcmsr_attr_host_fw_sdram_size, NULL);\nstatic DEVICE_ATTR(host_fw_hd_channels, S_IRUGO, arcmsr_attr_host_fw_hd_channels, NULL);\n\nstatic struct attribute *arcmsr_host_attrs[] = {\n\t&dev_attr_host_driver_version.attr,\n\t&dev_attr_host_driver_posted_cmd.attr,\n\t&dev_attr_host_driver_reset.attr,\n\t&dev_attr_host_driver_abort.attr,\n\t&dev_attr_host_fw_model.attr,\n\t&dev_attr_host_fw_version.attr,\n\t&dev_attr_host_fw_request_len.attr,\n\t&dev_attr_host_fw_numbers_queue.attr,\n\t&dev_attr_host_fw_sdram_size.attr,\n\t&dev_attr_host_fw_hd_channels.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group arcmsr_host_attr_group = {\n\t.attrs = arcmsr_host_attrs,\n};\n\nconst struct attribute_group *arcmsr_host_groups[] = {\n\t&arcmsr_host_attr_group,\n\tNULL\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}