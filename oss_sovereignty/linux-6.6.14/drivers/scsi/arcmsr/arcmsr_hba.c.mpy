{
  "module_name": "arcmsr_hba.c",
  "hash_id": "5e82c0fbd2a649bf41c27e62bbb0c8169edb32d275474d9f1d73d4e5f681cbc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/arcmsr/arcmsr_hba.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/reboot.h>\n#include <linux/spinlock.h>\n#include <linux/pci_ids.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/circ_buf.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsicam.h>\n#include \"arcmsr.h\"\nMODULE_AUTHOR(\"Nick Cheng, C.L. Huang <support@areca.com.tw>\");\nMODULE_DESCRIPTION(\"Areca ARC11xx/12xx/16xx/188x SAS/SATA RAID Controller Driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_VERSION(ARCMSR_DRIVER_VERSION);\n\nstatic int msix_enable = 1;\nmodule_param(msix_enable, int, S_IRUGO);\nMODULE_PARM_DESC(msix_enable, \"Enable MSI-X interrupt(0 ~ 1), msix_enable=1(enable), =0(disable)\");\n\nstatic int msi_enable = 1;\nmodule_param(msi_enable, int, S_IRUGO);\nMODULE_PARM_DESC(msi_enable, \"Enable MSI interrupt(0 ~ 1), msi_enable=1(enable), =0(disable)\");\n\nstatic int host_can_queue = ARCMSR_DEFAULT_OUTSTANDING_CMD;\nmodule_param(host_can_queue, int, S_IRUGO);\nMODULE_PARM_DESC(host_can_queue, \" adapter queue depth(32 ~ 1024), default is 128\");\n\nstatic int cmd_per_lun = ARCMSR_DEFAULT_CMD_PERLUN;\nmodule_param(cmd_per_lun, int, S_IRUGO);\nMODULE_PARM_DESC(cmd_per_lun, \" device queue depth(1 ~ 128), default is 32\");\n\nstatic int dma_mask_64 = 0;\nmodule_param(dma_mask_64, int, S_IRUGO);\nMODULE_PARM_DESC(dma_mask_64, \" set DMA mask to 64 bits(0 ~ 1), dma_mask_64=1(64 bits), =0(32 bits)\");\n\nstatic int set_date_time = 0;\nmodule_param(set_date_time, int, S_IRUGO);\nMODULE_PARM_DESC(set_date_time, \" send date, time to iop(0 ~ 1), set_date_time=1(enable), default(=0) is disable\");\n\nstatic int cmd_timeout = ARCMSR_DEFAULT_TIMEOUT;\nmodule_param(cmd_timeout, int, S_IRUGO);\nMODULE_PARM_DESC(cmd_timeout, \" scsi cmd timeout(0 ~ 120 sec.), default is 90\");\n\n#define\tARCMSR_SLEEPTIME\t10\n#define\tARCMSR_RETRYCOUNT\t12\n\nstatic wait_queue_head_t wait_q;\nstatic int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,\n\t\t\t\t\tstruct scsi_cmnd *cmd);\nstatic int arcmsr_iop_confirm(struct AdapterControlBlock *acb);\nstatic int arcmsr_abort(struct scsi_cmnd *);\nstatic int arcmsr_bus_reset(struct scsi_cmnd *);\nstatic int arcmsr_bios_param(struct scsi_device *sdev,\n\t\tstruct block_device *bdev, sector_t capacity, int *info);\nstatic int arcmsr_queue_command(struct Scsi_Host *h, struct scsi_cmnd *cmd);\nstatic int arcmsr_probe(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *id);\nstatic int __maybe_unused arcmsr_suspend(struct device *dev);\nstatic int __maybe_unused arcmsr_resume(struct device *dev);\nstatic void arcmsr_remove(struct pci_dev *pdev);\nstatic void arcmsr_shutdown(struct pci_dev *pdev);\nstatic void arcmsr_iop_init(struct AdapterControlBlock *acb);\nstatic void arcmsr_free_ccb_pool(struct AdapterControlBlock *acb);\nstatic u32 arcmsr_disable_outbound_ints(struct AdapterControlBlock *acb);\nstatic void arcmsr_enable_outbound_ints(struct AdapterControlBlock *acb,\n\tu32 intmask_org);\nstatic void arcmsr_stop_adapter_bgrb(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaA_flush_cache(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaB_flush_cache(struct AdapterControlBlock *acb);\nstatic void arcmsr_request_device_map(struct timer_list *t);\nstatic void arcmsr_message_isr_bh_fn(struct work_struct *work);\nstatic bool arcmsr_get_firmware_spec(struct AdapterControlBlock *acb);\nstatic void arcmsr_start_adapter_bgrb(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaC_message_isr(struct AdapterControlBlock *pACB);\nstatic void arcmsr_hbaD_message_isr(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaE_message_isr(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaE_postqueue_isr(struct AdapterControlBlock *acb);\nstatic void arcmsr_hbaF_postqueue_isr(struct AdapterControlBlock *acb);\nstatic void arcmsr_hardware_reset(struct AdapterControlBlock *acb);\nstatic const char *arcmsr_info(struct Scsi_Host *);\nstatic irqreturn_t arcmsr_interrupt(struct AdapterControlBlock *acb);\nstatic void arcmsr_free_irq(struct pci_dev *, struct AdapterControlBlock *);\nstatic void arcmsr_wait_firmware_ready(struct AdapterControlBlock *acb);\nstatic void arcmsr_set_iop_datetime(struct timer_list *);\nstatic int arcmsr_slave_config(struct scsi_device *sdev);\nstatic int arcmsr_adjust_disk_queue_depth(struct scsi_device *sdev, int queue_depth)\n{\n\tif (queue_depth > ARCMSR_MAX_CMD_PERLUN)\n\t\tqueue_depth = ARCMSR_MAX_CMD_PERLUN;\n\treturn scsi_change_queue_depth(sdev, queue_depth);\n}\n\nstatic const struct scsi_host_template arcmsr_scsi_host_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.proc_name\t\t= ARCMSR_NAME,\n\t.name\t\t\t= \"Areca SAS/SATA RAID driver\",\n\t.info\t\t\t= arcmsr_info,\n\t.queuecommand\t\t= arcmsr_queue_command,\n\t.eh_abort_handler\t= arcmsr_abort,\n\t.eh_bus_reset_handler\t= arcmsr_bus_reset,\n\t.bios_param\t\t= arcmsr_bios_param,\n\t.slave_configure\t= arcmsr_slave_config,\n\t.change_queue_depth\t= arcmsr_adjust_disk_queue_depth,\n\t.can_queue\t\t= ARCMSR_DEFAULT_OUTSTANDING_CMD,\n\t.this_id\t\t= ARCMSR_SCSI_INITIATOR_ID,\n\t.sg_tablesize\t        = ARCMSR_DEFAULT_SG_ENTRIES,\n\t.max_sectors\t\t= ARCMSR_MAX_XFER_SECTORS_C,\n\t.cmd_per_lun\t\t= ARCMSR_DEFAULT_CMD_PERLUN,\n\t.shost_groups\t\t= arcmsr_host_groups,\n\t.no_write_same\t\t= 1,\n};\n\nstatic struct pci_device_id arcmsr_device_id_table[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1110),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1120),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1130),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1160),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1170),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1200),\n\t\t.driver_data = ACB_ADAPTER_TYPE_B},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1201),\n\t\t.driver_data = ACB_ADAPTER_TYPE_B},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1202),\n\t\t.driver_data = ACB_ADAPTER_TYPE_B},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1203),\n\t\t.driver_data = ACB_ADAPTER_TYPE_B},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1210),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1214),\n\t\t.driver_data = ACB_ADAPTER_TYPE_D},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1220),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1230),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1260),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1270),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1280),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1380),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1381),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1680),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1681),\n\t\t.driver_data = ACB_ADAPTER_TYPE_A},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1880),\n\t\t.driver_data = ACB_ADAPTER_TYPE_C},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1884),\n\t\t.driver_data = ACB_ADAPTER_TYPE_E},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ARECA, PCI_DEVICE_ID_ARECA_1886),\n\t\t.driver_data = ACB_ADAPTER_TYPE_F},\n\t{0, 0},  \n};\nMODULE_DEVICE_TABLE(pci, arcmsr_device_id_table);\n\nstatic SIMPLE_DEV_PM_OPS(arcmsr_pm_ops, arcmsr_suspend, arcmsr_resume);\n\nstatic struct pci_driver arcmsr_pci_driver = {\n\t.name\t\t\t= \"arcmsr\",\n\t.id_table\t\t= arcmsr_device_id_table,\n\t.probe\t\t\t= arcmsr_probe,\n\t.remove\t\t\t= arcmsr_remove,\n\t.driver.pm\t\t= &arcmsr_pm_ops,\n\t.shutdown\t\t= arcmsr_shutdown,\n};\n \n\nstatic void arcmsr_free_io_queue(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_B:\n\tcase ACB_ADAPTER_TYPE_D:\n\tcase ACB_ADAPTER_TYPE_E:\n\tcase ACB_ADAPTER_TYPE_F:\n\t\tdma_free_coherent(&acb->pdev->dev, acb->ioqueue_size,\n\t\t\tacb->dma_coherent2, acb->dma_coherent_handle2);\n\t\tbreak;\n\t}\n}\n\nstatic bool arcmsr_remap_pciregion(struct AdapterControlBlock *acb)\n{\n\tstruct pci_dev *pdev = acb->pdev;\n\tswitch (acb->adapter_type){\n\tcase ACB_ADAPTER_TYPE_A:{\n\t\tacb->pmuA = ioremap(pci_resource_start(pdev,0), pci_resource_len(pdev,0));\n\t\tif (!acb->pmuA) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: memory mapping region fail \\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_B:{\n\t\tvoid __iomem *mem_base0, *mem_base1;\n\t\tmem_base0 = ioremap(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));\n\t\tif (!mem_base0) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: memory mapping region fail \\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tmem_base1 = ioremap(pci_resource_start(pdev, 2), pci_resource_len(pdev, 2));\n\t\tif (!mem_base1) {\n\t\t\tiounmap(mem_base0);\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: memory mapping region fail \\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tacb->mem_base0 = mem_base0;\n\t\tacb->mem_base1 = mem_base1;\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_C:{\n\t\tacb->pmuC = ioremap(pci_resource_start(pdev, 1), pci_resource_len(pdev, 1));\n\t\tif (!acb->pmuC) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: memory mapping region fail \\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tif (readl(&acb->pmuC->outbound_doorbell) & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &acb->pmuC->outbound_doorbell_clear); \n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tvoid __iomem *mem_base0;\n\t\tunsigned long addr, range;\n\n\t\taddr = (unsigned long)pci_resource_start(pdev, 0);\n\t\trange = pci_resource_len(pdev, 0);\n\t\tmem_base0 = ioremap(addr, range);\n\t\tif (!mem_base0) {\n\t\t\tpr_notice(\"arcmsr%d: memory mapping region fail\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tacb->mem_base0 = mem_base0;\n\t\tbreak;\n\t\t}\n\tcase ACB_ADAPTER_TYPE_E: {\n\t\tacb->pmuE = ioremap(pci_resource_start(pdev, 1),\n\t\t\tpci_resource_len(pdev, 1));\n\t\tif (!acb->pmuE) {\n\t\t\tpr_notice(\"arcmsr%d: memory mapping region fail \\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\twritel(0, &acb->pmuE->host_int_status);  \n\t\twritel(ARCMSR_HBEMU_DOORBELL_SYNC, &acb->pmuE->iobound_doorbell);\t \n\t\tacb->in_doorbell = 0;\n\t\tacb->out_doorbell = 0;\n\t\tbreak;\n\t\t}\n\tcase ACB_ADAPTER_TYPE_F: {\n\t\tacb->pmuF = ioremap(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));\n\t\tif (!acb->pmuF) {\n\t\t\tpr_notice(\"arcmsr%d: memory mapping region fail\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\twritel(0, &acb->pmuF->host_int_status);  \n\t\twritel(ARCMSR_HBFMU_DOORBELL_SYNC, &acb->pmuF->iobound_doorbell);\n\t\tacb->in_doorbell = 0;\n\t\tacb->out_doorbell = 0;\n\t\tbreak;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void arcmsr_unmap_pciregion(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\tiounmap(acb->pmuA);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\tiounmap(acb->mem_base0);\n\t\tiounmap(acb->mem_base1);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\tiounmap(acb->pmuC);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tiounmap(acb->mem_base0);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\t\tiounmap(acb->pmuE);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_F:\n\t\tiounmap(acb->pmuF);\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t arcmsr_do_interrupt(int irq, void *dev_id)\n{\n\tirqreturn_t handle_state;\n\tstruct AdapterControlBlock *acb = dev_id;\n\n\thandle_state = arcmsr_interrupt(acb);\n\treturn handle_state;\n}\n\nstatic int arcmsr_bios_param(struct scsi_device *sdev,\n\t\tstruct block_device *bdev, sector_t capacity, int *geom)\n{\n\tint heads, sectors, cylinders, total_capacity;\n\n\tif (scsi_partsize(bdev, capacity, geom))\n\t\treturn 0;\n\n\ttotal_capacity = capacity;\n\theads = 64;\n\tsectors = 32;\n\tcylinders = total_capacity / (heads * sectors);\n\tif (cylinders > 1024) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\tcylinders = total_capacity / (heads * sectors);\n\t}\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\treturn 0;\n}\n\nstatic uint8_t arcmsr_hbaA_wait_msgint_ready(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tint i;\n\n\tfor (i = 0; i < 2000; i++) {\n\t\tif (readl(&reg->outbound_intstatus) &\n\t\t\t\tARCMSR_MU_OUTBOUND_MESSAGE0_INT) {\n\t\t\twritel(ARCMSR_MU_OUTBOUND_MESSAGE0_INT,\n\t\t\t\t&reg->outbound_intstatus);\n\t\t\treturn true;\n\t\t}\n\t\tmsleep(10);\n\t}  \n\n\treturn false;\n}\n\nstatic uint8_t arcmsr_hbaB_wait_msgint_ready(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tint i;\n\n\tfor (i = 0; i < 2000; i++) {\n\t\tif (readl(reg->iop2drv_doorbell)\n\t\t\t& ARCMSR_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_MESSAGE_INT_CLEAR_PATTERN,\n\t\t\t\t\treg->iop2drv_doorbell);\n\t\t\twritel(ARCMSR_DRV2IOP_END_OF_INTERRUPT,\n\t\t\t\t\treg->drv2iop_doorbell);\n\t\t\treturn true;\n\t\t}\n\t\tmsleep(10);\n\t}  \n\n\treturn false;\n}\n\nstatic uint8_t arcmsr_hbaC_wait_msgint_ready(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_C __iomem *phbcmu = pACB->pmuC;\n\tint i;\n\n\tfor (i = 0; i < 2000; i++) {\n\t\tif (readl(&phbcmu->outbound_doorbell)\n\t\t\t\t& ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR,\n\t\t\t\t&phbcmu->outbound_doorbell_clear);  \n\t\t\treturn true;\n\t\t}\n\t\tmsleep(10);\n\t}  \n\n\treturn false;\n}\n\nstatic bool arcmsr_hbaD_wait_msgint_ready(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_D *reg = pACB->pmuD;\n\tint i;\n\n\tfor (i = 0; i < 2000; i++) {\n\t\tif (readl(reg->outbound_doorbell)\n\t\t\t& ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE,\n\t\t\t\treg->outbound_doorbell);\n\t\t\treturn true;\n\t\t}\n\t\tmsleep(10);\n\t}  \n\treturn false;\n}\n\nstatic bool arcmsr_hbaE_wait_msgint_ready(struct AdapterControlBlock *pACB)\n{\n\tint i;\n\tuint32_t read_doorbell;\n\tstruct MessageUnit_E __iomem *phbcmu = pACB->pmuE;\n\n\tfor (i = 0; i < 2000; i++) {\n\t\tread_doorbell = readl(&phbcmu->iobound_doorbell);\n\t\tif ((read_doorbell ^ pACB->in_doorbell) & ARCMSR_HBEMU_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(0, &phbcmu->host_int_status);  \n\t\t\tpACB->in_doorbell = read_doorbell;\n\t\t\treturn true;\n\t\t}\n\t\tmsleep(10);\n\t}  \n\treturn false;\n}\n\nstatic void arcmsr_hbaA_flush_cache(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tint retry_count = 30;\n\twritel(ARCMSR_INBOUND_MESG0_FLUSH_CACHE, &reg->inbound_msgaddr0);\n\tdo {\n\t\tif (arcmsr_hbaA_wait_msgint_ready(acb))\n\t\t\tbreak;\n\t\telse {\n\t\t\tretry_count--;\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'flush adapter cache' \\\n\t\t\ttimeout, retry count down = %d \\n\", acb->host->host_no, retry_count);\n\t\t}\n\t} while (retry_count != 0);\n}\n\nstatic void arcmsr_hbaB_flush_cache(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tint retry_count = 30;\n\twritel(ARCMSR_MESSAGE_FLUSH_CACHE, reg->drv2iop_doorbell);\n\tdo {\n\t\tif (arcmsr_hbaB_wait_msgint_ready(acb))\n\t\t\tbreak;\n\t\telse {\n\t\t\tretry_count--;\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'flush adapter cache' \\\n\t\t\ttimeout,retry count down = %d \\n\", acb->host->host_no, retry_count);\n\t\t}\n\t} while (retry_count != 0);\n}\n\nstatic void arcmsr_hbaC_flush_cache(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\tint retry_count = 30;/* enlarge wait flush adapter cache time: 10 minute */\n\twritel(ARCMSR_INBOUND_MESG0_FLUSH_CACHE, &reg->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\tdo {\n\t\tif (arcmsr_hbaC_wait_msgint_ready(pACB)) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tretry_count--;\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'flush adapter cache' \\\n\t\t\ttimeout,retry count down = %d \\n\", pACB->host->host_no, retry_count);\n\t\t}\n\t} while (retry_count != 0);\n\treturn;\n}\n\nstatic void arcmsr_hbaD_flush_cache(struct AdapterControlBlock *pACB)\n{\n\tint retry_count = 15;\n\tstruct MessageUnit_D *reg = pACB->pmuD;\n\n\twritel(ARCMSR_INBOUND_MESG0_FLUSH_CACHE, reg->inbound_msgaddr0);\n\tdo {\n\t\tif (arcmsr_hbaD_wait_msgint_ready(pACB))\n\t\t\tbreak;\n\n\t\tretry_count--;\n\t\tpr_notice(\"arcmsr%d: wait 'flush adapter \"\n\t\t\t\"cache' timeout, retry count down = %d\\n\",\n\t\t\tpACB->host->host_no, retry_count);\n\t} while (retry_count != 0);\n}\n\nstatic void arcmsr_hbaE_flush_cache(struct AdapterControlBlock *pACB)\n{\n\tint retry_count = 30;\n\tstruct MessageUnit_E __iomem *reg = pACB->pmuE;\n\n\twritel(ARCMSR_INBOUND_MESG0_FLUSH_CACHE, &reg->inbound_msgaddr0);\n\tpACB->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_MESSAGE_CMD_DONE;\n\twritel(pACB->out_doorbell, &reg->iobound_doorbell);\n\tdo {\n\t\tif (arcmsr_hbaE_wait_msgint_ready(pACB))\n\t\t\tbreak;\n\t\tretry_count--;\n\t\tpr_notice(\"arcmsr%d: wait 'flush adapter \"\n\t\t\t\"cache' timeout, retry count down = %d\\n\",\n\t\t\tpACB->host->host_no, retry_count);\n\t} while (retry_count != 0);\n}\n\nstatic void arcmsr_flush_adapter_cache(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A:\n\t\tarcmsr_hbaA_flush_cache(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\tarcmsr_hbaB_flush_cache(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\tarcmsr_hbaC_flush_cache(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tarcmsr_hbaD_flush_cache(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\tcase ACB_ADAPTER_TYPE_F:\n\t\tarcmsr_hbaE_flush_cache(acb);\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_hbaB_assign_regAddr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\n\tif (acb->pdev->device == PCI_DEVICE_ID_ARECA_1203) {\n\t\treg->drv2iop_doorbell = MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL_1203);\n\t\treg->drv2iop_doorbell_mask = MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL_MASK_1203);\n\t\treg->iop2drv_doorbell = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL_1203);\n\t\treg->iop2drv_doorbell_mask = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL_MASK_1203);\n\t} else {\n\t\treg->drv2iop_doorbell= MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL);\n\t\treg->drv2iop_doorbell_mask = MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL_MASK);\n\t\treg->iop2drv_doorbell = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL);\n\t\treg->iop2drv_doorbell_mask = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL_MASK);\n\t}\n\treg->message_wbuffer = MEM_BASE1(ARCMSR_MESSAGE_WBUFFER);\n\treg->message_rbuffer =  MEM_BASE1(ARCMSR_MESSAGE_RBUFFER);\n\treg->message_rwbuffer = MEM_BASE1(ARCMSR_MESSAGE_RWBUFFER);\n}\n\nstatic void arcmsr_hbaD_assign_regAddr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_D *reg = acb->pmuD;\n\n\treg->chip_id = MEM_BASE0(ARCMSR_ARC1214_CHIP_ID);\n\treg->cpu_mem_config = MEM_BASE0(ARCMSR_ARC1214_CPU_MEMORY_CONFIGURATION);\n\treg->i2o_host_interrupt_mask = MEM_BASE0(ARCMSR_ARC1214_I2_HOST_INTERRUPT_MASK);\n\treg->sample_at_reset = MEM_BASE0(ARCMSR_ARC1214_SAMPLE_RESET);\n\treg->reset_request = MEM_BASE0(ARCMSR_ARC1214_RESET_REQUEST);\n\treg->host_int_status = MEM_BASE0(ARCMSR_ARC1214_MAIN_INTERRUPT_STATUS);\n\treg->pcief0_int_enable = MEM_BASE0(ARCMSR_ARC1214_PCIE_F0_INTERRUPT_ENABLE);\n\treg->inbound_msgaddr0 = MEM_BASE0(ARCMSR_ARC1214_INBOUND_MESSAGE0);\n\treg->inbound_msgaddr1 = MEM_BASE0(ARCMSR_ARC1214_INBOUND_MESSAGE1);\n\treg->outbound_msgaddr0 = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_MESSAGE0);\n\treg->outbound_msgaddr1 = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_MESSAGE1);\n\treg->inbound_doorbell = MEM_BASE0(ARCMSR_ARC1214_INBOUND_DOORBELL);\n\treg->outbound_doorbell = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_DOORBELL);\n\treg->outbound_doorbell_enable = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_DOORBELL_ENABLE);\n\treg->inboundlist_base_low = MEM_BASE0(ARCMSR_ARC1214_INBOUND_LIST_BASE_LOW);\n\treg->inboundlist_base_high = MEM_BASE0(ARCMSR_ARC1214_INBOUND_LIST_BASE_HIGH);\n\treg->inboundlist_write_pointer = MEM_BASE0(ARCMSR_ARC1214_INBOUND_LIST_WRITE_POINTER);\n\treg->outboundlist_base_low = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_BASE_LOW);\n\treg->outboundlist_base_high = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_BASE_HIGH);\n\treg->outboundlist_copy_pointer = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_COPY_POINTER);\n\treg->outboundlist_read_pointer = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_READ_POINTER);\n\treg->outboundlist_interrupt_cause = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_INTERRUPT_CAUSE);\n\treg->outboundlist_interrupt_enable = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_INTERRUPT_ENABLE);\n\treg->message_wbuffer = MEM_BASE0(ARCMSR_ARC1214_MESSAGE_WBUFFER);\n\treg->message_rbuffer = MEM_BASE0(ARCMSR_ARC1214_MESSAGE_RBUFFER);\n\treg->msgcode_rwbuffer = MEM_BASE0(ARCMSR_ARC1214_MESSAGE_RWBUFFER);\n}\n\nstatic void arcmsr_hbaF_assign_regAddr(struct AdapterControlBlock *acb)\n{\n\tdma_addr_t host_buffer_dma;\n\tstruct MessageUnit_F __iomem *pmuF;\n\n\tmemset(acb->dma_coherent2, 0xff, acb->completeQ_size);\n\tacb->message_wbuffer = (uint32_t *)round_up((unsigned long)acb->dma_coherent2 +\n\t\tacb->completeQ_size, 4);\n\tacb->message_rbuffer = ((void *)acb->message_wbuffer) + 0x100;\n\tacb->msgcode_rwbuffer = ((void *)acb->message_wbuffer) + 0x200;\n\tmemset((void *)acb->message_wbuffer, 0, MESG_RW_BUFFER_SIZE);\n\thost_buffer_dma = round_up(acb->dma_coherent_handle2 + acb->completeQ_size, 4);\n\tpmuF = acb->pmuF;\n\t/* host buffer low address, bit0:1 all buffer active */\n\twritel(lower_32_bits(host_buffer_dma | 1), &pmuF->inbound_msgaddr0);\n\t/* host buffer high address */\n\twritel(upper_32_bits(host_buffer_dma), &pmuF->inbound_msgaddr1);\n\t/* set host buffer physical address */\n\twritel(ARCMSR_HBFMU_DOORBELL_SYNC1, &pmuF->iobound_doorbell);\n}\n\nstatic bool arcmsr_alloc_io_queue(struct AdapterControlBlock *acb)\n{\n\tbool rtn = true;\n\tvoid *dma_coherent;\n\tdma_addr_t dma_coherent_handle;\n\tstruct pci_dev *pdev = acb->pdev;\n\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tacb->ioqueue_size = roundup(sizeof(struct MessageUnit_B), 32);\n\t\tdma_coherent = dma_alloc_coherent(&pdev->dev, acb->ioqueue_size,\n\t\t\t&dma_coherent_handle, GFP_KERNEL);\n\t\tif (!dma_coherent) {\n\t\t\tpr_notice(\"arcmsr%d: DMA allocation failed\\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tacb->dma_coherent_handle2 = dma_coherent_handle;\n\t\tacb->dma_coherent2 = dma_coherent;\n\t\tacb->pmuB = (struct MessageUnit_B *)dma_coherent;\n\t\tarcmsr_hbaB_assign_regAddr(acb);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tacb->ioqueue_size = roundup(sizeof(struct MessageUnit_D), 32);\n\t\tdma_coherent = dma_alloc_coherent(&pdev->dev, acb->ioqueue_size,\n\t\t\t&dma_coherent_handle, GFP_KERNEL);\n\t\tif (!dma_coherent) {\n\t\t\tpr_notice(\"arcmsr%d: DMA allocation failed\\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tacb->dma_coherent_handle2 = dma_coherent_handle;\n\t\tacb->dma_coherent2 = dma_coherent;\n\t\tacb->pmuD = (struct MessageUnit_D *)dma_coherent;\n\t\tarcmsr_hbaD_assign_regAddr(acb);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E: {\n\t\tuint32_t completeQ_size;\n\t\tcompleteQ_size = sizeof(struct deliver_completeQ) * ARCMSR_MAX_HBE_DONEQUEUE + 128;\n\t\tacb->ioqueue_size = roundup(completeQ_size, 32);\n\t\tdma_coherent = dma_alloc_coherent(&pdev->dev, acb->ioqueue_size,\n\t\t\t&dma_coherent_handle, GFP_KERNEL);\n\t\tif (!dma_coherent){\n\t\t\tpr_notice(\"arcmsr%d: DMA allocation failed\\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tacb->dma_coherent_handle2 = dma_coherent_handle;\n\t\tacb->dma_coherent2 = dma_coherent;\n\t\tacb->pCompletionQ = dma_coherent;\n\t\tacb->completionQ_entry = acb->ioqueue_size / sizeof(struct deliver_completeQ);\n\t\tacb->doneq_index = 0;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_F: {\n\t\tuint32_t QueueDepth;\n\t\tuint32_t depthTbl[] = {256, 512, 1024, 128, 64, 32};\n\n\t\tarcmsr_wait_firmware_ready(acb);\n\t\tQueueDepth = depthTbl[readl(&acb->pmuF->outbound_msgaddr1) & 7];\n\t\tacb->completeQ_size = sizeof(struct deliver_completeQ) * QueueDepth + 128;\n\t\tacb->ioqueue_size = roundup(acb->completeQ_size + MESG_RW_BUFFER_SIZE, 32);\n\t\tdma_coherent = dma_alloc_coherent(&pdev->dev, acb->ioqueue_size,\n\t\t\t&dma_coherent_handle, GFP_KERNEL);\n\t\tif (!dma_coherent) {\n\t\t\tpr_notice(\"arcmsr%d: DMA allocation failed\\n\", acb->host->host_no);\n\t\t\treturn false;\n\t\t}\n\t\tacb->dma_coherent_handle2 = dma_coherent_handle;\n\t\tacb->dma_coherent2 = dma_coherent;\n\t\tacb->pCompletionQ = dma_coherent;\n\t\tacb->completionQ_entry = acb->completeQ_size / sizeof(struct deliver_completeQ);\n\t\tacb->doneq_index = 0;\n\t\tarcmsr_hbaF_assign_regAddr(acb);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_alloc_ccb_pool(struct AdapterControlBlock *acb)\n{\n\tstruct pci_dev *pdev = acb->pdev;\n\tvoid *dma_coherent;\n\tdma_addr_t dma_coherent_handle;\n\tstruct CommandControlBlock *ccb_tmp;\n\tint i = 0, j = 0;\n\tunsigned long cdb_phyaddr, next_ccb_phy;\n\tunsigned long roundup_ccbsize;\n\tunsigned long max_xfer_len;\n\tunsigned long max_sg_entrys;\n\tuint32_t  firm_config_version, curr_phy_upper32;\n\n\tfor (i = 0; i < ARCMSR_MAX_TARGETID; i++)\n\t\tfor (j = 0; j < ARCMSR_MAX_TARGETLUN; j++)\n\t\t\tacb->devstate[i][j] = ARECA_RAID_GONE;\n\n\tmax_xfer_len = ARCMSR_MAX_XFER_LEN;\n\tmax_sg_entrys = ARCMSR_DEFAULT_SG_ENTRIES;\n\tfirm_config_version = acb->firm_cfg_version;\n\tif((firm_config_version & 0xFF) >= 3){\n\t\tmax_xfer_len = (ARCMSR_CDB_SG_PAGE_LENGTH << ((firm_config_version >> 8) & 0xFF)) * 1024;/* max 4M byte */\n\t\tmax_sg_entrys = (max_xfer_len/4096);\n\t}\n\tacb->host->max_sectors = max_xfer_len/512;\n\tacb->host->sg_tablesize = max_sg_entrys;\n\troundup_ccbsize = roundup(sizeof(struct CommandControlBlock) + (max_sg_entrys - 1) * sizeof(struct SG64ENTRY), 32);\n\tacb->uncache_size = roundup_ccbsize * acb->maxFreeCCB;\n\tif (acb->adapter_type != ACB_ADAPTER_TYPE_F)\n\t\tacb->uncache_size += acb->ioqueue_size;\n\tdma_coherent = dma_alloc_coherent(&pdev->dev, acb->uncache_size, &dma_coherent_handle, GFP_KERNEL);\n\tif(!dma_coherent){\n\t\tprintk(KERN_NOTICE \"arcmsr%d: dma_alloc_coherent got error\\n\", acb->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\tacb->dma_coherent = dma_coherent;\n\tacb->dma_coherent_handle = dma_coherent_handle;\n\tmemset(dma_coherent, 0, acb->uncache_size);\n\tacb->ccbsize = roundup_ccbsize;\n\tccb_tmp = dma_coherent;\n\tcurr_phy_upper32 = upper_32_bits(dma_coherent_handle);\n\tacb->vir2phy_offset = (unsigned long)dma_coherent - (unsigned long)dma_coherent_handle;\n\tfor(i = 0; i < acb->maxFreeCCB; i++){\n\t\tcdb_phyaddr = (unsigned long)dma_coherent_handle + offsetof(struct CommandControlBlock, arcmsr_cdb);\n\t\tswitch (acb->adapter_type) {\n\t\tcase ACB_ADAPTER_TYPE_A:\n\t\tcase ACB_ADAPTER_TYPE_B:\n\t\t\tccb_tmp->cdb_phyaddr = cdb_phyaddr >> 5;\n\t\t\tbreak;\n\t\tcase ACB_ADAPTER_TYPE_C:\n\t\tcase ACB_ADAPTER_TYPE_D:\n\t\tcase ACB_ADAPTER_TYPE_E:\n\t\tcase ACB_ADAPTER_TYPE_F:\n\t\t\tccb_tmp->cdb_phyaddr = cdb_phyaddr;\n\t\t\tbreak;\n\t\t}\n\t\tacb->pccb_pool[i] = ccb_tmp;\n\t\tccb_tmp->acb = acb;\n\t\tccb_tmp->smid = (u32)i << 16;\n\t\tINIT_LIST_HEAD(&ccb_tmp->list);\n\t\tnext_ccb_phy = dma_coherent_handle + roundup_ccbsize;\n\t\tif (upper_32_bits(next_ccb_phy) != curr_phy_upper32) {\n\t\t\tacb->maxFreeCCB = i;\n\t\t\tacb->host->can_queue = i;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tlist_add_tail(&ccb_tmp->list, &acb->ccb_free_list);\n\t\tccb_tmp = (struct CommandControlBlock *)((unsigned long)ccb_tmp + roundup_ccbsize);\n\t\tdma_coherent_handle = next_ccb_phy;\n\t}\n\tif (acb->adapter_type != ACB_ADAPTER_TYPE_F) {\n\t\tacb->dma_coherent_handle2 = dma_coherent_handle;\n\t\tacb->dma_coherent2 = ccb_tmp;\n\t}\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_B:\n\t\tacb->pmuB = (struct MessageUnit_B *)acb->dma_coherent2;\n\t\tarcmsr_hbaB_assign_regAddr(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tacb->pmuD = (struct MessageUnit_D *)acb->dma_coherent2;\n\t\tarcmsr_hbaD_assign_regAddr(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\t\tacb->pCompletionQ = acb->dma_coherent2;\n\t\tacb->completionQ_entry = acb->ioqueue_size / sizeof(struct deliver_completeQ);\n\t\tacb->doneq_index = 0;\n\t\tbreak;\n\t}\t\n\treturn 0;\n}\n\nstatic void arcmsr_message_isr_bh_fn(struct work_struct *work) \n{\n\tstruct AdapterControlBlock *acb = container_of(work,\n\t\tstruct AdapterControlBlock, arcmsr_do_message_isr_bh);\n\tchar *acb_dev_map = (char *)acb->device_map;\n\tuint32_t __iomem *signature = NULL;\n\tchar __iomem *devicemap = NULL;\n\tint target, lun;\n\tstruct scsi_device *psdev;\n\tchar diff, temp;\n\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg  = acb->pmuA;\n\n\t\tsignature = (uint32_t __iomem *)(&reg->message_rwbuffer[0]);\n\t\tdevicemap = (char __iomem *)(&reg->message_rwbuffer[21]);\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg  = acb->pmuB;\n\n\t\tsignature = (uint32_t __iomem *)(&reg->message_rwbuffer[0]);\n\t\tdevicemap = (char __iomem *)(&reg->message_rwbuffer[21]);\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg  = acb->pmuC;\n\n\t\tsignature = (uint32_t __iomem *)(&reg->msgcode_rwbuffer[0]);\n\t\tdevicemap = (char __iomem *)(&reg->msgcode_rwbuffer[21]);\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg  = acb->pmuD;\n\n\t\tsignature = (uint32_t __iomem *)(&reg->msgcode_rwbuffer[0]);\n\t\tdevicemap = (char __iomem *)(&reg->msgcode_rwbuffer[21]);\n\t\tbreak;\n\t}\n\tcase ACB_ADAPTER_TYPE_E: {\n\t\tstruct MessageUnit_E __iomem *reg  = acb->pmuE;\n\n\t\tsignature = (uint32_t __iomem *)(&reg->msgcode_rwbuffer[0]);\n\t\tdevicemap = (char __iomem *)(&reg->msgcode_rwbuffer[21]);\n\t\tbreak;\n\t\t}\n\tcase ACB_ADAPTER_TYPE_F: {\n\t\tsignature = (uint32_t __iomem *)(&acb->msgcode_rwbuffer[0]);\n\t\tdevicemap = (char __iomem *)(&acb->msgcode_rwbuffer[21]);\n\t\tbreak;\n\t\t}\n\t}\n\tif (readl(signature) != ARCMSR_SIGNATURE_GET_CONFIG)\n\t\treturn;\n\tfor (target = 0; target < ARCMSR_MAX_TARGETID - 1;\n\t\ttarget++) {\n\t\ttemp = readb(devicemap);\n\t\tdiff = (*acb_dev_map) ^ temp;\n\t\tif (diff != 0) {\n\t\t\t*acb_dev_map = temp;\n\t\t\tfor (lun = 0; lun < ARCMSR_MAX_TARGETLUN;\n\t\t\t\tlun++) {\n\t\t\t\tif ((diff & 0x01) == 1 &&\n\t\t\t\t\t(temp & 0x01) == 1) {\n\t\t\t\t\tscsi_add_device(acb->host,\n\t\t\t\t\t\t0, target, lun);\n\t\t\t\t} else if ((diff & 0x01) == 1\n\t\t\t\t\t&& (temp & 0x01) == 0) {\n\t\t\t\t\tpsdev = scsi_device_lookup(acb->host,\n\t\t\t\t\t\t0, target, lun);\n\t\t\t\t\tif (psdev != NULL) {\n\t\t\t\t\t\tscsi_remove_device(psdev);\n\t\t\t\t\t\tscsi_device_put(psdev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttemp >>= 1;\n\t\t\t\tdiff >>= 1;\n\t\t\t}\n\t\t}\n\t\tdevicemap++;\n\t\tacb_dev_map++;\n\t}\n\tacb->acb_flags &= ~ACB_F_MSG_GET_CONFIG;\n}\n\nstatic int\narcmsr_request_irq(struct pci_dev *pdev, struct AdapterControlBlock *acb)\n{\n\tunsigned long flags;\n\tint nvec, i;\n\n\tif (msix_enable == 0)\n\t\tgoto msi_int0;\n\tnvec = pci_alloc_irq_vectors(pdev, 1, ARCMST_NUM_MSIX_VECTORS,\n\t\t\tPCI_IRQ_MSIX);\n\tif (nvec > 0) {\n\t\tpr_info(\"arcmsr%d: msi-x enabled\\n\", acb->host->host_no);\n\t\tflags = 0;\n\t} else {\nmsi_int0:\n\t\tif (msi_enable == 1) {\n\t\t\tnvec = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\t\t\tif (nvec == 1) {\n\t\t\t\tdev_info(&pdev->dev, \"msi enabled\\n\");\n\t\t\t\tgoto msi_int1;\n\t\t\t}\n\t\t}\n\t\tnvec = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_LEGACY);\n\t\tif (nvec < 1)\n\t\t\treturn FAILED;\nmsi_int1:\n\t\tflags = IRQF_SHARED;\n\t}\n\n\tacb->vector_count = nvec;\n\tfor (i = 0; i < nvec; i++) {\n\t\tif (request_irq(pci_irq_vector(pdev, i), arcmsr_do_interrupt,\n\t\t\t\tflags, \"arcmsr\", acb)) {\n\t\t\tpr_warn(\"arcmsr%d: request_irq =%d failed!\\n\",\n\t\t\t\tacb->host->host_no, pci_irq_vector(pdev, i));\n\t\t\tgoto out_free_irq;\n\t\t}\n\t}\n\n\treturn SUCCESS;\nout_free_irq:\n\twhile (--i >= 0)\n\t\tfree_irq(pci_irq_vector(pdev, i), acb);\n\tpci_free_irq_vectors(pdev);\n\treturn FAILED;\n}\n\nstatic void arcmsr_init_get_devmap_timer(struct AdapterControlBlock *pacb)\n{\n\tINIT_WORK(&pacb->arcmsr_do_message_isr_bh, arcmsr_message_isr_bh_fn);\n\tpacb->fw_flag = FW_NORMAL;\n\ttimer_setup(&pacb->eternal_timer, arcmsr_request_device_map, 0);\n\tpacb->eternal_timer.expires = jiffies + msecs_to_jiffies(6 * HZ);\n\tadd_timer(&pacb->eternal_timer);\n}\n\nstatic void arcmsr_init_set_datetime_timer(struct AdapterControlBlock *pacb)\n{\n\ttimer_setup(&pacb->refresh_timer, arcmsr_set_iop_datetime, 0);\n\tpacb->refresh_timer.expires = jiffies + msecs_to_jiffies(60 * 1000);\n\tadd_timer(&pacb->refresh_timer);\n}\n\nstatic int arcmsr_set_dma_mask(struct AdapterControlBlock *acb)\n{\n\tstruct pci_dev *pcidev = acb->pdev;\n\n\tif (IS_DMA64) {\n\t\tif (((acb->adapter_type == ACB_ADAPTER_TYPE_A) && !dma_mask_64) ||\n\t\t    dma_set_mask(&pcidev->dev, DMA_BIT_MASK(64)))\n\t\t\tgoto\tdma32;\n\t\tif (acb->adapter_type <= ACB_ADAPTER_TYPE_B)\n\t\t\treturn 0;\n\t\tif (dma_set_coherent_mask(&pcidev->dev, DMA_BIT_MASK(64)) ||\n\t\t    dma_set_mask_and_coherent(&pcidev->dev, DMA_BIT_MASK(64))) {\n\t\t\tprintk(\"arcmsr: set DMA 64 mask failed\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t} else {\ndma32:\n\t\tif (dma_set_mask(&pcidev->dev, DMA_BIT_MASK(32)) ||\n\t\t    dma_set_coherent_mask(&pcidev->dev, DMA_BIT_MASK(32)) ||\n\t\t    dma_set_mask_and_coherent(&pcidev->dev, DMA_BIT_MASK(32))) {\n\t\t\tprintk(\"arcmsr: set DMA 32-bit mask failed\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int arcmsr_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct Scsi_Host *host;\n\tstruct AdapterControlBlock *acb;\n\tuint8_t bus,dev_fun;\n\tint error;\n\terror = pci_enable_device(pdev);\n\tif(error){\n\t\treturn -ENODEV;\n\t}\n\thost = scsi_host_alloc(&arcmsr_scsi_host_template, sizeof(struct AdapterControlBlock));\n\tif(!host){\n    \t\tgoto pci_disable_dev;\n\t}\n\tinit_waitqueue_head(&wait_q);\n\tbus = pdev->bus->number;\n\tdev_fun = pdev->devfn;\n\tacb = (struct AdapterControlBlock *) host->hostdata;\n\tmemset(acb,0,sizeof(struct AdapterControlBlock));\n\tacb->pdev = pdev;\n\tacb->adapter_type = id->driver_data;\n\tif (arcmsr_set_dma_mask(acb))\n\t\tgoto scsi_host_release;\n\tacb->host = host;\n\thost->max_lun = ARCMSR_MAX_TARGETLUN;\n\thost->max_id = ARCMSR_MAX_TARGETID;\t\t/*16:8*/\n\thost->max_cmd_len = 16;\t \t\t\t/*this is issue of 64bit LBA ,over 2T byte*/\n\tif ((host_can_queue < ARCMSR_MIN_OUTSTANDING_CMD) || (host_can_queue > ARCMSR_MAX_OUTSTANDING_CMD))\n\t\thost_can_queue = ARCMSR_DEFAULT_OUTSTANDING_CMD;\n\thost->can_queue = host_can_queue;\t/* max simultaneous cmds */\n\tif ((cmd_per_lun < ARCMSR_MIN_CMD_PERLUN) || (cmd_per_lun > ARCMSR_MAX_CMD_PERLUN))\n\t\tcmd_per_lun = ARCMSR_DEFAULT_CMD_PERLUN;\n\thost->cmd_per_lun = cmd_per_lun;\n\thost->this_id = ARCMSR_SCSI_INITIATOR_ID;\n\thost->unique_id = (bus << 8) | dev_fun;\n\tpci_set_drvdata(pdev, host);\n\tpci_set_master(pdev);\n\terror = pci_request_regions(pdev, \"arcmsr\");\n\tif(error){\n\t\tgoto scsi_host_release;\n\t}\n\tspin_lock_init(&acb->eh_lock);\n\tspin_lock_init(&acb->ccblist_lock);\n\tspin_lock_init(&acb->postq_lock);\n\tspin_lock_init(&acb->doneq_lock);\n\tspin_lock_init(&acb->rqbuffer_lock);\n\tspin_lock_init(&acb->wqbuffer_lock);\n\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_RQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\tacb->acb_flags &= ~ACB_F_SCSISTOPADAPTER;\n\tINIT_LIST_HEAD(&acb->ccb_free_list);\n\terror = arcmsr_remap_pciregion(acb);\n\tif(!error){\n\t\tgoto pci_release_regs;\n\t}\n\terror = arcmsr_alloc_io_queue(acb);\n\tif (!error)\n\t\tgoto unmap_pci_region;\n\terror = arcmsr_get_firmware_spec(acb);\n\tif(!error){\n\t\tgoto free_hbb_mu;\n\t}\n\tif (acb->adapter_type != ACB_ADAPTER_TYPE_F)\n\t\tarcmsr_free_io_queue(acb);\n\terror = arcmsr_alloc_ccb_pool(acb);\n\tif(error){\n\t\tgoto unmap_pci_region;\n\t}\n\terror = scsi_add_host(host, &pdev->dev);\n\tif(error){\n\t\tgoto free_ccb_pool;\n\t}\n\tif (arcmsr_request_irq(pdev, acb) == FAILED)\n\t\tgoto scsi_host_remove;\n\tarcmsr_iop_init(acb);\n\tarcmsr_init_get_devmap_timer(acb);\n\tif (set_date_time)\n\t\tarcmsr_init_set_datetime_timer(acb);\n\tif(arcmsr_alloc_sysfs_attr(acb))\n\t\tgoto out_free_sysfs;\n\tscsi_scan_host(host);\n\treturn 0;\nout_free_sysfs:\n\tif (set_date_time)\n\t\tdel_timer_sync(&acb->refresh_timer);\n\tdel_timer_sync(&acb->eternal_timer);\n\tflush_work(&acb->arcmsr_do_message_isr_bh);\n\tarcmsr_stop_adapter_bgrb(acb);\n\tarcmsr_flush_adapter_cache(acb);\n\tarcmsr_free_irq(pdev, acb);\nscsi_host_remove:\n\tscsi_remove_host(host);\nfree_ccb_pool:\n\tarcmsr_free_ccb_pool(acb);\n\tgoto unmap_pci_region;\nfree_hbb_mu:\n\tarcmsr_free_io_queue(acb);\nunmap_pci_region:\n\tarcmsr_unmap_pciregion(acb);\npci_release_regs:\n\tpci_release_regions(pdev);\nscsi_host_release:\n\tscsi_host_put(host);\npci_disable_dev:\n\tpci_disable_device(pdev);\n\treturn -ENODEV;\n}\n\nstatic void arcmsr_free_irq(struct pci_dev *pdev,\n\t\tstruct AdapterControlBlock *acb)\n{\n\tint i;\n\n\tfor (i = 0; i < acb->vector_count; i++)\n\t\tfree_irq(pci_irq_vector(pdev, i), acb);\n\tpci_free_irq_vectors(pdev);\n}\n\nstatic int __maybe_unused arcmsr_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *)host->hostdata;\n\n\tarcmsr_disable_outbound_ints(acb);\n\tarcmsr_free_irq(pdev, acb);\n\tdel_timer_sync(&acb->eternal_timer);\n\tif (set_date_time)\n\t\tdel_timer_sync(&acb->refresh_timer);\n\tflush_work(&acb->arcmsr_do_message_isr_bh);\n\tarcmsr_stop_adapter_bgrb(acb);\n\tarcmsr_flush_adapter_cache(acb);\n\treturn 0;\n}\n\nstatic int __maybe_unused arcmsr_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *)host->hostdata;\n\n\tif (arcmsr_set_dma_mask(acb))\n\t\tgoto controller_unregister;\n\tif (arcmsr_request_irq(pdev, acb) == FAILED)\n\t\tgoto controller_stop;\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\tuint32_t i;\n\t\tfor (i = 0; i < ARCMSR_MAX_HBB_POSTQUEUE; i++) {\n\t\t\treg->post_qbuffer[i] = 0;\n\t\t\treg->done_qbuffer[i] = 0;\n\t\t}\n\t\treg->postq_index = 0;\n\t\treg->doneq_index = 0;\n\t\tbreak;\n\t\t}\n\tcase ACB_ADAPTER_TYPE_E:\n\t\twritel(0, &acb->pmuE->host_int_status);\n\t\twritel(ARCMSR_HBEMU_DOORBELL_SYNC, &acb->pmuE->iobound_doorbell);\n\t\tacb->in_doorbell = 0;\n\t\tacb->out_doorbell = 0;\n\t\tacb->doneq_index = 0;\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_F:\n\t\twritel(0, &acb->pmuF->host_int_status);\n\t\twritel(ARCMSR_HBFMU_DOORBELL_SYNC, &acb->pmuF->iobound_doorbell);\n\t\tacb->in_doorbell = 0;\n\t\tacb->out_doorbell = 0;\n\t\tacb->doneq_index = 0;\n\t\tarcmsr_hbaF_assign_regAddr(acb);\n\t\tbreak;\n\t}\n\tarcmsr_iop_init(acb);\n\tarcmsr_init_get_devmap_timer(acb);\n\tif (set_date_time)\n\t\tarcmsr_init_set_datetime_timer(acb);\n\treturn 0;\ncontroller_stop:\n\tarcmsr_stop_adapter_bgrb(acb);\n\tarcmsr_flush_adapter_cache(acb);\ncontroller_unregister:\n\tscsi_remove_host(host);\n\tarcmsr_free_ccb_pool(acb);\n\tif (acb->adapter_type == ACB_ADAPTER_TYPE_F)\n\t\tarcmsr_free_io_queue(acb);\n\tarcmsr_unmap_pciregion(acb);\n\tscsi_host_put(host);\n\treturn -ENODEV;\n}\n\nstatic uint8_t arcmsr_hbaA_abort_allcmd(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\twritel(ARCMSR_INBOUND_MESG0_ABORT_CMD, &reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'abort all outstanding command' timeout\\n\"\n\t\t\t, acb->host->host_no);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic uint8_t arcmsr_hbaB_abort_allcmd(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\n\twritel(ARCMSR_MESSAGE_ABORT_CMD, reg->drv2iop_doorbell);\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'abort all outstanding command' timeout\\n\"\n\t\t\t, acb->host->host_no);\n\t\treturn false;\n\t}\n\treturn true;\n}\nstatic uint8_t arcmsr_hbaC_abort_allcmd(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\twritel(ARCMSR_INBOUND_MESG0_ABORT_CMD, &reg->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\tif (!arcmsr_hbaC_wait_msgint_ready(pACB)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'abort all outstanding command' timeout\\n\"\n\t\t\t, pACB->host->host_no);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic uint8_t arcmsr_hbaD_abort_allcmd(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_D *reg = pACB->pmuD;\n\n\twritel(ARCMSR_INBOUND_MESG0_ABORT_CMD, reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaD_wait_msgint_ready(pACB)) {\n\t\tpr_notice(\"arcmsr%d: wait 'abort all outstanding \"\n\t\t\t\"command' timeout\\n\", pACB->host->host_no);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic uint8_t arcmsr_hbaE_abort_allcmd(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_E __iomem *reg = pACB->pmuE;\n\n\twritel(ARCMSR_INBOUND_MESG0_ABORT_CMD, &reg->inbound_msgaddr0);\n\tpACB->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_MESSAGE_CMD_DONE;\n\twritel(pACB->out_doorbell, &reg->iobound_doorbell);\n\tif (!arcmsr_hbaE_wait_msgint_ready(pACB)) {\n\t\tpr_notice(\"arcmsr%d: wait 'abort all outstanding \"\n\t\t\t\"command' timeout\\n\", pACB->host->host_no);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic uint8_t arcmsr_abort_allcmd(struct AdapterControlBlock *acb)\n{\n\tuint8_t rtnval = 0;\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\trtnval = arcmsr_hbaA_abort_allcmd(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\trtnval = arcmsr_hbaB_abort_allcmd(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\trtnval = arcmsr_hbaC_abort_allcmd(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\trtnval = arcmsr_hbaD_abort_allcmd(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\tcase ACB_ADAPTER_TYPE_F:\n\t\trtnval = arcmsr_hbaE_abort_allcmd(acb);\n\t\tbreak;\n\t}\n\treturn rtnval;\n}\n\nstatic void arcmsr_ccb_complete(struct CommandControlBlock *ccb)\n{\n\tstruct AdapterControlBlock *acb = ccb->acb;\n\tstruct scsi_cmnd *pcmd = ccb->pcmd;\n\tunsigned long flags;\n\tatomic_dec(&acb->ccboutstandingcount);\n\tscsi_dma_unmap(ccb->pcmd);\n\tccb->startdone = ARCMSR_CCB_DONE;\n\tspin_lock_irqsave(&acb->ccblist_lock, flags);\n\tlist_add_tail(&ccb->list, &acb->ccb_free_list);\n\tspin_unlock_irqrestore(&acb->ccblist_lock, flags);\n\tscsi_done(pcmd);\n}\n\nstatic void arcmsr_report_sense_info(struct CommandControlBlock *ccb)\n{\n\tstruct scsi_cmnd *pcmd = ccb->pcmd;\n\n\tpcmd->result = (DID_OK << 16) | SAM_STAT_CHECK_CONDITION;\n\tif (pcmd->sense_buffer) {\n\t\tstruct SENSE_DATA *sensebuffer;\n\n\t\tmemcpy_and_pad(pcmd->sense_buffer,\n\t\t\t       SCSI_SENSE_BUFFERSIZE,\n\t\t\t       ccb->arcmsr_cdb.SenseData,\n\t\t\t       sizeof(ccb->arcmsr_cdb.SenseData),\n\t\t\t       0);\n\n\t\tsensebuffer = (struct SENSE_DATA *)pcmd->sense_buffer;\n\t\tsensebuffer->ErrorCode = SCSI_SENSE_CURRENT_ERRORS;\n\t\tsensebuffer->Valid = 1;\n\t}\n}\n\nstatic u32 arcmsr_disable_outbound_ints(struct AdapterControlBlock *acb)\n{\n\tu32 orig_mask = 0;\n\tswitch (acb->adapter_type) {\t\n\tcase ACB_ADAPTER_TYPE_A : {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\torig_mask = readl(&reg->outbound_intmask);\n\t\twritel(orig_mask|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE, \\\n\t\t\t\t\t\t&reg->outbound_intmask);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B : {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\torig_mask = readl(reg->iop2drv_doorbell_mask);\n\t\twritel(0, reg->iop2drv_doorbell_mask);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:{\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\t \n\t\torig_mask = readl(&reg->host_int_mask);  \n\t\twritel(orig_mask|ARCMSR_HBCMU_ALL_INTMASKENABLE, &reg->host_int_mask);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\t \n\t\twritel(ARCMSR_ARC1214_ALL_INT_DISABLE, reg->pcief0_int_enable);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\tcase ACB_ADAPTER_TYPE_F: {\n\t\tstruct MessageUnit_E __iomem *reg = acb->pmuE;\n\t\torig_mask = readl(&reg->host_int_mask);\n\t\twritel(orig_mask | ARCMSR_HBEMU_OUTBOUND_DOORBELL_ISR | ARCMSR_HBEMU_OUTBOUND_POSTQUEUE_ISR, &reg->host_int_mask);\n\t\treadl(&reg->host_int_mask);  \n\t\t}\n\t\tbreak;\n\t}\n\treturn orig_mask;\n}\n\nstatic void arcmsr_report_ccb_state(struct AdapterControlBlock *acb, \n\t\t\tstruct CommandControlBlock *ccb, bool error)\n{\n\tuint8_t id, lun;\n\tid = ccb->pcmd->device->id;\n\tlun = ccb->pcmd->device->lun;\n\tif (!error) {\n\t\tif (acb->devstate[id][lun] == ARECA_RAID_GONE)\n\t\t\tacb->devstate[id][lun] = ARECA_RAID_GOOD;\n\t\tccb->pcmd->result = DID_OK << 16;\n\t\tarcmsr_ccb_complete(ccb);\n\t}else{\n\t\tswitch (ccb->arcmsr_cdb.DeviceStatus) {\n\t\tcase ARCMSR_DEV_SELECT_TIMEOUT: {\n\t\t\tacb->devstate[id][lun] = ARECA_RAID_GONE;\n\t\t\tccb->pcmd->result = DID_NO_CONNECT << 16;\n\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ARCMSR_DEV_ABORTED:\n\n\t\tcase ARCMSR_DEV_INIT_FAIL: {\n\t\t\tacb->devstate[id][lun] = ARECA_RAID_GONE;\n\t\t\tccb->pcmd->result = DID_BAD_TARGET << 16;\n\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ARCMSR_DEV_CHECK_CONDITION: {\n\t\t\tacb->devstate[id][lun] = ARECA_RAID_GOOD;\n\t\t\tarcmsr_report_sense_info(ccb);\n\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"arcmsr%d: scsi id = %d lun = %d isr get command error done, \\\n\t\t\t\tbut got unknown DeviceStatus = 0x%x \\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, id\n\t\t\t\t, lun\n\t\t\t\t, ccb->arcmsr_cdb.DeviceStatus);\n\t\t\t\tacb->devstate[id][lun] = ARECA_RAID_GONE;\n\t\t\t\tccb->pcmd->result = DID_NO_CONNECT << 16;\n\t\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void arcmsr_drain_donequeue(struct AdapterControlBlock *acb, struct CommandControlBlock *pCCB, bool error)\n{\n\tif ((pCCB->acb != acb) || (pCCB->startdone != ARCMSR_CCB_START)) {\n\t\tif (pCCB->startdone == ARCMSR_CCB_ABORTED) {\n\t\t\tstruct scsi_cmnd *abortcmd = pCCB->pcmd;\n\t\t\tif (abortcmd) {\n\t\t\t\tabortcmd->result |= DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(pCCB);\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: pCCB ='0x%p' isr got aborted command \\n\",\n\t\t\t\tacb->host->host_no, pCCB);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tprintk(KERN_NOTICE \"arcmsr%d: isr get an illegal ccb command \\\n\t\t\t\tdone acb = '0x%p'\"\n\t\t\t\t\"ccb = '0x%p' ccbacb = '0x%p' startdone = 0x%x\"\n\t\t\t\t\" ccboutstandingcount = %d \\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, acb\n\t\t\t\t, pCCB\n\t\t\t\t, pCCB->acb\n\t\t\t\t, pCCB->startdone\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\treturn;\n\t}\n\tarcmsr_report_ccb_state(acb, pCCB, error);\n}\n\nstatic void arcmsr_done4abort_postqueue(struct AdapterControlBlock *acb)\n{\n\tint i = 0;\n\tuint32_t flag_ccb;\n\tstruct ARCMSR_CDB *pARCMSR_CDB;\n\tbool error;\n\tstruct CommandControlBlock *pCCB;\n\tunsigned long ccb_cdb_phy;\n\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tuint32_t outbound_intstatus;\n\t\toutbound_intstatus = readl(&reg->outbound_intstatus) &\n\t\t\t\t\tacb->outbound_int_enable;\n\t\t/*clear and abort all outbound posted Q*/\n\t\twritel(outbound_intstatus, &reg->outbound_intstatus);/*clear interrupt*/\n\t\twhile(((flag_ccb = readl(&reg->outbound_queueport)) != 0xFFFFFFFF)\n\t\t\t\t&& (i++ < acb->maxOutstanding)) {\n\t\t\tccb_cdb_phy = (flag_ccb << 5) & 0xffffffff;\n\t\t\tif (acb->cdb_phyadd_hipart)\n\t\t\t\tccb_cdb_phy = ccb_cdb_phy | acb->cdb_phyadd_hipart;\n\t\t\tpARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset + ccb_cdb_phy);\n\t\t\tpCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\n\t\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\t/*clear all outbound posted Q*/\n\t\twritel(ARCMSR_DOORBELL_INT_CLEAR_PATTERN, reg->iop2drv_doorbell); /* clear doorbell interrupt */\n\t\tfor (i = 0; i < ARCMSR_MAX_HBB_POSTQUEUE; i++) {\n\t\t\tflag_ccb = reg->done_qbuffer[i];\n\t\t\tif (flag_ccb != 0) {\n\t\t\t\treg->done_qbuffer[i] = 0;\n\t\t\t\tccb_cdb_phy = (flag_ccb << 5) & 0xffffffff;\n\t\t\t\tif (acb->cdb_phyadd_hipart)\n\t\t\t\t\tccb_cdb_phy = ccb_cdb_phy | acb->cdb_phyadd_hipart;\n\t\t\t\tpARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset + ccb_cdb_phy);\n\t\t\t\tpCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\n\t\t\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\t\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t\t\t}\n\t\t\treg->post_qbuffer[i] = 0;\n\t\t}\n\t\treg->doneq_index = 0;\n\t\treg->postq_index = 0;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\twhile ((readl(&reg->host_int_status) & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR) && (i++ < acb->maxOutstanding)) {\n\t\t\t/*need to do*/\n\t\t\tflag_ccb = readl(&reg->outbound_queueport_low);\n\t\t\tccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\n\t\t\tif (acb->cdb_phyadd_hipart)\n\t\t\t\tccb_cdb_phy = ccb_cdb_phy | acb->cdb_phyadd_hipart;\n\t\t\tpARCMSR_CDB = (struct  ARCMSR_CDB *)(acb->vir2phy_offset + ccb_cdb_phy);\n\t\t\tpCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\n\t\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ? true : false;\n\t\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D  *pmu = acb->pmuD;\n\t\tuint32_t outbound_write_pointer;\n\t\tuint32_t doneq_index, index_stripped, addressLow, residual, toggle;\n\t\tunsigned long flags;\n\n\t\tresidual = atomic_read(&acb->ccboutstandingcount);\n\t\tfor (i = 0; i < residual; i++) {\n\t\t\tspin_lock_irqsave(&acb->doneq_lock, flags);\n\t\t\toutbound_write_pointer =\n\t\t\t\tpmu->done_qbuffer[0].addressLow + 1;\n\t\t\tdoneq_index = pmu->doneq_index;\n\t\t\tif ((doneq_index & 0xFFF) !=\n\t\t\t\t(outbound_write_pointer & 0xFFF)) {\n\t\t\t\ttoggle = doneq_index & 0x4000;\n\t\t\t\tindex_stripped = (doneq_index & 0xFFF) + 1;\n\t\t\t\tindex_stripped %= ARCMSR_MAX_ARC1214_DONEQUEUE;\n\t\t\t\tpmu->doneq_index = index_stripped ? (index_stripped | toggle) :\n\t\t\t\t\t((toggle ^ 0x4000) + 1);\n\t\t\t\tdoneq_index = pmu->doneq_index;\n\t\t\t\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n\t\t\t\taddressLow = pmu->done_qbuffer[doneq_index &\n\t\t\t\t\t0xFFF].addressLow;\n\t\t\t\tccb_cdb_phy = (addressLow & 0xFFFFFFF0);\n\t\t\t\tif (acb->cdb_phyadd_hipart)\n\t\t\t\t\tccb_cdb_phy = ccb_cdb_phy | acb->cdb_phyadd_hipart;\n\t\t\t\tpARCMSR_CDB = (struct  ARCMSR_CDB *)\n\t\t\t\t\t(acb->vir2phy_offset + ccb_cdb_phy);\n\t\t\t\tpCCB = container_of(pARCMSR_CDB,\n\t\t\t\t\tstruct CommandControlBlock, arcmsr_cdb);\n\t\t\t\terror = (addressLow &\n\t\t\t\t\tARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ?\n\t\t\t\t\ttrue : false;\n\t\t\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t\t\t\twritel(doneq_index,\n\t\t\t\t\tpmu->outboundlist_read_pointer);\n\t\t\t} else {\n\t\t\t\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n\t\t\t\tmdelay(10);\n\t\t\t}\n\t\t}\n\t\tpmu->postq_index = 0;\n\t\tpmu->doneq_index = 0x40FF;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\t\tarcmsr_hbaE_postqueue_isr(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_F:\n\t\tarcmsr_hbaF_postqueue_isr(acb);\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_remove_scsi_devices(struct AdapterControlBlock *acb)\n{\n\tchar *acb_dev_map = (char *)acb->device_map;\n\tint target, lun, i;\n\tstruct scsi_device *psdev;\n\tstruct CommandControlBlock *ccb;\n\tchar temp;\n\n\tfor (i = 0; i < acb->maxFreeCCB; i++) {\n\t\tccb = acb->pccb_pool[i];\n\t\tif (ccb->startdone == ARCMSR_CCB_START) {\n\t\t\tccb->pcmd->result = DID_NO_CONNECT << 16;\n\t\t\tscsi_dma_unmap(ccb->pcmd);\n\t\t\tscsi_done(ccb->pcmd);\n\t\t}\n\t}\n\tfor (target = 0; target < ARCMSR_MAX_TARGETID; target++) {\n\t\ttemp = *acb_dev_map;\n\t\tif (temp) {\n\t\t\tfor (lun = 0; lun < ARCMSR_MAX_TARGETLUN; lun++) {\n\t\t\t\tif (temp & 1) {\n\t\t\t\t\tpsdev = scsi_device_lookup(acb->host,\n\t\t\t\t\t\t0, target, lun);\n\t\t\t\t\tif (psdev != NULL) {\n\t\t\t\t\t\tscsi_remove_device(psdev);\n\t\t\t\t\t\tscsi_device_put(psdev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttemp >>= 1;\n\t\t\t}\n\t\t\t*acb_dev_map = 0;\n\t\t}\n\t\tacb_dev_map++;\n\t}\n}\n\nstatic void arcmsr_free_pcidev(struct AdapterControlBlock *acb)\n{\n\tstruct pci_dev *pdev;\n\tstruct Scsi_Host *host;\n\n\thost = acb->host;\n\tarcmsr_free_sysfs_attr(acb);\n\tscsi_remove_host(host);\n\tflush_work(&acb->arcmsr_do_message_isr_bh);\n\tdel_timer_sync(&acb->eternal_timer);\n\tif (set_date_time)\n\t\tdel_timer_sync(&acb->refresh_timer);\n\tpdev = acb->pdev;\n\tarcmsr_free_irq(pdev, acb);\n\tarcmsr_free_ccb_pool(acb);\n\tif (acb->adapter_type == ACB_ADAPTER_TYPE_F)\n\t\tarcmsr_free_io_queue(acb);\n\tarcmsr_unmap_pciregion(acb);\n\tpci_release_regions(pdev);\n\tscsi_host_put(host);\n\tpci_disable_device(pdev);\n}\n\nstatic void arcmsr_remove(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *) host->hostdata;\n\tint poll_count = 0;\n\tuint16_t dev_id;\n\n\tpci_read_config_word(pdev, PCI_DEVICE_ID, &dev_id);\n\tif (dev_id == 0xffff) {\n\t\tacb->acb_flags &= ~ACB_F_IOP_INITED;\n\t\tacb->acb_flags |= ACB_F_ADAPTER_REMOVED;\n\t\tarcmsr_remove_scsi_devices(acb);\n\t\tarcmsr_free_pcidev(acb);\n\t\treturn;\n\t}\n\tarcmsr_free_sysfs_attr(acb);\n\tscsi_remove_host(host);\n\tflush_work(&acb->arcmsr_do_message_isr_bh);\n\tdel_timer_sync(&acb->eternal_timer);\n\tif (set_date_time)\n\t\tdel_timer_sync(&acb->refresh_timer);\n\tarcmsr_disable_outbound_ints(acb);\n\tarcmsr_stop_adapter_bgrb(acb);\n\tarcmsr_flush_adapter_cache(acb);\t\n\tacb->acb_flags |= ACB_F_SCSISTOPADAPTER;\n\tacb->acb_flags &= ~ACB_F_IOP_INITED;\n\n\tfor (poll_count = 0; poll_count < acb->maxOutstanding; poll_count++){\n\t\tif (!atomic_read(&acb->ccboutstandingcount))\n\t\t\tbreak;\n\t\tarcmsr_interrupt(acb);/* FIXME: need spinlock */\n\t\tmsleep(25);\n\t}\n\n\tif (atomic_read(&acb->ccboutstandingcount)) {\n\t\tint i;\n\n\t\tarcmsr_abort_allcmd(acb);\n\t\tarcmsr_done4abort_postqueue(acb);\n\t\tfor (i = 0; i < acb->maxFreeCCB; i++) {\n\t\t\tstruct CommandControlBlock *ccb = acb->pccb_pool[i];\n\t\t\tif (ccb->startdone == ARCMSR_CCB_START) {\n\t\t\t\tccb->startdone = ARCMSR_CCB_ABORTED;\n\t\t\t\tccb->pcmd->result = DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t}\n\t\t}\n\t}\n\tarcmsr_free_irq(pdev, acb);\n\tarcmsr_free_ccb_pool(acb);\n\tif (acb->adapter_type == ACB_ADAPTER_TYPE_F)\n\t\tarcmsr_free_io_queue(acb);\n\tarcmsr_unmap_pciregion(acb);\n\tpci_release_regions(pdev);\n\tscsi_host_put(host);\n\tpci_disable_device(pdev);\n}\n\nstatic void arcmsr_shutdown(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *)host->hostdata;\n\tif (acb->acb_flags & ACB_F_ADAPTER_REMOVED)\n\t\treturn;\n\tdel_timer_sync(&acb->eternal_timer);\n\tif (set_date_time)\n\t\tdel_timer_sync(&acb->refresh_timer);\n\tarcmsr_disable_outbound_ints(acb);\n\tarcmsr_free_irq(pdev, acb);\n\tflush_work(&acb->arcmsr_do_message_isr_bh);\n\tarcmsr_stop_adapter_bgrb(acb);\n\tarcmsr_flush_adapter_cache(acb);\n}\n\nstatic int __init arcmsr_module_init(void)\n{\n\tint error = 0;\n\terror = pci_register_driver(&arcmsr_pci_driver);\n\treturn error;\n}\n\nstatic void __exit arcmsr_module_exit(void)\n{\n\tpci_unregister_driver(&arcmsr_pci_driver);\n}\nmodule_init(arcmsr_module_init);\nmodule_exit(arcmsr_module_exit);\n\nstatic void arcmsr_enable_outbound_ints(struct AdapterControlBlock *acb,\n\t\t\t\t\t\tu32 intmask_org)\n{\n\tu32 mask;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tmask = intmask_org & ~(ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE |\n\t\t\t     ARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE|\n\t\t\t     ARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE);\n\t\twritel(mask, &reg->outbound_intmask);\n\t\tacb->outbound_int_enable = ~(intmask_org & mask) & 0x000000ff;\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\tmask = intmask_org | (ARCMSR_IOP2DRV_DATA_WRITE_OK |\n\t\t\tARCMSR_IOP2DRV_DATA_READ_OK |\n\t\t\tARCMSR_IOP2DRV_CDB_DONE |\n\t\t\tARCMSR_IOP2DRV_MESSAGE_CMD_DONE);\n\t\twritel(mask, reg->iop2drv_doorbell_mask);\n\t\tacb->outbound_int_enable = (intmask_org | mask) & 0x0000000f;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\tmask = ~(ARCMSR_HBCMU_UTILITY_A_ISR_MASK | ARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR_MASK|ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR_MASK);\n\t\twritel(intmask_org & mask, &reg->host_int_mask);\n\t\tacb->outbound_int_enable = ~(intmask_org & mask) & 0x0000000f;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\n\t\tmask = ARCMSR_ARC1214_ALL_INT_ENABLE;\n\t\twritel(intmask_org | mask, reg->pcief0_int_enable);\n\t\tbreak;\n\t\t}\n\tcase ACB_ADAPTER_TYPE_E:\n\tcase ACB_ADAPTER_TYPE_F: {\n\t\tstruct MessageUnit_E __iomem *reg = acb->pmuE;\n\n\t\tmask = ~(ARCMSR_HBEMU_OUTBOUND_DOORBELL_ISR | ARCMSR_HBEMU_OUTBOUND_POSTQUEUE_ISR);\n\t\twritel(intmask_org & mask, &reg->host_int_mask);\n\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int arcmsr_build_ccb(struct AdapterControlBlock *acb,\n\tstruct CommandControlBlock *ccb, struct scsi_cmnd *pcmd)\n{\n\tstruct ARCMSR_CDB *arcmsr_cdb = (struct ARCMSR_CDB *)&ccb->arcmsr_cdb;\n\tint8_t *psge = (int8_t *)&arcmsr_cdb->u;\n\t__le32 address_lo, address_hi;\n\tint arccdbsize = 0x30;\n\t__le32 length = 0;\n\tint i;\n\tstruct scatterlist *sg;\n\tint nseg;\n\tccb->pcmd = pcmd;\n\tmemset(arcmsr_cdb, 0, sizeof(struct ARCMSR_CDB));\n\tarcmsr_cdb->TargetID = pcmd->device->id;\n\tarcmsr_cdb->LUN = pcmd->device->lun;\n\tarcmsr_cdb->Function = 1;\n\tarcmsr_cdb->msgContext = 0;\n\tmemcpy(arcmsr_cdb->Cdb, pcmd->cmnd, pcmd->cmd_len);\n\n\tnseg = scsi_dma_map(pcmd);\n\tif (unlikely(nseg > acb->host->sg_tablesize || nseg < 0))\n\t\treturn FAILED;\n\tscsi_for_each_sg(pcmd, sg, nseg, i) {\n\t\t/* Get the physical address of the current data pointer */\n\t\tlength = cpu_to_le32(sg_dma_len(sg));\n\t\taddress_lo = cpu_to_le32(dma_addr_lo32(sg_dma_address(sg)));\n\t\taddress_hi = cpu_to_le32(dma_addr_hi32(sg_dma_address(sg)));\n\t\tif (address_hi == 0) {\n\t\t\tstruct SG32ENTRY *pdma_sg = (struct SG32ENTRY *)psge;\n\n\t\t\tpdma_sg->address = address_lo;\n\t\t\tpdma_sg->length = length;\n\t\t\tpsge += sizeof (struct SG32ENTRY);\n\t\t\tarccdbsize += sizeof (struct SG32ENTRY);\n\t\t} else {\n\t\t\tstruct SG64ENTRY *pdma_sg = (struct SG64ENTRY *)psge;\n\n\t\t\tpdma_sg->addresshigh = address_hi;\n\t\t\tpdma_sg->address = address_lo;\n\t\t\tpdma_sg->length = length|cpu_to_le32(IS_SG64_ADDR);\n\t\t\tpsge += sizeof (struct SG64ENTRY);\n\t\t\tarccdbsize += sizeof (struct SG64ENTRY);\n\t\t}\n\t}\n\tarcmsr_cdb->sgcount = (uint8_t)nseg;\n\tarcmsr_cdb->DataLength = scsi_bufflen(pcmd);\n\tarcmsr_cdb->msgPages = arccdbsize/0x100 + (arccdbsize % 0x100 ? 1 : 0);\n\tif ( arccdbsize > 256)\n\t\tarcmsr_cdb->Flags |= ARCMSR_CDB_FLAG_SGL_BSIZE;\n\tif (pcmd->sc_data_direction == DMA_TO_DEVICE)\n\t\tarcmsr_cdb->Flags |= ARCMSR_CDB_FLAG_WRITE;\n\tccb->arc_cdb_size = arccdbsize;\n\treturn SUCCESS;\n}\n\nstatic void arcmsr_post_ccb(struct AdapterControlBlock *acb, struct CommandControlBlock *ccb)\n{\n\tuint32_t cdb_phyaddr = ccb->cdb_phyaddr;\n\tstruct ARCMSR_CDB *arcmsr_cdb = (struct ARCMSR_CDB *)&ccb->arcmsr_cdb;\n\tatomic_inc(&acb->ccboutstandingcount);\n\tccb->startdone = ARCMSR_CCB_START;\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\n\t\tif (arcmsr_cdb->Flags & ARCMSR_CDB_FLAG_SGL_BSIZE)\n\t\t\twritel(cdb_phyaddr | ARCMSR_CCBPOST_FLAG_SGL_BSIZE,\n\t\t\t&reg->inbound_queueport);\n\t\telse\n\t\t\twritel(cdb_phyaddr, &reg->inbound_queueport);\n\t\tbreak;\n\t}\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\tuint32_t ending_index, index = reg->postq_index;\n\n\t\tending_index = ((index + 1) % ARCMSR_MAX_HBB_POSTQUEUE);\n\t\treg->post_qbuffer[ending_index] = 0;\n\t\tif (arcmsr_cdb->Flags & ARCMSR_CDB_FLAG_SGL_BSIZE) {\n\t\t\treg->post_qbuffer[index] =\n\t\t\t\tcdb_phyaddr | ARCMSR_CCBPOST_FLAG_SGL_BSIZE;\n\t\t} else {\n\t\t\treg->post_qbuffer[index] = cdb_phyaddr;\n\t\t}\n\t\tindex++;\n\t\tindex %= ARCMSR_MAX_HBB_POSTQUEUE;/*if last index number set it to 0 */\n\t\treg->postq_index = index;\n\t\twritel(ARCMSR_DRV2IOP_CDB_POSTED, reg->drv2iop_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *phbcmu = acb->pmuC;\n\t\tuint32_t ccb_post_stamp, arc_cdb_size;\n\n\t\tarc_cdb_size = (ccb->arc_cdb_size > 0x300) ? 0x300 : ccb->arc_cdb_size;\n\t\tccb_post_stamp = (cdb_phyaddr | ((arc_cdb_size - 1) >> 6) | 1);\n\t\twritel(upper_32_bits(ccb->cdb_phyaddr), &phbcmu->inbound_queueport_high);\n\t\twritel(ccb_post_stamp, &phbcmu->inbound_queueport_low);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D  *pmu = acb->pmuD;\n\t\tu16 index_stripped;\n\t\tu16 postq_index, toggle;\n\t\tunsigned long flags;\n\t\tstruct InBound_SRB *pinbound_srb;\n\n\t\tspin_lock_irqsave(&acb->postq_lock, flags);\n\t\tpostq_index = pmu->postq_index;\n\t\tpinbound_srb = (struct InBound_SRB *)&(pmu->post_qbuffer[postq_index & 0xFF]);\n\t\tpinbound_srb->addressHigh = upper_32_bits(ccb->cdb_phyaddr);\n\t\tpinbound_srb->addressLow = cdb_phyaddr;\n\t\tpinbound_srb->length = ccb->arc_cdb_size >> 2;\n\t\tarcmsr_cdb->msgContext = dma_addr_lo32(cdb_phyaddr);\n\t\ttoggle = postq_index & 0x4000;\n\t\tindex_stripped = postq_index + 1;\n\t\tindex_stripped &= (ARCMSR_MAX_ARC1214_POSTQUEUE - 1);\n\t\tpmu->postq_index = index_stripped ? (index_stripped | toggle) :\n\t\t\t(toggle ^ 0x4000);\n\t\twritel(postq_index, pmu->inboundlist_write_pointer);\n\t\tspin_unlock_irqrestore(&acb->postq_lock, flags);\n\t\tbreak;\n\t\t}\n\tcase ACB_ADAPTER_TYPE_E: {\n\t\tstruct MessageUnit_E __iomem *pmu = acb->pmuE;\n\t\tu32 ccb_post_stamp, arc_cdb_size;\n\n\t\tarc_cdb_size = (ccb->arc_cdb_size > 0x300) ? 0x300 : ccb->arc_cdb_size;\n\t\tccb_post_stamp = (ccb->smid | ((arc_cdb_size - 1) >> 6));\n\t\twritel(0, &pmu->inbound_queueport_high);\n\t\twritel(ccb_post_stamp, &pmu->inbound_queueport_low);\n\t\tbreak;\n\t\t}\n\tcase ACB_ADAPTER_TYPE_F: {\n\t\tstruct MessageUnit_F __iomem *pmu = acb->pmuF;\n\t\tu32 ccb_post_stamp, arc_cdb_size;\n\n\t\tif (ccb->arc_cdb_size <= 0x300)\n\t\t\tarc_cdb_size = (ccb->arc_cdb_size - 1) >> 6 | 1;\n\t\telse {\n\t\t\tarc_cdb_size = ((ccb->arc_cdb_size + 0xff) >> 8) + 2;\n\t\t\tif (arc_cdb_size > 0xF)\n\t\t\t\tarc_cdb_size = 0xF;\n\t\t\tarc_cdb_size = (arc_cdb_size << 1) | 1;\n\t\t}\n\t\tccb_post_stamp = (ccb->smid | arc_cdb_size);\n\t\twritel(0, &pmu->inbound_queueport_high);\n\t\twritel(ccb_post_stamp, &pmu->inbound_queueport_low);\n\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void arcmsr_hbaA_stop_bgrb(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tacb->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_STOP_BGRB, &reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'stop adapter background rebuild' timeout\\n\"\n\t\t\t, acb->host->host_no);\n\t}\n}\n\nstatic void arcmsr_hbaB_stop_bgrb(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tacb->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_MESSAGE_STOP_BGRB, reg->drv2iop_doorbell);\n\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'stop adapter background rebuild' timeout\\n\"\n\t\t\t, acb->host->host_no);\n\t}\n}\n\nstatic void arcmsr_hbaC_stop_bgrb(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\tpACB->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_STOP_BGRB, &reg->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\tif (!arcmsr_hbaC_wait_msgint_ready(pACB)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"arcmsr%d: wait 'stop adapter background rebuild' timeout\\n\"\n\t\t\t, pACB->host->host_no);\n\t}\n\treturn;\n}\n\nstatic void arcmsr_hbaD_stop_bgrb(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_D *reg = pACB->pmuD;\n\n\tpACB->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_STOP_BGRB, reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaD_wait_msgint_ready(pACB))\n\t\tpr_notice(\"arcmsr%d: wait 'stop adapter background rebuild' \"\n\t\t\t\"timeout\\n\", pACB->host->host_no);\n}\n\nstatic void arcmsr_hbaE_stop_bgrb(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_E __iomem *reg = pACB->pmuE;\n\n\tpACB->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_STOP_BGRB, &reg->inbound_msgaddr0);\n\tpACB->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_MESSAGE_CMD_DONE;\n\twritel(pACB->out_doorbell, &reg->iobound_doorbell);\n\tif (!arcmsr_hbaE_wait_msgint_ready(pACB)) {\n\t\tpr_notice(\"arcmsr%d: wait 'stop adapter background rebuild' \"\n\t\t\t\"timeout\\n\", pACB->host->host_no);\n\t}\n}\n\nstatic void arcmsr_stop_adapter_bgrb(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\tarcmsr_hbaA_stop_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\tarcmsr_hbaB_stop_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\tarcmsr_hbaC_stop_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tarcmsr_hbaD_stop_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\tcase ACB_ADAPTER_TYPE_F:\n\t\tarcmsr_hbaE_stop_bgrb(acb);\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_free_ccb_pool(struct AdapterControlBlock *acb)\n{\n\tdma_free_coherent(&acb->pdev->dev, acb->uncache_size, acb->dma_coherent, acb->dma_coherent_handle);\n}\n\nstatic void arcmsr_iop_message_read(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\twritel(ARCMSR_INBOUND_DRIVER_DATA_READ_OK, &reg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\twritel(ARCMSR_DRV2IOP_DATA_READ_OK, reg->drv2iop_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\n\t\twritel(ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK, &reg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\twritel(ARCMSR_ARC1214_DRV2IOP_DATA_OUT_READ,\n\t\t\treg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\tcase ACB_ADAPTER_TYPE_F: {\n\t\tstruct MessageUnit_E __iomem *reg = acb->pmuE;\n\t\tacb->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_DATA_READ_OK;\n\t\twritel(acb->out_doorbell, &reg->iobound_doorbell);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_iop_message_wrote(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\t/*\n\t\t** push inbound doorbell tell iop, driver data write ok\n\t\t** and wait reply on next hwinterrupt for next Qbuffer post\n\t\t*/\n\t\twritel(ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK, &reg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\t/*\n\t\t** push inbound doorbell tell iop, driver data write ok\n\t\t** and wait reply on next hwinterrupt for next Qbuffer post\n\t\t*/\n\t\twritel(ARCMSR_DRV2IOP_DATA_WRITE_OK, reg->drv2iop_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\t/*\n\t\t** push inbound doorbell tell iop, driver data write ok\n\t\t** and wait reply on next hwinterrupt for next Qbuffer post\n\t\t*/\n\t\twritel(ARCMSR_HBCMU_DRV2IOP_DATA_WRITE_OK, &reg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\twritel(ARCMSR_ARC1214_DRV2IOP_DATA_IN_READY,\n\t\t\treg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\tcase ACB_ADAPTER_TYPE_F: {\n\t\tstruct MessageUnit_E __iomem *reg = acb->pmuE;\n\t\tacb->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_DATA_WRITE_OK;\n\t\twritel(acb->out_doorbell, &reg->iobound_doorbell);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstruct QBUFFER __iomem *arcmsr_get_iop_rqbuffer(struct AdapterControlBlock *acb)\n{\n\tstruct QBUFFER __iomem *qbuffer = NULL;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tqbuffer = (struct QBUFFER __iomem *)&reg->message_rbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\tqbuffer = (struct QBUFFER __iomem *)reg->message_rbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *phbcmu = acb->pmuC;\n\t\tqbuffer = (struct QBUFFER __iomem *)&phbcmu->message_rbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\tqbuffer = (struct QBUFFER __iomem *)reg->message_rbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E: {\n\t\tstruct MessageUnit_E __iomem *reg = acb->pmuE;\n\t\tqbuffer = (struct QBUFFER __iomem *)&reg->message_rbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_F: {\n\t\tqbuffer = (struct QBUFFER __iomem *)acb->message_rbuffer;\n\t\t}\n\t\tbreak;\n\t}\n\treturn qbuffer;\n}\n\nstatic struct QBUFFER __iomem *arcmsr_get_iop_wqbuffer(struct AdapterControlBlock *acb)\n{\n\tstruct QBUFFER __iomem *pqbuffer = NULL;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tpqbuffer = (struct QBUFFER __iomem *) &reg->message_wbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B  *reg = acb->pmuB;\n\t\tpqbuffer = (struct QBUFFER __iomem *)reg->message_wbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\tpqbuffer = (struct QBUFFER __iomem *)&reg->message_wbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\tpqbuffer = (struct QBUFFER __iomem *)reg->message_wbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E: {\n\t\tstruct MessageUnit_E __iomem *reg = acb->pmuE;\n\t\tpqbuffer = (struct QBUFFER __iomem *)&reg->message_wbuffer;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_F:\n\t\tpqbuffer = (struct QBUFFER __iomem *)acb->message_wbuffer;\n\t\tbreak;\n\t}\n\treturn pqbuffer;\n}\n\nstatic uint32_t\narcmsr_Read_iop_rqbuffer_in_DWORD(struct AdapterControlBlock *acb,\n\t\tstruct QBUFFER __iomem *prbuffer)\n{\n\tuint8_t *pQbuffer;\n\tuint8_t *buf1 = NULL;\n\tuint32_t __iomem *iop_data;\n\tuint32_t iop_len, data_len, *buf2 = NULL;\n\n\tiop_data = (uint32_t __iomem *)prbuffer->data;\n\tiop_len = readl(&prbuffer->data_len);\n\tif (iop_len > 0) {\n\t\tbuf1 = kmalloc(128, GFP_ATOMIC);\n\t\tbuf2 = (uint32_t *)buf1;\n\t\tif (buf1 == NULL)\n\t\t\treturn 0;\n\t\tdata_len = iop_len;\n\t\twhile (data_len >= 4) {\n\t\t\t*buf2++ = readl(iop_data);\n\t\t\tiop_data++;\n\t\t\tdata_len -= 4;\n\t\t}\n\t\tif (data_len)\n\t\t\t*buf2 = readl(iop_data);\n\t\tbuf2 = (uint32_t *)buf1;\n\t}\n\twhile (iop_len > 0) {\n\t\tpQbuffer = &acb->rqbuffer[acb->rqbuf_putIndex];\n\t\t*pQbuffer = *buf1;\n\t\tacb->rqbuf_putIndex++;\n\t\t/* if last, index number set it to 0 */\n\t\tacb->rqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\n\t\tbuf1++;\n\t\tiop_len--;\n\t}\n\tkfree(buf2);\n\t/* let IOP know data has been read */\n\tarcmsr_iop_message_read(acb);\n\treturn 1;\n}\n\nuint32_t\narcmsr_Read_iop_rqbuffer_data(struct AdapterControlBlock *acb,\n\tstruct QBUFFER __iomem *prbuffer) {\n\n\tuint8_t *pQbuffer;\n\tuint8_t __iomem *iop_data;\n\tuint32_t iop_len;\n\n\tif (acb->adapter_type > ACB_ADAPTER_TYPE_B)\n\t\treturn arcmsr_Read_iop_rqbuffer_in_DWORD(acb, prbuffer);\n\tiop_data = (uint8_t __iomem *)prbuffer->data;\n\tiop_len = readl(&prbuffer->data_len);\n\twhile (iop_len > 0) {\n\t\tpQbuffer = &acb->rqbuffer[acb->rqbuf_putIndex];\n\t\t*pQbuffer = readb(iop_data);\n\t\tacb->rqbuf_putIndex++;\n\t\tacb->rqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\n\t\tiop_data++;\n\t\tiop_len--;\n\t}\n\tarcmsr_iop_message_read(acb);\n\treturn 1;\n}\n\nstatic void arcmsr_iop2drv_data_wrote_handle(struct AdapterControlBlock *acb)\n{\n\tunsigned long flags;\n\tstruct QBUFFER __iomem  *prbuffer;\n\tint32_t buf_empty_len;\n\n\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\tprbuffer = arcmsr_get_iop_rqbuffer(acb);\n\tif (acb->rqbuf_putIndex >= acb->rqbuf_getIndex) {\n\t\tbuf_empty_len = (ARCMSR_MAX_QBUFFER - 1) -\n\t\t(acb->rqbuf_putIndex - acb->rqbuf_getIndex);\n\t} else\n\t\tbuf_empty_len = acb->rqbuf_getIndex - acb->rqbuf_putIndex - 1;\n\tif (buf_empty_len >= readl(&prbuffer->data_len)) {\n\t\tif (arcmsr_Read_iop_rqbuffer_data(acb, prbuffer) == 0)\n\t\t\tacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\n\t} else\n\t\tacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\n\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n}\n\nstatic void arcmsr_write_ioctldata2iop_in_DWORD(struct AdapterControlBlock *acb)\n{\n\tuint8_t *pQbuffer;\n\tstruct QBUFFER __iomem *pwbuffer;\n\tuint8_t *buf1 = NULL;\n\tuint32_t __iomem *iop_data;\n\tuint32_t allxfer_len = 0, data_len, *buf2 = NULL, data;\n\n\tif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_READED) {\n\t\tbuf1 = kmalloc(128, GFP_ATOMIC);\n\t\tbuf2 = (uint32_t *)buf1;\n\t\tif (buf1 == NULL)\n\t\t\treturn;\n\n\t\tacb->acb_flags &= (~ACB_F_MESSAGE_WQBUFFER_READED);\n\t\tpwbuffer = arcmsr_get_iop_wqbuffer(acb);\n\t\tiop_data = (uint32_t __iomem *)pwbuffer->data;\n\t\twhile ((acb->wqbuf_getIndex != acb->wqbuf_putIndex)\n\t\t\t&& (allxfer_len < 124)) {\n\t\t\tpQbuffer = &acb->wqbuffer[acb->wqbuf_getIndex];\n\t\t\t*buf1 = *pQbuffer;\n\t\t\tacb->wqbuf_getIndex++;\n\t\t\tacb->wqbuf_getIndex %= ARCMSR_MAX_QBUFFER;\n\t\t\tbuf1++;\n\t\t\tallxfer_len++;\n\t\t}\n\t\tdata_len = allxfer_len;\n\t\tbuf1 = (uint8_t *)buf2;\n\t\twhile (data_len >= 4) {\n\t\t\tdata = *buf2++;\n\t\t\twritel(data, iop_data);\n\t\t\tiop_data++;\n\t\t\tdata_len -= 4;\n\t\t}\n\t\tif (data_len) {\n\t\t\tdata = *buf2;\n\t\t\twritel(data, iop_data);\n\t\t}\n\t\twritel(allxfer_len, &pwbuffer->data_len);\n\t\tkfree(buf1);\n\t\tarcmsr_iop_message_wrote(acb);\n\t}\n}\n\nvoid\narcmsr_write_ioctldata2iop(struct AdapterControlBlock *acb)\n{\n\tuint8_t *pQbuffer;\n\tstruct QBUFFER __iomem *pwbuffer;\n\tuint8_t __iomem *iop_data;\n\tint32_t allxfer_len = 0;\n\n\tif (acb->adapter_type > ACB_ADAPTER_TYPE_B) {\n\t\tarcmsr_write_ioctldata2iop_in_DWORD(acb);\n\t\treturn;\n\t}\n\tif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_READED) {\n\t\tacb->acb_flags &= (~ACB_F_MESSAGE_WQBUFFER_READED);\n\t\tpwbuffer = arcmsr_get_iop_wqbuffer(acb);\n\t\tiop_data = (uint8_t __iomem *)pwbuffer->data;\n\t\twhile ((acb->wqbuf_getIndex != acb->wqbuf_putIndex)\n\t\t\t&& (allxfer_len < 124)) {\n\t\t\tpQbuffer = &acb->wqbuffer[acb->wqbuf_getIndex];\n\t\t\twriteb(*pQbuffer, iop_data);\n\t\t\tacb->wqbuf_getIndex++;\n\t\t\tacb->wqbuf_getIndex %= ARCMSR_MAX_QBUFFER;\n\t\t\tiop_data++;\n\t\t\tallxfer_len++;\n\t\t}\n\t\twritel(allxfer_len, &pwbuffer->data_len);\n\t\tarcmsr_iop_message_wrote(acb);\n\t}\n}\n\nstatic void arcmsr_iop2drv_data_read_handle(struct AdapterControlBlock *acb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\tacb->acb_flags |= ACB_F_MESSAGE_WQBUFFER_READED;\n\tif (acb->wqbuf_getIndex != acb->wqbuf_putIndex)\n\t\tarcmsr_write_ioctldata2iop(acb);\n\tif (acb->wqbuf_getIndex == acb->wqbuf_putIndex)\n\t\tacb->acb_flags |= ACB_F_MESSAGE_WQBUFFER_CLEARED;\n\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n}\n\nstatic void arcmsr_hbaA_doorbell_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t outbound_doorbell;\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\tdo {\n\t\twritel(outbound_doorbell, &reg->outbound_doorbell);\n\t\tif (outbound_doorbell & ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK)\n\t\t\tarcmsr_iop2drv_data_wrote_handle(acb);\n\t\tif (outbound_doorbell & ARCMSR_OUTBOUND_IOP331_DATA_READ_OK)\n\t\t\tarcmsr_iop2drv_data_read_handle(acb);\n\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t} while (outbound_doorbell & (ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK\n\t\t| ARCMSR_OUTBOUND_IOP331_DATA_READ_OK));\n}\nstatic void arcmsr_hbaC_doorbell_isr(struct AdapterControlBlock *pACB)\n{\n\tuint32_t outbound_doorbell;\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\t/*\n\t*******************************************************************\n\t**  Maybe here we need to check wrqbuffer_lock is lock or not\n\t**  DOORBELL: din! don!\n\t**  check if there are any mail need to pack from firmware\n\t*******************************************************************\n\t*/\n\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\tdo {\n\t\twritel(outbound_doorbell, &reg->outbound_doorbell_clear);\n\t\treadl(&reg->outbound_doorbell_clear);\n\t\tif (outbound_doorbell & ARCMSR_HBCMU_IOP2DRV_DATA_WRITE_OK)\n\t\t\tarcmsr_iop2drv_data_wrote_handle(pACB);\n\t\tif (outbound_doorbell & ARCMSR_HBCMU_IOP2DRV_DATA_READ_OK)\n\t\t\tarcmsr_iop2drv_data_read_handle(pACB);\n\t\tif (outbound_doorbell & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE)\n\t\t\tarcmsr_hbaC_message_isr(pACB);\n\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t} while (outbound_doorbell & (ARCMSR_HBCMU_IOP2DRV_DATA_WRITE_OK\n\t\t| ARCMSR_HBCMU_IOP2DRV_DATA_READ_OK\n\t\t| ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE));\n}\n\nstatic void arcmsr_hbaD_doorbell_isr(struct AdapterControlBlock *pACB)\n{\n\tuint32_t outbound_doorbell;\n\tstruct MessageUnit_D  *pmu = pACB->pmuD;\n\n\toutbound_doorbell = readl(pmu->outbound_doorbell);\n\tdo {\n\t\twritel(outbound_doorbell, pmu->outbound_doorbell);\n\t\tif (outbound_doorbell & ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE)\n\t\t\tarcmsr_hbaD_message_isr(pACB);\n\t\tif (outbound_doorbell & ARCMSR_ARC1214_IOP2DRV_DATA_WRITE_OK)\n\t\t\tarcmsr_iop2drv_data_wrote_handle(pACB);\n\t\tif (outbound_doorbell & ARCMSR_ARC1214_IOP2DRV_DATA_READ_OK)\n\t\t\tarcmsr_iop2drv_data_read_handle(pACB);\n\t\toutbound_doorbell = readl(pmu->outbound_doorbell);\n\t} while (outbound_doorbell & (ARCMSR_ARC1214_IOP2DRV_DATA_WRITE_OK\n\t\t| ARCMSR_ARC1214_IOP2DRV_DATA_READ_OK\n\t\t| ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE));\n}\n\nstatic void arcmsr_hbaE_doorbell_isr(struct AdapterControlBlock *pACB)\n{\n\tuint32_t outbound_doorbell, in_doorbell, tmp, i;\n\tstruct MessageUnit_E __iomem *reg = pACB->pmuE;\n\n\tif (pACB->adapter_type == ACB_ADAPTER_TYPE_F) {\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tin_doorbell = readl(&reg->iobound_doorbell);\n\t\t\tif (in_doorbell != 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else\n\t\tin_doorbell = readl(&reg->iobound_doorbell);\n\toutbound_doorbell = in_doorbell ^ pACB->in_doorbell;\n\tdo {\n\t\twritel(0, &reg->host_int_status); /* clear interrupt */\n\t\tif (outbound_doorbell & ARCMSR_HBEMU_IOP2DRV_DATA_WRITE_OK) {\n\t\t\tarcmsr_iop2drv_data_wrote_handle(pACB);\n\t\t}\n\t\tif (outbound_doorbell & ARCMSR_HBEMU_IOP2DRV_DATA_READ_OK) {\n\t\t\tarcmsr_iop2drv_data_read_handle(pACB);\n\t\t}\n\t\tif (outbound_doorbell & ARCMSR_HBEMU_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\tarcmsr_hbaE_message_isr(pACB);\n\t\t}\n\t\ttmp = in_doorbell;\n\t\tin_doorbell = readl(&reg->iobound_doorbell);\n\t\toutbound_doorbell = tmp ^ in_doorbell;\n\t} while (outbound_doorbell & (ARCMSR_HBEMU_IOP2DRV_DATA_WRITE_OK\n\t\t| ARCMSR_HBEMU_IOP2DRV_DATA_READ_OK\n\t\t| ARCMSR_HBEMU_IOP2DRV_MESSAGE_CMD_DONE));\n\tpACB->in_doorbell = in_doorbell;\n}\n\nstatic void arcmsr_hbaA_postqueue_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t flag_ccb;\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tstruct ARCMSR_CDB *pARCMSR_CDB;\n\tstruct CommandControlBlock *pCCB;\n\tbool error;\n\tunsigned long cdb_phy_addr;\n\n\twhile ((flag_ccb = readl(&reg->outbound_queueport)) != 0xFFFFFFFF) {\n\t\tcdb_phy_addr = (flag_ccb << 5) & 0xffffffff;\n\t\tif (acb->cdb_phyadd_hipart)\n\t\t\tcdb_phy_addr = cdb_phy_addr | acb->cdb_phyadd_hipart;\n\t\tpARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset + cdb_phy_addr);\n\t\tpCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t}\n}\nstatic void arcmsr_hbaB_postqueue_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t index;\n\tuint32_t flag_ccb;\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tstruct ARCMSR_CDB *pARCMSR_CDB;\n\tstruct CommandControlBlock *pCCB;\n\tbool error;\n\tunsigned long cdb_phy_addr;\n\n\tindex = reg->doneq_index;\n\twhile ((flag_ccb = reg->done_qbuffer[index]) != 0) {\n\t\tcdb_phy_addr = (flag_ccb << 5) & 0xffffffff;\n\t\tif (acb->cdb_phyadd_hipart)\n\t\t\tcdb_phy_addr = cdb_phy_addr | acb->cdb_phyadd_hipart;\n\t\tpARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset + cdb_phy_addr);\n\t\tpCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\tarcmsr_drain_donequeue(acb, pCCB, error);\n\t\treg->done_qbuffer[index] = 0;\n\t\tindex++;\n\t\tindex %= ARCMSR_MAX_HBB_POSTQUEUE;\n\t\treg->doneq_index = index;\n\t}\n}\n\nstatic void arcmsr_hbaC_postqueue_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_C __iomem *phbcmu;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tstruct CommandControlBlock *ccb;\n\tuint32_t flag_ccb, throttling = 0;\n\tunsigned long ccb_cdb_phy;\n\tint error;\n\n\tphbcmu = acb->pmuC;\n\t/* areca cdb command done */\n\t/* Use correct offset and size for syncing */\n\n\twhile ((flag_ccb = readl(&phbcmu->outbound_queueport_low)) !=\n\t\t\t0xFFFFFFFF) {\n\t\tccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\n\t\tif (acb->cdb_phyadd_hipart)\n\t\t\tccb_cdb_phy = ccb_cdb_phy | acb->cdb_phyadd_hipart;\n\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset\n\t\t\t+ ccb_cdb_phy);\n\t\tccb = container_of(arcmsr_cdb, struct CommandControlBlock,\n\t\t\tarcmsr_cdb);\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1)\n\t\t\t? true : false;\n\t\t/* check if command done with no error */\n\t\tarcmsr_drain_donequeue(acb, ccb, error);\n\t\tthrottling++;\n\t\tif (throttling == ARCMSR_HBC_ISR_THROTTLING_LEVEL) {\n\t\t\twritel(ARCMSR_HBCMU_DRV2IOP_POSTQUEUE_THROTTLING,\n\t\t\t\t&phbcmu->inbound_doorbell);\n\t\t\tthrottling = 0;\n\t\t}\n\t}\n}\n\nstatic void arcmsr_hbaD_postqueue_isr(struct AdapterControlBlock *acb)\n{\n\tu32 outbound_write_pointer, doneq_index, index_stripped, toggle;\n\tuint32_t addressLow;\n\tint error;\n\tstruct MessageUnit_D  *pmu;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tstruct CommandControlBlock *ccb;\n\tunsigned long flags, ccb_cdb_phy;\n\n\tspin_lock_irqsave(&acb->doneq_lock, flags);\n\tpmu = acb->pmuD;\n\toutbound_write_pointer = pmu->done_qbuffer[0].addressLow + 1;\n\tdoneq_index = pmu->doneq_index;\n\tif ((doneq_index & 0xFFF) != (outbound_write_pointer & 0xFFF)) {\n\t\tdo {\n\t\t\ttoggle = doneq_index & 0x4000;\n\t\t\tindex_stripped = (doneq_index & 0xFFF) + 1;\n\t\t\tindex_stripped %= ARCMSR_MAX_ARC1214_DONEQUEUE;\n\t\t\tpmu->doneq_index = index_stripped ? (index_stripped | toggle) :\n\t\t\t\t((toggle ^ 0x4000) + 1);\n\t\t\tdoneq_index = pmu->doneq_index;\n\t\t\taddressLow = pmu->done_qbuffer[doneq_index &\n\t\t\t\t0xFFF].addressLow;\n\t\t\tccb_cdb_phy = (addressLow & 0xFFFFFFF0);\n\t\t\tif (acb->cdb_phyadd_hipart)\n\t\t\t\tccb_cdb_phy = ccb_cdb_phy | acb->cdb_phyadd_hipart;\n\t\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset\n\t\t\t\t+ ccb_cdb_phy);\n\t\t\tccb = container_of(arcmsr_cdb,\n\t\t\t\tstruct CommandControlBlock, arcmsr_cdb);\n\t\t\terror = (addressLow & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1)\n\t\t\t\t? true : false;\n\t\t\tarcmsr_drain_donequeue(acb, ccb, error);\n\t\t\twritel(doneq_index, pmu->outboundlist_read_pointer);\n\t\t} while ((doneq_index & 0xFFF) !=\n\t\t\t(outbound_write_pointer & 0xFFF));\n\t}\n\twritel(ARCMSR_ARC1214_OUTBOUND_LIST_INTERRUPT_CLEAR,\n\t\tpmu->outboundlist_interrupt_cause);\n\treadl(pmu->outboundlist_interrupt_cause);\n\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n}\n\nstatic void arcmsr_hbaE_postqueue_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t doneq_index;\n\tuint16_t cmdSMID;\n\tint error;\n\tstruct MessageUnit_E __iomem *pmu;\n\tstruct CommandControlBlock *ccb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&acb->doneq_lock, flags);\n\tdoneq_index = acb->doneq_index;\n\tpmu = acb->pmuE;\n\twhile ((readl(&pmu->reply_post_producer_index) & 0xFFFF) != doneq_index) {\n\t\tcmdSMID = acb->pCompletionQ[doneq_index].cmdSMID;\n\t\tccb = acb->pccb_pool[cmdSMID];\n\t\terror = (acb->pCompletionQ[doneq_index].cmdFlag\n\t\t\t& ARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ? true : false;\n\t\tarcmsr_drain_donequeue(acb, ccb, error);\n\t\tdoneq_index++;\n\t\tif (doneq_index >= acb->completionQ_entry)\n\t\t\tdoneq_index = 0;\n\t}\n\tacb->doneq_index = doneq_index;\n\twritel(doneq_index, &pmu->reply_post_consumer_index);\n\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n}\n\nstatic void arcmsr_hbaF_postqueue_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t doneq_index;\n\tuint16_t cmdSMID;\n\tint error;\n\tstruct MessageUnit_F __iomem *phbcmu;\n\tstruct CommandControlBlock *ccb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&acb->doneq_lock, flags);\n\tdoneq_index = acb->doneq_index;\n\tphbcmu = acb->pmuF;\n\twhile (1) {\n\t\tcmdSMID = acb->pCompletionQ[doneq_index].cmdSMID;\n\t\tif (cmdSMID == 0xffff)\n\t\t\tbreak;\n\t\tccb = acb->pccb_pool[cmdSMID];\n\t\terror = (acb->pCompletionQ[doneq_index].cmdFlag &\n\t\t\tARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ? true : false;\n\t\tarcmsr_drain_donequeue(acb, ccb, error);\n\t\tacb->pCompletionQ[doneq_index].cmdSMID = 0xffff;\n\t\tdoneq_index++;\n\t\tif (doneq_index >= acb->completionQ_entry)\n\t\t\tdoneq_index = 0;\n\t}\n\tacb->doneq_index = doneq_index;\n\twritel(doneq_index, &phbcmu->reply_post_consumer_index);\n\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n}\n\n/*\n**********************************************************************************\n** Handle a message interrupt\n**\n** The only message interrupt we expect is in response to a query for the current adapter config.  \n** We want this in order to compare the drivemap so that we can detect newly-attached drives.\n**********************************************************************************\n*/\nstatic void arcmsr_hbaA_message_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg  = acb->pmuA;\n\t/*clear interrupt and message state*/\n\twritel(ARCMSR_MU_OUTBOUND_MESSAGE0_INT, &reg->outbound_intstatus);\n\tif (acb->acb_flags & ACB_F_MSG_GET_CONFIG)\n\t\tschedule_work(&acb->arcmsr_do_message_isr_bh);\n}\nstatic void arcmsr_hbaB_message_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg  = acb->pmuB;\n\n\t/*clear interrupt and message state*/\n\twritel(ARCMSR_MESSAGE_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\n\tif (acb->acb_flags & ACB_F_MSG_GET_CONFIG)\n\t\tschedule_work(&acb->arcmsr_do_message_isr_bh);\n}\n/*\n**********************************************************************************\n** Handle a message interrupt\n**\n** The only message interrupt we expect is in response to a query for the\n** current adapter config.\n** We want this in order to compare the drivemap so that we can detect newly-attached drives.\n**********************************************************************************\n*/\nstatic void arcmsr_hbaC_message_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_C __iomem *reg  = acb->pmuC;\n\t/*clear interrupt and message state*/\n\twritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &reg->outbound_doorbell_clear);\n\tif (acb->acb_flags & ACB_F_MSG_GET_CONFIG)\n\t\tschedule_work(&acb->arcmsr_do_message_isr_bh);\n}\n\nstatic void arcmsr_hbaD_message_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_D *reg  = acb->pmuD;\n\n\twritel(ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE, reg->outbound_doorbell);\n\treadl(reg->outbound_doorbell);\n\tif (acb->acb_flags & ACB_F_MSG_GET_CONFIG)\n\t\tschedule_work(&acb->arcmsr_do_message_isr_bh);\n}\n\nstatic void arcmsr_hbaE_message_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_E __iomem *reg  = acb->pmuE;\n\n\twritel(0, &reg->host_int_status);\n\tif (acb->acb_flags & ACB_F_MSG_GET_CONFIG)\n\t\tschedule_work(&acb->arcmsr_do_message_isr_bh);\n}\n\nstatic int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t outbound_intstatus;\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\toutbound_intstatus = readl(&reg->outbound_intstatus) &\n\t\tacb->outbound_int_enable;\n\tif (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))\n\t\treturn IRQ_NONE;\n\tdo {\n\t\twritel(outbound_intstatus, &reg->outbound_intstatus);\n\t\tif (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)\n\t\t\tarcmsr_hbaA_doorbell_isr(acb);\n\t\tif (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)\n\t\t\tarcmsr_hbaA_postqueue_isr(acb);\n\t\tif (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)\n\t\t\tarcmsr_hbaA_message_isr(acb);\n\t\toutbound_intstatus = readl(&reg->outbound_intstatus) &\n\t\t\tacb->outbound_int_enable;\n\t} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT\n\t\t| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT\n\t\t| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));\n\treturn IRQ_HANDLED;\n}\n\nstatic int arcmsr_hbaB_handle_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t outbound_doorbell;\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\toutbound_doorbell = readl(reg->iop2drv_doorbell) &\n\t\t\t\tacb->outbound_int_enable;\n\tif (!outbound_doorbell)\n\t\treturn IRQ_NONE;\n\tdo {\n\t\twritel(~outbound_doorbell, reg->iop2drv_doorbell);\n\t\twritel(ARCMSR_DRV2IOP_END_OF_INTERRUPT, reg->drv2iop_doorbell);\n\t\tif (outbound_doorbell & ARCMSR_IOP2DRV_DATA_WRITE_OK)\n\t\t\tarcmsr_iop2drv_data_wrote_handle(acb);\n\t\tif (outbound_doorbell & ARCMSR_IOP2DRV_DATA_READ_OK)\n\t\t\tarcmsr_iop2drv_data_read_handle(acb);\n\t\tif (outbound_doorbell & ARCMSR_IOP2DRV_CDB_DONE)\n\t\t\tarcmsr_hbaB_postqueue_isr(acb);\n\t\tif (outbound_doorbell & ARCMSR_IOP2DRV_MESSAGE_CMD_DONE)\n\t\t\tarcmsr_hbaB_message_isr(acb);\n\t\toutbound_doorbell = readl(reg->iop2drv_doorbell) &\n\t\t\tacb->outbound_int_enable;\n\t} while (outbound_doorbell & (ARCMSR_IOP2DRV_DATA_WRITE_OK\n\t\t| ARCMSR_IOP2DRV_DATA_READ_OK\n\t\t| ARCMSR_IOP2DRV_CDB_DONE\n\t\t| ARCMSR_IOP2DRV_MESSAGE_CMD_DONE));\n\treturn IRQ_HANDLED;\n}\n\nstatic int arcmsr_hbaC_handle_isr(struct AdapterControlBlock *pACB)\n{\n\tuint32_t host_interrupt_status;\n\tstruct MessageUnit_C __iomem *phbcmu = pACB->pmuC;\n\t/*\n\t*********************************************\n\t**   check outbound intstatus\n\t*********************************************\n\t*/\n\thost_interrupt_status = readl(&phbcmu->host_int_status) &\n\t\t(ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR);\n\tif (!host_interrupt_status)\n\t\treturn IRQ_NONE;\n\tdo {\n\t\tif (host_interrupt_status & ARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR)\n\t\t\tarcmsr_hbaC_doorbell_isr(pACB);\n\t\t/* MU post queue interrupts*/\n\t\tif (host_interrupt_status & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR)\n\t\t\tarcmsr_hbaC_postqueue_isr(pACB);\n\t\thost_interrupt_status = readl(&phbcmu->host_int_status);\n\t} while (host_interrupt_status & (ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR));\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t arcmsr_hbaD_handle_isr(struct AdapterControlBlock *pACB)\n{\n\tu32 host_interrupt_status;\n\tstruct MessageUnit_D  *pmu = pACB->pmuD;\n\n\thost_interrupt_status = readl(pmu->host_int_status) &\n\t\t(ARCMSR_ARC1214_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_ARC1214_OUTBOUND_DOORBELL_ISR);\n\tif (!host_interrupt_status)\n\t\treturn IRQ_NONE;\n\tdo {\n\t\t/* MU post queue interrupts*/\n\t\tif (host_interrupt_status &\n\t\t\tARCMSR_ARC1214_OUTBOUND_POSTQUEUE_ISR)\n\t\t\tarcmsr_hbaD_postqueue_isr(pACB);\n\t\tif (host_interrupt_status &\n\t\t\tARCMSR_ARC1214_OUTBOUND_DOORBELL_ISR)\n\t\t\tarcmsr_hbaD_doorbell_isr(pACB);\n\t\thost_interrupt_status = readl(pmu->host_int_status);\n\t} while (host_interrupt_status &\n\t\t(ARCMSR_ARC1214_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_ARC1214_OUTBOUND_DOORBELL_ISR));\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t arcmsr_hbaE_handle_isr(struct AdapterControlBlock *pACB)\n{\n\tuint32_t host_interrupt_status;\n\tstruct MessageUnit_E __iomem *pmu = pACB->pmuE;\n\n\thost_interrupt_status = readl(&pmu->host_int_status) &\n\t\t(ARCMSR_HBEMU_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_HBEMU_OUTBOUND_DOORBELL_ISR);\n\tif (!host_interrupt_status)\n\t\treturn IRQ_NONE;\n\tdo {\n\t\t/* MU ioctl transfer doorbell interrupts*/\n\t\tif (host_interrupt_status & ARCMSR_HBEMU_OUTBOUND_DOORBELL_ISR) {\n\t\t\tarcmsr_hbaE_doorbell_isr(pACB);\n\t\t}\n\t\t/* MU post queue interrupts*/\n\t\tif (host_interrupt_status & ARCMSR_HBEMU_OUTBOUND_POSTQUEUE_ISR) {\n\t\t\tarcmsr_hbaE_postqueue_isr(pACB);\n\t\t}\n\t\thost_interrupt_status = readl(&pmu->host_int_status);\n\t} while (host_interrupt_status & (ARCMSR_HBEMU_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_HBEMU_OUTBOUND_DOORBELL_ISR));\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t arcmsr_hbaF_handle_isr(struct AdapterControlBlock *pACB)\n{\n\tuint32_t host_interrupt_status;\n\tstruct MessageUnit_F __iomem *phbcmu = pACB->pmuF;\n\n\thost_interrupt_status = readl(&phbcmu->host_int_status) &\n\t\t(ARCMSR_HBEMU_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_HBEMU_OUTBOUND_DOORBELL_ISR);\n\tif (!host_interrupt_status)\n\t\treturn IRQ_NONE;\n\tdo {\n\t\t/* MU post queue interrupts*/\n\t\tif (host_interrupt_status & ARCMSR_HBEMU_OUTBOUND_POSTQUEUE_ISR)\n\t\t\tarcmsr_hbaF_postqueue_isr(pACB);\n\n\t\t/* MU ioctl transfer doorbell interrupts*/\n\t\tif (host_interrupt_status & ARCMSR_HBEMU_OUTBOUND_DOORBELL_ISR)\n\t\t\tarcmsr_hbaE_doorbell_isr(pACB);\n\n\t\thost_interrupt_status = readl(&phbcmu->host_int_status);\n\t} while (host_interrupt_status & (ARCMSR_HBEMU_OUTBOUND_POSTQUEUE_ISR |\n\t\tARCMSR_HBEMU_OUTBOUND_DOORBELL_ISR));\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t arcmsr_interrupt(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\treturn arcmsr_hbaA_handle_isr(acb);\n\tcase ACB_ADAPTER_TYPE_B:\n\t\treturn arcmsr_hbaB_handle_isr(acb);\n\tcase ACB_ADAPTER_TYPE_C:\n\t\treturn arcmsr_hbaC_handle_isr(acb);\n\tcase ACB_ADAPTER_TYPE_D:\n\t\treturn arcmsr_hbaD_handle_isr(acb);\n\tcase ACB_ADAPTER_TYPE_E:\n\t\treturn arcmsr_hbaE_handle_isr(acb);\n\tcase ACB_ADAPTER_TYPE_F:\n\t\treturn arcmsr_hbaF_handle_isr(acb);\n\tdefault:\n\t\treturn IRQ_NONE;\n\t}\n}\n\nstatic void arcmsr_iop_parking(struct AdapterControlBlock *acb)\n{\n\tif (acb) {\n\t\t/* stop adapter background rebuild */\n\t\tif (acb->acb_flags & ACB_F_MSG_START_BGRB) {\n\t\t\tuint32_t intmask_org;\n\t\t\tacb->acb_flags &= ~ACB_F_MSG_START_BGRB;\n\t\t\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\t\t\tarcmsr_stop_adapter_bgrb(acb);\n\t\t\tarcmsr_flush_adapter_cache(acb);\n\t\t\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\t\t}\n\t}\n}\n\n\nvoid arcmsr_clear_iop2drv_rqueue_buffer(struct AdapterControlBlock *acb)\n{\n\tuint32_t\ti;\n\n\tif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\n\t\tfor (i = 0; i < 15; i++) {\n\t\t\tif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\n\t\t\t\tacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\n\t\t\t\tacb->rqbuf_getIndex = 0;\n\t\t\t\tacb->rqbuf_putIndex = 0;\n\t\t\t\tarcmsr_iop_message_read(acb);\n\t\t\t\tmdelay(30);\n\t\t\t} else if (acb->rqbuf_getIndex !=\n\t\t\t\t   acb->rqbuf_putIndex) {\n\t\t\t\tacb->rqbuf_getIndex = 0;\n\t\t\t\tacb->rqbuf_putIndex = 0;\n\t\t\t\tmdelay(30);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,\n\t\tstruct scsi_cmnd *cmd)\n{\n\tchar *buffer;\n\tunsigned short use_sg;\n\tint retvalue = 0, transfer_len = 0;\n\tunsigned long flags;\n\tstruct CMD_MESSAGE_FIELD *pcmdmessagefld;\n\tuint32_t controlcode = (uint32_t)cmd->cmnd[5] << 24 |\n\t\t(uint32_t)cmd->cmnd[6] << 16 |\n\t\t(uint32_t)cmd->cmnd[7] << 8 |\n\t\t(uint32_t)cmd->cmnd[8];\n\tstruct scatterlist *sg;\n\n\tuse_sg = scsi_sg_count(cmd);\n\tsg = scsi_sglist(cmd);\n\tbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\n\tif (use_sg > 1) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tgoto message_out;\n\t}\n\ttransfer_len += sg->length;\n\tif (transfer_len > sizeof(struct CMD_MESSAGE_FIELD)) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: ARCMSR_MESSAGE_FAIL!\\n\", __func__);\n\t\tgoto message_out;\n\t}\n\tpcmdmessagefld = (struct CMD_MESSAGE_FIELD *)buffer;\n\tswitch (controlcode) {\n\tcase ARCMSR_MESSAGE_READ_RQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tuint8_t *ptmpQbuffer;\n\t\tuint32_t allxfer_len = 0;\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tpr_info(\"%s: memory not enough!\\n\", __func__);\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpQbuffer = ver_addr;\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tif (acb->rqbuf_getIndex != acb->rqbuf_putIndex) {\n\t\t\tunsigned int tail = acb->rqbuf_getIndex;\n\t\t\tunsigned int head = acb->rqbuf_putIndex;\n\t\t\tunsigned int cnt_to_end = CIRC_CNT_TO_END(head, tail, ARCMSR_MAX_QBUFFER);\n\n\t\t\tallxfer_len = CIRC_CNT(head, tail, ARCMSR_MAX_QBUFFER);\n\t\t\tif (allxfer_len > ARCMSR_API_DATA_BUFLEN)\n\t\t\t\tallxfer_len = ARCMSR_API_DATA_BUFLEN;\n\n\t\t\tif (allxfer_len <= cnt_to_end)\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, allxfer_len);\n\t\t\telse {\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, cnt_to_end);\n\t\t\t\tmemcpy(ptmpQbuffer + cnt_to_end, acb->rqbuffer, allxfer_len - cnt_to_end);\n\t\t\t}\n\t\t\tacb->rqbuf_getIndex = (acb->rqbuf_getIndex + allxfer_len) % ARCMSR_MAX_QBUFFER;\n\t\t}\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer, ver_addr,\n\t\t\tallxfer_len);\n\t\tif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\n\t\t\tstruct QBUFFER __iomem *prbuffer;\n\t\t\tacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\n\t\t\tprbuffer = arcmsr_get_iop_rqbuffer(acb);\n\t\t\tif (arcmsr_Read_iop_rqbuffer_data(acb, prbuffer) == 0)\n\t\t\t\tacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tpcmdmessagefld->cmdmessage.Length = allxfer_len;\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_WRITE_WQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tuint32_t user_len;\n\t\tint32_t cnt2end;\n\t\tuint8_t *pQbuffer, *ptmpuserbuffer;\n\n\t\tuser_len = pcmdmessagefld->cmdmessage.Length;\n\t\tif (user_len > ARCMSR_API_DATA_BUFLEN) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tgoto message_out;\n\t\t}\n\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpuserbuffer = ver_addr;\n\n\t\tmemcpy(ptmpuserbuffer,\n\t\t\tpcmdmessagefld->messagedatabuffer, user_len);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tif (acb->wqbuf_putIndex != acb->wqbuf_getIndex) {\n\t\t\tstruct SENSE_DATA *sensebuffer =\n\t\t\t\t(struct SENSE_DATA *)cmd->sense_buffer;\n\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t/* has error report sensedata */\n\t\t\tsensebuffer->ErrorCode = SCSI_SENSE_CURRENT_ERRORS;\n\t\t\tsensebuffer->SenseKey = ILLEGAL_REQUEST;\n\t\t\tsensebuffer->AdditionalSenseLength = 0x0A;\n\t\t\tsensebuffer->AdditionalSenseCode = 0x20;\n\t\t\tsensebuffer->Valid = 1;\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t} else {\n\t\t\tpQbuffer = &acb->wqbuffer[acb->wqbuf_putIndex];\n\t\t\tcnt2end = ARCMSR_MAX_QBUFFER - acb->wqbuf_putIndex;\n\t\t\tif (user_len > cnt2end) {\n\t\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, cnt2end);\n\t\t\t\tptmpuserbuffer += cnt2end;\n\t\t\t\tuser_len -= cnt2end;\n\t\t\t\tacb->wqbuf_putIndex = 0;\n\t\t\t\tpQbuffer = acb->wqbuffer;\n\t\t\t}\n\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, user_len);\n\t\t\tacb->wqbuf_putIndex += user_len;\n\t\t\tacb->wqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\n\t\t\tif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_CLEARED) {\n\t\t\t\tacb->acb_flags &=\n\t\t\t\t\t\t~ACB_F_MESSAGE_WQBUFFER_CLEARED;\n\t\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_RQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->rqbuffer;\n\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_WQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->wqbuffer;\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_ALLQBUFFER: {\n\t\tuint8_t *pQbuffer;\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tpQbuffer = acb->rqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tpQbuffer = acb->wqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_RETURN_CODE_3F: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_3F;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_HELLO: {\n\t\tint8_t *hello_string = \"Hello! I am ARCMSR\";\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer,\n\t\t\thello_string, (int16_t)strlen(hello_string));\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_GOODBYE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_iop_parking(acb);\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_flush_adapter_cache(acb);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: unknown controlcode!\\n\", __func__);\n\t}\nmessage_out:\n\tif (use_sg) {\n\t\tstruct scatterlist *sg = scsi_sglist(cmd);\n\t\tkunmap_atomic(buffer - sg->offset);\n\t}\n\treturn retvalue;\n}\n\nstatic struct CommandControlBlock *arcmsr_get_freeccb(struct AdapterControlBlock *acb)\n{\n\tstruct list_head *head;\n\tstruct CommandControlBlock *ccb = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&acb->ccblist_lock, flags);\n\thead = &acb->ccb_free_list;\n\tif (!list_empty(head)) {\n\t\tccb = list_entry(head->next, struct CommandControlBlock, list);\n\t\tlist_del_init(&ccb->list);\n\t}else{\n\t\tspin_unlock_irqrestore(&acb->ccblist_lock, flags);\n\t\treturn NULL;\n\t}\n\tspin_unlock_irqrestore(&acb->ccblist_lock, flags);\n\treturn ccb;\n}\n\nstatic void arcmsr_handle_virtual_command(struct AdapterControlBlock *acb,\n\t\tstruct scsi_cmnd *cmd)\n{\n\tswitch (cmd->cmnd[0]) {\n\tcase INQUIRY: {\n\t\tunsigned char inqdata[36];\n\t\tchar *buffer;\n\t\tstruct scatterlist *sg;\n\n\t\tif (cmd->device->lun) {\n\t\t\tcmd->result = (DID_TIME_OUT << 16);\n\t\t\tscsi_done(cmd);\n\t\t\treturn;\n\t\t}\n\t\tinqdata[0] = TYPE_PROCESSOR;\n\t\t/* Periph Qualifier & Periph Dev Type */\n\t\tinqdata[1] = 0;\n\t\t/* rem media bit & Dev Type Modifier */\n\t\tinqdata[2] = 0;\n\t\t/* ISO, ECMA, & ANSI versions */\n\t\tinqdata[4] = 31;\n\t\t/* length of additional data */\n\t\tmemcpy(&inqdata[8], \"Areca   \", 8);\n\t\t/* Vendor Identification */\n\t\tmemcpy(&inqdata[16], \"RAID controller \", 16);\n\t\t/* Product Identification */\n\t\tmemcpy(&inqdata[32], \"R001\", 4); /* Product Revision */\n\n\t\tsg = scsi_sglist(cmd);\n\t\tbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\n\n\t\tmemcpy(buffer, inqdata, sizeof(inqdata));\n\t\tsg = scsi_sglist(cmd);\n\t\tkunmap_atomic(buffer - sg->offset);\n\n\t\tscsi_done(cmd);\n\t}\n\tbreak;\n\tcase WRITE_BUFFER:\n\tcase READ_BUFFER: {\n\t\tif (arcmsr_iop_message_xfer(acb, cmd))\n\t\t\tcmd->result = (DID_ERROR << 16);\n\t\tscsi_done(cmd);\n\t}\n\tbreak;\n\tdefault:\n\t\tscsi_done(cmd);\n\t}\n}\n\nstatic int arcmsr_queue_command_lck(struct scsi_cmnd *cmd)\n{\n\tstruct Scsi_Host *host = cmd->device->host;\n\tstruct AdapterControlBlock *acb = (struct AdapterControlBlock *) host->hostdata;\n\tstruct CommandControlBlock *ccb;\n\tint target = cmd->device->id;\n\n\tif (acb->acb_flags & ACB_F_ADAPTER_REMOVED) {\n\t\tcmd->result = (DID_NO_CONNECT << 16);\n\t\tscsi_done(cmd);\n\t\treturn 0;\n\t}\n\tcmd->host_scribble = NULL;\n\tcmd->result = 0;\n\tif (target == 16) {\n\t\t/* virtual device for iop message transfer */\n\t\tarcmsr_handle_virtual_command(acb, cmd);\n\t\treturn 0;\n\t}\n\tccb = arcmsr_get_freeccb(acb);\n\tif (!ccb)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\tif (arcmsr_build_ccb( acb, ccb, cmd ) == FAILED) {\n\t\tcmd->result = (DID_ERROR << 16) | SAM_STAT_RESERVATION_CONFLICT;\n\t\tscsi_done(cmd);\n\t\treturn 0;\n\t}\n\tarcmsr_post_ccb(acb, ccb);\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(arcmsr_queue_command)\n\nstatic int arcmsr_slave_config(struct scsi_device *sdev)\n{\n\tunsigned int\tdev_timeout;\n\n\tdev_timeout = sdev->request_queue->rq_timeout;\n\tif ((cmd_timeout > 0) && ((cmd_timeout * HZ) > dev_timeout))\n\t\tblk_queue_rq_timeout(sdev->request_queue, cmd_timeout * HZ);\n\treturn 0;\n}\n\nstatic void arcmsr_get_adapter_config(struct AdapterControlBlock *pACB, uint32_t *rwbuffer)\n{\n\tint count;\n\tuint32_t *acb_firm_model = (uint32_t *)pACB->firm_model;\n\tuint32_t *acb_firm_version = (uint32_t *)pACB->firm_version;\n\tuint32_t *acb_device_map = (uint32_t *)pACB->device_map;\n\tuint32_t *firm_model = &rwbuffer[15];\n\tuint32_t *firm_version = &rwbuffer[17];\n\tuint32_t *device_map = &rwbuffer[21];\n\n\tcount = 2;\n\twhile (count) {\n\t\t*acb_firm_model = readl(firm_model);\n\t\tacb_firm_model++;\n\t\tfirm_model++;\n\t\tcount--;\n\t}\n\tcount = 4;\n\twhile (count) {\n\t\t*acb_firm_version = readl(firm_version);\n\t\tacb_firm_version++;\n\t\tfirm_version++;\n\t\tcount--;\n\t}\n\tcount = 4;\n\twhile (count) {\n\t\t*acb_device_map = readl(device_map);\n\t\tacb_device_map++;\n\t\tdevice_map++;\n\t\tcount--;\n\t}\n\tpACB->signature = readl(&rwbuffer[0]);\n\tpACB->firm_request_len = readl(&rwbuffer[1]);\n\tpACB->firm_numbers_queue = readl(&rwbuffer[2]);\n\tpACB->firm_sdram_size = readl(&rwbuffer[3]);\n\tpACB->firm_hd_channels = readl(&rwbuffer[4]);\n\tpACB->firm_cfg_version = readl(&rwbuffer[25]);\n\tpr_notice(\"Areca RAID Controller%d: Model %s, F/W %s\\n\",\n\t\tpACB->host->host_no,\n\t\tpACB->firm_model,\n\t\tpACB->firm_version);\n}\n\nstatic bool arcmsr_hbaA_get_config(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\n\tarcmsr_wait_firmware_ready(acb);\n\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'get adapter firmware \\\n\t\t\tmiscellaneous data' timeout \\n\", acb->host->host_no);\n\t\treturn false;\n\t}\n\tarcmsr_get_adapter_config(acb, reg->message_rwbuffer);\n\treturn true;\n}\nstatic bool arcmsr_hbaB_get_config(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\n\tarcmsr_wait_firmware_ready(acb);\n\twritel(ARCMSR_MESSAGE_START_DRIVER_MODE, reg->drv2iop_doorbell);\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_ERR \"arcmsr%d: can't set driver mode.\\n\", acb->host->host_no);\n\t\treturn false;\n\t}\n\twritel(ARCMSR_MESSAGE_GET_CONFIG, reg->drv2iop_doorbell);\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'get adapter firmware \\\n\t\t\tmiscellaneous data' timeout \\n\", acb->host->host_no);\n\t\treturn false;\n\t}\n\tarcmsr_get_adapter_config(acb, reg->message_rwbuffer);\n\treturn true;\n}\n\nstatic bool arcmsr_hbaC_get_config(struct AdapterControlBlock *pACB)\n{\n\tuint32_t intmask_org;\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\n\t/* disable all outbound interrupt */\n\tintmask_org = readl(&reg->host_int_mask); /* disable outbound message0 int */\n\twritel(intmask_org|ARCMSR_HBCMU_ALL_INTMASKENABLE, &reg->host_int_mask);\n\t/* wait firmware ready */\n\tarcmsr_wait_firmware_ready(pACB);\n\t/* post \"get config\" instruction */\n\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\t/* wait message ready */\n\tif (!arcmsr_hbaC_wait_msgint_ready(pACB)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'get adapter firmware \\\n\t\t\tmiscellaneous data' timeout \\n\", pACB->host->host_no);\n\t\treturn false;\n\t}\n\tarcmsr_get_adapter_config(pACB, reg->msgcode_rwbuffer);\n\treturn true;\n}\n\nstatic bool arcmsr_hbaD_get_config(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_D *reg = acb->pmuD;\n\n\tif (readl(acb->pmuD->outbound_doorbell) &\n\t\tARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\twritel(ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE,\n\t\t\tacb->pmuD->outbound_doorbell);/*clear interrupt*/\n\t}\n\tarcmsr_wait_firmware_ready(acb);\n\t/* post \"get config\" instruction */\n\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, reg->inbound_msgaddr0);\n\t/* wait message ready */\n\tif (!arcmsr_hbaD_wait_msgint_ready(acb)) {\n\t\tpr_notice(\"arcmsr%d: wait get adapter firmware \"\n\t\t\t\"miscellaneous data timeout\\n\", acb->host->host_no);\n\t\treturn false;\n\t}\n\tarcmsr_get_adapter_config(acb, reg->msgcode_rwbuffer);\n\treturn true;\n}\n\nstatic bool arcmsr_hbaE_get_config(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_E __iomem *reg = pACB->pmuE;\n\tuint32_t intmask_org;\n\n\t/* disable all outbound interrupt */\n\tintmask_org = readl(&reg->host_int_mask); /* disable outbound message0 int */\n\twritel(intmask_org | ARCMSR_HBEMU_ALL_INTMASKENABLE, &reg->host_int_mask);\n\t/* wait firmware ready */\n\tarcmsr_wait_firmware_ready(pACB);\n\tmdelay(20);\n\t/* post \"get config\" instruction */\n\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\n\tpACB->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_MESSAGE_CMD_DONE;\n\twritel(pACB->out_doorbell, &reg->iobound_doorbell);\n\t/* wait message ready */\n\tif (!arcmsr_hbaE_wait_msgint_ready(pACB)) {\n\t\tpr_notice(\"arcmsr%d: wait get adapter firmware \"\n\t\t\t\"miscellaneous data timeout\\n\", pACB->host->host_no);\n\t\treturn false;\n\t}\n\tarcmsr_get_adapter_config(pACB, reg->msgcode_rwbuffer);\n\treturn true;\n}\n\nstatic bool arcmsr_hbaF_get_config(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_F __iomem *reg = pACB->pmuF;\n\tuint32_t intmask_org;\n\n\t/* disable all outbound interrupt */\n\tintmask_org = readl(&reg->host_int_mask); /* disable outbound message0 int */\n\twritel(intmask_org | ARCMSR_HBEMU_ALL_INTMASKENABLE, &reg->host_int_mask);\n\t/* wait firmware ready */\n\tarcmsr_wait_firmware_ready(pACB);\n\t/* post \"get config\" instruction */\n\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\n\tpACB->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_MESSAGE_CMD_DONE;\n\twritel(pACB->out_doorbell, &reg->iobound_doorbell);\n\t/* wait message ready */\n\tif (!arcmsr_hbaE_wait_msgint_ready(pACB)) {\n\t\tpr_notice(\"arcmsr%d: wait get adapter firmware miscellaneous data timeout\\n\",\n\t\t\t  pACB->host->host_no);\n\t\treturn false;\n\t}\n\tarcmsr_get_adapter_config(pACB, pACB->msgcode_rwbuffer);\n\treturn true;\n}\n\nstatic bool arcmsr_get_firmware_spec(struct AdapterControlBlock *acb)\n{\n\tbool rtn = false;\n\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\trtn = arcmsr_hbaA_get_config(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\trtn = arcmsr_hbaB_get_config(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\trtn = arcmsr_hbaC_get_config(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\trtn = arcmsr_hbaD_get_config(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\t\trtn = arcmsr_hbaE_get_config(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_F:\n\t\trtn = arcmsr_hbaF_get_config(acb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tacb->maxOutstanding = acb->firm_numbers_queue - 1;\n\tif (acb->host->can_queue >= acb->firm_numbers_queue)\n\t\tacb->host->can_queue = acb->maxOutstanding;\n\telse\n\t\tacb->maxOutstanding = acb->host->can_queue;\n\tacb->maxFreeCCB = acb->host->can_queue;\n\tif (acb->maxFreeCCB < ARCMSR_MAX_FREECCB_NUM)\n\t\tacb->maxFreeCCB += 64;\n\treturn rtn;\n}\n\nstatic int arcmsr_hbaA_polling_ccbdone(struct AdapterControlBlock *acb,\n\tstruct CommandControlBlock *poll_ccb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tstruct CommandControlBlock *ccb;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tuint32_t flag_ccb, outbound_intstatus, poll_ccb_done = 0, poll_count = 0;\n\tint rtn;\n\tbool error;\n\tunsigned long ccb_cdb_phy;\n\npolling_hba_ccb_retry:\n\tpoll_count++;\n\toutbound_intstatus = readl(&reg->outbound_intstatus) & acb->outbound_int_enable;\n\twritel(outbound_intstatus, &reg->outbound_intstatus);/*clear interrupt*/\n\twhile (1) {\n\t\tif ((flag_ccb = readl(&reg->outbound_queueport)) == 0xFFFFFFFF) {\n\t\t\tif (poll_ccb_done){\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\tmsleep(25);\n\t\t\t\tif (poll_count > 100){\n\t\t\t\t\trtn = FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto polling_hba_ccb_retry;\n\t\t\t}\n\t\t}\n\t\tccb_cdb_phy = (flag_ccb << 5) & 0xffffffff;\n\t\tif (acb->cdb_phyadd_hipart)\n\t\t\tccb_cdb_phy = ccb_cdb_phy | acb->cdb_phyadd_hipart;\n\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + ccb_cdb_phy);\n\t\tccb = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\n\t\tpoll_ccb_done |= (ccb == poll_ccb) ? 1 : 0;\n\t\tif ((ccb->acb != acb) || (ccb->startdone != ARCMSR_CCB_START)) {\n\t\t\tif ((ccb->startdone == ARCMSR_CCB_ABORTED) || (ccb == poll_ccb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'\"\n\t\t\t\t\t\" poll command abort successfully \\n\"\n\t\t\t\t\t, acb->host->host_no\n\t\t\t\t\t, ccb->pcmd->device->id\n\t\t\t\t\t, (u32)ccb->pcmd->device->lun\n\t\t\t\t\t, ccb);\n\t\t\t\tccb->pcmd->result = DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: polling get an illegal ccb\"\n\t\t\t\t\" command done ccb = '0x%p'\"\n\t\t\t\t\"ccboutstandingcount = %d \\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, ccb\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\t\tcontinue;\n\t\t}\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\tarcmsr_report_ccb_state(acb, ccb, error);\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_hbaB_polling_ccbdone(struct AdapterControlBlock *acb,\n\t\t\t\t\tstruct CommandControlBlock *poll_ccb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tstruct CommandControlBlock *ccb;\n\tuint32_t flag_ccb, poll_ccb_done = 0, poll_count = 0;\n\tint index, rtn;\n\tbool error;\n\tunsigned long ccb_cdb_phy;\n\npolling_hbb_ccb_retry:\n\tpoll_count++;\n\t/* clear doorbell interrupt */\n\twritel(ARCMSR_DOORBELL_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\n\twhile(1){\n\t\tindex = reg->doneq_index;\n\t\tflag_ccb = reg->done_qbuffer[index];\n\t\tif (flag_ccb == 0) {\n\t\t\tif (poll_ccb_done){\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\tmsleep(25);\n\t\t\t\tif (poll_count > 100){\n\t\t\t\t\trtn = FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto polling_hbb_ccb_retry;\n\t\t\t}\n\t\t}\n\t\treg->done_qbuffer[index] = 0;\n\t\tindex++;\n\t\t/*if last index number set it to 0 */\n\t\tindex %= ARCMSR_MAX_HBB_POSTQUEUE;\n\t\treg->doneq_index = index;\n\t\t/* check if command done with no error*/\n\t\tccb_cdb_phy = (flag_ccb << 5) & 0xffffffff;\n\t\tif (acb->cdb_phyadd_hipart)\n\t\t\tccb_cdb_phy = ccb_cdb_phy | acb->cdb_phyadd_hipart;\n\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + ccb_cdb_phy);\n\t\tccb = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\n\t\tpoll_ccb_done |= (ccb == poll_ccb) ? 1 : 0;\n\t\tif ((ccb->acb != acb) || (ccb->startdone != ARCMSR_CCB_START)) {\n\t\t\tif ((ccb->startdone == ARCMSR_CCB_ABORTED) || (ccb == poll_ccb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'\"\n\t\t\t\t\t\" poll command abort successfully \\n\"\n\t\t\t\t\t,acb->host->host_no\n\t\t\t\t\t,ccb->pcmd->device->id\n\t\t\t\t\t,(u32)ccb->pcmd->device->lun\n\t\t\t\t\t,ccb);\n\t\t\t\tccb->pcmd->result = DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(ccb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: polling get an illegal ccb\"\n\t\t\t\t\" command done ccb = '0x%p'\"\n\t\t\t\t\"ccboutstandingcount = %d \\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, ccb\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\t\tcontinue;\n\t\t} \n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\n\t\tarcmsr_report_ccb_state(acb, ccb, error);\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_hbaC_polling_ccbdone(struct AdapterControlBlock *acb,\n\t\tstruct CommandControlBlock *poll_ccb)\n{\n\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\tuint32_t flag_ccb;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tbool error;\n\tstruct CommandControlBlock *pCCB;\n\tuint32_t poll_ccb_done = 0, poll_count = 0;\n\tint rtn;\n\tunsigned long ccb_cdb_phy;\n\npolling_hbc_ccb_retry:\n\tpoll_count++;\n\twhile (1) {\n\t\tif ((readl(&reg->host_int_status) & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR) == 0) {\n\t\t\tif (poll_ccb_done) {\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmsleep(25);\n\t\t\t\tif (poll_count > 100) {\n\t\t\t\t\trtn = FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto polling_hbc_ccb_retry;\n\t\t\t}\n\t\t}\n\t\tflag_ccb = readl(&reg->outbound_queueport_low);\n\t\tccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\n\t\tif (acb->cdb_phyadd_hipart)\n\t\t\tccb_cdb_phy = ccb_cdb_phy | acb->cdb_phyadd_hipart;\n\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + ccb_cdb_phy);\n\t\tpCCB = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\n\t\tpoll_ccb_done |= (pCCB == poll_ccb) ? 1 : 0;\n\t\t/* check ifcommand done with no error*/\n\t\tif ((pCCB->acb != acb) || (pCCB->startdone != ARCMSR_CCB_START)) {\n\t\t\tif (pCCB->startdone == ARCMSR_CCB_ABORTED) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'\"\n\t\t\t\t\t\" poll command abort successfully \\n\"\n\t\t\t\t\t, acb->host->host_no\n\t\t\t\t\t, pCCB->pcmd->device->id\n\t\t\t\t\t, (u32)pCCB->pcmd->device->lun\n\t\t\t\t\t, pCCB);\n\t\t\t\tpCCB->pcmd->result = DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(pCCB);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: polling get an illegal ccb\"\n\t\t\t\t\" command done ccb = '0x%p'\"\n\t\t\t\t\"ccboutstandingcount = %d \\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, pCCB\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\t\tcontinue;\n\t\t}\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ? true : false;\n\t\tarcmsr_report_ccb_state(acb, pCCB, error);\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_hbaD_polling_ccbdone(struct AdapterControlBlock *acb,\n\t\t\t\tstruct CommandControlBlock *poll_ccb)\n{\n\tbool error;\n\tuint32_t poll_ccb_done = 0, poll_count = 0, flag_ccb;\n\tint rtn, doneq_index, index_stripped, outbound_write_pointer, toggle;\n\tunsigned long flags, ccb_cdb_phy;\n\tstruct ARCMSR_CDB *arcmsr_cdb;\n\tstruct CommandControlBlock *pCCB;\n\tstruct MessageUnit_D *pmu = acb->pmuD;\n\npolling_hbaD_ccb_retry:\n\tpoll_count++;\n\twhile (1) {\n\t\tspin_lock_irqsave(&acb->doneq_lock, flags);\n\t\toutbound_write_pointer = pmu->done_qbuffer[0].addressLow + 1;\n\t\tdoneq_index = pmu->doneq_index;\n\t\tif ((outbound_write_pointer & 0xFFF) == (doneq_index & 0xFFF)) {\n\t\t\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n\t\t\tif (poll_ccb_done) {\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmsleep(25);\n\t\t\t\tif (poll_count > 40) {\n\t\t\t\t\trtn = FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto polling_hbaD_ccb_retry;\n\t\t\t}\n\t\t}\n\t\ttoggle = doneq_index & 0x4000;\n\t\tindex_stripped = (doneq_index & 0xFFF) + 1;\n\t\tindex_stripped %= ARCMSR_MAX_ARC1214_DONEQUEUE;\n\t\tpmu->doneq_index = index_stripped ? (index_stripped | toggle) :\n\t\t\t\t((toggle ^ 0x4000) + 1);\n\t\tdoneq_index = pmu->doneq_index;\n\t\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n\t\tflag_ccb = pmu->done_qbuffer[doneq_index & 0xFFF].addressLow;\n\t\tccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\n\t\tif (acb->cdb_phyadd_hipart)\n\t\t\tccb_cdb_phy = ccb_cdb_phy | acb->cdb_phyadd_hipart;\n\t\tarcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset +\n\t\t\tccb_cdb_phy);\n\t\tpCCB = container_of(arcmsr_cdb, struct CommandControlBlock,\n\t\t\tarcmsr_cdb);\n\t\tpoll_ccb_done |= (pCCB == poll_ccb) ? 1 : 0;\n\t\tif ((pCCB->acb != acb) ||\n\t\t\t(pCCB->startdone != ARCMSR_CCB_START)) {\n\t\t\tif (pCCB->startdone == ARCMSR_CCB_ABORTED) {\n\t\t\t\tpr_notice(\"arcmsr%d: scsi id = %d \"\n\t\t\t\t\t\"lun = %d ccb = '0x%p' poll command \"\n\t\t\t\t\t\"abort successfully\\n\"\n\t\t\t\t\t, acb->host->host_no\n\t\t\t\t\t, pCCB->pcmd->device->id\n\t\t\t\t\t, (u32)pCCB->pcmd->device->lun\n\t\t\t\t\t, pCCB);\n\t\t\t\tpCCB->pcmd->result = DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(pCCB);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpr_notice(\"arcmsr%d: polling an illegal \"\n\t\t\t\t\"ccb command done ccb = '0x%p' \"\n\t\t\t\t\"ccboutstandingcount = %d\\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, pCCB\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\t\tcontinue;\n\t\t}\n\t\terror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1)\n\t\t\t? true : false;\n\t\tarcmsr_report_ccb_state(acb, pCCB, error);\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_hbaE_polling_ccbdone(struct AdapterControlBlock *acb,\n\t\t\t\tstruct CommandControlBlock *poll_ccb)\n{\n\tbool error;\n\tuint32_t poll_ccb_done = 0, poll_count = 0, doneq_index;\n\tuint16_t cmdSMID;\n\tunsigned long flags;\n\tint rtn;\n\tstruct CommandControlBlock *pCCB;\n\tstruct MessageUnit_E __iomem *reg = acb->pmuE;\n\n\tpolling_hbaC_ccb_retry:\n\tpoll_count++;\n\twhile (1) {\n\t\tspin_lock_irqsave(&acb->doneq_lock, flags);\n\t\tdoneq_index = acb->doneq_index;\n\t\tif ((readl(&reg->reply_post_producer_index) & 0xFFFF) ==\n\t\t\t\tdoneq_index) {\n\t\t\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n\t\t\tif (poll_ccb_done) {\n\t\t\t\trtn = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmsleep(25);\n\t\t\t\tif (poll_count > 40) {\n\t\t\t\t\trtn = FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto polling_hbaC_ccb_retry;\n\t\t\t}\n\t\t}\n\t\tcmdSMID = acb->pCompletionQ[doneq_index].cmdSMID;\n\t\tdoneq_index++;\n\t\tif (doneq_index >= acb->completionQ_entry)\n\t\t\tdoneq_index = 0;\n\t\tacb->doneq_index = doneq_index;\n\t\tspin_unlock_irqrestore(&acb->doneq_lock, flags);\n\t\tpCCB = acb->pccb_pool[cmdSMID];\n\t\tpoll_ccb_done |= (pCCB == poll_ccb) ? 1 : 0;\n\t\t/* check if command done with no error*/\n\t\tif ((pCCB->acb != acb) || (pCCB->startdone != ARCMSR_CCB_START)) {\n\t\t\tif (pCCB->startdone == ARCMSR_CCB_ABORTED) {\n\t\t\t\tpr_notice(\"arcmsr%d: scsi id = %d \"\n\t\t\t\t\t\"lun = %d ccb = '0x%p' poll command \"\n\t\t\t\t\t\"abort successfully\\n\"\n\t\t\t\t\t, acb->host->host_no\n\t\t\t\t\t, pCCB->pcmd->device->id\n\t\t\t\t\t, (u32)pCCB->pcmd->device->lun\n\t\t\t\t\t, pCCB);\n\t\t\t\tpCCB->pcmd->result = DID_ABORT << 16;\n\t\t\t\tarcmsr_ccb_complete(pCCB);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpr_notice(\"arcmsr%d: polling an illegal \"\n\t\t\t\t\"ccb command done ccb = '0x%p' \"\n\t\t\t\t\"ccboutstandingcount = %d\\n\"\n\t\t\t\t, acb->host->host_no\n\t\t\t\t, pCCB\n\t\t\t\t, atomic_read(&acb->ccboutstandingcount));\n\t\t\tcontinue;\n\t\t}\n\t\terror = (acb->pCompletionQ[doneq_index].cmdFlag &\n\t\t\tARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ? true : false;\n\t\tarcmsr_report_ccb_state(acb, pCCB, error);\n\t}\n\twritel(doneq_index, &reg->reply_post_consumer_index);\n\treturn rtn;\n}\n\nstatic int arcmsr_polling_ccbdone(struct AdapterControlBlock *acb,\n\t\t\t\t\tstruct CommandControlBlock *poll_ccb)\n{\n\tint rtn = 0;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A:\n\t\trtn = arcmsr_hbaA_polling_ccbdone(acb, poll_ccb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\trtn = arcmsr_hbaB_polling_ccbdone(acb, poll_ccb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\trtn = arcmsr_hbaC_polling_ccbdone(acb, poll_ccb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\trtn = arcmsr_hbaD_polling_ccbdone(acb, poll_ccb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\tcase ACB_ADAPTER_TYPE_F:\n\t\trtn = arcmsr_hbaE_polling_ccbdone(acb, poll_ccb);\n\t\tbreak;\n\t}\n\treturn rtn;\n}\n\nstatic void arcmsr_set_iop_datetime(struct timer_list *t)\n{\n\tstruct AdapterControlBlock *pacb = from_timer(pacb, t, refresh_timer);\n\tunsigned int next_time;\n\tstruct tm tm;\n\n\tunion {\n\t\tstruct\t{\n\t\tuint16_t\tsignature;\n\t\tuint8_t\t\tyear;\n\t\tuint8_t\t\tmonth;\n\t\tuint8_t\t\tdate;\n\t\tuint8_t\t\thour;\n\t\tuint8_t\t\tminute;\n\t\tuint8_t\t\tsecond;\n\t\t} a;\n\t\tstruct\t{\n\t\tuint32_t\tmsg_time[2];\n\t\t} b;\n\t} datetime;\n\n\ttime64_to_tm(ktime_get_real_seconds(), -sys_tz.tz_minuteswest * 60, &tm);\n\n\tdatetime.a.signature = 0x55AA;\n\tdatetime.a.year = tm.tm_year - 100; /* base 2000 instead of 1900 */\n\tdatetime.a.month = tm.tm_mon;\n\tdatetime.a.date = tm.tm_mday;\n\tdatetime.a.hour = tm.tm_hour;\n\tdatetime.a.minute = tm.tm_min;\n\tdatetime.a.second = tm.tm_sec;\n\n\tswitch (pacb->adapter_type) {\n\t\tcase ACB_ADAPTER_TYPE_A: {\n\t\t\tstruct MessageUnit_A __iomem *reg = pacb->pmuA;\n\t\t\twritel(datetime.b.msg_time[0], &reg->message_rwbuffer[0]);\n\t\t\twritel(datetime.b.msg_time[1], &reg->message_rwbuffer[1]);\n\t\t\twritel(ARCMSR_INBOUND_MESG0_SYNC_TIMER, &reg->inbound_msgaddr0);\n\t\t\tbreak;\n\t\t}\n\t\tcase ACB_ADAPTER_TYPE_B: {\n\t\t\tuint32_t __iomem *rwbuffer;\n\t\t\tstruct MessageUnit_B *reg = pacb->pmuB;\n\t\t\trwbuffer = reg->message_rwbuffer;\n\t\t\twritel(datetime.b.msg_time[0], rwbuffer++);\n\t\t\twritel(datetime.b.msg_time[1], rwbuffer++);\n\t\t\twritel(ARCMSR_MESSAGE_SYNC_TIMER, reg->drv2iop_doorbell);\n\t\t\tbreak;\n\t\t}\n\t\tcase ACB_ADAPTER_TYPE_C: {\n\t\t\tstruct MessageUnit_C __iomem *reg = pacb->pmuC;\n\t\t\twritel(datetime.b.msg_time[0], &reg->msgcode_rwbuffer[0]);\n\t\t\twritel(datetime.b.msg_time[1], &reg->msgcode_rwbuffer[1]);\n\t\t\twritel(ARCMSR_INBOUND_MESG0_SYNC_TIMER, &reg->inbound_msgaddr0);\n\t\t\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\t\t\tbreak;\n\t\t}\n\t\tcase ACB_ADAPTER_TYPE_D: {\n\t\t\tuint32_t __iomem *rwbuffer;\n\t\t\tstruct MessageUnit_D *reg = pacb->pmuD;\n\t\t\trwbuffer = reg->msgcode_rwbuffer;\n\t\t\twritel(datetime.b.msg_time[0], rwbuffer++);\n\t\t\twritel(datetime.b.msg_time[1], rwbuffer++);\n\t\t\twritel(ARCMSR_INBOUND_MESG0_SYNC_TIMER, reg->inbound_msgaddr0);\n\t\t\tbreak;\n\t\t}\n\t\tcase ACB_ADAPTER_TYPE_E: {\n\t\t\tstruct MessageUnit_E __iomem *reg = pacb->pmuE;\n\t\t\twritel(datetime.b.msg_time[0], &reg->msgcode_rwbuffer[0]);\n\t\t\twritel(datetime.b.msg_time[1], &reg->msgcode_rwbuffer[1]);\n\t\t\twritel(ARCMSR_INBOUND_MESG0_SYNC_TIMER, &reg->inbound_msgaddr0);\n\t\t\tpacb->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_MESSAGE_CMD_DONE;\n\t\t\twritel(pacb->out_doorbell, &reg->iobound_doorbell);\n\t\t\tbreak;\n\t\t}\n\t\tcase ACB_ADAPTER_TYPE_F: {\n\t\t\tstruct MessageUnit_F __iomem *reg = pacb->pmuF;\n\n\t\t\tpacb->msgcode_rwbuffer[0] = datetime.b.msg_time[0];\n\t\t\tpacb->msgcode_rwbuffer[1] = datetime.b.msg_time[1];\n\t\t\twritel(ARCMSR_INBOUND_MESG0_SYNC_TIMER, &reg->inbound_msgaddr0);\n\t\t\tpacb->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_MESSAGE_CMD_DONE;\n\t\t\twritel(pacb->out_doorbell, &reg->iobound_doorbell);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (sys_tz.tz_minuteswest)\n\t\tnext_time = ARCMSR_HOURS;\n\telse\n\t\tnext_time = ARCMSR_MINUTES;\n\tmod_timer(&pacb->refresh_timer, jiffies + msecs_to_jiffies(next_time));\n}\n\nstatic int arcmsr_iop_confirm(struct AdapterControlBlock *acb)\n{\n\tuint32_t cdb_phyaddr, cdb_phyaddr_hi32;\n\tdma_addr_t dma_coherent_handle;\n\n\t/*\n\t********************************************************************\n\t** here we need to tell iop 331 our freeccb.HighPart\n\t** if freeccb.HighPart is not zero\n\t********************************************************************\n\t*/\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_B:\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tdma_coherent_handle = acb->dma_coherent_handle2;\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\tcase ACB_ADAPTER_TYPE_F:\n\t\tdma_coherent_handle = acb->dma_coherent_handle +\n\t\t\toffsetof(struct CommandControlBlock, arcmsr_cdb);\n\t\tbreak;\n\tdefault:\n\t\tdma_coherent_handle = acb->dma_coherent_handle;\n\t\tbreak;\n\t}\n\tcdb_phyaddr = lower_32_bits(dma_coherent_handle);\n\tcdb_phyaddr_hi32 = upper_32_bits(dma_coherent_handle);\n\tacb->cdb_phyaddr_hi32 = cdb_phyaddr_hi32;\n\tacb->cdb_phyadd_hipart = ((uint64_t)cdb_phyaddr_hi32) << 32;\n\t/*\n\t***********************************************************************\n\t**    if adapter type B, set window of \"post command Q\"\n\t***********************************************************************\n\t*/\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tif (cdb_phyaddr_hi32 != 0) {\n\t\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, \\\n\t\t\t\t\t\t&reg->message_rwbuffer[0]);\n\t\t\twritel(cdb_phyaddr_hi32, &reg->message_rwbuffer[1]);\n\t\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, \\\n\t\t\t\t\t\t\t&reg->inbound_msgaddr0);\n\t\t\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: \"\"set ccb high \\\n\t\t\t\tpart physical address timeout\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tuint32_t __iomem *rwbuffer;\n\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\treg->postq_index = 0;\n\t\treg->doneq_index = 0;\n\t\twritel(ARCMSR_MESSAGE_SET_POST_WINDOW, reg->drv2iop_doorbell);\n\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: cannot set driver mode\\n\", \\\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\trwbuffer = reg->message_rwbuffer;\n\t\t \n\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, rwbuffer++);\n\t\t \n\t\twritel(cdb_phyaddr_hi32, rwbuffer++);\n\t\t \n\t\twritel(cdb_phyaddr, rwbuffer++);\n\t\t \n\t\twritel(cdb_phyaddr + 1056, rwbuffer++);\n\t\t \n\t\twritel(1056, rwbuffer);\n\n\t\twritel(ARCMSR_MESSAGE_SET_CONFIG, reg->drv2iop_doorbell);\n\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: 'set command Q window' \\\n\t\t\ttimeout \\n\",acb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\twritel(ARCMSR_MESSAGE_START_DRIVER_MODE, reg->drv2iop_doorbell);\n\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\tpr_err(\"arcmsr%d: can't set driver mode.\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: cdb_phyaddr_hi32=0x%x\\n\",\n\t\t\t\t\tacb->adapter_index, cdb_phyaddr_hi32);\n\t\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, &reg->msgcode_rwbuffer[0]);\n\t\t\twritel(cdb_phyaddr_hi32, &reg->msgcode_rwbuffer[1]);\n\t\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, &reg->inbound_msgaddr0);\n\t\t\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\t\t\tif (!arcmsr_hbaC_wait_msgint_ready(acb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: 'set command Q window' \\\n\t\t\t\ttimeout \\n\", acb->host->host_no);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tuint32_t __iomem *rwbuffer;\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\treg->postq_index = 0;\n\t\treg->doneq_index = 0;\n\t\trwbuffer = reg->msgcode_rwbuffer;\n\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, rwbuffer++);\n\t\twritel(cdb_phyaddr_hi32, rwbuffer++);\n\t\twritel(cdb_phyaddr, rwbuffer++);\n\t\twritel(cdb_phyaddr + (ARCMSR_MAX_ARC1214_POSTQUEUE *\n\t\t\tsizeof(struct InBound_SRB)), rwbuffer++);\n\t\twritel(0x100, rwbuffer);\n\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, reg->inbound_msgaddr0);\n\t\tif (!arcmsr_hbaD_wait_msgint_ready(acb)) {\n\t\t\tpr_notice(\"arcmsr%d: 'set command Q window' timeout\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E: {\n\t\tstruct MessageUnit_E __iomem *reg = acb->pmuE;\n\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, &reg->msgcode_rwbuffer[0]);\n\t\twritel(ARCMSR_SIGNATURE_1884, &reg->msgcode_rwbuffer[1]);\n\t\twritel(cdb_phyaddr, &reg->msgcode_rwbuffer[2]);\n\t\twritel(cdb_phyaddr_hi32, &reg->msgcode_rwbuffer[3]);\n\t\twritel(acb->ccbsize, &reg->msgcode_rwbuffer[4]);\n\t\twritel(lower_32_bits(acb->dma_coherent_handle2), &reg->msgcode_rwbuffer[5]);\n\t\twritel(upper_32_bits(acb->dma_coherent_handle2), &reg->msgcode_rwbuffer[6]);\n\t\twritel(acb->ioqueue_size, &reg->msgcode_rwbuffer[7]);\n\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, &reg->inbound_msgaddr0);\n\t\tacb->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_MESSAGE_CMD_DONE;\n\t\twritel(acb->out_doorbell, &reg->iobound_doorbell);\n\t\tif (!arcmsr_hbaE_wait_msgint_ready(acb)) {\n\t\t\tpr_notice(\"arcmsr%d: 'set command Q window' timeout \\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_F: {\n\t\tstruct MessageUnit_F __iomem *reg = acb->pmuF;\n\n\t\tacb->msgcode_rwbuffer[0] = ARCMSR_SIGNATURE_SET_CONFIG;\n\t\tacb->msgcode_rwbuffer[1] = ARCMSR_SIGNATURE_1886;\n\t\tacb->msgcode_rwbuffer[2] = cdb_phyaddr;\n\t\tacb->msgcode_rwbuffer[3] = cdb_phyaddr_hi32;\n\t\tacb->msgcode_rwbuffer[4] = acb->ccbsize;\n\t\tacb->msgcode_rwbuffer[5] = lower_32_bits(acb->dma_coherent_handle2);\n\t\tacb->msgcode_rwbuffer[6] = upper_32_bits(acb->dma_coherent_handle2);\n\t\tacb->msgcode_rwbuffer[7] = acb->completeQ_size;\n\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, &reg->inbound_msgaddr0);\n\t\tacb->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_MESSAGE_CMD_DONE;\n\t\twritel(acb->out_doorbell, &reg->iobound_doorbell);\n\t\tif (!arcmsr_hbaE_wait_msgint_ready(acb)) {\n\t\t\tpr_notice(\"arcmsr%d: 'set command Q window' timeout\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void arcmsr_wait_firmware_ready(struct AdapterControlBlock *acb)\n{\n\tuint32_t firmware_state = 0;\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tdo {\n\t\t\tif (!(acb->acb_flags & ACB_F_IOP_INITED))\n\t\t\t\tmsleep(20);\n\t\t\tfirmware_state = readl(&reg->outbound_msgaddr1);\n\t\t} while ((firmware_state & ARCMSR_OUTBOUND_MESG1_FIRMWARE_OK) == 0);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\tdo {\n\t\t\tif (!(acb->acb_flags & ACB_F_IOP_INITED))\n\t\t\t\tmsleep(20);\n\t\t\tfirmware_state = readl(reg->iop2drv_doorbell);\n\t\t} while ((firmware_state & ARCMSR_MESSAGE_FIRMWARE_OK) == 0);\n\t\twritel(ARCMSR_DRV2IOP_END_OF_INTERRUPT, reg->drv2iop_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\tdo {\n\t\t\tif (!(acb->acb_flags & ACB_F_IOP_INITED))\n\t\t\t\tmsleep(20);\n\t\t\tfirmware_state = readl(&reg->outbound_msgaddr1);\n\t\t} while ((firmware_state & ARCMSR_HBCMU_MESSAGE_FIRMWARE_OK) == 0);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\tdo {\n\t\t\tif (!(acb->acb_flags & ACB_F_IOP_INITED))\n\t\t\t\tmsleep(20);\n\t\t\tfirmware_state = readl(reg->outbound_msgaddr1);\n\t\t} while ((firmware_state &\n\t\t\tARCMSR_ARC1214_MESSAGE_FIRMWARE_OK) == 0);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\tcase ACB_ADAPTER_TYPE_F: {\n\t\tstruct MessageUnit_E __iomem *reg = acb->pmuE;\n\t\tdo {\n\t\t\tif (!(acb->acb_flags & ACB_F_IOP_INITED))\n\t\t\t\tmsleep(20);\n\t\t\tfirmware_state = readl(&reg->outbound_msgaddr1);\n\t\t} while ((firmware_state & ARCMSR_HBEMU_MESSAGE_FIRMWARE_OK) == 0);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_request_device_map(struct timer_list *t)\n{\n\tstruct AdapterControlBlock *acb = from_timer(acb, t, eternal_timer);\n\tif (acb->acb_flags & (ACB_F_MSG_GET_CONFIG | ACB_F_BUS_RESET | ACB_F_ABORT)) {\n\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t} else {\n\t\tacb->fw_flag = FW_NORMAL;\n\t\tswitch (acb->adapter_type) {\n\t\tcase ACB_ADAPTER_TYPE_A: {\n\t\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\t\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase ACB_ADAPTER_TYPE_B: {\n\t\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\t\twritel(ARCMSR_MESSAGE_GET_CONFIG, reg->drv2iop_doorbell);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase ACB_ADAPTER_TYPE_C: {\n\t\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\t\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\t\t\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase ACB_ADAPTER_TYPE_D: {\n\t\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\t\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, reg->inbound_msgaddr0);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase ACB_ADAPTER_TYPE_E: {\n\t\t\tstruct MessageUnit_E __iomem *reg = acb->pmuE;\n\t\t\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\t\t\tacb->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_MESSAGE_CMD_DONE;\n\t\t\twritel(acb->out_doorbell, &reg->iobound_doorbell);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase ACB_ADAPTER_TYPE_F: {\n\t\t\tstruct MessageUnit_F __iomem *reg = acb->pmuF;\n\t\t\tuint32_t outMsg1 = readl(&reg->outbound_msgaddr1);\n\n\t\t\tif (!(outMsg1 & ARCMSR_HBFMU_MESSAGE_FIRMWARE_OK) ||\n\t\t\t\t(outMsg1 & ARCMSR_HBFMU_MESSAGE_NO_VOLUME_CHANGE))\n\t\t\t\tgoto nxt6s;\n\t\t\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\t\t\tacb->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_MESSAGE_CMD_DONE;\n\t\t\twritel(acb->out_doorbell, &reg->iobound_doorbell);\n\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tacb->acb_flags |= ACB_F_MSG_GET_CONFIG;\nnxt6s:\n\t\tmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\n\t}\n}\n\nstatic void arcmsr_hbaA_start_bgrb(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\tacb->acb_flags |= ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_START_BGRB, &reg->inbound_msgaddr0);\n\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'start adapter background \\\n\t\t\t\trebuild' timeout \\n\", acb->host->host_no);\n\t}\n}\n\nstatic void arcmsr_hbaB_start_bgrb(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tacb->acb_flags |= ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_MESSAGE_START_BGRB, reg->drv2iop_doorbell);\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'start adapter background \\\n\t\t\t\trebuild' timeout \\n\",acb->host->host_no);\n\t}\n}\n\nstatic void arcmsr_hbaC_start_bgrb(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_C __iomem *phbcmu = pACB->pmuC;\n\tpACB->acb_flags |= ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_START_BGRB, &phbcmu->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &phbcmu->inbound_doorbell);\n\tif (!arcmsr_hbaC_wait_msgint_ready(pACB)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'start adapter background \\\n\t\t\t\trebuild' timeout \\n\", pACB->host->host_no);\n\t}\n\treturn;\n}\n\nstatic void arcmsr_hbaD_start_bgrb(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_D *pmu = pACB->pmuD;\n\n\tpACB->acb_flags |= ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_START_BGRB, pmu->inbound_msgaddr0);\n\tif (!arcmsr_hbaD_wait_msgint_ready(pACB)) {\n\t\tpr_notice(\"arcmsr%d: wait 'start adapter \"\n\t\t\t\"background rebuild' timeout\\n\", pACB->host->host_no);\n\t}\n}\n\nstatic void arcmsr_hbaE_start_bgrb(struct AdapterControlBlock *pACB)\n{\n\tstruct MessageUnit_E __iomem *pmu = pACB->pmuE;\n\n\tpACB->acb_flags |= ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_INBOUND_MESG0_START_BGRB, &pmu->inbound_msgaddr0);\n\tpACB->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_MESSAGE_CMD_DONE;\n\twritel(pACB->out_doorbell, &pmu->iobound_doorbell);\n\tif (!arcmsr_hbaE_wait_msgint_ready(pACB)) {\n\t\tpr_notice(\"arcmsr%d: wait 'start adapter \"\n\t\t\t\"background rebuild' timeout \\n\", pACB->host->host_no);\n\t}\n}\n\nstatic void arcmsr_start_adapter_bgrb(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\tarcmsr_hbaA_start_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\tarcmsr_hbaB_start_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\tarcmsr_hbaC_start_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tarcmsr_hbaD_start_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\tcase ACB_ADAPTER_TYPE_F:\n\t\tarcmsr_hbaE_start_bgrb(acb);\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_clear_doorbell_queue_buffer(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\tuint32_t outbound_doorbell;\n\t\t/* empty doorbell Qbuffer if door bell ringed */\n\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t\t/*clear doorbell interrupt */\n\t\twritel(outbound_doorbell, &reg->outbound_doorbell);\n\t\twritel(ARCMSR_INBOUND_DRIVER_DATA_READ_OK, &reg->inbound_doorbell);\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\tuint32_t outbound_doorbell, i;\n\t\twritel(ARCMSR_DOORBELL_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\n\t\twritel(ARCMSR_DRV2IOP_DATA_READ_OK, reg->drv2iop_doorbell);\n\t\t/* let IOP know data has been read */\n\t\tfor(i=0; i < 200; i++) {\n\t\t\tmsleep(20);\n\t\t\toutbound_doorbell = readl(reg->iop2drv_doorbell);\n\t\t\tif( outbound_doorbell & ARCMSR_IOP2DRV_DATA_WRITE_OK) {\n\t\t\t\twritel(ARCMSR_DOORBELL_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\n\t\t\t\twritel(ARCMSR_DRV2IOP_DATA_READ_OK, reg->drv2iop_doorbell);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\tuint32_t outbound_doorbell, i;\n\t\t/* empty doorbell Qbuffer if door bell ringed */\n\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t\twritel(outbound_doorbell, &reg->outbound_doorbell_clear);\n\t\twritel(ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK, &reg->inbound_doorbell);\n\t\tfor (i = 0; i < 200; i++) {\n\t\t\tmsleep(20);\n\t\t\toutbound_doorbell = readl(&reg->outbound_doorbell);\n\t\t\tif (outbound_doorbell &\n\t\t\t\tARCMSR_HBCMU_IOP2DRV_DATA_WRITE_OK) {\n\t\t\t\twritel(outbound_doorbell,\n\t\t\t\t\t&reg->outbound_doorbell_clear);\n\t\t\t\twritel(ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK,\n\t\t\t\t\t&reg->inbound_doorbell);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\tuint32_t outbound_doorbell, i;\n\t\t/* empty doorbell Qbuffer if door bell ringed */\n\t\toutbound_doorbell = readl(reg->outbound_doorbell);\n\t\twritel(outbound_doorbell, reg->outbound_doorbell);\n\t\twritel(ARCMSR_ARC1214_DRV2IOP_DATA_OUT_READ,\n\t\t\treg->inbound_doorbell);\n\t\tfor (i = 0; i < 200; i++) {\n\t\t\tmsleep(20);\n\t\t\toutbound_doorbell = readl(reg->outbound_doorbell);\n\t\t\tif (outbound_doorbell &\n\t\t\t\tARCMSR_ARC1214_IOP2DRV_DATA_WRITE_OK) {\n\t\t\t\twritel(outbound_doorbell,\n\t\t\t\t\treg->outbound_doorbell);\n\t\t\t\twritel(ARCMSR_ARC1214_DRV2IOP_DATA_OUT_READ,\n\t\t\t\t\treg->inbound_doorbell);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\tcase ACB_ADAPTER_TYPE_F: {\n\t\tstruct MessageUnit_E __iomem *reg = acb->pmuE;\n\t\tuint32_t i, tmp;\n\n\t\tacb->in_doorbell = readl(&reg->iobound_doorbell);\n\t\twritel(0, &reg->host_int_status); /*clear interrupt*/\n\t\tacb->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_DATA_READ_OK;\n\t\twritel(acb->out_doorbell, &reg->iobound_doorbell);\n\t\tfor(i=0; i < 200; i++) {\n\t\t\tmsleep(20);\n\t\t\ttmp = acb->in_doorbell;\n\t\t\tacb->in_doorbell = readl(&reg->iobound_doorbell);\n\t\t\tif((tmp ^ acb->in_doorbell) & ARCMSR_HBEMU_IOP2DRV_DATA_WRITE_OK) {\n\t\t\t\twritel(0, &reg->host_int_status); /*clear interrupt*/\n\t\t\t\tacb->out_doorbell ^= ARCMSR_HBEMU_DRV2IOP_DATA_READ_OK;\n\t\t\t\twritel(acb->out_doorbell, &reg->iobound_doorbell);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void arcmsr_enable_eoi_mode(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\treturn;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\t{\n\t\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\t\twritel(ARCMSR_MESSAGE_ACTIVE_EOI_MODE, reg->drv2iop_doorbell);\n\t\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\t\tprintk(KERN_NOTICE \"ARCMSR IOP enables EOI_MODE TIMEOUT\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\treturn;\n\t}\n\treturn;\n}\n\nstatic void arcmsr_hardware_reset(struct AdapterControlBlock *acb)\n{\n\tuint8_t value[64];\n\tint i, count = 0;\n\tstruct MessageUnit_A __iomem *pmuA = acb->pmuA;\n\tstruct MessageUnit_C __iomem *pmuC = acb->pmuC;\n\tstruct MessageUnit_D *pmuD = acb->pmuD;\n\n\t/* backup pci config data */\n\tprintk(KERN_NOTICE \"arcmsr%d: executing hw bus reset .....\\n\", acb->host->host_no);\n\tfor (i = 0; i < 64; i++) {\n\t\tpci_read_config_byte(acb->pdev, i, &value[i]);\n\t}\n\t/* hardware reset signal */\n\tif (acb->dev_id == 0x1680) {\n\t\twritel(ARCMSR_ARC1680_BUS_RESET, &pmuA->reserved1[0]);\n\t} else if (acb->dev_id == 0x1880) {\n\t\tdo {\n\t\t\tcount++;\n\t\t\twritel(0xF, &pmuC->write_sequence);\n\t\t\twritel(0x4, &pmuC->write_sequence);\n\t\t\twritel(0xB, &pmuC->write_sequence);\n\t\t\twritel(0x2, &pmuC->write_sequence);\n\t\t\twritel(0x7, &pmuC->write_sequence);\n\t\t\twritel(0xD, &pmuC->write_sequence);\n\t\t} while (((readl(&pmuC->host_diagnostic) & ARCMSR_ARC1880_DiagWrite_ENABLE) == 0) && (count < 5));\n\t\twritel(ARCMSR_ARC1880_RESET_ADAPTER, &pmuC->host_diagnostic);\n\t} else if (acb->dev_id == 0x1884) {\n\t\tstruct MessageUnit_E __iomem *pmuE = acb->pmuE;\n\t\tdo {\n\t\t\tcount++;\n\t\t\twritel(0x4, &pmuE->write_sequence_3xxx);\n\t\t\twritel(0xB, &pmuE->write_sequence_3xxx);\n\t\t\twritel(0x2, &pmuE->write_sequence_3xxx);\n\t\t\twritel(0x7, &pmuE->write_sequence_3xxx);\n\t\t\twritel(0xD, &pmuE->write_sequence_3xxx);\n\t\t\tmdelay(10);\n\t\t} while (((readl(&pmuE->host_diagnostic_3xxx) &\n\t\t\tARCMSR_ARC1884_DiagWrite_ENABLE) == 0) && (count < 5));\n\t\twritel(ARCMSR_ARC188X_RESET_ADAPTER, &pmuE->host_diagnostic_3xxx);\n\t} else if (acb->dev_id == 0x1214) {\n\t\twritel(0x20, pmuD->reset_request);\n\t} else {\n\t\tpci_write_config_byte(acb->pdev, 0x84, 0x20);\n\t}\n\tmsleep(2000);\n\t/* write back pci config data */\n\tfor (i = 0; i < 64; i++) {\n\t\tpci_write_config_byte(acb->pdev, i, value[i]);\n\t}\n\tmsleep(1000);\n\treturn;\n}\n\nstatic bool arcmsr_reset_in_progress(struct AdapterControlBlock *acb)\n{\n\tbool rtn = true;\n\n\tswitch(acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:{\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\trtn = ((readl(&reg->outbound_msgaddr1) &\n\t\t\tARCMSR_OUTBOUND_MESG1_FIRMWARE_OK) == 0) ? true : false;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:{\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\trtn = ((readl(reg->iop2drv_doorbell) &\n\t\t\tARCMSR_MESSAGE_FIRMWARE_OK) == 0) ? true : false;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:{\n\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\t\trtn = (readl(&reg->host_diagnostic) & 0x04) ? true : false;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:{\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\trtn = ((readl(reg->sample_at_reset) & 0x80) == 0) ?\n\t\t\ttrue : false;\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_E:\n\tcase ACB_ADAPTER_TYPE_F:{\n\t\tstruct MessageUnit_E __iomem *reg = acb->pmuE;\n\t\trtn = (readl(&reg->host_diagnostic_3xxx) &\n\t\t\tARCMSR_ARC188X_RESET_ADAPTER) ? true : false;\n\t\t}\n\t\tbreak;\n\t}\n\treturn rtn;\n}\n\nstatic void arcmsr_iop_init(struct AdapterControlBlock *acb)\n{\n\tuint32_t intmask_org;\n\t/* disable all outbound interrupt */\n\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\tarcmsr_wait_firmware_ready(acb);\n\tarcmsr_iop_confirm(acb);\n\t/*start background rebuild*/\n\tarcmsr_start_adapter_bgrb(acb);\n\t/* empty doorbell Qbuffer if door bell ringed */\n\tarcmsr_clear_doorbell_queue_buffer(acb);\n\tarcmsr_enable_eoi_mode(acb);\n\t/* enable outbound Post Queue,outbound doorbell Interrupt */\n\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\tacb->acb_flags |= ACB_F_IOP_INITED;\n}\n\nstatic uint8_t arcmsr_iop_reset(struct AdapterControlBlock *acb)\n{\n\tstruct CommandControlBlock *ccb;\n\tuint32_t intmask_org;\n\tuint8_t rtnval = 0x00;\n\tint i = 0;\n\tunsigned long flags;\n\n\tif (atomic_read(&acb->ccboutstandingcount) != 0) {\n\t\t/* disable all outbound interrupt */\n\t\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\t\t/* talk to iop 331 outstanding command aborted */\n\t\trtnval = arcmsr_abort_allcmd(acb);\n\t\t/* clear all outbound posted Q */\n\t\tarcmsr_done4abort_postqueue(acb);\n\t\tfor (i = 0; i < acb->maxFreeCCB; i++) {\n\t\t\tccb = acb->pccb_pool[i];\n\t\t\tif (ccb->startdone == ARCMSR_CCB_START) {\n\t\t\t\tscsi_dma_unmap(ccb->pcmd);\n\t\t\t\tccb->startdone = ARCMSR_CCB_DONE;\n\t\t\t\tccb->ccb_flags = 0;\n\t\t\t\tspin_lock_irqsave(&acb->ccblist_lock, flags);\n\t\t\t\tlist_add_tail(&ccb->list, &acb->ccb_free_list);\n\t\t\t\tspin_unlock_irqrestore(&acb->ccblist_lock, flags);\n\t\t\t}\n\t\t}\n\t\tatomic_set(&acb->ccboutstandingcount, 0);\n\t\t/* enable all outbound interrupt */\n\t\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\t\treturn rtnval;\n\t}\n\treturn rtnval;\n}\n\nstatic int arcmsr_bus_reset(struct scsi_cmnd *cmd)\n{\n\tstruct AdapterControlBlock *acb;\n\tint retry_count = 0;\n\tint rtn = FAILED;\n\tacb = (struct AdapterControlBlock *) cmd->device->host->hostdata;\n\tif (acb->acb_flags & ACB_F_ADAPTER_REMOVED)\n\t\treturn SUCCESS;\n\tpr_notice(\"arcmsr: executing bus reset eh.....num_resets = %d,\"\n\t\t\" num_aborts = %d \\n\", acb->num_resets, acb->num_aborts);\n\tacb->num_resets++;\n\n\tif (acb->acb_flags & ACB_F_BUS_RESET) {\n\t\tlong timeout;\n\t\tpr_notice(\"arcmsr: there is a bus reset eh proceeding...\\n\");\n\t\ttimeout = wait_event_timeout(wait_q, (acb->acb_flags\n\t\t\t& ACB_F_BUS_RESET) == 0, 220 * HZ);\n\t\tif (timeout)\n\t\t\treturn SUCCESS;\n\t}\n\tacb->acb_flags |= ACB_F_BUS_RESET;\n\tif (!arcmsr_iop_reset(acb)) {\n\t\tarcmsr_hardware_reset(acb);\n\t\tacb->acb_flags &= ~ACB_F_IOP_INITED;\nwait_reset_done:\n\t\tssleep(ARCMSR_SLEEPTIME);\n\t\tif (arcmsr_reset_in_progress(acb)) {\n\t\t\tif (retry_count > ARCMSR_RETRYCOUNT) {\n\t\t\t\tacb->fw_flag = FW_DEADLOCK;\n\t\t\t\tpr_notice(\"arcmsr%d: waiting for hw bus reset\"\n\t\t\t\t\t\" return, RETRY TERMINATED!!\\n\",\n\t\t\t\t\tacb->host->host_no);\n\t\t\t\treturn FAILED;\n\t\t\t}\n\t\t\tretry_count++;\n\t\t\tgoto wait_reset_done;\n\t\t}\n\t\tarcmsr_iop_init(acb);\n\t\tacb->fw_flag = FW_NORMAL;\n\t\tmod_timer(&acb->eternal_timer, jiffies +\n\t\t\tmsecs_to_jiffies(6 * HZ));\n\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\trtn = SUCCESS;\n\t\tpr_notice(\"arcmsr: scsi bus reset eh returns with success\\n\");\n\t} else {\n\t\tacb->acb_flags &= ~ACB_F_BUS_RESET;\n\t\tacb->fw_flag = FW_NORMAL;\n\t\tmod_timer(&acb->eternal_timer, jiffies +\n\t\t\tmsecs_to_jiffies(6 * HZ));\n\t\trtn = SUCCESS;\n\t}\n\treturn rtn;\n}\n\nstatic int arcmsr_abort_one_cmd(struct AdapterControlBlock *acb,\n\t\tstruct CommandControlBlock *ccb)\n{\n\tint rtn;\n\trtn = arcmsr_polling_ccbdone(acb, ccb);\n\treturn rtn;\n}\n\nstatic int arcmsr_abort(struct scsi_cmnd *cmd)\n{\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *)cmd->device->host->hostdata;\n\tint i = 0;\n\tint rtn = FAILED;\n\tuint32_t intmask_org;\n\n\tif (acb->acb_flags & ACB_F_ADAPTER_REMOVED)\n\t\treturn SUCCESS;\n\tprintk(KERN_NOTICE\n\t\t\"arcmsr%d: abort device command of scsi id = %d lun = %d\\n\",\n\t\tacb->host->host_no, cmd->device->id, (u32)cmd->device->lun);\n\tacb->acb_flags |= ACB_F_ABORT;\n\tacb->num_aborts++;\n\t/*\n\t************************************************\n\t** the all interrupt service routine is locked\n\t** we need to handle it as soon as possible and exit\n\t************************************************\n\t*/\n\tif (!atomic_read(&acb->ccboutstandingcount)) {\n\t\tacb->acb_flags &= ~ACB_F_ABORT;\n\t\treturn rtn;\n\t}\n\n\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\tfor (i = 0; i < acb->maxFreeCCB; i++) {\n\t\tstruct CommandControlBlock *ccb = acb->pccb_pool[i];\n\t\tif (ccb->startdone == ARCMSR_CCB_START && ccb->pcmd == cmd) {\n\t\t\tccb->startdone = ARCMSR_CCB_ABORTED;\n\t\t\trtn = arcmsr_abort_one_cmd(acb, ccb);\n\t\t\tbreak;\n\t\t}\n\t}\n\tacb->acb_flags &= ~ACB_F_ABORT;\n\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\treturn rtn;\n}\n\nstatic const char *arcmsr_info(struct Scsi_Host *host)\n{\n\tstruct AdapterControlBlock *acb =\n\t\t(struct AdapterControlBlock *) host->hostdata;\n\tstatic char buf[256];\n\tchar *type;\n\tint raid6 = 1;\n\tswitch (acb->pdev->device) {\n\tcase PCI_DEVICE_ID_ARECA_1110:\n\tcase PCI_DEVICE_ID_ARECA_1200:\n\tcase PCI_DEVICE_ID_ARECA_1202:\n\tcase PCI_DEVICE_ID_ARECA_1210:\n\t\traid6 = 0;\n\t\tfallthrough;\n\tcase PCI_DEVICE_ID_ARECA_1120:\n\tcase PCI_DEVICE_ID_ARECA_1130:\n\tcase PCI_DEVICE_ID_ARECA_1160:\n\tcase PCI_DEVICE_ID_ARECA_1170:\n\tcase PCI_DEVICE_ID_ARECA_1201:\n\tcase PCI_DEVICE_ID_ARECA_1203:\n\tcase PCI_DEVICE_ID_ARECA_1220:\n\tcase PCI_DEVICE_ID_ARECA_1230:\n\tcase PCI_DEVICE_ID_ARECA_1260:\n\tcase PCI_DEVICE_ID_ARECA_1270:\n\tcase PCI_DEVICE_ID_ARECA_1280:\n\t\ttype = \"SATA\";\n\t\tbreak;\n\tcase PCI_DEVICE_ID_ARECA_1214:\n\tcase PCI_DEVICE_ID_ARECA_1380:\n\tcase PCI_DEVICE_ID_ARECA_1381:\n\tcase PCI_DEVICE_ID_ARECA_1680:\n\tcase PCI_DEVICE_ID_ARECA_1681:\n\tcase PCI_DEVICE_ID_ARECA_1880:\n\tcase PCI_DEVICE_ID_ARECA_1884:\n\t\ttype = \"SAS/SATA\";\n\t\tbreak;\n\tcase PCI_DEVICE_ID_ARECA_1886:\n\t\ttype = \"NVMe/SAS/SATA\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"unknown\";\n\t\traid6 =\t0;\n\t\tbreak;\n\t}\n\tsprintf(buf, \"Areca %s RAID Controller %s\\narcmsr version %s\\n\",\n\t\ttype, raid6 ? \"(RAID6 capable)\" : \"\", ARCMSR_DRIVER_VERSION);\n\treturn buf;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}