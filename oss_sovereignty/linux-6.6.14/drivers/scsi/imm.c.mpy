{
  "module_name": "imm.c",
  "hash_id": "5ae21f69ef4ab062a8e113ac9bec9cdc218794e5c273c6b1a927133d9063a4a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/imm.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/parport.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n\n \n#define IMM_PROBE_SPP   0x0001\n#define IMM_PROBE_PS2   0x0002\n#define IMM_PROBE_ECR   0x0010\n#define IMM_PROBE_EPP17 0x0100\n#define IMM_PROBE_EPP19 0x0200\n\n\ntypedef struct {\n\tstruct pardevice *dev;\t \n\tint base;\t\t \n\tint base_hi;\t\t \n\tint mode;\t\t \n\tstruct scsi_cmnd *cur_cmd;\t \n\tstruct delayed_work imm_tq;\t \n\tunsigned long jstart;\t \n\tunsigned failed:1;\t \n\tunsigned dp:1;\t\t \n\tunsigned rd:1;\t\t \n\tunsigned wanted:1;\t \n\tunsigned int dev_no;\t \n\twait_queue_head_t *waiting;\n\tstruct Scsi_Host *host;\n\tstruct list_head list;\n} imm_struct;\n\nstatic void imm_reset_pulse(unsigned int base);\nstatic int device_check(imm_struct *dev);\n\n#include \"imm.h\"\n\nstatic inline imm_struct *imm_dev(struct Scsi_Host *host)\n{\n\treturn *(imm_struct **)&host->hostdata;\n}\n\nstatic DEFINE_SPINLOCK(arbitration_lock);\n\nstatic void got_it(imm_struct *dev)\n{\n\tdev->base = dev->dev->port->base;\n\tif (dev->cur_cmd)\n\t\timm_scsi_pointer(dev->cur_cmd)->phase = 1;\n\telse\n\t\twake_up(dev->waiting);\n}\n\nstatic void imm_wakeup(void *ref)\n{\n\timm_struct *dev = (imm_struct *) ref;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&arbitration_lock, flags);\n\tif (dev->wanted) {\n\t\tif (parport_claim(dev->dev) == 0) {\n\t\t\tgot_it(dev);\n\t\t\tdev->wanted = 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&arbitration_lock, flags);\n}\n\nstatic int imm_pb_claim(imm_struct *dev)\n{\n\tunsigned long flags;\n\tint res = 1;\n\tspin_lock_irqsave(&arbitration_lock, flags);\n\tif (parport_claim(dev->dev) == 0) {\n\t\tgot_it(dev);\n\t\tres = 0;\n\t}\n\tdev->wanted = res;\n\tspin_unlock_irqrestore(&arbitration_lock, flags);\n\treturn res;\n}\n\nstatic void imm_pb_dismiss(imm_struct *dev)\n{\n\tunsigned long flags;\n\tint wanted;\n\tspin_lock_irqsave(&arbitration_lock, flags);\n\twanted = dev->wanted;\n\tdev->wanted = 0;\n\tspin_unlock_irqrestore(&arbitration_lock, flags);\n\tif (!wanted)\n\t\tparport_release(dev->dev);\n}\n\nstatic inline void imm_pb_release(imm_struct *dev)\n{\n\tparport_release(dev->dev);\n}\n\n \nstatic int imm_write_info(struct Scsi_Host *host, char *buffer, int length)\n{\n\timm_struct *dev = imm_dev(host);\n\n\tif ((length > 5) && (strncmp(buffer, \"mode=\", 5) == 0)) {\n\t\tdev->mode = simple_strtoul(buffer + 5, NULL, 0);\n\t\treturn length;\n\t}\n\tprintk(\"imm /proc: invalid variable\\n\");\n\treturn -EINVAL;\n}\n\nstatic int imm_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\timm_struct *dev = imm_dev(host);\n\n\tseq_printf(m, \"Version : %s\\n\", IMM_VERSION);\n\tseq_printf(m, \"Parport : %s\\n\", dev->dev->port->name);\n\tseq_printf(m, \"Mode    : %s\\n\", IMM_MODE_STRING[dev->mode]);\n\treturn 0;\n}\n\n#if IMM_DEBUG > 0\n#define imm_fail(x,y) printk(\"imm: imm_fail(%i) from %s at line %d\\n\",\\\n\t   y, __func__, __LINE__); imm_fail_func(x,y);\nstatic inline void\nimm_fail_func(imm_struct *dev, int error_code)\n#else\nstatic inline void\nimm_fail(imm_struct *dev, int error_code)\n#endif\n{\n\t \n\tif (dev->cur_cmd) {\n\t\tdev->cur_cmd->result = error_code << 16;\n\t\tdev->failed = 1;\n\t}\n}\n\n \nstatic unsigned char imm_wait(imm_struct *dev)\n{\n\tint k;\n\tunsigned short ppb = dev->base;\n\tunsigned char r;\n\n\tw_ctr(ppb, 0x0c);\n\n\tk = IMM_SPIN_TMO;\n\tdo {\n\t\tr = r_str(ppb);\n\t\tk--;\n\t\tudelay(1);\n\t}\n\twhile (!(r & 0x80) && (k));\n\n\t \n\tw_ctr(ppb, 0x04);\n\tif (k)\n\t\treturn (r & 0xb8);\n\n\t \n\timm_fail(dev, DID_TIME_OUT);\n\tprintk(\"imm timeout in imm_wait\\n\");\n\treturn 0;\t\t \n}\n\nstatic int imm_negotiate(imm_struct * tmp)\n{\n\t \n\n\tunsigned short base = tmp->base;\n\tunsigned char a, mode;\n\n\tswitch (tmp->mode) {\n\tcase IMM_NIBBLE:\n\t\tmode = 0x00;\n\t\tbreak;\n\tcase IMM_PS2:\n\t\tmode = 0x01;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tw_ctr(base, 0x04);\n\tudelay(5);\n\tw_dtr(base, mode);\n\tudelay(100);\n\tw_ctr(base, 0x06);\n\tudelay(5);\n\ta = (r_str(base) & 0x20) ? 0 : 1;\n\tudelay(5);\n\tw_ctr(base, 0x07);\n\tudelay(5);\n\tw_ctr(base, 0x06);\n\n\tif (a) {\n\t\tprintk\n\t\t    (\"IMM: IEEE1284 negotiate indicates no data available.\\n\");\n\t\timm_fail(tmp, DID_ERROR);\n\t}\n\treturn a;\n}\n\n \nstatic inline void epp_reset(unsigned short ppb)\n{\n\tint i;\n\n\ti = r_str(ppb);\n\tw_str(ppb, i);\n\tw_str(ppb, i & 0xfe);\n}\n\n \nstatic inline void ecp_sync(imm_struct *dev)\n{\n\tint i, ppb_hi = dev->base_hi;\n\n\tif (ppb_hi == 0)\n\t\treturn;\n\n\tif ((r_ecr(ppb_hi) & 0xe0) == 0x60) {\t \n\t\tfor (i = 0; i < 100; i++) {\n\t\t\tif (r_ecr(ppb_hi) & 0x01)\n\t\t\t\treturn;\n\t\t\tudelay(5);\n\t\t}\n\t\tprintk(\"imm: ECP sync failed as data still present in FIFO.\\n\");\n\t}\n}\n\nstatic int imm_byte_out(unsigned short base, const char *buffer, int len)\n{\n\tint i;\n\n\tw_ctr(base, 0x4);\t \n\tfor (i = len >> 1; i; i--) {\n\t\tw_dtr(base, *buffer++);\n\t\tw_ctr(base, 0x5);\t \n\t\tw_dtr(base, *buffer++);\n\t\tw_ctr(base, 0x0);\t \n\t}\n\tw_ctr(base, 0x4);\t \n\treturn 1;\t\t \n}\n\nstatic int imm_nibble_in(unsigned short base, char *buffer, int len)\n{\n\tunsigned char l;\n\tint i;\n\n\t \n\tw_ctr(base, 0x4);\n\tfor (i = len; i; i--) {\n\t\tw_ctr(base, 0x6);\n\t\tl = (r_str(base) & 0xf0) >> 4;\n\t\tw_ctr(base, 0x5);\n\t\t*buffer++ = (r_str(base) & 0xf0) | l;\n\t\tw_ctr(base, 0x4);\n\t}\n\treturn 1;\t\t \n}\n\nstatic int imm_byte_in(unsigned short base, char *buffer, int len)\n{\n\tint i;\n\n\t \n\tw_ctr(base, 0x4);\n\tfor (i = len; i; i--) {\n\t\tw_ctr(base, 0x26);\n\t\t*buffer++ = r_dtr(base);\n\t\tw_ctr(base, 0x25);\n\t}\n\treturn 1;\t\t \n}\n\nstatic int imm_out(imm_struct *dev, char *buffer, int len)\n{\n\tunsigned short ppb = dev->base;\n\tint r = imm_wait(dev);\n\n\t \n\tif ((r & 0x18) != 0x08) {\n\t\timm_fail(dev, DID_ERROR);\n\t\tprintk(\"IMM: returned SCSI status %2x\\n\", r);\n\t\treturn 0;\n\t}\n\tswitch (dev->mode) {\n\tcase IMM_EPP_32:\n\tcase IMM_EPP_16:\n\tcase IMM_EPP_8:\n\t\tepp_reset(ppb);\n\t\tw_ctr(ppb, 0x4);\n#ifdef CONFIG_SCSI_IZIP_EPP16\n\t\tif (!(((long) buffer | len) & 0x01))\n\t\t\toutsw(ppb + 4, buffer, len >> 1);\n#else\n\t\tif (!(((long) buffer | len) & 0x03))\n\t\t\toutsl(ppb + 4, buffer, len >> 2);\n#endif\n\t\telse\n\t\t\toutsb(ppb + 4, buffer, len);\n\t\tw_ctr(ppb, 0xc);\n\t\tr = !(r_str(ppb) & 0x01);\n\t\tw_ctr(ppb, 0xc);\n\t\tecp_sync(dev);\n\t\tbreak;\n\n\tcase IMM_NIBBLE:\n\tcase IMM_PS2:\n\t\t \n\t\tr = imm_byte_out(ppb, buffer, len);\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(\"IMM: bug in imm_out()\\n\");\n\t\tr = 0;\n\t}\n\treturn r;\n}\n\nstatic int imm_in(imm_struct *dev, char *buffer, int len)\n{\n\tunsigned short ppb = dev->base;\n\tint r = imm_wait(dev);\n\n\t \n\tif ((r & 0x18) != 0x18) {\n\t\timm_fail(dev, DID_ERROR);\n\t\treturn 0;\n\t}\n\tswitch (dev->mode) {\n\tcase IMM_NIBBLE:\n\t\t \n\t\tr = imm_nibble_in(ppb, buffer, len);\n\t\tw_ctr(ppb, 0xc);\n\t\tbreak;\n\n\tcase IMM_PS2:\n\t\t \n\t\tr = imm_byte_in(ppb, buffer, len);\n\t\tw_ctr(ppb, 0xc);\n\t\tbreak;\n\n\tcase IMM_EPP_32:\n\tcase IMM_EPP_16:\n\tcase IMM_EPP_8:\n\t\tepp_reset(ppb);\n\t\tw_ctr(ppb, 0x24);\n#ifdef CONFIG_SCSI_IZIP_EPP16\n\t\tif (!(((long) buffer | len) & 0x01))\n\t\t\tinsw(ppb + 4, buffer, len >> 1);\n#else\n\t\tif (!(((long) buffer | len) & 0x03))\n\t\t\tinsl(ppb + 4, buffer, len >> 2);\n#endif\n\t\telse\n\t\t\tinsb(ppb + 4, buffer, len);\n\t\tw_ctr(ppb, 0x2c);\n\t\tr = !(r_str(ppb) & 0x01);\n\t\tw_ctr(ppb, 0x2c);\n\t\tecp_sync(dev);\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(\"IMM: bug in imm_ins()\\n\");\n\t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n}\n\nstatic int imm_cpp(unsigned short ppb, unsigned char b)\n{\n\t \n\n\tunsigned char s1, s2, s3;\n\tw_ctr(ppb, 0x0c);\n\tudelay(2);\t\t \n\tw_dtr(ppb, 0xaa);\n\tudelay(10);\t\t \n\tw_dtr(ppb, 0x55);\n\tudelay(10);\t\t \n\tw_dtr(ppb, 0x00);\n\tudelay(10);\t\t \n\tw_dtr(ppb, 0xff);\n\tudelay(10);\t\t \n\ts1 = r_str(ppb) & 0xb8;\n\tw_dtr(ppb, 0x87);\n\tudelay(10);\t\t \n\ts2 = r_str(ppb) & 0xb8;\n\tw_dtr(ppb, 0x78);\n\tudelay(10);\t\t \n\ts3 = r_str(ppb) & 0x38;\n\t \n\tw_dtr(ppb, b);\n\tudelay(2);\t\t \n\tw_ctr(ppb, 0x0c);\n\tudelay(10);\t\t \n\tw_ctr(ppb, 0x0d);\n\tudelay(2);\t\t \n\tw_ctr(ppb, 0x0c);\n\tudelay(10);\t\t \n\tw_dtr(ppb, 0xff);\n\tudelay(10);\t\t \n\n\t \n\tif ((s1 == 0xb8) && (s2 == 0x18) && (s3 == 0x30))\n\t\treturn 1;\t \n\tif ((s1 == 0xb8) && (s2 == 0x18) && (s3 == 0x38))\n\t\treturn 0;\t \n\n\treturn -1;\t\t \n}\n\nstatic inline int imm_connect(imm_struct *dev, int flag)\n{\n\tunsigned short ppb = dev->base;\n\n\timm_cpp(ppb, 0xe0);\t \n\timm_cpp(ppb, 0x30);\t \n\n\tif ((dev->mode == IMM_EPP_8) ||\n\t    (dev->mode == IMM_EPP_16) ||\n\t    (dev->mode == IMM_EPP_32))\n\t\treturn imm_cpp(ppb, 0x28);\t \n\treturn imm_cpp(ppb, 0xe0);\t \n}\n\nstatic void imm_disconnect(imm_struct *dev)\n{\n\timm_cpp(dev->base, 0x30);\t \n}\n\nstatic int imm_select(imm_struct *dev, int target)\n{\n\tint k;\n\tunsigned short ppb = dev->base;\n\n\t \n\tw_ctr(ppb, 0xc);\n\n\tk = IMM_SELECT_TMO;\n\tdo {\n\t\tk--;\n\t} while ((r_str(ppb) & 0x08) && (k));\n\n\tif (!k)\n\t\treturn 0;\n\n\t \n\tw_ctr(ppb, 0x4);\n\tw_dtr(ppb, 0x80 | (1 << target));\n\tudelay(1);\n\n\t \n\tw_ctr(ppb, 0xc);\n\tw_ctr(ppb, 0xd);\n\n\t \n\tk = IMM_SELECT_TMO;\n\tdo {\n\t\tk--;\n\t}\n\twhile (!(r_str(ppb) & 0x08) && (k));\n\n\t \n\tw_ctr(ppb, 0xc);\n\treturn (k) ? 1 : 0;\n}\n\nstatic int imm_init(imm_struct *dev)\n{\n\tif (imm_connect(dev, 0) != 1)\n\t\treturn -EIO;\n\timm_reset_pulse(dev->base);\n\tmdelay(1);\t \n\timm_disconnect(dev);\n\tmdelay(1);\t \n\treturn device_check(dev);\n}\n\nstatic inline int imm_send_command(struct scsi_cmnd *cmd)\n{\n\timm_struct *dev = imm_dev(cmd->device->host);\n\tint k;\n\n\t \n\tfor (k = 0; k < cmd->cmd_len; k += 2)\n\t\tif (!imm_out(dev, &cmd->cmnd[k], 2))\n\t\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int imm_completion(struct scsi_cmnd *const cmd)\n{\n\t \n\tstruct scsi_pointer *scsi_pointer = imm_scsi_pointer(cmd);\n\timm_struct *dev = imm_dev(cmd->device->host);\n\tunsigned short ppb = dev->base;\n\tunsigned long start_jiffies = jiffies;\n\n\tunsigned char r, v;\n\tint fast, bulk, status;\n\n\tv = cmd->cmnd[0];\n\tbulk = ((v == READ_6) ||\n\t\t(v == READ_10) || (v == WRITE_6) || (v == WRITE_10));\n\n\t \n\tw_ctr(ppb, 0x0c);\n\tr = (r_str(ppb) & 0xb8);\n\n\t \n\twhile (r != (unsigned char) 0xb8) {\n\t\t \n\t\tif (time_after(jiffies, start_jiffies + 1))\n\t\t\treturn 0;\n\n\t\t \n\t\tif ((r & 0x88) != 0x88 || scsi_pointer->this_residual <= 0) {\n\t\t\timm_fail(dev, DID_ERROR);\n\t\t\treturn -1;\t \n\t\t}\n\t\t \n\t\tif (dev->rd == 0) {\n\t\t\tfast = bulk && scsi_pointer->this_residual >=\n\t\t\t\tIMM_BURST_SIZE ? IMM_BURST_SIZE : 2;\n\t\t\tstatus = imm_out(dev, scsi_pointer->ptr, fast);\n\t\t} else {\n\t\t\tfast = bulk && scsi_pointer->this_residual >=\n\t\t\t\tIMM_BURST_SIZE ? IMM_BURST_SIZE : 1;\n\t\t\tstatus = imm_in(dev, scsi_pointer->ptr, fast);\n\t\t}\n\n\t\tscsi_pointer->ptr += fast;\n\t\tscsi_pointer->this_residual -= fast;\n\n\t\tif (!status) {\n\t\t\timm_fail(dev, DID_BUS_BUSY);\n\t\t\treturn -1;\t \n\t\t}\n\t\tif (scsi_pointer->buffer && !scsi_pointer->this_residual) {\n\t\t\t \n\t\t\tif (scsi_pointer->buffers_residual--) {\n\t\t\t\tscsi_pointer->buffer =\n\t\t\t\t\tsg_next(scsi_pointer->buffer);\n\t\t\t\tscsi_pointer->this_residual =\n\t\t\t\t    scsi_pointer->buffer->length;\n\t\t\t\tscsi_pointer->ptr = sg_virt(scsi_pointer->buffer);\n\n\t\t\t\t \n\t\t\t\tif (scsi_pointer->this_residual & 0x01)\n\t\t\t\t\tscsi_pointer->this_residual++;\n\t\t\t}\n\t\t}\n\t\t \n\t\tw_ctr(ppb, 0x0c);\n\t\tr = (r_str(ppb) & 0xb8);\n\n\t\t \n\t\tif (!(r & 0x80))\n\t\t\treturn 0;\n\t}\n\treturn 1;\t\t \n}\n\n \nstatic void imm_interrupt(struct work_struct *work)\n{\n\timm_struct *dev = container_of(work, imm_struct, imm_tq.work);\n\tstruct scsi_cmnd *cmd = dev->cur_cmd;\n\tstruct Scsi_Host *host = cmd->device->host;\n\tunsigned long flags;\n\n\tif (imm_engine(dev, cmd)) {\n\t\tschedule_delayed_work(&dev->imm_tq, 1);\n\t\treturn;\n\t}\n\t \n#if IMM_DEBUG > 0\n\tswitch ((cmd->result >> 16) & 0xff) {\n\tcase DID_OK:\n\t\tbreak;\n\tcase DID_NO_CONNECT:\n\t\tprintk(\"imm: no device at SCSI ID %i\\n\", cmd->device->id);\n\t\tbreak;\n\tcase DID_BUS_BUSY:\n\t\tprintk(\"imm: BUS BUSY - EPP timeout detected\\n\");\n\t\tbreak;\n\tcase DID_TIME_OUT:\n\t\tprintk(\"imm: unknown timeout\\n\");\n\t\tbreak;\n\tcase DID_ABORT:\n\t\tprintk(\"imm: told to abort\\n\");\n\t\tbreak;\n\tcase DID_PARITY:\n\t\tprintk(\"imm: parity error (???)\\n\");\n\t\tbreak;\n\tcase DID_ERROR:\n\t\tprintk(\"imm: internal driver error\\n\");\n\t\tbreak;\n\tcase DID_RESET:\n\t\tprintk(\"imm: told to reset device\\n\");\n\t\tbreak;\n\tcase DID_BAD_INTR:\n\t\tprintk(\"imm: bad interrupt (???)\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"imm: bad return code (%02x)\\n\",\n\t\t       (cmd->result >> 16) & 0xff);\n\t}\n#endif\n\n\tif (imm_scsi_pointer(cmd)->phase > 1)\n\t\timm_disconnect(dev);\n\n\timm_pb_dismiss(dev);\n\n\tspin_lock_irqsave(host->host_lock, flags);\n\tdev->cur_cmd = NULL;\n\tscsi_done(cmd);\n\tspin_unlock_irqrestore(host->host_lock, flags);\n\treturn;\n}\n\nstatic int imm_engine(imm_struct *dev, struct scsi_cmnd *const cmd)\n{\n\tstruct scsi_pointer *scsi_pointer = imm_scsi_pointer(cmd);\n\tunsigned short ppb = dev->base;\n\tunsigned char l = 0, h = 0;\n\tint retv, x;\n\n\t \n\tif (dev->failed)\n\t\treturn 0;\n\n\tswitch (scsi_pointer->phase) {\n\tcase 0:\t\t \n\t\tif (time_after(jiffies, dev->jstart + HZ)) {\n\t\t\t \n\t\t\timm_fail(dev, DID_BUS_BUSY);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\t \n\n\tcase 1:\t\t \n\t\timm_connect(dev, CONNECT_EPP_MAYBE);\n\t\tscsi_pointer->phase++;\n\t\tfallthrough;\n\n\tcase 2:\t\t \n\t\tif (!imm_select(dev, scmd_id(cmd))) {\n\t\t\timm_fail(dev, DID_NO_CONNECT);\n\t\t\treturn 0;\n\t\t}\n\t\tscsi_pointer->phase++;\n\t\tfallthrough;\n\n\tcase 3:\t\t \n\t\tw_ctr(ppb, 0x0c);\n\t\tif (!(r_str(ppb) & 0x80))\n\t\t\treturn 1;\n\n\t\tif (!imm_send_command(cmd))\n\t\t\treturn 0;\n\t\tscsi_pointer->phase++;\n\t\tfallthrough;\n\n\tcase 4:\t\t \n\t\tif (scsi_bufflen(cmd)) {\n\t\t\tscsi_pointer->buffer = scsi_sglist(cmd);\n\t\t\tscsi_pointer->this_residual = scsi_pointer->buffer->length;\n\t\t\tscsi_pointer->ptr = sg_virt(scsi_pointer->buffer);\n\t\t} else {\n\t\t\tscsi_pointer->buffer = NULL;\n\t\t\tscsi_pointer->this_residual = 0;\n\t\t\tscsi_pointer->ptr = NULL;\n\t\t}\n\t\tscsi_pointer->buffers_residual = scsi_sg_count(cmd) - 1;\n\t\tscsi_pointer->phase++;\n\t\tif (scsi_pointer->this_residual & 0x01)\n\t\t\tscsi_pointer->this_residual++;\n\t\tfallthrough;\n\n\tcase 5:\t\t \n\t\t \n\t\tw_ctr(ppb, 0x0c);\n\t\tif (!(r_str(ppb) & 0x80))\n\t\t\treturn 1;\n\n\t\t \n\t\tx = (r_str(ppb) & 0xb8);\n\t\tdev->rd = (x & 0x10) ? 1 : 0;\n\t\tdev->dp = (x & 0x20) ? 0 : 1;\n\n\t\tif ((dev->dp) && (dev->rd))\n\t\t\tif (imm_negotiate(dev))\n\t\t\t\treturn 0;\n\t\tscsi_pointer->phase++;\n\t\tfallthrough;\n\n\tcase 6:\t\t \n\t\t \n\t\tw_ctr(ppb, 0x0c);\n\t\tif (!(r_str(ppb) & 0x80))\n\t\t\treturn 1;\n\n\t\tif (dev->dp) {\n\t\t\tretv = imm_completion(cmd);\n\t\t\tif (retv == -1)\n\t\t\t\treturn 0;\n\t\t\tif (retv == 0)\n\t\t\t\treturn 1;\n\t\t}\n\t\tscsi_pointer->phase++;\n\t\tfallthrough;\n\n\tcase 7:\t\t \n\t\tif ((dev->dp) && (dev->rd)) {\n\t\t\tif ((dev->mode == IMM_NIBBLE) || (dev->mode == IMM_PS2)) {\n\t\t\t\tw_ctr(ppb, 0x4);\n\t\t\t\tw_ctr(ppb, 0xc);\n\t\t\t\tw_ctr(ppb, 0xe);\n\t\t\t\tw_ctr(ppb, 0x4);\n\t\t\t}\n\t\t}\n\t\tscsi_pointer->phase++;\n\t\tfallthrough;\n\n\tcase 8:\t\t \n\t\t \n\t\tif (imm_wait(dev) != (unsigned char) 0xb8) {\n\t\t\timm_fail(dev, DID_ERROR);\n\t\t\treturn 0;\n\t\t}\n\t\tif (imm_negotiate(dev))\n\t\t\treturn 0;\n\t\tif (imm_in(dev, &l, 1)) {\t \n\t\t\t \n\t\t\tif (imm_wait(dev) == (unsigned char) 0xb8)\n\t\t\t\timm_in(dev, &h, 1);\n\t\t\tcmd->result = (DID_OK << 16) | (l & STATUS_MASK);\n\t\t}\n\t\tif ((dev->mode == IMM_NIBBLE) || (dev->mode == IMM_PS2)) {\n\t\t\tw_ctr(ppb, 0x4);\n\t\t\tw_ctr(ppb, 0xc);\n\t\t\tw_ctr(ppb, 0xe);\n\t\t\tw_ctr(ppb, 0x4);\n\t\t}\n\t\treturn 0;\t \n\n\tdefault:\n\t\tprintk(\"imm: Invalid scsi phase\\n\");\n\t}\n\treturn 0;\n}\n\nstatic int imm_queuecommand_lck(struct scsi_cmnd *cmd)\n{\n\timm_struct *dev = imm_dev(cmd->device->host);\n\n\tif (dev->cur_cmd) {\n\t\tprintk(\"IMM: bug in imm_queuecommand\\n\");\n\t\treturn 0;\n\t}\n\tdev->failed = 0;\n\tdev->jstart = jiffies;\n\tdev->cur_cmd = cmd;\n\tcmd->result = DID_ERROR << 16;\t \n\timm_scsi_pointer(cmd)->phase = 0;\t \n\n\tschedule_delayed_work(&dev->imm_tq, 0);\n\n\timm_pb_claim(dev);\n\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(imm_queuecommand)\n\n \nstatic int imm_biosparam(struct scsi_device *sdev, struct block_device *dev,\n\t\t\t sector_t capacity, int ip[])\n{\n\tip[0] = 0x40;\n\tip[1] = 0x20;\n\tip[2] = ((unsigned long) capacity + 1) / (ip[0] * ip[1]);\n\tif (ip[2] > 1024) {\n\t\tip[0] = 0xff;\n\t\tip[1] = 0x3f;\n\t\tip[2] = ((unsigned long) capacity + 1) / (ip[0] * ip[1]);\n\t}\n\treturn 0;\n}\n\nstatic int imm_abort(struct scsi_cmnd *cmd)\n{\n\timm_struct *dev = imm_dev(cmd->device->host);\n\t \n\n\tswitch (imm_scsi_pointer(cmd)->phase) {\n\tcase 0:\t\t \n\tcase 1:\t\t \n\t\tdev->cur_cmd = NULL;\t \n\t\treturn SUCCESS;\n\tdefault:\t\t \n\t\treturn FAILED;\n\t}\n}\n\nstatic void imm_reset_pulse(unsigned int base)\n{\n\tw_ctr(base, 0x04);\n\tw_dtr(base, 0x40);\n\tudelay(1);\n\tw_ctr(base, 0x0c);\n\tw_ctr(base, 0x0d);\n\tudelay(50);\n\tw_ctr(base, 0x0c);\n\tw_ctr(base, 0x04);\n}\n\nstatic int imm_reset(struct scsi_cmnd *cmd)\n{\n\timm_struct *dev = imm_dev(cmd->device->host);\n\n\tif (imm_scsi_pointer(cmd)->phase)\n\t\timm_disconnect(dev);\n\tdev->cur_cmd = NULL;\t \n\n\timm_connect(dev, CONNECT_NORMAL);\n\timm_reset_pulse(dev->base);\n\tmdelay(1);\t\t \n\timm_disconnect(dev);\n\tmdelay(1);\t\t \n\treturn SUCCESS;\n}\n\nstatic int device_check(imm_struct *dev)\n{\n\t \n\n\tstatic char cmd[6] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tint loop, old_mode, status, k, ppb = dev->base;\n\tunsigned char l;\n\n\told_mode = dev->mode;\n\tfor (loop = 0; loop < 8; loop++) {\n\t\t \n\t\tif ((ppb & 0x0007) == 0x0000)\n\t\t\tdev->mode = IMM_EPP_32;\n\n\t      second_pass:\n\t\timm_connect(dev, CONNECT_EPP_MAYBE);\n\t\t \n\t\tif (!imm_select(dev, loop)) {\n\t\t\timm_disconnect(dev);\n\t\t\tcontinue;\n\t\t}\n\t\tprintk(\"imm: Found device at ID %i, Attempting to use %s\\n\",\n\t\t       loop, IMM_MODE_STRING[dev->mode]);\n\n\t\t \n\t\tstatus = 1;\n\t\tw_ctr(ppb, 0x0c);\n\t\tfor (l = 0; (l < 3) && (status); l++)\n\t\t\tstatus = imm_out(dev, &cmd[l << 1], 2);\n\n\t\tif (!status) {\n\t\t\timm_disconnect(dev);\n\t\t\timm_connect(dev, CONNECT_EPP_MAYBE);\n\t\t\timm_reset_pulse(dev->base);\n\t\t\tudelay(1000);\n\t\t\timm_disconnect(dev);\n\t\t\tudelay(1000);\n\t\t\tif (dev->mode == IMM_EPP_32) {\n\t\t\t\tdev->mode = old_mode;\n\t\t\t\tgoto second_pass;\n\t\t\t}\n\t\t\tprintk(\"imm: Unable to establish communication\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tw_ctr(ppb, 0x0c);\n\n\t\tk = 1000000;\t \n\t\tdo {\n\t\t\tl = r_str(ppb);\n\t\t\tk--;\n\t\t\tudelay(1);\n\t\t} while (!(l & 0x80) && (k));\n\n\t\tl &= 0xb8;\n\n\t\tif (l != 0xb8) {\n\t\t\timm_disconnect(dev);\n\t\t\timm_connect(dev, CONNECT_EPP_MAYBE);\n\t\t\timm_reset_pulse(dev->base);\n\t\t\tudelay(1000);\n\t\t\timm_disconnect(dev);\n\t\t\tudelay(1000);\n\t\t\tif (dev->mode == IMM_EPP_32) {\n\t\t\t\tdev->mode = old_mode;\n\t\t\t\tgoto second_pass;\n\t\t\t}\n\t\t\tprintk\n\t\t\t    (\"imm: Unable to establish communication\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\timm_disconnect(dev);\n\t\tprintk\n\t\t    (\"imm: Communication established at 0x%x with ID %i using %s\\n\",\n\t\t     ppb, loop, IMM_MODE_STRING[dev->mode]);\n\t\timm_connect(dev, CONNECT_EPP_MAYBE);\n\t\timm_reset_pulse(dev->base);\n\t\tudelay(1000);\n\t\timm_disconnect(dev);\n\t\tudelay(1000);\n\t\treturn 0;\n\t}\n\tprintk(\"imm: No devices found\\n\");\n\treturn -ENODEV;\n}\n\n \nstatic int imm_adjust_queue(struct scsi_device *device)\n{\n\tblk_queue_bounce_limit(device->request_queue, BLK_BOUNCE_HIGH);\n\treturn 0;\n}\n\nstatic const struct scsi_host_template imm_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.proc_name\t\t= \"imm\",\n\t.show_info\t\t= imm_show_info,\n\t.write_info\t\t= imm_write_info,\n\t.name\t\t\t= \"Iomega VPI2 (imm) interface\",\n\t.queuecommand\t\t= imm_queuecommand,\n\t.eh_abort_handler\t= imm_abort,\n\t.eh_host_reset_handler\t= imm_reset,\n\t.bios_param\t\t= imm_biosparam,\n\t.this_id\t\t= 7,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.can_queue\t\t= 1,\n\t.slave_alloc\t\t= imm_adjust_queue,\n\t.cmd_size\t\t= sizeof(struct scsi_pointer),\n};\n\n \n\nstatic LIST_HEAD(imm_hosts);\n\n \n\nstatic inline imm_struct *find_parent(void)\n{\n\timm_struct *dev, *par = NULL;\n\tunsigned int cnt = 0;\n\n\tif (list_empty(&imm_hosts))\n\t\treturn NULL;\n\n\tlist_for_each_entry(dev, &imm_hosts, list) {\n\t\tif (dev->dev_no != cnt)\n\t\t\treturn par;\n\t\tcnt++;\n\t\tpar = dev;\n\t}\n\n\treturn par;\n}\n\nstatic int __imm_attach(struct parport *pb)\n{\n\tstruct Scsi_Host *host;\n\timm_struct *dev, *temp;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(waiting);\n\tDEFINE_WAIT(wait);\n\tint ports;\n\tint modes, ppb;\n\tint err = -ENOMEM;\n\tstruct pardev_cb imm_cb;\n\n\tinit_waitqueue_head(&waiting);\n\n\tdev = kzalloc(sizeof(imm_struct), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\n\tdev->base = -1;\n\tdev->mode = IMM_AUTODETECT;\n\tINIT_LIST_HEAD(&dev->list);\n\n\ttemp = find_parent();\n\tif (temp)\n\t\tdev->dev_no = temp->dev_no + 1;\n\n\tmemset(&imm_cb, 0, sizeof(imm_cb));\n\timm_cb.private = dev;\n\timm_cb.wakeup = imm_wakeup;\n\n\tdev->dev = parport_register_dev_model(pb, \"imm\", &imm_cb, dev->dev_no);\n\tif (!dev->dev)\n\t\tgoto out;\n\n\n\t \n\terr = -EBUSY;\n\tdev->waiting = &waiting;\n\tprepare_to_wait(&waiting, &wait, TASK_UNINTERRUPTIBLE);\n\tif (imm_pb_claim(dev))\n\t\tschedule_timeout(3 * HZ);\n\tif (dev->wanted) {\n\t\tprintk(KERN_ERR \"imm%d: failed to claim parport because \"\n\t\t\t\"a pardevice is owning the port for too long \"\n\t\t\t\"time!\\n\", pb->number);\n\t\timm_pb_dismiss(dev);\n\t\tdev->waiting = NULL;\n\t\tfinish_wait(&waiting, &wait);\n\t\tgoto out1;\n\t}\n\tdev->waiting = NULL;\n\tfinish_wait(&waiting, &wait);\n\tppb = dev->base = dev->dev->port->base;\n\tdev->base_hi = dev->dev->port->base_hi;\n\tw_ctr(ppb, 0x0c);\n\tmodes = dev->dev->port->modes;\n\n\t \n\tdev->mode = IMM_NIBBLE;\n\n\tif (modes & PARPORT_MODE_TRISTATE)\n\t\tdev->mode = IMM_PS2;\n\n\t \n\n\terr = imm_init(dev);\n\n\timm_pb_release(dev);\n\n\tif (err)\n\t\tgoto out1;\n\n\t \n\tif (dev->mode == IMM_NIBBLE || dev->mode == IMM_PS2)\n\t\tports = 3;\n\telse\n\t\tports = 8;\n\n\tINIT_DELAYED_WORK(&dev->imm_tq, imm_interrupt);\n\n\terr = -ENOMEM;\n\thost = scsi_host_alloc(&imm_template, sizeof(imm_struct *));\n\tif (!host)\n\t\tgoto out1;\n\thost->io_port = pb->base;\n\thost->n_io_port = ports;\n\thost->dma_channel = -1;\n\thost->unique_id = pb->number;\n\t*(imm_struct **)&host->hostdata = dev;\n\tdev->host = host;\n\tif (!temp)\n\t\tlist_add_tail(&dev->list, &imm_hosts);\n\telse\n\t\tlist_add_tail(&dev->list, &temp->list);\n\terr = scsi_add_host(host, NULL);\n\tif (err)\n\t\tgoto out2;\n\tscsi_scan_host(host);\n\treturn 0;\n\nout2:\n\tlist_del_init(&dev->list);\n\tscsi_host_put(host);\nout1:\n\tparport_unregister_device(dev->dev);\nout:\n\tkfree(dev);\n\treturn err;\n}\n\nstatic void imm_attach(struct parport *pb)\n{\n\t__imm_attach(pb);\n}\n\nstatic void imm_detach(struct parport *pb)\n{\n\timm_struct *dev;\n\tlist_for_each_entry(dev, &imm_hosts, list) {\n\t\tif (dev->dev->port == pb) {\n\t\t\tlist_del_init(&dev->list);\n\t\t\tscsi_remove_host(dev->host);\n\t\t\tscsi_host_put(dev->host);\n\t\t\tparport_unregister_device(dev->dev);\n\t\t\tkfree(dev);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct parport_driver imm_driver = {\n\t.name\t\t= \"imm\",\n\t.match_port\t= imm_attach,\n\t.detach\t\t= imm_detach,\n\t.devmodel\t= true,\n};\nmodule_parport_driver(imm_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}