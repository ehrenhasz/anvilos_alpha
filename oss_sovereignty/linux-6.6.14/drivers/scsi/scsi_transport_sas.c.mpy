{
  "module_name": "scsi_transport_sas.c",
  "hash_id": "7019d3c22f8231d97c98c4061997dfe9988b2f2f5b73951844521c4e774be51d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_transport_sas.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/blkdev.h>\n#include <linux/bsg.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n\n#include \"scsi_sas_internal.h\"\nstruct sas_host_attrs {\n\tstruct list_head rphy_list;\n\tstruct mutex lock;\n\tstruct request_queue *q;\n\tu32 next_target_id;\n\tu32 next_expander_id;\n\tint next_port_id;\n};\n#define to_sas_host_attrs(host)\t((struct sas_host_attrs *)(host)->shost_data)\n\n\n \n#define SAS_DEVICE_ATTR(_prefix,_name,_mode,_show,_store) \\\n\tstruct device_attribute dev_attr_##_prefix##_##_name = \\\n\t__ATTR(_name,_mode,_show,_store)\n\n\n \n\n#define sas_bitfield_name_match(title, table)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\\\nget_sas_##title##_names(u32 table_key, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tchar *prefix = \"\";\t\t\t\t\t\\\n\tssize_t len = 0;\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < ARRAY_SIZE(table); i++) {\t\t\\\n\t\tif (table[i].value & table_key) {\t\t\\\n\t\t\tlen += sprintf(buf + len, \"%s%s\",\t\\\n\t\t\t\tprefix, table[i].name);\t\t\\\n\t\t\tprefix = \", \";\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tlen += sprintf(buf + len, \"\\n\");\t\t\t\\\n\treturn len;\t\t\t\t\t\t\\\n}\n\n#define sas_bitfield_name_set(title, table)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\\\nset_sas_##title##_names(u32 *table_key, const char *buf)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tssize_t len = 0;\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < ARRAY_SIZE(table); i++) {\t\t\\\n\t\tlen = strlen(table[i].name);\t\t\t\\\n\t\tif (strncmp(buf, table[i].name, len) == 0 &&\t\\\n\t\t    (buf[len] == '\\n' || buf[len] == '\\0')) {\t\\\n\t\t\t*table_key = table[i].value;\t\t\\\n\t\t\treturn 0;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\treturn -EINVAL;\t\t\t\t\t\t\\\n}\n\n#define sas_bitfield_name_search(title, table)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\\\nget_sas_##title##_names(u32 table_key, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tssize_t len = 0;\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < ARRAY_SIZE(table); i++) {\t\t\\\n\t\tif (table[i].value == table_key) {\t\t\\\n\t\t\tlen += sprintf(buf + len, \"%s\",\t\t\\\n\t\t\t\ttable[i].name);\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tlen += sprintf(buf + len, \"\\n\");\t\t\t\\\n\treturn len;\t\t\t\t\t\t\\\n}\n\nstatic struct {\n\tu32\t\tvalue;\n\tchar\t\t*name;\n} sas_device_type_names[] = {\n\t{ SAS_PHY_UNUSED,\t\t\"unused\" },\n\t{ SAS_END_DEVICE,\t\t\"end device\" },\n\t{ SAS_EDGE_EXPANDER_DEVICE,\t\"edge expander\" },\n\t{ SAS_FANOUT_EXPANDER_DEVICE,\t\"fanout expander\" },\n};\nsas_bitfield_name_search(device_type, sas_device_type_names)\n\n\nstatic struct {\n\tu32\t\tvalue;\n\tchar\t\t*name;\n} sas_protocol_names[] = {\n\t{ SAS_PROTOCOL_SATA,\t\t\"sata\" },\n\t{ SAS_PROTOCOL_SMP,\t\t\"smp\" },\n\t{ SAS_PROTOCOL_STP,\t\t\"stp\" },\n\t{ SAS_PROTOCOL_SSP,\t\t\"ssp\" },\n};\nsas_bitfield_name_match(protocol, sas_protocol_names)\n\nstatic struct {\n\tu32\t\tvalue;\n\tchar\t\t*name;\n} sas_linkspeed_names[] = {\n\t{ SAS_LINK_RATE_UNKNOWN,\t\"Unknown\" },\n\t{ SAS_PHY_DISABLED,\t\t\"Phy disabled\" },\n\t{ SAS_LINK_RATE_FAILED,\t\t\"Link Rate failed\" },\n\t{ SAS_SATA_SPINUP_HOLD,\t\t\"Spin-up hold\" },\n\t{ SAS_LINK_RATE_1_5_GBPS,\t\"1.5 Gbit\" },\n\t{ SAS_LINK_RATE_3_0_GBPS,\t\"3.0 Gbit\" },\n\t{ SAS_LINK_RATE_6_0_GBPS,\t\"6.0 Gbit\" },\n\t{ SAS_LINK_RATE_12_0_GBPS,\t\"12.0 Gbit\" },\n\t{ SAS_LINK_RATE_22_5_GBPS,\t\"22.5 Gbit\" },\n};\nsas_bitfield_name_search(linkspeed, sas_linkspeed_names)\nsas_bitfield_name_set(linkspeed, sas_linkspeed_names)\n\nstatic struct sas_end_device *sas_sdev_to_rdev(struct scsi_device *sdev)\n{\n\tstruct sas_rphy *rphy = target_to_rphy(sdev->sdev_target);\n\tstruct sas_end_device *rdev;\n\n\tBUG_ON(rphy->identify.device_type != SAS_END_DEVICE);\n\n\trdev = rphy_to_end_device(rphy);\n\treturn rdev;\n}\n\nstatic int sas_smp_dispatch(struct bsg_job *job)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(job->dev);\n\tstruct sas_rphy *rphy = NULL;\n\n\tif (!scsi_is_host_device(job->dev))\n\t\trphy = dev_to_rphy(job->dev);\n\n\tif (!job->reply_payload.payload_len) {\n\t\tdev_warn(job->dev, \"space for a smp response is missing\\n\");\n\t\tbsg_job_done(job, -EINVAL, 0);\n\t\treturn 0;\n\t}\n\n\tto_sas_internal(shost->transportt)->f->smp_handler(job, shost, rphy);\n\treturn 0;\n}\n\nstatic int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)\n{\n\tstruct request_queue *q;\n\n\tif (!to_sas_internal(shost->transportt)->f->smp_handler) {\n\t\tprintk(\"%s can't handle SMP requests\\n\", shost->hostt->name);\n\t\treturn 0;\n\t}\n\n\tif (rphy) {\n\t\tq = bsg_setup_queue(&rphy->dev, dev_name(&rphy->dev),\n\t\t\t\tsas_smp_dispatch, NULL, 0);\n\t\tif (IS_ERR(q))\n\t\t\treturn PTR_ERR(q);\n\t\trphy->q = q;\n\t} else {\n\t\tchar name[20];\n\n\t\tsnprintf(name, sizeof(name), \"sas_host%d\", shost->host_no);\n\t\tq = bsg_setup_queue(&shost->shost_gendev, name,\n\t\t\t\tsas_smp_dispatch, NULL, 0);\n\t\tif (IS_ERR(q))\n\t\t\treturn PTR_ERR(q);\n\t\tto_sas_host_attrs(shost)->q = q;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int sas_host_setup(struct transport_container *tc, struct device *dev,\n\t\t\t  struct device *cdev)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(dev);\n\tstruct sas_host_attrs *sas_host = to_sas_host_attrs(shost);\n\tstruct device *dma_dev = shost->dma_dev;\n\n\tINIT_LIST_HEAD(&sas_host->rphy_list);\n\tmutex_init(&sas_host->lock);\n\tsas_host->next_target_id = 0;\n\tsas_host->next_expander_id = 0;\n\tsas_host->next_port_id = 0;\n\n\tif (sas_bsg_initialize(shost, NULL))\n\t\tdev_printk(KERN_ERR, dev, \"fail to a bsg device %d\\n\",\n\t\t\t   shost->host_no);\n\n\tif (dma_dev->dma_mask) {\n\t\tshost->opt_sectors = min_t(unsigned int, shost->max_sectors,\n\t\t\t\tdma_opt_mapping_size(dma_dev) >> SECTOR_SHIFT);\n\t}\n\n\treturn 0;\n}\n\nstatic int sas_host_remove(struct transport_container *tc, struct device *dev,\n\t\t\t   struct device *cdev)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(dev);\n\tstruct request_queue *q = to_sas_host_attrs(shost)->q;\n\n\tbsg_remove_queue(q);\n\treturn 0;\n}\n\nstatic DECLARE_TRANSPORT_CLASS(sas_host_class,\n\t\t\"sas_host\", sas_host_setup, sas_host_remove, NULL);\n\nstatic int sas_host_match(struct attribute_container *cont,\n\t\t\t    struct device *dev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct sas_internal *i;\n\n\tif (!scsi_is_host_device(dev))\n\t\treturn 0;\n\tshost = dev_to_shost(dev);\n\n\tif (!shost->transportt)\n\t\treturn 0;\n\tif (shost->transportt->host_attrs.ac.class !=\n\t\t\t&sas_host_class.class)\n\t\treturn 0;\n\n\ti = to_sas_internal(shost->transportt);\n\treturn &i->t.host_attrs.ac == cont;\n}\n\nstatic int do_sas_phy_delete(struct device *dev, void *data)\n{\n\tint pass = (int)(unsigned long)data;\n\n\tif (pass == 0 && scsi_is_sas_port(dev))\n\t\tsas_port_delete(dev_to_sas_port(dev));\n\telse if (pass == 1 && scsi_is_sas_phy(dev))\n\t\tsas_phy_delete(dev_to_phy(dev));\n\treturn 0;\n}\n\n \nvoid sas_remove_children(struct device *dev)\n{\n\tdevice_for_each_child(dev, (void *)0, do_sas_phy_delete);\n\tdevice_for_each_child(dev, (void *)1, do_sas_phy_delete);\n}\nEXPORT_SYMBOL(sas_remove_children);\n\n \nvoid sas_remove_host(struct Scsi_Host *shost)\n{\n\tsas_remove_children(&shost->shost_gendev);\n\tscsi_remove_host(shost);\n}\nEXPORT_SYMBOL(sas_remove_host);\n\n \nu64 sas_get_address(struct scsi_device *sdev)\n{\n\tstruct sas_end_device *rdev = sas_sdev_to_rdev(sdev);\n\n\treturn rdev->rphy.identify.sas_address;\n}\nEXPORT_SYMBOL(sas_get_address);\n\n \nunsigned int\nsas_tlr_supported(struct scsi_device *sdev)\n{\n\tconst int vpd_len = 32;\n\tstruct sas_end_device *rdev = sas_sdev_to_rdev(sdev);\n\tchar *buffer = kzalloc(vpd_len, GFP_KERNEL);\n\tint ret = 0;\n\n\tif (!buffer)\n\t\tgoto out;\n\n\tif (scsi_get_vpd_page(sdev, 0x90, buffer, vpd_len))\n\t\tgoto out;\n\n\t \n\tret = buffer[12] & 0x01;\n\n out:\n\tkfree(buffer);\n\trdev->tlr_supported = ret;\n\treturn ret;\n\n}\nEXPORT_SYMBOL_GPL(sas_tlr_supported);\n\n \nvoid\nsas_disable_tlr(struct scsi_device *sdev)\n{\n\tstruct sas_end_device *rdev = sas_sdev_to_rdev(sdev);\n\n\trdev->tlr_enabled = 0;\n}\nEXPORT_SYMBOL_GPL(sas_disable_tlr);\n\n \nvoid sas_enable_tlr(struct scsi_device *sdev)\n{\n\tunsigned int tlr_supported = 0;\n\ttlr_supported  = sas_tlr_supported(sdev);\n\n\tif (tlr_supported) {\n\t\tstruct sas_end_device *rdev = sas_sdev_to_rdev(sdev);\n\n\t\trdev->tlr_enabled = 1;\n\t}\n\n\treturn;\n}\nEXPORT_SYMBOL_GPL(sas_enable_tlr);\n\nunsigned int sas_is_tlr_enabled(struct scsi_device *sdev)\n{\n\tstruct sas_end_device *rdev = sas_sdev_to_rdev(sdev);\n\treturn rdev->tlr_enabled;\n}\nEXPORT_SYMBOL_GPL(sas_is_tlr_enabled);\n\n \n\n#define sas_phy_show_simple(field, name, format_string, cast)\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_sas_phy_##name(struct device *dev, \t\t\t\t\\\n\t\t    struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct sas_phy *phy = transport_class_to_phy(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn snprintf(buf, 20, format_string, cast phy->field);\t\\\n}\n\n#define sas_phy_simple_attr(field, name, format_string, type)\t\t\\\n\tsas_phy_show_simple(field, name, format_string, (type))\t\\\nstatic DEVICE_ATTR(name, S_IRUGO, show_sas_phy_##name, NULL)\n\n#define sas_phy_show_protocol(field, name)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_sas_phy_##name(struct device *dev, \t\t\t\t\\\n\t\t    struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct sas_phy *phy = transport_class_to_phy(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!phy->field)\t\t\t\t\t\t\\\n\t\treturn snprintf(buf, 20, \"none\\n\");\t\t\t\\\n\treturn get_sas_protocol_names(phy->field, buf);\t\t\\\n}\n\n#define sas_phy_protocol_attr(field, name)\t\t\t\t\\\n\tsas_phy_show_protocol(field, name)\t\t\t\t\\\nstatic DEVICE_ATTR(name, S_IRUGO, show_sas_phy_##name, NULL)\n\n#define sas_phy_show_linkspeed(field)\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_sas_phy_##field(struct device *dev, \t\t\t\t\\\n\t\t     struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct sas_phy *phy = transport_class_to_phy(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn get_sas_linkspeed_names(phy->field, buf);\t\t\\\n}\n\n \n#define sas_phy_store_linkspeed(field)\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nstore_sas_phy_##field(struct device *dev, \t\t\t\t\\\n\t\t      struct device_attribute *attr, \t\t\t\\\n\t\t      const char *buf,\tsize_t count)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct sas_phy *phy = transport_class_to_phy(dev);\t\t\\\n\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\t\\\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\t\\\n\tu32 value;\t\t\t\t\t\t\t\\\n\tstruct sas_phy_linkrates rates = {0};\t\t\t\t\\\n\tint error;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terror = set_sas_linkspeed_names(&value, buf);\t\t\t\\\n\tif (error)\t\t\t\t\t\t\t\\\n\t\treturn error;\t\t\t\t\t\t\\\n\trates.field = value;\t\t\t\t\t\t\\\n\terror = i->f->set_phy_speed(phy, &rates);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn error ? error : count;\t\t\t\t\t\\\n}\n\n#define sas_phy_linkspeed_rw_attr(field)\t\t\t\t\\\n\tsas_phy_show_linkspeed(field)\t\t\t\t\t\\\n\tsas_phy_store_linkspeed(field)\t\t\t\t\t\\\nstatic DEVICE_ATTR(field, S_IRUGO, show_sas_phy_##field,\t\t\\\n\tstore_sas_phy_##field)\n\n#define sas_phy_linkspeed_attr(field)\t\t\t\t\t\\\n\tsas_phy_show_linkspeed(field)\t\t\t\t\t\\\nstatic DEVICE_ATTR(field, S_IRUGO, show_sas_phy_##field, NULL)\n\n\n#define sas_phy_show_linkerror(field)\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_sas_phy_##field(struct device *dev, \t\t\t\t\\\n\t\t     struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct sas_phy *phy = transport_class_to_phy(dev);\t\t\\\n\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\t\\\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\t\\\n\tint error;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terror = i->f->get_linkerrors ? i->f->get_linkerrors(phy) : 0;\t\\\n\tif (error)\t\t\t\t\t\t\t\\\n\t\treturn error;\t\t\t\t\t\t\\\n\treturn snprintf(buf, 20, \"%u\\n\", phy->field);\t\t\t\\\n}\n\n#define sas_phy_linkerror_attr(field)\t\t\t\t\t\\\n\tsas_phy_show_linkerror(field)\t\t\t\t\t\\\nstatic DEVICE_ATTR(field, S_IRUGO, show_sas_phy_##field, NULL)\n\n\nstatic ssize_t\nshow_sas_device_type(struct device *dev,\n\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct sas_phy *phy = transport_class_to_phy(dev);\n\n\tif (!phy->identify.device_type)\n\t\treturn snprintf(buf, 20, \"none\\n\");\n\treturn get_sas_device_type_names(phy->identify.device_type, buf);\n}\nstatic DEVICE_ATTR(device_type, S_IRUGO, show_sas_device_type, NULL);\n\nstatic ssize_t do_sas_phy_enable(struct device *dev,\n\t\tsize_t count, int enable)\n{\n\tstruct sas_phy *phy = transport_class_to_phy(dev);\n\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\n\tint error;\n\n\terror = i->f->phy_enable(phy, enable);\n\tif (error)\n\t\treturn error;\n\tphy->enabled = enable;\n\treturn count;\n};\n\nstatic ssize_t\nstore_sas_phy_enable(struct device *dev, struct device_attribute *attr,\n\t\t     const char *buf, size_t count)\n{\n\tif (count < 1)\n\t\treturn -EINVAL;\n\n\tswitch (buf[0]) {\n\tcase '0':\n\t\tdo_sas_phy_enable(dev, count, 0);\n\t\tbreak;\n\tcase '1':\n\t\tdo_sas_phy_enable(dev, count, 1);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t\nshow_sas_phy_enable(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct sas_phy *phy = transport_class_to_phy(dev);\n\n\treturn snprintf(buf, 20, \"%d\\n\", phy->enabled);\n}\n\nstatic DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, show_sas_phy_enable,\n\t\t\t store_sas_phy_enable);\n\nstatic ssize_t\ndo_sas_phy_reset(struct device *dev, size_t count, int hard_reset)\n{\n\tstruct sas_phy *phy = transport_class_to_phy(dev);\n\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\n\tint error;\n\n\terror = i->f->phy_reset(phy, hard_reset);\n\tif (error)\n\t\treturn error;\n\tphy->enabled = 1;\n\treturn count;\n};\n\nstatic ssize_t\nstore_sas_link_reset(struct device *dev, struct device_attribute *attr,\n\t\t     const char *buf, size_t count)\n{\n\treturn do_sas_phy_reset(dev, count, 0);\n}\nstatic DEVICE_ATTR(link_reset, S_IWUSR, NULL, store_sas_link_reset);\n\nstatic ssize_t\nstore_sas_hard_reset(struct device *dev, struct device_attribute *attr,\n\t\t     const char *buf, size_t count)\n{\n\treturn do_sas_phy_reset(dev, count, 1);\n}\nstatic DEVICE_ATTR(hard_reset, S_IWUSR, NULL, store_sas_hard_reset);\n\nsas_phy_protocol_attr(identify.initiator_port_protocols,\n\t\tinitiator_port_protocols);\nsas_phy_protocol_attr(identify.target_port_protocols,\n\t\ttarget_port_protocols);\nsas_phy_simple_attr(identify.sas_address, sas_address, \"0x%016llx\\n\",\n\t\tunsigned long long);\nsas_phy_simple_attr(identify.phy_identifier, phy_identifier, \"%d\\n\", u8);\nsas_phy_linkspeed_attr(negotiated_linkrate);\nsas_phy_linkspeed_attr(minimum_linkrate_hw);\nsas_phy_linkspeed_rw_attr(minimum_linkrate);\nsas_phy_linkspeed_attr(maximum_linkrate_hw);\nsas_phy_linkspeed_rw_attr(maximum_linkrate);\nsas_phy_linkerror_attr(invalid_dword_count);\nsas_phy_linkerror_attr(running_disparity_error_count);\nsas_phy_linkerror_attr(loss_of_dword_sync_count);\nsas_phy_linkerror_attr(phy_reset_problem_count);\n\nstatic int sas_phy_setup(struct transport_container *tc, struct device *dev,\n\t\t\t struct device *cdev)\n{\n\tstruct sas_phy *phy = dev_to_phy(dev);\n\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\n\n\tif (i->f->phy_setup)\n\t\ti->f->phy_setup(phy);\n\n\treturn 0;\n}\n\nstatic DECLARE_TRANSPORT_CLASS(sas_phy_class,\n\t\t\"sas_phy\", sas_phy_setup, NULL, NULL);\n\nstatic int sas_phy_match(struct attribute_container *cont, struct device *dev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct sas_internal *i;\n\n\tif (!scsi_is_sas_phy(dev))\n\t\treturn 0;\n\tshost = dev_to_shost(dev->parent);\n\n\tif (!shost->transportt)\n\t\treturn 0;\n\tif (shost->transportt->host_attrs.ac.class !=\n\t\t\t&sas_host_class.class)\n\t\treturn 0;\n\n\ti = to_sas_internal(shost->transportt);\n\treturn &i->phy_attr_cont.ac == cont;\n}\n\nstatic void sas_phy_release(struct device *dev)\n{\n\tstruct sas_phy *phy = dev_to_phy(dev);\n\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\n\n\tif (i->f->phy_release)\n\t\ti->f->phy_release(phy);\n\tput_device(dev->parent);\n\tkfree(phy);\n}\n\n \nstruct sas_phy *sas_phy_alloc(struct device *parent, int number)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(parent);\n\tstruct sas_phy *phy;\n\n\tphy = kzalloc(sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn NULL;\n\n\tphy->number = number;\n\tphy->enabled = 1;\n\n\tdevice_initialize(&phy->dev);\n\tphy->dev.parent = get_device(parent);\n\tphy->dev.release = sas_phy_release;\n\tINIT_LIST_HEAD(&phy->port_siblings);\n\tif (scsi_is_sas_expander_device(parent)) {\n\t\tstruct sas_rphy *rphy = dev_to_rphy(parent);\n\t\tdev_set_name(&phy->dev, \"phy-%d:%d:%d\", shost->host_no,\n\t\t\trphy->scsi_target_id, number);\n\t} else\n\t\tdev_set_name(&phy->dev, \"phy-%d:%d\", shost->host_no, number);\n\n\ttransport_setup_device(&phy->dev);\n\n\treturn phy;\n}\nEXPORT_SYMBOL(sas_phy_alloc);\n\n \nint sas_phy_add(struct sas_phy *phy)\n{\n\tint error;\n\n\terror = device_add(&phy->dev);\n\tif (error)\n\t\treturn error;\n\n\terror = transport_add_device(&phy->dev);\n\tif (error) {\n\t\tdevice_del(&phy->dev);\n\t\treturn error;\n\t}\n\ttransport_configure_device(&phy->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sas_phy_add);\n\n \nvoid sas_phy_free(struct sas_phy *phy)\n{\n\ttransport_destroy_device(&phy->dev);\n\tput_device(&phy->dev);\n}\nEXPORT_SYMBOL(sas_phy_free);\n\n \nvoid\nsas_phy_delete(struct sas_phy *phy)\n{\n\tstruct device *dev = &phy->dev;\n\n\t \n\tBUG_ON(!list_empty(&phy->port_siblings));\n\n\ttransport_remove_device(dev);\n\tdevice_del(dev);\n\ttransport_destroy_device(dev);\n\tput_device(dev);\n}\nEXPORT_SYMBOL(sas_phy_delete);\n\n \nint scsi_is_sas_phy(const struct device *dev)\n{\n\treturn dev->release == sas_phy_release;\n}\nEXPORT_SYMBOL(scsi_is_sas_phy);\n\n \n#define sas_port_show_simple(field, name, format_string, cast)\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_sas_port_##name(struct device *dev, \t\t\t\t\\\n\t\t     struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct sas_port *port = transport_class_to_sas_port(dev);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn snprintf(buf, 20, format_string, cast port->field);\t\\\n}\n\n#define sas_port_simple_attr(field, name, format_string, type)\t\t\\\n\tsas_port_show_simple(field, name, format_string, (type))\t\\\nstatic DEVICE_ATTR(name, S_IRUGO, show_sas_port_##name, NULL)\n\nsas_port_simple_attr(num_phys, num_phys, \"%d\\n\", int);\n\nstatic DECLARE_TRANSPORT_CLASS(sas_port_class,\n\t\t\t       \"sas_port\", NULL, NULL, NULL);\n\nstatic int sas_port_match(struct attribute_container *cont, struct device *dev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct sas_internal *i;\n\n\tif (!scsi_is_sas_port(dev))\n\t\treturn 0;\n\tshost = dev_to_shost(dev->parent);\n\n\tif (!shost->transportt)\n\t\treturn 0;\n\tif (shost->transportt->host_attrs.ac.class !=\n\t\t\t&sas_host_class.class)\n\t\treturn 0;\n\n\ti = to_sas_internal(shost->transportt);\n\treturn &i->port_attr_cont.ac == cont;\n}\n\n\nstatic void sas_port_release(struct device *dev)\n{\n\tstruct sas_port *port = dev_to_sas_port(dev);\n\n\tBUG_ON(!list_empty(&port->phy_list));\n\n\tput_device(dev->parent);\n\tkfree(port);\n}\n\nstatic void sas_port_create_link(struct sas_port *port,\n\t\t\t\t struct sas_phy *phy)\n{\n\tint res;\n\n\tres = sysfs_create_link(&port->dev.kobj, &phy->dev.kobj,\n\t\t\t\tdev_name(&phy->dev));\n\tif (res)\n\t\tgoto err;\n\tres = sysfs_create_link(&phy->dev.kobj, &port->dev.kobj, \"port\");\n\tif (res)\n\t\tgoto err;\n\treturn;\nerr:\n\tprintk(KERN_ERR \"%s: Cannot create port links, err=%d\\n\",\n\t       __func__, res);\n}\n\nstatic void sas_port_delete_link(struct sas_port *port,\n\t\t\t\t struct sas_phy *phy)\n{\n\tsysfs_remove_link(&port->dev.kobj, dev_name(&phy->dev));\n\tsysfs_remove_link(&phy->dev.kobj, \"port\");\n}\n\n \nstruct sas_port *sas_port_alloc(struct device *parent, int port_id)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(parent);\n\tstruct sas_port *port;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn NULL;\n\n\tport->port_identifier = port_id;\n\n\tdevice_initialize(&port->dev);\n\n\tport->dev.parent = get_device(parent);\n\tport->dev.release = sas_port_release;\n\n\tmutex_init(&port->phy_list_mutex);\n\tINIT_LIST_HEAD(&port->phy_list);\n\n\tif (scsi_is_sas_expander_device(parent)) {\n\t\tstruct sas_rphy *rphy = dev_to_rphy(parent);\n\t\tdev_set_name(&port->dev, \"port-%d:%d:%d\", shost->host_no,\n\t\t\t     rphy->scsi_target_id, port->port_identifier);\n\t} else\n\t\tdev_set_name(&port->dev, \"port-%d:%d\", shost->host_no,\n\t\t\t     port->port_identifier);\n\n\ttransport_setup_device(&port->dev);\n\n\treturn port;\n}\nEXPORT_SYMBOL(sas_port_alloc);\n\n \nstruct sas_port *sas_port_alloc_num(struct device *parent)\n{\n\tint index;\n\tstruct Scsi_Host *shost = dev_to_shost(parent);\n\tstruct sas_host_attrs *sas_host = to_sas_host_attrs(shost);\n\n\t \n\tmutex_lock(&sas_host->lock);\n\tif (scsi_is_sas_expander_device(parent)) {\n\t\tstruct sas_rphy *rphy = dev_to_rphy(parent);\n\t\tstruct sas_expander_device *exp = rphy_to_expander_device(rphy);\n\n\t\tindex = exp->next_port_id++;\n\t} else\n\t\tindex = sas_host->next_port_id++;\n\tmutex_unlock(&sas_host->lock);\n\treturn sas_port_alloc(parent, index);\n}\nEXPORT_SYMBOL(sas_port_alloc_num);\n\n \nint sas_port_add(struct sas_port *port)\n{\n\tint error;\n\n\t \n\tBUG_ON(!list_empty(&port->phy_list));\n\n\terror = device_add(&port->dev);\n\n\tif (error)\n\t\treturn error;\n\n\ttransport_add_device(&port->dev);\n\ttransport_configure_device(&port->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sas_port_add);\n\n \nvoid sas_port_free(struct sas_port *port)\n{\n\ttransport_destroy_device(&port->dev);\n\tput_device(&port->dev);\n}\nEXPORT_SYMBOL(sas_port_free);\n\n \nvoid sas_port_delete(struct sas_port *port)\n{\n\tstruct device *dev = &port->dev;\n\tstruct sas_phy *phy, *tmp_phy;\n\n\tif (port->rphy) {\n\t\tsas_rphy_delete(port->rphy);\n\t\tport->rphy = NULL;\n\t}\n\n\tmutex_lock(&port->phy_list_mutex);\n\tlist_for_each_entry_safe(phy, tmp_phy, &port->phy_list,\n\t\t\t\t port_siblings) {\n\t\tsas_port_delete_link(port, phy);\n\t\tlist_del_init(&phy->port_siblings);\n\t}\n\tmutex_unlock(&port->phy_list_mutex);\n\n\tif (port->is_backlink) {\n\t\tstruct device *parent = port->dev.parent;\n\n\t\tsysfs_remove_link(&port->dev.kobj, dev_name(parent));\n\t\tport->is_backlink = 0;\n\t}\n\n\ttransport_remove_device(dev);\n\tdevice_del(dev);\n\ttransport_destroy_device(dev);\n\tput_device(dev);\n}\nEXPORT_SYMBOL(sas_port_delete);\n\n \nint scsi_is_sas_port(const struct device *dev)\n{\n\treturn dev->release == sas_port_release;\n}\nEXPORT_SYMBOL(scsi_is_sas_port);\n\n \nstruct sas_phy *sas_port_get_phy(struct sas_port *port)\n{\n\tstruct sas_phy *phy;\n\n\tmutex_lock(&port->phy_list_mutex);\n\tif (list_empty(&port->phy_list))\n\t\tphy = NULL;\n\telse {\n\t\tstruct list_head *ent = port->phy_list.next;\n\n\t\tphy = list_entry(ent, typeof(*phy), port_siblings);\n\t\tget_device(&phy->dev);\n\t}\n\tmutex_unlock(&port->phy_list_mutex);\n\n\treturn phy;\n}\nEXPORT_SYMBOL(sas_port_get_phy);\n\n \nvoid sas_port_add_phy(struct sas_port *port, struct sas_phy *phy)\n{\n\tmutex_lock(&port->phy_list_mutex);\n\tif (unlikely(!list_empty(&phy->port_siblings))) {\n\t\t \n\t\tstruct sas_phy *tmp;\n\n\t\tlist_for_each_entry(tmp, &port->phy_list, port_siblings)\n\t\t\tif (tmp == phy)\n\t\t\t\tbreak;\n\t\t \n\t\tif (unlikely(tmp != phy)) {\n\t\t\tdev_printk(KERN_ERR, &port->dev, \"trying to add phy %s fails: it's already part of another port\\n\",\n\t\t\t\t   dev_name(&phy->dev));\n\t\t\tBUG();\n\t\t}\n\t} else {\n\t\tsas_port_create_link(port, phy);\n\t\tlist_add_tail(&phy->port_siblings, &port->phy_list);\n\t\tport->num_phys++;\n\t}\n\tmutex_unlock(&port->phy_list_mutex);\n}\nEXPORT_SYMBOL(sas_port_add_phy);\n\n \nvoid sas_port_delete_phy(struct sas_port *port, struct sas_phy *phy)\n{\n\tmutex_lock(&port->phy_list_mutex);\n\tsas_port_delete_link(port, phy);\n\tlist_del_init(&phy->port_siblings);\n\tport->num_phys--;\n\tmutex_unlock(&port->phy_list_mutex);\n}\nEXPORT_SYMBOL(sas_port_delete_phy);\n\nvoid sas_port_mark_backlink(struct sas_port *port)\n{\n\tint res;\n\tstruct device *parent = port->dev.parent->parent->parent;\n\n\tif (port->is_backlink)\n\t\treturn;\n\tport->is_backlink = 1;\n\tres = sysfs_create_link(&port->dev.kobj, &parent->kobj,\n\t\t\t\tdev_name(parent));\n\tif (res)\n\t\tgoto err;\n\treturn;\nerr:\n\tprintk(KERN_ERR \"%s: Cannot create port backlink, err=%d\\n\",\n\t       __func__, res);\n\n}\nEXPORT_SYMBOL(sas_port_mark_backlink);\n\n \n\n#define sas_rphy_show_simple(field, name, format_string, cast)\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_sas_rphy_##name(struct device *dev, \t\t\t\t\\\n\t\t     struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct sas_rphy *rphy = transport_class_to_rphy(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn snprintf(buf, 20, format_string, cast rphy->field);\t\\\n}\n\n#define sas_rphy_simple_attr(field, name, format_string, type)\t\t\\\n\tsas_rphy_show_simple(field, name, format_string, (type))\t\\\nstatic SAS_DEVICE_ATTR(rphy, name, S_IRUGO, \t\t\t\\\n\t\tshow_sas_rphy_##name, NULL)\n\n#define sas_rphy_show_protocol(field, name)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_sas_rphy_##name(struct device *dev, \t\t\t\t\\\n\t\t     struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct sas_rphy *rphy = transport_class_to_rphy(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!rphy->field)\t\t\t\t\t\\\n\t\treturn snprintf(buf, 20, \"none\\n\");\t\t\t\\\n\treturn get_sas_protocol_names(rphy->field, buf);\t\\\n}\n\n#define sas_rphy_protocol_attr(field, name)\t\t\t\t\\\n\tsas_rphy_show_protocol(field, name)\t\t\t\t\\\nstatic SAS_DEVICE_ATTR(rphy, name, S_IRUGO,\t\t\t\\\n\t\tshow_sas_rphy_##name, NULL)\n\nstatic ssize_t\nshow_sas_rphy_device_type(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct sas_rphy *rphy = transport_class_to_rphy(dev);\n\n\tif (!rphy->identify.device_type)\n\t\treturn snprintf(buf, 20, \"none\\n\");\n\treturn get_sas_device_type_names(\n\t\t\trphy->identify.device_type, buf);\n}\n\nstatic SAS_DEVICE_ATTR(rphy, device_type, S_IRUGO,\n\t\tshow_sas_rphy_device_type, NULL);\n\nstatic ssize_t\nshow_sas_rphy_enclosure_identifier(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct sas_rphy *rphy = transport_class_to_rphy(dev);\n\tstruct sas_phy *phy = dev_to_phy(rphy->dev.parent);\n\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\n\tu64 identifier;\n\tint error;\n\n\terror = i->f->get_enclosure_identifier(rphy, &identifier);\n\tif (error)\n\t\treturn error;\n\treturn sprintf(buf, \"0x%llx\\n\", (unsigned long long)identifier);\n}\n\nstatic SAS_DEVICE_ATTR(rphy, enclosure_identifier, S_IRUGO,\n\t\tshow_sas_rphy_enclosure_identifier, NULL);\n\nstatic ssize_t\nshow_sas_rphy_bay_identifier(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct sas_rphy *rphy = transport_class_to_rphy(dev);\n\tstruct sas_phy *phy = dev_to_phy(rphy->dev.parent);\n\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\n\tint val;\n\n\tval = i->f->get_bay_identifier(rphy);\n\tif (val < 0)\n\t\treturn val;\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic SAS_DEVICE_ATTR(rphy, bay_identifier, S_IRUGO,\n\t\tshow_sas_rphy_bay_identifier, NULL);\n\nsas_rphy_protocol_attr(identify.initiator_port_protocols,\n\t\tinitiator_port_protocols);\nsas_rphy_protocol_attr(identify.target_port_protocols, target_port_protocols);\nsas_rphy_simple_attr(identify.sas_address, sas_address, \"0x%016llx\\n\",\n\t\tunsigned long long);\nsas_rphy_simple_attr(identify.phy_identifier, phy_identifier, \"%d\\n\", u8);\nsas_rphy_simple_attr(scsi_target_id, scsi_target_id, \"%d\\n\", u32);\n\n \n#define BUF_SIZE 64\n\nint sas_read_port_mode_page(struct scsi_device *sdev)\n{\n\tchar *buffer = kzalloc(BUF_SIZE, GFP_KERNEL), *msdata;\n\tstruct sas_end_device *rdev = sas_sdev_to_rdev(sdev);\n\tstruct scsi_mode_data mode_data;\n\tint error;\n\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\terror = scsi_mode_sense(sdev, 1, 0x19, 0, buffer, BUF_SIZE, 30*HZ, 3,\n\t\t\t\t&mode_data, NULL);\n\n\tif (error)\n\t\tgoto out;\n\n\tmsdata = buffer +  mode_data.header_length +\n\t\tmode_data.block_descriptor_length;\n\n\tif (msdata - buffer > BUF_SIZE - 8)\n\t\tgoto out;\n\n\terror = 0;\n\n\trdev->ready_led_meaning = msdata[2] & 0x10 ? 1 : 0;\n\trdev->I_T_nexus_loss_timeout = (msdata[4] << 8) + msdata[5];\n\trdev->initiator_response_timeout = (msdata[6] << 8) + msdata[7];\n\n out:\n\tkfree(buffer);\n\treturn error;\n}\nEXPORT_SYMBOL(sas_read_port_mode_page);\n\nstatic DECLARE_TRANSPORT_CLASS(sas_end_dev_class,\n\t\t\t       \"sas_end_device\", NULL, NULL, NULL);\n\n#define sas_end_dev_show_simple(field, name, format_string, cast)\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_sas_end_dev_##name(struct device *dev, \t\t\t\t\\\n\t\t\tstruct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct sas_rphy *rphy = transport_class_to_rphy(dev);\t\t\\\n\tstruct sas_end_device *rdev = rphy_to_end_device(rphy);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn snprintf(buf, 20, format_string, cast rdev->field);\t\\\n}\n\n#define sas_end_dev_simple_attr(field, name, format_string, type)\t\\\n\tsas_end_dev_show_simple(field, name, format_string, (type))\t\\\nstatic SAS_DEVICE_ATTR(end_dev, name, S_IRUGO, \t\t\t\\\n\t\tshow_sas_end_dev_##name, NULL)\n\nsas_end_dev_simple_attr(ready_led_meaning, ready_led_meaning, \"%d\\n\", int);\nsas_end_dev_simple_attr(I_T_nexus_loss_timeout, I_T_nexus_loss_timeout,\n\t\t\t\"%d\\n\", int);\nsas_end_dev_simple_attr(initiator_response_timeout, initiator_response_timeout,\n\t\t\t\"%d\\n\", int);\nsas_end_dev_simple_attr(tlr_supported, tlr_supported,\n\t\t\t\"%d\\n\", int);\nsas_end_dev_simple_attr(tlr_enabled, tlr_enabled,\n\t\t\t\"%d\\n\", int);\n\nstatic DECLARE_TRANSPORT_CLASS(sas_expander_class,\n\t\t\t       \"sas_expander\", NULL, NULL, NULL);\n\n#define sas_expander_show_simple(field, name, format_string, cast)\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_sas_expander_##name(struct device *dev, \t\t\t\t\\\n\t\t\t struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct sas_rphy *rphy = transport_class_to_rphy(dev);\t\t\\\n\tstruct sas_expander_device *edev = rphy_to_expander_device(rphy); \\\n\t\t\t\t\t\t\t\t\t\\\n\treturn snprintf(buf, 20, format_string, cast edev->field);\t\\\n}\n\n#define sas_expander_simple_attr(field, name, format_string, type)\t\\\n\tsas_expander_show_simple(field, name, format_string, (type))\t\\\nstatic SAS_DEVICE_ATTR(expander, name, S_IRUGO, \t\t\t\\\n\t\tshow_sas_expander_##name, NULL)\n\nsas_expander_simple_attr(vendor_id, vendor_id, \"%s\\n\", char *);\nsas_expander_simple_attr(product_id, product_id, \"%s\\n\", char *);\nsas_expander_simple_attr(product_rev, product_rev, \"%s\\n\", char *);\nsas_expander_simple_attr(component_vendor_id, component_vendor_id,\n\t\t\t \"%s\\n\", char *);\nsas_expander_simple_attr(component_id, component_id, \"%u\\n\", unsigned int);\nsas_expander_simple_attr(component_revision_id, component_revision_id, \"%u\\n\",\n\t\t\t unsigned int);\nsas_expander_simple_attr(level, level, \"%d\\n\", int);\n\nstatic DECLARE_TRANSPORT_CLASS(sas_rphy_class,\n\t\t\"sas_device\", NULL, NULL, NULL);\n\nstatic int sas_rphy_match(struct attribute_container *cont, struct device *dev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct sas_internal *i;\n\n\tif (!scsi_is_sas_rphy(dev))\n\t\treturn 0;\n\tshost = dev_to_shost(dev->parent->parent);\n\n\tif (!shost->transportt)\n\t\treturn 0;\n\tif (shost->transportt->host_attrs.ac.class !=\n\t\t\t&sas_host_class.class)\n\t\treturn 0;\n\n\ti = to_sas_internal(shost->transportt);\n\treturn &i->rphy_attr_cont.ac == cont;\n}\n\nstatic int sas_end_dev_match(struct attribute_container *cont,\n\t\t\t     struct device *dev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct sas_internal *i;\n\tstruct sas_rphy *rphy;\n\n\tif (!scsi_is_sas_rphy(dev))\n\t\treturn 0;\n\tshost = dev_to_shost(dev->parent->parent);\n\trphy = dev_to_rphy(dev);\n\n\tif (!shost->transportt)\n\t\treturn 0;\n\tif (shost->transportt->host_attrs.ac.class !=\n\t\t\t&sas_host_class.class)\n\t\treturn 0;\n\n\ti = to_sas_internal(shost->transportt);\n\treturn &i->end_dev_attr_cont.ac == cont &&\n\t\trphy->identify.device_type == SAS_END_DEVICE;\n}\n\nstatic int sas_expander_match(struct attribute_container *cont,\n\t\t\t      struct device *dev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct sas_internal *i;\n\tstruct sas_rphy *rphy;\n\n\tif (!scsi_is_sas_rphy(dev))\n\t\treturn 0;\n\tshost = dev_to_shost(dev->parent->parent);\n\trphy = dev_to_rphy(dev);\n\n\tif (!shost->transportt)\n\t\treturn 0;\n\tif (shost->transportt->host_attrs.ac.class !=\n\t\t\t&sas_host_class.class)\n\t\treturn 0;\n\n\ti = to_sas_internal(shost->transportt);\n\treturn &i->expander_attr_cont.ac == cont &&\n\t\t(rphy->identify.device_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t rphy->identify.device_type == SAS_FANOUT_EXPANDER_DEVICE);\n}\n\nstatic void sas_expander_release(struct device *dev)\n{\n\tstruct sas_rphy *rphy = dev_to_rphy(dev);\n\tstruct sas_expander_device *edev = rphy_to_expander_device(rphy);\n\n\tput_device(dev->parent);\n\tkfree(edev);\n}\n\nstatic void sas_end_device_release(struct device *dev)\n{\n\tstruct sas_rphy *rphy = dev_to_rphy(dev);\n\tstruct sas_end_device *edev = rphy_to_end_device(rphy);\n\n\tput_device(dev->parent);\n\tkfree(edev);\n}\n\n \nstatic void sas_rphy_initialize(struct sas_rphy *rphy)\n{\n\tINIT_LIST_HEAD(&rphy->list);\n}\n\n \nstruct sas_rphy *sas_end_device_alloc(struct sas_port *parent)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(&parent->dev);\n\tstruct sas_end_device *rdev;\n\n\trdev = kzalloc(sizeof(*rdev), GFP_KERNEL);\n\tif (!rdev) {\n\t\treturn NULL;\n\t}\n\n\tdevice_initialize(&rdev->rphy.dev);\n\trdev->rphy.dev.parent = get_device(&parent->dev);\n\trdev->rphy.dev.release = sas_end_device_release;\n\tif (scsi_is_sas_expander_device(parent->dev.parent)) {\n\t\tstruct sas_rphy *rphy = dev_to_rphy(parent->dev.parent);\n\t\tdev_set_name(&rdev->rphy.dev, \"end_device-%d:%d:%d\",\n\t\t\t     shost->host_no, rphy->scsi_target_id,\n\t\t\t     parent->port_identifier);\n\t} else\n\t\tdev_set_name(&rdev->rphy.dev, \"end_device-%d:%d\",\n\t\t\t     shost->host_no, parent->port_identifier);\n\trdev->rphy.identify.device_type = SAS_END_DEVICE;\n\tsas_rphy_initialize(&rdev->rphy);\n\ttransport_setup_device(&rdev->rphy.dev);\n\n\treturn &rdev->rphy;\n}\nEXPORT_SYMBOL(sas_end_device_alloc);\n\n \nstruct sas_rphy *sas_expander_alloc(struct sas_port *parent,\n\t\t\t\t    enum sas_device_type type)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(&parent->dev);\n\tstruct sas_expander_device *rdev;\n\tstruct sas_host_attrs *sas_host = to_sas_host_attrs(shost);\n\n\tBUG_ON(type != SAS_EDGE_EXPANDER_DEVICE &&\n\t       type != SAS_FANOUT_EXPANDER_DEVICE);\n\n\trdev = kzalloc(sizeof(*rdev), GFP_KERNEL);\n\tif (!rdev) {\n\t\treturn NULL;\n\t}\n\n\tdevice_initialize(&rdev->rphy.dev);\n\trdev->rphy.dev.parent = get_device(&parent->dev);\n\trdev->rphy.dev.release = sas_expander_release;\n\tmutex_lock(&sas_host->lock);\n\trdev->rphy.scsi_target_id = sas_host->next_expander_id++;\n\tmutex_unlock(&sas_host->lock);\n\tdev_set_name(&rdev->rphy.dev, \"expander-%d:%d\",\n\t\t     shost->host_no, rdev->rphy.scsi_target_id);\n\trdev->rphy.identify.device_type = type;\n\tsas_rphy_initialize(&rdev->rphy);\n\ttransport_setup_device(&rdev->rphy.dev);\n\n\treturn &rdev->rphy;\n}\nEXPORT_SYMBOL(sas_expander_alloc);\n\n \nint sas_rphy_add(struct sas_rphy *rphy)\n{\n\tstruct sas_port *parent = dev_to_sas_port(rphy->dev.parent);\n\tstruct Scsi_Host *shost = dev_to_shost(parent->dev.parent);\n\tstruct sas_host_attrs *sas_host = to_sas_host_attrs(shost);\n\tstruct sas_identify *identify = &rphy->identify;\n\tint error;\n\n\tif (parent->rphy)\n\t\treturn -ENXIO;\n\tparent->rphy = rphy;\n\n\terror = device_add(&rphy->dev);\n\tif (error)\n\t\treturn error;\n\ttransport_add_device(&rphy->dev);\n\ttransport_configure_device(&rphy->dev);\n\tif (sas_bsg_initialize(shost, rphy))\n\t\tprintk(\"fail to a bsg device %s\\n\", dev_name(&rphy->dev));\n\n\n\tmutex_lock(&sas_host->lock);\n\tlist_add_tail(&rphy->list, &sas_host->rphy_list);\n\tif (identify->device_type == SAS_END_DEVICE &&\n\t    (identify->target_port_protocols &\n\t     (SAS_PROTOCOL_SSP | SAS_PROTOCOL_STP | SAS_PROTOCOL_SATA)))\n\t\trphy->scsi_target_id = sas_host->next_target_id++;\n\telse if (identify->device_type == SAS_END_DEVICE)\n\t\trphy->scsi_target_id = -1;\n\tmutex_unlock(&sas_host->lock);\n\n\tif (identify->device_type == SAS_END_DEVICE &&\n\t    rphy->scsi_target_id != -1) {\n\t\tint lun;\n\n\t\tif (identify->target_port_protocols & SAS_PROTOCOL_SSP)\n\t\t\tlun = SCAN_WILD_CARD;\n\t\telse\n\t\t\tlun = 0;\n\n\t\tscsi_scan_target(&rphy->dev, 0, rphy->scsi_target_id, lun,\n\t\t\t\t SCSI_SCAN_INITIAL);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sas_rphy_add);\n\n \nvoid sas_rphy_free(struct sas_rphy *rphy)\n{\n\tstruct device *dev = &rphy->dev;\n\tstruct Scsi_Host *shost = dev_to_shost(rphy->dev.parent->parent);\n\tstruct sas_host_attrs *sas_host = to_sas_host_attrs(shost);\n\n\tmutex_lock(&sas_host->lock);\n\tlist_del(&rphy->list);\n\tmutex_unlock(&sas_host->lock);\n\n\ttransport_destroy_device(dev);\n\n\tput_device(dev);\n}\nEXPORT_SYMBOL(sas_rphy_free);\n\n \nvoid\nsas_rphy_delete(struct sas_rphy *rphy)\n{\n\tsas_rphy_remove(rphy);\n\tsas_rphy_free(rphy);\n}\nEXPORT_SYMBOL(sas_rphy_delete);\n\n \nvoid sas_rphy_unlink(struct sas_rphy *rphy)\n{\n\tstruct sas_port *parent = dev_to_sas_port(rphy->dev.parent);\n\n\tparent->rphy = NULL;\n}\nEXPORT_SYMBOL(sas_rphy_unlink);\n\n \nvoid\nsas_rphy_remove(struct sas_rphy *rphy)\n{\n\tstruct device *dev = &rphy->dev;\n\n\tswitch (rphy->identify.device_type) {\n\tcase SAS_END_DEVICE:\n\t\tscsi_remove_target(dev);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tsas_remove_children(dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsas_rphy_unlink(rphy);\n\tbsg_remove_queue(rphy->q);\n\ttransport_remove_device(dev);\n\tdevice_del(dev);\n}\nEXPORT_SYMBOL(sas_rphy_remove);\n\n \nint scsi_is_sas_rphy(const struct device *dev)\n{\n\treturn dev->release == sas_end_device_release ||\n\t\tdev->release == sas_expander_release;\n}\nEXPORT_SYMBOL(scsi_is_sas_rphy);\n\n\n \n\nstatic int sas_user_scan(struct Scsi_Host *shost, uint channel,\n\t\tuint id, u64 lun)\n{\n\tstruct sas_host_attrs *sas_host = to_sas_host_attrs(shost);\n\tstruct sas_rphy *rphy;\n\n\tmutex_lock(&sas_host->lock);\n\tlist_for_each_entry(rphy, &sas_host->rphy_list, list) {\n\t\tif (rphy->identify.device_type != SAS_END_DEVICE ||\n\t\t    rphy->scsi_target_id == -1)\n\t\t\tcontinue;\n\n\t\tif ((channel == SCAN_WILD_CARD || channel == 0) &&\n\t\t    (id == SCAN_WILD_CARD || id == rphy->scsi_target_id)) {\n\t\t\tscsi_scan_target(&rphy->dev, 0, rphy->scsi_target_id,\n\t\t\t\t\t lun, SCSI_SCAN_MANUAL);\n\t\t}\n\t}\n\tmutex_unlock(&sas_host->lock);\n\n\treturn 0;\n}\n\n\n \n\n#define SETUP_TEMPLATE(attrb, field, perm, test)\t\t\t\\\n\ti->private_##attrb[count] = dev_attr_##field;\t\t\\\n\ti->private_##attrb[count].attr.mode = perm;\t\t\t\\\n\ti->attrb[count] = &i->private_##attrb[count];\t\t\t\\\n\tif (test)\t\t\t\t\t\t\t\\\n\t\tcount++\n\n#define SETUP_TEMPLATE_RW(attrb, field, perm, test, ro_test, ro_perm)\t\\\n\ti->private_##attrb[count] = dev_attr_##field;\t\t\\\n\ti->private_##attrb[count].attr.mode = perm;\t\t\t\\\n\tif (ro_test) {\t\t\t\t\t\t\t\\\n\t\ti->private_##attrb[count].attr.mode = ro_perm;\t\t\\\n\t\ti->private_##attrb[count].store = NULL;\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\ti->attrb[count] = &i->private_##attrb[count];\t\t\t\\\n\tif (test)\t\t\t\t\t\t\t\\\n\t\tcount++\n\n#define SETUP_RPORT_ATTRIBUTE(field) \t\t\t\t\t\\\n\tSETUP_TEMPLATE(rphy_attrs, field, S_IRUGO, 1)\n\n#define SETUP_OPTIONAL_RPORT_ATTRIBUTE(field, func)\t\t\t\\\n\tSETUP_TEMPLATE(rphy_attrs, field, S_IRUGO, i->f->func)\n\n#define SETUP_PHY_ATTRIBUTE(field)\t\t\t\t\t\\\n\tSETUP_TEMPLATE(phy_attrs, field, S_IRUGO, 1)\n\n#define SETUP_PHY_ATTRIBUTE_RW(field)\t\t\t\t\t\\\n\tSETUP_TEMPLATE_RW(phy_attrs, field, S_IRUGO | S_IWUSR, 1,\t\\\n\t\t\t!i->f->set_phy_speed, S_IRUGO)\n\n#define SETUP_OPTIONAL_PHY_ATTRIBUTE_RW(field, func)\t\t\t\\\n\tSETUP_TEMPLATE_RW(phy_attrs, field, S_IRUGO | S_IWUSR, 1,\t\\\n\t\t\t  !i->f->func, S_IRUGO)\n\n#define SETUP_PORT_ATTRIBUTE(field)\t\t\t\t\t\\\n\tSETUP_TEMPLATE(port_attrs, field, S_IRUGO, 1)\n\n#define SETUP_OPTIONAL_PHY_ATTRIBUTE(field, func)\t\t\t\\\n\tSETUP_TEMPLATE(phy_attrs, field, S_IRUGO, i->f->func)\n\n#define SETUP_PHY_ATTRIBUTE_WRONLY(field)\t\t\t\t\\\n\tSETUP_TEMPLATE(phy_attrs, field, S_IWUSR, 1)\n\n#define SETUP_OPTIONAL_PHY_ATTRIBUTE_WRONLY(field, func)\t\t\\\n\tSETUP_TEMPLATE(phy_attrs, field, S_IWUSR, i->f->func)\n\n#define SETUP_END_DEV_ATTRIBUTE(field)\t\t\t\t\t\\\n\tSETUP_TEMPLATE(end_dev_attrs, field, S_IRUGO, 1)\n\n#define SETUP_EXPANDER_ATTRIBUTE(field)\t\t\t\t\t\\\n\tSETUP_TEMPLATE(expander_attrs, expander_##field, S_IRUGO, 1)\n\n \nstruct scsi_transport_template *\nsas_attach_transport(struct sas_function_template *ft)\n{\n\tstruct sas_internal *i;\n\tint count;\n\n\ti = kzalloc(sizeof(struct sas_internal), GFP_KERNEL);\n\tif (!i)\n\t\treturn NULL;\n\n\ti->t.user_scan = sas_user_scan;\n\n\ti->t.host_attrs.ac.attrs = &i->host_attrs[0];\n\ti->t.host_attrs.ac.class = &sas_host_class.class;\n\ti->t.host_attrs.ac.match = sas_host_match;\n\ttransport_container_register(&i->t.host_attrs);\n\ti->t.host_size = sizeof(struct sas_host_attrs);\n\n\ti->phy_attr_cont.ac.class = &sas_phy_class.class;\n\ti->phy_attr_cont.ac.attrs = &i->phy_attrs[0];\n\ti->phy_attr_cont.ac.match = sas_phy_match;\n\ttransport_container_register(&i->phy_attr_cont);\n\n\ti->port_attr_cont.ac.class = &sas_port_class.class;\n\ti->port_attr_cont.ac.attrs = &i->port_attrs[0];\n\ti->port_attr_cont.ac.match = sas_port_match;\n\ttransport_container_register(&i->port_attr_cont);\n\n\ti->rphy_attr_cont.ac.class = &sas_rphy_class.class;\n\ti->rphy_attr_cont.ac.attrs = &i->rphy_attrs[0];\n\ti->rphy_attr_cont.ac.match = sas_rphy_match;\n\ttransport_container_register(&i->rphy_attr_cont);\n\n\ti->end_dev_attr_cont.ac.class = &sas_end_dev_class.class;\n\ti->end_dev_attr_cont.ac.attrs = &i->end_dev_attrs[0];\n\ti->end_dev_attr_cont.ac.match = sas_end_dev_match;\n\ttransport_container_register(&i->end_dev_attr_cont);\n\n\ti->expander_attr_cont.ac.class = &sas_expander_class.class;\n\ti->expander_attr_cont.ac.attrs = &i->expander_attrs[0];\n\ti->expander_attr_cont.ac.match = sas_expander_match;\n\ttransport_container_register(&i->expander_attr_cont);\n\n\ti->f = ft;\n\n\tcount = 0;\n\tSETUP_PHY_ATTRIBUTE(initiator_port_protocols);\n\tSETUP_PHY_ATTRIBUTE(target_port_protocols);\n\tSETUP_PHY_ATTRIBUTE(device_type);\n\tSETUP_PHY_ATTRIBUTE(sas_address);\n\tSETUP_PHY_ATTRIBUTE(phy_identifier);\n\tSETUP_PHY_ATTRIBUTE(negotiated_linkrate);\n\tSETUP_PHY_ATTRIBUTE(minimum_linkrate_hw);\n\tSETUP_PHY_ATTRIBUTE_RW(minimum_linkrate);\n\tSETUP_PHY_ATTRIBUTE(maximum_linkrate_hw);\n\tSETUP_PHY_ATTRIBUTE_RW(maximum_linkrate);\n\n\tSETUP_PHY_ATTRIBUTE(invalid_dword_count);\n\tSETUP_PHY_ATTRIBUTE(running_disparity_error_count);\n\tSETUP_PHY_ATTRIBUTE(loss_of_dword_sync_count);\n\tSETUP_PHY_ATTRIBUTE(phy_reset_problem_count);\n\tSETUP_OPTIONAL_PHY_ATTRIBUTE_WRONLY(link_reset, phy_reset);\n\tSETUP_OPTIONAL_PHY_ATTRIBUTE_WRONLY(hard_reset, phy_reset);\n\tSETUP_OPTIONAL_PHY_ATTRIBUTE_RW(enable, phy_enable);\n\ti->phy_attrs[count] = NULL;\n\n\tcount = 0;\n\tSETUP_PORT_ATTRIBUTE(num_phys);\n\ti->port_attrs[count] = NULL;\n\n\tcount = 0;\n\tSETUP_RPORT_ATTRIBUTE(rphy_initiator_port_protocols);\n\tSETUP_RPORT_ATTRIBUTE(rphy_target_port_protocols);\n\tSETUP_RPORT_ATTRIBUTE(rphy_device_type);\n\tSETUP_RPORT_ATTRIBUTE(rphy_sas_address);\n\tSETUP_RPORT_ATTRIBUTE(rphy_phy_identifier);\n\tSETUP_RPORT_ATTRIBUTE(rphy_scsi_target_id);\n\tSETUP_OPTIONAL_RPORT_ATTRIBUTE(rphy_enclosure_identifier,\n\t\t\t\t       get_enclosure_identifier);\n\tSETUP_OPTIONAL_RPORT_ATTRIBUTE(rphy_bay_identifier,\n\t\t\t\t       get_bay_identifier);\n\ti->rphy_attrs[count] = NULL;\n\n\tcount = 0;\n\tSETUP_END_DEV_ATTRIBUTE(end_dev_ready_led_meaning);\n\tSETUP_END_DEV_ATTRIBUTE(end_dev_I_T_nexus_loss_timeout);\n\tSETUP_END_DEV_ATTRIBUTE(end_dev_initiator_response_timeout);\n\tSETUP_END_DEV_ATTRIBUTE(end_dev_tlr_supported);\n\tSETUP_END_DEV_ATTRIBUTE(end_dev_tlr_enabled);\n\ti->end_dev_attrs[count] = NULL;\n\n\tcount = 0;\n\tSETUP_EXPANDER_ATTRIBUTE(vendor_id);\n\tSETUP_EXPANDER_ATTRIBUTE(product_id);\n\tSETUP_EXPANDER_ATTRIBUTE(product_rev);\n\tSETUP_EXPANDER_ATTRIBUTE(component_vendor_id);\n\tSETUP_EXPANDER_ATTRIBUTE(component_id);\n\tSETUP_EXPANDER_ATTRIBUTE(component_revision_id);\n\tSETUP_EXPANDER_ATTRIBUTE(level);\n\ti->expander_attrs[count] = NULL;\n\n\treturn &i->t;\n}\nEXPORT_SYMBOL(sas_attach_transport);\n\n \nvoid sas_release_transport(struct scsi_transport_template *t)\n{\n\tstruct sas_internal *i = to_sas_internal(t);\n\n\ttransport_container_unregister(&i->t.host_attrs);\n\ttransport_container_unregister(&i->phy_attr_cont);\n\ttransport_container_unregister(&i->port_attr_cont);\n\ttransport_container_unregister(&i->rphy_attr_cont);\n\ttransport_container_unregister(&i->end_dev_attr_cont);\n\ttransport_container_unregister(&i->expander_attr_cont);\n\n\tkfree(i);\n}\nEXPORT_SYMBOL(sas_release_transport);\n\nstatic __init int sas_transport_init(void)\n{\n\tint error;\n\n\terror = transport_class_register(&sas_host_class);\n\tif (error)\n\t\tgoto out;\n\terror = transport_class_register(&sas_phy_class);\n\tif (error)\n\t\tgoto out_unregister_transport;\n\terror = transport_class_register(&sas_port_class);\n\tif (error)\n\t\tgoto out_unregister_phy;\n\terror = transport_class_register(&sas_rphy_class);\n\tif (error)\n\t\tgoto out_unregister_port;\n\terror = transport_class_register(&sas_end_dev_class);\n\tif (error)\n\t\tgoto out_unregister_rphy;\n\terror = transport_class_register(&sas_expander_class);\n\tif (error)\n\t\tgoto out_unregister_end_dev;\n\n\treturn 0;\n\n out_unregister_end_dev:\n\ttransport_class_unregister(&sas_end_dev_class);\n out_unregister_rphy:\n\ttransport_class_unregister(&sas_rphy_class);\n out_unregister_port:\n\ttransport_class_unregister(&sas_port_class);\n out_unregister_phy:\n\ttransport_class_unregister(&sas_phy_class);\n out_unregister_transport:\n\ttransport_class_unregister(&sas_host_class);\n out:\n\treturn error;\n\n}\n\nstatic void __exit sas_transport_exit(void)\n{\n\ttransport_class_unregister(&sas_host_class);\n\ttransport_class_unregister(&sas_phy_class);\n\ttransport_class_unregister(&sas_port_class);\n\ttransport_class_unregister(&sas_rphy_class);\n\ttransport_class_unregister(&sas_end_dev_class);\n\ttransport_class_unregister(&sas_expander_class);\n}\n\nMODULE_AUTHOR(\"Christoph Hellwig\");\nMODULE_DESCRIPTION(\"SAS Transport Attributes\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(sas_transport_init);\nmodule_exit(sas_transport_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}