{
  "module_name": "mac_scsi.c",
  "hash_id": "7030e6cb4245e25ee5778728f62443d2ee567bbaae27d30532eef33e11fbc6e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mac_scsi.c",
  "human_readable_source": "\n \n \n\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n\n#include <asm/hwtest.h>\n#include <asm/io.h>\n#include <asm/macintosh.h>\n#include <asm/macints.h>\n#include <asm/setup.h>\n\n#include <scsi/scsi_host.h>\n\n \n\n#define NCR5380_implementation_fields   int pdma_residual\n\n#define NCR5380_read(reg)           in_8(hostdata->io + ((reg) << 4))\n#define NCR5380_write(reg, value)   out_8(hostdata->io + ((reg) << 4), value)\n\n#define NCR5380_dma_xfer_len            macscsi_dma_xfer_len\n#define NCR5380_dma_recv_setup          macscsi_pread\n#define NCR5380_dma_send_setup          macscsi_pwrite\n#define NCR5380_dma_residual            macscsi_dma_residual\n\n#define NCR5380_intr                    macscsi_intr\n#define NCR5380_queue_command           macscsi_queue_command\n#define NCR5380_abort                   macscsi_abort\n#define NCR5380_host_reset              macscsi_host_reset\n#define NCR5380_info                    macscsi_info\n\n#include \"NCR5380.h\"\n\nstatic int setup_can_queue = -1;\nmodule_param(setup_can_queue, int, 0);\nstatic int setup_cmd_per_lun = -1;\nmodule_param(setup_cmd_per_lun, int, 0);\nstatic int setup_sg_tablesize = -1;\nmodule_param(setup_sg_tablesize, int, 0);\nstatic int setup_use_pdma = 512;\nmodule_param(setup_use_pdma, int, 0);\nstatic int setup_hostid = -1;\nmodule_param(setup_hostid, int, 0);\nstatic int setup_toshiba_delay = -1;\nmodule_param(setup_toshiba_delay, int, 0);\n\n#ifndef MODULE\nstatic int __init mac_scsi_setup(char *str)\n{\n\tint ints[8];\n\n\t(void)get_options(str, ARRAY_SIZE(ints), ints);\n\n\tif (ints[0] < 1) {\n\t\tpr_err(\"Usage: mac5380=<can_queue>[,<cmd_per_lun>[,<sg_tablesize>[,<hostid>[,<use_tags>[,<use_pdma>[,<toshiba_delay>]]]]]]\\n\");\n\t\treturn 0;\n\t}\n\tif (ints[0] >= 1)\n\t\tsetup_can_queue = ints[1];\n\tif (ints[0] >= 2)\n\t\tsetup_cmd_per_lun = ints[2];\n\tif (ints[0] >= 3)\n\t\tsetup_sg_tablesize = ints[3];\n\tif (ints[0] >= 4)\n\t\tsetup_hostid = ints[4];\n\t \n\tif (ints[0] >= 6)\n\t\tsetup_use_pdma = ints[6];\n\tif (ints[0] >= 7)\n\t\tsetup_toshiba_delay = ints[7];\n\treturn 1;\n}\n\n__setup(\"mac5380=\", mac_scsi_setup);\n#endif  \n\n \n\n#define MOVE_BYTE(operands) \\\n\tasm volatile ( \\\n\t\t\"1:     moveb \" operands \"     \\n\" \\\n\t\t\"11:    nop                    \\n\" \\\n\t\t\"       addq #1,%0             \\n\" \\\n\t\t\"       subq #1,%1             \\n\" \\\n\t\t\"40:                           \\n\" \\\n\t\t\"                              \\n\" \\\n\t\t\".section .fixup,\\\"ax\\\"        \\n\" \\\n\t\t\".even                         \\n\" \\\n\t\t\"90:    movel #1, %2           \\n\" \\\n\t\t\"       jra 40b                \\n\" \\\n\t\t\".previous                     \\n\" \\\n\t\t\"                              \\n\" \\\n\t\t\".section __ex_table,\\\"a\\\"     \\n\" \\\n\t\t\".align  4                     \\n\" \\\n\t\t\".long   1b,90b                \\n\" \\\n\t\t\".long  11b,90b                \\n\" \\\n\t\t\".previous                     \\n\" \\\n\t\t: \"+a\" (addr), \"+r\" (n), \"+r\" (result) : \"a\" (io))\n\n \n\n#define MOVE_WORD(operands) \\\n\tasm volatile ( \\\n\t\t\"1:     movew \" operands \"     \\n\" \\\n\t\t\"11:    nop                    \\n\" \\\n\t\t\"       subq #2,%1             \\n\" \\\n\t\t\"40:                           \\n\" \\\n\t\t\"                              \\n\" \\\n\t\t\".section .fixup,\\\"ax\\\"        \\n\" \\\n\t\t\".even                         \\n\" \\\n\t\t\"90:    movel #0, %1           \\n\" \\\n\t\t\"       movel #2, %2           \\n\" \\\n\t\t\"       jra 40b                \\n\" \\\n\t\t\".previous                     \\n\" \\\n\t\t\"                              \\n\" \\\n\t\t\".section __ex_table,\\\"a\\\"     \\n\" \\\n\t\t\".align  4                     \\n\" \\\n\t\t\".long   1b,90b                \\n\" \\\n\t\t\".long  11b,90b                \\n\" \\\n\t\t\".previous                     \\n\" \\\n\t\t: \"+a\" (addr), \"+r\" (n), \"+r\" (result) : \"a\" (io))\n\n#define MOVE_16_WORDS(operands) \\\n\tasm volatile ( \\\n\t\t\"1:     movew \" operands \"     \\n\" \\\n\t\t\"2:     movew \" operands \"     \\n\" \\\n\t\t\"3:     movew \" operands \"     \\n\" \\\n\t\t\"4:     movew \" operands \"     \\n\" \\\n\t\t\"5:     movew \" operands \"     \\n\" \\\n\t\t\"6:     movew \" operands \"     \\n\" \\\n\t\t\"7:     movew \" operands \"     \\n\" \\\n\t\t\"8:     movew \" operands \"     \\n\" \\\n\t\t\"9:     movew \" operands \"     \\n\" \\\n\t\t\"10:    movew \" operands \"     \\n\" \\\n\t\t\"11:    movew \" operands \"     \\n\" \\\n\t\t\"12:    movew \" operands \"     \\n\" \\\n\t\t\"13:    movew \" operands \"     \\n\" \\\n\t\t\"14:    movew \" operands \"     \\n\" \\\n\t\t\"15:    movew \" operands \"     \\n\" \\\n\t\t\"16:    movew \" operands \"     \\n\" \\\n\t\t\"17:    nop                    \\n\" \\\n\t\t\"       subl  #32,%1           \\n\" \\\n\t\t\"40:                           \\n\" \\\n\t\t\"                              \\n\" \\\n\t\t\".section .fixup,\\\"ax\\\"        \\n\" \\\n\t\t\".even                         \\n\" \\\n\t\t\"90:    movel #0, %1           \\n\" \\\n\t\t\"       movel #2, %2           \\n\" \\\n\t\t\"       jra 40b                \\n\" \\\n\t\t\".previous                     \\n\" \\\n\t\t\"                              \\n\" \\\n\t\t\".section __ex_table,\\\"a\\\"     \\n\" \\\n\t\t\".align  4                     \\n\" \\\n\t\t\".long   1b,90b                \\n\" \\\n\t\t\".long   2b,90b                \\n\" \\\n\t\t\".long   3b,90b                \\n\" \\\n\t\t\".long   4b,90b                \\n\" \\\n\t\t\".long   5b,90b                \\n\" \\\n\t\t\".long   6b,90b                \\n\" \\\n\t\t\".long   7b,90b                \\n\" \\\n\t\t\".long   8b,90b                \\n\" \\\n\t\t\".long   9b,90b                \\n\" \\\n\t\t\".long  10b,90b                \\n\" \\\n\t\t\".long  11b,90b                \\n\" \\\n\t\t\".long  12b,90b                \\n\" \\\n\t\t\".long  13b,90b                \\n\" \\\n\t\t\".long  14b,90b                \\n\" \\\n\t\t\".long  15b,90b                \\n\" \\\n\t\t\".long  16b,90b                \\n\" \\\n\t\t\".long  17b,90b                \\n\" \\\n\t\t\".previous                     \\n\" \\\n\t\t: \"+a\" (addr), \"+r\" (n), \"+r\" (result) : \"a\" (io))\n\n#define MAC_PDMA_DELAY\t\t32\n\nstatic inline int mac_pdma_recv(void __iomem *io, unsigned char *start, int n)\n{\n\tunsigned char *addr = start;\n\tint result = 0;\n\n\tif (n >= 1) {\n\t\tMOVE_BYTE(\"%3@,%0@\");\n\t\tif (result)\n\t\t\tgoto out;\n\t}\n\tif (n >= 1 && ((unsigned long)addr & 1)) {\n\t\tMOVE_BYTE(\"%3@,%0@\");\n\t\tif (result)\n\t\t\tgoto out;\n\t}\n\twhile (n >= 32)\n\t\tMOVE_16_WORDS(\"%3@,%0@+\");\n\twhile (n >= 2)\n\t\tMOVE_WORD(\"%3@,%0@+\");\n\tif (result)\n\t\treturn start - addr;  \n\tif (n == 1)\n\t\tMOVE_BYTE(\"%3@,%0@\");\nout:\n\treturn addr - start;\n}\n\nstatic inline int mac_pdma_send(unsigned char *start, void __iomem *io, int n)\n{\n\tunsigned char *addr = start;\n\tint result = 0;\n\n\tif (n >= 1) {\n\t\tMOVE_BYTE(\"%0@,%3@\");\n\t\tif (result)\n\t\t\tgoto out;\n\t}\n\tif (n >= 1 && ((unsigned long)addr & 1)) {\n\t\tMOVE_BYTE(\"%0@,%3@\");\n\t\tif (result)\n\t\t\tgoto out;\n\t}\n\twhile (n >= 32)\n\t\tMOVE_16_WORDS(\"%0@+,%3@\");\n\twhile (n >= 2)\n\t\tMOVE_WORD(\"%0@+,%3@\");\n\tif (result)\n\t\treturn start - addr;  \n\tif (n == 1)\n\t\tMOVE_BYTE(\"%0@,%3@\");\nout:\n\treturn addr - start;\n}\n\n \n#define CTRL_REG                0x8\n#define CTRL_INTERRUPTS_ENABLE  BIT(1)\n#define CTRL_HANDSHAKE_MODE     BIT(3)\n\nstatic inline void write_ctrl_reg(struct NCR5380_hostdata *hostdata, u32 value)\n{\n\tout_be32(hostdata->io + (CTRL_REG << 4), value);\n}\n\nstatic inline int macscsi_pread(struct NCR5380_hostdata *hostdata,\n                                unsigned char *dst, int len)\n{\n\tu8 __iomem *s = hostdata->pdma_io + (INPUT_DATA_REG << 4);\n\tunsigned char *d = dst;\n\tint result = 0;\n\n\thostdata->pdma_residual = len;\n\n\twhile (!NCR5380_poll_politely(hostdata, BUS_AND_STATUS_REG,\n\t                              BASR_DRQ | BASR_PHASE_MATCH,\n\t                              BASR_DRQ | BASR_PHASE_MATCH, 0)) {\n\t\tint bytes;\n\n\t\tif (macintosh_config->ident == MAC_MODEL_IIFX)\n\t\t\twrite_ctrl_reg(hostdata, CTRL_HANDSHAKE_MODE |\n\t\t\t                         CTRL_INTERRUPTS_ENABLE);\n\n\t\tbytes = mac_pdma_recv(s, d, min(hostdata->pdma_residual, 512));\n\n\t\tif (bytes > 0) {\n\t\t\td += bytes;\n\t\t\thostdata->pdma_residual -= bytes;\n\t\t}\n\n\t\tif (hostdata->pdma_residual == 0)\n\t\t\tgoto out;\n\n\t\tif (NCR5380_poll_politely2(hostdata, STATUS_REG, SR_REQ, SR_REQ,\n\t\t                           BUS_AND_STATUS_REG, BASR_ACK,\n\t\t                           BASR_ACK, 0) < 0)\n\t\t\tscmd_printk(KERN_DEBUG, hostdata->connected,\n\t\t\t            \"%s: !REQ and !ACK\\n\", __func__);\n\t\tif (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_PHASE_MATCH))\n\t\t\tgoto out;\n\n\t\tif (bytes == 0)\n\t\t\tudelay(MAC_PDMA_DELAY);\n\n\t\tif (bytes >= 0)\n\t\t\tcontinue;\n\n\t\tdsprintk(NDEBUG_PSEUDO_DMA, hostdata->host,\n\t\t         \"%s: bus error (%d/%d)\\n\", __func__, d - dst, len);\n\t\tNCR5380_dprint(NDEBUG_PSEUDO_DMA, hostdata->host);\n\t\tresult = -1;\n\t\tgoto out;\n\t}\n\n\tscmd_printk(KERN_ERR, hostdata->connected,\n\t            \"%s: phase mismatch or !DRQ\\n\", __func__);\n\tNCR5380_dprint(NDEBUG_PSEUDO_DMA, hostdata->host);\n\tresult = -1;\nout:\n\tif (macintosh_config->ident == MAC_MODEL_IIFX)\n\t\twrite_ctrl_reg(hostdata, CTRL_INTERRUPTS_ENABLE);\n\treturn result;\n}\n\nstatic inline int macscsi_pwrite(struct NCR5380_hostdata *hostdata,\n                                 unsigned char *src, int len)\n{\n\tunsigned char *s = src;\n\tu8 __iomem *d = hostdata->pdma_io + (OUTPUT_DATA_REG << 4);\n\tint result = 0;\n\n\thostdata->pdma_residual = len;\n\n\twhile (!NCR5380_poll_politely(hostdata, BUS_AND_STATUS_REG,\n\t                              BASR_DRQ | BASR_PHASE_MATCH,\n\t                              BASR_DRQ | BASR_PHASE_MATCH, 0)) {\n\t\tint bytes;\n\n\t\tif (macintosh_config->ident == MAC_MODEL_IIFX)\n\t\t\twrite_ctrl_reg(hostdata, CTRL_HANDSHAKE_MODE |\n\t\t\t                         CTRL_INTERRUPTS_ENABLE);\n\n\t\tbytes = mac_pdma_send(s, d, min(hostdata->pdma_residual, 512));\n\n\t\tif (bytes > 0) {\n\t\t\ts += bytes;\n\t\t\thostdata->pdma_residual -= bytes;\n\t\t}\n\n\t\tif (hostdata->pdma_residual == 0) {\n\t\t\tif (NCR5380_poll_politely(hostdata, TARGET_COMMAND_REG,\n\t\t\t                          TCR_LAST_BYTE_SENT,\n\t\t\t                          TCR_LAST_BYTE_SENT,\n\t\t\t                          0) < 0) {\n\t\t\t\tscmd_printk(KERN_ERR, hostdata->connected,\n\t\t\t\t            \"%s: Last Byte Sent timeout\\n\", __func__);\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (NCR5380_poll_politely2(hostdata, STATUS_REG, SR_REQ, SR_REQ,\n\t\t                           BUS_AND_STATUS_REG, BASR_ACK,\n\t\t                           BASR_ACK, 0) < 0)\n\t\t\tscmd_printk(KERN_DEBUG, hostdata->connected,\n\t\t\t            \"%s: !REQ and !ACK\\n\", __func__);\n\t\tif (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_PHASE_MATCH))\n\t\t\tgoto out;\n\n\t\tif (bytes == 0)\n\t\t\tudelay(MAC_PDMA_DELAY);\n\n\t\tif (bytes >= 0)\n\t\t\tcontinue;\n\n\t\tdsprintk(NDEBUG_PSEUDO_DMA, hostdata->host,\n\t\t         \"%s: bus error (%d/%d)\\n\", __func__, s - src, len);\n\t\tNCR5380_dprint(NDEBUG_PSEUDO_DMA, hostdata->host);\n\t\tresult = -1;\n\t\tgoto out;\n\t}\n\n\tscmd_printk(KERN_ERR, hostdata->connected,\n\t            \"%s: phase mismatch or !DRQ\\n\", __func__);\n\tNCR5380_dprint(NDEBUG_PSEUDO_DMA, hostdata->host);\n\tresult = -1;\nout:\n\tif (macintosh_config->ident == MAC_MODEL_IIFX)\n\t\twrite_ctrl_reg(hostdata, CTRL_INTERRUPTS_ENABLE);\n\treturn result;\n}\n\nstatic int macscsi_dma_xfer_len(struct NCR5380_hostdata *hostdata,\n                                struct scsi_cmnd *cmd)\n{\n\tint resid = NCR5380_to_ncmd(cmd)->this_residual;\n\n\tif (hostdata->flags & FLAG_NO_PSEUDO_DMA || resid < setup_use_pdma)\n\t\treturn 0;\n\n\treturn resid;\n}\n\nstatic int macscsi_dma_residual(struct NCR5380_hostdata *hostdata)\n{\n\treturn hostdata->pdma_residual;\n}\n\n#include \"NCR5380.c\"\n\n#define DRV_MODULE_NAME         \"mac_scsi\"\n#define PFX                     DRV_MODULE_NAME \": \"\n\nstatic struct scsi_host_template mac_scsi_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.proc_name\t\t= DRV_MODULE_NAME,\n\t.name\t\t\t= \"Macintosh NCR5380 SCSI\",\n\t.info\t\t\t= macscsi_info,\n\t.queuecommand\t\t= macscsi_queue_command,\n\t.eh_abort_handler\t= macscsi_abort,\n\t.eh_host_reset_handler\t= macscsi_host_reset,\n\t.can_queue\t\t= 16,\n\t.this_id\t\t= 7,\n\t.sg_tablesize\t\t= 1,\n\t.cmd_per_lun\t\t= 2,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n\t.cmd_size\t\t= sizeof(struct NCR5380_cmd),\n\t.max_sectors\t\t= 128,\n};\n\nstatic int __init mac_scsi_probe(struct platform_device *pdev)\n{\n\tstruct Scsi_Host *instance;\n\tstruct NCR5380_hostdata *hostdata;\n\tint error;\n\tint host_flags = 0;\n\tstruct resource *irq, *pio_mem, *pdma_mem = NULL;\n\n\tpio_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!pio_mem)\n\t\treturn -ENODEV;\n\n\tpdma_mem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\n\tirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\n\tif (!hwreg_present((unsigned char *)pio_mem->start +\n\t                   (STATUS_REG << 4))) {\n\t\tpr_info(PFX \"no device detected at %pap\\n\", &pio_mem->start);\n\t\treturn -ENODEV;\n\t}\n\n\tif (setup_can_queue > 0)\n\t\tmac_scsi_template.can_queue = setup_can_queue;\n\tif (setup_cmd_per_lun > 0)\n\t\tmac_scsi_template.cmd_per_lun = setup_cmd_per_lun;\n\tif (setup_sg_tablesize > 0)\n\t\tmac_scsi_template.sg_tablesize = setup_sg_tablesize;\n\tif (setup_hostid >= 0)\n\t\tmac_scsi_template.this_id = setup_hostid & 7;\n\n\tinstance = scsi_host_alloc(&mac_scsi_template,\n\t                           sizeof(struct NCR5380_hostdata));\n\tif (!instance)\n\t\treturn -ENOMEM;\n\n\tif (irq)\n\t\tinstance->irq = irq->start;\n\telse\n\t\tinstance->irq = NO_IRQ;\n\n\thostdata = shost_priv(instance);\n\thostdata->base = pio_mem->start;\n\thostdata->io = (u8 __iomem *)pio_mem->start;\n\n\tif (pdma_mem && setup_use_pdma)\n\t\thostdata->pdma_io = (u8 __iomem *)pdma_mem->start;\n\telse\n\t\thost_flags |= FLAG_NO_PSEUDO_DMA;\n\n\thost_flags |= setup_toshiba_delay > 0 ? FLAG_TOSHIBA_DELAY : 0;\n\n\terror = NCR5380_init(instance, host_flags | FLAG_LATE_DMA_SETUP);\n\tif (error)\n\t\tgoto fail_init;\n\n\tif (instance->irq != NO_IRQ) {\n\t\terror = request_irq(instance->irq, macscsi_intr, IRQF_SHARED,\n\t\t                    \"NCR5380\", instance);\n\t\tif (error)\n\t\t\tgoto fail_irq;\n\t}\n\n\tNCR5380_maybe_reset_bus(instance);\n\n\terror = scsi_add_host(instance, NULL);\n\tif (error)\n\t\tgoto fail_host;\n\n\tplatform_set_drvdata(pdev, instance);\n\n\tscsi_scan_host(instance);\n\treturn 0;\n\nfail_host:\n\tif (instance->irq != NO_IRQ)\n\t\tfree_irq(instance->irq, instance);\nfail_irq:\n\tNCR5380_exit(instance);\nfail_init:\n\tscsi_host_put(instance);\n\treturn error;\n}\n\nstatic int __exit mac_scsi_remove(struct platform_device *pdev)\n{\n\tstruct Scsi_Host *instance = platform_get_drvdata(pdev);\n\n\tscsi_remove_host(instance);\n\tif (instance->irq != NO_IRQ)\n\t\tfree_irq(instance->irq, instance);\n\tNCR5380_exit(instance);\n\tscsi_host_put(instance);\n\treturn 0;\n}\n\nstatic struct platform_driver mac_scsi_driver = {\n\t.remove = __exit_p(mac_scsi_remove),\n\t.driver = {\n\t\t.name\t= DRV_MODULE_NAME,\n\t},\n};\n\nmodule_platform_driver_probe(mac_scsi_driver, mac_scsi_probe);\n\nMODULE_ALIAS(\"platform:\" DRV_MODULE_NAME);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}