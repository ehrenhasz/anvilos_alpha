{
  "module_name": "scsi_dh.c",
  "hash_id": "bd78a36708c9c22cdb1c92afe962f1d022f8d5777815dc493a5f537a2233c692",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_dh.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <scsi/scsi_dh.h>\n#include \"scsi_priv.h\"\n\nstatic DEFINE_SPINLOCK(list_lock);\nstatic LIST_HEAD(scsi_dh_list);\n\nstruct scsi_dh_blist {\n\tconst char *vendor;\n\tconst char *model;\n\tconst char *driver;\n};\n\nstatic const struct scsi_dh_blist scsi_dh_blist[] = {\n\t{\"DGC\", \"RAID\",\t\t\t\"emc\" },\n\t{\"DGC\", \"DISK\",\t\t\t\"emc\" },\n\t{\"DGC\", \"VRAID\",\t\t\"emc\" },\n\n\t{\"COMPAQ\", \"MSA1000 VOLUME\",\t\"hp_sw\" },\n\t{\"COMPAQ\", \"HSV110\",\t\t\"hp_sw\" },\n\t{\"HP\", \"HSV100\",\t\t\"hp_sw\"},\n\t{\"DEC\", \"HSG80\",\t\t\"hp_sw\"},\n\n\t{\"IBM\", \"1722\",\t\t\t\"rdac\", },\n\t{\"IBM\", \"1724\",\t\t\t\"rdac\", },\n\t{\"IBM\", \"1726\",\t\t\t\"rdac\", },\n\t{\"IBM\", \"1742\",\t\t\t\"rdac\", },\n\t{\"IBM\", \"1745\",\t\t\t\"rdac\", },\n\t{\"IBM\", \"1746\",\t\t\t\"rdac\", },\n\t{\"IBM\", \"1813\",\t\t\t\"rdac\", },\n\t{\"IBM\", \"1814\",\t\t\t\"rdac\", },\n\t{\"IBM\", \"1815\",\t\t\t\"rdac\", },\n\t{\"IBM\", \"1818\",\t\t\t\"rdac\", },\n\t{\"IBM\", \"3526\",\t\t\t\"rdac\", },\n\t{\"IBM\", \"3542\",\t\t\t\"rdac\", },\n\t{\"IBM\", \"3552\",\t\t\t\"rdac\", },\n\t{\"SGI\", \"TP9300\",\t\t\"rdac\", },\n\t{\"SGI\", \"TP9400\",\t\t\"rdac\", },\n\t{\"SGI\", \"TP9500\",\t\t\"rdac\", },\n\t{\"SGI\", \"TP9700\",\t\t\"rdac\", },\n\t{\"SGI\", \"IS\",\t\t\t\"rdac\", },\n\t{\"STK\", \"OPENstorage\",\t\t\"rdac\", },\n\t{\"STK\", \"FLEXLINE 380\",\t\t\"rdac\", },\n\t{\"STK\", \"BladeCtlr\",\t\t\"rdac\", },\n\t{\"SUN\", \"CSM\",\t\t\t\"rdac\", },\n\t{\"SUN\", \"LCSM100\",\t\t\"rdac\", },\n\t{\"SUN\", \"STK6580_6780\",\t\t\"rdac\", },\n\t{\"SUN\", \"SUN_6180\",\t\t\"rdac\", },\n\t{\"SUN\", \"ArrayStorage\",\t\t\"rdac\", },\n\t{\"DELL\", \"MD3\",\t\t\t\"rdac\", },\n\t{\"NETAPP\", \"INF-01-00\",\t\t\"rdac\", },\n\t{\"LSI\", \"INF-01-00\",\t\t\"rdac\", },\n\t{\"ENGENIO\", \"INF-01-00\",\t\"rdac\", },\n\t{\"LENOVO\", \"DE_Series\",\t\t\"rdac\", },\n\t{\"FUJITSU\", \"ETERNUS_AHB\",\t\"rdac\", },\n\t{NULL, NULL,\t\t\tNULL },\n};\n\nstatic const char *\nscsi_dh_find_driver(struct scsi_device *sdev)\n{\n\tconst struct scsi_dh_blist *b;\n\n\tif (scsi_device_tpgs(sdev))\n\t\treturn \"alua\";\n\n\tfor (b = scsi_dh_blist; b->vendor; b++) {\n\t\tif (!strncmp(sdev->vendor, b->vendor, strlen(b->vendor)) &&\n\t\t    !strncmp(sdev->model, b->model, strlen(b->model))) {\n\t\t\treturn b->driver;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n\nstatic struct scsi_device_handler *__scsi_dh_lookup(const char *name)\n{\n\tstruct scsi_device_handler *tmp, *found = NULL;\n\n\tspin_lock(&list_lock);\n\tlist_for_each_entry(tmp, &scsi_dh_list, list) {\n\t\tif (!strncmp(tmp->name, name, strlen(tmp->name))) {\n\t\t\tfound = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&list_lock);\n\treturn found;\n}\n\nstatic struct scsi_device_handler *scsi_dh_lookup(const char *name)\n{\n\tstruct scsi_device_handler *dh;\n\n\tif (!name || strlen(name) == 0)\n\t\treturn NULL;\n\n\tdh = __scsi_dh_lookup(name);\n\tif (!dh) {\n\t\trequest_module(\"scsi_dh_%s\", name);\n\t\tdh = __scsi_dh_lookup(name);\n\t}\n\n\treturn dh;\n}\n\n \nstatic int scsi_dh_handler_attach(struct scsi_device *sdev,\n\t\t\t\t  struct scsi_device_handler *scsi_dh)\n{\n\tint error, ret = 0;\n\n\tif (!try_module_get(scsi_dh->module))\n\t\treturn -EINVAL;\n\n\terror = scsi_dh->attach(sdev);\n\tif (error != SCSI_DH_OK) {\n\t\tswitch (error) {\n\t\tcase SCSI_DH_NOMEM:\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\tcase SCSI_DH_RES_TEMP_UNAVAIL:\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\tcase SCSI_DH_DEV_UNSUPP:\n\t\tcase SCSI_DH_NOSYS:\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != -ENODEV)\n\t\t\tsdev_printk(KERN_ERR, sdev, \"%s: Attach failed (%d)\\n\",\n\t\t\t\t    scsi_dh->name, error);\n\t\tmodule_put(scsi_dh->module);\n\t} else\n\t\tsdev->handler = scsi_dh;\n\n\treturn ret;\n}\n\n \nstatic void scsi_dh_handler_detach(struct scsi_device *sdev)\n{\n\tsdev->handler->detach(sdev);\n\tsdev_printk(KERN_NOTICE, sdev, \"%s: Detached\\n\", sdev->handler->name);\n\tmodule_put(sdev->handler->module);\n}\n\nvoid scsi_dh_add_device(struct scsi_device *sdev)\n{\n\tstruct scsi_device_handler *devinfo = NULL;\n\tconst char *drv;\n\n\tdrv = scsi_dh_find_driver(sdev);\n\tif (drv)\n\t\tdevinfo = __scsi_dh_lookup(drv);\n\t \n\tif (devinfo)\n\t\t(void)scsi_dh_handler_attach(sdev, devinfo);\n}\n\nvoid scsi_dh_release_device(struct scsi_device *sdev)\n{\n\tif (sdev->handler)\n\t\tscsi_dh_handler_detach(sdev);\n}\n\n \nint scsi_register_device_handler(struct scsi_device_handler *scsi_dh)\n{\n\tif (__scsi_dh_lookup(scsi_dh->name))\n\t\treturn -EBUSY;\n\n\tif (!scsi_dh->attach || !scsi_dh->detach)\n\t\treturn -EINVAL;\n\n\tspin_lock(&list_lock);\n\tlist_add(&scsi_dh->list, &scsi_dh_list);\n\tspin_unlock(&list_lock);\n\n\tprintk(KERN_INFO \"%s: device handler registered\\n\", scsi_dh->name);\n\n\treturn SCSI_DH_OK;\n}\nEXPORT_SYMBOL_GPL(scsi_register_device_handler);\n\n \nint scsi_unregister_device_handler(struct scsi_device_handler *scsi_dh)\n{\n\tif (!__scsi_dh_lookup(scsi_dh->name))\n\t\treturn -ENODEV;\n\n\tspin_lock(&list_lock);\n\tlist_del(&scsi_dh->list);\n\tspin_unlock(&list_lock);\n\tprintk(KERN_INFO \"%s: device handler unregistered\\n\", scsi_dh->name);\n\n\treturn SCSI_DH_OK;\n}\nEXPORT_SYMBOL_GPL(scsi_unregister_device_handler);\n\n \nint scsi_dh_activate(struct request_queue *q, activate_complete fn, void *data)\n{\n\tstruct scsi_device *sdev;\n\tint err = SCSI_DH_NOSYS;\n\n\tsdev = scsi_device_from_queue(q);\n\tif (!sdev) {\n\t\tif (fn)\n\t\t\tfn(data, err);\n\t\treturn err;\n\t}\n\n\tif (!sdev->handler)\n\t\tgoto out_fn;\n\terr = SCSI_DH_NOTCONN;\n\tif (sdev->sdev_state == SDEV_CANCEL ||\n\t    sdev->sdev_state == SDEV_DEL)\n\t\tgoto out_fn;\n\n\terr = SCSI_DH_DEV_OFFLINED;\n\tif (sdev->sdev_state == SDEV_OFFLINE)\n\t\tgoto out_fn;\n\n\tif (sdev->handler->activate)\n\t\terr = sdev->handler->activate(sdev, fn, data);\n\nout_put_device:\n\tput_device(&sdev->sdev_gendev);\n\treturn err;\n\nout_fn:\n\tif (fn)\n\t\tfn(data, err);\n\tgoto out_put_device;\n}\nEXPORT_SYMBOL_GPL(scsi_dh_activate);\n\n \nint scsi_dh_set_params(struct request_queue *q, const char *params)\n{\n\tstruct scsi_device *sdev;\n\tint err = -SCSI_DH_NOSYS;\n\n\tsdev = scsi_device_from_queue(q);\n\tif (!sdev)\n\t\treturn err;\n\n\tif (sdev->handler && sdev->handler->set_params)\n\t\terr = sdev->handler->set_params(sdev, params);\n\tput_device(&sdev->sdev_gendev);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(scsi_dh_set_params);\n\n \nint scsi_dh_attach(struct request_queue *q, const char *name)\n{\n\tstruct scsi_device *sdev;\n\tstruct scsi_device_handler *scsi_dh;\n\tint err = 0;\n\n\tsdev = scsi_device_from_queue(q);\n\tif (!sdev)\n\t\treturn -ENODEV;\n\n\tscsi_dh = scsi_dh_lookup(name);\n\tif (!scsi_dh) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_device;\n\t}\n\n\tif (sdev->handler) {\n\t\tif (sdev->handler != scsi_dh)\n\t\t\terr = -EBUSY;\n\t\tgoto out_put_device;\n\t}\n\n\terr = scsi_dh_handler_attach(sdev, scsi_dh);\n\nout_put_device:\n\tput_device(&sdev->sdev_gendev);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(scsi_dh_attach);\n\n \nconst char *scsi_dh_attached_handler_name(struct request_queue *q, gfp_t gfp)\n{\n\tstruct scsi_device *sdev;\n\tconst char *handler_name = NULL;\n\n\tsdev = scsi_device_from_queue(q);\n\tif (!sdev)\n\t\treturn NULL;\n\n\tif (sdev->handler)\n\t\thandler_name = kstrdup(sdev->handler->name, gfp);\n\tput_device(&sdev->sdev_gendev);\n\treturn handler_name;\n}\nEXPORT_SYMBOL_GPL(scsi_dh_attached_handler_name);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}