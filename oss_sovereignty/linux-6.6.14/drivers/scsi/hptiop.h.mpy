{
  "module_name": "hptiop.h",
  "hash_id": "222e416439df4f0583d4836ececfd15dda87b577e73f2baa792c2e56f7853a07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/hptiop.h",
  "human_readable_source": " \n \n#ifndef _HPTIOP_H_\n#define _HPTIOP_H_\n\nstruct hpt_iopmu_itl {\n\t__le32 resrved0[4];\n\t__le32 inbound_msgaddr0;\n\t__le32 inbound_msgaddr1;\n\t__le32 outbound_msgaddr0;\n\t__le32 outbound_msgaddr1;\n\t__le32 inbound_doorbell;\n\t__le32 inbound_intstatus;\n\t__le32 inbound_intmask;\n\t__le32 outbound_doorbell;\n\t__le32 outbound_intstatus;\n\t__le32 outbound_intmask;\n\t__le32 reserved1[2];\n\t__le32 inbound_queue;\n\t__le32 outbound_queue;\n};\n\n#define IOPMU_QUEUE_EMPTY            0xffffffff\n#define IOPMU_QUEUE_MASK_HOST_BITS   0xf0000000\n#define IOPMU_QUEUE_ADDR_HOST_BIT    0x80000000\n#define IOPMU_QUEUE_REQUEST_SIZE_BIT    0x40000000\n#define IOPMU_QUEUE_REQUEST_RESULT_BIT   0x40000000\n\n#define IOPMU_OUTBOUND_INT_MSG0      1\n#define IOPMU_OUTBOUND_INT_MSG1      2\n#define IOPMU_OUTBOUND_INT_DOORBELL  4\n#define IOPMU_OUTBOUND_INT_POSTQUEUE 8\n#define IOPMU_OUTBOUND_INT_PCI       0x10\n\n#define IOPMU_INBOUND_INT_MSG0       1\n#define IOPMU_INBOUND_INT_MSG1       2\n#define IOPMU_INBOUND_INT_DOORBELL   4\n#define IOPMU_INBOUND_INT_ERROR      8\n#define IOPMU_INBOUND_INT_POSTQUEUE  0x10\n\n#define MVIOP_QUEUE_LEN  512\n\nstruct hpt_iopmu_mv {\n\t__le32 inbound_head;\n\t__le32 inbound_tail;\n\t__le32 outbound_head;\n\t__le32 outbound_tail;\n\t__le32 inbound_msg;\n\t__le32 outbound_msg;\n\t__le32 reserve[10];\n\t__le64 inbound_q[MVIOP_QUEUE_LEN];\n\t__le64 outbound_q[MVIOP_QUEUE_LEN];\n};\n\nstruct hpt_iopmv_regs {\n\t__le32 reserved[0x20400 / 4];\n\t__le32 inbound_doorbell;\n\t__le32 inbound_intmask;\n\t__le32 outbound_doorbell;\n\t__le32 outbound_intmask;\n};\n\n#pragma pack(1)\nstruct hpt_iopmu_mvfrey {\n\t__le32 reserved0[(0x4000 - 0) / 4];\n\t__le32 inbound_base;\n\t__le32 inbound_base_high;\n\t__le32 reserved1[(0x4018 - 0x4008) / 4];\n\t__le32 inbound_write_ptr;\n\t__le32 reserved2[(0x402c - 0x401c) / 4];\n\t__le32 inbound_conf_ctl;\n\t__le32 reserved3[(0x4050 - 0x4030) / 4];\n\t__le32 outbound_base;\n\t__le32 outbound_base_high;\n\t__le32 outbound_shadow_base;\n\t__le32 outbound_shadow_base_high;\n\t__le32 reserved4[(0x4088 - 0x4060) / 4];\n\t__le32 isr_cause;\n\t__le32 isr_enable;\n\t__le32 reserved5[(0x1020c - 0x4090) / 4];\n\t__le32 pcie_f0_int_enable;\n\t__le32 reserved6[(0x10400 - 0x10210) / 4];\n\t__le32 f0_to_cpu_msg_a;\n\t__le32 reserved7[(0x10420 - 0x10404) / 4];\n\t__le32 cpu_to_f0_msg_a;\n\t__le32 reserved8[(0x10480 - 0x10424) / 4];\n\t__le32 f0_doorbell;\n\t__le32 f0_doorbell_enable;\n};\n\nstruct mvfrey_inlist_entry {\n\tdma_addr_t addr;\n\t__le32 intrfc_len;\n\t__le32 reserved;\n};\n\nstruct mvfrey_outlist_entry {\n\t__le32 val;\n};\n#pragma pack()\n\n#define MVIOP_MU_QUEUE_ADDR_HOST_MASK   (~(0x1full))\n#define MVIOP_MU_QUEUE_ADDR_HOST_BIT    4\n\n#define MVIOP_MU_QUEUE_ADDR_IOP_HIGH32  0xffffffff\n#define MVIOP_MU_QUEUE_REQUEST_RESULT_BIT   1\n#define MVIOP_MU_QUEUE_REQUEST_RETURN_CONTEXT 2\n\n#define MVIOP_MU_INBOUND_INT_MSG        1\n#define MVIOP_MU_INBOUND_INT_POSTQUEUE  2\n#define MVIOP_MU_OUTBOUND_INT_MSG       1\n#define MVIOP_MU_OUTBOUND_INT_POSTQUEUE 2\n\n#define CL_POINTER_TOGGLE        0x00004000\n#define CPU_TO_F0_DRBL_MSG_BIT   0x02000000\n\nenum hpt_iopmu_message {\n\t \n\tIOPMU_INBOUND_MSG0_NOP = 0,\n\tIOPMU_INBOUND_MSG0_RESET,\n\tIOPMU_INBOUND_MSG0_FLUSH,\n\tIOPMU_INBOUND_MSG0_SHUTDOWN,\n\tIOPMU_INBOUND_MSG0_STOP_BACKGROUND_TASK,\n\tIOPMU_INBOUND_MSG0_START_BACKGROUND_TASK,\n\tIOPMU_INBOUND_MSG0_RESET_COMM,\n\tIOPMU_INBOUND_MSG0_MAX = 0xff,\n\t \n\tIOPMU_OUTBOUND_MSG0_REGISTER_DEVICE_0 = 0x100,\n\tIOPMU_OUTBOUND_MSG0_REGISTER_DEVICE_MAX = 0x1ff,\n\tIOPMU_OUTBOUND_MSG0_UNREGISTER_DEVICE_0 = 0x200,\n\tIOPMU_OUTBOUND_MSG0_UNREGISTER_DEVICE_MAX = 0x2ff,\n\tIOPMU_OUTBOUND_MSG0_REVALIDATE_DEVICE_0 = 0x300,\n\tIOPMU_OUTBOUND_MSG0_REVALIDATE_DEVICE_MAX = 0x3ff,\n};\n\nstruct hpt_iop_request_header {\n\t__le32 size;\n\t__le32 type;\n\t__le32 flags;\n\t__le32 result;\n\t__le32 context;  \n\t__le32 context_hi32;\n};\n\n#define IOP_REQUEST_FLAG_SYNC_REQUEST 1\n#define IOP_REQUEST_FLAG_BIST_REQUEST 2\n#define IOP_REQUEST_FLAG_REMAPPED     4\n#define IOP_REQUEST_FLAG_OUTPUT_CONTEXT 8\n#define IOP_REQUEST_FLAG_ADDR_BITS 0x40  \n\nenum hpt_iop_request_type {\n\tIOP_REQUEST_TYPE_GET_CONFIG = 0,\n\tIOP_REQUEST_TYPE_SET_CONFIG,\n\tIOP_REQUEST_TYPE_BLOCK_COMMAND,\n\tIOP_REQUEST_TYPE_SCSI_COMMAND,\n\tIOP_REQUEST_TYPE_IOCTL_COMMAND,\n\tIOP_REQUEST_TYPE_MAX\n};\n\nenum hpt_iop_result_type {\n\tIOP_RESULT_PENDING = 0,\n\tIOP_RESULT_SUCCESS,\n\tIOP_RESULT_FAIL,\n\tIOP_RESULT_BUSY,\n\tIOP_RESULT_RESET,\n\tIOP_RESULT_INVALID_REQUEST,\n\tIOP_RESULT_BAD_TARGET,\n\tIOP_RESULT_CHECK_CONDITION,\n};\n\nstruct hpt_iop_request_get_config {\n\tstruct hpt_iop_request_header header;\n\t__le32 interface_version;\n\t__le32 firmware_version;\n\t__le32 max_requests;\n\t__le32 request_size;\n\t__le32 max_sg_count;\n\t__le32 data_transfer_length;\n\t__le32 alignment_mask;\n\t__le32 max_devices;\n\t__le32 sdram_size;\n};\n\nstruct hpt_iop_request_set_config {\n\tstruct hpt_iop_request_header header;\n\t__le32 iop_id;\n\t__le16 vbus_id;\n\t__le16 max_host_request_size;\n\t__le32 reserve[6];\n};\n\nstruct hpt_iopsg {\n\t__le32 size;\n\t__le32 eot;  \n\t__le64 pci_address;\n};\n\nstruct hpt_iop_request_block_command {\n\tstruct hpt_iop_request_header header;\n\tu8     channel;\n\tu8     target;\n\tu8     lun;\n\tu8     pad1;\n\t__le16 command;  \n\t__le16 sectors;\n\t__le64 lba;\n\tstruct hpt_iopsg sg_list[1];\n};\n\n#define IOP_BLOCK_COMMAND_READ     1\n#define IOP_BLOCK_COMMAND_WRITE    2\n#define IOP_BLOCK_COMMAND_VERIFY   3\n#define IOP_BLOCK_COMMAND_FLUSH    4\n#define IOP_BLOCK_COMMAND_SHUTDOWN 5\n\nstruct hpt_iop_request_scsi_command {\n\tstruct hpt_iop_request_header header;\n\tu8     channel;\n\tu8     target;\n\tu8     lun;\n\tu8     pad1;\n\tu8     cdb[16];\n\t__le32 dataxfer_length;\n\tstruct hpt_iopsg sg_list[];\n};\n\nstruct hpt_iop_request_ioctl_command {\n\tstruct hpt_iop_request_header header;\n\t__le32 ioctl_code;\n\t__le32 inbuf_size;\n\t__le32 outbuf_size;\n\t__le32 bytes_returned;\n\tu8     buf[];\n\t \n};\n\n#define HPTIOP_MAX_REQUESTS  256u\n\nstruct hptiop_request {\n\tstruct hptiop_request *next;\n\tvoid                  *req_virt;\n\tu32                   req_shifted_phy;\n\tstruct scsi_cmnd      *scp;\n\tint                   index;\n};\n\nstruct hpt_cmd_priv {\n\tint mapped;\n\tint sgcnt;\n\tdma_addr_t dma_handle;\n};\n\n#define HPT_SCP(scp) ((struct hpt_cmd_priv *)scsi_cmd_priv(scp))\n\nenum hptiop_family {\n\tUNKNOWN_BASED_IOP,\n\tINTEL_BASED_IOP,\n\tMV_BASED_IOP,\n\tMVFREY_BASED_IOP\n} ;\n\nstruct hptiop_hba {\n\tstruct hptiop_adapter_ops *ops;\n\tunion {\n\t\tstruct {\n\t\t\tstruct hpt_iopmu_itl __iomem *iop;\n\t\t\tvoid __iomem *plx;\n\t\t} itl;\n\t\tstruct {\n\t\t\tstruct hpt_iopmv_regs *regs;\n\t\t\tstruct hpt_iopmu_mv __iomem *mu;\n\t\t\tvoid *internal_req;\n\t\t\tdma_addr_t internal_req_phy;\n\t\t} mv;\n\t\tstruct {\n\t\t\tstruct hpt_iop_request_get_config __iomem *config;\n\t\t\tstruct hpt_iopmu_mvfrey __iomem *mu;\n\n\t\t\tint internal_mem_size;\n\t\t\tstruct hptiop_request internal_req;\n\t\t\tint list_count;\n\t\t\tstruct mvfrey_inlist_entry *inlist;\n\t\t\tdma_addr_t inlist_phy;\n\t\t\t__le32 inlist_wptr;\n\t\t\tstruct mvfrey_outlist_entry *outlist;\n\t\t\tdma_addr_t outlist_phy;\n\t\t\t__le32 *outlist_cptr;  \n\t\t\tdma_addr_t outlist_cptr_phy;\n\t\t\t__le32 outlist_rptr;\n\t\t} mvfrey;\n\t} u;\n\n\tstruct Scsi_Host *host;\n\tstruct pci_dev *pcidev;\n\n\t \n\tu32     interface_version;\n\tu32     firmware_version;\n\tu32     sdram_size;\n\tu32     max_devices;\n\tu32     max_requests;\n\tu32     max_request_size;\n\tu32     max_sg_descriptors;\n\n\tu32     req_size;  \n\n\tu32     iopintf_v2: 1;\n\tu32     initialized: 1;\n\tu32     msg_done: 1;\n\n\tstruct hptiop_request * req_list;\n\tstruct hptiop_request reqs[HPTIOP_MAX_REQUESTS];\n\n\t \n\tvoid        *dma_coherent[HPTIOP_MAX_REQUESTS];\n\tdma_addr_t  dma_coherent_handle[HPTIOP_MAX_REQUESTS];\n\n\tatomic_t    reset_count;\n\tatomic_t    resetting;\n\n\twait_queue_head_t reset_wq;\n\twait_queue_head_t ioctl_wq;\n};\n\nstruct hpt_ioctl_k {\n\tstruct hptiop_hba * hba;\n\tu32    ioctl_code;\n\tu32    inbuf_size;\n\tu32    outbuf_size;\n\tvoid   *inbuf;\n\tvoid   *outbuf;\n\tu32    *bytes_returned;\n\tvoid (*done)(struct hpt_ioctl_k *);\n\tint    result;  \n};\n\nstruct hptiop_adapter_ops {\n\tenum hptiop_family family;\n\tint  (*iop_wait_ready)(struct hptiop_hba *hba, u32 millisec);\n\tint  (*internal_memalloc)(struct hptiop_hba *hba);\n\tint  (*internal_memfree)(struct hptiop_hba *hba);\n\tint  (*map_pci_bar)(struct hptiop_hba *hba);\n\tvoid (*unmap_pci_bar)(struct hptiop_hba *hba);\n\tvoid (*enable_intr)(struct hptiop_hba *hba);\n\tvoid (*disable_intr)(struct hptiop_hba *hba);\n\tint  (*get_config)(struct hptiop_hba *hba,\n\t\t\t\tstruct hpt_iop_request_get_config *config);\n\tint  (*set_config)(struct hptiop_hba *hba,\n\t\t\t\tstruct hpt_iop_request_set_config *config);\n\tint  (*iop_intr)(struct hptiop_hba *hba);\n\tvoid (*post_msg)(struct hptiop_hba *hba, u32 msg);\n\tvoid (*post_req)(struct hptiop_hba *hba, struct hptiop_request *_req);\n\tint  hw_dma_bit_mask;\n\tint  (*reset_comm)(struct hptiop_hba *hba);\n\t__le64  host_phy_flag;\n};\n\n#define HPT_IOCTL_RESULT_OK         0\n#define HPT_IOCTL_RESULT_FAILED     (-1)\n\n#if 0\n#define dprintk(fmt, args...) do { printk(fmt, ##args); } while(0)\n#else\n#define dprintk(fmt, args...)\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}