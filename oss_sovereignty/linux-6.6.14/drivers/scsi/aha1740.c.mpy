{
  "module_name": "aha1740.c",
  "hash_id": "b055941824285e23c5e8ef17935f2dbc338cc0fd6b83b06f5d1248b857167c84",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aha1740.c",
  "human_readable_source": " \n\n#include <linux/blkdev.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/ioport.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/eisa.h>\n#include <linux/dma-mapping.h>\n#include <linux/gfp.h>\n\n#include <asm/dma.h>\n#include <asm/io.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include \"aha1740.h\"\n\n \n#ifdef DEBUG\n#define DEB(x) x\n#else\n#define DEB(x)\n#endif\n\nstruct aha1740_hostdata {\n\tstruct eisa_device *edev;\n\tunsigned int translation;\n\tunsigned int last_ecb_used;\n\tdma_addr_t ecb_dma_addr;\n\tstruct ecb ecb[AHA1740_ECBS];\n};\n\nstruct aha1740_sg {\n\tstruct aha1740_chain sg_chain[AHA1740_SCATTER];\n\tdma_addr_t sg_dma_addr;\n\tdma_addr_t buf_dma_addr;\n};\n\n#define HOSTDATA(host) ((struct aha1740_hostdata *) &host->hostdata)\n\nstatic inline struct ecb *ecb_dma_to_cpu (struct Scsi_Host *host,\n\t\t\t\t\t  dma_addr_t dma)\n{\n\tstruct aha1740_hostdata *hdata = HOSTDATA (host);\n\tdma_addr_t offset;\n\n\toffset = dma - hdata->ecb_dma_addr;\n\n\treturn (struct ecb *)(((char *) hdata->ecb) + (unsigned int) offset);\n}\n\nstatic inline dma_addr_t ecb_cpu_to_dma (struct Scsi_Host *host, void *cpu)\n{\n\tstruct aha1740_hostdata *hdata = HOSTDATA (host);\n\tdma_addr_t offset;\n    \n\toffset = (char *) cpu - (char *) hdata->ecb;\n\n\treturn hdata->ecb_dma_addr + offset;\n}\n\nstatic int aha1740_show_info(struct seq_file *m, struct Scsi_Host *shpnt)\n{\n\tstruct aha1740_hostdata *host = HOSTDATA(shpnt);\n\tseq_printf(m, \"aha174x at IO:%lx, IRQ %d, SLOT %d.\\n\"\n\t\t      \"Extended translation %sabled.\\n\",\n\t\t      shpnt->io_port, shpnt->irq, host->edev->slot,\n\t\t      host->translation ? \"en\" : \"dis\");\n\treturn 0;\n}\n\nstatic int aha1740_makecode(unchar *sense, unchar *status)\n{\n\tstruct statusword\n\t{\n\t\tushort\tdon:1,\t \n\t\t\tdu:1,\t \n\t\t    :1,\tqf:1,\t \n\t\t        sc:1,\t \n\t\t        dor:1,\t \n\t\t        ch:1,\t \n\t\t        intr:1,\t \n\t\t        asa:1,\t \n\t\t        sns:1,\t \n\t\t    :1,\tini:1,\t \n\t\t\tme:1,\t \n\t\t    :1,\teca:1,   \n\t\t    :1;\n\t} status_word;\n\tint retval = DID_OK;\n\n\tstatus_word = * (struct statusword *) status;\n#ifdef DEBUG\n\tprintk(\"makecode from %x,%x,%x,%x %x,%x,%x,%x\",\n\t       status[0], status[1], status[2], status[3],\n\t       sense[0], sense[1], sense[2], sense[3]);\n#endif\n\tif (!status_word.don) {  \n\t\tif ( (status[1]&0x18) || status_word.sc ) {\n\t\t\t \n\t\t\t \n\t\t\tswitch ( status[2] ) {\n\t\t\tcase 0x12:\n\t\t\t\tif ( status_word.dor )\n\t\t\t\t\tretval=DID_ERROR;  \n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tcase 0x00:  \n\t\t\t\tbreak;\n\t\t\tcase 0x11:\n\t\t\tcase 0x21:\n\t\t\t\tretval=DID_TIME_OUT;\n\t\t\t\tbreak;\n\t\t\tcase 0x0a:\n\t\t\t\tretval=DID_BAD_TARGET;\n\t\t\t\tbreak;\n\t\t\tcase 0x04:\n\t\t\tcase 0x05:\n\t\t\t\tretval=DID_ABORT;\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tretval=DID_ERROR;  \n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif ( status_word.qf ) {\n\t\t\t\tretval = DID_TIME_OUT;  \n\t\t\t\t \n\t\t\t\tprintk(\"aha1740.c: WARNING: AHA1740 queue overflow!\\n\");\n\t\t\t} else\n\t\t\t\tif ( status[0]&0x60 ) {\n\t\t\t\t\t  \n\t\t\t\t\tretval = DID_ERROR;\n\t\t\t\t}\n\t\t\t \n\t\t}\n\t}\n\t \n\treturn status[3] | retval << 16;\n}\n\nstatic int aha1740_test_port(unsigned int base)\n{\n\tif ( inb(PORTADR(base)) & PORTADDR_ENH )\n\t\treturn 1;    \n\t\n\tprintk(\"aha174x: Board detected, but not in enhanced mode, so disabled it.\\n\");\n\treturn 0;\n}\n\n \nstatic irqreturn_t aha1740_intr_handle(int irq, void *dev_id)\n{\n\tstruct Scsi_Host *host = (struct Scsi_Host *) dev_id;\n        void (*my_done)(struct scsi_cmnd *);\n\tint errstatus, adapstat;\n\tint number_serviced;\n\tstruct ecb *ecbptr;\n\tstruct scsi_cmnd *SCtmp;\n\tunsigned int base;\n\tunsigned long flags;\n\tint handled = 0;\n\tstruct aha1740_sg *sgptr;\n\tstruct eisa_device *edev;\n\t\n\tif (!host)\n\t\tpanic(\"aha1740.c: Irq from unknown host!\\n\");\n\tspin_lock_irqsave(host->host_lock, flags);\n\tbase = host->io_port;\n\tnumber_serviced = 0;\n\tedev = HOSTDATA(host)->edev;\n\n\twhile(inb(G2STAT(base)) & G2STAT_INTPEND) {\n\t\thandled = 1;\n\t\tDEB(printk(\"aha1740_intr top of loop.\\n\"));\n\t\tadapstat = inb(G2INTST(base));\n\t\tecbptr = ecb_dma_to_cpu (host, inl(MBOXIN0(base)));\n\t\toutb(G2CNTRL_IRST,G2CNTRL(base));  \n      \n\t\tswitch ( adapstat & G2INTST_MASK ) {\n\t\tcase\tG2INTST_CCBRETRY:\n\t\tcase\tG2INTST_CCBERROR:\n\t\tcase\tG2INTST_CCBGOOD:\n\t\t\t \n\t\t\toutb(G2CNTRL_HRDY,G2CNTRL(base));\n\t\t\tif (!ecbptr) {\n\t\t\t\tprintk(\"Aha1740 null ecbptr in interrupt (%x,%x,%x,%d)\\n\",\n\t\t\t\t       inb(G2STAT(base)),adapstat,\n\t\t\t\t       inb(G2INTST(base)), number_serviced++);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSCtmp = ecbptr->SCpnt;\n\t\t\tif (!SCtmp) {\n\t\t\t\tprintk(\"Aha1740 null SCtmp in interrupt (%x,%x,%x,%d)\\n\",\n\t\t\t\t       inb(G2STAT(base)),adapstat,\n\t\t\t\t       inb(G2INTST(base)), number_serviced++);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsgptr = (struct aha1740_sg *) SCtmp->host_scribble;\n\t\t\tscsi_dma_unmap(SCtmp);\n\n\t\t\t \n\t\t\tdma_free_coherent (&edev->dev,\n\t\t\t\t\t   sizeof (struct aha1740_sg),\n\t\t\t\t\t   SCtmp->host_scribble,\n\t\t\t\t\t   sgptr->sg_dma_addr);\n\t    \n\t\t\t \n\t\t\tif ( (adapstat & G2INTST_MASK) == G2INTST_CCBERROR ) {\n\t\t\t\tmemcpy_and_pad(SCtmp->sense_buffer,\n\t\t\t\t\t       SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t\t       ecbptr->sense,\n\t\t\t\t\t       sizeof(ecbptr->sense),\n\t\t\t\t\t       0);\n\t\t\t\terrstatus = aha1740_makecode(ecbptr->sense,ecbptr->status);\n\t\t\t} else\n\t\t\t\terrstatus = 0;\n\t\t\tDEB(if (errstatus)\n\t\t\t    printk(\"aha1740_intr_handle: returning %6x\\n\",\n\t\t\t\t   errstatus));\n\t\t\tSCtmp->result = errstatus;\n\t\t\tmy_done = ecbptr->done;\n\t\t\tmemset(ecbptr,0,sizeof(struct ecb)); \n\t\t\tif ( my_done )\n\t\t\t\tmy_done(SCtmp);\n\t\t\tbreak;\n\t\t\t\n\t\tcase\tG2INTST_HARDFAIL:\n\t\t\tprintk(KERN_ALERT \"aha1740 hardware failure!\\n\");\n\t\t\tpanic(\"aha1740.c\");\t \n\t\t\t\n\t\tcase\tG2INTST_ASNEVENT:\n\t\t\tprintk(\"aha1740 asynchronous event: %02x %02x %02x %02x %02x\\n\",\n\t\t\t       adapstat,\n\t\t\t       inb(MBOXIN0(base)),\n\t\t\t       inb(MBOXIN1(base)),\n\t\t\t       inb(MBOXIN2(base)),\n\t\t\t       inb(MBOXIN3(base)));  \n\t\t\t \n\t\t\toutb(G2CNTRL_HRDY,G2CNTRL(base));\n\t\t\tbreak;\n\t\t\t\n\t\tcase\tG2INTST_CMDGOOD:\n\t\t\t \n\t\t\tbreak;\n\t\t\t\n\t\tcase\tG2INTST_CMDERROR:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tnumber_serviced++;\n\t}\n\n\tspin_unlock_irqrestore(host->host_lock, flags);\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic int aha1740_queuecommand_lck(struct scsi_cmnd *SCpnt)\n{\n\tvoid (*done)(struct scsi_cmnd *) = scsi_done;\n\tunchar direction;\n\tunchar *cmd = (unchar *) SCpnt->cmnd;\n\tunchar target = scmd_id(SCpnt);\n\tstruct aha1740_hostdata *host = HOSTDATA(SCpnt->device->host);\n\tunsigned long flags;\n\tdma_addr_t sg_dma;\n\tstruct aha1740_sg *sgptr;\n\tint ecbno, nseg;\n\tDEB(int i);\n\n\tif(*cmd == REQUEST_SENSE) {\n\t\tSCpnt->result = 0;\n\t\tdone(SCpnt); \n\t\treturn 0;\n\t}\n\n#ifdef DEBUG\n\tif (*cmd == READ_10 || *cmd == WRITE_10)\n\t\ti = xscsi2int(cmd+2);\n\telse if (*cmd == READ_6 || *cmd == WRITE_6)\n\t\ti = scsi2int(cmd+2);\n\telse\n\t\ti = -1;\n\tprintk(\"aha1740_queuecommand: dev %d cmd %02x pos %d len %d \",\n\t       target, *cmd, i, bufflen);\n\tprintk(\"scsi cmd:\");\n\tfor (i = 0; i < SCpnt->cmd_len; i++) printk(\"%02x \", cmd[i]);\n\tprintk(\"\\n\");\n#endif\n\n\t \n\tspin_lock_irqsave(SCpnt->device->host->host_lock, flags);\n\tecbno = host->last_ecb_used + 1;  \n\tif (ecbno >= AHA1740_ECBS)\n\t\tecbno = 0;\n\tdo {\n\t\tif (!host->ecb[ecbno].cmdw)\n\t\t\tbreak;\n\t\tecbno++;\n\t\tif (ecbno >= AHA1740_ECBS)\n\t\t\tecbno = 0;\n\t} while (ecbno != host->last_ecb_used);\n\n\tif (host->ecb[ecbno].cmdw)\n\t\tpanic(\"Unable to find empty ecb for aha1740.\\n\");\n\n\thost->ecb[ecbno].cmdw = AHA1740CMD_INIT;  \n\n\thost->last_ecb_used = ecbno;    \n\tspin_unlock_irqrestore(SCpnt->device->host->host_lock, flags);\n\n#ifdef DEBUG\n\tprintk(\"Sending command (%d %x)...\", ecbno, done);\n#endif\n\n\thost->ecb[ecbno].cdblen = SCpnt->cmd_len;  \n\n\tdirection = 0;\n\tif (*cmd == READ_10 || *cmd == READ_6)\n\t\tdirection = 1;\n\telse if (*cmd == WRITE_10 || *cmd == WRITE_6)\n\t\tdirection = 0;\n\n\tmemcpy(host->ecb[ecbno].cdb, cmd, SCpnt->cmd_len);\n\n\tSCpnt->host_scribble = dma_alloc_coherent (&host->edev->dev,\n\t\t\t\t\t\t   sizeof (struct aha1740_sg),\n\t\t\t\t\t\t   &sg_dma, GFP_ATOMIC);\n\tif(SCpnt->host_scribble == NULL) {\n\t\tprintk(KERN_WARNING \"aha1740: out of memory in queuecommand!\\n\");\n\t\treturn 1;\n\t}\n\tsgptr = (struct aha1740_sg *) SCpnt->host_scribble;\n\tsgptr->sg_dma_addr = sg_dma;\n\n\tnseg = scsi_dma_map(SCpnt);\n\tBUG_ON(nseg < 0);\n\tif (nseg) {\n\t\tstruct scatterlist *sg;\n\t\tstruct aha1740_chain * cptr;\n\t\tint i;\n\t\tDEB(unsigned char * ptr);\n\n\t\thost->ecb[ecbno].sg = 1;   \n\t\tcptr = sgptr->sg_chain;\n\t\tscsi_for_each_sg(SCpnt, sg, nseg, i) {\n\t\t\tcptr[i].datalen = sg_dma_len (sg);\n\t\t\tcptr[i].dataptr = sg_dma_address (sg);\n\t\t}\n\t\thost->ecb[ecbno].datalen = nseg * sizeof(struct aha1740_chain);\n\t\thost->ecb[ecbno].dataptr = sg_dma;\n#ifdef DEBUG\n\t\tprintk(\"cptr %x: \",cptr);\n\t\tptr = (unsigned char *) cptr;\n\t\tfor(i=0;i<24;i++) printk(\"%02x \", ptr[i]);\n#endif\n\t} else {\n\t\thost->ecb[ecbno].datalen = 0;\n\t\thost->ecb[ecbno].dataptr = 0;\n\t}\n\thost->ecb[ecbno].lun = SCpnt->device->lun;\n\thost->ecb[ecbno].ses = 1;  \n\thost->ecb[ecbno].dir = direction;\n\thost->ecb[ecbno].ars = 1;  \n\thost->ecb[ecbno].senselen = 12;\n\thost->ecb[ecbno].senseptr = ecb_cpu_to_dma (SCpnt->device->host,\n\t\t\t\t\t\t    host->ecb[ecbno].sense);\n\thost->ecb[ecbno].statusptr = ecb_cpu_to_dma (SCpnt->device->host,\n\t\t\t\t\t\t     host->ecb[ecbno].status);\n\thost->ecb[ecbno].done = done;\n\thost->ecb[ecbno].SCpnt = SCpnt;\n#ifdef DEBUG\n\t{\n\t\tint i;\n\t\tprintk(\"aha1740_command: sending.. \");\n\t\tfor (i = 0; i < sizeof(host->ecb[ecbno]) - 10; i++)\n\t\t\tprintk(\"%02x \", ((unchar *)&host->ecb[ecbno])[i]);\n\t}\n\tprintk(\"\\n\");\n#endif\n\tif (done) {\n\t \n\n#define LOOPCNT_WARN 10\t\t \n#define LOOPCNT_MAX 1000000\t \n\t\tint loopcnt;\n\t\tunsigned int base = SCpnt->device->host->io_port;\n\t\tDEB(printk(\"aha1740[%d] critical section\\n\",ecbno));\n\n\t\tspin_lock_irqsave(SCpnt->device->host->host_lock, flags);\n\t\tfor (loopcnt = 0; ; loopcnt++) {\n\t\t\tif (inb(G2STAT(base)) & G2STAT_MBXOUT) break;\n\t\t\tif (loopcnt == LOOPCNT_WARN) {\n\t\t\t\tprintk(\"aha1740[%d]_mbxout wait!\\n\",ecbno);\n\t\t\t}\n\t\t\tif (loopcnt == LOOPCNT_MAX)\n\t\t\t\tpanic(\"aha1740.c: mbxout busy!\\n\");\n\t\t}\n\t\toutl (ecb_cpu_to_dma (SCpnt->device->host, host->ecb + ecbno),\n\t\t      MBOXOUT0(base));\n\t\tfor (loopcnt = 0; ; loopcnt++) {\n\t\t\tif (! (inb(G2STAT(base)) & G2STAT_BUSY)) break;\n\t\t\tif (loopcnt == LOOPCNT_WARN) {\n\t\t\t\tprintk(\"aha1740[%d]_attn wait!\\n\",ecbno);\n\t\t\t}\n\t\t\tif (loopcnt == LOOPCNT_MAX)\n\t\t\t\tpanic(\"aha1740.c: attn wait failed!\\n\");\n\t\t}\n\t\toutb(ATTN_START | (target & 7), ATTN(base));  \n\t\tspin_unlock_irqrestore(SCpnt->device->host->host_lock, flags);\n\t\tDEB(printk(\"aha1740[%d] request queued.\\n\",ecbno));\n\t} else\n\t\tprintk(KERN_ALERT \"aha1740_queuecommand: done can't be NULL\\n\");\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(aha1740_queuecommand)\n\n \n\nstatic void aha1740_getconfig(unsigned int base, unsigned int *irq_level,\n\t\t\t      unsigned int *irq_type,\n\t\t\t      unsigned int *translation)\n{\n\tstatic int intab[] = { 9, 10, 11, 12, 0, 14, 15, 0 };\n\n\t*irq_level = intab[inb(INTDEF(base)) & 0x7];\n\t*irq_type  = (inb(INTDEF(base)) & 0x8) >> 3;\n\t*translation = inb(RESV1(base)) & 0x1;\n\toutb(inb(INTDEF(base)) | 0x10, INTDEF(base));\n}\n\nstatic int aha1740_biosparam(struct scsi_device *sdev,\n\t\t\t     struct block_device *dev,\n\t\t\t     sector_t capacity, int* ip)\n{\n\tint size = capacity;\n\tint extended = HOSTDATA(sdev->host)->translation;\n\n\tDEB(printk(\"aha1740_biosparam\\n\"));\n\tif (extended && (ip[2] > 1024))\t{\n\t\tip[0] = 255;\n\t\tip[1] = 63;\n\t\tip[2] = size / (255 * 63);\n\t} else {\n\t\tip[0] = 64;\n\t\tip[1] = 32;\n\t\tip[2] = size >> 11;\n\t}\n\treturn 0;\n}\n\nstatic int aha1740_eh_abort_handler (struct scsi_cmnd *dummy)\n{\n \n\n\treturn SUCCESS;\n}\n\nstatic const struct scsi_host_template aha1740_template = {\n\t.module           = THIS_MODULE,\n\t.proc_name        = \"aha1740\",\n\t.show_info        = aha1740_show_info,\n\t.name             = \"Adaptec 174x (EISA)\",\n\t.queuecommand     = aha1740_queuecommand,\n\t.bios_param       = aha1740_biosparam,\n\t.can_queue        = AHA1740_ECBS,\n\t.this_id          = 7,\n\t.sg_tablesize     = AHA1740_SCATTER,\n\t.eh_abort_handler = aha1740_eh_abort_handler,\n};\n\nstatic int aha1740_probe (struct device *dev)\n{\n\tint slotbase, rc;\n\tunsigned int irq_level, irq_type, translation;\n\tstruct Scsi_Host *shpnt;\n\tstruct aha1740_hostdata *host;\n\tstruct eisa_device *edev = to_eisa_device (dev);\n\n\tDEB(printk(\"aha1740_probe: \\n\"));\n\t\n\tslotbase = edev->base_addr + EISA_VENDOR_ID_OFFSET;\n\tif (!request_region(slotbase, SLOTSIZE, \"aha1740\"))  \n\t\treturn -EBUSY;\n\tif (!aha1740_test_port(slotbase))\n\t\tgoto err_release_region;\n\taha1740_getconfig(slotbase,&irq_level,&irq_type,&translation);\n\tif ((inb(G2STAT(slotbase)) &\n\t     (G2STAT_MBXOUT|G2STAT_BUSY)) != G2STAT_MBXOUT) {\n\t\t \n\t\toutb(G2CNTRL_HRST, G2CNTRL(slotbase));\n\t\toutb(0, G2CNTRL(slotbase));\n\t}\n\tprintk(KERN_INFO \"Configuring slot %d at IO:%x, IRQ %u (%s)\\n\",\n\t       edev->slot, slotbase, irq_level, irq_type ? \"edge\" : \"level\");\n\tprintk(KERN_INFO \"aha174x: Extended translation %sabled.\\n\",\n\t       translation ? \"en\" : \"dis\");\n\tshpnt = scsi_host_alloc(&aha1740_template,\n\t\t\t      sizeof(struct aha1740_hostdata));\n\tif(shpnt == NULL)\n\t\tgoto err_release_region;\n\n\tshpnt->base = 0;\n\tshpnt->io_port = slotbase;\n\tshpnt->n_io_port = SLOTSIZE;\n\tshpnt->irq = irq_level;\n\tshpnt->dma_channel = 0xff;\n\thost = HOSTDATA(shpnt);\n\thost->edev = edev;\n\thost->translation = translation;\n\thost->ecb_dma_addr = dma_map_single (&edev->dev, host->ecb,\n\t\t\t\t\t     sizeof (host->ecb),\n\t\t\t\t\t     DMA_BIDIRECTIONAL);\n\tif (!host->ecb_dma_addr) {\n\t\tprintk (KERN_ERR \"aha1740_probe: Couldn't map ECB, giving up\\n\");\n\t\tgoto err_host_put;\n\t}\n\t\n\tDEB(printk(\"aha1740_probe: enable interrupt channel %d\\n\",irq_level));\n\tif (request_irq(irq_level,aha1740_intr_handle,irq_type ? 0 : IRQF_SHARED,\n\t\t\t\"aha1740\",shpnt)) {\n\t\tprintk(KERN_ERR \"aha1740_probe: Unable to allocate IRQ %d.\\n\",\n\t\t       irq_level);\n\t\tgoto err_unmap;\n\t}\n\n\teisa_set_drvdata (edev, shpnt);\n\n\trc = scsi_add_host (shpnt, dev);\n\tif (rc)\n\t\tgoto err_irq;\n\n\tscsi_scan_host (shpnt);\n\treturn 0;\n\n err_irq:\n \tfree_irq(irq_level, shpnt);\n err_unmap:\n\tdma_unmap_single (&edev->dev, host->ecb_dma_addr,\n\t\t\t  sizeof (host->ecb), DMA_BIDIRECTIONAL);\n err_host_put:\n\tscsi_host_put (shpnt);\n err_release_region:\n\trelease_region(slotbase, SLOTSIZE);\n\n\treturn -ENODEV;\n}\n\nstatic int aha1740_remove (struct device *dev)\n{\n\tstruct Scsi_Host *shpnt = dev_get_drvdata(dev);\n\tstruct aha1740_hostdata *host = HOSTDATA (shpnt);\n\n\tscsi_remove_host(shpnt);\n\t\n\tfree_irq (shpnt->irq, shpnt);\n\tdma_unmap_single (dev, host->ecb_dma_addr,\n\t\t\t  sizeof (host->ecb), DMA_BIDIRECTIONAL);\n\trelease_region (shpnt->io_port, SLOTSIZE);\n\n\tscsi_host_put (shpnt);\n\t\n\treturn 0;\n}\n\nstatic struct eisa_device_id aha1740_ids[] = {\n\t{ \"ADP0000\" },\t\t \n\t{ \"ADP0001\" },\t\t \n\t{ \"ADP0002\" },\t\t \n\t{ \"ADP0400\" },\t\t \n\t{ \"\" }\n};\nMODULE_DEVICE_TABLE(eisa, aha1740_ids);\n\nstatic struct eisa_driver aha1740_driver = {\n\t.id_table = aha1740_ids,\n\t.driver   = {\n\t\t.name    = \"aha1740\",\n\t\t.probe   = aha1740_probe,\n\t\t.remove  = aha1740_remove,\n\t},\n};\n\nstatic __init int aha1740_init (void)\n{\n\treturn eisa_driver_register (&aha1740_driver);\n}\n\nstatic __exit void aha1740_exit (void)\n{\n\teisa_driver_unregister (&aha1740_driver);\n}\n\nmodule_init (aha1740_init);\nmodule_exit (aha1740_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}