{
  "module_name": "hptiop.c",
  "hash_id": "eacec181925bc13fffb8860c418a8a844555359dd80b0dca582d0df79c045d09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/hptiop.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/timer.h>\n#include <linux/spinlock.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include <asm/div64.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_host.h>\n\n#include \"hptiop.h\"\n\nMODULE_AUTHOR(\"HighPoint Technologies, Inc.\");\nMODULE_DESCRIPTION(\"HighPoint RocketRAID 3xxx/4xxx Controller Driver\");\n\nstatic char driver_name[] = \"hptiop\";\nstatic const char driver_name_long[] = \"RocketRAID 3xxx/4xxx Controller driver\";\nstatic const char driver_ver[] = \"v1.10.0\";\n\nstatic int iop_send_sync_msg(struct hptiop_hba *hba, u32 msg, u32 millisec);\nstatic void hptiop_finish_scsi_req(struct hptiop_hba *hba, u32 tag,\n\t\t\t\tstruct hpt_iop_request_scsi_command *req);\nstatic void hptiop_host_request_callback_itl(struct hptiop_hba *hba, u32 tag);\nstatic void hptiop_iop_request_callback_itl(struct hptiop_hba *hba, u32 tag);\nstatic void hptiop_message_callback(struct hptiop_hba *hba, u32 msg);\n\nstatic int iop_wait_ready_itl(struct hptiop_hba *hba, u32 millisec)\n{\n\tu32 req = 0;\n\tint i;\n\n\tfor (i = 0; i < millisec; i++) {\n\t\treq = readl(&hba->u.itl.iop->inbound_queue);\n\t\tif (req != IOPMU_QUEUE_EMPTY)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\n\tif (req != IOPMU_QUEUE_EMPTY) {\n\t\twritel(req, &hba->u.itl.iop->outbound_queue);\n\t\treadl(&hba->u.itl.iop->outbound_intstatus);\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic int iop_wait_ready_mv(struct hptiop_hba *hba, u32 millisec)\n{\n\treturn iop_send_sync_msg(hba, IOPMU_INBOUND_MSG0_NOP, millisec);\n}\n\nstatic int iop_wait_ready_mvfrey(struct hptiop_hba *hba, u32 millisec)\n{\n\treturn iop_send_sync_msg(hba, IOPMU_INBOUND_MSG0_NOP, millisec);\n}\n\nstatic void hptiop_request_callback_itl(struct hptiop_hba *hba, u32 tag)\n{\n\tif (tag & IOPMU_QUEUE_ADDR_HOST_BIT)\n\t\thptiop_host_request_callback_itl(hba,\n\t\t\t\ttag & ~IOPMU_QUEUE_ADDR_HOST_BIT);\n\telse\n\t\thptiop_iop_request_callback_itl(hba, tag);\n}\n\nstatic void hptiop_drain_outbound_queue_itl(struct hptiop_hba *hba)\n{\n\tu32 req;\n\n\twhile ((req = readl(&hba->u.itl.iop->outbound_queue)) !=\n\t\t\t\t\t\tIOPMU_QUEUE_EMPTY) {\n\n\t\tif (req & IOPMU_QUEUE_MASK_HOST_BITS)\n\t\t\thptiop_request_callback_itl(hba, req);\n\t\telse {\n\t\t\tstruct hpt_iop_request_header __iomem * p;\n\n\t\t\tp = (struct hpt_iop_request_header __iomem *)\n\t\t\t\t((char __iomem *)hba->u.itl.iop + req);\n\n\t\t\tif (readl(&p->flags) & IOP_REQUEST_FLAG_SYNC_REQUEST) {\n\t\t\t\tif (readl(&p->context))\n\t\t\t\t\thptiop_request_callback_itl(hba, req);\n\t\t\t\telse\n\t\t\t\t\twritel(1, &p->context);\n\t\t\t}\n\t\t\telse\n\t\t\t\thptiop_request_callback_itl(hba, req);\n\t\t}\n\t}\n}\n\nstatic int iop_intr_itl(struct hptiop_hba *hba)\n{\n\tstruct hpt_iopmu_itl __iomem *iop = hba->u.itl.iop;\n\tvoid __iomem *plx = hba->u.itl.plx;\n\tu32 status;\n\tint ret = 0;\n\n\tif (plx && readl(plx + 0x11C5C) & 0xf)\n\t\twritel(1, plx + 0x11C60);\n\n\tstatus = readl(&iop->outbound_intstatus);\n\n\tif (status & IOPMU_OUTBOUND_INT_MSG0) {\n\t\tu32 msg = readl(&iop->outbound_msgaddr0);\n\n\t\tdprintk(\"received outbound msg %x\\n\", msg);\n\t\twritel(IOPMU_OUTBOUND_INT_MSG0, &iop->outbound_intstatus);\n\t\thptiop_message_callback(hba, msg);\n\t\tret = 1;\n\t}\n\n\tif (status & IOPMU_OUTBOUND_INT_POSTQUEUE) {\n\t\thptiop_drain_outbound_queue_itl(hba);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic u64 mv_outbound_read(struct hpt_iopmu_mv __iomem *mu)\n{\n\tu32 outbound_tail = readl(&mu->outbound_tail);\n\tu32 outbound_head = readl(&mu->outbound_head);\n\n\tif (outbound_tail != outbound_head) {\n\t\tu64 p;\n\n\t\tmemcpy_fromio(&p, &mu->outbound_q[mu->outbound_tail], 8);\n\t\toutbound_tail++;\n\n\t\tif (outbound_tail == MVIOP_QUEUE_LEN)\n\t\t\toutbound_tail = 0;\n\t\twritel(outbound_tail, &mu->outbound_tail);\n\t\treturn p;\n\t} else\n\t\treturn 0;\n}\n\nstatic void mv_inbound_write(u64 p, struct hptiop_hba *hba)\n{\n\tu32 inbound_head = readl(&hba->u.mv.mu->inbound_head);\n\tu32 head = inbound_head + 1;\n\n\tif (head == MVIOP_QUEUE_LEN)\n\t\thead = 0;\n\n\tmemcpy_toio(&hba->u.mv.mu->inbound_q[inbound_head], &p, 8);\n\twritel(head, &hba->u.mv.mu->inbound_head);\n\twritel(MVIOP_MU_INBOUND_INT_POSTQUEUE,\n\t\t\t&hba->u.mv.regs->inbound_doorbell);\n}\n\nstatic void hptiop_request_callback_mv(struct hptiop_hba *hba, u64 tag)\n{\n\tu32 req_type = (tag >> 5) & 0x7;\n\tstruct hpt_iop_request_scsi_command *req;\n\n\tdprintk(\"hptiop_request_callback_mv: tag=%llx\\n\", tag);\n\n\tBUG_ON((tag & MVIOP_MU_QUEUE_REQUEST_RETURN_CONTEXT) == 0);\n\n\tswitch (req_type) {\n\tcase IOP_REQUEST_TYPE_GET_CONFIG:\n\tcase IOP_REQUEST_TYPE_SET_CONFIG:\n\t\thba->msg_done = 1;\n\t\tbreak;\n\n\tcase IOP_REQUEST_TYPE_SCSI_COMMAND:\n\t\treq = hba->reqs[tag >> 8].req_virt;\n\t\tif (likely(tag & MVIOP_MU_QUEUE_REQUEST_RESULT_BIT))\n\t\t\treq->header.result = cpu_to_le32(IOP_RESULT_SUCCESS);\n\n\t\thptiop_finish_scsi_req(hba, tag>>8, req);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int iop_intr_mv(struct hptiop_hba *hba)\n{\n\tu32 status;\n\tint ret = 0;\n\n\tstatus = readl(&hba->u.mv.regs->outbound_doorbell);\n\twritel(~status, &hba->u.mv.regs->outbound_doorbell);\n\n\tif (status & MVIOP_MU_OUTBOUND_INT_MSG) {\n\t\tu32 msg;\n\t\tmsg = readl(&hba->u.mv.mu->outbound_msg);\n\t\tdprintk(\"received outbound msg %x\\n\", msg);\n\t\thptiop_message_callback(hba, msg);\n\t\tret = 1;\n\t}\n\n\tif (status & MVIOP_MU_OUTBOUND_INT_POSTQUEUE) {\n\t\tu64 tag;\n\n\t\twhile ((tag = mv_outbound_read(hba->u.mv.mu)))\n\t\t\thptiop_request_callback_mv(hba, tag);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic void hptiop_request_callback_mvfrey(struct hptiop_hba *hba, u32 _tag)\n{\n\tu32 req_type = _tag & 0xf;\n\tstruct hpt_iop_request_scsi_command *req;\n\n\tswitch (req_type) {\n\tcase IOP_REQUEST_TYPE_GET_CONFIG:\n\tcase IOP_REQUEST_TYPE_SET_CONFIG:\n\t\thba->msg_done = 1;\n\t\tbreak;\n\n\tcase IOP_REQUEST_TYPE_SCSI_COMMAND:\n\t\treq = hba->reqs[(_tag >> 4) & 0xff].req_virt;\n\t\tif (likely(_tag & IOPMU_QUEUE_REQUEST_RESULT_BIT))\n\t\t\treq->header.result = IOP_RESULT_SUCCESS;\n\t\thptiop_finish_scsi_req(hba, (_tag >> 4) & 0xff, req);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int iop_intr_mvfrey(struct hptiop_hba *hba)\n{\n\tu32 _tag, status, cptr, cur_rptr;\n\tint ret = 0;\n\n\tif (hba->initialized)\n\t\twritel(0, &(hba->u.mvfrey.mu->pcie_f0_int_enable));\n\n\tstatus = readl(&(hba->u.mvfrey.mu->f0_doorbell));\n\tif (status) {\n\t\twritel(status, &(hba->u.mvfrey.mu->f0_doorbell));\n\t\tif (status & CPU_TO_F0_DRBL_MSG_BIT) {\n\t\t\tu32 msg = readl(&(hba->u.mvfrey.mu->cpu_to_f0_msg_a));\n\t\t\tdprintk(\"received outbound msg %x\\n\", msg);\n\t\t\thptiop_message_callback(hba, msg);\n\t\t}\n\t\tret = 1;\n\t}\n\n\tstatus = readl(&(hba->u.mvfrey.mu->isr_cause));\n\tif (status) {\n\t\twritel(status, &(hba->u.mvfrey.mu->isr_cause));\n\t\tdo {\n\t\t\tcptr = *hba->u.mvfrey.outlist_cptr & 0xff;\n\t\t\tcur_rptr = hba->u.mvfrey.outlist_rptr;\n\t\t\twhile (cur_rptr != cptr) {\n\t\t\t\tcur_rptr++;\n\t\t\t\tif (cur_rptr ==\thba->u.mvfrey.list_count)\n\t\t\t\t\tcur_rptr = 0;\n\n\t\t\t\t_tag = hba->u.mvfrey.outlist[cur_rptr].val;\n\t\t\t\tBUG_ON(!(_tag & IOPMU_QUEUE_MASK_HOST_BITS));\n\t\t\t\thptiop_request_callback_mvfrey(hba, _tag);\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\thba->u.mvfrey.outlist_rptr = cur_rptr;\n\t\t} while (cptr != (*hba->u.mvfrey.outlist_cptr & 0xff));\n\t}\n\n\tif (hba->initialized)\n\t\twritel(0x1010, &(hba->u.mvfrey.mu->pcie_f0_int_enable));\n\n\treturn ret;\n}\n\nstatic int iop_send_sync_request_itl(struct hptiop_hba *hba,\n\t\t\t\t\tvoid __iomem *_req, u32 millisec)\n{\n\tstruct hpt_iop_request_header __iomem *req = _req;\n\tu32 i;\n\n\twritel(readl(&req->flags) | IOP_REQUEST_FLAG_SYNC_REQUEST, &req->flags);\n\twritel(0, &req->context);\n\twritel((unsigned long)req - (unsigned long)hba->u.itl.iop,\n\t\t\t&hba->u.itl.iop->inbound_queue);\n\treadl(&hba->u.itl.iop->outbound_intstatus);\n\n\tfor (i = 0; i < millisec; i++) {\n\t\tiop_intr_itl(hba);\n\t\tif (readl(&req->context))\n\t\t\treturn 0;\n\t\tmsleep(1);\n\t}\n\n\treturn -1;\n}\n\nstatic int iop_send_sync_request_mv(struct hptiop_hba *hba,\n\t\t\t\t\tu32 size_bits, u32 millisec)\n{\n\tstruct hpt_iop_request_header *reqhdr = hba->u.mv.internal_req;\n\tu32 i;\n\n\thba->msg_done = 0;\n\treqhdr->flags |= cpu_to_le32(IOP_REQUEST_FLAG_SYNC_REQUEST);\n\tmv_inbound_write(hba->u.mv.internal_req_phy |\n\t\t\tMVIOP_MU_QUEUE_ADDR_HOST_BIT | size_bits, hba);\n\n\tfor (i = 0; i < millisec; i++) {\n\t\tiop_intr_mv(hba);\n\t\tif (hba->msg_done)\n\t\t\treturn 0;\n\t\tmsleep(1);\n\t}\n\treturn -1;\n}\n\nstatic int iop_send_sync_request_mvfrey(struct hptiop_hba *hba,\n\t\t\t\t\tu32 size_bits, u32 millisec)\n{\n\tstruct hpt_iop_request_header *reqhdr =\n\t\thba->u.mvfrey.internal_req.req_virt;\n\tu32 i;\n\n\thba->msg_done = 0;\n\treqhdr->flags |= cpu_to_le32(IOP_REQUEST_FLAG_SYNC_REQUEST);\n\thba->ops->post_req(hba, &(hba->u.mvfrey.internal_req));\n\n\tfor (i = 0; i < millisec; i++) {\n\t\tiop_intr_mvfrey(hba);\n\t\tif (hba->msg_done)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\treturn hba->msg_done ? 0 : -1;\n}\n\nstatic void hptiop_post_msg_itl(struct hptiop_hba *hba, u32 msg)\n{\n\twritel(msg, &hba->u.itl.iop->inbound_msgaddr0);\n\treadl(&hba->u.itl.iop->outbound_intstatus);\n}\n\nstatic void hptiop_post_msg_mv(struct hptiop_hba *hba, u32 msg)\n{\n\twritel(msg, &hba->u.mv.mu->inbound_msg);\n\twritel(MVIOP_MU_INBOUND_INT_MSG, &hba->u.mv.regs->inbound_doorbell);\n\treadl(&hba->u.mv.regs->inbound_doorbell);\n}\n\nstatic void hptiop_post_msg_mvfrey(struct hptiop_hba *hba, u32 msg)\n{\n\twritel(msg, &(hba->u.mvfrey.mu->f0_to_cpu_msg_a));\n\treadl(&(hba->u.mvfrey.mu->f0_to_cpu_msg_a));\n}\n\nstatic int iop_send_sync_msg(struct hptiop_hba *hba, u32 msg, u32 millisec)\n{\n\tu32 i;\n\n\thba->msg_done = 0;\n\thba->ops->disable_intr(hba);\n\thba->ops->post_msg(hba, msg);\n\n\tfor (i = 0; i < millisec; i++) {\n\t\tspin_lock_irq(hba->host->host_lock);\n\t\thba->ops->iop_intr(hba);\n\t\tspin_unlock_irq(hba->host->host_lock);\n\t\tif (hba->msg_done)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\n\thba->ops->enable_intr(hba);\n\treturn hba->msg_done? 0 : -1;\n}\n\nstatic int iop_get_config_itl(struct hptiop_hba *hba,\n\t\t\t\tstruct hpt_iop_request_get_config *config)\n{\n\tu32 req32;\n\tstruct hpt_iop_request_get_config __iomem *req;\n\n\treq32 = readl(&hba->u.itl.iop->inbound_queue);\n\tif (req32 == IOPMU_QUEUE_EMPTY)\n\t\treturn -1;\n\n\treq = (struct hpt_iop_request_get_config __iomem *)\n\t\t\t((unsigned long)hba->u.itl.iop + req32);\n\n\twritel(0, &req->header.flags);\n\twritel(IOP_REQUEST_TYPE_GET_CONFIG, &req->header.type);\n\twritel(sizeof(struct hpt_iop_request_get_config), &req->header.size);\n\twritel(IOP_RESULT_PENDING, &req->header.result);\n\n\tif (iop_send_sync_request_itl(hba, req, 20000)) {\n\t\tdprintk(\"Get config send cmd failed\\n\");\n\t\treturn -1;\n\t}\n\n\tmemcpy_fromio(config, req, sizeof(*config));\n\twritel(req32, &hba->u.itl.iop->outbound_queue);\n\treturn 0;\n}\n\nstatic int iop_get_config_mv(struct hptiop_hba *hba,\n\t\t\t\tstruct hpt_iop_request_get_config *config)\n{\n\tstruct hpt_iop_request_get_config *req = hba->u.mv.internal_req;\n\n\treq->header.flags = cpu_to_le32(IOP_REQUEST_FLAG_OUTPUT_CONTEXT);\n\treq->header.type = cpu_to_le32(IOP_REQUEST_TYPE_GET_CONFIG);\n\treq->header.size =\n\t\tcpu_to_le32(sizeof(struct hpt_iop_request_get_config));\n\treq->header.result = cpu_to_le32(IOP_RESULT_PENDING);\n\treq->header.context = cpu_to_le32(IOP_REQUEST_TYPE_GET_CONFIG<<5);\n\treq->header.context_hi32 = 0;\n\n\tif (iop_send_sync_request_mv(hba, 0, 20000)) {\n\t\tdprintk(\"Get config send cmd failed\\n\");\n\t\treturn -1;\n\t}\n\n\tmemcpy(config, req, sizeof(struct hpt_iop_request_get_config));\n\treturn 0;\n}\n\nstatic int iop_get_config_mvfrey(struct hptiop_hba *hba,\n\t\t\t\tstruct hpt_iop_request_get_config *config)\n{\n\tstruct hpt_iop_request_get_config *info = hba->u.mvfrey.config;\n\n\tif (info->header.size != sizeof(struct hpt_iop_request_get_config) ||\n\t\t\tinfo->header.type != IOP_REQUEST_TYPE_GET_CONFIG)\n\t\treturn -1;\n\n\tconfig->interface_version = info->interface_version;\n\tconfig->firmware_version = info->firmware_version;\n\tconfig->max_requests = info->max_requests;\n\tconfig->request_size = info->request_size;\n\tconfig->max_sg_count = info->max_sg_count;\n\tconfig->data_transfer_length = info->data_transfer_length;\n\tconfig->alignment_mask = info->alignment_mask;\n\tconfig->max_devices = info->max_devices;\n\tconfig->sdram_size = info->sdram_size;\n\n\treturn 0;\n}\n\nstatic int iop_set_config_itl(struct hptiop_hba *hba,\n\t\t\t\tstruct hpt_iop_request_set_config *config)\n{\n\tu32 req32;\n\tstruct hpt_iop_request_set_config __iomem *req;\n\n\treq32 = readl(&hba->u.itl.iop->inbound_queue);\n\tif (req32 == IOPMU_QUEUE_EMPTY)\n\t\treturn -1;\n\n\treq = (struct hpt_iop_request_set_config __iomem *)\n\t\t\t((unsigned long)hba->u.itl.iop + req32);\n\n\tmemcpy_toio((u8 __iomem *)req + sizeof(struct hpt_iop_request_header),\n\t\t(u8 *)config + sizeof(struct hpt_iop_request_header),\n\t\tsizeof(struct hpt_iop_request_set_config) -\n\t\t\tsizeof(struct hpt_iop_request_header));\n\n\twritel(0, &req->header.flags);\n\twritel(IOP_REQUEST_TYPE_SET_CONFIG, &req->header.type);\n\twritel(sizeof(struct hpt_iop_request_set_config), &req->header.size);\n\twritel(IOP_RESULT_PENDING, &req->header.result);\n\n\tif (iop_send_sync_request_itl(hba, req, 20000)) {\n\t\tdprintk(\"Set config send cmd failed\\n\");\n\t\treturn -1;\n\t}\n\n\twritel(req32, &hba->u.itl.iop->outbound_queue);\n\treturn 0;\n}\n\nstatic int iop_set_config_mv(struct hptiop_hba *hba,\n\t\t\t\tstruct hpt_iop_request_set_config *config)\n{\n\tstruct hpt_iop_request_set_config *req = hba->u.mv.internal_req;\n\n\tmemcpy(req, config, sizeof(struct hpt_iop_request_set_config));\n\treq->header.flags = cpu_to_le32(IOP_REQUEST_FLAG_OUTPUT_CONTEXT);\n\treq->header.type = cpu_to_le32(IOP_REQUEST_TYPE_SET_CONFIG);\n\treq->header.size =\n\t\tcpu_to_le32(sizeof(struct hpt_iop_request_set_config));\n\treq->header.result = cpu_to_le32(IOP_RESULT_PENDING);\n\treq->header.context = cpu_to_le32(IOP_REQUEST_TYPE_SET_CONFIG<<5);\n\treq->header.context_hi32 = 0;\n\n\tif (iop_send_sync_request_mv(hba, 0, 20000)) {\n\t\tdprintk(\"Set config send cmd failed\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int iop_set_config_mvfrey(struct hptiop_hba *hba,\n\t\t\t\tstruct hpt_iop_request_set_config *config)\n{\n\tstruct hpt_iop_request_set_config *req =\n\t\thba->u.mvfrey.internal_req.req_virt;\n\n\tmemcpy(req, config, sizeof(struct hpt_iop_request_set_config));\n\treq->header.flags = cpu_to_le32(IOP_REQUEST_FLAG_OUTPUT_CONTEXT);\n\treq->header.type = cpu_to_le32(IOP_REQUEST_TYPE_SET_CONFIG);\n\treq->header.size =\n\t\tcpu_to_le32(sizeof(struct hpt_iop_request_set_config));\n\treq->header.result = cpu_to_le32(IOP_RESULT_PENDING);\n\treq->header.context = cpu_to_le32(IOP_REQUEST_TYPE_SET_CONFIG<<5);\n\treq->header.context_hi32 = 0;\n\n\tif (iop_send_sync_request_mvfrey(hba, 0, 20000)) {\n\t\tdprintk(\"Set config send cmd failed\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void hptiop_enable_intr_itl(struct hptiop_hba *hba)\n{\n\twritel(~(IOPMU_OUTBOUND_INT_POSTQUEUE | IOPMU_OUTBOUND_INT_MSG0),\n\t\t&hba->u.itl.iop->outbound_intmask);\n}\n\nstatic void hptiop_enable_intr_mv(struct hptiop_hba *hba)\n{\n\twritel(MVIOP_MU_OUTBOUND_INT_POSTQUEUE | MVIOP_MU_OUTBOUND_INT_MSG,\n\t\t&hba->u.mv.regs->outbound_intmask);\n}\n\nstatic void hptiop_enable_intr_mvfrey(struct hptiop_hba *hba)\n{\n\twritel(CPU_TO_F0_DRBL_MSG_BIT, &(hba->u.mvfrey.mu->f0_doorbell_enable));\n\twritel(0x1, &(hba->u.mvfrey.mu->isr_enable));\n\twritel(0x1010, &(hba->u.mvfrey.mu->pcie_f0_int_enable));\n}\n\nstatic int hptiop_initialize_iop(struct hptiop_hba *hba)\n{\n\t \n\thba->ops->enable_intr(hba);\n\n\thba->initialized = 1;\n\n\t \n\tif (iop_send_sync_msg(hba,\n\t\t\tIOPMU_INBOUND_MSG0_START_BACKGROUND_TASK, 5000)) {\n\t\tprintk(KERN_ERR \"scsi%d: fail to start background task\\n\",\n\t\t\thba->host->host_no);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void __iomem *hptiop_map_pci_bar(struct hptiop_hba *hba, int index)\n{\n\tu32 mem_base_phy, length;\n\tvoid __iomem *mem_base_virt;\n\n\tstruct pci_dev *pcidev = hba->pcidev;\n\n\n\tif (!(pci_resource_flags(pcidev, index) & IORESOURCE_MEM)) {\n\t\tprintk(KERN_ERR \"scsi%d: pci resource invalid\\n\",\n\t\t\t\thba->host->host_no);\n\t\treturn NULL;\n\t}\n\n\tmem_base_phy = pci_resource_start(pcidev, index);\n\tlength = pci_resource_len(pcidev, index);\n\tmem_base_virt = ioremap(mem_base_phy, length);\n\n\tif (!mem_base_virt) {\n\t\tprintk(KERN_ERR \"scsi%d: Fail to ioremap memory space\\n\",\n\t\t\t\thba->host->host_no);\n\t\treturn NULL;\n\t}\n\treturn mem_base_virt;\n}\n\nstatic int hptiop_map_pci_bar_itl(struct hptiop_hba *hba)\n{\n\tstruct pci_dev *pcidev = hba->pcidev;\n\thba->u.itl.iop = hptiop_map_pci_bar(hba, 0);\n\tif (hba->u.itl.iop == NULL)\n\t\treturn -1;\n\tif ((pcidev->device & 0xff00) == 0x4400) {\n\t\thba->u.itl.plx = hba->u.itl.iop;\n\t\thba->u.itl.iop = hptiop_map_pci_bar(hba, 2);\n\t\tif (hba->u.itl.iop == NULL) {\n\t\t\tiounmap(hba->u.itl.plx);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void hptiop_unmap_pci_bar_itl(struct hptiop_hba *hba)\n{\n\tif (hba->u.itl.plx)\n\t\tiounmap(hba->u.itl.plx);\n\tiounmap(hba->u.itl.iop);\n}\n\nstatic int hptiop_map_pci_bar_mv(struct hptiop_hba *hba)\n{\n\thba->u.mv.regs = hptiop_map_pci_bar(hba, 0);\n\tif (hba->u.mv.regs == NULL)\n\t\treturn -1;\n\n\thba->u.mv.mu = hptiop_map_pci_bar(hba, 2);\n\tif (hba->u.mv.mu == NULL) {\n\t\tiounmap(hba->u.mv.regs);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int hptiop_map_pci_bar_mvfrey(struct hptiop_hba *hba)\n{\n\thba->u.mvfrey.config = hptiop_map_pci_bar(hba, 0);\n\tif (hba->u.mvfrey.config == NULL)\n\t\treturn -1;\n\n\thba->u.mvfrey.mu = hptiop_map_pci_bar(hba, 2);\n\tif (hba->u.mvfrey.mu == NULL) {\n\t\tiounmap(hba->u.mvfrey.config);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void hptiop_unmap_pci_bar_mv(struct hptiop_hba *hba)\n{\n\tiounmap(hba->u.mv.regs);\n\tiounmap(hba->u.mv.mu);\n}\n\nstatic void hptiop_unmap_pci_bar_mvfrey(struct hptiop_hba *hba)\n{\n\tiounmap(hba->u.mvfrey.config);\n\tiounmap(hba->u.mvfrey.mu);\n}\n\nstatic void hptiop_message_callback(struct hptiop_hba *hba, u32 msg)\n{\n\tdprintk(\"iop message 0x%x\\n\", msg);\n\n\tif (msg == IOPMU_INBOUND_MSG0_NOP ||\n\t\tmsg == IOPMU_INBOUND_MSG0_RESET_COMM)\n\t\thba->msg_done = 1;\n\n\tif (!hba->initialized)\n\t\treturn;\n\n\tif (msg == IOPMU_INBOUND_MSG0_RESET) {\n\t\tatomic_set(&hba->resetting, 0);\n\t\twake_up(&hba->reset_wq);\n\t}\n\telse if (msg <= IOPMU_INBOUND_MSG0_MAX)\n\t\thba->msg_done = 1;\n}\n\nstatic struct hptiop_request *get_req(struct hptiop_hba *hba)\n{\n\tstruct hptiop_request *ret;\n\n\tdprintk(\"get_req : req=%p\\n\", hba->req_list);\n\n\tret = hba->req_list;\n\tif (ret)\n\t\thba->req_list = ret->next;\n\n\treturn ret;\n}\n\nstatic void free_req(struct hptiop_hba *hba, struct hptiop_request *req)\n{\n\tdprintk(\"free_req(%d, %p)\\n\", req->index, req);\n\treq->next = hba->req_list;\n\thba->req_list = req;\n}\n\nstatic void hptiop_finish_scsi_req(struct hptiop_hba *hba, u32 tag,\n\t\t\t\tstruct hpt_iop_request_scsi_command *req)\n{\n\tstruct scsi_cmnd *scp;\n\n\tdprintk(\"hptiop_finish_scsi_req: req=%p, type=%d, \"\n\t\t\t\"result=%d, context=0x%x tag=%d\\n\",\n\t\t\treq, req->header.type, req->header.result,\n\t\t\treq->header.context, tag);\n\n\tBUG_ON(!req->header.result);\n\tBUG_ON(req->header.type != cpu_to_le32(IOP_REQUEST_TYPE_SCSI_COMMAND));\n\n\tscp = hba->reqs[tag].scp;\n\n\tif (HPT_SCP(scp)->mapped)\n\t\tscsi_dma_unmap(scp);\n\n\tswitch (le32_to_cpu(req->header.result)) {\n\tcase IOP_RESULT_SUCCESS:\n\t\tscsi_set_resid(scp,\n\t\t\tscsi_bufflen(scp) - le32_to_cpu(req->dataxfer_length));\n\t\tscp->result = (DID_OK<<16);\n\t\tbreak;\n\tcase IOP_RESULT_BAD_TARGET:\n\t\tscp->result = (DID_BAD_TARGET<<16);\n\t\tbreak;\n\tcase IOP_RESULT_BUSY:\n\t\tscp->result = (DID_BUS_BUSY<<16);\n\t\tbreak;\n\tcase IOP_RESULT_RESET:\n\t\tscp->result = (DID_RESET<<16);\n\t\tbreak;\n\tcase IOP_RESULT_FAIL:\n\t\tscp->result = (DID_ERROR<<16);\n\t\tbreak;\n\tcase IOP_RESULT_INVALID_REQUEST:\n\t\tscp->result = (DID_ABORT<<16);\n\t\tbreak;\n\tcase IOP_RESULT_CHECK_CONDITION:\n\t\tscsi_set_resid(scp,\n\t\t\tscsi_bufflen(scp) - le32_to_cpu(req->dataxfer_length));\n\t\tscp->result = SAM_STAT_CHECK_CONDITION;\n\t\tmemcpy(scp->sense_buffer, &req->sg_list, SCSI_SENSE_BUFFERSIZE);\n\t\tgoto skip_resid;\n\n\tdefault:\n\t\tscp->result = DID_ABORT << 16;\n\t\tbreak;\n\t}\n\n\tscsi_set_resid(scp,\n\t\tscsi_bufflen(scp) - le32_to_cpu(req->dataxfer_length));\n\nskip_resid:\n\tdprintk(\"scsi_done(%p)\\n\", scp);\n\tscsi_done(scp);\n\tfree_req(hba, &hba->reqs[tag]);\n}\n\nstatic void hptiop_host_request_callback_itl(struct hptiop_hba *hba, u32 _tag)\n{\n\tstruct hpt_iop_request_scsi_command *req;\n\tu32 tag;\n\n\tif (hba->iopintf_v2) {\n\t\ttag = _tag & ~IOPMU_QUEUE_REQUEST_RESULT_BIT;\n\t\treq = hba->reqs[tag].req_virt;\n\t\tif (likely(_tag & IOPMU_QUEUE_REQUEST_RESULT_BIT))\n\t\t\treq->header.result = cpu_to_le32(IOP_RESULT_SUCCESS);\n\t} else {\n\t\ttag = _tag;\n\t\treq = hba->reqs[tag].req_virt;\n\t}\n\n\thptiop_finish_scsi_req(hba, tag, req);\n}\n\nstatic void hptiop_iop_request_callback_itl(struct hptiop_hba *hba, u32 tag)\n{\n\tstruct hpt_iop_request_header __iomem *req;\n\tstruct hpt_iop_request_ioctl_command __iomem *p;\n\tstruct hpt_ioctl_k *arg;\n\n\treq = (struct hpt_iop_request_header __iomem *)\n\t\t\t((unsigned long)hba->u.itl.iop + tag);\n\tdprintk(\"hptiop_iop_request_callback_itl: req=%p, type=%d, \"\n\t\t\t\"result=%d, context=0x%x tag=%d\\n\",\n\t\t\treq, readl(&req->type), readl(&req->result),\n\t\t\treadl(&req->context), tag);\n\n\tBUG_ON(!readl(&req->result));\n\tBUG_ON(readl(&req->type) != IOP_REQUEST_TYPE_IOCTL_COMMAND);\n\n\tp = (struct hpt_iop_request_ioctl_command __iomem *)req;\n\targ = (struct hpt_ioctl_k *)(unsigned long)\n\t\t(readl(&req->context) |\n\t\t\t((u64)readl(&req->context_hi32)<<32));\n\n\tif (readl(&req->result) == IOP_RESULT_SUCCESS) {\n\t\targ->result = HPT_IOCTL_RESULT_OK;\n\n\t\tif (arg->outbuf_size)\n\t\t\tmemcpy_fromio(arg->outbuf,\n\t\t\t\t&p->buf[(readl(&p->inbuf_size) + 3)& ~3],\n\t\t\t\targ->outbuf_size);\n\n\t\tif (arg->bytes_returned)\n\t\t\t*arg->bytes_returned = arg->outbuf_size;\n\t}\n\telse\n\t\targ->result = HPT_IOCTL_RESULT_FAILED;\n\n\targ->done(arg);\n\twritel(tag, &hba->u.itl.iop->outbound_queue);\n}\n\nstatic irqreturn_t hptiop_intr(int irq, void *dev_id)\n{\n\tstruct hptiop_hba  *hba = dev_id;\n\tint  handled;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\thandled = hba->ops->iop_intr(hba);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\treturn handled;\n}\n\nstatic int hptiop_buildsgl(struct scsi_cmnd *scp, struct hpt_iopsg *psg)\n{\n\tstruct Scsi_Host *host = scp->device->host;\n\tstruct hptiop_hba *hba = (struct hptiop_hba *)host->hostdata;\n\tstruct scatterlist *sg;\n\tint idx, nseg;\n\n\tnseg = scsi_dma_map(scp);\n\tBUG_ON(nseg < 0);\n\tif (!nseg)\n\t\treturn 0;\n\n\tHPT_SCP(scp)->sgcnt = nseg;\n\tHPT_SCP(scp)->mapped = 1;\n\n\tBUG_ON(HPT_SCP(scp)->sgcnt > hba->max_sg_descriptors);\n\n\tscsi_for_each_sg(scp, sg, HPT_SCP(scp)->sgcnt, idx) {\n\t\tpsg[idx].pci_address = cpu_to_le64(sg_dma_address(sg)) |\n\t\t\thba->ops->host_phy_flag;\n\t\tpsg[idx].size = cpu_to_le32(sg_dma_len(sg));\n\t\tpsg[idx].eot = (idx == HPT_SCP(scp)->sgcnt - 1) ?\n\t\t\tcpu_to_le32(1) : 0;\n\t}\n\treturn HPT_SCP(scp)->sgcnt;\n}\n\nstatic void hptiop_post_req_itl(struct hptiop_hba *hba,\n\t\t\t\t\tstruct hptiop_request *_req)\n{\n\tstruct hpt_iop_request_header *reqhdr = _req->req_virt;\n\n\treqhdr->context = cpu_to_le32(IOPMU_QUEUE_ADDR_HOST_BIT |\n\t\t\t\t\t\t\t(u32)_req->index);\n\treqhdr->context_hi32 = 0;\n\n\tif (hba->iopintf_v2) {\n\t\tu32 size, size_bits;\n\n\t\tsize = le32_to_cpu(reqhdr->size);\n\t\tif (size < 256)\n\t\t\tsize_bits = IOPMU_QUEUE_REQUEST_SIZE_BIT;\n\t\telse if (size < 512)\n\t\t\tsize_bits = IOPMU_QUEUE_ADDR_HOST_BIT;\n\t\telse\n\t\t\tsize_bits = IOPMU_QUEUE_REQUEST_SIZE_BIT |\n\t\t\t\t\t\tIOPMU_QUEUE_ADDR_HOST_BIT;\n\t\twritel(_req->req_shifted_phy | size_bits,\n\t\t\t&hba->u.itl.iop->inbound_queue);\n\t} else\n\t\twritel(_req->req_shifted_phy | IOPMU_QUEUE_ADDR_HOST_BIT,\n\t\t\t\t\t&hba->u.itl.iop->inbound_queue);\n}\n\nstatic void hptiop_post_req_mv(struct hptiop_hba *hba,\n\t\t\t\t\tstruct hptiop_request *_req)\n{\n\tstruct hpt_iop_request_header *reqhdr = _req->req_virt;\n\tu32 size, size_bit;\n\n\treqhdr->context = cpu_to_le32(_req->index<<8 |\n\t\t\t\t\tIOP_REQUEST_TYPE_SCSI_COMMAND<<5);\n\treqhdr->context_hi32 = 0;\n\tsize = le32_to_cpu(reqhdr->size);\n\n\tif (size <= 256)\n\t\tsize_bit = 0;\n\telse if (size <= 256*2)\n\t\tsize_bit = 1;\n\telse if (size <= 256*3)\n\t\tsize_bit = 2;\n\telse\n\t\tsize_bit = 3;\n\n\tmv_inbound_write((_req->req_shifted_phy << 5) |\n\t\tMVIOP_MU_QUEUE_ADDR_HOST_BIT | size_bit, hba);\n}\n\nstatic void hptiop_post_req_mvfrey(struct hptiop_hba *hba,\n\t\t\t\t\tstruct hptiop_request *_req)\n{\n\tstruct hpt_iop_request_header *reqhdr = _req->req_virt;\n\tu32 index;\n\n\treqhdr->flags |= cpu_to_le32(IOP_REQUEST_FLAG_OUTPUT_CONTEXT |\n\t\t\tIOP_REQUEST_FLAG_ADDR_BITS |\n\t\t\t((_req->req_shifted_phy >> 11) & 0xffff0000));\n\treqhdr->context = cpu_to_le32(IOPMU_QUEUE_ADDR_HOST_BIT |\n\t\t\t(_req->index << 4) | reqhdr->type);\n\treqhdr->context_hi32 = cpu_to_le32((_req->req_shifted_phy << 5) &\n\t\t\t0xffffffff);\n\n\thba->u.mvfrey.inlist_wptr++;\n\tindex = hba->u.mvfrey.inlist_wptr & 0x3fff;\n\n\tif (index == hba->u.mvfrey.list_count) {\n\t\tindex = 0;\n\t\thba->u.mvfrey.inlist_wptr &= ~0x3fff;\n\t\thba->u.mvfrey.inlist_wptr ^= CL_POINTER_TOGGLE;\n\t}\n\n\thba->u.mvfrey.inlist[index].addr =\n\t\t\t(dma_addr_t)_req->req_shifted_phy << 5;\n\thba->u.mvfrey.inlist[index].intrfc_len = (reqhdr->size + 3) / 4;\n\twritel(hba->u.mvfrey.inlist_wptr,\n\t\t&(hba->u.mvfrey.mu->inbound_write_ptr));\n\treadl(&(hba->u.mvfrey.mu->inbound_write_ptr));\n}\n\nstatic int hptiop_reset_comm_itl(struct hptiop_hba *hba)\n{\n\treturn 0;\n}\n\nstatic int hptiop_reset_comm_mv(struct hptiop_hba *hba)\n{\n\treturn 0;\n}\n\nstatic int hptiop_reset_comm_mvfrey(struct hptiop_hba *hba)\n{\n\tu32 list_count = hba->u.mvfrey.list_count;\n\n\tif (iop_send_sync_msg(hba, IOPMU_INBOUND_MSG0_RESET_COMM, 3000))\n\t\treturn -1;\n\n\t \n\tmsleep(100);\n\n\twritel(cpu_to_le32(hba->u.mvfrey.inlist_phy & 0xffffffff),\n\t\t\t&(hba->u.mvfrey.mu->inbound_base));\n\twritel(cpu_to_le32((hba->u.mvfrey.inlist_phy >> 16) >> 16),\n\t\t\t&(hba->u.mvfrey.mu->inbound_base_high));\n\n\twritel(cpu_to_le32(hba->u.mvfrey.outlist_phy & 0xffffffff),\n\t\t\t&(hba->u.mvfrey.mu->outbound_base));\n\twritel(cpu_to_le32((hba->u.mvfrey.outlist_phy >> 16) >> 16),\n\t\t\t&(hba->u.mvfrey.mu->outbound_base_high));\n\n\twritel(cpu_to_le32(hba->u.mvfrey.outlist_cptr_phy & 0xffffffff),\n\t\t\t&(hba->u.mvfrey.mu->outbound_shadow_base));\n\twritel(cpu_to_le32((hba->u.mvfrey.outlist_cptr_phy >> 16) >> 16),\n\t\t\t&(hba->u.mvfrey.mu->outbound_shadow_base_high));\n\n\thba->u.mvfrey.inlist_wptr = (list_count - 1) | CL_POINTER_TOGGLE;\n\t*hba->u.mvfrey.outlist_cptr = (list_count - 1) | CL_POINTER_TOGGLE;\n\thba->u.mvfrey.outlist_rptr = list_count - 1;\n\treturn 0;\n}\n\nstatic int hptiop_queuecommand_lck(struct scsi_cmnd *scp)\n{\n\tstruct Scsi_Host *host = scp->device->host;\n\tstruct hptiop_hba *hba = (struct hptiop_hba *)host->hostdata;\n\tstruct hpt_iop_request_scsi_command *req;\n\tint sg_count = 0;\n\tstruct hptiop_request *_req;\n\n\t_req = get_req(hba);\n\tif (_req == NULL) {\n\t\tdprintk(\"hptiop_queuecmd : no free req\\n\");\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\t_req->scp = scp;\n\n\tdprintk(\"hptiop_queuecmd(scp=%p) %d/%d/%d/%llu cdb=(%08x-%08x-%08x-%08x) \"\n\t\t\t\"req_index=%d, req=%p\\n\",\n\t\t\tscp,\n\t\t\thost->host_no, scp->device->channel,\n\t\t\tscp->device->id, scp->device->lun,\n\t\t\tcpu_to_be32(((u32 *)scp->cmnd)[0]),\n\t\t\tcpu_to_be32(((u32 *)scp->cmnd)[1]),\n\t\t\tcpu_to_be32(((u32 *)scp->cmnd)[2]),\n\t\t\tcpu_to_be32(((u32 *)scp->cmnd)[3]),\n\t\t\t_req->index, _req->req_virt);\n\n\tscp->result = 0;\n\n\tif (scp->device->channel ||\n\t\t\t(scp->device->id > hba->max_devices) ||\n\t\t\t((scp->device->id == (hba->max_devices-1)) && scp->device->lun)) {\n\t\tscp->result = DID_BAD_TARGET << 16;\n\t\tfree_req(hba, _req);\n\t\tgoto cmd_done;\n\t}\n\n\treq = _req->req_virt;\n\n\t \n\tsg_count = hptiop_buildsgl(scp, req->sg_list);\n\tif (!sg_count)\n\t\tHPT_SCP(scp)->mapped = 0;\n\n\treq->header.flags = cpu_to_le32(IOP_REQUEST_FLAG_OUTPUT_CONTEXT);\n\treq->header.type = cpu_to_le32(IOP_REQUEST_TYPE_SCSI_COMMAND);\n\treq->header.result = cpu_to_le32(IOP_RESULT_PENDING);\n\treq->dataxfer_length = cpu_to_le32(scsi_bufflen(scp));\n\treq->channel = scp->device->channel;\n\treq->target = scp->device->id;\n\treq->lun = scp->device->lun;\n\treq->header.size = cpu_to_le32(struct_size(req, sg_list, sg_count));\n\n\tmemcpy(req->cdb, scp->cmnd, sizeof(req->cdb));\n\thba->ops->post_req(hba, _req);\n\treturn 0;\n\ncmd_done:\n\tdprintk(\"scsi_done(scp=%p)\\n\", scp);\n\tscsi_done(scp);\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(hptiop_queuecommand)\n\nstatic const char *hptiop_info(struct Scsi_Host *host)\n{\n\treturn driver_name_long;\n}\n\nstatic int hptiop_reset_hba(struct hptiop_hba *hba)\n{\n\tif (atomic_xchg(&hba->resetting, 1) == 0) {\n\t\tatomic_inc(&hba->reset_count);\n\t\thba->ops->post_msg(hba, IOPMU_INBOUND_MSG0_RESET);\n\t}\n\n\twait_event_timeout(hba->reset_wq,\n\t\t\tatomic_read(&hba->resetting) == 0, 60 * HZ);\n\n\tif (atomic_read(&hba->resetting)) {\n\t\t \n\t\tprintk(KERN_ERR \"scsi%d: reset failed\\n\", hba->host->host_no);\n\t\treturn -1;\n\t}\n\n\tif (iop_send_sync_msg(hba,\n\t\tIOPMU_INBOUND_MSG0_START_BACKGROUND_TASK, 5000)) {\n\t\tdprintk(\"scsi%d: fail to start background task\\n\",\n\t\t\t\thba->host->host_no);\n\t}\n\n\treturn 0;\n}\n\nstatic int hptiop_reset(struct scsi_cmnd *scp)\n{\n\tstruct hptiop_hba * hba = (struct hptiop_hba *)scp->device->host->hostdata;\n\n\tprintk(KERN_WARNING \"hptiop_reset(%d/%d/%d)\\n\",\n\t       scp->device->host->host_no, -1, -1);\n\n\treturn hptiop_reset_hba(hba)? FAILED : SUCCESS;\n}\n\nstatic int hptiop_adjust_disk_queue_depth(struct scsi_device *sdev,\n\t\t\t\t\t  int queue_depth)\n{\n\tstruct hptiop_hba *hba = (struct hptiop_hba *)sdev->host->hostdata;\n\n\tif (queue_depth > hba->max_requests)\n\t\tqueue_depth = hba->max_requests;\n\treturn scsi_change_queue_depth(sdev, queue_depth);\n}\n\nstatic ssize_t hptiop_show_version(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", driver_ver);\n}\n\nstatic ssize_t hptiop_show_fw_version(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tstruct hptiop_hba *hba = (struct hptiop_hba *)host->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d.%d.%d.%d\\n\",\n\t\t\t\thba->firmware_version >> 24,\n\t\t\t\t(hba->firmware_version >> 16) & 0xff,\n\t\t\t\t(hba->firmware_version >> 8) & 0xff,\n\t\t\t\thba->firmware_version & 0xff);\n}\n\nstatic struct device_attribute hptiop_attr_version = {\n\t.attr = {\n\t\t.name = \"driver-version\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = hptiop_show_version,\n};\n\nstatic struct device_attribute hptiop_attr_fw_version = {\n\t.attr = {\n\t\t.name = \"firmware-version\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = hptiop_show_fw_version,\n};\n\nstatic struct attribute *hptiop_host_attrs[] = {\n\t&hptiop_attr_version.attr,\n\t&hptiop_attr_fw_version.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(hptiop_host);\n\nstatic int hptiop_slave_config(struct scsi_device *sdev)\n{\n\tif (sdev->type == TYPE_TAPE)\n\t\tblk_queue_max_hw_sectors(sdev->request_queue, 8192);\n\n\treturn 0;\n}\n\nstatic const struct scsi_host_template driver_template = {\n\t.module                     = THIS_MODULE,\n\t.name                       = driver_name,\n\t.queuecommand               = hptiop_queuecommand,\n\t.eh_host_reset_handler      = hptiop_reset,\n\t.info                       = hptiop_info,\n\t.emulated                   = 0,\n\t.proc_name                  = driver_name,\n\t.shost_groups\t\t    = hptiop_host_groups,\n\t.slave_configure            = hptiop_slave_config,\n\t.this_id                    = -1,\n\t.change_queue_depth         = hptiop_adjust_disk_queue_depth,\n\t.cmd_size\t\t    = sizeof(struct hpt_cmd_priv),\n};\n\nstatic int hptiop_internal_memalloc_itl(struct hptiop_hba *hba)\n{\n\treturn 0;\n}\n\nstatic int hptiop_internal_memalloc_mv(struct hptiop_hba *hba)\n{\n\thba->u.mv.internal_req = dma_alloc_coherent(&hba->pcidev->dev,\n\t\t\t0x800, &hba->u.mv.internal_req_phy, GFP_KERNEL);\n\tif (hba->u.mv.internal_req)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}\n\nstatic int hptiop_internal_memalloc_mvfrey(struct hptiop_hba *hba)\n{\n\tu32 list_count = readl(&hba->u.mvfrey.mu->inbound_conf_ctl);\n\tchar *p;\n\tdma_addr_t phy;\n\n\tBUG_ON(hba->max_request_size == 0);\n\n\tif (list_count == 0) {\n\t\tBUG_ON(1);\n\t\treturn -1;\n\t}\n\n\tlist_count >>= 16;\n\n\thba->u.mvfrey.list_count = list_count;\n\thba->u.mvfrey.internal_mem_size = 0x800 +\n\t\t\tlist_count * sizeof(struct mvfrey_inlist_entry) +\n\t\t\tlist_count * sizeof(struct mvfrey_outlist_entry) +\n\t\t\tsizeof(int);\n\n\tp = dma_alloc_coherent(&hba->pcidev->dev,\n\t\t\thba->u.mvfrey.internal_mem_size, &phy, GFP_KERNEL);\n\tif (!p)\n\t\treturn -1;\n\n\thba->u.mvfrey.internal_req.req_virt = p;\n\thba->u.mvfrey.internal_req.req_shifted_phy = phy >> 5;\n\thba->u.mvfrey.internal_req.scp = NULL;\n\thba->u.mvfrey.internal_req.next = NULL;\n\n\tp += 0x800;\n\tphy += 0x800;\n\n\thba->u.mvfrey.inlist = (struct mvfrey_inlist_entry *)p;\n\thba->u.mvfrey.inlist_phy = phy;\n\n\tp += list_count * sizeof(struct mvfrey_inlist_entry);\n\tphy += list_count * sizeof(struct mvfrey_inlist_entry);\n\n\thba->u.mvfrey.outlist = (struct mvfrey_outlist_entry *)p;\n\thba->u.mvfrey.outlist_phy = phy;\n\n\tp += list_count * sizeof(struct mvfrey_outlist_entry);\n\tphy += list_count * sizeof(struct mvfrey_outlist_entry);\n\n\thba->u.mvfrey.outlist_cptr = (__le32 *)p;\n\thba->u.mvfrey.outlist_cptr_phy = phy;\n\n\treturn 0;\n}\n\nstatic int hptiop_internal_memfree_itl(struct hptiop_hba *hba)\n{\n\treturn 0;\n}\n\nstatic int hptiop_internal_memfree_mv(struct hptiop_hba *hba)\n{\n\tif (hba->u.mv.internal_req) {\n\t\tdma_free_coherent(&hba->pcidev->dev, 0x800,\n\t\t\thba->u.mv.internal_req, hba->u.mv.internal_req_phy);\n\t\treturn 0;\n\t} else\n\t\treturn -1;\n}\n\nstatic int hptiop_internal_memfree_mvfrey(struct hptiop_hba *hba)\n{\n\tif (hba->u.mvfrey.internal_req.req_virt) {\n\t\tdma_free_coherent(&hba->pcidev->dev,\n\t\t\thba->u.mvfrey.internal_mem_size,\n\t\t\thba->u.mvfrey.internal_req.req_virt,\n\t\t\t(dma_addr_t)\n\t\t\thba->u.mvfrey.internal_req.req_shifted_phy << 5);\n\t\treturn 0;\n\t} else\n\t\treturn -1;\n}\n\nstatic int hptiop_probe(struct pci_dev *pcidev, const struct pci_device_id *id)\n{\n\tstruct Scsi_Host *host = NULL;\n\tstruct hptiop_hba *hba;\n\tstruct hptiop_adapter_ops *iop_ops;\n\tstruct hpt_iop_request_get_config iop_config;\n\tstruct hpt_iop_request_set_config set_config;\n\tdma_addr_t start_phy;\n\tvoid *start_virt;\n\tu32 offset, i, req_size;\n\tint rc;\n\n\tdprintk(\"hptiop_probe(%p)\\n\", pcidev);\n\n\tif (pci_enable_device(pcidev)) {\n\t\tprintk(KERN_ERR \"hptiop: fail to enable pci device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tprintk(KERN_INFO \"adapter at PCI %d:%d:%d, IRQ %d\\n\",\n\t\tpcidev->bus->number, pcidev->devfn >> 3, pcidev->devfn & 7,\n\t\tpcidev->irq);\n\n\tpci_set_master(pcidev);\n\n\t \n\tiop_ops = (struct hptiop_adapter_ops *)id->driver_data;\n\trc = dma_set_mask(&pcidev->dev,\n\t\t\t  DMA_BIT_MASK(iop_ops->hw_dma_bit_mask));\n\tif (rc)\n\t\trc = dma_set_mask(&pcidev->dev, DMA_BIT_MASK(32));\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"hptiop: fail to set dma_mask\\n\");\n\t\tgoto disable_pci_device;\n\t}\n\n\tif (pci_request_regions(pcidev, driver_name)) {\n\t\tprintk(KERN_ERR \"hptiop: pci_request_regions failed\\n\");\n\t\tgoto disable_pci_device;\n\t}\n\n\thost = scsi_host_alloc(&driver_template, sizeof(struct hptiop_hba));\n\tif (!host) {\n\t\tprintk(KERN_ERR \"hptiop: fail to alloc scsi host\\n\");\n\t\tgoto free_pci_regions;\n\t}\n\n\thba = (struct hptiop_hba *)host->hostdata;\n\tmemset(hba, 0, sizeof(struct hptiop_hba));\n\n\thba->ops = iop_ops;\n\thba->pcidev = pcidev;\n\thba->host = host;\n\thba->initialized = 0;\n\thba->iopintf_v2 = 0;\n\n\tatomic_set(&hba->resetting, 0);\n\tatomic_set(&hba->reset_count, 0);\n\n\tinit_waitqueue_head(&hba->reset_wq);\n\tinit_waitqueue_head(&hba->ioctl_wq);\n\n\thost->max_lun = 128;\n\thost->max_channel = 0;\n\thost->io_port = 0;\n\thost->n_io_port = 0;\n\thost->irq = pcidev->irq;\n\n\tif (hba->ops->map_pci_bar(hba))\n\t\tgoto free_scsi_host;\n\n\tif (hba->ops->iop_wait_ready(hba, 20000)) {\n\t\tprintk(KERN_ERR \"scsi%d: firmware not ready\\n\",\n\t\t\t\thba->host->host_no);\n\t\tgoto unmap_pci_bar;\n\t}\n\n\tif (hba->ops->family == MV_BASED_IOP) {\n\t\tif (hba->ops->internal_memalloc(hba)) {\n\t\t\tprintk(KERN_ERR \"scsi%d: internal_memalloc failed\\n\",\n\t\t\t\thba->host->host_no);\n\t\t\tgoto unmap_pci_bar;\n\t\t}\n\t}\n\n\tif (hba->ops->get_config(hba, &iop_config)) {\n\t\tprintk(KERN_ERR \"scsi%d: get config failed\\n\",\n\t\t\t\thba->host->host_no);\n\t\tgoto unmap_pci_bar;\n\t}\n\n\thba->max_requests = min(le32_to_cpu(iop_config.max_requests),\n\t\t\t\tHPTIOP_MAX_REQUESTS);\n\thba->max_devices = le32_to_cpu(iop_config.max_devices);\n\thba->max_request_size = le32_to_cpu(iop_config.request_size);\n\thba->max_sg_descriptors = le32_to_cpu(iop_config.max_sg_count);\n\thba->firmware_version = le32_to_cpu(iop_config.firmware_version);\n\thba->interface_version = le32_to_cpu(iop_config.interface_version);\n\thba->sdram_size = le32_to_cpu(iop_config.sdram_size);\n\n\tif (hba->ops->family == MVFREY_BASED_IOP) {\n\t\tif (hba->ops->internal_memalloc(hba)) {\n\t\t\tprintk(KERN_ERR \"scsi%d: internal_memalloc failed\\n\",\n\t\t\t\thba->host->host_no);\n\t\t\tgoto unmap_pci_bar;\n\t\t}\n\t\tif (hba->ops->reset_comm(hba)) {\n\t\t\tprintk(KERN_ERR \"scsi%d: reset comm failed\\n\",\n\t\t\t\t\thba->host->host_no);\n\t\t\tgoto unmap_pci_bar;\n\t\t}\n\t}\n\n\tif (hba->firmware_version > 0x01020000 ||\n\t\t\thba->interface_version > 0x01020000)\n\t\thba->iopintf_v2 = 1;\n\n\thost->max_sectors = le32_to_cpu(iop_config.data_transfer_length) >> 9;\n\thost->max_id = le32_to_cpu(iop_config.max_devices);\n\thost->sg_tablesize = le32_to_cpu(iop_config.max_sg_count);\n\thost->can_queue = le32_to_cpu(iop_config.max_requests);\n\thost->cmd_per_lun = le32_to_cpu(iop_config.max_requests);\n\thost->max_cmd_len = 16;\n\n\treq_size = struct_size_t(struct hpt_iop_request_scsi_command,\n\t\t\t\t sg_list, hba->max_sg_descriptors);\n\tif ((req_size & 0x1f) != 0)\n\t\treq_size = (req_size + 0x1f) & ~0x1f;\n\n\tmemset(&set_config, 0, sizeof(struct hpt_iop_request_set_config));\n\tset_config.iop_id = cpu_to_le32(host->host_no);\n\tset_config.vbus_id = cpu_to_le16(host->host_no);\n\tset_config.max_host_request_size = cpu_to_le16(req_size);\n\n\tif (hba->ops->set_config(hba, &set_config)) {\n\t\tprintk(KERN_ERR \"scsi%d: set config failed\\n\",\n\t\t\t\thba->host->host_no);\n\t\tgoto unmap_pci_bar;\n\t}\n\n\tpci_set_drvdata(pcidev, host);\n\n\tif (request_irq(pcidev->irq, hptiop_intr, IRQF_SHARED,\n\t\t\t\t\tdriver_name, hba)) {\n\t\tprintk(KERN_ERR \"scsi%d: request irq %d failed\\n\",\n\t\t\t\t\thba->host->host_no, pcidev->irq);\n\t\tgoto unmap_pci_bar;\n\t}\n\n\t \n\n\tdprintk(\"req_size=%d, max_requests=%d\\n\", req_size, hba->max_requests);\n\n\thba->req_size = req_size;\n\thba->req_list = NULL;\n\n\tfor (i = 0; i < hba->max_requests; i++) {\n\t\tstart_virt = dma_alloc_coherent(&pcidev->dev,\n\t\t\t\t\thba->req_size + 0x20,\n\t\t\t\t\t&start_phy, GFP_KERNEL);\n\n\t\tif (!start_virt) {\n\t\t\tprintk(KERN_ERR \"scsi%d: fail to alloc request mem\\n\",\n\t\t\t\t\t\thba->host->host_no);\n\t\t\tgoto free_request_mem;\n\t\t}\n\n\t\thba->dma_coherent[i] = start_virt;\n\t\thba->dma_coherent_handle[i] = start_phy;\n\n\t\tif ((start_phy & 0x1f) != 0) {\n\t\t\toffset = ((start_phy + 0x1f) & ~0x1f) - start_phy;\n\t\t\tstart_phy += offset;\n\t\t\tstart_virt += offset;\n\t\t}\n\n\t\thba->reqs[i].next = NULL;\n\t\thba->reqs[i].req_virt = start_virt;\n\t\thba->reqs[i].req_shifted_phy = start_phy >> 5;\n\t\thba->reqs[i].index = i;\n\t\tfree_req(hba, &hba->reqs[i]);\n\t}\n\n\t \n\tif (hptiop_initialize_iop(hba))\n\t\tgoto free_request_mem;\n\n\tif (scsi_add_host(host, &pcidev->dev)) {\n\t\tprintk(KERN_ERR \"scsi%d: scsi_add_host failed\\n\",\n\t\t\t\t\thba->host->host_no);\n\t\tgoto free_request_mem;\n\t}\n\n\tscsi_scan_host(host);\n\n\tdprintk(\"scsi%d: hptiop_probe successfully\\n\", hba->host->host_no);\n\treturn 0;\n\nfree_request_mem:\n\tfor (i = 0; i < hba->max_requests; i++) {\n\t\tif (hba->dma_coherent[i] && hba->dma_coherent_handle[i])\n\t\t\tdma_free_coherent(&hba->pcidev->dev,\n\t\t\t\t\thba->req_size + 0x20,\n\t\t\t\t\thba->dma_coherent[i],\n\t\t\t\t\thba->dma_coherent_handle[i]);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tfree_irq(hba->pcidev->irq, hba);\n\nunmap_pci_bar:\n\thba->ops->internal_memfree(hba);\n\n\thba->ops->unmap_pci_bar(hba);\n\nfree_scsi_host:\n\tscsi_host_put(host);\n\nfree_pci_regions:\n\tpci_release_regions(pcidev);\n\ndisable_pci_device:\n\tpci_disable_device(pcidev);\n\n\tdprintk(\"scsi%d: hptiop_probe fail\\n\", host ? host->host_no : 0);\n\treturn -ENODEV;\n}\n\nstatic void hptiop_shutdown(struct pci_dev *pcidev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pcidev);\n\tstruct hptiop_hba *hba = (struct hptiop_hba *)host->hostdata;\n\n\tdprintk(\"hptiop_shutdown(%p)\\n\", hba);\n\n\t \n\tif (iop_send_sync_msg(hba, IOPMU_INBOUND_MSG0_SHUTDOWN, 60000))\n\t\tprintk(KERN_ERR \"scsi%d: shutdown the iop timeout\\n\",\n\t\t\t\t\thba->host->host_no);\n\n\t \n\thba->ops->disable_intr(hba);\n}\n\nstatic void hptiop_disable_intr_itl(struct hptiop_hba *hba)\n{\n\tu32 int_mask;\n\n\tint_mask = readl(&hba->u.itl.iop->outbound_intmask);\n\twritel(int_mask |\n\t\tIOPMU_OUTBOUND_INT_MSG0 | IOPMU_OUTBOUND_INT_POSTQUEUE,\n\t\t&hba->u.itl.iop->outbound_intmask);\n\treadl(&hba->u.itl.iop->outbound_intmask);\n}\n\nstatic void hptiop_disable_intr_mv(struct hptiop_hba *hba)\n{\n\twritel(0, &hba->u.mv.regs->outbound_intmask);\n\treadl(&hba->u.mv.regs->outbound_intmask);\n}\n\nstatic void hptiop_disable_intr_mvfrey(struct hptiop_hba *hba)\n{\n\twritel(0, &(hba->u.mvfrey.mu->f0_doorbell_enable));\n\treadl(&(hba->u.mvfrey.mu->f0_doorbell_enable));\n\twritel(0, &(hba->u.mvfrey.mu->isr_enable));\n\treadl(&(hba->u.mvfrey.mu->isr_enable));\n\twritel(0, &(hba->u.mvfrey.mu->pcie_f0_int_enable));\n\treadl(&(hba->u.mvfrey.mu->pcie_f0_int_enable));\n}\n\nstatic void hptiop_remove(struct pci_dev *pcidev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pcidev);\n\tstruct hptiop_hba *hba = (struct hptiop_hba *)host->hostdata;\n\tu32 i;\n\n\tdprintk(\"scsi%d: hptiop_remove\\n\", hba->host->host_no);\n\n\tscsi_remove_host(host);\n\n\thptiop_shutdown(pcidev);\n\n\tfree_irq(hba->pcidev->irq, hba);\n\n\tfor (i = 0; i < hba->max_requests; i++) {\n\t\tif (hba->dma_coherent[i] && hba->dma_coherent_handle[i])\n\t\t\tdma_free_coherent(&hba->pcidev->dev,\n\t\t\t\t\thba->req_size + 0x20,\n\t\t\t\t\thba->dma_coherent[i],\n\t\t\t\t\thba->dma_coherent_handle[i]);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\thba->ops->internal_memfree(hba);\n\n\thba->ops->unmap_pci_bar(hba);\n\n\tpci_release_regions(hba->pcidev);\n\tpci_set_drvdata(hba->pcidev, NULL);\n\tpci_disable_device(hba->pcidev);\n\n\tscsi_host_put(host);\n}\n\nstatic struct hptiop_adapter_ops hptiop_itl_ops = {\n\t.family            = INTEL_BASED_IOP,\n\t.iop_wait_ready    = iop_wait_ready_itl,\n\t.internal_memalloc = hptiop_internal_memalloc_itl,\n\t.internal_memfree  = hptiop_internal_memfree_itl,\n\t.map_pci_bar       = hptiop_map_pci_bar_itl,\n\t.unmap_pci_bar     = hptiop_unmap_pci_bar_itl,\n\t.enable_intr       = hptiop_enable_intr_itl,\n\t.disable_intr      = hptiop_disable_intr_itl,\n\t.get_config        = iop_get_config_itl,\n\t.set_config        = iop_set_config_itl,\n\t.iop_intr          = iop_intr_itl,\n\t.post_msg          = hptiop_post_msg_itl,\n\t.post_req          = hptiop_post_req_itl,\n\t.hw_dma_bit_mask   = 64,\n\t.reset_comm        = hptiop_reset_comm_itl,\n\t.host_phy_flag     = cpu_to_le64(0),\n};\n\nstatic struct hptiop_adapter_ops hptiop_mv_ops = {\n\t.family            = MV_BASED_IOP,\n\t.iop_wait_ready    = iop_wait_ready_mv,\n\t.internal_memalloc = hptiop_internal_memalloc_mv,\n\t.internal_memfree  = hptiop_internal_memfree_mv,\n\t.map_pci_bar       = hptiop_map_pci_bar_mv,\n\t.unmap_pci_bar     = hptiop_unmap_pci_bar_mv,\n\t.enable_intr       = hptiop_enable_intr_mv,\n\t.disable_intr      = hptiop_disable_intr_mv,\n\t.get_config        = iop_get_config_mv,\n\t.set_config        = iop_set_config_mv,\n\t.iop_intr          = iop_intr_mv,\n\t.post_msg          = hptiop_post_msg_mv,\n\t.post_req          = hptiop_post_req_mv,\n\t.hw_dma_bit_mask   = 33,\n\t.reset_comm        = hptiop_reset_comm_mv,\n\t.host_phy_flag     = cpu_to_le64(0),\n};\n\nstatic struct hptiop_adapter_ops hptiop_mvfrey_ops = {\n\t.family            = MVFREY_BASED_IOP,\n\t.iop_wait_ready    = iop_wait_ready_mvfrey,\n\t.internal_memalloc = hptiop_internal_memalloc_mvfrey,\n\t.internal_memfree  = hptiop_internal_memfree_mvfrey,\n\t.map_pci_bar       = hptiop_map_pci_bar_mvfrey,\n\t.unmap_pci_bar     = hptiop_unmap_pci_bar_mvfrey,\n\t.enable_intr       = hptiop_enable_intr_mvfrey,\n\t.disable_intr      = hptiop_disable_intr_mvfrey,\n\t.get_config        = iop_get_config_mvfrey,\n\t.set_config        = iop_set_config_mvfrey,\n\t.iop_intr          = iop_intr_mvfrey,\n\t.post_msg          = hptiop_post_msg_mvfrey,\n\t.post_req          = hptiop_post_req_mvfrey,\n\t.hw_dma_bit_mask   = 64,\n\t.reset_comm        = hptiop_reset_comm_mvfrey,\n\t.host_phy_flag     = cpu_to_le64(1),\n};\n\nstatic struct pci_device_id hptiop_id_table[] = {\n\t{ PCI_VDEVICE(TTI, 0x3220), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x3320), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x3410), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x3510), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x3511), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x3520), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x3521), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x3522), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x3530), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x3540), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x3560), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x4210), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x4211), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x4310), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x4311), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x4320), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x4321), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x4322), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x4400), (kernel_ulong_t)&hptiop_itl_ops },\n\t{ PCI_VDEVICE(TTI, 0x3120), (kernel_ulong_t)&hptiop_mv_ops },\n\t{ PCI_VDEVICE(TTI, 0x3122), (kernel_ulong_t)&hptiop_mv_ops },\n\t{ PCI_VDEVICE(TTI, 0x3020), (kernel_ulong_t)&hptiop_mv_ops },\n\t{ PCI_VDEVICE(TTI, 0x4520), (kernel_ulong_t)&hptiop_mvfrey_ops },\n\t{ PCI_VDEVICE(TTI, 0x4522), (kernel_ulong_t)&hptiop_mvfrey_ops },\n\t{ PCI_VDEVICE(TTI, 0x3610), (kernel_ulong_t)&hptiop_mvfrey_ops },\n\t{ PCI_VDEVICE(TTI, 0x3611), (kernel_ulong_t)&hptiop_mvfrey_ops },\n\t{ PCI_VDEVICE(TTI, 0x3620), (kernel_ulong_t)&hptiop_mvfrey_ops },\n\t{ PCI_VDEVICE(TTI, 0x3622), (kernel_ulong_t)&hptiop_mvfrey_ops },\n\t{ PCI_VDEVICE(TTI, 0x3640), (kernel_ulong_t)&hptiop_mvfrey_ops },\n\t{ PCI_VDEVICE(TTI, 0x3660), (kernel_ulong_t)&hptiop_mvfrey_ops },\n\t{ PCI_VDEVICE(TTI, 0x3680), (kernel_ulong_t)&hptiop_mvfrey_ops },\n\t{ PCI_VDEVICE(TTI, 0x3690), (kernel_ulong_t)&hptiop_mvfrey_ops },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(pci, hptiop_id_table);\n\nstatic struct pci_driver hptiop_pci_driver = {\n\t.name       = driver_name,\n\t.id_table   = hptiop_id_table,\n\t.probe      = hptiop_probe,\n\t.remove     = hptiop_remove,\n\t.shutdown   = hptiop_shutdown,\n};\n\nstatic int __init hptiop_module_init(void)\n{\n\tprintk(KERN_INFO \"%s %s\\n\", driver_name_long, driver_ver);\n\treturn pci_register_driver(&hptiop_pci_driver);\n}\n\nstatic void __exit hptiop_module_exit(void)\n{\n\tpci_unregister_driver(&hptiop_pci_driver);\n}\n\n\nmodule_init(hptiop_module_init);\nmodule_exit(hptiop_module_exit);\n\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}