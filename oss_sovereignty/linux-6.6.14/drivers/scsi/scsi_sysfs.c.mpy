{
  "module_name": "scsi_sysfs.c",
  "hash_id": "58cb95eaae97c5a217c6bcbedb356f14e519b030088bbfda0fd24b904efa5713",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/device.h>\n#include <linux/pm_runtime.h>\n#include <linux/bsg.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_dh.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_driver.h>\n#include <scsi/scsi_devinfo.h>\n\n#include \"scsi_priv.h\"\n#include \"scsi_logging.h\"\n\nstatic struct device_type scsi_dev_type;\n\nstatic const struct {\n\tenum scsi_device_state\tvalue;\n\tchar\t\t\t*name;\n} sdev_states[] = {\n\t{ SDEV_CREATED, \"created\" },\n\t{ SDEV_RUNNING, \"running\" },\n\t{ SDEV_CANCEL, \"cancel\" },\n\t{ SDEV_DEL, \"deleted\" },\n\t{ SDEV_QUIESCE, \"quiesce\" },\n\t{ SDEV_OFFLINE,\t\"offline\" },\n\t{ SDEV_TRANSPORT_OFFLINE, \"transport-offline\" },\n\t{ SDEV_BLOCK,\t\"blocked\" },\n\t{ SDEV_CREATED_BLOCK, \"created-blocked\" },\n};\n\nconst char *scsi_device_state_name(enum scsi_device_state state)\n{\n\tint i;\n\tchar *name = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(sdev_states); i++) {\n\t\tif (sdev_states[i].value == state) {\n\t\t\tname = sdev_states[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn name;\n}\n\nstatic const struct {\n\tenum scsi_host_state\tvalue;\n\tchar\t\t\t*name;\n} shost_states[] = {\n\t{ SHOST_CREATED, \"created\" },\n\t{ SHOST_RUNNING, \"running\" },\n\t{ SHOST_CANCEL, \"cancel\" },\n\t{ SHOST_DEL, \"deleted\" },\n\t{ SHOST_RECOVERY, \"recovery\" },\n\t{ SHOST_CANCEL_RECOVERY, \"cancel/recovery\" },\n\t{ SHOST_DEL_RECOVERY, \"deleted/recovery\", },\n};\nconst char *scsi_host_state_name(enum scsi_host_state state)\n{\n\tint i;\n\tchar *name = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(shost_states); i++) {\n\t\tif (shost_states[i].value == state) {\n\t\t\tname = shost_states[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn name;\n}\n\n#ifdef CONFIG_SCSI_DH\nstatic const struct {\n\tunsigned char\tvalue;\n\tchar\t\t*name;\n} sdev_access_states[] = {\n\t{ SCSI_ACCESS_STATE_OPTIMAL, \"active/optimized\" },\n\t{ SCSI_ACCESS_STATE_ACTIVE, \"active/non-optimized\" },\n\t{ SCSI_ACCESS_STATE_STANDBY, \"standby\" },\n\t{ SCSI_ACCESS_STATE_UNAVAILABLE, \"unavailable\" },\n\t{ SCSI_ACCESS_STATE_LBA, \"lba-dependent\" },\n\t{ SCSI_ACCESS_STATE_OFFLINE, \"offline\" },\n\t{ SCSI_ACCESS_STATE_TRANSITIONING, \"transitioning\" },\n};\n\nstatic const char *scsi_access_state_name(unsigned char state)\n{\n\tint i;\n\tchar *name = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(sdev_access_states); i++) {\n\t\tif (sdev_access_states[i].value == state) {\n\t\t\tname = sdev_access_states[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn name;\n}\n#endif\n\nstatic int check_set(unsigned long long *val, char *src)\n{\n\tchar *last;\n\n\tif (strcmp(src, \"-\") == 0) {\n\t\t*val = SCAN_WILD_CARD;\n\t} else {\n\t\t \n\t\t*val = simple_strtoull(src, &last, 0);\n\t\tif (*last != '\\0')\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int scsi_scan(struct Scsi_Host *shost, const char *str)\n{\n\tchar s1[15], s2[15], s3[17], junk;\n\tunsigned long long channel, id, lun;\n\tint res;\n\n\tres = sscanf(str, \"%10s %10s %16s %c\", s1, s2, s3, &junk);\n\tif (res != 3)\n\t\treturn -EINVAL;\n\tif (check_set(&channel, s1))\n\t\treturn -EINVAL;\n\tif (check_set(&id, s2))\n\t\treturn -EINVAL;\n\tif (check_set(&lun, s3))\n\t\treturn -EINVAL;\n\tif (shost->transportt->user_scan)\n\t\tres = shost->transportt->user_scan(shost, channel, id, lun);\n\telse\n\t\tres = scsi_scan_host_selected(shost, channel, id, lun,\n\t\t\t\t\t      SCSI_SCAN_MANUAL);\n\treturn res;\n}\n\n \n#define shost_show_function(name, field, format_string)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_##name (struct device *dev, struct device_attribute *attr, \t\\\n\t     char *buf)\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct Scsi_Host *shost = class_to_shost(dev);\t\t\t\\\n\treturn snprintf (buf, 20, format_string, shost->field);\t\t\\\n}\n\n \n#define shost_rd_attr2(name, field, format_string)\t\t\t\\\n\tshost_show_function(name, field, format_string)\t\t\t\\\nstatic DEVICE_ATTR(name, S_IRUGO, show_##name, NULL);\n\n#define shost_rd_attr(field, format_string) \\\nshost_rd_attr2(field, field, format_string)\n\n \n\nstatic ssize_t\nstore_scan(struct device *dev, struct device_attribute *attr,\n\t   const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tint res;\n\n\tres = scsi_scan(shost, buf);\n\tif (res == 0)\n\t\tres = count;\n\treturn res;\n};\nstatic DEVICE_ATTR(scan, S_IWUSR, NULL, store_scan);\n\nstatic ssize_t\nstore_shost_state(struct device *dev, struct device_attribute *attr,\n\t\t  const char *buf, size_t count)\n{\n\tint i;\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tenum scsi_host_state state = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(shost_states); i++) {\n\t\tconst int len = strlen(shost_states[i].name);\n\t\tif (strncmp(shost_states[i].name, buf, len) == 0 &&\n\t\t   buf[len] == '\\n') {\n\t\t\tstate = shost_states[i].value;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!state)\n\t\treturn -EINVAL;\n\n\tif (scsi_host_set_state(shost, state))\n\t\treturn -EINVAL;\n\treturn count;\n}\n\nstatic ssize_t\nshow_shost_state(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tconst char *name = scsi_host_state_name(shost->shost_state);\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\treturn snprintf(buf, 20, \"%s\\n\", name);\n}\n\n \nstatic struct device_attribute dev_attr_hstate =\n\t__ATTR(state, S_IRUGO | S_IWUSR, show_shost_state, store_shost_state);\n\nstatic ssize_t\nshow_shost_mode(unsigned int mode, char *buf)\n{\n\tssize_t len = 0;\n\n\tif (mode & MODE_INITIATOR)\n\t\tlen = sprintf(buf, \"%s\", \"Initiator\");\n\n\tif (mode & MODE_TARGET)\n\t\tlen += sprintf(buf + len, \"%s%s\", len ? \", \" : \"\", \"Target\");\n\n\tlen += sprintf(buf + len, \"\\n\");\n\n\treturn len;\n}\n\nstatic ssize_t\nshow_shost_supported_mode(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tunsigned int supported_mode = shost->hostt->supported_mode;\n\n\tif (supported_mode == MODE_UNKNOWN)\n\t\t \n\t\tsupported_mode = MODE_INITIATOR;\n\n\treturn show_shost_mode(supported_mode, buf);\n}\n\nstatic DEVICE_ATTR(supported_mode, S_IRUGO | S_IWUSR, show_shost_supported_mode, NULL);\n\nstatic ssize_t\nshow_shost_active_mode(struct device *dev,\n\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\n\tif (shost->active_mode == MODE_UNKNOWN)\n\t\treturn snprintf(buf, 20, \"unknown\\n\");\n\telse\n\t\treturn show_shost_mode(shost->active_mode, buf);\n}\n\nstatic DEVICE_ATTR(active_mode, S_IRUGO | S_IWUSR, show_shost_active_mode, NULL);\n\nstatic int check_reset_type(const char *str)\n{\n\tif (sysfs_streq(str, \"adapter\"))\n\t\treturn SCSI_ADAPTER_RESET;\n\telse if (sysfs_streq(str, \"firmware\"))\n\t\treturn SCSI_FIRMWARE_RESET;\n\telse\n\t\treturn 0;\n}\n\nstatic ssize_t\nstore_host_reset(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tconst struct scsi_host_template *sht = shost->hostt;\n\tint ret = -EINVAL;\n\tint type;\n\n\ttype = check_reset_type(buf);\n\tif (!type)\n\t\tgoto exit_store_host_reset;\n\n\tif (sht->host_reset)\n\t\tret = sht->host_reset(shost, type);\n\telse\n\t\tret = -EOPNOTSUPP;\n\nexit_store_host_reset:\n\tif (ret == 0)\n\t\tret = count;\n\treturn ret;\n}\n\nstatic DEVICE_ATTR(host_reset, S_IWUSR, NULL, store_host_reset);\n\nstatic ssize_t\nshow_shost_eh_deadline(struct device *dev,\n\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\n\tif (shost->eh_deadline == -1)\n\t\treturn snprintf(buf, strlen(\"off\") + 2, \"off\\n\");\n\treturn sprintf(buf, \"%u\\n\", shost->eh_deadline / HZ);\n}\n\nstatic ssize_t\nstore_shost_eh_deadline(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tint ret = -EINVAL;\n\tunsigned long deadline, flags;\n\n\tif (shost->transportt &&\n\t    (shost->transportt->eh_strategy_handler ||\n\t     !shost->hostt->eh_host_reset_handler))\n\t\treturn ret;\n\n\tif (!strncmp(buf, \"off\", strlen(\"off\")))\n\t\tdeadline = -1;\n\telse {\n\t\tret = kstrtoul(buf, 10, &deadline);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (deadline * HZ > UINT_MAX)\n\t\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (scsi_host_in_recovery(shost))\n\t\tret = -EBUSY;\n\telse {\n\t\tif (deadline == -1)\n\t\t\tshost->eh_deadline = -1;\n\t\telse\n\t\t\tshost->eh_deadline = deadline * HZ;\n\n\t\tret = count;\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR(eh_deadline, S_IRUGO | S_IWUSR, show_shost_eh_deadline, store_shost_eh_deadline);\n\nshost_rd_attr(unique_id, \"%u\\n\");\nshost_rd_attr(cmd_per_lun, \"%hd\\n\");\nshost_rd_attr(can_queue, \"%d\\n\");\nshost_rd_attr(sg_tablesize, \"%hu\\n\");\nshost_rd_attr(sg_prot_tablesize, \"%hu\\n\");\nshost_rd_attr(prot_capabilities, \"%u\\n\");\nshost_rd_attr(prot_guard_type, \"%hd\\n\");\nshost_rd_attr2(proc_name, hostt->proc_name, \"%s\\n\");\n\nstatic ssize_t\nshow_host_busy(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\treturn snprintf(buf, 20, \"%d\\n\", scsi_host_busy(shost));\n}\nstatic DEVICE_ATTR(host_busy, S_IRUGO, show_host_busy, NULL);\n\nstatic ssize_t\nshow_use_blk_mq(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"1\\n\");\n}\nstatic DEVICE_ATTR(use_blk_mq, S_IRUGO, show_use_blk_mq, NULL);\n\nstatic ssize_t\nshow_nr_hw_queues(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct blk_mq_tag_set *tag_set = &shost->tag_set;\n\n\treturn snprintf(buf, 20, \"%d\\n\", tag_set->nr_hw_queues);\n}\nstatic DEVICE_ATTR(nr_hw_queues, S_IRUGO, show_nr_hw_queues, NULL);\n\nstatic struct attribute *scsi_sysfs_shost_attrs[] = {\n\t&dev_attr_use_blk_mq.attr,\n\t&dev_attr_unique_id.attr,\n\t&dev_attr_host_busy.attr,\n\t&dev_attr_cmd_per_lun.attr,\n\t&dev_attr_can_queue.attr,\n\t&dev_attr_sg_tablesize.attr,\n\t&dev_attr_sg_prot_tablesize.attr,\n\t&dev_attr_proc_name.attr,\n\t&dev_attr_scan.attr,\n\t&dev_attr_hstate.attr,\n\t&dev_attr_supported_mode.attr,\n\t&dev_attr_active_mode.attr,\n\t&dev_attr_prot_capabilities.attr,\n\t&dev_attr_prot_guard_type.attr,\n\t&dev_attr_host_reset.attr,\n\t&dev_attr_eh_deadline.attr,\n\t&dev_attr_nr_hw_queues.attr,\n\tNULL\n};\n\nstatic const struct attribute_group scsi_shost_attr_group = {\n\t.attrs =\tscsi_sysfs_shost_attrs,\n};\n\nconst struct attribute_group *scsi_shost_groups[] = {\n\t&scsi_shost_attr_group,\n\tNULL\n};\n\nstatic void scsi_device_cls_release(struct device *class_dev)\n{\n\tstruct scsi_device *sdev;\n\n\tsdev = class_to_sdev(class_dev);\n\tput_device(&sdev->sdev_gendev);\n}\n\nstatic void scsi_device_dev_release(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct device *parent;\n\tstruct list_head *this, *tmp;\n\tstruct scsi_vpd *vpd_pg80 = NULL, *vpd_pg83 = NULL;\n\tstruct scsi_vpd *vpd_pg0 = NULL, *vpd_pg89 = NULL;\n\tstruct scsi_vpd *vpd_pgb0 = NULL, *vpd_pgb1 = NULL, *vpd_pgb2 = NULL;\n\tunsigned long flags;\n\n\tmight_sleep();\n\n\tscsi_dh_release_device(sdev);\n\n\tparent = sdev->sdev_gendev.parent;\n\n\tspin_lock_irqsave(sdev->host->host_lock, flags);\n\tlist_del(&sdev->siblings);\n\tlist_del(&sdev->same_target_siblings);\n\tlist_del(&sdev->starved_entry);\n\tspin_unlock_irqrestore(sdev->host->host_lock, flags);\n\n\tcancel_work_sync(&sdev->event_work);\n\n\tlist_for_each_safe(this, tmp, &sdev->event_list) {\n\t\tstruct scsi_event *evt;\n\n\t\tevt = list_entry(this, struct scsi_event, node);\n\t\tlist_del(&evt->node);\n\t\tkfree(evt);\n\t}\n\n\tblk_put_queue(sdev->request_queue);\n\t \n\tsdev->request_queue = NULL;\n\n\tsbitmap_free(&sdev->budget_map);\n\n\tmutex_lock(&sdev->inquiry_mutex);\n\tvpd_pg0 = rcu_replace_pointer(sdev->vpd_pg0, vpd_pg0,\n\t\t\t\t       lockdep_is_held(&sdev->inquiry_mutex));\n\tvpd_pg80 = rcu_replace_pointer(sdev->vpd_pg80, vpd_pg80,\n\t\t\t\t       lockdep_is_held(&sdev->inquiry_mutex));\n\tvpd_pg83 = rcu_replace_pointer(sdev->vpd_pg83, vpd_pg83,\n\t\t\t\t       lockdep_is_held(&sdev->inquiry_mutex));\n\tvpd_pg89 = rcu_replace_pointer(sdev->vpd_pg89, vpd_pg89,\n\t\t\t\t       lockdep_is_held(&sdev->inquiry_mutex));\n\tvpd_pgb0 = rcu_replace_pointer(sdev->vpd_pgb0, vpd_pgb0,\n\t\t\t\t       lockdep_is_held(&sdev->inquiry_mutex));\n\tvpd_pgb1 = rcu_replace_pointer(sdev->vpd_pgb1, vpd_pgb1,\n\t\t\t\t       lockdep_is_held(&sdev->inquiry_mutex));\n\tvpd_pgb2 = rcu_replace_pointer(sdev->vpd_pgb2, vpd_pgb2,\n\t\t\t\t       lockdep_is_held(&sdev->inquiry_mutex));\n\tmutex_unlock(&sdev->inquiry_mutex);\n\n\tif (vpd_pg0)\n\t\tkfree_rcu(vpd_pg0, rcu);\n\tif (vpd_pg83)\n\t\tkfree_rcu(vpd_pg83, rcu);\n\tif (vpd_pg80)\n\t\tkfree_rcu(vpd_pg80, rcu);\n\tif (vpd_pg89)\n\t\tkfree_rcu(vpd_pg89, rcu);\n\tif (vpd_pgb0)\n\t\tkfree_rcu(vpd_pgb0, rcu);\n\tif (vpd_pgb1)\n\t\tkfree_rcu(vpd_pgb1, rcu);\n\tif (vpd_pgb2)\n\t\tkfree_rcu(vpd_pgb2, rcu);\n\tkfree(sdev->inquiry);\n\tkfree(sdev);\n\n\tif (parent)\n\t\tput_device(parent);\n}\n\nstatic struct class sdev_class = {\n\t.name\t\t= \"scsi_device\",\n\t.dev_release\t= scsi_device_cls_release,\n};\n\n \nstatic int scsi_bus_match(struct device *dev, struct device_driver *gendrv)\n{\n\tstruct scsi_device *sdp;\n\n\tif (dev->type != &scsi_dev_type)\n\t\treturn 0;\n\n\tsdp = to_scsi_device(dev);\n\tif (sdp->no_uld_attach)\n\t\treturn 0;\n\treturn (sdp->inq_periph_qual == SCSI_INQ_PQ_CON)? 1: 0;\n}\n\nstatic int scsi_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct scsi_device *sdev;\n\n\tif (dev->type != &scsi_dev_type)\n\t\treturn 0;\n\n\tsdev = to_scsi_device(dev);\n\n\tadd_uevent_var(env, \"MODALIAS=\" SCSI_DEVICE_MODALIAS_FMT, sdev->type);\n\treturn 0;\n}\n\nstruct bus_type scsi_bus_type = {\n        .name\t\t= \"scsi\",\n        .match\t\t= scsi_bus_match,\n\t.uevent\t\t= scsi_bus_uevent,\n#ifdef CONFIG_PM\n\t.pm\t\t= &scsi_bus_pm_ops,\n#endif\n};\n\nint scsi_sysfs_register(void)\n{\n\tint error;\n\n\terror = bus_register(&scsi_bus_type);\n\tif (!error) {\n\t\terror = class_register(&sdev_class);\n\t\tif (error)\n\t\t\tbus_unregister(&scsi_bus_type);\n\t}\n\n\treturn error;\n}\n\nvoid scsi_sysfs_unregister(void)\n{\n\tclass_unregister(&sdev_class);\n\tbus_unregister(&scsi_bus_type);\n}\n\n \n#define sdev_show_function(field, format_string)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nsdev_show_##field (struct device *dev, struct device_attribute *attr,\t\\\n\t\t   char *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct scsi_device *sdev;\t\t\t\t\t\\\n\tsdev = to_scsi_device(dev);\t\t\t\t\t\\\n\treturn snprintf (buf, 20, format_string, sdev->field);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\n \n#define sdev_rd_attr(field, format_string)\t\t\t\t\\\n\tsdev_show_function(field, format_string)\t\t\t\\\nstatic DEVICE_ATTR(field, S_IRUGO, sdev_show_##field, NULL);\n\n\n \n#define sdev_rw_attr(field, format_string)\t\t\t\t\\\n\tsdev_show_function(field, format_string)\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nsdev_store_##field (struct device *dev, struct device_attribute *attr,\t\\\n\t\t    const char *buf, size_t count)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct scsi_device *sdev;\t\t\t\t\t\\\n\tsdev = to_scsi_device(dev);\t\t\t\t\t\\\n\tsscanf (buf, format_string, &sdev->field);\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(field, S_IRUGO | S_IWUSR, sdev_show_##field, sdev_store_##field);\n\n \n#if 0\n \n#define sdev_rw_attr_bit(field)\t\t\t\t\t\t\\\n\tsdev_show_function(field, \"%d\\n\")\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nsdev_store_##field (struct device *dev, struct device_attribute *attr,\t\\\n\t\t    const char *buf, size_t count)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tstruct scsi_device *sdev;\t\t\t\t\t\\\n\tret = scsi_sdev_check_buf_bit(buf);\t\t\t\t\\\n\tif (ret >= 0)\t{\t\t\t\t\t\t\\\n\t\tsdev = to_scsi_device(dev);\t\t\t\t\\\n\t\tsdev->field = ret;\t\t\t\t\t\\\n\t\tret = count;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(field, S_IRUGO | S_IWUSR, sdev_show_##field, sdev_store_##field);\n\n \nstatic int scsi_sdev_check_buf_bit(const char *buf)\n{\n\tif ((buf[1] == '\\0') || ((buf[1] == '\\n') && (buf[2] == '\\0'))) {\n\t\tif (buf[0] == '1')\n\t\t\treturn 1;\n\t\telse if (buf[0] == '0')\n\t\t\treturn 0;\n\t\telse \n\t\t\treturn -EINVAL;\n\t} else\n\t\treturn -EINVAL;\n}\n#endif\n \nsdev_rd_attr (type, \"%d\\n\");\nsdev_rd_attr (scsi_level, \"%d\\n\");\nsdev_rd_attr (vendor, \"%.8s\\n\");\nsdev_rd_attr (model, \"%.16s\\n\");\nsdev_rd_attr (rev, \"%.4s\\n\");\nsdev_rd_attr (cdl_supported, \"%d\\n\");\n\nstatic ssize_t\nsdev_show_device_busy(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\treturn snprintf(buf, 20, \"%d\\n\", scsi_device_busy(sdev));\n}\nstatic DEVICE_ATTR(device_busy, S_IRUGO, sdev_show_device_busy, NULL);\n\nstatic ssize_t\nsdev_show_device_blocked(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\treturn snprintf(buf, 20, \"%d\\n\", atomic_read(&sdev->device_blocked));\n}\nstatic DEVICE_ATTR(device_blocked, S_IRUGO, sdev_show_device_blocked, NULL);\n\n \nstatic ssize_t\nsdev_show_timeout (struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev;\n\tsdev = to_scsi_device(dev);\n\treturn snprintf(buf, 20, \"%d\\n\", sdev->request_queue->rq_timeout / HZ);\n}\n\nstatic ssize_t\nsdev_store_timeout (struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tstruct scsi_device *sdev;\n\tint timeout;\n\tsdev = to_scsi_device(dev);\n\tsscanf (buf, \"%d\\n\", &timeout);\n\tblk_queue_rq_timeout(sdev->request_queue, timeout * HZ);\n\treturn count;\n}\nstatic DEVICE_ATTR(timeout, S_IRUGO | S_IWUSR, sdev_show_timeout, sdev_store_timeout);\n\nstatic ssize_t\nsdev_show_eh_timeout(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev;\n\tsdev = to_scsi_device(dev);\n\treturn snprintf(buf, 20, \"%u\\n\", sdev->eh_timeout / HZ);\n}\n\nstatic ssize_t\nsdev_store_eh_timeout(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tstruct scsi_device *sdev;\n\tunsigned int eh_timeout;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tsdev = to_scsi_device(dev);\n\terr = kstrtouint(buf, 10, &eh_timeout);\n\tif (err)\n\t\treturn err;\n\tsdev->eh_timeout = eh_timeout * HZ;\n\n\treturn count;\n}\nstatic DEVICE_ATTR(eh_timeout, S_IRUGO | S_IWUSR, sdev_show_eh_timeout, sdev_store_eh_timeout);\n\nstatic ssize_t\nstore_rescan_field (struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tscsi_rescan_device(to_scsi_device(dev));\n\treturn count;\n}\nstatic DEVICE_ATTR(rescan, S_IWUSR, NULL, store_rescan_field);\n\nstatic ssize_t\nsdev_store_delete(struct device *dev, struct device_attribute *attr,\n\t\t  const char *buf, size_t count)\n{\n\tstruct kernfs_node *kn;\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\t \n\tif (scsi_device_get(sdev))\n\t\treturn -ENODEV;\n\n\tkn = sysfs_break_active_protection(&dev->kobj, &attr->attr);\n\tWARN_ON_ONCE(!kn);\n\t \n\tdevice_remove_file(dev, attr);\n\tscsi_remove_device(sdev);\n\tif (kn)\n\t\tsysfs_unbreak_active_protection(kn);\n\tscsi_device_put(sdev);\n\treturn count;\n};\nstatic DEVICE_ATTR(delete, S_IWUSR, NULL, sdev_store_delete);\n\nstatic ssize_t\nstore_state_field(struct device *dev, struct device_attribute *attr,\n\t\t  const char *buf, size_t count)\n{\n\tint i, ret;\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tenum scsi_device_state state = 0;\n\tbool rescan_dev = false;\n\n\tfor (i = 0; i < ARRAY_SIZE(sdev_states); i++) {\n\t\tconst int len = strlen(sdev_states[i].name);\n\t\tif (strncmp(sdev_states[i].name, buf, len) == 0 &&\n\t\t   buf[len] == '\\n') {\n\t\t\tstate = sdev_states[i].value;\n\t\t\tbreak;\n\t\t}\n\t}\n\tswitch (state) {\n\tcase SDEV_RUNNING:\n\tcase SDEV_OFFLINE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&sdev->state_mutex);\n\tswitch (sdev->sdev_state) {\n\tcase SDEV_RUNNING:\n\tcase SDEV_OFFLINE:\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&sdev->state_mutex);\n\t\treturn -EINVAL;\n\t}\n\tif (sdev->sdev_state == SDEV_RUNNING && state == SDEV_RUNNING) {\n\t\tret = 0;\n\t} else {\n\t\tret = scsi_device_set_state(sdev, state);\n\t\tif (ret == 0 && state == SDEV_RUNNING)\n\t\t\trescan_dev = true;\n\t}\n\tmutex_unlock(&sdev->state_mutex);\n\n\tif (rescan_dev) {\n\t\t \n\t\tblk_mq_run_hw_queues(sdev->request_queue, true);\n\t\tscsi_rescan_device(sdev);\n\t}\n\n\treturn ret == 0 ? count : -EINVAL;\n}\n\nstatic ssize_t\nshow_state_field(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tconst char *name = scsi_device_state_name(sdev->sdev_state);\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\treturn snprintf(buf, 20, \"%s\\n\", name);\n}\n\nstatic DEVICE_ATTR(state, S_IRUGO | S_IWUSR, show_state_field, store_state_field);\n\nstatic ssize_t\nshow_queue_type_field(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tconst char *name = \"none\";\n\n\tif (sdev->simple_tags)\n\t\tname = \"simple\";\n\n\treturn snprintf(buf, 20, \"%s\\n\", name);\n}\n\nstatic ssize_t\nstore_queue_type_field(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\tif (!sdev->tagged_supported)\n\t\treturn -EINVAL;\n\t\t\n\tsdev_printk(KERN_INFO, sdev,\n\t\t    \"ignoring write to deprecated queue_type attribute\");\n\treturn count;\n}\n\nstatic DEVICE_ATTR(queue_type, S_IRUGO | S_IWUSR, show_queue_type_field,\n\t\t   store_queue_type_field);\n\n#define sdev_vpd_pg_attr(_page)\t\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\\\nshow_vpd_##_page(struct file *filp, struct kobject *kobj,\t\\\n\t\t struct bin_attribute *bin_attr,\t\t\t\\\n\t\t char *buf, loff_t off, size_t count)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct device *dev = kobj_to_dev(kobj);\t\t\t\t\\\n\tstruct scsi_device *sdev = to_scsi_device(dev);\t\t\t\\\n\tstruct scsi_vpd *vpd_page;\t\t\t\t\t\\\n\tint ret = -EINVAL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\trcu_read_lock();\t\t\t\t\t\t\\\n\tvpd_page = rcu_dereference(sdev->vpd_##_page);\t\t\t\\\n\tif (vpd_page)\t\t\t\t\t\t\t\\\n\t\tret = memory_read_from_buffer(buf, count, &off,\t\t\\\n\t\t\t\tvpd_page->data, vpd_page->len);\t\t\\\n\trcu_read_unlock();\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic struct bin_attribute dev_attr_vpd_##_page = {\t\t\\\n\t.attr =\t{.name = __stringify(vpd_##_page), .mode = S_IRUGO },\t\\\n\t.size = 0,\t\t\t\t\t\t\t\\\n\t.read = show_vpd_##_page,\t\t\t\t\t\\\n};\n\nsdev_vpd_pg_attr(pg83);\nsdev_vpd_pg_attr(pg80);\nsdev_vpd_pg_attr(pg89);\nsdev_vpd_pg_attr(pgb0);\nsdev_vpd_pg_attr(pgb1);\nsdev_vpd_pg_attr(pgb2);\nsdev_vpd_pg_attr(pg0);\n\nstatic ssize_t show_inquiry(struct file *filep, struct kobject *kobj,\n\t\t\t    struct bin_attribute *bin_attr,\n\t\t\t    char *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\tif (!sdev->inquiry)\n\t\treturn -EINVAL;\n\n\treturn memory_read_from_buffer(buf, count, &off, sdev->inquiry,\n\t\t\t\t       sdev->inquiry_len);\n}\n\nstatic struct bin_attribute dev_attr_inquiry = {\n\t.attr = {\n\t\t.name = \"inquiry\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.size = 0,\n\t.read = show_inquiry,\n};\n\nstatic ssize_t\nshow_iostat_counterbits(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\treturn snprintf(buf, 20, \"%d\\n\", (int)sizeof(atomic_t) * 8);\n}\n\nstatic DEVICE_ATTR(iocounterbits, S_IRUGO, show_iostat_counterbits, NULL);\n\n#define show_sdev_iostat(field)\t\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_iostat_##field(struct device *dev, struct device_attribute *attr,\t\\\n\t\t    char *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct scsi_device *sdev = to_scsi_device(dev);\t\t\t\\\n\tunsigned long long count = atomic_read(&sdev->field);\t\t\\\n\treturn snprintf(buf, 20, \"0x%llx\\n\", count);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(field, S_IRUGO, show_iostat_##field, NULL)\n\nshow_sdev_iostat(iorequest_cnt);\nshow_sdev_iostat(iodone_cnt);\nshow_sdev_iostat(ioerr_cnt);\nshow_sdev_iostat(iotmo_cnt);\n\nstatic ssize_t\nsdev_show_modalias(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev;\n\tsdev = to_scsi_device(dev);\n\treturn snprintf (buf, 20, SCSI_DEVICE_MODALIAS_FMT \"\\n\", sdev->type);\n}\nstatic DEVICE_ATTR(modalias, S_IRUGO, sdev_show_modalias, NULL);\n\n#define DECLARE_EVT_SHOW(name, Cap_name)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nsdev_show_evt_##name(struct device *dev, struct device_attribute *attr,\t\\\n\t\t     char *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct scsi_device *sdev = to_scsi_device(dev);\t\t\t\\\n\tint val = test_bit(SDEV_EVT_##Cap_name, sdev->supported_events);\\\n\treturn snprintf(buf, 20, \"%d\\n\", val);\t\t\t\t\\\n}\n\n#define DECLARE_EVT_STORE(name, Cap_name)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nsdev_store_evt_##name(struct device *dev, struct device_attribute *attr,\\\n\t\t      const char *buf, size_t count)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct scsi_device *sdev = to_scsi_device(dev);\t\t\t\\\n\tint val = simple_strtoul(buf, NULL, 0);\t\t\t\t\\\n\tif (val == 0)\t\t\t\t\t\t\t\\\n\t\tclear_bit(SDEV_EVT_##Cap_name, sdev->supported_events);\t\\\n\telse if (val == 1)\t\t\t\t\t\t\\\n\t\tset_bit(SDEV_EVT_##Cap_name, sdev->supported_events);\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define DECLARE_EVT(name, Cap_name)\t\t\t\t\t\\\n\tDECLARE_EVT_SHOW(name, Cap_name)\t\t\t\t\\\n\tDECLARE_EVT_STORE(name, Cap_name)\t\t\t\t\\\n\tstatic DEVICE_ATTR(evt_##name, S_IRUGO, sdev_show_evt_##name,\t\\\n\t\t\t   sdev_store_evt_##name);\n#define REF_EVT(name) &dev_attr_evt_##name.attr\n\nDECLARE_EVT(media_change, MEDIA_CHANGE)\nDECLARE_EVT(inquiry_change_reported, INQUIRY_CHANGE_REPORTED)\nDECLARE_EVT(capacity_change_reported, CAPACITY_CHANGE_REPORTED)\nDECLARE_EVT(soft_threshold_reached, SOFT_THRESHOLD_REACHED_REPORTED)\nDECLARE_EVT(mode_parameter_change_reported, MODE_PARAMETER_CHANGE_REPORTED)\nDECLARE_EVT(lun_change_reported, LUN_CHANGE_REPORTED)\n\nstatic ssize_t\nsdev_store_queue_depth(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tint depth, retval;\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tconst struct scsi_host_template *sht = sdev->host->hostt;\n\n\tif (!sht->change_queue_depth)\n\t\treturn -EINVAL;\n\n\tdepth = simple_strtoul(buf, NULL, 0);\n\n\tif (depth < 1 || depth > sdev->host->can_queue)\n\t\treturn -EINVAL;\n\n\tretval = sht->change_queue_depth(sdev, depth);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tsdev->max_queue_depth = sdev->queue_depth;\n\n\treturn count;\n}\nsdev_show_function(queue_depth, \"%d\\n\");\n\nstatic DEVICE_ATTR(queue_depth, S_IRUGO | S_IWUSR, sdev_show_queue_depth,\n\t\t   sdev_store_queue_depth);\n\nstatic ssize_t\nsdev_show_wwid(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tssize_t count;\n\n\tcount = scsi_vpd_lun_id(sdev, buf, PAGE_SIZE);\n\tif (count > 0) {\n\t\tbuf[count] = '\\n';\n\t\tcount++;\n\t}\n\treturn count;\n}\nstatic DEVICE_ATTR(wwid, S_IRUGO, sdev_show_wwid, NULL);\n\n#define BLIST_FLAG_NAME(name)\t\t\t\t\t\\\n\t[const_ilog2((__force __u64)BLIST_##name)] = #name\nstatic const char *const sdev_bflags_name[] = {\n#include \"scsi_devinfo_tbl.c\"\n};\n#undef BLIST_FLAG_NAME\n\nstatic ssize_t\nsdev_show_blacklist(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tint i;\n\tssize_t len = 0;\n\n\tfor (i = 0; i < sizeof(sdev->sdev_bflags) * BITS_PER_BYTE; i++) {\n\t\tconst char *name = NULL;\n\n\t\tif (!(sdev->sdev_bflags & (__force blist_flags_t)BIT(i)))\n\t\t\tcontinue;\n\t\tif (i < ARRAY_SIZE(sdev_bflags_name) && sdev_bflags_name[i])\n\t\t\tname = sdev_bflags_name[i];\n\n\t\tif (name)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t \"%s%s\", len ? \" \" : \"\", name);\n\t\telse\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t \"%sINVALID_BIT(%d)\", len ? \" \" : \"\", i);\n\t}\n\tif (len)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"\\n\");\n\treturn len;\n}\nstatic DEVICE_ATTR(blacklist, S_IRUGO, sdev_show_blacklist, NULL);\n\n#ifdef CONFIG_SCSI_DH\nstatic ssize_t\nsdev_show_dh_state(struct device *dev, struct device_attribute *attr,\n\t\t   char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\tif (!sdev->handler)\n\t\treturn snprintf(buf, 20, \"detached\\n\");\n\n\treturn snprintf(buf, 20, \"%s\\n\", sdev->handler->name);\n}\n\nstatic ssize_t\nsdev_store_dh_state(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tint err = -EINVAL;\n\n\tif (sdev->sdev_state == SDEV_CANCEL ||\n\t    sdev->sdev_state == SDEV_DEL)\n\t\treturn -ENODEV;\n\n\tif (!sdev->handler) {\n\t\t \n\t\terr = scsi_dh_attach(sdev->request_queue, buf);\n\t} else if (!strncmp(buf, \"activate\", 8)) {\n\t\t \n\t\tif (sdev->handler->activate)\n\t\t\terr = sdev->handler->activate(sdev, NULL, NULL);\n\t\telse\n\t\t\terr = 0;\n\t} else if (!strncmp(buf, \"detach\", 6)) {\n\t\t \n\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t    \"can't detach handler %s.\\n\",\n\t\t\t    sdev->handler->name);\n\t\terr = -EINVAL;\n\t}\n\n\treturn err < 0 ? err : count;\n}\n\nstatic DEVICE_ATTR(dh_state, S_IRUGO | S_IWUSR, sdev_show_dh_state,\n\t\t   sdev_store_dh_state);\n\nstatic ssize_t\nsdev_show_access_state(struct device *dev,\n\t\t       struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tunsigned char access_state;\n\tconst char *access_state_name;\n\n\tif (!sdev->handler)\n\t\treturn -EINVAL;\n\n\taccess_state = (sdev->access_state & SCSI_ACCESS_STATE_MASK);\n\taccess_state_name = scsi_access_state_name(access_state);\n\n\treturn sprintf(buf, \"%s\\n\",\n\t\t       access_state_name ? access_state_name : \"unknown\");\n}\nstatic DEVICE_ATTR(access_state, S_IRUGO, sdev_show_access_state, NULL);\n\nstatic ssize_t\nsdev_show_preferred_path(struct device *dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\tif (!sdev->handler)\n\t\treturn -EINVAL;\n\n\tif (sdev->access_state & SCSI_ACCESS_STATE_PREFERRED)\n\t\treturn sprintf(buf, \"1\\n\");\n\telse\n\t\treturn sprintf(buf, \"0\\n\");\n}\nstatic DEVICE_ATTR(preferred_path, S_IRUGO, sdev_show_preferred_path, NULL);\n#endif\n\nstatic ssize_t\nsdev_show_queue_ramp_up_period(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct scsi_device *sdev;\n\tsdev = to_scsi_device(dev);\n\treturn snprintf(buf, 20, \"%u\\n\",\n\t\t\tjiffies_to_msecs(sdev->queue_ramp_up_period));\n}\n\nstatic ssize_t\nsdev_store_queue_ramp_up_period(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tunsigned int period;\n\n\tif (kstrtouint(buf, 10, &period))\n\t\treturn -EINVAL;\n\n\tsdev->queue_ramp_up_period = msecs_to_jiffies(period);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(queue_ramp_up_period, S_IRUGO | S_IWUSR,\n\t\t   sdev_show_queue_ramp_up_period,\n\t\t   sdev_store_queue_ramp_up_period);\n\nstatic ssize_t sdev_show_cdl_enable(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", (int)sdev->cdl_enable);\n}\n\nstatic ssize_t sdev_store_cdl_enable(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tint ret;\n\tbool v;\n\n\tif (kstrtobool(buf, &v))\n\t\treturn -EINVAL;\n\n\tret = scsi_cdl_enable(to_scsi_device(dev), v);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR(cdl_enable, S_IRUGO | S_IWUSR,\n\t\t   sdev_show_cdl_enable, sdev_store_cdl_enable);\n\nstatic umode_t scsi_sdev_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t struct attribute *attr, int i)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\n\tif (attr == &dev_attr_queue_depth.attr &&\n\t    !sdev->host->hostt->change_queue_depth)\n\t\treturn S_IRUGO;\n\n\tif (attr == &dev_attr_queue_ramp_up_period.attr &&\n\t    !sdev->host->hostt->change_queue_depth)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic umode_t scsi_sdev_bin_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t     struct bin_attribute *attr, int i)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\n\tif (attr == &dev_attr_vpd_pg0 && !sdev->vpd_pg0)\n\t\treturn 0;\n\n\tif (attr == &dev_attr_vpd_pg80 && !sdev->vpd_pg80)\n\t\treturn 0;\n\n\tif (attr == &dev_attr_vpd_pg83 && !sdev->vpd_pg83)\n\t\treturn 0;\n\n\tif (attr == &dev_attr_vpd_pg89 && !sdev->vpd_pg89)\n\t\treturn 0;\n\n\tif (attr == &dev_attr_vpd_pgb0 && !sdev->vpd_pgb0)\n\t\treturn 0;\n\n\tif (attr == &dev_attr_vpd_pgb1 && !sdev->vpd_pgb1)\n\t\treturn 0;\n\n\tif (attr == &dev_attr_vpd_pgb2 && !sdev->vpd_pgb2)\n\t\treturn 0;\n\n\treturn S_IRUGO;\n}\n\n \nstatic struct attribute *scsi_sdev_attrs[] = {\n\t&dev_attr_device_blocked.attr,\n\t&dev_attr_type.attr,\n\t&dev_attr_scsi_level.attr,\n\t&dev_attr_device_busy.attr,\n\t&dev_attr_vendor.attr,\n\t&dev_attr_model.attr,\n\t&dev_attr_rev.attr,\n\t&dev_attr_rescan.attr,\n\t&dev_attr_delete.attr,\n\t&dev_attr_state.attr,\n\t&dev_attr_timeout.attr,\n\t&dev_attr_eh_timeout.attr,\n\t&dev_attr_iocounterbits.attr,\n\t&dev_attr_iorequest_cnt.attr,\n\t&dev_attr_iodone_cnt.attr,\n\t&dev_attr_ioerr_cnt.attr,\n\t&dev_attr_iotmo_cnt.attr,\n\t&dev_attr_modalias.attr,\n\t&dev_attr_queue_depth.attr,\n\t&dev_attr_queue_type.attr,\n\t&dev_attr_wwid.attr,\n\t&dev_attr_blacklist.attr,\n#ifdef CONFIG_SCSI_DH\n\t&dev_attr_dh_state.attr,\n\t&dev_attr_access_state.attr,\n\t&dev_attr_preferred_path.attr,\n#endif\n\t&dev_attr_queue_ramp_up_period.attr,\n\t&dev_attr_cdl_supported.attr,\n\t&dev_attr_cdl_enable.attr,\n\tREF_EVT(media_change),\n\tREF_EVT(inquiry_change_reported),\n\tREF_EVT(capacity_change_reported),\n\tREF_EVT(soft_threshold_reached),\n\tREF_EVT(mode_parameter_change_reported),\n\tREF_EVT(lun_change_reported),\n\tNULL\n};\n\nstatic struct bin_attribute *scsi_sdev_bin_attrs[] = {\n\t&dev_attr_vpd_pg0,\n\t&dev_attr_vpd_pg83,\n\t&dev_attr_vpd_pg80,\n\t&dev_attr_vpd_pg89,\n\t&dev_attr_vpd_pgb0,\n\t&dev_attr_vpd_pgb1,\n\t&dev_attr_vpd_pgb2,\n\t&dev_attr_inquiry,\n\tNULL\n};\nstatic struct attribute_group scsi_sdev_attr_group = {\n\t.attrs =\tscsi_sdev_attrs,\n\t.bin_attrs =\tscsi_sdev_bin_attrs,\n\t.is_visible =\tscsi_sdev_attr_is_visible,\n\t.is_bin_visible = scsi_sdev_bin_attr_is_visible,\n};\n\nstatic const struct attribute_group *scsi_sdev_attr_groups[] = {\n\t&scsi_sdev_attr_group,\n\tNULL\n};\n\nstatic int scsi_target_add(struct scsi_target *starget)\n{\n\tint error;\n\n\tif (starget->state != STARGET_CREATED)\n\t\treturn 0;\n\n\terror = device_add(&starget->dev);\n\tif (error) {\n\t\tdev_err(&starget->dev, \"target device_add failed, error %d\\n\", error);\n\t\treturn error;\n\t}\n\ttransport_add_device(&starget->dev);\n\tstarget->state = STARGET_RUNNING;\n\n\tpm_runtime_set_active(&starget->dev);\n\tpm_runtime_enable(&starget->dev);\n\tdevice_enable_async_suspend(&starget->dev);\n\n\treturn 0;\n}\n\n \nint scsi_sysfs_add_sdev(struct scsi_device *sdev)\n{\n\tint error;\n\tstruct scsi_target *starget = sdev->sdev_target;\n\n\terror = scsi_target_add(starget);\n\tif (error)\n\t\treturn error;\n\n\ttransport_configure_device(&starget->dev);\n\n\tdevice_enable_async_suspend(&sdev->sdev_gendev);\n\tscsi_autopm_get_target(starget);\n\tpm_runtime_set_active(&sdev->sdev_gendev);\n\tif (!sdev->rpm_autosuspend)\n\t\tpm_runtime_forbid(&sdev->sdev_gendev);\n\tpm_runtime_enable(&sdev->sdev_gendev);\n\tscsi_autopm_put_target(starget);\n\n\tscsi_autopm_get_device(sdev);\n\n\tscsi_dh_add_device(sdev);\n\n\terror = device_add(&sdev->sdev_gendev);\n\tif (error) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\"failed to add device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tdevice_enable_async_suspend(&sdev->sdev_dev);\n\terror = device_add(&sdev->sdev_dev);\n\tif (error) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\"failed to add class device: %d\\n\", error);\n\t\tdevice_del(&sdev->sdev_gendev);\n\t\treturn error;\n\t}\n\ttransport_add_device(&sdev->sdev_gendev);\n\tsdev->is_visible = 1;\n\n\tif (IS_ENABLED(CONFIG_BLK_DEV_BSG)) {\n\t\tsdev->bsg_dev = scsi_bsg_register_queue(sdev);\n\t\tif (IS_ERR(sdev->bsg_dev)) {\n\t\t\terror = PTR_ERR(sdev->bsg_dev);\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Failed to register bsg queue, errno=%d\\n\",\n\t\t\t\t    error);\n\t\t\tsdev->bsg_dev = NULL;\n\t\t}\n\t}\n\n\tscsi_autopm_put_device(sdev);\n\treturn error;\n}\n\nvoid __scsi_remove_device(struct scsi_device *sdev)\n{\n\tstruct device *dev = &sdev->sdev_gendev;\n\tint res;\n\n\t \n\tif (sdev->sdev_state == SDEV_DEL)\n\t\treturn;\n\n\tif (sdev->is_visible) {\n\t\t \n\t\tmutex_lock(&sdev->state_mutex);\n\t\t \n\t\tres = scsi_device_set_state(sdev, SDEV_CANCEL);\n\t\tif (res != 0) {\n\t\t\tres = scsi_device_set_state(sdev, SDEV_DEL);\n\t\t\tif (res == 0)\n\t\t\t\tscsi_start_queue(sdev);\n\t\t}\n\t\tmutex_unlock(&sdev->state_mutex);\n\n\t\tif (res != 0)\n\t\t\treturn;\n\n\t\tif (IS_ENABLED(CONFIG_BLK_DEV_BSG) && sdev->bsg_dev)\n\t\t\tbsg_unregister_queue(sdev->bsg_dev);\n\t\tdevice_unregister(&sdev->sdev_dev);\n\t\ttransport_remove_device(dev);\n\t\tdevice_del(dev);\n\t} else\n\t\tput_device(&sdev->sdev_dev);\n\n\t \n\tmutex_lock(&sdev->state_mutex);\n\tscsi_device_set_state(sdev, SDEV_DEL);\n\tmutex_unlock(&sdev->state_mutex);\n\n\tblk_mq_destroy_queue(sdev->request_queue);\n\tkref_put(&sdev->host->tagset_refcnt, scsi_mq_free_tags);\n\tcancel_work_sync(&sdev->requeue_work);\n\n\tif (sdev->host->hostt->slave_destroy)\n\t\tsdev->host->hostt->slave_destroy(sdev);\n\ttransport_destroy_device(dev);\n\n\t \n\tscsi_target_reap(scsi_target(sdev));\n\n\tput_device(dev);\n}\n\n \nvoid scsi_remove_device(struct scsi_device *sdev)\n{\n\tstruct Scsi_Host *shost = sdev->host;\n\n\tmutex_lock(&shost->scan_mutex);\n\t__scsi_remove_device(sdev);\n\tmutex_unlock(&shost->scan_mutex);\n}\nEXPORT_SYMBOL(scsi_remove_device);\n\nstatic void __scsi_remove_target(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tunsigned long flags;\n\tstruct scsi_device *sdev;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n restart:\n\tlist_for_each_entry(sdev, &shost->__devices, siblings) {\n\t\t \n\t\tif (sdev->channel != starget->channel ||\n\t\t    sdev->id != starget->id)\n\t\t\tcontinue;\n\t\tif (sdev->sdev_state == SDEV_DEL ||\n\t\t    sdev->sdev_state == SDEV_CANCEL ||\n\t\t    !get_device(&sdev->sdev_gendev))\n\t\t\tcontinue;\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\tscsi_remove_device(sdev);\n\t\tput_device(&sdev->sdev_gendev);\n\t\tspin_lock_irqsave(shost->host_lock, flags);\n\t\tgoto restart;\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n}\n\n \nvoid scsi_remove_target(struct device *dev)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(dev->parent);\n\tstruct scsi_target *starget;\n\tunsigned long flags;\n\nrestart:\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tlist_for_each_entry(starget, &shost->__targets, siblings) {\n\t\tif (starget->state == STARGET_DEL ||\n\t\t    starget->state == STARGET_REMOVE ||\n\t\t    starget->state == STARGET_CREATED_REMOVE)\n\t\t\tcontinue;\n\t\tif (starget->dev.parent == dev || &starget->dev == dev) {\n\t\t\tkref_get(&starget->reap_ref);\n\t\t\tif (starget->state == STARGET_CREATED)\n\t\t\t\tstarget->state = STARGET_CREATED_REMOVE;\n\t\t\telse\n\t\t\t\tstarget->state = STARGET_REMOVE;\n\t\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\t\t__scsi_remove_target(starget);\n\t\t\tscsi_target_reap(starget);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n}\nEXPORT_SYMBOL(scsi_remove_target);\n\nint scsi_register_driver(struct device_driver *drv)\n{\n\tdrv->bus = &scsi_bus_type;\n\n\treturn driver_register(drv);\n}\nEXPORT_SYMBOL(scsi_register_driver);\n\nint scsi_register_interface(struct class_interface *intf)\n{\n\tintf->class = &sdev_class;\n\n\treturn class_interface_register(intf);\n}\nEXPORT_SYMBOL(scsi_register_interface);\n\n \nint scsi_sysfs_add_host(struct Scsi_Host *shost)\n{\n\ttransport_register_device(&shost->shost_gendev);\n\ttransport_configure_device(&shost->shost_gendev);\n\treturn 0;\n}\n\nstatic struct device_type scsi_dev_type = {\n\t.name =\t\t\"scsi_device\",\n\t.release =\tscsi_device_dev_release,\n\t.groups =\tscsi_sdev_attr_groups,\n};\n\nvoid scsi_sysfs_device_initialize(struct scsi_device *sdev)\n{\n\tunsigned long flags;\n\tstruct Scsi_Host *shost = sdev->host;\n\tconst struct scsi_host_template *hostt = shost->hostt;\n\tstruct scsi_target  *starget = sdev->sdev_target;\n\n\tdevice_initialize(&sdev->sdev_gendev);\n\tsdev->sdev_gendev.bus = &scsi_bus_type;\n\tsdev->sdev_gendev.type = &scsi_dev_type;\n\tscsi_enable_async_suspend(&sdev->sdev_gendev);\n\tdev_set_name(&sdev->sdev_gendev, \"%d:%d:%d:%llu\",\n\t\t     sdev->host->host_no, sdev->channel, sdev->id, sdev->lun);\n\tsdev->sdev_gendev.groups = hostt->sdev_groups;\n\n\tdevice_initialize(&sdev->sdev_dev);\n\tsdev->sdev_dev.parent = get_device(&sdev->sdev_gendev);\n\tsdev->sdev_dev.class = &sdev_class;\n\tdev_set_name(&sdev->sdev_dev, \"%d:%d:%d:%llu\",\n\t\t     sdev->host->host_no, sdev->channel, sdev->id, sdev->lun);\n\t \n\tsdev->scsi_level = starget->scsi_level;\n\tif (sdev->scsi_level <= SCSI_2 &&\n\t\t\tsdev->scsi_level != SCSI_UNKNOWN &&\n\t\t\t!shost->no_scsi2_lun_in_cdb)\n\t\tsdev->lun_in_cdb = 1;\n\n\ttransport_setup_device(&sdev->sdev_gendev);\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tlist_add_tail(&sdev->same_target_siblings, &starget->devices);\n\tlist_add_tail(&sdev->siblings, &shost->__devices);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t \n\tkref_get(&starget->reap_ref);\n}\n\nint scsi_is_sdev_device(const struct device *dev)\n{\n\treturn dev->type == &scsi_dev_type;\n}\nEXPORT_SYMBOL(scsi_is_sdev_device);\n\n \nstruct scsi_transport_template blank_transport_template = { { { {NULL, }, }, }, };\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}