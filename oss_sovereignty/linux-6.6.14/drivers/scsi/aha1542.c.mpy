{
  "module_name": "aha1542.c",
  "hash_id": "6f246f87374da1d4d2c7c4b35ba39ad7802b7cc4dbc19eb0670eafd05db41ee3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aha1542.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/isa.h>\n#include <linux/pnp.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include \"aha1542.h\"\n\n#define MAXBOARDS 4\n\nstatic bool isapnp = 1;\nmodule_param(isapnp, bool, 0);\nMODULE_PARM_DESC(isapnp, \"enable PnP support (default=1)\");\n\nstatic int io[MAXBOARDS] = { 0x330, 0x334, 0, 0 };\nmodule_param_hw_array(io, int, ioport, NULL, 0);\nMODULE_PARM_DESC(io, \"base IO address of controller (0x130,0x134,0x230,0x234,0x330,0x334, default=0x330,0x334)\");\n\n \nstatic int bus_on[MAXBOARDS] = { -1, -1, -1, -1 };  \nmodule_param_array(bus_on, int, NULL, 0);\nMODULE_PARM_DESC(bus_on, \"bus on time [us] (2-15, default=-1 [HW default: 11])\");\n\n \nstatic int bus_off[MAXBOARDS] = { -1, -1, -1, -1 };  \nmodule_param_array(bus_off, int, NULL, 0);\nMODULE_PARM_DESC(bus_off, \"bus off time [us] (1-64, default=-1 [HW default: 4])\");\n\n \nstatic int dma_speed[MAXBOARDS] = { -1, -1, -1, -1 };\nmodule_param_array(dma_speed, int, NULL, 0);\nMODULE_PARM_DESC(dma_speed, \"DMA speed [MB/s] (5,6,7,8,10, default=-1 [by jumper])\");\n\n#define BIOS_TRANSLATION_6432 1\t \n#define BIOS_TRANSLATION_25563 2\t \n\nstruct aha1542_hostdata {\n\t \n\tint bios_translation;\t \n\tint aha1542_last_mbi_used;\n\tint aha1542_last_mbo_used;\n\tstruct scsi_cmnd *int_cmds[AHA1542_MAILBOXES];\n\tstruct mailbox *mb;\n\tdma_addr_t mb_handle;\n\tstruct ccb *ccb;\n\tdma_addr_t ccb_handle;\n};\n\n#define AHA1542_MAX_SECTORS       16\n\nstruct aha1542_cmd {\n\t \n\tvoid *data_buffer;\n\tdma_addr_t data_buffer_handle;\n};\n\nstatic inline void aha1542_intr_reset(u16 base)\n{\n\toutb(IRST, CONTROL(base));\n}\n\nstatic inline bool wait_mask(u16 port, u8 mask, u8 allof, u8 noneof, int timeout)\n{\n\tbool delayed = true;\n\n\tif (timeout == 0) {\n\t\ttimeout = 3000000;\n\t\tdelayed = false;\n\t}\n\n\twhile (1) {\n\t\tu8 bits = inb(port) & mask;\n\t\tif ((bits & allof) == allof && ((bits & noneof) == 0))\n\t\t\tbreak;\n\t\tif (delayed)\n\t\t\tmdelay(1);\n\t\tif (--timeout == 0)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int aha1542_outb(unsigned int base, u8 val)\n{\n\tif (!wait_mask(STATUS(base), CDF, 0, CDF, 0))\n\t\treturn 1;\n\toutb(val, DATA(base));\n\n\treturn 0;\n}\n\nstatic int aha1542_out(unsigned int base, u8 *buf, int len)\n{\n\twhile (len--) {\n\t\tif (!wait_mask(STATUS(base), CDF, 0, CDF, 0))\n\t\t\treturn 1;\n\t\toutb(*buf++, DATA(base));\n\t}\n\tif (!wait_mask(INTRFLAGS(base), INTRMASK, HACC, 0, 0))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \n\nstatic int aha1542_in(unsigned int base, u8 *buf, int len, int timeout)\n{\n\twhile (len--) {\n\t\tif (!wait_mask(STATUS(base), DF, DF, 0, timeout))\n\t\t\treturn 1;\n\t\t*buf++ = inb(DATA(base));\n\t}\n\treturn 0;\n}\n\nstatic int makecode(unsigned hosterr, unsigned scsierr)\n{\n\tswitch (hosterr) {\n\tcase 0x0:\n\tcase 0xa:\t\t \n\tcase 0xb:\t\t \n\t\thosterr = 0;\n\t\tbreak;\n\n\tcase 0x11:\t\t \n\t\thosterr = DID_TIME_OUT;\n\t\tbreak;\n\n\tcase 0x12:\t\t \n\n\tcase 0x13:\t\t \n\n\tcase 0x15:\t\t \n\n\tcase 0x16:\t\t \n\n\tcase 0x17:\t\t \n\tcase 0x18:\t\t \n\n\tcase 0x19:\t\t \n\n\tcase 0x1a:\t\t \n#ifdef DEBUG\n\t\tprintk(\"Aha1542: %x %x\\n\", hosterr, scsierr);\n#endif\n\t\thosterr = DID_ERROR;\t \n\t\tbreak;\n\n\tcase 0x14:\t\t \n\t\thosterr = DID_RESET;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"aha1542: makecode: unknown hoststatus %x\\n\", hosterr);\n\t\tbreak;\n\t}\n\treturn scsierr | (hosterr << 16);\n}\n\nstatic int aha1542_test_port(struct Scsi_Host *sh)\n{\n\tint i;\n\n\t \n\tif (inb(STATUS(sh->io_port)) == 0xff)\n\t\treturn 0;\n\n\t \n\n\t \n\taha1542_intr_reset(sh->io_port);\t \n\n\toutb(SRST | IRST   , CONTROL(sh->io_port));\n\n\tmdelay(20);\t\t \n\n\t \n\tif (!wait_mask(STATUS(sh->io_port), STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0))\n\t\treturn 0;\n\n\t \n\tif (inb(INTRFLAGS(sh->io_port)) & INTRMASK)\n\t\treturn 0;\n\n\t \n\n\taha1542_outb(sh->io_port, CMD_INQUIRY);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (!wait_mask(STATUS(sh->io_port), DF, DF, 0, 0))\n\t\t\treturn 0;\n\t\t(void)inb(DATA(sh->io_port));\n\t}\n\n\t \n\tif (inb(STATUS(sh->io_port)) & DF)\n\t\treturn 0;\n\n\t \n\tif (!wait_mask(INTRFLAGS(sh->io_port), HACC, HACC, 0, 0))\n\t\treturn 0;\n\n\t \n\toutb(IRST, CONTROL(sh->io_port));\n\n\treturn 1;\n}\n\nstatic void aha1542_free_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct aha1542_cmd *acmd = scsi_cmd_priv(cmd);\n\n\tif (cmd->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tstruct request *rq = scsi_cmd_to_rq(cmd);\n\t\tvoid *buf = acmd->data_buffer;\n\t\tstruct req_iterator iter;\n\t\tstruct bio_vec bv;\n\n\t\trq_for_each_segment(bv, rq, iter) {\n\t\t\tmemcpy_to_bvec(&bv, buf);\n\t\t\tbuf += bv.bv_len;\n\t\t}\n\t}\n\n\tscsi_dma_unmap(cmd);\n}\n\nstatic irqreturn_t aha1542_interrupt(int irq, void *dev_id)\n{\n\tstruct Scsi_Host *sh = dev_id;\n\tstruct aha1542_hostdata *aha1542 = shost_priv(sh);\n\tint errstatus, mbi, mbo, mbistatus;\n\tint number_serviced;\n\tunsigned long flags;\n\tstruct scsi_cmnd *tmp_cmd;\n\tint flag;\n\tstruct mailbox *mb = aha1542->mb;\n\tstruct ccb *ccb = aha1542->ccb;\n\n#ifdef DEBUG\n\t{\n\t\tflag = inb(INTRFLAGS(sh->io_port));\n\t\tshost_printk(KERN_DEBUG, sh, \"aha1542_intr_handle: \");\n\t\tif (!(flag & ANYINTR))\n\t\t\tprintk(\"no interrupt?\");\n\t\tif (flag & MBIF)\n\t\t\tprintk(\"MBIF \");\n\t\tif (flag & MBOA)\n\t\t\tprintk(\"MBOF \");\n\t\tif (flag & HACC)\n\t\t\tprintk(\"HACC \");\n\t\tif (flag & SCRD)\n\t\t\tprintk(\"SCRD \");\n\t\tprintk(\"status %02x\\n\", inb(STATUS(sh->io_port)));\n\t}\n#endif\n\tnumber_serviced = 0;\n\n\tspin_lock_irqsave(sh->host_lock, flags);\n\twhile (1) {\n\t\tflag = inb(INTRFLAGS(sh->io_port));\n\n\t\t \n\t\tif (flag & ~MBIF) {\n\t\t\tif (flag & MBOA)\n\t\t\t\tprintk(\"MBOF \");\n\t\t\tif (flag & HACC)\n\t\t\t\tprintk(\"HACC \");\n\t\t\tif (flag & SCRD)\n\t\t\t\tprintk(\"SCRD \");\n\t\t}\n\t\taha1542_intr_reset(sh->io_port);\n\n\t\tmbi = aha1542->aha1542_last_mbi_used + 1;\n\t\tif (mbi >= 2 * AHA1542_MAILBOXES)\n\t\t\tmbi = AHA1542_MAILBOXES;\n\n\t\tdo {\n\t\t\tif (mb[mbi].status != 0)\n\t\t\t\tbreak;\n\t\t\tmbi++;\n\t\t\tif (mbi >= 2 * AHA1542_MAILBOXES)\n\t\t\t\tmbi = AHA1542_MAILBOXES;\n\t\t} while (mbi != aha1542->aha1542_last_mbi_used);\n\n\t\tif (mb[mbi].status == 0) {\n\t\t\tspin_unlock_irqrestore(sh->host_lock, flags);\n\t\t\t \n\t\t\tif (!number_serviced)\n\t\t\t\tshost_printk(KERN_WARNING, sh, \"interrupt received, but no mail.\\n\");\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tmbo = (scsi2int(mb[mbi].ccbptr) - (unsigned long)aha1542->ccb_handle) / sizeof(struct ccb);\n\t\tmbistatus = mb[mbi].status;\n\t\tmb[mbi].status = 0;\n\t\taha1542->aha1542_last_mbi_used = mbi;\n\n#ifdef DEBUG\n\t\tif (ccb[mbo].tarstat | ccb[mbo].hastat)\n\t\t\tshost_printk(KERN_DEBUG, sh, \"aha1542_command: returning %x (status %d)\\n\",\n\t\t\t       ccb[mbo].tarstat + ((int) ccb[mbo].hastat << 16), mb[mbi].status);\n#endif\n\n\t\tif (mbistatus == 3)\n\t\t\tcontinue;\t \n\n#ifdef DEBUG\n\t\tshost_printk(KERN_DEBUG, sh, \"...done %d %d\\n\", mbo, mbi);\n#endif\n\n\t\ttmp_cmd = aha1542->int_cmds[mbo];\n\n\t\tif (!tmp_cmd) {\n\t\t\tspin_unlock_irqrestore(sh->host_lock, flags);\n\t\t\tshost_printk(KERN_WARNING, sh, \"Unexpected interrupt\\n\");\n\t\t\tshost_printk(KERN_WARNING, sh, \"tarstat=%x, hastat=%x idlun=%x ccb#=%d\\n\", ccb[mbo].tarstat,\n\t\t\t       ccb[mbo].hastat, ccb[mbo].idlun, mbo);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\taha1542_free_cmd(tmp_cmd);\n\t\t \n\t\tif (ccb[mbo].tarstat == 2)\n\t\t\tmemcpy(tmp_cmd->sense_buffer, &ccb[mbo].cdb[ccb[mbo].cdblen],\n\t\t\t       SCSI_SENSE_BUFFERSIZE);\n\n\n\t\t \n\n\t\t \n\t\tif (mbistatus != 1)\n\t\t\t \n\t\t\terrstatus = makecode(ccb[mbo].hastat, ccb[mbo].tarstat);\n\t\telse\n\t\t\terrstatus = 0;\n\n#ifdef DEBUG\n\t\tif (errstatus)\n\t\t\tshost_printk(KERN_DEBUG, sh, \"(aha1542 error:%x %x %x) \", errstatus,\n\t\t\t       ccb[mbo].hastat, ccb[mbo].tarstat);\n\t\tif (ccb[mbo].tarstat == 2)\n\t\t\tprint_hex_dump_bytes(\"sense: \", DUMP_PREFIX_NONE, &ccb[mbo].cdb[ccb[mbo].cdblen], 12);\n\t\tif (errstatus)\n\t\t\tprintk(\"aha1542_intr_handle: returning %6x\\n\", errstatus);\n#endif\n\t\ttmp_cmd->result = errstatus;\n\t\taha1542->int_cmds[mbo] = NULL;\t \n\t\tscsi_done(tmp_cmd);\n\t\tnumber_serviced++;\n\t}\n}\n\nstatic int aha1542_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)\n{\n\tstruct aha1542_cmd *acmd = scsi_cmd_priv(cmd);\n\tstruct aha1542_hostdata *aha1542 = shost_priv(sh);\n\tu8 direction;\n\tu8 target = cmd->device->id;\n\tu8 lun = cmd->device->lun;\n\tunsigned long flags;\n\tint bufflen = scsi_bufflen(cmd);\n\tint mbo;\n\tstruct mailbox *mb = aha1542->mb;\n\tstruct ccb *ccb = aha1542->ccb;\n\n\tif (*cmd->cmnd == REQUEST_SENSE) {\n\t\t \n\t\tcmd->result = 0;\n\t\tscsi_done(cmd);\n\t\treturn 0;\n\t}\n#ifdef DEBUG\n\t{\n\t\tint i = -1;\n\t\tif (*cmd->cmnd == READ_10 || *cmd->cmnd == WRITE_10)\n\t\t\ti = xscsi2int(cmd->cmnd + 2);\n\t\telse if (*cmd->cmnd == READ_6 || *cmd->cmnd == WRITE_6)\n\t\t\ti = scsi2int(cmd->cmnd + 2);\n\t\tshost_printk(KERN_DEBUG, sh, \"aha1542_queuecommand: dev %d cmd %02x pos %d len %d\",\n\t\t\t\t\t\ttarget, *cmd->cmnd, i, bufflen);\n\t\tprint_hex_dump_bytes(\"command: \", DUMP_PREFIX_NONE, cmd->cmnd, cmd->cmd_len);\n\t}\n#endif\n\n\tif (cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tstruct request *rq = scsi_cmd_to_rq(cmd);\n\t\tvoid *buf = acmd->data_buffer;\n\t\tstruct req_iterator iter;\n\t\tstruct bio_vec bv;\n\n\t\trq_for_each_segment(bv, rq, iter) {\n\t\t\tmemcpy_from_bvec(buf, &bv);\n\t\t\tbuf += bv.bv_len;\n\t\t}\n\t}\n\n\t \n\n\tspin_lock_irqsave(sh->host_lock, flags);\n\tmbo = aha1542->aha1542_last_mbo_used + 1;\n\tif (mbo >= AHA1542_MAILBOXES)\n\t\tmbo = 0;\n\n\tdo {\n\t\tif (mb[mbo].status == 0 && aha1542->int_cmds[mbo] == NULL)\n\t\t\tbreak;\n\t\tmbo++;\n\t\tif (mbo >= AHA1542_MAILBOXES)\n\t\t\tmbo = 0;\n\t} while (mbo != aha1542->aha1542_last_mbo_used);\n\n\tif (mb[mbo].status || aha1542->int_cmds[mbo])\n\t\tpanic(\"Unable to find empty mailbox for aha1542.\\n\");\n\n\taha1542->int_cmds[mbo] = cmd;\t \n\n\taha1542->aha1542_last_mbo_used = mbo;\n\n#ifdef DEBUG\n\tshost_printk(KERN_DEBUG, sh, \"Sending command (%d)...\", mbo);\n#endif\n\n\t \n\tany2scsi(mb[mbo].ccbptr, aha1542->ccb_handle + mbo * sizeof(*ccb));\n\n\tmemset(&ccb[mbo], 0, sizeof(struct ccb));\n\n\tccb[mbo].cdblen = cmd->cmd_len;\n\n\tdirection = 0;\n\tif (*cmd->cmnd == READ_10 || *cmd->cmnd == READ_6)\n\t\tdirection = 8;\n\telse if (*cmd->cmnd == WRITE_10 || *cmd->cmnd == WRITE_6)\n\t\tdirection = 16;\n\n\tmemcpy(ccb[mbo].cdb, cmd->cmnd, ccb[mbo].cdblen);\n\tccb[mbo].op = 0;\t \n\tany2scsi(ccb[mbo].datalen, bufflen);\n\tif (bufflen)\n\t\tany2scsi(ccb[mbo].dataptr, acmd->data_buffer_handle);\n\telse\n\t\tany2scsi(ccb[mbo].dataptr, 0);\n\tccb[mbo].idlun = (target & 7) << 5 | direction | (lun & 7);\t \n\tccb[mbo].rsalen = 16;\n\tccb[mbo].linkptr[0] = ccb[mbo].linkptr[1] = ccb[mbo].linkptr[2] = 0;\n\tccb[mbo].commlinkid = 0;\n\n#ifdef DEBUG\n\tprint_hex_dump_bytes(\"sending: \", DUMP_PREFIX_NONE, &ccb[mbo], sizeof(ccb[mbo]) - 10);\n\tprintk(\"aha1542_queuecommand: now waiting for interrupt \");\n#endif\n\tmb[mbo].status = 1;\n\taha1542_outb(cmd->device->host->io_port, CMD_START_SCSI);\n\tspin_unlock_irqrestore(sh->host_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void setup_mailboxes(struct Scsi_Host *sh)\n{\n\tstruct aha1542_hostdata *aha1542 = shost_priv(sh);\n\tu8 mb_cmd[5] = { CMD_MBINIT, AHA1542_MAILBOXES, 0, 0, 0};\n\tint i;\n\n\tfor (i = 0; i < AHA1542_MAILBOXES; i++) {\n\t\taha1542->mb[i].status = 0;\n\t\tany2scsi(aha1542->mb[i].ccbptr,\n\t\t\t aha1542->ccb_handle + i * sizeof(struct ccb));\n\t\taha1542->mb[AHA1542_MAILBOXES + i].status = 0;\n\t}\n\taha1542_intr_reset(sh->io_port);\t \n\tany2scsi(mb_cmd + 2, aha1542->mb_handle);\n\tif (aha1542_out(sh->io_port, mb_cmd, 5))\n\t\tshost_printk(KERN_ERR, sh, \"failed setting up mailboxes\\n\");\n\taha1542_intr_reset(sh->io_port);\n}\n\nstatic int aha1542_getconfig(struct Scsi_Host *sh)\n{\n\tu8 inquiry_result[3];\n\tint i;\n\ti = inb(STATUS(sh->io_port));\n\tif (i & DF) {\n\t\ti = inb(DATA(sh->io_port));\n\t}\n\taha1542_outb(sh->io_port, CMD_RETCONF);\n\taha1542_in(sh->io_port, inquiry_result, 3, 0);\n\tif (!wait_mask(INTRFLAGS(sh->io_port), INTRMASK, HACC, 0, 0))\n\t\tshost_printk(KERN_ERR, sh, \"error querying board settings\\n\");\n\taha1542_intr_reset(sh->io_port);\n\tswitch (inquiry_result[0]) {\n\tcase 0x80:\n\t\tsh->dma_channel = 7;\n\t\tbreak;\n\tcase 0x40:\n\t\tsh->dma_channel = 6;\n\t\tbreak;\n\tcase 0x20:\n\t\tsh->dma_channel = 5;\n\t\tbreak;\n\tcase 0x01:\n\t\tsh->dma_channel = 0;\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\tsh->dma_channel = 0xFF;\n\t\tbreak;\n\tdefault:\n\t\tshost_printk(KERN_ERR, sh, \"Unable to determine DMA channel.\\n\");\n\t\treturn -1;\n\t}\n\tswitch (inquiry_result[1]) {\n\tcase 0x40:\n\t\tsh->irq = 15;\n\t\tbreak;\n\tcase 0x20:\n\t\tsh->irq = 14;\n\t\tbreak;\n\tcase 0x8:\n\t\tsh->irq = 12;\n\t\tbreak;\n\tcase 0x4:\n\t\tsh->irq = 11;\n\t\tbreak;\n\tcase 0x2:\n\t\tsh->irq = 10;\n\t\tbreak;\n\tcase 0x1:\n\t\tsh->irq = 9;\n\t\tbreak;\n\tdefault:\n\t\tshost_printk(KERN_ERR, sh, \"Unable to determine IRQ level.\\n\");\n\t\treturn -1;\n\t}\n\tsh->this_id = inquiry_result[2] & 7;\n\treturn 0;\n}\n\n \n\nstatic int aha1542_mbenable(struct Scsi_Host *sh)\n{\n\tstatic u8 mbenable_cmd[3];\n\tstatic u8 mbenable_result[2];\n\tint retval;\n\n\tretval = BIOS_TRANSLATION_6432;\n\n\taha1542_outb(sh->io_port, CMD_EXTBIOS);\n\tif (aha1542_in(sh->io_port, mbenable_result, 2, 100))\n\t\treturn retval;\n\tif (!wait_mask(INTRFLAGS(sh->io_port), INTRMASK, HACC, 0, 100))\n\t\tgoto fail;\n\taha1542_intr_reset(sh->io_port);\n\n\tif ((mbenable_result[0] & 0x08) || mbenable_result[1]) {\n\t\tmbenable_cmd[0] = CMD_MBENABLE;\n\t\tmbenable_cmd[1] = 0;\n\t\tmbenable_cmd[2] = mbenable_result[1];\n\n\t\tif ((mbenable_result[0] & 0x08) && (mbenable_result[1] & 0x03))\n\t\t\tretval = BIOS_TRANSLATION_25563;\n\n\t\tif (aha1542_out(sh->io_port, mbenable_cmd, 3))\n\t\t\tgoto fail;\n\t}\n\twhile (0) {\nfail:\n\t\tshost_printk(KERN_ERR, sh, \"Mailbox init failed\\n\");\n\t}\n\taha1542_intr_reset(sh->io_port);\n\treturn retval;\n}\n\n \nstatic int aha1542_query(struct Scsi_Host *sh)\n{\n\tstruct aha1542_hostdata *aha1542 = shost_priv(sh);\n\tu8 inquiry_result[4];\n\tint i;\n\ti = inb(STATUS(sh->io_port));\n\tif (i & DF) {\n\t\ti = inb(DATA(sh->io_port));\n\t}\n\taha1542_outb(sh->io_port, CMD_INQUIRY);\n\taha1542_in(sh->io_port, inquiry_result, 4, 0);\n\tif (!wait_mask(INTRFLAGS(sh->io_port), INTRMASK, HACC, 0, 0))\n\t\tshost_printk(KERN_ERR, sh, \"error querying card type\\n\");\n\taha1542_intr_reset(sh->io_port);\n\n\taha1542->bios_translation = BIOS_TRANSLATION_6432;\t \n\n\t \n\n\tif (inquiry_result[0] == 0x43) {\n\t\tshost_printk(KERN_INFO, sh, \"Emulation mode not supported for AHA-1740 hardware, use aha1740 driver instead.\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\n\taha1542->bios_translation = aha1542_mbenable(sh);\n\n\treturn 0;\n}\n\nstatic u8 dma_speed_hw(int dma_speed)\n{\n\tswitch (dma_speed) {\n\tcase 5:\n\t\treturn 0x00;\n\tcase 6:\n\t\treturn 0x04;\n\tcase 7:\n\t\treturn 0x01;\n\tcase 8:\n\t\treturn 0x02;\n\tcase 10:\n\t\treturn 0x03;\n\t}\n\n\treturn 0xff;\t \n}\n\n \nstatic void aha1542_set_bus_times(struct Scsi_Host *sh, int bus_on, int bus_off, int dma_speed)\n{\n\tif (bus_on > 0) {\n\t\tu8 oncmd[] = { CMD_BUSON_TIME, clamp(bus_on, 2, 15) };\n\n\t\taha1542_intr_reset(sh->io_port);\n\t\tif (aha1542_out(sh->io_port, oncmd, 2))\n\t\t\tgoto fail;\n\t}\n\n\tif (bus_off > 0) {\n\t\tu8 offcmd[] = { CMD_BUSOFF_TIME, clamp(bus_off, 1, 64) };\n\n\t\taha1542_intr_reset(sh->io_port);\n\t\tif (aha1542_out(sh->io_port, offcmd, 2))\n\t\t\tgoto fail;\n\t}\n\n\tif (dma_speed_hw(dma_speed) != 0xff) {\n\t\tu8 dmacmd[] = { CMD_DMASPEED, dma_speed_hw(dma_speed) };\n\n\t\taha1542_intr_reset(sh->io_port);\n\t\tif (aha1542_out(sh->io_port, dmacmd, 2))\n\t\t\tgoto fail;\n\t}\n\taha1542_intr_reset(sh->io_port);\n\treturn;\nfail:\n\tshost_printk(KERN_ERR, sh, \"setting bus on/off-time failed\\n\");\n\taha1542_intr_reset(sh->io_port);\n}\n\n \nstatic struct Scsi_Host *aha1542_hw_init(const struct scsi_host_template *tpnt,\n\t\t\t\t\t struct device *pdev, int indx)\n{\n\tunsigned int base_io = io[indx];\n\tstruct Scsi_Host *sh;\n\tstruct aha1542_hostdata *aha1542;\n\tchar dma_info[] = \"no DMA\";\n\n\tif (base_io == 0)\n\t\treturn NULL;\n\n\tif (!request_region(base_io, AHA1542_REGION_SIZE, \"aha1542\"))\n\t\treturn NULL;\n\n\tsh = scsi_host_alloc(tpnt, sizeof(struct aha1542_hostdata));\n\tif (!sh)\n\t\tgoto release;\n\taha1542 = shost_priv(sh);\n\n\tsh->unique_id = base_io;\n\tsh->io_port = base_io;\n\tsh->n_io_port = AHA1542_REGION_SIZE;\n\taha1542->aha1542_last_mbi_used = 2 * AHA1542_MAILBOXES - 1;\n\taha1542->aha1542_last_mbo_used = AHA1542_MAILBOXES - 1;\n\n\tif (!aha1542_test_port(sh))\n\t\tgoto unregister;\n\n\taha1542_set_bus_times(sh, bus_on[indx], bus_off[indx], dma_speed[indx]);\n\tif (aha1542_query(sh))\n\t\tgoto unregister;\n\tif (aha1542_getconfig(sh) == -1)\n\t\tgoto unregister;\n\n\tif (sh->dma_channel != 0xFF)\n\t\tsnprintf(dma_info, sizeof(dma_info), \"DMA %d\", sh->dma_channel);\n\tshost_printk(KERN_INFO, sh, \"Adaptec AHA-1542 (SCSI-ID %d) at IO 0x%x, IRQ %d, %s\\n\",\n\t\t\t\tsh->this_id, base_io, sh->irq, dma_info);\n\tif (aha1542->bios_translation == BIOS_TRANSLATION_25563)\n\t\tshost_printk(KERN_INFO, sh, \"Using extended bios translation\\n\");\n\n\tif (dma_set_mask_and_coherent(pdev, DMA_BIT_MASK(24)) < 0)\n\t\tgoto unregister;\n\n\taha1542->mb = dma_alloc_coherent(pdev,\n\t\t\tAHA1542_MAILBOXES * 2 * sizeof(struct mailbox),\n\t\t\t&aha1542->mb_handle, GFP_KERNEL);\n\tif (!aha1542->mb)\n\t\tgoto unregister;\n\n\taha1542->ccb = dma_alloc_coherent(pdev,\n\t\t\tAHA1542_MAILBOXES * sizeof(struct ccb),\n\t\t\t&aha1542->ccb_handle, GFP_KERNEL);\n\tif (!aha1542->ccb)\n\t\tgoto free_mb;\n\n\tsetup_mailboxes(sh);\n\n\tif (request_irq(sh->irq, aha1542_interrupt, 0, \"aha1542\", sh)) {\n\t\tshost_printk(KERN_ERR, sh, \"Unable to allocate IRQ.\\n\");\n\t\tgoto free_ccb;\n\t}\n\tif (sh->dma_channel != 0xFF) {\n\t\tif (request_dma(sh->dma_channel, \"aha1542\")) {\n\t\t\tshost_printk(KERN_ERR, sh, \"Unable to allocate DMA channel.\\n\");\n\t\t\tgoto free_irq;\n\t\t}\n\t\tif (sh->dma_channel == 0 || sh->dma_channel >= 5) {\n\t\t\tset_dma_mode(sh->dma_channel, DMA_MODE_CASCADE);\n\t\t\tenable_dma(sh->dma_channel);\n\t\t}\n\t}\n\n\tif (scsi_add_host(sh, pdev))\n\t\tgoto free_dma;\n\n\tscsi_scan_host(sh);\n\n\treturn sh;\n\nfree_dma:\n\tif (sh->dma_channel != 0xff)\n\t\tfree_dma(sh->dma_channel);\nfree_irq:\n\tfree_irq(sh->irq, sh);\nfree_ccb:\n\tdma_free_coherent(pdev, AHA1542_MAILBOXES * sizeof(struct ccb),\n\t\t\t  aha1542->ccb, aha1542->ccb_handle);\nfree_mb:\n\tdma_free_coherent(pdev, AHA1542_MAILBOXES * 2 * sizeof(struct mailbox),\n\t\t\t  aha1542->mb, aha1542->mb_handle);\nunregister:\n\tscsi_host_put(sh);\nrelease:\n\trelease_region(base_io, AHA1542_REGION_SIZE);\n\n\treturn NULL;\n}\n\nstatic int aha1542_release(struct Scsi_Host *sh)\n{\n\tstruct aha1542_hostdata *aha1542 = shost_priv(sh);\n\tstruct device *dev = sh->dma_dev;\n\n\tscsi_remove_host(sh);\n\tif (sh->dma_channel != 0xff)\n\t\tfree_dma(sh->dma_channel);\n\tdma_free_coherent(dev, AHA1542_MAILBOXES * sizeof(struct ccb),\n\t\t\t  aha1542->ccb, aha1542->ccb_handle);\n\tdma_free_coherent(dev, AHA1542_MAILBOXES * 2 * sizeof(struct mailbox),\n\t\t\t  aha1542->mb, aha1542->mb_handle);\n\tif (sh->irq)\n\t\tfree_irq(sh->irq, sh);\n\tif (sh->io_port && sh->n_io_port)\n\t\trelease_region(sh->io_port, sh->n_io_port);\n\tscsi_host_put(sh);\n\treturn 0;\n}\n\n\n \nstatic int aha1542_dev_reset(struct scsi_cmnd *cmd)\n{\n\tstruct Scsi_Host *sh = cmd->device->host;\n\tstruct aha1542_hostdata *aha1542 = shost_priv(sh);\n\tunsigned long flags;\n\tstruct mailbox *mb = aha1542->mb;\n\tu8 target = cmd->device->id;\n\tu8 lun = cmd->device->lun;\n\tint mbo;\n\tstruct ccb *ccb = aha1542->ccb;\n\n\tspin_lock_irqsave(sh->host_lock, flags);\n\tmbo = aha1542->aha1542_last_mbo_used + 1;\n\tif (mbo >= AHA1542_MAILBOXES)\n\t\tmbo = 0;\n\n\tdo {\n\t\tif (mb[mbo].status == 0 && aha1542->int_cmds[mbo] == NULL)\n\t\t\tbreak;\n\t\tmbo++;\n\t\tif (mbo >= AHA1542_MAILBOXES)\n\t\t\tmbo = 0;\n\t} while (mbo != aha1542->aha1542_last_mbo_used);\n\n\tif (mb[mbo].status || aha1542->int_cmds[mbo])\n\t\tpanic(\"Unable to find empty mailbox for aha1542.\\n\");\n\n\taha1542->int_cmds[mbo] = cmd;\t \n\n\taha1542->aha1542_last_mbo_used = mbo;\n\n\t \n\tany2scsi(mb[mbo].ccbptr, aha1542->ccb_handle + mbo * sizeof(*ccb));\n\n\tmemset(&ccb[mbo], 0, sizeof(struct ccb));\n\n\tccb[mbo].op = 0x81;\t \n\n\tccb[mbo].idlun = (target & 7) << 5 | (lun & 7);\t\t \n\n\tccb[mbo].linkptr[0] = ccb[mbo].linkptr[1] = ccb[mbo].linkptr[2] = 0;\n\tccb[mbo].commlinkid = 0;\n\n\t \n\taha1542_outb(sh->io_port, CMD_START_SCSI);\n\tspin_unlock_irqrestore(sh->host_lock, flags);\n\n\tscmd_printk(KERN_WARNING, cmd,\n\t\t\"Trying device reset for target\\n\");\n\n\treturn SUCCESS;\n}\n\nstatic int aha1542_reset(struct scsi_cmnd *cmd, u8 reset_cmd)\n{\n\tstruct Scsi_Host *sh = cmd->device->host;\n\tstruct aha1542_hostdata *aha1542 = shost_priv(sh);\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(sh->host_lock, flags);\n\t \n\toutb(reset_cmd, CONTROL(cmd->device->host->io_port));\n\n\tif (!wait_mask(STATUS(cmd->device->host->io_port),\n\t     STATMASK, IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0)) {\n\t\tspin_unlock_irqrestore(sh->host_lock, flags);\n\t\treturn FAILED;\n\t}\n\n\t \n\tif (reset_cmd & HRST)\n\t\tsetup_mailboxes(cmd->device->host);\n\n\t \n\tshost_printk(KERN_WARNING, cmd->device->host, \"Sent BUS RESET to scsi host %d\\n\", cmd->device->host->host_no);\n\n\tfor (i = 0; i < AHA1542_MAILBOXES; i++) {\n\t\tif (aha1542->int_cmds[i] != NULL) {\n\t\t\tstruct scsi_cmnd *tmp_cmd;\n\t\t\ttmp_cmd = aha1542->int_cmds[i];\n\n\t\t\tif (tmp_cmd->device->soft_reset) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taha1542_free_cmd(tmp_cmd);\n\t\t\taha1542->int_cmds[i] = NULL;\n\t\t\taha1542->mb[i].status = 0;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(sh->host_lock, flags);\n\treturn SUCCESS;\n}\n\nstatic int aha1542_bus_reset(struct scsi_cmnd *cmd)\n{\n\treturn aha1542_reset(cmd, SCRST);\n}\n\nstatic int aha1542_host_reset(struct scsi_cmnd *cmd)\n{\n\treturn aha1542_reset(cmd, HRST | SCRST);\n}\n\nstatic int aha1542_biosparam(struct scsi_device *sdev,\n\t\tstruct block_device *bdev, sector_t capacity, int geom[])\n{\n\tstruct aha1542_hostdata *aha1542 = shost_priv(sdev->host);\n\n\tif (capacity >= 0x200000 &&\n\t\t\taha1542->bios_translation == BIOS_TRANSLATION_25563) {\n\t\t \n\t\tgeom[0] = 255;\t \n\t\tgeom[1] = 63;\t \n\t} else {\n\t\tgeom[0] = 64;\t \n\t\tgeom[1] = 32;\t \n\t}\n\tgeom[2] = sector_div(capacity, geom[0] * geom[1]);\t \n\n\treturn 0;\n}\nMODULE_LICENSE(\"GPL\");\n\nstatic int aha1542_init_cmd_priv(struct Scsi_Host *shost, struct scsi_cmnd *cmd)\n{\n\tstruct aha1542_cmd *acmd = scsi_cmd_priv(cmd);\n\n\tacmd->data_buffer = dma_alloc_coherent(shost->dma_dev,\n\t\t\tSECTOR_SIZE * AHA1542_MAX_SECTORS,\n\t\t\t&acmd->data_buffer_handle, GFP_KERNEL);\n\tif (!acmd->data_buffer)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int aha1542_exit_cmd_priv(struct Scsi_Host *shost, struct scsi_cmnd *cmd)\n{\n\tstruct aha1542_cmd *acmd = scsi_cmd_priv(cmd);\n\n\tdma_free_coherent(shost->dma_dev, SECTOR_SIZE * AHA1542_MAX_SECTORS,\n\t\t\tacmd->data_buffer, acmd->data_buffer_handle);\n\treturn 0;\n}\n\nstatic const struct scsi_host_template driver_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.proc_name\t\t= \"aha1542\",\n\t.name\t\t\t= \"Adaptec 1542\",\n\t.cmd_size\t\t= sizeof(struct aha1542_cmd),\n\t.queuecommand\t\t= aha1542_queuecommand,\n\t.eh_device_reset_handler= aha1542_dev_reset,\n\t.eh_bus_reset_handler\t= aha1542_bus_reset,\n\t.eh_host_reset_handler\t= aha1542_host_reset,\n\t.bios_param\t\t= aha1542_biosparam,\n\t.init_cmd_priv\t\t= aha1542_init_cmd_priv,\n\t.exit_cmd_priv\t\t= aha1542_exit_cmd_priv,\n\t.can_queue\t\t= AHA1542_MAILBOXES,\n\t.this_id\t\t= 7,\n\t.max_sectors\t\t= AHA1542_MAX_SECTORS,\n\t.sg_tablesize\t\t= SG_ALL,\n};\n\nstatic int aha1542_isa_match(struct device *pdev, unsigned int ndev)\n{\n\tstruct Scsi_Host *sh = aha1542_hw_init(&driver_template, pdev, ndev);\n\n\tif (!sh)\n\t\treturn 0;\n\n\tdev_set_drvdata(pdev, sh);\n\treturn 1;\n}\n\nstatic void aha1542_isa_remove(struct device *pdev,\n\t\t\t\t    unsigned int ndev)\n{\n\taha1542_release(dev_get_drvdata(pdev));\n\tdev_set_drvdata(pdev, NULL);\n}\n\nstatic struct isa_driver aha1542_isa_driver = {\n\t.match\t\t= aha1542_isa_match,\n\t.remove\t\t= aha1542_isa_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"aha1542\"\n\t},\n};\nstatic int isa_registered;\n\n#ifdef CONFIG_PNP\nstatic const struct pnp_device_id aha1542_pnp_ids[] = {\n\t{ .id = \"ADP1542\" },\n\t{ .id = \"\" }\n};\nMODULE_DEVICE_TABLE(pnp, aha1542_pnp_ids);\n\nstatic int aha1542_pnp_probe(struct pnp_dev *pdev, const struct pnp_device_id *id)\n{\n\tint indx;\n\tstruct Scsi_Host *sh;\n\n\tfor (indx = 0; indx < ARRAY_SIZE(io); indx++) {\n\t\tif (io[indx])\n\t\t\tcontinue;\n\n\t\tif (pnp_activate_dev(pdev) < 0)\n\t\t\tcontinue;\n\n\t\tio[indx] = pnp_port_start(pdev, 0);\n\n\t\t \n\n\t\tdev_info(&pdev->dev, \"ISAPnP found an AHA1535 at I/O 0x%03X\", io[indx]);\n\t}\n\n\tsh = aha1542_hw_init(&driver_template, &pdev->dev, indx);\n\tif (!sh)\n\t\treturn -ENODEV;\n\n\tpnp_set_drvdata(pdev, sh);\n\treturn 0;\n}\n\nstatic void aha1542_pnp_remove(struct pnp_dev *pdev)\n{\n\taha1542_release(pnp_get_drvdata(pdev));\n\tpnp_set_drvdata(pdev, NULL);\n}\n\nstatic struct pnp_driver aha1542_pnp_driver = {\n\t.name\t\t= \"aha1542\",\n\t.id_table\t= aha1542_pnp_ids,\n\t.probe\t\t= aha1542_pnp_probe,\n\t.remove\t\t= aha1542_pnp_remove,\n};\nstatic int pnp_registered;\n#endif  \n\nstatic int __init aha1542_init(void)\n{\n\tint ret = 0;\n\n#ifdef CONFIG_PNP\n\tif (isapnp) {\n\t\tret = pnp_register_driver(&aha1542_pnp_driver);\n\t\tif (!ret)\n\t\t\tpnp_registered = 1;\n\t}\n#endif\n\tret = isa_register_driver(&aha1542_isa_driver, MAXBOARDS);\n\tif (!ret)\n\t\tisa_registered = 1;\n\n#ifdef CONFIG_PNP\n\tif (pnp_registered)\n\t\tret = 0;\n#endif\n\tif (isa_registered)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic void __exit aha1542_exit(void)\n{\n#ifdef CONFIG_PNP\n\tif (pnp_registered)\n\t\tpnp_unregister_driver(&aha1542_pnp_driver);\n#endif\n\tif (isa_registered)\n\t\tisa_unregister_driver(&aha1542_isa_driver);\n}\n\nmodule_init(aha1542_init);\nmodule_exit(aha1542_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}