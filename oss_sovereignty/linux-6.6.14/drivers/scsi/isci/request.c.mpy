{
  "module_name": "request.c",
  "hash_id": "dc8b64d3bb67c5676ad2b10f10b1f80c0e01ab0c176216792cb8f64b380868a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/isci/request.c",
  "human_readable_source": " \n\n#include <scsi/scsi_cmnd.h>\n#include \"isci.h\"\n#include \"task.h\"\n#include \"request.h\"\n#include \"scu_completion_codes.h\"\n#include \"scu_event_codes.h\"\n#include \"sas.h\"\n\n#undef C\n#define C(a) (#a)\nconst char *req_state_name(enum sci_base_request_states state)\n{\n\tstatic const char * const strings[] = REQUEST_STATES;\n\n\treturn strings[state];\n}\n#undef C\n\nstatic struct scu_sgl_element_pair *to_sgl_element_pair(struct isci_request *ireq,\n\t\t\t\t\t\t\tint idx)\n{\n\tif (idx == 0)\n\t\treturn &ireq->tc->sgl_pair_ab;\n\telse if (idx == 1)\n\t\treturn &ireq->tc->sgl_pair_cd;\n\telse if (idx < 0)\n\t\treturn NULL;\n\telse\n\t\treturn &ireq->sg_table[idx - 2];\n}\n\nstatic dma_addr_t to_sgl_element_pair_dma(struct isci_host *ihost,\n\t\t\t\t\t  struct isci_request *ireq, u32 idx)\n{\n\tu32 offset;\n\n\tif (idx == 0) {\n\t\toffset = (void *) &ireq->tc->sgl_pair_ab -\n\t\t\t (void *) &ihost->task_context_table[0];\n\t\treturn ihost->tc_dma + offset;\n\t} else if (idx == 1) {\n\t\toffset = (void *) &ireq->tc->sgl_pair_cd -\n\t\t\t (void *) &ihost->task_context_table[0];\n\t\treturn ihost->tc_dma + offset;\n\t}\n\n\treturn sci_io_request_get_dma_addr(ireq, &ireq->sg_table[idx - 2]);\n}\n\nstatic void init_sgl_element(struct scu_sgl_element *e, struct scatterlist *sg)\n{\n\te->length = sg_dma_len(sg);\n\te->address_upper = upper_32_bits(sg_dma_address(sg));\n\te->address_lower = lower_32_bits(sg_dma_address(sg));\n\te->address_modifier = 0;\n}\n\nstatic void sci_request_build_sgl(struct isci_request *ireq)\n{\n\tstruct isci_host *ihost = ireq->isci_host;\n\tstruct sas_task *task = isci_request_access_task(ireq);\n\tstruct scatterlist *sg = NULL;\n\tdma_addr_t dma_addr;\n\tu32 sg_idx = 0;\n\tstruct scu_sgl_element_pair *scu_sg   = NULL;\n\tstruct scu_sgl_element_pair *prev_sg  = NULL;\n\n\tif (task->num_scatter > 0) {\n\t\tsg = task->scatter;\n\n\t\twhile (sg) {\n\t\t\tscu_sg = to_sgl_element_pair(ireq, sg_idx);\n\t\t\tinit_sgl_element(&scu_sg->A, sg);\n\t\t\tsg = sg_next(sg);\n\t\t\tif (sg) {\n\t\t\t\tinit_sgl_element(&scu_sg->B, sg);\n\t\t\t\tsg = sg_next(sg);\n\t\t\t} else\n\t\t\t\tmemset(&scu_sg->B, 0, sizeof(scu_sg->B));\n\n\t\t\tif (prev_sg) {\n\t\t\t\tdma_addr = to_sgl_element_pair_dma(ihost,\n\t\t\t\t\t\t\t\t   ireq,\n\t\t\t\t\t\t\t\t   sg_idx);\n\n\t\t\t\tprev_sg->next_pair_upper =\n\t\t\t\t\tupper_32_bits(dma_addr);\n\t\t\t\tprev_sg->next_pair_lower =\n\t\t\t\t\tlower_32_bits(dma_addr);\n\t\t\t}\n\n\t\t\tprev_sg = scu_sg;\n\t\t\tsg_idx++;\n\t\t}\n\t} else {\t \n\t\tscu_sg = to_sgl_element_pair(ireq, sg_idx);\n\n\t\tdma_addr = dma_map_single(&ihost->pdev->dev,\n\t\t\t\t\t  task->scatter,\n\t\t\t\t\t  task->total_xfer_len,\n\t\t\t\t\t  task->data_dir);\n\n\t\tireq->zero_scatter_daddr = dma_addr;\n\n\t\tscu_sg->A.length = task->total_xfer_len;\n\t\tscu_sg->A.address_upper = upper_32_bits(dma_addr);\n\t\tscu_sg->A.address_lower = lower_32_bits(dma_addr);\n\t}\n\n\tif (scu_sg) {\n\t\tscu_sg->next_pair_upper = 0;\n\t\tscu_sg->next_pair_lower = 0;\n\t}\n}\n\nstatic void sci_io_request_build_ssp_command_iu(struct isci_request *ireq)\n{\n\tstruct ssp_cmd_iu *cmd_iu;\n\tstruct sas_task *task = isci_request_access_task(ireq);\n\n\tcmd_iu = &ireq->ssp.cmd;\n\n\tmemcpy(cmd_iu->LUN, task->ssp_task.LUN, 8);\n\tcmd_iu->add_cdb_len = 0;\n\tcmd_iu->_r_a = 0;\n\tcmd_iu->_r_b = 0;\n\tcmd_iu->en_fburst = 0;  \n\tcmd_iu->task_prio = 0;\n\tcmd_iu->task_attr = task->ssp_task.task_attr;\n\tcmd_iu->_r_c = 0;\n\n\tsci_swab32_cpy(&cmd_iu->cdb, task->ssp_task.cmd->cmnd,\n\t\t       (task->ssp_task.cmd->cmd_len+3) / sizeof(u32));\n}\n\nstatic void sci_task_request_build_ssp_task_iu(struct isci_request *ireq)\n{\n\tstruct ssp_task_iu *task_iu;\n\tstruct sas_task *task = isci_request_access_task(ireq);\n\tstruct isci_tmf *isci_tmf = isci_request_access_tmf(ireq);\n\n\ttask_iu = &ireq->ssp.tmf;\n\n\tmemset(task_iu, 0, sizeof(struct ssp_task_iu));\n\n\tmemcpy(task_iu->LUN, task->ssp_task.LUN, 8);\n\n\ttask_iu->task_func = isci_tmf->tmf_code;\n\ttask_iu->task_tag =\n\t\t(test_bit(IREQ_TMF, &ireq->flags)) ?\n\t\tisci_tmf->io_tag :\n\t\tSCI_CONTROLLER_INVALID_IO_TAG;\n}\n\n \nstatic void scu_ssp_request_construct_task_context(\n\tstruct isci_request *ireq,\n\tstruct scu_task_context *task_context)\n{\n\tdma_addr_t dma_addr;\n\tstruct isci_remote_device *idev;\n\tstruct isci_port *iport;\n\n\tidev = ireq->target_device;\n\tiport = idev->owning_port;\n\n\t \n\ttask_context->abort = 0;\n\ttask_context->priority = 0;\n\ttask_context->initiator_request = 1;\n\ttask_context->connection_rate = idev->connection_rate;\n\ttask_context->protocol_engine_index = ISCI_PEG;\n\ttask_context->logical_port_index = iport->physical_port_index;\n\ttask_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SSP;\n\ttask_context->valid = SCU_TASK_CONTEXT_VALID;\n\ttask_context->context_type = SCU_TASK_CONTEXT_TYPE;\n\n\ttask_context->remote_node_index = idev->rnc.remote_node_index;\n\ttask_context->command_code = 0;\n\n\ttask_context->link_layer_control = 0;\n\ttask_context->do_not_dma_ssp_good_response = 1;\n\ttask_context->strict_ordering = 0;\n\ttask_context->control_frame = 0;\n\ttask_context->timeout_enable = 0;\n\ttask_context->block_guard_enable = 0;\n\n\ttask_context->address_modifier = 0;\n\n\t \n\ttask_context->task_phase = 0x01;\n\n\tireq->post_context = (SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |\n\t\t\t      (ISCI_PEG << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |\n\t\t\t      (iport->physical_port_index <<\n\t\t\t       SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |\n\t\t\t      ISCI_TAG_TCI(ireq->io_tag));\n\n\t \n\tdma_addr = sci_io_request_get_dma_addr(ireq, &ireq->ssp.cmd);\n\n\ttask_context->command_iu_upper = upper_32_bits(dma_addr);\n\ttask_context->command_iu_lower = lower_32_bits(dma_addr);\n\n\t \n\tdma_addr = sci_io_request_get_dma_addr(ireq, &ireq->ssp.rsp);\n\n\ttask_context->response_iu_upper = upper_32_bits(dma_addr);\n\ttask_context->response_iu_lower = lower_32_bits(dma_addr);\n}\n\nstatic u8 scu_bg_blk_size(struct scsi_device *sdp)\n{\n\tswitch (sdp->sector_size) {\n\tcase 512:\n\t\treturn 0;\n\tcase 1024:\n\t\treturn 1;\n\tcase 4096:\n\t\treturn 3;\n\tdefault:\n\t\treturn 0xff;\n\t}\n}\n\nstatic u32 scu_dif_bytes(u32 len, u32 sector_size)\n{\n\treturn (len >> ilog2(sector_size)) * 8;\n}\n\nstatic void scu_ssp_ireq_dif_insert(struct isci_request *ireq, u8 type, u8 op)\n{\n\tstruct scu_task_context *tc = ireq->tc;\n\tstruct scsi_cmnd *scmd = ireq->ttype_ptr.io_task_ptr->uldd_task;\n\tu8 blk_sz = scu_bg_blk_size(scmd->device);\n\n\ttc->block_guard_enable = 1;\n\ttc->blk_prot_en = 1;\n\ttc->blk_sz = blk_sz;\n\t \n\ttc->blk_prot_func = 0x2;\n\n\ttc->transfer_length_bytes += scu_dif_bytes(tc->transfer_length_bytes,\n\t\t\t\t\t\t   scmd->device->sector_size);\n\n\t \n\ttc->interm_crc_val = 0;\n\n\ttc->init_crc_seed = 0;\n\ttc->app_tag_verify = 0;\n\ttc->app_tag_gen = 0;\n\ttc->ref_tag_seed_verify = 0;\n\n\t \n\ttc->UD_bytes_immed_val = scmd->device->sector_size;\n\n\ttc->reserved_DC_0 = 0;\n\n\t \n\ttc->DIF_bytes_immed_val = 8;\n\n\ttc->reserved_DC_1 = 0;\n\ttc->bgc_blk_sz = scmd->device->sector_size;\n\ttc->reserved_E0_0 = 0;\n\ttc->app_tag_gen_mask = 0;\n\n\t \n\ttc->bgctl = 0;\n\n\t \n\ttc->bgctl_f.op = 0x2;\n\n\ttc->app_tag_verify_mask = 0;\n\n\t \n\ttc->blk_guard_err = 0;\n\n\ttc->reserved_E8_0 = 0;\n\n\tif ((type & SCSI_PROT_DIF_TYPE1) || (type & SCSI_PROT_DIF_TYPE2))\n\t\ttc->ref_tag_seed_gen = scsi_prot_ref_tag(scmd);\n\telse if (type & SCSI_PROT_DIF_TYPE3)\n\t\ttc->ref_tag_seed_gen = 0;\n}\n\nstatic void scu_ssp_ireq_dif_strip(struct isci_request *ireq, u8 type, u8 op)\n{\n\tstruct scu_task_context *tc = ireq->tc;\n\tstruct scsi_cmnd *scmd = ireq->ttype_ptr.io_task_ptr->uldd_task;\n\tu8 blk_sz = scu_bg_blk_size(scmd->device);\n\n\ttc->block_guard_enable = 1;\n\ttc->blk_prot_en = 1;\n\ttc->blk_sz = blk_sz;\n\t \n\ttc->blk_prot_func = 0x1;\n\n\ttc->transfer_length_bytes += scu_dif_bytes(tc->transfer_length_bytes,\n\t\t\t\t\t\t   scmd->device->sector_size);\n\n\t \n\ttc->interm_crc_val = 0;\n\n\ttc->init_crc_seed = 0;\n\ttc->app_tag_verify = 0;\n\ttc->app_tag_gen = 0;\n\n\tif ((type & SCSI_PROT_DIF_TYPE1) || (type & SCSI_PROT_DIF_TYPE2))\n\t\ttc->ref_tag_seed_verify = scsi_prot_ref_tag(scmd);\n\telse if (type & SCSI_PROT_DIF_TYPE3)\n\t\ttc->ref_tag_seed_verify = 0;\n\n\t \n\ttc->UD_bytes_immed_val = scmd->device->sector_size;\n\n\ttc->reserved_DC_0 = 0;\n\n\t \n\ttc->DIF_bytes_immed_val = 8;\n\n\ttc->reserved_DC_1 = 0;\n\ttc->bgc_blk_sz = scmd->device->sector_size;\n\ttc->reserved_E0_0 = 0;\n\ttc->app_tag_gen_mask = 0;\n\n\t \n\ttc->bgctl = 0;\n\n\t \n\ttc->bgctl_f.crc_verify = 1;\n\ttc->bgctl_f.op = 0x1;\n\tif ((type & SCSI_PROT_DIF_TYPE1) || (type & SCSI_PROT_DIF_TYPE2)) {\n\t\ttc->bgctl_f.ref_tag_chk = 1;\n\t\ttc->bgctl_f.app_f_detect = 1;\n\t} else if (type & SCSI_PROT_DIF_TYPE3)\n\t\ttc->bgctl_f.app_ref_f_detect = 1;\n\n\ttc->app_tag_verify_mask = 0;\n\n\t \n\ttc->blk_guard_err = 0;\n\n\ttc->reserved_E8_0 = 0;\n\ttc->ref_tag_seed_gen = 0;\n}\n\n \nstatic void scu_ssp_io_request_construct_task_context(struct isci_request *ireq,\n\t\t\t\t\t\t      enum dma_data_direction dir,\n\t\t\t\t\t\t      u32 len)\n{\n\tstruct scu_task_context *task_context = ireq->tc;\n\tstruct sas_task *sas_task = ireq->ttype_ptr.io_task_ptr;\n\tstruct scsi_cmnd *scmd = sas_task->uldd_task;\n\tu8 prot_type = scsi_get_prot_type(scmd);\n\tu8 prot_op = scsi_get_prot_op(scmd);\n\n\tscu_ssp_request_construct_task_context(ireq, task_context);\n\n\ttask_context->ssp_command_iu_length =\n\t\tsizeof(struct ssp_cmd_iu) / sizeof(u32);\n\ttask_context->type.ssp.frame_type = SSP_COMMAND;\n\n\tswitch (dir) {\n\tcase DMA_FROM_DEVICE:\n\tcase DMA_NONE:\n\tdefault:\n\t\ttask_context->task_type = SCU_TASK_TYPE_IOREAD;\n\t\tbreak;\n\tcase DMA_TO_DEVICE:\n\t\ttask_context->task_type = SCU_TASK_TYPE_IOWRITE;\n\t\tbreak;\n\t}\n\n\ttask_context->transfer_length_bytes = len;\n\n\tif (task_context->transfer_length_bytes > 0)\n\t\tsci_request_build_sgl(ireq);\n\n\tif (prot_type != SCSI_PROT_DIF_TYPE0) {\n\t\tif (prot_op == SCSI_PROT_READ_STRIP)\n\t\t\tscu_ssp_ireq_dif_strip(ireq, prot_type, prot_op);\n\t\telse if (prot_op == SCSI_PROT_WRITE_INSERT)\n\t\t\tscu_ssp_ireq_dif_insert(ireq, prot_type, prot_op);\n\t}\n}\n\n \nstatic void scu_ssp_task_request_construct_task_context(struct isci_request *ireq)\n{\n\tstruct scu_task_context *task_context = ireq->tc;\n\n\tscu_ssp_request_construct_task_context(ireq, task_context);\n\n\ttask_context->control_frame                = 1;\n\ttask_context->priority                     = SCU_TASK_PRIORITY_HIGH;\n\ttask_context->task_type                    = SCU_TASK_TYPE_RAW_FRAME;\n\ttask_context->transfer_length_bytes        = 0;\n\ttask_context->type.ssp.frame_type          = SSP_TASK;\n\ttask_context->ssp_command_iu_length =\n\t\tsizeof(struct ssp_task_iu) / sizeof(u32);\n}\n\n \nstatic void scu_sata_request_construct_task_context(\n\tstruct isci_request *ireq,\n\tstruct scu_task_context *task_context)\n{\n\tdma_addr_t dma_addr;\n\tstruct isci_remote_device *idev;\n\tstruct isci_port *iport;\n\n\tidev = ireq->target_device;\n\tiport = idev->owning_port;\n\n\t \n\ttask_context->abort = 0;\n\ttask_context->priority = SCU_TASK_PRIORITY_NORMAL;\n\ttask_context->initiator_request = 1;\n\ttask_context->connection_rate = idev->connection_rate;\n\ttask_context->protocol_engine_index = ISCI_PEG;\n\ttask_context->logical_port_index = iport->physical_port_index;\n\ttask_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_STP;\n\ttask_context->valid = SCU_TASK_CONTEXT_VALID;\n\ttask_context->context_type = SCU_TASK_CONTEXT_TYPE;\n\n\ttask_context->remote_node_index = idev->rnc.remote_node_index;\n\ttask_context->command_code = 0;\n\n\ttask_context->link_layer_control = 0;\n\ttask_context->do_not_dma_ssp_good_response = 1;\n\ttask_context->strict_ordering = 0;\n\ttask_context->control_frame = 0;\n\ttask_context->timeout_enable = 0;\n\ttask_context->block_guard_enable = 0;\n\n\ttask_context->address_modifier = 0;\n\ttask_context->task_phase = 0x01;\n\n\ttask_context->ssp_command_iu_length =\n\t\t(sizeof(struct host_to_dev_fis) - sizeof(u32)) / sizeof(u32);\n\n\t \n\ttask_context->type.words[0] = *(u32 *)&ireq->stp.cmd;\n\n\tireq->post_context = (SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |\n\t\t\t      (ISCI_PEG << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |\n\t\t\t      (iport->physical_port_index <<\n\t\t\t       SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |\n\t\t\t      ISCI_TAG_TCI(ireq->io_tag));\n\t \n\tdma_addr = sci_io_request_get_dma_addr(ireq,\n\t\t\t\t\t\t((char *) &ireq->stp.cmd) +\n\t\t\t\t\t\tsizeof(u32));\n\n\ttask_context->command_iu_upper = upper_32_bits(dma_addr);\n\ttask_context->command_iu_lower = lower_32_bits(dma_addr);\n\n\t \n\ttask_context->response_iu_upper = 0;\n\ttask_context->response_iu_lower = 0;\n}\n\nstatic void scu_stp_raw_request_construct_task_context(struct isci_request *ireq)\n{\n\tstruct scu_task_context *task_context = ireq->tc;\n\n\tscu_sata_request_construct_task_context(ireq, task_context);\n\n\ttask_context->control_frame         = 0;\n\ttask_context->priority              = SCU_TASK_PRIORITY_NORMAL;\n\ttask_context->task_type             = SCU_TASK_TYPE_SATA_RAW_FRAME;\n\ttask_context->type.stp.fis_type     = FIS_REGH2D;\n\ttask_context->transfer_length_bytes = sizeof(struct host_to_dev_fis) - sizeof(u32);\n}\n\nstatic enum sci_status sci_stp_pio_request_construct(struct isci_request *ireq,\n\t\t\t\t\t\t\t  bool copy_rx_frame)\n{\n\tstruct isci_stp_request *stp_req = &ireq->stp.req;\n\n\tscu_stp_raw_request_construct_task_context(ireq);\n\n\tstp_req->status = 0;\n\tstp_req->sgl.offset = 0;\n\tstp_req->sgl.set = SCU_SGL_ELEMENT_PAIR_A;\n\n\tif (copy_rx_frame) {\n\t\tsci_request_build_sgl(ireq);\n\t\tstp_req->sgl.index = 0;\n\t} else {\n\t\t \n\t\tstp_req->sgl.index = -1;\n\t}\n\n\treturn SCI_SUCCESS;\n}\n\n \nstatic void sci_stp_optimized_request_construct(struct isci_request *ireq,\n\t\t\t\t\t\t     u8 optimized_task_type,\n\t\t\t\t\t\t     u32 len,\n\t\t\t\t\t\t     enum dma_data_direction dir)\n{\n\tstruct scu_task_context *task_context = ireq->tc;\n\n\t \n\tscu_sata_request_construct_task_context(ireq, task_context);\n\n\t \n\tsci_request_build_sgl(ireq);\n\n\t \n\ttask_context->transfer_length_bytes = len;\n\n\tif (dir == DMA_TO_DEVICE) {\n\t\t \n\t\ttask_context->task_type = optimized_task_type + (SCU_TASK_TYPE_DMA_OUT\n\t\t\t\t\t\t\t\t - SCU_TASK_TYPE_DMA_IN);\n\t} else {\n\t\t \n\t\ttask_context->task_type = optimized_task_type;\n\t}\n}\n\nstatic void sci_atapi_construct(struct isci_request *ireq)\n{\n\tstruct host_to_dev_fis *h2d_fis = &ireq->stp.cmd;\n\tstruct sas_task *task;\n\n\t \n\th2d_fis->features |= ATAPI_PKT_DMA;\n\n\tscu_stp_raw_request_construct_task_context(ireq);\n\n\ttask = isci_request_access_task(ireq);\n\tif (task->data_dir == DMA_NONE)\n\t\ttask->total_xfer_len = 0;\n\n\t \n\tireq->stp.rsp.fis_type = 0;\n}\n\nstatic enum sci_status\nsci_io_request_construct_sata(struct isci_request *ireq,\n\t\t\t       u32 len,\n\t\t\t       enum dma_data_direction dir,\n\t\t\t       bool copy)\n{\n\tenum sci_status status = SCI_SUCCESS;\n\tstruct sas_task *task = isci_request_access_task(ireq);\n\tstruct domain_device *dev = ireq->target_device->domain_dev;\n\n\t \n\tif (test_bit(IREQ_TMF, &ireq->flags)) {\n\t\tstruct isci_tmf *tmf = isci_request_access_tmf(ireq);\n\n\t\tdev_err(&ireq->owning_controller->pdev->dev,\n\t\t\t\"%s: Request 0x%p received un-handled SAT \"\n\t\t\t\"management protocol 0x%x.\\n\",\n\t\t\t__func__, ireq, tmf->tmf_code);\n\n\t\treturn SCI_FAILURE;\n\t}\n\n\tif (!sas_protocol_ata(task->task_proto)) {\n\t\tdev_err(&ireq->owning_controller->pdev->dev,\n\t\t\t\"%s: Non-ATA protocol in SATA path: 0x%x\\n\",\n\t\t\t__func__,\n\t\t\ttask->task_proto);\n\t\treturn SCI_FAILURE;\n\n\t}\n\n\t \n\tif (dev->sata_dev.class == ATA_DEV_ATAPI &&\n\t    task->ata_task.fis.command == ATA_CMD_PACKET) {\n\t\tsci_atapi_construct(ireq);\n\t\treturn SCI_SUCCESS;\n\t}\n\n\t \n\tif (task->data_dir == DMA_NONE) {\n\t\tscu_stp_raw_request_construct_task_context(ireq);\n\t\treturn SCI_SUCCESS;\n\t}\n\n\t \n\tif (task->ata_task.use_ncq) {\n\t\tsci_stp_optimized_request_construct(ireq,\n\t\t\t\t\t\t\t SCU_TASK_TYPE_FPDMAQ_READ,\n\t\t\t\t\t\t\t len, dir);\n\t\treturn SCI_SUCCESS;\n\t}\n\n\t \n\tif (task->ata_task.dma_xfer) {\n\t\tsci_stp_optimized_request_construct(ireq,\n\t\t\t\t\t\t\t SCU_TASK_TYPE_DMA_IN,\n\t\t\t\t\t\t\t len, dir);\n\t\treturn SCI_SUCCESS;\n\t} else  \n\t\treturn sci_stp_pio_request_construct(ireq, copy);\n\n\treturn status;\n}\n\nstatic enum sci_status sci_io_request_construct_basic_ssp(struct isci_request *ireq)\n{\n\tstruct sas_task *task = isci_request_access_task(ireq);\n\n\tireq->protocol = SAS_PROTOCOL_SSP;\n\n\tscu_ssp_io_request_construct_task_context(ireq,\n\t\t\t\t\t\t  task->data_dir,\n\t\t\t\t\t\t  task->total_xfer_len);\n\n\tsci_io_request_build_ssp_command_iu(ireq);\n\n\tsci_change_state(&ireq->sm, SCI_REQ_CONSTRUCTED);\n\n\treturn SCI_SUCCESS;\n}\n\nenum sci_status sci_task_request_construct_ssp(\n\tstruct isci_request *ireq)\n{\n\t \n\tscu_ssp_task_request_construct_task_context(ireq);\n\n\t \n\tsci_task_request_build_ssp_task_iu(ireq);\n\n\tsci_change_state(&ireq->sm, SCI_REQ_CONSTRUCTED);\n\n\treturn SCI_SUCCESS;\n}\n\nstatic enum sci_status sci_io_request_construct_basic_sata(struct isci_request *ireq)\n{\n\tenum sci_status status;\n\tbool copy = false;\n\tstruct sas_task *task = isci_request_access_task(ireq);\n\n\tireq->protocol = SAS_PROTOCOL_STP;\n\n\tcopy = (task->data_dir == DMA_NONE) ? false : true;\n\n\tstatus = sci_io_request_construct_sata(ireq,\n\t\t\t\t\t\ttask->total_xfer_len,\n\t\t\t\t\t\ttask->data_dir,\n\t\t\t\t\t\tcopy);\n\n\tif (status == SCI_SUCCESS)\n\t\tsci_change_state(&ireq->sm, SCI_REQ_CONSTRUCTED);\n\n\treturn status;\n}\n\n#define SCU_TASK_CONTEXT_SRAM 0x200000\n \nstatic u32 sci_req_tx_bytes(struct isci_request *ireq)\n{\n\tstruct isci_host *ihost = ireq->owning_controller;\n\tu32 ret_val = 0;\n\n\tif (readl(&ihost->smu_registers->address_modifier) == 0) {\n\t\tvoid __iomem *scu_reg_base = ihost->scu_registers;\n\n\t\t \n\t\tret_val = readl(scu_reg_base +\n\t\t\t\t(SCU_TASK_CONTEXT_SRAM + offsetof(struct scu_task_context, type.ssp.data_offset)) +\n\t\t\t\t((sizeof(struct scu_task_context)) * ISCI_TAG_TCI(ireq->io_tag)));\n\t}\n\n\treturn ret_val;\n}\n\nenum sci_status sci_request_start(struct isci_request *ireq)\n{\n\tenum sci_base_request_states state;\n\tstruct scu_task_context *tc = ireq->tc;\n\tstruct isci_host *ihost = ireq->owning_controller;\n\n\tstate = ireq->sm.current_state_id;\n\tif (state != SCI_REQ_CONSTRUCTED) {\n\t\tdev_warn(&ihost->pdev->dev,\n\t\t\t\"%s: SCIC IO Request requested to start while in wrong \"\n\t\t\t \"state %d\\n\", __func__, state);\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n\n\ttc->task_index = ISCI_TAG_TCI(ireq->io_tag);\n\n\tswitch (tc->protocol_type) {\n\tcase SCU_TASK_CONTEXT_PROTOCOL_SMP:\n\tcase SCU_TASK_CONTEXT_PROTOCOL_SSP:\n\t\t \n\t\ttc->type.ssp.tag = ireq->io_tag;\n\t\ttc->type.ssp.target_port_transfer_tag = 0xFFFF;\n\t\tbreak;\n\n\tcase SCU_TASK_CONTEXT_PROTOCOL_STP:\n\t\t \n\t\tbreak;\n\n\tcase SCU_TASK_CONTEXT_PROTOCOL_NONE:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tireq->post_context |= ISCI_TAG_TCI(ireq->io_tag);\n\n\t \n\tsci_change_state(&ireq->sm, SCI_REQ_STARTED);\n\n\treturn SCI_SUCCESS;\n}\n\nenum sci_status\nsci_io_request_terminate(struct isci_request *ireq)\n{\n\tenum sci_base_request_states state;\n\n\tstate = ireq->sm.current_state_id;\n\n\tswitch (state) {\n\tcase SCI_REQ_CONSTRUCTED:\n\t\t \n\t\tset_bit(IREQ_TC_ABORT_POSTED, &ireq->flags);\n\t\tireq->scu_status = SCU_TASK_DONE_TASK_ABORT;\n\t\tireq->sci_status = SCI_FAILURE_IO_TERMINATED;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\treturn SCI_SUCCESS;\n\tcase SCI_REQ_STARTED:\n\tcase SCI_REQ_TASK_WAIT_TC_COMP:\n\tcase SCI_REQ_SMP_WAIT_RESP:\n\tcase SCI_REQ_SMP_WAIT_TC_COMP:\n\tcase SCI_REQ_STP_UDMA_WAIT_TC_COMP:\n\tcase SCI_REQ_STP_UDMA_WAIT_D2H:\n\tcase SCI_REQ_STP_NON_DATA_WAIT_H2D:\n\tcase SCI_REQ_STP_NON_DATA_WAIT_D2H:\n\tcase SCI_REQ_STP_PIO_WAIT_H2D:\n\tcase SCI_REQ_STP_PIO_WAIT_FRAME:\n\tcase SCI_REQ_STP_PIO_DATA_IN:\n\tcase SCI_REQ_STP_PIO_DATA_OUT:\n\tcase SCI_REQ_ATAPI_WAIT_H2D:\n\tcase SCI_REQ_ATAPI_WAIT_PIO_SETUP:\n\tcase SCI_REQ_ATAPI_WAIT_D2H:\n\tcase SCI_REQ_ATAPI_WAIT_TC_COMP:\n\t\t \n\tcase SCI_REQ_TASK_WAIT_TC_RESP:\n\t\t \n\t\tsci_change_state(&ireq->sm, SCI_REQ_ABORTING);\n\t\tfallthrough;\t \n\tcase SCI_REQ_ABORTING:\n\t\tif (!isci_remote_device_is_safe_to_abort(ireq->target_device))\n\t\t\tset_bit(IREQ_PENDING_ABORT, &ireq->flags);\n\t\telse\n\t\t\tclear_bit(IREQ_PENDING_ABORT, &ireq->flags);\n\t\t \n\t\treturn SCI_SUCCESS;\n\tcase SCI_REQ_COMPLETED:\n\tdefault:\n\t\tdev_warn(&ireq->owning_controller->pdev->dev,\n\t\t\t \"%s: SCIC IO Request requested to abort while in wrong \"\n\t\t\t \"state %d\\n\", __func__, ireq->sm.current_state_id);\n\t\tbreak;\n\t}\n\n\treturn SCI_FAILURE_INVALID_STATE;\n}\n\nenum sci_status sci_request_complete(struct isci_request *ireq)\n{\n\tenum sci_base_request_states state;\n\tstruct isci_host *ihost = ireq->owning_controller;\n\n\tstate = ireq->sm.current_state_id;\n\tif (WARN_ONCE(state != SCI_REQ_COMPLETED,\n\t\t      \"isci: request completion from wrong state (%s)\\n\",\n\t\t      req_state_name(state)))\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\n\tif (ireq->saved_rx_frame_index != SCU_INVALID_FRAME_INDEX)\n\t\tsci_controller_release_frame(ihost,\n\t\t\t\t\t\t  ireq->saved_rx_frame_index);\n\n\t \n\tsci_change_state(&ireq->sm, SCI_REQ_FINAL);\n\treturn SCI_SUCCESS;\n}\n\nenum sci_status sci_io_request_event_handler(struct isci_request *ireq,\n\t\t\t\t\t\t  u32 event_code)\n{\n\tenum sci_base_request_states state;\n\tstruct isci_host *ihost = ireq->owning_controller;\n\n\tstate = ireq->sm.current_state_id;\n\n\tif (state != SCI_REQ_STP_PIO_DATA_IN) {\n\t\tdev_warn(&ihost->pdev->dev, \"%s: (%x) in wrong state %s\\n\",\n\t\t\t __func__, event_code, req_state_name(state));\n\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n\n\tswitch (scu_get_event_specifier(event_code)) {\n\tcase SCU_TASK_DONE_CRC_ERR << SCU_EVENT_SPECIFIC_CODE_SHIFT:\n\t\t \n\t\tsci_change_state(&ireq->sm, SCI_REQ_STP_PIO_WAIT_FRAME);\n\t\treturn SCI_SUCCESS;\n\tdefault:\n\t\tdev_err(&ihost->pdev->dev,\n\t\t\t\"%s: pio request unexpected event %#x\\n\",\n\t\t\t__func__, event_code);\n\n\t\t \n\t\treturn SCI_FAILURE;\n\t}\n}\n\n \nstatic void sci_io_request_copy_response(struct isci_request *ireq)\n{\n\tvoid *resp_buf;\n\tu32 len;\n\tstruct ssp_response_iu *ssp_response;\n\tstruct isci_tmf *isci_tmf = isci_request_access_tmf(ireq);\n\n\tssp_response = &ireq->ssp.rsp;\n\n\tresp_buf = &isci_tmf->resp.resp_iu;\n\n\tlen = min_t(u32,\n\t\t    SSP_RESP_IU_MAX_SIZE,\n\t\t    be32_to_cpu(ssp_response->response_data_len));\n\n\tmemcpy(resp_buf, ssp_response->resp_data, len);\n}\n\nstatic enum sci_status\nrequest_started_state_tc_event(struct isci_request *ireq,\n\t\t\t       u32 completion_code)\n{\n\tstruct ssp_response_iu *resp_iu;\n\tu8 datapres;\n\n\t \n\tswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\n\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\tireq->sci_status = SCI_SUCCESS;\n\t\tbreak;\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_EARLY_RESP): {\n\t\t \n\t\tstruct ssp_response_iu *resp = &ireq->ssp.rsp;\n\t\tssize_t word_cnt = SSP_RESP_IU_MAX_SIZE / sizeof(u32);\n\n\t\tsci_swab32_cpy(&ireq->ssp.rsp,\n\t\t\t       &ireq->ssp.rsp,\n\t\t\t       word_cnt);\n\n\t\tif (resp->status == 0) {\n\t\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\t\tireq->sci_status = SCI_SUCCESS_IO_DONE_EARLY;\n\t\t} else {\n\t\t\tireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\n\t\t\tireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\n\t\t}\n\t\tbreak;\n\t}\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_CHECK_RESPONSE): {\n\t\tssize_t word_cnt = SSP_RESP_IU_MAX_SIZE / sizeof(u32);\n\n\t\tsci_swab32_cpy(&ireq->ssp.rsp,\n\t\t\t       &ireq->ssp.rsp,\n\t\t\t       word_cnt);\n\n\t\tireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\n\t\tireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\n\t\tbreak;\n\t}\n\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_RESP_LEN_ERR):\n\t\t \n\t\tresp_iu = &ireq->ssp.rsp;\n\t\tdatapres = resp_iu->datapres;\n\n\t\tif (datapres == SAS_DATAPRES_RESPONSE_DATA ||\n\t\t    datapres == SAS_DATAPRES_SENSE_DATA) {\n\t\t\tireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\n\t\t\tireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\n\t\t} else {\n\t\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\t\tireq->sci_status = SCI_SUCCESS;\n\t\t}\n\t\tbreak;\n\t \n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_ACK_NAK_TO):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_LL_PERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_NAK_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_DATA_LEN_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_LL_ABORT_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_XR_WD_LEN):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_MAX_PLD_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_UNEXP_RESP):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_UNEXP_SDBFIS):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_REG_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SDB_ERR):\n\t\tif (ireq->protocol == SAS_PROTOCOL_STP) {\n\t\t\tireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>\n\t\t\t\t\t   SCU_COMPLETION_TL_STATUS_SHIFT;\n\t\t\tireq->sci_status = SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;\n\t\t} else {\n\t\t\tireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>\n\t\t\t\t\t   SCU_COMPLETION_TL_STATUS_SHIFT;\n\t\t\tireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\n\t\t}\n\t\tbreak;\n\n\t \n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_LF_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_WRONG_DESTINATION):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_1):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_2):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_3):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_BAD_DESTINATION):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_ZONE_VIOLATION):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_STP_RESOURCES_BUSY):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_CONNECTION_RATE_NOT_SUPPORTED):\n\t\tireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>\n\t\t\t\t   SCU_COMPLETION_TL_STATUS_SHIFT;\n\t\tireq->sci_status = SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;\n\t\tbreak;\n\n\t \n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_NAK_CMD_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_UNEXP_XR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_XR_IU_LEN_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SDMA_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_OFFSET_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_EXCESS_DATA):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_RESP_TO_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_UFI_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_FRM_TYPE_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_LL_RX_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_UNEXP_DATA):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_OPEN_FAIL):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_VIIT_ENTRY_NV):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_IIT_ENTRY_NV):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_RNCNV_OUTBOUND):\n\tdefault:\n\t\tireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>\n\t\t\t\t   SCU_COMPLETION_TL_STATUS_SHIFT;\n\t\tireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\n\t\tbreak;\n\t}\n\n\t \n\n\t \n\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\treturn SCI_SUCCESS;\n}\n\nstatic enum sci_status\nrequest_aborting_state_tc_event(struct isci_request *ireq,\n\t\t\t\tu32 completion_code)\n{\n\tswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\n\tcase (SCU_TASK_DONE_GOOD << SCU_COMPLETION_TL_STATUS_SHIFT):\n\tcase (SCU_TASK_DONE_TASK_ABORT << SCU_COMPLETION_TL_STATUS_SHIFT):\n\t\tireq->scu_status = SCU_TASK_DONE_TASK_ABORT;\n\t\tireq->sci_status = SCI_FAILURE_IO_TERMINATED;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn SCI_SUCCESS;\n}\n\nstatic enum sci_status ssp_task_request_await_tc_event(struct isci_request *ireq,\n\t\t\t\t\t\t       u32 completion_code)\n{\n\tswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\n\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\tireq->sci_status = SCI_SUCCESS;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_TASK_WAIT_TC_RESP);\n\t\tbreak;\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_ACK_NAK_TO):\n\t\t \n\t\tdev_warn(&ireq->owning_controller->pdev->dev,\n\t\t\t \"%s: TaskRequest:0x%p CompletionCode:%x - \"\n\t\t\t \"ACK/NAK timeout\\n\", __func__, ireq,\n\t\t\t completion_code);\n\n\t\tsci_change_state(&ireq->sm, SCI_REQ_TASK_WAIT_TC_RESP);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\n\t\tireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tbreak;\n\t}\n\n\treturn SCI_SUCCESS;\n}\n\nstatic enum sci_status\nsmp_request_await_response_tc_event(struct isci_request *ireq,\n\t\t\t\t    u32 completion_code)\n{\n\tswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\n\t\t \n\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\tireq->sci_status = SCI_SUCCESS;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tbreak;\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_RESP_TO_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_UFI_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_FRM_TYPE_ERR):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_LL_RX_ERR):\n\t\t \n\t\tireq->scu_status = SCU_TASK_DONE_SMP_RESP_TO_ERR;\n\t\tireq->sci_status = SCI_FAILURE_RETRY_REQUIRED;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\n\t\tireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tbreak;\n\t}\n\n\treturn SCI_SUCCESS;\n}\n\nstatic enum sci_status\nsmp_request_await_tc_event(struct isci_request *ireq,\n\t\t\t   u32 completion_code)\n{\n\tswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\n\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\tireq->sci_status = SCI_SUCCESS;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\n\t\tireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tbreak;\n\t}\n\n\treturn SCI_SUCCESS;\n}\n\nstatic struct scu_sgl_element *pio_sgl_next(struct isci_stp_request *stp_req)\n{\n\tstruct scu_sgl_element *sgl;\n\tstruct scu_sgl_element_pair *sgl_pair;\n\tstruct isci_request *ireq = to_ireq(stp_req);\n\tstruct isci_stp_pio_sgl *pio_sgl = &stp_req->sgl;\n\n\tsgl_pair = to_sgl_element_pair(ireq, pio_sgl->index);\n\tif (!sgl_pair)\n\t\tsgl = NULL;\n\telse if (pio_sgl->set == SCU_SGL_ELEMENT_PAIR_A) {\n\t\tif (sgl_pair->B.address_lower == 0 &&\n\t\t    sgl_pair->B.address_upper == 0) {\n\t\t\tsgl = NULL;\n\t\t} else {\n\t\t\tpio_sgl->set = SCU_SGL_ELEMENT_PAIR_B;\n\t\t\tsgl = &sgl_pair->B;\n\t\t}\n\t} else {\n\t\tif (sgl_pair->next_pair_lower == 0 &&\n\t\t    sgl_pair->next_pair_upper == 0) {\n\t\t\tsgl = NULL;\n\t\t} else {\n\t\t\tpio_sgl->index++;\n\t\t\tpio_sgl->set = SCU_SGL_ELEMENT_PAIR_A;\n\t\t\tsgl_pair = to_sgl_element_pair(ireq, pio_sgl->index);\n\t\t\tsgl = &sgl_pair->A;\n\t\t}\n\t}\n\n\treturn sgl;\n}\n\nstatic enum sci_status\nstp_request_non_data_await_h2d_tc_event(struct isci_request *ireq,\n\t\t\t\t\tu32 completion_code)\n{\n\tswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\n\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\tireq->sci_status = SCI_SUCCESS;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_STP_NON_DATA_WAIT_D2H);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\n\t\tireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tbreak;\n\t}\n\n\treturn SCI_SUCCESS;\n}\n\n#define SCU_MAX_FRAME_BUFFER_SIZE  0x400   \n\n \nstatic enum sci_status sci_stp_request_pio_data_out_trasmit_data_frame(\n\tstruct isci_request *ireq,\n\tu32 length)\n{\n\tstruct isci_stp_request *stp_req = &ireq->stp.req;\n\tstruct scu_task_context *task_context = ireq->tc;\n\tstruct scu_sgl_element_pair *sgl_pair;\n\tstruct scu_sgl_element *current_sgl;\n\n\t \n\tsgl_pair = to_sgl_element_pair(ireq, stp_req->sgl.index);\n\tif (stp_req->sgl.set == SCU_SGL_ELEMENT_PAIR_A)\n\t\tcurrent_sgl = &sgl_pair->A;\n\telse\n\t\tcurrent_sgl = &sgl_pair->B;\n\n\t \n\ttask_context->command_iu_upper = current_sgl->address_upper;\n\ttask_context->command_iu_lower = current_sgl->address_lower;\n\ttask_context->transfer_length_bytes = length;\n\ttask_context->type.stp.fis_type = FIS_DATA;\n\n\t \n\treturn sci_controller_continue_io(ireq);\n}\n\nstatic enum sci_status sci_stp_request_pio_data_out_transmit_data(struct isci_request *ireq)\n{\n\tstruct isci_stp_request *stp_req = &ireq->stp.req;\n\tstruct scu_sgl_element_pair *sgl_pair;\n\tenum sci_status status = SCI_SUCCESS;\n\tstruct scu_sgl_element *sgl;\n\tu32 offset;\n\tu32 len = 0;\n\n\toffset = stp_req->sgl.offset;\n\tsgl_pair = to_sgl_element_pair(ireq, stp_req->sgl.index);\n\tif (WARN_ONCE(!sgl_pair, \"%s: null sgl element\", __func__))\n\t\treturn SCI_FAILURE;\n\n\tif (stp_req->sgl.set == SCU_SGL_ELEMENT_PAIR_A) {\n\t\tsgl = &sgl_pair->A;\n\t\tlen = sgl_pair->A.length - offset;\n\t} else {\n\t\tsgl = &sgl_pair->B;\n\t\tlen = sgl_pair->B.length - offset;\n\t}\n\n\tif (stp_req->pio_len == 0)\n\t\treturn SCI_SUCCESS;\n\n\tif (stp_req->pio_len >= len) {\n\t\tstatus = sci_stp_request_pio_data_out_trasmit_data_frame(ireq, len);\n\t\tif (status != SCI_SUCCESS)\n\t\t\treturn status;\n\t\tstp_req->pio_len -= len;\n\n\t\t \n\t\tsgl = pio_sgl_next(stp_req);\n\t\toffset = 0;\n\t} else if (stp_req->pio_len < len) {\n\t\tsci_stp_request_pio_data_out_trasmit_data_frame(ireq, stp_req->pio_len);\n\n\t\t \n\t\toffset += stp_req->pio_len;\n\t\tsgl->address_lower += stp_req->pio_len;\n\t\tstp_req->pio_len = 0;\n\t}\n\n\tstp_req->sgl.offset = offset;\n\n\treturn status;\n}\n\n \nstatic enum sci_status\nsci_stp_request_pio_data_in_copy_data_buffer(struct isci_stp_request *stp_req,\n\t\t\t\t\t     u8 *data_buf, u32 len)\n{\n\tstruct isci_request *ireq;\n\tu8 *src_addr;\n\tint copy_len;\n\tstruct sas_task *task;\n\tstruct scatterlist *sg;\n\tvoid *kaddr;\n\tint total_len = len;\n\n\tireq = to_ireq(stp_req);\n\ttask = isci_request_access_task(ireq);\n\tsrc_addr = data_buf;\n\n\tif (task->num_scatter > 0) {\n\t\tsg = task->scatter;\n\n\t\twhile (total_len > 0) {\n\t\t\tstruct page *page = sg_page(sg);\n\n\t\t\tcopy_len = min_t(int, total_len, sg_dma_len(sg));\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tmemcpy(kaddr + sg->offset, src_addr, copy_len);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\ttotal_len -= copy_len;\n\t\t\tsrc_addr += copy_len;\n\t\t\tsg = sg_next(sg);\n\t\t}\n\t} else {\n\t\tBUG_ON(task->total_xfer_len < total_len);\n\t\tmemcpy(task->scatter, src_addr, total_len);\n\t}\n\n\treturn SCI_SUCCESS;\n}\n\n \nstatic enum sci_status sci_stp_request_pio_data_in_copy_data(\n\tstruct isci_stp_request *stp_req,\n\tu8 *data_buffer)\n{\n\tenum sci_status status;\n\n\t \n\tif (stp_req->pio_len < SCU_MAX_FRAME_BUFFER_SIZE) {\n\t\tstatus = sci_stp_request_pio_data_in_copy_data_buffer(\n\t\t\tstp_req, data_buffer, stp_req->pio_len);\n\n\t\tif (status == SCI_SUCCESS)\n\t\t\tstp_req->pio_len = 0;\n\t} else {\n\t\t \n\t\tstatus = sci_stp_request_pio_data_in_copy_data_buffer(\n\t\t\tstp_req, data_buffer, SCU_MAX_FRAME_BUFFER_SIZE);\n\n\t\tif (status == SCI_SUCCESS)\n\t\t\tstp_req->pio_len -= SCU_MAX_FRAME_BUFFER_SIZE;\n\t}\n\n\treturn status;\n}\n\nstatic enum sci_status\nstp_request_pio_await_h2d_completion_tc_event(struct isci_request *ireq,\n\t\t\t\t\t      u32 completion_code)\n{\n\tswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\n\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\tireq->sci_status = SCI_SUCCESS;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_STP_PIO_WAIT_FRAME);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\n\t\tireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tbreak;\n\t}\n\n\treturn SCI_SUCCESS;\n}\n\nstatic enum sci_status\npio_data_out_tx_done_tc_event(struct isci_request *ireq,\n\t\t\t      u32 completion_code)\n{\n\tenum sci_status status = SCI_SUCCESS;\n\tbool all_frames_transferred = false;\n\tstruct isci_stp_request *stp_req = &ireq->stp.req;\n\n\tswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\n\t\t \n\t\tif (stp_req->pio_len != 0) {\n\t\t\tstatus = sci_stp_request_pio_data_out_transmit_data(ireq);\n\t\t\tif (status == SCI_SUCCESS) {\n\t\t\t\tif (stp_req->pio_len == 0)\n\t\t\t\t\tall_frames_transferred = true;\n\t\t\t}\n\t\t} else if (stp_req->pio_len == 0) {\n\t\t\t \n\t\t\tall_frames_transferred  = true;\n\t\t}\n\n\t\t \n\t\tif (all_frames_transferred) {\n\t\t\t \n\t\t\tsci_change_state(&ireq->sm, SCI_REQ_STP_PIO_WAIT_FRAME);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\n\t\tireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nstatic enum sci_status sci_stp_request_udma_general_frame_handler(struct isci_request *ireq,\n\t\t\t\t\t\t\t\t       u32 frame_index)\n{\n\tstruct isci_host *ihost = ireq->owning_controller;\n\tstruct dev_to_host_fis *frame_header;\n\tenum sci_status status;\n\tu32 *frame_buffer;\n\n\tstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\n\t\t\t\t\t\t\t       frame_index,\n\t\t\t\t\t\t\t       (void **)&frame_header);\n\n\tif ((status == SCI_SUCCESS) &&\n\t    (frame_header->fis_type == FIS_REGD2H)) {\n\t\tsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\n\t\t\t\t\t\t\t      frame_index,\n\t\t\t\t\t\t\t      (void **)&frame_buffer);\n\n\t\tsci_controller_copy_sata_response(&ireq->stp.rsp,\n\t\t\t\t\t\t       frame_header,\n\t\t\t\t\t\t       frame_buffer);\n\t}\n\n\tsci_controller_release_frame(ihost, frame_index);\n\n\treturn status;\n}\n\nstatic enum sci_status process_unsolicited_fis(struct isci_request *ireq,\n\t\t\t\t\t       u32 frame_index)\n{\n\tstruct isci_host *ihost = ireq->owning_controller;\n\tenum sci_status status;\n\tstruct dev_to_host_fis *frame_header;\n\tu32 *frame_buffer;\n\n\tstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\n\t\t\t\t\t\t\t  frame_index,\n\t\t\t\t\t\t\t  (void **)&frame_header);\n\n\tif (status != SCI_SUCCESS)\n\t\treturn status;\n\n\tif (frame_header->fis_type != FIS_REGD2H) {\n\t\tdev_err(&ireq->isci_host->pdev->dev,\n\t\t\t\"%s ERROR: invalid fis type 0x%X\\n\",\n\t\t\t__func__, frame_header->fis_type);\n\t\treturn SCI_FAILURE;\n\t}\n\n\tsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\n\t\t\t\t\t\t frame_index,\n\t\t\t\t\t\t (void **)&frame_buffer);\n\n\tsci_controller_copy_sata_response(&ireq->stp.rsp,\n\t\t\t\t\t  (u32 *)frame_header,\n\t\t\t\t\t  frame_buffer);\n\n\t \n\tsci_controller_release_frame(ihost, frame_index);\n\n\treturn status;\n}\n\nstatic enum sci_status atapi_d2h_reg_frame_handler(struct isci_request *ireq,\n\t\t\t\t\t\t   u32 frame_index)\n{\n\tstruct sas_task *task = isci_request_access_task(ireq);\n\tenum sci_status status;\n\n\tstatus = process_unsolicited_fis(ireq, frame_index);\n\n\tif (status == SCI_SUCCESS) {\n\t\tif (ireq->stp.rsp.status & ATA_ERR)\n\t\t\tstatus = SCI_FAILURE_IO_RESPONSE_VALID;\n\t} else {\n\t\tstatus = SCI_FAILURE_IO_RESPONSE_VALID;\n\t}\n\n\tif (status != SCI_SUCCESS) {\n\t\tireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\n\t\tireq->sci_status = status;\n\t} else {\n\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\tireq->sci_status = SCI_SUCCESS;\n\t}\n\n\t \n\tif (task->data_dir == DMA_NONE)\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\n\treturn status;\n}\n\nstatic void scu_atapi_reconstruct_raw_frame_task_context(struct isci_request *ireq)\n{\n\tstruct ata_device *dev = sas_to_ata_dev(ireq->target_device->domain_dev);\n\tvoid *atapi_cdb = ireq->ttype_ptr.io_task_ptr->ata_task.atapi_packet;\n\tstruct scu_task_context *task_context = ireq->tc;\n\n\t \n\tmemset(&ireq->stp.cmd, 0, sizeof(struct host_to_dev_fis));\n\tmemcpy(((u8 *)&ireq->stp.cmd + sizeof(u32)), atapi_cdb, ATAPI_CDB_LEN);\n\tmemset(&(task_context->type.stp), 0, sizeof(struct stp_task_context));\n\ttask_context->type.stp.fis_type = FIS_DATA;\n\ttask_context->transfer_length_bytes = dev->cdb_len;\n}\n\nstatic void scu_atapi_construct_task_context(struct isci_request *ireq)\n{\n\tstruct ata_device *dev = sas_to_ata_dev(ireq->target_device->domain_dev);\n\tstruct sas_task *task = isci_request_access_task(ireq);\n\tstruct scu_task_context *task_context = ireq->tc;\n\tint cdb_len = dev->cdb_len;\n\n\t \n\tif (task->data_dir == DMA_TO_DEVICE) {\n\t\ttask_context->task_type = SCU_TASK_TYPE_PACKET_DMA_OUT;\n\t\ttask_context->sata_direction = 0;\n\t} else {\n\t\t \n\t\ttask_context->task_type = SCU_TASK_TYPE_PACKET_DMA_IN;\n\t\ttask_context->sata_direction = 1;\n\t}\n\n\tmemset(&task_context->type.stp, 0, sizeof(task_context->type.stp));\n\ttask_context->type.stp.fis_type = FIS_DATA;\n\n\tmemset(&ireq->stp.cmd, 0, sizeof(ireq->stp.cmd));\n\tmemcpy(&ireq->stp.cmd.lbal, task->ata_task.atapi_packet, cdb_len);\n\ttask_context->ssp_command_iu_length = cdb_len / sizeof(u32);\n\n\t \n\ttask_context->task_phase = 0x1;\n\n\t \n\ttask_context->stp_retry_count = 0;\n\n\t \n\ttask_context->transfer_length_bytes = task->total_xfer_len;\n\n\t \n\tsci_request_build_sgl(ireq);\n}\n\nenum sci_status\nsci_io_request_frame_handler(struct isci_request *ireq,\n\t\t\t\t  u32 frame_index)\n{\n\tstruct isci_host *ihost = ireq->owning_controller;\n\tstruct isci_stp_request *stp_req = &ireq->stp.req;\n\tenum sci_base_request_states state;\n\tenum sci_status status;\n\tssize_t word_cnt;\n\n\tstate = ireq->sm.current_state_id;\n\tswitch (state)  {\n\tcase SCI_REQ_STARTED: {\n\t\tstruct ssp_frame_hdr ssp_hdr;\n\t\tvoid *frame_header;\n\n\t\tsci_unsolicited_frame_control_get_header(&ihost->uf_control,\n\t\t\t\t\t\t\t      frame_index,\n\t\t\t\t\t\t\t      &frame_header);\n\n\t\tword_cnt = sizeof(struct ssp_frame_hdr) / sizeof(u32);\n\t\tsci_swab32_cpy(&ssp_hdr, frame_header, word_cnt);\n\n\t\tif (ssp_hdr.frame_type == SSP_RESPONSE) {\n\t\t\tstruct ssp_response_iu *resp_iu;\n\t\t\tssize_t word_cnt = SSP_RESP_IU_MAX_SIZE / sizeof(u32);\n\n\t\t\tsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\n\t\t\t\t\t\t\t\t      frame_index,\n\t\t\t\t\t\t\t\t      (void **)&resp_iu);\n\n\t\t\tsci_swab32_cpy(&ireq->ssp.rsp, resp_iu, word_cnt);\n\n\t\t\tresp_iu = &ireq->ssp.rsp;\n\n\t\t\tif (resp_iu->datapres == SAS_DATAPRES_RESPONSE_DATA ||\n\t\t\t    resp_iu->datapres == SAS_DATAPRES_SENSE_DATA) {\n\t\t\t\tireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\n\t\t\t\tireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\n\t\t\t} else {\n\t\t\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\t\t\tireq->sci_status = SCI_SUCCESS;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tdev_err(&ihost->pdev->dev,\n\t\t\t\t\"%s: SCIC IO Request 0x%p received unexpected \"\n\t\t\t\t\"frame %d type 0x%02x\\n\", __func__, ireq,\n\t\t\t\tframe_index, ssp_hdr.frame_type);\n\t\t}\n\n\t\t \n\t\tsci_controller_release_frame(ihost, frame_index);\n\n\t\treturn SCI_SUCCESS;\n\t}\n\n\tcase SCI_REQ_TASK_WAIT_TC_RESP:\n\t\tsci_io_request_copy_response(ireq);\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tsci_controller_release_frame(ihost, frame_index);\n\t\treturn SCI_SUCCESS;\n\n\tcase SCI_REQ_SMP_WAIT_RESP: {\n\t\tstruct sas_task *task = isci_request_access_task(ireq);\n\t\tstruct scatterlist *sg = &task->smp_task.smp_resp;\n\t\tvoid *frame_header, *kaddr;\n\t\tu8 *rsp;\n\n\t\tsci_unsolicited_frame_control_get_header(&ihost->uf_control,\n\t\t\t\t\t\t\t frame_index,\n\t\t\t\t\t\t\t &frame_header);\n\t\tkaddr = kmap_atomic(sg_page(sg));\n\t\trsp = kaddr + sg->offset;\n\t\tsci_swab32_cpy(rsp, frame_header, 1);\n\n\t\tif (rsp[0] == SMP_RESPONSE) {\n\t\t\tvoid *smp_resp;\n\n\t\t\tsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\n\t\t\t\t\t\t\t\t frame_index,\n\t\t\t\t\t\t\t\t &smp_resp);\n\n\t\t\tword_cnt = (sg->length/4)-1;\n\t\t\tif (word_cnt > 0)\n\t\t\t\tword_cnt = min_t(unsigned int, word_cnt,\n\t\t\t\t\t\t SCU_UNSOLICITED_FRAME_BUFFER_SIZE/4);\n\t\t\tsci_swab32_cpy(rsp + 4, smp_resp, word_cnt);\n\n\t\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\t\tireq->sci_status = SCI_SUCCESS;\n\t\t\tsci_change_state(&ireq->sm, SCI_REQ_SMP_WAIT_TC_COMP);\n\t\t} else {\n\t\t\t \n\t\t\tdev_err(&ihost->pdev->dev,\n\t\t\t\t\"%s: SCIC SMP Request 0x%p received unexpected \"\n\t\t\t\t\"frame %d type 0x%02x\\n\",\n\t\t\t\t__func__,\n\t\t\t\tireq,\n\t\t\t\tframe_index,\n\t\t\t\trsp[0]);\n\n\t\t\tireq->scu_status = SCU_TASK_DONE_SMP_FRM_TYPE_ERR;\n\t\t\tireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\n\t\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\t}\n\t\tkunmap_atomic(kaddr);\n\n\t\tsci_controller_release_frame(ihost, frame_index);\n\n\t\treturn SCI_SUCCESS;\n\t}\n\n\tcase SCI_REQ_STP_UDMA_WAIT_TC_COMP:\n\t\treturn sci_stp_request_udma_general_frame_handler(ireq,\n\t\t\t\t\t\t\t\t       frame_index);\n\n\tcase SCI_REQ_STP_UDMA_WAIT_D2H:\n\t\t \n\t\tstatus = sci_stp_request_udma_general_frame_handler(ireq, frame_index);\n\n\t\tif (status != SCI_SUCCESS)\n\t\t\treturn status;\n\n\t\tireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\n\t\tireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\treturn SCI_SUCCESS;\n\n\tcase SCI_REQ_STP_NON_DATA_WAIT_D2H: {\n\t\tstruct dev_to_host_fis *frame_header;\n\t\tu32 *frame_buffer;\n\n\t\tstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\n\t\t\t\t\t\t\t\t       frame_index,\n\t\t\t\t\t\t\t\t       (void **)&frame_header);\n\n\t\tif (status != SCI_SUCCESS) {\n\t\t\tdev_err(&ihost->pdev->dev,\n\t\t\t\t\"%s: SCIC IO Request 0x%p could not get frame \"\n\t\t\t\t\"header for frame index %d, status %x\\n\",\n\t\t\t\t__func__,\n\t\t\t\tstp_req,\n\t\t\t\tframe_index,\n\t\t\t\tstatus);\n\n\t\t\treturn status;\n\t\t}\n\n\t\tswitch (frame_header->fis_type) {\n\t\tcase FIS_REGD2H:\n\t\t\tsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\n\t\t\t\t\t\t\t\t      frame_index,\n\t\t\t\t\t\t\t\t      (void **)&frame_buffer);\n\n\t\t\tsci_controller_copy_sata_response(&ireq->stp.rsp,\n\t\t\t\t\t\t\t       frame_header,\n\t\t\t\t\t\t\t       frame_buffer);\n\n\t\t\t \n\t\t\tireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\n\t\t\tireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_warn(&ihost->pdev->dev,\n\t\t\t\t \"%s: IO Request:0x%p Frame Id:%d protocol \"\n\t\t\t\t  \"violation occurred\\n\", __func__, stp_req,\n\t\t\t\t  frame_index);\n\n\t\t\tireq->scu_status = SCU_TASK_DONE_UNEXP_FIS;\n\t\t\tireq->sci_status = SCI_FAILURE_PROTOCOL_VIOLATION;\n\t\t\tbreak;\n\t\t}\n\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\n\t\t \n\t\tsci_controller_release_frame(ihost, frame_index);\n\n\t\treturn status;\n\t}\n\n\tcase SCI_REQ_STP_PIO_WAIT_FRAME: {\n\t\tstruct sas_task *task = isci_request_access_task(ireq);\n\t\tstruct dev_to_host_fis *frame_header;\n\t\tu32 *frame_buffer;\n\n\t\tstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\n\t\t\t\t\t\t\t\t       frame_index,\n\t\t\t\t\t\t\t\t       (void **)&frame_header);\n\n\t\tif (status != SCI_SUCCESS) {\n\t\t\tdev_err(&ihost->pdev->dev,\n\t\t\t\t\"%s: SCIC IO Request 0x%p could not get frame \"\n\t\t\t\t\"header for frame index %d, status %x\\n\",\n\t\t\t\t__func__, stp_req, frame_index, status);\n\t\t\treturn status;\n\t\t}\n\n\t\tswitch (frame_header->fis_type) {\n\t\tcase FIS_PIO_SETUP:\n\t\t\t \n\t\t\tsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\n\t\t\t\t\t\t\t\t      frame_index,\n\t\t\t\t\t\t\t\t      (void **)&frame_buffer);\n\n\t\t\t \n\n\t\t\t \n\t\t\tstp_req->pio_len = frame_buffer[3] & 0xffff;\n\n\t\t\t \n\t\t\tstp_req->status = (frame_buffer[2] >> 24) & 0xff;\n\n\t\t\tsci_controller_copy_sata_response(&ireq->stp.rsp,\n\t\t\t\t\t\t\t       frame_header,\n\t\t\t\t\t\t\t       frame_buffer);\n\n\t\t\tireq->stp.rsp.status = stp_req->status;\n\n\t\t\t \n\t\t\tif (task->data_dir == DMA_FROM_DEVICE) {\n\t\t\t\tsci_change_state(&ireq->sm, SCI_REQ_STP_PIO_DATA_IN);\n\t\t\t} else if (task->data_dir == DMA_TO_DEVICE) {\n\t\t\t\t \n\t\t\t\tstatus = sci_stp_request_pio_data_out_transmit_data(ireq);\n\t\t\t\tif (status != SCI_SUCCESS)\n\t\t\t\t\tbreak;\n\t\t\t\tsci_change_state(&ireq->sm, SCI_REQ_STP_PIO_DATA_OUT);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase FIS_SETDEVBITS:\n\t\t\tsci_change_state(&ireq->sm, SCI_REQ_STP_PIO_WAIT_FRAME);\n\t\t\tbreak;\n\n\t\tcase FIS_REGD2H:\n\t\t\tif (frame_header->status & ATA_BUSY) {\n\t\t\t\t \n\t\t\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t\t\t\"%s: SCIC PIO Request 0x%p received \"\n\t\t\t\t\t\"D2H Register FIS with BSY status \"\n\t\t\t\t\t\"0x%x\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\tstp_req,\n\t\t\t\t\tframe_header->status);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\n\t\t\t\t\t\t\t\t      frame_index,\n\t\t\t\t\t\t\t\t      (void **)&frame_buffer);\n\n\t\t\tsci_controller_copy_sata_response(&ireq->stp.rsp,\n\t\t\t\t\t\t\t       frame_header,\n\t\t\t\t\t\t\t       frame_buffer);\n\n\t\t\tireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\n\t\t\tireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\n\t\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tsci_controller_release_frame(ihost, frame_index);\n\n\t\treturn status;\n\t}\n\n\tcase SCI_REQ_STP_PIO_DATA_IN: {\n\t\tstruct dev_to_host_fis *frame_header;\n\t\tstruct sata_fis_data *frame_buffer;\n\n\t\tstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\n\t\t\t\t\t\t\t\t       frame_index,\n\t\t\t\t\t\t\t\t       (void **)&frame_header);\n\n\t\tif (status != SCI_SUCCESS) {\n\t\t\tdev_err(&ihost->pdev->dev,\n\t\t\t\t\"%s: SCIC IO Request 0x%p could not get frame \"\n\t\t\t\t\"header for frame index %d, status %x\\n\",\n\t\t\t\t__func__,\n\t\t\t\tstp_req,\n\t\t\t\tframe_index,\n\t\t\t\tstatus);\n\t\t\treturn status;\n\t\t}\n\n\t\tif (frame_header->fis_type != FIS_DATA) {\n\t\t\tdev_err(&ihost->pdev->dev,\n\t\t\t\t\"%s: SCIC PIO Request 0x%p received frame %d \"\n\t\t\t\t\"with fis type 0x%02x when expecting a data \"\n\t\t\t\t\"fis.\\n\",\n\t\t\t\t__func__,\n\t\t\t\tstp_req,\n\t\t\t\tframe_index,\n\t\t\t\tframe_header->fis_type);\n\n\t\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\t\tireq->sci_status = SCI_FAILURE_IO_REQUIRES_SCSI_ABORT;\n\t\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\n\t\t\t \n\t\t\tsci_controller_release_frame(ihost, frame_index);\n\t\t\treturn status;\n\t\t}\n\n\t\tif (stp_req->sgl.index < 0) {\n\t\t\tireq->saved_rx_frame_index = frame_index;\n\t\t\tstp_req->pio_len = 0;\n\t\t} else {\n\t\t\tsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\n\t\t\t\t\t\t\t\t      frame_index,\n\t\t\t\t\t\t\t\t      (void **)&frame_buffer);\n\n\t\t\tstatus = sci_stp_request_pio_data_in_copy_data(stp_req,\n\t\t\t\t\t\t\t\t\t    (u8 *)frame_buffer);\n\n\t\t\t \n\t\t\tsci_controller_release_frame(ihost, frame_index);\n\t\t}\n\n\t\t \n\t\tif (status != SCI_SUCCESS || stp_req->pio_len != 0)\n\t\t\treturn status;\n\n\t\tif ((stp_req->status & ATA_BUSY) == 0) {\n\t\t\tireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\n\t\t\tireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\n\t\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\t} else {\n\t\t\tsci_change_state(&ireq->sm, SCI_REQ_STP_PIO_WAIT_FRAME);\n\t\t}\n\t\treturn status;\n\t}\n\n\tcase SCI_REQ_ATAPI_WAIT_PIO_SETUP: {\n\t\tstruct sas_task *task = isci_request_access_task(ireq);\n\n\t\tsci_controller_release_frame(ihost, frame_index);\n\t\tireq->target_device->working_request = ireq;\n\t\tif (task->data_dir == DMA_NONE) {\n\t\t\tsci_change_state(&ireq->sm, SCI_REQ_ATAPI_WAIT_TC_COMP);\n\t\t\tscu_atapi_reconstruct_raw_frame_task_context(ireq);\n\t\t} else {\n\t\t\tsci_change_state(&ireq->sm, SCI_REQ_ATAPI_WAIT_D2H);\n\t\t\tscu_atapi_construct_task_context(ireq);\n\t\t}\n\n\t\tsci_controller_continue_io(ireq);\n\t\treturn SCI_SUCCESS;\n\t}\n\tcase SCI_REQ_ATAPI_WAIT_D2H:\n\t\treturn atapi_d2h_reg_frame_handler(ireq, frame_index);\n\tcase SCI_REQ_ABORTING:\n\t\t \n\t\tsci_controller_release_frame(ihost, frame_index);\n\t\treturn SCI_SUCCESS;\n\n\tdefault:\n\t\tdev_warn(&ihost->pdev->dev,\n\t\t\t \"%s: SCIC IO Request given unexpected frame %x while \"\n\t\t\t \"in state %d\\n\",\n\t\t\t __func__,\n\t\t\t frame_index,\n\t\t\t state);\n\n\t\tsci_controller_release_frame(ihost, frame_index);\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n}\n\nstatic enum sci_status stp_request_udma_await_tc_event(struct isci_request *ireq,\n\t\t\t\t\t\t       u32 completion_code)\n{\n\tswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\n\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\tireq->sci_status = SCI_SUCCESS;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tbreak;\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_UNEXP_FIS):\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_REG_ERR):\n\t\t \n\t\tif (ireq->stp.rsp.fis_type == FIS_REGD2H) {\n\t\t\tsci_remote_device_suspend(ireq->target_device,\n\t\t\t\t\t\t  SCI_SW_SUSPEND_NORMAL);\n\n\t\t\tireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\n\t\t\tireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\n\t\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\t} else {\n\t\t\t \n\t\t\tsci_change_state(&ireq->sm, SCI_REQ_STP_UDMA_WAIT_D2H);\n\t\t}\n\t\tbreak;\n\n\t \n\t \n\tdefault:\n\t\t \n\t\tireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\n\t\tireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tbreak;\n\t}\n\n\treturn SCI_SUCCESS;\n}\n\nstatic enum sci_status atapi_raw_completion(struct isci_request *ireq, u32 completion_code,\n\t\t\t\t\t\t  enum sci_base_request_states next)\n{\n\tswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\n\tcase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\n\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\tireq->sci_status = SCI_SUCCESS;\n\t\tsci_change_state(&ireq->sm, next);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\n\t\tireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\n\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tbreak;\n\t}\n\n\treturn SCI_SUCCESS;\n}\n\nstatic enum sci_status atapi_data_tc_completion_handler(struct isci_request *ireq,\n\t\t\t\t\t\t\tu32 completion_code)\n{\n\tstruct isci_remote_device *idev = ireq->target_device;\n\tstruct dev_to_host_fis *d2h = &ireq->stp.rsp;\n\tenum sci_status status = SCI_SUCCESS;\n\n\tswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\n\tcase (SCU_TASK_DONE_GOOD << SCU_COMPLETION_TL_STATUS_SHIFT):\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tbreak;\n\n\tcase (SCU_TASK_DONE_UNEXP_FIS << SCU_COMPLETION_TL_STATUS_SHIFT): {\n\t\tu16 len = sci_req_tx_bytes(ireq);\n\n\t\t \n\t\tif (d2h->fis_type != FIS_REGD2H) {\n\t\t\td2h->fis_type = FIS_REGD2H;\n\t\t\td2h->flags = (1 << 6);\n\t\t\td2h->status = 0x50;\n\t\t\td2h->error = 0;\n\t\t\td2h->lbal = 0;\n\t\t\td2h->byte_count_low = len & 0xff;\n\t\t\td2h->byte_count_high = len >> 8;\n\t\t\td2h->device = 0xa0;\n\t\t\td2h->lbal_exp = 0;\n\t\t\td2h->lbam_exp = 0;\n\t\t\td2h->lbah_exp = 0;\n\t\t\td2h->_r_a = 0;\n\t\t\td2h->sector_count = 0x3;\n\t\t\td2h->sector_count_exp = 0;\n\t\t\td2h->_r_b = 0;\n\t\t\td2h->_r_c = 0;\n\t\t\td2h->_r_d = 0;\n\t\t}\n\n\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\tireq->sci_status = SCI_SUCCESS_IO_DONE_EARLY;\n\t\tstatus = ireq->sci_status;\n\n\t\t \n\t\tsci_change_state(&idev->sm, SCI_STP_DEV_ATAPI_ERROR);\n\t\tbreak;\n\t}\n\tcase (SCU_TASK_DONE_EXCESS_DATA << SCU_COMPLETION_TL_STATUS_SHIFT):\n\t\t \n\t\tireq->scu_status = SCU_TASK_DONE_GOOD;\n\t\tireq->sci_status = SCI_SUCCESS;\n\t\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n\t\tbreak;\n\n\tdefault:\n\t\tif (d2h->fis_type == FIS_REGD2H) {\n\t\t\t \n\t\t\tstatus = ireq->sci_status;\n\t\t\tsci_change_state(&idev->sm, SCI_STP_DEV_ATAPI_ERROR);\n\t\t} else {\n\t\t\t \n\t\t\tireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\n\t\t\tireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\n\n\t\t\tsci_change_state(&ireq->sm, SCI_REQ_ATAPI_WAIT_D2H);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nstatic int sci_request_smp_completion_status_is_tx_suspend(\n\tunsigned int completion_status)\n{\n\tswitch (completion_status) {\n\tcase SCU_TASK_OPEN_REJECT_WRONG_DESTINATION:\n\tcase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_1:\n\tcase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_2:\n\tcase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_3:\n\tcase SCU_TASK_OPEN_REJECT_BAD_DESTINATION:\n\tcase SCU_TASK_OPEN_REJECT_ZONE_VIOLATION:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int sci_request_smp_completion_status_is_tx_rx_suspend(\n\tunsigned int completion_status)\n{\n\treturn 0;  \n}\n\nstatic int sci_request_ssp_completion_status_is_tx_suspend(\n\tunsigned int completion_status)\n{\n\tswitch (completion_status) {\n\tcase SCU_TASK_DONE_TX_RAW_CMD_ERR:\n\tcase SCU_TASK_DONE_LF_ERR:\n\tcase SCU_TASK_OPEN_REJECT_WRONG_DESTINATION:\n\tcase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_1:\n\tcase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_2:\n\tcase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_3:\n\tcase SCU_TASK_OPEN_REJECT_BAD_DESTINATION:\n\tcase SCU_TASK_OPEN_REJECT_ZONE_VIOLATION:\n\tcase SCU_TASK_OPEN_REJECT_STP_RESOURCES_BUSY:\n\tcase SCU_TASK_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED:\n\tcase SCU_TASK_OPEN_REJECT_CONNECTION_RATE_NOT_SUPPORTED:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int sci_request_ssp_completion_status_is_tx_rx_suspend(\n\tunsigned int completion_status)\n{\n\treturn 0;  \n}\n\nstatic int sci_request_stpsata_completion_status_is_tx_suspend(\n\tunsigned int completion_status)\n{\n\tswitch (completion_status) {\n\tcase SCU_TASK_DONE_TX_RAW_CMD_ERR:\n\tcase SCU_TASK_DONE_LL_R_ERR:\n\tcase SCU_TASK_DONE_LL_PERR:\n\tcase SCU_TASK_DONE_REG_ERR:\n\tcase SCU_TASK_DONE_SDB_ERR:\n\tcase SCU_TASK_OPEN_REJECT_WRONG_DESTINATION:\n\tcase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_1:\n\tcase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_2:\n\tcase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_3:\n\tcase SCU_TASK_OPEN_REJECT_BAD_DESTINATION:\n\tcase SCU_TASK_OPEN_REJECT_ZONE_VIOLATION:\n\tcase SCU_TASK_OPEN_REJECT_STP_RESOURCES_BUSY:\n\tcase SCU_TASK_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED:\n\tcase SCU_TASK_OPEN_REJECT_CONNECTION_RATE_NOT_SUPPORTED:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nstatic int sci_request_stpsata_completion_status_is_tx_rx_suspend(\n\tunsigned int completion_status)\n{\n\tswitch (completion_status) {\n\tcase SCU_TASK_DONE_LF_ERR:\n\tcase SCU_TASK_DONE_LL_SY_TERM:\n\tcase SCU_TASK_DONE_LL_LF_TERM:\n\tcase SCU_TASK_DONE_BREAK_RCVD:\n\tcase SCU_TASK_DONE_INV_FIS_LEN:\n\tcase SCU_TASK_DONE_UNEXP_FIS:\n\tcase SCU_TASK_DONE_UNEXP_SDBFIS:\n\tcase SCU_TASK_DONE_MAX_PLD_ERR:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void sci_request_handle_suspending_completions(\n\tstruct isci_request *ireq,\n\tu32 completion_code)\n{\n\tint is_tx = 0;\n\tint is_tx_rx = 0;\n\n\tswitch (ireq->protocol) {\n\tcase SAS_PROTOCOL_SMP:\n\t\tis_tx = sci_request_smp_completion_status_is_tx_suspend(\n\t\t\tcompletion_code);\n\t\tis_tx_rx = sci_request_smp_completion_status_is_tx_rx_suspend(\n\t\t\tcompletion_code);\n\t\tbreak;\n\tcase SAS_PROTOCOL_SSP:\n\t\tis_tx = sci_request_ssp_completion_status_is_tx_suspend(\n\t\t\tcompletion_code);\n\t\tis_tx_rx = sci_request_ssp_completion_status_is_tx_rx_suspend(\n\t\t\tcompletion_code);\n\t\tbreak;\n\tcase SAS_PROTOCOL_STP:\n\t\tis_tx = sci_request_stpsata_completion_status_is_tx_suspend(\n\t\t\tcompletion_code);\n\t\tis_tx_rx =\n\t\t\tsci_request_stpsata_completion_status_is_tx_rx_suspend(\n\t\t\t\tcompletion_code);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&ireq->isci_host->pdev->dev,\n\t\t\t \"%s: request %p has no valid protocol\\n\",\n\t\t\t __func__, ireq);\n\t\tbreak;\n\t}\n\tif (is_tx || is_tx_rx) {\n\t\tBUG_ON(is_tx && is_tx_rx);\n\n\t\tsci_remote_node_context_suspend(\n\t\t\t&ireq->target_device->rnc,\n\t\t\tSCI_HW_SUSPEND,\n\t\t\t(is_tx_rx) ? SCU_EVENT_TL_RNC_SUSPEND_TX_RX\n\t\t\t\t   : SCU_EVENT_TL_RNC_SUSPEND_TX);\n\t}\n}\n\nenum sci_status\nsci_io_request_tc_completion(struct isci_request *ireq,\n\t\t\t     u32 completion_code)\n{\n\tenum sci_base_request_states state;\n\tstruct isci_host *ihost = ireq->owning_controller;\n\n\tstate = ireq->sm.current_state_id;\n\n\t \n\tsci_request_handle_suspending_completions(\n\t\tireq, SCU_GET_COMPLETION_TL_STATUS(completion_code));\n\n\tswitch (state) {\n\tcase SCI_REQ_STARTED:\n\t\treturn request_started_state_tc_event(ireq, completion_code);\n\n\tcase SCI_REQ_TASK_WAIT_TC_COMP:\n\t\treturn ssp_task_request_await_tc_event(ireq,\n\t\t\t\t\t\t       completion_code);\n\n\tcase SCI_REQ_SMP_WAIT_RESP:\n\t\treturn smp_request_await_response_tc_event(ireq,\n\t\t\t\t\t\t\t   completion_code);\n\n\tcase SCI_REQ_SMP_WAIT_TC_COMP:\n\t\treturn smp_request_await_tc_event(ireq, completion_code);\n\n\tcase SCI_REQ_STP_UDMA_WAIT_TC_COMP:\n\t\treturn stp_request_udma_await_tc_event(ireq,\n\t\t\t\t\t\t       completion_code);\n\n\tcase SCI_REQ_STP_NON_DATA_WAIT_H2D:\n\t\treturn stp_request_non_data_await_h2d_tc_event(ireq,\n\t\t\t\t\t\t\t       completion_code);\n\n\tcase SCI_REQ_STP_PIO_WAIT_H2D:\n\t\treturn stp_request_pio_await_h2d_completion_tc_event(ireq,\n\t\t\t\t\t\t\t\t     completion_code);\n\n\tcase SCI_REQ_STP_PIO_DATA_OUT:\n\t\treturn pio_data_out_tx_done_tc_event(ireq, completion_code);\n\n\tcase SCI_REQ_ABORTING:\n\t\treturn request_aborting_state_tc_event(ireq,\n\t\t\t\t\t\t       completion_code);\n\n\tcase SCI_REQ_ATAPI_WAIT_H2D:\n\t\treturn atapi_raw_completion(ireq, completion_code,\n\t\t\t\t\t    SCI_REQ_ATAPI_WAIT_PIO_SETUP);\n\n\tcase SCI_REQ_ATAPI_WAIT_TC_COMP:\n\t\treturn atapi_raw_completion(ireq, completion_code,\n\t\t\t\t\t    SCI_REQ_ATAPI_WAIT_D2H);\n\n\tcase SCI_REQ_ATAPI_WAIT_D2H:\n\t\treturn atapi_data_tc_completion_handler(ireq, completion_code);\n\n\tdefault:\n\t\tdev_warn(&ihost->pdev->dev, \"%s: %x in wrong state %s\\n\",\n\t\t\t __func__, completion_code, req_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n}\n\n \nstatic void isci_request_process_response_iu(\n\tstruct sas_task *task,\n\tstruct ssp_response_iu *resp_iu,\n\tstruct device *dev)\n{\n\tdev_dbg(dev,\n\t\t\"%s: resp_iu = %p \"\n\t\t\"resp_iu->status = 0x%x,\\nresp_iu->datapres = %d \"\n\t\t\"resp_iu->response_data_len = %x, \"\n\t\t\"resp_iu->sense_data_len = %x\\nresponse data: \",\n\t\t__func__,\n\t\tresp_iu,\n\t\tresp_iu->status,\n\t\tresp_iu->datapres,\n\t\tresp_iu->response_data_len,\n\t\tresp_iu->sense_data_len);\n\n\ttask->task_status.stat = resp_iu->status;\n\n\t \n\tsas_ssp_task_response(dev, task, resp_iu);\n}\n\n \nstatic void isci_request_set_open_reject_status(\n\tstruct isci_request *request,\n\tstruct sas_task *task,\n\tenum service_response *response_ptr,\n\tenum exec_status *status_ptr,\n\tenum sas_open_rej_reason open_rej_reason)\n{\n\t \n\tset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\n\t*response_ptr                     = SAS_TASK_UNDELIVERED;\n\t*status_ptr                       = SAS_OPEN_REJECT;\n\ttask->task_status.open_rej_reason = open_rej_reason;\n}\n\n \nstatic void isci_request_handle_controller_specific_errors(\n\tstruct isci_remote_device *idev,\n\tstruct isci_request *request,\n\tstruct sas_task *task,\n\tenum service_response *response_ptr,\n\tenum exec_status *status_ptr)\n{\n\tunsigned int cstatus;\n\n\tcstatus = request->scu_status;\n\n\tdev_dbg(&request->isci_host->pdev->dev,\n\t\t\"%s: %p SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR \"\n\t\t\"- controller status = 0x%x\\n\",\n\t\t__func__, request, cstatus);\n\n\t \n\tswitch (cstatus) {\n\tcase SCU_TASK_DONE_DMASETUP_DIRERR:\n\t \n\tcase SCU_TASK_DONE_XFERCNT_ERR:\n\t\t \n\t\tif (task->task_proto == SAS_PROTOCOL_SMP) {\n\t\t\t \n\t\t\t*response_ptr = SAS_TASK_COMPLETE;\n\n\t\t\t \n\t\t\tif (!idev)\n\t\t\t\t*status_ptr = SAS_DEVICE_UNKNOWN;\n\t\t\telse\n\t\t\t\t*status_ptr = SAS_ABORTED_TASK;\n\n\t\t\tset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\n\t\t} else {\n\t\t\t \n\t\t\t*response_ptr = SAS_TASK_UNDELIVERED;\n\n\t\t\tif (!idev)\n\t\t\t\t*status_ptr = SAS_DEVICE_UNKNOWN;\n\t\t\telse\n\t\t\t\t*status_ptr = SAS_SAM_STAT_TASK_ABORTED;\n\n\t\t\tclear_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\n\t\t}\n\n\t\tbreak;\n\n\tcase SCU_TASK_DONE_CRC_ERR:\n\tcase SCU_TASK_DONE_NAK_CMD_ERR:\n\tcase SCU_TASK_DONE_EXCESS_DATA:\n\tcase SCU_TASK_DONE_UNEXP_FIS:\n\t \n\tcase SCU_TASK_DONE_VIIT_ENTRY_NV:        \n\tcase SCU_TASK_DONE_IIT_ENTRY_NV:         \n\tcase SCU_TASK_DONE_RNCNV_OUTBOUND:       \n\t\t \n\t\t*response_ptr = SAS_TASK_COMPLETE;\n\n\t\t \n\t\tif (!idev)\n\t\t\t*status_ptr = SAS_DEVICE_UNKNOWN;\n\t\telse\n\t\t\t*status_ptr = SAS_ABORTED_TASK;\n\n\t\tset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\n\t\tbreak;\n\n\n\t \n\tcase SCU_TASK_OPEN_REJECT_WRONG_DESTINATION:\n\n\t\tisci_request_set_open_reject_status(\n\t\t\trequest, task, response_ptr, status_ptr,\n\t\t\tSAS_OREJ_WRONG_DEST);\n\t\tbreak;\n\n\tcase SCU_TASK_OPEN_REJECT_ZONE_VIOLATION:\n\n\t\t \n\t\tisci_request_set_open_reject_status(\n\t\t\trequest, task, response_ptr, status_ptr,\n\t\t\tSAS_OREJ_RESV_AB0);\n\t\tbreak;\n\n\tcase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_1:\n\n\t\tisci_request_set_open_reject_status(\n\t\t\trequest, task, response_ptr, status_ptr,\n\t\t\tSAS_OREJ_RESV_AB1);\n\t\tbreak;\n\n\tcase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_2:\n\n\t\tisci_request_set_open_reject_status(\n\t\t\trequest, task, response_ptr, status_ptr,\n\t\t\tSAS_OREJ_RESV_AB2);\n\t\tbreak;\n\n\tcase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_3:\n\n\t\tisci_request_set_open_reject_status(\n\t\t\trequest, task, response_ptr, status_ptr,\n\t\t\tSAS_OREJ_RESV_AB3);\n\t\tbreak;\n\n\tcase SCU_TASK_OPEN_REJECT_BAD_DESTINATION:\n\n\t\tisci_request_set_open_reject_status(\n\t\t\trequest, task, response_ptr, status_ptr,\n\t\t\tSAS_OREJ_BAD_DEST);\n\t\tbreak;\n\n\tcase SCU_TASK_OPEN_REJECT_STP_RESOURCES_BUSY:\n\n\t\tisci_request_set_open_reject_status(\n\t\t\trequest, task, response_ptr, status_ptr,\n\t\t\tSAS_OREJ_STP_NORES);\n\t\tbreak;\n\n\tcase SCU_TASK_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED:\n\n\t\tisci_request_set_open_reject_status(\n\t\t\trequest, task, response_ptr, status_ptr,\n\t\t\tSAS_OREJ_EPROTO);\n\t\tbreak;\n\n\tcase SCU_TASK_OPEN_REJECT_CONNECTION_RATE_NOT_SUPPORTED:\n\n\t\tisci_request_set_open_reject_status(\n\t\t\trequest, task, response_ptr, status_ptr,\n\t\t\tSAS_OREJ_CONN_RATE);\n\t\tbreak;\n\n\tcase SCU_TASK_DONE_LL_R_ERR:\n\t \n\tcase SCU_TASK_DONE_LL_PERR:\n\tcase SCU_TASK_DONE_LL_SY_TERM:\n\t \n\tcase SCU_TASK_DONE_LL_LF_TERM:\n\t \n\tcase SCU_TASK_DONE_LL_ABORT_ERR:\n\tcase SCU_TASK_DONE_SEQ_INV_TYPE:\n\t \n\tcase SCU_TASK_DONE_XR_IU_LEN_ERR:\n\tcase SCU_TASK_DONE_INV_FIS_LEN:\n\t \n\tcase SCU_TASK_DONE_SDMA_ERR:\n\tcase SCU_TASK_DONE_OFFSET_ERR:\n\tcase SCU_TASK_DONE_MAX_PLD_ERR:\n\tcase SCU_TASK_DONE_LF_ERR:\n\tcase SCU_TASK_DONE_SMP_RESP_TO_ERR:   \n\tcase SCU_TASK_DONE_SMP_LL_RX_ERR:\n\tcase SCU_TASK_DONE_UNEXP_DATA:\n\tcase SCU_TASK_DONE_UNEXP_SDBFIS:\n\tcase SCU_TASK_DONE_REG_ERR:\n\tcase SCU_TASK_DONE_SDB_ERR:\n\tcase SCU_TASK_DONE_TASK_ABORT:\n\tdefault:\n\t\t \n\t\t*response_ptr = SAS_TASK_UNDELIVERED;\n\t\t*status_ptr = SAS_SAM_STAT_TASK_ABORTED;\n\n\t\tif (task->task_proto == SAS_PROTOCOL_SMP)\n\t\t\tset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\n\t\telse\n\t\t\tclear_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\n\t\tbreak;\n\t}\n}\n\nstatic void isci_process_stp_response(struct sas_task *task, struct dev_to_host_fis *fis)\n{\n\tstruct task_status_struct *ts = &task->task_status;\n\tstruct ata_task_resp *resp = (void *)&ts->buf[0];\n\n\tresp->frame_len = sizeof(*fis);\n\tmemcpy(resp->ending_fis, fis, sizeof(*fis));\n\tts->buf_valid_size = sizeof(*resp);\n\n\t \n\tif (ac_err_mask(fis->status))\n\t\tts->stat = SAS_PROTO_RESPONSE;\n\telse\n\t\tts->stat = SAS_SAM_STAT_GOOD;\n\n\tts->resp = SAS_TASK_COMPLETE;\n}\n\nstatic void isci_request_io_request_complete(struct isci_host *ihost,\n\t\t\t\t\t     struct isci_request *request,\n\t\t\t\t\t     enum sci_io_status completion_status)\n{\n\tstruct sas_task *task = isci_request_access_task(request);\n\tstruct ssp_response_iu *resp_iu;\n\tunsigned long task_flags;\n\tstruct isci_remote_device *idev = request->target_device;\n\tenum service_response response = SAS_TASK_UNDELIVERED;\n\tenum exec_status status = SAS_ABORTED_TASK;\n\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: request = %p, task = %p, \"\n\t\t\"task->data_dir = %d completion_status = 0x%x\\n\",\n\t\t__func__, request, task, task->data_dir, completion_status);\n\n\t \n\n\t \n\tswitch (completion_status) {\n\n\tcase SCI_IO_FAILURE_RESPONSE_VALID:\n\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t\"%s: SCI_IO_FAILURE_RESPONSE_VALID (%p/%p)\\n\",\n\t\t\t__func__, request, task);\n\n\t\tif (sas_protocol_ata(task->task_proto)) {\n\t\t\tisci_process_stp_response(task, &request->stp.rsp);\n\t\t} else if (SAS_PROTOCOL_SSP == task->task_proto) {\n\n\t\t\t \n\t\t\tresp_iu = &request->ssp.rsp;\n\t\t\tisci_request_process_response_iu(task, resp_iu,\n\t\t\t\t\t\t\t &ihost->pdev->dev);\n\n\t\t} else if (SAS_PROTOCOL_SMP == task->task_proto) {\n\n\t\t\tdev_err(&ihost->pdev->dev,\n\t\t\t\t\"%s: SCI_IO_FAILURE_RESPONSE_VALID: \"\n\t\t\t\t\t\"SAS_PROTOCOL_SMP protocol\\n\",\n\t\t\t\t__func__);\n\n\t\t} else\n\t\t\tdev_err(&ihost->pdev->dev,\n\t\t\t\t\"%s: unknown protocol\\n\", __func__);\n\n\t\t \n\t\tset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\n\t\tresponse = task->task_status.resp;\n\t\tstatus = task->task_status.stat;\n\t\tbreak;\n\n\tcase SCI_IO_SUCCESS:\n\tcase SCI_IO_SUCCESS_IO_DONE_EARLY:\n\n\t\tresponse = SAS_TASK_COMPLETE;\n\t\tstatus   = SAS_SAM_STAT_GOOD;\n\t\tset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\n\n\t\tif (completion_status == SCI_IO_SUCCESS_IO_DONE_EARLY) {\n\n\t\t\t \n\t\t\tu32 transferred_length = sci_req_tx_bytes(request);\n\n\t\t\ttask->task_status.residual\n\t\t\t\t= task->total_xfer_len - transferred_length;\n\n\t\t\t \n\t\t\tif (task->task_status.residual != 0)\n\t\t\t\tstatus = SAS_DATA_UNDERRUN;\n\n\t\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t\t\"%s: SCI_IO_SUCCESS_IO_DONE_EARLY %d\\n\",\n\t\t\t\t__func__, status);\n\n\t\t} else\n\t\t\tdev_dbg(&ihost->pdev->dev, \"%s: SCI_IO_SUCCESS\\n\",\n\t\t\t\t__func__);\n\t\tbreak;\n\n\tcase SCI_IO_FAILURE_TERMINATED:\n\n\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t\"%s: SCI_IO_FAILURE_TERMINATED (%p/%p)\\n\",\n\t\t\t__func__, request, task);\n\n\t\t \n\t\tset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\n\t\tresponse = SAS_TASK_UNDELIVERED;\n\n\t\t \n\t\tif (!idev)\n\t\t\tstatus = SAS_DEVICE_UNKNOWN;\n\t\telse\n\t\t\tstatus = SAS_ABORTED_TASK;\n\t\tbreak;\n\n\tcase SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR:\n\n\t\tisci_request_handle_controller_specific_errors(idev, request,\n\t\t\t\t\t\t\t       task, &response,\n\t\t\t\t\t\t\t       &status);\n\t\tbreak;\n\n\tcase SCI_IO_FAILURE_REMOTE_DEVICE_RESET_REQUIRED:\n\t\t \n\t\tspin_lock_irqsave(&task->task_state_lock, task_flags);\n\t\ttask->task_state_flags |= SAS_TASK_NEED_DEV_RESET;\n\t\tspin_unlock_irqrestore(&task->task_state_lock, task_flags);\n\n\t\t \n\t\tresponse = SAS_TASK_UNDELIVERED;\n\t\tstatus = SAS_SAM_STAT_TASK_ABORTED;\n\n\t\tclear_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\n\t\tbreak;\n\n\tcase SCI_FAILURE_RETRY_REQUIRED:\n\n\t\t \n\t\tresponse = SAS_TASK_UNDELIVERED;\n\t\tif (!idev)\n\t\t\tstatus = SAS_DEVICE_UNKNOWN;\n\t\telse\n\t\t\tstatus = SAS_ABORTED_TASK;\n\n\t\tset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\n\t\tbreak;\n\n\n\tdefault:\n\t\t \n\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t\"%s: invalid completion code: 0x%x - \"\n\t\t\t\t\"isci_request = %p\\n\",\n\t\t\t__func__, completion_status, request);\n\n\t\tresponse = SAS_TASK_UNDELIVERED;\n\n\t\t \n\t\tif (!idev)\n\t\t\tstatus = SAS_DEVICE_UNKNOWN;\n\t\telse\n\t\t\tstatus = SAS_ABORTED_TASK;\n\n\t\tif (SAS_PROTOCOL_SMP == task->task_proto)\n\t\t\tset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\n\t\telse\n\t\t\tclear_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\n\t\tbreak;\n\t}\n\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SSP:\n\t\tif (task->data_dir == DMA_NONE)\n\t\t\tbreak;\n\t\tif (task->num_scatter == 0)\n\t\t\t \n\t\t\tdma_unmap_single(&ihost->pdev->dev,\n\t\t\t\t\t request->zero_scatter_daddr,\n\t\t\t\t\t task->total_xfer_len, task->data_dir);\n\t\telse   \n\t\t\tdma_unmap_sg(&ihost->pdev->dev, task->scatter,\n\t\t\t\t     request->num_sg_entries, task->data_dir);\n\t\tbreak;\n\tcase SAS_PROTOCOL_SMP: {\n\t\tstruct scatterlist *sg = &task->smp_task.smp_req;\n\t\tstruct smp_req *smp_req;\n\t\tvoid *kaddr;\n\n\t\tdma_unmap_sg(&ihost->pdev->dev, sg, 1, DMA_TO_DEVICE);\n\n\t\t \n\t\tkaddr = kmap_atomic(sg_page(sg));\n\t\tsmp_req = kaddr + sg->offset;\n\t\tsci_swab32_cpy(smp_req, smp_req, sg->length / sizeof(u32));\n\t\tkunmap_atomic(kaddr);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&task->task_state_lock, task_flags);\n\n\ttask->task_status.resp = response;\n\ttask->task_status.stat = status;\n\n\tif (test_bit(IREQ_COMPLETE_IN_TARGET, &request->flags)) {\n\t\t \n\t\ttask->task_state_flags |= SAS_TASK_STATE_DONE;\n\t\ttask->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\t}\n\tspin_unlock_irqrestore(&task->task_state_lock, task_flags);\n\n\t \n\tsci_controller_complete_io(ihost, request->target_device, request);\n\n\t \n\tset_bit(IREQ_TERMINATED, &request->flags);\n\n\tireq_done(ihost, request, task);\n}\n\nstatic void sci_request_started_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_request *ireq = container_of(sm, typeof(*ireq), sm);\n\tstruct domain_device *dev = ireq->target_device->domain_dev;\n\tenum sci_base_request_states state;\n\tstruct sas_task *task;\n\n\t \n\ttask = (test_bit(IREQ_TMF, &ireq->flags)) ? NULL : isci_request_access_task(ireq);\n\n\t \n\tif (!task && dev->dev_type == SAS_END_DEVICE) {\n\t\tstate = SCI_REQ_TASK_WAIT_TC_COMP;\n\t} else if (task && task->task_proto == SAS_PROTOCOL_SMP) {\n\t\tstate = SCI_REQ_SMP_WAIT_RESP;\n\t} else if (task && sas_protocol_ata(task->task_proto) &&\n\t\t   !task->ata_task.use_ncq) {\n\t\tif (dev->sata_dev.class == ATA_DEV_ATAPI &&\n\t\t\ttask->ata_task.fis.command == ATA_CMD_PACKET) {\n\t\t\tstate = SCI_REQ_ATAPI_WAIT_H2D;\n\t\t} else if (task->data_dir == DMA_NONE) {\n\t\t\tstate = SCI_REQ_STP_NON_DATA_WAIT_H2D;\n\t\t} else if (task->ata_task.dma_xfer) {\n\t\t\tstate = SCI_REQ_STP_UDMA_WAIT_TC_COMP;\n\t\t} else   {\n\t\t\tstate = SCI_REQ_STP_PIO_WAIT_H2D;\n\t\t}\n\t} else {\n\t\t \n\t\treturn;\n\t}\n\tsci_change_state(sm, state);\n}\n\nstatic void sci_request_completed_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_request *ireq = container_of(sm, typeof(*ireq), sm);\n\tstruct isci_host *ihost = ireq->owning_controller;\n\n\t \n\tif (!test_bit(IREQ_TMF, &ireq->flags))\n\t\tisci_request_io_request_complete(ihost, ireq,\n\t\t\t\t\t\t ireq->sci_status);\n\telse\n\t\tisci_task_request_complete(ihost, ireq, ireq->sci_status);\n}\n\nstatic void sci_request_aborting_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_request *ireq = container_of(sm, typeof(*ireq), sm);\n\n\t \n\tireq->tc->abort = 1;\n}\n\nstatic void sci_stp_request_started_non_data_await_h2d_completion_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_request *ireq = container_of(sm, typeof(*ireq), sm);\n\n\tireq->target_device->working_request = ireq;\n}\n\nstatic void sci_stp_request_started_pio_await_h2d_completion_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_request *ireq = container_of(sm, typeof(*ireq), sm);\n\n\tireq->target_device->working_request = ireq;\n}\n\nstatic const struct sci_base_state sci_request_state_table[] = {\n\t[SCI_REQ_INIT] = { },\n\t[SCI_REQ_CONSTRUCTED] = { },\n\t[SCI_REQ_STARTED] = {\n\t\t.enter_state = sci_request_started_state_enter,\n\t},\n\t[SCI_REQ_STP_NON_DATA_WAIT_H2D] = {\n\t\t.enter_state = sci_stp_request_started_non_data_await_h2d_completion_enter,\n\t},\n\t[SCI_REQ_STP_NON_DATA_WAIT_D2H] = { },\n\t[SCI_REQ_STP_PIO_WAIT_H2D] = {\n\t\t.enter_state = sci_stp_request_started_pio_await_h2d_completion_enter,\n\t},\n\t[SCI_REQ_STP_PIO_WAIT_FRAME] = { },\n\t[SCI_REQ_STP_PIO_DATA_IN] = { },\n\t[SCI_REQ_STP_PIO_DATA_OUT] = { },\n\t[SCI_REQ_STP_UDMA_WAIT_TC_COMP] = { },\n\t[SCI_REQ_STP_UDMA_WAIT_D2H] = { },\n\t[SCI_REQ_TASK_WAIT_TC_COMP] = { },\n\t[SCI_REQ_TASK_WAIT_TC_RESP] = { },\n\t[SCI_REQ_SMP_WAIT_RESP] = { },\n\t[SCI_REQ_SMP_WAIT_TC_COMP] = { },\n\t[SCI_REQ_ATAPI_WAIT_H2D] = { },\n\t[SCI_REQ_ATAPI_WAIT_PIO_SETUP] = { },\n\t[SCI_REQ_ATAPI_WAIT_D2H] = { },\n\t[SCI_REQ_ATAPI_WAIT_TC_COMP] = { },\n\t[SCI_REQ_COMPLETED] = {\n\t\t.enter_state = sci_request_completed_state_enter,\n\t},\n\t[SCI_REQ_ABORTING] = {\n\t\t.enter_state = sci_request_aborting_state_enter,\n\t},\n\t[SCI_REQ_FINAL] = { },\n};\n\nstatic void\nsci_general_request_construct(struct isci_host *ihost,\n\t\t\t\t   struct isci_remote_device *idev,\n\t\t\t\t   struct isci_request *ireq)\n{\n\tsci_init_sm(&ireq->sm, sci_request_state_table, SCI_REQ_INIT);\n\n\tireq->target_device = idev;\n\tireq->protocol = SAS_PROTOCOL_NONE;\n\tireq->saved_rx_frame_index = SCU_INVALID_FRAME_INDEX;\n\n\tireq->sci_status   = SCI_SUCCESS;\n\tireq->scu_status   = 0;\n\tireq->post_context = 0xFFFFFFFF;\n}\n\nstatic enum sci_status\nsci_io_request_construct(struct isci_host *ihost,\n\t\t\t  struct isci_remote_device *idev,\n\t\t\t  struct isci_request *ireq)\n{\n\tstruct domain_device *dev = idev->domain_dev;\n\tenum sci_status status = SCI_SUCCESS;\n\n\t \n\tsci_general_request_construct(ihost, idev, ireq);\n\n\tif (idev->rnc.remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX)\n\t\treturn SCI_FAILURE_INVALID_REMOTE_DEVICE;\n\n\tif (dev->dev_type == SAS_END_DEVICE)\n\t\t ;\n\telse if (dev_is_sata(dev))\n\t\tmemset(&ireq->stp.cmd, 0, sizeof(ireq->stp.cmd));\n\telse if (dev_is_expander(dev->dev_type))\n\t\t ;\n\telse\n\t\treturn SCI_FAILURE_UNSUPPORTED_PROTOCOL;\n\n\tmemset(ireq->tc, 0, offsetof(struct scu_task_context, sgl_pair_ab));\n\n\treturn status;\n}\n\nenum sci_status sci_task_request_construct(struct isci_host *ihost,\n\t\t\t\t\t    struct isci_remote_device *idev,\n\t\t\t\t\t    u16 io_tag, struct isci_request *ireq)\n{\n\tstruct domain_device *dev = idev->domain_dev;\n\tenum sci_status status = SCI_SUCCESS;\n\n\t \n\tsci_general_request_construct(ihost, idev, ireq);\n\n\tif (dev->dev_type == SAS_END_DEVICE || dev_is_sata(dev)) {\n\t\tset_bit(IREQ_TMF, &ireq->flags);\n\t\tmemset(ireq->tc, 0, sizeof(struct scu_task_context));\n\n\t\t \n\t\tif (dev_is_sata(dev))\n\t\t\tireq->protocol = SAS_PROTOCOL_STP;\n\t\telse\n\t\t\tireq->protocol = SAS_PROTOCOL_SSP;\n\t} else\n\t\tstatus = SCI_FAILURE_UNSUPPORTED_PROTOCOL;\n\n\treturn status;\n}\n\nstatic enum sci_status isci_request_ssp_request_construct(\n\tstruct isci_request *request)\n{\n\tenum sci_status status;\n\n\tdev_dbg(&request->isci_host->pdev->dev,\n\t\t\"%s: request = %p\\n\",\n\t\t__func__,\n\t\trequest);\n\tstatus = sci_io_request_construct_basic_ssp(request);\n\treturn status;\n}\n\nstatic enum sci_status isci_request_stp_request_construct(struct isci_request *ireq)\n{\n\tstruct sas_task *task = isci_request_access_task(ireq);\n\tstruct host_to_dev_fis *fis = &ireq->stp.cmd;\n\tstruct ata_queued_cmd *qc = task->uldd_task;\n\tenum sci_status status;\n\n\tdev_dbg(&ireq->isci_host->pdev->dev,\n\t\t\"%s: ireq = %p\\n\",\n\t\t__func__,\n\t\tireq);\n\n\tmemcpy(fis, &task->ata_task.fis, sizeof(struct host_to_dev_fis));\n\tif (!task->ata_task.device_control_reg_update)\n\t\tfis->flags |= 0x80;\n\tfis->flags &= 0xF0;\n\n\tstatus = sci_io_request_construct_basic_sata(ireq);\n\n\tif (qc && (qc->tf.command == ATA_CMD_FPDMA_WRITE ||\n\t\t   qc->tf.command == ATA_CMD_FPDMA_READ ||\n\t\t   qc->tf.command == ATA_CMD_FPDMA_RECV ||\n\t\t   qc->tf.command == ATA_CMD_FPDMA_SEND ||\n\t\t   qc->tf.command == ATA_CMD_NCQ_NON_DATA)) {\n\t\tfis->sector_count = qc->tag << 3;\n\t\tireq->tc->type.stp.ncq_tag = qc->tag;\n\t}\n\n\treturn status;\n}\n\nstatic enum sci_status\nsci_io_request_construct_smp(struct device *dev,\n\t\t\t      struct isci_request *ireq,\n\t\t\t      struct sas_task *task)\n{\n\tstruct scatterlist *sg = &task->smp_task.smp_req;\n\tstruct isci_remote_device *idev;\n\tstruct scu_task_context *task_context;\n\tstruct isci_port *iport;\n\tstruct smp_req *smp_req;\n\tvoid *kaddr;\n\tu8 req_len;\n\tu32 cmd;\n\n\tkaddr = kmap_atomic(sg_page(sg));\n\tsmp_req = kaddr + sg->offset;\n\t \n\tif (smp_req->req_len == 0) {\n\t\tswitch (smp_req->func) {\n\t\tcase SMP_DISCOVER:\n\t\tcase SMP_REPORT_PHY_ERR_LOG:\n\t\tcase SMP_REPORT_PHY_SATA:\n\t\tcase SMP_REPORT_ROUTE_INFO:\n\t\t\tsmp_req->req_len = 2;\n\t\t\tbreak;\n\t\tcase SMP_CONF_ROUTE_INFO:\n\t\tcase SMP_PHY_CONTROL:\n\t\tcase SMP_PHY_TEST_FUNCTION:\n\t\t\tsmp_req->req_len = 9;\n\t\t\tbreak;\n\t\t\t \n\t\t}\n\t}\n\treq_len = smp_req->req_len;\n\tsci_swab32_cpy(smp_req, smp_req, sg->length / sizeof(u32));\n\tcmd = *(u32 *) smp_req;\n\tkunmap_atomic(kaddr);\n\n\tif (!dma_map_sg(dev, sg, 1, DMA_TO_DEVICE))\n\t\treturn SCI_FAILURE;\n\n\tireq->protocol = SAS_PROTOCOL_SMP;\n\n\t \n\n\ttask_context = ireq->tc;\n\n\tidev = ireq->target_device;\n\tiport = idev->owning_port;\n\n\t \n\ttask_context->priority = 0;\n\ttask_context->initiator_request = 1;\n\ttask_context->connection_rate = idev->connection_rate;\n\ttask_context->protocol_engine_index = ISCI_PEG;\n\ttask_context->logical_port_index = iport->physical_port_index;\n\ttask_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SMP;\n\ttask_context->abort = 0;\n\ttask_context->valid = SCU_TASK_CONTEXT_VALID;\n\ttask_context->context_type = SCU_TASK_CONTEXT_TYPE;\n\n\t \n\ttask_context->remote_node_index = idev->rnc.remote_node_index;\n\ttask_context->command_code = 0;\n\ttask_context->task_type = SCU_TASK_TYPE_SMP_REQUEST;\n\n\t \n\ttask_context->link_layer_control = 0;\n\ttask_context->do_not_dma_ssp_good_response = 1;\n\ttask_context->strict_ordering = 0;\n\ttask_context->control_frame = 1;\n\ttask_context->timeout_enable = 0;\n\ttask_context->block_guard_enable = 0;\n\n\t \n\ttask_context->address_modifier = 0;\n\n\t \n\ttask_context->ssp_command_iu_length = req_len;\n\n\t \n\ttask_context->transfer_length_bytes = 0;\n\n\t \n\tmemcpy(&task_context->type.smp, &cmd, sizeof(u32));\n\n\t \n\ttask_context->task_phase = 0;\n\n\tireq->post_context = (SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |\n\t\t\t      (ISCI_PEG << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |\n\t\t\t       (iport->physical_port_index <<\n\t\t\t\tSCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |\n\t\t\t      ISCI_TAG_TCI(ireq->io_tag));\n\t \n\ttask_context->command_iu_upper = upper_32_bits(sg_dma_address(sg));\n\ttask_context->command_iu_lower = lower_32_bits(sg_dma_address(sg) + sizeof(u32));\n\n\t \n\ttask_context->response_iu_upper = 0;\n\ttask_context->response_iu_lower = 0;\n\n\tsci_change_state(&ireq->sm, SCI_REQ_CONSTRUCTED);\n\n\treturn SCI_SUCCESS;\n}\n\n \nstatic enum sci_status isci_smp_request_build(struct isci_request *ireq)\n{\n\tstruct sas_task *task = isci_request_access_task(ireq);\n\tstruct device *dev = &ireq->isci_host->pdev->dev;\n\tenum sci_status status = SCI_FAILURE;\n\n\tstatus = sci_io_request_construct_smp(dev, ireq, task);\n\tif (status != SCI_SUCCESS)\n\t\tdev_dbg(&ireq->isci_host->pdev->dev,\n\t\t\t \"%s: failed with status = %d\\n\",\n\t\t\t __func__,\n\t\t\t status);\n\n\treturn status;\n}\n\n \nstatic enum sci_status isci_io_request_build(struct isci_host *ihost,\n\t\t\t\t\t     struct isci_request *request,\n\t\t\t\t\t     struct isci_remote_device *idev)\n{\n\tenum sci_status status = SCI_SUCCESS;\n\tstruct sas_task *task = isci_request_access_task(request);\n\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: idev = 0x%p; request = %p, \"\n\t\t\"num_scatter = %d\\n\",\n\t\t__func__,\n\t\tidev,\n\t\trequest,\n\t\ttask->num_scatter);\n\n\t \n\tif (task->num_scatter &&\n\t    !sas_protocol_ata(task->task_proto) &&\n\t    !(SAS_PROTOCOL_SMP & task->task_proto)) {\n\n\t\trequest->num_sg_entries = dma_map_sg(\n\t\t\t&ihost->pdev->dev,\n\t\t\ttask->scatter,\n\t\t\ttask->num_scatter,\n\t\t\ttask->data_dir\n\t\t\t);\n\n\t\tif (request->num_sg_entries == 0)\n\t\t\treturn SCI_FAILURE_INSUFFICIENT_RESOURCES;\n\t}\n\n\tstatus = sci_io_request_construct(ihost, idev, request);\n\n\tif (status != SCI_SUCCESS) {\n\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t \"%s: failed request construct\\n\",\n\t\t\t __func__);\n\t\treturn SCI_FAILURE;\n\t}\n\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SMP:\n\t\tstatus = isci_smp_request_build(request);\n\t\tbreak;\n\tcase SAS_PROTOCOL_SSP:\n\t\tstatus = isci_request_ssp_request_construct(request);\n\t\tbreak;\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\tcase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:\n\t\tstatus = isci_request_stp_request_construct(request);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t \"%s: unknown protocol\\n\", __func__);\n\t\treturn SCI_FAILURE;\n\t}\n\n\treturn SCI_SUCCESS;\n}\n\nstatic struct isci_request *isci_request_from_tag(struct isci_host *ihost, u16 tag)\n{\n\tstruct isci_request *ireq;\n\n\tireq = ihost->reqs[ISCI_TAG_TCI(tag)];\n\tireq->io_tag = tag;\n\tireq->io_request_completion = NULL;\n\tireq->flags = 0;\n\tireq->num_sg_entries = 0;\n\n\treturn ireq;\n}\n\nstruct isci_request *isci_io_request_from_tag(struct isci_host *ihost,\n\t\t\t\t\t      struct sas_task *task,\n\t\t\t\t\t      u16 tag)\n{\n\tstruct isci_request *ireq;\n\n\tireq = isci_request_from_tag(ihost, tag);\n\tireq->ttype_ptr.io_task_ptr = task;\n\tclear_bit(IREQ_TMF, &ireq->flags);\n\ttask->lldd_task = ireq;\n\n\treturn ireq;\n}\n\nstruct isci_request *isci_tmf_request_from_tag(struct isci_host *ihost,\n\t\t\t\t\t       struct isci_tmf *isci_tmf,\n\t\t\t\t\t       u16 tag)\n{\n\tstruct isci_request *ireq;\n\n\tireq = isci_request_from_tag(ihost, tag);\n\tireq->ttype_ptr.tmf_task_ptr = isci_tmf;\n\tset_bit(IREQ_TMF, &ireq->flags);\n\n\treturn ireq;\n}\n\nint isci_request_execute(struct isci_host *ihost, struct isci_remote_device *idev,\n\t\t\t struct sas_task *task, struct isci_request *ireq)\n{\n\tenum sci_status status;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tstatus = isci_io_request_build(ihost, ireq, idev);\n\tif (status != SCI_SUCCESS) {\n\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t \"%s: request_construct failed - status = 0x%x\\n\",\n\t\t\t __func__,\n\t\t\t status);\n\t\treturn status;\n\t}\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\n\tif (test_bit(IDEV_IO_NCQERROR, &idev->flags)) {\n\n\t\tif (isci_task_is_ncq_recovery(task)) {\n\n\t\t\t \n\t\t\tstatus = sci_controller_start_task(ihost,\n\t\t\t\t\t\t\t    idev,\n\t\t\t\t\t\t\t    ireq);\n\t\t} else {\n\t\t\tstatus = SCI_FAILURE;\n\t\t}\n\t} else {\n\t\t \n\t\tstatus = sci_controller_start_io(ihost, idev,\n\t\t\t\t\t\t  ireq);\n\t}\n\n\tif (status != SCI_SUCCESS &&\n\t    status != SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED) {\n\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t \"%s: failed request start (0x%x)\\n\",\n\t\t\t __func__, status);\n\t\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\t\treturn status;\n\t}\n\t \n\tif (status != SCI_SUCCESS) {\n\t\t \n\t\tset_bit(IREQ_TERMINATED, &ireq->flags);\n\t}\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\tif (status ==\n\t    SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED) {\n\t\t \n\t\tspin_lock_irqsave(&task->task_state_lock, flags);\n\t\ttask->task_state_flags |= SAS_TASK_NEED_DEV_RESET;\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\t\t \n\t\tsas_task_abort(task);\n\n\t\t \n\t\tstatus = SCI_SUCCESS;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}