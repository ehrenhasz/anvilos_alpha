{
  "module_name": "port.c",
  "hash_id": "1240d9019dd4aef2c99144f80720f83268b8e0b76a763f824d289f2be68c0d19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/isci/port.c",
  "human_readable_source": " \n\n#include \"isci.h\"\n#include \"port.h\"\n#include \"request.h\"\n\n#define SCIC_SDS_PORT_HARD_RESET_TIMEOUT  (1000)\n#define SCU_DUMMY_INDEX    (0xFFFF)\n\n#undef C\n#define C(a) (#a)\nstatic const char *port_state_name(enum sci_port_states state)\n{\n\tstatic const char * const strings[] = PORT_STATES;\n\n\treturn strings[state];\n}\n#undef C\n\nstatic struct device *sciport_to_dev(struct isci_port *iport)\n{\n\tint i = iport->physical_port_index;\n\tstruct isci_port *table;\n\tstruct isci_host *ihost;\n\n\tif (i == SCIC_SDS_DUMMY_PORT)\n\t\ti = SCI_MAX_PORTS+1;\n\n\ttable = iport - i;\n\tihost = container_of(table, typeof(*ihost), ports[0]);\n\n\treturn &ihost->pdev->dev;\n}\n\nstatic void sci_port_get_protocols(struct isci_port *iport, struct sci_phy_proto *proto)\n{\n\tu8 index;\n\n\tproto->all = 0;\n\tfor (index = 0; index < SCI_MAX_PHYS; index++) {\n\t\tstruct isci_phy *iphy = iport->phy_table[index];\n\n\t\tif (!iphy)\n\t\t\tcontinue;\n\t\tsci_phy_get_protocols(iphy, proto);\n\t}\n}\n\nstatic u32 sci_port_get_phys(struct isci_port *iport)\n{\n\tu32 index;\n\tu32 mask;\n\n\tmask = 0;\n\tfor (index = 0; index < SCI_MAX_PHYS; index++)\n\t\tif (iport->phy_table[index])\n\t\t\tmask |= (1 << index);\n\n\treturn mask;\n}\n\n \nenum sci_status sci_port_get_properties(struct isci_port *iport,\n\t\t\t\t\t\tstruct sci_port_properties *prop)\n{\n\tif (!iport || iport->logical_port_index == SCIC_SDS_DUMMY_PORT)\n\t\treturn SCI_FAILURE_INVALID_PORT;\n\n\tprop->index = iport->logical_port_index;\n\tprop->phy_mask = sci_port_get_phys(iport);\n\tsci_port_get_sas_address(iport, &prop->local.sas_address);\n\tsci_port_get_protocols(iport, &prop->local.protocols);\n\tsci_port_get_attached_sas_address(iport, &prop->remote.sas_address);\n\n\treturn SCI_SUCCESS;\n}\n\nstatic void sci_port_bcn_enable(struct isci_port *iport)\n{\n\tstruct isci_phy *iphy;\n\tu32 val;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(iport->phy_table); i++) {\n\t\tiphy = iport->phy_table[i];\n\t\tif (!iphy)\n\t\t\tcontinue;\n\t\tval = readl(&iphy->link_layer_registers->link_layer_control);\n\t\t \n\t\twritel(val, &iphy->link_layer_registers->link_layer_control);\n\t}\n}\n\nstatic void isci_port_bc_change_received(struct isci_host *ihost,\n\t\t\t\t\t struct isci_port *iport,\n\t\t\t\t\t struct isci_phy *iphy)\n{\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: isci_phy = %p, sas_phy = %p\\n\",\n\t\t__func__, iphy, &iphy->sas_phy);\n\n\tsas_notify_port_event(&iphy->sas_phy,\n\t\t\t      PORTE_BROADCAST_RCVD, GFP_ATOMIC);\n\tsci_port_bcn_enable(iport);\n}\n\nstatic void isci_port_link_up(struct isci_host *isci_host,\n\t\t\t      struct isci_port *iport,\n\t\t\t      struct isci_phy *iphy)\n{\n\tunsigned long flags;\n\tstruct sci_port_properties properties;\n\tunsigned long success = true;\n\n\tdev_dbg(&isci_host->pdev->dev,\n\t\t\"%s: isci_port = %p\\n\",\n\t\t__func__, iport);\n\n\tspin_lock_irqsave(&iphy->sas_phy.frame_rcvd_lock, flags);\n\n\tsci_port_get_properties(iport, &properties);\n\n\tif (iphy->protocol == SAS_PROTOCOL_SATA) {\n\t\tu64 attached_sas_address;\n\n\t\tiphy->sas_phy.oob_mode = SATA_OOB_MODE;\n\t\tiphy->sas_phy.frame_rcvd_size = sizeof(struct dev_to_host_fis);\n\n\t\t \n\t\tattached_sas_address = properties.remote.sas_address.high;\n\t\tattached_sas_address <<= 32;\n\t\tattached_sas_address |= properties.remote.sas_address.low;\n\t\tswab64s(&attached_sas_address);\n\n\t\tmemcpy(&iphy->sas_phy.attached_sas_addr,\n\t\t       &attached_sas_address, sizeof(attached_sas_address));\n\t} else if (iphy->protocol == SAS_PROTOCOL_SSP) {\n\t\tiphy->sas_phy.oob_mode = SAS_OOB_MODE;\n\t\tiphy->sas_phy.frame_rcvd_size = sizeof(struct sas_identify_frame);\n\n\t\t \n\t\tmemcpy(iphy->sas_phy.attached_sas_addr,\n\t\t       iphy->frame_rcvd.iaf.sas_addr, SAS_ADDR_SIZE);\n\t} else {\n\t\tdev_err(&isci_host->pdev->dev, \"%s: unknown target\\n\", __func__);\n\t\tsuccess = false;\n\t}\n\n\tiphy->sas_phy.phy->negotiated_linkrate = sci_phy_linkrate(iphy);\n\n\tspin_unlock_irqrestore(&iphy->sas_phy.frame_rcvd_lock, flags);\n\n\t \n\tif (success)\n\t\tsas_notify_port_event(&iphy->sas_phy,\n\t\t\t\t      PORTE_BYTES_DMAED, GFP_ATOMIC);\n}\n\n\n \nstatic void isci_port_link_down(struct isci_host *isci_host,\n\t\t\t\tstruct isci_phy *isci_phy,\n\t\t\t\tstruct isci_port *isci_port)\n{\n\tstruct isci_remote_device *isci_device;\n\n\tdev_dbg(&isci_host->pdev->dev,\n\t\t\"%s: isci_port = %p\\n\", __func__, isci_port);\n\n\tif (isci_port) {\n\n\t\t \n\t\tif (isci_phy->sas_phy.port &&\n\t\t    isci_phy->sas_phy.port->num_phys == 1) {\n\t\t\t \n\t\t\tlist_for_each_entry(isci_device,\n\t\t\t\t\t    &isci_port->remote_dev_list,\n\t\t\t\t\t    node) {\n\t\t\t\tdev_dbg(&isci_host->pdev->dev,\n\t\t\t\t\t\"%s: isci_device = %p\\n\",\n\t\t\t\t\t__func__, isci_device);\n\t\t\t\tset_bit(IDEV_GONE, &isci_device->flags);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tsas_phy_disconnected(&isci_phy->sas_phy);\n\tsas_notify_phy_event(&isci_phy->sas_phy,\n\t\t\t     PHYE_LOSS_OF_SIGNAL, GFP_ATOMIC);\n\n\tdev_dbg(&isci_host->pdev->dev,\n\t\t\"%s: isci_port = %p - Done\\n\", __func__, isci_port);\n}\n\nstatic bool is_port_ready_state(enum sci_port_states state)\n{\n\tswitch (state) {\n\tcase SCI_PORT_READY:\n\tcase SCI_PORT_SUB_WAITING:\n\tcase SCI_PORT_SUB_OPERATIONAL:\n\tcase SCI_PORT_SUB_CONFIGURING:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic void port_state_machine_change(struct isci_port *iport,\n\t\t\t\t      enum sci_port_states state)\n{\n\tstruct sci_base_state_machine *sm = &iport->sm;\n\tenum sci_port_states old_state = sm->current_state_id;\n\n\tif (is_port_ready_state(old_state) && !is_port_ready_state(state))\n\t\tiport->ready_exit = true;\n\n\tsci_change_state(sm, state);\n\tiport->ready_exit = false;\n}\n\n \nstatic void isci_port_hard_reset_complete(struct isci_port *isci_port,\n\t\t\t\t\t  enum sci_status completion_status)\n{\n\tstruct isci_host *ihost = isci_port->owning_controller;\n\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: isci_port = %p, completion_status=%x\\n\",\n\t\t     __func__, isci_port, completion_status);\n\n\t \n\tisci_port->hard_reset_status = completion_status;\n\n\tif (completion_status != SCI_SUCCESS) {\n\n\t\t \n\t\tif (isci_port->active_phy_mask == 0) {\n\t\t\tint phy_idx = isci_port->last_active_phy;\n\t\t\tstruct isci_phy *iphy = &ihost->phys[phy_idx];\n\n\t\t\t \n\t\t\tisci_port_link_down(ihost, iphy, isci_port);\n\t\t}\n\t\t \n\t\tport_state_machine_change(isci_port, SCI_PORT_SUB_WAITING);\n\n\t}\n\tclear_bit(IPORT_RESET_PENDING, &isci_port->state);\n\twake_up(&ihost->eventq);\n\n}\n\n \nbool sci_port_is_valid_phy_assignment(struct isci_port *iport, u32 phy_index)\n{\n\tstruct isci_host *ihost = iport->owning_controller;\n\tstruct sci_user_parameters *user = &ihost->user_parameters;\n\n\t \n\tu32 existing_phy_index = SCI_MAX_PHYS;\n\tu32 index;\n\n\tif ((iport->physical_port_index == 1) && (phy_index != 1))\n\t\treturn false;\n\n\tif (iport->physical_port_index == 3 && phy_index != 3)\n\t\treturn false;\n\n\tif (iport->physical_port_index == 2 &&\n\t    (phy_index == 0 || phy_index == 1))\n\t\treturn false;\n\n\tfor (index = 0; index < SCI_MAX_PHYS; index++)\n\t\tif (iport->phy_table[index] && index != phy_index)\n\t\t\texisting_phy_index = index;\n\n\t \n\tif (existing_phy_index < SCI_MAX_PHYS &&\n\t    user->phys[phy_index].max_speed_generation !=\n\t    user->phys[existing_phy_index].max_speed_generation)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool sci_port_is_phy_mask_valid(\n\tstruct isci_port *iport,\n\tu32 phy_mask)\n{\n\tif (iport->physical_port_index == 0) {\n\t\tif (((phy_mask & 0x0F) == 0x0F)\n\t\t    || ((phy_mask & 0x03) == 0x03)\n\t\t    || ((phy_mask & 0x01) == 0x01)\n\t\t    || (phy_mask == 0))\n\t\t\treturn true;\n\t} else if (iport->physical_port_index == 1) {\n\t\tif (((phy_mask & 0x02) == 0x02)\n\t\t    || (phy_mask == 0))\n\t\t\treturn true;\n\t} else if (iport->physical_port_index == 2) {\n\t\tif (((phy_mask & 0x0C) == 0x0C)\n\t\t    || ((phy_mask & 0x04) == 0x04)\n\t\t    || (phy_mask == 0))\n\t\t\treturn true;\n\t} else if (iport->physical_port_index == 3) {\n\t\tif (((phy_mask & 0x08) == 0x08)\n\t\t    || (phy_mask == 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic struct isci_phy *sci_port_get_a_connected_phy(struct isci_port *iport)\n{\n\tu32 index;\n\tstruct isci_phy *iphy;\n\n\tfor (index = 0; index < SCI_MAX_PHYS; index++) {\n\t\t \n\t\tiphy = iport->phy_table[index];\n\t\tif (iphy && sci_port_active_phy(iport, iphy))\n\t\t\treturn iphy;\n\t}\n\n\treturn NULL;\n}\n\nstatic enum sci_status sci_port_set_phy(struct isci_port *iport, struct isci_phy *iphy)\n{\n\t \n\tif (!iport->phy_table[iphy->phy_index] &&\n\t    !phy_get_non_dummy_port(iphy) &&\n\t    sci_port_is_valid_phy_assignment(iport, iphy->phy_index)) {\n\t\t \n\t\tiport->logical_port_index = iport->physical_port_index;\n\t\tiport->phy_table[iphy->phy_index] = iphy;\n\t\tsci_phy_set_port(iphy, iport);\n\n\t\treturn SCI_SUCCESS;\n\t}\n\n\treturn SCI_FAILURE;\n}\n\nstatic enum sci_status sci_port_clear_phy(struct isci_port *iport, struct isci_phy *iphy)\n{\n\t \n\tif (iport->phy_table[iphy->phy_index] == iphy &&\n\t    phy_get_non_dummy_port(iphy) == iport) {\n\t\tstruct isci_host *ihost = iport->owning_controller;\n\n\t\t \n\t\tsci_phy_set_port(iphy, &ihost->ports[SCI_MAX_PORTS]);\n\t\tiport->phy_table[iphy->phy_index] = NULL;\n\t\treturn SCI_SUCCESS;\n\t}\n\n\treturn SCI_FAILURE;\n}\n\nvoid sci_port_get_sas_address(struct isci_port *iport, struct sci_sas_address *sas)\n{\n\tu32 index;\n\n\tsas->high = 0;\n\tsas->low  = 0;\n\tfor (index = 0; index < SCI_MAX_PHYS; index++)\n\t\tif (iport->phy_table[index])\n\t\t\tsci_phy_get_sas_address(iport->phy_table[index], sas);\n}\n\nvoid sci_port_get_attached_sas_address(struct isci_port *iport, struct sci_sas_address *sas)\n{\n\tstruct isci_phy *iphy;\n\n\t \n\tiphy = sci_port_get_a_connected_phy(iport);\n\tif (iphy) {\n\t\tif (iphy->protocol != SAS_PROTOCOL_SATA) {\n\t\t\tsci_phy_get_attached_sas_address(iphy, sas);\n\t\t} else {\n\t\t\tsci_phy_get_sas_address(iphy, sas);\n\t\t\tsas->low += iphy->phy_index;\n\t\t}\n\t} else {\n\t\tsas->high = 0;\n\t\tsas->low  = 0;\n\t}\n}\n\n \nstatic void sci_port_construct_dummy_rnc(struct isci_port *iport, u16 rni)\n{\n\tunion scu_remote_node_context *rnc;\n\n\trnc = &iport->owning_controller->remote_node_context_table[rni];\n\n\tmemset(rnc, 0, sizeof(union scu_remote_node_context));\n\n\trnc->ssp.remote_sas_address_hi = 0;\n\trnc->ssp.remote_sas_address_lo = 0;\n\n\trnc->ssp.remote_node_index = rni;\n\trnc->ssp.remote_node_port_width = 1;\n\trnc->ssp.logical_port_index = iport->physical_port_index;\n\n\trnc->ssp.nexus_loss_timer_enable = false;\n\trnc->ssp.check_bit = false;\n\trnc->ssp.is_valid = true;\n\trnc->ssp.is_remote_node_context = true;\n\trnc->ssp.function_number = 0;\n\trnc->ssp.arbitration_wait_time = 0;\n}\n\n \nstatic void sci_port_construct_dummy_task(struct isci_port *iport, u16 tag)\n{\n\tstruct isci_host *ihost = iport->owning_controller;\n\tstruct scu_task_context *task_context;\n\n\ttask_context = &ihost->task_context_table[ISCI_TAG_TCI(tag)];\n\tmemset(task_context, 0, sizeof(struct scu_task_context));\n\n\ttask_context->initiator_request = 1;\n\ttask_context->connection_rate = 1;\n\ttask_context->logical_port_index = iport->physical_port_index;\n\ttask_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SSP;\n\ttask_context->task_index = ISCI_TAG_TCI(tag);\n\ttask_context->valid = SCU_TASK_CONTEXT_VALID;\n\ttask_context->context_type = SCU_TASK_CONTEXT_TYPE;\n\ttask_context->remote_node_index = iport->reserved_rni;\n\ttask_context->do_not_dma_ssp_good_response = 1;\n\ttask_context->task_phase = 0x01;\n}\n\nstatic void sci_port_destroy_dummy_resources(struct isci_port *iport)\n{\n\tstruct isci_host *ihost = iport->owning_controller;\n\n\tif (iport->reserved_tag != SCI_CONTROLLER_INVALID_IO_TAG)\n\t\tisci_free_tag(ihost, iport->reserved_tag);\n\n\tif (iport->reserved_rni != SCU_DUMMY_INDEX)\n\t\tsci_remote_node_table_release_remote_node_index(&ihost->available_remote_nodes,\n\t\t\t\t\t\t\t\t     1, iport->reserved_rni);\n\n\tiport->reserved_rni = SCU_DUMMY_INDEX;\n\tiport->reserved_tag = SCI_CONTROLLER_INVALID_IO_TAG;\n}\n\nvoid sci_port_setup_transports(struct isci_port *iport, u32 device_id)\n{\n\tu8 index;\n\n\tfor (index = 0; index < SCI_MAX_PHYS; index++) {\n\t\tif (iport->active_phy_mask & (1 << index))\n\t\t\tsci_phy_setup_transport(iport->phy_table[index], device_id);\n\t}\n}\n\nstatic void sci_port_resume_phy(struct isci_port *iport, struct isci_phy *iphy)\n{\n\tsci_phy_resume(iphy);\n\tiport->enabled_phy_mask |= 1 << iphy->phy_index;\n}\n\nstatic void sci_port_activate_phy(struct isci_port *iport,\n\t\t\t\t  struct isci_phy *iphy,\n\t\t\t\t  u8 flags)\n{\n\tstruct isci_host *ihost = iport->owning_controller;\n\n\tif (iphy->protocol != SAS_PROTOCOL_SATA && (flags & PF_RESUME))\n\t\tsci_phy_resume(iphy);\n\n\tiport->active_phy_mask |= 1 << iphy->phy_index;\n\n\tsci_controller_clear_invalid_phy(ihost, iphy);\n\n\tif (flags & PF_NOTIFY)\n\t\tisci_port_link_up(ihost, iport, iphy);\n}\n\nvoid sci_port_deactivate_phy(struct isci_port *iport, struct isci_phy *iphy,\n\t\t\t     bool do_notify_user)\n{\n\tstruct isci_host *ihost = iport->owning_controller;\n\n\tiport->active_phy_mask &= ~(1 << iphy->phy_index);\n\tiport->enabled_phy_mask &= ~(1 << iphy->phy_index);\n\tif (!iport->active_phy_mask)\n\t\tiport->last_active_phy = iphy->phy_index;\n\n\tiphy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;\n\n\t \n\tif (iport->owning_controller->oem_parameters.controller.mode_type ==\n\t\tSCIC_PORT_AUTOMATIC_CONFIGURATION_MODE)\n\t\twritel(iphy->phy_index,\n\t\t\t&iport->port_pe_configuration_register[iphy->phy_index]);\n\n\tif (do_notify_user == true)\n\t\tisci_port_link_down(ihost, iphy, iport);\n}\n\nstatic void sci_port_invalid_link_up(struct isci_port *iport, struct isci_phy *iphy)\n{\n\tstruct isci_host *ihost = iport->owning_controller;\n\n\t \n\tif ((ihost->invalid_phy_mask & (1 << iphy->phy_index)) == 0) {\n\t\tihost->invalid_phy_mask |= 1 << iphy->phy_index;\n\t\tdev_warn(&ihost->pdev->dev, \"Invalid link up!\\n\");\n\t}\n}\n\n \nstatic void sci_port_general_link_up_handler(struct isci_port *iport,\n\t\t\t\t\t     struct isci_phy *iphy,\n\t\t\t\t\t     u8 flags)\n{\n\tstruct sci_sas_address port_sas_address;\n\tstruct sci_sas_address phy_sas_address;\n\n\tsci_port_get_attached_sas_address(iport, &port_sas_address);\n\tsci_phy_get_attached_sas_address(iphy, &phy_sas_address);\n\n\t \n\tif ((phy_sas_address.high == port_sas_address.high &&\n\t     phy_sas_address.low  == port_sas_address.low) ||\n\t    iport->active_phy_mask == 0) {\n\t\tstruct sci_base_state_machine *sm = &iport->sm;\n\n\t\tsci_port_activate_phy(iport, iphy, flags);\n\t\tif (sm->current_state_id == SCI_PORT_RESETTING)\n\t\t\tport_state_machine_change(iport, SCI_PORT_READY);\n\t} else\n\t\tsci_port_invalid_link_up(iport, iphy);\n}\n\n\n\n \nstatic bool sci_port_is_wide(struct isci_port *iport)\n{\n\tu32 index;\n\tu32 phy_count = 0;\n\n\tfor (index = 0; index < SCI_MAX_PHYS; index++) {\n\t\tif (iport->phy_table[index] != NULL) {\n\t\t\tphy_count++;\n\t\t}\n\t}\n\n\treturn phy_count != 1;\n}\n\n \nbool sci_port_link_detected(struct isci_port *iport, struct isci_phy *iphy)\n{\n\tif ((iport->logical_port_index != SCIC_SDS_DUMMY_PORT) &&\n\t    (iphy->protocol == SAS_PROTOCOL_SATA)) {\n\t\tif (sci_port_is_wide(iport)) {\n\t\t\tsci_port_invalid_link_up(iport, iphy);\n\t\t\treturn false;\n\t\t} else {\n\t\t\tstruct isci_host *ihost = iport->owning_controller;\n\t\t\tstruct isci_port *dst_port = &(ihost->ports[iphy->phy_index]);\n\t\t\twritel(iphy->phy_index,\n\t\t\t       &dst_port->port_pe_configuration_register[iphy->phy_index]);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic void port_timeout(struct timer_list *t)\n{\n\tstruct sci_timer *tmr = from_timer(tmr, t, timer);\n\tstruct isci_port *iport = container_of(tmr, typeof(*iport), timer);\n\tstruct isci_host *ihost = iport->owning_controller;\n\tunsigned long flags;\n\tu32 current_state;\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\n\tif (tmr->cancel)\n\t\tgoto done;\n\n\tcurrent_state = iport->sm.current_state_id;\n\n\tif (current_state == SCI_PORT_RESETTING) {\n\t\t \n\t\tport_state_machine_change(iport, SCI_PORT_FAILED);\n\t} else if (current_state == SCI_PORT_STOPPED) {\n\t\t \n\t\tdev_err(sciport_to_dev(iport),\n\t\t\t\"%s: SCIC Port 0x%p failed to stop before timeout.\\n\",\n\t\t\t__func__,\n\t\t\tiport);\n\t} else if (current_state == SCI_PORT_STOPPING) {\n\t\tdev_dbg(sciport_to_dev(iport),\n\t\t\t\"%s: port%d: stop complete timeout\\n\",\n\t\t\t__func__, iport->physical_port_index);\n\t} else {\n\t\t \n\t\tdev_err(sciport_to_dev(iport),\n\t\t\t\"%s: SCIC Port 0x%p is processing a timeout operation \"\n\t\t\t\"in state %d.\\n\", __func__, iport, current_state);\n\t}\n\ndone:\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n}\n\n \n\n \nstatic void sci_port_update_viit_entry(struct isci_port *iport)\n{\n\tstruct sci_sas_address sas_address;\n\n\tsci_port_get_sas_address(iport, &sas_address);\n\n\twritel(sas_address.high,\n\t\t&iport->viit_registers->initiator_sas_address_hi);\n\twritel(sas_address.low,\n\t\t&iport->viit_registers->initiator_sas_address_lo);\n\n\t \n\twritel(0, &iport->viit_registers->reserved);\n\n\t \n\twritel(SCU_VIIT_ENTRY_ID_VIIT |\n\t       SCU_VIIT_IPPT_INITIATOR |\n\t       ((1 << iport->physical_port_index) << SCU_VIIT_ENTRY_LPVIE_SHIFT) |\n\t       SCU_VIIT_STATUS_ALL_VALID,\n\t       &iport->viit_registers->status);\n}\n\nenum sas_linkrate sci_port_get_max_allowed_speed(struct isci_port *iport)\n{\n\tu16 index;\n\tstruct isci_phy *iphy;\n\tenum sas_linkrate max_allowed_speed = SAS_LINK_RATE_6_0_GBPS;\n\n\t \n\tfor (index = 0; index < SCI_MAX_PHYS; index++) {\n\t\tiphy = iport->phy_table[index];\n\t\tif (iphy && sci_port_active_phy(iport, iphy) &&\n\t\t    iphy->max_negotiated_speed < max_allowed_speed)\n\t\t\tmax_allowed_speed = iphy->max_negotiated_speed;\n\t}\n\n\treturn max_allowed_speed;\n}\n\nstatic void sci_port_suspend_port_task_scheduler(struct isci_port *iport)\n{\n\tu32 pts_control_value;\n\n\tpts_control_value = readl(&iport->port_task_scheduler_registers->control);\n\tpts_control_value |= SCU_PTSxCR_GEN_BIT(SUSPEND);\n\twritel(pts_control_value, &iport->port_task_scheduler_registers->control);\n}\n\n \nstatic void sci_port_post_dummy_request(struct isci_port *iport)\n{\n\tstruct isci_host *ihost = iport->owning_controller;\n\tu16 tag = iport->reserved_tag;\n\tstruct scu_task_context *tc;\n\tu32 command;\n\n\ttc = &ihost->task_context_table[ISCI_TAG_TCI(tag)];\n\ttc->abort = 0;\n\n\tcommand = SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |\n\t\t  iport->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |\n\t\t  ISCI_TAG_TCI(tag);\n\n\tsci_controller_post_request(ihost, command);\n}\n\n \nstatic void sci_port_abort_dummy_request(struct isci_port *iport)\n{\n\tstruct isci_host *ihost = iport->owning_controller;\n\tu16 tag = iport->reserved_tag;\n\tstruct scu_task_context *tc;\n\tu32 command;\n\n\ttc = &ihost->task_context_table[ISCI_TAG_TCI(tag)];\n\ttc->abort = 1;\n\n\tcommand = SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT |\n\t\t  iport->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |\n\t\t  ISCI_TAG_TCI(tag);\n\n\tsci_controller_post_request(ihost, command);\n}\n\n \nstatic void\nsci_port_resume_port_task_scheduler(struct isci_port *iport)\n{\n\tu32 pts_control_value;\n\n\tpts_control_value = readl(&iport->port_task_scheduler_registers->control);\n\tpts_control_value &= ~SCU_PTSxCR_GEN_BIT(SUSPEND);\n\twritel(pts_control_value, &iport->port_task_scheduler_registers->control);\n}\n\nstatic void sci_port_ready_substate_waiting_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_port *iport = container_of(sm, typeof(*iport), sm);\n\n\tsci_port_suspend_port_task_scheduler(iport);\n\n\tiport->not_ready_reason = SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS;\n\n\tif (iport->active_phy_mask != 0) {\n\t\t \n\t\tport_state_machine_change(iport,\n\t\t\t\t\t  SCI_PORT_SUB_OPERATIONAL);\n\t}\n}\n\nstatic void scic_sds_port_ready_substate_waiting_exit(\n\t\t\t\t\tstruct sci_base_state_machine *sm)\n{\n\tstruct isci_port *iport = container_of(sm, typeof(*iport), sm);\n\tsci_port_resume_port_task_scheduler(iport);\n}\n\nstatic void sci_port_ready_substate_operational_enter(struct sci_base_state_machine *sm)\n{\n\tu32 index;\n\tstruct isci_port *iport = container_of(sm, typeof(*iport), sm);\n\tstruct isci_host *ihost = iport->owning_controller;\n\n\tdev_dbg(&ihost->pdev->dev, \"%s: port%d ready\\n\",\n\t\t__func__, iport->physical_port_index);\n\n\tfor (index = 0; index < SCI_MAX_PHYS; index++) {\n\t\tif (iport->phy_table[index]) {\n\t\t\twritel(iport->physical_port_index,\n\t\t\t\t&iport->port_pe_configuration_register[\n\t\t\t\t\tiport->phy_table[index]->phy_index]);\n\t\t\tif (((iport->active_phy_mask^iport->enabled_phy_mask) & (1 << index)) != 0)\n\t\t\t\tsci_port_resume_phy(iport, iport->phy_table[index]);\n\t\t}\n\t}\n\n\tsci_port_update_viit_entry(iport);\n\n\t \n\tsci_port_post_dummy_request(iport);\n}\n\nstatic void sci_port_invalidate_dummy_remote_node(struct isci_port *iport)\n{\n\tstruct isci_host *ihost = iport->owning_controller;\n\tu8 phys_index = iport->physical_port_index;\n\tunion scu_remote_node_context *rnc;\n\tu16 rni = iport->reserved_rni;\n\tu32 command;\n\n\trnc = &ihost->remote_node_context_table[rni];\n\n\trnc->ssp.is_valid = false;\n\n\t \n\treadl(&ihost->smu_registers->interrupt_status);  \n\tudelay(10);\n\n\tcommand = SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE |\n\t\t  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;\n\n\tsci_controller_post_request(ihost, command);\n}\n\n \nstatic void sci_port_ready_substate_operational_exit(struct sci_base_state_machine *sm)\n{\n\tstruct isci_port *iport = container_of(sm, typeof(*iport), sm);\n\tstruct isci_host *ihost = iport->owning_controller;\n\n\t \n\tsci_port_abort_dummy_request(iport);\n\n\tdev_dbg(&ihost->pdev->dev, \"%s: port%d !ready\\n\",\n\t\t__func__, iport->physical_port_index);\n\n\tif (iport->ready_exit)\n\t\tsci_port_invalidate_dummy_remote_node(iport);\n}\n\nstatic void sci_port_ready_substate_configuring_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_port *iport = container_of(sm, typeof(*iport), sm);\n\tstruct isci_host *ihost = iport->owning_controller;\n\n\tif (iport->active_phy_mask == 0) {\n\t\tdev_dbg(&ihost->pdev->dev, \"%s: port%d !ready\\n\",\n\t\t\t__func__, iport->physical_port_index);\n\n\t\tport_state_machine_change(iport, SCI_PORT_SUB_WAITING);\n\t} else\n\t\tport_state_machine_change(iport, SCI_PORT_SUB_OPERATIONAL);\n}\n\nenum sci_status sci_port_start(struct isci_port *iport)\n{\n\tstruct isci_host *ihost = iport->owning_controller;\n\tenum sci_status status = SCI_SUCCESS;\n\tenum sci_port_states state;\n\tu32 phy_mask;\n\n\tstate = iport->sm.current_state_id;\n\tif (state != SCI_PORT_STOPPED) {\n\t\tdev_warn(sciport_to_dev(iport), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, port_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n\n\tif (iport->assigned_device_count > 0) {\n\t\t \n\t\treturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\n\t}\n\n\tif (iport->reserved_rni == SCU_DUMMY_INDEX) {\n\t\tu16 rni = sci_remote_node_table_allocate_remote_node(\n\t\t\t\t&ihost->available_remote_nodes, 1);\n\n\t\tif (rni != SCU_DUMMY_INDEX)\n\t\t\tsci_port_construct_dummy_rnc(iport, rni);\n\t\telse\n\t\t\tstatus = SCI_FAILURE_INSUFFICIENT_RESOURCES;\n\t\tiport->reserved_rni = rni;\n\t}\n\n\tif (iport->reserved_tag == SCI_CONTROLLER_INVALID_IO_TAG) {\n\t\tu16 tag;\n\n\t\ttag = isci_alloc_tag(ihost);\n\t\tif (tag == SCI_CONTROLLER_INVALID_IO_TAG)\n\t\t\tstatus = SCI_FAILURE_INSUFFICIENT_RESOURCES;\n\t\telse\n\t\t\tsci_port_construct_dummy_task(iport, tag);\n\t\tiport->reserved_tag = tag;\n\t}\n\n\tif (status == SCI_SUCCESS) {\n\t\tphy_mask = sci_port_get_phys(iport);\n\n\t\t \n\t\tif (sci_port_is_phy_mask_valid(iport, phy_mask) == true) {\n\t\t\tport_state_machine_change(iport,\n\t\t\t\t\t\t  SCI_PORT_READY);\n\n\t\t\treturn SCI_SUCCESS;\n\t\t}\n\t\tstatus = SCI_FAILURE;\n\t}\n\n\tif (status != SCI_SUCCESS)\n\t\tsci_port_destroy_dummy_resources(iport);\n\n\treturn status;\n}\n\nenum sci_status sci_port_stop(struct isci_port *iport)\n{\n\tenum sci_port_states state;\n\n\tstate = iport->sm.current_state_id;\n\tswitch (state) {\n\tcase SCI_PORT_STOPPED:\n\t\treturn SCI_SUCCESS;\n\tcase SCI_PORT_SUB_WAITING:\n\tcase SCI_PORT_SUB_OPERATIONAL:\n\tcase SCI_PORT_SUB_CONFIGURING:\n\tcase SCI_PORT_RESETTING:\n\t\tport_state_machine_change(iport,\n\t\t\t\t\t  SCI_PORT_STOPPING);\n\t\treturn SCI_SUCCESS;\n\tdefault:\n\t\tdev_warn(sciport_to_dev(iport), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, port_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n}\n\nstatic enum sci_status sci_port_hard_reset(struct isci_port *iport, u32 timeout)\n{\n\tenum sci_status status = SCI_FAILURE_INVALID_PHY;\n\tstruct isci_phy *iphy = NULL;\n\tenum sci_port_states state;\n\tu32 phy_index;\n\n\tstate = iport->sm.current_state_id;\n\tif (state != SCI_PORT_SUB_OPERATIONAL) {\n\t\tdev_warn(sciport_to_dev(iport), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, port_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n\n\t \n\tfor (phy_index = 0; phy_index < SCI_MAX_PHYS && !iphy; phy_index++) {\n\t\tiphy = iport->phy_table[phy_index];\n\t\tif (iphy && !sci_port_active_phy(iport, iphy)) {\n\t\t\t \n\t\t\tiphy = NULL;\n\t\t}\n\t}\n\n\t \n\tif (!iphy)\n\t\treturn status;\n\tstatus = sci_phy_reset(iphy);\n\n\tif (status != SCI_SUCCESS)\n\t\treturn status;\n\n\tsci_mod_timer(&iport->timer, timeout);\n\tiport->not_ready_reason = SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;\n\n\tport_state_machine_change(iport, SCI_PORT_RESETTING);\n\treturn SCI_SUCCESS;\n}\n\n \nenum sci_status sci_port_add_phy(struct isci_port *iport,\n\t\t\t\t      struct isci_phy *iphy)\n{\n\tenum sci_status status;\n\tenum sci_port_states state;\n\n\tsci_port_bcn_enable(iport);\n\n\tstate = iport->sm.current_state_id;\n\tswitch (state) {\n\tcase SCI_PORT_STOPPED: {\n\t\tstruct sci_sas_address port_sas_address;\n\n\t\t \n\t\tsci_port_get_sas_address(iport, &port_sas_address);\n\n\t\tif (port_sas_address.high != 0 && port_sas_address.low != 0) {\n\t\t\tstruct sci_sas_address phy_sas_address;\n\n\t\t\t \n\t\t\tsci_phy_get_sas_address(iphy, &phy_sas_address);\n\n\t\t\tif (port_sas_address.high != phy_sas_address.high ||\n\t\t\t    port_sas_address.low  != phy_sas_address.low)\n\t\t\t\treturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\n\t\t}\n\t\treturn sci_port_set_phy(iport, iphy);\n\t}\n\tcase SCI_PORT_SUB_WAITING:\n\tcase SCI_PORT_SUB_OPERATIONAL:\n\t\tstatus = sci_port_set_phy(iport, iphy);\n\n\t\tif (status != SCI_SUCCESS)\n\t\t\treturn status;\n\n\t\tsci_port_general_link_up_handler(iport, iphy, PF_NOTIFY|PF_RESUME);\n\t\tiport->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;\n\t\tport_state_machine_change(iport, SCI_PORT_SUB_CONFIGURING);\n\n\t\treturn status;\n\tcase SCI_PORT_SUB_CONFIGURING:\n\t\tstatus = sci_port_set_phy(iport, iphy);\n\n\t\tif (status != SCI_SUCCESS)\n\t\t\treturn status;\n\t\tsci_port_general_link_up_handler(iport, iphy, PF_NOTIFY);\n\n\t\t \n\t\tport_state_machine_change(iport,\n\t\t\t\t\t  SCI_PORT_SUB_CONFIGURING);\n\t\treturn SCI_SUCCESS;\n\tdefault:\n\t\tdev_warn(sciport_to_dev(iport), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, port_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n}\n\n \nenum sci_status sci_port_remove_phy(struct isci_port *iport,\n\t\t\t\t\t struct isci_phy *iphy)\n{\n\tenum sci_status status;\n\tenum sci_port_states state;\n\n\tstate = iport->sm.current_state_id;\n\n\tswitch (state) {\n\tcase SCI_PORT_STOPPED:\n\t\treturn sci_port_clear_phy(iport, iphy);\n\tcase SCI_PORT_SUB_OPERATIONAL:\n\t\tstatus = sci_port_clear_phy(iport, iphy);\n\t\tif (status != SCI_SUCCESS)\n\t\t\treturn status;\n\n\t\tsci_port_deactivate_phy(iport, iphy, true);\n\t\tiport->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;\n\t\tport_state_machine_change(iport,\n\t\t\t\t\t  SCI_PORT_SUB_CONFIGURING);\n\t\treturn SCI_SUCCESS;\n\tcase SCI_PORT_SUB_CONFIGURING:\n\t\tstatus = sci_port_clear_phy(iport, iphy);\n\n\t\tif (status != SCI_SUCCESS)\n\t\t\treturn status;\n\t\tsci_port_deactivate_phy(iport, iphy, true);\n\n\t\t \n\t\tport_state_machine_change(iport,\n\t\t\t\t\t  SCI_PORT_SUB_CONFIGURING);\n\t\treturn SCI_SUCCESS;\n\tdefault:\n\t\tdev_warn(sciport_to_dev(iport), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, port_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n}\n\nenum sci_status sci_port_link_up(struct isci_port *iport,\n\t\t\t\t      struct isci_phy *iphy)\n{\n\tenum sci_port_states state;\n\n\tstate = iport->sm.current_state_id;\n\tswitch (state) {\n\tcase SCI_PORT_SUB_WAITING:\n\t\t \n\t\tsci_port_activate_phy(iport, iphy, PF_NOTIFY|PF_RESUME);\n\n\t\tport_state_machine_change(iport,\n\t\t\t\t\t  SCI_PORT_SUB_OPERATIONAL);\n\t\treturn SCI_SUCCESS;\n\tcase SCI_PORT_SUB_OPERATIONAL:\n\t\tsci_port_general_link_up_handler(iport, iphy, PF_NOTIFY|PF_RESUME);\n\t\treturn SCI_SUCCESS;\n\tcase SCI_PORT_RESETTING:\n\t\t \n\n\t\t \n\t\tsci_port_general_link_up_handler(iport, iphy, PF_RESUME);\n\t\treturn SCI_SUCCESS;\n\tdefault:\n\t\tdev_warn(sciport_to_dev(iport), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, port_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n}\n\nenum sci_status sci_port_link_down(struct isci_port *iport,\n\t\t\t\t\tstruct isci_phy *iphy)\n{\n\tenum sci_port_states state;\n\n\tstate = iport->sm.current_state_id;\n\tswitch (state) {\n\tcase SCI_PORT_SUB_OPERATIONAL:\n\t\tsci_port_deactivate_phy(iport, iphy, true);\n\n\t\t \n\t\tif (iport->active_phy_mask == 0)\n\t\t\tport_state_machine_change(iport,\n\t\t\t\t\t\t  SCI_PORT_SUB_WAITING);\n\t\treturn SCI_SUCCESS;\n\tcase SCI_PORT_RESETTING:\n\t\t \n\t\tsci_port_deactivate_phy(iport, iphy, false);\n\t\treturn SCI_SUCCESS;\n\tdefault:\n\t\tdev_warn(sciport_to_dev(iport), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, port_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n}\n\nenum sci_status sci_port_start_io(struct isci_port *iport,\n\t\t\t\t  struct isci_remote_device *idev,\n\t\t\t\t  struct isci_request *ireq)\n{\n\tenum sci_port_states state;\n\n\tstate = iport->sm.current_state_id;\n\tswitch (state) {\n\tcase SCI_PORT_SUB_WAITING:\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\tcase SCI_PORT_SUB_OPERATIONAL:\n\t\tiport->started_request_count++;\n\t\treturn SCI_SUCCESS;\n\tdefault:\n\t\tdev_warn(sciport_to_dev(iport), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, port_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n}\n\nenum sci_status sci_port_complete_io(struct isci_port *iport,\n\t\t\t\t     struct isci_remote_device *idev,\n\t\t\t\t     struct isci_request *ireq)\n{\n\tenum sci_port_states state;\n\n\tstate = iport->sm.current_state_id;\n\tswitch (state) {\n\tcase SCI_PORT_STOPPED:\n\t\tdev_warn(sciport_to_dev(iport), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, port_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\tcase SCI_PORT_STOPPING:\n\t\tsci_port_decrement_request_count(iport);\n\n\t\tif (iport->started_request_count == 0)\n\t\t\tport_state_machine_change(iport,\n\t\t\t\t\t\t  SCI_PORT_STOPPED);\n\t\tbreak;\n\tcase SCI_PORT_READY:\n\tcase SCI_PORT_RESETTING:\n\tcase SCI_PORT_FAILED:\n\tcase SCI_PORT_SUB_WAITING:\n\tcase SCI_PORT_SUB_OPERATIONAL:\n\t\tsci_port_decrement_request_count(iport);\n\t\tbreak;\n\tcase SCI_PORT_SUB_CONFIGURING:\n\t\tsci_port_decrement_request_count(iport);\n\t\tif (iport->started_request_count == 0) {\n\t\t\tport_state_machine_change(iport,\n\t\t\t\t\t\t  SCI_PORT_SUB_OPERATIONAL);\n\t\t}\n\t\tbreak;\n\t}\n\treturn SCI_SUCCESS;\n}\n\nstatic void sci_port_enable_port_task_scheduler(struct isci_port *iport)\n{\n\tu32 pts_control_value;\n\n\t  \n\tpts_control_value = readl(&iport->port_task_scheduler_registers->control);\n\tpts_control_value |= SCU_PTSxCR_GEN_BIT(ENABLE) | SCU_PTSxCR_GEN_BIT(SUSPEND);\n\twritel(pts_control_value, &iport->port_task_scheduler_registers->control);\n}\n\nstatic void sci_port_disable_port_task_scheduler(struct isci_port *iport)\n{\n\tu32 pts_control_value;\n\n\tpts_control_value = readl(&iport->port_task_scheduler_registers->control);\n\tpts_control_value &=\n\t\t~(SCU_PTSxCR_GEN_BIT(ENABLE) | SCU_PTSxCR_GEN_BIT(SUSPEND));\n\twritel(pts_control_value, &iport->port_task_scheduler_registers->control);\n}\n\nstatic void sci_port_post_dummy_remote_node(struct isci_port *iport)\n{\n\tstruct isci_host *ihost = iport->owning_controller;\n\tu8 phys_index = iport->physical_port_index;\n\tunion scu_remote_node_context *rnc;\n\tu16 rni = iport->reserved_rni;\n\tu32 command;\n\n\trnc = &ihost->remote_node_context_table[rni];\n\trnc->ssp.is_valid = true;\n\n\tcommand = SCU_CONTEXT_COMMAND_POST_RNC_32 |\n\t\t  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;\n\n\tsci_controller_post_request(ihost, command);\n\n\t \n\treadl(&ihost->smu_registers->interrupt_status);  \n\tudelay(10);\n\n\tcommand = SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX_RX |\n\t\t  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;\n\n\tsci_controller_post_request(ihost, command);\n}\n\nstatic void sci_port_stopped_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_port *iport = container_of(sm, typeof(*iport), sm);\n\n\tif (iport->sm.previous_state_id == SCI_PORT_STOPPING) {\n\t\t \n\t\tsci_port_disable_port_task_scheduler(iport);\n\t}\n}\n\nstatic void sci_port_stopped_state_exit(struct sci_base_state_machine *sm)\n{\n\tstruct isci_port *iport = container_of(sm, typeof(*iport), sm);\n\n\t \n\tsci_port_enable_port_task_scheduler(iport);\n}\n\nstatic void sci_port_ready_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_port *iport = container_of(sm, typeof(*iport), sm);\n\tstruct isci_host *ihost = iport->owning_controller;\n\tu32 prev_state;\n\n\tprev_state = iport->sm.previous_state_id;\n\tif (prev_state  == SCI_PORT_RESETTING)\n\t\tisci_port_hard_reset_complete(iport, SCI_SUCCESS);\n\telse\n\t\tdev_dbg(&ihost->pdev->dev, \"%s: port%d !ready\\n\",\n\t\t\t__func__, iport->physical_port_index);\n\n\t \n\tsci_port_post_dummy_remote_node(iport);\n\n\t \n\tport_state_machine_change(iport,\n\t\t\t\t  SCI_PORT_SUB_WAITING);\n}\n\nstatic void sci_port_resetting_state_exit(struct sci_base_state_machine *sm)\n{\n\tstruct isci_port *iport = container_of(sm, typeof(*iport), sm);\n\n\tsci_del_timer(&iport->timer);\n}\n\nstatic void sci_port_stopping_state_exit(struct sci_base_state_machine *sm)\n{\n\tstruct isci_port *iport = container_of(sm, typeof(*iport), sm);\n\n\tsci_del_timer(&iport->timer);\n\n\tsci_port_destroy_dummy_resources(iport);\n}\n\nstatic void sci_port_failed_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_port *iport = container_of(sm, typeof(*iport), sm);\n\n\tisci_port_hard_reset_complete(iport, SCI_FAILURE_TIMEOUT);\n}\n\nvoid sci_port_set_hang_detection_timeout(struct isci_port *iport, u32 timeout)\n{\n\tint phy_index;\n\tu32 phy_mask = iport->active_phy_mask;\n\n\tif (timeout)\n\t\t++iport->hang_detect_users;\n\telse if (iport->hang_detect_users > 1)\n\t\t--iport->hang_detect_users;\n\telse\n\t\tiport->hang_detect_users = 0;\n\n\tif (timeout || (iport->hang_detect_users == 0)) {\n\t\tfor (phy_index = 0; phy_index < SCI_MAX_PHYS; phy_index++) {\n\t\t\tif ((phy_mask >> phy_index) & 1) {\n\t\t\t\twritel(timeout,\n\t\t\t\t       &iport->phy_table[phy_index]\n\t\t\t\t\t  ->link_layer_registers\n\t\t\t\t\t  ->link_layer_hang_detection_timeout);\n\t\t\t}\n\t\t}\n\t}\n}\n \n\nstatic const struct sci_base_state sci_port_state_table[] = {\n\t[SCI_PORT_STOPPED] = {\n\t\t.enter_state = sci_port_stopped_state_enter,\n\t\t.exit_state  = sci_port_stopped_state_exit\n\t},\n\t[SCI_PORT_STOPPING] = {\n\t\t.exit_state  = sci_port_stopping_state_exit\n\t},\n\t[SCI_PORT_READY] = {\n\t\t.enter_state = sci_port_ready_state_enter,\n\t},\n\t[SCI_PORT_SUB_WAITING] = {\n\t\t.enter_state = sci_port_ready_substate_waiting_enter,\n\t\t.exit_state  = scic_sds_port_ready_substate_waiting_exit,\n\t},\n\t[SCI_PORT_SUB_OPERATIONAL] = {\n\t\t.enter_state = sci_port_ready_substate_operational_enter,\n\t\t.exit_state  = sci_port_ready_substate_operational_exit\n\t},\n\t[SCI_PORT_SUB_CONFIGURING] = {\n\t\t.enter_state = sci_port_ready_substate_configuring_enter\n\t},\n\t[SCI_PORT_RESETTING] = {\n\t\t.exit_state  = sci_port_resetting_state_exit\n\t},\n\t[SCI_PORT_FAILED] = {\n\t\t.enter_state = sci_port_failed_state_enter,\n\t}\n};\n\nvoid sci_port_construct(struct isci_port *iport, u8 index,\n\t\t\t     struct isci_host *ihost)\n{\n\tsci_init_sm(&iport->sm, sci_port_state_table, SCI_PORT_STOPPED);\n\n\tiport->logical_port_index  = SCIC_SDS_DUMMY_PORT;\n\tiport->physical_port_index = index;\n\tiport->active_phy_mask     = 0;\n\tiport->enabled_phy_mask    = 0;\n\tiport->last_active_phy     = 0;\n\tiport->ready_exit\t   = false;\n\n\tiport->owning_controller = ihost;\n\n\tiport->started_request_count = 0;\n\tiport->assigned_device_count = 0;\n\tiport->hang_detect_users = 0;\n\n\tiport->reserved_rni = SCU_DUMMY_INDEX;\n\tiport->reserved_tag = SCI_CONTROLLER_INVALID_IO_TAG;\n\n\tsci_init_timer(&iport->timer, port_timeout);\n\n\tiport->port_task_scheduler_registers = NULL;\n\n\tfor (index = 0; index < SCI_MAX_PHYS; index++)\n\t\tiport->phy_table[index] = NULL;\n}\n\nvoid sci_port_broadcast_change_received(struct isci_port *iport, struct isci_phy *iphy)\n{\n\tstruct isci_host *ihost = iport->owning_controller;\n\n\t \n\tisci_port_bc_change_received(ihost, iport, iphy);\n}\n\nstatic void wait_port_reset(struct isci_host *ihost, struct isci_port *iport)\n{\n\twait_event(ihost->eventq, !test_bit(IPORT_RESET_PENDING, &iport->state));\n}\n\nint isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *iport,\n\t\t\t\t struct isci_phy *iphy)\n{\n\tunsigned long flags;\n\tenum sci_status status;\n\tint ret = TMF_RESP_FUNC_COMPLETE;\n\n\tdev_dbg(&ihost->pdev->dev, \"%s: iport = %p\\n\",\n\t\t__func__, iport);\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\tset_bit(IPORT_RESET_PENDING, &iport->state);\n\n\t#define ISCI_PORT_RESET_TIMEOUT SCIC_SDS_SIGNATURE_FIS_TIMEOUT\n\tstatus = sci_port_hard_reset(iport, ISCI_PORT_RESET_TIMEOUT);\n\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\tif (status == SCI_SUCCESS) {\n\t\twait_port_reset(ihost, iport);\n\n\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t\"%s: iport = %p; hard reset completion\\n\",\n\t\t\t__func__, iport);\n\n\t\tif (iport->hard_reset_status != SCI_SUCCESS) {\n\t\t\tret = TMF_RESP_FUNC_FAILED;\n\n\t\t\tdev_err(&ihost->pdev->dev,\n\t\t\t\t\"%s: iport = %p; hard reset failed (0x%x)\\n\",\n\t\t\t\t__func__, iport, iport->hard_reset_status);\n\t\t}\n\t} else {\n\t\tclear_bit(IPORT_RESET_PENDING, &iport->state);\n\t\twake_up(&ihost->eventq);\n\t\tret = TMF_RESP_FUNC_FAILED;\n\n\t\tdev_err(&ihost->pdev->dev,\n\t\t\t\"%s: iport = %p; sci_port_hard_reset call\"\n\t\t\t\" failed 0x%x\\n\",\n\t\t\t__func__, iport, status);\n\n\t}\n\treturn ret;\n}\n\nint isci_ata_check_ready(struct domain_device *dev)\n{\n\tstruct isci_port *iport = dev->port->lldd_port;\n\tstruct isci_host *ihost = dev_to_ihost(dev);\n\tstruct isci_remote_device *idev;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\tidev = isci_lookup_device(dev);\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\tif (!idev)\n\t\tgoto out;\n\n\tif (test_bit(IPORT_RESET_PENDING, &iport->state))\n\t\tgoto out;\n\n\trc = !!iport->active_phy_mask;\n out:\n\tisci_put_device(idev);\n\n\treturn rc;\n}\n\nvoid isci_port_deformed(struct asd_sas_phy *phy)\n{\n\tstruct isci_host *ihost = phy->ha->lldd_ha;\n\tstruct isci_port *iport = phy->port->lldd_port;\n\tunsigned long flags;\n\tint i;\n\n\t \n\tif (!iport)\n\t\treturn;\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\tfor (i = 0; i < SCI_MAX_PHYS; i++) {\n\t\tif (iport->active_phy_mask & 1 << i)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\tif (i >= SCI_MAX_PHYS)\n\t\tdev_dbg(&ihost->pdev->dev, \"%s: port: %ld\\n\",\n\t\t\t__func__, (long) (iport - &ihost->ports[0]));\n}\n\nvoid isci_port_formed(struct asd_sas_phy *phy)\n{\n\tstruct isci_host *ihost = phy->ha->lldd_ha;\n\tstruct isci_phy *iphy = to_iphy(phy);\n\tstruct asd_sas_port *port = phy->port;\n\tstruct isci_port *iport = NULL;\n\tunsigned long flags;\n\tint i;\n\n\t \n\twait_for_start(ihost);\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\tfor (i = 0; i < SCI_MAX_PORTS; i++) {\n\t\tiport = &ihost->ports[i];\n\t\tif (iport->active_phy_mask & 1 << iphy->phy_index)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\tif (i >= SCI_MAX_PORTS)\n\t\tiport = NULL;\n\n\tport->lldd_port = iport;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}