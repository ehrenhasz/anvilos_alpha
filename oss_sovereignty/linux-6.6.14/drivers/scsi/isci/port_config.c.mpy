{
  "module_name": "port_config.c",
  "hash_id": "c7f4055101ce87c67575f9c30ce036e4362e4cc9424178a3172283072f0badcb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/isci/port_config.c",
  "human_readable_source": " \n\n#include \"host.h\"\n\n#define SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT    (10)\n#define SCIC_SDS_APC_RECONFIGURATION_TIMEOUT    (10)\n#define SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION  (1000)\n\nenum SCIC_SDS_APC_ACTIVITY {\n\tSCIC_SDS_APC_SKIP_PHY,\n\tSCIC_SDS_APC_ADD_PHY,\n\tSCIC_SDS_APC_START_TIMER,\n\n\tSCIC_SDS_APC_ACTIVITY_MAX\n};\n\n \n\n \nstatic s32 sci_sas_address_compare(\n\tstruct sci_sas_address address_one,\n\tstruct sci_sas_address address_two)\n{\n\tif (address_one.high > address_two.high) {\n\t\treturn 1;\n\t} else if (address_one.high < address_two.high) {\n\t\treturn -1;\n\t} else if (address_one.low > address_two.low) {\n\t\treturn 1;\n\t} else if (address_one.low < address_two.low) {\n\t\treturn -1;\n\t}\n\n\t \n\treturn 0;\n}\n\n \nstatic struct isci_port *sci_port_configuration_agent_find_port(\n\tstruct isci_host *ihost,\n\tstruct isci_phy *iphy)\n{\n\tu8 i;\n\tstruct sci_sas_address port_sas_address;\n\tstruct sci_sas_address port_attached_device_address;\n\tstruct sci_sas_address phy_sas_address;\n\tstruct sci_sas_address phy_attached_device_address;\n\n\t \n\tsci_phy_get_sas_address(iphy, &phy_sas_address);\n\tsci_phy_get_attached_sas_address(iphy, &phy_attached_device_address);\n\n\tfor (i = 0; i < ihost->logical_port_entries; i++) {\n\t\tstruct isci_port *iport = &ihost->ports[i];\n\n\t\tsci_port_get_sas_address(iport, &port_sas_address);\n\t\tsci_port_get_attached_sas_address(iport, &port_attached_device_address);\n\n\t\tif (sci_sas_address_compare(port_sas_address, phy_sas_address) == 0 &&\n\t\t    sci_sas_address_compare(port_attached_device_address, phy_attached_device_address) == 0)\n\t\t\treturn iport;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic enum sci_status sci_port_configuration_agent_validate_ports(\n\tstruct isci_host *ihost,\n\tstruct sci_port_configuration_agent *port_agent)\n{\n\tstruct sci_sas_address first_address;\n\tstruct sci_sas_address second_address;\n\n\t \n\tif (port_agent->phy_valid_port_range[0].max_index != 0 ||\n\t    port_agent->phy_valid_port_range[1].max_index != 1 ||\n\t    port_agent->phy_valid_port_range[2].max_index != 2 ||\n\t    port_agent->phy_valid_port_range[3].max_index != 3)\n\t\treturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\n\n\t \n\tif (port_agent->phy_valid_port_range[0].min_index == 0 &&\n\t    port_agent->phy_valid_port_range[1].min_index == 0 &&\n\t    port_agent->phy_valid_port_range[2].min_index == 0 &&\n\t    port_agent->phy_valid_port_range[3].min_index == 0)\n\t\treturn SCI_SUCCESS;\n\n\t \n\tif (port_agent->phy_valid_port_range[2].min_index == 1) {\n\t\treturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\n\t}\n\n\t \n\tsci_phy_get_sas_address(&ihost->phys[0], &first_address);\n\tsci_phy_get_sas_address(&ihost->phys[3], &second_address);\n\n\tif (sci_sas_address_compare(first_address, second_address) == 0) {\n\t\treturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\n\t}\n\n\t \n\tif (port_agent->phy_valid_port_range[0].min_index == 0 &&\n\t    port_agent->phy_valid_port_range[1].min_index == 1) {\n\t\tsci_phy_get_sas_address(&ihost->phys[0], &first_address);\n\t\tsci_phy_get_sas_address(&ihost->phys[2], &second_address);\n\n\t\tif (sci_sas_address_compare(first_address, second_address) == 0) {\n\t\t\treturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\n\t\t}\n\t}\n\n\t \n\tif (port_agent->phy_valid_port_range[2].min_index == 2 &&\n\t    port_agent->phy_valid_port_range[3].min_index == 3) {\n\t\tsci_phy_get_sas_address(&ihost->phys[1], &first_address);\n\t\tsci_phy_get_sas_address(&ihost->phys[3], &second_address);\n\n\t\tif (sci_sas_address_compare(first_address, second_address) == 0) {\n\t\t\treturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\n\t\t}\n\t}\n\n\treturn SCI_SUCCESS;\n}\n\n \n\n \nstatic enum sci_status\nsci_mpc_agent_validate_phy_configuration(struct isci_host *ihost,\n\t\t\t\t\t      struct sci_port_configuration_agent *port_agent)\n{\n\tu32 phy_mask;\n\tu32 assigned_phy_mask;\n\tstruct sci_sas_address sas_address;\n\tstruct sci_sas_address phy_assigned_address;\n\tu8 port_index;\n\tu8 phy_index;\n\n\tassigned_phy_mask = 0;\n\tsas_address.high = 0;\n\tsas_address.low = 0;\n\n\tfor (port_index = 0; port_index < SCI_MAX_PORTS; port_index++) {\n\t\tphy_mask = ihost->oem_parameters.ports[port_index].phy_mask;\n\n\t\tif (!phy_mask)\n\t\t\tcontinue;\n\t\t \n\t\tif ((phy_mask & ~assigned_phy_mask) == 0) {\n\t\t\treturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\n\t\t}\n\n\t\t \n\t\tfor (phy_index = 0; phy_index < SCI_MAX_PHYS; phy_index++) {\n\t\t\tif ((phy_mask & (1 << phy_index)) == 0)\n\t\t\t\tcontinue;\n\t\t\tsci_phy_get_sas_address(&ihost->phys[phy_index],\n\t\t\t\t\t\t     &sas_address);\n\n\t\t\t \n\t\t\tport_agent->phy_valid_port_range[phy_index].min_index = port_index;\n\t\t\tport_agent->phy_valid_port_range[phy_index].max_index = phy_index;\n\n\t\t\tif (phy_index != port_index) {\n\t\t\t\treturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfor (; phy_index < SCI_MAX_PHYS; phy_index++) {\n\t\t\tif ((phy_mask & (1 << phy_index)) == 0)\n\t\t\t\tcontinue;\n\t\t\tsci_phy_get_sas_address(&ihost->phys[phy_index],\n\t\t\t\t\t\t     &phy_assigned_address);\n\n\t\t\tif (sci_sas_address_compare(sas_address, phy_assigned_address) != 0) {\n\t\t\t\t \n\t\t\t\treturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\n\t\t\t}\n\n\t\t\tport_agent->phy_valid_port_range[phy_index].min_index = port_index;\n\t\t\tport_agent->phy_valid_port_range[phy_index].max_index = phy_index;\n\n\t\t\tsci_port_add_phy(&ihost->ports[port_index],\n\t\t\t\t\t      &ihost->phys[phy_index]);\n\n\t\t\tassigned_phy_mask |= (1 << phy_index);\n\t\t}\n\n\t}\n\n\treturn sci_port_configuration_agent_validate_ports(ihost, port_agent);\n}\n\nstatic void mpc_agent_timeout(struct timer_list *t)\n{\n\tu8 index;\n\tstruct sci_timer *tmr = from_timer(tmr, t, timer);\n\tstruct sci_port_configuration_agent *port_agent;\n\tstruct isci_host *ihost;\n\tunsigned long flags;\n\tu16 configure_phy_mask;\n\n\tport_agent = container_of(tmr, typeof(*port_agent), timer);\n\tihost = container_of(port_agent, typeof(*ihost), port_agent);\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\n\tif (tmr->cancel)\n\t\tgoto done;\n\n\tport_agent->timer_pending = false;\n\n\t \n\tconfigure_phy_mask = ~port_agent->phy_configured_mask & port_agent->phy_ready_mask;\n\n\tfor (index = 0; index < SCI_MAX_PHYS; index++) {\n\t\tstruct isci_phy *iphy = &ihost->phys[index];\n\n\t\tif (configure_phy_mask & (1 << index)) {\n\t\t\tport_agent->link_up_handler(ihost, port_agent,\n\t\t\t\t\t\t    phy_get_non_dummy_port(iphy),\n\t\t\t\t\t\t    iphy);\n\t\t}\n\t}\n\ndone:\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n}\n\nstatic void sci_mpc_agent_link_up(struct isci_host *ihost,\n\t\t\t\t       struct sci_port_configuration_agent *port_agent,\n\t\t\t\t       struct isci_port *iport,\n\t\t\t\t       struct isci_phy *iphy)\n{\n\t \n\tif (!iport)\n\t\treturn;\n\n\tport_agent->phy_ready_mask |= (1 << iphy->phy_index);\n\tsci_port_link_up(iport, iphy);\n\tif ((iport->active_phy_mask & (1 << iphy->phy_index)))\n\t\tport_agent->phy_configured_mask |= (1 << iphy->phy_index);\n}\n\n \nstatic void sci_mpc_agent_link_down(\n\tstruct isci_host *ihost,\n\tstruct sci_port_configuration_agent *port_agent,\n\tstruct isci_port *iport,\n\tstruct isci_phy *iphy)\n{\n\tif (iport != NULL) {\n\t\t \n\t\tport_agent->phy_ready_mask &= ~(1 << iphy->phy_index);\n\t\tport_agent->phy_configured_mask &= ~(1 << iphy->phy_index);\n\n\t\t \n\t\tif ((port_agent->phy_configured_mask == 0x0000) &&\n\t\t    (port_agent->phy_ready_mask != 0x0000) &&\n\t\t    !port_agent->timer_pending) {\n\t\t\tport_agent->timer_pending = true;\n\n\t\t\tsci_mod_timer(&port_agent->timer,\n\t\t\t\t      SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT);\n\t\t}\n\n\t\tsci_port_link_down(iport, iphy);\n\t}\n}\n\n \nstatic enum sci_status\nsci_apc_agent_validate_phy_configuration(struct isci_host *ihost,\n\t\t\t\t\t      struct sci_port_configuration_agent *port_agent)\n{\n\tu8 phy_index;\n\tu8 port_index;\n\tstruct sci_sas_address sas_address;\n\tstruct sci_sas_address phy_assigned_address;\n\n\tphy_index = 0;\n\n\twhile (phy_index < SCI_MAX_PHYS) {\n\t\tport_index = phy_index;\n\n\t\t \n\t\tsci_phy_get_sas_address(&ihost->phys[phy_index],\n\t\t\t\t\t    &sas_address);\n\n\t\twhile (++phy_index < SCI_MAX_PHYS) {\n\t\t\tsci_phy_get_sas_address(&ihost->phys[phy_index],\n\t\t\t\t\t\t     &phy_assigned_address);\n\n\t\t\t \n\t\t\tif (sci_sas_address_compare(sas_address, phy_assigned_address) == 0) {\n\t\t\t\tport_agent->phy_valid_port_range[phy_index].min_index = port_index;\n\t\t\t\tport_agent->phy_valid_port_range[phy_index].max_index = phy_index;\n\t\t\t} else {\n\t\t\t\tport_agent->phy_valid_port_range[phy_index].min_index = phy_index;\n\t\t\t\tport_agent->phy_valid_port_range[phy_index].max_index = phy_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sci_port_configuration_agent_validate_ports(ihost, port_agent);\n}\n\n \nstatic void sci_apc_agent_start_timer(struct sci_port_configuration_agent *port_agent,\n\t\t\t\t      u32 timeout)\n{\n\tport_agent->timer_pending = true;\n\tsci_mod_timer(&port_agent->timer, timeout);\n}\n\nstatic void sci_apc_agent_configure_ports(struct isci_host *ihost,\n\t\t\t\t\t       struct sci_port_configuration_agent *port_agent,\n\t\t\t\t\t       struct isci_phy *iphy,\n\t\t\t\t\t       bool start_timer)\n{\n\tu8 port_index;\n\tenum sci_status status;\n\tstruct isci_port *iport;\n\tenum SCIC_SDS_APC_ACTIVITY apc_activity = SCIC_SDS_APC_SKIP_PHY;\n\n\tiport = sci_port_configuration_agent_find_port(ihost, iphy);\n\n\tif (iport) {\n\t\tif (sci_port_is_valid_phy_assignment(iport, iphy->phy_index))\n\t\t\tapc_activity = SCIC_SDS_APC_ADD_PHY;\n\t\telse\n\t\t\tapc_activity = SCIC_SDS_APC_SKIP_PHY;\n\t} else {\n\t\t \n\t\tfor (port_index = port_agent->phy_valid_port_range[iphy->phy_index].min_index;\n\t\t     port_index <= port_agent->phy_valid_port_range[iphy->phy_index].max_index;\n\t\t     port_index++) {\n\n\t\t\tiport = &ihost->ports[port_index];\n\n\t\t\t \n\t\t\tif (sci_port_is_valid_phy_assignment(iport, iphy->phy_index)) {\n\t\t\t\t \n\t\t\t\tif (iport->active_phy_mask > (1 << iphy->phy_index)) {\n\t\t\t\t\tapc_activity = SCIC_SDS_APC_SKIP_PHY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (iport->physical_port_index == iphy->phy_index) {\n\t\t\t\t\t \n\t\t\t\t\tif (apc_activity != SCIC_SDS_APC_START_TIMER) {\n\t\t\t\t\t\tapc_activity = SCIC_SDS_APC_ADD_PHY;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (iport->active_phy_mask == 0) {\n\t\t\t\t\tapc_activity = SCIC_SDS_APC_START_TIMER;\n\t\t\t\t}\n\t\t\t} else if (iport->active_phy_mask != 0) {\n\t\t\t\t \n\t\t\t\tapc_activity = SCIC_SDS_APC_SKIP_PHY;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (\n\t\t(start_timer == false)\n\t\t&& (apc_activity == SCIC_SDS_APC_START_TIMER)\n\t\t) {\n\t\tapc_activity = SCIC_SDS_APC_ADD_PHY;\n\t}\n\n\tswitch (apc_activity) {\n\tcase SCIC_SDS_APC_ADD_PHY:\n\t\tstatus = sci_port_add_phy(iport, iphy);\n\n\t\tif (status == SCI_SUCCESS) {\n\t\t\tport_agent->phy_configured_mask |= (1 << iphy->phy_index);\n\t\t}\n\t\tbreak;\n\n\tcase SCIC_SDS_APC_START_TIMER:\n\t\tsci_apc_agent_start_timer(port_agent,\n\t\t\t\t\t  SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION);\n\t\tbreak;\n\n\tcase SCIC_SDS_APC_SKIP_PHY:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\n \nstatic void sci_apc_agent_link_up(struct isci_host *ihost,\n\t\t\t\t       struct sci_port_configuration_agent *port_agent,\n\t\t\t\t       struct isci_port *iport,\n\t\t\t\t       struct isci_phy *iphy)\n{\n\tu8 phy_index  = iphy->phy_index;\n\n\tif (!iport) {\n\t\t \n\t\tport_agent->phy_ready_mask |= 1 << phy_index;\n\t\tsci_apc_agent_start_timer(port_agent,\n\t\t\t\t\t  SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION);\n\t} else {\n\t\t \n\t\tport_agent->phy_ready_mask |= 1 << phy_index;\n\t\tsci_port_link_up(iport, iphy);\n\t}\n}\n\n \nstatic void sci_apc_agent_link_down(\n\tstruct isci_host *ihost,\n\tstruct sci_port_configuration_agent *port_agent,\n\tstruct isci_port *iport,\n\tstruct isci_phy *iphy)\n{\n\tport_agent->phy_ready_mask &= ~(1 << iphy->phy_index);\n\n\tif (!iport)\n\t\treturn;\n\tif (port_agent->phy_configured_mask & (1 << iphy->phy_index)) {\n\t\tenum sci_status status;\n\n\t\tstatus = sci_port_remove_phy(iport, iphy);\n\n\t\tif (status == SCI_SUCCESS)\n\t\t\tport_agent->phy_configured_mask &= ~(1 << iphy->phy_index);\n\t}\n}\n\n \nstatic void apc_agent_timeout(struct timer_list *t)\n{\n\tu32 index;\n\tstruct sci_timer *tmr = from_timer(tmr, t, timer);\n\tstruct sci_port_configuration_agent *port_agent;\n\tstruct isci_host *ihost;\n\tunsigned long flags;\n\tu16 configure_phy_mask;\n\n\tport_agent = container_of(tmr, typeof(*port_agent), timer);\n\tihost = container_of(port_agent, typeof(*ihost), port_agent);\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\n\tif (tmr->cancel)\n\t\tgoto done;\n\n\tport_agent->timer_pending = false;\n\n\tconfigure_phy_mask = ~port_agent->phy_configured_mask & port_agent->phy_ready_mask;\n\n\tif (!configure_phy_mask)\n\t\tgoto done;\n\n\tfor (index = 0; index < SCI_MAX_PHYS; index++) {\n\t\tif ((configure_phy_mask & (1 << index)) == 0)\n\t\t\tcontinue;\n\n\t\tsci_apc_agent_configure_ports(ihost, port_agent,\n\t\t\t\t\t\t   &ihost->phys[index], false);\n\t}\n\n\tif (is_controller_start_complete(ihost))\n\t\tsci_controller_transition_to_ready(ihost, SCI_SUCCESS);\n\ndone:\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n}\n\n \n\n \nvoid sci_port_configuration_agent_construct(\n\tstruct sci_port_configuration_agent *port_agent)\n{\n\tu32 index;\n\n\tport_agent->phy_configured_mask = 0x00;\n\tport_agent->phy_ready_mask = 0x00;\n\n\tport_agent->link_up_handler = NULL;\n\tport_agent->link_down_handler = NULL;\n\n\tport_agent->timer_pending = false;\n\n\tfor (index = 0; index < SCI_MAX_PORTS; index++) {\n\t\tport_agent->phy_valid_port_range[index].min_index = 0;\n\t\tport_agent->phy_valid_port_range[index].max_index = 0;\n\t}\n}\n\nbool is_port_config_apc(struct isci_host *ihost)\n{\n\treturn ihost->port_agent.link_up_handler == sci_apc_agent_link_up;\n}\n\nenum sci_status sci_port_configuration_agent_initialize(\n\tstruct isci_host *ihost,\n\tstruct sci_port_configuration_agent *port_agent)\n{\n\tenum sci_status status;\n\tenum sci_port_configuration_mode mode;\n\n\tmode = ihost->oem_parameters.controller.mode_type;\n\n\tif (mode == SCIC_PORT_MANUAL_CONFIGURATION_MODE) {\n\t\tstatus = sci_mpc_agent_validate_phy_configuration(\n\t\t\t\tihost, port_agent);\n\n\t\tport_agent->link_up_handler = sci_mpc_agent_link_up;\n\t\tport_agent->link_down_handler = sci_mpc_agent_link_down;\n\n\t\tsci_init_timer(&port_agent->timer, mpc_agent_timeout);\n\t} else {\n\t\tstatus = sci_apc_agent_validate_phy_configuration(\n\t\t\t\tihost, port_agent);\n\n\t\tport_agent->link_up_handler = sci_apc_agent_link_up;\n\t\tport_agent->link_down_handler = sci_apc_agent_link_down;\n\n\t\tsci_init_timer(&port_agent->timer, apc_agent_timeout);\n\t}\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}