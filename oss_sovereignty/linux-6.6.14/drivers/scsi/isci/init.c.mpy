{
  "module_name": "init.c",
  "hash_id": "7b00dbbda66d7de06d195607ea91b19094a8e24c32e3d02190ad8cdb9b7458bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/isci/init.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/efi.h>\n#include <asm/string.h>\n#include <scsi/scsi_host.h>\n#include \"host.h\"\n#include \"isci.h\"\n#include \"task.h\"\n#include \"probe_roms.h\"\n\n#define MAJ 1\n#define MIN 2\n#define BUILD 0\n#define DRV_VERSION __stringify(MAJ) \".\" __stringify(MIN) \".\" \\\n\t__stringify(BUILD)\n\nMODULE_VERSION(DRV_VERSION);\n\nstatic struct scsi_transport_template *isci_transport_template;\n\nstatic const struct pci_device_id isci_id_table[] = {\n\t{ PCI_VDEVICE(INTEL, 0x1D61),},\n\t{ PCI_VDEVICE(INTEL, 0x1D63),},\n\t{ PCI_VDEVICE(INTEL, 0x1D65),},\n\t{ PCI_VDEVICE(INTEL, 0x1D67),},\n\t{ PCI_VDEVICE(INTEL, 0x1D69),},\n\t{ PCI_VDEVICE(INTEL, 0x1D6B),},\n\t{ PCI_VDEVICE(INTEL, 0x1D60),},\n\t{ PCI_VDEVICE(INTEL, 0x1D62),},\n\t{ PCI_VDEVICE(INTEL, 0x1D64),},\n\t{ PCI_VDEVICE(INTEL, 0x1D66),},\n\t{ PCI_VDEVICE(INTEL, 0x1D68),},\n\t{ PCI_VDEVICE(INTEL, 0x1D6A),},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, isci_id_table);\n\n \n\nunsigned char no_outbound_task_to = 2;\nmodule_param(no_outbound_task_to, byte, 0);\nMODULE_PARM_DESC(no_outbound_task_to, \"No Outbound Task Timeout (1us incr)\");\n\nu16 ssp_max_occ_to = 20;\nmodule_param(ssp_max_occ_to, ushort, 0);\nMODULE_PARM_DESC(ssp_max_occ_to, \"SSP Max occupancy timeout (100us incr)\");\n\nu16 stp_max_occ_to = 5;\nmodule_param(stp_max_occ_to, ushort, 0);\nMODULE_PARM_DESC(stp_max_occ_to, \"STP Max occupancy timeout (100us incr)\");\n\nu16 ssp_inactive_to = 5;\nmodule_param(ssp_inactive_to, ushort, 0);\nMODULE_PARM_DESC(ssp_inactive_to, \"SSP inactivity timeout (100us incr)\");\n\nu16 stp_inactive_to = 5;\nmodule_param(stp_inactive_to, ushort, 0);\nMODULE_PARM_DESC(stp_inactive_to, \"STP inactivity timeout (100us incr)\");\n\nunsigned char phy_gen = SCIC_SDS_PARM_GEN2_SPEED;\nmodule_param(phy_gen, byte, 0);\nMODULE_PARM_DESC(phy_gen, \"PHY generation (1: 1.5Gbps 2: 3.0Gbps 3: 6.0Gbps)\");\n\nunsigned char max_concurr_spinup;\nmodule_param(max_concurr_spinup, byte, 0);\nMODULE_PARM_DESC(max_concurr_spinup, \"Max concurrent device spinup\");\n\nuint cable_selection_override = CABLE_OVERRIDE_DISABLED;\nmodule_param(cable_selection_override, uint, 0);\n\nMODULE_PARM_DESC(cable_selection_override,\n\t\t \"This field indicates length of the SAS/SATA cable between \"\n\t\t \"host and device. If any bits > 15 are set (default) \"\n\t\t \"indicates \\\"use platform defaults\\\"\");\n\nstatic ssize_t isci_show_id(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = container_of(dev, typeof(*shost), shost_dev);\n\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\n\tstruct isci_host *ihost = container_of(sas_ha, typeof(*ihost), sas_ha);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", ihost->id);\n}\n\nstatic DEVICE_ATTR(isci_id, S_IRUGO, isci_show_id, NULL);\n\nstatic struct attribute *isci_host_attrs[] = {\n\t&dev_attr_isci_id.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(isci_host);\n\nstatic const struct scsi_host_template isci_sht = {\n\n\t.module\t\t\t\t= THIS_MODULE,\n\t.name\t\t\t\t= DRV_NAME,\n\t.proc_name\t\t\t= DRV_NAME,\n\t.queuecommand\t\t\t= sas_queuecommand,\n\t.dma_need_drain\t\t\t= ata_scsi_dma_need_drain,\n\t.target_alloc\t\t\t= sas_target_alloc,\n\t.slave_configure\t\t= sas_slave_configure,\n\t.scan_finished\t\t\t= isci_host_scan_finished,\n\t.scan_start\t\t\t= isci_host_start,\n\t.change_queue_depth\t\t= sas_change_queue_depth,\n\t.bios_param\t\t\t= sas_bios_param,\n\t.can_queue\t\t\t= ISCI_CAN_QUEUE_VAL,\n\t.this_id\t\t\t= -1,\n\t.sg_tablesize\t\t\t= SG_ALL,\n\t.max_sectors\t\t\t= SCSI_DEFAULT_MAX_SECTORS,\n\t.eh_abort_handler\t\t= sas_eh_abort_handler,\n\t.eh_device_reset_handler        = sas_eh_device_reset_handler,\n\t.eh_target_reset_handler        = sas_eh_target_reset_handler,\n\t.slave_alloc\t\t\t= sas_slave_alloc,\n\t.target_destroy\t\t\t= sas_target_destroy,\n\t.ioctl\t\t\t\t= sas_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t\t= sas_ioctl,\n#endif\n\t.shost_groups\t\t\t= isci_host_groups,\n\t.track_queue_depth\t\t= 1,\n};\n\nstatic struct sas_domain_function_template isci_transport_ops  = {\n\n\t \n\t.lldd_port_formed\t= isci_port_formed,\n\t.lldd_port_deformed\t= isci_port_deformed,\n\n\t \n\t.lldd_dev_found\t\t= isci_remote_device_found,\n\t.lldd_dev_gone\t\t= isci_remote_device_gone,\n\n\t.lldd_execute_task\t= isci_task_execute_task,\n\t \n\t.lldd_abort_task\t= isci_task_abort_task,\n\t.lldd_abort_task_set\t= isci_task_abort_task_set,\n\t.lldd_clear_task_set\t= isci_task_clear_task_set,\n\t.lldd_I_T_nexus_reset\t= isci_task_I_T_nexus_reset,\n\t.lldd_lu_reset\t\t= isci_task_lu_reset,\n\t.lldd_query_task\t= isci_task_query_task,\n\n\t \n\t.lldd_ata_check_ready\t= isci_ata_check_ready,\n\n\t \n\t.lldd_clear_nexus_port\t= isci_task_clear_nexus_port,\n\t.lldd_clear_nexus_ha\t= isci_task_clear_nexus_ha,\n\n\t \n\t.lldd_control_phy\t= isci_phy_control,\n\n\t \n\t.lldd_write_gpio\t= isci_gpio_write,\n};\n\n\n \n\n\n\n \nstatic int isci_register_sas_ha(struct isci_host *isci_host)\n{\n\tint i;\n\tstruct sas_ha_struct *sas_ha = &(isci_host->sas_ha);\n\tstruct asd_sas_phy **sas_phys;\n\tstruct asd_sas_port **sas_ports;\n\n\tsas_phys = devm_kcalloc(&isci_host->pdev->dev,\n\t\t\t\tSCI_MAX_PHYS, sizeof(void *),\n\t\t\t\tGFP_KERNEL);\n\tif (!sas_phys)\n\t\treturn -ENOMEM;\n\n\tsas_ports = devm_kcalloc(&isci_host->pdev->dev,\n\t\t\t\t SCI_MAX_PORTS, sizeof(void *),\n\t\t\t\t GFP_KERNEL);\n\tif (!sas_ports)\n\t\treturn -ENOMEM;\n\n\tsas_ha->sas_ha_name = DRV_NAME;\n\tsas_ha->sas_addr    = &isci_host->phys[0].sas_addr[0];\n\n\tfor (i = 0; i < SCI_MAX_PHYS; i++) {\n\t\tsas_phys[i] = &isci_host->phys[i].sas_phy;\n\t\tsas_ports[i] = &isci_host->sas_ports[i];\n\t}\n\n\tsas_ha->sas_phy  = sas_phys;\n\tsas_ha->sas_port = sas_ports;\n\tsas_ha->num_phys = SCI_MAX_PHYS;\n\n\tsas_ha->strict_wide_ports = 1;\n\n\treturn sas_register_ha(sas_ha);\n}\n\nstatic void isci_unregister(struct isci_host *isci_host)\n{\n\tstruct Scsi_Host *shost;\n\n\tif (!isci_host)\n\t\treturn;\n\n\tshost = to_shost(isci_host);\n\tsas_unregister_ha(&isci_host->sas_ha);\n\n\tsas_remove_host(shost);\n\tscsi_host_put(shost);\n}\n\nstatic int isci_pci_init(struct pci_dev *pdev)\n{\n\tint err, bar_num, bar_mask = 0;\n\tvoid __iomem * const *iomap;\n\n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed enable PCI device %s!\\n\",\n\t\t\tpci_name(pdev));\n\t\treturn err;\n\t}\n\n\tfor (bar_num = 0; bar_num < SCI_PCI_BAR_COUNT; bar_num++)\n\t\tbar_mask |= 1 << (bar_num * 2);\n\n\terr = pcim_iomap_regions(pdev, bar_mask, DRV_NAME);\n\tif (err)\n\t\treturn err;\n\n\tiomap = pcim_iomap_table(pdev);\n\tif (!iomap)\n\t\treturn -ENOMEM;\n\n\tpci_set_master(pdev);\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err)\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\treturn err;\n}\n\nstatic int num_controllers(struct pci_dev *pdev)\n{\n\t \n\tresource_size_t scu_bar_size = pci_resource_len(pdev, SCI_SCU_BAR*2);\n\tresource_size_t smu_bar_size = pci_resource_len(pdev, SCI_SMU_BAR*2);\n\n\tif (scu_bar_size >= SCI_SCU_BAR_SIZE*SCI_MAX_CONTROLLERS &&\n\t    smu_bar_size >= SCI_SMU_BAR_SIZE*SCI_MAX_CONTROLLERS)\n\t\treturn SCI_MAX_CONTROLLERS;\n\telse\n\t\treturn 1;\n}\n\nstatic int isci_setup_interrupts(struct pci_dev *pdev)\n{\n\tint err, i, num_msix;\n\tstruct isci_host *ihost;\n\tstruct isci_pci_info *pci_info = to_pci_info(pdev);\n\n\t \n\tnum_msix = num_controllers(pdev) * SCI_NUM_MSI_X_INT;\n\n\terr = pci_alloc_irq_vectors(pdev, num_msix, num_msix, PCI_IRQ_MSIX);\n\tif (err < 0)\n\t\tgoto intx;\n\n\tfor (i = 0; i < num_msix; i++) {\n\t\tint id = i / SCI_NUM_MSI_X_INT;\n\t\tirq_handler_t isr;\n\n\t\tihost = pci_info->hosts[id];\n\t\t \n\t\tif (i & 1)\n\t\t\tisr = isci_error_isr;\n\t\telse\n\t\t\tisr = isci_msix_isr;\n\n\t\terr = devm_request_irq(&pdev->dev, pci_irq_vector(pdev, i),\n\t\t\t\tisr, 0, DRV_NAME\"-msix\", ihost);\n\t\tif (!err)\n\t\t\tcontinue;\n\n\t\tdev_info(&pdev->dev, \"msix setup failed falling back to intx\\n\");\n\t\twhile (i--) {\n\t\t\tid = i / SCI_NUM_MSI_X_INT;\n\t\t\tihost = pci_info->hosts[id];\n\t\t\tdevm_free_irq(&pdev->dev, pci_irq_vector(pdev, i),\n\t\t\t\t\tihost);\n\t\t}\n\t\tpci_free_irq_vectors(pdev);\n\t\tgoto intx;\n\t}\n\treturn 0;\n\n intx:\n\tfor_each_isci_host(i, ihost, pdev) {\n\t\terr = devm_request_irq(&pdev->dev, pci_irq_vector(pdev, 0),\n\t\t\t\tisci_intx_isr, IRQF_SHARED, DRV_NAME\"-intx\",\n\t\t\t\tihost);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic void isci_user_parameters_get(struct sci_user_parameters *u)\n{\n\tint i;\n\n\tfor (i = 0; i < SCI_MAX_PHYS; i++) {\n\t\tstruct sci_phy_user_params *u_phy = &u->phys[i];\n\n\t\tu_phy->max_speed_generation = phy_gen;\n\n\t\t \n\t\tu_phy->align_insertion_frequency = 0x7f;\n\t\tu_phy->in_connection_align_insertion_frequency = 0xff;\n\t\tu_phy->notify_enable_spin_up_insertion_frequency = 0x33;\n\t}\n\n\tu->stp_inactivity_timeout = stp_inactive_to;\n\tu->ssp_inactivity_timeout = ssp_inactive_to;\n\tu->stp_max_occupancy_timeout = stp_max_occ_to;\n\tu->ssp_max_occupancy_timeout = ssp_max_occ_to;\n\tu->no_outbound_task_timeout = no_outbound_task_to;\n\tu->max_concurr_spinup = max_concurr_spinup;\n}\n\nstatic enum sci_status sci_user_parameters_set(struct isci_host *ihost,\n\t\t\t\t\t       struct sci_user_parameters *sci_parms)\n{\n\tu16 index;\n\n\t \n\tfor (index = 0; index < SCI_MAX_PHYS; index++) {\n\t\tstruct sci_phy_user_params *u;\n\n\t\tu = &sci_parms->phys[index];\n\n\t\tif (!((u->max_speed_generation <= SCIC_SDS_PARM_MAX_SPEED) &&\n\t\t      (u->max_speed_generation > SCIC_SDS_PARM_NO_SPEED)))\n\t\t\treturn SCI_FAILURE_INVALID_PARAMETER_VALUE;\n\n\t\tif ((u->in_connection_align_insertion_frequency < 3) ||\n\t\t    (u->align_insertion_frequency == 0) ||\n\t\t    (u->notify_enable_spin_up_insertion_frequency == 0))\n\t\t\treturn SCI_FAILURE_INVALID_PARAMETER_VALUE;\n\t}\n\n\tif ((sci_parms->stp_inactivity_timeout == 0) ||\n\t    (sci_parms->ssp_inactivity_timeout == 0) ||\n\t    (sci_parms->stp_max_occupancy_timeout == 0) ||\n\t    (sci_parms->ssp_max_occupancy_timeout == 0) ||\n\t    (sci_parms->no_outbound_task_timeout == 0))\n\t\treturn SCI_FAILURE_INVALID_PARAMETER_VALUE;\n\n\tmemcpy(&ihost->user_parameters, sci_parms, sizeof(*sci_parms));\n\n\treturn SCI_SUCCESS;\n}\n\nstatic void sci_oem_defaults(struct isci_host *ihost)\n{\n\t \n\tstruct sci_user_parameters *user = &ihost->user_parameters;\n\tstruct sci_oem_params *oem = &ihost->oem_parameters;\n\tint i;\n\n\t \n\toem->controller.mode_type = SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE;\n\n\t \n\toem->controller.max_concurr_spin_up = 1;\n\n\t \n\toem->controller.do_enable_ssc = false;\n\n\t \n\toem->controller.cable_selection_mask = 0;\n\n\t \n\tfor (i = 0; i < SCI_MAX_PORTS; i++)\n\t\toem->ports[i].phy_mask = 0;\n\n\t \n\tfor (i = 0; i < SCI_MAX_PHYS; i++) {\n\t\t \n\t\tuser->phys[i].max_speed_generation = SCIC_SDS_PARM_GEN2_SPEED;\n\n\t\t \n\t\tuser->phys[i].align_insertion_frequency = 0x7f;\n\t\tuser->phys[i].in_connection_align_insertion_frequency = 0xff;\n\t\tuser->phys[i].notify_enable_spin_up_insertion_frequency = 0x33;\n\n\t\t \n\t\toem->phys[i].sas_address.low = 0x1 + ihost->id;\n\t\toem->phys[i].sas_address.high = 0x5FCFFFFF;\n\t}\n\n\tuser->stp_inactivity_timeout = 5;\n\tuser->ssp_inactivity_timeout = 5;\n\tuser->stp_max_occupancy_timeout = 5;\n\tuser->ssp_max_occupancy_timeout = 20;\n\tuser->no_outbound_task_timeout = 2;\n}\n\nstatic struct isci_host *isci_host_alloc(struct pci_dev *pdev, int id)\n{\n\tstruct isci_orom *orom = to_pci_info(pdev)->orom;\n\tstruct sci_user_parameters sci_user_params;\n\tu8 oem_version = ISCI_ROM_VER_1_0;\n\tstruct isci_host *ihost;\n\tstruct Scsi_Host *shost;\n\tint err, i;\n\n\tihost = devm_kzalloc(&pdev->dev, sizeof(*ihost), GFP_KERNEL);\n\tif (!ihost)\n\t\treturn NULL;\n\n\tihost->pdev = pdev;\n\tihost->id = id;\n\tspin_lock_init(&ihost->scic_lock);\n\tinit_waitqueue_head(&ihost->eventq);\n\tihost->sas_ha.dev = &ihost->pdev->dev;\n\tihost->sas_ha.lldd_ha = ihost;\n\ttasklet_init(&ihost->completion_tasklet,\n\t\t     isci_host_completion_routine, (unsigned long)ihost);\n\n\t \n\t \n\tsci_oem_defaults(ihost);\n\tisci_user_parameters_get(&sci_user_params);\n\tif (sci_user_parameters_set(ihost, &sci_user_params)) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"%s: sci_user_parameters_set failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (orom) {\n\t\tif (id < 0 || id >= SCI_MAX_CONTROLLERS || id > orom->hdr.num_elements) {\n\t\t\tdev_warn(&pdev->dev, \"parsing firmware oem parameters failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tihost->oem_parameters = orom->ctrl[id];\n\t\toem_version = orom->hdr.version;\n\t}\n\n\t \n\tif (sci_oem_parameters_validate(&ihost->oem_parameters, oem_version)) {\n\t\tdev_warn(&pdev->dev, \"oem parameter validation failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < SCI_MAX_PORTS; i++) {\n\t\tstruct isci_port *iport = &ihost->ports[i];\n\n\t\tINIT_LIST_HEAD(&iport->remote_dev_list);\n\t\tiport->isci_host = ihost;\n\t}\n\n\tfor (i = 0; i < SCI_MAX_PHYS; i++)\n\t\tisci_phy_init(&ihost->phys[i], ihost, i);\n\n\tfor (i = 0; i < SCI_MAX_REMOTE_DEVICES; i++) {\n\t\tstruct isci_remote_device *idev = &ihost->devices[i];\n\n\t\tINIT_LIST_HEAD(&idev->node);\n\t}\n\n\tshost = scsi_host_alloc(&isci_sht, sizeof(void *));\n\tif (!shost)\n\t\treturn NULL;\n\n\tdev_info(&pdev->dev, \"%sSCU controller %d: phy 3-0 cables: \"\n\t\t \"{%s, %s, %s, %s}\\n\",\n\t\t (is_cable_select_overridden() ? \"* \" : \"\"), ihost->id,\n\t\t lookup_cable_names(decode_cable_selection(ihost, 3)),\n\t\t lookup_cable_names(decode_cable_selection(ihost, 2)),\n\t\t lookup_cable_names(decode_cable_selection(ihost, 1)),\n\t\t lookup_cable_names(decode_cable_selection(ihost, 0)));\n\n\terr = isci_host_init(ihost);\n\tif (err)\n\t\tgoto err_shost;\n\n\tSHOST_TO_SAS_HA(shost) = &ihost->sas_ha;\n\tihost->sas_ha.shost = shost;\n\tshost->transportt = isci_transport_template;\n\n\tshost->max_id = ~0;\n\tshost->max_lun = ~0;\n\tshost->max_cmd_len = MAX_COMMAND_SIZE;\n\n\t \n\tscsi_host_set_prot(shost,\n\t\t\t   SHOST_DIF_TYPE1_PROTECTION |\n\t\t\t   SHOST_DIF_TYPE2_PROTECTION |\n\t\t\t   SHOST_DIF_TYPE3_PROTECTION);\n\tscsi_host_set_guard(shost, SHOST_DIX_GUARD_CRC);\n\n\terr = scsi_add_host(shost, &pdev->dev);\n\tif (err)\n\t\tgoto err_shost;\n\n\terr = isci_register_sas_ha(ihost);\n\tif (err)\n\t\tgoto err_shost_remove;\n\n\treturn ihost;\n\n err_shost_remove:\n\tscsi_remove_host(shost);\n err_shost:\n\tscsi_host_put(shost);\n\n\treturn NULL;\n}\n\nstatic int isci_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct isci_pci_info *pci_info;\n\tint err, i;\n\tstruct isci_host *isci_host;\n\tconst struct firmware *fw = NULL;\n\tstruct isci_orom *orom = NULL;\n\tchar *source = \"(platform)\";\n\n\tdev_info(&pdev->dev, \"driver configured for rev: %d silicon\\n\",\n\t\t pdev->revision);\n\n\tpci_info = devm_kzalloc(&pdev->dev, sizeof(*pci_info), GFP_KERNEL);\n\tif (!pci_info)\n\t\treturn -ENOMEM;\n\tpci_set_drvdata(pdev, pci_info);\n\n\tif (efi_rt_services_supported(EFI_RT_SUPPORTED_GET_VARIABLE))\n\t\torom = isci_get_efi_var(pdev);\n\n\tif (!orom)\n\t\torom = isci_request_oprom(pdev);\n\n\tfor (i = 0; orom && i < num_controllers(pdev); i++) {\n\t\tif (sci_oem_parameters_validate(&orom->ctrl[i],\n\t\t\t\t\t\torom->hdr.version)) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"[%d]: invalid oem parameters detected, falling back to firmware\\n\", i);\n\t\t\torom = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!orom) {\n\t\tsource = \"(firmware)\";\n\t\torom = isci_request_firmware(pdev, fw);\n\t\tif (!orom) {\n\t\t\t \n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Loading user firmware failed, using default \"\n\t\t\t\t \"values\\n\");\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Default OEM configuration being used: 4 \"\n\t\t\t\t \"narrow ports, and default SAS Addresses\\n\");\n\t\t}\n\t}\n\n\tif (orom)\n\t\tdev_info(&pdev->dev,\n\t\t\t \"OEM SAS parameters (version: %u.%u) loaded %s\\n\",\n\t\t\t (orom->hdr.version & 0xf0) >> 4,\n\t\t\t (orom->hdr.version & 0xf), source);\n\n\tpci_info->orom = orom;\n\n\terr = isci_pci_init(pdev);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < num_controllers(pdev); i++) {\n\t\tstruct isci_host *h = isci_host_alloc(pdev, i);\n\n\t\tif (!h) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_host_alloc;\n\t\t}\n\t\tpci_info->hosts[i] = h;\n\t}\n\n\terr = isci_setup_interrupts(pdev);\n\tif (err)\n\t\tgoto err_host_alloc;\n\n\tfor_each_isci_host(i, isci_host, pdev)\n\t\tscsi_scan_host(to_shost(isci_host));\n\n\treturn 0;\n\n err_host_alloc:\n\tfor_each_isci_host(i, isci_host, pdev)\n\t\tisci_unregister(isci_host);\n\treturn err;\n}\n\nstatic void isci_pci_remove(struct pci_dev *pdev)\n{\n\tstruct isci_host *ihost;\n\tint i;\n\n\tfor_each_isci_host(i, ihost, pdev) {\n\t\twait_for_start(ihost);\n\t\tisci_unregister(ihost);\n\t\tisci_host_deinit(ihost);\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int isci_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct isci_host *ihost;\n\tint i;\n\n\tfor_each_isci_host(i, ihost, pdev) {\n\t\tsas_suspend_ha(&ihost->sas_ha);\n\t\tisci_host_deinit(ihost);\n\t}\n\n\treturn 0;\n}\n\nstatic int isci_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct isci_host *ihost;\n\tint i;\n\n\tfor_each_isci_host(i, ihost, pdev) {\n\t\tsas_prep_resume_ha(&ihost->sas_ha);\n\n\t\tisci_host_init(ihost);\n\t\tisci_host_start(ihost->sas_ha.shost);\n\t\twait_for_start(ihost);\n\n\t\tsas_resume_ha(&ihost->sas_ha);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(isci_pm_ops, isci_suspend, isci_resume);\n\nstatic struct pci_driver isci_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= isci_id_table,\n\t.probe\t\t= isci_pci_probe,\n\t.remove\t\t= isci_pci_remove,\n\t.driver.pm      = &isci_pm_ops,\n};\n\nstatic __init int isci_init(void)\n{\n\tint err;\n\n\tpr_info(\"%s: Intel(R) C600 SAS Controller Driver - version %s\\n\",\n\t\tDRV_NAME, DRV_VERSION);\n\n\tisci_transport_template = sas_domain_attach_transport(&isci_transport_ops);\n\tif (!isci_transport_template)\n\t\treturn -ENOMEM;\n\n\terr = pci_register_driver(&isci_pci_driver);\n\tif (err)\n\t\tsas_release_transport(isci_transport_template);\n\n\treturn err;\n}\n\nstatic __exit void isci_exit(void)\n{\n\tpci_unregister_driver(&isci_pci_driver);\n\tsas_release_transport(isci_transport_template);\n}\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_FIRMWARE(ISCI_FW_NAME);\nmodule_init(isci_init);\nmodule_exit(isci_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}