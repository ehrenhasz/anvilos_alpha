{
  "module_name": "port.h",
  "hash_id": "688b38dff616dbcff7452a34784204de0cfe4599d48c332fa4abaf7ad3d22557",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/isci/port.h",
  "human_readable_source": " \n\n#ifndef _ISCI_PORT_H_\n#define _ISCI_PORT_H_\n\n#include <scsi/libsas.h>\n#include \"isci.h\"\n#include \"sas.h\"\n#include \"phy.h\"\n\n#define SCIC_SDS_DUMMY_PORT   0xFF\n\n#define PF_NOTIFY (1 << 0)\n#define PF_RESUME (1 << 1)\n\nstruct isci_phy;\nstruct isci_host;\n\nenum isci_status {\n\tisci_freed        = 0x00,\n\tisci_starting     = 0x01,\n\tisci_ready        = 0x02,\n\tisci_ready_for_io = 0x03,\n\tisci_stopping     = 0x04,\n\tisci_stopped      = 0x05,\n};\n\n \nstruct isci_port {\n\tstruct isci_host *isci_host;\n\tstruct list_head remote_dev_list;\n\t#define IPORT_RESET_PENDING 0\n\tunsigned long state;\n\tenum sci_status hard_reset_status;\n\tstruct sci_base_state_machine sm;\n\tbool ready_exit;\n\tu8 logical_port_index;\n\tu8 physical_port_index;\n\tu8 active_phy_mask;\n\tu8 enabled_phy_mask;\n\tu8 last_active_phy;\n\tu16 reserved_rni;\n\tu16 reserved_tag;\n\tu32 started_request_count;\n\tu32 assigned_device_count;\n\tu32 hang_detect_users;\n\tu32 not_ready_reason;\n\tstruct isci_phy *phy_table[SCI_MAX_PHYS];\n\tstruct isci_host *owning_controller;\n\tstruct sci_timer timer;\n\tstruct scu_port_task_scheduler_registers __iomem *port_task_scheduler_registers;\n\t \n\tu32 __iomem *port_pe_configuration_register;\n\tstruct scu_viit_entry __iomem *viit_registers;\n};\n\nenum sci_port_not_ready_reason_code {\n\tSCIC_PORT_NOT_READY_NO_ACTIVE_PHYS,\n\tSCIC_PORT_NOT_READY_HARD_RESET_REQUESTED,\n\tSCIC_PORT_NOT_READY_INVALID_PORT_CONFIGURATION,\n\tSCIC_PORT_NOT_READY_RECONFIGURING,\n\n\tSCIC_PORT_NOT_READY_REASON_CODE_MAX\n};\n\nstruct sci_port_end_point_properties {\n\tstruct sci_sas_address sas_address;\n\tstruct sci_phy_proto protocols;\n};\n\nstruct sci_port_properties {\n\tu32 index;\n\tstruct sci_port_end_point_properties local;\n\tstruct sci_port_end_point_properties remote;\n\tu32 phy_mask;\n};\n\n \n#define PORT_STATES {\\\n\tC(PORT_STOPPED),\\\n\tC(PORT_STOPPING),\\\n\tC(PORT_READY),\\\n\tC(PORT_SUB_WAITING),\\\n\tC(PORT_SUB_OPERATIONAL),\\\n\tC(PORT_SUB_CONFIGURING),\\\n\tC(PORT_RESETTING),\\\n\tC(PORT_FAILED),\\\n\t}\n#undef C\n#define C(a) SCI_##a\nenum sci_port_states PORT_STATES;\n#undef C\n\nstatic inline void sci_port_decrement_request_count(struct isci_port *iport)\n{\n\tif (WARN_ONCE(iport->started_request_count == 0,\n\t\t       \"%s: tried to decrement started_request_count past 0!?\",\n\t\t\t__func__))\n\t\t ;\n\telse\n\t\tiport->started_request_count--;\n}\n\n#define sci_port_active_phy(port, phy) \\\n\t(((port)->active_phy_mask & (1 << (phy)->phy_index)) != 0)\n\nvoid sci_port_construct(\n\tstruct isci_port *iport,\n\tu8 port_index,\n\tstruct isci_host *ihost);\n\nenum sci_status sci_port_start(struct isci_port *iport);\nenum sci_status sci_port_stop(struct isci_port *iport);\n\nenum sci_status sci_port_add_phy(\n\tstruct isci_port *iport,\n\tstruct isci_phy *iphy);\n\nenum sci_status sci_port_remove_phy(\n\tstruct isci_port *iport,\n\tstruct isci_phy *iphy);\n\nvoid sci_port_setup_transports(\n\tstruct isci_port *iport,\n\tu32 device_id);\n\nvoid isci_port_bcn_enable(struct isci_host *, struct isci_port *);\n\nvoid sci_port_deactivate_phy(\n\tstruct isci_port *iport,\n\tstruct isci_phy *iphy,\n\tbool do_notify_user);\n\nbool sci_port_link_detected(\n\tstruct isci_port *iport,\n\tstruct isci_phy *iphy);\n\nenum sci_status sci_port_get_properties(\n\tstruct isci_port *iport,\n\tstruct sci_port_properties *prop);\n\nenum sci_status sci_port_link_up(struct isci_port *iport,\n\t\t\t\t      struct isci_phy *iphy);\nenum sci_status sci_port_link_down(struct isci_port *iport,\n\t\t\t\t\tstruct isci_phy *iphy);\n\nstruct isci_request;\nstruct isci_remote_device;\nenum sci_status sci_port_start_io(\n\tstruct isci_port *iport,\n\tstruct isci_remote_device *idev,\n\tstruct isci_request *ireq);\n\nenum sci_status sci_port_complete_io(\n\tstruct isci_port *iport,\n\tstruct isci_remote_device *idev,\n\tstruct isci_request *ireq);\n\nenum sas_linkrate sci_port_get_max_allowed_speed(\n\tstruct isci_port *iport);\n\nvoid sci_port_broadcast_change_received(\n\tstruct isci_port *iport,\n\tstruct isci_phy *iphy);\n\nbool sci_port_is_valid_phy_assignment(\n\tstruct isci_port *iport,\n\tu32 phy_index);\n\nvoid sci_port_get_sas_address(\n\tstruct isci_port *iport,\n\tstruct sci_sas_address *sas_address);\n\nvoid sci_port_get_attached_sas_address(\n\tstruct isci_port *iport,\n\tstruct sci_sas_address *sas_address);\n\nvoid sci_port_set_hang_detection_timeout(\n\tstruct isci_port *isci_port,\n\tu32 timeout);\n\nvoid isci_port_formed(struct asd_sas_phy *);\nvoid isci_port_deformed(struct asd_sas_phy *);\n\nint isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *iport,\n\t\t\t\t struct isci_phy *iphy);\nint isci_ata_check_ready(struct domain_device *dev);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}