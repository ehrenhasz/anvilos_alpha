{
  "module_name": "remote_node_context.c",
  "hash_id": "05bdab9f1a049edc36bcab8443bc74960a69306c30754ce515a8ce4d0b57cad1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/isci/remote_node_context.c",
  "human_readable_source": " \n#include <scsi/sas_ata.h>\n#include \"host.h\"\n#include \"isci.h\"\n#include \"remote_device.h\"\n#include \"remote_node_context.h\"\n#include \"scu_event_codes.h\"\n#include \"scu_task_context.h\"\n\n#undef C\n#define C(a) (#a)\nconst char *rnc_state_name(enum scis_sds_remote_node_context_states state)\n{\n\tstatic const char * const strings[] = RNC_STATES;\n\n\tif (state >= ARRAY_SIZE(strings))\n\t\treturn \"UNKNOWN\";\n\n\treturn strings[state];\n}\n#undef C\n\n \nbool sci_remote_node_context_is_ready(\n\tstruct sci_remote_node_context *sci_rnc)\n{\n\tu32 current_state = sci_rnc->sm.current_state_id;\n\n\tif (current_state == SCI_RNC_READY) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool sci_remote_node_context_is_suspended(struct sci_remote_node_context *sci_rnc)\n{\n\tu32 current_state = sci_rnc->sm.current_state_id;\n\n\tif (current_state == SCI_RNC_TX_RX_SUSPENDED)\n\t\treturn true;\n\treturn false;\n}\n\nstatic union scu_remote_node_context *sci_rnc_by_id(struct isci_host *ihost, u16 id)\n{\n\tif (id < ihost->remote_node_entries &&\n\t    ihost->device_table[id])\n\t\treturn &ihost->remote_node_context_table[id];\n\n\treturn NULL;\n}\n\nstatic void sci_remote_node_context_construct_buffer(struct sci_remote_node_context *sci_rnc)\n{\n\tstruct isci_remote_device *idev = rnc_to_dev(sci_rnc);\n\tstruct domain_device *dev = idev->domain_dev;\n\tint rni = sci_rnc->remote_node_index;\n\tunion scu_remote_node_context *rnc;\n\tstruct isci_host *ihost;\n\t__le64 sas_addr;\n\n\tihost = idev->owning_port->owning_controller;\n\trnc = sci_rnc_by_id(ihost, rni);\n\n\tmemset(rnc, 0, sizeof(union scu_remote_node_context)\n\t\t* sci_remote_device_node_count(idev));\n\n\trnc->ssp.remote_node_index = rni;\n\trnc->ssp.remote_node_port_width = idev->device_port_width;\n\trnc->ssp.logical_port_index = idev->owning_port->physical_port_index;\n\n\t \n\tsas_addr = cpu_to_le64(SAS_ADDR(dev->sas_addr));\n\trnc->ssp.remote_sas_address_hi = upper_32_bits(sas_addr);\n\trnc->ssp.remote_sas_address_lo = lower_32_bits(sas_addr);\n\n\trnc->ssp.nexus_loss_timer_enable = true;\n\trnc->ssp.check_bit               = false;\n\trnc->ssp.is_valid                = false;\n\trnc->ssp.is_remote_node_context  = true;\n\trnc->ssp.function_number         = 0;\n\n\trnc->ssp.arbitration_wait_time = 0;\n\n\tif (dev_is_sata(dev)) {\n\t\trnc->ssp.connection_occupancy_timeout =\n\t\t\tihost->user_parameters.stp_max_occupancy_timeout;\n\t\trnc->ssp.connection_inactivity_timeout =\n\t\t\tihost->user_parameters.stp_inactivity_timeout;\n\t} else {\n\t\trnc->ssp.connection_occupancy_timeout  =\n\t\t\tihost->user_parameters.ssp_max_occupancy_timeout;\n\t\trnc->ssp.connection_inactivity_timeout =\n\t\t\tihost->user_parameters.ssp_inactivity_timeout;\n\t}\n\n\trnc->ssp.initial_arbitration_wait_time = 0;\n\n\t \n\trnc->ssp.oaf_connection_rate = idev->connection_rate;\n\trnc->ssp.oaf_features = 0;\n\trnc->ssp.oaf_source_zone_group = 0;\n\trnc->ssp.oaf_more_compatibility_features = 0;\n}\n \nstatic void sci_remote_node_context_setup_to_resume(\n\tstruct sci_remote_node_context *sci_rnc,\n\tscics_sds_remote_node_context_callback callback,\n\tvoid *callback_parameter,\n\tenum sci_remote_node_context_destination_state dest_param)\n{\n\tif (sci_rnc->destination_state != RNC_DEST_FINAL) {\n\t\tsci_rnc->destination_state = dest_param;\n\t\tif (callback != NULL) {\n\t\t\tsci_rnc->user_callback = callback;\n\t\t\tsci_rnc->user_cookie   = callback_parameter;\n\t\t}\n\t}\n}\n\nstatic void sci_remote_node_context_setup_to_destroy(\n\tstruct sci_remote_node_context *sci_rnc,\n\tscics_sds_remote_node_context_callback callback,\n\tvoid *callback_parameter)\n{\n\tstruct isci_host *ihost = idev_to_ihost(rnc_to_dev(sci_rnc));\n\n\tsci_rnc->destination_state = RNC_DEST_FINAL;\n\tsci_rnc->user_callback     = callback;\n\tsci_rnc->user_cookie       = callback_parameter;\n\n\twake_up(&ihost->eventq);\n}\n\n \nstatic void sci_remote_node_context_notify_user(\n\tstruct sci_remote_node_context *rnc)\n{\n\tif (rnc->user_callback != NULL) {\n\t\t(*rnc->user_callback)(rnc->user_cookie);\n\n\t\trnc->user_callback = NULL;\n\t\trnc->user_cookie = NULL;\n\t}\n}\n\nstatic void sci_remote_node_context_continue_state_transitions(struct sci_remote_node_context *rnc)\n{\n\tswitch (rnc->destination_state) {\n\tcase RNC_DEST_READY:\n\tcase RNC_DEST_SUSPENDED_RESUME:\n\t\trnc->destination_state = RNC_DEST_READY;\n\t\tfallthrough;\n\tcase RNC_DEST_FINAL:\n\t\tsci_remote_node_context_resume(rnc, rnc->user_callback,\n\t\t\t\t\t       rnc->user_cookie);\n\t\tbreak;\n\tdefault:\n\t\trnc->destination_state = RNC_DEST_UNSPECIFIED;\n\t\tbreak;\n\t}\n}\n\nstatic void sci_remote_node_context_validate_context_buffer(struct sci_remote_node_context *sci_rnc)\n{\n\tunion scu_remote_node_context *rnc_buffer;\n\tstruct isci_remote_device *idev = rnc_to_dev(sci_rnc);\n\tstruct domain_device *dev = idev->domain_dev;\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\n\trnc_buffer = sci_rnc_by_id(ihost, sci_rnc->remote_node_index);\n\n\trnc_buffer->ssp.is_valid = true;\n\n\tif (dev_is_sata(dev) && dev->parent) {\n\t\tsci_remote_device_post_request(idev, SCU_CONTEXT_COMMAND_POST_RNC_96);\n\t} else {\n\t\tsci_remote_device_post_request(idev, SCU_CONTEXT_COMMAND_POST_RNC_32);\n\n\t\tif (!dev->parent)\n\t\t\tsci_port_setup_transports(idev->owning_port,\n\t\t\t\t\t\t  sci_rnc->remote_node_index);\n\t}\n}\n\nstatic void sci_remote_node_context_invalidate_context_buffer(struct sci_remote_node_context *sci_rnc)\n{\n\tunion scu_remote_node_context *rnc_buffer;\n\tstruct isci_remote_device *idev = rnc_to_dev(sci_rnc);\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\n\trnc_buffer = sci_rnc_by_id(ihost, sci_rnc->remote_node_index);\n\n\trnc_buffer->ssp.is_valid = false;\n\n\tsci_remote_device_post_request(rnc_to_dev(sci_rnc),\n\t\t\t\t       SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE);\n}\n\nstatic void sci_remote_node_context_initial_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);\n\tstruct isci_remote_device *idev = rnc_to_dev(rnc);\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\n\t \n\tif (sm->previous_state_id == SCI_RNC_INVALIDATING) {\n\t\trnc->destination_state = RNC_DEST_UNSPECIFIED;\n\t\tsci_remote_node_context_notify_user(rnc);\n\n\t\tsmp_wmb();\n\t\twake_up(&ihost->eventq);\n\t}\n}\n\nstatic void sci_remote_node_context_posting_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct sci_remote_node_context *sci_rnc = container_of(sm, typeof(*sci_rnc), sm);\n\n\tsci_remote_node_context_validate_context_buffer(sci_rnc);\n}\n\nstatic void sci_remote_node_context_invalidating_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);\n\n\t \n\tsci_remote_device_terminate_requests(rnc_to_dev(rnc));\n\tsci_remote_node_context_invalidate_context_buffer(rnc);\n}\n\nstatic void sci_remote_node_context_resuming_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);\n\tstruct isci_remote_device *idev;\n\tstruct domain_device *dev;\n\n\tidev = rnc_to_dev(rnc);\n\tdev = idev->domain_dev;\n\n\t \n\tif (dev_is_sata(dev) && !dev->parent)\n\t\tsci_port_setup_transports(idev->owning_port, rnc->remote_node_index);\n\n\tsci_remote_device_post_request(idev, SCU_CONTEXT_COMMAND_POST_RNC_RESUME);\n}\n\nstatic void sci_remote_node_context_ready_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);\n\tenum sci_remote_node_context_destination_state dest_select;\n\tint tell_user = 1;\n\n\tdest_select = rnc->destination_state;\n\trnc->destination_state = RNC_DEST_UNSPECIFIED;\n\n\tif ((dest_select == RNC_DEST_SUSPENDED) ||\n\t    (dest_select == RNC_DEST_SUSPENDED_RESUME)) {\n\t\tsci_remote_node_context_suspend(\n\t\t\trnc, rnc->suspend_reason,\n\t\t\tSCI_SOFTWARE_SUSPEND_EXPECTED_EVENT);\n\n\t\tif (dest_select == RNC_DEST_SUSPENDED_RESUME)\n\t\t\ttell_user = 0;   \n\t}\n\tif (tell_user)\n\t\tsci_remote_node_context_notify_user(rnc);\n}\n\nstatic void sci_remote_node_context_tx_suspended_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);\n\n\tsci_remote_node_context_continue_state_transitions(rnc);\n}\n\nstatic void sci_remote_node_context_tx_rx_suspended_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);\n\tstruct isci_remote_device *idev = rnc_to_dev(rnc);\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\tu32 new_count = rnc->suspend_count + 1;\n\n\tif (new_count == 0)\n\t\trnc->suspend_count = 1;\n\telse\n\t\trnc->suspend_count = new_count;\n\tsmp_wmb();\n\n\t \n\tsci_remote_device_abort_requests_pending_abort(idev);\n\n\twake_up(&ihost->eventq);\n\tsci_remote_node_context_continue_state_transitions(rnc);\n}\n\nstatic void sci_remote_node_context_await_suspend_state_exit(\n\tstruct sci_base_state_machine *sm)\n{\n\tstruct sci_remote_node_context *rnc\n\t\t= container_of(sm, typeof(*rnc), sm);\n\tstruct isci_remote_device *idev = rnc_to_dev(rnc);\n\n\tif (dev_is_sata(idev->domain_dev))\n\t\tisci_dev_set_hang_detection_timeout(idev, 0);\n}\n\nstatic const struct sci_base_state sci_remote_node_context_state_table[] = {\n\t[SCI_RNC_INITIAL] = {\n\t\t.enter_state = sci_remote_node_context_initial_state_enter,\n\t},\n\t[SCI_RNC_POSTING] = {\n\t\t.enter_state = sci_remote_node_context_posting_state_enter,\n\t},\n\t[SCI_RNC_INVALIDATING] = {\n\t\t.enter_state = sci_remote_node_context_invalidating_state_enter,\n\t},\n\t[SCI_RNC_RESUMING] = {\n\t\t.enter_state = sci_remote_node_context_resuming_state_enter,\n\t},\n\t[SCI_RNC_READY] = {\n\t\t.enter_state = sci_remote_node_context_ready_state_enter,\n\t},\n\t[SCI_RNC_TX_SUSPENDED] = {\n\t\t.enter_state = sci_remote_node_context_tx_suspended_state_enter,\n\t},\n\t[SCI_RNC_TX_RX_SUSPENDED] = {\n\t\t.enter_state = sci_remote_node_context_tx_rx_suspended_state_enter,\n\t},\n\t[SCI_RNC_AWAIT_SUSPENSION] = {\n\t\t.exit_state = sci_remote_node_context_await_suspend_state_exit,\n\t},\n};\n\nvoid sci_remote_node_context_construct(struct sci_remote_node_context *rnc,\n\t\t\t\t\t    u16 remote_node_index)\n{\n\tmemset(rnc, 0, sizeof(struct sci_remote_node_context));\n\n\trnc->remote_node_index = remote_node_index;\n\trnc->destination_state = RNC_DEST_UNSPECIFIED;\n\n\tsci_init_sm(&rnc->sm, sci_remote_node_context_state_table, SCI_RNC_INITIAL);\n}\n\nenum sci_status sci_remote_node_context_event_handler(struct sci_remote_node_context *sci_rnc,\n\t\t\t\t\t\t\t   u32 event_code)\n{\n\tenum scis_sds_remote_node_context_states state;\n\tu32 next_state;\n\n\tstate = sci_rnc->sm.current_state_id;\n\tswitch (state) {\n\tcase SCI_RNC_POSTING:\n\t\tswitch (scu_get_event_code(event_code)) {\n\t\tcase SCU_EVENT_POST_RNC_COMPLETE:\n\t\t\tsci_change_state(&sci_rnc->sm, SCI_RNC_READY);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase SCI_RNC_INVALIDATING:\n\t\tif (scu_get_event_code(event_code) == SCU_EVENT_POST_RNC_INVALIDATE_COMPLETE) {\n\t\t\tif (sci_rnc->destination_state == RNC_DEST_FINAL)\n\t\t\t\tnext_state = SCI_RNC_INITIAL;\n\t\t\telse\n\t\t\t\tnext_state = SCI_RNC_POSTING;\n\t\t\tsci_change_state(&sci_rnc->sm, next_state);\n\t\t} else {\n\t\t\tswitch (scu_get_event_type(event_code)) {\n\t\t\tcase SCU_EVENT_TYPE_RNC_SUSPEND_TX:\n\t\t\tcase SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:\n\t\t\t\t \n\t\t\t\tdev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),\n\t\t\t\t\t\"%s: SCIC Remote Node Context 0x%p was \"\n\t\t\t\t\t\"suspended by hardware while being \"\n\t\t\t\t\t\"invalidated.\\n\", __func__, sci_rnc);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SCI_RNC_RESUMING:\n\t\tif (scu_get_event_code(event_code) == SCU_EVENT_POST_RCN_RELEASE) {\n\t\t\tsci_change_state(&sci_rnc->sm, SCI_RNC_READY);\n\t\t} else {\n\t\t\tswitch (scu_get_event_type(event_code)) {\n\t\t\tcase SCU_EVENT_TYPE_RNC_SUSPEND_TX:\n\t\t\tcase SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:\n\t\t\t\t \n\t\t\t\tdev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),\n\t\t\t\t\t\"%s: SCIC Remote Node Context 0x%p was \"\n\t\t\t\t\t\"suspended by hardware while being resumed.\\n\",\n\t\t\t\t\t__func__, sci_rnc);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SCI_RNC_READY:\n\t\tswitch (scu_get_event_type(event_code)) {\n\t\tcase SCU_EVENT_TL_RNC_SUSPEND_TX:\n\t\t\tsci_change_state(&sci_rnc->sm, SCI_RNC_TX_SUSPENDED);\n\t\t\tsci_rnc->suspend_type = scu_get_event_type(event_code);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_TL_RNC_SUSPEND_TX_RX:\n\t\t\tsci_change_state(&sci_rnc->sm, SCI_RNC_TX_RX_SUSPENDED);\n\t\t\tsci_rnc->suspend_type = scu_get_event_type(event_code);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase SCI_RNC_AWAIT_SUSPENSION:\n\t\tswitch (scu_get_event_type(event_code)) {\n\t\tcase SCU_EVENT_TL_RNC_SUSPEND_TX:\n\t\t\tnext_state = SCI_RNC_TX_SUSPENDED;\n\t\t\tbreak;\n\t\tcase SCU_EVENT_TL_RNC_SUSPEND_TX_RX:\n\t\t\tnext_state = SCI_RNC_TX_RX_SUSPENDED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\tif (sci_rnc->suspend_type == scu_get_event_type(event_code))\n\t\t\tsci_change_state(&sci_rnc->sm, next_state);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),\n\t\t\t \"%s: invalid state: %s\\n\", __func__,\n\t\t\t rnc_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n\treturn SCI_SUCCESS;\n\n out:\n\tdev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),\n\t\t \"%s: code: %#x state: %s\\n\", __func__, event_code,\n\t\t rnc_state_name(state));\n\treturn SCI_FAILURE;\n\n}\n\nenum sci_status sci_remote_node_context_destruct(struct sci_remote_node_context *sci_rnc,\n\t\t\t\t\t\t      scics_sds_remote_node_context_callback cb_fn,\n\t\t\t\t\t\t      void *cb_p)\n{\n\tenum scis_sds_remote_node_context_states state;\n\n\tstate = sci_rnc->sm.current_state_id;\n\tswitch (state) {\n\tcase SCI_RNC_INVALIDATING:\n\t\tsci_remote_node_context_setup_to_destroy(sci_rnc, cb_fn, cb_p);\n\t\treturn SCI_SUCCESS;\n\tcase SCI_RNC_POSTING:\n\tcase SCI_RNC_RESUMING:\n\tcase SCI_RNC_READY:\n\tcase SCI_RNC_TX_SUSPENDED:\n\tcase SCI_RNC_TX_RX_SUSPENDED:\n\t\tsci_remote_node_context_setup_to_destroy(sci_rnc, cb_fn, cb_p);\n\t\tsci_change_state(&sci_rnc->sm, SCI_RNC_INVALIDATING);\n\t\treturn SCI_SUCCESS;\n\tcase SCI_RNC_AWAIT_SUSPENSION:\n\t\tsci_remote_node_context_setup_to_destroy(sci_rnc, cb_fn, cb_p);\n\t\treturn SCI_SUCCESS;\n\tcase SCI_RNC_INITIAL:\n\t\tdev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),\n\t\t\t \"%s: invalid state: %s\\n\", __func__,\n\t\t\t rnc_state_name(state));\n\t\t \n\t\treturn SCI_SUCCESS;\n\tdefault:\n\t\tdev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),\n\t\t\t \"%s: invalid state %s\\n\", __func__,\n\t\t\t rnc_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n}\n\nenum sci_status sci_remote_node_context_suspend(\n\t\t\tstruct sci_remote_node_context *sci_rnc,\n\t\t\tenum sci_remote_node_suspension_reasons suspend_reason,\n\t\t\tu32 suspend_type)\n{\n\tenum scis_sds_remote_node_context_states state\n\t\t= sci_rnc->sm.current_state_id;\n\tstruct isci_remote_device *idev = rnc_to_dev(sci_rnc);\n\tenum sci_status status = SCI_FAILURE_INVALID_STATE;\n\tenum sci_remote_node_context_destination_state dest_param =\n\t\tRNC_DEST_UNSPECIFIED;\n\n\tdev_dbg(scirdev_to_dev(idev),\n\t\t\"%s: current state %s, current suspend_type %x dest state %d,\"\n\t\t\t\" arg suspend_reason %d, arg suspend_type %x\",\n\t\t__func__, rnc_state_name(state), sci_rnc->suspend_type,\n\t\tsci_rnc->destination_state, suspend_reason,\n\t\tsuspend_type);\n\n\t \n\tif ((suspend_reason == SCI_HW_SUSPEND) ||\n\t    (sci_rnc->destination_state == RNC_DEST_FINAL))\n\t\tdest_param = sci_rnc->destination_state;\n\n\tswitch (state) {\n\tcase SCI_RNC_READY:\n\t\tbreak;\n\tcase SCI_RNC_INVALIDATING:\n\t\tif (sci_rnc->destination_state == RNC_DEST_FINAL) {\n\t\t\tdev_warn(scirdev_to_dev(idev),\n\t\t\t\t \"%s: already destroying %p\\n\",\n\t\t\t\t __func__, sci_rnc);\n\t\t\treturn SCI_FAILURE_INVALID_STATE;\n\t\t}\n\t\tfallthrough;\t \n\tcase SCI_RNC_RESUMING:\n\t\tfallthrough;\t \n\tcase SCI_RNC_POSTING:\n\t\t \n\t\tif (sci_rnc->destination_state != RNC_DEST_FINAL)\n\t\t\tsci_rnc->destination_state = RNC_DEST_SUSPENDED;\n\t\tsci_rnc->suspend_type = suspend_type;\n\t\tsci_rnc->suspend_reason = suspend_reason;\n\t\treturn SCI_SUCCESS;\n\n\tcase SCI_RNC_TX_SUSPENDED:\n\t\tif (suspend_type == SCU_EVENT_TL_RNC_SUSPEND_TX)\n\t\t\tstatus = SCI_SUCCESS;\n\t\tbreak;\n\tcase SCI_RNC_TX_RX_SUSPENDED:\n\t\tif (suspend_type == SCU_EVENT_TL_RNC_SUSPEND_TX_RX)\n\t\t\tstatus = SCI_SUCCESS;\n\t\tbreak;\n\tcase SCI_RNC_AWAIT_SUSPENSION:\n\t\tif ((sci_rnc->suspend_type == SCU_EVENT_TL_RNC_SUSPEND_TX_RX)\n\t\t    || (suspend_type == sci_rnc->suspend_type))\n\t\t\treturn SCI_SUCCESS;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),\n\t\t\t \"%s: invalid state %s\\n\", __func__,\n\t\t\t rnc_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n\tsci_rnc->destination_state = dest_param;\n\tsci_rnc->suspend_type = suspend_type;\n\tsci_rnc->suspend_reason = suspend_reason;\n\n\tif (status == SCI_SUCCESS) {  \n\t\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\n\t\twake_up_all(&ihost->eventq);  \n\t\treturn SCI_SUCCESS;\n\t}\n\tif ((suspend_reason == SCI_SW_SUSPEND_NORMAL) ||\n\t    (suspend_reason == SCI_SW_SUSPEND_LINKHANG_DETECT)) {\n\n\t\tif (suspend_reason == SCI_SW_SUSPEND_LINKHANG_DETECT)\n\t\t\tisci_dev_set_hang_detection_timeout(idev, 0x00000001);\n\n\t\tsci_remote_device_post_request(\n\t\t\tidev, SCI_SOFTWARE_SUSPEND_CMD);\n\t}\n\tif (state != SCI_RNC_AWAIT_SUSPENSION)\n\t\tsci_change_state(&sci_rnc->sm, SCI_RNC_AWAIT_SUSPENSION);\n\n\treturn SCI_SUCCESS;\n}\n\nenum sci_status sci_remote_node_context_resume(struct sci_remote_node_context *sci_rnc,\n\t\t\t\t\t\t    scics_sds_remote_node_context_callback cb_fn,\n\t\t\t\t\t\t    void *cb_p)\n{\n\tenum scis_sds_remote_node_context_states state;\n\tstruct isci_remote_device *idev = rnc_to_dev(sci_rnc);\n\n\tstate = sci_rnc->sm.current_state_id;\n\tdev_dbg(scirdev_to_dev(idev),\n\t\t\"%s: state %s, cb_fn = %p, cb_p = %p; dest_state = %d; \"\n\t\t\t\"dev resume path %s\\n\",\n\t\t__func__, rnc_state_name(state), cb_fn, cb_p,\n\t\tsci_rnc->destination_state,\n\t\ttest_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags)\n\t\t\t? \"<abort active>\" : \"<normal>\");\n\n\tswitch (state) {\n\tcase SCI_RNC_INITIAL:\n\t\tif (sci_rnc->remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX)\n\t\t\treturn SCI_FAILURE_INVALID_STATE;\n\n\t\tsci_remote_node_context_setup_to_resume(sci_rnc, cb_fn,\tcb_p,\n\t\t\t\t\t\t\tRNC_DEST_READY);\n\t\tif (!test_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags)) {\n\t\t\tsci_remote_node_context_construct_buffer(sci_rnc);\n\t\t\tsci_change_state(&sci_rnc->sm, SCI_RNC_POSTING);\n\t\t}\n\t\treturn SCI_SUCCESS;\n\n\tcase SCI_RNC_POSTING:\n\tcase SCI_RNC_INVALIDATING:\n\tcase SCI_RNC_RESUMING:\n\t\t \n\t\tswitch (sci_rnc->destination_state) {\n\t\tcase RNC_DEST_SUSPENDED:\n\t\tcase RNC_DEST_SUSPENDED_RESUME:\n\t\t\t \n\t\t\tsci_remote_node_context_setup_to_resume(\n\t\t\t\tsci_rnc, cb_fn, cb_p,\n\t\t\t\tRNC_DEST_SUSPENDED_RESUME);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsci_remote_node_context_setup_to_resume(\n\t\t\t\tsci_rnc, cb_fn, cb_p,\n\t\t\t\tRNC_DEST_READY);\n\t\t\tbreak;\n\t\t}\n\t\treturn SCI_SUCCESS;\n\n\tcase SCI_RNC_TX_SUSPENDED:\n\tcase SCI_RNC_TX_RX_SUSPENDED:\n\t\t{\n\t\t\tstruct domain_device *dev = idev->domain_dev;\n\t\t\t \n\t\t\tsci_remote_node_context_setup_to_resume(\n\t\t\t\tsci_rnc, cb_fn, cb_p, RNC_DEST_READY);\n\n\t\t\tif (!test_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags)) {\n\t\t\t\tif ((dev_is_sata(dev) && dev->parent) ||\n\t\t\t\t    (sci_rnc->destination_state == RNC_DEST_FINAL))\n\t\t\t\t\tsci_change_state(&sci_rnc->sm,\n\t\t\t\t\t\t\t SCI_RNC_INVALIDATING);\n\t\t\t\telse\n\t\t\t\t\tsci_change_state(&sci_rnc->sm,\n\t\t\t\t\t\t\t SCI_RNC_RESUMING);\n\t\t\t}\n\t\t}\n\t\treturn SCI_SUCCESS;\n\n\tcase SCI_RNC_AWAIT_SUSPENSION:\n\t\tsci_remote_node_context_setup_to_resume(\n\t\t\tsci_rnc, cb_fn, cb_p, RNC_DEST_SUSPENDED_RESUME);\n\t\treturn SCI_SUCCESS;\n\tdefault:\n\t\tdev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),\n\t\t\t \"%s: invalid state %s\\n\", __func__,\n\t\t\t rnc_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n}\n\nenum sci_status sci_remote_node_context_start_io(struct sci_remote_node_context *sci_rnc,\n\t\t\t\t\t\t\t     struct isci_request *ireq)\n{\n\tenum scis_sds_remote_node_context_states state;\n\n\tstate = sci_rnc->sm.current_state_id;\n\n\tswitch (state) {\n\tcase SCI_RNC_READY:\n\t\treturn SCI_SUCCESS;\n\tcase SCI_RNC_TX_SUSPENDED:\n\tcase SCI_RNC_TX_RX_SUSPENDED:\n\tcase SCI_RNC_AWAIT_SUSPENSION:\n\t\tdev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),\n\t\t\t \"%s: invalid state %s\\n\", __func__,\n\t\t\t rnc_state_name(state));\n\t\treturn SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;\n\tdefault:\n\t\tdev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),\n\t\t\t\"%s: invalid state %s\\n\", __func__,\n\t\t\trnc_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n}\n\nenum sci_status sci_remote_node_context_start_task(\n\tstruct sci_remote_node_context *sci_rnc,\n\tstruct isci_request *ireq,\n\tscics_sds_remote_node_context_callback cb_fn,\n\tvoid *cb_p)\n{\n\tenum sci_status status = sci_remote_node_context_resume(sci_rnc,\n\t\t\t\t\t\t\t\tcb_fn, cb_p);\n\tif (status != SCI_SUCCESS)\n\t\tdev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),\n\t\t\t\"%s: resume failed: %d\\n\", __func__, status);\n\treturn status;\n}\n\nint sci_remote_node_context_is_safe_to_abort(\n\tstruct sci_remote_node_context *sci_rnc)\n{\n\tenum scis_sds_remote_node_context_states state;\n\n\tstate = sci_rnc->sm.current_state_id;\n\tswitch (state) {\n\tcase SCI_RNC_INVALIDATING:\n\tcase SCI_RNC_TX_RX_SUSPENDED:\n\t\treturn 1;\n\tcase SCI_RNC_POSTING:\n\tcase SCI_RNC_RESUMING:\n\tcase SCI_RNC_READY:\n\tcase SCI_RNC_TX_SUSPENDED:\n\tcase SCI_RNC_AWAIT_SUSPENSION:\n\tcase SCI_RNC_INITIAL:\n\t\treturn 0;\n\tdefault:\n\t\tdev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),\n\t\t\t \"%s: invalid state %d\\n\", __func__, state);\n\t\treturn 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}