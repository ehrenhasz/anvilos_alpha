{
  "module_name": "isci.h",
  "hash_id": "5c41d759189c2612b6e1516cd6d0a3bac33424b7f6cdb449acb88ab2483676b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/isci/isci.h",
  "human_readable_source": " \n\n#ifndef __ISCI_H__\n#define __ISCI_H__\n\n#include <linux/interrupt.h>\n#include <linux/types.h>\n\n#define DRV_NAME \"isci\"\n#define SCI_PCI_BAR_COUNT 2\n#define SCI_NUM_MSI_X_INT 2\n#define SCI_SMU_BAR       0\n#define SCI_SMU_BAR_SIZE  (16*1024)\n#define SCI_SCU_BAR       1\n#define SCI_SCU_BAR_SIZE  (4*1024*1024)\n#define SCI_IO_SPACE_BAR0 2\n#define SCI_IO_SPACE_BAR1 3\n#define ISCI_CAN_QUEUE_VAL 250  \n#define SCIC_CONTROLLER_STOP_TIMEOUT 5000\n\n#define SCI_CONTROLLER_INVALID_IO_TAG 0xFFFF\n\n#define SCI_MAX_PHYS  (4UL)\n#define SCI_MAX_PORTS SCI_MAX_PHYS\n#define SCI_MAX_SMP_PHYS  (384)  \n#define SCI_MAX_REMOTE_DEVICES (256UL)\n#define SCI_MAX_IO_REQUESTS (256UL)\n#define SCI_MAX_SEQ (16)\n#define SCI_MAX_MSIX_MESSAGES  (2)\n#define SCI_MAX_SCATTER_GATHER_ELEMENTS 130  \n#define SCI_MAX_CONTROLLERS 2\n#define SCI_MAX_DOMAINS  SCI_MAX_PORTS\n\n#define SCU_MAX_CRITICAL_NOTIFICATIONS    (384)\n#define SCU_MAX_EVENTS_SHIFT\t\t  (7)\n#define SCU_MAX_EVENTS                    (1 << SCU_MAX_EVENTS_SHIFT)\n#define SCU_MAX_UNSOLICITED_FRAMES        (128)\n#define SCU_MAX_COMPLETION_QUEUE_SCRATCH  (128)\n#define SCU_MAX_COMPLETION_QUEUE_ENTRIES  (SCU_MAX_CRITICAL_NOTIFICATIONS \\\n\t\t\t\t\t   + SCU_MAX_EVENTS \\\n\t\t\t\t\t   + SCU_MAX_UNSOLICITED_FRAMES\t\\\n\t\t\t\t\t   + SCI_MAX_IO_REQUESTS \\\n\t\t\t\t\t   + SCU_MAX_COMPLETION_QUEUE_SCRATCH)\n#define SCU_MAX_COMPLETION_QUEUE_SHIFT\t  (ilog2(SCU_MAX_COMPLETION_QUEUE_ENTRIES))\n\n#define SCU_ABSOLUTE_MAX_UNSOLICITED_FRAMES (4096)\n#define SCU_UNSOLICITED_FRAME_BUFFER_SIZE   (1024U)\n#define SCU_INVALID_FRAME_INDEX             (0xFFFF)\n\n#define SCU_IO_REQUEST_MAX_SGE_SIZE         (0x00FFFFFF)\n#define SCU_IO_REQUEST_MAX_TRANSFER_LENGTH  (0x00FFFFFF)\n\nstatic inline void check_sizes(void)\n{\n\tBUILD_BUG_ON_NOT_POWER_OF_2(SCU_MAX_EVENTS);\n\tBUILD_BUG_ON(SCU_MAX_UNSOLICITED_FRAMES <= 8);\n\tBUILD_BUG_ON_NOT_POWER_OF_2(SCU_MAX_UNSOLICITED_FRAMES);\n\tBUILD_BUG_ON_NOT_POWER_OF_2(SCU_MAX_COMPLETION_QUEUE_ENTRIES);\n\tBUILD_BUG_ON(SCU_MAX_UNSOLICITED_FRAMES > SCU_ABSOLUTE_MAX_UNSOLICITED_FRAMES);\n\tBUILD_BUG_ON_NOT_POWER_OF_2(SCI_MAX_IO_REQUESTS);\n\tBUILD_BUG_ON_NOT_POWER_OF_2(SCI_MAX_SEQ);\n}\n\n \nenum sci_status {\n\t \n\tSCI_SUCCESS = 0,\n\n\t \n\tSCI_SUCCESS_IO_COMPLETE_BEFORE_START,\n\n\t \n\tSCI_SUCCESS_IO_DONE_EARLY,\n\n\t \n\tSCI_WARNING_ALREADY_IN_STATE,\n\n\t \n\tSCI_WARNING_TIMER_CONFLICT,\n\n\t \n\tSCI_WARNING_SEQUENCE_INCOMPLETE,\n\n\t \n\tSCI_FAILURE,\n\n\t \n\tSCI_FATAL_ERROR,\n\n\t \n\tSCI_FAILURE_INVALID_STATE,\n\n\t \n\tSCI_FAILURE_INSUFFICIENT_RESOURCES,\n\n\t \n\tSCI_FAILURE_CONTROLLER_NOT_FOUND,\n\n\t \n\tSCI_FAILURE_UNSUPPORTED_CONTROLLER_TYPE,\n\n\t \n\tSCI_FAILURE_UNSUPPORTED_INIT_DATA_VERSION,\n\n\t \n\tSCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION,\n\n\t \n\tSCI_FAILURE_UNSUPPORTED_PROTOCOL,\n\n\t \n\tSCI_FAILURE_UNSUPPORTED_INFORMATION_TYPE,\n\n\t \n\tSCI_FAILURE_DEVICE_EXISTS,\n\n\t \n\tSCI_FAILURE_ADDING_PHY_UNSUPPORTED,\n\n\t \n\tSCI_FAILURE_UNSUPPORTED_INFORMATION_FIELD,\n\n\t \n\tSCI_FAILURE_UNSUPPORTED_TIME_LIMIT,\n\n\t \n\tSCI_FAILURE_INVALID_PHY,\n\n\t \n\tSCI_FAILURE_INVALID_PORT,\n\n\t \n\tSCI_FAILURE_RESET_PORT_PARTIAL_SUCCESS,\n\n\t \n\tSCI_FAILURE_RESET_PORT_FAILURE,\n\n\t \n\tSCI_FAILURE_INVALID_REMOTE_DEVICE,\n\n\t \n\tSCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED,\n\n\t \n\tSCI_FAILURE_INVALID_IO_TAG,\n\n\t \n\tSCI_FAILURE_IO_RESPONSE_VALID,\n\n\t \n\tSCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR,\n\n\t \n\tSCI_FAILURE_IO_TERMINATED,\n\n\t \n\tSCI_FAILURE_IO_REQUIRES_SCSI_ABORT,\n\n\t \n\tSCI_FAILURE_DEVICE_NOT_FOUND,\n\n\t \n\tSCI_FAILURE_INVALID_ASSOCIATION,\n\n\t \n\tSCI_FAILURE_TIMEOUT,\n\n\t \n\tSCI_FAILURE_INVALID_PARAMETER_VALUE,\n\n\t \n\tSCI_FAILURE_UNSUPPORTED_MESSAGE_COUNT,\n\n\t \n\tSCI_FAILURE_NO_NCQ_TAG_AVAILABLE,\n\n\t \n\tSCI_FAILURE_PROTOCOL_VIOLATION,\n\n\t \n\tSCI_FAILURE_RETRY_REQUIRED,\n\n\t \n\tSCI_FAILURE_RETRY_LIMIT_REACHED,\n\n\t \n\tSCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS,\n\n\t \n\tSCI_FAILURE_ILLEGAL_ROUTING_ATTRIBUTE_CONFIGURATION,\n\n\t \n\tSCI_FAILURE_EXCEED_MAX_ROUTE_INDEX,\n\n\t \n\tSCI_FAILURE_UNSUPPORTED_PCI_DEVICE_ID\n\n};\n\n \nenum sci_io_status {\n\tSCI_IO_SUCCESS                         = SCI_SUCCESS,\n\tSCI_IO_FAILURE                         = SCI_FAILURE,\n\tSCI_IO_SUCCESS_COMPLETE_BEFORE_START   = SCI_SUCCESS_IO_COMPLETE_BEFORE_START,\n\tSCI_IO_SUCCESS_IO_DONE_EARLY           = SCI_SUCCESS_IO_DONE_EARLY,\n\tSCI_IO_FAILURE_INVALID_STATE           = SCI_FAILURE_INVALID_STATE,\n\tSCI_IO_FAILURE_INSUFFICIENT_RESOURCES  = SCI_FAILURE_INSUFFICIENT_RESOURCES,\n\tSCI_IO_FAILURE_UNSUPPORTED_PROTOCOL    = SCI_FAILURE_UNSUPPORTED_PROTOCOL,\n\tSCI_IO_FAILURE_RESPONSE_VALID          = SCI_FAILURE_IO_RESPONSE_VALID,\n\tSCI_IO_FAILURE_CONTROLLER_SPECIFIC_ERR = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR,\n\tSCI_IO_FAILURE_TERMINATED              = SCI_FAILURE_IO_TERMINATED,\n\tSCI_IO_FAILURE_REQUIRES_SCSI_ABORT     = SCI_FAILURE_IO_REQUIRES_SCSI_ABORT,\n\tSCI_IO_FAILURE_INVALID_PARAMETER_VALUE = SCI_FAILURE_INVALID_PARAMETER_VALUE,\n\tSCI_IO_FAILURE_NO_NCQ_TAG_AVAILABLE    = SCI_FAILURE_NO_NCQ_TAG_AVAILABLE,\n\tSCI_IO_FAILURE_PROTOCOL_VIOLATION      = SCI_FAILURE_PROTOCOL_VIOLATION,\n\n\tSCI_IO_FAILURE_REMOTE_DEVICE_RESET_REQUIRED = SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED,\n\n\tSCI_IO_FAILURE_RETRY_REQUIRED      = SCI_FAILURE_RETRY_REQUIRED,\n\tSCI_IO_FAILURE_RETRY_LIMIT_REACHED = SCI_FAILURE_RETRY_LIMIT_REACHED,\n\tSCI_IO_FAILURE_INVALID_REMOTE_DEVICE = SCI_FAILURE_INVALID_REMOTE_DEVICE\n};\n\n \nenum sci_task_status {\n\tSCI_TASK_SUCCESS                         = SCI_SUCCESS,\n\tSCI_TASK_FAILURE                         = SCI_FAILURE,\n\tSCI_TASK_FAILURE_INVALID_STATE           = SCI_FAILURE_INVALID_STATE,\n\tSCI_TASK_FAILURE_INSUFFICIENT_RESOURCES  = SCI_FAILURE_INSUFFICIENT_RESOURCES,\n\tSCI_TASK_FAILURE_UNSUPPORTED_PROTOCOL    = SCI_FAILURE_UNSUPPORTED_PROTOCOL,\n\tSCI_TASK_FAILURE_INVALID_TAG             = SCI_FAILURE_INVALID_IO_TAG,\n\tSCI_TASK_FAILURE_RESPONSE_VALID          = SCI_FAILURE_IO_RESPONSE_VALID,\n\tSCI_TASK_FAILURE_CONTROLLER_SPECIFIC_ERR = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR,\n\tSCI_TASK_FAILURE_TERMINATED              = SCI_FAILURE_IO_TERMINATED,\n\tSCI_TASK_FAILURE_INVALID_PARAMETER_VALUE = SCI_FAILURE_INVALID_PARAMETER_VALUE,\n\n\tSCI_TASK_FAILURE_REMOTE_DEVICE_RESET_REQUIRED = SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED,\n\tSCI_TASK_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS = SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS\n\n};\n\n \nstatic inline void sci_swab32_cpy(void *_dest, void *_src, ssize_t word_cnt)\n{\n\tu32 *dest = _dest, *src = _src;\n\n\twhile (--word_cnt >= 0)\n\t\tdest[word_cnt] = swab32(src[word_cnt]);\n}\n\nextern unsigned char no_outbound_task_to;\nextern u16 ssp_max_occ_to;\nextern u16 stp_max_occ_to;\nextern u16 ssp_inactive_to;\nextern u16 stp_inactive_to;\nextern unsigned char phy_gen;\nextern unsigned char max_concurr_spinup;\nextern uint cable_selection_override;\n\nirqreturn_t isci_msix_isr(int vec, void *data);\nirqreturn_t isci_intx_isr(int vec, void *data);\nirqreturn_t isci_error_isr(int vec, void *data);\n\n \nstruct sci_timer {\n\tstruct timer_list\ttimer;\n\tbool\t\t\tcancel;\n};\n\nstatic inline\nvoid sci_init_timer(struct sci_timer *tmr, void (*fn)(struct timer_list *t))\n{\n\ttmr->cancel = false;\n\ttimer_setup(&tmr->timer, fn, 0);\n}\n\nstatic inline void sci_mod_timer(struct sci_timer *tmr, unsigned long msec)\n{\n\ttmr->cancel = false;\n\tmod_timer(&tmr->timer, jiffies + msecs_to_jiffies(msec));\n}\n\nstatic inline void sci_del_timer(struct sci_timer *tmr)\n{\n\ttmr->cancel = true;\n\tdel_timer(&tmr->timer);\n}\n\nstruct sci_base_state_machine {\n\tconst struct sci_base_state *state_table;\n\tu32 initial_state_id;\n\tu32 current_state_id;\n\tu32 previous_state_id;\n};\n\ntypedef void (*sci_state_transition_t)(struct sci_base_state_machine *sm);\n\nstruct sci_base_state {\n\tsci_state_transition_t enter_state;\t \n\tsci_state_transition_t exit_state;\t \n};\n\nextern void sci_init_sm(struct sci_base_state_machine *sm,\n\t\t\tconst struct sci_base_state *state_table,\n\t\t\tu32 initial_state);\nextern void sci_change_state(struct sci_base_state_machine *sm, u32 next_state);\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}