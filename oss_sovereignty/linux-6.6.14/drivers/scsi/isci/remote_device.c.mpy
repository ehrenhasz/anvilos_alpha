{
  "module_name": "remote_device.c",
  "hash_id": "0ad1d127ce0f37363a963831ce8d74a61d4d5266f0640cfcbb2480b5c9cdc368",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/isci/remote_device.c",
  "human_readable_source": " \n#include <scsi/sas.h>\n#include <linux/bitops.h>\n#include \"isci.h\"\n#include \"port.h\"\n#include \"remote_device.h\"\n#include \"request.h\"\n#include \"remote_node_context.h\"\n#include \"scu_event_codes.h\"\n#include \"task.h\"\n\n#undef C\n#define C(a) (#a)\nconst char *dev_state_name(enum sci_remote_device_states state)\n{\n\tstatic const char * const strings[] = REMOTE_DEV_STATES;\n\n\treturn strings[state];\n}\n#undef C\n\nenum sci_status sci_remote_device_suspend(struct isci_remote_device *idev,\n\t\t\t\t\t  enum sci_remote_node_suspension_reasons reason)\n{\n\treturn sci_remote_node_context_suspend(&idev->rnc, reason,\n\t\t\t\t\t       SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT);\n}\n\n \nstatic void isci_remote_device_ready(struct isci_host *ihost, struct isci_remote_device *idev)\n{\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: idev = %p\\n\", __func__, idev);\n\n\tclear_bit(IDEV_IO_NCQERROR, &idev->flags);\n\tset_bit(IDEV_IO_READY, &idev->flags);\n\tif (test_and_clear_bit(IDEV_START_PENDING, &idev->flags))\n\t\twake_up(&ihost->eventq);\n}\n\nstatic enum sci_status sci_remote_device_terminate_req(\n\tstruct isci_host *ihost,\n\tstruct isci_remote_device *idev,\n\tint check_abort,\n\tstruct isci_request *ireq)\n{\n\tif (!test_bit(IREQ_ACTIVE, &ireq->flags) ||\n\t    (ireq->target_device != idev) ||\n\t    (check_abort && !test_bit(IREQ_PENDING_ABORT, &ireq->flags)))\n\t\treturn SCI_SUCCESS;\n\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: idev=%p; flags=%lx; req=%p; req target=%p\\n\",\n\t\t__func__, idev, idev->flags, ireq, ireq->target_device);\n\n\tset_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags);\n\n\treturn sci_controller_terminate_request(ihost, idev, ireq);\n}\n\nstatic enum sci_status sci_remote_device_terminate_reqs_checkabort(\n\tstruct isci_remote_device *idev,\n\tint chk)\n{\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\tenum sci_status status  = SCI_SUCCESS;\n\tu32 i;\n\n\tfor (i = 0; i < SCI_MAX_IO_REQUESTS; i++) {\n\t\tstruct isci_request *ireq = ihost->reqs[i];\n\t\tenum sci_status s;\n\n\t\ts = sci_remote_device_terminate_req(ihost, idev, chk, ireq);\n\t\tif (s != SCI_SUCCESS)\n\t\t\tstatus = s;\n\t}\n\treturn status;\n}\n\nstatic bool isci_compare_suspendcount(\n\tstruct isci_remote_device *idev,\n\tu32 localcount)\n{\n\tsmp_rmb();\n\n\t \n\treturn (localcount != idev->rnc.suspend_count)\n\t    || sci_remote_node_context_is_being_destroyed(&idev->rnc);\n}\n\nstatic bool isci_check_reqterm(\n\tstruct isci_host *ihost,\n\tstruct isci_remote_device *idev,\n\tstruct isci_request *ireq,\n\tu32 localcount)\n{\n\tunsigned long flags;\n\tbool res;\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\tres = isci_compare_suspendcount(idev, localcount)\n\t\t&& !test_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags);\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\treturn res;\n}\n\nstatic bool isci_check_devempty(\n\tstruct isci_host *ihost,\n\tstruct isci_remote_device *idev,\n\tu32 localcount)\n{\n\tunsigned long flags;\n\tbool res;\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\tres = isci_compare_suspendcount(idev, localcount)\n\t\t&& idev->started_request_count == 0;\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\treturn res;\n}\n\nenum sci_status isci_remote_device_terminate_requests(\n\tstruct isci_host *ihost,\n\tstruct isci_remote_device *idev,\n\tstruct isci_request *ireq)\n{\n\tenum sci_status status = SCI_SUCCESS;\n\tunsigned long flags;\n\tu32 rnc_suspend_count;\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\n\tif (isci_get_device(idev) == NULL) {\n\t\tdev_dbg(&ihost->pdev->dev, \"%s: failed isci_get_device(idev=%p)\\n\",\n\t\t\t__func__, idev);\n\t\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\t\tstatus = SCI_FAILURE;\n\t} else {\n\t\t \n\t\tsmp_rmb();\n\t\trnc_suspend_count\n\t\t\t= sci_remote_node_context_is_suspended(&idev->rnc)\n\t\t\t\t? 0 : idev->rnc.suspend_count;\n\n\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t\"%s: idev=%p, ireq=%p; started_request_count=%d, \"\n\t\t\t\t\"rnc_suspend_count=%d, rnc.suspend_count=%d\"\n\t\t\t\t\"about to wait\\n\",\n\t\t\t__func__, idev, ireq, idev->started_request_count,\n\t\t\trnc_suspend_count, idev->rnc.suspend_count);\n\n\t\t#define MAX_SUSPEND_MSECS 10000\n\t\tif (ireq) {\n\t\t\t \n\t\t\tset_bit(IREQ_NO_AUTO_FREE_TAG, &ireq->flags);\n\t\t\tsci_remote_device_terminate_req(ihost, idev, 0, ireq);\n\t\t\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\t\t\tif (!wait_event_timeout(ihost->eventq,\n\t\t\t\t\t\tisci_check_reqterm(ihost, idev, ireq,\n\t\t\t\t\t\t\t\t   rnc_suspend_count),\n\t\t\t\t\t\tmsecs_to_jiffies(MAX_SUSPEND_MSECS))) {\n\n\t\t\t\tdev_warn(&ihost->pdev->dev, \"%s host%d timeout single\\n\",\n\t\t\t\t\t __func__, ihost->id);\n\t\t\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t\t\t \"%s: ******* Timeout waiting for \"\n\t\t\t\t\t \"suspend; idev=%p, current state %s; \"\n\t\t\t\t\t \"started_request_count=%d, flags=%lx\\n\\t\"\n\t\t\t\t\t \"rnc_suspend_count=%d, rnc.suspend_count=%d \"\n\t\t\t\t\t \"RNC: current state %s, current \"\n\t\t\t\t\t \"suspend_type %x dest state %d;\\n\"\n\t\t\t\t\t \"ireq=%p, ireq->flags = %lx\\n\",\n\t\t\t\t\t __func__, idev,\n\t\t\t\t\t dev_state_name(idev->sm.current_state_id),\n\t\t\t\t\t idev->started_request_count, idev->flags,\n\t\t\t\t\t rnc_suspend_count, idev->rnc.suspend_count,\n\t\t\t\t\t rnc_state_name(idev->rnc.sm.current_state_id),\n\t\t\t\t\t idev->rnc.suspend_type,\n\t\t\t\t\t idev->rnc.destination_state,\n\t\t\t\t\t ireq, ireq->flags);\n\t\t\t}\n\t\t\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\t\t\tclear_bit(IREQ_NO_AUTO_FREE_TAG, &ireq->flags);\n\t\t\tif (!test_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags))\n\t\t\t\tisci_free_tag(ihost, ireq->io_tag);\n\t\t\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\t\t} else {\n\t\t\t \n\t\t\tsci_remote_device_terminate_requests(idev);\n\t\t\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\t\t\tif (!wait_event_timeout(ihost->eventq,\n\t\t\t\t\t\tisci_check_devempty(ihost, idev,\n\t\t\t\t\t\t\t\t    rnc_suspend_count),\n\t\t\t\t\t\tmsecs_to_jiffies(MAX_SUSPEND_MSECS))) {\n\n\t\t\t\tdev_warn(&ihost->pdev->dev, \"%s host%d timeout all\\n\",\n\t\t\t\t\t __func__, ihost->id);\n\t\t\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t\t\t\"%s: ******* Timeout waiting for \"\n\t\t\t\t\t\"suspend; idev=%p, current state %s; \"\n\t\t\t\t\t\"started_request_count=%d, flags=%lx\\n\\t\"\n\t\t\t\t\t\"rnc_suspend_count=%d, \"\n\t\t\t\t\t\"RNC: current state %s, \"\n\t\t\t\t\t\"rnc.suspend_count=%d, current \"\n\t\t\t\t\t\"suspend_type %x dest state %d\\n\",\n\t\t\t\t\t__func__, idev,\n\t\t\t\t\tdev_state_name(idev->sm.current_state_id),\n\t\t\t\t\tidev->started_request_count, idev->flags,\n\t\t\t\t\trnc_suspend_count,\n\t\t\t\t\trnc_state_name(idev->rnc.sm.current_state_id),\n\t\t\t\t\tidev->rnc.suspend_count,\n\t\t\t\t\tidev->rnc.suspend_type,\n\t\t\t\t\tidev->rnc.destination_state);\n\t\t\t}\n\t\t}\n\t\tdev_dbg(&ihost->pdev->dev, \"%s: idev=%p, wait done\\n\",\n\t\t\t__func__, idev);\n\t\tisci_put_device(idev);\n\t}\n\treturn status;\n}\n\n \nstatic void isci_remote_device_not_ready(struct isci_host *ihost,\n\t\t\t\t\t struct isci_remote_device *idev,\n\t\t\t\t\t u32 reason)\n{\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: isci_device = %p; reason = %d\\n\", __func__, idev, reason);\n\n\tswitch (reason) {\n\tcase SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED:\n\t\tset_bit(IDEV_IO_NCQERROR, &idev->flags);\n\n\t\t \n\t\tsci_remote_device_suspend(idev, SCI_SW_SUSPEND_NORMAL);\n\n\t\t \n\t\tsci_remote_device_terminate_requests(idev);\n\n\t\tfallthrough;\t \n\tdefault:\n\t\tclear_bit(IDEV_IO_READY, &idev->flags);\n\t\tbreak;\n\t}\n}\n\n \nstatic void rnc_destruct_done(void *_dev)\n{\n\tstruct isci_remote_device *idev = _dev;\n\n\tBUG_ON(idev->started_request_count != 0);\n\tsci_change_state(&idev->sm, SCI_DEV_STOPPED);\n}\n\nenum sci_status sci_remote_device_terminate_requests(\n\tstruct isci_remote_device *idev)\n{\n\treturn sci_remote_device_terminate_reqs_checkabort(idev, 0);\n}\n\nenum sci_status sci_remote_device_stop(struct isci_remote_device *idev,\n\t\t\t\t\tu32 timeout)\n{\n\tstruct sci_base_state_machine *sm = &idev->sm;\n\tenum sci_remote_device_states state = sm->current_state_id;\n\n\tswitch (state) {\n\tcase SCI_DEV_INITIAL:\n\tcase SCI_DEV_FAILED:\n\tcase SCI_DEV_FINAL:\n\tdefault:\n\t\tdev_warn(scirdev_to_dev(idev), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, dev_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\tcase SCI_DEV_STOPPED:\n\t\treturn SCI_SUCCESS;\n\tcase SCI_DEV_STARTING:\n\t\t \n\t\tBUG_ON(idev->started_request_count != 0);\n\t\tsci_remote_node_context_destruct(&idev->rnc,\n\t\t\t\t\t\t      rnc_destruct_done, idev);\n\t\t \n\t\tsci_change_state(sm, SCI_DEV_STOPPING);\n\t\treturn SCI_SUCCESS;\n\tcase SCI_DEV_READY:\n\tcase SCI_STP_DEV_IDLE:\n\tcase SCI_STP_DEV_CMD:\n\tcase SCI_STP_DEV_NCQ:\n\tcase SCI_STP_DEV_NCQ_ERROR:\n\tcase SCI_STP_DEV_AWAIT_RESET:\n\tcase SCI_SMP_DEV_IDLE:\n\tcase SCI_SMP_DEV_CMD:\n\t\tsci_change_state(sm, SCI_DEV_STOPPING);\n\t\tif (idev->started_request_count == 0)\n\t\t\tsci_remote_node_context_destruct(&idev->rnc,\n\t\t\t\t\t\t\t rnc_destruct_done,\n\t\t\t\t\t\t\t idev);\n\t\telse {\n\t\t\tsci_remote_device_suspend(\n\t\t\t\tidev, SCI_SW_SUSPEND_LINKHANG_DETECT);\n\t\t\tsci_remote_device_terminate_requests(idev);\n\t\t}\n\t\treturn SCI_SUCCESS;\n\tcase SCI_DEV_STOPPING:\n\t\t \n\t\treturn sci_remote_device_terminate_requests(idev);\n\tcase SCI_DEV_RESETTING:\n\t\tsci_change_state(sm, SCI_DEV_STOPPING);\n\t\treturn SCI_SUCCESS;\n\t}\n}\n\nenum sci_status sci_remote_device_reset(struct isci_remote_device *idev)\n{\n\tstruct sci_base_state_machine *sm = &idev->sm;\n\tenum sci_remote_device_states state = sm->current_state_id;\n\n\tswitch (state) {\n\tcase SCI_DEV_INITIAL:\n\tcase SCI_DEV_STOPPED:\n\tcase SCI_DEV_STARTING:\n\tcase SCI_SMP_DEV_IDLE:\n\tcase SCI_SMP_DEV_CMD:\n\tcase SCI_DEV_STOPPING:\n\tcase SCI_DEV_FAILED:\n\tcase SCI_DEV_RESETTING:\n\tcase SCI_DEV_FINAL:\n\tdefault:\n\t\tdev_warn(scirdev_to_dev(idev), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, dev_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\tcase SCI_DEV_READY:\n\tcase SCI_STP_DEV_IDLE:\n\tcase SCI_STP_DEV_CMD:\n\tcase SCI_STP_DEV_NCQ:\n\tcase SCI_STP_DEV_NCQ_ERROR:\n\tcase SCI_STP_DEV_AWAIT_RESET:\n\t\tsci_change_state(sm, SCI_DEV_RESETTING);\n\t\treturn SCI_SUCCESS;\n\t}\n}\n\nenum sci_status sci_remote_device_reset_complete(struct isci_remote_device *idev)\n{\n\tstruct sci_base_state_machine *sm = &idev->sm;\n\tenum sci_remote_device_states state = sm->current_state_id;\n\n\tif (state != SCI_DEV_RESETTING) {\n\t\tdev_warn(scirdev_to_dev(idev), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, dev_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n\n\tsci_change_state(sm, SCI_DEV_READY);\n\treturn SCI_SUCCESS;\n}\n\nenum sci_status sci_remote_device_frame_handler(struct isci_remote_device *idev,\n\t\t\t\t\t\t     u32 frame_index)\n{\n\tstruct sci_base_state_machine *sm = &idev->sm;\n\tenum sci_remote_device_states state = sm->current_state_id;\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\tenum sci_status status;\n\n\tswitch (state) {\n\tcase SCI_DEV_INITIAL:\n\tcase SCI_DEV_STOPPED:\n\tcase SCI_DEV_STARTING:\n\tcase SCI_STP_DEV_IDLE:\n\tcase SCI_SMP_DEV_IDLE:\n\tcase SCI_DEV_FINAL:\n\tdefault:\n\t\tdev_warn(scirdev_to_dev(idev), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, dev_state_name(state));\n\t\t \n\t\tsci_controller_release_frame(ihost, frame_index);\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\tcase SCI_DEV_READY:\n\tcase SCI_STP_DEV_NCQ_ERROR:\n\tcase SCI_STP_DEV_AWAIT_RESET:\n\tcase SCI_DEV_STOPPING:\n\tcase SCI_DEV_FAILED:\n\tcase SCI_DEV_RESETTING: {\n\t\tstruct isci_request *ireq;\n\t\tstruct ssp_frame_hdr hdr;\n\t\tvoid *frame_header;\n\t\tssize_t word_cnt;\n\n\t\tstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\n\t\t\t\t\t\t\t\t       frame_index,\n\t\t\t\t\t\t\t\t       &frame_header);\n\t\tif (status != SCI_SUCCESS)\n\t\t\treturn status;\n\n\t\tword_cnt = sizeof(hdr) / sizeof(u32);\n\t\tsci_swab32_cpy(&hdr, frame_header, word_cnt);\n\n\t\tireq = sci_request_by_tag(ihost, be16_to_cpu(hdr.tag));\n\t\tif (ireq && ireq->target_device == idev) {\n\t\t\t \n\t\t\tstatus = sci_io_request_frame_handler(ireq, frame_index);\n\t\t} else {\n\t\t\t \n\t\t\tsci_controller_release_frame(ihost, frame_index);\n\t\t}\n\t\tbreak;\n\t}\n\tcase SCI_STP_DEV_NCQ: {\n\t\tstruct dev_to_host_fis *hdr;\n\n\t\tstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\n\t\t\t\t\t\t\t\t       frame_index,\n\t\t\t\t\t\t\t\t       (void **)&hdr);\n\t\tif (status != SCI_SUCCESS)\n\t\t\treturn status;\n\n\t\tif (hdr->fis_type == FIS_SETDEVBITS &&\n\t\t    (hdr->status & ATA_ERR)) {\n\t\t\tidev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;\n\n\t\t\t \n\t\t\tsci_change_state(sm, SCI_STP_DEV_NCQ_ERROR);\n\t\t} else if (hdr->fis_type == FIS_REGD2H &&\n\t\t\t   (hdr->status & ATA_ERR)) {\n\t\t\t \n\t\t\tidev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;\n\t\t\tsci_change_state(&idev->sm, SCI_STP_DEV_NCQ_ERROR);\n\t\t} else\n\t\t\tstatus = SCI_FAILURE;\n\n\t\tsci_controller_release_frame(ihost, frame_index);\n\t\tbreak;\n\t}\n\tcase SCI_STP_DEV_CMD:\n\tcase SCI_SMP_DEV_CMD:\n\t\t \n\t\tstatus = sci_io_request_frame_handler(idev->working_request, frame_index);\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nstatic bool is_remote_device_ready(struct isci_remote_device *idev)\n{\n\n\tstruct sci_base_state_machine *sm = &idev->sm;\n\tenum sci_remote_device_states state = sm->current_state_id;\n\n\tswitch (state) {\n\tcase SCI_DEV_READY:\n\tcase SCI_STP_DEV_IDLE:\n\tcase SCI_STP_DEV_CMD:\n\tcase SCI_STP_DEV_NCQ:\n\tcase SCI_STP_DEV_NCQ_ERROR:\n\tcase SCI_STP_DEV_AWAIT_RESET:\n\tcase SCI_SMP_DEV_IDLE:\n\tcase SCI_SMP_DEV_CMD:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic void atapi_remote_device_resume_done(void *_dev)\n{\n\tstruct isci_remote_device *idev = _dev;\n\tstruct isci_request *ireq = idev->working_request;\n\n\tsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\n}\n\nenum sci_status sci_remote_device_event_handler(struct isci_remote_device *idev,\n\t\t\t\t\t\t     u32 event_code)\n{\n\tenum sci_status status;\n\tstruct sci_base_state_machine *sm = &idev->sm;\n\tenum sci_remote_device_states state = sm->current_state_id;\n\n\tswitch (scu_get_event_type(event_code)) {\n\tcase SCU_EVENT_TYPE_RNC_OPS_MISC:\n\tcase SCU_EVENT_TYPE_RNC_SUSPEND_TX:\n\tcase SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:\n\t\tstatus = sci_remote_node_context_event_handler(&idev->rnc, event_code);\n\t\tbreak;\n\tcase SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT:\n\t\tif (scu_get_event_code(event_code) == SCU_EVENT_IT_NEXUS_TIMEOUT) {\n\t\t\tstatus = SCI_SUCCESS;\n\n\t\t\t \n\t\t\tsci_remote_device_suspend(idev, SCI_SW_SUSPEND_NORMAL);\n\n\t\t\tdev_dbg(scirdev_to_dev(idev),\n\t\t\t\t\"%s: device: %p event code: %x: %s\\n\",\n\t\t\t\t__func__, idev, event_code,\n\t\t\t\tis_remote_device_ready(idev)\n\t\t\t\t? \"I_T_Nexus_Timeout event\"\n\t\t\t\t: \"I_T_Nexus_Timeout event in wrong state\");\n\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\t \n\tdefault:\n\t\tdev_dbg(scirdev_to_dev(idev),\n\t\t\t\"%s: device: %p event code: %x: %s\\n\",\n\t\t\t__func__, idev, event_code,\n\t\t\tis_remote_device_ready(idev)\n\t\t\t? \"unexpected event\"\n\t\t\t: \"unexpected event in wrong state\");\n\t\tstatus = SCI_FAILURE_INVALID_STATE;\n\t\tbreak;\n\t}\n\n\tif (status != SCI_SUCCESS)\n\t\treturn status;\n\n\t \n\tif (state == SCI_STP_DEV_ATAPI_ERROR) {\n\t\t \n\t\tif (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||\n\t\t    scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX) {\n\t\t\treturn sci_remote_node_context_resume(&idev->rnc,\n\t\t\t\t\t\t\t      atapi_remote_device_resume_done,\n\t\t\t\t\t\t\t      idev);\n\t\t}\n\t}\n\n\tif (state == SCI_STP_DEV_IDLE) {\n\n\t\t \n\t\tif (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||\n\t\t    scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX)\n\t\t\tstatus = sci_remote_node_context_resume(&idev->rnc, NULL, NULL);\n\t}\n\n\treturn status;\n}\n\nstatic void sci_remote_device_start_request(struct isci_remote_device *idev,\n\t\t\t\t\t\t struct isci_request *ireq,\n\t\t\t\t\t\t enum sci_status status)\n{\n\tstruct isci_port *iport = idev->owning_port;\n\n\t \n\tif (status != SCI_SUCCESS)\n\t\tsci_port_complete_io(iport, idev, ireq);\n\telse {\n\t\tkref_get(&idev->kref);\n\t\tidev->started_request_count++;\n\t}\n}\n\nenum sci_status sci_remote_device_start_io(struct isci_host *ihost,\n\t\t\t\t\t\tstruct isci_remote_device *idev,\n\t\t\t\t\t\tstruct isci_request *ireq)\n{\n\tstruct sci_base_state_machine *sm = &idev->sm;\n\tenum sci_remote_device_states state = sm->current_state_id;\n\tstruct isci_port *iport = idev->owning_port;\n\tenum sci_status status;\n\n\tswitch (state) {\n\tcase SCI_DEV_INITIAL:\n\tcase SCI_DEV_STOPPED:\n\tcase SCI_DEV_STARTING:\n\tcase SCI_STP_DEV_NCQ_ERROR:\n\tcase SCI_DEV_STOPPING:\n\tcase SCI_DEV_FAILED:\n\tcase SCI_DEV_RESETTING:\n\tcase SCI_DEV_FINAL:\n\tdefault:\n\t\tdev_warn(scirdev_to_dev(idev), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, dev_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\tcase SCI_DEV_READY:\n\t\t \n\t\tstatus = sci_port_start_io(iport, idev, ireq);\n\t\tif (status != SCI_SUCCESS)\n\t\t\treturn status;\n\n\t\tstatus = sci_remote_node_context_start_io(&idev->rnc, ireq);\n\t\tif (status != SCI_SUCCESS)\n\t\t\tbreak;\n\n\t\tstatus = sci_request_start(ireq);\n\t\tbreak;\n\tcase SCI_STP_DEV_IDLE: {\n\t\t \n\t\tenum sci_remote_device_states new_state;\n\t\tstruct sas_task *task = isci_request_access_task(ireq);\n\n\t\tstatus = sci_port_start_io(iport, idev, ireq);\n\t\tif (status != SCI_SUCCESS)\n\t\t\treturn status;\n\n\t\tstatus = sci_remote_node_context_start_io(&idev->rnc, ireq);\n\t\tif (status != SCI_SUCCESS)\n\t\t\tbreak;\n\n\t\tstatus = sci_request_start(ireq);\n\t\tif (status != SCI_SUCCESS)\n\t\t\tbreak;\n\n\t\tif (task->ata_task.use_ncq)\n\t\t\tnew_state = SCI_STP_DEV_NCQ;\n\t\telse {\n\t\t\tidev->working_request = ireq;\n\t\t\tnew_state = SCI_STP_DEV_CMD;\n\t\t}\n\t\tsci_change_state(sm, new_state);\n\t\tbreak;\n\t}\n\tcase SCI_STP_DEV_NCQ: {\n\t\tstruct sas_task *task = isci_request_access_task(ireq);\n\n\t\tif (task->ata_task.use_ncq) {\n\t\t\tstatus = sci_port_start_io(iport, idev, ireq);\n\t\t\tif (status != SCI_SUCCESS)\n\t\t\t\treturn status;\n\n\t\t\tstatus = sci_remote_node_context_start_io(&idev->rnc, ireq);\n\t\t\tif (status != SCI_SUCCESS)\n\t\t\t\tbreak;\n\n\t\t\tstatus = sci_request_start(ireq);\n\t\t} else\n\t\t\treturn SCI_FAILURE_INVALID_STATE;\n\t\tbreak;\n\t}\n\tcase SCI_STP_DEV_AWAIT_RESET:\n\t\treturn SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;\n\tcase SCI_SMP_DEV_IDLE:\n\t\tstatus = sci_port_start_io(iport, idev, ireq);\n\t\tif (status != SCI_SUCCESS)\n\t\t\treturn status;\n\n\t\tstatus = sci_remote_node_context_start_io(&idev->rnc, ireq);\n\t\tif (status != SCI_SUCCESS)\n\t\t\tbreak;\n\n\t\tstatus = sci_request_start(ireq);\n\t\tif (status != SCI_SUCCESS)\n\t\t\tbreak;\n\n\t\tidev->working_request = ireq;\n\t\tsci_change_state(&idev->sm, SCI_SMP_DEV_CMD);\n\t\tbreak;\n\tcase SCI_STP_DEV_CMD:\n\tcase SCI_SMP_DEV_CMD:\n\t\t \n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n\n\tsci_remote_device_start_request(idev, ireq, status);\n\treturn status;\n}\n\nstatic enum sci_status common_complete_io(struct isci_port *iport,\n\t\t\t\t\t  struct isci_remote_device *idev,\n\t\t\t\t\t  struct isci_request *ireq)\n{\n\tenum sci_status status;\n\n\tstatus = sci_request_complete(ireq);\n\tif (status != SCI_SUCCESS)\n\t\treturn status;\n\n\tstatus = sci_port_complete_io(iport, idev, ireq);\n\tif (status != SCI_SUCCESS)\n\t\treturn status;\n\n\tsci_remote_device_decrement_request_count(idev);\n\treturn status;\n}\n\nenum sci_status sci_remote_device_complete_io(struct isci_host *ihost,\n\t\t\t\t\t\t   struct isci_remote_device *idev,\n\t\t\t\t\t\t   struct isci_request *ireq)\n{\n\tstruct sci_base_state_machine *sm = &idev->sm;\n\tenum sci_remote_device_states state = sm->current_state_id;\n\tstruct isci_port *iport = idev->owning_port;\n\tenum sci_status status;\n\n\tswitch (state) {\n\tcase SCI_DEV_INITIAL:\n\tcase SCI_DEV_STOPPED:\n\tcase SCI_DEV_STARTING:\n\tcase SCI_STP_DEV_IDLE:\n\tcase SCI_SMP_DEV_IDLE:\n\tcase SCI_DEV_FAILED:\n\tcase SCI_DEV_FINAL:\n\tdefault:\n\t\tdev_warn(scirdev_to_dev(idev), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, dev_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\tcase SCI_DEV_READY:\n\tcase SCI_STP_DEV_AWAIT_RESET:\n\tcase SCI_DEV_RESETTING:\n\t\tstatus = common_complete_io(iport, idev, ireq);\n\t\tbreak;\n\tcase SCI_STP_DEV_CMD:\n\tcase SCI_STP_DEV_NCQ:\n\tcase SCI_STP_DEV_NCQ_ERROR:\n\tcase SCI_STP_DEV_ATAPI_ERROR:\n\t\tstatus = common_complete_io(iport, idev, ireq);\n\t\tif (status != SCI_SUCCESS)\n\t\t\tbreak;\n\n\t\tif (ireq->sci_status == SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED) {\n\t\t\t \n\t\t\tsci_change_state(sm, SCI_STP_DEV_AWAIT_RESET);\n\t\t} else if (idev->started_request_count == 0)\n\t\t\tsci_change_state(sm, SCI_STP_DEV_IDLE);\n\t\tbreak;\n\tcase SCI_SMP_DEV_CMD:\n\t\tstatus = common_complete_io(iport, idev, ireq);\n\t\tif (status != SCI_SUCCESS)\n\t\t\tbreak;\n\t\tsci_change_state(sm, SCI_SMP_DEV_IDLE);\n\t\tbreak;\n\tcase SCI_DEV_STOPPING:\n\t\tstatus = common_complete_io(iport, idev, ireq);\n\t\tif (status != SCI_SUCCESS)\n\t\t\tbreak;\n\n\t\tif (idev->started_request_count == 0)\n\t\t\tsci_remote_node_context_destruct(&idev->rnc,\n\t\t\t\t\t\t\t rnc_destruct_done,\n\t\t\t\t\t\t\t idev);\n\t\tbreak;\n\t}\n\n\tif (status != SCI_SUCCESS)\n\t\tdev_err(scirdev_to_dev(idev),\n\t\t\t\"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x \"\n\t\t\t\"could not complete\\n\", __func__, iport,\n\t\t\tidev, ireq, status);\n\telse\n\t\tisci_put_device(idev);\n\n\treturn status;\n}\n\nstatic void sci_remote_device_continue_request(void *dev)\n{\n\tstruct isci_remote_device *idev = dev;\n\n\t \n\tif (idev->working_request)\n\t\tsci_controller_continue_io(idev->working_request);\n}\n\nenum sci_status sci_remote_device_start_task(struct isci_host *ihost,\n\t\t\t\t\t\t  struct isci_remote_device *idev,\n\t\t\t\t\t\t  struct isci_request *ireq)\n{\n\tstruct sci_base_state_machine *sm = &idev->sm;\n\tenum sci_remote_device_states state = sm->current_state_id;\n\tstruct isci_port *iport = idev->owning_port;\n\tenum sci_status status;\n\n\tswitch (state) {\n\tcase SCI_DEV_INITIAL:\n\tcase SCI_DEV_STOPPED:\n\tcase SCI_DEV_STARTING:\n\tcase SCI_SMP_DEV_IDLE:\n\tcase SCI_SMP_DEV_CMD:\n\tcase SCI_DEV_STOPPING:\n\tcase SCI_DEV_FAILED:\n\tcase SCI_DEV_RESETTING:\n\tcase SCI_DEV_FINAL:\n\tdefault:\n\t\tdev_warn(scirdev_to_dev(idev), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, dev_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\tcase SCI_STP_DEV_IDLE:\n\tcase SCI_STP_DEV_CMD:\n\tcase SCI_STP_DEV_NCQ:\n\tcase SCI_STP_DEV_NCQ_ERROR:\n\tcase SCI_STP_DEV_AWAIT_RESET:\n\t\tstatus = sci_port_start_io(iport, idev, ireq);\n\t\tif (status != SCI_SUCCESS)\n\t\t\treturn status;\n\n\t\tstatus = sci_request_start(ireq);\n\t\tif (status != SCI_SUCCESS)\n\t\t\tgoto out;\n\n\t\t \n\t\tidev->working_request = ireq;\n\t\tsci_change_state(sm, SCI_STP_DEV_CMD);\n\n\t\t \n\t\tsci_remote_device_suspend(idev,\n\t\t\t\t\t  SCI_SW_SUSPEND_LINKHANG_DETECT);\n\n\t\tstatus = sci_remote_node_context_start_task(&idev->rnc, ireq,\n\t\t\t\tsci_remote_device_continue_request, idev);\n\n\tout:\n\t\tsci_remote_device_start_request(idev, ireq, status);\n\t\t \n\t\treturn SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;\n\tcase SCI_DEV_READY:\n\t\tstatus = sci_port_start_io(iport, idev, ireq);\n\t\tif (status != SCI_SUCCESS)\n\t\t\treturn status;\n\n\t\t \n\t\tstatus = sci_remote_node_context_start_task(&idev->rnc, ireq,\n\t\t\t\t\t\t\t    NULL, NULL);\n\t\tif (status != SCI_SUCCESS)\n\t\t\tbreak;\n\n\t\tstatus = sci_request_start(ireq);\n\t\tbreak;\n\t}\n\tsci_remote_device_start_request(idev, ireq, status);\n\n\treturn status;\n}\n\nvoid sci_remote_device_post_request(struct isci_remote_device *idev, u32 request)\n{\n\tstruct isci_port *iport = idev->owning_port;\n\tu32 context;\n\n\tcontext = request |\n\t\t  (ISCI_PEG << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |\n\t\t  (iport->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |\n\t\t  idev->rnc.remote_node_index;\n\n\tsci_controller_post_request(iport->owning_controller, context);\n}\n\n \nstatic void remote_device_resume_done(void *_dev)\n{\n\tstruct isci_remote_device *idev = _dev;\n\n\tif (is_remote_device_ready(idev))\n\t\treturn;\n\n\t \n\tsci_change_state(&idev->sm, SCI_DEV_READY);\n}\n\nstatic void sci_stp_remote_device_ready_idle_substate_resume_complete_handler(void *_dev)\n{\n\tstruct isci_remote_device *idev = _dev;\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\n\t \n\tif (idev->sm.previous_state_id != SCI_STP_DEV_NCQ)\n\t\tisci_remote_device_ready(ihost, idev);\n}\n\nstatic void sci_remote_device_initial_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\n\n\t \n\tsci_change_state(&idev->sm, SCI_DEV_STOPPED);\n}\n\n \nstatic enum sci_status sci_remote_device_destruct(struct isci_remote_device *idev)\n{\n\tstruct sci_base_state_machine *sm = &idev->sm;\n\tenum sci_remote_device_states state = sm->current_state_id;\n\tstruct isci_host *ihost;\n\n\tif (state != SCI_DEV_STOPPED) {\n\t\tdev_warn(scirdev_to_dev(idev), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, dev_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n\n\tihost = idev->owning_port->owning_controller;\n\tsci_controller_free_remote_node_context(ihost, idev,\n\t\t\t\t\t\t     idev->rnc.remote_node_index);\n\tidev->rnc.remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;\n\tsci_change_state(sm, SCI_DEV_FINAL);\n\n\treturn SCI_SUCCESS;\n}\n\n \nstatic void isci_remote_device_deconstruct(struct isci_host *ihost, struct isci_remote_device *idev)\n{\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: isci_device = %p\\n\", __func__, idev);\n\n\t \n\tBUG_ON(idev->started_request_count > 0);\n\n\tsci_remote_device_destruct(idev);\n\tlist_del_init(&idev->node);\n\tisci_put_device(idev);\n}\n\nstatic void sci_remote_device_stopped_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\tu32 prev_state;\n\n\t \n\tprev_state = idev->sm.previous_state_id;\n\tif (prev_state == SCI_DEV_STOPPING)\n\t\tisci_remote_device_deconstruct(ihost, idev);\n\n\tsci_controller_remote_device_stopped(ihost, idev);\n}\n\nstatic void sci_remote_device_starting_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\n\tisci_remote_device_not_ready(ihost, idev,\n\t\t\t\t     SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);\n}\n\nstatic void sci_remote_device_ready_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\tstruct domain_device *dev = idev->domain_dev;\n\n\tif (dev->dev_type == SAS_SATA_DEV || (dev->tproto & SAS_PROTOCOL_SATA)) {\n\t\tsci_change_state(&idev->sm, SCI_STP_DEV_IDLE);\n\t} else if (dev_is_expander(dev->dev_type)) {\n\t\tsci_change_state(&idev->sm, SCI_SMP_DEV_IDLE);\n\t} else\n\t\tisci_remote_device_ready(ihost, idev);\n}\n\nstatic void sci_remote_device_ready_state_exit(struct sci_base_state_machine *sm)\n{\n\tstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\n\tstruct domain_device *dev = idev->domain_dev;\n\n\tif (dev->dev_type == SAS_END_DEVICE) {\n\t\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\n\t\tisci_remote_device_not_ready(ihost, idev,\n\t\t\t\t\t     SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED);\n\t}\n}\n\nstatic void sci_remote_device_resetting_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: isci_device = %p\\n\", __func__, idev);\n\n\tsci_remote_device_suspend(idev, SCI_SW_SUSPEND_LINKHANG_DETECT);\n}\n\nstatic void sci_remote_device_resetting_state_exit(struct sci_base_state_machine *sm)\n{\n\tstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: isci_device = %p\\n\", __func__, idev);\n\n\tsci_remote_node_context_resume(&idev->rnc, NULL, NULL);\n}\n\nstatic void sci_stp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\n\n\tidev->working_request = NULL;\n\tif (sci_remote_node_context_is_ready(&idev->rnc)) {\n\t\t \n\t\tsci_stp_remote_device_ready_idle_substate_resume_complete_handler(idev);\n\t} else {\n\t\tsci_remote_node_context_resume(&idev->rnc,\n\t\t\tsci_stp_remote_device_ready_idle_substate_resume_complete_handler,\n\t\t\tidev);\n\t}\n}\n\nstatic void sci_stp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\n\tBUG_ON(idev->working_request == NULL);\n\n\tisci_remote_device_not_ready(ihost, idev,\n\t\t\t\t     SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED);\n}\n\nstatic void sci_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\n\tif (idev->not_ready_reason == SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)\n\t\tisci_remote_device_not_ready(ihost, idev,\n\t\t\t\t\t     idev->not_ready_reason);\n}\n\nstatic void sci_smp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\n\tisci_remote_device_ready(ihost, idev);\n}\n\nstatic void sci_smp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\n\tBUG_ON(idev->working_request == NULL);\n\n\tisci_remote_device_not_ready(ihost, idev,\n\t\t\t\t     SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED);\n}\n\nstatic void sci_smp_remote_device_ready_cmd_substate_exit(struct sci_base_state_machine *sm)\n{\n\tstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\n\n\tidev->working_request = NULL;\n}\n\nstatic const struct sci_base_state sci_remote_device_state_table[] = {\n\t[SCI_DEV_INITIAL] = {\n\t\t.enter_state = sci_remote_device_initial_state_enter,\n\t},\n\t[SCI_DEV_STOPPED] = {\n\t\t.enter_state = sci_remote_device_stopped_state_enter,\n\t},\n\t[SCI_DEV_STARTING] = {\n\t\t.enter_state = sci_remote_device_starting_state_enter,\n\t},\n\t[SCI_DEV_READY] = {\n\t\t.enter_state = sci_remote_device_ready_state_enter,\n\t\t.exit_state  = sci_remote_device_ready_state_exit\n\t},\n\t[SCI_STP_DEV_IDLE] = {\n\t\t.enter_state = sci_stp_remote_device_ready_idle_substate_enter,\n\t},\n\t[SCI_STP_DEV_CMD] = {\n\t\t.enter_state = sci_stp_remote_device_ready_cmd_substate_enter,\n\t},\n\t[SCI_STP_DEV_NCQ] = { },\n\t[SCI_STP_DEV_NCQ_ERROR] = {\n\t\t.enter_state = sci_stp_remote_device_ready_ncq_error_substate_enter,\n\t},\n\t[SCI_STP_DEV_ATAPI_ERROR] = { },\n\t[SCI_STP_DEV_AWAIT_RESET] = { },\n\t[SCI_SMP_DEV_IDLE] = {\n\t\t.enter_state = sci_smp_remote_device_ready_idle_substate_enter,\n\t},\n\t[SCI_SMP_DEV_CMD] = {\n\t\t.enter_state = sci_smp_remote_device_ready_cmd_substate_enter,\n\t\t.exit_state  = sci_smp_remote_device_ready_cmd_substate_exit,\n\t},\n\t[SCI_DEV_STOPPING] = { },\n\t[SCI_DEV_FAILED] = { },\n\t[SCI_DEV_RESETTING] = {\n\t\t.enter_state = sci_remote_device_resetting_state_enter,\n\t\t.exit_state  = sci_remote_device_resetting_state_exit\n\t},\n\t[SCI_DEV_FINAL] = { },\n};\n\n \nstatic void sci_remote_device_construct(struct isci_port *iport,\n\t\t\t\t  struct isci_remote_device *idev)\n{\n\tidev->owning_port = iport;\n\tidev->started_request_count = 0;\n\n\tsci_init_sm(&idev->sm, sci_remote_device_state_table, SCI_DEV_INITIAL);\n\n\tsci_remote_node_context_construct(&idev->rnc,\n\t\t\t\t\t       SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);\n}\n\n \nstatic enum sci_status sci_remote_device_da_construct(struct isci_port *iport,\n\t\t\t\t\t\t       struct isci_remote_device *idev)\n{\n\tenum sci_status status;\n\tstruct sci_port_properties properties;\n\n\tsci_remote_device_construct(iport, idev);\n\n\tsci_port_get_properties(iport, &properties);\n\t \n\tidev->device_port_width = hweight32(properties.phy_mask);\n\n\tstatus = sci_controller_allocate_remote_node_context(iport->owning_controller,\n\t\t\t\t\t\t\t     idev,\n\t\t\t\t\t\t\t     &idev->rnc.remote_node_index);\n\n\tif (status != SCI_SUCCESS)\n\t\treturn status;\n\n\tidev->connection_rate = sci_port_get_max_allowed_speed(iport);\n\n\treturn SCI_SUCCESS;\n}\n\n \nstatic enum sci_status sci_remote_device_ea_construct(struct isci_port *iport,\n\t\t\t\t\t\t       struct isci_remote_device *idev)\n{\n\tstruct domain_device *dev = idev->domain_dev;\n\tenum sci_status status;\n\n\tsci_remote_device_construct(iport, idev);\n\n\tstatus = sci_controller_allocate_remote_node_context(iport->owning_controller,\n\t\t\t\t\t\t\t\t  idev,\n\t\t\t\t\t\t\t\t  &idev->rnc.remote_node_index);\n\tif (status != SCI_SUCCESS)\n\t\treturn status;\n\n\t \n\tidev->connection_rate = min_t(u16, sci_port_get_max_allowed_speed(iport),\n\t\t\t\t\t dev->linkrate);\n\n\t \n\tidev->device_port_width = 1;\n\n\treturn SCI_SUCCESS;\n}\n\nenum sci_status sci_remote_device_resume(\n\tstruct isci_remote_device *idev,\n\tscics_sds_remote_node_context_callback cb_fn,\n\tvoid *cb_p)\n{\n\tenum sci_status status;\n\n\tstatus = sci_remote_node_context_resume(&idev->rnc, cb_fn, cb_p);\n\tif (status != SCI_SUCCESS)\n\t\tdev_dbg(scirdev_to_dev(idev), \"%s: failed to resume: %d\\n\",\n\t\t\t__func__, status);\n\treturn status;\n}\n\nstatic void isci_remote_device_resume_from_abort_complete(void *cbparam)\n{\n\tstruct isci_remote_device *idev = cbparam;\n\tstruct isci_host *ihost = idev->owning_port->owning_controller;\n\tscics_sds_remote_node_context_callback abort_resume_cb =\n\t\tidev->abort_resume_cb;\n\n\tdev_dbg(scirdev_to_dev(idev), \"%s: passing-along resume: %p\\n\",\n\t\t__func__, abort_resume_cb);\n\n\tif (abort_resume_cb != NULL) {\n\t\tidev->abort_resume_cb = NULL;\n\t\tabort_resume_cb(idev->abort_resume_cbparam);\n\t}\n\tclear_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);\n\twake_up(&ihost->eventq);\n}\n\nstatic bool isci_remote_device_test_resume_done(\n\tstruct isci_host *ihost,\n\tstruct isci_remote_device *idev)\n{\n\tunsigned long flags;\n\tbool done;\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\tdone = !test_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags)\n\t\t|| test_bit(IDEV_STOP_PENDING, &idev->flags)\n\t\t|| sci_remote_node_context_is_being_destroyed(&idev->rnc);\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\treturn done;\n}\n\nstatic void isci_remote_device_wait_for_resume_from_abort(\n\tstruct isci_host *ihost,\n\tstruct isci_remote_device *idev)\n{\n\tdev_dbg(&ihost->pdev->dev, \"%s: starting resume wait: %p\\n\",\n\t\t __func__, idev);\n\n\t#define MAX_RESUME_MSECS 10000\n\tif (!wait_event_timeout(ihost->eventq,\n\t\t\t\tisci_remote_device_test_resume_done(ihost, idev),\n\t\t\t\tmsecs_to_jiffies(MAX_RESUME_MSECS))) {\n\n\t\tdev_warn(&ihost->pdev->dev, \"%s: #### Timeout waiting for \"\n\t\t\t \"resume: %p\\n\", __func__, idev);\n\t}\n\tclear_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);\n\n\tdev_dbg(&ihost->pdev->dev, \"%s: resume wait done: %p\\n\",\n\t\t __func__, idev);\n}\n\nenum sci_status isci_remote_device_resume_from_abort(\n\tstruct isci_host *ihost,\n\tstruct isci_remote_device *idev)\n{\n\tunsigned long flags;\n\tenum sci_status status = SCI_SUCCESS;\n\tint destroyed;\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\t \n\tidev->abort_resume_cb = idev->rnc.user_callback;\n\tidev->abort_resume_cbparam = idev->rnc.user_cookie;\n\tset_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);\n\tclear_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags);\n\tdestroyed = sci_remote_node_context_is_being_destroyed(&idev->rnc);\n\tif (!destroyed)\n\t\tstatus = sci_remote_device_resume(\n\t\t\tidev, isci_remote_device_resume_from_abort_complete,\n\t\t\tidev);\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\tif (!destroyed && (status == SCI_SUCCESS))\n\t\tisci_remote_device_wait_for_resume_from_abort(ihost, idev);\n\telse\n\t\tclear_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);\n\n\treturn status;\n}\n\n \nstatic enum sci_status sci_remote_device_start(struct isci_remote_device *idev,\n\t\t\t\t\t       u32 timeout)\n{\n\tstruct sci_base_state_machine *sm = &idev->sm;\n\tenum sci_remote_device_states state = sm->current_state_id;\n\tenum sci_status status;\n\n\tif (state != SCI_DEV_STOPPED) {\n\t\tdev_warn(scirdev_to_dev(idev), \"%s: in wrong state: %s\\n\",\n\t\t\t __func__, dev_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n\n\tstatus = sci_remote_device_resume(idev, remote_device_resume_done,\n\t\t\t\t\t  idev);\n\tif (status != SCI_SUCCESS)\n\t\treturn status;\n\n\tsci_change_state(sm, SCI_DEV_STARTING);\n\n\treturn SCI_SUCCESS;\n}\n\nstatic enum sci_status isci_remote_device_construct(struct isci_port *iport,\n\t\t\t\t\t\t    struct isci_remote_device *idev)\n{\n\tstruct isci_host *ihost = iport->isci_host;\n\tstruct domain_device *dev = idev->domain_dev;\n\tenum sci_status status;\n\n\tif (dev->parent && dev_is_expander(dev->parent->dev_type))\n\t\tstatus = sci_remote_device_ea_construct(iport, idev);\n\telse\n\t\tstatus = sci_remote_device_da_construct(iport, idev);\n\n\tif (status != SCI_SUCCESS) {\n\t\tdev_dbg(&ihost->pdev->dev, \"%s: construct failed: %d\\n\",\n\t\t\t__func__, status);\n\n\t\treturn status;\n\t}\n\n\t \n\tstatus = sci_remote_device_start(idev, ISCI_REMOTE_DEVICE_START_TIMEOUT);\n\n\tif (status != SCI_SUCCESS)\n\t\tdev_warn(&ihost->pdev->dev, \"remote device start failed: %d\\n\",\n\t\t\t status);\n\n\treturn status;\n}\n\n \nstatic struct isci_remote_device *\nisci_remote_device_alloc(struct isci_host *ihost, struct isci_port *iport)\n{\n\tstruct isci_remote_device *idev;\n\tint i;\n\n\tfor (i = 0; i < SCI_MAX_REMOTE_DEVICES; i++) {\n\t\tidev = &ihost->devices[i];\n\t\tif (!test_and_set_bit(IDEV_ALLOCATED, &idev->flags))\n\t\t\tbreak;\n\t}\n\n\tif (i >= SCI_MAX_REMOTE_DEVICES) {\n\t\tdev_warn(&ihost->pdev->dev, \"%s: failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tif (WARN_ONCE(!list_empty(&idev->node), \"found non-idle remote device\\n\"))\n\t\treturn NULL;\n\n\treturn idev;\n}\n\nvoid isci_remote_device_release(struct kref *kref)\n{\n\tstruct isci_remote_device *idev = container_of(kref, typeof(*idev), kref);\n\tstruct isci_host *ihost = idev->isci_port->isci_host;\n\n\tidev->domain_dev = NULL;\n\tidev->isci_port = NULL;\n\tclear_bit(IDEV_START_PENDING, &idev->flags);\n\tclear_bit(IDEV_STOP_PENDING, &idev->flags);\n\tclear_bit(IDEV_IO_READY, &idev->flags);\n\tclear_bit(IDEV_GONE, &idev->flags);\n\tsmp_mb__before_atomic();\n\tclear_bit(IDEV_ALLOCATED, &idev->flags);\n\twake_up(&ihost->eventq);\n}\n\n \nenum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_remote_device *idev)\n{\n\tenum sci_status status;\n\tunsigned long flags;\n\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: isci_device = %p\\n\", __func__, idev);\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\tidev->domain_dev->lldd_dev = NULL;  \n\tset_bit(IDEV_GONE, &idev->flags);\n\n\tset_bit(IDEV_STOP_PENDING, &idev->flags);\n\tstatus = sci_remote_device_stop(idev, 50);\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\t \n\tif (WARN_ONCE(status != SCI_SUCCESS, \"failed to stop device\\n\"))\n\t\t ;\n\telse\n\t\twait_for_device_stop(ihost, idev);\n\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: isci_device = %p, waiting done.\\n\", __func__, idev);\n\n\treturn status;\n}\n\n \nvoid isci_remote_device_gone(struct domain_device *dev)\n{\n\tstruct isci_host *ihost = dev_to_ihost(dev);\n\tstruct isci_remote_device *idev = dev->lldd_dev;\n\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: domain_device = %p, isci_device = %p, isci_port = %p\\n\",\n\t\t__func__, dev, idev, idev->isci_port);\n\n\tisci_remote_device_stop(ihost, idev);\n}\n\n\n \nint isci_remote_device_found(struct domain_device *dev)\n{\n\tstruct isci_host *isci_host = dev_to_ihost(dev);\n\tstruct isci_port *isci_port = dev->port->lldd_port;\n\tstruct isci_remote_device *isci_device;\n\tenum sci_status status;\n\n\tdev_dbg(&isci_host->pdev->dev,\n\t\t\"%s: domain_device = %p\\n\", __func__, dev);\n\n\tif (!isci_port)\n\t\treturn -ENODEV;\n\n\tisci_device = isci_remote_device_alloc(isci_host, isci_port);\n\tif (!isci_device)\n\t\treturn -ENODEV;\n\n\tkref_init(&isci_device->kref);\n\tINIT_LIST_HEAD(&isci_device->node);\n\n\tspin_lock_irq(&isci_host->scic_lock);\n\tisci_device->domain_dev = dev;\n\tisci_device->isci_port = isci_port;\n\tlist_add_tail(&isci_device->node, &isci_port->remote_dev_list);\n\n\tset_bit(IDEV_START_PENDING, &isci_device->flags);\n\tstatus = isci_remote_device_construct(isci_port, isci_device);\n\n\tdev_dbg(&isci_host->pdev->dev,\n\t\t\"%s: isci_device = %p\\n\",\n\t\t__func__, isci_device);\n\n\tif (status == SCI_SUCCESS) {\n\t\t \n\t\tdev->lldd_dev = isci_device;\n\t} else\n\t\tisci_put_device(isci_device);\n\tspin_unlock_irq(&isci_host->scic_lock);\n\n\t \n\twait_for_device_start(isci_host, isci_device);\n\n\treturn status == SCI_SUCCESS ? 0 : -ENODEV;\n}\n\nenum sci_status isci_remote_device_suspend_terminate(\n\tstruct isci_host *ihost,\n\tstruct isci_remote_device *idev,\n\tstruct isci_request *ireq)\n{\n\tunsigned long flags;\n\tenum sci_status status;\n\n\t \n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\tset_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags);\n\tsci_remote_device_suspend(idev, SCI_SW_SUSPEND_LINKHANG_DETECT);\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\t \n\tstatus = isci_remote_device_terminate_requests(ihost, idev, ireq);\n\tif (status != SCI_SUCCESS)\n\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t\"%s: isci_remote_device_terminate_requests(%p) \"\n\t\t\t\t\"returned %d!\\n\",\n\t\t\t__func__, idev, status);\n\n\t \n\treturn status;\n}\n\nint isci_remote_device_is_safe_to_abort(\n\tstruct isci_remote_device *idev)\n{\n\treturn sci_remote_node_context_is_safe_to_abort(&idev->rnc);\n}\n\nenum sci_status sci_remote_device_abort_requests_pending_abort(\n\tstruct isci_remote_device *idev)\n{\n\treturn sci_remote_device_terminate_reqs_checkabort(idev, 1);\n}\n\nenum sci_status isci_remote_device_reset_complete(\n\tstruct isci_host *ihost,\n\tstruct isci_remote_device *idev)\n{\n\tunsigned long flags;\n\tenum sci_status status;\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\tstatus = sci_remote_device_reset_complete(idev);\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\treturn status;\n}\n\nvoid isci_dev_set_hang_detection_timeout(\n\tstruct isci_remote_device *idev,\n\tu32 timeout)\n{\n\tif (dev_is_sata(idev->domain_dev)) {\n\t\tif (timeout) {\n\t\t\tif (test_and_set_bit(IDEV_RNC_LLHANG_ENABLED,\n\t\t\t\t\t     &idev->flags))\n\t\t\t\treturn;   \n\t\t} else if (!test_and_clear_bit(IDEV_RNC_LLHANG_ENABLED,\n\t\t\t\t\t       &idev->flags))\n\t\t\treturn;   \n\n\t\tsci_port_set_hang_detection_timeout(idev->owning_port,\n\t\t\t\t\t\t    timeout);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}