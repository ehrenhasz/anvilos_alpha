{
  "module_name": "phy.c",
  "hash_id": "ae63079beada64ea686f4a7da1842ee38ea33a60cfd71c0bf68b2c6dc1fdc9dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/isci/phy.c",
  "human_readable_source": " \n\n#include \"isci.h\"\n#include \"host.h\"\n#include \"phy.h\"\n#include \"scu_event_codes.h\"\n#include \"probe_roms.h\"\n\n#undef C\n#define C(a) (#a)\nstatic const char *phy_state_name(enum sci_phy_states state)\n{\n\tstatic const char * const strings[] = PHY_STATES;\n\n\treturn strings[state];\n}\n#undef C\n\n \n#define SCIC_SDS_PHY_MAX_ARBITRATION_WAIT_TIME  (700)\n\nenum sas_linkrate sci_phy_linkrate(struct isci_phy *iphy)\n{\n\treturn iphy->max_negotiated_speed;\n}\n\nstatic struct isci_host *phy_to_host(struct isci_phy *iphy)\n{\n\tstruct isci_phy *table = iphy - iphy->phy_index;\n\tstruct isci_host *ihost = container_of(table, typeof(*ihost), phys[0]);\n\n\treturn ihost;\n}\n\nstatic struct device *sciphy_to_dev(struct isci_phy *iphy)\n{\n\treturn &phy_to_host(iphy)->pdev->dev;\n}\n\nstatic enum sci_status\nsci_phy_transport_layer_initialization(struct isci_phy *iphy,\n\t\t\t\t       struct scu_transport_layer_registers __iomem *reg)\n{\n\tu32 tl_control;\n\n\tiphy->transport_layer_registers = reg;\n\n\twritel(SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX,\n\t\t&iphy->transport_layer_registers->stp_rni);\n\n\t \n\ttl_control = readl(&iphy->transport_layer_registers->control);\n\ttl_control |= SCU_TLCR_GEN_BIT(STP_WRITE_DATA_PREFETCH);\n\twritel(tl_control, &iphy->transport_layer_registers->control);\n\n\treturn SCI_SUCCESS;\n}\n\nstatic enum sci_status\nsci_phy_link_layer_initialization(struct isci_phy *iphy,\n\t\t\t\t  struct scu_link_layer_registers __iomem *llr)\n{\n\tstruct isci_host *ihost = iphy->owning_port->owning_controller;\n\tstruct sci_phy_user_params *phy_user;\n\tstruct sci_phy_oem_params *phy_oem;\n\tint phy_idx = iphy->phy_index;\n\tstruct sci_phy_cap phy_cap;\n\tu32 phy_configuration;\n\tu32 parity_check = 0;\n\tu32 parity_count = 0;\n\tu32 llctl, link_rate;\n\tu32 clksm_value = 0;\n\tu32 sp_timeouts = 0;\n\n\tphy_user = &ihost->user_parameters.phys[phy_idx];\n\tphy_oem = &ihost->oem_parameters.phys[phy_idx];\n\tiphy->link_layer_registers = llr;\n\n\t \n\t#define SCI_END_DEVICE 0x01\n\n\twritel(SCU_SAS_TIID_GEN_BIT(SMP_INITIATOR) |\n\t       SCU_SAS_TIID_GEN_BIT(SSP_INITIATOR) |\n\t       SCU_SAS_TIID_GEN_BIT(STP_INITIATOR) |\n\t       SCU_SAS_TIID_GEN_BIT(DA_SATA_HOST) |\n\t       SCU_SAS_TIID_GEN_VAL(DEVICE_TYPE, SCI_END_DEVICE),\n\t       &llr->transmit_identification);\n\n\t \n\twritel(0xFEDCBA98, &llr->sas_device_name_high);\n\twritel(phy_idx, &llr->sas_device_name_low);\n\n\t \n\twritel(phy_oem->sas_address.high, &llr->source_sas_address_high);\n\twritel(phy_oem->sas_address.low, &llr->source_sas_address_low);\n\n\t \n\twritel(0, &llr->identify_frame_phy_id);\n\twritel(SCU_SAS_TIPID_GEN_VALUE(ID, phy_idx), &llr->identify_frame_phy_id);\n\n\t \n\tphy_configuration = readl(&llr->phy_configuration);\n\n\t \n\tphy_configuration |=  SCU_SAS_PCFG_GEN_BIT(OOB_RESET);\n\twritel(phy_configuration, &llr->phy_configuration);\n\n\t \n\tphy_cap.all = 0;\n\tphy_cap.start = 1;\n\tphy_cap.gen3_no_ssc = 1;\n\tphy_cap.gen2_no_ssc = 1;\n\tphy_cap.gen1_no_ssc = 1;\n\tif (ihost->oem_parameters.controller.do_enable_ssc) {\n\t\tstruct scu_afe_registers __iomem *afe = &ihost->scu_registers->afe;\n\t\tstruct scu_afe_transceiver __iomem *xcvr = &afe->scu_afe_xcvr[phy_idx];\n\t\tstruct isci_pci_info *pci_info = to_pci_info(ihost->pdev);\n\t\tbool en_sas = false;\n\t\tbool en_sata = false;\n\t\tu32 sas_type = 0;\n\t\tu32 sata_spread = 0x2;\n\t\tu32 sas_spread = 0x2;\n\n\t\tphy_cap.gen3_ssc = 1;\n\t\tphy_cap.gen2_ssc = 1;\n\t\tphy_cap.gen1_ssc = 1;\n\n\t\tif (pci_info->orom->hdr.version < ISCI_ROM_VER_1_1)\n\t\t\ten_sas = en_sata = true;\n\t\telse {\n\t\t\tsata_spread = ihost->oem_parameters.controller.ssc_sata_tx_spread_level;\n\t\t\tsas_spread = ihost->oem_parameters.controller.ssc_sas_tx_spread_level;\n\n\t\t\tif (sata_spread)\n\t\t\t\ten_sata = true;\n\n\t\t\tif (sas_spread) {\n\t\t\t\ten_sas = true;\n\t\t\t\tsas_type = ihost->oem_parameters.controller.ssc_sas_tx_type;\n\t\t\t}\n\n\t\t}\n\n\t\tif (en_sas) {\n\t\t\tu32 reg;\n\n\t\t\treg = readl(&xcvr->afe_xcvr_control0);\n\t\t\treg |= (0x00100000 | (sas_type << 19));\n\t\t\twritel(reg, &xcvr->afe_xcvr_control0);\n\n\t\t\treg = readl(&xcvr->afe_tx_ssc_control);\n\t\t\treg |= sas_spread << 8;\n\t\t\twritel(reg, &xcvr->afe_tx_ssc_control);\n\t\t}\n\n\t\tif (en_sata) {\n\t\t\tu32 reg;\n\n\t\t\treg = readl(&xcvr->afe_tx_ssc_control);\n\t\t\treg |= sata_spread;\n\t\t\twritel(reg, &xcvr->afe_tx_ssc_control);\n\n\t\t\treg = readl(&llr->stp_control);\n\t\t\treg |= 1 << 12;\n\t\t\twritel(reg, &llr->stp_control);\n\t\t}\n\t}\n\n\t \n\tparity_check = phy_cap.all;\n\twhile (parity_check != 0) {\n\t\tif (parity_check & 0x1)\n\t\t\tparity_count++;\n\t\tparity_check >>= 1;\n\t}\n\n\t \n\tif ((parity_count % 2) != 0)\n\t\tphy_cap.parity = 1;\n\n\twritel(phy_cap.all, &llr->phy_capabilities);\n\n\t \n\twritel(SCU_ENSPINUP_GEN_VAL(COUNT,\n\t\t\tphy_user->notify_enable_spin_up_insertion_frequency),\n\t\t&llr->notify_enable_spinup_control);\n\n\t \n\tclksm_value = SCU_ALIGN_INSERTION_FREQUENCY_GEN_VAL(CONNECTED,\n\t\t\tphy_user->in_connection_align_insertion_frequency);\n\n\tclksm_value |= SCU_ALIGN_INSERTION_FREQUENCY_GEN_VAL(GENERAL,\n\t\t\tphy_user->align_insertion_frequency);\n\n\twritel(clksm_value, &llr->clock_skew_management);\n\n\tif (is_c0(ihost->pdev) || is_c1(ihost->pdev)) {\n\t\twritel(0x04210400, &llr->afe_lookup_table_control);\n\t\twritel(0x020A7C05, &llr->sas_primitive_timeout);\n\t} else\n\t\twritel(0x02108421, &llr->afe_lookup_table_control);\n\n\tllctl = SCU_SAS_LLCTL_GEN_VAL(NO_OUTBOUND_TASK_TIMEOUT,\n\t\t(u8)ihost->user_parameters.no_outbound_task_timeout);\n\n\tswitch (phy_user->max_speed_generation) {\n\tcase SCIC_SDS_PARM_GEN3_SPEED:\n\t\tlink_rate = SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN3;\n\t\tbreak;\n\tcase SCIC_SDS_PARM_GEN2_SPEED:\n\t\tlink_rate = SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN2;\n\t\tbreak;\n\tdefault:\n\t\tlink_rate = SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN1;\n\t\tbreak;\n\t}\n\tllctl |= SCU_SAS_LLCTL_GEN_VAL(MAX_LINK_RATE, link_rate);\n\twritel(llctl, &llr->link_layer_control);\n\n\tsp_timeouts = readl(&llr->sas_phy_timeouts);\n\n\t \n\tsp_timeouts &= ~SCU_SAS_PHYTOV_GEN_VAL(RATE_CHANGE, 0xFF);\n\n\t \n\tsp_timeouts |= SCU_SAS_PHYTOV_GEN_VAL(RATE_CHANGE, 0x3B);\n\n\twritel(sp_timeouts, &llr->sas_phy_timeouts);\n\n\tif (is_a2(ihost->pdev)) {\n\t\t \n\t\twritel(SCIC_SDS_PHY_MAX_ARBITRATION_WAIT_TIME,\n\t\t       &llr->maximum_arbitration_wait_timer_timeout);\n\t}\n\n\t \n\twritel(0, &llr->link_layer_hang_detection_timeout);\n\n\t \n\tsci_change_state(&iphy->sm, SCI_PHY_STOPPED);\n\n\treturn SCI_SUCCESS;\n}\n\nstatic void phy_sata_timeout(struct timer_list *t)\n{\n\tstruct sci_timer *tmr = from_timer(tmr, t, timer);\n\tstruct isci_phy *iphy = container_of(tmr, typeof(*iphy), sata_timer);\n\tstruct isci_host *ihost = iphy->owning_port->owning_controller;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\n\tif (tmr->cancel)\n\t\tgoto done;\n\n\tdev_dbg(sciphy_to_dev(iphy),\n\t\t \"%s: SCIC SDS Phy 0x%p did not receive signature fis before \"\n\t\t \"timeout.\\n\",\n\t\t __func__,\n\t\t iphy);\n\n\tsci_change_state(&iphy->sm, SCI_PHY_STARTING);\ndone:\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n}\n\n \nstruct isci_port *phy_get_non_dummy_port(struct isci_phy *iphy)\n{\n\tstruct isci_port *iport = iphy->owning_port;\n\n\tif (iport->physical_port_index == SCIC_SDS_DUMMY_PORT)\n\t\treturn NULL;\n\n\treturn iphy->owning_port;\n}\n\n \nvoid sci_phy_set_port(\n\tstruct isci_phy *iphy,\n\tstruct isci_port *iport)\n{\n\tiphy->owning_port = iport;\n\n\tif (iphy->bcn_received_while_port_unassigned) {\n\t\tiphy->bcn_received_while_port_unassigned = false;\n\t\tsci_port_broadcast_change_received(iphy->owning_port, iphy);\n\t}\n}\n\nenum sci_status sci_phy_initialize(struct isci_phy *iphy,\n\t\t\t\t   struct scu_transport_layer_registers __iomem *tl,\n\t\t\t\t   struct scu_link_layer_registers __iomem *ll)\n{\n\t \n\tsci_phy_transport_layer_initialization(iphy, tl);\n\n\t \n\tsci_phy_link_layer_initialization(iphy, ll);\n\n\t \n\tsci_change_state(&iphy->sm, SCI_PHY_STOPPED);\n\n\treturn SCI_SUCCESS;\n}\n\n \nvoid sci_phy_setup_transport(struct isci_phy *iphy, u32 device_id)\n{\n\tu32 tl_control;\n\n\twritel(device_id, &iphy->transport_layer_registers->stp_rni);\n\n\t \n\ttl_control = readl(&iphy->transport_layer_registers->control);\n\ttl_control |= SCU_TLCR_GEN_BIT(CLEAR_TCI_NCQ_MAPPING_TABLE);\n\twritel(tl_control, &iphy->transport_layer_registers->control);\n}\n\nstatic void sci_phy_suspend(struct isci_phy *iphy)\n{\n\tu32 scu_sas_pcfg_value;\n\n\tscu_sas_pcfg_value =\n\t\treadl(&iphy->link_layer_registers->phy_configuration);\n\tscu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE);\n\twritel(scu_sas_pcfg_value,\n\t\t&iphy->link_layer_registers->phy_configuration);\n\n\tsci_phy_setup_transport(iphy, SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);\n}\n\nvoid sci_phy_resume(struct isci_phy *iphy)\n{\n\tu32 scu_sas_pcfg_value;\n\n\tscu_sas_pcfg_value =\n\t\treadl(&iphy->link_layer_registers->phy_configuration);\n\tscu_sas_pcfg_value &= ~SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE);\n\twritel(scu_sas_pcfg_value,\n\t\t&iphy->link_layer_registers->phy_configuration);\n}\n\nvoid sci_phy_get_sas_address(struct isci_phy *iphy, struct sci_sas_address *sas)\n{\n\tsas->high = readl(&iphy->link_layer_registers->source_sas_address_high);\n\tsas->low = readl(&iphy->link_layer_registers->source_sas_address_low);\n}\n\nvoid sci_phy_get_attached_sas_address(struct isci_phy *iphy, struct sci_sas_address *sas)\n{\n\tstruct sas_identify_frame *iaf;\n\n\tiaf = &iphy->frame_rcvd.iaf;\n\tmemcpy(sas, iaf->sas_addr, SAS_ADDR_SIZE);\n}\n\nvoid sci_phy_get_protocols(struct isci_phy *iphy, struct sci_phy_proto *proto)\n{\n\tproto->all = readl(&iphy->link_layer_registers->transmit_identification);\n}\n\nenum sci_status sci_phy_start(struct isci_phy *iphy)\n{\n\tenum sci_phy_states state = iphy->sm.current_state_id;\n\n\tif (state != SCI_PHY_STOPPED) {\n\t\tdev_dbg(sciphy_to_dev(iphy), \"%s: in wrong state: %s\\n\",\n\t\t\t__func__, phy_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n\n\tsci_change_state(&iphy->sm, SCI_PHY_STARTING);\n\treturn SCI_SUCCESS;\n}\n\nenum sci_status sci_phy_stop(struct isci_phy *iphy)\n{\n\tenum sci_phy_states state = iphy->sm.current_state_id;\n\n\tswitch (state) {\n\tcase SCI_PHY_SUB_INITIAL:\n\tcase SCI_PHY_SUB_AWAIT_OSSP_EN:\n\tcase SCI_PHY_SUB_AWAIT_SAS_SPEED_EN:\n\tcase SCI_PHY_SUB_AWAIT_SAS_POWER:\n\tcase SCI_PHY_SUB_AWAIT_SATA_POWER:\n\tcase SCI_PHY_SUB_AWAIT_SATA_PHY_EN:\n\tcase SCI_PHY_SUB_AWAIT_SATA_SPEED_EN:\n\tcase SCI_PHY_SUB_AWAIT_SIG_FIS_UF:\n\tcase SCI_PHY_SUB_FINAL:\n\tcase SCI_PHY_READY:\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(sciphy_to_dev(iphy), \"%s: in wrong state: %s\\n\",\n\t\t\t__func__, phy_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n\n\tsci_change_state(&iphy->sm, SCI_PHY_STOPPED);\n\treturn SCI_SUCCESS;\n}\n\nenum sci_status sci_phy_reset(struct isci_phy *iphy)\n{\n\tenum sci_phy_states state = iphy->sm.current_state_id;\n\n\tif (state != SCI_PHY_READY) {\n\t\tdev_dbg(sciphy_to_dev(iphy), \"%s: in wrong state: %s\\n\",\n\t\t\t__func__, phy_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n\n\tsci_change_state(&iphy->sm, SCI_PHY_RESETTING);\n\treturn SCI_SUCCESS;\n}\n\nenum sci_status sci_phy_consume_power_handler(struct isci_phy *iphy)\n{\n\tenum sci_phy_states state = iphy->sm.current_state_id;\n\n\tswitch (state) {\n\tcase SCI_PHY_SUB_AWAIT_SAS_POWER: {\n\t\tu32 enable_spinup;\n\n\t\tenable_spinup = readl(&iphy->link_layer_registers->notify_enable_spinup_control);\n\t\tenable_spinup |= SCU_ENSPINUP_GEN_BIT(ENABLE);\n\t\twritel(enable_spinup, &iphy->link_layer_registers->notify_enable_spinup_control);\n\n\t\t \n\t\tsci_change_state(&iphy->sm, SCI_PHY_SUB_FINAL);\n\n\t\treturn SCI_SUCCESS;\n\t}\n\tcase SCI_PHY_SUB_AWAIT_SATA_POWER: {\n\t\tu32 scu_sas_pcfg_value;\n\n\t\t \n\t\tscu_sas_pcfg_value =\n\t\t\treadl(&iphy->link_layer_registers->phy_configuration);\n\t\tscu_sas_pcfg_value &=\n\t\t\t~(SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD) | SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE));\n\t\tscu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_RESET);\n\t\twritel(scu_sas_pcfg_value,\n\t\t\t&iphy->link_layer_registers->phy_configuration);\n\n\t\t \n\t\tscu_sas_pcfg_value &= ~SCU_SAS_PCFG_GEN_BIT(OOB_RESET);\n\t\tscu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);\n\t\twritel(scu_sas_pcfg_value,\n\t\t\t&iphy->link_layer_registers->phy_configuration);\n\n\t\t \n\t\tsci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_PHY_EN);\n\n\t\treturn SCI_SUCCESS;\n\t}\n\tdefault:\n\t\tdev_dbg(sciphy_to_dev(iphy), \"%s: in wrong state: %s\\n\",\n\t\t\t__func__, phy_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n}\n\nstatic void sci_phy_start_sas_link_training(struct isci_phy *iphy)\n{\n\t \n\tu32 phy_control;\n\n\tphy_control = readl(&iphy->link_layer_registers->phy_configuration);\n\tphy_control |= SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD);\n\twritel(phy_control,\n\t       &iphy->link_layer_registers->phy_configuration);\n\n\tsci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SAS_SPEED_EN);\n\n\tiphy->protocol = SAS_PROTOCOL_SSP;\n}\n\nstatic void sci_phy_start_sata_link_training(struct isci_phy *iphy)\n{\n\t \n\tsci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_POWER);\n\n\tiphy->protocol = SAS_PROTOCOL_SATA;\n}\n\n \nstatic void sci_phy_complete_link_training(struct isci_phy *iphy,\n\t\t\t\t\t   enum sas_linkrate max_link_rate,\n\t\t\t\t\t   u32 next_state)\n{\n\tiphy->max_negotiated_speed = max_link_rate;\n\n\tsci_change_state(&iphy->sm, next_state);\n}\n\nstatic const char *phy_event_name(u32 event_code)\n{\n\tswitch (scu_get_event_code(event_code)) {\n\tcase SCU_EVENT_PORT_SELECTOR_DETECTED:\n\t\treturn \"port selector\";\n\tcase SCU_EVENT_SENT_PORT_SELECTION:\n\t\treturn \"port selection\";\n\tcase SCU_EVENT_HARD_RESET_TRANSMITTED:\n\t\treturn \"tx hard reset\";\n\tcase SCU_EVENT_HARD_RESET_RECEIVED:\n\t\treturn \"rx hard reset\";\n\tcase SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:\n\t\treturn \"identify timeout\";\n\tcase SCU_EVENT_LINK_FAILURE:\n\t\treturn \"link fail\";\n\tcase SCU_EVENT_SATA_SPINUP_HOLD:\n\t\treturn \"sata spinup hold\";\n\tcase SCU_EVENT_SAS_15_SSC:\n\tcase SCU_EVENT_SAS_15:\n\t\treturn \"sas 1.5\";\n\tcase SCU_EVENT_SAS_30_SSC:\n\tcase SCU_EVENT_SAS_30:\n\t\treturn \"sas 3.0\";\n\tcase SCU_EVENT_SAS_60_SSC:\n\tcase SCU_EVENT_SAS_60:\n\t\treturn \"sas 6.0\";\n\tcase SCU_EVENT_SATA_15_SSC:\n\tcase SCU_EVENT_SATA_15:\n\t\treturn \"sata 1.5\";\n\tcase SCU_EVENT_SATA_30_SSC:\n\tcase SCU_EVENT_SATA_30:\n\t\treturn \"sata 3.0\";\n\tcase SCU_EVENT_SATA_60_SSC:\n\tcase SCU_EVENT_SATA_60:\n\t\treturn \"sata 6.0\";\n\tcase SCU_EVENT_SAS_PHY_DETECTED:\n\t\treturn \"sas detect\";\n\tcase SCU_EVENT_SATA_PHY_DETECTED:\n\t\treturn \"sata detect\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n#define phy_event_dbg(iphy, state, code) \\\n\tdev_dbg(sciphy_to_dev(iphy), \"phy-%d:%d: %s event: %s (%x)\\n\", \\\n\t\tphy_to_host(iphy)->id, iphy->phy_index, \\\n\t\tphy_state_name(state), phy_event_name(code), code)\n\n#define phy_event_warn(iphy, state, code) \\\n\tdev_warn(sciphy_to_dev(iphy), \"phy-%d:%d: %s event: %s (%x)\\n\", \\\n\t\tphy_to_host(iphy)->id, iphy->phy_index, \\\n\t\tphy_state_name(state), phy_event_name(code), code)\n\n\nstatic void scu_link_layer_set_txcomsas_timeout(struct isci_phy *iphy, u32 timeout)\n{\n\tu32 val;\n\n\t \n\tval = readl(&iphy->link_layer_registers->transmit_comsas_signal);\n\tval &= ~SCU_SAS_LLTXCOMSAS_GEN_VAL(NEGTIME, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_MASK);\n\tval |= SCU_SAS_LLTXCOMSAS_GEN_VAL(NEGTIME, timeout);\n\n\twritel(val, &iphy->link_layer_registers->transmit_comsas_signal);\n}\n\nenum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)\n{\n\tenum sci_phy_states state = iphy->sm.current_state_id;\n\n\tswitch (state) {\n\tcase SCI_PHY_SUB_AWAIT_OSSP_EN:\n\t\tswitch (scu_get_event_code(event_code)) {\n\t\tcase SCU_EVENT_SAS_PHY_DETECTED:\n\t\t\tsci_phy_start_sas_link_training(iphy);\n\t\t\tiphy->is_in_link_training = true;\n\t\t\tbreak;\n\t\tcase SCU_EVENT_SATA_SPINUP_HOLD:\n\t\t\tsci_phy_start_sata_link_training(iphy);\n\t\t\tiphy->is_in_link_training = true;\n\t\t\tbreak;\n\t\tcase SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:\n\t\t        \n\t\t       scu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_EXTENDED);\n\n\t\t        \n\t\t       sci_change_state(&iphy->sm, SCI_PHY_STARTING);\n\t\t       break;\n\t\tdefault:\n\t\t\tphy_event_dbg(iphy, state, event_code);\n\t\t\treturn SCI_FAILURE;\n\t\t}\n\t\treturn SCI_SUCCESS;\n\tcase SCI_PHY_SUB_AWAIT_SAS_SPEED_EN:\n\t\tswitch (scu_get_event_code(event_code)) {\n\t\tcase SCU_EVENT_SAS_PHY_DETECTED:\n\t\t\t \n\t\t\tbreak;\n\t\tcase SCU_EVENT_SAS_15:\n\t\tcase SCU_EVENT_SAS_15_SSC:\n\t\t\tsci_phy_complete_link_training(iphy, SAS_LINK_RATE_1_5_GBPS,\n\t\t\t\t\t\t       SCI_PHY_SUB_AWAIT_IAF_UF);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_SAS_30:\n\t\tcase SCU_EVENT_SAS_30_SSC:\n\t\t\tsci_phy_complete_link_training(iphy, SAS_LINK_RATE_3_0_GBPS,\n\t\t\t\t\t\t       SCI_PHY_SUB_AWAIT_IAF_UF);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_SAS_60:\n\t\tcase SCU_EVENT_SAS_60_SSC:\n\t\t\tsci_phy_complete_link_training(iphy, SAS_LINK_RATE_6_0_GBPS,\n\t\t\t\t\t\t       SCI_PHY_SUB_AWAIT_IAF_UF);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_SATA_SPINUP_HOLD:\n\t\t\t \n\t\t\tsci_phy_start_sata_link_training(iphy);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_LINK_FAILURE:\n\t\t\t \n\t\t\tscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\n\n\t\t\t \n\t\t\tsci_change_state(&iphy->sm, SCI_PHY_STARTING);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:\n\t\t        \n\t\t       scu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_EXTENDED);\n\n\t\t        \n\t\t       sci_change_state(&iphy->sm, SCI_PHY_STARTING);\n\t\t       break;\n\t\tdefault:\n\t\t\tphy_event_warn(iphy, state, event_code);\n\t\t\treturn SCI_FAILURE;\n\t\t}\n\t\treturn SCI_SUCCESS;\n\tcase SCI_PHY_SUB_AWAIT_IAF_UF:\n\t\tswitch (scu_get_event_code(event_code)) {\n\t\tcase SCU_EVENT_SAS_PHY_DETECTED:\n\t\t\t \n\t\t\tsci_phy_start_sas_link_training(iphy);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_SATA_SPINUP_HOLD:\n\t\t\t \n\t\t\tsci_phy_start_sata_link_training(iphy);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:\n\t\t\t \n\t\t\tscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_EXTENDED);\n\n\t\t\t \n\t\t\tsci_change_state(&iphy->sm, SCI_PHY_STARTING);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_LINK_FAILURE:\n\t\t\tscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\n\t\t\tfallthrough;\n\t\tcase SCU_EVENT_HARD_RESET_RECEIVED:\n\t\t\t \n\t\t\tsci_change_state(&iphy->sm, SCI_PHY_STARTING);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphy_event_warn(iphy, state, event_code);\n\t\t\treturn SCI_FAILURE;\n\t\t}\n\t\treturn SCI_SUCCESS;\n\tcase SCI_PHY_SUB_AWAIT_SAS_POWER:\n\t\tswitch (scu_get_event_code(event_code)) {\n\t\tcase SCU_EVENT_LINK_FAILURE:\n\t\t\t \n\t\t\tscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\n\n\t\t\t \n\t\t\tsci_change_state(&iphy->sm, SCI_PHY_STARTING);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphy_event_warn(iphy, state, event_code);\n\t\t\treturn SCI_FAILURE;\n\t\t}\n\t\treturn SCI_SUCCESS;\n\tcase SCI_PHY_SUB_AWAIT_SATA_POWER:\n\t\tswitch (scu_get_event_code(event_code)) {\n\t\tcase SCU_EVENT_LINK_FAILURE:\n\t\t\t \n\t\t\tscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\n\n\t\t\t \n\t\t\tsci_change_state(&iphy->sm, SCI_PHY_STARTING);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_SATA_SPINUP_HOLD:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase SCU_EVENT_SAS_PHY_DETECTED:\n\t\t\t \n\t\t\tsci_phy_start_sas_link_training(iphy);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphy_event_warn(iphy, state, event_code);\n\t\t\treturn SCI_FAILURE;\n\t\t}\n\t\treturn SCI_SUCCESS;\n\tcase SCI_PHY_SUB_AWAIT_SATA_PHY_EN:\n\t\tswitch (scu_get_event_code(event_code)) {\n\t\tcase SCU_EVENT_LINK_FAILURE:\n\t\t\t \n\t\t\tscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\n\n\t\t\t \n\t\t\tsci_change_state(&iphy->sm, SCI_PHY_STARTING);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_SATA_SPINUP_HOLD:\n\t\t\t \n\t\t\tbreak;\n\t\tcase SCU_EVENT_SATA_PHY_DETECTED:\n\t\t\tiphy->protocol = SAS_PROTOCOL_SATA;\n\n\t\t\t \n\t\t\tsci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_SPEED_EN);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_SAS_PHY_DETECTED:\n\t\t\t \n\t\t\tsci_phy_start_sas_link_training(iphy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphy_event_warn(iphy, state, event_code);\n\t\t\treturn SCI_FAILURE;\n\t\t}\n\t\treturn SCI_SUCCESS;\n\tcase SCI_PHY_SUB_AWAIT_SATA_SPEED_EN:\n\t\tswitch (scu_get_event_code(event_code)) {\n\t\tcase SCU_EVENT_SATA_PHY_DETECTED:\n\t\t\t \n\t\t\tbreak;\n\t\tcase SCU_EVENT_SATA_15:\n\t\tcase SCU_EVENT_SATA_15_SSC:\n\t\t\tsci_phy_complete_link_training(iphy, SAS_LINK_RATE_1_5_GBPS,\n\t\t\t\t\t\t       SCI_PHY_SUB_AWAIT_SIG_FIS_UF);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_SATA_30:\n\t\tcase SCU_EVENT_SATA_30_SSC:\n\t\t\tsci_phy_complete_link_training(iphy, SAS_LINK_RATE_3_0_GBPS,\n\t\t\t\t\t\t       SCI_PHY_SUB_AWAIT_SIG_FIS_UF);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_SATA_60:\n\t\tcase SCU_EVENT_SATA_60_SSC:\n\t\t\tsci_phy_complete_link_training(iphy, SAS_LINK_RATE_6_0_GBPS,\n\t\t\t\t\t\t       SCI_PHY_SUB_AWAIT_SIG_FIS_UF);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_LINK_FAILURE:\n\t\t\t \n\t\t\tscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\n\n\t\t\t \n\t\t\tsci_change_state(&iphy->sm, SCI_PHY_STARTING);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_SAS_PHY_DETECTED:\n\t\t\t \n\t\t\tsci_phy_start_sas_link_training(iphy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphy_event_warn(iphy, state, event_code);\n\t\t\treturn SCI_FAILURE;\n\t\t}\n\n\t\treturn SCI_SUCCESS;\n\tcase SCI_PHY_SUB_AWAIT_SIG_FIS_UF:\n\t\tswitch (scu_get_event_code(event_code)) {\n\t\tcase SCU_EVENT_SATA_PHY_DETECTED:\n\t\t\t \n\t\t\tsci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_SPEED_EN);\n\t\t\tbreak;\n\n\t\tcase SCU_EVENT_LINK_FAILURE:\n\t\t\t \n\t\t\tscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\n\n\t\t\t \n\t\t\tsci_change_state(&iphy->sm, SCI_PHY_STARTING);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphy_event_warn(iphy, state, event_code);\n\t\t\treturn SCI_FAILURE;\n\t\t}\n\t\treturn SCI_SUCCESS;\n\tcase SCI_PHY_READY:\n\t\tswitch (scu_get_event_code(event_code)) {\n\t\tcase SCU_EVENT_LINK_FAILURE:\n\t\t\t \n\t\t\tscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\n\n\t\t\t \n\t\t\tsci_change_state(&iphy->sm, SCI_PHY_STARTING);\n\t\t\tbreak;\n\t\tcase SCU_EVENT_BROADCAST_CHANGE:\n\t\tcase SCU_EVENT_BROADCAST_SES:\n\t\tcase SCU_EVENT_BROADCAST_RESERVED0:\n\t\tcase SCU_EVENT_BROADCAST_RESERVED1:\n\t\tcase SCU_EVENT_BROADCAST_EXPANDER:\n\t\tcase SCU_EVENT_BROADCAST_AEN:\n\t\t\t \n\t\t\tif (phy_get_non_dummy_port(iphy) != NULL)\n\t\t\t\tsci_port_broadcast_change_received(iphy->owning_port, iphy);\n\t\t\telse\n\t\t\t\tiphy->bcn_received_while_port_unassigned = true;\n\t\t\tbreak;\n\t\tcase SCU_EVENT_BROADCAST_RESERVED3:\n\t\tcase SCU_EVENT_BROADCAST_RESERVED4:\n\t\tdefault:\n\t\t\tphy_event_warn(iphy, state, event_code);\n\t\t\treturn SCI_FAILURE_INVALID_STATE;\n\t\t}\n\t\treturn SCI_SUCCESS;\n\tcase SCI_PHY_RESETTING:\n\t\tswitch (scu_get_event_code(event_code)) {\n\t\tcase SCU_EVENT_HARD_RESET_TRANSMITTED:\n\t\t\t \n\t\t\tsci_change_state(&iphy->sm, SCI_PHY_STARTING);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphy_event_warn(iphy, state, event_code);\n\t\t\treturn SCI_FAILURE_INVALID_STATE;\n\t\t}\n\t\treturn SCI_SUCCESS;\n\tdefault:\n\t\tdev_dbg(sciphy_to_dev(iphy), \"%s: in wrong state: %s\\n\",\n\t\t\t__func__, phy_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n}\n\nenum sci_status sci_phy_frame_handler(struct isci_phy *iphy, u32 frame_index)\n{\n\tenum sci_phy_states state = iphy->sm.current_state_id;\n\tstruct isci_host *ihost = iphy->owning_port->owning_controller;\n\tenum sci_status result;\n\tunsigned long flags;\n\n\tswitch (state) {\n\tcase SCI_PHY_SUB_AWAIT_IAF_UF: {\n\t\tu32 *frame_words;\n\t\tstruct sas_identify_frame iaf;\n\n\t\tresult = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\n\t\t\t\t\t\t\t\t  frame_index,\n\t\t\t\t\t\t\t\t  (void **)&frame_words);\n\n\t\tif (result != SCI_SUCCESS)\n\t\t\treturn result;\n\n\t\tsci_swab32_cpy(&iaf, frame_words, sizeof(iaf) / sizeof(u32));\n\t\tif (iaf.frame_type == 0) {\n\t\t\tu32 state;\n\n\t\t\tspin_lock_irqsave(&iphy->sas_phy.frame_rcvd_lock, flags);\n\t\t\tmemcpy(&iphy->frame_rcvd.iaf, &iaf, sizeof(iaf));\n\t\t\tspin_unlock_irqrestore(&iphy->sas_phy.frame_rcvd_lock, flags);\n\t\t\tif (iaf.smp_tport) {\n\t\t\t\t \n\t\t\t\tstate = SCI_PHY_SUB_FINAL;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tstate = SCI_PHY_SUB_AWAIT_SAS_POWER;\n\t\t\t}\n\t\t\tsci_change_state(&iphy->sm, state);\n\t\t\tresult = SCI_SUCCESS;\n\t\t} else\n\t\t\tdev_warn(sciphy_to_dev(iphy),\n\t\t\t\t\"%s: PHY starting substate machine received \"\n\t\t\t\t\"unexpected frame id %x\\n\",\n\t\t\t\t__func__, frame_index);\n\n\t\tsci_controller_release_frame(ihost, frame_index);\n\t\treturn result;\n\t}\n\tcase SCI_PHY_SUB_AWAIT_SIG_FIS_UF: {\n\t\tstruct dev_to_host_fis *frame_header;\n\t\tu32 *fis_frame_data;\n\n\t\tresult = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\n\t\t\t\t\t\t\t\t  frame_index,\n\t\t\t\t\t\t\t\t  (void **)&frame_header);\n\n\t\tif (result != SCI_SUCCESS)\n\t\t\treturn result;\n\n\t\tif ((frame_header->fis_type == FIS_REGD2H) &&\n\t\t    !(frame_header->status & ATA_BUSY)) {\n\t\t\tsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\n\t\t\t\t\t\t\t\t frame_index,\n\t\t\t\t\t\t\t\t (void **)&fis_frame_data);\n\n\t\t\tspin_lock_irqsave(&iphy->sas_phy.frame_rcvd_lock, flags);\n\t\t\tsci_controller_copy_sata_response(&iphy->frame_rcvd.fis,\n\t\t\t\t\t\t\t  frame_header,\n\t\t\t\t\t\t\t  fis_frame_data);\n\t\t\tspin_unlock_irqrestore(&iphy->sas_phy.frame_rcvd_lock, flags);\n\n\t\t\t \n\t\t\tsci_change_state(&iphy->sm, SCI_PHY_SUB_FINAL);\n\n\t\t\tresult = SCI_SUCCESS;\n\t\t} else\n\t\t\tdev_warn(sciphy_to_dev(iphy),\n\t\t\t\t \"%s: PHY starting substate machine received \"\n\t\t\t\t \"unexpected frame id %x\\n\",\n\t\t\t\t __func__, frame_index);\n\n\t\t \n\t\tsci_controller_release_frame(ihost, frame_index);\n\n\t\treturn result;\n\t}\n\tdefault:\n\t\tdev_dbg(sciphy_to_dev(iphy), \"%s: in wrong state: %s\\n\",\n\t\t\t__func__, phy_state_name(state));\n\t\treturn SCI_FAILURE_INVALID_STATE;\n\t}\n\n}\n\nstatic void sci_phy_starting_initial_substate_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\n\t \n\tsci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_OSSP_EN);\n}\n\nstatic void sci_phy_starting_await_sas_power_substate_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\tstruct isci_host *ihost = iphy->owning_port->owning_controller;\n\n\tsci_controller_power_control_queue_insert(ihost, iphy);\n}\n\nstatic void sci_phy_starting_await_sas_power_substate_exit(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\tstruct isci_host *ihost = iphy->owning_port->owning_controller;\n\n\tsci_controller_power_control_queue_remove(ihost, iphy);\n}\n\nstatic void sci_phy_starting_await_sata_power_substate_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\tstruct isci_host *ihost = iphy->owning_port->owning_controller;\n\n\tsci_controller_power_control_queue_insert(ihost, iphy);\n}\n\nstatic void sci_phy_starting_await_sata_power_substate_exit(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\tstruct isci_host *ihost = iphy->owning_port->owning_controller;\n\n\tsci_controller_power_control_queue_remove(ihost, iphy);\n}\n\nstatic void sci_phy_starting_await_sata_phy_substate_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\n\tsci_mod_timer(&iphy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);\n}\n\nstatic void sci_phy_starting_await_sata_phy_substate_exit(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\n\tsci_del_timer(&iphy->sata_timer);\n}\n\nstatic void sci_phy_starting_await_sata_speed_substate_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\n\tsci_mod_timer(&iphy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);\n}\n\nstatic void sci_phy_starting_await_sata_speed_substate_exit(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\n\tsci_del_timer(&iphy->sata_timer);\n}\n\nstatic void sci_phy_starting_await_sig_fis_uf_substate_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\n\tif (sci_port_link_detected(iphy->owning_port, iphy)) {\n\n\t\t \n\t\tsci_phy_resume(iphy);\n\n\t\tsci_mod_timer(&iphy->sata_timer,\n\t\t\t      SCIC_SDS_SIGNATURE_FIS_TIMEOUT);\n\t} else\n\t\tiphy->is_in_link_training = false;\n}\n\nstatic void sci_phy_starting_await_sig_fis_uf_substate_exit(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\n\tsci_del_timer(&iphy->sata_timer);\n}\n\nstatic void sci_phy_starting_final_substate_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\n\t \n\tsci_change_state(&iphy->sm, SCI_PHY_READY);\n}\n\n \nstatic void scu_link_layer_stop_protocol_engine(\n\tstruct isci_phy *iphy)\n{\n\tu32 scu_sas_pcfg_value;\n\tu32 enable_spinup_value;\n\n\t \n\tscu_sas_pcfg_value =\n\t\treadl(&iphy->link_layer_registers->phy_configuration);\n\tscu_sas_pcfg_value |=\n\t\t(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) |\n\t\t SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE) |\n\t\t SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD));\n\twritel(scu_sas_pcfg_value,\n\t       &iphy->link_layer_registers->phy_configuration);\n\n\t \n\tenable_spinup_value = readl(&iphy->link_layer_registers->notify_enable_spinup_control);\n\tenable_spinup_value &= ~SCU_ENSPINUP_GEN_BIT(ENABLE);\n\twritel(enable_spinup_value, &iphy->link_layer_registers->notify_enable_spinup_control);\n}\n\nstatic void scu_link_layer_start_oob(struct isci_phy *iphy)\n{\n\tstruct scu_link_layer_registers __iomem *ll = iphy->link_layer_registers;\n\tu32 val;\n\n\t \n\tval = readl(&ll->phy_configuration);\n\tval &= ~(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) |\n\t\t SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE) |\n\t\t SCU_SAS_PCFG_GEN_BIT(HARD_RESET));\n\twritel(val, &ll->phy_configuration);\n\treadl(&ll->phy_configuration);  \n\t \n\n\t \n\tval = readl(&ll->phy_configuration);\n\tval |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);\n\twritel(val, &ll->phy_configuration);\n\treadl(&ll->phy_configuration);  \n\t \n}\n\n \nstatic void scu_link_layer_tx_hard_reset(\n\tstruct isci_phy *iphy)\n{\n\tu32 phy_configuration_value;\n\n\t \n\tphy_configuration_value =\n\t\treadl(&iphy->link_layer_registers->phy_configuration);\n\tphy_configuration_value &= ~(SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE));\n\tphy_configuration_value |=\n\t\t(SCU_SAS_PCFG_GEN_BIT(HARD_RESET) |\n\t\t SCU_SAS_PCFG_GEN_BIT(OOB_RESET));\n\twritel(phy_configuration_value,\n\t       &iphy->link_layer_registers->phy_configuration);\n\n\t \n\tphy_configuration_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);\n\tphy_configuration_value &= ~SCU_SAS_PCFG_GEN_BIT(OOB_RESET);\n\twritel(phy_configuration_value,\n\t       &iphy->link_layer_registers->phy_configuration);\n}\n\nstatic void sci_phy_stopped_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\tstruct isci_port *iport = iphy->owning_port;\n\tstruct isci_host *ihost = iport->owning_controller;\n\n\t \n\tsci_del_timer(&iphy->sata_timer);\n\n\tscu_link_layer_stop_protocol_engine(iphy);\n\n\tif (iphy->sm.previous_state_id != SCI_PHY_INITIAL)\n\t\tsci_controller_link_down(ihost, phy_get_non_dummy_port(iphy), iphy);\n}\n\nstatic void sci_phy_starting_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\tstruct isci_port *iport = iphy->owning_port;\n\tstruct isci_host *ihost = iport->owning_controller;\n\n\tscu_link_layer_stop_protocol_engine(iphy);\n\tscu_link_layer_start_oob(iphy);\n\n\t \n\tiphy->protocol = SAS_PROTOCOL_NONE;\n\tiphy->bcn_received_while_port_unassigned = false;\n\n\tif (iphy->sm.previous_state_id == SCI_PHY_READY)\n\t\tsci_controller_link_down(ihost, phy_get_non_dummy_port(iphy), iphy);\n\n\tsci_change_state(&iphy->sm, SCI_PHY_SUB_INITIAL);\n}\n\nstatic void sci_phy_ready_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\tstruct isci_port *iport = iphy->owning_port;\n\tstruct isci_host *ihost = iport->owning_controller;\n\n\tsci_controller_link_up(ihost, phy_get_non_dummy_port(iphy), iphy);\n}\n\nstatic void sci_phy_ready_state_exit(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\n\tsci_phy_suspend(iphy);\n}\n\nstatic void sci_phy_resetting_state_enter(struct sci_base_state_machine *sm)\n{\n\tstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\n\n\t \n\tsci_port_deactivate_phy(iphy->owning_port, iphy, false);\n\n\tif (iphy->protocol == SAS_PROTOCOL_SSP) {\n\t\tscu_link_layer_tx_hard_reset(iphy);\n\t} else {\n\t\t \n\t\tsci_change_state(&iphy->sm, SCI_PHY_STARTING);\n\t}\n}\n\nstatic const struct sci_base_state sci_phy_state_table[] = {\n\t[SCI_PHY_INITIAL] = { },\n\t[SCI_PHY_STOPPED] = {\n\t\t.enter_state = sci_phy_stopped_state_enter,\n\t},\n\t[SCI_PHY_STARTING] = {\n\t\t.enter_state = sci_phy_starting_state_enter,\n\t},\n\t[SCI_PHY_SUB_INITIAL] = {\n\t\t.enter_state = sci_phy_starting_initial_substate_enter,\n\t},\n\t[SCI_PHY_SUB_AWAIT_OSSP_EN] = { },\n\t[SCI_PHY_SUB_AWAIT_SAS_SPEED_EN] = { },\n\t[SCI_PHY_SUB_AWAIT_IAF_UF] = { },\n\t[SCI_PHY_SUB_AWAIT_SAS_POWER] = {\n\t\t.enter_state = sci_phy_starting_await_sas_power_substate_enter,\n\t\t.exit_state  = sci_phy_starting_await_sas_power_substate_exit,\n\t},\n\t[SCI_PHY_SUB_AWAIT_SATA_POWER] = {\n\t\t.enter_state = sci_phy_starting_await_sata_power_substate_enter,\n\t\t.exit_state  = sci_phy_starting_await_sata_power_substate_exit\n\t},\n\t[SCI_PHY_SUB_AWAIT_SATA_PHY_EN] = {\n\t\t.enter_state = sci_phy_starting_await_sata_phy_substate_enter,\n\t\t.exit_state  = sci_phy_starting_await_sata_phy_substate_exit\n\t},\n\t[SCI_PHY_SUB_AWAIT_SATA_SPEED_EN] = {\n\t\t.enter_state = sci_phy_starting_await_sata_speed_substate_enter,\n\t\t.exit_state  = sci_phy_starting_await_sata_speed_substate_exit\n\t},\n\t[SCI_PHY_SUB_AWAIT_SIG_FIS_UF] = {\n\t\t.enter_state = sci_phy_starting_await_sig_fis_uf_substate_enter,\n\t\t.exit_state  = sci_phy_starting_await_sig_fis_uf_substate_exit\n\t},\n\t[SCI_PHY_SUB_FINAL] = {\n\t\t.enter_state = sci_phy_starting_final_substate_enter,\n\t},\n\t[SCI_PHY_READY] = {\n\t\t.enter_state = sci_phy_ready_state_enter,\n\t\t.exit_state = sci_phy_ready_state_exit,\n\t},\n\t[SCI_PHY_RESETTING] = {\n\t\t.enter_state = sci_phy_resetting_state_enter,\n\t},\n\t[SCI_PHY_FINAL] = { },\n};\n\nvoid sci_phy_construct(struct isci_phy *iphy,\n\t\t\t    struct isci_port *iport, u8 phy_index)\n{\n\tsci_init_sm(&iphy->sm, sci_phy_state_table, SCI_PHY_INITIAL);\n\n\t \n\tiphy->owning_port = iport;\n\tiphy->phy_index = phy_index;\n\tiphy->bcn_received_while_port_unassigned = false;\n\tiphy->protocol = SAS_PROTOCOL_NONE;\n\tiphy->link_layer_registers = NULL;\n\tiphy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;\n\n\t \n\tsci_init_timer(&iphy->sata_timer, phy_sata_timeout);\n}\n\nvoid isci_phy_init(struct isci_phy *iphy, struct isci_host *ihost, int index)\n{\n\tstruct sci_oem_params *oem = &ihost->oem_parameters;\n\tu64 sci_sas_addr;\n\t__be64 sas_addr;\n\n\tsci_sas_addr = oem->phys[index].sas_address.high;\n\tsci_sas_addr <<= 32;\n\tsci_sas_addr |= oem->phys[index].sas_address.low;\n\tsas_addr = cpu_to_be64(sci_sas_addr);\n\tmemcpy(iphy->sas_addr, &sas_addr, sizeof(sas_addr));\n\n\tiphy->sas_phy.enabled = 0;\n\tiphy->sas_phy.id = index;\n\tiphy->sas_phy.sas_addr = &iphy->sas_addr[0];\n\tiphy->sas_phy.frame_rcvd = (u8 *)&iphy->frame_rcvd;\n\tiphy->sas_phy.ha = &ihost->sas_ha;\n\tiphy->sas_phy.lldd_phy = iphy;\n\tiphy->sas_phy.enabled = 1;\n\tiphy->sas_phy.iproto = SAS_PROTOCOL_ALL;\n\tiphy->sas_phy.tproto = 0;\n\tiphy->sas_phy.role = PHY_ROLE_INITIATOR;\n\tiphy->sas_phy.oob_mode = OOB_NOT_CONNECTED;\n\tiphy->sas_phy.linkrate = SAS_LINK_RATE_UNKNOWN;\n\tmemset(&iphy->frame_rcvd, 0, sizeof(iphy->frame_rcvd));\n}\n\n\n \nint isci_phy_control(struct asd_sas_phy *sas_phy,\n\t\t     enum phy_func func,\n\t\t     void *buf)\n{\n\tint ret = 0;\n\tstruct isci_phy *iphy = sas_phy->lldd_phy;\n\tstruct asd_sas_port *port = sas_phy->port;\n\tstruct isci_host *ihost = sas_phy->ha->lldd_ha;\n\tunsigned long flags;\n\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: phy %p; func %d; buf %p; isci phy %p, port %p\\n\",\n\t\t__func__, sas_phy, func, buf, iphy, port);\n\n\tswitch (func) {\n\tcase PHY_FUNC_DISABLE:\n\t\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\t\tscu_link_layer_start_oob(iphy);\n\t\tsci_phy_stop(iphy);\n\t\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\t\tbreak;\n\n\tcase PHY_FUNC_LINK_RESET:\n\t\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\t\tscu_link_layer_start_oob(iphy);\n\t\tsci_phy_stop(iphy);\n\t\tsci_phy_start(iphy);\n\t\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\t\tbreak;\n\n\tcase PHY_FUNC_HARD_RESET:\n\t\tif (!port)\n\t\t\treturn -ENODEV;\n\n\t\tret = isci_port_perform_hard_reset(ihost, port->lldd_port, iphy);\n\n\t\tbreak;\n\tcase PHY_FUNC_GET_EVENTS: {\n\t\tstruct scu_link_layer_registers __iomem *r;\n\t\tstruct sas_phy *phy = sas_phy->phy;\n\n\t\tr = iphy->link_layer_registers;\n\t\tphy->running_disparity_error_count = readl(&r->running_disparity_error_count);\n\t\tphy->loss_of_dword_sync_count = readl(&r->loss_of_sync_error_count);\n\t\tphy->phy_reset_problem_count = readl(&r->phy_reset_problem_count);\n\t\tphy->invalid_dword_count = readl(&r->invalid_dword_counter);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t   \"%s: phy %p; func %d NOT IMPLEMENTED!\\n\",\n\t\t\t   __func__, sas_phy, func);\n\t\tret = -ENOSYS;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}