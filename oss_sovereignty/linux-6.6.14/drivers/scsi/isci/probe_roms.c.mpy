{
  "module_name": "probe_roms.c",
  "hash_id": "b26bc40ec8823421f15002a64b2a896a97c8f86932c22998667ad3eb45615a77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/isci/probe_roms.c",
  "human_readable_source": " \n\n \n\n#include <linux/kernel.h>\n#include <linux/firmware.h>\n#include <linux/uaccess.h>\n#include <linux/efi.h>\n#include <asm/probe_roms.h>\n\n#include \"isci.h\"\n#include \"task.h\"\n#include \"probe_roms.h\"\n\nstatic efi_char16_t isci_efivar_name[] = {\n\t'R', 's', 't', 'S', 'c', 'u', 'O'\n};\n\nstruct isci_orom *isci_request_oprom(struct pci_dev *pdev)\n{\n\tvoid __iomem *oprom = pci_map_biosrom(pdev);\n\tstruct isci_orom *rom = NULL;\n\tsize_t len, i;\n\tint j;\n\tchar oem_sig[4];\n\tstruct isci_oem_hdr oem_hdr;\n\tu8 *tmp, sum;\n\n\tif (!oprom)\n\t\treturn NULL;\n\n\tlen = pci_biosrom_size(pdev);\n\trom = devm_kzalloc(&pdev->dev, sizeof(*rom), GFP_KERNEL);\n\tif (!rom) {\n\t\tpci_unmap_biosrom(oprom);\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Unable to allocate memory for orom\\n\");\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < len && rom; i += ISCI_OEM_SIG_SIZE) {\n\t\tmemcpy_fromio(oem_sig, oprom + i, ISCI_OEM_SIG_SIZE);\n\n\t\t \n\t\tif (memcmp(oem_sig, ISCI_OEM_SIG, ISCI_OEM_SIG_SIZE) == 0) {\n\t\t\tsize_t copy_len;\n\n\t\t\tmemcpy_fromio(&oem_hdr, oprom + i, sizeof(oem_hdr));\n\n\t\t\tcopy_len = min(oem_hdr.len - sizeof(oem_hdr),\n\t\t\t\t       sizeof(*rom));\n\n\t\t\tmemcpy_fromio(rom,\n\t\t\t\t      oprom + i + sizeof(oem_hdr),\n\t\t\t\t      copy_len);\n\n\t\t\t \n\t\t\ttmp = (u8 *)&oem_hdr;\n\t\t\tfor (j = 0, sum = 0; j < sizeof(oem_hdr); j++, tmp++)\n\t\t\t\tsum += *tmp;\n\n\t\t\ttmp = (u8 *)rom;\n\t\t\tfor (j = 0; j < sizeof(*rom); j++, tmp++)\n\t\t\t\tsum += *tmp;\n\n\t\t\tif (sum != 0) {\n\t\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\t \"OEM table checksum failed\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (memcmp(rom->hdr.signature,\n\t\t\t\t   ISCI_ROM_SIG,\n\t\t\t\t   ISCI_ROM_SIG_SIZE) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"OEM parameter table found in OROM\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i >= len) {\n\t\tdev_err(&pdev->dev, \"oprom parse error\\n\");\n\t\trom = NULL;\n\t}\n\tpci_unmap_biosrom(oprom);\n\n\treturn rom;\n}\n\nstruct isci_orom *isci_request_firmware(struct pci_dev *pdev, const struct firmware *fw)\n{\n\tstruct isci_orom *orom = NULL, *data;\n\tint i, j;\n\n\tif (request_firmware(&fw, ISCI_FW_NAME, &pdev->dev) != 0)\n\t\treturn NULL;\n\n\tif (fw->size < sizeof(*orom))\n\t\tgoto out;\n\n\tdata = (struct isci_orom *)fw->data;\n\n\tif (strncmp(ISCI_ROM_SIG, data->hdr.signature,\n\t\t    strlen(ISCI_ROM_SIG)) != 0)\n\t\tgoto out;\n\n\torom = devm_kzalloc(&pdev->dev, fw->size, GFP_KERNEL);\n\tif (!orom)\n\t\tgoto out;\n\n\tmemcpy(orom, fw->data, fw->size);\n\n\tif (is_c0(pdev) || is_c1(pdev))\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(orom->ctrl); i++)\n\t\tfor (j = 0; j < ARRAY_SIZE(orom->ctrl[i].phys); j++) {\n\t\t\torom->ctrl[i].phys[j].afe_tx_amp_control0 = 0xe7c03;\n\t\t\torom->ctrl[i].phys[j].afe_tx_amp_control1 = 0xe7c03;\n\t\t\torom->ctrl[i].phys[j].afe_tx_amp_control2 = 0xe7c03;\n\t\t\torom->ctrl[i].phys[j].afe_tx_amp_control3 = 0xe7c03;\n\t\t}\n out:\n\trelease_firmware(fw);\n\n\treturn orom;\n}\n\nstatic struct efi *get_efi(void)\n{\n#ifdef CONFIG_EFI\n\treturn &efi;\n#else\n\treturn NULL;\n#endif\n}\n\nstruct isci_orom *isci_get_efi_var(struct pci_dev *pdev)\n{\n\tefi_status_t status;\n\tstruct isci_orom *rom;\n\tstruct isci_oem_hdr *oem_hdr;\n\tu8 *tmp, sum;\n\tint j;\n\tunsigned long data_len;\n\tu8 *efi_data;\n\tu32 efi_attrib = 0;\n\n\tdata_len = 1024;\n\tefi_data = devm_kzalloc(&pdev->dev, data_len, GFP_KERNEL);\n\tif (!efi_data) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Unable to allocate memory for EFI data\\n\");\n\t\treturn NULL;\n\t}\n\n\trom = (struct isci_orom *)(efi_data + sizeof(struct isci_oem_hdr));\n\n\tif (get_efi())\n\t\tstatus = get_efi()->get_variable(isci_efivar_name,\n\t\t\t\t\t\t &ISCI_EFI_VENDOR_GUID,\n\t\t\t\t\t\t &efi_attrib,\n\t\t\t\t\t\t &data_len,\n\t\t\t\t\t\t efi_data);\n\telse\n\t\tstatus = EFI_NOT_FOUND;\n\n\tif (status != EFI_SUCCESS) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Unable to obtain EFI var data for OEM parms\\n\");\n\t\treturn NULL;\n\t}\n\n\toem_hdr = (struct isci_oem_hdr *)efi_data;\n\n\tif (memcmp(oem_hdr->sig, ISCI_OEM_SIG, ISCI_OEM_SIG_SIZE) != 0) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Invalid OEM header signature\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\ttmp = (u8 *)efi_data;\n\tfor (j = 0, sum = 0; j < (sizeof(*oem_hdr) + sizeof(*rom)); j++, tmp++)\n\t\tsum += *tmp;\n\n\tif (sum != 0) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"OEM table checksum failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (memcmp(rom->hdr.signature,\n\t\t   ISCI_ROM_SIG,\n\t\t   ISCI_ROM_SIG_SIZE) != 0) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Invalid OEM table signature\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn rom;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}