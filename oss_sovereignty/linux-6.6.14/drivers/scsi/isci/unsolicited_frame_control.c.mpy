{
  "module_name": "unsolicited_frame_control.c",
  "hash_id": "fcecee1d6639448402ae4ccf221241186539b6d9d2ada4d6330e96b913c58825",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/isci/unsolicited_frame_control.c",
  "human_readable_source": " \n\n#include \"host.h\"\n#include \"unsolicited_frame_control.h\"\n#include \"registers.h\"\n\nvoid sci_unsolicited_frame_control_construct(struct isci_host *ihost)\n{\n\tstruct sci_unsolicited_frame_control *uf_control = &ihost->uf_control;\n\tstruct sci_unsolicited_frame *uf;\n\tdma_addr_t dma = ihost->ufi_dma;\n\tvoid *virt = ihost->ufi_buf;\n\tint i;\n\n\t \n\n\t \n\tuf_control->headers.physical_address = dma + SCI_UFI_BUF_SIZE;\n\tuf_control->headers.array = virt + SCI_UFI_BUF_SIZE;\n\n\t \n\tuf_control->address_table.physical_address = dma + SCI_UFI_BUF_SIZE + SCI_UFI_HDR_SIZE;\n\tuf_control->address_table.array = virt + SCI_UFI_BUF_SIZE + SCI_UFI_HDR_SIZE;\n\tuf_control->get = 0;\n\n\t \n\n\t \n\tfor (i = 0; i < SCU_MAX_UNSOLICITED_FRAMES; i++) {\n\t\tuf = &uf_control->buffers.array[i];\n\n\t\tuf_control->address_table.array[i] = dma;\n\n\t\tuf->buffer = virt;\n\t\tuf->header = &uf_control->headers.array[i];\n\t\tuf->state  = UNSOLICITED_FRAME_EMPTY;\n\n\t\t \n\t\tvirt += SCU_UNSOLICITED_FRAME_BUFFER_SIZE;\n\t\tdma += SCU_UNSOLICITED_FRAME_BUFFER_SIZE;\n\t}\n}\n\nenum sci_status sci_unsolicited_frame_control_get_header(struct sci_unsolicited_frame_control *uf_control,\n\t\t\t\t\t\t\t u32 frame_index,\n\t\t\t\t\t\t\t void **frame_header)\n{\n\tif (frame_index < SCU_MAX_UNSOLICITED_FRAMES) {\n\t\t \n\t\t*frame_header = &uf_control->buffers.array[frame_index].header->data;\n\n\t\treturn SCI_SUCCESS;\n\t}\n\n\treturn SCI_FAILURE_INVALID_PARAMETER_VALUE;\n}\n\nenum sci_status sci_unsolicited_frame_control_get_buffer(struct sci_unsolicited_frame_control *uf_control,\n\t\t\t\t\t\t\t u32 frame_index,\n\t\t\t\t\t\t\t void **frame_buffer)\n{\n\tif (frame_index < SCU_MAX_UNSOLICITED_FRAMES) {\n\t\t*frame_buffer = uf_control->buffers.array[frame_index].buffer;\n\n\t\treturn SCI_SUCCESS;\n\t}\n\n\treturn SCI_FAILURE_INVALID_PARAMETER_VALUE;\n}\n\nbool sci_unsolicited_frame_control_release_frame(struct sci_unsolicited_frame_control *uf_control,\n\t\t\t\t\t\t u32 frame_index)\n{\n\tu32 frame_get;\n\tu32 frame_cycle;\n\n\tframe_get   = uf_control->get & (SCU_MAX_UNSOLICITED_FRAMES - 1);\n\tframe_cycle = uf_control->get & SCU_MAX_UNSOLICITED_FRAMES;\n\n\t \n\twhile (lower_32_bits(uf_control->address_table.array[frame_get]) == 0 &&\n\t       upper_32_bits(uf_control->address_table.array[frame_get]) == 0 &&\n\t       frame_get < SCU_MAX_UNSOLICITED_FRAMES)\n\t\tframe_get++;\n\n\t \n\tBUG_ON(frame_get >= SCU_MAX_UNSOLICITED_FRAMES);\n\tif (frame_index >= SCU_MAX_UNSOLICITED_FRAMES)\n\t\treturn false;\n\n\tuf_control->buffers.array[frame_index].state = UNSOLICITED_FRAME_RELEASED;\n\n\tif (frame_get != frame_index) {\n\t\t \n\t\treturn false;\n\t}\n\n\t \n\twhile (uf_control->buffers.array[frame_get].state == UNSOLICITED_FRAME_RELEASED) {\n\t\tuf_control->buffers.array[frame_get].state = UNSOLICITED_FRAME_EMPTY;\n\n\t\tif (frame_get+1 == SCU_MAX_UNSOLICITED_FRAMES-1) {\n\t\t\tframe_cycle ^= SCU_MAX_UNSOLICITED_FRAMES;\n\t\t\tframe_get = 0;\n\t\t} else\n\t\t\tframe_get++;\n\t}\n\n\tuf_control->get = SCU_UFQGP_GEN_BIT(ENABLE_BIT) | frame_cycle | frame_get;\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}