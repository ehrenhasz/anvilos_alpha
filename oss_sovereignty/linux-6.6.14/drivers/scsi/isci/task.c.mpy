{
  "module_name": "task.c",
  "hash_id": "075801ec845b6cb5b34d2f3277acf0352583aad24535277da993836eba411ba7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/isci/task.c",
  "human_readable_source": " \n\n#include <linux/completion.h>\n#include <linux/irqflags.h>\n#include \"sas.h\"\n#include <scsi/libsas.h>\n#include \"remote_device.h\"\n#include \"remote_node_context.h\"\n#include \"isci.h\"\n#include \"request.h\"\n#include \"task.h\"\n#include \"host.h\"\n\n \nstatic void isci_task_refuse(struct isci_host *ihost, struct sas_task *task,\n\t\t\t     enum service_response response,\n\t\t\t     enum exec_status status)\n\n{\n\tunsigned long flags;\n\n\t \n\tdev_dbg(&ihost->pdev->dev, \"%s: task = %p, response=%d, status=%d\\n\",\n\t\t__func__, task, response, status);\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\n\ttask->task_status.resp = response;\n\ttask->task_status.stat = status;\n\n\t \n\ttask->task_state_flags |= SAS_TASK_STATE_DONE;\n\ttask->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\ttask->lldd_task = NULL;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\ttask->task_done(task);\n}\n\n#define for_each_sas_task(num, task) \\\n\tfor (; num > 0; num--,\\\n\t     task = list_entry(task->list.next, struct sas_task, list))\n\n\nstatic inline int isci_device_io_ready(struct isci_remote_device *idev,\n\t\t\t\t       struct sas_task *task)\n{\n\treturn idev ? test_bit(IDEV_IO_READY, &idev->flags) ||\n\t\t      (test_bit(IDEV_IO_NCQERROR, &idev->flags) &&\n\t\t       isci_task_is_ncq_recovery(task))\n\t\t    : 0;\n}\n \nint isci_task_execute_task(struct sas_task *task, gfp_t gfp_flags)\n{\n\tstruct isci_host *ihost = dev_to_ihost(task->dev);\n\tstruct isci_remote_device *idev;\n\tunsigned long flags;\n\tenum sci_status status = SCI_FAILURE;\n\tbool io_ready;\n\tu16 tag;\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\tidev = isci_lookup_device(task->dev);\n\tio_ready = isci_device_io_ready(idev, task);\n\ttag = isci_alloc_tag(ihost);\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"task: %p, dev: %p idev: %p:%#lx cmd = %p\\n\",\n\t\ttask, task->dev, idev, idev ? idev->flags : 0,\n\t\ttask->uldd_task);\n\n\tif (!idev) {\n\t\tisci_task_refuse(ihost, task, SAS_TASK_UNDELIVERED,\n\t\t\t\t SAS_DEVICE_UNKNOWN);\n\t} else if (!io_ready || tag == SCI_CONTROLLER_INVALID_IO_TAG) {\n\t\t \n\t\tisci_task_refuse(ihost, task, SAS_TASK_COMPLETE,\n\t\t\t\t SAS_QUEUE_FULL);\n\t} else {\n\t\t \n\t\tspin_lock_irqsave(&task->task_state_lock, flags);\n\n\t\tif (task->task_state_flags & SAS_TASK_STATE_ABORTED) {\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\t\t\tisci_task_refuse(ihost, task,\n\t\t\t\t\t SAS_TASK_UNDELIVERED,\n\t\t\t\t\t SAS_SAM_STAT_TASK_ABORTED);\n\t\t} else {\n\t\t\tstruct isci_request *ireq;\n\n\t\t\t \n\t\t\tireq = isci_io_request_from_tag(ihost, task, tag);\n\t\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\t\t\t \n\t\t\t \n\t\t\tstatus = isci_request_execute(ihost, idev, task, ireq);\n\n\t\t\tif (status != SCI_SUCCESS) {\n\t\t\t\tif (test_bit(IDEV_GONE, &idev->flags)) {\n\t\t\t\t\t \n\t\t\t\t\tisci_task_refuse(ihost, task,\n\t\t\t\t\t\tSAS_TASK_UNDELIVERED,\n\t\t\t\t\t\tSAS_DEVICE_UNKNOWN);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tisci_task_refuse(ihost, task,\n\t\t\t\t\t\tSAS_TASK_COMPLETE,\n\t\t\t\t\t\tSAS_QUEUE_FULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (status != SCI_SUCCESS && tag != SCI_CONTROLLER_INVALID_IO_TAG) {\n\t\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\t\t \n\t\tisci_tci_free(ihost, ISCI_TAG_TCI(tag));\n\t\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\t}\n\n\tisci_put_device(idev);\n\treturn 0;\n}\n\nstatic struct isci_request *isci_task_request_build(struct isci_host *ihost,\n\t\t\t\t\t\t    struct isci_remote_device *idev,\n\t\t\t\t\t\t    u16 tag, struct isci_tmf *isci_tmf)\n{\n\tenum sci_status status = SCI_FAILURE;\n\tstruct isci_request *ireq = NULL;\n\tstruct domain_device *dev;\n\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: isci_tmf = %p\\n\", __func__, isci_tmf);\n\n\tdev = idev->domain_dev;\n\n\t \n\tireq = isci_tmf_request_from_tag(ihost, isci_tmf, tag);\n\tif (!ireq)\n\t\treturn NULL;\n\n\t \n\tstatus = sci_task_request_construct(ihost, idev, tag,\n\t\t\t\t\t     ireq);\n\n\tif (status != SCI_SUCCESS) {\n\t\tdev_warn(&ihost->pdev->dev,\n\t\t\t \"%s: sci_task_request_construct failed - \"\n\t\t\t \"status = 0x%x\\n\",\n\t\t\t __func__,\n\t\t\t status);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (dev->dev_type == SAS_END_DEVICE) {\n\t\tisci_tmf->proto = SAS_PROTOCOL_SSP;\n\t\tstatus = sci_task_request_construct_ssp(ireq);\n\t\tif (status != SCI_SUCCESS)\n\t\t\treturn NULL;\n\t}\n\n\treturn ireq;\n}\n\nstatic int isci_task_execute_tmf(struct isci_host *ihost,\n\t\t\t\t struct isci_remote_device *idev,\n\t\t\t\t struct isci_tmf *tmf, unsigned long timeout_ms)\n{\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tenum sci_status status = SCI_FAILURE;\n\tstruct isci_request *ireq;\n\tint ret = TMF_RESP_FUNC_FAILED;\n\tunsigned long flags;\n\tunsigned long timeleft;\n\tu16 tag;\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\ttag = isci_alloc_tag(ihost);\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\tif (tag == SCI_CONTROLLER_INVALID_IO_TAG)\n\t\treturn ret;\n\n\t \n\tif (!idev ||\n\t    (!test_bit(IDEV_IO_READY, &idev->flags) &&\n\t     !test_bit(IDEV_IO_NCQERROR, &idev->flags))) {\n\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t\"%s: idev = %p not ready (%#lx)\\n\",\n\t\t\t__func__,\n\t\t\tidev, idev ? idev->flags : 0);\n\t\tgoto err_tci;\n\t} else\n\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t\"%s: idev = %p\\n\",\n\t\t\t__func__, idev);\n\n\t \n\ttmf->complete = &completion;\n\ttmf->status = SCI_FAILURE_TIMEOUT;\n\n\tireq = isci_task_request_build(ihost, idev, tag, tmf);\n\tif (!ireq)\n\t\tgoto err_tci;\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\n\t \n\tstatus = sci_controller_start_task(ihost, idev, ireq);\n\n\tif (status != SCI_SUCCESS) {\n\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t \"%s: start_io failed - status = 0x%x, request = %p\\n\",\n\t\t\t __func__,\n\t\t\t status,\n\t\t\t ireq);\n\t\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\t\tgoto err_tci;\n\t}\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\t \n\tisci_remote_device_resume_from_abort(ihost, idev);\n\n\t \n\ttimeleft = wait_for_completion_timeout(&completion,\n\t\t\t\t\t       msecs_to_jiffies(timeout_ms));\n\n\tif (timeleft == 0) {\n\t\t \n\t\tisci_remote_device_suspend_terminate(ihost, idev, ireq);\n\t}\n\n\tisci_print_tmf(ihost, tmf);\n\n\tif (tmf->status == SCI_SUCCESS)\n\t\tret =  TMF_RESP_FUNC_COMPLETE;\n\telse if (tmf->status == SCI_FAILURE_IO_RESPONSE_VALID) {\n\t\tdev_dbg(&ihost->pdev->dev,\n\t\t\t\"%s: tmf.status == \"\n\t\t\t\"SCI_FAILURE_IO_RESPONSE_VALID\\n\",\n\t\t\t__func__);\n\t\tret =  TMF_RESP_FUNC_COMPLETE;\n\t}\n\t \n\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: completed request = %p\\n\",\n\t\t__func__,\n\t\tireq);\n\n\treturn ret;\n\n err_tci:\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\tisci_tci_free(ihost, ISCI_TAG_TCI(tag));\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\treturn ret;\n}\n\nstatic void isci_task_build_tmf(struct isci_tmf *tmf,\n\t\t\t\tenum isci_tmf_function_codes code)\n{\n\tmemset(tmf, 0, sizeof(*tmf));\n\ttmf->tmf_code = code;\n}\n\nstatic void isci_task_build_abort_task_tmf(struct isci_tmf *tmf,\n\t\t\t\t\t   enum isci_tmf_function_codes code,\n\t\t\t\t\t   struct isci_request *old_request)\n{\n\tisci_task_build_tmf(tmf, code);\n\ttmf->io_tag = old_request->io_tag;\n}\n\n \nstatic int isci_task_send_lu_reset_sas(\n\tstruct isci_host *isci_host,\n\tstruct isci_remote_device *isci_device,\n\tu8 *lun)\n{\n\tstruct isci_tmf tmf;\n\tint ret = TMF_RESP_FUNC_FAILED;\n\n\tdev_dbg(&isci_host->pdev->dev,\n\t\t\"%s: isci_host = %p, isci_device = %p\\n\",\n\t\t__func__, isci_host, isci_device);\n\t \n\tisci_task_build_tmf(&tmf, isci_tmf_ssp_lun_reset);\n\n\t#define ISCI_LU_RESET_TIMEOUT_MS 2000  \n\tret = isci_task_execute_tmf(isci_host, isci_device, &tmf, ISCI_LU_RESET_TIMEOUT_MS);\n\n\tif (ret == TMF_RESP_FUNC_COMPLETE)\n\t\tdev_dbg(&isci_host->pdev->dev,\n\t\t\t\"%s: %p: TMF_LU_RESET passed\\n\",\n\t\t\t__func__, isci_device);\n\telse\n\t\tdev_dbg(&isci_host->pdev->dev,\n\t\t\t\"%s: %p: TMF_LU_RESET failed (%x)\\n\",\n\t\t\t__func__, isci_device, ret);\n\n\treturn ret;\n}\n\nint isci_task_lu_reset(struct domain_device *dev, u8 *lun)\n{\n\tstruct isci_host *ihost = dev_to_ihost(dev);\n\tstruct isci_remote_device *idev;\n\tunsigned long flags;\n\tint ret = TMF_RESP_FUNC_COMPLETE;\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\tidev = isci_get_device(dev->lldd_dev);\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: domain_device=%p, isci_host=%p; isci_device=%p\\n\",\n\t\t__func__, dev, ihost, idev);\n\n\tif (!idev) {\n\t\t \n\t\tdev_dbg(&ihost->pdev->dev, \"%s: No dev\\n\", __func__);\n\n\t\tret = TMF_RESP_FUNC_FAILED;\n\t\tgoto out;\n\t}\n\n\t \n\tif (isci_remote_device_suspend_terminate(ihost, idev, NULL)\n\t    != SCI_SUCCESS) {\n\t\t \n\t\tret = TMF_RESP_FUNC_FAILED;\n\t\tgoto out;\n\t}\n\t \n\tif (!test_bit(IDEV_GONE, &idev->flags)) {\n\t\tif (dev_is_sata(dev))\n\t\t\tsas_ata_schedule_reset(dev);\n\t\telse\n\t\t\t \n\t\t\tret = isci_task_send_lu_reset_sas(ihost, idev, lun);\n\t}\n out:\n\tisci_put_device(idev);\n\treturn ret;\n}\n\n\n \nint isci_task_clear_nexus_port(struct asd_sas_port *port)\n{\n\treturn TMF_RESP_FUNC_FAILED;\n}\n\n\n\nint isci_task_clear_nexus_ha(struct sas_ha_struct *ha)\n{\n\treturn TMF_RESP_FUNC_FAILED;\n}\n\n \n\n \nint isci_task_abort_task(struct sas_task *task)\n{\n\tstruct isci_host *ihost = dev_to_ihost(task->dev);\n\tDECLARE_COMPLETION_ONSTACK(aborted_io_completion);\n\tstruct isci_request       *old_request = NULL;\n\tstruct isci_remote_device *idev = NULL;\n\tstruct isci_tmf           tmf;\n\tint                       ret = TMF_RESP_FUNC_FAILED;\n\tunsigned long             flags;\n\tint                       target_done_already = 0;\n\n\t \n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\tspin_lock(&task->task_state_lock);\n\n\told_request = task->lldd_task;\n\n\t \n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE) &&\n\t    old_request) {\n\t\tidev = isci_get_device(task->dev->lldd_dev);\n\t\ttarget_done_already = test_bit(IREQ_COMPLETE_IN_TARGET,\n\t\t\t\t\t       &old_request->flags);\n\t}\n\tspin_unlock(&task->task_state_lock);\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\tdev_warn(&ihost->pdev->dev,\n\t\t \"%s: dev = %p (%s%s), task = %p, old_request == %p\\n\",\n\t\t __func__, idev,\n\t\t (dev_is_sata(task->dev) ? \"STP/SATA\"\n\t\t\t\t\t : ((dev_is_expander(task->dev->dev_type))\n\t\t\t\t\t\t? \"SMP\"\n\t\t\t\t\t\t: \"SSP\")),\n\t\t ((idev) ? ((test_bit(IDEV_GONE, &idev->flags))\n\t\t\t   ? \" IDEV_GONE\"\n\t\t\t   : \"\")\n\t\t\t : \" <NULL>\"),\n\t\t task, old_request);\n\n\t \n\tif (!idev || !old_request) {\n\t\t \n\t\tspin_lock_irqsave(&task->task_state_lock, flags);\n\t\ttask->task_state_flags |= SAS_TASK_STATE_DONE;\n\t\ttask->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\t\tret = TMF_RESP_FUNC_COMPLETE;\n\n\t\tdev_warn(&ihost->pdev->dev,\n\t\t\t \"%s: abort task not needed for %p\\n\",\n\t\t\t __func__, task);\n\t\tgoto out;\n\t}\n\t \n\tif (isci_remote_device_suspend_terminate(ihost, idev, old_request)\n\t    != SCI_SUCCESS) {\n\t\tdev_warn(&ihost->pdev->dev,\n\t\t\t \"%s: isci_remote_device_reset_terminate(dev=%p, \"\n\t\t\t\t \"req=%p, task=%p) failed\\n\",\n\t\t\t __func__, idev, old_request, task);\n\t\tret = TMF_RESP_FUNC_FAILED;\n\t\tgoto out;\n\t}\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\n\tif (task->task_proto == SAS_PROTOCOL_SMP ||\n\t    sas_protocol_ata(task->task_proto) ||\n\t    target_done_already ||\n\t    test_bit(IDEV_GONE, &idev->flags)) {\n\n\t\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\t\t \n\t\tisci_remote_device_resume_from_abort(ihost, idev);\n\n\t\tdev_warn(&ihost->pdev->dev,\n\t\t\t \"%s: %s request\"\n\t\t\t\t \" or complete_in_target (%d), \"\n\t\t\t\t \"or IDEV_GONE (%d), thus no TMF\\n\",\n\t\t\t __func__,\n\t\t\t ((task->task_proto == SAS_PROTOCOL_SMP)\n\t\t\t  ? \"SMP\"\n\t\t\t  : (sas_protocol_ata(task->task_proto)\n\t\t\t\t? \"SATA/STP\"\n\t\t\t\t: \"<other>\")\n\t\t\t  ),\n\t\t\t test_bit(IREQ_COMPLETE_IN_TARGET,\n\t\t\t\t  &old_request->flags),\n\t\t\t test_bit(IDEV_GONE, &idev->flags));\n\n\t\tspin_lock_irqsave(&task->task_state_lock, flags);\n\t\ttask->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\t\ttask->task_state_flags |= SAS_TASK_STATE_DONE;\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\t\tret = TMF_RESP_FUNC_COMPLETE;\n\t} else {\n\t\t \n\t\tisci_task_build_abort_task_tmf(&tmf, isci_tmf_ssp_task_abort,\n\t\t\t\t\t       old_request);\n\n\t\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\t\t \n\t\t#define ISCI_ABORT_TASK_TIMEOUT_MS 500  \n\t\tret = isci_task_execute_tmf(ihost, idev, &tmf,\n\t\t\t\t\t    ISCI_ABORT_TASK_TIMEOUT_MS);\n\t}\nout:\n\tdev_warn(&ihost->pdev->dev,\n\t\t \"%s: Done; dev = %p, task = %p , old_request == %p\\n\",\n\t\t __func__, idev, task, old_request);\n\tisci_put_device(idev);\n\treturn ret;\n}\n\n \nint isci_task_abort_task_set(\n\tstruct domain_device *d_device,\n\tu8 *lun)\n{\n\treturn TMF_RESP_FUNC_FAILED;\n}\n\n\n \nint isci_task_clear_task_set(\n\tstruct domain_device *d_device,\n\tu8 *lun)\n{\n\treturn TMF_RESP_FUNC_FAILED;\n}\n\n\n \nint isci_task_query_task(\n\tstruct sas_task *task)\n{\n\t \n\tif (task->task_state_flags & SAS_TASK_NEED_DEV_RESET)\n\t\treturn TMF_RESP_FUNC_FAILED;\n\telse\n\t\treturn TMF_RESP_FUNC_SUCC;\n}\n\n \nvoid\nisci_task_request_complete(struct isci_host *ihost,\n\t\t\t   struct isci_request *ireq,\n\t\t\t   enum sci_task_status completion_status)\n{\n\tstruct isci_tmf *tmf = isci_request_access_tmf(ireq);\n\tstruct completion *tmf_complete = NULL;\n\n\tdev_dbg(&ihost->pdev->dev,\n\t\t\"%s: request = %p, status=%d\\n\",\n\t\t__func__, ireq, completion_status);\n\n\tset_bit(IREQ_COMPLETE_IN_TARGET, &ireq->flags);\n\n\tif (tmf) {\n\t\ttmf->status = completion_status;\n\n\t\tif (tmf->proto == SAS_PROTOCOL_SSP) {\n\t\t\tmemcpy(tmf->resp.rsp_buf,\n\t\t\t       ireq->ssp.rsp_buf,\n\t\t\t       SSP_RESP_IU_MAX_SIZE);\n\t\t} else if (tmf->proto == SAS_PROTOCOL_SATA) {\n\t\t\tmemcpy(&tmf->resp.d2h_fis,\n\t\t\t       &ireq->stp.rsp,\n\t\t\t       sizeof(struct dev_to_host_fis));\n\t\t}\n\t\t \n\t\ttmf_complete = tmf->complete;\n\t}\n\tsci_controller_complete_io(ihost, ireq->target_device, ireq);\n\t \n\tset_bit(IREQ_TERMINATED, &ireq->flags);\n\n\tif (test_and_clear_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags))\n\t\twake_up_all(&ihost->eventq);\n\n\tif (!test_bit(IREQ_NO_AUTO_FREE_TAG, &ireq->flags))\n\t\tisci_free_tag(ihost, ireq->io_tag);\n\n\t \n\tif (tmf_complete)\n\t\tcomplete(tmf_complete);\n}\n\nstatic int isci_reset_device(struct isci_host *ihost,\n\t\t\t     struct domain_device *dev,\n\t\t\t     struct isci_remote_device *idev)\n{\n\tint rc = TMF_RESP_FUNC_COMPLETE, reset_stat = -1;\n\tstruct sas_phy *phy = sas_get_local_phy(dev);\n\tstruct isci_port *iport = dev->port->lldd_port;\n\n\tdev_dbg(&ihost->pdev->dev, \"%s: idev %p\\n\", __func__, idev);\n\n\t \n\tif (isci_remote_device_suspend_terminate(ihost, idev, NULL)\n\t    != SCI_SUCCESS) {\n\t\trc = TMF_RESP_FUNC_FAILED;\n\t\tgoto out;\n\t}\n\t \n\tif (!test_bit(IDEV_GONE, &idev->flags)) {\n\t\tif (scsi_is_sas_phy_local(phy)) {\n\t\t\tstruct isci_phy *iphy = &ihost->phys[phy->number];\n\n\t\t\treset_stat = isci_port_perform_hard_reset(ihost, iport,\n\t\t\t\t\t\t\t\t  iphy);\n\t\t} else\n\t\t\treset_stat = sas_phy_reset(phy, !dev_is_sata(dev));\n\t}\n\t \n\tisci_remote_device_resume_from_abort(ihost, idev);\n\n\tdev_dbg(&ihost->pdev->dev, \"%s: idev %p complete, reset_stat=%d.\\n\",\n\t\t__func__, idev, reset_stat);\n out:\n\tsas_put_local_phy(phy);\n\treturn rc;\n}\n\nint isci_task_I_T_nexus_reset(struct domain_device *dev)\n{\n\tstruct isci_host *ihost = dev_to_ihost(dev);\n\tstruct isci_remote_device *idev;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&ihost->scic_lock, flags);\n\tidev = isci_get_device(dev->lldd_dev);\n\tspin_unlock_irqrestore(&ihost->scic_lock, flags);\n\n\tif (!idev) {\n\t\t \n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tret = isci_reset_device(ihost, dev, idev);\n out:\n\tisci_put_device(idev);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}