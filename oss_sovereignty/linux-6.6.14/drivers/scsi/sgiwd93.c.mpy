{
  "module_name": "sgiwd93.c",
  "hash_id": "57d5124e8b5f1e0c76132ca9cfc885160704b71849031d2a02d0e1b19eb15cd2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sgiwd93.c",
  "human_readable_source": " \n\n#undef DEBUG\n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#include <asm/sgi/hpc3.h>\n#include <asm/sgi/ip22.h>\n#include <asm/sgi/wd.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_tcq.h>\n#include \"wd33c93.h\"\n\nstruct ip22_hostdata {\n\tstruct WD33C93_hostdata wh;\n\tdma_addr_t dma;\n\tvoid *cpu;\n\tstruct device *dev;\n};\n\n#define host_to_hostdata(host) ((struct ip22_hostdata *)((host)->hostdata))\n\nstruct hpc_chunk {\n\tstruct hpc_dma_desc desc;\n\tu32 _padding;\t \n};\n\n \n#define HPC_DMA_SIZE   PAGE_SIZE\n\n#define DMA_DIR(d)   ((d == DATA_OUT_DIR) ? DMA_TO_DEVICE : DMA_FROM_DEVICE)\n\nstatic irqreturn_t sgiwd93_intr(int irq, void *dev_id)\n{\n\tstruct Scsi_Host * host = dev_id;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(host->host_lock, flags);\n\twd33c93_intr(host);\n\tspin_unlock_irqrestore(host->host_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline\nvoid fill_hpc_entries(struct ip22_hostdata *hd, struct scsi_cmnd *cmd, int din)\n{\n\tstruct scsi_pointer *scsi_pointer = WD33C93_scsi_pointer(cmd);\n\tunsigned long len = scsi_pointer->this_residual;\n\tvoid *addr = scsi_pointer->ptr;\n\tdma_addr_t physaddr;\n\tunsigned long count;\n\tstruct hpc_chunk *hcp;\n\n\tphysaddr = dma_map_single(hd->dev, addr, len, DMA_DIR(din));\n\tscsi_pointer->dma_handle = physaddr;\n\thcp = hd->cpu;\n\n\twhile (len) {\n\t\t \n\t\tcount = len > 8192 ? 8192 : len;\n\t\thcp->desc.pbuf = physaddr;\n\t\thcp->desc.cntinfo = count;\n\t\thcp++;\n\t\tlen -= count;\n\t\tphysaddr += count;\n\t}\n\n\t \n\thcp->desc.pbuf = 0;\n\thcp->desc.cntinfo = HPCDMA_EOX;\n\tdma_sync_single_for_device(hd->dev, hd->dma,\n\t\t       (unsigned long)(hcp + 1) - (unsigned long)hd->cpu,\n\t\t       DMA_TO_DEVICE);\n}\n\nstatic int dma_setup(struct scsi_cmnd *cmd, int datainp)\n{\n\tstruct scsi_pointer *scsi_pointer = WD33C93_scsi_pointer(cmd);\n\tstruct ip22_hostdata *hdata = host_to_hostdata(cmd->device->host);\n\tstruct hpc3_scsiregs *hregs =\n\t\t(struct hpc3_scsiregs *) cmd->device->host->base;\n\n\tpr_debug(\"dma_setup: datainp<%d> hcp<%p> \", datainp, hdata->cpu);\n\n\thdata->wh.dma_dir = datainp;\n\n\t \n\tif (scsi_pointer->ptr == NULL || scsi_pointer->this_residual == 0)\n\t\treturn 1;\n\n\tfill_hpc_entries(hdata, cmd, datainp);\n\n\tpr_debug(\" HPCGO\\n\");\n\n\t \n\thregs->ndptr = hdata->dma;\n\tif (datainp)\n\t\thregs->ctrl = HPC3_SCTRL_ACTIVE;\n\telse\n\t\thregs->ctrl = HPC3_SCTRL_ACTIVE | HPC3_SCTRL_DIR;\n\n\treturn 0;\n}\n\nstatic void dma_stop(struct Scsi_Host *instance, struct scsi_cmnd *SCpnt,\n\t\t     int status)\n{\n\tstruct scsi_pointer *scsi_pointer = WD33C93_scsi_pointer(SCpnt);\n\tstruct ip22_hostdata *hdata = host_to_hostdata(instance);\n\tstruct hpc3_scsiregs *hregs;\n\n\tif (!SCpnt)\n\t\treturn;\n\n\tif (scsi_pointer->ptr == NULL || scsi_pointer->this_residual == 0)\n\t\treturn;\n\n\thregs = (struct hpc3_scsiregs *) SCpnt->device->host->base;\n\n\tpr_debug(\"dma_stop: status<%d> \", status);\n\n\t \n\tif (hdata->wh.dma_dir) {\n\t\thregs->ctrl |= HPC3_SCTRL_FLUSH;\n\t\twhile (hregs->ctrl & HPC3_SCTRL_ACTIVE)\n\t\t\tbarrier();\n\t}\n\thregs->ctrl = 0;\n\tdma_unmap_single(hdata->dev, scsi_pointer->dma_handle,\n\t\t\t scsi_pointer->this_residual,\n\t\t\t DMA_DIR(hdata->wh.dma_dir));\n\n\tpr_debug(\"\\n\");\n}\n\nvoid sgiwd93_reset(unsigned long base)\n{\n\tstruct hpc3_scsiregs *hregs = (struct hpc3_scsiregs *) base;\n\n\thregs->ctrl = HPC3_SCTRL_CRESET;\n\tudelay(50);\n\thregs->ctrl = 0;\n}\nEXPORT_SYMBOL_GPL(sgiwd93_reset);\n\nstatic inline void init_hpc_chain(struct ip22_hostdata *hdata)\n{\n\tstruct hpc_chunk *hcp = (struct hpc_chunk *)hdata->cpu;\n\tdma_addr_t dma = hdata->dma;\n\tunsigned long start, end;\n\n\tstart = (unsigned long) hcp;\n\tend = start + HPC_DMA_SIZE;\n\twhile (start < end) {\n\t\thcp->desc.pnext = (u32) (dma + sizeof(struct hpc_chunk));\n\t\thcp->desc.cntinfo = HPCDMA_EOX;\n\t\thcp++;\n\t\tdma += sizeof(struct hpc_chunk);\n\t\tstart += sizeof(struct hpc_chunk);\n\t}\n\thcp--;\n\thcp->desc.pnext = hdata->dma;\n}\n\n \nstatic const struct scsi_host_template sgiwd93_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.proc_name\t\t= \"SGIWD93\",\n\t.name\t\t\t= \"SGI WD93\",\n\t.queuecommand\t\t= wd33c93_queuecommand,\n\t.eh_abort_handler\t= wd33c93_abort,\n\t.eh_host_reset_handler\t= wd33c93_host_reset,\n\t.can_queue\t\t= 16,\n\t.this_id\t\t= 7,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.cmd_per_lun\t\t= 8,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n\t.cmd_size\t\t= sizeof(struct scsi_pointer),\n};\n\nstatic int sgiwd93_probe(struct platform_device *pdev)\n{\n\tstruct sgiwd93_platform_data *pd = pdev->dev.platform_data;\n\tunsigned char *wdregs = pd->wdregs;\n\tstruct hpc3_scsiregs *hregs = pd->hregs;\n\tstruct ip22_hostdata *hdata;\n\tstruct Scsi_Host *host;\n\twd33c93_regs regs;\n\tunsigned int unit = pd->unit;\n\tunsigned int irq = pd->irq;\n\tint err;\n\n\thost = scsi_host_alloc(&sgiwd93_template, sizeof(struct ip22_hostdata));\n\tif (!host) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\thost->base = (unsigned long) hregs;\n\thost->irq = irq;\n\n\thdata = host_to_hostdata(host);\n\thdata->dev = &pdev->dev;\n\thdata->cpu = dma_alloc_noncoherent(&pdev->dev, HPC_DMA_SIZE,\n\t\t\t\t&hdata->dma, DMA_TO_DEVICE, GFP_KERNEL);\n\tif (!hdata->cpu) {\n\t\tprintk(KERN_WARNING \"sgiwd93: Could not allocate memory for \"\n\t\t       \"host %d buffer.\\n\", unit);\n\t\terr = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\n\tinit_hpc_chain(hdata);\n\n\tregs.SASR = wdregs + 3;\n\tregs.SCMD = wdregs + 7;\n\n\thdata->wh.no_sync = 0;\n\thdata->wh.fast = 1;\n\thdata->wh.dma_mode = CTRL_BURST;\n\n\twd33c93_init(host, regs, dma_setup, dma_stop, WD33C93_FS_MHZ(20));\n\n\terr = request_irq(irq, sgiwd93_intr, 0, \"SGI WD93\", host);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"sgiwd93: Could not register irq %d \"\n\t\t       \"for host %d.\\n\", irq, unit);\n\t\tgoto out_free;\n\t}\n\n\tplatform_set_drvdata(pdev, host);\n\n\terr = scsi_add_host(host, NULL);\n\tif (err)\n\t\tgoto out_irq;\n\n\tscsi_scan_host(host);\n\n\treturn 0;\n\nout_irq:\n\tfree_irq(irq, host);\nout_free:\n\tdma_free_noncoherent(&pdev->dev, HPC_DMA_SIZE, hdata->cpu, hdata->dma,\n\t\t\tDMA_TO_DEVICE);\nout_put:\n\tscsi_host_put(host);\nout:\n\n\treturn err;\n}\n\nstatic int sgiwd93_remove(struct platform_device *pdev)\n{\n\tstruct Scsi_Host *host = platform_get_drvdata(pdev);\n\tstruct ip22_hostdata *hdata = (struct ip22_hostdata *) host->hostdata;\n\tstruct sgiwd93_platform_data *pd = pdev->dev.platform_data;\n\n\tscsi_remove_host(host);\n\tfree_irq(pd->irq, host);\n\tdma_free_noncoherent(&pdev->dev, HPC_DMA_SIZE, hdata->cpu, hdata->dma,\n\t\t\tDMA_TO_DEVICE);\n\tscsi_host_put(host);\n\treturn 0;\n}\n\nstatic struct platform_driver sgiwd93_driver = {\n\t.probe  = sgiwd93_probe,\n\t.remove = sgiwd93_remove,\n\t.driver = {\n\t\t.name   = \"sgiwd93\",\n\t}\n};\n\nstatic int __init sgiwd93_module_init(void)\n{\n\treturn platform_driver_register(&sgiwd93_driver);\n}\n\nstatic void __exit sgiwd93_module_exit(void)\n{\n\treturn platform_driver_unregister(&sgiwd93_driver);\n}\n\nmodule_init(sgiwd93_module_init);\nmodule_exit(sgiwd93_module_exit);\n\nMODULE_DESCRIPTION(\"SGI WD33C93 driver\");\nMODULE_AUTHOR(\"Ralf Baechle <ralf@linux-mips.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:sgiwd93\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}