{
  "module_name": "vnic_dev.c",
  "hash_id": "18c6d2062095e39b8b155098b05fbf57e27b77d047d4af3637d4f3d347bcd6cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/snic/vnic_dev.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/if_ether.h>\n#include <linux/slab.h>\n#include \"vnic_resource.h\"\n#include \"vnic_devcmd.h\"\n#include \"vnic_dev.h\"\n#include \"vnic_stats.h\"\n#include \"vnic_wq.h\"\n\n#define VNIC_DVCMD_TMO\t10000\t \n#define VNIC_NOTIFY_INTR_MASK 0x0000ffff00000000ULL\n\nstruct devcmd2_controller {\n\tstruct vnic_wq_ctrl __iomem *wq_ctrl;\n\tstruct vnic_dev_ring results_ring;\n\tstruct vnic_wq wq;\n\tstruct vnic_devcmd2 *cmd_ring;\n\tstruct devcmd2_result *result;\n\tu16 next_result;\n\tu16 result_size;\n\tint color;\n};\n\nstruct vnic_res {\n\tvoid __iomem *vaddr;\n\tunsigned int count;\n};\n\nstruct vnic_dev {\n\tvoid *priv;\n\tstruct pci_dev *pdev;\n\tstruct vnic_res res[RES_TYPE_MAX];\n\tenum vnic_dev_intr_mode intr_mode;\n\tstruct vnic_devcmd __iomem *devcmd;\n\tstruct vnic_devcmd_notify *notify;\n\tstruct vnic_devcmd_notify notify_copy;\n\tdma_addr_t notify_pa;\n\tu32 *linkstatus;\n\tdma_addr_t linkstatus_pa;\n\tstruct vnic_stats *stats;\n\tdma_addr_t stats_pa;\n\tstruct vnic_devcmd_fw_info *fw_info;\n\tdma_addr_t fw_info_pa;\n\tu64 args[VNIC_DEVCMD_NARGS];\n\tstruct devcmd2_controller *devcmd2;\n\n\tint (*devcmd_rtn)(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd,\n\t\t\t  int wait);\n};\n\n#define VNIC_MAX_RES_HDR_SIZE \\\n\t(sizeof(struct vnic_resource_header) + \\\n\tsizeof(struct vnic_resource) * RES_TYPE_MAX)\n#define VNIC_RES_STRIDE\t128\n\nvoid *svnic_dev_priv(struct vnic_dev *vdev)\n{\n\treturn vdev->priv;\n}\n\nstatic int vnic_dev_discover_res(struct vnic_dev *vdev,\n\tstruct vnic_dev_bar *bar, unsigned int num_bars)\n{\n\tstruct vnic_resource_header __iomem *rh;\n\tstruct vnic_resource __iomem *r;\n\tu8 type;\n\n\tif (num_bars == 0)\n\t\treturn -EINVAL;\n\n\tif (bar->len < VNIC_MAX_RES_HDR_SIZE) {\n\t\tpr_err(\"vNIC BAR0 res hdr length error\\n\");\n\n\t\treturn -EINVAL;\n\t}\n\n\trh = bar->vaddr;\n\tif (!rh) {\n\t\tpr_err(\"vNIC BAR0 res hdr not mem-mapped\\n\");\n\n\t\treturn -EINVAL;\n\t}\n\n\tif (ioread32(&rh->magic) != VNIC_RES_MAGIC ||\n\t    ioread32(&rh->version) != VNIC_RES_VERSION) {\n\t\tpr_err(\"vNIC BAR0 res magic/version error exp (%lx/%lx) curr (%x/%x)\\n\",\n\t\t\tVNIC_RES_MAGIC, VNIC_RES_VERSION,\n\t\t\tioread32(&rh->magic), ioread32(&rh->version));\n\n\t\treturn -EINVAL;\n\t}\n\n\tr = (struct vnic_resource __iomem *)(rh + 1);\n\n\twhile ((type = ioread8(&r->type)) != RES_TYPE_EOL) {\n\n\t\tu8 bar_num = ioread8(&r->bar);\n\t\tu32 bar_offset = ioread32(&r->bar_offset);\n\t\tu32 count = ioread32(&r->count);\n\t\tu32 len;\n\n\t\tr++;\n\n\t\tif (bar_num >= num_bars)\n\t\t\tcontinue;\n\n\t\tif (!bar[bar_num].len || !bar[bar_num].vaddr)\n\t\t\tcontinue;\n\n\t\tswitch (type) {\n\t\tcase RES_TYPE_WQ:\n\t\tcase RES_TYPE_RQ:\n\t\tcase RES_TYPE_CQ:\n\t\tcase RES_TYPE_INTR_CTRL:\n\t\t\t \n\t\t\tlen = count * VNIC_RES_STRIDE;\n\t\t\tif (len + bar_offset > bar->len) {\n\t\t\t\tpr_err(\"vNIC BAR0 resource %d out-of-bounds, offset 0x%x + size 0x%x > bar len 0x%lx\\n\",\n\t\t\t\t\ttype, bar_offset,\n\t\t\t\t\tlen,\n\t\t\t\t\tbar->len);\n\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase RES_TYPE_INTR_PBA_LEGACY:\n\t\tcase RES_TYPE_DEVCMD:\n\t\tcase RES_TYPE_DEVCMD2:\n\t\t\tlen = count;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tvdev->res[type].count = count;\n\t\tvdev->res[type].vaddr = (char __iomem *)bar->vaddr + bar_offset;\n\t}\n\n\treturn 0;\n}\n\nunsigned int svnic_dev_get_res_count(struct vnic_dev *vdev,\n\tenum vnic_res_type type)\n{\n\treturn vdev->res[type].count;\n}\n\nvoid __iomem *svnic_dev_get_res(struct vnic_dev *vdev, enum vnic_res_type type,\n\tunsigned int index)\n{\n\tif (!vdev->res[type].vaddr)\n\t\treturn NULL;\n\n\tswitch (type) {\n\tcase RES_TYPE_WQ:\n\tcase RES_TYPE_RQ:\n\tcase RES_TYPE_CQ:\n\tcase RES_TYPE_INTR_CTRL:\n\t\treturn (char __iomem *)vdev->res[type].vaddr +\n\t\t\t\t\tindex * VNIC_RES_STRIDE;\n\n\tdefault:\n\t\treturn (char __iomem *)vdev->res[type].vaddr;\n\t}\n}\n\nunsigned int svnic_dev_desc_ring_size(struct vnic_dev_ring *ring,\n\t\t\t\t      unsigned int desc_count,\n\t\t\t\t      unsigned int desc_size)\n{\n\t \n\n\tunsigned int count_align = 32;\n\tunsigned int desc_align = 16;\n\n\tring->base_align = 512;\n\n\tif (desc_count == 0)\n\t\tdesc_count = 4096;\n\n\tring->desc_count = ALIGN(desc_count, count_align);\n\n\tring->desc_size = ALIGN(desc_size, desc_align);\n\n\tring->size = ring->desc_count * ring->desc_size;\n\tring->size_unaligned = ring->size + ring->base_align;\n\n\treturn ring->size_unaligned;\n}\n\nvoid svnic_dev_clear_desc_ring(struct vnic_dev_ring *ring)\n{\n\tmemset(ring->descs, 0, ring->size);\n}\n\nint svnic_dev_alloc_desc_ring(struct vnic_dev *vdev, struct vnic_dev_ring *ring,\n\tunsigned int desc_count, unsigned int desc_size)\n{\n\tsvnic_dev_desc_ring_size(ring, desc_count, desc_size);\n\n\tring->descs_unaligned = dma_alloc_coherent(&vdev->pdev->dev,\n\t\t\tring->size_unaligned, &ring->base_addr_unaligned,\n\t\t\tGFP_KERNEL);\n\tif (!ring->descs_unaligned) {\n\t\tpr_err(\"Failed to allocate ring (size=%d), aborting\\n\",\n\t\t\t(int)ring->size);\n\n\t\treturn -ENOMEM;\n\t}\n\n\tring->base_addr = ALIGN(ring->base_addr_unaligned,\n\t\tring->base_align);\n\tring->descs = (u8 *)ring->descs_unaligned +\n\t\t(ring->base_addr - ring->base_addr_unaligned);\n\n\tsvnic_dev_clear_desc_ring(ring);\n\n\tring->desc_avail = ring->desc_count - 1;\n\n\treturn 0;\n}\n\nvoid svnic_dev_free_desc_ring(struct vnic_dev *vdev, struct vnic_dev_ring *ring)\n{\n\tif (ring->descs) {\n\t\tdma_free_coherent(&vdev->pdev->dev,\n\t\t\tring->size_unaligned,\n\t\t\tring->descs_unaligned,\n\t\t\tring->base_addr_unaligned);\n\t\tring->descs = NULL;\n\t}\n}\n\nstatic int _svnic_dev_cmd2(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd,\n\tint wait)\n{\n\tstruct devcmd2_controller *dc2c = vdev->devcmd2;\n\tstruct devcmd2_result *result = NULL;\n\tunsigned int i;\n\tint delay;\n\tint err;\n\tu32 posted;\n\tu32 fetch_idx;\n\tu32 new_posted;\n\tu8 color;\n\n\tfetch_idx = ioread32(&dc2c->wq_ctrl->fetch_index);\n\tif (fetch_idx == 0xFFFFFFFF) {  \n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tposted = ioread32(&dc2c->wq_ctrl->posted_index);\n\n\tif (posted == 0xFFFFFFFF) {  \n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tnew_posted = (posted + 1) % DEVCMD2_RING_SIZE;\n\tif (new_posted == fetch_idx) {\n\t\tpr_err(\"%s: wq is full while issuing devcmd2 command %d, fetch index: %u, posted index: %u\\n\",\n\t\t\tpci_name(vdev->pdev), _CMD_N(cmd), fetch_idx, posted);\n\n\t\treturn -EBUSY;\n\t}\n\n\tdc2c->cmd_ring[posted].cmd = cmd;\n\tdc2c->cmd_ring[posted].flags = 0;\n\n\tif ((_CMD_FLAGS(cmd) & _CMD_FLAGS_NOWAIT))\n\t\tdc2c->cmd_ring[posted].flags |= DEVCMD2_FNORESULT;\n\n\tif (_CMD_DIR(cmd) & _CMD_DIR_WRITE) {\n\t\tfor (i = 0; i < VNIC_DEVCMD_NARGS; i++)\n\t\t\tdc2c->cmd_ring[posted].args[i] = vdev->args[i];\n\t}\n\t \n\twmb();\n\tiowrite32(new_posted, &dc2c->wq_ctrl->posted_index);\n\n\tif (dc2c->cmd_ring[posted].flags & DEVCMD2_FNORESULT)\n\t\treturn 0;\n\n\tresult = dc2c->result + dc2c->next_result;\n\tcolor = dc2c->color;\n\n\t \n\tdc2c->next_result++;\n\tif (dc2c->next_result == dc2c->result_size) {\n\t\tdc2c->next_result = 0;\n\t\tdc2c->color = dc2c->color ? 0 : 1;\n\t}\n\n\tfor (delay = 0; delay < wait; delay++) {\n\t\tudelay(100);\n\t\tif (result->color == color) {\n\t\t\tif (result->error) {\n\t\t\t\terr = (int) result->error;\n\t\t\t\tif (err != ERR_ECMDUNKNOWN ||\n\t\t\t\t    cmd != CMD_CAPABILITY)\n\t\t\t\t\tpr_err(\"Error %d devcmd %d\\n\",\n\t\t\t\t\t\terr, _CMD_N(cmd));\n\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (_CMD_DIR(cmd) & _CMD_DIR_READ) {\n\t\t\t\tfor (i = 0; i < VNIC_DEVCMD_NARGS; i++)\n\t\t\t\t\tvdev->args[i] = result->results[i];\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpr_err(\"Timed out devcmd %d\\n\", _CMD_N(cmd));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int svnic_dev_init_devcmd2(struct vnic_dev *vdev)\n{\n\tstruct devcmd2_controller *dc2c = NULL;\n\tunsigned int fetch_idx;\n\tint ret;\n\tvoid __iomem *p;\n\n\tif (vdev->devcmd2)\n\t\treturn 0;\n\n\tp = svnic_dev_get_res(vdev, RES_TYPE_DEVCMD2, 0);\n\tif (!p)\n\t\treturn -ENODEV;\n\n\tdc2c = kzalloc(sizeof(*dc2c), GFP_ATOMIC);\n\tif (!dc2c)\n\t\treturn -ENOMEM;\n\n\tvdev->devcmd2 = dc2c;\n\n\tdc2c->color = 1;\n\tdc2c->result_size = DEVCMD2_RING_SIZE;\n\n\tret  = vnic_wq_devcmd2_alloc(vdev,\n\t\t\t\t     &dc2c->wq,\n\t\t\t\t     DEVCMD2_RING_SIZE,\n\t\t\t\t     DEVCMD2_DESC_SIZE);\n\tif (ret)\n\t\tgoto err_free_devcmd2;\n\n\tfetch_idx = ioread32(&dc2c->wq.ctrl->fetch_index);\n\tif (fetch_idx == 0xFFFFFFFF) {  \n\t\t \n\t\tfetch_idx = 0;\n\t}\n\n\t \n\tvnic_wq_init_start(&dc2c->wq, 0, fetch_idx, fetch_idx, 0, 0);\n\tsvnic_wq_enable(&dc2c->wq);\n\tret = svnic_dev_alloc_desc_ring(vdev,\n\t\t\t\t\t&dc2c->results_ring,\n\t\t\t\t\tDEVCMD2_RING_SIZE,\n\t\t\t\t\tDEVCMD2_DESC_SIZE);\n\tif (ret)\n\t\tgoto err_free_wq;\n\n\tdc2c->result = (struct devcmd2_result *) dc2c->results_ring.descs;\n\tdc2c->cmd_ring = (struct vnic_devcmd2 *) dc2c->wq.ring.descs;\n\tdc2c->wq_ctrl = dc2c->wq.ctrl;\n\tvdev->args[0] = (u64) dc2c->results_ring.base_addr | VNIC_PADDR_TARGET;\n\tvdev->args[1] = DEVCMD2_RING_SIZE;\n\n\tret = _svnic_dev_cmd2(vdev, CMD_INITIALIZE_DEVCMD2, VNIC_DVCMD_TMO);\n\tif (ret < 0)\n\t\tgoto err_free_desc_ring;\n\n\tvdev->devcmd_rtn = &_svnic_dev_cmd2;\n\tpr_info(\"DEVCMD2 Initialized.\\n\");\n\n\treturn ret;\n\nerr_free_desc_ring:\n\tsvnic_dev_free_desc_ring(vdev, &dc2c->results_ring);\n\nerr_free_wq:\n\tsvnic_wq_disable(&dc2c->wq);\n\tsvnic_wq_free(&dc2c->wq);\n\nerr_free_devcmd2:\n\tkfree(dc2c);\n\tvdev->devcmd2 = NULL;\n\n\treturn ret;\n}  \n\nstatic void vnic_dev_deinit_devcmd2(struct vnic_dev *vdev)\n{\n\tstruct devcmd2_controller *dc2c = vdev->devcmd2;\n\n\tvdev->devcmd2 = NULL;\n\tvdev->devcmd_rtn = NULL;\n\n\tsvnic_dev_free_desc_ring(vdev, &dc2c->results_ring);\n\tsvnic_wq_disable(&dc2c->wq);\n\tsvnic_wq_free(&dc2c->wq);\n\tkfree(dc2c);\n}\n\nint svnic_dev_cmd(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd,\n\tu64 *a0, u64 *a1, int wait)\n{\n\tint err;\n\n\tmemset(vdev->args, 0, sizeof(vdev->args));\n\tvdev->args[0] = *a0;\n\tvdev->args[1] = *a1;\n\n\terr = (*vdev->devcmd_rtn)(vdev, cmd, wait);\n\n\t*a0 = vdev->args[0];\n\t*a1 = vdev->args[1];\n\n\treturn  err;\n}\n\nint svnic_dev_fw_info(struct vnic_dev *vdev,\n\tstruct vnic_devcmd_fw_info **fw_info)\n{\n\tu64 a0, a1 = 0;\n\tint wait = VNIC_DVCMD_TMO;\n\tint err = 0;\n\n\tif (!vdev->fw_info) {\n\t\tvdev->fw_info = dma_alloc_coherent(&vdev->pdev->dev,\n\t\t\tsizeof(struct vnic_devcmd_fw_info),\n\t\t\t&vdev->fw_info_pa, GFP_KERNEL);\n\t\tif (!vdev->fw_info)\n\t\t\treturn -ENOMEM;\n\n\t\ta0 = vdev->fw_info_pa;\n\n\t\t \n\t\terr = svnic_dev_cmd(vdev, CMD_MCPU_FW_INFO, &a0, &a1, wait);\n\t}\n\n\t*fw_info = vdev->fw_info;\n\n\treturn err;\n}\n\nint svnic_dev_spec(struct vnic_dev *vdev, unsigned int offset,\n\tunsigned int size, void *value)\n{\n\tu64 a0, a1;\n\tint wait = VNIC_DVCMD_TMO;\n\tint err;\n\n\ta0 = offset;\n\ta1 = size;\n\n\terr = svnic_dev_cmd(vdev, CMD_DEV_SPEC, &a0, &a1, wait);\n\n\tswitch (size) {\n\tcase 1:\n\t\t*(u8 *)value = (u8)a0;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)value = (u16)a0;\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)value = (u32)a0;\n\t\tbreak;\n\tcase 8:\n\t\t*(u64 *)value = a0;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint svnic_dev_stats_clear(struct vnic_dev *vdev)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = VNIC_DVCMD_TMO;\n\n\treturn svnic_dev_cmd(vdev, CMD_STATS_CLEAR, &a0, &a1, wait);\n}\n\nint svnic_dev_stats_dump(struct vnic_dev *vdev, struct vnic_stats **stats)\n{\n\tu64 a0, a1;\n\tint wait = VNIC_DVCMD_TMO;\n\n\tif (!vdev->stats) {\n\t\tvdev->stats = dma_alloc_coherent(&vdev->pdev->dev,\n\t\t\tsizeof(struct vnic_stats), &vdev->stats_pa, GFP_KERNEL);\n\t\tif (!vdev->stats)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t*stats = vdev->stats;\n\ta0 = vdev->stats_pa;\n\ta1 = sizeof(struct vnic_stats);\n\n\treturn svnic_dev_cmd(vdev, CMD_STATS_DUMP, &a0, &a1, wait);\n}\n\nint svnic_dev_close(struct vnic_dev *vdev)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = VNIC_DVCMD_TMO;\n\n\treturn svnic_dev_cmd(vdev, CMD_CLOSE, &a0, &a1, wait);\n}\n\nint svnic_dev_enable_wait(struct vnic_dev *vdev)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = VNIC_DVCMD_TMO;\n\tint err = 0;\n\n\terr = svnic_dev_cmd(vdev, CMD_ENABLE_WAIT, &a0, &a1, wait);\n\tif (err == ERR_ECMDUNKNOWN)\n\t\treturn svnic_dev_cmd(vdev, CMD_ENABLE, &a0, &a1, wait);\n\n\treturn err;\n}\n\nint svnic_dev_disable(struct vnic_dev *vdev)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = VNIC_DVCMD_TMO;\n\n\treturn svnic_dev_cmd(vdev, CMD_DISABLE, &a0, &a1, wait);\n}\n\nint svnic_dev_open(struct vnic_dev *vdev, int arg)\n{\n\tu64 a0 = (u32)arg, a1 = 0;\n\tint wait = VNIC_DVCMD_TMO;\n\n\treturn svnic_dev_cmd(vdev, CMD_OPEN, &a0, &a1, wait);\n}\n\nint svnic_dev_open_done(struct vnic_dev *vdev, int *done)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = VNIC_DVCMD_TMO;\n\tint err;\n\n\t*done = 0;\n\n\terr = svnic_dev_cmd(vdev, CMD_OPEN_STATUS, &a0, &a1, wait);\n\tif (err)\n\t\treturn err;\n\n\t*done = (a0 == 0);\n\n\treturn 0;\n}\n\nint svnic_dev_notify_set(struct vnic_dev *vdev, u16 intr)\n{\n\tu64 a0, a1;\n\tint wait = VNIC_DVCMD_TMO;\n\n\tif (!vdev->notify) {\n\t\tvdev->notify = dma_alloc_coherent(&vdev->pdev->dev,\n\t\t\tsizeof(struct vnic_devcmd_notify),\n\t\t\t&vdev->notify_pa, GFP_KERNEL);\n\t\tif (!vdev->notify)\n\t\t\treturn -ENOMEM;\n\t}\n\n\ta0 = vdev->notify_pa;\n\ta1 = ((u64)intr << 32) & VNIC_NOTIFY_INTR_MASK;\n\ta1 += sizeof(struct vnic_devcmd_notify);\n\n\treturn svnic_dev_cmd(vdev, CMD_NOTIFY, &a0, &a1, wait);\n}\n\nvoid svnic_dev_notify_unset(struct vnic_dev *vdev)\n{\n\tu64 a0, a1;\n\tint wait = VNIC_DVCMD_TMO;\n\n\ta0 = 0;   \n\ta1 = VNIC_NOTIFY_INTR_MASK;  \n\ta1 += sizeof(struct vnic_devcmd_notify);\n\n\tsvnic_dev_cmd(vdev, CMD_NOTIFY, &a0, &a1, wait);\n}\n\nstatic int vnic_dev_notify_ready(struct vnic_dev *vdev)\n{\n\tu32 *words;\n\tunsigned int nwords = sizeof(struct vnic_devcmd_notify) / 4;\n\tunsigned int i;\n\tu32 csum;\n\n\tif (!vdev->notify)\n\t\treturn 0;\n\n\tdo {\n\t\tcsum = 0;\n\t\tmemcpy(&vdev->notify_copy, vdev->notify,\n\t\t\tsizeof(struct vnic_devcmd_notify));\n\t\twords = (u32 *)&vdev->notify_copy;\n\t\tfor (i = 1; i < nwords; i++)\n\t\t\tcsum += words[i];\n\t} while (csum != words[0]);\n\n\treturn 1;\n}\n\nint svnic_dev_init(struct vnic_dev *vdev, int arg)\n{\n\tu64 a0 = (u32)arg, a1 = 0;\n\tint wait = VNIC_DVCMD_TMO;\n\n\treturn svnic_dev_cmd(vdev, CMD_INIT, &a0, &a1, wait);\n}\n\nint svnic_dev_link_status(struct vnic_dev *vdev)\n{\n\tif (vdev->linkstatus)\n\t\treturn *vdev->linkstatus;\n\n\tif (!vnic_dev_notify_ready(vdev))\n\t\treturn 0;\n\n\treturn vdev->notify_copy.link_state;\n}\n\nu32 svnic_dev_link_down_cnt(struct vnic_dev *vdev)\n{\n\tif (!vnic_dev_notify_ready(vdev))\n\t\treturn 0;\n\n\treturn vdev->notify_copy.link_down_cnt;\n}\n\nvoid svnic_dev_set_intr_mode(struct vnic_dev *vdev,\n\tenum vnic_dev_intr_mode intr_mode)\n{\n\tvdev->intr_mode = intr_mode;\n}\n\nenum vnic_dev_intr_mode svnic_dev_get_intr_mode(struct vnic_dev *vdev)\n{\n\treturn vdev->intr_mode;\n}\n\nvoid svnic_dev_unregister(struct vnic_dev *vdev)\n{\n\tif (vdev) {\n\t\tif (vdev->notify)\n\t\t\tdma_free_coherent(&vdev->pdev->dev,\n\t\t\t\tsizeof(struct vnic_devcmd_notify),\n\t\t\t\tvdev->notify,\n\t\t\t\tvdev->notify_pa);\n\t\tif (vdev->linkstatus)\n\t\t\tdma_free_coherent(&vdev->pdev->dev,\n\t\t\t\tsizeof(u32),\n\t\t\t\tvdev->linkstatus,\n\t\t\t\tvdev->linkstatus_pa);\n\t\tif (vdev->stats)\n\t\t\tdma_free_coherent(&vdev->pdev->dev,\n\t\t\t\tsizeof(struct vnic_stats),\n\t\t\t\tvdev->stats, vdev->stats_pa);\n\t\tif (vdev->fw_info)\n\t\t\tdma_free_coherent(&vdev->pdev->dev,\n\t\t\t\tsizeof(struct vnic_devcmd_fw_info),\n\t\t\t\tvdev->fw_info, vdev->fw_info_pa);\n\t\tif (vdev->devcmd2)\n\t\t\tvnic_dev_deinit_devcmd2(vdev);\n\t\tkfree(vdev);\n\t}\n}\n\nstruct vnic_dev *svnic_dev_alloc_discover(struct vnic_dev *vdev,\n\t\t\t\t\t  void *priv,\n\t\t\t\t\t  struct pci_dev *pdev,\n\t\t\t\t\t  struct vnic_dev_bar *bar,\n\t\t\t\t\t  unsigned int num_bars)\n{\n\tif (!vdev) {\n\t\tvdev = kzalloc(sizeof(struct vnic_dev), GFP_ATOMIC);\n\t\tif (!vdev)\n\t\t\treturn NULL;\n\t}\n\n\tvdev->priv = priv;\n\tvdev->pdev = pdev;\n\n\tif (vnic_dev_discover_res(vdev, bar, num_bars))\n\t\tgoto err_out;\n\n\treturn vdev;\n\nerr_out:\n\tsvnic_dev_unregister(vdev);\n\n\treturn NULL;\n}  \n\n \nint svnic_dev_cmd_init(struct vnic_dev *vdev, int fallback)\n{\n\tint err = -ENODEV;\n\tvoid __iomem *p;\n\n\tp = svnic_dev_get_res(vdev, RES_TYPE_DEVCMD2, 0);\n\tif (p)\n\t\terr = svnic_dev_init_devcmd2(vdev);\n\telse\n\t\tpr_err(\"DEVCMD2 resource not found.\\n\");\n\n\treturn err;\n}  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}