{
  "module_name": "vnic_wq.h",
  "hash_id": "061dd6f2a7c741679263176cc4ef1bad404adef5496567d6d5a20aff48b3959b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/snic/vnic_wq.h",
  "human_readable_source": " \n \n\n#ifndef _VNIC_WQ_H_\n#define _VNIC_WQ_H_\n\n#include <linux/pci.h>\n#include \"vnic_dev.h\"\n#include \"vnic_cq.h\"\n\n \nstruct vnic_wq_ctrl {\n\tu64 ring_base;\t\t\t \n\tu32 ring_size;\t\t\t \n\tu32 pad0;\n\tu32 posted_index;\t\t \n\tu32 pad1;\n\tu32 cq_index;\t\t\t \n\tu32 pad2;\n\tu32 enable;\t\t\t \n\tu32 pad3;\n\tu32 running;\t\t\t \n\tu32 pad4;\n\tu32 fetch_index;\t\t \n\tu32 pad5;\n\tu32 dca_value;\t\t\t \n\tu32 pad6;\n\tu32 error_interrupt_enable;\t \n\tu32 pad7;\n\tu32 error_interrupt_offset;\t \n\tu32 pad8;\n\tu32 error_status;\t\t \n\tu32 pad9;\n};\n\nstruct vnic_wq_buf {\n\tstruct vnic_wq_buf *next;\n\tdma_addr_t dma_addr;\n\tvoid *os_buf;\n\tunsigned int len;\n\tunsigned int index;\n\tint sop;\n\tvoid *desc;\n};\n\n \n#define VNIC_WQ_BUF_MIN_BLK_ENTRIES 32\n#define VNIC_WQ_BUF_DFLT_BLK_ENTRIES 64\n#define VNIC_WQ_BUF_BLK_ENTRIES(entries) \\\n\t((unsigned int)(entries < VNIC_WQ_BUF_DFLT_BLK_ENTRIES) ? \\\n\t\tVNIC_WQ_BUF_MIN_BLK_ENTRIES : VNIC_WQ_BUF_DFLT_BLK_ENTRIES)\n#define VNIC_WQ_BUF_BLK_SZ \\\n\t(VNIC_WQ_BUF_DFLT_BLK_ENTRIES * sizeof(struct vnic_wq_buf))\n#define VNIC_WQ_BUF_BLKS_NEEDED(entries) \\\n\tDIV_ROUND_UP(entries, VNIC_WQ_BUF_DFLT_BLK_ENTRIES)\n#define VNIC_WQ_BUF_BLKS_NEEDED(entries) \\\n\tDIV_ROUND_UP(entries, VNIC_WQ_BUF_DFLT_BLK_ENTRIES)\n#define VNIC_WQ_BUF_BLKS_MAX VNIC_WQ_BUF_BLKS_NEEDED(4096)\n\nstruct vnic_wq {\n\tunsigned int index;\n\tstruct vnic_dev *vdev;\n\tstruct vnic_wq_ctrl __iomem *ctrl;\t \n\tstruct vnic_dev_ring ring;\n\tstruct vnic_wq_buf *bufs[VNIC_WQ_BUF_BLKS_MAX];\n\tstruct vnic_wq_buf *to_use;\n\tstruct vnic_wq_buf *to_clean;\n\tunsigned int pkts_outstanding;\n};\n\nstatic inline unsigned int svnic_wq_desc_avail(struct vnic_wq *wq)\n{\n\t \n\treturn wq->ring.desc_avail;\n}\n\nstatic inline unsigned int svnic_wq_desc_used(struct vnic_wq *wq)\n{\n\t \n\treturn wq->ring.desc_count - wq->ring.desc_avail - 1;\n}\n\nstatic inline void *svnic_wq_next_desc(struct vnic_wq *wq)\n{\n\treturn wq->to_use->desc;\n}\n\nstatic inline void svnic_wq_post(struct vnic_wq *wq,\n\tvoid *os_buf, dma_addr_t dma_addr,\n\tunsigned int len, int sop, int eop)\n{\n\tstruct vnic_wq_buf *buf = wq->to_use;\n\n\tbuf->sop = sop;\n\tbuf->os_buf = eop ? os_buf : NULL;\n\tbuf->dma_addr = dma_addr;\n\tbuf->len = len;\n\n\tbuf = buf->next;\n\tif (eop) {\n\t\t \n\t\twmb();\n\t\tiowrite32(buf->index, &wq->ctrl->posted_index);\n\t}\n\twq->to_use = buf;\n\n\twq->ring.desc_avail--;\n}\n\nstatic inline void svnic_wq_service(struct vnic_wq *wq,\n\tstruct cq_desc *cq_desc, u16 completed_index,\n\tvoid (*buf_service)(struct vnic_wq *wq,\n\tstruct cq_desc *cq_desc, struct vnic_wq_buf *buf, void *opaque),\n\tvoid *opaque)\n{\n\tstruct vnic_wq_buf *buf;\n\n\tbuf = wq->to_clean;\n\twhile (1) {\n\n\t\t(*buf_service)(wq, cq_desc, buf, opaque);\n\n\t\twq->ring.desc_avail++;\n\n\t\twq->to_clean = buf->next;\n\n\t\tif (buf->index == completed_index)\n\t\t\tbreak;\n\n\t\tbuf = wq->to_clean;\n\t}\n}\n\nvoid svnic_wq_free(struct vnic_wq *wq);\nint svnic_wq_alloc(struct vnic_dev *vdev, struct vnic_wq *wq,\n\tunsigned int index, unsigned int desc_count, unsigned int desc_size);\nint vnic_wq_devcmd2_alloc(struct vnic_dev *vdev, struct vnic_wq *wq,\n\t\tunsigned int desc_count, unsigned int desc_size);\nvoid vnic_wq_init_start(struct vnic_wq *wq, unsigned int cq_index,\n\t\tunsigned int fetch_index, unsigned int post_index,\n\t\tunsigned int error_interrupt_enable,\n\t\tunsigned int error_interrupt_offset);\n\nvoid svnic_wq_init(struct vnic_wq *wq, unsigned int cq_index,\n\tunsigned int error_interrupt_enable,\n\tunsigned int error_interrupt_offset);\nunsigned int svnic_wq_error_status(struct vnic_wq *wq);\nvoid svnic_wq_enable(struct vnic_wq *wq);\nint svnic_wq_disable(struct vnic_wq *wq);\nvoid svnic_wq_clean(struct vnic_wq *wq,\n\tvoid (*buf_clean)(struct vnic_wq *wq, struct vnic_wq_buf *buf));\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}