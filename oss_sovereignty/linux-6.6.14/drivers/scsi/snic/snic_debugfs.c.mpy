{
  "module_name": "snic_debugfs.c",
  "hash_id": "47cc1c77ef8e21f92d21c1e9e1379c4d1dd735771edb503d300b4077ea6daf20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/snic/snic_debugfs.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/debugfs.h>\n\n#include \"snic.h\"\n\n \nvoid snic_debugfs_init(void)\n{\n\tsnic_glob->trc_root = debugfs_create_dir(\"snic\", NULL);\n\n\tsnic_glob->stats_root = debugfs_create_dir(\"statistics\",\n\t\t\t\t\t\t   snic_glob->trc_root);\n}\n\n \nvoid\nsnic_debugfs_term(void)\n{\n\tdebugfs_remove(snic_glob->stats_root);\n\tsnic_glob->stats_root = NULL;\n\n\tdebugfs_remove(snic_glob->trc_root);\n\tsnic_glob->trc_root = NULL;\n}\n\n \nstatic int\nsnic_reset_stats_open(struct inode *inode, struct file *filp)\n{\n\tSNIC_BUG_ON(!inode->i_private);\n\tfilp->private_data = inode->i_private;\n\n\treturn 0;\n}\n\n \nstatic ssize_t\nsnic_reset_stats_read(struct file *filp,\n\t\t      char __user *ubuf,\n\t\t      size_t cnt,\n\t\t      loff_t *ppos)\n{\n\tstruct snic *snic = (struct snic *) filp->private_data;\n\tchar buf[64];\n\tint len;\n\n\tlen = sprintf(buf, \"%u\\n\", snic->reset_stats);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, len);\n}\n\n \nstatic ssize_t\nsnic_reset_stats_write(struct file *filp,\n\t\t       const char __user *ubuf,\n\t\t       size_t cnt,\n\t\t       loff_t *ppos)\n{\n\tstruct snic *snic = (struct snic *) filp->private_data;\n\tstruct snic_stats *stats = &snic->s_stats;\n\tu64 *io_stats_p = (u64 *) &stats->io;\n\tu64 *fw_stats_p = (u64 *) &stats->fw;\n\tchar buf[64];\n\tunsigned long val;\n\tint ret;\n\n\tif (cnt >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&buf, ubuf, cnt))\n\t\treturn -EFAULT;\n\n\tbuf[cnt] = '\\0';\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsnic->reset_stats = val;\n\n\tif (snic->reset_stats) {\n\t\t \n\t\tatomic64_set(&snic->io_cmpl_skip,\n\t\t\t     atomic64_read(&stats->io.active));\n\t\tmemset(&stats->abts, 0, sizeof(struct snic_abort_stats));\n\t\tmemset(&stats->reset, 0, sizeof(struct snic_reset_stats));\n\t\tmemset(&stats->misc, 0, sizeof(struct snic_misc_stats));\n\t\tmemset(io_stats_p+1,\n\t\t\t0,\n\t\t\tsizeof(struct snic_io_stats) - sizeof(u64));\n\t\tmemset(fw_stats_p+1,\n\t\t\t0,\n\t\t\tsizeof(struct snic_fw_stats) - sizeof(u64));\n\t}\n\n\t(*ppos)++;\n\n\tSNIC_HOST_INFO(snic->shost, \"Reset Op: Driver statistics.\\n\");\n\n\treturn cnt;\n}\n\nstatic int\nsnic_reset_stats_release(struct inode *inode, struct file *filp)\n{\n\tfilp->private_data = NULL;\n\n\treturn 0;\n}\n\n \nstatic int\nsnic_stats_show(struct seq_file *sfp, void *data)\n{\n\tstruct snic *snic = (struct snic *) sfp->private;\n\tstruct snic_stats *stats = &snic->s_stats;\n\tstruct timespec64 last_isr_tms, last_ack_tms;\n\tu64 maxio_tm;\n\tint i;\n\n\t \n\tseq_printf(sfp,\n\t\t   \"------------------------------------------\\n\"\n\t\t   \"\\t\\t IO Statistics\\n\"\n\t\t   \"------------------------------------------\\n\");\n\n\tmaxio_tm = (u64) atomic64_read(&stats->io.max_time);\n\tseq_printf(sfp,\n\t\t   \"Active IOs                  : %lld\\n\"\n\t\t   \"Max Active IOs              : %lld\\n\"\n\t\t   \"Total IOs                   : %lld\\n\"\n\t\t   \"IOs Completed               : %lld\\n\"\n\t\t   \"IOs Failed                  : %lld\\n\"\n\t\t   \"IOs Not Found               : %lld\\n\"\n\t\t   \"Memory Alloc Failures       : %lld\\n\"\n\t\t   \"REQs Null                   : %lld\\n\"\n\t\t   \"SCSI Cmd Pointers Null      : %lld\\n\"\n\t\t   \"Max SGL for any IO          : %lld\\n\"\n\t\t   \"Max IO Size                 : %lld Sectors\\n\"\n\t\t   \"Max Queuing Time            : %lld\\n\"\n\t\t   \"Max Completion Time         : %lld\\n\"\n\t\t   \"Max IO Process Time(FW)     : %lld (%u msec)\\n\",\n\t\t   (u64) atomic64_read(&stats->io.active),\n\t\t   (u64) atomic64_read(&stats->io.max_active),\n\t\t   (u64) atomic64_read(&stats->io.num_ios),\n\t\t   (u64) atomic64_read(&stats->io.compl),\n\t\t   (u64) atomic64_read(&stats->io.fail),\n\t\t   (u64) atomic64_read(&stats->io.io_not_found),\n\t\t   (u64) atomic64_read(&stats->io.alloc_fail),\n\t\t   (u64) atomic64_read(&stats->io.req_null),\n\t\t   (u64) atomic64_read(&stats->io.sc_null),\n\t\t   (u64) atomic64_read(&stats->io.max_sgl),\n\t\t   (u64) atomic64_read(&stats->io.max_io_sz),\n\t\t   (u64) atomic64_read(&stats->io.max_qtime),\n\t\t   (u64) atomic64_read(&stats->io.max_cmpl_time),\n\t\t   maxio_tm,\n\t\t   jiffies_to_msecs(maxio_tm));\n\n\tseq_puts(sfp, \"\\nSGL Counters\\n\");\n\n\tfor (i = 0; i < SNIC_MAX_SG_DESC_CNT; i++) {\n\t\tseq_printf(sfp,\n\t\t\t   \"%10lld \",\n\t\t\t   (u64) atomic64_read(&stats->io.sgl_cnt[i]));\n\n\t\tif ((i + 1) % 8 == 0)\n\t\t\tseq_puts(sfp, \"\\n\");\n\t}\n\n\t \n\tseq_printf(sfp,\n\t\t   \"\\n-------------------------------------------\\n\"\n\t\t   \"\\t\\t Abort Statistics\\n\"\n\t\t   \"---------------------------------------------\\n\");\n\n\tseq_printf(sfp,\n\t\t   \"Aborts                      : %lld\\n\"\n\t\t   \"Aborts Fail                 : %lld\\n\"\n\t\t   \"Aborts Driver Timeout       : %lld\\n\"\n\t\t   \"Abort FW Timeout            : %lld\\n\"\n\t\t   \"Abort IO NOT Found          : %lld\\n\"\n\t\t   \"Abort Queuing Failed        : %lld\\n\",\n\t\t   (u64) atomic64_read(&stats->abts.num),\n\t\t   (u64) atomic64_read(&stats->abts.fail),\n\t\t   (u64) atomic64_read(&stats->abts.drv_tmo),\n\t\t   (u64) atomic64_read(&stats->abts.fw_tmo),\n\t\t   (u64) atomic64_read(&stats->abts.io_not_found),\n\t\t   (u64) atomic64_read(&stats->abts.q_fail));\n\n\t \n\tseq_printf(sfp,\n\t\t   \"\\n-------------------------------------------\\n\"\n\t\t   \"\\t\\t Reset Statistics\\n\"\n\t\t   \"---------------------------------------------\\n\");\n\n\tseq_printf(sfp,\n\t\t   \"HBA Resets                  : %lld\\n\"\n\t\t   \"HBA Reset Cmpls             : %lld\\n\"\n\t\t   \"HBA Reset Fail              : %lld\\n\",\n\t\t   (u64) atomic64_read(&stats->reset.hba_resets),\n\t\t   (u64) atomic64_read(&stats->reset.hba_reset_cmpl),\n\t\t   (u64) atomic64_read(&stats->reset.hba_reset_fail));\n\n\t \n\tseq_printf(sfp,\n\t\t   \"\\n-------------------------------------------\\n\"\n\t\t   \"\\t\\t Firmware Statistics\\n\"\n\t\t   \"---------------------------------------------\\n\");\n\n\tseq_printf(sfp,\n\t\t\"Active FW Requests             : %lld\\n\"\n\t\t\"Max FW Requests                : %lld\\n\"\n\t\t\"FW Out Of Resource Errs        : %lld\\n\"\n\t\t\"FW IO Errors                   : %lld\\n\"\n\t\t\"FW SCSI Errors                 : %lld\\n\",\n\t\t(u64) atomic64_read(&stats->fw.actv_reqs),\n\t\t(u64) atomic64_read(&stats->fw.max_actv_reqs),\n\t\t(u64) atomic64_read(&stats->fw.out_of_res),\n\t\t(u64) atomic64_read(&stats->fw.io_errs),\n\t\t(u64) atomic64_read(&stats->fw.scsi_errs));\n\n\n\t \n\tseq_printf(sfp,\n\t\t   \"\\n---------------------------------------------\\n\"\n\t\t   \"\\t\\t Other Statistics\\n\"\n\t\t   \"\\n---------------------------------------------\\n\");\n\n\tjiffies_to_timespec64(stats->misc.last_isr_time, &last_isr_tms);\n\tjiffies_to_timespec64(stats->misc.last_ack_time, &last_ack_tms);\n\n\tseq_printf(sfp,\n\t\t   \"Last ISR Time               : %llu (%8llu.%09lu)\\n\"\n\t\t   \"Last Ack Time               : %llu (%8llu.%09lu)\\n\"\n\t\t   \"Ack ISRs                    : %llu\\n\"\n\t\t   \"IO Cmpl ISRs                : %llu\\n\"\n\t\t   \"Err Notify ISRs             : %llu\\n\"\n\t\t   \"Max CQ Entries              : %lld\\n\"\n\t\t   \"Data Count Mismatch         : %lld\\n\"\n\t\t   \"IOs w/ Timeout Status       : %lld\\n\"\n\t\t   \"IOs w/ Aborted Status       : %lld\\n\"\n\t\t   \"IOs w/ SGL Invalid Stat     : %lld\\n\"\n\t\t   \"WQ Desc Alloc Fail          : %lld\\n\"\n\t\t   \"Queue Full                  : %lld\\n\"\n\t\t   \"Queue Ramp Up               : %lld\\n\"\n\t\t   \"Queue Ramp Down             : %lld\\n\"\n\t\t   \"Queue Last Queue Depth      : %lld\\n\"\n\t\t   \"Target Not Ready            : %lld\\n\",\n\t\t   (u64) stats->misc.last_isr_time,\n\t\t   last_isr_tms.tv_sec, last_isr_tms.tv_nsec,\n\t\t   (u64)stats->misc.last_ack_time,\n\t\t   last_ack_tms.tv_sec, last_ack_tms.tv_nsec,\n\t\t   (u64) atomic64_read(&stats->misc.ack_isr_cnt),\n\t\t   (u64) atomic64_read(&stats->misc.cmpl_isr_cnt),\n\t\t   (u64) atomic64_read(&stats->misc.errnotify_isr_cnt),\n\t\t   (u64) atomic64_read(&stats->misc.max_cq_ents),\n\t\t   (u64) atomic64_read(&stats->misc.data_cnt_mismat),\n\t\t   (u64) atomic64_read(&stats->misc.io_tmo),\n\t\t   (u64) atomic64_read(&stats->misc.io_aborted),\n\t\t   (u64) atomic64_read(&stats->misc.sgl_inval),\n\t\t   (u64) atomic64_read(&stats->misc.wq_alloc_fail),\n\t\t   (u64) atomic64_read(&stats->misc.qfull),\n\t\t   (u64) atomic64_read(&stats->misc.qsz_rampup),\n\t\t   (u64) atomic64_read(&stats->misc.qsz_rampdown),\n\t\t   (u64) atomic64_read(&stats->misc.last_qsz),\n\t\t   (u64) atomic64_read(&stats->misc.tgt_not_rdy));\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(snic_stats);\n\nstatic const struct file_operations snic_reset_stats_fops = {\n\t.owner = THIS_MODULE,\n\t.open = snic_reset_stats_open,\n\t.read = snic_reset_stats_read,\n\t.write = snic_reset_stats_write,\n\t.release = snic_reset_stats_release,\n};\n\n \nvoid snic_stats_debugfs_init(struct snic *snic)\n{\n\tchar name[16];\n\n\tsnprintf(name, sizeof(name), \"host%d\", snic->shost->host_no);\n\n\tsnic->stats_host = debugfs_create_dir(name, snic_glob->stats_root);\n\n\tsnic->stats_file = debugfs_create_file(\"stats\", S_IFREG|S_IRUGO,\n\t\t\t\t\t       snic->stats_host, snic,\n\t\t\t\t\t       &snic_stats_fops);\n\n\tsnic->reset_stats_file = debugfs_create_file(\"reset_stats\",\n\t\t\t\t\t\t     S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\t\t\t     snic->stats_host, snic,\n\t\t\t\t\t\t     &snic_reset_stats_fops);\n}\n\n \nvoid\nsnic_stats_debugfs_remove(struct snic *snic)\n{\n\tdebugfs_remove(snic->stats_file);\n\tsnic->stats_file = NULL;\n\n\tdebugfs_remove(snic->reset_stats_file);\n\tsnic->reset_stats_file = NULL;\n\n\tdebugfs_remove(snic->stats_host);\n\tsnic->stats_host = NULL;\n}\n\n \nstatic void *\nsnic_trc_seq_start(struct seq_file *sfp, loff_t *pos)\n{\n\treturn &snic_glob->trc;\n}\n\nstatic void *\nsnic_trc_seq_next(struct seq_file *sfp, void *data, loff_t *pos)\n{\n\treturn NULL;\n}\n\nstatic void\nsnic_trc_seq_stop(struct seq_file *sfp, void *data)\n{\n}\n\n#define SNIC_TRC_PBLEN\t256\nstatic int\nsnic_trc_seq_show(struct seq_file *sfp, void *data)\n{\n\tchar buf[SNIC_TRC_PBLEN];\n\n\tif (snic_get_trc_data(buf, SNIC_TRC_PBLEN) > 0)\n\t\tseq_printf(sfp, \"%s\\n\", buf);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations snic_trc_sops = {\n\t.start\t= snic_trc_seq_start,\n\t.next\t= snic_trc_seq_next,\n\t.stop\t= snic_trc_seq_stop,\n\t.show\t= snic_trc_seq_show,\n};\n\nDEFINE_SEQ_ATTRIBUTE(snic_trc);\n\n#define TRC_ENABLE_FILE\t\"tracing_enable\"\n#define TRC_FILE\t\"trace\"\n \nvoid snic_trc_debugfs_init(void)\n{\n\tdebugfs_create_bool(TRC_ENABLE_FILE, S_IFREG | S_IRUGO | S_IWUSR,\n\t\t\t    snic_glob->trc_root, &snic_glob->trc.enable);\n\n\tdebugfs_create_file(TRC_FILE, S_IFREG | S_IRUGO | S_IWUSR,\n\t\t\t    snic_glob->trc_root, NULL, &snic_trc_fops);\n}\n\n \nvoid\nsnic_trc_debugfs_term(void)\n{\n\tdebugfs_lookup_and_remove(TRC_FILE, snic_glob->trc_root);\n\tdebugfs_lookup_and_remove(TRC_ENABLE_FILE, snic_glob->trc_root);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}