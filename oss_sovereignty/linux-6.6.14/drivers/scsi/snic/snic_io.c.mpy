{
  "module_name": "snic_io.c",
  "hash_id": "084c59e420ebe7d0327820a54a15681a9bc954a9ca03639731a221e857f09a5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/snic/snic_io.c",
  "human_readable_source": "\n\n\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/spinlock.h>\n#include <linux/mempool.h>\n#include <scsi/scsi_tcq.h>\n\n#include \"snic_io.h\"\n#include \"snic.h\"\n#include \"cq_enet_desc.h\"\n#include \"snic_fwint.h\"\n\nstatic void\nsnic_wq_cmpl_frame_send(struct vnic_wq *wq,\n\t\t\t    struct cq_desc *cq_desc,\n\t\t\t    struct vnic_wq_buf *buf,\n\t\t\t    void *opaque)\n{\n\tstruct snic *snic = svnic_dev_priv(wq->vdev);\n\n\tSNIC_BUG_ON(buf->os_buf == NULL);\n\n\tif (snic_log_level & SNIC_DESC_LOGGING)\n\t\tSNIC_HOST_INFO(snic->shost,\n\t\t\t       \"Ack received for snic_host_req %p.\\n\",\n\t\t\t       buf->os_buf);\n\n\tSNIC_TRC(snic->shost->host_no, 0, 0,\n\t\t ((ulong)(buf->os_buf) - sizeof(struct snic_req_info)), 0, 0,\n\t\t 0);\n\n\tbuf->os_buf = NULL;\n}\n\nstatic int\nsnic_wq_cmpl_handler_cont(struct vnic_dev *vdev,\n\t\t\t  struct cq_desc *cq_desc,\n\t\t\t  u8 type,\n\t\t\t  u16 q_num,\n\t\t\t  u16 cmpl_idx,\n\t\t\t  void *opaque)\n{\n\tstruct snic *snic = svnic_dev_priv(vdev);\n\tunsigned long flags;\n\n\tSNIC_BUG_ON(q_num != 0);\n\n\tspin_lock_irqsave(&snic->wq_lock[q_num], flags);\n\tsvnic_wq_service(&snic->wq[q_num],\n\t\t\t cq_desc,\n\t\t\t cmpl_idx,\n\t\t\t snic_wq_cmpl_frame_send,\n\t\t\t NULL);\n\tspin_unlock_irqrestore(&snic->wq_lock[q_num], flags);\n\n\treturn 0;\n}  \n\nint\nsnic_wq_cmpl_handler(struct snic *snic, int work_to_do)\n{\n\tunsigned int work_done = 0;\n\tunsigned int i;\n\n\tsnic->s_stats.misc.last_ack_time = jiffies;\n\tfor (i = 0; i < snic->wq_count; i++) {\n\t\twork_done += svnic_cq_service(&snic->cq[i],\n\t\t\t\t\t      work_to_do,\n\t\t\t\t\t      snic_wq_cmpl_handler_cont,\n\t\t\t\t\t      NULL);\n\t}\n\n\treturn work_done;\n}  \n\nvoid\nsnic_free_wq_buf(struct vnic_wq *wq, struct vnic_wq_buf *buf)\n{\n\n\tstruct snic_host_req *req = buf->os_buf;\n\tstruct snic *snic = svnic_dev_priv(wq->vdev);\n\tstruct snic_req_info *rqi = NULL;\n\tunsigned long flags;\n\n\tdma_unmap_single(&snic->pdev->dev, buf->dma_addr, buf->len,\n\t\t\t DMA_TO_DEVICE);\n\n\trqi = req_to_rqi(req);\n\tspin_lock_irqsave(&snic->spl_cmd_lock, flags);\n\tif (list_empty(&rqi->list)) {\n\t\tspin_unlock_irqrestore(&snic->spl_cmd_lock, flags);\n\t\tgoto end;\n\t}\n\n\tSNIC_BUG_ON(rqi->list.next == NULL);  \n\tlist_del_init(&rqi->list);\n\tspin_unlock_irqrestore(&snic->spl_cmd_lock, flags);\n\n\tif (rqi->sge_va) {\n\t\tsnic_pci_unmap_rsp_buf(snic, rqi);\n\t\tkfree((void *)rqi->sge_va);\n\t\trqi->sge_va = 0;\n\t}\n\tsnic_req_free(snic, rqi);\n\tSNIC_HOST_INFO(snic->shost, \"snic_free_wq_buf .. freed.\\n\");\n\nend:\n\treturn;\n}\n\n \nstatic int\nsnic_select_wq(struct snic *snic)\n{\n\t \n\tBUILD_BUG_ON(SNIC_WQ_MAX > 1);\n\n\treturn 0;\n}\n\nstatic int\nsnic_wqdesc_avail(struct snic *snic, int q_num, int req_type)\n{\n\tint nr_wqdesc = snic->config.wq_enet_desc_count;\n\n\tif (q_num > 0) {\n\t\t \n\t\tSNIC_HOST_INFO(snic->shost, \"desc_avail: Multi Queue case.\\n\");\n\t\tSNIC_BUG_ON(q_num > 0);\n\n\t\treturn -1;\n\t}\n\n\tnr_wqdesc -= atomic64_read(&snic->s_stats.fw.actv_reqs);\n\n\treturn ((req_type == SNIC_REQ_HBA_RESET) ? nr_wqdesc : nr_wqdesc - 1);\n}\n\nint\nsnic_queue_wq_desc(struct snic *snic, void *os_buf, u16 len)\n{\n\tdma_addr_t pa = 0;\n\tunsigned long flags;\n\tstruct snic_fw_stats *fwstats = &snic->s_stats.fw;\n\tstruct snic_host_req *req = (struct snic_host_req *) os_buf;\n\tlong act_reqs;\n\tlong desc_avail = 0;\n\tint q_num = 0;\n\n\tsnic_print_desc(__func__, os_buf, len);\n\n\t \n\tpa = dma_map_single(&snic->pdev->dev, os_buf, len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(&snic->pdev->dev, pa)) {\n\t\tSNIC_HOST_ERR(snic->shost, \"qdesc: PCI DMA Mapping Fail.\\n\");\n\n\t\treturn -ENOMEM;\n\t}\n\n\treq->req_pa = (ulong)pa;\n\n\tq_num = snic_select_wq(snic);\n\n\tspin_lock_irqsave(&snic->wq_lock[q_num], flags);\n\tdesc_avail = snic_wqdesc_avail(snic, q_num, req->hdr.type);\n\tif (desc_avail <= 0) {\n\t\tdma_unmap_single(&snic->pdev->dev, pa, len, DMA_TO_DEVICE);\n\t\treq->req_pa = 0;\n\t\tspin_unlock_irqrestore(&snic->wq_lock[q_num], flags);\n\t\tatomic64_inc(&snic->s_stats.misc.wq_alloc_fail);\n\t\tSNIC_DBG(\"host = %d, WQ is Full\\n\", snic->shost->host_no);\n\n\t\treturn -ENOMEM;\n\t}\n\n\tsnic_queue_wq_eth_desc(&snic->wq[q_num], os_buf, pa, len, 0, 0, 1);\n\t \n\tact_reqs = atomic64_inc_return(&fwstats->actv_reqs);\n\tspin_unlock_irqrestore(&snic->wq_lock[q_num], flags);\n\n\tif (act_reqs > atomic64_read(&fwstats->max_actv_reqs))\n\t\tatomic64_set(&fwstats->max_actv_reqs, act_reqs);\n\n\treturn 0;\n}  \n\n \nvoid\nsnic_handle_untagged_req(struct snic *snic, struct snic_req_info *rqi)\n{\n\tunsigned long flags;\n\n\tINIT_LIST_HEAD(&rqi->list);\n\n\tspin_lock_irqsave(&snic->spl_cmd_lock, flags);\n\tlist_add_tail(&rqi->list, &snic->spl_cmd_list);\n\tspin_unlock_irqrestore(&snic->spl_cmd_lock, flags);\n}\n\n \nstruct snic_req_info *\nsnic_req_init(struct snic *snic, int sg_cnt)\n{\n\tu8 typ;\n\tstruct snic_req_info *rqi = NULL;\n\n\ttyp = (sg_cnt <= SNIC_REQ_CACHE_DFLT_SGL) ?\n\t\tSNIC_REQ_CACHE_DFLT_SGL : SNIC_REQ_CACHE_MAX_SGL;\n\n\trqi = mempool_alloc(snic->req_pool[typ], GFP_ATOMIC);\n\tif (!rqi) {\n\t\tatomic64_inc(&snic->s_stats.io.alloc_fail);\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"Failed to allocate memory from snic req pool id = %d\\n\",\n\t\t\t      typ);\n\t\treturn rqi;\n\t}\n\n\tmemset(rqi, 0, sizeof(*rqi));\n\trqi->rq_pool_type = typ;\n\trqi->start_time = jiffies;\n\trqi->req = (struct snic_host_req *) (rqi + 1);\n\trqi->req_len = sizeof(struct snic_host_req);\n\trqi->snic = snic;\n\n\trqi->req = (struct snic_host_req *)(rqi + 1);\n\n\tif (sg_cnt == 0)\n\t\tgoto end;\n\n\trqi->req_len += (sg_cnt * sizeof(struct snic_sg_desc));\n\n\tif (sg_cnt > atomic64_read(&snic->s_stats.io.max_sgl))\n\t\tatomic64_set(&snic->s_stats.io.max_sgl, sg_cnt);\n\n\tSNIC_BUG_ON(sg_cnt > SNIC_MAX_SG_DESC_CNT);\n\tatomic64_inc(&snic->s_stats.io.sgl_cnt[sg_cnt - 1]);\n\nend:\n\tmemset(rqi->req, 0, rqi->req_len);\n\n\t \n\trqi->req->hdr.init_ctx = (ulong) rqi;\n\n\tSNIC_SCSI_DBG(snic->shost, \"Req_alloc:rqi = %p allocatd.\\n\", rqi);\n\n\treturn rqi;\n}  \n\n \nstruct snic_host_req *\nsnic_abort_req_init(struct snic *snic, struct snic_req_info *rqi)\n{\n\tstruct snic_host_req *req = NULL;\n\n\tSNIC_BUG_ON(!rqi);\n\n\t \n\tif (rqi->abort_req)\n\t\treturn rqi->abort_req;\n\n\n\treq = mempool_alloc(snic->req_pool[SNIC_REQ_TM_CACHE], GFP_ATOMIC);\n\tif (!req) {\n\t\tSNIC_HOST_ERR(snic->shost, \"abts:Failed to alloc tm req.\\n\");\n\t\tWARN_ON_ONCE(1);\n\n\t\treturn NULL;\n\t}\n\n\trqi->abort_req = req;\n\tmemset(req, 0, sizeof(struct snic_host_req));\n\t \n\treq->hdr.init_ctx = (ulong) rqi;\n\n\treturn req;\n}  \n\n \nstruct snic_host_req *\nsnic_dr_req_init(struct snic *snic, struct snic_req_info *rqi)\n{\n\tstruct snic_host_req *req = NULL;\n\n\tSNIC_BUG_ON(!rqi);\n\n\treq = mempool_alloc(snic->req_pool[SNIC_REQ_TM_CACHE], GFP_ATOMIC);\n\tif (!req) {\n\t\tSNIC_HOST_ERR(snic->shost, \"dr:Failed to alloc tm req.\\n\");\n\t\tWARN_ON_ONCE(1);\n\n\t\treturn NULL;\n\t}\n\n\tSNIC_BUG_ON(rqi->dr_req != NULL);\n\trqi->dr_req = req;\n\tmemset(req, 0, sizeof(struct snic_host_req));\n\t \n\treq->hdr.init_ctx = (ulong) rqi;\n\n\treturn req;\n}  \n\n \nvoid\nsnic_req_free(struct snic *snic, struct snic_req_info *rqi)\n{\n\tSNIC_BUG_ON(rqi->req == rqi->abort_req);\n\tSNIC_BUG_ON(rqi->req == rqi->dr_req);\n\tSNIC_BUG_ON(rqi->sge_va != 0);\n\n\tSNIC_SCSI_DBG(snic->shost,\n\t\t      \"Req_free:rqi %p:ioreq %p:abt %p:dr %p\\n\",\n\t\t      rqi, rqi->req, rqi->abort_req, rqi->dr_req);\n\n\tif (rqi->abort_req) {\n\t\tif (rqi->abort_req->req_pa)\n\t\t\tdma_unmap_single(&snic->pdev->dev,\n\t\t\t\t\t rqi->abort_req->req_pa,\n\t\t\t\t\t sizeof(struct snic_host_req),\n\t\t\t\t\t DMA_TO_DEVICE);\n\n\t\tmempool_free(rqi->abort_req, snic->req_pool[SNIC_REQ_TM_CACHE]);\n\t}\n\n\tif (rqi->dr_req) {\n\t\tif (rqi->dr_req->req_pa)\n\t\t\tdma_unmap_single(&snic->pdev->dev,\n\t\t\t\t\t rqi->dr_req->req_pa,\n\t\t\t\t\t sizeof(struct snic_host_req),\n\t\t\t\t\t DMA_TO_DEVICE);\n\n\t\tmempool_free(rqi->dr_req, snic->req_pool[SNIC_REQ_TM_CACHE]);\n\t}\n\n\tif (rqi->req->req_pa)\n\t\tdma_unmap_single(&snic->pdev->dev,\n\t\t\t\t rqi->req->req_pa,\n\t\t\t\t rqi->req_len,\n\t\t\t\t DMA_TO_DEVICE);\n\n\tmempool_free(rqi, snic->req_pool[rqi->rq_pool_type]);\n}\n\nvoid\nsnic_pci_unmap_rsp_buf(struct snic *snic, struct snic_req_info *rqi)\n{\n\tstruct snic_sg_desc *sgd;\n\n\tsgd = req_to_sgl(rqi_to_req(rqi));\n\tSNIC_BUG_ON(sgd[0].addr == 0);\n\tdma_unmap_single(&snic->pdev->dev,\n\t\t\t le64_to_cpu(sgd[0].addr),\n\t\t\t le32_to_cpu(sgd[0].len),\n\t\t\t DMA_FROM_DEVICE);\n}\n\n \nvoid\nsnic_free_all_untagged_reqs(struct snic *snic)\n{\n\tstruct snic_req_info *rqi;\n\tstruct list_head *cur, *nxt;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&snic->spl_cmd_lock, flags);\n\tlist_for_each_safe(cur, nxt, &snic->spl_cmd_list) {\n\t\trqi = list_entry(cur, struct snic_req_info, list);\n\t\tlist_del_init(&rqi->list);\n\t\tif (rqi->sge_va) {\n\t\t\tsnic_pci_unmap_rsp_buf(snic, rqi);\n\t\t\tkfree((void *)rqi->sge_va);\n\t\t\trqi->sge_va = 0;\n\t\t}\n\n\t\tsnic_req_free(snic, rqi);\n\t}\n\tspin_unlock_irqrestore(&snic->spl_cmd_lock, flags);\n}\n\n \nvoid\nsnic_release_untagged_req(struct snic *snic, struct snic_req_info *rqi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&snic->snic_lock, flags);\n\tif (snic->in_remove) {\n\t\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\t\tgoto end;\n\t}\n\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\n\tspin_lock_irqsave(&snic->spl_cmd_lock, flags);\n\tif (list_empty(&rqi->list)) {\n\t\tspin_unlock_irqrestore(&snic->spl_cmd_lock, flags);\n\t\tgoto end;\n\t}\n\tlist_del_init(&rqi->list);\n\tspin_unlock_irqrestore(&snic->spl_cmd_lock, flags);\n\tsnic_req_free(snic, rqi);\n\nend:\n\treturn;\n}\n\n \nvoid\nsnic_hex_dump(char *pfx, char *data, int len)\n{\n\tSNIC_INFO(\"%s Dumping Data of Len = %d\\n\", pfx, len);\n\tprint_hex_dump_bytes(pfx, DUMP_PREFIX_NONE, data, len);\n}\n\n#define\tLINE_BUFSZ\t128\t \nstatic void\nsnic_dump_desc(const char *fn, char *os_buf, int len)\n{\n\tstruct snic_host_req *req = (struct snic_host_req *) os_buf;\n\tstruct snic_fw_req *fwreq = (struct snic_fw_req *) os_buf;\n\tstruct snic_req_info *rqi = NULL;\n\tchar line[LINE_BUFSZ] = { '\\0' };\n\tchar *cmd_str = NULL;\n\n\tif (req->hdr.type >= SNIC_RSP_REPORT_TGTS_CMPL)\n\t\trqi = (struct snic_req_info *) fwreq->hdr.init_ctx;\n\telse\n\t\trqi = (struct snic_req_info *) req->hdr.init_ctx;\n\n\tSNIC_BUG_ON(rqi == NULL || rqi->req == NULL);\n\tswitch (req->hdr.type) {\n\tcase SNIC_REQ_REPORT_TGTS:\n\t\tcmd_str = \"report-tgt : \";\n\t\tsnprintf(line, LINE_BUFSZ, \"SNIC_REQ_REPORT_TGTS :\");\n\t\tbreak;\n\n\tcase SNIC_REQ_ICMND:\n\t\tcmd_str = \"icmnd : \";\n\t\tsnprintf(line, LINE_BUFSZ, \"SNIC_REQ_ICMND : 0x%x :\",\n\t\t\t req->u.icmnd.cdb[0]);\n\t\tbreak;\n\n\tcase SNIC_REQ_ITMF:\n\t\tcmd_str = \"itmf : \";\n\t\tsnprintf(line, LINE_BUFSZ, \"SNIC_REQ_ITMF :\");\n\t\tbreak;\n\n\tcase SNIC_REQ_HBA_RESET:\n\t\tcmd_str = \"hba reset :\";\n\t\tsnprintf(line, LINE_BUFSZ, \"SNIC_REQ_HBA_RESET :\");\n\t\tbreak;\n\n\tcase SNIC_REQ_EXCH_VER:\n\t\tcmd_str = \"exch ver : \";\n\t\tsnprintf(line, LINE_BUFSZ, \"SNIC_REQ_EXCH_VER :\");\n\t\tbreak;\n\n\tcase SNIC_REQ_TGT_INFO:\n\t\tcmd_str = \"tgt info : \";\n\t\tbreak;\n\n\tcase SNIC_RSP_REPORT_TGTS_CMPL:\n\t\tcmd_str = \"report tgt cmpl : \";\n\t\tsnprintf(line, LINE_BUFSZ, \"SNIC_RSP_REPORT_TGTS_CMPL :\");\n\t\tbreak;\n\n\tcase SNIC_RSP_ICMND_CMPL:\n\t\tcmd_str = \"icmnd_cmpl : \";\n\t\tsnprintf(line, LINE_BUFSZ, \"SNIC_RSP_ICMND_CMPL : 0x%x :\",\n\t\t\t rqi->req->u.icmnd.cdb[0]);\n\t\tbreak;\n\n\tcase SNIC_RSP_ITMF_CMPL:\n\t\tcmd_str = \"itmf_cmpl : \";\n\t\tsnprintf(line, LINE_BUFSZ, \"SNIC_RSP_ITMF_CMPL :\");\n\t\tbreak;\n\n\tcase SNIC_RSP_HBA_RESET_CMPL:\n\t\tcmd_str = \"hba_reset_cmpl : \";\n\t\tsnprintf(line, LINE_BUFSZ, \"SNIC_RSP_HBA_RESET_CMPL :\");\n\t\tbreak;\n\n\tcase SNIC_RSP_EXCH_VER_CMPL:\n\t\tcmd_str = \"exch_ver_cmpl : \";\n\t\tsnprintf(line, LINE_BUFSZ, \"SNIC_RSP_EXCH_VER_CMPL :\");\n\t\tbreak;\n\n\tcase SNIC_MSG_ACK:\n\t\tcmd_str = \"msg ack : \";\n\t\tsnprintf(line, LINE_BUFSZ, \"SNIC_MSG_ACK :\");\n\t\tbreak;\n\n\tcase SNIC_MSG_ASYNC_EVNOTIFY:\n\t\tcmd_str = \"async notify : \";\n\t\tsnprintf(line, LINE_BUFSZ, \"SNIC_MSG_ASYNC_EVNOTIFY :\");\n\t\tbreak;\n\n\tdefault:\n\t\tcmd_str = \"unknown : \";\n\t\tSNIC_BUG_ON(1);\n\t\tbreak;\n\t}\n\n\tSNIC_INFO(\"%s:%s >>cmndid=%x:sg_cnt = %x:status = %x:ctx = %lx.\\n\",\n\t\t  fn, line, req->hdr.cmnd_id, req->hdr.sg_cnt, req->hdr.status,\n\t\t  req->hdr.init_ctx);\n\n\t \n\tif (snic_log_level & 0x20)\n\t\tsnic_hex_dump(cmd_str, os_buf, len);\n}  \n\nvoid\nsnic_print_desc(const char *fn, char *os_buf, int len)\n{\n\tif (snic_log_level & SNIC_DESC_LOGGING)\n\t\tsnic_dump_desc(fn, os_buf, len);\n}\n\nvoid\nsnic_calc_io_process_time(struct snic *snic, struct snic_req_info *rqi)\n{\n\tu64 duration;\n\n\tduration = jiffies - rqi->start_time;\n\n\tif (duration > atomic64_read(&snic->s_stats.io.max_time))\n\t\tatomic64_set(&snic->s_stats.io.max_time, duration);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}