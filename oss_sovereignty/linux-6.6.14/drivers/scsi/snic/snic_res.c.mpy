{
  "module_name": "snic_res.c",
  "hash_id": "10f7fbd38c3738ac33b1461b9519ea62fdf77459c3e2132f5afe90bc1b38367e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/snic/snic_res.c",
  "human_readable_source": "\n\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n\n#include \"wq_enet_desc.h\"\n#include \"cq_enet_desc.h\"\n#include \"vnic_resource.h\"\n#include \"vnic_dev.h\"\n#include \"vnic_wq.h\"\n#include \"vnic_cq.h\"\n#include \"vnic_intr.h\"\n#include \"vnic_stats.h\"\n#include \"snic.h\"\n\nint\nsnic_get_vnic_config(struct snic *snic)\n{\n\tstruct vnic_snic_config *c = &snic->config;\n\tint ret;\n\n#define GET_CONFIG(m) \\\n\tdo { \\\n\t\tret = svnic_dev_spec(snic->vdev, \\\n\t\t\t\t     offsetof(struct vnic_snic_config, m), \\\n\t\t\t\t     sizeof(c->m), \\\n\t\t\t\t     &c->m); \\\n\t\tif (ret) { \\\n\t\t\tSNIC_HOST_ERR(snic->shost, \\\n\t\t\t\t      \"Error getting %s, %d\\n\", #m, ret); \\\n\t\t\treturn ret; \\\n\t\t} \\\n\t} while (0)\n\n\tGET_CONFIG(wq_enet_desc_count);\n\tGET_CONFIG(maxdatafieldsize);\n\tGET_CONFIG(intr_timer);\n\tGET_CONFIG(intr_timer_type);\n\tGET_CONFIG(flags);\n\tGET_CONFIG(io_throttle_count);\n\tGET_CONFIG(port_down_timeout);\n\tGET_CONFIG(port_down_io_retries);\n\tGET_CONFIG(luns_per_tgt);\n\tGET_CONFIG(xpt_type);\n\tGET_CONFIG(hid);\n\n\tc->wq_enet_desc_count = min_t(u32,\n\t\t\t\t      VNIC_SNIC_WQ_DESCS_MAX,\n\t\t\t\t      max_t(u32,\n\t\t\t\t\t    VNIC_SNIC_WQ_DESCS_MIN,\n\t\t\t\t\t    c->wq_enet_desc_count));\n\n\tc->wq_enet_desc_count = ALIGN(c->wq_enet_desc_count, 16);\n\n\tc->maxdatafieldsize = min_t(u32,\n\t\t\t\t    VNIC_SNIC_MAXDATAFIELDSIZE_MAX,\n\t\t\t\t    max_t(u32,\n\t\t\t\t\t  VNIC_SNIC_MAXDATAFIELDSIZE_MIN,\n\t\t\t\t\t  c->maxdatafieldsize));\n\n\tc->io_throttle_count = min_t(u32,\n\t\t\t\t     VNIC_SNIC_IO_THROTTLE_COUNT_MAX,\n\t\t\t\t     max_t(u32,\n\t\t\t\t\t   VNIC_SNIC_IO_THROTTLE_COUNT_MIN,\n\t\t\t\t\t   c->io_throttle_count));\n\n\tc->port_down_timeout = min_t(u32,\n\t\t\t\t     VNIC_SNIC_PORT_DOWN_TIMEOUT_MAX,\n\t\t\t\t     c->port_down_timeout);\n\n\tc->port_down_io_retries = min_t(u32,\n\t\t\t\t     VNIC_SNIC_PORT_DOWN_IO_RETRIES_MAX,\n\t\t\t\t     c->port_down_io_retries);\n\n\tc->luns_per_tgt = min_t(u32,\n\t\t\t\tVNIC_SNIC_LUNS_PER_TARGET_MAX,\n\t\t\t\tmax_t(u32,\n\t\t\t\t      VNIC_SNIC_LUNS_PER_TARGET_MIN,\n\t\t\t\t      c->luns_per_tgt));\n\n\tc->intr_timer = min_t(u32, VNIC_INTR_TIMER_MAX, c->intr_timer);\n\n\tSNIC_INFO(\"vNIC resources wq %d\\n\", c->wq_enet_desc_count);\n\tSNIC_INFO(\"vNIC mtu %d intr timer %d\\n\",\n\t\t  c->maxdatafieldsize,\n\t\t  c->intr_timer);\n\n\tSNIC_INFO(\"vNIC flags 0x%x luns per tgt %d\\n\",\n\t\t  c->flags,\n\t\t  c->luns_per_tgt);\n\n\tSNIC_INFO(\"vNIC io throttle count %d\\n\", c->io_throttle_count);\n\tSNIC_INFO(\"vNIC port down timeout %d port down io retries %d\\n\",\n\t\t  c->port_down_timeout,\n\t\t  c->port_down_io_retries);\n\n\tSNIC_INFO(\"vNIC back end type = %d\\n\", c->xpt_type);\n\tSNIC_INFO(\"vNIC hid = %d\\n\", c->hid);\n\n\treturn 0;\n}\n\nvoid\nsnic_get_res_counts(struct snic *snic)\n{\n\tsnic->wq_count = svnic_dev_get_res_count(snic->vdev, RES_TYPE_WQ);\n\tSNIC_BUG_ON(snic->wq_count == 0);\n\tsnic->cq_count = svnic_dev_get_res_count(snic->vdev, RES_TYPE_CQ);\n\tSNIC_BUG_ON(snic->cq_count == 0);\n\tsnic->intr_count = svnic_dev_get_res_count(snic->vdev,\n\t\t\t\t\t\t  RES_TYPE_INTR_CTRL);\n\tSNIC_BUG_ON(snic->intr_count == 0);\n}\n\nvoid\nsnic_free_vnic_res(struct snic *snic)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < snic->wq_count; i++)\n\t\tsvnic_wq_free(&snic->wq[i]);\n\n\tfor (i = 0; i < snic->cq_count; i++)\n\t\tsvnic_cq_free(&snic->cq[i]);\n\n\tfor (i = 0; i < snic->intr_count; i++)\n\t\tsvnic_intr_free(&snic->intr[i]);\n}\n\nint\nsnic_alloc_vnic_res(struct snic *snic)\n{\n\tenum vnic_dev_intr_mode intr_mode;\n\tunsigned int mask_on_assertion;\n\tunsigned int intr_offset;\n\tunsigned int err_intr_enable;\n\tunsigned int err_intr_offset;\n\tunsigned int i;\n\tint ret;\n\n\tintr_mode = svnic_dev_get_intr_mode(snic->vdev);\n\n\tSNIC_INFO(\"vNIC interrupt mode: %s\\n\",\n\t\t  ((intr_mode == VNIC_DEV_INTR_MODE_INTX) ?\n\t\t   \"Legacy PCI INTx\" :\n\t\t   ((intr_mode == VNIC_DEV_INTR_MODE_MSI) ?\n\t\t    \"MSI\" :\n\t\t    ((intr_mode == VNIC_DEV_INTR_MODE_MSIX) ?\n\t\t     \"MSI-X\" : \"Unknown\"))));\n\n\t \n\tSNIC_BUG_ON(intr_mode != VNIC_DEV_INTR_MODE_MSIX);\n\n\tSNIC_INFO(\"wq %d cq %d intr %d\\n\", snic->wq_count,\n\t\t  snic->cq_count,\n\t\t  snic->intr_count);\n\n\n\t \n\tfor (i = 0; i < snic->wq_count; i++) {\n\t\tret = svnic_wq_alloc(snic->vdev,\n\t\t\t\t     &snic->wq[i],\n\t\t\t\t     i,\n\t\t\t\t     snic->config.wq_enet_desc_count,\n\t\t\t\t     sizeof(struct wq_enet_desc));\n\t\tif (ret)\n\t\t\tgoto error_cleanup;\n\t}\n\n\t \n\tfor (i = 0; i < snic->wq_count; i++) {\n\t\tret = svnic_cq_alloc(snic->vdev,\n\t\t\t\t     &snic->cq[i],\n\t\t\t\t     i,\n\t\t\t\t     snic->config.wq_enet_desc_count,\n\t\t\t\t     sizeof(struct cq_enet_wq_desc));\n\t\tif (ret)\n\t\t\tgoto error_cleanup;\n\t}\n\n\tSNIC_BUG_ON(snic->cq_count != 2 * snic->wq_count);\n\t \n\tfor (i = snic->wq_count; i < snic->cq_count; i++) {\n\t\tret = svnic_cq_alloc(snic->vdev,\n\t\t\t\t     &snic->cq[i],\n\t\t\t\t     i,\n\t\t\t\t     (snic->config.wq_enet_desc_count * 3),\n\t\t\t\t     sizeof(struct snic_fw_req));\n\t\tif (ret)\n\t\t\tgoto error_cleanup;\n\t}\n\n\tfor (i = 0; i < snic->intr_count; i++) {\n\t\tret = svnic_intr_alloc(snic->vdev, &snic->intr[i], i);\n\t\tif (ret)\n\t\t\tgoto error_cleanup;\n\t}\n\n\t \n\terr_intr_enable = 1;\n\terr_intr_offset = snic->err_intr_offset;\n\n\tfor (i = 0; i < snic->wq_count; i++) {\n\t\tsvnic_wq_init(&snic->wq[i],\n\t\t\t      i,\n\t\t\t      err_intr_enable,\n\t\t\t      err_intr_offset);\n\t}\n\n\tfor (i = 0; i < snic->cq_count; i++) {\n\t\tintr_offset = i;\n\n\t\tsvnic_cq_init(&snic->cq[i],\n\t\t\t      0  ,\n\t\t\t      1  ,\n\t\t\t      0  ,\n\t\t\t      0  ,\n\t\t\t      1  ,\n\t\t\t      1  ,\n\t\t\t      1  ,\n\t\t\t      0  ,\n\t\t\t      intr_offset,\n\t\t\t      0  );\n\t}\n\n\t \n\tSNIC_BUG_ON(intr_mode != VNIC_DEV_INTR_MODE_MSIX);\n\tmask_on_assertion = 1;\n\n\tfor (i = 0; i < snic->intr_count; i++) {\n\t\tsvnic_intr_init(&snic->intr[i],\n\t\t\t\tsnic->config.intr_timer,\n\t\t\t\tsnic->config.intr_timer_type,\n\t\t\t\tmask_on_assertion);\n\t}\n\n\t \n\tret = svnic_dev_stats_dump(snic->vdev, &snic->stats);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"svnic_dev_stats_dump failed - x%x\\n\",\n\t\t\t      ret);\n\t\tgoto error_cleanup;\n\t}\n\n\t \n\tsvnic_dev_stats_clear(snic->vdev);\n\tret = 0;\n\n\treturn ret;\n\nerror_cleanup:\n\tsnic_free_vnic_res(snic);\n\n\treturn ret;\n}\n\nvoid\nsnic_log_q_error(struct snic *snic)\n{\n\tunsigned int i;\n\tu32 err_status;\n\n\tfor (i = 0; i < snic->wq_count; i++) {\n\t\terr_status = ioread32(&snic->wq[i].ctrl->error_status);\n\t\tif (err_status)\n\t\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t\t      \"WQ[%d] error status %d\\n\",\n\t\t\t\t      i,\n\t\t\t\t      err_status);\n\t}\n}  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}