{
  "module_name": "snic_scsi.c",
  "hash_id": "141252133827f3a4ebfa3c25d2476539cc1c2b0c4184363dced0d40305e8bb47",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/snic/snic_scsi.c",
  "human_readable_source": "\n\n\n#include <linux/mempool.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/workqueue.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_dbg.h>\n\n#include \"snic_io.h\"\n#include \"snic.h\"\n\n#define snic_cmd_tag(sc)\t(scsi_cmd_to_rq(sc)->tag)\n\nconst char *snic_state_str[] = {\n\t[SNIC_INIT]\t= \"SNIC_INIT\",\n\t[SNIC_ERROR]\t= \"SNIC_ERROR\",\n\t[SNIC_ONLINE]\t= \"SNIC_ONLINE\",\n\t[SNIC_OFFLINE]\t= \"SNIC_OFFLINE\",\n\t[SNIC_FWRESET]\t= \"SNIC_FWRESET\",\n};\n\nstatic const char * const snic_req_state_str[] = {\n\t[SNIC_IOREQ_NOT_INITED]\t= \"SNIC_IOREQ_NOT_INITED\",\n\t[SNIC_IOREQ_PENDING]\t= \"SNIC_IOREQ_PENDING\",\n\t[SNIC_IOREQ_ABTS_PENDING] = \"SNIC_IOREQ_ABTS_PENDING\",\n\t[SNIC_IOREQ_ABTS_COMPLETE] = \"SNIC_IOREQ_ABTS_COMPLETE\",\n\t[SNIC_IOREQ_LR_PENDING]\t= \"SNIC_IOREQ_LR_PENDING\",\n\t[SNIC_IOREQ_LR_COMPLETE] = \"SNIC_IOREQ_LR_COMPLETE\",\n\t[SNIC_IOREQ_COMPLETE]\t= \"SNIC_IOREQ_CMD_COMPLETE\",\n};\n\n \nstatic const char * const snic_io_status_str[] = {\n\t[SNIC_STAT_IO_SUCCESS]\t= \"SNIC_STAT_IO_SUCCESS\",  \n\t[SNIC_STAT_INVALID_HDR] = \"SNIC_STAT_INVALID_HDR\",\n\t[SNIC_STAT_OUT_OF_RES]\t= \"SNIC_STAT_OUT_OF_RES\",\n\t[SNIC_STAT_INVALID_PARM] = \"SNIC_STAT_INVALID_PARM\",\n\t[SNIC_STAT_REQ_NOT_SUP]\t= \"SNIC_STAT_REQ_NOT_SUP\",\n\t[SNIC_STAT_IO_NOT_FOUND] = \"SNIC_STAT_IO_NOT_FOUND\",\n\t[SNIC_STAT_ABORTED]\t= \"SNIC_STAT_ABORTED\",\n\t[SNIC_STAT_TIMEOUT]\t= \"SNIC_STAT_TIMEOUT\",\n\t[SNIC_STAT_SGL_INVALID] = \"SNIC_STAT_SGL_INVALID\",\n\t[SNIC_STAT_DATA_CNT_MISMATCH] = \"SNIC_STAT_DATA_CNT_MISMATCH\",\n\t[SNIC_STAT_FW_ERR]\t= \"SNIC_STAT_FW_ERR\",\n\t[SNIC_STAT_ITMF_REJECT] = \"SNIC_STAT_ITMF_REJECT\",\n\t[SNIC_STAT_ITMF_FAIL]\t= \"SNIC_STAT_ITMF_FAIL\",\n\t[SNIC_STAT_ITMF_INCORRECT_LUN] = \"SNIC_STAT_ITMF_INCORRECT_LUN\",\n\t[SNIC_STAT_CMND_REJECT] = \"SNIC_STAT_CMND_REJECT\",\n\t[SNIC_STAT_DEV_OFFLINE] = \"SNIC_STAT_DEV_OFFLINE\",\n\t[SNIC_STAT_NO_BOOTLUN]\t= \"SNIC_STAT_NO_BOOTLUN\",\n\t[SNIC_STAT_SCSI_ERR]\t= \"SNIC_STAT_SCSI_ERR\",\n\t[SNIC_STAT_NOT_READY]\t= \"SNIC_STAT_NOT_READY\",\n\t[SNIC_STAT_FATAL_ERROR]\t= \"SNIC_STAT_FATAL_ERROR\",\n};\n\nstatic void snic_scsi_cleanup(struct snic *, int);\n\nconst char *\nsnic_state_to_str(unsigned int state)\n{\n\tif (state >= ARRAY_SIZE(snic_state_str) || !snic_state_str[state])\n\t\treturn \"Unknown\";\n\n\treturn snic_state_str[state];\n}\n\nstatic const char *\nsnic_io_status_to_str(unsigned int state)\n{\n\tif ((state >= ARRAY_SIZE(snic_io_status_str)) ||\n\t     (!snic_io_status_str[state]))\n\t\treturn \"Unknown\";\n\n\treturn snic_io_status_str[state];\n}\n\nstatic const char *\nsnic_ioreq_state_to_str(unsigned int state)\n{\n\tif (state >= ARRAY_SIZE(snic_req_state_str) ||\n\t\t\t!snic_req_state_str[state])\n\t\treturn \"Unknown\";\n\n\treturn snic_req_state_str[state];\n}\n\nstatic inline spinlock_t *\nsnic_io_lock_hash(struct snic *snic, struct scsi_cmnd *sc)\n{\n\tu32 hash = snic_cmd_tag(sc) & (SNIC_IO_LOCKS - 1);\n\n\treturn &snic->io_req_lock[hash];\n}\n\nstatic inline spinlock_t *\nsnic_io_lock_tag(struct snic *snic, int tag)\n{\n\treturn &snic->io_req_lock[tag & (SNIC_IO_LOCKS - 1)];\n}\n\n \nstatic void\nsnic_release_req_buf(struct snic *snic,\n\t\t   struct snic_req_info *rqi,\n\t\t   struct scsi_cmnd *sc)\n{\n\tstruct snic_host_req *req = rqi_to_req(rqi);\n\n\t \n\tSNIC_BUG_ON(!((CMD_STATE(sc) == SNIC_IOREQ_COMPLETE) ||\n\t\t      (CMD_STATE(sc) == SNIC_IOREQ_ABTS_COMPLETE) ||\n\t\t      (CMD_FLAGS(sc) & SNIC_DEV_RST_NOTSUP) ||\n\t\t      (CMD_FLAGS(sc) & SNIC_IO_INTERNAL_TERM_ISSUED) ||\n\t\t      (CMD_FLAGS(sc) & SNIC_DEV_RST_TERM_ISSUED) ||\n\t\t      (CMD_FLAGS(sc) & SNIC_SCSI_CLEANUP) ||\n\t\t      (CMD_STATE(sc) == SNIC_IOREQ_LR_COMPLETE)));\n\n\tSNIC_SCSI_DBG(snic->shost,\n\t\t      \"Rel_req:sc %p:tag %x:rqi %p:ioreq %p:abt %p:dr %p: state %s:flags 0x%llx\\n\",\n\t\t      sc, snic_cmd_tag(sc), rqi, rqi->req, rqi->abort_req,\n\t\t      rqi->dr_req, snic_ioreq_state_to_str(CMD_STATE(sc)),\n\t\t      CMD_FLAGS(sc));\n\n\tif (req->u.icmnd.sense_addr)\n\t\tdma_unmap_single(&snic->pdev->dev,\n\t\t\t\t le64_to_cpu(req->u.icmnd.sense_addr),\n\t\t\t\t SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t DMA_FROM_DEVICE);\n\n\tscsi_dma_unmap(sc);\n\n\tsnic_req_free(snic, rqi);\n}  \n\n \nstatic int\nsnic_queue_icmnd_req(struct snic *snic,\n\t\t     struct snic_req_info *rqi,\n\t\t     struct scsi_cmnd *sc,\n\t\t     int sg_cnt)\n{\n\tstruct scatterlist *sg;\n\tstruct snic_sg_desc *sgd;\n\tdma_addr_t pa = 0;\n\tstruct scsi_lun lun;\n\tu16 flags = 0;\n\tint ret = 0;\n\tunsigned int i;\n\n\tif (sg_cnt) {\n\t\tflags = SNIC_ICMND_ESGL;\n\t\tsgd = (struct snic_sg_desc *) req_to_sgl(rqi->req);\n\n\t\tfor_each_sg(scsi_sglist(sc), sg, sg_cnt, i) {\n\t\t\tsgd->addr = cpu_to_le64(sg_dma_address(sg));\n\t\t\tsgd->len = cpu_to_le32(sg_dma_len(sg));\n\t\t\tsgd->_resvd = 0;\n\t\t\tsgd++;\n\t\t}\n\t}\n\n\tpa = dma_map_single(&snic->pdev->dev,\n\t\t\t    sc->sense_buffer,\n\t\t\t    SCSI_SENSE_BUFFERSIZE,\n\t\t\t    DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&snic->pdev->dev, pa)) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"QIcmnd:PCI Map Failed for sns buf %p tag %x\\n\",\n\t\t\t      sc->sense_buffer, snic_cmd_tag(sc));\n\t\tret = -ENOMEM;\n\n\t\treturn ret;\n\t}\n\n\tint_to_scsilun(sc->device->lun, &lun);\n\tif (sc->sc_data_direction == DMA_FROM_DEVICE)\n\t\tflags |= SNIC_ICMND_RD;\n\tif (sc->sc_data_direction == DMA_TO_DEVICE)\n\t\tflags |= SNIC_ICMND_WR;\n\n\t \n\tsnic_icmnd_init(rqi->req,\n\t\t\tsnic_cmd_tag(sc),\n\t\t\tsnic->config.hid,  \n\t\t\t(ulong) rqi,\n\t\t\tflags,  \n\t\t\trqi->tgt_id,\n\t\t\tlun.scsi_lun,\n\t\t\tsc->cmnd,\n\t\t\tsc->cmd_len,\n\t\t\tscsi_bufflen(sc),\n\t\t\tsg_cnt,\n\t\t\t(ulong) req_to_sgl(rqi->req),\n\t\t\tpa,  \n\t\t\tSCSI_SENSE_BUFFERSIZE);\n\n\tatomic64_inc(&snic->s_stats.io.active);\n\tret = snic_queue_wq_desc(snic, rqi->req, rqi->req_len);\n\tif (ret) {\n\t\tatomic64_dec(&snic->s_stats.io.active);\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"QIcmnd: Queuing Icmnd Failed. ret = %d\\n\",\n\t\t\t      ret);\n\t} else\n\t\tsnic_stats_update_active_ios(&snic->s_stats);\n\n\treturn ret;\n}  \n\n \nstatic int\nsnic_issue_scsi_req(struct snic *snic,\n\t\t      struct snic_tgt *tgt,\n\t\t      struct scsi_cmnd *sc)\n{\n\tstruct snic_req_info *rqi = NULL;\n\tint sg_cnt = 0;\n\tint ret = 0;\n\tu32 tag = snic_cmd_tag(sc);\n\tu64 cmd_trc = 0, cmd_st_flags = 0;\n\tspinlock_t *io_lock = NULL;\n\tunsigned long flags;\n\n\tCMD_STATE(sc) = SNIC_IOREQ_NOT_INITED;\n\tCMD_FLAGS(sc) = SNIC_NO_FLAGS;\n\tsg_cnt = scsi_dma_map(sc);\n\tif (sg_cnt < 0) {\n\t\tSNIC_TRC((u16)snic->shost->host_no, tag, (ulong) sc, 0,\n\t\t\t sc->cmnd[0], sg_cnt, CMD_STATE(sc));\n\n\t\tSNIC_HOST_ERR(snic->shost, \"issue_sc:Failed to map SG List.\\n\");\n\t\tret = -ENOMEM;\n\n\t\tgoto issue_sc_end;\n\t}\n\n\trqi = snic_req_init(snic, sg_cnt);\n\tif (!rqi) {\n\t\tscsi_dma_unmap(sc);\n\t\tret = -ENOMEM;\n\n\t\tgoto issue_sc_end;\n\t}\n\n\trqi->tgt_id = tgt->id;\n\trqi->sc = sc;\n\n\tCMD_STATE(sc) = SNIC_IOREQ_PENDING;\n\tCMD_SP(sc) = (char *) rqi;\n\tcmd_trc = SNIC_TRC_CMD(sc);\n\tCMD_FLAGS(sc) |= (SNIC_IO_INITIALIZED | SNIC_IO_ISSUED);\n\tcmd_st_flags = SNIC_TRC_CMD_STATE_FLAGS(sc);\n\tio_lock = snic_io_lock_hash(snic, sc);\n\n\t \n\tret = snic_queue_icmnd_req(snic, rqi, sc, sg_cnt);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"issue_sc: icmnd qing Failed for sc %p, err %d\\n\",\n\t\t\t      sc, ret);\n\n\t\tspin_lock_irqsave(io_lock, flags);\n\t\trqi = (struct snic_req_info *) CMD_SP(sc);\n\t\tCMD_SP(sc) = NULL;\n\t\tCMD_STATE(sc) = SNIC_IOREQ_COMPLETE;\n\t\tCMD_FLAGS(sc) &= ~SNIC_IO_ISSUED;  \n\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\tif (rqi)\n\t\t\tsnic_release_req_buf(snic, rqi, sc);\n\n\t\tSNIC_TRC(snic->shost->host_no, tag, (ulong) sc, 0, 0, 0,\n\t\t\t SNIC_TRC_CMD_STATE_FLAGS(sc));\n\t} else {\n\t\tu32 io_sz = scsi_bufflen(sc) >> 9;\n\t\tu32 qtime = jiffies - rqi->start_time;\n\t\tstruct snic_io_stats *iostats = &snic->s_stats.io;\n\n\t\tif (io_sz > atomic64_read(&iostats->max_io_sz))\n\t\t\tatomic64_set(&iostats->max_io_sz, io_sz);\n\n\t\tif (qtime > atomic64_read(&iostats->max_qtime))\n\t\t\tatomic64_set(&iostats->max_qtime, qtime);\n\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"issue_sc:sc %p, tag %d queued to WQ.\\n\",\n\t\t\t      sc, tag);\n\n\t\tSNIC_TRC(snic->shost->host_no, tag, (ulong) sc, (ulong) rqi,\n\t\t\t sg_cnt, cmd_trc, cmd_st_flags);\n\t}\n\nissue_sc_end:\n\n\treturn ret;\n}  \n\n\n \nint\nsnic_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *sc)\n{\n\tstruct snic_tgt *tgt = NULL;\n\tstruct snic *snic = shost_priv(shost);\n\tint ret;\n\n\ttgt = starget_to_tgt(scsi_target(sc->device));\n\tret = snic_tgt_chkready(tgt);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost, \"Tgt %p id %d Not Ready.\\n\", tgt, tgt->id);\n\t\tatomic64_inc(&snic->s_stats.misc.tgt_not_rdy);\n\t\tsc->result = ret;\n\t\tscsi_done(sc);\n\n\t\treturn 0;\n\t}\n\n\tif (snic_get_state(snic) != SNIC_ONLINE) {\n\t\tSNIC_HOST_ERR(shost, \"snic state is %s\\n\",\n\t\t\t      snic_state_str[snic_get_state(snic)]);\n\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\tatomic_inc(&snic->ios_inflight);\n\n\tSNIC_SCSI_DBG(shost, \"sc %p Tag %d (sc %0x) lun %lld in snic_qcmd\\n\",\n\t\t      sc, snic_cmd_tag(sc), sc->cmnd[0], sc->device->lun);\n\n\tret = snic_issue_scsi_req(snic, tgt, sc);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost, \"Failed to Q, Scsi Req w/ err %d.\\n\", ret);\n\t\tret = SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tatomic_dec(&snic->ios_inflight);\n\n\treturn ret;\n}  \n\n \nstatic void\nsnic_proc_tmreq_pending_state(struct snic *snic,\n\t\t\t      struct scsi_cmnd *sc,\n\t\t\t      u8 cmpl_status)\n{\n\tint state = CMD_STATE(sc);\n\n\tif (state == SNIC_IOREQ_ABTS_PENDING)\n\t\tCMD_FLAGS(sc) |= SNIC_IO_ABTS_PENDING;\n\telse if (state == SNIC_IOREQ_LR_PENDING)\n\t\tCMD_FLAGS(sc) |= SNIC_DEV_RST_PENDING;\n\telse\n\t\tSNIC_BUG_ON(1);\n\n\tswitch (cmpl_status) {\n\tcase SNIC_STAT_IO_SUCCESS:\n\t\tCMD_FLAGS(sc) |= SNIC_IO_DONE;\n\t\tbreak;\n\n\tcase SNIC_STAT_ABORTED:\n\t\tCMD_FLAGS(sc) |= SNIC_IO_ABORTED;\n\t\tbreak;\n\n\tdefault:\n\t\tSNIC_BUG_ON(1);\n\t}\n}\n\n \nstatic void\nsnic_process_io_failed_state(struct snic *snic,\n\t\t\t     struct snic_icmnd_cmpl *icmnd_cmpl,\n\t\t\t     struct scsi_cmnd *sc,\n\t\t\t     u8 cmpl_stat)\n{\n\tint res = 0;\n\n\tswitch (cmpl_stat) {\n\tcase SNIC_STAT_TIMEOUT:\t\t \n\t\tatomic64_inc(&snic->s_stats.misc.io_tmo);\n\t\tres = DID_TIME_OUT;\n\t\tbreak;\n\n\tcase SNIC_STAT_ABORTED:\t\t \n\t\tatomic64_inc(&snic->s_stats.misc.io_aborted);\n\t\tres = DID_ABORT;\n\t\tbreak;\n\n\tcase SNIC_STAT_DATA_CNT_MISMATCH: \n\t\tatomic64_inc(&snic->s_stats.misc.data_cnt_mismat);\n\t\tscsi_set_resid(sc, le32_to_cpu(icmnd_cmpl->resid));\n\t\tres = DID_ERROR;\n\t\tbreak;\n\n\tcase SNIC_STAT_OUT_OF_RES:  \n\t\tatomic64_inc(&snic->s_stats.fw.out_of_res);\n\t\tres = DID_REQUEUE;\n\t\tbreak;\n\n\tcase SNIC_STAT_IO_NOT_FOUND:\t \n\t\tatomic64_inc(&snic->s_stats.io.io_not_found);\n\t\tres = DID_ERROR;\n\t\tbreak;\n\n\tcase SNIC_STAT_SGL_INVALID:\t \n\t\tatomic64_inc(&snic->s_stats.misc.sgl_inval);\n\t\tres = DID_ERROR;\n\t\tbreak;\n\n\tcase SNIC_STAT_FW_ERR:\t\t \n\t\tatomic64_inc(&snic->s_stats.fw.io_errs);\n\t\tres = DID_ERROR;\n\t\tbreak;\n\n\tcase SNIC_STAT_SCSI_ERR:\t \n\t\tatomic64_inc(&snic->s_stats.fw.scsi_errs);\n\t\tbreak;\n\n\tcase SNIC_STAT_NOT_READY:\t \n\tcase SNIC_STAT_DEV_OFFLINE:\t \n\t\tres = DID_NO_CONNECT;\n\t\tbreak;\n\n\tcase SNIC_STAT_INVALID_HDR:\t \n\tcase SNIC_STAT_INVALID_PARM:\t \n\tcase SNIC_STAT_REQ_NOT_SUP:\t \n\tcase SNIC_STAT_CMND_REJECT:\t \n\tcase SNIC_STAT_FATAL_ERROR:\t \n\tdefault:\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"Invalid Hdr/Param or Req Not Supported or Cmnd Rejected or Device Offline. or Unknown\\n\");\n\t\tres = DID_ERROR;\n\t\tbreak;\n\t}\n\n\tSNIC_HOST_ERR(snic->shost, \"fw returns failed status %s flags 0x%llx\\n\",\n\t\t      snic_io_status_to_str(cmpl_stat), CMD_FLAGS(sc));\n\n\t \n\tsc->result = (res << 16) | icmnd_cmpl->scsi_status;\n}  \n\n \nstatic int\nsnic_tmreq_pending(struct scsi_cmnd *sc)\n{\n\tint state = CMD_STATE(sc);\n\n\treturn ((state == SNIC_IOREQ_ABTS_PENDING) ||\n\t\t\t(state == SNIC_IOREQ_LR_PENDING));\n}\n\n \nstatic int\nsnic_process_icmnd_cmpl_status(struct snic *snic,\n\t\t\t       struct snic_icmnd_cmpl *icmnd_cmpl,\n\t\t\t       u8 cmpl_stat,\n\t\t\t       struct scsi_cmnd *sc)\n{\n\tu8 scsi_stat = icmnd_cmpl->scsi_status;\n\tint ret = 0;\n\n\t \n\tCMD_STATE(sc) = SNIC_IOREQ_COMPLETE;\n\n\tif (likely(cmpl_stat == SNIC_STAT_IO_SUCCESS)) {\n\t\tsc->result = (DID_OK << 16) | scsi_stat;\n\n\t\t \n\t\tscsi_set_resid(sc, le32_to_cpu(icmnd_cmpl->resid));\n\n\t\tif (icmnd_cmpl->flags & SNIC_ICMND_CMPL_UNDR_RUN)\n\t\t\tatomic64_inc(&snic->s_stats.misc.io_under_run);\n\n\t\tif (icmnd_cmpl->scsi_status == SAM_STAT_TASK_SET_FULL)\n\t\t\tatomic64_inc(&snic->s_stats.misc.qfull);\n\n\t\tret = 0;\n\t} else {\n\t\tsnic_process_io_failed_state(snic, icmnd_cmpl, sc, cmpl_stat);\n\t\tatomic64_inc(&snic->s_stats.io.fail);\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"icmnd_cmpl: IO Failed : Hdr Status %s flags 0x%llx\\n\",\n\t\t\t      snic_io_status_to_str(cmpl_stat), CMD_FLAGS(sc));\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}  \n\n\n \nstatic void\nsnic_icmnd_cmpl_handler(struct snic *snic, struct snic_fw_req *fwreq)\n{\n\tu8 typ, hdr_stat;\n\tu32 cmnd_id, hid;\n\tulong ctx;\n\tstruct scsi_cmnd *sc = NULL;\n\tstruct snic_icmnd_cmpl *icmnd_cmpl = NULL;\n\tstruct snic_host_req *req = NULL;\n\tstruct snic_req_info *rqi = NULL;\n\tunsigned long flags, start_time;\n\tspinlock_t *io_lock;\n\tu8 sc_stat = 0;\n\n\tsnic_io_hdr_dec(&fwreq->hdr, &typ, &hdr_stat, &cmnd_id, &hid, &ctx);\n\ticmnd_cmpl = &fwreq->u.icmnd_cmpl;\n\tsc_stat = icmnd_cmpl->scsi_status;\n\n\tSNIC_SCSI_DBG(snic->shost,\n\t\t      \"Icmnd_cmpl: type = %x, hdr_stat = %x, cmnd_id = %x, hid = %x,i ctx = %lx\\n\",\n\t\t      typ, hdr_stat, cmnd_id, hid, ctx);\n\n\tif (cmnd_id >= snic->max_tag_id) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"Icmnd_cmpl:Tag Error:Out of Range Tag %d, hdr status = %s\\n\",\n\t\t\t      cmnd_id, snic_io_status_to_str(hdr_stat));\n\t\treturn;\n\t}\n\n\tsc = scsi_host_find_tag(snic->shost, cmnd_id);\n\tWARN_ON_ONCE(!sc);\n\n\tif (!sc) {\n\t\tatomic64_inc(&snic->s_stats.io.sc_null);\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"Icmnd_cmpl: Scsi Cmnd Not found, sc = NULL Hdr Status = %s tag = 0x%x fwreq = 0x%p\\n\",\n\t\t\t      snic_io_status_to_str(hdr_stat),\n\t\t\t      cmnd_id,\n\t\t\t      fwreq);\n\n\t\tSNIC_TRC(snic->shost->host_no, cmnd_id, 0,\n\t\t\t ((u64)hdr_stat << 16 |\n\t\t\t  (u64)sc_stat << 8 | (u64)icmnd_cmpl->flags),\n\t\t\t (ulong) fwreq, le32_to_cpu(icmnd_cmpl->resid), ctx);\n\n\t\treturn;\n\t}\n\n\tio_lock = snic_io_lock_hash(snic, sc);\n\n\tspin_lock_irqsave(io_lock, flags);\n\trqi = (struct snic_req_info *) CMD_SP(sc);\n\tSNIC_SCSI_DBG(snic->shost,\n\t\t      \"Icmnd_cmpl:lun %lld sc %p cmd %xtag %d flags 0x%llx rqi %p\\n\",\n\t\t      sc->device->lun, sc, sc->cmnd[0], snic_cmd_tag(sc),\n\t\t      CMD_FLAGS(sc), rqi);\n\n\tif (CMD_FLAGS(sc) & SNIC_HOST_RESET_CMD_TERM) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\treturn;\n\t}\n\n\tSNIC_BUG_ON(rqi != (struct snic_req_info *)ctx);\n\tWARN_ON_ONCE(req);\n\tif (!rqi) {\n\t\tatomic64_inc(&snic->s_stats.io.req_null);\n\t\tCMD_FLAGS(sc) |= SNIC_IO_REQ_NULL;\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"Icmnd_cmpl:Host Req Not Found(null), Hdr Status %s, Tag 0x%x, sc 0x%p flags 0x%llx\\n\",\n\t\t\t      snic_io_status_to_str(hdr_stat),\n\t\t\t      cmnd_id, sc, CMD_FLAGS(sc));\n\t\treturn;\n\t}\n\n\trqi = (struct snic_req_info *) ctx;\n\tstart_time = rqi->start_time;\n\n\t \n\trqi->io_cmpl = 1;\n\n\t \n\tif (unlikely(snic_tmreq_pending(sc))) {\n\t\tsnic_proc_tmreq_pending_state(snic, sc, hdr_stat);\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\tsnic_stats_update_io_cmpl(&snic->s_stats);\n\n\t\t \n\t\tif (likely(hdr_stat == SNIC_STAT_ABORTED))\n\t\t\treturn;\n\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"icmnd_cmpl:TM Req Pending(%s), Hdr Status %s sc 0x%p scsi status %x resid %d flags 0x%llx\\n\",\n\t\t\t      snic_ioreq_state_to_str(CMD_STATE(sc)),\n\t\t\t      snic_io_status_to_str(hdr_stat),\n\t\t\t      sc, sc_stat, le32_to_cpu(icmnd_cmpl->resid),\n\t\t\t      CMD_FLAGS(sc));\n\n\t\tSNIC_TRC(snic->shost->host_no, cmnd_id, (ulong) sc,\n\t\t\t jiffies_to_msecs(jiffies - start_time), (ulong) fwreq,\n\t\t\t SNIC_TRC_CMD(sc), SNIC_TRC_CMD_STATE_FLAGS(sc));\n\n\t\treturn;\n\t}\n\n\tif (snic_process_icmnd_cmpl_status(snic, icmnd_cmpl, hdr_stat, sc)) {\n\t\tscsi_print_command(sc);\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"icmnd_cmpl:IO Failed, sc 0x%p Tag %d Cmd %x Hdr Status %s flags 0x%llx\\n\",\n\t\t\t      sc, sc->cmnd[0], cmnd_id,\n\t\t\t      snic_io_status_to_str(hdr_stat), CMD_FLAGS(sc));\n\t}\n\n\t \n\tCMD_SP(sc) = NULL;\n\tCMD_FLAGS(sc) |= SNIC_IO_DONE;\n\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\t \n\tsnic_calc_io_process_time(snic, rqi);\n\n\tsnic_release_req_buf(snic, rqi, sc);\n\n\tSNIC_TRC(snic->shost->host_no, cmnd_id, (ulong) sc,\n\t\t jiffies_to_msecs(jiffies - start_time), (ulong) fwreq,\n\t\t SNIC_TRC_CMD(sc), SNIC_TRC_CMD_STATE_FLAGS(sc));\n\n\n\tscsi_done(sc);\n\n\tsnic_stats_update_io_cmpl(&snic->s_stats);\n}  \n\nstatic void\nsnic_proc_dr_cmpl_locked(struct snic *snic,\n\t\t\t struct snic_fw_req *fwreq,\n\t\t\t u8 cmpl_stat,\n\t\t\t u32 cmnd_id,\n\t\t\t struct scsi_cmnd *sc)\n{\n\tstruct snic_req_info *rqi = (struct snic_req_info *) CMD_SP(sc);\n\tu32 start_time = rqi->start_time;\n\n\tCMD_LR_STATUS(sc) = cmpl_stat;\n\n\tSNIC_SCSI_DBG(snic->shost, \"itmf_cmpl: Cmd State = %s\\n\",\n\t\t      snic_ioreq_state_to_str(CMD_STATE(sc)));\n\n\tif (CMD_STATE(sc) == SNIC_IOREQ_ABTS_PENDING) {\n\t\tCMD_FLAGS(sc) |= SNIC_DEV_RST_ABTS_PENDING;\n\n\t\tSNIC_TRC(snic->shost->host_no, cmnd_id, (ulong) sc,\n\t\t\t jiffies_to_msecs(jiffies - start_time),\n\t\t\t (ulong) fwreq, 0, SNIC_TRC_CMD_STATE_FLAGS(sc));\n\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"itmf_cmpl: Terminate Pending Dev Reset Cmpl Recvd.id %x, status %s flags 0x%llx\\n\",\n\t\t\t      (int)(cmnd_id & SNIC_TAG_MASK),\n\t\t\t      snic_io_status_to_str(cmpl_stat),\n\t\t\t      CMD_FLAGS(sc));\n\n\t\treturn;\n\t}\n\n\n\tif (CMD_FLAGS(sc) & SNIC_DEV_RST_TIMEDOUT) {\n\t\tSNIC_TRC(snic->shost->host_no, cmnd_id, (ulong) sc,\n\t\t\t jiffies_to_msecs(jiffies - start_time),\n\t\t\t (ulong) fwreq, 0, SNIC_TRC_CMD_STATE_FLAGS(sc));\n\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"itmf_cmpl:Dev Reset Completion Received after timeout. id %d cmpl status %s flags 0x%llx\\n\",\n\t\t\t      (int)(cmnd_id & SNIC_TAG_MASK),\n\t\t\t      snic_io_status_to_str(cmpl_stat),\n\t\t\t      CMD_FLAGS(sc));\n\n\t\treturn;\n\t}\n\n\tCMD_STATE(sc) = SNIC_IOREQ_LR_COMPLETE;\n\tCMD_FLAGS(sc) |= SNIC_DEV_RST_DONE;\n\n\tSNIC_SCSI_DBG(snic->shost,\n\t\t      \"itmf_cmpl:Dev Reset Cmpl Recvd id %d cmpl status %s flags 0x%llx\\n\",\n\t\t      (int)(cmnd_id & SNIC_TAG_MASK),\n\t\t      snic_io_status_to_str(cmpl_stat),\n\t\t      CMD_FLAGS(sc));\n\n\tif (rqi->dr_done)\n\t\tcomplete(rqi->dr_done);\n}  \n\n \nstatic void\nsnic_update_abort_stats(struct snic *snic, u8 cmpl_stat)\n{\n\tstruct snic_abort_stats *abt_stats = &snic->s_stats.abts;\n\n\tSNIC_SCSI_DBG(snic->shost, \"Updating Abort stats.\\n\");\n\n\tswitch (cmpl_stat) {\n\tcase  SNIC_STAT_IO_SUCCESS:\n\t\tbreak;\n\n\tcase SNIC_STAT_TIMEOUT:\n\t\tatomic64_inc(&abt_stats->fw_tmo);\n\t\tbreak;\n\n\tcase SNIC_STAT_IO_NOT_FOUND:\n\t\tatomic64_inc(&abt_stats->io_not_found);\n\t\tbreak;\n\n\tdefault:\n\t\tatomic64_inc(&abt_stats->fail);\n\t\tbreak;\n\t}\n}\n\nstatic int\nsnic_process_itmf_cmpl(struct snic *snic,\n\t\t       struct snic_fw_req *fwreq,\n\t\t       u32 cmnd_id,\n\t\t       u8 cmpl_stat,\n\t\t       struct scsi_cmnd *sc)\n{\n\tstruct snic_req_info *rqi = NULL;\n\tu32 tm_tags = 0;\n\tspinlock_t *io_lock = NULL;\n\tunsigned long flags;\n\tu32 start_time = 0;\n\tint ret = 0;\n\n\tio_lock = snic_io_lock_hash(snic, sc);\n\tspin_lock_irqsave(io_lock, flags);\n\tif (CMD_FLAGS(sc) & SNIC_HOST_RESET_CMD_TERM) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\treturn ret;\n\t}\n\trqi = (struct snic_req_info *) CMD_SP(sc);\n\tWARN_ON_ONCE(!rqi);\n\n\tif (!rqi) {\n\t\tatomic64_inc(&snic->s_stats.io.req_null);\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tCMD_FLAGS(sc) |= SNIC_IO_ABTS_TERM_REQ_NULL;\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"itmf_cmpl: rqi is null,Hdr stat = %s Tag = 0x%x sc = 0x%p flags 0x%llx\\n\",\n\t\t\t      snic_io_status_to_str(cmpl_stat), cmnd_id, sc,\n\t\t\t      CMD_FLAGS(sc));\n\n\t\treturn ret;\n\t}\n\n\t \n\ttm_tags = cmnd_id & ~(SNIC_TAG_MASK);\n\n\tstart_time = rqi->start_time;\n\tcmnd_id &= (SNIC_TAG_MASK);\n\n\tswitch (tm_tags) {\n\tcase SNIC_TAG_ABORT:\n\t\t \n\t\tsnic_update_abort_stats(snic, cmpl_stat);\n\n\t\tif (CMD_STATE(sc) != SNIC_IOREQ_ABTS_PENDING) {\n\t\t\t \n\t\t\tret = -1;\n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tCMD_STATE(sc) = SNIC_IOREQ_ABTS_COMPLETE;\n\t\tCMD_ABTS_STATUS(sc) = cmpl_stat;\n\t\tCMD_FLAGS(sc) |= SNIC_IO_ABTS_TERM_DONE;\n\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"itmf_cmpl:Abort Cmpl Recvd.Tag 0x%x Status %s flags 0x%llx\\n\",\n\t\t\t      cmnd_id,\n\t\t\t      snic_io_status_to_str(cmpl_stat),\n\t\t\t      CMD_FLAGS(sc));\n\n\t\t \n\t\tif (rqi->abts_done) {\n\t\t\tcomplete(rqi->abts_done);\n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\t\tbreak;  \n\t\t}\n\n\t\tCMD_SP(sc) = NULL;\n\t\tsc->result = (DID_ERROR << 16);\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"itmf_cmpl: Completing IO. sc %p flags 0x%llx\\n\",\n\t\t\t      sc, CMD_FLAGS(sc));\n\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\tsnic_release_req_buf(snic, rqi, sc);\n\n\t\tSNIC_TRC(snic->shost->host_no, cmnd_id, (ulong) sc,\n\t\t\t jiffies_to_msecs(jiffies - start_time),\n\t\t\t (ulong) fwreq, SNIC_TRC_CMD(sc),\n\t\t\t SNIC_TRC_CMD_STATE_FLAGS(sc));\n\n\t\tscsi_done(sc);\n\n\t\tbreak;\n\n\tcase SNIC_TAG_DEV_RST:\n\tcase SNIC_TAG_DEV_RST | SNIC_TAG_IOCTL_DEV_RST:\n\t\tsnic_proc_dr_cmpl_locked(snic, fwreq, cmpl_stat, cmnd_id, sc);\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tret = 0;\n\n\t\tbreak;\n\n\tcase SNIC_TAG_ABORT | SNIC_TAG_DEV_RST:\n\t\t \n\n\t\tCMD_STATE(sc) = SNIC_IOREQ_ABTS_COMPLETE;\n\t\tCMD_ABTS_STATUS(sc) = cmpl_stat;\n\t\tCMD_FLAGS(sc) |= SNIC_DEV_RST_DONE;\n\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"itmf_cmpl:dev reset abts cmpl recvd. id %d status %s flags 0x%llx\\n\",\n\t\t\t      cmnd_id, snic_io_status_to_str(cmpl_stat),\n\t\t\t      CMD_FLAGS(sc));\n\n\t\tif (rqi->abts_done)\n\t\t\tcomplete(rqi->abts_done);\n\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\tbreak;\n\n\tdefault:\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"itmf_cmpl: Unknown TM tag bit 0x%x\\n\", tm_tags);\n\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"itmf_cmpl:Unexpected itmf io stat %s Tag = 0x%x flags 0x%llx\\n\",\n\t\t\t      snic_ioreq_state_to_str(CMD_STATE(sc)),\n\t\t\t      cmnd_id,\n\t\t\t      CMD_FLAGS(sc));\n\t\tret = -1;\n\t\tSNIC_BUG_ON(1);\n\n\t\tbreak;\n\t}\n\n\treturn ret;\n}  \n\n \nstatic void\nsnic_itmf_cmpl_handler(struct snic *snic, struct snic_fw_req *fwreq)\n{\n\tstruct scsi_cmnd  *sc = NULL;\n\tstruct snic_req_info *rqi = NULL;\n\tstruct snic_itmf_cmpl *itmf_cmpl = NULL;\n\tulong ctx;\n\tu32 cmnd_id;\n\tu32 hid;\n\tu8 typ;\n\tu8 hdr_stat;\n\n\tsnic_io_hdr_dec(&fwreq->hdr, &typ, &hdr_stat, &cmnd_id, &hid, &ctx);\n\tSNIC_SCSI_DBG(snic->shost,\n\t\t      \"Itmf_cmpl: %s: type = %x, hdr_stat = %x, cmnd_id = %x, hid = %x,ctx = %lx\\n\",\n\t\t      __func__, typ, hdr_stat, cmnd_id, hid, ctx);\n\n\titmf_cmpl = &fwreq->u.itmf_cmpl;\n\tSNIC_SCSI_DBG(snic->shost,\n\t\t      \"Itmf_cmpl: nterm %u , flags 0x%x\\n\",\n\t\t      le32_to_cpu(itmf_cmpl->nterminated), itmf_cmpl->flags);\n\n\t \n\tif (cmnd_id & SNIC_TAG_IOCTL_DEV_RST) {\n\t\trqi = (struct snic_req_info *) ctx;\n\t\tsc = rqi->sc;\n\n\t\tgoto ioctl_dev_rst;\n\t}\n\n\tif ((cmnd_id & SNIC_TAG_MASK) >= snic->max_tag_id) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"Itmf_cmpl: Tag 0x%x out of Range,HdrStat %s\\n\",\n\t\t\t      cmnd_id, snic_io_status_to_str(hdr_stat));\n\t\tSNIC_BUG_ON(1);\n\n\t\treturn;\n\t}\n\n\tsc = scsi_host_find_tag(snic->shost, cmnd_id & SNIC_TAG_MASK);\n\tWARN_ON_ONCE(!sc);\n\nioctl_dev_rst:\n\tif (!sc) {\n\t\tatomic64_inc(&snic->s_stats.io.sc_null);\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"Itmf_cmpl: sc is NULL - Hdr Stat %s Tag 0x%x\\n\",\n\t\t\t      snic_io_status_to_str(hdr_stat), cmnd_id);\n\n\t\treturn;\n\t}\n\n\tsnic_process_itmf_cmpl(snic, fwreq, cmnd_id, hdr_stat, sc);\n}  \n\n\n\nstatic void\nsnic_hba_reset_scsi_cleanup(struct snic *snic, struct scsi_cmnd *sc)\n{\n\tstruct snic_stats *st = &snic->s_stats;\n\tlong act_ios = 0, act_fwreqs = 0;\n\n\tSNIC_SCSI_DBG(snic->shost, \"HBA Reset scsi cleanup.\\n\");\n\tsnic_scsi_cleanup(snic, snic_cmd_tag(sc));\n\n\t \n\tact_ios = atomic64_read(&st->io.active);\n\tatomic64_add(act_ios, &st->io.compl);\n\tatomic64_sub(act_ios, &st->io.active);\n\n\tact_fwreqs = atomic64_read(&st->fw.actv_reqs);\n\tatomic64_sub(act_fwreqs, &st->fw.actv_reqs);\n}\n\n \nstatic int\nsnic_hba_reset_cmpl_handler(struct snic *snic, struct snic_fw_req *fwreq)\n{\n\tulong ctx;\n\tu32 cmnd_id;\n\tu32 hid;\n\tu8 typ;\n\tu8 hdr_stat;\n\tstruct scsi_cmnd *sc = NULL;\n\tstruct snic_req_info *rqi = NULL;\n\tspinlock_t *io_lock = NULL;\n\tunsigned long flags, gflags;\n\tint ret = 0;\n\n\tsnic_io_hdr_dec(&fwreq->hdr, &typ, &hdr_stat, &cmnd_id, &hid, &ctx);\n\tSNIC_HOST_INFO(snic->shost,\n\t\t       \"reset_cmpl:Tag %d ctx %lx cmpl status %s HBA Reset Completion received.\\n\",\n\t\t       cmnd_id, ctx, snic_io_status_to_str(hdr_stat));\n\n\tSNIC_SCSI_DBG(snic->shost,\n\t\t      \"reset_cmpl: type = %x, hdr_stat = %x, cmnd_id = %x, hid = %x, ctx = %lx\\n\",\n\t\t      typ, hdr_stat, cmnd_id, hid, ctx);\n\n\t \n\tif (cmnd_id == SCSI_NO_TAG) {\n\t\trqi = (struct snic_req_info *) ctx;\n\t\tSNIC_HOST_INFO(snic->shost,\n\t\t\t       \"reset_cmpl:Tag %d ctx %lx cmpl stat %s\\n\",\n\t\t\t       cmnd_id, ctx, snic_io_status_to_str(hdr_stat));\n\t\tsc = rqi->sc;\n\n\t\tgoto ioctl_hba_rst;\n\t}\n\n\tif (cmnd_id >= snic->max_tag_id) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"reset_cmpl: Tag 0x%x out of Range,HdrStat %s\\n\",\n\t\t\t      cmnd_id, snic_io_status_to_str(hdr_stat));\n\t\tSNIC_BUG_ON(1);\n\n\t\treturn 1;\n\t}\n\n\tsc = scsi_host_find_tag(snic->shost, cmnd_id);\nioctl_hba_rst:\n\tif (!sc) {\n\t\tatomic64_inc(&snic->s_stats.io.sc_null);\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"reset_cmpl: sc is NULL - Hdr Stat %s Tag 0x%x\\n\",\n\t\t\t      snic_io_status_to_str(hdr_stat), cmnd_id);\n\t\tret = 1;\n\n\t\treturn ret;\n\t}\n\n\tSNIC_HOST_INFO(snic->shost,\n\t\t       \"reset_cmpl: sc %p rqi %p Tag %d flags 0x%llx\\n\",\n\t\t       sc, rqi, cmnd_id, CMD_FLAGS(sc));\n\n\tio_lock = snic_io_lock_hash(snic, sc);\n\tspin_lock_irqsave(io_lock, flags);\n\n\tif (!snic->remove_wait) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"reset_cmpl:host reset completed after timeout\\n\");\n\t\tret = 1;\n\n\t\treturn ret;\n\t}\n\n\trqi = (struct snic_req_info *) CMD_SP(sc);\n\tWARN_ON_ONCE(!rqi);\n\n\tif (!rqi) {\n\t\tatomic64_inc(&snic->s_stats.io.req_null);\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tCMD_FLAGS(sc) |= SNIC_IO_ABTS_TERM_REQ_NULL;\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"reset_cmpl: rqi is null,Hdr stat %s Tag 0x%x sc 0x%p flags 0x%llx\\n\",\n\t\t\t      snic_io_status_to_str(hdr_stat), cmnd_id, sc,\n\t\t\t      CMD_FLAGS(sc));\n\n\t\tret = 1;\n\n\t\treturn ret;\n\t}\n\t \n\tspin_unlock_irqrestore(io_lock, flags);\n\n\t \n\tsnic_hba_reset_scsi_cleanup(snic, sc);\n\n\tSNIC_BUG_ON(snic_get_state(snic) != SNIC_OFFLINE &&\n\t\t    snic_get_state(snic) != SNIC_FWRESET);\n\n\t \n\tspin_lock_irqsave(io_lock, flags);\n\tspin_lock_irqsave(&snic->snic_lock, gflags);\n\tif (snic_get_state(snic) == SNIC_FWRESET)\n\t\tsnic_set_state(snic, SNIC_ONLINE);\n\tspin_unlock_irqrestore(&snic->snic_lock, gflags);\n\n\tif (snic->remove_wait)\n\t\tcomplete(snic->remove_wait);\n\n\tspin_unlock_irqrestore(io_lock, flags);\n\tatomic64_inc(&snic->s_stats.reset.hba_reset_cmpl);\n\n\tret = 0;\n\t \n\tif (snic->config.xpt_type == SNIC_DAS)\n\t\t\treturn ret;\n\n\tSNIC_SCSI_DBG(snic->shost, \"reset_cmpl: Queuing discovery work.\\n\");\n\tqueue_work(snic_glob->event_q, &snic->disc_work);\n\n\treturn ret;\n}\n\nstatic void\nsnic_msg_ack_handler(struct snic *snic, struct snic_fw_req *fwreq)\n{\n\tSNIC_HOST_INFO(snic->shost, \"Message Ack Received.\\n\");\n\n\tSNIC_ASSERT_NOT_IMPL(1);\n}\n\nstatic void\nsnic_aen_handler(struct snic *snic, struct snic_fw_req *fwreq)\n{\n\tu8 typ, hdr_stat;\n\tu32 cmnd_id, hid;\n\tulong ctx;\n\tstruct snic_async_evnotify *aen = &fwreq->u.async_ev;\n\tu32 event_id = 0;\n\n\tsnic_io_hdr_dec(&fwreq->hdr, &typ, &hdr_stat, &cmnd_id, &hid, &ctx);\n\tSNIC_SCSI_DBG(snic->shost,\n\t\t      \"aen: type = %x, hdr_stat = %x, cmnd_id = %x, hid = %x, ctx = %lx\\n\",\n\t\t      typ, hdr_stat, cmnd_id, hid, ctx);\n\n\tevent_id = le32_to_cpu(aen->ev_id);\n\n\tswitch (event_id) {\n\tcase SNIC_EV_TGT_OFFLINE:\n\t\tSNIC_HOST_INFO(snic->shost, \"aen:TGT_OFFLINE Event Recvd.\\n\");\n\t\tbreak;\n\n\tcase SNIC_EV_TGT_ONLINE:\n\t\tSNIC_HOST_INFO(snic->shost, \"aen:TGT_ONLINE Event Recvd.\\n\");\n\t\tbreak;\n\n\tcase SNIC_EV_LUN_OFFLINE:\n\t\tSNIC_HOST_INFO(snic->shost, \"aen:LUN_OFFLINE Event Recvd.\\n\");\n\t\tbreak;\n\n\tcase SNIC_EV_LUN_ONLINE:\n\t\tSNIC_HOST_INFO(snic->shost, \"aen:LUN_ONLINE Event Recvd.\\n\");\n\t\tbreak;\n\n\tcase SNIC_EV_CONF_CHG:\n\t\tSNIC_HOST_INFO(snic->shost, \"aen:Config Change Event Recvd.\\n\");\n\t\tbreak;\n\n\tcase SNIC_EV_TGT_ADDED:\n\t\tSNIC_HOST_INFO(snic->shost, \"aen:TGT_ADD Event Recvd.\\n\");\n\t\tbreak;\n\n\tcase SNIC_EV_TGT_DELTD:\n\t\tSNIC_HOST_INFO(snic->shost, \"aen:TGT_DEL Event Recvd.\\n\");\n\t\tbreak;\n\n\tcase SNIC_EV_LUN_ADDED:\n\t\tSNIC_HOST_INFO(snic->shost, \"aen:LUN_ADD Event Recvd.\\n\");\n\t\tbreak;\n\n\tcase SNIC_EV_LUN_DELTD:\n\t\tSNIC_HOST_INFO(snic->shost, \"aen:LUN_DEL Event Recvd.\\n\");\n\t\tbreak;\n\n\tcase SNIC_EV_DISC_CMPL:\n\t\tSNIC_HOST_INFO(snic->shost, \"aen:DISC_CMPL Event Recvd.\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tSNIC_HOST_INFO(snic->shost, \"aen:Unknown Event Recvd.\\n\");\n\t\tSNIC_BUG_ON(1);\n\t\tbreak;\n\t}\n\n\tSNIC_ASSERT_NOT_IMPL(1);\n}  \n\n \nstatic int\nsnic_io_cmpl_handler(struct vnic_dev *vdev,\n\t\t     unsigned int cq_idx,\n\t\t     struct snic_fw_req *fwreq)\n{\n\tstruct snic *snic = svnic_dev_priv(vdev);\n\tu64 start = jiffies, cmpl_time;\n\n\tsnic_print_desc(__func__, (char *)fwreq, sizeof(*fwreq));\n\n\t \n\tif ((fwreq->hdr.type >= SNIC_RSP_REPORT_TGTS_CMPL) &&\n\t\t(fwreq->hdr.type <= SNIC_RSP_BOOT_LUNS_CMPL))\n\t\tatomic64_dec(&snic->s_stats.fw.actv_reqs);\n\n\tSNIC_BUG_ON((fwreq->hdr.type > SNIC_RSP_BOOT_LUNS_CMPL) &&\n\t\t    (fwreq->hdr.type < SNIC_MSG_ASYNC_EVNOTIFY));\n\n\t \n\tswitch (fwreq->hdr.status) {\n\tcase SNIC_STAT_NOT_READY:\t \n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"sNIC SubSystem is NOT Ready.\\n\");\n\t\tbreak;\n\n\tcase SNIC_STAT_FATAL_ERROR:\t \n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"sNIC SubSystem in Unrecoverable State.\\n\");\n\t\tbreak;\n\t}\n\n\tswitch (fwreq->hdr.type) {\n\tcase SNIC_RSP_EXCH_VER_CMPL:\n\t\tsnic_io_exch_ver_cmpl_handler(snic, fwreq);\n\t\tbreak;\n\n\tcase SNIC_RSP_REPORT_TGTS_CMPL:\n\t\tsnic_report_tgt_cmpl_handler(snic, fwreq);\n\t\tbreak;\n\n\tcase SNIC_RSP_ICMND_CMPL:\n\t\tsnic_icmnd_cmpl_handler(snic, fwreq);\n\t\tbreak;\n\n\tcase SNIC_RSP_ITMF_CMPL:\n\t\tsnic_itmf_cmpl_handler(snic, fwreq);\n\t\tbreak;\n\n\tcase SNIC_RSP_HBA_RESET_CMPL:\n\t\tsnic_hba_reset_cmpl_handler(snic, fwreq);\n\t\tbreak;\n\n\tcase SNIC_MSG_ACK:\n\t\tsnic_msg_ack_handler(snic, fwreq);\n\t\tbreak;\n\n\tcase SNIC_MSG_ASYNC_EVNOTIFY:\n\t\tsnic_aen_handler(snic, fwreq);\n\t\tbreak;\n\n\tdefault:\n\t\tSNIC_BUG_ON(1);\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"Unknown Firmware completion request type %d\\n\",\n\t\t\t      fwreq->hdr.type);\n\t\tbreak;\n\t}\n\n\t \n\tcmpl_time = jiffies - start;\n\tif (cmpl_time > atomic64_read(&snic->s_stats.io.max_cmpl_time))\n\t\tatomic64_set(&snic->s_stats.io.max_cmpl_time, cmpl_time);\n\n\treturn 0;\n}  \n\n \nint\nsnic_fwcq_cmpl_handler(struct snic *snic, int io_cmpl_work)\n{\n\tunsigned int num_ent = 0;\t \n\tunsigned int cq_idx;\n\tunsigned int nent_per_cq;\n\tstruct snic_misc_stats *misc_stats = &snic->s_stats.misc;\n\n\tfor (cq_idx = snic->wq_count; cq_idx < snic->cq_count; cq_idx++) {\n\t\tnent_per_cq = vnic_cq_fw_service(&snic->cq[cq_idx],\n\t\t\t\t\t\t snic_io_cmpl_handler,\n\t\t\t\t\t\t io_cmpl_work);\n\t\tnum_ent += nent_per_cq;\n\n\t\tif (nent_per_cq > atomic64_read(&misc_stats->max_cq_ents))\n\t\t\tatomic64_set(&misc_stats->max_cq_ents, nent_per_cq);\n\t}\n\n\treturn num_ent;\n}  \n\n \nstatic int\nsnic_queue_itmf_req(struct snic *snic,\n\t\t    struct snic_host_req *tmreq,\n\t\t    struct scsi_cmnd *sc,\n\t\t    u32 tmf,\n\t\t    u32 req_id)\n{\n\tstruct snic_req_info *rqi = req_to_rqi(tmreq);\n\tstruct scsi_lun lun;\n\tint tm_tag = snic_cmd_tag(sc) | rqi->tm_tag;\n\tint ret = 0;\n\n\tSNIC_BUG_ON(!rqi);\n\tSNIC_BUG_ON(!rqi->tm_tag);\n\n\t \n\tint_to_scsilun(sc->device->lun, &lun);\n\n\t \n\tsnic_itmf_init(tmreq,\n\t\t       tm_tag,\n\t\t       snic->config.hid,\n\t\t       (ulong) rqi,\n\t\t       0  ,\n\t\t       req_id,  \n\t\t       rqi->tgt_id,\n\t\t       lun.scsi_lun,\n\t\t       tmf);\n\n\t \n\n\tret = snic_queue_wq_desc(snic, tmreq, sizeof(*tmreq));\n\tif (ret)\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"qitmf:Queuing ITMF(%d) Req sc %p, rqi %p, req_id %d tag %d Failed, ret = %d\\n\",\n\t\t\t      tmf, sc, rqi, req_id, snic_cmd_tag(sc), ret);\n\telse\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"qitmf:Queuing ITMF(%d) Req sc %p, rqi %p, req_id %d, tag %d (req_id)- Success.\",\n\t\t\t      tmf, sc, rqi, req_id, snic_cmd_tag(sc));\n\n\treturn ret;\n}  \n\nstatic int\nsnic_issue_tm_req(struct snic *snic,\n\t\t    struct snic_req_info *rqi,\n\t\t    struct scsi_cmnd *sc,\n\t\t    int tmf)\n{\n\tstruct snic_host_req *tmreq = NULL;\n\tint req_id = 0, tag = snic_cmd_tag(sc);\n\tint ret = 0;\n\n\tif (snic_get_state(snic) == SNIC_FWRESET)\n\t\treturn -EBUSY;\n\n\tatomic_inc(&snic->ios_inflight);\n\n\tSNIC_SCSI_DBG(snic->shost,\n\t\t      \"issu_tmreq: Task mgmt req %d. rqi %p w/ tag %x\\n\",\n\t\t      tmf, rqi, tag);\n\n\n\tif (tmf == SNIC_ITMF_LUN_RESET) {\n\t\ttmreq = snic_dr_req_init(snic, rqi);\n\t\treq_id = SCSI_NO_TAG;\n\t} else {\n\t\ttmreq = snic_abort_req_init(snic, rqi);\n\t\treq_id = tag;\n\t}\n\n\tif (!tmreq) {\n\t\tret = -ENOMEM;\n\n\t\tgoto tmreq_err;\n\t}\n\n\tret = snic_queue_itmf_req(snic, tmreq, sc, tmf, req_id);\n\ntmreq_err:\n\tif (ret) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"issu_tmreq: Queueing ITMF(%d) Req, sc %p rqi %p req_id %d tag %x fails err = %d\\n\",\n\t\t\t      tmf, sc, rqi, req_id, tag, ret);\n\t} else {\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"issu_tmreq: Queueing ITMF(%d) Req, sc %p, rqi %p, req_id %d tag %x - Success.\\n\",\n\t\t\t      tmf, sc, rqi, req_id, tag);\n\t}\n\n\tatomic_dec(&snic->ios_inflight);\n\n\treturn ret;\n}\n\n \nstatic int\nsnic_queue_abort_req(struct snic *snic,\n\t\t     struct snic_req_info *rqi,\n\t\t     struct scsi_cmnd *sc,\n\t\t     int tmf)\n{\n\tSNIC_SCSI_DBG(snic->shost, \"q_abtreq: sc %p, rqi %p, tag %x, tmf %d\\n\",\n\t\t      sc, rqi, snic_cmd_tag(sc), tmf);\n\n\t \n\trqi->tm_tag |= SNIC_TAG_ABORT;\n\n\treturn snic_issue_tm_req(snic, rqi, sc, tmf);\n}\n\n \nstatic int\nsnic_abort_finish(struct snic *snic, struct scsi_cmnd *sc)\n{\n\tstruct snic_req_info *rqi = NULL;\n\tspinlock_t *io_lock = NULL;\n\tunsigned long flags;\n\tint ret = 0, tag = snic_cmd_tag(sc);\n\n\tio_lock = snic_io_lock_hash(snic, sc);\n\tspin_lock_irqsave(io_lock, flags);\n\trqi = (struct snic_req_info *) CMD_SP(sc);\n\tif (!rqi) {\n\t\tatomic64_inc(&snic->s_stats.io.req_null);\n\t\tCMD_FLAGS(sc) |= SNIC_IO_ABTS_TERM_REQ_NULL;\n\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"abt_fini:req info is null tag 0x%x, sc 0x%p flags 0x%llx\\n\",\n\t\t\t      tag, sc, CMD_FLAGS(sc));\n\t\tret = FAILED;\n\n\t\tgoto abort_fail;\n\t}\n\n\trqi->abts_done = NULL;\n\n\tret = FAILED;\n\n\t \n\tswitch (CMD_ABTS_STATUS(sc)) {\n\tcase SNIC_INVALID_CODE:\n\t\t \n\t\tCMD_FLAGS(sc) |= SNIC_IO_ABTS_TIMEDOUT;\n\t\tatomic64_inc(&snic->s_stats.abts.drv_tmo);\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"abt_fini:sc %p Tag %x Driver Timeout.flags 0x%llx\\n\",\n\t\t\t      sc, snic_cmd_tag(sc), CMD_FLAGS(sc));\n\t\t \n\t\trqi = NULL;\n\n\t\tgoto abort_fail;\n\n\tcase SNIC_STAT_IO_SUCCESS:\n\tcase SNIC_STAT_IO_NOT_FOUND:\n\t\tret = SUCCESS;\n\t\t \n\t\tsc->result = (DID_ERROR << 16);\n\t\tscsi_done(sc);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tret = FAILED;\n\t\trqi = NULL;\n\t\tbreak;\n\t}\n\n\tCMD_SP(sc) = NULL;\n\tSNIC_HOST_INFO(snic->shost,\n\t\t       \"abt_fini: Tag %x, Cmpl Status %s flags 0x%llx\\n\",\n\t\t       tag, snic_io_status_to_str(CMD_ABTS_STATUS(sc)),\n\t\t       CMD_FLAGS(sc));\n\nabort_fail:\n\tspin_unlock_irqrestore(io_lock, flags);\n\tif (rqi)\n\t\tsnic_release_req_buf(snic, rqi, sc);\n\n\treturn ret;\n}  \n\n \nstatic int\nsnic_send_abort_and_wait(struct snic *snic, struct scsi_cmnd *sc)\n{\n\tstruct snic_req_info *rqi = NULL;\n\tenum snic_ioreq_state sv_state;\n\tstruct snic_tgt *tgt = NULL;\n\tspinlock_t *io_lock = NULL;\n\tDECLARE_COMPLETION_ONSTACK(tm_done);\n\tunsigned long flags;\n\tint ret = 0, tmf = 0, tag = snic_cmd_tag(sc);\n\n\ttgt = starget_to_tgt(scsi_target(sc->device));\n\tif ((snic_tgt_chkready(tgt) != 0) && (tgt->tdata.typ == SNIC_TGT_SAN))\n\t\ttmf = SNIC_ITMF_ABTS_TASK_TERM;\n\telse\n\t\ttmf = SNIC_ITMF_ABTS_TASK;\n\n\t \n\n\tio_lock = snic_io_lock_hash(snic, sc);\n\n\t \n\tspin_lock_irqsave(io_lock, flags);\n\trqi = (struct snic_req_info *) CMD_SP(sc);\n\tif (!rqi) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"abt_cmd: rqi is null. Tag %d flags 0x%llx\\n\",\n\t\t\t      tag, CMD_FLAGS(sc));\n\n\t\tret = SUCCESS;\n\n\t\tgoto send_abts_end;\n\t}\n\n\trqi->abts_done = &tm_done;\n\tif (CMD_STATE(sc) == SNIC_IOREQ_ABTS_PENDING) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\tret = 0;\n\t\tgoto abts_pending;\n\t}\n\tSNIC_BUG_ON(!rqi->abts_done);\n\n\t \n\tsv_state = CMD_STATE(sc);\n\n\t \n\tCMD_STATE(sc) = SNIC_IOREQ_ABTS_PENDING;\n\tCMD_ABTS_STATUS(sc) = SNIC_INVALID_CODE;\n\n\tSNIC_SCSI_DBG(snic->shost, \"send_abt_cmd: TAG 0x%x\\n\", tag);\n\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\t \n\tret = snic_queue_abort_req(snic, rqi, sc, tmf);\n\tif (ret) {\n\t\tatomic64_inc(&snic->s_stats.abts.q_fail);\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"send_abt_cmd: IO w/ Tag 0x%x fail w/ err %d flags 0x%llx\\n\",\n\t\t\t      tag, ret, CMD_FLAGS(sc));\n\n\t\tspin_lock_irqsave(io_lock, flags);\n\t\t \n\t\tCMD_STATE(sc) = sv_state;\n\t\trqi = (struct snic_req_info *) CMD_SP(sc);\n\t\tif (rqi)\n\t\t\trqi->abts_done = NULL;\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tret = FAILED;\n\n\t\tgoto send_abts_end;\n\t}\n\n\tspin_lock_irqsave(io_lock, flags);\n\tif (tmf == SNIC_ITMF_ABTS_TASK) {\n\t\tCMD_FLAGS(sc) |= SNIC_IO_ABTS_ISSUED;\n\t\tatomic64_inc(&snic->s_stats.abts.num);\n\t} else {\n\t\t \n\t\tCMD_FLAGS(sc) |= SNIC_IO_TERM_ISSUED;\n\t}\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\tSNIC_SCSI_DBG(snic->shost,\n\t\t      \"send_abt_cmd: sc %p Tag %x flags 0x%llx\\n\",\n\t\t      sc, tag, CMD_FLAGS(sc));\n\n\n\tret = 0;\n\nabts_pending:\n\t \n\twait_for_completion_timeout(&tm_done, SNIC_ABTS_TIMEOUT);\n\nsend_abts_end:\n\treturn ret;\n}  \n\n \nint\nsnic_abort_cmd(struct scsi_cmnd *sc)\n{\n\tstruct snic *snic = shost_priv(sc->device->host);\n\tint ret = SUCCESS, tag = snic_cmd_tag(sc);\n\tu32 start_time = jiffies;\n\n\tSNIC_SCSI_DBG(snic->shost, \"abt_cmd:sc %p :0x%x :req = %p :tag = %d\\n\",\n\t\t       sc, sc->cmnd[0], scsi_cmd_to_rq(sc), tag);\n\n\tif (unlikely(snic_get_state(snic) != SNIC_ONLINE)) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"abt_cmd: tag %x Parent Devs are not rdy\\n\",\n\t\t\t      tag);\n\t\tret = FAST_IO_FAIL;\n\n\t\tgoto abort_end;\n\t}\n\n\n\tret = snic_send_abort_and_wait(snic, sc);\n\tif (ret)\n\t\tgoto abort_end;\n\n\tret = snic_abort_finish(snic, sc);\n\nabort_end:\n\tSNIC_TRC(snic->shost->host_no, tag, (ulong) sc,\n\t\t jiffies_to_msecs(jiffies - start_time), 0,\n\t\t SNIC_TRC_CMD(sc), SNIC_TRC_CMD_STATE_FLAGS(sc));\n\n\tSNIC_SCSI_DBG(snic->shost,\n\t\t      \"abts: Abort Req Status = %s\\n\",\n\t\t      (ret == SUCCESS) ? \"SUCCESS\" :\n\t\t       ((ret == FAST_IO_FAIL) ? \"FAST_IO_FAIL\" : \"FAILED\"));\n\n\treturn ret;\n}\n\n\n\nstatic int\nsnic_is_abts_pending(struct snic *snic, struct scsi_cmnd *lr_sc)\n{\n\tstruct snic_req_info *rqi = NULL;\n\tstruct scsi_cmnd *sc = NULL;\n\tstruct scsi_device *lr_sdev = NULL;\n\tspinlock_t *io_lock = NULL;\n\tu32 tag;\n\tunsigned long flags;\n\n\tif (lr_sc)\n\t\tlr_sdev = lr_sc->device;\n\n\t \n\tfor (tag = 0; tag < snic->max_tag_id; tag++) {\n\t\tio_lock = snic_io_lock_tag(snic, tag);\n\n\t\tspin_lock_irqsave(io_lock, flags);\n\t\tsc = scsi_host_find_tag(snic->shost, tag);\n\n\t\tif (!sc || (lr_sc && (sc->device != lr_sdev || sc == lr_sc))) {\n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\trqi = (struct snic_req_info *) CMD_SP(sc);\n\t\tif (!rqi) {\n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tSNIC_SCSI_DBG(snic->shost, \"Found IO in %s on LUN\\n\",\n\t\t\t      snic_ioreq_state_to_str(CMD_STATE(sc)));\n\n\t\tif (CMD_STATE(sc) == SNIC_IOREQ_ABTS_PENDING) {\n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t}\n\n\treturn 0;\n}  \n\nstatic int\nsnic_dr_clean_single_req(struct snic *snic,\n\t\t\t u32 tag,\n\t\t\t struct scsi_device *lr_sdev)\n{\n\tstruct snic_req_info *rqi = NULL;\n\tstruct snic_tgt *tgt = NULL;\n\tstruct scsi_cmnd *sc = NULL;\n\tspinlock_t *io_lock = NULL;\n\tu32 sv_state = 0, tmf = 0;\n\tDECLARE_COMPLETION_ONSTACK(tm_done);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tio_lock = snic_io_lock_tag(snic, tag);\n\tspin_lock_irqsave(io_lock, flags);\n\tsc = scsi_host_find_tag(snic->shost, tag);\n\n\t \n\tif (!sc || sc->device != lr_sdev)\n\t\tgoto skip_clean;\n\n\trqi = (struct snic_req_info *) CMD_SP(sc);\n\n\tif (!rqi)\n\t\tgoto skip_clean;\n\n\n\tif (CMD_STATE(sc) == SNIC_IOREQ_ABTS_PENDING)\n\t\tgoto skip_clean;\n\n\n\tif ((CMD_FLAGS(sc) & SNIC_DEVICE_RESET) &&\n\t\t\t(!(CMD_FLAGS(sc) & SNIC_DEV_RST_ISSUED))) {\n\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"clean_single_req: devrst is not pending sc 0x%p\\n\",\n\t\t\t      sc);\n\n\t\tgoto skip_clean;\n\t}\n\n\tSNIC_SCSI_DBG(snic->shost,\n\t\t\"clean_single_req: Found IO in %s on lun\\n\",\n\t\tsnic_ioreq_state_to_str(CMD_STATE(sc)));\n\n\t \n\tsv_state = CMD_STATE(sc);\n\n\t \n\n\tCMD_STATE(sc) = SNIC_IOREQ_ABTS_PENDING;\n\tSNIC_BUG_ON(rqi->abts_done);\n\n\tif (CMD_FLAGS(sc) & SNIC_DEVICE_RESET) {\n\t\trqi->tm_tag = SNIC_TAG_DEV_RST;\n\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"clean_single_req:devrst sc 0x%p\\n\", sc);\n\t}\n\n\tCMD_ABTS_STATUS(sc) = SNIC_INVALID_CODE;\n\trqi->abts_done = &tm_done;\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\ttgt = starget_to_tgt(scsi_target(sc->device));\n\tif ((snic_tgt_chkready(tgt) != 0) && (tgt->tdata.typ == SNIC_TGT_SAN))\n\t\ttmf = SNIC_ITMF_ABTS_TASK_TERM;\n\telse\n\t\ttmf = SNIC_ITMF_ABTS_TASK;\n\n\t \n\tret = snic_queue_abort_req(snic, rqi, sc, tmf);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"clean_single_req_err:sc %p, tag %d abt failed. tm_tag %d flags 0x%llx\\n\",\n\t\t\t      sc, tag, rqi->tm_tag, CMD_FLAGS(sc));\n\n\t\tspin_lock_irqsave(io_lock, flags);\n\t\trqi = (struct snic_req_info *) CMD_SP(sc);\n\t\tif (rqi)\n\t\t\trqi->abts_done = NULL;\n\n\t\t \n\t\tif (CMD_STATE(sc) == SNIC_IOREQ_ABTS_PENDING)\n\t\t\tCMD_STATE(sc) = sv_state;\n\n\t\tret = 1;\n\t\tgoto skip_clean;\n\t}\n\n\tspin_lock_irqsave(io_lock, flags);\n\tif (CMD_FLAGS(sc) & SNIC_DEVICE_RESET)\n\t\tCMD_FLAGS(sc) |= SNIC_DEV_RST_TERM_ISSUED;\n\n\tCMD_FLAGS(sc) |= SNIC_IO_INTERNAL_TERM_ISSUED;\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\twait_for_completion_timeout(&tm_done, SNIC_ABTS_TIMEOUT);\n\n\t \n\tspin_lock_irqsave(io_lock, flags);\n\trqi = (struct snic_req_info *) CMD_SP(sc);\n\tif (!rqi) {\n\t\tCMD_FLAGS(sc) |= SNIC_IO_ABTS_TERM_REQ_NULL;\n\t\tgoto skip_clean;\n\t}\n\trqi->abts_done = NULL;\n\n\t \n\tif (CMD_ABTS_STATUS(sc) == SNIC_INVALID_CODE) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"clean_single_req_err:sc %p tag %d abt still pending w/ fw, tm_tag %d flags 0x%llx\\n\",\n\t\t\t      sc, tag, rqi->tm_tag, CMD_FLAGS(sc));\n\n\t\tCMD_FLAGS(sc) |= SNIC_IO_ABTS_TERM_DONE;\n\t\tret = 1;\n\n\t\tgoto skip_clean;\n\t}\n\n\tCMD_STATE(sc) = SNIC_IOREQ_ABTS_COMPLETE;\n\tCMD_SP(sc) = NULL;\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\tsnic_release_req_buf(snic, rqi, sc);\n\n\tsc->result = (DID_ERROR << 16);\n\tscsi_done(sc);\n\n\tret = 0;\n\n\treturn ret;\n\nskip_clean:\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\treturn ret;\n}  \n\nstatic int\nsnic_dr_clean_pending_req(struct snic *snic, struct scsi_cmnd *lr_sc)\n{\n\tstruct scsi_device *lr_sdev = lr_sc->device;\n\tu32 tag = 0;\n\tint ret = FAILED;\n\n\tfor (tag = 0; tag < snic->max_tag_id; tag++) {\n\t\tif (tag == snic_cmd_tag(lr_sc))\n\t\t\tcontinue;\n\n\t\tret = snic_dr_clean_single_req(snic, tag, lr_sdev);\n\t\tif (ret) {\n\t\t\tSNIC_HOST_ERR(snic->shost, \"clean_err:tag = %d\\n\", tag);\n\n\t\t\tgoto clean_err;\n\t\t}\n\t}\n\n\tschedule_timeout(msecs_to_jiffies(100));\n\n\t \n\tif (snic_is_abts_pending(snic, lr_sc)) {\n\t\tret = FAILED;\n\n\t\tgoto clean_err;\n\t}\n\n\tret = 0;\n\tSNIC_SCSI_DBG(snic->shost, \"clean_pending_req: Success.\\n\");\n\n\treturn ret;\n\nclean_err:\n\tret = FAILED;\n\tSNIC_HOST_ERR(snic->shost,\n\t\t      \"Failed to Clean Pending IOs on %s device.\\n\",\n\t\t      dev_name(&lr_sdev->sdev_gendev));\n\n\treturn ret;\n\n}  \n\n \nstatic int\nsnic_dr_finish(struct snic *snic, struct scsi_cmnd *sc)\n{\n\tstruct snic_req_info *rqi = NULL;\n\tspinlock_t *io_lock = NULL;\n\tunsigned long flags;\n\tint lr_res = 0;\n\tint ret = FAILED;\n\n\tio_lock = snic_io_lock_hash(snic, sc);\n\tspin_lock_irqsave(io_lock, flags);\n\trqi = (struct snic_req_info *) CMD_SP(sc);\n\tif (!rqi) {\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"dr_fini: rqi is null tag 0x%x sc 0x%p flags 0x%llx\\n\",\n\t\t\t      snic_cmd_tag(sc), sc, CMD_FLAGS(sc));\n\n\t\tret = FAILED;\n\t\tgoto dr_fini_end;\n\t}\n\n\trqi->dr_done = NULL;\n\n\tlr_res = CMD_LR_STATUS(sc);\n\n\tswitch (lr_res) {\n\tcase SNIC_INVALID_CODE:\n\t\t \n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"dr_fini: Tag %x Dev Reset Timedout. flags 0x%llx\\n\",\n\t\t\t      snic_cmd_tag(sc), CMD_FLAGS(sc));\n\n\t\tCMD_FLAGS(sc) |= SNIC_DEV_RST_TIMEDOUT;\n\t\tret = FAILED;\n\n\t\tgoto dr_failed;\n\n\tcase SNIC_STAT_IO_SUCCESS:\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"dr_fini: Tag %x Dev Reset cmpl\\n\",\n\t\t\t      snic_cmd_tag(sc));\n\t\tret = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"dr_fini:Device Reset completed& failed.Tag = %x lr_status %s flags 0x%llx\\n\",\n\t\t\t      snic_cmd_tag(sc),\n\t\t\t      snic_io_status_to_str(lr_res), CMD_FLAGS(sc));\n\t\tret = FAILED;\n\t\tgoto dr_failed;\n\t}\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\t \n\n\tret = snic_dr_clean_pending_req(snic, sc);\n\tif (ret) {\n\t\tspin_lock_irqsave(io_lock, flags);\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"dr_fini: Device Reset Failed since could not abort all IOs. Tag = %x.\\n\",\n\t\t\t      snic_cmd_tag(sc));\n\t\trqi = (struct snic_req_info *) CMD_SP(sc);\n\n\t\tgoto dr_failed;\n\t} else {\n\t\t \n\t\tspin_lock_irqsave(io_lock, flags);\n\t\trqi = (struct snic_req_info *) CMD_SP(sc);\n\t\tif (rqi)\n\t\t\tret = SUCCESS;  \n\t\telse\n\t\t\tret = FAILED;\n\t}\n\ndr_failed:\n\tlockdep_assert_held(io_lock);\n\tif (rqi)\n\t\tCMD_SP(sc) = NULL;\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\tif (rqi)\n\t\tsnic_release_req_buf(snic, rqi, sc);\n\ndr_fini_end:\n\treturn ret;\n}  \n\nstatic int\nsnic_queue_dr_req(struct snic *snic,\n\t\t  struct snic_req_info *rqi,\n\t\t  struct scsi_cmnd *sc)\n{\n\t \n\trqi->tm_tag |= SNIC_TAG_DEV_RST;\n\n\treturn snic_issue_tm_req(snic, rqi, sc, SNIC_ITMF_LUN_RESET);\n}\n\nstatic int\nsnic_send_dr_and_wait(struct snic *snic, struct scsi_cmnd *sc)\n{\n\tstruct snic_req_info *rqi = NULL;\n\tenum snic_ioreq_state sv_state;\n\tspinlock_t *io_lock = NULL;\n\tunsigned long flags;\n\tDECLARE_COMPLETION_ONSTACK(tm_done);\n\tint ret = FAILED, tag = snic_cmd_tag(sc);\n\n\tio_lock = snic_io_lock_hash(snic, sc);\n\tspin_lock_irqsave(io_lock, flags);\n\tCMD_FLAGS(sc) |= SNIC_DEVICE_RESET;\n\trqi = (struct snic_req_info *) CMD_SP(sc);\n\tif (!rqi) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"send_dr: rqi is null, Tag 0x%x flags 0x%llx\\n\",\n\t\t\t      tag, CMD_FLAGS(sc));\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\tret = FAILED;\n\t\tgoto send_dr_end;\n\t}\n\n\t \n\tsv_state = CMD_STATE(sc);\n\n\tCMD_STATE(sc) = SNIC_IOREQ_LR_PENDING;\n\tCMD_LR_STATUS(sc) = SNIC_INVALID_CODE;\n\n\tSNIC_SCSI_DBG(snic->shost, \"dr: TAG = %x\\n\", tag);\n\n\trqi->dr_done = &tm_done;\n\tSNIC_BUG_ON(!rqi->dr_done);\n\n\tspin_unlock_irqrestore(io_lock, flags);\n\t \n\n\tret = snic_queue_dr_req(snic, rqi, sc);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"send_dr: IO w/ Tag 0x%x Failed err = %d. flags 0x%llx\\n\",\n\t\t\t      tag, ret, CMD_FLAGS(sc));\n\n\t\tspin_lock_irqsave(io_lock, flags);\n\t\t \n\t\tCMD_STATE(sc) = sv_state;\n\t\trqi = (struct snic_req_info *) CMD_SP(sc);\n\t\tif (rqi)\n\t\t\trqi->dr_done = NULL;\n\t\t \n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tret = FAILED;\n\n\t\tgoto send_dr_end;\n\t}\n\n\tspin_lock_irqsave(io_lock, flags);\n\tCMD_FLAGS(sc) |= SNIC_DEV_RST_ISSUED;\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\tret = 0;\n\n\twait_for_completion_timeout(&tm_done, SNIC_LUN_RESET_TIMEOUT);\n\nsend_dr_end:\n\treturn ret;\n}\n\n \nstatic int\nsnic_dev_reset_supported(struct scsi_device *sdev)\n{\n\tstruct snic_tgt *tgt = starget_to_tgt(scsi_target(sdev));\n\n\tif (tgt->tdata.typ == SNIC_TGT_DAS)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void\nsnic_unlink_and_release_req(struct snic *snic, struct scsi_cmnd *sc, int flag)\n{\n\tstruct snic_req_info *rqi = NULL;\n\tspinlock_t *io_lock = NULL;\n\tunsigned long flags;\n\tu32 start_time = jiffies;\n\n\tio_lock = snic_io_lock_hash(snic, sc);\n\tspin_lock_irqsave(io_lock, flags);\n\trqi = (struct snic_req_info *) CMD_SP(sc);\n\tif (rqi) {\n\t\tstart_time = rqi->start_time;\n\t\tCMD_SP(sc) = NULL;\n\t}\n\n\tCMD_FLAGS(sc) |= flag;\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\tif (rqi)\n\t\tsnic_release_req_buf(snic, rqi, sc);\n\n\tSNIC_TRC(snic->shost->host_no, snic_cmd_tag(sc), (ulong) sc,\n\t\t jiffies_to_msecs(jiffies - start_time), (ulong) rqi,\n\t\t SNIC_TRC_CMD(sc), SNIC_TRC_CMD_STATE_FLAGS(sc));\n}\n\n \nint\nsnic_device_reset(struct scsi_cmnd *sc)\n{\n\tstruct Scsi_Host *shost = sc->device->host;\n\tstruct snic *snic = shost_priv(shost);\n\tstruct snic_req_info *rqi = NULL;\n\tint tag = snic_cmd_tag(sc);\n\tint start_time = jiffies;\n\tint ret = FAILED;\n\tint dr_supp = 0;\n\n\tSNIC_SCSI_DBG(shost, \"dev_reset:sc %p :0x%x :req = %p :tag = %d\\n\",\n\t\t      sc, sc->cmnd[0], scsi_cmd_to_rq(sc),\n\t\t      snic_cmd_tag(sc));\n\tdr_supp = snic_dev_reset_supported(sc->device);\n\tif (!dr_supp) {\n\t\t \n\t\tSNIC_HOST_INFO(shost, \"LUN Reset Op not supported.\\n\");\n\t\tsnic_unlink_and_release_req(snic, sc, SNIC_DEV_RST_NOTSUP);\n\n\t\tgoto dev_rst_end;\n\t}\n\n\tif (unlikely(snic_get_state(snic) != SNIC_ONLINE)) {\n\t\tsnic_unlink_and_release_req(snic, sc, 0);\n\t\tSNIC_HOST_ERR(shost, \"Devrst: Parent Devs are not online.\\n\");\n\n\t\tgoto dev_rst_end;\n\t}\n\n\t \n\tif (unlikely(tag <= SNIC_NO_TAG)) {\n\t\tSNIC_HOST_INFO(snic->shost,\n\t\t\t       \"Devrst: LUN Reset Recvd thru IOCTL.\\n\");\n\n\t\trqi = snic_req_init(snic, 0);\n\t\tif (!rqi)\n\t\t\tgoto dev_rst_end;\n\n\t\tmemset(scsi_cmd_priv(sc), 0,\n\t\t\tsizeof(struct snic_internal_io_state));\n\t\tCMD_SP(sc) = (char *)rqi;\n\t\tCMD_FLAGS(sc) = SNIC_NO_FLAGS;\n\n\t\t \n\t\trqi->tm_tag = SNIC_TAG_IOCTL_DEV_RST;\n\t\trqi->sc = sc;\n\t}\n\n\tret = snic_send_dr_and_wait(snic, sc);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"Devrst: IO w/ Tag %x Failed w/ err = %d\\n\",\n\t\t\t      tag, ret);\n\n\t\tsnic_unlink_and_release_req(snic, sc, 0);\n\n\t\tgoto dev_rst_end;\n\t}\n\n\tret = snic_dr_finish(snic, sc);\n\ndev_rst_end:\n\tSNIC_TRC(snic->shost->host_no, tag, (ulong) sc,\n\t\t jiffies_to_msecs(jiffies - start_time),\n\t\t 0, SNIC_TRC_CMD(sc), SNIC_TRC_CMD_STATE_FLAGS(sc));\n\n\tSNIC_SCSI_DBG(snic->shost,\n\t\t      \"Devrst: Returning from Device Reset : %s\\n\",\n\t\t      (ret == SUCCESS) ? \"SUCCESS\" : \"FAILED\");\n\n\treturn ret;\n}  \n\n \n \nstatic int\nsnic_issue_hba_reset(struct snic *snic, struct scsi_cmnd *sc)\n{\n\tstruct snic_req_info *rqi = NULL;\n\tstruct snic_host_req *req = NULL;\n\tspinlock_t *io_lock = NULL;\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\tunsigned long flags;\n\tint ret = -ENOMEM;\n\n\trqi = snic_req_init(snic, 0);\n\tif (!rqi) {\n\t\tret = -ENOMEM;\n\n\t\tgoto hba_rst_end;\n\t}\n\n\tif (snic_cmd_tag(sc) == SCSI_NO_TAG) {\n\t\tmemset(scsi_cmd_priv(sc), 0,\n\t\t\tsizeof(struct snic_internal_io_state));\n\t\tSNIC_HOST_INFO(snic->shost, \"issu_hr:Host reset thru ioctl.\\n\");\n\t\trqi->sc = sc;\n\t}\n\n\treq = rqi_to_req(rqi);\n\n\tio_lock = snic_io_lock_hash(snic, sc);\n\tspin_lock_irqsave(io_lock, flags);\n\tSNIC_BUG_ON(CMD_SP(sc) != NULL);\n\tCMD_STATE(sc) = SNIC_IOREQ_PENDING;\n\tCMD_SP(sc) = (char *) rqi;\n\tCMD_FLAGS(sc) |= SNIC_IO_INITIALIZED;\n\tsnic->remove_wait = &wait;\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\t \n\tsnic_io_hdr_enc(&req->hdr, SNIC_REQ_HBA_RESET, 0, snic_cmd_tag(sc),\n\t\t\tsnic->config.hid, 0, (ulong) rqi);\n\n\treq->u.reset.flags = 0;\n\n\tret = snic_queue_wq_desc(snic, req, sizeof(*req));\n\tif (ret) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"issu_hr:Queuing HBA Reset Failed. w err %d\\n\",\n\t\t\t      ret);\n\n\t\tgoto hba_rst_err;\n\t}\n\n\tspin_lock_irqsave(io_lock, flags);\n\tCMD_FLAGS(sc) |= SNIC_HOST_RESET_ISSUED;\n\tspin_unlock_irqrestore(io_lock, flags);\n\tatomic64_inc(&snic->s_stats.reset.hba_resets);\n\tSNIC_HOST_INFO(snic->shost, \"Queued HBA Reset Successfully.\\n\");\n\n\twait_for_completion_timeout(snic->remove_wait,\n\t\t\t\t    SNIC_HOST_RESET_TIMEOUT);\n\n\tif (snic_get_state(snic) == SNIC_FWRESET) {\n\t\tSNIC_HOST_ERR(snic->shost, \"reset_cmpl: Reset Timedout.\\n\");\n\t\tret = -ETIMEDOUT;\n\n\t\tgoto hba_rst_err;\n\t}\n\n\tspin_lock_irqsave(io_lock, flags);\n\tsnic->remove_wait = NULL;\n\trqi = (struct snic_req_info *) CMD_SP(sc);\n\tCMD_SP(sc) = NULL;\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\tif (rqi)\n\t\tsnic_req_free(snic, rqi);\n\n\tret = 0;\n\n\treturn ret;\n\nhba_rst_err:\n\tspin_lock_irqsave(io_lock, flags);\n\tsnic->remove_wait = NULL;\n\trqi = (struct snic_req_info *) CMD_SP(sc);\n\tCMD_SP(sc) = NULL;\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\tif (rqi)\n\t\tsnic_req_free(snic, rqi);\n\nhba_rst_end:\n\tSNIC_HOST_ERR(snic->shost,\n\t\t      \"reset:HBA Reset Failed w/ err = %d.\\n\",\n\t\t      ret);\n\n\treturn ret;\n}  \n\nint\nsnic_reset(struct Scsi_Host *shost, struct scsi_cmnd *sc)\n{\n\tstruct snic *snic = shost_priv(shost);\n\tenum snic_state sv_state;\n\tunsigned long flags;\n\tint ret = FAILED;\n\n\t \n\tsv_state = snic_get_state(snic);\n\n\tspin_lock_irqsave(&snic->snic_lock, flags);\n\tif (snic_get_state(snic) == SNIC_FWRESET) {\n\t\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\t\tSNIC_HOST_INFO(shost, \"reset:prev reset is in progress\\n\");\n\n\t\tmsleep(SNIC_HOST_RESET_TIMEOUT);\n\t\tret = SUCCESS;\n\n\t\tgoto reset_end;\n\t}\n\n\tsnic_set_state(snic, SNIC_FWRESET);\n\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\n\n\t \n\twhile (atomic_read(&snic->ios_inflight))\n\t\tschedule_timeout(msecs_to_jiffies(1));\n\n\tret = snic_issue_hba_reset(snic, sc);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost,\n\t\t\t      \"reset:Host Reset Failed w/ err %d.\\n\",\n\t\t\t      ret);\n\t\tspin_lock_irqsave(&snic->snic_lock, flags);\n\t\tsnic_set_state(snic, sv_state);\n\t\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\t\tatomic64_inc(&snic->s_stats.reset.hba_reset_fail);\n\t\tret = FAILED;\n\n\t\tgoto reset_end;\n\t}\n\n\tret = SUCCESS;\n\nreset_end:\n\treturn ret;\n}  \n\n \nint\nsnic_host_reset(struct scsi_cmnd *sc)\n{\n\tstruct Scsi_Host *shost = sc->device->host;\n\tu32 start_time  = jiffies;\n\tint ret;\n\n\tSNIC_SCSI_DBG(shost,\n\t\t      \"host reset:sc %p sc_cmd 0x%x req %p tag %d flags 0x%llx\\n\",\n\t\t      sc, sc->cmnd[0], scsi_cmd_to_rq(sc),\n\t\t      snic_cmd_tag(sc), CMD_FLAGS(sc));\n\n\tret = snic_reset(shost, sc);\n\n\tSNIC_TRC(shost->host_no, snic_cmd_tag(sc), (ulong) sc,\n\t\t jiffies_to_msecs(jiffies - start_time),\n\t\t 0, SNIC_TRC_CMD(sc), SNIC_TRC_CMD_STATE_FLAGS(sc));\n\n\treturn ret;\n}  \n\n \nstatic void\nsnic_cmpl_pending_tmreq(struct snic *snic, struct scsi_cmnd *sc)\n{\n\tstruct snic_req_info *rqi = NULL;\n\n\tSNIC_SCSI_DBG(snic->shost,\n\t\t      \"Completing Pending TM Req sc %p, state %s flags 0x%llx\\n\",\n\t\t      sc, snic_io_status_to_str(CMD_STATE(sc)), CMD_FLAGS(sc));\n\n\t \n\tCMD_ABTS_STATUS(sc) = SNIC_STAT_IO_SUCCESS;\n\n\trqi = (struct snic_req_info *) CMD_SP(sc);\n\tif (!rqi)\n\t\treturn;\n\n\tif (rqi->dr_done)\n\t\tcomplete(rqi->dr_done);\n\telse if (rqi->abts_done)\n\t\tcomplete(rqi->abts_done);\n}\n\n \nstatic void\nsnic_scsi_cleanup(struct snic *snic, int ex_tag)\n{\n\tstruct snic_req_info *rqi = NULL;\n\tstruct scsi_cmnd *sc = NULL;\n\tspinlock_t *io_lock = NULL;\n\tunsigned long flags;\n\tint tag;\n\tu64 st_time = 0;\n\n\tSNIC_SCSI_DBG(snic->shost, \"sc_clean: scsi cleanup.\\n\");\n\n\tfor (tag = 0; tag < snic->max_tag_id; tag++) {\n\t\t \n\t\tif (tag == ex_tag)\n\t\t\tcontinue;\n\n\t\tio_lock = snic_io_lock_tag(snic, tag);\n\t\tspin_lock_irqsave(io_lock, flags);\n\t\tsc = scsi_host_find_tag(snic->shost, tag);\n\t\tif (!sc) {\n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlikely(snic_tmreq_pending(sc))) {\n\t\t\t \n\t\t\tsnic_cmpl_pending_tmreq(snic, sc);\n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\trqi = (struct snic_req_info *) CMD_SP(sc);\n\t\tif (!rqi) {\n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"sc_clean: sc %p, rqi %p, tag %d flags 0x%llx\\n\",\n\t\t\t      sc, rqi, tag, CMD_FLAGS(sc));\n\n\t\tCMD_SP(sc) = NULL;\n\t\tCMD_FLAGS(sc) |= SNIC_SCSI_CLEANUP;\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\t\tst_time = rqi->start_time;\n\n\t\tSNIC_HOST_INFO(snic->shost,\n\t\t\t       \"sc_clean: Releasing rqi %p : flags 0x%llx\\n\",\n\t\t\t       rqi, CMD_FLAGS(sc));\n\n\t\tsnic_release_req_buf(snic, rqi, sc);\n\ncleanup:\n\t\tsc->result = DID_TRANSPORT_DISRUPTED << 16;\n\t\tSNIC_HOST_INFO(snic->shost,\n\t\t\t       \"sc_clean: DID_TRANSPORT_DISRUPTED for sc %p, Tag %d flags 0x%llx rqi %p duration %u msecs\\n\",\n\t\t\t       sc, scsi_cmd_to_rq(sc)->tag, CMD_FLAGS(sc), rqi,\n\t\t\t       jiffies_to_msecs(jiffies - st_time));\n\n\t\t \n\t\tsnic_stats_update_io_cmpl(&snic->s_stats);\n\n\t\tSNIC_TRC(snic->shost->host_no, tag, (ulong) sc,\n\t\t\t jiffies_to_msecs(jiffies - st_time), 0,\n\t\t\t SNIC_TRC_CMD(sc),\n\t\t\t SNIC_TRC_CMD_STATE_FLAGS(sc));\n\n\t\tscsi_done(sc);\n\t}\n}  \n\nvoid\nsnic_shutdown_scsi_cleanup(struct snic *snic)\n{\n\tSNIC_HOST_INFO(snic->shost, \"Shutdown time SCSI Cleanup.\\n\");\n\n\tsnic_scsi_cleanup(snic, SCSI_NO_TAG);\n}  \n\n \nstatic int\nsnic_internal_abort_io(struct snic *snic, struct scsi_cmnd *sc, int tmf)\n{\n\tstruct snic_req_info *rqi = NULL;\n\tspinlock_t *io_lock = NULL;\n\tunsigned long flags;\n\tu32 sv_state = 0;\n\tint ret = 0;\n\n\tio_lock = snic_io_lock_hash(snic, sc);\n\tspin_lock_irqsave(io_lock, flags);\n\trqi = (struct snic_req_info *) CMD_SP(sc);\n\tif (!rqi)\n\t\tgoto skip_internal_abts;\n\n\tif (CMD_STATE(sc) == SNIC_IOREQ_ABTS_PENDING)\n\t\tgoto skip_internal_abts;\n\n\tif ((CMD_FLAGS(sc) & SNIC_DEVICE_RESET) &&\n\t\t(!(CMD_FLAGS(sc) & SNIC_DEV_RST_ISSUED))) {\n\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t      \"internal_abts: dev rst not pending sc 0x%p\\n\",\n\t\t\t      sc);\n\n\t\tgoto skip_internal_abts;\n\t}\n\n\n\tif (!(CMD_FLAGS(sc) & SNIC_IO_ISSUED)) {\n\t\tSNIC_SCSI_DBG(snic->shost,\n\t\t\t\"internal_abts: IO not yet issued sc 0x%p tag 0x%x flags 0x%llx state %d\\n\",\n\t\t\tsc, snic_cmd_tag(sc), CMD_FLAGS(sc), CMD_STATE(sc));\n\n\t\tgoto skip_internal_abts;\n\t}\n\n\tsv_state = CMD_STATE(sc);\n\tCMD_STATE(sc) = SNIC_IOREQ_ABTS_PENDING;\n\tCMD_ABTS_STATUS(sc) = SNIC_INVALID_CODE;\n\tCMD_FLAGS(sc) |= SNIC_IO_INTERNAL_TERM_PENDING;\n\n\tif (CMD_FLAGS(sc) & SNIC_DEVICE_RESET) {\n\t\t \n\t\trqi->tm_tag = SNIC_TAG_DEV_RST;\n\t\tSNIC_SCSI_DBG(snic->shost, \"internal_abts:dev rst sc %p\\n\", sc);\n\t}\n\n\tSNIC_SCSI_DBG(snic->shost, \"internal_abts: Issuing abts tag %x\\n\",\n\t\t      snic_cmd_tag(sc));\n\tSNIC_BUG_ON(rqi->abts_done);\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\tret = snic_queue_abort_req(snic, rqi, sc, tmf);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"internal_abts: Tag = %x , Failed w/ err = %d\\n\",\n\t\t\t      snic_cmd_tag(sc), ret);\n\n\t\tspin_lock_irqsave(io_lock, flags);\n\n\t\tif (CMD_STATE(sc) == SNIC_IOREQ_ABTS_PENDING)\n\t\t\tCMD_STATE(sc) = sv_state;\n\n\t\tgoto skip_internal_abts;\n\t}\n\n\tspin_lock_irqsave(io_lock, flags);\n\tif (CMD_FLAGS(sc) & SNIC_DEVICE_RESET)\n\t\tCMD_FLAGS(sc) |= SNIC_DEV_RST_TERM_ISSUED;\n\telse\n\t\tCMD_FLAGS(sc) |= SNIC_IO_INTERNAL_TERM_ISSUED;\n\n\tret = SUCCESS;\n\nskip_internal_abts:\n\tlockdep_assert_held(io_lock);\n\tspin_unlock_irqrestore(io_lock, flags);\n\n\treturn ret;\n}  \n\n \nint\nsnic_tgt_scsi_abort_io(struct snic_tgt *tgt)\n{\n\tstruct snic *snic = NULL;\n\tstruct scsi_cmnd *sc = NULL;\n\tstruct snic_tgt *sc_tgt = NULL;\n\tspinlock_t *io_lock = NULL;\n\tunsigned long flags;\n\tint ret = 0, tag, abt_cnt = 0, tmf = 0;\n\n\tif (!tgt)\n\t\treturn -1;\n\n\tsnic = shost_priv(snic_tgt_to_shost(tgt));\n\tSNIC_SCSI_DBG(snic->shost, \"tgt_abt_io: Cleaning Pending IOs.\\n\");\n\n\tif (tgt->tdata.typ == SNIC_TGT_DAS)\n\t\ttmf = SNIC_ITMF_ABTS_TASK;\n\telse\n\t\ttmf = SNIC_ITMF_ABTS_TASK_TERM;\n\n\tfor (tag = 0; tag < snic->max_tag_id; tag++) {\n\t\tio_lock = snic_io_lock_tag(snic, tag);\n\n\t\tspin_lock_irqsave(io_lock, flags);\n\t\tsc = scsi_host_find_tag(snic->shost, tag);\n\t\tif (!sc) {\n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tsc_tgt = starget_to_tgt(scsi_target(sc->device));\n\t\tif (sc_tgt != tgt) {\n\t\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock_irqrestore(io_lock, flags);\n\n\t\tret = snic_internal_abort_io(snic, sc, tmf);\n\t\tif (ret < 0) {\n\t\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t\t      \"tgt_abt_io: Tag %x, Failed w err = %d\\n\",\n\t\t\t\t      tag, ret);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret == SUCCESS)\n\t\t\tabt_cnt++;\n\t}\n\n\tSNIC_SCSI_DBG(snic->shost, \"tgt_abt_io: abt_cnt = %d\\n\", abt_cnt);\n\n\treturn 0;\n}  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}