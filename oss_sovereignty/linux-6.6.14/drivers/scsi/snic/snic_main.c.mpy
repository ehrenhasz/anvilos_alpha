{
  "module_name": "snic_main.c",
  "hash_id": "7e352dd1b96a11502b32a75575c95a2b7db6ab792ba64b2af5cd4773d56bbf18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/snic/snic_main.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/mempool.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/skbuff.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n\n#include \"snic.h\"\n#include \"snic_fwint.h\"\n\n#define PCI_DEVICE_ID_CISCO_SNIC\t0x0046\n\n \nstatic struct pci_device_id snic_id_table[] = {\n\t{PCI_DEVICE(0x1137, PCI_DEVICE_ID_CISCO_SNIC) },\n\t{ 0, }\t \n};\n\nunsigned int snic_log_level = 0x0;\nmodule_param(snic_log_level, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(snic_log_level, \"bitmask for snic logging levels\");\n\n#ifdef CONFIG_SCSI_SNIC_DEBUG_FS\nunsigned int snic_trace_max_pages = 16;\nmodule_param(snic_trace_max_pages, uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(snic_trace_max_pages,\n\t\t\"Total allocated memory pages for snic trace buffer\");\n\n#endif\nunsigned int snic_max_qdepth = SNIC_DFLT_QUEUE_DEPTH;\nmodule_param(snic_max_qdepth, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(snic_max_qdepth, \"Queue depth to report for each LUN\");\n\n \nstatic int\nsnic_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct snic_tgt *tgt = starget_to_tgt(scsi_target(sdev));\n\n\tif (!tgt || snic_tgt_chkready(tgt))\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\n\n \nstatic int\nsnic_slave_configure(struct scsi_device *sdev)\n{\n\tstruct snic *snic = shost_priv(sdev->host);\n\tu32 qdepth = 0, max_ios = 0;\n\tint tmo = SNIC_DFLT_CMD_TIMEOUT * HZ;\n\n\t \n\tmax_ios = snic_max_qdepth;\n\tqdepth = min_t(u32, max_ios, SNIC_MAX_QUEUE_DEPTH);\n\tscsi_change_queue_depth(sdev, qdepth);\n\n\tif (snic->fwinfo.io_tmo > 1)\n\t\ttmo = snic->fwinfo.io_tmo * HZ;\n\n\t \n\tblk_queue_rq_timeout(sdev->request_queue, tmo);\n\n\treturn 0;\n}\n\nstatic int\nsnic_change_queue_depth(struct scsi_device *sdev, int qdepth)\n{\n\tstruct snic *snic = shost_priv(sdev->host);\n\tint qsz = 0;\n\n\tqsz = min_t(u32, qdepth, SNIC_MAX_QUEUE_DEPTH);\n\tif (qsz < sdev->queue_depth)\n\t\tatomic64_inc(&snic->s_stats.misc.qsz_rampdown);\n\telse if (qsz > sdev->queue_depth)\n\t\tatomic64_inc(&snic->s_stats.misc.qsz_rampup);\n\n\tatomic64_set(&snic->s_stats.misc.last_qsz, sdev->queue_depth);\n\n\tscsi_change_queue_depth(sdev, qsz);\n\n\treturn sdev->queue_depth;\n}\n\nstatic const struct scsi_host_template snic_host_template = {\n\t.module = THIS_MODULE,\n\t.name = SNIC_DRV_NAME,\n\t.queuecommand = snic_queuecommand,\n\t.eh_abort_handler = snic_abort_cmd,\n\t.eh_device_reset_handler = snic_device_reset,\n\t.eh_host_reset_handler = snic_host_reset,\n\t.slave_alloc = snic_slave_alloc,\n\t.slave_configure = snic_slave_configure,\n\t.change_queue_depth = snic_change_queue_depth,\n\t.this_id = -1,\n\t.cmd_per_lun = SNIC_DFLT_QUEUE_DEPTH,\n\t.can_queue = SNIC_MAX_IO_REQ,\n\t.sg_tablesize = SNIC_MAX_SG_DESC_CNT,\n\t.max_sectors = 0x800,\n\t.shost_groups = snic_host_groups,\n\t.track_queue_depth = 1,\n\t.cmd_size = sizeof(struct snic_internal_io_state),\n\t.proc_name = \"snic_scsi\",\n};\n\n \nvoid\nsnic_handle_link_event(struct snic *snic)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&snic->snic_lock, flags);\n\tif (snic->stop_link_events) {\n\t\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\n\tqueue_work(snic_glob->event_q, &snic->link_work);\n}  \n\n \nstatic int\nsnic_notify_set(struct snic *snic)\n{\n\tint ret = 0;\n\tenum vnic_dev_intr_mode intr_mode;\n\n\tintr_mode = svnic_dev_get_intr_mode(snic->vdev);\n\n\tif (intr_mode == VNIC_DEV_INTR_MODE_MSIX) {\n\t\tret = svnic_dev_notify_set(snic->vdev, SNIC_MSIX_ERR_NOTIFY);\n\t} else {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"Interrupt mode should be setup before devcmd notify set %d\\n\",\n\t\t\t      intr_mode);\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}  \n\n \nstatic int\nsnic_dev_wait(struct vnic_dev *vdev,\n\t\tint (*start)(struct vnic_dev *, int),\n\t\tint (*finished)(struct vnic_dev *, int *),\n\t\tint arg)\n{\n\tunsigned long time;\n\tint ret, done;\n\tint retry_cnt = 0;\n\n\tret = start(vdev, arg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttime = jiffies + (HZ * 2);\n\tdo {\n\t\tret = finished(vdev, &done);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (done)\n\t\t\treturn 0;\n\t\tschedule_timeout_uninterruptible(HZ/10);\n\t\t++retry_cnt;\n\t} while (time_after(time, jiffies) || (retry_cnt < 3));\n\n\treturn -ETIMEDOUT;\n}  \n\n \nstatic int\nsnic_cleanup(struct snic *snic)\n{\n\tunsigned int i;\n\tint ret;\n\n\tsvnic_dev_disable(snic->vdev);\n\tfor (i = 0; i < snic->intr_count; i++)\n\t\tsvnic_intr_mask(&snic->intr[i]);\n\n\tfor (i = 0; i < snic->wq_count; i++) {\n\t\tret = svnic_wq_disable(&snic->wq[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tsnic_fwcq_cmpl_handler(snic, -1);\n\n\tsnic_wq_cmpl_handler(snic, -1);\n\n\t \n\tfor (i = 0; i < snic->wq_count; i++)\n\t\tsvnic_wq_clean(&snic->wq[i], snic_free_wq_buf);\n\n\tfor (i = 0; i < snic->cq_count; i++)\n\t\tsvnic_cq_clean(&snic->cq[i]);\n\n\tfor (i = 0; i < snic->intr_count; i++)\n\t\tsvnic_intr_clean(&snic->intr[i]);\n\n\t \n\tsnic_free_all_untagged_reqs(snic);\n\n\t \n\tsnic_shutdown_scsi_cleanup(snic);\n\n\tfor (i = 0; i < SNIC_REQ_MAX_CACHES; i++)\n\t\tmempool_destroy(snic->req_pool[i]);\n\n\treturn 0;\n}  \n\n\nstatic void\nsnic_iounmap(struct snic *snic)\n{\n\tif (snic->bar0.vaddr)\n\t\tiounmap(snic->bar0.vaddr);\n}\n\n \nstatic int\nsnic_vdev_open_done(struct vnic_dev *vdev, int *done)\n{\n\tstruct snic *snic = svnic_dev_priv(vdev);\n\tint ret;\n\tint nretries = 5;\n\n\tdo {\n\t\tret = svnic_dev_open_done(vdev, done);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\n\t\tSNIC_HOST_INFO(snic->shost, \"VNIC_DEV_OPEN Timedout.\\n\");\n\t} while (nretries--);\n\n\treturn ret;\n}  \n\n \nstatic int\nsnic_add_host(struct Scsi_Host *shost, struct pci_dev *pdev)\n{\n\tint ret = 0;\n\n\tret = scsi_add_host(shost, &pdev->dev);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost,\n\t\t\t      \"snic: scsi_add_host failed. %d\\n\",\n\t\t\t      ret);\n\n\t\treturn ret;\n\t}\n\n\tSNIC_BUG_ON(shost->work_q != NULL);\n\tsnprintf(shost->work_q_name, sizeof(shost->work_q_name), \"scsi_wq_%d\",\n\t\t shost->host_no);\n\tshost->work_q = create_singlethread_workqueue(shost->work_q_name);\n\tif (!shost->work_q) {\n\t\tSNIC_HOST_ERR(shost, \"Failed to Create ScsiHost wq.\\n\");\n\n\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}  \n\nstatic void\nsnic_del_host(struct Scsi_Host *shost)\n{\n\tif (!shost->work_q)\n\t\treturn;\n\n\tdestroy_workqueue(shost->work_q);\n\tshost->work_q = NULL;\n\tscsi_remove_host(shost);\n}\n\nint\nsnic_get_state(struct snic *snic)\n{\n\treturn atomic_read(&snic->state);\n}\n\nvoid\nsnic_set_state(struct snic *snic, enum snic_state state)\n{\n\tSNIC_HOST_INFO(snic->shost, \"snic state change from %s to %s\\n\",\n\t\t       snic_state_to_str(snic_get_state(snic)),\n\t\t       snic_state_to_str(state));\n\n\tatomic_set(&snic->state, state);\n}\n\n \nstatic int\nsnic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct Scsi_Host *shost;\n\tstruct snic *snic;\n\tmempool_t *pool;\n\tunsigned long flags;\n\tu32 max_ios = 0;\n\tint ret, i;\n\n\t \n\tSNIC_INFO(\"snic device %4x:%4x:%4x:%4x: \",\n\t\t  pdev->vendor, pdev->device, pdev->subsystem_vendor,\n\t\t  pdev->subsystem_device);\n\n\tSNIC_INFO(\"snic device bus %x: slot %x: fn %x\\n\",\n\t\t  pdev->bus->number, PCI_SLOT(pdev->devfn),\n\t\t  PCI_FUNC(pdev->devfn));\n\n\t \n\tshost = scsi_host_alloc(&snic_host_template, sizeof(struct snic));\n\tif (!shost) {\n\t\tSNIC_ERR(\"Unable to alloc scsi_host\\n\");\n\t\tret = -ENOMEM;\n\n\t\tgoto prob_end;\n\t}\n\tsnic = shost_priv(shost);\n\tsnic->shost = shost;\n\n\tsnprintf(snic->name, sizeof(snic->name) - 1, \"%s%d\", SNIC_DRV_NAME,\n\t\t shost->host_no);\n\n\tSNIC_HOST_INFO(shost,\n\t\t       \"snic%d = %p shost = %p device bus %x: slot %x: fn %x\\n\",\n\t\t       shost->host_no, snic, shost, pdev->bus->number,\n\t\t       PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));\n#ifdef CONFIG_SCSI_SNIC_DEBUG_FS\n\t \n\tsnic_stats_debugfs_init(snic);\n#endif\n\n\t \n\tpci_set_drvdata(pdev, snic);\n\tsnic->pdev = pdev;\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost,\n\t\t\t      \"Cannot enable PCI Resources, aborting : %d\\n\",\n\t\t\t      ret);\n\n\t\tgoto err_free_snic;\n\t}\n\n\tret = pci_request_regions(pdev, SNIC_DRV_NAME);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost,\n\t\t\t      \"Cannot obtain PCI Resources, aborting : %d\\n\",\n\t\t\t      ret);\n\n\t\tgoto err_pci_disable;\n\t}\n\n\tpci_set_master(pdev);\n\n\t \n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(43));\n\tif (ret) {\n\t\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (ret) {\n\t\t\tSNIC_HOST_ERR(shost,\n\t\t\t\t      \"No Usable DMA Configuration, aborting %d\\n\",\n\t\t\t\t      ret);\n\t\t\tgoto err_rel_regions;\n\t\t}\n\t}\n\n\t \n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\n\t\tSNIC_HOST_ERR(shost, \"BAR0 not memory mappable aborting.\\n\");\n\n\t\tret = -ENODEV;\n\t\tgoto err_rel_regions;\n\t}\n\n\tsnic->bar0.vaddr = pci_iomap(pdev, 0, 0);\n\tif (!snic->bar0.vaddr) {\n\t\tSNIC_HOST_ERR(shost,\n\t\t\t      \"Cannot memory map BAR0 res hdr aborting.\\n\");\n\n\t\tret = -ENODEV;\n\t\tgoto err_rel_regions;\n\t}\n\n\tsnic->bar0.bus_addr = pci_resource_start(pdev, 0);\n\tsnic->bar0.len = pci_resource_len(pdev, 0);\n\tSNIC_BUG_ON(snic->bar0.bus_addr == 0);\n\n\t \n\tsnic->vdev = svnic_dev_alloc_discover(NULL, snic, pdev, &snic->bar0, 1);\n\tif (!snic->vdev) {\n\t\tSNIC_HOST_ERR(shost, \"vNIC Resource Discovery Failed.\\n\");\n\n\t\tret = -ENODEV;\n\t\tgoto err_iounmap;\n\t}\n\n\tret = svnic_dev_cmd_init(snic->vdev, 0);\n\tif (ret) {\n\t\tSNIC_HOST_INFO(shost, \"Devcmd2 Init Failed. err = %d\\n\", ret);\n\n\t\tgoto err_vnic_unreg;\n\t}\n\n\tret = snic_dev_wait(snic->vdev, svnic_dev_open, snic_vdev_open_done, 0);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost,\n\t\t\t      \"vNIC dev open failed, aborting. %d\\n\",\n\t\t\t      ret);\n\n\t\tgoto err_vnic_unreg;\n\t}\n\n\tret = svnic_dev_init(snic->vdev, 0);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost,\n\t\t\t      \"vNIC dev init failed. aborting. %d\\n\",\n\t\t\t      ret);\n\n\t\tgoto err_dev_close;\n\t}\n\n\t \n\tret = snic_get_vnic_config(snic);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost,\n\t\t\t      \"Get vNIC configuration failed, aborting. %d\\n\",\n\t\t\t      ret);\n\n\t\tgoto err_dev_close;\n\t}\n\n\t \n\tmax_ios = snic->config.io_throttle_count;\n\tif (max_ios != SNIC_UCSM_DFLT_THROTTLE_CNT_BLD)\n\t\tshost->can_queue = min_t(u32, SNIC_MAX_IO_REQ,\n\t\t\t\t\t max_t(u32, SNIC_MIN_IO_REQ, max_ios));\n\n\tsnic->max_tag_id = shost->can_queue;\n\n\tshost->max_lun = snic->config.luns_per_tgt;\n\tshost->max_id = SNIC_MAX_TARGET;\n\n\tshost->max_cmd_len = MAX_COMMAND_SIZE;  \n\n\tsnic_get_res_counts(snic);\n\n\t \n\tret = snic_set_intr_mode(snic);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost,\n\t\t\t      \"Failed to set intr mode aborting. %d\\n\",\n\t\t\t      ret);\n\n\t\tgoto err_dev_close;\n\t}\n\n\tret = snic_alloc_vnic_res(snic);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost,\n\t\t\t      \"Failed to alloc vNIC resources aborting. %d\\n\",\n\t\t\t      ret);\n\n\t\tgoto err_clear_intr;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&snic->list);\n\n\t \n\tINIT_LIST_HEAD(&snic->spl_cmd_list);\n\tspin_lock_init(&snic->spl_cmd_lock);\n\n\t \n\tspin_lock_init(&snic->snic_lock);\n\n\tfor (i = 0; i < SNIC_WQ_MAX; i++)\n\t\tspin_lock_init(&snic->wq_lock[i]);\n\n\tfor (i = 0; i < SNIC_IO_LOCKS; i++)\n\t\tspin_lock_init(&snic->io_req_lock[i]);\n\n\tpool = mempool_create_slab_pool(2,\n\t\t\t\tsnic_glob->req_cache[SNIC_REQ_CACHE_DFLT_SGL]);\n\tif (!pool) {\n\t\tSNIC_HOST_ERR(shost, \"dflt sgl pool creation failed\\n\");\n\n\t\tret = -ENOMEM;\n\t\tgoto err_free_res;\n\t}\n\n\tsnic->req_pool[SNIC_REQ_CACHE_DFLT_SGL] = pool;\n\n\tpool = mempool_create_slab_pool(2,\n\t\t\t\tsnic_glob->req_cache[SNIC_REQ_CACHE_MAX_SGL]);\n\tif (!pool) {\n\t\tSNIC_HOST_ERR(shost, \"max sgl pool creation failed\\n\");\n\n\t\tret = -ENOMEM;\n\t\tgoto err_free_dflt_sgl_pool;\n\t}\n\n\tsnic->req_pool[SNIC_REQ_CACHE_MAX_SGL] = pool;\n\n\tpool = mempool_create_slab_pool(2,\n\t\t\t\tsnic_glob->req_cache[SNIC_REQ_TM_CACHE]);\n\tif (!pool) {\n\t\tSNIC_HOST_ERR(shost, \"snic tmreq info pool creation failed.\\n\");\n\n\t\tret = -ENOMEM;\n\t\tgoto err_free_max_sgl_pool;\n\t}\n\n\tsnic->req_pool[SNIC_REQ_TM_CACHE] = pool;\n\n\t \n\tatomic_set(&snic->state, SNIC_INIT);\n\n\tatomic_set(&snic->ios_inflight, 0);\n\n\t \n\tret = snic_notify_set(snic);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost,\n\t\t\t      \"Failed to alloc notify buffer aborting. %d\\n\",\n\t\t\t      ret);\n\n\t\tgoto err_free_tmreq_pool;\n\t}\n\n\tspin_lock_irqsave(&snic_glob->snic_list_lock, flags);\n\tlist_add_tail(&snic->list, &snic_glob->snic_list);\n\tspin_unlock_irqrestore(&snic_glob->snic_list_lock, flags);\n\n\tsnic_disc_init(&snic->disc);\n\tINIT_WORK(&snic->tgt_work, snic_handle_tgt_disc);\n\tINIT_WORK(&snic->disc_work, snic_handle_disc);\n\tINIT_WORK(&snic->link_work, snic_handle_link);\n\n\t \n\tfor (i = 0; i < snic->wq_count; i++)\n\t\tsvnic_wq_enable(&snic->wq[i]);\n\n\tret = svnic_dev_enable_wait(snic->vdev);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost,\n\t\t\t      \"vNIC dev enable failed w/ error %d\\n\",\n\t\t\t      ret);\n\n\t\tgoto err_vdev_enable;\n\t}\n\n\tret = snic_request_intr(snic);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost, \"Unable to request irq. %d\\n\", ret);\n\n\t\tgoto err_req_intr;\n\t}\n\n\tfor (i = 0; i < snic->intr_count; i++)\n\t\tsvnic_intr_unmask(&snic->intr[i]);\n\n\t \n\tret = snic_get_conf(snic);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost,\n\t\t\t      \"Failed to get snic io config from FW w err %d\\n\",\n\t\t\t      ret);\n\n\t\tgoto err_get_conf;\n\t}\n\n\t \n\tret = snic_add_host(shost, pdev);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost,\n\t\t\t      \"Adding scsi host Failed ... exiting. %d\\n\",\n\t\t\t      ret);\n\n\t\tgoto err_get_conf;\n\t}\n\n\tsnic_set_state(snic, SNIC_ONLINE);\n\n\tret = snic_disc_start(snic);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(shost, \"snic_probe:Discovery Failed w err = %d\\n\",\n\t\t\t      ret);\n\n\t\tgoto err_get_conf;\n\t}\n\n\tSNIC_HOST_INFO(shost, \"SNIC Device Probe Successful.\\n\");\n\n\treturn 0;\n\nerr_get_conf:\n\tsnic_free_all_untagged_reqs(snic);\n\n\tfor (i = 0; i < snic->intr_count; i++)\n\t\tsvnic_intr_mask(&snic->intr[i]);\n\n\tsnic_free_intr(snic);\n\nerr_req_intr:\n\tsvnic_dev_disable(snic->vdev);\n\nerr_vdev_enable:\n\tsvnic_dev_notify_unset(snic->vdev);\n\n\tfor (i = 0; i < snic->wq_count; i++) {\n\t\tint rc = 0;\n\n\t\trc = svnic_wq_disable(&snic->wq[i]);\n\t\tif (rc) {\n\t\t\tSNIC_HOST_ERR(shost,\n\t\t\t\t      \"WQ Disable Failed w/ err = %d\\n\", rc);\n\n\t\t\t break;\n\t\t}\n\t}\n\tsnic_del_host(snic->shost);\n\nerr_free_tmreq_pool:\n\tmempool_destroy(snic->req_pool[SNIC_REQ_TM_CACHE]);\n\nerr_free_max_sgl_pool:\n\tmempool_destroy(snic->req_pool[SNIC_REQ_CACHE_MAX_SGL]);\n\nerr_free_dflt_sgl_pool:\n\tmempool_destroy(snic->req_pool[SNIC_REQ_CACHE_DFLT_SGL]);\n\nerr_free_res:\n\tsnic_free_vnic_res(snic);\n\nerr_clear_intr:\n\tsnic_clear_intr_mode(snic);\n\nerr_dev_close:\n\tsvnic_dev_close(snic->vdev);\n\nerr_vnic_unreg:\n\tsvnic_dev_unregister(snic->vdev);\n\nerr_iounmap:\n\tsnic_iounmap(snic);\n\nerr_rel_regions:\n\tpci_release_regions(pdev);\n\nerr_pci_disable:\n\tpci_disable_device(pdev);\n\nerr_free_snic:\n#ifdef CONFIG_SCSI_SNIC_DEBUG_FS\n\tsnic_stats_debugfs_remove(snic);\n#endif\n\tscsi_host_put(shost);\n\tpci_set_drvdata(pdev, NULL);\n\nprob_end:\n\tSNIC_INFO(\"sNIC device : bus %d: slot %d: fn %d Registration Failed.\\n\",\n\t\t  pdev->bus->number, PCI_SLOT(pdev->devfn),\n\t\t  PCI_FUNC(pdev->devfn));\n\n\treturn ret;\n}  \n\n\n \nstatic void\nsnic_remove(struct pci_dev *pdev)\n{\n\tstruct snic *snic = pci_get_drvdata(pdev);\n\tunsigned long flags;\n\n\tif (!snic) {\n\t\tSNIC_INFO(\"sNIC dev: bus %d slot %d fn %d snic inst is null.\\n\",\n\t\t\t  pdev->bus->number, PCI_SLOT(pdev->devfn),\n\t\t\t  PCI_FUNC(pdev->devfn));\n\n\t\treturn;\n\t}\n\n\t \n\tsnic_set_state(snic, SNIC_OFFLINE);\n\tspin_lock_irqsave(&snic->snic_lock, flags);\n\tsnic->stop_link_events = 1;\n\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\n\tflush_workqueue(snic_glob->event_q);\n\tsnic_disc_term(snic);\n\n\tspin_lock_irqsave(&snic->snic_lock, flags);\n\tsnic->in_remove = 1;\n\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\n\t \n\tsnic_cleanup(snic);\n\n\tspin_lock_irqsave(&snic_glob->snic_list_lock, flags);\n\tlist_del(&snic->list);\n\tspin_unlock_irqrestore(&snic_glob->snic_list_lock, flags);\n\n\tsnic_tgt_del_all(snic);\n#ifdef CONFIG_SCSI_SNIC_DEBUG_FS\n\tsnic_stats_debugfs_remove(snic);\n#endif\n\tsnic_del_host(snic->shost);\n\n\tsvnic_dev_notify_unset(snic->vdev);\n\tsnic_free_intr(snic);\n\tsnic_free_vnic_res(snic);\n\tsnic_clear_intr_mode(snic);\n\tsvnic_dev_close(snic->vdev);\n\tsvnic_dev_unregister(snic->vdev);\n\tsnic_iounmap(snic);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_drvdata(pdev, NULL);\n\n\t \n\tscsi_host_put(snic->shost);\n}  \n\n\nstruct snic_global *snic_glob;\n\n \nstatic int\nsnic_global_data_init(void)\n{\n\tint ret = 0;\n\tstruct kmem_cache *cachep;\n\tssize_t len = 0;\n\n\tsnic_glob = kzalloc(sizeof(*snic_glob), GFP_KERNEL);\n\n\tif (!snic_glob) {\n\t\tSNIC_ERR(\"Failed to allocate Global Context.\\n\");\n\n\t\tret = -ENOMEM;\n\t\tgoto gdi_end;\n\t}\n\n#ifdef CONFIG_SCSI_SNIC_DEBUG_FS\n\t \n\t \n\tsnic_debugfs_init();\n\n\t \n\t \n\tret = snic_trc_init();\n\tif (ret < 0) {\n\t\tSNIC_ERR(\"Trace buffer init failed, SNIC tracing disabled\\n\");\n\t\tsnic_trc_free();\n\t\t \n\t}\n\n#endif\n\tINIT_LIST_HEAD(&snic_glob->snic_list);\n\tspin_lock_init(&snic_glob->snic_list_lock);\n\n\t \n\tlen = sizeof(struct snic_req_info);\n\tlen += sizeof(struct snic_host_req) + sizeof(struct snic_dflt_sgl);\n\tcachep = kmem_cache_create(\"snic_req_dfltsgl\", len, SNIC_SG_DESC_ALIGN,\n\t\t\t\t   SLAB_HWCACHE_ALIGN, NULL);\n\tif (!cachep) {\n\t\tSNIC_ERR(\"Failed to create snic default sgl slab\\n\");\n\t\tret = -ENOMEM;\n\n\t\tgoto err_dflt_req_slab;\n\t}\n\tsnic_glob->req_cache[SNIC_REQ_CACHE_DFLT_SGL] = cachep;\n\n\t \n\tlen = sizeof(struct snic_req_info);\n\tlen += sizeof(struct snic_host_req) + sizeof(struct snic_max_sgl);\n\tcachep = kmem_cache_create(\"snic_req_maxsgl\", len, SNIC_SG_DESC_ALIGN,\n\t\t\t\t   SLAB_HWCACHE_ALIGN, NULL);\n\tif (!cachep) {\n\t\tSNIC_ERR(\"Failed to create snic max sgl slab\\n\");\n\t\tret = -ENOMEM;\n\n\t\tgoto err_max_req_slab;\n\t}\n\tsnic_glob->req_cache[SNIC_REQ_CACHE_MAX_SGL] = cachep;\n\n\tlen = sizeof(struct snic_host_req);\n\tcachep = kmem_cache_create(\"snic_req_maxsgl\", len, SNIC_SG_DESC_ALIGN,\n\t\t\t\t   SLAB_HWCACHE_ALIGN, NULL);\n\tif (!cachep) {\n\t\tSNIC_ERR(\"Failed to create snic tm req slab\\n\");\n\t\tret = -ENOMEM;\n\n\t\tgoto err_tmreq_slab;\n\t}\n\tsnic_glob->req_cache[SNIC_REQ_TM_CACHE] = cachep;\n\n\t \n\tsnic_glob->event_q = create_singlethread_workqueue(\"snic_event_wq\");\n\tif (!snic_glob->event_q) {\n\t\tSNIC_ERR(\"snic event queue create failed\\n\");\n\t\tret = -ENOMEM;\n\n\t\tgoto err_eventq;\n\t}\n\n\treturn ret;\n\nerr_eventq:\n\tkmem_cache_destroy(snic_glob->req_cache[SNIC_REQ_TM_CACHE]);\n\nerr_tmreq_slab:\n\tkmem_cache_destroy(snic_glob->req_cache[SNIC_REQ_CACHE_MAX_SGL]);\n\nerr_max_req_slab:\n\tkmem_cache_destroy(snic_glob->req_cache[SNIC_REQ_CACHE_DFLT_SGL]);\n\nerr_dflt_req_slab:\n#ifdef CONFIG_SCSI_SNIC_DEBUG_FS\n\tsnic_trc_free();\n\tsnic_debugfs_term();\n#endif\n\tkfree(snic_glob);\n\tsnic_glob = NULL;\n\ngdi_end:\n\treturn ret;\n}  \n\n \nstatic void\nsnic_global_data_cleanup(void)\n{\n\tSNIC_BUG_ON(snic_glob == NULL);\n\n\tdestroy_workqueue(snic_glob->event_q);\n\tkmem_cache_destroy(snic_glob->req_cache[SNIC_REQ_TM_CACHE]);\n\tkmem_cache_destroy(snic_glob->req_cache[SNIC_REQ_CACHE_MAX_SGL]);\n\tkmem_cache_destroy(snic_glob->req_cache[SNIC_REQ_CACHE_DFLT_SGL]);\n\n#ifdef CONFIG_SCSI_SNIC_DEBUG_FS\n\t \n\tsnic_trc_free();\n\n\t \n\tsnic_debugfs_term();\n#endif\n\tkfree(snic_glob);\n\tsnic_glob = NULL;\n}  \n\nstatic struct pci_driver snic_driver = {\n\t.name = SNIC_DRV_NAME,\n\t.id_table = snic_id_table,\n\t.probe = snic_probe,\n\t.remove = snic_remove,\n};\n\nstatic int __init\nsnic_init_module(void)\n{\n\tint ret = 0;\n\n#ifndef __x86_64__\n\tSNIC_INFO(\"SNIC Driver is supported only for x86_64 platforms!\\n\");\n\tadd_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);\n#endif\n\n\tSNIC_INFO(\"%s, ver %s\\n\", SNIC_DRV_DESCRIPTION, SNIC_DRV_VERSION);\n\n\tret = snic_global_data_init();\n\tif (ret) {\n\t\tSNIC_ERR(\"Failed to Initialize Global Data.\\n\");\n\n\t\treturn ret;\n\t}\n\n\tret = pci_register_driver(&snic_driver);\n\tif (ret < 0) {\n\t\tSNIC_ERR(\"PCI driver register error\\n\");\n\n\t\tgoto err_pci_reg;\n\t}\n\n\treturn ret;\n\nerr_pci_reg:\n\tsnic_global_data_cleanup();\n\n\treturn ret;\n}\n\nstatic void __exit\nsnic_cleanup_module(void)\n{\n\tpci_unregister_driver(&snic_driver);\n\tsnic_global_data_cleanup();\n}\n\nmodule_init(snic_init_module);\nmodule_exit(snic_cleanup_module);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(SNIC_DRV_DESCRIPTION);\nMODULE_VERSION(SNIC_DRV_VERSION);\nMODULE_DEVICE_TABLE(pci, snic_id_table);\nMODULE_AUTHOR(\"Narsimhulu Musini <nmusini@cisco.com>, \"\n\t      \"Sesidhar Baddela <sebaddel@cisco.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}