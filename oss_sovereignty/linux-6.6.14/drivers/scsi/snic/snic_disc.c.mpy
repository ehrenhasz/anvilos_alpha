{
  "module_name": "snic_disc.c",
  "hash_id": "ca802a70e368fea4333ff1a8a1d01921699411299a64e7bdd10287db6d37fe11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/snic/snic_disc.c",
  "human_readable_source": "\n\n\n#include <linux/errno.h>\n#include <linux/mempool.h>\n\n#include <scsi/scsi_tcq.h>\n\n#include \"snic_disc.h\"\n#include \"snic.h\"\n#include \"snic_io.h\"\n\n\n \nstatic const char * const snic_tgt_type_str[] = {\n\t[SNIC_TGT_DAS] = \"DAS\",\n\t[SNIC_TGT_SAN] = \"SAN\",\n};\n\nstatic inline const char *\nsnic_tgt_type_to_str(int typ)\n{\n\treturn ((typ > SNIC_TGT_NONE && typ <= SNIC_TGT_SAN) ?\n\t\t snic_tgt_type_str[typ] : \"Unknown\");\n}\n\nstatic const char * const snic_tgt_state_str[] = {\n\t[SNIC_TGT_STAT_INIT]\t= \"INIT\",\n\t[SNIC_TGT_STAT_ONLINE]\t= \"ONLINE\",\n\t[SNIC_TGT_STAT_OFFLINE]\t= \"OFFLINE\",\n\t[SNIC_TGT_STAT_DEL]\t= \"DELETION IN PROGRESS\",\n};\n\nconst char *\nsnic_tgt_state_to_str(int state)\n{\n\treturn ((state >= SNIC_TGT_STAT_INIT && state <= SNIC_TGT_STAT_DEL) ?\n\t\tsnic_tgt_state_str[state] : \"UNKNOWN\");\n}\n\n \nstatic void\nsnic_report_tgt_init(struct snic_host_req *req, u32 hid, u8 *buf, u32 len,\n\t\t     dma_addr_t rsp_buf_pa, ulong ctx)\n{\n\tstruct snic_sg_desc *sgd = NULL;\n\n\n\tsnic_io_hdr_enc(&req->hdr, SNIC_REQ_REPORT_TGTS, 0, SCSI_NO_TAG, hid,\n\t\t\t1, ctx);\n\n\treq->u.rpt_tgts.sg_cnt = cpu_to_le16(1);\n\tsgd = req_to_sgl(req);\n\tsgd[0].addr = cpu_to_le64(rsp_buf_pa);\n\tsgd[0].len = cpu_to_le32(len);\n\tsgd[0]._resvd = 0;\n\treq->u.rpt_tgts.sg_addr = cpu_to_le64((ulong)sgd);\n}\n\n \nstatic int\nsnic_queue_report_tgt_req(struct snic *snic)\n{\n\tstruct snic_req_info *rqi = NULL;\n\tu32 ntgts, buf_len = 0;\n\tu8 *buf = NULL;\n\tdma_addr_t pa = 0;\n\tint ret = 0;\n\n\trqi = snic_req_init(snic, 1);\n\tif (!rqi) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tif (snic->fwinfo.max_tgts)\n\t\tntgts = min_t(u32, snic->fwinfo.max_tgts, snic->shost->max_id);\n\telse\n\t\tntgts = snic->shost->max_id;\n\n\t \n\tSNIC_BUG_ON(ntgts == 0);\n\tbuf_len = ntgts * sizeof(struct snic_tgt_id) + SNIC_SG_DESC_ALIGN;\n\n\tbuf = kzalloc(buf_len, GFP_KERNEL);\n\tif (!buf) {\n\t\tsnic_req_free(snic, rqi);\n\t\tSNIC_HOST_ERR(snic->shost, \"Resp Buf Alloc Failed.\\n\");\n\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tSNIC_BUG_ON((((unsigned long)buf) % SNIC_SG_DESC_ALIGN) != 0);\n\n\tpa = dma_map_single(&snic->pdev->dev, buf, buf_len, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&snic->pdev->dev, pa)) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"Rpt-tgt rspbuf %p: PCI DMA Mapping Failed\\n\",\n\t\t\t      buf);\n\t\tkfree(buf);\n\t\tsnic_req_free(snic, rqi);\n\t\tret = -EINVAL;\n\n\t\tgoto error;\n\t}\n\n\n\tSNIC_BUG_ON(pa == 0);\n\trqi->sge_va = (ulong) buf;\n\n\tsnic_report_tgt_init(rqi->req,\n\t\t\t     snic->config.hid,\n\t\t\t     buf,\n\t\t\t     buf_len,\n\t\t\t     pa,\n\t\t\t     (ulong)rqi);\n\n\tsnic_handle_untagged_req(snic, rqi);\n\n\tret = snic_queue_wq_desc(snic, rqi->req, rqi->req_len);\n\tif (ret) {\n\t\tdma_unmap_single(&snic->pdev->dev, pa, buf_len,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tkfree(buf);\n\t\trqi->sge_va = 0;\n\t\tsnic_release_untagged_req(snic, rqi);\n\t\tSNIC_HOST_ERR(snic->shost, \"Queuing Report Tgts Failed.\\n\");\n\n\t\tgoto error;\n\t}\n\n\tSNIC_DISC_DBG(snic->shost, \"Report Targets Issued.\\n\");\n\n\treturn ret;\n\nerror:\n\tSNIC_HOST_ERR(snic->shost,\n\t\t      \"Queuing Report Targets Failed, err = %d\\n\",\n\t\t      ret);\n\treturn ret;\n}  \n\n \nstatic void\nsnic_scsi_scan_tgt(struct work_struct *work)\n{\n\tstruct snic_tgt *tgt = container_of(work, struct snic_tgt, scan_work);\n\tstruct Scsi_Host *shost = dev_to_shost(&tgt->dev);\n\tunsigned long flags;\n\n\tSNIC_HOST_INFO(shost, \"Scanning Target id 0x%x\\n\", tgt->id);\n\tscsi_scan_target(&tgt->dev,\n\t\t\t tgt->channel,\n\t\t\t tgt->scsi_tgt_id,\n\t\t\t SCAN_WILD_CARD,\n\t\t\t SCSI_SCAN_RESCAN);\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\ttgt->flags &= ~SNIC_TGT_SCAN_PENDING;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n}  \n\n \nstatic struct snic_tgt *\nsnic_tgt_lookup(struct snic *snic, struct snic_tgt_id *tgtid)\n{\n\tstruct list_head *cur, *nxt;\n\tstruct snic_tgt *tgt = NULL;\n\n\tlist_for_each_safe(cur, nxt, &snic->disc.tgt_list) {\n\t\ttgt = list_entry(cur, struct snic_tgt, list);\n\t\tif (tgt->id == le32_to_cpu(tgtid->tgt_id))\n\t\t\treturn tgt;\n\t\ttgt = NULL;\n\t}\n\n\treturn tgt;\n}  \n\n \nvoid\nsnic_tgt_dev_release(struct device *dev)\n{\n\tstruct snic_tgt *tgt = dev_to_tgt(dev);\n\n\tSNIC_HOST_INFO(snic_tgt_to_shost(tgt),\n\t\t       \"Target Device ID %d (%s) Permanently Deleted.\\n\",\n\t\t       tgt->id,\n\t\t       dev_name(dev));\n\n\tSNIC_BUG_ON(!list_empty(&tgt->list));\n\tkfree(tgt);\n}\n\n \nstatic void\nsnic_tgt_del(struct work_struct *work)\n{\n\tstruct snic_tgt *tgt = container_of(work, struct snic_tgt, del_work);\n\tstruct Scsi_Host *shost = snic_tgt_to_shost(tgt);\n\n\tif (tgt->flags & SNIC_TGT_SCAN_PENDING)\n\t\tscsi_flush_work(shost);\n\n\t \n\tscsi_block_targets(shost, &tgt->dev);\n\n\t \n\tsnic_tgt_scsi_abort_io(tgt);\n\n\t \n\tscsi_target_unblock(&tgt->dev, SDEV_TRANSPORT_OFFLINE);\n\n\t \n\tscsi_remove_target(&tgt->dev);   \n\tdevice_del(&tgt->dev);\n\tput_device(&tgt->dev);\n}  \n\n \nstatic struct snic_tgt *\nsnic_tgt_create(struct snic *snic, struct snic_tgt_id *tgtid)\n{\n\tstruct snic_tgt *tgt = NULL;\n\tunsigned long flags;\n\tint ret;\n\n\ttgt = snic_tgt_lookup(snic, tgtid);\n\tif (tgt) {\n\t\t \n\t\treturn tgt;\n\t}\n\n\ttgt = kzalloc(sizeof(*tgt), GFP_KERNEL);\n\tif (!tgt) {\n\t\tSNIC_HOST_ERR(snic->shost, \"Failure to allocate snic_tgt.\\n\");\n\t\tret = -ENOMEM;\n\n\t\treturn tgt;\n\t}\n\n\tINIT_LIST_HEAD(&tgt->list);\n\ttgt->id = le32_to_cpu(tgtid->tgt_id);\n\ttgt->channel = 0;\n\n\tSNIC_BUG_ON(le16_to_cpu(tgtid->tgt_type) > SNIC_TGT_SAN);\n\ttgt->tdata.typ = le16_to_cpu(tgtid->tgt_type);\n\n\t \n\ttgt->tdata.disc_id = 0;\n\ttgt->state = SNIC_TGT_STAT_INIT;\n\tdevice_initialize(&tgt->dev);\n\ttgt->dev.parent = get_device(&snic->shost->shost_gendev);\n\ttgt->dev.release = snic_tgt_dev_release;\n\tINIT_WORK(&tgt->scan_work, snic_scsi_scan_tgt);\n\tINIT_WORK(&tgt->del_work, snic_tgt_del);\n\tswitch (tgt->tdata.typ) {\n\tcase SNIC_TGT_DAS:\n\t\tdev_set_name(&tgt->dev, \"snic_das_tgt:%d:%d-%d\",\n\t\t\t     snic->shost->host_no, tgt->channel, tgt->id);\n\t\tbreak;\n\n\tcase SNIC_TGT_SAN:\n\t\tdev_set_name(&tgt->dev, \"snic_san_tgt:%d:%d-%d\",\n\t\t\t     snic->shost->host_no, tgt->channel, tgt->id);\n\t\tbreak;\n\n\tdefault:\n\t\tSNIC_HOST_INFO(snic->shost, \"Target type Unknown Detected.\\n\");\n\t\tdev_set_name(&tgt->dev, \"snic_das_tgt:%d:%d-%d\",\n\t\t\t     snic->shost->host_no, tgt->channel, tgt->id);\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(snic->shost->host_lock, flags);\n\tlist_add_tail(&tgt->list, &snic->disc.tgt_list);\n\ttgt->scsi_tgt_id = snic->disc.nxt_tgt_id++;\n\ttgt->state = SNIC_TGT_STAT_ONLINE;\n\tspin_unlock_irqrestore(snic->shost->host_lock, flags);\n\n\tSNIC_HOST_INFO(snic->shost,\n\t\t       \"Tgt %d, type = %s detected. Adding..\\n\",\n\t\t       tgt->id, snic_tgt_type_to_str(tgt->tdata.typ));\n\n\tret = device_add(&tgt->dev);\n\tif (ret) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"Snic Tgt: device_add, with err = %d\\n\",\n\t\t\t      ret);\n\n\t\tput_device(&snic->shost->shost_gendev);\n\t\tspin_lock_irqsave(snic->shost->host_lock, flags);\n\t\tlist_del(&tgt->list);\n\t\tspin_unlock_irqrestore(snic->shost->host_lock, flags);\n\t\tput_device(&tgt->dev);\n\t\ttgt = NULL;\n\n\t\treturn tgt;\n\t}\n\n\tSNIC_HOST_INFO(snic->shost, \"Scanning %s.\\n\", dev_name(&tgt->dev));\n\n\tscsi_queue_work(snic->shost, &tgt->scan_work);\n\n\treturn tgt;\n}  \n\n \nvoid\nsnic_handle_tgt_disc(struct work_struct *work)\n{\n\tstruct snic *snic = container_of(work, struct snic, tgt_work);\n\tstruct snic_tgt_id *tgtid = NULL;\n\tstruct snic_tgt *tgt = NULL;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&snic->snic_lock, flags);\n\tif (snic->in_remove) {\n\t\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\t\tkfree(snic->disc.rtgt_info);\n\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\n\tmutex_lock(&snic->disc.mutex);\n\t \n\tif (snic->disc.req_cnt) {\n\t\tsnic->disc.state = SNIC_DISC_DONE;\n\t\tsnic->disc.req_cnt = 0;\n\t\tmutex_unlock(&snic->disc.mutex);\n\t\tkfree(snic->disc.rtgt_info);\n\t\tsnic->disc.rtgt_info = NULL;\n\n\t\tSNIC_HOST_INFO(snic->shost, \"tgt_disc: Discovery restart.\\n\");\n\t\t \n\t\tsnic_disc_start(snic);\n\n\t\treturn;\n\t}\n\n\ttgtid = (struct snic_tgt_id *)snic->disc.rtgt_info;\n\n\tSNIC_BUG_ON(snic->disc.rtgt_cnt == 0 || tgtid == NULL);\n\n\tfor (i = 0; i < snic->disc.rtgt_cnt; i++) {\n\t\ttgt = snic_tgt_create(snic, &tgtid[i]);\n\t\tif (!tgt) {\n\t\t\tint buf_sz = snic->disc.rtgt_cnt * sizeof(*tgtid);\n\n\t\t\tSNIC_HOST_ERR(snic->shost, \"Failed to create tgt.\\n\");\n\t\t\tsnic_hex_dump(\"rpt_tgt_rsp\", (char *)tgtid, buf_sz);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsnic->disc.rtgt_info = NULL;\n\tsnic->disc.state = SNIC_DISC_DONE;\n\tmutex_unlock(&snic->disc.mutex);\n\n\tSNIC_HOST_INFO(snic->shost, \"Discovery Completed.\\n\");\n\n\tkfree(tgtid);\n}  \n\n\nint\nsnic_report_tgt_cmpl_handler(struct snic *snic, struct snic_fw_req *fwreq)\n{\n\n\tu8 typ, cmpl_stat;\n\tu32 cmnd_id, hid, tgt_cnt = 0;\n\tulong ctx;\n\tstruct snic_req_info *rqi = NULL;\n\tstruct snic_tgt_id *tgtid;\n\tint i, ret = 0;\n\n\tsnic_io_hdr_dec(&fwreq->hdr, &typ, &cmpl_stat, &cmnd_id, &hid, &ctx);\n\trqi = (struct snic_req_info *) ctx;\n\ttgtid = (struct snic_tgt_id *) rqi->sge_va;\n\n\ttgt_cnt = le32_to_cpu(fwreq->u.rpt_tgts_cmpl.tgt_cnt);\n\tif (tgt_cnt == 0) {\n\t\tSNIC_HOST_ERR(snic->shost, \"No Targets Found on this host.\\n\");\n\t\tret = 1;\n\n\t\tgoto end;\n\t}\n\n\t \n\tSNIC_HOST_INFO(snic->shost, \"Target Count = %d\\n\", tgt_cnt);\n\n\tSNIC_BUG_ON(tgt_cnt > snic->fwinfo.max_tgts);\n\n\tfor (i = 0; i < tgt_cnt; i++)\n\t\tSNIC_HOST_INFO(snic->shost,\n\t\t\t       \"Tgt id = 0x%x\\n\",\n\t\t\t       le32_to_cpu(tgtid[i].tgt_id));\n\n\t \n\tsnic->disc.rtgt_cnt = tgt_cnt;\n\tsnic->disc.rtgt_info = (u8 *) tgtid;\n\tqueue_work(snic_glob->event_q, &snic->tgt_work);\n\tret = 0;\n\nend:\n\t \n\tsnic_pci_unmap_rsp_buf(snic, rqi);\n\tif (ret)\n\t\tkfree(tgtid);\n\n\trqi->sge_va = 0;\n\tsnic_release_untagged_req(snic, rqi);\n\n\treturn ret;\n}  \n\n \nvoid\nsnic_disc_init(struct snic_disc *disc)\n{\n\tINIT_LIST_HEAD(&disc->tgt_list);\n\tmutex_init(&disc->mutex);\n\tdisc->disc_id = 0;\n\tdisc->nxt_tgt_id = 0;\n\tdisc->state = SNIC_DISC_INIT;\n\tdisc->req_cnt = 0;\n\tdisc->rtgt_cnt = 0;\n\tdisc->rtgt_info = NULL;\n\tdisc->cb = NULL;\n}  \n\n \nvoid\nsnic_disc_term(struct snic *snic)\n{\n\tstruct snic_disc *disc = &snic->disc;\n\n\tmutex_lock(&disc->mutex);\n\tif (disc->req_cnt) {\n\t\tdisc->req_cnt = 0;\n\t\tSNIC_SCSI_DBG(snic->shost, \"Terminating Discovery.\\n\");\n\t}\n\tmutex_unlock(&disc->mutex);\n}\n\n \nint\nsnic_disc_start(struct snic *snic)\n{\n\tstruct snic_disc *disc = &snic->disc;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tSNIC_SCSI_DBG(snic->shost, \"Discovery Start.\\n\");\n\n\tspin_lock_irqsave(&snic->snic_lock, flags);\n\tif (snic->in_remove) {\n\t\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\t\tSNIC_ERR(\"snic driver removal in progress ...\\n\");\n\t\tret = 0;\n\n\t\treturn ret;\n\t}\n\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\n\tmutex_lock(&disc->mutex);\n\tif (disc->state == SNIC_DISC_PENDING) {\n\t\tdisc->req_cnt++;\n\t\tmutex_unlock(&disc->mutex);\n\n\t\treturn ret;\n\t}\n\tdisc->state = SNIC_DISC_PENDING;\n\tmutex_unlock(&disc->mutex);\n\n\tret = snic_queue_report_tgt_req(snic);\n\tif (ret)\n\t\tSNIC_HOST_INFO(snic->shost, \"Discovery Failed, err=%d.\\n\", ret);\n\n\treturn ret;\n}  \n\n \nvoid\nsnic_handle_disc(struct work_struct *work)\n{\n\tstruct snic *snic = container_of(work, struct snic, disc_work);\n\tint ret = 0;\n\n\tSNIC_HOST_INFO(snic->shost, \"disc_work: Discovery\\n\");\n\n\tret = snic_disc_start(snic);\n\tif (ret)\n\t\tgoto disc_err;\n\ndisc_err:\n\tSNIC_HOST_ERR(snic->shost,\n\t\t      \"disc_work: Discovery Failed w/ err = %d\\n\",\n\t\t      ret);\n}  \n\n \nvoid\nsnic_tgt_del_all(struct snic *snic)\n{\n\tstruct snic_tgt *tgt = NULL;\n\tstruct list_head *cur, *nxt;\n\tunsigned long flags;\n\n\tscsi_flush_work(snic->shost);\n\n\tmutex_lock(&snic->disc.mutex);\n\tspin_lock_irqsave(snic->shost->host_lock, flags);\n\n\tlist_for_each_safe(cur, nxt, &snic->disc.tgt_list) {\n\t\ttgt = list_entry(cur, struct snic_tgt, list);\n\t\ttgt->state = SNIC_TGT_STAT_DEL;\n\t\tlist_del_init(&tgt->list);\n\t\tSNIC_HOST_INFO(snic->shost, \"Tgt %d q'ing for del\\n\", tgt->id);\n\t\tqueue_work(snic_glob->event_q, &tgt->del_work);\n\t\ttgt = NULL;\n\t}\n\tspin_unlock_irqrestore(snic->shost->host_lock, flags);\n\tmutex_unlock(&snic->disc.mutex);\n\n\tflush_workqueue(snic_glob->event_q);\n}  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}