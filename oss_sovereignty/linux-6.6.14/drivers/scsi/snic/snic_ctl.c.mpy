{
  "module_name": "snic_ctl.c",
  "hash_id": "972fc08bea15dd4fbfd5dacd3445dcc4e921db74ba9e266a9b7a39423f298ee0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/snic/snic_ctl.c",
  "human_readable_source": "\n\n\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/spinlock.h>\n#include <linux/mempool.h>\n#include <scsi/scsi_tcq.h>\n#include <linux/ctype.h>\n\n#include \"snic_io.h\"\n#include \"snic.h\"\n#include \"cq_enet_desc.h\"\n#include \"snic_fwint.h\"\n\n \nvoid\nsnic_handle_link(struct work_struct *work)\n{\n\tstruct snic *snic = container_of(work, struct snic, link_work);\n\n\tif (snic->config.xpt_type == SNIC_DAS)\n\t\treturn;\n\n\tsnic->link_status = svnic_dev_link_status(snic->vdev);\n\tsnic->link_down_cnt = svnic_dev_link_down_cnt(snic->vdev);\n\tSNIC_HOST_INFO(snic->shost, \"Link Event: Link %s.\\n\",\n\t\t       ((snic->link_status) ? \"Up\" : \"Down\"));\n\n\tSNIC_ASSERT_NOT_IMPL(1);\n}\n\n\n \nstatic int\nsnic_ver_enc(const char *s)\n{\n\tint v[4] = {0};\n\tint  i = 0, x = 0;\n\tchar c;\n\tconst char *p = s;\n\n\t \n\tif ((strlen(s) > 15) || (strlen(s) < 7))\n\t\tgoto end;\n\n\twhile ((c = *p++)) {\n\t\tif (c == '.') {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i > 3 || !isdigit(c))\n\t\t\tgoto end;\n\n\t\tv[i] = v[i] * 10 + (c - '0');\n\t}\n\n\t \n\tfor (i = 3; i >= 0; i--)\n\t\tif (v[i] > 0xff)\n\t\t\tgoto end;\n\n\tx |= (v[0] << 24) | v[1] << 16 | v[2] << 8 | v[3];\n\nend:\n\tif (x == 0) {\n\t\tSNIC_ERR(\"Invalid version string [%s].\\n\", s);\n\n\t\treturn -1;\n\t}\n\n\treturn x;\n}  \n\n \nint\nsnic_queue_exch_ver_req(struct snic *snic)\n{\n\tstruct snic_req_info *rqi = NULL;\n\tstruct snic_host_req *req = NULL;\n\tu32 ver = 0;\n\tint ret = 0;\n\n\tSNIC_HOST_INFO(snic->shost, \"Exch Ver Req Preparing...\\n\");\n\n\trqi = snic_req_init(snic, 0);\n\tif (!rqi) {\n\t\tSNIC_HOST_ERR(snic->shost, \"Init Exch Ver Req failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treq = rqi_to_req(rqi);\n\n\t \n\tsnic_io_hdr_enc(&req->hdr, SNIC_REQ_EXCH_VER, 0, SCSI_NO_TAG,\n\t\t\tsnic->config.hid, 0, (ulong)rqi);\n\tver = snic_ver_enc(SNIC_DRV_VERSION);\n\treq->u.exch_ver.drvr_ver = cpu_to_le32(ver);\n\treq->u.exch_ver.os_type = cpu_to_le32(SNIC_OS_LINUX);\n\n\tsnic_handle_untagged_req(snic, rqi);\n\n\tret = snic_queue_wq_desc(snic, req, sizeof(*req));\n\tif (ret) {\n\t\tsnic_release_untagged_req(snic, rqi);\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"Queuing Exch Ver Req failed, err = %d\\n\",\n\t\t\t      ret);\n\t\tgoto error;\n\t}\n\n\tSNIC_HOST_INFO(snic->shost, \"Exch Ver Req is issued. ret = %d\\n\", ret);\n\nerror:\n\treturn ret;\n}  \n\n \nvoid\nsnic_io_exch_ver_cmpl_handler(struct snic *snic, struct snic_fw_req *fwreq)\n{\n\tstruct snic_req_info *rqi = NULL;\n\tstruct snic_exch_ver_rsp *exv_cmpl = &fwreq->u.exch_ver_cmpl;\n\tu8 typ, hdr_stat;\n\tu32 cmnd_id, hid, max_sgs;\n\tulong ctx = 0;\n\tunsigned long flags;\n\n\tSNIC_HOST_INFO(snic->shost, \"Exch Ver Compl Received.\\n\");\n\tsnic_io_hdr_dec(&fwreq->hdr, &typ, &hdr_stat, &cmnd_id, &hid, &ctx);\n\tSNIC_BUG_ON(snic->config.hid != hid);\n\trqi = (struct snic_req_info *) ctx;\n\n\tif (hdr_stat) {\n\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t      \"Exch Ver Completed w/ err status %d\\n\",\n\t\t\t      hdr_stat);\n\n\t\tgoto exch_cmpl_end;\n\t}\n\n\tspin_lock_irqsave(&snic->snic_lock, flags);\n\tsnic->fwinfo.fw_ver = le32_to_cpu(exv_cmpl->version);\n\tsnic->fwinfo.hid = le32_to_cpu(exv_cmpl->hid);\n\tsnic->fwinfo.max_concur_ios = le32_to_cpu(exv_cmpl->max_concur_ios);\n\tsnic->fwinfo.max_sgs_per_cmd = le32_to_cpu(exv_cmpl->max_sgs_per_cmd);\n\tsnic->fwinfo.max_io_sz = le32_to_cpu(exv_cmpl->max_io_sz);\n\tsnic->fwinfo.max_tgts = le32_to_cpu(exv_cmpl->max_tgts);\n\tsnic->fwinfo.io_tmo = le16_to_cpu(exv_cmpl->io_timeout);\n\n\tSNIC_HOST_INFO(snic->shost,\n\t\t       \"vers %u hid %u max_concur_ios %u max_sgs_per_cmd %u max_io_sz %u max_tgts %u fw tmo %u\\n\",\n\t\t       snic->fwinfo.fw_ver,\n\t\t       snic->fwinfo.hid,\n\t\t       snic->fwinfo.max_concur_ios,\n\t\t       snic->fwinfo.max_sgs_per_cmd,\n\t\t       snic->fwinfo.max_io_sz,\n\t\t       snic->fwinfo.max_tgts,\n\t\t       snic->fwinfo.io_tmo);\n\n\tSNIC_HOST_INFO(snic->shost,\n\t\t       \"HBA Capabilities = 0x%x\\n\",\n\t\t       le32_to_cpu(exv_cmpl->hba_cap));\n\n\t \n\tmax_sgs = snic->fwinfo.max_sgs_per_cmd;\n\tif (max_sgs && max_sgs < SNIC_MAX_SG_DESC_CNT) {\n\t\tsnic->shost->sg_tablesize = max_sgs;\n\t\tSNIC_HOST_INFO(snic->shost, \"Max SGs set to %d\\n\",\n\t\t\t       snic->shost->sg_tablesize);\n\t} else if (max_sgs > snic->shost->sg_tablesize) {\n\t\tSNIC_HOST_INFO(snic->shost,\n\t\t\t       \"Target type %d Supports Larger Max SGList %d than driver's Max SG List %d.\\n\",\n\t\t\t       snic->config.xpt_type, max_sgs,\n\t\t\t       snic->shost->sg_tablesize);\n\t}\n\n\tif (snic->shost->can_queue > snic->fwinfo.max_concur_ios)\n\t\tsnic->shost->can_queue = snic->fwinfo.max_concur_ios;\n\n\tsnic->shost->max_sectors = snic->fwinfo.max_io_sz >> 9;\n\tif (snic->fwinfo.wait)\n\t\tcomplete(snic->fwinfo.wait);\n\n\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\nexch_cmpl_end:\n\tsnic_release_untagged_req(snic, rqi);\n\n\tSNIC_HOST_INFO(snic->shost, \"Exch_cmpl Done, hdr_stat %d.\\n\", hdr_stat);\n}  \n\n \nint\nsnic_get_conf(struct snic *snic)\n{\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\tunsigned long flags;\n\tint ret;\n\tint nr_retries = 3;\n\n\tSNIC_HOST_INFO(snic->shost, \"Retrieving snic params.\\n\");\n\tspin_lock_irqsave(&snic->snic_lock, flags);\n\tmemset(&snic->fwinfo, 0, sizeof(snic->fwinfo));\n\tsnic->fwinfo.wait = &wait;\n\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\n\t \n\tmsleep(50);\n\n\t \n\tdo {\n\t\tret = snic_queue_exch_ver_req(snic);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\twait_for_completion_timeout(&wait, msecs_to_jiffies(2000));\n\t\tspin_lock_irqsave(&snic->snic_lock, flags);\n\t\tret = (snic->fwinfo.fw_ver != 0) ? 0 : -ETIMEDOUT;\n\t\tif (ret)\n\t\t\tSNIC_HOST_ERR(snic->shost,\n\t\t\t\t      \"Failed to retrieve snic params,\\n\");\n\n\t\t \n\t\tif (ret == 0 || nr_retries == 1)\n\t\t\tsnic->fwinfo.wait = NULL;\n\n\t\tspin_unlock_irqrestore(&snic->snic_lock, flags);\n\t} while (ret && --nr_retries);\n\n\treturn ret;\n}  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}