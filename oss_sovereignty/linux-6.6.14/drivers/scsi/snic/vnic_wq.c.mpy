{
  "module_name": "vnic_wq.c",
  "hash_id": "e5aee92f153d0aa431d710aed370e585cf3f24cdb449857efebdf13ca27b0c1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/snic/vnic_wq.c",
  "human_readable_source": "\n\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include \"vnic_dev.h\"\n#include \"vnic_wq.h\"\n\nstatic inline int vnic_wq_get_ctrl(struct vnic_dev *vdev, struct vnic_wq *wq,\n\tunsigned int index, enum vnic_res_type res_type)\n{\n\twq->ctrl = svnic_dev_get_res(vdev, res_type, index);\n\tif (!wq->ctrl)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline int vnic_wq_alloc_ring(struct vnic_dev *vdev, struct vnic_wq *wq,\n\tunsigned int index, unsigned int desc_count, unsigned int desc_size)\n{\n\treturn svnic_dev_alloc_desc_ring(vdev, &wq->ring, desc_count,\n\t\t\t\t\t desc_size);\n}\n\nstatic int vnic_wq_alloc_bufs(struct vnic_wq *wq)\n{\n\tstruct vnic_wq_buf *buf;\n\tunsigned int i, j, count = wq->ring.desc_count;\n\tunsigned int blks = VNIC_WQ_BUF_BLKS_NEEDED(count);\n\n\tfor (i = 0; i < blks; i++) {\n\t\twq->bufs[i] = kzalloc(VNIC_WQ_BUF_BLK_SZ, GFP_ATOMIC);\n\t\tif (!wq->bufs[i]) {\n\t\t\tpr_err(\"Failed to alloc wq_bufs\\n\");\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < blks; i++) {\n\t\tbuf = wq->bufs[i];\n\t\tfor (j = 0; j < VNIC_WQ_BUF_DFLT_BLK_ENTRIES; j++) {\n\t\t\tbuf->index = i * VNIC_WQ_BUF_DFLT_BLK_ENTRIES + j;\n\t\t\tbuf->desc = (u8 *)wq->ring.descs +\n\t\t\t\twq->ring.desc_size * buf->index;\n\t\t\tif (buf->index + 1 == count) {\n\t\t\t\tbuf->next = wq->bufs[0];\n\t\t\t\tbreak;\n\t\t\t} else if (j + 1 == VNIC_WQ_BUF_DFLT_BLK_ENTRIES) {\n\t\t\t\tbuf->next = wq->bufs[i + 1];\n\t\t\t} else {\n\t\t\t\tbuf->next = buf + 1;\n\t\t\t\tbuf++;\n\t\t\t}\n\t\t}\n\t}\n\n\twq->to_use = wq->to_clean = wq->bufs[0];\n\n\treturn 0;\n}\n\nvoid svnic_wq_free(struct vnic_wq *wq)\n{\n\tstruct vnic_dev *vdev;\n\tunsigned int i;\n\n\tvdev = wq->vdev;\n\n\tsvnic_dev_free_desc_ring(vdev, &wq->ring);\n\n\tfor (i = 0; i < VNIC_WQ_BUF_BLKS_MAX; i++) {\n\t\tkfree(wq->bufs[i]);\n\t\twq->bufs[i] = NULL;\n\t}\n\n\twq->ctrl = NULL;\n\n}\n\nint vnic_wq_devcmd2_alloc(struct vnic_dev *vdev, struct vnic_wq *wq,\n\tunsigned int desc_count, unsigned int desc_size)\n{\n\tint err;\n\n\twq->index = 0;\n\twq->vdev = vdev;\n\n\terr = vnic_wq_get_ctrl(vdev, wq, 0, RES_TYPE_DEVCMD2);\n\tif (err) {\n\t\tpr_err(\"Failed to get devcmd2 resource\\n\");\n\n\t\treturn err;\n\t}\n\n\tsvnic_wq_disable(wq);\n\n\terr = vnic_wq_alloc_ring(vdev, wq, 0, desc_count, desc_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nint svnic_wq_alloc(struct vnic_dev *vdev, struct vnic_wq *wq,\n\tunsigned int index, unsigned int desc_count, unsigned int desc_size)\n{\n\tint err;\n\n\twq->index = index;\n\twq->vdev = vdev;\n\n\terr = vnic_wq_get_ctrl(vdev, wq, index, RES_TYPE_WQ);\n\tif (err) {\n\t\tpr_err(\"Failed to hook WQ[%d] resource\\n\", index);\n\n\t\treturn err;\n\t}\n\n\tsvnic_wq_disable(wq);\n\n\terr = vnic_wq_alloc_ring(vdev, wq, index, desc_count, desc_size);\n\tif (err)\n\t\treturn err;\n\n\terr = vnic_wq_alloc_bufs(wq);\n\tif (err) {\n\t\tsvnic_wq_free(wq);\n\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid vnic_wq_init_start(struct vnic_wq *wq, unsigned int cq_index,\n\tunsigned int fetch_index, unsigned int posted_index,\n\tunsigned int error_interrupt_enable,\n\tunsigned int error_interrupt_offset)\n{\n\tu64 paddr;\n\tunsigned int count = wq->ring.desc_count;\n\n\tpaddr = (u64)wq->ring.base_addr | VNIC_PADDR_TARGET;\n\twriteq(paddr, &wq->ctrl->ring_base);\n\tiowrite32(count, &wq->ctrl->ring_size);\n\tiowrite32(fetch_index, &wq->ctrl->fetch_index);\n\tiowrite32(posted_index, &wq->ctrl->posted_index);\n\tiowrite32(cq_index, &wq->ctrl->cq_index);\n\tiowrite32(error_interrupt_enable, &wq->ctrl->error_interrupt_enable);\n\tiowrite32(error_interrupt_offset, &wq->ctrl->error_interrupt_offset);\n\tiowrite32(0, &wq->ctrl->error_status);\n\n\twq->to_use = wq->to_clean =\n\t\t&wq->bufs[fetch_index / VNIC_WQ_BUF_BLK_ENTRIES(count)]\n\t\t\t[fetch_index % VNIC_WQ_BUF_BLK_ENTRIES(count)];\n}\n\nvoid svnic_wq_init(struct vnic_wq *wq, unsigned int cq_index,\n\tunsigned int error_interrupt_enable,\n\tunsigned int error_interrupt_offset)\n{\n\tvnic_wq_init_start(wq, cq_index, 0, 0, error_interrupt_enable,\n\t\t\t   error_interrupt_offset);\n}\n\nunsigned int svnic_wq_error_status(struct vnic_wq *wq)\n{\n\treturn ioread32(&wq->ctrl->error_status);\n}\n\nvoid svnic_wq_enable(struct vnic_wq *wq)\n{\n\tiowrite32(1, &wq->ctrl->enable);\n}\n\nint svnic_wq_disable(struct vnic_wq *wq)\n{\n\tunsigned int wait;\n\n\tiowrite32(0, &wq->ctrl->enable);\n\n\t \n\tfor (wait = 0; wait < 100; wait++) {\n\t\tif (!(ioread32(&wq->ctrl->running)))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\tpr_err(\"Failed to disable WQ[%d]\\n\", wq->index);\n\n\treturn -ETIMEDOUT;\n}\n\nvoid svnic_wq_clean(struct vnic_wq *wq,\n\tvoid (*buf_clean)(struct vnic_wq *wq, struct vnic_wq_buf *buf))\n{\n\tstruct vnic_wq_buf *buf;\n\n\tBUG_ON(ioread32(&wq->ctrl->enable));\n\n\tbuf = wq->to_clean;\n\n\twhile (svnic_wq_desc_used(wq) > 0) {\n\n\t\t(*buf_clean)(wq, buf);\n\n\t\tbuf = wq->to_clean = buf->next;\n\t\twq->ring.desc_avail++;\n\t}\n\n\twq->to_use = wq->to_clean = wq->bufs[0];\n\n\tiowrite32(0, &wq->ctrl->fetch_index);\n\tiowrite32(0, &wq->ctrl->posted_index);\n\tiowrite32(0, &wq->ctrl->error_status);\n\n\tsvnic_dev_clear_desc_ring(&wq->ring);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}