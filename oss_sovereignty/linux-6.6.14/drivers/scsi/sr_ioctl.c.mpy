{
  "module_name": "sr_ioctl.c",
  "hash_id": "dc064234d3a2e252190f36bbfa596aecfb361cb08d47daab2dba66955cc2675b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sr_ioctl.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/blkpg.h>\n#include <linux/cdrom.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_ioctl.h>\n#include <scsi/scsi_cmnd.h>\n\n#include \"sr.h\"\n\n#if 0\n#define DEBUG\n#endif\n\n \nstatic int xa_test = 0;\n\nmodule_param(xa_test, int, S_IRUGO | S_IWUSR);\n\nstatic int sr_read_tochdr(struct cdrom_device_info *cdi,\n\t\tstruct cdrom_tochdr *tochdr)\n{\n\tstruct scsi_cd *cd = cdi->handle;\n\tstruct packet_command cgc;\n\tint result;\n\tunsigned char *buffer;\n\n\tbuffer = kzalloc(32, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.timeout = IOCTL_TIMEOUT;\n\tcgc.cmd[0] = GPCMD_READ_TOC_PMA_ATIP;\n\tcgc.cmd[8] = 12;\t\t \n\tcgc.buffer = buffer;\n\tcgc.buflen = 12;\n\tcgc.quiet = 1;\n\tcgc.data_direction = DMA_FROM_DEVICE;\n\n\tresult = sr_do_ioctl(cd, &cgc);\n\tif (result)\n\t\tgoto err;\n\n\ttochdr->cdth_trk0 = buffer[2];\n\ttochdr->cdth_trk1 = buffer[3];\n\nerr:\n\tkfree(buffer);\n\treturn result;\n}\n\nstatic int sr_read_tocentry(struct cdrom_device_info *cdi,\n\t\tstruct cdrom_tocentry *tocentry)\n{\n\tstruct scsi_cd *cd = cdi->handle;\n\tstruct packet_command cgc;\n\tint result;\n\tunsigned char *buffer;\n\n\tbuffer = kzalloc(32, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.timeout = IOCTL_TIMEOUT;\n\tcgc.cmd[0] = GPCMD_READ_TOC_PMA_ATIP;\n\tcgc.cmd[1] |= (tocentry->cdte_format == CDROM_MSF) ? 0x02 : 0;\n\tcgc.cmd[6] = tocentry->cdte_track;\n\tcgc.cmd[8] = 12;\t\t \n\tcgc.buffer = buffer;\n\tcgc.buflen = 12;\n\tcgc.data_direction = DMA_FROM_DEVICE;\n\n\tresult = sr_do_ioctl(cd, &cgc);\n\tif (result)\n\t\tgoto err;\n\n\ttocentry->cdte_ctrl = buffer[5] & 0xf;\n\ttocentry->cdte_adr = buffer[5] >> 4;\n\ttocentry->cdte_datamode = (tocentry->cdte_ctrl & 0x04) ? 1 : 0;\n\tif (tocentry->cdte_format == CDROM_MSF) {\n\t\ttocentry->cdte_addr.msf.minute = buffer[9];\n\t\ttocentry->cdte_addr.msf.second = buffer[10];\n\t\ttocentry->cdte_addr.msf.frame = buffer[11];\n\t} else\n\t\ttocentry->cdte_addr.lba = (((((buffer[8] << 8) + buffer[9]) << 8)\n\t\t\t+ buffer[10]) << 8) + buffer[11];\n\nerr:\n\tkfree(buffer);\n\treturn result;\n}\n\n#define IOCTL_RETRIES 3\n\n \n\nstatic int sr_fake_playtrkind(struct cdrom_device_info *cdi, struct cdrom_ti *ti)\n{\n\tstruct cdrom_tocentry trk0_te, trk1_te;\n\tstruct cdrom_tochdr tochdr;\n\tstruct packet_command cgc;\n\tint ntracks, ret;\n\n\tret = sr_read_tochdr(cdi, &tochdr);\n\tif (ret)\n\t\treturn ret;\n\n\tntracks = tochdr.cdth_trk1 - tochdr.cdth_trk0 + 1;\n\t\n\tif (ti->cdti_trk1 == ntracks) \n\t\tti->cdti_trk1 = CDROM_LEADOUT;\n\telse if (ti->cdti_trk1 != CDROM_LEADOUT)\n\t\tti->cdti_trk1 ++;\n\n\ttrk0_te.cdte_track = ti->cdti_trk0;\n\ttrk0_te.cdte_format = CDROM_MSF;\n\ttrk1_te.cdte_track = ti->cdti_trk1;\n\ttrk1_te.cdte_format = CDROM_MSF;\n\t\n\tret = sr_read_tocentry(cdi, &trk0_te);\n\tif (ret)\n\t\treturn ret;\n\tret = sr_read_tocentry(cdi, &trk1_te);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_PLAY_AUDIO_MSF;\n\tcgc.cmd[3] = trk0_te.cdte_addr.msf.minute;\n\tcgc.cmd[4] = trk0_te.cdte_addr.msf.second;\n\tcgc.cmd[5] = trk0_te.cdte_addr.msf.frame;\n\tcgc.cmd[6] = trk1_te.cdte_addr.msf.minute;\n\tcgc.cmd[7] = trk1_te.cdte_addr.msf.second;\n\tcgc.cmd[8] = trk1_te.cdte_addr.msf.frame;\n\tcgc.data_direction = DMA_NONE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\treturn sr_do_ioctl(cdi->handle, &cgc);\n}\n\nstatic int sr_play_trkind(struct cdrom_device_info *cdi,\n\t\tstruct cdrom_ti *ti)\n\n{\n\tstruct scsi_cd *cd = cdi->handle;\n\tstruct packet_command cgc;\n\tint result;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.timeout = IOCTL_TIMEOUT;\n\tcgc.cmd[0] = GPCMD_PLAYAUDIO_TI;\n\tcgc.cmd[4] = ti->cdti_trk0;\n\tcgc.cmd[5] = ti->cdti_ind0;\n\tcgc.cmd[7] = ti->cdti_trk1;\n\tcgc.cmd[8] = ti->cdti_ind1;\n\tcgc.data_direction = DMA_NONE;\n\n\tresult = sr_do_ioctl(cd, &cgc);\n\tif (result == -EDRIVE_CANT_DO_THIS)\n\t\tresult = sr_fake_playtrkind(cdi, ti);\n\n\treturn result;\n}\n\n \n\nint sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)\n{\n\tstruct scsi_device *SDev;\n\tstruct scsi_sense_hdr local_sshdr, *sshdr;\n\tint result, err = 0, retries = 0;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = cgc->sshdr ? : &local_sshdr,\n\t};\n\n\tSDev = cd->device;\n\n\tsshdr = exec_args.sshdr;\n\n      retry:\n\tif (!scsi_block_when_processing_errors(SDev)) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tresult = scsi_execute_cmd(SDev, cgc->cmd,\n\t\t\t\t  cgc->data_direction == DMA_TO_DEVICE ?\n\t\t\t\t  REQ_OP_DRV_OUT : REQ_OP_DRV_IN, cgc->buffer,\n\t\t\t\t  cgc->buflen, cgc->timeout, IOCTL_RETRIES,\n\t\t\t\t  &exec_args);\n\t \n\tif (result < 0) {\n\t\terr = result;\n\t\tgoto out;\n\t}\n\tif (scsi_status_is_check_condition(result)) {\n\t\tswitch (sshdr->sense_key) {\n\t\tcase UNIT_ATTENTION:\n\t\t\tSDev->changed = 1;\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"disc change detected.\\n\");\n\t\t\tif (retries++ < 10)\n\t\t\t\tgoto retry;\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase NOT_READY:\t \n\t\t\tif (sshdr->asc == 0x04 &&\n\t\t\t    sshdr->ascq == 0x01) {\n\t\t\t\t \n\t\t\t\tif (!cgc->quiet)\n\t\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t\t  \"CDROM not ready yet.\\n\");\n\t\t\t\tif (retries++ < 10) {\n\t\t\t\t\t \n\t\t\t\t\tssleep(2);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\terr = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"CDROM not ready.  Make sure there \"\n\t\t\t\t\t  \"is a disc in the drive.\\n\");\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase ILLEGAL_REQUEST:\n\t\t\terr = -EIO;\n\t\t\tif (sshdr->asc == 0x20 &&\n\t\t\t    sshdr->ascq == 0x00)\n\t\t\t\t \n\t\t\t\terr = -EDRIVE_CANT_DO_THIS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\n\t \n      out:\n\tcgc->stat = err;\n\treturn err;\n}\n\n \n \n\nint sr_tray_move(struct cdrom_device_info *cdi, int pos)\n{\n\tScsi_CD *cd = cdi->handle;\n\tstruct packet_command cgc;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_START_STOP_UNIT;\n\tcgc.cmd[4] = (pos == 0) ? 0x03   : 0x02   ;\n\tcgc.data_direction = DMA_NONE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\treturn sr_do_ioctl(cd, &cgc);\n}\n\nint sr_lock_door(struct cdrom_device_info *cdi, int lock)\n{\n\tScsi_CD *cd = cdi->handle;\n\n\treturn scsi_set_medium_removal(cd->device, lock ?\n\t\t       SCSI_REMOVAL_PREVENT : SCSI_REMOVAL_ALLOW);\n}\n\nint sr_drive_status(struct cdrom_device_info *cdi, int slot)\n{\n\tstruct scsi_cd *cd = cdi->handle;\n\tstruct scsi_sense_hdr sshdr;\n\tstruct media_event_desc med;\n\n\tif (CDSL_CURRENT != slot) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\tif (!scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr))\n\t\treturn CDS_DISC_OK;\n\n\t \n\tif (scsi_sense_valid(&sshdr) && sshdr.sense_key == NOT_READY\n\t\t\t&& sshdr.asc == 0x04 && sshdr.ascq == 0x01)\n\t\treturn CDS_DRIVE_NOT_READY;\n\n\tif (!cdrom_get_media_event(cdi, &med)) {\n\t\tif (med.media_present)\n\t\t\treturn CDS_DISC_OK;\n\t\telse if (med.door_open)\n\t\t\treturn CDS_TRAY_OPEN;\n\t\telse\n\t\t\treturn CDS_NO_DISC;\n\t}\n\n\t \n\tif (scsi_sense_valid(&sshdr) && sshdr.sense_key == NOT_READY\n\t\t\t&& sshdr.asc == 0x04 && sshdr.ascq == 0x02)\n\t\treturn CDS_TRAY_OPEN;\n\n\t \n\tif (sshdr.sense_key == NOT_READY && sshdr.asc == 0x04)\n\t\treturn CDS_DISC_OK;\n\n\t \n\tif (scsi_sense_valid(&sshdr) &&\n\t     \n\t    sshdr.asc == 0x3a)\n\t\treturn CDS_NO_DISC;\n\telse\n\t\treturn CDS_TRAY_OPEN;\n\n\treturn CDS_DRIVE_NOT_READY;\n}\n\nint sr_disk_status(struct cdrom_device_info *cdi)\n{\n\tScsi_CD *cd = cdi->handle;\n\tstruct cdrom_tochdr toc_h;\n\tstruct cdrom_tocentry toc_e;\n\tint i, rc, have_datatracks = 0;\n\n\t \n\trc = sr_read_tochdr(cdi, &toc_h);\n\tif (rc)\n\t\treturn (rc == -ENOMEDIUM) ? CDS_NO_DISC : CDS_NO_INFO;\n\n\tfor (i = toc_h.cdth_trk0; i <= toc_h.cdth_trk1; i++) {\n\t\ttoc_e.cdte_track = i;\n\t\ttoc_e.cdte_format = CDROM_LBA;\n\t\tif (sr_read_tocentry(cdi, &toc_e))\n\t\t\treturn CDS_NO_INFO;\n\t\tif (toc_e.cdte_ctrl & CDROM_DATA_TRACK) {\n\t\t\thave_datatracks = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!have_datatracks)\n\t\treturn CDS_AUDIO;\n\n\tif (cd->xa_flag)\n\t\treturn CDS_XA_2_1;\n\telse\n\t\treturn CDS_DATA_1;\n}\n\nint sr_get_last_session(struct cdrom_device_info *cdi,\n\t\t\tstruct cdrom_multisession *ms_info)\n{\n\tScsi_CD *cd = cdi->handle;\n\n\tms_info->addr.lba = cd->ms_offset;\n\tms_info->xa_flag = cd->xa_flag || cd->ms_offset > 0;\n\n\treturn 0;\n}\n\nint sr_get_mcn(struct cdrom_device_info *cdi, struct cdrom_mcn *mcn)\n{\n\tScsi_CD *cd = cdi->handle;\n\tstruct packet_command cgc;\n\tchar *buffer = kzalloc(32, GFP_KERNEL);\n\tint result;\n\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_READ_SUBCHANNEL;\n\tcgc.cmd[2] = 0x40;\t \n\tcgc.cmd[3] = 0x02;\t \n\tcgc.cmd[8] = 24;\n\tcgc.buffer = buffer;\n\tcgc.buflen = 24;\n\tcgc.data_direction = DMA_FROM_DEVICE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\tresult = sr_do_ioctl(cd, &cgc);\n\tif (result)\n\t\tgoto err;\n\n\tmemcpy(mcn->medium_catalog_number, buffer + 9, 13);\n\tmcn->medium_catalog_number[13] = 0;\n\nerr:\n\tkfree(buffer);\n\treturn result;\n}\n\nint sr_reset(struct cdrom_device_info *cdi)\n{\n\treturn 0;\n}\n\nint sr_select_speed(struct cdrom_device_info *cdi, int speed)\n{\n\tScsi_CD *cd = cdi->handle;\n\tstruct packet_command cgc;\n\n\tif (speed == 0)\n\t\tspeed = 0xffff;\t \n\telse\n\t\tspeed *= 177;\t \n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_SET_SPEED;\t \n\tcgc.cmd[2] = (speed >> 8) & 0xff;\t \n\tcgc.cmd[3] = speed & 0xff;\t \n\tcgc.data_direction = DMA_NONE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\n\tif (sr_do_ioctl(cd, &cgc))\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \n \n \n \n \n\nint sr_audio_ioctl(struct cdrom_device_info *cdi, unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase CDROMREADTOCHDR:\n\t\treturn sr_read_tochdr(cdi, arg);\n\tcase CDROMREADTOCENTRY:\n\t\treturn sr_read_tocentry(cdi, arg);\n\tcase CDROMPLAYTRKIND:\n\t\treturn sr_play_trkind(cdi, arg);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \n\nstatic int sr_read_cd(Scsi_CD *cd, unsigned char *dest, int lba, int format, int blksize)\n{\n\tstruct packet_command cgc;\n\n#ifdef DEBUG\n\tsr_printk(KERN_INFO, cd, \"sr_read_cd lba=%d format=%d blksize=%d\\n\",\n\t\t  lba, format, blksize);\n#endif\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_READ_CD;\t \n\tcgc.cmd[1] = ((format & 7) << 2);\n\tcgc.cmd[2] = (unsigned char) (lba >> 24) & 0xff;\n\tcgc.cmd[3] = (unsigned char) (lba >> 16) & 0xff;\n\tcgc.cmd[4] = (unsigned char) (lba >> 8) & 0xff;\n\tcgc.cmd[5] = (unsigned char) lba & 0xff;\n\tcgc.cmd[8] = 1;\n\tswitch (blksize) {\n\tcase 2336:\n\t\tcgc.cmd[9] = 0x58;\n\t\tbreak;\n\tcase 2340:\n\t\tcgc.cmd[9] = 0x78;\n\t\tbreak;\n\tcase 2352:\n\t\tcgc.cmd[9] = 0xf8;\n\t\tbreak;\n\tdefault:\n\t\tcgc.cmd[9] = 0x10;\n\t\tbreak;\n\t}\n\tcgc.buffer = dest;\n\tcgc.buflen = blksize;\n\tcgc.data_direction = DMA_FROM_DEVICE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\treturn sr_do_ioctl(cd, &cgc);\n}\n\n \n\nstatic int sr_read_sector(Scsi_CD *cd, int lba, int blksize, unsigned char *dest)\n{\n\tstruct packet_command cgc;\n\tint rc;\n\n\t \n\tif (cd->readcd_known) {\n\t\trc = sr_read_cd(cd, dest, lba, 0, blksize);\n\t\tif (-EDRIVE_CANT_DO_THIS != rc)\n\t\t\treturn rc;\n\t\tcd->readcd_known = 0;\n\t\tsr_printk(KERN_INFO, cd,\n\t\t\t  \"CDROM doesn't support READ CD (0xbe) command\\n\");\n\t\t \n\t}\n\t \n\tif (blksize != cd->device->sector_size) {\n\t\tif (0 != (rc = sr_set_blocklength(cd, blksize)))\n\t\t\treturn rc;\n\t}\n#ifdef DEBUG\n\tsr_printk(KERN_INFO, cd, \"sr_read_sector lba=%d blksize=%d\\n\",\n\t\t  lba, blksize);\n#endif\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_READ_10;\n\tcgc.cmd[2] = (unsigned char) (lba >> 24) & 0xff;\n\tcgc.cmd[3] = (unsigned char) (lba >> 16) & 0xff;\n\tcgc.cmd[4] = (unsigned char) (lba >> 8) & 0xff;\n\tcgc.cmd[5] = (unsigned char) lba & 0xff;\n\tcgc.cmd[8] = 1;\n\tcgc.buffer = dest;\n\tcgc.buflen = blksize;\n\tcgc.data_direction = DMA_FROM_DEVICE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\trc = sr_do_ioctl(cd, &cgc);\n\n\tif (blksize != CD_FRAMESIZE)\n\t\trc |= sr_set_blocklength(cd, CD_FRAMESIZE);\n\treturn rc;\n}\n\n \n\nint sr_is_xa(Scsi_CD *cd)\n{\n\tunsigned char *raw_sector;\n\tint is_xa;\n\n\tif (!xa_test)\n\t\treturn 0;\n\n\traw_sector = kmalloc(2048, GFP_KERNEL);\n\tif (!raw_sector)\n\t\treturn -ENOMEM;\n\tif (0 == sr_read_sector(cd, cd->ms_offset + 16,\n\t\t\t\tCD_FRAMESIZE_RAW1, raw_sector)) {\n\t\tis_xa = (raw_sector[3] == 0x02) ? 1 : 0;\n\t} else {\n\t\t \n\t\tis_xa = -1;\n\t}\n\tkfree(raw_sector);\n#ifdef DEBUG\n\tsr_printk(KERN_INFO, cd, \"sr_is_xa: %d\\n\", is_xa);\n#endif\n\treturn is_xa;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}