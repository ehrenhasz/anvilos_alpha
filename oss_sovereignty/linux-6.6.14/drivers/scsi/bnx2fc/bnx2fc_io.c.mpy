{
  "module_name": "bnx2fc_io.c",
  "hash_id": "adadc5f0028daf74b84206a371a985494d2a2ae2656a48a16baa96acd541c20a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bnx2fc/bnx2fc_io.c",
  "human_readable_source": " \n\n#include \"bnx2fc.h\"\n\n#define RESERVE_FREE_LIST_INDEX num_possible_cpus()\n\nstatic int bnx2fc_split_bd(struct bnx2fc_cmd *io_req, u64 addr, int sg_len,\n\t\t\t   int bd_index);\nstatic int bnx2fc_map_sg(struct bnx2fc_cmd *io_req);\nstatic int bnx2fc_build_bd_list_from_sg(struct bnx2fc_cmd *io_req);\nstatic void bnx2fc_unmap_sg_list(struct bnx2fc_cmd *io_req);\nstatic void bnx2fc_free_mp_resc(struct bnx2fc_cmd *io_req);\nstatic void bnx2fc_parse_fcp_rsp(struct bnx2fc_cmd *io_req,\n\t\t\t\t struct fcoe_fcp_rsp_payload *fcp_rsp,\n\t\t\t\t u8 num_rq, unsigned char *rq_data);\n\nvoid bnx2fc_cmd_timer_set(struct bnx2fc_cmd *io_req,\n\t\t\t  unsigned int timer_msec)\n{\n\tstruct bnx2fc_interface *interface = io_req->port->priv;\n\n\tif (queue_delayed_work(interface->timer_work_queue,\n\t\t\t       &io_req->timeout_work,\n\t\t\t       msecs_to_jiffies(timer_msec)))\n\t\tkref_get(&io_req->refcount);\n}\n\nstatic void bnx2fc_cmd_timeout(struct work_struct *work)\n{\n\tstruct bnx2fc_cmd *io_req = container_of(work, struct bnx2fc_cmd,\n\t\t\t\t\t\t timeout_work.work);\n\tu8 cmd_type = io_req->cmd_type;\n\tstruct bnx2fc_rport *tgt = io_req->tgt;\n\tint rc;\n\n\tBNX2FC_IO_DBG(io_req, \"cmd_timeout, cmd_type = %d,\"\n\t\t      \"req_flags = %lx\\n\", cmd_type, io_req->req_flags);\n\n\tspin_lock_bh(&tgt->tgt_lock);\n\tif (test_and_clear_bit(BNX2FC_FLAG_ISSUE_RRQ, &io_req->req_flags)) {\n\t\tclear_bit(BNX2FC_FLAG_RETIRE_OXID, &io_req->req_flags);\n\t\t \n\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t\tbnx2fc_send_rrq(io_req);\n\t\treturn;\n\t}\n\tif (test_and_clear_bit(BNX2FC_FLAG_RETIRE_OXID, &io_req->req_flags)) {\n\t\tBNX2FC_IO_DBG(io_req, \"IO ready for reuse now\\n\");\n\t\tgoto done;\n\t}\n\n\tswitch (cmd_type) {\n\tcase BNX2FC_SCSI_CMD:\n\t\tif (test_and_clear_bit(BNX2FC_FLAG_EH_ABORT,\n\t\t\t\t\t\t\t&io_req->req_flags)) {\n\t\t\t \n\t\t\tBNX2FC_IO_DBG(io_req, \"eh_abort timed out\\n\");\n\t\t\tcomplete(&io_req->abts_done);\n\t\t} else if (test_bit(BNX2FC_FLAG_ISSUE_ABTS,\n\t\t\t\t    &io_req->req_flags)) {\n\t\t\t \n\t\t\tBNX2FC_IO_DBG(io_req, \"ABTS timed out refcnt = %d\\n\",\n\t\t\t\t\tkref_read(&io_req->refcount));\n\t\t\tif (!(test_and_set_bit(BNX2FC_FLAG_ABTS_DONE,\n\t\t\t\t\t       &io_req->req_flags))) {\n\t\t\t\t \n\t\t\t\tbnx2fc_initiate_cleanup(io_req);\n\t\t\t\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\t\t\t\tspin_unlock_bh(&tgt->tgt_lock);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tBNX2FC_IO_DBG(io_req, \"IO timed out. issue ABTS\\n\");\n\t\t\tif (test_and_set_bit(BNX2FC_FLAG_IO_COMPL,\n\t\t\t\t\t     &io_req->req_flags)) {\n\t\t\t\tBNX2FC_IO_DBG(io_req, \"IO completed before \"\n\t\t\t\t\t\t\t   \" timer expiry\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!test_and_set_bit(BNX2FC_FLAG_ISSUE_ABTS,\n\t\t\t\t\t      &io_req->req_flags)) {\n\t\t\t\trc = bnx2fc_initiate_abts(io_req);\n\t\t\t\tif (rc == SUCCESS)\n\t\t\t\t\tgoto done;\n\n\t\t\t\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\t\t\t\tspin_unlock_bh(&tgt->tgt_lock);\n\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tBNX2FC_IO_DBG(io_req, \"IO already in \"\n\t\t\t\t\t\t      \"ABTS processing\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase BNX2FC_ELS:\n\n\t\tif (test_bit(BNX2FC_FLAG_ISSUE_ABTS, &io_req->req_flags)) {\n\t\t\tBNX2FC_IO_DBG(io_req, \"ABTS for ELS timed out\\n\");\n\n\t\t\tif (!test_and_set_bit(BNX2FC_FLAG_ABTS_DONE,\n\t\t\t\t\t      &io_req->req_flags)) {\n\t\t\t\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\t\t\t\tspin_unlock_bh(&tgt->tgt_lock);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tBNX2FC_IO_DBG(io_req, \"ELS timed out\\n\");\n\t\t\tif (test_and_set_bit(BNX2FC_FLAG_ELS_DONE,\n\t\t\t\t\t       &io_req->req_flags))\n\t\t\t\tgoto done;\n\n\t\t\t \n\t\t\tset_bit(BNX2FC_FLAG_ELS_TIMEOUT, &io_req->req_flags);\n\n\t\t\tif ((io_req->cb_func) && (io_req->cb_arg)) {\n\t\t\t\tio_req->cb_func(io_req->cb_arg);\n\t\t\t\tio_req->cb_arg = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR PFX \"cmd_timeout: invalid cmd_type %d\\n\",\n\t\t\tcmd_type);\n\t\tbreak;\n\t}\n\ndone:\n\t \n\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\tspin_unlock_bh(&tgt->tgt_lock);\n}\n\nstatic void bnx2fc_scsi_done(struct bnx2fc_cmd *io_req, int err_code)\n{\n\t \n\tstruct scsi_cmnd *sc_cmd = io_req->sc_cmd;\n\n\t \n\tif (io_req->cmd_type != BNX2FC_SCSI_CMD)\n\t\treturn;\n\n\tBNX2FC_IO_DBG(io_req, \"scsi_done. err_code = 0x%x\\n\", err_code);\n\tif (test_bit(BNX2FC_FLAG_CMD_LOST, &io_req->req_flags)) {\n\t\t \n\t\treturn;\n\t}\n\n\tbnx2fc_unmap_sg_list(io_req);\n\tio_req->sc_cmd = NULL;\n\n\t \n\tif (!sc_cmd) {\n\t\tprintk(KERN_ERR PFX \"scsi_done - sc_cmd NULL. \"\n\t\t\t\t    \"IO(0x%x) already cleaned up\\n\",\n\t\t       io_req->xid);\n\t\treturn;\n\t}\n\tif (!sc_cmd->device) {\n\t\tpr_err(PFX \"0x%x: sc_cmd->device is NULL.\\n\", io_req->xid);\n\t\treturn;\n\t}\n\tif (!sc_cmd->device->host) {\n\t\tpr_err(PFX \"0x%x: sc_cmd->device->host is NULL.\\n\",\n\t\t    io_req->xid);\n\t\treturn;\n\t}\n\n\tsc_cmd->result = err_code << 16;\n\n\tBNX2FC_IO_DBG(io_req, \"sc=%p, result=0x%x, retries=%d, allowed=%d\\n\",\n\t\tsc_cmd, host_byte(sc_cmd->result), sc_cmd->retries,\n\t\tsc_cmd->allowed);\n\tscsi_set_resid(sc_cmd, scsi_bufflen(sc_cmd));\n\tbnx2fc_priv(sc_cmd)->io_req = NULL;\n\tscsi_done(sc_cmd);\n}\n\nstruct bnx2fc_cmd_mgr *bnx2fc_cmd_mgr_alloc(struct bnx2fc_hba *hba)\n{\n\tstruct bnx2fc_cmd_mgr *cmgr;\n\tstruct io_bdt *bdt_info;\n\tstruct bnx2fc_cmd *io_req;\n\tsize_t len;\n\tu32 mem_size;\n\tu16 xid;\n\tint i;\n\tint num_ios, num_pri_ios;\n\tsize_t bd_tbl_sz;\n\tint arr_sz = num_possible_cpus() + 1;\n\tu16 min_xid = BNX2FC_MIN_XID;\n\tu16 max_xid = hba->max_xid;\n\n\tif (max_xid <= min_xid || max_xid == FC_XID_UNKNOWN) {\n\t\tprintk(KERN_ERR PFX \"cmd_mgr_alloc: Invalid min_xid 0x%x \\\n\t\t\t\t\tand max_xid 0x%x\\n\", min_xid, max_xid);\n\t\treturn NULL;\n\t}\n\tBNX2FC_MISC_DBG(\"min xid 0x%x, max xid 0x%x\\n\", min_xid, max_xid);\n\n\tnum_ios = max_xid - min_xid + 1;\n\tlen = (num_ios * (sizeof(struct bnx2fc_cmd *)));\n\tlen += sizeof(struct bnx2fc_cmd_mgr);\n\n\tcmgr = kzalloc(len, GFP_KERNEL);\n\tif (!cmgr) {\n\t\tprintk(KERN_ERR PFX \"failed to alloc cmgr\\n\");\n\t\treturn NULL;\n\t}\n\n\tcmgr->hba = hba;\n\tcmgr->free_list = kcalloc(arr_sz, sizeof(*cmgr->free_list),\n\t\t\t\t  GFP_KERNEL);\n\tif (!cmgr->free_list) {\n\t\tprintk(KERN_ERR PFX \"failed to alloc free_list\\n\");\n\t\tgoto mem_err;\n\t}\n\n\tcmgr->free_list_lock = kcalloc(arr_sz, sizeof(*cmgr->free_list_lock),\n\t\t\t\t       GFP_KERNEL);\n\tif (!cmgr->free_list_lock) {\n\t\tprintk(KERN_ERR PFX \"failed to alloc free_list_lock\\n\");\n\t\tkfree(cmgr->free_list);\n\t\tcmgr->free_list = NULL;\n\t\tgoto mem_err;\n\t}\n\n\tcmgr->cmds = (struct bnx2fc_cmd **)(cmgr + 1);\n\n\tfor (i = 0; i < arr_sz; i++)  {\n\t\tINIT_LIST_HEAD(&cmgr->free_list[i]);\n\t\tspin_lock_init(&cmgr->free_list_lock[i]);\n\t}\n\n\t/*\n\t * Pre-allocated pool of bnx2fc_cmds.\n\t * Last entry in the free list array is the free list\n\t * of slow path requests.\n\t */\n\txid = BNX2FC_MIN_XID;\n\tnum_pri_ios = num_ios - hba->elstm_xids;\n\tfor (i = 0; i < num_ios; i++) {\n\t\tio_req = kzalloc(sizeof(*io_req), GFP_KERNEL);\n\n\t\tif (!io_req) {\n\t\t\tprintk(KERN_ERR PFX \"failed to alloc io_req\\n\");\n\t\t\tgoto mem_err;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&io_req->link);\n\t\tINIT_DELAYED_WORK(&io_req->timeout_work, bnx2fc_cmd_timeout);\n\n\t\tio_req->xid = xid++;\n\t\tif (i < num_pri_ios)\n\t\t\tlist_add_tail(&io_req->link,\n\t\t\t\t&cmgr->free_list[io_req->xid %\n\t\t\t\t\t\t num_possible_cpus()]);\n\t\telse\n\t\t\tlist_add_tail(&io_req->link,\n\t\t\t\t&cmgr->free_list[num_possible_cpus()]);\n\t\tio_req++;\n\t}\n\n\t/* Allocate pool of io_bdts - one for each bnx2fc_cmd */\n\tmem_size = num_ios * sizeof(struct io_bdt *);\n\tcmgr->io_bdt_pool = kzalloc(mem_size, GFP_KERNEL);\n\tif (!cmgr->io_bdt_pool) {\n\t\tprintk(KERN_ERR PFX \"failed to alloc io_bdt_pool\\n\");\n\t\tgoto mem_err;\n\t}\n\n\tmem_size = sizeof(struct io_bdt);\n\tfor (i = 0; i < num_ios; i++) {\n\t\tcmgr->io_bdt_pool[i] = kmalloc(mem_size, GFP_KERNEL);\n\t\tif (!cmgr->io_bdt_pool[i]) {\n\t\t\tprintk(KERN_ERR PFX \"failed to alloc \"\n\t\t\t\t\"io_bdt_pool[%d]\\n\", i);\n\t\t\tgoto mem_err;\n\t\t}\n\t}\n\n\t/* Allocate an map fcoe_bdt_ctx structures */\n\tbd_tbl_sz = BNX2FC_MAX_BDS_PER_CMD * sizeof(struct fcoe_bd_ctx);\n\tfor (i = 0; i < num_ios; i++) {\n\t\tbdt_info = cmgr->io_bdt_pool[i];\n\t\tbdt_info->bd_tbl = dma_alloc_coherent(&hba->pcidev->dev,\n\t\t\t\t\t\t      bd_tbl_sz,\n\t\t\t\t\t\t      &bdt_info->bd_tbl_dma,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!bdt_info->bd_tbl) {\n\t\t\tprintk(KERN_ERR PFX \"failed to alloc \"\n\t\t\t\t\"bdt_tbl[%d]\\n\", i);\n\t\t\tgoto mem_err;\n\t\t}\n\t}\n\n\treturn cmgr;\n\nmem_err:\n\tbnx2fc_cmd_mgr_free(cmgr);\n\treturn NULL;\n}\n\nvoid bnx2fc_cmd_mgr_free(struct bnx2fc_cmd_mgr *cmgr)\n{\n\tstruct io_bdt *bdt_info;\n\tstruct bnx2fc_hba *hba = cmgr->hba;\n\tsize_t bd_tbl_sz;\n\tu16 min_xid = BNX2FC_MIN_XID;\n\tu16 max_xid = hba->max_xid;\n\tint num_ios;\n\tint i;\n\n\tnum_ios = max_xid - min_xid + 1;\n\n\t/* Free fcoe_bdt_ctx structures */\n\tif (!cmgr->io_bdt_pool)\n\t\tgoto free_cmd_pool;\n\n\tbd_tbl_sz = BNX2FC_MAX_BDS_PER_CMD * sizeof(struct fcoe_bd_ctx);\n\tfor (i = 0; i < num_ios; i++) {\n\t\tbdt_info = cmgr->io_bdt_pool[i];\n\t\tif (bdt_info->bd_tbl) {\n\t\t\tdma_free_coherent(&hba->pcidev->dev, bd_tbl_sz,\n\t\t\t\t\t    bdt_info->bd_tbl,\n\t\t\t\t\t    bdt_info->bd_tbl_dma);\n\t\t\tbdt_info->bd_tbl = NULL;\n\t\t}\n\t}\n\n\t/* Destroy io_bdt pool */\n\tfor (i = 0; i < num_ios; i++) {\n\t\tkfree(cmgr->io_bdt_pool[i]);\n\t\tcmgr->io_bdt_pool[i] = NULL;\n\t}\n\n\tkfree(cmgr->io_bdt_pool);\n\tcmgr->io_bdt_pool = NULL;\n\nfree_cmd_pool:\n\tkfree(cmgr->free_list_lock);\n\n\t/* Destroy cmd pool */\n\tif (!cmgr->free_list)\n\t\tgoto free_cmgr;\n\n\tfor (i = 0; i < num_possible_cpus() + 1; i++)  {\n\t\tstruct bnx2fc_cmd *tmp, *io_req;\n\n\t\tlist_for_each_entry_safe(io_req, tmp,\n\t\t\t\t\t &cmgr->free_list[i], link) {\n\t\t\tlist_del(&io_req->link);\n\t\t\tkfree(io_req);\n\t\t}\n\t}\n\tkfree(cmgr->free_list);\nfree_cmgr:\n\t/* Free command manager itself */\n\tkfree(cmgr);\n}\n\nstruct bnx2fc_cmd *bnx2fc_elstm_alloc(struct bnx2fc_rport *tgt, int type)\n{\n\tstruct fcoe_port *port = tgt->port;\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct bnx2fc_cmd_mgr *cmd_mgr = interface->hba->cmd_mgr;\n\tstruct bnx2fc_cmd *io_req;\n\tstruct list_head *listp;\n\tstruct io_bdt *bd_tbl;\n\tint index = RESERVE_FREE_LIST_INDEX;\n\tu32 free_sqes;\n\tu32 max_sqes;\n\tu16 xid;\n\n\tmax_sqes = tgt->max_sqes;\n\tswitch (type) {\n\tcase BNX2FC_TASK_MGMT_CMD:\n\t\tmax_sqes = BNX2FC_TM_MAX_SQES;\n\t\tbreak;\n\tcase BNX2FC_ELS:\n\t\tmax_sqes = BNX2FC_ELS_MAX_SQES;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * NOTE: Free list insertions and deletions are protected with\n\t * cmgr lock\n\t */\n\tspin_lock_bh(&cmd_mgr->free_list_lock[index]);\n\tfree_sqes = atomic_read(&tgt->free_sqes);\n\tif ((list_empty(&(cmd_mgr->free_list[index]))) ||\n\t    (tgt->num_active_ios.counter  >= max_sqes) ||\n\t    (free_sqes + max_sqes <= BNX2FC_SQ_WQES_MAX)) {\n\t\tBNX2FC_TGT_DBG(tgt, \"No free els_tm cmds available \"\n\t\t\t\"ios(%d):sqes(%d)\\n\",\n\t\t\ttgt->num_active_ios.counter, tgt->max_sqes);\n\t\tif (list_empty(&(cmd_mgr->free_list[index])))\n\t\t\tprintk(KERN_ERR PFX \"elstm_alloc: list_empty\\n\");\n\t\tspin_unlock_bh(&cmd_mgr->free_list_lock[index]);\n\t\treturn NULL;\n\t}\n\n\tlistp = (struct list_head *)\n\t\t\tcmd_mgr->free_list[index].next;\n\tlist_del_init(listp);\n\tio_req = (struct bnx2fc_cmd *) listp;\n\txid = io_req->xid;\n\tcmd_mgr->cmds[xid] = io_req;\n\tatomic_inc(&tgt->num_active_ios);\n\tatomic_dec(&tgt->free_sqes);\n\tspin_unlock_bh(&cmd_mgr->free_list_lock[index]);\n\n\tINIT_LIST_HEAD(&io_req->link);\n\n\tio_req->port = port;\n\tio_req->cmd_mgr = cmd_mgr;\n\tio_req->req_flags = 0;\n\tio_req->cmd_type = type;\n\n\t/* Bind io_bdt for this io_req */\n\t/* Have a static link between io_req and io_bdt_pool */\n\tbd_tbl = io_req->bd_tbl = cmd_mgr->io_bdt_pool[xid];\n\tbd_tbl->io_req = io_req;\n\n\t/* Hold the io_req  against deletion */\n\tkref_init(&io_req->refcount);\n\treturn io_req;\n}\n\nstruct bnx2fc_cmd *bnx2fc_cmd_alloc(struct bnx2fc_rport *tgt)\n{\n\tstruct fcoe_port *port = tgt->port;\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct bnx2fc_cmd_mgr *cmd_mgr = interface->hba->cmd_mgr;\n\tstruct bnx2fc_cmd *io_req;\n\tstruct list_head *listp;\n\tstruct io_bdt *bd_tbl;\n\tu32 free_sqes;\n\tu32 max_sqes;\n\tu16 xid;\n\tint index = raw_smp_processor_id();\n\n\tmax_sqes = BNX2FC_SCSI_MAX_SQES;\n\t/*\n\t * NOTE: Free list insertions and deletions are protected with\n\t * cmgr lock\n\t */\n\tspin_lock_bh(&cmd_mgr->free_list_lock[index]);\n\tfree_sqes = atomic_read(&tgt->free_sqes);\n\tif ((list_empty(&cmd_mgr->free_list[index])) ||\n\t    (tgt->num_active_ios.counter  >= max_sqes) ||\n\t    (free_sqes + max_sqes <= BNX2FC_SQ_WQES_MAX)) {\n\t\tspin_unlock_bh(&cmd_mgr->free_list_lock[index]);\n\t\treturn NULL;\n\t}\n\n\tlistp = (struct list_head *)\n\t\tcmd_mgr->free_list[index].next;\n\tlist_del_init(listp);\n\tio_req = (struct bnx2fc_cmd *) listp;\n\txid = io_req->xid;\n\tcmd_mgr->cmds[xid] = io_req;\n\tatomic_inc(&tgt->num_active_ios);\n\tatomic_dec(&tgt->free_sqes);\n\tspin_unlock_bh(&cmd_mgr->free_list_lock[index]);\n\n\tINIT_LIST_HEAD(&io_req->link);\n\n\tio_req->port = port;\n\tio_req->cmd_mgr = cmd_mgr;\n\tio_req->req_flags = 0;\n\n\t/* Bind io_bdt for this io_req */\n\t/* Have a static link between io_req and io_bdt_pool */\n\tbd_tbl = io_req->bd_tbl = cmd_mgr->io_bdt_pool[xid];\n\tbd_tbl->io_req = io_req;\n\n\t/* Hold the io_req  against deletion */\n\tkref_init(&io_req->refcount);\n\treturn io_req;\n}\n\nvoid bnx2fc_cmd_release(struct kref *ref)\n{\n\tstruct bnx2fc_cmd *io_req = container_of(ref,\n\t\t\t\t\t\tstruct bnx2fc_cmd, refcount);\n\tstruct bnx2fc_cmd_mgr *cmd_mgr = io_req->cmd_mgr;\n\tint index;\n\n\tif (io_req->cmd_type == BNX2FC_SCSI_CMD)\n\t\tindex = io_req->xid % num_possible_cpus();\n\telse\n\t\tindex = RESERVE_FREE_LIST_INDEX;\n\n\n\tspin_lock_bh(&cmd_mgr->free_list_lock[index]);\n\tif (io_req->cmd_type != BNX2FC_SCSI_CMD)\n\t\tbnx2fc_free_mp_resc(io_req);\n\tcmd_mgr->cmds[io_req->xid] = NULL;\n\t/* Delete IO from retire queue */\n\tlist_del_init(&io_req->link);\n\t/* Add it to the free list */\n\tlist_add(&io_req->link,\n\t\t\t&cmd_mgr->free_list[index]);\n\tatomic_dec(&io_req->tgt->num_active_ios);\n\tspin_unlock_bh(&cmd_mgr->free_list_lock[index]);\n\n}\n\nstatic void bnx2fc_free_mp_resc(struct bnx2fc_cmd *io_req)\n{\n\tstruct bnx2fc_mp_req *mp_req = &(io_req->mp_req);\n\tstruct bnx2fc_interface *interface = io_req->port->priv;\n\tstruct bnx2fc_hba *hba = interface->hba;\n\tsize_t sz = sizeof(struct fcoe_bd_ctx);\n\n\t/* clear tm flags */\n\tmp_req->tm_flags = 0;\n\tif (mp_req->mp_req_bd) {\n\t\tdma_free_coherent(&hba->pcidev->dev, sz,\n\t\t\t\t     mp_req->mp_req_bd,\n\t\t\t\t     mp_req->mp_req_bd_dma);\n\t\tmp_req->mp_req_bd = NULL;\n\t}\n\tif (mp_req->mp_resp_bd) {\n\t\tdma_free_coherent(&hba->pcidev->dev, sz,\n\t\t\t\t     mp_req->mp_resp_bd,\n\t\t\t\t     mp_req->mp_resp_bd_dma);\n\t\tmp_req->mp_resp_bd = NULL;\n\t}\n\tif (mp_req->req_buf) {\n\t\tdma_free_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\n\t\t\t\t     mp_req->req_buf,\n\t\t\t\t     mp_req->req_buf_dma);\n\t\tmp_req->req_buf = NULL;\n\t}\n\tif (mp_req->resp_buf) {\n\t\tdma_free_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\n\t\t\t\t     mp_req->resp_buf,\n\t\t\t\t     mp_req->resp_buf_dma);\n\t\tmp_req->resp_buf = NULL;\n\t}\n}\n\nint bnx2fc_init_mp_req(struct bnx2fc_cmd *io_req)\n{\n\tstruct bnx2fc_mp_req *mp_req;\n\tstruct fcoe_bd_ctx *mp_req_bd;\n\tstruct fcoe_bd_ctx *mp_resp_bd;\n\tstruct bnx2fc_interface *interface = io_req->port->priv;\n\tstruct bnx2fc_hba *hba = interface->hba;\n\tdma_addr_t addr;\n\tsize_t sz;\n\n\tmp_req = (struct bnx2fc_mp_req *)&(io_req->mp_req);\n\tmemset(mp_req, 0, sizeof(struct bnx2fc_mp_req));\n\n\tif (io_req->cmd_type != BNX2FC_ELS) {\n\t\tmp_req->req_len = sizeof(struct fcp_cmnd);\n\t\tio_req->data_xfer_len = mp_req->req_len;\n\t} else\n\t\tmp_req->req_len = io_req->data_xfer_len;\n\n\tmp_req->req_buf = dma_alloc_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\n\t\t\t\t\t     &mp_req->req_buf_dma,\n\t\t\t\t\t     GFP_ATOMIC);\n\tif (!mp_req->req_buf) {\n\t\tprintk(KERN_ERR PFX \"unable to alloc MP req buffer\\n\");\n\t\tbnx2fc_free_mp_resc(io_req);\n\t\treturn FAILED;\n\t}\n\n\tmp_req->resp_buf = dma_alloc_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\n\t\t\t\t\t      &mp_req->resp_buf_dma,\n\t\t\t\t\t      GFP_ATOMIC);\n\tif (!mp_req->resp_buf) {\n\t\tprintk(KERN_ERR PFX \"unable to alloc TM resp buffer\\n\");\n\t\tbnx2fc_free_mp_resc(io_req);\n\t\treturn FAILED;\n\t}\n\tmemset(mp_req->req_buf, 0, CNIC_PAGE_SIZE);\n\tmemset(mp_req->resp_buf, 0, CNIC_PAGE_SIZE);\n\n\t/* Allocate and map mp_req_bd and mp_resp_bd */\n\tsz = sizeof(struct fcoe_bd_ctx);\n\tmp_req->mp_req_bd = dma_alloc_coherent(&hba->pcidev->dev, sz,\n\t\t\t\t\t\t &mp_req->mp_req_bd_dma,\n\t\t\t\t\t\t GFP_ATOMIC);\n\tif (!mp_req->mp_req_bd) {\n\t\tprintk(KERN_ERR PFX \"unable to alloc MP req bd\\n\");\n\t\tbnx2fc_free_mp_resc(io_req);\n\t\treturn FAILED;\n\t}\n\tmp_req->mp_resp_bd = dma_alloc_coherent(&hba->pcidev->dev, sz,\n\t\t\t\t\t\t &mp_req->mp_resp_bd_dma,\n\t\t\t\t\t\t GFP_ATOMIC);\n\tif (!mp_req->mp_resp_bd) {\n\t\tprintk(KERN_ERR PFX \"unable to alloc MP resp bd\\n\");\n\t\tbnx2fc_free_mp_resc(io_req);\n\t\treturn FAILED;\n\t}\n\t/* Fill bd table */\n\taddr = mp_req->req_buf_dma;\n\tmp_req_bd = mp_req->mp_req_bd;\n\tmp_req_bd->buf_addr_lo = (u32)addr & 0xffffffff;\n\tmp_req_bd->buf_addr_hi = (u32)((u64)addr >> 32);\n\tmp_req_bd->buf_len = CNIC_PAGE_SIZE;\n\tmp_req_bd->flags = 0;\n\n\t/*\n\t * MP buffer is either a task mgmt command or an ELS.\n\t * So the assumption is that it consumes a single bd\n\t * entry in the bd table\n\t */\n\tmp_resp_bd = mp_req->mp_resp_bd;\n\taddr = mp_req->resp_buf_dma;\n\tmp_resp_bd->buf_addr_lo = (u32)addr & 0xffffffff;\n\tmp_resp_bd->buf_addr_hi = (u32)((u64)addr >> 32);\n\tmp_resp_bd->buf_len = CNIC_PAGE_SIZE;\n\tmp_resp_bd->flags = 0;\n\n\treturn SUCCESS;\n}\n\nstatic int bnx2fc_initiate_tmf(struct scsi_cmnd *sc_cmd, u8 tm_flags)\n{\n\tstruct fc_lport *lport;\n\tstruct fc_rport *rport;\n\tstruct fc_rport_libfc_priv *rp;\n\tstruct fcoe_port *port;\n\tstruct bnx2fc_interface *interface;\n\tstruct bnx2fc_rport *tgt;\n\tstruct bnx2fc_cmd *io_req;\n\tstruct bnx2fc_mp_req *tm_req;\n\tstruct fcoe_task_ctx_entry *task;\n\tstruct fcoe_task_ctx_entry *task_page;\n\tstruct Scsi_Host *host = sc_cmd->device->host;\n\tstruct fc_frame_header *fc_hdr;\n\tstruct fcp_cmnd *fcp_cmnd;\n\tint task_idx, index;\n\tint rc = SUCCESS;\n\tu16 xid;\n\tu32 sid, did;\n\tunsigned long start = jiffies;\n\n\tlport = shost_priv(host);\n\trport = starget_to_rport(scsi_target(sc_cmd->device));\n\tport = lport_priv(lport);\n\tinterface = port->priv;\n\n\tif (rport == NULL) {\n\t\tprintk(KERN_ERR PFX \"device_reset: rport is NULL\\n\");\n\t\trc = FAILED;\n\t\tgoto tmf_err;\n\t}\n\trp = rport->dd_data;\n\n\trc = fc_block_scsi_eh(sc_cmd);\n\tif (rc)\n\t\treturn rc;\n\n\tif (lport->state != LPORT_ST_READY || !(lport->link_up)) {\n\t\tprintk(KERN_ERR PFX \"device_reset: link is not ready\\n\");\n\t\trc = FAILED;\n\t\tgoto tmf_err;\n\t}\n\t/* rport and tgt are allocated together, so tgt should be non-NULL */\n\ttgt = (struct bnx2fc_rport *)&rp[1];\n\n\tif (!(test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags))) {\n\t\tprintk(KERN_ERR PFX \"device_reset: tgt not offloaded\\n\");\n\t\trc = FAILED;\n\t\tgoto tmf_err;\n\t}\nretry_tmf:\n\tio_req = bnx2fc_elstm_alloc(tgt, BNX2FC_TASK_MGMT_CMD);\n\tif (!io_req) {\n\t\tif (time_after(jiffies, start + HZ)) {\n\t\t\tprintk(KERN_ERR PFX \"tmf: Failed TMF\");\n\t\t\trc = FAILED;\n\t\t\tgoto tmf_err;\n\t\t}\n\t\tmsleep(20);\n\t\tgoto retry_tmf;\n\t}\n\t/* Initialize rest of io_req fields */\n\tio_req->sc_cmd = sc_cmd;\n\tio_req->port = port;\n\tio_req->tgt = tgt;\n\n\ttm_req = (struct bnx2fc_mp_req *)&(io_req->mp_req);\n\n\trc = bnx2fc_init_mp_req(io_req);\n\tif (rc == FAILED) {\n\t\tprintk(KERN_ERR PFX \"Task mgmt MP request init failed\\n\");\n\t\tspin_lock_bh(&tgt->tgt_lock);\n\t\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t\tgoto tmf_err;\n\t}\n\n\t/* Set TM flags */\n\tio_req->io_req_flags = 0;\n\ttm_req->tm_flags = tm_flags;\n\n\t/* Fill FCP_CMND */\n\tbnx2fc_build_fcp_cmnd(io_req, (struct fcp_cmnd *)tm_req->req_buf);\n\tfcp_cmnd = (struct fcp_cmnd *)tm_req->req_buf;\n\tmemset(fcp_cmnd->fc_cdb, 0,  sc_cmd->cmd_len);\n\tfcp_cmnd->fc_dl = 0;\n\n\t/* Fill FC header */\n\tfc_hdr = &(tm_req->req_fc_hdr);\n\tsid = tgt->sid;\n\tdid = rport->port_id;\n\t__fc_fill_fc_hdr(fc_hdr, FC_RCTL_DD_UNSOL_CMD, did, sid,\n\t\t\t   FC_TYPE_FCP, FC_FC_FIRST_SEQ | FC_FC_END_SEQ |\n\t\t\t   FC_FC_SEQ_INIT, 0);\n\t/* Obtain exchange id */\n\txid = io_req->xid;\n\n\tBNX2FC_TGT_DBG(tgt, \"Initiate TMF - xid = 0x%x\\n\", xid);\n\ttask_idx = xid/BNX2FC_TASKS_PER_PAGE;\n\tindex = xid % BNX2FC_TASKS_PER_PAGE;\n\n\t/* Initialize task context for this IO request */\n\ttask_page = (struct fcoe_task_ctx_entry *)\n\t\t\tinterface->hba->task_ctx[task_idx];\n\ttask = &(task_page[index]);\n\tbnx2fc_init_mp_task(io_req, task);\n\n\tbnx2fc_priv(sc_cmd)->io_req = io_req;\n\n\t/* Obtain free SQ entry */\n\tspin_lock_bh(&tgt->tgt_lock);\n\tbnx2fc_add_2_sq(tgt, xid);\n\n\t/* Enqueue the io_req to active_tm_queue */\n\tio_req->on_tmf_queue = 1;\n\tlist_add_tail(&io_req->link, &tgt->active_tm_queue);\n\n\tinit_completion(&io_req->abts_done);\n\tio_req->wait_for_abts_comp = 1;\n\n\t/* Ring doorbell */\n\tbnx2fc_ring_doorbell(tgt);\n\tspin_unlock_bh(&tgt->tgt_lock);\n\n\trc = wait_for_completion_timeout(&io_req->abts_done,\n\t\t\t\t\t interface->tm_timeout * HZ);\n\tspin_lock_bh(&tgt->tgt_lock);\n\n\tio_req->wait_for_abts_comp = 0;\n\tif (!(test_bit(BNX2FC_FLAG_TM_COMPL, &io_req->req_flags))) {\n\t\tset_bit(BNX2FC_FLAG_TM_TIMEOUT, &io_req->req_flags);\n\t\tif (io_req->on_tmf_queue) {\n\t\t\tlist_del_init(&io_req->link);\n\t\t\tio_req->on_tmf_queue = 0;\n\t\t}\n\t\tio_req->wait_for_cleanup_comp = 1;\n\t\tinit_completion(&io_req->cleanup_done);\n\t\tbnx2fc_initiate_cleanup(io_req);\n\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t\trc = wait_for_completion_timeout(&io_req->cleanup_done,\n\t\t\t\t\t\t BNX2FC_FW_TIMEOUT);\n\t\tspin_lock_bh(&tgt->tgt_lock);\n\t\tio_req->wait_for_cleanup_comp = 0;\n\t\tif (!rc)\n\t\t\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\t}\n\n\tspin_unlock_bh(&tgt->tgt_lock);\n\n\tif (!rc) {\n\t\tBNX2FC_TGT_DBG(tgt, \"task mgmt command failed...\\n\");\n\t\trc = FAILED;\n\t} else {\n\t\tBNX2FC_TGT_DBG(tgt, \"task mgmt command success...\\n\");\n\t\trc = SUCCESS;\n\t}\ntmf_err:\n\treturn rc;\n}\n\nint bnx2fc_initiate_abts(struct bnx2fc_cmd *io_req)\n{\n\tstruct fc_lport *lport;\n\tstruct bnx2fc_rport *tgt = io_req->tgt;\n\tstruct fc_rport *rport = tgt->rport;\n\tstruct fc_rport_priv *rdata = tgt->rdata;\n\tstruct bnx2fc_interface *interface;\n\tstruct fcoe_port *port;\n\tstruct bnx2fc_cmd *abts_io_req;\n\tstruct fcoe_task_ctx_entry *task;\n\tstruct fcoe_task_ctx_entry *task_page;\n\tstruct fc_frame_header *fc_hdr;\n\tstruct bnx2fc_mp_req *abts_req;\n\tint task_idx, index;\n\tu32 sid, did;\n\tu16 xid;\n\tint rc = SUCCESS;\n\tu32 r_a_tov = rdata->r_a_tov;\n\n\t/* called with tgt_lock held */\n\tBNX2FC_IO_DBG(io_req, \"Entered bnx2fc_initiate_abts\\n\");\n\n\tport = io_req->port;\n\tinterface = port->priv;\n\tlport = port->lport;\n\n\tif (!test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags)) {\n\t\tprintk(KERN_ERR PFX \"initiate_abts: tgt not offloaded\\n\");\n\t\trc = FAILED;\n\t\tgoto abts_err;\n\t}\n\n\tif (rport == NULL) {\n\t\tprintk(KERN_ERR PFX \"initiate_abts: rport is NULL\\n\");\n\t\trc = FAILED;\n\t\tgoto abts_err;\n\t}\n\n\tif (lport->state != LPORT_ST_READY || !(lport->link_up)) {\n\t\tprintk(KERN_ERR PFX \"initiate_abts: link is not ready\\n\");\n\t\trc = FAILED;\n\t\tgoto abts_err;\n\t}\n\n\tabts_io_req = bnx2fc_elstm_alloc(tgt, BNX2FC_ABTS);\n\tif (!abts_io_req) {\n\t\tprintk(KERN_ERR PFX \"abts: couldn't allocate cmd\\n\");\n\t\trc = FAILED;\n\t\tgoto abts_err;\n\t}\n\n\t/* Initialize rest of io_req fields */\n\tabts_io_req->sc_cmd = NULL;\n\tabts_io_req->port = port;\n\tabts_io_req->tgt = tgt;\n\tabts_io_req->data_xfer_len = 0; /* No data transfer for ABTS */\n\n\tabts_req = (struct bnx2fc_mp_req *)&(abts_io_req->mp_req);\n\tmemset(abts_req, 0, sizeof(struct bnx2fc_mp_req));\n\n\t/* Fill FC header */\n\tfc_hdr = &(abts_req->req_fc_hdr);\n\n\t/* Obtain oxid and rxid for the original exchange to be aborted */\n\tfc_hdr->fh_ox_id = htons(io_req->xid);\n\tfc_hdr->fh_rx_id = htons(io_req->task->rxwr_txrd.var_ctx.rx_id);\n\n\tsid = tgt->sid;\n\tdid = rport->port_id;\n\n\t__fc_fill_fc_hdr(fc_hdr, FC_RCTL_BA_ABTS, did, sid,\n\t\t\t   FC_TYPE_BLS, FC_FC_FIRST_SEQ | FC_FC_END_SEQ |\n\t\t\t   FC_FC_SEQ_INIT, 0);\n\n\txid = abts_io_req->xid;\n\tBNX2FC_IO_DBG(abts_io_req, \"ABTS io_req\\n\");\n\ttask_idx = xid/BNX2FC_TASKS_PER_PAGE;\n\tindex = xid % BNX2FC_TASKS_PER_PAGE;\n\n\t/* Initialize task context for this IO request */\n\ttask_page = (struct fcoe_task_ctx_entry *)\n\t\t\tinterface->hba->task_ctx[task_idx];\n\ttask = &(task_page[index]);\n\tbnx2fc_init_mp_task(abts_io_req, task);\n\n\t/*\n\t * ABTS task is a temporary task that will be cleaned up\n\t * irrespective of ABTS response. We need to start the timer\n\t * for the original exchange, as the CQE is posted for the original\n\t * IO request.\n\t *\n\t * Timer for ABTS is started only when it is originated by a\n\t * TM request. For the ABTS issued as part of ULP timeout,\n\t * scsi-ml maintains the timers.\n\t */\n\n\t/* if (test_bit(BNX2FC_FLAG_ISSUE_ABTS, &io_req->req_flags))*/\n\tbnx2fc_cmd_timer_set(io_req, 2 * r_a_tov);\n\n\t/* Obtain free SQ entry */\n\tbnx2fc_add_2_sq(tgt, xid);\n\n\t/* Ring doorbell */\n\tbnx2fc_ring_doorbell(tgt);\n\nabts_err:\n\treturn rc;\n}\n\nint bnx2fc_initiate_seq_cleanup(struct bnx2fc_cmd *orig_io_req, u32 offset,\n\t\t\t\tenum fc_rctl r_ctl)\n{\n\tstruct bnx2fc_rport *tgt = orig_io_req->tgt;\n\tstruct bnx2fc_interface *interface;\n\tstruct fcoe_port *port;\n\tstruct bnx2fc_cmd *seq_clnp_req;\n\tstruct fcoe_task_ctx_entry *task;\n\tstruct fcoe_task_ctx_entry *task_page;\n\tstruct bnx2fc_els_cb_arg *cb_arg = NULL;\n\tint task_idx, index;\n\tu16 xid;\n\tint rc = 0;\n\n\tBNX2FC_IO_DBG(orig_io_req, \"bnx2fc_initiate_seq_cleanup xid = 0x%x\\n\",\n\t\t   orig_io_req->xid);\n\tkref_get(&orig_io_req->refcount);\n\n\tport = orig_io_req->port;\n\tinterface = port->priv;\n\n\tcb_arg = kzalloc(sizeof(struct bnx2fc_els_cb_arg), GFP_ATOMIC);\n\tif (!cb_arg) {\n\t\tprintk(KERN_ERR PFX \"Unable to alloc cb_arg for seq clnup\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto cleanup_err;\n\t}\n\n\tseq_clnp_req = bnx2fc_elstm_alloc(tgt, BNX2FC_SEQ_CLEANUP);\n\tif (!seq_clnp_req) {\n\t\tprintk(KERN_ERR PFX \"cleanup: couldn't allocate cmd\\n\");\n\t\trc = -ENOMEM;\n\t\tkfree(cb_arg);\n\t\tgoto cleanup_err;\n\t}\n\t/* Initialize rest of io_req fields */\n\tseq_clnp_req->sc_cmd = NULL;\n\tseq_clnp_req->port = port;\n\tseq_clnp_req->tgt = tgt;\n\tseq_clnp_req->data_xfer_len = 0; /* No data transfer for cleanup */\n\n\txid = seq_clnp_req->xid;\n\n\ttask_idx = xid/BNX2FC_TASKS_PER_PAGE;\n\tindex = xid % BNX2FC_TASKS_PER_PAGE;\n\n\t/* Initialize task context for this IO request */\n\ttask_page = (struct fcoe_task_ctx_entry *)\n\t\t     interface->hba->task_ctx[task_idx];\n\ttask = &(task_page[index]);\n\tcb_arg->aborted_io_req = orig_io_req;\n\tcb_arg->io_req = seq_clnp_req;\n\tcb_arg->r_ctl = r_ctl;\n\tcb_arg->offset = offset;\n\tseq_clnp_req->cb_arg = cb_arg;\n\n\tprintk(KERN_ERR PFX \"call init_seq_cleanup_task\\n\");\n\tbnx2fc_init_seq_cleanup_task(seq_clnp_req, task, orig_io_req, offset);\n\n\t/* Obtain free SQ entry */\n\tbnx2fc_add_2_sq(tgt, xid);\n\n\t/* Ring doorbell */\n\tbnx2fc_ring_doorbell(tgt);\ncleanup_err:\n\treturn rc;\n}\n\nint bnx2fc_initiate_cleanup(struct bnx2fc_cmd *io_req)\n{\n\tstruct bnx2fc_rport *tgt = io_req->tgt;\n\tstruct bnx2fc_interface *interface;\n\tstruct fcoe_port *port;\n\tstruct bnx2fc_cmd *cleanup_io_req;\n\tstruct fcoe_task_ctx_entry *task;\n\tstruct fcoe_task_ctx_entry *task_page;\n\tint task_idx, index;\n\tu16 xid, orig_xid;\n\tint rc = 0;\n\n\t/* ASSUMPTION: called with tgt_lock held */\n\tBNX2FC_IO_DBG(io_req, \"Entered bnx2fc_initiate_cleanup\\n\");\n\n\tport = io_req->port;\n\tinterface = port->priv;\n\n\tcleanup_io_req = bnx2fc_elstm_alloc(tgt, BNX2FC_CLEANUP);\n\tif (!cleanup_io_req) {\n\t\tprintk(KERN_ERR PFX \"cleanup: couldn't allocate cmd\\n\");\n\t\trc = -1;\n\t\tgoto cleanup_err;\n\t}\n\n\t/* Initialize rest of io_req fields */\n\tcleanup_io_req->sc_cmd = NULL;\n\tcleanup_io_req->port = port;\n\tcleanup_io_req->tgt = tgt;\n\tcleanup_io_req->data_xfer_len = 0; /* No data transfer for cleanup */\n\n\txid = cleanup_io_req->xid;\n\n\ttask_idx = xid/BNX2FC_TASKS_PER_PAGE;\n\tindex = xid % BNX2FC_TASKS_PER_PAGE;\n\n\t/* Initialize task context for this IO request */\n\ttask_page = (struct fcoe_task_ctx_entry *)\n\t\t\tinterface->hba->task_ctx[task_idx];\n\ttask = &(task_page[index]);\n\torig_xid = io_req->xid;\n\n\tBNX2FC_IO_DBG(io_req, \"CLEANUP io_req xid = 0x%x\\n\", xid);\n\n\tbnx2fc_init_cleanup_task(cleanup_io_req, task, orig_xid);\n\n\t/* Obtain free SQ entry */\n\tbnx2fc_add_2_sq(tgt, xid);\n\n\t/* Set flag that cleanup request is pending with the firmware */\n\tset_bit(BNX2FC_FLAG_ISSUE_CLEANUP_REQ, &io_req->req_flags);\n\n\t/* Ring doorbell */\n\tbnx2fc_ring_doorbell(tgt);\n\ncleanup_err:\n\treturn rc;\n}\n\n/**\n * bnx2fc_eh_target_reset: Reset a target\n *\n * @sc_cmd:\tSCSI command\n *\n * Set from SCSI host template to send task mgmt command to the target\n *\tand wait for the response\n */\nint bnx2fc_eh_target_reset(struct scsi_cmnd *sc_cmd)\n{\n\treturn bnx2fc_initiate_tmf(sc_cmd, FCP_TMF_TGT_RESET);\n}\n\n/**\n * bnx2fc_eh_device_reset - Reset a single LUN\n *\n * @sc_cmd:\tSCSI command\n *\n * Set from SCSI host template to send task mgmt command to the target\n *\tand wait for the response\n */\nint bnx2fc_eh_device_reset(struct scsi_cmnd *sc_cmd)\n{\n\treturn bnx2fc_initiate_tmf(sc_cmd, FCP_TMF_LUN_RESET);\n}\n\nstatic int bnx2fc_abts_cleanup(struct bnx2fc_cmd *io_req)\n\t__must_hold(&tgt->tgt_lock)\n{\n\tstruct bnx2fc_rport *tgt = io_req->tgt;\n\tunsigned int time_left;\n\n\tinit_completion(&io_req->cleanup_done);\n\tio_req->wait_for_cleanup_comp = 1;\n\tbnx2fc_initiate_cleanup(io_req);\n\n\tspin_unlock_bh(&tgt->tgt_lock);\n\n\t/*\n\t * Can't wait forever on cleanup response lest we let the SCSI error\n\t * handler wait forever\n\t */\n\ttime_left = wait_for_completion_timeout(&io_req->cleanup_done,\n\t\t\t\t\t\tBNX2FC_FW_TIMEOUT);\n\tif (!time_left) {\n\t\tBNX2FC_IO_DBG(io_req, \"%s(): Wait for cleanup timed out.\\n\",\n\t\t\t      __func__);\n\n\t\t \n\t\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\t}\n\n\tspin_lock_bh(&tgt->tgt_lock);\n\tio_req->wait_for_cleanup_comp = 0;\n\treturn SUCCESS;\n}\n\n \nint bnx2fc_eh_abort(struct scsi_cmnd *sc_cmd)\n{\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sc_cmd->device));\n\tstruct fc_rport_libfc_priv *rp = rport->dd_data;\n\tstruct bnx2fc_cmd *io_req;\n\tstruct fc_lport *lport;\n\tstruct bnx2fc_rport *tgt;\n\tint rc;\n\tunsigned int time_left;\n\n\trc = fc_block_scsi_eh(sc_cmd);\n\tif (rc)\n\t\treturn rc;\n\n\tlport = shost_priv(sc_cmd->device->host);\n\tif ((lport->state != LPORT_ST_READY) || !(lport->link_up)) {\n\t\tprintk(KERN_ERR PFX \"eh_abort: link not ready\\n\");\n\t\treturn FAILED;\n\t}\n\n\ttgt = (struct bnx2fc_rport *)&rp[1];\n\n\tBNX2FC_TGT_DBG(tgt, \"Entered bnx2fc_eh_abort\\n\");\n\n\tspin_lock_bh(&tgt->tgt_lock);\n\tio_req = bnx2fc_priv(sc_cmd)->io_req;\n\tif (!io_req) {\n\t\t \n\t\tprintk(KERN_ERR PFX \"eh_abort: io_req is NULL\\n\");\n\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t\treturn SUCCESS;\n\t}\n\tBNX2FC_IO_DBG(io_req, \"eh_abort - refcnt = %d\\n\",\n\t\t      kref_read(&io_req->refcount));\n\n\t \n\tkref_get(&io_req->refcount);\n\n\tBUG_ON(tgt != io_req->tgt);\n\n\t \n\t \n\tif (tgt->flush_in_prog) {\n\t\tprintk(KERN_ERR PFX \"eh_abort: io_req (xid = 0x%x) \"\n\t\t\t\"flush in progress\\n\", io_req->xid);\n\t\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t\treturn SUCCESS;\n\t}\n\n\tif (io_req->on_active_queue == 0) {\n\t\tprintk(KERN_ERR PFX \"eh_abort: io_req (xid = 0x%x) \"\n\t\t\t\t\"not on active_q\\n\", io_req->xid);\n\t\t \n\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t\treturn FAILED;\n\t}\n\n\t \n\tlist_del_init(&io_req->link);\n\tio_req->on_active_queue = 0;\n\t \n\tlist_add_tail(&io_req->link, &tgt->io_retire_queue);\n\n\tinit_completion(&io_req->abts_done);\n\tinit_completion(&io_req->cleanup_done);\n\n\tif (test_and_set_bit(BNX2FC_FLAG_ISSUE_ABTS, &io_req->req_flags)) {\n\t\tprintk(KERN_ERR PFX \"eh_abort: io_req (xid = 0x%x) \"\n\t\t\t\t\"already in abts processing\\n\", io_req->xid);\n\t\tif (cancel_delayed_work(&io_req->timeout_work))\n\t\t\tkref_put(&io_req->refcount,\n\t\t\t\t bnx2fc_cmd_release);  \n\t\t \n\t\tbnx2fc_abts_cleanup(io_req);\n\t\t \n\t\tset_bit(BNX2FC_FLAG_IO_CLEANUP,\t&io_req->req_flags);\n\t\trc = FAILED;\n\t\tgoto done;\n\t}\n\n\t \n\tif (cancel_delayed_work(&io_req->timeout_work))\n\t\tkref_put(&io_req->refcount,\n\t\t\t bnx2fc_cmd_release);  \n\tset_bit(BNX2FC_FLAG_EH_ABORT, &io_req->req_flags);\n\tio_req->wait_for_abts_comp = 1;\n\trc = bnx2fc_initiate_abts(io_req);\n\tif (rc == FAILED) {\n\t\tio_req->wait_for_cleanup_comp = 1;\n\t\tbnx2fc_initiate_cleanup(io_req);\n\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t\twait_for_completion(&io_req->cleanup_done);\n\t\tspin_lock_bh(&tgt->tgt_lock);\n\t\tio_req->wait_for_cleanup_comp = 0;\n\t\tgoto done;\n\t}\n\tspin_unlock_bh(&tgt->tgt_lock);\n\n\t \n\ttime_left = wait_for_completion_timeout(&io_req->abts_done,\n\t\t\t\t\tmsecs_to_jiffies(2 * rp->r_a_tov + 1));\n\tif (time_left)\n\t\tBNX2FC_IO_DBG(io_req,\n\t\t\t      \"Timed out in eh_abort waiting for abts_done\");\n\n\tspin_lock_bh(&tgt->tgt_lock);\n\tio_req->wait_for_abts_comp = 0;\n\tif (test_bit(BNX2FC_FLAG_IO_COMPL, &io_req->req_flags)) {\n\t\tBNX2FC_IO_DBG(io_req, \"IO completed in a different context\\n\");\n\t\trc = SUCCESS;\n\t} else if (!(test_and_set_bit(BNX2FC_FLAG_ABTS_DONE,\n\t\t\t\t      &io_req->req_flags))) {\n\t\t \n\t\tprintk(KERN_ERR PFX \"abort failed, xid = 0x%x\\n\",\n\t\t       io_req->xid);\n\t\t \n\t\trc = bnx2fc_abts_cleanup(io_req);\n\t\tgoto done;\n\t} else {\n\t\t \n\t\tBNX2FC_IO_DBG(io_req, \"abort succeeded\\n\");\n\t\trc = SUCCESS;\n\t\tbnx2fc_scsi_done(io_req, DID_ABORT);\n\t\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\t}\ndone:\n\t \n\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\tspin_unlock_bh(&tgt->tgt_lock);\n\treturn rc;\n}\n\nvoid bnx2fc_process_seq_cleanup_compl(struct bnx2fc_cmd *seq_clnp_req,\n\t\t\t\t      struct fcoe_task_ctx_entry *task,\n\t\t\t\t      u8 rx_state)\n{\n\tstruct bnx2fc_els_cb_arg *cb_arg = seq_clnp_req->cb_arg;\n\tstruct bnx2fc_cmd *orig_io_req = cb_arg->aborted_io_req;\n\tu32 offset = cb_arg->offset;\n\tenum fc_rctl r_ctl = cb_arg->r_ctl;\n\tint rc = 0;\n\tstruct bnx2fc_rport *tgt = orig_io_req->tgt;\n\n\tBNX2FC_IO_DBG(orig_io_req, \"Entered process_cleanup_compl xid = 0x%x\"\n\t\t\t      \"cmd_type = %d\\n\",\n\t\t   seq_clnp_req->xid, seq_clnp_req->cmd_type);\n\n\tif (rx_state == FCOE_TASK_RX_STATE_IGNORED_SEQUENCE_CLEANUP) {\n\t\tprintk(KERN_ERR PFX \"seq cleanup ignored - xid = 0x%x\\n\",\n\t\t\tseq_clnp_req->xid);\n\t\tgoto free_cb_arg;\n\t}\n\n\tspin_unlock_bh(&tgt->tgt_lock);\n\trc = bnx2fc_send_srr(orig_io_req, offset, r_ctl);\n\tspin_lock_bh(&tgt->tgt_lock);\n\n\tif (rc)\n\t\tprintk(KERN_ERR PFX \"clnup_compl: Unable to send SRR\"\n\t\t\t\" IO will abort\\n\");\n\tseq_clnp_req->cb_arg = NULL;\n\tkref_put(&orig_io_req->refcount, bnx2fc_cmd_release);\nfree_cb_arg:\n\tkfree(cb_arg);\n\treturn;\n}\n\nvoid bnx2fc_process_cleanup_compl(struct bnx2fc_cmd *io_req,\n\t\t\t\t  struct fcoe_task_ctx_entry *task,\n\t\t\t\t  u8 num_rq)\n{\n\tBNX2FC_IO_DBG(io_req, \"Entered process_cleanup_compl \"\n\t\t\t      \"refcnt = %d, cmd_type = %d\\n\",\n\t\t   kref_read(&io_req->refcount), io_req->cmd_type);\n\t \n\tif (!test_and_clear_bit(BNX2FC_FLAG_ISSUE_CLEANUP_REQ,\n\t\t\t\t&io_req->req_flags))\n\t\treturn;\n\t \n\tif (test_bit(BNX2FC_FLAG_ISSUE_ABTS, &io_req->req_flags) &&\n\t    !test_bit(BNX2FC_FLAG_ABTS_DONE, &io_req->req_flags)) {\n\t\tset_bit(BNX2FC_FLAG_ABTS_DONE, &io_req->req_flags);\n\t\tif (io_req->wait_for_abts_comp)\n\t\t\tcomplete(&io_req->abts_done);\n\t}\n\n\tbnx2fc_scsi_done(io_req, DID_ERROR);\n\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\tif (io_req->wait_for_cleanup_comp)\n\t\tcomplete(&io_req->cleanup_done);\n}\n\nvoid bnx2fc_process_abts_compl(struct bnx2fc_cmd *io_req,\n\t\t\t       struct fcoe_task_ctx_entry *task,\n\t\t\t       u8 num_rq)\n{\n\tu32 r_ctl;\n\tu32 r_a_tov = FC_DEF_R_A_TOV;\n\tu8 issue_rrq = 0;\n\tstruct bnx2fc_rport *tgt = io_req->tgt;\n\n\tBNX2FC_IO_DBG(io_req, \"Entered process_abts_compl xid = 0x%x\"\n\t\t\t      \"refcnt = %d, cmd_type = %d\\n\",\n\t\t   io_req->xid,\n\t\t   kref_read(&io_req->refcount), io_req->cmd_type);\n\n\tif (test_and_set_bit(BNX2FC_FLAG_ABTS_DONE,\n\t\t\t\t       &io_req->req_flags)) {\n\t\tBNX2FC_IO_DBG(io_req, \"Timer context finished processing\"\n\t\t\t\t\" this io\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (test_bit(BNX2FC_FLAG_ISSUE_CLEANUP_REQ, &io_req->req_flags)) {\n\t\tclear_bit(BNX2FC_FLAG_ISSUE_CLEANUP_REQ, &io_req->req_flags);\n\t\tif (io_req->wait_for_cleanup_comp)\n\t\t\tcomplete(&io_req->cleanup_done);\n\t}\n\n\t \n\tif (test_and_set_bit(BNX2FC_FLAG_IO_CLEANUP,\n\t\t\t\t&io_req->req_flags))\n\t\tgoto io_compl;\n\n\t \n\tif (test_bit(BNX2FC_FLAG_ISSUE_ABTS, &io_req->req_flags))\n\t\tif (cancel_delayed_work(&io_req->timeout_work))\n\t\t\tkref_put(&io_req->refcount,\n\t\t\t\t bnx2fc_cmd_release);  \n\n\tr_ctl = (u8)task->rxwr_only.union_ctx.comp_info.abts_rsp.r_ctl;\n\n\tswitch (r_ctl) {\n\tcase FC_RCTL_BA_ACC:\n\t\t \n\t\tBNX2FC_IO_DBG(io_req, \"ABTS response - ACC Send RRQ\\n\");\n\t\tissue_rrq = 1;\n\t\tbreak;\n\n\tcase FC_RCTL_BA_RJT:\n\t\tBNX2FC_IO_DBG(io_req, \"ABTS response - RJT\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR PFX \"Unknown ABTS response\\n\");\n\t\tbreak;\n\t}\n\n\tif (issue_rrq) {\n\t\tBNX2FC_IO_DBG(io_req, \"Issue RRQ after R_A_TOV\\n\");\n\t\tset_bit(BNX2FC_FLAG_ISSUE_RRQ, &io_req->req_flags);\n\t}\n\tset_bit(BNX2FC_FLAG_RETIRE_OXID, &io_req->req_flags);\n\tbnx2fc_cmd_timer_set(io_req, r_a_tov);\n\nio_compl:\n\tif (io_req->wait_for_abts_comp) {\n\t\tif (test_and_clear_bit(BNX2FC_FLAG_EH_ABORT,\n\t\t\t\t       &io_req->req_flags))\n\t\t\tcomplete(&io_req->abts_done);\n\t} else {\n\t\t \n\n\t\tif (io_req->on_active_queue) {\n\t\t\tlist_del_init(&io_req->link);\n\t\t\tio_req->on_active_queue = 0;\n\t\t\t \n\t\t\tlist_add_tail(&io_req->link, &tgt->io_retire_queue);\n\t\t}\n\t\tbnx2fc_scsi_done(io_req, DID_ERROR);\n\t\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\t}\n}\n\nstatic void bnx2fc_lun_reset_cmpl(struct bnx2fc_cmd *io_req)\n{\n\tstruct scsi_cmnd *sc_cmd = io_req->sc_cmd;\n\tstruct bnx2fc_rport *tgt = io_req->tgt;\n\tstruct bnx2fc_cmd *cmd, *tmp;\n\tu64 tm_lun = sc_cmd->device->lun;\n\tu64 lun;\n\tint rc = 0;\n\n\t \n\tBNX2FC_IO_DBG(io_req, \"Entered bnx2fc_lun_reset_cmpl\\n\");\n\t \n\tlist_for_each_entry_safe(cmd, tmp, &tgt->active_cmd_queue, link) {\n\t\tBNX2FC_TGT_DBG(tgt, \"LUN RST cmpl: scan for pending IOs\\n\");\n\t\tlun = cmd->sc_cmd->device->lun;\n\t\tif (lun == tm_lun) {\n\t\t\t \n\t\t\tif (!test_and_set_bit(BNX2FC_FLAG_ISSUE_ABTS,\n\t\t\t\t\t      &cmd->req_flags)) {\n\t\t\t\t \n\t\t\t\tif (cancel_delayed_work(&io_req->timeout_work))\n\t\t\t\t\tkref_put(&io_req->refcount,\n\t\t\t\t\t\t bnx2fc_cmd_release);\n\t\t\t\t\t\t\t \n\t\t\t\trc = bnx2fc_initiate_abts(cmd);\n\t\t\t\t \n\t\t\t\tWARN_ON(rc != SUCCESS);\n\t\t\t} else\n\t\t\t\tprintk(KERN_ERR PFX \"lun_rst: abts already in\"\n\t\t\t\t\t\" progress for this IO 0x%x\\n\",\n\t\t\t\t\tcmd->xid);\n\t\t}\n\t}\n}\n\nstatic void bnx2fc_tgt_reset_cmpl(struct bnx2fc_cmd *io_req)\n{\n\tstruct bnx2fc_rport *tgt = io_req->tgt;\n\tstruct bnx2fc_cmd *cmd, *tmp;\n\tint rc = 0;\n\n\t \n\tBNX2FC_IO_DBG(io_req, \"Entered bnx2fc_tgt_reset_cmpl\\n\");\n\t \n\tlist_for_each_entry_safe(cmd, tmp, &tgt->active_cmd_queue, link) {\n\t\tBNX2FC_TGT_DBG(tgt, \"TGT RST cmpl: scan for pending IOs\\n\");\n\t\t \n\t\tif (!test_and_set_bit(BNX2FC_FLAG_ISSUE_ABTS,\n\t\t\t\t\t\t\t&cmd->req_flags)) {\n\t\t\t \n\t\t\tif (cancel_delayed_work(&io_req->timeout_work))\n\t\t\t\tkref_put(&io_req->refcount,\n\t\t\t\t\t bnx2fc_cmd_release);  \n\t\t\trc = bnx2fc_initiate_abts(cmd);\n\t\t\t \n\t\t\tWARN_ON(rc != SUCCESS);\n\n\t\t} else\n\t\t\tprintk(KERN_ERR PFX \"tgt_rst: abts already in progress\"\n\t\t\t\t\" for this IO 0x%x\\n\", cmd->xid);\n\t}\n}\n\nvoid bnx2fc_process_tm_compl(struct bnx2fc_cmd *io_req,\n\t\t\t     struct fcoe_task_ctx_entry *task, u8 num_rq,\n\t\t\t\t  unsigned char *rq_data)\n{\n\tstruct bnx2fc_mp_req *tm_req;\n\tstruct fc_frame_header *fc_hdr;\n\tstruct scsi_cmnd *sc_cmd = io_req->sc_cmd;\n\tu64 *hdr;\n\tu64 *temp_hdr;\n\tvoid *rsp_buf;\n\n\t \n\tBNX2FC_IO_DBG(io_req, \"Entered process_tm_compl\\n\");\n\n\tif (!(test_bit(BNX2FC_FLAG_TM_TIMEOUT, &io_req->req_flags)))\n\t\tset_bit(BNX2FC_FLAG_TM_COMPL, &io_req->req_flags);\n\telse {\n\t\t \n\t\treturn;\n\t}\n\n\ttm_req = &(io_req->mp_req);\n\tfc_hdr = &(tm_req->resp_fc_hdr);\n\thdr = (u64 *)fc_hdr;\n\ttemp_hdr = (u64 *)\n\t\t&task->rxwr_only.union_ctx.comp_info.mp_rsp.fc_hdr;\n\thdr[0] = cpu_to_be64(temp_hdr[0]);\n\thdr[1] = cpu_to_be64(temp_hdr[1]);\n\thdr[2] = cpu_to_be64(temp_hdr[2]);\n\n\ttm_req->resp_len =\n\t\ttask->rxwr_only.union_ctx.comp_info.mp_rsp.mp_payload_len;\n\n\trsp_buf = tm_req->resp_buf;\n\n\tif (fc_hdr->fh_r_ctl == FC_RCTL_DD_CMD_STATUS) {\n\t\tbnx2fc_parse_fcp_rsp(io_req,\n\t\t\t\t     (struct fcoe_fcp_rsp_payload *)\n\t\t\t\t     rsp_buf, num_rq, rq_data);\n\t\tif (io_req->fcp_rsp_code == 0) {\n\t\t\t \n\t\t\tif (tm_req->tm_flags & FCP_TMF_LUN_RESET)\n\t\t\t\tbnx2fc_lun_reset_cmpl(io_req);\n\t\t\telse if (tm_req->tm_flags & FCP_TMF_TGT_RESET)\n\t\t\t\tbnx2fc_tgt_reset_cmpl(io_req);\n\t\t}\n\t} else {\n\t\tprintk(KERN_ERR PFX \"tmf's fc_hdr r_ctl = 0x%x\\n\",\n\t\t\tfc_hdr->fh_r_ctl);\n\t}\n\tif (!bnx2fc_priv(sc_cmd)->io_req) {\n\t\tprintk(KERN_ERR PFX \"tm_compl: io_req is NULL\\n\");\n\t\treturn;\n\t}\n\tswitch (io_req->fcp_status) {\n\tcase FC_GOOD:\n\t\tif (io_req->cdb_status == 0) {\n\t\t\t \n\t\t\tsc_cmd->result = DID_OK << 16;\n\t\t} else {\n\t\t\t \n\t\t\tsc_cmd->result = (DID_OK << 16) | io_req->cdb_status;\n\t\t}\n\t\tif (io_req->fcp_resid)\n\t\t\tscsi_set_resid(sc_cmd, io_req->fcp_resid);\n\t\tbreak;\n\n\tdefault:\n\t\tBNX2FC_IO_DBG(io_req, \"process_tm_compl: fcp_status = %d\\n\",\n\t\t\t   io_req->fcp_status);\n\t\tbreak;\n\t}\n\n\tsc_cmd = io_req->sc_cmd;\n\tio_req->sc_cmd = NULL;\n\n\t \n\tif (io_req->on_tmf_queue) {\n\n\t\tlist_del_init(&io_req->link);\n\t\tio_req->on_tmf_queue = 0;\n\t} else {\n\n\t\tprintk(KERN_ERR PFX \"Command not on active_cmd_queue!\\n\");\n\t\treturn;\n\t}\n\n\tbnx2fc_priv(sc_cmd)->io_req = NULL;\n\tscsi_done(sc_cmd);\n\n\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\tif (io_req->wait_for_abts_comp) {\n\t\tBNX2FC_IO_DBG(io_req, \"tm_compl - wake up the waiter\\n\");\n\t\tcomplete(&io_req->abts_done);\n\t}\n}\n\nstatic int bnx2fc_split_bd(struct bnx2fc_cmd *io_req, u64 addr, int sg_len,\n\t\t\t   int bd_index)\n{\n\tstruct fcoe_bd_ctx *bd = io_req->bd_tbl->bd_tbl;\n\tint frag_size, sg_frags;\n\n\tsg_frags = 0;\n\twhile (sg_len) {\n\t\tif (sg_len >= BNX2FC_BD_SPLIT_SZ)\n\t\t\tfrag_size = BNX2FC_BD_SPLIT_SZ;\n\t\telse\n\t\t\tfrag_size = sg_len;\n\t\tbd[bd_index + sg_frags].buf_addr_lo = addr & 0xffffffff;\n\t\tbd[bd_index + sg_frags].buf_addr_hi  = addr >> 32;\n\t\tbd[bd_index + sg_frags].buf_len = (u16)frag_size;\n\t\tbd[bd_index + sg_frags].flags = 0;\n\n\t\taddr += (u64) frag_size;\n\t\tsg_frags++;\n\t\tsg_len -= frag_size;\n\t}\n\treturn sg_frags;\n\n}\n\nstatic int bnx2fc_map_sg(struct bnx2fc_cmd *io_req)\n{\n\tstruct bnx2fc_interface *interface = io_req->port->priv;\n\tstruct bnx2fc_hba *hba = interface->hba;\n\tstruct scsi_cmnd *sc = io_req->sc_cmd;\n\tstruct fcoe_bd_ctx *bd = io_req->bd_tbl->bd_tbl;\n\tstruct scatterlist *sg;\n\tint byte_count = 0;\n\tint sg_count = 0;\n\tint bd_count = 0;\n\tint sg_frags;\n\tunsigned int sg_len;\n\tu64 addr;\n\tint i;\n\n\tWARN_ON(scsi_sg_count(sc) > BNX2FC_MAX_BDS_PER_CMD);\n\t \n\tsg_count = dma_map_sg(&hba->pcidev->dev, scsi_sglist(sc),\n\t\t\t      scsi_sg_count(sc), sc->sc_data_direction);\n\tscsi_for_each_sg(sc, sg, sg_count, i) {\n\t\tsg_len = sg_dma_len(sg);\n\t\taddr = sg_dma_address(sg);\n\t\tif (sg_len > BNX2FC_MAX_BD_LEN) {\n\t\t\tsg_frags = bnx2fc_split_bd(io_req, addr, sg_len,\n\t\t\t\t\t\t   bd_count);\n\t\t} else {\n\n\t\t\tsg_frags = 1;\n\t\t\tbd[bd_count].buf_addr_lo = addr & 0xffffffff;\n\t\t\tbd[bd_count].buf_addr_hi  = addr >> 32;\n\t\t\tbd[bd_count].buf_len = (u16)sg_len;\n\t\t\tbd[bd_count].flags = 0;\n\t\t}\n\t\tbd_count += sg_frags;\n\t\tbyte_count += sg_len;\n\t}\n\tif (byte_count != scsi_bufflen(sc))\n\t\tprintk(KERN_ERR PFX \"byte_count = %d != scsi_bufflen = %d, \"\n\t\t\t\"task_id = 0x%x\\n\", byte_count, scsi_bufflen(sc),\n\t\t\tio_req->xid);\n\treturn bd_count;\n}\n\nstatic int bnx2fc_build_bd_list_from_sg(struct bnx2fc_cmd *io_req)\n{\n\tstruct scsi_cmnd *sc = io_req->sc_cmd;\n\tstruct fcoe_bd_ctx *bd = io_req->bd_tbl->bd_tbl;\n\tint bd_count;\n\n\tif (scsi_sg_count(sc)) {\n\t\tbd_count = bnx2fc_map_sg(io_req);\n\t\tif (bd_count == 0)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tbd_count = 0;\n\t\tbd[0].buf_addr_lo = bd[0].buf_addr_hi = 0;\n\t\tbd[0].buf_len = bd[0].flags = 0;\n\t}\n\tio_req->bd_tbl->bd_valid = bd_count;\n\n\t \n\tif (bd_count > BNX2FC_FW_MAX_BDS_PER_CMD) {\n\t\tpr_err(\"bd_count = %d exceeded FW supported max BD(255), task_id = 0x%x\\n\",\n\t\t       bd_count, io_req->xid);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void bnx2fc_unmap_sg_list(struct bnx2fc_cmd *io_req)\n{\n\tstruct scsi_cmnd *sc = io_req->sc_cmd;\n\tstruct bnx2fc_interface *interface = io_req->port->priv;\n\tstruct bnx2fc_hba *hba = interface->hba;\n\n\t \n\tif (io_req->bd_tbl->bd_valid && sc && scsi_sg_count(sc)) {\n\t\tdma_unmap_sg(&hba->pcidev->dev, scsi_sglist(sc),\n\t\t    scsi_sg_count(sc), sc->sc_data_direction);\n\t\tio_req->bd_tbl->bd_valid = 0;\n\t}\n}\n\nvoid bnx2fc_build_fcp_cmnd(struct bnx2fc_cmd *io_req,\n\t\t\t\t  struct fcp_cmnd *fcp_cmnd)\n{\n\tstruct scsi_cmnd *sc_cmd = io_req->sc_cmd;\n\n\tmemset(fcp_cmnd, 0, sizeof(struct fcp_cmnd));\n\n\tint_to_scsilun(sc_cmd->device->lun, &fcp_cmnd->fc_lun);\n\n\tfcp_cmnd->fc_dl = htonl(io_req->data_xfer_len);\n\tmemcpy(fcp_cmnd->fc_cdb, sc_cmd->cmnd, sc_cmd->cmd_len);\n\n\tfcp_cmnd->fc_cmdref = 0;\n\tfcp_cmnd->fc_pri_ta = 0;\n\tfcp_cmnd->fc_tm_flags = io_req->mp_req.tm_flags;\n\tfcp_cmnd->fc_flags = io_req->io_req_flags;\n\tfcp_cmnd->fc_pri_ta = FCP_PTA_SIMPLE;\n}\n\nstatic void bnx2fc_parse_fcp_rsp(struct bnx2fc_cmd *io_req,\n\t\t\t\t struct fcoe_fcp_rsp_payload *fcp_rsp,\n\t\t\t\t u8 num_rq, unsigned char *rq_data)\n{\n\tstruct scsi_cmnd *sc_cmd = io_req->sc_cmd;\n\tu8 rsp_flags = fcp_rsp->fcp_flags.flags;\n\tu32 rq_buff_len = 0;\n\tint fcp_sns_len = 0;\n\tint fcp_rsp_len = 0;\n\n\tio_req->fcp_status = FC_GOOD;\n\tio_req->fcp_resid = 0;\n\tif (rsp_flags & (FCOE_FCP_RSP_FLAGS_FCP_RESID_OVER |\n\t    FCOE_FCP_RSP_FLAGS_FCP_RESID_UNDER))\n\t\tio_req->fcp_resid = fcp_rsp->fcp_resid;\n\n\tio_req->scsi_comp_flags = rsp_flags;\n\tio_req->cdb_status = fcp_rsp->scsi_status_code;\n\n\t \n\tif (num_rq) {\n\n\t\t \n\n\t\tif (rsp_flags &\n\t\t    FCOE_FCP_RSP_FLAGS_FCP_RSP_LEN_VALID) {\n\t\t\tfcp_rsp_len = rq_buff_len\n\t\t\t\t\t= fcp_rsp->fcp_rsp_len;\n\t\t}\n\n\t\tif (rsp_flags &\n\t\t    FCOE_FCP_RSP_FLAGS_FCP_SNS_LEN_VALID) {\n\t\t\tfcp_sns_len = fcp_rsp->fcp_sns_len;\n\t\t\trq_buff_len += fcp_rsp->fcp_sns_len;\n\t\t}\n\n\t\tio_req->fcp_rsp_len = fcp_rsp_len;\n\t\tio_req->fcp_sns_len = fcp_sns_len;\n\n\t\tif (rq_buff_len > num_rq * BNX2FC_RQ_BUF_SZ) {\n\t\t\t \n\t\t\tprintk(KERN_ERR PFX \"invalid sns length %d\\n\",\n\t\t\t\trq_buff_len);\n\t\t\t \n\t\t\trq_buff_len =  num_rq * BNX2FC_RQ_BUF_SZ;\n\t\t}\n\n\t\t \n\t\tif ((fcp_rsp_len == 4) || (fcp_rsp_len == 8)) {\n\t\t\t \n\t\t\tio_req->fcp_rsp_code = rq_data[3];\n\t\t\tBNX2FC_IO_DBG(io_req, \"fcp_rsp_code = %d\\n\",\n\t\t\t\tio_req->fcp_rsp_code);\n\t\t}\n\n\t\t \n\t\trq_data += fcp_rsp_len;\n\n\t\tif (fcp_sns_len > SCSI_SENSE_BUFFERSIZE) {\n\t\t\tprintk(KERN_ERR PFX \"Truncating sense buffer\\n\");\n\t\t\tfcp_sns_len = SCSI_SENSE_BUFFERSIZE;\n\t\t}\n\n\t\tmemset(sc_cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\n\t\tif (fcp_sns_len)\n\t\t\tmemcpy(sc_cmd->sense_buffer, rq_data, fcp_sns_len);\n\n\t}\n}\n\n \nint bnx2fc_queuecommand(struct Scsi_Host *host,\n\t\t\tstruct scsi_cmnd *sc_cmd)\n{\n\tstruct fc_lport *lport = shost_priv(host);\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sc_cmd->device));\n\tstruct fc_rport_libfc_priv *rp = rport->dd_data;\n\tstruct bnx2fc_rport *tgt;\n\tstruct bnx2fc_cmd *io_req;\n\tint rc = 0;\n\tint rval;\n\n\trval = fc_remote_port_chkready(rport);\n\tif (rval) {\n\t\tsc_cmd->result = rval;\n\t\tscsi_done(sc_cmd);\n\t\treturn 0;\n\t}\n\n\tif ((lport->state != LPORT_ST_READY) || !(lport->link_up)) {\n\t\trc = SCSI_MLQUEUE_HOST_BUSY;\n\t\tgoto exit_qcmd;\n\t}\n\n\t \n\ttgt = (struct bnx2fc_rport *)&rp[1];\n\n\tif (!test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags)) {\n\t\t \n\t\trc = SCSI_MLQUEUE_TARGET_BUSY;\n\t\tgoto exit_qcmd;\n\t}\n\tif (tgt->retry_delay_timestamp) {\n\t\tif (time_after(jiffies, tgt->retry_delay_timestamp)) {\n\t\t\ttgt->retry_delay_timestamp = 0;\n\t\t} else {\n\t\t\t \n\t\t\trc = SCSI_MLQUEUE_TARGET_BUSY;\n\t\t\tgoto exit_qcmd;\n\t\t}\n\t}\n\n\tspin_lock_bh(&tgt->tgt_lock);\n\n\tio_req = bnx2fc_cmd_alloc(tgt);\n\tif (!io_req) {\n\t\trc = SCSI_MLQUEUE_HOST_BUSY;\n\t\tgoto exit_qcmd_tgtlock;\n\t}\n\tio_req->sc_cmd = sc_cmd;\n\n\tif (bnx2fc_post_io_req(tgt, io_req)) {\n\t\tprintk(KERN_ERR PFX \"Unable to post io_req\\n\");\n\t\trc = SCSI_MLQUEUE_HOST_BUSY;\n\t\tgoto exit_qcmd_tgtlock;\n\t}\n\nexit_qcmd_tgtlock:\n\tspin_unlock_bh(&tgt->tgt_lock);\nexit_qcmd:\n\treturn rc;\n}\n\nvoid bnx2fc_process_scsi_cmd_compl(struct bnx2fc_cmd *io_req,\n\t\t\t\t   struct fcoe_task_ctx_entry *task,\n\t\t\t\t   u8 num_rq, unsigned char *rq_data)\n{\n\tstruct fcoe_fcp_rsp_payload *fcp_rsp;\n\tstruct bnx2fc_rport *tgt = io_req->tgt;\n\tstruct scsi_cmnd *sc_cmd;\n\tu16 scope = 0, qualifier = 0;\n\n\t \n\n\tif (test_and_set_bit(BNX2FC_FLAG_IO_COMPL, &io_req->req_flags)) {\n\t\t \n\t\tBNX2FC_IO_DBG(io_req, \"Timer context finished processing \"\n\t\t\t   \"this scsi cmd\\n\");\n\t\tif (test_and_clear_bit(BNX2FC_FLAG_IO_CLEANUP,\n\t\t\t\t       &io_req->req_flags)) {\n\t\t\tBNX2FC_IO_DBG(io_req,\n\t\t\t\t      \"Actual completion after cleanup request cleaning up\\n\");\n\t\t\tbnx2fc_process_cleanup_compl(io_req, task, num_rq);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (cancel_delayed_work(&io_req->timeout_work))\n\t\tkref_put(&io_req->refcount,\n\t\t\t bnx2fc_cmd_release);  \n\n\tsc_cmd = io_req->sc_cmd;\n\tif (sc_cmd == NULL) {\n\t\tprintk(KERN_ERR PFX \"scsi_cmd_compl - sc_cmd is NULL\\n\");\n\t\treturn;\n\t}\n\n\t \n\tfcp_rsp = (struct fcoe_fcp_rsp_payload *)\n\t\t   &(task->rxwr_only.union_ctx.comp_info.fcp_rsp.payload);\n\n\t \n\tbnx2fc_parse_fcp_rsp(io_req, fcp_rsp, num_rq, rq_data);\n\n\tif (!bnx2fc_priv(sc_cmd)->io_req) {\n\t\tprintk(KERN_ERR PFX \"io_req is NULL\\n\");\n\t\treturn;\n\t}\n\n\tif (io_req->on_active_queue) {\n\t\tlist_del_init(&io_req->link);\n\t\tio_req->on_active_queue = 0;\n\t\t \n\t\tlist_add_tail(&io_req->link, &tgt->io_retire_queue);\n\t} else {\n\t\t \n\t\tBNX2FC_IO_DBG(io_req, \"xid not on active_cmd_queue\\n\");\n\t\tif (io_req->wait_for_abts_comp)\n\t\t\tif (test_and_clear_bit(BNX2FC_FLAG_EH_ABORT,\n\t\t\t\t\t       &io_req->req_flags))\n\t\t\t\tcomplete(&io_req->abts_done);\n\t}\n\n\tbnx2fc_unmap_sg_list(io_req);\n\tio_req->sc_cmd = NULL;\n\n\tswitch (io_req->fcp_status) {\n\tcase FC_GOOD:\n\t\tif (io_req->cdb_status == 0) {\n\t\t\t \n\t\t\tsc_cmd->result = DID_OK << 16;\n\t\t} else {\n\t\t\t \n\t\t\tBNX2FC_IO_DBG(io_req, \"scsi_cmpl: cdb_status = %d\"\n\t\t\t\t \" fcp_resid = 0x%x\\n\",\n\t\t\t\tio_req->cdb_status, io_req->fcp_resid);\n\t\t\tsc_cmd->result = (DID_OK << 16) | io_req->cdb_status;\n\n\t\t\tif (io_req->cdb_status == SAM_STAT_TASK_SET_FULL ||\n\t\t\t    io_req->cdb_status == SAM_STAT_BUSY) {\n\t\t\t\t \n\t\t\t\tif (fcp_rsp->retry_delay_timer) {\n\t\t\t\t\t \n\t\t\t\t\tscope = fcp_rsp->retry_delay_timer\n\t\t\t\t\t\t& 0xC000;\n\t\t\t\t\t \n\t\t\t\t\tqualifier = fcp_rsp->retry_delay_timer\n\t\t\t\t\t\t& 0x3FFF;\n\t\t\t\t}\n\t\t\t\tif (scope > 0 && qualifier > 0 &&\n\t\t\t\t\tqualifier <= 0x3FEF) {\n\t\t\t\t\t \n\t\t\t\t\ttgt->retry_delay_timestamp = jiffies +\n\t\t\t\t\t\t(qualifier * HZ / 10);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (io_req->fcp_resid)\n\t\t\tscsi_set_resid(sc_cmd, io_req->fcp_resid);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR PFX \"scsi_cmd_compl: fcp_status = %d\\n\",\n\t\t\tio_req->fcp_status);\n\t\tbreak;\n\t}\n\tbnx2fc_priv(sc_cmd)->io_req = NULL;\n\tscsi_done(sc_cmd);\n\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n}\n\nint bnx2fc_post_io_req(struct bnx2fc_rport *tgt,\n\t\t\t       struct bnx2fc_cmd *io_req)\n{\n\tstruct fcoe_task_ctx_entry *task;\n\tstruct fcoe_task_ctx_entry *task_page;\n\tstruct scsi_cmnd *sc_cmd = io_req->sc_cmd;\n\tstruct fcoe_port *port = tgt->port;\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct bnx2fc_hba *hba = interface->hba;\n\tstruct fc_lport *lport = port->lport;\n\tint task_idx, index;\n\tu16 xid;\n\n\t \n\n\t \n\tio_req->cmd_type = BNX2FC_SCSI_CMD;\n\tio_req->port = port;\n\tio_req->tgt = tgt;\n\tio_req->data_xfer_len = scsi_bufflen(sc_cmd);\n\tbnx2fc_priv(sc_cmd)->io_req = io_req;\n\n\tif (sc_cmd->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tio_req->io_req_flags = BNX2FC_READ;\n\t\tthis_cpu_inc(lport->stats->InputRequests);\n\t\tthis_cpu_add(lport->stats->InputBytes, io_req->data_xfer_len);\n\t} else if (sc_cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tio_req->io_req_flags = BNX2FC_WRITE;\n\t\tthis_cpu_inc(lport->stats->OutputRequests);\n\t\tthis_cpu_add(lport->stats->OutputBytes, io_req->data_xfer_len);\n\t} else {\n\t\tio_req->io_req_flags = 0;\n\t\tthis_cpu_inc(lport->stats->ControlRequests);\n\t}\n\n\txid = io_req->xid;\n\n\t \n\tif (bnx2fc_build_bd_list_from_sg(io_req)) {\n\t\tprintk(KERN_ERR PFX \"BD list creation failed\\n\");\n\t\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\t\treturn -EAGAIN;\n\t}\n\n\ttask_idx = xid / BNX2FC_TASKS_PER_PAGE;\n\tindex = xid % BNX2FC_TASKS_PER_PAGE;\n\n\t \n\ttask_page = (struct fcoe_task_ctx_entry *) hba->task_ctx[task_idx];\n\ttask = &(task_page[index]);\n\tbnx2fc_init_task(io_req, task);\n\n\tif (tgt->flush_in_prog) {\n\t\tprintk(KERN_ERR PFX \"Flush in progress..Host Busy\\n\");\n\t\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags)) {\n\t\tprintk(KERN_ERR PFX \"Session not ready...post_io\\n\");\n\t\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (tgt->io_timeout)\n\t\tbnx2fc_cmd_timer_set(io_req, BNX2FC_IO_TIMEOUT);\n\t \n\tbnx2fc_add_2_sq(tgt, xid);\n\n\t \n\n\tio_req->on_active_queue = 1;\n\t \n\tlist_add_tail(&io_req->link, &tgt->active_cmd_queue);\n\n\t \n\tbnx2fc_ring_doorbell(tgt);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}