{
  "module_name": "bnx2fc_fcoe.c",
  "hash_id": "c69457beced517a017c33e086bf06321661131392931251d081ecda447cf722c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bnx2fc/bnx2fc_fcoe.c",
  "human_readable_source": " \n\n#include \"bnx2fc.h\"\n\n#include <linux/ethtool.h>\n\nstatic struct list_head adapter_list;\nstatic struct list_head if_list;\nstatic u32 adapter_count;\nstatic DEFINE_MUTEX(bnx2fc_dev_lock);\nDEFINE_PER_CPU(struct bnx2fc_percpu_s, bnx2fc_percpu);\n\n#define DRV_MODULE_NAME\t\t\"bnx2fc\"\n#define DRV_MODULE_VERSION\tBNX2FC_VERSION\n#define DRV_MODULE_RELDATE\t\"October 15, 2015\"\n\n\nstatic char version[] =\n\t\t\"QLogic FCoE Driver \" DRV_MODULE_NAME \\\n\t\t\" v\" DRV_MODULE_VERSION \" (\" DRV_MODULE_RELDATE \")\\n\";\n\n\nMODULE_AUTHOR(\"Bhanu Prakash Gollapudi <bprakash@broadcom.com>\");\nMODULE_DESCRIPTION(\"QLogic FCoE Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_MODULE_VERSION);\n\n#define BNX2FC_MAX_QUEUE_DEPTH\t256\n#define BNX2FC_MIN_QUEUE_DEPTH\t32\n#define FCOE_WORD_TO_BYTE  4\n\nstatic struct scsi_transport_template\t*bnx2fc_transport_template;\nstatic struct scsi_transport_template\t*bnx2fc_vport_xport_template;\n\nstruct workqueue_struct *bnx2fc_wq;\n\n \nstruct fcoe_percpu_s bnx2fc_global;\nstatic DEFINE_SPINLOCK(bnx2fc_global_lock);\n\nstatic struct cnic_ulp_ops bnx2fc_cnic_cb;\nstatic struct libfc_function_template bnx2fc_libfc_fcn_templ;\nstatic struct scsi_host_template bnx2fc_shost_template;\nstatic struct fc_function_template bnx2fc_transport_function;\nstatic struct fcoe_sysfs_function_template bnx2fc_fcoe_sysfs_templ;\nstatic struct fc_function_template bnx2fc_vport_xport_function;\nstatic int bnx2fc_create(struct net_device *netdev, enum fip_mode fip_mode);\nstatic void __bnx2fc_destroy(struct bnx2fc_interface *interface);\nstatic int bnx2fc_destroy(struct net_device *net_device);\nstatic int bnx2fc_enable(struct net_device *netdev);\nstatic int bnx2fc_disable(struct net_device *netdev);\n\n \nstatic int bnx2fc_ctlr_alloc(struct net_device *netdev);\nstatic int bnx2fc_ctlr_enabled(struct fcoe_ctlr_device *cdev);\n\nstatic void bnx2fc_recv_frame(struct sk_buff *skb);\n\nstatic void bnx2fc_start_disc(struct bnx2fc_interface *interface);\nstatic int bnx2fc_shost_config(struct fc_lport *lport, struct device *dev);\nstatic int bnx2fc_lport_config(struct fc_lport *lport);\nstatic int bnx2fc_em_config(struct fc_lport *lport, struct bnx2fc_hba *hba);\nstatic int bnx2fc_bind_adapter_devices(struct bnx2fc_hba *hba);\nstatic void bnx2fc_unbind_adapter_devices(struct bnx2fc_hba *hba);\nstatic int bnx2fc_bind_pcidev(struct bnx2fc_hba *hba);\nstatic void bnx2fc_unbind_pcidev(struct bnx2fc_hba *hba);\nstatic struct fc_lport *bnx2fc_if_create(struct bnx2fc_interface *interface,\n\t\t\t\t  struct device *parent, int npiv);\nstatic void bnx2fc_port_destroy(struct fcoe_port *port);\n\nstatic struct bnx2fc_hba *bnx2fc_hba_lookup(struct net_device *phys_dev);\nstatic struct bnx2fc_interface *bnx2fc_interface_lookup(struct net_device\n\t\t\t\t\t\t\t*phys_dev);\nstatic inline void bnx2fc_interface_put(struct bnx2fc_interface *interface);\nstatic struct bnx2fc_hba *bnx2fc_find_hba_for_cnic(struct cnic_dev *cnic);\n\nstatic int bnx2fc_fw_init(struct bnx2fc_hba *hba);\nstatic void bnx2fc_fw_destroy(struct bnx2fc_hba *hba);\n\nstatic void bnx2fc_port_shutdown(struct fc_lport *lport);\nstatic void bnx2fc_stop(struct bnx2fc_interface *interface);\nstatic int __init bnx2fc_mod_init(void);\nstatic void __exit bnx2fc_mod_exit(void);\n\nunsigned int bnx2fc_debug_level;\nmodule_param_named(debug_logging, bnx2fc_debug_level, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(debug_logging,\n\t\t\"Option to enable extended logging,\\n\"\n\t\t\"\\t\\tDefault is 0 - no logging.\\n\"\n\t\t\"\\t\\t0x01 - SCSI cmd error, cleanup.\\n\"\n\t\t\"\\t\\t0x02 - Session setup, cleanup, etc.\\n\"\n\t\t\"\\t\\t0x04 - lport events, link, mtu, etc.\\n\"\n\t\t\"\\t\\t0x08 - ELS logs.\\n\"\n\t\t\"\\t\\t0x10 - fcoe L2 fame related logs.\\n\"\n\t\t\"\\t\\t0xff - LOG all messages.\");\n\nstatic uint bnx2fc_devloss_tmo;\nmodule_param_named(devloss_tmo, bnx2fc_devloss_tmo, uint, S_IRUGO);\nMODULE_PARM_DESC(devloss_tmo, \" Change devloss_tmo for the remote ports \"\n\t\"attached via bnx2fc.\");\n\nstatic uint bnx2fc_max_luns = BNX2FC_MAX_LUN;\nmodule_param_named(max_luns, bnx2fc_max_luns, uint, S_IRUGO);\nMODULE_PARM_DESC(max_luns, \" Change the default max_lun per SCSI host. Default \"\n\t\"0xffff.\");\n\nstatic uint bnx2fc_queue_depth;\nmodule_param_named(queue_depth, bnx2fc_queue_depth, uint, S_IRUGO);\nMODULE_PARM_DESC(queue_depth, \" Change the default queue depth of SCSI devices \"\n\t\"attached via bnx2fc.\");\n\nstatic uint bnx2fc_log_fka;\nmodule_param_named(log_fka, bnx2fc_log_fka, uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(log_fka, \" Print message to kernel log when fcoe is \"\n\t\"initiating a FIP keep alive when debug logging is enabled.\");\n\nstatic inline struct net_device *bnx2fc_netdev(const struct fc_lport *lport)\n{\n\treturn ((struct bnx2fc_interface *)\n\t\t((struct fcoe_port *)lport_priv(lport))->priv)->netdev;\n}\n\nstatic void bnx2fc_fcf_get_vlan_id(struct fcoe_fcf_device *fcf_dev)\n{\n\tstruct fcoe_ctlr_device *ctlr_dev =\n\t\tfcoe_fcf_dev_to_ctlr_dev(fcf_dev);\n\tstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(ctlr_dev);\n\tstruct bnx2fc_interface *fcoe = fcoe_ctlr_priv(ctlr);\n\n\tfcf_dev->vlan_id = fcoe->vlan_id;\n}\n\nstatic void bnx2fc_clean_rx_queue(struct fc_lport *lp)\n{\n\tstruct fcoe_percpu_s *bg;\n\tstruct fcoe_rcv_info *fr;\n\tstruct sk_buff_head *list;\n\tstruct sk_buff *skb, *next;\n\n\tbg = &bnx2fc_global;\n\tspin_lock_bh(&bg->fcoe_rx_list.lock);\n\tlist = &bg->fcoe_rx_list;\n\tskb_queue_walk_safe(list, skb, next) {\n\t\tfr = fcoe_dev_from_skb(skb);\n\t\tif (fr->fr_dev == lp) {\n\t\t\t__skb_unlink(skb, list);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\tspin_unlock_bh(&bg->fcoe_rx_list.lock);\n}\n\nint bnx2fc_get_paged_crc_eof(struct sk_buff *skb, int tlen)\n{\n\tint rc;\n\tspin_lock(&bnx2fc_global_lock);\n\trc = fcoe_get_paged_crc_eof(skb, tlen, &bnx2fc_global);\n\tspin_unlock(&bnx2fc_global_lock);\n\n\treturn rc;\n}\n\nstatic void bnx2fc_abort_io(struct fc_lport *lport)\n{\n\t \n}\n\nstatic void bnx2fc_cleanup(struct fc_lport *lport)\n{\n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct bnx2fc_hba *hba = interface->hba;\n\tstruct bnx2fc_rport *tgt;\n\tint i;\n\n\tBNX2FC_MISC_DBG(\"Entered %s\\n\", __func__);\n\tmutex_lock(&hba->hba_mutex);\n\tspin_lock_bh(&hba->hba_lock);\n\tfor (i = 0; i < BNX2FC_NUM_MAX_SESS; i++) {\n\t\ttgt = hba->tgt_ofld_list[i];\n\t\tif (tgt) {\n\t\t\t \n\t\t\tif (tgt->port == port) {\n\t\t\t\tspin_unlock_bh(&hba->hba_lock);\n\t\t\t\tBNX2FC_TGT_DBG(tgt, \"flush/cleanup\\n\");\n\t\t\t\tbnx2fc_flush_active_ios(tgt);\n\t\t\t\tspin_lock_bh(&hba->hba_lock);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&hba->hba_lock);\n\tmutex_unlock(&hba->hba_mutex);\n}\n\nstatic int bnx2fc_xmit_l2_frame(struct bnx2fc_rport *tgt,\n\t\t\t     struct fc_frame *fp)\n{\n\tstruct fc_rport_priv *rdata = tgt->rdata;\n\tstruct fc_frame_header *fh;\n\tint rc = 0;\n\n\tfh = fc_frame_header_get(fp);\n\tBNX2FC_TGT_DBG(tgt, \"Xmit L2 frame rport = 0x%x, oxid = 0x%x, \"\n\t\t\t\"r_ctl = 0x%x\\n\", rdata->ids.port_id,\n\t\t\tntohs(fh->fh_ox_id), fh->fh_r_ctl);\n\tif ((fh->fh_type == FC_TYPE_ELS) &&\n\t    (fh->fh_r_ctl == FC_RCTL_ELS_REQ)) {\n\n\t\tswitch (fc_frame_payload_op(fp)) {\n\t\tcase ELS_ADISC:\n\t\t\trc = bnx2fc_send_adisc(tgt, fp);\n\t\t\tbreak;\n\t\tcase ELS_LOGO:\n\t\t\trc = bnx2fc_send_logo(tgt, fp);\n\t\t\tbreak;\n\t\tcase ELS_RLS:\n\t\t\trc = bnx2fc_send_rls(tgt, fp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if ((fh->fh_type ==  FC_TYPE_BLS) &&\n\t    (fh->fh_r_ctl == FC_RCTL_BA_ABTS))\n\t\tBNX2FC_TGT_DBG(tgt, \"ABTS frame\\n\");\n\telse {\n\t\tBNX2FC_TGT_DBG(tgt, \"Send L2 frame type 0x%x \"\n\t\t\t\t\"rctl 0x%x thru non-offload path\\n\",\n\t\t\t\tfh->fh_type, fh->fh_r_ctl);\n\t\treturn -ENODEV;\n\t}\n\tif (rc)\n\t\treturn -ENOMEM;\n\telse\n\t\treturn 0;\n}\n\n \nstatic int bnx2fc_xmit(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct ethhdr\t\t*eh;\n\tstruct fcoe_crc_eof\t*cp;\n\tstruct sk_buff\t\t*skb;\n\tstruct fc_frame_header\t*fh;\n\tstruct bnx2fc_interface\t*interface;\n\tstruct fcoe_ctlr        *ctlr;\n\tstruct bnx2fc_hba *hba;\n\tstruct fcoe_port\t*port;\n\tstruct fcoe_hdr\t\t*hp;\n\tstruct bnx2fc_rport\t*tgt;\n\tu8\t\t\tsof, eof;\n\tu32\t\t\tcrc;\n\tunsigned int\t\thlen, tlen, elen;\n\tint\t\t\twlen, rc = 0;\n\n\tport = (struct fcoe_port *)lport_priv(lport);\n\tinterface = port->priv;\n\tctlr = bnx2fc_to_ctlr(interface);\n\thba = interface->hba;\n\n\tfh = fc_frame_header_get(fp);\n\n\tskb = fp_skb(fp);\n\tif (!lport->link_up) {\n\t\tBNX2FC_HBA_DBG(lport, \"bnx2fc_xmit link down\\n\");\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(fh->fh_r_ctl == FC_RCTL_ELS_REQ)) {\n\t\tif (!ctlr->sel_fcf) {\n\t\t\tBNX2FC_HBA_DBG(lport, \"FCF not selected yet!\\n\");\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (fcoe_ctlr_els_send(ctlr, lport, skb))\n\t\t\treturn 0;\n\t}\n\n\tsof = fr_sof(fp);\n\teof = fr_eof(fp);\n\n\t \n\t \n\n\tspin_lock_bh(&hba->hba_lock);\n\ttgt = bnx2fc_tgt_lookup(port, ntoh24(fh->fh_d_id));\n\tif (tgt && (test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags))) {\n\t\t \n\t\tBNX2FC_HBA_DBG(lport, \"xmit: Frame is for offloaded session \"\n\t\t\t\t\"port_id = 0x%x\\n\", ntoh24(fh->fh_d_id));\n\t\tspin_unlock_bh(&hba->hba_lock);\n\t\trc = bnx2fc_xmit_l2_frame(tgt, fp);\n\t\tif (rc != -ENODEV) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\tspin_unlock_bh(&hba->hba_lock);\n\t}\n\n\telen = sizeof(struct ethhdr);\n\thlen = sizeof(struct fcoe_hdr);\n\ttlen = sizeof(struct fcoe_crc_eof);\n\twlen = (skb->len - tlen + sizeof(crc)) / FCOE_WORD_TO_BYTE;\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\tcrc = fcoe_fc_crc(fp);\n\n\t \n\tif (skb_is_nonlinear(skb)) {\n\t\tskb_frag_t *frag;\n\t\tif (bnx2fc_get_paged_crc_eof(skb, tlen)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfrag = &skb_shinfo(skb)->frags[skb_shinfo(skb)->nr_frags - 1];\n\t\tcp = kmap_atomic(skb_frag_page(frag)) + skb_frag_off(frag);\n\t} else {\n\t\tcp = skb_put(skb, tlen);\n\t}\n\n\tmemset(cp, 0, sizeof(*cp));\n\tcp->fcoe_eof = eof;\n\tcp->fcoe_crc32 = cpu_to_le32(~crc);\n\tif (skb_is_nonlinear(skb)) {\n\t\tkunmap_atomic(cp);\n\t\tcp = NULL;\n\t}\n\n\t \n\tskb_push(skb, elen + hlen);\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tskb->mac_len = elen;\n\tskb->protocol = htons(ETH_P_FCOE);\n\tskb->dev = interface->netdev;\n\n\t \n\teh = eth_hdr(skb);\n\teh->h_proto = htons(ETH_P_FCOE);\n\tif (ctlr->map_dest)\n\t\tfc_fcoe_set_mac(eh->h_dest, fh->fh_d_id);\n\telse\n\t\t \n\t\tmemcpy(eh->h_dest, ctlr->dest_addr, ETH_ALEN);\n\n\tif (unlikely(ctlr->flogi_oxid != FC_XID_UNKNOWN))\n\t\tmemcpy(eh->h_source, ctlr->ctl_src_addr, ETH_ALEN);\n\telse\n\t\tmemcpy(eh->h_source, port->data_src_addr, ETH_ALEN);\n\n\thp = (struct fcoe_hdr *)(eh + 1);\n\tmemset(hp, 0, sizeof(*hp));\n\tif (FC_FCOE_VER)\n\t\tFC_FCOE_ENCAPS_VER(hp, FC_FCOE_VER);\n\thp->fcoe_sof = sof;\n\n\t \n\tif (lport->seq_offload && fr_max_payload(fp)) {\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_FCOE;\n\t\tskb_shinfo(skb)->gso_size = fr_max_payload(fp);\n\t} else {\n\t\tskb_shinfo(skb)->gso_type = 0;\n\t\tskb_shinfo(skb)->gso_size = 0;\n\t}\n\n\t \n\tthis_cpu_inc(lport->stats->TxFrames);\n\tthis_cpu_add(lport->stats->TxWords, wlen);\n\n\t \n\tfr_dev(fp) = lport;\n\tif (port->fcoe_pending_queue.qlen)\n\t\tfcoe_check_wait_queue(lport, skb);\n\telse if (fcoe_start_io(skb))\n\t\tfcoe_check_wait_queue(lport, skb);\n\n\treturn 0;\n}\n\n \nstatic int bnx2fc_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\tstruct packet_type *ptype, struct net_device *olddev)\n{\n\tstruct fc_lport *lport;\n\tstruct bnx2fc_interface *interface;\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fcoe_rcv_info *fr;\n\tstruct fcoe_percpu_s *bg;\n\n\tinterface = container_of(ptype, struct bnx2fc_interface,\n\t\t\t\t fcoe_packet_type);\n\tctlr = bnx2fc_to_ctlr(interface);\n\tlport = ctlr->lp;\n\n\tif (unlikely(lport == NULL)) {\n\t\tprintk(KERN_ERR PFX \"bnx2fc_rcv: lport is NULL\\n\");\n\t\tgoto err;\n\t}\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -1;\n\n\tif (unlikely(eth_hdr(skb)->h_proto != htons(ETH_P_FCOE))) {\n\t\tprintk(KERN_ERR PFX \"bnx2fc_rcv: Wrong FC type frame\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tif (unlikely((skb->len < FCOE_MIN_FRAME) ||\n\t    !pskb_may_pull(skb, FCOE_HEADER_LEN)))\n\t\tgoto err;\n\n\tskb_set_transport_header(skb, sizeof(struct fcoe_hdr));\n\n\tfr = fcoe_dev_from_skb(skb);\n\tfr->fr_dev = lport;\n\n\tbg = &bnx2fc_global;\n\tspin_lock(&bg->fcoe_rx_list.lock);\n\n\t__skb_queue_tail(&bg->fcoe_rx_list, skb);\n\tif (bg->fcoe_rx_list.qlen == 1)\n\t\twake_up_process(bg->kthread);\n\n\tspin_unlock(&bg->fcoe_rx_list.lock);\n\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -1;\n}\n\nstatic int bnx2fc_l2_rcv_thread(void *arg)\n{\n\tstruct fcoe_percpu_s *bg = arg;\n\tstruct sk_buff *skb;\n\n\tset_user_nice(current, MIN_NICE);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tspin_lock_bh(&bg->fcoe_rx_list.lock);\n\t\twhile ((skb = __skb_dequeue(&bg->fcoe_rx_list)) != NULL) {\n\t\t\tspin_unlock_bh(&bg->fcoe_rx_list.lock);\n\t\t\tbnx2fc_recv_frame(skb);\n\t\t\tspin_lock_bh(&bg->fcoe_rx_list.lock);\n\t\t}\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_unlock_bh(&bg->fcoe_rx_list.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn 0;\n}\n\n\nstatic void bnx2fc_recv_frame(struct sk_buff *skb)\n{\n\tu64 crc_err;\n\tu32 fr_len, fr_crc;\n\tstruct fc_lport *lport;\n\tstruct fcoe_rcv_info *fr;\n\tstruct fc_frame_header *fh;\n\tstruct fcoe_crc_eof crc_eof;\n\tstruct fc_frame *fp;\n\tstruct fc_lport *vn_port;\n\tstruct fcoe_port *port, *phys_port;\n\tu8 *mac = NULL;\n\tu8 *dest_mac = NULL;\n\tstruct fcoe_hdr *hp;\n\tstruct bnx2fc_interface *interface;\n\tstruct fcoe_ctlr *ctlr;\n\n\tfr = fcoe_dev_from_skb(skb);\n\tlport = fr->fr_dev;\n\tif (unlikely(lport == NULL)) {\n\t\tprintk(KERN_ERR PFX \"Invalid lport struct\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (skb_is_nonlinear(skb))\n\t\tskb_linearize(skb);\n\tmac = eth_hdr(skb)->h_source;\n\tdest_mac = eth_hdr(skb)->h_dest;\n\n\t \n\thp = (struct fcoe_hdr *) skb_network_header(skb);\n\tfh = (struct fc_frame_header *) skb_transport_header(skb);\n\tskb_pull(skb, sizeof(struct fcoe_hdr));\n\tfr_len = skb->len - sizeof(struct fcoe_crc_eof);\n\n\tthis_cpu_inc(lport->stats->RxFrames);\n\tthis_cpu_add(lport->stats->RxWords, fr_len / FCOE_WORD_TO_BYTE);\n\n\tfp = (struct fc_frame *)skb;\n\tfc_frame_init(fp);\n\tfr_dev(fp) = lport;\n\tfr_sof(fp) = hp->fcoe_sof;\n\tif (skb_copy_bits(skb, fr_len, &crc_eof, sizeof(crc_eof))) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tfr_eof(fp) = crc_eof.fcoe_eof;\n\tfr_crc(fp) = crc_eof.fcoe_crc32;\n\tif (pskb_trim(skb, fr_len)) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tphys_port = lport_priv(lport);\n\tinterface = phys_port->priv;\n\tctlr = bnx2fc_to_ctlr(interface);\n\n\tfh = fc_frame_header_get(fp);\n\n\tif (ntoh24(&dest_mac[3]) != ntoh24(fh->fh_d_id)) {\n\t\tBNX2FC_HBA_DBG(lport, \"FC frame d_id mismatch with MAC %pM.\\n\",\n\t\t    dest_mac);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tvn_port = fc_vport_id_lookup(lport, ntoh24(fh->fh_d_id));\n\tif (vn_port) {\n\t\tport = lport_priv(vn_port);\n\t\tif (!ether_addr_equal(port->data_src_addr, dest_mac)) {\n\t\t\tBNX2FC_HBA_DBG(lport, \"fpma mismatch\\n\");\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (ctlr->state) {\n\t\tif (!ether_addr_equal(mac, ctlr->dest_addr)) {\n\t\t\tBNX2FC_HBA_DBG(lport, \"Wrong source address: mac:%pM dest_addr:%pM.\\n\",\n\t\t\t    mac, ctlr->dest_addr);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (fh->fh_r_ctl == FC_RCTL_DD_SOL_DATA &&\n\t    fh->fh_type == FC_TYPE_FCP) {\n\t\t \n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tif (fh->fh_r_ctl == FC_RCTL_ELS_REQ &&\n\t    fh->fh_type == FC_TYPE_ELS) {\n\t\tswitch (fc_frame_payload_op(fp)) {\n\t\tcase ELS_LOGO:\n\t\t\tif (ntoh24(fh->fh_s_id) == FC_FID_FLOGI) {\n\t\t\t\t \n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fh->fh_r_ctl == FC_RCTL_BA_ABTS) {\n\t\t \n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\tif (lport->port_id != ntoh24(fh->fh_d_id) && !vn_port) {\n\t\tBNX2FC_HBA_DBG(lport, \"Dropping frame due to destination mismatch: lport->port_id=%x fh->d_id=%x.\\n\",\n\t\t    lport->port_id, ntoh24(fh->fh_d_id));\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tfr_crc = le32_to_cpu(fr_crc(fp));\n\n\tif (unlikely(fr_crc != ~crc32(~0, skb->data, fr_len))) {\n\t\tcrc_err = this_cpu_inc_return(lport->stats->InvalidCRCCount);\n\t\tif (crc_err < 5)\n\t\t\tprintk(KERN_WARNING PFX \"dropping frame with \"\n\t\t\t       \"CRC error\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tfc_exch_recv(lport, fp);\n}\n\n \nstatic int bnx2fc_percpu_io_thread(void *arg)\n{\n\tstruct bnx2fc_percpu_s *p = arg;\n\tstruct bnx2fc_work *work, *tmp;\n\tLIST_HEAD(work_list);\n\n\tset_user_nice(current, MIN_NICE);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tspin_lock_bh(&p->fp_work_lock);\n\t\twhile (!list_empty(&p->work_list)) {\n\t\t\tlist_splice_init(&p->work_list, &work_list);\n\t\t\tspin_unlock_bh(&p->fp_work_lock);\n\n\t\t\tlist_for_each_entry_safe(work, tmp, &work_list, list) {\n\t\t\t\tlist_del_init(&work->list);\n\t\t\t\tbnx2fc_process_cq_compl(work->tgt, work->wqe,\n\t\t\t\t\t\t\twork->rq_data,\n\t\t\t\t\t\t\twork->num_rq,\n\t\t\t\t\t\t\twork->task);\n\t\t\t\tkfree(work);\n\t\t\t}\n\n\t\t\tspin_lock_bh(&p->fp_work_lock);\n\t\t}\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_unlock_bh(&p->fp_work_lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\treturn 0;\n}\n\nstatic struct fc_host_statistics *bnx2fc_get_host_stats(struct Scsi_Host *shost)\n{\n\tstruct fc_host_statistics *bnx2fc_stats;\n\tstruct fc_lport *lport = shost_priv(shost);\n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct bnx2fc_hba *hba = interface->hba;\n\tstruct fcoe_statistics_params *fw_stats;\n\tint rc = 0;\n\n\tfw_stats = (struct fcoe_statistics_params *)hba->stats_buffer;\n\tif (!fw_stats)\n\t\treturn NULL;\n\n\tmutex_lock(&hba->hba_stats_mutex);\n\n\tbnx2fc_stats = fc_get_host_stats(shost);\n\n\tinit_completion(&hba->stat_req_done);\n\tif (bnx2fc_send_stat_req(hba))\n\t\tgoto unlock_stats_mutex;\n\trc = wait_for_completion_timeout(&hba->stat_req_done, (2 * HZ));\n\tif (!rc) {\n\t\tBNX2FC_HBA_DBG(lport, \"FW stat req timed out\\n\");\n\t\tgoto unlock_stats_mutex;\n\t}\n\tBNX2FC_STATS(hba, rx_stat2, fc_crc_cnt);\n\tbnx2fc_stats->invalid_crc_count += hba->bfw_stats.fc_crc_cnt;\n\tBNX2FC_STATS(hba, tx_stat, fcoe_tx_pkt_cnt);\n\tbnx2fc_stats->tx_frames += hba->bfw_stats.fcoe_tx_pkt_cnt;\n\tBNX2FC_STATS(hba, tx_stat, fcoe_tx_byte_cnt);\n\tbnx2fc_stats->tx_words += ((hba->bfw_stats.fcoe_tx_byte_cnt) / 4);\n\tBNX2FC_STATS(hba, rx_stat0, fcoe_rx_pkt_cnt);\n\tbnx2fc_stats->rx_frames += hba->bfw_stats.fcoe_rx_pkt_cnt;\n\tBNX2FC_STATS(hba, rx_stat0, fcoe_rx_byte_cnt);\n\tbnx2fc_stats->rx_words += ((hba->bfw_stats.fcoe_rx_byte_cnt) / 4);\n\n\tbnx2fc_stats->dumped_frames = 0;\n\tbnx2fc_stats->lip_count = 0;\n\tbnx2fc_stats->nos_count = 0;\n\tbnx2fc_stats->loss_of_sync_count = 0;\n\tbnx2fc_stats->loss_of_signal_count = 0;\n\tbnx2fc_stats->prim_seq_protocol_err_count = 0;\n\n\tmemcpy(&hba->prev_stats, hba->stats_buffer,\n\t       sizeof(struct fcoe_statistics_params));\n\nunlock_stats_mutex:\n\tmutex_unlock(&hba->hba_stats_mutex);\n\treturn bnx2fc_stats;\n}\n\nstatic int bnx2fc_shost_config(struct fc_lport *lport, struct device *dev)\n{\n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct bnx2fc_hba *hba = interface->hba;\n\tstruct Scsi_Host *shost = lport->host;\n\tint rc = 0;\n\n\tshost->max_cmd_len = BNX2FC_MAX_CMD_LEN;\n\tshost->max_lun = bnx2fc_max_luns;\n\tshost->max_id = BNX2FC_MAX_FCP_TGT;\n\tshost->max_channel = 0;\n\tif (lport->vport)\n\t\tshost->transportt = bnx2fc_vport_xport_template;\n\telse\n\t\tshost->transportt = bnx2fc_transport_template;\n\n\t \n\trc = scsi_add_host(lport->host, dev);\n\tif (rc) {\n\t\tprintk(KERN_ERR PFX \"Error on scsi_add_host\\n\");\n\t\treturn rc;\n\t}\n\tif (!lport->vport)\n\t\tfc_host_max_npiv_vports(lport->host) = USHRT_MAX;\n\tsnprintf(fc_host_symbolic_name(lport->host), 256,\n\t\t \"%s (QLogic %s) v%s over %s\",\n\t\tBNX2FC_NAME, hba->chip_num, BNX2FC_VERSION,\n\t\tinterface->netdev->name);\n\n\treturn 0;\n}\n\nstatic int bnx2fc_link_ok(struct fc_lport *lport)\n{\n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct bnx2fc_hba *hba = interface->hba;\n\tstruct net_device *dev = hba->phys_dev;\n\tint rc = 0;\n\n\tif ((dev->flags & IFF_UP) && netif_carrier_ok(dev))\n\t\tclear_bit(ADAPTER_STATE_LINK_DOWN, &hba->adapter_state);\n\telse {\n\t\tset_bit(ADAPTER_STATE_LINK_DOWN, &hba->adapter_state);\n\t\trc = -1;\n\t}\n\treturn rc;\n}\n\n \nvoid bnx2fc_get_link_state(struct bnx2fc_hba *hba)\n{\n\tif (test_bit(__LINK_STATE_NOCARRIER, &hba->phys_dev->state))\n\t\tset_bit(ADAPTER_STATE_LINK_DOWN, &hba->adapter_state);\n\telse\n\t\tclear_bit(ADAPTER_STATE_LINK_DOWN, &hba->adapter_state);\n}\n\nstatic int bnx2fc_net_config(struct fc_lport *lport, struct net_device *netdev)\n{\n\tstruct bnx2fc_hba *hba;\n\tstruct bnx2fc_interface *interface;\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fcoe_port *port;\n\tu64 wwnn, wwpn;\n\n\tport = lport_priv(lport);\n\tinterface = port->priv;\n\tctlr = bnx2fc_to_ctlr(interface);\n\thba = interface->hba;\n\n\t \n\tif (!hba->phys_dev->ethtool_ops ||\n\t    !hba->phys_dev->ethtool_ops->get_pauseparam)\n\t\treturn -EOPNOTSUPP;\n\n\tif (fc_set_mfs(lport, BNX2FC_MFS))\n\t\treturn -EINVAL;\n\n\tskb_queue_head_init(&port->fcoe_pending_queue);\n\tport->fcoe_pending_queue_active = 0;\n\ttimer_setup(&port->timer, fcoe_queue_timer, 0);\n\n\tfcoe_link_speed_update(lport);\n\n\tif (!lport->vport) {\n\t\tif (fcoe_get_wwn(netdev, &wwnn, NETDEV_FCOE_WWNN))\n\t\t\twwnn = fcoe_wwn_from_mac(ctlr->ctl_src_addr,\n\t\t\t\t\t\t 1, 0);\n\t\tBNX2FC_HBA_DBG(lport, \"WWNN = 0x%llx\\n\", wwnn);\n\t\tfc_set_wwnn(lport, wwnn);\n\n\t\tif (fcoe_get_wwn(netdev, &wwpn, NETDEV_FCOE_WWPN))\n\t\t\twwpn = fcoe_wwn_from_mac(ctlr->ctl_src_addr,\n\t\t\t\t\t\t 2, 0);\n\n\t\tBNX2FC_HBA_DBG(lport, \"WWPN = 0x%llx\\n\", wwpn);\n\t\tfc_set_wwpn(lport, wwpn);\n\t}\n\n\treturn 0;\n}\n\nstatic void bnx2fc_destroy_timer(struct timer_list *t)\n{\n\tstruct bnx2fc_hba *hba = from_timer(hba, t, destroy_timer);\n\n\tprintk(KERN_ERR PFX \"ERROR:bnx2fc_destroy_timer - \"\n\t       \"Destroy compl not received!!\\n\");\n\tset_bit(BNX2FC_FLAG_DESTROY_CMPL, &hba->flags);\n\twake_up_interruptible(&hba->destroy_wait);\n}\n\n \nstatic void bnx2fc_indicate_netevent(void *context, unsigned long event,\n\t\t\t\t     u16 vlan_id)\n{\n\tstruct bnx2fc_hba *hba = (struct bnx2fc_hba *)context;\n\tstruct fcoe_ctlr_device *cdev;\n\tstruct fc_lport *lport;\n\tstruct fc_lport *vport;\n\tstruct bnx2fc_interface *interface, *tmp;\n\tstruct fcoe_ctlr *ctlr;\n\tint wait_for_upload = 0;\n\tu32 link_possible = 1;\n\n\tif (vlan_id != 0 && event != NETDEV_UNREGISTER)\n\t\treturn;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tif (!test_bit(ADAPTER_STATE_UP, &hba->adapter_state))\n\t\t\tprintk(KERN_ERR \"indicate_netevent: \"\\\n\t\t\t\t\t\"hba is not UP!!\\n\");\n\t\tbreak;\n\n\tcase NETDEV_DOWN:\n\t\tclear_bit(ADAPTER_STATE_GOING_DOWN, &hba->adapter_state);\n\t\tclear_bit(ADAPTER_STATE_UP, &hba->adapter_state);\n\t\tlink_possible = 0;\n\t\tbreak;\n\n\tcase NETDEV_GOING_DOWN:\n\t\tset_bit(ADAPTER_STATE_GOING_DOWN, &hba->adapter_state);\n\t\tlink_possible = 0;\n\t\tbreak;\n\n\tcase NETDEV_CHANGE:\n\t\tbreak;\n\n\tcase NETDEV_UNREGISTER:\n\t\tif (!vlan_id)\n\t\t\treturn;\n\t\tmutex_lock(&bnx2fc_dev_lock);\n\t\tlist_for_each_entry_safe(interface, tmp, &if_list, list) {\n\t\t\tif (interface->hba == hba &&\n\t\t\t    interface->vlan_id == (vlan_id & VLAN_VID_MASK))\n\t\t\t\t__bnx2fc_destroy(interface);\n\t\t}\n\t\tmutex_unlock(&bnx2fc_dev_lock);\n\t\treturn;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tmutex_lock(&bnx2fc_dev_lock);\n\tlist_for_each_entry(interface, &if_list, list) {\n\n\t\tif (interface->hba != hba)\n\t\t\tcontinue;\n\n\t\tctlr = bnx2fc_to_ctlr(interface);\n\t\tlport = ctlr->lp;\n\t\tBNX2FC_HBA_DBG(lport, \"netevent handler - event=%s %ld\\n\",\n\t\t\t\tinterface->netdev->name, event);\n\n\t\tfcoe_link_speed_update(lport);\n\n\t\tcdev = fcoe_ctlr_to_ctlr_dev(ctlr);\n\n\t\tif (link_possible && !bnx2fc_link_ok(lport)) {\n\t\t\tswitch (cdev->enabled) {\n\t\t\tcase FCOE_CTLR_DISABLED:\n\t\t\t\tpr_info(\"Link up while interface is disabled.\\n\");\n\t\t\t\tbreak;\n\t\t\tcase FCOE_CTLR_ENABLED:\n\t\t\tcase FCOE_CTLR_UNUSED:\n\t\t\t\t \n\t\t\t\tfc_set_mfs(lport, BNX2FC_MFS);\n\t\t\t\t \n\t\t\t\tif (interface->enabled)\n\t\t\t\t\tfcoe_ctlr_link_up(ctlr);\n\t\t\t}\n\t\t} else if (fcoe_ctlr_link_down(ctlr)) {\n\t\t\tswitch (cdev->enabled) {\n\t\t\tcase FCOE_CTLR_DISABLED:\n\t\t\t\tpr_info(\"Link down while interface is disabled.\\n\");\n\t\t\t\tbreak;\n\t\t\tcase FCOE_CTLR_ENABLED:\n\t\t\tcase FCOE_CTLR_UNUSED:\n\t\t\t\tmutex_lock(&lport->lp_mutex);\n\t\t\t\tlist_for_each_entry(vport, &lport->vports, list)\n\t\t\t\t\tfc_host_port_type(vport->host) =\n\t\t\t\t\tFC_PORTTYPE_UNKNOWN;\n\t\t\t\tmutex_unlock(&lport->lp_mutex);\n\t\t\t\tfc_host_port_type(lport->host) =\n\t\t\t\t\tFC_PORTTYPE_UNKNOWN;\n\t\t\t\tthis_cpu_inc(lport->stats->LinkFailureCount);\n\t\t\t\tfcoe_clean_pending_queue(lport);\n\t\t\t\twait_for_upload = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&bnx2fc_dev_lock);\n\n\tif (wait_for_upload) {\n\t\tclear_bit(ADAPTER_STATE_READY, &hba->adapter_state);\n\t\tinit_waitqueue_head(&hba->shutdown_wait);\n\t\tBNX2FC_MISC_DBG(\"indicate_netevent \"\n\t\t\t\t\"num_ofld_sess = %d\\n\",\n\t\t\t\thba->num_ofld_sess);\n\t\thba->wait_for_link_down = 1;\n\t\twait_event_interruptible(hba->shutdown_wait,\n\t\t\t\t\t (hba->num_ofld_sess == 0));\n\t\tBNX2FC_MISC_DBG(\"wakeup - num_ofld_sess = %d\\n\",\n\t\t\t\thba->num_ofld_sess);\n\t\thba->wait_for_link_down = 0;\n\n\t\tif (signal_pending(current))\n\t\t\tflush_signals(current);\n\t}\n}\n\nstatic int bnx2fc_libfc_config(struct fc_lport *lport)\n{\n\n\t \n\tmemcpy(&lport->tt, &bnx2fc_libfc_fcn_templ,\n\t\tsizeof(struct libfc_function_template));\n\tfc_elsct_init(lport);\n\tfc_exch_init(lport);\n\tfc_disc_init(lport);\n\tfc_disc_config(lport, lport);\n\treturn 0;\n}\n\nstatic int bnx2fc_em_config(struct fc_lport *lport, struct bnx2fc_hba *hba)\n{\n\tint fcoe_min_xid, fcoe_max_xid;\n\n\tfcoe_min_xid = hba->max_xid + 1;\n\tif (nr_cpu_ids <= 2)\n\t\tfcoe_max_xid = hba->max_xid + FCOE_XIDS_PER_CPU_OFFSET;\n\telse\n\t\tfcoe_max_xid = hba->max_xid + FCOE_MAX_XID_OFFSET;\n\tif (!fc_exch_mgr_alloc(lport, FC_CLASS_3, fcoe_min_xid,\n\t\t\t       fcoe_max_xid, NULL)) {\n\t\tprintk(KERN_ERR PFX \"em_config:fc_exch_mgr_alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2fc_lport_config(struct fc_lport *lport)\n{\n\tlport->link_up = 0;\n\tlport->qfull = 0;\n\tlport->max_retry_count = BNX2FC_MAX_RETRY_CNT;\n\tlport->max_rport_retry_count = BNX2FC_MAX_RPORT_RETRY_CNT;\n\tlport->e_d_tov = 2 * 1000;\n\tlport->r_a_tov = 10 * 1000;\n\n\tlport->service_params = (FCP_SPPF_INIT_FCN | FCP_SPPF_RD_XRDY_DIS |\n\t\t\t\tFCP_SPPF_RETRY | FCP_SPPF_CONF_COMPL);\n\tlport->does_npiv = 1;\n\n\tmemset(&lport->rnid_gen, 0, sizeof(struct fc_els_rnid_gen));\n\tlport->rnid_gen.rnid_atype = BNX2FC_RNID_HBA;\n\n\t \n\tif (fc_lport_init_stats(lport))\n\t\treturn -ENOMEM;\n\n\t \n\tfc_lport_config(lport);\n\n\treturn 0;\n}\n\n \nstatic int bnx2fc_fip_recv(struct sk_buff *skb, struct net_device *dev,\n\t\t\t   struct packet_type *ptype,\n\t\t\t   struct net_device *orig_dev)\n{\n\tstruct bnx2fc_interface *interface;\n\tstruct fcoe_ctlr *ctlr;\n\tinterface = container_of(ptype, struct bnx2fc_interface,\n\t\t\t\t fip_packet_type);\n\tctlr = bnx2fc_to_ctlr(interface);\n\tfcoe_ctlr_recv(ctlr, skb);\n\treturn 0;\n}\n\n \nstatic void bnx2fc_update_src_mac(struct fc_lport *lport, u8 *addr)\n{\n\tstruct fcoe_port *port = lport_priv(lport);\n\n\tmemcpy(port->data_src_addr, addr, ETH_ALEN);\n}\n\n \nstatic u8 *bnx2fc_get_src_mac(struct fc_lport *lport)\n{\n\tstruct fcoe_port *port;\n\n\tport = (struct fcoe_port *)lport_priv(lport);\n\treturn port->data_src_addr;\n}\n\n \nstatic void bnx2fc_fip_send(struct fcoe_ctlr *fip, struct sk_buff *skb)\n{\n\tstruct fip_header *fiph;\n\tstruct ethhdr *eth_hdr;\n\tu16 op;\n\tu8 sub;\n\n\tfiph = (struct fip_header *) ((void *)skb->data + 2 * ETH_ALEN + 2);\n\teth_hdr = (struct ethhdr *)skb_mac_header(skb);\n\top = ntohs(fiph->fip_op);\n\tsub = fiph->fip_subcode;\n\n\tif (op == FIP_OP_CTRL && sub == FIP_SC_SOL && bnx2fc_log_fka)\n\t\tBNX2FC_MISC_DBG(\"Sending FKA from %pM to %pM.\\n\",\n\t\t    eth_hdr->h_source, eth_hdr->h_dest);\n\n\tskb->dev = bnx2fc_from_ctlr(fip)->netdev;\n\tdev_queue_xmit(skb);\n}\n\nstatic int bnx2fc_vport_create(struct fc_vport *vport, bool disabled)\n{\n\tstruct Scsi_Host *shost = vport_to_shost(vport);\n\tstruct fc_lport *n_port = shost_priv(shost);\n\tstruct fcoe_port *port = lport_priv(n_port);\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct net_device *netdev = interface->netdev;\n\tstruct fc_lport *vn_port;\n\tint rc;\n\tchar buf[32];\n\n\trc = fcoe_validate_vport_create(vport);\n\tif (rc) {\n\t\tfcoe_wwn_to_str(vport->port_name, buf, sizeof(buf));\n\t\tprintk(KERN_ERR PFX \"Failed to create vport, \"\n\t\t       \"WWPN (0x%s) already exists\\n\",\n\t\t       buf);\n\t\treturn rc;\n\t}\n\n\tif (!test_bit(BNX2FC_FLAG_FW_INIT_DONE, &interface->hba->flags)) {\n\t\tprintk(KERN_ERR PFX \"vn ports cannot be created on\"\n\t\t\t\"this interface\\n\");\n\t\treturn -EIO;\n\t}\n\trtnl_lock();\n\tmutex_lock(&bnx2fc_dev_lock);\n\tvn_port = bnx2fc_if_create(interface, &vport->dev, 1);\n\tmutex_unlock(&bnx2fc_dev_lock);\n\trtnl_unlock();\n\n\tif (!vn_port) {\n\t\tprintk(KERN_ERR PFX \"bnx2fc_vport_create (%s) failed\\n\",\n\t\t\tnetdev->name);\n\t\treturn -EIO;\n\t}\n\n\tif (bnx2fc_devloss_tmo)\n\t\tfc_host_dev_loss_tmo(vn_port->host) = bnx2fc_devloss_tmo;\n\n\tif (disabled) {\n\t\tfc_vport_set_state(vport, FC_VPORT_DISABLED);\n\t} else {\n\t\tvn_port->boot_time = jiffies;\n\t\tfc_lport_init(vn_port);\n\t\tfc_fabric_login(vn_port);\n\t\tfc_vport_setlink(vn_port);\n\t}\n\treturn 0;\n}\n\nstatic void bnx2fc_free_vport(struct bnx2fc_hba *hba, struct fc_lport *lport)\n{\n\tstruct bnx2fc_lport *blport, *tmp;\n\n\tspin_lock_bh(&hba->hba_lock);\n\tlist_for_each_entry_safe(blport, tmp, &hba->vports, list) {\n\t\tif (blport->lport == lport) {\n\t\t\tlist_del(&blport->list);\n\t\t\tkfree(blport);\n\t\t}\n\t}\n\tspin_unlock_bh(&hba->hba_lock);\n}\n\nstatic int bnx2fc_vport_destroy(struct fc_vport *vport)\n{\n\tstruct Scsi_Host *shost = vport_to_shost(vport);\n\tstruct fc_lport *n_port = shost_priv(shost);\n\tstruct fc_lport *vn_port = vport->dd_data;\n\tstruct fcoe_port *port = lport_priv(vn_port);\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct fc_lport *v_port;\n\tbool found = false;\n\n\tmutex_lock(&n_port->lp_mutex);\n\tlist_for_each_entry(v_port, &n_port->vports, list)\n\t\tif (v_port->vport == vport) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\tif (!found) {\n\t\tmutex_unlock(&n_port->lp_mutex);\n\t\treturn -ENOENT;\n\t}\n\tlist_del(&vn_port->list);\n\tmutex_unlock(&n_port->lp_mutex);\n\tbnx2fc_free_vport(interface->hba, port->lport);\n\tbnx2fc_port_shutdown(port->lport);\n\tbnx2fc_port_destroy(port);\n\tbnx2fc_interface_put(interface);\n\treturn 0;\n}\n\nstatic int bnx2fc_vport_disable(struct fc_vport *vport, bool disable)\n{\n\tstruct fc_lport *lport = vport->dd_data;\n\n\tif (disable) {\n\t\tfc_vport_set_state(vport, FC_VPORT_DISABLED);\n\t\tfc_fabric_logoff(lport);\n\t} else {\n\t\tlport->boot_time = jiffies;\n\t\tfc_fabric_login(lport);\n\t\tfc_vport_setlink(lport);\n\t}\n\treturn 0;\n}\n\n\nstatic int bnx2fc_interface_setup(struct bnx2fc_interface *interface)\n{\n\tstruct net_device *netdev = interface->netdev;\n\tstruct net_device *physdev = interface->hba->phys_dev;\n\tstruct fcoe_ctlr *ctlr = bnx2fc_to_ctlr(interface);\n\tstruct netdev_hw_addr *ha;\n\tint sel_san_mac = 0;\n\n\t \n\trcu_read_lock();\n\tfor_each_dev_addr(physdev, ha) {\n\t\tBNX2FC_MISC_DBG(\"net_config: ha->type = %d, fip_mac = \",\n\t\t\t\tha->type);\n\t\tprintk(KERN_INFO \"%2x:%2x:%2x:%2x:%2x:%2x\\n\", ha->addr[0],\n\t\t\t\tha->addr[1], ha->addr[2], ha->addr[3],\n\t\t\t\tha->addr[4], ha->addr[5]);\n\n\t\tif ((ha->type == NETDEV_HW_ADDR_T_SAN) &&\n\t\t    (is_valid_ether_addr(ha->addr))) {\n\t\t\tmemcpy(ctlr->ctl_src_addr, ha->addr,\n\t\t\t       ETH_ALEN);\n\t\t\tsel_san_mac = 1;\n\t\t\tBNX2FC_MISC_DBG(\"Found SAN MAC\\n\");\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!sel_san_mac)\n\t\treturn -ENODEV;\n\n\tinterface->fip_packet_type.func = bnx2fc_fip_recv;\n\tinterface->fip_packet_type.type = htons(ETH_P_FIP);\n\tinterface->fip_packet_type.dev = netdev;\n\tdev_add_pack(&interface->fip_packet_type);\n\n\tinterface->fcoe_packet_type.func = bnx2fc_rcv;\n\tinterface->fcoe_packet_type.type = __constant_htons(ETH_P_FCOE);\n\tinterface->fcoe_packet_type.dev = netdev;\n\tdev_add_pack(&interface->fcoe_packet_type);\n\n\treturn 0;\n}\n\nstatic int bnx2fc_attach_transport(void)\n{\n\tbnx2fc_transport_template =\n\t\tfc_attach_transport(&bnx2fc_transport_function);\n\n\tif (bnx2fc_transport_template == NULL) {\n\t\tprintk(KERN_ERR PFX \"Failed to attach FC transport\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbnx2fc_vport_xport_template =\n\t\tfc_attach_transport(&bnx2fc_vport_xport_function);\n\tif (bnx2fc_vport_xport_template == NULL) {\n\t\tprintk(KERN_ERR PFX\n\t\t       \"Failed to attach FC transport for vport\\n\");\n\t\tfc_release_transport(bnx2fc_transport_template);\n\t\tbnx2fc_transport_template = NULL;\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\nstatic void bnx2fc_release_transport(void)\n{\n\tfc_release_transport(bnx2fc_transport_template);\n\tfc_release_transport(bnx2fc_vport_xport_template);\n\tbnx2fc_transport_template = NULL;\n\tbnx2fc_vport_xport_template = NULL;\n}\n\nstatic void bnx2fc_interface_release(struct kref *kref)\n{\n\tstruct fcoe_ctlr_device *ctlr_dev;\n\tstruct bnx2fc_interface *interface;\n\tstruct fcoe_ctlr *ctlr;\n\tstruct net_device *netdev;\n\n\tinterface = container_of(kref, struct bnx2fc_interface, kref);\n\tBNX2FC_MISC_DBG(\"Interface is being released\\n\");\n\n\tctlr = bnx2fc_to_ctlr(interface);\n\tctlr_dev = fcoe_ctlr_to_ctlr_dev(ctlr);\n\tnetdev = interface->netdev;\n\n\t \n\tif (test_and_clear_bit(BNX2FC_CTLR_INIT_DONE, &interface->if_flags))\n\t\tfcoe_ctlr_destroy(ctlr);\n\n\tfcoe_ctlr_device_delete(ctlr_dev);\n\n\tdev_put(netdev);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic inline void bnx2fc_interface_get(struct bnx2fc_interface *interface)\n{\n\tkref_get(&interface->kref);\n}\n\nstatic inline void bnx2fc_interface_put(struct bnx2fc_interface *interface)\n{\n\tkref_put(&interface->kref, bnx2fc_interface_release);\n}\nstatic void bnx2fc_hba_destroy(struct bnx2fc_hba *hba)\n{\n\t \n\tif (hba->cmd_mgr) {\n\t\tbnx2fc_cmd_mgr_free(hba->cmd_mgr);\n\t\thba->cmd_mgr = NULL;\n\t}\n\tkfree(hba->tgt_ofld_list);\n\tbnx2fc_unbind_pcidev(hba);\n\tkfree(hba);\n}\n\n \nstatic struct bnx2fc_hba *bnx2fc_hba_create(struct cnic_dev *cnic)\n{\n\tstruct bnx2fc_hba *hba;\n\tstruct fcoe_capabilities *fcoe_cap;\n\tint rc;\n\n\thba = kzalloc(sizeof(*hba), GFP_KERNEL);\n\tif (!hba) {\n\t\tprintk(KERN_ERR PFX \"Unable to allocate hba structure\\n\");\n\t\treturn NULL;\n\t}\n\tspin_lock_init(&hba->hba_lock);\n\tmutex_init(&hba->hba_mutex);\n\tmutex_init(&hba->hba_stats_mutex);\n\n\thba->cnic = cnic;\n\n\thba->max_tasks = cnic->max_fcoe_exchanges;\n\thba->elstm_xids = (hba->max_tasks / 2);\n\thba->max_outstanding_cmds = hba->elstm_xids;\n\thba->max_xid = (hba->max_tasks - 1);\n\n\trc = bnx2fc_bind_pcidev(hba);\n\tif (rc) {\n\t\tprintk(KERN_ERR PFX \"create_adapter:  bind error\\n\");\n\t\tgoto bind_err;\n\t}\n\thba->phys_dev = cnic->netdev;\n\thba->next_conn_id = 0;\n\n\thba->tgt_ofld_list =\n\t\tkcalloc(BNX2FC_NUM_MAX_SESS, sizeof(struct bnx2fc_rport *),\n\t\t\tGFP_KERNEL);\n\tif (!hba->tgt_ofld_list) {\n\t\tprintk(KERN_ERR PFX \"Unable to allocate tgt offload list\\n\");\n\t\tgoto tgtofld_err;\n\t}\n\n\thba->num_ofld_sess = 0;\n\n\thba->cmd_mgr = bnx2fc_cmd_mgr_alloc(hba);\n\tif (!hba->cmd_mgr) {\n\t\tprintk(KERN_ERR PFX \"em_config:bnx2fc_cmd_mgr_alloc failed\\n\");\n\t\tgoto cmgr_err;\n\t}\n\tfcoe_cap = &hba->fcoe_cap;\n\n\tfcoe_cap->capability1 = BNX2FC_TM_MAX_SQES <<\n\t\t\t\t\tFCOE_IOS_PER_CONNECTION_SHIFT;\n\tfcoe_cap->capability1 |= BNX2FC_NUM_MAX_SESS <<\n\t\t\t\t\tFCOE_LOGINS_PER_PORT_SHIFT;\n\tfcoe_cap->capability2 = hba->max_outstanding_cmds <<\n\t\t\t\t\tFCOE_NUMBER_OF_EXCHANGES_SHIFT;\n\tfcoe_cap->capability2 |= BNX2FC_MAX_NPIV <<\n\t\t\t\t\tFCOE_NPIV_WWN_PER_PORT_SHIFT;\n\tfcoe_cap->capability3 = BNX2FC_NUM_MAX_SESS <<\n\t\t\t\t\tFCOE_TARGETS_SUPPORTED_SHIFT;\n\tfcoe_cap->capability3 |= hba->max_outstanding_cmds <<\n\t\t\t\t\tFCOE_OUTSTANDING_COMMANDS_SHIFT;\n\tfcoe_cap->capability4 = FCOE_CAPABILITY4_STATEFUL;\n\n\tinit_waitqueue_head(&hba->shutdown_wait);\n\tinit_waitqueue_head(&hba->destroy_wait);\n\tINIT_LIST_HEAD(&hba->vports);\n\n\treturn hba;\n\ncmgr_err:\n\tkfree(hba->tgt_ofld_list);\ntgtofld_err:\n\tbnx2fc_unbind_pcidev(hba);\nbind_err:\n\tkfree(hba);\n\treturn NULL;\n}\n\nstatic struct bnx2fc_interface *\nbnx2fc_interface_create(struct bnx2fc_hba *hba,\n\t\t\tstruct net_device *netdev,\n\t\t\tenum fip_mode fip_mode)\n{\n\tstruct fcoe_ctlr_device *ctlr_dev;\n\tstruct bnx2fc_interface *interface;\n\tstruct fcoe_ctlr *ctlr;\n\tint size;\n\tint rc = 0;\n\n\tsize = (sizeof(*interface) + sizeof(struct fcoe_ctlr));\n\tctlr_dev = fcoe_ctlr_device_add(&netdev->dev, &bnx2fc_fcoe_sysfs_templ,\n\t\t\t\t\t size);\n\tif (!ctlr_dev) {\n\t\tprintk(KERN_ERR PFX \"Unable to allocate interface structure\\n\");\n\t\treturn NULL;\n\t}\n\tctlr = fcoe_ctlr_device_priv(ctlr_dev);\n\tctlr->cdev = ctlr_dev;\n\tinterface = fcoe_ctlr_priv(ctlr);\n\tdev_hold(netdev);\n\tkref_init(&interface->kref);\n\tinterface->hba = hba;\n\tinterface->netdev = netdev;\n\n\t \n\tfcoe_ctlr_init(ctlr, fip_mode);\n\tctlr->send = bnx2fc_fip_send;\n\tctlr->update_mac = bnx2fc_update_src_mac;\n\tctlr->get_src_addr = bnx2fc_get_src_mac;\n\tset_bit(BNX2FC_CTLR_INIT_DONE, &interface->if_flags);\n\n\trc = bnx2fc_interface_setup(interface);\n\tif (!rc)\n\t\treturn interface;\n\n\tfcoe_ctlr_destroy(ctlr);\n\tdev_put(netdev);\n\tfcoe_ctlr_device_delete(ctlr_dev);\n\treturn NULL;\n}\n\n \nstatic struct fc_lport *bnx2fc_if_create(struct bnx2fc_interface *interface,\n\t\t\t\t  struct device *parent, int npiv)\n{\n\tstruct fcoe_ctlr        *ctlr = bnx2fc_to_ctlr(interface);\n\tstruct fc_lport\t\t*lport, *n_port;\n\tstruct fcoe_port\t*port;\n\tstruct Scsi_Host\t*shost;\n\tstruct fc_vport\t\t*vport = dev_to_vport(parent);\n\tstruct bnx2fc_lport\t*blport;\n\tstruct bnx2fc_hba\t*hba = interface->hba;\n\tint\t\t\trc = 0;\n\n\tblport = kzalloc(sizeof(struct bnx2fc_lport), GFP_KERNEL);\n\tif (!blport) {\n\t\tBNX2FC_HBA_DBG(ctlr->lp, \"Unable to alloc blport\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tbnx2fc_shost_template.can_queue = hba->max_outstanding_cmds;\n\tif (!npiv)\n\t\tlport = libfc_host_alloc(&bnx2fc_shost_template, sizeof(*port));\n\telse\n\t\tlport = libfc_vport_create(vport, sizeof(*port));\n\n\tif (!lport) {\n\t\tprintk(KERN_ERR PFX \"could not allocate scsi host structure\\n\");\n\t\tgoto free_blport;\n\t}\n\tshost = lport->host;\n\tport = lport_priv(lport);\n\tport->lport = lport;\n\tport->priv = interface;\n\tport->get_netdev = bnx2fc_netdev;\n\n\t \n\trc = bnx2fc_lport_config(lport);\n\tif (rc)\n\t\tgoto lp_config_err;\n\n\tif (npiv) {\n\t\tprintk(KERN_ERR PFX \"Setting vport names, 0x%llX 0x%llX\\n\",\n\t\t\tvport->node_name, vport->port_name);\n\t\tfc_set_wwnn(lport, vport->node_name);\n\t\tfc_set_wwpn(lport, vport->port_name);\n\t}\n\t \n\trc = bnx2fc_net_config(lport, interface->netdev);\n\tif (rc) {\n\t\tprintk(KERN_ERR PFX \"Error on bnx2fc_net_config\\n\");\n\t\tgoto lp_config_err;\n\t}\n\n\trc = bnx2fc_shost_config(lport, parent);\n\tif (rc) {\n\t\tprintk(KERN_ERR PFX \"Couldn't configure shost for %s\\n\",\n\t\t\tinterface->netdev->name);\n\t\tgoto lp_config_err;\n\t}\n\n\t \n\trc = bnx2fc_libfc_config(lport);\n\tif (rc) {\n\t\tprintk(KERN_ERR PFX \"Couldn't configure libfc\\n\");\n\t\tgoto shost_err;\n\t}\n\tfc_host_port_type(lport->host) = FC_PORTTYPE_UNKNOWN;\n\n\tif (bnx2fc_devloss_tmo)\n\t\tfc_host_dev_loss_tmo(shost) = bnx2fc_devloss_tmo;\n\n\t \n\tif (!npiv)\n\t\trc = bnx2fc_em_config(lport, hba);\n\telse {\n\t\tshost = vport_to_shost(vport);\n\t\tn_port = shost_priv(shost);\n\t\trc = fc_exch_mgr_list_clone(n_port, lport);\n\t}\n\n\tif (rc) {\n\t\tprintk(KERN_ERR PFX \"Error on bnx2fc_em_config\\n\");\n\t\tgoto shost_err;\n\t}\n\n\tbnx2fc_interface_get(interface);\n\n\tspin_lock_bh(&hba->hba_lock);\n\tblport->lport = lport;\n\tlist_add_tail(&blport->list, &hba->vports);\n\tspin_unlock_bh(&hba->hba_lock);\n\n\treturn lport;\n\nshost_err:\n\tscsi_remove_host(shost);\nlp_config_err:\n\tscsi_host_put(lport->host);\nfree_blport:\n\tkfree(blport);\n\treturn NULL;\n}\n\nstatic void bnx2fc_net_cleanup(struct bnx2fc_interface *interface)\n{\n\t \n\t__dev_remove_pack(&interface->fcoe_packet_type);\n\t__dev_remove_pack(&interface->fip_packet_type);\n\tsynchronize_net();\n}\n\nstatic void bnx2fc_interface_cleanup(struct bnx2fc_interface *interface)\n{\n\tstruct fcoe_ctlr *ctlr = bnx2fc_to_ctlr(interface);\n\tstruct fc_lport *lport = ctlr->lp;\n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct bnx2fc_hba *hba = interface->hba;\n\n\t \n\tdel_timer_sync(&port->timer);\n\n\t \n\tfcoe_clean_pending_queue(lport);\n\n\tbnx2fc_net_cleanup(interface);\n\n\tbnx2fc_free_vport(hba, lport);\n}\n\nstatic void bnx2fc_if_destroy(struct fc_lport *lport)\n{\n\n\t \n\tbnx2fc_clean_rx_queue(lport);\n\n\t \n\tfc_remove_host(lport->host);\n\tscsi_remove_host(lport->host);\n\n\t \n\tfc_exch_mgr_free(lport);\n\n\t \n\tfc_lport_free_stats(lport);\n\n\t \n\tscsi_host_put(lport->host);\n}\n\nstatic void __bnx2fc_destroy(struct bnx2fc_interface *interface)\n{\n\tstruct fcoe_ctlr *ctlr = bnx2fc_to_ctlr(interface);\n\tstruct fc_lport *lport = ctlr->lp;\n\tstruct fcoe_port *port = lport_priv(lport);\n\n\tbnx2fc_interface_cleanup(interface);\n\tbnx2fc_stop(interface);\n\tlist_del(&interface->list);\n\tbnx2fc_port_destroy(port);\n\tbnx2fc_interface_put(interface);\n}\n\n \nstatic int bnx2fc_destroy(struct net_device *netdev)\n{\n\tstruct bnx2fc_interface *interface = NULL;\n\tstruct workqueue_struct *timer_work_queue;\n\tstruct fcoe_ctlr *ctlr;\n\tint rc = 0;\n\n\trtnl_lock();\n\tmutex_lock(&bnx2fc_dev_lock);\n\n\tinterface = bnx2fc_interface_lookup(netdev);\n\tctlr = bnx2fc_to_ctlr(interface);\n\tif (!interface || !ctlr->lp) {\n\t\trc = -ENODEV;\n\t\tprintk(KERN_ERR PFX \"bnx2fc_destroy: interface or lport not found\\n\");\n\t\tgoto netdev_err;\n\t}\n\n\ttimer_work_queue = interface->timer_work_queue;\n\t__bnx2fc_destroy(interface);\n\tdestroy_workqueue(timer_work_queue);\n\nnetdev_err:\n\tmutex_unlock(&bnx2fc_dev_lock);\n\trtnl_unlock();\n\treturn rc;\n}\n\nstatic void bnx2fc_port_destroy(struct fcoe_port *port)\n{\n\tstruct fc_lport *lport;\n\n\tlport = port->lport;\n\tBNX2FC_HBA_DBG(lport, \"Entered %s, destroying lport %p\\n\", __func__, lport);\n\n\tbnx2fc_if_destroy(lport);\n}\n\nstatic void bnx2fc_unbind_adapter_devices(struct bnx2fc_hba *hba)\n{\n\tbnx2fc_free_fw_resc(hba);\n\tbnx2fc_free_task_ctx(hba);\n}\n\n \nstatic int bnx2fc_bind_adapter_devices(struct bnx2fc_hba *hba)\n{\n\tif (bnx2fc_setup_task_ctx(hba))\n\t\tgoto mem_err;\n\n\tif (bnx2fc_setup_fw_resc(hba))\n\t\tgoto mem_err;\n\n\treturn 0;\nmem_err:\n\tbnx2fc_unbind_adapter_devices(hba);\n\treturn -ENOMEM;\n}\n\nstatic int bnx2fc_bind_pcidev(struct bnx2fc_hba *hba)\n{\n\tstruct cnic_dev *cnic;\n\tstruct pci_dev *pdev;\n\n\tif (!hba->cnic) {\n\t\tprintk(KERN_ERR PFX \"cnic is NULL\\n\");\n\t\treturn -ENODEV;\n\t}\n\tcnic = hba->cnic;\n\tpdev = hba->pcidev = cnic->pcidev;\n\tif (!hba->pcidev)\n\t\treturn -ENODEV;\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_NX2_57710:\n\t\tstrncpy(hba->chip_num, \"BCM57710\", BCM_CHIP_LEN);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_NX2_57711:\n\t\tstrncpy(hba->chip_num, \"BCM57711\", BCM_CHIP_LEN);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_NX2_57712:\n\tcase PCI_DEVICE_ID_NX2_57712_MF:\n\tcase PCI_DEVICE_ID_NX2_57712_VF:\n\t\tstrncpy(hba->chip_num, \"BCM57712\", BCM_CHIP_LEN);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_NX2_57800:\n\tcase PCI_DEVICE_ID_NX2_57800_MF:\n\tcase PCI_DEVICE_ID_NX2_57800_VF:\n\t\tstrncpy(hba->chip_num, \"BCM57800\", BCM_CHIP_LEN);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_NX2_57810:\n\tcase PCI_DEVICE_ID_NX2_57810_MF:\n\tcase PCI_DEVICE_ID_NX2_57810_VF:\n\t\tstrncpy(hba->chip_num, \"BCM57810\", BCM_CHIP_LEN);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_NX2_57840:\n\tcase PCI_DEVICE_ID_NX2_57840_MF:\n\tcase PCI_DEVICE_ID_NX2_57840_VF:\n\tcase PCI_DEVICE_ID_NX2_57840_2_20:\n\tcase PCI_DEVICE_ID_NX2_57840_4_10:\n\t\tstrncpy(hba->chip_num, \"BCM57840\", BCM_CHIP_LEN);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(PFX \"Unknown device id 0x%x\\n\", pdev->device);\n\t\tbreak;\n\t}\n\tpci_dev_get(hba->pcidev);\n\treturn 0;\n}\n\nstatic void bnx2fc_unbind_pcidev(struct bnx2fc_hba *hba)\n{\n\tif (hba->pcidev) {\n\t\thba->chip_num[0] = '\\0';\n\t\tpci_dev_put(hba->pcidev);\n\t}\n\thba->pcidev = NULL;\n}\n\n \nstatic int bnx2fc_ulp_get_stats(void *handle)\n{\n\tstruct bnx2fc_hba *hba = handle;\n\tstruct cnic_dev *cnic;\n\tstruct fcoe_stats_info *stats_addr;\n\n\tif (!hba)\n\t\treturn -EINVAL;\n\n\tcnic = hba->cnic;\n\tstats_addr = &cnic->stats_addr->fcoe_stat;\n\tif (!stats_addr)\n\t\treturn -EINVAL;\n\n\tstrncpy(stats_addr->version, BNX2FC_VERSION,\n\t\tsizeof(stats_addr->version));\n\tstats_addr->txq_size = BNX2FC_SQ_WQES_MAX;\n\tstats_addr->rxq_size = BNX2FC_CQ_WQES_MAX;\n\n\treturn 0;\n}\n\n\n \nstatic void bnx2fc_ulp_start(void *handle)\n{\n\tstruct bnx2fc_hba *hba = handle;\n\tstruct bnx2fc_interface *interface;\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fc_lport *lport;\n\n\tmutex_lock(&bnx2fc_dev_lock);\n\n\tif (!test_bit(BNX2FC_FLAG_FW_INIT_DONE, &hba->flags))\n\t\tbnx2fc_fw_init(hba);\n\n\tBNX2FC_MISC_DBG(\"bnx2fc started.\\n\");\n\n\tlist_for_each_entry(interface, &if_list, list) {\n\t\tif (interface->hba == hba) {\n\t\t\tctlr = bnx2fc_to_ctlr(interface);\n\t\t\tlport = ctlr->lp;\n\t\t\t \n\t\t\tprintk(KERN_ERR PFX \"ulp_init: start discovery\\n\");\n\t\t\tlport->tt.frame_send = bnx2fc_xmit;\n\t\t\tbnx2fc_start_disc(interface);\n\t\t}\n\t}\n\n\tmutex_unlock(&bnx2fc_dev_lock);\n}\n\nstatic void bnx2fc_port_shutdown(struct fc_lport *lport)\n{\n\tBNX2FC_MISC_DBG(\"Entered %s\\n\", __func__);\n\tfc_fabric_logoff(lport);\n\tfc_lport_destroy(lport);\n}\n\nstatic void bnx2fc_stop(struct bnx2fc_interface *interface)\n{\n\tstruct fcoe_ctlr *ctlr = bnx2fc_to_ctlr(interface);\n\tstruct fc_lport *lport;\n\tstruct fc_lport *vport;\n\n\tif (!test_bit(BNX2FC_FLAG_FW_INIT_DONE, &interface->hba->flags))\n\t\treturn;\n\n\tlport = ctlr->lp;\n\tbnx2fc_port_shutdown(lport);\n\n\tmutex_lock(&lport->lp_mutex);\n\tlist_for_each_entry(vport, &lport->vports, list)\n\t\tfc_host_port_type(vport->host) =\n\t\t\t\t\tFC_PORTTYPE_UNKNOWN;\n\tmutex_unlock(&lport->lp_mutex);\n\tfc_host_port_type(lport->host) = FC_PORTTYPE_UNKNOWN;\n\tfcoe_ctlr_link_down(ctlr);\n\tfcoe_clean_pending_queue(lport);\n}\n\nstatic int bnx2fc_fw_init(struct bnx2fc_hba *hba)\n{\n#define BNX2FC_INIT_POLL_TIME\t\t(1000 / HZ)\n\tint rc = -1;\n\tint i = HZ;\n\n\trc = bnx2fc_bind_adapter_devices(hba);\n\tif (rc) {\n\t\tprintk(KERN_ALERT PFX\n\t\t\t\"bnx2fc_bind_adapter_devices failed - rc = %d\\n\", rc);\n\t\tgoto err_out;\n\t}\n\n\trc = bnx2fc_send_fw_fcoe_init_msg(hba);\n\tif (rc) {\n\t\tprintk(KERN_ALERT PFX\n\t\t\t\"bnx2fc_send_fw_fcoe_init_msg failed - rc = %d\\n\", rc);\n\t\tgoto err_unbind;\n\t}\n\n\t \n\twhile (!test_bit(ADAPTER_STATE_UP, &hba->adapter_state) && i--)\n\t\tmsleep(BNX2FC_INIT_POLL_TIME);\n\n\tif (!test_bit(ADAPTER_STATE_UP, &hba->adapter_state)) {\n\t\tprintk(KERN_ERR PFX \"bnx2fc_start: %s failed to initialize.  \"\n\t\t\t\t\"Ignoring...\\n\",\n\t\t\t\thba->cnic->netdev->name);\n\t\trc = -1;\n\t\tgoto err_unbind;\n\t}\n\n\n\tset_bit(BNX2FC_FLAG_FW_INIT_DONE, &hba->flags);\n\treturn 0;\n\nerr_unbind:\n\tbnx2fc_unbind_adapter_devices(hba);\nerr_out:\n\treturn rc;\n}\n\nstatic void bnx2fc_fw_destroy(struct bnx2fc_hba *hba)\n{\n\tif (test_and_clear_bit(BNX2FC_FLAG_FW_INIT_DONE, &hba->flags)) {\n\t\tif (bnx2fc_send_fw_fcoe_destroy_msg(hba) == 0) {\n\t\t\ttimer_setup(&hba->destroy_timer, bnx2fc_destroy_timer,\n\t\t\t\t    0);\n\t\t\thba->destroy_timer.expires = BNX2FC_FW_TIMEOUT +\n\t\t\t\t\t\t\t\tjiffies;\n\t\t\tadd_timer(&hba->destroy_timer);\n\t\t\twait_event_interruptible(hba->destroy_wait,\n\t\t\t\t\ttest_bit(BNX2FC_FLAG_DESTROY_CMPL,\n\t\t\t\t\t\t &hba->flags));\n\t\t\tclear_bit(BNX2FC_FLAG_DESTROY_CMPL, &hba->flags);\n\t\t\t \n\t\t\tif (signal_pending(current))\n\t\t\t\tflush_signals(current);\n\n\t\t\tdel_timer_sync(&hba->destroy_timer);\n\t\t}\n\t\tbnx2fc_unbind_adapter_devices(hba);\n\t}\n}\n\n \nstatic void bnx2fc_ulp_stop(void *handle)\n{\n\tstruct bnx2fc_hba *hba = handle;\n\tstruct bnx2fc_interface *interface;\n\n\tprintk(KERN_ERR \"ULP_STOP\\n\");\n\n\tmutex_lock(&bnx2fc_dev_lock);\n\tif (!test_bit(BNX2FC_FLAG_FW_INIT_DONE, &hba->flags))\n\t\tgoto exit;\n\tlist_for_each_entry(interface, &if_list, list) {\n\t\tif (interface->hba == hba)\n\t\t\tbnx2fc_stop(interface);\n\t}\n\tBUG_ON(hba->num_ofld_sess != 0);\n\n\tmutex_lock(&hba->hba_mutex);\n\tclear_bit(ADAPTER_STATE_UP, &hba->adapter_state);\n\tclear_bit(ADAPTER_STATE_GOING_DOWN,\n\t\t  &hba->adapter_state);\n\n\tclear_bit(ADAPTER_STATE_READY, &hba->adapter_state);\n\tmutex_unlock(&hba->hba_mutex);\n\n\tbnx2fc_fw_destroy(hba);\nexit:\n\tmutex_unlock(&bnx2fc_dev_lock);\n}\n\nstatic void bnx2fc_start_disc(struct bnx2fc_interface *interface)\n{\n\tstruct fcoe_ctlr *ctlr = bnx2fc_to_ctlr(interface);\n\tstruct fc_lport *lport;\n\tint wait_cnt = 0;\n\n\tBNX2FC_MISC_DBG(\"Entered %s\\n\", __func__);\n\t \n\tif (!test_bit(BNX2FC_FLAG_FW_INIT_DONE, &interface->hba->flags)) {\n\t\tprintk(KERN_ERR PFX \"Init not done yet\\n\");\n\t\treturn;\n\t}\n\n\tlport = ctlr->lp;\n\tBNX2FC_HBA_DBG(lport, \"calling fc_fabric_login\\n\");\n\n\tif (!bnx2fc_link_ok(lport) && interface->enabled) {\n\t\tBNX2FC_HBA_DBG(lport, \"ctlr_link_up\\n\");\n\t\tfcoe_ctlr_link_up(ctlr);\n\t\tfc_host_port_type(lport->host) = FC_PORTTYPE_NPORT;\n\t\tset_bit(ADAPTER_STATE_READY, &interface->hba->adapter_state);\n\t}\n\n\t \n\twhile (!ctlr->sel_fcf) {\n\t\tmsleep(250);\n\t\t \n\t\tif (++wait_cnt > 12)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (fc_set_mfs(lport, BNX2FC_MFS))\n\t\treturn;\n\n\tfc_lport_init(lport);\n\tfc_fabric_login(lport);\n}\n\n\n \nstatic void bnx2fc_ulp_init(struct cnic_dev *dev)\n{\n\tstruct bnx2fc_hba *hba;\n\tint rc = 0;\n\n\tBNX2FC_MISC_DBG(\"Entered %s\\n\", __func__);\n\t \n\tif (!test_bit(CNIC_F_BNX2X_CLASS, &dev->flags) ||\n\t    (dev->max_fcoe_conn == 0)) {\n\t\tprintk(KERN_ERR PFX \"bnx2fc FCoE not supported on %s,\"\n\t\t\t\t    \" flags: %lx fcoe_conn: %d\\n\",\n\t\t\tdev->netdev->name, dev->flags, dev->max_fcoe_conn);\n\t\treturn;\n\t}\n\n\thba = bnx2fc_hba_create(dev);\n\tif (!hba) {\n\t\tprintk(KERN_ERR PFX \"hba initialization failed\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(PFX \"FCoE initialized for %s.\\n\", dev->netdev->name);\n\n\t \n\tmutex_lock(&bnx2fc_dev_lock);\n\tlist_add_tail(&hba->list, &adapter_list);\n\tadapter_count++;\n\tmutex_unlock(&bnx2fc_dev_lock);\n\n\tdev->fcoe_cap = &hba->fcoe_cap;\n\tclear_bit(BNX2FC_CNIC_REGISTERED, &hba->reg_with_cnic);\n\trc = dev->register_device(dev, CNIC_ULP_FCOE,\n\t\t\t\t\t\t(void *) hba);\n\tif (rc)\n\t\tprintk(KERN_ERR PFX \"register_device failed, rc = %d\\n\", rc);\n\telse\n\t\tset_bit(BNX2FC_CNIC_REGISTERED, &hba->reg_with_cnic);\n}\n\n \nstatic int __bnx2fc_disable(struct fcoe_ctlr *ctlr)\n{\n\tstruct bnx2fc_interface *interface = fcoe_ctlr_priv(ctlr);\n\n\tif (interface->enabled) {\n\t\tif (!ctlr->lp) {\n\t\t\tpr_err(PFX \"__bnx2fc_disable: lport not found\\n\");\n\t\t\treturn -ENODEV;\n\t\t} else {\n\t\t\tinterface->enabled = false;\n\t\t\tfcoe_ctlr_link_down(ctlr);\n\t\t\tfcoe_clean_pending_queue(ctlr->lp);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int bnx2fc_disable(struct net_device *netdev)\n{\n\tstruct bnx2fc_interface *interface;\n\tstruct fcoe_ctlr *ctlr;\n\tint rc = 0;\n\n\trtnl_lock();\n\tmutex_lock(&bnx2fc_dev_lock);\n\n\tinterface = bnx2fc_interface_lookup(netdev);\n\tctlr = bnx2fc_to_ctlr(interface);\n\n\tif (!interface) {\n\t\trc = -ENODEV;\n\t\tpr_err(PFX \"bnx2fc_disable: interface not found\\n\");\n\t} else {\n\t\trc = __bnx2fc_disable(ctlr);\n\t}\n\tmutex_unlock(&bnx2fc_dev_lock);\n\trtnl_unlock();\n\treturn rc;\n}\n\nstatic uint bnx2fc_npiv_create_vports(struct fc_lport *lport,\n\t\t\t\t      struct cnic_fc_npiv_tbl *npiv_tbl)\n{\n\tstruct fc_vport_identifiers vpid;\n\tuint i, created = 0;\n\tu64 wwnn = 0;\n\tchar wwpn_str[32];\n\tchar wwnn_str[32];\n\n\tif (npiv_tbl->count > MAX_NPIV_ENTRIES) {\n\t\tBNX2FC_HBA_DBG(lport, \"Exceeded count max of npiv table\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tif (wwn_to_u64(npiv_tbl->wwnn[0]) == 0 &&\n\t    wwn_to_u64(npiv_tbl->wwpn[0]) == 0) {\n\t\tBNX2FC_HBA_DBG(lport, \"First NPIV table entries invalid.\\n\");\n\t\tgoto done;\n\t}\n\n\tvpid.roles = FC_PORT_ROLE_FCP_INITIATOR;\n\tvpid.vport_type = FC_PORTTYPE_NPIV;\n\tvpid.disable = false;\n\n\tfor (i = 0; i < npiv_tbl->count; i++) {\n\t\twwnn = wwn_to_u64(npiv_tbl->wwnn[i]);\n\t\tif (wwnn == 0) {\n\t\t\t \n\t\t\twwnn = lport->wwnn;\n\t\t}\n\t\tvpid.node_name = wwnn;\n\t\tvpid.port_name = wwn_to_u64(npiv_tbl->wwpn[i]);\n\t\tscnprintf(vpid.symbolic_name, sizeof(vpid.symbolic_name),\n\t\t    \"NPIV[%u]:%016llx-%016llx\",\n\t\t    created, vpid.port_name, vpid.node_name);\n\t\tfcoe_wwn_to_str(vpid.node_name, wwnn_str, sizeof(wwnn_str));\n\t\tfcoe_wwn_to_str(vpid.port_name, wwpn_str, sizeof(wwpn_str));\n\t\tBNX2FC_HBA_DBG(lport, \"Creating vport %s:%s.\\n\", wwnn_str,\n\t\t    wwpn_str);\n\t\tif (fc_vport_create(lport->host, 0, &vpid))\n\t\t\tcreated++;\n\t\telse\n\t\t\tBNX2FC_HBA_DBG(lport, \"Failed to create vport\\n\");\n\t}\ndone:\n\treturn created;\n}\n\nstatic int __bnx2fc_enable(struct fcoe_ctlr *ctlr)\n{\n\tstruct bnx2fc_interface *interface = fcoe_ctlr_priv(ctlr);\n\tstruct bnx2fc_hba *hba;\n\tstruct cnic_fc_npiv_tbl *npiv_tbl;\n\tstruct fc_lport *lport;\n\n\tif (!interface->enabled) {\n\t\tif (!ctlr->lp) {\n\t\t\tpr_err(PFX \"__bnx2fc_enable: lport not found\\n\");\n\t\t\treturn -ENODEV;\n\t\t} else if (!bnx2fc_link_ok(ctlr->lp)) {\n\t\t\tfcoe_ctlr_link_up(ctlr);\n\t\t\tinterface->enabled = true;\n\t\t}\n\t}\n\n\t \n\thba = interface->hba;\n\tlport = ctlr->lp;\n\n\tif (!hba)\n\t\tgoto done;\n\n\tif (!hba->cnic)\n\t\tgoto done;\n\n\tif (!lport)\n\t\tgoto done;\n\n\tif (!lport->host)\n\t\tgoto done;\n\n\tif (!hba->cnic->get_fc_npiv_tbl)\n\t\tgoto done;\n\n\tnpiv_tbl = kzalloc(sizeof(struct cnic_fc_npiv_tbl), GFP_KERNEL);\n\tif (!npiv_tbl)\n\t\tgoto done;\n\n\tif (hba->cnic->get_fc_npiv_tbl(hba->cnic, npiv_tbl))\n\t\tgoto done_free;\n\n\tbnx2fc_npiv_create_vports(lport, npiv_tbl);\ndone_free:\n\tkfree(npiv_tbl);\ndone:\n\treturn 0;\n}\n\n \nstatic int bnx2fc_enable(struct net_device *netdev)\n{\n\tstruct bnx2fc_interface *interface;\n\tstruct fcoe_ctlr *ctlr;\n\tint rc = 0;\n\n\trtnl_lock();\n\tmutex_lock(&bnx2fc_dev_lock);\n\n\tinterface = bnx2fc_interface_lookup(netdev);\n\tctlr = bnx2fc_to_ctlr(interface);\n\tif (!interface) {\n\t\trc = -ENODEV;\n\t\tpr_err(PFX \"bnx2fc_enable: interface not found\\n\");\n\t} else {\n\t\trc = __bnx2fc_enable(ctlr);\n\t}\n\n\tmutex_unlock(&bnx2fc_dev_lock);\n\trtnl_unlock();\n\treturn rc;\n}\n\n \nstatic int bnx2fc_ctlr_enabled(struct fcoe_ctlr_device *cdev)\n{\n\tstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(cdev);\n\n\tswitch (cdev->enabled) {\n\tcase FCOE_CTLR_ENABLED:\n\t\treturn __bnx2fc_enable(ctlr);\n\tcase FCOE_CTLR_DISABLED:\n\t\treturn __bnx2fc_disable(ctlr);\n\tcase FCOE_CTLR_UNUSED:\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nenum bnx2fc_create_link_state {\n\tBNX2FC_CREATE_LINK_DOWN,\n\tBNX2FC_CREATE_LINK_UP,\n};\n\n \nstatic int _bnx2fc_create(struct net_device *netdev,\n\t\t\t  enum fip_mode fip_mode,\n\t\t\t  enum bnx2fc_create_link_state link_state)\n{\n\tstruct fcoe_ctlr_device *cdev;\n\tstruct fcoe_ctlr *ctlr;\n\tstruct bnx2fc_interface *interface;\n\tstruct bnx2fc_hba *hba;\n\tstruct net_device *phys_dev = netdev;\n\tstruct fc_lport *lport;\n\tstruct ethtool_drvinfo drvinfo;\n\tint rc = 0;\n\tint vlan_id = 0;\n\n\tBNX2FC_MISC_DBG(\"Entered bnx2fc_create\\n\");\n\tif (fip_mode != FIP_MODE_FABRIC) {\n\t\tprintk(KERN_ERR \"fip mode not FABRIC\\n\");\n\t\treturn -EIO;\n\t}\n\n\trtnl_lock();\n\n\tmutex_lock(&bnx2fc_dev_lock);\n\n\tif (!try_module_get(THIS_MODULE)) {\n\t\trc = -EINVAL;\n\t\tgoto mod_err;\n\t}\n\n\t \n\tif (is_vlan_dev(netdev))\n\t\tphys_dev = vlan_dev_real_dev(netdev);\n\n\t \n\tif (phys_dev->ethtool_ops && phys_dev->ethtool_ops->get_drvinfo) {\n\t\tmemset(&drvinfo, 0, sizeof(drvinfo));\n\t\tphys_dev->ethtool_ops->get_drvinfo(phys_dev, &drvinfo);\n\t\tif (strncmp(drvinfo.driver, \"bnx2x\", strlen(\"bnx2x\"))) {\n\t\t\tprintk(KERN_ERR PFX \"Not a netxtreme2 device\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto netdev_err;\n\t\t}\n\t} else {\n\t\tprintk(KERN_ERR PFX \"unable to obtain drv_info\\n\");\n\t\trc = -EINVAL;\n\t\tgoto netdev_err;\n\t}\n\n\t \n\thba = bnx2fc_hba_lookup(phys_dev);\n\tif (!hba) {\n\t\trc = -ENODEV;\n\t\tprintk(KERN_ERR PFX \"bnx2fc_create: hba not found\\n\");\n\t\tgoto netdev_err;\n\t}\n\n\tif (bnx2fc_interface_lookup(netdev)) {\n\t\trc = -EEXIST;\n\t\tgoto netdev_err;\n\t}\n\n\tinterface = bnx2fc_interface_create(hba, netdev, fip_mode);\n\tif (!interface) {\n\t\tprintk(KERN_ERR PFX \"bnx2fc_interface_create failed\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto netdev_err;\n\t}\n\n\tif (is_vlan_dev(netdev)) {\n\t\tvlan_id = vlan_dev_vlan_id(netdev);\n\t\tinterface->vlan_enabled = 1;\n\t}\n\n\tctlr = bnx2fc_to_ctlr(interface);\n\tcdev = fcoe_ctlr_to_ctlr_dev(ctlr);\n\tinterface->vlan_id = vlan_id;\n\tinterface->tm_timeout = BNX2FC_TM_TIMEOUT;\n\n\tinterface->timer_work_queue =\n\t\t\tcreate_singlethread_workqueue(\"bnx2fc_timer_wq\");\n\tif (!interface->timer_work_queue) {\n\t\tprintk(KERN_ERR PFX \"ulp_init could not create timer_wq\\n\");\n\t\trc = -EINVAL;\n\t\tgoto ifput_err;\n\t}\n\n\tlport = bnx2fc_if_create(interface, &cdev->dev, 0);\n\tif (!lport) {\n\t\tprintk(KERN_ERR PFX \"Failed to create interface (%s)\\n\",\n\t\t\tnetdev->name);\n\t\trc = -EINVAL;\n\t\tgoto if_create_err;\n\t}\n\n\t \n\tlist_add_tail(&interface->list, &if_list);\n\n\tlport->boot_time = jiffies;\n\n\t \n\tctlr->lp = lport;\n\n\tif (link_state == BNX2FC_CREATE_LINK_UP)\n\t\tcdev->enabled = FCOE_CTLR_ENABLED;\n\telse\n\t\tcdev->enabled = FCOE_CTLR_DISABLED;\n\n\tif (link_state == BNX2FC_CREATE_LINK_UP &&\n\t    !bnx2fc_link_ok(lport)) {\n\t\tfcoe_ctlr_link_up(ctlr);\n\t\tfc_host_port_type(lport->host) = FC_PORTTYPE_NPORT;\n\t\tset_bit(ADAPTER_STATE_READY, &interface->hba->adapter_state);\n\t}\n\n\tBNX2FC_HBA_DBG(lport, \"create: START DISC\\n\");\n\tbnx2fc_start_disc(interface);\n\n\tif (link_state == BNX2FC_CREATE_LINK_UP)\n\t\tinterface->enabled = true;\n\n\t \n\tbnx2fc_interface_put(interface);\n\t \n\tmutex_unlock(&bnx2fc_dev_lock);\n\trtnl_unlock();\n\treturn 0;\n\nif_create_err:\n\tdestroy_workqueue(interface->timer_work_queue);\nifput_err:\n\tbnx2fc_net_cleanup(interface);\n\tbnx2fc_interface_put(interface);\n\tgoto mod_err;\nnetdev_err:\n\tmodule_put(THIS_MODULE);\nmod_err:\n\tmutex_unlock(&bnx2fc_dev_lock);\n\trtnl_unlock();\n\treturn rc;\n}\n\n \nstatic int bnx2fc_create(struct net_device *netdev, enum fip_mode fip_mode)\n{\n\treturn _bnx2fc_create(netdev, fip_mode, BNX2FC_CREATE_LINK_UP);\n}\n\n \nstatic int bnx2fc_ctlr_alloc(struct net_device *netdev)\n{\n\treturn _bnx2fc_create(netdev, FIP_MODE_FABRIC,\n\t\t\t      BNX2FC_CREATE_LINK_DOWN);\n}\n\n \nstatic struct bnx2fc_hba *bnx2fc_find_hba_for_cnic(struct cnic_dev *cnic)\n{\n\tstruct bnx2fc_hba *hba;\n\n\t \n\tlist_for_each_entry(hba, &adapter_list, list) {\n\t\tif (hba->cnic == cnic)\n\t\t\treturn hba;\n\t}\n\treturn NULL;\n}\n\nstatic struct bnx2fc_interface *bnx2fc_interface_lookup(struct net_device\n\t\t\t\t\t\t\t*netdev)\n{\n\tstruct bnx2fc_interface *interface;\n\n\t \n\tlist_for_each_entry(interface, &if_list, list) {\n\t\tif (interface->netdev == netdev)\n\t\t\treturn interface;\n\t}\n\treturn NULL;\n}\n\nstatic struct bnx2fc_hba *bnx2fc_hba_lookup(struct net_device\n\t\t\t\t\t\t      *phys_dev)\n{\n\tstruct bnx2fc_hba *hba;\n\n\t \n\tlist_for_each_entry(hba, &adapter_list, list) {\n\t\tif (hba->phys_dev == phys_dev)\n\t\t\treturn hba;\n\t}\n\tprintk(KERN_ERR PFX \"adapter_lookup: hba NULL\\n\");\n\treturn NULL;\n}\n\n \nstatic void bnx2fc_ulp_exit(struct cnic_dev *dev)\n{\n\tstruct bnx2fc_hba *hba;\n\tstruct bnx2fc_interface *interface, *tmp;\n\n\tBNX2FC_MISC_DBG(\"Entered bnx2fc_ulp_exit\\n\");\n\n\tif (!test_bit(CNIC_F_BNX2X_CLASS, &dev->flags)) {\n\t\tprintk(KERN_ERR PFX \"bnx2fc port check: %s, flags: %lx\\n\",\n\t\t\tdev->netdev->name, dev->flags);\n\t\treturn;\n\t}\n\n\tmutex_lock(&bnx2fc_dev_lock);\n\thba = bnx2fc_find_hba_for_cnic(dev);\n\tif (!hba) {\n\t\tprintk(KERN_ERR PFX \"bnx2fc_ulp_exit: hba not found, dev 0%p\\n\",\n\t\t       dev);\n\t\tmutex_unlock(&bnx2fc_dev_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&hba->list);\n\tadapter_count--;\n\n\tlist_for_each_entry_safe(interface, tmp, &if_list, list)\n\t\t \n\t\tif (interface->hba == hba)\n\t\t\t__bnx2fc_destroy(interface);\n\tmutex_unlock(&bnx2fc_dev_lock);\n\n\tbnx2fc_ulp_stop(hba);\n\t \n\tif (test_and_clear_bit(BNX2FC_CNIC_REGISTERED, &hba->reg_with_cnic))\n\t\thba->cnic->unregister_device(hba->cnic, CNIC_ULP_FCOE);\n\tbnx2fc_hba_destroy(hba);\n}\n\nstatic void bnx2fc_rport_terminate_io(struct fc_rport *rport)\n{\n\t \n}\n\n \nstatic int bnx2fc_fcoe_reset(struct Scsi_Host *shost)\n{\n\tstruct fc_lport *lport = shost_priv(shost);\n\tfc_lport_reset(lport);\n\treturn 0;\n}\n\n\nstatic bool bnx2fc_match(struct net_device *netdev)\n{\n\tstruct net_device *phys_dev = netdev;\n\n\tmutex_lock(&bnx2fc_dev_lock);\n\tif (is_vlan_dev(netdev))\n\t\tphys_dev = vlan_dev_real_dev(netdev);\n\n\tif (bnx2fc_hba_lookup(phys_dev)) {\n\t\tmutex_unlock(&bnx2fc_dev_lock);\n\t\treturn true;\n\t}\n\n\tmutex_unlock(&bnx2fc_dev_lock);\n\treturn false;\n}\n\n\nstatic struct fcoe_transport bnx2fc_transport = {\n\t.name = {\"bnx2fc\"},\n\t.attached = false,\n\t.list = LIST_HEAD_INIT(bnx2fc_transport.list),\n\t.alloc = bnx2fc_ctlr_alloc,\n\t.match = bnx2fc_match,\n\t.create = bnx2fc_create,\n\t.destroy = bnx2fc_destroy,\n\t.enable = bnx2fc_enable,\n\t.disable = bnx2fc_disable,\n};\n\n \nstatic int bnx2fc_cpu_online(unsigned int cpu)\n{\n\tstruct bnx2fc_percpu_s *p;\n\tstruct task_struct *thread;\n\n\tp = &per_cpu(bnx2fc_percpu, cpu);\n\n\tthread = kthread_create_on_node(bnx2fc_percpu_io_thread,\n\t\t\t\t\t(void *)p, cpu_to_node(cpu),\n\t\t\t\t\t\"bnx2fc_thread/%d\", cpu);\n\tif (IS_ERR(thread))\n\t\treturn PTR_ERR(thread);\n\n\t \n\tkthread_bind(thread, cpu);\n\tp->iothread = thread;\n\twake_up_process(thread);\n\treturn 0;\n}\n\nstatic int bnx2fc_cpu_offline(unsigned int cpu)\n{\n\tstruct bnx2fc_percpu_s *p;\n\tstruct task_struct *thread;\n\tstruct bnx2fc_work *work, *tmp;\n\n\tBNX2FC_MISC_DBG(\"destroying io thread for CPU %d\\n\", cpu);\n\n\t \n\tp = &per_cpu(bnx2fc_percpu, cpu);\n\tspin_lock_bh(&p->fp_work_lock);\n\tthread = p->iothread;\n\tp->iothread = NULL;\n\n\t \n\tlist_for_each_entry_safe(work, tmp, &p->work_list, list) {\n\t\tlist_del_init(&work->list);\n\t\tbnx2fc_process_cq_compl(work->tgt, work->wqe, work->rq_data,\n\t\t\t\t\twork->num_rq, work->task);\n\t\tkfree(work);\n\t}\n\n\tspin_unlock_bh(&p->fp_work_lock);\n\n\tif (thread)\n\t\tkthread_stop(thread);\n\treturn 0;\n}\n\nstatic int bnx2fc_slave_configure(struct scsi_device *sdev)\n{\n\tif (!bnx2fc_queue_depth)\n\t\treturn 0;\n\n\tscsi_change_queue_depth(sdev, bnx2fc_queue_depth);\n\treturn 0;\n}\n\nstatic enum cpuhp_state bnx2fc_online_state;\n\n \nstatic int __init bnx2fc_mod_init(void)\n{\n\tstruct fcoe_percpu_s *bg;\n\tstruct task_struct *l2_thread;\n\tint rc = 0;\n\tunsigned int cpu = 0;\n\tstruct bnx2fc_percpu_s *p;\n\n\tprintk(KERN_INFO PFX \"%s\", version);\n\n\t \n\trc = fcoe_transport_attach(&bnx2fc_transport);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"failed to register an fcoe transport, check \"\n\t\t\t\"if libfcoe is loaded\\n\");\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&adapter_list);\n\tINIT_LIST_HEAD(&if_list);\n\tmutex_init(&bnx2fc_dev_lock);\n\tadapter_count = 0;\n\n\t \n\trc = bnx2fc_attach_transport();\n\tif (rc)\n\t\tgoto detach_ft;\n\n\tbnx2fc_wq = alloc_workqueue(\"bnx2fc\", 0, 0);\n\tif (!bnx2fc_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto release_bt;\n\t}\n\n\tbg = &bnx2fc_global;\n\tskb_queue_head_init(&bg->fcoe_rx_list);\n\tl2_thread = kthread_run(bnx2fc_l2_rcv_thread,\n\t\t\t\t(void *)bg,\n\t\t\t\t\"bnx2fc_l2_thread\");\n\tif (IS_ERR(l2_thread)) {\n\t\trc = PTR_ERR(l2_thread);\n\t\tgoto free_wq;\n\t}\n\tspin_lock_bh(&bg->fcoe_rx_list.lock);\n\tbg->kthread = l2_thread;\n\tspin_unlock_bh(&bg->fcoe_rx_list.lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tp = &per_cpu(bnx2fc_percpu, cpu);\n\t\tINIT_LIST_HEAD(&p->work_list);\n\t\tspin_lock_init(&p->fp_work_lock);\n\t}\n\n\trc = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"scsi/bnx2fc:online\",\n\t\t\t       bnx2fc_cpu_online, bnx2fc_cpu_offline);\n\tif (rc < 0)\n\t\tgoto stop_thread;\n\tbnx2fc_online_state = rc;\n\n\tcnic_register_driver(CNIC_ULP_FCOE, &bnx2fc_cnic_cb);\n\treturn 0;\n\nstop_thread:\n\tkthread_stop(l2_thread);\nfree_wq:\n\tdestroy_workqueue(bnx2fc_wq);\nrelease_bt:\n\tbnx2fc_release_transport();\ndetach_ft:\n\tfcoe_transport_detach(&bnx2fc_transport);\nout:\n\treturn rc;\n}\n\nstatic void __exit bnx2fc_mod_exit(void)\n{\n\tLIST_HEAD(to_be_deleted);\n\tstruct bnx2fc_hba *hba, *next;\n\tstruct fcoe_percpu_s *bg;\n\tstruct task_struct *l2_thread;\n\tstruct sk_buff *skb;\n\n\t \n\tmutex_lock(&bnx2fc_dev_lock);\n\tlist_splice_init(&adapter_list, &to_be_deleted);\n\tadapter_count = 0;\n\tmutex_unlock(&bnx2fc_dev_lock);\n\n\t \n\tlist_for_each_entry_safe(hba, next, &to_be_deleted, list) {\n\t\tlist_del_init(&hba->list);\n\t\tprintk(KERN_ERR PFX \"MOD_EXIT:destroy hba = 0x%p\\n\",\n\t\t       hba);\n\t\tbnx2fc_ulp_stop(hba);\n\t\t \n\t\tif (test_and_clear_bit(BNX2FC_CNIC_REGISTERED,\n\t\t\t\t       &hba->reg_with_cnic))\n\t\t\thba->cnic->unregister_device(hba->cnic,\n\t\t\t\t\t\t\t CNIC_ULP_FCOE);\n\t\tbnx2fc_hba_destroy(hba);\n\t}\n\tcnic_unregister_driver(CNIC_ULP_FCOE);\n\n\t \n\tbg = &bnx2fc_global;\n\tspin_lock_bh(&bg->fcoe_rx_list.lock);\n\tl2_thread = bg->kthread;\n\tbg->kthread = NULL;\n\twhile ((skb = __skb_dequeue(&bg->fcoe_rx_list)) != NULL)\n\t\tkfree_skb(skb);\n\n\tspin_unlock_bh(&bg->fcoe_rx_list.lock);\n\n\tif (l2_thread)\n\t\tkthread_stop(l2_thread);\n\n\tcpuhp_remove_state(bnx2fc_online_state);\n\n\tdestroy_workqueue(bnx2fc_wq);\n\t \n\tbnx2fc_release_transport();\n\n\t \n\tfcoe_transport_detach(&bnx2fc_transport);\n}\n\nmodule_init(bnx2fc_mod_init);\nmodule_exit(bnx2fc_mod_exit);\n\nstatic struct fcoe_sysfs_function_template bnx2fc_fcoe_sysfs_templ = {\n\t.set_fcoe_ctlr_enabled = bnx2fc_ctlr_enabled,\n\t.get_fcoe_ctlr_link_fail = fcoe_ctlr_get_lesb,\n\t.get_fcoe_ctlr_vlink_fail = fcoe_ctlr_get_lesb,\n\t.get_fcoe_ctlr_miss_fka = fcoe_ctlr_get_lesb,\n\t.get_fcoe_ctlr_symb_err = fcoe_ctlr_get_lesb,\n\t.get_fcoe_ctlr_err_block = fcoe_ctlr_get_lesb,\n\t.get_fcoe_ctlr_fcs_error = fcoe_ctlr_get_lesb,\n\n\t.get_fcoe_fcf_selected = fcoe_fcf_get_selected,\n\t.get_fcoe_fcf_vlan_id = bnx2fc_fcf_get_vlan_id,\n};\n\nstatic struct fc_function_template bnx2fc_transport_function = {\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_active_fc4s = 1,\n\t.show_host_maxframe_size = 1,\n\n\t.show_host_port_id = 1,\n\t.show_host_supported_speeds = 1,\n\t.get_host_speed = fc_get_host_speed,\n\t.show_host_speed = 1,\n\t.show_host_port_type = 1,\n\t.get_host_port_state = fc_get_host_port_state,\n\t.show_host_port_state = 1,\n\t.show_host_symbolic_name = 1,\n\n\t.dd_fcrport_size = (sizeof(struct fc_rport_libfc_priv) +\n\t\t\t\tsizeof(struct bnx2fc_rport)),\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\n\t.show_host_fabric_name = 1,\n\t.show_starget_node_name = 1,\n\t.show_starget_port_name = 1,\n\t.show_starget_port_id = 1,\n\t.set_rport_dev_loss_tmo = fc_set_rport_loss_tmo,\n\t.show_rport_dev_loss_tmo = 1,\n\t.get_fc_host_stats = bnx2fc_get_host_stats,\n\n\t.issue_fc_host_lip = bnx2fc_fcoe_reset,\n\n\t.terminate_rport_io = bnx2fc_rport_terminate_io,\n\n\t.vport_create = bnx2fc_vport_create,\n\t.vport_delete = bnx2fc_vport_destroy,\n\t.vport_disable = bnx2fc_vport_disable,\n\t.bsg_request = fc_lport_bsg_request,\n};\n\nstatic struct fc_function_template bnx2fc_vport_xport_function = {\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_active_fc4s = 1,\n\t.show_host_maxframe_size = 1,\n\n\t.show_host_port_id = 1,\n\t.show_host_supported_speeds = 1,\n\t.get_host_speed = fc_get_host_speed,\n\t.show_host_speed = 1,\n\t.show_host_port_type = 1,\n\t.get_host_port_state = fc_get_host_port_state,\n\t.show_host_port_state = 1,\n\t.show_host_symbolic_name = 1,\n\n\t.dd_fcrport_size = (sizeof(struct fc_rport_libfc_priv) +\n\t\t\t\tsizeof(struct bnx2fc_rport)),\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\n\t.show_host_fabric_name = 1,\n\t.show_starget_node_name = 1,\n\t.show_starget_port_name = 1,\n\t.show_starget_port_id = 1,\n\t.set_rport_dev_loss_tmo = fc_set_rport_loss_tmo,\n\t.show_rport_dev_loss_tmo = 1,\n\t.get_fc_host_stats = fc_get_host_stats,\n\t.issue_fc_host_lip = bnx2fc_fcoe_reset,\n\t.terminate_rport_io = fc_rport_terminate_io,\n\t.bsg_request = fc_lport_bsg_request,\n};\n\n \nstatic ssize_t\nbnx2fc_tm_timeout_show(struct device *dev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct fc_lport *lport = shost_priv(shost);\n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct bnx2fc_interface *interface = port->priv;\n\n\tsprintf(buf, \"%u\\n\", interface->tm_timeout);\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nbnx2fc_tm_timeout_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct fc_lport *lport = shost_priv(shost);\n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct bnx2fc_interface *interface = port->priv;\n\tint rval, val;\n\n\trval = kstrtouint(buf, 10, &val);\n\tif (rval)\n\t\treturn rval;\n\tif (val > 255)\n\t\treturn -ERANGE;\n\n\tinterface->tm_timeout = (u8)val;\n\treturn strlen(buf);\n}\n\nstatic DEVICE_ATTR(tm_timeout, S_IRUGO|S_IWUSR, bnx2fc_tm_timeout_show,\n\tbnx2fc_tm_timeout_store);\n\nstatic struct attribute *bnx2fc_host_attrs[] = {\n\t&dev_attr_tm_timeout.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(bnx2fc_host);\n\n \nstatic struct scsi_host_template bnx2fc_shost_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"QLogic Offload FCoE Initiator\",\n\t.queuecommand\t\t= bnx2fc_queuecommand,\n\t.eh_timed_out\t\t= fc_eh_timed_out,\n\t.eh_abort_handler\t= bnx2fc_eh_abort,\t   \n\t.eh_device_reset_handler = bnx2fc_eh_device_reset,  \n\t.eh_target_reset_handler = bnx2fc_eh_target_reset,  \n\t.eh_host_reset_handler\t= fc_eh_host_reset,\n\t.slave_alloc\t\t= fc_slave_alloc,\n\t.change_queue_depth\t= scsi_change_queue_depth,\n\t.this_id\t\t= -1,\n\t.cmd_per_lun\t\t= 3,\n\t.sg_tablesize\t\t= BNX2FC_MAX_BDS_PER_CMD,\n\t.dma_boundary           = 0x7fff,\n\t.max_sectors\t\t= 0x3fbf,\n\t.track_queue_depth\t= 1,\n\t.slave_configure\t= bnx2fc_slave_configure,\n\t.shost_groups\t\t= bnx2fc_host_groups,\n\t.cmd_size\t\t= sizeof(struct bnx2fc_priv),\n};\n\nstatic struct libfc_function_template bnx2fc_libfc_fcn_templ = {\n\t.frame_send\t\t= bnx2fc_xmit,\n\t.elsct_send\t\t= bnx2fc_elsct_send,\n\t.fcp_abort_io\t\t= bnx2fc_abort_io,\n\t.fcp_cleanup\t\t= bnx2fc_cleanup,\n\t.get_lesb\t\t= fcoe_get_lesb,\n\t.rport_event_callback\t= bnx2fc_rport_event_handler,\n};\n\n \nstatic struct cnic_ulp_ops bnx2fc_cnic_cb = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.cnic_init\t\t= bnx2fc_ulp_init,\n\t.cnic_exit\t\t= bnx2fc_ulp_exit,\n\t.cnic_start\t\t= bnx2fc_ulp_start,\n\t.cnic_stop\t\t= bnx2fc_ulp_stop,\n\t.indicate_kcqes\t\t= bnx2fc_indicate_kcqe,\n\t.indicate_netevent\t= bnx2fc_indicate_netevent,\n\t.cnic_get_stats\t\t= bnx2fc_ulp_get_stats,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}