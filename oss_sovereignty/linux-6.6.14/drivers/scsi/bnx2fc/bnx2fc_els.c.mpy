{
  "module_name": "bnx2fc_els.c",
  "hash_id": "c6f1e68373d41c26345d9149d4a602cec69a963a325b587b7621de340dd87f5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bnx2fc/bnx2fc_els.c",
  "human_readable_source": " \n\n#include \"bnx2fc.h\"\n\nstatic void bnx2fc_logo_resp(struct fc_seq *seq, struct fc_frame *fp,\n\t\t\t     void *arg);\nstatic void bnx2fc_flogi_resp(struct fc_seq *seq, struct fc_frame *fp,\n\t\t\t      void *arg);\nstatic int bnx2fc_initiate_els(struct bnx2fc_rport *tgt, unsigned int op,\n\t\t\tvoid *data, u32 data_len,\n\t\t\tvoid (*cb_func)(struct bnx2fc_els_cb_arg *cb_arg),\n\t\t\tstruct bnx2fc_els_cb_arg *cb_arg, u32 timer_msec);\n\nstatic void bnx2fc_rrq_compl(struct bnx2fc_els_cb_arg *cb_arg)\n{\n\tstruct bnx2fc_cmd *orig_io_req;\n\tstruct bnx2fc_cmd *rrq_req;\n\tint rc = 0;\n\n\tBUG_ON(!cb_arg);\n\trrq_req = cb_arg->io_req;\n\torig_io_req = cb_arg->aborted_io_req;\n\tBUG_ON(!orig_io_req);\n\tBNX2FC_ELS_DBG(\"rrq_compl: orig xid = 0x%x, rrq_xid = 0x%x\\n\",\n\t\t   orig_io_req->xid, rrq_req->xid);\n\n\tkref_put(&orig_io_req->refcount, bnx2fc_cmd_release);\n\n\tif (test_and_clear_bit(BNX2FC_FLAG_ELS_TIMEOUT, &rrq_req->req_flags)) {\n\t\t \n\t\tBNX2FC_ELS_DBG(\"rrq xid - 0x%x timed out, clean it up\\n\",\n\t\t\t   rrq_req->xid);\n\n\t\tif (rrq_req->on_active_queue) {\n\t\t\tlist_del_init(&rrq_req->link);\n\t\t\trrq_req->on_active_queue = 0;\n\t\t\trc = bnx2fc_initiate_cleanup(rrq_req);\n\t\t\tBUG_ON(rc);\n\t\t}\n\t}\n\tkfree(cb_arg);\n}\nint bnx2fc_send_rrq(struct bnx2fc_cmd *aborted_io_req)\n{\n\n\tstruct fc_els_rrq rrq;\n\tstruct bnx2fc_rport *tgt = aborted_io_req->tgt;\n\tstruct fc_lport *lport = NULL;\n\tstruct bnx2fc_els_cb_arg *cb_arg = NULL;\n\tu32 sid = 0;\n\tu32 r_a_tov = 0;\n\tunsigned long start = jiffies;\n\tint rc;\n\n\tif (!test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags))\n\t\treturn -EINVAL;\n\n\tlport = tgt->rdata->local_port;\n\tsid = tgt->sid;\n\tr_a_tov = lport->r_a_tov;\n\n\tBNX2FC_ELS_DBG(\"Sending RRQ orig_xid = 0x%x\\n\",\n\t\t   aborted_io_req->xid);\n\tmemset(&rrq, 0, sizeof(rrq));\n\n\tcb_arg = kzalloc(sizeof(struct bnx2fc_els_cb_arg), GFP_NOIO);\n\tif (!cb_arg) {\n\t\tprintk(KERN_ERR PFX \"Unable to allocate cb_arg for RRQ\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto rrq_err;\n\t}\n\n\tcb_arg->aborted_io_req = aborted_io_req;\n\n\trrq.rrq_cmd = ELS_RRQ;\n\thton24(rrq.rrq_s_id, sid);\n\trrq.rrq_ox_id = htons(aborted_io_req->xid);\n\trrq.rrq_rx_id = htons(aborted_io_req->task->rxwr_txrd.var_ctx.rx_id);\n\nretry_rrq:\n\trc = bnx2fc_initiate_els(tgt, ELS_RRQ, &rrq, sizeof(rrq),\n\t\t\t\t bnx2fc_rrq_compl, cb_arg,\n\t\t\t\t r_a_tov);\n\tif (rc == -ENOMEM) {\n\t\tif (time_after(jiffies, start + (10 * HZ))) {\n\t\t\tBNX2FC_ELS_DBG(\"rrq Failed\\n\");\n\t\t\trc = FAILED;\n\t\t\tgoto rrq_err;\n\t\t}\n\t\tmsleep(20);\n\t\tgoto retry_rrq;\n\t}\nrrq_err:\n\tif (rc) {\n\t\tBNX2FC_ELS_DBG(\"RRQ failed - release orig io req 0x%x\\n\",\n\t\t\taborted_io_req->xid);\n\t\tkfree(cb_arg);\n\t\tspin_lock_bh(&tgt->tgt_lock);\n\t\tkref_put(&aborted_io_req->refcount, bnx2fc_cmd_release);\n\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t}\n\treturn rc;\n}\n\nstatic void bnx2fc_l2_els_compl(struct bnx2fc_els_cb_arg *cb_arg)\n{\n\tstruct bnx2fc_cmd *els_req;\n\tstruct bnx2fc_rport *tgt;\n\tstruct bnx2fc_mp_req *mp_req;\n\tstruct fc_frame_header *fc_hdr;\n\tunsigned char *buf;\n\tvoid *resp_buf;\n\tu32 resp_len, hdr_len;\n\tu16 l2_oxid;\n\tint frame_len;\n\tint rc = 0;\n\n\tl2_oxid = cb_arg->l2_oxid;\n\tBNX2FC_ELS_DBG(\"ELS COMPL - l2_oxid = 0x%x\\n\", l2_oxid);\n\n\tels_req = cb_arg->io_req;\n\tif (test_and_clear_bit(BNX2FC_FLAG_ELS_TIMEOUT, &els_req->req_flags)) {\n\t\t \n\t\tif (els_req->on_active_queue) {\n\t\t\tlist_del_init(&els_req->link);\n\t\t\tels_req->on_active_queue = 0;\n\t\t\trc = bnx2fc_initiate_cleanup(els_req);\n\t\t\tBUG_ON(rc);\n\t\t}\n\t\tgoto free_arg;\n\t}\n\n\ttgt = els_req->tgt;\n\tmp_req = &(els_req->mp_req);\n\tfc_hdr = &(mp_req->resp_fc_hdr);\n\tresp_len = mp_req->resp_len;\n\tresp_buf = mp_req->resp_buf;\n\n\tbuf = kzalloc(PAGE_SIZE, GFP_ATOMIC);\n\tif (!buf) {\n\t\tprintk(KERN_ERR PFX \"Unable to alloc mp buf\\n\");\n\t\tgoto free_arg;\n\t}\n\thdr_len = sizeof(*fc_hdr);\n\tif (hdr_len + resp_len > PAGE_SIZE) {\n\t\tprintk(KERN_ERR PFX \"l2_els_compl: resp len is \"\n\t\t\t\t    \"beyond page size\\n\");\n\t\tgoto free_buf;\n\t}\n\tmemcpy(buf, fc_hdr, hdr_len);\n\tmemcpy(buf + hdr_len, resp_buf, resp_len);\n\tframe_len = hdr_len + resp_len;\n\n\tbnx2fc_process_l2_frame_compl(tgt, buf, frame_len, l2_oxid);\n\nfree_buf:\n\tkfree(buf);\nfree_arg:\n\tkfree(cb_arg);\n}\n\nint bnx2fc_send_adisc(struct bnx2fc_rport *tgt, struct fc_frame *fp)\n{\n\tstruct fc_els_adisc *adisc;\n\tstruct fc_frame_header *fh;\n\tstruct bnx2fc_els_cb_arg *cb_arg;\n\tstruct fc_lport *lport = tgt->rdata->local_port;\n\tu32 r_a_tov = lport->r_a_tov;\n\tint rc;\n\n\tfh = fc_frame_header_get(fp);\n\tcb_arg = kzalloc(sizeof(struct bnx2fc_els_cb_arg), GFP_ATOMIC);\n\tif (!cb_arg) {\n\t\tprintk(KERN_ERR PFX \"Unable to allocate cb_arg for ADISC\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcb_arg->l2_oxid = ntohs(fh->fh_ox_id);\n\n\tBNX2FC_ELS_DBG(\"send ADISC: l2_oxid = 0x%x\\n\", cb_arg->l2_oxid);\n\tadisc = fc_frame_payload_get(fp, sizeof(*adisc));\n\t \n\trc = bnx2fc_initiate_els(tgt, ELS_ADISC, adisc, sizeof(*adisc),\n\t\t\t\t bnx2fc_l2_els_compl, cb_arg, 2 * r_a_tov);\n\tif (rc)\n\t\tkfree(cb_arg);\n\treturn rc;\n}\n\nint bnx2fc_send_logo(struct bnx2fc_rport *tgt, struct fc_frame *fp)\n{\n\tstruct fc_els_logo *logo;\n\tstruct fc_frame_header *fh;\n\tstruct bnx2fc_els_cb_arg *cb_arg;\n\tstruct fc_lport *lport = tgt->rdata->local_port;\n\tu32 r_a_tov = lport->r_a_tov;\n\tint rc;\n\n\tfh = fc_frame_header_get(fp);\n\tcb_arg = kzalloc(sizeof(struct bnx2fc_els_cb_arg), GFP_ATOMIC);\n\tif (!cb_arg) {\n\t\tprintk(KERN_ERR PFX \"Unable to allocate cb_arg for LOGO\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcb_arg->l2_oxid = ntohs(fh->fh_ox_id);\n\n\tBNX2FC_ELS_DBG(\"Send LOGO: l2_oxid = 0x%x\\n\", cb_arg->l2_oxid);\n\tlogo = fc_frame_payload_get(fp, sizeof(*logo));\n\t \n\trc = bnx2fc_initiate_els(tgt, ELS_LOGO, logo, sizeof(*logo),\n\t\t\t\t bnx2fc_l2_els_compl, cb_arg, 2 * r_a_tov);\n\tif (rc)\n\t\tkfree(cb_arg);\n\treturn rc;\n}\n\nint bnx2fc_send_rls(struct bnx2fc_rport *tgt, struct fc_frame *fp)\n{\n\tstruct fc_els_rls *rls;\n\tstruct fc_frame_header *fh;\n\tstruct bnx2fc_els_cb_arg *cb_arg;\n\tstruct fc_lport *lport = tgt->rdata->local_port;\n\tu32 r_a_tov = lport->r_a_tov;\n\tint rc;\n\n\tfh = fc_frame_header_get(fp);\n\tcb_arg = kzalloc(sizeof(struct bnx2fc_els_cb_arg), GFP_ATOMIC);\n\tif (!cb_arg) {\n\t\tprintk(KERN_ERR PFX \"Unable to allocate cb_arg for LOGO\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcb_arg->l2_oxid = ntohs(fh->fh_ox_id);\n\n\trls = fc_frame_payload_get(fp, sizeof(*rls));\n\t \n\trc = bnx2fc_initiate_els(tgt, ELS_RLS, rls, sizeof(*rls),\n\t\t\t\t  bnx2fc_l2_els_compl, cb_arg, 2 * r_a_tov);\n\tif (rc)\n\t\tkfree(cb_arg);\n\treturn rc;\n}\n\nstatic void bnx2fc_srr_compl(struct bnx2fc_els_cb_arg *cb_arg)\n{\n\tstruct bnx2fc_mp_req *mp_req;\n\tstruct fc_frame_header *fc_hdr, *fh;\n\tstruct bnx2fc_cmd *srr_req;\n\tstruct bnx2fc_cmd *orig_io_req;\n\tstruct fc_frame *fp;\n\tunsigned char *buf;\n\tvoid *resp_buf;\n\tu32 resp_len, hdr_len;\n\tu8 opcode;\n\tint rc = 0;\n\n\torig_io_req = cb_arg->aborted_io_req;\n\tsrr_req = cb_arg->io_req;\n\tif (test_and_clear_bit(BNX2FC_FLAG_ELS_TIMEOUT, &srr_req->req_flags)) {\n\t\t \n\t\tBNX2FC_IO_DBG(srr_req, \"srr timed out, abort \"\n\t\t       \"orig_io - 0x%x\\n\",\n\t\t\torig_io_req->xid);\n\t\trc = bnx2fc_initiate_abts(srr_req);\n\t\tif (rc != SUCCESS) {\n\t\t\tBNX2FC_IO_DBG(srr_req, \"srr_compl: initiate_abts \"\n\t\t\t\t\"failed. issue cleanup\\n\");\n\t\t\tbnx2fc_initiate_cleanup(srr_req);\n\t\t}\n\t\tif (test_bit(BNX2FC_FLAG_IO_COMPL, &orig_io_req->req_flags) ||\n\t\t    test_bit(BNX2FC_FLAG_ISSUE_ABTS, &orig_io_req->req_flags)) {\n\t\t\tBNX2FC_IO_DBG(srr_req, \"srr_compl:xid 0x%x flags = %lx\",\n\t\t\t\t      orig_io_req->xid, orig_io_req->req_flags);\n\t\t\tgoto srr_compl_done;\n\t\t}\n\t\torig_io_req->srr_retry++;\n\t\tif (orig_io_req->srr_retry <= SRR_RETRY_COUNT) {\n\t\t\tstruct bnx2fc_rport *tgt = orig_io_req->tgt;\n\t\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t\t\trc = bnx2fc_send_srr(orig_io_req,\n\t\t\t\t\t     orig_io_req->srr_offset,\n\t\t\t\t\t     orig_io_req->srr_rctl);\n\t\t\tspin_lock_bh(&tgt->tgt_lock);\n\t\t\tif (!rc)\n\t\t\t\tgoto srr_compl_done;\n\t\t}\n\n\t\trc = bnx2fc_initiate_abts(orig_io_req);\n\t\tif (rc != SUCCESS) {\n\t\t\tBNX2FC_IO_DBG(srr_req, \"srr_compl: initiate_abts \"\n\t\t\t\t\"failed xid = 0x%x. issue cleanup\\n\",\n\t\t\t\torig_io_req->xid);\n\t\t\tbnx2fc_initiate_cleanup(orig_io_req);\n\t\t}\n\t\tgoto srr_compl_done;\n\t}\n\tif (test_bit(BNX2FC_FLAG_IO_COMPL, &orig_io_req->req_flags) ||\n\t    test_bit(BNX2FC_FLAG_ISSUE_ABTS, &orig_io_req->req_flags)) {\n\t\tBNX2FC_IO_DBG(srr_req, \"srr_compl:xid - 0x%x flags = %lx\",\n\t\t\t      orig_io_req->xid, orig_io_req->req_flags);\n\t\tgoto srr_compl_done;\n\t}\n\tmp_req = &(srr_req->mp_req);\n\tfc_hdr = &(mp_req->resp_fc_hdr);\n\tresp_len = mp_req->resp_len;\n\tresp_buf = mp_req->resp_buf;\n\n\thdr_len = sizeof(*fc_hdr);\n\tbuf = kzalloc(PAGE_SIZE, GFP_ATOMIC);\n\tif (!buf) {\n\t\tprintk(KERN_ERR PFX \"srr buf: mem alloc failure\\n\");\n\t\tgoto srr_compl_done;\n\t}\n\tmemcpy(buf, fc_hdr, hdr_len);\n\tmemcpy(buf + hdr_len, resp_buf, resp_len);\n\n\tfp = fc_frame_alloc(NULL, resp_len);\n\tif (!fp) {\n\t\tprintk(KERN_ERR PFX \"fc_frame_alloc failure\\n\");\n\t\tgoto free_buf;\n\t}\n\n\tfh = (struct fc_frame_header *) fc_frame_header_get(fp);\n\t \n\tmemcpy(fh, buf, hdr_len + resp_len);\n\n\topcode = fc_frame_payload_op(fp);\n\tswitch (opcode) {\n\tcase ELS_LS_ACC:\n\t\tBNX2FC_IO_DBG(srr_req, \"SRR success\\n\");\n\t\tbreak;\n\tcase ELS_LS_RJT:\n\t\tBNX2FC_IO_DBG(srr_req, \"SRR rejected\\n\");\n\t\trc = bnx2fc_initiate_abts(orig_io_req);\n\t\tif (rc != SUCCESS) {\n\t\t\tBNX2FC_IO_DBG(srr_req, \"srr_compl: initiate_abts \"\n\t\t\t\t\"failed xid = 0x%x. issue cleanup\\n\",\n\t\t\t\torig_io_req->xid);\n\t\t\tbnx2fc_initiate_cleanup(orig_io_req);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBNX2FC_IO_DBG(srr_req, \"srr compl - invalid opcode = %d\\n\",\n\t\t\topcode);\n\t\tbreak;\n\t}\n\tfc_frame_free(fp);\nfree_buf:\n\tkfree(buf);\nsrr_compl_done:\n\tkref_put(&orig_io_req->refcount, bnx2fc_cmd_release);\n}\n\nstatic void bnx2fc_rec_compl(struct bnx2fc_els_cb_arg *cb_arg)\n{\n\tstruct bnx2fc_cmd *orig_io_req, *new_io_req;\n\tstruct bnx2fc_cmd *rec_req;\n\tstruct bnx2fc_mp_req *mp_req;\n\tstruct fc_frame_header *fc_hdr, *fh;\n\tstruct fc_els_ls_rjt *rjt;\n\tstruct fc_els_rec_acc *acc;\n\tstruct bnx2fc_rport *tgt;\n\tstruct fcoe_err_report_entry *err_entry;\n\tstruct scsi_cmnd *sc_cmd;\n\tenum fc_rctl r_ctl;\n\tunsigned char *buf;\n\tvoid *resp_buf;\n\tstruct fc_frame *fp;\n\tu8 opcode;\n\tu32 offset;\n\tu32 e_stat;\n\tu32 resp_len, hdr_len;\n\tint rc = 0;\n\tbool send_seq_clnp = false;\n\tbool abort_io = false;\n\n\tBNX2FC_MISC_DBG(\"Entered rec_compl callback\\n\");\n\trec_req = cb_arg->io_req;\n\torig_io_req = cb_arg->aborted_io_req;\n\tBNX2FC_IO_DBG(rec_req, \"rec_compl: orig xid = 0x%x\", orig_io_req->xid);\n\ttgt = orig_io_req->tgt;\n\n\t \n\tif (test_and_clear_bit(BNX2FC_FLAG_ELS_TIMEOUT, &rec_req->req_flags)) {\n\t\tBNX2FC_IO_DBG(rec_req, \"timed out, abort \"\n\t\t       \"orig_io - 0x%x\\n\",\n\t\t\torig_io_req->xid);\n\t\t \n\t\trc = bnx2fc_initiate_abts(rec_req);\n\t\tif (rc != SUCCESS) {\n\t\t\tBNX2FC_IO_DBG(rec_req, \"rec_compl: initiate_abts \"\n\t\t\t\t\"failed. issue cleanup\\n\");\n\t\t\tbnx2fc_initiate_cleanup(rec_req);\n\t\t}\n\t\torig_io_req->rec_retry++;\n\t\t \n\t\tif (orig_io_req->rec_retry <= REC_RETRY_COUNT) {\n\t\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t\t\trc = bnx2fc_send_rec(orig_io_req);\n\t\t\tspin_lock_bh(&tgt->tgt_lock);\n\t\t\tif (!rc)\n\t\t\t\tgoto rec_compl_done;\n\t\t}\n\t\trc = bnx2fc_initiate_abts(orig_io_req);\n\t\tif (rc != SUCCESS) {\n\t\t\tBNX2FC_IO_DBG(rec_req, \"rec_compl: initiate_abts \"\n\t\t\t\t\"failed xid = 0x%x. issue cleanup\\n\",\n\t\t\t\torig_io_req->xid);\n\t\t\tbnx2fc_initiate_cleanup(orig_io_req);\n\t\t}\n\t\tgoto rec_compl_done;\n\t}\n\n\tif (test_bit(BNX2FC_FLAG_IO_COMPL, &orig_io_req->req_flags)) {\n\t\tBNX2FC_IO_DBG(rec_req, \"completed\"\n\t\t       \"orig_io - 0x%x\\n\",\n\t\t\torig_io_req->xid);\n\t\tgoto rec_compl_done;\n\t}\n\tif (test_bit(BNX2FC_FLAG_ISSUE_ABTS, &orig_io_req->req_flags)) {\n\t\tBNX2FC_IO_DBG(rec_req, \"abts in prog \"\n\t\t       \"orig_io - 0x%x\\n\",\n\t\t\torig_io_req->xid);\n\t\tgoto rec_compl_done;\n\t}\n\n\tmp_req = &(rec_req->mp_req);\n\tfc_hdr = &(mp_req->resp_fc_hdr);\n\tresp_len = mp_req->resp_len;\n\tacc = resp_buf = mp_req->resp_buf;\n\n\thdr_len = sizeof(*fc_hdr);\n\n\tbuf = kzalloc(PAGE_SIZE, GFP_ATOMIC);\n\tif (!buf) {\n\t\tprintk(KERN_ERR PFX \"rec buf: mem alloc failure\\n\");\n\t\tgoto rec_compl_done;\n\t}\n\tmemcpy(buf, fc_hdr, hdr_len);\n\tmemcpy(buf + hdr_len, resp_buf, resp_len);\n\n\tfp = fc_frame_alloc(NULL, resp_len);\n\tif (!fp) {\n\t\tprintk(KERN_ERR PFX \"fc_frame_alloc failure\\n\");\n\t\tgoto free_buf;\n\t}\n\n\tfh = (struct fc_frame_header *) fc_frame_header_get(fp);\n\t \n\tmemcpy(fh, buf, hdr_len + resp_len);\n\n\topcode = fc_frame_payload_op(fp);\n\tif (opcode == ELS_LS_RJT) {\n\t\tBNX2FC_IO_DBG(rec_req, \"opcode is RJT\\n\");\n\t\trjt = fc_frame_payload_get(fp, sizeof(*rjt));\n\t\tif ((rjt->er_reason == ELS_RJT_LOGIC ||\n\t\t    rjt->er_reason == ELS_RJT_UNAB) &&\n\t\t    rjt->er_explan == ELS_EXPL_OXID_RXID) {\n\t\t\tBNX2FC_IO_DBG(rec_req, \"handle CMD LOST case\\n\");\n\t\t\tnew_io_req = bnx2fc_cmd_alloc(tgt);\n\t\t\tif (!new_io_req)\n\t\t\t\tgoto abort_io;\n\t\t\tnew_io_req->sc_cmd = orig_io_req->sc_cmd;\n\t\t\t \n\t\t\tset_bit(BNX2FC_FLAG_CMD_LOST,\n\t\t\t\t&orig_io_req->req_flags);\n\t\t\tbnx2fc_initiate_cleanup(orig_io_req);\n\t\t\t \n\t\t\tBNX2FC_IO_DBG(rec_req, \"Post IO request again\\n\");\n\t\t\trc = bnx2fc_post_io_req(tgt, new_io_req);\n\t\t\tif (!rc)\n\t\t\t\tgoto free_frame;\n\t\t\tBNX2FC_IO_DBG(rec_req, \"REC: io post err\\n\");\n\t\t}\nabort_io:\n\t\trc = bnx2fc_initiate_abts(orig_io_req);\n\t\tif (rc != SUCCESS) {\n\t\t\tBNX2FC_IO_DBG(rec_req, \"rec_compl: initiate_abts \"\n\t\t\t\t\"failed. issue cleanup\\n\");\n\t\t\tbnx2fc_initiate_cleanup(orig_io_req);\n\t\t}\n\t} else if (opcode == ELS_LS_ACC) {\n\t\t \n\t\toffset = ntohl(acc->reca_fc4value);\n\t\te_stat = ntohl(acc->reca_e_stat);\n\t\tif (e_stat & ESB_ST_SEQ_INIT)  {\n\t\t\tBNX2FC_IO_DBG(rec_req, \"target has the seq init\\n\");\n\t\t\tgoto free_frame;\n\t\t}\n\t\tBNX2FC_IO_DBG(rec_req, \"e_stat = 0x%x, offset = 0x%x\\n\",\n\t\t\te_stat, offset);\n\t\t \n\t\terr_entry = (struct fcoe_err_report_entry *)\n\t\t\t     &orig_io_req->err_entry;\n\t\tsc_cmd = orig_io_req->sc_cmd;\n\t\tif (sc_cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\t\t \n\t\t\tif (offset == orig_io_req->data_xfer_len) {\n\t\t\t\tBNX2FC_IO_DBG(rec_req, \"WRITE - resp lost\\n\");\n\t\t\t\t \n\t\t\t\tr_ctl = FC_RCTL_DD_CMD_STATUS;\n\t\t\t\toffset = 0;\n\t\t\t} else  {\n\t\t\t\t \n\t\t\t\tBNX2FC_IO_DBG(rec_req, \"XFER_RDY/DATA lost\\n\");\n\t\t\t\tsend_seq_clnp = true;\n\t\t\t\tr_ctl = FC_RCTL_DD_DATA_DESC;\n\t\t\t\tif (bnx2fc_initiate_seq_cleanup(orig_io_req,\n\t\t\t\t\t\t\t\toffset, r_ctl))\n\t\t\t\t\tabort_io = true;\n\t\t\t\t \n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (err_entry->data.rx_buf_off ==\n\t\t\t\t\torig_io_req->data_xfer_len) {\n\t\t\t\t \n\t\t\t\tBNX2FC_IO_DBG(rec_req, \"READ - resp lost\\n\");\n\t\t\t\tr_ctl = FC_RCTL_DD_CMD_STATUS;\n\t\t\t\toffset = 0;\n\t\t\t} else  {\n\t\t\t\t \n\t\t\t\tsend_seq_clnp = true;\n\t\t\t\toffset = err_entry->data.rx_buf_off;\n\t\t\t\tBNX2FC_IO_DBG(rec_req, \"RD DATA lost\\n\");\n\t\t\t\t \n\t\t\t\tr_ctl = FC_RCTL_DD_SOL_DATA;\n\t\t\t\tif (bnx2fc_initiate_seq_cleanup(orig_io_req,\n\t\t\t\t\t\t\t\toffset, r_ctl))\n\t\t\t\t\tabort_io = true;\n\t\t\t}\n\t\t}\n\t\tif (abort_io) {\n\t\t\trc = bnx2fc_initiate_abts(orig_io_req);\n\t\t\tif (rc != SUCCESS) {\n\t\t\t\tBNX2FC_IO_DBG(rec_req, \"rec_compl:initiate_abts\"\n\t\t\t\t\t      \" failed. issue cleanup\\n\");\n\t\t\t\tbnx2fc_initiate_cleanup(orig_io_req);\n\t\t\t}\n\t\t} else if (!send_seq_clnp) {\n\t\t\tBNX2FC_IO_DBG(rec_req, \"Send SRR - FCP_RSP\\n\");\n\t\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t\t\trc = bnx2fc_send_srr(orig_io_req, offset, r_ctl);\n\t\t\tspin_lock_bh(&tgt->tgt_lock);\n\n\t\t\tif (rc) {\n\t\t\t\tBNX2FC_IO_DBG(rec_req, \"Unable to send SRR\"\n\t\t\t\t\t\" IO will abort\\n\");\n\t\t\t}\n\t\t}\n\t}\nfree_frame:\n\tfc_frame_free(fp);\nfree_buf:\n\tkfree(buf);\nrec_compl_done:\n\tkref_put(&orig_io_req->refcount, bnx2fc_cmd_release);\n\tkfree(cb_arg);\n}\n\nint bnx2fc_send_rec(struct bnx2fc_cmd *orig_io_req)\n{\n\tstruct fc_els_rec rec;\n\tstruct bnx2fc_rport *tgt = orig_io_req->tgt;\n\tstruct fc_lport *lport = tgt->rdata->local_port;\n\tstruct bnx2fc_els_cb_arg *cb_arg = NULL;\n\tu32 sid = tgt->sid;\n\tu32 r_a_tov = lport->r_a_tov;\n\tint rc;\n\n\tBNX2FC_IO_DBG(orig_io_req, \"Sending REC\\n\");\n\tmemset(&rec, 0, sizeof(rec));\n\n\tcb_arg = kzalloc(sizeof(struct bnx2fc_els_cb_arg), GFP_ATOMIC);\n\tif (!cb_arg) {\n\t\tprintk(KERN_ERR PFX \"Unable to allocate cb_arg for REC\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto rec_err;\n\t}\n\tkref_get(&orig_io_req->refcount);\n\n\tcb_arg->aborted_io_req = orig_io_req;\n\n\trec.rec_cmd = ELS_REC;\n\thton24(rec.rec_s_id, sid);\n\trec.rec_ox_id = htons(orig_io_req->xid);\n\trec.rec_rx_id = htons(orig_io_req->task->rxwr_txrd.var_ctx.rx_id);\n\n\trc = bnx2fc_initiate_els(tgt, ELS_REC, &rec, sizeof(rec),\n\t\t\t\t bnx2fc_rec_compl, cb_arg,\n\t\t\t\t r_a_tov);\n\tif (rc) {\n\t\tBNX2FC_IO_DBG(orig_io_req, \"REC failed - release\\n\");\n\t\tspin_lock_bh(&tgt->tgt_lock);\n\t\tkref_put(&orig_io_req->refcount, bnx2fc_cmd_release);\n\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t\tkfree(cb_arg);\n\t}\nrec_err:\n\treturn rc;\n}\n\nint bnx2fc_send_srr(struct bnx2fc_cmd *orig_io_req, u32 offset, u8 r_ctl)\n{\n\tstruct fcp_srr srr;\n\tstruct bnx2fc_rport *tgt = orig_io_req->tgt;\n\tstruct fc_lport *lport = tgt->rdata->local_port;\n\tstruct bnx2fc_els_cb_arg *cb_arg = NULL;\n\tu32 r_a_tov = lport->r_a_tov;\n\tint rc;\n\n\tBNX2FC_IO_DBG(orig_io_req, \"Sending SRR\\n\");\n\tmemset(&srr, 0, sizeof(srr));\n\n\tcb_arg = kzalloc(sizeof(struct bnx2fc_els_cb_arg), GFP_ATOMIC);\n\tif (!cb_arg) {\n\t\tprintk(KERN_ERR PFX \"Unable to allocate cb_arg for SRR\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto srr_err;\n\t}\n\tkref_get(&orig_io_req->refcount);\n\n\tcb_arg->aborted_io_req = orig_io_req;\n\n\tsrr.srr_op = ELS_SRR;\n\tsrr.srr_ox_id = htons(orig_io_req->xid);\n\tsrr.srr_rx_id = htons(orig_io_req->task->rxwr_txrd.var_ctx.rx_id);\n\tsrr.srr_rel_off = htonl(offset);\n\tsrr.srr_r_ctl = r_ctl;\n\torig_io_req->srr_offset = offset;\n\torig_io_req->srr_rctl = r_ctl;\n\n\trc = bnx2fc_initiate_els(tgt, ELS_SRR, &srr, sizeof(srr),\n\t\t\t\t bnx2fc_srr_compl, cb_arg,\n\t\t\t\t r_a_tov);\n\tif (rc) {\n\t\tBNX2FC_IO_DBG(orig_io_req, \"SRR failed - release\\n\");\n\t\tspin_lock_bh(&tgt->tgt_lock);\n\t\tkref_put(&orig_io_req->refcount, bnx2fc_cmd_release);\n\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t\tkfree(cb_arg);\n\t} else\n\t\tset_bit(BNX2FC_FLAG_SRR_SENT, &orig_io_req->req_flags);\n\nsrr_err:\n\treturn rc;\n}\n\nstatic int bnx2fc_initiate_els(struct bnx2fc_rport *tgt, unsigned int op,\n\t\t\tvoid *data, u32 data_len,\n\t\t\tvoid (*cb_func)(struct bnx2fc_els_cb_arg *cb_arg),\n\t\t\tstruct bnx2fc_els_cb_arg *cb_arg, u32 timer_msec)\n{\n\tstruct fcoe_port *port = tgt->port;\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct fc_rport *rport = tgt->rport;\n\tstruct fc_lport *lport = port->lport;\n\tstruct bnx2fc_cmd *els_req;\n\tstruct bnx2fc_mp_req *mp_req;\n\tstruct fc_frame_header *fc_hdr;\n\tstruct fcoe_task_ctx_entry *task;\n\tstruct fcoe_task_ctx_entry *task_page;\n\tint rc = 0;\n\tint task_idx, index;\n\tu32 did, sid;\n\tu16 xid;\n\n\trc = fc_remote_port_chkready(rport);\n\tif (rc) {\n\t\tprintk(KERN_ERR PFX \"els 0x%x: rport not ready\\n\", op);\n\t\trc = -EINVAL;\n\t\tgoto els_err;\n\t}\n\tif (lport->state != LPORT_ST_READY || !(lport->link_up)) {\n\t\tprintk(KERN_ERR PFX \"els 0x%x: link is not ready\\n\", op);\n\t\trc = -EINVAL;\n\t\tgoto els_err;\n\t}\n\tif (!(test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags))) {\n\t\tprintk(KERN_ERR PFX \"els 0x%x: tgt not ready\\n\", op);\n\t\trc = -EINVAL;\n\t\tgoto els_err;\n\t}\n\tels_req = bnx2fc_elstm_alloc(tgt, BNX2FC_ELS);\n\tif (!els_req) {\n\t\trc = -ENOMEM;\n\t\tgoto els_err;\n\t}\n\n\tels_req->sc_cmd = NULL;\n\tels_req->port = port;\n\tels_req->tgt = tgt;\n\tels_req->cb_func = cb_func;\n\tcb_arg->io_req = els_req;\n\tels_req->cb_arg = cb_arg;\n\tels_req->data_xfer_len = data_len;\n\n\tmp_req = (struct bnx2fc_mp_req *)&(els_req->mp_req);\n\trc = bnx2fc_init_mp_req(els_req);\n\tif (rc == FAILED) {\n\t\tprintk(KERN_ERR PFX \"ELS MP request init failed\\n\");\n\t\tspin_lock_bh(&tgt->tgt_lock);\n\t\tkref_put(&els_req->refcount, bnx2fc_cmd_release);\n\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t\trc = -ENOMEM;\n\t\tgoto els_err;\n\t} else {\n\t\t \n\t\trc = 0;\n\t}\n\n\t \n\tmp_req->req_len = data_len;\n\tels_req->data_xfer_len = mp_req->req_len;\n\n\t \n\tif ((op >= ELS_LS_RJT) && (op <= ELS_AUTH_ELS)) {\n\t\tmemcpy(mp_req->req_buf, data, data_len);\n\t} else {\n\t\tprintk(KERN_ERR PFX \"Invalid ELS op 0x%x\\n\", op);\n\t\tels_req->cb_func = NULL;\n\t\tels_req->cb_arg = NULL;\n\t\tspin_lock_bh(&tgt->tgt_lock);\n\t\tkref_put(&els_req->refcount, bnx2fc_cmd_release);\n\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t\trc = -EINVAL;\n\t}\n\n\tif (rc)\n\t\tgoto els_err;\n\n\t \n\tfc_hdr = &(mp_req->req_fc_hdr);\n\n\tdid = tgt->rport->port_id;\n\tsid = tgt->sid;\n\n\tif (op == ELS_SRR)\n\t\t__fc_fill_fc_hdr(fc_hdr, FC_RCTL_ELS4_REQ, did, sid,\n\t\t\t\t   FC_TYPE_FCP, FC_FC_FIRST_SEQ |\n\t\t\t\t   FC_FC_END_SEQ | FC_FC_SEQ_INIT, 0);\n\telse\n\t\t__fc_fill_fc_hdr(fc_hdr, FC_RCTL_ELS_REQ, did, sid,\n\t\t\t\t   FC_TYPE_ELS, FC_FC_FIRST_SEQ |\n\t\t\t\t   FC_FC_END_SEQ | FC_FC_SEQ_INIT, 0);\n\n\t \n\txid = els_req->xid;\n\ttask_idx = xid/BNX2FC_TASKS_PER_PAGE;\n\tindex = xid % BNX2FC_TASKS_PER_PAGE;\n\n\t \n\ttask_page = (struct fcoe_task_ctx_entry *)\n\t\t\tinterface->hba->task_ctx[task_idx];\n\ttask = &(task_page[index]);\n\tbnx2fc_init_mp_task(els_req, task);\n\n\tspin_lock_bh(&tgt->tgt_lock);\n\n\tif (!test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags)) {\n\t\tprintk(KERN_ERR PFX \"initiate_els.. session not ready\\n\");\n\t\tels_req->cb_func = NULL;\n\t\tels_req->cb_arg = NULL;\n\t\tkref_put(&els_req->refcount, bnx2fc_cmd_release);\n\t\tspin_unlock_bh(&tgt->tgt_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (timer_msec)\n\t\tbnx2fc_cmd_timer_set(els_req, timer_msec);\n\tbnx2fc_add_2_sq(tgt, xid);\n\n\tels_req->on_active_queue = 1;\n\tlist_add_tail(&els_req->link, &tgt->els_queue);\n\n\t \n\tbnx2fc_ring_doorbell(tgt);\n\tspin_unlock_bh(&tgt->tgt_lock);\n\nels_err:\n\treturn rc;\n}\n\nvoid bnx2fc_process_els_compl(struct bnx2fc_cmd *els_req,\n\t\t\t      struct fcoe_task_ctx_entry *task, u8 num_rq)\n{\n\tstruct bnx2fc_mp_req *mp_req;\n\tstruct fc_frame_header *fc_hdr;\n\tu64 *hdr;\n\tu64 *temp_hdr;\n\n\tBNX2FC_ELS_DBG(\"Entered process_els_compl xid = 0x%x\"\n\t\t\t\"cmd_type = %d\\n\", els_req->xid, els_req->cmd_type);\n\n\tif (test_and_set_bit(BNX2FC_FLAG_ELS_DONE,\n\t\t\t     &els_req->req_flags)) {\n\t\tBNX2FC_ELS_DBG(\"Timer context finished processing this \"\n\t\t\t   \"els - 0x%x\\n\", els_req->xid);\n\t\t \n\t\tkref_put(&els_req->refcount, bnx2fc_cmd_release);\n\t\treturn;\n\t}\n\n\t \n\tif (cancel_delayed_work(&els_req->timeout_work))\n\t\tkref_put(&els_req->refcount,\n\t\t\t bnx2fc_cmd_release);  \n\n\tif (els_req->on_active_queue) {\n\t\tlist_del_init(&els_req->link);\n\t\tels_req->on_active_queue = 0;\n\t}\n\n\tmp_req = &(els_req->mp_req);\n\tfc_hdr = &(mp_req->resp_fc_hdr);\n\n\thdr = (u64 *)fc_hdr;\n\ttemp_hdr = (u64 *)\n\t\t&task->rxwr_only.union_ctx.comp_info.mp_rsp.fc_hdr;\n\thdr[0] = cpu_to_be64(temp_hdr[0]);\n\thdr[1] = cpu_to_be64(temp_hdr[1]);\n\thdr[2] = cpu_to_be64(temp_hdr[2]);\n\n\tmp_req->resp_len =\n\t\ttask->rxwr_only.union_ctx.comp_info.mp_rsp.mp_payload_len;\n\n\t \n\tif ((els_req->cb_func) && (els_req->cb_arg)) {\n\t\tels_req->cb_func(els_req->cb_arg);\n\t\tels_req->cb_arg = NULL;\n\t}\n\n\tkref_put(&els_req->refcount, bnx2fc_cmd_release);\n}\n\n#define\t\tBNX2FC_FCOE_MAC_METHOD_GRANGED_MAC\t1\n#define\t\tBNX2FC_FCOE_MAC_METHOD_FCF_MAP\t\t2\n#define\t\tBNX2FC_FCOE_MAC_METHOD_FCOE_SET_MAC\t3\nstatic void bnx2fc_flogi_resp(struct fc_seq *seq, struct fc_frame *fp,\n\t\t\t      void *arg)\n{\n\tstruct fcoe_ctlr *fip = arg;\n\tstruct fc_exch *exch = fc_seq_exch(seq);\n\tstruct fc_lport *lport = exch->lp;\n\n\tstruct fc_frame_header *fh;\n\tu8 *granted_mac;\n\tu8 fcoe_mac[6];\n\tu8 fc_map[3];\n\tint method;\n\n\tif (IS_ERR(fp))\n\t\tgoto done;\n\n\tfh = fc_frame_header_get(fp);\n\tgranted_mac = fr_cb(fp)->granted_mac;\n\n\t \n\tif (!is_zero_ether_addr(granted_mac)) {\n\t\tether_addr_copy(fcoe_mac, granted_mac);\n\t\tmethod = BNX2FC_FCOE_MAC_METHOD_GRANGED_MAC;\n\t} else if (fip->sel_fcf && fip->sel_fcf->fc_map != 0) {\n\t\thton24(fc_map, fip->sel_fcf->fc_map);\n\t\tfcoe_mac[0] = fc_map[0];\n\t\tfcoe_mac[1] = fc_map[1];\n\t\tfcoe_mac[2] = fc_map[2];\n\t\tfcoe_mac[3] = fh->fh_d_id[0];\n\t\tfcoe_mac[4] = fh->fh_d_id[1];\n\t\tfcoe_mac[5] = fh->fh_d_id[2];\n\t\tmethod = BNX2FC_FCOE_MAC_METHOD_FCF_MAP;\n\t} else {\n\t\tfc_fcoe_set_mac(fcoe_mac, fh->fh_d_id);\n\t\tmethod = BNX2FC_FCOE_MAC_METHOD_FCOE_SET_MAC;\n\t}\n\n\tBNX2FC_HBA_DBG(lport, \"fcoe_mac=%pM method=%d\\n\", fcoe_mac, method);\n\tfip->update_mac(lport, fcoe_mac);\ndone:\n\tfc_lport_flogi_resp(seq, fp, lport);\n}\n\nstatic void bnx2fc_logo_resp(struct fc_seq *seq, struct fc_frame *fp,\n\t\t\t     void *arg)\n{\n\tstruct fcoe_ctlr *fip = arg;\n\tstruct fc_exch *exch = fc_seq_exch(seq);\n\tstruct fc_lport *lport = exch->lp;\n\tstatic u8 zero_mac[ETH_ALEN] = { 0 };\n\n\tif (!IS_ERR(fp))\n\t\tfip->update_mac(lport, zero_mac);\n\tfc_lport_logo_resp(seq, fp, lport);\n}\n\nstruct fc_seq *bnx2fc_elsct_send(struct fc_lport *lport, u32 did,\n\t\t\t\t      struct fc_frame *fp, unsigned int op,\n\t\t\t\t      void (*resp)(struct fc_seq *,\n\t\t\t\t\t\t   struct fc_frame *,\n\t\t\t\t\t\t   void *),\n\t\t\t\t      void *arg, u32 timeout)\n{\n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct fcoe_ctlr *fip = bnx2fc_to_ctlr(interface);\n\tstruct fc_frame_header *fh = fc_frame_header_get(fp);\n\n\tswitch (op) {\n\tcase ELS_FLOGI:\n\tcase ELS_FDISC:\n\t\treturn fc_elsct_send(lport, did, fp, op, bnx2fc_flogi_resp,\n\t\t\t\t     fip, timeout);\n\tcase ELS_LOGO:\n\t\t \n\t\tif (ntoh24(fh->fh_d_id) != FC_FID_FLOGI)\n\t\t\tbreak;\n\t\treturn fc_elsct_send(lport, did, fp, op, bnx2fc_logo_resp,\n\t\t\t\t     fip, timeout);\n\t}\n\treturn fc_elsct_send(lport, did, fp, op, resp, arg, timeout);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}