{
  "module_name": "bnx2fc_tgt.c",
  "hash_id": "c95aecc1363b60ba28487ce6fb87eb74d4a847de638e1dc6e4668505fb5c31ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bnx2fc/bnx2fc_tgt.c",
  "human_readable_source": " \n\n#include \"bnx2fc.h\"\nstatic void bnx2fc_upld_timer(struct timer_list *t);\nstatic void bnx2fc_ofld_timer(struct timer_list *t);\nstatic int bnx2fc_init_tgt(struct bnx2fc_rport *tgt,\n\t\t\t   struct fcoe_port *port,\n\t\t\t   struct fc_rport_priv *rdata);\nstatic u32 bnx2fc_alloc_conn_id(struct bnx2fc_hba *hba,\n\t\t\t\tstruct bnx2fc_rport *tgt);\nstatic int bnx2fc_alloc_session_resc(struct bnx2fc_hba *hba,\n\t\t\t      struct bnx2fc_rport *tgt);\nstatic void bnx2fc_free_session_resc(struct bnx2fc_hba *hba,\n\t\t\t      struct bnx2fc_rport *tgt);\nstatic void bnx2fc_free_conn_id(struct bnx2fc_hba *hba, u32 conn_id);\n\nstatic void bnx2fc_upld_timer(struct timer_list *t)\n{\n\n\tstruct bnx2fc_rport *tgt = from_timer(tgt, t, upld_timer);\n\n\tBNX2FC_TGT_DBG(tgt, \"upld_timer - Upload compl not received!!\\n\");\n\t \n\tclear_bit(BNX2FC_FLAG_OFFLOADED, &tgt->flags);\n\tclear_bit(BNX2FC_FLAG_ENABLED, &tgt->flags);\n\tset_bit(BNX2FC_FLAG_UPLD_REQ_COMPL, &tgt->flags);\n\twake_up_interruptible(&tgt->upld_wait);\n}\n\nstatic void bnx2fc_ofld_timer(struct timer_list *t)\n{\n\n\tstruct bnx2fc_rport *tgt = from_timer(tgt, t, ofld_timer);\n\n\tBNX2FC_TGT_DBG(tgt, \"entered bnx2fc_ofld_timer\\n\");\n\t \n\t \n\tclear_bit(BNX2FC_FLAG_OFFLOADED, &tgt->flags);\n\tclear_bit(BNX2FC_FLAG_ENABLED, &tgt->flags);\n\tset_bit(BNX2FC_FLAG_OFLD_REQ_CMPL, &tgt->flags);\n\twake_up_interruptible(&tgt->ofld_wait);\n}\n\nstatic void bnx2fc_ofld_wait(struct bnx2fc_rport *tgt)\n{\n\ttimer_setup(&tgt->ofld_timer, bnx2fc_ofld_timer, 0);\n\tmod_timer(&tgt->ofld_timer, jiffies + BNX2FC_FW_TIMEOUT);\n\n\twait_event_interruptible(tgt->ofld_wait,\n\t\t\t\t (test_bit(\n\t\t\t\t  BNX2FC_FLAG_OFLD_REQ_CMPL,\n\t\t\t\t  &tgt->flags)));\n\tif (signal_pending(current))\n\t\tflush_signals(current);\n\tdel_timer_sync(&tgt->ofld_timer);\n}\n\nstatic void bnx2fc_offload_session(struct fcoe_port *port,\n\t\t\t\t\tstruct bnx2fc_rport *tgt,\n\t\t\t\t\tstruct fc_rport_priv *rdata)\n{\n\tstruct fc_rport *rport = rdata->rport;\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct bnx2fc_hba *hba = interface->hba;\n\tint rval;\n\tint i = 0;\n\n\t \n\t \n\trval = bnx2fc_init_tgt(tgt, port, rdata);\n\tif (rval) {\n\t\tprintk(KERN_ERR PFX \"Failed to allocate conn id for \"\n\t\t\t\"port_id (%6x)\\n\", rport->port_id);\n\t\tgoto tgt_init_err;\n\t}\n\n\t \n\trval = bnx2fc_alloc_session_resc(hba, tgt);\n\tif (rval) {\n\t\tprintk(KERN_ERR PFX \"Failed to allocate resources\\n\");\n\t\tgoto ofld_err;\n\t}\n\n\t \nretry_ofld:\n\tclear_bit(BNX2FC_FLAG_OFLD_REQ_CMPL, &tgt->flags);\n\trval = bnx2fc_send_session_ofld_req(port, tgt);\n\tif (rval) {\n\t\tprintk(KERN_ERR PFX \"ofld_req failed\\n\");\n\t\tgoto ofld_err;\n\t}\n\n\t \n\tbnx2fc_ofld_wait(tgt);\n\n\tif (!(test_bit(BNX2FC_FLAG_OFFLOADED, &tgt->flags))) {\n\t\tif (test_and_clear_bit(BNX2FC_FLAG_CTX_ALLOC_FAILURE,\n\t\t\t\t       &tgt->flags)) {\n\t\t\tBNX2FC_TGT_DBG(tgt, \"ctx_alloc_failure, \"\n\t\t\t\t\"retry ofld..%d\\n\", i++);\n\t\t\tmsleep_interruptible(1000);\n\t\t\tif (i > 3) {\n\t\t\t\ti = 0;\n\t\t\t\tgoto ofld_err;\n\t\t\t}\n\t\t\tgoto retry_ofld;\n\t\t}\n\t\tgoto ofld_err;\n\t}\n\tif (bnx2fc_map_doorbell(tgt)) {\n\t\tprintk(KERN_ERR PFX \"map doorbell failed - no mem\\n\");\n\t\tgoto ofld_err;\n\t}\n\tclear_bit(BNX2FC_FLAG_OFLD_REQ_CMPL, &tgt->flags);\n\trval = bnx2fc_send_session_enable_req(port, tgt);\n\tif (rval) {\n\t\tpr_err(PFX \"enable session failed\\n\");\n\t\tgoto ofld_err;\n\t}\n\tbnx2fc_ofld_wait(tgt);\n\tif (!(test_bit(BNX2FC_FLAG_ENABLED, &tgt->flags)))\n\t\tgoto ofld_err;\n\treturn;\n\nofld_err:\n\t \n\tBNX2FC_TGT_DBG(tgt, \"bnx2fc_offload_session - offload error\\n\");\n\tclear_bit(BNX2FC_FLAG_OFFLOADED, &tgt->flags);\n\t \n\tbnx2fc_free_session_resc(hba, tgt);\ntgt_init_err:\n\tif (tgt->fcoe_conn_id != -1)\n\t\tbnx2fc_free_conn_id(hba, tgt->fcoe_conn_id);\n\tfc_rport_logoff(rdata);\n}\n\nvoid bnx2fc_flush_active_ios(struct bnx2fc_rport *tgt)\n{\n\tstruct bnx2fc_cmd *io_req;\n\tstruct bnx2fc_cmd *tmp;\n\tint rc;\n\tint i = 0;\n\tBNX2FC_TGT_DBG(tgt, \"Entered flush_active_ios - %d\\n\",\n\t\t       tgt->num_active_ios.counter);\n\n\tspin_lock_bh(&tgt->tgt_lock);\n\ttgt->flush_in_prog = 1;\n\n\tlist_for_each_entry_safe(io_req, tmp, &tgt->active_cmd_queue, link) {\n\t\ti++;\n\t\tlist_del_init(&io_req->link);\n\t\tio_req->on_active_queue = 0;\n\t\tBNX2FC_IO_DBG(io_req, \"cmd_queue cleanup\\n\");\n\n\t\tif (cancel_delayed_work(&io_req->timeout_work)) {\n\t\t\tif (test_and_clear_bit(BNX2FC_FLAG_EH_ABORT,\n\t\t\t\t\t\t&io_req->req_flags)) {\n\t\t\t\t \n\t\t\t\tBNX2FC_IO_DBG(io_req, \"eh_abort for IO \"\n\t\t\t\t\t      \"cleaned up\\n\");\n\t\t\t\tcomplete(&io_req->abts_done);\n\t\t\t}\n\t\t\tkref_put(&io_req->refcount,\n\t\t\t\t bnx2fc_cmd_release);  \n\t\t}\n\n\t\tset_bit(BNX2FC_FLAG_IO_COMPL, &io_req->req_flags);\n\t\tset_bit(BNX2FC_FLAG_IO_CLEANUP, &io_req->req_flags);\n\n\t\t \n\t\tif (test_bit(BNX2FC_FLAG_DISABLE_FAILED, &tgt->flags))\n\t\t\tbnx2fc_process_cleanup_compl(io_req, io_req->task, 0);\n\t\telse {\n\t\t\trc = bnx2fc_initiate_cleanup(io_req);\n\t\t\tBUG_ON(rc);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(io_req, tmp, &tgt->active_tm_queue, link) {\n\t\ti++;\n\t\tlist_del_init(&io_req->link);\n\t\tio_req->on_tmf_queue = 0;\n\t\tBNX2FC_IO_DBG(io_req, \"tm_queue cleanup\\n\");\n\t\tif (io_req->wait_for_abts_comp)\n\t\t\tcomplete(&io_req->abts_done);\n\t}\n\n\tlist_for_each_entry_safe(io_req, tmp, &tgt->els_queue, link) {\n\t\ti++;\n\t\tlist_del_init(&io_req->link);\n\t\tio_req->on_active_queue = 0;\n\n\t\tBNX2FC_IO_DBG(io_req, \"els_queue cleanup\\n\");\n\n\t\tif (cancel_delayed_work(&io_req->timeout_work))\n\t\t\tkref_put(&io_req->refcount,\n\t\t\t\t bnx2fc_cmd_release);  \n\n\t\tif ((io_req->cb_func) && (io_req->cb_arg)) {\n\t\t\tio_req->cb_func(io_req->cb_arg);\n\t\t\tio_req->cb_arg = NULL;\n\t\t}\n\n\t\t \n\t\tif (test_bit(BNX2FC_FLAG_DISABLE_FAILED, &tgt->flags))\n\t\t\tbnx2fc_process_cleanup_compl(io_req, io_req->task, 0);\n\t\telse {\n\t\t\trc = bnx2fc_initiate_cleanup(io_req);\n\t\t\tBUG_ON(rc);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(io_req, tmp, &tgt->io_retire_queue, link) {\n\t\ti++;\n\t\tlist_del_init(&io_req->link);\n\n\t\tBNX2FC_IO_DBG(io_req, \"retire_queue flush\\n\");\n\n\t\tif (cancel_delayed_work(&io_req->timeout_work)) {\n\t\t\tif (test_and_clear_bit(BNX2FC_FLAG_EH_ABORT,\n\t\t\t\t\t\t&io_req->req_flags)) {\n\t\t\t\t \n\t\t\t\tBNX2FC_IO_DBG(io_req, \"eh_abort for IO \"\n\t\t\t\t\t      \"in retire_q\\n\");\n\t\t\t\tif (io_req->wait_for_abts_comp)\n\t\t\t\t\tcomplete(&io_req->abts_done);\n\t\t\t}\n\t\t\tkref_put(&io_req->refcount, bnx2fc_cmd_release);\n\t\t}\n\n\t\tclear_bit(BNX2FC_FLAG_ISSUE_RRQ, &io_req->req_flags);\n\t}\n\n\tBNX2FC_TGT_DBG(tgt, \"IOs flushed = %d\\n\", i);\n\ti = 0;\n\tspin_unlock_bh(&tgt->tgt_lock);\n\t \n\twhile ((tgt->num_active_ios.counter != 0) && (i++ < BNX2FC_WAIT_CNT))\n\t\tmsleep(25);\n\tif (tgt->num_active_ios.counter != 0)\n\t\tprintk(KERN_ERR PFX \"CLEANUP on port 0x%x:\"\n\t\t\t\t    \" active_ios = %d\\n\",\n\t\t\ttgt->rdata->ids.port_id, tgt->num_active_ios.counter);\n\tspin_lock_bh(&tgt->tgt_lock);\n\ttgt->flush_in_prog = 0;\n\tspin_unlock_bh(&tgt->tgt_lock);\n}\n\nstatic void bnx2fc_upld_wait(struct bnx2fc_rport *tgt)\n{\n\ttimer_setup(&tgt->upld_timer, bnx2fc_upld_timer, 0);\n\tmod_timer(&tgt->upld_timer, jiffies + BNX2FC_FW_TIMEOUT);\n\twait_event_interruptible(tgt->upld_wait,\n\t\t\t\t (test_bit(\n\t\t\t\t  BNX2FC_FLAG_UPLD_REQ_COMPL,\n\t\t\t\t  &tgt->flags)));\n\tif (signal_pending(current))\n\t\tflush_signals(current);\n\tdel_timer_sync(&tgt->upld_timer);\n}\n\nstatic void bnx2fc_upload_session(struct fcoe_port *port,\n\t\t\t\t\tstruct bnx2fc_rport *tgt)\n{\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct bnx2fc_hba *hba = interface->hba;\n\n\tBNX2FC_TGT_DBG(tgt, \"upload_session: active_ios = %d\\n\",\n\t\ttgt->num_active_ios.counter);\n\n\t \n\tclear_bit(BNX2FC_FLAG_UPLD_REQ_COMPL, &tgt->flags);\n\tbnx2fc_send_session_disable_req(port, tgt);\n\n\t \n\tBNX2FC_TGT_DBG(tgt, \"waiting for disable compl\\n\");\n\tbnx2fc_upld_wait(tgt);\n\n\t \n\tBNX2FC_TGT_DBG(tgt, \"flush/upload - disable wait flags = 0x%lx\\n\",\n\t\t       tgt->flags);\n\tbnx2fc_flush_active_ios(tgt);\n\n\t \n\tif (test_bit(BNX2FC_FLAG_DISABLED, &tgt->flags)) {\n\t\tBNX2FC_TGT_DBG(tgt, \"send destroy req\\n\");\n\t\tclear_bit(BNX2FC_FLAG_UPLD_REQ_COMPL, &tgt->flags);\n\t\tbnx2fc_send_session_destroy_req(hba, tgt);\n\n\t\t \n\t\tbnx2fc_upld_wait(tgt);\n\n\t\tif (!(test_bit(BNX2FC_FLAG_DESTROYED, &tgt->flags)))\n\t\t\tprintk(KERN_ERR PFX \"ERROR!! destroy timed out\\n\");\n\n\t\tBNX2FC_TGT_DBG(tgt, \"destroy wait complete flags = 0x%lx\\n\",\n\t\t\ttgt->flags);\n\n\t} else if (test_bit(BNX2FC_FLAG_DISABLE_FAILED, &tgt->flags)) {\n\t\tprintk(KERN_ERR PFX \"ERROR!! DISABLE req failed, destroy\"\n\t\t\t\t\" not sent to FW\\n\");\n\t} else {\n\t\tprintk(KERN_ERR PFX \"ERROR!! DISABLE req timed out, destroy\"\n\t\t\t\t\" not sent to FW\\n\");\n\t}\n\n\t \n\tbnx2fc_free_session_resc(hba, tgt);\n\tbnx2fc_free_conn_id(hba, tgt->fcoe_conn_id);\n}\n\nstatic int bnx2fc_init_tgt(struct bnx2fc_rport *tgt,\n\t\t\t   struct fcoe_port *port,\n\t\t\t   struct fc_rport_priv *rdata)\n{\n\n\tstruct fc_rport *rport = rdata->rport;\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct bnx2fc_hba *hba = interface->hba;\n\tstruct b577xx_doorbell_set_prod *sq_db = &tgt->sq_db;\n\tstruct b577xx_fcoe_rx_doorbell *rx_db = &tgt->rx_db;\n\n\ttgt->rport = rport;\n\ttgt->rdata = rdata;\n\ttgt->port = port;\n\n\tif (hba->num_ofld_sess >= BNX2FC_NUM_MAX_SESS) {\n\t\tBNX2FC_TGT_DBG(tgt, \"exceeded max sessions. logoff this tgt\\n\");\n\t\ttgt->fcoe_conn_id = -1;\n\t\treturn -1;\n\t}\n\n\ttgt->fcoe_conn_id = bnx2fc_alloc_conn_id(hba, tgt);\n\tif (tgt->fcoe_conn_id == -1)\n\t\treturn -1;\n\n\tBNX2FC_TGT_DBG(tgt, \"init_tgt - conn_id = 0x%x\\n\", tgt->fcoe_conn_id);\n\n\ttgt->max_sqes = BNX2FC_SQ_WQES_MAX;\n\ttgt->max_rqes = BNX2FC_RQ_WQES_MAX;\n\ttgt->max_cqes = BNX2FC_CQ_WQES_MAX;\n\tatomic_set(&tgt->free_sqes, BNX2FC_SQ_WQES_MAX);\n\n\t \n\ttgt->sq_curr_toggle_bit = 1;\n\ttgt->cq_curr_toggle_bit = 1;\n\ttgt->sq_prod_idx = 0;\n\ttgt->cq_cons_idx = 0;\n\ttgt->rq_prod_idx = 0x8000;\n\ttgt->rq_cons_idx = 0;\n\tatomic_set(&tgt->num_active_ios, 0);\n\ttgt->retry_delay_timestamp = 0;\n\n\tif (rdata->flags & FC_RP_FLAGS_RETRY &&\n\t    rdata->ids.roles & FC_RPORT_ROLE_FCP_TARGET &&\n\t    !(rdata->ids.roles & FC_RPORT_ROLE_FCP_INITIATOR)) {\n\t\ttgt->dev_type = TYPE_TAPE;\n\t\ttgt->io_timeout = 0;  \n\t} else {\n\t\ttgt->dev_type = TYPE_DISK;\n\t\ttgt->io_timeout = BNX2FC_IO_TIMEOUT;\n\t}\n\n\t \n\tsq_db->header.header = B577XX_DOORBELL_HDR_DB_TYPE;\n\tsq_db->header.header |= B577XX_FCOE_CONNECTION_TYPE <<\n\t\t\t\t\tB577XX_DOORBELL_HDR_CONN_TYPE_SHIFT;\n\t \n\trx_db->hdr.header = ((0x1 << B577XX_DOORBELL_HDR_RX_SHIFT) |\n\t\t\t  (0x1 << B577XX_DOORBELL_HDR_DB_TYPE_SHIFT) |\n\t\t\t  (B577XX_FCOE_CONNECTION_TYPE <<\n\t\t\t\tB577XX_DOORBELL_HDR_CONN_TYPE_SHIFT));\n\trx_db->params = (0x2 << B577XX_FCOE_RX_DOORBELL_NEGATIVE_ARM_SHIFT) |\n\t\t     (0x3 << B577XX_FCOE_RX_DOORBELL_OPCODE_SHIFT);\n\n\tspin_lock_init(&tgt->tgt_lock);\n\tspin_lock_init(&tgt->cq_lock);\n\n\t \n\tINIT_LIST_HEAD(&tgt->active_cmd_queue);\n\n\t \n\tINIT_LIST_HEAD(&tgt->io_retire_queue);\n\n\tINIT_LIST_HEAD(&tgt->els_queue);\n\n\t \n\tINIT_LIST_HEAD(&tgt->active_tm_queue);\n\n\tinit_waitqueue_head(&tgt->ofld_wait);\n\tinit_waitqueue_head(&tgt->upld_wait);\n\n\treturn 0;\n}\n\n \nvoid bnx2fc_rport_event_handler(struct fc_lport *lport,\n\t\t\t\tstruct fc_rport_priv *rdata,\n\t\t\t\tenum fc_rport_event event)\n{\n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct bnx2fc_hba *hba = interface->hba;\n\tstruct fc_rport *rport = rdata->rport;\n\tstruct fc_rport_libfc_priv *rp;\n\tstruct bnx2fc_rport *tgt;\n\tu32 port_id;\n\n\tBNX2FC_HBA_DBG(lport, \"rport_event_hdlr: event = %d, port_id = 0x%x\\n\",\n\t\tevent, rdata->ids.port_id);\n\tswitch (event) {\n\tcase RPORT_EV_READY:\n\t\tif (!rport) {\n\t\t\tprintk(KERN_ERR PFX \"rport is NULL: ERROR!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\trp = rport->dd_data;\n\t\tif (rport->port_id == FC_FID_DIR_SERV) {\n\t\t\t \n\t\t\tprintk(KERN_ERR PFX \"%x - rport_event_handler ERROR\\n\",\n\t\t\t\trdata->ids.port_id);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rdata->spp_type != FC_TYPE_FCP) {\n\t\t\tBNX2FC_HBA_DBG(lport, \"not FCP type target.\"\n\t\t\t\t   \" not offloading\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (!(rdata->ids.roles & FC_RPORT_ROLE_FCP_TARGET)) {\n\t\t\tBNX2FC_HBA_DBG(lport, \"not FCP_TARGET\"\n\t\t\t\t   \" not offloading\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmutex_lock(&hba->hba_mutex);\n\t\ttgt = (struct bnx2fc_rport *)&rp[1];\n\n\t\t \n\t\tif (test_bit(BNX2FC_FLAG_ENABLED, &tgt->flags)) {\n\t\t\tBNX2FC_TGT_DBG(tgt, \"already offloaded\\n\");\n\t\t\tmutex_unlock(&hba->hba_mutex);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tbnx2fc_offload_session(port, tgt, rdata);\n\n\t\tBNX2FC_TGT_DBG(tgt, \"OFFLOAD num_ofld_sess = %d\\n\",\n\t\t\thba->num_ofld_sess);\n\n\t\tif (test_bit(BNX2FC_FLAG_ENABLED, &tgt->flags)) {\n\t\t\t \n\t\t\tBNX2FC_TGT_DBG(tgt, \"sess offloaded\\n\");\n\t\t\t \n\t\t\thba->num_ofld_sess++;\n\n\t\t\tset_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags);\n\t\t} else {\n\t\t\t \n\t\t\tBNX2FC_TGT_DBG(tgt, \"Port is being logged off as \"\n\t\t\t\t   \"offloaded flag not set\\n\");\n\t\t}\n\t\tmutex_unlock(&hba->hba_mutex);\n\t\tbreak;\n\tcase RPORT_EV_LOGO:\n\tcase RPORT_EV_FAILED:\n\tcase RPORT_EV_STOP:\n\t\tport_id = rdata->ids.port_id;\n\t\tif (port_id == FC_FID_DIR_SERV)\n\t\t\tbreak;\n\n\t\tif (!rport) {\n\t\t\tprintk(KERN_INFO PFX \"%x - rport not created Yet!!\\n\",\n\t\t\t\tport_id);\n\t\t\tbreak;\n\t\t}\n\t\trp = rport->dd_data;\n\t\tmutex_lock(&hba->hba_mutex);\n\t\t \n\t\ttgt = (struct bnx2fc_rport *)&rp[1];\n\n\t\tif (!(test_bit(BNX2FC_FLAG_ENABLED, &tgt->flags))) {\n\t\t\tmutex_unlock(&hba->hba_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tclear_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags);\n\n\t\tbnx2fc_upload_session(port, tgt);\n\t\thba->num_ofld_sess--;\n\t\tBNX2FC_TGT_DBG(tgt, \"UPLOAD num_ofld_sess = %d\\n\",\n\t\t\thba->num_ofld_sess);\n\t\t \n\t\tif ((hba->wait_for_link_down) &&\n\t\t    (hba->num_ofld_sess == 0)) {\n\t\t\twake_up_interruptible(&hba->shutdown_wait);\n\t\t}\n\t\tmutex_unlock(&hba->hba_mutex);\n\n\t\tbreak;\n\n\tcase RPORT_EV_NONE:\n\t\tbreak;\n\t}\n}\n\n \nstruct bnx2fc_rport *bnx2fc_tgt_lookup(struct fcoe_port *port,\n\t\t\t\t\t     u32 port_id)\n{\n\tstruct bnx2fc_interface *interface = port->priv;\n\tstruct bnx2fc_hba *hba = interface->hba;\n\tstruct bnx2fc_rport *tgt;\n\tstruct fc_rport_priv *rdata;\n\tint i;\n\n\tfor (i = 0; i < BNX2FC_NUM_MAX_SESS; i++) {\n\t\ttgt = hba->tgt_ofld_list[i];\n\t\tif ((tgt) && (tgt->port == port)) {\n\t\t\trdata = tgt->rdata;\n\t\t\tif (rdata->ids.port_id == port_id) {\n\t\t\t\tif (rdata->rp_state != RPORT_ST_DELETE) {\n\t\t\t\t\tBNX2FC_TGT_DBG(tgt, \"rport \"\n\t\t\t\t\t\t\"obtained\\n\");\n\t\t\t\t\treturn tgt;\n\t\t\t\t} else {\n\t\t\t\t\tBNX2FC_TGT_DBG(tgt, \"rport 0x%x \"\n\t\t\t\t\t\t\"is in DELETED state\\n\",\n\t\t\t\t\t\trdata->ids.port_id);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n\n \nstatic u32 bnx2fc_alloc_conn_id(struct bnx2fc_hba *hba,\n\t\t\t\tstruct bnx2fc_rport *tgt)\n{\n\tu32 conn_id, next;\n\n\t \n\n\t \n\n\tspin_lock_bh(&hba->hba_lock);\n\tnext = hba->next_conn_id;\n\tconn_id = hba->next_conn_id++;\n\tif (hba->next_conn_id == BNX2FC_NUM_MAX_SESS)\n\t\thba->next_conn_id = 0;\n\n\twhile (hba->tgt_ofld_list[conn_id] != NULL) {\n\t\tconn_id++;\n\t\tif (conn_id == BNX2FC_NUM_MAX_SESS)\n\t\t\tconn_id = 0;\n\n\t\tif (conn_id == next) {\n\t\t\t \n\t\t\tspin_unlock_bh(&hba->hba_lock);\n\t\t\treturn -1;\n\t\t}\n\t}\n\thba->tgt_ofld_list[conn_id] = tgt;\n\ttgt->fcoe_conn_id = conn_id;\n\tspin_unlock_bh(&hba->hba_lock);\n\treturn conn_id;\n}\n\nstatic void bnx2fc_free_conn_id(struct bnx2fc_hba *hba, u32 conn_id)\n{\n\t \n\tspin_lock_bh(&hba->hba_lock);\n\thba->tgt_ofld_list[conn_id] = NULL;\n\tspin_unlock_bh(&hba->hba_lock);\n}\n\n \nstatic int bnx2fc_alloc_session_resc(struct bnx2fc_hba *hba,\n\t\t\t\t\tstruct bnx2fc_rport *tgt)\n{\n\tdma_addr_t page;\n\tint num_pages;\n\tu32 *pbl;\n\n\t \n\ttgt->sq_mem_size = tgt->max_sqes * BNX2FC_SQ_WQE_SIZE;\n\ttgt->sq_mem_size = (tgt->sq_mem_size + (CNIC_PAGE_SIZE - 1)) &\n\t\t\t   CNIC_PAGE_MASK;\n\n\ttgt->sq = dma_alloc_coherent(&hba->pcidev->dev, tgt->sq_mem_size,\n\t\t\t\t     &tgt->sq_dma, GFP_KERNEL);\n\tif (!tgt->sq) {\n\t\tprintk(KERN_ERR PFX \"unable to allocate SQ memory %d\\n\",\n\t\t\ttgt->sq_mem_size);\n\t\tgoto mem_alloc_failure;\n\t}\n\n\t \n\ttgt->cq_mem_size = tgt->max_cqes * BNX2FC_CQ_WQE_SIZE;\n\ttgt->cq_mem_size = (tgt->cq_mem_size + (CNIC_PAGE_SIZE - 1)) &\n\t\t\t   CNIC_PAGE_MASK;\n\n\ttgt->cq = dma_alloc_coherent(&hba->pcidev->dev, tgt->cq_mem_size,\n\t\t\t\t     &tgt->cq_dma, GFP_KERNEL);\n\tif (!tgt->cq) {\n\t\tprintk(KERN_ERR PFX \"unable to allocate CQ memory %d\\n\",\n\t\t\ttgt->cq_mem_size);\n\t\tgoto mem_alloc_failure;\n\t}\n\n\t \n\ttgt->rq_mem_size = tgt->max_rqes * BNX2FC_RQ_WQE_SIZE;\n\ttgt->rq_mem_size = (tgt->rq_mem_size + (CNIC_PAGE_SIZE - 1)) &\n\t\t\t   CNIC_PAGE_MASK;\n\n\ttgt->rq = dma_alloc_coherent(&hba->pcidev->dev, tgt->rq_mem_size,\n\t\t\t\t     &tgt->rq_dma, GFP_KERNEL);\n\tif (!tgt->rq) {\n\t\tprintk(KERN_ERR PFX \"unable to allocate RQ memory %d\\n\",\n\t\t\ttgt->rq_mem_size);\n\t\tgoto mem_alloc_failure;\n\t}\n\n\ttgt->rq_pbl_size = (tgt->rq_mem_size / CNIC_PAGE_SIZE) * sizeof(void *);\n\ttgt->rq_pbl_size = (tgt->rq_pbl_size + (CNIC_PAGE_SIZE - 1)) &\n\t\t\t   CNIC_PAGE_MASK;\n\n\ttgt->rq_pbl = dma_alloc_coherent(&hba->pcidev->dev, tgt->rq_pbl_size,\n\t\t\t\t\t &tgt->rq_pbl_dma, GFP_KERNEL);\n\tif (!tgt->rq_pbl) {\n\t\tprintk(KERN_ERR PFX \"unable to allocate RQ PBL %d\\n\",\n\t\t\ttgt->rq_pbl_size);\n\t\tgoto mem_alloc_failure;\n\t}\n\n\tnum_pages = tgt->rq_mem_size / CNIC_PAGE_SIZE;\n\tpage = tgt->rq_dma;\n\tpbl = (u32 *)tgt->rq_pbl;\n\n\twhile (num_pages--) {\n\t\t*pbl = (u32)page;\n\t\tpbl++;\n\t\t*pbl = (u32)((u64)page >> 32);\n\t\tpbl++;\n\t\tpage += CNIC_PAGE_SIZE;\n\t}\n\n\t \n\ttgt->xferq_mem_size = tgt->max_sqes * BNX2FC_XFERQ_WQE_SIZE;\n\ttgt->xferq_mem_size = (tgt->xferq_mem_size + (CNIC_PAGE_SIZE - 1)) &\n\t\t\t       CNIC_PAGE_MASK;\n\n\ttgt->xferq = dma_alloc_coherent(&hba->pcidev->dev,\n\t\t\t\t\ttgt->xferq_mem_size, &tgt->xferq_dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!tgt->xferq) {\n\t\tprintk(KERN_ERR PFX \"unable to allocate XFERQ %d\\n\",\n\t\t\ttgt->xferq_mem_size);\n\t\tgoto mem_alloc_failure;\n\t}\n\n\t \n\ttgt->confq_mem_size = tgt->max_sqes * BNX2FC_CONFQ_WQE_SIZE;\n\ttgt->confq_mem_size = (tgt->confq_mem_size + (CNIC_PAGE_SIZE - 1)) &\n\t\t\t       CNIC_PAGE_MASK;\n\n\ttgt->confq = dma_alloc_coherent(&hba->pcidev->dev,\n\t\t\t\t\ttgt->confq_mem_size, &tgt->confq_dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!tgt->confq) {\n\t\tprintk(KERN_ERR PFX \"unable to allocate CONFQ %d\\n\",\n\t\t\ttgt->confq_mem_size);\n\t\tgoto mem_alloc_failure;\n\t}\n\n\ttgt->confq_pbl_size =\n\t\t(tgt->confq_mem_size / CNIC_PAGE_SIZE) * sizeof(void *);\n\ttgt->confq_pbl_size =\n\t\t(tgt->confq_pbl_size + (CNIC_PAGE_SIZE - 1)) & CNIC_PAGE_MASK;\n\n\ttgt->confq_pbl = dma_alloc_coherent(&hba->pcidev->dev,\n\t\t\t\t\t    tgt->confq_pbl_size,\n\t\t\t\t\t    &tgt->confq_pbl_dma, GFP_KERNEL);\n\tif (!tgt->confq_pbl) {\n\t\tprintk(KERN_ERR PFX \"unable to allocate CONFQ PBL %d\\n\",\n\t\t\ttgt->confq_pbl_size);\n\t\tgoto mem_alloc_failure;\n\t}\n\n\tnum_pages = tgt->confq_mem_size / CNIC_PAGE_SIZE;\n\tpage = tgt->confq_dma;\n\tpbl = (u32 *)tgt->confq_pbl;\n\n\twhile (num_pages--) {\n\t\t*pbl = (u32)page;\n\t\tpbl++;\n\t\t*pbl = (u32)((u64)page >> 32);\n\t\tpbl++;\n\t\tpage += CNIC_PAGE_SIZE;\n\t}\n\n\t \n\ttgt->conn_db_mem_size = sizeof(struct fcoe_conn_db);\n\n\ttgt->conn_db = dma_alloc_coherent(&hba->pcidev->dev,\n\t\t\t\t\t  tgt->conn_db_mem_size,\n\t\t\t\t\t  &tgt->conn_db_dma, GFP_KERNEL);\n\tif (!tgt->conn_db) {\n\t\tprintk(KERN_ERR PFX \"unable to allocate conn_db %d\\n\",\n\t\t\t\t\t\ttgt->conn_db_mem_size);\n\t\tgoto mem_alloc_failure;\n\t}\n\n\n\t \n\ttgt->lcq_mem_size = (tgt->max_sqes + 8) * BNX2FC_SQ_WQE_SIZE;\n\ttgt->lcq_mem_size = (tgt->lcq_mem_size + (CNIC_PAGE_SIZE - 1)) &\n\t\t\t     CNIC_PAGE_MASK;\n\n\ttgt->lcq = dma_alloc_coherent(&hba->pcidev->dev, tgt->lcq_mem_size,\n\t\t\t\t      &tgt->lcq_dma, GFP_KERNEL);\n\n\tif (!tgt->lcq) {\n\t\tprintk(KERN_ERR PFX \"unable to allocate lcq %d\\n\",\n\t\t       tgt->lcq_mem_size);\n\t\tgoto mem_alloc_failure;\n\t}\n\n\ttgt->conn_db->rq_prod = 0x8000;\n\n\treturn 0;\n\nmem_alloc_failure:\n\treturn -ENOMEM;\n}\n\n \nstatic void bnx2fc_free_session_resc(struct bnx2fc_hba *hba,\n\t\t\t\t\t\tstruct bnx2fc_rport *tgt)\n{\n\tvoid __iomem *ctx_base_ptr;\n\n\tBNX2FC_TGT_DBG(tgt, \"Freeing up session resources\\n\");\n\n\tspin_lock_bh(&tgt->cq_lock);\n\tctx_base_ptr = tgt->ctx_base;\n\ttgt->ctx_base = NULL;\n\n\t \n\tif (tgt->lcq) {\n\t\tdma_free_coherent(&hba->pcidev->dev, tgt->lcq_mem_size,\n\t\t\t\t    tgt->lcq, tgt->lcq_dma);\n\t\ttgt->lcq = NULL;\n\t}\n\t \n\tif (tgt->conn_db) {\n\t\tdma_free_coherent(&hba->pcidev->dev, tgt->conn_db_mem_size,\n\t\t\t\t    tgt->conn_db, tgt->conn_db_dma);\n\t\ttgt->conn_db = NULL;\n\t}\n\t \n\tif (tgt->confq_pbl) {\n\t\tdma_free_coherent(&hba->pcidev->dev, tgt->confq_pbl_size,\n\t\t\t\t    tgt->confq_pbl, tgt->confq_pbl_dma);\n\t\ttgt->confq_pbl = NULL;\n\t}\n\tif (tgt->confq) {\n\t\tdma_free_coherent(&hba->pcidev->dev, tgt->confq_mem_size,\n\t\t\t\t    tgt->confq, tgt->confq_dma);\n\t\ttgt->confq = NULL;\n\t}\n\t \n\tif (tgt->xferq) {\n\t\tdma_free_coherent(&hba->pcidev->dev, tgt->xferq_mem_size,\n\t\t\t\t    tgt->xferq, tgt->xferq_dma);\n\t\ttgt->xferq = NULL;\n\t}\n\t \n\tif (tgt->rq_pbl) {\n\t\tdma_free_coherent(&hba->pcidev->dev, tgt->rq_pbl_size,\n\t\t\t\t    tgt->rq_pbl, tgt->rq_pbl_dma);\n\t\ttgt->rq_pbl = NULL;\n\t}\n\tif (tgt->rq) {\n\t\tdma_free_coherent(&hba->pcidev->dev, tgt->rq_mem_size,\n\t\t\t\t    tgt->rq, tgt->rq_dma);\n\t\ttgt->rq = NULL;\n\t}\n\t \n\tif (tgt->cq) {\n\t\tdma_free_coherent(&hba->pcidev->dev, tgt->cq_mem_size,\n\t\t\t\t    tgt->cq, tgt->cq_dma);\n\t\ttgt->cq = NULL;\n\t}\n\t \n\tif (tgt->sq) {\n\t\tdma_free_coherent(&hba->pcidev->dev, tgt->sq_mem_size,\n\t\t\t\t    tgt->sq, tgt->sq_dma);\n\t\ttgt->sq = NULL;\n\t}\n\tspin_unlock_bh(&tgt->cq_lock);\n\n\tif (ctx_base_ptr)\n\t\tiounmap(ctx_base_ptr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}