{
  "module_name": "script_asm.pl",
  "hash_id": "0463860079dff5af6697a8bfac82331e8f3622a923b6df45d097714df9390c66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/script_asm.pl",
  "human_readable_source": "#!/usr/bin/perl -s\n# SPDX-License-Identifier: GPL-2.0-or-later\n\n# NCR 53c810 script assembler\n# Sponsored by \n#       iX Multiuser Multitasking Magazine\n#\n# Copyright 1993, Drew Eckhardt\n#      Visionary Computing \n#      (Unix and Linux consulting and custom programming)\n#      drew@Colorado.EDU\n#      +1 (303) 786-7975 \n#\n#   Support for 53c710 (via -ncr7x0_family switch) added by Richard\n#   Hirst <richard@sleepie.demon.co.uk> - 15th March 1997\n#\n# TolerANT and SCSI SCRIPTS are registered trademarks of NCR Corporation.\n#\n\n# \n# Basically, I follow the NCR syntax documented in the NCR53c710 \n# Programmer's guide, with the new instructions, registers, etc.\n# from the NCR53c810.\n#\n# Differences between this assembler and NCR's are that \n# 1.  PASS, REL (data, JUMPs work fine), and the option to start a new \n#\tscript,  are unimplemented, since I didn't use them in my scripts.\n# \n# 2.  I also emit a script_u.h file, which will undefine all of \n# \tthe A_*, E_*, etc. symbols defined in the script.  This \n#\tmakes including multiple scripts in one program easier\n# \t\n# 3.  This is a single pass assembler, which only emits \n#\t.h files.\n#\n\n\n# XXX - set these with command line options\n$debug = 0;\t\t# Print general debugging messages\n$debug_external = 0;\t# Print external/forward reference messages\n$list_in_array = 1;\t# Emit original SCRIPTS assembler in comments in\n\t\t\t# script.h\n#$prefix;\t\t# (set by perl -s)\n                        # define all arrays having this prefix so we \n\t\t\t# don't have name space collisions after \n\t\t\t# assembling this file in different ways for\n\t\t\t# different host adapters\n\n# Constants\n\n\n# Table of the SCSI phase encodings\n%scsi_phases = ( \t\t\t\n    'DATA_OUT', 0x00_00_00_00, 'DATA_IN', 0x01_00_00_00, 'CMD', 0x02_00_00_00,\n    'STATUS', 0x03_00_00_00, 'MSG_OUT', 0x06_00_00_00, 'MSG_IN', 0x07_00_00_00\n);\n\n# XXX - replace references to the *_810 constants with general constants\n# assigned at compile time based on chip type.\n\n# Table of operator encodings\n# XXX - NCR53c710 only implements \n# \tmove (nop) = 0x00_00_00_00\n#\tor = 0x02_00_00_00\n# \tand = 0x04_00_00_00\n# \tadd = 0x06_00_00_00\n\nif ($ncr7x0_family) {\n  %operators = (\n    '|', 0x02_00_00_00, 'OR', 0x02_00_00_00,\n    '&', 0x04_00_00_00, 'AND', 0x04_00_00_00,\n    '+', 0x06_00_00_00\n  );\n}\nelse {\n  %operators = (\n    'SHL',  0x01_00_00_00, \n    '|', 0x02_00_00_00, 'OR', 0x02_00_00_00, \n    'XOR', 0x03_00_00_00, \n    '&', 0x04_00_00_00, 'AND', 0x04_00_00_00, \n    'SHR', 0x05_00_00_00, \n    # Note : low bit of the operator bit should be set for add with \n    # carry.\n    '+', 0x06_00_00_00 \n  );\n}\n\n# Table of register addresses\n\nif ($ncr7x0_family) {\n  %registers = (\n    'SCNTL0', 0, 'SCNTL1', 1, 'SDID', 2, 'SIEN', 3,\n    'SCID', 4, 'SXFER', 5, 'SODL', 6, 'SOCL', 7,\n    'SFBR', 8, 'SIDL', 9, 'SBDL', 10, 'SBCL', 11,\n    'DSTAT', 12, 'SSTAT0', 13, 'SSTAT1', 14, 'SSTAT2', 15,\n    'DSA0', 16, 'DSA1', 17, 'DSA2', 18, 'DSA3', 19,\n    'CTEST0', 20, 'CTEST1', 21, 'CTEST2', 22, 'CTEST3', 23,\n    'CTEST4', 24, 'CTEST5', 25, 'CTEST6', 26, 'CTEST7', 27,\n    'TEMP0', 28, 'TEMP1', 29, 'TEMP2', 30, 'TEMP3', 31,\n    'DFIFO', 32, 'ISTAT', 33, 'CTEST8', 34, 'LCRC', 35,\n    'DBC0', 36, 'DBC1', 37, 'DBC2', 38, 'DCMD', 39,\n    'DNAD0', 40, 'DNAD1', 41, 'DNAD2', 42, 'DNAD3', 43,\n    'DSP0', 44, 'DSP1', 45, 'DSP2', 46, 'DSP3', 47,\n    'DSPS0', 48, 'DSPS1', 49, 'DSPS2', 50, 'DSPS3', 51,\n    'SCRATCH0', 52, 'SCRATCH1', 53, 'SCRATCH2', 54, 'SCRATCH3', 55,\n    'DMODE', 56, 'DIEN', 57, 'DWT', 58, 'DCNTL', 59,\n    'ADDER0', 60, 'ADDER1', 61, 'ADDER2', 62, 'ADDER3', 63,\n  );\n}\nelse {\n  %registers = (\n    'SCNTL0', 0, 'SCNTL1', 1, 'SCNTL2', 2, 'SCNTL3', 3,\n    'SCID', 4, 'SXFER', 5, 'SDID', 6, 'GPREG', 7,\n    'SFBR', 8, 'SOCL', 9, 'SSID', 10, 'SBCL', 11,\n    'DSTAT', 12, 'SSTAT0', 13, 'SSTAT1', 14, 'SSTAT2', 15,\n    'DSA0', 16, 'DSA1', 17, 'DSA2', 18, 'DSA3', 19,\n    'ISTAT', 20,\n    'CTEST0', 24, 'CTEST1', 25, 'CTEST2', 26, 'CTEST3', 27,\n    'TEMP0', 28, 'TEMP1', 29, 'TEMP2', 30, 'TEMP3', 31,\n    'DFIFO', 32, 'CTEST4', 33, 'CTEST5', 34, 'CTEST6', 35,\n    'DBC0', 36, 'DBC1', 37, 'DBC2', 38, 'DCMD', 39,\n    'DNAD0', 40, 'DNAD1', 41, 'DNAD2', 42, 'DNAD3', 43,\n    'DSP0', 44, 'DSP1', 45, 'DSP2', 46, 'DSP3', 47,\n    'DSPS0', 48, 'DSPS1', 49, 'DSPS2', 50, 'DSPS3', 51,\n    'SCRATCH0', 52, 'SCRATCH1', 53, 'SCRATCH2', 54, 'SCRATCH3', 55,\n    'SCRATCHA0', 52, 'SCRATCHA1', 53, 'SCRATCHA2', 54, 'SCRATCHA3', 55,\n    'DMODE', 56, 'DIEN', 57, 'DWT', 58, 'DCNTL', 59,\n    'ADDER0', 60, 'ADDER1', 61, 'ADDER2', 62, 'ADDER3', 63,\n    'SIEN0', 64, 'SIEN1', 65, 'SIST0', 66, 'SIST1', 67,\n    'SLPAR', 68, \t      'MACNTL', 70, 'GPCNTL', 71,\n    'STIME0', 72, 'STIME1', 73, 'RESPID', 74, \n    'STEST0', 76, 'STEST1', 77, 'STEST2', 78, 'STEST3', 79,\n    'SIDL', 80,\n    'SODL', 84,\n    'SBDL', 88,\n    'SCRATCHB0', 92, 'SCRATCHB1', 93, 'SCRATCHB2', 94, 'SCRATCHB3', 95\n  );\n}\n\n# Parsing regular expressions\n$identifier = '[A-Za-z_][A-Za-z_0-9]*';\t\t\n$decnum = '-?\\\\d+';\n$hexnum = '0[xX][0-9A-Fa-f]+';\t\t\n$constant = \"$hexnum|$decnum\";\n\n# yucky - since we can't control grouping of # $constant, we need to \n# expand out each alternative for $value.\n\n$value = \"$identifier|$identifier\\\\s*[+\\-]\\\\s*$decnum|\".\n    \"$identifier\\\\s*[+-]\\s*$hexnum|$constant\";\n\nprint STDERR \"value regex = $value\\n\" if ($debug);\n\n$phase = join ('|', keys %scsi_phases);\nprint STDERR \"phase regex = $phase\\n\" if ($debug);\n$register = join ('|', keys %registers);\n\n# yucky - since %operators includes meta-characters which must\n# be escaped, I can't use the join() trick I used for the register\n# regex\n\nif ($ncr7x0_family) {\n  $operator = '\\||OR|AND|\\&|\\+';\n}\nelse {\n  $operator = '\\||OR|AND|XOR|\\&|\\+';\n}\n\n# Global variables\n\n%symbol_values = (%registers) ;\t\t# Traditional symbol table\n\n%symbol_references = () ;\t\t# Table of symbol references, where\n\t\t\t\t\t# the index is the symbol name, \n\t\t\t\t\t# and the contents a white space \n\t\t\t\t\t# delimited list of address,size\n\t\t\t\t\t# tuples where size is in bytes.\n\n@code = ();\t\t\t\t# Array of 32 bit words for SIOP \n\n@entry = ();\t\t\t\t# Array of entry point names\n\n@label = ();\t\t\t\t# Array of label names\n\n@absolute = ();\t\t\t\t# Array of absolute names\n\n@relative = ();\t\t\t\t# Array of relative names\n\n@external = ();\t\t\t\t# Array of external names\n\n$address = 0;\t\t\t\t# Address of current instruction\n\n$lineno = 0;\t\t\t\t# Line number we are parsing\n\n$output = 'script.h';\t\t\t# Output file\n$outputu = 'scriptu.h';\n\n# &patch ($address, $offset, $length, $value) patches $code[$address]\n# \tso that the $length bytes at $offset have $value added to\n# \tthem.  \n\n@inverted_masks = (0x00_00_00_00, 0x00_00_00_ff, 0x00_00_ff_ff, 0x00_ff_ff_ff, \n    0xff_ff_ff_ff);\n\nsub patch {\n    local ($address, $offset, $length, $value) = @_;\n    if ($debug) {\n\tprint STDERR \"Patching $address at offset $offset, length $length to $value\\n\";\n\tprintf STDERR \"Old code : %08x\\n\", $code[$address];\n     }\n\n    $mask = ($inverted_masks[$length] << ($offset * 8));\n   \n    $code[$address] = ($code[$address] & ~$mask) | \n\t(($code[$address] & $mask) + ($value << ($offset * 8)) & \n\t$mask);\n    \n    printf STDERR \"New code : %08x\\n\", $code[$address] if ($debug);\n}\n\n# &parse_value($value, $word, $offset, $length) where $value is \n# \tan identifier or constant, $word is the word offset relative to \n#\t$address, $offset is the starting byte within that word, and \n#\t$length is the length of the field in bytes.\n#\n# Side effects are that the bytes are combined into the @code array\n#\trelative to $address, and that the %symbol_references table is \n# \tupdated as appropriate.\n\nsub parse_value {\n    local ($value, $word, $offset, $length) = @_;\n    local ($tmp);\n\n    $symbol = '';\n\n    if ($value =~ /^REL\\s*\\(\\s*($identifier)\\s*\\)\\s*(.*)/i) {\n\t$relative = 'REL';\n\t$symbol = $1;\n\t$value = $2;\nprint STDERR \"Relative reference $symbol\\n\" if ($debug);\n    } elsif ($value =~ /^($identifier)\\s*(.*)/) {\n\t$relative = 'ABS';\n\t$symbol = $1;\n\t$value = $2;\nprint STDERR \"Absolute reference $symbol\\n\" if ($debug);\n    } \n\n    if ($symbol ne '') {\nprint STDERR \"Referencing symbol $1, length = $length in $_\\n\" if ($debug);\n     \t$tmp = ($address + $word) * 4 + $offset;\n\tif ($symbol_references{$symbol} ne undef) {\n\t    $symbol_references{$symbol} = \n\t\t\"$symbol_references{$symbol} $relative,$tmp,$length\";\n\t} else {\n\t    if (!defined($symbol_values{$symbol})) {\nprint STDERR \"forward $1\\n\" if ($debug_external);\n\t\t$forward{$symbol} = \"line $lineno : $_\";\n\t    } \n\t    $symbol_references{$symbol} = \"$relative,$tmp,$length\";\n\t}\n    } \n\n    $value = eval $value;\n    &patch ($address + $word, $offset, $length, $value);\n}\n\n# &parse_conditional ($conditional) where $conditional is the conditional\n# clause from a transfer control instruction (RETURN, CALL, JUMP, INT).\n\nsub parse_conditional {\n    local ($conditional) = @_;\n    if ($conditional =~ /^\\s*(IF|WHEN)\\s*(.*)/i) {\n\t$if = $1;\n\t$conditional = $2;\n\tif ($if =~ /WHEN/i) {\n\t    $allow_atn = 0;\n\t    $code[$address] |= 0x00_01_00_00;\n\t    $allow_atn = 0;\n\t    print STDERR \"$0 : parsed WHEN\\n\" if ($debug);\n\t} else {\n\t    $allow_atn = 1;\n\t    print STDERR \"$0 : parsed IF\\n\" if ($debug);\n\t}\n    } else {\n\t    die \"$0 : syntax error in line $lineno : $_\n\texpected IF or WHEN\n\";\n    }\n\n    if ($conditional =~ /^NOT\\s+(.*)$/i) {\n\t$not = 'NOT ';\n\t$other = 'OR';\n\t$conditional = $1;\n\tprint STDERR \"$0 : parsed NOT\\n\" if ($debug);\n    } else {\n\t$code[$address] |= 0x00_08_00_00;\n\t$not = '';\n\t$other = 'AND'\n    }\n\n    $need_data = 0;\n    if ($conditional =~ /^ATN\\s*(.*)/i) {#\n\tdie \"$0 : syntax error in line $lineno : $_\n\tWHEN conditional is incompatible with ATN \n\" if (!$allow_atn);\n\t$code[$address] |= 0x00_02_00_00;\n\t$conditional = $1;\n\tprint STDERR \"$0 : parsed ATN\\n\" if ($debug);\n    } elsif ($conditional =~ /^($phase)\\s*(.*)/i) {\n\t$phase_index = \"\\U$1\\E\";\n\t$p = $scsi_phases{$phase_index};\n\t$code[$address] |= $p | 0x00_02_00_00;\n\t$conditional = $2;\n\tprint STDERR \"$0 : parsed phase $phase_index\\n\" if ($debug);\n    } else {\n\t$other = '';\n\t$need_data = 1;\n    }\n\nprint STDERR \"Parsing conjunction, expecting $other\\n\" if ($debug);\n    if ($conditional =~ /^(AND|OR)\\s*(.*)/i) {\n\t$conjunction = $1;\n\t$conditional = $2;\n\t$need_data = 1;\n\tdie \"$0 : syntax error in line $lineno : $_\n\t    Illegal use of $1.  Valid uses are \n\t    \".$not.\"<phase> $1 data\n\t    \".$not.\"ATN $1 data\n\" if ($other eq '');\n\tdie \"$0 : syntax error in line $lineno : $_\n\tIllegal use of $conjunction.  Valid syntaxes are \n\t\tNOT <phase>|ATN OR data\n\t\t<phase>|ATN AND data\n\" if ($conjunction !~ /\\s*$other\\s*/i);\n\tprint STDERR \"$0 : parsed $1\\n\" if ($debug);\n    }\n\n    if ($need_data) {\nprint STDERR \"looking for data in $conditional\\n\" if ($debug);\n\tif ($conditional=~ /^($value)\\s*(.*)/i) {\n\t    $code[$address] |= 0x00_04_00_00;\n\t    $conditional = $2;\n\t    &parse_value($1, 0, 0, 1);\n\t    print STDERR \"$0 : parsed data\\n\" if ($debug);\n\t} else {\n\tdie \"$0 : syntax error in line $lineno : $_\n\texpected <data>.\n\";\n\t}\n    }\n\n    if ($conditional =~ /^\\s*,\\s*(.*)/) {\n\t$conditional = $1;\n\tif ($conditional =~ /^AND\\s\\s*MASK\\s\\s*($value)\\s*(.*)/i) {\n\t    &parse_value ($1, 0, 1, 1);\n\t    print STDERR \"$0 parsed AND MASK $1\\n\" if ($debug);\n\t    die \"$0 : syntax error in line $lineno : $_\n\texpected end of line, not \\\"$2\\\"\n\" if ($2 ne '');\n\t} else {\n\t    die \"$0 : syntax error in line $lineno : $_\n\texpected \\\",AND MASK <data>\\\", not \\\"$2\\\"\n\";\n\t}\n    } elsif ($conditional !~ /^\\s*$/) { \n\tdie \"$0 : syntax error in line $lineno : $_\n\texpected end of line\" . (($need_data) ? \" or \\\"AND MASK <data>\\\"\" : \"\") . \"\n\tnot \\\"$conditional\\\"\n\";\n    }\n}\n\n# Parse command line\n$output = shift;\n$outputu = shift;\n\n    \n# Main loop\nwhile (<STDIN>) {\n    $lineno = $lineno + 1;\n    $list[$address] = $list[$address].$_;\n    s/;.*$//;\t\t\t\t# Strip comments\n\n\n    chop;\t\t\t\t# Leave new line out of error messages\n\n# Handle symbol definitions of the form label:\n    if (/^\\s*($identifier)\\s*:(.*)/) {\n\tif (!defined($symbol_values{$1})) {\n\t    $symbol_values{$1} = $address * 4;\t# Address is an index into\n\t    delete $forward{$1};\t\t# an array of longs\n\t    push (@label, $1);\n\t    $_ = $2;\n\t} else {\n\t    die \"$0 : redefinition of symbol $1 in line $lineno : $_\\n\";\n\t}\n    }\n\n# Handle symbol definitions of the form ABSOLUTE or RELATIVE identifier = \n# value\n    if (/^\\s*(ABSOLUTE|RELATIVE)\\s+(.*)/i) {\n\t$is_absolute = $1;\n\t$rest = $2;\n\tforeach $rest (split (/\\s*,\\s*/, $rest)) {\n\t    if ($rest =~ /^($identifier)\\s*=\\s*($constant)\\s*$/) {\n\t        local ($id, $cnst) = ($1, $2);\n\t\tif ($symbol_values{$id} eq undef) {\n\t\t    $symbol_values{$id} = eval $cnst;\n\t\t    delete $forward{$id};\n\t\t    if ($is_absolute =~ /ABSOLUTE/i) {\n\t\t\tpush (@absolute , $id);\n\t\t    } else {\n\t\t\tpush (@relative, $id);\n\t\t    }\n\t\t} else {\n\t\t    die \"$0 : redefinition of symbol $id in line $lineno : $_\\n\";\n\t\t}\n\t    } else {\n\t\tdie \n\"$0 : syntax error in line $lineno : $_\n\t    expected <identifier> = <value>\n\";\n\t    }\n\t}\n    } elsif (/^\\s*EXTERNAL\\s+(.*)/i) {\n\t$externals = $1;\n\tforeach $external (split (/,/,$externals)) {\n\t    if ($external =~ /\\s*($identifier)\\s*$/) {\n\t\t$external = $1;\n\t\tpush (@external, $external);\n\t\tdelete $forward{$external};\n\t\tif (defined($symbol_values{$external})) {\n\t\t\tdie \"$0 : redefinition of symbol $1 in line $lineno : $_\\n\";\n\t\t}\n\t\t$symbol_values{$external} = $external;\nprint STDERR \"defined external $1 to $external\\n\" if ($debug_external);\n\t    } else {\n\t\tdie \n\"$0 : syntax error in line $lineno : $_\n\texpected <identifier>, got $external\n\";\n\t    }\n\t}\n# Process ENTRY identifier declarations\n    } elsif (/^\\s*ENTRY\\s+(.*)/i) {\n\tif ($1 =~ /^($identifier)\\s*$/) {\n\t    push (@entry, $1);\n\t} else {\n\t    die\n\"$0 : syntax error in line $lineno : $_\n\texpected ENTRY <identifier>\n\";\n\t}\n# Process MOVE length, address, WITH|WHEN phase instruction\n    } elsif (/^\\s*MOVE\\s+(.*)/i) {\n\t$rest = $1;\n\tif ($rest =~ /^FROM\\s+($value)\\s*,\\s*(WITH|WHEN)\\s+($phase)\\s*$/i) {\n\t    $transfer_addr = $1;\n\t    $with_when = $2;\n\t    $scsi_phase = $3;\nprint STDERR \"Parsing MOVE FROM $transfer_addr, $with_when $3\\n\" if ($debug);\n\t    $code[$address] = 0x18_00_00_00 | (($with_when =~ /WITH/i) ? \n\t\t0x00_00_00_00 : 0x08_00_00_00) | $scsi_phases{$scsi_phase};\n\t    &parse_value ($transfer_addr, 1, 0, 4);\n\t    $address += 2;\n\t} elsif ($rest =~ /^($value)\\s*,\\s*(PTR\\s+|)($value)\\s*,\\s*(WITH|WHEN)\\s+($phase)\\s*$/i) {\n\t    $transfer_len = $1;\n\t    $ptr = $2;\n\t    $transfer_addr = $3;\n\t    $with_when = $4;\n\t    $scsi_phase = $5;\n\t    $code[$address] = (($with_when =~ /WITH/i) ? 0x00_00_00_00 : \n\t\t0x08_00_00_00)  | (($ptr =~ /PTR/i) ? (1 << 29) : 0) | \n\t\t$scsi_phases{$scsi_phase};\n\t    &parse_value ($transfer_len, 0, 0, 3);\n\t    &parse_value ($transfer_addr, 1, 0, 4);\n\t    $address += 2;\n\t} elsif ($rest =~ /^MEMORY\\s+(.*)/i) {\n\t    $rest = $1;\n\t    $code[$address] = 0xc0_00_00_00; \n\t    if ($rest =~ /^($value)\\s*,\\s*($value)\\s*,\\s*($value)\\s*$/) {\n\t\t$count = $1;\n\t\t$source = $2;\n\t\t$dest =  $3;\nprint STDERR \"Parsing MOVE MEMORY $count, $source, $dest\\n\" if ($debug);\n\t\t&parse_value ($count, 0, 0, 3);\n\t\t&parse_value ($source, 1, 0, 4);\n\t\t&parse_value ($dest, 2, 0, 4);\nprintf STDERR \"Move memory instruction = %08x,%08x,%08x\\n\", \n\t\t$code[$address], $code[$address+1], $code[$address +2] if\n\t\t($debug);\n\t\t$address += 3;\n\t\n\t    } else {\n\t\tdie \n\"$0 : syntax error in line $lineno : $_\n\texpected <count>, <source>, <destination>\n\"\n\t    }\n\t} elsif ($1 =~ /^(.*)\\s+(TO|SHL|SHR)\\s+(.*)/i) {\nprint STDERR \"Parsing register to register move\\n\" if ($debug);\n\t    $src = $1;\n\t    $op = \"\\U$2\\E\";\n\t    $rest = $3;\n\n\t    $code[$address] = 0x40_00_00_00;\n\t\n\t    $force = ($op !~ /TO/i); \n\n\nprint STDERR \"Forcing register source \\n\" if ($force && $debug);\n\n\t    if (!$force && $src =~ \n\t\t/^($register)\\s+(-|$operator)\\s+($value)\\s*$/i) {\nprint STDERR \"register operand  data8 source\\n\" if ($debug);\n\t\t$src_reg = \"\\U$1\\E\";\n\t\t$op = \"\\U$2\\E\";\n\t\tif ($op ne '-') {\n\t\t    $data8 = $3;\n\t\t} else {\n\t\t    die \"- is not implemented yet.\\n\"\n\t\t}\n\t    } elsif ($src =~ /^($register)\\s*$/i) {\nprint STDERR \"register source\\n\" if ($debug);\n\t\t$src_reg = \"\\U$1\\E\";\n\t\t# Encode register to register move as a register | 0 \n\t\t# move to register.\n\t\tif (!$force) {\n\t\t    $op = '|';\n\t\t}\n\t\t$data8 = 0;\n\t    } elsif (!$force && $src =~ /^($value)\\s*$/i) {\nprint STDERR \"data8 source\\n\" if ($debug);\n\t\t$src_reg = undef;\n\t\t$op = 'NONE';\n\t\t$data8 = $1;\n\t    } else {\n\t\tif (!$force) {\n\t\t    die \n\"$0 : syntax error in line $lineno : $_\n\texpected <register>\n\t\t<data8>\n\t\t<register> <operand> <data8>\n\";\n\t\t} else {\n\t\t    die\n\"$0 : syntax error in line $lineno : $_\n\texpected <register>\n\";\n\t\t}\n\t    }\n\t    if ($rest =~ /^($register)\\s*(.*)$/i) {\n\t\t$dst_reg = \"\\U$1\\E\";\n\t\t$rest = $2;\n\t    } else {\n\t    die \n\"$0 : syntax error in $lineno : $_\n\texpected <register>, got $rest\n\";\n\t    }\n\n\t    if ($rest =~ /^WITH\\s+CARRY\\s*(.*)/i) {\n\t\t$rest = $1;\n\t\tif ($op eq '+') {\n\t\t    $code[$address] |= 0x01_00_00_00;\n\t\t} else {\n\t\t    die\n\"$0 : syntax error in $lineno : $_\n\tWITH CARRY option is incompatible with the $op operator.\n\";\n\t\t}\n\t    }\n\n\t    if ($rest !~ /^\\s*$/) {\n\t\tdie\n\"$0 : syntax error in $lineno : $_\n\tExpected end of line, got $rest\n\";\n\t    }\n\n\t    print STDERR \"source = $src_reg, data = $data8 , destination = $dst_reg\\n\"\n\t\tif ($debug);\n\t    # Note that Move data8 to reg is encoded as a read-modify-write\n\t    # instruction.\n\t    if (($src_reg eq undef) || ($src_reg eq $dst_reg)) {\n\t\t$code[$address] |= 0x38_00_00_00 | \n\t\t    ($registers{$dst_reg} << 16);\n\t    } elsif ($dst_reg =~ /SFBR/i) {\n\t\t$code[$address] |= 0x30_00_00_00 |\n\t\t    ($registers{$src_reg} << 16);\n\t    } elsif ($src_reg =~ /SFBR/i) {\n\t\t$code[$address] |= 0x28_00_00_00 |\n\t\t    ($registers{$dst_reg} << 16);\n\t    } else {\n\t\tdie\n\"$0 : Illegal combination of registers in line $lineno : $_\n\tEither source and destination registers must be the same,\n\tor either source or destination register must be SFBR.\n\";\n\t    }\n\n\t    $code[$address] |= $operators{$op};\n\t    \n\t    &parse_value ($data8, 0, 1, 1);\n\t    $code[$address] |= $operators{$op};\n\t    $code[$address + 1] = 0x00_00_00_00;# Reserved\n\t    $address += 2;\n\t} else {\n\t    die \n\"$0 : syntax error in line $lineno : $_\n\texpected (initiator) <length>, <address>, WHEN <phase>\n\t\t (target) <length>, <address>, WITH <phase>\n\t\t MEMORY <length>, <source>, <destination>\n\t\t <expression> TO <register>\n\";\n\t}\n# Process SELECT {ATN|} id, fail_address\n    } elsif (/^\\s*(SELECT|RESELECT)\\s+(.*)/i) {\n\t$rest = $2;\n\tif ($rest =~ /^(ATN|)\\s*($value)\\s*,\\s*($identifier)\\s*$/i) {\n\t    $atn = $1;\n\t    $id = $2;\n\t    $alt_addr = $3;\n\t    $code[$address] = 0x40_00_00_00 | \n\t\t(($atn =~ /ATN/i) ? 0x01_00_00_00 : 0);\n\t    $code[$address + 1] = 0x00_00_00_00;\n\t    &parse_value($id, 0, 2, 1);\n\t    &parse_value($alt_addr, 1, 0, 4);\n\t    $address += 2;\n\t} elsif ($rest =~ /^(ATN|)\\s*FROM\\s+($value)\\s*,\\s*($identifier)\\s*$/i) {\n\t    $atn = $1;\n\t    $addr = $2;\n\t    $alt_addr = $3;\n\t    $code[$address] = 0x42_00_00_00 | \n\t\t(($atn =~ /ATN/i) ? 0x01_00_00_00 : 0);\n\t    $code[$address + 1] = 0x00_00_00_00;\n\t    &parse_value($addr, 0, 0, 3);\n\t    &parse_value($alt_addr, 1, 0, 4);\n\t    $address += 2;\n        } else {\n\t    die \n\"$0 : syntax error in line $lineno : $_\n\texpected SELECT id, alternate_address or \n\t\tSELECT FROM address, alternate_address or \n\t\tRESELECT id, alternate_address or\n\t\tRESELECT FROM address, alternate_address\n\";\n\t}\n    } elsif (/^\\s*WAIT\\s+(.*)/i) {\n\t    $rest = $1;\nprint STDERR \"Parsing WAIT $rest\\n\" if ($debug);\n\tif ($rest =~ /^DISCONNECT\\s*$/i) {\n\t    $code[$address] = 0x48_00_00_00;\n\t    $code[$address + 1] = 0x00_00_00_00;\n\t    $address += 2;\n\t} elsif ($rest =~ /^(RESELECT|SELECT)\\s+($identifier)\\s*$/i) {\n\t    $alt_addr = $2;\n\t    $code[$address] = 0x50_00_00_00;\n\t    &parse_value ($alt_addr, 1, 0, 4);\n\t    $address += 2;\n\t} else {\n\t    die\n\"$0 : syntax error in line $lineno : $_\n\texpected (initiator) WAIT DISCONNECT or \n\t\t (initiator) WAIT RESELECT alternate_address or\n\t\t (target) WAIT SELECT alternate_address\n\";\n\t}\n# Handle SET and CLEAR instructions.  Note that we should also do something\n# with this syntax to set target mode.\n    } elsif (/^\\s*(SET|CLEAR)\\s+(.*)/i) {\n\t$set = $1;\n\t$list = $2;\n\t$code[$address] = ($set =~ /SET/i) ?  0x58_00_00_00 : \n\t    0x60_00_00_00;\n\tforeach $arg (split (/\\s+AND\\s+/i,$list)) {\n\t    if ($arg =~ /ATN/i) {\n\t\t$code[$address] |= 0x00_00_00_08;\n\t    } elsif ($arg =~ /ACK/i) {\n\t\t$code[$address] |= 0x00_00_00_40;\n\t    } elsif ($arg =~ /TARGET/i) {\n\t\t$code[$address] |= 0x00_00_02_00;\n\t    } elsif ($arg =~ /CARRY/i) {\n\t\t$code[$address] |= 0x00_00_04_00;\n\t    } else {\n\t\tdie \n\"$0 : syntax error in line $lineno : $_\n\texpected $set followed by a AND delimited list of one or \n\tmore strings from the list ACK, ATN, CARRY, TARGET.\n\";\n\t    }\n\t}\n\t$code[$address + 1] = 0x00_00_00_00;\n\t$address += 2;\n    } elsif (/^\\s*(JUMP|CALL|INT)\\s+(.*)/i) {\n\t$instruction = $1;\n\t$rest = $2;\n\tif ($instruction =~ /JUMP/i) {\n\t    $code[$address] = 0x80_00_00_00;\n\t} elsif ($instruction =~ /CALL/i) {\n\t    $code[$address] = 0x88_00_00_00;\n\t} else {\n\t    $code[$address] = 0x98_00_00_00;\n\t}\nprint STDERR \"parsing JUMP, rest = $rest\\n\" if ($debug);\n\n# Relative jump. \n\tif ($rest =~ /^(REL\\s*\\(\\s*$identifier\\s*\\))\\s*(.*)/i) { \n\t    $addr = $1;\n\t    $rest = $2;\nprint STDERR \"parsing JUMP REL, addr = $addr, rest = $rest\\n\" if ($debug);\n\t    $code[$address]  |= 0x00_80_00_00;\n\t    &parse_value($addr, 1, 0, 4);\n# Absolute jump, requires no more gunk\n\t} elsif ($rest =~ /^($value)\\s*(.*)/) {\n\t    $addr = $1;\n\t    $rest = $2;\n\t    &parse_value($addr, 1, 0, 4);\n\t} else {\n\t    die\n\"$0 : syntax error in line $lineno : $_\n\texpected <address> or REL (address)\n\";\n\t}\n\n\tif ($rest =~ /^,\\s*(.*)/) {\n\t    &parse_conditional($1);\n\t} elsif ($rest =~ /^\\s*$/) {\n\t    $code[$address] |= (1 << 19);\n\t} else {\n\t    die\n\"$0 : syntax error in line $lineno : $_\n\texpected , <conditional> or end of line, got $1\n\";\n\t}\n\t\n\t$address += 2;\n    } elsif (/^\\s*(RETURN|INTFLY)\\s*(.*)/i) {\n\t$instruction = $1;\n\t$conditional = $2; \nprint STDERR \"Parsing $instruction\\n\" if ($debug);\n\t$code[$address] = ($instruction =~ /RETURN/i) ? 0x90_00_00_00 :\n\t    0x98_10_00_00;\n\tif ($conditional =~ /^,\\s*(.*)/) {\n\t    $conditional = $1;\n\t    &parse_conditional ($conditional);\n\t} elsif ($conditional !~ /^\\s*$/) {\n\t    die\n\"$0 : syntax error in line $lineno : $_\n\texpected , <conditional> \n\";\n\t} else {\n\t    $code[$address] |= 0x00_08_00_00;\n\t}\n\t   \n\t$code[$address + 1] = 0x00_00_00_00;\n\t$address += 2;\n    } elsif (/^\\s*DISCONNECT\\s*$/) {\n\t$code[$address] = 0x48_00_00_00;\n\t$code[$address + 1] = 0x00_00_00_00;\n\t$address += 2;\n# I'm not sure that I should be including this extension, but \n# what the hell?\n    } elsif (/^\\s*NOP\\s*$/i) {\n\t$code[$address] = 0x80_88_00_00;\n\t$code[$address + 1] = 0x00_00_00_00;\n\t$address += 2;\n# Ignore lines consisting entirely of white space\n    } elsif (/^\\s*$/) {\n    } else {\n\tdie \n\"$0 : syntax error in line $lineno: $_\n\texpected label:, ABSOLUTE, CLEAR, DISCONNECT, EXTERNAL, MOVE, RESELECT,\n\t    SELECT SET, or WAIT\n\";\n    }\n}\n\n# Fill in label references\n\n@undefined = keys %forward;\nif ($#undefined >= 0) {\n    print STDERR \"Undefined symbols : \\n\";\n    foreach $undef (@undefined) {\n\tprint STDERR \"$undef in $forward{$undef}\\n\";\n    }\n    exit 1;\n}\n\n@label_patches = ();\n\n@external_patches = ();\n\n@absolute = sort @absolute;\n\nforeach $i (@absolute) {\n    foreach $j (split (/\\s+/,$symbol_references{$i})) {\n\t$j =~ /(REL|ABS),(.*),(.*)/;\n\t$type = $1;\n\t$address = $2;\n\t$length = $3;\n\tdie \n\"$0 : $symbol $i has invalid relative reference at address $address,\n    size $length\\n\"\n\tif ($type eq 'REL');\n\t    \n\t&patch ($address / 4, $address % 4, $length, $symbol_values{$i});\n    }\n}\n\nforeach $external (@external) {\nprint STDERR \"checking external $external \\n\" if ($debug_external);\n    if ($symbol_references{$external} ne undef) {\n\tfor $reference (split(/\\s+/,$symbol_references{$external})) {\n\t    $reference =~ /(REL|ABS),(.*),(.*)/;\n\t    $type = $1;\n\t    $address = $2;\n\t    $length = $3;\n\t    \n\t    die \n\"$0 : symbol $label is external, has invalid relative reference at $address,\n    size $length\\n\"\n\t\tif ($type eq 'REL');\n\n\t    die \n\"$0 : symbol $label has invalid reference at $address, size $length\\n\"\n\t\tif ((($address % 4) !=0) || ($length != 4));\n\n\t    $symbol = $symbol_values{$external};\n\t    $add = $code[$address / 4];\n\t    if ($add eq 0) {\n\t\t$code[$address / 4] = $symbol;\n\t    } else {\n\t\t$add = sprintf (\"0x%08x\", $add);\n\t\t$code[$address / 4] = \"$symbol + $add\";\n\t    }\n\t\t\nprint STDERR \"referenced external $external at $1\\n\" if ($debug_external);\n\t}\n    }\n}\n\nforeach $label (@label) {\n    if ($symbol_references{$label} ne undef) {\n\tfor $reference (split(/\\s+/,$symbol_references{$label})) {\n\t    $reference =~ /(REL|ABS),(.*),(.*)/;\n\t    $type = $1;\n\t    $address = $2;\n\t    $length = $3;\n\n\t    if ((($address % 4) !=0) || ($length != 4)) {\n\t\tdie \"$0 : symbol $label has invalid reference at $1, size $2\\n\";\n\t    }\n\n\t    if ($type eq 'ABS') {\n\t\t$code[$address / 4] += $symbol_values{$label};\n\t\tpush (@label_patches, $address / 4);\n\t    } else {\n# \n# - The address of the reference should be in the second and last word\n#\tof an instruction\n# - Relative jumps, etc. are relative to the DSP of the _next_ instruction\n#\n# So, we need to add four to the address of the reference, to get \n# the address of the next instruction, when computing the reference.\n  \n\t\t$tmp = $symbol_values{$label} - \n\t\t    ($address + 4);\n\t\tdie \n# Relative addressing is limited to 24 bits.\n\"$0 : symbol $label is too far ($tmp) from $address to reference as \n    relative/\\n\" if (($tmp >= 0x80_00_00) || ($tmp < -0x80_00_00));\n\t\t$code[$address / 4] = $tmp & 0x00_ff_ff_ff;\n\t    }\n\t}\n    }\n}\n\n# Output SCRIPT[] array, one instruction per line.  Optionally \n# print the original code too.\n\nopen (OUTPUT, \">$output\") || die \"$0 : can't open $output for writing\\n\";\nopen (OUTPUTU, \">$outputu\") || die \"$0 : can't open $outputu for writing\\n\";\n\n($_ = $0) =~ s:.*/::;\nprint OUTPUT \"/* DO NOT EDIT - Generated automatically by \".$_.\" */\\n\";\nprint OUTPUT \"static u32 \".$prefix.\"SCRIPT[] = {\\n\";\n$instructions = 0;\nfor ($i = 0; $i < $#code; ) {\n    if ($list_in_array) {\n\tprintf OUTPUT \"/*\\n$list[$i]\\nat 0x%08x : */\", $i;\n    }\n    printf OUTPUT \"\\t0x%08x,\", $code[$i];\n    printf STDERR \"Address $i = %x\\n\", $code[$i] if ($debug);\n    if ($code[$i + 1] =~ /\\s*($identifier)(.*)$/) {\n\tpush (@external_patches, $i+1, $1);\n\tprintf OUTPUT \"0%s,\", $2\n    } else {\n\tprintf OUTPUT \"0x%08x,\",$code[$i+1];\n    }\n\n    if (($code[$i] & 0xff_00_00_00) == 0xc0_00_00_00) {\n\tif ($code[$i + 2] =~ /$identifier/) {\n\t    push (@external_patches, $i+2, $code[$i+2]);\n\t    printf OUTPUT \"0,\\n\";\n\t} else {\n\t    printf OUTPUT \"0x%08x,\\n\",$code[$i+2];\n\t}\n\t$i += 3;\n    } else {\n\tprintf OUTPUT \"\\n\";\n\t$i += 2;\n    }\n    $instructions += 1;\n}\nprint OUTPUT \"};\\n\\n\";\n\nforeach $i (@absolute) {\n    printf OUTPUT \"#define A_$i\\t0x%08x\\n\", $symbol_values{$i};\n    if (defined($prefix) && $prefix ne '') {\n\tprintf OUTPUT \"#define A_\".$i.\"_used \".$prefix.\"A_\".$i.\"_used\\n\";\n\tprintf OUTPUTU \"#undef A_\".$i.\"_used\\n\";\n    }\n    printf OUTPUTU \"#undef A_$i\\n\";\n\n    printf OUTPUT \"static u32 A_\".$i.\"_used\\[\\] __attribute((unused)) = {\\n\";\nprintf STDERR \"$i is used $symbol_references{$i}\\n\" if ($debug);\n    foreach $j (split (/\\s+/,$symbol_references{$i})) {\n\t$j =~ /(ABS|REL),(.*),(.*)/;\n\tif ($1 eq 'ABS') {\n\t    $address = $2;\n\t    $length = $3;\n\t    printf OUTPUT \"\\t0x%08x,\\n\", $address / 4;\n\t}\n    }\n    printf OUTPUT \"};\\n\\n\";\n}\n\nforeach $i (sort @entry) {\n    printf OUTPUT \"#define Ent_$i\\t0x%08x\\n\", $symbol_values{$i};\n    printf OUTPUTU \"#undef Ent_$i\\n\", $symbol_values{$i};\n}\n\n#\n# NCR assembler outputs label patches in the form of indices into \n# the code.\n#\nprintf OUTPUT \"static u32 \".$prefix.\"LABELPATCHES[] __attribute((unused)) = {\\n\";\nfor $patch (sort {$a <=> $b} @label_patches) {\n    printf OUTPUT \"\\t0x%08x,\\n\", $patch;\n}\nprintf OUTPUT \"};\\n\\n\";\n\n$num_external_patches = 0;\nprintf OUTPUT \"static struct {\\n\\tu32\\toffset;\\n\\tvoid\\t\\t*address;\\n\".\n    \"} \".$prefix.\"EXTERNAL_PATCHES[] __attribute((unused)) = {\\n\";\nwhile ($ident = pop(@external_patches)) {\n    $off = pop(@external_patches);\n    printf OUTPUT \"\\t{0x%08x, &%s},\\n\", $off, $ident;\n    ++$num_external_patches;\n}\nprintf OUTPUT \"};\\n\\n\";\n\nprintf OUTPUT \"static u32 \".$prefix.\"INSTRUCTIONS __attribute((unused))\\t= %d;\\n\", \n    $instructions;\nprintf OUTPUT \"static u32 \".$prefix.\"PATCHES __attribute((unused))\\t= %d;\\n\", \n    $#label_patches+1;\nprintf OUTPUT \"static u32 \".$prefix.\"EXTERNAL_PATCHES_LEN __attribute((unused))\\t= %d;\\n\",\n    $num_external_patches;\nclose OUTPUT;\nclose OUTPUTU;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}