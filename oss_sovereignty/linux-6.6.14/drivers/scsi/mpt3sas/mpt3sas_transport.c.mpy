{
  "module_name": "mpt3sas_transport.c",
  "hash_id": "a3d29b2e5db8fe22e644723c6fca5e0df640dd229a9c1f05d25d48ea3b193dd4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mpt3sas/mpt3sas_transport.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_sas.h>\n#include <scsi/scsi_dbg.h>\n\n#include \"mpt3sas_base.h\"\n\n \nstatic inline u8\n_transport_get_port_id_by_sas_phy(struct sas_phy *phy)\n{\n\tu8 port_id = 0xFF;\n\tstruct hba_port *port = phy->hostdata;\n\n\tif (port)\n\t\tport_id = port->port_id;\n\n\treturn port_id;\n}\n\n \nstatic struct _sas_node *\n_transport_sas_node_find_by_sas_address(struct MPT3SAS_ADAPTER *ioc,\n\tu64 sas_address, struct hba_port *port)\n{\n\tif (ioc->sas_hba.sas_address == sas_address)\n\t\treturn &ioc->sas_hba;\n\telse\n\t\treturn mpt3sas_scsih_expander_find_by_sas_address(ioc,\n\t\t    sas_address, port);\n}\n\n \nstatic u8\n_transport_get_port_id_by_rphy(struct MPT3SAS_ADAPTER *ioc,\n\tstruct sas_rphy *rphy)\n{\n\tstruct _sas_node *sas_expander;\n\tstruct _sas_device *sas_device;\n\tunsigned long flags;\n\tu8 port_id = 0xFF;\n\n\tif (!rphy)\n\t\treturn port_id;\n\n\tif (rphy->identify.device_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t    rphy->identify.device_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\t\tlist_for_each_entry(sas_expander,\n\t\t    &ioc->sas_expander_list, list) {\n\t\t\tif (sas_expander->rphy == rphy) {\n\t\t\t\tport_id = sas_expander->port->port_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t} else if (rphy->identify.device_type == SAS_END_DEVICE) {\n\t\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\t\tsas_device = __mpt3sas_get_sdev_by_rphy(ioc, rphy);\n\t\tif (sas_device) {\n\t\t\tport_id = sas_device->port->port_id;\n\t\t\tsas_device_put(sas_device);\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\t}\n\n\treturn port_id;\n}\n\n \nstatic enum sas_linkrate\n_transport_convert_phy_link_rate(u8 link_rate)\n{\n\tenum sas_linkrate rc;\n\n\tswitch (link_rate) {\n\tcase MPI2_SAS_NEG_LINK_RATE_1_5:\n\t\trc = SAS_LINK_RATE_1_5_GBPS;\n\t\tbreak;\n\tcase MPI2_SAS_NEG_LINK_RATE_3_0:\n\t\trc = SAS_LINK_RATE_3_0_GBPS;\n\t\tbreak;\n\tcase MPI2_SAS_NEG_LINK_RATE_6_0:\n\t\trc = SAS_LINK_RATE_6_0_GBPS;\n\t\tbreak;\n\tcase MPI25_SAS_NEG_LINK_RATE_12_0:\n\t\trc = SAS_LINK_RATE_12_0_GBPS;\n\t\tbreak;\n\tcase MPI2_SAS_NEG_LINK_RATE_PHY_DISABLED:\n\t\trc = SAS_PHY_DISABLED;\n\t\tbreak;\n\tcase MPI2_SAS_NEG_LINK_RATE_NEGOTIATION_FAILED:\n\t\trc = SAS_LINK_RATE_FAILED;\n\t\tbreak;\n\tcase MPI2_SAS_NEG_LINK_RATE_PORT_SELECTOR:\n\t\trc = SAS_SATA_PORT_SELECTOR;\n\t\tbreak;\n\tcase MPI2_SAS_NEG_LINK_RATE_SMP_RESET_IN_PROGRESS:\n\t\trc = SAS_PHY_RESET_IN_PROGRESS;\n\t\tbreak;\n\n\tdefault:\n\tcase MPI2_SAS_NEG_LINK_RATE_SATA_OOB_COMPLETE:\n\tcase MPI2_SAS_NEG_LINK_RATE_UNKNOWN_LINK_RATE:\n\t\trc = SAS_LINK_RATE_UNKNOWN;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\n \nstatic int\n_transport_set_identify(struct MPT3SAS_ADAPTER *ioc, u16 handle,\n\tstruct sas_identify *identify)\n{\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu32 device_info;\n\tu32 ioc_status;\n\n\tif (ioc->shost_recovery || ioc->pci_error_recovery) {\n\t\tioc_info(ioc, \"%s: host reset in progress!\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\n\t    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"handle(0x%04x), ioc_status(0x%04x) failure at %s:%d/%s()!\\n\",\n\t\t\thandle, ioc_status, __FILE__, __LINE__, __func__);\n\t\treturn -EIO;\n\t}\n\n\tmemset(identify, 0, sizeof(struct sas_identify));\n\tdevice_info = le32_to_cpu(sas_device_pg0.DeviceInfo);\n\n\t \n\tidentify->sas_address = le64_to_cpu(sas_device_pg0.SASAddress);\n\n\t \n\tidentify->phy_identifier = sas_device_pg0.PhyNum;\n\n\t \n\tswitch (device_info & MPI2_SAS_DEVICE_INFO_MASK_DEVICE_TYPE) {\n\tcase MPI2_SAS_DEVICE_INFO_NO_DEVICE:\n\t\tidentify->device_type = SAS_PHY_UNUSED;\n\t\tbreak;\n\tcase MPI2_SAS_DEVICE_INFO_END_DEVICE:\n\t\tidentify->device_type = SAS_END_DEVICE;\n\t\tbreak;\n\tcase MPI2_SAS_DEVICE_INFO_EDGE_EXPANDER:\n\t\tidentify->device_type = SAS_EDGE_EXPANDER_DEVICE;\n\t\tbreak;\n\tcase MPI2_SAS_DEVICE_INFO_FANOUT_EXPANDER:\n\t\tidentify->device_type = SAS_FANOUT_EXPANDER_DEVICE;\n\t\tbreak;\n\t}\n\n\t \n\tif (device_info & MPI2_SAS_DEVICE_INFO_SSP_INITIATOR)\n\t\tidentify->initiator_port_protocols |= SAS_PROTOCOL_SSP;\n\tif (device_info & MPI2_SAS_DEVICE_INFO_STP_INITIATOR)\n\t\tidentify->initiator_port_protocols |= SAS_PROTOCOL_STP;\n\tif (device_info & MPI2_SAS_DEVICE_INFO_SMP_INITIATOR)\n\t\tidentify->initiator_port_protocols |= SAS_PROTOCOL_SMP;\n\tif (device_info & MPI2_SAS_DEVICE_INFO_SATA_HOST)\n\t\tidentify->initiator_port_protocols |= SAS_PROTOCOL_SATA;\n\n\t \n\tif (device_info & MPI2_SAS_DEVICE_INFO_SSP_TARGET)\n\t\tidentify->target_port_protocols |= SAS_PROTOCOL_SSP;\n\tif (device_info & MPI2_SAS_DEVICE_INFO_STP_TARGET)\n\t\tidentify->target_port_protocols |= SAS_PROTOCOL_STP;\n\tif (device_info & MPI2_SAS_DEVICE_INFO_SMP_TARGET)\n\t\tidentify->target_port_protocols |= SAS_PROTOCOL_SMP;\n\tif (device_info & MPI2_SAS_DEVICE_INFO_SATA_DEVICE)\n\t\tidentify->target_port_protocols |= SAS_PROTOCOL_SATA;\n\n\treturn 0;\n}\n\n \nu8\nmpt3sas_transport_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\n\tu32 reply)\n{\n\tMPI2DefaultReply_t *mpi_reply;\n\n\tmpi_reply =  mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tif (ioc->transport_cmds.status == MPT3_CMD_NOT_USED)\n\t\treturn 1;\n\tif (ioc->transport_cmds.smid != smid)\n\t\treturn 1;\n\tioc->transport_cmds.status |= MPT3_CMD_COMPLETE;\n\tif (mpi_reply) {\n\t\tmemcpy(ioc->transport_cmds.reply, mpi_reply,\n\t\t    mpi_reply->MsgLength*4);\n\t\tioc->transport_cmds.status |= MPT3_CMD_REPLY_VALID;\n\t}\n\tioc->transport_cmds.status &= ~MPT3_CMD_PENDING;\n\tcomplete(&ioc->transport_cmds.done);\n\treturn 1;\n}\n\n \nstruct rep_manu_request {\n\tu8 smp_frame_type;\n\tu8 function;\n\tu8 reserved;\n\tu8 request_length;\n};\n\n \nstruct rep_manu_reply {\n\tu8 smp_frame_type;  \n\tu8 function;  \n\tu8 function_result;\n\tu8 response_length;\n\tu16 expander_change_count;\n\tu8 reserved0[2];\n\tu8 sas_format;\n\tu8 reserved2[3];\n\tu8 vendor_id[SAS_EXPANDER_VENDOR_ID_LEN];\n\tu8 product_id[SAS_EXPANDER_PRODUCT_ID_LEN];\n\tu8 product_rev[SAS_EXPANDER_PRODUCT_REV_LEN];\n\tu8 component_vendor_id[SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN];\n\tu16 component_id;\n\tu8 component_revision_id;\n\tu8 reserved3;\n\tu8 vendor_specific[8];\n};\n\n \nstatic int\n_transport_expander_report_manufacture(struct MPT3SAS_ADAPTER *ioc,\n\tu64 sas_address, struct sas_expander_device *edev, u8 port_id)\n{\n\tMpi2SmpPassthroughRequest_t *mpi_request;\n\tMpi2SmpPassthroughReply_t *mpi_reply;\n\tstruct rep_manu_reply *manufacture_reply;\n\tstruct rep_manu_request *manufacture_request;\n\tint rc;\n\tu16 smid;\n\tvoid *psge;\n\tu8 issue_reset = 0;\n\tvoid *data_out = NULL;\n\tdma_addr_t data_out_dma;\n\tdma_addr_t data_in_dma;\n\tsize_t data_in_sz;\n\tsize_t data_out_sz;\n\n\tif (ioc->shost_recovery || ioc->pci_error_recovery) {\n\t\tioc_info(ioc, \"%s: host reset in progress!\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tmutex_lock(&ioc->transport_cmds.mutex);\n\n\tif (ioc->transport_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: transport_cmds in use\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\tioc->transport_cmds.status = MPT3_CMD_PENDING;\n\n\trc = mpt3sas_wait_for_ioc(ioc, IOC_OPERATIONAL_WAIT_COUNT);\n\tif (rc)\n\t\tgoto out;\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->transport_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->transport_cmds.smid = smid;\n\n\tdata_out_sz = sizeof(struct rep_manu_request);\n\tdata_in_sz = sizeof(struct rep_manu_reply);\n\tdata_out = dma_alloc_coherent(&ioc->pdev->dev, data_out_sz + data_in_sz,\n\t\t\t&data_out_dma, GFP_KERNEL);\n\tif (!data_out) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\", __FILE__,\n\t\t    __LINE__, __func__);\n\t\trc = -ENOMEM;\n\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\tgoto out;\n\t}\n\n\tdata_in_dma = data_out_dma + sizeof(struct rep_manu_request);\n\n\tmanufacture_request = data_out;\n\tmanufacture_request->smp_frame_type = 0x40;\n\tmanufacture_request->function = 1;\n\tmanufacture_request->reserved = 0;\n\tmanufacture_request->request_length = 0;\n\n\tmemset(mpi_request, 0, sizeof(Mpi2SmpPassthroughRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_SMP_PASSTHROUGH;\n\tmpi_request->PhysicalPort = port_id;\n\tmpi_request->SASAddress = cpu_to_le64(sas_address);\n\tmpi_request->RequestDataLength = cpu_to_le16(data_out_sz);\n\tpsge = &mpi_request->SGL;\n\n\tioc->build_sg(ioc, psge, data_out_dma, data_out_sz, data_in_dma,\n\t    data_in_sz);\n\n\tdtransportprintk(ioc,\n\t\t\t ioc_info(ioc, \"report_manufacture - send to sas_addr(0x%016llx)\\n\",\n\t\t\t\t  (u64)sas_address));\n\tinit_completion(&ioc->transport_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);\n\n\tif (!(ioc->transport_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tioc_err(ioc, \"%s: timeout\\n\", __func__);\n\t\t_debug_dump_mf(mpi_request,\n\t\t    sizeof(Mpi2SmpPassthroughRequest_t)/4);\n\t\tif (!(ioc->transport_cmds.status & MPT3_CMD_RESET))\n\t\t\tissue_reset = 1;\n\t\tgoto issue_host_reset;\n\t}\n\n\tdtransportprintk(ioc, ioc_info(ioc, \"report_manufacture - complete\\n\"));\n\n\tif (ioc->transport_cmds.status & MPT3_CMD_REPLY_VALID) {\n\t\tu8 *tmp;\n\n\t\tmpi_reply = ioc->transport_cmds.reply;\n\n\t\tdtransportprintk(ioc,\n\t\t\t\t ioc_info(ioc, \"report_manufacture - reply data transfer size(%d)\\n\",\n\t\t\t\t\t  le16_to_cpu(mpi_reply->ResponseDataLength)));\n\n\t\tif (le16_to_cpu(mpi_reply->ResponseDataLength) !=\n\t\t    sizeof(struct rep_manu_reply))\n\t\t\tgoto out;\n\n\t\tmanufacture_reply = data_out + sizeof(struct rep_manu_request);\n\t\tstrncpy(edev->vendor_id, manufacture_reply->vendor_id,\n\t\t     SAS_EXPANDER_VENDOR_ID_LEN);\n\t\tstrncpy(edev->product_id, manufacture_reply->product_id,\n\t\t     SAS_EXPANDER_PRODUCT_ID_LEN);\n\t\tstrncpy(edev->product_rev, manufacture_reply->product_rev,\n\t\t     SAS_EXPANDER_PRODUCT_REV_LEN);\n\t\tedev->level = manufacture_reply->sas_format & 1;\n\t\tif (edev->level) {\n\t\t\tstrncpy(edev->component_vendor_id,\n\t\t\t    manufacture_reply->component_vendor_id,\n\t\t\t     SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN);\n\t\t\ttmp = (u8 *)&manufacture_reply->component_id;\n\t\t\tedev->component_id = tmp[0] << 8 | tmp[1];\n\t\t\tedev->component_revision_id =\n\t\t\t    manufacture_reply->component_revision_id;\n\t\t}\n\t} else\n\t\tdtransportprintk(ioc,\n\t\t\t\t ioc_info(ioc, \"report_manufacture - no reply\\n\"));\n\n issue_host_reset:\n\tif (issue_reset)\n\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n out:\n\tioc->transport_cmds.status = MPT3_CMD_NOT_USED;\n\tif (data_out)\n\t\tdma_free_coherent(&ioc->pdev->dev, data_out_sz + data_in_sz,\n\t\t    data_out, data_out_dma);\n\n\tmutex_unlock(&ioc->transport_cmds.mutex);\n\treturn rc;\n}\n\n\n \nstatic void\n_transport_delete_port(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_port *mpt3sas_port)\n{\n\tu64 sas_address = mpt3sas_port->remote_identify.sas_address;\n\tstruct hba_port *port = mpt3sas_port->hba_port;\n\tenum sas_device_type device_type =\n\t    mpt3sas_port->remote_identify.device_type;\n\n\tdev_printk(KERN_INFO, &mpt3sas_port->port->dev,\n\t    \"remove: sas_addr(0x%016llx)\\n\",\n\t    (unsigned long long) sas_address);\n\n\tioc->logging_level |= MPT_DEBUG_TRANSPORT;\n\tif (device_type == SAS_END_DEVICE)\n\t\tmpt3sas_device_remove_by_sas_address(ioc,\n\t\t    sas_address, port);\n\telse if (device_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t    device_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\tmpt3sas_expander_remove(ioc, sas_address, port);\n\tioc->logging_level &= ~MPT_DEBUG_TRANSPORT;\n}\n\n \nstatic void\n_transport_delete_phy(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_port *mpt3sas_port, struct _sas_phy *mpt3sas_phy)\n{\n\tu64 sas_address = mpt3sas_port->remote_identify.sas_address;\n\n\tdev_printk(KERN_INFO, &mpt3sas_phy->phy->dev,\n\t    \"remove: sas_addr(0x%016llx), phy(%d)\\n\",\n\t    (unsigned long long) sas_address, mpt3sas_phy->phy_id);\n\n\tlist_del(&mpt3sas_phy->port_siblings);\n\tmpt3sas_port->num_phys--;\n\tsas_port_delete_phy(mpt3sas_port->port, mpt3sas_phy->phy);\n\tmpt3sas_phy->phy_belongs_to_port = 0;\n}\n\n \nstatic void\n_transport_add_phy(struct MPT3SAS_ADAPTER *ioc, struct _sas_port *mpt3sas_port,\n\tstruct _sas_phy *mpt3sas_phy)\n{\n\tu64 sas_address = mpt3sas_port->remote_identify.sas_address;\n\n\tdev_printk(KERN_INFO, &mpt3sas_phy->phy->dev,\n\t    \"add: sas_addr(0x%016llx), phy(%d)\\n\", (unsigned long long)\n\t    sas_address, mpt3sas_phy->phy_id);\n\n\tlist_add_tail(&mpt3sas_phy->port_siblings, &mpt3sas_port->phy_list);\n\tmpt3sas_port->num_phys++;\n\tsas_port_add_phy(mpt3sas_port->port, mpt3sas_phy->phy);\n\tmpt3sas_phy->phy_belongs_to_port = 1;\n}\n\n \nvoid\nmpt3sas_transport_add_phy_to_an_existing_port(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_node *sas_node, struct _sas_phy *mpt3sas_phy,\n\tu64 sas_address, struct hba_port *port)\n{\n\tstruct _sas_port *mpt3sas_port;\n\tstruct _sas_phy *phy_srch;\n\n\tif (mpt3sas_phy->phy_belongs_to_port == 1)\n\t\treturn;\n\n\tif (!port)\n\t\treturn;\n\n\tlist_for_each_entry(mpt3sas_port, &sas_node->sas_port_list,\n\t    port_list) {\n\t\tif (mpt3sas_port->remote_identify.sas_address !=\n\t\t    sas_address)\n\t\t\tcontinue;\n\t\tif (mpt3sas_port->hba_port != port)\n\t\t\tcontinue;\n\t\tlist_for_each_entry(phy_srch, &mpt3sas_port->phy_list,\n\t\t    port_siblings) {\n\t\t\tif (phy_srch == mpt3sas_phy)\n\t\t\t\treturn;\n\t\t}\n\t\t_transport_add_phy(ioc, mpt3sas_port, mpt3sas_phy);\n\t\treturn;\n\t}\n\n}\n\n \nvoid\nmpt3sas_transport_del_phy_from_an_existing_port(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_node *sas_node, struct _sas_phy *mpt3sas_phy)\n{\n\tstruct _sas_port *mpt3sas_port, *next;\n\tstruct _sas_phy *phy_srch;\n\n\tif (mpt3sas_phy->phy_belongs_to_port == 0)\n\t\treturn;\n\n\tlist_for_each_entry_safe(mpt3sas_port, next, &sas_node->sas_port_list,\n\t    port_list) {\n\t\tlist_for_each_entry(phy_srch, &mpt3sas_port->phy_list,\n\t\t    port_siblings) {\n\t\t\tif (phy_srch != mpt3sas_phy)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (mpt3sas_port->num_phys == 1 && !ioc->shost_recovery)\n\t\t\t\t_transport_delete_port(ioc, mpt3sas_port);\n\t\t\telse\n\t\t\t\t_transport_delete_phy(ioc, mpt3sas_port,\n\t\t\t\t    mpt3sas_phy);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nstatic void\n_transport_sanity_check(struct MPT3SAS_ADAPTER *ioc, struct _sas_node *sas_node,\n\tu64 sas_address, struct hba_port *port)\n{\n\tint i;\n\n\tfor (i = 0; i < sas_node->num_phys; i++) {\n\t\tif (sas_node->phy[i].remote_identify.sas_address != sas_address)\n\t\t\tcontinue;\n\t\tif (sas_node->phy[i].port != port)\n\t\t\tcontinue;\n\t\tif (sas_node->phy[i].phy_belongs_to_port == 1)\n\t\t\tmpt3sas_transport_del_phy_from_an_existing_port(ioc,\n\t\t\t    sas_node, &sas_node->phy[i]);\n\t}\n}\n\n \nstruct _sas_port *\nmpt3sas_transport_port_add(struct MPT3SAS_ADAPTER *ioc, u16 handle,\n\tu64 sas_address, struct hba_port *hba_port)\n{\n\tstruct _sas_phy *mpt3sas_phy, *next;\n\tstruct _sas_port *mpt3sas_port;\n\tunsigned long flags;\n\tstruct _sas_node *sas_node;\n\tstruct sas_rphy *rphy;\n\tstruct _sas_device *sas_device = NULL;\n\tint i;\n\tstruct sas_port *port;\n\tstruct virtual_phy *vphy = NULL;\n\n\tif (!hba_port) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn NULL;\n\t}\n\n\tmpt3sas_port = kzalloc(sizeof(struct _sas_port),\n\t    GFP_KERNEL);\n\tif (!mpt3sas_port) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&mpt3sas_port->port_list);\n\tINIT_LIST_HEAD(&mpt3sas_port->phy_list);\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tsas_node = _transport_sas_node_find_by_sas_address(ioc,\n\t    sas_address, hba_port);\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\n\tif (!sas_node) {\n\t\tioc_err(ioc, \"%s: Could not find parent sas_address(0x%016llx)!\\n\",\n\t\t\t__func__, (u64)sas_address);\n\t\tgoto out_fail;\n\t}\n\n\tif ((_transport_set_identify(ioc, handle,\n\t    &mpt3sas_port->remote_identify))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out_fail;\n\t}\n\n\tif (mpt3sas_port->remote_identify.device_type == SAS_PHY_UNUSED) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out_fail;\n\t}\n\n\tmpt3sas_port->hba_port = hba_port;\n\t_transport_sanity_check(ioc, sas_node,\n\t    mpt3sas_port->remote_identify.sas_address, hba_port);\n\n\tfor (i = 0; i < sas_node->num_phys; i++) {\n\t\tif (sas_node->phy[i].remote_identify.sas_address !=\n\t\t    mpt3sas_port->remote_identify.sas_address)\n\t\t\tcontinue;\n\t\tif (sas_node->phy[i].port != hba_port)\n\t\t\tcontinue;\n\t\tlist_add_tail(&sas_node->phy[i].port_siblings,\n\t\t    &mpt3sas_port->phy_list);\n\t\tmpt3sas_port->num_phys++;\n\t\tif (sas_node->handle <= ioc->sas_hba.num_phys) {\n\t\t\tif (!sas_node->phy[i].hba_vphy) {\n\t\t\t\thba_port->phy_mask |= (1 << i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvphy = mpt3sas_get_vphy_by_phy(ioc, hba_port, i);\n\t\t\tif (!vphy) {\n\t\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!mpt3sas_port->num_phys) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out_fail;\n\t}\n\n\tif (mpt3sas_port->remote_identify.device_type == SAS_END_DEVICE) {\n\t\tsas_device = mpt3sas_get_sdev_by_addr(ioc,\n\t\t    mpt3sas_port->remote_identify.sas_address,\n\t\t    mpt3sas_port->hba_port);\n\t\tif (!sas_device) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\tgoto out_fail;\n\t\t}\n\t\tsas_device->pend_sas_rphy_add = 1;\n\t}\n\n\tif (!sas_node->parent_dev) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out_fail;\n\t}\n\tport = sas_port_alloc_num(sas_node->parent_dev);\n\tif (!port || (sas_port_add(port))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out_fail;\n\t}\n\n\tlist_for_each_entry(mpt3sas_phy, &mpt3sas_port->phy_list,\n\t    port_siblings) {\n\t\tif ((ioc->logging_level & MPT_DEBUG_TRANSPORT))\n\t\t\tdev_printk(KERN_INFO, &port->dev,\n\t\t\t\t\"add: handle(0x%04x), sas_addr(0x%016llx), phy(%d)\\n\",\n\t\t\t\thandle, (unsigned long long)\n\t\t\t    mpt3sas_port->remote_identify.sas_address,\n\t\t\t    mpt3sas_phy->phy_id);\n\t\tsas_port_add_phy(port, mpt3sas_phy->phy);\n\t\tmpt3sas_phy->phy_belongs_to_port = 1;\n\t\tmpt3sas_phy->port = hba_port;\n\t}\n\n\tmpt3sas_port->port = port;\n\tif (mpt3sas_port->remote_identify.device_type == SAS_END_DEVICE) {\n\t\trphy = sas_end_device_alloc(port);\n\t\tsas_device->rphy = rphy;\n\t\tif (sas_node->handle <= ioc->sas_hba.num_phys) {\n\t\t\tif (!vphy)\n\t\t\t\thba_port->sas_address =\n\t\t\t\t    sas_device->sas_address;\n\t\t\telse\n\t\t\t\tvphy->sas_address =\n\t\t\t\t    sas_device->sas_address;\n\t\t}\n\t} else {\n\t\trphy = sas_expander_alloc(port,\n\t\t    mpt3sas_port->remote_identify.device_type);\n\t\tif (sas_node->handle <= ioc->sas_hba.num_phys)\n\t\t\thba_port->sas_address =\n\t\t\t    mpt3sas_port->remote_identify.sas_address;\n\t}\n\n\tif (!rphy) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out_delete_port;\n\t}\n\n\trphy->identify = mpt3sas_port->remote_identify;\n\n\tif ((sas_rphy_add(rphy))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tsas_rphy_free(rphy);\n\t\trphy = NULL;\n\t\tgoto out_delete_port;\n\t}\n\n\tif (mpt3sas_port->remote_identify.device_type == SAS_END_DEVICE) {\n\t\tsas_device->pend_sas_rphy_add = 0;\n\t\tsas_device_put(sas_device);\n\t}\n\n\tdev_info(&rphy->dev,\n\t    \"add: handle(0x%04x), sas_addr(0x%016llx)\\n\", handle,\n\t    (unsigned long long)mpt3sas_port->remote_identify.sas_address);\n\n\tmpt3sas_port->rphy = rphy;\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tlist_add_tail(&mpt3sas_port->port_list, &sas_node->sas_port_list);\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\n\t \n\tif (mpt3sas_port->remote_identify.device_type ==\n\t    MPI2_SAS_DEVICE_INFO_EDGE_EXPANDER ||\n\t    mpt3sas_port->remote_identify.device_type ==\n\t    MPI2_SAS_DEVICE_INFO_FANOUT_EXPANDER)\n\t\t_transport_expander_report_manufacture(ioc,\n\t\t    mpt3sas_port->remote_identify.sas_address,\n\t\t    rphy_to_expander_device(rphy), hba_port->port_id);\n\treturn mpt3sas_port;\n\nout_delete_port:\n\tsas_port_delete(port);\n\nout_fail:\n\tlist_for_each_entry_safe(mpt3sas_phy, next, &mpt3sas_port->phy_list,\n\t    port_siblings)\n\t\tlist_del(&mpt3sas_phy->port_siblings);\n\tkfree(mpt3sas_port);\n\treturn NULL;\n}\n\n \nvoid\nmpt3sas_transport_port_remove(struct MPT3SAS_ADAPTER *ioc, u64 sas_address,\n\tu64 sas_address_parent, struct hba_port *port)\n{\n\tint i;\n\tunsigned long flags;\n\tstruct _sas_port *mpt3sas_port, *next;\n\tstruct _sas_node *sas_node;\n\tu8 found = 0;\n\tstruct _sas_phy *mpt3sas_phy, *next_phy;\n\tstruct hba_port *hba_port_next, *hba_port = NULL;\n\tstruct virtual_phy *vphy, *vphy_next = NULL;\n\n\tif (!port)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tsas_node = _transport_sas_node_find_by_sas_address(ioc,\n\t    sas_address_parent, port);\n\tif (!sas_node) {\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t\treturn;\n\t}\n\tlist_for_each_entry_safe(mpt3sas_port, next, &sas_node->sas_port_list,\n\t    port_list) {\n\t\tif (mpt3sas_port->remote_identify.sas_address != sas_address)\n\t\t\tcontinue;\n\t\tif (mpt3sas_port->hba_port != port)\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tlist_del(&mpt3sas_port->port_list);\n\t\tgoto out;\n\t}\n out:\n\tif (!found) {\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t\treturn;\n\t}\n\n\tif (sas_node->handle <= ioc->sas_hba.num_phys &&\n\t    (ioc->multipath_on_hba)) {\n\t\tif (port->vphys_mask) {\n\t\t\tlist_for_each_entry_safe(vphy, vphy_next,\n\t\t\t    &port->vphys_list, list) {\n\t\t\t\tif (vphy->sas_address != sas_address)\n\t\t\t\t\tcontinue;\n\t\t\t\tioc_info(ioc,\n\t\t\t\t    \"remove vphy entry: %p of port:%p,from %d port's vphys list\\n\",\n\t\t\t\t    vphy, port, port->port_id);\n\t\t\t\tport->vphys_mask &= ~vphy->phy_mask;\n\t\t\t\tlist_del(&vphy->list);\n\t\t\t\tkfree(vphy);\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry_safe(hba_port, hba_port_next,\n\t\t    &ioc->port_table_list, list) {\n\t\t\tif (hba_port != port)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif ((hba_port->sas_address == sas_address ||\n\t\t\t    !hba_port->sas_address) && !hba_port->vphys_mask) {\n\t\t\t\tioc_info(ioc,\n\t\t\t\t    \"remove hba_port entry: %p port: %d from hba_port list\\n\",\n\t\t\t\t    hba_port, hba_port->port_id);\n\t\t\t\tlist_del(&hba_port->list);\n\t\t\t\tkfree(hba_port);\n\t\t\t} else if (hba_port->sas_address == sas_address &&\n\t\t\t    hba_port->vphys_mask) {\n\t\t\t\t \n\t\t\t\tioc_info(ioc,\n\t\t\t\t    \"clearing sas_address from hba_port entry: %p port: %d from hba_port list\\n\",\n\t\t\t\t    hba_port, hba_port->port_id);\n\t\t\t\tport->sas_address = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < sas_node->num_phys; i++) {\n\t\tif (sas_node->phy[i].remote_identify.sas_address == sas_address)\n\t\t\tmemset(&sas_node->phy[i].remote_identify, 0 ,\n\t\t\t    sizeof(struct sas_identify));\n\t}\n\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\n\tlist_for_each_entry_safe(mpt3sas_phy, next_phy,\n\t    &mpt3sas_port->phy_list, port_siblings) {\n\t\tif ((ioc->logging_level & MPT_DEBUG_TRANSPORT))\n\t\t\tdev_printk(KERN_INFO, &mpt3sas_port->port->dev,\n\t\t\t    \"remove: sas_addr(0x%016llx), phy(%d)\\n\",\n\t\t\t    (unsigned long long)\n\t\t\t    mpt3sas_port->remote_identify.sas_address,\n\t\t\t    mpt3sas_phy->phy_id);\n\t\tmpt3sas_phy->phy_belongs_to_port = 0;\n\t\tif (!ioc->remove_host)\n\t\t\tsas_port_delete_phy(mpt3sas_port->port,\n\t\t\t\t\t\tmpt3sas_phy->phy);\n\t\tlist_del(&mpt3sas_phy->port_siblings);\n\t}\n\tif (!ioc->remove_host)\n\t\tsas_port_delete(mpt3sas_port->port);\n\tioc_info(ioc, \"%s: removed: sas_addr(0x%016llx)\\n\",\n\t    __func__, (unsigned long long)sas_address);\n\tkfree(mpt3sas_port);\n}\n\n \nint\nmpt3sas_transport_add_host_phy(struct MPT3SAS_ADAPTER *ioc, struct _sas_phy\n\t*mpt3sas_phy, Mpi2SasPhyPage0_t phy_pg0, struct device *parent_dev)\n{\n\tstruct sas_phy *phy;\n\tint phy_index = mpt3sas_phy->phy_id;\n\n\n\tINIT_LIST_HEAD(&mpt3sas_phy->port_siblings);\n\tphy = sas_phy_alloc(parent_dev, phy_index);\n\tif (!phy) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\tif ((_transport_set_identify(ioc, mpt3sas_phy->handle,\n\t    &mpt3sas_phy->identify))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tsas_phy_free(phy);\n\t\treturn -1;\n\t}\n\tphy->identify = mpt3sas_phy->identify;\n\tmpt3sas_phy->attached_handle = le16_to_cpu(phy_pg0.AttachedDevHandle);\n\tif (mpt3sas_phy->attached_handle)\n\t\t_transport_set_identify(ioc, mpt3sas_phy->attached_handle,\n\t\t    &mpt3sas_phy->remote_identify);\n\tphy->identify.phy_identifier = mpt3sas_phy->phy_id;\n\tphy->negotiated_linkrate = _transport_convert_phy_link_rate(\n\t    phy_pg0.NegotiatedLinkRate & MPI2_SAS_NEG_LINK_RATE_MASK_PHYSICAL);\n\tphy->minimum_linkrate_hw = _transport_convert_phy_link_rate(\n\t    phy_pg0.HwLinkRate & MPI2_SAS_HWRATE_MIN_RATE_MASK);\n\tphy->maximum_linkrate_hw = _transport_convert_phy_link_rate(\n\t    phy_pg0.HwLinkRate >> 4);\n\tphy->minimum_linkrate = _transport_convert_phy_link_rate(\n\t    phy_pg0.ProgrammedLinkRate & MPI2_SAS_PRATE_MIN_RATE_MASK);\n\tphy->maximum_linkrate = _transport_convert_phy_link_rate(\n\t    phy_pg0.ProgrammedLinkRate >> 4);\n\tphy->hostdata = mpt3sas_phy->port;\n\n\tif ((sas_phy_add(phy))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tsas_phy_free(phy);\n\t\treturn -1;\n\t}\n\tif ((ioc->logging_level & MPT_DEBUG_TRANSPORT))\n\t\tdev_printk(KERN_INFO, &phy->dev,\n\t\t    \"add: handle(0x%04x), sas_addr(0x%016llx)\\n\"\n\t\t    \"\\tattached_handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t    mpt3sas_phy->handle, (unsigned long long)\n\t\t    mpt3sas_phy->identify.sas_address,\n\t\t    mpt3sas_phy->attached_handle,\n\t\t    (unsigned long long)\n\t\t    mpt3sas_phy->remote_identify.sas_address);\n\tmpt3sas_phy->phy = phy;\n\treturn 0;\n}\n\n\n \nint\nmpt3sas_transport_add_expander_phy(struct MPT3SAS_ADAPTER *ioc, struct _sas_phy\n\t*mpt3sas_phy, Mpi2ExpanderPage1_t expander_pg1,\n\tstruct device *parent_dev)\n{\n\tstruct sas_phy *phy;\n\tint phy_index = mpt3sas_phy->phy_id;\n\n\tINIT_LIST_HEAD(&mpt3sas_phy->port_siblings);\n\tphy = sas_phy_alloc(parent_dev, phy_index);\n\tif (!phy) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\tif ((_transport_set_identify(ioc, mpt3sas_phy->handle,\n\t    &mpt3sas_phy->identify))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tsas_phy_free(phy);\n\t\treturn -1;\n\t}\n\tphy->identify = mpt3sas_phy->identify;\n\tmpt3sas_phy->attached_handle =\n\t    le16_to_cpu(expander_pg1.AttachedDevHandle);\n\tif (mpt3sas_phy->attached_handle)\n\t\t_transport_set_identify(ioc, mpt3sas_phy->attached_handle,\n\t\t    &mpt3sas_phy->remote_identify);\n\tphy->identify.phy_identifier = mpt3sas_phy->phy_id;\n\tphy->negotiated_linkrate = _transport_convert_phy_link_rate(\n\t    expander_pg1.NegotiatedLinkRate &\n\t    MPI2_SAS_NEG_LINK_RATE_MASK_PHYSICAL);\n\tphy->minimum_linkrate_hw = _transport_convert_phy_link_rate(\n\t    expander_pg1.HwLinkRate & MPI2_SAS_HWRATE_MIN_RATE_MASK);\n\tphy->maximum_linkrate_hw = _transport_convert_phy_link_rate(\n\t    expander_pg1.HwLinkRate >> 4);\n\tphy->minimum_linkrate = _transport_convert_phy_link_rate(\n\t    expander_pg1.ProgrammedLinkRate & MPI2_SAS_PRATE_MIN_RATE_MASK);\n\tphy->maximum_linkrate = _transport_convert_phy_link_rate(\n\t    expander_pg1.ProgrammedLinkRate >> 4);\n\tphy->hostdata = mpt3sas_phy->port;\n\n\tif ((sas_phy_add(phy))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tsas_phy_free(phy);\n\t\treturn -1;\n\t}\n\tif ((ioc->logging_level & MPT_DEBUG_TRANSPORT))\n\t\tdev_printk(KERN_INFO, &phy->dev,\n\t\t    \"add: handle(0x%04x), sas_addr(0x%016llx)\\n\"\n\t\t    \"\\tattached_handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t    mpt3sas_phy->handle, (unsigned long long)\n\t\t    mpt3sas_phy->identify.sas_address,\n\t\t    mpt3sas_phy->attached_handle,\n\t\t    (unsigned long long)\n\t\t    mpt3sas_phy->remote_identify.sas_address);\n\tmpt3sas_phy->phy = phy;\n\treturn 0;\n}\n\n \nvoid\nmpt3sas_transport_update_links(struct MPT3SAS_ADAPTER *ioc,\n\tu64 sas_address, u16 handle, u8 phy_number, u8 link_rate,\n\tstruct hba_port *port)\n{\n\tunsigned long flags;\n\tstruct _sas_node *sas_node;\n\tstruct _sas_phy *mpt3sas_phy;\n\tstruct hba_port *hba_port = NULL;\n\n\tif (ioc->shost_recovery || ioc->pci_error_recovery)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tsas_node = _transport_sas_node_find_by_sas_address(ioc,\n\t    sas_address, port);\n\tif (!sas_node) {\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t\treturn;\n\t}\n\n\tmpt3sas_phy = &sas_node->phy[phy_number];\n\tmpt3sas_phy->attached_handle = handle;\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\tif (handle && (link_rate >= MPI2_SAS_NEG_LINK_RATE_1_5)) {\n\t\t_transport_set_identify(ioc, handle,\n\t\t    &mpt3sas_phy->remote_identify);\n\t\tif ((sas_node->handle <= ioc->sas_hba.num_phys) &&\n\t\t    (ioc->multipath_on_hba)) {\n\t\t\tlist_for_each_entry(hba_port,\n\t\t\t    &ioc->port_table_list, list) {\n\t\t\t\tif (hba_port->sas_address == sas_address &&\n\t\t\t\t    hba_port == port)\n\t\t\t\t\thba_port->phy_mask |=\n\t\t\t\t\t    (1 << mpt3sas_phy->phy_id);\n\t\t\t}\n\t\t}\n\t\tmpt3sas_transport_add_phy_to_an_existing_port(ioc, sas_node,\n\t\t    mpt3sas_phy, mpt3sas_phy->remote_identify.sas_address,\n\t\t    port);\n\t} else\n\t\tmemset(&mpt3sas_phy->remote_identify, 0 , sizeof(struct\n\t\t    sas_identify));\n\n\tif (mpt3sas_phy->phy)\n\t\tmpt3sas_phy->phy->negotiated_linkrate =\n\t\t    _transport_convert_phy_link_rate(link_rate);\n\n\tif ((ioc->logging_level & MPT_DEBUG_TRANSPORT))\n\t\tdev_printk(KERN_INFO, &mpt3sas_phy->phy->dev,\n\t\t    \"refresh: parent sas_addr(0x%016llx),\\n\"\n\t\t    \"\\tlink_rate(0x%02x), phy(%d)\\n\"\n\t\t    \"\\tattached_handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t    (unsigned long long)sas_address,\n\t\t    link_rate, phy_number, handle, (unsigned long long)\n\t\t    mpt3sas_phy->remote_identify.sas_address);\n}\n\nstatic inline void *\nphy_to_ioc(struct sas_phy *phy)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\treturn shost_priv(shost);\n}\n\nstatic inline void *\nrphy_to_ioc(struct sas_rphy *rphy)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(rphy->dev.parent->parent);\n\treturn shost_priv(shost);\n}\n\n \nstruct phy_error_log_request {\n\tu8 smp_frame_type;  \n\tu8 function;  \n\tu8 allocated_response_length;\n\tu8 request_length;  \n\tu8 reserved_1[5];\n\tu8 phy_identifier;\n\tu8 reserved_2[2];\n};\n\n \nstruct phy_error_log_reply {\n\tu8 smp_frame_type;  \n\tu8 function;  \n\tu8 function_result;\n\tu8 response_length;\n\t__be16 expander_change_count;\n\tu8 reserved_1[3];\n\tu8 phy_identifier;\n\tu8 reserved_2[2];\n\t__be32 invalid_dword;\n\t__be32 running_disparity_error;\n\t__be32 loss_of_dword_sync;\n\t__be32 phy_reset_problem;\n};\n\n \nstatic int\n_transport_get_expander_phy_error_log(struct MPT3SAS_ADAPTER *ioc,\n\tstruct sas_phy *phy)\n{\n\tMpi2SmpPassthroughRequest_t *mpi_request;\n\tMpi2SmpPassthroughReply_t *mpi_reply;\n\tstruct phy_error_log_request *phy_error_log_request;\n\tstruct phy_error_log_reply *phy_error_log_reply;\n\tint rc;\n\tu16 smid;\n\tvoid *psge;\n\tu8 issue_reset = 0;\n\tvoid *data_out = NULL;\n\tdma_addr_t data_out_dma;\n\tu32 sz;\n\n\tif (ioc->shost_recovery || ioc->pci_error_recovery) {\n\t\tioc_info(ioc, \"%s: host reset in progress!\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tmutex_lock(&ioc->transport_cmds.mutex);\n\n\tif (ioc->transport_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: transport_cmds in use\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\tioc->transport_cmds.status = MPT3_CMD_PENDING;\n\n\trc = mpt3sas_wait_for_ioc(ioc, IOC_OPERATIONAL_WAIT_COUNT);\n\tif (rc)\n\t\tgoto out;\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->transport_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->transport_cmds.smid = smid;\n\n\tsz = sizeof(struct phy_error_log_request) +\n\t    sizeof(struct phy_error_log_reply);\n\tdata_out = dma_alloc_coherent(&ioc->pdev->dev, sz, &data_out_dma,\n\t\t\tGFP_KERNEL);\n\tif (!data_out) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\", __FILE__,\n\t\t    __LINE__, __func__);\n\t\trc = -ENOMEM;\n\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\tgoto out;\n\t}\n\n\trc = -EINVAL;\n\tmemset(data_out, 0, sz);\n\tphy_error_log_request = data_out;\n\tphy_error_log_request->smp_frame_type = 0x40;\n\tphy_error_log_request->function = 0x11;\n\tphy_error_log_request->request_length = 2;\n\tphy_error_log_request->allocated_response_length = 0;\n\tphy_error_log_request->phy_identifier = phy->number;\n\n\tmemset(mpi_request, 0, sizeof(Mpi2SmpPassthroughRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_SMP_PASSTHROUGH;\n\tmpi_request->PhysicalPort = _transport_get_port_id_by_sas_phy(phy);\n\tmpi_request->VF_ID = 0;  \n\tmpi_request->VP_ID = 0;\n\tmpi_request->SASAddress = cpu_to_le64(phy->identify.sas_address);\n\tmpi_request->RequestDataLength =\n\t    cpu_to_le16(sizeof(struct phy_error_log_request));\n\tpsge = &mpi_request->SGL;\n\n\tioc->build_sg(ioc, psge, data_out_dma,\n\t\tsizeof(struct phy_error_log_request),\n\t    data_out_dma + sizeof(struct phy_error_log_request),\n\t    sizeof(struct phy_error_log_reply));\n\n\tdtransportprintk(ioc,\n\t\t\t ioc_info(ioc, \"phy_error_log - send to sas_addr(0x%016llx), phy(%d)\\n\",\n\t\t\t\t  (u64)phy->identify.sas_address,\n\t\t\t\t  phy->number));\n\tinit_completion(&ioc->transport_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);\n\n\tif (!(ioc->transport_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tioc_err(ioc, \"%s: timeout\\n\", __func__);\n\t\t_debug_dump_mf(mpi_request,\n\t\t    sizeof(Mpi2SmpPassthroughRequest_t)/4);\n\t\tif (!(ioc->transport_cmds.status & MPT3_CMD_RESET))\n\t\t\tissue_reset = 1;\n\t\tgoto issue_host_reset;\n\t}\n\n\tdtransportprintk(ioc, ioc_info(ioc, \"phy_error_log - complete\\n\"));\n\n\tif (ioc->transport_cmds.status & MPT3_CMD_REPLY_VALID) {\n\n\t\tmpi_reply = ioc->transport_cmds.reply;\n\n\t\tdtransportprintk(ioc,\n\t\t\t\t ioc_info(ioc, \"phy_error_log - reply data transfer size(%d)\\n\",\n\t\t\t\t\t  le16_to_cpu(mpi_reply->ResponseDataLength)));\n\n\t\tif (le16_to_cpu(mpi_reply->ResponseDataLength) !=\n\t\t    sizeof(struct phy_error_log_reply))\n\t\t\tgoto out;\n\n\t\tphy_error_log_reply = data_out +\n\t\t    sizeof(struct phy_error_log_request);\n\n\t\tdtransportprintk(ioc,\n\t\t\t\t ioc_info(ioc, \"phy_error_log - function_result(%d)\\n\",\n\t\t\t\t\t  phy_error_log_reply->function_result));\n\n\t\tphy->invalid_dword_count =\n\t\t    be32_to_cpu(phy_error_log_reply->invalid_dword);\n\t\tphy->running_disparity_error_count =\n\t\t    be32_to_cpu(phy_error_log_reply->running_disparity_error);\n\t\tphy->loss_of_dword_sync_count =\n\t\t    be32_to_cpu(phy_error_log_reply->loss_of_dword_sync);\n\t\tphy->phy_reset_problem_count =\n\t\t    be32_to_cpu(phy_error_log_reply->phy_reset_problem);\n\t\trc = 0;\n\t} else\n\t\tdtransportprintk(ioc,\n\t\t\t\t ioc_info(ioc, \"phy_error_log - no reply\\n\"));\n\n issue_host_reset:\n\tif (issue_reset)\n\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n out:\n\tioc->transport_cmds.status = MPT3_CMD_NOT_USED;\n\tif (data_out)\n\t\tdma_free_coherent(&ioc->pdev->dev, sz, data_out, data_out_dma);\n\n\tmutex_unlock(&ioc->transport_cmds.mutex);\n\treturn rc;\n}\n\n \nstatic int\n_transport_get_linkerrors(struct sas_phy *phy)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = phy_to_ioc(phy);\n\tunsigned long flags;\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasPhyPage1_t phy_pg1;\n\tstruct hba_port *port = phy->hostdata;\n\tint port_id = port->port_id;\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tif (_transport_sas_node_find_by_sas_address(ioc,\n\t    phy->identify.sas_address,\n\t    mpt3sas_get_port_by_id(ioc, port_id, 0)) == NULL) {\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\n\tif (phy->identify.sas_address != ioc->sas_hba.sas_address)\n\t\treturn _transport_get_expander_phy_error_log(ioc, phy);\n\n\t \n\tif ((mpt3sas_config_get_phy_pg1(ioc, &mpi_reply, &phy_pg1,\n\t\t    phy->number))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tif (mpi_reply.IOCStatus || mpi_reply.IOCLogInfo)\n\t\tioc_info(ioc, \"phy(%d), ioc_status (0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t phy->number,\n\t\t\t le16_to_cpu(mpi_reply.IOCStatus),\n\t\t\t le32_to_cpu(mpi_reply.IOCLogInfo));\n\n\tphy->invalid_dword_count = le32_to_cpu(phy_pg1.InvalidDwordCount);\n\tphy->running_disparity_error_count =\n\t    le32_to_cpu(phy_pg1.RunningDisparityErrorCount);\n\tphy->loss_of_dword_sync_count =\n\t    le32_to_cpu(phy_pg1.LossDwordSynchCount);\n\tphy->phy_reset_problem_count =\n\t    le32_to_cpu(phy_pg1.PhyResetProblemCount);\n\treturn 0;\n}\n\n \nstatic int\n_transport_get_enclosure_identifier(struct sas_rphy *rphy, u64 *identifier)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = rphy_to_ioc(rphy);\n\tstruct _sas_device *sas_device;\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_rphy(ioc, rphy);\n\tif (sas_device) {\n\t\t*identifier = sas_device->enclosure_logical_id;\n\t\trc = 0;\n\t\tsas_device_put(sas_device);\n\t} else {\n\t\t*identifier = 0;\n\t\trc = -ENXIO;\n\t}\n\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\treturn rc;\n}\n\n \nstatic int\n_transport_get_bay_identifier(struct sas_rphy *rphy)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = rphy_to_ioc(rphy);\n\tstruct _sas_device *sas_device;\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_rphy(ioc, rphy);\n\tif (sas_device) {\n\t\trc = sas_device->slot;\n\t\tsas_device_put(sas_device);\n\t} else {\n\t\trc = -ENXIO;\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\treturn rc;\n}\n\n \nstruct phy_control_request {\n\tu8 smp_frame_type;  \n\tu8 function;  \n\tu8 allocated_response_length;\n\tu8 request_length;  \n\tu16 expander_change_count;\n\tu8 reserved_1[3];\n\tu8 phy_identifier;\n\tu8 phy_operation;\n\tu8 reserved_2[13];\n\tu64 attached_device_name;\n\tu8 programmed_min_physical_link_rate;\n\tu8 programmed_max_physical_link_rate;\n\tu8 reserved_3[6];\n};\n\n \nstruct phy_control_reply {\n\tu8 smp_frame_type;  \n\tu8 function;  \n\tu8 function_result;\n\tu8 response_length;\n};\n\n#define SMP_PHY_CONTROL_LINK_RESET\t(0x01)\n#define SMP_PHY_CONTROL_HARD_RESET\t(0x02)\n#define SMP_PHY_CONTROL_DISABLE\t\t(0x03)\n\n \nstatic int\n_transport_expander_phy_control(struct MPT3SAS_ADAPTER *ioc,\n\tstruct sas_phy *phy, u8 phy_operation)\n{\n\tMpi2SmpPassthroughRequest_t *mpi_request;\n\tMpi2SmpPassthroughReply_t *mpi_reply;\n\tstruct phy_control_request *phy_control_request;\n\tstruct phy_control_reply *phy_control_reply;\n\tint rc;\n\tu16 smid;\n\tvoid *psge;\n\tu8 issue_reset = 0;\n\tvoid *data_out = NULL;\n\tdma_addr_t data_out_dma;\n\tu32 sz;\n\n\tif (ioc->shost_recovery || ioc->pci_error_recovery) {\n\t\tioc_info(ioc, \"%s: host reset in progress!\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tmutex_lock(&ioc->transport_cmds.mutex);\n\n\tif (ioc->transport_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: transport_cmds in use\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\tioc->transport_cmds.status = MPT3_CMD_PENDING;\n\n\trc = mpt3sas_wait_for_ioc(ioc, IOC_OPERATIONAL_WAIT_COUNT);\n\tif (rc)\n\t\tgoto out;\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->transport_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->transport_cmds.smid = smid;\n\n\tsz = sizeof(struct phy_control_request) +\n\t    sizeof(struct phy_control_reply);\n\tdata_out = dma_alloc_coherent(&ioc->pdev->dev, sz, &data_out_dma,\n\t\t\tGFP_KERNEL);\n\tif (!data_out) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\", __FILE__,\n\t\t    __LINE__, __func__);\n\t\trc = -ENOMEM;\n\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\tgoto out;\n\t}\n\n\trc = -EINVAL;\n\tmemset(data_out, 0, sz);\n\tphy_control_request = data_out;\n\tphy_control_request->smp_frame_type = 0x40;\n\tphy_control_request->function = 0x91;\n\tphy_control_request->request_length = 9;\n\tphy_control_request->allocated_response_length = 0;\n\tphy_control_request->phy_identifier = phy->number;\n\tphy_control_request->phy_operation = phy_operation;\n\tphy_control_request->programmed_min_physical_link_rate =\n\t    phy->minimum_linkrate << 4;\n\tphy_control_request->programmed_max_physical_link_rate =\n\t    phy->maximum_linkrate << 4;\n\n\tmemset(mpi_request, 0, sizeof(Mpi2SmpPassthroughRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_SMP_PASSTHROUGH;\n\tmpi_request->PhysicalPort = _transport_get_port_id_by_sas_phy(phy);\n\tmpi_request->VF_ID = 0;  \n\tmpi_request->VP_ID = 0;\n\tmpi_request->SASAddress = cpu_to_le64(phy->identify.sas_address);\n\tmpi_request->RequestDataLength =\n\t    cpu_to_le16(sizeof(struct phy_error_log_request));\n\tpsge = &mpi_request->SGL;\n\n\tioc->build_sg(ioc, psge, data_out_dma,\n\t\t\t    sizeof(struct phy_control_request),\n\t    data_out_dma + sizeof(struct phy_control_request),\n\t    sizeof(struct phy_control_reply));\n\n\tdtransportprintk(ioc,\n\t\t\t ioc_info(ioc, \"phy_control - send to sas_addr(0x%016llx), phy(%d), opcode(%d)\\n\",\n\t\t\t\t  (u64)phy->identify.sas_address,\n\t\t\t\t  phy->number, phy_operation));\n\tinit_completion(&ioc->transport_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);\n\n\tif (!(ioc->transport_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tioc_err(ioc, \"%s: timeout\\n\", __func__);\n\t\t_debug_dump_mf(mpi_request,\n\t\t    sizeof(Mpi2SmpPassthroughRequest_t)/4);\n\t\tif (!(ioc->transport_cmds.status & MPT3_CMD_RESET))\n\t\t\tissue_reset = 1;\n\t\tgoto issue_host_reset;\n\t}\n\n\tdtransportprintk(ioc, ioc_info(ioc, \"phy_control - complete\\n\"));\n\n\tif (ioc->transport_cmds.status & MPT3_CMD_REPLY_VALID) {\n\n\t\tmpi_reply = ioc->transport_cmds.reply;\n\n\t\tdtransportprintk(ioc,\n\t\t\t\t ioc_info(ioc, \"phy_control - reply data transfer size(%d)\\n\",\n\t\t\t\t\t  le16_to_cpu(mpi_reply->ResponseDataLength)));\n\n\t\tif (le16_to_cpu(mpi_reply->ResponseDataLength) !=\n\t\t    sizeof(struct phy_control_reply))\n\t\t\tgoto out;\n\n\t\tphy_control_reply = data_out +\n\t\t    sizeof(struct phy_control_request);\n\n\t\tdtransportprintk(ioc,\n\t\t\t\t ioc_info(ioc, \"phy_control - function_result(%d)\\n\",\n\t\t\t\t\t  phy_control_reply->function_result));\n\n\t\trc = 0;\n\t} else\n\t\tdtransportprintk(ioc,\n\t\t\t\t ioc_info(ioc, \"phy_control - no reply\\n\"));\n\n issue_host_reset:\n\tif (issue_reset)\n\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n out:\n\tioc->transport_cmds.status = MPT3_CMD_NOT_USED;\n\tif (data_out)\n\t\tdma_free_coherent(&ioc->pdev->dev, sz, data_out,\n\t\t\t\tdata_out_dma);\n\n\tmutex_unlock(&ioc->transport_cmds.mutex);\n\treturn rc;\n}\n\n \nstatic int\n_transport_phy_reset(struct sas_phy *phy, int hard_reset)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = phy_to_ioc(phy);\n\tMpi2SasIoUnitControlReply_t mpi_reply;\n\tMpi2SasIoUnitControlRequest_t mpi_request;\n\tstruct hba_port *port = phy->hostdata;\n\tint port_id = port->port_id;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tif (_transport_sas_node_find_by_sas_address(ioc,\n\t    phy->identify.sas_address,\n\t    mpt3sas_get_port_by_id(ioc, port_id, 0)) == NULL) {\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\n\t \n\tif (phy->identify.sas_address != ioc->sas_hba.sas_address)\n\t\treturn _transport_expander_phy_control(ioc, phy,\n\t\t    (hard_reset == 1) ? SMP_PHY_CONTROL_HARD_RESET :\n\t\t    SMP_PHY_CONTROL_LINK_RESET);\n\n\t \n\tmemset(&mpi_request, 0, sizeof(Mpi2SasIoUnitControlRequest_t));\n\tmpi_request.Function = MPI2_FUNCTION_SAS_IO_UNIT_CONTROL;\n\tmpi_request.Operation = hard_reset ?\n\t    MPI2_SAS_OP_PHY_HARD_RESET : MPI2_SAS_OP_PHY_LINK_RESET;\n\tmpi_request.PhyNum = phy->number;\n\n\tif ((mpt3sas_base_sas_iounit_control(ioc, &mpi_reply, &mpi_request))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tif (mpi_reply.IOCStatus || mpi_reply.IOCLogInfo)\n\t\tioc_info(ioc, \"phy(%d), ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t phy->number, le16_to_cpu(mpi_reply.IOCStatus),\n\t\t\t le32_to_cpu(mpi_reply.IOCLogInfo));\n\n\treturn 0;\n}\n\n \nstatic int\n_transport_phy_enable(struct sas_phy *phy, int enable)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = phy_to_ioc(phy);\n\tMpi2SasIOUnitPage1_t *sas_iounit_pg1 = NULL;\n\tMpi2SasIOUnitPage0_t *sas_iounit_pg0 = NULL;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 ioc_status;\n\tu16 sz;\n\tint rc = 0;\n\tunsigned long flags;\n\tint i, discovery_active;\n\tstruct hba_port *port = phy->hostdata;\n\tint port_id = port->port_id;\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tif (_transport_sas_node_find_by_sas_address(ioc,\n\t    phy->identify.sas_address,\n\t    mpt3sas_get_port_by_id(ioc, port_id, 0)) == NULL) {\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\n\t \n\tif (phy->identify.sas_address != ioc->sas_hba.sas_address)\n\t\treturn _transport_expander_phy_control(ioc, phy,\n\t\t    (enable == 1) ? SMP_PHY_CONTROL_LINK_RESET :\n\t\t    SMP_PHY_CONTROL_DISABLE);\n\n\t \n\n\t \n\tsz = offsetof(Mpi2SasIOUnitPage0_t, PhyData) + (ioc->sas_hba.num_phys *\n\t    sizeof(Mpi2SasIOUnit0PhyData_t));\n\tsas_iounit_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_iounit_pg0) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif ((mpt3sas_config_get_sas_iounit_pg0(ioc, &mpi_reply,\n\t    sas_iounit_pg0, sz))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trc = -ENXIO;\n\t\tgoto out;\n\t}\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0, discovery_active = 0; i < ioc->sas_hba.num_phys ; i++) {\n\t\tif (sas_iounit_pg0->PhyData[i].PortFlags &\n\t\t    MPI2_SASIOUNIT0_PORTFLAGS_DISCOVERY_IN_PROGRESS) {\n\t\t\tioc_err(ioc, \"discovery is active on port = %d, phy = %d: unable to enable/disable phys, try again later!\\n\",\n\t\t\t\tsas_iounit_pg0->PhyData[i].Port, i);\n\t\t\tdiscovery_active = 1;\n\t\t}\n\t}\n\n\tif (discovery_active) {\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\t \n\tsz = offsetof(Mpi2SasIOUnitPage1_t, PhyData) + (ioc->sas_hba.num_phys *\n\t    sizeof(Mpi2SasIOUnit1PhyData_t));\n\tsas_iounit_pg1 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_iounit_pg1) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif ((mpt3sas_config_get_sas_iounit_pg1(ioc, &mpi_reply,\n\t    sas_iounit_pg1, sz))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trc = -ENXIO;\n\t\tgoto out;\n\t}\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < ioc->sas_hba.num_phys ; i++) {\n\t\tsas_iounit_pg1->PhyData[i].Port =\n\t\t    sas_iounit_pg0->PhyData[i].Port;\n\t\tsas_iounit_pg1->PhyData[i].PortFlags =\n\t\t    (sas_iounit_pg0->PhyData[i].PortFlags &\n\t\t    MPI2_SASIOUNIT0_PORTFLAGS_AUTO_PORT_CONFIG);\n\t\tsas_iounit_pg1->PhyData[i].PhyFlags =\n\t\t    (sas_iounit_pg0->PhyData[i].PhyFlags &\n\t\t    (MPI2_SASIOUNIT0_PHYFLAGS_ZONING_ENABLED +\n\t\t    MPI2_SASIOUNIT0_PHYFLAGS_PHY_DISABLED));\n\t}\n\n\tif (enable)\n\t\tsas_iounit_pg1->PhyData[phy->number].PhyFlags\n\t\t    &= ~MPI2_SASIOUNIT1_PHYFLAGS_PHY_DISABLE;\n\telse\n\t\tsas_iounit_pg1->PhyData[phy->number].PhyFlags\n\t\t    |= MPI2_SASIOUNIT1_PHYFLAGS_PHY_DISABLE;\n\n\tmpt3sas_config_set_sas_iounit_pg1(ioc, &mpi_reply, sas_iounit_pg1, sz);\n\n\t \n\tif (enable)\n\t\t_transport_phy_reset(phy, 0);\n\n out:\n\tkfree(sas_iounit_pg1);\n\tkfree(sas_iounit_pg0);\n\treturn rc;\n}\n\n \nstatic int\n_transport_phy_speed(struct sas_phy *phy, struct sas_phy_linkrates *rates)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = phy_to_ioc(phy);\n\tMpi2SasIOUnitPage1_t *sas_iounit_pg1 = NULL;\n\tMpi2SasPhyPage0_t phy_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 ioc_status;\n\tu16 sz;\n\tint i;\n\tint rc = 0;\n\tunsigned long flags;\n\tstruct hba_port *port = phy->hostdata;\n\tint port_id = port->port_id;\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tif (_transport_sas_node_find_by_sas_address(ioc,\n\t    phy->identify.sas_address,\n\t    mpt3sas_get_port_by_id(ioc, port_id, 0)) == NULL) {\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\n\tif (!rates->minimum_linkrate)\n\t\trates->minimum_linkrate = phy->minimum_linkrate;\n\telse if (rates->minimum_linkrate < phy->minimum_linkrate_hw)\n\t\trates->minimum_linkrate = phy->minimum_linkrate_hw;\n\n\tif (!rates->maximum_linkrate)\n\t\trates->maximum_linkrate = phy->maximum_linkrate;\n\telse if (rates->maximum_linkrate > phy->maximum_linkrate_hw)\n\t\trates->maximum_linkrate = phy->maximum_linkrate_hw;\n\n\t \n\tif (phy->identify.sas_address != ioc->sas_hba.sas_address) {\n\t\tphy->minimum_linkrate = rates->minimum_linkrate;\n\t\tphy->maximum_linkrate = rates->maximum_linkrate;\n\t\treturn _transport_expander_phy_control(ioc, phy,\n\t\t    SMP_PHY_CONTROL_LINK_RESET);\n\t}\n\n\t \n\n\t \n\tsz = offsetof(Mpi2SasIOUnitPage1_t, PhyData) + (ioc->sas_hba.num_phys *\n\t    sizeof(Mpi2SasIOUnit1PhyData_t));\n\tsas_iounit_pg1 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_iounit_pg1) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif ((mpt3sas_config_get_sas_iounit_pg1(ioc, &mpi_reply,\n\t    sas_iounit_pg1, sz))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trc = -ENXIO;\n\t\tgoto out;\n\t}\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ioc->sas_hba.num_phys; i++) {\n\t\tif (phy->number != i) {\n\t\t\tsas_iounit_pg1->PhyData[i].MaxMinLinkRate =\n\t\t\t    (ioc->sas_hba.phy[i].phy->minimum_linkrate +\n\t\t\t    (ioc->sas_hba.phy[i].phy->maximum_linkrate << 4));\n\t\t} else {\n\t\t\tsas_iounit_pg1->PhyData[i].MaxMinLinkRate =\n\t\t\t    (rates->minimum_linkrate +\n\t\t\t    (rates->maximum_linkrate << 4));\n\t\t}\n\t}\n\n\tif (mpt3sas_config_set_sas_iounit_pg1(ioc, &mpi_reply, sas_iounit_pg1,\n\t    sz)) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trc = -ENXIO;\n\t\tgoto out;\n\t}\n\n\t \n\t_transport_phy_reset(phy, 0);\n\n\t \n\tif (!mpt3sas_config_get_phy_pg0(ioc, &mpi_reply, &phy_pg0,\n\t    phy->number)) {\n\t\tphy->minimum_linkrate = _transport_convert_phy_link_rate(\n\t\t    phy_pg0.ProgrammedLinkRate & MPI2_SAS_PRATE_MIN_RATE_MASK);\n\t\tphy->maximum_linkrate = _transport_convert_phy_link_rate(\n\t\t    phy_pg0.ProgrammedLinkRate >> 4);\n\t\tphy->negotiated_linkrate = _transport_convert_phy_link_rate(\n\t\t    phy_pg0.NegotiatedLinkRate &\n\t\t    MPI2_SAS_NEG_LINK_RATE_MASK_PHYSICAL);\n\t}\n\n out:\n\tkfree(sas_iounit_pg1);\n\treturn rc;\n}\n\nstatic int\n_transport_map_smp_buffer(struct device *dev, struct bsg_buffer *buf,\n\t\tdma_addr_t *dma_addr, size_t *dma_len, void **p)\n{\n\t \n\tif (buf->sg_cnt > 1) {\n\t\t*p = dma_alloc_coherent(dev, buf->payload_len, dma_addr,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!*p)\n\t\t\treturn -ENOMEM;\n\t\t*dma_len = buf->payload_len;\n\t} else {\n\t\tif (!dma_map_sg(dev, buf->sg_list, 1, DMA_BIDIRECTIONAL))\n\t\t\treturn -ENOMEM;\n\t\t*dma_addr = sg_dma_address(buf->sg_list);\n\t\t*dma_len = sg_dma_len(buf->sg_list);\n\t\t*p = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic void\n_transport_unmap_smp_buffer(struct device *dev, struct bsg_buffer *buf,\n\t\tdma_addr_t dma_addr, void *p)\n{\n\tif (p)\n\t\tdma_free_coherent(dev, buf->payload_len, p, dma_addr);\n\telse\n\t\tdma_unmap_sg(dev, buf->sg_list, 1, DMA_BIDIRECTIONAL);\n}\n\n \nstatic void\n_transport_smp_handler(struct bsg_job *job, struct Scsi_Host *shost,\n\t\tstruct sas_rphy *rphy)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tMpi2SmpPassthroughRequest_t *mpi_request;\n\tMpi2SmpPassthroughReply_t *mpi_reply;\n\tint rc;\n\tu16 smid;\n\tvoid *psge;\n\tdma_addr_t dma_addr_in;\n\tdma_addr_t dma_addr_out;\n\tvoid *addr_in = NULL;\n\tvoid *addr_out = NULL;\n\tsize_t dma_len_in;\n\tsize_t dma_len_out;\n\tunsigned int reslen = 0;\n\n\tif (ioc->shost_recovery || ioc->pci_error_recovery) {\n\t\tioc_info(ioc, \"%s: host reset in progress!\\n\", __func__);\n\t\trc = -EFAULT;\n\t\tgoto job_done;\n\t}\n\n\trc = mutex_lock_interruptible(&ioc->transport_cmds.mutex);\n\tif (rc)\n\t\tgoto job_done;\n\n\tif (ioc->transport_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: transport_cmds in use\\n\",\n\t\t\t__func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\tioc->transport_cmds.status = MPT3_CMD_PENDING;\n\n\trc = _transport_map_smp_buffer(&ioc->pdev->dev, &job->request_payload,\n\t\t\t&dma_addr_out, &dma_len_out, &addr_out);\n\tif (rc)\n\t\tgoto out;\n\tif (addr_out) {\n\t\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\t\t\tjob->request_payload.sg_cnt, addr_out,\n\t\t\t\tjob->request_payload.payload_len);\n\t}\n\n\trc = _transport_map_smp_buffer(&ioc->pdev->dev, &job->reply_payload,\n\t\t\t&dma_addr_in, &dma_len_in, &addr_in);\n\tif (rc)\n\t\tgoto unmap_out;\n\n\trc = mpt3sas_wait_for_ioc(ioc, IOC_OPERATIONAL_WAIT_COUNT);\n\tif (rc)\n\t\tgoto unmap_in;\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->transport_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto unmap_in;\n\t}\n\n\trc = 0;\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->transport_cmds.smid = smid;\n\n\tmemset(mpi_request, 0, sizeof(Mpi2SmpPassthroughRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_SMP_PASSTHROUGH;\n\tmpi_request->PhysicalPort = _transport_get_port_id_by_rphy(ioc, rphy);\n\tmpi_request->SASAddress = (rphy) ?\n\t    cpu_to_le64(rphy->identify.sas_address) :\n\t    cpu_to_le64(ioc->sas_hba.sas_address);\n\tmpi_request->RequestDataLength = cpu_to_le16(dma_len_out - 4);\n\tpsge = &mpi_request->SGL;\n\n\tioc->build_sg(ioc, psge, dma_addr_out, dma_len_out - 4, dma_addr_in,\n\t\t\tdma_len_in - 4);\n\n\tdtransportprintk(ioc,\n\t\t\t ioc_info(ioc, \"%s: sending smp request\\n\", __func__));\n\n\tinit_completion(&ioc->transport_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);\n\n\tif (!(ioc->transport_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tioc_err(ioc, \"%s: timeout\\n\", __func__);\n\t\t_debug_dump_mf(mpi_request,\n\t\t    sizeof(Mpi2SmpPassthroughRequest_t)/4);\n\t\tif (!(ioc->transport_cmds.status & MPT3_CMD_RESET)) {\n\t\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\t\t\trc = -ETIMEDOUT;\n\t\t\tgoto unmap_in;\n\t\t}\n\t}\n\n\tdtransportprintk(ioc, ioc_info(ioc, \"%s - complete\\n\", __func__));\n\n\tif (!(ioc->transport_cmds.status & MPT3_CMD_REPLY_VALID)) {\n\t\tdtransportprintk(ioc,\n\t\t\t\t ioc_info(ioc, \"%s: no reply\\n\", __func__));\n\t\trc = -ENXIO;\n\t\tgoto unmap_in;\n\t}\n\n\tmpi_reply = ioc->transport_cmds.reply;\n\n\tdtransportprintk(ioc,\n\t\t\t ioc_info(ioc, \"%s: reply data transfer size(%d)\\n\",\n\t\t\t\t  __func__,\n\t\t\t\t  le16_to_cpu(mpi_reply->ResponseDataLength)));\n\n\tmemcpy(job->reply, mpi_reply, sizeof(*mpi_reply));\n\tjob->reply_len = sizeof(*mpi_reply);\n\treslen = le16_to_cpu(mpi_reply->ResponseDataLength);\n\n\tif (addr_in) {\n\t\tsg_copy_to_buffer(job->reply_payload.sg_list,\n\t\t\t\tjob->reply_payload.sg_cnt, addr_in,\n\t\t\t\tjob->reply_payload.payload_len);\n\t}\n\n\trc = 0;\n unmap_in:\n\t_transport_unmap_smp_buffer(&ioc->pdev->dev, &job->reply_payload,\n\t\t\tdma_addr_in, addr_in);\n unmap_out:\n\t_transport_unmap_smp_buffer(&ioc->pdev->dev, &job->request_payload,\n\t\t\tdma_addr_out, addr_out);\n out:\n\tioc->transport_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_unlock(&ioc->transport_cmds.mutex);\njob_done:\n\tbsg_job_done(job, rc, reslen);\n}\n\nstruct sas_function_template mpt3sas_transport_functions = {\n\t.get_linkerrors\t\t= _transport_get_linkerrors,\n\t.get_enclosure_identifier = _transport_get_enclosure_identifier,\n\t.get_bay_identifier\t= _transport_get_bay_identifier,\n\t.phy_reset\t\t= _transport_phy_reset,\n\t.phy_enable\t\t= _transport_phy_enable,\n\t.set_phy_speed\t\t= _transport_phy_speed,\n\t.smp_handler\t\t= _transport_smp_handler,\n};\n\nstruct scsi_transport_template *mpt3sas_transport_template;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}