{
  "module_name": "mpt3sas_ctl.c",
  "hash_id": "d9aa784444a11eecd33f28811a2f47ac30587fe6d5da6d361eea434d2396ef62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mpt3sas/mpt3sas_ctl.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/compat.h>\n#include <linux/poll.h>\n\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n#include \"mpt3sas_base.h\"\n#include \"mpt3sas_ctl.h\"\n\n\nstatic struct fasync_struct *async_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(ctl_poll_wait);\n\n\n \nenum block_state {\n\tNON_BLOCKING,\n\tBLOCKING,\n};\n\n \nstatic void\n_ctl_display_some_debug(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tchar *calling_function_name, MPI2DefaultReply_t *mpi_reply)\n{\n\tMpi2ConfigRequest_t *mpi_request;\n\tchar *desc = NULL;\n\n\tif (!(ioc->logging_level & MPT_DEBUG_IOCTL))\n\t\treturn;\n\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tswitch (mpi_request->Function) {\n\tcase MPI2_FUNCTION_SCSI_IO_REQUEST:\n\t{\n\t\tMpi2SCSIIORequest_t *scsi_request =\n\t\t    (Mpi2SCSIIORequest_t *)mpi_request;\n\n\t\tsnprintf(ioc->tmp_string, MPT_STRING_LENGTH,\n\t\t    \"scsi_io, cmd(0x%02x), cdb_len(%d)\",\n\t\t    scsi_request->CDB.CDB32[0],\n\t\t    le16_to_cpu(scsi_request->IoFlags) & 0xF);\n\t\tdesc = ioc->tmp_string;\n\t\tbreak;\n\t}\n\tcase MPI2_FUNCTION_SCSI_TASK_MGMT:\n\t\tdesc = \"task_mgmt\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_IOC_INIT:\n\t\tdesc = \"ioc_init\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_IOC_FACTS:\n\t\tdesc = \"ioc_facts\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_CONFIG:\n\t{\n\t\tMpi2ConfigRequest_t *config_request =\n\t\t    (Mpi2ConfigRequest_t *)mpi_request;\n\n\t\tsnprintf(ioc->tmp_string, MPT_STRING_LENGTH,\n\t\t    \"config, type(0x%02x), ext_type(0x%02x), number(%d)\",\n\t\t    (config_request->Header.PageType &\n\t\t     MPI2_CONFIG_PAGETYPE_MASK), config_request->ExtPageType,\n\t\t    config_request->Header.PageNumber);\n\t\tdesc = ioc->tmp_string;\n\t\tbreak;\n\t}\n\tcase MPI2_FUNCTION_PORT_FACTS:\n\t\tdesc = \"port_facts\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_PORT_ENABLE:\n\t\tdesc = \"port_enable\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_EVENT_NOTIFICATION:\n\t\tdesc = \"event_notification\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_FW_DOWNLOAD:\n\t\tdesc = \"fw_download\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_FW_UPLOAD:\n\t\tdesc = \"fw_upload\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_RAID_ACTION:\n\t\tdesc = \"raid_action\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH:\n\t{\n\t\tMpi2SCSIIORequest_t *scsi_request =\n\t\t    (Mpi2SCSIIORequest_t *)mpi_request;\n\n\t\tsnprintf(ioc->tmp_string, MPT_STRING_LENGTH,\n\t\t    \"raid_pass, cmd(0x%02x), cdb_len(%d)\",\n\t\t    scsi_request->CDB.CDB32[0],\n\t\t    le16_to_cpu(scsi_request->IoFlags) & 0xF);\n\t\tdesc = ioc->tmp_string;\n\t\tbreak;\n\t}\n\tcase MPI2_FUNCTION_SAS_IO_UNIT_CONTROL:\n\t\tdesc = \"sas_iounit_cntl\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_SATA_PASSTHROUGH:\n\t\tdesc = \"sata_pass\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_DIAG_BUFFER_POST:\n\t\tdesc = \"diag_buffer_post\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_DIAG_RELEASE:\n\t\tdesc = \"diag_release\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_SMP_PASSTHROUGH:\n\t\tdesc = \"smp_passthrough\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_TOOLBOX:\n\t\tdesc = \"toolbox\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_NVME_ENCAPSULATED:\n\t\tdesc = \"nvme_encapsulated\";\n\t\tbreak;\n\t}\n\n\tif (!desc)\n\t\treturn;\n\n\tioc_info(ioc, \"%s: %s, smid(%d)\\n\", calling_function_name, desc, smid);\n\n\tif (!mpi_reply)\n\t\treturn;\n\n\tif (mpi_reply->IOCStatus || mpi_reply->IOCLogInfo)\n\t\tioc_info(ioc, \"\\tiocstatus(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t le16_to_cpu(mpi_reply->IOCStatus),\n\t\t\t le32_to_cpu(mpi_reply->IOCLogInfo));\n\n\tif (mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||\n\t    mpi_request->Function ==\n\t    MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH) {\n\t\tMpi2SCSIIOReply_t *scsi_reply =\n\t\t    (Mpi2SCSIIOReply_t *)mpi_reply;\n\t\tstruct _sas_device *sas_device = NULL;\n\t\tstruct _pcie_device *pcie_device = NULL;\n\n\t\tsas_device = mpt3sas_get_sdev_by_handle(ioc,\n\t\t    le16_to_cpu(scsi_reply->DevHandle));\n\t\tif (sas_device) {\n\t\t\tioc_warn(ioc, \"\\tsas_address(0x%016llx), phy(%d)\\n\",\n\t\t\t\t (u64)sas_device->sas_address,\n\t\t\t\t sas_device->phy);\n\t\t\tioc_warn(ioc, \"\\tenclosure_logical_id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t (u64)sas_device->enclosure_logical_id,\n\t\t\t\t sas_device->slot);\n\t\t\tsas_device_put(sas_device);\n\t\t}\n\t\tif (!sas_device) {\n\t\t\tpcie_device = mpt3sas_get_pdev_by_handle(ioc,\n\t\t\t\tle16_to_cpu(scsi_reply->DevHandle));\n\t\t\tif (pcie_device) {\n\t\t\t\tioc_warn(ioc, \"\\tWWID(0x%016llx), port(%d)\\n\",\n\t\t\t\t\t (unsigned long long)pcie_device->wwid,\n\t\t\t\t\t pcie_device->port_num);\n\t\t\t\tif (pcie_device->enclosure_handle != 0)\n\t\t\t\t\tioc_warn(ioc, \"\\tenclosure_logical_id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t\t\t (u64)pcie_device->enclosure_logical_id,\n\t\t\t\t\t\t pcie_device->slot);\n\t\t\t\tpcie_device_put(pcie_device);\n\t\t\t}\n\t\t}\n\t\tif (scsi_reply->SCSIState || scsi_reply->SCSIStatus)\n\t\t\tioc_info(ioc, \"\\tscsi_state(0x%02x), scsi_status(0x%02x)\\n\",\n\t\t\t\t scsi_reply->SCSIState,\n\t\t\t\t scsi_reply->SCSIStatus);\n\t}\n}\n\n \nu8\nmpt3sas_ctl_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\n\tu32 reply)\n{\n\tMPI2DefaultReply_t *mpi_reply;\n\tMpi2SCSIIOReply_t *scsiio_reply;\n\tMpi26NVMeEncapsulatedErrorReply_t *nvme_error_reply;\n\tconst void *sense_data;\n\tu32 sz;\n\n\tif (ioc->ctl_cmds.status == MPT3_CMD_NOT_USED)\n\t\treturn 1;\n\tif (ioc->ctl_cmds.smid != smid)\n\t\treturn 1;\n\tioc->ctl_cmds.status |= MPT3_CMD_COMPLETE;\n\tmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tif (mpi_reply) {\n\t\tmemcpy(ioc->ctl_cmds.reply, mpi_reply, mpi_reply->MsgLength*4);\n\t\tioc->ctl_cmds.status |= MPT3_CMD_REPLY_VALID;\n\t\t \n\t\tif (mpi_reply->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||\n\t\t    mpi_reply->Function ==\n\t\t    MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH) {\n\t\t\tscsiio_reply = (Mpi2SCSIIOReply_t *)mpi_reply;\n\t\t\tif (scsiio_reply->SCSIState &\n\t\t\t    MPI2_SCSI_STATE_AUTOSENSE_VALID) {\n\t\t\t\tsz = min_t(u32, SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t    le32_to_cpu(scsiio_reply->SenseCount));\n\t\t\t\tsense_data = mpt3sas_base_get_sense_buffer(ioc,\n\t\t\t\t    smid);\n\t\t\t\tmemcpy(ioc->ctl_cmds.sense, sense_data, sz);\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (mpi_reply->Function == MPI2_FUNCTION_NVME_ENCAPSULATED) {\n\t\t\tnvme_error_reply =\n\t\t\t    (Mpi26NVMeEncapsulatedErrorReply_t *)mpi_reply;\n\t\t\tsz = min_t(u32, NVME_ERROR_RESPONSE_SIZE,\n\t\t\t    le16_to_cpu(nvme_error_reply->ErrorResponseCount));\n\t\t\tsense_data = mpt3sas_base_get_sense_buffer(ioc, smid);\n\t\t\tmemcpy(ioc->ctl_cmds.sense, sense_data, sz);\n\t\t}\n\t}\n\n\t_ctl_display_some_debug(ioc, smid, \"ctl_done\", mpi_reply);\n\tioc->ctl_cmds.status &= ~MPT3_CMD_PENDING;\n\tcomplete(&ioc->ctl_cmds.done);\n\treturn 1;\n}\n\n \nstatic int\n_ctl_check_event_type(struct MPT3SAS_ADAPTER *ioc, u16 event)\n{\n\tu16 i;\n\tu32 desired_event;\n\n\tif (event >= 128 || !event || !ioc->event_log)\n\t\treturn 0;\n\n\tdesired_event = (1 << (event % 32));\n\tif (!desired_event)\n\t\tdesired_event = 1;\n\ti = event / 32;\n\treturn desired_event & ioc->event_type[i];\n}\n\n \nvoid\nmpt3sas_ctl_add_to_event_log(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventNotificationReply_t *mpi_reply)\n{\n\tstruct MPT3_IOCTL_EVENTS *event_log;\n\tu16 event;\n\tint i;\n\tu32 sz, event_data_sz;\n\tu8 send_aen = 0;\n\n\tif (!ioc->event_log)\n\t\treturn;\n\n\tevent = le16_to_cpu(mpi_reply->Event);\n\n\tif (_ctl_check_event_type(ioc, event)) {\n\n\t\t \n\t\ti = ioc->event_context % MPT3SAS_CTL_EVENT_LOG_SIZE;\n\t\tevent_log = ioc->event_log;\n\t\tevent_log[i].event = event;\n\t\tevent_log[i].context = ioc->event_context++;\n\n\t\tevent_data_sz = le16_to_cpu(mpi_reply->EventDataLength)*4;\n\t\tsz = min_t(u32, event_data_sz, MPT3_EVENT_DATA_SIZE);\n\t\tmemset(event_log[i].data, 0, MPT3_EVENT_DATA_SIZE);\n\t\tmemcpy(event_log[i].data, mpi_reply->EventData, sz);\n\t\tsend_aen = 1;\n\t}\n\n\t \n\tif (event == MPI2_EVENT_LOG_ENTRY_ADDED ||\n\t    (send_aen && !ioc->aen_event_read_flag)) {\n\t\tioc->aen_event_read_flag = 1;\n\t\twake_up_interruptible(&ctl_poll_wait);\n\t\tif (async_queue)\n\t\t\tkill_fasync(&async_queue, SIGIO, POLL_IN);\n\t}\n}\n\n \nu8\nmpt3sas_ctl_event_callback(struct MPT3SAS_ADAPTER *ioc, u8 msix_index,\n\tu32 reply)\n{\n\tMpi2EventNotificationReply_t *mpi_reply;\n\n\tmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tif (mpi_reply)\n\t\tmpt3sas_ctl_add_to_event_log(ioc, mpi_reply);\n\treturn 1;\n}\n\n \nstatic int\n_ctl_verify_adapter(int ioc_number, struct MPT3SAS_ADAPTER **iocpp,\n\t\t\t\t\t\t\tint mpi_version)\n{\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tint version = 0;\n\t \n\tspin_lock(&gioc_lock);\n\tlist_for_each_entry(ioc, &mpt3sas_ioc_list, list) {\n\t\tif (ioc->id != ioc_number)\n\t\t\tcontinue;\n\t\t \n\t\tversion = ioc->hba_mpi_version_belonged;\n\t\t \n\t\tif (mpi_version == (MPI25_VERSION | MPI26_VERSION)) {\n\t\t\tif ((version == MPI25_VERSION) ||\n\t\t\t\t(version == MPI26_VERSION))\n\t\t\t\tgoto out;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (version != mpi_version)\n\t\t\t\tcontinue;\n\t\t}\nout:\n\t\tspin_unlock(&gioc_lock);\n\t\t*iocpp = ioc;\n\t\treturn ioc_number;\n\t}\n\tspin_unlock(&gioc_lock);\n\t*iocpp = NULL;\n\treturn -1;\n}\n\n \nvoid mpt3sas_ctl_pre_reset_handler(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint i;\n\tu8 issue_reset;\n\n\tdtmprintk(ioc, ioc_info(ioc, \"%s: MPT3_IOC_PRE_RESET\\n\", __func__));\n\tfor (i = 0; i < MPI2_DIAG_BUF_TYPE_COUNT; i++) {\n\t\tif (!(ioc->diag_buffer_status[i] &\n\t\t      MPT3_DIAG_BUFFER_IS_REGISTERED))\n\t\t\tcontinue;\n\t\tif ((ioc->diag_buffer_status[i] &\n\t\t     MPT3_DIAG_BUFFER_IS_RELEASED))\n\t\t\tcontinue;\n\n\t\t \n\t\tioc_info(ioc,\n\t\t    \"%s: Releasing the trace buffer due to adapter reset.\",\n\t\t    __func__);\n\t\tioc->htb_rel.buffer_rel_condition =\n\t\t    MPT3_DIAG_BUFFER_REL_TRIGGER;\n\t\tmpt3sas_send_diag_release(ioc, i, &issue_reset);\n\t}\n}\n\n \nvoid mpt3sas_ctl_clear_outstanding_ioctls(struct MPT3SAS_ADAPTER *ioc)\n{\n\tdtmprintk(ioc,\n\t    ioc_info(ioc, \"%s: clear outstanding ioctl cmd\\n\", __func__));\n\tif (ioc->ctl_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc->ctl_cmds.status |= MPT3_CMD_RESET;\n\t\tmpt3sas_base_free_smid(ioc, ioc->ctl_cmds.smid);\n\t\tcomplete(&ioc->ctl_cmds.done);\n\t}\n}\n\n \nvoid mpt3sas_ctl_reset_done_handler(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint i;\n\n\tdtmprintk(ioc, ioc_info(ioc, \"%s: MPT3_IOC_DONE_RESET\\n\", __func__));\n\n\tfor (i = 0; i < MPI2_DIAG_BUF_TYPE_COUNT; i++) {\n\t\tif (!(ioc->diag_buffer_status[i] &\n\t\t      MPT3_DIAG_BUFFER_IS_REGISTERED))\n\t\t\tcontinue;\n\t\tif ((ioc->diag_buffer_status[i] &\n\t\t     MPT3_DIAG_BUFFER_IS_RELEASED))\n\t\t\tcontinue;\n\t\tioc->diag_buffer_status[i] |=\n\t\t\tMPT3_DIAG_BUFFER_IS_DIAG_RESET;\n\t}\n}\n\n \nstatic int\n_ctl_fasync(int fd, struct file *filep, int mode)\n{\n\treturn fasync_helper(fd, filep, mode, &async_queue);\n}\n\n \nstatic __poll_t\n_ctl_poll(struct file *filep, poll_table *wait)\n{\n\tstruct MPT3SAS_ADAPTER *ioc;\n\n\tpoll_wait(filep, &ctl_poll_wait, wait);\n\n\t \n\tspin_lock(&gioc_lock);\n\tlist_for_each_entry(ioc, &mpt3sas_ioc_list, list) {\n\t\tif (ioc->aen_event_read_flag) {\n\t\t\tspin_unlock(&gioc_lock);\n\t\t\treturn EPOLLIN | EPOLLRDNORM;\n\t\t}\n\t}\n\tspin_unlock(&gioc_lock);\n\treturn 0;\n}\n\n \nstatic int\n_ctl_set_task_mid(struct MPT3SAS_ADAPTER *ioc, struct mpt3_ioctl_command *karg,\n\tMpi2SCSITaskManagementRequest_t *tm_request)\n{\n\tbool found = false;\n\tu16 smid;\n\tu16 handle;\n\tstruct scsi_cmnd *scmd;\n\tstruct MPT3SAS_DEVICE *priv_data;\n\tMpi2SCSITaskManagementReply_t *tm_reply;\n\tu32 sz;\n\tu32 lun;\n\tchar *desc = NULL;\n\n\tif (tm_request->TaskType == MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK)\n\t\tdesc = \"abort_task\";\n\telse if (tm_request->TaskType == MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK)\n\t\tdesc = \"query_task\";\n\telse\n\t\treturn 0;\n\n\tlun = scsilun_to_int((struct scsi_lun *)tm_request->LUN);\n\n\thandle = le16_to_cpu(tm_request->DevHandle);\n\tfor (smid = ioc->scsiio_depth; smid && !found; smid--) {\n\t\tstruct scsiio_tracker *st;\n\t\t__le16 task_mid;\n\n\t\tscmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);\n\t\tif (!scmd)\n\t\t\tcontinue;\n\t\tif (lun != scmd->device->lun)\n\t\t\tcontinue;\n\t\tpriv_data = scmd->device->hostdata;\n\t\tif (priv_data->sas_target == NULL)\n\t\t\tcontinue;\n\t\tif (priv_data->sas_target->handle != handle)\n\t\t\tcontinue;\n\t\tst = scsi_cmd_priv(scmd);\n\n\t\t \n\t\ttask_mid = cpu_to_le16(st->smid);\n\t\tif (!tm_request->TaskMID)\n\t\t\ttm_request->TaskMID = task_mid;\n\t\tfound = tm_request->TaskMID == task_mid;\n\t}\n\n\tif (!found) {\n\t\tdctlprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: handle(0x%04x), lun(%d), no active mid!!\\n\",\n\t\t\t\t    desc, le16_to_cpu(tm_request->DevHandle),\n\t\t\t\t    lun));\n\t\ttm_reply = ioc->ctl_cmds.reply;\n\t\ttm_reply->DevHandle = tm_request->DevHandle;\n\t\ttm_reply->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;\n\t\ttm_reply->TaskType = tm_request->TaskType;\n\t\ttm_reply->MsgLength = sizeof(Mpi2SCSITaskManagementReply_t)/4;\n\t\ttm_reply->VP_ID = tm_request->VP_ID;\n\t\ttm_reply->VF_ID = tm_request->VF_ID;\n\t\tsz = min_t(u32, karg->max_reply_bytes, ioc->reply_sz);\n\t\tif (copy_to_user(karg->reply_frame_buf_ptr, ioc->ctl_cmds.reply,\n\t\t    sz))\n\t\t\tpr_err(\"failure at %s:%d/%s()!\\n\", __FILE__,\n\t\t\t    __LINE__, __func__);\n\t\treturn 1;\n\t}\n\n\tdctlprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: handle(0x%04x), lun(%d), task_mid(%d)\\n\",\n\t\t\t    desc, le16_to_cpu(tm_request->DevHandle), lun,\n\t\t\t    le16_to_cpu(tm_request->TaskMID)));\n\treturn 0;\n}\n\n \nstatic long\n_ctl_do_mpt_command(struct MPT3SAS_ADAPTER *ioc, struct mpt3_ioctl_command karg,\n\tvoid __user *mf)\n{\n\tMPI2RequestHeader_t *mpi_request = NULL, *request;\n\tMPI2DefaultReply_t *mpi_reply;\n\tMpi26NVMeEncapsulatedRequest_t *nvme_encap_request = NULL;\n\tstruct _pcie_device *pcie_device = NULL;\n\tu16 smid;\n\tunsigned long timeout;\n\tu8 issue_reset;\n\tu32 sz, sz_arg;\n\tvoid *psge;\n\tvoid *data_out = NULL;\n\tdma_addr_t data_out_dma = 0;\n\tsize_t data_out_sz = 0;\n\tvoid *data_in = NULL;\n\tdma_addr_t data_in_dma = 0;\n\tsize_t data_in_sz = 0;\n\tlong ret;\n\tu16 device_handle = MPT3SAS_INVALID_DEVICE_HANDLE;\n\n\tissue_reset = 0;\n\n\tif (ioc->ctl_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: ctl_cmd in use\\n\", __func__);\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tret = mpt3sas_wait_for_ioc(ioc,\tIOC_OPERATIONAL_WAIT_COUNT);\n\tif (ret)\n\t\tgoto out;\n\n\tmpi_request = kzalloc(ioc->request_sz, GFP_KERNEL);\n\tif (!mpi_request) {\n\t\tioc_err(ioc, \"%s: failed obtaining a memory for mpi_request\\n\",\n\t\t\t__func__);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tif (karg.data_sge_offset * 4 > ioc->request_sz ||\n\t    karg.data_sge_offset > (UINT_MAX / 4)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (copy_from_user(mpi_request, mf, karg.data_sge_offset*4)) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\", __FILE__, __LINE__,\n\t\t    __func__);\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (mpi_request->Function == MPI2_FUNCTION_SCSI_TASK_MGMT) {\n\t\tsmid = mpt3sas_base_get_smid_hpr(ioc, ioc->ctl_cb_idx);\n\t\tif (!smid) {\n\t\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tsmid = ioc->scsiio_depth - INTERNAL_SCSIIO_CMDS_COUNT + 1;\n\t}\n\n\tret = 0;\n\tioc->ctl_cmds.status = MPT3_CMD_PENDING;\n\tmemset(ioc->ctl_cmds.reply, 0, ioc->reply_sz);\n\trequest = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(request, 0, ioc->request_sz);\n\tmemcpy(request, mpi_request, karg.data_sge_offset*4);\n\tioc->ctl_cmds.smid = smid;\n\tdata_out_sz = karg.data_out_size;\n\tdata_in_sz = karg.data_in_size;\n\n\tif (mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||\n\t    mpi_request->Function == MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH ||\n\t    mpi_request->Function == MPI2_FUNCTION_SCSI_TASK_MGMT ||\n\t    mpi_request->Function == MPI2_FUNCTION_SATA_PASSTHROUGH ||\n\t    mpi_request->Function == MPI2_FUNCTION_NVME_ENCAPSULATED) {\n\n\t\tdevice_handle = le16_to_cpu(mpi_request->FunctionDependent1);\n\t\tif (!device_handle || (device_handle >\n\t\t    ioc->facts.MaxDevHandle)) {\n\t\t\tret = -EINVAL;\n\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (data_out_sz)   {\n\t\tdata_out = dma_alloc_coherent(&ioc->pdev->dev, data_out_sz,\n\t\t\t\t&data_out_dma, GFP_KERNEL);\n\t\tif (!data_out) {\n\t\t\tpr_err(\"failure at %s:%d/%s()!\\n\", __FILE__,\n\t\t\t    __LINE__, __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\tgoto out;\n\t\t}\n\t\tif (copy_from_user(data_out, karg.data_out_buf_ptr,\n\t\t\tdata_out_sz)) {\n\t\t\tpr_err(\"failure at %s:%d/%s()!\\n\", __FILE__,\n\t\t\t    __LINE__, __func__);\n\t\t\tret =  -EFAULT;\n\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (data_in_sz)   {\n\t\tdata_in = dma_alloc_coherent(&ioc->pdev->dev, data_in_sz,\n\t\t\t\t&data_in_dma, GFP_KERNEL);\n\t\tif (!data_in) {\n\t\t\tpr_err(\"failure at %s:%d/%s()!\\n\", __FILE__,\n\t\t\t    __LINE__, __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpsge = (void *)request + (karg.data_sge_offset*4);\n\n\t \n\t_ctl_display_some_debug(ioc, smid, \"ctl_request\", NULL);\n\n\tinit_completion(&ioc->ctl_cmds.done);\n\tswitch (mpi_request->Function) {\n\tcase MPI2_FUNCTION_NVME_ENCAPSULATED:\n\t{\n\t\tnvme_encap_request = (Mpi26NVMeEncapsulatedRequest_t *)request;\n\t\tif (!ioc->pcie_sg_lookup) {\n\t\t\tdtmprintk(ioc, ioc_info(ioc,\n\t\t\t    \"HBA doesn't support NVMe. Rejecting NVMe Encapsulated request.\\n\"\n\t\t\t    ));\n\n\t\t\tif (ioc->logging_level & MPT_DEBUG_TM)\n\t\t\t\t_debug_dump_mf(nvme_encap_request,\n\t\t\t\t    ioc->request_sz/4);\n\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tnvme_encap_request->ErrorResponseBaseAddress =\n\t\t    cpu_to_le64(ioc->sense_dma & 0xFFFFFFFF00000000UL);\n\t\tnvme_encap_request->ErrorResponseBaseAddress |=\n\t\t   cpu_to_le64(le32_to_cpu(\n\t\t   mpt3sas_base_get_sense_buffer_dma(ioc, smid)));\n\t\tnvme_encap_request->ErrorResponseAllocationLength =\n\t\t\t\t\tcpu_to_le16(NVME_ERROR_RESPONSE_SIZE);\n\t\tmemset(ioc->ctl_cmds.sense, 0, NVME_ERROR_RESPONSE_SIZE);\n\t\tioc->build_nvme_prp(ioc, smid, nvme_encap_request,\n\t\t    data_out_dma, data_out_sz, data_in_dma, data_in_sz);\n\t\tif (test_bit(device_handle, ioc->device_remove_in_progress)) {\n\t\t\tdtmprintk(ioc,\n\t\t\t\t  ioc_info(ioc, \"handle(0x%04x): ioctl failed due to device removal in progress\\n\",\n\t\t\t\t\t   device_handle));\n\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmpt3sas_base_put_smid_nvme_encap(ioc, smid);\n\t\tbreak;\n\t}\n\tcase MPI2_FUNCTION_SCSI_IO_REQUEST:\n\tcase MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH:\n\t{\n\t\tMpi2SCSIIORequest_t *scsiio_request =\n\t\t    (Mpi2SCSIIORequest_t *)request;\n\t\tscsiio_request->SenseBufferLength = SCSI_SENSE_BUFFERSIZE;\n\t\tscsiio_request->SenseBufferLowAddress =\n\t\t    mpt3sas_base_get_sense_buffer_dma(ioc, smid);\n\t\tmemset(ioc->ctl_cmds.sense, 0, SCSI_SENSE_BUFFERSIZE);\n\t\tif (test_bit(device_handle, ioc->device_remove_in_progress)) {\n\t\t\tdtmprintk(ioc,\n\t\t\t\t  ioc_info(ioc, \"handle(0x%04x) :ioctl failed due to device removal in progress\\n\",\n\t\t\t\t\t   device_handle));\n\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tioc->build_sg(ioc, psge, data_out_dma, data_out_sz,\n\t\t    data_in_dma, data_in_sz);\n\t\tif (mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST)\n\t\t\tioc->put_smid_scsi_io(ioc, smid, device_handle);\n\t\telse\n\t\t\tioc->put_smid_default(ioc, smid);\n\t\tbreak;\n\t}\n\tcase MPI2_FUNCTION_SCSI_TASK_MGMT:\n\t{\n\t\tMpi2SCSITaskManagementRequest_t *tm_request =\n\t\t    (Mpi2SCSITaskManagementRequest_t *)request;\n\n\t\tdtmprintk(ioc,\n\t\t\t  ioc_info(ioc, \"TASK_MGMT: handle(0x%04x), task_type(0x%02x)\\n\",\n\t\t\t\t   le16_to_cpu(tm_request->DevHandle),\n\t\t\t\t   tm_request->TaskType));\n\t\tioc->got_task_abort_from_ioctl = 1;\n\t\tif (tm_request->TaskType ==\n\t\t    MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK ||\n\t\t    tm_request->TaskType ==\n\t\t    MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK) {\n\t\t\tif (_ctl_set_task_mid(ioc, &karg, tm_request)) {\n\t\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\t\tioc->got_task_abort_from_ioctl = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tioc->got_task_abort_from_ioctl = 0;\n\n\t\tif (test_bit(device_handle, ioc->device_remove_in_progress)) {\n\t\t\tdtmprintk(ioc,\n\t\t\t\t  ioc_info(ioc, \"handle(0x%04x) :ioctl failed due to device removal in progress\\n\",\n\t\t\t\t\t   device_handle));\n\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmpt3sas_scsih_set_tm_flag(ioc, le16_to_cpu(\n\t\t    tm_request->DevHandle));\n\t\tioc->build_sg_mpi(ioc, psge, data_out_dma, data_out_sz,\n\t\t    data_in_dma, data_in_sz);\n\t\tioc->put_smid_hi_priority(ioc, smid, 0);\n\t\tbreak;\n\t}\n\tcase MPI2_FUNCTION_SMP_PASSTHROUGH:\n\t{\n\t\tMpi2SmpPassthroughRequest_t *smp_request =\n\t\t    (Mpi2SmpPassthroughRequest_t *)mpi_request;\n\t\tu8 *data;\n\n\t\tif (!ioc->multipath_on_hba) {\n\t\t\t \n\t\t\tsmp_request->PhysicalPort = 0xFF;\n\t\t}\n\t\tif (smp_request->PassthroughFlags &\n\t\t    MPI2_SMP_PT_REQ_PT_FLAGS_IMMEDIATE)\n\t\t\tdata = (u8 *)&smp_request->SGL;\n\t\telse {\n\t\t\tif (unlikely(data_out == NULL)) {\n\t\t\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdata = data_out;\n\t\t}\n\n\t\tif (data[1] == 0x91 && (data[10] == 1 || data[10] == 2)) {\n\t\t\tioc->ioc_link_reset_in_progress = 1;\n\t\t\tioc->ignore_loginfos = 1;\n\t\t}\n\t\tioc->build_sg(ioc, psge, data_out_dma, data_out_sz, data_in_dma,\n\t\t    data_in_sz);\n\t\tioc->put_smid_default(ioc, smid);\n\t\tbreak;\n\t}\n\tcase MPI2_FUNCTION_SATA_PASSTHROUGH:\n\t{\n\t\tif (test_bit(device_handle, ioc->device_remove_in_progress)) {\n\t\t\tdtmprintk(ioc,\n\t\t\t\t  ioc_info(ioc, \"handle(0x%04x) :ioctl failed due to device removal in progress\\n\",\n\t\t\t\t\t   device_handle));\n\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tioc->build_sg(ioc, psge, data_out_dma, data_out_sz, data_in_dma,\n\t\t    data_in_sz);\n\t\tioc->put_smid_default(ioc, smid);\n\t\tbreak;\n\t}\n\tcase MPI2_FUNCTION_FW_DOWNLOAD:\n\t{\n\t\tif (ioc->pdev->vendor == MPI2_MFGPAGE_VENDORID_ATTO) {\n\t\t\tioc_info(ioc, \"Firmware download not supported for ATTO HBA.\\n\");\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\t}\n\tcase MPI2_FUNCTION_FW_UPLOAD:\n\t{\n\t\tioc->build_sg(ioc, psge, data_out_dma, data_out_sz, data_in_dma,\n\t\t    data_in_sz);\n\t\tioc->put_smid_default(ioc, smid);\n\t\tbreak;\n\t}\n\tcase MPI2_FUNCTION_TOOLBOX:\n\t{\n\t\tMpi2ToolboxCleanRequest_t *toolbox_request =\n\t\t\t(Mpi2ToolboxCleanRequest_t *)mpi_request;\n\n\t\tif ((toolbox_request->Tool == MPI2_TOOLBOX_DIAGNOSTIC_CLI_TOOL)\n\t\t    || (toolbox_request->Tool ==\n\t\t    MPI26_TOOLBOX_BACKEND_PCIE_LANE_MARGIN))\n\t\t\tioc->build_sg(ioc, psge, data_out_dma, data_out_sz,\n\t\t\t\tdata_in_dma, data_in_sz);\n\t\telse if (toolbox_request->Tool ==\n\t\t\t\tMPI2_TOOLBOX_MEMORY_MOVE_TOOL) {\n\t\t\tMpi2ToolboxMemMoveRequest_t *mem_move_request =\n\t\t\t\t\t(Mpi2ToolboxMemMoveRequest_t *)request;\n\t\t\tMpi2SGESimple64_t tmp, *src = NULL, *dst = NULL;\n\n\t\t\tioc->build_sg_mpi(ioc, psge, data_out_dma,\n\t\t\t\t\tdata_out_sz, data_in_dma, data_in_sz);\n\t\t\tif (data_out_sz && !data_in_sz) {\n\t\t\t\tdst =\n\t\t\t\t    (Mpi2SGESimple64_t *)&mem_move_request->SGL;\n\t\t\t\tsrc = (void *)dst + ioc->sge_size;\n\n\t\t\t\tmemcpy(&tmp, src, ioc->sge_size);\n\t\t\t\tmemcpy(src, dst, ioc->sge_size);\n\t\t\t\tmemcpy(dst, &tmp, ioc->sge_size);\n\t\t\t}\n\t\t\tif (ioc->logging_level & MPT_DEBUG_TM) {\n\t\t\t\tioc_info(ioc,\n\t\t\t\t  \"Mpi2ToolboxMemMoveRequest_t request msg\\n\");\n\t\t\t\t_debug_dump_mf(mem_move_request,\n\t\t\t\t\t\t\tioc->request_sz/4);\n\t\t\t}\n\t\t} else\n\t\t\tioc->build_sg_mpi(ioc, psge, data_out_dma, data_out_sz,\n\t\t\t    data_in_dma, data_in_sz);\n\t\tioc->put_smid_default(ioc, smid);\n\t\tbreak;\n\t}\n\tcase MPI2_FUNCTION_SAS_IO_UNIT_CONTROL:\n\t{\n\t\tMpi2SasIoUnitControlRequest_t *sasiounit_request =\n\t\t    (Mpi2SasIoUnitControlRequest_t *)mpi_request;\n\n\t\tif (sasiounit_request->Operation == MPI2_SAS_OP_PHY_HARD_RESET\n\t\t    || sasiounit_request->Operation ==\n\t\t    MPI2_SAS_OP_PHY_LINK_RESET) {\n\t\t\tioc->ioc_link_reset_in_progress = 1;\n\t\t\tioc->ignore_loginfos = 1;\n\t\t}\n\t\t \n\t}\n\t\tfallthrough;\n\tdefault:\n\t\tioc->build_sg_mpi(ioc, psge, data_out_dma, data_out_sz,\n\t\t    data_in_dma, data_in_sz);\n\t\tioc->put_smid_default(ioc, smid);\n\t\tbreak;\n\t}\n\n\tif (karg.timeout < MPT3_IOCTL_DEFAULT_TIMEOUT)\n\t\ttimeout = MPT3_IOCTL_DEFAULT_TIMEOUT;\n\telse\n\t\ttimeout = karg.timeout;\n\twait_for_completion_timeout(&ioc->ctl_cmds.done, timeout*HZ);\n\tif (mpi_request->Function == MPI2_FUNCTION_SCSI_TASK_MGMT) {\n\t\tMpi2SCSITaskManagementRequest_t *tm_request =\n\t\t    (Mpi2SCSITaskManagementRequest_t *)mpi_request;\n\t\tmpt3sas_scsih_clear_tm_flag(ioc, le16_to_cpu(\n\t\t    tm_request->DevHandle));\n\t\tmpt3sas_trigger_master(ioc, MASTER_TRIGGER_TASK_MANAGMENT);\n\t} else if ((mpi_request->Function == MPI2_FUNCTION_SMP_PASSTHROUGH ||\n\t    mpi_request->Function == MPI2_FUNCTION_SAS_IO_UNIT_CONTROL) &&\n\t\tioc->ioc_link_reset_in_progress) {\n\t\tioc->ioc_link_reset_in_progress = 0;\n\t\tioc->ignore_loginfos = 0;\n\t}\n\tif (!(ioc->ctl_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tmpt3sas_check_cmd_timeout(ioc,\n\t\t    ioc->ctl_cmds.status, mpi_request,\n\t\t    karg.data_sge_offset, issue_reset);\n\t\tgoto issue_host_reset;\n\t}\n\n\tmpi_reply = ioc->ctl_cmds.reply;\n\n\tif (mpi_reply->Function == MPI2_FUNCTION_SCSI_TASK_MGMT &&\n\t    (ioc->logging_level & MPT_DEBUG_TM)) {\n\t\tMpi2SCSITaskManagementReply_t *tm_reply =\n\t\t    (Mpi2SCSITaskManagementReply_t *)mpi_reply;\n\n\t\tioc_info(ioc, \"TASK_MGMT: IOCStatus(0x%04x), IOCLogInfo(0x%08x), TerminationCount(0x%08x)\\n\",\n\t\t\t le16_to_cpu(tm_reply->IOCStatus),\n\t\t\t le32_to_cpu(tm_reply->IOCLogInfo),\n\t\t\t le32_to_cpu(tm_reply->TerminationCount));\n\t}\n\n\t \n\tif (data_in_sz) {\n\t\tif (copy_to_user(karg.data_in_buf_ptr, data_in,\n\t\t    data_in_sz)) {\n\t\t\tpr_err(\"failure at %s:%d/%s()!\\n\", __FILE__,\n\t\t\t    __LINE__, __func__);\n\t\t\tret = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (karg.max_reply_bytes) {\n\t\tsz = min_t(u32, karg.max_reply_bytes, ioc->reply_sz);\n\t\tif (copy_to_user(karg.reply_frame_buf_ptr, ioc->ctl_cmds.reply,\n\t\t    sz)) {\n\t\t\tpr_err(\"failure at %s:%d/%s()!\\n\", __FILE__,\n\t\t\t    __LINE__, __func__);\n\t\t\tret = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (karg.max_sense_bytes && (mpi_request->Function ==\n\t    MPI2_FUNCTION_SCSI_IO_REQUEST || mpi_request->Function ==\n\t    MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH || mpi_request->Function ==\n\t    MPI2_FUNCTION_NVME_ENCAPSULATED)) {\n\t\tif (karg.sense_data_ptr == NULL) {\n\t\t\tioc_info(ioc, \"Response buffer provided by application is NULL; Response data will not be returned\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tsz_arg = (mpi_request->Function ==\n\t\tMPI2_FUNCTION_NVME_ENCAPSULATED) ? NVME_ERROR_RESPONSE_SIZE :\n\t\t\t\t\t\t\tSCSI_SENSE_BUFFERSIZE;\n\t\tsz = min_t(u32, karg.max_sense_bytes, sz_arg);\n\t\tif (copy_to_user(karg.sense_data_ptr, ioc->ctl_cmds.sense,\n\t\t    sz)) {\n\t\t\tpr_err(\"failure at %s:%d/%s()!\\n\", __FILE__,\n\t\t\t\t__LINE__, __func__);\n\t\t\tret = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n issue_host_reset:\n\tif (issue_reset) {\n\t\tret = -ENODATA;\n\t\tif ((mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||\n\t\t    mpi_request->Function ==\n\t\t    MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH ||\n\t\t    mpi_request->Function == MPI2_FUNCTION_SATA_PASSTHROUGH)) {\n\t\t\tioc_info(ioc, \"issue target reset: handle = (0x%04x)\\n\",\n\t\t\t\t le16_to_cpu(mpi_request->FunctionDependent1));\n\t\t\tmpt3sas_halt_firmware(ioc);\n\t\t\tpcie_device = mpt3sas_get_pdev_by_handle(ioc,\n\t\t\t\tle16_to_cpu(mpi_request->FunctionDependent1));\n\t\t\tif (pcie_device && (!ioc->tm_custom_handling) &&\n\t\t\t    (!(mpt3sas_scsih_is_pcie_scsi_device(\n\t\t\t    pcie_device->device_info))))\n\t\t\t\tmpt3sas_scsih_issue_locked_tm(ioc,\n\t\t\t\t  le16_to_cpu(mpi_request->FunctionDependent1),\n\t\t\t\t  0, 0, 0,\n\t\t\t\t  MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET, 0,\n\t\t\t\t  0, pcie_device->reset_timeout,\n\t\t\tMPI26_SCSITASKMGMT_MSGFLAGS_PROTOCOL_LVL_RST_PCIE);\n\t\t\telse\n\t\t\t\tmpt3sas_scsih_issue_locked_tm(ioc,\n\t\t\t\t  le16_to_cpu(mpi_request->FunctionDependent1),\n\t\t\t\t  0, 0, 0,\n\t\t\t\t  MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET, 0,\n\t\t\t\t  0, 30, MPI2_SCSITASKMGMT_MSGFLAGS_LINK_RESET);\n\t\t} else\n\t\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\t}\n\n out:\n\tif (pcie_device)\n\t\tpcie_device_put(pcie_device);\n\n\t \n\tif (data_in)\n\t\tdma_free_coherent(&ioc->pdev->dev, data_in_sz, data_in,\n\t\t    data_in_dma);\n\n\tif (data_out)\n\t\tdma_free_coherent(&ioc->pdev->dev, data_out_sz, data_out,\n\t\t    data_out_dma);\n\n\tkfree(mpi_request);\n\tioc->ctl_cmds.status = MPT3_CMD_NOT_USED;\n\treturn ret;\n}\n\n \nstatic long\n_ctl_getiocinfo(struct MPT3SAS_ADAPTER *ioc, void __user *arg)\n{\n\tstruct mpt3_ioctl_iocinfo karg;\n\n\tdctlprintk(ioc, ioc_info(ioc, \"%s: enter\\n\",\n\t\t\t\t __func__));\n\n\tmemset(&karg, 0 , sizeof(karg));\n\tif (ioc->pfacts)\n\t\tkarg.port_number = ioc->pfacts[0].PortNumber;\n\tkarg.hw_rev = ioc->pdev->revision;\n\tkarg.pci_id = ioc->pdev->device;\n\tkarg.subsystem_device = ioc->pdev->subsystem_device;\n\tkarg.subsystem_vendor = ioc->pdev->subsystem_vendor;\n\tkarg.pci_information.u.bits.bus = ioc->pdev->bus->number;\n\tkarg.pci_information.u.bits.device = PCI_SLOT(ioc->pdev->devfn);\n\tkarg.pci_information.u.bits.function = PCI_FUNC(ioc->pdev->devfn);\n\tkarg.pci_information.segment_id = pci_domain_nr(ioc->pdev->bus);\n\tkarg.firmware_version = ioc->facts.FWVersion.Word;\n\tstrcpy(karg.driver_version, ioc->driver_name);\n\tstrcat(karg.driver_version, \"-\");\n\tswitch  (ioc->hba_mpi_version_belonged) {\n\tcase MPI2_VERSION:\n\t\tif (ioc->is_warpdrive)\n\t\t\tkarg.adapter_type = MPT2_IOCTL_INTERFACE_SAS2_SSS6200;\n\t\telse\n\t\t\tkarg.adapter_type = MPT2_IOCTL_INTERFACE_SAS2;\n\t\tstrcat(karg.driver_version, MPT2SAS_DRIVER_VERSION);\n\t\tbreak;\n\tcase MPI25_VERSION:\n\tcase MPI26_VERSION:\n\t\tif (ioc->is_gen35_ioc)\n\t\t\tkarg.adapter_type = MPT3_IOCTL_INTERFACE_SAS35;\n\t\telse\n\t\t\tkarg.adapter_type = MPT3_IOCTL_INTERFACE_SAS3;\n\t\tstrcat(karg.driver_version, MPT3SAS_DRIVER_VERSION);\n\t\tbreak;\n\t}\n\tkarg.bios_version = le32_to_cpu(ioc->bios_pg3.BiosVersion);\n\n\tif (copy_to_user(arg, &karg, sizeof(karg))) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n \nstatic long\n_ctl_eventquery(struct MPT3SAS_ADAPTER *ioc, void __user *arg)\n{\n\tstruct mpt3_ioctl_eventquery karg;\n\n\tif (copy_from_user(&karg, arg, sizeof(karg))) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, ioc_info(ioc, \"%s: enter\\n\",\n\t\t\t\t __func__));\n\n\tkarg.event_entries = MPT3SAS_CTL_EVENT_LOG_SIZE;\n\tmemcpy(karg.event_types, ioc->event_type,\n\t    MPI2_EVENT_NOTIFY_EVENTMASK_WORDS * sizeof(u32));\n\n\tif (copy_to_user(arg, &karg, sizeof(karg))) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n \nstatic long\n_ctl_eventenable(struct MPT3SAS_ADAPTER *ioc, void __user *arg)\n{\n\tstruct mpt3_ioctl_eventenable karg;\n\n\tif (copy_from_user(&karg, arg, sizeof(karg))) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, ioc_info(ioc, \"%s: enter\\n\",\n\t\t\t\t __func__));\n\n\tmemcpy(ioc->event_type, karg.event_types,\n\t    MPI2_EVENT_NOTIFY_EVENTMASK_WORDS * sizeof(u32));\n\tmpt3sas_base_validate_event_type(ioc, ioc->event_type);\n\n\tif (ioc->event_log)\n\t\treturn 0;\n\t \n\tioc->event_context = 0;\n\tioc->aen_event_read_flag = 0;\n\tioc->event_log = kcalloc(MPT3SAS_CTL_EVENT_LOG_SIZE,\n\t    sizeof(struct MPT3_IOCTL_EVENTS), GFP_KERNEL);\n\tif (!ioc->event_log) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nstatic long\n_ctl_eventreport(struct MPT3SAS_ADAPTER *ioc, void __user *arg)\n{\n\tstruct mpt3_ioctl_eventreport karg;\n\tu32 number_bytes, max_events, max;\n\tstruct mpt3_ioctl_eventreport __user *uarg = arg;\n\n\tif (copy_from_user(&karg, arg, sizeof(karg))) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, ioc_info(ioc, \"%s: enter\\n\",\n\t\t\t\t __func__));\n\n\tnumber_bytes = karg.hdr.max_data_size -\n\t    sizeof(struct mpt3_ioctl_header);\n\tmax_events = number_bytes/sizeof(struct MPT3_IOCTL_EVENTS);\n\tmax = min_t(u32, MPT3SAS_CTL_EVENT_LOG_SIZE, max_events);\n\n\t \n\tif (!max || !ioc->event_log)\n\t\treturn -ENODATA;\n\n\tnumber_bytes = max * sizeof(struct MPT3_IOCTL_EVENTS);\n\tif (copy_to_user(uarg->event_data, ioc->event_log, number_bytes)) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tioc->aen_event_read_flag = 0;\n\treturn 0;\n}\n\n \nstatic long\n_ctl_do_reset(struct MPT3SAS_ADAPTER *ioc, void __user *arg)\n{\n\tstruct mpt3_ioctl_diag_reset karg;\n\tint retval;\n\n\tif (copy_from_user(&karg, arg, sizeof(karg))) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tif (ioc->shost_recovery || ioc->pci_error_recovery ||\n\t    ioc->is_driver_loading)\n\t\treturn -EAGAIN;\n\n\tdctlprintk(ioc, ioc_info(ioc, \"%s: enter\\n\",\n\t\t\t\t __func__));\n\n\tioc->reset_from_user = 1;\n\tretval = mpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\tioc_info(ioc,\n\t    \"Ioctl: host reset: %s\\n\", ((!retval) ? \"SUCCESS\" : \"FAILED\"));\n\treturn 0;\n}\n\n \nstatic int\n_ctl_btdh_search_sas_device(struct MPT3SAS_ADAPTER *ioc,\n\tstruct mpt3_ioctl_btdh_mapping *btdh)\n{\n\tstruct _sas_device *sas_device;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tif (list_empty(&ioc->sas_device_list))\n\t\treturn rc;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tlist_for_each_entry(sas_device, &ioc->sas_device_list, list) {\n\t\tif (btdh->bus == 0xFFFFFFFF && btdh->id == 0xFFFFFFFF &&\n\t\t    btdh->handle == sas_device->handle) {\n\t\t\tbtdh->bus = sas_device->channel;\n\t\t\tbtdh->id = sas_device->id;\n\t\t\trc = 1;\n\t\t\tgoto out;\n\t\t} else if (btdh->bus == sas_device->channel && btdh->id ==\n\t\t    sas_device->id && btdh->handle == 0xFFFF) {\n\t\t\tbtdh->handle = sas_device->handle;\n\t\t\trc = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\treturn rc;\n}\n\n \nstatic int\n_ctl_btdh_search_pcie_device(struct MPT3SAS_ADAPTER *ioc,\n\tstruct mpt3_ioctl_btdh_mapping *btdh)\n{\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tif (list_empty(&ioc->pcie_device_list))\n\t\treturn rc;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_list, list) {\n\t\tif (btdh->bus == 0xFFFFFFFF && btdh->id == 0xFFFFFFFF &&\n\t\t\t   btdh->handle == pcie_device->handle) {\n\t\t\tbtdh->bus = pcie_device->channel;\n\t\t\tbtdh->id = pcie_device->id;\n\t\t\trc = 1;\n\t\t\tgoto out;\n\t\t} else if (btdh->bus == pcie_device->channel && btdh->id ==\n\t\t\t   pcie_device->id && btdh->handle == 0xFFFF) {\n\t\t\tbtdh->handle = pcie_device->handle;\n\t\t\trc = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\treturn rc;\n}\n\n \nstatic int\n_ctl_btdh_search_raid_device(struct MPT3SAS_ADAPTER *ioc,\n\tstruct mpt3_ioctl_btdh_mapping *btdh)\n{\n\tstruct _raid_device *raid_device;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tif (list_empty(&ioc->raid_device_list))\n\t\treturn rc;\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\tlist_for_each_entry(raid_device, &ioc->raid_device_list, list) {\n\t\tif (btdh->bus == 0xFFFFFFFF && btdh->id == 0xFFFFFFFF &&\n\t\t    btdh->handle == raid_device->handle) {\n\t\t\tbtdh->bus = raid_device->channel;\n\t\t\tbtdh->id = raid_device->id;\n\t\t\trc = 1;\n\t\t\tgoto out;\n\t\t} else if (btdh->bus == raid_device->channel && btdh->id ==\n\t\t    raid_device->id && btdh->handle == 0xFFFF) {\n\t\t\tbtdh->handle = raid_device->handle;\n\t\t\trc = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\treturn rc;\n}\n\n \nstatic long\n_ctl_btdh_mapping(struct MPT3SAS_ADAPTER *ioc, void __user *arg)\n{\n\tstruct mpt3_ioctl_btdh_mapping karg;\n\tint rc;\n\n\tif (copy_from_user(&karg, arg, sizeof(karg))) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, ioc_info(ioc, \"%s\\n\",\n\t\t\t\t __func__));\n\n\trc = _ctl_btdh_search_sas_device(ioc, &karg);\n\tif (!rc)\n\t\trc = _ctl_btdh_search_pcie_device(ioc, &karg);\n\tif (!rc)\n\t\t_ctl_btdh_search_raid_device(ioc, &karg);\n\n\tif (copy_to_user(arg, &karg, sizeof(karg))) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n \nstatic u8\n_ctl_diag_capability(struct MPT3SAS_ADAPTER *ioc, u8 buffer_type)\n{\n\tu8 rc = 0;\n\n\tswitch (buffer_type) {\n\tcase MPI2_DIAG_BUF_TYPE_TRACE:\n\t\tif (ioc->facts.IOCCapabilities &\n\t\t    MPI2_IOCFACTS_CAPABILITY_DIAG_TRACE_BUFFER)\n\t\t\trc = 1;\n\t\tbreak;\n\tcase MPI2_DIAG_BUF_TYPE_SNAPSHOT:\n\t\tif (ioc->facts.IOCCapabilities &\n\t\t    MPI2_IOCFACTS_CAPABILITY_SNAPSHOT_BUFFER)\n\t\t\trc = 1;\n\t\tbreak;\n\tcase MPI2_DIAG_BUF_TYPE_EXTENDED:\n\t\tif (ioc->facts.IOCCapabilities &\n\t\t    MPI2_IOCFACTS_CAPABILITY_EXTENDED_BUFFER)\n\t\t\trc = 1;\n\t}\n\n\treturn rc;\n}\n\n \nstatic u8\n_ctl_diag_get_bufftype(struct MPT3SAS_ADAPTER *ioc, u32 unique_id)\n{\n\tu8  index;\n\n\tfor (index = 0; index < MPI2_DIAG_BUF_TYPE_COUNT; index++) {\n\t\tif (ioc->unique_id[index] == unique_id)\n\t\t\treturn index;\n\t}\n\n\treturn MPT3_DIAG_UID_NOT_FOUND;\n}\n\n \nstatic long\n_ctl_diag_register_2(struct MPT3SAS_ADAPTER *ioc,\n\tstruct mpt3_diag_register *diag_register)\n{\n\tint rc, i;\n\tvoid *request_data = NULL;\n\tdma_addr_t request_data_dma;\n\tu32 request_data_sz = 0;\n\tMpi2DiagBufferPostRequest_t *mpi_request;\n\tMpi2DiagBufferPostReply_t *mpi_reply;\n\tu8 buffer_type;\n\tu16 smid;\n\tu16 ioc_status;\n\tu32 ioc_state;\n\tu8 issue_reset = 0;\n\n\tdctlprintk(ioc, ioc_info(ioc, \"%s\\n\",\n\t\t\t\t __func__));\n\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 1);\n\tif (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\n\t\tioc_err(ioc, \"%s: failed due to ioc not operational\\n\",\n\t\t\t__func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (ioc->ctl_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: ctl_cmd in use\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tbuffer_type = diag_register->buffer_type;\n\tif (!_ctl_diag_capability(ioc, buffer_type)) {\n\t\tioc_err(ioc, \"%s: doesn't have capability for buffer_type(0x%02x)\\n\",\n\t\t\t__func__, buffer_type);\n\t\treturn -EPERM;\n\t}\n\n\tif (diag_register->unique_id == 0) {\n\t\tioc_err(ioc,\n\t\t    \"%s: Invalid UID(0x%08x), buffer_type(0x%02x)\\n\", __func__,\n\t\t    diag_register->unique_id, buffer_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_APP_OWNED) &&\n\t    !(ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_RELEASED)) {\n\t\tioc_err(ioc,\n\t\t    \"%s: buffer_type(0x%02x) is already registered by application with UID(0x%08x)\\n\",\n\t\t    __func__, buffer_type, ioc->unique_id[buffer_type]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_REGISTERED) {\n\t\t \n\n\t\tif (ioc->unique_id[buffer_type] == MPT3DIAGBUFFUNIQUEID &&\n\t\t    ioc->diag_buffer_sz[buffer_type] ==\n\t\t    diag_register->requested_buffer_size) {\n\n\t\t\tif (!(ioc->diag_buffer_status[buffer_type] &\n\t\t\t     MPT3_DIAG_BUFFER_IS_RELEASED)) {\n\t\t\t\tdctlprintk(ioc, ioc_info(ioc,\n\t\t\t\t    \"%s: diag_buffer (%d) ownership changed. old-ID(0x%08x), new-ID(0x%08x)\\n\",\n\t\t\t\t    __func__, buffer_type,\n\t\t\t\t    ioc->unique_id[buffer_type],\n\t\t\t\t    diag_register->unique_id));\n\n\t\t\t\t \n\t\t\t\tioc->unique_id[buffer_type] =\n\t\t\t\t    diag_register->unique_id;\n\t\t\t\trc = 0;  \n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (ioc->unique_id[buffer_type] !=\n\t\t    MPT3DIAGBUFFUNIQUEID) {\n\t\t\tif (ioc->unique_id[buffer_type] !=\n\t\t\t    diag_register->unique_id ||\n\t\t\t    ioc->diag_buffer_sz[buffer_type] !=\n\t\t\t    diag_register->requested_buffer_size ||\n\t\t\t    !(ioc->diag_buffer_status[buffer_type] &\n\t\t\t    MPT3_DIAG_BUFFER_IS_RELEASED)) {\n\t\t\t\tioc_err(ioc,\n\t\t\t\t    \"%s: already has a registered buffer for buffer_type(0x%02x)\\n\",\n\t\t\t\t    __func__, buffer_type);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tioc_err(ioc, \"%s: already has a registered buffer for buffer_type(0x%02x)\\n\",\n\t\t\t    __func__, buffer_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_DRIVER_ALLOCATED) {\n\n\t\tif (ioc->unique_id[buffer_type] != MPT3DIAGBUFFUNIQUEID ||\n\t\t    ioc->diag_buffer_sz[buffer_type] !=\n\t\t    diag_register->requested_buffer_size) {\n\n\t\t\tioc_err(ioc,\n\t\t\t    \"%s: already a buffer is allocated for buffer_type(0x%02x) of size %d bytes, so please try registering again with same size\\n\",\n\t\t\t     __func__, buffer_type,\n\t\t\t    ioc->diag_buffer_sz[buffer_type]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (diag_register->requested_buffer_size % 4)  {\n\t\tioc_err(ioc, \"%s: the requested_buffer_size is not 4 byte aligned\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->ctl_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\tioc->ctl_cmds.status = MPT3_CMD_PENDING;\n\tmemset(ioc->ctl_cmds.reply, 0, ioc->reply_sz);\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(mpi_request, 0, ioc->request_sz);\n\tioc->ctl_cmds.smid = smid;\n\n\trequest_data = ioc->diag_buffer[buffer_type];\n\trequest_data_sz = diag_register->requested_buffer_size;\n\tioc->unique_id[buffer_type] = diag_register->unique_id;\n\t \n\tioc->reset_from_user = 0;\n\tmemset(&ioc->htb_rel, 0, sizeof(struct htb_rel_query));\n\tioc->diag_buffer_status[buffer_type] &=\n\t    MPT3_DIAG_BUFFER_IS_DRIVER_ALLOCATED;\n\tmemcpy(ioc->product_specific[buffer_type],\n\t    diag_register->product_specific, MPT3_PRODUCT_SPECIFIC_DWORDS);\n\tioc->diagnostic_flags[buffer_type] = diag_register->diagnostic_flags;\n\n\tif (request_data) {\n\t\trequest_data_dma = ioc->diag_buffer_dma[buffer_type];\n\t\tif (request_data_sz != ioc->diag_buffer_sz[buffer_type]) {\n\t\t\tdma_free_coherent(&ioc->pdev->dev,\n\t\t\t\t\tioc->diag_buffer_sz[buffer_type],\n\t\t\t\t\trequest_data, request_data_dma);\n\t\t\trequest_data = NULL;\n\t\t}\n\t}\n\n\tif (request_data == NULL) {\n\t\tioc->diag_buffer_sz[buffer_type] = 0;\n\t\tioc->diag_buffer_dma[buffer_type] = 0;\n\t\trequest_data = dma_alloc_coherent(&ioc->pdev->dev,\n\t\t\t\trequest_data_sz, &request_data_dma, GFP_KERNEL);\n\t\tif (request_data == NULL) {\n\t\t\tioc_err(ioc, \"%s: failed allocating memory for diag buffers, requested size(%d)\\n\",\n\t\t\t\t__func__, request_data_sz);\n\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tioc->diag_buffer[buffer_type] = request_data;\n\t\tioc->diag_buffer_sz[buffer_type] = request_data_sz;\n\t\tioc->diag_buffer_dma[buffer_type] = request_data_dma;\n\t}\n\n\tmpi_request->Function = MPI2_FUNCTION_DIAG_BUFFER_POST;\n\tmpi_request->BufferType = diag_register->buffer_type;\n\tmpi_request->Flags = cpu_to_le32(diag_register->diagnostic_flags);\n\tmpi_request->BufferAddress = cpu_to_le64(request_data_dma);\n\tmpi_request->BufferLength = cpu_to_le32(request_data_sz);\n\tmpi_request->VF_ID = 0;  \n\tmpi_request->VP_ID = 0;\n\n\tdctlprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: diag_buffer(0x%p), dma(0x%llx), sz(%d)\\n\",\n\t\t\t    __func__, request_data,\n\t\t\t    (unsigned long long)request_data_dma,\n\t\t\t    le32_to_cpu(mpi_request->BufferLength)));\n\n\tfor (i = 0; i < MPT3_PRODUCT_SPECIFIC_DWORDS; i++)\n\t\tmpi_request->ProductSpecific[i] =\n\t\t\tcpu_to_le32(ioc->product_specific[buffer_type][i]);\n\n\tinit_completion(&ioc->ctl_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->ctl_cmds.done,\n\t    MPT3_IOCTL_DEFAULT_TIMEOUT*HZ);\n\n\tif (!(ioc->ctl_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tmpt3sas_check_cmd_timeout(ioc,\n\t\t    ioc->ctl_cmds.status, mpi_request,\n\t\t    sizeof(Mpi2DiagBufferPostRequest_t)/4, issue_reset);\n\t\tgoto issue_host_reset;\n\t}\n\n\t \n\tif ((ioc->ctl_cmds.status & MPT3_CMD_REPLY_VALID) == 0) {\n\t\tioc_err(ioc, \"%s: no reply message\\n\", __func__);\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tmpi_reply = ioc->ctl_cmds.reply;\n\tioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;\n\n\tif (ioc_status == MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc->diag_buffer_status[buffer_type] |=\n\t\t\tMPT3_DIAG_BUFFER_IS_REGISTERED;\n\t\tdctlprintk(ioc, ioc_info(ioc, \"%s: success\\n\", __func__));\n\t} else {\n\t\tioc_info(ioc, \"%s: ioc_status(0x%04x) log_info(0x%08x)\\n\",\n\t\t\t __func__,\n\t\t\t ioc_status, le32_to_cpu(mpi_reply->IOCLogInfo));\n\t\trc = -EFAULT;\n\t}\n\n issue_host_reset:\n\tif (issue_reset)\n\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\n out:\n\n\tif (rc && request_data) {\n\t\tdma_free_coherent(&ioc->pdev->dev, request_data_sz,\n\t\t    request_data, request_data_dma);\n\t\tioc->diag_buffer[buffer_type] = NULL;\n\t\tioc->diag_buffer_status[buffer_type] &=\n\t\t    ~MPT3_DIAG_BUFFER_IS_DRIVER_ALLOCATED;\n\t}\n\n\tioc->ctl_cmds.status = MPT3_CMD_NOT_USED;\n\treturn rc;\n}\n\n \nvoid\nmpt3sas_enable_diag_buffer(struct MPT3SAS_ADAPTER *ioc, u8 bits_to_register)\n{\n\tstruct mpt3_diag_register diag_register;\n\tu32 ret_val;\n\tu32 trace_buff_size = ioc->manu_pg11.HostTraceBufferMaxSizeKB<<10;\n\tu32 min_trace_buff_size = 0;\n\tu32 decr_trace_buff_size = 0;\n\n\tmemset(&diag_register, 0, sizeof(struct mpt3_diag_register));\n\n\tif (bits_to_register & 1) {\n\t\tioc_info(ioc, \"registering trace buffer support\\n\");\n\t\tioc->diag_trigger_master.MasterData =\n\t\t    (MASTER_TRIGGER_FW_FAULT + MASTER_TRIGGER_ADAPTER_RESET);\n\t\tdiag_register.buffer_type = MPI2_DIAG_BUF_TYPE_TRACE;\n\t\tdiag_register.unique_id =\n\t\t    (ioc->hba_mpi_version_belonged == MPI2_VERSION) ?\n\t\t    (MPT2DIAGBUFFUNIQUEID):(MPT3DIAGBUFFUNIQUEID);\n\n\t\tif (trace_buff_size != 0) {\n\t\t\tdiag_register.requested_buffer_size = trace_buff_size;\n\t\t\tmin_trace_buff_size =\n\t\t\t    ioc->manu_pg11.HostTraceBufferMinSizeKB<<10;\n\t\t\tdecr_trace_buff_size =\n\t\t\t    ioc->manu_pg11.HostTraceBufferDecrementSizeKB<<10;\n\n\t\t\tif (min_trace_buff_size > trace_buff_size) {\n\t\t\t\t \n\t\t\t\tioc_err(ioc,\n\t\t\t\t    \"Min Trace Buff size (%d KB) greater than Max Trace Buff size (%d KB)\\n\",\n\t\t\t\t     min_trace_buff_size>>10,\n\t\t\t\t     trace_buff_size>>10);\n\t\t\t\tioc_err(ioc,\n\t\t\t\t    \"Using zero Min Trace Buff Size\\n\");\n\t\t\t\tmin_trace_buff_size = 0;\n\t\t\t}\n\n\t\t\tif (decr_trace_buff_size == 0) {\n\t\t\t\t \n\t\t\t\tdecr_trace_buff_size =\n\t\t\t\t    trace_buff_size - min_trace_buff_size;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tdiag_register.requested_buffer_size = 2 * (1024 * 1024);\n\t\t}\n\n\t\tdo {\n\t\t\tret_val = _ctl_diag_register_2(ioc,  &diag_register);\n\n\t\t\tif (ret_val == -ENOMEM && min_trace_buff_size &&\n\t\t\t    (trace_buff_size - decr_trace_buff_size) >=\n\t\t\t    min_trace_buff_size) {\n\t\t\t\t \n\t\t\t\ttrace_buff_size -= decr_trace_buff_size;\n\t\t\t\tdiag_register.requested_buffer_size =\n\t\t\t\t    trace_buff_size;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t} while (true);\n\n\t\tif (ret_val == -ENOMEM)\n\t\t\tioc_err(ioc,\n\t\t\t    \"Cannot allocate trace buffer memory. Last memory tried = %d KB\\n\",\n\t\t\t    diag_register.requested_buffer_size>>10);\n\t\telse if (ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE]\n\t\t    & MPT3_DIAG_BUFFER_IS_REGISTERED) {\n\t\t\tioc_info(ioc, \"Trace buffer memory %d KB allocated\\n\",\n\t\t\t    diag_register.requested_buffer_size>>10);\n\t\t\tif (ioc->hba_mpi_version_belonged != MPI2_VERSION)\n\t\t\t\tioc->diag_buffer_status[\n\t\t\t\t    MPI2_DIAG_BUF_TYPE_TRACE] |=\n\t\t\t\t    MPT3_DIAG_BUFFER_IS_DRIVER_ALLOCATED;\n\t\t}\n\t}\n\n\tif (bits_to_register & 2) {\n\t\tioc_info(ioc, \"registering snapshot buffer support\\n\");\n\t\tdiag_register.buffer_type = MPI2_DIAG_BUF_TYPE_SNAPSHOT;\n\t\t \n\t\tdiag_register.requested_buffer_size = 2 * (1024 * 1024);\n\t\tdiag_register.unique_id = 0x7075901;\n\t\t_ctl_diag_register_2(ioc,  &diag_register);\n\t}\n\n\tif (bits_to_register & 4) {\n\t\tioc_info(ioc, \"registering extended buffer support\\n\");\n\t\tdiag_register.buffer_type = MPI2_DIAG_BUF_TYPE_EXTENDED;\n\t\t \n\t\tdiag_register.requested_buffer_size = 2 * (1024 * 1024);\n\t\tdiag_register.unique_id = 0x7075901;\n\t\t_ctl_diag_register_2(ioc,  &diag_register);\n\t}\n}\n\n \nstatic long\n_ctl_diag_register(struct MPT3SAS_ADAPTER *ioc, void __user *arg)\n{\n\tstruct mpt3_diag_register karg;\n\tlong rc;\n\n\tif (copy_from_user(&karg, arg, sizeof(karg))) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\n\trc = _ctl_diag_register_2(ioc, &karg);\n\n\tif (!rc && (ioc->diag_buffer_status[karg.buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_REGISTERED))\n\t\tioc->diag_buffer_status[karg.buffer_type] |=\n\t\t    MPT3_DIAG_BUFFER_IS_APP_OWNED;\n\n\treturn rc;\n}\n\n \nstatic long\n_ctl_diag_unregister(struct MPT3SAS_ADAPTER *ioc, void __user *arg)\n{\n\tstruct mpt3_diag_unregister karg;\n\tvoid *request_data;\n\tdma_addr_t request_data_dma;\n\tu32 request_data_sz;\n\tu8 buffer_type;\n\n\tif (copy_from_user(&karg, arg, sizeof(karg))) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, ioc_info(ioc, \"%s\\n\",\n\t\t\t\t __func__));\n\n\tbuffer_type = _ctl_diag_get_bufftype(ioc, karg.unique_id);\n\tif (buffer_type == MPT3_DIAG_UID_NOT_FOUND) {\n\t\tioc_err(ioc, \"%s: buffer with unique_id(0x%08x) not found\\n\",\n\t\t    __func__, karg.unique_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!_ctl_diag_capability(ioc, buffer_type)) {\n\t\tioc_err(ioc, \"%s: doesn't have capability for buffer_type(0x%02x)\\n\",\n\t\t\t__func__, buffer_type);\n\t\treturn -EPERM;\n\t}\n\n\tif ((ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0) {\n\t\tioc_err(ioc, \"%s: buffer_type(0x%02x) is not registered\\n\",\n\t\t\t__func__, buffer_type);\n\t\treturn -EINVAL;\n\t}\n\tif ((ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_RELEASED) == 0) {\n\t\tioc_err(ioc, \"%s: buffer_type(0x%02x) has not been released\\n\",\n\t\t\t__func__, buffer_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (karg.unique_id != ioc->unique_id[buffer_type]) {\n\t\tioc_err(ioc, \"%s: unique_id(0x%08x) is not registered\\n\",\n\t\t\t__func__, karg.unique_id);\n\t\treturn -EINVAL;\n\t}\n\n\trequest_data = ioc->diag_buffer[buffer_type];\n\tif (!request_data) {\n\t\tioc_err(ioc, \"%s: doesn't have memory allocated for buffer_type(0x%02x)\\n\",\n\t\t\t__func__, buffer_type);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_DRIVER_ALLOCATED) {\n\t\tioc->unique_id[buffer_type] = MPT3DIAGBUFFUNIQUEID;\n\t\tioc->diag_buffer_status[buffer_type] &=\n\t\t    ~MPT3_DIAG_BUFFER_IS_APP_OWNED;\n\t\tioc->diag_buffer_status[buffer_type] &=\n\t\t    ~MPT3_DIAG_BUFFER_IS_REGISTERED;\n\t} else {\n\t\trequest_data_sz = ioc->diag_buffer_sz[buffer_type];\n\t\trequest_data_dma = ioc->diag_buffer_dma[buffer_type];\n\t\tdma_free_coherent(&ioc->pdev->dev, request_data_sz,\n\t\t\t\trequest_data, request_data_dma);\n\t\tioc->diag_buffer[buffer_type] = NULL;\n\t\tioc->diag_buffer_status[buffer_type] = 0;\n\t}\n\treturn 0;\n}\n\n \nstatic long\n_ctl_diag_query(struct MPT3SAS_ADAPTER *ioc, void __user *arg)\n{\n\tstruct mpt3_diag_query karg;\n\tvoid *request_data;\n\tint i;\n\tu8 buffer_type;\n\n\tif (copy_from_user(&karg, arg, sizeof(karg))) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, ioc_info(ioc, \"%s\\n\",\n\t\t\t\t __func__));\n\n\tkarg.application_flags = 0;\n\tbuffer_type = karg.buffer_type;\n\n\tif (!_ctl_diag_capability(ioc, buffer_type)) {\n\t\tioc_err(ioc, \"%s: doesn't have capability for buffer_type(0x%02x)\\n\",\n\t\t\t__func__, buffer_type);\n\t\treturn -EPERM;\n\t}\n\n\tif (!(ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_DRIVER_ALLOCATED)) {\n\t\tif ((ioc->diag_buffer_status[buffer_type] &\n\t\t    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0) {\n\t\t\tioc_err(ioc, \"%s: buffer_type(0x%02x) is not registered\\n\",\n\t\t\t\t__func__, buffer_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (karg.unique_id) {\n\t\tif (karg.unique_id != ioc->unique_id[buffer_type]) {\n\t\t\tioc_err(ioc, \"%s: unique_id(0x%08x) is not registered\\n\",\n\t\t\t\t__func__, karg.unique_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\trequest_data = ioc->diag_buffer[buffer_type];\n\tif (!request_data) {\n\t\tioc_err(ioc, \"%s: doesn't have buffer for buffer_type(0x%02x)\\n\",\n\t\t\t__func__, buffer_type);\n\t\treturn -ENOMEM;\n\t}\n\n\tif ((ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_REGISTERED))\n\t\tkarg.application_flags |= MPT3_APP_FLAGS_BUFFER_VALID;\n\n\tif (!(ioc->diag_buffer_status[buffer_type] &\n\t     MPT3_DIAG_BUFFER_IS_RELEASED))\n\t\tkarg.application_flags |= MPT3_APP_FLAGS_FW_BUFFER_ACCESS;\n\n\tif (!(ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_DRIVER_ALLOCATED))\n\t\tkarg.application_flags |= MPT3_APP_FLAGS_DYNAMIC_BUFFER_ALLOC;\n\n\tif ((ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_APP_OWNED))\n\t\tkarg.application_flags |= MPT3_APP_FLAGS_APP_OWNED;\n\n\tfor (i = 0; i < MPT3_PRODUCT_SPECIFIC_DWORDS; i++)\n\t\tkarg.product_specific[i] =\n\t\t    ioc->product_specific[buffer_type][i];\n\n\tkarg.total_buffer_size = ioc->diag_buffer_sz[buffer_type];\n\tkarg.driver_added_buffer_size = 0;\n\tkarg.unique_id = ioc->unique_id[buffer_type];\n\tkarg.diagnostic_flags = ioc->diagnostic_flags[buffer_type];\n\n\tif (copy_to_user(arg, &karg, sizeof(struct mpt3_diag_query))) {\n\t\tioc_err(ioc, \"%s: unable to write mpt3_diag_query data @ %p\\n\",\n\t\t\t__func__, arg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n \nint\nmpt3sas_send_diag_release(struct MPT3SAS_ADAPTER *ioc, u8 buffer_type,\n\tu8 *issue_reset)\n{\n\tMpi2DiagReleaseRequest_t *mpi_request;\n\tMpi2DiagReleaseReply_t *mpi_reply;\n\tu16 smid;\n\tu16 ioc_status;\n\tu32 ioc_state;\n\tint rc;\n\tu8 reset_needed = 0;\n\n\tdctlprintk(ioc, ioc_info(ioc, \"%s\\n\",\n\t\t\t\t __func__));\n\n\trc = 0;\n\t*issue_reset = 0;\n\n\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 1);\n\tif (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\n\t\tif (ioc->diag_buffer_status[buffer_type] &\n\t\t    MPT3_DIAG_BUFFER_IS_REGISTERED)\n\t\t\tioc->diag_buffer_status[buffer_type] |=\n\t\t\t    MPT3_DIAG_BUFFER_IS_RELEASED;\n\t\tdctlprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: skipping due to FAULT state\\n\",\n\t\t\t\t    __func__));\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (ioc->ctl_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: ctl_cmd in use\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->ctl_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tioc->ctl_cmds.status = MPT3_CMD_PENDING;\n\tmemset(ioc->ctl_cmds.reply, 0, ioc->reply_sz);\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(mpi_request, 0, ioc->request_sz);\n\tioc->ctl_cmds.smid = smid;\n\n\tmpi_request->Function = MPI2_FUNCTION_DIAG_RELEASE;\n\tmpi_request->BufferType = buffer_type;\n\tmpi_request->VF_ID = 0;  \n\tmpi_request->VP_ID = 0;\n\n\tinit_completion(&ioc->ctl_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->ctl_cmds.done,\n\t    MPT3_IOCTL_DEFAULT_TIMEOUT*HZ);\n\n\tif (!(ioc->ctl_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tmpt3sas_check_cmd_timeout(ioc,\n\t\t    ioc->ctl_cmds.status, mpi_request,\n\t\t    sizeof(Mpi2DiagReleaseRequest_t)/4, reset_needed);\n\t\t*issue_reset = reset_needed;\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((ioc->ctl_cmds.status & MPT3_CMD_REPLY_VALID) == 0) {\n\t\tioc_err(ioc, \"%s: no reply message\\n\", __func__);\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tmpi_reply = ioc->ctl_cmds.reply;\n\tioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;\n\n\tif (ioc_status == MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc->diag_buffer_status[buffer_type] |=\n\t\t    MPT3_DIAG_BUFFER_IS_RELEASED;\n\t\tdctlprintk(ioc, ioc_info(ioc, \"%s: success\\n\", __func__));\n\t} else {\n\t\tioc_info(ioc, \"%s: ioc_status(0x%04x) log_info(0x%08x)\\n\",\n\t\t\t __func__,\n\t\t\t ioc_status, le32_to_cpu(mpi_reply->IOCLogInfo));\n\t\trc = -EFAULT;\n\t}\n\n out:\n\tioc->ctl_cmds.status = MPT3_CMD_NOT_USED;\n\treturn rc;\n}\n\n \nstatic long\n_ctl_diag_release(struct MPT3SAS_ADAPTER *ioc, void __user *arg)\n{\n\tstruct mpt3_diag_release karg;\n\tvoid *request_data;\n\tint rc;\n\tu8 buffer_type;\n\tu8 issue_reset = 0;\n\n\tif (copy_from_user(&karg, arg, sizeof(karg))) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, ioc_info(ioc, \"%s\\n\",\n\t\t\t\t __func__));\n\n\tbuffer_type = _ctl_diag_get_bufftype(ioc, karg.unique_id);\n\tif (buffer_type == MPT3_DIAG_UID_NOT_FOUND) {\n\t\tioc_err(ioc, \"%s: buffer with unique_id(0x%08x) not found\\n\",\n\t\t    __func__, karg.unique_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!_ctl_diag_capability(ioc, buffer_type)) {\n\t\tioc_err(ioc, \"%s: doesn't have capability for buffer_type(0x%02x)\\n\",\n\t\t\t__func__, buffer_type);\n\t\treturn -EPERM;\n\t}\n\n\tif ((ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0) {\n\t\tioc_err(ioc, \"%s: buffer_type(0x%02x) is not registered\\n\",\n\t\t\t__func__, buffer_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (karg.unique_id != ioc->unique_id[buffer_type]) {\n\t\tioc_err(ioc, \"%s: unique_id(0x%08x) is not registered\\n\",\n\t\t\t__func__, karg.unique_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_RELEASED) {\n\t\tioc_err(ioc, \"%s: buffer_type(0x%02x) is already released\\n\",\n\t\t\t__func__, buffer_type);\n\t\treturn -EINVAL;\n\t}\n\n\trequest_data = ioc->diag_buffer[buffer_type];\n\n\tif (!request_data) {\n\t\tioc_err(ioc, \"%s: doesn't have memory allocated for buffer_type(0x%02x)\\n\",\n\t\t\t__func__, buffer_type);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif ((ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_DIAG_RESET)) {\n\t\tioc->diag_buffer_status[buffer_type] |=\n\t\t    MPT3_DIAG_BUFFER_IS_RELEASED;\n\t\tioc->diag_buffer_status[buffer_type] &=\n\t\t    ~MPT3_DIAG_BUFFER_IS_DIAG_RESET;\n\t\tioc_err(ioc, \"%s: buffer_type(0x%02x) was released due to host reset\\n\",\n\t\t\t__func__, buffer_type);\n\t\treturn 0;\n\t}\n\n\trc = mpt3sas_send_diag_release(ioc, buffer_type, &issue_reset);\n\n\tif (issue_reset)\n\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\n\treturn rc;\n}\n\n \nstatic long\n_ctl_diag_read_buffer(struct MPT3SAS_ADAPTER *ioc, void __user *arg)\n{\n\tstruct mpt3_diag_read_buffer karg;\n\tstruct mpt3_diag_read_buffer __user *uarg = arg;\n\tvoid *request_data, *diag_data;\n\tMpi2DiagBufferPostRequest_t *mpi_request;\n\tMpi2DiagBufferPostReply_t *mpi_reply;\n\tint rc, i;\n\tu8 buffer_type;\n\tunsigned long request_size, copy_size;\n\tu16 smid;\n\tu16 ioc_status;\n\tu8 issue_reset = 0;\n\n\tif (copy_from_user(&karg, arg, sizeof(karg))) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, ioc_info(ioc, \"%s\\n\",\n\t\t\t\t __func__));\n\n\tbuffer_type = _ctl_diag_get_bufftype(ioc, karg.unique_id);\n\tif (buffer_type == MPT3_DIAG_UID_NOT_FOUND) {\n\t\tioc_err(ioc, \"%s: buffer with unique_id(0x%08x) not found\\n\",\n\t\t    __func__, karg.unique_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!_ctl_diag_capability(ioc, buffer_type)) {\n\t\tioc_err(ioc, \"%s: doesn't have capability for buffer_type(0x%02x)\\n\",\n\t\t\t__func__, buffer_type);\n\t\treturn -EPERM;\n\t}\n\n\tif (karg.unique_id != ioc->unique_id[buffer_type]) {\n\t\tioc_err(ioc, \"%s: unique_id(0x%08x) is not registered\\n\",\n\t\t\t__func__, karg.unique_id);\n\t\treturn -EINVAL;\n\t}\n\n\trequest_data = ioc->diag_buffer[buffer_type];\n\tif (!request_data) {\n\t\tioc_err(ioc, \"%s: doesn't have buffer for buffer_type(0x%02x)\\n\",\n\t\t\t__func__, buffer_type);\n\t\treturn -ENOMEM;\n\t}\n\n\trequest_size = ioc->diag_buffer_sz[buffer_type];\n\n\tif ((karg.starting_offset % 4) || (karg.bytes_to_read % 4)) {\n\t\tioc_err(ioc, \"%s: either the starting_offset or bytes_to_read are not 4 byte aligned\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (karg.starting_offset > request_size)\n\t\treturn -EINVAL;\n\n\tdiag_data = (void *)(request_data + karg.starting_offset);\n\tdctlprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: diag_buffer(%p), offset(%d), sz(%d)\\n\",\n\t\t\t    __func__, diag_data, karg.starting_offset,\n\t\t\t    karg.bytes_to_read));\n\n\t \n\tif ((diag_data + karg.bytes_to_read < diag_data) ||\n\t    (diag_data + karg.bytes_to_read > request_data + request_size))\n\t\tcopy_size = request_size - karg.starting_offset;\n\telse\n\t\tcopy_size = karg.bytes_to_read;\n\n\tif (copy_to_user((void __user *)uarg->diagnostic_data,\n\t    diag_data, copy_size)) {\n\t\tioc_err(ioc, \"%s: Unable to write mpt_diag_read_buffer_t data @ %p\\n\",\n\t\t\t__func__, diag_data);\n\t\treturn -EFAULT;\n\t}\n\n\tif ((karg.flags & MPT3_FLAGS_REREGISTER) == 0)\n\t\treturn 0;\n\n\tdctlprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: Reregister buffer_type(0x%02x)\\n\",\n\t\t\t    __func__, buffer_type));\n\tif ((ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_RELEASED) == 0) {\n\t\tdctlprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: buffer_type(0x%02x) is still registered\\n\",\n\t\t\t\t    __func__, buffer_type));\n\t\treturn 0;\n\t}\n\t \n\n\tif (ioc->ctl_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: ctl_cmd in use\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->ctl_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\tioc->ctl_cmds.status = MPT3_CMD_PENDING;\n\tmemset(ioc->ctl_cmds.reply, 0, ioc->reply_sz);\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(mpi_request, 0, ioc->request_sz);\n\tioc->ctl_cmds.smid = smid;\n\n\tmpi_request->Function = MPI2_FUNCTION_DIAG_BUFFER_POST;\n\tmpi_request->BufferType = buffer_type;\n\tmpi_request->BufferLength =\n\t    cpu_to_le32(ioc->diag_buffer_sz[buffer_type]);\n\tmpi_request->BufferAddress =\n\t    cpu_to_le64(ioc->diag_buffer_dma[buffer_type]);\n\tfor (i = 0; i < MPT3_PRODUCT_SPECIFIC_DWORDS; i++)\n\t\tmpi_request->ProductSpecific[i] =\n\t\t\tcpu_to_le32(ioc->product_specific[buffer_type][i]);\n\tmpi_request->VF_ID = 0;  \n\tmpi_request->VP_ID = 0;\n\n\tinit_completion(&ioc->ctl_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->ctl_cmds.done,\n\t    MPT3_IOCTL_DEFAULT_TIMEOUT*HZ);\n\n\tif (!(ioc->ctl_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tmpt3sas_check_cmd_timeout(ioc,\n\t\t    ioc->ctl_cmds.status, mpi_request,\n\t\t    sizeof(Mpi2DiagBufferPostRequest_t)/4, issue_reset);\n\t\tgoto issue_host_reset;\n\t}\n\n\t \n\tif ((ioc->ctl_cmds.status & MPT3_CMD_REPLY_VALID) == 0) {\n\t\tioc_err(ioc, \"%s: no reply message\\n\", __func__);\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tmpi_reply = ioc->ctl_cmds.reply;\n\tioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;\n\n\tif (ioc_status == MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc->diag_buffer_status[buffer_type] |=\n\t\t    MPT3_DIAG_BUFFER_IS_REGISTERED;\n\t\tioc->diag_buffer_status[buffer_type] &=\n\t\t    ~MPT3_DIAG_BUFFER_IS_RELEASED;\n\t\tdctlprintk(ioc, ioc_info(ioc, \"%s: success\\n\", __func__));\n\t} else {\n\t\tioc_info(ioc, \"%s: ioc_status(0x%04x) log_info(0x%08x)\\n\",\n\t\t\t __func__, ioc_status,\n\t\t\t le32_to_cpu(mpi_reply->IOCLogInfo));\n\t\trc = -EFAULT;\n\t}\n\n issue_host_reset:\n\tif (issue_reset)\n\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\n out:\n\n\tioc->ctl_cmds.status = MPT3_CMD_NOT_USED;\n\treturn rc;\n}\n\n \nstatic long\n_ctl_addnl_diag_query(struct MPT3SAS_ADAPTER *ioc, void __user *arg)\n{\n\tstruct mpt3_addnl_diag_query karg;\n\tu32 buffer_type = 0;\n\n\tif (copy_from_user(&karg, arg, sizeof(karg))) {\n\t\tpr_err(\"%s: failure at %s:%d/%s()!\\n\",\n\t\t    ioc->name, __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\tdctlprintk(ioc, ioc_info(ioc, \"%s\\n\",  __func__));\n\tif (karg.unique_id == 0) {\n\t\tioc_err(ioc, \"%s: unique_id is(0x%08x)\\n\",\n\t\t    __func__, karg.unique_id);\n\t\treturn -EPERM;\n\t}\n\tbuffer_type = _ctl_diag_get_bufftype(ioc, karg.unique_id);\n\tif (buffer_type == MPT3_DIAG_UID_NOT_FOUND) {\n\t\tioc_err(ioc, \"%s: buffer with unique_id(0x%08x) not found\\n\",\n\t\t    __func__, karg.unique_id);\n\t\treturn -EPERM;\n\t}\n\tmemset(&karg.rel_query, 0, sizeof(karg.rel_query));\n\tif ((ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0) {\n\t\tioc_info(ioc, \"%s: buffer_type(0x%02x) is not registered\\n\",\n\t\t    __func__, buffer_type);\n\t\tgoto out;\n\t}\n\tif ((ioc->diag_buffer_status[buffer_type] &\n\t    MPT3_DIAG_BUFFER_IS_RELEASED) == 0) {\n\t\tioc_err(ioc, \"%s: buffer_type(0x%02x) is not released\\n\",\n\t\t    __func__, buffer_type);\n\t\treturn -EPERM;\n\t}\n\tmemcpy(&karg.rel_query, &ioc->htb_rel, sizeof(karg.rel_query));\nout:\n\tif (copy_to_user(arg, &karg, sizeof(struct mpt3_addnl_diag_query))) {\n\t\tioc_err(ioc, \"%s: unable to write mpt3_addnl_diag_query data @ %p\\n\",\n\t\t    __func__, arg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_COMPAT\n \nstatic long\n_ctl_compat_mpt_command(struct MPT3SAS_ADAPTER *ioc, unsigned cmd,\n\tvoid __user *arg)\n{\n\tstruct mpt3_ioctl_command32 karg32;\n\tstruct mpt3_ioctl_command32 __user *uarg;\n\tstruct mpt3_ioctl_command karg;\n\n\tif (_IOC_SIZE(cmd) != sizeof(struct mpt3_ioctl_command32))\n\t\treturn -EINVAL;\n\n\tuarg = (struct mpt3_ioctl_command32 __user *) arg;\n\n\tif (copy_from_user(&karg32, (char __user *)arg, sizeof(karg32))) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tmemset(&karg, 0, sizeof(struct mpt3_ioctl_command));\n\tkarg.hdr.ioc_number = karg32.hdr.ioc_number;\n\tkarg.hdr.port_number = karg32.hdr.port_number;\n\tkarg.hdr.max_data_size = karg32.hdr.max_data_size;\n\tkarg.timeout = karg32.timeout;\n\tkarg.max_reply_bytes = karg32.max_reply_bytes;\n\tkarg.data_in_size = karg32.data_in_size;\n\tkarg.data_out_size = karg32.data_out_size;\n\tkarg.max_sense_bytes = karg32.max_sense_bytes;\n\tkarg.data_sge_offset = karg32.data_sge_offset;\n\tkarg.reply_frame_buf_ptr = compat_ptr(karg32.reply_frame_buf_ptr);\n\tkarg.data_in_buf_ptr = compat_ptr(karg32.data_in_buf_ptr);\n\tkarg.data_out_buf_ptr = compat_ptr(karg32.data_out_buf_ptr);\n\tkarg.sense_data_ptr = compat_ptr(karg32.sense_data_ptr);\n\treturn _ctl_do_mpt_command(ioc, karg, &uarg->mf);\n}\n#endif\n\n \nstatic long\n_ctl_ioctl_main(struct file *file, unsigned int cmd, void __user *arg,\n\tu8 compat, u16 mpi_version)\n{\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tstruct mpt3_ioctl_header ioctl_header;\n\tenum block_state state;\n\tlong ret = -ENOIOCTLCMD;\n\n\t \n\tif (copy_from_user(&ioctl_header, (char __user *)arg,\n\t    sizeof(struct mpt3_ioctl_header))) {\n\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tif (_ctl_verify_adapter(ioctl_header.ioc_number,\n\t\t\t\t&ioc, mpi_version) == -1 || !ioc)\n\t\treturn -ENODEV;\n\n\t \n\tmutex_lock(&ioc->pci_access_mutex);\n\n\tif (ioc->shost_recovery || ioc->pci_error_recovery ||\n\t    ioc->is_driver_loading || ioc->remove_host) {\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock_pciaccess;\n\t}\n\n\tstate = (file->f_flags & O_NONBLOCK) ? NON_BLOCKING : BLOCKING;\n\tif (state == NON_BLOCKING) {\n\t\tif (!mutex_trylock(&ioc->ctl_cmds.mutex)) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock_pciaccess;\n\t\t}\n\t} else if (mutex_lock_interruptible(&ioc->ctl_cmds.mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_unlock_pciaccess;\n\t}\n\n\n\tswitch (cmd) {\n\tcase MPT3IOCINFO:\n\t\tif (_IOC_SIZE(cmd) == sizeof(struct mpt3_ioctl_iocinfo))\n\t\t\tret = _ctl_getiocinfo(ioc, arg);\n\t\tbreak;\n#ifdef CONFIG_COMPAT\n\tcase MPT3COMMAND32:\n#endif\n\tcase MPT3COMMAND:\n\t{\n\t\tstruct mpt3_ioctl_command __user *uarg;\n\t\tstruct mpt3_ioctl_command karg;\n\n#ifdef CONFIG_COMPAT\n\t\tif (compat) {\n\t\t\tret = _ctl_compat_mpt_command(ioc, cmd, arg);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tif (copy_from_user(&karg, arg, sizeof(karg))) {\n\t\t\tpr_err(\"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (karg.hdr.ioc_number != ioctl_header.ioc_number) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (_IOC_SIZE(cmd) == sizeof(struct mpt3_ioctl_command)) {\n\t\t\tuarg = arg;\n\t\t\tret = _ctl_do_mpt_command(ioc, karg, &uarg->mf);\n\t\t}\n\t\tbreak;\n\t}\n\tcase MPT3EVENTQUERY:\n\t\tif (_IOC_SIZE(cmd) == sizeof(struct mpt3_ioctl_eventquery))\n\t\t\tret = _ctl_eventquery(ioc, arg);\n\t\tbreak;\n\tcase MPT3EVENTENABLE:\n\t\tif (_IOC_SIZE(cmd) == sizeof(struct mpt3_ioctl_eventenable))\n\t\t\tret = _ctl_eventenable(ioc, arg);\n\t\tbreak;\n\tcase MPT3EVENTREPORT:\n\t\tret = _ctl_eventreport(ioc, arg);\n\t\tbreak;\n\tcase MPT3HARDRESET:\n\t\tif (_IOC_SIZE(cmd) == sizeof(struct mpt3_ioctl_diag_reset))\n\t\t\tret = _ctl_do_reset(ioc, arg);\n\t\tbreak;\n\tcase MPT3BTDHMAPPING:\n\t\tif (_IOC_SIZE(cmd) == sizeof(struct mpt3_ioctl_btdh_mapping))\n\t\t\tret = _ctl_btdh_mapping(ioc, arg);\n\t\tbreak;\n\tcase MPT3DIAGREGISTER:\n\t\tif (_IOC_SIZE(cmd) == sizeof(struct mpt3_diag_register))\n\t\t\tret = _ctl_diag_register(ioc, arg);\n\t\tbreak;\n\tcase MPT3DIAGUNREGISTER:\n\t\tif (_IOC_SIZE(cmd) == sizeof(struct mpt3_diag_unregister))\n\t\t\tret = _ctl_diag_unregister(ioc, arg);\n\t\tbreak;\n\tcase MPT3DIAGQUERY:\n\t\tif (_IOC_SIZE(cmd) == sizeof(struct mpt3_diag_query))\n\t\t\tret = _ctl_diag_query(ioc, arg);\n\t\tbreak;\n\tcase MPT3DIAGRELEASE:\n\t\tif (_IOC_SIZE(cmd) == sizeof(struct mpt3_diag_release))\n\t\t\tret = _ctl_diag_release(ioc, arg);\n\t\tbreak;\n\tcase MPT3DIAGREADBUFFER:\n\t\tif (_IOC_SIZE(cmd) == sizeof(struct mpt3_diag_read_buffer))\n\t\t\tret = _ctl_diag_read_buffer(ioc, arg);\n\t\tbreak;\n\tcase MPT3ADDNLDIAGQUERY:\n\t\tif (_IOC_SIZE(cmd) == sizeof(struct mpt3_addnl_diag_query))\n\t\t\tret = _ctl_addnl_diag_query(ioc, arg);\n\t\tbreak;\n\tdefault:\n\t\tdctlprintk(ioc,\n\t\t\t   ioc_info(ioc, \"unsupported ioctl opcode(0x%08x)\\n\",\n\t\t\t\t    cmd));\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&ioc->ctl_cmds.mutex);\nout_unlock_pciaccess:\n\tmutex_unlock(&ioc->pci_access_mutex);\n\treturn ret;\n}\n\n \nstatic long\n_ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong ret;\n\n\t \n\tret = _ctl_ioctl_main(file, cmd, (void __user *)arg, 0,\n\t\tMPI25_VERSION | MPI26_VERSION);\n\treturn ret;\n}\n\n \nstatic long\n_ctl_mpt2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong ret;\n\n\t \n\tret = _ctl_ioctl_main(file, cmd, (void __user *)arg, 0, MPI2_VERSION);\n\treturn ret;\n}\n#ifdef CONFIG_COMPAT\n \nstatic long\n_ctl_ioctl_compat(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tlong ret;\n\n\tret = _ctl_ioctl_main(file, cmd, (void __user *)arg, 1,\n\t\tMPI25_VERSION | MPI26_VERSION);\n\treturn ret;\n}\n\n \nstatic long\n_ctl_mpt2_ioctl_compat(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tlong ret;\n\n\tret = _ctl_ioctl_main(file, cmd, (void __user *)arg, 1, MPI2_VERSION);\n\treturn ret;\n}\n#endif\n\n \n \nstatic ssize_t\nversion_fw_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%02d.%02d.%02d.%02d\\n\",\n\t    (ioc->facts.FWVersion.Word & 0xFF000000) >> 24,\n\t    (ioc->facts.FWVersion.Word & 0x00FF0000) >> 16,\n\t    (ioc->facts.FWVersion.Word & 0x0000FF00) >> 8,\n\t    ioc->facts.FWVersion.Word & 0x000000FF);\n}\nstatic DEVICE_ATTR_RO(version_fw);\n\n \nstatic ssize_t\nversion_bios_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\tu32 version = le32_to_cpu(ioc->bios_pg3.BiosVersion);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%02d.%02d.%02d.%02d\\n\",\n\t    (version & 0xFF000000) >> 24,\n\t    (version & 0x00FF0000) >> 16,\n\t    (version & 0x0000FF00) >> 8,\n\t    version & 0x000000FF);\n}\nstatic DEVICE_ATTR_RO(version_bios);\n\n \nstatic ssize_t\nversion_mpi_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%03x.%02x\\n\",\n\t    ioc->facts.MsgVersion, ioc->facts.HeaderVersion >> 8);\n}\nstatic DEVICE_ATTR_RO(version_mpi);\n\n \nstatic ssize_t\nversion_product_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, 16, \"%s\\n\", ioc->manu_pg0.ChipName);\n}\nstatic DEVICE_ATTR_RO(version_product);\n\n \nstatic ssize_t\nversion_nvdata_persistent_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%08xh\\n\",\n\t    le32_to_cpu(ioc->iounit_pg0.NvdataVersionPersistent.Word));\n}\nstatic DEVICE_ATTR_RO(version_nvdata_persistent);\n\n \nstatic ssize_t\nversion_nvdata_default_show(struct device *cdev, struct device_attribute\n\t*attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%08xh\\n\",\n\t    le32_to_cpu(ioc->iounit_pg0.NvdataVersionDefault.Word));\n}\nstatic DEVICE_ATTR_RO(version_nvdata_default);\n\n \nstatic ssize_t\nboard_name_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, 16, \"%s\\n\", ioc->manu_pg0.BoardName);\n}\nstatic DEVICE_ATTR_RO(board_name);\n\n \nstatic ssize_t\nboard_assembly_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, 16, \"%s\\n\", ioc->manu_pg0.BoardAssembly);\n}\nstatic DEVICE_ATTR_RO(board_assembly);\n\n \nstatic ssize_t\nboard_tracer_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, 16, \"%s\\n\", ioc->manu_pg0.BoardTracerNumber);\n}\nstatic DEVICE_ATTR_RO(board_tracer);\n\n \nstatic ssize_t\nio_delay_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%02d\\n\", ioc->io_missing_delay);\n}\nstatic DEVICE_ATTR_RO(io_delay);\n\n \nstatic ssize_t\ndevice_delay_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%02d\\n\", ioc->device_missing_delay);\n}\nstatic DEVICE_ATTR_RO(device_delay);\n\n \nstatic ssize_t\nfw_queue_depth_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%02d\\n\", ioc->facts.RequestCredit);\n}\nstatic DEVICE_ATTR_RO(fw_queue_depth);\n\n \nstatic ssize_t\nhost_sas_address_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"0x%016llx\\n\",\n\t    (unsigned long long)ioc->sas_hba.sas_address);\n}\nstatic DEVICE_ATTR_RO(host_sas_address);\n\n \nstatic ssize_t\nlogging_level_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%08xh\\n\", ioc->logging_level);\n}\nstatic ssize_t\nlogging_level_store(struct device *cdev, struct device_attribute *attr,\n\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tint val = 0;\n\n\tif (sscanf(buf, \"%x\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tioc->logging_level = val;\n\tioc_info(ioc, \"logging_level=%08xh\\n\",\n\t\t ioc->logging_level);\n\treturn strlen(buf);\n}\nstatic DEVICE_ATTR_RW(logging_level);\n\n \nstatic ssize_t\nfwfault_debug_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", ioc->fwfault_debug);\n}\nstatic ssize_t\nfwfault_debug_store(struct device *cdev, struct device_attribute *attr,\n\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tint val = 0;\n\n\tif (sscanf(buf, \"%d\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tioc->fwfault_debug = val;\n\tioc_info(ioc, \"fwfault_debug=%d\\n\",\n\t\t ioc->fwfault_debug);\n\treturn strlen(buf);\n}\nstatic DEVICE_ATTR_RW(fwfault_debug);\n\n \nstatic ssize_t\nioc_reset_count_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", ioc->ioc_reset_count);\n}\nstatic DEVICE_ATTR_RO(ioc_reset_count);\n\n \nstatic ssize_t\nreply_queue_count_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tu8 reply_queue_count;\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\tif ((ioc->facts.IOCCapabilities &\n\t    MPI2_IOCFACTS_CAPABILITY_MSI_X_INDEX) && ioc->msix_enable)\n\t\treply_queue_count = ioc->reply_queue_count;\n\telse\n\t\treply_queue_count = 1;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", reply_queue_count);\n}\nstatic DEVICE_ATTR_RO(reply_queue_count);\n\n \nstatic ssize_t\nBRM_status_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tMpi2IOUnitPage3_t io_unit_pg3;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 backup_rail_monitor_status = 0;\n\tu16 ioc_status;\n\tint sz;\n\tssize_t rc = 0;\n\n\tif (!ioc->is_warpdrive) {\n\t\tioc_err(ioc, \"%s: BRM attribute is only for warpdrive\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\t \n\tmutex_lock(&ioc->pci_access_mutex);\n\tif (ioc->pci_error_recovery || ioc->remove_host)\n\t\tgoto out;\n\n\tsz = sizeof(io_unit_pg3);\n\tmemset(&io_unit_pg3, 0, sz);\n\n\tif (mpt3sas_config_get_iounit_pg3(ioc, &mpi_reply, &io_unit_pg3, sz) !=\n\t    0) {\n\t\tioc_err(ioc, \"%s: failed reading iounit_pg3\\n\",\n\t\t\t__func__);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"%s: iounit_pg3 failed with ioc_status(0x%04x)\\n\",\n\t\t\t__func__, ioc_status);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (io_unit_pg3.GPIOCount < 25) {\n\t\tioc_err(ioc, \"%s: iounit_pg3.GPIOCount less than 25 entries, detected (%d) entries\\n\",\n\t\t\t__func__, io_unit_pg3.GPIOCount);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tbackup_rail_monitor_status = le16_to_cpu(io_unit_pg3.GPIOVal[24]);\n\trc = snprintf(buf, PAGE_SIZE, \"%d\\n\", (backup_rail_monitor_status & 1));\n\n out:\n\tmutex_unlock(&ioc->pci_access_mutex);\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(BRM_status);\n\nstruct DIAG_BUFFER_START {\n\t__le32\tSize;\n\t__le32\tDiagVersion;\n\tu8\tBufferType;\n\tu8\tReserved[3];\n\t__le32\tReserved1;\n\t__le32\tReserved2;\n\t__le32\tReserved3;\n};\n\n \nstatic ssize_t\nhost_trace_buffer_size_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tu32 size = 0;\n\tstruct DIAG_BUFFER_START *request_data;\n\n\tif (!ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE]) {\n\t\tioc_err(ioc, \"%s: host_trace_buffer is not registered\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\n\tif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0) {\n\t\tioc_err(ioc, \"%s: host_trace_buffer is not registered\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\n\trequest_data = (struct DIAG_BUFFER_START *)\n\t    ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE];\n\tif ((le32_to_cpu(request_data->DiagVersion) == 0x00000000 ||\n\t    le32_to_cpu(request_data->DiagVersion) == 0x01000000 ||\n\t    le32_to_cpu(request_data->DiagVersion) == 0x01010000) &&\n\t    le32_to_cpu(request_data->Reserved3) == 0x4742444c)\n\t\tsize = le32_to_cpu(request_data->Size);\n\n\tioc->ring_buffer_sz = size;\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", size);\n}\nstatic DEVICE_ATTR_RO(host_trace_buffer_size);\n\n \nstatic ssize_t\nhost_trace_buffer_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tvoid *request_data;\n\tu32 size;\n\n\tif (!ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE]) {\n\t\tioc_err(ioc, \"%s: host_trace_buffer is not registered\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\n\tif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0) {\n\t\tioc_err(ioc, \"%s: host_trace_buffer is not registered\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\n\tif (ioc->ring_buffer_offset > ioc->ring_buffer_sz)\n\t\treturn 0;\n\n\tsize = ioc->ring_buffer_sz - ioc->ring_buffer_offset;\n\tsize = (size >= PAGE_SIZE) ? (PAGE_SIZE - 1) : size;\n\trequest_data = ioc->diag_buffer[0] + ioc->ring_buffer_offset;\n\tmemcpy(buf, request_data, size);\n\treturn size;\n}\n\nstatic ssize_t\nhost_trace_buffer_store(struct device *cdev, struct device_attribute *attr,\n\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tint val = 0;\n\n\tif (sscanf(buf, \"%d\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tioc->ring_buffer_offset = val;\n\treturn strlen(buf);\n}\nstatic DEVICE_ATTR_RW(host_trace_buffer);\n\n\n \n\n \nstatic ssize_t\nhost_trace_buffer_enable_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\tif ((!ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE]) ||\n\t   ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0))\n\t\treturn snprintf(buf, PAGE_SIZE, \"off\\n\");\n\telse if ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_RELEASED))\n\t\treturn snprintf(buf, PAGE_SIZE, \"release\\n\");\n\telse\n\t\treturn snprintf(buf, PAGE_SIZE, \"post\\n\");\n}\n\nstatic ssize_t\nhost_trace_buffer_enable_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tchar str[10] = \"\";\n\tstruct mpt3_diag_register diag_register;\n\tu8 issue_reset = 0;\n\n\t \n\tif (ioc->shost_recovery || ioc->remove_host ||\n\t    ioc->pci_error_recovery || ioc->is_driver_loading)\n\t\treturn -EBUSY;\n\n\tif (sscanf(buf, \"%9s\", str) != 1)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(str, \"post\")) {\n\t\t \n\t\tif ((ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE]) &&\n\t\t    (ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t\t    MPT3_DIAG_BUFFER_IS_REGISTERED) &&\n\t\t    ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t\t    MPT3_DIAG_BUFFER_IS_RELEASED) == 0))\n\t\t\tgoto out;\n\t\tmemset(&diag_register, 0, sizeof(struct mpt3_diag_register));\n\t\tioc_info(ioc, \"posting host trace buffers\\n\");\n\t\tdiag_register.buffer_type = MPI2_DIAG_BUF_TYPE_TRACE;\n\n\t\tif (ioc->manu_pg11.HostTraceBufferMaxSizeKB != 0 &&\n\t\t    ioc->diag_buffer_sz[MPI2_DIAG_BUF_TYPE_TRACE] != 0) {\n\t\t\t \n\t\t\tdiag_register.requested_buffer_size =\n\t\t\t    ioc->diag_buffer_sz[MPI2_DIAG_BUF_TYPE_TRACE];\n\t\t} else {\n\t\t\t \n\t\t\tif ((ioc->diag_buffer_sz[MPI2_DIAG_BUF_TYPE_TRACE] != 0)\n\t\t\t    &&\n\t\t\t    (ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t\t\t    MPT3_DIAG_BUFFER_IS_APP_OWNED)) {\n\t\t\t\tdma_free_coherent(&ioc->pdev->dev,\n\t\t\t\t\t\t  ioc->diag_buffer_sz[MPI2_DIAG_BUF_TYPE_TRACE],\n\t\t\t\t\t\t  ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE],\n\t\t\t\t\t\t  ioc->diag_buffer_dma[MPI2_DIAG_BUF_TYPE_TRACE]);\n\t\t\t\tioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE] =\n\t\t\t\t    NULL;\n\t\t\t}\n\n\t\t\tdiag_register.requested_buffer_size = (1024 * 1024);\n\t\t}\n\n\t\tdiag_register.unique_id =\n\t\t    (ioc->hba_mpi_version_belonged == MPI2_VERSION) ?\n\t\t    (MPT2DIAGBUFFUNIQUEID):(MPT3DIAGBUFFUNIQUEID);\n\t\tioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] = 0;\n\t\t_ctl_diag_register_2(ioc,  &diag_register);\n\t\tif (ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t\t    MPT3_DIAG_BUFFER_IS_REGISTERED) {\n\t\t\tioc_info(ioc,\n\t\t\t    \"Trace buffer %d KB allocated through sysfs\\n\",\n\t\t\t    diag_register.requested_buffer_size>>10);\n\t\t\tif (ioc->hba_mpi_version_belonged != MPI2_VERSION)\n\t\t\t\tioc->diag_buffer_status[\n\t\t\t\t    MPI2_DIAG_BUF_TYPE_TRACE] |=\n\t\t\t\t    MPT3_DIAG_BUFFER_IS_DRIVER_ALLOCATED;\n\t\t}\n\t} else if (!strcmp(str, \"release\")) {\n\t\t \n\t\tif (!ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE])\n\t\t\tgoto out;\n\t\tif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t\t    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0)\n\t\t\tgoto out;\n\t\tif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t\t    MPT3_DIAG_BUFFER_IS_RELEASED))\n\t\t\tgoto out;\n\t\tioc_info(ioc, \"releasing host trace buffer\\n\");\n\t\tioc->htb_rel.buffer_rel_condition = MPT3_DIAG_BUFFER_REL_SYSFS;\n\t\tmpt3sas_send_diag_release(ioc, MPI2_DIAG_BUF_TYPE_TRACE,\n\t\t    &issue_reset);\n\t}\n\n out:\n\treturn strlen(buf);\n}\nstatic DEVICE_ATTR_RW(host_trace_buffer_enable);\n\n \n\n \nstatic ssize_t\ndiag_trigger_master_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tunsigned long flags;\n\tssize_t rc;\n\n\tspin_lock_irqsave(&ioc->diag_trigger_lock, flags);\n\trc = sizeof(struct SL_WH_MASTER_TRIGGER_T);\n\tmemcpy(buf, &ioc->diag_trigger_master, rc);\n\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\treturn rc;\n}\n\n \nstatic ssize_t\ndiag_trigger_master_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tstruct SL_WH_MASTER_TRIGGER_T *master_tg;\n\tunsigned long flags;\n\tssize_t rc;\n\tbool set = 1;\n\n\trc = min(sizeof(struct SL_WH_MASTER_TRIGGER_T), count);\n\n\tif (ioc->supports_trigger_pages) {\n\t\tmaster_tg = kzalloc(sizeof(struct SL_WH_MASTER_TRIGGER_T),\n\t\t    GFP_KERNEL);\n\t\tif (!master_tg)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(master_tg, buf, rc);\n\t\tif (!master_tg->MasterData)\n\t\t\tset = 0;\n\t\tif (mpt3sas_config_update_driver_trigger_pg1(ioc, master_tg,\n\t\t    set)) {\n\t\t\tkfree(master_tg);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tkfree(master_tg);\n\t}\n\n\tspin_lock_irqsave(&ioc->diag_trigger_lock, flags);\n\tmemset(&ioc->diag_trigger_master, 0,\n\t    sizeof(struct SL_WH_MASTER_TRIGGER_T));\n\tmemcpy(&ioc->diag_trigger_master, buf, rc);\n\tioc->diag_trigger_master.MasterData |=\n\t    (MASTER_TRIGGER_FW_FAULT + MASTER_TRIGGER_ADAPTER_RESET);\n\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\treturn rc;\n}\nstatic DEVICE_ATTR_RW(diag_trigger_master);\n\n\n \nstatic ssize_t\ndiag_trigger_event_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tunsigned long flags;\n\tssize_t rc;\n\n\tspin_lock_irqsave(&ioc->diag_trigger_lock, flags);\n\trc = sizeof(struct SL_WH_EVENT_TRIGGERS_T);\n\tmemcpy(buf, &ioc->diag_trigger_event, rc);\n\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\treturn rc;\n}\n\n \nstatic ssize_t\ndiag_trigger_event_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tstruct SL_WH_EVENT_TRIGGERS_T *event_tg;\n\tunsigned long flags;\n\tssize_t sz;\n\tbool set = 1;\n\n\tsz = min(sizeof(struct SL_WH_EVENT_TRIGGERS_T), count);\n\tif (ioc->supports_trigger_pages) {\n\t\tevent_tg = kzalloc(sizeof(struct SL_WH_EVENT_TRIGGERS_T),\n\t\t    GFP_KERNEL);\n\t\tif (!event_tg)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(event_tg, buf, sz);\n\t\tif (!event_tg->ValidEntries)\n\t\t\tset = 0;\n\t\tif (mpt3sas_config_update_driver_trigger_pg2(ioc, event_tg,\n\t\t    set)) {\n\t\t\tkfree(event_tg);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tkfree(event_tg);\n\t}\n\n\tspin_lock_irqsave(&ioc->diag_trigger_lock, flags);\n\n\tmemset(&ioc->diag_trigger_event, 0,\n\t    sizeof(struct SL_WH_EVENT_TRIGGERS_T));\n\tmemcpy(&ioc->diag_trigger_event, buf, sz);\n\tif (ioc->diag_trigger_event.ValidEntries > NUM_VALID_ENTRIES)\n\t\tioc->diag_trigger_event.ValidEntries = NUM_VALID_ENTRIES;\n\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\treturn sz;\n}\nstatic DEVICE_ATTR_RW(diag_trigger_event);\n\n\n \nstatic ssize_t\ndiag_trigger_scsi_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tunsigned long flags;\n\tssize_t rc;\n\n\tspin_lock_irqsave(&ioc->diag_trigger_lock, flags);\n\trc = sizeof(struct SL_WH_SCSI_TRIGGERS_T);\n\tmemcpy(buf, &ioc->diag_trigger_scsi, rc);\n\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\treturn rc;\n}\n\n \nstatic ssize_t\ndiag_trigger_scsi_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tstruct SL_WH_SCSI_TRIGGERS_T *scsi_tg;\n\tunsigned long flags;\n\tssize_t sz;\n\tbool set = 1;\n\n\tsz = min(sizeof(struct SL_WH_SCSI_TRIGGERS_T), count);\n\tif (ioc->supports_trigger_pages) {\n\t\tscsi_tg = kzalloc(sizeof(struct SL_WH_SCSI_TRIGGERS_T),\n\t\t    GFP_KERNEL);\n\t\tif (!scsi_tg)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(scsi_tg, buf, sz);\n\t\tif (!scsi_tg->ValidEntries)\n\t\t\tset = 0;\n\t\tif (mpt3sas_config_update_driver_trigger_pg3(ioc, scsi_tg,\n\t\t    set)) {\n\t\t\tkfree(scsi_tg);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tkfree(scsi_tg);\n\t}\n\n\tspin_lock_irqsave(&ioc->diag_trigger_lock, flags);\n\n\tmemset(&ioc->diag_trigger_scsi, 0, sizeof(ioc->diag_trigger_scsi));\n\tmemcpy(&ioc->diag_trigger_scsi, buf, sz);\n\tif (ioc->diag_trigger_scsi.ValidEntries > NUM_VALID_ENTRIES)\n\t\tioc->diag_trigger_scsi.ValidEntries = NUM_VALID_ENTRIES;\n\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\treturn sz;\n}\nstatic DEVICE_ATTR_RW(diag_trigger_scsi);\n\n\n \nstatic ssize_t\ndiag_trigger_mpi_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tunsigned long flags;\n\tssize_t rc;\n\n\tspin_lock_irqsave(&ioc->diag_trigger_lock, flags);\n\trc = sizeof(struct SL_WH_MPI_TRIGGERS_T);\n\tmemcpy(buf, &ioc->diag_trigger_mpi, rc);\n\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\treturn rc;\n}\n\n \nstatic ssize_t\ndiag_trigger_mpi_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tstruct SL_WH_MPI_TRIGGERS_T *mpi_tg;\n\tunsigned long flags;\n\tssize_t sz;\n\tbool set = 1;\n\n\tsz = min(sizeof(struct SL_WH_MPI_TRIGGERS_T), count);\n\tif (ioc->supports_trigger_pages) {\n\t\tmpi_tg = kzalloc(sizeof(struct SL_WH_MPI_TRIGGERS_T),\n\t\t    GFP_KERNEL);\n\t\tif (!mpi_tg)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(mpi_tg, buf, sz);\n\t\tif (!mpi_tg->ValidEntries)\n\t\t\tset = 0;\n\t\tif (mpt3sas_config_update_driver_trigger_pg4(ioc, mpi_tg,\n\t\t    set)) {\n\t\t\tkfree(mpi_tg);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tkfree(mpi_tg);\n\t}\n\n\tspin_lock_irqsave(&ioc->diag_trigger_lock, flags);\n\tmemset(&ioc->diag_trigger_mpi, 0,\n\t    sizeof(ioc->diag_trigger_mpi));\n\tmemcpy(&ioc->diag_trigger_mpi, buf, sz);\n\tif (ioc->diag_trigger_mpi.ValidEntries > NUM_VALID_ENTRIES)\n\t\tioc->diag_trigger_mpi.ValidEntries = NUM_VALID_ENTRIES;\n\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\treturn sz;\n}\n\nstatic DEVICE_ATTR_RW(diag_trigger_mpi);\n\n \n\n \n\n \nstatic ssize_t\ndrv_support_bitmap_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"0x%08x\\n\", ioc->drv_support_bitmap);\n}\nstatic DEVICE_ATTR_RO(drv_support_bitmap);\n\n \nstatic ssize_t\nenable_sdev_max_qd_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", ioc->enable_sdev_max_qd);\n}\n\n \nstatic ssize_t\nenable_sdev_max_qd_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tint val = 0;\n\tstruct scsi_device *sdev;\n\tstruct _raid_device *raid_device;\n\tint qdepth;\n\n\tif (kstrtoint(buf, 0, &val) != 0)\n\t\treturn -EINVAL;\n\n\tswitch (val) {\n\tcase 0:\n\t\tioc->enable_sdev_max_qd = 0;\n\t\tshost_for_each_device(sdev, ioc->shost) {\n\t\t\tsas_device_priv_data = sdev->hostdata;\n\t\t\tif (!sas_device_priv_data)\n\t\t\t\tcontinue;\n\t\t\tsas_target_priv_data = sas_device_priv_data->sas_target;\n\t\t\tif (!sas_target_priv_data)\n\t\t\t\tcontinue;\n\n\t\t\tif (sas_target_priv_data->flags &\n\t\t\t    MPT_TARGET_FLAGS_VOLUME) {\n\t\t\t\traid_device =\n\t\t\t\t    mpt3sas_raid_device_find_by_handle(ioc,\n\t\t\t\t    sas_target_priv_data->handle);\n\n\t\t\t\tswitch (raid_device->volume_type) {\n\t\t\t\tcase MPI2_RAID_VOL_TYPE_RAID0:\n\t\t\t\t\tif (raid_device->device_info &\n\t\t\t\t\t    MPI2_SAS_DEVICE_INFO_SSP_TARGET)\n\t\t\t\t\t\tqdepth =\n\t\t\t\t\t\t    MPT3SAS_SAS_QUEUE_DEPTH;\n\t\t\t\t\telse\n\t\t\t\t\t\tqdepth =\n\t\t\t\t\t\t    MPT3SAS_SATA_QUEUE_DEPTH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MPI2_RAID_VOL_TYPE_RAID1E:\n\t\t\t\tcase MPI2_RAID_VOL_TYPE_RAID1:\n\t\t\t\tcase MPI2_RAID_VOL_TYPE_RAID10:\n\t\t\t\tcase MPI2_RAID_VOL_TYPE_UNKNOWN:\n\t\t\t\tdefault:\n\t\t\t\t\tqdepth = MPT3SAS_RAID_QUEUE_DEPTH;\n\t\t\t\t}\n\t\t\t} else if (sas_target_priv_data->flags &\n\t\t\t    MPT_TARGET_FLAGS_PCIE_DEVICE)\n\t\t\t\tqdepth = ioc->max_nvme_qd;\n\t\t\telse\n\t\t\t\tqdepth = (sas_target_priv_data->sas_dev->port_type > 1) ?\n\t\t\t\t    ioc->max_wideport_qd : ioc->max_narrowport_qd;\n\n\t\t\tmpt3sas_scsih_change_queue_depth(sdev, qdepth);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tioc->enable_sdev_max_qd = 1;\n\t\tshost_for_each_device(sdev, ioc->shost)\n\t\t\tmpt3sas_scsih_change_queue_depth(sdev,\n\t\t\t    shost->can_queue);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn strlen(buf);\n}\nstatic DEVICE_ATTR_RW(enable_sdev_max_qd);\n\nstatic struct attribute *mpt3sas_host_attrs[] = {\n\t&dev_attr_version_fw.attr,\n\t&dev_attr_version_bios.attr,\n\t&dev_attr_version_mpi.attr,\n\t&dev_attr_version_product.attr,\n\t&dev_attr_version_nvdata_persistent.attr,\n\t&dev_attr_version_nvdata_default.attr,\n\t&dev_attr_board_name.attr,\n\t&dev_attr_board_assembly.attr,\n\t&dev_attr_board_tracer.attr,\n\t&dev_attr_io_delay.attr,\n\t&dev_attr_device_delay.attr,\n\t&dev_attr_logging_level.attr,\n\t&dev_attr_fwfault_debug.attr,\n\t&dev_attr_fw_queue_depth.attr,\n\t&dev_attr_host_sas_address.attr,\n\t&dev_attr_ioc_reset_count.attr,\n\t&dev_attr_host_trace_buffer_size.attr,\n\t&dev_attr_host_trace_buffer.attr,\n\t&dev_attr_host_trace_buffer_enable.attr,\n\t&dev_attr_reply_queue_count.attr,\n\t&dev_attr_diag_trigger_master.attr,\n\t&dev_attr_diag_trigger_event.attr,\n\t&dev_attr_diag_trigger_scsi.attr,\n\t&dev_attr_diag_trigger_mpi.attr,\n\t&dev_attr_drv_support_bitmap.attr,\n\t&dev_attr_BRM_status.attr,\n\t&dev_attr_enable_sdev_max_qd.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mpt3sas_host_attr_group = {\n\t.attrs = mpt3sas_host_attrs\n};\n\nconst struct attribute_group *mpt3sas_host_groups[] = {\n\t&mpt3sas_host_attr_group,\n\tNULL\n};\n\n \n\n \nstatic ssize_t\nsas_address_show(struct device *dev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data = sdev->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"0x%016llx\\n\",\n\t    (unsigned long long)sas_device_priv_data->sas_target->sas_address);\n}\nstatic DEVICE_ATTR_RO(sas_address);\n\n \nstatic ssize_t\nsas_device_handle_show(struct device *dev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data = sdev->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"0x%04x\\n\",\n\t    sas_device_priv_data->sas_target->handle);\n}\nstatic DEVICE_ATTR_RO(sas_device_handle);\n\n \nstatic ssize_t\nsas_ncq_prio_supported_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", scsih_ncq_prio_supp(sdev));\n}\nstatic DEVICE_ATTR_RO(sas_ncq_prio_supported);\n\n \nstatic ssize_t\nsas_ncq_prio_enable_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data = sdev->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\tsas_device_priv_data->ncq_prio_enable);\n}\n\nstatic ssize_t\nsas_ncq_prio_enable_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data = sdev->hostdata;\n\tbool ncq_prio_enable = 0;\n\n\tif (kstrtobool(buf, &ncq_prio_enable))\n\t\treturn -EINVAL;\n\n\tif (!scsih_ncq_prio_supp(sdev))\n\t\treturn -EINVAL;\n\n\tsas_device_priv_data->ncq_prio_enable = ncq_prio_enable;\n\treturn strlen(buf);\n}\nstatic DEVICE_ATTR_RW(sas_ncq_prio_enable);\n\nstatic struct attribute *mpt3sas_dev_attrs[] = {\n\t&dev_attr_sas_address.attr,\n\t&dev_attr_sas_device_handle.attr,\n\t&dev_attr_sas_ncq_prio_supported.attr,\n\t&dev_attr_sas_ncq_prio_enable.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mpt3sas_dev_attr_group = {\n\t.attrs = mpt3sas_dev_attrs\n};\n\nconst struct attribute_group *mpt3sas_dev_groups[] = {\n\t&mpt3sas_dev_attr_group,\n\tNULL\n};\n\n \nstatic const struct file_operations ctl_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = _ctl_ioctl,\n\t.poll = _ctl_poll,\n\t.fasync = _ctl_fasync,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = _ctl_ioctl_compat,\n#endif\n};\n\n \nstatic const struct file_operations ctl_gen2_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = _ctl_mpt2_ioctl,\n\t.poll = _ctl_poll,\n\t.fasync = _ctl_fasync,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = _ctl_mpt2_ioctl_compat,\n#endif\n};\n\nstatic struct miscdevice ctl_dev = {\n\t.minor  = MPT3SAS_MINOR,\n\t.name   = MPT3SAS_DEV_NAME,\n\t.fops   = &ctl_fops,\n};\n\nstatic struct miscdevice gen2_ctl_dev = {\n\t.minor  = MPT2SAS_MINOR,\n\t.name   = MPT2SAS_DEV_NAME,\n\t.fops   = &ctl_gen2_fops,\n};\n\n \nvoid\nmpt3sas_ctl_init(ushort hbas_to_enumerate)\n{\n\tasync_queue = NULL;\n\n\t \n\tif (hbas_to_enumerate != 1)\n\t\tif (misc_register(&ctl_dev) < 0)\n\t\t\tpr_err(\"%s can't register misc device [minor=%d]\\n\",\n\t\t\t    MPT3SAS_DRIVER_NAME, MPT3SAS_MINOR);\n\n\t \n\tif (hbas_to_enumerate != 2)\n\t\tif (misc_register(&gen2_ctl_dev) < 0)\n\t\t\tpr_err(\"%s can't register misc device [minor=%d]\\n\",\n\t\t\t    MPT2SAS_DRIVER_NAME, MPT2SAS_MINOR);\n\n\tinit_waitqueue_head(&ctl_poll_wait);\n}\n\n \nvoid\nmpt3sas_ctl_exit(ushort hbas_to_enumerate)\n{\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tint i;\n\n\tlist_for_each_entry(ioc, &mpt3sas_ioc_list, list) {\n\n\t\t \n\t\tfor (i = 0; i < MPI2_DIAG_BUF_TYPE_COUNT; i++) {\n\t\t\tif (!ioc->diag_buffer[i])\n\t\t\t\tcontinue;\n\t\t\tdma_free_coherent(&ioc->pdev->dev,\n\t\t\t\t\t  ioc->diag_buffer_sz[i],\n\t\t\t\t\t  ioc->diag_buffer[i],\n\t\t\t\t\t  ioc->diag_buffer_dma[i]);\n\t\t\tioc->diag_buffer[i] = NULL;\n\t\t\tioc->diag_buffer_status[i] = 0;\n\t\t}\n\n\t\tkfree(ioc->event_log);\n\t}\n\tif (hbas_to_enumerate != 1)\n\t\tmisc_deregister(&ctl_dev);\n\tif (hbas_to_enumerate != 2)\n\t\tmisc_deregister(&gen2_ctl_dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}