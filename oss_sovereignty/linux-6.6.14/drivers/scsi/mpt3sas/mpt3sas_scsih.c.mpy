{
  "module_name": "mpt3sas_scsih.c",
  "hash_id": "5576f23cf79c2f856191e1e40d611fd1b5538310e37d0309d344b367d40f7546",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mpt3sas/mpt3sas_scsih.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/blkdev.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/raid_class.h>\n#include <linux/blk-mq-pci.h>\n#include <asm/unaligned.h>\n\n#include \"mpt3sas_base.h\"\n\n#define RAID_CHANNEL 1\n\n#define PCIE_CHANNEL 2\n\n \nstatic void _scsih_expander_node_remove(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_node *sas_expander);\nstatic void _firmware_event_work(struct work_struct *work);\n\nstatic void _scsih_remove_device(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_device *sas_device);\nstatic int _scsih_add_device(struct MPT3SAS_ADAPTER *ioc, u16 handle,\n\tu8 retry_count, u8 is_pd);\nstatic int _scsih_pcie_add_device(struct MPT3SAS_ADAPTER *ioc, u16 handle);\nstatic void _scsih_pcie_device_remove_from_sml(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _pcie_device *pcie_device);\nstatic void\n_scsih_pcie_check_device(struct MPT3SAS_ADAPTER *ioc, u16 handle);\nstatic u8 _scsih_check_for_pending_tm(struct MPT3SAS_ADAPTER *ioc, u16 smid);\nstatic void _scsih_complete_devices_scanning(struct MPT3SAS_ADAPTER *ioc);\n\n \nLIST_HEAD(mpt3sas_ioc_list);\n \nDEFINE_SPINLOCK(gioc_lock);\n\nMODULE_AUTHOR(MPT3SAS_AUTHOR);\nMODULE_DESCRIPTION(MPT3SAS_DESCRIPTION);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(MPT3SAS_DRIVER_VERSION);\nMODULE_ALIAS(\"mpt2sas\");\n\n \nstatic u8 scsi_io_cb_idx = -1;\nstatic u8 tm_cb_idx = -1;\nstatic u8 ctl_cb_idx = -1;\nstatic u8 base_cb_idx = -1;\nstatic u8 port_enable_cb_idx = -1;\nstatic u8 transport_cb_idx = -1;\nstatic u8 scsih_cb_idx = -1;\nstatic u8 config_cb_idx = -1;\nstatic int mpt2_ids;\nstatic int mpt3_ids;\n\nstatic u8 tm_tr_cb_idx = -1 ;\nstatic u8 tm_tr_volume_cb_idx = -1 ;\nstatic u8 tm_sas_control_cb_idx = -1;\n\n \nstatic u32 logging_level;\nMODULE_PARM_DESC(logging_level,\n\t\" bits for enabling additional logging info (default=0)\");\n\n\nstatic ushort max_sectors = 0xFFFF;\nmodule_param(max_sectors, ushort, 0444);\nMODULE_PARM_DESC(max_sectors, \"max sectors, range 64 to 32767  default=32767\");\n\n\nstatic int missing_delay[2] = {-1, -1};\nmodule_param_array(missing_delay, int, NULL, 0444);\nMODULE_PARM_DESC(missing_delay, \" device missing delay , io missing delay\");\n\n \n#define MPT3SAS_MAX_LUN (16895)\nstatic u64 max_lun = MPT3SAS_MAX_LUN;\nmodule_param(max_lun, ullong, 0444);\nMODULE_PARM_DESC(max_lun, \" max lun, default=16895 \");\n\nstatic ushort hbas_to_enumerate;\nmodule_param(hbas_to_enumerate, ushort, 0444);\nMODULE_PARM_DESC(hbas_to_enumerate,\n\t\t\" 0 - enumerates both SAS 2.0 & SAS 3.0 generation HBAs\\n \\\n\t\t  1 - enumerates only SAS 2.0 generation HBAs\\n \\\n\t\t  2 - enumerates only SAS 3.0 generation HBAs (default=0)\");\n\n/* diag_buffer_enable is bitwise\n * bit 0 set = TRACE\n * bit 1 set = SNAPSHOT\n * bit 2 set = EXTENDED\n *\n * Either bit can be set, or both\n */\nstatic int diag_buffer_enable = -1;\nmodule_param(diag_buffer_enable, int, 0444);\nMODULE_PARM_DESC(diag_buffer_enable,\n\t\" post diag buffers (TRACE=1/SNAPSHOT=2/EXTENDED=4/default=0)\");\nstatic int disable_discovery = -1;\nmodule_param(disable_discovery, int, 0444);\nMODULE_PARM_DESC(disable_discovery, \" disable discovery \");\n\n\n/* permit overriding the host protection capabilities mask (EEDP/T10 PI) */\nstatic int prot_mask = -1;\nmodule_param(prot_mask, int, 0444);\nMODULE_PARM_DESC(prot_mask, \" host protection capabilities mask, def=7 \");\n\nstatic bool enable_sdev_max_qd;\nmodule_param(enable_sdev_max_qd, bool, 0444);\nMODULE_PARM_DESC(enable_sdev_max_qd,\n\t\"Enable sdev max qd as can_queue, def=disabled(0)\");\n\nstatic int multipath_on_hba = -1;\nmodule_param(multipath_on_hba, int, 0);\nMODULE_PARM_DESC(multipath_on_hba,\n\t\"Multipath support to add same target device\\n\\t\\t\"\n\t\"as many times as it is visible to HBA from various paths\\n\\t\\t\"\n\t\"(by default:\\n\\t\\t\"\n\t\"\\t SAS 2.0 & SAS 3.0 HBA - This will be disabled,\\n\\t\\t\"\n\t\"\\t SAS 3.5 HBA - This will be enabled)\");\n\nstatic int host_tagset_enable = 1;\nmodule_param(host_tagset_enable, int, 0444);\nMODULE_PARM_DESC(host_tagset_enable,\n\t\"Shared host tagset enable/disable Default: enable(1)\");\n\n/* raid transport support */\nstatic struct raid_template *mpt3sas_raid_template;\nstatic struct raid_template *mpt2sas_raid_template;\n\n\n/**\n * struct sense_info - common structure for obtaining sense keys\n * @skey: sense key\n * @asc: additional sense code\n * @ascq: additional sense code qualifier\n */\nstruct sense_info {\n\tu8 skey;\n\tu8 asc;\n\tu8 ascq;\n};\n\n#define MPT3SAS_PROCESS_TRIGGER_DIAG (0xFFFB)\n#define MPT3SAS_TURN_ON_PFA_LED (0xFFFC)\n#define MPT3SAS_PORT_ENABLE_COMPLETE (0xFFFD)\n#define MPT3SAS_ABRT_TASK_SET (0xFFFE)\n#define MPT3SAS_REMOVE_UNRESPONDING_DEVICES (0xFFFF)\n/**\n * struct fw_event_work - firmware event struct\n * @list: link list framework\n * @work: work object (ioc->fault_reset_work_q)\n * @ioc: per adapter object\n * @device_handle: device handle\n * @VF_ID: virtual function id\n * @VP_ID: virtual port id\n * @ignore: flag meaning this event has been marked to ignore\n * @event: firmware event MPI2_EVENT_XXX defined in mpi2_ioc.h\n * @refcount: kref for this event\n * @event_data: reply event data payload follows\n *\n * This object stored on ioc->fw_event_list.\n */\nstruct fw_event_work {\n\tstruct list_head\tlist;\n\tstruct work_struct\twork;\n\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tu16\t\t\tdevice_handle;\n\tu8\t\t\tVF_ID;\n\tu8\t\t\tVP_ID;\n\tu8\t\t\tignore;\n\tu16\t\t\tevent;\n\tstruct kref\t\trefcount;\n\tchar\t\t\tevent_data[] __aligned(4);\n};\n\nstatic void fw_event_work_free(struct kref *r)\n{\n\tkfree(container_of(r, struct fw_event_work, refcount));\n}\n\nstatic void fw_event_work_get(struct fw_event_work *fw_work)\n{\n\tkref_get(&fw_work->refcount);\n}\n\nstatic void fw_event_work_put(struct fw_event_work *fw_work)\n{\n\tkref_put(&fw_work->refcount, fw_event_work_free);\n}\n\nstatic struct fw_event_work *alloc_fw_event_work(int len)\n{\n\tstruct fw_event_work *fw_event;\n\n\tfw_event = kzalloc(sizeof(*fw_event) + len, GFP_ATOMIC);\n\tif (!fw_event)\n\t\treturn NULL;\n\n\tkref_init(&fw_event->refcount);\n\treturn fw_event;\n}\n\n/**\n * struct _scsi_io_transfer - scsi io transfer\n * @handle: sas device handle (assigned by firmware)\n * @is_raid: flag set for hidden raid components\n * @dir: DMA_TO_DEVICE, DMA_FROM_DEVICE,\n * @data_length: data transfer length\n * @data_dma: dma pointer to data\n * @sense: sense data\n * @lun: lun number\n * @cdb_length: cdb length\n * @cdb: cdb contents\n * @timeout: timeout for this command\n * @VF_ID: virtual function id\n * @VP_ID: virtual port id\n * @valid_reply: flag set for reply message\n * @sense_length: sense length\n * @ioc_status: ioc status\n * @scsi_state: scsi state\n * @scsi_status: scsi staus\n * @log_info: log information\n * @transfer_length: data length transfer when there is a reply message\n *\n * Used for sending internal scsi commands to devices within this module.\n * Refer to _scsi_send_scsi_io().\n */\nstruct _scsi_io_transfer {\n\tu16\thandle;\n\tu8\tis_raid;\n\tenum dma_data_direction dir;\n\tu32\tdata_length;\n\tdma_addr_t data_dma;\n\tu8\tsense[SCSI_SENSE_BUFFERSIZE];\n\tu32\tlun;\n\tu8\tcdb_length;\n\tu8\tcdb[32];\n\tu8\ttimeout;\n\tu8\tVF_ID;\n\tu8\tVP_ID;\n\tu8\tvalid_reply;\n  /* the following bits are only valid when 'valid_reply = 1' */\n\tu32\tsense_length;\n\tu16\tioc_status;\n\tu8\tscsi_state;\n\tu8\tscsi_status;\n\tu32\tlog_info;\n\tu32\ttransfer_length;\n};\n\n/**\n * _scsih_set_debug_level - global setting of ioc->logging_level.\n * @val: ?\n * @kp: ?\n *\n * Note: The logging levels are defined in mpt3sas_debug.h.\n */\nstatic int\n_scsih_set_debug_level(const char *val, const struct kernel_param *kp)\n{\n\tint ret = param_set_int(val, kp);\n\tstruct MPT3SAS_ADAPTER *ioc;\n\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"setting logging_level(0x%08x)\\n\", logging_level);\n\tspin_lock(&gioc_lock);\n\tlist_for_each_entry(ioc, &mpt3sas_ioc_list, list)\n\t\tioc->logging_level = logging_level;\n\tspin_unlock(&gioc_lock);\n\treturn 0;\n}\nmodule_param_call(logging_level, _scsih_set_debug_level, param_get_int,\n\t&logging_level, 0644);\n\n/**\n * _scsih_srch_boot_sas_address - search based on sas_address\n * @sas_address: sas address\n * @boot_device: boot device object from bios page 2\n *\n * Return: 1 when there's a match, 0 means no match.\n */\nstatic inline int\n_scsih_srch_boot_sas_address(u64 sas_address,\n\tMpi2BootDeviceSasWwid_t *boot_device)\n{\n\treturn (sas_address == le64_to_cpu(boot_device->SASAddress)) ?  1 : 0;\n}\n\n/**\n * _scsih_srch_boot_device_name - search based on device name\n * @device_name: device name specified in INDENTIFY fram\n * @boot_device: boot device object from bios page 2\n *\n * Return: 1 when there's a match, 0 means no match.\n */\nstatic inline int\n_scsih_srch_boot_device_name(u64 device_name,\n\tMpi2BootDeviceDeviceName_t *boot_device)\n{\n\treturn (device_name == le64_to_cpu(boot_device->DeviceName)) ? 1 : 0;\n}\n\n/**\n * _scsih_srch_boot_encl_slot - search based on enclosure_logical_id/slot\n * @enclosure_logical_id: enclosure logical id\n * @slot_number: slot number\n * @boot_device: boot device object from bios page 2\n *\n * Return: 1 when there's a match, 0 means no match.\n */\nstatic inline int\n_scsih_srch_boot_encl_slot(u64 enclosure_logical_id, u16 slot_number,\n\tMpi2BootDeviceEnclosureSlot_t *boot_device)\n{\n\treturn (enclosure_logical_id == le64_to_cpu(boot_device->\n\t    EnclosureLogicalID) && slot_number == le16_to_cpu(boot_device->\n\t    SlotNumber)) ? 1 : 0;\n}\n\n/**\n * mpt3sas_get_port_by_id - get hba port entry corresponding to provided\n *\t\t\t  port number from port list\n * @ioc: per adapter object\n * @port_id: port number\n * @bypass_dirty_port_flag: when set look the matching hba port entry even\n *\t\t\tif hba port entry is marked as dirty.\n *\n * Search for hba port entry corresponding to provided port number,\n * if available return port object otherwise return NULL.\n */\nstruct hba_port *\nmpt3sas_get_port_by_id(struct MPT3SAS_ADAPTER *ioc,\n\tu8 port_id, u8 bypass_dirty_port_flag)\n{\n\tstruct hba_port *port, *port_next;\n\n\t/*\n\t * When multipath_on_hba is disabled then\n\t * search the hba_port entry using default\n\t * port id i.e. 255\n\t */\n\tif (!ioc->multipath_on_hba)\n\t\tport_id = MULTIPATH_DISABLED_PORT_ID;\n\n\tlist_for_each_entry_safe(port, port_next,\n\t    &ioc->port_table_list, list) {\n\t\tif (port->port_id != port_id)\n\t\t\tcontinue;\n\t\tif (bypass_dirty_port_flag)\n\t\t\treturn port;\n\t\tif (port->flags & HBA_PORT_FLAG_DIRTY_PORT)\n\t\t\tcontinue;\n\t\treturn port;\n\t}\n\n\t/*\n\t * Allocate hba_port object for default port id (i.e. 255)\n\t * when multipath_on_hba is disabled for the HBA.\n\t * And add this object to port_table_list.\n\t */\n\tif (!ioc->multipath_on_hba) {\n\t\tport = kzalloc(sizeof(struct hba_port), GFP_ATOMIC);\n\t\tif (!port)\n\t\t\treturn NULL;\n\n\t\tport->port_id = port_id;\n\t\tioc_info(ioc,\n\t\t   \"hba_port entry: %p, port: %d is added to hba_port list\\n\",\n\t\t   port, port->port_id);\n\t\tlist_add_tail(&port->list,\n\t\t    &ioc->port_table_list);\n\t\treturn port;\n\t}\n\treturn NULL;\n}\n\n/**\n * mpt3sas_get_vphy_by_phy - get virtual_phy object corresponding to phy number\n * @ioc: per adapter object\n * @port: hba_port object\n * @phy: phy number\n *\n * Return virtual_phy object corresponding to phy number.\n */\nstruct virtual_phy *\nmpt3sas_get_vphy_by_phy(struct MPT3SAS_ADAPTER *ioc,\n\tstruct hba_port *port, u32 phy)\n{\n\tstruct virtual_phy *vphy, *vphy_next;\n\n\tif (!port->vphys_mask)\n\t\treturn NULL;\n\n\tlist_for_each_entry_safe(vphy, vphy_next, &port->vphys_list, list) {\n\t\tif (vphy->phy_mask & (1 << phy))\n\t\t\treturn vphy;\n\t}\n\treturn NULL;\n}\n\n/**\n * _scsih_is_boot_device - search for matching boot device.\n * @sas_address: sas address\n * @device_name: device name specified in INDENTIFY fram\n * @enclosure_logical_id: enclosure logical id\n * @slot: slot number\n * @form: specifies boot device form\n * @boot_device: boot device object from bios page 2\n *\n * Return: 1 when there's a match, 0 means no match.\n */\nstatic int\n_scsih_is_boot_device(u64 sas_address, u64 device_name,\n\tu64 enclosure_logical_id, u16 slot, u8 form,\n\tMpi2BiosPage2BootDevice_t *boot_device)\n{\n\tint rc = 0;\n\n\tswitch (form) {\n\tcase MPI2_BIOSPAGE2_FORM_SAS_WWID:\n\t\tif (!sas_address)\n\t\t\tbreak;\n\t\trc = _scsih_srch_boot_sas_address(\n\t\t    sas_address, &boot_device->SasWwid);\n\t\tbreak;\n\tcase MPI2_BIOSPAGE2_FORM_ENCLOSURE_SLOT:\n\t\tif (!enclosure_logical_id)\n\t\t\tbreak;\n\t\trc = _scsih_srch_boot_encl_slot(\n\t\t    enclosure_logical_id,\n\t\t    slot, &boot_device->EnclosureSlot);\n\t\tbreak;\n\tcase MPI2_BIOSPAGE2_FORM_DEVICE_NAME:\n\t\tif (!device_name)\n\t\t\tbreak;\n\t\trc = _scsih_srch_boot_device_name(\n\t\t    device_name, &boot_device->DeviceName);\n\t\tbreak;\n\tcase MPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n/**\n * _scsih_get_sas_address - set the sas_address for given device handle\n * @ioc: ?\n * @handle: device handle\n * @sas_address: sas address\n *\n * Return: 0 success, non-zero when failure\n */\nstatic int\n_scsih_get_sas_address(struct MPT3SAS_ADAPTER *ioc, u16 handle,\n\tu64 *sas_address)\n{\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu32 ioc_status;\n\n\t*sas_address = 0;\n\n\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\n\t    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status == MPI2_IOCSTATUS_SUCCESS) {\n\t\t/* For HBA, vSES doesn't return HBA SAS address. Instead return\n\t\t * vSES's sas address.\n\t\t */\n\t\tif ((handle <= ioc->sas_hba.num_phys) &&\n\t\t   (!(le32_to_cpu(sas_device_pg0.DeviceInfo) &\n\t\t   MPI2_SAS_DEVICE_INFO_SEP)))\n\t\t\t*sas_address = ioc->sas_hba.sas_address;\n\t\telse\n\t\t\t*sas_address = le64_to_cpu(sas_device_pg0.SASAddress);\n\t\treturn 0;\n\t}\n\n\t/* we hit this because the given parent handle doesn't exist */\n\tif (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)\n\t\treturn -ENXIO;\n\n\t/* else error case */\n\tioc_err(ioc, \"handle(0x%04x), ioc_status(0x%04x), failure at %s:%d/%s()!\\n\",\n\t\thandle, ioc_status, __FILE__, __LINE__, __func__);\n\treturn -EIO;\n}\n\n/**\n * _scsih_determine_boot_device - determine boot device.\n * @ioc: per adapter object\n * @device: sas_device or pcie_device object\n * @channel: SAS or PCIe channel\n *\n * Determines whether this device should be first reported device to\n * to scsi-ml or sas transport, this purpose is for persistent boot device.\n * There are primary, alternate, and current entries in bios page 2. The order\n * priority is primary, alternate, then current.  This routine saves\n * the corresponding device object.\n * The saved data to be used later in _scsih_probe_boot_devices().\n */\nstatic void\n_scsih_determine_boot_device(struct MPT3SAS_ADAPTER *ioc, void *device,\n\tu32 channel)\n{\n\tstruct _sas_device *sas_device;\n\tstruct _pcie_device *pcie_device;\n\tstruct _raid_device *raid_device;\n\tu64 sas_address;\n\tu64 device_name;\n\tu64 enclosure_logical_id;\n\tu16 slot;\n\n\t /* only process this function when driver loads */\n\tif (!ioc->is_driver_loading)\n\t\treturn;\n\n\t /* no Bios, return immediately */\n\tif (!ioc->bios_pg3.BiosVersion)\n\t\treturn;\n\n\tif (channel == RAID_CHANNEL) {\n\t\traid_device = device;\n\t\tsas_address = raid_device->wwid;\n\t\tdevice_name = 0;\n\t\tenclosure_logical_id = 0;\n\t\tslot = 0;\n\t} else if (channel == PCIE_CHANNEL) {\n\t\tpcie_device = device;\n\t\tsas_address = pcie_device->wwid;\n\t\tdevice_name = 0;\n\t\tenclosure_logical_id = 0;\n\t\tslot = 0;\n\t} else {\n\t\tsas_device = device;\n\t\tsas_address = sas_device->sas_address;\n\t\tdevice_name = sas_device->device_name;\n\t\tenclosure_logical_id = sas_device->enclosure_logical_id;\n\t\tslot = sas_device->slot;\n\t}\n\n\tif (!ioc->req_boot_device.device) {\n\t\tif (_scsih_is_boot_device(sas_address, device_name,\n\t\t    enclosure_logical_id, slot,\n\t\t    (ioc->bios_pg2.ReqBootDeviceForm &\n\t\t    MPI2_BIOSPAGE2_FORM_MASK),\n\t\t    &ioc->bios_pg2.RequestedBootDevice)) {\n\t\t\tdinitprintk(ioc,\n\t\t\t\t    ioc_info(ioc, \"%s: req_boot_device(0x%016llx)\\n\",\n\t\t\t\t\t     __func__, (u64)sas_address));\n\t\t\tioc->req_boot_device.device = device;\n\t\t\tioc->req_boot_device.channel = channel;\n\t\t}\n\t}\n\n\tif (!ioc->req_alt_boot_device.device) {\n\t\tif (_scsih_is_boot_device(sas_address, device_name,\n\t\t    enclosure_logical_id, slot,\n\t\t    (ioc->bios_pg2.ReqAltBootDeviceForm &\n\t\t    MPI2_BIOSPAGE2_FORM_MASK),\n\t\t    &ioc->bios_pg2.RequestedAltBootDevice)) {\n\t\t\tdinitprintk(ioc,\n\t\t\t\t    ioc_info(ioc, \"%s: req_alt_boot_device(0x%016llx)\\n\",\n\t\t\t\t\t     __func__, (u64)sas_address));\n\t\t\tioc->req_alt_boot_device.device = device;\n\t\t\tioc->req_alt_boot_device.channel = channel;\n\t\t}\n\t}\n\n\tif (!ioc->current_boot_device.device) {\n\t\tif (_scsih_is_boot_device(sas_address, device_name,\n\t\t    enclosure_logical_id, slot,\n\t\t    (ioc->bios_pg2.CurrentBootDeviceForm &\n\t\t    MPI2_BIOSPAGE2_FORM_MASK),\n\t\t    &ioc->bios_pg2.CurrentBootDevice)) {\n\t\t\tdinitprintk(ioc,\n\t\t\t\t    ioc_info(ioc, \"%s: current_boot_device(0x%016llx)\\n\",\n\t\t\t\t\t     __func__, (u64)sas_address));\n\t\t\tioc->current_boot_device.device = device;\n\t\t\tioc->current_boot_device.channel = channel;\n\t\t}\n\t}\n}\n\nstatic struct _sas_device *\n__mpt3sas_get_sdev_from_target(struct MPT3SAS_ADAPTER *ioc,\n\t\tstruct MPT3SAS_TARGET *tgt_priv)\n{\n\tstruct _sas_device *ret;\n\n\tassert_spin_locked(&ioc->sas_device_lock);\n\n\tret = tgt_priv->sas_dev;\n\tif (ret)\n\t\tsas_device_get(ret);\n\n\treturn ret;\n}\n\nstatic struct _sas_device *\nmpt3sas_get_sdev_from_target(struct MPT3SAS_ADAPTER *ioc,\n\t\tstruct MPT3SAS_TARGET *tgt_priv)\n{\n\tstruct _sas_device *ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tret = __mpt3sas_get_sdev_from_target(ioc, tgt_priv);\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\treturn ret;\n}\n\nstatic struct _pcie_device *\n__mpt3sas_get_pdev_from_target(struct MPT3SAS_ADAPTER *ioc,\n\tstruct MPT3SAS_TARGET *tgt_priv)\n{\n\tstruct _pcie_device *ret;\n\n\tassert_spin_locked(&ioc->pcie_device_lock);\n\n\tret = tgt_priv->pcie_dev;\n\tif (ret)\n\t\tpcie_device_get(ret);\n\n\treturn ret;\n}\n\n/**\n * mpt3sas_get_pdev_from_target - pcie device search\n * @ioc: per adapter object\n * @tgt_priv: starget private object\n *\n * Context: This function will acquire ioc->pcie_device_lock and will release\n * before returning the pcie_device object.\n *\n * This searches for pcie_device from target, then return pcie_device object.\n */\nstatic struct _pcie_device *\nmpt3sas_get_pdev_from_target(struct MPT3SAS_ADAPTER *ioc,\n\tstruct MPT3SAS_TARGET *tgt_priv)\n{\n\tstruct _pcie_device *ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tret = __mpt3sas_get_pdev_from_target(ioc, tgt_priv);\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\treturn ret;\n}\n\n\n/**\n * __mpt3sas_get_sdev_by_rphy - sas device search\n * @ioc: per adapter object\n * @rphy: sas_rphy pointer\n *\n * Context: This function will acquire ioc->sas_device_lock and will release\n * before returning the sas_device object.\n *\n * This searches for sas_device from rphy object\n * then return sas_device object.\n */\nstruct _sas_device *\n__mpt3sas_get_sdev_by_rphy(struct MPT3SAS_ADAPTER *ioc,\n\tstruct sas_rphy *rphy)\n{\n\tstruct _sas_device *sas_device;\n\n\tassert_spin_locked(&ioc->sas_device_lock);\n\n\tlist_for_each_entry(sas_device, &ioc->sas_device_list, list) {\n\t\tif (sas_device->rphy != rphy)\n\t\t\tcontinue;\n\t\tsas_device_get(sas_device);\n\t\treturn sas_device;\n\t}\n\n\tsas_device = NULL;\n\tlist_for_each_entry(sas_device, &ioc->sas_device_init_list, list) {\n\t\tif (sas_device->rphy != rphy)\n\t\t\tcontinue;\n\t\tsas_device_get(sas_device);\n\t\treturn sas_device;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * __mpt3sas_get_sdev_by_addr - get _sas_device object corresponding to provided\n *\t\t\t\tsas address from sas_device_list list\n * @ioc: per adapter object\n * @sas_address: device sas address\n * @port: port number\n *\n * Search for _sas_device object corresponding to provided sas address,\n * if available return _sas_device object address otherwise return NULL.\n */\nstruct _sas_device *\n__mpt3sas_get_sdev_by_addr(struct MPT3SAS_ADAPTER *ioc,\n\tu64 sas_address, struct hba_port *port)\n{\n\tstruct _sas_device *sas_device;\n\n\tif (!port)\n\t\treturn NULL;\n\n\tassert_spin_locked(&ioc->sas_device_lock);\n\n\tlist_for_each_entry(sas_device, &ioc->sas_device_list, list) {\n\t\tif (sas_device->sas_address != sas_address)\n\t\t\tcontinue;\n\t\tif (sas_device->port != port)\n\t\t\tcontinue;\n\t\tsas_device_get(sas_device);\n\t\treturn sas_device;\n\t}\n\n\tlist_for_each_entry(sas_device, &ioc->sas_device_init_list, list) {\n\t\tif (sas_device->sas_address != sas_address)\n\t\t\tcontinue;\n\t\tif (sas_device->port != port)\n\t\t\tcontinue;\n\t\tsas_device_get(sas_device);\n\t\treturn sas_device;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * mpt3sas_get_sdev_by_addr - sas device search\n * @ioc: per adapter object\n * @sas_address: sas address\n * @port: hba port entry\n * Context: Calling function should acquire ioc->sas_device_lock\n *\n * This searches for sas_device based on sas_address & port number,\n * then return sas_device object.\n */\nstruct _sas_device *\nmpt3sas_get_sdev_by_addr(struct MPT3SAS_ADAPTER *ioc,\n\tu64 sas_address, struct hba_port *port)\n{\n\tstruct _sas_device *sas_device;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_addr(ioc,\n\t    sas_address, port);\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\treturn sas_device;\n}\n\nstatic struct _sas_device *\n__mpt3sas_get_sdev_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _sas_device *sas_device;\n\n\tassert_spin_locked(&ioc->sas_device_lock);\n\n\tlist_for_each_entry(sas_device, &ioc->sas_device_list, list)\n\t\tif (sas_device->handle == handle)\n\t\t\tgoto found_device;\n\n\tlist_for_each_entry(sas_device, &ioc->sas_device_init_list, list)\n\t\tif (sas_device->handle == handle)\n\t\t\tgoto found_device;\n\n\treturn NULL;\n\nfound_device:\n\tsas_device_get(sas_device);\n\treturn sas_device;\n}\n\n/**\n * mpt3sas_get_sdev_by_handle - sas device search\n * @ioc: per adapter object\n * @handle: sas device handle (assigned by firmware)\n * Context: Calling function should acquire ioc->sas_device_lock\n *\n * This searches for sas_device based on sas_address, then return sas_device\n * object.\n */\nstruct _sas_device *\nmpt3sas_get_sdev_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _sas_device *sas_device;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_handle(ioc, handle);\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\treturn sas_device;\n}\n\n/**\n * _scsih_display_enclosure_chassis_info - display device location info\n * @ioc: per adapter object\n * @sas_device: per sas device object\n * @sdev: scsi device struct\n * @starget: scsi target struct\n */\nstatic void\n_scsih_display_enclosure_chassis_info(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_device *sas_device, struct scsi_device *sdev,\n\tstruct scsi_target *starget)\n{\n\tif (sdev) {\n\t\tif (sas_device->enclosure_handle != 0)\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"enclosure logical id (0x%016llx), slot(%d) \\n\",\n\t\t\t    (unsigned long long)\n\t\t\t    sas_device->enclosure_logical_id,\n\t\t\t    sas_device->slot);\n\t\tif (sas_device->connector_name[0] != '\\0')\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t    sas_device->enclosure_level,\n\t\t\t    sas_device->connector_name);\n\t\tif (sas_device->is_chassis_slot_valid)\n\t\t\tsdev_printk(KERN_INFO, sdev, \"chassis slot(0x%04x)\\n\",\n\t\t\t    sas_device->chassis_slot);\n\t} else if (starget) {\n\t\tif (sas_device->enclosure_handle != 0)\n\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t    \"enclosure logical id(0x%016llx), slot(%d) \\n\",\n\t\t\t    (unsigned long long)\n\t\t\t    sas_device->enclosure_logical_id,\n\t\t\t    sas_device->slot);\n\t\tif (sas_device->connector_name[0] != '\\0')\n\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t    \"enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t    sas_device->enclosure_level,\n\t\t\t    sas_device->connector_name);\n\t\tif (sas_device->is_chassis_slot_valid)\n\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t    \"chassis slot(0x%04x)\\n\",\n\t\t\t    sas_device->chassis_slot);\n\t} else {\n\t\tif (sas_device->enclosure_handle != 0)\n\t\t\tioc_info(ioc, \"enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t (u64)sas_device->enclosure_logical_id,\n\t\t\t\t sas_device->slot);\n\t\tif (sas_device->connector_name[0] != '\\0')\n\t\t\tioc_info(ioc, \"enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t sas_device->enclosure_level,\n\t\t\t\t sas_device->connector_name);\n\t\tif (sas_device->is_chassis_slot_valid)\n\t\t\tioc_info(ioc, \"chassis slot(0x%04x)\\n\",\n\t\t\t\t sas_device->chassis_slot);\n\t}\n}\n\n/**\n * _scsih_sas_device_remove - remove sas_device from list.\n * @ioc: per adapter object\n * @sas_device: the sas_device object\n * Context: This function will acquire ioc->sas_device_lock.\n *\n * If sas_device is on the list, remove it and decrement its reference count.\n */\nstatic void\n_scsih_sas_device_remove(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_device *sas_device)\n{\n\tunsigned long flags;\n\n\tif (!sas_device)\n\t\treturn;\n\tioc_info(ioc, \"removing handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t sas_device->handle, (u64)sas_device->sas_address);\n\n\t_scsih_display_enclosure_chassis_info(ioc, sas_device, NULL, NULL);\n\n\t/*\n\t * The lock serializes access to the list, but we still need to verify\n\t * that nobody removed the entry while we were waiting on the lock.\n\t */\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tif (!list_empty(&sas_device->list)) {\n\t\tlist_del_init(&sas_device->list);\n\t\tsas_device_put(sas_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n}\n\n/**\n * _scsih_device_remove_by_handle - removing device object by handle\n * @ioc: per adapter object\n * @handle: device handle\n */\nstatic void\n_scsih_device_remove_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _sas_device *sas_device;\n\tunsigned long flags;\n\n\tif (ioc->shost_recovery)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_handle(ioc, handle);\n\tif (sas_device) {\n\t\tlist_del_init(&sas_device->list);\n\t\tsas_device_put(sas_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\tif (sas_device) {\n\t\t_scsih_remove_device(ioc, sas_device);\n\t\tsas_device_put(sas_device);\n\t}\n}\n\n/**\n * mpt3sas_device_remove_by_sas_address - removing device object by\n *\t\t\t\t\tsas address & port number\n * @ioc: per adapter object\n * @sas_address: device sas_address\n * @port: hba port entry\n *\n * Return nothing.\n */\nvoid\nmpt3sas_device_remove_by_sas_address(struct MPT3SAS_ADAPTER *ioc,\n\tu64 sas_address, struct hba_port *port)\n{\n\tstruct _sas_device *sas_device;\n\tunsigned long flags;\n\n\tif (ioc->shost_recovery)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_addr(ioc, sas_address, port);\n\tif (sas_device) {\n\t\tlist_del_init(&sas_device->list);\n\t\tsas_device_put(sas_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\tif (sas_device) {\n\t\t_scsih_remove_device(ioc, sas_device);\n\t\tsas_device_put(sas_device);\n\t}\n}\n\n/**\n * _scsih_sas_device_add - insert sas_device to the list.\n * @ioc: per adapter object\n * @sas_device: the sas_device object\n * Context: This function will acquire ioc->sas_device_lock.\n *\n * Adding new object to the ioc->sas_device_list.\n */\nstatic void\n_scsih_sas_device_add(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_device *sas_device)\n{\n\tunsigned long flags;\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t    __func__, sas_device->handle,\n\t\t\t    (u64)sas_device->sas_address));\n\n\tdewtprintk(ioc, _scsih_display_enclosure_chassis_info(ioc, sas_device,\n\t    NULL, NULL));\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device_get(sas_device);\n\tlist_add_tail(&sas_device->list, &ioc->sas_device_list);\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\tif (ioc->hide_drives) {\n\t\tclear_bit(sas_device->handle, ioc->pend_os_device_add);\n\t\treturn;\n\t}\n\n\tif (!mpt3sas_transport_port_add(ioc, sas_device->handle,\n\t     sas_device->sas_address_parent, sas_device->port)) {\n\t\t_scsih_sas_device_remove(ioc, sas_device);\n\t} else if (!sas_device->starget) {\n\t\t/*\n\t\t * When asyn scanning is enabled, its not possible to remove\n\t\t * devices while scanning is turned on due to an oops in\n\t\t * scsi_sysfs_add_sdev()->add_device()->sysfs_addrm_start()\n\t\t */\n\t\tif (!ioc->is_driver_loading) {\n\t\t\tmpt3sas_transport_port_remove(ioc,\n\t\t\t    sas_device->sas_address,\n\t\t\t    sas_device->sas_address_parent,\n\t\t\t    sas_device->port);\n\t\t\t_scsih_sas_device_remove(ioc, sas_device);\n\t\t}\n\t} else\n\t\tclear_bit(sas_device->handle, ioc->pend_os_device_add);\n}\n\n/**\n * _scsih_sas_device_init_add - insert sas_device to the list.\n * @ioc: per adapter object\n * @sas_device: the sas_device object\n * Context: This function will acquire ioc->sas_device_lock.\n *\n * Adding new object at driver load time to the ioc->sas_device_init_list.\n */\nstatic void\n_scsih_sas_device_init_add(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_device *sas_device)\n{\n\tunsigned long flags;\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t    __func__, sas_device->handle,\n\t\t\t    (u64)sas_device->sas_address));\n\n\tdewtprintk(ioc, _scsih_display_enclosure_chassis_info(ioc, sas_device,\n\t    NULL, NULL));\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device_get(sas_device);\n\tlist_add_tail(&sas_device->list, &ioc->sas_device_init_list);\n\t_scsih_determine_boot_device(ioc, sas_device, 0);\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n}\n\n\nstatic struct _pcie_device *\n__mpt3sas_get_pdev_by_wwid(struct MPT3SAS_ADAPTER *ioc, u64 wwid)\n{\n\tstruct _pcie_device *pcie_device;\n\n\tassert_spin_locked(&ioc->pcie_device_lock);\n\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_list, list)\n\t\tif (pcie_device->wwid == wwid)\n\t\t\tgoto found_device;\n\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_init_list, list)\n\t\tif (pcie_device->wwid == wwid)\n\t\t\tgoto found_device;\n\n\treturn NULL;\n\nfound_device:\n\tpcie_device_get(pcie_device);\n\treturn pcie_device;\n}\n\n\n/**\n * mpt3sas_get_pdev_by_wwid - pcie device search\n * @ioc: per adapter object\n * @wwid: wwid\n *\n * Context: This function will acquire ioc->pcie_device_lock and will release\n * before returning the pcie_device object.\n *\n * This searches for pcie_device based on wwid, then return pcie_device object.\n */\nstatic struct _pcie_device *\nmpt3sas_get_pdev_by_wwid(struct MPT3SAS_ADAPTER *ioc, u64 wwid)\n{\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tpcie_device = __mpt3sas_get_pdev_by_wwid(ioc, wwid);\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\treturn pcie_device;\n}\n\n\nstatic struct _pcie_device *\n__mpt3sas_get_pdev_by_idchannel(struct MPT3SAS_ADAPTER *ioc, int id,\n\tint channel)\n{\n\tstruct _pcie_device *pcie_device;\n\n\tassert_spin_locked(&ioc->pcie_device_lock);\n\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_list, list)\n\t\tif (pcie_device->id == id && pcie_device->channel == channel)\n\t\t\tgoto found_device;\n\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_init_list, list)\n\t\tif (pcie_device->id == id && pcie_device->channel == channel)\n\t\t\tgoto found_device;\n\n\treturn NULL;\n\nfound_device:\n\tpcie_device_get(pcie_device);\n\treturn pcie_device;\n}\n\nstatic struct _pcie_device *\n__mpt3sas_get_pdev_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _pcie_device *pcie_device;\n\n\tassert_spin_locked(&ioc->pcie_device_lock);\n\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_list, list)\n\t\tif (pcie_device->handle == handle)\n\t\t\tgoto found_device;\n\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_init_list, list)\n\t\tif (pcie_device->handle == handle)\n\t\t\tgoto found_device;\n\n\treturn NULL;\n\nfound_device:\n\tpcie_device_get(pcie_device);\n\treturn pcie_device;\n}\n\n\n/**\n * mpt3sas_get_pdev_by_handle - pcie device search\n * @ioc: per adapter object\n * @handle: Firmware device handle\n *\n * Context: This function will acquire ioc->pcie_device_lock and will release\n * before returning the pcie_device object.\n *\n * This searches for pcie_device based on handle, then return pcie_device\n * object.\n */\nstruct _pcie_device *\nmpt3sas_get_pdev_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tpcie_device = __mpt3sas_get_pdev_by_handle(ioc, handle);\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\treturn pcie_device;\n}\n\n/**\n * _scsih_set_nvme_max_shutdown_latency - Update max_shutdown_latency.\n * @ioc: per adapter object\n * Context: This function will acquire ioc->pcie_device_lock\n *\n * Update ioc->max_shutdown_latency to that NVMe drives RTD3 Entry Latency\n * which has reported maximum among all available NVMe drives.\n * Minimum max_shutdown_latency will be six seconds.\n */\nstatic void\n_scsih_set_nvme_max_shutdown_latency(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\tu16 shutdown_latency = IO_UNIT_CONTROL_SHUTDOWN_TIMEOUT;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_list, list) {\n\t\tif (pcie_device->shutdown_latency) {\n\t\t\tif (shutdown_latency < pcie_device->shutdown_latency)\n\t\t\t\tshutdown_latency =\n\t\t\t\t\tpcie_device->shutdown_latency;\n\t\t}\n\t}\n\tioc->max_shutdown_latency = shutdown_latency;\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n}\n\n/**\n * _scsih_pcie_device_remove - remove pcie_device from list.\n * @ioc: per adapter object\n * @pcie_device: the pcie_device object\n * Context: This function will acquire ioc->pcie_device_lock.\n *\n * If pcie_device is on the list, remove it and decrement its reference count.\n */\nstatic void\n_scsih_pcie_device_remove(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _pcie_device *pcie_device)\n{\n\tunsigned long flags;\n\tint was_on_pcie_device_list = 0;\n\tu8 update_latency = 0;\n\n\tif (!pcie_device)\n\t\treturn;\n\tioc_info(ioc, \"removing handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t pcie_device->handle, (u64)pcie_device->wwid);\n\tif (pcie_device->enclosure_handle != 0)\n\t\tioc_info(ioc, \"removing enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t (u64)pcie_device->enclosure_logical_id,\n\t\t\t pcie_device->slot);\n\tif (pcie_device->connector_name[0] != '\\0')\n\t\tioc_info(ioc, \"removing enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t pcie_device->enclosure_level,\n\t\t\t pcie_device->connector_name);\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tif (!list_empty(&pcie_device->list)) {\n\t\tlist_del_init(&pcie_device->list);\n\t\twas_on_pcie_device_list = 1;\n\t}\n\tif (pcie_device->shutdown_latency == ioc->max_shutdown_latency)\n\t\tupdate_latency = 1;\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\tif (was_on_pcie_device_list) {\n\t\tkfree(pcie_device->serial_number);\n\t\tpcie_device_put(pcie_device);\n\t}\n\n\t/*\n\t * This device's RTD3 Entry Latency matches IOC's\n\t * max_shutdown_latency. Recalculate IOC's max_shutdown_latency\n\t * from the available drives as current drive is getting removed.\n\t */\n\tif (update_latency)\n\t\t_scsih_set_nvme_max_shutdown_latency(ioc);\n}\n\n\n/**\n * _scsih_pcie_device_remove_by_handle - removing pcie device object by handle\n * @ioc: per adapter object\n * @handle: device handle\n */\nstatic void\n_scsih_pcie_device_remove_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\tint was_on_pcie_device_list = 0;\n\tu8 update_latency = 0;\n\n\tif (ioc->shost_recovery)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tpcie_device = __mpt3sas_get_pdev_by_handle(ioc, handle);\n\tif (pcie_device) {\n\t\tif (!list_empty(&pcie_device->list)) {\n\t\t\tlist_del_init(&pcie_device->list);\n\t\t\twas_on_pcie_device_list = 1;\n\t\t\tpcie_device_put(pcie_device);\n\t\t}\n\t\tif (pcie_device->shutdown_latency == ioc->max_shutdown_latency)\n\t\t\tupdate_latency = 1;\n\t}\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\tif (was_on_pcie_device_list) {\n\t\t_scsih_pcie_device_remove_from_sml(ioc, pcie_device);\n\t\tpcie_device_put(pcie_device);\n\t}\n\n\t/*\n\t * This device's RTD3 Entry Latency matches IOC's\n\t * max_shutdown_latency. Recalculate IOC's max_shutdown_latency\n\t * from the available drives as current drive is getting removed.\n\t */\n\tif (update_latency)\n\t\t_scsih_set_nvme_max_shutdown_latency(ioc);\n}\n\n/**\n * _scsih_pcie_device_add - add pcie_device object\n * @ioc: per adapter object\n * @pcie_device: pcie_device object\n *\n * This is added to the pcie_device_list link list.\n */\nstatic void\n_scsih_pcie_device_add(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _pcie_device *pcie_device)\n{\n\tunsigned long flags;\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: handle (0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t    __func__,\n\t\t\t    pcie_device->handle, (u64)pcie_device->wwid));\n\tif (pcie_device->enclosure_handle != 0)\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enclosure logical id(0x%016llx), slot( %d)\\n\",\n\t\t\t\t    __func__,\n\t\t\t\t    (u64)pcie_device->enclosure_logical_id,\n\t\t\t\t    pcie_device->slot));\n\tif (pcie_device->connector_name[0] != '\\0')\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t    __func__, pcie_device->enclosure_level,\n\t\t\t\t    pcie_device->connector_name));\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tpcie_device_get(pcie_device);\n\tlist_add_tail(&pcie_device->list, &ioc->pcie_device_list);\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\tif (pcie_device->access_status ==\n\t    MPI26_PCIEDEV0_ASTATUS_DEVICE_BLOCKED) {\n\t\tclear_bit(pcie_device->handle, ioc->pend_os_device_add);\n\t\treturn;\n\t}\n\tif (scsi_add_device(ioc->shost, PCIE_CHANNEL, pcie_device->id, 0)) {\n\t\t_scsih_pcie_device_remove(ioc, pcie_device);\n\t} else if (!pcie_device->starget) {\n\t\tif (!ioc->is_driver_loading) {\n/*TODO-- Need to find out whether this condition will occur or not*/\n\t\t\tclear_bit(pcie_device->handle, ioc->pend_os_device_add);\n\t\t}\n\t} else\n\t\tclear_bit(pcie_device->handle, ioc->pend_os_device_add);\n}\n\n/*\n * _scsih_pcie_device_init_add - insert pcie_device to the init list.\n * @ioc: per adapter object\n * @pcie_device: the pcie_device object\n * Context: This function will acquire ioc->pcie_device_lock.\n *\n * Adding new object at driver load time to the ioc->pcie_device_init_list.\n */\nstatic void\n_scsih_pcie_device_init_add(struct MPT3SAS_ADAPTER *ioc,\n\t\t\t\tstruct _pcie_device *pcie_device)\n{\n\tunsigned long flags;\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: handle (0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t    __func__,\n\t\t\t    pcie_device->handle, (u64)pcie_device->wwid));\n\tif (pcie_device->enclosure_handle != 0)\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enclosure logical id(0x%016llx), slot( %d)\\n\",\n\t\t\t\t    __func__,\n\t\t\t\t    (u64)pcie_device->enclosure_logical_id,\n\t\t\t\t    pcie_device->slot));\n\tif (pcie_device->connector_name[0] != '\\0')\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t    __func__, pcie_device->enclosure_level,\n\t\t\t\t    pcie_device->connector_name));\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tpcie_device_get(pcie_device);\n\tlist_add_tail(&pcie_device->list, &ioc->pcie_device_init_list);\n\tif (pcie_device->access_status !=\n\t    MPI26_PCIEDEV0_ASTATUS_DEVICE_BLOCKED)\n\t\t_scsih_determine_boot_device(ioc, pcie_device, PCIE_CHANNEL);\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n}\n/**\n * _scsih_raid_device_find_by_id - raid device search\n * @ioc: per adapter object\n * @id: sas device target id\n * @channel: sas device channel\n * Context: Calling function should acquire ioc->raid_device_lock\n *\n * This searches for raid_device based on target id, then return raid_device\n * object.\n */\nstatic struct _raid_device *\n_scsih_raid_device_find_by_id(struct MPT3SAS_ADAPTER *ioc, int id, int channel)\n{\n\tstruct _raid_device *raid_device, *r;\n\n\tr = NULL;\n\tlist_for_each_entry(raid_device, &ioc->raid_device_list, list) {\n\t\tif (raid_device->id == id && raid_device->channel == channel) {\n\t\t\tr = raid_device;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\treturn r;\n}\n\n/**\n * mpt3sas_raid_device_find_by_handle - raid device search\n * @ioc: per adapter object\n * @handle: sas device handle (assigned by firmware)\n * Context: Calling function should acquire ioc->raid_device_lock\n *\n * This searches for raid_device based on handle, then return raid_device\n * object.\n */\nstruct _raid_device *\nmpt3sas_raid_device_find_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _raid_device *raid_device, *r;\n\n\tr = NULL;\n\tlist_for_each_entry(raid_device, &ioc->raid_device_list, list) {\n\t\tif (raid_device->handle != handle)\n\t\t\tcontinue;\n\t\tr = raid_device;\n\t\tgoto out;\n\t}\n\n out:\n\treturn r;\n}\n\n/**\n * _scsih_raid_device_find_by_wwid - raid device search\n * @ioc: per adapter object\n * @wwid: ?\n * Context: Calling function should acquire ioc->raid_device_lock\n *\n * This searches for raid_device based on wwid, then return raid_device\n * object.\n */\nstatic struct _raid_device *\n_scsih_raid_device_find_by_wwid(struct MPT3SAS_ADAPTER *ioc, u64 wwid)\n{\n\tstruct _raid_device *raid_device, *r;\n\n\tr = NULL;\n\tlist_for_each_entry(raid_device, &ioc->raid_device_list, list) {\n\t\tif (raid_device->wwid != wwid)\n\t\t\tcontinue;\n\t\tr = raid_device;\n\t\tgoto out;\n\t}\n\n out:\n\treturn r;\n}\n\n/**\n * _scsih_raid_device_add - add raid_device object\n * @ioc: per adapter object\n * @raid_device: raid_device object\n *\n * This is added to the raid_device_list link list.\n */\nstatic void\n_scsih_raid_device_add(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _raid_device *raid_device)\n{\n\tunsigned long flags;\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t    __func__,\n\t\t\t    raid_device->handle, (u64)raid_device->wwid));\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\tlist_add_tail(&raid_device->list, &ioc->raid_device_list);\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n}\n\n/**\n * _scsih_raid_device_remove - delete raid_device object\n * @ioc: per adapter object\n * @raid_device: raid_device object\n *\n */\nstatic void\n_scsih_raid_device_remove(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _raid_device *raid_device)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\tlist_del(&raid_device->list);\n\tkfree(raid_device);\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n}\n\n/**\n * mpt3sas_scsih_expander_find_by_handle - expander device search\n * @ioc: per adapter object\n * @handle: expander handle (assigned by firmware)\n * Context: Calling function should acquire ioc->sas_device_lock\n *\n * This searches for expander device based on handle, then returns the\n * sas_node object.\n */\nstruct _sas_node *\nmpt3sas_scsih_expander_find_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _sas_node *sas_expander, *r;\n\n\tr = NULL;\n\tlist_for_each_entry(sas_expander, &ioc->sas_expander_list, list) {\n\t\tif (sas_expander->handle != handle)\n\t\t\tcontinue;\n\t\tr = sas_expander;\n\t\tgoto out;\n\t}\n out:\n\treturn r;\n}\n\n/**\n * mpt3sas_scsih_enclosure_find_by_handle - exclosure device search\n * @ioc: per adapter object\n * @handle: enclosure handle (assigned by firmware)\n * Context: Calling function should acquire ioc->sas_device_lock\n *\n * This searches for enclosure device based on handle, then returns the\n * enclosure object.\n */\nstatic struct _enclosure_node *\nmpt3sas_scsih_enclosure_find_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _enclosure_node *enclosure_dev, *r;\n\n\tr = NULL;\n\tlist_for_each_entry(enclosure_dev, &ioc->enclosure_list, list) {\n\t\tif (le16_to_cpu(enclosure_dev->pg0.EnclosureHandle) != handle)\n\t\t\tcontinue;\n\t\tr = enclosure_dev;\n\t\tgoto out;\n\t}\nout:\n\treturn r;\n}\n/**\n * mpt3sas_scsih_expander_find_by_sas_address - expander device search\n * @ioc: per adapter object\n * @sas_address: sas address\n * @port: hba port entry\n * Context: Calling function should acquire ioc->sas_node_lock.\n *\n * This searches for expander device based on sas_address & port number,\n * then returns the sas_node object.\n */\nstruct _sas_node *\nmpt3sas_scsih_expander_find_by_sas_address(struct MPT3SAS_ADAPTER *ioc,\n\tu64 sas_address, struct hba_port *port)\n{\n\tstruct _sas_node *sas_expander, *r = NULL;\n\n\tif (!port)\n\t\treturn r;\n\n\tlist_for_each_entry(sas_expander, &ioc->sas_expander_list, list) {\n\t\tif (sas_expander->sas_address != sas_address)\n\t\t\tcontinue;\n\t\tif (sas_expander->port != port)\n\t\t\tcontinue;\n\t\tr = sas_expander;\n\t\tgoto out;\n\t}\n out:\n\treturn r;\n}\n\n/**\n * _scsih_expander_node_add - insert expander device to the list.\n * @ioc: per adapter object\n * @sas_expander: the sas_device object\n * Context: This function will acquire ioc->sas_node_lock.\n *\n * Adding new object to the ioc->sas_expander_list.\n */\nstatic void\n_scsih_expander_node_add(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_node *sas_expander)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tlist_add_tail(&sas_expander->list, &ioc->sas_expander_list);\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n}\n\n/**\n * _scsih_is_end_device - determines if device is an end device\n * @device_info: bitfield providing information about the device.\n * Context: none\n *\n * Return: 1 if end device.\n */\nstatic int\n_scsih_is_end_device(u32 device_info)\n{\n\tif (device_info & MPI2_SAS_DEVICE_INFO_END_DEVICE &&\n\t\t((device_info & MPI2_SAS_DEVICE_INFO_SSP_TARGET) |\n\t\t(device_info & MPI2_SAS_DEVICE_INFO_STP_TARGET) |\n\t\t(device_info & MPI2_SAS_DEVICE_INFO_SATA_DEVICE)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n/**\n * _scsih_is_nvme_pciescsi_device - determines if\n *\t\t\tdevice is an pcie nvme/scsi device\n * @device_info: bitfield providing information about the device.\n * Context: none\n *\n * Returns 1 if device is pcie device type nvme/scsi.\n */\nstatic int\n_scsih_is_nvme_pciescsi_device(u32 device_info)\n{\n\tif (((device_info & MPI26_PCIE_DEVINFO_MASK_DEVICE_TYPE)\n\t    == MPI26_PCIE_DEVINFO_NVME) ||\n\t    ((device_info & MPI26_PCIE_DEVINFO_MASK_DEVICE_TYPE)\n\t    == MPI26_PCIE_DEVINFO_SCSI))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n/**\n * _scsih_scsi_lookup_find_by_target - search for matching channel:id\n * @ioc: per adapter object\n * @id: target id\n * @channel: channel\n * Context: This function will acquire ioc->scsi_lookup_lock.\n *\n * This will search for a matching channel:id in the scsi_lookup array,\n * returning 1 if found.\n */\nstatic u8\n_scsih_scsi_lookup_find_by_target(struct MPT3SAS_ADAPTER *ioc, int id,\n\tint channel)\n{\n\tint smid;\n\tstruct scsi_cmnd *scmd;\n\n\tfor (smid = 1;\n\t     smid <= ioc->shost->can_queue; smid++) {\n\t\tscmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);\n\t\tif (!scmd)\n\t\t\tcontinue;\n\t\tif (scmd->device->id == id &&\n\t\t    scmd->device->channel == channel)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/**\n * _scsih_scsi_lookup_find_by_lun - search for matching channel:id:lun\n * @ioc: per adapter object\n * @id: target id\n * @lun: lun number\n * @channel: channel\n * Context: This function will acquire ioc->scsi_lookup_lock.\n *\n * This will search for a matching channel:id:lun in the scsi_lookup array,\n * returning 1 if found.\n */\nstatic u8\n_scsih_scsi_lookup_find_by_lun(struct MPT3SAS_ADAPTER *ioc, int id,\n\tunsigned int lun, int channel)\n{\n\tint smid;\n\tstruct scsi_cmnd *scmd;\n\n\tfor (smid = 1; smid <= ioc->shost->can_queue; smid++) {\n\n\t\tscmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);\n\t\tif (!scmd)\n\t\t\tcontinue;\n\t\tif (scmd->device->id == id &&\n\t\t    scmd->device->channel == channel &&\n\t\t    scmd->device->lun == lun)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/**\n * mpt3sas_scsih_scsi_lookup_get - returns scmd entry\n * @ioc: per adapter object\n * @smid: system request message index\n *\n * Return: the smid stored scmd pointer.\n * Then will dereference the stored scmd pointer.\n */\nstruct scsi_cmnd *\nmpt3sas_scsih_scsi_lookup_get(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tstruct scsi_cmnd *scmd = NULL;\n\tstruct scsiio_tracker *st;\n\tMpi25SCSIIORequest_t *mpi_request;\n\tu16 tag = smid - 1;\n\n\tif (smid > 0  &&\n\t    smid <= ioc->scsiio_depth - INTERNAL_SCSIIO_CMDS_COUNT) {\n\t\tu32 unique_tag =\n\t\t    ioc->io_queue_num[tag] << BLK_MQ_UNIQUE_TAG_BITS | tag;\n\n\t\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\n\t\t/*\n\t\t * If SCSI IO request is outstanding at driver level then\n\t\t * DevHandle filed must be non-zero. If DevHandle is zero\n\t\t * then it means that this smid is free at driver level,\n\t\t * so return NULL.\n\t\t */\n\t\tif (!mpi_request->DevHandle)\n\t\t\treturn scmd;\n\n\t\tscmd = scsi_host_find_tag(ioc->shost, unique_tag);\n\t\tif (scmd) {\n\t\t\tst = scsi_cmd_priv(scmd);\n\t\t\tif (st->cb_idx == 0xFF || st->smid == 0)\n\t\t\t\tscmd = NULL;\n\t\t}\n\t}\n\treturn scmd;\n}\n\n/**\n * scsih_change_queue_depth - setting device queue depth\n * @sdev: scsi device struct\n * @qdepth: requested queue depth\n *\n * Return: queue depth.\n */\nstatic int\nscsih_change_queue_depth(struct scsi_device *sdev, int qdepth)\n{\n\tstruct Scsi_Host *shost = sdev->host;\n\tint max_depth;\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct _sas_device *sas_device;\n\tunsigned long flags;\n\n\tmax_depth = shost->can_queue;\n\n\t/*\n\t * limit max device queue for SATA to 32 if enable_sdev_max_qd\n\t * is disabled.\n\t */\n\tif (ioc->enable_sdev_max_qd || ioc->is_gen35_ioc)\n\t\tgoto not_sata;\n\n\tsas_device_priv_data = sdev->hostdata;\n\tif (!sas_device_priv_data)\n\t\tgoto not_sata;\n\tsas_target_priv_data = sas_device_priv_data->sas_target;\n\tif (!sas_target_priv_data)\n\t\tgoto not_sata;\n\tif ((sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME))\n\t\tgoto not_sata;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_from_target(ioc, sas_target_priv_data);\n\tif (sas_device) {\n\t\tif (sas_device->device_info & MPI2_SAS_DEVICE_INFO_SATA_DEVICE)\n\t\t\tmax_depth = MPT3SAS_SATA_QUEUE_DEPTH;\n\n\t\tsas_device_put(sas_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n not_sata:\n\n\tif (!sdev->tagged_supported)\n\t\tmax_depth = 1;\n\tif (qdepth > max_depth)\n\t\tqdepth = max_depth;\n\tscsi_change_queue_depth(sdev, qdepth);\n\tsdev_printk(KERN_INFO, sdev,\n\t    \"qdepth(%d), tagged(%d), scsi_level(%d), cmd_que(%d)\\n\",\n\t    sdev->queue_depth, sdev->tagged_supported,\n\t    sdev->scsi_level, ((sdev->inquiry[7] & 2) >> 1));\n\treturn sdev->queue_depth;\n}\n\n/**\n * mpt3sas_scsih_change_queue_depth - setting device queue depth\n * @sdev: scsi device struct\n * @qdepth: requested queue depth\n *\n * Returns nothing.\n */\nvoid\nmpt3sas_scsih_change_queue_depth(struct scsi_device *sdev, int qdepth)\n{\n\tstruct Scsi_Host *shost = sdev->host;\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\tif (ioc->enable_sdev_max_qd)\n\t\tqdepth = shost->can_queue;\n\n\tscsih_change_queue_depth(sdev, qdepth);\n}\n\n/**\n * scsih_target_alloc - target add routine\n * @starget: scsi target struct\n *\n * Return: 0 if ok. Any other return is assumed to be an error and\n * the device is ignored.\n */\nstatic int\nscsih_target_alloc(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct _sas_device *sas_device;\n\tstruct _raid_device *raid_device;\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\tstruct sas_rphy *rphy;\n\n\tsas_target_priv_data = kzalloc(sizeof(*sas_target_priv_data),\n\t\t\t\t       GFP_KERNEL);\n\tif (!sas_target_priv_data)\n\t\treturn -ENOMEM;\n\n\tstarget->hostdata = sas_target_priv_data;\n\tsas_target_priv_data->starget = starget;\n\tsas_target_priv_data->handle = MPT3SAS_INVALID_DEVICE_HANDLE;\n\n\t/* RAID volumes */\n\tif (starget->channel == RAID_CHANNEL) {\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\traid_device = _scsih_raid_device_find_by_id(ioc, starget->id,\n\t\t    starget->channel);\n\t\tif (raid_device) {\n\t\t\tsas_target_priv_data->handle = raid_device->handle;\n\t\t\tsas_target_priv_data->sas_address = raid_device->wwid;\n\t\t\tsas_target_priv_data->flags |= MPT_TARGET_FLAGS_VOLUME;\n\t\t\tif (ioc->is_warpdrive)\n\t\t\t\tsas_target_priv_data->raid_device = raid_device;\n\t\t\traid_device->starget = starget;\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t\treturn 0;\n\t}\n\n\t/* PCIe devices */\n\tif (starget->channel == PCIE_CHANNEL) {\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\tpcie_device = __mpt3sas_get_pdev_by_idchannel(ioc, starget->id,\n\t\t\tstarget->channel);\n\t\tif (pcie_device) {\n\t\t\tsas_target_priv_data->handle = pcie_device->handle;\n\t\t\tsas_target_priv_data->sas_address = pcie_device->wwid;\n\t\t\tsas_target_priv_data->port = NULL;\n\t\t\tsas_target_priv_data->pcie_dev = pcie_device;\n\t\t\tpcie_device->starget = starget;\n\t\t\tpcie_device->id = starget->id;\n\t\t\tpcie_device->channel = starget->channel;\n\t\t\tsas_target_priv_data->flags |=\n\t\t\t\tMPT_TARGET_FLAGS_PCIE_DEVICE;\n\t\t\tif (pcie_device->fast_path)\n\t\t\t\tsas_target_priv_data->flags |=\n\t\t\t\t\tMPT_TARGET_FASTPATH_IO;\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\treturn 0;\n\t}\n\n\t/* sas/sata devices */\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\trphy = dev_to_rphy(starget->dev.parent);\n\tsas_device = __mpt3sas_get_sdev_by_rphy(ioc, rphy);\n\n\tif (sas_device) {\n\t\tsas_target_priv_data->handle = sas_device->handle;\n\t\tsas_target_priv_data->sas_address = sas_device->sas_address;\n\t\tsas_target_priv_data->port = sas_device->port;\n\t\tsas_target_priv_data->sas_dev = sas_device;\n\t\tsas_device->starget = starget;\n\t\tsas_device->id = starget->id;\n\t\tsas_device->channel = starget->channel;\n\t\tif (test_bit(sas_device->handle, ioc->pd_handles))\n\t\t\tsas_target_priv_data->flags |=\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT;\n\t\tif (sas_device->fast_path)\n\t\t\tsas_target_priv_data->flags |=\n\t\t\t\t\tMPT_TARGET_FASTPATH_IO;\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\treturn 0;\n}\n\n/**\n * scsih_target_destroy - target destroy routine\n * @starget: scsi target struct\n */\nstatic void\nscsih_target_destroy(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct _sas_device *sas_device;\n\tstruct _raid_device *raid_device;\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\n\tsas_target_priv_data = starget->hostdata;\n\tif (!sas_target_priv_data)\n\t\treturn;\n\n\tif (starget->channel == RAID_CHANNEL) {\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\traid_device = _scsih_raid_device_find_by_id(ioc, starget->id,\n\t\t    starget->channel);\n\t\tif (raid_device) {\n\t\t\traid_device->starget = NULL;\n\t\t\traid_device->sdev = NULL;\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t\tgoto out;\n\t}\n\n\tif (starget->channel == PCIE_CHANNEL) {\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\tpcie_device = __mpt3sas_get_pdev_from_target(ioc,\n\t\t\t\t\t\t\tsas_target_priv_data);\n\t\tif (pcie_device && (pcie_device->starget == starget) &&\n\t\t\t(pcie_device->id == starget->id) &&\n\t\t\t(pcie_device->channel == starget->channel))\n\t\t\tpcie_device->starget = NULL;\n\n\t\tif (pcie_device) {\n\t\t\t/*\n\t\t\t * Corresponding get() is in _scsih_target_alloc()\n\t\t\t */\n\t\t\tsas_target_priv_data->pcie_dev = NULL;\n\t\t\tpcie_device_put(pcie_device);\n\t\t\tpcie_device_put(pcie_device);\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_from_target(ioc, sas_target_priv_data);\n\tif (sas_device && (sas_device->starget == starget) &&\n\t    (sas_device->id == starget->id) &&\n\t    (sas_device->channel == starget->channel))\n\t\tsas_device->starget = NULL;\n\n\tif (sas_device) {\n\t\t/*\n\t\t * Corresponding get() is in _scsih_target_alloc()\n\t\t */\n\t\tsas_target_priv_data->sas_dev = NULL;\n\t\tsas_device_put(sas_device);\n\n\t\tsas_device_put(sas_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n out:\n\tkfree(sas_target_priv_data);\n\tstarget->hostdata = NULL;\n}\n\n/**\n * scsih_slave_alloc - device add routine\n * @sdev: scsi device struct\n *\n * Return: 0 if ok. Any other return is assumed to be an error and\n * the device is ignored.\n */\nstatic int\nscsih_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_target *starget;\n\tstruct _raid_device *raid_device;\n\tstruct _sas_device *sas_device;\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\n\tsas_device_priv_data = kzalloc(sizeof(*sas_device_priv_data),\n\t\t\t\t       GFP_KERNEL);\n\tif (!sas_device_priv_data)\n\t\treturn -ENOMEM;\n\n\tsas_device_priv_data->lun = sdev->lun;\n\tsas_device_priv_data->flags = MPT_DEVICE_FLAGS_INIT;\n\n\tstarget = scsi_target(sdev);\n\tsas_target_priv_data = starget->hostdata;\n\tsas_target_priv_data->num_luns++;\n\tsas_device_priv_data->sas_target = sas_target_priv_data;\n\tsdev->hostdata = sas_device_priv_data;\n\tif ((sas_target_priv_data->flags & MPT_TARGET_FLAGS_RAID_COMPONENT))\n\t\tsdev->no_uld_attach = 1;\n\n\tshost = dev_to_shost(&starget->dev);\n\tioc = shost_priv(shost);\n\tif (starget->channel == RAID_CHANNEL) {\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\traid_device = _scsih_raid_device_find_by_id(ioc,\n\t\t    starget->id, starget->channel);\n\t\tif (raid_device)\n\t\t\traid_device->sdev = sdev; /* raid is single lun */\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t}\n\tif (starget->channel == PCIE_CHANNEL) {\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\tpcie_device = __mpt3sas_get_pdev_by_wwid(ioc,\n\t\t\t\tsas_target_priv_data->sas_address);\n\t\tif (pcie_device && (pcie_device->starget == NULL)) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"%s : pcie_device->starget set to starget @ %d\\n\",\n\t\t\t    __func__, __LINE__);\n\t\t\tpcie_device->starget = starget;\n\t\t}\n\n\t\tif (pcie_device)\n\t\t\tpcie_device_put(pcie_device);\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\t} else  if (!(sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME)) {\n\t\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\t\tsas_device = __mpt3sas_get_sdev_by_addr(ioc,\n\t\t    sas_target_priv_data->sas_address,\n\t\t    sas_target_priv_data->port);\n\t\tif (sas_device && (sas_device->starget == NULL)) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\"%s : sas_device->starget set to starget @ %d\\n\",\n\t\t\t     __func__, __LINE__);\n\t\t\tsas_device->starget = starget;\n\t\t}\n\n\t\tif (sas_device)\n\t\t\tsas_device_put(sas_device);\n\n\t\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\t}\n\n\treturn 0;\n}\n\n/**\n * scsih_slave_destroy - device destroy routine\n * @sdev: scsi device struct\n */\nstatic void\nscsih_slave_destroy(struct scsi_device *sdev)\n{\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct scsi_target *starget;\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tstruct _sas_device *sas_device;\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\n\tif (!sdev->hostdata)\n\t\treturn;\n\n\tstarget = scsi_target(sdev);\n\tsas_target_priv_data = starget->hostdata;\n\tsas_target_priv_data->num_luns--;\n\n\tshost = dev_to_shost(&starget->dev);\n\tioc = shost_priv(shost);\n\n\tif (sas_target_priv_data->flags & MPT_TARGET_FLAGS_PCIE_DEVICE) {\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\tpcie_device = __mpt3sas_get_pdev_from_target(ioc,\n\t\t\t\tsas_target_priv_data);\n\t\tif (pcie_device && !sas_target_priv_data->num_luns)\n\t\t\tpcie_device->starget = NULL;\n\n\t\tif (pcie_device)\n\t\t\tpcie_device_put(pcie_device);\n\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\t} else if (!(sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME)) {\n\t\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\t\tsas_device = __mpt3sas_get_sdev_from_target(ioc,\n\t\t\t\tsas_target_priv_data);\n\t\tif (sas_device && !sas_target_priv_data->num_luns)\n\t\t\tsas_device->starget = NULL;\n\n\t\tif (sas_device)\n\t\t\tsas_device_put(sas_device);\n\t\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\t}\n\n\tkfree(sdev->hostdata);\n\tsdev->hostdata = NULL;\n}\n\n/**\n * _scsih_display_sata_capabilities - sata capabilities\n * @ioc: per adapter object\n * @handle: device handle\n * @sdev: scsi device struct\n */\nstatic void\n_scsih_display_sata_capabilities(struct MPT3SAS_ADAPTER *ioc,\n\tu16 handle, struct scsi_device *sdev)\n{\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tu32 ioc_status;\n\tu16 flags;\n\tu32 device_info;\n\n\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\n\t    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tflags = le16_to_cpu(sas_device_pg0.Flags);\n\tdevice_info = le32_to_cpu(sas_device_pg0.DeviceInfo);\n\n\tsdev_printk(KERN_INFO, sdev,\n\t    \"atapi(%s), ncq(%s), asyn_notify(%s), smart(%s), fua(%s), \"\n\t    \"sw_preserve(%s)\\n\",\n\t    (device_info & MPI2_SAS_DEVICE_INFO_ATAPI_DEVICE) ? \"y\" : \"n\",\n\t    (flags & MPI2_SAS_DEVICE0_FLAGS_SATA_NCQ_SUPPORTED) ? \"y\" : \"n\",\n\t    (flags & MPI2_SAS_DEVICE0_FLAGS_SATA_ASYNCHRONOUS_NOTIFY) ? \"y\" :\n\t    \"n\",\n\t    (flags & MPI2_SAS_DEVICE0_FLAGS_SATA_SMART_SUPPORTED) ? \"y\" : \"n\",\n\t    (flags & MPI2_SAS_DEVICE0_FLAGS_SATA_FUA_SUPPORTED) ? \"y\" : \"n\",\n\t    (flags & MPI2_SAS_DEVICE0_FLAGS_SATA_SW_PRESERVE) ? \"y\" : \"n\");\n}\n\n/*\n * raid transport support -\n * Enabled for SLES11 and newer, in older kernels the driver will panic when\n * unloading the driver followed by a load - I believe that the subroutine\n * raid_class_release() is not cleaning up properly.\n */\n\n/**\n * scsih_is_raid - return boolean indicating device is raid volume\n * @dev: the device struct object\n */\nstatic int\nscsih_is_raid(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(sdev->host);\n\n\tif (ioc->is_warpdrive)\n\t\treturn 0;\n\treturn (sdev->channel == RAID_CHANNEL) ? 1 : 0;\n}\n\nstatic int\nscsih_is_nvme(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\treturn (sdev->channel == PCIE_CHANNEL) ? 1 : 0;\n}\n\n/**\n * scsih_get_resync - get raid volume resync percent complete\n * @dev: the device struct object\n */\nstatic void\nscsih_get_resync(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(sdev->host);\n\tstatic struct _raid_device *raid_device;\n\tunsigned long flags;\n\tMpi2RaidVolPage0_t vol_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu32 volume_status_flags;\n\tu8 percent_complete;\n\tu16 handle;\n\n\tpercent_complete = 0;\n\thandle = 0;\n\tif (ioc->is_warpdrive)\n\t\tgoto out;\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\traid_device = _scsih_raid_device_find_by_id(ioc, sdev->id,\n\t    sdev->channel);\n\tif (raid_device) {\n\t\thandle = raid_device->handle;\n\t\tpercent_complete = raid_device->percent_complete;\n\t}\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\n\tif (!handle)\n\t\tgoto out;\n\n\tif (mpt3sas_config_get_raid_volume_pg0(ioc, &mpi_reply, &vol_pg0,\n\t     MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,\n\t     sizeof(Mpi2RaidVolPage0_t))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tpercent_complete = 0;\n\t\tgoto out;\n\t}\n\n\tvolume_status_flags = le32_to_cpu(vol_pg0.VolumeStatusFlags);\n\tif (!(volume_status_flags &\n\t    MPI2_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS))\n\t\tpercent_complete = 0;\n\n out:\n\n\tswitch (ioc->hba_mpi_version_belonged) {\n\tcase MPI2_VERSION:\n\t\traid_set_resync(mpt2sas_raid_template, dev, percent_complete);\n\t\tbreak;\n\tcase MPI25_VERSION:\n\tcase MPI26_VERSION:\n\t\traid_set_resync(mpt3sas_raid_template, dev, percent_complete);\n\t\tbreak;\n\t}\n}\n\n/**\n * scsih_get_state - get raid volume level\n * @dev: the device struct object\n */\nstatic void\nscsih_get_state(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(sdev->host);\n\tstatic struct _raid_device *raid_device;\n\tunsigned long flags;\n\tMpi2RaidVolPage0_t vol_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu32 volstate;\n\tenum raid_state state = RAID_STATE_UNKNOWN;\n\tu16 handle = 0;\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\traid_device = _scsih_raid_device_find_by_id(ioc, sdev->id,\n\t    sdev->channel);\n\tif (raid_device)\n\t\thandle = raid_device->handle;\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\n\tif (!raid_device)\n\t\tgoto out;\n\n\tif (mpt3sas_config_get_raid_volume_pg0(ioc, &mpi_reply, &vol_pg0,\n\t     MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,\n\t     sizeof(Mpi2RaidVolPage0_t))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\tvolstate = le32_to_cpu(vol_pg0.VolumeStatusFlags);\n\tif (volstate & MPI2_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS) {\n\t\tstate = RAID_STATE_RESYNCING;\n\t\tgoto out;\n\t}\n\n\tswitch (vol_pg0.VolumeState) {\n\tcase MPI2_RAID_VOL_STATE_OPTIMAL:\n\tcase MPI2_RAID_VOL_STATE_ONLINE:\n\t\tstate = RAID_STATE_ACTIVE;\n\t\tbreak;\n\tcase  MPI2_RAID_VOL_STATE_DEGRADED:\n\t\tstate = RAID_STATE_DEGRADED;\n\t\tbreak;\n\tcase MPI2_RAID_VOL_STATE_FAILED:\n\tcase MPI2_RAID_VOL_STATE_MISSING:\n\t\tstate = RAID_STATE_OFFLINE;\n\t\tbreak;\n\t}\n out:\n\tswitch (ioc->hba_mpi_version_belonged) {\n\tcase MPI2_VERSION:\n\t\traid_set_state(mpt2sas_raid_template, dev, state);\n\t\tbreak;\n\tcase MPI25_VERSION:\n\tcase MPI26_VERSION:\n\t\traid_set_state(mpt3sas_raid_template, dev, state);\n\t\tbreak;\n\t}\n}\n\n/**\n * _scsih_set_level - set raid level\n * @ioc: ?\n * @sdev: scsi device struct\n * @volume_type: volume type\n */\nstatic void\n_scsih_set_level(struct MPT3SAS_ADAPTER *ioc,\n\tstruct scsi_device *sdev, u8 volume_type)\n{\n\tenum raid_level level = RAID_LEVEL_UNKNOWN;\n\n\tswitch (volume_type) {\n\tcase MPI2_RAID_VOL_TYPE_RAID0:\n\t\tlevel = RAID_LEVEL_0;\n\t\tbreak;\n\tcase MPI2_RAID_VOL_TYPE_RAID10:\n\t\tlevel = RAID_LEVEL_10;\n\t\tbreak;\n\tcase MPI2_RAID_VOL_TYPE_RAID1E:\n\t\tlevel = RAID_LEVEL_1E;\n\t\tbreak;\n\tcase MPI2_RAID_VOL_TYPE_RAID1:\n\t\tlevel = RAID_LEVEL_1;\n\t\tbreak;\n\t}\n\n\tswitch (ioc->hba_mpi_version_belonged) {\n\tcase MPI2_VERSION:\n\t\traid_set_level(mpt2sas_raid_template,\n\t\t\t&sdev->sdev_gendev, level);\n\t\tbreak;\n\tcase MPI25_VERSION:\n\tcase MPI26_VERSION:\n\t\traid_set_level(mpt3sas_raid_template,\n\t\t\t&sdev->sdev_gendev, level);\n\t\tbreak;\n\t}\n}\n\n\n/**\n * _scsih_get_volume_capabilities - volume capabilities\n * @ioc: per adapter object\n * @raid_device: the raid_device object\n *\n * Return: 0 for success, else 1\n */\nstatic int\n_scsih_get_volume_capabilities(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _raid_device *raid_device)\n{\n\tMpi2RaidVolPage0_t *vol_pg0;\n\tMpi2RaidPhysDiskPage0_t pd_pg0;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 sz;\n\tu8 num_pds;\n\n\tif ((mpt3sas_config_get_number_pds(ioc, raid_device->handle,\n\t    &num_pds)) || !num_pds) {\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\treturn 1;\n\t}\n\n\traid_device->num_pds = num_pds;\n\tsz = offsetof(Mpi2RaidVolPage0_t, PhysDisk) + (num_pds *\n\t    sizeof(Mpi2RaidVol0PhysDisk_t));\n\tvol_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!vol_pg0) {\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\treturn 1;\n\t}\n\n\tif ((mpt3sas_config_get_raid_volume_pg0(ioc, &mpi_reply, vol_pg0,\n\t     MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, raid_device->handle, sz))) {\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\tkfree(vol_pg0);\n\t\treturn 1;\n\t}\n\n\traid_device->volume_type = vol_pg0->VolumeType;\n\n\t/* figure out what the underlying devices are by\n\t * obtaining the device_info bits for the 1st device\n\t */\n\tif (!(mpt3sas_config_get_phys_disk_pg0(ioc, &mpi_reply,\n\t    &pd_pg0, MPI2_PHYSDISK_PGAD_FORM_PHYSDISKNUM,\n\t    vol_pg0->PhysDisk[0].PhysDiskNum))) {\n\t\tif (!(mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply,\n\t\t    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_HANDLE,\n\t\t    le16_to_cpu(pd_pg0.DevHandle)))) {\n\t\t\traid_device->device_info =\n\t\t\t    le32_to_cpu(sas_device_pg0.DeviceInfo);\n\t\t}\n\t}\n\n\tkfree(vol_pg0);\n\treturn 0;\n}\n\n/**\n * _scsih_enable_tlr - setting TLR flags\n * @ioc: per adapter object\n * @sdev: scsi device struct\n *\n * Enabling Transaction Layer Retries for tape devices when\n * vpd page 0x90 is present\n *\n */\nstatic void\n_scsih_enable_tlr(struct MPT3SAS_ADAPTER *ioc, struct scsi_device *sdev)\n{\n\n\t/* only for TAPE */\n\tif (sdev->type != TYPE_TAPE)\n\t\treturn;\n\n\tif (!(ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_TLR))\n\t\treturn;\n\n\tsas_enable_tlr(sdev);\n\tsdev_printk(KERN_INFO, sdev, \"TLR %s\\n\",\n\t    sas_is_tlr_enabled(sdev) ? \"Enabled\" : \"Disabled\");\n\treturn;\n\n}\n\n/**\n * scsih_slave_configure - device configure routine.\n * @sdev: scsi device struct\n *\n * Return: 0 if ok. Any other return is assumed to be an error and\n * the device is ignored.\n */\nstatic int\nscsih_slave_configure(struct scsi_device *sdev)\n{\n\tstruct Scsi_Host *shost = sdev->host;\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct _sas_device *sas_device;\n\tstruct _pcie_device *pcie_device;\n\tstruct _raid_device *raid_device;\n\tunsigned long flags;\n\tint qdepth;\n\tu8 ssp_target = 0;\n\tchar *ds = \"\";\n\tchar *r_level = \"\";\n\tu16 handle, volume_handle = 0;\n\tu64 volume_wwid = 0;\n\n\tqdepth = 1;\n\tsas_device_priv_data = sdev->hostdata;\n\tsas_device_priv_data->configured_lun = 1;\n\tsas_device_priv_data->flags &= ~MPT_DEVICE_FLAGS_INIT;\n\tsas_target_priv_data = sas_device_priv_data->sas_target;\n\thandle = sas_target_priv_data->handle;\n\n\t/* raid volume handling */\n\tif (sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME) {\n\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\traid_device = mpt3sas_raid_device_find_by_handle(ioc, handle);\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t\tif (!raid_device) {\n\t\t\tdfailprintk(ioc,\n\t\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (_scsih_get_volume_capabilities(ioc, raid_device)) {\n\t\t\tdfailprintk(ioc,\n\t\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * WARPDRIVE: Initialize the required data for Direct IO\n\t\t */\n\t\tmpt3sas_init_warpdrive_properties(ioc, raid_device);\n\n\t\t/* RAID Queue Depth Support\n\t\t * IS volume = underlying qdepth of drive type, either\n\t\t *    MPT3SAS_SAS_QUEUE_DEPTH or MPT3SAS_SATA_QUEUE_DEPTH\n\t\t * IM/IME/R10 = 128 (MPT3SAS_RAID_QUEUE_DEPTH)\n\t\t */\n\t\tif (raid_device->device_info &\n\t\t    MPI2_SAS_DEVICE_INFO_SSP_TARGET) {\n\t\t\tqdepth = MPT3SAS_SAS_QUEUE_DEPTH;\n\t\t\tds = \"SSP\";\n\t\t} else {\n\t\t\tqdepth = MPT3SAS_SATA_QUEUE_DEPTH;\n\t\t\tif (raid_device->device_info &\n\t\t\t    MPI2_SAS_DEVICE_INFO_SATA_DEVICE)\n\t\t\t\tds = \"SATA\";\n\t\t\telse\n\t\t\t\tds = \"STP\";\n\t\t}\n\n\t\tswitch (raid_device->volume_type) {\n\t\tcase MPI2_RAID_VOL_TYPE_RAID0:\n\t\t\tr_level = \"RAID0\";\n\t\t\tbreak;\n\t\tcase MPI2_RAID_VOL_TYPE_RAID1E:\n\t\t\tqdepth = MPT3SAS_RAID_QUEUE_DEPTH;\n\t\t\tif (ioc->manu_pg10.OEMIdentifier &&\n\t\t\t    (le32_to_cpu(ioc->manu_pg10.GenericFlags0) &\n\t\t\t    MFG10_GF0_R10_DISPLAY) &&\n\t\t\t    !(raid_device->num_pds % 2))\n\t\t\t\tr_level = \"RAID10\";\n\t\t\telse\n\t\t\t\tr_level = \"RAID1E\";\n\t\t\tbreak;\n\t\tcase MPI2_RAID_VOL_TYPE_RAID1:\n\t\t\tqdepth = MPT3SAS_RAID_QUEUE_DEPTH;\n\t\t\tr_level = \"RAID1\";\n\t\t\tbreak;\n\t\tcase MPI2_RAID_VOL_TYPE_RAID10:\n\t\t\tqdepth = MPT3SAS_RAID_QUEUE_DEPTH;\n\t\t\tr_level = \"RAID10\";\n\t\t\tbreak;\n\t\tcase MPI2_RAID_VOL_TYPE_UNKNOWN:\n\t\tdefault:\n\t\t\tqdepth = MPT3SAS_RAID_QUEUE_DEPTH;\n\t\t\tr_level = \"RAIDX\";\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ioc->hide_ir_msg)\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t   \"%s: handle(0x%04x), wwid(0x%016llx),\"\n\t\t\t    \" pd_count(%d), type(%s)\\n\",\n\t\t\t    r_level, raid_device->handle,\n\t\t\t    (unsigned long long)raid_device->wwid,\n\t\t\t    raid_device->num_pds, ds);\n\n\t\tif (shost->max_sectors > MPT3SAS_RAID_MAX_SECTORS) {\n\t\t\tblk_queue_max_hw_sectors(sdev->request_queue,\n\t\t\t\t\t\tMPT3SAS_RAID_MAX_SECTORS);\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\t\"Set queue's max_sector to: %u\\n\",\n\t\t\t\t\t\tMPT3SAS_RAID_MAX_SECTORS);\n\t\t}\n\n\t\tmpt3sas_scsih_change_queue_depth(sdev, qdepth);\n\n\t\t/* raid transport support */\n\t\tif (!ioc->is_warpdrive)\n\t\t\t_scsih_set_level(ioc, sdev, raid_device->volume_type);\n\t\treturn 0;\n\t}\n\n\t/* non-raid handling */\n\tif (sas_target_priv_data->flags & MPT_TARGET_FLAGS_RAID_COMPONENT) {\n\t\tif (mpt3sas_config_get_volume_handle(ioc, handle,\n\t\t    &volume_handle)) {\n\t\t\tdfailprintk(ioc,\n\t\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\t\treturn 1;\n\t\t}\n\t\tif (volume_handle && mpt3sas_config_get_volume_wwid(ioc,\n\t\t    volume_handle, &volume_wwid)) {\n\t\t\tdfailprintk(ioc,\n\t\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* PCIe handling */\n\tif (sas_target_priv_data->flags & MPT_TARGET_FLAGS_PCIE_DEVICE) {\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\tpcie_device = __mpt3sas_get_pdev_by_wwid(ioc,\n\t\t\t\tsas_device_priv_data->sas_target->sas_address);\n\t\tif (!pcie_device) {\n\t\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\t\tdfailprintk(ioc,\n\t\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\t\treturn 1;\n\t\t}\n\n\t\tqdepth = ioc->max_nvme_qd;\n\t\tds = \"NVMe\";\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\"%s: handle(0x%04x), wwid(0x%016llx), port(%d)\\n\",\n\t\t\tds, handle, (unsigned long long)pcie_device->wwid,\n\t\t\tpcie_device->port_num);\n\t\tif (pcie_device->enclosure_handle != 0)\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\"%s: enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\tds,\n\t\t\t(unsigned long long)pcie_device->enclosure_logical_id,\n\t\t\tpcie_device->slot);\n\t\tif (pcie_device->connector_name[0] != '\\0')\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\"%s: enclosure level(0x%04x),\"\n\t\t\t\t\"connector name( %s)\\n\", ds,\n\t\t\t\tpcie_device->enclosure_level,\n\t\t\t\tpcie_device->connector_name);\n\n\t\tif (pcie_device->nvme_mdts)\n\t\t\tblk_queue_max_hw_sectors(sdev->request_queue,\n\t\t\t\t\tpcie_device->nvme_mdts/512);\n\n\t\tpcie_device_put(pcie_device);\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\tmpt3sas_scsih_change_queue_depth(sdev, qdepth);\n\t\t/* Enable QUEUE_FLAG_NOMERGES flag, so that IOs won't be\n\t\t ** merged and can eliminate holes created during merging\n\t\t ** operation.\n\t\t **/\n\t\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES,\n\t\t\t\tsdev->request_queue);\n\t\tblk_queue_virt_boundary(sdev->request_queue,\n\t\t\t\tioc->page_size - 1);\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_addr(ioc,\n\t   sas_device_priv_data->sas_target->sas_address,\n\t   sas_device_priv_data->sas_target->port);\n\tif (!sas_device) {\n\t\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\treturn 1;\n\t}\n\n\tsas_device->volume_handle = volume_handle;\n\tsas_device->volume_wwid = volume_wwid;\n\tif (sas_device->device_info & MPI2_SAS_DEVICE_INFO_SSP_TARGET) {\n\t\tqdepth = (sas_device->port_type > 1) ?\n\t\t\tioc->max_wideport_qd : ioc->max_narrowport_qd;\n\t\tssp_target = 1;\n\t\tif (sas_device->device_info &\n\t\t\t\tMPI2_SAS_DEVICE_INFO_SEP) {\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\"set ignore_delay_remove for handle(0x%04x)\\n\",\n\t\t\tsas_device_priv_data->sas_target->handle);\n\t\t\tsas_device_priv_data->ignore_delay_remove = 1;\n\t\t\tds = \"SES\";\n\t\t} else\n\t\t\tds = \"SSP\";\n\t} else {\n\t\tqdepth = ioc->max_sata_qd;\n\t\tif (sas_device->device_info & MPI2_SAS_DEVICE_INFO_STP_TARGET)\n\t\t\tds = \"STP\";\n\t\telse if (sas_device->device_info &\n\t\t    MPI2_SAS_DEVICE_INFO_SATA_DEVICE)\n\t\t\tds = \"SATA\";\n\t}\n\n\tsdev_printk(KERN_INFO, sdev, \"%s: handle(0x%04x), \" \\\n\t    \"sas_addr(0x%016llx), phy(%d), device_name(0x%016llx)\\n\",\n\t    ds, handle, (unsigned long long)sas_device->sas_address,\n\t    sas_device->phy, (unsigned long long)sas_device->device_name);\n\n\t_scsih_display_enclosure_chassis_info(NULL, sas_device, sdev, NULL);\n\n\tsas_device_put(sas_device);\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\tif (!ssp_target)\n\t\t_scsih_display_sata_capabilities(ioc, handle, sdev);\n\n\n\tmpt3sas_scsih_change_queue_depth(sdev, qdepth);\n\n\tif (ssp_target) {\n\t\tsas_read_port_mode_page(sdev);\n\t\t_scsih_enable_tlr(ioc, sdev);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nscsih_bios_param(struct scsi_device *sdev, struct block_device *bdev,\n\tsector_t capacity, int params[])\n{\n\tint\t\theads;\n\tint\t\tsectors;\n\tsector_t\tcylinders;\n\tulong\t\tdummy;\n\n\theads = 64;\n\tsectors = 32;\n\n\tdummy = heads * sectors;\n\tcylinders = capacity;\n\tsector_div(cylinders, dummy);\n\n\t \n\tif ((ulong)capacity >= 0x200000) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\tdummy = heads * sectors;\n\t\tcylinders = capacity;\n\t\tsector_div(cylinders, dummy);\n\t}\n\n\t \n\tparams[0] = heads;\n\tparams[1] = sectors;\n\tparams[2] = cylinders;\n\n\treturn 0;\n}\n\n \nstatic void\n_scsih_response_code(struct MPT3SAS_ADAPTER *ioc, u8 response_code)\n{\n\tchar *desc;\n\n\tswitch (response_code) {\n\tcase MPI2_SCSITASKMGMT_RSP_TM_COMPLETE:\n\t\tdesc = \"task management request completed\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_INVALID_FRAME:\n\t\tdesc = \"invalid frame\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_TM_NOT_SUPPORTED:\n\t\tdesc = \"task management request not supported\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_TM_FAILED:\n\t\tdesc = \"task management request failed\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_TM_SUCCEEDED:\n\t\tdesc = \"task management request succeeded\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_TM_INVALID_LUN:\n\t\tdesc = \"invalid lun\";\n\t\tbreak;\n\tcase 0xA:\n\t\tdesc = \"overlapped tag attempted\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC:\n\t\tdesc = \"task queued, however not sent to target\";\n\t\tbreak;\n\tdefault:\n\t\tdesc = \"unknown\";\n\t\tbreak;\n\t}\n\tioc_warn(ioc, \"response_code(0x%01x): %s\\n\", response_code, desc);\n}\n\n \nstatic u8\n_scsih_tm_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)\n{\n\tMPI2DefaultReply_t *mpi_reply;\n\n\tif (ioc->tm_cmds.status == MPT3_CMD_NOT_USED)\n\t\treturn 1;\n\tif (ioc->tm_cmds.smid != smid)\n\t\treturn 1;\n\tioc->tm_cmds.status |= MPT3_CMD_COMPLETE;\n\tmpi_reply =  mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tif (mpi_reply) {\n\t\tmemcpy(ioc->tm_cmds.reply, mpi_reply, mpi_reply->MsgLength*4);\n\t\tioc->tm_cmds.status |= MPT3_CMD_REPLY_VALID;\n\t}\n\tioc->tm_cmds.status &= ~MPT3_CMD_PENDING;\n\tcomplete(&ioc->tm_cmds.done);\n\treturn 1;\n}\n\n \nvoid\nmpt3sas_scsih_set_tm_flag(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_device *sdev;\n\tu8 skip = 0;\n\n\tshost_for_each_device(sdev, ioc->shost) {\n\t\tif (skip)\n\t\t\tcontinue;\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (!sas_device_priv_data)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->sas_target->handle == handle) {\n\t\t\tsas_device_priv_data->sas_target->tm_busy = 1;\n\t\t\tskip = 1;\n\t\t\tioc->ignore_loginfos = 1;\n\t\t}\n\t}\n}\n\n \nvoid\nmpt3sas_scsih_clear_tm_flag(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_device *sdev;\n\tu8 skip = 0;\n\n\tshost_for_each_device(sdev, ioc->shost) {\n\t\tif (skip)\n\t\t\tcontinue;\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (!sas_device_priv_data)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->sas_target->handle == handle) {\n\t\t\tsas_device_priv_data->sas_target->tm_busy = 0;\n\t\t\tskip = 1;\n\t\t\tioc->ignore_loginfos = 0;\n\t\t}\n\t}\n}\n\n \nstatic int\nscsih_tm_cmd_map_status(struct MPT3SAS_ADAPTER *ioc, uint channel,\n\tuint id, uint lun, u8 type, u16 smid_task)\n{\n\n\tif (smid_task <= ioc->shost->can_queue) {\n\t\tswitch (type) {\n\t\tcase MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET:\n\t\t\tif (!(_scsih_scsi_lookup_find_by_target(ioc,\n\t\t\t    id, channel)))\n\t\t\t\treturn SUCCESS;\n\t\t\tbreak;\n\t\tcase MPI2_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET:\n\t\tcase MPI2_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET:\n\t\t\tif (!(_scsih_scsi_lookup_find_by_lun(ioc, id,\n\t\t\t    lun, channel)))\n\t\t\t\treturn SUCCESS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn SUCCESS;\n\t\t}\n\t} else if (smid_task == ioc->scsih_cmds.smid) {\n\t\tif ((ioc->scsih_cmds.status & MPT3_CMD_COMPLETE) ||\n\t\t    (ioc->scsih_cmds.status & MPT3_CMD_NOT_USED))\n\t\t\treturn SUCCESS;\n\t} else if (smid_task == ioc->ctl_cmds.smid) {\n\t\tif ((ioc->ctl_cmds.status & MPT3_CMD_COMPLETE) ||\n\t\t    (ioc->ctl_cmds.status & MPT3_CMD_NOT_USED))\n\t\t\treturn SUCCESS;\n\t}\n\n\treturn FAILED;\n}\n\n \nstatic int\nscsih_tm_post_processing(struct MPT3SAS_ADAPTER *ioc, u16 handle,\n\tuint channel, uint id, uint lun, u8 type, u16 smid_task)\n{\n\tint rc;\n\n\trc = scsih_tm_cmd_map_status(ioc, channel, id, lun, type, smid_task);\n\tif (rc == SUCCESS)\n\t\treturn rc;\n\n\tioc_info(ioc,\n\t    \"Poll ReplyDescriptor queues for completion of\"\n\t    \" smid(%d), task_type(0x%02x), handle(0x%04x)\\n\",\n\t    smid_task, type, handle);\n\n\t \n\tmpt3sas_base_mask_interrupts(ioc);\n\tmpt3sas_base_sync_reply_irqs(ioc, 1);\n\tmpt3sas_base_unmask_interrupts(ioc);\n\n\treturn scsih_tm_cmd_map_status(ioc, channel, id, lun, type, smid_task);\n}\n\n \nint\nmpt3sas_scsih_issue_tm(struct MPT3SAS_ADAPTER *ioc, u16 handle, uint channel,\n\tuint id, u64 lun, u8 type, u16 smid_task, u16 msix_task,\n\tu8 timeout, u8 tr_method)\n{\n\tMpi2SCSITaskManagementRequest_t *mpi_request;\n\tMpi2SCSITaskManagementReply_t *mpi_reply;\n\tMpi25SCSIIORequest_t *request;\n\tu16 smid = 0;\n\tu32 ioc_state;\n\tint rc;\n\tu8 issue_reset = 0;\n\n\tlockdep_assert_held(&ioc->tm_cmds.mutex);\n\n\tif (ioc->tm_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_info(ioc, \"%s: tm_cmd busy!!!\\n\", __func__);\n\t\treturn FAILED;\n\t}\n\n\tif (ioc->shost_recovery || ioc->remove_host ||\n\t    ioc->pci_error_recovery) {\n\t\tioc_info(ioc, \"%s: host reset in progress!\\n\", __func__);\n\t\treturn FAILED;\n\t}\n\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\tif (ioc_state & MPI2_DOORBELL_USED) {\n\t\tdhsprintk(ioc, ioc_info(ioc, \"unexpected doorbell active!\\n\"));\n\t\trc = mpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\t\treturn (!rc) ? SUCCESS : FAILED;\n\t}\n\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {\n\t\tmpt3sas_print_fault_code(ioc, ioc_state &\n\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\trc = mpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\t\treturn (!rc) ? SUCCESS : FAILED;\n\t} else if ((ioc_state & MPI2_IOC_STATE_MASK) ==\n\t    MPI2_IOC_STATE_COREDUMP) {\n\t\tmpt3sas_print_coredump_info(ioc, ioc_state &\n\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\trc = mpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\t\treturn (!rc) ? SUCCESS : FAILED;\n\t}\n\n\tsmid = mpt3sas_base_get_smid_hpr(ioc, ioc->tm_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\treturn FAILED;\n\t}\n\n\tdtmprintk(ioc,\n\t\t  ioc_info(ioc, \"sending tm: handle(0x%04x), task_type(0x%02x), smid(%d), timeout(%d), tr_method(0x%x)\\n\",\n\t\t\t   handle, type, smid_task, timeout, tr_method));\n\tioc->tm_cmds.status = MPT3_CMD_PENDING;\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->tm_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi2SCSITaskManagementRequest_t));\n\tmemset(ioc->tm_cmds.reply, 0, sizeof(Mpi2SCSITaskManagementReply_t));\n\tmpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;\n\tmpi_request->DevHandle = cpu_to_le16(handle);\n\tmpi_request->TaskType = type;\n\tif (type == MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK ||\n\t    type == MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK)\n\t\tmpi_request->MsgFlags = tr_method;\n\tmpi_request->TaskMID = cpu_to_le16(smid_task);\n\tint_to_scsilun(lun, (struct scsi_lun *)mpi_request->LUN);\n\tmpt3sas_scsih_set_tm_flag(ioc, handle);\n\tinit_completion(&ioc->tm_cmds.done);\n\tioc->put_smid_hi_priority(ioc, smid, msix_task);\n\twait_for_completion_timeout(&ioc->tm_cmds.done, timeout*HZ);\n\tif (!(ioc->tm_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tmpt3sas_check_cmd_timeout(ioc,\n\t\t    ioc->tm_cmds.status, mpi_request,\n\t\t    sizeof(Mpi2SCSITaskManagementRequest_t)/4, issue_reset);\n\t\tif (issue_reset) {\n\t\t\trc = mpt3sas_base_hard_reset_handler(ioc,\n\t\t\t\t\tFORCE_BIG_HAMMER);\n\t\t\trc = (!rc) ? SUCCESS : FAILED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tmpt3sas_base_sync_reply_irqs(ioc, 0);\n\n\tif (ioc->tm_cmds.status & MPT3_CMD_REPLY_VALID) {\n\t\tmpt3sas_trigger_master(ioc, MASTER_TRIGGER_TASK_MANAGMENT);\n\t\tmpi_reply = ioc->tm_cmds.reply;\n\t\tdtmprintk(ioc,\n\t\t\t  ioc_info(ioc, \"complete tm: ioc_status(0x%04x), loginfo(0x%08x), term_count(0x%08x)\\n\",\n\t\t\t\t   le16_to_cpu(mpi_reply->IOCStatus),\n\t\t\t\t   le32_to_cpu(mpi_reply->IOCLogInfo),\n\t\t\t\t   le32_to_cpu(mpi_reply->TerminationCount)));\n\t\tif (ioc->logging_level & MPT_DEBUG_TM) {\n\t\t\t_scsih_response_code(ioc, mpi_reply->ResponseCode);\n\t\t\tif (mpi_reply->IOCStatus)\n\t\t\t\t_debug_dump_mf(mpi_request,\n\t\t\t\t    sizeof(Mpi2SCSITaskManagementRequest_t)/4);\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK:\n\t\trc = SUCCESS;\n\t\t \n\t\trequest = mpt3sas_base_get_msg_frame(ioc, smid_task);\n\t\tif (le16_to_cpu(request->DevHandle) != handle)\n\t\t\tbreak;\n\n\t\tioc_info(ioc, \"Task abort tm failed: handle(0x%04x),\"\n\t\t    \"timeout(%d) tr_method(0x%x) smid(%d) msix_index(%d)\\n\",\n\t\t    handle, timeout, tr_method, smid_task, msix_task);\n\t\trc = FAILED;\n\t\tbreak;\n\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET:\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET:\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET:\n\t\trc = scsih_tm_post_processing(ioc, handle, channel, id, lun,\n\t\t    type, smid_task);\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK:\n\t\trc = SUCCESS;\n\t\tbreak;\n\tdefault:\n\t\trc = FAILED;\n\t\tbreak;\n\t}\n\nout:\n\tmpt3sas_scsih_clear_tm_flag(ioc, handle);\n\tioc->tm_cmds.status = MPT3_CMD_NOT_USED;\n\treturn rc;\n}\n\nint mpt3sas_scsih_issue_locked_tm(struct MPT3SAS_ADAPTER *ioc, u16 handle,\n\t\tuint channel, uint id, u64 lun, u8 type, u16 smid_task,\n\t\tu16 msix_task, u8 timeout, u8 tr_method)\n{\n\tint ret;\n\n\tmutex_lock(&ioc->tm_cmds.mutex);\n\tret = mpt3sas_scsih_issue_tm(ioc, handle, channel, id, lun, type,\n\t\t\tsmid_task, msix_task, timeout, tr_method);\n\tmutex_unlock(&ioc->tm_cmds.mutex);\n\n\treturn ret;\n}\n\n \nstatic void\n_scsih_tm_display_info(struct MPT3SAS_ADAPTER *ioc, struct scsi_cmnd *scmd)\n{\n\tstruct scsi_target *starget = scmd->device->sdev_target;\n\tstruct MPT3SAS_TARGET *priv_target = starget->hostdata;\n\tstruct _sas_device *sas_device = NULL;\n\tstruct _pcie_device *pcie_device = NULL;\n\tunsigned long flags;\n\tchar *device_str = NULL;\n\n\tif (!priv_target)\n\t\treturn;\n\tif (ioc->hide_ir_msg)\n\t\tdevice_str = \"WarpDrive\";\n\telse\n\t\tdevice_str = \"volume\";\n\n\tscsi_print_command(scmd);\n\tif (priv_target->flags & MPT_TARGET_FLAGS_VOLUME) {\n\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\"%s handle(0x%04x), %s wwid(0x%016llx)\\n\",\n\t\t\tdevice_str, priv_target->handle,\n\t\t    device_str, (unsigned long long)priv_target->sas_address);\n\n\t} else if (priv_target->flags & MPT_TARGET_FLAGS_PCIE_DEVICE) {\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\tpcie_device = __mpt3sas_get_pdev_from_target(ioc, priv_target);\n\t\tif (pcie_device) {\n\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\t\"handle(0x%04x), wwid(0x%016llx), port(%d)\\n\",\n\t\t\t\tpcie_device->handle,\n\t\t\t\t(unsigned long long)pcie_device->wwid,\n\t\t\t\tpcie_device->port_num);\n\t\t\tif (pcie_device->enclosure_handle != 0)\n\t\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\t\t\"enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t\t(unsigned long long)\n\t\t\t\t\tpcie_device->enclosure_logical_id,\n\t\t\t\t\tpcie_device->slot);\n\t\t\tif (pcie_device->connector_name[0] != '\\0')\n\t\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\t\t\"enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t\tpcie_device->enclosure_level,\n\t\t\t\t\tpcie_device->connector_name);\n\t\t\tpcie_device_put(pcie_device);\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\t} else {\n\t\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\t\tsas_device = __mpt3sas_get_sdev_from_target(ioc, priv_target);\n\t\tif (sas_device) {\n\t\t\tif (priv_target->flags &\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT) {\n\t\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\t    \"volume handle(0x%04x), \"\n\t\t\t\t    \"volume wwid(0x%016llx)\\n\",\n\t\t\t\t    sas_device->volume_handle,\n\t\t\t\t   (unsigned long long)sas_device->volume_wwid);\n\t\t\t}\n\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t    \"handle(0x%04x), sas_address(0x%016llx), phy(%d)\\n\",\n\t\t\t    sas_device->handle,\n\t\t\t    (unsigned long long)sas_device->sas_address,\n\t\t\t    sas_device->phy);\n\n\t\t\t_scsih_display_enclosure_chassis_info(NULL, sas_device,\n\t\t\t    NULL, starget);\n\n\t\t\tsas_device_put(sas_device);\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\t}\n}\n\n \nstatic int\nscsih_abort(struct scsi_cmnd *scmd)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(scmd->device->host);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsiio_tracker *st = scsi_cmd_priv(scmd);\n\tu16 handle;\n\tint r;\n\n\tu8 timeout = 30;\n\tstruct _pcie_device *pcie_device = NULL;\n\tsdev_printk(KERN_INFO, scmd->device, \"attempting task abort!\"\n\t    \"scmd(0x%p), outstanding for %u ms & timeout %u ms\\n\",\n\t    scmd, jiffies_to_msecs(jiffies - scmd->jiffies_at_alloc),\n\t    (scsi_cmd_to_rq(scmd)->timeout / HZ) * 1000);\n\t_scsih_tm_display_info(ioc, scmd);\n\n\tsas_device_priv_data = scmd->device->hostdata;\n\tif (!sas_device_priv_data || !sas_device_priv_data->sas_target ||\n\t    ioc->remove_host) {\n\t\tsdev_printk(KERN_INFO, scmd->device,\n\t\t    \"device been deleted! scmd(0x%p)\\n\", scmd);\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(scmd);\n\t\tr = SUCCESS;\n\t\tgoto out;\n\t}\n\n\t \n\tif (st == NULL || st->cb_idx == 0xFF) {\n\t\tsdev_printk(KERN_INFO, scmd->device, \"No reference found at \"\n\t\t    \"driver, assuming scmd(0x%p) might have completed\\n\", scmd);\n\t\tscmd->result = DID_RESET << 16;\n\t\tr = SUCCESS;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sas_device_priv_data->sas_target->flags &\n\t    MPT_TARGET_FLAGS_RAID_COMPONENT ||\n\t    sas_device_priv_data->sas_target->flags & MPT_TARGET_FLAGS_VOLUME) {\n\t\tscmd->result = DID_RESET << 16;\n\t\tr = FAILED;\n\t\tgoto out;\n\t}\n\n\tmpt3sas_halt_firmware(ioc);\n\n\thandle = sas_device_priv_data->sas_target->handle;\n\tpcie_device = mpt3sas_get_pdev_by_handle(ioc, handle);\n\tif (pcie_device && (!ioc->tm_custom_handling) &&\n\t    (!(mpt3sas_scsih_is_pcie_scsi_device(pcie_device->device_info))))\n\t\ttimeout = ioc->nvme_abort_timeout;\n\tr = mpt3sas_scsih_issue_locked_tm(ioc, handle, scmd->device->channel,\n\t\tscmd->device->id, scmd->device->lun,\n\t\tMPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK,\n\t\tst->smid, st->msix_io, timeout, 0);\n\t \n\tif (r == SUCCESS && st->cb_idx != 0xFF)\n\t\tr = FAILED;\n out:\n\tsdev_printk(KERN_INFO, scmd->device, \"task abort: %s scmd(0x%p)\\n\",\n\t    ((r == SUCCESS) ? \"SUCCESS\" : \"FAILED\"), scmd);\n\tif (pcie_device)\n\t\tpcie_device_put(pcie_device);\n\treturn r;\n}\n\n \nstatic int\nscsih_dev_reset(struct scsi_cmnd *scmd)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(scmd->device->host);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct _sas_device *sas_device = NULL;\n\tstruct _pcie_device *pcie_device = NULL;\n\tu16\thandle;\n\tu8\ttr_method = 0;\n\tu8\ttr_timeout = 30;\n\tint r;\n\n\tstruct scsi_target *starget = scmd->device->sdev_target;\n\tstruct MPT3SAS_TARGET *target_priv_data = starget->hostdata;\n\n\tsdev_printk(KERN_INFO, scmd->device,\n\t    \"attempting device reset! scmd(0x%p)\\n\", scmd);\n\t_scsih_tm_display_info(ioc, scmd);\n\n\tsas_device_priv_data = scmd->device->hostdata;\n\tif (!sas_device_priv_data || !sas_device_priv_data->sas_target ||\n\t    ioc->remove_host) {\n\t\tsdev_printk(KERN_INFO, scmd->device,\n\t\t    \"device been deleted! scmd(0x%p)\\n\", scmd);\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(scmd);\n\t\tr = SUCCESS;\n\t\tgoto out;\n\t}\n\n\t \n\thandle = 0;\n\tif (sas_device_priv_data->sas_target->flags &\n\t    MPT_TARGET_FLAGS_RAID_COMPONENT) {\n\t\tsas_device = mpt3sas_get_sdev_from_target(ioc,\n\t\t\t\ttarget_priv_data);\n\t\tif (sas_device)\n\t\t\thandle = sas_device->volume_handle;\n\t} else\n\t\thandle = sas_device_priv_data->sas_target->handle;\n\n\tif (!handle) {\n\t\tscmd->result = DID_RESET << 16;\n\t\tr = FAILED;\n\t\tgoto out;\n\t}\n\n\tpcie_device = mpt3sas_get_pdev_by_handle(ioc, handle);\n\n\tif (pcie_device && (!ioc->tm_custom_handling) &&\n\t    (!(mpt3sas_scsih_is_pcie_scsi_device(pcie_device->device_info)))) {\n\t\ttr_timeout = pcie_device->reset_timeout;\n\t\ttr_method = MPI26_SCSITASKMGMT_MSGFLAGS_PROTOCOL_LVL_RST_PCIE;\n\t} else\n\t\ttr_method = MPI2_SCSITASKMGMT_MSGFLAGS_LINK_RESET;\n\n\tr = mpt3sas_scsih_issue_locked_tm(ioc, handle, scmd->device->channel,\n\t\tscmd->device->id, scmd->device->lun,\n\t\tMPI2_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET, 0, 0,\n\t\ttr_timeout, tr_method);\n\t \n\tif (r == SUCCESS && scsi_device_busy(scmd->device))\n\t\tr = FAILED;\n out:\n\tsdev_printk(KERN_INFO, scmd->device, \"device reset: %s scmd(0x%p)\\n\",\n\t    ((r == SUCCESS) ? \"SUCCESS\" : \"FAILED\"), scmd);\n\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n\tif (pcie_device)\n\t\tpcie_device_put(pcie_device);\n\n\treturn r;\n}\n\n \nstatic int\nscsih_target_reset(struct scsi_cmnd *scmd)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(scmd->device->host);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct _sas_device *sas_device = NULL;\n\tstruct _pcie_device *pcie_device = NULL;\n\tu16\thandle;\n\tu8\ttr_method = 0;\n\tu8\ttr_timeout = 30;\n\tint r;\n\tstruct scsi_target *starget = scmd->device->sdev_target;\n\tstruct MPT3SAS_TARGET *target_priv_data = starget->hostdata;\n\n\tstarget_printk(KERN_INFO, starget,\n\t    \"attempting target reset! scmd(0x%p)\\n\", scmd);\n\t_scsih_tm_display_info(ioc, scmd);\n\n\tsas_device_priv_data = scmd->device->hostdata;\n\tif (!sas_device_priv_data || !sas_device_priv_data->sas_target ||\n\t    ioc->remove_host) {\n\t\tstarget_printk(KERN_INFO, starget,\n\t\t    \"target been deleted! scmd(0x%p)\\n\", scmd);\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(scmd);\n\t\tr = SUCCESS;\n\t\tgoto out;\n\t}\n\n\t \n\thandle = 0;\n\tif (sas_device_priv_data->sas_target->flags &\n\t    MPT_TARGET_FLAGS_RAID_COMPONENT) {\n\t\tsas_device = mpt3sas_get_sdev_from_target(ioc,\n\t\t\t\ttarget_priv_data);\n\t\tif (sas_device)\n\t\t\thandle = sas_device->volume_handle;\n\t} else\n\t\thandle = sas_device_priv_data->sas_target->handle;\n\n\tif (!handle) {\n\t\tscmd->result = DID_RESET << 16;\n\t\tr = FAILED;\n\t\tgoto out;\n\t}\n\n\tpcie_device = mpt3sas_get_pdev_by_handle(ioc, handle);\n\n\tif (pcie_device && (!ioc->tm_custom_handling) &&\n\t    (!(mpt3sas_scsih_is_pcie_scsi_device(pcie_device->device_info)))) {\n\t\ttr_timeout = pcie_device->reset_timeout;\n\t\ttr_method = MPI26_SCSITASKMGMT_MSGFLAGS_PROTOCOL_LVL_RST_PCIE;\n\t} else\n\t\ttr_method = MPI2_SCSITASKMGMT_MSGFLAGS_LINK_RESET;\n\tr = mpt3sas_scsih_issue_locked_tm(ioc, handle, scmd->device->channel,\n\t\tscmd->device->id, 0,\n\t\tMPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET, 0, 0,\n\t    tr_timeout, tr_method);\n\t \n\tif (r == SUCCESS && atomic_read(&starget->target_busy))\n\t\tr = FAILED;\n out:\n\tstarget_printk(KERN_INFO, starget, \"target reset: %s scmd(0x%p)\\n\",\n\t    ((r == SUCCESS) ? \"SUCCESS\" : \"FAILED\"), scmd);\n\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n\tif (pcie_device)\n\t\tpcie_device_put(pcie_device);\n\treturn r;\n}\n\n\n \nstatic int\nscsih_host_reset(struct scsi_cmnd *scmd)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(scmd->device->host);\n\tint r, retval;\n\n\tioc_info(ioc, \"attempting host reset! scmd(0x%p)\\n\", scmd);\n\tscsi_print_command(scmd);\n\n\tif (ioc->is_driver_loading || ioc->remove_host) {\n\t\tioc_info(ioc, \"Blocking the host reset\\n\");\n\t\tr = FAILED;\n\t\tgoto out;\n\t}\n\n\tretval = mpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\tr = (retval < 0) ? FAILED : SUCCESS;\nout:\n\tioc_info(ioc, \"host reset: %s scmd(0x%p)\\n\",\n\t\t r == SUCCESS ? \"SUCCESS\" : \"FAILED\", scmd);\n\n\treturn r;\n}\n\n \nstatic void\n_scsih_fw_event_add(struct MPT3SAS_ADAPTER *ioc, struct fw_event_work *fw_event)\n{\n\tunsigned long flags;\n\n\tif (ioc->firmware_event_thread == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\tfw_event_work_get(fw_event);\n\tINIT_LIST_HEAD(&fw_event->list);\n\tlist_add_tail(&fw_event->list, &ioc->fw_event_list);\n\tINIT_WORK(&fw_event->work, _firmware_event_work);\n\tfw_event_work_get(fw_event);\n\tqueue_work(ioc->firmware_event_thread, &fw_event->work);\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n}\n\n \nstatic void\n_scsih_fw_event_del_from_list(struct MPT3SAS_ADAPTER *ioc, struct fw_event_work\n\t*fw_event)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\tif (!list_empty(&fw_event->list)) {\n\t\tlist_del_init(&fw_event->list);\n\t\tfw_event_work_put(fw_event);\n\t}\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n}\n\n\n  \nvoid\nmpt3sas_send_trigger_data_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct SL_WH_TRIGGERS_EVENT_DATA_T *event_data)\n{\n\tstruct fw_event_work *fw_event;\n\tu16 sz;\n\n\tif (ioc->is_driver_loading)\n\t\treturn;\n\tsz = sizeof(*event_data);\n\tfw_event = alloc_fw_event_work(sz);\n\tif (!fw_event)\n\t\treturn;\n\tfw_event->event = MPT3SAS_PROCESS_TRIGGER_DIAG;\n\tfw_event->ioc = ioc;\n\tmemcpy(fw_event->event_data, event_data, sizeof(*event_data));\n\t_scsih_fw_event_add(ioc, fw_event);\n\tfw_event_work_put(fw_event);\n}\n\n \nstatic void\n_scsih_error_recovery_delete_devices(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct fw_event_work *fw_event;\n\n\tfw_event = alloc_fw_event_work(0);\n\tif (!fw_event)\n\t\treturn;\n\tfw_event->event = MPT3SAS_REMOVE_UNRESPONDING_DEVICES;\n\tfw_event->ioc = ioc;\n\t_scsih_fw_event_add(ioc, fw_event);\n\tfw_event_work_put(fw_event);\n}\n\n \nvoid\nmpt3sas_port_enable_complete(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct fw_event_work *fw_event;\n\n\tfw_event = alloc_fw_event_work(0);\n\tif (!fw_event)\n\t\treturn;\n\tfw_event->event = MPT3SAS_PORT_ENABLE_COMPLETE;\n\tfw_event->ioc = ioc;\n\t_scsih_fw_event_add(ioc, fw_event);\n\tfw_event_work_put(fw_event);\n}\n\nstatic struct fw_event_work *dequeue_next_fw_event(struct MPT3SAS_ADAPTER *ioc)\n{\n\tunsigned long flags;\n\tstruct fw_event_work *fw_event = NULL;\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\tif (!list_empty(&ioc->fw_event_list)) {\n\t\tfw_event = list_first_entry(&ioc->fw_event_list,\n\t\t\t\tstruct fw_event_work, list);\n\t\tlist_del_init(&fw_event->list);\n\t\tfw_event_work_put(fw_event);\n\t}\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n\n\treturn fw_event;\n}\n\n \nstatic void\n_scsih_fw_event_cleanup_queue(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct fw_event_work *fw_event;\n\n\tif ((list_empty(&ioc->fw_event_list) && !ioc->current_event) ||\n\t    !ioc->firmware_event_thread)\n\t\treturn;\n\t \n\tif (ioc->shost_recovery && ioc->current_event)\n\t\tioc->current_event->ignore = 1;\n\n\tioc->fw_events_cleanup = 1;\n\twhile ((fw_event = dequeue_next_fw_event(ioc)) ||\n\t     (fw_event = ioc->current_event)) {\n\n\t\t \n\n\t\tif (fw_event == ioc->current_event &&\n\t\t    ioc->current_event->event !=\n\t\t    MPT3SAS_REMOVE_UNRESPONDING_DEVICES) {\n\t\t\tioc->current_event = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (fw_event->event == MPT3SAS_PORT_ENABLE_COMPLETE) {\n\t\t\tioc->port_enable_cmds.status |= MPT3_CMD_RESET;\n\t\t\tioc->start_scan = 0;\n\t\t}\n\n\t\t \n\t\tif (cancel_work_sync(&fw_event->work))\n\t\t\tfw_event_work_put(fw_event);\n\n\t}\n\tioc->fw_events_cleanup = 0;\n}\n\n \nstatic void\n_scsih_internal_device_block(struct scsi_device *sdev,\n\t\t\tstruct MPT3SAS_DEVICE *sas_device_priv_data)\n{\n\tint r = 0;\n\n\tsdev_printk(KERN_INFO, sdev, \"device_block, handle(0x%04x)\\n\",\n\t    sas_device_priv_data->sas_target->handle);\n\tsas_device_priv_data->block = 1;\n\n\tr = scsi_internal_device_block_nowait(sdev);\n\tif (r == -EINVAL)\n\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t    \"device_block failed with return(%d) for handle(0x%04x)\\n\",\n\t\t    r, sas_device_priv_data->sas_target->handle);\n}\n\n \n\nstatic void\n_scsih_internal_device_unblock(struct scsi_device *sdev,\n\t\t\tstruct MPT3SAS_DEVICE *sas_device_priv_data)\n{\n\tint r = 0;\n\n\tsdev_printk(KERN_WARNING, sdev, \"device_unblock and setting to running, \"\n\t    \"handle(0x%04x)\\n\", sas_device_priv_data->sas_target->handle);\n\tsas_device_priv_data->block = 0;\n\tr = scsi_internal_device_unblock_nowait(sdev, SDEV_RUNNING);\n\tif (r == -EINVAL) {\n\t\t \n\n\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t    \"device_unblock failed with return(%d) for handle(0x%04x) \"\n\t\t    \"performing a block followed by an unblock\\n\",\n\t\t    r, sas_device_priv_data->sas_target->handle);\n\t\tsas_device_priv_data->block = 1;\n\t\tr = scsi_internal_device_block_nowait(sdev);\n\t\tif (r)\n\t\t\tsdev_printk(KERN_WARNING, sdev, \"retried device_block \"\n\t\t\t    \"failed with return(%d) for handle(0x%04x)\\n\",\n\t\t\t    r, sas_device_priv_data->sas_target->handle);\n\n\t\tsas_device_priv_data->block = 0;\n\t\tr = scsi_internal_device_unblock_nowait(sdev, SDEV_RUNNING);\n\t\tif (r)\n\t\t\tsdev_printk(KERN_WARNING, sdev, \"retried device_unblock\"\n\t\t\t    \" failed with return(%d) for handle(0x%04x)\\n\",\n\t\t\t    r, sas_device_priv_data->sas_target->handle);\n\t}\n}\n\n \nstatic void\n_scsih_ublock_io_all_device(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_device *sdev;\n\n\tshost_for_each_device(sdev, ioc->shost) {\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (!sas_device_priv_data)\n\t\t\tcontinue;\n\t\tif (!sas_device_priv_data->block)\n\t\t\tcontinue;\n\n\t\tdewtprintk(ioc, sdev_printk(KERN_INFO, sdev,\n\t\t\t\"device_running, handle(0x%04x)\\n\",\n\t\t    sas_device_priv_data->sas_target->handle));\n\t\t_scsih_internal_device_unblock(sdev, sas_device_priv_data);\n\t}\n}\n\n\n \nstatic void\n_scsih_ublock_io_device(struct MPT3SAS_ADAPTER *ioc,\n\tu64 sas_address, struct hba_port *port)\n{\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_device *sdev;\n\n\tshost_for_each_device(sdev, ioc->shost) {\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (!sas_device_priv_data || !sas_device_priv_data->sas_target)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->sas_target->sas_address\n\t\t    != sas_address)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->sas_target->port != port)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->block)\n\t\t\t_scsih_internal_device_unblock(sdev,\n\t\t\t\tsas_device_priv_data);\n\t}\n}\n\n \nstatic void\n_scsih_block_io_all_device(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_device *sdev;\n\n\tshost_for_each_device(sdev, ioc->shost) {\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (!sas_device_priv_data)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->block)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->ignore_delay_remove) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\"%s skip device_block for SES handle(0x%04x)\\n\",\n\t\t\t__func__, sas_device_priv_data->sas_target->handle);\n\t\t\tcontinue;\n\t\t}\n\t\t_scsih_internal_device_block(sdev, sas_device_priv_data);\n\t}\n}\n\n \nstatic void\n_scsih_block_io_device(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_device *sdev;\n\tstruct _sas_device *sas_device;\n\n\tsas_device = mpt3sas_get_sdev_by_handle(ioc, handle);\n\n\tshost_for_each_device(sdev, ioc->shost) {\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (!sas_device_priv_data)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->sas_target->handle != handle)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->block)\n\t\t\tcontinue;\n\t\tif (sas_device && sas_device->pend_sas_rphy_add)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->ignore_delay_remove) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\"%s skip device_block for SES handle(0x%04x)\\n\",\n\t\t\t__func__, sas_device_priv_data->sas_target->handle);\n\t\t\tcontinue;\n\t\t}\n\t\t_scsih_internal_device_block(sdev, sas_device_priv_data);\n\t}\n\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n}\n\n \nstatic void\n_scsih_block_io_to_children_attached_to_ex(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_node *sas_expander)\n{\n\tstruct _sas_port *mpt3sas_port;\n\tstruct _sas_device *sas_device;\n\tstruct _sas_node *expander_sibling;\n\tunsigned long flags;\n\n\tif (!sas_expander)\n\t\treturn;\n\n\tlist_for_each_entry(mpt3sas_port,\n\t   &sas_expander->sas_port_list, port_list) {\n\t\tif (mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_END_DEVICE) {\n\t\t\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\t\t\tsas_device = __mpt3sas_get_sdev_by_addr(ioc,\n\t\t\t    mpt3sas_port->remote_identify.sas_address,\n\t\t\t    mpt3sas_port->hba_port);\n\t\t\tif (sas_device) {\n\t\t\t\tset_bit(sas_device->handle,\n\t\t\t\t\t\tioc->blocking_handles);\n\t\t\t\tsas_device_put(sas_device);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\t\t}\n\t}\n\n\tlist_for_each_entry(mpt3sas_port,\n\t   &sas_expander->sas_port_list, port_list) {\n\n\t\tif (mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\texpander_sibling =\n\t\t\t    mpt3sas_scsih_expander_find_by_sas_address(\n\t\t\t    ioc, mpt3sas_port->remote_identify.sas_address,\n\t\t\t    mpt3sas_port->hba_port);\n\t\t\t_scsih_block_io_to_children_attached_to_ex(ioc,\n\t\t\t    expander_sibling);\n\t\t}\n\t}\n}\n\n \nstatic void\n_scsih_block_io_to_children_attached_directly(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataSasTopologyChangeList_t *event_data)\n{\n\tint i;\n\tu16 handle;\n\tu16 reason_code;\n\n\tfor (i = 0; i < event_data->NumEntries; i++) {\n\t\thandle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\treason_code = event_data->PHY[i].PhyStatus &\n\t\t    MPI2_EVENT_SAS_TOPO_RC_MASK;\n\t\tif (reason_code == MPI2_EVENT_SAS_TOPO_RC_DELAY_NOT_RESPONDING)\n\t\t\t_scsih_block_io_device(ioc, handle);\n\t}\n}\n\n \nstatic void\n_scsih_block_io_to_pcie_children_attached_directly(struct MPT3SAS_ADAPTER *ioc,\n\t\tMpi26EventDataPCIeTopologyChangeList_t *event_data)\n{\n\tint i;\n\tu16 handle;\n\tu16 reason_code;\n\n\tfor (i = 0; i < event_data->NumEntries; i++) {\n\t\thandle =\n\t\t\tle16_to_cpu(event_data->PortEntry[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\treason_code = event_data->PortEntry[i].PortStatus;\n\t\tif (reason_code ==\n\t\t\t\tMPI26_EVENT_PCIE_TOPO_PS_DELAY_NOT_RESPONDING)\n\t\t\t_scsih_block_io_device(ioc, handle);\n\t}\n}\n \nstatic void\n_scsih_tm_tr_send(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tMpi2SCSITaskManagementRequest_t *mpi_request;\n\tu16 smid;\n\tstruct _sas_device *sas_device = NULL;\n\tstruct _pcie_device *pcie_device = NULL;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data = NULL;\n\tu64 sas_address = 0;\n\tunsigned long flags;\n\tstruct _tr_list *delayed_tr;\n\tu32 ioc_state;\n\tu8 tr_method = 0;\n\tstruct hba_port *port = NULL;\n\n\tif (ioc->pci_error_recovery) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host in pci error recovery: handle(0x%04x)\\n\",\n\t\t\t\t    __func__, handle));\n\t\treturn;\n\t}\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 1);\n\tif (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host is not operational: handle(0x%04x)\\n\",\n\t\t\t\t    __func__, handle));\n\t\treturn;\n\t}\n\n\t \n\tif (test_bit(handle, ioc->pd_handles))\n\t\treturn;\n\n\tclear_bit(handle, ioc->pend_os_device_add);\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_handle(ioc, handle);\n\tif (sas_device && sas_device->starget &&\n\t    sas_device->starget->hostdata) {\n\t\tsas_target_priv_data = sas_device->starget->hostdata;\n\t\tsas_target_priv_data->deleted = 1;\n\t\tsas_address = sas_device->sas_address;\n\t\tport = sas_device->port;\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\tif (!sas_device) {\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\tpcie_device = __mpt3sas_get_pdev_by_handle(ioc, handle);\n\t\tif (pcie_device && pcie_device->starget &&\n\t\t\tpcie_device->starget->hostdata) {\n\t\t\tsas_target_priv_data = pcie_device->starget->hostdata;\n\t\t\tsas_target_priv_data->deleted = 1;\n\t\t\tsas_address = pcie_device->wwid;\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\tif (pcie_device && (!ioc->tm_custom_handling) &&\n\t\t    (!(mpt3sas_scsih_is_pcie_scsi_device(\n\t\t    pcie_device->device_info))))\n\t\t\ttr_method =\n\t\t\t    MPI26_SCSITASKMGMT_MSGFLAGS_PROTOCOL_LVL_RST_PCIE;\n\t\telse\n\t\t\ttr_method = MPI2_SCSITASKMGMT_MSGFLAGS_LINK_RESET;\n\t}\n\tif (sas_target_priv_data) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"setting delete flag: handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t\t    handle, (u64)sas_address));\n\t\tif (sas_device) {\n\t\t\tif (sas_device->enclosure_handle != 0)\n\t\t\t\tdewtprintk(ioc,\n\t\t\t\t\t   ioc_info(ioc, \"setting delete flag:enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t\t\t    (u64)sas_device->enclosure_logical_id,\n\t\t\t\t\t\t    sas_device->slot));\n\t\t\tif (sas_device->connector_name[0] != '\\0')\n\t\t\t\tdewtprintk(ioc,\n\t\t\t\t\t   ioc_info(ioc, \"setting delete flag: enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t\t\t    sas_device->enclosure_level,\n\t\t\t\t\t\t    sas_device->connector_name));\n\t\t} else if (pcie_device) {\n\t\t\tif (pcie_device->enclosure_handle != 0)\n\t\t\t\tdewtprintk(ioc,\n\t\t\t\t\t   ioc_info(ioc, \"setting delete flag: logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t\t\t    (u64)pcie_device->enclosure_logical_id,\n\t\t\t\t\t\t    pcie_device->slot));\n\t\t\tif (pcie_device->connector_name[0] != '\\0')\n\t\t\t\tdewtprintk(ioc,\n\t\t\t\t\t   ioc_info(ioc, \"setting delete flag:, enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t\t\t    pcie_device->enclosure_level,\n\t\t\t\t\t\t    pcie_device->connector_name));\n\t\t}\n\t\t_scsih_ublock_io_device(ioc, sas_address, port);\n\t\tsas_target_priv_data->handle = MPT3SAS_INVALID_DEVICE_HANDLE;\n\t}\n\n\tsmid = mpt3sas_base_get_smid_hpr(ioc, ioc->tm_tr_cb_idx);\n\tif (!smid) {\n\t\tdelayed_tr = kzalloc(sizeof(*delayed_tr), GFP_ATOMIC);\n\t\tif (!delayed_tr)\n\t\t\tgoto out;\n\t\tINIT_LIST_HEAD(&delayed_tr->list);\n\t\tdelayed_tr->handle = handle;\n\t\tlist_add_tail(&delayed_tr->list, &ioc->delayed_tr_list);\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"DELAYED:tr:handle(0x%04x), (open)\\n\",\n\t\t\t\t    handle));\n\t\tgoto out;\n\t}\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"tr_send:handle(0x%04x), (open), smid(%d), cb(%d)\\n\",\n\t\t\t    handle, smid, ioc->tm_tr_cb_idx));\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(mpi_request, 0, sizeof(Mpi2SCSITaskManagementRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;\n\tmpi_request->DevHandle = cpu_to_le16(handle);\n\tmpi_request->TaskType = MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET;\n\tmpi_request->MsgFlags = tr_method;\n\tset_bit(handle, ioc->device_remove_in_progress);\n\tioc->put_smid_hi_priority(ioc, smid, 0);\n\tmpt3sas_trigger_master(ioc, MASTER_TRIGGER_DEVICE_REMOVAL);\n\nout:\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n\tif (pcie_device)\n\t\tpcie_device_put(pcie_device);\n}\n\n \nstatic u8\n_scsih_tm_tr_complete(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\n\tu32 reply)\n{\n\tu16 handle;\n\tMpi2SCSITaskManagementRequest_t *mpi_request_tm;\n\tMpi2SCSITaskManagementReply_t *mpi_reply =\n\t    mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tMpi2SasIoUnitControlRequest_t *mpi_request;\n\tu16 smid_sas_ctrl;\n\tu32 ioc_state;\n\tstruct _sc_list *delayed_sc;\n\n\tif (ioc->pci_error_recovery) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host in pci error recovery\\n\",\n\t\t\t\t    __func__));\n\t\treturn 1;\n\t}\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 1);\n\tif (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host is not operational\\n\",\n\t\t\t\t    __func__));\n\t\treturn 1;\n\t}\n\tif (unlikely(!mpi_reply)) {\n\t\tioc_err(ioc, \"mpi_reply not valid at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 1;\n\t}\n\tmpi_request_tm = mpt3sas_base_get_msg_frame(ioc, smid);\n\thandle = le16_to_cpu(mpi_request_tm->DevHandle);\n\tif (handle != le16_to_cpu(mpi_reply->DevHandle)) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_err(ioc, \"spurious interrupt: handle(0x%04x:0x%04x), smid(%d)!!!\\n\",\n\t\t\t\t   handle,\n\t\t\t\t   le16_to_cpu(mpi_reply->DevHandle), smid));\n\t\treturn 0;\n\t}\n\n\tmpt3sas_trigger_master(ioc, MASTER_TRIGGER_TASK_MANAGMENT);\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"tr_complete:handle(0x%04x), (open) smid(%d), ioc_status(0x%04x), loginfo(0x%08x), completed(%d)\\n\",\n\t\t\t    handle, smid, le16_to_cpu(mpi_reply->IOCStatus),\n\t\t\t    le32_to_cpu(mpi_reply->IOCLogInfo),\n\t\t\t    le32_to_cpu(mpi_reply->TerminationCount)));\n\n\tsmid_sas_ctrl = mpt3sas_base_get_smid(ioc, ioc->tm_sas_control_cb_idx);\n\tif (!smid_sas_ctrl) {\n\t\tdelayed_sc = kzalloc(sizeof(*delayed_sc), GFP_ATOMIC);\n\t\tif (!delayed_sc)\n\t\t\treturn _scsih_check_for_pending_tm(ioc, smid);\n\t\tINIT_LIST_HEAD(&delayed_sc->list);\n\t\tdelayed_sc->handle = le16_to_cpu(mpi_request_tm->DevHandle);\n\t\tlist_add_tail(&delayed_sc->list, &ioc->delayed_sc_list);\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"DELAYED:sc:handle(0x%04x), (open)\\n\",\n\t\t\t\t    handle));\n\t\treturn _scsih_check_for_pending_tm(ioc, smid);\n\t}\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"sc_send:handle(0x%04x), (open), smid(%d), cb(%d)\\n\",\n\t\t\t    handle, smid_sas_ctrl, ioc->tm_sas_control_cb_idx));\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid_sas_ctrl);\n\tmemset(mpi_request, 0, sizeof(Mpi2SasIoUnitControlRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_SAS_IO_UNIT_CONTROL;\n\tmpi_request->Operation = MPI2_SAS_OP_REMOVE_DEVICE;\n\tmpi_request->DevHandle = mpi_request_tm->DevHandle;\n\tioc->put_smid_default(ioc, smid_sas_ctrl);\n\n\treturn _scsih_check_for_pending_tm(ioc, smid);\n}\n\n \ninline bool _scsih_allow_scmd_to_device(struct MPT3SAS_ADAPTER *ioc,\n\tstruct scsi_cmnd *scmd)\n{\n\n\tif (ioc->pci_error_recovery)\n\t\treturn false;\n\n\tif (ioc->hba_mpi_version_belonged == MPI2_VERSION) {\n\t\tif (ioc->remove_host)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\tif (ioc->remove_host) {\n\n\t\tswitch (scmd->cmnd[0]) {\n\t\tcase SYNCHRONIZE_CACHE:\n\t\tcase START_STOP:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic u8\n_scsih_sas_control_complete(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tu8 msix_index, u32 reply)\n{\n\tMpi2SasIoUnitControlReply_t *mpi_reply =\n\t    mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\n\tif (likely(mpi_reply)) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"sc_complete:handle(0x%04x), (open) smid(%d), ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t    le16_to_cpu(mpi_reply->DevHandle), smid,\n\t\t\t\t    le16_to_cpu(mpi_reply->IOCStatus),\n\t\t\t\t    le32_to_cpu(mpi_reply->IOCLogInfo)));\n\t\tif (le16_to_cpu(mpi_reply->IOCStatus) ==\n\t\t     MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tclear_bit(le16_to_cpu(mpi_reply->DevHandle),\n\t\t\t    ioc->device_remove_in_progress);\n\t\t}\n\t} else {\n\t\tioc_err(ioc, \"mpi_reply not valid at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t}\n\treturn mpt3sas_check_for_pending_internal_cmds(ioc, smid);\n}\n\n \nstatic void\n_scsih_tm_tr_volume_send(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tMpi2SCSITaskManagementRequest_t *mpi_request;\n\tu16 smid;\n\tstruct _tr_list *delayed_tr;\n\n\tif (ioc->pci_error_recovery) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host reset in progress!\\n\",\n\t\t\t\t    __func__));\n\t\treturn;\n\t}\n\n\tsmid = mpt3sas_base_get_smid_hpr(ioc, ioc->tm_tr_volume_cb_idx);\n\tif (!smid) {\n\t\tdelayed_tr = kzalloc(sizeof(*delayed_tr), GFP_ATOMIC);\n\t\tif (!delayed_tr)\n\t\t\treturn;\n\t\tINIT_LIST_HEAD(&delayed_tr->list);\n\t\tdelayed_tr->handle = handle;\n\t\tlist_add_tail(&delayed_tr->list, &ioc->delayed_tr_volume_list);\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"DELAYED:tr:handle(0x%04x), (open)\\n\",\n\t\t\t\t    handle));\n\t\treturn;\n\t}\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"tr_send:handle(0x%04x), (open), smid(%d), cb(%d)\\n\",\n\t\t\t    handle, smid, ioc->tm_tr_volume_cb_idx));\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(mpi_request, 0, sizeof(Mpi2SCSITaskManagementRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;\n\tmpi_request->DevHandle = cpu_to_le16(handle);\n\tmpi_request->TaskType = MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET;\n\tioc->put_smid_hi_priority(ioc, smid, 0);\n}\n\n \nstatic u8\n_scsih_tm_volume_tr_complete(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tu8 msix_index, u32 reply)\n{\n\tu16 handle;\n\tMpi2SCSITaskManagementRequest_t *mpi_request_tm;\n\tMpi2SCSITaskManagementReply_t *mpi_reply =\n\t    mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\n\tif (ioc->shost_recovery || ioc->pci_error_recovery) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host reset in progress!\\n\",\n\t\t\t\t    __func__));\n\t\treturn 1;\n\t}\n\tif (unlikely(!mpi_reply)) {\n\t\tioc_err(ioc, \"mpi_reply not valid at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 1;\n\t}\n\n\tmpi_request_tm = mpt3sas_base_get_msg_frame(ioc, smid);\n\thandle = le16_to_cpu(mpi_request_tm->DevHandle);\n\tif (handle != le16_to_cpu(mpi_reply->DevHandle)) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_err(ioc, \"spurious interrupt: handle(0x%04x:0x%04x), smid(%d)!!!\\n\",\n\t\t\t\t   handle, le16_to_cpu(mpi_reply->DevHandle),\n\t\t\t\t   smid));\n\t\treturn 0;\n\t}\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"tr_complete:handle(0x%04x), (open) smid(%d), ioc_status(0x%04x), loginfo(0x%08x), completed(%d)\\n\",\n\t\t\t    handle, smid, le16_to_cpu(mpi_reply->IOCStatus),\n\t\t\t    le32_to_cpu(mpi_reply->IOCLogInfo),\n\t\t\t    le32_to_cpu(mpi_reply->TerminationCount)));\n\n\treturn _scsih_check_for_pending_tm(ioc, smid);\n}\n\n \nstatic void\n_scsih_issue_delayed_event_ack(struct MPT3SAS_ADAPTER *ioc, u16 smid, U16 event,\n\t\t\t\tU32 event_context)\n{\n\tMpi2EventAckRequest_t *ack_request;\n\tint i = smid - ioc->internal_smid;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tioc->internal_lookup[i].cb_idx = ioc->base_cb_idx;\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"EVENT ACK: event(0x%04x), smid(%d), cb(%d)\\n\",\n\t\t\t    le16_to_cpu(event), smid, ioc->base_cb_idx));\n\tack_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(ack_request, 0, sizeof(Mpi2EventAckRequest_t));\n\tack_request->Function = MPI2_FUNCTION_EVENT_ACK;\n\tack_request->Event = event;\n\tack_request->EventContext = event_context;\n\tack_request->VF_ID = 0;   \n\tack_request->VP_ID = 0;\n\tioc->put_smid_default(ioc, smid);\n}\n\n \nstatic void\n_scsih_issue_delayed_sas_io_unit_ctrl(struct MPT3SAS_ADAPTER *ioc,\n\t\t\t\t\tu16 smid, u16 handle)\n{\n\tMpi2SasIoUnitControlRequest_t *mpi_request;\n\tu32 ioc_state;\n\tint i = smid - ioc->internal_smid;\n\tunsigned long flags;\n\n\tif (ioc->remove_host) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host has been removed\\n\",\n\t\t\t\t    __func__));\n\t\treturn;\n\t} else if (ioc->pci_error_recovery) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host in pci error recovery\\n\",\n\t\t\t\t    __func__));\n\t\treturn;\n\t}\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 1);\n\tif (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host is not operational\\n\",\n\t\t\t\t    __func__));\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tioc->internal_lookup[i].cb_idx = ioc->tm_sas_control_cb_idx;\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"sc_send:handle(0x%04x), (open), smid(%d), cb(%d)\\n\",\n\t\t\t    handle, smid, ioc->tm_sas_control_cb_idx));\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(mpi_request, 0, sizeof(Mpi2SasIoUnitControlRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_SAS_IO_UNIT_CONTROL;\n\tmpi_request->Operation = MPI2_SAS_OP_REMOVE_DEVICE;\n\tmpi_request->DevHandle = cpu_to_le16(handle);\n\tioc->put_smid_default(ioc, smid);\n}\n\n \nu8\nmpt3sas_check_for_pending_internal_cmds(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tstruct _sc_list *delayed_sc;\n\tstruct _event_ack_list *delayed_event_ack;\n\n\tif (!list_empty(&ioc->delayed_event_ack_list)) {\n\t\tdelayed_event_ack = list_entry(ioc->delayed_event_ack_list.next,\n\t\t\t\t\t\tstruct _event_ack_list, list);\n\t\t_scsih_issue_delayed_event_ack(ioc, smid,\n\t\t  delayed_event_ack->Event, delayed_event_ack->EventContext);\n\t\tlist_del(&delayed_event_ack->list);\n\t\tkfree(delayed_event_ack);\n\t\treturn 0;\n\t}\n\n\tif (!list_empty(&ioc->delayed_sc_list)) {\n\t\tdelayed_sc = list_entry(ioc->delayed_sc_list.next,\n\t\t\t\t\t\tstruct _sc_list, list);\n\t\t_scsih_issue_delayed_sas_io_unit_ctrl(ioc, smid,\n\t\t\t\t\t\t delayed_sc->handle);\n\t\tlist_del(&delayed_sc->list);\n\t\tkfree(delayed_sc);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nstatic u8\n_scsih_check_for_pending_tm(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tstruct _tr_list *delayed_tr;\n\n\tif (!list_empty(&ioc->delayed_tr_volume_list)) {\n\t\tdelayed_tr = list_entry(ioc->delayed_tr_volume_list.next,\n\t\t    struct _tr_list, list);\n\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t_scsih_tm_tr_volume_send(ioc, delayed_tr->handle);\n\t\tlist_del(&delayed_tr->list);\n\t\tkfree(delayed_tr);\n\t\treturn 0;\n\t}\n\n\tif (!list_empty(&ioc->delayed_tr_list)) {\n\t\tdelayed_tr = list_entry(ioc->delayed_tr_list.next,\n\t\t    struct _tr_list, list);\n\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t_scsih_tm_tr_send(ioc, delayed_tr->handle);\n\t\tlist_del(&delayed_tr->list);\n\t\tkfree(delayed_tr);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic void\n_scsih_check_topo_delete_events(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataSasTopologyChangeList_t *event_data)\n{\n\tstruct fw_event_work *fw_event;\n\tMpi2EventDataSasTopologyChangeList_t *local_event_data;\n\tu16 expander_handle;\n\tstruct _sas_node *sas_expander;\n\tunsigned long flags;\n\tint i, reason_code;\n\tu16 handle;\n\n\tfor (i = 0 ; i < event_data->NumEntries; i++) {\n\t\thandle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\treason_code = event_data->PHY[i].PhyStatus &\n\t\t    MPI2_EVENT_SAS_TOPO_RC_MASK;\n\t\tif (reason_code == MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING)\n\t\t\t_scsih_tm_tr_send(ioc, handle);\n\t}\n\n\texpander_handle = le16_to_cpu(event_data->ExpanderDevHandle);\n\tif (expander_handle < ioc->sas_hba.num_phys) {\n\t\t_scsih_block_io_to_children_attached_directly(ioc, event_data);\n\t\treturn;\n\t}\n\tif (event_data->ExpStatus ==\n\t    MPI2_EVENT_SAS_TOPO_ES_DELAY_NOT_RESPONDING) {\n\t\t \n\t\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\t\tsas_expander = mpt3sas_scsih_expander_find_by_handle(ioc,\n\t\t    expander_handle);\n\t\t_scsih_block_io_to_children_attached_to_ex(ioc, sas_expander);\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t\tdo {\n\t\t\thandle = find_first_bit(ioc->blocking_handles,\n\t\t\t    ioc->facts.MaxDevHandle);\n\t\t\tif (handle < ioc->facts.MaxDevHandle)\n\t\t\t\t_scsih_block_io_device(ioc, handle);\n\t\t} while (test_and_clear_bit(handle, ioc->blocking_handles));\n\t} else if (event_data->ExpStatus == MPI2_EVENT_SAS_TOPO_ES_RESPONDING)\n\t\t_scsih_block_io_to_children_attached_directly(ioc, event_data);\n\n\tif (event_data->ExpStatus != MPI2_EVENT_SAS_TOPO_ES_NOT_RESPONDING)\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\tlist_for_each_entry(fw_event, &ioc->fw_event_list, list) {\n\t\tif (fw_event->event != MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST ||\n\t\t    fw_event->ignore)\n\t\t\tcontinue;\n\t\tlocal_event_data = (Mpi2EventDataSasTopologyChangeList_t *)\n\t\t\t\t   fw_event->event_data;\n\t\tif (local_event_data->ExpStatus ==\n\t\t    MPI2_EVENT_SAS_TOPO_ES_ADDED ||\n\t\t    local_event_data->ExpStatus ==\n\t\t    MPI2_EVENT_SAS_TOPO_ES_RESPONDING) {\n\t\t\tif (le16_to_cpu(local_event_data->ExpanderDevHandle) ==\n\t\t\t    expander_handle) {\n\t\t\t\tdewtprintk(ioc,\n\t\t\t\t\t   ioc_info(ioc, \"setting ignoring flag\\n\"));\n\t\t\t\tfw_event->ignore = 1;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n}\n\n \nstatic void\n_scsih_check_pcie_topo_remove_events(struct MPT3SAS_ADAPTER *ioc,\n\tMpi26EventDataPCIeTopologyChangeList_t *event_data)\n{\n\tstruct fw_event_work *fw_event;\n\tMpi26EventDataPCIeTopologyChangeList_t *local_event_data;\n\tunsigned long flags;\n\tint i, reason_code;\n\tu16 handle, switch_handle;\n\n\tfor (i = 0; i < event_data->NumEntries; i++) {\n\t\thandle =\n\t\t\tle16_to_cpu(event_data->PortEntry[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\treason_code = event_data->PortEntry[i].PortStatus;\n\t\tif (reason_code == MPI26_EVENT_PCIE_TOPO_PS_NOT_RESPONDING)\n\t\t\t_scsih_tm_tr_send(ioc, handle);\n\t}\n\n\tswitch_handle = le16_to_cpu(event_data->SwitchDevHandle);\n\tif (!switch_handle) {\n\t\t_scsih_block_io_to_pcie_children_attached_directly(\n\t\t\t\t\t\t\tioc, event_data);\n\t\treturn;\n\t}\n     \n\tif ((event_data->SwitchStatus\n\t\t== MPI26_EVENT_PCIE_TOPO_SS_DELAY_NOT_RESPONDING) ||\n\t\t(event_data->SwitchStatus ==\n\t\t\t\t\tMPI26_EVENT_PCIE_TOPO_SS_RESPONDING))\n\t\t_scsih_block_io_to_pcie_children_attached_directly(\n\t\t\t\t\t\t\tioc, event_data);\n\n\tif (event_data->SwitchStatus != MPI2_EVENT_SAS_TOPO_ES_NOT_RESPONDING)\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\tlist_for_each_entry(fw_event, &ioc->fw_event_list, list) {\n\t\tif (fw_event->event != MPI2_EVENT_PCIE_TOPOLOGY_CHANGE_LIST ||\n\t\t\tfw_event->ignore)\n\t\t\tcontinue;\n\t\tlocal_event_data =\n\t\t\t(Mpi26EventDataPCIeTopologyChangeList_t *)\n\t\t\tfw_event->event_data;\n\t\tif (local_event_data->SwitchStatus ==\n\t\t    MPI2_EVENT_SAS_TOPO_ES_ADDED ||\n\t\t    local_event_data->SwitchStatus ==\n\t\t    MPI2_EVENT_SAS_TOPO_ES_RESPONDING) {\n\t\t\tif (le16_to_cpu(local_event_data->SwitchDevHandle) ==\n\t\t\t\tswitch_handle) {\n\t\t\t\tdewtprintk(ioc,\n\t\t\t\t\t   ioc_info(ioc, \"setting ignoring flag for switch event\\n\"));\n\t\t\t\tfw_event->ignore = 1;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n}\n\n \nstatic void\n_scsih_set_volume_delete_flag(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _raid_device *raid_device;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\traid_device = mpt3sas_raid_device_find_by_handle(ioc, handle);\n\tif (raid_device && raid_device->starget &&\n\t    raid_device->starget->hostdata) {\n\t\tsas_target_priv_data =\n\t\t    raid_device->starget->hostdata;\n\t\tsas_target_priv_data->deleted = 1;\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"setting delete flag: handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t\t    handle, (u64)raid_device->wwid));\n\t}\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n}\n\n \nstatic void\n_scsih_set_volume_handle_for_tr(u16 handle, u16 *a, u16 *b)\n{\n\tif (!handle || handle == *a || handle == *b)\n\t\treturn;\n\tif (!*a)\n\t\t*a = handle;\n\telse if (!*b)\n\t\t*b = handle;\n}\n\n \nstatic void\n_scsih_check_ir_config_unhide_events(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataIrConfigChangeList_t *event_data)\n{\n\tMpi2EventIrConfigElement_t *element;\n\tint i;\n\tu16 handle, volume_handle, a, b;\n\tstruct _tr_list *delayed_tr;\n\n\ta = 0;\n\tb = 0;\n\n\tif (ioc->is_warpdrive)\n\t\treturn;\n\n\t \n\telement = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];\n\tfor (i = 0; i < event_data->NumElements; i++, element++) {\n\t\tif (le32_to_cpu(event_data->Flags) &\n\t\t    MPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG)\n\t\t\tcontinue;\n\t\tif (element->ReasonCode ==\n\t\t    MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED ||\n\t\t    element->ReasonCode ==\n\t\t    MPI2_EVENT_IR_CHANGE_RC_REMOVED) {\n\t\t\tvolume_handle = le16_to_cpu(element->VolDevHandle);\n\t\t\t_scsih_set_volume_delete_flag(ioc, volume_handle);\n\t\t\t_scsih_set_volume_handle_for_tr(volume_handle, &a, &b);\n\t\t}\n\t}\n\n\t \n\telement = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];\n\tfor (i = 0; i < event_data->NumElements; i++, element++) {\n\t\tif (le32_to_cpu(event_data->Flags) &\n\t\t    MPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG)\n\t\t\tcontinue;\n\t\tif (element->ReasonCode == MPI2_EVENT_IR_CHANGE_RC_UNHIDE) {\n\t\t\tvolume_handle = le16_to_cpu(element->VolDevHandle);\n\t\t\t_scsih_set_volume_handle_for_tr(volume_handle, &a, &b);\n\t\t}\n\t}\n\n\tif (a)\n\t\t_scsih_tm_tr_volume_send(ioc, a);\n\tif (b)\n\t\t_scsih_tm_tr_volume_send(ioc, b);\n\n\t \n\telement = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];\n\tfor (i = 0; i < event_data->NumElements; i++, element++) {\n\t\tif (element->ReasonCode != MPI2_EVENT_IR_CHANGE_RC_UNHIDE)\n\t\t\tcontinue;\n\t\thandle = le16_to_cpu(element->PhysDiskDevHandle);\n\t\tvolume_handle = le16_to_cpu(element->VolDevHandle);\n\t\tclear_bit(handle, ioc->pd_handles);\n\t\tif (!volume_handle)\n\t\t\t_scsih_tm_tr_send(ioc, handle);\n\t\telse if (volume_handle == a || volume_handle == b) {\n\t\t\tdelayed_tr = kzalloc(sizeof(*delayed_tr), GFP_ATOMIC);\n\t\t\tBUG_ON(!delayed_tr);\n\t\t\tINIT_LIST_HEAD(&delayed_tr->list);\n\t\t\tdelayed_tr->handle = handle;\n\t\t\tlist_add_tail(&delayed_tr->list, &ioc->delayed_tr_list);\n\t\t\tdewtprintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"DELAYED:tr:handle(0x%04x), (open)\\n\",\n\t\t\t\t\t    handle));\n\t\t} else\n\t\t\t_scsih_tm_tr_send(ioc, handle);\n\t}\n}\n\n\n \nstatic void\n_scsih_check_volume_delete_events(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataIrVolume_t *event_data)\n{\n\tu32 state;\n\n\tif (event_data->ReasonCode != MPI2_EVENT_IR_VOLUME_RC_STATE_CHANGED)\n\t\treturn;\n\tstate = le32_to_cpu(event_data->NewValue);\n\tif (state == MPI2_RAID_VOL_STATE_MISSING || state ==\n\t    MPI2_RAID_VOL_STATE_FAILED)\n\t\t_scsih_set_volume_delete_flag(ioc,\n\t\t    le16_to_cpu(event_data->VolDevHandle));\n}\n\n \nstatic void\n_scsih_temp_threshold_events(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataTemperature_t *event_data)\n{\n\tu32 doorbell;\n\tif (ioc->temp_sensors_count >= event_data->SensorNum) {\n\t\tioc_err(ioc, \"Temperature Threshold flags %s%s%s%s exceeded for Sensor: %d !!!\\n\",\n\t\t\tle16_to_cpu(event_data->Status) & 0x1 ? \"0 \" : \" \",\n\t\t\tle16_to_cpu(event_data->Status) & 0x2 ? \"1 \" : \" \",\n\t\t\tle16_to_cpu(event_data->Status) & 0x4 ? \"2 \" : \" \",\n\t\t\tle16_to_cpu(event_data->Status) & 0x8 ? \"3 \" : \" \",\n\t\t\tevent_data->SensorNum);\n\t\tioc_err(ioc, \"Current Temp In Celsius: %d\\n\",\n\t\t\tevent_data->CurrentTemperature);\n\t\tif (ioc->hba_mpi_version_belonged != MPI2_VERSION) {\n\t\t\tdoorbell = mpt3sas_base_get_iocstate(ioc, 0);\n\t\t\tif ((doorbell & MPI2_IOC_STATE_MASK) ==\n\t\t\t    MPI2_IOC_STATE_FAULT) {\n\t\t\t\tmpt3sas_print_fault_code(ioc,\n\t\t\t\t    doorbell & MPI2_DOORBELL_DATA_MASK);\n\t\t\t} else if ((doorbell & MPI2_IOC_STATE_MASK) ==\n\t\t\t    MPI2_IOC_STATE_COREDUMP) {\n\t\t\t\tmpt3sas_print_coredump_info(ioc,\n\t\t\t\t    doorbell & MPI2_DOORBELL_DATA_MASK);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int _scsih_set_satl_pending(struct scsi_cmnd *scmd, bool pending)\n{\n\tstruct MPT3SAS_DEVICE *priv = scmd->device->hostdata;\n\n\tif (scmd->cmnd[0] != ATA_12 && scmd->cmnd[0] != ATA_16)\n\t\treturn 0;\n\n\tif (pending)\n\t\treturn test_and_set_bit(0, &priv->ata_command_pending);\n\n\tclear_bit(0, &priv->ata_command_pending);\n\treturn 0;\n}\n\n \nstatic void\n_scsih_flush_running_cmds(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct scsi_cmnd *scmd;\n\tstruct scsiio_tracker *st;\n\tu16 smid;\n\tint count = 0;\n\n\tfor (smid = 1; smid <= ioc->scsiio_depth; smid++) {\n\t\tscmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);\n\t\tif (!scmd)\n\t\t\tcontinue;\n\t\tcount++;\n\t\t_scsih_set_satl_pending(scmd, false);\n\t\tst = scsi_cmd_priv(scmd);\n\t\tmpt3sas_base_clear_st(ioc, st);\n\t\tscsi_dma_unmap(scmd);\n\t\tif (ioc->pci_error_recovery || ioc->remove_host)\n\t\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\telse\n\t\t\tscmd->result = DID_RESET << 16;\n\t\tscsi_done(scmd);\n\t}\n\tdtmprintk(ioc, ioc_info(ioc, \"completing %d cmds\\n\", count));\n}\n\n \nstatic void\n_scsih_setup_eedp(struct MPT3SAS_ADAPTER *ioc, struct scsi_cmnd *scmd,\n\tMpi25SCSIIORequest_t *mpi_request)\n{\n\tu16 eedp_flags;\n\tMpi25SCSIIORequest_t *mpi_request_3v =\n\t   (Mpi25SCSIIORequest_t *)mpi_request;\n\n\tswitch (scsi_get_prot_op(scmd)) {\n\tcase SCSI_PROT_READ_STRIP:\n\t\teedp_flags = MPI2_SCSIIO_EEDPFLAGS_CHECK_REMOVE_OP;\n\t\tbreak;\n\tcase SCSI_PROT_WRITE_INSERT:\n\t\teedp_flags = MPI2_SCSIIO_EEDPFLAGS_INSERT_OP;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (scmd->prot_flags & SCSI_PROT_GUARD_CHECK)\n\t\teedp_flags |= MPI2_SCSIIO_EEDPFLAGS_CHECK_GUARD;\n\n\tif (scmd->prot_flags & SCSI_PROT_REF_CHECK)\n\t\teedp_flags |= MPI2_SCSIIO_EEDPFLAGS_CHECK_REFTAG;\n\n\tif (scmd->prot_flags & SCSI_PROT_REF_INCREMENT) {\n\t\teedp_flags |= MPI2_SCSIIO_EEDPFLAGS_INC_PRI_REFTAG;\n\n\t\tmpi_request->CDB.EEDP32.PrimaryReferenceTag =\n\t\t\tcpu_to_be32(scsi_prot_ref_tag(scmd));\n\t}\n\n\tmpi_request_3v->EEDPBlockSize = cpu_to_le16(scsi_prot_interval(scmd));\n\n\tif (ioc->is_gen35_ioc)\n\t\teedp_flags |= MPI25_SCSIIO_EEDPFLAGS_APPTAG_DISABLE_MODE;\n\tmpi_request->EEDPFlags = cpu_to_le16(eedp_flags);\n}\n\n \nstatic void\n_scsih_eedp_error_handling(struct scsi_cmnd *scmd, u16 ioc_status)\n{\n\tu8 ascq;\n\n\tswitch (ioc_status) {\n\tcase MPI2_IOCSTATUS_EEDP_GUARD_ERROR:\n\t\tascq = 0x01;\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:\n\t\tascq = 0x02;\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:\n\t\tascq = 0x03;\n\t\tbreak;\n\tdefault:\n\t\tascq = 0x00;\n\t\tbreak;\n\t}\n\tscsi_build_sense(scmd, 0, ILLEGAL_REQUEST, 0x10, ascq);\n\tset_host_byte(scmd, DID_ABORT);\n}\n\n \nstatic int\nscsih_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *scmd)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct _raid_device *raid_device;\n\tstruct request *rq = scsi_cmd_to_rq(scmd);\n\tint class;\n\tMpi25SCSIIORequest_t *mpi_request;\n\tstruct _pcie_device *pcie_device = NULL;\n\tu32 mpi_control;\n\tu16 smid;\n\tu16 handle;\n\n\tif (ioc->logging_level & MPT_DEBUG_SCSI)\n\t\tscsi_print_command(scmd);\n\n\tsas_device_priv_data = scmd->device->hostdata;\n\tif (!sas_device_priv_data || !sas_device_priv_data->sas_target) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tif (!(_scsih_allow_scmd_to_device(ioc, scmd))) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tsas_target_priv_data = sas_device_priv_data->sas_target;\n\n\t \n\thandle = sas_target_priv_data->handle;\n\n\t \n\tif (handle == MPT3SAS_INVALID_DEVICE_HANDLE || sas_device_priv_data->block) {\n\t\tif (scmd->device->host->shost_state == SHOST_RECOVERY &&\n\t\t    scmd->cmnd[0] == TEST_UNIT_READY) {\n\t\t\tscsi_build_sense(scmd, 0, UNIT_ATTENTION, 0x29, 0x07);\n\t\t\tscsi_done(scmd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (handle == MPT3SAS_INVALID_DEVICE_HANDLE) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\n\tif (ioc->shost_recovery || ioc->ioc_link_reset_in_progress) {\n\t\t \n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t} else if (sas_target_priv_data->deleted) {\n\t\t \n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\t} else if (sas_target_priv_data->tm_busy ||\n\t\t   sas_device_priv_data->block) {\n\t\t \n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t}\n\n\t \n\tdo {\n\t\tif (test_bit(0, &sas_device_priv_data->ata_command_pending))\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t} while (_scsih_set_satl_pending(scmd, true));\n\n\tif (scmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\tmpi_control = MPI2_SCSIIO_CONTROL_READ;\n\telse if (scmd->sc_data_direction == DMA_TO_DEVICE)\n\t\tmpi_control = MPI2_SCSIIO_CONTROL_WRITE;\n\telse\n\t\tmpi_control = MPI2_SCSIIO_CONTROL_NODATATRANSFER;\n\n\t \n\tmpi_control |= MPI2_SCSIIO_CONTROL_SIMPLEQ;\n\t \n\tif (sas_device_priv_data->ncq_prio_enable) {\n\t\tclass = IOPRIO_PRIO_CLASS(req_get_ioprio(rq));\n\t\tif (class == IOPRIO_CLASS_RT)\n\t\t\tmpi_control |= 1 << MPI2_SCSIIO_CONTROL_CMDPRI_SHIFT;\n\t}\n\t \n\tif (((!ioc->is_warpdrive && !scsih_is_raid(&scmd->device->sdev_gendev))\n\t\t&& !scsih_is_nvme(&scmd->device->sdev_gendev))\n\t\t&& sas_is_tlr_enabled(scmd->device) && scmd->cmd_len != 32)\n\t\tmpi_control |= MPI2_SCSIIO_CONTROL_TLR_ON;\n\n\tsmid = mpt3sas_base_get_smid_scsiio(ioc, ioc->scsi_io_cb_idx, scmd);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\t_scsih_set_satl_pending(scmd, false);\n\t\tgoto out;\n\t}\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(mpi_request, 0, ioc->request_sz);\n\t_scsih_setup_eedp(ioc, scmd, mpi_request);\n\n\tif (scmd->cmd_len == 32)\n\t\tmpi_control |= 4 << MPI2_SCSIIO_CONTROL_ADDCDBLEN_SHIFT;\n\tmpi_request->Function = MPI2_FUNCTION_SCSI_IO_REQUEST;\n\tif (sas_device_priv_data->sas_target->flags &\n\t    MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\tmpi_request->Function = MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH;\n\telse\n\t\tmpi_request->Function = MPI2_FUNCTION_SCSI_IO_REQUEST;\n\tmpi_request->DevHandle = cpu_to_le16(handle);\n\tmpi_request->DataLength = cpu_to_le32(scsi_bufflen(scmd));\n\tmpi_request->Control = cpu_to_le32(mpi_control);\n\tmpi_request->IoFlags = cpu_to_le16(scmd->cmd_len);\n\tmpi_request->MsgFlags = MPI2_SCSIIO_MSGFLAGS_SYSTEM_SENSE_ADDR;\n\tmpi_request->SenseBufferLength = SCSI_SENSE_BUFFERSIZE;\n\tmpi_request->SenseBufferLowAddress =\n\t    mpt3sas_base_get_sense_buffer_dma(ioc, smid);\n\tmpi_request->SGLOffset0 = offsetof(Mpi25SCSIIORequest_t, SGL) / 4;\n\tint_to_scsilun(sas_device_priv_data->lun, (struct scsi_lun *)\n\t    mpi_request->LUN);\n\tmemcpy(mpi_request->CDB.CDB32, scmd->cmnd, scmd->cmd_len);\n\n\tif (mpi_request->DataLength) {\n\t\tpcie_device = sas_target_priv_data->pcie_dev;\n\t\tif (ioc->build_sg_scmd(ioc, scmd, smid, pcie_device)) {\n\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\t_scsih_set_satl_pending(scmd, false);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tioc->build_zero_len_sge(ioc, &mpi_request->SGL);\n\n\traid_device = sas_target_priv_data->raid_device;\n\tif (raid_device && raid_device->direct_io_enabled)\n\t\tmpt3sas_setup_direct_io(ioc, scmd,\n\t\t\traid_device, mpi_request);\n\n\tif (likely(mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST)) {\n\t\tif (sas_target_priv_data->flags & MPT_TARGET_FASTPATH_IO) {\n\t\t\tmpi_request->IoFlags = cpu_to_le16(scmd->cmd_len |\n\t\t\t    MPI25_SCSIIO_IOFLAGS_FAST_PATH);\n\t\t\tioc->put_smid_fast_path(ioc, smid, handle);\n\t\t} else\n\t\t\tioc->put_smid_scsi_io(ioc, smid,\n\t\t\t    le16_to_cpu(mpi_request->DevHandle));\n\t} else\n\t\tioc->put_smid_default(ioc, smid);\n\treturn 0;\n\n out:\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n}\n\n \nstatic void\n_scsih_normalize_sense(char *sense_buffer, struct sense_info *data)\n{\n\tif ((sense_buffer[0] & 0x7F) >= 0x72) {\n\t\t \n\t\tdata->skey = sense_buffer[1] & 0x0F;\n\t\tdata->asc = sense_buffer[2];\n\t\tdata->ascq = sense_buffer[3];\n\t} else {\n\t\t \n\t\tdata->skey = sense_buffer[2] & 0x0F;\n\t\tdata->asc = sense_buffer[12];\n\t\tdata->ascq = sense_buffer[13];\n\t}\n}\n\n \nstatic void\n_scsih_scsi_ioc_info(struct MPT3SAS_ADAPTER *ioc, struct scsi_cmnd *scmd,\n\tMpi2SCSIIOReply_t *mpi_reply, u16 smid)\n{\n\tu32 response_info;\n\tu8 *response_bytes;\n\tu16 ioc_status = le16_to_cpu(mpi_reply->IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tu8 scsi_state = mpi_reply->SCSIState;\n\tu8 scsi_status = mpi_reply->SCSIStatus;\n\tchar *desc_ioc_state = NULL;\n\tchar *desc_scsi_status = NULL;\n\tchar *desc_scsi_state = ioc->tmp_string;\n\tu32 log_info = le32_to_cpu(mpi_reply->IOCLogInfo);\n\tstruct _sas_device *sas_device = NULL;\n\tstruct _pcie_device *pcie_device = NULL;\n\tstruct scsi_target *starget = scmd->device->sdev_target;\n\tstruct MPT3SAS_TARGET *priv_target = starget->hostdata;\n\tchar *device_str = NULL;\n\n\tif (!priv_target)\n\t\treturn;\n\tif (ioc->hide_ir_msg)\n\t\tdevice_str = \"WarpDrive\";\n\telse\n\t\tdevice_str = \"volume\";\n\n\tif (log_info == 0x31170000)\n\t\treturn;\n\n\tswitch (ioc_status) {\n\tcase MPI2_IOCSTATUS_SUCCESS:\n\t\tdesc_ioc_state = \"success\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INVALID_FUNCTION:\n\t\tdesc_ioc_state = \"invalid function\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_RECOVERED_ERROR:\n\t\tdesc_ioc_state = \"scsi recovered error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_INVALID_DEVHANDLE:\n\t\tdesc_ioc_state = \"scsi invalid dev handle\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\n\t\tdesc_ioc_state = \"scsi device not there\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_DATA_OVERRUN:\n\t\tdesc_ioc_state = \"scsi data overrun\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN:\n\t\tdesc_ioc_state = \"scsi data underrun\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_IO_DATA_ERROR:\n\t\tdesc_ioc_state = \"scsi io data error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_PROTOCOL_ERROR:\n\t\tdesc_ioc_state = \"scsi protocol error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_TASK_TERMINATED:\n\t\tdesc_ioc_state = \"scsi task terminated\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:\n\t\tdesc_ioc_state = \"scsi residual mismatch\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_TASK_MGMT_FAILED:\n\t\tdesc_ioc_state = \"scsi task mgmt failed\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_IOC_TERMINATED:\n\t\tdesc_ioc_state = \"scsi ioc terminated\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_EXT_TERMINATED:\n\t\tdesc_ioc_state = \"scsi ext terminated\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_EEDP_GUARD_ERROR:\n\t\tdesc_ioc_state = \"eedp guard error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:\n\t\tdesc_ioc_state = \"eedp ref tag error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:\n\t\tdesc_ioc_state = \"eedp app tag error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INSUFFICIENT_POWER:\n\t\tdesc_ioc_state = \"insufficient power\";\n\t\tbreak;\n\tdefault:\n\t\tdesc_ioc_state = \"unknown\";\n\t\tbreak;\n\t}\n\n\tswitch (scsi_status) {\n\tcase MPI2_SCSI_STATUS_GOOD:\n\t\tdesc_scsi_status = \"good\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_CHECK_CONDITION:\n\t\tdesc_scsi_status = \"check condition\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_CONDITION_MET:\n\t\tdesc_scsi_status = \"condition met\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_BUSY:\n\t\tdesc_scsi_status = \"busy\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_INTERMEDIATE:\n\t\tdesc_scsi_status = \"intermediate\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_INTERMEDIATE_CONDMET:\n\t\tdesc_scsi_status = \"intermediate condmet\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_RESERVATION_CONFLICT:\n\t\tdesc_scsi_status = \"reservation conflict\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_COMMAND_TERMINATED:\n\t\tdesc_scsi_status = \"command terminated\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_TASK_SET_FULL:\n\t\tdesc_scsi_status = \"task set full\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_ACA_ACTIVE:\n\t\tdesc_scsi_status = \"aca active\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_TASK_ABORTED:\n\t\tdesc_scsi_status = \"task aborted\";\n\t\tbreak;\n\tdefault:\n\t\tdesc_scsi_status = \"unknown\";\n\t\tbreak;\n\t}\n\n\tdesc_scsi_state[0] = '\\0';\n\tif (!scsi_state)\n\t\tdesc_scsi_state = \" \";\n\tif (scsi_state & MPI2_SCSI_STATE_RESPONSE_INFO_VALID)\n\t\tstrcat(desc_scsi_state, \"response info \");\n\tif (scsi_state & MPI2_SCSI_STATE_TERMINATED)\n\t\tstrcat(desc_scsi_state, \"state terminated \");\n\tif (scsi_state & MPI2_SCSI_STATE_NO_SCSI_STATUS)\n\t\tstrcat(desc_scsi_state, \"no status \");\n\tif (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_FAILED)\n\t\tstrcat(desc_scsi_state, \"autosense failed \");\n\tif (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID)\n\t\tstrcat(desc_scsi_state, \"autosense valid \");\n\n\tscsi_print_command(scmd);\n\n\tif (priv_target->flags & MPT_TARGET_FLAGS_VOLUME) {\n\t\tioc_warn(ioc, \"\\t%s wwid(0x%016llx)\\n\",\n\t\t\t device_str, (u64)priv_target->sas_address);\n\t} else if (priv_target->flags & MPT_TARGET_FLAGS_PCIE_DEVICE) {\n\t\tpcie_device = mpt3sas_get_pdev_from_target(ioc, priv_target);\n\t\tif (pcie_device) {\n\t\t\tioc_info(ioc, \"\\twwid(0x%016llx), port(%d)\\n\",\n\t\t\t\t (u64)pcie_device->wwid, pcie_device->port_num);\n\t\t\tif (pcie_device->enclosure_handle != 0)\n\t\t\t\tioc_info(ioc, \"\\tenclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t\t (u64)pcie_device->enclosure_logical_id,\n\t\t\t\t\t pcie_device->slot);\n\t\t\tif (pcie_device->connector_name[0])\n\t\t\t\tioc_info(ioc, \"\\tenclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t\t pcie_device->enclosure_level,\n\t\t\t\t\t pcie_device->connector_name);\n\t\t\tpcie_device_put(pcie_device);\n\t\t}\n\t} else {\n\t\tsas_device = mpt3sas_get_sdev_from_target(ioc, priv_target);\n\t\tif (sas_device) {\n\t\t\tioc_warn(ioc, \"\\tsas_address(0x%016llx), phy(%d)\\n\",\n\t\t\t\t (u64)sas_device->sas_address, sas_device->phy);\n\n\t\t\t_scsih_display_enclosure_chassis_info(ioc, sas_device,\n\t\t\t    NULL, NULL);\n\n\t\t\tsas_device_put(sas_device);\n\t\t}\n\t}\n\n\tioc_warn(ioc, \"\\thandle(0x%04x), ioc_status(%s)(0x%04x), smid(%d)\\n\",\n\t\t le16_to_cpu(mpi_reply->DevHandle),\n\t\t desc_ioc_state, ioc_status, smid);\n\tioc_warn(ioc, \"\\trequest_len(%d), underflow(%d), resid(%d)\\n\",\n\t\t scsi_bufflen(scmd), scmd->underflow, scsi_get_resid(scmd));\n\tioc_warn(ioc, \"\\ttag(%d), transfer_count(%d), sc->result(0x%08x)\\n\",\n\t\t le16_to_cpu(mpi_reply->TaskTag),\n\t\t le32_to_cpu(mpi_reply->TransferCount), scmd->result);\n\tioc_warn(ioc, \"\\tscsi_status(%s)(0x%02x), scsi_state(%s)(0x%02x)\\n\",\n\t\t desc_scsi_status, scsi_status, desc_scsi_state, scsi_state);\n\n\tif (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID) {\n\t\tstruct sense_info data;\n\t\t_scsih_normalize_sense(scmd->sense_buffer, &data);\n\t\tioc_warn(ioc, \"\\t[sense_key,asc,ascq]: [0x%02x,0x%02x,0x%02x], count(%d)\\n\",\n\t\t\t data.skey, data.asc, data.ascq,\n\t\t\t le32_to_cpu(mpi_reply->SenseCount));\n\t}\n\tif (scsi_state & MPI2_SCSI_STATE_RESPONSE_INFO_VALID) {\n\t\tresponse_info = le32_to_cpu(mpi_reply->ResponseInfo);\n\t\tresponse_bytes = (u8 *)&response_info;\n\t\t_scsih_response_code(ioc, response_bytes[0]);\n\t}\n}\n\n \nstatic void\n_scsih_turn_on_pfa_led(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tMpi2SepReply_t mpi_reply;\n\tMpi2SepRequest_t mpi_request;\n\tstruct _sas_device *sas_device;\n\n\tsas_device = mpt3sas_get_sdev_by_handle(ioc, handle);\n\tif (!sas_device)\n\t\treturn;\n\n\tmemset(&mpi_request, 0, sizeof(Mpi2SepRequest_t));\n\tmpi_request.Function = MPI2_FUNCTION_SCSI_ENCLOSURE_PROCESSOR;\n\tmpi_request.Action = MPI2_SEP_REQ_ACTION_WRITE_STATUS;\n\tmpi_request.SlotStatus =\n\t    cpu_to_le32(MPI2_SEP_REQ_SLOTSTATUS_PREDICTED_FAULT);\n\tmpi_request.DevHandle = cpu_to_le16(handle);\n\tmpi_request.Flags = MPI2_SEP_REQ_FLAGS_DEVHANDLE_ADDRESS;\n\tif ((mpt3sas_base_scsi_enclosure_processor(ioc, &mpi_reply,\n\t    &mpi_request)) != 0) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tsas_device->pfa_led_on = 1;\n\n\tif (mpi_reply.IOCStatus || mpi_reply.IOCLogInfo) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"enclosure_processor: ioc_status (0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t    le16_to_cpu(mpi_reply.IOCStatus),\n\t\t\t\t    le32_to_cpu(mpi_reply.IOCLogInfo)));\n\t\tgoto out;\n\t}\nout:\n\tsas_device_put(sas_device);\n}\n\n \nstatic void\n_scsih_turn_off_pfa_led(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_device *sas_device)\n{\n\tMpi2SepReply_t mpi_reply;\n\tMpi2SepRequest_t mpi_request;\n\n\tmemset(&mpi_request, 0, sizeof(Mpi2SepRequest_t));\n\tmpi_request.Function = MPI2_FUNCTION_SCSI_ENCLOSURE_PROCESSOR;\n\tmpi_request.Action = MPI2_SEP_REQ_ACTION_WRITE_STATUS;\n\tmpi_request.SlotStatus = 0;\n\tmpi_request.Slot = cpu_to_le16(sas_device->slot);\n\tmpi_request.DevHandle = 0;\n\tmpi_request.EnclosureHandle = cpu_to_le16(sas_device->enclosure_handle);\n\tmpi_request.Flags = MPI2_SEP_REQ_FLAGS_ENCLOSURE_SLOT_ADDRESS;\n\tif ((mpt3sas_base_scsi_enclosure_processor(ioc, &mpi_reply,\n\t\t&mpi_request)) != 0) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tif (mpi_reply.IOCStatus || mpi_reply.IOCLogInfo) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"enclosure_processor: ioc_status (0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t    le16_to_cpu(mpi_reply.IOCStatus),\n\t\t\t\t    le32_to_cpu(mpi_reply.IOCLogInfo)));\n\t\treturn;\n\t}\n}\n\n \nstatic void\n_scsih_send_event_to_turn_on_pfa_led(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct fw_event_work *fw_event;\n\n\tfw_event = alloc_fw_event_work(0);\n\tif (!fw_event)\n\t\treturn;\n\tfw_event->event = MPT3SAS_TURN_ON_PFA_LED;\n\tfw_event->device_handle = handle;\n\tfw_event->ioc = ioc;\n\t_scsih_fw_event_add(ioc, fw_event);\n\tfw_event_work_put(fw_event);\n}\n\n \nstatic void\n_scsih_smart_predicted_fault(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct scsi_target *starget;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tMpi2EventNotificationReply_t *event_reply;\n\tMpi2EventDataSasDeviceStatusChange_t *event_data;\n\tstruct _sas_device *sas_device;\n\tssize_t sz;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_handle(ioc, handle);\n\tif (!sas_device)\n\t\tgoto out_unlock;\n\n\tstarget = sas_device->starget;\n\tsas_target_priv_data = starget->hostdata;\n\n\tif ((sas_target_priv_data->flags & MPT_TARGET_FLAGS_RAID_COMPONENT) ||\n\t   ((sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME)))\n\t\tgoto out_unlock;\n\n\t_scsih_display_enclosure_chassis_info(NULL, sas_device, NULL, starget);\n\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\tif (ioc->pdev->subsystem_vendor == PCI_VENDOR_ID_IBM)\n\t\t_scsih_send_event_to_turn_on_pfa_led(ioc, handle);\n\n\t \n\tsz = offsetof(Mpi2EventNotificationReply_t, EventData) +\n\t     sizeof(Mpi2EventDataSasDeviceStatusChange_t);\n\tevent_reply = kzalloc(sz, GFP_ATOMIC);\n\tif (!event_reply) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\tevent_reply->Function = MPI2_FUNCTION_EVENT_NOTIFICATION;\n\tevent_reply->Event =\n\t    cpu_to_le16(MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE);\n\tevent_reply->MsgLength = sz/4;\n\tevent_reply->EventDataLength =\n\t    cpu_to_le16(sizeof(Mpi2EventDataSasDeviceStatusChange_t)/4);\n\tevent_data = (Mpi2EventDataSasDeviceStatusChange_t *)\n\t    event_reply->EventData;\n\tevent_data->ReasonCode = MPI2_EVENT_SAS_DEV_STAT_RC_SMART_DATA;\n\tevent_data->ASC = 0x5D;\n\tevent_data->DevHandle = cpu_to_le16(handle);\n\tevent_data->SASAddress = cpu_to_le64(sas_target_priv_data->sas_address);\n\tmpt3sas_ctl_add_to_event_log(ioc, event_reply);\n\tkfree(event_reply);\nout:\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n\treturn;\n\nout_unlock:\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\tgoto out;\n}\n\n \nstatic u8\n_scsih_io_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)\n{\n\tMpi25SCSIIORequest_t *mpi_request;\n\tMpi2SCSIIOReply_t *mpi_reply;\n\tstruct scsi_cmnd *scmd;\n\tstruct scsiio_tracker *st;\n\tu16 ioc_status;\n\tu32 xfer_cnt;\n\tu8 scsi_state;\n\tu8 scsi_status;\n\tu32 log_info;\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tu32 response_code = 0;\n\n\tmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\n\tscmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);\n\tif (scmd == NULL)\n\t\treturn 1;\n\n\t_scsih_set_satl_pending(scmd, false);\n\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\n\tif (mpi_reply == NULL) {\n\t\tscmd->result = DID_OK << 16;\n\t\tgoto out;\n\t}\n\n\tsas_device_priv_data = scmd->device->hostdata;\n\tif (!sas_device_priv_data || !sas_device_priv_data->sas_target ||\n\t     sas_device_priv_data->sas_target->deleted) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tgoto out;\n\t}\n\tioc_status = le16_to_cpu(mpi_reply->IOCStatus);\n\n\t \n\tst = scsi_cmd_priv(scmd);\n\tif (st->direct_io &&\n\t     ((ioc_status & MPI2_IOCSTATUS_MASK)\n\t      != MPI2_IOCSTATUS_SCSI_TASK_TERMINATED)) {\n\t\tst->direct_io = 0;\n\t\tst->scmd = scmd;\n\t\tmemcpy(mpi_request->CDB.CDB32, scmd->cmnd, scmd->cmd_len);\n\t\tmpi_request->DevHandle =\n\t\t    cpu_to_le16(sas_device_priv_data->sas_target->handle);\n\t\tioc->put_smid_scsi_io(ioc, smid,\n\t\t    sas_device_priv_data->sas_target->handle);\n\t\treturn 0;\n\t}\n\t \n\tscsi_state = mpi_reply->SCSIState;\n\tif (scsi_state & MPI2_SCSI_STATE_RESPONSE_INFO_VALID)\n\t\tresponse_code =\n\t\t    le32_to_cpu(mpi_reply->ResponseInfo) & 0xFF;\n\tif (!sas_device_priv_data->tlr_snoop_check) {\n\t\tsas_device_priv_data->tlr_snoop_check++;\n\t\tif ((!ioc->is_warpdrive &&\n\t\t    !scsih_is_raid(&scmd->device->sdev_gendev) &&\n\t\t    !scsih_is_nvme(&scmd->device->sdev_gendev))\n\t\t    && sas_is_tlr_enabled(scmd->device) &&\n\t\t    response_code == MPI2_SCSITASKMGMT_RSP_INVALID_FRAME) {\n\t\t\tsas_disable_tlr(scmd->device);\n\t\t\tsdev_printk(KERN_INFO, scmd->device, \"TLR disabled\\n\");\n\t\t}\n\t}\n\n\txfer_cnt = le32_to_cpu(mpi_reply->TransferCount);\n\tscsi_set_resid(scmd, scsi_bufflen(scmd) - xfer_cnt);\n\tif (ioc_status & MPI2_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE)\n\t\tlog_info =  le32_to_cpu(mpi_reply->IOCLogInfo);\n\telse\n\t\tlog_info = 0;\n\tioc_status &= MPI2_IOCSTATUS_MASK;\n\tscsi_status = mpi_reply->SCSIStatus;\n\n\tif (ioc_status == MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN && xfer_cnt == 0 &&\n\t    (scsi_status == MPI2_SCSI_STATUS_BUSY ||\n\t     scsi_status == MPI2_SCSI_STATUS_RESERVATION_CONFLICT ||\n\t     scsi_status == MPI2_SCSI_STATUS_TASK_SET_FULL)) {\n\t\tioc_status = MPI2_IOCSTATUS_SUCCESS;\n\t}\n\n\tif (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID) {\n\t\tstruct sense_info data;\n\t\tconst void *sense_data = mpt3sas_base_get_sense_buffer(ioc,\n\t\t    smid);\n\t\tu32 sz = min_t(u32, SCSI_SENSE_BUFFERSIZE,\n\t\t    le32_to_cpu(mpi_reply->SenseCount));\n\t\tmemcpy(scmd->sense_buffer, sense_data, sz);\n\t\t_scsih_normalize_sense(scmd->sense_buffer, &data);\n\t\t \n\t\tif (data.asc == 0x5D)\n\t\t\t_scsih_smart_predicted_fault(ioc,\n\t\t\t    le16_to_cpu(mpi_reply->DevHandle));\n\t\tmpt3sas_trigger_scsi(ioc, data.skey, data.asc, data.ascq);\n\n\t\tif ((ioc->logging_level & MPT_DEBUG_REPLY) &&\n\t\t     ((scmd->sense_buffer[2] == UNIT_ATTENTION) ||\n\t\t     (scmd->sense_buffer[2] == MEDIUM_ERROR) ||\n\t\t     (scmd->sense_buffer[2] == HARDWARE_ERROR)))\n\t\t\t_scsih_scsi_ioc_info(ioc, scmd, mpi_reply, smid);\n\t}\n\tswitch (ioc_status) {\n\tcase MPI2_IOCSTATUS_BUSY:\n\tcase MPI2_IOCSTATUS_INSUFFICIENT_RESOURCES:\n\t\tscmd->result = SAM_STAT_BUSY;\n\t\tbreak;\n\n\tcase MPI2_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tbreak;\n\n\tcase MPI2_IOCSTATUS_SCSI_IOC_TERMINATED:\n\t\tif (sas_device_priv_data->block) {\n\t\t\tscmd->result = DID_TRANSPORT_DISRUPTED << 16;\n\t\t\tgoto out;\n\t\t}\n\t\tif (log_info == 0x31110630) {\n\t\t\tif (scmd->retries > 2) {\n\t\t\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\t\t\tscsi_device_set_state(scmd->device,\n\t\t\t\t    SDEV_OFFLINE);\n\t\t\t} else {\n\t\t\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\t\t\tscmd->device->expecting_cc_ua = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (log_info == VIRTUAL_IO_FAILED_RETRY) {\n\t\t\tscmd->result = DID_RESET << 16;\n\t\t\tbreak;\n\t\t} else if ((scmd->device->channel == RAID_CHANNEL) &&\n\t\t   (scsi_state == (MPI2_SCSI_STATE_TERMINATED |\n\t\t   MPI2_SCSI_STATE_NO_SCSI_STATUS))) {\n\t\t\tscmd->result = DID_RESET << 16;\n\t\t\tbreak;\n\t\t}\n\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_TASK_TERMINATED:\n\tcase MPI2_IOCSTATUS_SCSI_EXT_TERMINATED:\n\t\tscmd->result = DID_RESET << 16;\n\t\tbreak;\n\n\tcase MPI2_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:\n\t\tif ((xfer_cnt == 0) || (scmd->underflow > xfer_cnt))\n\t\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\telse\n\t\t\tscmd->result = (DID_OK << 16) | scsi_status;\n\t\tbreak;\n\n\tcase MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN:\n\t\tscmd->result = (DID_OK << 16) | scsi_status;\n\n\t\tif ((scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID))\n\t\t\tbreak;\n\n\t\tif (xfer_cnt < scmd->underflow) {\n\t\t\tif (scsi_status == SAM_STAT_BUSY)\n\t\t\t\tscmd->result = SAM_STAT_BUSY;\n\t\t\telse\n\t\t\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\t} else if (scsi_state & (MPI2_SCSI_STATE_AUTOSENSE_FAILED |\n\t\t     MPI2_SCSI_STATE_NO_SCSI_STATUS))\n\t\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\telse if (scsi_state & MPI2_SCSI_STATE_TERMINATED)\n\t\t\tscmd->result = DID_RESET << 16;\n\t\telse if (!xfer_cnt && scmd->cmnd[0] == REPORT_LUNS) {\n\t\t\tmpi_reply->SCSIState = MPI2_SCSI_STATE_AUTOSENSE_VALID;\n\t\t\tmpi_reply->SCSIStatus = SAM_STAT_CHECK_CONDITION;\n\t\t\tscsi_build_sense(scmd, 0, ILLEGAL_REQUEST,\n\t\t\t\t\t 0x20, 0);\n\t\t}\n\t\tbreak;\n\n\tcase MPI2_IOCSTATUS_SCSI_DATA_OVERRUN:\n\t\tscsi_set_resid(scmd, 0);\n\t\tfallthrough;\n\tcase MPI2_IOCSTATUS_SCSI_RECOVERED_ERROR:\n\tcase MPI2_IOCSTATUS_SUCCESS:\n\t\tscmd->result = (DID_OK << 16) | scsi_status;\n\t\tif (response_code ==\n\t\t    MPI2_SCSITASKMGMT_RSP_INVALID_FRAME ||\n\t\t    (scsi_state & (MPI2_SCSI_STATE_AUTOSENSE_FAILED |\n\t\t     MPI2_SCSI_STATE_NO_SCSI_STATUS)))\n\t\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\telse if (scsi_state & MPI2_SCSI_STATE_TERMINATED)\n\t\t\tscmd->result = DID_RESET << 16;\n\t\tbreak;\n\n\tcase MPI2_IOCSTATUS_EEDP_GUARD_ERROR:\n\tcase MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:\n\tcase MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:\n\t\t_scsih_eedp_error_handling(scmd, ioc_status);\n\t\tbreak;\n\n\tcase MPI2_IOCSTATUS_SCSI_PROTOCOL_ERROR:\n\tcase MPI2_IOCSTATUS_INVALID_FUNCTION:\n\tcase MPI2_IOCSTATUS_INVALID_SGL:\n\tcase MPI2_IOCSTATUS_INTERNAL_ERROR:\n\tcase MPI2_IOCSTATUS_INVALID_FIELD:\n\tcase MPI2_IOCSTATUS_INVALID_STATE:\n\tcase MPI2_IOCSTATUS_SCSI_IO_DATA_ERROR:\n\tcase MPI2_IOCSTATUS_SCSI_TASK_MGMT_FAILED:\n\tcase MPI2_IOCSTATUS_INSUFFICIENT_POWER:\n\tdefault:\n\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\tbreak;\n\n\t}\n\n\tif (scmd->result && (ioc->logging_level & MPT_DEBUG_REPLY))\n\t\t_scsih_scsi_ioc_info(ioc , scmd, mpi_reply, smid);\n\n out:\n\n\tscsi_dma_unmap(scmd);\n\tmpt3sas_base_free_smid(ioc, smid);\n\tscsi_done(scmd);\n\treturn 0;\n}\n\n \nstatic void\n_scsih_update_vphys_after_reset(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu16 sz, ioc_status;\n\tint i;\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasIOUnitPage0_t *sas_iounit_pg0 = NULL;\n\tu16 attached_handle;\n\tu64 attached_sas_addr;\n\tu8 found = 0, port_id;\n\tMpi2SasPhyPage0_t phy_pg0;\n\tstruct hba_port *port, *port_next, *mport;\n\tstruct virtual_phy *vphy, *vphy_next;\n\tstruct _sas_device *sas_device;\n\n\t \n\tlist_for_each_entry_safe(port, port_next,\n\t    &ioc->port_table_list, list) {\n\t\tif (!port->vphys_mask)\n\t\t\tcontinue;\n\t\tlist_for_each_entry_safe(vphy, vphy_next,\n\t\t    &port->vphys_list, list) {\n\t\t\tvphy->flags |= MPT_VPHY_FLAG_DIRTY_PHY;\n\t\t}\n\t}\n\n\t \n\tsz = offsetof(Mpi2SasIOUnitPage0_t, PhyData) +\n\t    (ioc->sas_hba.num_phys * sizeof(Mpi2SasIOUnit0PhyData_t));\n\tsas_iounit_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_iounit_pg0) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\tif ((mpt3sas_config_get_sas_iounit_pg0(ioc, &mpi_reply,\n\t    sas_iounit_pg0, sz)) != 0)\n\t\tgoto out;\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\tgoto out;\n\t \n\tfor (i = 0; i < ioc->sas_hba.num_phys; i++) {\n\t\t \n\t\tif ((sas_iounit_pg0->PhyData[i].NegotiatedLinkRate >> 4) <\n\t\t    MPI2_SAS_NEG_LINK_RATE_1_5)\n\t\t\tcontinue;\n\t\t \n\t\tif (!(le32_to_cpu(\n\t\t    sas_iounit_pg0->PhyData[i].ControllerPhyDeviceInfo) &\n\t\t    MPI2_SAS_DEVICE_INFO_SEP))\n\t\t\tcontinue;\n\n\t\tif ((mpt3sas_config_get_phy_pg0(ioc, &mpi_reply, &phy_pg0,\n\t\t    i))) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(le32_to_cpu(phy_pg0.PhyInfo) &\n\t\t    MPI2_SAS_PHYINFO_VIRTUAL_PHY))\n\t\t\tcontinue;\n\t\t \n\t\tattached_handle = le16_to_cpu(\n\t\t    sas_iounit_pg0->PhyData[i].AttachedDevHandle);\n\t\tif (_scsih_get_sas_address(ioc, attached_handle,\n\t\t    &attached_sas_addr) != 0) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfound = 0;\n\t\tport = port_next = NULL;\n\t\t \n\t\tlist_for_each_entry_safe(port,\n\t\t    port_next, &ioc->port_table_list, list) {\n\t\t\tif (!port->vphys_mask)\n\t\t\t\tcontinue;\n\t\t\tlist_for_each_entry_safe(vphy, vphy_next,\n\t\t\t    &port->vphys_list, list) {\n\t\t\t\t \n\t\t\t\tif (!(vphy->flags & MPT_VPHY_FLAG_DIRTY_PHY))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tif (vphy->sas_address != attached_sas_addr)\n\t\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t\tif (!(vphy->phy_mask & (1 << i)))\n\t\t\t\t\tvphy->phy_mask = (1 << i);\n\t\t\t\t \n\t\t\t\tport_id = sas_iounit_pg0->PhyData[i].Port;\n\t\t\t\tmport = mpt3sas_get_port_by_id(ioc, port_id, 1);\n\t\t\t\tif (!mport) {\n\t\t\t\t\tmport = kzalloc(\n\t\t\t\t\t    sizeof(struct hba_port), GFP_KERNEL);\n\t\t\t\t\tif (!mport)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tmport->port_id = port_id;\n\t\t\t\t\tioc_info(ioc,\n\t\t\t\t\t    \"%s: hba_port entry: %p, port: %d is added to hba_port list\\n\",\n\t\t\t\t\t    __func__, mport, mport->port_id);\n\t\t\t\t\tlist_add_tail(&mport->list,\n\t\t\t\t\t\t&ioc->port_table_list);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (port != mport) {\n\t\t\t\t\tif (!mport->vphys_mask)\n\t\t\t\t\t\tINIT_LIST_HEAD(\n\t\t\t\t\t\t    &mport->vphys_list);\n\t\t\t\t\tmport->vphys_mask |= (1 << i);\n\t\t\t\t\tport->vphys_mask &= ~(1 << i);\n\t\t\t\t\tlist_move(&vphy->list,\n\t\t\t\t\t    &mport->vphys_list);\n\t\t\t\t\tsas_device = mpt3sas_get_sdev_by_addr(\n\t\t\t\t\t    ioc, attached_sas_addr, port);\n\t\t\t\t\tif (sas_device)\n\t\t\t\t\t\tsas_device->port = mport;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (mport->flags & HBA_PORT_FLAG_DIRTY_PORT) {\n\t\t\t\t\tmport->sas_address = 0;\n\t\t\t\t\tmport->phy_mask = 0;\n\t\t\t\t\tmport->flags &=\n\t\t\t\t\t    ~HBA_PORT_FLAG_DIRTY_PORT;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tvphy->flags &= ~MPT_VPHY_FLAG_DIRTY_PHY;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tkfree(sas_iounit_pg0);\n}\n\n \nstatic int\n_scsih_get_port_table_after_reset(struct MPT3SAS_ADAPTER *ioc,\n\tstruct hba_port *port_table)\n{\n\tu16 sz, ioc_status;\n\tint i, j;\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasIOUnitPage0_t *sas_iounit_pg0 = NULL;\n\tu16 attached_handle;\n\tu64 attached_sas_addr;\n\tu8 found = 0, port_count = 0, port_id;\n\n\tsz = offsetof(Mpi2SasIOUnitPage0_t, PhyData) + (ioc->sas_hba.num_phys\n\t    * sizeof(Mpi2SasIOUnit0PhyData_t));\n\tsas_iounit_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_iounit_pg0) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn port_count;\n\t}\n\n\tif ((mpt3sas_config_get_sas_iounit_pg0(ioc, &mpi_reply,\n\t    sas_iounit_pg0, sz)) != 0)\n\t\tgoto out;\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\tgoto out;\n\tfor (i = 0; i < ioc->sas_hba.num_phys; i++) {\n\t\tfound = 0;\n\t\tif ((sas_iounit_pg0->PhyData[i].NegotiatedLinkRate >> 4) <\n\t\t    MPI2_SAS_NEG_LINK_RATE_1_5)\n\t\t\tcontinue;\n\t\tattached_handle =\n\t\t    le16_to_cpu(sas_iounit_pg0->PhyData[i].AttachedDevHandle);\n\t\tif (_scsih_get_sas_address(\n\t\t    ioc, attached_handle, &attached_sas_addr) != 0) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < port_count; j++) {\n\t\t\tport_id = sas_iounit_pg0->PhyData[i].Port;\n\t\t\tif (port_table[j].port_id == port_id &&\n\t\t\t    port_table[j].sas_address == attached_sas_addr) {\n\t\t\t\tport_table[j].phy_mask |= (1 << i);\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\tport_id = sas_iounit_pg0->PhyData[i].Port;\n\t\tport_table[port_count].port_id = port_id;\n\t\tport_table[port_count].phy_mask = (1 << i);\n\t\tport_table[port_count].sas_address = attached_sas_addr;\n\t\tport_count++;\n\t}\nout:\n\tkfree(sas_iounit_pg0);\n\treturn port_count;\n}\n\nenum hba_port_matched_codes {\n\tNOT_MATCHED = 0,\n\tMATCHED_WITH_ADDR_AND_PHYMASK,\n\tMATCHED_WITH_ADDR_SUBPHYMASK_AND_PORT,\n\tMATCHED_WITH_ADDR_AND_SUBPHYMASK,\n\tMATCHED_WITH_ADDR,\n};\n\n \nstatic enum hba_port_matched_codes\n_scsih_look_and_get_matched_port_entry(struct MPT3SAS_ADAPTER *ioc,\n\tstruct hba_port *port_entry,\n\tstruct hba_port **matched_port_entry, int *count)\n{\n\tstruct hba_port *port_table_entry, *matched_port = NULL;\n\tenum hba_port_matched_codes matched_code = NOT_MATCHED;\n\tint lcount = 0;\n\t*matched_port_entry = NULL;\n\n\tlist_for_each_entry(port_table_entry, &ioc->port_table_list, list) {\n\t\tif (!(port_table_entry->flags & HBA_PORT_FLAG_DIRTY_PORT))\n\t\t\tcontinue;\n\n\t\tif ((port_table_entry->sas_address == port_entry->sas_address)\n\t\t    && (port_table_entry->phy_mask == port_entry->phy_mask)) {\n\t\t\tmatched_code = MATCHED_WITH_ADDR_AND_PHYMASK;\n\t\t\tmatched_port = port_table_entry;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((port_table_entry->sas_address == port_entry->sas_address)\n\t\t    && (port_table_entry->phy_mask & port_entry->phy_mask)\n\t\t    && (port_table_entry->port_id == port_entry->port_id)) {\n\t\t\tmatched_code = MATCHED_WITH_ADDR_SUBPHYMASK_AND_PORT;\n\t\t\tmatched_port = port_table_entry;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((port_table_entry->sas_address == port_entry->sas_address)\n\t\t    && (port_table_entry->phy_mask & port_entry->phy_mask)) {\n\t\t\tif (matched_code ==\n\t\t\t    MATCHED_WITH_ADDR_SUBPHYMASK_AND_PORT)\n\t\t\t\tcontinue;\n\t\t\tmatched_code = MATCHED_WITH_ADDR_AND_SUBPHYMASK;\n\t\t\tmatched_port = port_table_entry;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (port_table_entry->sas_address == port_entry->sas_address) {\n\t\t\tif (matched_code ==\n\t\t\t    MATCHED_WITH_ADDR_SUBPHYMASK_AND_PORT)\n\t\t\t\tcontinue;\n\t\t\tif (matched_code == MATCHED_WITH_ADDR_AND_SUBPHYMASK)\n\t\t\t\tcontinue;\n\t\t\tmatched_code = MATCHED_WITH_ADDR;\n\t\t\tmatched_port = port_table_entry;\n\t\t\tlcount++;\n\t\t}\n\t}\n\n\t*matched_port_entry = matched_port;\n\tif (matched_code ==  MATCHED_WITH_ADDR)\n\t\t*count = lcount;\n\treturn matched_code;\n}\n\n \nstatic void\n_scsih_del_phy_part_of_anther_port(struct MPT3SAS_ADAPTER *ioc,\n\tstruct hba_port *port_table,\n\tint index, u8 port_count, int offset)\n{\n\tstruct _sas_node *sas_node = &ioc->sas_hba;\n\tu32 i, found = 0;\n\n\tfor (i = 0; i < port_count; i++) {\n\t\tif (i == index)\n\t\t\tcontinue;\n\n\t\tif (port_table[i].phy_mask & (1 << offset)) {\n\t\t\tmpt3sas_transport_del_phy_from_an_existing_port(\n\t\t\t    ioc, sas_node, &sas_node->phy[offset]);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\tport_table[index].phy_mask |= (1 << offset);\n}\n\n \nstatic void\n_scsih_add_or_del_phys_from_existing_port(struct MPT3SAS_ADAPTER *ioc,\n\tstruct hba_port *hba_port_entry, struct hba_port *port_table,\n\tint index, int port_count)\n{\n\tu32 phy_mask, offset = 0;\n\tstruct _sas_node *sas_node = &ioc->sas_hba;\n\n\tphy_mask = hba_port_entry->phy_mask ^ port_table[index].phy_mask;\n\n\tfor (offset = 0; offset < ioc->sas_hba.num_phys; offset++) {\n\t\tif (phy_mask & (1 << offset)) {\n\t\t\tif (!(port_table[index].phy_mask & (1 << offset))) {\n\t\t\t\t_scsih_del_phy_part_of_anther_port(\n\t\t\t\t    ioc, port_table, index, port_count,\n\t\t\t\t    offset);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sas_node->phy[offset].phy_belongs_to_port)\n\t\t\t\tmpt3sas_transport_del_phy_from_an_existing_port(\n\t\t\t\t    ioc, sas_node, &sas_node->phy[offset]);\n\t\t\tmpt3sas_transport_add_phy_to_an_existing_port(\n\t\t\t    ioc, sas_node, &sas_node->phy[offset],\n\t\t\t    hba_port_entry->sas_address,\n\t\t\t    hba_port_entry);\n\t\t}\n\t}\n}\n\n \nstatic void\n_scsih_del_dirty_vphy(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct hba_port *port, *port_next;\n\tstruct virtual_phy *vphy, *vphy_next;\n\n\tlist_for_each_entry_safe(port, port_next,\n\t    &ioc->port_table_list, list) {\n\t\tif (!port->vphys_mask)\n\t\t\tcontinue;\n\t\tlist_for_each_entry_safe(vphy, vphy_next,\n\t\t    &port->vphys_list, list) {\n\t\t\tif (vphy->flags & MPT_VPHY_FLAG_DIRTY_PHY) {\n\t\t\t\tdrsprintk(ioc, ioc_info(ioc,\n\t\t\t\t    \"Deleting vphy %p entry from port id: %d\\t, Phy_mask 0x%08x\\n\",\n\t\t\t\t    vphy, port->port_id,\n\t\t\t\t    vphy->phy_mask));\n\t\t\t\tport->vphys_mask &= ~vphy->phy_mask;\n\t\t\t\tlist_del(&vphy->list);\n\t\t\t\tkfree(vphy);\n\t\t\t}\n\t\t}\n\t\tif (!port->vphys_mask && !port->sas_address)\n\t\t\tport->flags |= HBA_PORT_FLAG_DIRTY_PORT;\n\t}\n}\n\n \nstatic void\n_scsih_del_dirty_port_entries(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct hba_port *port, *port_next;\n\n\tlist_for_each_entry_safe(port, port_next,\n\t    &ioc->port_table_list, list) {\n\t\tif (!(port->flags & HBA_PORT_FLAG_DIRTY_PORT) ||\n\t\t    port->flags & HBA_PORT_FLAG_NEW_PORT)\n\t\t\tcontinue;\n\n\t\tdrsprintk(ioc, ioc_info(ioc,\n\t\t    \"Deleting port table entry %p having Port: %d\\t Phy_mask 0x%08x\\n\",\n\t\t    port, port->port_id, port->phy_mask));\n\t\tlist_del(&port->list);\n\t\tkfree(port);\n\t}\n}\n\n \nstatic void\n_scsih_sas_port_refresh(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 port_count = 0;\n\tstruct hba_port *port_table;\n\tstruct hba_port *port_table_entry;\n\tstruct hba_port *port_entry = NULL;\n\tint i, j, count = 0, lcount = 0;\n\tint ret;\n\tu64 sas_addr;\n\tu8 num_phys;\n\n\tdrsprintk(ioc, ioc_info(ioc,\n\t    \"updating ports for sas_host(0x%016llx)\\n\",\n\t    (unsigned long long)ioc->sas_hba.sas_address));\n\n\tmpt3sas_config_get_number_hba_phys(ioc, &num_phys);\n\tif (!num_phys) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tif (num_phys > ioc->sas_hba.nr_phys_allocated) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t   __FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\tioc->sas_hba.num_phys = num_phys;\n\n\tport_table = kcalloc(ioc->sas_hba.num_phys,\n\t    sizeof(struct hba_port), GFP_KERNEL);\n\tif (!port_table)\n\t\treturn;\n\n\tport_count = _scsih_get_port_table_after_reset(ioc, port_table);\n\tif (!port_count)\n\t\treturn;\n\n\tdrsprintk(ioc, ioc_info(ioc, \"New Port table\\n\"));\n\tfor (j = 0; j < port_count; j++)\n\t\tdrsprintk(ioc, ioc_info(ioc,\n\t\t    \"Port: %d\\t Phy_mask 0x%08x\\t sas_addr(0x%016llx)\\n\",\n\t\t    port_table[j].port_id,\n\t\t    port_table[j].phy_mask, port_table[j].sas_address));\n\n\tlist_for_each_entry(port_table_entry, &ioc->port_table_list, list)\n\t\tport_table_entry->flags |= HBA_PORT_FLAG_DIRTY_PORT;\n\n\tdrsprintk(ioc, ioc_info(ioc, \"Old Port table\\n\"));\n\tport_table_entry = NULL;\n\tlist_for_each_entry(port_table_entry, &ioc->port_table_list, list) {\n\t\tdrsprintk(ioc, ioc_info(ioc,\n\t\t    \"Port: %d\\t Phy_mask 0x%08x\\t sas_addr(0x%016llx)\\n\",\n\t\t    port_table_entry->port_id,\n\t\t    port_table_entry->phy_mask,\n\t\t    port_table_entry->sas_address));\n\t}\n\n\tfor (j = 0; j < port_count; j++) {\n\t\tret = _scsih_look_and_get_matched_port_entry(ioc,\n\t\t    &port_table[j], &port_entry, &count);\n\t\tif (!port_entry) {\n\t\t\tdrsprintk(ioc, ioc_info(ioc,\n\t\t\t    \"No Matched entry for sas_addr(0x%16llx), Port:%d\\n\",\n\t\t\t    port_table[j].sas_address,\n\t\t\t    port_table[j].port_id));\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase MATCHED_WITH_ADDR_SUBPHYMASK_AND_PORT:\n\t\tcase MATCHED_WITH_ADDR_AND_SUBPHYMASK:\n\t\t\t_scsih_add_or_del_phys_from_existing_port(ioc,\n\t\t\t    port_entry, port_table, j, port_count);\n\t\t\tbreak;\n\t\tcase MATCHED_WITH_ADDR:\n\t\t\tsas_addr = port_table[j].sas_address;\n\t\t\tfor (i = 0; i < port_count; i++) {\n\t\t\t\tif (port_table[i].sas_address == sas_addr)\n\t\t\t\t\tlcount++;\n\t\t\t}\n\n\t\t\tif (count > 1 || lcount > 1)\n\t\t\t\tport_entry = NULL;\n\t\t\telse\n\t\t\t\t_scsih_add_or_del_phys_from_existing_port(ioc,\n\t\t\t\t    port_entry, port_table, j, port_count);\n\t\t}\n\n\t\tif (!port_entry)\n\t\t\tcontinue;\n\n\t\tif (port_entry->port_id != port_table[j].port_id)\n\t\t\tport_entry->port_id = port_table[j].port_id;\n\t\tport_entry->flags &= ~HBA_PORT_FLAG_DIRTY_PORT;\n\t\tport_entry->phy_mask = port_table[j].phy_mask;\n\t}\n\n\tport_table_entry = NULL;\n}\n\n \nstatic struct virtual_phy *\n_scsih_alloc_vphy(struct MPT3SAS_ADAPTER *ioc, u8 port_id, u8 phy_num)\n{\n\tstruct virtual_phy *vphy;\n\tstruct hba_port *port;\n\n\tport = mpt3sas_get_port_by_id(ioc, port_id, 0);\n\tif (!port)\n\t\treturn NULL;\n\n\tvphy = mpt3sas_get_vphy_by_phy(ioc, port, phy_num);\n\tif (!vphy) {\n\t\tvphy = kzalloc(sizeof(struct virtual_phy), GFP_KERNEL);\n\t\tif (!vphy)\n\t\t\treturn NULL;\n\n\t\tif (!port->vphys_mask)\n\t\t\tINIT_LIST_HEAD(&port->vphys_list);\n\n\t\t \n\t\tport->vphys_mask |= (1 << phy_num);\n\t\tvphy->phy_mask |= (1 << phy_num);\n\n\t\tlist_add_tail(&vphy->list, &port->vphys_list);\n\n\t\tioc_info(ioc,\n\t\t    \"vphy entry: %p, port id: %d, phy:%d is added to port's vphys_list\\n\",\n\t\t    vphy, port->port_id, phy_num);\n\t}\n\treturn vphy;\n}\n\n \nstatic void\n_scsih_sas_host_refresh(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu16 sz;\n\tu16 ioc_status;\n\tint i;\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasIOUnitPage0_t *sas_iounit_pg0 = NULL;\n\tu16 attached_handle;\n\tu8 link_rate, port_id;\n\tstruct hba_port *port;\n\tMpi2SasPhyPage0_t phy_pg0;\n\n\tdtmprintk(ioc,\n\t\t  ioc_info(ioc, \"updating handles for sas_host(0x%016llx)\\n\",\n\t\t\t   (u64)ioc->sas_hba.sas_address));\n\n\tsz = offsetof(Mpi2SasIOUnitPage0_t, PhyData) + (ioc->sas_hba.num_phys\n\t    * sizeof(Mpi2SasIOUnit0PhyData_t));\n\tsas_iounit_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_iounit_pg0) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tif ((mpt3sas_config_get_sas_iounit_pg0(ioc, &mpi_reply,\n\t    sas_iounit_pg0, sz)) != 0)\n\t\tgoto out;\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\tgoto out;\n\tfor (i = 0; i < ioc->sas_hba.num_phys ; i++) {\n\t\tlink_rate = sas_iounit_pg0->PhyData[i].NegotiatedLinkRate >> 4;\n\t\tif (i == 0)\n\t\t\tioc->sas_hba.handle = le16_to_cpu(\n\t\t\t    sas_iounit_pg0->PhyData[0].ControllerDevHandle);\n\t\tport_id = sas_iounit_pg0->PhyData[i].Port;\n\t\tif (!(mpt3sas_get_port_by_id(ioc, port_id, 0))) {\n\t\t\tport = kzalloc(sizeof(struct hba_port), GFP_KERNEL);\n\t\t\tif (!port)\n\t\t\t\tgoto out;\n\n\t\t\tport->port_id = port_id;\n\t\t\tioc_info(ioc,\n\t\t\t    \"hba_port entry: %p, port: %d is added to hba_port list\\n\",\n\t\t\t    port, port->port_id);\n\t\t\tif (ioc->shost_recovery)\n\t\t\t\tport->flags = HBA_PORT_FLAG_NEW_PORT;\n\t\t\tlist_add_tail(&port->list, &ioc->port_table_list);\n\t\t}\n\t\t \n\t\tif (le32_to_cpu(sas_iounit_pg0->PhyData[i].ControllerPhyDeviceInfo) &\n\t\t    MPI2_SAS_DEVICE_INFO_SEP &&\n\t\t    (link_rate >=  MPI2_SAS_NEG_LINK_RATE_1_5)) {\n\t\t\tif ((mpt3sas_config_get_phy_pg0(ioc, &mpi_reply,\n\t\t\t    &phy_pg0, i))) {\n\t\t\t\tioc_err(ioc,\n\t\t\t\t    \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t     __FILE__, __LINE__, __func__);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!(le32_to_cpu(phy_pg0.PhyInfo) &\n\t\t\t    MPI2_SAS_PHYINFO_VIRTUAL_PHY))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (!_scsih_alloc_vphy(ioc, port_id, i))\n\t\t\t\tgoto out;\n\t\t\tioc->sas_hba.phy[i].hba_vphy = 1;\n\t\t}\n\n\t\t \n\t\tif (!ioc->sas_hba.phy[i].phy) {\n\t\t\tif ((mpt3sas_config_get_phy_pg0(ioc, &mpi_reply,\n\t\t\t\t\t\t\t&phy_pg0, i))) {\n\t\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t\t\tMPI2_IOCSTATUS_MASK;\n\t\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tioc->sas_hba.phy[i].phy_id = i;\n\t\t\tmpt3sas_transport_add_host_phy(ioc,\n\t\t\t\t&ioc->sas_hba.phy[i], phy_pg0,\n\t\t\t\tioc->sas_hba.parent_dev);\n\t\t\tcontinue;\n\t\t}\n\t\tioc->sas_hba.phy[i].handle = ioc->sas_hba.handle;\n\t\tattached_handle = le16_to_cpu(sas_iounit_pg0->PhyData[i].\n\t\t    AttachedDevHandle);\n\t\tif (attached_handle && link_rate < MPI2_SAS_NEG_LINK_RATE_1_5)\n\t\t\tlink_rate = MPI2_SAS_NEG_LINK_RATE_1_5;\n\t\tioc->sas_hba.phy[i].port =\n\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0);\n\t\tmpt3sas_transport_update_links(ioc, ioc->sas_hba.sas_address,\n\t\t    attached_handle, i, link_rate,\n\t\t    ioc->sas_hba.phy[i].port);\n\t}\n\t \n\tfor (i = ioc->sas_hba.num_phys;\n\t     i < ioc->sas_hba.nr_phys_allocated; i++) {\n\t\tif (ioc->sas_hba.phy[i].phy &&\n\t\t    ioc->sas_hba.phy[i].phy->negotiated_linkrate >=\n\t\t    SAS_LINK_RATE_1_5_GBPS)\n\t\t\tmpt3sas_transport_update_links(ioc,\n\t\t\t\tioc->sas_hba.sas_address, 0, i,\n\t\t\t\tMPI2_SAS_NEG_LINK_RATE_PHY_DISABLED, NULL);\n\t}\n out:\n\tkfree(sas_iounit_pg0);\n}\n\n \nstatic void\n_scsih_sas_host_add(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint i;\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasIOUnitPage0_t *sas_iounit_pg0 = NULL;\n\tMpi2SasIOUnitPage1_t *sas_iounit_pg1 = NULL;\n\tMpi2SasPhyPage0_t phy_pg0;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tMpi2SasEnclosurePage0_t enclosure_pg0;\n\tu16 ioc_status;\n\tu16 sz;\n\tu8 device_missing_delay;\n\tu8 num_phys, port_id;\n\tstruct hba_port *port;\n\n\tmpt3sas_config_get_number_hba_phys(ioc, &num_phys);\n\tif (!num_phys) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tioc->sas_hba.nr_phys_allocated = max_t(u8,\n\t    MPT_MAX_HBA_NUM_PHYS, num_phys);\n\tioc->sas_hba.phy = kcalloc(ioc->sas_hba.nr_phys_allocated,\n\t    sizeof(struct _sas_phy), GFP_KERNEL);\n\tif (!ioc->sas_hba.phy) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tioc->sas_hba.num_phys = num_phys;\n\n\t \n\tsz = offsetof(Mpi2SasIOUnitPage0_t, PhyData) + (ioc->sas_hba.num_phys *\n\t    sizeof(Mpi2SasIOUnit0PhyData_t));\n\tsas_iounit_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_iounit_pg0) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\tif ((mpt3sas_config_get_sas_iounit_pg0(ioc, &mpi_reply,\n\t    sas_iounit_pg0, sz))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\t \n\tsz = offsetof(Mpi2SasIOUnitPage1_t, PhyData) + (ioc->sas_hba.num_phys *\n\t    sizeof(Mpi2SasIOUnit1PhyData_t));\n\tsas_iounit_pg1 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_iounit_pg1) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tif ((mpt3sas_config_get_sas_iounit_pg1(ioc, &mpi_reply,\n\t    sas_iounit_pg1, sz))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\tioc->io_missing_delay =\n\t    sas_iounit_pg1->IODeviceMissingDelay;\n\tdevice_missing_delay =\n\t    sas_iounit_pg1->ReportDeviceMissingDelay;\n\tif (device_missing_delay & MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16)\n\t\tioc->device_missing_delay = (device_missing_delay &\n\t\t    MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK) * 16;\n\telse\n\t\tioc->device_missing_delay = device_missing_delay &\n\t\t    MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK;\n\n\tioc->sas_hba.parent_dev = &ioc->shost->shost_gendev;\n\tfor (i = 0; i < ioc->sas_hba.num_phys ; i++) {\n\t\tif ((mpt3sas_config_get_phy_pg0(ioc, &mpi_reply, &phy_pg0,\n\t\t    i))) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (i == 0)\n\t\t\tioc->sas_hba.handle = le16_to_cpu(sas_iounit_pg0->\n\t\t\t    PhyData[0].ControllerDevHandle);\n\n\t\tport_id = sas_iounit_pg0->PhyData[i].Port;\n\t\tif (!(mpt3sas_get_port_by_id(ioc, port_id, 0))) {\n\t\t\tport = kzalloc(sizeof(struct hba_port), GFP_KERNEL);\n\t\t\tif (!port)\n\t\t\t\tgoto out;\n\n\t\t\tport->port_id = port_id;\n\t\t\tioc_info(ioc,\n\t\t\t   \"hba_port entry: %p, port: %d is added to hba_port list\\n\",\n\t\t\t   port, port->port_id);\n\t\t\tlist_add_tail(&port->list,\n\t\t\t    &ioc->port_table_list);\n\t\t}\n\n\t\t \n\t\tif ((le32_to_cpu(phy_pg0.PhyInfo) &\n\t\t    MPI2_SAS_PHYINFO_VIRTUAL_PHY) &&\n\t\t    (phy_pg0.NegotiatedLinkRate >> 4) >=\n\t\t    MPI2_SAS_NEG_LINK_RATE_1_5) {\n\t\t\t \n\t\t\tif (!_scsih_alloc_vphy(ioc, port_id, i))\n\t\t\t\tgoto out;\n\t\t\tioc->sas_hba.phy[i].hba_vphy = 1;\n\t\t}\n\n\t\tioc->sas_hba.phy[i].handle = ioc->sas_hba.handle;\n\t\tioc->sas_hba.phy[i].phy_id = i;\n\t\tioc->sas_hba.phy[i].port =\n\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0);\n\t\tmpt3sas_transport_add_host_phy(ioc, &ioc->sas_hba.phy[i],\n\t\t    phy_pg0, ioc->sas_hba.parent_dev);\n\t}\n\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\n\t    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, ioc->sas_hba.handle))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tioc->sas_hba.enclosure_handle =\n\t    le16_to_cpu(sas_device_pg0.EnclosureHandle);\n\tioc->sas_hba.sas_address = le64_to_cpu(sas_device_pg0.SASAddress);\n\tioc_info(ioc, \"host_add: handle(0x%04x), sas_addr(0x%016llx), phys(%d)\\n\",\n\t\t ioc->sas_hba.handle,\n\t\t (u64)ioc->sas_hba.sas_address,\n\t\t ioc->sas_hba.num_phys);\n\n\tif (ioc->sas_hba.enclosure_handle) {\n\t\tif (!(mpt3sas_config_get_enclosure_pg0(ioc, &mpi_reply,\n\t\t    &enclosure_pg0, MPI2_SAS_ENCLOS_PGAD_FORM_HANDLE,\n\t\t   ioc->sas_hba.enclosure_handle)))\n\t\t\tioc->sas_hba.enclosure_logical_id =\n\t\t\t    le64_to_cpu(enclosure_pg0.EnclosureLogicalID);\n\t}\n\n out:\n\tkfree(sas_iounit_pg1);\n\tkfree(sas_iounit_pg0);\n}\n\n \nstatic int\n_scsih_expander_add(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _sas_node *sas_expander;\n\tstruct _enclosure_node *enclosure_dev;\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2ExpanderPage0_t expander_pg0;\n\tMpi2ExpanderPage1_t expander_pg1;\n\tu32 ioc_status;\n\tu16 parent_handle;\n\tu64 sas_address, sas_address_parent = 0;\n\tint i;\n\tunsigned long flags;\n\tstruct _sas_port *mpt3sas_port = NULL;\n\tu8 port_id;\n\n\tint rc = 0;\n\n\tif (!handle)\n\t\treturn -1;\n\n\tif (ioc->shost_recovery || ioc->pci_error_recovery)\n\t\treturn -1;\n\n\tif ((mpt3sas_config_get_expander_pg0(ioc, &mpi_reply, &expander_pg0,\n\t    MPI2_SAS_EXPAND_PGAD_FORM_HNDL, handle))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\t \n\tparent_handle = le16_to_cpu(expander_pg0.ParentDevHandle);\n\tif (_scsih_get_sas_address(ioc, parent_handle, &sas_address_parent)\n\t    != 0) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\tport_id = expander_pg0.PhysicalPort;\n\tif (sas_address_parent != ioc->sas_hba.sas_address) {\n\t\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\t\tsas_expander = mpt3sas_scsih_expander_find_by_sas_address(ioc,\n\t\t    sas_address_parent,\n\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0));\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t\tif (!sas_expander) {\n\t\t\trc = _scsih_expander_add(ioc, parent_handle);\n\t\t\tif (rc != 0)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tsas_address = le64_to_cpu(expander_pg0.SASAddress);\n\tsas_expander = mpt3sas_scsih_expander_find_by_sas_address(ioc,\n\t    sas_address, mpt3sas_get_port_by_id(ioc, port_id, 0));\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\n\tif (sas_expander)\n\t\treturn 0;\n\n\tsas_expander = kzalloc(sizeof(struct _sas_node),\n\t    GFP_KERNEL);\n\tif (!sas_expander) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\tsas_expander->handle = handle;\n\tsas_expander->num_phys = expander_pg0.NumPhys;\n\tsas_expander->sas_address_parent = sas_address_parent;\n\tsas_expander->sas_address = sas_address;\n\tsas_expander->port = mpt3sas_get_port_by_id(ioc, port_id, 0);\n\tif (!sas_expander->port) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\trc = -1;\n\t\tgoto out_fail;\n\t}\n\n\tioc_info(ioc, \"expander_add: handle(0x%04x), parent(0x%04x), sas_addr(0x%016llx), phys(%d)\\n\",\n\t\t handle, parent_handle,\n\t\t (u64)sas_expander->sas_address, sas_expander->num_phys);\n\n\tif (!sas_expander->num_phys) {\n\t\trc = -1;\n\t\tgoto out_fail;\n\t}\n\tsas_expander->phy = kcalloc(sas_expander->num_phys,\n\t    sizeof(struct _sas_phy), GFP_KERNEL);\n\tif (!sas_expander->phy) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trc = -1;\n\t\tgoto out_fail;\n\t}\n\n\tINIT_LIST_HEAD(&sas_expander->sas_port_list);\n\tmpt3sas_port = mpt3sas_transport_port_add(ioc, handle,\n\t    sas_address_parent, sas_expander->port);\n\tif (!mpt3sas_port) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trc = -1;\n\t\tgoto out_fail;\n\t}\n\tsas_expander->parent_dev = &mpt3sas_port->rphy->dev;\n\tsas_expander->rphy = mpt3sas_port->rphy;\n\n\tfor (i = 0 ; i < sas_expander->num_phys ; i++) {\n\t\tif ((mpt3sas_config_get_expander_pg1(ioc, &mpi_reply,\n\t\t    &expander_pg1, i, handle))) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\trc = -1;\n\t\t\tgoto out_fail;\n\t\t}\n\t\tsas_expander->phy[i].handle = handle;\n\t\tsas_expander->phy[i].phy_id = i;\n\t\tsas_expander->phy[i].port =\n\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0);\n\n\t\tif ((mpt3sas_transport_add_expander_phy(ioc,\n\t\t    &sas_expander->phy[i], expander_pg1,\n\t\t    sas_expander->parent_dev))) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\trc = -1;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tif (sas_expander->enclosure_handle) {\n\t\tenclosure_dev =\n\t\t\tmpt3sas_scsih_enclosure_find_by_handle(ioc,\n\t\t\t\t\t\tsas_expander->enclosure_handle);\n\t\tif (enclosure_dev)\n\t\t\tsas_expander->enclosure_logical_id =\n\t\t\t    le64_to_cpu(enclosure_dev->pg0.EnclosureLogicalID);\n\t}\n\n\t_scsih_expander_node_add(ioc, sas_expander);\n\treturn 0;\n\n out_fail:\n\n\tif (mpt3sas_port)\n\t\tmpt3sas_transport_port_remove(ioc, sas_expander->sas_address,\n\t\t    sas_address_parent, sas_expander->port);\n\tkfree(sas_expander);\n\treturn rc;\n}\n\n \nvoid\nmpt3sas_expander_remove(struct MPT3SAS_ADAPTER *ioc, u64 sas_address,\n\tstruct hba_port *port)\n{\n\tstruct _sas_node *sas_expander;\n\tunsigned long flags;\n\n\tif (ioc->shost_recovery)\n\t\treturn;\n\n\tif (!port)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tsas_expander = mpt3sas_scsih_expander_find_by_sas_address(ioc,\n\t    sas_address, port);\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\tif (sas_expander)\n\t\t_scsih_expander_node_remove(ioc, sas_expander);\n}\n\n \nstatic u8\n_scsih_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)\n{\n\tMPI2DefaultReply_t *mpi_reply;\n\n\tmpi_reply =  mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tif (ioc->scsih_cmds.status == MPT3_CMD_NOT_USED)\n\t\treturn 1;\n\tif (ioc->scsih_cmds.smid != smid)\n\t\treturn 1;\n\tioc->scsih_cmds.status |= MPT3_CMD_COMPLETE;\n\tif (mpi_reply) {\n\t\tmemcpy(ioc->scsih_cmds.reply, mpi_reply,\n\t\t    mpi_reply->MsgLength*4);\n\t\tioc->scsih_cmds.status |= MPT3_CMD_REPLY_VALID;\n\t}\n\tioc->scsih_cmds.status &= ~MPT3_CMD_PENDING;\n\tcomplete(&ioc->scsih_cmds.done);\n\treturn 1;\n}\n\n\n\n\n#define MPT3_MAX_LUNS (255)\n\n\n \nstatic u8\n_scsih_check_access_status(struct MPT3SAS_ADAPTER *ioc, u64 sas_address,\n\tu16 handle, u8 access_status)\n{\n\tu8 rc = 1;\n\tchar *desc = NULL;\n\n\tswitch (access_status) {\n\tcase MPI2_SAS_DEVICE0_ASTATUS_NO_ERRORS:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SATA_NEEDS_INITIALIZATION:\n\t\trc = 0;\n\t\tbreak;\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SATA_CAPABILITY_FAILED:\n\t\tdesc = \"sata capability failed\";\n\t\tbreak;\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SATA_AFFILIATION_CONFLICT:\n\t\tdesc = \"sata affiliation conflict\";\n\t\tbreak;\n\tcase MPI2_SAS_DEVICE0_ASTATUS_ROUTE_NOT_ADDRESSABLE:\n\t\tdesc = \"route not addressable\";\n\t\tbreak;\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SMP_ERROR_NOT_ADDRESSABLE:\n\t\tdesc = \"smp error not addressable\";\n\t\tbreak;\n\tcase MPI2_SAS_DEVICE0_ASTATUS_DEVICE_BLOCKED:\n\t\tdesc = \"device blocked\";\n\t\tbreak;\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SATA_INIT_FAILED:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_UNKNOWN:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_AFFILIATION_CONFLICT:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_DIAG:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_IDENTIFICATION:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_CHECK_POWER:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_PIO_SN:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_MDMA_SN:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_UDMA_SN:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_ZONING_VIOLATION:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_NOT_ADDRESSABLE:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_MAX:\n\t\tdesc = \"sata initialization failed\";\n\t\tbreak;\n\tdefault:\n\t\tdesc = \"unknown\";\n\t\tbreak;\n\t}\n\n\tif (!rc)\n\t\treturn 0;\n\n\tioc_err(ioc, \"discovery errors(%s): sas_address(0x%016llx), handle(0x%04x)\\n\",\n\t\tdesc, (u64)sas_address, handle);\n\treturn rc;\n}\n\n \nstatic void\n_scsih_check_device(struct MPT3SAS_ADAPTER *ioc,\n\tu64 parent_sas_address, u16 handle, u8 phy_number, u8 link_rate)\n{\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tstruct _sas_device *sas_device = NULL;\n\tstruct _enclosure_node *enclosure_dev = NULL;\n\tu32 ioc_status;\n\tunsigned long flags;\n\tu64 sas_address;\n\tstruct scsi_target *starget;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tu32 device_info;\n\tstruct hba_port *port;\n\n\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\n\t    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle)))\n\t\treturn;\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\treturn;\n\n\t \n\tif (phy_number != sas_device_pg0.PhyNum)\n\t\treturn;\n\n\t \n\tdevice_info = le32_to_cpu(sas_device_pg0.DeviceInfo);\n\tif (!(_scsih_is_end_device(device_info)))\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_address = le64_to_cpu(sas_device_pg0.SASAddress);\n\tport = mpt3sas_get_port_by_id(ioc, sas_device_pg0.PhysicalPort, 0);\n\tif (!port)\n\t\tgoto out_unlock;\n\tsas_device = __mpt3sas_get_sdev_by_addr(ioc,\n\t    sas_address, port);\n\n\tif (!sas_device)\n\t\tgoto out_unlock;\n\n\tif (unlikely(sas_device->handle != handle)) {\n\t\tstarget = sas_device->starget;\n\t\tsas_target_priv_data = starget->hostdata;\n\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\"handle changed from(0x%04x) to (0x%04x)!!!\\n\",\n\t\t\tsas_device->handle, handle);\n\t\tsas_target_priv_data->handle = handle;\n\t\tsas_device->handle = handle;\n\t\tif (le16_to_cpu(sas_device_pg0.Flags) &\n\t\t     MPI2_SAS_DEVICE0_FLAGS_ENCL_LEVEL_VALID) {\n\t\t\tsas_device->enclosure_level =\n\t\t\t\tsas_device_pg0.EnclosureLevel;\n\t\t\tmemcpy(sas_device->connector_name,\n\t\t\t\tsas_device_pg0.ConnectorName, 4);\n\t\t\tsas_device->connector_name[4] = '\\0';\n\t\t} else {\n\t\t\tsas_device->enclosure_level = 0;\n\t\t\tsas_device->connector_name[0] = '\\0';\n\t\t}\n\n\t\tsas_device->enclosure_handle =\n\t\t\t\tle16_to_cpu(sas_device_pg0.EnclosureHandle);\n\t\tsas_device->is_chassis_slot_valid = 0;\n\t\tenclosure_dev = mpt3sas_scsih_enclosure_find_by_handle(ioc,\n\t\t\t\t\t\tsas_device->enclosure_handle);\n\t\tif (enclosure_dev) {\n\t\t\tsas_device->enclosure_logical_id =\n\t\t\t    le64_to_cpu(enclosure_dev->pg0.EnclosureLogicalID);\n\t\t\tif (le16_to_cpu(enclosure_dev->pg0.Flags) &\n\t\t\t    MPI2_SAS_ENCLS0_FLAGS_CHASSIS_SLOT_VALID) {\n\t\t\t\tsas_device->is_chassis_slot_valid = 1;\n\t\t\t\tsas_device->chassis_slot =\n\t\t\t\t\tenclosure_dev->pg0.ChassisSlot;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!(le16_to_cpu(sas_device_pg0.Flags) &\n\t    MPI2_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)) {\n\t\tioc_err(ioc, \"device is not present handle(0x%04x), flags!!!\\n\",\n\t\t\thandle);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (_scsih_check_access_status(ioc, sas_address, handle,\n\t    sas_device_pg0.AccessStatus))\n\t\tgoto out_unlock;\n\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\t_scsih_ublock_io_device(ioc, sas_address, port);\n\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n\treturn;\n\nout_unlock:\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n}\n\n \nstatic int\n_scsih_add_device(struct MPT3SAS_ADAPTER *ioc, u16 handle, u8 phy_num,\n\tu8 is_pd)\n{\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tstruct _sas_device *sas_device;\n\tstruct _enclosure_node *enclosure_dev = NULL;\n\tu32 ioc_status;\n\tu64 sas_address;\n\tu32 device_info;\n\tu8 port_id;\n\n\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\n\t    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\t \n\tdevice_info = le32_to_cpu(sas_device_pg0.DeviceInfo);\n\tif (!(_scsih_is_end_device(device_info)))\n\t\treturn -1;\n\tset_bit(handle, ioc->pend_os_device_add);\n\tsas_address = le64_to_cpu(sas_device_pg0.SASAddress);\n\n\t \n\tif (!(le16_to_cpu(sas_device_pg0.Flags) &\n\t    MPI2_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)) {\n\t\tioc_err(ioc, \"device is not present handle(0x04%x)!!!\\n\",\n\t\t\thandle);\n\t\treturn -1;\n\t}\n\n\t \n\tif (_scsih_check_access_status(ioc, sas_address, handle,\n\t    sas_device_pg0.AccessStatus))\n\t\treturn -1;\n\n\tport_id = sas_device_pg0.PhysicalPort;\n\tsas_device = mpt3sas_get_sdev_by_addr(ioc,\n\t    sas_address, mpt3sas_get_port_by_id(ioc, port_id, 0));\n\tif (sas_device) {\n\t\tclear_bit(handle, ioc->pend_os_device_add);\n\t\tsas_device_put(sas_device);\n\t\treturn -1;\n\t}\n\n\tif (sas_device_pg0.EnclosureHandle) {\n\t\tenclosure_dev =\n\t\t\tmpt3sas_scsih_enclosure_find_by_handle(ioc,\n\t\t\t    le16_to_cpu(sas_device_pg0.EnclosureHandle));\n\t\tif (enclosure_dev == NULL)\n\t\t\tioc_info(ioc, \"Enclosure handle(0x%04x) doesn't match with enclosure device!\\n\",\n\t\t\t\t sas_device_pg0.EnclosureHandle);\n\t}\n\n\tsas_device = kzalloc(sizeof(struct _sas_device),\n\t    GFP_KERNEL);\n\tif (!sas_device) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 0;\n\t}\n\n\tkref_init(&sas_device->refcount);\n\tsas_device->handle = handle;\n\tif (_scsih_get_sas_address(ioc,\n\t    le16_to_cpu(sas_device_pg0.ParentDevHandle),\n\t    &sas_device->sas_address_parent) != 0)\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\tsas_device->enclosure_handle =\n\t    le16_to_cpu(sas_device_pg0.EnclosureHandle);\n\tif (sas_device->enclosure_handle != 0)\n\t\tsas_device->slot =\n\t\t    le16_to_cpu(sas_device_pg0.Slot);\n\tsas_device->device_info = device_info;\n\tsas_device->sas_address = sas_address;\n\tsas_device->phy = sas_device_pg0.PhyNum;\n\tsas_device->fast_path = (le16_to_cpu(sas_device_pg0.Flags) &\n\t    MPI25_SAS_DEVICE0_FLAGS_FAST_PATH_CAPABLE) ? 1 : 0;\n\tsas_device->port = mpt3sas_get_port_by_id(ioc, port_id, 0);\n\tif (!sas_device->port) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(sas_device_pg0.Flags)\n\t\t& MPI2_SAS_DEVICE0_FLAGS_ENCL_LEVEL_VALID) {\n\t\tsas_device->enclosure_level =\n\t\t\tsas_device_pg0.EnclosureLevel;\n\t\tmemcpy(sas_device->connector_name,\n\t\t\tsas_device_pg0.ConnectorName, 4);\n\t\tsas_device->connector_name[4] = '\\0';\n\t} else {\n\t\tsas_device->enclosure_level = 0;\n\t\tsas_device->connector_name[0] = '\\0';\n\t}\n\t \n\tsas_device->is_chassis_slot_valid = 0;\n\tif (enclosure_dev) {\n\t\tsas_device->enclosure_logical_id =\n\t\t    le64_to_cpu(enclosure_dev->pg0.EnclosureLogicalID);\n\t\tif (le16_to_cpu(enclosure_dev->pg0.Flags) &\n\t\t    MPI2_SAS_ENCLS0_FLAGS_CHASSIS_SLOT_VALID) {\n\t\t\tsas_device->is_chassis_slot_valid = 1;\n\t\t\tsas_device->chassis_slot =\n\t\t\t\t\tenclosure_dev->pg0.ChassisSlot;\n\t\t}\n\t}\n\n\t \n\tsas_device->device_name = le64_to_cpu(sas_device_pg0.DeviceName);\n\tsas_device->port_type = sas_device_pg0.MaxPortConnections;\n\tioc_info(ioc,\n\t    \"handle(0x%0x) sas_address(0x%016llx) port_type(0x%0x)\\n\",\n\t    handle, sas_device->sas_address, sas_device->port_type);\n\n\tif (ioc->wait_for_discovery_to_complete)\n\t\t_scsih_sas_device_init_add(ioc, sas_device);\n\telse\n\t\t_scsih_sas_device_add(ioc, sas_device);\n\nout:\n\tsas_device_put(sas_device);\n\treturn 0;\n}\n\n \nstatic void\n_scsih_remove_device(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_device *sas_device)\n{\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\n\tif ((ioc->pdev->subsystem_vendor == PCI_VENDOR_ID_IBM) &&\n\t     (sas_device->pfa_led_on)) {\n\t\t_scsih_turn_off_pfa_led(ioc, sas_device);\n\t\tsas_device->pfa_led_on = 0;\n\t}\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: enter: handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t    __func__,\n\t\t\t    sas_device->handle, (u64)sas_device->sas_address));\n\n\tdewtprintk(ioc, _scsih_display_enclosure_chassis_info(ioc, sas_device,\n\t    NULL, NULL));\n\n\tif (sas_device->starget && sas_device->starget->hostdata) {\n\t\tsas_target_priv_data = sas_device->starget->hostdata;\n\t\tsas_target_priv_data->deleted = 1;\n\t\t_scsih_ublock_io_device(ioc, sas_device->sas_address,\n\t\t    sas_device->port);\n\t\tsas_target_priv_data->handle =\n\t\t     MPT3SAS_INVALID_DEVICE_HANDLE;\n\t}\n\n\tif (!ioc->hide_drives)\n\t\tmpt3sas_transport_port_remove(ioc,\n\t\t    sas_device->sas_address,\n\t\t    sas_device->sas_address_parent,\n\t\t    sas_device->port);\n\n\tioc_info(ioc, \"removing handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t sas_device->handle, (u64)sas_device->sas_address);\n\n\t_scsih_display_enclosure_chassis_info(ioc, sas_device, NULL, NULL);\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: exit: handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t    __func__,\n\t\t\t    sas_device->handle, (u64)sas_device->sas_address));\n\tdewtprintk(ioc, _scsih_display_enclosure_chassis_info(ioc, sas_device,\n\t    NULL, NULL));\n}\n\n \nstatic void\n_scsih_sas_topology_change_event_debug(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataSasTopologyChangeList_t *event_data)\n{\n\tint i;\n\tu16 handle;\n\tu16 reason_code;\n\tu8 phy_number;\n\tchar *status_str = NULL;\n\tu8 link_rate, prev_link_rate;\n\n\tswitch (event_data->ExpStatus) {\n\tcase MPI2_EVENT_SAS_TOPO_ES_ADDED:\n\t\tstatus_str = \"add\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_TOPO_ES_NOT_RESPONDING:\n\t\tstatus_str = \"remove\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_TOPO_ES_RESPONDING:\n\tcase 0:\n\t\tstatus_str =  \"responding\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_TOPO_ES_DELAY_NOT_RESPONDING:\n\t\tstatus_str = \"remove delay\";\n\t\tbreak;\n\tdefault:\n\t\tstatus_str = \"unknown status\";\n\t\tbreak;\n\t}\n\tioc_info(ioc, \"sas topology change: (%s)\\n\", status_str);\n\tpr_info(\"\\thandle(0x%04x), enclosure_handle(0x%04x) \" \\\n\t    \"start_phy(%02d), count(%d)\\n\",\n\t    le16_to_cpu(event_data->ExpanderDevHandle),\n\t    le16_to_cpu(event_data->EnclosureHandle),\n\t    event_data->StartPhyNum, event_data->NumEntries);\n\tfor (i = 0; i < event_data->NumEntries; i++) {\n\t\thandle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\tphy_number = event_data->StartPhyNum + i;\n\t\treason_code = event_data->PHY[i].PhyStatus &\n\t\t    MPI2_EVENT_SAS_TOPO_RC_MASK;\n\t\tswitch (reason_code) {\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED:\n\t\t\tstatus_str = \"target add\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING:\n\t\t\tstatus_str = \"target remove\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_DELAY_NOT_RESPONDING:\n\t\t\tstatus_str = \"delay target remove\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_PHY_CHANGED:\n\t\t\tstatus_str = \"link rate change\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_NO_CHANGE:\n\t\t\tstatus_str = \"target responding\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus_str = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t\tlink_rate = event_data->PHY[i].LinkRate >> 4;\n\t\tprev_link_rate = event_data->PHY[i].LinkRate & 0xF;\n\t\tpr_info(\"\\tphy(%02d), attached_handle(0x%04x): %s:\" \\\n\t\t    \" link rate: new(0x%02x), old(0x%02x)\\n\", phy_number,\n\t\t    handle, status_str, link_rate, prev_link_rate);\n\n\t}\n}\n\n \nstatic int\n_scsih_sas_topology_change_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tint i;\n\tu16 parent_handle, handle;\n\tu16 reason_code;\n\tu8 phy_number, max_phys;\n\tstruct _sas_node *sas_expander;\n\tu64 sas_address;\n\tunsigned long flags;\n\tu8 link_rate, prev_link_rate;\n\tstruct hba_port *port;\n\tMpi2EventDataSasTopologyChangeList_t *event_data =\n\t\t(Mpi2EventDataSasTopologyChangeList_t *)\n\t\tfw_event->event_data;\n\n\tif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\n\t\t_scsih_sas_topology_change_event_debug(ioc, event_data);\n\n\tif (ioc->shost_recovery || ioc->remove_host || ioc->pci_error_recovery)\n\t\treturn 0;\n\n\tif (!ioc->sas_hba.num_phys)\n\t\t_scsih_sas_host_add(ioc);\n\telse\n\t\t_scsih_sas_host_refresh(ioc);\n\n\tif (fw_event->ignore) {\n\t\tdewtprintk(ioc, ioc_info(ioc, \"ignoring expander event\\n\"));\n\t\treturn 0;\n\t}\n\n\tparent_handle = le16_to_cpu(event_data->ExpanderDevHandle);\n\tport = mpt3sas_get_port_by_id(ioc, event_data->PhysicalPort, 0);\n\n\t \n\tif (event_data->ExpStatus == MPI2_EVENT_SAS_TOPO_ES_ADDED)\n\t\tif (_scsih_expander_add(ioc, parent_handle) != 0)\n\t\t\treturn 0;\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tsas_expander = mpt3sas_scsih_expander_find_by_handle(ioc,\n\t    parent_handle);\n\tif (sas_expander) {\n\t\tsas_address = sas_expander->sas_address;\n\t\tmax_phys = sas_expander->num_phys;\n\t\tport = sas_expander->port;\n\t} else if (parent_handle < ioc->sas_hba.num_phys) {\n\t\tsas_address = ioc->sas_hba.sas_address;\n\t\tmax_phys = ioc->sas_hba.num_phys;\n\t} else {\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\n\t \n\tfor (i = 0; i < event_data->NumEntries; i++) {\n\t\tif (fw_event->ignore) {\n\t\t\tdewtprintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"ignoring expander event\\n\"));\n\t\t\treturn 0;\n\t\t}\n\t\tif (ioc->remove_host || ioc->pci_error_recovery)\n\t\t\treturn 0;\n\t\tphy_number = event_data->StartPhyNum + i;\n\t\tif (phy_number >= max_phys)\n\t\t\tcontinue;\n\t\treason_code = event_data->PHY[i].PhyStatus &\n\t\t    MPI2_EVENT_SAS_TOPO_RC_MASK;\n\t\tif ((event_data->PHY[i].PhyStatus &\n\t\t    MPI2_EVENT_SAS_TOPO_PHYSTATUS_VACANT) && (reason_code !=\n\t\t    MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING))\n\t\t\t\tcontinue;\n\t\thandle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\tlink_rate = event_data->PHY[i].LinkRate >> 4;\n\t\tprev_link_rate = event_data->PHY[i].LinkRate & 0xF;\n\t\tswitch (reason_code) {\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_PHY_CHANGED:\n\n\t\t\tif (ioc->shost_recovery)\n\t\t\t\tbreak;\n\n\t\t\tif (link_rate == prev_link_rate)\n\t\t\t\tbreak;\n\n\t\t\tmpt3sas_transport_update_links(ioc, sas_address,\n\t\t\t    handle, phy_number, link_rate, port);\n\n\t\t\tif (link_rate < MPI2_SAS_NEG_LINK_RATE_1_5)\n\t\t\t\tbreak;\n\n\t\t\t_scsih_check_device(ioc, sas_address, handle,\n\t\t\t    phy_number, link_rate);\n\n\t\t\tif (!test_bit(handle, ioc->pend_os_device_add))\n\t\t\t\tbreak;\n\n\t\t\tfallthrough;\n\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED:\n\n\t\t\tif (ioc->shost_recovery)\n\t\t\t\tbreak;\n\n\t\t\tmpt3sas_transport_update_links(ioc, sas_address,\n\t\t\t    handle, phy_number, link_rate, port);\n\n\t\t\t_scsih_add_device(ioc, handle, phy_number, 0);\n\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING:\n\n\t\t\t_scsih_device_remove_by_handle(ioc, handle);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (event_data->ExpStatus == MPI2_EVENT_SAS_TOPO_ES_NOT_RESPONDING &&\n\t    sas_expander)\n\t\tmpt3sas_expander_remove(ioc, sas_address, port);\n\n\treturn 0;\n}\n\n \nstatic void\n_scsih_sas_device_status_change_event_debug(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataSasDeviceStatusChange_t *event_data)\n{\n\tchar *reason_str = NULL;\n\n\tswitch (event_data->ReasonCode) {\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_SMART_DATA:\n\t\treason_str = \"smart data\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_UNSUPPORTED:\n\t\treason_str = \"unsupported device discovered\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET:\n\t\treason_str = \"internal device reset\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_TASK_ABORT_INTERNAL:\n\t\treason_str = \"internal task abort\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_ABORT_TASK_SET_INTERNAL:\n\t\treason_str = \"internal task abort set\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_CLEAR_TASK_SET_INTERNAL:\n\t\treason_str = \"internal clear task set\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_QUERY_TASK_INTERNAL:\n\t\treason_str = \"internal query task\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_SATA_INIT_FAILURE:\n\t\treason_str = \"sata init failure\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_CMP_INTERNAL_DEV_RESET:\n\t\treason_str = \"internal device reset complete\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_CMP_TASK_ABORT_INTERNAL:\n\t\treason_str = \"internal task abort complete\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_ASYNC_NOTIFICATION:\n\t\treason_str = \"internal async notification\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_EXPANDER_REDUCED_FUNCTIONALITY:\n\t\treason_str = \"expander reduced functionality\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_CMP_EXPANDER_REDUCED_FUNCTIONALITY:\n\t\treason_str = \"expander reduced functionality complete\";\n\t\tbreak;\n\tdefault:\n\t\treason_str = \"unknown reason\";\n\t\tbreak;\n\t}\n\tioc_info(ioc, \"device status change: (%s)\\thandle(0x%04x), sas address(0x%016llx), tag(%d)\",\n\t\t reason_str, le16_to_cpu(event_data->DevHandle),\n\t\t (u64)le64_to_cpu(event_data->SASAddress),\n\t\t le16_to_cpu(event_data->TaskTag));\n\tif (event_data->ReasonCode == MPI2_EVENT_SAS_DEV_STAT_RC_SMART_DATA)\n\t\tpr_cont(\", ASC(0x%x), ASCQ(0x%x)\\n\",\n\t\t\tevent_data->ASC, event_data->ASCQ);\n\tpr_cont(\"\\n\");\n}\n\n \nstatic void\n_scsih_sas_device_status_change_event(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataSasDeviceStatusChange_t *event_data)\n{\n\tstruct MPT3SAS_TARGET *target_priv_data;\n\tstruct _sas_device *sas_device;\n\tu64 sas_address;\n\tunsigned long flags;\n\n\t \n\tif ((ioc->facts.HeaderVersion >> 8) < 0xC)\n\t\treturn;\n\n\tif (event_data->ReasonCode !=\n\t    MPI2_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET &&\n\t   event_data->ReasonCode !=\n\t    MPI2_EVENT_SAS_DEV_STAT_RC_CMP_INTERNAL_DEV_RESET)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_address = le64_to_cpu(event_data->SASAddress);\n\tsas_device = __mpt3sas_get_sdev_by_addr(ioc,\n\t    sas_address,\n\t    mpt3sas_get_port_by_id(ioc, event_data->PhysicalPort, 0));\n\n\tif (!sas_device || !sas_device->starget)\n\t\tgoto out;\n\n\ttarget_priv_data = sas_device->starget->hostdata;\n\tif (!target_priv_data)\n\t\tgoto out;\n\n\tif (event_data->ReasonCode ==\n\t    MPI2_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET)\n\t\ttarget_priv_data->tm_busy = 1;\n\telse\n\t\ttarget_priv_data->tm_busy = 0;\n\n\tif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\n\t\tioc_info(ioc,\n\t\t    \"%s tm_busy flag for handle(0x%04x)\\n\",\n\t\t    (target_priv_data->tm_busy == 1) ? \"Enable\" : \"Disable\",\n\t\t    target_priv_data->handle);\n\nout:\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n}\n\n\n \nstatic u8\n_scsih_check_pcie_access_status(struct MPT3SAS_ADAPTER *ioc, u64 wwid,\n\tu16 handle, u8 access_status)\n{\n\tu8 rc = 1;\n\tchar *desc = NULL;\n\n\tswitch (access_status) {\n\tcase MPI26_PCIEDEV0_ASTATUS_NO_ERRORS:\n\tcase MPI26_PCIEDEV0_ASTATUS_NEEDS_INITIALIZATION:\n\t\trc = 0;\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_CAPABILITY_FAILED:\n\t\tdesc = \"PCIe device capability failed\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_DEVICE_BLOCKED:\n\t\tdesc = \"PCIe device blocked\";\n\t\tioc_info(ioc,\n\t\t    \"Device with Access Status (%s): wwid(0x%016llx), \"\n\t\t    \"handle(0x%04x)\\n ll only be added to the internal list\",\n\t\t    desc, (u64)wwid, handle);\n\t\trc = 0;\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_MEMORY_SPACE_ACCESS_FAILED:\n\t\tdesc = \"PCIe device mem space access failed\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_UNSUPPORTED_DEVICE:\n\t\tdesc = \"PCIe device unsupported\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_MSIX_REQUIRED:\n\t\tdesc = \"PCIe device MSIx Required\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_INIT_FAIL_MAX:\n\t\tdesc = \"PCIe device init fail max\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_UNKNOWN:\n\t\tdesc = \"PCIe device status unknown\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_READY_TIMEOUT:\n\t\tdesc = \"nvme ready timeout\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_DEVCFG_UNSUPPORTED:\n\t\tdesc = \"nvme device configuration unsupported\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_IDENTIFY_FAILED:\n\t\tdesc = \"nvme identify failed\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_QCONFIG_FAILED:\n\t\tdesc = \"nvme qconfig failed\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_QCREATION_FAILED:\n\t\tdesc = \"nvme qcreation failed\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_EVENTCFG_FAILED:\n\t\tdesc = \"nvme eventcfg failed\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_GET_FEATURE_STAT_FAILED:\n\t\tdesc = \"nvme get feature stat failed\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_IDLE_TIMEOUT:\n\t\tdesc = \"nvme idle timeout\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_FAILURE_STATUS:\n\t\tdesc = \"nvme failure status\";\n\t\tbreak;\n\tdefault:\n\t\tioc_err(ioc, \"NVMe discovery error(0x%02x): wwid(0x%016llx), handle(0x%04x)\\n\",\n\t\t\taccess_status, (u64)wwid, handle);\n\t\treturn rc;\n\t}\n\n\tif (!rc)\n\t\treturn rc;\n\n\tioc_info(ioc, \"NVMe discovery error(%s): wwid(0x%016llx), handle(0x%04x)\\n\",\n\t\t desc, (u64)wwid, handle);\n\treturn rc;\n}\n\n \nstatic void\n_scsih_pcie_device_remove_from_sml(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _pcie_device *pcie_device)\n{\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: enter: handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t    __func__,\n\t\t\t    pcie_device->handle, (u64)pcie_device->wwid));\n\tif (pcie_device->enclosure_handle != 0)\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enter: enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t    __func__,\n\t\t\t\t    (u64)pcie_device->enclosure_logical_id,\n\t\t\t\t    pcie_device->slot));\n\tif (pcie_device->connector_name[0] != '\\0')\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enter: enclosure level(0x%04x), connector name(%s)\\n\",\n\t\t\t\t    __func__,\n\t\t\t\t    pcie_device->enclosure_level,\n\t\t\t\t    pcie_device->connector_name));\n\n\tif (pcie_device->starget && pcie_device->starget->hostdata) {\n\t\tsas_target_priv_data = pcie_device->starget->hostdata;\n\t\tsas_target_priv_data->deleted = 1;\n\t\t_scsih_ublock_io_device(ioc, pcie_device->wwid, NULL);\n\t\tsas_target_priv_data->handle = MPT3SAS_INVALID_DEVICE_HANDLE;\n\t}\n\n\tioc_info(ioc, \"removing handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t pcie_device->handle, (u64)pcie_device->wwid);\n\tif (pcie_device->enclosure_handle != 0)\n\t\tioc_info(ioc, \"removing : enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t (u64)pcie_device->enclosure_logical_id,\n\t\t\t pcie_device->slot);\n\tif (pcie_device->connector_name[0] != '\\0')\n\t\tioc_info(ioc, \"removing: enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t pcie_device->enclosure_level,\n\t\t\t pcie_device->connector_name);\n\n\tif (pcie_device->starget && (pcie_device->access_status !=\n\t\t\t\tMPI26_PCIEDEV0_ASTATUS_DEVICE_BLOCKED))\n\t\tscsi_remove_target(&pcie_device->starget->dev);\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: exit: handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t    __func__,\n\t\t\t    pcie_device->handle, (u64)pcie_device->wwid));\n\tif (pcie_device->enclosure_handle != 0)\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: exit: enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t    __func__,\n\t\t\t\t    (u64)pcie_device->enclosure_logical_id,\n\t\t\t\t    pcie_device->slot));\n\tif (pcie_device->connector_name[0] != '\\0')\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: exit: enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t    __func__,\n\t\t\t\t    pcie_device->enclosure_level,\n\t\t\t\t    pcie_device->connector_name));\n\n\tkfree(pcie_device->serial_number);\n}\n\n\n \nstatic void\n_scsih_pcie_check_device(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi26PCIeDevicePage0_t pcie_device_pg0;\n\tu32 ioc_status;\n\tstruct _pcie_device *pcie_device;\n\tu64 wwid;\n\tunsigned long flags;\n\tstruct scsi_target *starget;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tu32 device_info;\n\n\tif ((mpt3sas_config_get_pcie_device_pg0(ioc, &mpi_reply,\n\t\t&pcie_device_pg0, MPI26_PCIE_DEVICE_PGAD_FORM_HANDLE, handle)))\n\t\treturn;\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\treturn;\n\n\t \n\tdevice_info = le32_to_cpu(pcie_device_pg0.DeviceInfo);\n\tif (!(_scsih_is_nvme_pciescsi_device(device_info)))\n\t\treturn;\n\n\twwid = le64_to_cpu(pcie_device_pg0.WWID);\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tpcie_device = __mpt3sas_get_pdev_by_wwid(ioc, wwid);\n\n\tif (!pcie_device) {\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\treturn;\n\t}\n\n\tif (unlikely(pcie_device->handle != handle)) {\n\t\tstarget = pcie_device->starget;\n\t\tsas_target_priv_data = starget->hostdata;\n\t\tpcie_device->access_status = pcie_device_pg0.AccessStatus;\n\t\tstarget_printk(KERN_INFO, starget,\n\t\t    \"handle changed from(0x%04x) to (0x%04x)!!!\\n\",\n\t\t    pcie_device->handle, handle);\n\t\tsas_target_priv_data->handle = handle;\n\t\tpcie_device->handle = handle;\n\n\t\tif (le32_to_cpu(pcie_device_pg0.Flags) &\n\t\t    MPI26_PCIEDEV0_FLAGS_ENCL_LEVEL_VALID) {\n\t\t\tpcie_device->enclosure_level =\n\t\t\t    pcie_device_pg0.EnclosureLevel;\n\t\t\tmemcpy(&pcie_device->connector_name[0],\n\t\t\t    &pcie_device_pg0.ConnectorName[0], 4);\n\t\t} else {\n\t\t\tpcie_device->enclosure_level = 0;\n\t\t\tpcie_device->connector_name[0] = '\\0';\n\t\t}\n\t}\n\n\t \n\tif (!(le32_to_cpu(pcie_device_pg0.Flags) &\n\t    MPI26_PCIEDEV0_FLAGS_DEVICE_PRESENT)) {\n\t\tioc_info(ioc, \"device is not present handle(0x%04x), flags!!!\\n\",\n\t\t\t handle);\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\tpcie_device_put(pcie_device);\n\t\treturn;\n\t}\n\n\t \n\tif (_scsih_check_pcie_access_status(ioc, wwid, handle,\n\t    pcie_device_pg0.AccessStatus)) {\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\tpcie_device_put(pcie_device);\n\t\treturn;\n\t}\n\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\tpcie_device_put(pcie_device);\n\n\t_scsih_ublock_io_device(ioc, wwid, NULL);\n\n\treturn;\n}\n\n \nstatic int\n_scsih_pcie_add_device(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tMpi26PCIeDevicePage0_t pcie_device_pg0;\n\tMpi26PCIeDevicePage2_t pcie_device_pg2;\n\tMpi2ConfigReply_t mpi_reply;\n\tstruct _pcie_device *pcie_device;\n\tstruct _enclosure_node *enclosure_dev;\n\tu32 ioc_status;\n\tu64 wwid;\n\n\tif ((mpt3sas_config_get_pcie_device_pg0(ioc, &mpi_reply,\n\t    &pcie_device_pg0, MPI26_PCIE_DEVICE_PGAD_FORM_HANDLE, handle))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 0;\n\t}\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 0;\n\t}\n\n\tset_bit(handle, ioc->pend_os_device_add);\n\twwid = le64_to_cpu(pcie_device_pg0.WWID);\n\n\t \n\tif (!(le32_to_cpu(pcie_device_pg0.Flags) &\n\t\tMPI26_PCIEDEV0_FLAGS_DEVICE_PRESENT)) {\n\t\tioc_err(ioc, \"device is not present handle(0x04%x)!!!\\n\",\n\t\t\thandle);\n\t\treturn 0;\n\t}\n\n\t \n\tif (_scsih_check_pcie_access_status(ioc, wwid, handle,\n\t    pcie_device_pg0.AccessStatus))\n\t\treturn 0;\n\n\tif (!(_scsih_is_nvme_pciescsi_device(le32_to_cpu\n\t    (pcie_device_pg0.DeviceInfo))))\n\t\treturn 0;\n\n\tpcie_device = mpt3sas_get_pdev_by_wwid(ioc, wwid);\n\tif (pcie_device) {\n\t\tclear_bit(handle, ioc->pend_os_device_add);\n\t\tpcie_device_put(pcie_device);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!(mpt3sas_scsih_is_pcie_scsi_device(\n\t\tle32_to_cpu(pcie_device_pg0.DeviceInfo)))) {\n\t\tif (mpt3sas_config_get_pcie_device_pg2(ioc, &mpi_reply,\n\t\t    &pcie_device_pg2, MPI2_SAS_DEVICE_PGAD_FORM_HANDLE,\n\t\t    handle)) {\n\t\t\tioc_err(ioc,\n\t\t\t    \"failure at %s:%d/%s()!\\n\", __FILE__,\n\t\t\t    __LINE__, __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t\t\t\tMPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_err(ioc,\n\t\t\t    \"failure at %s:%d/%s()!\\n\", __FILE__,\n\t\t\t    __LINE__, __func__);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpcie_device = kzalloc(sizeof(struct _pcie_device), GFP_KERNEL);\n\tif (!pcie_device) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 0;\n\t}\n\n\tkref_init(&pcie_device->refcount);\n\tpcie_device->id = ioc->pcie_target_id++;\n\tpcie_device->channel = PCIE_CHANNEL;\n\tpcie_device->handle = handle;\n\tpcie_device->access_status = pcie_device_pg0.AccessStatus;\n\tpcie_device->device_info = le32_to_cpu(pcie_device_pg0.DeviceInfo);\n\tpcie_device->wwid = wwid;\n\tpcie_device->port_num = pcie_device_pg0.PortNum;\n\tpcie_device->fast_path = (le32_to_cpu(pcie_device_pg0.Flags) &\n\t    MPI26_PCIEDEV0_FLAGS_FAST_PATH_CAPABLE) ? 1 : 0;\n\n\tpcie_device->enclosure_handle =\n\t    le16_to_cpu(pcie_device_pg0.EnclosureHandle);\n\tif (pcie_device->enclosure_handle != 0)\n\t\tpcie_device->slot = le16_to_cpu(pcie_device_pg0.Slot);\n\n\tif (le32_to_cpu(pcie_device_pg0.Flags) &\n\t    MPI26_PCIEDEV0_FLAGS_ENCL_LEVEL_VALID) {\n\t\tpcie_device->enclosure_level = pcie_device_pg0.EnclosureLevel;\n\t\tmemcpy(&pcie_device->connector_name[0],\n\t\t    &pcie_device_pg0.ConnectorName[0], 4);\n\t} else {\n\t\tpcie_device->enclosure_level = 0;\n\t\tpcie_device->connector_name[0] = '\\0';\n\t}\n\n\t \n\tif (pcie_device->enclosure_handle) {\n\t\tenclosure_dev =\n\t\t\tmpt3sas_scsih_enclosure_find_by_handle(ioc,\n\t\t\t\t\t\tpcie_device->enclosure_handle);\n\t\tif (enclosure_dev)\n\t\t\tpcie_device->enclosure_logical_id =\n\t\t\t    le64_to_cpu(enclosure_dev->pg0.EnclosureLogicalID);\n\t}\n\t \n\tif (!(mpt3sas_scsih_is_pcie_scsi_device(\n\t    le32_to_cpu(pcie_device_pg0.DeviceInfo)))) {\n\t\tpcie_device->nvme_mdts =\n\t\t    le32_to_cpu(pcie_device_pg2.MaximumDataTransferSize);\n\t\tpcie_device->shutdown_latency =\n\t\t\tle16_to_cpu(pcie_device_pg2.ShutdownLatency);\n\t\t \n\t\tif (pcie_device->shutdown_latency > ioc->max_shutdown_latency)\n\t\t\tioc->max_shutdown_latency =\n\t\t\t\tpcie_device->shutdown_latency;\n\t\tif (pcie_device_pg2.ControllerResetTO)\n\t\t\tpcie_device->reset_timeout =\n\t\t\t    pcie_device_pg2.ControllerResetTO;\n\t\telse\n\t\t\tpcie_device->reset_timeout = 30;\n\t} else\n\t\tpcie_device->reset_timeout = 30;\n\n\tif (ioc->wait_for_discovery_to_complete)\n\t\t_scsih_pcie_device_init_add(ioc, pcie_device);\n\telse\n\t\t_scsih_pcie_device_add(ioc, pcie_device);\n\n\tpcie_device_put(pcie_device);\n\treturn 0;\n}\n\n \nstatic void\n_scsih_pcie_topology_change_event_debug(struct MPT3SAS_ADAPTER *ioc,\n\tMpi26EventDataPCIeTopologyChangeList_t *event_data)\n{\n\tint i;\n\tu16 handle;\n\tu16 reason_code;\n\tu8 port_number;\n\tchar *status_str = NULL;\n\tu8 link_rate, prev_link_rate;\n\n\tswitch (event_data->SwitchStatus) {\n\tcase MPI26_EVENT_PCIE_TOPO_SS_ADDED:\n\t\tstatus_str = \"add\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIE_TOPO_SS_NOT_RESPONDING:\n\t\tstatus_str = \"remove\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIE_TOPO_SS_RESPONDING:\n\tcase 0:\n\t\tstatus_str =  \"responding\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIE_TOPO_SS_DELAY_NOT_RESPONDING:\n\t\tstatus_str = \"remove delay\";\n\t\tbreak;\n\tdefault:\n\t\tstatus_str = \"unknown status\";\n\t\tbreak;\n\t}\n\tioc_info(ioc, \"pcie topology change: (%s)\\n\", status_str);\n\tpr_info(\"\\tswitch_handle(0x%04x), enclosure_handle(0x%04x)\"\n\t\t\"start_port(%02d), count(%d)\\n\",\n\t\tle16_to_cpu(event_data->SwitchDevHandle),\n\t\tle16_to_cpu(event_data->EnclosureHandle),\n\t\tevent_data->StartPortNum, event_data->NumEntries);\n\tfor (i = 0; i < event_data->NumEntries; i++) {\n\t\thandle =\n\t\t\tle16_to_cpu(event_data->PortEntry[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\tport_number = event_data->StartPortNum + i;\n\t\treason_code = event_data->PortEntry[i].PortStatus;\n\t\tswitch (reason_code) {\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_DEV_ADDED:\n\t\t\tstatus_str = \"target add\";\n\t\t\tbreak;\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_NOT_RESPONDING:\n\t\t\tstatus_str = \"target remove\";\n\t\t\tbreak;\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_DELAY_NOT_RESPONDING:\n\t\t\tstatus_str = \"delay target remove\";\n\t\t\tbreak;\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_PORT_CHANGED:\n\t\t\tstatus_str = \"link rate change\";\n\t\t\tbreak;\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_NO_CHANGE:\n\t\t\tstatus_str = \"target responding\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus_str = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t\tlink_rate = event_data->PortEntry[i].CurrentPortInfo &\n\t\t\tMPI26_EVENT_PCIE_TOPO_PI_RATE_MASK;\n\t\tprev_link_rate = event_data->PortEntry[i].PreviousPortInfo &\n\t\t\tMPI26_EVENT_PCIE_TOPO_PI_RATE_MASK;\n\t\tpr_info(\"\\tport(%02d), attached_handle(0x%04x): %s:\"\n\t\t\t\" link rate: new(0x%02x), old(0x%02x)\\n\", port_number,\n\t\t\thandle, status_str, link_rate, prev_link_rate);\n\t}\n}\n\n \nstatic void\n_scsih_pcie_topology_change_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tint i;\n\tu16 handle;\n\tu16 reason_code;\n\tu8 link_rate, prev_link_rate;\n\tunsigned long flags;\n\tint rc;\n\tMpi26EventDataPCIeTopologyChangeList_t *event_data =\n\t\t(Mpi26EventDataPCIeTopologyChangeList_t *) fw_event->event_data;\n\tstruct _pcie_device *pcie_device;\n\n\tif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\n\t\t_scsih_pcie_topology_change_event_debug(ioc, event_data);\n\n\tif (ioc->shost_recovery || ioc->remove_host ||\n\t\tioc->pci_error_recovery)\n\t\treturn;\n\n\tif (fw_event->ignore) {\n\t\tdewtprintk(ioc, ioc_info(ioc, \"ignoring switch event\\n\"));\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < event_data->NumEntries; i++) {\n\t\tif (fw_event->ignore) {\n\t\t\tdewtprintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"ignoring switch event\\n\"));\n\t\t\treturn;\n\t\t}\n\t\tif (ioc->remove_host || ioc->pci_error_recovery)\n\t\t\treturn;\n\t\treason_code = event_data->PortEntry[i].PortStatus;\n\t\thandle =\n\t\t\tle16_to_cpu(event_data->PortEntry[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\n\t\tlink_rate = event_data->PortEntry[i].CurrentPortInfo\n\t\t\t& MPI26_EVENT_PCIE_TOPO_PI_RATE_MASK;\n\t\tprev_link_rate = event_data->PortEntry[i].PreviousPortInfo\n\t\t\t& MPI26_EVENT_PCIE_TOPO_PI_RATE_MASK;\n\n\t\tswitch (reason_code) {\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_PORT_CHANGED:\n\t\t\tif (ioc->shost_recovery)\n\t\t\t\tbreak;\n\t\t\tif (link_rate == prev_link_rate)\n\t\t\t\tbreak;\n\t\t\tif (link_rate < MPI26_EVENT_PCIE_TOPO_PI_RATE_2_5)\n\t\t\t\tbreak;\n\n\t\t\t_scsih_pcie_check_device(ioc, handle);\n\n\t\t\t \n\t\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\t\tpcie_device = __mpt3sas_get_pdev_by_handle(ioc, handle);\n\t\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\t\t\tif (pcie_device) {\n\t\t\t\tpcie_device_put(pcie_device);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!test_bit(handle, ioc->pend_os_device_add))\n\t\t\t\tbreak;\n\n\t\t\tdewtprintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"handle(0x%04x) device not found: convert event to a device add\\n\",\n\t\t\t\t\t    handle));\n\t\t\tevent_data->PortEntry[i].PortStatus &= 0xF0;\n\t\t\tevent_data->PortEntry[i].PortStatus |=\n\t\t\t\tMPI26_EVENT_PCIE_TOPO_PS_DEV_ADDED;\n\t\t\tfallthrough;\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_DEV_ADDED:\n\t\t\tif (ioc->shost_recovery)\n\t\t\t\tbreak;\n\t\t\tif (link_rate < MPI26_EVENT_PCIE_TOPO_PI_RATE_2_5)\n\t\t\t\tbreak;\n\n\t\t\trc = _scsih_pcie_add_device(ioc, handle);\n\t\t\tif (!rc) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tevent_data->PortEntry[i].PortStatus |=\n\t\t\t\t\tMPI26_EVENT_PCIE_TOPO_PS_NO_CHANGE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_NOT_RESPONDING:\n\t\t\t_scsih_pcie_device_remove_by_handle(ioc, handle);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void\n_scsih_pcie_device_status_change_event_debug(struct MPT3SAS_ADAPTER *ioc,\n\tMpi26EventDataPCIeDeviceStatusChange_t *event_data)\n{\n\tchar *reason_str = NULL;\n\n\tswitch (event_data->ReasonCode) {\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_SMART_DATA:\n\t\treason_str = \"smart data\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_UNSUPPORTED:\n\t\treason_str = \"unsupported device discovered\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_INTERNAL_DEVICE_RESET:\n\t\treason_str = \"internal device reset\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_TASK_ABORT_INTERNAL:\n\t\treason_str = \"internal task abort\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_ABORT_TASK_SET_INTERNAL:\n\t\treason_str = \"internal task abort set\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_CLEAR_TASK_SET_INTERNAL:\n\t\treason_str = \"internal clear task set\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_QUERY_TASK_INTERNAL:\n\t\treason_str = \"internal query task\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_DEV_INIT_FAILURE:\n\t\treason_str = \"device init failure\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_CMP_INTERNAL_DEV_RESET:\n\t\treason_str = \"internal device reset complete\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_CMP_TASK_ABORT_INTERNAL:\n\t\treason_str = \"internal task abort complete\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_ASYNC_NOTIFICATION:\n\t\treason_str = \"internal async notification\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_PCIE_HOT_RESET_FAILED:\n\t\treason_str = \"pcie hot reset failed\";\n\t\tbreak;\n\tdefault:\n\t\treason_str = \"unknown reason\";\n\t\tbreak;\n\t}\n\n\tioc_info(ioc, \"PCIE device status change: (%s)\\n\"\n\t\t \"\\thandle(0x%04x), WWID(0x%016llx), tag(%d)\",\n\t\t reason_str, le16_to_cpu(event_data->DevHandle),\n\t\t (u64)le64_to_cpu(event_data->WWID),\n\t\t le16_to_cpu(event_data->TaskTag));\n\tif (event_data->ReasonCode == MPI26_EVENT_PCIDEV_STAT_RC_SMART_DATA)\n\t\tpr_cont(\", ASC(0x%x), ASCQ(0x%x)\\n\",\n\t\t\tevent_data->ASC, event_data->ASCQ);\n\tpr_cont(\"\\n\");\n}\n\n \nstatic void\n_scsih_pcie_device_status_change_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tstruct MPT3SAS_TARGET *target_priv_data;\n\tstruct _pcie_device *pcie_device;\n\tu64 wwid;\n\tunsigned long flags;\n\tMpi26EventDataPCIeDeviceStatusChange_t *event_data =\n\t\t(Mpi26EventDataPCIeDeviceStatusChange_t *)fw_event->event_data;\n\tif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\n\t\t_scsih_pcie_device_status_change_event_debug(ioc,\n\t\t\tevent_data);\n\n\tif (event_data->ReasonCode !=\n\t\tMPI26_EVENT_PCIDEV_STAT_RC_INTERNAL_DEVICE_RESET &&\n\t\tevent_data->ReasonCode !=\n\t\tMPI26_EVENT_PCIDEV_STAT_RC_CMP_INTERNAL_DEV_RESET)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\twwid = le64_to_cpu(event_data->WWID);\n\tpcie_device = __mpt3sas_get_pdev_by_wwid(ioc, wwid);\n\n\tif (!pcie_device || !pcie_device->starget)\n\t\tgoto out;\n\n\ttarget_priv_data = pcie_device->starget->hostdata;\n\tif (!target_priv_data)\n\t\tgoto out;\n\n\tif (event_data->ReasonCode ==\n\t\tMPI26_EVENT_PCIDEV_STAT_RC_INTERNAL_DEVICE_RESET)\n\t\ttarget_priv_data->tm_busy = 1;\n\telse\n\t\ttarget_priv_data->tm_busy = 0;\nout:\n\tif (pcie_device)\n\t\tpcie_device_put(pcie_device);\n\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n}\n\n \nstatic void\n_scsih_sas_enclosure_dev_status_change_event_debug(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataSasEnclDevStatusChange_t *event_data)\n{\n\tchar *reason_str = NULL;\n\n\tswitch (event_data->ReasonCode) {\n\tcase MPI2_EVENT_SAS_ENCL_RC_ADDED:\n\t\treason_str = \"enclosure add\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_ENCL_RC_NOT_RESPONDING:\n\t\treason_str = \"enclosure remove\";\n\t\tbreak;\n\tdefault:\n\t\treason_str = \"unknown reason\";\n\t\tbreak;\n\t}\n\n\tioc_info(ioc, \"enclosure status change: (%s)\\n\"\n\t\t \"\\thandle(0x%04x), enclosure logical id(0x%016llx) number slots(%d)\\n\",\n\t\t reason_str,\n\t\t le16_to_cpu(event_data->EnclosureHandle),\n\t\t (u64)le64_to_cpu(event_data->EnclosureLogicalID),\n\t\t le16_to_cpu(event_data->StartSlot));\n}\n\n \nstatic void\n_scsih_sas_enclosure_dev_status_change_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tMpi2ConfigReply_t mpi_reply;\n\tstruct _enclosure_node *enclosure_dev = NULL;\n\tMpi2EventDataSasEnclDevStatusChange_t *event_data =\n\t\t(Mpi2EventDataSasEnclDevStatusChange_t *)fw_event->event_data;\n\tint rc;\n\tu16 enclosure_handle = le16_to_cpu(event_data->EnclosureHandle);\n\n\tif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\n\t\t_scsih_sas_enclosure_dev_status_change_event_debug(ioc,\n\t\t     (Mpi2EventDataSasEnclDevStatusChange_t *)\n\t\t     fw_event->event_data);\n\tif (ioc->shost_recovery)\n\t\treturn;\n\n\tif (enclosure_handle)\n\t\tenclosure_dev =\n\t\t\tmpt3sas_scsih_enclosure_find_by_handle(ioc,\n\t\t\t\t\t\tenclosure_handle);\n\tswitch (event_data->ReasonCode) {\n\tcase MPI2_EVENT_SAS_ENCL_RC_ADDED:\n\t\tif (!enclosure_dev) {\n\t\t\tenclosure_dev =\n\t\t\t\tkzalloc(sizeof(struct _enclosure_node),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!enclosure_dev) {\n\t\t\t\tioc_info(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t __FILE__, __LINE__, __func__);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trc = mpt3sas_config_get_enclosure_pg0(ioc, &mpi_reply,\n\t\t\t\t&enclosure_dev->pg0,\n\t\t\t\tMPI2_SAS_ENCLOS_PGAD_FORM_HANDLE,\n\t\t\t\tenclosure_handle);\n\n\t\t\tif (rc || (le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t\t\t\t\tMPI2_IOCSTATUS_MASK)) {\n\t\t\t\tkfree(enclosure_dev);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlist_add_tail(&enclosure_dev->list,\n\t\t\t\t\t\t\t&ioc->enclosure_list);\n\t\t}\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_ENCL_RC_NOT_RESPONDING:\n\t\tif (enclosure_dev) {\n\t\t\tlist_del(&enclosure_dev->list);\n\t\t\tkfree(enclosure_dev);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void\n_scsih_sas_broadcast_primitive_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tstruct scsi_cmnd *scmd;\n\tstruct scsi_device *sdev;\n\tstruct scsiio_tracker *st;\n\tu16 smid, handle;\n\tu32 lun;\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tu32 termination_count;\n\tu32 query_count;\n\tMpi2SCSITaskManagementReply_t *mpi_reply;\n\tMpi2EventDataSasBroadcastPrimitive_t *event_data =\n\t\t(Mpi2EventDataSasBroadcastPrimitive_t *)\n\t\tfw_event->event_data;\n\tu16 ioc_status;\n\tunsigned long flags;\n\tint r;\n\tu8 max_retries = 0;\n\tu8 task_abort_retries;\n\n\tmutex_lock(&ioc->tm_cmds.mutex);\n\tioc_info(ioc, \"%s: enter: phy number(%d), width(%d)\\n\",\n\t\t __func__, event_data->PhyNum, event_data->PortWidth);\n\n\t_scsih_block_io_all_device(ioc);\n\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tmpi_reply = ioc->tm_cmds.reply;\n broadcast_aen_retry:\n\n\t \n\tif (max_retries++ == 5) {\n\t\tdewtprintk(ioc, ioc_info(ioc, \"%s: giving up\\n\", __func__));\n\t\tgoto out;\n\t} else if (max_retries > 1)\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: %d retry\\n\",\n\t\t\t\t    __func__, max_retries - 1));\n\n\ttermination_count = 0;\n\tquery_count = 0;\n\tfor (smid = 1; smid <= ioc->scsiio_depth; smid++) {\n\t\tif (ioc->shost_recovery)\n\t\t\tgoto out;\n\t\tscmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);\n\t\tif (!scmd)\n\t\t\tcontinue;\n\t\tst = scsi_cmd_priv(scmd);\n\t\tsdev = scmd->device;\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (!sas_device_priv_data || !sas_device_priv_data->sas_target)\n\t\t\tcontinue;\n\t\t  \n\t\tif (sas_device_priv_data->sas_target->flags &\n\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\t\tcontinue;\n\t\t  \n\t\tif (sas_device_priv_data->sas_target->flags &\n\t\t    MPT_TARGET_FLAGS_VOLUME)\n\t\t\tcontinue;\n\t\t  \n\t\tif (sas_device_priv_data->sas_target->flags &\n\t\t    MPT_TARGET_FLAGS_PCIE_DEVICE)\n\t\t\tcontinue;\n\n\t\thandle = sas_device_priv_data->sas_target->handle;\n\t\tlun = sas_device_priv_data->lun;\n\t\tquery_count++;\n\n\t\tif (ioc->shost_recovery)\n\t\t\tgoto out;\n\n\t\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\t\tr = mpt3sas_scsih_issue_tm(ioc, handle, 0, 0, lun,\n\t\t\tMPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK, st->smid,\n\t\t\tst->msix_io, 30, 0);\n\t\tif (r == FAILED) {\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t    \"mpt3sas_scsih_issue_tm: FAILED when sending \"\n\t\t\t    \"QUERY_TASK: scmd(%p)\\n\", scmd);\n\t\t\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\t\t\tgoto broadcast_aen_retry;\n\t\t}\n\t\tioc_status = le16_to_cpu(mpi_reply->IOCStatus)\n\t\t    & MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t\"query task: FAILED with IOCSTATUS(0x%04x), scmd(%p)\\n\",\n\t\t\t\tioc_status, scmd);\n\t\t\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\t\t\tgoto broadcast_aen_retry;\n\t\t}\n\n\t\t \n\t\tif (mpi_reply->ResponseCode ==\n\t\t     MPI2_SCSITASKMGMT_RSP_TM_SUCCEEDED ||\n\t\t     mpi_reply->ResponseCode ==\n\t\t     MPI2_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC) {\n\t\t\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_abort_retries = 0;\n tm_retry:\n\t\tif (task_abort_retries++ == 60) {\n\t\t\tdewtprintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"%s: ABORT_TASK: giving up\\n\",\n\t\t\t\t\t    __func__));\n\t\t\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\t\t\tgoto broadcast_aen_retry;\n\t\t}\n\n\t\tif (ioc->shost_recovery)\n\t\t\tgoto out_no_lock;\n\n\t\tr = mpt3sas_scsih_issue_tm(ioc, handle, sdev->channel, sdev->id,\n\t\t\tsdev->lun, MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK,\n\t\t\tst->smid, st->msix_io, 30, 0);\n\t\tif (r == FAILED || st->cb_idx != 0xFF) {\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t    \"mpt3sas_scsih_issue_tm: ABORT_TASK: FAILED : \"\n\t\t\t    \"scmd(%p)\\n\", scmd);\n\t\t\tgoto tm_retry;\n\t\t}\n\n\t\tif (task_abort_retries > 1)\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t    \"mpt3sas_scsih_issue_tm: ABORT_TASK: RETRIES (%d):\"\n\t\t\t    \" scmd(%p)\\n\",\n\t\t\t    task_abort_retries - 1, scmd);\n\n\t\ttermination_count += le32_to_cpu(mpi_reply->TerminationCount);\n\t\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\t}\n\n\tif (ioc->broadcast_aen_pending) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc,\n\t\t\t\t    \"%s: loop back due to pending AEN\\n\",\n\t\t\t\t    __func__));\n\t\t ioc->broadcast_aen_pending = 0;\n\t\t goto broadcast_aen_retry;\n\t}\n\n out:\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n out_no_lock:\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s - exit, query_count = %d termination_count = %d\\n\",\n\t\t\t    __func__, query_count, termination_count));\n\n\tioc->broadcast_aen_busy = 0;\n\tif (!ioc->shost_recovery)\n\t\t_scsih_ublock_io_all_device(ioc);\n\tmutex_unlock(&ioc->tm_cmds.mutex);\n}\n\n \nstatic void\n_scsih_sas_discovery_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tMpi2EventDataSasDiscovery_t *event_data =\n\t\t(Mpi2EventDataSasDiscovery_t *) fw_event->event_data;\n\n\tif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK) {\n\t\tioc_info(ioc, \"discovery event: (%s)\",\n\t\t\t event_data->ReasonCode == MPI2_EVENT_SAS_DISC_RC_STARTED ?\n\t\t\t \"start\" : \"stop\");\n\t\tif (event_data->DiscoveryStatus)\n\t\t\tpr_cont(\"discovery_status(0x%08x)\",\n\t\t\t\tle32_to_cpu(event_data->DiscoveryStatus));\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tif (event_data->ReasonCode == MPI2_EVENT_SAS_DISC_RC_STARTED &&\n\t    !ioc->sas_hba.num_phys) {\n\t\tif (disable_discovery > 0 && ioc->shost_recovery) {\n\t\t\t \n\t\t\twhile (ioc->shost_recovery)\n\t\t\t\tssleep(1);\n\t\t}\n\t\t_scsih_sas_host_add(ioc);\n\t}\n}\n\n \nstatic void\n_scsih_sas_device_discovery_error_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tMpi25EventDataSasDeviceDiscoveryError_t *event_data =\n\t\t(Mpi25EventDataSasDeviceDiscoveryError_t *)fw_event->event_data;\n\n\tswitch (event_data->ReasonCode) {\n\tcase MPI25_EVENT_SAS_DISC_ERR_SMP_FAILED:\n\t\tioc_warn(ioc, \"SMP command sent to the expander (handle:0x%04x, sas_address:0x%016llx, physical_port:0x%02x) has failed\\n\",\n\t\t\t le16_to_cpu(event_data->DevHandle),\n\t\t\t (u64)le64_to_cpu(event_data->SASAddress),\n\t\t\t event_data->PhysicalPort);\n\t\tbreak;\n\tcase MPI25_EVENT_SAS_DISC_ERR_SMP_TIMEOUT:\n\t\tioc_warn(ioc, \"SMP command sent to the expander (handle:0x%04x, sas_address:0x%016llx, physical_port:0x%02x) has timed out\\n\",\n\t\t\t le16_to_cpu(event_data->DevHandle),\n\t\t\t (u64)le64_to_cpu(event_data->SASAddress),\n\t\t\t event_data->PhysicalPort);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void\n_scsih_pcie_enumeration_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tMpi26EventDataPCIeEnumeration_t *event_data =\n\t\t(Mpi26EventDataPCIeEnumeration_t *)fw_event->event_data;\n\n\tif (!(ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK))\n\t\treturn;\n\n\tioc_info(ioc, \"pcie enumeration event: (%s) Flag 0x%02x\",\n\t\t (event_data->ReasonCode == MPI26_EVENT_PCIE_ENUM_RC_STARTED) ?\n\t\t \"started\" : \"completed\",\n\t\t event_data->Flags);\n\tif (event_data->EnumerationStatus)\n\t\tpr_cont(\"enumeration_status(0x%08x)\",\n\t\t\tle32_to_cpu(event_data->EnumerationStatus));\n\tpr_cont(\"\\n\");\n}\n\n \nstatic int\n_scsih_ir_fastpath(struct MPT3SAS_ADAPTER *ioc, u16 handle, u8 phys_disk_num)\n{\n\tMpi2RaidActionRequest_t *mpi_request;\n\tMpi2RaidActionReply_t *mpi_reply;\n\tu16 smid;\n\tu8 issue_reset = 0;\n\tint rc = 0;\n\tu16 ioc_status;\n\tu32 log_info;\n\n\tif (ioc->hba_mpi_version_belonged == MPI2_VERSION)\n\t\treturn rc;\n\n\tmutex_lock(&ioc->scsih_cmds.mutex);\n\n\tif (ioc->scsih_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: scsih_cmd in use\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\tioc->scsih_cmds.status = MPT3_CMD_PENDING;\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->scsih_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->scsih_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi2RaidActionRequest_t));\n\n\tmpi_request->Function = MPI2_FUNCTION_RAID_ACTION;\n\tmpi_request->Action = MPI2_RAID_ACTION_PHYSDISK_HIDDEN;\n\tmpi_request->PhysDiskNum = phys_disk_num;\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"IR RAID_ACTION: turning fast path on for handle(0x%04x), phys_disk_num (0x%02x)\\n\",\n\t\t\t    handle, phys_disk_num));\n\n\tinit_completion(&ioc->scsih_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->scsih_cmds.done, 10*HZ);\n\n\tif (!(ioc->scsih_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tmpt3sas_check_cmd_timeout(ioc,\n\t\t    ioc->scsih_cmds.status, mpi_request,\n\t\t    sizeof(Mpi2RaidActionRequest_t)/4, issue_reset);\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (ioc->scsih_cmds.status & MPT3_CMD_REPLY_VALID) {\n\n\t\tmpi_reply = ioc->scsih_cmds.reply;\n\t\tioc_status = le16_to_cpu(mpi_reply->IOCStatus);\n\t\tif (ioc_status & MPI2_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE)\n\t\t\tlog_info =  le32_to_cpu(mpi_reply->IOCLogInfo);\n\t\telse\n\t\t\tlog_info = 0;\n\t\tioc_status &= MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tdewtprintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"IR RAID_ACTION: failed: ioc_status(0x%04x), loginfo(0x%08x)!!!\\n\",\n\t\t\t\t\t    ioc_status, log_info));\n\t\t\trc = -EFAULT;\n\t\t} else\n\t\t\tdewtprintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"IR RAID_ACTION: completed successfully\\n\"));\n\t}\n\n out:\n\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_unlock(&ioc->scsih_cmds.mutex);\n\n\tif (issue_reset)\n\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\treturn rc;\n}\n\n \nstatic void\n_scsih_reprobe_lun(struct scsi_device *sdev, void *no_uld_attach)\n{\n\tsdev->no_uld_attach = no_uld_attach ? 1 : 0;\n\tsdev_printk(KERN_INFO, sdev, \"%s raid component\\n\",\n\t    sdev->no_uld_attach ? \"hiding\" : \"exposing\");\n\tWARN_ON(scsi_device_reprobe(sdev));\n}\n\n \nstatic void\n_scsih_sas_volume_add(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventIrConfigElement_t *element)\n{\n\tstruct _raid_device *raid_device;\n\tunsigned long flags;\n\tu64 wwid;\n\tu16 handle = le16_to_cpu(element->VolDevHandle);\n\tint rc;\n\n\tmpt3sas_config_get_volume_wwid(ioc, handle, &wwid);\n\tif (!wwid) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\traid_device = _scsih_raid_device_find_by_wwid(ioc, wwid);\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\n\tif (raid_device)\n\t\treturn;\n\n\traid_device = kzalloc(sizeof(struct _raid_device), GFP_KERNEL);\n\tif (!raid_device) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\traid_device->id = ioc->sas_id++;\n\traid_device->channel = RAID_CHANNEL;\n\traid_device->handle = handle;\n\traid_device->wwid = wwid;\n\t_scsih_raid_device_add(ioc, raid_device);\n\tif (!ioc->wait_for_discovery_to_complete) {\n\t\trc = scsi_add_device(ioc->shost, RAID_CHANNEL,\n\t\t    raid_device->id, 0);\n\t\tif (rc)\n\t\t\t_scsih_raid_device_remove(ioc, raid_device);\n\t} else {\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\t_scsih_determine_boot_device(ioc, raid_device, 1);\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t}\n}\n\n \nstatic void\n_scsih_sas_volume_delete(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _raid_device *raid_device;\n\tunsigned long flags;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct scsi_target *starget = NULL;\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\traid_device = mpt3sas_raid_device_find_by_handle(ioc, handle);\n\tif (raid_device) {\n\t\tif (raid_device->starget) {\n\t\t\tstarget = raid_device->starget;\n\t\t\tsas_target_priv_data = starget->hostdata;\n\t\t\tsas_target_priv_data->deleted = 1;\n\t\t}\n\t\tioc_info(ioc, \"removing handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t raid_device->handle, (u64)raid_device->wwid);\n\t\tlist_del(&raid_device->list);\n\t\tkfree(raid_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\tif (starget)\n\t\tscsi_remove_target(&starget->dev);\n}\n\n \nstatic void\n_scsih_sas_pd_expose(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventIrConfigElement_t *element)\n{\n\tstruct _sas_device *sas_device;\n\tstruct scsi_target *starget = NULL;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tunsigned long flags;\n\tu16 handle = le16_to_cpu(element->PhysDiskDevHandle);\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_handle(ioc, handle);\n\tif (sas_device) {\n\t\tsas_device->volume_handle = 0;\n\t\tsas_device->volume_wwid = 0;\n\t\tclear_bit(handle, ioc->pd_handles);\n\t\tif (sas_device->starget && sas_device->starget->hostdata) {\n\t\t\tstarget = sas_device->starget;\n\t\t\tsas_target_priv_data = starget->hostdata;\n\t\t\tsas_target_priv_data->flags &=\n\t\t\t    ~MPT_TARGET_FLAGS_RAID_COMPONENT;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\tif (!sas_device)\n\t\treturn;\n\n\t \n\tif (starget)\n\t\tstarget_for_each_device(starget, NULL, _scsih_reprobe_lun);\n\n\tsas_device_put(sas_device);\n}\n\n \nstatic void\n_scsih_sas_pd_hide(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventIrConfigElement_t *element)\n{\n\tstruct _sas_device *sas_device;\n\tstruct scsi_target *starget = NULL;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tunsigned long flags;\n\tu16 handle = le16_to_cpu(element->PhysDiskDevHandle);\n\tu16 volume_handle = 0;\n\tu64 volume_wwid = 0;\n\n\tmpt3sas_config_get_volume_handle(ioc, handle, &volume_handle);\n\tif (volume_handle)\n\t\tmpt3sas_config_get_volume_wwid(ioc, volume_handle,\n\t\t    &volume_wwid);\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_handle(ioc, handle);\n\tif (sas_device) {\n\t\tset_bit(handle, ioc->pd_handles);\n\t\tif (sas_device->starget && sas_device->starget->hostdata) {\n\t\t\tstarget = sas_device->starget;\n\t\t\tsas_target_priv_data = starget->hostdata;\n\t\t\tsas_target_priv_data->flags |=\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT;\n\t\t\tsas_device->volume_handle = volume_handle;\n\t\t\tsas_device->volume_wwid = volume_wwid;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\tif (!sas_device)\n\t\treturn;\n\n\t \n\t_scsih_ir_fastpath(ioc, handle, element->PhysDiskNum);\n\n\tif (starget)\n\t\tstarget_for_each_device(starget, (void *)1, _scsih_reprobe_lun);\n\n\tsas_device_put(sas_device);\n}\n\n \nstatic void\n_scsih_sas_pd_delete(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventIrConfigElement_t *element)\n{\n\tu16 handle = le16_to_cpu(element->PhysDiskDevHandle);\n\n\t_scsih_device_remove_by_handle(ioc, handle);\n}\n\n \nstatic void\n_scsih_sas_pd_add(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventIrConfigElement_t *element)\n{\n\tstruct _sas_device *sas_device;\n\tu16 handle = le16_to_cpu(element->PhysDiskDevHandle);\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tu32 ioc_status;\n\tu64 sas_address;\n\tu16 parent_handle;\n\n\tset_bit(handle, ioc->pd_handles);\n\n\tsas_device = mpt3sas_get_sdev_by_handle(ioc, handle);\n\tif (sas_device) {\n\t\t_scsih_ir_fastpath(ioc, handle, element->PhysDiskNum);\n\t\tsas_device_put(sas_device);\n\t\treturn;\n\t}\n\n\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\n\t    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tparent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);\n\tif (!_scsih_get_sas_address(ioc, parent_handle, &sas_address))\n\t\tmpt3sas_transport_update_links(ioc, sas_address, handle,\n\t\t    sas_device_pg0.PhyNum, MPI2_SAS_NEG_LINK_RATE_1_5,\n\t\t    mpt3sas_get_port_by_id(ioc,\n\t\t    sas_device_pg0.PhysicalPort, 0));\n\n\t_scsih_ir_fastpath(ioc, handle, element->PhysDiskNum);\n\t_scsih_add_device(ioc, handle, 0, 1);\n}\n\n \nstatic void\n_scsih_sas_ir_config_change_event_debug(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataIrConfigChangeList_t *event_data)\n{\n\tMpi2EventIrConfigElement_t *element;\n\tu8 element_type;\n\tint i;\n\tchar *reason_str = NULL, *element_str = NULL;\n\n\telement = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];\n\n\tioc_info(ioc, \"raid config change: (%s), elements(%d)\\n\",\n\t\t le32_to_cpu(event_data->Flags) & MPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG ?\n\t\t \"foreign\" : \"native\",\n\t\t event_data->NumElements);\n\tfor (i = 0; i < event_data->NumElements; i++, element++) {\n\t\tswitch (element->ReasonCode) {\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_ADDED:\n\t\t\treason_str = \"add\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_REMOVED:\n\t\t\treason_str = \"remove\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_NO_CHANGE:\n\t\t\treason_str = \"no change\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_HIDE:\n\t\t\treason_str = \"hide\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_UNHIDE:\n\t\t\treason_str = \"unhide\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED:\n\t\t\treason_str = \"volume_created\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED:\n\t\t\treason_str = \"volume_deleted\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_PD_CREATED:\n\t\t\treason_str = \"pd_created\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_PD_DELETED:\n\t\t\treason_str = \"pd_deleted\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treason_str = \"unknown reason\";\n\t\t\tbreak;\n\t\t}\n\t\telement_type = le16_to_cpu(element->ElementFlags) &\n\t\t    MPI2_EVENT_IR_CHANGE_EFLAGS_ELEMENT_TYPE_MASK;\n\t\tswitch (element_type) {\n\t\tcase MPI2_EVENT_IR_CHANGE_EFLAGS_VOLUME_ELEMENT:\n\t\t\telement_str = \"volume\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_EFLAGS_VOLPHYSDISK_ELEMENT:\n\t\t\telement_str = \"phys disk\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_EFLAGS_HOTSPARE_ELEMENT:\n\t\t\telement_str = \"hot spare\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telement_str = \"unknown element\";\n\t\t\tbreak;\n\t\t}\n\t\tpr_info(\"\\t(%s:%s), vol handle(0x%04x), \" \\\n\t\t    \"pd handle(0x%04x), pd num(0x%02x)\\n\", element_str,\n\t\t    reason_str, le16_to_cpu(element->VolDevHandle),\n\t\t    le16_to_cpu(element->PhysDiskDevHandle),\n\t\t    element->PhysDiskNum);\n\t}\n}\n\n \nstatic void\n_scsih_sas_ir_config_change_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tMpi2EventIrConfigElement_t *element;\n\tint i;\n\tu8 foreign_config;\n\tMpi2EventDataIrConfigChangeList_t *event_data =\n\t\t(Mpi2EventDataIrConfigChangeList_t *)\n\t\tfw_event->event_data;\n\n\tif ((ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK) &&\n\t     (!ioc->hide_ir_msg))\n\t\t_scsih_sas_ir_config_change_event_debug(ioc, event_data);\n\n\tforeign_config = (le32_to_cpu(event_data->Flags) &\n\t    MPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG) ? 1 : 0;\n\n\telement = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];\n\tif (ioc->shost_recovery &&\n\t    ioc->hba_mpi_version_belonged != MPI2_VERSION) {\n\t\tfor (i = 0; i < event_data->NumElements; i++, element++) {\n\t\t\tif (element->ReasonCode == MPI2_EVENT_IR_CHANGE_RC_HIDE)\n\t\t\t\t_scsih_ir_fastpath(ioc,\n\t\t\t\t\tle16_to_cpu(element->PhysDiskDevHandle),\n\t\t\t\t\telement->PhysDiskNum);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < event_data->NumElements; i++, element++) {\n\n\t\tswitch (element->ReasonCode) {\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED:\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_ADDED:\n\t\t\tif (!foreign_config)\n\t\t\t\t_scsih_sas_volume_add(ioc, element);\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED:\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_REMOVED:\n\t\t\tif (!foreign_config)\n\t\t\t\t_scsih_sas_volume_delete(ioc,\n\t\t\t\t    le16_to_cpu(element->VolDevHandle));\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_PD_CREATED:\n\t\t\tif (!ioc->is_warpdrive)\n\t\t\t\t_scsih_sas_pd_hide(ioc, element);\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_PD_DELETED:\n\t\t\tif (!ioc->is_warpdrive)\n\t\t\t\t_scsih_sas_pd_expose(ioc, element);\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_HIDE:\n\t\t\tif (!ioc->is_warpdrive)\n\t\t\t\t_scsih_sas_pd_add(ioc, element);\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_UNHIDE:\n\t\t\tif (!ioc->is_warpdrive)\n\t\t\t\t_scsih_sas_pd_delete(ioc, element);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void\n_scsih_sas_ir_volume_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tu64 wwid;\n\tunsigned long flags;\n\tstruct _raid_device *raid_device;\n\tu16 handle;\n\tu32 state;\n\tint rc;\n\tMpi2EventDataIrVolume_t *event_data =\n\t\t(Mpi2EventDataIrVolume_t *) fw_event->event_data;\n\n\tif (ioc->shost_recovery)\n\t\treturn;\n\n\tif (event_data->ReasonCode != MPI2_EVENT_IR_VOLUME_RC_STATE_CHANGED)\n\t\treturn;\n\n\thandle = le16_to_cpu(event_data->VolDevHandle);\n\tstate = le32_to_cpu(event_data->NewValue);\n\tif (!ioc->hide_ir_msg)\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: handle(0x%04x), old(0x%08x), new(0x%08x)\\n\",\n\t\t\t\t    __func__, handle,\n\t\t\t\t    le32_to_cpu(event_data->PreviousValue),\n\t\t\t\t    state));\n\tswitch (state) {\n\tcase MPI2_RAID_VOL_STATE_MISSING:\n\tcase MPI2_RAID_VOL_STATE_FAILED:\n\t\t_scsih_sas_volume_delete(ioc, handle);\n\t\tbreak;\n\n\tcase MPI2_RAID_VOL_STATE_ONLINE:\n\tcase MPI2_RAID_VOL_STATE_DEGRADED:\n\tcase MPI2_RAID_VOL_STATE_OPTIMAL:\n\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\traid_device = mpt3sas_raid_device_find_by_handle(ioc, handle);\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\n\t\tif (raid_device)\n\t\t\tbreak;\n\n\t\tmpt3sas_config_get_volume_wwid(ioc, handle, &wwid);\n\t\tif (!wwid) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\traid_device = kzalloc(sizeof(struct _raid_device), GFP_KERNEL);\n\t\tif (!raid_device) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\traid_device->id = ioc->sas_id++;\n\t\traid_device->channel = RAID_CHANNEL;\n\t\traid_device->handle = handle;\n\t\traid_device->wwid = wwid;\n\t\t_scsih_raid_device_add(ioc, raid_device);\n\t\trc = scsi_add_device(ioc->shost, RAID_CHANNEL,\n\t\t    raid_device->id, 0);\n\t\tif (rc)\n\t\t\t_scsih_raid_device_remove(ioc, raid_device);\n\t\tbreak;\n\n\tcase MPI2_RAID_VOL_STATE_INITIALIZING:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void\n_scsih_sas_ir_physical_disk_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tu16 handle, parent_handle;\n\tu32 state;\n\tstruct _sas_device *sas_device;\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tu32 ioc_status;\n\tMpi2EventDataIrPhysicalDisk_t *event_data =\n\t\t(Mpi2EventDataIrPhysicalDisk_t *) fw_event->event_data;\n\tu64 sas_address;\n\n\tif (ioc->shost_recovery)\n\t\treturn;\n\n\tif (event_data->ReasonCode != MPI2_EVENT_IR_PHYSDISK_RC_STATE_CHANGED)\n\t\treturn;\n\n\thandle = le16_to_cpu(event_data->PhysDiskDevHandle);\n\tstate = le32_to_cpu(event_data->NewValue);\n\n\tif (!ioc->hide_ir_msg)\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: handle(0x%04x), old(0x%08x), new(0x%08x)\\n\",\n\t\t\t\t    __func__, handle,\n\t\t\t\t    le32_to_cpu(event_data->PreviousValue),\n\t\t\t\t    state));\n\n\tswitch (state) {\n\tcase MPI2_RAID_PD_STATE_ONLINE:\n\tcase MPI2_RAID_PD_STATE_DEGRADED:\n\tcase MPI2_RAID_PD_STATE_REBUILDING:\n\tcase MPI2_RAID_PD_STATE_OPTIMAL:\n\tcase MPI2_RAID_PD_STATE_HOT_SPARE:\n\n\t\tif (!ioc->is_warpdrive)\n\t\t\tset_bit(handle, ioc->pd_handles);\n\n\t\tsas_device = mpt3sas_get_sdev_by_handle(ioc, handle);\n\t\tif (sas_device) {\n\t\t\tsas_device_put(sas_device);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply,\n\t\t    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_HANDLE,\n\t\t    handle))) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tparent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);\n\t\tif (!_scsih_get_sas_address(ioc, parent_handle, &sas_address))\n\t\t\tmpt3sas_transport_update_links(ioc, sas_address, handle,\n\t\t\t    sas_device_pg0.PhyNum, MPI2_SAS_NEG_LINK_RATE_1_5,\n\t\t\t    mpt3sas_get_port_by_id(ioc,\n\t\t\t    sas_device_pg0.PhysicalPort, 0));\n\n\t\t_scsih_add_device(ioc, handle, 0, 1);\n\n\t\tbreak;\n\n\tcase MPI2_RAID_PD_STATE_OFFLINE:\n\tcase MPI2_RAID_PD_STATE_NOT_CONFIGURED:\n\tcase MPI2_RAID_PD_STATE_NOT_COMPATIBLE:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void\n_scsih_sas_ir_operation_status_event_debug(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataIrOperationStatus_t *event_data)\n{\n\tchar *reason_str = NULL;\n\n\tswitch (event_data->RAIDOperation) {\n\tcase MPI2_EVENT_IR_RAIDOP_RESYNC:\n\t\treason_str = \"resync\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_RAIDOP_ONLINE_CAP_EXPANSION:\n\t\treason_str = \"online capacity expansion\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_RAIDOP_CONSISTENCY_CHECK:\n\t\treason_str = \"consistency check\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_RAIDOP_BACKGROUND_INIT:\n\t\treason_str = \"background init\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_RAIDOP_MAKE_DATA_CONSISTENT:\n\t\treason_str = \"make data consistent\";\n\t\tbreak;\n\t}\n\n\tif (!reason_str)\n\t\treturn;\n\n\tioc_info(ioc, \"raid operational status: (%s)\\thandle(0x%04x), percent complete(%d)\\n\",\n\t\t reason_str,\n\t\t le16_to_cpu(event_data->VolDevHandle),\n\t\t event_data->PercentComplete);\n}\n\n \nstatic void\n_scsih_sas_ir_operation_status_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tMpi2EventDataIrOperationStatus_t *event_data =\n\t\t(Mpi2EventDataIrOperationStatus_t *)\n\t\tfw_event->event_data;\n\tstatic struct _raid_device *raid_device;\n\tunsigned long flags;\n\tu16 handle;\n\n\tif ((ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK) &&\n\t    (!ioc->hide_ir_msg))\n\t\t_scsih_sas_ir_operation_status_event_debug(ioc,\n\t\t     event_data);\n\n\t \n\tif (event_data->RAIDOperation == MPI2_EVENT_IR_RAIDOP_RESYNC) {\n\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\thandle = le16_to_cpu(event_data->VolDevHandle);\n\t\traid_device = mpt3sas_raid_device_find_by_handle(ioc, handle);\n\t\tif (raid_device)\n\t\t\traid_device->percent_complete =\n\t\t\t    event_data->PercentComplete;\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t}\n}\n\n \nstatic void\n_scsih_prep_device_scan(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_device *sdev;\n\n\tshost_for_each_device(sdev, ioc->shost) {\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (sas_device_priv_data && sas_device_priv_data->sas_target)\n\t\t\tsas_device_priv_data->sas_target->deleted = 1;\n\t}\n}\n\n \nstatic void\n_scsih_update_device_qdepth(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct _sas_device *sas_device;\n\tstruct scsi_device *sdev;\n\tu16 qdepth;\n\n\tioc_info(ioc, \"Update devices with firmware reported queue depth\\n\");\n\tshost_for_each_device(sdev, ioc->shost) {\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (sas_device_priv_data && sas_device_priv_data->sas_target) {\n\t\t\tsas_target_priv_data = sas_device_priv_data->sas_target;\n\t\t\tsas_device = sas_device_priv_data->sas_target->sas_dev;\n\t\t\tif (sas_target_priv_data->flags & MPT_TARGET_FLAGS_PCIE_DEVICE)\n\t\t\t\tqdepth = ioc->max_nvme_qd;\n\t\t\telse if (sas_device &&\n\t\t\t    sas_device->device_info & MPI2_SAS_DEVICE_INFO_SSP_TARGET)\n\t\t\t\tqdepth = (sas_device->port_type > 1) ?\n\t\t\t\t    ioc->max_wideport_qd : ioc->max_narrowport_qd;\n\t\t\telse if (sas_device &&\n\t\t\t    sas_device->device_info & MPI2_SAS_DEVICE_INFO_SATA_DEVICE)\n\t\t\t\tqdepth = ioc->max_sata_qd;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\tmpt3sas_scsih_change_queue_depth(sdev, qdepth);\n\t\t}\n\t}\n}\n\n \nstatic void\n_scsih_mark_responding_sas_device(struct MPT3SAS_ADAPTER *ioc,\nMpi2SasDevicePage0_t *sas_device_pg0)\n{\n\tstruct MPT3SAS_TARGET *sas_target_priv_data = NULL;\n\tstruct scsi_target *starget;\n\tstruct _sas_device *sas_device = NULL;\n\tstruct _enclosure_node *enclosure_dev = NULL;\n\tunsigned long flags;\n\tstruct hba_port *port = mpt3sas_get_port_by_id(\n\t    ioc, sas_device_pg0->PhysicalPort, 0);\n\n\tif (sas_device_pg0->EnclosureHandle) {\n\t\tenclosure_dev =\n\t\t\tmpt3sas_scsih_enclosure_find_by_handle(ioc,\n\t\t\t\tle16_to_cpu(sas_device_pg0->EnclosureHandle));\n\t\tif (enclosure_dev == NULL)\n\t\t\tioc_info(ioc, \"Enclosure handle(0x%04x) doesn't match with enclosure device!\\n\",\n\t\t\t\t sas_device_pg0->EnclosureHandle);\n\t}\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tlist_for_each_entry(sas_device, &ioc->sas_device_list, list) {\n\t\tif (sas_device->sas_address != le64_to_cpu(\n\t\t    sas_device_pg0->SASAddress))\n\t\t\tcontinue;\n\t\tif (sas_device->slot != le16_to_cpu(sas_device_pg0->Slot))\n\t\t\tcontinue;\n\t\tif (sas_device->port != port)\n\t\t\tcontinue;\n\t\tsas_device->responding = 1;\n\t\tstarget = sas_device->starget;\n\t\tif (starget && starget->hostdata) {\n\t\t\tsas_target_priv_data = starget->hostdata;\n\t\t\tsas_target_priv_data->tm_busy = 0;\n\t\t\tsas_target_priv_data->deleted = 0;\n\t\t} else\n\t\t\tsas_target_priv_data = NULL;\n\t\tif (starget) {\n\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t    \"handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t    le16_to_cpu(sas_device_pg0->DevHandle),\n\t\t\t    (unsigned long long)\n\t\t\t    sas_device->sas_address);\n\n\t\t\tif (sas_device->enclosure_handle != 0)\n\t\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\t \"enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t (unsigned long long)\n\t\t\t\t sas_device->enclosure_logical_id,\n\t\t\t\t sas_device->slot);\n\t\t}\n\t\tif (le16_to_cpu(sas_device_pg0->Flags) &\n\t\t      MPI2_SAS_DEVICE0_FLAGS_ENCL_LEVEL_VALID) {\n\t\t\tsas_device->enclosure_level =\n\t\t\t   sas_device_pg0->EnclosureLevel;\n\t\t\tmemcpy(&sas_device->connector_name[0],\n\t\t\t\t&sas_device_pg0->ConnectorName[0], 4);\n\t\t} else {\n\t\t\tsas_device->enclosure_level = 0;\n\t\t\tsas_device->connector_name[0] = '\\0';\n\t\t}\n\n\t\tsas_device->enclosure_handle =\n\t\t\tle16_to_cpu(sas_device_pg0->EnclosureHandle);\n\t\tsas_device->is_chassis_slot_valid = 0;\n\t\tif (enclosure_dev) {\n\t\t\tsas_device->enclosure_logical_id = le64_to_cpu(\n\t\t\t\tenclosure_dev->pg0.EnclosureLogicalID);\n\t\t\tif (le16_to_cpu(enclosure_dev->pg0.Flags) &\n\t\t\t    MPI2_SAS_ENCLS0_FLAGS_CHASSIS_SLOT_VALID) {\n\t\t\t\tsas_device->is_chassis_slot_valid = 1;\n\t\t\t\tsas_device->chassis_slot =\n\t\t\t\t\tenclosure_dev->pg0.ChassisSlot;\n\t\t\t}\n\t\t}\n\n\t\tif (sas_device->handle == le16_to_cpu(\n\t\t    sas_device_pg0->DevHandle))\n\t\t\tgoto out;\n\t\tpr_info(\"\\thandle changed from(0x%04x)!!!\\n\",\n\t\t    sas_device->handle);\n\t\tsas_device->handle = le16_to_cpu(\n\t\t    sas_device_pg0->DevHandle);\n\t\tif (sas_target_priv_data)\n\t\t\tsas_target_priv_data->handle =\n\t\t\t    le16_to_cpu(sas_device_pg0->DevHandle);\n\t\tgoto out;\n\t}\n out:\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n}\n\n \nstatic void\n_scsih_create_enclosure_list_after_reset(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _enclosure_node *enclosure_dev;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 enclosure_handle;\n\tint rc;\n\n\t \n\tmpt3sas_free_enclosure_list(ioc);\n\n\t \n\tenclosure_handle = 0xFFFF;\n\tdo {\n\t\tenclosure_dev =\n\t\t\tkzalloc(sizeof(struct _enclosure_node), GFP_KERNEL);\n\t\tif (!enclosure_dev) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\treturn;\n\t\t}\n\t\trc = mpt3sas_config_get_enclosure_pg0(ioc, &mpi_reply,\n\t\t\t\t&enclosure_dev->pg0,\n\t\t\t\tMPI2_SAS_ENCLOS_PGAD_FORM_GET_NEXT_HANDLE,\n\t\t\t\tenclosure_handle);\n\n\t\tif (rc || (le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t\t\t\t\tMPI2_IOCSTATUS_MASK)) {\n\t\t\tkfree(enclosure_dev);\n\t\t\treturn;\n\t\t}\n\t\tlist_add_tail(&enclosure_dev->list,\n\t\t\t\t\t\t&ioc->enclosure_list);\n\t\tenclosure_handle =\n\t\t\tle16_to_cpu(enclosure_dev->pg0.EnclosureHandle);\n\t} while (1);\n}\n\n \nstatic void\n_scsih_search_responding_sas_devices(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 ioc_status;\n\tu16 handle;\n\tu32 device_info;\n\n\tioc_info(ioc, \"search for end-devices: start\\n\");\n\n\tif (list_empty(&ioc->sas_device_list))\n\t\tgoto out;\n\n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply,\n\t    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE,\n\t    handle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\t\tbreak;\n\t\thandle = le16_to_cpu(sas_device_pg0.DevHandle);\n\t\tdevice_info = le32_to_cpu(sas_device_pg0.DeviceInfo);\n\t\tif (!(_scsih_is_end_device(device_info)))\n\t\t\tcontinue;\n\t\t_scsih_mark_responding_sas_device(ioc, &sas_device_pg0);\n\t}\n\n out:\n\tioc_info(ioc, \"search for end-devices: complete\\n\");\n}\n\n \nstatic void\n_scsih_mark_responding_pcie_device(struct MPT3SAS_ADAPTER *ioc,\n\tMpi26PCIeDevicePage0_t *pcie_device_pg0)\n{\n\tstruct MPT3SAS_TARGET *sas_target_priv_data = NULL;\n\tstruct scsi_target *starget;\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_list, list) {\n\t\tif ((pcie_device->wwid == le64_to_cpu(pcie_device_pg0->WWID))\n\t\t    && (pcie_device->slot == le16_to_cpu(\n\t\t    pcie_device_pg0->Slot))) {\n\t\t\tpcie_device->access_status =\n\t\t\t\t\tpcie_device_pg0->AccessStatus;\n\t\t\tpcie_device->responding = 1;\n\t\t\tstarget = pcie_device->starget;\n\t\t\tif (starget && starget->hostdata) {\n\t\t\t\tsas_target_priv_data = starget->hostdata;\n\t\t\t\tsas_target_priv_data->tm_busy = 0;\n\t\t\t\tsas_target_priv_data->deleted = 0;\n\t\t\t} else\n\t\t\t\tsas_target_priv_data = NULL;\n\t\t\tif (starget) {\n\t\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\t    \"handle(0x%04x), wwid(0x%016llx) \",\n\t\t\t\t    pcie_device->handle,\n\t\t\t\t    (unsigned long long)pcie_device->wwid);\n\t\t\t\tif (pcie_device->enclosure_handle != 0)\n\t\t\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\t\t    \"enclosure logical id(0x%016llx), \"\n\t\t\t\t\t    \"slot(%d)\\n\",\n\t\t\t\t\t    (unsigned long long)\n\t\t\t\t\t    pcie_device->enclosure_logical_id,\n\t\t\t\t\t    pcie_device->slot);\n\t\t\t}\n\n\t\t\tif (((le32_to_cpu(pcie_device_pg0->Flags)) &\n\t\t\t    MPI26_PCIEDEV0_FLAGS_ENCL_LEVEL_VALID) &&\n\t\t\t    (ioc->hba_mpi_version_belonged != MPI2_VERSION)) {\n\t\t\t\tpcie_device->enclosure_level =\n\t\t\t\t    pcie_device_pg0->EnclosureLevel;\n\t\t\t\tmemcpy(&pcie_device->connector_name[0],\n\t\t\t\t    &pcie_device_pg0->ConnectorName[0], 4);\n\t\t\t} else {\n\t\t\t\tpcie_device->enclosure_level = 0;\n\t\t\t\tpcie_device->connector_name[0] = '\\0';\n\t\t\t}\n\n\t\t\tif (pcie_device->handle == le16_to_cpu(\n\t\t\t    pcie_device_pg0->DevHandle))\n\t\t\t\tgoto out;\n\t\t\tpr_info(\"\\thandle changed from(0x%04x)!!!\\n\",\n\t\t\t    pcie_device->handle);\n\t\t\tpcie_device->handle = le16_to_cpu(\n\t\t\t    pcie_device_pg0->DevHandle);\n\t\t\tif (sas_target_priv_data)\n\t\t\t\tsas_target_priv_data->handle =\n\t\t\t\t    le16_to_cpu(pcie_device_pg0->DevHandle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n}\n\n \nstatic void\n_scsih_search_responding_pcie_devices(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi26PCIeDevicePage0_t pcie_device_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 ioc_status;\n\tu16 handle;\n\tu32 device_info;\n\n\tioc_info(ioc, \"search for end-devices: start\\n\");\n\n\tif (list_empty(&ioc->pcie_device_list))\n\t\tgoto out;\n\n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_pcie_device_pg0(ioc, &mpi_reply,\n\t\t&pcie_device_pg0, MPI26_PCIE_DEVICE_PGAD_FORM_GET_NEXT_HANDLE,\n\t\thandle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from %s: ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t __func__, ioc_status,\n\t\t\t\t le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\thandle = le16_to_cpu(pcie_device_pg0.DevHandle);\n\t\tdevice_info = le32_to_cpu(pcie_device_pg0.DeviceInfo);\n\t\tif (!(_scsih_is_nvme_pciescsi_device(device_info)))\n\t\t\tcontinue;\n\t\t_scsih_mark_responding_pcie_device(ioc, &pcie_device_pg0);\n\t}\nout:\n\tioc_info(ioc, \"search for PCIe end-devices: complete\\n\");\n}\n\n \nstatic void\n_scsih_mark_responding_raid_device(struct MPT3SAS_ADAPTER *ioc, u64 wwid,\n\tu16 handle)\n{\n\tstruct MPT3SAS_TARGET *sas_target_priv_data = NULL;\n\tstruct scsi_target *starget;\n\tstruct _raid_device *raid_device;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\tlist_for_each_entry(raid_device, &ioc->raid_device_list, list) {\n\t\tif (raid_device->wwid == wwid && raid_device->starget) {\n\t\t\tstarget = raid_device->starget;\n\t\t\tif (starget && starget->hostdata) {\n\t\t\t\tsas_target_priv_data = starget->hostdata;\n\t\t\t\tsas_target_priv_data->deleted = 0;\n\t\t\t} else\n\t\t\t\tsas_target_priv_data = NULL;\n\t\t\traid_device->responding = 1;\n\t\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t\t\tstarget_printk(KERN_INFO, raid_device->starget,\n\t\t\t    \"handle(0x%04x), wwid(0x%016llx)\\n\", handle,\n\t\t\t    (unsigned long long)raid_device->wwid);\n\n\t\t\t \n\t\t\tmpt3sas_init_warpdrive_properties(ioc, raid_device);\n\t\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\t\tif (raid_device->handle == handle) {\n\t\t\t\tspin_unlock_irqrestore(&ioc->raid_device_lock,\n\t\t\t\t    flags);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpr_info(\"\\thandle changed from(0x%04x)!!!\\n\",\n\t\t\t    raid_device->handle);\n\t\t\traid_device->handle = handle;\n\t\t\tif (sas_target_priv_data)\n\t\t\t\tsas_target_priv_data->handle = handle;\n\t\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n}\n\n \nstatic void\n_scsih_search_responding_raid_devices(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2RaidVolPage1_t volume_pg1;\n\tMpi2RaidVolPage0_t volume_pg0;\n\tMpi2RaidPhysDiskPage0_t pd_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 ioc_status;\n\tu16 handle;\n\tu8 phys_disk_num;\n\n\tif (!ioc->ir_firmware)\n\t\treturn;\n\n\tioc_info(ioc, \"search for raid volumes: start\\n\");\n\n\tif (list_empty(&ioc->raid_device_list))\n\t\tgoto out;\n\n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_raid_volume_pg1(ioc, &mpi_reply,\n\t    &volume_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\t\tbreak;\n\t\thandle = le16_to_cpu(volume_pg1.DevHandle);\n\n\t\tif (mpt3sas_config_get_raid_volume_pg0(ioc, &mpi_reply,\n\t\t    &volume_pg0, MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,\n\t\t     sizeof(Mpi2RaidVolPage0_t)))\n\t\t\tcontinue;\n\n\t\tif (volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_OPTIMAL ||\n\t\t    volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_ONLINE ||\n\t\t    volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_DEGRADED)\n\t\t\t_scsih_mark_responding_raid_device(ioc,\n\t\t\t    le64_to_cpu(volume_pg1.WWID), handle);\n\t}\n\n\t \n\tif (!ioc->is_warpdrive) {\n\t\tphys_disk_num = 0xFF;\n\t\tmemset(ioc->pd_handles, 0, ioc->pd_handles_sz);\n\t\twhile (!(mpt3sas_config_get_phys_disk_pg0(ioc, &mpi_reply,\n\t\t    &pd_pg0, MPI2_PHYSDISK_PGAD_FORM_GET_NEXT_PHYSDISKNUM,\n\t\t    phys_disk_num))) {\n\t\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t\t    MPI2_IOCSTATUS_MASK;\n\t\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t\tphys_disk_num = pd_pg0.PhysDiskNum;\n\t\t\thandle = le16_to_cpu(pd_pg0.DevHandle);\n\t\t\tset_bit(handle, ioc->pd_handles);\n\t\t}\n\t}\n out:\n\tioc_info(ioc, \"search for responding raid volumes: complete\\n\");\n}\n\n \nstatic void\n_scsih_mark_responding_expander(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2ExpanderPage0_t *expander_pg0)\n{\n\tstruct _sas_node *sas_expander = NULL;\n\tunsigned long flags;\n\tint i;\n\tstruct _enclosure_node *enclosure_dev = NULL;\n\tu16 handle = le16_to_cpu(expander_pg0->DevHandle);\n\tu16 enclosure_handle = le16_to_cpu(expander_pg0->EnclosureHandle);\n\tu64 sas_address = le64_to_cpu(expander_pg0->SASAddress);\n\tstruct hba_port *port = mpt3sas_get_port_by_id(\n\t    ioc, expander_pg0->PhysicalPort, 0);\n\n\tif (enclosure_handle)\n\t\tenclosure_dev =\n\t\t\tmpt3sas_scsih_enclosure_find_by_handle(ioc,\n\t\t\t\t\t\t\tenclosure_handle);\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tlist_for_each_entry(sas_expander, &ioc->sas_expander_list, list) {\n\t\tif (sas_expander->sas_address != sas_address)\n\t\t\tcontinue;\n\t\tif (sas_expander->port != port)\n\t\t\tcontinue;\n\t\tsas_expander->responding = 1;\n\n\t\tif (enclosure_dev) {\n\t\t\tsas_expander->enclosure_logical_id =\n\t\t\t    le64_to_cpu(enclosure_dev->pg0.EnclosureLogicalID);\n\t\t\tsas_expander->enclosure_handle =\n\t\t\t    le16_to_cpu(expander_pg0->EnclosureHandle);\n\t\t}\n\n\t\tif (sas_expander->handle == handle)\n\t\t\tgoto out;\n\t\tpr_info(\"\\texpander(0x%016llx): handle changed\" \\\n\t\t    \" from(0x%04x) to (0x%04x)!!!\\n\",\n\t\t    (unsigned long long)sas_expander->sas_address,\n\t\t    sas_expander->handle, handle);\n\t\tsas_expander->handle = handle;\n\t\tfor (i = 0 ; i < sas_expander->num_phys ; i++)\n\t\t\tsas_expander->phy[i].handle = handle;\n\t\tgoto out;\n\t}\n out:\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n}\n\n \nstatic void\n_scsih_search_responding_expanders(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2ExpanderPage0_t expander_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 ioc_status;\n\tu64 sas_address;\n\tu16 handle;\n\tu8 port;\n\n\tioc_info(ioc, \"search for expanders: start\\n\");\n\n\tif (list_empty(&ioc->sas_expander_list))\n\t\tgoto out;\n\n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_expander_pg0(ioc, &mpi_reply, &expander_pg0,\n\t    MPI2_SAS_EXPAND_PGAD_FORM_GET_NEXT_HNDL, handle))) {\n\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\t\tbreak;\n\n\t\thandle = le16_to_cpu(expander_pg0.DevHandle);\n\t\tsas_address = le64_to_cpu(expander_pg0.SASAddress);\n\t\tport = expander_pg0.PhysicalPort;\n\t\tpr_info(\n\t\t    \"\\texpander present: handle(0x%04x), sas_addr(0x%016llx), port:%d\\n\",\n\t\t    handle, (unsigned long long)sas_address,\n\t\t    (ioc->multipath_on_hba ?\n\t\t    port : MULTIPATH_DISABLED_PORT_ID));\n\t\t_scsih_mark_responding_expander(ioc, &expander_pg0);\n\t}\n\n out:\n\tioc_info(ioc, \"search for expanders: complete\\n\");\n}\n\n \nstatic void\n_scsih_remove_unresponding_devices(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _sas_device *sas_device, *sas_device_next;\n\tstruct _sas_node *sas_expander, *sas_expander_next;\n\tstruct _raid_device *raid_device, *raid_device_next;\n\tstruct _pcie_device *pcie_device, *pcie_device_next;\n\tstruct list_head tmp_list;\n\tunsigned long flags;\n\tLIST_HEAD(head);\n\n\tioc_info(ioc, \"removing unresponding devices: start\\n\");\n\n\t \n\tioc_info(ioc, \"removing unresponding devices: end-devices\\n\");\n\t \n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\n\t \n\tlist_for_each_entry_safe(sas_device, sas_device_next,\n\t    &ioc->sas_device_init_list, list) {\n\t\tlist_del_init(&sas_device->list);\n\t\tsas_device_put(sas_device);\n\t}\n\n\tlist_for_each_entry_safe(sas_device, sas_device_next,\n\t    &ioc->sas_device_list, list) {\n\t\tif (!sas_device->responding)\n\t\t\tlist_move_tail(&sas_device->list, &head);\n\t\telse\n\t\t\tsas_device->responding = 0;\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\t \n\tlist_for_each_entry_safe(sas_device, sas_device_next, &head, list) {\n\t\t_scsih_remove_device(ioc, sas_device);\n\t\tlist_del_init(&sas_device->list);\n\t\tsas_device_put(sas_device);\n\t}\n\n\tioc_info(ioc, \"Removing unresponding devices: pcie end-devices\\n\");\n\tINIT_LIST_HEAD(&head);\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t \n\tlist_for_each_entry_safe(pcie_device, pcie_device_next,\n\t    &ioc->pcie_device_init_list, list) {\n\t\tlist_del_init(&pcie_device->list);\n\t\tpcie_device_put(pcie_device);\n\t}\n\n\tlist_for_each_entry_safe(pcie_device, pcie_device_next,\n\t    &ioc->pcie_device_list, list) {\n\t\tif (!pcie_device->responding)\n\t\t\tlist_move_tail(&pcie_device->list, &head);\n\t\telse\n\t\t\tpcie_device->responding = 0;\n\t}\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\tlist_for_each_entry_safe(pcie_device, pcie_device_next, &head, list) {\n\t\t_scsih_pcie_device_remove_from_sml(ioc, pcie_device);\n\t\tlist_del_init(&pcie_device->list);\n\t\tpcie_device_put(pcie_device);\n\t}\n\n\t \n\tif (ioc->ir_firmware) {\n\t\tioc_info(ioc, \"removing unresponding devices: volumes\\n\");\n\t\tlist_for_each_entry_safe(raid_device, raid_device_next,\n\t\t    &ioc->raid_device_list, list) {\n\t\t\tif (!raid_device->responding)\n\t\t\t\t_scsih_sas_volume_delete(ioc,\n\t\t\t\t    raid_device->handle);\n\t\t\telse\n\t\t\t\traid_device->responding = 0;\n\t\t}\n\t}\n\n\t \n\tioc_info(ioc, \"removing unresponding devices: expanders\\n\");\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tINIT_LIST_HEAD(&tmp_list);\n\tlist_for_each_entry_safe(sas_expander, sas_expander_next,\n\t    &ioc->sas_expander_list, list) {\n\t\tif (!sas_expander->responding)\n\t\t\tlist_move_tail(&sas_expander->list, &tmp_list);\n\t\telse\n\t\t\tsas_expander->responding = 0;\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\tlist_for_each_entry_safe(sas_expander, sas_expander_next, &tmp_list,\n\t    list) {\n\t\t_scsih_expander_node_remove(ioc, sas_expander);\n\t}\n\n\tioc_info(ioc, \"removing unresponding devices: complete\\n\");\n\n\t \n\t_scsih_ublock_io_all_device(ioc);\n}\n\nstatic void\n_scsih_refresh_expander_links(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_node *sas_expander, u16 handle)\n{\n\tMpi2ExpanderPage1_t expander_pg1;\n\tMpi2ConfigReply_t mpi_reply;\n\tint i;\n\n\tfor (i = 0 ; i < sas_expander->num_phys ; i++) {\n\t\tif ((mpt3sas_config_get_expander_pg1(ioc, &mpi_reply,\n\t\t    &expander_pg1, i, handle))) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tmpt3sas_transport_update_links(ioc, sas_expander->sas_address,\n\t\t    le16_to_cpu(expander_pg1.AttachedDevHandle), i,\n\t\t    expander_pg1.NegotiatedLinkRate >> 4,\n\t\t    sas_expander->port);\n\t}\n}\n\n \nstatic void\n_scsih_scan_for_devices_after_reset(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2ExpanderPage0_t expander_pg0;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tMpi26PCIeDevicePage0_t pcie_device_pg0;\n\tMpi2RaidVolPage1_t *volume_pg1;\n\tMpi2RaidVolPage0_t *volume_pg0;\n\tMpi2RaidPhysDiskPage0_t pd_pg0;\n\tMpi2EventIrConfigElement_t element;\n\tMpi2ConfigReply_t mpi_reply;\n\tu8 phys_disk_num, port_id;\n\tu16 ioc_status;\n\tu16 handle, parent_handle;\n\tu64 sas_address;\n\tstruct _sas_device *sas_device;\n\tstruct _pcie_device *pcie_device;\n\tstruct _sas_node *expander_device;\n\tstatic struct _raid_device *raid_device;\n\tu8 retry_count;\n\tunsigned long flags;\n\n\tvolume_pg0 = kzalloc(sizeof(*volume_pg0), GFP_KERNEL);\n\tif (!volume_pg0)\n\t\treturn;\n\n\tvolume_pg1 = kzalloc(sizeof(*volume_pg1), GFP_KERNEL);\n\tif (!volume_pg1) {\n\t\tkfree(volume_pg0);\n\t\treturn;\n\t}\n\n\tioc_info(ioc, \"scan devices: start\\n\");\n\n\t_scsih_sas_host_refresh(ioc);\n\n\tioc_info(ioc, \"\\tscan devices: expanders start\\n\");\n\n\t \n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_expander_pg0(ioc, &mpi_reply, &expander_pg0,\n\t    MPI2_SAS_EXPAND_PGAD_FORM_GET_NEXT_HNDL, handle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from expander scan: ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t ioc_status, le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\thandle = le16_to_cpu(expander_pg0.DevHandle);\n\t\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\t\tport_id = expander_pg0.PhysicalPort;\n\t\texpander_device = mpt3sas_scsih_expander_find_by_sas_address(\n\t\t    ioc, le64_to_cpu(expander_pg0.SASAddress),\n\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0));\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t\tif (expander_device)\n\t\t\t_scsih_refresh_expander_links(ioc, expander_device,\n\t\t\t    handle);\n\t\telse {\n\t\t\tioc_info(ioc, \"\\tBEFORE adding expander: handle (0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t\t handle,\n\t\t\t\t (u64)le64_to_cpu(expander_pg0.SASAddress));\n\t\t\t_scsih_expander_add(ioc, handle);\n\t\t\tioc_info(ioc, \"\\tAFTER adding expander: handle (0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t\t handle,\n\t\t\t\t (u64)le64_to_cpu(expander_pg0.SASAddress));\n\t\t}\n\t}\n\n\tioc_info(ioc, \"\\tscan devices: expanders complete\\n\");\n\n\tif (!ioc->ir_firmware)\n\t\tgoto skip_to_sas;\n\n\tioc_info(ioc, \"\\tscan devices: phys disk start\\n\");\n\n\t \n\tphys_disk_num = 0xFF;\n\twhile (!(mpt3sas_config_get_phys_disk_pg0(ioc, &mpi_reply,\n\t    &pd_pg0, MPI2_PHYSDISK_PGAD_FORM_GET_NEXT_PHYSDISKNUM,\n\t    phys_disk_num))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from phys disk scan: ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t ioc_status, le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\tphys_disk_num = pd_pg0.PhysDiskNum;\n\t\thandle = le16_to_cpu(pd_pg0.DevHandle);\n\t\tsas_device = mpt3sas_get_sdev_by_handle(ioc, handle);\n\t\tif (sas_device) {\n\t\t\tsas_device_put(sas_device);\n\t\t\tcontinue;\n\t\t}\n\t\tif (mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply,\n\t\t    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_HANDLE,\n\t\t    handle) != 0)\n\t\t\tcontinue;\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from phys disk scan ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t ioc_status, le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\tparent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);\n\t\tif (!_scsih_get_sas_address(ioc, parent_handle,\n\t\t    &sas_address)) {\n\t\t\tioc_info(ioc, \"\\tBEFORE adding phys disk: handle (0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t\t handle,\n\t\t\t\t (u64)le64_to_cpu(sas_device_pg0.SASAddress));\n\t\t\tport_id = sas_device_pg0.PhysicalPort;\n\t\t\tmpt3sas_transport_update_links(ioc, sas_address,\n\t\t\t    handle, sas_device_pg0.PhyNum,\n\t\t\t    MPI2_SAS_NEG_LINK_RATE_1_5,\n\t\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0));\n\t\t\tset_bit(handle, ioc->pd_handles);\n\t\t\tretry_count = 0;\n\t\t\t \n\t\t\twhile (_scsih_add_device(ioc, handle, retry_count++,\n\t\t\t    1)) {\n\t\t\t\tssleep(1);\n\t\t\t}\n\t\t\tioc_info(ioc, \"\\tAFTER adding phys disk: handle (0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t\t handle,\n\t\t\t\t (u64)le64_to_cpu(sas_device_pg0.SASAddress));\n\t\t}\n\t}\n\n\tioc_info(ioc, \"\\tscan devices: phys disk complete\\n\");\n\n\tioc_info(ioc, \"\\tscan devices: volumes start\\n\");\n\n\t \n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_raid_volume_pg1(ioc, &mpi_reply,\n\t    volume_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from volume scan: ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t ioc_status, le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\thandle = le16_to_cpu(volume_pg1->DevHandle);\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\traid_device = _scsih_raid_device_find_by_wwid(ioc,\n\t\t    le64_to_cpu(volume_pg1->WWID));\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t\tif (raid_device)\n\t\t\tcontinue;\n\t\tif (mpt3sas_config_get_raid_volume_pg0(ioc, &mpi_reply,\n\t\t    volume_pg0, MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,\n\t\t     sizeof(Mpi2RaidVolPage0_t)))\n\t\t\tcontinue;\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from volume scan: ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t ioc_status, le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\tif (volume_pg0->VolumeState == MPI2_RAID_VOL_STATE_OPTIMAL ||\n\t\t    volume_pg0->VolumeState == MPI2_RAID_VOL_STATE_ONLINE ||\n\t\t    volume_pg0->VolumeState == MPI2_RAID_VOL_STATE_DEGRADED) {\n\t\t\tmemset(&element, 0, sizeof(Mpi2EventIrConfigElement_t));\n\t\t\telement.ReasonCode = MPI2_EVENT_IR_CHANGE_RC_ADDED;\n\t\t\telement.VolDevHandle = volume_pg1->DevHandle;\n\t\t\tioc_info(ioc, \"\\tBEFORE adding volume: handle (0x%04x)\\n\",\n\t\t\t\t volume_pg1->DevHandle);\n\t\t\t_scsih_sas_volume_add(ioc, &element);\n\t\t\tioc_info(ioc, \"\\tAFTER adding volume: handle (0x%04x)\\n\",\n\t\t\t\t volume_pg1->DevHandle);\n\t\t}\n\t}\n\n\tioc_info(ioc, \"\\tscan devices: volumes complete\\n\");\n\n skip_to_sas:\n\n\tioc_info(ioc, \"\\tscan devices: end devices start\\n\");\n\n\t \n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply,\n\t    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE,\n\t    handle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from end device scan: ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t ioc_status, le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\thandle = le16_to_cpu(sas_device_pg0.DevHandle);\n\t\tif (!(_scsih_is_end_device(\n\t\t    le32_to_cpu(sas_device_pg0.DeviceInfo))))\n\t\t\tcontinue;\n\t\tport_id = sas_device_pg0.PhysicalPort;\n\t\tsas_device = mpt3sas_get_sdev_by_addr(ioc,\n\t\t    le64_to_cpu(sas_device_pg0.SASAddress),\n\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0));\n\t\tif (sas_device) {\n\t\t\tsas_device_put(sas_device);\n\t\t\tcontinue;\n\t\t}\n\t\tparent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);\n\t\tif (!_scsih_get_sas_address(ioc, parent_handle, &sas_address)) {\n\t\t\tioc_info(ioc, \"\\tBEFORE adding end device: handle (0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t\t handle,\n\t\t\t\t (u64)le64_to_cpu(sas_device_pg0.SASAddress));\n\t\t\tmpt3sas_transport_update_links(ioc, sas_address, handle,\n\t\t\t    sas_device_pg0.PhyNum, MPI2_SAS_NEG_LINK_RATE_1_5,\n\t\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0));\n\t\t\tretry_count = 0;\n\t\t\t \n\t\t\twhile (_scsih_add_device(ioc, handle, retry_count++,\n\t\t\t    0)) {\n\t\t\t\tssleep(1);\n\t\t\t}\n\t\t\tioc_info(ioc, \"\\tAFTER adding end device: handle (0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t\t handle,\n\t\t\t\t (u64)le64_to_cpu(sas_device_pg0.SASAddress));\n\t\t}\n\t}\n\tioc_info(ioc, \"\\tscan devices: end devices complete\\n\");\n\tioc_info(ioc, \"\\tscan devices: pcie end devices start\\n\");\n\n\t \n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_pcie_device_pg0(ioc, &mpi_reply,\n\t\t&pcie_device_pg0, MPI26_PCIE_DEVICE_PGAD_FORM_GET_NEXT_HANDLE,\n\t\thandle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus)\n\t\t\t\t& MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from pcie end device scan: ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t ioc_status, le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\thandle = le16_to_cpu(pcie_device_pg0.DevHandle);\n\t\tif (!(_scsih_is_nvme_pciescsi_device(\n\t\t\tle32_to_cpu(pcie_device_pg0.DeviceInfo))))\n\t\t\tcontinue;\n\t\tpcie_device = mpt3sas_get_pdev_by_wwid(ioc,\n\t\t\t\tle64_to_cpu(pcie_device_pg0.WWID));\n\t\tif (pcie_device) {\n\t\t\tpcie_device_put(pcie_device);\n\t\t\tcontinue;\n\t\t}\n\t\tretry_count = 0;\n\t\tparent_handle = le16_to_cpu(pcie_device_pg0.ParentDevHandle);\n\t\t_scsih_pcie_add_device(ioc, handle);\n\n\t\tioc_info(ioc, \"\\tAFTER adding pcie end device: handle (0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t handle, (u64)le64_to_cpu(pcie_device_pg0.WWID));\n\t}\n\n\tkfree(volume_pg0);\n\tkfree(volume_pg1);\n\n\tioc_info(ioc, \"\\tpcie devices: pcie end devices complete\\n\");\n\tioc_info(ioc, \"scan devices: complete\\n\");\n}\n\n \nvoid mpt3sas_scsih_pre_reset_handler(struct MPT3SAS_ADAPTER *ioc)\n{\n\tdtmprintk(ioc, ioc_info(ioc, \"%s: MPT3_IOC_PRE_RESET\\n\", __func__));\n}\n\n \nvoid\nmpt3sas_scsih_clear_outstanding_scsi_tm_commands(struct MPT3SAS_ADAPTER *ioc)\n{\n\tdtmprintk(ioc,\n\t    ioc_info(ioc, \"%s: clear outstanding scsi & tm cmds\\n\", __func__));\n\tif (ioc->scsih_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc->scsih_cmds.status |= MPT3_CMD_RESET;\n\t\tmpt3sas_base_free_smid(ioc, ioc->scsih_cmds.smid);\n\t\tcomplete(&ioc->scsih_cmds.done);\n\t}\n\tif (ioc->tm_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc->tm_cmds.status |= MPT3_CMD_RESET;\n\t\tmpt3sas_base_free_smid(ioc, ioc->tm_cmds.smid);\n\t\tcomplete(&ioc->tm_cmds.done);\n\t}\n\n\tmemset(ioc->pend_os_device_add, 0, ioc->pend_os_device_add_sz);\n\tmemset(ioc->device_remove_in_progress, 0,\n\t       ioc->device_remove_in_progress_sz);\n\t_scsih_fw_event_cleanup_queue(ioc);\n\t_scsih_flush_running_cmds(ioc);\n}\n\n \nvoid\nmpt3sas_scsih_reset_done_handler(struct MPT3SAS_ADAPTER *ioc)\n{\n\tdtmprintk(ioc, ioc_info(ioc, \"%s: MPT3_IOC_DONE_RESET\\n\", __func__));\n\tif (!(disable_discovery > 0 && !ioc->sas_hba.num_phys)) {\n\t\tif (ioc->multipath_on_hba) {\n\t\t\t_scsih_sas_port_refresh(ioc);\n\t\t\t_scsih_update_vphys_after_reset(ioc);\n\t\t}\n\t\t_scsih_prep_device_scan(ioc);\n\t\t_scsih_create_enclosure_list_after_reset(ioc);\n\t\t_scsih_search_responding_sas_devices(ioc);\n\t\t_scsih_search_responding_pcie_devices(ioc);\n\t\t_scsih_search_responding_raid_devices(ioc);\n\t\t_scsih_search_responding_expanders(ioc);\n\t\t_scsih_error_recovery_delete_devices(ioc);\n\t}\n}\n\n \nstatic void\n_mpt3sas_fw_work(struct MPT3SAS_ADAPTER *ioc, struct fw_event_work *fw_event)\n{\n\tioc->current_event = fw_event;\n\t_scsih_fw_event_del_from_list(ioc, fw_event);\n\n\t \n\tif (ioc->remove_host || ioc->pci_error_recovery) {\n\t\tfw_event_work_put(fw_event);\n\t\tioc->current_event = NULL;\n\t\treturn;\n\t}\n\n\tswitch (fw_event->event) {\n\tcase MPT3SAS_PROCESS_TRIGGER_DIAG:\n\t\tmpt3sas_process_trigger_data(ioc,\n\t\t\t(struct SL_WH_TRIGGERS_EVENT_DATA_T *)\n\t\t\tfw_event->event_data);\n\t\tbreak;\n\tcase MPT3SAS_REMOVE_UNRESPONDING_DEVICES:\n\t\twhile (scsi_host_in_recovery(ioc->shost) ||\n\t\t\t\t\t ioc->shost_recovery) {\n\t\t\t \n\t\t\tif (ioc->remove_host || ioc->fw_events_cleanup)\n\t\t\t\tgoto out;\n\t\t\tssleep(1);\n\t\t}\n\t\t_scsih_remove_unresponding_devices(ioc);\n\t\t_scsih_del_dirty_vphy(ioc);\n\t\t_scsih_del_dirty_port_entries(ioc);\n\t\tif (ioc->is_gen35_ioc)\n\t\t\t_scsih_update_device_qdepth(ioc);\n\t\t_scsih_scan_for_devices_after_reset(ioc);\n\t\t \n\t\tif (ioc->is_driver_loading)\n\t\t\t_scsih_complete_devices_scanning(ioc);\n\t\t_scsih_set_nvme_max_shutdown_latency(ioc);\n\t\tbreak;\n\tcase MPT3SAS_PORT_ENABLE_COMPLETE:\n\t\tioc->start_scan = 0;\n\t\tif (missing_delay[0] != -1 && missing_delay[1] != -1)\n\t\t\tmpt3sas_base_update_missing_delay(ioc, missing_delay[0],\n\t\t\t    missing_delay[1]);\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"port enable: complete from worker thread\\n\"));\n\t\tbreak;\n\tcase MPT3SAS_TURN_ON_PFA_LED:\n\t\t_scsih_turn_on_pfa_led(ioc, fw_event->device_handle);\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST:\n\t\t_scsih_sas_topology_change_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE:\n\t\tif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\n\t\t\t_scsih_sas_device_status_change_event_debug(ioc,\n\t\t\t    (Mpi2EventDataSasDeviceStatusChange_t *)\n\t\t\t    fw_event->event_data);\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DISCOVERY:\n\t\t_scsih_sas_discovery_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEVICE_DISCOVERY_ERROR:\n\t\t_scsih_sas_device_discovery_error_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_BROADCAST_PRIMITIVE:\n\t\t_scsih_sas_broadcast_primitive_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE:\n\t\t_scsih_sas_enclosure_dev_status_change_event(ioc,\n\t\t    fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST:\n\t\t_scsih_sas_ir_config_change_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_IR_VOLUME:\n\t\t_scsih_sas_ir_volume_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_IR_PHYSICAL_DISK:\n\t\t_scsih_sas_ir_physical_disk_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_IR_OPERATION_STATUS:\n\t\t_scsih_sas_ir_operation_status_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_PCIE_DEVICE_STATUS_CHANGE:\n\t\t_scsih_pcie_device_status_change_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_PCIE_ENUMERATION:\n\t\t_scsih_pcie_enumeration_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_PCIE_TOPOLOGY_CHANGE_LIST:\n\t\t_scsih_pcie_topology_change_event(ioc, fw_event);\n\t\tioc->current_event = NULL;\n\t\treturn;\n\t}\nout:\n\tfw_event_work_put(fw_event);\n\tioc->current_event = NULL;\n}\n\n \n\nstatic void\n_firmware_event_work(struct work_struct *work)\n{\n\tstruct fw_event_work *fw_event = container_of(work,\n\t    struct fw_event_work, work);\n\n\t_mpt3sas_fw_work(fw_event->ioc, fw_event);\n}\n\n \nu8\nmpt3sas_scsih_event_callback(struct MPT3SAS_ADAPTER *ioc, u8 msix_index,\n\tu32 reply)\n{\n\tstruct fw_event_work *fw_event;\n\tMpi2EventNotificationReply_t *mpi_reply;\n\tu16 event;\n\tu16 sz;\n\tMpi26EventDataActiveCableExcept_t *ActiveCableEventData;\n\n\t \n\tif (ioc->pci_error_recovery)\n\t\treturn 1;\n\n\tmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\n\tif (unlikely(!mpi_reply)) {\n\t\tioc_err(ioc, \"mpi_reply not valid at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 1;\n\t}\n\n\tevent = le16_to_cpu(mpi_reply->Event);\n\n\tif (event != MPI2_EVENT_LOG_ENTRY_ADDED)\n\t\tmpt3sas_trigger_event(ioc, event, 0);\n\n\tswitch (event) {\n\t \n\tcase MPI2_EVENT_SAS_BROADCAST_PRIMITIVE:\n\t{\n\t\tMpi2EventDataSasBroadcastPrimitive_t *baen_data =\n\t\t    (Mpi2EventDataSasBroadcastPrimitive_t *)\n\t\t    mpi_reply->EventData;\n\n\t\tif (baen_data->Primitive !=\n\t\t    MPI2_EVENT_PRIMITIVE_ASYNCHRONOUS_EVENT)\n\t\t\treturn 1;\n\n\t\tif (ioc->broadcast_aen_busy) {\n\t\t\tioc->broadcast_aen_pending++;\n\t\t\treturn 1;\n\t\t} else\n\t\t\tioc->broadcast_aen_busy = 1;\n\t\tbreak;\n\t}\n\n\tcase MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST:\n\t\t_scsih_check_topo_delete_events(ioc,\n\t\t    (Mpi2EventDataSasTopologyChangeList_t *)\n\t\t    mpi_reply->EventData);\n\t\t \n\t\tif (ioc->shost_recovery)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MPI2_EVENT_PCIE_TOPOLOGY_CHANGE_LIST:\n\t_scsih_check_pcie_topo_remove_events(ioc,\n\t\t    (Mpi26EventDataPCIeTopologyChangeList_t *)\n\t\t    mpi_reply->EventData);\n\t\tif (ioc->shost_recovery)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST:\n\t\t_scsih_check_ir_config_unhide_events(ioc,\n\t\t    (Mpi2EventDataIrConfigChangeList_t *)\n\t\t    mpi_reply->EventData);\n\t\tbreak;\n\tcase MPI2_EVENT_IR_VOLUME:\n\t\t_scsih_check_volume_delete_events(ioc,\n\t\t    (Mpi2EventDataIrVolume_t *)\n\t\t    mpi_reply->EventData);\n\t\tbreak;\n\tcase MPI2_EVENT_LOG_ENTRY_ADDED:\n\t{\n\t\tMpi2EventDataLogEntryAdded_t *log_entry;\n\t\tu32 log_code;\n\n\t\tif (!ioc->is_warpdrive)\n\t\t\tbreak;\n\n\t\tlog_entry = (Mpi2EventDataLogEntryAdded_t *)\n\t\t    mpi_reply->EventData;\n\t\tlog_code = le32_to_cpu(*(__le32 *)log_entry->LogData);\n\n\t\tif (le16_to_cpu(log_entry->LogEntryQualifier)\n\t\t    != MPT2_WARPDRIVE_LOGENTRY)\n\t\t\tbreak;\n\n\t\tswitch (log_code) {\n\t\tcase MPT2_WARPDRIVE_LC_SSDT:\n\t\t\tioc_warn(ioc, \"WarpDrive Warning: IO Throttling has occurred in the WarpDrive subsystem. Check WarpDrive documentation for additional details.\\n\");\n\t\t\tbreak;\n\t\tcase MPT2_WARPDRIVE_LC_SSDLW:\n\t\t\tioc_warn(ioc, \"WarpDrive Warning: Program/Erase Cycles for the WarpDrive subsystem in degraded range. Check WarpDrive documentation for additional details.\\n\");\n\t\t\tbreak;\n\t\tcase MPT2_WARPDRIVE_LC_SSDLF:\n\t\t\tioc_err(ioc, \"WarpDrive Fatal Error: There are no Program/Erase Cycles for the WarpDrive subsystem. The storage device will be in read-only mode. Check WarpDrive documentation for additional details.\\n\");\n\t\t\tbreak;\n\t\tcase MPT2_WARPDRIVE_LC_BRMF:\n\t\t\tioc_err(ioc, \"WarpDrive Fatal Error: The Backup Rail Monitor has failed on the WarpDrive subsystem. Check WarpDrive documentation for additional details.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE:\n\t\t_scsih_sas_device_status_change_event(ioc,\n\t\t    (Mpi2EventDataSasDeviceStatusChange_t *)\n\t\t    mpi_reply->EventData);\n\t\tbreak;\n\tcase MPI2_EVENT_IR_OPERATION_STATUS:\n\tcase MPI2_EVENT_SAS_DISCOVERY:\n\tcase MPI2_EVENT_SAS_DEVICE_DISCOVERY_ERROR:\n\tcase MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE:\n\tcase MPI2_EVENT_IR_PHYSICAL_DISK:\n\tcase MPI2_EVENT_PCIE_ENUMERATION:\n\tcase MPI2_EVENT_PCIE_DEVICE_STATUS_CHANGE:\n\t\tbreak;\n\n\tcase MPI2_EVENT_TEMP_THRESHOLD:\n\t\t_scsih_temp_threshold_events(ioc,\n\t\t\t(Mpi2EventDataTemperature_t *)\n\t\t\tmpi_reply->EventData);\n\t\tbreak;\n\tcase MPI2_EVENT_ACTIVE_CABLE_EXCEPTION:\n\t\tActiveCableEventData =\n\t\t    (Mpi26EventDataActiveCableExcept_t *) mpi_reply->EventData;\n\t\tswitch (ActiveCableEventData->ReasonCode) {\n\t\tcase MPI26_EVENT_ACTIVE_CABLE_INSUFFICIENT_POWER:\n\t\t\tioc_notice(ioc, \"Currently an active cable with ReceptacleID %d\\n\",\n\t\t\t\t   ActiveCableEventData->ReceptacleID);\n\t\t\tpr_notice(\"cannot be powered and devices connected\\n\");\n\t\t\tpr_notice(\"to this active cable will not be seen\\n\");\n\t\t\tpr_notice(\"This active cable requires %d mW of power\\n\",\n\t\t\t    le32_to_cpu(\n\t\t\t    ActiveCableEventData->ActiveCablePowerRequirement));\n\t\t\tbreak;\n\n\t\tcase MPI26_EVENT_ACTIVE_CABLE_DEGRADED:\n\t\t\tioc_notice(ioc, \"Currently a cable with ReceptacleID %d\\n\",\n\t\t\t\t   ActiveCableEventData->ReceptacleID);\n\t\t\tpr_notice(\n\t\t\t    \"is not running at optimal speed(12 Gb/s rate)\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:  \n\t\treturn 1;\n\t}\n\n\tsz = le16_to_cpu(mpi_reply->EventDataLength) * 4;\n\tfw_event = alloc_fw_event_work(sz);\n\tif (!fw_event) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 1;\n\t}\n\n\tmemcpy(fw_event->event_data, mpi_reply->EventData, sz);\n\tfw_event->ioc = ioc;\n\tfw_event->VF_ID = mpi_reply->VF_ID;\n\tfw_event->VP_ID = mpi_reply->VP_ID;\n\tfw_event->event = event;\n\t_scsih_fw_event_add(ioc, fw_event);\n\tfw_event_work_put(fw_event);\n\treturn 1;\n}\n\n \nstatic void\n_scsih_expander_node_remove(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_node *sas_expander)\n{\n\tstruct _sas_port *mpt3sas_port, *next;\n\tunsigned long flags;\n\tint port_id;\n\n\t \n\tlist_for_each_entry_safe(mpt3sas_port, next,\n\t   &sas_expander->sas_port_list, port_list) {\n\t\tif (ioc->shost_recovery)\n\t\t\treturn;\n\t\tif (mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_END_DEVICE)\n\t\t\tmpt3sas_device_remove_by_sas_address(ioc,\n\t\t\t    mpt3sas_port->remote_identify.sas_address,\n\t\t\t    mpt3sas_port->hba_port);\n\t\telse if (mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\tmpt3sas_expander_remove(ioc,\n\t\t\t    mpt3sas_port->remote_identify.sas_address,\n\t\t\t    mpt3sas_port->hba_port);\n\t}\n\n\tport_id = sas_expander->port->port_id;\n\n\tmpt3sas_transport_port_remove(ioc, sas_expander->sas_address,\n\t    sas_expander->sas_address_parent, sas_expander->port);\n\n\tioc_info(ioc,\n\t    \"expander_remove: handle(0x%04x), sas_addr(0x%016llx), port:%d\\n\",\n\t    sas_expander->handle, (unsigned long long)\n\t    sas_expander->sas_address,\n\t    port_id);\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tlist_del(&sas_expander->list);\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\n\tkfree(sas_expander->phy);\n\tkfree(sas_expander);\n}\n\n \nstatic void\n_scsih_nvme_shutdown(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi26IoUnitControlRequest_t *mpi_request;\n\tMpi26IoUnitControlReply_t *mpi_reply;\n\tu16 smid;\n\n\t \n\tif (list_empty(&ioc->pcie_device_list))\n\t\treturn;\n\n\tmutex_lock(&ioc->scsih_cmds.mutex);\n\n\tif (ioc->scsih_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: scsih_cmd in use\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tioc->scsih_cmds.status = MPT3_CMD_PENDING;\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->scsih_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc,\n\t\t    \"%s: failed obtaining a smid\\n\", __func__);\n\t\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\t\tgoto out;\n\t}\n\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->scsih_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi26IoUnitControlRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_IO_UNIT_CONTROL;\n\tmpi_request->Operation = MPI26_CTRL_OP_SHUTDOWN;\n\n\tinit_completion(&ioc->scsih_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\t \n\tioc_info(ioc,\n\t\t\"Io Unit Control shutdown (sending), Shutdown latency %d sec\\n\",\n\t\tioc->max_shutdown_latency);\n\twait_for_completion_timeout(&ioc->scsih_cmds.done,\n\t\t\tioc->max_shutdown_latency*HZ);\n\n\tif (!(ioc->scsih_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tioc_err(ioc, \"%s: timeout\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tif (ioc->scsih_cmds.status & MPT3_CMD_REPLY_VALID) {\n\t\tmpi_reply = ioc->scsih_cmds.reply;\n\t\tioc_info(ioc, \"Io Unit Control shutdown (complete):\"\n\t\t\t\"ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\tle16_to_cpu(mpi_reply->IOCStatus),\n\t\t\tle32_to_cpu(mpi_reply->IOCLogInfo));\n\t}\n out:\n\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_unlock(&ioc->scsih_cmds.mutex);\n}\n\n\n \nstatic void\n_scsih_ir_shutdown(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2RaidActionRequest_t *mpi_request;\n\tMpi2RaidActionReply_t *mpi_reply;\n\tu16 smid;\n\n\t \n\tif (!ioc->ir_firmware)\n\t\treturn;\n\n\t \n\tif (list_empty(&ioc->raid_device_list))\n\t\treturn;\n\n\tmutex_lock(&ioc->scsih_cmds.mutex);\n\n\tif (ioc->scsih_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: scsih_cmd in use\\n\", __func__);\n\t\tgoto out;\n\t}\n\tioc->scsih_cmds.status = MPT3_CMD_PENDING;\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->scsih_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\t\tgoto out;\n\t}\n\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->scsih_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi2RaidActionRequest_t));\n\n\tmpi_request->Function = MPI2_FUNCTION_RAID_ACTION;\n\tmpi_request->Action = MPI2_RAID_ACTION_SYSTEM_SHUTDOWN_INITIATED;\n\n\tif (!ioc->hide_ir_msg)\n\t\tioc_info(ioc, \"IR shutdown (sending)\\n\");\n\tinit_completion(&ioc->scsih_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->scsih_cmds.done, 10*HZ);\n\n\tif (!(ioc->scsih_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tioc_err(ioc, \"%s: timeout\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tif (ioc->scsih_cmds.status & MPT3_CMD_REPLY_VALID) {\n\t\tmpi_reply = ioc->scsih_cmds.reply;\n\t\tif (!ioc->hide_ir_msg)\n\t\t\tioc_info(ioc, \"IR shutdown (complete): ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t le16_to_cpu(mpi_reply->IOCStatus),\n\t\t\t\t le32_to_cpu(mpi_reply->IOCLogInfo));\n\t}\n\n out:\n\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_unlock(&ioc->scsih_cmds.mutex);\n}\n\n \nstatic int\n_scsih_get_shost_and_ioc(struct pci_dev *pdev,\n\tstruct Scsi_Host **shost, struct MPT3SAS_ADAPTER **ioc)\n{\n\t*shost = pci_get_drvdata(pdev);\n\tif (*shost == NULL) {\n\t\tdev_err(&pdev->dev, \"pdev's driver data is null\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t*ioc = shost_priv(*shost);\n\tif (*ioc == NULL) {\n\t\tdev_err(&pdev->dev, \"shost's private data is null\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void scsih_remove(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tstruct _sas_port *mpt3sas_port, *next_port;\n\tstruct _raid_device *raid_device, *next;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct _pcie_device *pcie_device, *pcienext;\n\tstruct workqueue_struct\t*wq;\n\tunsigned long flags;\n\tMpi2ConfigReply_t mpi_reply;\n\tstruct hba_port *port, *port_next;\n\n\tif (_scsih_get_shost_and_ioc(pdev, &shost, &ioc))\n\t\treturn;\n\n\tioc->remove_host = 1;\n\n\tif (!pci_device_is_present(pdev)) {\n\t\tmpt3sas_base_pause_mq_polling(ioc);\n\t\t_scsih_flush_running_cmds(ioc);\n\t}\n\n\t_scsih_fw_event_cleanup_queue(ioc);\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\twq = ioc->firmware_event_thread;\n\tioc->firmware_event_thread = NULL;\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n\tif (wq)\n\t\tdestroy_workqueue(wq);\n\t \n\tif (ioc->is_aero_ioc)\n\t\tmpt3sas_config_set_ioc_pg1(ioc, &mpi_reply,\n\t\t\t\t&ioc->ioc_pg1_copy);\n\t \n\t_scsih_ir_shutdown(ioc);\n\tmpt3sas_destroy_debugfs(ioc);\n\tsas_remove_host(shost);\n\tlist_for_each_entry_safe(raid_device, next, &ioc->raid_device_list,\n\t    list) {\n\t\tif (raid_device->starget) {\n\t\t\tsas_target_priv_data =\n\t\t\t    raid_device->starget->hostdata;\n\t\t\tsas_target_priv_data->deleted = 1;\n\t\t\tscsi_remove_target(&raid_device->starget->dev);\n\t\t}\n\t\tioc_info(ioc, \"removing handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t raid_device->handle, (u64)raid_device->wwid);\n\t\t_scsih_raid_device_remove(ioc, raid_device);\n\t}\n\tlist_for_each_entry_safe(pcie_device, pcienext, &ioc->pcie_device_list,\n\t\tlist) {\n\t\t_scsih_pcie_device_remove_from_sml(ioc, pcie_device);\n\t\tlist_del_init(&pcie_device->list);\n\t\tpcie_device_put(pcie_device);\n\t}\n\n\t \n\tlist_for_each_entry_safe(mpt3sas_port, next_port,\n\t   &ioc->sas_hba.sas_port_list, port_list) {\n\t\tif (mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_END_DEVICE)\n\t\t\tmpt3sas_device_remove_by_sas_address(ioc,\n\t\t\t    mpt3sas_port->remote_identify.sas_address,\n\t\t\t    mpt3sas_port->hba_port);\n\t\telse if (mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\tmpt3sas_expander_remove(ioc,\n\t\t\t    mpt3sas_port->remote_identify.sas_address,\n\t\t\t    mpt3sas_port->hba_port);\n\t}\n\n\tlist_for_each_entry_safe(port, port_next,\n\t    &ioc->port_table_list, list) {\n\t\tlist_del(&port->list);\n\t\tkfree(port);\n\t}\n\n\t \n\tif (ioc->sas_hba.num_phys) {\n\t\tkfree(ioc->sas_hba.phy);\n\t\tioc->sas_hba.phy = NULL;\n\t\tioc->sas_hba.num_phys = 0;\n\t}\n\n\tmpt3sas_base_detach(ioc);\n\tspin_lock(&gioc_lock);\n\tlist_del(&ioc->list);\n\tspin_unlock(&gioc_lock);\n\tscsi_host_put(shost);\n}\n\n \nstatic void\nscsih_shutdown(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tstruct workqueue_struct\t*wq;\n\tunsigned long flags;\n\tMpi2ConfigReply_t mpi_reply;\n\n\tif (_scsih_get_shost_and_ioc(pdev, &shost, &ioc))\n\t\treturn;\n\n\tioc->remove_host = 1;\n\n\tif (!pci_device_is_present(pdev)) {\n\t\tmpt3sas_base_pause_mq_polling(ioc);\n\t\t_scsih_flush_running_cmds(ioc);\n\t}\n\n\t_scsih_fw_event_cleanup_queue(ioc);\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\twq = ioc->firmware_event_thread;\n\tioc->firmware_event_thread = NULL;\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n\tif (wq)\n\t\tdestroy_workqueue(wq);\n\t \n\tif (ioc->is_aero_ioc)\n\t\tmpt3sas_config_set_ioc_pg1(ioc, &mpi_reply,\n\t\t\t\t&ioc->ioc_pg1_copy);\n\n\t_scsih_ir_shutdown(ioc);\n\t_scsih_nvme_shutdown(ioc);\n\tmpt3sas_base_mask_interrupts(ioc);\n\tmpt3sas_base_stop_watchdog(ioc);\n\tioc->shost_recovery = 1;\n\tmpt3sas_base_make_ioc_ready(ioc, SOFT_RESET);\n\tioc->shost_recovery = 0;\n\tmpt3sas_base_free_irq(ioc);\n\tmpt3sas_base_disable_msix(ioc);\n}\n\n\n \nstatic void\n_scsih_probe_boot_devices(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 channel;\n\tvoid *device;\n\tstruct _sas_device *sas_device;\n\tstruct _raid_device *raid_device;\n\tstruct _pcie_device *pcie_device;\n\tu16 handle;\n\tu64 sas_address_parent;\n\tu64 sas_address;\n\tunsigned long flags;\n\tint rc;\n\tint tid;\n\tstruct hba_port *port;\n\n\t  \n\tif (!ioc->bios_pg3.BiosVersion)\n\t\treturn;\n\n\tdevice = NULL;\n\tif (ioc->req_boot_device.device) {\n\t\tdevice =  ioc->req_boot_device.device;\n\t\tchannel = ioc->req_boot_device.channel;\n\t} else if (ioc->req_alt_boot_device.device) {\n\t\tdevice =  ioc->req_alt_boot_device.device;\n\t\tchannel = ioc->req_alt_boot_device.channel;\n\t} else if (ioc->current_boot_device.device) {\n\t\tdevice =  ioc->current_boot_device.device;\n\t\tchannel = ioc->current_boot_device.channel;\n\t}\n\n\tif (!device)\n\t\treturn;\n\n\tif (channel == RAID_CHANNEL) {\n\t\traid_device = device;\n\t\t \n\t\tif (raid_device->starget)\n\t\t\treturn;\n\t\trc = scsi_add_device(ioc->shost, RAID_CHANNEL,\n\t\t    raid_device->id, 0);\n\t\tif (rc)\n\t\t\t_scsih_raid_device_remove(ioc, raid_device);\n\t} else if (channel == PCIE_CHANNEL) {\n\t\tpcie_device = device;\n\t\t \n\t\tif (pcie_device->starget)\n\t\t\treturn;\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\ttid = pcie_device->id;\n\t\tlist_move_tail(&pcie_device->list, &ioc->pcie_device_list);\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\trc = scsi_add_device(ioc->shost, PCIE_CHANNEL, tid, 0);\n\t\tif (rc)\n\t\t\t_scsih_pcie_device_remove(ioc, pcie_device);\n\t} else {\n\t\tsas_device = device;\n\t\t \n\t\tif (sas_device->starget)\n\t\t\treturn;\n\t\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\t\thandle = sas_device->handle;\n\t\tsas_address_parent = sas_device->sas_address_parent;\n\t\tsas_address = sas_device->sas_address;\n\t\tport = sas_device->port;\n\t\tlist_move_tail(&sas_device->list, &ioc->sas_device_list);\n\t\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\t\tif (ioc->hide_drives)\n\t\t\treturn;\n\n\t\tif (!port)\n\t\t\treturn;\n\n\t\tif (!mpt3sas_transport_port_add(ioc, handle,\n\t\t    sas_address_parent, port)) {\n\t\t\t_scsih_sas_device_remove(ioc, sas_device);\n\t\t} else if (!sas_device->starget) {\n\t\t\tif (!ioc->is_driver_loading) {\n\t\t\t\tmpt3sas_transport_port_remove(ioc,\n\t\t\t\t    sas_address,\n\t\t\t\t    sas_address_parent, port);\n\t\t\t\t_scsih_sas_device_remove(ioc, sas_device);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void\n_scsih_probe_raid(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _raid_device *raid_device, *raid_next;\n\tint rc;\n\n\tlist_for_each_entry_safe(raid_device, raid_next,\n\t    &ioc->raid_device_list, list) {\n\t\tif (raid_device->starget)\n\t\t\tcontinue;\n\t\trc = scsi_add_device(ioc->shost, RAID_CHANNEL,\n\t\t    raid_device->id, 0);\n\t\tif (rc)\n\t\t\t_scsih_raid_device_remove(ioc, raid_device);\n\t}\n}\n\nstatic struct _sas_device *get_next_sas_device(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _sas_device *sas_device = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tif (!list_empty(&ioc->sas_device_init_list)) {\n\t\tsas_device = list_first_entry(&ioc->sas_device_init_list,\n\t\t\t\tstruct _sas_device, list);\n\t\tsas_device_get(sas_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\treturn sas_device;\n}\n\nstatic void sas_device_make_active(struct MPT3SAS_ADAPTER *ioc,\n\t\tstruct _sas_device *sas_device)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\n\t \n\tif (!list_empty(&sas_device->list)) {\n\t\tlist_del_init(&sas_device->list);\n\t\tsas_device_put(sas_device);\n\t}\n\n\tsas_device_get(sas_device);\n\tlist_add_tail(&sas_device->list, &ioc->sas_device_list);\n\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n}\n\n \nstatic void\n_scsih_probe_sas(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _sas_device *sas_device;\n\n\tif (ioc->hide_drives)\n\t\treturn;\n\n\twhile ((sas_device = get_next_sas_device(ioc))) {\n\t\tif (!mpt3sas_transport_port_add(ioc, sas_device->handle,\n\t\t    sas_device->sas_address_parent, sas_device->port)) {\n\t\t\t_scsih_sas_device_remove(ioc, sas_device);\n\t\t\tsas_device_put(sas_device);\n\t\t\tcontinue;\n\t\t} else if (!sas_device->starget) {\n\t\t\t \n\t\t\tif (!ioc->is_driver_loading) {\n\t\t\t\tmpt3sas_transport_port_remove(ioc,\n\t\t\t\t    sas_device->sas_address,\n\t\t\t\t    sas_device->sas_address_parent,\n\t\t\t\t    sas_device->port);\n\t\t\t\t_scsih_sas_device_remove(ioc, sas_device);\n\t\t\t\tsas_device_put(sas_device);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tsas_device_make_active(ioc, sas_device);\n\t\tsas_device_put(sas_device);\n\t}\n}\n\n \nstatic struct _pcie_device *get_next_pcie_device(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _pcie_device *pcie_device = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tif (!list_empty(&ioc->pcie_device_init_list)) {\n\t\tpcie_device = list_first_entry(&ioc->pcie_device_init_list,\n\t\t\t\tstruct _pcie_device, list);\n\t\tpcie_device_get(pcie_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\treturn pcie_device;\n}\n\n \nstatic void pcie_device_make_active(struct MPT3SAS_ADAPTER *ioc,\n\t\tstruct _pcie_device *pcie_device)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\n\tif (!list_empty(&pcie_device->list)) {\n\t\tlist_del_init(&pcie_device->list);\n\t\tpcie_device_put(pcie_device);\n\t}\n\tpcie_device_get(pcie_device);\n\tlist_add_tail(&pcie_device->list, &ioc->pcie_device_list);\n\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n}\n\n \nstatic void\n_scsih_probe_pcie(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _pcie_device *pcie_device;\n\tint rc;\n\n\t \n\twhile ((pcie_device = get_next_pcie_device(ioc))) {\n\t\tif (pcie_device->starget) {\n\t\t\tpcie_device_put(pcie_device);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pcie_device->access_status ==\n\t\t    MPI26_PCIEDEV0_ASTATUS_DEVICE_BLOCKED) {\n\t\t\tpcie_device_make_active(ioc, pcie_device);\n\t\t\tpcie_device_put(pcie_device);\n\t\t\tcontinue;\n\t\t}\n\t\trc = scsi_add_device(ioc->shost, PCIE_CHANNEL,\n\t\t\tpcie_device->id, 0);\n\t\tif (rc) {\n\t\t\t_scsih_pcie_device_remove(ioc, pcie_device);\n\t\t\tpcie_device_put(pcie_device);\n\t\t\tcontinue;\n\t\t} else if (!pcie_device->starget) {\n\t\t\t \n\t\t\tif (!ioc->is_driver_loading) {\n\t\t\t \n\t\t\t\t_scsih_pcie_device_remove(ioc, pcie_device);\n\t\t\t\tpcie_device_put(pcie_device);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tpcie_device_make_active(ioc, pcie_device);\n\t\tpcie_device_put(pcie_device);\n\t}\n}\n\n \nstatic void\n_scsih_probe_devices(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu16 volume_mapping_flags;\n\n\tif (!(ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_SCSI_INITIATOR))\n\t\treturn;   \n\n\t_scsih_probe_boot_devices(ioc);\n\n\tif (ioc->ir_firmware) {\n\t\tvolume_mapping_flags =\n\t\t    le16_to_cpu(ioc->ioc_pg8.IRVolumeMappingFlags) &\n\t\t    MPI2_IOCPAGE8_IRFLAGS_MASK_VOLUME_MAPPING_MODE;\n\t\tif (volume_mapping_flags ==\n\t\t    MPI2_IOCPAGE8_IRFLAGS_LOW_VOLUME_MAPPING) {\n\t\t\t_scsih_probe_raid(ioc);\n\t\t\t_scsih_probe_sas(ioc);\n\t\t} else {\n\t\t\t_scsih_probe_sas(ioc);\n\t\t\t_scsih_probe_raid(ioc);\n\t\t}\n\t} else {\n\t\t_scsih_probe_sas(ioc);\n\t\t_scsih_probe_pcie(ioc);\n\t}\n}\n\n \nstatic void\nscsih_scan_start(struct Scsi_Host *shost)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tint rc;\n\tif (diag_buffer_enable != -1 && diag_buffer_enable != 0)\n\t\tmpt3sas_enable_diag_buffer(ioc, diag_buffer_enable);\n\telse if (ioc->manu_pg11.HostTraceBufferMaxSizeKB != 0)\n\t\tmpt3sas_enable_diag_buffer(ioc, 1);\n\n\tif (disable_discovery > 0)\n\t\treturn;\n\n\tioc->start_scan = 1;\n\trc = mpt3sas_port_enable(ioc);\n\n\tif (rc != 0)\n\t\tioc_info(ioc, \"port enable: FAILED\\n\");\n}\n\n \nstatic void _scsih_complete_devices_scanning(struct MPT3SAS_ADAPTER *ioc)\n{\n\n\tif (ioc->wait_for_discovery_to_complete) {\n\t\tioc->wait_for_discovery_to_complete = 0;\n\t\t_scsih_probe_devices(ioc);\n\t}\n\n\tmpt3sas_base_start_watchdog(ioc);\n\tioc->is_driver_loading = 0;\n}\n\n \nstatic int\nscsih_scan_finished(struct Scsi_Host *shost, unsigned long time)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tu32 ioc_state;\n\tint issue_hard_reset = 0;\n\n\tif (disable_discovery > 0) {\n\t\tioc->is_driver_loading = 0;\n\t\tioc->wait_for_discovery_to_complete = 0;\n\t\treturn 1;\n\t}\n\n\tif (time >= (300 * HZ)) {\n\t\tioc->port_enable_cmds.status = MPT3_CMD_NOT_USED;\n\t\tioc_info(ioc, \"port enable: FAILED with timeout (timeout=300s)\\n\");\n\t\tioc->is_driver_loading = 0;\n\t\treturn 1;\n\t}\n\n\tif (ioc->start_scan) {\n\t\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\t\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {\n\t\t\tmpt3sas_print_fault_code(ioc, ioc_state &\n\t\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\t\tissue_hard_reset = 1;\n\t\t\tgoto out;\n\t\t} else if ((ioc_state & MPI2_IOC_STATE_MASK) ==\n\t\t\t\tMPI2_IOC_STATE_COREDUMP) {\n\t\t\tmpt3sas_base_coredump_info(ioc, ioc_state &\n\t\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\t\tmpt3sas_base_wait_for_coredump_completion(ioc, __func__);\n\t\t\tissue_hard_reset = 1;\n\t\t\tgoto out;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (ioc->port_enable_cmds.status & MPT3_CMD_RESET) {\n\t\tioc_info(ioc,\n\t\t    \"port enable: aborted due to diag reset\\n\");\n\t\tioc->port_enable_cmds.status = MPT3_CMD_NOT_USED;\n\t\tgoto out;\n\t}\n\tif (ioc->start_scan_failed) {\n\t\tioc_info(ioc, \"port enable: FAILED with (ioc_status=0x%08x)\\n\",\n\t\t\t ioc->start_scan_failed);\n\t\tioc->is_driver_loading = 0;\n\t\tioc->wait_for_discovery_to_complete = 0;\n\t\tioc->remove_host = 1;\n\t\treturn 1;\n\t}\n\n\tioc_info(ioc, \"port enable: SUCCESS\\n\");\n\tioc->port_enable_cmds.status = MPT3_CMD_NOT_USED;\n\t_scsih_complete_devices_scanning(ioc);\n\nout:\n\tif (issue_hard_reset) {\n\t\tioc->port_enable_cmds.status = MPT3_CMD_NOT_USED;\n\t\tif (mpt3sas_base_hard_reset_handler(ioc, SOFT_RESET))\n\t\t\tioc->is_driver_loading = 0;\n\t}\n\treturn 1;\n}\n\n \nstatic void scsih_map_queues(struct Scsi_Host *shost)\n{\n\tstruct MPT3SAS_ADAPTER *ioc =\n\t    (struct MPT3SAS_ADAPTER *)shost->hostdata;\n\tstruct blk_mq_queue_map *map;\n\tint i, qoff, offset;\n\tint nr_msix_vectors = ioc->iopoll_q_start_index;\n\tint iopoll_q_count = ioc->reply_queue_count - nr_msix_vectors;\n\n\tif (shost->nr_hw_queues == 1)\n\t\treturn;\n\n\tfor (i = 0, qoff = 0; i < shost->nr_maps; i++) {\n\t\tmap = &shost->tag_set.map[i];\n\t\tmap->nr_queues = 0;\n\t\toffset = 0;\n\t\tif (i == HCTX_TYPE_DEFAULT) {\n\t\t\tmap->nr_queues =\n\t\t\t    nr_msix_vectors - ioc->high_iops_queues;\n\t\t\toffset = ioc->high_iops_queues;\n\t\t} else if (i == HCTX_TYPE_POLL)\n\t\t\tmap->nr_queues = iopoll_q_count;\n\n\t\tif (!map->nr_queues)\n\t\t\tBUG_ON(i == HCTX_TYPE_DEFAULT);\n\n\t\t \n\t\tmap->queue_offset = qoff;\n\t\tif (i != HCTX_TYPE_POLL)\n\t\t\tblk_mq_pci_map_queues(map, ioc->pdev, offset);\n\t\telse\n\t\t\tblk_mq_map_queues(map);\n\n\t\tqoff += map->nr_queues;\n\t}\n}\n\n \nstatic const struct scsi_host_template mpt2sas_driver_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.name\t\t\t\t= \"Fusion MPT SAS Host\",\n\t.proc_name\t\t\t= MPT2SAS_DRIVER_NAME,\n\t.queuecommand\t\t\t= scsih_qcmd,\n\t.target_alloc\t\t\t= scsih_target_alloc,\n\t.slave_alloc\t\t\t= scsih_slave_alloc,\n\t.slave_configure\t\t= scsih_slave_configure,\n\t.target_destroy\t\t\t= scsih_target_destroy,\n\t.slave_destroy\t\t\t= scsih_slave_destroy,\n\t.scan_finished\t\t\t= scsih_scan_finished,\n\t.scan_start\t\t\t= scsih_scan_start,\n\t.change_queue_depth\t\t= scsih_change_queue_depth,\n\t.eh_abort_handler\t\t= scsih_abort,\n\t.eh_device_reset_handler\t= scsih_dev_reset,\n\t.eh_target_reset_handler\t= scsih_target_reset,\n\t.eh_host_reset_handler\t\t= scsih_host_reset,\n\t.bios_param\t\t\t= scsih_bios_param,\n\t.can_queue\t\t\t= 1,\n\t.this_id\t\t\t= -1,\n\t.sg_tablesize\t\t\t= MPT2SAS_SG_DEPTH,\n\t.max_sectors\t\t\t= 32767,\n\t.cmd_per_lun\t\t\t= 7,\n\t.shost_groups\t\t\t= mpt3sas_host_groups,\n\t.sdev_groups\t\t\t= mpt3sas_dev_groups,\n\t.track_queue_depth\t\t= 1,\n\t.cmd_size\t\t\t= sizeof(struct scsiio_tracker),\n};\n\n \nstatic struct raid_function_template mpt2sas_raid_functions = {\n\t.cookie\t\t= &mpt2sas_driver_template,\n\t.is_raid\t= scsih_is_raid,\n\t.get_resync\t= scsih_get_resync,\n\t.get_state\t= scsih_get_state,\n};\n\n \nstatic const struct scsi_host_template mpt3sas_driver_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.name\t\t\t\t= \"Fusion MPT SAS Host\",\n\t.proc_name\t\t\t= MPT3SAS_DRIVER_NAME,\n\t.queuecommand\t\t\t= scsih_qcmd,\n\t.target_alloc\t\t\t= scsih_target_alloc,\n\t.slave_alloc\t\t\t= scsih_slave_alloc,\n\t.slave_configure\t\t= scsih_slave_configure,\n\t.target_destroy\t\t\t= scsih_target_destroy,\n\t.slave_destroy\t\t\t= scsih_slave_destroy,\n\t.scan_finished\t\t\t= scsih_scan_finished,\n\t.scan_start\t\t\t= scsih_scan_start,\n\t.change_queue_depth\t\t= scsih_change_queue_depth,\n\t.eh_abort_handler\t\t= scsih_abort,\n\t.eh_device_reset_handler\t= scsih_dev_reset,\n\t.eh_target_reset_handler\t= scsih_target_reset,\n\t.eh_host_reset_handler\t\t= scsih_host_reset,\n\t.bios_param\t\t\t= scsih_bios_param,\n\t.can_queue\t\t\t= 1,\n\t.this_id\t\t\t= -1,\n\t.sg_tablesize\t\t\t= MPT3SAS_SG_DEPTH,\n\t.max_sectors\t\t\t= 32767,\n\t.max_segment_size\t\t= 0xffffffff,\n\t.cmd_per_lun\t\t\t= 128,\n\t.shost_groups\t\t\t= mpt3sas_host_groups,\n\t.sdev_groups\t\t\t= mpt3sas_dev_groups,\n\t.track_queue_depth\t\t= 1,\n\t.cmd_size\t\t\t= sizeof(struct scsiio_tracker),\n\t.map_queues\t\t\t= scsih_map_queues,\n\t.mq_poll\t\t\t= mpt3sas_blk_mq_poll,\n};\n\n \nstatic struct raid_function_template mpt3sas_raid_functions = {\n\t.cookie\t\t= &mpt3sas_driver_template,\n\t.is_raid\t= scsih_is_raid,\n\t.get_resync\t= scsih_get_resync,\n\t.get_state\t= scsih_get_state,\n};\n\n \nstatic u16\n_scsih_determine_hba_mpi_version(struct pci_dev *pdev)\n{\n\n\tswitch (pdev->device) {\n\tcase MPI2_MFGPAGE_DEVID_SSS6200:\n\tcase MPI2_MFGPAGE_DEVID_SAS2004:\n\tcase MPI2_MFGPAGE_DEVID_SAS2008:\n\tcase MPI2_MFGPAGE_DEVID_SAS2108_1:\n\tcase MPI2_MFGPAGE_DEVID_SAS2108_2:\n\tcase MPI2_MFGPAGE_DEVID_SAS2108_3:\n\tcase MPI2_MFGPAGE_DEVID_SAS2116_1:\n\tcase MPI2_MFGPAGE_DEVID_SAS2116_2:\n\tcase MPI2_MFGPAGE_DEVID_SAS2208_1:\n\tcase MPI2_MFGPAGE_DEVID_SAS2208_2:\n\tcase MPI2_MFGPAGE_DEVID_SAS2208_3:\n\tcase MPI2_MFGPAGE_DEVID_SAS2208_4:\n\tcase MPI2_MFGPAGE_DEVID_SAS2208_5:\n\tcase MPI2_MFGPAGE_DEVID_SAS2208_6:\n\tcase MPI2_MFGPAGE_DEVID_SAS2308_1:\n\tcase MPI2_MFGPAGE_DEVID_SAS2308_2:\n\tcase MPI2_MFGPAGE_DEVID_SAS2308_3:\n\tcase MPI2_MFGPAGE_DEVID_SWITCH_MPI_EP:\n\tcase MPI2_MFGPAGE_DEVID_SWITCH_MPI_EP_1:\n\t\treturn MPI2_VERSION;\n\tcase MPI25_MFGPAGE_DEVID_SAS3004:\n\tcase MPI25_MFGPAGE_DEVID_SAS3008:\n\tcase MPI25_MFGPAGE_DEVID_SAS3108_1:\n\tcase MPI25_MFGPAGE_DEVID_SAS3108_2:\n\tcase MPI25_MFGPAGE_DEVID_SAS3108_5:\n\tcase MPI25_MFGPAGE_DEVID_SAS3108_6:\n\t\treturn MPI25_VERSION;\n\tcase MPI26_MFGPAGE_DEVID_SAS3216:\n\tcase MPI26_MFGPAGE_DEVID_SAS3224:\n\tcase MPI26_MFGPAGE_DEVID_SAS3316_1:\n\tcase MPI26_MFGPAGE_DEVID_SAS3316_2:\n\tcase MPI26_MFGPAGE_DEVID_SAS3316_3:\n\tcase MPI26_MFGPAGE_DEVID_SAS3316_4:\n\tcase MPI26_MFGPAGE_DEVID_SAS3324_1:\n\tcase MPI26_MFGPAGE_DEVID_SAS3324_2:\n\tcase MPI26_MFGPAGE_DEVID_SAS3324_3:\n\tcase MPI26_MFGPAGE_DEVID_SAS3324_4:\n\tcase MPI26_MFGPAGE_DEVID_SAS3508:\n\tcase MPI26_MFGPAGE_DEVID_SAS3508_1:\n\tcase MPI26_MFGPAGE_DEVID_SAS3408:\n\tcase MPI26_MFGPAGE_DEVID_SAS3516:\n\tcase MPI26_MFGPAGE_DEVID_SAS3516_1:\n\tcase MPI26_MFGPAGE_DEVID_SAS3416:\n\tcase MPI26_MFGPAGE_DEVID_SAS3616:\n\tcase MPI26_ATLAS_PCIe_SWITCH_DEVID:\n\tcase MPI26_MFGPAGE_DEVID_CFG_SEC_3916:\n\tcase MPI26_MFGPAGE_DEVID_HARD_SEC_3916:\n\tcase MPI26_MFGPAGE_DEVID_CFG_SEC_3816:\n\tcase MPI26_MFGPAGE_DEVID_HARD_SEC_3816:\n\tcase MPI26_MFGPAGE_DEVID_INVALID0_3916:\n\tcase MPI26_MFGPAGE_DEVID_INVALID1_3916:\n\tcase MPI26_MFGPAGE_DEVID_INVALID0_3816:\n\tcase MPI26_MFGPAGE_DEVID_INVALID1_3816:\n\t\treturn MPI26_VERSION;\n\t}\n\treturn 0;\n}\n\n \nstatic int\n_scsih_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tstruct Scsi_Host *shost = NULL;\n\tint rv;\n\tu16 hba_mpi_version;\n\tint iopoll_q_count = 0;\n\n\t \n\thba_mpi_version = _scsih_determine_hba_mpi_version(pdev);\n\tif (hba_mpi_version == 0)\n\t\treturn -ENODEV;\n\n\t \n\tif ((hbas_to_enumerate == 1) && (hba_mpi_version !=  MPI2_VERSION))\n\t\treturn -ENODEV;\n\n\t \n\tif ((hbas_to_enumerate == 2) && (!(hba_mpi_version ==  MPI25_VERSION\n\t\t|| hba_mpi_version ==  MPI26_VERSION)))\n\t\treturn -ENODEV;\n\n\tswitch (hba_mpi_version) {\n\tcase MPI2_VERSION:\n\t\tpci_disable_link_state(pdev, PCIE_LINK_STATE_L0S |\n\t\t\tPCIE_LINK_STATE_L1 | PCIE_LINK_STATE_CLKPM);\n\t\t \n\t\tshost = scsi_host_alloc(&mpt2sas_driver_template,\n\t\t  sizeof(struct MPT3SAS_ADAPTER));\n\t\tif (!shost)\n\t\t\treturn -ENODEV;\n\t\tioc = shost_priv(shost);\n\t\tmemset(ioc, 0, sizeof(struct MPT3SAS_ADAPTER));\n\t\tioc->hba_mpi_version_belonged = hba_mpi_version;\n\t\tioc->id = mpt2_ids++;\n\t\tsprintf(ioc->driver_name, \"%s\", MPT2SAS_DRIVER_NAME);\n\t\tswitch (pdev->device) {\n\t\tcase MPI2_MFGPAGE_DEVID_SSS6200:\n\t\t\tioc->is_warpdrive = 1;\n\t\t\tioc->hide_ir_msg = 1;\n\t\t\tbreak;\n\t\tcase MPI2_MFGPAGE_DEVID_SWITCH_MPI_EP:\n\t\tcase MPI2_MFGPAGE_DEVID_SWITCH_MPI_EP_1:\n\t\t\tioc->is_mcpu_endpoint = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tioc->mfg_pg10_hide_flag = MFG_PAGE10_EXPOSE_ALL_DISKS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (multipath_on_hba == -1 || multipath_on_hba == 0)\n\t\t\tioc->multipath_on_hba = 0;\n\t\telse\n\t\t\tioc->multipath_on_hba = 1;\n\n\t\tbreak;\n\tcase MPI25_VERSION:\n\tcase MPI26_VERSION:\n\t\t \n\t\tshost = scsi_host_alloc(&mpt3sas_driver_template,\n\t\t  sizeof(struct MPT3SAS_ADAPTER));\n\t\tif (!shost)\n\t\t\treturn -ENODEV;\n\t\tioc = shost_priv(shost);\n\t\tmemset(ioc, 0, sizeof(struct MPT3SAS_ADAPTER));\n\t\tioc->hba_mpi_version_belonged = hba_mpi_version;\n\t\tioc->id = mpt3_ids++;\n\t\tsprintf(ioc->driver_name, \"%s\", MPT3SAS_DRIVER_NAME);\n\t\tswitch (pdev->device) {\n\t\tcase MPI26_MFGPAGE_DEVID_SAS3508:\n\t\tcase MPI26_MFGPAGE_DEVID_SAS3508_1:\n\t\tcase MPI26_MFGPAGE_DEVID_SAS3408:\n\t\tcase MPI26_MFGPAGE_DEVID_SAS3516:\n\t\tcase MPI26_MFGPAGE_DEVID_SAS3516_1:\n\t\tcase MPI26_MFGPAGE_DEVID_SAS3416:\n\t\tcase MPI26_MFGPAGE_DEVID_SAS3616:\n\t\tcase MPI26_ATLAS_PCIe_SWITCH_DEVID:\n\t\t\tioc->is_gen35_ioc = 1;\n\t\t\tbreak;\n\t\tcase MPI26_MFGPAGE_DEVID_INVALID0_3816:\n\t\tcase MPI26_MFGPAGE_DEVID_INVALID0_3916:\n\t\t\tdev_err(&pdev->dev,\n\t\t\t    \"HBA with DeviceId 0x%04x, sub VendorId 0x%04x, sub DeviceId 0x%04x is Invalid\",\n\t\t\t    pdev->device, pdev->subsystem_vendor,\n\t\t\t    pdev->subsystem_device);\n\t\t\treturn 1;\n\t\tcase MPI26_MFGPAGE_DEVID_INVALID1_3816:\n\t\tcase MPI26_MFGPAGE_DEVID_INVALID1_3916:\n\t\t\tdev_err(&pdev->dev,\n\t\t\t    \"HBA with DeviceId 0x%04x, sub VendorId 0x%04x, sub DeviceId 0x%04x is Tampered\",\n\t\t\t    pdev->device, pdev->subsystem_vendor,\n\t\t\t    pdev->subsystem_device);\n\t\t\treturn 1;\n\t\tcase MPI26_MFGPAGE_DEVID_CFG_SEC_3816:\n\t\tcase MPI26_MFGPAGE_DEVID_CFG_SEC_3916:\n\t\t\tdev_info(&pdev->dev,\n\t\t\t    \"HBA is in Configurable Secure mode\\n\");\n\t\t\tfallthrough;\n\t\tcase MPI26_MFGPAGE_DEVID_HARD_SEC_3816:\n\t\tcase MPI26_MFGPAGE_DEVID_HARD_SEC_3916:\n\t\t\tioc->is_aero_ioc = ioc->is_gen35_ioc = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tioc->is_gen35_ioc = ioc->is_aero_ioc = 0;\n\t\t}\n\t\tif ((ioc->hba_mpi_version_belonged == MPI25_VERSION &&\n\t\t\tpdev->revision >= SAS3_PCI_DEVICE_C0_REVISION) ||\n\t\t\t(ioc->hba_mpi_version_belonged == MPI26_VERSION)) {\n\t\t\tioc->combined_reply_queue = 1;\n\t\t\tif (ioc->is_gen35_ioc)\n\t\t\t\tioc->combined_reply_index_count =\n\t\t\t\t MPT3_SUP_REPLY_POST_HOST_INDEX_REG_COUNT_G35;\n\t\t\telse\n\t\t\t\tioc->combined_reply_index_count =\n\t\t\t\t MPT3_SUP_REPLY_POST_HOST_INDEX_REG_COUNT_G3;\n\t\t}\n\n\t\tswitch (ioc->is_gen35_ioc) {\n\t\tcase 0:\n\t\t\tif (multipath_on_hba == -1 || multipath_on_hba == 0)\n\t\t\t\tioc->multipath_on_hba = 0;\n\t\t\telse\n\t\t\t\tioc->multipath_on_hba = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (multipath_on_hba == -1 || multipath_on_hba > 0)\n\t\t\t\tioc->multipath_on_hba = 1;\n\t\t\telse\n\t\t\t\tioc->multipath_on_hba = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tINIT_LIST_HEAD(&ioc->list);\n\tspin_lock(&gioc_lock);\n\tlist_add_tail(&ioc->list, &mpt3sas_ioc_list);\n\tspin_unlock(&gioc_lock);\n\tioc->shost = shost;\n\tioc->pdev = pdev;\n\tioc->scsi_io_cb_idx = scsi_io_cb_idx;\n\tioc->tm_cb_idx = tm_cb_idx;\n\tioc->ctl_cb_idx = ctl_cb_idx;\n\tioc->base_cb_idx = base_cb_idx;\n\tioc->port_enable_cb_idx = port_enable_cb_idx;\n\tioc->transport_cb_idx = transport_cb_idx;\n\tioc->scsih_cb_idx = scsih_cb_idx;\n\tioc->config_cb_idx = config_cb_idx;\n\tioc->tm_tr_cb_idx = tm_tr_cb_idx;\n\tioc->tm_tr_volume_cb_idx = tm_tr_volume_cb_idx;\n\tioc->tm_sas_control_cb_idx = tm_sas_control_cb_idx;\n\tioc->logging_level = logging_level;\n\tioc->schedule_dead_ioc_flush_running_cmds = &_scsih_flush_running_cmds;\n\t \n\tioc->max_shutdown_latency = IO_UNIT_CONTROL_SHUTDOWN_TIMEOUT;\n\t \n\tioc->drv_support_bitmap |= MPT_DRV_SUPPORT_BITMAP_MEMMOVE;\n\t \n\tioc->drv_support_bitmap |= MPT_DRV_SUPPORT_BITMAP_ADDNLQUERY;\n\n\tioc->enable_sdev_max_qd = enable_sdev_max_qd;\n\n\t \n\tmutex_init(&ioc->reset_in_progress_mutex);\n\t \n\tmutex_init(&ioc->pci_access_mutex);\n\tspin_lock_init(&ioc->ioc_reset_in_progress_lock);\n\tspin_lock_init(&ioc->scsi_lookup_lock);\n\tspin_lock_init(&ioc->sas_device_lock);\n\tspin_lock_init(&ioc->sas_node_lock);\n\tspin_lock_init(&ioc->fw_event_lock);\n\tspin_lock_init(&ioc->raid_device_lock);\n\tspin_lock_init(&ioc->pcie_device_lock);\n\tspin_lock_init(&ioc->diag_trigger_lock);\n\n\tINIT_LIST_HEAD(&ioc->sas_device_list);\n\tINIT_LIST_HEAD(&ioc->sas_device_init_list);\n\tINIT_LIST_HEAD(&ioc->sas_expander_list);\n\tINIT_LIST_HEAD(&ioc->enclosure_list);\n\tINIT_LIST_HEAD(&ioc->pcie_device_list);\n\tINIT_LIST_HEAD(&ioc->pcie_device_init_list);\n\tINIT_LIST_HEAD(&ioc->fw_event_list);\n\tINIT_LIST_HEAD(&ioc->raid_device_list);\n\tINIT_LIST_HEAD(&ioc->sas_hba.sas_port_list);\n\tINIT_LIST_HEAD(&ioc->delayed_tr_list);\n\tINIT_LIST_HEAD(&ioc->delayed_sc_list);\n\tINIT_LIST_HEAD(&ioc->delayed_event_ack_list);\n\tINIT_LIST_HEAD(&ioc->delayed_tr_volume_list);\n\tINIT_LIST_HEAD(&ioc->reply_queue_list);\n\tINIT_LIST_HEAD(&ioc->port_table_list);\n\n\tsprintf(ioc->name, \"%s_cm%d\", ioc->driver_name, ioc->id);\n\n\t \n\tshost->max_cmd_len = 32;\n\tshost->max_lun = max_lun;\n\tshost->transportt = mpt3sas_transport_template;\n\tshost->unique_id = ioc->id;\n\n\tif (ioc->is_mcpu_endpoint) {\n\t\t \n\t\tshost->max_sectors = 128;\n\t\tioc_info(ioc, \"The max_sectors value is set to %d\\n\",\n\t\t\t shost->max_sectors);\n\t} else {\n\t\tif (max_sectors != 0xFFFF) {\n\t\t\tif (max_sectors < 64) {\n\t\t\t\tshost->max_sectors = 64;\n\t\t\t\tioc_warn(ioc, \"Invalid value %d passed for max_sectors, range is 64 to 32767. Assigning value of 64.\\n\",\n\t\t\t\t\t max_sectors);\n\t\t\t} else if (max_sectors > 32767) {\n\t\t\t\tshost->max_sectors = 32767;\n\t\t\t\tioc_warn(ioc, \"Invalid value %d passed for max_sectors, range is 64 to 32767.Assigning default value of 32767.\\n\",\n\t\t\t\t\t max_sectors);\n\t\t\t} else {\n\t\t\t\tshost->max_sectors = max_sectors & 0xFFFE;\n\t\t\t\tioc_info(ioc, \"The max_sectors value is set to %d\\n\",\n\t\t\t\t\t shost->max_sectors);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (prot_mask >= 0)\n\t\tscsi_host_set_prot(shost, (prot_mask & 0x07));\n\telse\n\t\tscsi_host_set_prot(shost, SHOST_DIF_TYPE1_PROTECTION\n\t\t\t\t   | SHOST_DIF_TYPE2_PROTECTION\n\t\t\t\t   | SHOST_DIF_TYPE3_PROTECTION);\n\n\tscsi_host_set_guard(shost, SHOST_DIX_GUARD_CRC);\n\n\t \n\tsnprintf(ioc->firmware_event_name, sizeof(ioc->firmware_event_name),\n\t    \"fw_event_%s%d\", ioc->driver_name, ioc->id);\n\tioc->firmware_event_thread = alloc_ordered_workqueue(\n\t    ioc->firmware_event_name, 0);\n\tif (!ioc->firmware_event_thread) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trv = -ENODEV;\n\t\tgoto out_thread_fail;\n\t}\n\n\tshost->host_tagset = 0;\n\n\tif (ioc->is_gen35_ioc && host_tagset_enable)\n\t\tshost->host_tagset = 1;\n\n\tioc->is_driver_loading = 1;\n\tif ((mpt3sas_base_attach(ioc))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trv = -ENODEV;\n\t\tgoto out_attach_fail;\n\t}\n\n\tif (ioc->is_warpdrive) {\n\t\tif (ioc->mfg_pg10_hide_flag ==  MFG_PAGE10_EXPOSE_ALL_DISKS)\n\t\t\tioc->hide_drives = 0;\n\t\telse if (ioc->mfg_pg10_hide_flag ==  MFG_PAGE10_HIDE_ALL_DISKS)\n\t\t\tioc->hide_drives = 1;\n\t\telse {\n\t\t\tif (mpt3sas_get_num_volumes(ioc))\n\t\t\t\tioc->hide_drives = 1;\n\t\t\telse\n\t\t\t\tioc->hide_drives = 0;\n\t\t}\n\t} else\n\t\tioc->hide_drives = 0;\n\n\tshost->nr_hw_queues = 1;\n\n\tif (shost->host_tagset) {\n\t\tshost->nr_hw_queues =\n\t\t    ioc->reply_queue_count - ioc->high_iops_queues;\n\n\t\tiopoll_q_count =\n\t\t    ioc->reply_queue_count - ioc->iopoll_q_start_index;\n\n\t\tshost->nr_maps = iopoll_q_count ? 3 : 1;\n\n\t\tdev_info(&ioc->pdev->dev,\n\t\t    \"Max SCSIIO MPT commands: %d shared with nr_hw_queues = %d\\n\",\n\t\t    shost->can_queue, shost->nr_hw_queues);\n\t}\n\n\trv = scsi_add_host(shost, &pdev->dev);\n\tif (rv) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out_add_shost_fail;\n\t}\n\n\tscsi_scan_host(shost);\n\tmpt3sas_setup_debugfs(ioc);\n\treturn 0;\nout_add_shost_fail:\n\tmpt3sas_base_detach(ioc);\n out_attach_fail:\n\tdestroy_workqueue(ioc->firmware_event_thread);\n out_thread_fail:\n\tspin_lock(&gioc_lock);\n\tlist_del(&ioc->list);\n\tspin_unlock(&gioc_lock);\n\tscsi_host_put(shost);\n\treturn rv;\n}\n\n \nstatic int __maybe_unused\nscsih_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tint rc;\n\n\trc = _scsih_get_shost_and_ioc(pdev, &shost, &ioc);\n\tif (rc)\n\t\treturn rc;\n\n\tmpt3sas_base_stop_watchdog(ioc);\n\tscsi_block_requests(shost);\n\t_scsih_nvme_shutdown(ioc);\n\tioc_info(ioc, \"pdev=0x%p, slot=%s, entering operating state\\n\",\n\t\t pdev, pci_name(pdev));\n\n\tmpt3sas_base_free_resources(ioc);\n\treturn 0;\n}\n\n \nstatic int __maybe_unused\nscsih_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tpci_power_t device_state = pdev->current_state;\n\tint r;\n\n\tr = _scsih_get_shost_and_ioc(pdev, &shost, &ioc);\n\tif (r)\n\t\treturn r;\n\n\tioc_info(ioc, \"pdev=0x%p, slot=%s, previous operating state [D%d]\\n\",\n\t\t pdev, pci_name(pdev), device_state);\n\n\tioc->pdev = pdev;\n\tr = mpt3sas_base_map_resources(ioc);\n\tif (r)\n\t\treturn r;\n\tioc_info(ioc, \"Issuing Hard Reset as part of OS Resume\\n\");\n\tmpt3sas_base_hard_reset_handler(ioc, SOFT_RESET);\n\tscsi_unblock_requests(shost);\n\tmpt3sas_base_start_watchdog(ioc);\n\treturn 0;\n}\n\n \nstatic pci_ers_result_t\nscsih_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\n\tif (_scsih_get_shost_and_ioc(pdev, &shost, &ioc))\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tioc_info(ioc, \"PCI error: detected callback, state(%d)!!\\n\", state);\n\n\tswitch (state) {\n\tcase pci_channel_io_normal:\n\t\treturn PCI_ERS_RESULT_CAN_RECOVER;\n\tcase pci_channel_io_frozen:\n\t\t \n\t\tioc->pci_error_recovery = 1;\n\t\tscsi_block_requests(ioc->shost);\n\t\tmpt3sas_base_stop_watchdog(ioc);\n\t\tmpt3sas_base_free_resources(ioc);\n\t\treturn PCI_ERS_RESULT_NEED_RESET;\n\tcase pci_channel_io_perm_failure:\n\t\t \n\t\tioc->pci_error_recovery = 1;\n\t\tmpt3sas_base_stop_watchdog(ioc);\n\t\tmpt3sas_base_pause_mq_polling(ioc);\n\t\t_scsih_flush_running_cmds(ioc);\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n \nstatic pci_ers_result_t\nscsih_pci_slot_reset(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tint rc;\n\n\tif (_scsih_get_shost_and_ioc(pdev, &shost, &ioc))\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tioc_info(ioc, \"PCI error: slot reset callback!!\\n\");\n\n\tioc->pci_error_recovery = 0;\n\tioc->pdev = pdev;\n\tpci_restore_state(pdev);\n\trc = mpt3sas_base_map_resources(ioc);\n\tif (rc)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tioc_info(ioc, \"Issuing Hard Reset as part of PCI Slot Reset\\n\");\n\trc = mpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\n\tioc_warn(ioc, \"hard reset: %s\\n\",\n\t\t (rc == 0) ? \"success\" : \"failed\");\n\n\tif (!rc)\n\t\treturn PCI_ERS_RESULT_RECOVERED;\n\telse\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n}\n\n \nstatic void\nscsih_pci_resume(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\n\tif (_scsih_get_shost_and_ioc(pdev, &shost, &ioc))\n\t\treturn;\n\n\tioc_info(ioc, \"PCI error: resume callback!!\\n\");\n\n\tmpt3sas_base_start_watchdog(ioc);\n\tscsi_unblock_requests(ioc->shost);\n}\n\n \nstatic pci_ers_result_t\nscsih_pci_mmio_enabled(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\n\tif (_scsih_get_shost_and_ioc(pdev, &shost, &ioc))\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tioc_info(ioc, \"PCI error: mmio enabled callback!!\\n\");\n\n\t \n\n\t \n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\n \nbool scsih_ncq_prio_supp(struct scsi_device *sdev)\n{\n\tstruct scsi_vpd *vpd;\n\tbool ncq_prio_supp = false;\n\n\trcu_read_lock();\n\tvpd = rcu_dereference(sdev->vpd_pg89);\n\tif (!vpd || vpd->len < 214)\n\t\tgoto out;\n\n\tncq_prio_supp = (vpd->data[213] >> 4) & 1;\nout:\n\trcu_read_unlock();\n\n\treturn ncq_prio_supp;\n}\n \nstatic const struct pci_device_id mpt3sas_pci_table[] = {\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2004,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2008,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2108_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2108_2,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2108_3,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2116_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2116_2,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_2,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_3,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_4,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_5,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_6,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2308_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2308_2,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2308_3,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SWITCH_MPI_EP,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SWITCH_MPI_EP_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SSS6200,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3004,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3008,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_2,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_5,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_6,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3216,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3224,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3316_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3316_2,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3316_3,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3316_4,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3324_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3324_2,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3324_3,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3324_4,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3508,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3508_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3408,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3516,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3516_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3416,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3616,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_CFG_SEC_3916,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_HARD_SEC_3916,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_INVALID0_3916,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_INVALID1_3916,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_ATLAS_PCIe_SWITCH_DEVID,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_CFG_SEC_3816,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_HARD_SEC_3816,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\n\t \n\t{ MPI2_MFGPAGE_VENDORID_ATTO, MPI26_MFGPAGE_DEVID_HARD_SEC_3816,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\n\t \n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_INVALID0_3816,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_INVALID1_3816,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\n\t{0}      \n};\nMODULE_DEVICE_TABLE(pci, mpt3sas_pci_table);\n\nstatic struct pci_error_handlers _mpt3sas_err_handler = {\n\t.error_detected\t= scsih_pci_error_detected,\n\t.mmio_enabled\t= scsih_pci_mmio_enabled,\n\t.slot_reset\t= scsih_pci_slot_reset,\n\t.resume\t\t= scsih_pci_resume,\n};\n\nstatic SIMPLE_DEV_PM_OPS(scsih_pm_ops, scsih_suspend, scsih_resume);\n\nstatic struct pci_driver mpt3sas_driver = {\n\t.name\t\t= MPT3SAS_DRIVER_NAME,\n\t.id_table\t= mpt3sas_pci_table,\n\t.probe\t\t= _scsih_probe,\n\t.remove\t\t= scsih_remove,\n\t.shutdown\t= scsih_shutdown,\n\t.err_handler\t= &_mpt3sas_err_handler,\n\t.driver.pm\t= &scsih_pm_ops,\n};\n\n \nstatic int\nscsih_init(void)\n{\n\tmpt2_ids = 0;\n\tmpt3_ids = 0;\n\n\tmpt3sas_base_initialize_callback_handler();\n\n\t  \n\tscsi_io_cb_idx = mpt3sas_base_register_callback_handler(_scsih_io_done);\n\n\t \n\ttm_cb_idx = mpt3sas_base_register_callback_handler(_scsih_tm_done);\n\n\t \n\tbase_cb_idx = mpt3sas_base_register_callback_handler(mpt3sas_base_done);\n\tport_enable_cb_idx = mpt3sas_base_register_callback_handler(\n\t    mpt3sas_port_enable_done);\n\n\t \n\ttransport_cb_idx = mpt3sas_base_register_callback_handler(\n\t    mpt3sas_transport_done);\n\n\t \n\tscsih_cb_idx = mpt3sas_base_register_callback_handler(_scsih_done);\n\n\t \n\tconfig_cb_idx = mpt3sas_base_register_callback_handler(\n\t    mpt3sas_config_done);\n\n\t \n\tctl_cb_idx = mpt3sas_base_register_callback_handler(mpt3sas_ctl_done);\n\n\ttm_tr_cb_idx = mpt3sas_base_register_callback_handler(\n\t    _scsih_tm_tr_complete);\n\n\ttm_tr_volume_cb_idx = mpt3sas_base_register_callback_handler(\n\t    _scsih_tm_volume_tr_complete);\n\n\ttm_sas_control_cb_idx = mpt3sas_base_register_callback_handler(\n\t    _scsih_sas_control_complete);\n\n\tmpt3sas_init_debugfs();\n\treturn 0;\n}\n\n \nstatic void\nscsih_exit(void)\n{\n\n\tmpt3sas_base_release_callback_handler(scsi_io_cb_idx);\n\tmpt3sas_base_release_callback_handler(tm_cb_idx);\n\tmpt3sas_base_release_callback_handler(base_cb_idx);\n\tmpt3sas_base_release_callback_handler(port_enable_cb_idx);\n\tmpt3sas_base_release_callback_handler(transport_cb_idx);\n\tmpt3sas_base_release_callback_handler(scsih_cb_idx);\n\tmpt3sas_base_release_callback_handler(config_cb_idx);\n\tmpt3sas_base_release_callback_handler(ctl_cb_idx);\n\n\tmpt3sas_base_release_callback_handler(tm_tr_cb_idx);\n\tmpt3sas_base_release_callback_handler(tm_tr_volume_cb_idx);\n\tmpt3sas_base_release_callback_handler(tm_sas_control_cb_idx);\n\n \n\tif (hbas_to_enumerate != 1)\n\t\traid_class_release(mpt3sas_raid_template);\n\tif (hbas_to_enumerate != 2)\n\t\traid_class_release(mpt2sas_raid_template);\n\tsas_release_transport(mpt3sas_transport_template);\n\tmpt3sas_exit_debugfs();\n}\n\n \nstatic int __init\n_mpt3sas_init(void)\n{\n\tint error;\n\n\tpr_info(\"%s version %s loaded\\n\", MPT3SAS_DRIVER_NAME,\n\t\t\t\t\tMPT3SAS_DRIVER_VERSION);\n\n\tmpt3sas_transport_template =\n\t    sas_attach_transport(&mpt3sas_transport_functions);\n\tif (!mpt3sas_transport_template)\n\t\treturn -ENODEV;\n\n\t \n\tif (hbas_to_enumerate != 1) {\n\t\tmpt3sas_raid_template =\n\t\t\t\traid_class_attach(&mpt3sas_raid_functions);\n\t\tif (!mpt3sas_raid_template) {\n\t\t\tsas_release_transport(mpt3sas_transport_template);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tif (hbas_to_enumerate != 2) {\n\t\tmpt2sas_raid_template =\n\t\t\t\traid_class_attach(&mpt2sas_raid_functions);\n\t\tif (!mpt2sas_raid_template) {\n\t\t\tsas_release_transport(mpt3sas_transport_template);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\terror = scsih_init();\n\tif (error) {\n\t\tscsih_exit();\n\t\treturn error;\n\t}\n\n\tmpt3sas_ctl_init(hbas_to_enumerate);\n\n\terror = pci_register_driver(&mpt3sas_driver);\n\tif (error) {\n\t\tmpt3sas_ctl_exit(hbas_to_enumerate);\n\t\tscsih_exit();\n\t}\n\n\treturn error;\n}\n\n \nstatic void __exit\n_mpt3sas_exit(void)\n{\n\tpr_info(\"mpt3sas version %s unloading\\n\",\n\t\t\t\tMPT3SAS_DRIVER_VERSION);\n\n\tpci_unregister_driver(&mpt3sas_driver);\n\n\tmpt3sas_ctl_exit(hbas_to_enumerate);\n\n\tscsih_exit();\n}\n\nmodule_init(_mpt3sas_init);\nmodule_exit(_mpt3sas_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}