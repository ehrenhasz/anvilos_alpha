{
  "module_name": "mpt3sas_warpdrive.c",
  "hash_id": "fec1085d7f263a5310e5d16f644f1d97c6e5185a520b7b8e1fe8e304d6725dd1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mpt3sas/mpt3sas_warpdrive.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <asm/unaligned.h>\n\n#include \"mpt3sas_base.h\"\n\n \nstatic void\n_warpdrive_disable_ddio(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2RaidVolPage1_t vol_pg1;\n\tMpi2ConfigReply_t mpi_reply;\n\tstruct _raid_device *raid_device;\n\tu16 handle;\n\tu16 ioc_status;\n\tunsigned long flags;\n\n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_raid_volume_pg1(ioc, &mpi_reply,\n\t    &vol_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)\n\t\t\tbreak;\n\t\thandle = le16_to_cpu(vol_pg1.DevHandle);\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\traid_device = mpt3sas_raid_device_find_by_handle(ioc, handle);\n\t\tif (raid_device)\n\t\t\traid_device->direct_io_enabled = 0;\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t}\n\treturn;\n}\n\n\n \nu8\nmpt3sas_get_num_volumes(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2RaidVolPage1_t vol_pg1;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 handle;\n\tu8 vol_cnt = 0;\n\tu16 ioc_status;\n\n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_raid_volume_pg1(ioc, &mpi_reply,\n\t    &vol_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)\n\t\t\tbreak;\n\t\tvol_cnt++;\n\t\thandle = le16_to_cpu(vol_pg1.DevHandle);\n\t}\n\treturn vol_cnt;\n}\n\n\n \nvoid\nmpt3sas_init_warpdrive_properties(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _raid_device *raid_device)\n{\n\tMpi2RaidVolPage0_t *vol_pg0;\n\tMpi2RaidPhysDiskPage0_t pd_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 sz;\n\tu8 num_pds, count;\n\tunsigned long stripe_sz, block_sz;\n\tu8 stripe_exp, block_exp;\n\tu64 dev_max_lba;\n\n\tif (!ioc->is_warpdrive)\n\t\treturn;\n\n\tif (ioc->mfg_pg10_hide_flag ==  MFG_PAGE10_EXPOSE_ALL_DISKS) {\n\t\tioc_info(ioc, \"WarpDrive : Direct IO is disabled globally as drives are exposed\\n\");\n\t\treturn;\n\t}\n\tif (mpt3sas_get_num_volumes(ioc) > 1) {\n\t\t_warpdrive_disable_ddio(ioc);\n\t\tioc_info(ioc, \"WarpDrive : Direct IO is disabled globally as number of drives > 1\\n\");\n\t\treturn;\n\t}\n\tif ((mpt3sas_config_get_number_pds(ioc, raid_device->handle,\n\t    &num_pds)) || !num_pds) {\n\t\tioc_info(ioc, \"WarpDrive : Direct IO is disabled Failure in computing number of drives\\n\");\n\t\treturn;\n\t}\n\n\tsz = offsetof(Mpi2RaidVolPage0_t, PhysDisk) + (num_pds *\n\t    sizeof(Mpi2RaidVol0PhysDisk_t));\n\tvol_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!vol_pg0) {\n\t\tioc_info(ioc, \"WarpDrive : Direct IO is disabled Memory allocation failure for RVPG0\\n\");\n\t\treturn;\n\t}\n\n\tif ((mpt3sas_config_get_raid_volume_pg0(ioc, &mpi_reply, vol_pg0,\n\t     MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, raid_device->handle, sz))) {\n\t\tioc_info(ioc, \"WarpDrive : Direct IO is disabled Failure in retrieving RVPG0\\n\");\n\t\tkfree(vol_pg0);\n\t\treturn;\n\t}\n\n\t \n\tif (num_pds > MPT_MAX_WARPDRIVE_PDS) {\n\t\tioc_warn(ioc, \"WarpDrive : Direct IO is disabled for the drive with handle(0x%04x): num_mem=%d, max_mem_allowed=%d\\n\",\n\t\t\t raid_device->handle, num_pds, MPT_MAX_WARPDRIVE_PDS);\n\t\tkfree(vol_pg0);\n\t\treturn;\n\t}\n\tfor (count = 0; count < num_pds; count++) {\n\t\tif (mpt3sas_config_get_phys_disk_pg0(ioc, &mpi_reply,\n\t\t    &pd_pg0, MPI2_PHYSDISK_PGAD_FORM_PHYSDISKNUM,\n\t\t    vol_pg0->PhysDisk[count].PhysDiskNum) ||\n\t\t    le16_to_cpu(pd_pg0.DevHandle) ==\n\t\t    MPT3SAS_INVALID_DEVICE_HANDLE) {\n\t\t\tioc_info(ioc, \"WarpDrive : Direct IO is disabled for the drive with handle(0x%04x) member handle retrieval failed for member number=%d\\n\",\n\t\t\t\t raid_device->handle,\n\t\t\t\t vol_pg0->PhysDisk[count].PhysDiskNum);\n\t\t\tgoto out_error;\n\t\t}\n\t\t \n\t\tdev_max_lba = le64_to_cpu(pd_pg0.DeviceMaxLBA);\n\t\tif (dev_max_lba >> 32) {\n\t\t\tioc_info(ioc, \"WarpDrive : Direct IO is disabled for the drive with handle(0x%04x) member handle (0x%04x) unsupported max lba 0x%016llx\\n\",\n\t\t\t\t raid_device->handle,\n\t\t\t\t le16_to_cpu(pd_pg0.DevHandle),\n\t\t\t\t (u64)dev_max_lba);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\traid_device->pd_handle[count] = le16_to_cpu(pd_pg0.DevHandle);\n\t}\n\n\t \n\tif (raid_device->volume_type != MPI2_RAID_VOL_TYPE_RAID0) {\n\t\tioc_info(ioc, \"WarpDrive : Direct IO is disabled for the drive with handle(0x%04x): type=%d, s_sz=%uK, blk_size=%u\\n\",\n\t\t\t raid_device->handle, raid_device->volume_type,\n\t\t\t (le32_to_cpu(vol_pg0->StripeSize) *\n\t\t\t  le16_to_cpu(vol_pg0->BlockSize)) / 1024,\n\t\t\t le16_to_cpu(vol_pg0->BlockSize));\n\t\tgoto out_error;\n\t}\n\n\tstripe_sz = le32_to_cpu(vol_pg0->StripeSize);\n\tstripe_exp = find_first_bit(&stripe_sz, 32);\n\tif (stripe_exp == 32) {\n\t\tioc_info(ioc, \"WarpDrive : Direct IO is disabled for the drive with handle(0x%04x) invalid stripe sz %uK\\n\",\n\t\t\t raid_device->handle,\n\t\t\t (le32_to_cpu(vol_pg0->StripeSize) *\n\t\t\t  le16_to_cpu(vol_pg0->BlockSize)) / 1024);\n\t\tgoto out_error;\n\t}\n\traid_device->stripe_exponent = stripe_exp;\n\tblock_sz = le16_to_cpu(vol_pg0->BlockSize);\n\tblock_exp = find_first_bit(&block_sz, 16);\n\tif (block_exp == 16) {\n\t\tioc_info(ioc, \"WarpDrive : Direct IO is disabled for the drive with handle(0x%04x) invalid block sz %u\\n\",\n\t\t\t raid_device->handle, le16_to_cpu(vol_pg0->BlockSize));\n\t\tgoto out_error;\n\t}\n\traid_device->block_exponent = block_exp;\n\traid_device->direct_io_enabled = 1;\n\n\tioc_info(ioc, \"WarpDrive : Direct IO is Enabled for the drive with handle(0x%04x)\\n\",\n\t\t raid_device->handle);\n\t \n\traid_device->max_lba = le64_to_cpu(vol_pg0->MaxLBA);\n\traid_device->stripe_sz = le32_to_cpu(vol_pg0->StripeSize);\n\traid_device->block_sz = le16_to_cpu(vol_pg0->BlockSize);\n\n\n\tkfree(vol_pg0);\n\treturn;\n\nout_error:\n\traid_device->direct_io_enabled = 0;\n\tfor (count = 0; count < num_pds; count++)\n\t\traid_device->pd_handle[count] = 0;\n\tkfree(vol_pg0);\n\treturn;\n}\n\n \nvoid\nmpt3sas_setup_direct_io(struct MPT3SAS_ADAPTER *ioc, struct scsi_cmnd *scmd,\n\tstruct _raid_device *raid_device, Mpi25SCSIIORequest_t *mpi_request)\n{\n\tsector_t v_lba, p_lba, stripe_off, column, io_size;\n\tu32 stripe_sz, stripe_exp;\n\tu8 num_pds, cmd = scmd->cmnd[0];\n\tstruct scsiio_tracker *st = scsi_cmd_priv(scmd);\n\n\tif (cmd != READ_10 && cmd != WRITE_10 &&\n\t    cmd != READ_16 && cmd != WRITE_16)\n\t\treturn;\n\n\tif (cmd == READ_10 || cmd == WRITE_10)\n\t\tv_lba = get_unaligned_be32(&mpi_request->CDB.CDB32[2]);\n\telse\n\t\tv_lba = get_unaligned_be64(&mpi_request->CDB.CDB32[2]);\n\n\tio_size = scsi_bufflen(scmd) >> raid_device->block_exponent;\n\n\tif (v_lba + io_size - 1 > raid_device->max_lba)\n\t\treturn;\n\n\tstripe_sz = raid_device->stripe_sz;\n\tstripe_exp = raid_device->stripe_exponent;\n\tstripe_off = v_lba & (stripe_sz - 1);\n\n\t \n\tif (stripe_off + io_size > stripe_sz)\n\t\treturn;\n\n\tnum_pds = raid_device->num_pds;\n\tp_lba = v_lba >> stripe_exp;\n\tcolumn = sector_div(p_lba, num_pds);\n\tp_lba = (p_lba << stripe_exp) + stripe_off;\n\tmpi_request->DevHandle = cpu_to_le16(raid_device->pd_handle[column]);\n\n\tif (cmd == READ_10 || cmd == WRITE_10)\n\t\tput_unaligned_be32(lower_32_bits(p_lba),\n\t\t\t\t   &mpi_request->CDB.CDB32[2]);\n\telse\n\t\tput_unaligned_be64(p_lba, &mpi_request->CDB.CDB32[2]);\n\n\tst->direct_io = 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}