{
  "module_name": "mpt3sas_trigger_diag.c",
  "hash_id": "604dd651a6a0ee7e59c3603eedc4895cdea93988be565d97e2f980b02079f805",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/compat.h>\n#include <linux/poll.h>\n\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n#include \"mpt3sas_base.h\"\n\n \nstatic void\n_mpt3sas_raise_sigio(struct MPT3SAS_ADAPTER *ioc,\n\tstruct SL_WH_TRIGGERS_EVENT_DATA_T *event_data)\n{\n\tMpi2EventNotificationReply_t *mpi_reply;\n\tu16 sz, event_data_sz;\n\tunsigned long flags;\n\n\tdTriggerDiagPrintk(ioc, ioc_info(ioc, \"%s: enter\\n\", __func__));\n\n\tsz = offsetof(Mpi2EventNotificationReply_t, EventData) +\n\t    sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T) + 4;\n\tmpi_reply = kzalloc(sz, GFP_KERNEL);\n\tif (!mpi_reply)\n\t\tgoto out;\n\tmpi_reply->Event = cpu_to_le16(MPI3_EVENT_DIAGNOSTIC_TRIGGER_FIRED);\n\tevent_data_sz = (sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T) + 4) / 4;\n\tmpi_reply->EventDataLength = cpu_to_le16(event_data_sz);\n\tmemcpy(&mpi_reply->EventData, event_data,\n\t    sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T));\n\tdTriggerDiagPrintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: add to driver event log\\n\",\n\t\t\t\t    __func__));\n\tmpt3sas_ctl_add_to_event_log(ioc, mpi_reply);\n\tkfree(mpi_reply);\n out:\n\n\t \n\tspin_lock_irqsave(&ioc->diag_trigger_lock, flags);\n\tdTriggerDiagPrintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: clearing diag_trigger_active flag\\n\",\n\t\t\t\t    __func__));\n\tioc->diag_trigger_active = 0;\n\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\n\tdTriggerDiagPrintk(ioc, ioc_info(ioc, \"%s: exit\\n\",\n\t\t\t\t\t __func__));\n}\n\n \nvoid\nmpt3sas_process_trigger_data(struct MPT3SAS_ADAPTER *ioc,\n\tstruct SL_WH_TRIGGERS_EVENT_DATA_T *event_data)\n{\n\tu8 issue_reset = 0;\n\tu32 *trig_data = (u32 *)&event_data->u.master;\n\n\tdTriggerDiagPrintk(ioc, ioc_info(ioc, \"%s: enter\\n\", __func__));\n\n\t \n\tif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_RELEASED) == 0) {\n\t\t \n\t\tioc_info(ioc,\n\t\t    \"%s: Releasing the trace buffer. Trigger_Type 0x%08x, Data[0] 0x%08x, Data[1] 0x%08x\\n\",\n\t\t    __func__, event_data->trigger_type,\n\t\t    trig_data[0], trig_data[1]);\n\t\tmpt3sas_send_diag_release(ioc, MPI2_DIAG_BUF_TYPE_TRACE,\n\t\t    &issue_reset);\n\t}\n\n\tioc->htb_rel.buffer_rel_condition = MPT3_DIAG_BUFFER_REL_TRIGGER;\n\tif (event_data) {\n\t\tioc->htb_rel.trigger_type = event_data->trigger_type;\n\t\tswitch (event_data->trigger_type) {\n\t\tcase MPT3SAS_TRIGGER_SCSI:\n\t\t\tmemcpy(&ioc->htb_rel.trigger_info_dwords,\n\t\t\t    &event_data->u.scsi,\n\t\t\t    sizeof(struct SL_WH_SCSI_TRIGGER_T));\n\t\t\tbreak;\n\t\tcase MPT3SAS_TRIGGER_MPI:\n\t\t\tmemcpy(&ioc->htb_rel.trigger_info_dwords,\n\t\t\t    &event_data->u.mpi,\n\t\t\t    sizeof(struct SL_WH_MPI_TRIGGER_T));\n\t\t\tbreak;\n\t\tcase MPT3SAS_TRIGGER_MASTER:\n\t\t\tioc->htb_rel.trigger_info_dwords[0] =\n\t\t\t    event_data->u.master.MasterData;\n\t\t\tbreak;\n\t\tcase MPT3SAS_TRIGGER_EVENT:\n\t\t\tmemcpy(&ioc->htb_rel.trigger_info_dwords,\n\t\t\t    &event_data->u.event,\n\t\t\t    sizeof(struct SL_WH_EVENT_TRIGGER_T));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tioc_err(ioc, \"%d - Is not a valid Trigger type\\n\",\n\t\t\t    event_data->trigger_type);\n\t\t\tbreak;\n\t\t}\n\t}\n\t_mpt3sas_raise_sigio(ioc, event_data);\n\n\tdTriggerDiagPrintk(ioc, ioc_info(ioc, \"%s: exit\\n\",\n\t\t\t\t\t __func__));\n}\n\n \nvoid\nmpt3sas_trigger_master(struct MPT3SAS_ADAPTER *ioc, u32 trigger_bitmask)\n{\n\tstruct SL_WH_TRIGGERS_EVENT_DATA_T event_data;\n\tunsigned long flags;\n\tu8 found_match = 0;\n\n\tspin_lock_irqsave(&ioc->diag_trigger_lock, flags);\n\n\tif (trigger_bitmask & MASTER_TRIGGER_FW_FAULT ||\n\t    trigger_bitmask & MASTER_TRIGGER_ADAPTER_RESET)\n\t\tgoto by_pass_checks;\n\n\t \n\tif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0) {\n\t\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tif (ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_RELEASED) {\n\t\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\t\treturn;\n\t}\n\n by_pass_checks:\n\n\tdTriggerDiagPrintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enter - trigger_bitmask = 0x%08x\\n\",\n\t\t\t\t    __func__, trigger_bitmask));\n\n\t \n\tif (ioc->diag_trigger_active) {\n\t\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\t\tgoto out;\n\t}\n\n\t \n\tif (ioc->diag_trigger_master.MasterData & trigger_bitmask) {\n\t\tfound_match = 1;\n\t\tioc->diag_trigger_active = 1;\n\t\tdTriggerDiagPrintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"%s: setting diag_trigger_active flag\\n\",\n\t\t\t\t\t    __func__));\n\t}\n\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\n\tif (!found_match)\n\t\tgoto out;\n\n\tmemset(&event_data, 0, sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T));\n\tevent_data.trigger_type = MPT3SAS_TRIGGER_MASTER;\n\tevent_data.u.master.MasterData = trigger_bitmask;\n\n\tif (trigger_bitmask & MASTER_TRIGGER_FW_FAULT ||\n\t    trigger_bitmask & MASTER_TRIGGER_ADAPTER_RESET) {\n\t\tioc->htb_rel.trigger_type = MPT3SAS_TRIGGER_MASTER;\n\t\tioc->htb_rel.trigger_info_dwords[0] = trigger_bitmask;\n\t\tif (ioc->reset_from_user)\n\t\t\tioc->htb_rel.trigger_info_dwords[1] =\n\t\t\t    MPT_DIAG_RESET_ISSUED_BY_USER;\n\t\t_mpt3sas_raise_sigio(ioc, &event_data);\n\t} else\n\t\tmpt3sas_send_trigger_data_event(ioc, &event_data);\n\n out:\n\tdTriggerDiagPrintk(ioc, ioc_info(ioc, \"%s: exit\\n\",\n\t\t\t\t\t __func__));\n}\n\n \nvoid\nmpt3sas_trigger_event(struct MPT3SAS_ADAPTER *ioc, u16 event,\n\tu16 log_entry_qualifier)\n{\n\tstruct SL_WH_TRIGGERS_EVENT_DATA_T event_data;\n\tstruct SL_WH_EVENT_TRIGGER_T *event_trigger;\n\tint i;\n\tunsigned long flags;\n\tu8 found_match;\n\n\tspin_lock_irqsave(&ioc->diag_trigger_lock, flags);\n\n\t \n\tif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0) {\n\t\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tif (ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_RELEASED) {\n\t\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\t\treturn;\n\t}\n\n\tdTriggerDiagPrintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enter - event = 0x%04x, log_entry_qualifier = 0x%04x\\n\",\n\t\t\t\t    __func__, event, log_entry_qualifier));\n\n\t \n\tif (ioc->diag_trigger_active) {\n\t\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\t\tgoto out;\n\t}\n\n\t \n\tevent_trigger = ioc->diag_trigger_event.EventTriggerEntry;\n\tfor (i = 0 , found_match = 0; i < ioc->diag_trigger_event.ValidEntries\n\t    && !found_match; i++, event_trigger++) {\n\t\tif (event_trigger->EventValue != event)\n\t\t\tcontinue;\n\t\tif (event == MPI2_EVENT_LOG_ENTRY_ADDED) {\n\t\t\tif (event_trigger->LogEntryQualifier ==\n\t\t\t    log_entry_qualifier)\n\t\t\t\tfound_match = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tfound_match = 1;\n\t\tioc->diag_trigger_active = 1;\n\t\tdTriggerDiagPrintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"%s: setting diag_trigger_active flag\\n\",\n\t\t\t\t\t    __func__));\n\t}\n\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\n\tif (!found_match)\n\t\tgoto out;\n\n\tdTriggerDiagPrintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: setting diag_trigger_active flag\\n\",\n\t\t\t\t    __func__));\n\tmemset(&event_data, 0, sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T));\n\tevent_data.trigger_type = MPT3SAS_TRIGGER_EVENT;\n\tevent_data.u.event.EventValue = event;\n\tevent_data.u.event.LogEntryQualifier = log_entry_qualifier;\n\tmpt3sas_send_trigger_data_event(ioc, &event_data);\n out:\n\tdTriggerDiagPrintk(ioc, ioc_info(ioc, \"%s: exit\\n\",\n\t\t\t\t\t __func__));\n}\n\n \nvoid\nmpt3sas_trigger_scsi(struct MPT3SAS_ADAPTER *ioc, u8 sense_key, u8 asc,\n\tu8 ascq)\n{\n\tstruct SL_WH_TRIGGERS_EVENT_DATA_T event_data;\n\tstruct SL_WH_SCSI_TRIGGER_T *scsi_trigger;\n\tint i;\n\tunsigned long flags;\n\tu8 found_match;\n\n\tspin_lock_irqsave(&ioc->diag_trigger_lock, flags);\n\n\t \n\tif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0) {\n\t\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tif (ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_RELEASED) {\n\t\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\t\treturn;\n\t}\n\n\tdTriggerDiagPrintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enter - sense_key = 0x%02x, asc = 0x%02x, ascq = 0x%02x\\n\",\n\t\t\t\t    __func__, sense_key, asc, ascq));\n\n\t \n\tif (ioc->diag_trigger_active) {\n\t\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\t\tgoto out;\n\t}\n\n\t \n\tscsi_trigger = ioc->diag_trigger_scsi.SCSITriggerEntry;\n\tfor (i = 0 , found_match = 0; i < ioc->diag_trigger_scsi.ValidEntries\n\t    && !found_match; i++, scsi_trigger++) {\n\t\tif (scsi_trigger->SenseKey != sense_key)\n\t\t\tcontinue;\n\t\tif (!(scsi_trigger->ASC == 0xFF || scsi_trigger->ASC == asc))\n\t\t\tcontinue;\n\t\tif (!(scsi_trigger->ASCQ == 0xFF || scsi_trigger->ASCQ == ascq))\n\t\t\tcontinue;\n\t\tfound_match = 1;\n\t\tioc->diag_trigger_active = 1;\n\t}\n\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\n\tif (!found_match)\n\t\tgoto out;\n\n\tdTriggerDiagPrintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: setting diag_trigger_active flag\\n\",\n\t\t\t\t    __func__));\n\tmemset(&event_data, 0, sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T));\n\tevent_data.trigger_type = MPT3SAS_TRIGGER_SCSI;\n\tevent_data.u.scsi.SenseKey = sense_key;\n\tevent_data.u.scsi.ASC = asc;\n\tevent_data.u.scsi.ASCQ = ascq;\n\tmpt3sas_send_trigger_data_event(ioc, &event_data);\n out:\n\tdTriggerDiagPrintk(ioc, ioc_info(ioc, \"%s: exit\\n\",\n\t\t\t\t\t __func__));\n}\n\n \nvoid\nmpt3sas_trigger_mpi(struct MPT3SAS_ADAPTER *ioc, u16 ioc_status, u32 loginfo)\n{\n\tstruct SL_WH_TRIGGERS_EVENT_DATA_T event_data;\n\tstruct SL_WH_MPI_TRIGGER_T *mpi_trigger;\n\tint i;\n\tunsigned long flags;\n\tu8 found_match;\n\n\tspin_lock_irqsave(&ioc->diag_trigger_lock, flags);\n\n\t \n\tif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0) {\n\t\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tif (ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_RELEASED) {\n\t\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\t\treturn;\n\t}\n\n\tdTriggerDiagPrintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enter - ioc_status = 0x%04x, loginfo = 0x%08x\\n\",\n\t\t\t\t    __func__, ioc_status, loginfo));\n\n\t \n\tif (ioc->diag_trigger_active) {\n\t\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\t\tgoto out;\n\t}\n\n\t \n\tmpi_trigger = ioc->diag_trigger_mpi.MPITriggerEntry;\n\tfor (i = 0 , found_match = 0; i < ioc->diag_trigger_mpi.ValidEntries\n\t    && !found_match; i++, mpi_trigger++) {\n\t\tif (mpi_trigger->IOCStatus != ioc_status)\n\t\t\tcontinue;\n\t\tif (!(mpi_trigger->IocLogInfo == 0xFFFFFFFF ||\n\t\t    mpi_trigger->IocLogInfo == loginfo))\n\t\t\tcontinue;\n\t\tfound_match = 1;\n\t\tioc->diag_trigger_active = 1;\n\t}\n\tspin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);\n\n\tif (!found_match)\n\t\tgoto out;\n\n\tdTriggerDiagPrintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: setting diag_trigger_active flag\\n\",\n\t\t\t\t    __func__));\n\tmemset(&event_data, 0, sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T));\n\tevent_data.trigger_type = MPT3SAS_TRIGGER_MPI;\n\tevent_data.u.mpi.IOCStatus = ioc_status;\n\tevent_data.u.mpi.IocLogInfo = loginfo;\n\tmpt3sas_send_trigger_data_event(ioc, &event_data);\n out:\n\tdTriggerDiagPrintk(ioc, ioc_info(ioc, \"%s: exit\\n\",\n\t\t\t\t\t __func__));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}