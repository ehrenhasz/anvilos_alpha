{
  "module_name": "mpt3sas_base.c",
  "hash_id": "14f92f3fcb01c976d5f02d3719993596d281176c93a763e26fc4bb6b531b4ed5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mpt3sas/mpt3sas_base.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/kdev_t.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/ktime.h>\n#include <linux/kthread.h>\n#include <asm/page.h>         \n\n\n#include \"mpt3sas_base.h\"\n\nstatic MPT_CALLBACK\tmpt_callbacks[MPT_MAX_CALLBACKS];\n\n\n#define FAULT_POLLING_INTERVAL 1000  \n\n  \n#define MAX_HBA_QUEUE_DEPTH\t30000\n#define MAX_CHAIN_DEPTH\t\t100000\nstatic int max_queue_depth = -1;\nmodule_param(max_queue_depth, int, 0444);\nMODULE_PARM_DESC(max_queue_depth, \" max controller queue depth \");\n\nstatic int max_sgl_entries = -1;\nmodule_param(max_sgl_entries, int, 0444);\nMODULE_PARM_DESC(max_sgl_entries, \" max sg entries \");\n\nstatic int msix_disable = -1;\nmodule_param(msix_disable, int, 0444);\nMODULE_PARM_DESC(msix_disable, \" disable msix routed interrupts (default=0)\");\n\nstatic int smp_affinity_enable = 1;\nmodule_param(smp_affinity_enable, int, 0444);\nMODULE_PARM_DESC(smp_affinity_enable, \"SMP affinity feature enable/disable Default: enable(1)\");\n\nstatic int max_msix_vectors = -1;\nmodule_param(max_msix_vectors, int, 0444);\nMODULE_PARM_DESC(max_msix_vectors,\n\t\" max msix vectors\");\n\nstatic int irqpoll_weight = -1;\nmodule_param(irqpoll_weight, int, 0444);\nMODULE_PARM_DESC(irqpoll_weight,\n\t\"irq poll weight (default= one fourth of HBA queue depth)\");\n\nstatic int mpt3sas_fwfault_debug;\nMODULE_PARM_DESC(mpt3sas_fwfault_debug,\n\t\" enable detection of firmware fault and halt firmware - (default=0)\");\n\nstatic int perf_mode = -1;\nmodule_param(perf_mode, int, 0444);\nMODULE_PARM_DESC(perf_mode,\n\t\"Performance mode (only for Aero/Sea Generation), options:\\n\\t\\t\"\n\t\"0 - balanced: high iops mode is enabled &\\n\\t\\t\"\n\t\"interrupt coalescing is enabled only on high iops queues,\\n\\t\\t\"\n\t\"1 - iops: high iops mode is disabled &\\n\\t\\t\"\n\t\"interrupt coalescing is enabled on all queues,\\n\\t\\t\"\n\t\"2 - latency: high iops mode is disabled &\\n\\t\\t\"\n\t\"interrupt coalescing is enabled on all queues with timeout value 0xA,\\n\"\n\t\"\\t\\tdefault - default perf_mode is 'balanced'\"\n\t);\n\nstatic int poll_queues;\nmodule_param(poll_queues, int, 0444);\nMODULE_PARM_DESC(poll_queues, \"Number of queues to be use for io_uring poll mode.\\n\\t\\t\"\n\t\"This parameter is effective only if host_tagset_enable=1. &\\n\\t\\t\"\n\t\"when poll_queues are enabled then &\\n\\t\\t\"\n\t\"perf_mode is set to latency mode. &\\n\\t\\t\"\n\t);\n\nenum mpt3sas_perf_mode {\n\tMPT_PERF_MODE_DEFAULT\t= -1,\n\tMPT_PERF_MODE_BALANCED\t= 0,\n\tMPT_PERF_MODE_IOPS\t= 1,\n\tMPT_PERF_MODE_LATENCY\t= 2,\n};\n\nstatic int\n_base_wait_on_iocstate(struct MPT3SAS_ADAPTER *ioc,\n\t\tu32 ioc_state, int timeout);\nstatic int\n_base_get_ioc_facts(struct MPT3SAS_ADAPTER *ioc);\nstatic void\n_base_clear_outstanding_commands(struct MPT3SAS_ADAPTER *ioc);\n\nstatic u32\n_base_readl_ext_retry(const void __iomem *addr);\n\n \nu8\nmpt3sas_base_check_cmd_timeout(struct MPT3SAS_ADAPTER *ioc,\n\t\tu8 status, void *mpi_request, int sz)\n{\n\tu8 issue_reset = 0;\n\n\tif (!(status & MPT3_CMD_RESET))\n\t\tissue_reset = 1;\n\n\tioc_err(ioc, \"Command %s\\n\",\n\t\tissue_reset == 0 ? \"terminated due to Host Reset\" : \"Timeout\");\n\t_debug_dump_mf(mpi_request, sz);\n\n\treturn issue_reset;\n}\n\n \nstatic int\n_scsih_set_fwfault_debug(const char *val, const struct kernel_param *kp)\n{\n\tint ret = param_set_int(val, kp);\n\tstruct MPT3SAS_ADAPTER *ioc;\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpr_info(\"setting fwfault_debug(%d)\\n\", mpt3sas_fwfault_debug);\n\tspin_lock(&gioc_lock);\n\tlist_for_each_entry(ioc, &mpt3sas_ioc_list, list)\n\t\tioc->fwfault_debug = mpt3sas_fwfault_debug;\n\tspin_unlock(&gioc_lock);\n\treturn 0;\n}\nmodule_param_call(mpt3sas_fwfault_debug, _scsih_set_fwfault_debug,\n\tparam_get_int, &mpt3sas_fwfault_debug, 0644);\n\n \nstatic inline u32\n_base_readl_aero(const void __iomem *addr)\n{\n\tu32 i = 0, ret_val;\n\n\tdo {\n\t\tret_val = readl(addr);\n\t\ti++;\n\t} while (ret_val == 0 && i < 3);\n\n\treturn ret_val;\n}\n\nstatic u32\n_base_readl_ext_retry(const void __iomem *addr)\n{\n\tu32 i, ret_val;\n\n\tfor (i = 0 ; i < 30 ; i++) {\n\t\tret_val = readl(addr);\n\t\tif (ret_val != 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret_val;\n}\n\nstatic inline u32\n_base_readl(const void __iomem *addr)\n{\n\treturn readl(addr);\n}\n\n \nstatic void\n_base_clone_reply_to_sys_mem(struct MPT3SAS_ADAPTER *ioc, u32 reply,\n\t\tu32 index)\n{\n\t \n\tu16 cmd_credit = ioc->facts.RequestCredit + 1;\n\tvoid __iomem *reply_free_iomem = (void __iomem *)ioc->chip +\n\t\t\tMPI_FRAME_START_OFFSET +\n\t\t\t(cmd_credit * ioc->request_sz) + (index * sizeof(u32));\n\n\twritel(reply, reply_free_iomem);\n}\n\n \nstatic void\n_base_clone_mpi_to_sys_mem(void *dst_iomem, void *src, u32 size)\n{\n\tint i;\n\tu32 *src_virt_mem = (u32 *)src;\n\n\tfor (i = 0; i < size/4; i++)\n\t\twritel((u32)src_virt_mem[i],\n\t\t\t\t(void __iomem *)dst_iomem + (i * 4));\n}\n\n \nstatic void\n_base_clone_to_sys_mem(void __iomem *dst_iomem, void *src, u32 size)\n{\n\tint i;\n\tu32 *src_virt_mem = (u32 *)(src);\n\n\tfor (i = 0; i < size/4; i++)\n\t\twritel((u32)src_virt_mem[i],\n\t\t\t(void __iomem *)dst_iomem + (i * 4));\n}\n\n \nstatic inline void __iomem*\n_base_get_chain(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\t\tu8 sge_chain_count)\n{\n\tvoid __iomem *base_chain, *chain_virt;\n\tu16 cmd_credit = ioc->facts.RequestCredit + 1;\n\n\tbase_chain  = (void __iomem *)ioc->chip + MPI_FRAME_START_OFFSET +\n\t\t(cmd_credit * ioc->request_sz) +\n\t\tREPLY_FREE_POOL_SIZE;\n\tchain_virt = base_chain + (smid * ioc->facts.MaxChainDepth *\n\t\t\tioc->request_sz) + (sge_chain_count * ioc->request_sz);\n\treturn chain_virt;\n}\n\n \nstatic inline phys_addr_t\n_base_get_chain_phys(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\t\tu8 sge_chain_count)\n{\n\tphys_addr_t base_chain_phys, chain_phys;\n\tu16 cmd_credit = ioc->facts.RequestCredit + 1;\n\n\tbase_chain_phys  = ioc->chip_phys + MPI_FRAME_START_OFFSET +\n\t\t(cmd_credit * ioc->request_sz) +\n\t\tREPLY_FREE_POOL_SIZE;\n\tchain_phys = base_chain_phys + (smid * ioc->facts.MaxChainDepth *\n\t\t\tioc->request_sz) + (sge_chain_count * ioc->request_sz);\n\treturn chain_phys;\n}\n\n \n\nstatic void __iomem *\n_base_get_buffer_bar0(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tu16 cmd_credit = ioc->facts.RequestCredit + 1;\n\t\n\tvoid __iomem *chain_end = _base_get_chain(ioc,\n\t\t\tcmd_credit + 1,\n\t\t\tioc->facts.MaxChainDepth);\n\treturn chain_end + (smid * 64 * 1024);\n}\n\n \nstatic phys_addr_t\n_base_get_buffer_phys_bar0(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tu16 cmd_credit = ioc->facts.RequestCredit + 1;\n\tphys_addr_t chain_end_phys = _base_get_chain_phys(ioc,\n\t\t\tcmd_credit + 1,\n\t\t\tioc->facts.MaxChainDepth);\n\treturn chain_end_phys + (smid * 64 * 1024);\n}\n\n \nstatic void *\n_base_get_chain_buffer_dma_to_chain_buffer(struct MPT3SAS_ADAPTER *ioc,\n\t\tdma_addr_t chain_buffer_dma)\n{\n\tu16 index, j;\n\tstruct chain_tracker *ct;\n\n\tfor (index = 0; index < ioc->scsiio_depth; index++) {\n\t\tfor (j = 0; j < ioc->chains_needed_per_io; j++) {\n\t\t\tct = &ioc->chain_lookup[index].chains_per_smid[j];\n\t\t\tif (ct && ct->chain_buffer_dma == chain_buffer_dma)\n\t\t\t\treturn ct->chain_buffer;\n\t\t}\n\t}\n\tioc_info(ioc, \"Provided chain_buffer_dma address is not in the lookup list\\n\");\n\treturn NULL;\n}\n\n \nstatic void _clone_sg_entries(struct MPT3SAS_ADAPTER *ioc,\n\t\tvoid *mpi_request, u16 smid)\n{\n\tMpi2SGESimple32_t *sgel, *sgel_next;\n\tu32  sgl_flags, sge_chain_count = 0;\n\tbool is_write = false;\n\tu16 i = 0;\n\tvoid __iomem *buffer_iomem;\n\tphys_addr_t buffer_iomem_phys;\n\tvoid __iomem *buff_ptr;\n\tphys_addr_t buff_ptr_phys;\n\tvoid __iomem *dst_chain_addr[MCPU_MAX_CHAINS_PER_IO];\n\tvoid *src_chain_addr[MCPU_MAX_CHAINS_PER_IO];\n\tphys_addr_t dst_addr_phys;\n\tMPI2RequestHeader_t *request_hdr;\n\tstruct scsi_cmnd *scmd;\n\tstruct scatterlist *sg_scmd = NULL;\n\tint is_scsiio_req = 0;\n\n\trequest_hdr = (MPI2RequestHeader_t *) mpi_request;\n\n\tif (request_hdr->Function == MPI2_FUNCTION_SCSI_IO_REQUEST) {\n\t\tMpi25SCSIIORequest_t *scsiio_request =\n\t\t\t(Mpi25SCSIIORequest_t *)mpi_request;\n\t\tsgel = (Mpi2SGESimple32_t *) &scsiio_request->SGL;\n\t\tis_scsiio_req = 1;\n\t} else if (request_hdr->Function == MPI2_FUNCTION_CONFIG) {\n\t\tMpi2ConfigRequest_t  *config_req =\n\t\t\t(Mpi2ConfigRequest_t *)mpi_request;\n\t\tsgel = (Mpi2SGESimple32_t *) &config_req->PageBufferSGE;\n\t} else\n\t\treturn;\n\n\t \n\n\tif (is_scsiio_req) {\n\t\t \n\t\tscmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);\n\t\tif (scmd == NULL) {\n\t\t\tioc_err(ioc, \"scmd is NULL\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tsg_scmd = scsi_sglist(scmd);\n\t}\n\n\t \n\n\tbuffer_iomem = _base_get_buffer_bar0(ioc, smid);\n\tbuffer_iomem_phys = _base_get_buffer_phys_bar0(ioc, smid);\n\n\tbuff_ptr = buffer_iomem;\n\tbuff_ptr_phys = buffer_iomem_phys;\n\tWARN_ON(buff_ptr_phys > U32_MAX);\n\n\tif (le32_to_cpu(sgel->FlagsLength) &\n\t\t\t(MPI2_SGE_FLAGS_HOST_TO_IOC << MPI2_SGE_FLAGS_SHIFT))\n\t\tis_write = true;\n\n\tfor (i = 0; i < MPT_MIN_PHYS_SEGMENTS + ioc->facts.MaxChainDepth; i++) {\n\n\t\tsgl_flags =\n\t\t    (le32_to_cpu(sgel->FlagsLength) >> MPI2_SGE_FLAGS_SHIFT);\n\n\t\tswitch (sgl_flags & MPI2_SGE_FLAGS_ELEMENT_MASK) {\n\t\tcase MPI2_SGE_FLAGS_CHAIN_ELEMENT:\n\t\t\t \n\t\t\tsgel_next =\n\t\t\t\t_base_get_chain_buffer_dma_to_chain_buffer(ioc,\n\t\t\t\t\t\tle32_to_cpu(sgel->Address));\n\t\t\tif (sgel_next == NULL)\n\t\t\t\treturn;\n\t\t\t \n\t\t\tdst_chain_addr[sge_chain_count] =\n\t\t\t\t_base_get_chain(ioc,\n\t\t\t\t\tsmid, sge_chain_count);\n\t\t\tsrc_chain_addr[sge_chain_count] =\n\t\t\t\t\t\t(void *) sgel_next;\n\t\t\tdst_addr_phys = _base_get_chain_phys(ioc,\n\t\t\t\t\t\tsmid, sge_chain_count);\n\t\t\tWARN_ON(dst_addr_phys > U32_MAX);\n\t\t\tsgel->Address =\n\t\t\t\tcpu_to_le32(lower_32_bits(dst_addr_phys));\n\t\t\tsgel = sgel_next;\n\t\t\tsge_chain_count++;\n\t\t\tbreak;\n\t\tcase MPI2_SGE_FLAGS_SIMPLE_ELEMENT:\n\t\t\tif (is_write) {\n\t\t\t\tif (is_scsiio_req) {\n\t\t\t\t\t_base_clone_to_sys_mem(buff_ptr,\n\t\t\t\t\t    sg_virt(sg_scmd),\n\t\t\t\t\t    (le32_to_cpu(sgel->FlagsLength) &\n\t\t\t\t\t    0x00ffffff));\n\t\t\t\t\t \n\t\t\t\t\tsgel->Address =\n\t\t\t\t\t    cpu_to_le32((u32)buff_ptr_phys);\n\t\t\t\t} else {\n\t\t\t\t\t_base_clone_to_sys_mem(buff_ptr,\n\t\t\t\t\t    ioc->config_vaddr,\n\t\t\t\t\t    (le32_to_cpu(sgel->FlagsLength) &\n\t\t\t\t\t    0x00ffffff));\n\t\t\t\t\tsgel->Address =\n\t\t\t\t\t    cpu_to_le32((u32)buff_ptr_phys);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuff_ptr += (le32_to_cpu(sgel->FlagsLength) &\n\t\t\t    0x00ffffff);\n\t\t\tbuff_ptr_phys += (le32_to_cpu(sgel->FlagsLength) &\n\t\t\t    0x00ffffff);\n\t\t\tif ((le32_to_cpu(sgel->FlagsLength) &\n\t\t\t    (MPI2_SGE_FLAGS_END_OF_BUFFER\n\t\t\t\t\t<< MPI2_SGE_FLAGS_SHIFT)))\n\t\t\t\tgoto eob_clone_chain;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tif (is_scsiio_req) {\n\t\t\t\t\tsg_scmd = sg_next(sg_scmd);\n\t\t\t\t\tif (sg_scmd)\n\t\t\t\t\t\tsgel++;\n\t\t\t\t\telse\n\t\t\t\t\t\tgoto eob_clone_chain;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\neob_clone_chain:\n\tfor (i = 0; i < sge_chain_count; i++) {\n\t\tif (is_scsiio_req)\n\t\t\t_base_clone_to_sys_mem(dst_chain_addr[i],\n\t\t\t\tsrc_chain_addr[i], ioc->request_sz);\n\t}\n}\n\n \nstatic int mpt3sas_remove_dead_ioc_func(void *arg)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = (struct MPT3SAS_ADAPTER *)arg;\n\tstruct pci_dev *pdev;\n\n\tif (!ioc)\n\t\treturn -1;\n\n\tpdev = ioc->pdev;\n\tif (!pdev)\n\t\treturn -1;\n\tpci_stop_and_remove_bus_device_locked(pdev);\n\treturn 0;\n}\n\n \nstatic void _base_sync_drv_fw_timestamp(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi26IoUnitControlRequest_t *mpi_request;\n\tMpi26IoUnitControlReply_t *mpi_reply;\n\tu16 smid;\n\tktime_t current_time;\n\tu64 TimeStamp = 0;\n\tu8 issue_reset = 0;\n\n\tmutex_lock(&ioc->scsih_cmds.mutex);\n\tif (ioc->scsih_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"scsih_cmd in use %s\\n\", __func__);\n\t\tgoto out;\n\t}\n\tioc->scsih_cmds.status = MPT3_CMD_PENDING;\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->scsih_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"Failed obtaining a smid %s\\n\", __func__);\n\t\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\t\tgoto out;\n\t}\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->scsih_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi26IoUnitControlRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_IO_UNIT_CONTROL;\n\tmpi_request->Operation = MPI26_CTRL_OP_SET_IOC_PARAMETER;\n\tmpi_request->IOCParameter = MPI26_SET_IOC_PARAMETER_SYNC_TIMESTAMP;\n\tcurrent_time = ktime_get_real();\n\tTimeStamp = ktime_to_ms(current_time);\n\tmpi_request->Reserved7 = cpu_to_le32(TimeStamp >> 32);\n\tmpi_request->IOCParameterValue = cpu_to_le32(TimeStamp & 0xFFFFFFFF);\n\tinit_completion(&ioc->scsih_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\tdinitprintk(ioc, ioc_info(ioc,\n\t    \"Io Unit Control Sync TimeStamp (sending), @time %lld ms\\n\",\n\t    TimeStamp));\n\twait_for_completion_timeout(&ioc->scsih_cmds.done,\n\t\tMPT3SAS_TIMESYNC_TIMEOUT_SECONDS*HZ);\n\tif (!(ioc->scsih_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tmpt3sas_check_cmd_timeout(ioc,\n\t\t    ioc->scsih_cmds.status, mpi_request,\n\t\t    sizeof(Mpi2SasIoUnitControlRequest_t)/4, issue_reset);\n\t\tgoto issue_host_reset;\n\t}\n\tif (ioc->scsih_cmds.status & MPT3_CMD_REPLY_VALID) {\n\t\tmpi_reply = ioc->scsih_cmds.reply;\n\t\tdinitprintk(ioc, ioc_info(ioc,\n\t\t    \"Io Unit Control sync timestamp (complete): ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t    le16_to_cpu(mpi_reply->IOCStatus),\n\t\t    le32_to_cpu(mpi_reply->IOCLogInfo)));\n\t}\nissue_host_reset:\n\tif (issue_reset)\n\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\nout:\n\tmutex_unlock(&ioc->scsih_cmds.mutex);\n}\n\n \nstatic void\n_base_fault_reset_work(struct work_struct *work)\n{\n\tstruct MPT3SAS_ADAPTER *ioc =\n\t    container_of(work, struct MPT3SAS_ADAPTER, fault_reset_work.work);\n\tunsigned long\t flags;\n\tu32 doorbell;\n\tint rc;\n\tstruct task_struct *p;\n\n\n\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\n\tif ((ioc->shost_recovery && (ioc->ioc_coredump_loop == 0)) ||\n\t\t\tioc->pci_error_recovery)\n\t\tgoto rearm_timer;\n\tspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\n\n\tdoorbell = mpt3sas_base_get_iocstate(ioc, 0);\n\tif ((doorbell & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_MASK) {\n\t\tioc_err(ioc, \"SAS host is non-operational !!!!\\n\");\n\n\t\t \n\t\tif (ioc->non_operational_loop++ < 5) {\n\t\t\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock,\n\t\t\t\t\t\t\t flags);\n\t\t\tgoto rearm_timer;\n\t\t}\n\n\t\t \n\t\tmpt3sas_base_pause_mq_polling(ioc);\n\t\tioc->schedule_dead_ioc_flush_running_cmds(ioc);\n\t\t \n\t\tioc->remove_host = 1;\n\t\t \n\t\tp = kthread_run(mpt3sas_remove_dead_ioc_func, ioc,\n\t\t    \"%s_dead_ioc_%d\", ioc->driver_name, ioc->id);\n\t\tif (IS_ERR(p))\n\t\t\tioc_err(ioc, \"%s: Running mpt3sas_dead_ioc thread failed !!!!\\n\",\n\t\t\t\t__func__);\n\t\telse\n\t\t\tioc_err(ioc, \"%s: Running mpt3sas_dead_ioc thread success !!!!\\n\",\n\t\t\t\t__func__);\n\t\treturn;  \n\t}\n\n\tif ((doorbell & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_COREDUMP) {\n\t\tu8 timeout = (ioc->manu_pg11.CoreDumpTOSec) ?\n\t\t    ioc->manu_pg11.CoreDumpTOSec :\n\t\t    MPT3SAS_DEFAULT_COREDUMP_TIMEOUT_SECONDS;\n\n\t\ttimeout /= (FAULT_POLLING_INTERVAL/1000);\n\n\t\tif (ioc->ioc_coredump_loop == 0) {\n\t\t\tmpt3sas_print_coredump_info(ioc,\n\t\t\t    doorbell & MPI2_DOORBELL_DATA_MASK);\n\t\t\t \n\t\t\tspin_lock_irqsave(\n\t\t\t    &ioc->ioc_reset_in_progress_lock, flags);\n\t\t\tioc->shost_recovery = 1;\n\t\t\tspin_unlock_irqrestore(\n\t\t\t    &ioc->ioc_reset_in_progress_lock, flags);\n\t\t\tmpt3sas_base_mask_interrupts(ioc);\n\t\t\tmpt3sas_base_pause_mq_polling(ioc);\n\t\t\t_base_clear_outstanding_commands(ioc);\n\t\t}\n\n\t\tioc_info(ioc, \"%s: CoreDump loop %d.\",\n\t\t    __func__, ioc->ioc_coredump_loop);\n\n\t\t \n\t\tif (ioc->ioc_coredump_loop++ < timeout) {\n\t\t\tspin_lock_irqsave(\n\t\t\t    &ioc->ioc_reset_in_progress_lock, flags);\n\t\t\tgoto rearm_timer;\n\t\t}\n\t}\n\n\tif (ioc->ioc_coredump_loop) {\n\t\tif ((doorbell & MPI2_IOC_STATE_MASK) != MPI2_IOC_STATE_COREDUMP)\n\t\t\tioc_err(ioc, \"%s: CoreDump completed. LoopCount: %d\",\n\t\t\t    __func__, ioc->ioc_coredump_loop);\n\t\telse\n\t\t\tioc_err(ioc, \"%s: CoreDump Timed out. LoopCount: %d\",\n\t\t\t    __func__, ioc->ioc_coredump_loop);\n\t\tioc->ioc_coredump_loop = MPT3SAS_COREDUMP_LOOP_DONE;\n\t}\n\tioc->non_operational_loop = 0;\n\tif ((doorbell & MPI2_IOC_STATE_MASK) != MPI2_IOC_STATE_OPERATIONAL) {\n\t\trc = mpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\t\tioc_warn(ioc, \"%s: hard reset: %s\\n\",\n\t\t\t __func__, rc == 0 ? \"success\" : \"failed\");\n\t\tdoorbell = mpt3sas_base_get_iocstate(ioc, 0);\n\t\tif ((doorbell & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {\n\t\t\tmpt3sas_print_fault_code(ioc, doorbell &\n\t\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\t} else if ((doorbell & MPI2_IOC_STATE_MASK) ==\n\t\t    MPI2_IOC_STATE_COREDUMP)\n\t\t\tmpt3sas_print_coredump_info(ioc, doorbell &\n\t\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\tif (rc && (doorbell & MPI2_IOC_STATE_MASK) !=\n\t\t    MPI2_IOC_STATE_OPERATIONAL)\n\t\t\treturn;  \n\t}\n\tioc->ioc_coredump_loop = 0;\n\tif (ioc->time_sync_interval &&\n\t    ++ioc->timestamp_update_count >= ioc->time_sync_interval) {\n\t\tioc->timestamp_update_count = 0;\n\t\t_base_sync_drv_fw_timestamp(ioc);\n\t}\n\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\n rearm_timer:\n\tif (ioc->fault_reset_work_q)\n\t\tqueue_delayed_work(ioc->fault_reset_work_q,\n\t\t    &ioc->fault_reset_work,\n\t\t    msecs_to_jiffies(FAULT_POLLING_INTERVAL));\n\tspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\n}\n\n \nvoid\nmpt3sas_base_start_watchdog(struct MPT3SAS_ADAPTER *ioc)\n{\n\tunsigned long\t flags;\n\n\tif (ioc->fault_reset_work_q)\n\t\treturn;\n\n\tioc->timestamp_update_count = 0;\n\t \n\n\tINIT_DELAYED_WORK(&ioc->fault_reset_work, _base_fault_reset_work);\n\tsnprintf(ioc->fault_reset_work_q_name,\n\t    sizeof(ioc->fault_reset_work_q_name), \"poll_%s%d_status\",\n\t    ioc->driver_name, ioc->id);\n\tioc->fault_reset_work_q =\n\t\tcreate_singlethread_workqueue(ioc->fault_reset_work_q_name);\n\tif (!ioc->fault_reset_work_q) {\n\t\tioc_err(ioc, \"%s: failed (line=%d)\\n\", __func__, __LINE__);\n\t\treturn;\n\t}\n\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\n\tif (ioc->fault_reset_work_q)\n\t\tqueue_delayed_work(ioc->fault_reset_work_q,\n\t\t    &ioc->fault_reset_work,\n\t\t    msecs_to_jiffies(FAULT_POLLING_INTERVAL));\n\tspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\n}\n\n \nvoid\nmpt3sas_base_stop_watchdog(struct MPT3SAS_ADAPTER *ioc)\n{\n\tunsigned long flags;\n\tstruct workqueue_struct *wq;\n\n\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\n\twq = ioc->fault_reset_work_q;\n\tioc->fault_reset_work_q = NULL;\n\tspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\n\tif (wq) {\n\t\tif (!cancel_delayed_work_sync(&ioc->fault_reset_work))\n\t\t\tflush_workqueue(wq);\n\t\tdestroy_workqueue(wq);\n\t}\n}\n\n \nvoid\nmpt3sas_base_fault_info(struct MPT3SAS_ADAPTER *ioc, u16 fault_code)\n{\n\tioc_err(ioc, \"fault_state(0x%04x)!\\n\", fault_code);\n}\n\n \nvoid\nmpt3sas_base_coredump_info(struct MPT3SAS_ADAPTER *ioc, u16 fault_code)\n{\n\tioc_err(ioc, \"coredump_state(0x%04x)!\\n\", fault_code);\n}\n\n \nint\nmpt3sas_base_wait_for_coredump_completion(struct MPT3SAS_ADAPTER *ioc,\n\t\tconst char *caller)\n{\n\tu8 timeout = (ioc->manu_pg11.CoreDumpTOSec) ?\n\t\t\tioc->manu_pg11.CoreDumpTOSec :\n\t\t\tMPT3SAS_DEFAULT_COREDUMP_TIMEOUT_SECONDS;\n\n\tint ioc_state = _base_wait_on_iocstate(ioc, MPI2_IOC_STATE_FAULT,\n\t\t\t\t\ttimeout);\n\n\tif (ioc_state)\n\t\tioc_err(ioc,\n\t\t    \"%s: CoreDump timed out. (ioc_state=0x%x)\\n\",\n\t\t    caller, ioc_state);\n\telse\n\t\tioc_info(ioc,\n\t\t    \"%s: CoreDump completed. (ioc_state=0x%x)\\n\",\n\t\t    caller, ioc_state);\n\n\treturn ioc_state;\n}\n\n \nvoid\nmpt3sas_halt_firmware(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 doorbell;\n\n\tif (!ioc->fwfault_debug)\n\t\treturn;\n\n\tdump_stack();\n\n\tdoorbell = ioc->base_readl_ext_retry(&ioc->chip->Doorbell);\n\tif ((doorbell & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {\n\t\tmpt3sas_print_fault_code(ioc, doorbell &\n\t\t    MPI2_DOORBELL_DATA_MASK);\n\t} else if ((doorbell & MPI2_IOC_STATE_MASK) ==\n\t    MPI2_IOC_STATE_COREDUMP) {\n\t\tmpt3sas_print_coredump_info(ioc, doorbell &\n\t\t    MPI2_DOORBELL_DATA_MASK);\n\t} else {\n\t\twritel(0xC0FFEE00, &ioc->chip->Doorbell);\n\t\tioc_err(ioc, \"Firmware is halted due to command timeout\\n\");\n\t}\n\n\tif (ioc->fwfault_debug == 2)\n\t\tfor (;;)\n\t\t\t;\n\telse\n\t\tpanic(\"panic in %s\\n\", __func__);\n}\n\n \nstatic void\n_base_sas_ioc_info(struct MPT3SAS_ADAPTER *ioc, MPI2DefaultReply_t *mpi_reply,\n\tMPI2RequestHeader_t *request_hdr)\n{\n\tu16 ioc_status = le16_to_cpu(mpi_reply->IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tchar *desc = NULL;\n\tu16 frame_sz;\n\tchar *func_str = NULL;\n\n\t \n\tif (request_hdr->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||\n\t    request_hdr->Function == MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH ||\n\t    request_hdr->Function == MPI2_FUNCTION_EVENT_NOTIFICATION)\n\t\treturn;\n\n\tif (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)\n\t\treturn;\n\t \n\tif (request_hdr->Function == MPI2_FUNCTION_CONFIG) {\n\t\tMpi2ConfigRequest_t *rqst = (Mpi2ConfigRequest_t *)request_hdr;\n\n\t\tif ((rqst->ExtPageType ==\n\t\t    MPI2_CONFIG_EXTPAGETYPE_DRIVER_PERSISTENT_TRIGGER) &&\n\t\t    !(ioc->logging_level & MPT_DEBUG_CONFIG)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tswitch (ioc_status) {\n\n \n\n\tcase MPI2_IOCSTATUS_INVALID_FUNCTION:\n\t\tdesc = \"invalid function\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_BUSY:\n\t\tdesc = \"busy\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INVALID_SGL:\n\t\tdesc = \"invalid sgl\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INTERNAL_ERROR:\n\t\tdesc = \"internal error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INVALID_VPID:\n\t\tdesc = \"invalid vpid\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INSUFFICIENT_RESOURCES:\n\t\tdesc = \"insufficient resources\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INSUFFICIENT_POWER:\n\t\tdesc = \"insufficient power\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INVALID_FIELD:\n\t\tdesc = \"invalid field\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INVALID_STATE:\n\t\tdesc = \"invalid state\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_OP_STATE_NOT_SUPPORTED:\n\t\tdesc = \"op state not supported\";\n\t\tbreak;\n\n \n\n\tcase MPI2_IOCSTATUS_CONFIG_INVALID_ACTION:\n\t\tdesc = \"config invalid action\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_CONFIG_INVALID_TYPE:\n\t\tdesc = \"config invalid type\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_CONFIG_INVALID_PAGE:\n\t\tdesc = \"config invalid page\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_CONFIG_INVALID_DATA:\n\t\tdesc = \"config invalid data\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_CONFIG_NO_DEFAULTS:\n\t\tdesc = \"config no defaults\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_CONFIG_CANT_COMMIT:\n\t\tdesc = \"config can't commit\";\n\t\tbreak;\n\n \n\n\tcase MPI2_IOCSTATUS_SCSI_RECOVERED_ERROR:\n\tcase MPI2_IOCSTATUS_SCSI_INVALID_DEVHANDLE:\n\tcase MPI2_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\n\tcase MPI2_IOCSTATUS_SCSI_DATA_OVERRUN:\n\tcase MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN:\n\tcase MPI2_IOCSTATUS_SCSI_IO_DATA_ERROR:\n\tcase MPI2_IOCSTATUS_SCSI_PROTOCOL_ERROR:\n\tcase MPI2_IOCSTATUS_SCSI_TASK_TERMINATED:\n\tcase MPI2_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:\n\tcase MPI2_IOCSTATUS_SCSI_TASK_MGMT_FAILED:\n\tcase MPI2_IOCSTATUS_SCSI_IOC_TERMINATED:\n\tcase MPI2_IOCSTATUS_SCSI_EXT_TERMINATED:\n\t\tbreak;\n\n \n\n\tcase MPI2_IOCSTATUS_EEDP_GUARD_ERROR:\n\t\tdesc = \"eedp guard error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:\n\t\tdesc = \"eedp ref tag error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:\n\t\tdesc = \"eedp app tag error\";\n\t\tbreak;\n\n \n\n\tcase MPI2_IOCSTATUS_TARGET_INVALID_IO_INDEX:\n\t\tdesc = \"target invalid io index\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_ABORTED:\n\t\tdesc = \"target aborted\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_NO_CONN_RETRYABLE:\n\t\tdesc = \"target no conn retryable\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_NO_CONNECTION:\n\t\tdesc = \"target no connection\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_XFER_COUNT_MISMATCH:\n\t\tdesc = \"target xfer count mismatch\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_DATA_OFFSET_ERROR:\n\t\tdesc = \"target data offset error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_TOO_MUCH_WRITE_DATA:\n\t\tdesc = \"target too much write data\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_IU_TOO_SHORT:\n\t\tdesc = \"target iu too short\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_ACK_NAK_TIMEOUT:\n\t\tdesc = \"target ack nak timeout\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_NAK_RECEIVED:\n\t\tdesc = \"target nak received\";\n\t\tbreak;\n\n \n\n\tcase MPI2_IOCSTATUS_SAS_SMP_REQUEST_FAILED:\n\t\tdesc = \"smp request failed\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SAS_SMP_DATA_OVERRUN:\n\t\tdesc = \"smp data overrun\";\n\t\tbreak;\n\n \n\n\tcase MPI2_IOCSTATUS_DIAGNOSTIC_RELEASED:\n\t\tdesc = \"diagnostic released\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!desc)\n\t\treturn;\n\n\tswitch (request_hdr->Function) {\n\tcase MPI2_FUNCTION_CONFIG:\n\t\tframe_sz = sizeof(Mpi2ConfigRequest_t) + ioc->sge_size;\n\t\tfunc_str = \"config_page\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_SCSI_TASK_MGMT:\n\t\tframe_sz = sizeof(Mpi2SCSITaskManagementRequest_t);\n\t\tfunc_str = \"task_mgmt\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_SAS_IO_UNIT_CONTROL:\n\t\tframe_sz = sizeof(Mpi2SasIoUnitControlRequest_t);\n\t\tfunc_str = \"sas_iounit_ctl\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_SCSI_ENCLOSURE_PROCESSOR:\n\t\tframe_sz = sizeof(Mpi2SepRequest_t);\n\t\tfunc_str = \"enclosure\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_IOC_INIT:\n\t\tframe_sz = sizeof(Mpi2IOCInitRequest_t);\n\t\tfunc_str = \"ioc_init\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_PORT_ENABLE:\n\t\tframe_sz = sizeof(Mpi2PortEnableRequest_t);\n\t\tfunc_str = \"port_enable\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_SMP_PASSTHROUGH:\n\t\tframe_sz = sizeof(Mpi2SmpPassthroughRequest_t) + ioc->sge_size;\n\t\tfunc_str = \"smp_passthru\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_NVME_ENCAPSULATED:\n\t\tframe_sz = sizeof(Mpi26NVMeEncapsulatedRequest_t) +\n\t\t    ioc->sge_size;\n\t\tfunc_str = \"nvme_encapsulated\";\n\t\tbreak;\n\tdefault:\n\t\tframe_sz = 32;\n\t\tfunc_str = \"unknown\";\n\t\tbreak;\n\t}\n\n\tioc_warn(ioc, \"ioc_status: %s(0x%04x), request(0x%p),(%s)\\n\",\n\t\t desc, ioc_status, request_hdr, func_str);\n\n\t_debug_dump_mf(request_hdr, frame_sz/4);\n}\n\n \nstatic void\n_base_display_event_data(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventNotificationReply_t *mpi_reply)\n{\n\tchar *desc = NULL;\n\tu16 event;\n\n\tif (!(ioc->logging_level & MPT_DEBUG_EVENTS))\n\t\treturn;\n\n\tevent = le16_to_cpu(mpi_reply->Event);\n\n\tswitch (event) {\n\tcase MPI2_EVENT_LOG_DATA:\n\t\tdesc = \"Log Data\";\n\t\tbreak;\n\tcase MPI2_EVENT_STATE_CHANGE:\n\t\tdesc = \"Status Change\";\n\t\tbreak;\n\tcase MPI2_EVENT_HARD_RESET_RECEIVED:\n\t\tdesc = \"Hard Reset Received\";\n\t\tbreak;\n\tcase MPI2_EVENT_EVENT_CHANGE:\n\t\tdesc = \"Event Change\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE:\n\t\tdesc = \"Device Status Change\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_OPERATION_STATUS:\n\t\tif (!ioc->hide_ir_msg)\n\t\t\tdesc = \"IR Operation Status\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DISCOVERY:\n\t{\n\t\tMpi2EventDataSasDiscovery_t *event_data =\n\t\t    (Mpi2EventDataSasDiscovery_t *)mpi_reply->EventData;\n\t\tioc_info(ioc, \"Discovery: (%s)\",\n\t\t\t event_data->ReasonCode == MPI2_EVENT_SAS_DISC_RC_STARTED ?\n\t\t\t \"start\" : \"stop\");\n\t\tif (event_data->DiscoveryStatus)\n\t\t\tpr_cont(\" discovery_status(0x%08x)\",\n\t\t\t    le32_to_cpu(event_data->DiscoveryStatus));\n\t\tpr_cont(\"\\n\");\n\t\treturn;\n\t}\n\tcase MPI2_EVENT_SAS_BROADCAST_PRIMITIVE:\n\t\tdesc = \"SAS Broadcast Primitive\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_INIT_DEVICE_STATUS_CHANGE:\n\t\tdesc = \"SAS Init Device Status Change\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_INIT_TABLE_OVERFLOW:\n\t\tdesc = \"SAS Init Table Overflow\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST:\n\t\tdesc = \"SAS Topology Change List\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE:\n\t\tdesc = \"SAS Enclosure Device Status Change\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_VOLUME:\n\t\tif (!ioc->hide_ir_msg)\n\t\t\tdesc = \"IR Volume\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_PHYSICAL_DISK:\n\t\tif (!ioc->hide_ir_msg)\n\t\t\tdesc = \"IR Physical Disk\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST:\n\t\tif (!ioc->hide_ir_msg)\n\t\t\tdesc = \"IR Configuration Change List\";\n\t\tbreak;\n\tcase MPI2_EVENT_LOG_ENTRY_ADDED:\n\t\tif (!ioc->hide_ir_msg)\n\t\t\tdesc = \"Log Entry Added\";\n\t\tbreak;\n\tcase MPI2_EVENT_TEMP_THRESHOLD:\n\t\tdesc = \"Temperature Threshold\";\n\t\tbreak;\n\tcase MPI2_EVENT_ACTIVE_CABLE_EXCEPTION:\n\t\tdesc = \"Cable Event\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEVICE_DISCOVERY_ERROR:\n\t\tdesc = \"SAS Device Discovery Error\";\n\t\tbreak;\n\tcase MPI2_EVENT_PCIE_DEVICE_STATUS_CHANGE:\n\t\tdesc = \"PCIE Device Status Change\";\n\t\tbreak;\n\tcase MPI2_EVENT_PCIE_ENUMERATION:\n\t{\n\t\tMpi26EventDataPCIeEnumeration_t *event_data =\n\t\t\t(Mpi26EventDataPCIeEnumeration_t *)mpi_reply->EventData;\n\t\tioc_info(ioc, \"PCIE Enumeration: (%s)\",\n\t\t\t event_data->ReasonCode == MPI26_EVENT_PCIE_ENUM_RC_STARTED ?\n\t\t\t \"start\" : \"stop\");\n\t\tif (event_data->EnumerationStatus)\n\t\t\tpr_cont(\"enumeration_status(0x%08x)\",\n\t\t\t\tle32_to_cpu(event_data->EnumerationStatus));\n\t\tpr_cont(\"\\n\");\n\t\treturn;\n\t}\n\tcase MPI2_EVENT_PCIE_TOPOLOGY_CHANGE_LIST:\n\t\tdesc = \"PCIE Topology Change List\";\n\t\tbreak;\n\t}\n\n\tif (!desc)\n\t\treturn;\n\n\tioc_info(ioc, \"%s\\n\", desc);\n}\n\n \nstatic void\n_base_sas_log_info(struct MPT3SAS_ADAPTER *ioc, u32 log_info)\n{\n\tunion loginfo_type {\n\t\tu32\tloginfo;\n\t\tstruct {\n\t\t\tu32\tsubcode:16;\n\t\t\tu32\tcode:8;\n\t\t\tu32\toriginator:4;\n\t\t\tu32\tbus_type:4;\n\t\t} dw;\n\t};\n\tunion loginfo_type sas_loginfo;\n\tchar *originator_str = NULL;\n\n\tsas_loginfo.loginfo = log_info;\n\tif (sas_loginfo.dw.bus_type != 3  )\n\t\treturn;\n\n\t \n\tif (log_info == 0x31170000)\n\t\treturn;\n\n\t \n\tif (ioc->ignore_loginfos && (log_info == 0x30050000 || log_info ==\n\t    0x31140000 || log_info == 0x31130000))\n\t\treturn;\n\n\tswitch (sas_loginfo.dw.originator) {\n\tcase 0:\n\t\toriginator_str = \"IOP\";\n\t\tbreak;\n\tcase 1:\n\t\toriginator_str = \"PL\";\n\t\tbreak;\n\tcase 2:\n\t\tif (!ioc->hide_ir_msg)\n\t\t\toriginator_str = \"IR\";\n\t\telse\n\t\t\toriginator_str = \"WarpDrive\";\n\t\tbreak;\n\t}\n\n\tioc_warn(ioc, \"log_info(0x%08x): originator(%s), code(0x%02x), sub_code(0x%04x)\\n\",\n\t\t log_info,\n\t\t originator_str, sas_loginfo.dw.code, sas_loginfo.dw.subcode);\n}\n\n \nstatic void\n_base_display_reply_info(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\n\tu32 reply)\n{\n\tMPI2DefaultReply_t *mpi_reply;\n\tu16 ioc_status;\n\tu32 loginfo = 0;\n\n\tmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tif (unlikely(!mpi_reply)) {\n\t\tioc_err(ioc, \"mpi_reply not valid at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\tioc_status = le16_to_cpu(mpi_reply->IOCStatus);\n\n\tif ((ioc_status & MPI2_IOCSTATUS_MASK) &&\n\t    (ioc->logging_level & MPT_DEBUG_REPLY)) {\n\t\t_base_sas_ioc_info(ioc, mpi_reply,\n\t\t   mpt3sas_base_get_msg_frame(ioc, smid));\n\t}\n\n\tif (ioc_status & MPI2_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE) {\n\t\tloginfo = le32_to_cpu(mpi_reply->IOCLogInfo);\n\t\t_base_sas_log_info(ioc, loginfo);\n\t}\n\n\tif (ioc_status || loginfo) {\n\t\tioc_status &= MPI2_IOCSTATUS_MASK;\n\t\tmpt3sas_trigger_mpi(ioc, ioc_status, loginfo);\n\t}\n}\n\n \nu8\nmpt3sas_base_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\n\tu32 reply)\n{\n\tMPI2DefaultReply_t *mpi_reply;\n\n\tmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tif (mpi_reply && mpi_reply->Function == MPI2_FUNCTION_EVENT_ACK)\n\t\treturn mpt3sas_check_for_pending_internal_cmds(ioc, smid);\n\n\tif (ioc->base_cmds.status == MPT3_CMD_NOT_USED)\n\t\treturn 1;\n\n\tioc->base_cmds.status |= MPT3_CMD_COMPLETE;\n\tif (mpi_reply) {\n\t\tioc->base_cmds.status |= MPT3_CMD_REPLY_VALID;\n\t\tmemcpy(ioc->base_cmds.reply, mpi_reply, mpi_reply->MsgLength*4);\n\t}\n\tioc->base_cmds.status &= ~MPT3_CMD_PENDING;\n\n\tcomplete(&ioc->base_cmds.done);\n\treturn 1;\n}\n\n \nstatic u8\n_base_async_event(struct MPT3SAS_ADAPTER *ioc, u8 msix_index, u32 reply)\n{\n\tMpi2EventNotificationReply_t *mpi_reply;\n\tMpi2EventAckRequest_t *ack_request;\n\tu16 smid;\n\tstruct _event_ack_list *delayed_event_ack;\n\n\tmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tif (!mpi_reply)\n\t\treturn 1;\n\tif (mpi_reply->Function != MPI2_FUNCTION_EVENT_NOTIFICATION)\n\t\treturn 1;\n\n\t_base_display_event_data(ioc, mpi_reply);\n\n\tif (!(mpi_reply->AckRequired & MPI2_EVENT_NOTIFICATION_ACK_REQUIRED))\n\t\tgoto out;\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);\n\tif (!smid) {\n\t\tdelayed_event_ack = kzalloc(sizeof(*delayed_event_ack),\n\t\t\t\t\tGFP_ATOMIC);\n\t\tif (!delayed_event_ack)\n\t\t\tgoto out;\n\t\tINIT_LIST_HEAD(&delayed_event_ack->list);\n\t\tdelayed_event_ack->Event = mpi_reply->Event;\n\t\tdelayed_event_ack->EventContext = mpi_reply->EventContext;\n\t\tlist_add_tail(&delayed_event_ack->list,\n\t\t\t\t&ioc->delayed_event_ack_list);\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"DELAYED: EVENT ACK: event (0x%04x)\\n\",\n\t\t\t\t    le16_to_cpu(mpi_reply->Event)));\n\t\tgoto out;\n\t}\n\n\tack_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(ack_request, 0, sizeof(Mpi2EventAckRequest_t));\n\tack_request->Function = MPI2_FUNCTION_EVENT_ACK;\n\tack_request->Event = mpi_reply->Event;\n\tack_request->EventContext = mpi_reply->EventContext;\n\tack_request->VF_ID = 0;   \n\tack_request->VP_ID = 0;\n\tioc->put_smid_default(ioc, smid);\n\n out:\n\n\t \n\tmpt3sas_scsih_event_callback(ioc, msix_index, reply);\n\n\t \n\tmpt3sas_ctl_event_callback(ioc, msix_index, reply);\n\n\treturn 1;\n}\n\nstatic struct scsiio_tracker *\n_get_st_from_smid(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tstruct scsi_cmnd *cmd;\n\n\tif (WARN_ON(!smid) ||\n\t    WARN_ON(smid >= ioc->hi_priority_smid))\n\t\treturn NULL;\n\n\tcmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);\n\tif (cmd)\n\t\treturn scsi_cmd_priv(cmd);\n\n\treturn NULL;\n}\n\n \nstatic u8\n_base_get_cb_idx(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tint i;\n\tu16 ctl_smid = ioc->scsiio_depth - INTERNAL_SCSIIO_CMDS_COUNT + 1;\n\tu8 cb_idx = 0xFF;\n\n\tif (smid < ioc->hi_priority_smid) {\n\t\tstruct scsiio_tracker *st;\n\n\t\tif (smid < ctl_smid) {\n\t\t\tst = _get_st_from_smid(ioc, smid);\n\t\t\tif (st)\n\t\t\t\tcb_idx = st->cb_idx;\n\t\t} else if (smid == ctl_smid)\n\t\t\tcb_idx = ioc->ctl_cb_idx;\n\t} else if (smid < ioc->internal_smid) {\n\t\ti = smid - ioc->hi_priority_smid;\n\t\tcb_idx = ioc->hpr_lookup[i].cb_idx;\n\t} else if (smid <= ioc->hba_queue_depth) {\n\t\ti = smid - ioc->internal_smid;\n\t\tcb_idx = ioc->internal_lookup[i].cb_idx;\n\t}\n\treturn cb_idx;\n}\n\n \nvoid\nmpt3sas_base_pause_mq_polling(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint iopoll_q_count =\n\t    ioc->reply_queue_count - ioc->iopoll_q_start_index;\n\tint qid;\n\n\tfor (qid = 0; qid < iopoll_q_count; qid++)\n\t\tatomic_set(&ioc->io_uring_poll_queues[qid].pause, 1);\n\n\t \n\tfor (qid = 0; qid < iopoll_q_count; qid++) {\n\t\twhile (atomic_read(&ioc->io_uring_poll_queues[qid].busy)) {\n\t\t\tcpu_relax();\n\t\t\tudelay(500);\n\t\t}\n\t}\n}\n\n \nvoid\nmpt3sas_base_resume_mq_polling(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint iopoll_q_count =\n\t    ioc->reply_queue_count - ioc->iopoll_q_start_index;\n\tint qid;\n\n\tfor (qid = 0; qid < iopoll_q_count; qid++)\n\t\tatomic_set(&ioc->io_uring_poll_queues[qid].pause, 0);\n}\n\n \nvoid\nmpt3sas_base_mask_interrupts(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 him_register;\n\n\tioc->mask_interrupts = 1;\n\thim_register = ioc->base_readl(&ioc->chip->HostInterruptMask);\n\thim_register |= MPI2_HIM_DIM + MPI2_HIM_RIM + MPI2_HIM_RESET_IRQ_MASK;\n\twritel(him_register, &ioc->chip->HostInterruptMask);\n\tioc->base_readl(&ioc->chip->HostInterruptMask);\n}\n\n \nvoid\nmpt3sas_base_unmask_interrupts(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 him_register;\n\n\thim_register = ioc->base_readl(&ioc->chip->HostInterruptMask);\n\thim_register &= ~MPI2_HIM_RIM;\n\twritel(him_register, &ioc->chip->HostInterruptMask);\n\tioc->mask_interrupts = 0;\n}\n\nunion reply_descriptor {\n\tu64 word;\n\tstruct {\n\t\tu32 low;\n\t\tu32 high;\n\t} u;\n};\n\nstatic u32 base_mod64(u64 dividend, u32 divisor)\n{\n\tu32 remainder;\n\n\tif (!divisor)\n\t\tpr_err(\"mpt3sas: DIVISOR is zero, in div fn\\n\");\n\tremainder = do_div(dividend, divisor);\n\treturn remainder;\n}\n\n \nstatic int\n_base_process_reply_queue(struct adapter_reply_queue *reply_q)\n{\n\tunion reply_descriptor rd;\n\tu64 completed_cmds;\n\tu8 request_descript_type;\n\tu16 smid;\n\tu8 cb_idx;\n\tu32 reply;\n\tu8 msix_index = reply_q->msix_index;\n\tstruct MPT3SAS_ADAPTER *ioc = reply_q->ioc;\n\tMpi2ReplyDescriptorsUnion_t *rpf;\n\tu8 rc;\n\n\tcompleted_cmds = 0;\n\tif (!atomic_add_unless(&reply_q->busy, 1, 1))\n\t\treturn completed_cmds;\n\n\trpf = &reply_q->reply_post_free[reply_q->reply_post_host_index];\n\trequest_descript_type = rpf->Default.ReplyFlags\n\t     & MPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK;\n\tif (request_descript_type == MPI2_RPY_DESCRIPT_FLAGS_UNUSED) {\n\t\tatomic_dec(&reply_q->busy);\n\t\treturn completed_cmds;\n\t}\n\n\tcb_idx = 0xFF;\n\tdo {\n\t\trd.word = le64_to_cpu(rpf->Words);\n\t\tif (rd.u.low == UINT_MAX || rd.u.high == UINT_MAX)\n\t\t\tgoto out;\n\t\treply = 0;\n\t\tsmid = le16_to_cpu(rpf->Default.DescriptorTypeDependent1);\n\t\tif (request_descript_type ==\n\t\t    MPI25_RPY_DESCRIPT_FLAGS_FAST_PATH_SCSI_IO_SUCCESS ||\n\t\t    request_descript_type ==\n\t\t    MPI2_RPY_DESCRIPT_FLAGS_SCSI_IO_SUCCESS ||\n\t\t    request_descript_type ==\n\t\t    MPI26_RPY_DESCRIPT_FLAGS_PCIE_ENCAPSULATED_SUCCESS) {\n\t\t\tcb_idx = _base_get_cb_idx(ioc, smid);\n\t\t\tif ((likely(cb_idx < MPT_MAX_CALLBACKS)) &&\n\t\t\t    (likely(mpt_callbacks[cb_idx] != NULL))) {\n\t\t\t\trc = mpt_callbacks[cb_idx](ioc, smid,\n\t\t\t\t    msix_index, 0);\n\t\t\t\tif (rc)\n\t\t\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\t}\n\t\t} else if (request_descript_type ==\n\t\t    MPI2_RPY_DESCRIPT_FLAGS_ADDRESS_REPLY) {\n\t\t\treply = le32_to_cpu(\n\t\t\t    rpf->AddressReply.ReplyFrameAddress);\n\t\t\tif (reply > ioc->reply_dma_max_address ||\n\t\t\t    reply < ioc->reply_dma_min_address)\n\t\t\t\treply = 0;\n\t\t\tif (smid) {\n\t\t\t\tcb_idx = _base_get_cb_idx(ioc, smid);\n\t\t\t\tif ((likely(cb_idx < MPT_MAX_CALLBACKS)) &&\n\t\t\t\t    (likely(mpt_callbacks[cb_idx] != NULL))) {\n\t\t\t\t\trc = mpt_callbacks[cb_idx](ioc, smid,\n\t\t\t\t\t    msix_index, reply);\n\t\t\t\t\tif (reply)\n\t\t\t\t\t\t_base_display_reply_info(ioc,\n\t\t\t\t\t\t    smid, msix_index, reply);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\tmpt3sas_base_free_smid(ioc,\n\t\t\t\t\t\t    smid);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_base_async_event(ioc, msix_index, reply);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (reply) {\n\t\t\t\tioc->reply_free_host_index =\n\t\t\t\t    (ioc->reply_free_host_index ==\n\t\t\t\t    (ioc->reply_free_queue_depth - 1)) ?\n\t\t\t\t    0 : ioc->reply_free_host_index + 1;\n\t\t\t\tioc->reply_free[ioc->reply_free_host_index] =\n\t\t\t\t    cpu_to_le32(reply);\n\t\t\t\tif (ioc->is_mcpu_endpoint)\n\t\t\t\t\t_base_clone_reply_to_sys_mem(ioc,\n\t\t\t\t\t\treply,\n\t\t\t\t\t\tioc->reply_free_host_index);\n\t\t\t\twritel(ioc->reply_free_host_index,\n\t\t\t\t    &ioc->chip->ReplyFreeHostIndex);\n\t\t\t}\n\t\t}\n\n\t\trpf->Words = cpu_to_le64(ULLONG_MAX);\n\t\treply_q->reply_post_host_index =\n\t\t    (reply_q->reply_post_host_index ==\n\t\t    (ioc->reply_post_queue_depth - 1)) ? 0 :\n\t\t    reply_q->reply_post_host_index + 1;\n\t\trequest_descript_type =\n\t\t    reply_q->reply_post_free[reply_q->reply_post_host_index].\n\t\t    Default.ReplyFlags & MPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK;\n\t\tcompleted_cmds++;\n\t\t \n\t\tif (completed_cmds >= ioc->thresh_hold) {\n\t\t\tif (ioc->combined_reply_queue) {\n\t\t\t\twritel(reply_q->reply_post_host_index |\n\t\t\t\t\t\t((msix_index  & 7) <<\n\t\t\t\t\t\t MPI2_RPHI_MSIX_INDEX_SHIFT),\n\t\t\t\t    ioc->replyPostRegisterIndex[msix_index/8]);\n\t\t\t} else {\n\t\t\t\twritel(reply_q->reply_post_host_index |\n\t\t\t\t\t\t(msix_index <<\n\t\t\t\t\t\t MPI2_RPHI_MSIX_INDEX_SHIFT),\n\t\t\t\t\t\t&ioc->chip->ReplyPostHostIndex);\n\t\t\t}\n\t\t\tif (!reply_q->is_iouring_poll_q &&\n\t\t\t    !reply_q->irq_poll_scheduled) {\n\t\t\t\treply_q->irq_poll_scheduled = true;\n\t\t\t\tirq_poll_sched(&reply_q->irqpoll);\n\t\t\t}\n\t\t\tatomic_dec(&reply_q->busy);\n\t\t\treturn completed_cmds;\n\t\t}\n\t\tif (request_descript_type == MPI2_RPY_DESCRIPT_FLAGS_UNUSED)\n\t\t\tgoto out;\n\t\tif (!reply_q->reply_post_host_index)\n\t\t\trpf = reply_q->reply_post_free;\n\t\telse\n\t\t\trpf++;\n\t} while (1);\n\n out:\n\n\tif (!completed_cmds) {\n\t\tatomic_dec(&reply_q->busy);\n\t\treturn completed_cmds;\n\t}\n\n\tif (ioc->is_warpdrive) {\n\t\twritel(reply_q->reply_post_host_index,\n\t\tioc->reply_post_host_index[msix_index]);\n\t\tatomic_dec(&reply_q->busy);\n\t\treturn completed_cmds;\n\t}\n\n\t \n\tif (ioc->combined_reply_queue)\n\t\twritel(reply_q->reply_post_host_index | ((msix_index  & 7) <<\n\t\t\tMPI2_RPHI_MSIX_INDEX_SHIFT),\n\t\t\tioc->replyPostRegisterIndex[msix_index/8]);\n\telse\n\t\twritel(reply_q->reply_post_host_index | (msix_index <<\n\t\t\tMPI2_RPHI_MSIX_INDEX_SHIFT),\n\t\t\t&ioc->chip->ReplyPostHostIndex);\n\tatomic_dec(&reply_q->busy);\n\treturn completed_cmds;\n}\n\n \nint mpt3sas_blk_mq_poll(struct Scsi_Host *shost, unsigned int queue_num)\n{\n\tstruct MPT3SAS_ADAPTER *ioc =\n\t    (struct MPT3SAS_ADAPTER *)shost->hostdata;\n\tstruct adapter_reply_queue *reply_q;\n\tint num_entries = 0;\n\tint qid = queue_num - ioc->iopoll_q_start_index;\n\n\tif (atomic_read(&ioc->io_uring_poll_queues[qid].pause) ||\n\t    !atomic_add_unless(&ioc->io_uring_poll_queues[qid].busy, 1, 1))\n\t\treturn 0;\n\n\treply_q = ioc->io_uring_poll_queues[qid].reply_q;\n\n\tnum_entries = _base_process_reply_queue(reply_q);\n\tatomic_dec(&ioc->io_uring_poll_queues[qid].busy);\n\n\treturn num_entries;\n}\n\n \nstatic irqreturn_t\n_base_interrupt(int irq, void *bus_id)\n{\n\tstruct adapter_reply_queue *reply_q = bus_id;\n\tstruct MPT3SAS_ADAPTER *ioc = reply_q->ioc;\n\n\tif (ioc->mask_interrupts)\n\t\treturn IRQ_NONE;\n\tif (reply_q->irq_poll_scheduled)\n\t\treturn IRQ_HANDLED;\n\treturn ((_base_process_reply_queue(reply_q) > 0) ?\n\t\t\tIRQ_HANDLED : IRQ_NONE);\n}\n\n \nstatic int\n_base_irqpoll(struct irq_poll *irqpoll, int budget)\n{\n\tstruct adapter_reply_queue *reply_q;\n\tint num_entries = 0;\n\n\treply_q = container_of(irqpoll, struct adapter_reply_queue,\n\t\t\tirqpoll);\n\tif (reply_q->irq_line_enable) {\n\t\tdisable_irq_nosync(reply_q->os_irq);\n\t\treply_q->irq_line_enable = false;\n\t}\n\tnum_entries = _base_process_reply_queue(reply_q);\n\tif (num_entries < budget) {\n\t\tirq_poll_complete(irqpoll);\n\t\treply_q->irq_poll_scheduled = false;\n\t\treply_q->irq_line_enable = true;\n\t\tenable_irq(reply_q->os_irq);\n\t\t \n\t\t_base_process_reply_queue(reply_q);\n\t}\n\n\treturn num_entries;\n}\n\n \nstatic void\n_base_init_irqpolls(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct adapter_reply_queue *reply_q, *next;\n\n\tif (list_empty(&ioc->reply_queue_list))\n\t\treturn;\n\n\tlist_for_each_entry_safe(reply_q, next, &ioc->reply_queue_list, list) {\n\t\tif (reply_q->is_iouring_poll_q)\n\t\t\tcontinue;\n\t\tirq_poll_init(&reply_q->irqpoll,\n\t\t\tioc->hba_queue_depth/4, _base_irqpoll);\n\t\treply_q->irq_poll_scheduled = false;\n\t\treply_q->irq_line_enable = true;\n\t\treply_q->os_irq = pci_irq_vector(ioc->pdev,\n\t\t    reply_q->msix_index);\n\t}\n}\n\n \nstatic inline int\n_base_is_controller_msix_enabled(struct MPT3SAS_ADAPTER *ioc)\n{\n\treturn (ioc->facts.IOCCapabilities &\n\t    MPI2_IOCFACTS_CAPABILITY_MSI_X_INDEX) && ioc->msix_enable;\n}\n\n \nvoid\nmpt3sas_base_sync_reply_irqs(struct MPT3SAS_ADAPTER *ioc, u8 poll)\n{\n\tstruct adapter_reply_queue *reply_q;\n\n\t \n\tif (!_base_is_controller_msix_enabled(ioc))\n\t\treturn;\n\n\tlist_for_each_entry(reply_q, &ioc->reply_queue_list, list) {\n\t\tif (ioc->shost_recovery || ioc->remove_host ||\n\t\t\t\tioc->pci_error_recovery)\n\t\t\treturn;\n\t\t \n\t\tif (reply_q->msix_index == 0)\n\t\t\tcontinue;\n\n\t\tif (reply_q->is_iouring_poll_q) {\n\t\t\t_base_process_reply_queue(reply_q);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsynchronize_irq(pci_irq_vector(ioc->pdev, reply_q->msix_index));\n\t\tif (reply_q->irq_poll_scheduled) {\n\t\t\t \n\t\t\tirq_poll_disable(&reply_q->irqpoll);\n\t\t\tirq_poll_enable(&reply_q->irqpoll);\n\t\t\t \n\t\t\tif (reply_q->irq_poll_scheduled) {\n\t\t\t\treply_q->irq_poll_scheduled = false;\n\t\t\t\treply_q->irq_line_enable = true;\n\t\t\t\tenable_irq(reply_q->os_irq);\n\t\t\t}\n\t\t}\n\n\t\tif (poll)\n\t\t\t_base_process_reply_queue(reply_q);\n\t}\n}\n\n \nvoid\nmpt3sas_base_release_callback_handler(u8 cb_idx)\n{\n\tmpt_callbacks[cb_idx] = NULL;\n}\n\n \nu8\nmpt3sas_base_register_callback_handler(MPT_CALLBACK cb_func)\n{\n\tu8 cb_idx;\n\n\tfor (cb_idx = MPT_MAX_CALLBACKS-1; cb_idx; cb_idx--)\n\t\tif (mpt_callbacks[cb_idx] == NULL)\n\t\t\tbreak;\n\n\tmpt_callbacks[cb_idx] = cb_func;\n\treturn cb_idx;\n}\n\n \nvoid\nmpt3sas_base_initialize_callback_handler(void)\n{\n\tu8 cb_idx;\n\n\tfor (cb_idx = 0; cb_idx < MPT_MAX_CALLBACKS; cb_idx++)\n\t\tmpt3sas_base_release_callback_handler(cb_idx);\n}\n\n\n \nstatic void\n_base_build_zero_len_sge(struct MPT3SAS_ADAPTER *ioc, void *paddr)\n{\n\tu32 flags_length = (u32)((MPI2_SGE_FLAGS_LAST_ELEMENT |\n\t    MPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_END_OF_LIST |\n\t    MPI2_SGE_FLAGS_SIMPLE_ELEMENT) <<\n\t    MPI2_SGE_FLAGS_SHIFT);\n\tioc->base_add_sg_single(paddr, flags_length, -1);\n}\n\n \nstatic void\n_base_add_sg_single_32(void *paddr, u32 flags_length, dma_addr_t dma_addr)\n{\n\tMpi2SGESimple32_t *sgel = paddr;\n\n\tflags_length |= (MPI2_SGE_FLAGS_32_BIT_ADDRESSING |\n\t    MPI2_SGE_FLAGS_SYSTEM_ADDRESS) << MPI2_SGE_FLAGS_SHIFT;\n\tsgel->FlagsLength = cpu_to_le32(flags_length);\n\tsgel->Address = cpu_to_le32(dma_addr);\n}\n\n\n \nstatic void\n_base_add_sg_single_64(void *paddr, u32 flags_length, dma_addr_t dma_addr)\n{\n\tMpi2SGESimple64_t *sgel = paddr;\n\n\tflags_length |= (MPI2_SGE_FLAGS_64_BIT_ADDRESSING |\n\t    MPI2_SGE_FLAGS_SYSTEM_ADDRESS) << MPI2_SGE_FLAGS_SHIFT;\n\tsgel->FlagsLength = cpu_to_le32(flags_length);\n\tsgel->Address = cpu_to_le64(dma_addr);\n}\n\n \nstatic struct chain_tracker *\n_base_get_chain_buffer_tracker(struct MPT3SAS_ADAPTER *ioc,\n\t\t\t       struct scsi_cmnd *scmd)\n{\n\tstruct chain_tracker *chain_req;\n\tstruct scsiio_tracker *st = scsi_cmd_priv(scmd);\n\tu16 smid = st->smid;\n\tu8 chain_offset =\n\t   atomic_read(&ioc->chain_lookup[smid - 1].chain_offset);\n\n\tif (chain_offset == ioc->chains_needed_per_io)\n\t\treturn NULL;\n\n\tchain_req = &ioc->chain_lookup[smid - 1].chains_per_smid[chain_offset];\n\tatomic_inc(&ioc->chain_lookup[smid - 1].chain_offset);\n\treturn chain_req;\n}\n\n\n \nstatic void\n_base_build_sg(struct MPT3SAS_ADAPTER *ioc, void *psge,\n\tdma_addr_t data_out_dma, size_t data_out_sz, dma_addr_t data_in_dma,\n\tsize_t data_in_sz)\n{\n\tu32 sgl_flags;\n\n\tif (!data_out_sz && !data_in_sz) {\n\t\t_base_build_zero_len_sge(ioc, psge);\n\t\treturn;\n\t}\n\n\tif (data_out_sz && data_in_sz) {\n\t\t \n\t\tsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t    MPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_HOST_TO_IOC);\n\t\tsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\n\t\tioc->base_add_sg_single(psge, sgl_flags |\n\t\t    data_out_sz, data_out_dma);\n\n\t\t \n\t\tpsge += ioc->sge_size;\n\n\t\t \n\t\tsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t    MPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |\n\t\t    MPI2_SGE_FLAGS_END_OF_LIST);\n\t\tsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\n\t\tioc->base_add_sg_single(psge, sgl_flags |\n\t\t    data_in_sz, data_in_dma);\n\t} else if (data_out_sz)   {\n\t\tsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t    MPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |\n\t\t    MPI2_SGE_FLAGS_END_OF_LIST | MPI2_SGE_FLAGS_HOST_TO_IOC);\n\t\tsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\n\t\tioc->base_add_sg_single(psge, sgl_flags |\n\t\t    data_out_sz, data_out_dma);\n\t} else if (data_in_sz)   {\n\t\tsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t    MPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |\n\t\t    MPI2_SGE_FLAGS_END_OF_LIST);\n\t\tsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\n\t\tioc->base_add_sg_single(psge, sgl_flags |\n\t\t    data_in_sz, data_in_dma);\n\t}\n}\n\n \n\n \nstatic void\n_base_build_nvme_prp(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tMpi26NVMeEncapsulatedRequest_t *nvme_encap_request,\n\tdma_addr_t data_out_dma, size_t data_out_sz, dma_addr_t data_in_dma,\n\tsize_t data_in_sz)\n{\n\tint\t\tprp_size = NVME_PRP_SIZE;\n\t__le64\t\t*prp_entry, *prp1_entry, *prp2_entry;\n\t__le64\t\t*prp_page;\n\tdma_addr_t\tprp_entry_dma, prp_page_dma, dma_addr;\n\tu32\t\toffset, entry_len;\n\tu32\t\tpage_mask_result, page_mask;\n\tsize_t\t\tlength;\n\tstruct mpt3sas_nvme_cmd *nvme_cmd =\n\t\t(void *)nvme_encap_request->NVMe_Command;\n\n\t \n\tif (!data_in_sz && !data_out_sz)\n\t\treturn;\n\tprp1_entry = &nvme_cmd->prp1;\n\tprp2_entry = &nvme_cmd->prp2;\n\tprp_entry = prp1_entry;\n\t \n\tprp_page = (__le64 *)mpt3sas_base_get_pcie_sgl(ioc, smid);\n\tprp_page_dma = mpt3sas_base_get_pcie_sgl_dma(ioc, smid);\n\n\t \n\tpage_mask = ioc->page_size - 1;\n\tpage_mask_result = (uintptr_t)((u8 *)prp_page + prp_size) & page_mask;\n\tif (!page_mask_result) {\n\t\t \n\t\tprp_page = (__le64 *)((u8 *)prp_page + prp_size);\n\t\tprp_page_dma = prp_page_dma + prp_size;\n\t}\n\n\t \n\tprp_entry_dma = prp_page_dma;\n\n\t \n\tif (data_in_sz) {\n\t\tdma_addr = data_in_dma;\n\t\tlength = data_in_sz;\n\t} else {\n\t\tdma_addr = data_out_dma;\n\t\tlength = data_out_sz;\n\t}\n\n\t \n\twhile (length) {\n\t\t \n\t\tpage_mask_result = (prp_entry_dma + prp_size) & page_mask;\n\t\tif (!page_mask_result) {\n\t\t\t \n\t\t\tprp_entry_dma++;\n\t\t\t*prp_entry = cpu_to_le64(prp_entry_dma);\n\t\t\tprp_entry++;\n\t\t}\n\n\t\t \n\t\toffset = dma_addr & page_mask;\n\t\tentry_len = ioc->page_size - offset;\n\n\t\tif (prp_entry == prp1_entry) {\n\t\t\t \n\t\t\t*prp1_entry = cpu_to_le64(dma_addr);\n\n\t\t\t \n\t\t\tprp_entry = prp2_entry;\n\t\t} else if (prp_entry == prp2_entry) {\n\t\t\t \n\t\t\tif (length > ioc->page_size) {\n\t\t\t\t \n\t\t\t\t*prp2_entry = cpu_to_le64(prp_entry_dma);\n\n\t\t\t\t \n\t\t\t\tprp_entry = prp_page;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t*prp2_entry = cpu_to_le64(dma_addr);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\t*prp_entry = cpu_to_le64(dma_addr);\n\t\t\tprp_entry++;\n\t\t\tprp_entry_dma++;\n\t\t}\n\n\t\t \n\t\tdma_addr += entry_len;\n\n\t\t \n\t\tif (entry_len > length)\n\t\t\tlength = 0;\n\t\telse\n\t\t\tlength -= entry_len;\n\t}\n}\n\n \nstatic void\nbase_make_prp_nvme(struct MPT3SAS_ADAPTER *ioc,\n\t\tstruct scsi_cmnd *scmd,\n\t\tMpi25SCSIIORequest_t *mpi_request,\n\t\tu16 smid, int sge_count)\n{\n\tint sge_len, num_prp_in_chain = 0;\n\tMpi25IeeeSgeChain64_t *main_chain_element, *ptr_first_sgl;\n\t__le64 *curr_buff;\n\tdma_addr_t msg_dma, sge_addr, offset;\n\tu32 page_mask, page_mask_result;\n\tstruct scatterlist *sg_scmd;\n\tu32 first_prp_len;\n\tint data_len = scsi_bufflen(scmd);\n\tu32 nvme_pg_size;\n\n\tnvme_pg_size = max_t(u32, ioc->page_size, NVME_PRP_PAGE_SIZE);\n\t \n\tpage_mask = nvme_pg_size - 1;\n\n\t \n\n\t \n\tmain_chain_element = (pMpi25IeeeSgeChain64_t)&mpi_request->SGL;\n\t \n\tmain_chain_element = (Mpi25IeeeSgeChain64_t *)\n\t\t((u8 *)main_chain_element + sizeof(MPI25_IEEE_SGE_CHAIN64));\n\n\t \n\tcurr_buff = mpt3sas_base_get_pcie_sgl(ioc, smid);\n\tmsg_dma = mpt3sas_base_get_pcie_sgl_dma(ioc, smid);\n\n\tmain_chain_element->Address = cpu_to_le64(msg_dma);\n\tmain_chain_element->NextChainOffset = 0;\n\tmain_chain_element->Flags = MPI2_IEEE_SGE_FLAGS_CHAIN_ELEMENT |\n\t\t\tMPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR |\n\t\t\tMPI26_IEEE_SGE_FLAGS_NSF_NVME_PRP;\n\n\t \n\tptr_first_sgl = (pMpi25IeeeSgeChain64_t)&mpi_request->SGL;\n\tsg_scmd = scsi_sglist(scmd);\n\tsge_addr = sg_dma_address(sg_scmd);\n\tsge_len = sg_dma_len(sg_scmd);\n\n\toffset = sge_addr & page_mask;\n\tfirst_prp_len = nvme_pg_size - offset;\n\n\tptr_first_sgl->Address = cpu_to_le64(sge_addr);\n\tptr_first_sgl->Length = cpu_to_le32(first_prp_len);\n\n\tdata_len -= first_prp_len;\n\n\tif (sge_len > first_prp_len) {\n\t\tsge_addr += first_prp_len;\n\t\tsge_len -= first_prp_len;\n\t} else if (data_len && (sge_len == first_prp_len)) {\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsge_addr = sg_dma_address(sg_scmd);\n\t\tsge_len = sg_dma_len(sg_scmd);\n\t}\n\n\tfor (;;) {\n\t\toffset = sge_addr & page_mask;\n\n\t\t \n\t\tpage_mask_result = (uintptr_t)(curr_buff + 1) & page_mask;\n\t\tif (unlikely(!page_mask_result)) {\n\t\t\tscmd_printk(KERN_NOTICE,\n\t\t\t\tscmd, \"page boundary curr_buff: 0x%p\\n\",\n\t\t\t\tcurr_buff);\n\t\t\tmsg_dma += 8;\n\t\t\t*curr_buff = cpu_to_le64(msg_dma);\n\t\t\tcurr_buff++;\n\t\t\tnum_prp_in_chain++;\n\t\t}\n\n\t\t*curr_buff = cpu_to_le64(sge_addr);\n\t\tcurr_buff++;\n\t\tmsg_dma += 8;\n\t\tnum_prp_in_chain++;\n\n\t\tsge_addr += nvme_pg_size;\n\t\tsge_len -= nvme_pg_size;\n\t\tdata_len -= nvme_pg_size;\n\n\t\tif (data_len <= 0)\n\t\t\tbreak;\n\n\t\tif (sge_len > 0)\n\t\t\tcontinue;\n\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsge_addr = sg_dma_address(sg_scmd);\n\t\tsge_len = sg_dma_len(sg_scmd);\n\t}\n\n\tmain_chain_element->Length =\n\t\tcpu_to_le32(num_prp_in_chain * sizeof(u64));\n\treturn;\n}\n\nstatic bool\nbase_is_prp_possible(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _pcie_device *pcie_device, struct scsi_cmnd *scmd, int sge_count)\n{\n\tu32 data_length = 0;\n\tbool build_prp = true;\n\n\tdata_length = scsi_bufflen(scmd);\n\tif (pcie_device &&\n\t    (mpt3sas_scsih_is_pcie_scsi_device(pcie_device->device_info))) {\n\t\tbuild_prp = false;\n\t\treturn build_prp;\n\t}\n\n\t \n\tif ((data_length <= NVME_PRP_PAGE_SIZE*4) && (sge_count <= 2))\n\t\tbuild_prp = false;\n\n\treturn build_prp;\n}\n\n \nstatic int\n_base_check_pcie_native_sgl(struct MPT3SAS_ADAPTER *ioc,\n\tMpi25SCSIIORequest_t *mpi_request, u16 smid, struct scsi_cmnd *scmd,\n\tstruct _pcie_device *pcie_device)\n{\n\tint sges_left;\n\n\t \n\tsges_left = scsi_dma_map(scmd);\n\tif (sges_left < 0)\n\t\treturn 1;\n\n\t \n\tif (!base_is_prp_possible(ioc, pcie_device,\n\t\t\t\tscmd, sges_left)) {\n\t\t \n\t\tgoto out;\n\t}\n\n\t \n\tbase_make_prp_nvme(ioc, scmd, mpi_request,\n\t\t\tsmid, sges_left);\n\n\treturn 0;\nout:\n\tscsi_dma_unmap(scmd);\n\treturn 1;\n}\n\n \nstatic void\n_base_add_sg_single_ieee(void *paddr, u8 flags, u8 chain_offset, u32 length,\n\tdma_addr_t dma_addr)\n{\n\tMpi25IeeeSgeChain64_t *sgel = paddr;\n\n\tsgel->Flags = flags;\n\tsgel->NextChainOffset = chain_offset;\n\tsgel->Length = cpu_to_le32(length);\n\tsgel->Address = cpu_to_le64(dma_addr);\n}\n\n \nstatic void\n_base_build_zero_len_sge_ieee(struct MPT3SAS_ADAPTER *ioc, void *paddr)\n{\n\tu8 sgl_flags = (MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\tMPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR |\n\t\tMPI25_IEEE_SGE_FLAGS_END_OF_LIST);\n\n\t_base_add_sg_single_ieee(paddr, sgl_flags, 0, 0, -1);\n}\n\n \nstatic int\n_base_build_sg_scmd(struct MPT3SAS_ADAPTER *ioc,\n\tstruct scsi_cmnd *scmd, u16 smid, struct _pcie_device *unused)\n{\n\tMpi2SCSIIORequest_t *mpi_request;\n\tdma_addr_t chain_dma;\n\tstruct scatterlist *sg_scmd;\n\tvoid *sg_local, *chain;\n\tu32 chain_offset;\n\tu32 chain_length;\n\tu32 chain_flags;\n\tint sges_left;\n\tu32 sges_in_segment;\n\tu32 sgl_flags;\n\tu32 sgl_flags_last_element;\n\tu32 sgl_flags_end_buffer;\n\tstruct chain_tracker *chain_req;\n\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\n\t \n\tsgl_flags = MPI2_SGE_FLAGS_SIMPLE_ELEMENT;\n\tif (scmd->sc_data_direction == DMA_TO_DEVICE)\n\t\tsgl_flags |= MPI2_SGE_FLAGS_HOST_TO_IOC;\n\tsgl_flags_last_element = (sgl_flags | MPI2_SGE_FLAGS_LAST_ELEMENT)\n\t    << MPI2_SGE_FLAGS_SHIFT;\n\tsgl_flags_end_buffer = (sgl_flags | MPI2_SGE_FLAGS_LAST_ELEMENT |\n\t    MPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_END_OF_LIST)\n\t    << MPI2_SGE_FLAGS_SHIFT;\n\tsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\n\n\tsg_scmd = scsi_sglist(scmd);\n\tsges_left = scsi_dma_map(scmd);\n\tif (sges_left < 0)\n\t\treturn -ENOMEM;\n\n\tsg_local = &mpi_request->SGL;\n\tsges_in_segment = ioc->max_sges_in_main_message;\n\tif (sges_left <= sges_in_segment)\n\t\tgoto fill_in_last_segment;\n\n\tmpi_request->ChainOffset = (offsetof(Mpi2SCSIIORequest_t, SGL) +\n\t    (sges_in_segment * ioc->sge_size))/4;\n\n\t \n\twhile (sges_in_segment) {\n\t\tif (sges_in_segment == 1)\n\t\t\tioc->base_add_sg_single(sg_local,\n\t\t\t    sgl_flags_last_element | sg_dma_len(sg_scmd),\n\t\t\t    sg_dma_address(sg_scmd));\n\t\telse\n\t\t\tioc->base_add_sg_single(sg_local, sgl_flags |\n\t\t\t    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsg_local += ioc->sge_size;\n\t\tsges_left--;\n\t\tsges_in_segment--;\n\t}\n\n\t \n\tchain_flags = MPI2_SGE_FLAGS_CHAIN_ELEMENT << MPI2_SGE_FLAGS_SHIFT;\n\tchain_req = _base_get_chain_buffer_tracker(ioc, scmd);\n\tif (!chain_req)\n\t\treturn -1;\n\tchain = chain_req->chain_buffer;\n\tchain_dma = chain_req->chain_buffer_dma;\n\tdo {\n\t\tsges_in_segment = (sges_left <=\n\t\t    ioc->max_sges_in_chain_message) ? sges_left :\n\t\t    ioc->max_sges_in_chain_message;\n\t\tchain_offset = (sges_left == sges_in_segment) ?\n\t\t    0 : (sges_in_segment * ioc->sge_size)/4;\n\t\tchain_length = sges_in_segment * ioc->sge_size;\n\t\tif (chain_offset) {\n\t\t\tchain_offset = chain_offset <<\n\t\t\t    MPI2_SGE_CHAIN_OFFSET_SHIFT;\n\t\t\tchain_length += ioc->sge_size;\n\t\t}\n\t\tioc->base_add_sg_single(sg_local, chain_flags | chain_offset |\n\t\t    chain_length, chain_dma);\n\t\tsg_local = chain;\n\t\tif (!chain_offset)\n\t\t\tgoto fill_in_last_segment;\n\n\t\t \n\t\twhile (sges_in_segment) {\n\t\t\tif (sges_in_segment == 1)\n\t\t\t\tioc->base_add_sg_single(sg_local,\n\t\t\t\t    sgl_flags_last_element |\n\t\t\t\t    sg_dma_len(sg_scmd),\n\t\t\t\t    sg_dma_address(sg_scmd));\n\t\t\telse\n\t\t\t\tioc->base_add_sg_single(sg_local, sgl_flags |\n\t\t\t\t    sg_dma_len(sg_scmd),\n\t\t\t\t    sg_dma_address(sg_scmd));\n\t\t\tsg_scmd = sg_next(sg_scmd);\n\t\t\tsg_local += ioc->sge_size;\n\t\t\tsges_left--;\n\t\t\tsges_in_segment--;\n\t\t}\n\n\t\tchain_req = _base_get_chain_buffer_tracker(ioc, scmd);\n\t\tif (!chain_req)\n\t\t\treturn -1;\n\t\tchain = chain_req->chain_buffer;\n\t\tchain_dma = chain_req->chain_buffer_dma;\n\t} while (1);\n\n\n fill_in_last_segment:\n\n\t \n\twhile (sges_left) {\n\t\tif (sges_left == 1)\n\t\t\tioc->base_add_sg_single(sg_local, sgl_flags_end_buffer |\n\t\t\t    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\n\t\telse\n\t\t\tioc->base_add_sg_single(sg_local, sgl_flags |\n\t\t\t    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsg_local += ioc->sge_size;\n\t\tsges_left--;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\n_base_build_sg_scmd_ieee(struct MPT3SAS_ADAPTER *ioc,\n\tstruct scsi_cmnd *scmd, u16 smid, struct _pcie_device *pcie_device)\n{\n\tMpi25SCSIIORequest_t *mpi_request;\n\tdma_addr_t chain_dma;\n\tstruct scatterlist *sg_scmd;\n\tvoid *sg_local, *chain;\n\tu32 chain_offset;\n\tu32 chain_length;\n\tint sges_left;\n\tu32 sges_in_segment;\n\tu8 simple_sgl_flags;\n\tu8 simple_sgl_flags_last;\n\tu8 chain_sgl_flags;\n\tstruct chain_tracker *chain_req;\n\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\n\t \n\tsimple_sgl_flags = MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |\n\t    MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;\n\tsimple_sgl_flags_last = simple_sgl_flags |\n\t    MPI25_IEEE_SGE_FLAGS_END_OF_LIST;\n\tchain_sgl_flags = MPI2_IEEE_SGE_FLAGS_CHAIN_ELEMENT |\n\t    MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;\n\n\t \n\tif ((pcie_device) && (_base_check_pcie_native_sgl(ioc, mpi_request,\n\t\t\tsmid, scmd, pcie_device) == 0)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tsg_scmd = scsi_sglist(scmd);\n\tsges_left = scsi_dma_map(scmd);\n\tif (sges_left < 0)\n\t\treturn -ENOMEM;\n\n\tsg_local = &mpi_request->SGL;\n\tsges_in_segment = (ioc->request_sz -\n\t\t   offsetof(Mpi25SCSIIORequest_t, SGL))/ioc->sge_size_ieee;\n\tif (sges_left <= sges_in_segment)\n\t\tgoto fill_in_last_segment;\n\n\tmpi_request->ChainOffset = (sges_in_segment - 1  ) +\n\t    (offsetof(Mpi25SCSIIORequest_t, SGL)/ioc->sge_size_ieee);\n\n\t \n\twhile (sges_in_segment > 1) {\n\t\t_base_add_sg_single_ieee(sg_local, simple_sgl_flags, 0,\n\t\t    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsg_local += ioc->sge_size_ieee;\n\t\tsges_left--;\n\t\tsges_in_segment--;\n\t}\n\n\t \n\tchain_req = _base_get_chain_buffer_tracker(ioc, scmd);\n\tif (!chain_req)\n\t\treturn -1;\n\tchain = chain_req->chain_buffer;\n\tchain_dma = chain_req->chain_buffer_dma;\n\tdo {\n\t\tsges_in_segment = (sges_left <=\n\t\t    ioc->max_sges_in_chain_message) ? sges_left :\n\t\t    ioc->max_sges_in_chain_message;\n\t\tchain_offset = (sges_left == sges_in_segment) ?\n\t\t    0 : sges_in_segment;\n\t\tchain_length = sges_in_segment * ioc->sge_size_ieee;\n\t\tif (chain_offset)\n\t\t\tchain_length += ioc->sge_size_ieee;\n\t\t_base_add_sg_single_ieee(sg_local, chain_sgl_flags,\n\t\t    chain_offset, chain_length, chain_dma);\n\n\t\tsg_local = chain;\n\t\tif (!chain_offset)\n\t\t\tgoto fill_in_last_segment;\n\n\t\t \n\t\twhile (sges_in_segment) {\n\t\t\t_base_add_sg_single_ieee(sg_local, simple_sgl_flags, 0,\n\t\t\t    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\n\t\t\tsg_scmd = sg_next(sg_scmd);\n\t\t\tsg_local += ioc->sge_size_ieee;\n\t\t\tsges_left--;\n\t\t\tsges_in_segment--;\n\t\t}\n\n\t\tchain_req = _base_get_chain_buffer_tracker(ioc, scmd);\n\t\tif (!chain_req)\n\t\t\treturn -1;\n\t\tchain = chain_req->chain_buffer;\n\t\tchain_dma = chain_req->chain_buffer_dma;\n\t} while (1);\n\n\n fill_in_last_segment:\n\n\t \n\twhile (sges_left > 0) {\n\t\tif (sges_left == 1)\n\t\t\t_base_add_sg_single_ieee(sg_local,\n\t\t\t    simple_sgl_flags_last, 0, sg_dma_len(sg_scmd),\n\t\t\t    sg_dma_address(sg_scmd));\n\t\telse\n\t\t\t_base_add_sg_single_ieee(sg_local, simple_sgl_flags, 0,\n\t\t\t    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsg_local += ioc->sge_size_ieee;\n\t\tsges_left--;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\n_base_build_sg_ieee(struct MPT3SAS_ADAPTER *ioc, void *psge,\n\tdma_addr_t data_out_dma, size_t data_out_sz, dma_addr_t data_in_dma,\n\tsize_t data_in_sz)\n{\n\tu8 sgl_flags;\n\n\tif (!data_out_sz && !data_in_sz) {\n\t\t_base_build_zero_len_sge_ieee(ioc, psge);\n\t\treturn;\n\t}\n\n\tif (data_out_sz && data_in_sz) {\n\t\t \n\t\tsgl_flags = MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t    MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;\n\t\t_base_add_sg_single_ieee(psge, sgl_flags, 0, data_out_sz,\n\t\t    data_out_dma);\n\n\t\t \n\t\tpsge += ioc->sge_size_ieee;\n\n\t\t \n\t\tsgl_flags |= MPI25_IEEE_SGE_FLAGS_END_OF_LIST;\n\t\t_base_add_sg_single_ieee(psge, sgl_flags, 0, data_in_sz,\n\t\t    data_in_dma);\n\t} else if (data_out_sz)   {\n\t\tsgl_flags = MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t    MPI25_IEEE_SGE_FLAGS_END_OF_LIST |\n\t\t    MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;\n\t\t_base_add_sg_single_ieee(psge, sgl_flags, 0, data_out_sz,\n\t\t    data_out_dma);\n\t} else if (data_in_sz)   {\n\t\tsgl_flags = MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t    MPI25_IEEE_SGE_FLAGS_END_OF_LIST |\n\t\t    MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;\n\t\t_base_add_sg_single_ieee(psge, sgl_flags, 0, data_in_sz,\n\t\t    data_in_dma);\n\t}\n}\n\n#define convert_to_kb(x) ((x) << (PAGE_SHIFT - 10))\n\n \nstatic int\n_base_config_dma_addressing(struct MPT3SAS_ADAPTER *ioc, struct pci_dev *pdev)\n{\n\tstruct sysinfo s;\n\tu64 coherent_dma_mask, dma_mask;\n\n\tif (ioc->is_mcpu_endpoint || sizeof(dma_addr_t) == 4) {\n\t\tioc->dma_mask = 32;\n\t\tcoherent_dma_mask = dma_mask = DMA_BIT_MASK(32);\n\t \n\t} else if (ioc->hba_mpi_version_belonged > MPI2_VERSION) {\n\t\tioc->dma_mask = 63;\n\t\tcoherent_dma_mask = dma_mask = DMA_BIT_MASK(63);\n\t} else {\n\t\tioc->dma_mask = 64;\n\t\tcoherent_dma_mask = dma_mask = DMA_BIT_MASK(64);\n\t}\n\n\tif (ioc->use_32bit_dma)\n\t\tcoherent_dma_mask = DMA_BIT_MASK(32);\n\n\tif (dma_set_mask(&pdev->dev, dma_mask) ||\n\t    dma_set_coherent_mask(&pdev->dev, coherent_dma_mask))\n\t\treturn -ENODEV;\n\n\tif (ioc->dma_mask > 32) {\n\t\tioc->base_add_sg_single = &_base_add_sg_single_64;\n\t\tioc->sge_size = sizeof(Mpi2SGESimple64_t);\n\t} else {\n\t\tioc->base_add_sg_single = &_base_add_sg_single_32;\n\t\tioc->sge_size = sizeof(Mpi2SGESimple32_t);\n\t}\n\n\tsi_meminfo(&s);\n\tioc_info(ioc, \"%d BIT PCI BUS DMA ADDRESSING SUPPORTED, total mem (%ld kB)\\n\",\n\t\tioc->dma_mask, convert_to_kb(s.totalram));\n\n\treturn 0;\n}\n\n \nstatic int\n_base_check_enable_msix(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint base;\n\tu16 message_control;\n\n\t \n\tif (ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2008 &&\n\t    ioc->pdev->revision == SAS2_PCI_DEVICE_B0_REVISION) {\n\t\treturn -EINVAL;\n\t}\n\n\tbase = pci_find_capability(ioc->pdev, PCI_CAP_ID_MSIX);\n\tif (!base) {\n\t\tdfailprintk(ioc, ioc_info(ioc, \"msix not supported\\n\"));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\t \n\tif (ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2004 ||\n\t    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2008 ||\n\t    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2108_1 ||\n\t    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2108_2 ||\n\t    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2108_3 ||\n\t    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2116_1 ||\n\t    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2116_2)\n\t\tioc->msix_vector_count = 1;\n\telse {\n\t\tpci_read_config_word(ioc->pdev, base + 2, &message_control);\n\t\tioc->msix_vector_count = (message_control & 0x3FF) + 1;\n\t}\n\tdinitprintk(ioc, ioc_info(ioc, \"msix is supported, vector_count(%d)\\n\",\n\t\t\t\t  ioc->msix_vector_count));\n\treturn 0;\n}\n\n \nvoid\nmpt3sas_base_free_irq(struct MPT3SAS_ADAPTER *ioc)\n{\n\tunsigned int irq;\n\tstruct adapter_reply_queue *reply_q, *next;\n\n\tif (list_empty(&ioc->reply_queue_list))\n\t\treturn;\n\n\tlist_for_each_entry_safe(reply_q, next, &ioc->reply_queue_list, list) {\n\t\tlist_del(&reply_q->list);\n\t\tif (reply_q->is_iouring_poll_q) {\n\t\t\tkfree(reply_q);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ioc->smp_affinity_enable) {\n\t\t\tirq = pci_irq_vector(ioc->pdev, reply_q->msix_index);\n\t\t\tirq_update_affinity_hint(irq, NULL);\n\t\t}\n\t\tfree_irq(pci_irq_vector(ioc->pdev, reply_q->msix_index),\n\t\t\t reply_q);\n\t\tkfree(reply_q);\n\t}\n}\n\n \nstatic int\n_base_request_irq(struct MPT3SAS_ADAPTER *ioc, u8 index)\n{\n\tstruct pci_dev *pdev = ioc->pdev;\n\tstruct adapter_reply_queue *reply_q;\n\tint r, qid;\n\n\treply_q =  kzalloc(sizeof(struct adapter_reply_queue), GFP_KERNEL);\n\tif (!reply_q) {\n\t\tioc_err(ioc, \"unable to allocate memory %zu!\\n\",\n\t\t\tsizeof(struct adapter_reply_queue));\n\t\treturn -ENOMEM;\n\t}\n\treply_q->ioc = ioc;\n\treply_q->msix_index = index;\n\n\tatomic_set(&reply_q->busy, 0);\n\n\tif (index >= ioc->iopoll_q_start_index) {\n\t\tqid = index - ioc->iopoll_q_start_index;\n\t\tsnprintf(reply_q->name, MPT_NAME_LENGTH, \"%s%d-mq-poll%d\",\n\t\t    ioc->driver_name, ioc->id, qid);\n\t\treply_q->is_iouring_poll_q = 1;\n\t\tioc->io_uring_poll_queues[qid].reply_q = reply_q;\n\t\tgoto out;\n\t}\n\n\n\tif (ioc->msix_enable)\n\t\tsnprintf(reply_q->name, MPT_NAME_LENGTH, \"%s%d-msix%d\",\n\t\t    ioc->driver_name, ioc->id, index);\n\telse\n\t\tsnprintf(reply_q->name, MPT_NAME_LENGTH, \"%s%d\",\n\t\t    ioc->driver_name, ioc->id);\n\tr = request_irq(pci_irq_vector(pdev, index), _base_interrupt,\n\t\t\tIRQF_SHARED, reply_q->name, reply_q);\n\tif (r) {\n\t\tpr_err(\"%s: unable to allocate interrupt %d!\\n\",\n\t\t       reply_q->name, pci_irq_vector(pdev, index));\n\t\tkfree(reply_q);\n\t\treturn -EBUSY;\n\t}\nout:\n\tINIT_LIST_HEAD(&reply_q->list);\n\tlist_add_tail(&reply_q->list, &ioc->reply_queue_list);\n\treturn 0;\n}\n\n \nstatic void\n_base_assign_reply_queues(struct MPT3SAS_ADAPTER *ioc)\n{\n\tunsigned int cpu, nr_cpus, nr_msix, index = 0, irq;\n\tstruct adapter_reply_queue *reply_q;\n\tint iopoll_q_count = ioc->reply_queue_count -\n\t    ioc->iopoll_q_start_index;\n\tconst struct cpumask *mask;\n\n\tif (!_base_is_controller_msix_enabled(ioc))\n\t\treturn;\n\n\tif (ioc->msix_load_balance)\n\t\treturn;\n\n\tmemset(ioc->cpu_msix_table, 0, ioc->cpu_msix_table_sz);\n\n\tnr_cpus = num_online_cpus();\n\tnr_msix = ioc->reply_queue_count = min(ioc->reply_queue_count,\n\t\t\t\t\t       ioc->facts.MaxMSIxVectors);\n\tif (!nr_msix)\n\t\treturn;\n\n\tif (ioc->smp_affinity_enable) {\n\n\t\t \n\t\tif (ioc->high_iops_queues) {\n\t\t\tmask = cpumask_of_node(dev_to_node(&ioc->pdev->dev));\n\t\t\tfor (index = 0; index < ioc->high_iops_queues;\n\t\t\t    index++) {\n\t\t\t\tirq = pci_irq_vector(ioc->pdev, index);\n\t\t\t\tirq_set_affinity_and_hint(irq, mask);\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry(reply_q, &ioc->reply_queue_list, list) {\n\t\t\tconst cpumask_t *mask;\n\n\t\t\tif (reply_q->msix_index < ioc->high_iops_queues ||\n\t\t\t    reply_q->msix_index >= ioc->iopoll_q_start_index)\n\t\t\t\tcontinue;\n\n\t\t\tmask = pci_irq_get_affinity(ioc->pdev,\n\t\t\t    reply_q->msix_index);\n\t\t\tif (!mask) {\n\t\t\t\tioc_warn(ioc, \"no affinity for msi %x\\n\",\n\t\t\t\t\t reply_q->msix_index);\n\t\t\t\tgoto fall_back;\n\t\t\t}\n\n\t\t\tfor_each_cpu_and(cpu, mask, cpu_online_mask) {\n\t\t\t\tif (cpu >= ioc->cpu_msix_table_sz)\n\t\t\t\t\tbreak;\n\t\t\t\tioc->cpu_msix_table[cpu] = reply_q->msix_index;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\nfall_back:\n\tcpu = cpumask_first(cpu_online_mask);\n\tnr_msix -= (ioc->high_iops_queues - iopoll_q_count);\n\tindex = 0;\n\n\tlist_for_each_entry(reply_q, &ioc->reply_queue_list, list) {\n\t\tunsigned int i, group = nr_cpus / nr_msix;\n\n\t\tif (reply_q->msix_index < ioc->high_iops_queues ||\n\t\t    reply_q->msix_index >= ioc->iopoll_q_start_index)\n\t\t\tcontinue;\n\n\t\tif (cpu >= nr_cpus)\n\t\t\tbreak;\n\n\t\tif (index < nr_cpus % nr_msix)\n\t\t\tgroup++;\n\n\t\tfor (i = 0 ; i < group ; i++) {\n\t\t\tioc->cpu_msix_table[cpu] = reply_q->msix_index;\n\t\t\tcpu = cpumask_next(cpu, cpu_online_mask);\n\t\t}\n\t\tindex++;\n\t}\n}\n\n \nstatic void\n_base_check_and_enable_high_iops_queues(struct MPT3SAS_ADAPTER *ioc,\n\t\tint hba_msix_vector_count)\n{\n\tu16 lnksta, speed;\n\n\t \n\tif (perf_mode == MPT_PERF_MODE_IOPS ||\n\t    perf_mode == MPT_PERF_MODE_LATENCY ||\n\t    ioc->io_uring_poll_queues) {\n\t\tioc->high_iops_queues = 0;\n\t\treturn;\n\t}\n\n\tif (perf_mode == MPT_PERF_MODE_DEFAULT) {\n\n\t\tpcie_capability_read_word(ioc->pdev, PCI_EXP_LNKSTA, &lnksta);\n\t\tspeed = lnksta & PCI_EXP_LNKSTA_CLS;\n\n\t\tif (speed < 0x4) {\n\t\t\tioc->high_iops_queues = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!reset_devices && ioc->is_aero_ioc &&\n\t    hba_msix_vector_count == MPT3SAS_GEN35_MAX_MSIX_QUEUES &&\n\t    num_online_cpus() >= MPT3SAS_HIGH_IOPS_REPLY_QUEUES &&\n\t    max_msix_vectors == -1)\n\t\tioc->high_iops_queues = MPT3SAS_HIGH_IOPS_REPLY_QUEUES;\n\telse\n\t\tioc->high_iops_queues = 0;\n}\n\n \nvoid\nmpt3sas_base_disable_msix(struct MPT3SAS_ADAPTER *ioc)\n{\n\tif (!ioc->msix_enable)\n\t\treturn;\n\tpci_free_irq_vectors(ioc->pdev);\n\tioc->msix_enable = 0;\n\tkfree(ioc->io_uring_poll_queues);\n}\n\n \nstatic int\n_base_alloc_irq_vectors(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint i, irq_flags = PCI_IRQ_MSIX;\n\tstruct irq_affinity desc = { .pre_vectors = ioc->high_iops_queues };\n\tstruct irq_affinity *descp = &desc;\n\t \n\tint nr_msix_vectors = ioc->iopoll_q_start_index;\n\n\n\tif (ioc->smp_affinity_enable)\n\t\tirq_flags |= PCI_IRQ_AFFINITY | PCI_IRQ_ALL_TYPES;\n\telse\n\t\tdescp = NULL;\n\n\tioc_info(ioc, \" %d %d %d\\n\", ioc->high_iops_queues,\n\t    ioc->reply_queue_count, nr_msix_vectors);\n\n\ti = pci_alloc_irq_vectors_affinity(ioc->pdev,\n\t    ioc->high_iops_queues,\n\t    nr_msix_vectors, irq_flags, descp);\n\n\treturn i;\n}\n\n \nstatic int\n_base_enable_msix(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint r;\n\tint i, local_max_msix_vectors;\n\tu8 try_msix = 0;\n\tint iopoll_q_count = 0;\n\n\tioc->msix_load_balance = false;\n\n\tif (msix_disable == -1 || msix_disable == 0)\n\t\ttry_msix = 1;\n\n\tif (!try_msix)\n\t\tgoto try_ioapic;\n\n\tif (_base_check_enable_msix(ioc) != 0)\n\t\tgoto try_ioapic;\n\n\tioc_info(ioc, \"MSI-X vectors supported: %d\\n\", ioc->msix_vector_count);\n\tpr_info(\"\\t no of cores: %d, max_msix_vectors: %d\\n\",\n\t\tioc->cpu_count, max_msix_vectors);\n\n\tioc->reply_queue_count =\n\t\tmin_t(int, ioc->cpu_count, ioc->msix_vector_count);\n\n\tif (!ioc->rdpq_array_enable && max_msix_vectors == -1)\n\t\tlocal_max_msix_vectors = (reset_devices) ? 1 : 8;\n\telse\n\t\tlocal_max_msix_vectors = max_msix_vectors;\n\n\tif (local_max_msix_vectors == 0)\n\t\tgoto try_ioapic;\n\n\t \n\tif (!ioc->combined_reply_queue &&\n\t    ioc->hba_mpi_version_belonged != MPI2_VERSION) {\n\t\tioc_info(ioc,\n\t\t    \"combined ReplyQueue is off, Enabling msix load balance\\n\");\n\t\tioc->msix_load_balance = true;\n\t}\n\n\t \n\tif (ioc->msix_load_balance)\n\t\tioc->smp_affinity_enable = 0;\n\n\tif (!ioc->smp_affinity_enable || ioc->reply_queue_count <= 1)\n\t\tioc->shost->host_tagset = 0;\n\n\t \n\tif (ioc->shost->host_tagset)\n\t\tiopoll_q_count = poll_queues;\n\n\tif (iopoll_q_count) {\n\t\tioc->io_uring_poll_queues = kcalloc(iopoll_q_count,\n\t\t    sizeof(struct io_uring_poll_queue), GFP_KERNEL);\n\t\tif (!ioc->io_uring_poll_queues)\n\t\t\tiopoll_q_count = 0;\n\t}\n\n\tif (ioc->is_aero_ioc)\n\t\t_base_check_and_enable_high_iops_queues(ioc,\n\t\t    ioc->msix_vector_count);\n\n\t \n\tioc->reply_queue_count = min_t(int,\n\t    ioc->reply_queue_count + ioc->high_iops_queues,\n\t    ioc->msix_vector_count);\n\n\t \n\tif (local_max_msix_vectors > 0)\n\t\tioc->reply_queue_count = min_t(int, local_max_msix_vectors,\n\t\t    ioc->reply_queue_count);\n\t \n\tif (iopoll_q_count) {\n\t\tif (ioc->reply_queue_count < (iopoll_q_count + MPT3_MIN_IRQS))\n\t\t\tiopoll_q_count = 0;\n\t\tioc->reply_queue_count = min_t(int,\n\t\t    ioc->reply_queue_count + iopoll_q_count,\n\t\t    ioc->msix_vector_count);\n\t}\n\n\t \n\tioc->iopoll_q_start_index =\n\t    ioc->reply_queue_count - iopoll_q_count;\n\n\tr = _base_alloc_irq_vectors(ioc);\n\tif (r < 0) {\n\t\tioc_info(ioc, \"pci_alloc_irq_vectors failed (r=%d) !!!\\n\", r);\n\t\tgoto try_ioapic;\n\t}\n\n\t \n\tif (r < ioc->iopoll_q_start_index) {\n\t\tioc->reply_queue_count = r + iopoll_q_count;\n\t\tioc->iopoll_q_start_index =\n\t\t    ioc->reply_queue_count - iopoll_q_count;\n\t}\n\n\tioc->msix_enable = 1;\n\tfor (i = 0; i < ioc->reply_queue_count; i++) {\n\t\tr = _base_request_irq(ioc, i);\n\t\tif (r) {\n\t\t\tmpt3sas_base_free_irq(ioc);\n\t\t\tmpt3sas_base_disable_msix(ioc);\n\t\t\tgoto try_ioapic;\n\t\t}\n\t}\n\n\tioc_info(ioc, \"High IOPs queues : %s\\n\",\n\t\t\tioc->high_iops_queues ? \"enabled\" : \"disabled\");\n\n\treturn 0;\n\n \n try_ioapic:\n\tioc->high_iops_queues = 0;\n\tioc_info(ioc, \"High IOPs queues : disabled\\n\");\n\tioc->reply_queue_count = 1;\n\tioc->iopoll_q_start_index = ioc->reply_queue_count - 0;\n\tr = pci_alloc_irq_vectors(ioc->pdev, 1, 1, PCI_IRQ_LEGACY);\n\tif (r < 0) {\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_info(ioc, \"pci_alloc_irq_vector(legacy) failed (r=%d) !!!\\n\",\n\t\t\t\t     r));\n\t} else\n\t\tr = _base_request_irq(ioc, 0);\n\n\treturn r;\n}\n\n \nstatic void\nmpt3sas_base_unmap_resources(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct pci_dev *pdev = ioc->pdev;\n\n\tdexitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tmpt3sas_base_free_irq(ioc);\n\tmpt3sas_base_disable_msix(ioc);\n\n\tkfree(ioc->replyPostRegisterIndex);\n\tioc->replyPostRegisterIndex = NULL;\n\n\n\tif (ioc->chip_phys) {\n\t\tiounmap(ioc->chip);\n\t\tioc->chip_phys = 0;\n\t}\n\n\tif (pci_is_enabled(pdev)) {\n\t\tpci_release_selected_regions(ioc->pdev, ioc->bars);\n\t\tpci_disable_device(pdev);\n\t}\n}\n\nstatic int\n_base_diag_reset(struct MPT3SAS_ADAPTER *ioc);\n\n \nint\nmpt3sas_base_check_for_fault_and_issue_reset(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 ioc_state;\n\tint rc = -EFAULT;\n\n\tdinitprintk(ioc, pr_info(\"%s\\n\", __func__));\n\tif (ioc->pci_error_recovery)\n\t\treturn 0;\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\tdhsprintk(ioc, pr_info(\"%s: ioc_state(0x%08x)\\n\", __func__, ioc_state));\n\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {\n\t\tmpt3sas_print_fault_code(ioc, ioc_state &\n\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\tmpt3sas_base_mask_interrupts(ioc);\n\t\trc = _base_diag_reset(ioc);\n\t} else if ((ioc_state & MPI2_IOC_STATE_MASK) ==\n\t    MPI2_IOC_STATE_COREDUMP) {\n\t\tmpt3sas_print_coredump_info(ioc, ioc_state &\n\t\t     MPI2_DOORBELL_DATA_MASK);\n\t\tmpt3sas_base_wait_for_coredump_completion(ioc, __func__);\n\t\tmpt3sas_base_mask_interrupts(ioc);\n\t\trc = _base_diag_reset(ioc);\n\t}\n\n\treturn rc;\n}\n\n \nint\nmpt3sas_base_map_resources(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct pci_dev *pdev = ioc->pdev;\n\tu32 memap_sz;\n\tu32 pio_sz;\n\tint i, r = 0, rc;\n\tu64 pio_chip = 0;\n\tphys_addr_t chip_phys = 0;\n\tstruct adapter_reply_queue *reply_q;\n\tint iopoll_q_count = 0;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tioc->bars = pci_select_bars(pdev, IORESOURCE_MEM);\n\tif (pci_enable_device_mem(pdev)) {\n\t\tioc_warn(ioc, \"pci_enable_device_mem: failed\\n\");\n\t\tioc->bars = 0;\n\t\treturn -ENODEV;\n\t}\n\n\n\tif (pci_request_selected_regions(pdev, ioc->bars,\n\t    ioc->driver_name)) {\n\t\tioc_warn(ioc, \"pci_request_selected_regions: failed\\n\");\n\t\tioc->bars = 0;\n\t\tr = -ENODEV;\n\t\tgoto out_fail;\n\t}\n\n\tpci_set_master(pdev);\n\n\n\tif (_base_config_dma_addressing(ioc, pdev) != 0) {\n\t\tioc_warn(ioc, \"no suitable DMA mask for %s\\n\", pci_name(pdev));\n\t\tr = -ENODEV;\n\t\tgoto out_fail;\n\t}\n\n\tfor (i = 0, memap_sz = 0, pio_sz = 0; (i < DEVICE_COUNT_RESOURCE) &&\n\t     (!memap_sz || !pio_sz); i++) {\n\t\tif (pci_resource_flags(pdev, i) & IORESOURCE_IO) {\n\t\t\tif (pio_sz)\n\t\t\t\tcontinue;\n\t\t\tpio_chip = (u64)pci_resource_start(pdev, i);\n\t\t\tpio_sz = pci_resource_len(pdev, i);\n\t\t} else if (pci_resource_flags(pdev, i) & IORESOURCE_MEM) {\n\t\t\tif (memap_sz)\n\t\t\t\tcontinue;\n\t\t\tioc->chip_phys = pci_resource_start(pdev, i);\n\t\t\tchip_phys = ioc->chip_phys;\n\t\t\tmemap_sz = pci_resource_len(pdev, i);\n\t\t\tioc->chip = ioremap(ioc->chip_phys, memap_sz);\n\t\t}\n\t}\n\n\tif (ioc->chip == NULL) {\n\t\tioc_err(ioc,\n\t\t    \"unable to map adapter memory! or resource not found\\n\");\n\t\tr = -EINVAL;\n\t\tgoto out_fail;\n\t}\n\n\tmpt3sas_base_mask_interrupts(ioc);\n\n\tr = _base_get_ioc_facts(ioc);\n\tif (r) {\n\t\trc = mpt3sas_base_check_for_fault_and_issue_reset(ioc);\n\t\tif (rc || (_base_get_ioc_facts(ioc)))\n\t\t\tgoto out_fail;\n\t}\n\n\tif (!ioc->rdpq_array_enable_assigned) {\n\t\tioc->rdpq_array_enable = ioc->rdpq_array_capable;\n\t\tioc->rdpq_array_enable_assigned = 1;\n\t}\n\n\tr = _base_enable_msix(ioc);\n\tif (r)\n\t\tgoto out_fail;\n\n\tiopoll_q_count = ioc->reply_queue_count - ioc->iopoll_q_start_index;\n\tfor (i = 0; i < iopoll_q_count; i++) {\n\t\tatomic_set(&ioc->io_uring_poll_queues[i].busy, 0);\n\t\tatomic_set(&ioc->io_uring_poll_queues[i].pause, 0);\n\t}\n\n\tif (!ioc->is_driver_loading)\n\t\t_base_init_irqpolls(ioc);\n\t \n\tif (ioc->combined_reply_queue) {\n\t\t \n\t\tioc->replyPostRegisterIndex = kcalloc(\n\t\t     ioc->combined_reply_index_count,\n\t\t     sizeof(resource_size_t *), GFP_KERNEL);\n\t\tif (!ioc->replyPostRegisterIndex) {\n\t\t\tioc_err(ioc,\n\t\t\t    \"allocation for replyPostRegisterIndex failed!\\n\");\n\t\t\tr = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tfor (i = 0; i < ioc->combined_reply_index_count; i++) {\n\t\t\tioc->replyPostRegisterIndex[i] =\n\t\t\t\t(resource_size_t __iomem *)\n\t\t\t\t((u8 __force *)&ioc->chip->Doorbell +\n\t\t\t\t MPI25_SUP_REPLY_POST_HOST_INDEX_OFFSET +\n\t\t\t\t (i * MPT3_SUP_REPLY_POST_HOST_INDEX_REG_OFFSET));\n\t\t}\n\t}\n\n\tif (ioc->is_warpdrive) {\n\t\tioc->reply_post_host_index[0] = (resource_size_t __iomem *)\n\t\t    &ioc->chip->ReplyPostHostIndex;\n\n\t\tfor (i = 1; i < ioc->cpu_msix_table_sz; i++)\n\t\t\tioc->reply_post_host_index[i] =\n\t\t\t(resource_size_t __iomem *)\n\t\t\t((u8 __iomem *)&ioc->chip->Doorbell + (0x4000 + ((i - 1)\n\t\t\t* 4)));\n\t}\n\n\tlist_for_each_entry(reply_q, &ioc->reply_queue_list, list) {\n\t\tif (reply_q->msix_index >= ioc->iopoll_q_start_index) {\n\t\t\tpr_info(\"%s: enabled: index: %d\\n\",\n\t\t\t    reply_q->name, reply_q->msix_index);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_info(\"%s: %s enabled: IRQ %d\\n\",\n\t\t\treply_q->name,\n\t\t\tioc->msix_enable ? \"PCI-MSI-X\" : \"IO-APIC\",\n\t\t\tpci_irq_vector(ioc->pdev, reply_q->msix_index));\n\t}\n\n\tioc_info(ioc, \"iomem(%pap), mapped(0x%p), size(%d)\\n\",\n\t\t &chip_phys, ioc->chip, memap_sz);\n\tioc_info(ioc, \"ioport(0x%016llx), size(%d)\\n\",\n\t\t (unsigned long long)pio_chip, pio_sz);\n\n\t \n\tpci_save_state(pdev);\n\treturn 0;\n\n out_fail:\n\tmpt3sas_base_unmap_resources(ioc);\n\treturn r;\n}\n\n \nvoid *\nmpt3sas_base_get_msg_frame(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\treturn (void *)(ioc->request + (smid * ioc->request_sz));\n}\n\n \nvoid *\nmpt3sas_base_get_sense_buffer(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\treturn (void *)(ioc->sense + ((smid - 1) * SCSI_SENSE_BUFFERSIZE));\n}\n\n \n__le32\nmpt3sas_base_get_sense_buffer_dma(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\treturn cpu_to_le32(ioc->sense_dma + ((smid - 1) *\n\t    SCSI_SENSE_BUFFERSIZE));\n}\n\n \nvoid *\nmpt3sas_base_get_pcie_sgl(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\treturn (void *)(ioc->pcie_sg_lookup[smid - 1].pcie_sgl);\n}\n\n \ndma_addr_t\nmpt3sas_base_get_pcie_sgl_dma(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\treturn ioc->pcie_sg_lookup[smid - 1].pcie_sgl_dma;\n}\n\n \nvoid *\nmpt3sas_base_get_reply_virt_addr(struct MPT3SAS_ADAPTER *ioc, u32 phys_addr)\n{\n\tif (!phys_addr)\n\t\treturn NULL;\n\treturn ioc->reply + (phys_addr - (u32)ioc->reply_dma);\n}\n\n \nstatic inline u8\n_base_get_msix_index(struct MPT3SAS_ADAPTER *ioc,\n\tstruct scsi_cmnd *scmd)\n{\n\t \n\tif (ioc->msix_load_balance)\n\t\treturn ioc->reply_queue_count ?\n\t\t    base_mod64(atomic64_add_return(1,\n\t\t    &ioc->total_io_cnt), ioc->reply_queue_count) : 0;\n\n\tif (scmd && ioc->shost->nr_hw_queues > 1) {\n\t\tu32 tag = blk_mq_unique_tag(scsi_cmd_to_rq(scmd));\n\n\t\treturn blk_mq_unique_tag_to_hwq(tag) +\n\t\t\tioc->high_iops_queues;\n\t}\n\n\treturn ioc->cpu_msix_table[raw_smp_processor_id()];\n}\n\n \nstatic inline u8\n_base_get_high_iops_msix_index(struct MPT3SAS_ADAPTER *ioc,\n\tstruct scsi_cmnd *scmd)\n{\n\t \n\n\tif (scsi_device_busy(scmd->device) > MPT3SAS_DEVICE_HIGH_IOPS_DEPTH)\n\t\treturn base_mod64((\n\t\t    atomic64_add_return(1, &ioc->high_iops_outstanding) /\n\t\t    MPT3SAS_HIGH_IOPS_BATCH_COUNT),\n\t\t    MPT3SAS_HIGH_IOPS_REPLY_QUEUES);\n\n\treturn _base_get_msix_index(ioc, scmd);\n}\n\n \nu16\nmpt3sas_base_get_smid(struct MPT3SAS_ADAPTER *ioc, u8 cb_idx)\n{\n\tunsigned long flags;\n\tstruct request_tracker *request;\n\tu16 smid;\n\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tif (list_empty(&ioc->internal_free_list)) {\n\t\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\t\tioc_err(ioc, \"%s: smid not available\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\trequest = list_entry(ioc->internal_free_list.next,\n\t    struct request_tracker, tracker_list);\n\trequest->cb_idx = cb_idx;\n\tsmid = request->smid;\n\tlist_del(&request->tracker_list);\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\treturn smid;\n}\n\n \nu16\nmpt3sas_base_get_smid_scsiio(struct MPT3SAS_ADAPTER *ioc, u8 cb_idx,\n\tstruct scsi_cmnd *scmd)\n{\n\tstruct scsiio_tracker *request = scsi_cmd_priv(scmd);\n\tu16 smid;\n\tu32 tag, unique_tag;\n\n\tunique_tag = blk_mq_unique_tag(scsi_cmd_to_rq(scmd));\n\ttag = blk_mq_unique_tag_to_tag(unique_tag);\n\n\t \n\tioc->io_queue_num[tag] = blk_mq_unique_tag_to_hwq(unique_tag);\n\n\tsmid = tag + 1;\n\trequest->cb_idx = cb_idx;\n\trequest->smid = smid;\n\trequest->scmd = scmd;\n\tINIT_LIST_HEAD(&request->chain_list);\n\treturn smid;\n}\n\n \nu16\nmpt3sas_base_get_smid_hpr(struct MPT3SAS_ADAPTER *ioc, u8 cb_idx)\n{\n\tunsigned long flags;\n\tstruct request_tracker *request;\n\tu16 smid;\n\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tif (list_empty(&ioc->hpr_free_list)) {\n\t\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\t\treturn 0;\n\t}\n\n\trequest = list_entry(ioc->hpr_free_list.next,\n\t    struct request_tracker, tracker_list);\n\trequest->cb_idx = cb_idx;\n\tsmid = request->smid;\n\tlist_del(&request->tracker_list);\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\treturn smid;\n}\n\nstatic void\n_base_recovery_check(struct MPT3SAS_ADAPTER *ioc)\n{\n\t \n\tif (ioc->shost_recovery && ioc->pending_io_count) {\n\t\tioc->pending_io_count = scsi_host_busy(ioc->shost);\n\t\tif (ioc->pending_io_count == 0)\n\t\t\twake_up(&ioc->reset_wq);\n\t}\n}\n\nvoid mpt3sas_base_clear_st(struct MPT3SAS_ADAPTER *ioc,\n\t\t\t   struct scsiio_tracker *st)\n{\n\tif (WARN_ON(st->smid == 0))\n\t\treturn;\n\tst->cb_idx = 0xFF;\n\tst->direct_io = 0;\n\tst->scmd = NULL;\n\tatomic_set(&ioc->chain_lookup[st->smid - 1].chain_offset, 0);\n\tst->smid = 0;\n}\n\n \nvoid\nmpt3sas_base_free_smid(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tunsigned long flags;\n\tint i;\n\n\tif (smid < ioc->hi_priority_smid) {\n\t\tstruct scsiio_tracker *st;\n\t\tvoid *request;\n\n\t\tst = _get_st_from_smid(ioc, smid);\n\t\tif (!st) {\n\t\t\t_base_recovery_check(ioc);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\trequest = mpt3sas_base_get_msg_frame(ioc, smid);\n\t\tmemset(request, 0, ioc->request_sz);\n\n\t\tmpt3sas_base_clear_st(ioc, st);\n\t\t_base_recovery_check(ioc);\n\t\tioc->io_queue_num[smid - 1] = 0;\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tif (smid < ioc->internal_smid) {\n\t\t \n\t\ti = smid - ioc->hi_priority_smid;\n\t\tioc->hpr_lookup[i].cb_idx = 0xFF;\n\t\tlist_add(&ioc->hpr_lookup[i].tracker_list, &ioc->hpr_free_list);\n\t} else if (smid <= ioc->hba_queue_depth) {\n\t\t \n\t\ti = smid - ioc->internal_smid;\n\t\tioc->internal_lookup[i].cb_idx = 0xFF;\n\t\tlist_add(&ioc->internal_lookup[i].tracker_list,\n\t\t    &ioc->internal_free_list);\n\t}\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n}\n\n \nstatic inline void\n_base_mpi_ep_writeq(__u64 b, volatile void __iomem *addr,\n\t\t\t\t\tspinlock_t *writeq_lock)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(writeq_lock, flags);\n\t__raw_writel((u32)(b), addr);\n\t__raw_writel((u32)(b >> 32), (addr + 4));\n\tspin_unlock_irqrestore(writeq_lock, flags);\n}\n\n \n#if defined(writeq) && defined(CONFIG_64BIT)\nstatic inline void\n_base_writeq(__u64 b, volatile void __iomem *addr, spinlock_t *writeq_lock)\n{\n\twmb();\n\t__raw_writeq(b, addr);\n\tbarrier();\n}\n#else\nstatic inline void\n_base_writeq(__u64 b, volatile void __iomem *addr, spinlock_t *writeq_lock)\n{\n\t_base_mpi_ep_writeq(b, addr, writeq_lock);\n}\n#endif\n\n \nstatic u8\n_base_set_and_get_msix_index(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tstruct scsiio_tracker *st = NULL;\n\n\tif (smid < ioc->hi_priority_smid)\n\t\tst = _get_st_from_smid(ioc, smid);\n\n\tif (st == NULL)\n\t\treturn  _base_get_msix_index(ioc, NULL);\n\n\tst->msix_io = ioc->get_msix_index_for_smlio(ioc, st->scmd);\n\treturn st->msix_io;\n}\n\n \nstatic void\n_base_put_smid_mpi_ep_scsi_io(struct MPT3SAS_ADAPTER *ioc,\n\tu16 smid, u16 handle)\n{\n\tMpi2RequestDescriptorUnion_t descriptor;\n\tu64 *request = (u64 *)&descriptor;\n\tvoid *mpi_req_iomem;\n\t__le32 *mfp = (__le32 *)mpt3sas_base_get_msg_frame(ioc, smid);\n\n\t_clone_sg_entries(ioc, (void *) mfp, smid);\n\tmpi_req_iomem = (void __force *)ioc->chip +\n\t\t\tMPI_FRAME_START_OFFSET + (smid * ioc->request_sz);\n\t_base_clone_mpi_to_sys_mem(mpi_req_iomem, (void *)mfp,\n\t\t\t\t\tioc->request_sz);\n\tdescriptor.SCSIIO.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO;\n\tdescriptor.SCSIIO.MSIxIndex = _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.SCSIIO.SMID = cpu_to_le16(smid);\n\tdescriptor.SCSIIO.DevHandle = cpu_to_le16(handle);\n\tdescriptor.SCSIIO.LMID = 0;\n\t_base_mpi_ep_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\n\t    &ioc->scsi_lookup_lock);\n}\n\n \nstatic void\n_base_put_smid_scsi_io(struct MPT3SAS_ADAPTER *ioc, u16 smid, u16 handle)\n{\n\tMpi2RequestDescriptorUnion_t descriptor;\n\tu64 *request = (u64 *)&descriptor;\n\n\n\tdescriptor.SCSIIO.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO;\n\tdescriptor.SCSIIO.MSIxIndex = _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.SCSIIO.SMID = cpu_to_le16(smid);\n\tdescriptor.SCSIIO.DevHandle = cpu_to_le16(handle);\n\tdescriptor.SCSIIO.LMID = 0;\n\t_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\n\t    &ioc->scsi_lookup_lock);\n}\n\n \nstatic void\n_base_put_smid_fast_path(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tu16 handle)\n{\n\tMpi2RequestDescriptorUnion_t descriptor;\n\tu64 *request = (u64 *)&descriptor;\n\n\tdescriptor.SCSIIO.RequestFlags =\n\t    MPI25_REQ_DESCRIPT_FLAGS_FAST_PATH_SCSI_IO;\n\tdescriptor.SCSIIO.MSIxIndex = _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.SCSIIO.SMID = cpu_to_le16(smid);\n\tdescriptor.SCSIIO.DevHandle = cpu_to_le16(handle);\n\tdescriptor.SCSIIO.LMID = 0;\n\t_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\n\t    &ioc->scsi_lookup_lock);\n}\n\n \nstatic void\n_base_put_smid_hi_priority(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tu16 msix_task)\n{\n\tMpi2RequestDescriptorUnion_t descriptor;\n\tvoid *mpi_req_iomem;\n\tu64 *request;\n\n\tif (ioc->is_mcpu_endpoint) {\n\t\t__le32 *mfp = (__le32 *)mpt3sas_base_get_msg_frame(ioc, smid);\n\n\t\t \n\t\tmpi_req_iomem = (void __force *)ioc->chip\n\t\t\t\t\t+ MPI_FRAME_START_OFFSET\n\t\t\t\t\t+ (smid * ioc->request_sz);\n\t\t_base_clone_mpi_to_sys_mem(mpi_req_iomem, (void *)mfp,\n\t\t\t\t\t\t\tioc->request_sz);\n\t}\n\n\trequest = (u64 *)&descriptor;\n\n\tdescriptor.HighPriority.RequestFlags =\n\t    MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY;\n\tdescriptor.HighPriority.MSIxIndex =  msix_task;\n\tdescriptor.HighPriority.SMID = cpu_to_le16(smid);\n\tdescriptor.HighPriority.LMID = 0;\n\tdescriptor.HighPriority.Reserved1 = 0;\n\tif (ioc->is_mcpu_endpoint)\n\t\t_base_mpi_ep_writeq(*request,\n\t\t\t\t&ioc->chip->RequestDescriptorPostLow,\n\t\t\t\t&ioc->scsi_lookup_lock);\n\telse\n\t\t_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\n\t\t    &ioc->scsi_lookup_lock);\n}\n\n \nvoid\nmpt3sas_base_put_smid_nvme_encap(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tMpi2RequestDescriptorUnion_t descriptor;\n\tu64 *request = (u64 *)&descriptor;\n\n\tdescriptor.Default.RequestFlags =\n\t\tMPI26_REQ_DESCRIPT_FLAGS_PCIE_ENCAPSULATED;\n\tdescriptor.Default.MSIxIndex =  _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.Default.SMID = cpu_to_le16(smid);\n\tdescriptor.Default.LMID = 0;\n\tdescriptor.Default.DescriptorTypeDependent = 0;\n\t_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\n\t    &ioc->scsi_lookup_lock);\n}\n\n \nstatic void\n_base_put_smid_default(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tMpi2RequestDescriptorUnion_t descriptor;\n\tvoid *mpi_req_iomem;\n\tu64 *request;\n\n\tif (ioc->is_mcpu_endpoint) {\n\t\t__le32 *mfp = (__le32 *)mpt3sas_base_get_msg_frame(ioc, smid);\n\n\t\t_clone_sg_entries(ioc, (void *) mfp, smid);\n\t\t \n\t\tmpi_req_iomem = (void __force *)ioc->chip +\n\t\t\tMPI_FRAME_START_OFFSET + (smid * ioc->request_sz);\n\t\t_base_clone_mpi_to_sys_mem(mpi_req_iomem, (void *)mfp,\n\t\t\t\t\t\t\tioc->request_sz);\n\t}\n\trequest = (u64 *)&descriptor;\n\tdescriptor.Default.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE;\n\tdescriptor.Default.MSIxIndex = _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.Default.SMID = cpu_to_le16(smid);\n\tdescriptor.Default.LMID = 0;\n\tdescriptor.Default.DescriptorTypeDependent = 0;\n\tif (ioc->is_mcpu_endpoint)\n\t\t_base_mpi_ep_writeq(*request,\n\t\t\t\t&ioc->chip->RequestDescriptorPostLow,\n\t\t\t\t&ioc->scsi_lookup_lock);\n\telse\n\t\t_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\n\t\t\t\t&ioc->scsi_lookup_lock);\n}\n\n \nstatic void\n_base_put_smid_scsi_io_atomic(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tu16 handle)\n{\n\tMpi26AtomicRequestDescriptor_t descriptor;\n\tu32 *request = (u32 *)&descriptor;\n\n\tdescriptor.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO;\n\tdescriptor.MSIxIndex = _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.SMID = cpu_to_le16(smid);\n\n\twritel(cpu_to_le32(*request), &ioc->chip->AtomicRequestDescriptorPost);\n}\n\n \nstatic void\n_base_put_smid_fast_path_atomic(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tu16 handle)\n{\n\tMpi26AtomicRequestDescriptor_t descriptor;\n\tu32 *request = (u32 *)&descriptor;\n\n\tdescriptor.RequestFlags = MPI25_REQ_DESCRIPT_FLAGS_FAST_PATH_SCSI_IO;\n\tdescriptor.MSIxIndex = _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.SMID = cpu_to_le16(smid);\n\n\twritel(cpu_to_le32(*request), &ioc->chip->AtomicRequestDescriptorPost);\n}\n\n \nstatic void\n_base_put_smid_hi_priority_atomic(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tu16 msix_task)\n{\n\tMpi26AtomicRequestDescriptor_t descriptor;\n\tu32 *request = (u32 *)&descriptor;\n\n\tdescriptor.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY;\n\tdescriptor.MSIxIndex = msix_task;\n\tdescriptor.SMID = cpu_to_le16(smid);\n\n\twritel(cpu_to_le32(*request), &ioc->chip->AtomicRequestDescriptorPost);\n}\n\n \nstatic void\n_base_put_smid_default_atomic(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tMpi26AtomicRequestDescriptor_t descriptor;\n\tu32 *request = (u32 *)&descriptor;\n\n\tdescriptor.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE;\n\tdescriptor.MSIxIndex = _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.SMID = cpu_to_le16(smid);\n\n\twritel(cpu_to_le32(*request), &ioc->chip->AtomicRequestDescriptorPost);\n}\n\n \nstatic void\n_base_display_OEMs_branding(struct MPT3SAS_ADAPTER *ioc)\n{\n\tif (ioc->pdev->subsystem_vendor != PCI_VENDOR_ID_INTEL)\n\t\treturn;\n\n\tswitch (ioc->pdev->subsystem_vendor) {\n\tcase PCI_VENDOR_ID_INTEL:\n\t\tswitch (ioc->pdev->device) {\n\t\tcase MPI2_MFGPAGE_DEVID_SAS2008:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT2SAS_INTEL_RMS2LL080_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS2LL080_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_RMS2LL040_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS2LL040_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_SSD910_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_SSD910_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"Intel(R) Controller: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI2_MFGPAGE_DEVID_SAS2308_2:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT2SAS_INTEL_RS25GB008_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RS25GB008_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_RMS25JB080_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS25JB080_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_RMS25JB040_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS25JB040_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_RMS25KB080_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS25KB080_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_RMS25KB040_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS25KB040_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_RMS25LB040_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS25LB040_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_RMS25LB080_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS25LB080_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"Intel(R) Controller: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI25_MFGPAGE_DEVID_SAS3008:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT3SAS_INTEL_RMS3JC080_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_INTEL_RMS3JC080_BRANDING);\n\t\t\t\tbreak;\n\n\t\t\tcase MPT3SAS_INTEL_RS3GC008_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_INTEL_RS3GC008_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT3SAS_INTEL_RS3FC044_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_INTEL_RS3FC044_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT3SAS_INTEL_RS3UC080_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_INTEL_RS3UC080_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"Intel(R) Controller: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tioc_info(ioc, \"Intel(R) Controller: Subsystem ID: 0x%X\\n\",\n\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PCI_VENDOR_ID_DELL:\n\t\tswitch (ioc->pdev->device) {\n\t\tcase MPI2_MFGPAGE_DEVID_SAS2008:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT2SAS_DELL_6GBPS_SAS_HBA_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_DELL_6GBPS_SAS_HBA_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_DELL_PERC_H200_ADAPTER_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_DELL_PERC_H200_ADAPTER_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_DELL_PERC_H200_INTEGRATED_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_DELL_PERC_H200_INTEGRATED_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_DELL_PERC_H200_MODULAR_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_DELL_PERC_H200_MODULAR_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_DELL_PERC_H200_EMBEDDED_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_DELL_PERC_H200_EMBEDDED_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_DELL_PERC_H200_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_DELL_PERC_H200_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_DELL_6GBPS_SAS_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_DELL_6GBPS_SAS_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"Dell 6Gbps HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI25_MFGPAGE_DEVID_SAS3008:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT3SAS_DELL_12G_HBA_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_DELL_12G_HBA_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"Dell 12Gbps HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tioc_info(ioc, \"Dell HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PCI_VENDOR_ID_CISCO:\n\t\tswitch (ioc->pdev->device) {\n\t\tcase MPI25_MFGPAGE_DEVID_SAS3008:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT3SAS_CISCO_12G_8E_HBA_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_CISCO_12G_8E_HBA_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT3SAS_CISCO_12G_8I_HBA_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_CISCO_12G_8I_HBA_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT3SAS_CISCO_12G_AVILA_HBA_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_CISCO_12G_AVILA_HBA_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"Cisco 12Gbps SAS HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI25_MFGPAGE_DEVID_SAS3108_1:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT3SAS_CISCO_12G_AVILA_HBA_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_CISCO_12G_AVILA_HBA_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT3SAS_CISCO_12G_COLUSA_MEZZANINE_HBA_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_CISCO_12G_COLUSA_MEZZANINE_HBA_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"Cisco 12Gbps SAS HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tioc_info(ioc, \"Cisco SAS HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MPT2SAS_HP_3PAR_SSVID:\n\t\tswitch (ioc->pdev->device) {\n\t\tcase MPI2_MFGPAGE_DEVID_SAS2004:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT2SAS_HP_DAUGHTER_2_4_INTERNAL_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_HP_DAUGHTER_2_4_INTERNAL_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"HP 6Gbps SAS HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI2_MFGPAGE_DEVID_SAS2308_2:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT2SAS_HP_2_4_INTERNAL_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_HP_2_4_INTERNAL_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_HP_2_4_EXTERNAL_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_HP_2_4_EXTERNAL_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_HP_1_4_INTERNAL_1_4_EXTERNAL_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_HP_1_4_INTERNAL_1_4_EXTERNAL_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_HP_EMBEDDED_2_4_INTERNAL_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_HP_EMBEDDED_2_4_INTERNAL_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"HP 6Gbps SAS HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tioc_info(ioc, \"HP SAS HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \n\tstatic int\n_base_display_fwpkg_version(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2FWImageHeader_t *fw_img_hdr;\n\tMpi26ComponentImageHeader_t *cmp_img_hdr;\n\tMpi25FWUploadRequest_t *mpi_request;\n\tMpi2FWUploadReply_t mpi_reply;\n\tint r = 0, issue_diag_reset = 0;\n\tu32  package_version = 0;\n\tvoid *fwpkg_data = NULL;\n\tdma_addr_t fwpkg_data_dma;\n\tu16 smid, ioc_status;\n\tsize_t data_length;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tif (ioc->base_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc_err(ioc, \"%s: internal command already in use\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tdata_length = sizeof(Mpi2FWImageHeader_t);\n\tfwpkg_data = dma_alloc_coherent(&ioc->pdev->dev, data_length,\n\t\t\t&fwpkg_data_dma, GFP_KERNEL);\n\tif (!fwpkg_data) {\n\t\tioc_err(ioc,\n\t\t    \"Memory allocation for fwpkg data failed at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\tr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tioc->base_cmds.status = MPT3_CMD_PENDING;\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->base_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi25FWUploadRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_FW_UPLOAD;\n\tmpi_request->ImageType = MPI2_FW_UPLOAD_ITYPE_FW_FLASH;\n\tmpi_request->ImageSize = cpu_to_le32(data_length);\n\tioc->build_sg(ioc, &mpi_request->SGL, 0, 0, fwpkg_data_dma,\n\t\t\tdata_length);\n\tinit_completion(&ioc->base_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\t \n\twait_for_completion_timeout(&ioc->base_cmds.done,\n\t\t\tFW_IMG_HDR_READ_TIMEOUT*HZ);\n\tioc_info(ioc, \"%s: complete\\n\", __func__);\n\tif (!(ioc->base_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tioc_err(ioc, \"%s: timeout\\n\", __func__);\n\t\t_debug_dump_mf(mpi_request,\n\t\t\t\tsizeof(Mpi25FWUploadRequest_t)/4);\n\t\tissue_diag_reset = 1;\n\t} else {\n\t\tmemset(&mpi_reply, 0, sizeof(Mpi2FWUploadReply_t));\n\t\tif (ioc->base_cmds.status & MPT3_CMD_REPLY_VALID) {\n\t\t\tmemcpy(&mpi_reply, ioc->base_cmds.reply,\n\t\t\t\t\tsizeof(Mpi2FWUploadReply_t));\n\t\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t\t\t\t\tMPI2_IOCSTATUS_MASK;\n\t\t\tif (ioc_status == MPI2_IOCSTATUS_SUCCESS) {\n\t\t\t\tfw_img_hdr = (Mpi2FWImageHeader_t *)fwpkg_data;\n\t\t\t\tif (le32_to_cpu(fw_img_hdr->Signature) ==\n\t\t\t\t    MPI26_IMAGE_HEADER_SIGNATURE0_MPI26) {\n\t\t\t\t\tcmp_img_hdr =\n\t\t\t\t\t    (Mpi26ComponentImageHeader_t *)\n\t\t\t\t\t    (fwpkg_data);\n\t\t\t\t\tpackage_version =\n\t\t\t\t\t    le32_to_cpu(\n\t\t\t\t\t    cmp_img_hdr->ApplicationSpecific);\n\t\t\t\t} else\n\t\t\t\t\tpackage_version =\n\t\t\t\t\t    le32_to_cpu(\n\t\t\t\t\t    fw_img_hdr->PackageVersion.Word);\n\t\t\t\tif (package_version)\n\t\t\t\t\tioc_info(ioc,\n\t\t\t\t\t\"FW Package Ver(%02d.%02d.%02d.%02d)\\n\",\n\t\t\t\t\t((package_version) & 0xFF000000) >> 24,\n\t\t\t\t\t((package_version) & 0x00FF0000) >> 16,\n\t\t\t\t\t((package_version) & 0x0000FF00) >> 8,\n\t\t\t\t\t(package_version) & 0x000000FF);\n\t\t\t} else {\n\t\t\t\t_debug_dump_mf(&mpi_reply,\n\t\t\t\t\t\tsizeof(Mpi2FWUploadReply_t)/4);\n\t\t\t}\n\t\t}\n\t}\n\tioc->base_cmds.status = MPT3_CMD_NOT_USED;\nout:\n\tif (fwpkg_data)\n\t\tdma_free_coherent(&ioc->pdev->dev, data_length, fwpkg_data,\n\t\t\t\tfwpkg_data_dma);\n\tif (issue_diag_reset) {\n\t\tif (ioc->drv_internal_flags & MPT_DRV_INTERNAL_FIRST_PE_ISSUED)\n\t\t\treturn -EFAULT;\n\t\tif (mpt3sas_base_check_for_fault_and_issue_reset(ioc))\n\t\t\treturn -EFAULT;\n\t\tr = -EAGAIN;\n\t}\n\treturn r;\n}\n\n \nstatic void\n_base_display_ioc_capabilities(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint i = 0;\n\tchar desc[17] = {0};\n\tu32 iounit_pg1_flags;\n\n\tstrncpy(desc, ioc->manu_pg0.ChipName, 16);\n\tioc_info(ioc, \"%s: FWVersion(%02d.%02d.%02d.%02d), ChipRevision(0x%02x)\\n\",\n\t\t desc,\n\t\t (ioc->facts.FWVersion.Word & 0xFF000000) >> 24,\n\t\t (ioc->facts.FWVersion.Word & 0x00FF0000) >> 16,\n\t\t (ioc->facts.FWVersion.Word & 0x0000FF00) >> 8,\n\t\t ioc->facts.FWVersion.Word & 0x000000FF,\n\t\t ioc->pdev->revision);\n\n\t_base_display_OEMs_branding(ioc);\n\n\tif (ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_NVME_DEVICES) {\n\t\tpr_info(\"%sNVMe\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tioc_info(ioc, \"Protocol=(\");\n\n\tif (ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_SCSI_INITIATOR) {\n\t\tpr_cont(\"Initiator\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_SCSI_TARGET) {\n\t\tpr_cont(\"%sTarget\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\ti = 0;\n\tpr_cont(\"), Capabilities=(\");\n\n\tif (!ioc->hide_ir_msg) {\n\t\tif (ioc->facts.IOCCapabilities &\n\t\t    MPI2_IOCFACTS_CAPABILITY_INTEGRATED_RAID) {\n\t\t\tpr_cont(\"Raid\");\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_TLR) {\n\t\tpr_cont(\"%sTLR\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_MULTICAST) {\n\t\tpr_cont(\"%sMulticast\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.IOCCapabilities &\n\t    MPI2_IOCFACTS_CAPABILITY_BIDIRECTIONAL_TARGET) {\n\t\tpr_cont(\"%sBIDI Target\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_EEDP) {\n\t\tpr_cont(\"%sEEDP\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.IOCCapabilities &\n\t    MPI2_IOCFACTS_CAPABILITY_SNAPSHOT_BUFFER) {\n\t\tpr_cont(\"%sSnapshot Buffer\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.IOCCapabilities &\n\t    MPI2_IOCFACTS_CAPABILITY_DIAG_TRACE_BUFFER) {\n\t\tpr_cont(\"%sDiag Trace Buffer\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.IOCCapabilities &\n\t    MPI2_IOCFACTS_CAPABILITY_EXTENDED_BUFFER) {\n\t\tpr_cont(\"%sDiag Extended Buffer\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.IOCCapabilities &\n\t    MPI2_IOCFACTS_CAPABILITY_TASK_SET_FULL_HANDLING) {\n\t\tpr_cont(\"%sTask Set Full\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tiounit_pg1_flags = le32_to_cpu(ioc->iounit_pg1.Flags);\n\tif (!(iounit_pg1_flags & MPI2_IOUNITPAGE1_NATIVE_COMMAND_Q_DISABLE)) {\n\t\tpr_cont(\"%sNCQ\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tpr_cont(\")\\n\");\n}\n\n \nvoid\nmpt3sas_base_update_missing_delay(struct MPT3SAS_ADAPTER *ioc,\n\tu16 device_missing_delay, u8 io_missing_delay)\n{\n\tu16 dmd, dmd_new, dmd_orignal;\n\tu8 io_missing_delay_original;\n\tu16 sz;\n\tMpi2SasIOUnitPage1_t *sas_iounit_pg1 = NULL;\n\tMpi2ConfigReply_t mpi_reply;\n\tu8 num_phys = 0;\n\tu16 ioc_status;\n\n\tmpt3sas_config_get_number_hba_phys(ioc, &num_phys);\n\tif (!num_phys)\n\t\treturn;\n\n\tsz = offsetof(Mpi2SasIOUnitPage1_t, PhyData) + (num_phys *\n\t    sizeof(Mpi2SasIOUnit1PhyData_t));\n\tsas_iounit_pg1 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_iounit_pg1) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tif ((mpt3sas_config_get_sas_iounit_pg1(ioc, &mpi_reply,\n\t    sas_iounit_pg1, sz))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\t \n\tdmd = sas_iounit_pg1->ReportDeviceMissingDelay;\n\tif (dmd & MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16)\n\t\tdmd = (dmd & MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK) * 16;\n\telse\n\t\tdmd = dmd & MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK;\n\tdmd_orignal = dmd;\n\tif (device_missing_delay > 0x7F) {\n\t\tdmd = (device_missing_delay > 0x7F0) ? 0x7F0 :\n\t\t    device_missing_delay;\n\t\tdmd = dmd / 16;\n\t\tdmd |= MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16;\n\t} else\n\t\tdmd = device_missing_delay;\n\tsas_iounit_pg1->ReportDeviceMissingDelay = dmd;\n\n\t \n\tio_missing_delay_original = sas_iounit_pg1->IODeviceMissingDelay;\n\tsas_iounit_pg1->IODeviceMissingDelay = io_missing_delay;\n\n\tif (!mpt3sas_config_set_sas_iounit_pg1(ioc, &mpi_reply, sas_iounit_pg1,\n\t    sz)) {\n\t\tif (dmd & MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16)\n\t\t\tdmd_new = (dmd &\n\t\t\t    MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK) * 16;\n\t\telse\n\t\t\tdmd_new =\n\t\t    dmd & MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK;\n\t\tioc_info(ioc, \"device_missing_delay: old(%d), new(%d)\\n\",\n\t\t\t dmd_orignal, dmd_new);\n\t\tioc_info(ioc, \"ioc_missing_delay: old(%d), new(%d)\\n\",\n\t\t\t io_missing_delay_original,\n\t\t\t io_missing_delay);\n\t\tioc->device_missing_delay = dmd_new;\n\t\tioc->io_missing_delay = io_missing_delay;\n\t}\n\nout:\n\tkfree(sas_iounit_pg1);\n}\n\n \nstatic int\n_base_update_ioc_page1_inlinewith_perf_mode(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2IOCPage1_t ioc_pg1;\n\tMpi2ConfigReply_t mpi_reply;\n\tint rc;\n\n\trc = mpt3sas_config_get_ioc_pg1(ioc, &mpi_reply, &ioc->ioc_pg1_copy);\n\tif (rc)\n\t\treturn rc;\n\tmemcpy(&ioc_pg1, &ioc->ioc_pg1_copy, sizeof(Mpi2IOCPage1_t));\n\n\tswitch (perf_mode) {\n\tcase MPT_PERF_MODE_DEFAULT:\n\tcase MPT_PERF_MODE_BALANCED:\n\t\tif (ioc->high_iops_queues) {\n\t\t\tioc_info(ioc,\n\t\t\t\t\"Enable interrupt coalescing only for first\\t\"\n\t\t\t\t\"%d reply queues\\n\",\n\t\t\t\tMPT3SAS_HIGH_IOPS_REPLY_QUEUES);\n\t\t\t \n\t\t\tioc_pg1.ProductSpecific = cpu_to_le32(0x80000000 |\n\t\t\t    ((1 << MPT3SAS_HIGH_IOPS_REPLY_QUEUES/8) - 1));\n\t\t\trc = mpt3sas_config_set_ioc_pg1(ioc, &mpi_reply, &ioc_pg1);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tioc_info(ioc, \"performance mode: balanced\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tcase MPT_PERF_MODE_LATENCY:\n\t\t \n\t\tioc_pg1.CoalescingTimeout = cpu_to_le32(0xa);\n\t\tioc_pg1.Flags |= cpu_to_le32(MPI2_IOCPAGE1_REPLY_COALESCING);\n\t\tioc_pg1.ProductSpecific = 0;\n\t\trc = mpt3sas_config_set_ioc_pg1(ioc, &mpi_reply, &ioc_pg1);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tioc_info(ioc, \"performance mode: latency\\n\");\n\t\tbreak;\n\tcase MPT_PERF_MODE_IOPS:\n\t\t \n\t\tioc_info(ioc,\n\t\t    \"performance mode: iops with coalescing timeout: 0x%x\\n\",\n\t\t    le32_to_cpu(ioc_pg1.CoalescingTimeout));\n\t\tioc_pg1.Flags |= cpu_to_le32(MPI2_IOCPAGE1_REPLY_COALESCING);\n\t\tioc_pg1.ProductSpecific = 0;\n\t\trc = mpt3sas_config_set_ioc_pg1(ioc, &mpi_reply, &ioc_pg1);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int\n_base_get_event_diag_triggers(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi26DriverTriggerPage2_t trigger_pg2;\n\tstruct SL_WH_EVENT_TRIGGER_T *event_tg;\n\tMPI26_DRIVER_MPI_EVENT_TIGGER_ENTRY *mpi_event_tg;\n\tMpi2ConfigReply_t mpi_reply;\n\tint r = 0, i = 0;\n\tu16 count = 0;\n\tu16 ioc_status;\n\n\tr = mpt3sas_config_get_driver_trigger_pg2(ioc, &mpi_reply,\n\t    &trigger_pg2);\n\tif (r)\n\t\treturn r;\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tdinitprintk(ioc,\n\t\t    ioc_err(ioc,\n\t\t    \"%s: Failed to get trigger pg2, ioc_status(0x%04x)\\n\",\n\t\t   __func__, ioc_status));\n\t\treturn 0;\n\t}\n\n\tif (le16_to_cpu(trigger_pg2.NumMPIEventTrigger)) {\n\t\tcount = le16_to_cpu(trigger_pg2.NumMPIEventTrigger);\n\t\tcount = min_t(u16, NUM_VALID_ENTRIES, count);\n\t\tioc->diag_trigger_event.ValidEntries = count;\n\n\t\tevent_tg = &ioc->diag_trigger_event.EventTriggerEntry[0];\n\t\tmpi_event_tg = &trigger_pg2.MPIEventTriggers[0];\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tevent_tg->EventValue = le16_to_cpu(\n\t\t\t    mpi_event_tg->MPIEventCode);\n\t\t\tevent_tg->LogEntryQualifier = le16_to_cpu(\n\t\t\t    mpi_event_tg->MPIEventCodeSpecific);\n\t\t\tevent_tg++;\n\t\t\tmpi_event_tg++;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int\n_base_get_scsi_diag_triggers(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi26DriverTriggerPage3_t trigger_pg3;\n\tstruct SL_WH_SCSI_TRIGGER_T *scsi_tg;\n\tMPI26_DRIVER_SCSI_SENSE_TIGGER_ENTRY *mpi_scsi_tg;\n\tMpi2ConfigReply_t mpi_reply;\n\tint r = 0, i = 0;\n\tu16 count = 0;\n\tu16 ioc_status;\n\n\tr = mpt3sas_config_get_driver_trigger_pg3(ioc, &mpi_reply,\n\t    &trigger_pg3);\n\tif (r)\n\t\treturn r;\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tdinitprintk(ioc,\n\t\t    ioc_err(ioc,\n\t\t    \"%s: Failed to get trigger pg3, ioc_status(0x%04x)\\n\",\n\t\t    __func__, ioc_status));\n\t\treturn 0;\n\t}\n\n\tif (le16_to_cpu(trigger_pg3.NumSCSISenseTrigger)) {\n\t\tcount = le16_to_cpu(trigger_pg3.NumSCSISenseTrigger);\n\t\tcount = min_t(u16, NUM_VALID_ENTRIES, count);\n\t\tioc->diag_trigger_scsi.ValidEntries = count;\n\n\t\tscsi_tg = &ioc->diag_trigger_scsi.SCSITriggerEntry[0];\n\t\tmpi_scsi_tg = &trigger_pg3.SCSISenseTriggers[0];\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tscsi_tg->ASCQ = mpi_scsi_tg->ASCQ;\n\t\t\tscsi_tg->ASC = mpi_scsi_tg->ASC;\n\t\t\tscsi_tg->SenseKey = mpi_scsi_tg->SenseKey;\n\n\t\t\tscsi_tg++;\n\t\t\tmpi_scsi_tg++;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int\n_base_get_mpi_diag_triggers(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi26DriverTriggerPage4_t trigger_pg4;\n\tstruct SL_WH_MPI_TRIGGER_T *status_tg;\n\tMPI26_DRIVER_IOCSTATUS_LOGINFO_TIGGER_ENTRY *mpi_status_tg;\n\tMpi2ConfigReply_t mpi_reply;\n\tint r = 0, i = 0;\n\tu16 count = 0;\n\tu16 ioc_status;\n\n\tr = mpt3sas_config_get_driver_trigger_pg4(ioc, &mpi_reply,\n\t    &trigger_pg4);\n\tif (r)\n\t\treturn r;\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tdinitprintk(ioc,\n\t\t    ioc_err(ioc,\n\t\t    \"%s: Failed to get trigger pg4, ioc_status(0x%04x)\\n\",\n\t\t    __func__, ioc_status));\n\t\treturn 0;\n\t}\n\n\tif (le16_to_cpu(trigger_pg4.NumIOCStatusLogInfoTrigger)) {\n\t\tcount = le16_to_cpu(trigger_pg4.NumIOCStatusLogInfoTrigger);\n\t\tcount = min_t(u16, NUM_VALID_ENTRIES, count);\n\t\tioc->diag_trigger_mpi.ValidEntries = count;\n\n\t\tstatus_tg = &ioc->diag_trigger_mpi.MPITriggerEntry[0];\n\t\tmpi_status_tg = &trigger_pg4.IOCStatusLoginfoTriggers[0];\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tstatus_tg->IOCStatus = le16_to_cpu(\n\t\t\t    mpi_status_tg->IOCStatus);\n\t\t\tstatus_tg->IocLogInfo = le32_to_cpu(\n\t\t\t    mpi_status_tg->LogInfo);\n\n\t\t\tstatus_tg++;\n\t\t\tmpi_status_tg++;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int\n_base_get_master_diag_triggers(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi26DriverTriggerPage1_t trigger_pg1;\n\tMpi2ConfigReply_t mpi_reply;\n\tint r;\n\tu16 ioc_status;\n\n\tr = mpt3sas_config_get_driver_trigger_pg1(ioc, &mpi_reply,\n\t    &trigger_pg1);\n\tif (r)\n\t\treturn r;\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tdinitprintk(ioc,\n\t\t    ioc_err(ioc,\n\t\t    \"%s: Failed to get trigger pg1, ioc_status(0x%04x)\\n\",\n\t\t   __func__, ioc_status));\n\t\treturn 0;\n\t}\n\n\tif (le16_to_cpu(trigger_pg1.NumMasterTrigger))\n\t\tioc->diag_trigger_master.MasterData |=\n\t\t    le32_to_cpu(\n\t\t    trigger_pg1.MasterTriggers[0].MasterTriggerFlags);\n\treturn 0;\n}\n\n \nstatic int\n_base_check_for_trigger_pages_support(struct MPT3SAS_ADAPTER *ioc, u32 *trigger_flags)\n{\n\tMpi26DriverTriggerPage0_t trigger_pg0;\n\tint r = 0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 ioc_status;\n\n\tr = mpt3sas_config_get_driver_trigger_pg0(ioc, &mpi_reply,\n\t    &trigger_pg0);\n\tif (r)\n\t\treturn r;\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\treturn -EFAULT;\n\n\t*trigger_flags = le16_to_cpu(trigger_pg0.TriggerFlags);\n\treturn 0;\n}\n\n \nstatic int\n_base_get_diag_triggers(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint trigger_flags;\n\tint r;\n\n\t \n\tioc->diag_trigger_master.MasterData =\n\t    (MASTER_TRIGGER_FW_FAULT + MASTER_TRIGGER_ADAPTER_RESET);\n\n\tr = _base_check_for_trigger_pages_support(ioc, &trigger_flags);\n\tif (r) {\n\t\tif (r == -EAGAIN)\n\t\t\treturn r;\n\t\t \n\t\treturn 0;\n\t}\n\n\tioc->supports_trigger_pages = 1;\n\n\t \n\tif ((u16)trigger_flags &\n\t    MPI26_DRIVER_TRIGGER0_FLAG_MASTER_TRIGGER_VALID) {\n\t\tr = _base_get_master_diag_triggers(ioc);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t \n\tif ((u16)trigger_flags &\n\t    MPI26_DRIVER_TRIGGER0_FLAG_MPI_EVENT_TRIGGER_VALID) {\n\t\tr = _base_get_event_diag_triggers(ioc);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t \n\tif ((u16)trigger_flags &\n\t    MPI26_DRIVER_TRIGGER0_FLAG_SCSI_SENSE_TRIGGER_VALID) {\n\t\tr = _base_get_scsi_diag_triggers(ioc);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\t \n\tif ((u16)trigger_flags &\n\t    MPI26_DRIVER_TRIGGER0_FLAG_LOGINFO_TRIGGER_VALID) {\n\t\tr = _base_get_mpi_diag_triggers(ioc);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\n \nstatic void\n_base_update_diag_trigger_pages(struct MPT3SAS_ADAPTER *ioc)\n{\n\n\tif (ioc->diag_trigger_master.MasterData)\n\t\tmpt3sas_config_update_driver_trigger_pg1(ioc,\n\t\t    &ioc->diag_trigger_master, 1);\n\n\tif (ioc->diag_trigger_event.ValidEntries)\n\t\tmpt3sas_config_update_driver_trigger_pg2(ioc,\n\t\t    &ioc->diag_trigger_event, 1);\n\n\tif (ioc->diag_trigger_scsi.ValidEntries)\n\t\tmpt3sas_config_update_driver_trigger_pg3(ioc,\n\t\t    &ioc->diag_trigger_scsi, 1);\n\n\tif (ioc->diag_trigger_mpi.ValidEntries)\n\t\tmpt3sas_config_update_driver_trigger_pg4(ioc,\n\t\t    &ioc->diag_trigger_mpi, 1);\n}\n\n \nstatic int _base_assign_fw_reported_qd(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasIOUnitPage1_t *sas_iounit_pg1 = NULL;\n\tMpi26PCIeIOUnitPage1_t pcie_iounit_pg1;\n\tu16 depth;\n\tint sz;\n\tint rc = 0;\n\n\tioc->max_wideport_qd = MPT3SAS_SAS_QUEUE_DEPTH;\n\tioc->max_narrowport_qd = MPT3SAS_SAS_QUEUE_DEPTH;\n\tioc->max_sata_qd = MPT3SAS_SATA_QUEUE_DEPTH;\n\tioc->max_nvme_qd = MPT3SAS_NVME_QUEUE_DEPTH;\n\tif (!ioc->is_gen35_ioc)\n\t\tgoto out;\n\t \n\tsz = offsetof(Mpi2SasIOUnitPage1_t, PhyData);\n\tsas_iounit_pg1 = kzalloc(sizeof(Mpi2SasIOUnitPage1_t), GFP_KERNEL);\n\tif (!sas_iounit_pg1) {\n\t\tpr_err(\"%s: failure at %s:%d/%s()!\\n\",\n\t\t    ioc->name, __FILE__, __LINE__, __func__);\n\t\treturn rc;\n\t}\n\trc = mpt3sas_config_get_sas_iounit_pg1(ioc, &mpi_reply,\n\t    sas_iounit_pg1, sz);\n\tif (rc) {\n\t\tpr_err(\"%s: failure at %s:%d/%s()!\\n\",\n\t\t    ioc->name, __FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\tdepth = le16_to_cpu(sas_iounit_pg1->SASWideMaxQueueDepth);\n\tioc->max_wideport_qd = (depth ? depth : MPT3SAS_SAS_QUEUE_DEPTH);\n\n\tdepth = le16_to_cpu(sas_iounit_pg1->SASNarrowMaxQueueDepth);\n\tioc->max_narrowport_qd = (depth ? depth : MPT3SAS_SAS_QUEUE_DEPTH);\n\n\tdepth = sas_iounit_pg1->SATAMaxQDepth;\n\tioc->max_sata_qd = (depth ? depth : MPT3SAS_SATA_QUEUE_DEPTH);\n\n\t \n\trc = mpt3sas_config_get_pcie_iounit_pg1(ioc, &mpi_reply,\n\t    &pcie_iounit_pg1, sizeof(Mpi26PCIeIOUnitPage1_t));\n\tif (rc) {\n\t\tpr_err(\"%s: failure at %s:%d/%s()!\\n\",\n\t\t    ioc->name, __FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tioc->max_nvme_qd = (le16_to_cpu(pcie_iounit_pg1.NVMeMaxQueueDepth)) ?\n\t    (le16_to_cpu(pcie_iounit_pg1.NVMeMaxQueueDepth)) :\n\t    MPT3SAS_NVME_QUEUE_DEPTH;\nout:\n\tdinitprintk(ioc, pr_err(\n\t    \"MaxWidePortQD: 0x%x MaxNarrowPortQD: 0x%x MaxSataQD: 0x%x MaxNvmeQD: 0x%x\\n\",\n\t    ioc->max_wideport_qd, ioc->max_narrowport_qd,\n\t    ioc->max_sata_qd, ioc->max_nvme_qd));\n\tkfree(sas_iounit_pg1);\n\treturn rc;\n}\n\n \nstatic int\nmpt3sas_atto_validate_nvram(struct MPT3SAS_ADAPTER *ioc,\n\t\t\t    struct ATTO_SAS_NVRAM *n)\n{\n\tint r = -EINVAL;\n\tunion ATTO_SAS_ADDRESS *s1;\n\tu32 len;\n\tu8 *pb;\n\tu8 ckSum;\n\n\t \n\tpb = (u8 *) n;\n\tckSum = ATTO_SASNVR_CKSUM_SEED;\n\tlen = sizeof(struct ATTO_SAS_NVRAM);\n\n\twhile (len--)\n\t\tckSum = ckSum + pb[len];\n\n\tif (ckSum) {\n\t\tioc_err(ioc, \"Invalid ATTO NVRAM checksum\\n\");\n\t\treturn r;\n\t}\n\n\ts1 = (union ATTO_SAS_ADDRESS *) n->SasAddr;\n\n\tif (n->Signature[0] != 'E'\n\t|| n->Signature[1] != 'S'\n\t|| n->Signature[2] != 'A'\n\t|| n->Signature[3] != 'S')\n\t\tioc_err(ioc, \"Invalid ATTO NVRAM signature\\n\");\n\telse if (n->Version > ATTO_SASNVR_VERSION)\n\t\tioc_info(ioc, \"Invalid ATTO NVRAM version\");\n\telse if ((n->SasAddr[7] & (ATTO_SAS_ADDR_ALIGN - 1))\n\t\t\t|| s1->b[0] != 0x50\n\t\t\t|| s1->b[1] != 0x01\n\t\t\t|| s1->b[2] != 0x08\n\t\t\t|| (s1->b[3] & 0xF0) != 0x60\n\t\t\t|| ((s1->b[3] & 0x0F) | le32_to_cpu(s1->d[1])) == 0) {\n\t\tioc_err(ioc, \"Invalid ATTO SAS address\\n\");\n\t} else\n\t\tr = 0;\n\treturn r;\n}\n\n \nstatic int\nmpt3sas_atto_get_sas_addr(struct MPT3SAS_ADAPTER *ioc, union ATTO_SAS_ADDRESS *sas_addr)\n{\n\tMpi2ManufacturingPage1_t mfg_pg1;\n\tMpi2ConfigReply_t mpi_reply;\n\tstruct ATTO_SAS_NVRAM *nvram;\n\tint r;\n\t__be64 addr;\n\n\tr = mpt3sas_config_get_manufacturing_pg1(ioc, &mpi_reply, &mfg_pg1);\n\tif (r) {\n\t\tioc_err(ioc, \"Failed to read manufacturing page 1\\n\");\n\t\treturn r;\n\t}\n\n\t \n\tnvram = (struct ATTO_SAS_NVRAM *) mfg_pg1.VPD;\n\tr = mpt3sas_atto_validate_nvram(ioc, nvram);\n\tif (r)\n\t\treturn r;\n\n\taddr = *((__be64 *) nvram->SasAddr);\n\tsas_addr->q = cpu_to_le64(be64_to_cpu(addr));\n\treturn r;\n}\n\n \nstatic int\nmpt3sas_atto_init(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint sz = 0;\n\tMpi2BiosPage4_t *bios_pg4 = NULL;\n\tMpi2ConfigReply_t mpi_reply;\n\tint r;\n\tint ix;\n\tunion ATTO_SAS_ADDRESS sas_addr;\n\tunion ATTO_SAS_ADDRESS temp;\n\tunion ATTO_SAS_ADDRESS bias;\n\n\tr = mpt3sas_atto_get_sas_addr(ioc, &sas_addr);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = mpt3sas_config_get_bios_pg4(ioc, &mpi_reply, NULL, 0);\n\tif (r) {\n\t\tioc_err(ioc, \"Failed to read ATTO bios page 4 header.\\n\");\n\t\treturn r;\n\t}\n\n\tsz = mpi_reply.Header.PageLength * sizeof(u32);\n\tbios_pg4 = kzalloc(sz, GFP_KERNEL);\n\tif (!bios_pg4) {\n\t\tioc_err(ioc, \"Failed to allocate memory for ATTO bios page.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tr = mpt3sas_config_get_bios_pg4(ioc, &mpi_reply, bios_pg4, sz);\n\tif (r) {\n\t\tioc_err(ioc, \"Failed to read ATTO bios page 4\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tbias.q = sas_addr.q;\n\tbias.b[7] += ATTO_SAS_ADDR_DEVNAME_BIAS;\n\n\tfor (ix = 0; ix < bios_pg4->NumPhys; ix++) {\n\t\ttemp.q = sas_addr.q;\n\t\ttemp.b[7] += ix;\n\t\tbios_pg4->Phy[ix].ReassignmentWWID = temp.q;\n\t\tbios_pg4->Phy[ix].ReassignmentDeviceName = bias.q;\n\t}\n\tr = mpt3sas_config_set_bios_pg4(ioc, &mpi_reply, bios_pg4, sz);\n\nout:\n\tkfree(bios_pg4);\n\treturn r;\n}\n\n \nstatic int\n_base_static_config_pages(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2ConfigReply_t mpi_reply;\n\tu32 iounit_pg1_flags;\n\tint tg_flags = 0;\n\tint rc;\n\tioc->nvme_abort_timeout = 30;\n\n\trc = mpt3sas_config_get_manufacturing_pg0(ioc, &mpi_reply,\n\t    &ioc->manu_pg0);\n\tif (rc)\n\t\treturn rc;\n\tif (ioc->ir_firmware) {\n\t\trc = mpt3sas_config_get_manufacturing_pg10(ioc, &mpi_reply,\n\t\t    &ioc->manu_pg10);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (ioc->pdev->vendor == MPI2_MFGPAGE_VENDORID_ATTO) {\n\t\trc = mpt3sas_atto_init(ioc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\trc = mpt3sas_config_get_manufacturing_pg11(ioc, &mpi_reply,\n\t    &ioc->manu_pg11);\n\tif (rc)\n\t\treturn rc;\n\tif (!ioc->is_gen35_ioc && ioc->manu_pg11.EEDPTagMode == 0) {\n\t\tpr_err(\"%s: overriding NVDATA EEDPTagMode setting\\n\",\n\t\t    ioc->name);\n\t\tioc->manu_pg11.EEDPTagMode &= ~0x3;\n\t\tioc->manu_pg11.EEDPTagMode |= 0x1;\n\t\tmpt3sas_config_set_manufacturing_pg11(ioc, &mpi_reply,\n\t\t    &ioc->manu_pg11);\n\t}\n\tif (ioc->manu_pg11.AddlFlags2 & NVME_TASK_MNGT_CUSTOM_MASK)\n\t\tioc->tm_custom_handling = 1;\n\telse {\n\t\tioc->tm_custom_handling = 0;\n\t\tif (ioc->manu_pg11.NVMeAbortTO < NVME_TASK_ABORT_MIN_TIMEOUT)\n\t\t\tioc->nvme_abort_timeout = NVME_TASK_ABORT_MIN_TIMEOUT;\n\t\telse if (ioc->manu_pg11.NVMeAbortTO >\n\t\t\t\t\tNVME_TASK_ABORT_MAX_TIMEOUT)\n\t\t\tioc->nvme_abort_timeout = NVME_TASK_ABORT_MAX_TIMEOUT;\n\t\telse\n\t\t\tioc->nvme_abort_timeout = ioc->manu_pg11.NVMeAbortTO;\n\t}\n\tioc->time_sync_interval =\n\t    ioc->manu_pg11.TimeSyncInterval & MPT3SAS_TIMESYNC_MASK;\n\tif (ioc->time_sync_interval) {\n\t\tif (ioc->manu_pg11.TimeSyncInterval & MPT3SAS_TIMESYNC_UNIT_MASK)\n\t\t\tioc->time_sync_interval =\n\t\t\t    ioc->time_sync_interval * SECONDS_PER_HOUR;\n\t\telse\n\t\t\tioc->time_sync_interval =\n\t\t\t    ioc->time_sync_interval * SECONDS_PER_MIN;\n\t\tdinitprintk(ioc, ioc_info(ioc,\n\t\t    \"Driver-FW TimeSync interval is %d seconds. ManuPg11 TimeSync Unit is in %s\\n\",\n\t\t    ioc->time_sync_interval, (ioc->manu_pg11.TimeSyncInterval &\n\t\t    MPT3SAS_TIMESYNC_UNIT_MASK) ? \"Hour\" : \"Minute\"));\n\t} else {\n\t\tif (ioc->is_gen35_ioc)\n\t\t\tioc_warn(ioc,\n\t\t\t    \"TimeSync Interval in Manuf page-11 is not enabled. Periodic Time-Sync will be disabled\\n\");\n\t}\n\trc = _base_assign_fw_reported_qd(ioc);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (ioc->pdev->vendor ==  MPI2_MFGPAGE_VENDORID_ATTO)\n\t\tioc->bios_pg3.BiosVersion = 0;\n\telse {\n\t\trc = mpt3sas_config_get_bios_pg2(ioc, &mpi_reply, &ioc->bios_pg2);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = mpt3sas_config_get_bios_pg3(ioc, &mpi_reply, &ioc->bios_pg3);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = mpt3sas_config_get_ioc_pg8(ioc, &mpi_reply, &ioc->ioc_pg8);\n\tif (rc)\n\t\treturn rc;\n\trc = mpt3sas_config_get_iounit_pg0(ioc, &mpi_reply, &ioc->iounit_pg0);\n\tif (rc)\n\t\treturn rc;\n\trc = mpt3sas_config_get_iounit_pg1(ioc, &mpi_reply, &ioc->iounit_pg1);\n\tif (rc)\n\t\treturn rc;\n\trc = mpt3sas_config_get_iounit_pg8(ioc, &mpi_reply, &ioc->iounit_pg8);\n\tif (rc)\n\t\treturn rc;\n\t_base_display_ioc_capabilities(ioc);\n\n\t \n\tiounit_pg1_flags = le32_to_cpu(ioc->iounit_pg1.Flags);\n\tif ((ioc->facts.IOCCapabilities &\n\t    MPI2_IOCFACTS_CAPABILITY_TASK_SET_FULL_HANDLING))\n\t\tiounit_pg1_flags &=\n\t\t    ~MPI2_IOUNITPAGE1_DISABLE_TASK_SET_FULL_HANDLING;\n\telse\n\t\tiounit_pg1_flags |=\n\t\t    MPI2_IOUNITPAGE1_DISABLE_TASK_SET_FULL_HANDLING;\n\tioc->iounit_pg1.Flags = cpu_to_le32(iounit_pg1_flags);\n\trc = mpt3sas_config_set_iounit_pg1(ioc, &mpi_reply, &ioc->iounit_pg1);\n\tif (rc)\n\t\treturn rc;\n\n\tif (ioc->iounit_pg8.NumSensors)\n\t\tioc->temp_sensors_count = ioc->iounit_pg8.NumSensors;\n\tif (ioc->is_aero_ioc) {\n\t\trc = _base_update_ioc_page1_inlinewith_perf_mode(ioc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif (ioc->is_gen35_ioc) {\n\t\tif (ioc->is_driver_loading) {\n\t\t\trc = _base_get_diag_triggers(ioc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t} else {\n\t\t\t \n\t\t\t_base_check_for_trigger_pages_support(ioc, &tg_flags);\n\t\t\tif (!ioc->supports_trigger_pages && tg_flags != -EFAULT)\n\t\t\t\t_base_update_diag_trigger_pages(ioc);\n\t\t\telse if (ioc->supports_trigger_pages &&\n\t\t\t    tg_flags == -EFAULT)\n\t\t\t\tioc->supports_trigger_pages = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nvoid\nmpt3sas_free_enclosure_list(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _enclosure_node *enclosure_dev, *enclosure_dev_next;\n\n\t \n\tlist_for_each_entry_safe(enclosure_dev,\n\t\t\tenclosure_dev_next, &ioc->enclosure_list, list) {\n\t\tlist_del(&enclosure_dev->list);\n\t\tkfree(enclosure_dev);\n\t}\n}\n\n \nstatic void\n_base_release_memory_pools(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint i = 0;\n\tint j = 0;\n\tint dma_alloc_count = 0;\n\tstruct chain_tracker *ct;\n\tint count = ioc->rdpq_array_enable ? ioc->reply_queue_count : 1;\n\n\tdexitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tif (ioc->request) {\n\t\tdma_free_coherent(&ioc->pdev->dev, ioc->request_dma_sz,\n\t\t    ioc->request,  ioc->request_dma);\n\t\tdexitprintk(ioc,\n\t\t\t    ioc_info(ioc, \"request_pool(0x%p): free\\n\",\n\t\t\t\t     ioc->request));\n\t\tioc->request = NULL;\n\t}\n\n\tif (ioc->sense) {\n\t\tdma_pool_free(ioc->sense_dma_pool, ioc->sense, ioc->sense_dma);\n\t\tdma_pool_destroy(ioc->sense_dma_pool);\n\t\tdexitprintk(ioc,\n\t\t\t    ioc_info(ioc, \"sense_pool(0x%p): free\\n\",\n\t\t\t\t     ioc->sense));\n\t\tioc->sense = NULL;\n\t}\n\n\tif (ioc->reply) {\n\t\tdma_pool_free(ioc->reply_dma_pool, ioc->reply, ioc->reply_dma);\n\t\tdma_pool_destroy(ioc->reply_dma_pool);\n\t\tdexitprintk(ioc,\n\t\t\t    ioc_info(ioc, \"reply_pool(0x%p): free\\n\",\n\t\t\t\t     ioc->reply));\n\t\tioc->reply = NULL;\n\t}\n\n\tif (ioc->reply_free) {\n\t\tdma_pool_free(ioc->reply_free_dma_pool, ioc->reply_free,\n\t\t    ioc->reply_free_dma);\n\t\tdma_pool_destroy(ioc->reply_free_dma_pool);\n\t\tdexitprintk(ioc,\n\t\t\t    ioc_info(ioc, \"reply_free_pool(0x%p): free\\n\",\n\t\t\t\t     ioc->reply_free));\n\t\tioc->reply_free = NULL;\n\t}\n\n\tif (ioc->reply_post) {\n\t\tdma_alloc_count = DIV_ROUND_UP(count,\n\t\t\t\tRDPQ_MAX_INDEX_IN_ONE_CHUNK);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (i % RDPQ_MAX_INDEX_IN_ONE_CHUNK == 0\n\t\t\t    && dma_alloc_count) {\n\t\t\t\tif (ioc->reply_post[i].reply_post_free) {\n\t\t\t\t\tdma_pool_free(\n\t\t\t\t\t    ioc->reply_post_free_dma_pool,\n\t\t\t\t\t    ioc->reply_post[i].reply_post_free,\n\t\t\t\t\tioc->reply_post[i].reply_post_free_dma);\n\t\t\t\t\tdexitprintk(ioc, ioc_info(ioc,\n\t\t\t\t\t   \"reply_post_free_pool(0x%p): free\\n\",\n\t\t\t\t\t   ioc->reply_post[i].reply_post_free));\n\t\t\t\t\tioc->reply_post[i].reply_post_free =\n\t\t\t\t\t\t\t\t\tNULL;\n\t\t\t\t}\n\t\t\t\t--dma_alloc_count;\n\t\t\t}\n\t\t}\n\t\tdma_pool_destroy(ioc->reply_post_free_dma_pool);\n\t\tif (ioc->reply_post_free_array &&\n\t\t\tioc->rdpq_array_enable) {\n\t\t\tdma_pool_free(ioc->reply_post_free_array_dma_pool,\n\t\t\t    ioc->reply_post_free_array,\n\t\t\t    ioc->reply_post_free_array_dma);\n\t\t\tioc->reply_post_free_array = NULL;\n\t\t}\n\t\tdma_pool_destroy(ioc->reply_post_free_array_dma_pool);\n\t\tkfree(ioc->reply_post);\n\t}\n\n\tif (ioc->pcie_sgl_dma_pool) {\n\t\tfor (i = 0; i < ioc->scsiio_depth; i++) {\n\t\t\tdma_pool_free(ioc->pcie_sgl_dma_pool,\n\t\t\t\t\tioc->pcie_sg_lookup[i].pcie_sgl,\n\t\t\t\t\tioc->pcie_sg_lookup[i].pcie_sgl_dma);\n\t\t\tioc->pcie_sg_lookup[i].pcie_sgl = NULL;\n\t\t}\n\t\tdma_pool_destroy(ioc->pcie_sgl_dma_pool);\n\t}\n\tkfree(ioc->pcie_sg_lookup);\n\tioc->pcie_sg_lookup = NULL;\n\n\tif (ioc->config_page) {\n\t\tdexitprintk(ioc,\n\t\t\t    ioc_info(ioc, \"config_page(0x%p): free\\n\",\n\t\t\t\t     ioc->config_page));\n\t\tdma_free_coherent(&ioc->pdev->dev, ioc->config_page_sz,\n\t\t    ioc->config_page, ioc->config_page_dma);\n\t}\n\n\tkfree(ioc->hpr_lookup);\n\tioc->hpr_lookup = NULL;\n\tkfree(ioc->internal_lookup);\n\tioc->internal_lookup = NULL;\n\tif (ioc->chain_lookup) {\n\t\tfor (i = 0; i < ioc->scsiio_depth; i++) {\n\t\t\tfor (j = ioc->chains_per_prp_buffer;\n\t\t\t    j < ioc->chains_needed_per_io; j++) {\n\t\t\t\tct = &ioc->chain_lookup[i].chains_per_smid[j];\n\t\t\t\tif (ct && ct->chain_buffer)\n\t\t\t\t\tdma_pool_free(ioc->chain_dma_pool,\n\t\t\t\t\t\tct->chain_buffer,\n\t\t\t\t\t\tct->chain_buffer_dma);\n\t\t\t}\n\t\t\tkfree(ioc->chain_lookup[i].chains_per_smid);\n\t\t}\n\t\tdma_pool_destroy(ioc->chain_dma_pool);\n\t\tkfree(ioc->chain_lookup);\n\t\tioc->chain_lookup = NULL;\n\t}\n\n\tkfree(ioc->io_queue_num);\n\tioc->io_queue_num = NULL;\n}\n\n \nstatic int\nmpt3sas_check_same_4gb_region(dma_addr_t start_address, u32 pool_sz)\n{\n\tdma_addr_t end_address;\n\n\tend_address = start_address + pool_sz - 1;\n\n\tif (upper_32_bits(start_address) == upper_32_bits(end_address))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic inline int\n_base_reduce_hba_queue_depth(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint reduce_sz = 64;\n\n\tif ((ioc->hba_queue_depth - reduce_sz) >\n\t    (ioc->internal_depth + INTERNAL_SCSIIO_CMDS_COUNT)) {\n\t\tioc->hba_queue_depth -= reduce_sz;\n\t\treturn 0;\n\t} else\n\t\treturn -ENOMEM;\n}\n\n \n\nstatic int\n_base_allocate_pcie_sgl_pool(struct MPT3SAS_ADAPTER *ioc, u32 sz)\n{\n\tint i = 0, j = 0;\n\tstruct chain_tracker *ct;\n\n\tioc->pcie_sgl_dma_pool =\n\t    dma_pool_create(\"PCIe SGL pool\", &ioc->pdev->dev, sz,\n\t    ioc->page_size, 0);\n\tif (!ioc->pcie_sgl_dma_pool) {\n\t\tioc_err(ioc, \"PCIe SGL pool: dma_pool_create failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tioc->chains_per_prp_buffer = sz/ioc->chain_segment_sz;\n\tioc->chains_per_prp_buffer =\n\t    min(ioc->chains_per_prp_buffer, ioc->chains_needed_per_io);\n\tfor (i = 0; i < ioc->scsiio_depth; i++) {\n\t\tioc->pcie_sg_lookup[i].pcie_sgl =\n\t\t    dma_pool_alloc(ioc->pcie_sgl_dma_pool, GFP_KERNEL,\n\t\t    &ioc->pcie_sg_lookup[i].pcie_sgl_dma);\n\t\tif (!ioc->pcie_sg_lookup[i].pcie_sgl) {\n\t\t\tioc_err(ioc, \"PCIe SGL pool: dma_pool_alloc failed\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (!mpt3sas_check_same_4gb_region(\n\t\t    ioc->pcie_sg_lookup[i].pcie_sgl_dma, sz)) {\n\t\t\tioc_err(ioc, \"PCIE SGLs are not in same 4G !! pcie sgl (0x%p) dma = (0x%llx)\\n\",\n\t\t\t    ioc->pcie_sg_lookup[i].pcie_sgl,\n\t\t\t    (unsigned long long)\n\t\t\t    ioc->pcie_sg_lookup[i].pcie_sgl_dma);\n\t\t\tioc->use_32bit_dma = true;\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tfor (j = 0; j < ioc->chains_per_prp_buffer; j++) {\n\t\t\tct = &ioc->chain_lookup[i].chains_per_smid[j];\n\t\t\tct->chain_buffer =\n\t\t\t    ioc->pcie_sg_lookup[i].pcie_sgl +\n\t\t\t    (j * ioc->chain_segment_sz);\n\t\t\tct->chain_buffer_dma =\n\t\t\t    ioc->pcie_sg_lookup[i].pcie_sgl_dma +\n\t\t\t    (j * ioc->chain_segment_sz);\n\t\t}\n\t}\n\tdinitprintk(ioc, ioc_info(ioc,\n\t    \"PCIe sgl pool depth(%d), element_size(%d), pool_size(%d kB)\\n\",\n\t    ioc->scsiio_depth, sz, (sz * ioc->scsiio_depth)/1024));\n\tdinitprintk(ioc, ioc_info(ioc,\n\t    \"Number of chains can fit in a PRP page(%d)\\n\",\n\t    ioc->chains_per_prp_buffer));\n\treturn 0;\n}\n\n \nstatic int\n_base_allocate_chain_dma_pool(struct MPT3SAS_ADAPTER *ioc, u32 sz)\n{\n\tint i = 0, j = 0;\n\tstruct chain_tracker *ctr;\n\n\tioc->chain_dma_pool = dma_pool_create(\"chain pool\", &ioc->pdev->dev,\n\t    ioc->chain_segment_sz, 16, 0);\n\tif (!ioc->chain_dma_pool)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ioc->scsiio_depth; i++) {\n\t\tfor (j = ioc->chains_per_prp_buffer;\n\t\t    j < ioc->chains_needed_per_io; j++) {\n\t\t\tctr = &ioc->chain_lookup[i].chains_per_smid[j];\n\t\t\tctr->chain_buffer = dma_pool_alloc(ioc->chain_dma_pool,\n\t\t\t    GFP_KERNEL, &ctr->chain_buffer_dma);\n\t\t\tif (!ctr->chain_buffer)\n\t\t\t\treturn -EAGAIN;\n\t\t\tif (!mpt3sas_check_same_4gb_region(\n\t\t\t    ctr->chain_buffer_dma, ioc->chain_segment_sz)) {\n\t\t\t\tioc_err(ioc,\n\t\t\t\t    \"Chain buffers are not in same 4G !!! Chain buff (0x%p) dma = (0x%llx)\\n\",\n\t\t\t\t    ctr->chain_buffer,\n\t\t\t\t    (unsigned long long)ctr->chain_buffer_dma);\n\t\t\t\tioc->use_32bit_dma = true;\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t}\n\t}\n\tdinitprintk(ioc, ioc_info(ioc,\n\t    \"chain_lookup depth (%d), frame_size(%d), pool_size(%d kB)\\n\",\n\t    ioc->scsiio_depth, ioc->chain_segment_sz, ((ioc->scsiio_depth *\n\t    (ioc->chains_needed_per_io - ioc->chains_per_prp_buffer) *\n\t    ioc->chain_segment_sz))/1024));\n\treturn 0;\n}\n\n \nstatic int\n_base_allocate_sense_dma_pool(struct MPT3SAS_ADAPTER *ioc, u32 sz)\n{\n\tioc->sense_dma_pool =\n\t    dma_pool_create(\"sense pool\", &ioc->pdev->dev, sz, 4, 0);\n\tif (!ioc->sense_dma_pool)\n\t\treturn -ENOMEM;\n\tioc->sense = dma_pool_alloc(ioc->sense_dma_pool,\n\t    GFP_KERNEL, &ioc->sense_dma);\n\tif (!ioc->sense)\n\t\treturn -EAGAIN;\n\tif (!mpt3sas_check_same_4gb_region(ioc->sense_dma, sz)) {\n\t\tdinitprintk(ioc, pr_err(\n\t\t    \"Bad Sense Pool! sense (0x%p) sense_dma = (0x%llx)\\n\",\n\t\t    ioc->sense, (unsigned long long) ioc->sense_dma));\n\t\tioc->use_32bit_dma = true;\n\t\treturn -EAGAIN;\n\t}\n\tioc_info(ioc,\n\t    \"sense pool(0x%p) - dma(0x%llx): depth(%d), element_size(%d), pool_size (%d kB)\\n\",\n\t    ioc->sense, (unsigned long long)ioc->sense_dma,\n\t    ioc->scsiio_depth, SCSI_SENSE_BUFFERSIZE, sz/1024);\n\treturn 0;\n}\n\n \nstatic int\n_base_allocate_reply_pool(struct MPT3SAS_ADAPTER *ioc, u32 sz)\n{\n\t \n\tioc->reply_dma_pool = dma_pool_create(\"reply pool\",\n\t    &ioc->pdev->dev, sz, 4, 0);\n\tif (!ioc->reply_dma_pool)\n\t\treturn -ENOMEM;\n\tioc->reply = dma_pool_alloc(ioc->reply_dma_pool, GFP_KERNEL,\n\t    &ioc->reply_dma);\n\tif (!ioc->reply)\n\t\treturn -EAGAIN;\n\tif (!mpt3sas_check_same_4gb_region(ioc->reply_dma, sz)) {\n\t\tdinitprintk(ioc, pr_err(\n\t\t    \"Bad Reply Pool! Reply (0x%p) Reply dma = (0x%llx)\\n\",\n\t\t    ioc->reply, (unsigned long long) ioc->reply_dma));\n\t\tioc->use_32bit_dma = true;\n\t\treturn -EAGAIN;\n\t}\n\tioc->reply_dma_min_address = (u32)(ioc->reply_dma);\n\tioc->reply_dma_max_address = (u32)(ioc->reply_dma) + sz;\n\tioc_info(ioc,\n\t    \"reply pool(0x%p) - dma(0x%llx): depth(%d), frame_size(%d), pool_size(%d kB)\\n\",\n\t    ioc->reply, (unsigned long long)ioc->reply_dma,\n\t    ioc->reply_free_queue_depth, ioc->reply_sz, sz/1024);\n\treturn 0;\n}\n\n \nstatic int\n_base_allocate_reply_free_dma_pool(struct MPT3SAS_ADAPTER *ioc, u32 sz)\n{\n\t \n\tioc->reply_free_dma_pool = dma_pool_create(\n\t    \"reply_free pool\", &ioc->pdev->dev, sz, 16, 0);\n\tif (!ioc->reply_free_dma_pool)\n\t\treturn -ENOMEM;\n\tioc->reply_free = dma_pool_alloc(ioc->reply_free_dma_pool,\n\t    GFP_KERNEL, &ioc->reply_free_dma);\n\tif (!ioc->reply_free)\n\t\treturn -EAGAIN;\n\tif (!mpt3sas_check_same_4gb_region(ioc->reply_free_dma, sz)) {\n\t\tdinitprintk(ioc,\n\t\t    pr_err(\"Bad Reply Free Pool! Reply Free (0x%p) Reply Free dma = (0x%llx)\\n\",\n\t\t    ioc->reply_free, (unsigned long long) ioc->reply_free_dma));\n\t\tioc->use_32bit_dma = true;\n\t\treturn -EAGAIN;\n\t}\n\tmemset(ioc->reply_free, 0, sz);\n\tdinitprintk(ioc, ioc_info(ioc,\n\t    \"reply_free pool(0x%p): depth(%d), element_size(%d), pool_size(%d kB)\\n\",\n\t    ioc->reply_free, ioc->reply_free_queue_depth, 4, sz/1024));\n\tdinitprintk(ioc, ioc_info(ioc,\n\t    \"reply_free_dma (0x%llx)\\n\",\n\t    (unsigned long long)ioc->reply_free_dma));\n\treturn 0;\n}\n\n \n\nstatic int\n_base_allocate_reply_post_free_array(struct MPT3SAS_ADAPTER *ioc,\n\tu32 reply_post_free_array_sz)\n{\n\tioc->reply_post_free_array_dma_pool =\n\t    dma_pool_create(\"reply_post_free_array pool\",\n\t    &ioc->pdev->dev, reply_post_free_array_sz, 16, 0);\n\tif (!ioc->reply_post_free_array_dma_pool)\n\t\treturn -ENOMEM;\n\tioc->reply_post_free_array =\n\t    dma_pool_alloc(ioc->reply_post_free_array_dma_pool,\n\t    GFP_KERNEL, &ioc->reply_post_free_array_dma);\n\tif (!ioc->reply_post_free_array)\n\t\treturn -EAGAIN;\n\tif (!mpt3sas_check_same_4gb_region(ioc->reply_post_free_array_dma,\n\t    reply_post_free_array_sz)) {\n\t\tdinitprintk(ioc, pr_err(\n\t\t    \"Bad Reply Free Pool! Reply Free (0x%p) Reply Free dma = (0x%llx)\\n\",\n\t\t    ioc->reply_free,\n\t\t    (unsigned long long) ioc->reply_free_dma));\n\t\tioc->use_32bit_dma = true;\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n \nstatic int\nbase_alloc_rdpq_dma_pool(struct MPT3SAS_ADAPTER *ioc, int sz)\n{\n\tint i = 0;\n\tu32 dma_alloc_count = 0;\n\tint reply_post_free_sz = ioc->reply_post_queue_depth *\n\t\tsizeof(Mpi2DefaultReplyDescriptor_t);\n\tint count = ioc->rdpq_array_enable ? ioc->reply_queue_count : 1;\n\n\tioc->reply_post = kcalloc(count, sizeof(struct reply_post_struct),\n\t\t\tGFP_KERNEL);\n\tif (!ioc->reply_post)\n\t\treturn -ENOMEM;\n\t \n\tdma_alloc_count = DIV_ROUND_UP(count,\n\t\t\t\tRDPQ_MAX_INDEX_IN_ONE_CHUNK);\n\tioc->reply_post_free_dma_pool =\n\t\tdma_pool_create(\"reply_post_free pool\",\n\t\t    &ioc->pdev->dev, sz, 16, 0);\n\tif (!ioc->reply_post_free_dma_pool)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < count; i++) {\n\t\tif ((i % RDPQ_MAX_INDEX_IN_ONE_CHUNK == 0) && dma_alloc_count) {\n\t\t\tioc->reply_post[i].reply_post_free =\n\t\t\t    dma_pool_zalloc(ioc->reply_post_free_dma_pool,\n\t\t\t\tGFP_KERNEL,\n\t\t\t\t&ioc->reply_post[i].reply_post_free_dma);\n\t\t\tif (!ioc->reply_post[i].reply_post_free)\n\t\t\t\treturn -ENOMEM;\n\t\t\t \n\t\t\tif (!mpt3sas_check_same_4gb_region(\n\t\t\t\tioc->reply_post[i].reply_post_free_dma, sz)) {\n\t\t\t\tdinitprintk(ioc,\n\t\t\t\t    ioc_err(ioc, \"bad Replypost free pool(0x%p)\"\n\t\t\t\t    \"reply_post_free_dma = (0x%llx)\\n\",\n\t\t\t\t    ioc->reply_post[i].reply_post_free,\n\t\t\t\t    (unsigned long long)\n\t\t\t\t    ioc->reply_post[i].reply_post_free_dma));\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t\tdma_alloc_count--;\n\n\t\t} else {\n\t\t\tioc->reply_post[i].reply_post_free =\n\t\t\t    (Mpi2ReplyDescriptorsUnion_t *)\n\t\t\t    ((long)ioc->reply_post[i-1].reply_post_free\n\t\t\t    + reply_post_free_sz);\n\t\t\tioc->reply_post[i].reply_post_free_dma =\n\t\t\t    (dma_addr_t)\n\t\t\t    (ioc->reply_post[i-1].reply_post_free_dma +\n\t\t\t    reply_post_free_sz);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int\n_base_allocate_memory_pools(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct mpt3sas_facts *facts;\n\tu16 max_sge_elements;\n\tu16 chains_needed_per_io;\n\tu32 sz, total_sz, reply_post_free_sz, reply_post_free_array_sz;\n\tu32 retry_sz;\n\tu32 rdpq_sz = 0, sense_sz = 0;\n\tu16 max_request_credit, nvme_blocks_needed;\n\tunsigned short sg_tablesize;\n\tu16 sge_size;\n\tint i;\n\tint ret = 0, rc = 0;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\n\tretry_sz = 0;\n\tfacts = &ioc->facts;\n\n\t \n\tif (max_sgl_entries != -1)\n\t\tsg_tablesize = max_sgl_entries;\n\telse {\n\t\tif (ioc->hba_mpi_version_belonged == MPI2_VERSION)\n\t\t\tsg_tablesize = MPT2SAS_SG_DEPTH;\n\t\telse\n\t\t\tsg_tablesize = MPT3SAS_SG_DEPTH;\n\t}\n\n\t \n\tif (reset_devices)\n\t\tsg_tablesize = min_t(unsigned short, sg_tablesize,\n\t\t   MPT_KDUMP_MIN_PHYS_SEGMENTS);\n\n\tif (ioc->is_mcpu_endpoint)\n\t\tioc->shost->sg_tablesize = MPT_MIN_PHYS_SEGMENTS;\n\telse {\n\t\tif (sg_tablesize < MPT_MIN_PHYS_SEGMENTS)\n\t\t\tsg_tablesize = MPT_MIN_PHYS_SEGMENTS;\n\t\telse if (sg_tablesize > MPT_MAX_PHYS_SEGMENTS) {\n\t\t\tsg_tablesize = min_t(unsigned short, sg_tablesize,\n\t\t\t\t\tSG_MAX_SEGMENTS);\n\t\t\tioc_warn(ioc, \"sg_tablesize(%u) is bigger than kernel defined SG_CHUNK_SIZE(%u)\\n\",\n\t\t\t\t sg_tablesize, MPT_MAX_PHYS_SEGMENTS);\n\t\t}\n\t\tioc->shost->sg_tablesize = sg_tablesize;\n\t}\n\n\tioc->internal_depth = min_t(int, (facts->HighPriorityCredit + (5)),\n\t\t(facts->RequestCredit / 4));\n\tif (ioc->internal_depth < INTERNAL_CMDS_COUNT) {\n\t\tif (facts->RequestCredit <= (INTERNAL_CMDS_COUNT +\n\t\t\t\tINTERNAL_SCSIIO_CMDS_COUNT)) {\n\t\t\tioc_err(ioc, \"IOC doesn't have enough Request Credits, it has just %d number of credits\\n\",\n\t\t\t\tfacts->RequestCredit);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tioc->internal_depth = 10;\n\t}\n\n\tioc->hi_priority_depth = ioc->internal_depth - (5);\n\t \n\tif (max_queue_depth != -1 && max_queue_depth != 0) {\n\t\tmax_request_credit = min_t(u16, max_queue_depth +\n\t\t\tioc->internal_depth, facts->RequestCredit);\n\t\tif (max_request_credit > MAX_HBA_QUEUE_DEPTH)\n\t\t\tmax_request_credit =  MAX_HBA_QUEUE_DEPTH;\n\t} else if (reset_devices)\n\t\tmax_request_credit = min_t(u16, facts->RequestCredit,\n\t\t    (MPT3SAS_KDUMP_SCSI_IO_DEPTH + ioc->internal_depth));\n\telse\n\t\tmax_request_credit = min_t(u16, facts->RequestCredit,\n\t\t    MAX_HBA_QUEUE_DEPTH);\n\n\t \n\tioc->hba_queue_depth = max_request_credit + ioc->hi_priority_depth;\n\n\t \n\tioc->request_sz = facts->IOCRequestFrameSize * 4;\n\n\t \n\tioc->reply_sz = facts->ReplyFrameSize * 4;\n\n\t \n\tif (ioc->hba_mpi_version_belonged != MPI2_VERSION) {\n\t\tif (facts->IOCMaxChainSegmentSize)\n\t\t\tioc->chain_segment_sz =\n\t\t\t\t\tfacts->IOCMaxChainSegmentSize *\n\t\t\t\t\tMAX_CHAIN_ELEMT_SZ;\n\t\telse\n\t\t \n\t\t\tioc->chain_segment_sz = DEFAULT_NUM_FWCHAIN_ELEMTS *\n\t\t\t\t\t\t    MAX_CHAIN_ELEMT_SZ;\n\t} else\n\t\tioc->chain_segment_sz = ioc->request_sz;\n\n\t \n\tsge_size = max_t(u16, ioc->sge_size, ioc->sge_size_ieee);\n\n retry_allocation:\n\ttotal_sz = 0;\n\t \n\tmax_sge_elements = ioc->request_sz - ((sizeof(Mpi2SCSIIORequest_t) -\n\t    sizeof(Mpi2SGEIOUnion_t)) + sge_size);\n\tioc->max_sges_in_main_message = max_sge_elements/sge_size;\n\n\t \n\tmax_sge_elements = ioc->chain_segment_sz - sge_size;\n\tioc->max_sges_in_chain_message = max_sge_elements/sge_size;\n\n\t \n\tchains_needed_per_io = ((ioc->shost->sg_tablesize -\n\t   ioc->max_sges_in_main_message)/ioc->max_sges_in_chain_message)\n\t    + 1;\n\tif (chains_needed_per_io > facts->MaxChainDepth) {\n\t\tchains_needed_per_io = facts->MaxChainDepth;\n\t\tioc->shost->sg_tablesize = min_t(u16,\n\t\tioc->max_sges_in_main_message + (ioc->max_sges_in_chain_message\n\t\t* chains_needed_per_io), ioc->shost->sg_tablesize);\n\t}\n\tioc->chains_needed_per_io = chains_needed_per_io;\n\n\t \n\tioc->reply_free_queue_depth = ioc->hba_queue_depth + 64;\n\n\t \n\tif (ioc->is_mcpu_endpoint)\n\t\tioc->reply_post_queue_depth = ioc->reply_free_queue_depth;\n\telse {\n\t\t \n\t\tioc->reply_post_queue_depth = ioc->hba_queue_depth +\n\t\t\tioc->reply_free_queue_depth +  1;\n\t\t \n\t\tif (ioc->reply_post_queue_depth % 16)\n\t\t\tioc->reply_post_queue_depth += 16 -\n\t\t\t\t(ioc->reply_post_queue_depth % 16);\n\t}\n\n\tif (ioc->reply_post_queue_depth >\n\t    facts->MaxReplyDescriptorPostQueueDepth) {\n\t\tioc->reply_post_queue_depth =\n\t\t\t\tfacts->MaxReplyDescriptorPostQueueDepth -\n\t\t    (facts->MaxReplyDescriptorPostQueueDepth % 16);\n\t\tioc->hba_queue_depth =\n\t\t\t\t((ioc->reply_post_queue_depth - 64) / 2) - 1;\n\t\tioc->reply_free_queue_depth = ioc->hba_queue_depth + 64;\n\t}\n\n\tioc_info(ioc,\n\t    \"scatter gather: sge_in_main_msg(%d), sge_per_chain(%d), \"\n\t    \"sge_per_io(%d), chains_per_io(%d)\\n\",\n\t    ioc->max_sges_in_main_message,\n\t    ioc->max_sges_in_chain_message,\n\t    ioc->shost->sg_tablesize,\n\t    ioc->chains_needed_per_io);\n\n\t \n\treply_post_free_sz = ioc->reply_post_queue_depth *\n\t    sizeof(Mpi2DefaultReplyDescriptor_t);\n\trdpq_sz = reply_post_free_sz * RDPQ_MAX_INDEX_IN_ONE_CHUNK;\n\tif ((_base_is_controller_msix_enabled(ioc) && !ioc->rdpq_array_enable)\n\t    || (ioc->reply_queue_count < RDPQ_MAX_INDEX_IN_ONE_CHUNK))\n\t\trdpq_sz = reply_post_free_sz * ioc->reply_queue_count;\n\tret = base_alloc_rdpq_dma_pool(ioc, rdpq_sz);\n\tif (ret == -EAGAIN) {\n\t\t \n\t\t_base_release_memory_pools(ioc);\n\t\tioc->use_32bit_dma = true;\n\t\tif (_base_config_dma_addressing(ioc, ioc->pdev) != 0) {\n\t\t\tioc_err(ioc,\n\t\t\t    \"32 DMA mask failed %s\\n\", pci_name(ioc->pdev));\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (base_alloc_rdpq_dma_pool(ioc, rdpq_sz))\n\t\t\treturn -ENOMEM;\n\t} else if (ret == -ENOMEM)\n\t\treturn -ENOMEM;\n\ttotal_sz = rdpq_sz * (!ioc->rdpq_array_enable ? 1 :\n\t    DIV_ROUND_UP(ioc->reply_queue_count, RDPQ_MAX_INDEX_IN_ONE_CHUNK));\n\tioc->scsiio_depth = ioc->hba_queue_depth -\n\t    ioc->hi_priority_depth - ioc->internal_depth;\n\n\t \n\tioc->shost->can_queue = ioc->scsiio_depth - INTERNAL_SCSIIO_CMDS_COUNT;\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"scsi host: can_queue depth (%d)\\n\",\n\t\t\t     ioc->shost->can_queue));\n\n\t \n\tioc->chain_depth = ioc->chains_needed_per_io * ioc->scsiio_depth;\n\tsz = ((ioc->scsiio_depth + 1) * ioc->request_sz);\n\n\t \n\tsz += (ioc->hi_priority_depth * ioc->request_sz);\n\n\t \n\tsz += (ioc->internal_depth * ioc->request_sz);\n\n\tioc->request_dma_sz = sz;\n\tioc->request = dma_alloc_coherent(&ioc->pdev->dev, sz,\n\t\t\t&ioc->request_dma, GFP_KERNEL);\n\tif (!ioc->request) {\n\t\tioc_err(ioc, \"request pool: dma_alloc_coherent failed: hba_depth(%d), chains_per_io(%d), frame_sz(%d), total(%d kB)\\n\",\n\t\t\tioc->hba_queue_depth, ioc->chains_needed_per_io,\n\t\t\tioc->request_sz, sz / 1024);\n\t\tif (ioc->scsiio_depth < MPT3SAS_SAS_QUEUE_DEPTH)\n\t\t\tgoto out;\n\t\tretry_sz = 64;\n\t\tioc->hba_queue_depth -= retry_sz;\n\t\t_base_release_memory_pools(ioc);\n\t\tgoto retry_allocation;\n\t}\n\n\tif (retry_sz)\n\t\tioc_err(ioc, \"request pool: dma_alloc_coherent succeed: hba_depth(%d), chains_per_io(%d), frame_sz(%d), total(%d kb)\\n\",\n\t\t\tioc->hba_queue_depth, ioc->chains_needed_per_io,\n\t\t\tioc->request_sz, sz / 1024);\n\n\t \n\tioc->hi_priority = ioc->request + ((ioc->scsiio_depth + 1) *\n\t    ioc->request_sz);\n\tioc->hi_priority_dma = ioc->request_dma + ((ioc->scsiio_depth + 1) *\n\t    ioc->request_sz);\n\n\t \n\tioc->internal = ioc->hi_priority + (ioc->hi_priority_depth *\n\t    ioc->request_sz);\n\tioc->internal_dma = ioc->hi_priority_dma + (ioc->hi_priority_depth *\n\t    ioc->request_sz);\n\n\tioc_info(ioc,\n\t    \"request pool(0x%p) - dma(0x%llx): \"\n\t    \"depth(%d), frame_size(%d), pool_size(%d kB)\\n\",\n\t    ioc->request, (unsigned long long) ioc->request_dma,\n\t    ioc->hba_queue_depth, ioc->request_sz,\n\t    (ioc->hba_queue_depth * ioc->request_sz) / 1024);\n\n\ttotal_sz += sz;\n\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"scsiio(0x%p): depth(%d)\\n\",\n\t\t\t     ioc->request, ioc->scsiio_depth));\n\n\tioc->chain_depth = min_t(u32, ioc->chain_depth, MAX_CHAIN_DEPTH);\n\tsz = ioc->scsiio_depth * sizeof(struct chain_lookup);\n\tioc->chain_lookup = kzalloc(sz, GFP_KERNEL);\n\tif (!ioc->chain_lookup) {\n\t\tioc_err(ioc, \"chain_lookup: __get_free_pages failed\\n\");\n\t\tgoto out;\n\t}\n\n\tsz = ioc->chains_needed_per_io * sizeof(struct chain_tracker);\n\tfor (i = 0; i < ioc->scsiio_depth; i++) {\n\t\tioc->chain_lookup[i].chains_per_smid = kzalloc(sz, GFP_KERNEL);\n\t\tif (!ioc->chain_lookup[i].chains_per_smid) {\n\t\t\tioc_err(ioc, \"chain_lookup: kzalloc failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tioc->hpr_lookup = kcalloc(ioc->hi_priority_depth,\n\t    sizeof(struct request_tracker), GFP_KERNEL);\n\tif (!ioc->hpr_lookup) {\n\t\tioc_err(ioc, \"hpr_lookup: kcalloc failed\\n\");\n\t\tgoto out;\n\t}\n\tioc->hi_priority_smid = ioc->scsiio_depth + 1;\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"hi_priority(0x%p): depth(%d), start smid(%d)\\n\",\n\t\t\t     ioc->hi_priority,\n\t\t\t     ioc->hi_priority_depth, ioc->hi_priority_smid));\n\n\t \n\tioc->internal_lookup = kcalloc(ioc->internal_depth,\n\t    sizeof(struct request_tracker), GFP_KERNEL);\n\tif (!ioc->internal_lookup) {\n\t\tioc_err(ioc, \"internal_lookup: kcalloc failed\\n\");\n\t\tgoto out;\n\t}\n\tioc->internal_smid = ioc->hi_priority_smid + ioc->hi_priority_depth;\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"internal(0x%p): depth(%d), start smid(%d)\\n\",\n\t\t\t     ioc->internal,\n\t\t\t     ioc->internal_depth, ioc->internal_smid));\n\n\tioc->io_queue_num = kcalloc(ioc->scsiio_depth,\n\t    sizeof(u16), GFP_KERNEL);\n\tif (!ioc->io_queue_num)\n\t\tgoto out;\n\t \n\n\tioc->chains_per_prp_buffer = 0;\n\tif (ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_NVME_DEVICES) {\n\t\tnvme_blocks_needed =\n\t\t\t(ioc->shost->sg_tablesize * NVME_PRP_SIZE) - 1;\n\t\tnvme_blocks_needed /= (ioc->page_size - NVME_PRP_SIZE);\n\t\tnvme_blocks_needed++;\n\n\t\tsz = sizeof(struct pcie_sg_list) * ioc->scsiio_depth;\n\t\tioc->pcie_sg_lookup = kzalloc(sz, GFP_KERNEL);\n\t\tif (!ioc->pcie_sg_lookup) {\n\t\t\tioc_info(ioc, \"PCIe SGL lookup: kzalloc failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tsz = nvme_blocks_needed * ioc->page_size;\n\t\trc = _base_allocate_pcie_sgl_pool(ioc, sz);\n\t\tif (rc == -ENOMEM)\n\t\t\treturn -ENOMEM;\n\t\telse if (rc == -EAGAIN)\n\t\t\tgoto try_32bit_dma;\n\t\ttotal_sz += sz * ioc->scsiio_depth;\n\t}\n\n\trc = _base_allocate_chain_dma_pool(ioc, ioc->chain_segment_sz);\n\tif (rc == -ENOMEM)\n\t\treturn -ENOMEM;\n\telse if (rc == -EAGAIN)\n\t\tgoto try_32bit_dma;\n\ttotal_sz += ioc->chain_segment_sz * ((ioc->chains_needed_per_io -\n\t\tioc->chains_per_prp_buffer) * ioc->scsiio_depth);\n\tdinitprintk(ioc,\n\t    ioc_info(ioc, \"chain pool depth(%d), frame_size(%d), pool_size(%d kB)\\n\",\n\t    ioc->chain_depth, ioc->chain_segment_sz,\n\t    (ioc->chain_depth * ioc->chain_segment_sz) / 1024));\n\t \n\tsense_sz = ioc->scsiio_depth * SCSI_SENSE_BUFFERSIZE;\n\trc = _base_allocate_sense_dma_pool(ioc, sense_sz);\n\tif (rc  == -ENOMEM)\n\t\treturn -ENOMEM;\n\telse if (rc == -EAGAIN)\n\t\tgoto try_32bit_dma;\n\ttotal_sz += sense_sz;\n\t \n\tsz = ioc->reply_free_queue_depth * ioc->reply_sz;\n\trc = _base_allocate_reply_pool(ioc, sz);\n\tif (rc == -ENOMEM)\n\t\treturn -ENOMEM;\n\telse if (rc == -EAGAIN)\n\t\tgoto try_32bit_dma;\n\ttotal_sz += sz;\n\n\t \n\tsz = ioc->reply_free_queue_depth * 4;\n\trc = _base_allocate_reply_free_dma_pool(ioc, sz);\n\tif (rc  == -ENOMEM)\n\t\treturn -ENOMEM;\n\telse if (rc == -EAGAIN)\n\t\tgoto try_32bit_dma;\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"reply_free_dma (0x%llx)\\n\",\n\t\t\t     (unsigned long long)ioc->reply_free_dma));\n\ttotal_sz += sz;\n\tif (ioc->rdpq_array_enable) {\n\t\treply_post_free_array_sz = ioc->reply_queue_count *\n\t\t    sizeof(Mpi2IOCInitRDPQArrayEntry);\n\t\trc = _base_allocate_reply_post_free_array(ioc,\n\t\t    reply_post_free_array_sz);\n\t\tif (rc == -ENOMEM)\n\t\t\treturn -ENOMEM;\n\t\telse if (rc == -EAGAIN)\n\t\t\tgoto try_32bit_dma;\n\t}\n\tioc->config_page_sz = 512;\n\tioc->config_page = dma_alloc_coherent(&ioc->pdev->dev,\n\t\t\tioc->config_page_sz, &ioc->config_page_dma, GFP_KERNEL);\n\tif (!ioc->config_page) {\n\t\tioc_err(ioc, \"config page: dma_pool_alloc failed\\n\");\n\t\tgoto out;\n\t}\n\n\tioc_info(ioc, \"config page(0x%p) - dma(0x%llx): size(%d)\\n\",\n\t    ioc->config_page, (unsigned long long)ioc->config_page_dma,\n\t    ioc->config_page_sz);\n\ttotal_sz += ioc->config_page_sz;\n\n\tioc_info(ioc, \"Allocated physical memory: size(%d kB)\\n\",\n\t\t total_sz / 1024);\n\tioc_info(ioc, \"Current Controller Queue Depth(%d),Max Controller Queue Depth(%d)\\n\",\n\t\t ioc->shost->can_queue, facts->RequestCredit);\n\tioc_info(ioc, \"Scatter Gather Elements per IO(%d)\\n\",\n\t\t ioc->shost->sg_tablesize);\n\treturn 0;\n\ntry_32bit_dma:\n\t_base_release_memory_pools(ioc);\n\tif (ioc->use_32bit_dma && (ioc->dma_mask > 32)) {\n\t\t \n\t\tif (_base_config_dma_addressing(ioc, ioc->pdev) != 0) {\n\t\t\tpr_err(\"Setting 32 bit coherent DMA mask Failed %s\\n\",\n\t\t\t    pci_name(ioc->pdev));\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else if (_base_reduce_hba_queue_depth(ioc) != 0)\n\t\treturn -ENOMEM;\n\tgoto retry_allocation;\n\n out:\n\treturn -ENOMEM;\n}\n\n \nu32\nmpt3sas_base_get_iocstate(struct MPT3SAS_ADAPTER *ioc, int cooked)\n{\n\tu32 s, sc;\n\n\ts = ioc->base_readl_ext_retry(&ioc->chip->Doorbell);\n\tsc = s & MPI2_IOC_STATE_MASK;\n\treturn cooked ? sc : s;\n}\n\n \nstatic int\n_base_wait_on_iocstate(struct MPT3SAS_ADAPTER *ioc, u32 ioc_state, int timeout)\n{\n\tu32 count, cntdn;\n\tu32 current_state;\n\n\tcount = 0;\n\tcntdn = 1000 * timeout;\n\tdo {\n\t\tcurrent_state = mpt3sas_base_get_iocstate(ioc, 1);\n\t\tif (current_state == ioc_state)\n\t\t\treturn 0;\n\t\tif (count && current_state == MPI2_IOC_STATE_FAULT)\n\t\t\tbreak;\n\t\tif (count && current_state == MPI2_IOC_STATE_COREDUMP)\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 1500);\n\t\tcount++;\n\t} while (--cntdn);\n\n\treturn current_state;\n}\n\n \nstatic inline void\n_base_dump_reg_set(struct MPT3SAS_ADAPTER *ioc)\n{\n\tunsigned int i, sz = 256;\n\tu32 __iomem *reg = (u32 __iomem *)ioc->chip;\n\n\tioc_info(ioc, \"System Register set:\\n\");\n\tfor (i = 0; i < (sz / sizeof(u32)); i++)\n\t\tpr_info(\"%08x: %08x\\n\", (i * 4), readl(&reg[i]));\n}\n\n \n\nstatic int\n_base_wait_for_doorbell_int(struct MPT3SAS_ADAPTER *ioc, int timeout)\n{\n\tu32 cntdn, count;\n\tu32 int_status;\n\n\tcount = 0;\n\tcntdn = 1000 * timeout;\n\tdo {\n\t\tint_status = ioc->base_readl(&ioc->chip->HostInterruptStatus);\n\t\tif (int_status & MPI2_HIS_IOC2SYS_DB_STATUS) {\n\t\t\tdhsprintk(ioc,\n\t\t\t\t  ioc_info(ioc, \"%s: successful count(%d), timeout(%d)\\n\",\n\t\t\t\t\t   __func__, count, timeout));\n\t\t\treturn 0;\n\t\t}\n\n\t\tusleep_range(1000, 1500);\n\t\tcount++;\n\t} while (--cntdn);\n\n\tioc_err(ioc, \"%s: failed due to timeout count(%d), int_status(%x)!\\n\",\n\t\t__func__, count, int_status);\n\treturn -EFAULT;\n}\n\nstatic int\n_base_spin_on_doorbell_int(struct MPT3SAS_ADAPTER *ioc, int timeout)\n{\n\tu32 cntdn, count;\n\tu32 int_status;\n\n\tcount = 0;\n\tcntdn = 2000 * timeout;\n\tdo {\n\t\tint_status = ioc->base_readl(&ioc->chip->HostInterruptStatus);\n\t\tif (int_status & MPI2_HIS_IOC2SYS_DB_STATUS) {\n\t\t\tdhsprintk(ioc,\n\t\t\t\t  ioc_info(ioc, \"%s: successful count(%d), timeout(%d)\\n\",\n\t\t\t\t\t   __func__, count, timeout));\n\t\t\treturn 0;\n\t\t}\n\n\t\tudelay(500);\n\t\tcount++;\n\t} while (--cntdn);\n\n\tioc_err(ioc, \"%s: failed due to timeout count(%d), int_status(%x)!\\n\",\n\t\t__func__, count, int_status);\n\treturn -EFAULT;\n\n}\n\n \nstatic int\n_base_wait_for_doorbell_ack(struct MPT3SAS_ADAPTER *ioc, int timeout)\n{\n\tu32 cntdn, count;\n\tu32 int_status;\n\tu32 doorbell;\n\n\tcount = 0;\n\tcntdn = 1000 * timeout;\n\tdo {\n\t\tint_status = ioc->base_readl(&ioc->chip->HostInterruptStatus);\n\t\tif (!(int_status & MPI2_HIS_SYS2IOC_DB_STATUS)) {\n\t\t\tdhsprintk(ioc,\n\t\t\t\t  ioc_info(ioc, \"%s: successful count(%d), timeout(%d)\\n\",\n\t\t\t\t\t   __func__, count, timeout));\n\t\t\treturn 0;\n\t\t} else if (int_status & MPI2_HIS_IOC2SYS_DB_STATUS) {\n\t\t\tdoorbell = ioc->base_readl_ext_retry(&ioc->chip->Doorbell);\n\t\t\tif ((doorbell & MPI2_IOC_STATE_MASK) ==\n\t\t\t    MPI2_IOC_STATE_FAULT) {\n\t\t\t\tmpt3sas_print_fault_code(ioc, doorbell);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tif ((doorbell & MPI2_IOC_STATE_MASK) ==\n\t\t\t    MPI2_IOC_STATE_COREDUMP) {\n\t\t\t\tmpt3sas_print_coredump_info(ioc, doorbell);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else if (int_status == 0xFFFFFFFF)\n\t\t\tgoto out;\n\n\t\tusleep_range(1000, 1500);\n\t\tcount++;\n\t} while (--cntdn);\n\n out:\n\tioc_err(ioc, \"%s: failed due to timeout count(%d), int_status(%x)!\\n\",\n\t\t__func__, count, int_status);\n\treturn -EFAULT;\n}\n\n \nstatic int\n_base_wait_for_doorbell_not_used(struct MPT3SAS_ADAPTER *ioc, int timeout)\n{\n\tu32 cntdn, count;\n\tu32 doorbell_reg;\n\n\tcount = 0;\n\tcntdn = 1000 * timeout;\n\tdo {\n\t\tdoorbell_reg = ioc->base_readl_ext_retry(&ioc->chip->Doorbell);\n\t\tif (!(doorbell_reg & MPI2_DOORBELL_USED)) {\n\t\t\tdhsprintk(ioc,\n\t\t\t\t  ioc_info(ioc, \"%s: successful count(%d), timeout(%d)\\n\",\n\t\t\t\t\t   __func__, count, timeout));\n\t\t\treturn 0;\n\t\t}\n\n\t\tusleep_range(1000, 1500);\n\t\tcount++;\n\t} while (--cntdn);\n\n\tioc_err(ioc, \"%s: failed due to timeout count(%d), doorbell_reg(%x)!\\n\",\n\t\t__func__, count, doorbell_reg);\n\treturn -EFAULT;\n}\n\n \nstatic int\n_base_send_ioc_reset(struct MPT3SAS_ADAPTER *ioc, u8 reset_type, int timeout)\n{\n\tu32 ioc_state;\n\tint r = 0;\n\tunsigned long flags;\n\n\tif (reset_type != MPI2_FUNCTION_IOC_MESSAGE_UNIT_RESET) {\n\t\tioc_err(ioc, \"%s: unknown reset_type\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tif (!(ioc->facts.IOCCapabilities &\n\t   MPI2_IOCFACTS_CAPABILITY_EVENT_REPLAY))\n\t\treturn -EFAULT;\n\n\tioc_info(ioc, \"sending message unit reset !!\\n\");\n\n\twritel(reset_type << MPI2_DOORBELL_FUNCTION_SHIFT,\n\t    &ioc->chip->Doorbell);\n\tif ((_base_wait_for_doorbell_ack(ioc, 15))) {\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tioc_state = _base_wait_on_iocstate(ioc, MPI2_IOC_STATE_READY, timeout);\n\tif (ioc_state) {\n\t\tioc_err(ioc, \"%s: failed going to ready state (ioc_state=0x%x)\\n\",\n\t\t\t__func__, ioc_state);\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n out:\n\tif (r != 0) {\n\t\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\t\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\n\t\t \n\t\tif ((ioc_state & MPI2_IOC_STATE_MASK) ==\n\t\t    MPI2_IOC_STATE_COREDUMP && (ioc->is_driver_loading == 1 ||\n\t\t    ioc->fault_reset_work_q == NULL)) {\n\t\t\tspin_unlock_irqrestore(\n\t\t\t    &ioc->ioc_reset_in_progress_lock, flags);\n\t\t\tmpt3sas_print_coredump_info(ioc, ioc_state);\n\t\t\tmpt3sas_base_wait_for_coredump_completion(ioc,\n\t\t\t    __func__);\n\t\t\tspin_lock_irqsave(\n\t\t\t    &ioc->ioc_reset_in_progress_lock, flags);\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\n\t}\n\tioc_info(ioc, \"message unit reset: %s\\n\",\n\t\t r == 0 ? \"SUCCESS\" : \"FAILED\");\n\treturn r;\n}\n\n \n\nint\nmpt3sas_wait_for_ioc(struct MPT3SAS_ADAPTER *ioc, int timeout)\n{\n\tint wait_state_count = 0;\n\tu32 ioc_state;\n\n\tdo {\n\t\tioc_state = mpt3sas_base_get_iocstate(ioc, 1);\n\t\tif (ioc_state == MPI2_IOC_STATE_OPERATIONAL)\n\t\t\tbreak;\n\n\t\t \n\t\tif (ioc->is_driver_loading)\n\t\t\treturn -ETIME;\n\n\t\tssleep(1);\n\t\tioc_info(ioc, \"%s: waiting for operational state(count=%d)\\n\",\n\t\t\t\t__func__, ++wait_state_count);\n\t} while (--timeout);\n\tif (!timeout) {\n\t\tioc_err(ioc, \"%s: failed due to ioc not operational\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\tif (wait_state_count)\n\t\tioc_info(ioc, \"ioc is operational\\n\");\n\treturn 0;\n}\n\n \nstatic int\n_base_handshake_req_reply_wait(struct MPT3SAS_ADAPTER *ioc, int request_bytes,\n\tu32 *request, int reply_bytes, u16 *reply, int timeout)\n{\n\tMPI2DefaultReply_t *default_reply = (MPI2DefaultReply_t *)reply;\n\tint i;\n\tu8 failed;\n\t__le32 *mfp;\n\n\t \n\tif ((ioc->base_readl_ext_retry(&ioc->chip->Doorbell) & MPI2_DOORBELL_USED)) {\n\t\tioc_err(ioc, \"doorbell is in use (line=%d)\\n\", __LINE__);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (ioc->base_readl(&ioc->chip->HostInterruptStatus) &\n\t    MPI2_HIS_IOC2SYS_DB_STATUS)\n\t\twritel(0, &ioc->chip->HostInterruptStatus);\n\n\t \n\twritel(((MPI2_FUNCTION_HANDSHAKE<<MPI2_DOORBELL_FUNCTION_SHIFT) |\n\t    ((request_bytes/4)<<MPI2_DOORBELL_ADD_DWORDS_SHIFT)),\n\t    &ioc->chip->Doorbell);\n\n\tif ((_base_spin_on_doorbell_int(ioc, 5))) {\n\t\tioc_err(ioc, \"doorbell handshake int failed (line=%d)\\n\",\n\t\t\t__LINE__);\n\t\treturn -EFAULT;\n\t}\n\twritel(0, &ioc->chip->HostInterruptStatus);\n\n\tif ((_base_wait_for_doorbell_ack(ioc, 5))) {\n\t\tioc_err(ioc, \"doorbell handshake ack failed (line=%d)\\n\",\n\t\t\t__LINE__);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tfor (i = 0, failed = 0; i < request_bytes/4 && !failed; i++) {\n\t\twritel(cpu_to_le32(request[i]), &ioc->chip->Doorbell);\n\t\tif ((_base_wait_for_doorbell_ack(ioc, 5)))\n\t\t\tfailed = 1;\n\t}\n\n\tif (failed) {\n\t\tioc_err(ioc, \"doorbell handshake sending request failed (line=%d)\\n\",\n\t\t\t__LINE__);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tif ((_base_wait_for_doorbell_int(ioc, timeout))) {\n\t\tioc_err(ioc, \"doorbell handshake int failed (line=%d)\\n\",\n\t\t\t__LINE__);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\treply[0] = le16_to_cpu(ioc->base_readl_ext_retry(&ioc->chip->Doorbell)\n\t    & MPI2_DOORBELL_DATA_MASK);\n\twritel(0, &ioc->chip->HostInterruptStatus);\n\tif ((_base_wait_for_doorbell_int(ioc, 5))) {\n\t\tioc_err(ioc, \"doorbell handshake int failed (line=%d)\\n\",\n\t\t\t__LINE__);\n\t\treturn -EFAULT;\n\t}\n\treply[1] = le16_to_cpu(ioc->base_readl_ext_retry(&ioc->chip->Doorbell)\n\t    & MPI2_DOORBELL_DATA_MASK);\n\twritel(0, &ioc->chip->HostInterruptStatus);\n\n\tfor (i = 2; i < default_reply->MsgLength * 2; i++)  {\n\t\tif ((_base_wait_for_doorbell_int(ioc, 5))) {\n\t\t\tioc_err(ioc, \"doorbell handshake int failed (line=%d)\\n\",\n\t\t\t\t__LINE__);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (i >=  reply_bytes/2)  \n\t\t\tioc->base_readl_ext_retry(&ioc->chip->Doorbell);\n\t\telse\n\t\t\treply[i] = le16_to_cpu(\n\t\t\t    ioc->base_readl_ext_retry(&ioc->chip->Doorbell)\n\t\t\t    & MPI2_DOORBELL_DATA_MASK);\n\t\twritel(0, &ioc->chip->HostInterruptStatus);\n\t}\n\n\t_base_wait_for_doorbell_int(ioc, 5);\n\tif (_base_wait_for_doorbell_not_used(ioc, 5) != 0) {\n\t\tdhsprintk(ioc,\n\t\t\t  ioc_info(ioc, \"doorbell is in use (line=%d)\\n\",\n\t\t\t\t   __LINE__));\n\t}\n\twritel(0, &ioc->chip->HostInterruptStatus);\n\n\tif (ioc->logging_level & MPT_DEBUG_INIT) {\n\t\tmfp = (__le32 *)reply;\n\t\tpr_info(\"\\toffset:data\\n\");\n\t\tfor (i = 0; i < reply_bytes/4; i++)\n\t\t\tioc_info(ioc, \"\\t[0x%02x]:%08x\\n\", i*4,\n\t\t\t    le32_to_cpu(mfp[i]));\n\t}\n\treturn 0;\n}\n\n \nint\nmpt3sas_base_sas_iounit_control(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2SasIoUnitControlReply_t *mpi_reply,\n\tMpi2SasIoUnitControlRequest_t *mpi_request)\n{\n\tu16 smid;\n\tu8 issue_reset = 0;\n\tint rc;\n\tvoid *request;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tmutex_lock(&ioc->base_cmds.mutex);\n\n\tif (ioc->base_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: base_cmd in use\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trc = mpt3sas_wait_for_ioc(ioc, IOC_OPERATIONAL_WAIT_COUNT);\n\tif (rc)\n\t\tgoto out;\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\tioc->base_cmds.status = MPT3_CMD_PENDING;\n\trequest = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->base_cmds.smid = smid;\n\tmemcpy(request, mpi_request, sizeof(Mpi2SasIoUnitControlRequest_t));\n\tif (mpi_request->Operation == MPI2_SAS_OP_PHY_HARD_RESET ||\n\t    mpi_request->Operation == MPI2_SAS_OP_PHY_LINK_RESET)\n\t\tioc->ioc_link_reset_in_progress = 1;\n\tinit_completion(&ioc->base_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->base_cmds.done,\n\t    msecs_to_jiffies(10000));\n\tif ((mpi_request->Operation == MPI2_SAS_OP_PHY_HARD_RESET ||\n\t    mpi_request->Operation == MPI2_SAS_OP_PHY_LINK_RESET) &&\n\t    ioc->ioc_link_reset_in_progress)\n\t\tioc->ioc_link_reset_in_progress = 0;\n\tif (!(ioc->base_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tmpt3sas_check_cmd_timeout(ioc, ioc->base_cmds.status,\n\t\t    mpi_request, sizeof(Mpi2SasIoUnitControlRequest_t)/4,\n\t\t    issue_reset);\n\t\tgoto issue_host_reset;\n\t}\n\tif (ioc->base_cmds.status & MPT3_CMD_REPLY_VALID)\n\t\tmemcpy(mpi_reply, ioc->base_cmds.reply,\n\t\t    sizeof(Mpi2SasIoUnitControlReply_t));\n\telse\n\t\tmemset(mpi_reply, 0, sizeof(Mpi2SasIoUnitControlReply_t));\n\tioc->base_cmds.status = MPT3_CMD_NOT_USED;\n\tgoto out;\n\n issue_host_reset:\n\tif (issue_reset)\n\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\tioc->base_cmds.status = MPT3_CMD_NOT_USED;\n\trc = -EFAULT;\n out:\n\tmutex_unlock(&ioc->base_cmds.mutex);\n\treturn rc;\n}\n\n \nint\nmpt3sas_base_scsi_enclosure_processor(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2SepReply_t *mpi_reply, Mpi2SepRequest_t *mpi_request)\n{\n\tu16 smid;\n\tu8 issue_reset = 0;\n\tint rc;\n\tvoid *request;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tmutex_lock(&ioc->base_cmds.mutex);\n\n\tif (ioc->base_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: base_cmd in use\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trc = mpt3sas_wait_for_ioc(ioc, IOC_OPERATIONAL_WAIT_COUNT);\n\tif (rc)\n\t\tgoto out;\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\tioc->base_cmds.status = MPT3_CMD_PENDING;\n\trequest = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->base_cmds.smid = smid;\n\tmemset(request, 0, ioc->request_sz);\n\tmemcpy(request, mpi_request, sizeof(Mpi2SepReply_t));\n\tinit_completion(&ioc->base_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->base_cmds.done,\n\t    msecs_to_jiffies(10000));\n\tif (!(ioc->base_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tmpt3sas_check_cmd_timeout(ioc,\n\t\t    ioc->base_cmds.status, mpi_request,\n\t\t    sizeof(Mpi2SepRequest_t)/4, issue_reset);\n\t\tgoto issue_host_reset;\n\t}\n\tif (ioc->base_cmds.status & MPT3_CMD_REPLY_VALID)\n\t\tmemcpy(mpi_reply, ioc->base_cmds.reply,\n\t\t    sizeof(Mpi2SepReply_t));\n\telse\n\t\tmemset(mpi_reply, 0, sizeof(Mpi2SepReply_t));\n\tioc->base_cmds.status = MPT3_CMD_NOT_USED;\n\tgoto out;\n\n issue_host_reset:\n\tif (issue_reset)\n\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\tioc->base_cmds.status = MPT3_CMD_NOT_USED;\n\trc = -EFAULT;\n out:\n\tmutex_unlock(&ioc->base_cmds.mutex);\n\treturn rc;\n}\n\n \nstatic int\n_base_get_port_facts(struct MPT3SAS_ADAPTER *ioc, int port)\n{\n\tMpi2PortFactsRequest_t mpi_request;\n\tMpi2PortFactsReply_t mpi_reply;\n\tstruct mpt3sas_port_facts *pfacts;\n\tint mpi_reply_sz, mpi_request_sz, r;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tmpi_reply_sz = sizeof(Mpi2PortFactsReply_t);\n\tmpi_request_sz = sizeof(Mpi2PortFactsRequest_t);\n\tmemset(&mpi_request, 0, mpi_request_sz);\n\tmpi_request.Function = MPI2_FUNCTION_PORT_FACTS;\n\tmpi_request.PortNumber = port;\n\tr = _base_handshake_req_reply_wait(ioc, mpi_request_sz,\n\t    (u32 *)&mpi_request, mpi_reply_sz, (u16 *)&mpi_reply, 5);\n\n\tif (r != 0) {\n\t\tioc_err(ioc, \"%s: handshake failed (r=%d)\\n\", __func__, r);\n\t\treturn r;\n\t}\n\n\tpfacts = &ioc->pfacts[port];\n\tmemset(pfacts, 0, sizeof(struct mpt3sas_port_facts));\n\tpfacts->PortNumber = mpi_reply.PortNumber;\n\tpfacts->VP_ID = mpi_reply.VP_ID;\n\tpfacts->VF_ID = mpi_reply.VF_ID;\n\tpfacts->MaxPostedCmdBuffers =\n\t    le16_to_cpu(mpi_reply.MaxPostedCmdBuffers);\n\n\treturn 0;\n}\n\n \nstatic int\n_base_wait_for_iocstate(struct MPT3SAS_ADAPTER *ioc, int timeout)\n{\n\tu32 ioc_state;\n\tint rc;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tif (ioc->pci_error_recovery) {\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_info(ioc, \"%s: host in pci error recovery\\n\",\n\t\t\t\t     __func__));\n\t\treturn -EFAULT;\n\t}\n\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\tdhsprintk(ioc,\n\t\t  ioc_info(ioc, \"%s: ioc_state(0x%08x)\\n\",\n\t\t\t   __func__, ioc_state));\n\n\tif (((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_READY) ||\n\t    (ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_OPERATIONAL)\n\t\treturn 0;\n\n\tif (ioc_state & MPI2_DOORBELL_USED) {\n\t\tdhsprintk(ioc, ioc_info(ioc, \"unexpected doorbell active!\\n\"));\n\t\tgoto issue_diag_reset;\n\t}\n\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {\n\t\tmpt3sas_print_fault_code(ioc, ioc_state &\n\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\tgoto issue_diag_reset;\n\t} else if ((ioc_state & MPI2_IOC_STATE_MASK) ==\n\t    MPI2_IOC_STATE_COREDUMP) {\n\t\tioc_info(ioc,\n\t\t    \"%s: Skipping the diag reset here. (ioc_state=0x%x)\\n\",\n\t\t    __func__, ioc_state);\n\t\treturn -EFAULT;\n\t}\n\n\tioc_state = _base_wait_on_iocstate(ioc, MPI2_IOC_STATE_READY, timeout);\n\tif (ioc_state) {\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_info(ioc, \"%s: failed going to ready state (ioc_state=0x%x)\\n\",\n\t\t\t\t     __func__, ioc_state));\n\t\treturn -EFAULT;\n\t}\n\n issue_diag_reset:\n\trc = _base_diag_reset(ioc);\n\treturn rc;\n}\n\n \nstatic int\n_base_get_ioc_facts(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2IOCFactsRequest_t mpi_request;\n\tMpi2IOCFactsReply_t mpi_reply;\n\tstruct mpt3sas_facts *facts;\n\tint mpi_reply_sz, mpi_request_sz, r;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tr = _base_wait_for_iocstate(ioc, 10);\n\tif (r) {\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_info(ioc, \"%s: failed getting to correct state\\n\",\n\t\t\t\t     __func__));\n\t\treturn r;\n\t}\n\tmpi_reply_sz = sizeof(Mpi2IOCFactsReply_t);\n\tmpi_request_sz = sizeof(Mpi2IOCFactsRequest_t);\n\tmemset(&mpi_request, 0, mpi_request_sz);\n\tmpi_request.Function = MPI2_FUNCTION_IOC_FACTS;\n\tr = _base_handshake_req_reply_wait(ioc, mpi_request_sz,\n\t    (u32 *)&mpi_request, mpi_reply_sz, (u16 *)&mpi_reply, 5);\n\n\tif (r != 0) {\n\t\tioc_err(ioc, \"%s: handshake failed (r=%d)\\n\", __func__, r);\n\t\treturn r;\n\t}\n\n\tfacts = &ioc->facts;\n\tmemset(facts, 0, sizeof(struct mpt3sas_facts));\n\tfacts->MsgVersion = le16_to_cpu(mpi_reply.MsgVersion);\n\tfacts->HeaderVersion = le16_to_cpu(mpi_reply.HeaderVersion);\n\tfacts->VP_ID = mpi_reply.VP_ID;\n\tfacts->VF_ID = mpi_reply.VF_ID;\n\tfacts->IOCExceptions = le16_to_cpu(mpi_reply.IOCExceptions);\n\tfacts->MaxChainDepth = mpi_reply.MaxChainDepth;\n\tfacts->WhoInit = mpi_reply.WhoInit;\n\tfacts->NumberOfPorts = mpi_reply.NumberOfPorts;\n\tfacts->MaxMSIxVectors = mpi_reply.MaxMSIxVectors;\n\tif (ioc->msix_enable && (facts->MaxMSIxVectors <=\n\t    MAX_COMBINED_MSIX_VECTORS(ioc->is_gen35_ioc)))\n\t\tioc->combined_reply_queue = 0;\n\tfacts->RequestCredit = le16_to_cpu(mpi_reply.RequestCredit);\n\tfacts->MaxReplyDescriptorPostQueueDepth =\n\t    le16_to_cpu(mpi_reply.MaxReplyDescriptorPostQueueDepth);\n\tfacts->ProductID = le16_to_cpu(mpi_reply.ProductID);\n\tfacts->IOCCapabilities = le32_to_cpu(mpi_reply.IOCCapabilities);\n\tif ((facts->IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_INTEGRATED_RAID))\n\t\tioc->ir_firmware = 1;\n\tif ((facts->IOCCapabilities &\n\t      MPI2_IOCFACTS_CAPABILITY_RDPQ_ARRAY_CAPABLE) && (!reset_devices))\n\t\tioc->rdpq_array_capable = 1;\n\tif ((facts->IOCCapabilities & MPI26_IOCFACTS_CAPABILITY_ATOMIC_REQ)\n\t    && ioc->is_aero_ioc)\n\t\tioc->atomic_desc_capable = 1;\n\tfacts->FWVersion.Word = le32_to_cpu(mpi_reply.FWVersion.Word);\n\tfacts->IOCRequestFrameSize =\n\t    le16_to_cpu(mpi_reply.IOCRequestFrameSize);\n\tif (ioc->hba_mpi_version_belonged != MPI2_VERSION) {\n\t\tfacts->IOCMaxChainSegmentSize =\n\t\t\tle16_to_cpu(mpi_reply.IOCMaxChainSegmentSize);\n\t}\n\tfacts->MaxInitiators = le16_to_cpu(mpi_reply.MaxInitiators);\n\tfacts->MaxTargets = le16_to_cpu(mpi_reply.MaxTargets);\n\tioc->shost->max_id = -1;\n\tfacts->MaxSasExpanders = le16_to_cpu(mpi_reply.MaxSasExpanders);\n\tfacts->MaxEnclosures = le16_to_cpu(mpi_reply.MaxEnclosures);\n\tfacts->ProtocolFlags = le16_to_cpu(mpi_reply.ProtocolFlags);\n\tfacts->HighPriorityCredit =\n\t    le16_to_cpu(mpi_reply.HighPriorityCredit);\n\tfacts->ReplyFrameSize = mpi_reply.ReplyFrameSize;\n\tfacts->MaxDevHandle = le16_to_cpu(mpi_reply.MaxDevHandle);\n\tfacts->CurrentHostPageSize = mpi_reply.CurrentHostPageSize;\n\n\t \n\tioc->page_size = 1 << facts->CurrentHostPageSize;\n\tif (ioc->page_size == 1) {\n\t\tioc_info(ioc, \"CurrentHostPageSize is 0: Setting default host page size to 4k\\n\");\n\t\tioc->page_size = 1 << MPT3SAS_HOST_PAGE_SIZE_4K;\n\t}\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"CurrentHostPageSize(%d)\\n\",\n\t\t\t     facts->CurrentHostPageSize));\n\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"hba queue depth(%d), max chains per io(%d)\\n\",\n\t\t\t     facts->RequestCredit, facts->MaxChainDepth));\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"request frame size(%d), reply frame size(%d)\\n\",\n\t\t\t     facts->IOCRequestFrameSize * 4,\n\t\t\t     facts->ReplyFrameSize * 4));\n\treturn 0;\n}\n\n \nstatic int\n_base_send_ioc_init(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2IOCInitRequest_t mpi_request;\n\tMpi2IOCInitReply_t mpi_reply;\n\tint i, r = 0;\n\tktime_t current_time;\n\tu16 ioc_status;\n\tu32 reply_post_free_array_sz = 0;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tmemset(&mpi_request, 0, sizeof(Mpi2IOCInitRequest_t));\n\tmpi_request.Function = MPI2_FUNCTION_IOC_INIT;\n\tmpi_request.WhoInit = MPI2_WHOINIT_HOST_DRIVER;\n\tmpi_request.VF_ID = 0;  \n\tmpi_request.VP_ID = 0;\n\tmpi_request.MsgVersion = cpu_to_le16(ioc->hba_mpi_version_belonged);\n\tmpi_request.HeaderVersion = cpu_to_le16(MPI2_HEADER_VERSION);\n\tmpi_request.HostPageSize = MPT3SAS_HOST_PAGE_SIZE_4K;\n\n\tif (_base_is_controller_msix_enabled(ioc))\n\t\tmpi_request.HostMSIxVectors = ioc->reply_queue_count;\n\tmpi_request.SystemRequestFrameSize = cpu_to_le16(ioc->request_sz/4);\n\tmpi_request.ReplyDescriptorPostQueueDepth =\n\t    cpu_to_le16(ioc->reply_post_queue_depth);\n\tmpi_request.ReplyFreeQueueDepth =\n\t    cpu_to_le16(ioc->reply_free_queue_depth);\n\n\tmpi_request.SenseBufferAddressHigh =\n\t    cpu_to_le32((u64)ioc->sense_dma >> 32);\n\tmpi_request.SystemReplyAddressHigh =\n\t    cpu_to_le32((u64)ioc->reply_dma >> 32);\n\tmpi_request.SystemRequestFrameBaseAddress =\n\t    cpu_to_le64((u64)ioc->request_dma);\n\tmpi_request.ReplyFreeQueueAddress =\n\t    cpu_to_le64((u64)ioc->reply_free_dma);\n\n\tif (ioc->rdpq_array_enable) {\n\t\treply_post_free_array_sz = ioc->reply_queue_count *\n\t\t    sizeof(Mpi2IOCInitRDPQArrayEntry);\n\t\tmemset(ioc->reply_post_free_array, 0, reply_post_free_array_sz);\n\t\tfor (i = 0; i < ioc->reply_queue_count; i++)\n\t\t\tioc->reply_post_free_array[i].RDPQBaseAddress =\n\t\t\t    cpu_to_le64(\n\t\t\t\t(u64)ioc->reply_post[i].reply_post_free_dma);\n\t\tmpi_request.MsgFlags = MPI2_IOCINIT_MSGFLAG_RDPQ_ARRAY_MODE;\n\t\tmpi_request.ReplyDescriptorPostQueueAddress =\n\t\t    cpu_to_le64((u64)ioc->reply_post_free_array_dma);\n\t} else {\n\t\tmpi_request.ReplyDescriptorPostQueueAddress =\n\t\t    cpu_to_le64((u64)ioc->reply_post[0].reply_post_free_dma);\n\t}\n\n\t \n\tmpi_request.ConfigurationFlags |=\n\t    cpu_to_le16(MPI26_IOCINIT_CFGFLAGS_COREDUMP_ENABLE);\n\n\t \n\tcurrent_time = ktime_get_real();\n\tmpi_request.TimeStamp = cpu_to_le64(ktime_to_ms(current_time));\n\n\tif (ioc->logging_level & MPT_DEBUG_INIT) {\n\t\t__le32 *mfp;\n\t\tint i;\n\n\t\tmfp = (__le32 *)&mpi_request;\n\t\tioc_info(ioc, \"\\toffset:data\\n\");\n\t\tfor (i = 0; i < sizeof(Mpi2IOCInitRequest_t)/4; i++)\n\t\t\tioc_info(ioc, \"\\t[0x%02x]:%08x\\n\", i*4,\n\t\t\t    le32_to_cpu(mfp[i]));\n\t}\n\n\tr = _base_handshake_req_reply_wait(ioc,\n\t    sizeof(Mpi2IOCInitRequest_t), (u32 *)&mpi_request,\n\t    sizeof(Mpi2IOCInitReply_t), (u16 *)&mpi_reply, 30);\n\n\tif (r != 0) {\n\t\tioc_err(ioc, \"%s: handshake failed (r=%d)\\n\", __func__, r);\n\t\treturn r;\n\t}\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS ||\n\t    mpi_reply.IOCLogInfo) {\n\t\tioc_err(ioc, \"%s: failed\\n\", __func__);\n\t\tr = -EIO;\n\t}\n\n\t \n\tioc->timestamp_update_count = 0;\n\treturn r;\n}\n\n \nu8\nmpt3sas_port_enable_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\n\tu32 reply)\n{\n\tMPI2DefaultReply_t *mpi_reply;\n\tu16 ioc_status;\n\n\tif (ioc->port_enable_cmds.status == MPT3_CMD_NOT_USED)\n\t\treturn 1;\n\n\tmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tif (!mpi_reply)\n\t\treturn 1;\n\n\tif (mpi_reply->Function != MPI2_FUNCTION_PORT_ENABLE)\n\t\treturn 1;\n\n\tioc->port_enable_cmds.status &= ~MPT3_CMD_PENDING;\n\tioc->port_enable_cmds.status |= MPT3_CMD_COMPLETE;\n\tioc->port_enable_cmds.status |= MPT3_CMD_REPLY_VALID;\n\tmemcpy(ioc->port_enable_cmds.reply, mpi_reply, mpi_reply->MsgLength*4);\n\tioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\tioc->port_enable_failed = 1;\n\n\tif (ioc->port_enable_cmds.status & MPT3_CMD_COMPLETE_ASYNC) {\n\t\tioc->port_enable_cmds.status &= ~MPT3_CMD_COMPLETE_ASYNC;\n\t\tif (ioc_status == MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tmpt3sas_port_enable_complete(ioc);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tioc->start_scan_failed = ioc_status;\n\t\t\tioc->start_scan = 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tcomplete(&ioc->port_enable_cmds.done);\n\treturn 1;\n}\n\n \nstatic int\n_base_send_port_enable(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2PortEnableRequest_t *mpi_request;\n\tMpi2PortEnableReply_t *mpi_reply;\n\tint r = 0;\n\tu16 smid;\n\tu16 ioc_status;\n\n\tioc_info(ioc, \"sending port enable !!\\n\");\n\n\tif (ioc->port_enable_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc_err(ioc, \"%s: internal command already in use\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->port_enable_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tioc->port_enable_cmds.status = MPT3_CMD_PENDING;\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->port_enable_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi2PortEnableRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_PORT_ENABLE;\n\n\tinit_completion(&ioc->port_enable_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->port_enable_cmds.done, 300*HZ);\n\tif (!(ioc->port_enable_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tioc_err(ioc, \"%s: timeout\\n\", __func__);\n\t\t_debug_dump_mf(mpi_request,\n\t\t    sizeof(Mpi2PortEnableRequest_t)/4);\n\t\tif (ioc->port_enable_cmds.status & MPT3_CMD_RESET)\n\t\t\tr = -EFAULT;\n\t\telse\n\t\t\tr = -ETIME;\n\t\tgoto out;\n\t}\n\n\tmpi_reply = ioc->port_enable_cmds.reply;\n\tioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"%s: failed with (ioc_status=0x%08x)\\n\",\n\t\t\t__func__, ioc_status);\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\n out:\n\tioc->port_enable_cmds.status = MPT3_CMD_NOT_USED;\n\tioc_info(ioc, \"port enable: %s\\n\", r == 0 ? \"SUCCESS\" : \"FAILED\");\n\treturn r;\n}\n\n \nint\nmpt3sas_port_enable(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2PortEnableRequest_t *mpi_request;\n\tu16 smid;\n\n\tioc_info(ioc, \"sending port enable !!\\n\");\n\n\tif (ioc->port_enable_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc_err(ioc, \"%s: internal command already in use\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->port_enable_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\tioc->drv_internal_flags |= MPT_DRV_INTERNAL_FIRST_PE_ISSUED;\n\tioc->port_enable_cmds.status = MPT3_CMD_PENDING;\n\tioc->port_enable_cmds.status |= MPT3_CMD_COMPLETE_ASYNC;\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->port_enable_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi2PortEnableRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_PORT_ENABLE;\n\n\tioc->put_smid_default(ioc, smid);\n\treturn 0;\n}\n\n \nstatic int\n_base_determine_wait_on_discovery(struct MPT3SAS_ADAPTER *ioc)\n{\n\t \n\tif (ioc->ir_firmware)\n\t\treturn 1;\n\n\t \n\tif (!ioc->bios_pg3.BiosVersion)\n\t\treturn 0;\n\n\t \n\n\t \n\tif ((ioc->bios_pg2.CurrentBootDeviceForm &\n\t    MPI2_BIOSPAGE2_FORM_MASK) ==\n\t    MPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED &&\n\t \n\t   (ioc->bios_pg2.ReqBootDeviceForm &\n\t    MPI2_BIOSPAGE2_FORM_MASK) ==\n\t    MPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED &&\n\t \n\t   (ioc->bios_pg2.ReqAltBootDeviceForm &\n\t    MPI2_BIOSPAGE2_FORM_MASK) ==\n\t    MPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic void\n_base_unmask_events(struct MPT3SAS_ADAPTER *ioc, u16 event)\n{\n\tu32 desired_event;\n\n\tif (event >= 128)\n\t\treturn;\n\n\tdesired_event = (1 << (event % 32));\n\n\tif (event < 32)\n\t\tioc->event_masks[0] &= ~desired_event;\n\telse if (event < 64)\n\t\tioc->event_masks[1] &= ~desired_event;\n\telse if (event < 96)\n\t\tioc->event_masks[2] &= ~desired_event;\n\telse if (event < 128)\n\t\tioc->event_masks[3] &= ~desired_event;\n}\n\n \nstatic int\n_base_event_notification(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2EventNotificationRequest_t *mpi_request;\n\tu16 smid;\n\tint r = 0;\n\tint i, issue_diag_reset = 0;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tif (ioc->base_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc_err(ioc, \"%s: internal command already in use\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\tioc->base_cmds.status = MPT3_CMD_PENDING;\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->base_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi2EventNotificationRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_EVENT_NOTIFICATION;\n\tmpi_request->VF_ID = 0;  \n\tmpi_request->VP_ID = 0;\n\tfor (i = 0; i < MPI2_EVENT_NOTIFY_EVENTMASK_WORDS; i++)\n\t\tmpi_request->EventMasks[i] =\n\t\t    cpu_to_le32(ioc->event_masks[i]);\n\tinit_completion(&ioc->base_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->base_cmds.done, 30*HZ);\n\tif (!(ioc->base_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tioc_err(ioc, \"%s: timeout\\n\", __func__);\n\t\t_debug_dump_mf(mpi_request,\n\t\t    sizeof(Mpi2EventNotificationRequest_t)/4);\n\t\tif (ioc->base_cmds.status & MPT3_CMD_RESET)\n\t\t\tr = -EFAULT;\n\t\telse\n\t\t\tissue_diag_reset = 1;\n\n\t} else\n\t\tdinitprintk(ioc, ioc_info(ioc, \"%s: complete\\n\", __func__));\n\tioc->base_cmds.status = MPT3_CMD_NOT_USED;\n\n\tif (issue_diag_reset) {\n\t\tif (ioc->drv_internal_flags & MPT_DRV_INTERNAL_FIRST_PE_ISSUED)\n\t\t\treturn -EFAULT;\n\t\tif (mpt3sas_base_check_for_fault_and_issue_reset(ioc))\n\t\t\treturn -EFAULT;\n\t\tr = -EAGAIN;\n\t}\n\treturn r;\n}\n\n \nvoid\nmpt3sas_base_validate_event_type(struct MPT3SAS_ADAPTER *ioc, u32 *event_type)\n{\n\tint i, j;\n\tu32 event_mask, desired_event;\n\tu8 send_update_to_fw;\n\n\tfor (i = 0, send_update_to_fw = 0; i <\n\t    MPI2_EVENT_NOTIFY_EVENTMASK_WORDS; i++) {\n\t\tevent_mask = ~event_type[i];\n\t\tdesired_event = 1;\n\t\tfor (j = 0; j < 32; j++) {\n\t\t\tif (!(event_mask & desired_event) &&\n\t\t\t    (ioc->event_masks[i] & desired_event)) {\n\t\t\t\tioc->event_masks[i] &= ~desired_event;\n\t\t\t\tsend_update_to_fw = 1;\n\t\t\t}\n\t\t\tdesired_event = (desired_event << 1);\n\t\t}\n\t}\n\n\tif (!send_update_to_fw)\n\t\treturn;\n\n\tmutex_lock(&ioc->base_cmds.mutex);\n\t_base_event_notification(ioc);\n\tmutex_unlock(&ioc->base_cmds.mutex);\n}\n\n \nstatic int\n_base_diag_reset(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 host_diagnostic;\n\tu32 ioc_state;\n\tu32 count;\n\tu32 hcb_size;\n\n\tioc_info(ioc, \"sending diag reset !!\\n\");\n\n\tpci_cfg_access_lock(ioc->pdev);\n\n\tdrsprintk(ioc, ioc_info(ioc, \"clear interrupts\\n\"));\n\n\tcount = 0;\n\tdo {\n\t\t \n\t\tdrsprintk(ioc, ioc_info(ioc, \"write magic sequence\\n\"));\n\t\twritel(MPI2_WRSEQ_FLUSH_KEY_VALUE, &ioc->chip->WriteSequence);\n\t\twritel(MPI2_WRSEQ_1ST_KEY_VALUE, &ioc->chip->WriteSequence);\n\t\twritel(MPI2_WRSEQ_2ND_KEY_VALUE, &ioc->chip->WriteSequence);\n\t\twritel(MPI2_WRSEQ_3RD_KEY_VALUE, &ioc->chip->WriteSequence);\n\t\twritel(MPI2_WRSEQ_4TH_KEY_VALUE, &ioc->chip->WriteSequence);\n\t\twritel(MPI2_WRSEQ_5TH_KEY_VALUE, &ioc->chip->WriteSequence);\n\t\twritel(MPI2_WRSEQ_6TH_KEY_VALUE, &ioc->chip->WriteSequence);\n\n\t\t \n\t\tmsleep(100);\n\n\t\tif (count++ > 20) {\n\t\t\tioc_info(ioc,\n\t\t\t    \"Stop writing magic sequence after 20 retries\\n\");\n\t\t\t_base_dump_reg_set(ioc);\n\t\t\tgoto out;\n\t\t}\n\n\t\thost_diagnostic = ioc->base_readl_ext_retry(&ioc->chip->HostDiagnostic);\n\t\tdrsprintk(ioc,\n\t\t\t  ioc_info(ioc, \"wrote magic sequence: count(%d), host_diagnostic(0x%08x)\\n\",\n\t\t\t\t   count, host_diagnostic));\n\n\t} while ((host_diagnostic & MPI2_DIAG_DIAG_WRITE_ENABLE) == 0);\n\n\thcb_size = ioc->base_readl(&ioc->chip->HCBSize);\n\n\tdrsprintk(ioc, ioc_info(ioc, \"diag reset: issued\\n\"));\n\twritel(host_diagnostic | MPI2_DIAG_RESET_ADAPTER,\n\t     &ioc->chip->HostDiagnostic);\n\n\t \n\tmsleep(MPI2_HARD_RESET_PCIE_FIRST_READ_DELAY_MICRO_SEC/1000);\n\n\t \n\tfor (count = 0; count < (300000000 /\n\t\tMPI2_HARD_RESET_PCIE_SECOND_READ_DELAY_MICRO_SEC); count++) {\n\n\t\thost_diagnostic = ioc->base_readl_ext_retry(&ioc->chip->HostDiagnostic);\n\n\t\tif (host_diagnostic == 0xFFFFFFFF) {\n\t\t\tioc_info(ioc,\n\t\t\t    \"Invalid host diagnostic register value\\n\");\n\t\t\t_base_dump_reg_set(ioc);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!(host_diagnostic & MPI2_DIAG_RESET_ADAPTER))\n\t\t\tbreak;\n\n\t\tmsleep(MPI2_HARD_RESET_PCIE_SECOND_READ_DELAY_MICRO_SEC / 1000);\n\t}\n\n\tif (host_diagnostic & MPI2_DIAG_HCB_MODE) {\n\n\t\tdrsprintk(ioc,\n\t\t\t  ioc_info(ioc, \"restart the adapter assuming the HCB Address points to good F/W\\n\"));\n\t\thost_diagnostic &= ~MPI2_DIAG_BOOT_DEVICE_SELECT_MASK;\n\t\thost_diagnostic |= MPI2_DIAG_BOOT_DEVICE_SELECT_HCDW;\n\t\twritel(host_diagnostic, &ioc->chip->HostDiagnostic);\n\n\t\tdrsprintk(ioc, ioc_info(ioc, \"re-enable the HCDW\\n\"));\n\t\twritel(hcb_size | MPI2_HCB_SIZE_HCB_ENABLE,\n\t\t    &ioc->chip->HCBSize);\n\t}\n\n\tdrsprintk(ioc, ioc_info(ioc, \"restart the adapter\\n\"));\n\twritel(host_diagnostic & ~MPI2_DIAG_HOLD_IOC_RESET,\n\t    &ioc->chip->HostDiagnostic);\n\n\tdrsprintk(ioc,\n\t\t  ioc_info(ioc, \"disable writes to the diagnostic register\\n\"));\n\twritel(MPI2_WRSEQ_FLUSH_KEY_VALUE, &ioc->chip->WriteSequence);\n\n\tdrsprintk(ioc, ioc_info(ioc, \"Wait for FW to go to the READY state\\n\"));\n\tioc_state = _base_wait_on_iocstate(ioc, MPI2_IOC_STATE_READY, 20);\n\tif (ioc_state) {\n\t\tioc_err(ioc, \"%s: failed going to ready state (ioc_state=0x%x)\\n\",\n\t\t\t__func__, ioc_state);\n\t\t_base_dump_reg_set(ioc);\n\t\tgoto out;\n\t}\n\n\tpci_cfg_access_unlock(ioc->pdev);\n\tioc_info(ioc, \"diag reset: SUCCESS\\n\");\n\treturn 0;\n\n out:\n\tpci_cfg_access_unlock(ioc->pdev);\n\tioc_err(ioc, \"diag reset: FAILED\\n\");\n\treturn -EFAULT;\n}\n\n \nint\nmpt3sas_base_make_ioc_ready(struct MPT3SAS_ADAPTER *ioc, enum reset_type type)\n{\n\tu32 ioc_state;\n\tint rc;\n\tint count;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tif (ioc->pci_error_recovery)\n\t\treturn 0;\n\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\tdhsprintk(ioc,\n\t\t  ioc_info(ioc, \"%s: ioc_state(0x%08x)\\n\",\n\t\t\t   __func__, ioc_state));\n\n\t \n\tcount = 0;\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_RESET) {\n\t\twhile ((ioc_state & MPI2_IOC_STATE_MASK) !=\n\t\t    MPI2_IOC_STATE_READY) {\n\t\t\tif (count++ == 10) {\n\t\t\t\tioc_err(ioc, \"%s: failed going to ready state (ioc_state=0x%x)\\n\",\n\t\t\t\t\t__func__, ioc_state);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tssleep(1);\n\t\t\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\t\t}\n\t}\n\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_READY)\n\t\treturn 0;\n\n\tif (ioc_state & MPI2_DOORBELL_USED) {\n\t\tioc_info(ioc, \"unexpected doorbell active!\\n\");\n\t\tgoto issue_diag_reset;\n\t}\n\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {\n\t\tmpt3sas_print_fault_code(ioc, ioc_state &\n\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\tgoto issue_diag_reset;\n\t}\n\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_COREDUMP) {\n\t\t \n\t\tif (ioc->ioc_coredump_loop != MPT3SAS_COREDUMP_LOOP_DONE) {\n\t\t\tmpt3sas_print_coredump_info(ioc, ioc_state &\n\t\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\t\tmpt3sas_base_wait_for_coredump_completion(ioc,\n\t\t\t    __func__);\n\t\t}\n\t\tgoto issue_diag_reset;\n\t}\n\n\tif (type == FORCE_BIG_HAMMER)\n\t\tgoto issue_diag_reset;\n\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_OPERATIONAL)\n\t\tif (!(_base_send_ioc_reset(ioc,\n\t\t    MPI2_FUNCTION_IOC_MESSAGE_UNIT_RESET, 15))) {\n\t\t\treturn 0;\n\t}\n\n issue_diag_reset:\n\trc = _base_diag_reset(ioc);\n\treturn rc;\n}\n\n \nstatic int\n_base_make_ioc_operational(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint r, i, index, rc;\n\tunsigned long\tflags;\n\tu32 reply_address;\n\tu16 smid;\n\tstruct _tr_list *delayed_tr, *delayed_tr_next;\n\tstruct _sc_list *delayed_sc, *delayed_sc_next;\n\tstruct _event_ack_list *delayed_event_ack, *delayed_event_ack_next;\n\tu8 hide_flag;\n\tstruct adapter_reply_queue *reply_q;\n\tMpi2ReplyDescriptorsUnion_t *reply_post_free_contig;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\t \n\tlist_for_each_entry_safe(delayed_tr, delayed_tr_next,\n\t    &ioc->delayed_tr_list, list) {\n\t\tlist_del(&delayed_tr->list);\n\t\tkfree(delayed_tr);\n\t}\n\n\n\tlist_for_each_entry_safe(delayed_tr, delayed_tr_next,\n\t    &ioc->delayed_tr_volume_list, list) {\n\t\tlist_del(&delayed_tr->list);\n\t\tkfree(delayed_tr);\n\t}\n\n\tlist_for_each_entry_safe(delayed_sc, delayed_sc_next,\n\t    &ioc->delayed_sc_list, list) {\n\t\tlist_del(&delayed_sc->list);\n\t\tkfree(delayed_sc);\n\t}\n\n\tlist_for_each_entry_safe(delayed_event_ack, delayed_event_ack_next,\n\t    &ioc->delayed_event_ack_list, list) {\n\t\tlist_del(&delayed_event_ack->list);\n\t\tkfree(delayed_event_ack);\n\t}\n\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\n\t \n\tINIT_LIST_HEAD(&ioc->hpr_free_list);\n\tsmid = ioc->hi_priority_smid;\n\tfor (i = 0; i < ioc->hi_priority_depth; i++, smid++) {\n\t\tioc->hpr_lookup[i].cb_idx = 0xFF;\n\t\tioc->hpr_lookup[i].smid = smid;\n\t\tlist_add_tail(&ioc->hpr_lookup[i].tracker_list,\n\t\t    &ioc->hpr_free_list);\n\t}\n\n\t \n\tINIT_LIST_HEAD(&ioc->internal_free_list);\n\tsmid = ioc->internal_smid;\n\tfor (i = 0; i < ioc->internal_depth; i++, smid++) {\n\t\tioc->internal_lookup[i].cb_idx = 0xFF;\n\t\tioc->internal_lookup[i].smid = smid;\n\t\tlist_add_tail(&ioc->internal_lookup[i].tracker_list,\n\t\t    &ioc->internal_free_list);\n\t}\n\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\n\t \n\tfor (i = 0, reply_address = (u32)ioc->reply_dma ;\n\t    i < ioc->reply_free_queue_depth ; i++, reply_address +=\n\t    ioc->reply_sz) {\n\t\tioc->reply_free[i] = cpu_to_le32(reply_address);\n\t\tif (ioc->is_mcpu_endpoint)\n\t\t\t_base_clone_reply_to_sys_mem(ioc,\n\t\t\t\t\treply_address, i);\n\t}\n\n\t \n\tif (ioc->is_driver_loading)\n\t\t_base_assign_reply_queues(ioc);\n\n\t \n\tindex = 0;\n\treply_post_free_contig = ioc->reply_post[0].reply_post_free;\n\tlist_for_each_entry(reply_q, &ioc->reply_queue_list, list) {\n\t\t \n\t\tif (ioc->rdpq_array_enable) {\n\t\t\treply_q->reply_post_free =\n\t\t\t\tioc->reply_post[index++].reply_post_free;\n\t\t} else {\n\t\t\treply_q->reply_post_free = reply_post_free_contig;\n\t\t\treply_post_free_contig += ioc->reply_post_queue_depth;\n\t\t}\n\n\t\treply_q->reply_post_host_index = 0;\n\t\tfor (i = 0; i < ioc->reply_post_queue_depth; i++)\n\t\t\treply_q->reply_post_free[i].Words =\n\t\t\t    cpu_to_le64(ULLONG_MAX);\n\t\tif (!_base_is_controller_msix_enabled(ioc))\n\t\t\tgoto skip_init_reply_post_free_queue;\n\t}\n skip_init_reply_post_free_queue:\n\n\tr = _base_send_ioc_init(ioc);\n\tif (r) {\n\t\t \n\t\tif (!ioc->is_driver_loading)\n\t\t\treturn r;\n\n\t\trc = mpt3sas_base_check_for_fault_and_issue_reset(ioc);\n\t\tif (rc || (_base_send_ioc_init(ioc)))\n\t\t\treturn r;\n\t}\n\n\t \n\tioc->reply_free_host_index = ioc->reply_free_queue_depth - 1;\n\twritel(ioc->reply_free_host_index, &ioc->chip->ReplyFreeHostIndex);\n\n\t \n\tlist_for_each_entry(reply_q, &ioc->reply_queue_list, list) {\n\t\tif (ioc->combined_reply_queue)\n\t\t\twritel((reply_q->msix_index & 7)<<\n\t\t\t   MPI2_RPHI_MSIX_INDEX_SHIFT,\n\t\t\t   ioc->replyPostRegisterIndex[reply_q->msix_index/8]);\n\t\telse\n\t\t\twritel(reply_q->msix_index <<\n\t\t\t\tMPI2_RPHI_MSIX_INDEX_SHIFT,\n\t\t\t\t&ioc->chip->ReplyPostHostIndex);\n\n\t\tif (!_base_is_controller_msix_enabled(ioc))\n\t\t\tgoto skip_init_reply_post_host_index;\n\t}\n\n skip_init_reply_post_host_index:\n\n\tmpt3sas_base_unmask_interrupts(ioc);\n\n\tif (ioc->hba_mpi_version_belonged != MPI2_VERSION) {\n\t\tr = _base_display_fwpkg_version(ioc);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = _base_static_config_pages(ioc);\n\tif (r)\n\t\treturn r;\n\n\tr = _base_event_notification(ioc);\n\tif (r)\n\t\treturn r;\n\n\tif (!ioc->shost_recovery) {\n\n\t\tif (ioc->is_warpdrive && ioc->manu_pg10.OEMIdentifier\n\t\t    == 0x80) {\n\t\t\thide_flag = (u8) (\n\t\t\t    le32_to_cpu(ioc->manu_pg10.OEMSpecificFlags0) &\n\t\t\t    MFG_PAGE10_HIDE_SSDS_MASK);\n\t\t\tif (hide_flag != MFG_PAGE10_HIDE_SSDS_MASK)\n\t\t\t\tioc->mfg_pg10_hide_flag = hide_flag;\n\t\t}\n\n\t\tioc->wait_for_discovery_to_complete =\n\t\t    _base_determine_wait_on_discovery(ioc);\n\n\t\treturn r;  \n\t}\n\n\tr = _base_send_port_enable(ioc);\n\tif (r)\n\t\treturn r;\n\n\treturn r;\n}\n\n \nvoid\nmpt3sas_base_free_resources(struct MPT3SAS_ADAPTER *ioc)\n{\n\tdexitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\t \n\tmutex_lock(&ioc->pci_access_mutex);\n\tif (ioc->chip_phys && ioc->chip) {\n\t\tmpt3sas_base_mask_interrupts(ioc);\n\t\tioc->shost_recovery = 1;\n\t\tmpt3sas_base_make_ioc_ready(ioc, SOFT_RESET);\n\t\tioc->shost_recovery = 0;\n\t}\n\n\tmpt3sas_base_unmap_resources(ioc);\n\tmutex_unlock(&ioc->pci_access_mutex);\n\treturn;\n}\n\n \nint\nmpt3sas_base_attach(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint r, i, rc;\n\tint cpu_id, last_cpu_id = 0;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\t \n\tioc->cpu_count = num_online_cpus();\n\tfor_each_online_cpu(cpu_id)\n\t\tlast_cpu_id = cpu_id;\n\tioc->cpu_msix_table_sz = last_cpu_id + 1;\n\tioc->cpu_msix_table = kzalloc(ioc->cpu_msix_table_sz, GFP_KERNEL);\n\tioc->reply_queue_count = 1;\n\tif (!ioc->cpu_msix_table) {\n\t\tioc_info(ioc, \"Allocation for cpu_msix_table failed!!!\\n\");\n\t\tr = -ENOMEM;\n\t\tgoto out_free_resources;\n\t}\n\n\tif (ioc->is_warpdrive) {\n\t\tioc->reply_post_host_index = kcalloc(ioc->cpu_msix_table_sz,\n\t\t    sizeof(resource_size_t *), GFP_KERNEL);\n\t\tif (!ioc->reply_post_host_index) {\n\t\t\tioc_info(ioc, \"Allocation for reply_post_host_index failed!!!\\n\");\n\t\t\tr = -ENOMEM;\n\t\t\tgoto out_free_resources;\n\t\t}\n\t}\n\n\tioc->smp_affinity_enable = smp_affinity_enable;\n\n\tioc->rdpq_array_enable_assigned = 0;\n\tioc->use_32bit_dma = false;\n\tioc->dma_mask = 64;\n\tif (ioc->is_aero_ioc) {\n\t\tioc->base_readl = &_base_readl_aero;\n\t\tioc->base_readl_ext_retry = &_base_readl_ext_retry;\n\t} else {\n\t\tioc->base_readl = &_base_readl;\n\t\tioc->base_readl_ext_retry = &_base_readl;\n\t}\n\tr = mpt3sas_base_map_resources(ioc);\n\tif (r)\n\t\tgoto out_free_resources;\n\n\tpci_set_drvdata(ioc->pdev, ioc->shost);\n\tr = _base_get_ioc_facts(ioc);\n\tif (r) {\n\t\trc = mpt3sas_base_check_for_fault_and_issue_reset(ioc);\n\t\tif (rc || (_base_get_ioc_facts(ioc)))\n\t\t\tgoto out_free_resources;\n\t}\n\n\tswitch (ioc->hba_mpi_version_belonged) {\n\tcase MPI2_VERSION:\n\t\tioc->build_sg_scmd = &_base_build_sg_scmd;\n\t\tioc->build_sg = &_base_build_sg;\n\t\tioc->build_zero_len_sge = &_base_build_zero_len_sge;\n\t\tioc->get_msix_index_for_smlio = &_base_get_msix_index;\n\t\tbreak;\n\tcase MPI25_VERSION:\n\tcase MPI26_VERSION:\n\t\t \n\t\tioc->build_sg_scmd = &_base_build_sg_scmd_ieee;\n\t\tioc->build_sg = &_base_build_sg_ieee;\n\t\tioc->build_nvme_prp = &_base_build_nvme_prp;\n\t\tioc->build_zero_len_sge = &_base_build_zero_len_sge_ieee;\n\t\tioc->sge_size_ieee = sizeof(Mpi2IeeeSgeSimple64_t);\n\t\tif (ioc->high_iops_queues)\n\t\t\tioc->get_msix_index_for_smlio =\n\t\t\t\t\t&_base_get_high_iops_msix_index;\n\t\telse\n\t\t\tioc->get_msix_index_for_smlio = &_base_get_msix_index;\n\t\tbreak;\n\t}\n\tif (ioc->atomic_desc_capable) {\n\t\tioc->put_smid_default = &_base_put_smid_default_atomic;\n\t\tioc->put_smid_scsi_io = &_base_put_smid_scsi_io_atomic;\n\t\tioc->put_smid_fast_path =\n\t\t\t\t&_base_put_smid_fast_path_atomic;\n\t\tioc->put_smid_hi_priority =\n\t\t\t\t&_base_put_smid_hi_priority_atomic;\n\t} else {\n\t\tioc->put_smid_default = &_base_put_smid_default;\n\t\tioc->put_smid_fast_path = &_base_put_smid_fast_path;\n\t\tioc->put_smid_hi_priority = &_base_put_smid_hi_priority;\n\t\tif (ioc->is_mcpu_endpoint)\n\t\t\tioc->put_smid_scsi_io =\n\t\t\t\t&_base_put_smid_mpi_ep_scsi_io;\n\t\telse\n\t\t\tioc->put_smid_scsi_io = &_base_put_smid_scsi_io;\n\t}\n\t \n\tioc->build_sg_mpi = &_base_build_sg;\n\tioc->build_zero_len_sge_mpi = &_base_build_zero_len_sge;\n\n\tr = mpt3sas_base_make_ioc_ready(ioc, SOFT_RESET);\n\tif (r)\n\t\tgoto out_free_resources;\n\n\tioc->pfacts = kcalloc(ioc->facts.NumberOfPorts,\n\t    sizeof(struct mpt3sas_port_facts), GFP_KERNEL);\n\tif (!ioc->pfacts) {\n\t\tr = -ENOMEM;\n\t\tgoto out_free_resources;\n\t}\n\n\tfor (i = 0 ; i < ioc->facts.NumberOfPorts; i++) {\n\t\tr = _base_get_port_facts(ioc, i);\n\t\tif (r) {\n\t\t\trc = mpt3sas_base_check_for_fault_and_issue_reset(ioc);\n\t\t\tif (rc || (_base_get_port_facts(ioc, i)))\n\t\t\t\tgoto out_free_resources;\n\t\t}\n\t}\n\n\tr = _base_allocate_memory_pools(ioc);\n\tif (r)\n\t\tgoto out_free_resources;\n\n\tif (irqpoll_weight > 0)\n\t\tioc->thresh_hold = irqpoll_weight;\n\telse\n\t\tioc->thresh_hold = ioc->hba_queue_depth/4;\n\n\t_base_init_irqpolls(ioc);\n\tinit_waitqueue_head(&ioc->reset_wq);\n\n\t \n\tioc->pd_handles_sz = (ioc->facts.MaxDevHandle / 8);\n\tif (ioc->facts.MaxDevHandle % 8)\n\t\tioc->pd_handles_sz++;\n\tioc->pd_handles = kzalloc(ioc->pd_handles_sz,\n\t    GFP_KERNEL);\n\tif (!ioc->pd_handles) {\n\t\tr = -ENOMEM;\n\t\tgoto out_free_resources;\n\t}\n\tioc->blocking_handles = kzalloc(ioc->pd_handles_sz,\n\t    GFP_KERNEL);\n\tif (!ioc->blocking_handles) {\n\t\tr = -ENOMEM;\n\t\tgoto out_free_resources;\n\t}\n\n\t \n\tioc->pend_os_device_add_sz = (ioc->facts.MaxDevHandle / 8);\n\tif (ioc->facts.MaxDevHandle % 8)\n\t\tioc->pend_os_device_add_sz++;\n\tioc->pend_os_device_add = kzalloc(ioc->pend_os_device_add_sz,\n\t    GFP_KERNEL);\n\tif (!ioc->pend_os_device_add) {\n\t\tr = -ENOMEM;\n\t\tgoto out_free_resources;\n\t}\n\n\tioc->device_remove_in_progress_sz = ioc->pend_os_device_add_sz;\n\tioc->device_remove_in_progress =\n\t\tkzalloc(ioc->device_remove_in_progress_sz, GFP_KERNEL);\n\tif (!ioc->device_remove_in_progress) {\n\t\tr = -ENOMEM;\n\t\tgoto out_free_resources;\n\t}\n\n\tioc->fwfault_debug = mpt3sas_fwfault_debug;\n\n\t \n\tmutex_init(&ioc->base_cmds.mutex);\n\tioc->base_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\n\tioc->base_cmds.status = MPT3_CMD_NOT_USED;\n\n\t \n\tioc->port_enable_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\n\tioc->port_enable_cmds.status = MPT3_CMD_NOT_USED;\n\n\t \n\tioc->transport_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\n\tioc->transport_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_init(&ioc->transport_cmds.mutex);\n\n\t \n\tioc->scsih_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\n\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_init(&ioc->scsih_cmds.mutex);\n\n\t \n\tioc->tm_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\n\tioc->tm_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_init(&ioc->tm_cmds.mutex);\n\n\t \n\tioc->config_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\n\tioc->config_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_init(&ioc->config_cmds.mutex);\n\n\t \n\tioc->ctl_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\n\tioc->ctl_cmds.sense = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_KERNEL);\n\tioc->ctl_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_init(&ioc->ctl_cmds.mutex);\n\n\tif (!ioc->base_cmds.reply || !ioc->port_enable_cmds.reply ||\n\t    !ioc->transport_cmds.reply || !ioc->scsih_cmds.reply ||\n\t    !ioc->tm_cmds.reply || !ioc->config_cmds.reply ||\n\t    !ioc->ctl_cmds.reply || !ioc->ctl_cmds.sense) {\n\t\tr = -ENOMEM;\n\t\tgoto out_free_resources;\n\t}\n\n\tfor (i = 0; i < MPI2_EVENT_NOTIFY_EVENTMASK_WORDS; i++)\n\t\tioc->event_masks[i] = -1;\n\n\t \n\t_base_unmask_events(ioc, MPI2_EVENT_SAS_DISCOVERY);\n\t_base_unmask_events(ioc, MPI2_EVENT_SAS_BROADCAST_PRIMITIVE);\n\t_base_unmask_events(ioc, MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST);\n\t_base_unmask_events(ioc, MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE);\n\t_base_unmask_events(ioc, MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE);\n\t_base_unmask_events(ioc, MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST);\n\t_base_unmask_events(ioc, MPI2_EVENT_IR_VOLUME);\n\t_base_unmask_events(ioc, MPI2_EVENT_IR_PHYSICAL_DISK);\n\t_base_unmask_events(ioc, MPI2_EVENT_IR_OPERATION_STATUS);\n\t_base_unmask_events(ioc, MPI2_EVENT_LOG_ENTRY_ADDED);\n\t_base_unmask_events(ioc, MPI2_EVENT_TEMP_THRESHOLD);\n\t_base_unmask_events(ioc, MPI2_EVENT_ACTIVE_CABLE_EXCEPTION);\n\t_base_unmask_events(ioc, MPI2_EVENT_SAS_DEVICE_DISCOVERY_ERROR);\n\tif (ioc->hba_mpi_version_belonged == MPI26_VERSION) {\n\t\tif (ioc->is_gen35_ioc) {\n\t\t\t_base_unmask_events(ioc,\n\t\t\t\tMPI2_EVENT_PCIE_DEVICE_STATUS_CHANGE);\n\t\t\t_base_unmask_events(ioc, MPI2_EVENT_PCIE_ENUMERATION);\n\t\t\t_base_unmask_events(ioc,\n\t\t\t\tMPI2_EVENT_PCIE_TOPOLOGY_CHANGE_LIST);\n\t\t}\n\t}\n\tr = _base_make_ioc_operational(ioc);\n\tif (r == -EAGAIN) {\n\t\tr = _base_make_ioc_operational(ioc);\n\t\tif (r)\n\t\t\tgoto out_free_resources;\n\t}\n\n\t \n\tmemcpy(&ioc->prev_fw_facts, &ioc->facts,\n\t    sizeof(struct mpt3sas_facts));\n\n\tioc->non_operational_loop = 0;\n\tioc->ioc_coredump_loop = 0;\n\tioc->got_task_abort_from_ioctl = 0;\n\treturn 0;\n\n out_free_resources:\n\n\tioc->remove_host = 1;\n\n\tmpt3sas_base_free_resources(ioc);\n\t_base_release_memory_pools(ioc);\n\tpci_set_drvdata(ioc->pdev, NULL);\n\tkfree(ioc->cpu_msix_table);\n\tif (ioc->is_warpdrive)\n\t\tkfree(ioc->reply_post_host_index);\n\tkfree(ioc->pd_handles);\n\tkfree(ioc->blocking_handles);\n\tkfree(ioc->device_remove_in_progress);\n\tkfree(ioc->pend_os_device_add);\n\tkfree(ioc->tm_cmds.reply);\n\tkfree(ioc->transport_cmds.reply);\n\tkfree(ioc->scsih_cmds.reply);\n\tkfree(ioc->config_cmds.reply);\n\tkfree(ioc->base_cmds.reply);\n\tkfree(ioc->port_enable_cmds.reply);\n\tkfree(ioc->ctl_cmds.reply);\n\tkfree(ioc->ctl_cmds.sense);\n\tkfree(ioc->pfacts);\n\tioc->ctl_cmds.reply = NULL;\n\tioc->base_cmds.reply = NULL;\n\tioc->tm_cmds.reply = NULL;\n\tioc->scsih_cmds.reply = NULL;\n\tioc->transport_cmds.reply = NULL;\n\tioc->config_cmds.reply = NULL;\n\tioc->pfacts = NULL;\n\treturn r;\n}\n\n\n \nvoid\nmpt3sas_base_detach(struct MPT3SAS_ADAPTER *ioc)\n{\n\tdexitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tmpt3sas_base_stop_watchdog(ioc);\n\tmpt3sas_base_free_resources(ioc);\n\t_base_release_memory_pools(ioc);\n\tmpt3sas_free_enclosure_list(ioc);\n\tpci_set_drvdata(ioc->pdev, NULL);\n\tkfree(ioc->cpu_msix_table);\n\tif (ioc->is_warpdrive)\n\t\tkfree(ioc->reply_post_host_index);\n\tkfree(ioc->pd_handles);\n\tkfree(ioc->blocking_handles);\n\tkfree(ioc->device_remove_in_progress);\n\tkfree(ioc->pend_os_device_add);\n\tkfree(ioc->pfacts);\n\tkfree(ioc->ctl_cmds.reply);\n\tkfree(ioc->ctl_cmds.sense);\n\tkfree(ioc->base_cmds.reply);\n\tkfree(ioc->port_enable_cmds.reply);\n\tkfree(ioc->tm_cmds.reply);\n\tkfree(ioc->transport_cmds.reply);\n\tkfree(ioc->scsih_cmds.reply);\n\tkfree(ioc->config_cmds.reply);\n}\n\n \nstatic void _base_pre_reset_handler(struct MPT3SAS_ADAPTER *ioc)\n{\n\tmpt3sas_scsih_pre_reset_handler(ioc);\n\tmpt3sas_ctl_pre_reset_handler(ioc);\n\tdtmprintk(ioc, ioc_info(ioc, \"%s: MPT3_IOC_PRE_RESET\\n\", __func__));\n}\n\n \nstatic void\n_base_clear_outstanding_mpt_commands(struct MPT3SAS_ADAPTER *ioc)\n{\n\tdtmprintk(ioc,\n\t    ioc_info(ioc, \"%s: clear outstanding mpt cmds\\n\", __func__));\n\tif (ioc->transport_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc->transport_cmds.status |= MPT3_CMD_RESET;\n\t\tmpt3sas_base_free_smid(ioc, ioc->transport_cmds.smid);\n\t\tcomplete(&ioc->transport_cmds.done);\n\t}\n\tif (ioc->base_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc->base_cmds.status |= MPT3_CMD_RESET;\n\t\tmpt3sas_base_free_smid(ioc, ioc->base_cmds.smid);\n\t\tcomplete(&ioc->base_cmds.done);\n\t}\n\tif (ioc->port_enable_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc->port_enable_failed = 1;\n\t\tioc->port_enable_cmds.status |= MPT3_CMD_RESET;\n\t\tmpt3sas_base_free_smid(ioc, ioc->port_enable_cmds.smid);\n\t\tif (ioc->is_driver_loading) {\n\t\t\tioc->start_scan_failed =\n\t\t\t\tMPI2_IOCSTATUS_INTERNAL_ERROR;\n\t\t\tioc->start_scan = 0;\n\t\t} else {\n\t\t\tcomplete(&ioc->port_enable_cmds.done);\n\t\t}\n\t}\n\tif (ioc->config_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc->config_cmds.status |= MPT3_CMD_RESET;\n\t\tmpt3sas_base_free_smid(ioc, ioc->config_cmds.smid);\n\t\tioc->config_cmds.smid = USHRT_MAX;\n\t\tcomplete(&ioc->config_cmds.done);\n\t}\n}\n\n \nstatic void _base_clear_outstanding_commands(struct MPT3SAS_ADAPTER *ioc)\n{\n\tmpt3sas_scsih_clear_outstanding_scsi_tm_commands(ioc);\n\tmpt3sas_ctl_clear_outstanding_ioctls(ioc);\n\t_base_clear_outstanding_mpt_commands(ioc);\n}\n\n \nstatic void _base_reset_done_handler(struct MPT3SAS_ADAPTER *ioc)\n{\n\tmpt3sas_scsih_reset_done_handler(ioc);\n\tmpt3sas_ctl_reset_done_handler(ioc);\n\tdtmprintk(ioc, ioc_info(ioc, \"%s: MPT3_IOC_DONE_RESET\\n\", __func__));\n}\n\n \nvoid\nmpt3sas_wait_for_commands_to_complete(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 ioc_state;\n\n\tioc->pending_io_count = 0;\n\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) != MPI2_IOC_STATE_OPERATIONAL)\n\t\treturn;\n\n\t \n\tioc->pending_io_count = scsi_host_busy(ioc->shost);\n\n\tif (!ioc->pending_io_count)\n\t\treturn;\n\n\t \n\twait_event_timeout(ioc->reset_wq, ioc->pending_io_count == 0, 10 * HZ);\n}\n\n \nstatic int\n_base_check_ioc_facts_changes(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu16 pd_handles_sz;\n\tvoid *pd_handles = NULL, *blocking_handles = NULL;\n\tvoid *pend_os_device_add = NULL, *device_remove_in_progress = NULL;\n\tstruct mpt3sas_facts *old_facts = &ioc->prev_fw_facts;\n\n\tif (ioc->facts.MaxDevHandle > old_facts->MaxDevHandle) {\n\t\tpd_handles_sz = (ioc->facts.MaxDevHandle / 8);\n\t\tif (ioc->facts.MaxDevHandle % 8)\n\t\t\tpd_handles_sz++;\n\n\t\tpd_handles = krealloc(ioc->pd_handles, pd_handles_sz,\n\t\t    GFP_KERNEL);\n\t\tif (!pd_handles) {\n\t\t\tioc_info(ioc,\n\t\t\t    \"Unable to allocate the memory for pd_handles of sz: %d\\n\",\n\t\t\t    pd_handles_sz);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(pd_handles + ioc->pd_handles_sz, 0,\n\t\t    (pd_handles_sz - ioc->pd_handles_sz));\n\t\tioc->pd_handles = pd_handles;\n\n\t\tblocking_handles = krealloc(ioc->blocking_handles,\n\t\t    pd_handles_sz, GFP_KERNEL);\n\t\tif (!blocking_handles) {\n\t\t\tioc_info(ioc,\n\t\t\t    \"Unable to allocate the memory for \"\n\t\t\t    \"blocking_handles of sz: %d\\n\",\n\t\t\t    pd_handles_sz);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(blocking_handles + ioc->pd_handles_sz, 0,\n\t\t    (pd_handles_sz - ioc->pd_handles_sz));\n\t\tioc->blocking_handles = blocking_handles;\n\t\tioc->pd_handles_sz = pd_handles_sz;\n\n\t\tpend_os_device_add = krealloc(ioc->pend_os_device_add,\n\t\t    pd_handles_sz, GFP_KERNEL);\n\t\tif (!pend_os_device_add) {\n\t\t\tioc_info(ioc,\n\t\t\t    \"Unable to allocate the memory for pend_os_device_add of sz: %d\\n\",\n\t\t\t    pd_handles_sz);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(pend_os_device_add + ioc->pend_os_device_add_sz, 0,\n\t\t    (pd_handles_sz - ioc->pend_os_device_add_sz));\n\t\tioc->pend_os_device_add = pend_os_device_add;\n\t\tioc->pend_os_device_add_sz = pd_handles_sz;\n\n\t\tdevice_remove_in_progress = krealloc(\n\t\t    ioc->device_remove_in_progress, pd_handles_sz, GFP_KERNEL);\n\t\tif (!device_remove_in_progress) {\n\t\t\tioc_info(ioc,\n\t\t\t    \"Unable to allocate the memory for \"\n\t\t\t    \"device_remove_in_progress of sz: %d\\n \"\n\t\t\t    , pd_handles_sz);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(device_remove_in_progress +\n\t\t    ioc->device_remove_in_progress_sz, 0,\n\t\t    (pd_handles_sz - ioc->device_remove_in_progress_sz));\n\t\tioc->device_remove_in_progress = device_remove_in_progress;\n\t\tioc->device_remove_in_progress_sz = pd_handles_sz;\n\t}\n\n\tmemcpy(&ioc->prev_fw_facts, &ioc->facts, sizeof(struct mpt3sas_facts));\n\treturn 0;\n}\n\n \nint\nmpt3sas_base_hard_reset_handler(struct MPT3SAS_ADAPTER *ioc,\n\tenum reset_type type)\n{\n\tint r;\n\tunsigned long flags;\n\tu32 ioc_state;\n\tu8 is_fault = 0, is_trigger = 0;\n\n\tdtmprintk(ioc, ioc_info(ioc, \"%s: enter\\n\", __func__));\n\n\tif (ioc->pci_error_recovery) {\n\t\tioc_err(ioc, \"%s: pci error recovery reset\\n\", __func__);\n\t\tr = 0;\n\t\tgoto out_unlocked;\n\t}\n\n\tif (mpt3sas_fwfault_debug)\n\t\tmpt3sas_halt_firmware(ioc);\n\n\t \n\tmutex_lock(&ioc->reset_in_progress_mutex);\n\n\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\n\tioc->shost_recovery = 1;\n\tspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\n\n\tif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_REGISTERED) &&\n\t    (!(ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_RELEASED))) {\n\t\tis_trigger = 1;\n\t\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\t\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT ||\n\t\t    (ioc_state & MPI2_IOC_STATE_MASK) ==\n\t\t    MPI2_IOC_STATE_COREDUMP) {\n\t\t\tis_fault = 1;\n\t\t\tioc->htb_rel.trigger_info_dwords[1] =\n\t\t\t    (ioc_state & MPI2_DOORBELL_DATA_MASK);\n\t\t}\n\t}\n\t_base_pre_reset_handler(ioc);\n\tmpt3sas_wait_for_commands_to_complete(ioc);\n\tmpt3sas_base_mask_interrupts(ioc);\n\tmpt3sas_base_pause_mq_polling(ioc);\n\tr = mpt3sas_base_make_ioc_ready(ioc, type);\n\tif (r)\n\t\tgoto out;\n\t_base_clear_outstanding_commands(ioc);\n\n\t \n\tif (ioc->is_driver_loading && ioc->port_enable_failed) {\n\t\tioc->remove_host = 1;\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\tr = _base_get_ioc_facts(ioc);\n\tif (r)\n\t\tgoto out;\n\n\tr = _base_check_ioc_facts_changes(ioc);\n\tif (r) {\n\t\tioc_info(ioc,\n\t\t    \"Some of the parameters got changed in this new firmware\"\n\t\t    \" image and it requires system reboot\\n\");\n\t\tgoto out;\n\t}\n\tif (ioc->rdpq_array_enable && !ioc->rdpq_array_capable)\n\t\tpanic(\"%s: Issue occurred with flashing controller firmware.\"\n\t\t      \"Please reboot the system and ensure that the correct\"\n\t\t      \" firmware version is running\\n\", ioc->name);\n\n\tr = _base_make_ioc_operational(ioc);\n\tif (!r)\n\t\t_base_reset_done_handler(ioc);\n\n out:\n\tioc_info(ioc, \"%s: %s\\n\", __func__, r == 0 ? \"SUCCESS\" : \"FAILED\");\n\n\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\n\tioc->shost_recovery = 0;\n\tspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\n\tioc->ioc_reset_count++;\n\tmutex_unlock(&ioc->reset_in_progress_mutex);\n\tmpt3sas_base_resume_mq_polling(ioc);\n\n out_unlocked:\n\tif ((r == 0) && is_trigger) {\n\t\tif (is_fault)\n\t\t\tmpt3sas_trigger_master(ioc, MASTER_TRIGGER_FW_FAULT);\n\t\telse\n\t\t\tmpt3sas_trigger_master(ioc,\n\t\t\t    MASTER_TRIGGER_ADAPTER_RESET);\n\t}\n\tdtmprintk(ioc, ioc_info(ioc, \"%s: exit\\n\", __func__));\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}