{
  "module_name": "advansys.c",
  "hash_id": "d10c04e9b17e66f770d622ce158f2b179f681b66920ae492153db0f3925ce5d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/advansys.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/isa.h>\n#include <linux/eisa.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n#include <linux/dmapool.h>\n\n#include <asm/io.h>\n#include <asm/dma.h>\n\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n\n#define DRV_NAME \"advansys\"\n#define ASC_VERSION \"3.5\"\t \n\n \n\n \n#define ADVANSYS_STATS\n\n \n#undef ADVANSYS_DEBUG\n\ntypedef unsigned char uchar;\n\n#define isodd_word(val)   ((((uint)val) & (uint)0x0001) != 0)\n\n#define PCI_VENDOR_ID_ASP\t\t0x10cd\n#define PCI_DEVICE_ID_ASP_1200A\t\t0x1100\n#define PCI_DEVICE_ID_ASP_ABP940\t0x1200\n#define PCI_DEVICE_ID_ASP_ABP940U\t0x1300\n#define PCI_DEVICE_ID_ASP_ABP940UW\t0x2300\n#define PCI_DEVICE_ID_38C0800_REV1\t0x2500\n#define PCI_DEVICE_ID_38C1600_REV1\t0x2700\n\n#define PortAddr                 unsigned int\t \n#define inp(port)                inb(port)\n#define outp(port, byte)         outb((byte), (port))\n\n#define inpw(port)               inw(port)\n#define outpw(port, word)        outw((word), (port))\n\n#define ASC_MAX_SG_QUEUE    7\n#define ASC_MAX_SG_LIST     255\n\n#define ASC_CS_TYPE  unsigned short\n\n#define ASC_IS_EISA         (0x0002)\n#define ASC_IS_PCI          (0x0004)\n#define ASC_IS_PCI_ULTRA    (0x0104)\n#define ASC_IS_PCMCIA       (0x0008)\n#define ASC_IS_MCA          (0x0020)\n#define ASC_IS_VL           (0x0040)\n#define ASC_IS_WIDESCSI_16  (0x0100)\n#define ASC_IS_WIDESCSI_32  (0x0200)\n#define ASC_IS_BIG_ENDIAN   (0x8000)\n\n#define ASC_CHIP_MIN_VER_VL      (0x01)\n#define ASC_CHIP_MAX_VER_VL      (0x07)\n#define ASC_CHIP_MIN_VER_PCI     (0x09)\n#define ASC_CHIP_MAX_VER_PCI     (0x0F)\n#define ASC_CHIP_VER_PCI_BIT     (0x08)\n#define ASC_CHIP_VER_ASYN_BUG    (0x21)\n#define ASC_CHIP_VER_PCI             0x08\n#define ASC_CHIP_VER_PCI_ULTRA_3150  (ASC_CHIP_VER_PCI | 0x02)\n#define ASC_CHIP_VER_PCI_ULTRA_3050  (ASC_CHIP_VER_PCI | 0x03)\n#define ASC_CHIP_MIN_VER_EISA (0x41)\n#define ASC_CHIP_MAX_VER_EISA (0x47)\n#define ASC_CHIP_VER_EISA_BIT (0x40)\n#define ASC_CHIP_LATEST_VER_EISA   ((ASC_CHIP_MIN_VER_EISA - 1) + 3)\n#define ASC_MAX_VL_DMA_COUNT    (0x07FFFFFFL)\n#define ASC_MAX_PCI_DMA_COUNT   (0xFFFFFFFFL)\n\n#define ASC_SCSI_ID_BITS  3\n#define ASC_SCSI_TIX_TYPE     uchar\n#define ASC_ALL_DEVICE_BIT_SET  0xFF\n#define ASC_SCSI_BIT_ID_TYPE  uchar\n#define ASC_MAX_TID       7\n#define ASC_MAX_LUN       7\n#define ASC_SCSI_WIDTH_BIT_SET  0xFF\n#define ASC_MAX_SENSE_LEN   32\n#define ASC_MIN_SENSE_LEN   14\n#define ASC_SCSI_RESET_HOLD_TIME_US  60\n\n \n#define ASC_MAX_CDB_LEN     12\n#define ADV_MAX_CDB_LEN     16\n\n#define MS_SDTR_LEN    0x03\n#define MS_WDTR_LEN    0x02\n\n#define ASC_SG_LIST_PER_Q   7\n#define QS_FREE        0x00\n#define QS_READY       0x01\n#define QS_DISC1       0x02\n#define QS_DISC2       0x04\n#define QS_BUSY        0x08\n#define QS_ABORTED     0x40\n#define QS_DONE        0x80\n#define QC_NO_CALLBACK   0x01\n#define QC_SG_SWAP_QUEUE 0x02\n#define QC_SG_HEAD       0x04\n#define QC_DATA_IN       0x08\n#define QC_DATA_OUT      0x10\n#define QC_URGENT        0x20\n#define QC_MSG_OUT       0x40\n#define QC_REQ_SENSE     0x80\n#define QCSG_SG_XFER_LIST  0x02\n#define QCSG_SG_XFER_MORE  0x04\n#define QCSG_SG_XFER_END   0x08\n#define QD_IN_PROGRESS       0x00\n#define QD_NO_ERROR          0x01\n#define QD_ABORTED_BY_HOST   0x02\n#define QD_WITH_ERROR        0x04\n#define QD_INVALID_REQUEST   0x80\n#define QD_INVALID_HOST_NUM  0x81\n#define QD_INVALID_DEVICE    0x82\n#define QD_ERR_INTERNAL      0xFF\n#define QHSTA_NO_ERROR               0x00\n#define QHSTA_M_SEL_TIMEOUT          0x11\n#define QHSTA_M_DATA_OVER_RUN        0x12\n#define QHSTA_M_DATA_UNDER_RUN       0x12\n#define QHSTA_M_UNEXPECTED_BUS_FREE  0x13\n#define QHSTA_M_BAD_BUS_PHASE_SEQ    0x14\n#define QHSTA_D_QDONE_SG_LIST_CORRUPTED 0x21\n#define QHSTA_D_ASC_DVC_ERROR_CODE_SET  0x22\n#define QHSTA_D_HOST_ABORT_FAILED       0x23\n#define QHSTA_D_EXE_SCSI_Q_FAILED       0x24\n#define QHSTA_D_EXE_SCSI_Q_BUSY_TIMEOUT 0x25\n#define QHSTA_D_ASPI_NO_BUF_POOL        0x26\n#define QHSTA_M_WTM_TIMEOUT         0x41\n#define QHSTA_M_BAD_CMPL_STATUS_IN  0x42\n#define QHSTA_M_NO_AUTO_REQ_SENSE   0x43\n#define QHSTA_M_AUTO_REQ_SENSE_FAIL 0x44\n#define QHSTA_M_TARGET_STATUS_BUSY  0x45\n#define QHSTA_M_BAD_TAG_CODE        0x46\n#define QHSTA_M_BAD_QUEUE_FULL_OR_BUSY  0x47\n#define QHSTA_M_HUNG_REQ_SCSI_BUS_RESET 0x48\n#define QHSTA_D_LRAM_CMP_ERROR        0x81\n#define QHSTA_M_MICRO_CODE_ERROR_HALT 0xA1\n#define ASC_FLAG_SCSIQ_REQ        0x01\n#define ASC_FLAG_BIOS_SCSIQ_REQ   0x02\n#define ASC_FLAG_BIOS_ASYNC_IO    0x04\n#define ASC_FLAG_SRB_LINEAR_ADDR  0x08\n#define ASC_FLAG_WIN16            0x10\n#define ASC_FLAG_WIN32            0x20\n#define ASC_FLAG_DOS_VM_CALLBACK  0x80\n#define ASC_TAG_FLAG_EXTRA_BYTES               0x10\n#define ASC_TAG_FLAG_DISABLE_DISCONNECT        0x04\n#define ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX  0x08\n#define ASC_TAG_FLAG_DISABLE_CHK_COND_INT_HOST 0x40\n#define ASC_SCSIQ_CPY_BEG              4\n#define ASC_SCSIQ_SGHD_CPY_BEG         2\n#define ASC_SCSIQ_B_FWD                0\n#define ASC_SCSIQ_B_BWD                1\n#define ASC_SCSIQ_B_STATUS             2\n#define ASC_SCSIQ_B_QNO                3\n#define ASC_SCSIQ_B_CNTL               4\n#define ASC_SCSIQ_B_SG_QUEUE_CNT       5\n#define ASC_SCSIQ_D_DATA_ADDR          8\n#define ASC_SCSIQ_D_DATA_CNT          12\n#define ASC_SCSIQ_B_SENSE_LEN         20\n#define ASC_SCSIQ_DONE_INFO_BEG       22\n#define ASC_SCSIQ_D_SRBPTR            22\n#define ASC_SCSIQ_B_TARGET_IX         26\n#define ASC_SCSIQ_B_CDB_LEN           28\n#define ASC_SCSIQ_B_TAG_CODE          29\n#define ASC_SCSIQ_W_VM_ID             30\n#define ASC_SCSIQ_DONE_STATUS         32\n#define ASC_SCSIQ_HOST_STATUS         33\n#define ASC_SCSIQ_SCSI_STATUS         34\n#define ASC_SCSIQ_CDB_BEG             36\n#define ASC_SCSIQ_DW_REMAIN_XFER_ADDR 56\n#define ASC_SCSIQ_DW_REMAIN_XFER_CNT  60\n#define ASC_SCSIQ_B_FIRST_SG_WK_QP    48\n#define ASC_SCSIQ_B_SG_WK_QP          49\n#define ASC_SCSIQ_B_SG_WK_IX          50\n#define ASC_SCSIQ_W_ALT_DC1           52\n#define ASC_SCSIQ_B_LIST_CNT          6\n#define ASC_SCSIQ_B_CUR_LIST_CNT      7\n#define ASC_SGQ_B_SG_CNTL             4\n#define ASC_SGQ_B_SG_HEAD_QP          5\n#define ASC_SGQ_B_SG_LIST_CNT         6\n#define ASC_SGQ_B_SG_CUR_LIST_CNT     7\n#define ASC_SGQ_LIST_BEG              8\n#define ASC_DEF_SCSI1_QNG    4\n#define ASC_MAX_SCSI1_QNG    4\n#define ASC_DEF_SCSI2_QNG    16\n#define ASC_MAX_SCSI2_QNG    32\n#define ASC_TAG_CODE_MASK    0x23\n#define ASC_STOP_REQ_RISC_STOP      0x01\n#define ASC_STOP_ACK_RISC_STOP      0x03\n#define ASC_STOP_CLEAN_UP_BUSY_Q    0x10\n#define ASC_STOP_CLEAN_UP_DISC_Q    0x20\n#define ASC_STOP_HOST_REQ_RISC_HALT 0x40\n#define ASC_TIDLUN_TO_IX(tid, lun)  (ASC_SCSI_TIX_TYPE)((tid) + ((lun)<<ASC_SCSI_ID_BITS))\n#define ASC_TID_TO_TARGET_ID(tid)   (ASC_SCSI_BIT_ID_TYPE)(0x01 << (tid))\n#define ASC_TIX_TO_TARGET_ID(tix)   (0x01 << ((tix) & ASC_MAX_TID))\n#define ASC_TIX_TO_TID(tix)         ((tix) & ASC_MAX_TID)\n#define ASC_TID_TO_TIX(tid)         ((tid) & ASC_MAX_TID)\n#define ASC_TIX_TO_LUN(tix)         (((tix) >> ASC_SCSI_ID_BITS) & ASC_MAX_LUN)\n#define ASC_QNO_TO_QADDR(q_no)      ((ASC_QADR_BEG)+((int)(q_no) << 6))\n\ntypedef struct asc_scsiq_1 {\n\tuchar status;\n\tuchar q_no;\n\tuchar cntl;\n\tuchar sg_queue_cnt;\n\tuchar target_id;\n\tuchar target_lun;\n\t__le32 data_addr;\n\t__le32 data_cnt;\n\t__le32 sense_addr;\n\tuchar sense_len;\n\tuchar extra_bytes;\n} ASC_SCSIQ_1;\n\ntypedef struct asc_scsiq_2 {\n\tu32 srb_tag;\n\tuchar target_ix;\n\tuchar flag;\n\tuchar cdb_len;\n\tuchar tag_code;\n\tushort vm_id;\n} ASC_SCSIQ_2;\n\ntypedef struct asc_scsiq_3 {\n\tuchar done_stat;\n\tuchar host_stat;\n\tuchar scsi_stat;\n\tuchar scsi_msg;\n} ASC_SCSIQ_3;\n\ntypedef struct asc_scsiq_4 {\n\tuchar cdb[ASC_MAX_CDB_LEN];\n\tuchar y_first_sg_list_qp;\n\tuchar y_working_sg_qp;\n\tuchar y_working_sg_ix;\n\tuchar y_res;\n\tushort x_req_count;\n\tushort x_reconnect_rtn;\n\t__le32 x_saved_data_addr;\n\t__le32 x_saved_data_cnt;\n} ASC_SCSIQ_4;\n\ntypedef struct asc_q_done_info {\n\tASC_SCSIQ_2 d2;\n\tASC_SCSIQ_3 d3;\n\tuchar q_status;\n\tuchar q_no;\n\tuchar cntl;\n\tuchar sense_len;\n\tuchar extra_bytes;\n\tuchar res;\n\tu32 remain_bytes;\n} ASC_QDONE_INFO;\n\ntypedef struct asc_sg_list {\n\t__le32 addr;\n\t__le32 bytes;\n} ASC_SG_LIST;\n\ntypedef struct asc_sg_head {\n\tushort entry_cnt;\n\tushort queue_cnt;\n\tushort entry_to_copy;\n\tushort res;\n\tASC_SG_LIST sg_list[];\n} ASC_SG_HEAD;\n\ntypedef struct asc_scsi_q {\n\tASC_SCSIQ_1 q1;\n\tASC_SCSIQ_2 q2;\n\tuchar *cdbptr;\n\tASC_SG_HEAD *sg_head;\n\tushort remain_sg_entry_cnt;\n\tushort next_sg_index;\n} ASC_SCSI_Q;\n\ntypedef struct asc_scsi_bios_req_q {\n\tASC_SCSIQ_1 r1;\n\tASC_SCSIQ_2 r2;\n\tuchar *cdbptr;\n\tASC_SG_HEAD *sg_head;\n\tuchar *sense_ptr;\n\tASC_SCSIQ_3 r3;\n\tuchar cdb[ASC_MAX_CDB_LEN];\n\tuchar sense[ASC_MIN_SENSE_LEN];\n} ASC_SCSI_BIOS_REQ_Q;\n\ntypedef struct asc_risc_q {\n\tuchar fwd;\n\tuchar bwd;\n\tASC_SCSIQ_1 i1;\n\tASC_SCSIQ_2 i2;\n\tASC_SCSIQ_3 i3;\n\tASC_SCSIQ_4 i4;\n} ASC_RISC_Q;\n\ntypedef struct asc_sg_list_q {\n\tuchar seq_no;\n\tuchar q_no;\n\tuchar cntl;\n\tuchar sg_head_qp;\n\tuchar sg_list_cnt;\n\tuchar sg_cur_list_cnt;\n} ASC_SG_LIST_Q;\n\ntypedef struct asc_risc_sg_list_q {\n\tuchar fwd;\n\tuchar bwd;\n\tASC_SG_LIST_Q sg;\n\tASC_SG_LIST sg_list[7];\n} ASC_RISC_SG_LIST_Q;\n\n#define ASCQ_ERR_Q_STATUS             0x0D\n#define ASCQ_ERR_CUR_QNG              0x17\n#define ASCQ_ERR_SG_Q_LINKS           0x18\n#define ASCQ_ERR_ISR_RE_ENTRY         0x1A\n#define ASCQ_ERR_CRITICAL_RE_ENTRY    0x1B\n#define ASCQ_ERR_ISR_ON_CRITICAL      0x1C\n\n \n#define ASC_WARN_NO_ERROR             0x0000\n#define ASC_WARN_IO_PORT_ROTATE       0x0001\n#define ASC_WARN_EEPROM_CHKSUM        0x0002\n#define ASC_WARN_IRQ_MODIFIED         0x0004\n#define ASC_WARN_AUTO_CONFIG          0x0008\n#define ASC_WARN_CMD_QNG_CONFLICT     0x0010\n#define ASC_WARN_EEPROM_RECOVER       0x0020\n#define ASC_WARN_CFG_MSW_RECOVER      0x0040\n\n \n#define ASC_IERR_NO_CARRIER\t\t0x0001\t \n#define ASC_IERR_MCODE_CHKSUM\t\t0x0002\t \n#define ASC_IERR_SET_PC_ADDR\t\t0x0004\n#define ASC_IERR_START_STOP_CHIP\t0x0008\t \n#define ASC_IERR_ILLEGAL_CONNECTION\t0x0010\t \n#define ASC_IERR_SINGLE_END_DEVICE\t0x0020\t \n#define ASC_IERR_REVERSED_CABLE\t\t0x0040\t \n#define ASC_IERR_SET_SCSI_ID\t\t0x0080\t \n#define ASC_IERR_HVD_DEVICE\t\t0x0100\t \n#define ASC_IERR_BAD_SIGNATURE\t\t0x0200\t \n#define ASC_IERR_NO_BUS_TYPE\t\t0x0400\n#define ASC_IERR_BIST_PRE_TEST\t\t0x0800\t \n#define ASC_IERR_BIST_RAM_TEST\t\t0x1000\t \n#define ASC_IERR_BAD_CHIPTYPE\t\t0x2000\t \n\n#define ASC_DEF_MAX_TOTAL_QNG   (0xF0)\n#define ASC_MIN_TAG_Q_PER_DVC   (0x04)\n#define ASC_MIN_FREE_Q        (0x02)\n#define ASC_MIN_TOTAL_QNG     ((ASC_MAX_SG_QUEUE)+(ASC_MIN_FREE_Q))\n#define ASC_MAX_TOTAL_QNG 240\n#define ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG 16\n#define ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG   8\n#define ASC_MAX_PCI_INRAM_TOTAL_QNG  20\n#define ASC_MAX_INRAM_TAG_QNG   16\n#define ASC_IOADR_GAP   0x10\n#define ASC_SYN_MAX_OFFSET         0x0F\n#define ASC_DEF_SDTR_OFFSET        0x0F\n#define ASC_SDTR_ULTRA_PCI_10MB_INDEX  0x02\n#define ASYN_SDTR_DATA_FIX_PCI_REV_AB 0x41\n\n \nstatic const unsigned char asc_syn_xfer_period[8] = {\n\t25, 30, 35, 40, 50, 60, 70, 85\n};\n\nstatic const unsigned char asc_syn_ultra_xfer_period[16] = {\n\t12, 19, 25, 32, 38, 44, 50, 57, 63, 69, 75, 82, 88, 94, 100, 107\n};\n\ntypedef struct ext_msg {\n\tuchar msg_type;\n\tuchar msg_len;\n\tuchar msg_req;\n\tunion {\n\t\tstruct {\n\t\t\tuchar sdtr_xfer_period;\n\t\t\tuchar sdtr_req_ack_offset;\n\t\t} sdtr;\n\t\tstruct {\n\t\t\tuchar wdtr_width;\n\t\t} wdtr;\n\t\tstruct {\n\t\t\tuchar mdp_b3;\n\t\t\tuchar mdp_b2;\n\t\t\tuchar mdp_b1;\n\t\t\tuchar mdp_b0;\n\t\t} mdp;\n\t} u_ext_msg;\n\tuchar res;\n} EXT_MSG;\n\n#define xfer_period     u_ext_msg.sdtr.sdtr_xfer_period\n#define req_ack_offset  u_ext_msg.sdtr.sdtr_req_ack_offset\n#define wdtr_width      u_ext_msg.wdtr.wdtr_width\n#define mdp_b3          u_ext_msg.mdp_b3\n#define mdp_b2          u_ext_msg.mdp_b2\n#define mdp_b1          u_ext_msg.mdp_b1\n#define mdp_b0          u_ext_msg.mdp_b0\n\ntypedef struct asc_dvc_cfg {\n\tASC_SCSI_BIT_ID_TYPE can_tagged_qng;\n\tASC_SCSI_BIT_ID_TYPE cmd_qng_enabled;\n\tASC_SCSI_BIT_ID_TYPE disc_enable;\n\tASC_SCSI_BIT_ID_TYPE sdtr_enable;\n\tuchar chip_scsi_id;\n\tuchar chip_version;\n\tushort mcode_date;\n\tushort mcode_version;\n\tuchar max_tag_qng[ASC_MAX_TID + 1];\n\tuchar sdtr_period_offset[ASC_MAX_TID + 1];\n\tuchar adapter_info[6];\n} ASC_DVC_CFG;\n\n#define ASC_DEF_DVC_CNTL       0xFFFF\n#define ASC_DEF_CHIP_SCSI_ID   7\n#define ASC_DEF_ISA_DMA_SPEED  4\n#define ASC_INIT_STATE_BEG_GET_CFG   0x0001\n#define ASC_INIT_STATE_END_GET_CFG   0x0002\n#define ASC_INIT_STATE_BEG_SET_CFG   0x0004\n#define ASC_INIT_STATE_END_SET_CFG   0x0008\n#define ASC_INIT_STATE_BEG_LOAD_MC   0x0010\n#define ASC_INIT_STATE_END_LOAD_MC   0x0020\n#define ASC_INIT_STATE_BEG_INQUIRY   0x0040\n#define ASC_INIT_STATE_END_INQUIRY   0x0080\n#define ASC_INIT_RESET_SCSI_DONE     0x0100\n#define ASC_INIT_STATE_WITHOUT_EEP   0x8000\n#define ASC_BUG_FIX_IF_NOT_DWB       0x0001\n#define ASC_BUG_FIX_ASYN_USE_SYN     0x0002\n#define ASC_MIN_TAGGED_CMD  7\n#define ASC_MAX_SCSI_RESET_WAIT      30\n#define ASC_OVERRUN_BSIZE\t\t64\n\nstruct asc_dvc_var;\t\t \n\ntypedef struct asc_dvc_var {\n\tPortAddr iop_base;\n\tushort err_code;\n\tushort dvc_cntl;\n\tushort bug_fix_cntl;\n\tushort bus_type;\n\tASC_SCSI_BIT_ID_TYPE init_sdtr;\n\tASC_SCSI_BIT_ID_TYPE sdtr_done;\n\tASC_SCSI_BIT_ID_TYPE use_tagged_qng;\n\tASC_SCSI_BIT_ID_TYPE unit_not_ready;\n\tASC_SCSI_BIT_ID_TYPE queue_full_or_busy;\n\tASC_SCSI_BIT_ID_TYPE start_motor;\n\tuchar *overrun_buf;\n\tdma_addr_t overrun_dma;\n\tuchar scsi_reset_wait;\n\tuchar chip_no;\n\tbool is_in_int;\n\tuchar max_total_qng;\n\tuchar cur_total_qng;\n\tuchar in_critical_cnt;\n\tuchar last_q_shortage;\n\tushort init_state;\n\tuchar cur_dvc_qng[ASC_MAX_TID + 1];\n\tuchar max_dvc_qng[ASC_MAX_TID + 1];\n\tASC_SCSI_Q *scsiq_busy_head[ASC_MAX_TID + 1];\n\tASC_SCSI_Q *scsiq_busy_tail[ASC_MAX_TID + 1];\n\tconst uchar *sdtr_period_tbl;\n\tASC_DVC_CFG *cfg;\n\tASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer_always;\n\tchar redo_scam;\n\tushort res2;\n\tuchar dos_int13_table[ASC_MAX_TID + 1];\n\tunsigned int max_dma_count;\n\tASC_SCSI_BIT_ID_TYPE no_scam;\n\tASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer;\n\tuchar min_sdtr_index;\n\tuchar max_sdtr_index;\n\tstruct asc_board *drv_ptr;\n\tunsigned int uc_break;\n} ASC_DVC_VAR;\n\ntypedef struct asc_dvc_inq_info {\n\tuchar type[ASC_MAX_TID + 1][ASC_MAX_LUN + 1];\n} ASC_DVC_INQ_INFO;\n\ntypedef struct asc_cap_info {\n\tu32 lba;\n\tu32 blk_size;\n} ASC_CAP_INFO;\n\ntypedef struct asc_cap_info_array {\n\tASC_CAP_INFO cap_info[ASC_MAX_TID + 1][ASC_MAX_LUN + 1];\n} ASC_CAP_INFO_ARRAY;\n\n#define ASC_MCNTL_NO_SEL_TIMEOUT  (ushort)0x0001\n#define ASC_MCNTL_NULL_TARGET     (ushort)0x0002\n#define ASC_CNTL_INITIATOR         (ushort)0x0001\n#define ASC_CNTL_BIOS_GT_1GB       (ushort)0x0002\n#define ASC_CNTL_BIOS_GT_2_DISK    (ushort)0x0004\n#define ASC_CNTL_BIOS_REMOVABLE    (ushort)0x0008\n#define ASC_CNTL_NO_SCAM           (ushort)0x0010\n#define ASC_CNTL_INT_MULTI_Q       (ushort)0x0080\n#define ASC_CNTL_NO_LUN_SUPPORT    (ushort)0x0040\n#define ASC_CNTL_NO_VERIFY_COPY    (ushort)0x0100\n#define ASC_CNTL_RESET_SCSI        (ushort)0x0200\n#define ASC_CNTL_INIT_INQUIRY      (ushort)0x0400\n#define ASC_CNTL_INIT_VERBOSE      (ushort)0x0800\n#define ASC_CNTL_SCSI_PARITY       (ushort)0x1000\n#define ASC_CNTL_BURST_MODE        (ushort)0x2000\n#define ASC_CNTL_SDTR_ENABLE_ULTRA (ushort)0x4000\n#define ASC_EEP_DVC_CFG_BEG_VL    2\n#define ASC_EEP_MAX_DVC_ADDR_VL   15\n#define ASC_EEP_DVC_CFG_BEG      32\n#define ASC_EEP_MAX_DVC_ADDR     45\n#define ASC_EEP_MAX_RETRY        20\n\n \n\n#define ASC_EEP_GET_CHIP_ID(cfg)    ((cfg)->id_speed & 0x0f)\n#define ASC_EEP_GET_DMA_SPD(cfg)    (((cfg)->id_speed & 0xf0) >> 4)\n#define ASC_EEP_SET_CHIP_ID(cfg, sid) \\\n   ((cfg)->id_speed = ((cfg)->id_speed & 0xf0) | ((sid) & ASC_MAX_TID))\n#define ASC_EEP_SET_DMA_SPD(cfg, spd) \\\n   ((cfg)->id_speed = ((cfg)->id_speed & 0x0f) | ((spd) & 0x0f) << 4)\n\ntypedef struct asceep_config {\n\tushort cfg_lsw;\n\tushort cfg_msw;\n\tuchar init_sdtr;\n\tuchar disc_enable;\n\tuchar use_cmd_qng;\n\tuchar start_motor;\n\tuchar max_total_qng;\n\tuchar max_tag_qng;\n\tuchar bios_scan;\n\tuchar power_up_wait;\n\tuchar no_scam;\n\tuchar id_speed;\t\t \n\t \n\tuchar dos_int13_table[ASC_MAX_TID + 1];\n\tuchar adapter_info[6];\n\tushort cntl;\n\tushort chksum;\n} ASCEEP_CONFIG;\n\n#define ASC_EEP_CMD_READ          0x80\n#define ASC_EEP_CMD_WRITE         0x40\n#define ASC_EEP_CMD_WRITE_ABLE    0x30\n#define ASC_EEP_CMD_WRITE_DISABLE 0x00\n#define ASCV_MSGOUT_BEG         0x0000\n#define ASCV_MSGOUT_SDTR_PERIOD (ASCV_MSGOUT_BEG+3)\n#define ASCV_MSGOUT_SDTR_OFFSET (ASCV_MSGOUT_BEG+4)\n#define ASCV_BREAK_SAVED_CODE   (ushort)0x0006\n#define ASCV_MSGIN_BEG          (ASCV_MSGOUT_BEG+8)\n#define ASCV_MSGIN_SDTR_PERIOD  (ASCV_MSGIN_BEG+3)\n#define ASCV_MSGIN_SDTR_OFFSET  (ASCV_MSGIN_BEG+4)\n#define ASCV_SDTR_DATA_BEG      (ASCV_MSGIN_BEG+8)\n#define ASCV_SDTR_DONE_BEG      (ASCV_SDTR_DATA_BEG+8)\n#define ASCV_MAX_DVC_QNG_BEG    (ushort)0x0020\n#define ASCV_BREAK_ADDR           (ushort)0x0028\n#define ASCV_BREAK_NOTIFY_COUNT   (ushort)0x002A\n#define ASCV_BREAK_CONTROL        (ushort)0x002C\n#define ASCV_BREAK_HIT_COUNT      (ushort)0x002E\n\n#define ASCV_ASCDVC_ERR_CODE_W  (ushort)0x0030\n#define ASCV_MCODE_CHKSUM_W   (ushort)0x0032\n#define ASCV_MCODE_SIZE_W     (ushort)0x0034\n#define ASCV_STOP_CODE_B      (ushort)0x0036\n#define ASCV_DVC_ERR_CODE_B   (ushort)0x0037\n#define ASCV_OVERRUN_PADDR_D  (ushort)0x0038\n#define ASCV_OVERRUN_BSIZE_D  (ushort)0x003C\n#define ASCV_HALTCODE_W       (ushort)0x0040\n#define ASCV_CHKSUM_W         (ushort)0x0042\n#define ASCV_MC_DATE_W        (ushort)0x0044\n#define ASCV_MC_VER_W         (ushort)0x0046\n#define ASCV_NEXTRDY_B        (ushort)0x0048\n#define ASCV_DONENEXT_B       (ushort)0x0049\n#define ASCV_USE_TAGGED_QNG_B (ushort)0x004A\n#define ASCV_SCSIBUSY_B       (ushort)0x004B\n#define ASCV_Q_DONE_IN_PROGRESS_B  (ushort)0x004C\n#define ASCV_CURCDB_B         (ushort)0x004D\n#define ASCV_RCLUN_B          (ushort)0x004E\n#define ASCV_BUSY_QHEAD_B     (ushort)0x004F\n#define ASCV_DISC1_QHEAD_B    (ushort)0x0050\n#define ASCV_DISC_ENABLE_B    (ushort)0x0052\n#define ASCV_CAN_TAGGED_QNG_B (ushort)0x0053\n#define ASCV_HOSTSCSI_ID_B    (ushort)0x0055\n#define ASCV_MCODE_CNTL_B     (ushort)0x0056\n#define ASCV_NULL_TARGET_B    (ushort)0x0057\n#define ASCV_FREE_Q_HEAD_W    (ushort)0x0058\n#define ASCV_DONE_Q_TAIL_W    (ushort)0x005A\n#define ASCV_FREE_Q_HEAD_B    (ushort)(ASCV_FREE_Q_HEAD_W+1)\n#define ASCV_DONE_Q_TAIL_B    (ushort)(ASCV_DONE_Q_TAIL_W+1)\n#define ASCV_HOST_FLAG_B      (ushort)0x005D\n#define ASCV_TOTAL_READY_Q_B  (ushort)0x0064\n#define ASCV_VER_SERIAL_B     (ushort)0x0065\n#define ASCV_HALTCODE_SAVED_W (ushort)0x0066\n#define ASCV_WTM_FLAG_B       (ushort)0x0068\n#define ASCV_RISC_FLAG_B      (ushort)0x006A\n#define ASCV_REQ_SG_LIST_QP   (ushort)0x006B\n#define ASC_HOST_FLAG_IN_ISR        0x01\n#define ASC_HOST_FLAG_ACK_INT       0x02\n#define ASC_RISC_FLAG_GEN_INT      0x01\n#define ASC_RISC_FLAG_REQ_SG_LIST  0x02\n#define IOP_CTRL         (0x0F)\n#define IOP_STATUS       (0x0E)\n#define IOP_INT_ACK      IOP_STATUS\n#define IOP_REG_IFC      (0x0D)\n#define IOP_SYN_OFFSET    (0x0B)\n#define IOP_EXTRA_CONTROL (0x0D)\n#define IOP_REG_PC        (0x0C)\n#define IOP_RAM_ADDR      (0x0A)\n#define IOP_RAM_DATA      (0x08)\n#define IOP_EEP_DATA      (0x06)\n#define IOP_EEP_CMD       (0x07)\n#define IOP_VERSION       (0x03)\n#define IOP_CONFIG_HIGH   (0x04)\n#define IOP_CONFIG_LOW    (0x02)\n#define IOP_SIG_BYTE      (0x01)\n#define IOP_SIG_WORD      (0x00)\n#define IOP_REG_DC1      (0x0E)\n#define IOP_REG_DC0      (0x0C)\n#define IOP_REG_SB       (0x0B)\n#define IOP_REG_DA1      (0x0A)\n#define IOP_REG_DA0      (0x08)\n#define IOP_REG_SC       (0x09)\n#define IOP_DMA_SPEED    (0x07)\n#define IOP_REG_FLAG     (0x07)\n#define IOP_FIFO_H       (0x06)\n#define IOP_FIFO_L       (0x04)\n#define IOP_REG_ID       (0x05)\n#define IOP_REG_QP       (0x03)\n#define IOP_REG_IH       (0x02)\n#define IOP_REG_IX       (0x01)\n#define IOP_REG_AX       (0x00)\n#define IFC_REG_LOCK      (0x00)\n#define IFC_REG_UNLOCK    (0x09)\n#define IFC_WR_EN_FILTER  (0x10)\n#define IFC_RD_NO_EEPROM  (0x10)\n#define IFC_SLEW_RATE     (0x20)\n#define IFC_ACT_NEG       (0x40)\n#define IFC_INP_FILTER    (0x80)\n#define IFC_INIT_DEFAULT  (IFC_ACT_NEG | IFC_REG_UNLOCK)\n#define SC_SEL   (uchar)(0x80)\n#define SC_BSY   (uchar)(0x40)\n#define SC_ACK   (uchar)(0x20)\n#define SC_REQ   (uchar)(0x10)\n#define SC_ATN   (uchar)(0x08)\n#define SC_IO    (uchar)(0x04)\n#define SC_CD    (uchar)(0x02)\n#define SC_MSG   (uchar)(0x01)\n#define SEC_SCSI_CTL         (uchar)(0x80)\n#define SEC_ACTIVE_NEGATE    (uchar)(0x40)\n#define SEC_SLEW_RATE        (uchar)(0x20)\n#define SEC_ENABLE_FILTER    (uchar)(0x10)\n#define ASC_HALT_EXTMSG_IN     (ushort)0x8000\n#define ASC_HALT_CHK_CONDITION (ushort)0x8100\n#define ASC_HALT_SS_QUEUE_FULL (ushort)0x8200\n#define ASC_HALT_DISABLE_ASYN_USE_SYN_FIX  (ushort)0x8300\n#define ASC_HALT_ENABLE_ASYN_USE_SYN_FIX   (ushort)0x8400\n#define ASC_HALT_SDTR_REJECTED (ushort)0x4000\n#define ASC_HALT_HOST_COPY_SG_LIST_TO_RISC ( ushort )0x2000\n#define ASC_MAX_QNO        0xF8\n#define ASC_DATA_SEC_BEG   (ushort)0x0080\n#define ASC_DATA_SEC_END   (ushort)0x0080\n#define ASC_CODE_SEC_BEG   (ushort)0x0080\n#define ASC_CODE_SEC_END   (ushort)0x0080\n#define ASC_QADR_BEG       (0x4000)\n#define ASC_QADR_USED      (ushort)(ASC_MAX_QNO * 64)\n#define ASC_QADR_END       (ushort)0x7FFF\n#define ASC_QLAST_ADR      (ushort)0x7FC0\n#define ASC_QBLK_SIZE      0x40\n#define ASC_BIOS_DATA_QBEG 0xF8\n#define ASC_MIN_ACTIVE_QNO 0x01\n#define ASC_QLINK_END      0xFF\n#define ASC_EEPROM_WORDS   0x10\n#define ASC_MAX_MGS_LEN    0x10\n#define ASC_BIOS_ADDR_DEF  0xDC00\n#define ASC_BIOS_SIZE      0x3800\n#define ASC_BIOS_RAM_OFF   0x3800\n#define ASC_BIOS_RAM_SIZE  0x800\n#define ASC_BIOS_MIN_ADDR  0xC000\n#define ASC_BIOS_MAX_ADDR  0xEC00\n#define ASC_BIOS_BANK_SIZE 0x0400\n#define ASC_MCODE_START_ADDR  0x0080\n#define ASC_CFG0_HOST_INT_ON    0x0020\n#define ASC_CFG0_BIOS_ON        0x0040\n#define ASC_CFG0_VERA_BURST_ON  0x0080\n#define ASC_CFG0_SCSI_PARITY_ON 0x0800\n#define ASC_CFG1_SCSI_TARGET_ON 0x0080\n#define ASC_CFG1_LRAM_8BITS_ON  0x0800\n#define ASC_CFG_MSW_CLR_MASK    0x3080\n#define CSW_TEST1             (ASC_CS_TYPE)0x8000\n#define CSW_AUTO_CONFIG       (ASC_CS_TYPE)0x4000\n#define CSW_RESERVED1         (ASC_CS_TYPE)0x2000\n#define CSW_IRQ_WRITTEN       (ASC_CS_TYPE)0x1000\n#define CSW_33MHZ_SELECTED    (ASC_CS_TYPE)0x0800\n#define CSW_TEST2             (ASC_CS_TYPE)0x0400\n#define CSW_TEST3             (ASC_CS_TYPE)0x0200\n#define CSW_RESERVED2         (ASC_CS_TYPE)0x0100\n#define CSW_DMA_DONE          (ASC_CS_TYPE)0x0080\n#define CSW_FIFO_RDY          (ASC_CS_TYPE)0x0040\n#define CSW_EEP_READ_DONE     (ASC_CS_TYPE)0x0020\n#define CSW_HALTED            (ASC_CS_TYPE)0x0010\n#define CSW_SCSI_RESET_ACTIVE (ASC_CS_TYPE)0x0008\n#define CSW_PARITY_ERR        (ASC_CS_TYPE)0x0004\n#define CSW_SCSI_RESET_LATCH  (ASC_CS_TYPE)0x0002\n#define CSW_INT_PENDING       (ASC_CS_TYPE)0x0001\n#define CIW_CLR_SCSI_RESET_INT (ASC_CS_TYPE)0x1000\n#define CIW_INT_ACK      (ASC_CS_TYPE)0x0100\n#define CIW_TEST1        (ASC_CS_TYPE)0x0200\n#define CIW_TEST2        (ASC_CS_TYPE)0x0400\n#define CIW_SEL_33MHZ    (ASC_CS_TYPE)0x0800\n#define CIW_IRQ_ACT      (ASC_CS_TYPE)0x1000\n#define CC_CHIP_RESET   (uchar)0x80\n#define CC_SCSI_RESET   (uchar)0x40\n#define CC_HALT         (uchar)0x20\n#define CC_SINGLE_STEP  (uchar)0x10\n#define CC_DMA_ABLE     (uchar)0x08\n#define CC_TEST         (uchar)0x04\n#define CC_BANK_ONE     (uchar)0x02\n#define CC_DIAG         (uchar)0x01\n#define ASC_1000_ID0W      0x04C1\n#define ASC_1000_ID0W_FIX  0x00C1\n#define ASC_1000_ID1B      0x25\n#define ASC_EISA_REV_IOP_MASK  (0x0C83)\n#define ASC_EISA_CFG_IOP_MASK  (0x0C86)\n#define ASC_GET_EISA_SLOT(iop)  (PortAddr)((iop) & 0xF000)\n#define INS_HALTINT        (ushort)0x6281\n#define INS_HALT           (ushort)0x6280\n#define INS_SINT           (ushort)0x6200\n#define INS_RFLAG_WTM      (ushort)0x7380\n#define ASC_MC_SAVE_CODE_WSIZE  0x500\n#define ASC_MC_SAVE_DATA_WSIZE  0x40\n\ntypedef struct asc_mc_saved {\n\tushort data[ASC_MC_SAVE_DATA_WSIZE];\n\tushort code[ASC_MC_SAVE_CODE_WSIZE];\n} ASC_MC_SAVED;\n\n#define AscGetQDoneInProgress(port)         AscReadLramByte((port), ASCV_Q_DONE_IN_PROGRESS_B)\n#define AscPutQDoneInProgress(port, val)    AscWriteLramByte((port), ASCV_Q_DONE_IN_PROGRESS_B, val)\n#define AscGetVarFreeQHead(port)            AscReadLramWord((port), ASCV_FREE_Q_HEAD_W)\n#define AscGetVarDoneQTail(port)            AscReadLramWord((port), ASCV_DONE_Q_TAIL_W)\n#define AscPutVarFreeQHead(port, val)       AscWriteLramWord((port), ASCV_FREE_Q_HEAD_W, val)\n#define AscPutVarDoneQTail(port, val)       AscWriteLramWord((port), ASCV_DONE_Q_TAIL_W, val)\n#define AscGetRiscVarFreeQHead(port)        AscReadLramByte((port), ASCV_NEXTRDY_B)\n#define AscGetRiscVarDoneQTail(port)        AscReadLramByte((port), ASCV_DONENEXT_B)\n#define AscPutRiscVarFreeQHead(port, val)   AscWriteLramByte((port), ASCV_NEXTRDY_B, val)\n#define AscPutRiscVarDoneQTail(port, val)   AscWriteLramByte((port), ASCV_DONENEXT_B, val)\n#define AscPutMCodeSDTRDoneAtID(port, id, data)  AscWriteLramByte((port), (ushort)((ushort)ASCV_SDTR_DONE_BEG+(ushort)id), (data))\n#define AscGetMCodeSDTRDoneAtID(port, id)        AscReadLramByte((port), (ushort)((ushort)ASCV_SDTR_DONE_BEG+(ushort)id))\n#define AscPutMCodeInitSDTRAtID(port, id, data)  AscWriteLramByte((port), (ushort)((ushort)ASCV_SDTR_DATA_BEG+(ushort)id), data)\n#define AscGetMCodeInitSDTRAtID(port, id)        AscReadLramByte((port), (ushort)((ushort)ASCV_SDTR_DATA_BEG+(ushort)id))\n#define AscGetChipSignatureByte(port)     (uchar)inp((port)+IOP_SIG_BYTE)\n#define AscGetChipSignatureWord(port)     (ushort)inpw((port)+IOP_SIG_WORD)\n#define AscGetChipVerNo(port)             (uchar)inp((port)+IOP_VERSION)\n#define AscGetChipCfgLsw(port)            (ushort)inpw((port)+IOP_CONFIG_LOW)\n#define AscGetChipCfgMsw(port)            (ushort)inpw((port)+IOP_CONFIG_HIGH)\n#define AscSetChipCfgLsw(port, data)      outpw((port)+IOP_CONFIG_LOW, data)\n#define AscSetChipCfgMsw(port, data)      outpw((port)+IOP_CONFIG_HIGH, data)\n#define AscGetChipEEPCmd(port)            (uchar)inp((port)+IOP_EEP_CMD)\n#define AscSetChipEEPCmd(port, data)      outp((port)+IOP_EEP_CMD, data)\n#define AscGetChipEEPData(port)           (ushort)inpw((port)+IOP_EEP_DATA)\n#define AscSetChipEEPData(port, data)     outpw((port)+IOP_EEP_DATA, data)\n#define AscGetChipLramAddr(port)          (ushort)inpw((PortAddr)((port)+IOP_RAM_ADDR))\n#define AscSetChipLramAddr(port, addr)    outpw((PortAddr)((port)+IOP_RAM_ADDR), addr)\n#define AscGetChipLramData(port)          (ushort)inpw((port)+IOP_RAM_DATA)\n#define AscSetChipLramData(port, data)    outpw((port)+IOP_RAM_DATA, data)\n#define AscGetChipIFC(port)               (uchar)inp((port)+IOP_REG_IFC)\n#define AscSetChipIFC(port, data)          outp((port)+IOP_REG_IFC, data)\n#define AscGetChipStatus(port)            (ASC_CS_TYPE)inpw((port)+IOP_STATUS)\n#define AscSetChipStatus(port, cs_val)    outpw((port)+IOP_STATUS, cs_val)\n#define AscGetChipControl(port)           (uchar)inp((port)+IOP_CTRL)\n#define AscSetChipControl(port, cc_val)   outp((port)+IOP_CTRL, cc_val)\n#define AscGetChipSyn(port)               (uchar)inp((port)+IOP_SYN_OFFSET)\n#define AscSetChipSyn(port, data)         outp((port)+IOP_SYN_OFFSET, data)\n#define AscSetPCAddr(port, data)          outpw((port)+IOP_REG_PC, data)\n#define AscGetPCAddr(port)                (ushort)inpw((port)+IOP_REG_PC)\n#define AscIsIntPending(port)             (AscGetChipStatus(port) & (CSW_INT_PENDING | CSW_SCSI_RESET_LATCH))\n#define AscGetChipScsiID(port)            ((AscGetChipCfgLsw(port) >> 8) & ASC_MAX_TID)\n#define AscGetExtraControl(port)          (uchar)inp((port)+IOP_EXTRA_CONTROL)\n#define AscSetExtraControl(port, data)    outp((port)+IOP_EXTRA_CONTROL, data)\n#define AscReadChipAX(port)               (ushort)inpw((port)+IOP_REG_AX)\n#define AscWriteChipAX(port, data)        outpw((port)+IOP_REG_AX, data)\n#define AscReadChipIX(port)               (uchar)inp((port)+IOP_REG_IX)\n#define AscWriteChipIX(port, data)        outp((port)+IOP_REG_IX, data)\n#define AscReadChipIH(port)               (ushort)inpw((port)+IOP_REG_IH)\n#define AscWriteChipIH(port, data)        outpw((port)+IOP_REG_IH, data)\n#define AscReadChipQP(port)               (uchar)inp((port)+IOP_REG_QP)\n#define AscWriteChipQP(port, data)        outp((port)+IOP_REG_QP, data)\n#define AscReadChipFIFO_L(port)           (ushort)inpw((port)+IOP_REG_FIFO_L)\n#define AscWriteChipFIFO_L(port, data)    outpw((port)+IOP_REG_FIFO_L, data)\n#define AscReadChipFIFO_H(port)           (ushort)inpw((port)+IOP_REG_FIFO_H)\n#define AscWriteChipFIFO_H(port, data)    outpw((port)+IOP_REG_FIFO_H, data)\n#define AscReadChipDmaSpeed(port)         (uchar)inp((port)+IOP_DMA_SPEED)\n#define AscWriteChipDmaSpeed(port, data)  outp((port)+IOP_DMA_SPEED, data)\n#define AscReadChipDA0(port)              (ushort)inpw((port)+IOP_REG_DA0)\n#define AscWriteChipDA0(port)             outpw((port)+IOP_REG_DA0, data)\n#define AscReadChipDA1(port)              (ushort)inpw((port)+IOP_REG_DA1)\n#define AscWriteChipDA1(port)             outpw((port)+IOP_REG_DA1, data)\n#define AscReadChipDC0(port)              (ushort)inpw((port)+IOP_REG_DC0)\n#define AscWriteChipDC0(port)             outpw((port)+IOP_REG_DC0, data)\n#define AscReadChipDC1(port)              (ushort)inpw((port)+IOP_REG_DC1)\n#define AscWriteChipDC1(port)             outpw((port)+IOP_REG_DC1, data)\n#define AscReadChipDvcID(port)            (uchar)inp((port)+IOP_REG_ID)\n#define AscWriteChipDvcID(port, data)     outp((port)+IOP_REG_ID, data)\n\n#define AdvPortAddr  void __iomem *\t \n\n \n#define ADV_MEM_READB(addr) readb(addr)\n#define ADV_MEM_READW(addr) readw(addr)\n#define ADV_MEM_WRITEB(addr, byte) writeb(byte, addr)\n#define ADV_MEM_WRITEW(addr, word) writew(word, addr)\n#define ADV_MEM_WRITEDW(addr, dword) writel(dword, addr)\n\n \n#define ADV_TOT_SG_BLOCK        ASC_DEF_MAX_HOST_QNG\n\n \n#define ADV_MAX_SG_LIST         255\n#define NO_OF_SG_PER_BLOCK              15\n\n#define ADV_EEP_DVC_CFG_BEGIN           (0x00)\n#define ADV_EEP_DVC_CFG_END             (0x15)\n#define ADV_EEP_DVC_CTL_BEGIN           (0x16)\t \n#define ADV_EEP_MAX_WORD_ADDR           (0x1E)\n\n#define ADV_EEP_DELAY_MS                100\n\n#define ADV_EEPROM_BIG_ENDIAN          0x8000\t \n#define ADV_EEPROM_BIOS_ENABLE         0x4000\t \n \n#define ADV_EEPROM_TERM_POL            0x2000\t \n#define ADV_EEPROM_CIS_LD              0x2000\t \n \n#define ADV_EEPROM_INTAB               0x0800\t \n\ntypedef struct adveep_3550_config {\n\t \n\n\tushort cfg_lsw;\t\t \n\t \n\t \n\t \n\tushort cfg_msw;\t\t \n\tushort disc_enable;\t \n\tushort wdtr_able;\t \n\tushort sdtr_able;\t \n\tushort start_motor;\t \n\tushort tagqng_able;\t \n\tushort bios_scan;\t \n\tushort scam_tolerant;\t \n\n\tuchar adapter_scsi_id;\t \n\tuchar bios_boot_delay;\t \n\n\tuchar scsi_reset_delay;\t \n\tuchar bios_id_lun;\t \n\t \n\t \n\n\tuchar termination;\t \n\t \n\t \n\t \n\t \n\n\tuchar reserved1;\t \n\n\tushort bios_ctrl;\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\tushort ultra_able;\t \n\tushort reserved2;\t \n\tuchar max_host_qng;\t \n\tuchar max_dvc_qng;\t \n\tushort dvc_cntl;\t \n\tushort bug_fix;\t\t \n\tushort serial_number_word1;\t \n\tushort serial_number_word2;\t \n\tushort serial_number_word3;\t \n\tushort check_sum;\t \n\tuchar oem_name[16];\t \n\tushort dvc_err_code;\t \n\tushort adv_err_code;\t \n\tushort adv_err_addr;\t \n\tushort saved_dvc_err_code;\t \n\tushort saved_adv_err_code;\t \n\tushort saved_adv_err_addr;\t \n\tushort num_of_err;\t \n} ADVEEP_3550_CONFIG;\n\ntypedef struct adveep_38C0800_config {\n\t \n\n\tushort cfg_lsw;\t\t \n\t \n\t \n\t \n\tushort cfg_msw;\t\t \n\tushort disc_enable;\t \n\tushort wdtr_able;\t \n\tushort sdtr_speed1;\t \n\tushort start_motor;\t \n\tushort tagqng_able;\t \n\tushort bios_scan;\t \n\tushort scam_tolerant;\t \n\n\tuchar adapter_scsi_id;\t \n\tuchar bios_boot_delay;\t \n\n\tuchar scsi_reset_delay;\t \n\tuchar bios_id_lun;\t \n\t \n\t \n\n\tuchar termination_se;\t \n\t \n\t \n\t \n\t \n\n\tuchar termination_lvd;\t \n\t \n\t \n\t \n\t \n\n\tushort bios_ctrl;\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\tushort sdtr_speed2;\t \n\tushort sdtr_speed3;\t \n\tuchar max_host_qng;\t \n\tuchar max_dvc_qng;\t \n\tushort dvc_cntl;\t \n\tushort sdtr_speed4;\t \n\tushort serial_number_word1;\t \n\tushort serial_number_word2;\t \n\tushort serial_number_word3;\t \n\tushort check_sum;\t \n\tuchar oem_name[16];\t \n\tushort dvc_err_code;\t \n\tushort adv_err_code;\t \n\tushort adv_err_addr;\t \n\tushort saved_dvc_err_code;\t \n\tushort saved_adv_err_code;\t \n\tushort saved_adv_err_addr;\t \n\tushort reserved36;\t \n\tushort reserved37;\t \n\tushort reserved38;\t \n\tushort reserved39;\t \n\tushort reserved40;\t \n\tushort reserved41;\t \n\tushort reserved42;\t \n\tushort reserved43;\t \n\tushort reserved44;\t \n\tushort reserved45;\t \n\tushort reserved46;\t \n\tushort reserved47;\t \n\tushort reserved48;\t \n\tushort reserved49;\t \n\tushort reserved50;\t \n\tushort reserved51;\t \n\tushort reserved52;\t \n\tushort reserved53;\t \n\tushort reserved54;\t \n\tushort reserved55;\t \n\tushort cisptr_lsw;\t \n\tushort cisprt_msw;\t \n\tushort subsysvid;\t \n\tushort subsysid;\t \n\tushort reserved60;\t \n\tushort reserved61;\t \n\tushort reserved62;\t \n\tushort reserved63;\t \n} ADVEEP_38C0800_CONFIG;\n\ntypedef struct adveep_38C1600_config {\n\t \n\n\tushort cfg_lsw;\t\t \n\t \n\t \n\t \n\t \n\t \n\tushort cfg_msw;\t\t \n\tushort disc_enable;\t \n\tushort wdtr_able;\t \n\tushort sdtr_speed1;\t \n\tushort start_motor;\t \n\tushort tagqng_able;\t \n\tushort bios_scan;\t \n\tushort scam_tolerant;\t \n\n\tuchar adapter_scsi_id;\t \n\tuchar bios_boot_delay;\t \n\n\tuchar scsi_reset_delay;\t \n\tuchar bios_id_lun;\t \n\t \n\t \n\n\tuchar termination_se;\t \n\t \n\t \n\t \n\t \n\n\tuchar termination_lvd;\t \n\t \n\t \n\t \n\t \n\n\tushort bios_ctrl;\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\tushort sdtr_speed2;\t \n\tushort sdtr_speed3;\t \n\tuchar max_host_qng;\t \n\tuchar max_dvc_qng;\t \n\tushort dvc_cntl;\t \n\tushort sdtr_speed4;\t \n\tushort serial_number_word1;\t \n\tushort serial_number_word2;\t \n\tushort serial_number_word3;\t \n\tushort check_sum;\t \n\tuchar oem_name[16];\t \n\tushort dvc_err_code;\t \n\tushort adv_err_code;\t \n\tushort adv_err_addr;\t \n\tushort saved_dvc_err_code;\t \n\tushort saved_adv_err_code;\t \n\tushort saved_adv_err_addr;\t \n\tushort reserved36;\t \n\tushort reserved37;\t \n\tushort reserved38;\t \n\tushort reserved39;\t \n\tushort reserved40;\t \n\tushort reserved41;\t \n\tushort reserved42;\t \n\tushort reserved43;\t \n\tushort reserved44;\t \n\tushort reserved45;\t \n\tushort reserved46;\t \n\tushort reserved47;\t \n\tushort reserved48;\t \n\tushort reserved49;\t \n\tushort reserved50;\t \n\tushort reserved51;\t \n\tushort reserved52;\t \n\tushort reserved53;\t \n\tushort reserved54;\t \n\tushort reserved55;\t \n\tushort cisptr_lsw;\t \n\tushort cisprt_msw;\t \n\tushort subsysvid;\t \n\tushort subsysid;\t \n\tushort reserved60;\t \n\tushort reserved61;\t \n\tushort reserved62;\t \n\tushort reserved63;\t \n} ADVEEP_38C1600_CONFIG;\n\n \n#define ASC_EEP_CMD_DONE             0x0200\n\n \n#define BIOS_CTRL_BIOS               0x0001\n#define BIOS_CTRL_EXTENDED_XLAT      0x0002\n#define BIOS_CTRL_GT_2_DISK          0x0004\n#define BIOS_CTRL_BIOS_REMOVABLE     0x0008\n#define BIOS_CTRL_BOOTABLE_CD        0x0010\n#define BIOS_CTRL_MULTIPLE_LUN       0x0040\n#define BIOS_CTRL_DISPLAY_MSG        0x0080\n#define BIOS_CTRL_NO_SCAM            0x0100\n#define BIOS_CTRL_RESET_SCSI_BUS     0x0200\n#define BIOS_CTRL_INIT_VERBOSE       0x0800\n#define BIOS_CTRL_SCSI_PARITY        0x1000\n#define BIOS_CTRL_AIPP_DIS           0x2000\n\n#define ADV_3550_MEMSIZE   0x2000\t \n\n#define ADV_38C0800_MEMSIZE  0x4000\t \n\n \n#define ADV_38C1600_MEMSIZE  0x4000\t \n\n \n#define IOPB_INTR_STATUS_REG    0x00\n#define IOPB_CHIP_ID_1          0x01\n#define IOPB_INTR_ENABLES       0x02\n#define IOPB_CHIP_TYPE_REV      0x03\n#define IOPB_RES_ADDR_4         0x04\n#define IOPB_RES_ADDR_5         0x05\n#define IOPB_RAM_DATA           0x06\n#define IOPB_RES_ADDR_7         0x07\n#define IOPB_FLAG_REG           0x08\n#define IOPB_RES_ADDR_9         0x09\n#define IOPB_RISC_CSR           0x0A\n#define IOPB_RES_ADDR_B         0x0B\n#define IOPB_RES_ADDR_C         0x0C\n#define IOPB_RES_ADDR_D         0x0D\n#define IOPB_SOFT_OVER_WR       0x0E\n#define IOPB_RES_ADDR_F         0x0F\n#define IOPB_MEM_CFG            0x10\n#define IOPB_RES_ADDR_11        0x11\n#define IOPB_GPIO_DATA          0x12\n#define IOPB_RES_ADDR_13        0x13\n#define IOPB_FLASH_PAGE         0x14\n#define IOPB_RES_ADDR_15        0x15\n#define IOPB_GPIO_CNTL          0x16\n#define IOPB_RES_ADDR_17        0x17\n#define IOPB_FLASH_DATA         0x18\n#define IOPB_RES_ADDR_19        0x19\n#define IOPB_RES_ADDR_1A        0x1A\n#define IOPB_RES_ADDR_1B        0x1B\n#define IOPB_RES_ADDR_1C        0x1C\n#define IOPB_RES_ADDR_1D        0x1D\n#define IOPB_RES_ADDR_1E        0x1E\n#define IOPB_RES_ADDR_1F        0x1F\n#define IOPB_DMA_CFG0           0x20\n#define IOPB_DMA_CFG1           0x21\n#define IOPB_TICKLE             0x22\n#define IOPB_DMA_REG_WR         0x23\n#define IOPB_SDMA_STATUS        0x24\n#define IOPB_SCSI_BYTE_CNT      0x25\n#define IOPB_HOST_BYTE_CNT      0x26\n#define IOPB_BYTE_LEFT_TO_XFER  0x27\n#define IOPB_BYTE_TO_XFER_0     0x28\n#define IOPB_BYTE_TO_XFER_1     0x29\n#define IOPB_BYTE_TO_XFER_2     0x2A\n#define IOPB_BYTE_TO_XFER_3     0x2B\n#define IOPB_ACC_GRP            0x2C\n#define IOPB_RES_ADDR_2D        0x2D\n#define IOPB_DEV_ID             0x2E\n#define IOPB_RES_ADDR_2F        0x2F\n#define IOPB_SCSI_DATA          0x30\n#define IOPB_RES_ADDR_31        0x31\n#define IOPB_RES_ADDR_32        0x32\n#define IOPB_SCSI_DATA_HSHK     0x33\n#define IOPB_SCSI_CTRL          0x34\n#define IOPB_RES_ADDR_35        0x35\n#define IOPB_RES_ADDR_36        0x36\n#define IOPB_RES_ADDR_37        0x37\n#define IOPB_RAM_BIST           0x38\n#define IOPB_PLL_TEST           0x39\n#define IOPB_PCI_INT_CFG        0x3A\n#define IOPB_RES_ADDR_3B        0x3B\n#define IOPB_RFIFO_CNT          0x3C\n#define IOPB_RES_ADDR_3D        0x3D\n#define IOPB_RES_ADDR_3E        0x3E\n#define IOPB_RES_ADDR_3F        0x3F\n\n \n#define IOPW_CHIP_ID_0          0x00\t \n#define IOPW_CTRL_REG           0x02\t \n#define IOPW_RAM_ADDR           0x04\t \n#define IOPW_RAM_DATA           0x06\t \n#define IOPW_RES_ADDR_08        0x08\n#define IOPW_RISC_CSR           0x0A\t \n#define IOPW_SCSI_CFG0          0x0C\t \n#define IOPW_SCSI_CFG1          0x0E\t \n#define IOPW_RES_ADDR_10        0x10\n#define IOPW_SEL_MASK           0x12\t \n#define IOPW_RES_ADDR_14        0x14\n#define IOPW_FLASH_ADDR         0x16\t \n#define IOPW_RES_ADDR_18        0x18\n#define IOPW_EE_CMD             0x1A\t \n#define IOPW_EE_DATA            0x1C\t \n#define IOPW_SFIFO_CNT          0x1E\t \n#define IOPW_RES_ADDR_20        0x20\n#define IOPW_Q_BASE             0x22\t \n#define IOPW_QP                 0x24\t \n#define IOPW_IX                 0x26\t \n#define IOPW_SP                 0x28\t \n#define IOPW_PC                 0x2A\t \n#define IOPW_RES_ADDR_2C        0x2C\n#define IOPW_RES_ADDR_2E        0x2E\n#define IOPW_SCSI_DATA          0x30\t \n#define IOPW_SCSI_DATA_HSHK     0x32\t \n#define IOPW_SCSI_CTRL          0x34\t \n#define IOPW_HSHK_CFG           0x36\t \n#define IOPW_SXFR_STATUS        0x36\t \n#define IOPW_SXFR_CNTL          0x38\t \n#define IOPW_SXFR_CNTH          0x3A\t \n#define IOPW_RES_ADDR_3C        0x3C\n#define IOPW_RFIFO_DATA         0x3E\t \n\n \n#define IOPDW_RES_ADDR_0         0x00\n#define IOPDW_RAM_DATA           0x04\n#define IOPDW_RES_ADDR_8         0x08\n#define IOPDW_RES_ADDR_C         0x0C\n#define IOPDW_RES_ADDR_10        0x10\n#define IOPDW_COMMA              0x14\n#define IOPDW_COMMB              0x18\n#define IOPDW_RES_ADDR_1C        0x1C\n#define IOPDW_SDMA_ADDR0         0x20\n#define IOPDW_SDMA_ADDR1         0x24\n#define IOPDW_SDMA_COUNT         0x28\n#define IOPDW_SDMA_ERROR         0x2C\n#define IOPDW_RDMA_ADDR0         0x30\n#define IOPDW_RDMA_ADDR1         0x34\n#define IOPDW_RDMA_COUNT         0x38\n#define IOPDW_RDMA_ERROR         0x3C\n\n#define ADV_CHIP_ID_BYTE         0x25\n#define ADV_CHIP_ID_WORD         0x04C1\n\n#define ADV_INTR_ENABLE_HOST_INTR                   0x01\n#define ADV_INTR_ENABLE_SEL_INTR                    0x02\n#define ADV_INTR_ENABLE_DPR_INTR                    0x04\n#define ADV_INTR_ENABLE_RTA_INTR                    0x08\n#define ADV_INTR_ENABLE_RMA_INTR                    0x10\n#define ADV_INTR_ENABLE_RST_INTR                    0x20\n#define ADV_INTR_ENABLE_DPE_INTR                    0x40\n#define ADV_INTR_ENABLE_GLOBAL_INTR                 0x80\n\n#define ADV_INTR_STATUS_INTRA            0x01\n#define ADV_INTR_STATUS_INTRB            0x02\n#define ADV_INTR_STATUS_INTRC            0x04\n\n#define ADV_RISC_CSR_STOP           (0x0000)\n#define ADV_RISC_TEST_COND          (0x2000)\n#define ADV_RISC_CSR_RUN            (0x4000)\n#define ADV_RISC_CSR_SINGLE_STEP    (0x8000)\n\n#define ADV_CTRL_REG_HOST_INTR      0x0100\n#define ADV_CTRL_REG_SEL_INTR       0x0200\n#define ADV_CTRL_REG_DPR_INTR       0x0400\n#define ADV_CTRL_REG_RTA_INTR       0x0800\n#define ADV_CTRL_REG_RMA_INTR       0x1000\n#define ADV_CTRL_REG_RES_BIT14      0x2000\n#define ADV_CTRL_REG_DPE_INTR       0x4000\n#define ADV_CTRL_REG_POWER_DONE     0x8000\n#define ADV_CTRL_REG_ANY_INTR       0xFF00\n\n#define ADV_CTRL_REG_CMD_RESET             0x00C6\n#define ADV_CTRL_REG_CMD_WR_IO_REG         0x00C5\n#define ADV_CTRL_REG_CMD_RD_IO_REG         0x00C4\n#define ADV_CTRL_REG_CMD_WR_PCI_CFG_SPACE  0x00C3\n#define ADV_CTRL_REG_CMD_RD_PCI_CFG_SPACE  0x00C2\n\n#define ADV_TICKLE_NOP                      0x00\n#define ADV_TICKLE_A                        0x01\n#define ADV_TICKLE_B                        0x02\n#define ADV_TICKLE_C                        0x03\n\n#define AdvIsIntPending(port) \\\n    (AdvReadWordRegister(port, IOPW_CTRL_REG) & ADV_CTRL_REG_HOST_INTR)\n\n \n#define TIMER_MODEAB    0xC000\t \n#define PARITY_EN       0x2000\t \n#define EVEN_PARITY     0x1000\t \n#define WD_LONG         0x0800\t \n#define QUEUE_128       0x0400\t \n#define PRIM_MODE       0x0100\t \n#define SCAM_EN         0x0080\t \n#define SEL_TMO_LONG    0x0040\t \n#define CFRM_ID         0x0020\t \n#define OUR_ID_EN       0x0010\t \n#define OUR_ID          0x000F\t \n\n \n#define BIG_ENDIAN      0x8000\t \n#define TERM_POL        0x2000\t \n#define SLEW_RATE       0x1000\t \n#define FILTER_SEL      0x0C00\t \n#define  FLTR_DISABLE    0x0000\t \n#define  FLTR_11_TO_20NS 0x0800\t \n#define  FLTR_21_TO_39NS 0x0C00\t \n#define ACTIVE_DBL      0x0200\t \n#define DIFF_MODE       0x0100\t \n#define DIFF_SENSE      0x0080\t \n#define TERM_CTL_SEL    0x0040\t \n#define TERM_CTL        0x0030\t \n#define  TERM_CTL_H      0x0020\t \n#define  TERM_CTL_L      0x0010\t \n#define CABLE_DETECT    0x000F\t \n\n \n#define DIS_TERM_DRV    0x4000\t \n#define HVD_LVD_SE      0x1C00\t \n#define  HVD             0x1000\t \n#define  LVD             0x0800\t \n#define  SE              0x0400\t \n#define TERM_LVD        0x00C0\t \n#define  TERM_LVD_HI     0x0080\t \n#define  TERM_LVD_LO     0x0040\t \n#define TERM_SE         0x0030\t \n#define  TERM_SE_HI      0x0020\t \n#define  TERM_SE_LO      0x0010\t \n#define C_DET_LVD       0x000C\t \n#define  C_DET3          0x0008\t \n#define  C_DET2          0x0004\t \n#define C_DET_SE        0x0003\t \n#define  C_DET1          0x0002\t \n#define  C_DET0          0x0001\t \n\n#define CABLE_ILLEGAL_A 0x7\n     \n\n#define CABLE_ILLEGAL_B 0xB\n     \n\n \n#define BIOS_EN         0x40\t \n#define FAST_EE_CLK     0x20\t \n#define RAM_SZ          0x1C\t \n#define  RAM_SZ_2KB      0x00\t \n#define  RAM_SZ_4KB      0x04\t \n#define  RAM_SZ_8KB      0x08\t \n#define  RAM_SZ_16KB     0x0C\t \n#define  RAM_SZ_32KB     0x10\t \n#define  RAM_SZ_64KB     0x14\t \n\n \n#define BC_THRESH_ENB   0x80\t \n#define FIFO_THRESH     0x70\t \n#define  FIFO_THRESH_16B  0x00\t \n#define  FIFO_THRESH_32B  0x20\t \n#define  FIFO_THRESH_48B  0x30\t \n#define  FIFO_THRESH_64B  0x40\t \n#define  FIFO_THRESH_80B  0x50\t \n#define  FIFO_THRESH_96B  0x60\t \n#define  FIFO_THRESH_112B 0x70\t \n#define START_CTL       0x0C\t \n#define  START_CTL_TH    0x00\t \n#define  START_CTL_ID    0x04\t \n#define  START_CTL_THID  0x08\t \n#define  START_CTL_EMFU  0x0C\t \n#define READ_CMD        0x03\t \n#define  READ_CMD_MR     0x00\t \n#define  READ_CMD_MRL    0x02\t \n#define  READ_CMD_MRM    0x03\t \n\n \n#define RAM_TEST_MODE         0x80\n#define PRE_TEST_MODE         0x40\n#define NORMAL_MODE           0x00\n#define RAM_TEST_DONE         0x10\n#define RAM_TEST_STATUS       0x0F\n#define  RAM_TEST_HOST_ERROR   0x08\n#define  RAM_TEST_INTRAM_ERROR 0x04\n#define  RAM_TEST_RISC_ERROR   0x02\n#define  RAM_TEST_SCSI_ERROR   0x01\n#define  RAM_TEST_SUCCESS      0x00\n#define PRE_TEST_VALUE        0x05\n#define NORMAL_VALUE          0x00\n\n \n\n#define INTAB_LD        0x80\t \n\n \n#define TOTEMPOLE       0x02\n\n \n#define INTAB           0x01\n\n \n#define ADV_TRUE        1\n#define ADV_FALSE       0\n#define ADV_SUCCESS     1\n#define ADV_BUSY        0\n#define ADV_ERROR       (-1)\n\n \n#define ASC_WARN_BUSRESET_ERROR         0x0001\t \n#define ASC_WARN_EEPROM_CHKSUM          0x0002\t \n#define ASC_WARN_EEPROM_TERMINATION     0x0004\t \n#define ASC_WARN_ERROR                  0xFFFF\t \n\n#define ADV_MAX_TID                     15\t \n#define ADV_MAX_LUN                     7\t \n\n \n#define ASC_MC_CODE_BEGIN_ADDR          0x0028\t \n#define ASC_MC_CODE_END_ADDR            0x002A\t \n#define ASC_MC_CODE_CHK_SUM             0x002C\t \n#define ASC_MC_VERSION_DATE             0x0038\t \n#define ASC_MC_VERSION_NUM              0x003A\t \n#define ASC_MC_BIOSMEM                  0x0040\t \n#define ASC_MC_BIOSLEN                  0x0050\t \n#define ASC_MC_BIOS_SIGNATURE           0x0058\t \n#define ASC_MC_BIOS_VERSION             0x005A\t \n#define ASC_MC_SDTR_SPEED1              0x0090\t \n#define ASC_MC_SDTR_SPEED2              0x0092\t \n#define ASC_MC_SDTR_SPEED3              0x0094\t \n#define ASC_MC_SDTR_SPEED4              0x0096\t \n#define ASC_MC_CHIP_TYPE                0x009A\n#define ASC_MC_INTRB_CODE               0x009B\n#define ASC_MC_WDTR_ABLE                0x009C\n#define ASC_MC_SDTR_ABLE                0x009E\n#define ASC_MC_TAGQNG_ABLE              0x00A0\n#define ASC_MC_DISC_ENABLE              0x00A2\n#define ASC_MC_IDLE_CMD_STATUS          0x00A4\n#define ASC_MC_IDLE_CMD                 0x00A6\n#define ASC_MC_IDLE_CMD_PARAMETER       0x00A8\n#define ASC_MC_DEFAULT_SCSI_CFG0        0x00AC\n#define ASC_MC_DEFAULT_SCSI_CFG1        0x00AE\n#define ASC_MC_DEFAULT_MEM_CFG          0x00B0\n#define ASC_MC_DEFAULT_SEL_MASK         0x00B2\n#define ASC_MC_SDTR_DONE                0x00B6\n#define ASC_MC_NUMBER_OF_QUEUED_CMD     0x00C0\n#define ASC_MC_NUMBER_OF_MAX_CMD        0x00D0\n#define ASC_MC_DEVICE_HSHK_CFG_TABLE    0x0100\n#define ASC_MC_CONTROL_FLAG             0x0122\t \n#define ASC_MC_WDTR_DONE                0x0124\n#define ASC_MC_CAM_MODE_MASK            0x015E\t \n#define ASC_MC_ICQ                      0x0160\n#define ASC_MC_IRQ                      0x0164\n#define ASC_MC_PPR_ABLE                 0x017A\n\n \n#define BIOS_CODESEG    0x54\n#define BIOS_CODELEN    0x56\n#define BIOS_SIGNATURE  0x58\n#define BIOS_VERSION    0x5A\n\n \n#define CONTROL_FLAG_IGNORE_PERR        0x0001\t \n#define CONTROL_FLAG_ENABLE_AIPP        0x0002\t \n\n \n#define HSHK_CFG_WIDE_XFR       0x8000\n#define HSHK_CFG_RATE           0x0F00\n#define HSHK_CFG_OFFSET         0x001F\n\n#define ASC_DEF_MAX_HOST_QNG    0xFD\t \n#define ASC_DEF_MIN_HOST_QNG    0x10\t \n#define ASC_DEF_MAX_DVC_QNG     0x3F\t \n#define ASC_DEF_MIN_DVC_QNG     0x04\t \n\n#define ASC_QC_DATA_CHECK  0x01\t \n#define ASC_QC_DATA_OUT    0x02\t \n#define ASC_QC_START_MOTOR 0x04\t \n#define ASC_QC_NO_OVERRUN  0x08\t \n#define ASC_QC_FREEZE_TIDQ 0x10\t \n\n#define ASC_QSC_NO_DISC     0x01\t \n#define ASC_QSC_NO_TAGMSG   0x02\t \n#define ASC_QSC_NO_SYNC     0x04\t \n#define ASC_QSC_NO_WIDE     0x08\t \n#define ASC_QSC_REDO_DTR    0x10\t \n \n#define ASC_QSC_HEAD_TAG    0x40\t \n#define ASC_QSC_ORDERED_TAG 0x80\t \n\n \ntypedef struct adv_carr_t {\n\t__le32 carr_va;\t \n\t__le32 carr_pa;\t \n\t__le32 areq_vpa;\t \n\t \n\t__le32 next_vpa;\n} ADV_CARR_T;\n\n \n#define ADV_NEXT_VPA_MASK       0xFFFFFFF0\n\n#define ADV_RQ_DONE             0x00000001\n#define ADV_RQ_GOOD             0x00000002\n#define ADV_CQ_STOPPER          0x00000000\n\n#define ADV_GET_CARRP(carrp) ((carrp) & ADV_NEXT_VPA_MASK)\n\n \n#define ADV_CARRIER_COUNT (ASC_DEF_MAX_HOST_QNG + 3)\n\n#define ADV_CARRIER_BUFSIZE \\\n\t(ADV_CARRIER_COUNT * sizeof(ADV_CARR_T))\n\n#define ADV_CHIP_ASC3550          0x01\t \n#define ADV_CHIP_ASC38C0800       0x02\t \n#define ADV_CHIP_ASC38C1600       0x03\t \n\n \ntypedef struct adv_dvc_cfg {\n\tushort disc_enable;\t \n\tuchar chip_version;\t \n\tuchar termination;\t \n\tushort control_flag;\t \n\tushort mcode_date;\t \n\tushort mcode_version;\t \n\tushort serial1;\t\t \n\tushort serial2;\t\t \n\tushort serial3;\t\t \n} ADV_DVC_CFG;\n\nstruct adv_dvc_var;\nstruct adv_scsi_req_q;\n\ntypedef struct adv_sg_block {\n\tuchar reserved1;\n\tuchar reserved2;\n\tuchar reserved3;\n\tuchar sg_cnt;\t\t \n\t__le32 sg_ptr;\t \n\tstruct {\n\t\t__le32 sg_addr;\t \n\t\t__le32 sg_count;\t \n\t} sg_list[NO_OF_SG_PER_BLOCK];\n} ADV_SG_BLOCK;\n\n \ntypedef struct adv_scsi_req_q {\n\tuchar cntl;\t\t \n\tuchar target_cmd;\n\tuchar target_id;\t \n\tuchar target_lun;\t \n\t__le32 data_addr;\t \n\t__le32 data_cnt;\t \n\t__le32 sense_addr;\n\t__le32 carr_pa;\n\tuchar mflag;\n\tuchar sense_len;\n\tuchar cdb_len;\t\t \n\tuchar scsi_cntl;\n\tuchar done_status;\t \n\tuchar scsi_status;\t \n\tuchar host_status;\t \n\tuchar sg_working_ix;\n\tuchar cdb[12];\t\t \n\t__le32 sg_real_addr;\t \n\t__le32 scsiq_rptr;\n\tuchar cdb16[4];\t\t \n\t__le32 scsiq_ptr;\n\t__le32 carr_va;\n\t \n\tu32 srb_tag;\n\tADV_SG_BLOCK *sg_list_ptr;\t \n} ADV_SCSI_REQ_Q;\n\n \ntypedef struct adv_sgblk {\n\tADV_SG_BLOCK sg_block;\t \n\tdma_addr_t sg_addr;\t \n\tstruct adv_sgblk *next_sgblkp;\t \n} adv_sgblk_t;\n\ntypedef struct adv_req {\n\tADV_SCSI_REQ_Q scsi_req_q;\t \n\tuchar align[24];\t \n\tstruct scsi_cmnd *cmndp;\t \n\tdma_addr_t req_addr;\n\tadv_sgblk_t *sgblkp;\t \n} adv_req_t __aligned(32);\n\n \ntypedef struct adv_dvc_var {\n\tAdvPortAddr iop_base;\t \n\tushort err_code;\t \n\tushort bios_ctrl;\t \n\tushort wdtr_able;\t \n\tushort sdtr_able;\t \n\tushort ultra_able;\t \n\tushort sdtr_speed1;\t \n\tushort sdtr_speed2;\t \n\tushort sdtr_speed3;\t \n\tushort sdtr_speed4;\t \n\tushort tagqng_able;\t \n\tushort ppr_able;\t \n\tuchar max_dvc_qng;\t \n\tushort start_motor;\t \n\tuchar scsi_reset_wait;\t \n\tuchar chip_no;\t\t \n\tuchar max_host_qng;\t \n\tushort no_scam;\t\t \n\tstruct asc_board *drv_ptr;\t \n\tuchar chip_scsi_id;\t \n\tuchar chip_type;\n\tuchar bist_err_code;\n\tADV_CARR_T *carrier;\n\tADV_CARR_T *carr_freelist;\t \n\tdma_addr_t carrier_addr;\n\tADV_CARR_T *icq_sp;\t \n\tADV_CARR_T *irq_sp;\t \n\tushort carr_pending_cnt;\t \n\t \n\tADV_DVC_CFG *cfg;\t \n} ADV_DVC_VAR;\n\n \n#define IDLE_CMD_COMPLETED           0\n#define IDLE_CMD_STOP_CHIP           0x0001\n#define IDLE_CMD_STOP_CHIP_SEND_INT  0x0002\n#define IDLE_CMD_SEND_INT            0x0004\n#define IDLE_CMD_ABORT               0x0008\n#define IDLE_CMD_DEVICE_RESET        0x0010\n#define IDLE_CMD_SCSI_RESET_START    0x0020\t \n#define IDLE_CMD_SCSI_RESET_END      0x0040\t \n#define IDLE_CMD_SCSIREQ             0x0080\n\n#define IDLE_CMD_STATUS_SUCCESS      0x0001\n#define IDLE_CMD_STATUS_FAILURE      0x0002\n\n \n#define ADV_NOWAIT     0x01\n\n \n#define SCSI_WAIT_100_MSEC           100UL\t \n#define SCSI_US_PER_MSEC             1000\t \n#define SCSI_MAX_RETRY               10\t \n\n#define ADV_ASYNC_RDMA_FAILURE          0x01\t \n#define ADV_ASYNC_SCSI_BUS_RESET_DET    0x02\t \n#define ADV_ASYNC_CARRIER_READY_FAILURE 0x03\t \n#define ADV_RDMA_IN_CARR_AND_Q_INVALID  0x04\t \n\n#define ADV_HOST_SCSI_BUS_RESET      0x80\t \n\n \n#define AdvReadByteRegister(iop_base, reg_off) \\\n     (ADV_MEM_READB((iop_base) + (reg_off)))\n\n \n#define AdvWriteByteRegister(iop_base, reg_off, byte) \\\n     (ADV_MEM_WRITEB((iop_base) + (reg_off), (byte)))\n\n \n#define AdvReadWordRegister(iop_base, reg_off) \\\n     (ADV_MEM_READW((iop_base) + (reg_off)))\n\n \n#define AdvWriteWordRegister(iop_base, reg_off, word) \\\n     (ADV_MEM_WRITEW((iop_base) + (reg_off), (word)))\n\n \n#define AdvWriteDWordRegister(iop_base, reg_off, dword) \\\n     (ADV_MEM_WRITEDW((iop_base) + (reg_off), (dword)))\n\n \n#define AdvReadByteLram(iop_base, addr, byte) \\\ndo { \\\n    ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)); \\\n    (byte) = ADV_MEM_READB((iop_base) + IOPB_RAM_DATA); \\\n} while (0)\n\n \n#define AdvWriteByteLram(iop_base, addr, byte) \\\n    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \\\n     ADV_MEM_WRITEB((iop_base) + IOPB_RAM_DATA, (byte)))\n\n \n#define AdvReadWordLram(iop_base, addr, word) \\\ndo { \\\n    ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)); \\\n    (word) = (ADV_MEM_READW((iop_base) + IOPW_RAM_DATA)); \\\n} while (0)\n\n \n#define AdvWriteWordLram(iop_base, addr, word) \\\n    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \\\n     ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, (word)))\n\n \n \n#define AdvWriteDWordLramNoSwap(iop_base, addr, dword) \\\n    ((ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \\\n      ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, \\\n                     cpu_to_le16((ushort) ((dword) & 0xFFFF)))), \\\n     (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr) + 2), \\\n      ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, \\\n                     cpu_to_le16((ushort) ((dword >> 16) & 0xFFFF)))))\n\n \n#define AdvReadWordAutoIncLram(iop_base) \\\n     (ADV_MEM_READW((iop_base) + IOPW_RAM_DATA))\n\n \n#define AdvWriteWordAutoIncLram(iop_base, word) \\\n     (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, (word)))\n\n \n#define AdvFindSignature(iop_base) \\\n    (((AdvReadByteRegister((iop_base), IOPB_CHIP_ID_1) == \\\n    ADV_CHIP_ID_BYTE) && \\\n     (AdvReadWordRegister((iop_base), IOPW_CHIP_ID_0) == \\\n    ADV_CHIP_ID_WORD)) ?  ADV_TRUE : ADV_FALSE)\n\n \n#define AdvGetChipVersion(iop_base, bus_type) \\\n    AdvReadByteRegister((iop_base), IOPB_CHIP_TYPE_REV)\n\n \n#define AdvAbortQueue(asc_dvc, srb_tag) \\\n     AdvSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_ABORT, \\\n\t\t    (ADV_DCNT) (srb_tag))\n\n \n#define AdvResetDevice(asc_dvc, target_id) \\\n     AdvSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_DEVICE_RESET,\t\\\n\t\t    (ADV_DCNT) (target_id))\n\n \n#define ADV_SCSI_BIT_ID_TYPE   ushort\n\n \n#define ADV_SCAN_LUN           0x01\n#define ADV_CAPINFO_NOLUN      0x02\n\n \n#define ADV_TID_TO_TIDMASK(tid)   (0x01 << ((tid) & ADV_MAX_TID))\n\n \n\n#define QD_NO_STATUS         0x00\t \n#define QD_NO_ERROR          0x01\n#define QD_ABORTED_BY_HOST   0x02\n#define QD_WITH_ERROR        0x04\n\n#define QHSTA_NO_ERROR              0x00\n#define QHSTA_M_SEL_TIMEOUT         0x11\n#define QHSTA_M_DATA_OVER_RUN       0x12\n#define QHSTA_M_UNEXPECTED_BUS_FREE 0x13\n#define QHSTA_M_QUEUE_ABORTED       0x15\n#define QHSTA_M_SXFR_SDMA_ERR       0x16\t \n#define QHSTA_M_SXFR_SXFR_PERR      0x17\t \n#define QHSTA_M_RDMA_PERR           0x18\t \n#define QHSTA_M_SXFR_OFF_UFLW       0x19\t \n#define QHSTA_M_SXFR_OFF_OFLW       0x20\t \n#define QHSTA_M_SXFR_WD_TMO         0x21\t \n#define QHSTA_M_SXFR_DESELECTED     0x22\t \n \n#define QHSTA_M_SXFR_XFR_OFLW       0x12\t \n#define QHSTA_M_SXFR_XFR_PH_ERR     0x24\t \n#define QHSTA_M_SXFR_UNKNOWN_ERROR  0x25\t \n#define QHSTA_M_SCSI_BUS_RESET      0x30\t \n#define QHSTA_M_SCSI_BUS_RESET_UNSOL 0x31\t \n#define QHSTA_M_BUS_DEVICE_RESET    0x32\t \n#define QHSTA_M_DIRECTION_ERR       0x35\t \n#define QHSTA_M_DIRECTION_ERR_HUNG  0x36\t \n#define QHSTA_M_WTM_TIMEOUT         0x41\n#define QHSTA_M_BAD_CMPL_STATUS_IN  0x42\n#define QHSTA_M_NO_AUTO_REQ_SENSE   0x43\n#define QHSTA_M_AUTO_REQ_SENSE_FAIL 0x44\n#define QHSTA_M_INVALID_DEVICE      0x45\t \n#define QHSTA_M_FROZEN_TIDQ         0x46\t \n#define QHSTA_M_SGBACKUP_ERROR      0x47\t \n\n \n#define ADV_32BALIGN(addr)     (((ulong) (addr) + 0x1F) & ~0x1F)\n\n \n\n#define ADV_SG_LIST_MAX_BYTE_SIZE \\\n         (sizeof(ADV_SG_BLOCK) * \\\n          ((ADV_MAX_SG_LIST + (NO_OF_SG_PER_BLOCK - 1))/NO_OF_SG_PER_BLOCK))\n\n \n#define ASC_IS_WIDE_BOARD       0x04\t \n\n#define ASC_NARROW_BOARD(boardp) (((boardp)->flags & ASC_IS_WIDE_BOARD) == 0)\n\n#define NO_ISA_DMA              0xff\t \n\n#define ASC_INFO_SIZE           128\t \n\n \n#define ASC_TRUE        1\n#define ASC_FALSE       0\n#define ASC_NOERROR     1\n#define ASC_BUSY        0\n#define ASC_ERROR       (-1)\n\n#define ASC_STATS(shost, counter) ASC_STATS_ADD(shost, counter, 1)\n#ifndef ADVANSYS_STATS\n#define ASC_STATS_ADD(shost, counter, count)\n#else  \n#define ASC_STATS_ADD(shost, counter, count) \\\n\t(((struct asc_board *) shost_priv(shost))->asc_stats.counter += (count))\n#endif  \n\n \n#define ASC_TENTHS(num, den) \\\n    (((10 * ((num)/(den))) > (((num) * 10)/(den))) ? \\\n    0 : ((((num) * 10)/(den)) - (10 * ((num)/(den)))))\n\n \n#define ASC_PRINT(s) \\\n    { \\\n        printk(\"advansys: \"); \\\n        printk(s); \\\n    }\n\n#define ASC_PRINT1(s, a1) \\\n    { \\\n        printk(\"advansys: \"); \\\n        printk((s), (a1)); \\\n    }\n\n#define ASC_PRINT2(s, a1, a2) \\\n    { \\\n        printk(\"advansys: \"); \\\n        printk((s), (a1), (a2)); \\\n    }\n\n#define ASC_PRINT3(s, a1, a2, a3) \\\n    { \\\n        printk(\"advansys: \"); \\\n        printk((s), (a1), (a2), (a3)); \\\n    }\n\n#define ASC_PRINT4(s, a1, a2, a3, a4) \\\n    { \\\n        printk(\"advansys: \"); \\\n        printk((s), (a1), (a2), (a3), (a4)); \\\n    }\n\n#ifndef ADVANSYS_DEBUG\n\n#define ASC_DBG(lvl, s...)\n#define ASC_DBG_PRT_SCSI_HOST(lvl, s)\n#define ASC_DBG_PRT_ASC_SCSI_Q(lvl, scsiqp)\n#define ASC_DBG_PRT_ADV_SCSI_REQ_Q(lvl, scsiqp)\n#define ASC_DBG_PRT_ASC_QDONE_INFO(lvl, qdone)\n#define ADV_DBG_PRT_ADV_SCSI_REQ_Q(lvl, scsiqp)\n#define ASC_DBG_PRT_HEX(lvl, name, start, length)\n#define ASC_DBG_PRT_CDB(lvl, cdb, len)\n#define ASC_DBG_PRT_SENSE(lvl, sense, len)\n#define ASC_DBG_PRT_INQUIRY(lvl, inq, len)\n\n#else  \n\n \n\n#define ASC_DBG(lvl, format, arg...) {\t\t\t\t\t\\\n\tif (asc_dbglvl >= (lvl))\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"%s: %s: \" format, DRV_NAME,\t\t\\\n\t\t\t__func__ , ## arg);\t\t\t\t\\\n}\n\n#define ASC_DBG_PRT_SCSI_HOST(lvl, s) \\\n    { \\\n        if (asc_dbglvl >= (lvl)) { \\\n            asc_prt_scsi_host(s); \\\n        } \\\n    }\n\n#define ASC_DBG_PRT_ASC_SCSI_Q(lvl, scsiqp) \\\n    { \\\n        if (asc_dbglvl >= (lvl)) { \\\n            asc_prt_asc_scsi_q(scsiqp); \\\n        } \\\n    }\n\n#define ASC_DBG_PRT_ASC_QDONE_INFO(lvl, qdone) \\\n    { \\\n        if (asc_dbglvl >= (lvl)) { \\\n            asc_prt_asc_qdone_info(qdone); \\\n        } \\\n    }\n\n#define ASC_DBG_PRT_ADV_SCSI_REQ_Q(lvl, scsiqp) \\\n    { \\\n        if (asc_dbglvl >= (lvl)) { \\\n            asc_prt_adv_scsi_req_q(scsiqp); \\\n        } \\\n    }\n\n#define ASC_DBG_PRT_HEX(lvl, name, start, length) \\\n    { \\\n        if (asc_dbglvl >= (lvl)) { \\\n            asc_prt_hex((name), (start), (length)); \\\n        } \\\n    }\n\n#define ASC_DBG_PRT_CDB(lvl, cdb, len) \\\n        ASC_DBG_PRT_HEX((lvl), \"CDB\", (uchar *) (cdb), (len));\n\n#define ASC_DBG_PRT_SENSE(lvl, sense, len) \\\n        ASC_DBG_PRT_HEX((lvl), \"SENSE\", (uchar *) (sense), (len));\n\n#define ASC_DBG_PRT_INQUIRY(lvl, inq, len) \\\n        ASC_DBG_PRT_HEX((lvl), \"INQUIRY\", (uchar *) (inq), (len));\n#endif  \n\n#ifdef ADVANSYS_STATS\n\n \nstruct asc_stats {\n\t \n\tunsigned int queuecommand;\t \n\tunsigned int reset;\t\t \n\tunsigned int biosparam;\t \n\tunsigned int interrupt;\t \n\tunsigned int callback;\t \n\tunsigned int done;\t\t \n\tunsigned int build_error;\t \n\tunsigned int adv_build_noreq;\t \n\tunsigned int adv_build_nosg;\t \n\t \n\tunsigned int exe_noerror;\t \n\tunsigned int exe_busy;\t \n\tunsigned int exe_error;\t \n\tunsigned int exe_unknown;\t \n\t \n\tunsigned int xfer_cnt;\t \n\tunsigned int xfer_elem;\t \n\tunsigned int xfer_sect;\t \n};\n#endif  \n\n \nstruct asc_board {\n\tstruct device *dev;\n\tstruct Scsi_Host *shost;\n\tuint flags;\t\t \n\tunsigned int irq;\n\tunion {\n\t\tASC_DVC_VAR asc_dvc_var;\t \n\t\tADV_DVC_VAR adv_dvc_var;\t \n\t} dvc_var;\n\tunion {\n\t\tASC_DVC_CFG asc_dvc_cfg;\t \n\t\tADV_DVC_CFG adv_dvc_cfg;\t \n\t} dvc_cfg;\n\tushort asc_n_io_port;\t \n\tADV_SCSI_BIT_ID_TYPE init_tidmask;\t \n\tushort reqcnt[ADV_MAX_TID + 1];\t \n\tADV_SCSI_BIT_ID_TYPE queue_full;\t \n\tushort queue_full_cnt[ADV_MAX_TID + 1];\t \n\tunion {\n\t\tASCEEP_CONFIG asc_eep;\t \n\t\tADVEEP_3550_CONFIG adv_3550_eep;\t \n\t\tADVEEP_38C0800_CONFIG adv_38C0800_eep;\t \n\t\tADVEEP_38C1600_CONFIG adv_38C1600_eep;\t \n\t} eep_config;\n\t \n#ifdef ADVANSYS_STATS\n\tstruct asc_stats asc_stats;\t \n#endif\t\t\t\t \n\t \n\tuchar sdtr_data[ASC_MAX_TID + 1];\t \n\t \n\tvoid __iomem *ioremap_addr;\t \n\tushort ioport;\t\t \n\tadv_req_t *adv_reqp;\t \n\tdma_addr_t adv_reqp_addr;\n\tsize_t adv_reqp_size;\n\tstruct dma_pool *adv_sgblk_pool;\t \n\tushort bios_signature;\t \n\tushort bios_version;\t \n\tushort bios_codeseg;\t \n\tushort bios_codelen;\t \n};\n\n#define asc_dvc_to_board(asc_dvc) container_of(asc_dvc, struct asc_board, \\\n\t\t\t\t\t\t\tdvc_var.asc_dvc_var)\n#define adv_dvc_to_board(adv_dvc) container_of(adv_dvc, struct asc_board, \\\n\t\t\t\t\t\t\tdvc_var.adv_dvc_var)\n#define adv_dvc_to_pdev(adv_dvc) to_pci_dev(adv_dvc_to_board(adv_dvc)->dev)\n\nstruct advansys_cmd {\n\tdma_addr_t dma_handle;\n};\n\nstatic struct advansys_cmd *advansys_cmd(struct scsi_cmnd *cmd)\n{\n\treturn scsi_cmd_priv(cmd);\n}\n\n#ifdef ADVANSYS_DEBUG\nstatic int asc_dbglvl = 3;\n\n \nstatic void asc_prt_asc_dvc_var(ASC_DVC_VAR *h)\n{\n\tprintk(\"ASC_DVC_VAR at addr 0x%lx\\n\", (ulong)h);\n\n\tprintk(\" iop_base 0x%x, err_code 0x%x, dvc_cntl 0x%x, bug_fix_cntl \"\n\t       \"%d,\\n\", h->iop_base, h->err_code, h->dvc_cntl, h->bug_fix_cntl);\n\n\tprintk(\" bus_type %d, init_sdtr 0x%x,\\n\", h->bus_type,\n\t\t(unsigned)h->init_sdtr);\n\n\tprintk(\" sdtr_done 0x%x, use_tagged_qng 0x%x, unit_not_ready 0x%x, \"\n\t       \"chip_no 0x%x,\\n\", (unsigned)h->sdtr_done,\n\t       (unsigned)h->use_tagged_qng, (unsigned)h->unit_not_ready,\n\t       (unsigned)h->chip_no);\n\n\tprintk(\" queue_full_or_busy 0x%x, start_motor 0x%x, scsi_reset_wait \"\n\t       \"%u,\\n\", (unsigned)h->queue_full_or_busy,\n\t       (unsigned)h->start_motor, (unsigned)h->scsi_reset_wait);\n\n\tprintk(\" is_in_int %u, max_total_qng %u, cur_total_qng %u, \"\n\t       \"in_critical_cnt %u,\\n\", (unsigned)h->is_in_int,\n\t       (unsigned)h->max_total_qng, (unsigned)h->cur_total_qng,\n\t       (unsigned)h->in_critical_cnt);\n\n\tprintk(\" last_q_shortage %u, init_state 0x%x, no_scam 0x%x, \"\n\t       \"pci_fix_asyn_xfer 0x%x,\\n\", (unsigned)h->last_q_shortage,\n\t       (unsigned)h->init_state, (unsigned)h->no_scam,\n\t       (unsigned)h->pci_fix_asyn_xfer);\n\n\tprintk(\" cfg 0x%lx\\n\", (ulong)h->cfg);\n}\n\n \nstatic void asc_prt_asc_dvc_cfg(ASC_DVC_CFG *h)\n{\n\tprintk(\"ASC_DVC_CFG at addr 0x%lx\\n\", (ulong)h);\n\n\tprintk(\" can_tagged_qng 0x%x, cmd_qng_enabled 0x%x,\\n\",\n\t       h->can_tagged_qng, h->cmd_qng_enabled);\n\tprintk(\" disc_enable 0x%x, sdtr_enable 0x%x,\\n\",\n\t       h->disc_enable, h->sdtr_enable);\n\n\tprintk(\" chip_scsi_id %d, chip_version %d,\\n\",\n\t       h->chip_scsi_id, h->chip_version);\n\n\tprintk(\" mcode_date 0x%x, mcode_version %d\\n\",\n\t\th->mcode_date, h->mcode_version);\n}\n\n \nstatic void asc_prt_adv_dvc_var(ADV_DVC_VAR *h)\n{\n\tprintk(\" ADV_DVC_VAR at addr 0x%lx\\n\", (ulong)h);\n\n\tprintk(\"  iop_base 0x%lx, err_code 0x%x, ultra_able 0x%x\\n\",\n\t       (ulong)h->iop_base, h->err_code, (unsigned)h->ultra_able);\n\n\tprintk(\"  sdtr_able 0x%x, wdtr_able 0x%x\\n\",\n\t       (unsigned)h->sdtr_able, (unsigned)h->wdtr_able);\n\n\tprintk(\"  start_motor 0x%x, scsi_reset_wait 0x%x\\n\",\n\t       (unsigned)h->start_motor, (unsigned)h->scsi_reset_wait);\n\n\tprintk(\"  max_host_qng %u, max_dvc_qng %u, carr_freelist 0x%p\\n\",\n\t       (unsigned)h->max_host_qng, (unsigned)h->max_dvc_qng,\n\t       h->carr_freelist);\n\n\tprintk(\"  icq_sp 0x%p, irq_sp 0x%p\\n\", h->icq_sp, h->irq_sp);\n\n\tprintk(\"  no_scam 0x%x, tagqng_able 0x%x\\n\",\n\t       (unsigned)h->no_scam, (unsigned)h->tagqng_able);\n\n\tprintk(\"  chip_scsi_id 0x%x, cfg 0x%lx\\n\",\n\t       (unsigned)h->chip_scsi_id, (ulong)h->cfg);\n}\n\n \nstatic void asc_prt_adv_dvc_cfg(ADV_DVC_CFG *h)\n{\n\tprintk(\" ADV_DVC_CFG at addr 0x%lx\\n\", (ulong)h);\n\n\tprintk(\"  disc_enable 0x%x, termination 0x%x\\n\",\n\t       h->disc_enable, h->termination);\n\n\tprintk(\"  chip_version 0x%x, mcode_date 0x%x\\n\",\n\t       h->chip_version, h->mcode_date);\n\n\tprintk(\"  mcode_version 0x%x, control_flag 0x%x\\n\",\n\t       h->mcode_version, h->control_flag);\n}\n\n \nstatic void asc_prt_scsi_host(struct Scsi_Host *s)\n{\n\tstruct asc_board *boardp = shost_priv(s);\n\n\tprintk(\"Scsi_Host at addr 0x%p, device %s\\n\", s, dev_name(boardp->dev));\n\tprintk(\" host_busy %d, host_no %d,\\n\",\n\t       scsi_host_busy(s), s->host_no);\n\n\tprintk(\" base 0x%lx, io_port 0x%lx, irq %d,\\n\",\n\t       (ulong)s->base, (ulong)s->io_port, boardp->irq);\n\n\tprintk(\" dma_channel %d, this_id %d, can_queue %d,\\n\",\n\t       s->dma_channel, s->this_id, s->can_queue);\n\n\tprintk(\" cmd_per_lun %d, sg_tablesize %d\\n\",\n\t       s->cmd_per_lun, s->sg_tablesize);\n\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tasc_prt_asc_dvc_var(&boardp->dvc_var.asc_dvc_var);\n\t\tasc_prt_asc_dvc_cfg(&boardp->dvc_cfg.asc_dvc_cfg);\n\t} else {\n\t\tasc_prt_adv_dvc_var(&boardp->dvc_var.adv_dvc_var);\n\t\tasc_prt_adv_dvc_cfg(&boardp->dvc_cfg.adv_dvc_cfg);\n\t}\n}\n\n \nstatic void asc_prt_hex(char *f, uchar *s, int l)\n{\n\tint i;\n\tint j;\n\tint k;\n\tint m;\n\n\tprintk(\"%s: (%d bytes)\\n\", f, l);\n\n\tfor (i = 0; i < l; i += 32) {\n\n\t\t \n\t\tif ((k = (l - i) / 4) >= 8) {\n\t\t\tk = 8;\n\t\t\tm = 0;\n\t\t} else {\n\t\t\tm = (l - i) % 4;\n\t\t}\n\n\t\tfor (j = 0; j < k; j++) {\n\t\t\tprintk(\" %2.2X%2.2X%2.2X%2.2X\",\n\t\t\t       (unsigned)s[i + (j * 4)],\n\t\t\t       (unsigned)s[i + (j * 4) + 1],\n\t\t\t       (unsigned)s[i + (j * 4) + 2],\n\t\t\t       (unsigned)s[i + (j * 4) + 3]);\n\t\t}\n\n\t\tswitch (m) {\n\t\tcase 0:\n\t\tdefault:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintk(\" %2.2X\", (unsigned)s[i + (j * 4)]);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintk(\" %2.2X%2.2X\",\n\t\t\t       (unsigned)s[i + (j * 4)],\n\t\t\t       (unsigned)s[i + (j * 4) + 1]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintk(\" %2.2X%2.2X%2.2X\",\n\t\t\t       (unsigned)s[i + (j * 4) + 1],\n\t\t\t       (unsigned)s[i + (j * 4) + 2],\n\t\t\t       (unsigned)s[i + (j * 4) + 3]);\n\t\t\tbreak;\n\t\t}\n\n\t\tprintk(\"\\n\");\n\t}\n}\n\n \nstatic void asc_prt_asc_scsi_q(ASC_SCSI_Q *q)\n{\n\tASC_SG_HEAD *sgp;\n\tint i;\n\n\tprintk(\"ASC_SCSI_Q at addr 0x%lx\\n\", (ulong)q);\n\n\tprintk\n\t    (\" target_ix 0x%x, target_lun %u, srb_tag 0x%x, tag_code 0x%x,\\n\",\n\t     q->q2.target_ix, q->q1.target_lun, q->q2.srb_tag,\n\t     q->q2.tag_code);\n\n\tprintk\n\t    (\" data_addr 0x%lx, data_cnt %lu, sense_addr 0x%lx, sense_len %u,\\n\",\n\t     (ulong)le32_to_cpu(q->q1.data_addr),\n\t     (ulong)le32_to_cpu(q->q1.data_cnt),\n\t     (ulong)le32_to_cpu(q->q1.sense_addr), q->q1.sense_len);\n\n\tprintk(\" cdbptr 0x%lx, cdb_len %u, sg_head 0x%lx, sg_queue_cnt %u\\n\",\n\t       (ulong)q->cdbptr, q->q2.cdb_len,\n\t       (ulong)q->sg_head, q->q1.sg_queue_cnt);\n\n\tif (q->sg_head) {\n\t\tsgp = q->sg_head;\n\t\tprintk(\"ASC_SG_HEAD at addr 0x%lx\\n\", (ulong)sgp);\n\t\tprintk(\" entry_cnt %u, queue_cnt %u\\n\", sgp->entry_cnt,\n\t\t       sgp->queue_cnt);\n\t\tfor (i = 0; i < sgp->entry_cnt; i++) {\n\t\t\tprintk(\" [%u]: addr 0x%lx, bytes %lu\\n\",\n\t\t\t       i, (ulong)le32_to_cpu(sgp->sg_list[i].addr),\n\t\t\t       (ulong)le32_to_cpu(sgp->sg_list[i].bytes));\n\t\t}\n\n\t}\n}\n\n \nstatic void asc_prt_asc_qdone_info(ASC_QDONE_INFO *q)\n{\n\tprintk(\"ASC_QDONE_INFO at addr 0x%lx\\n\", (ulong)q);\n\tprintk(\" srb_tag 0x%x, target_ix %u, cdb_len %u, tag_code %u,\\n\",\n\t       q->d2.srb_tag, q->d2.target_ix, q->d2.cdb_len,\n\t       q->d2.tag_code);\n\tprintk\n\t    (\" done_stat 0x%x, host_stat 0x%x, scsi_stat 0x%x, scsi_msg 0x%x\\n\",\n\t     q->d3.done_stat, q->d3.host_stat, q->d3.scsi_stat, q->d3.scsi_msg);\n}\n\n \nstatic void asc_prt_adv_sgblock(int sgblockno, ADV_SG_BLOCK *b)\n{\n\tint i;\n\n\tprintk(\" ADV_SG_BLOCK at addr 0x%lx (sgblockno %d)\\n\",\n\t       (ulong)b, sgblockno);\n\tprintk(\"  sg_cnt %u, sg_ptr 0x%x\\n\",\n\t       b->sg_cnt, (u32)le32_to_cpu(b->sg_ptr));\n\tBUG_ON(b->sg_cnt > NO_OF_SG_PER_BLOCK);\n\tif (b->sg_ptr != 0)\n\t\tBUG_ON(b->sg_cnt != NO_OF_SG_PER_BLOCK);\n\tfor (i = 0; i < b->sg_cnt; i++) {\n\t\tprintk(\"  [%u]: sg_addr 0x%x, sg_count 0x%x\\n\",\n\t\t       i, (u32)le32_to_cpu(b->sg_list[i].sg_addr),\n\t\t       (u32)le32_to_cpu(b->sg_list[i].sg_count));\n\t}\n}\n\n \nstatic void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)\n{\n\tint sg_blk_cnt;\n\tstruct adv_sg_block *sg_ptr;\n\tadv_sgblk_t *sgblkp;\n\n\tprintk(\"ADV_SCSI_REQ_Q at addr 0x%lx\\n\", (ulong)q);\n\n\tprintk(\"  target_id %u, target_lun %u, srb_tag 0x%x\\n\",\n\t       q->target_id, q->target_lun, q->srb_tag);\n\n\tprintk(\"  cntl 0x%x, data_addr 0x%lx\\n\",\n\t       q->cntl, (ulong)le32_to_cpu(q->data_addr));\n\n\tprintk(\"  data_cnt %lu, sense_addr 0x%lx, sense_len %u,\\n\",\n\t       (ulong)le32_to_cpu(q->data_cnt),\n\t       (ulong)le32_to_cpu(q->sense_addr), q->sense_len);\n\n\tprintk\n\t    (\"  cdb_len %u, done_status 0x%x, host_status 0x%x, scsi_status 0x%x\\n\",\n\t     q->cdb_len, q->done_status, q->host_status, q->scsi_status);\n\n\tprintk(\"  sg_working_ix 0x%x, target_cmd %u\\n\",\n\t       q->sg_working_ix, q->target_cmd);\n\n\tprintk(\"  scsiq_rptr 0x%lx, sg_real_addr 0x%lx, sg_list_ptr 0x%lx\\n\",\n\t       (ulong)le32_to_cpu(q->scsiq_rptr),\n\t       (ulong)le32_to_cpu(q->sg_real_addr), (ulong)q->sg_list_ptr);\n\n\t \n\tif (q->sg_list_ptr != NULL) {\n\t\tsgblkp = container_of(q->sg_list_ptr, adv_sgblk_t, sg_block);\n\t\tsg_blk_cnt = 0;\n\t\twhile (sgblkp) {\n\t\t\tsg_ptr = &sgblkp->sg_block;\n\t\t\tasc_prt_adv_sgblock(sg_blk_cnt, sg_ptr);\n\t\t\tif (sg_ptr->sg_ptr == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsgblkp = sgblkp->next_sgblkp;\n\t\t\tsg_blk_cnt++;\n\t\t}\n\t}\n}\n#endif  \n\n \nstatic const char *advansys_info(struct Scsi_Host *shost)\n{\n\tstatic char info[ASC_INFO_SIZE];\n\tstruct asc_board *boardp = shost_priv(shost);\n\tASC_DVC_VAR *asc_dvc_varp;\n\tADV_DVC_VAR *adv_dvc_varp;\n\tchar *busname;\n\tchar *widename = NULL;\n\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tasc_dvc_varp = &boardp->dvc_var.asc_dvc_var;\n\t\tASC_DBG(1, \"begin\\n\");\n\n\t\tif (asc_dvc_varp->bus_type & ASC_IS_VL) {\n\t\t\tbusname = \"VL\";\n\t\t} else if (asc_dvc_varp->bus_type & ASC_IS_EISA) {\n\t\t\tbusname = \"EISA\";\n\t\t} else if (asc_dvc_varp->bus_type & ASC_IS_PCI) {\n\t\t\tif ((asc_dvc_varp->bus_type & ASC_IS_PCI_ULTRA)\n\t\t\t    == ASC_IS_PCI_ULTRA) {\n\t\t\t\tbusname = \"PCI Ultra\";\n\t\t\t} else {\n\t\t\t\tbusname = \"PCI\";\n\t\t\t}\n\t\t} else {\n\t\t\tbusname = \"?\";\n\t\t\tshost_printk(KERN_ERR, shost, \"unknown bus \"\n\t\t\t\t\"type %d\\n\", asc_dvc_varp->bus_type);\n\t\t}\n\t\tsprintf(info,\n\t\t\t\"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X\",\n\t\t\tASC_VERSION, busname, (ulong)shost->io_port,\n\t\t\t(ulong)shost->io_port + ASC_IOADR_GAP - 1,\n\t\t\tboardp->irq);\n\t} else {\n\t\t \n\t\tadv_dvc_varp = &boardp->dvc_var.adv_dvc_var;\n\t\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\t\twidename = \"Ultra-Wide\";\n\t\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\t\twidename = \"Ultra2-Wide\";\n\t\t} else {\n\t\t\twidename = \"Ultra3-Wide\";\n\t\t}\n\t\tsprintf(info,\n\t\t\t\"AdvanSys SCSI %s: PCI %s: PCIMEM 0x%lX-0x%lX, IRQ 0x%X\",\n\t\t\tASC_VERSION, widename, (ulong)adv_dvc_varp->iop_base,\n\t\t\t(ulong)adv_dvc_varp->iop_base + boardp->asc_n_io_port - 1, boardp->irq);\n\t}\n\tBUG_ON(strlen(info) >= ASC_INFO_SIZE);\n\tASC_DBG(1, \"end\\n\");\n\treturn info;\n}\n\n#ifdef CONFIG_PROC_FS\n\n \nstatic void asc_prt_board_devices(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\tint chip_scsi_id;\n\tint i;\n\n\tseq_printf(m,\n\t\t   \"\\nDevice Information for AdvanSys SCSI Host %d:\\n\",\n\t\t   shost->host_no);\n\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tchip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;\n\t} else {\n\t\tchip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;\n\t}\n\n\tseq_puts(m, \"Target IDs Detected:\");\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\tif (boardp->init_tidmask & ADV_TID_TO_TIDMASK(i))\n\t\t\tseq_printf(m, \" %X,\", i);\n\t}\n\tseq_printf(m, \" (%X=Host Adapter)\\n\", chip_scsi_id);\n}\n\n \nstatic void asc_prt_adv_bios(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\tushort major, minor, letter;\n\n\tseq_puts(m, \"\\nROM BIOS Version: \");\n\n\t \n\tif (boardp->bios_signature != 0x55AA) {\n\t\tseq_puts(m, \"Disabled or Pre-3.1\\n\"\n\t\t\t\"BIOS either disabled or Pre-3.1. If it is pre-3.1, then a newer version\\n\"\n\t\t\t\"can be found at the ConnectCom FTP site: ftp://ftp.connectcom.net/pub\\n\");\n\t} else {\n\t\tmajor = (boardp->bios_version >> 12) & 0xF;\n\t\tminor = (boardp->bios_version >> 8) & 0xF;\n\t\tletter = (boardp->bios_version & 0xFF);\n\n\t\tseq_printf(m, \"%d.%d%c\\n\",\n\t\t\t\t   major, minor,\n\t\t\t\t   letter >= 26 ? '?' : letter + 'A');\n\t\t \n\t\tif (major < 3 || (major <= 3 && minor < 1) ||\n\t\t    (major <= 3 && minor <= 1 && letter < ('I' - 'A'))) {\n\t\t\tseq_puts(m, \"Newer version of ROM BIOS is available at the ConnectCom FTP site:\\n\"\n\t\t\t\t\"ftp://ftp.connectcom.net/pub\\n\");\n\t\t}\n\t}\n}\n\n \nstatic int asc_get_eeprom_string(ushort *serialnum, uchar *cp)\n{\n\tushort w, num;\n\n\tif ((serialnum[1] & 0xFE00) != ((ushort)0xAA << 8)) {\n\t\treturn ASC_FALSE;\n\t} else {\n\t\t \n\t\tw = serialnum[0];\n\n\t\t \n\t\tif ((*cp = 'A' + ((w & 0xE000) >> 13)) == 'H') {\n\t\t\t \n\t\t\t*cp += 0x8;\n\t\t}\n\t\tcp++;\n\n\t\t \n\t\t*cp++ = 'A' + ((w & 0x1C00) >> 10);\n\n\t\t \n\t\tnum = w & 0x3FF;\n\t\t*cp++ = '0' + (num / 100);\n\t\tnum %= 100;\n\t\t*cp++ = '0' + (num / 10);\n\n\t\t \n\t\t*cp++ = 'A' + (num % 10);\n\n\t\t \n\t\tw = serialnum[1];\n\n\t\t \n\t\tif (serialnum[2] & 0x8000) {\n\t\t\t*cp++ = '8' + ((w & 0x1C0) >> 6);\n\t\t} else {\n\t\t\t*cp++ = '0' + ((w & 0x1C0) >> 6);\n\t\t}\n\n\t\t \n\t\tnum = w & 0x003F;\n\t\t*cp++ = '0' + num / 10;\n\t\tnum %= 10;\n\t\t*cp++ = '0' + num;\n\n\t\t \n\t\tw = serialnum[2] & 0x7FFF;\n\n\t\t \n\t\t*cp++ = 'A' + (w / 1000);\n\n\t\t \n\t\tnum = w % 1000;\n\t\t*cp++ = '0' + num / 100;\n\t\tnum %= 100;\n\t\t*cp++ = '0' + num / 10;\n\t\tnum %= 10;\n\t\t*cp++ = '0' + num;\n\n\t\t*cp = '\\0';\t \n\t\treturn ASC_TRUE;\n\t}\n}\n\n \nstatic void asc_prt_asc_board_eeprom(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\tASCEEP_CONFIG *ep;\n\tint i;\n\tuchar serialstr[13];\n\n\tep = &boardp->eep_config.asc_eep;\n\n\tseq_printf(m,\n\t\t   \"\\nEEPROM Settings for AdvanSys SCSI Host %d:\\n\",\n\t\t   shost->host_no);\n\n\tif (asc_get_eeprom_string((ushort *)&ep->adapter_info[0], serialstr)\n\t    == ASC_TRUE)\n\t\tseq_printf(m, \" Serial Number: %s\\n\", serialstr);\n\telse if (ep->adapter_info[5] == 0xBB)\n\t\tseq_puts(m,\n\t\t\t \" Default Settings Used for EEPROM-less Adapter.\\n\");\n\telse\n\t\tseq_puts(m, \" Serial Number Signature Not Present.\\n\");\n\n\tseq_printf(m,\n\t\t   \" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\\n\",\n\t\t   ASC_EEP_GET_CHIP_ID(ep), ep->max_total_qng,\n\t\t   ep->max_tag_qng);\n\n\tseq_printf(m,\n\t\t   \" cntl 0x%x, no_scam 0x%x\\n\", ep->cntl, ep->no_scam);\n\n\tseq_puts(m, \" Target ID:           \");\n\tfor (i = 0; i <= ASC_MAX_TID; i++)\n\t\tseq_printf(m, \" %d\", i);\n\n\tseq_puts(m, \"\\n Disconnects:         \");\n\tfor (i = 0; i <= ASC_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (ep->disc_enable & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\n\tseq_puts(m, \"\\n Command Queuing:     \");\n\tfor (i = 0; i <= ASC_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (ep->use_cmd_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\n\tseq_puts(m, \"\\n Start Motor:         \");\n\tfor (i = 0; i <= ASC_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (ep->start_motor & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\n\tseq_puts(m, \"\\n Synchronous Transfer:\");\n\tfor (i = 0; i <= ASC_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (ep->init_sdtr & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\tseq_putc(m, '\\n');\n}\n\n \nstatic void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\tADV_DVC_VAR *adv_dvc_varp;\n\tint i;\n\tchar *termstr;\n\tuchar serialstr[13];\n\tADVEEP_3550_CONFIG *ep_3550 = NULL;\n\tADVEEP_38C0800_CONFIG *ep_38C0800 = NULL;\n\tADVEEP_38C1600_CONFIG *ep_38C1600 = NULL;\n\tushort word;\n\tushort *wordp;\n\tushort sdtr_speed = 0;\n\n\tadv_dvc_varp = &boardp->dvc_var.adv_dvc_var;\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tep_3550 = &boardp->eep_config.adv_3550_eep;\n\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tep_38C0800 = &boardp->eep_config.adv_38C0800_eep;\n\t} else {\n\t\tep_38C1600 = &boardp->eep_config.adv_38C1600_eep;\n\t}\n\n\tseq_printf(m,\n\t\t   \"\\nEEPROM Settings for AdvanSys SCSI Host %d:\\n\",\n\t\t   shost->host_no);\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\twordp = &ep_3550->serial_number_word1;\n\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\twordp = &ep_38C0800->serial_number_word1;\n\t} else {\n\t\twordp = &ep_38C1600->serial_number_word1;\n\t}\n\n\tif (asc_get_eeprom_string(wordp, serialstr) == ASC_TRUE)\n\t\tseq_printf(m, \" Serial Number: %s\\n\", serialstr);\n\telse\n\t\tseq_puts(m, \" Serial Number Signature Not Present.\\n\");\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)\n\t\tseq_printf(m,\n\t\t\t   \" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\\n\",\n\t\t\t   ep_3550->adapter_scsi_id,\n\t\t\t   ep_3550->max_host_qng, ep_3550->max_dvc_qng);\n\telse if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)\n\t\tseq_printf(m,\n\t\t\t   \" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\\n\",\n\t\t\t   ep_38C0800->adapter_scsi_id,\n\t\t\t   ep_38C0800->max_host_qng,\n\t\t\t   ep_38C0800->max_dvc_qng);\n\telse\n\t\tseq_printf(m,\n\t\t\t   \" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\\n\",\n\t\t\t   ep_38C1600->adapter_scsi_id,\n\t\t\t   ep_38C1600->max_host_qng,\n\t\t\t   ep_38C1600->max_dvc_qng);\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tword = ep_3550->termination;\n\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tword = ep_38C0800->termination_lvd;\n\t} else {\n\t\tword = ep_38C1600->termination_lvd;\n\t}\n\tswitch (word) {\n\tcase 1:\n\t\ttermstr = \"Low Off/High Off\";\n\t\tbreak;\n\tcase 2:\n\t\ttermstr = \"Low Off/High On\";\n\t\tbreak;\n\tcase 3:\n\t\ttermstr = \"Low On/High On\";\n\t\tbreak;\n\tdefault:\n\tcase 0:\n\t\ttermstr = \"Automatic\";\n\t\tbreak;\n\t}\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)\n\t\tseq_printf(m,\n\t\t\t   \" termination: %u (%s), bios_ctrl: 0x%x\\n\",\n\t\t\t   ep_3550->termination, termstr,\n\t\t\t   ep_3550->bios_ctrl);\n\telse if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)\n\t\tseq_printf(m,\n\t\t\t   \" termination: %u (%s), bios_ctrl: 0x%x\\n\",\n\t\t\t   ep_38C0800->termination_lvd, termstr,\n\t\t\t   ep_38C0800->bios_ctrl);\n\telse\n\t\tseq_printf(m,\n\t\t\t   \" termination: %u (%s), bios_ctrl: 0x%x\\n\",\n\t\t\t   ep_38C1600->termination_lvd, termstr,\n\t\t\t   ep_38C1600->bios_ctrl);\n\n\tseq_puts(m, \" Target ID:           \");\n\tfor (i = 0; i <= ADV_MAX_TID; i++)\n\t\tseq_printf(m, \" %X\", i);\n\tseq_putc(m, '\\n');\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tword = ep_3550->disc_enable;\n\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tword = ep_38C0800->disc_enable;\n\t} else {\n\t\tword = ep_38C1600->disc_enable;\n\t}\n\tseq_puts(m, \" Disconnects:         \");\n\tfor (i = 0; i <= ADV_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\tseq_putc(m, '\\n');\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tword = ep_3550->tagqng_able;\n\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tword = ep_38C0800->tagqng_able;\n\t} else {\n\t\tword = ep_38C1600->tagqng_able;\n\t}\n\tseq_puts(m, \" Command Queuing:     \");\n\tfor (i = 0; i <= ADV_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\tseq_putc(m, '\\n');\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tword = ep_3550->start_motor;\n\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tword = ep_38C0800->start_motor;\n\t} else {\n\t\tword = ep_38C1600->start_motor;\n\t}\n\tseq_puts(m, \" Start Motor:         \");\n\tfor (i = 0; i <= ADV_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\tseq_putc(m, '\\n');\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tseq_puts(m, \" Synchronous Transfer:\");\n\t\tfor (i = 0; i <= ADV_MAX_TID; i++)\n\t\t\tseq_printf(m, \" %c\",\n\t\t\t\t   (ep_3550->sdtr_able & ADV_TID_TO_TIDMASK(i)) ?\n\t\t\t\t   'Y' : 'N');\n\t\tseq_putc(m, '\\n');\n\t}\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tseq_puts(m, \" Ultra Transfer:      \");\n\t\tfor (i = 0; i <= ADV_MAX_TID; i++)\n\t\t\tseq_printf(m, \" %c\",\n\t\t\t\t   (ep_3550->ultra_able & ADV_TID_TO_TIDMASK(i))\n\t\t\t\t   ? 'Y' : 'N');\n\t\tseq_putc(m, '\\n');\n\t}\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tword = ep_3550->wdtr_able;\n\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tword = ep_38C0800->wdtr_able;\n\t} else {\n\t\tword = ep_38C1600->wdtr_able;\n\t}\n\tseq_puts(m, \" Wide Transfer:       \");\n\tfor (i = 0; i <= ADV_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\tseq_putc(m, '\\n');\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800 ||\n\t    adv_dvc_varp->chip_type == ADV_CHIP_ASC38C1600) {\n\t\tseq_puts(m, \" Synchronous Transfer Speed (Mhz):\\n  \");\n\t\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\t\tchar *speed_str;\n\n\t\t\tif (i == 0) {\n\t\t\t\tsdtr_speed = adv_dvc_varp->sdtr_speed1;\n\t\t\t} else if (i == 4) {\n\t\t\t\tsdtr_speed = adv_dvc_varp->sdtr_speed2;\n\t\t\t} else if (i == 8) {\n\t\t\t\tsdtr_speed = adv_dvc_varp->sdtr_speed3;\n\t\t\t} else if (i == 12) {\n\t\t\t\tsdtr_speed = adv_dvc_varp->sdtr_speed4;\n\t\t\t}\n\t\t\tswitch (sdtr_speed & ADV_MAX_TID) {\n\t\t\tcase 0:\n\t\t\t\tspeed_str = \"Off\";\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tspeed_str = \"  5\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tspeed_str = \" 10\";\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tspeed_str = \" 20\";\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tspeed_str = \" 40\";\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tspeed_str = \" 80\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tspeed_str = \"Unk\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseq_printf(m, \"%X:%s \", i, speed_str);\n\t\t\tif (i == 7)\n\t\t\t\tseq_puts(m, \"\\n  \");\n\t\t\tsdtr_speed >>= 4;\n\t\t}\n\t\tseq_putc(m, '\\n');\n\t}\n}\n\n \nstatic void asc_prt_driver_conf(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\n\tseq_printf(m,\n\t\t\"\\nLinux Driver Configuration and Information for AdvanSys SCSI Host %d:\\n\",\n\t\tshost->host_no);\n\n\tseq_printf(m,\n\t\t   \" host_busy %d, max_id %u, max_lun %llu, max_channel %u\\n\",\n\t\t   scsi_host_busy(shost), shost->max_id,\n\t\t   shost->max_lun, shost->max_channel);\n\n\tseq_printf(m,\n\t\t   \" unique_id %d, can_queue %d, this_id %d, sg_tablesize %u, cmd_per_lun %u\\n\",\n\t\t   shost->unique_id, shost->can_queue, shost->this_id,\n\t\t   shost->sg_tablesize, shost->cmd_per_lun);\n\n\tseq_printf(m,\n\t\t   \" flags 0x%x, last_reset 0x%lx, jiffies 0x%lx, asc_n_io_port 0x%x\\n\",\n\t\t   boardp->flags, shost->last_reset, jiffies,\n\t\t   boardp->asc_n_io_port);\n\n\tseq_printf(m, \" io_port 0x%lx\\n\", shost->io_port);\n}\n\n \nstatic void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\tint chip_scsi_id;\n\tASC_DVC_VAR *v;\n\tASC_DVC_CFG *c;\n\tint i;\n\tint renegotiate = 0;\n\n\tv = &boardp->dvc_var.asc_dvc_var;\n\tc = &boardp->dvc_cfg.asc_dvc_cfg;\n\tchip_scsi_id = c->chip_scsi_id;\n\n\tseq_printf(m,\n\t\t   \"\\nAsc Library Configuration and Statistics for AdvanSys SCSI Host %d:\\n\",\n\t\t   shost->host_no);\n\n\tseq_printf(m, \" chip_version %u, mcode_date 0x%x, \"\n\t\t   \"mcode_version 0x%x, err_code %u\\n\",\n\t\t   c->chip_version, c->mcode_date, c->mcode_version,\n\t\t   v->err_code);\n\n\t \n\tseq_printf(m,\n\t\t   \" Total Command Pending: %d\\n\", v->cur_total_qng);\n\n\tseq_puts(m, \" Command Queuing:\");\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\t\tseq_printf(m, \" %X:%c\",\n\t\t\t   i,\n\t\t\t   (v->use_tagged_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\t}\n\n\t \n\tseq_puts(m, \"\\n Command Queue Pending:\");\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\t\tseq_printf(m, \" %X:%u\", i, v->cur_dvc_qng[i]);\n\t}\n\n\t \n\tseq_puts(m, \"\\n Command Queue Limit:\");\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\t\tseq_printf(m, \" %X:%u\", i, v->max_dvc_qng[i]);\n\t}\n\n\t \n\tseq_puts(m, \"\\n Command Queue Full:\");\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (boardp->queue_full & ADV_TID_TO_TIDMASK(i))\n\t\t\tseq_printf(m, \" %X:Y-%d\",\n\t\t\t\t   i, boardp->queue_full_cnt[i]);\n\t\telse\n\t\t\tseq_printf(m, \" %X:N\", i);\n\t}\n\n\tseq_puts(m, \"\\n Synchronous Transfer:\");\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\t\tseq_printf(m, \" %X:%c\",\n\t\t\t   i,\n\t\t\t   (v->sdtr_done & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\t}\n\tseq_putc(m, '\\n');\n\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tuchar syn_period_ix;\n\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||\n\t\t    ((v->init_sdtr & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(m, \"  %X:\", i);\n\n\t\tif ((boardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET) == 0) {\n\t\t\tseq_puts(m, \" Asynchronous\");\n\t\t} else {\n\t\t\tsyn_period_ix =\n\t\t\t    (boardp->sdtr_data[i] >> 4) & (v->max_sdtr_index -\n\t\t\t\t\t\t\t   1);\n\n\t\t\tseq_printf(m,\n\t\t\t\t   \" Transfer Period Factor: %d (%d.%d Mhz),\",\n\t\t\t\t   v->sdtr_period_tbl[syn_period_ix],\n\t\t\t\t   250 / v->sdtr_period_tbl[syn_period_ix],\n\t\t\t\t   ASC_TENTHS(250,\n\t\t\t\t\t      v->sdtr_period_tbl[syn_period_ix]));\n\n\t\t\tseq_printf(m, \" REQ/ACK Offset: %d\",\n\t\t\t\t   boardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET);\n\t\t}\n\n\t\tif ((v->sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {\n\t\t\tseq_puts(m, \"*\\n\");\n\t\t\trenegotiate = 1;\n\t\t} else {\n\t\t\tseq_putc(m, '\\n');\n\t\t}\n\t}\n\n\tif (renegotiate) {\n\t\tseq_puts(m, \" * = Re-negotiation pending before next command.\\n\");\n\t}\n}\n\n \nstatic void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\tint i;\n\tADV_DVC_VAR *v;\n\tADV_DVC_CFG *c;\n\tAdvPortAddr iop_base;\n\tushort chip_scsi_id;\n\tushort lramword;\n\tuchar lrambyte;\n\tushort tagqng_able;\n\tushort sdtr_able, wdtr_able;\n\tushort wdtr_done, sdtr_done;\n\tushort period = 0;\n\tint renegotiate = 0;\n\n\tv = &boardp->dvc_var.adv_dvc_var;\n\tc = &boardp->dvc_cfg.adv_dvc_cfg;\n\tiop_base = v->iop_base;\n\tchip_scsi_id = v->chip_scsi_id;\n\n\tseq_printf(m,\n\t\t   \"\\nAdv Library Configuration and Statistics for AdvanSys SCSI Host %d:\\n\",\n\t\t   shost->host_no);\n\n\tseq_printf(m,\n\t\t   \" iop_base 0x%p, cable_detect: %X, err_code %u\\n\",\n\t\t   v->iop_base,\n\t\t   AdvReadWordRegister(iop_base,IOPW_SCSI_CFG1) & CABLE_DETECT,\n\t\t   v->err_code);\n\n\tseq_printf(m, \" chip_version %u, mcode_date 0x%x, \"\n\t\t   \"mcode_version 0x%x\\n\", c->chip_version,\n\t\t   c->mcode_date, c->mcode_version);\n\n\tAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tseq_puts(m, \" Queuing Enabled:\");\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(m, \" %X:%c\",\n\t\t\t   i,\n\t\t\t   (tagqng_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\t}\n\n\tseq_puts(m, \"\\n Queue Limit:\");\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + i,\n\t\t\t\tlrambyte);\n\n\t\tseq_printf(m, \" %X:%d\", i, lrambyte);\n\t}\n\n\tseq_puts(m, \"\\n Command Pending:\");\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_QUEUED_CMD + i,\n\t\t\t\tlrambyte);\n\n\t\tseq_printf(m, \" %X:%d\", i, lrambyte);\n\t}\n\tseq_putc(m, '\\n');\n\n\tAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\tseq_puts(m, \" Wide Enabled:\");\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(m, \" %X:%c\",\n\t\t\t   i,\n\t\t\t   (wdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\t}\n\tseq_putc(m, '\\n');\n\n\tAdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, wdtr_done);\n\tseq_puts(m, \" Transfer Bit Width:\");\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tAdvReadWordLram(iop_base,\n\t\t\t\tASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),\n\t\t\t\tlramword);\n\n\t\tseq_printf(m, \" %X:%d\",\n\t\t\t   i, (lramword & 0x8000) ? 16 : 8);\n\n\t\tif ((wdtr_able & ADV_TID_TO_TIDMASK(i)) &&\n\t\t    (wdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {\n\t\t\tseq_putc(m, '*');\n\t\t\trenegotiate = 1;\n\t\t}\n\t}\n\tseq_putc(m, '\\n');\n\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\tseq_puts(m, \" Synchronous Enabled:\");\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(m, \" %X:%c\",\n\t\t\t   i,\n\t\t\t   (sdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\t}\n\tseq_putc(m, '\\n');\n\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, sdtr_done);\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\n\t\tAdvReadWordLram(iop_base,\n\t\t\t\tASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),\n\t\t\t\tlramword);\n\t\tlramword &= ~0x8000;\n\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||\n\t\t    ((sdtr_able & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(m, \"  %X:\", i);\n\n\t\tif ((lramword & 0x1F) == 0) {\t \n\t\t\tseq_puts(m, \" Asynchronous\");\n\t\t} else {\n\t\t\tseq_puts(m, \" Transfer Period Factor: \");\n\n\t\t\tif ((lramword & 0x1F00) == 0x1100) {\t \n\t\t\t\tseq_puts(m, \"9 (80.0 Mhz),\");\n\t\t\t} else if ((lramword & 0x1F00) == 0x1000) {\t \n\t\t\t\tseq_puts(m, \"10 (40.0 Mhz),\");\n\t\t\t} else {\t \n\n\t\t\t\tperiod = (((lramword >> 8) * 25) + 50) / 4;\n\n\t\t\t\tif (period == 0) {\t \n\t\t\t\t\tseq_printf(m, \"%d (? Mhz), \", period);\n\t\t\t\t} else {\n\t\t\t\t\tseq_printf(m,\n\t\t\t\t\t\t   \"%d (%d.%d Mhz),\",\n\t\t\t\t\t\t   period, 250 / period,\n\t\t\t\t\t\t   ASC_TENTHS(250, period));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tseq_printf(m, \" REQ/ACK Offset: %d\",\n\t\t\t\t   lramword & 0x1F);\n\t\t}\n\n\t\tif ((sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {\n\t\t\tseq_puts(m, \"*\\n\");\n\t\t\trenegotiate = 1;\n\t\t} else {\n\t\t\tseq_putc(m, '\\n');\n\t\t}\n\t}\n\n\tif (renegotiate) {\n\t\tseq_puts(m, \" * = Re-negotiation pending before next command.\\n\");\n\t}\n}\n\n#ifdef ADVANSYS_STATS\n \nstatic void asc_prt_board_stats(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\tstruct asc_stats *s = &boardp->asc_stats;\n\n\tseq_printf(m,\n\t\t   \"\\nLinux Driver Statistics for AdvanSys SCSI Host %d:\\n\",\n\t\t   shost->host_no);\n\n\tseq_printf(m,\n\t\t   \" queuecommand %u, reset %u, biosparam %u, interrupt %u\\n\",\n\t\t   s->queuecommand, s->reset, s->biosparam,\n\t\t   s->interrupt);\n\n\tseq_printf(m,\n\t\t   \" callback %u, done %u, build_error %u, build_noreq %u, build_nosg %u\\n\",\n\t\t   s->callback, s->done, s->build_error,\n\t\t   s->adv_build_noreq, s->adv_build_nosg);\n\n\tseq_printf(m,\n\t\t   \" exe_noerror %u, exe_busy %u, exe_error %u, exe_unknown %u\\n\",\n\t\t   s->exe_noerror, s->exe_busy, s->exe_error,\n\t\t   s->exe_unknown);\n\n\t \n\tif (s->xfer_cnt > 0) {\n\t\tseq_printf(m, \" xfer_cnt %u, xfer_elem %u, \",\n\t\t\t   s->xfer_cnt, s->xfer_elem);\n\n\t\tseq_printf(m, \"xfer_bytes %u.%01u kb\\n\",\n\t\t\t   s->xfer_sect / 2, ASC_TENTHS(s->xfer_sect, 2));\n\n\t\t \n\t\tseq_printf(m, \" avg_num_elem %u.%01u, \",\n\t\t\t   s->xfer_elem / s->xfer_cnt,\n\t\t\t   ASC_TENTHS(s->xfer_elem, s->xfer_cnt));\n\n\t\tseq_printf(m, \"avg_elem_size %u.%01u kb, \",\n\t\t\t   (s->xfer_sect / 2) / s->xfer_elem,\n\t\t\t   ASC_TENTHS((s->xfer_sect / 2), s->xfer_elem));\n\n\t\tseq_printf(m, \"avg_xfer_size %u.%01u kb\\n\",\n\t\t\t   (s->xfer_sect / 2) / s->xfer_cnt,\n\t\t\t   ASC_TENTHS((s->xfer_sect / 2), s->xfer_cnt));\n\t}\n}\n#endif  \n\n \nstatic int\nadvansys_show_info(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\n\tASC_DBG(1, \"begin\\n\");\n\n\t \n\n\t \n\t \n\tseq_printf(m, \"%s\\n\", (char *)advansys_info(shost));\n\t \n\tif (!ASC_NARROW_BOARD(boardp))\n\t\tasc_prt_adv_bios(m, shost);\n\n\t \n\tasc_prt_board_devices(m, shost);\n\n\t \n\tif (ASC_NARROW_BOARD(boardp))\n\t\tasc_prt_asc_board_eeprom(m, shost);\n\telse\n\t\tasc_prt_adv_board_eeprom(m, shost);\n\n\t \n\tasc_prt_driver_conf(m, shost);\n\n#ifdef ADVANSYS_STATS\n\t \n\tasc_prt_board_stats(m, shost);\n#endif  \n\n\t \n\tif (ASC_NARROW_BOARD(boardp))\n\t\tasc_prt_asc_board_info(m, shost);\n\telse\n\t\tasc_prt_adv_board_info(m, shost);\n\treturn 0;\n}\n#endif  \n\nstatic void asc_scsi_done(struct scsi_cmnd *scp)\n{\n\tscsi_dma_unmap(scp);\n\tASC_STATS(scp->device->host, done);\n\tscsi_done(scp);\n}\n\nstatic void AscSetBank(PortAddr iop_base, uchar bank)\n{\n\tuchar val;\n\n\tval = AscGetChipControl(iop_base) &\n\t    (~\n\t     (CC_SINGLE_STEP | CC_TEST | CC_DIAG | CC_SCSI_RESET |\n\t      CC_CHIP_RESET));\n\tif (bank == 1) {\n\t\tval |= CC_BANK_ONE;\n\t} else if (bank == 2) {\n\t\tval |= CC_DIAG | CC_BANK_ONE;\n\t} else {\n\t\tval &= ~CC_BANK_ONE;\n\t}\n\tAscSetChipControl(iop_base, val);\n}\n\nstatic void AscSetChipIH(PortAddr iop_base, ushort ins_code)\n{\n\tAscSetBank(iop_base, 1);\n\tAscWriteChipIH(iop_base, ins_code);\n\tAscSetBank(iop_base, 0);\n}\n\nstatic int AscStartChip(PortAddr iop_base)\n{\n\tAscSetChipControl(iop_base, 0);\n\tif ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {\n\t\treturn (0);\n\t}\n\treturn (1);\n}\n\nstatic bool AscStopChip(PortAddr iop_base)\n{\n\tuchar cc_val;\n\n\tcc_val =\n\t    AscGetChipControl(iop_base) &\n\t    (~(CC_SINGLE_STEP | CC_TEST | CC_DIAG));\n\tAscSetChipControl(iop_base, (uchar)(cc_val | CC_HALT));\n\tAscSetChipIH(iop_base, INS_HALT);\n\tAscSetChipIH(iop_base, INS_RFLAG_WTM);\n\tif ((AscGetChipStatus(iop_base) & CSW_HALTED) == 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool AscIsChipHalted(PortAddr iop_base)\n{\n\tif ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {\n\t\tif ((AscGetChipControl(iop_base) & CC_HALT) != 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool AscResetChipAndScsiBus(ASC_DVC_VAR *asc_dvc)\n{\n\tPortAddr iop_base;\n\tint i = 10;\n\n\tiop_base = asc_dvc->iop_base;\n\twhile ((AscGetChipStatus(iop_base) & CSW_SCSI_RESET_ACTIVE)\n\t       && (i-- > 0)) {\n\t\tmdelay(100);\n\t}\n\tAscStopChip(iop_base);\n\tAscSetChipControl(iop_base, CC_CHIP_RESET | CC_SCSI_RESET | CC_HALT);\n\tudelay(60);\n\tAscSetChipIH(iop_base, INS_RFLAG_WTM);\n\tAscSetChipIH(iop_base, INS_HALT);\n\tAscSetChipControl(iop_base, CC_CHIP_RESET | CC_HALT);\n\tAscSetChipControl(iop_base, CC_HALT);\n\tmdelay(200);\n\tAscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);\n\tAscSetChipStatus(iop_base, 0);\n\treturn (AscIsChipHalted(iop_base));\n}\n\nstatic int AscFindSignature(PortAddr iop_base)\n{\n\tushort sig_word;\n\n\tASC_DBG(1, \"AscGetChipSignatureByte(0x%x) 0x%x\\n\",\n\t\t iop_base, AscGetChipSignatureByte(iop_base));\n\tif (AscGetChipSignatureByte(iop_base) == (uchar)ASC_1000_ID1B) {\n\t\tASC_DBG(1, \"AscGetChipSignatureWord(0x%x) 0x%x\\n\",\n\t\t\t iop_base, AscGetChipSignatureWord(iop_base));\n\t\tsig_word = AscGetChipSignatureWord(iop_base);\n\t\tif ((sig_word == (ushort)ASC_1000_ID0W) ||\n\t\t    (sig_word == (ushort)ASC_1000_ID0W_FIX)) {\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic void AscEnableInterrupt(PortAddr iop_base)\n{\n\tushort cfg;\n\n\tcfg = AscGetChipCfgLsw(iop_base);\n\tAscSetChipCfgLsw(iop_base, cfg | ASC_CFG0_HOST_INT_ON);\n}\n\nstatic void AscDisableInterrupt(PortAddr iop_base)\n{\n\tushort cfg;\n\n\tcfg = AscGetChipCfgLsw(iop_base);\n\tAscSetChipCfgLsw(iop_base, cfg & (~ASC_CFG0_HOST_INT_ON));\n}\n\nstatic uchar AscReadLramByte(PortAddr iop_base, ushort addr)\n{\n\tunsigned char byte_data;\n\tunsigned short word_data;\n\n\tif (isodd_word(addr)) {\n\t\tAscSetChipLramAddr(iop_base, addr - 1);\n\t\tword_data = AscGetChipLramData(iop_base);\n\t\tbyte_data = (word_data >> 8) & 0xFF;\n\t} else {\n\t\tAscSetChipLramAddr(iop_base, addr);\n\t\tword_data = AscGetChipLramData(iop_base);\n\t\tbyte_data = word_data & 0xFF;\n\t}\n\treturn byte_data;\n}\n\nstatic ushort AscReadLramWord(PortAddr iop_base, ushort addr)\n{\n\tushort word_data;\n\n\tAscSetChipLramAddr(iop_base, addr);\n\tword_data = AscGetChipLramData(iop_base);\n\treturn (word_data);\n}\n\nstatic void\nAscMemWordSetLram(PortAddr iop_base, ushort s_addr, ushort set_wval, int words)\n{\n\tint i;\n\n\tAscSetChipLramAddr(iop_base, s_addr);\n\tfor (i = 0; i < words; i++) {\n\t\tAscSetChipLramData(iop_base, set_wval);\n\t}\n}\n\nstatic void AscWriteLramWord(PortAddr iop_base, ushort addr, ushort word_val)\n{\n\tAscSetChipLramAddr(iop_base, addr);\n\tAscSetChipLramData(iop_base, word_val);\n}\n\nstatic void AscWriteLramByte(PortAddr iop_base, ushort addr, uchar byte_val)\n{\n\tushort word_data;\n\n\tif (isodd_word(addr)) {\n\t\taddr--;\n\t\tword_data = AscReadLramWord(iop_base, addr);\n\t\tword_data &= 0x00FF;\n\t\tword_data |= (((ushort)byte_val << 8) & 0xFF00);\n\t} else {\n\t\tword_data = AscReadLramWord(iop_base, addr);\n\t\tword_data &= 0xFF00;\n\t\tword_data |= ((ushort)byte_val & 0x00FF);\n\t}\n\tAscWriteLramWord(iop_base, addr, word_data);\n}\n\n \nstatic void\nAscMemWordCopyPtrToLram(PortAddr iop_base, ushort s_addr,\n\t\t\tconst uchar *s_buffer, int words)\n{\n\tint i;\n\n\tAscSetChipLramAddr(iop_base, s_addr);\n\tfor (i = 0; i < 2 * words; i += 2) {\n\t\t \n\t\toutpw(iop_base + IOP_RAM_DATA,\n\t\t      ((ushort)s_buffer[i + 1] << 8) | s_buffer[i]);\n\t}\n}\n\n \nstatic void\nAscMemDWordCopyPtrToLram(PortAddr iop_base,\n\t\t\t ushort s_addr, uchar *s_buffer, int dwords)\n{\n\tint i;\n\n\tAscSetChipLramAddr(iop_base, s_addr);\n\tfor (i = 0; i < 4 * dwords; i += 4) {\n\t\toutpw(iop_base + IOP_RAM_DATA, ((ushort)s_buffer[i + 1] << 8) | s_buffer[i]);\t \n\t\toutpw(iop_base + IOP_RAM_DATA, ((ushort)s_buffer[i + 3] << 8) | s_buffer[i + 2]);\t \n\t}\n}\n\n \nstatic void\nAscMemWordCopyPtrFromLram(PortAddr iop_base,\n\t\t\t  ushort s_addr, uchar *d_buffer, int words)\n{\n\tint i;\n\tushort word;\n\n\tAscSetChipLramAddr(iop_base, s_addr);\n\tfor (i = 0; i < 2 * words; i += 2) {\n\t\tword = inpw(iop_base + IOP_RAM_DATA);\n\t\td_buffer[i] = word & 0xff;\n\t\td_buffer[i + 1] = (word >> 8) & 0xff;\n\t}\n}\n\nstatic u32 AscMemSumLramWord(PortAddr iop_base, ushort s_addr, int words)\n{\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < words; i++, s_addr += 2) {\n\t\tsum += AscReadLramWord(iop_base, s_addr);\n\t}\n\treturn (sum);\n}\n\nstatic void AscInitLram(ASC_DVC_VAR *asc_dvc)\n{\n\tuchar i;\n\tushort s_addr;\n\tPortAddr iop_base;\n\n\tiop_base = asc_dvc->iop_base;\n\tAscMemWordSetLram(iop_base, ASC_QADR_BEG, 0,\n\t\t\t  (ushort)(((int)(asc_dvc->max_total_qng + 2 + 1) *\n\t\t\t\t    64) >> 1));\n\ti = ASC_MIN_ACTIVE_QNO;\n\ts_addr = ASC_QADR_BEG + ASC_QBLK_SIZE;\n\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),\n\t\t\t (uchar)(i + 1));\n\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),\n\t\t\t (uchar)(asc_dvc->max_total_qng));\n\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),\n\t\t\t (uchar)i);\n\ti++;\n\ts_addr += ASC_QBLK_SIZE;\n\tfor (; i < asc_dvc->max_total_qng; i++, s_addr += ASC_QBLK_SIZE) {\n\t\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),\n\t\t\t\t (uchar)(i + 1));\n\t\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),\n\t\t\t\t (uchar)(i - 1));\n\t\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),\n\t\t\t\t (uchar)i);\n\t}\n\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),\n\t\t\t (uchar)ASC_QLINK_END);\n\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),\n\t\t\t (uchar)(asc_dvc->max_total_qng - 1));\n\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),\n\t\t\t (uchar)asc_dvc->max_total_qng);\n\ti++;\n\ts_addr += ASC_QBLK_SIZE;\n\tfor (; i <= (uchar)(asc_dvc->max_total_qng + 3);\n\t     i++, s_addr += ASC_QBLK_SIZE) {\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(s_addr + (ushort)ASC_SCSIQ_B_FWD), i);\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(s_addr + (ushort)ASC_SCSIQ_B_BWD), i);\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(s_addr + (ushort)ASC_SCSIQ_B_QNO), i);\n\t}\n}\n\nstatic u32\nAscLoadMicroCode(PortAddr iop_base, ushort s_addr,\n\t\t const uchar *mcode_buf, ushort mcode_size)\n{\n\tu32 chksum;\n\tushort mcode_word_size;\n\tushort mcode_chksum;\n\n\t \n\tmcode_word_size = (ushort)(mcode_size >> 1);\n\tAscMemWordSetLram(iop_base, s_addr, 0, mcode_word_size);\n\tAscMemWordCopyPtrToLram(iop_base, s_addr, mcode_buf, mcode_word_size);\n\n\tchksum = AscMemSumLramWord(iop_base, s_addr, mcode_word_size);\n\tASC_DBG(1, \"chksum 0x%lx\\n\", (ulong)chksum);\n\tmcode_chksum = (ushort)AscMemSumLramWord(iop_base,\n\t\t\t\t\t\t (ushort)ASC_CODE_SEC_BEG,\n\t\t\t\t\t\t (ushort)((mcode_size -\n\t\t\t\t\t\t\t   s_addr - (ushort)\n\t\t\t\t\t\t\t   ASC_CODE_SEC_BEG) /\n\t\t\t\t\t\t\t  2));\n\tASC_DBG(1, \"mcode_chksum 0x%lx\\n\", (ulong)mcode_chksum);\n\tAscWriteLramWord(iop_base, ASCV_MCODE_CHKSUM_W, mcode_chksum);\n\tAscWriteLramWord(iop_base, ASCV_MCODE_SIZE_W, mcode_size);\n\treturn chksum;\n}\n\nstatic void AscInitQLinkVar(ASC_DVC_VAR *asc_dvc)\n{\n\tPortAddr iop_base;\n\tint i;\n\tushort lram_addr;\n\n\tiop_base = asc_dvc->iop_base;\n\tAscPutRiscVarFreeQHead(iop_base, 1);\n\tAscPutRiscVarDoneQTail(iop_base, asc_dvc->max_total_qng);\n\tAscPutVarFreeQHead(iop_base, 1);\n\tAscPutVarDoneQTail(iop_base, asc_dvc->max_total_qng);\n\tAscWriteLramByte(iop_base, ASCV_BUSY_QHEAD_B,\n\t\t\t (uchar)((int)asc_dvc->max_total_qng + 1));\n\tAscWriteLramByte(iop_base, ASCV_DISC1_QHEAD_B,\n\t\t\t (uchar)((int)asc_dvc->max_total_qng + 2));\n\tAscWriteLramByte(iop_base, (ushort)ASCV_TOTAL_READY_Q_B,\n\t\t\t asc_dvc->max_total_qng);\n\tAscWriteLramWord(iop_base, ASCV_ASCDVC_ERR_CODE_W, 0);\n\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\tAscWriteLramByte(iop_base, ASCV_STOP_CODE_B, 0);\n\tAscWriteLramByte(iop_base, ASCV_SCSIBUSY_B, 0);\n\tAscWriteLramByte(iop_base, ASCV_WTM_FLAG_B, 0);\n\tAscPutQDoneInProgress(iop_base, 0);\n\tlram_addr = ASC_QADR_BEG;\n\tfor (i = 0; i < 32; i++, lram_addr += 2) {\n\t\tAscWriteLramWord(iop_base, lram_addr, 0);\n\t}\n}\n\nstatic int AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)\n{\n\tint i;\n\tint warn_code;\n\tPortAddr iop_base;\n\t__le32 phy_addr;\n\t__le32 phy_size;\n\tstruct asc_board *board = asc_dvc_to_board(asc_dvc);\n\n\tiop_base = asc_dvc->iop_base;\n\twarn_code = 0;\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tAscPutMCodeInitSDTRAtID(iop_base, i,\n\t\t\t\t\tasc_dvc->cfg->sdtr_period_offset[i]);\n\t}\n\n\tAscInitQLinkVar(asc_dvc);\n\tAscWriteLramByte(iop_base, ASCV_DISC_ENABLE_B,\n\t\t\t asc_dvc->cfg->disc_enable);\n\tAscWriteLramByte(iop_base, ASCV_HOSTSCSI_ID_B,\n\t\t\t ASC_TID_TO_TARGET_ID(asc_dvc->cfg->chip_scsi_id));\n\n\t \n\tBUG_ON((unsigned long)asc_dvc->overrun_buf & 7);\n\tasc_dvc->overrun_dma = dma_map_single(board->dev, asc_dvc->overrun_buf,\n\t\t\t\t\tASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(board->dev, asc_dvc->overrun_dma)) {\n\t\twarn_code = -ENOMEM;\n\t\tgoto err_dma_map;\n\t}\n\tphy_addr = cpu_to_le32(asc_dvc->overrun_dma);\n\tAscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_PADDR_D,\n\t\t\t\t (uchar *)&phy_addr, 1);\n\tphy_size = cpu_to_le32(ASC_OVERRUN_BSIZE);\n\tAscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_BSIZE_D,\n\t\t\t\t (uchar *)&phy_size, 1);\n\n\tasc_dvc->cfg->mcode_date =\n\t    AscReadLramWord(iop_base, (ushort)ASCV_MC_DATE_W);\n\tasc_dvc->cfg->mcode_version =\n\t    AscReadLramWord(iop_base, (ushort)ASCV_MC_VER_W);\n\n\tAscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);\n\tif (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {\n\t\tasc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;\n\t\twarn_code = -EINVAL;\n\t\tgoto err_mcode_start;\n\t}\n\tif (AscStartChip(iop_base) != 1) {\n\t\tasc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;\n\t\twarn_code = -EIO;\n\t\tgoto err_mcode_start;\n\t}\n\n\treturn warn_code;\n\nerr_mcode_start:\n\tdma_unmap_single(board->dev, asc_dvc->overrun_dma,\n\t\t\t ASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);\nerr_dma_map:\n\tasc_dvc->overrun_dma = 0;\n\treturn warn_code;\n}\n\nstatic int AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)\n{\n\tconst struct firmware *fw;\n\tconst char fwname[] = \"advansys/mcode.bin\";\n\tint err;\n\tunsigned long chksum;\n\tint warn_code;\n\tPortAddr iop_base;\n\n\tiop_base = asc_dvc->iop_base;\n\twarn_code = 0;\n\tif ((asc_dvc->dvc_cntl & ASC_CNTL_RESET_SCSI) &&\n\t    !(asc_dvc->init_state & ASC_INIT_RESET_SCSI_DONE)) {\n\t\tAscResetChipAndScsiBus(asc_dvc);\n\t\tmdelay(asc_dvc->scsi_reset_wait * 1000);  \n\t}\n\tasc_dvc->init_state |= ASC_INIT_STATE_BEG_LOAD_MC;\n\tif (asc_dvc->err_code != 0)\n\t\treturn ASC_ERROR;\n\tif (!AscFindSignature(asc_dvc->iop_base)) {\n\t\tasc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;\n\t\treturn warn_code;\n\t}\n\tAscDisableInterrupt(iop_base);\n\tAscInitLram(asc_dvc);\n\n\terr = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"Failed to load image \\\"%s\\\" err %d\\n\",\n\t\t       fwname, err);\n\t\tasc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;\n\t\treturn err;\n\t}\n\tif (fw->size < 4) {\n\t\tprintk(KERN_ERR \"Bogus length %zu in image \\\"%s\\\"\\n\",\n\t\t       fw->size, fwname);\n\t\trelease_firmware(fw);\n\t\tasc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;\n\t\treturn -EINVAL;\n\t}\n\tchksum = (fw->data[3] << 24) | (fw->data[2] << 16) |\n\t\t (fw->data[1] << 8) | fw->data[0];\n\tASC_DBG(1, \"_asc_mcode_chksum 0x%lx\\n\", (ulong)chksum);\n\tif (AscLoadMicroCode(iop_base, 0, &fw->data[4],\n\t\t\t     fw->size - 4) != chksum) {\n\t\tasc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;\n\t\trelease_firmware(fw);\n\t\treturn warn_code;\n\t}\n\trelease_firmware(fw);\n\twarn_code |= AscInitMicroCodeVar(asc_dvc);\n\tif (!asc_dvc->overrun_dma)\n\t\treturn warn_code;\n\tasc_dvc->init_state |= ASC_INIT_STATE_END_LOAD_MC;\n\tAscEnableInterrupt(iop_base);\n\treturn warn_code;\n}\n\n \nstatic int AdvLoadMicrocode(AdvPortAddr iop_base, const unsigned char *buf,\n\t\t\t    int size, int memsize, int chksum)\n{\n\tint i, j, end, len = 0;\n\tu32 sum;\n\n\tAdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);\n\n\tfor (i = 253 * 2; i < size; i++) {\n\t\tif (buf[i] == 0xff) {\n\t\t\tunsigned short word = (buf[i + 3] << 8) | buf[i + 2];\n\t\t\tfor (j = 0; j < buf[i + 1]; j++) {\n\t\t\t\tAdvWriteWordAutoIncLram(iop_base, word);\n\t\t\t\tlen += 2;\n\t\t\t}\n\t\t\ti += 3;\n\t\t} else if (buf[i] == 0xfe) {\n\t\t\tunsigned short word = (buf[i + 2] << 8) | buf[i + 1];\n\t\t\tAdvWriteWordAutoIncLram(iop_base, word);\n\t\t\ti += 2;\n\t\t\tlen += 2;\n\t\t} else {\n\t\t\tunsigned int off = buf[i] * 2;\n\t\t\tunsigned short word = (buf[off + 1] << 8) | buf[off];\n\t\t\tAdvWriteWordAutoIncLram(iop_base, word);\n\t\t\tlen += 2;\n\t\t}\n\t}\n\n\tend = len;\n\n\twhile (len < memsize) {\n\t\tAdvWriteWordAutoIncLram(iop_base, 0);\n\t\tlen += 2;\n\t}\n\n\t \n\tsum = 0;\n\tAdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);\n\n\tfor (len = 0; len < end; len += 2) {\n\t\tsum += AdvReadWordAutoIncLram(iop_base);\n\t}\n\n\tif (sum != chksum)\n\t\treturn ASC_IERR_MCODE_CHKSUM;\n\n\treturn 0;\n}\n\nstatic void AdvBuildCarrierFreelist(struct adv_dvc_var *adv_dvc)\n{\n\toff_t carr_offset = 0, next_offset;\n\tdma_addr_t carr_paddr;\n\tint carr_num = ADV_CARRIER_BUFSIZE / sizeof(ADV_CARR_T), i;\n\n\tfor (i = 0; i < carr_num; i++) {\n\t\tcarr_offset = i * sizeof(ADV_CARR_T);\n\t\t \n\t\tcarr_paddr = adv_dvc->carrier_addr + carr_offset;\n\n\t\tadv_dvc->carrier[i].carr_pa = cpu_to_le32(carr_paddr);\n\t\tadv_dvc->carrier[i].carr_va = cpu_to_le32(carr_offset);\n\t\tadv_dvc->carrier[i].areq_vpa = 0;\n\t\tnext_offset = carr_offset + sizeof(ADV_CARR_T);\n\t\tif (i == carr_num)\n\t\t\tnext_offset = ~0;\n\t\tadv_dvc->carrier[i].next_vpa = cpu_to_le32(next_offset);\n\t}\n\t \n\tadv_dvc->carr_freelist = &adv_dvc->carrier[1];\n}\n\nstatic ADV_CARR_T *adv_get_carrier(struct adv_dvc_var *adv_dvc, u32 offset)\n{\n\tint index;\n\n\tBUG_ON(offset > ADV_CARRIER_BUFSIZE);\n\n\tindex = offset / sizeof(ADV_CARR_T);\n\treturn &adv_dvc->carrier[index];\n}\n\nstatic ADV_CARR_T *adv_get_next_carrier(struct adv_dvc_var *adv_dvc)\n{\n\tADV_CARR_T *carrp = adv_dvc->carr_freelist;\n\tu32 next_vpa = le32_to_cpu(carrp->next_vpa);\n\n\tif (next_vpa == 0 || next_vpa == ~0) {\n\t\tASC_DBG(1, \"invalid vpa offset 0x%x\\n\", next_vpa);\n\t\treturn NULL;\n\t}\n\n\tadv_dvc->carr_freelist = adv_get_carrier(adv_dvc, next_vpa);\n\t \n\tcarrp->next_vpa = cpu_to_le32(ADV_CQ_STOPPER);\n\n\treturn carrp;\n}\n\n \nstatic adv_req_t * adv_get_reqp(struct adv_dvc_var *adv_dvc, u32 offset)\n{\n\tstruct asc_board *boardp = adv_dvc->drv_ptr;\n\n\tBUG_ON(offset > adv_dvc->max_host_qng);\n\treturn &boardp->adv_reqp[offset];\n}\n\n \nstatic int\nAdvSendIdleCmd(ADV_DVC_VAR *asc_dvc,\n\t       ushort idle_cmd, u32 idle_cmd_parameter)\n{\n\tint result, i, j;\n\tAdvPortAddr iop_base;\n\n\tiop_base = asc_dvc->iop_base;\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS, (ushort)0);\n\n\t \n\tAdvWriteDWordLramNoSwap(iop_base, ASC_MC_IDLE_CMD_PARAMETER,\n\t\t\t\tcpu_to_le32(idle_cmd_parameter));\n\tAdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD, idle_cmd);\n\n\t \n\tAdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_B);\n\tif (asc_dvc->chip_type == ADV_CHIP_ASC3550) {\n\t\t \n\t\tAdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_NOP);\n\t}\n\n\t \n\tfor (i = 0; i < SCSI_WAIT_100_MSEC; i++) {\n\t\t \n\t\tfor (j = 0; j < SCSI_US_PER_MSEC; j++) {\n\t\t\tAdvReadWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS,\n\t\t\t\t\tresult);\n\t\t\tif (result != 0)\n\t\t\t\treturn result;\n\t\t\tudelay(1);\n\t\t}\n\t}\n\n\tBUG();\t\t \n\treturn ADV_ERROR;\n}\n\n \nstatic int AdvResetSB(ADV_DVC_VAR *asc_dvc)\n{\n\tint status;\n\n\t \n\tstatus = AdvSendIdleCmd(asc_dvc, (ushort)IDLE_CMD_SCSI_RESET_START, 0L);\n\tif (status != ADV_TRUE) {\n\t\treturn status;\n\t}\n\n\t \n\tudelay(ASC_SCSI_RESET_HOLD_TIME_US);\n\n\t \n\tstatus = AdvSendIdleCmd(asc_dvc, (ushort)IDLE_CMD_SCSI_RESET_END, 0L);\n\tif (status != ADV_TRUE) {\n\t\treturn status;\n\t}\n\n\tmdelay(asc_dvc->scsi_reset_wait * 1000);\t \n\n\treturn status;\n}\n\n \nstatic int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)\n{\n\tconst struct firmware *fw;\n\tconst char fwname[] = \"advansys/3550.bin\";\n\tAdvPortAddr iop_base;\n\tushort warn_code;\n\tint begin_addr;\n\tint end_addr;\n\tushort code_sum;\n\tint word;\n\tint i;\n\tint err;\n\tunsigned long chksum;\n\tushort scsi_cfg1;\n\tuchar tid;\n\tushort bios_mem[ASC_MC_BIOSLEN / 2];\t \n\tushort wdtr_able = 0, sdtr_able, tagqng_able;\n\tuchar max_cmd[ADV_MAX_TID + 1];\n\n\t \n\tif (asc_dvc->err_code != 0)\n\t\treturn ADV_ERROR;\n\n\t \n\tif (asc_dvc->chip_type != ADV_CHIP_ASC3550) {\n\t\tasc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;\n\t\treturn ADV_ERROR;\n\t}\n\n\twarn_code = 0;\n\tiop_base = asc_dvc->iop_base;\n\n\t \n\tfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t \n\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] == 0x55AA) {\n\t\tushort bios_version, major, minor;\n\n\t\tbios_version =\n\t\t    bios_mem[(ASC_MC_BIOS_VERSION - ASC_MC_BIOSMEM) / 2];\n\t\tmajor = (bios_version >> 12) & 0xF;\n\t\tminor = (bios_version >> 8) & 0xF;\n\t\tif (major < 3 || (major == 3 && minor == 1)) {\n\t\t\t \n\t\t\tAdvReadWordLram(iop_base, 0x120, wdtr_able);\n\t\t} else {\n\t\t\tAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t}\n\t}\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\tAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\tAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\tmax_cmd[tid]);\n\t}\n\n\terr = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"Failed to load image \\\"%s\\\" err %d\\n\",\n\t\t       fwname, err);\n\t\tasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\n\t\treturn err;\n\t}\n\tif (fw->size < 4) {\n\t\tprintk(KERN_ERR \"Bogus length %zu in image \\\"%s\\\"\\n\",\n\t\t       fw->size, fwname);\n\t\trelease_firmware(fw);\n\t\tasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\n\t\treturn -EINVAL;\n\t}\n\tchksum = (fw->data[3] << 24) | (fw->data[2] << 16) |\n\t\t (fw->data[1] << 8) | fw->data[0];\n\tasc_dvc->err_code = AdvLoadMicrocode(iop_base, &fw->data[4],\n\t\t\t\t\t     fw->size - 4, ADV_3550_MEMSIZE,\n\t\t\t\t\t     chksum);\n\trelease_firmware(fw);\n\tif (asc_dvc->err_code)\n\t\treturn ADV_ERROR;\n\n\t \n\tfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\n\t\tAdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\t bios_mem[i]);\n\t}\n\n\t \n\tAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tAdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tAdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += AdvReadWordAutoIncLram(iop_base);\n\t}\n\tAdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t \n\tAdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,\n\t\t\tasc_dvc->cfg->mcode_date);\n\tAdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,\n\t\t\tasc_dvc->cfg->mcode_version);\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC3550);\n\n\t \n\tif (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tAdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t \n\tAdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,\n\t\t\t     START_CTL_EMFU | READ_CMD_MRM);\n\n\t \n\tif ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,\n\t\t\t\t asc_dvc->wdtr_able);\n\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,\n\t\t\t\t asc_dvc->sdtr_able);\n\t}\n\n\t \n\tword = 0;\n\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\tif (ADV_TID_TO_TIDMASK(tid) & asc_dvc->ultra_able) {\n\t\t\t \n\t\t\tword |= (0x3 << (4 * (tid % 4)));\n\t\t} else {\n\t\t\t \n\t\t\tword |= (0x2 << (4 * (tid % 4)));\n\t\t}\n\t\tif (tid == 3) {\t \n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, word);\n\t\t\tword = 0;\n\t\t} else if (tid == 7) {\t \n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, word);\n\t\t\tword = 0;\n\t\t} else if (tid == 11) {\t \n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, word);\n\t\t\tword = 0;\n\t\t} else if (tid == 15) {\t \n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, word);\n\t\t\t \n\t\t}\n\t}\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,\n\t\t\t asc_dvc->cfg->disc_enable);\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\t\t PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |\n\t\t\t asc_dvc->chip_scsi_id);\n\n\t \n\n\t \n\tscsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);\n\n\t \n\tif ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||\n\t    (scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {\n\t\tasc_dvc->err_code |= ASC_IERR_ILLEGAL_CONNECTION;\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tif ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {\n\t\tasc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tif ((scsi_cfg1 & DIFF_MODE) && (scsi_cfg1 & DIFF_SENSE) == 0) {\n\t\tasc_dvc->err_code |= ASC_IERR_SINGLE_END_DEVICE;\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tif (asc_dvc->cfg->termination == 0) {\n\t\t \n\t\tasc_dvc->cfg->termination |= TERM_CTL_SEL;\n\n\t\tswitch (scsi_cfg1 & CABLE_DETECT) {\n\t\t\t \n\t\tcase 0x3:\n\t\tcase 0x7:\n\t\tcase 0xB:\n\t\tcase 0xD:\n\t\tcase 0xE:\n\t\tcase 0xF:\n\t\t\tasc_dvc->cfg->termination |= (TERM_CTL_H | TERM_CTL_L);\n\t\t\tbreak;\n\n\t\t\t \n\t\tcase 0x1:\n\t\tcase 0x5:\n\t\tcase 0x9:\n\t\tcase 0xA:\n\t\tcase 0xC:\n\t\t\tasc_dvc->cfg->termination |= TERM_CTL_H;\n\t\t\tbreak;\n\n\t\t\t \n\t\tcase 0x2:\n\t\tcase 0x6:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tscsi_cfg1 &= ~TERM_CTL;\n\n\t \n\tscsi_cfg1 |= (TERM_CTL_SEL | (~asc_dvc->cfg->termination & TERM_CTL));\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1,\n\t\t\t FLTR_DISABLE | scsi_cfg1);\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,\n\t\t\t BIOS_EN | RAM_SZ_8KB);\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,\n\t\t\t ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));\n\n\tAdvBuildCarrierFreelist(asc_dvc);\n\n\t \n\n\tasc_dvc->icq_sp = adv_get_next_carrier(asc_dvc);\n\tif (!asc_dvc->icq_sp) {\n\t\tasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tAdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);\n\n\t \n\tasc_dvc->irq_sp = adv_get_next_carrier(asc_dvc);\n\tif (!asc_dvc->irq_sp) {\n\t\tasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tAdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);\n\tasc_dvc->carr_pending_cnt = 0;\n\n\tAdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,\n\t\t\t     (ADV_INTR_ENABLE_HOST_INTR |\n\t\t\t      ADV_INTR_ENABLE_GLOBAL_INTR));\n\n\tAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);\n\tAdvWriteWordRegister(iop_base, IOPW_PC, word);\n\n\t \n\tAdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);\n\n\t \n\tif (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {\n\t\t \n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==\n\t\t    0x55AA) {\n\t\t\t \n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\t tagqng_able);\n\t\t\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\t\t\tAdvWriteByteLram(iop_base,\n\t\t\t\t\t\t ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\t\t max_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetSB(asc_dvc) != ADV_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn warn_code;\n}\n\n \nstatic int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)\n{\n\tconst struct firmware *fw;\n\tconst char fwname[] = \"advansys/38C0800.bin\";\n\tAdvPortAddr iop_base;\n\tushort warn_code;\n\tint begin_addr;\n\tint end_addr;\n\tushort code_sum;\n\tint word;\n\tint i;\n\tint err;\n\tunsigned long chksum;\n\tushort scsi_cfg1;\n\tuchar byte;\n\tuchar tid;\n\tushort bios_mem[ASC_MC_BIOSLEN / 2];\t \n\tushort wdtr_able, sdtr_able, tagqng_able;\n\tuchar max_cmd[ADV_MAX_TID + 1];\n\n\t \n\tif (asc_dvc->err_code != 0)\n\t\treturn ADV_ERROR;\n\n\t \n\tif (asc_dvc->chip_type != ADV_CHIP_ASC38C0800) {\n\t\tasc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;\n\t\treturn ADV_ERROR;\n\t}\n\n\twarn_code = 0;\n\tiop_base = asc_dvc->iop_base;\n\n\t \n\tfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t \n\tAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\tAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\tAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\tmax_cmd[tid]);\n\t}\n\n\t \n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);\n\t\tmdelay(10);\t \n\t\tbyte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);\n\t\tif ((byte & RAM_TEST_DONE) == 0\n\t\t    || (byte & 0x0F) != PRE_TEST_VALUE) {\n\t\t\tasc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;\n\t\t\treturn ADV_ERROR;\n\t\t}\n\n\t\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);\n\t\tmdelay(10);\t \n\t\tif (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)\n\t\t    != NORMAL_VALUE) {\n\t\t\tasc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;\n\t\t\treturn ADV_ERROR;\n\t\t}\n\t}\n\n\t \n\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);\n\tmdelay(10);\t \n\n\tbyte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);\n\tif ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {\n\t\t \n\t\tasc_dvc->bist_err_code = byte;\t \n\t\tasc_dvc->err_code = ASC_IERR_BIST_RAM_TEST;\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);\n\n\terr = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"Failed to load image \\\"%s\\\" err %d\\n\",\n\t\t       fwname, err);\n\t\tasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\n\t\treturn err;\n\t}\n\tif (fw->size < 4) {\n\t\tprintk(KERN_ERR \"Bogus length %zu in image \\\"%s\\\"\\n\",\n\t\t       fw->size, fwname);\n\t\trelease_firmware(fw);\n\t\tasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\n\t\treturn -EINVAL;\n\t}\n\tchksum = (fw->data[3] << 24) | (fw->data[2] << 16) |\n\t\t (fw->data[1] << 8) | fw->data[0];\n\tasc_dvc->err_code = AdvLoadMicrocode(iop_base, &fw->data[4],\n\t\t\t\t\t     fw->size - 4, ADV_38C0800_MEMSIZE,\n\t\t\t\t\t     chksum);\n\trelease_firmware(fw);\n\tif (asc_dvc->err_code)\n\t\treturn ADV_ERROR;\n\n\t \n\tfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\n\t\tAdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\t bios_mem[i]);\n\t}\n\n\t \n\tAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tAdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tAdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += AdvReadWordAutoIncLram(iop_base);\n\t}\n\tAdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t \n\tAdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,\n\t\t\tasc_dvc->cfg->mcode_date);\n\tAdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,\n\t\t\tasc_dvc->cfg->mcode_version);\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C0800);\n\n\t \n\tscsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);\n\tAdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1,\n\t\t\t     scsi_cfg1 | DIS_TERM_DRV);\n\n\t \n\tif (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tAdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t \n\tAdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,\n\t\t\t     BC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH |\n\t\t\t     READ_CMD_MRM);\n\n\t \n\tif ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,\n\t\t\t\t asc_dvc->wdtr_able);\n\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,\n\t\t\t\t asc_dvc->sdtr_able);\n\t}\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,\n\t\t\t asc_dvc->cfg->disc_enable);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\t\t PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |\n\t\t\t asc_dvc->chip_scsi_id);\n\n\t \n\n\t \n\tscsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);\n\n\t \n\tif ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {\n\t\tasc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tif (scsi_cfg1 & HVD) {\n\t\tasc_dvc->err_code = ASC_IERR_HVD_DEVICE;\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tif ((asc_dvc->cfg->termination & TERM_SE) == 0) {\n\t\t \n\t\tswitch (scsi_cfg1 & C_DET_SE) {\n\t\t\t \n\t\tcase 0x1:\n\t\tcase 0x2:\n\t\tcase 0x3:\n\t\t\tasc_dvc->cfg->termination |= TERM_SE;\n\t\t\tbreak;\n\n\t\t\t \n\t\tcase 0x0:\n\t\t\tasc_dvc->cfg->termination |= TERM_SE_HI;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((asc_dvc->cfg->termination & TERM_LVD) == 0) {\n\t\t \n\t\tswitch (scsi_cfg1 & C_DET_LVD) {\n\t\t\t \n\t\tcase 0x4:\n\t\tcase 0x8:\n\t\tcase 0xC:\n\t\t\tasc_dvc->cfg->termination |= TERM_LVD;\n\t\t\tbreak;\n\n\t\t\t \n\t\tcase 0x0:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tscsi_cfg1 &= (~TERM_SE & ~TERM_LVD);\n\n\t \n\tscsi_cfg1 |= (~asc_dvc->cfg->termination & 0xF0);\n\n\t \n\tscsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL & ~HVD_LVD_SE);\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,\n\t\t\t BIOS_EN | RAM_SZ_16KB);\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,\n\t\t\t ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));\n\n\tAdvBuildCarrierFreelist(asc_dvc);\n\n\t \n\n\tasc_dvc->icq_sp = adv_get_next_carrier(asc_dvc);\n\tif (!asc_dvc->icq_sp) {\n\t\tASC_DBG(0, \"Failed to get ICQ carrier\\n\");\n\t\tasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tAdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);\n\n\t \n\tasc_dvc->irq_sp = adv_get_next_carrier(asc_dvc);\n\tif (!asc_dvc->irq_sp) {\n\t\tASC_DBG(0, \"Failed to get IRQ carrier\\n\");\n\t\tasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tAdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);\n\tasc_dvc->carr_pending_cnt = 0;\n\n\tAdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,\n\t\t\t     (ADV_INTR_ENABLE_HOST_INTR |\n\t\t\t      ADV_INTR_ENABLE_GLOBAL_INTR));\n\n\tAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);\n\tAdvWriteWordRegister(iop_base, IOPW_PC, word);\n\n\t \n\tAdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);\n\n\t \n\tif (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {\n\t\t \n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==\n\t\t    0x55AA) {\n\t\t\t \n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\t tagqng_able);\n\t\t\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\t\t\tAdvWriteByteLram(iop_base,\n\t\t\t\t\t\t ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\t\t max_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetSB(asc_dvc) != ADV_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn warn_code;\n}\n\n \nstatic int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)\n{\n\tconst struct firmware *fw;\n\tconst char fwname[] = \"advansys/38C1600.bin\";\n\tAdvPortAddr iop_base;\n\tushort warn_code;\n\tint begin_addr;\n\tint end_addr;\n\tushort code_sum;\n\tlong word;\n\tint i;\n\tint err;\n\tunsigned long chksum;\n\tushort scsi_cfg1;\n\tuchar byte;\n\tuchar tid;\n\tushort bios_mem[ASC_MC_BIOSLEN / 2];\t \n\tushort wdtr_able, sdtr_able, ppr_able, tagqng_able;\n\tuchar max_cmd[ASC_MAX_TID + 1];\n\n\t \n\tif (asc_dvc->err_code != 0) {\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tif (asc_dvc->chip_type != ADV_CHIP_ASC38C1600) {\n\t\tasc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;\n\t\treturn ADV_ERROR;\n\t}\n\n\twarn_code = 0;\n\tiop_base = asc_dvc->iop_base;\n\n\t \n\tfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t \n\tAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\tAdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);\n\tAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ASC_MAX_TID; tid++) {\n\t\tAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\tmax_cmd[tid]);\n\t}\n\n\t \n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);\n\t\tmdelay(10);\t \n\t\tbyte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);\n\t\tif ((byte & RAM_TEST_DONE) == 0\n\t\t    || (byte & 0x0F) != PRE_TEST_VALUE) {\n\t\t\tasc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;\n\t\t\treturn ADV_ERROR;\n\t\t}\n\n\t\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);\n\t\tmdelay(10);\t \n\t\tif (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)\n\t\t    != NORMAL_VALUE) {\n\t\t\tasc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;\n\t\t\treturn ADV_ERROR;\n\t\t}\n\t}\n\n\t \n\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);\n\tmdelay(10);\t \n\n\tbyte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);\n\tif ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {\n\t\t \n\t\tasc_dvc->bist_err_code = byte;\t \n\t\tasc_dvc->err_code = ASC_IERR_BIST_RAM_TEST;\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);\n\n\terr = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"Failed to load image \\\"%s\\\" err %d\\n\",\n\t\t       fwname, err);\n\t\tasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\n\t\treturn err;\n\t}\n\tif (fw->size < 4) {\n\t\tprintk(KERN_ERR \"Bogus length %zu in image \\\"%s\\\"\\n\",\n\t\t       fw->size, fwname);\n\t\trelease_firmware(fw);\n\t\tasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\n\t\treturn -EINVAL;\n\t}\n\tchksum = (fw->data[3] << 24) | (fw->data[2] << 16) |\n\t\t (fw->data[1] << 8) | fw->data[0];\n\tasc_dvc->err_code = AdvLoadMicrocode(iop_base, &fw->data[4],\n\t\t\t\t\t     fw->size - 4, ADV_38C1600_MEMSIZE,\n\t\t\t\t\t     chksum);\n\trelease_firmware(fw);\n\tif (asc_dvc->err_code)\n\t\treturn ADV_ERROR;\n\n\t \n\tfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\n\t\tAdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\t bios_mem[i]);\n\t}\n\n\t \n\tAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tAdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tAdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += AdvReadWordAutoIncLram(iop_base);\n\t}\n\tAdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t \n\tAdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,\n\t\t\tasc_dvc->cfg->mcode_date);\n\tAdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,\n\t\t\tasc_dvc->cfg->mcode_version);\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C1600);\n\n\t \n\tscsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);\n\tAdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1,\n\t\t\t     scsi_cfg1 | DIS_TERM_DRV);\n\n\t \n\tif (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tAdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t \n\tif ((asc_dvc->bios_ctrl & BIOS_CTRL_AIPP_DIS) == 0) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_ENABLE_AIPP;\n\t\tAdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t \n\tAdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,\n\t\t\t     FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);\n\n\t \n\tif ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,\n\t\t\t\t asc_dvc->wdtr_able);\n\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,\n\t\t\t\t asc_dvc->sdtr_able);\n\t}\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,\n\t\t\t asc_dvc->cfg->disc_enable);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\t\t PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |\n\t\t\t asc_dvc->chip_scsi_id);\n\n\t \n\tscsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);\n\n\t \n\tif ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {\n\t\tasc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tif (scsi_cfg1 & HVD) {\n\t\tasc_dvc->err_code |= ASC_IERR_HVD_DEVICE;\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tif ((asc_dvc->cfg->termination & TERM_SE) == 0) {\n\t\tstruct pci_dev *pdev = adv_dvc_to_pdev(asc_dvc);\n\t\t \n\t\tswitch (scsi_cfg1 & C_DET_SE) {\n\t\t\t \n\t\tcase 0x1:\n\t\tcase 0x2:\n\t\tcase 0x3:\n\t\t\tasc_dvc->cfg->termination |= TERM_SE;\n\t\t\tbreak;\n\n\t\tcase 0x0:\n\t\t\tif (PCI_FUNC(pdev->devfn) == 0) {\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tasc_dvc->cfg->termination |= TERM_SE_HI;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tscsi_cfg1 &= ~TERM_SE;\n\n\t \n\tscsi_cfg1 |= (~asc_dvc->cfg->termination & TERM_SE);\n\n\t \n\tscsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL);\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,\n\t\t\t BIOS_EN | RAM_SZ_16KB);\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,\n\t\t\t ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));\n\n\tAdvBuildCarrierFreelist(asc_dvc);\n\n\t \n\tasc_dvc->icq_sp = adv_get_next_carrier(asc_dvc);\n\tif (!asc_dvc->icq_sp) {\n\t\tasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tAdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);\n\tAdvWriteDWordRegister(iop_base, IOPDW_COMMA,\n\t\t\t      le32_to_cpu(asc_dvc->icq_sp->carr_pa));\n\n\t \n\tasc_dvc->irq_sp = adv_get_next_carrier(asc_dvc);\n\tif (!asc_dvc->irq_sp) {\n\t\tasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\n\t\treturn ADV_ERROR;\n\t}\n\n\t \n\tAdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);\n\tasc_dvc->carr_pending_cnt = 0;\n\n\tAdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,\n\t\t\t     (ADV_INTR_ENABLE_HOST_INTR |\n\t\t\t      ADV_INTR_ENABLE_GLOBAL_INTR));\n\tAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);\n\tAdvWriteWordRegister(iop_base, IOPW_PC, word);\n\n\t \n\tAdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);\n\n\t \n\tif (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {\n\t\t \n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==\n\t\t    0x55AA) {\n\t\t\t \n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\t tagqng_able);\n\t\t\tfor (tid = 0; tid <= ASC_MAX_TID; tid++) {\n\t\t\t\tAdvWriteByteLram(iop_base,\n\t\t\t\t\t\t ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\t\t max_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetSB(asc_dvc) != ADV_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn warn_code;\n}\n\n \nstatic int AdvResetChipAndSB(ADV_DVC_VAR *asc_dvc)\n{\n\tint status;\n\tushort wdtr_able, sdtr_able, tagqng_able;\n\tushort ppr_able = 0;\n\tuchar tid, max_cmd[ADV_MAX_TID + 1];\n\tAdvPortAddr iop_base;\n\tushort bios_sig;\n\n\tiop_base = asc_dvc->iop_base;\n\n\t \n\tAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\tif (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);\n\t}\n\tAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\tAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\tmax_cmd[tid]);\n\t}\n\n\t \n\tAdvReadWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\tAdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, 0);\n\n\t \n\tAdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_STOP);\n\tAdvWriteWordRegister(iop_base, IOPW_CTRL_REG, ADV_CTRL_REG_CMD_RESET);\n\tmdelay(100);\n\tAdvWriteWordRegister(iop_base, IOPW_CTRL_REG,\n\t\t\t     ADV_CTRL_REG_CMD_WR_IO_REG);\n\n\t \n\tasc_dvc->err_code = 0;\n\tif (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {\n\t\tstatus = AdvInitAsc38C1600Driver(asc_dvc);\n\t} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tstatus = AdvInitAsc38C0800Driver(asc_dvc);\n\t} else {\n\t\tstatus = AdvInitAsc3550Driver(asc_dvc);\n\t}\n\n\t \n\tif (status == 0) {\n\t\tstatus = ADV_TRUE;\n\t} else {\n\t\tstatus = ADV_FALSE;\n\t}\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\n\t \n\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\tif (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {\n\t\tAdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);\n\t}\n\tAdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\tAdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t max_cmd[tid]);\n\t}\n\n\treturn status;\n}\n\n \nstatic void adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)\n{\n\tswitch (code) {\n\tcase ADV_ASYNC_SCSI_BUS_RESET_DET:\n\t\t \n\t\tASC_DBG(0, \"ADV_ASYNC_SCSI_BUS_RESET_DET\\n\");\n\t\tbreak;\n\n\tcase ADV_ASYNC_RDMA_FAILURE:\n\t\t \n\t\tASC_DBG(0, \"ADV_ASYNC_RDMA_FAILURE\\n\");\n\t\tAdvResetChipAndSB(adv_dvc_varp);\n\t\tbreak;\n\n\tcase ADV_HOST_SCSI_BUS_RESET:\n\t\t \n\t\tASC_DBG(0, \"ADV_HOST_SCSI_BUS_RESET\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tASC_DBG(0, \"unknown code 0x%x\\n\", code);\n\t\tbreak;\n\t}\n}\n\n \nstatic void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)\n{\n\tstruct asc_board *boardp = adv_dvc_varp->drv_ptr;\n\tadv_req_t *reqp;\n\tadv_sgblk_t *sgblkp;\n\tstruct scsi_cmnd *scp;\n\tu32 resid_cnt;\n\tdma_addr_t sense_addr;\n\n\tASC_DBG(1, \"adv_dvc_varp 0x%p, scsiqp 0x%p\\n\",\n\t\tadv_dvc_varp, scsiqp);\n\tASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);\n\n\t \n\tscp = scsi_host_find_tag(boardp->shost, scsiqp->srb_tag);\n\n\tASC_DBG(1, \"scp 0x%p\\n\", scp);\n\tif (scp == NULL) {\n\t\tASC_PRINT\n\t\t    (\"adv_isr_callback: scp is NULL; adv_req_t dropped.\\n\");\n\t\treturn;\n\t}\n\tASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);\n\n\treqp = (adv_req_t *)scp->host_scribble;\n\tASC_DBG(1, \"reqp 0x%lx\\n\", (ulong)reqp);\n\tif (reqp == NULL) {\n\t\tASC_PRINT(\"adv_isr_callback: reqp is NULL\\n\");\n\t\treturn;\n\t}\n\t \n\tscp->host_scribble = NULL;\n\treqp->cmndp = NULL;\n\n\tASC_STATS(boardp->shost, callback);\n\tASC_DBG(1, \"shost 0x%p\\n\", boardp->shost);\n\n\tsense_addr = le32_to_cpu(scsiqp->sense_addr);\n\tdma_unmap_single(boardp->dev, sense_addr,\n\t\t\t SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\n\n\t \n\tscp->result = 0;\n\tswitch (scsiqp->done_status) {\n\tcase QD_NO_ERROR:\n\t\tASC_DBG(2, \"QD_NO_ERROR\\n\");\n\n\t\t \n\t\tresid_cnt = le32_to_cpu(scsiqp->data_cnt);\n\t\tif (scsi_bufflen(scp) != 0 && resid_cnt != 0 &&\n\t\t    resid_cnt <= scsi_bufflen(scp)) {\n\t\t\tASC_DBG(1, \"underrun condition %lu bytes\\n\",\n\t\t\t\t (ulong)resid_cnt);\n\t\t\tscsi_set_resid(scp, resid_cnt);\n\t\t}\n\t\tbreak;\n\n\tcase QD_WITH_ERROR:\n\t\tASC_DBG(2, \"QD_WITH_ERROR\\n\");\n\t\tswitch (scsiqp->host_status) {\n\t\tcase QHSTA_NO_ERROR:\n\t\t\tset_status_byte(scp, scsiqp->scsi_status);\n\t\t\tif (scsiqp->scsi_status == SAM_STAT_CHECK_CONDITION) {\n\t\t\t\tASC_DBG(2, \"SAM_STAT_CHECK_CONDITION\\n\");\n\t\t\t\tASC_DBG_PRT_SENSE(2, scp->sense_buffer,\n\t\t\t\t\t\t  SCSI_SENSE_BUFFERSIZE);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tASC_DBG(1, \"host_status 0x%x\\n\", scsiqp->host_status);\n\t\t\tset_host_byte(scp, DID_BAD_TARGET);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase QD_ABORTED_BY_HOST:\n\t\tASC_DBG(1, \"QD_ABORTED_BY_HOST\\n\");\n\t\tset_status_byte(scp, scsiqp->scsi_status);\n\t\tset_host_byte(scp, DID_ABORT);\n\t\tbreak;\n\n\tdefault:\n\t\tASC_DBG(1, \"done_status 0x%x\\n\", scsiqp->done_status);\n\t\tset_status_byte(scp, scsiqp->scsi_status);\n\t\tset_host_byte(scp, DID_ERROR);\n\t\tbreak;\n\t}\n\n\t \n\tif ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&\n\t    scsiqp->done_status == QD_NO_ERROR &&\n\t    scsiqp->host_status == QHSTA_NO_ERROR) {\n\t\tboardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);\n\t}\n\n\tasc_scsi_done(scp);\n\n\t \n\twhile ((sgblkp = reqp->sgblkp) != NULL) {\n\t\t \n\t\treqp->sgblkp = sgblkp->next_sgblkp;\n\n\t\tdma_pool_free(boardp->adv_sgblk_pool, sgblkp,\n\t\t\t      sgblkp->sg_addr);\n\t}\n\n\tASC_DBG(1, \"done\\n\");\n}\n\n \nstatic int AdvISR(ADV_DVC_VAR *asc_dvc)\n{\n\tAdvPortAddr iop_base;\n\tuchar int_stat;\n\tADV_CARR_T *free_carrp;\n\t__le32 irq_next_vpa;\n\tADV_SCSI_REQ_Q *scsiq;\n\tadv_req_t *reqp;\n\n\tiop_base = asc_dvc->iop_base;\n\n\t \n\tint_stat = AdvReadByteRegister(iop_base, IOPB_INTR_STATUS_REG);\n\n\tif ((int_stat & (ADV_INTR_STATUS_INTRA | ADV_INTR_STATUS_INTRB |\n\t\t\t ADV_INTR_STATUS_INTRC)) == 0) {\n\t\treturn ADV_FALSE;\n\t}\n\n\t \n\tif (int_stat & ADV_INTR_STATUS_INTRB) {\n\t\tuchar intrb_code;\n\n\t\tAdvReadByteLram(iop_base, ASC_MC_INTRB_CODE, intrb_code);\n\n\t\tif (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||\n\t\t    asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\t\tif (intrb_code == ADV_ASYNC_CARRIER_READY_FAILURE &&\n\t\t\t    asc_dvc->carr_pending_cnt != 0) {\n\t\t\t\tAdvWriteByteRegister(iop_base, IOPB_TICKLE,\n\t\t\t\t\t\t     ADV_TICKLE_A);\n\t\t\t\tif (asc_dvc->chip_type == ADV_CHIP_ASC3550) {\n\t\t\t\t\tAdvWriteByteRegister(iop_base,\n\t\t\t\t\t\t\t     IOPB_TICKLE,\n\t\t\t\t\t\t\t     ADV_TICKLE_NOP);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tadv_async_callback(asc_dvc, intrb_code);\n\t}\n\n\t \n\twhile (((irq_next_vpa =\n\t\t le32_to_cpu(asc_dvc->irq_sp->next_vpa)) & ADV_RQ_DONE) != 0) {\n\t\t \n\t\tu32 pa_offset = le32_to_cpu(asc_dvc->irq_sp->areq_vpa);\n\t\tASC_DBG(1, \"irq_sp %p areq_vpa %u\\n\",\n\t\t\tasc_dvc->irq_sp, pa_offset);\n\t\treqp = adv_get_reqp(asc_dvc, pa_offset);\n\t\tscsiq = &reqp->scsi_req_q;\n\n\t\t \n\t\tif ((irq_next_vpa & ADV_RQ_GOOD) != 0) {\n\t\t\tscsiq->done_status = QD_NO_ERROR;\n\t\t\tscsiq->host_status = scsiq->scsi_status = 0;\n\t\t\tscsiq->data_cnt = 0L;\n\t\t}\n\n\t\t \n\t\tfree_carrp = asc_dvc->irq_sp;\n\t\tasc_dvc->irq_sp = adv_get_carrier(asc_dvc,\n\t\t\t\t\t\t  ADV_GET_CARRP(irq_next_vpa));\n\n\t\tfree_carrp->next_vpa = asc_dvc->carr_freelist->carr_va;\n\t\tasc_dvc->carr_freelist = free_carrp;\n\t\tasc_dvc->carr_pending_cnt--;\n\n\t\t \n\t\tscsiq->cntl = 0;\n\n\t\t \n\t\tadv_isr_callback(asc_dvc, scsiq);\n\t\t \n\t}\n\treturn ADV_TRUE;\n}\n\nstatic int AscSetLibErrorCode(ASC_DVC_VAR *asc_dvc, ushort err_code)\n{\n\tif (asc_dvc->err_code == 0) {\n\t\tasc_dvc->err_code = err_code;\n\t\tAscWriteLramWord(asc_dvc->iop_base, ASCV_ASCDVC_ERR_CODE_W,\n\t\t\t\t err_code);\n\t}\n\treturn err_code;\n}\n\nstatic void AscAckInterrupt(PortAddr iop_base)\n{\n\tuchar host_flag;\n\tuchar risc_flag;\n\tushort loop;\n\n\tloop = 0;\n\tdo {\n\t\trisc_flag = AscReadLramByte(iop_base, ASCV_RISC_FLAG_B);\n\t\tif (loop++ > 0x7FFF) {\n\t\t\tbreak;\n\t\t}\n\t} while ((risc_flag & ASC_RISC_FLAG_GEN_INT) != 0);\n\thost_flag =\n\t    AscReadLramByte(iop_base,\n\t\t\t    ASCV_HOST_FLAG_B) & (~ASC_HOST_FLAG_ACK_INT);\n\tAscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,\n\t\t\t (uchar)(host_flag | ASC_HOST_FLAG_ACK_INT));\n\tAscSetChipStatus(iop_base, CIW_INT_ACK);\n\tloop = 0;\n\twhile (AscGetChipStatus(iop_base) & CSW_INT_PENDING) {\n\t\tAscSetChipStatus(iop_base, CIW_INT_ACK);\n\t\tif (loop++ > 3) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tAscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);\n}\n\nstatic uchar AscGetSynPeriodIndex(ASC_DVC_VAR *asc_dvc, uchar syn_time)\n{\n\tconst uchar *period_table;\n\tint max_index;\n\tint min_index;\n\tint i;\n\n\tperiod_table = asc_dvc->sdtr_period_tbl;\n\tmax_index = (int)asc_dvc->max_sdtr_index;\n\tmin_index = (int)asc_dvc->min_sdtr_index;\n\tif ((syn_time <= period_table[max_index])) {\n\t\tfor (i = min_index; i < (max_index - 1); i++) {\n\t\t\tif (syn_time <= period_table[i]) {\n\t\t\t\treturn (uchar)i;\n\t\t\t}\n\t\t}\n\t\treturn (uchar)max_index;\n\t} else {\n\t\treturn (uchar)(max_index + 1);\n\t}\n}\n\nstatic uchar\nAscMsgOutSDTR(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar sdtr_offset)\n{\n\tPortAddr iop_base = asc_dvc->iop_base;\n\tuchar sdtr_period_index = AscGetSynPeriodIndex(asc_dvc, sdtr_period);\n\tEXT_MSG sdtr_buf = {\n\t\t.msg_type = EXTENDED_MESSAGE,\n\t\t.msg_len = MS_SDTR_LEN,\n\t\t.msg_req = EXTENDED_SDTR,\n\t\t.xfer_period = sdtr_period,\n\t\t.req_ack_offset = sdtr_offset,\n\t};\n\tsdtr_offset &= ASC_SYN_MAX_OFFSET;\n\n\tif (sdtr_period_index <= asc_dvc->max_sdtr_index) {\n\t\tAscMemWordCopyPtrToLram(iop_base, ASCV_MSGOUT_BEG,\n\t\t\t\t\t(uchar *)&sdtr_buf,\n\t\t\t\t\tsizeof(EXT_MSG) >> 1);\n\t\treturn ((sdtr_period_index << 4) | sdtr_offset);\n\t} else {\n\t\tsdtr_buf.req_ack_offset = 0;\n\t\tAscMemWordCopyPtrToLram(iop_base, ASCV_MSGOUT_BEG,\n\t\t\t\t\t(uchar *)&sdtr_buf,\n\t\t\t\t\tsizeof(EXT_MSG) >> 1);\n\t\treturn 0;\n\t}\n}\n\nstatic uchar\nAscCalSDTRData(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar syn_offset)\n{\n\tuchar byte;\n\tuchar sdtr_period_ix;\n\n\tsdtr_period_ix = AscGetSynPeriodIndex(asc_dvc, sdtr_period);\n\tif (sdtr_period_ix > asc_dvc->max_sdtr_index)\n\t\treturn 0xFF;\n\tbyte = (sdtr_period_ix << 4) | (syn_offset & ASC_SYN_MAX_OFFSET);\n\treturn byte;\n}\n\nstatic bool AscSetChipSynRegAtID(PortAddr iop_base, uchar id, uchar sdtr_data)\n{\n\tASC_SCSI_BIT_ID_TYPE org_id;\n\tint i;\n\tbool sta = true;\n\n\tAscSetBank(iop_base, 1);\n\torg_id = AscReadChipDvcID(iop_base);\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tif (org_id == (0x01 << i))\n\t\t\tbreak;\n\t}\n\torg_id = (ASC_SCSI_BIT_ID_TYPE) i;\n\tAscWriteChipDvcID(iop_base, id);\n\tif (AscReadChipDvcID(iop_base) == (0x01 << id)) {\n\t\tAscSetBank(iop_base, 0);\n\t\tAscSetChipSyn(iop_base, sdtr_data);\n\t\tif (AscGetChipSyn(iop_base) != sdtr_data) {\n\t\t\tsta = false;\n\t\t}\n\t} else {\n\t\tsta = false;\n\t}\n\tAscSetBank(iop_base, 1);\n\tAscWriteChipDvcID(iop_base, org_id);\n\tAscSetBank(iop_base, 0);\n\treturn (sta);\n}\n\nstatic void AscSetChipSDTR(PortAddr iop_base, uchar sdtr_data, uchar tid_no)\n{\n\tAscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);\n\tAscPutMCodeSDTRDoneAtID(iop_base, tid_no, sdtr_data);\n}\n\nstatic void AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)\n{\n\tEXT_MSG ext_msg;\n\tEXT_MSG out_msg;\n\tushort halt_q_addr;\n\tbool sdtr_accept;\n\tushort int_halt_code;\n\tASC_SCSI_BIT_ID_TYPE scsi_busy;\n\tASC_SCSI_BIT_ID_TYPE target_id;\n\tPortAddr iop_base;\n\tuchar tag_code;\n\tuchar q_status;\n\tuchar halt_qp;\n\tuchar sdtr_data;\n\tuchar target_ix;\n\tuchar q_cntl, tid_no;\n\tuchar cur_dvc_qng;\n\tuchar asyn_sdtr;\n\tuchar scsi_status;\n\tstruct asc_board *boardp;\n\n\tBUG_ON(!asc_dvc->drv_ptr);\n\tboardp = asc_dvc->drv_ptr;\n\n\tiop_base = asc_dvc->iop_base;\n\tint_halt_code = AscReadLramWord(iop_base, ASCV_HALTCODE_W);\n\n\thalt_qp = AscReadLramByte(iop_base, ASCV_CURCDB_B);\n\thalt_q_addr = ASC_QNO_TO_QADDR(halt_qp);\n\ttarget_ix = AscReadLramByte(iop_base,\n\t\t\t\t    (ushort)(halt_q_addr +\n\t\t\t\t\t     (ushort)ASC_SCSIQ_B_TARGET_IX));\n\tq_cntl = AscReadLramByte(iop_base,\n\t\t\t    (ushort)(halt_q_addr + (ushort)ASC_SCSIQ_B_CNTL));\n\ttid_no = ASC_TIX_TO_TID(target_ix);\n\ttarget_id = (uchar)ASC_TID_TO_TARGET_ID(tid_no);\n\tif (asc_dvc->pci_fix_asyn_xfer & target_id) {\n\t\tasyn_sdtr = ASYN_SDTR_DATA_FIX_PCI_REV_AB;\n\t} else {\n\t\tasyn_sdtr = 0;\n\t}\n\tif (int_halt_code == ASC_HALT_DISABLE_ASYN_USE_SYN_FIX) {\n\t\tif (asc_dvc->pci_fix_asyn_xfer & target_id) {\n\t\t\tAscSetChipSDTR(iop_base, 0, tid_no);\n\t\t\tboardp->sdtr_data[tid_no] = 0;\n\t\t}\n\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\treturn;\n\t} else if (int_halt_code == ASC_HALT_ENABLE_ASYN_USE_SYN_FIX) {\n\t\tif (asc_dvc->pci_fix_asyn_xfer & target_id) {\n\t\t\tAscSetChipSDTR(iop_base, asyn_sdtr, tid_no);\n\t\t\tboardp->sdtr_data[tid_no] = asyn_sdtr;\n\t\t}\n\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\treturn;\n\t} else if (int_halt_code == ASC_HALT_EXTMSG_IN) {\n\t\tAscMemWordCopyPtrFromLram(iop_base,\n\t\t\t\t\t  ASCV_MSGIN_BEG,\n\t\t\t\t\t  (uchar *)&ext_msg,\n\t\t\t\t\t  sizeof(EXT_MSG) >> 1);\n\n\t\tif (ext_msg.msg_type == EXTENDED_MESSAGE &&\n\t\t    ext_msg.msg_req == EXTENDED_SDTR &&\n\t\t    ext_msg.msg_len == MS_SDTR_LEN) {\n\t\t\tsdtr_accept = true;\n\t\t\tif ((ext_msg.req_ack_offset > ASC_SYN_MAX_OFFSET)) {\n\n\t\t\t\tsdtr_accept = false;\n\t\t\t\text_msg.req_ack_offset = ASC_SYN_MAX_OFFSET;\n\t\t\t}\n\t\t\tif ((ext_msg.xfer_period <\n\t\t\t     asc_dvc->sdtr_period_tbl[asc_dvc->min_sdtr_index])\n\t\t\t    || (ext_msg.xfer_period >\n\t\t\t\tasc_dvc->sdtr_period_tbl[asc_dvc->\n\t\t\t\t\t\t\t max_sdtr_index])) {\n\t\t\t\tsdtr_accept = false;\n\t\t\t\text_msg.xfer_period =\n\t\t\t\t    asc_dvc->sdtr_period_tbl[asc_dvc->\n\t\t\t\t\t\t\t     min_sdtr_index];\n\t\t\t}\n\t\t\tif (sdtr_accept) {\n\t\t\t\tsdtr_data =\n\t\t\t\t    AscCalSDTRData(asc_dvc, ext_msg.xfer_period,\n\t\t\t\t\t\t   ext_msg.req_ack_offset);\n\t\t\t\tif (sdtr_data == 0xFF) {\n\n\t\t\t\t\tq_cntl |= QC_MSG_OUT;\n\t\t\t\t\tasc_dvc->init_sdtr &= ~target_id;\n\t\t\t\t\tasc_dvc->sdtr_done &= ~target_id;\n\t\t\t\t\tAscSetChipSDTR(iop_base, asyn_sdtr,\n\t\t\t\t\t\t       tid_no);\n\t\t\t\t\tboardp->sdtr_data[tid_no] = asyn_sdtr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ext_msg.req_ack_offset == 0) {\n\n\t\t\t\tq_cntl &= ~QC_MSG_OUT;\n\t\t\t\tasc_dvc->init_sdtr &= ~target_id;\n\t\t\t\tasc_dvc->sdtr_done &= ~target_id;\n\t\t\t\tAscSetChipSDTR(iop_base, asyn_sdtr, tid_no);\n\t\t\t} else {\n\t\t\t\tif (sdtr_accept && (q_cntl & QC_MSG_OUT)) {\n\t\t\t\t\tq_cntl &= ~QC_MSG_OUT;\n\t\t\t\t\tasc_dvc->sdtr_done |= target_id;\n\t\t\t\t\tasc_dvc->init_sdtr |= target_id;\n\t\t\t\t\tasc_dvc->pci_fix_asyn_xfer &=\n\t\t\t\t\t    ~target_id;\n\t\t\t\t\tsdtr_data =\n\t\t\t\t\t    AscCalSDTRData(asc_dvc,\n\t\t\t\t\t\t\t   ext_msg.xfer_period,\n\t\t\t\t\t\t\t   ext_msg.\n\t\t\t\t\t\t\t   req_ack_offset);\n\t\t\t\t\tAscSetChipSDTR(iop_base, sdtr_data,\n\t\t\t\t\t\t       tid_no);\n\t\t\t\t\tboardp->sdtr_data[tid_no] = sdtr_data;\n\t\t\t\t} else {\n\t\t\t\t\tq_cntl |= QC_MSG_OUT;\n\t\t\t\t\tAscMsgOutSDTR(asc_dvc,\n\t\t\t\t\t\t      ext_msg.xfer_period,\n\t\t\t\t\t\t      ext_msg.req_ack_offset);\n\t\t\t\t\tasc_dvc->pci_fix_asyn_xfer &=\n\t\t\t\t\t    ~target_id;\n\t\t\t\t\tsdtr_data =\n\t\t\t\t\t    AscCalSDTRData(asc_dvc,\n\t\t\t\t\t\t\t   ext_msg.xfer_period,\n\t\t\t\t\t\t\t   ext_msg.\n\t\t\t\t\t\t\t   req_ack_offset);\n\t\t\t\t\tAscSetChipSDTR(iop_base, sdtr_data,\n\t\t\t\t\t\t       tid_no);\n\t\t\t\t\tboardp->sdtr_data[tid_no] = sdtr_data;\n\t\t\t\t\tasc_dvc->sdtr_done |= target_id;\n\t\t\t\t\tasc_dvc->init_sdtr |= target_id;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tAscWriteLramByte(iop_base,\n\t\t\t\t\t (ushort)(halt_q_addr +\n\t\t\t\t\t\t  (ushort)ASC_SCSIQ_B_CNTL),\n\t\t\t\t\t q_cntl);\n\t\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\t\treturn;\n\t\t} else if (ext_msg.msg_type == EXTENDED_MESSAGE &&\n\t\t\t   ext_msg.msg_req == EXTENDED_WDTR &&\n\t\t\t   ext_msg.msg_len == MS_WDTR_LEN) {\n\n\t\t\text_msg.wdtr_width = 0;\n\t\t\tAscMemWordCopyPtrToLram(iop_base,\n\t\t\t\t\t\tASCV_MSGOUT_BEG,\n\t\t\t\t\t\t(uchar *)&ext_msg,\n\t\t\t\t\t\tsizeof(EXT_MSG) >> 1);\n\t\t\tq_cntl |= QC_MSG_OUT;\n\t\t\tAscWriteLramByte(iop_base,\n\t\t\t\t\t (ushort)(halt_q_addr +\n\t\t\t\t\t\t  (ushort)ASC_SCSIQ_B_CNTL),\n\t\t\t\t\t q_cntl);\n\t\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\t\treturn;\n\t\t} else {\n\n\t\t\text_msg.msg_type = MESSAGE_REJECT;\n\t\t\tAscMemWordCopyPtrToLram(iop_base,\n\t\t\t\t\t\tASCV_MSGOUT_BEG,\n\t\t\t\t\t\t(uchar *)&ext_msg,\n\t\t\t\t\t\tsizeof(EXT_MSG) >> 1);\n\t\t\tq_cntl |= QC_MSG_OUT;\n\t\t\tAscWriteLramByte(iop_base,\n\t\t\t\t\t (ushort)(halt_q_addr +\n\t\t\t\t\t\t  (ushort)ASC_SCSIQ_B_CNTL),\n\t\t\t\t\t q_cntl);\n\t\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\t\treturn;\n\t\t}\n\t} else if (int_halt_code == ASC_HALT_CHK_CONDITION) {\n\n\t\tq_cntl |= QC_REQ_SENSE;\n\n\t\tif ((asc_dvc->init_sdtr & target_id) != 0) {\n\n\t\t\tasc_dvc->sdtr_done &= ~target_id;\n\n\t\t\tsdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);\n\t\t\tq_cntl |= QC_MSG_OUT;\n\t\t\tAscMsgOutSDTR(asc_dvc,\n\t\t\t\t      asc_dvc->\n\t\t\t\t      sdtr_period_tbl[(sdtr_data >> 4) &\n\t\t\t\t\t\t      (uchar)(asc_dvc->\n\t\t\t\t\t\t\t      max_sdtr_index -\n\t\t\t\t\t\t\t      1)],\n\t\t\t\t      (uchar)(sdtr_data & (uchar)\n\t\t\t\t\t      ASC_SYN_MAX_OFFSET));\n\t\t}\n\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(halt_q_addr +\n\t\t\t\t\t  (ushort)ASC_SCSIQ_B_CNTL), q_cntl);\n\n\t\ttag_code = AscReadLramByte(iop_base,\n\t\t\t\t\t   (ushort)(halt_q_addr + (ushort)\n\t\t\t\t\t\t    ASC_SCSIQ_B_TAG_CODE));\n\t\ttag_code &= 0xDC;\n\t\tif ((asc_dvc->pci_fix_asyn_xfer & target_id)\n\t\t    && !(asc_dvc->pci_fix_asyn_xfer_always & target_id)\n\t\t    ) {\n\n\t\t\ttag_code |= (ASC_TAG_FLAG_DISABLE_DISCONNECT\n\t\t\t\t     | ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX);\n\n\t\t}\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(halt_q_addr +\n\t\t\t\t\t  (ushort)ASC_SCSIQ_B_TAG_CODE),\n\t\t\t\t tag_code);\n\n\t\tq_status = AscReadLramByte(iop_base,\n\t\t\t\t\t   (ushort)(halt_q_addr + (ushort)\n\t\t\t\t\t\t    ASC_SCSIQ_B_STATUS));\n\t\tq_status |= (QS_READY | QS_BUSY);\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(halt_q_addr +\n\t\t\t\t\t  (ushort)ASC_SCSIQ_B_STATUS),\n\t\t\t\t q_status);\n\n\t\tscsi_busy = AscReadLramByte(iop_base, (ushort)ASCV_SCSIBUSY_B);\n\t\tscsi_busy &= ~target_id;\n\t\tAscWriteLramByte(iop_base, (ushort)ASCV_SCSIBUSY_B, scsi_busy);\n\n\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\treturn;\n\t} else if (int_halt_code == ASC_HALT_SDTR_REJECTED) {\n\n\t\tAscMemWordCopyPtrFromLram(iop_base,\n\t\t\t\t\t  ASCV_MSGOUT_BEG,\n\t\t\t\t\t  (uchar *)&out_msg,\n\t\t\t\t\t  sizeof(EXT_MSG) >> 1);\n\n\t\tif ((out_msg.msg_type == EXTENDED_MESSAGE) &&\n\t\t    (out_msg.msg_len == MS_SDTR_LEN) &&\n\t\t    (out_msg.msg_req == EXTENDED_SDTR)) {\n\n\t\t\tasc_dvc->init_sdtr &= ~target_id;\n\t\t\tasc_dvc->sdtr_done &= ~target_id;\n\t\t\tAscSetChipSDTR(iop_base, asyn_sdtr, tid_no);\n\t\t\tboardp->sdtr_data[tid_no] = asyn_sdtr;\n\t\t}\n\t\tq_cntl &= ~QC_MSG_OUT;\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(halt_q_addr +\n\t\t\t\t\t  (ushort)ASC_SCSIQ_B_CNTL), q_cntl);\n\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\treturn;\n\t} else if (int_halt_code == ASC_HALT_SS_QUEUE_FULL) {\n\n\t\tscsi_status = AscReadLramByte(iop_base,\n\t\t\t\t\t      (ushort)((ushort)halt_q_addr +\n\t\t\t\t\t\t       (ushort)\n\t\t\t\t\t\t       ASC_SCSIQ_SCSI_STATUS));\n\t\tcur_dvc_qng =\n\t\t    AscReadLramByte(iop_base,\n\t\t\t\t    (ushort)((ushort)ASC_QADR_BEG +\n\t\t\t\t\t     (ushort)target_ix));\n\t\tif ((cur_dvc_qng > 0) && (asc_dvc->cur_dvc_qng[tid_no] > 0)) {\n\n\t\t\tscsi_busy = AscReadLramByte(iop_base,\n\t\t\t\t\t\t    (ushort)ASCV_SCSIBUSY_B);\n\t\t\tscsi_busy |= target_id;\n\t\t\tAscWriteLramByte(iop_base,\n\t\t\t\t\t (ushort)ASCV_SCSIBUSY_B, scsi_busy);\n\t\t\tasc_dvc->queue_full_or_busy |= target_id;\n\n\t\t\tif (scsi_status == SAM_STAT_TASK_SET_FULL) {\n\t\t\t\tif (cur_dvc_qng > ASC_MIN_TAGGED_CMD) {\n\t\t\t\t\tcur_dvc_qng -= 1;\n\t\t\t\t\tasc_dvc->max_dvc_qng[tid_no] =\n\t\t\t\t\t    cur_dvc_qng;\n\n\t\t\t\t\tAscWriteLramByte(iop_base,\n\t\t\t\t\t\t\t (ushort)((ushort)\n\t\t\t\t\t\t\t\t  ASCV_MAX_DVC_QNG_BEG\n\t\t\t\t\t\t\t\t  + (ushort)\n\t\t\t\t\t\t\t\t  tid_no),\n\t\t\t\t\t\t\t cur_dvc_qng);\n\n\t\t\t\t\t \n\t\t\t\t\tboardp->queue_full |= target_id;\n\t\t\t\t\tboardp->queue_full_cnt[tid_no] =\n\t\t\t\t\t    cur_dvc_qng;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\treturn;\n\t}\n\treturn;\n}\n\n \nstatic void\nDvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)\n{\n\tint i;\n\tushort word;\n\n\tAscSetChipLramAddr(iop_base, s_addr);\n\tfor (i = 0; i < 2 * words; i += 2) {\n\t\tif (i == 10) {\n\t\t\tcontinue;\n\t\t}\n\t\tword = inpw(iop_base + IOP_RAM_DATA);\n\t\tinbuf[i] = word & 0xff;\n\t\tinbuf[i + 1] = (word >> 8) & 0xff;\n\t}\n\tASC_DBG_PRT_HEX(2, \"DvcGetQinfo\", inbuf, 2 * words);\n}\n\nstatic uchar\n_AscCopyLramScsiDoneQ(PortAddr iop_base,\n\t\t      ushort q_addr,\n\t\t      ASC_QDONE_INFO *scsiq, unsigned int max_dma_count)\n{\n\tushort _val;\n\tuchar sg_queue_cnt;\n\n\tDvcGetQinfo(iop_base,\n\t\t    q_addr + ASC_SCSIQ_DONE_INFO_BEG,\n\t\t    (uchar *)scsiq,\n\t\t    (sizeof(ASC_SCSIQ_2) + sizeof(ASC_SCSIQ_3)) / 2);\n\n\t_val = AscReadLramWord(iop_base,\n\t\t\t       (ushort)(q_addr + (ushort)ASC_SCSIQ_B_STATUS));\n\tscsiq->q_status = (uchar)_val;\n\tscsiq->q_no = (uchar)(_val >> 8);\n\t_val = AscReadLramWord(iop_base,\n\t\t\t       (ushort)(q_addr + (ushort)ASC_SCSIQ_B_CNTL));\n\tscsiq->cntl = (uchar)_val;\n\tsg_queue_cnt = (uchar)(_val >> 8);\n\t_val = AscReadLramWord(iop_base,\n\t\t\t       (ushort)(q_addr +\n\t\t\t\t\t(ushort)ASC_SCSIQ_B_SENSE_LEN));\n\tscsiq->sense_len = (uchar)_val;\n\tscsiq->extra_bytes = (uchar)(_val >> 8);\n\n\t \n\tscsiq->remain_bytes = (((u32)AscReadLramWord(iop_base,\n\t\t\t\t\t\t     (ushort)(q_addr +\n\t\t\t\t\t\t\t      (ushort)\n\t\t\t\t\t\t\t      ASC_SCSIQ_W_ALT_DC1)))\n\t\t\t       << 16);\n\t \n\tscsiq->remain_bytes += AscReadLramWord(iop_base,\n\t\t\t\t\t       (ushort)(q_addr + (ushort)\n\t\t\t\t\t\t\tASC_SCSIQ_DW_REMAIN_XFER_CNT));\n\n\tscsiq->remain_bytes &= max_dma_count;\n\treturn sg_queue_cnt;\n}\n\n \nstatic void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)\n{\n\tstruct asc_board *boardp = asc_dvc_varp->drv_ptr;\n\tu32 srb_tag;\n\tstruct scsi_cmnd *scp;\n\n\tASC_DBG(1, \"asc_dvc_varp 0x%p, qdonep 0x%p\\n\", asc_dvc_varp, qdonep);\n\tASC_DBG_PRT_ASC_QDONE_INFO(2, qdonep);\n\n\t \n\tsrb_tag = qdonep->d2.srb_tag - 1;\n\tscp = scsi_host_find_tag(boardp->shost, srb_tag);\n\tif (!scp)\n\t\treturn;\n\n\tASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);\n\n\tASC_STATS(boardp->shost, callback);\n\n\tdma_unmap_single(boardp->dev, advansys_cmd(scp)->dma_handle,\n\t\t\t SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\n\t \n\tscp->result = 0;\n\tswitch (qdonep->d3.done_stat) {\n\tcase QD_NO_ERROR:\n\t\tASC_DBG(2, \"QD_NO_ERROR\\n\");\n\n\t\t \n\t\tif (scsi_bufflen(scp) != 0 && qdonep->remain_bytes != 0 &&\n\t\t    qdonep->remain_bytes <= scsi_bufflen(scp)) {\n\t\t\tASC_DBG(1, \"underrun condition %u bytes\\n\",\n\t\t\t\t (unsigned)qdonep->remain_bytes);\n\t\t\tscsi_set_resid(scp, qdonep->remain_bytes);\n\t\t}\n\t\tbreak;\n\n\tcase QD_WITH_ERROR:\n\t\tASC_DBG(2, \"QD_WITH_ERROR\\n\");\n\t\tswitch (qdonep->d3.host_stat) {\n\t\tcase QHSTA_NO_ERROR:\n\t\t\tset_status_byte(scp, qdonep->d3.scsi_stat);\n\t\t\tif (qdonep->d3.scsi_stat == SAM_STAT_CHECK_CONDITION) {\n\t\t\t\tASC_DBG(2, \"SAM_STAT_CHECK_CONDITION\\n\");\n\t\t\t\tASC_DBG_PRT_SENSE(2, scp->sense_buffer,\n\t\t\t\t\t\t  SCSI_SENSE_BUFFERSIZE);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tASC_DBG(1, \"host_stat 0x%x\\n\", qdonep->d3.host_stat);\n\t\t\tset_host_byte(scp, DID_BAD_TARGET);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase QD_ABORTED_BY_HOST:\n\t\tASC_DBG(1, \"QD_ABORTED_BY_HOST\\n\");\n\t\tset_status_byte(scp, qdonep->d3.scsi_stat);\n\t\tset_host_byte(scp, DID_ABORT);\n\t\tbreak;\n\n\tdefault:\n\t\tASC_DBG(1, \"done_stat 0x%x\\n\", qdonep->d3.done_stat);\n\t\tset_status_byte(scp, qdonep->d3.scsi_stat);\n\t\tset_host_byte(scp, DID_ERROR);\n\t\tbreak;\n\t}\n\n\t \n\tif ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&\n\t    qdonep->d3.done_stat == QD_NO_ERROR &&\n\t    qdonep->d3.host_stat == QHSTA_NO_ERROR) {\n\t\tboardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);\n\t}\n\n\tasc_scsi_done(scp);\n}\n\nstatic int AscIsrQDone(ASC_DVC_VAR *asc_dvc)\n{\n\tuchar next_qp;\n\tuchar n_q_used;\n\tuchar sg_list_qp;\n\tuchar sg_queue_cnt;\n\tuchar q_cnt;\n\tuchar done_q_tail;\n\tuchar tid_no;\n\tASC_SCSI_BIT_ID_TYPE scsi_busy;\n\tASC_SCSI_BIT_ID_TYPE target_id;\n\tPortAddr iop_base;\n\tushort q_addr;\n\tushort sg_q_addr;\n\tuchar cur_target_qng;\n\tASC_QDONE_INFO scsiq_buf;\n\tASC_QDONE_INFO *scsiq;\n\tbool false_overrun;\n\n\tiop_base = asc_dvc->iop_base;\n\tn_q_used = 1;\n\tscsiq = (ASC_QDONE_INFO *)&scsiq_buf;\n\tdone_q_tail = (uchar)AscGetVarDoneQTail(iop_base);\n\tq_addr = ASC_QNO_TO_QADDR(done_q_tail);\n\tnext_qp = AscReadLramByte(iop_base,\n\t\t\t\t  (ushort)(q_addr + (ushort)ASC_SCSIQ_B_FWD));\n\tif (next_qp != ASC_QLINK_END) {\n\t\tAscPutVarDoneQTail(iop_base, next_qp);\n\t\tq_addr = ASC_QNO_TO_QADDR(next_qp);\n\t\tsg_queue_cnt = _AscCopyLramScsiDoneQ(iop_base, q_addr, scsiq,\n\t\t\t\t\t\t     asc_dvc->max_dma_count);\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(q_addr +\n\t\t\t\t\t  (ushort)ASC_SCSIQ_B_STATUS),\n\t\t\t\t (uchar)(scsiq->\n\t\t\t\t\t q_status & (uchar)~(QS_READY |\n\t\t\t\t\t\t\t     QS_ABORTED)));\n\t\ttid_no = ASC_TIX_TO_TID(scsiq->d2.target_ix);\n\t\ttarget_id = ASC_TIX_TO_TARGET_ID(scsiq->d2.target_ix);\n\t\tif ((scsiq->cntl & QC_SG_HEAD) != 0) {\n\t\t\tsg_q_addr = q_addr;\n\t\t\tsg_list_qp = next_qp;\n\t\t\tfor (q_cnt = 0; q_cnt < sg_queue_cnt; q_cnt++) {\n\t\t\t\tsg_list_qp = AscReadLramByte(iop_base,\n\t\t\t\t\t\t\t     (ushort)(sg_q_addr\n\t\t\t\t\t\t\t\t      + (ushort)\n\t\t\t\t\t\t\t\t      ASC_SCSIQ_B_FWD));\n\t\t\t\tsg_q_addr = ASC_QNO_TO_QADDR(sg_list_qp);\n\t\t\t\tif (sg_list_qp == ASC_QLINK_END) {\n\t\t\t\t\tAscSetLibErrorCode(asc_dvc,\n\t\t\t\t\t\t\t   ASCQ_ERR_SG_Q_LINKS);\n\t\t\t\t\tscsiq->d3.done_stat = QD_WITH_ERROR;\n\t\t\t\t\tscsiq->d3.host_stat =\n\t\t\t\t\t    QHSTA_D_QDONE_SG_LIST_CORRUPTED;\n\t\t\t\t\tgoto FATAL_ERR_QDONE;\n\t\t\t\t}\n\t\t\t\tAscWriteLramByte(iop_base,\n\t\t\t\t\t\t (ushort)(sg_q_addr + (ushort)\n\t\t\t\t\t\t\t  ASC_SCSIQ_B_STATUS),\n\t\t\t\t\t\t QS_FREE);\n\t\t\t}\n\t\t\tn_q_used = sg_queue_cnt + 1;\n\t\t\tAscPutVarDoneQTail(iop_base, sg_list_qp);\n\t\t}\n\t\tif (asc_dvc->queue_full_or_busy & target_id) {\n\t\t\tcur_target_qng = AscReadLramByte(iop_base,\n\t\t\t\t\t\t\t (ushort)((ushort)\n\t\t\t\t\t\t\t\t  ASC_QADR_BEG\n\t\t\t\t\t\t\t\t  + (ushort)\n\t\t\t\t\t\t\t\t  scsiq->d2.\n\t\t\t\t\t\t\t\t  target_ix));\n\t\t\tif (cur_target_qng < asc_dvc->max_dvc_qng[tid_no]) {\n\t\t\t\tscsi_busy = AscReadLramByte(iop_base, (ushort)\n\t\t\t\t\t\t\t    ASCV_SCSIBUSY_B);\n\t\t\t\tscsi_busy &= ~target_id;\n\t\t\t\tAscWriteLramByte(iop_base,\n\t\t\t\t\t\t (ushort)ASCV_SCSIBUSY_B,\n\t\t\t\t\t\t scsi_busy);\n\t\t\t\tasc_dvc->queue_full_or_busy &= ~target_id;\n\t\t\t}\n\t\t}\n\t\tif (asc_dvc->cur_total_qng >= n_q_used) {\n\t\t\tasc_dvc->cur_total_qng -= n_q_used;\n\t\t\tif (asc_dvc->cur_dvc_qng[tid_no] != 0) {\n\t\t\t\tasc_dvc->cur_dvc_qng[tid_no]--;\n\t\t\t}\n\t\t} else {\n\t\t\tAscSetLibErrorCode(asc_dvc, ASCQ_ERR_CUR_QNG);\n\t\t\tscsiq->d3.done_stat = QD_WITH_ERROR;\n\t\t\tgoto FATAL_ERR_QDONE;\n\t\t}\n\t\tif ((scsiq->d2.srb_tag == 0UL) ||\n\t\t    ((scsiq->q_status & QS_ABORTED) != 0)) {\n\t\t\treturn (0x11);\n\t\t} else if (scsiq->q_status == QS_DONE) {\n\t\t\t \n\t\t\tfalse_overrun = false;\n\t\t\tif (scsiq->extra_bytes != 0) {\n\t\t\t\tscsiq->remain_bytes += scsiq->extra_bytes;\n\t\t\t}\n\t\t\tif (scsiq->d3.done_stat == QD_WITH_ERROR) {\n\t\t\t\tif (scsiq->d3.host_stat ==\n\t\t\t\t    QHSTA_M_DATA_OVER_RUN) {\n\t\t\t\t\tif ((scsiq->\n\t\t\t\t\t     cntl & (QC_DATA_IN | QC_DATA_OUT))\n\t\t\t\t\t    == 0) {\n\t\t\t\t\t\tscsiq->d3.done_stat =\n\t\t\t\t\t\t    QD_NO_ERROR;\n\t\t\t\t\t\tscsiq->d3.host_stat =\n\t\t\t\t\t\t    QHSTA_NO_ERROR;\n\t\t\t\t\t} else if (false_overrun) {\n\t\t\t\t\t\tscsiq->d3.done_stat =\n\t\t\t\t\t\t    QD_NO_ERROR;\n\t\t\t\t\t\tscsiq->d3.host_stat =\n\t\t\t\t\t\t    QHSTA_NO_ERROR;\n\t\t\t\t\t}\n\t\t\t\t} else if (scsiq->d3.host_stat ==\n\t\t\t\t\t   QHSTA_M_HUNG_REQ_SCSI_BUS_RESET) {\n\t\t\t\t\tAscStopChip(iop_base);\n\t\t\t\t\tAscSetChipControl(iop_base,\n\t\t\t\t\t\t\t  (uchar)(CC_SCSI_RESET\n\t\t\t\t\t\t\t\t  | CC_HALT));\n\t\t\t\t\tudelay(60);\n\t\t\t\t\tAscSetChipControl(iop_base, CC_HALT);\n\t\t\t\t\tAscSetChipStatus(iop_base,\n\t\t\t\t\t\t\t CIW_CLR_SCSI_RESET_INT);\n\t\t\t\t\tAscSetChipStatus(iop_base, 0);\n\t\t\t\t\tAscSetChipControl(iop_base, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((scsiq->cntl & QC_NO_CALLBACK) == 0) {\n\t\t\t\tasc_isr_callback(asc_dvc, scsiq);\n\t\t\t} else {\n\t\t\t\tif ((AscReadLramByte(iop_base,\n\t\t\t\t\t\t     (ushort)(q_addr + (ushort)\n\t\t\t\t\t\t\t      ASC_SCSIQ_CDB_BEG))\n\t\t\t\t     == START_STOP)) {\n\t\t\t\t\tasc_dvc->unit_not_ready &= ~target_id;\n\t\t\t\t\tif (scsiq->d3.done_stat != QD_NO_ERROR) {\n\t\t\t\t\t\tasc_dvc->start_motor &=\n\t\t\t\t\t\t    ~target_id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (1);\n\t\t} else {\n\t\t\tAscSetLibErrorCode(asc_dvc, ASCQ_ERR_Q_STATUS);\n FATAL_ERR_QDONE:\n\t\t\tif ((scsiq->cntl & QC_NO_CALLBACK) == 0) {\n\t\t\t\tasc_isr_callback(asc_dvc, scsiq);\n\t\t\t}\n\t\t\treturn (0x80);\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic int AscISR(ASC_DVC_VAR *asc_dvc)\n{\n\tASC_CS_TYPE chipstat;\n\tPortAddr iop_base;\n\tushort saved_ram_addr;\n\tuchar ctrl_reg;\n\tuchar saved_ctrl_reg;\n\tint int_pending;\n\tint status;\n\tuchar host_flag;\n\n\tiop_base = asc_dvc->iop_base;\n\tint_pending = ASC_FALSE;\n\n\tif (AscIsIntPending(iop_base) == 0)\n\t\treturn int_pending;\n\n\tif ((asc_dvc->init_state & ASC_INIT_STATE_END_LOAD_MC) == 0) {\n\t\treturn ASC_ERROR;\n\t}\n\tif (asc_dvc->in_critical_cnt != 0) {\n\t\tAscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_ON_CRITICAL);\n\t\treturn ASC_ERROR;\n\t}\n\tif (asc_dvc->is_in_int) {\n\t\tAscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_RE_ENTRY);\n\t\treturn ASC_ERROR;\n\t}\n\tasc_dvc->is_in_int = true;\n\tctrl_reg = AscGetChipControl(iop_base);\n\tsaved_ctrl_reg = ctrl_reg & (~(CC_SCSI_RESET | CC_CHIP_RESET |\n\t\t\t\t       CC_SINGLE_STEP | CC_DIAG | CC_TEST));\n\tchipstat = AscGetChipStatus(iop_base);\n\tif (chipstat & CSW_SCSI_RESET_LATCH) {\n\t\tif (!(asc_dvc->bus_type & (ASC_IS_VL | ASC_IS_EISA))) {\n\t\t\tint i = 10;\n\t\t\tint_pending = ASC_TRUE;\n\t\t\tasc_dvc->sdtr_done = 0;\n\t\t\tsaved_ctrl_reg &= (uchar)(~CC_HALT);\n\t\t\twhile ((AscGetChipStatus(iop_base) &\n\t\t\t\tCSW_SCSI_RESET_ACTIVE) && (i-- > 0)) {\n\t\t\t\tmdelay(100);\n\t\t\t}\n\t\t\tAscSetChipControl(iop_base, (CC_CHIP_RESET | CC_HALT));\n\t\t\tAscSetChipControl(iop_base, CC_HALT);\n\t\t\tAscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);\n\t\t\tAscSetChipStatus(iop_base, 0);\n\t\t\tchipstat = AscGetChipStatus(iop_base);\n\t\t}\n\t}\n\tsaved_ram_addr = AscGetChipLramAddr(iop_base);\n\thost_flag = AscReadLramByte(iop_base,\n\t\t\t\t    ASCV_HOST_FLAG_B) &\n\t    (uchar)(~ASC_HOST_FLAG_IN_ISR);\n\tAscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,\n\t\t\t (uchar)(host_flag | (uchar)ASC_HOST_FLAG_IN_ISR));\n\tif ((chipstat & CSW_INT_PENDING) || (int_pending)) {\n\t\tAscAckInterrupt(iop_base);\n\t\tint_pending = ASC_TRUE;\n\t\tif ((chipstat & CSW_HALTED) && (ctrl_reg & CC_SINGLE_STEP)) {\n\t\t\tAscIsrChipHalted(asc_dvc);\n\t\t\tsaved_ctrl_reg &= (uchar)(~CC_HALT);\n\t\t} else {\n\t\t\tif ((asc_dvc->dvc_cntl & ASC_CNTL_INT_MULTI_Q) != 0) {\n\t\t\t\twhile (((status =\n\t\t\t\t\t AscIsrQDone(asc_dvc)) & 0x01) != 0) {\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tif ((status =\n\t\t\t\t\t     AscIsrQDone(asc_dvc)) == 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} while (status == 0x11);\n\t\t\t}\n\t\t\tif ((status & 0x80) != 0)\n\t\t\t\tint_pending = ASC_ERROR;\n\t\t}\n\t}\n\tAscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);\n\tAscSetChipLramAddr(iop_base, saved_ram_addr);\n\tAscSetChipControl(iop_base, saved_ctrl_reg);\n\tasc_dvc->is_in_int = false;\n\treturn int_pending;\n}\n\n \nstatic int advansys_reset(struct scsi_cmnd *scp)\n{\n\tstruct Scsi_Host *shost = scp->device->host;\n\tstruct asc_board *boardp = shost_priv(shost);\n\tunsigned long flags;\n\tint status;\n\tint ret = SUCCESS;\n\n\tASC_DBG(1, \"0x%p\\n\", scp);\n\n\tASC_STATS(shost, reset);\n\n\tscmd_printk(KERN_INFO, scp, \"SCSI host reset started...\\n\");\n\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;\n\n\t\t \n\t\tASC_DBG(1, \"before AscInitAsc1000Driver()\\n\");\n\t\tstatus = AscInitAsc1000Driver(asc_dvc);\n\n\t\t \n\t\tif (asc_dvc->err_code || !asc_dvc->overrun_dma) {\n\t\t\tscmd_printk(KERN_INFO, scp, \"SCSI host reset error: \"\n\t\t\t\t    \"0x%x, status: 0x%x\\n\", asc_dvc->err_code,\n\t\t\t\t    status);\n\t\t\tret = FAILED;\n\t\t} else if (status) {\n\t\t\tscmd_printk(KERN_INFO, scp, \"SCSI host reset warning: \"\n\t\t\t\t    \"0x%x\\n\", status);\n\t\t} else {\n\t\t\tscmd_printk(KERN_INFO, scp, \"SCSI host reset \"\n\t\t\t\t    \"successful\\n\");\n\t\t}\n\n\t\tASC_DBG(1, \"after AscInitAsc1000Driver()\\n\");\n\t} else {\n\t\t \n\t\tADV_DVC_VAR *adv_dvc = &boardp->dvc_var.adv_dvc_var;\n\n\t\t \n\t\tASC_DBG(1, \"before AdvResetChipAndSB()\\n\");\n\t\tswitch (AdvResetChipAndSB(adv_dvc)) {\n\t\tcase ASC_TRUE:\n\t\t\tscmd_printk(KERN_INFO, scp, \"SCSI host reset \"\n\t\t\t\t    \"successful\\n\");\n\t\t\tbreak;\n\t\tcase ASC_FALSE:\n\t\tdefault:\n\t\t\tscmd_printk(KERN_INFO, scp, \"SCSI host reset error\\n\");\n\t\t\tret = FAILED;\n\t\t\tbreak;\n\t\t}\n\t\tspin_lock_irqsave(shost->host_lock, flags);\n\t\tAdvISR(adv_dvc);\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t}\n\n\tASC_DBG(1, \"ret %d\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic int\nadvansys_biosparam(struct scsi_device *sdev, struct block_device *bdev,\n\t\t   sector_t capacity, int ip[])\n{\n\tstruct asc_board *boardp = shost_priv(sdev->host);\n\n\tASC_DBG(1, \"begin\\n\");\n\tASC_STATS(sdev->host, biosparam);\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tif ((boardp->dvc_var.asc_dvc_var.dvc_cntl &\n\t\t     ASC_CNTL_BIOS_GT_1GB) && capacity > 0x200000) {\n\t\t\tip[0] = 255;\n\t\t\tip[1] = 63;\n\t\t} else {\n\t\t\tip[0] = 64;\n\t\t\tip[1] = 32;\n\t\t}\n\t} else {\n\t\tif ((boardp->dvc_var.adv_dvc_var.bios_ctrl &\n\t\t     BIOS_CTRL_EXTENDED_XLAT) && capacity > 0x200000) {\n\t\t\tip[0] = 255;\n\t\t\tip[1] = 63;\n\t\t} else {\n\t\t\tip[0] = 64;\n\t\t\tip[1] = 32;\n\t\t}\n\t}\n\tip[2] = (unsigned long)capacity / (ip[0] * ip[1]);\n\tASC_DBG(1, \"end\\n\");\n\treturn 0;\n}\n\n \nstatic irqreturn_t advansys_interrupt(int irq, void *dev_id)\n{\n\tstruct Scsi_Host *shost = dev_id;\n\tstruct asc_board *boardp = shost_priv(shost);\n\tirqreturn_t result = IRQ_NONE;\n\tunsigned long flags;\n\n\tASC_DBG(2, \"boardp 0x%p\\n\", boardp);\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tif (AscIsIntPending(shost->io_port)) {\n\t\t\tresult = IRQ_HANDLED;\n\t\t\tASC_STATS(shost, interrupt);\n\t\t\tASC_DBG(1, \"before AscISR()\\n\");\n\t\t\tAscISR(&boardp->dvc_var.asc_dvc_var);\n\t\t}\n\t} else {\n\t\tASC_DBG(1, \"before AdvISR()\\n\");\n\t\tif (AdvISR(&boardp->dvc_var.adv_dvc_var)) {\n\t\t\tresult = IRQ_HANDLED;\n\t\t\tASC_STATS(shost, interrupt);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tASC_DBG(1, \"end\\n\");\n\treturn result;\n}\n\nstatic bool AscHostReqRiscHalt(PortAddr iop_base)\n{\n\tint count = 0;\n\tbool sta = false;\n\tuchar saved_stop_code;\n\n\tif (AscIsChipHalted(iop_base))\n\t\treturn true;\n\tsaved_stop_code = AscReadLramByte(iop_base, ASCV_STOP_CODE_B);\n\tAscWriteLramByte(iop_base, ASCV_STOP_CODE_B,\n\t\t\t ASC_STOP_HOST_REQ_RISC_HALT | ASC_STOP_REQ_RISC_STOP);\n\tdo {\n\t\tif (AscIsChipHalted(iop_base)) {\n\t\t\tsta = true;\n\t\t\tbreak;\n\t\t}\n\t\tmdelay(100);\n\t} while (count++ < 20);\n\tAscWriteLramByte(iop_base, ASCV_STOP_CODE_B, saved_stop_code);\n\treturn sta;\n}\n\nstatic bool\nAscSetRunChipSynRegAtID(PortAddr iop_base, uchar tid_no, uchar sdtr_data)\n{\n\tbool sta = false;\n\n\tif (AscHostReqRiscHalt(iop_base)) {\n\t\tsta = AscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);\n\t\tAscStartChip(iop_base);\n\t}\n\treturn sta;\n}\n\nstatic void AscAsyncFix(ASC_DVC_VAR *asc_dvc, struct scsi_device *sdev)\n{\n\tchar type = sdev->type;\n\tASC_SCSI_BIT_ID_TYPE tid_bits = 1 << sdev->id;\n\n\tif (!(asc_dvc->bug_fix_cntl & ASC_BUG_FIX_ASYN_USE_SYN))\n\t\treturn;\n\tif (asc_dvc->init_sdtr & tid_bits)\n\t\treturn;\n\n\tif ((type == TYPE_ROM) && (strncmp(sdev->vendor, \"HP \", 3) == 0))\n\t\tasc_dvc->pci_fix_asyn_xfer_always |= tid_bits;\n\n\tasc_dvc->pci_fix_asyn_xfer |= tid_bits;\n\tif ((type == TYPE_PROCESSOR) || (type == TYPE_SCANNER) ||\n\t    (type == TYPE_ROM) || (type == TYPE_TAPE))\n\t\tasc_dvc->pci_fix_asyn_xfer &= ~tid_bits;\n\n\tif (asc_dvc->pci_fix_asyn_xfer & tid_bits)\n\t\tAscSetRunChipSynRegAtID(asc_dvc->iop_base, sdev->id,\n\t\t\t\t\tASYN_SDTR_DATA_FIX_PCI_REV_AB);\n}\n\nstatic void\nadvansys_narrow_slave_configure(struct scsi_device *sdev, ASC_DVC_VAR *asc_dvc)\n{\n\tASC_SCSI_BIT_ID_TYPE tid_bit = 1 << sdev->id;\n\tASC_SCSI_BIT_ID_TYPE orig_use_tagged_qng = asc_dvc->use_tagged_qng;\n\n\tif (sdev->lun == 0) {\n\t\tASC_SCSI_BIT_ID_TYPE orig_init_sdtr = asc_dvc->init_sdtr;\n\t\tif ((asc_dvc->cfg->sdtr_enable & tid_bit) && sdev->sdtr) {\n\t\t\tasc_dvc->init_sdtr |= tid_bit;\n\t\t} else {\n\t\t\tasc_dvc->init_sdtr &= ~tid_bit;\n\t\t}\n\n\t\tif (orig_init_sdtr != asc_dvc->init_sdtr)\n\t\t\tAscAsyncFix(asc_dvc, sdev);\n\t}\n\n\tif (sdev->tagged_supported) {\n\t\tif (asc_dvc->cfg->cmd_qng_enabled & tid_bit) {\n\t\t\tif (sdev->lun == 0) {\n\t\t\t\tasc_dvc->cfg->can_tagged_qng |= tid_bit;\n\t\t\t\tasc_dvc->use_tagged_qng |= tid_bit;\n\t\t\t}\n\t\t\tscsi_change_queue_depth(sdev, \n\t\t\t\t\t\tasc_dvc->max_dvc_qng[sdev->id]);\n\t\t}\n\t} else {\n\t\tif (sdev->lun == 0) {\n\t\t\tasc_dvc->cfg->can_tagged_qng &= ~tid_bit;\n\t\t\tasc_dvc->use_tagged_qng &= ~tid_bit;\n\t\t}\n\t}\n\n\tif ((sdev->lun == 0) &&\n\t    (orig_use_tagged_qng != asc_dvc->use_tagged_qng)) {\n\t\tAscWriteLramByte(asc_dvc->iop_base, ASCV_DISC_ENABLE_B,\n\t\t\t\t asc_dvc->cfg->disc_enable);\n\t\tAscWriteLramByte(asc_dvc->iop_base, ASCV_USE_TAGGED_QNG_B,\n\t\t\t\t asc_dvc->use_tagged_qng);\n\t\tAscWriteLramByte(asc_dvc->iop_base, ASCV_CAN_TAGGED_QNG_B,\n\t\t\t\t asc_dvc->cfg->can_tagged_qng);\n\n\t\tasc_dvc->max_dvc_qng[sdev->id] =\n\t\t\t\t\tasc_dvc->cfg->max_tag_qng[sdev->id];\n\t\tAscWriteLramByte(asc_dvc->iop_base,\n\t\t\t\t (ushort)(ASCV_MAX_DVC_QNG_BEG + sdev->id),\n\t\t\t\t asc_dvc->max_dvc_qng[sdev->id]);\n\t}\n}\n\n \nstatic void\nadvansys_wide_enable_wdtr(AdvPortAddr iop_base, unsigned short tidmask)\n{\n\tunsigned short cfg_word;\n\tAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);\n\tif ((cfg_word & tidmask) != 0)\n\t\treturn;\n\n\tcfg_word |= tidmask;\n\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);\n\n\t \n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);\n\tcfg_word &= ~tidmask;\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);\n\tAdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);\n\tcfg_word &= ~tidmask;\n\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);\n}\n\n \nstatic void\nadvansys_wide_enable_sdtr(AdvPortAddr iop_base, unsigned short tidmask)\n{\n\tunsigned short cfg_word;\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);\n\tif ((cfg_word & tidmask) != 0)\n\t\treturn;\n\n\tcfg_word |= tidmask;\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);\n\n\t \n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);\n\tcfg_word &= ~tidmask;\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);\n}\n\n \nstatic void advansys_wide_enable_ppr(ADV_DVC_VAR *adv_dvc,\n\t\t\t\tAdvPortAddr iop_base, unsigned short tidmask)\n{\n\tAdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, adv_dvc->ppr_able);\n\tadv_dvc->ppr_able |= tidmask;\n\tAdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, adv_dvc->ppr_able);\n}\n\nstatic void\nadvansys_wide_slave_configure(struct scsi_device *sdev, ADV_DVC_VAR *adv_dvc)\n{\n\tAdvPortAddr iop_base = adv_dvc->iop_base;\n\tunsigned short tidmask = 1 << sdev->id;\n\n\tif (sdev->lun == 0) {\n\t\t \n\n\t\tif ((adv_dvc->wdtr_able & tidmask) && sdev->wdtr)\n\t\t\tadvansys_wide_enable_wdtr(iop_base, tidmask);\n\t\tif ((adv_dvc->sdtr_able & tidmask) && sdev->sdtr)\n\t\t\tadvansys_wide_enable_sdtr(iop_base, tidmask);\n\t\tif (adv_dvc->chip_type == ADV_CHIP_ASC38C1600 && sdev->ppr)\n\t\t\tadvansys_wide_enable_ppr(adv_dvc, iop_base, tidmask);\n\n\t\t \n\t\tif ((adv_dvc->tagqng_able & tidmask) &&\n\t\t    sdev->tagged_supported) {\n\t\t\tunsigned short cfg_word;\n\t\t\tAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, cfg_word);\n\t\t\tcfg_word |= tidmask;\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\t cfg_word);\n\t\t\tAdvWriteByteLram(iop_base,\n\t\t\t\t\t ASC_MC_NUMBER_OF_MAX_CMD + sdev->id,\n\t\t\t\t\t adv_dvc->max_dvc_qng);\n\t\t}\n\t}\n\n\tif ((adv_dvc->tagqng_able & tidmask) && sdev->tagged_supported)\n\t\tscsi_change_queue_depth(sdev, adv_dvc->max_dvc_qng);\n}\n\n \nstatic int advansys_slave_configure(struct scsi_device *sdev)\n{\n\tstruct asc_board *boardp = shost_priv(sdev->host);\n\n\tif (ASC_NARROW_BOARD(boardp))\n\t\tadvansys_narrow_slave_configure(sdev,\n\t\t\t\t\t\t&boardp->dvc_var.asc_dvc_var);\n\telse\n\t\tadvansys_wide_slave_configure(sdev,\n\t\t\t\t\t\t&boardp->dvc_var.adv_dvc_var);\n\n\treturn 0;\n}\n\nstatic __le32 asc_get_sense_buffer_dma(struct scsi_cmnd *scp)\n{\n\tstruct asc_board *board = shost_priv(scp->device->host);\n\tstruct advansys_cmd *acmd = advansys_cmd(scp);\n\n\tacmd->dma_handle = dma_map_single(board->dev, scp->sense_buffer,\n\t\t\t\t\tSCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(board->dev, acmd->dma_handle)) {\n\t\tASC_DBG(1, \"failed to map sense buffer\\n\");\n\t\treturn 0;\n\t}\n\treturn cpu_to_le32(acmd->dma_handle);\n}\n\nstatic int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,\n\t\t\tstruct asc_scsi_q *asc_scsi_q)\n{\n\tstruct asc_dvc_var *asc_dvc = &boardp->dvc_var.asc_dvc_var;\n\tint use_sg;\n\tu32 srb_tag;\n\n\tmemset(asc_scsi_q, 0, sizeof(*asc_scsi_q));\n\n\t \n\tsrb_tag = scsi_cmd_to_rq(scp)->tag + 1;\n\tasc_scsi_q->q2.srb_tag = srb_tag;\n\n\t \n\tasc_scsi_q->cdbptr = &scp->cmnd[0];\n\tasc_scsi_q->q2.cdb_len = scp->cmd_len;\n\tasc_scsi_q->q1.target_id = ASC_TID_TO_TARGET_ID(scp->device->id);\n\tasc_scsi_q->q1.target_lun = scp->device->lun;\n\tasc_scsi_q->q2.target_ix =\n\t    ASC_TIDLUN_TO_IX(scp->device->id, scp->device->lun);\n\tasc_scsi_q->q1.sense_addr = asc_get_sense_buffer_dma(scp);\n\tasc_scsi_q->q1.sense_len = SCSI_SENSE_BUFFERSIZE;\n\tif (!asc_scsi_q->q1.sense_addr)\n\t\treturn ASC_BUSY;\n\n\t \n\tif ((asc_dvc->cur_dvc_qng[scp->device->id] > 0) &&\n\t    (boardp->reqcnt[scp->device->id] % 255) == 0) {\n\t\tasc_scsi_q->q2.tag_code = ORDERED_QUEUE_TAG;\n\t} else {\n\t\tasc_scsi_q->q2.tag_code = SIMPLE_QUEUE_TAG;\n\t}\n\n\t \n\tuse_sg = scsi_dma_map(scp);\n\tif (use_sg < 0) {\n\t\tASC_DBG(1, \"failed to map sglist\\n\");\n\t\treturn ASC_BUSY;\n\t} else if (use_sg > 0) {\n\t\tint sgcnt;\n\t\tstruct scatterlist *slp;\n\t\tstruct asc_sg_head *asc_sg_head;\n\n\t\tif (use_sg > scp->device->host->sg_tablesize) {\n\t\t\tscmd_printk(KERN_ERR, scp, \"use_sg %d > \"\n\t\t\t\t\"sg_tablesize %d\\n\", use_sg,\n\t\t\t\tscp->device->host->sg_tablesize);\n\t\t\tscsi_dma_unmap(scp);\n\t\t\tset_host_byte(scp, DID_ERROR);\n\t\t\treturn ASC_ERROR;\n\t\t}\n\n\t\tasc_sg_head = kzalloc(struct_size(asc_sg_head, sg_list, use_sg),\n\t\t\t\t      GFP_ATOMIC);\n\t\tif (!asc_sg_head) {\n\t\t\tscsi_dma_unmap(scp);\n\t\t\tset_host_byte(scp, DID_SOFT_ERROR);\n\t\t\treturn ASC_ERROR;\n\t\t}\n\n\t\tasc_scsi_q->q1.cntl |= QC_SG_HEAD;\n\t\tasc_scsi_q->sg_head = asc_sg_head;\n\t\tasc_scsi_q->q1.data_cnt = 0;\n\t\tasc_scsi_q->q1.data_addr = 0;\n\t\t \n\t\tasc_sg_head->entry_cnt = asc_scsi_q->q1.sg_queue_cnt = use_sg;\n\t\tASC_STATS_ADD(scp->device->host, xfer_elem,\n\t\t\t      asc_sg_head->entry_cnt);\n\n\t\t \n\t\tscsi_for_each_sg(scp, slp, use_sg, sgcnt) {\n\t\t\tasc_sg_head->sg_list[sgcnt].addr =\n\t\t\t    cpu_to_le32(sg_dma_address(slp));\n\t\t\tasc_sg_head->sg_list[sgcnt].bytes =\n\t\t\t    cpu_to_le32(sg_dma_len(slp));\n\t\t\tASC_STATS_ADD(scp->device->host, xfer_sect,\n\t\t\t\t      DIV_ROUND_UP(sg_dma_len(slp), 512));\n\t\t}\n\t}\n\n\tASC_STATS(scp->device->host, xfer_cnt);\n\n\tASC_DBG_PRT_ASC_SCSI_Q(2, asc_scsi_q);\n\tASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);\n\n\treturn ASC_NOERROR;\n}\n\n \nstatic int\nadv_get_sglist(struct asc_board *boardp, adv_req_t *reqp,\n\t       ADV_SCSI_REQ_Q *scsiqp, struct scsi_cmnd *scp, int use_sg)\n{\n\tadv_sgblk_t *sgblkp, *prev_sgblkp;\n\tstruct scatterlist *slp;\n\tint sg_elem_cnt;\n\tADV_SG_BLOCK *sg_block, *prev_sg_block;\n\tdma_addr_t sgblk_paddr;\n\tint i;\n\n\tslp = scsi_sglist(scp);\n\tsg_elem_cnt = use_sg;\n\tprev_sgblkp = NULL;\n\tprev_sg_block = NULL;\n\treqp->sgblkp = NULL;\n\n\tfor (;;) {\n\t\t \n\t\tsgblkp = dma_pool_alloc(boardp->adv_sgblk_pool, GFP_ATOMIC,\n\t\t\t\t\t&sgblk_paddr);\n\t\tif (!sgblkp) {\n\t\t\tASC_DBG(1, \"no free adv_sgblk_t\\n\");\n\t\t\tASC_STATS(scp->device->host, adv_build_nosg);\n\n\t\t\t \n\t\t\twhile ((sgblkp = reqp->sgblkp) != NULL) {\n\t\t\t\t \n\t\t\t\treqp->sgblkp = sgblkp->next_sgblkp;\n\t\t\t\tsgblkp->next_sgblkp = NULL;\n\t\t\t\tdma_pool_free(boardp->adv_sgblk_pool, sgblkp,\n\t\t\t\t\t      sgblkp->sg_addr);\n\t\t\t}\n\t\t\treturn ASC_BUSY;\n\t\t}\n\t\t \n\t\tsgblkp->sg_addr = sgblk_paddr;\n\t\tsgblkp->next_sgblkp = NULL;\n\t\tsg_block = &sgblkp->sg_block;\n\n\t\t \n\t\tif (reqp->sgblkp == NULL) {\n\t\t\t \n\t\t\treqp->sgblkp = sgblkp;\n\n\t\t\t \n\t\t\tscsiqp->sg_list_ptr = sg_block;\n\t\t\tscsiqp->sg_real_addr = cpu_to_le32(sgblk_paddr);\n\t\t} else {\n\t\t\t \n\t\t\tprev_sgblkp->next_sgblkp = sgblkp;\n\n\t\t\t \n\t\t\tprev_sg_block->sg_ptr = cpu_to_le32(sgblk_paddr);\n\t\t}\n\n\t\tfor (i = 0; i < NO_OF_SG_PER_BLOCK; i++) {\n\t\t\tsg_block->sg_list[i].sg_addr =\n\t\t\t\t\tcpu_to_le32(sg_dma_address(slp));\n\t\t\tsg_block->sg_list[i].sg_count =\n\t\t\t\t\tcpu_to_le32(sg_dma_len(slp));\n\t\t\tASC_STATS_ADD(scp->device->host, xfer_sect,\n\t\t\t\t      DIV_ROUND_UP(sg_dma_len(slp), 512));\n\n\t\t\tif (--sg_elem_cnt == 0) {\n\t\t\t\t \n\t\t\t\tsg_block->sg_cnt = i + 1;\n\t\t\t\tsg_block->sg_ptr = 0L;  \n\t\t\t\treturn ADV_SUCCESS;\n\t\t\t}\n\t\t\tslp = sg_next(slp);\n\t\t}\n\t\tsg_block->sg_cnt = NO_OF_SG_PER_BLOCK;\n\t\tprev_sg_block = sg_block;\n\t\tprev_sgblkp = sgblkp;\n\t}\n}\n\n \nstatic int\nadv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,\n\t      adv_req_t **adv_reqpp)\n{\n\tu32 srb_tag = scsi_cmd_to_rq(scp)->tag;\n\tadv_req_t *reqp;\n\tADV_SCSI_REQ_Q *scsiqp;\n\tint ret;\n\tint use_sg;\n\tdma_addr_t sense_addr;\n\n\t \n\treqp = &boardp->adv_reqp[srb_tag];\n\tif (reqp->cmndp && reqp->cmndp != scp ) {\n\t\tASC_DBG(1, \"no free adv_req_t\\n\");\n\t\tASC_STATS(scp->device->host, adv_build_noreq);\n\t\treturn ASC_BUSY;\n\t}\n\n\treqp->req_addr = boardp->adv_reqp_addr + (srb_tag * sizeof(adv_req_t));\n\n\tscsiqp = &reqp->scsi_req_q;\n\n\t \n\tscsiqp->cntl = scsiqp->scsi_cntl = scsiqp->done_status = 0;\n\n\t \n\tscsiqp->srb_tag = srb_tag;\n\n\t \n\treqp->cmndp = scp;\n\tscp->host_scribble = (void *)reqp;\n\n\t \n\n\t \n\tscsiqp->cdb_len = scp->cmd_len;\n\t \n\tmemcpy(scsiqp->cdb, scp->cmnd, scp->cmd_len < 12 ? scp->cmd_len : 12);\n\t \n\tif (scp->cmd_len > 12) {\n\t\tint cdb16_len = scp->cmd_len - 12;\n\n\t\tmemcpy(scsiqp->cdb16, &scp->cmnd[12], cdb16_len);\n\t}\n\n\tscsiqp->target_id = scp->device->id;\n\tscsiqp->target_lun = scp->device->lun;\n\n\tsense_addr = dma_map_single(boardp->dev, scp->sense_buffer,\n\t\t\t\t    SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(boardp->dev, sense_addr)) {\n\t\tASC_DBG(1, \"failed to map sense buffer\\n\");\n\t\tASC_STATS(scp->device->host, adv_build_noreq);\n\t\treturn ASC_BUSY;\n\t}\n\tscsiqp->sense_addr = cpu_to_le32(sense_addr);\n\tscsiqp->sense_len = SCSI_SENSE_BUFFERSIZE;\n\n\t \n\n\tuse_sg = scsi_dma_map(scp);\n\tif (use_sg < 0) {\n\t\tASC_DBG(1, \"failed to map SG list\\n\");\n\t\tASC_STATS(scp->device->host, adv_build_noreq);\n\t\treturn ASC_BUSY;\n\t} else if (use_sg == 0) {\n\t\t \n\t\treqp->sgblkp = NULL;\n\t\tscsiqp->data_cnt = 0;\n\n\t\tscsiqp->data_addr = 0;\n\t\tscsiqp->sg_list_ptr = NULL;\n\t\tscsiqp->sg_real_addr = 0;\n\t} else {\n\t\tif (use_sg > ADV_MAX_SG_LIST) {\n\t\t\tscmd_printk(KERN_ERR, scp, \"use_sg %d > \"\n\t\t\t\t   \"ADV_MAX_SG_LIST %d\\n\", use_sg,\n\t\t\t\t   scp->device->host->sg_tablesize);\n\t\t\tscsi_dma_unmap(scp);\n\t\t\tset_host_byte(scp, DID_ERROR);\n\t\t\treqp->cmndp = NULL;\n\t\t\tscp->host_scribble = NULL;\n\n\t\t\treturn ASC_ERROR;\n\t\t}\n\n\t\tscsiqp->data_cnt = cpu_to_le32(scsi_bufflen(scp));\n\n\t\tret = adv_get_sglist(boardp, reqp, scsiqp, scp, use_sg);\n\t\tif (ret != ADV_SUCCESS) {\n\t\t\tscsi_dma_unmap(scp);\n\t\t\tset_host_byte(scp, DID_ERROR);\n\t\t\treqp->cmndp = NULL;\n\t\t\tscp->host_scribble = NULL;\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tASC_STATS_ADD(scp->device->host, xfer_elem, use_sg);\n\t}\n\n\tASC_STATS(scp->device->host, xfer_cnt);\n\n\tASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);\n\tASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);\n\n\t*adv_reqpp = reqp;\n\n\treturn ASC_NOERROR;\n}\n\nstatic int AscSgListToQueue(int sg_list)\n{\n\tint n_sg_list_qs;\n\n\tn_sg_list_qs = ((sg_list - 1) / ASC_SG_LIST_PER_Q);\n\tif (((sg_list - 1) % ASC_SG_LIST_PER_Q) != 0)\n\t\tn_sg_list_qs++;\n\treturn n_sg_list_qs + 1;\n}\n\nstatic uint\nAscGetNumOfFreeQueue(ASC_DVC_VAR *asc_dvc, uchar target_ix, uchar n_qs)\n{\n\tuint cur_used_qs;\n\tuint cur_free_qs;\n\tASC_SCSI_BIT_ID_TYPE target_id;\n\tuchar tid_no;\n\n\ttarget_id = ASC_TIX_TO_TARGET_ID(target_ix);\n\ttid_no = ASC_TIX_TO_TID(target_ix);\n\tif ((asc_dvc->unit_not_ready & target_id) ||\n\t    (asc_dvc->queue_full_or_busy & target_id)) {\n\t\treturn 0;\n\t}\n\tif (n_qs == 1) {\n\t\tcur_used_qs = (uint) asc_dvc->cur_total_qng +\n\t\t    (uint) asc_dvc->last_q_shortage + (uint) ASC_MIN_FREE_Q;\n\t} else {\n\t\tcur_used_qs = (uint) asc_dvc->cur_total_qng +\n\t\t    (uint) ASC_MIN_FREE_Q;\n\t}\n\tif ((uint) (cur_used_qs + n_qs) <= (uint) asc_dvc->max_total_qng) {\n\t\tcur_free_qs = (uint) asc_dvc->max_total_qng - cur_used_qs;\n\t\tif (asc_dvc->cur_dvc_qng[tid_no] >=\n\t\t    asc_dvc->max_dvc_qng[tid_no]) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn cur_free_qs;\n\t}\n\tif (n_qs > 1) {\n\t\tif ((n_qs > asc_dvc->last_q_shortage)\n\t\t    && (n_qs <= (asc_dvc->max_total_qng - ASC_MIN_FREE_Q))) {\n\t\t\tasc_dvc->last_q_shortage = n_qs;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic uchar AscAllocFreeQueue(PortAddr iop_base, uchar free_q_head)\n{\n\tushort q_addr;\n\tuchar next_qp;\n\tuchar q_status;\n\n\tq_addr = ASC_QNO_TO_QADDR(free_q_head);\n\tq_status = (uchar)AscReadLramByte(iop_base,\n\t\t\t\t\t  (ushort)(q_addr +\n\t\t\t\t\t\t   ASC_SCSIQ_B_STATUS));\n\tnext_qp = AscReadLramByte(iop_base, (ushort)(q_addr + ASC_SCSIQ_B_FWD));\n\tif (((q_status & QS_READY) == 0) && (next_qp != ASC_QLINK_END))\n\t\treturn next_qp;\n\treturn ASC_QLINK_END;\n}\n\nstatic uchar\nAscAllocMultipleFreeQueue(PortAddr iop_base, uchar free_q_head, uchar n_free_q)\n{\n\tuchar i;\n\n\tfor (i = 0; i < n_free_q; i++) {\n\t\tfree_q_head = AscAllocFreeQueue(iop_base, free_q_head);\n\t\tif (free_q_head == ASC_QLINK_END)\n\t\t\tbreak;\n\t}\n\treturn free_q_head;\n}\n\n \nstatic void\nDvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)\n{\n\tint i;\n\n\tASC_DBG_PRT_HEX(2, \"DvcPutScsiQ\", outbuf, 2 * words);\n\tAscSetChipLramAddr(iop_base, s_addr);\n\tfor (i = 0; i < 2 * words; i += 2) {\n\t\tif (i == 4 || i == 20) {\n\t\t\tcontinue;\n\t\t}\n\t\toutpw(iop_base + IOP_RAM_DATA,\n\t\t      ((ushort)outbuf[i + 1] << 8) | outbuf[i]);\n\t}\n}\n\nstatic int AscPutReadyQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)\n{\n\tushort q_addr;\n\tuchar tid_no;\n\tuchar sdtr_data;\n\tuchar syn_period_ix;\n\tuchar syn_offset;\n\tPortAddr iop_base;\n\n\tiop_base = asc_dvc->iop_base;\n\tif (((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) &&\n\t    ((asc_dvc->sdtr_done & scsiq->q1.target_id) == 0)) {\n\t\ttid_no = ASC_TIX_TO_TID(scsiq->q2.target_ix);\n\t\tsdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);\n\t\tsyn_period_ix =\n\t\t    (sdtr_data >> 4) & (asc_dvc->max_sdtr_index - 1);\n\t\tsyn_offset = sdtr_data & ASC_SYN_MAX_OFFSET;\n\t\tAscMsgOutSDTR(asc_dvc,\n\t\t\t      asc_dvc->sdtr_period_tbl[syn_period_ix],\n\t\t\t      syn_offset);\n\t\tscsiq->q1.cntl |= QC_MSG_OUT;\n\t}\n\tq_addr = ASC_QNO_TO_QADDR(q_no);\n\tif ((scsiq->q1.target_id & asc_dvc->use_tagged_qng) == 0) {\n\t\tscsiq->q2.tag_code &= ~SIMPLE_QUEUE_TAG;\n\t}\n\tscsiq->q1.status = QS_FREE;\n\tAscMemWordCopyPtrToLram(iop_base,\n\t\t\t\tq_addr + ASC_SCSIQ_CDB_BEG,\n\t\t\t\t(uchar *)scsiq->cdbptr, scsiq->q2.cdb_len >> 1);\n\n\tDvcPutScsiQ(iop_base,\n\t\t    q_addr + ASC_SCSIQ_CPY_BEG,\n\t\t    (uchar *)&scsiq->q1.cntl,\n\t\t    ((sizeof(ASC_SCSIQ_1) + sizeof(ASC_SCSIQ_2)) / 2) - 1);\n\tAscWriteLramWord(iop_base,\n\t\t\t (ushort)(q_addr + (ushort)ASC_SCSIQ_B_STATUS),\n\t\t\t (ushort)(((ushort)scsiq->q1.\n\t\t\t\t   q_no << 8) | (ushort)QS_READY));\n\treturn 1;\n}\n\nstatic int\nAscPutReadySgListQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)\n{\n\tint sta;\n\tint i;\n\tASC_SG_HEAD *sg_head;\n\tASC_SG_LIST_Q scsi_sg_q;\n\t__le32 saved_data_addr;\n\t__le32 saved_data_cnt;\n\tPortAddr iop_base;\n\tushort sg_list_dwords;\n\tushort sg_index;\n\tushort sg_entry_cnt;\n\tushort q_addr;\n\tuchar next_qp;\n\n\tiop_base = asc_dvc->iop_base;\n\tsg_head = scsiq->sg_head;\n\tsaved_data_addr = scsiq->q1.data_addr;\n\tsaved_data_cnt = scsiq->q1.data_cnt;\n\tscsiq->q1.data_addr = cpu_to_le32(sg_head->sg_list[0].addr);\n\tscsiq->q1.data_cnt = cpu_to_le32(sg_head->sg_list[0].bytes);\n\t \n\tsg_entry_cnt = sg_head->entry_cnt - 1;\n\n\tif (sg_entry_cnt != 0) {\n\t\tscsiq->q1.cntl |= QC_SG_HEAD;\n\t\tq_addr = ASC_QNO_TO_QADDR(q_no);\n\t\tsg_index = 1;\n\t\tscsiq->q1.sg_queue_cnt = sg_head->queue_cnt;\n\t\tscsi_sg_q.sg_head_qp = q_no;\n\t\tscsi_sg_q.cntl = QCSG_SG_XFER_LIST;\n\t\tfor (i = 0; i < sg_head->queue_cnt; i++) {\n\t\t\tscsi_sg_q.seq_no = i + 1;\n\t\t\tif (sg_entry_cnt > ASC_SG_LIST_PER_Q) {\n\t\t\t\tsg_list_dwords = (uchar)(ASC_SG_LIST_PER_Q * 2);\n\t\t\t\tsg_entry_cnt -= ASC_SG_LIST_PER_Q;\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tscsi_sg_q.sg_list_cnt =\n\t\t\t\t\t    ASC_SG_LIST_PER_Q;\n\t\t\t\t\tscsi_sg_q.sg_cur_list_cnt =\n\t\t\t\t\t    ASC_SG_LIST_PER_Q;\n\t\t\t\t} else {\n\t\t\t\t\tscsi_sg_q.sg_list_cnt =\n\t\t\t\t\t    ASC_SG_LIST_PER_Q - 1;\n\t\t\t\t\tscsi_sg_q.sg_cur_list_cnt =\n\t\t\t\t\t    ASC_SG_LIST_PER_Q - 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscsi_sg_q.cntl |= QCSG_SG_XFER_END;\n\t\t\t\tsg_list_dwords = sg_entry_cnt << 1;\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tscsi_sg_q.sg_list_cnt = sg_entry_cnt;\n\t\t\t\t\tscsi_sg_q.sg_cur_list_cnt =\n\t\t\t\t\t    sg_entry_cnt;\n\t\t\t\t} else {\n\t\t\t\t\tscsi_sg_q.sg_list_cnt =\n\t\t\t\t\t    sg_entry_cnt - 1;\n\t\t\t\t\tscsi_sg_q.sg_cur_list_cnt =\n\t\t\t\t\t    sg_entry_cnt - 1;\n\t\t\t\t}\n\t\t\t\tsg_entry_cnt = 0;\n\t\t\t}\n\t\t\tnext_qp = AscReadLramByte(iop_base,\n\t\t\t\t\t\t  (ushort)(q_addr +\n\t\t\t\t\t\t\t   ASC_SCSIQ_B_FWD));\n\t\t\tscsi_sg_q.q_no = next_qp;\n\t\t\tq_addr = ASC_QNO_TO_QADDR(next_qp);\n\t\t\tAscMemWordCopyPtrToLram(iop_base,\n\t\t\t\t\t\tq_addr + ASC_SCSIQ_SGHD_CPY_BEG,\n\t\t\t\t\t\t(uchar *)&scsi_sg_q,\n\t\t\t\t\t\tsizeof(ASC_SG_LIST_Q) >> 1);\n\t\t\tAscMemDWordCopyPtrToLram(iop_base,\n\t\t\t\t\t\t q_addr + ASC_SGQ_LIST_BEG,\n\t\t\t\t\t\t (uchar *)&sg_head->\n\t\t\t\t\t\t sg_list[sg_index],\n\t\t\t\t\t\t sg_list_dwords);\n\t\t\tsg_index += ASC_SG_LIST_PER_Q;\n\t\t\tscsiq->next_sg_index = sg_index;\n\t\t}\n\t} else {\n\t\tscsiq->q1.cntl &= ~QC_SG_HEAD;\n\t}\n\tsta = AscPutReadyQueue(asc_dvc, scsiq, q_no);\n\tscsiq->q1.data_addr = saved_data_addr;\n\tscsiq->q1.data_cnt = saved_data_cnt;\n\treturn (sta);\n}\n\nstatic int\nAscSendScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar n_q_required)\n{\n\tPortAddr iop_base;\n\tuchar free_q_head;\n\tuchar next_qp;\n\tuchar tid_no;\n\tuchar target_ix;\n\tint sta;\n\n\tiop_base = asc_dvc->iop_base;\n\ttarget_ix = scsiq->q2.target_ix;\n\ttid_no = ASC_TIX_TO_TID(target_ix);\n\tsta = 0;\n\tfree_q_head = (uchar)AscGetVarFreeQHead(iop_base);\n\tif (n_q_required > 1) {\n\t\tnext_qp = AscAllocMultipleFreeQueue(iop_base, free_q_head,\n\t\t\t\t\t\t    (uchar)n_q_required);\n\t\tif (next_qp != ASC_QLINK_END) {\n\t\t\tasc_dvc->last_q_shortage = 0;\n\t\t\tscsiq->sg_head->queue_cnt = n_q_required - 1;\n\t\t\tscsiq->q1.q_no = free_q_head;\n\t\t\tsta = AscPutReadySgListQueue(asc_dvc, scsiq,\n\t\t\t\t\t\t     free_q_head);\n\t\t}\n\t} else if (n_q_required == 1) {\n\t\tnext_qp = AscAllocFreeQueue(iop_base, free_q_head);\n\t\tif (next_qp != ASC_QLINK_END) {\n\t\t\tscsiq->q1.q_no = free_q_head;\n\t\t\tsta = AscPutReadyQueue(asc_dvc, scsiq, free_q_head);\n\t\t}\n\t}\n\tif (sta == 1) {\n\t\tAscPutVarFreeQHead(iop_base, next_qp);\n\t\tasc_dvc->cur_total_qng += n_q_required;\n\t\tasc_dvc->cur_dvc_qng[tid_no]++;\n\t}\n\treturn sta;\n}\n\n#define ASC_SYN_OFFSET_ONE_DISABLE_LIST  16\nstatic uchar _syn_offset_one_disable_cmd[ASC_SYN_OFFSET_ONE_DISABLE_LIST] = {\n\tINQUIRY,\n\tREQUEST_SENSE,\n\tREAD_CAPACITY,\n\tREAD_TOC,\n\tMODE_SELECT,\n\tMODE_SENSE,\n\tMODE_SELECT_10,\n\tMODE_SENSE_10,\n\t0xFF,\n\t0xFF,\n\t0xFF,\n\t0xFF,\n\t0xFF,\n\t0xFF,\n\t0xFF,\n\t0xFF\n};\n\nstatic int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)\n{\n\tPortAddr iop_base;\n\tint sta;\n\tint n_q_required;\n\tbool disable_syn_offset_one_fix;\n\tint i;\n\tu32 addr;\n\tushort sg_entry_cnt = 0;\n\tushort sg_entry_cnt_minus_one = 0;\n\tuchar target_ix;\n\tuchar tid_no;\n\tuchar sdtr_data;\n\tuchar extra_bytes;\n\tuchar scsi_cmd;\n\tuchar disable_cmd;\n\tASC_SG_HEAD *sg_head;\n\tunsigned long data_cnt;\n\n\tiop_base = asc_dvc->iop_base;\n\tsg_head = scsiq->sg_head;\n\tif (asc_dvc->err_code != 0)\n\t\treturn ASC_ERROR;\n\tscsiq->q1.q_no = 0;\n\tif ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0) {\n\t\tscsiq->q1.extra_bytes = 0;\n\t}\n\tsta = 0;\n\ttarget_ix = scsiq->q2.target_ix;\n\ttid_no = ASC_TIX_TO_TID(target_ix);\n\tn_q_required = 1;\n\tif (scsiq->cdbptr[0] == REQUEST_SENSE) {\n\t\tif ((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) {\n\t\t\tasc_dvc->sdtr_done &= ~scsiq->q1.target_id;\n\t\t\tsdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);\n\t\t\tAscMsgOutSDTR(asc_dvc,\n\t\t\t\t      asc_dvc->\n\t\t\t\t      sdtr_period_tbl[(sdtr_data >> 4) &\n\t\t\t\t\t\t      (uchar)(asc_dvc->\n\t\t\t\t\t\t\t      max_sdtr_index -\n\t\t\t\t\t\t\t      1)],\n\t\t\t\t      (uchar)(sdtr_data & (uchar)\n\t\t\t\t\t      ASC_SYN_MAX_OFFSET));\n\t\t\tscsiq->q1.cntl |= (QC_MSG_OUT | QC_URGENT);\n\t\t}\n\t}\n\tif (asc_dvc->in_critical_cnt != 0) {\n\t\tAscSetLibErrorCode(asc_dvc, ASCQ_ERR_CRITICAL_RE_ENTRY);\n\t\treturn ASC_ERROR;\n\t}\n\tasc_dvc->in_critical_cnt++;\n\tif ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {\n\t\tif ((sg_entry_cnt = sg_head->entry_cnt) == 0) {\n\t\t\tasc_dvc->in_critical_cnt--;\n\t\t\treturn ASC_ERROR;\n\t\t}\n\t\tif (sg_entry_cnt > ASC_MAX_SG_LIST) {\n\t\t\tasc_dvc->in_critical_cnt--;\n\t\t\treturn ASC_ERROR;\n\t\t}\n\t\tif (sg_entry_cnt == 1) {\n\t\t\tscsiq->q1.data_addr = cpu_to_le32(sg_head->sg_list[0].addr);\n\t\t\tscsiq->q1.data_cnt = cpu_to_le32(sg_head->sg_list[0].bytes);\n\t\t\tscsiq->q1.cntl &= ~(QC_SG_HEAD | QC_SG_SWAP_QUEUE);\n\t\t}\n\t\tsg_entry_cnt_minus_one = sg_entry_cnt - 1;\n\t}\n\tscsi_cmd = scsiq->cdbptr[0];\n\tdisable_syn_offset_one_fix = false;\n\tif ((asc_dvc->pci_fix_asyn_xfer & scsiq->q1.target_id) &&\n\t    !(asc_dvc->pci_fix_asyn_xfer_always & scsiq->q1.target_id)) {\n\t\tif (scsiq->q1.cntl & QC_SG_HEAD) {\n\t\t\tdata_cnt = 0;\n\t\t\tfor (i = 0; i < sg_entry_cnt; i++) {\n\t\t\t\tdata_cnt += le32_to_cpu(sg_head->sg_list[i].\n\t\t\t\t\t\t\tbytes);\n\t\t\t}\n\t\t} else {\n\t\t\tdata_cnt = le32_to_cpu(scsiq->q1.data_cnt);\n\t\t}\n\t\tif (data_cnt != 0UL) {\n\t\t\tif (data_cnt < 512UL) {\n\t\t\t\tdisable_syn_offset_one_fix = true;\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < ASC_SYN_OFFSET_ONE_DISABLE_LIST;\n\t\t\t\t     i++) {\n\t\t\t\t\tdisable_cmd =\n\t\t\t\t\t    _syn_offset_one_disable_cmd[i];\n\t\t\t\t\tif (disable_cmd == 0xFF) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (scsi_cmd == disable_cmd) {\n\t\t\t\t\t\tdisable_syn_offset_one_fix =\n\t\t\t\t\t\t    true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (disable_syn_offset_one_fix) {\n\t\tscsiq->q2.tag_code &= ~SIMPLE_QUEUE_TAG;\n\t\tscsiq->q2.tag_code |= (ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX |\n\t\t\t\t       ASC_TAG_FLAG_DISABLE_DISCONNECT);\n\t} else {\n\t\tscsiq->q2.tag_code &= 0x27;\n\t}\n\tif ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {\n\t\tif (asc_dvc->bug_fix_cntl) {\n\t\t\tif (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {\n\t\t\t\tif ((scsi_cmd == READ_6) ||\n\t\t\t\t    (scsi_cmd == READ_10)) {\n\t\t\t\t\taddr = le32_to_cpu(sg_head->\n\t\t\t\t\t\t\t\t   sg_list\n\t\t\t\t\t\t\t\t   [sg_entry_cnt_minus_one].\n\t\t\t\t\t\t\t\t   addr) +\n\t\t\t\t\t\tle32_to_cpu(sg_head->\n\t\t\t\t\t\t\t\t  sg_list\n\t\t\t\t\t\t\t\t  [sg_entry_cnt_minus_one].\n\t\t\t\t\t\t\t\t  bytes);\n\t\t\t\t\textra_bytes =\n\t\t\t\t\t    (uchar)((ushort)addr & 0x0003);\n\t\t\t\t\tif ((extra_bytes != 0)\n\t\t\t\t\t    &&\n\t\t\t\t\t    ((scsiq->q2.\n\t\t\t\t\t      tag_code &\n\t\t\t\t\t      ASC_TAG_FLAG_EXTRA_BYTES)\n\t\t\t\t\t     == 0)) {\n\t\t\t\t\t\tscsiq->q2.tag_code |=\n\t\t\t\t\t\t    ASC_TAG_FLAG_EXTRA_BYTES;\n\t\t\t\t\t\tscsiq->q1.extra_bytes =\n\t\t\t\t\t\t    extra_bytes;\n\t\t\t\t\t\tdata_cnt =\n\t\t\t\t\t\t    le32_to_cpu(sg_head->\n\t\t\t\t\t\t\t\tsg_list\n\t\t\t\t\t\t\t\t[sg_entry_cnt_minus_one].\n\t\t\t\t\t\t\t\tbytes);\n\t\t\t\t\t\tdata_cnt -= extra_bytes;\n\t\t\t\t\t\tsg_head->\n\t\t\t\t\t\t    sg_list\n\t\t\t\t\t\t    [sg_entry_cnt_minus_one].\n\t\t\t\t\t\t    bytes =\n\t\t\t\t\t\t    cpu_to_le32(data_cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsg_head->entry_to_copy = sg_head->entry_cnt;\n\t\tn_q_required = AscSgListToQueue(sg_entry_cnt);\n\t\tif ((AscGetNumOfFreeQueue(asc_dvc, target_ix, n_q_required) >=\n\t\t     (uint) n_q_required)\n\t\t    || ((scsiq->q1.cntl & QC_URGENT) != 0)) {\n\t\t\tif ((sta =\n\t\t\t     AscSendScsiQueue(asc_dvc, scsiq,\n\t\t\t\t\t      n_q_required)) == 1) {\n\t\t\t\tasc_dvc->in_critical_cnt--;\n\t\t\t\treturn (sta);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (asc_dvc->bug_fix_cntl) {\n\t\t\tif (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {\n\t\t\t\tif ((scsi_cmd == READ_6) ||\n\t\t\t\t    (scsi_cmd == READ_10)) {\n\t\t\t\t\taddr =\n\t\t\t\t\t    le32_to_cpu(scsiq->q1.data_addr) +\n\t\t\t\t\t    le32_to_cpu(scsiq->q1.data_cnt);\n\t\t\t\t\textra_bytes =\n\t\t\t\t\t    (uchar)((ushort)addr & 0x0003);\n\t\t\t\t\tif ((extra_bytes != 0)\n\t\t\t\t\t    &&\n\t\t\t\t\t    ((scsiq->q2.\n\t\t\t\t\t      tag_code &\n\t\t\t\t\t      ASC_TAG_FLAG_EXTRA_BYTES)\n\t\t\t\t\t     == 0)) {\n\t\t\t\t\t\tdata_cnt =\n\t\t\t\t\t\t    le32_to_cpu(scsiq->q1.\n\t\t\t\t\t\t\t\tdata_cnt);\n\t\t\t\t\t\tif (((ushort)data_cnt & 0x01FF)\n\t\t\t\t\t\t    == 0) {\n\t\t\t\t\t\t\tscsiq->q2.tag_code |=\n\t\t\t\t\t\t\t    ASC_TAG_FLAG_EXTRA_BYTES;\n\t\t\t\t\t\t\tdata_cnt -= extra_bytes;\n\t\t\t\t\t\t\tscsiq->q1.data_cnt =\n\t\t\t\t\t\t\t    cpu_to_le32\n\t\t\t\t\t\t\t    (data_cnt);\n\t\t\t\t\t\t\tscsiq->q1.extra_bytes =\n\t\t\t\t\t\t\t    extra_bytes;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tn_q_required = 1;\n\t\tif ((AscGetNumOfFreeQueue(asc_dvc, target_ix, 1) >= 1) ||\n\t\t    ((scsiq->q1.cntl & QC_URGENT) != 0)) {\n\t\t\tif ((sta = AscSendScsiQueue(asc_dvc, scsiq,\n\t\t\t\t\t\t    n_q_required)) == 1) {\n\t\t\t\tasc_dvc->in_critical_cnt--;\n\t\t\t\treturn (sta);\n\t\t\t}\n\t\t}\n\t}\n\tasc_dvc->in_critical_cnt--;\n\treturn (sta);\n}\n\n \nstatic int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, adv_req_t *reqp)\n{\n\tAdvPortAddr iop_base;\n\tADV_CARR_T *new_carrp;\n\tADV_SCSI_REQ_Q *scsiq = &reqp->scsi_req_q;\n\n\t \n\tif (scsiq->target_id > ADV_MAX_TID) {\n\t\tscsiq->host_status = QHSTA_M_INVALID_DEVICE;\n\t\tscsiq->done_status = QD_WITH_ERROR;\n\t\treturn ADV_ERROR;\n\t}\n\n\tiop_base = asc_dvc->iop_base;\n\n\t \n\tnew_carrp = adv_get_next_carrier(asc_dvc);\n\tif (!new_carrp) {\n\t\tASC_DBG(1, \"No free carriers\\n\");\n\t\treturn ADV_BUSY;\n\t}\n\n\tasc_dvc->carr_pending_cnt++;\n\n\t \n\tscsiq->scsiq_ptr = cpu_to_le32(scsiq->srb_tag);\n\tscsiq->scsiq_rptr = cpu_to_le32(reqp->req_addr);\n\n\tscsiq->carr_va = asc_dvc->icq_sp->carr_va;\n\tscsiq->carr_pa = asc_dvc->icq_sp->carr_pa;\n\n\t \n\tasc_dvc->icq_sp->areq_vpa = scsiq->scsiq_rptr;\n\n\t \n\tasc_dvc->icq_sp->next_vpa = new_carrp->carr_pa;\n\n\t \n\tasc_dvc->icq_sp = new_carrp;\n\n\tif (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||\n\t    asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\t \n\t\tAdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_A);\n\t\tif (asc_dvc->chip_type == ADV_CHIP_ASC3550) {\n\t\t\t \n\t\t\tAdvWriteByteRegister(iop_base, IOPB_TICKLE,\n\t\t\t\t\t     ADV_TICKLE_NOP);\n\t\t}\n\t} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {\n\t\t \n\t\tAdvWriteDWordRegister(iop_base, IOPDW_COMMA,\n\t\t\t\t      le32_to_cpu(new_carrp->carr_pa));\n\t}\n\n\treturn ADV_SUCCESS;\n}\n\n \nstatic int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)\n{\n\tint ret, err_code;\n\tstruct asc_board *boardp = shost_priv(scp->device->host);\n\n\tASC_DBG(1, \"scp 0x%p\\n\", scp);\n\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;\n\t\tstruct asc_scsi_q asc_scsi_q;\n\n\t\tret = asc_build_req(boardp, scp, &asc_scsi_q);\n\t\tif (ret != ASC_NOERROR) {\n\t\t\tASC_STATS(scp->device->host, build_error);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = AscExeScsiQueue(asc_dvc, &asc_scsi_q);\n\t\tkfree(asc_scsi_q.sg_head);\n\t\terr_code = asc_dvc->err_code;\n\t} else {\n\t\tADV_DVC_VAR *adv_dvc = &boardp->dvc_var.adv_dvc_var;\n\t\tadv_req_t *adv_reqp;\n\n\t\tswitch (adv_build_req(boardp, scp, &adv_reqp)) {\n\t\tcase ASC_NOERROR:\n\t\t\tASC_DBG(3, \"adv_build_req ASC_NOERROR\\n\");\n\t\t\tbreak;\n\t\tcase ASC_BUSY:\n\t\t\tASC_DBG(1, \"adv_build_req ASC_BUSY\\n\");\n\t\t\t \n\t\t\treturn ASC_BUSY;\n\t\tcase ASC_ERROR:\n\t\tdefault:\n\t\t\tASC_DBG(1, \"adv_build_req ASC_ERROR\\n\");\n\t\t\tASC_STATS(scp->device->host, build_error);\n\t\t\treturn ASC_ERROR;\n\t\t}\n\n\t\tret = AdvExeScsiQueue(adv_dvc, adv_reqp);\n\t\terr_code = adv_dvc->err_code;\n\t}\n\n\tswitch (ret) {\n\tcase ASC_NOERROR:\n\t\tASC_STATS(scp->device->host, exe_noerror);\n\t\t \n\t\tboardp->reqcnt[scp->device->id]++;\n\t\tASC_DBG(1, \"ExeScsiQueue() ASC_NOERROR\\n\");\n\t\tbreak;\n\tcase ASC_BUSY:\n\t\tASC_DBG(1, \"ExeScsiQueue() ASC_BUSY\\n\");\n\t\tASC_STATS(scp->device->host, exe_busy);\n\t\tbreak;\n\tcase ASC_ERROR:\n\t\tscmd_printk(KERN_ERR, scp, \"ExeScsiQueue() ASC_ERROR, \"\n\t\t\t\"err_code 0x%x\\n\", err_code);\n\t\tASC_STATS(scp->device->host, exe_error);\n\t\tset_host_byte(scp, DID_ERROR);\n\t\tbreak;\n\tdefault:\n\t\tscmd_printk(KERN_ERR, scp, \"ExeScsiQueue() unknown, \"\n\t\t\t\"err_code 0x%x\\n\", err_code);\n\t\tASC_STATS(scp->device->host, exe_unknown);\n\t\tset_host_byte(scp, DID_ERROR);\n\t\tbreak;\n\t}\n\n\tASC_DBG(1, \"end\\n\");\n\treturn ret;\n}\n\n \nstatic int advansys_queuecommand_lck(struct scsi_cmnd *scp)\n{\n\tstruct Scsi_Host *shost = scp->device->host;\n\tint asc_res, result = 0;\n\n\tASC_STATS(shost, queuecommand);\n\n\tasc_res = asc_execute_scsi_cmnd(scp);\n\n\tswitch (asc_res) {\n\tcase ASC_NOERROR:\n\t\tbreak;\n\tcase ASC_BUSY:\n\t\tresult = SCSI_MLQUEUE_HOST_BUSY;\n\t\tbreak;\n\tcase ASC_ERROR:\n\tdefault:\n\t\tasc_scsi_done(scp);\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic DEF_SCSI_QCMD(advansys_queuecommand)\n\nstatic ushort AscGetEisaChipCfg(PortAddr iop_base)\n{\n\tPortAddr eisa_cfg_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |\n\t    (PortAddr) (ASC_EISA_CFG_IOP_MASK);\n\treturn inpw(eisa_cfg_iop);\n}\n\n \nstatic unsigned short AscGetChipBiosAddress(PortAddr iop_base,\n\t\t\t\t\t    unsigned short bus_type)\n{\n\tunsigned short cfg_lsw;\n\tunsigned short bios_addr;\n\n\t \n\tif (bus_type & ASC_IS_PCI)\n\t\treturn 0;\n\n\tif ((bus_type & ASC_IS_EISA) != 0) {\n\t\tcfg_lsw = AscGetEisaChipCfg(iop_base);\n\t\tcfg_lsw &= 0x000F;\n\t\tbios_addr = ASC_BIOS_MIN_ADDR + cfg_lsw * ASC_BIOS_BANK_SIZE;\n\t\treturn bios_addr;\n\t}\n\n\tcfg_lsw = AscGetChipCfgLsw(iop_base);\n\tbios_addr = ASC_BIOS_MIN_ADDR + (cfg_lsw >> 12) * ASC_BIOS_BANK_SIZE;\n\treturn bios_addr;\n}\n\nstatic uchar AscSetChipScsiID(PortAddr iop_base, uchar new_host_id)\n{\n\tushort cfg_lsw;\n\n\tif (AscGetChipScsiID(iop_base) == new_host_id) {\n\t\treturn (new_host_id);\n\t}\n\tcfg_lsw = AscGetChipCfgLsw(iop_base);\n\tcfg_lsw &= 0xF8FF;\n\tcfg_lsw |= (ushort)((new_host_id & ASC_MAX_TID) << 8);\n\tAscSetChipCfgLsw(iop_base, cfg_lsw);\n\treturn (AscGetChipScsiID(iop_base));\n}\n\nstatic unsigned char AscGetChipScsiCtrl(PortAddr iop_base)\n{\n\tunsigned char sc;\n\n\tAscSetBank(iop_base, 1);\n\tsc = inp(iop_base + IOP_REG_SC);\n\tAscSetBank(iop_base, 0);\n\treturn sc;\n}\n\nstatic unsigned char AscGetChipVersion(PortAddr iop_base,\n\t\t\t\t       unsigned short bus_type)\n{\n\tif (bus_type & ASC_IS_EISA) {\n\t\tPortAddr eisa_iop;\n\t\tunsigned char revision;\n\t\teisa_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |\n\t\t    (PortAddr) ASC_EISA_REV_IOP_MASK;\n\t\trevision = inp(eisa_iop);\n\t\treturn ASC_CHIP_MIN_VER_EISA - 1 + revision;\n\t}\n\treturn AscGetChipVerNo(iop_base);\n}\n\nstatic int AscStopQueueExe(PortAddr iop_base)\n{\n\tint count = 0;\n\n\tif (AscReadLramByte(iop_base, ASCV_STOP_CODE_B) == 0) {\n\t\tAscWriteLramByte(iop_base, ASCV_STOP_CODE_B,\n\t\t\t\t ASC_STOP_REQ_RISC_STOP);\n\t\tdo {\n\t\t\tif (AscReadLramByte(iop_base, ASCV_STOP_CODE_B) &\n\t\t\t    ASC_STOP_ACK_RISC_STOP) {\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tmdelay(100);\n\t\t} while (count++ < 20);\n\t}\n\treturn (0);\n}\n\nstatic unsigned int AscGetMaxDmaCount(ushort bus_type)\n{\n\tif (bus_type & (ASC_IS_EISA | ASC_IS_VL))\n\t\treturn ASC_MAX_VL_DMA_COUNT;\n\treturn ASC_MAX_PCI_DMA_COUNT;\n}\n\nstatic void AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)\n{\n\tint i;\n\tPortAddr iop_base;\n\tuchar chip_version;\n\n\tiop_base = asc_dvc->iop_base;\n\tasc_dvc->err_code = 0;\n\tif ((asc_dvc->bus_type &\n\t     (ASC_IS_PCI | ASC_IS_EISA | ASC_IS_VL)) == 0) {\n\t\tasc_dvc->err_code |= ASC_IERR_NO_BUS_TYPE;\n\t}\n\tAscSetChipControl(iop_base, CC_HALT);\n\tAscSetChipStatus(iop_base, 0);\n\tasc_dvc->bug_fix_cntl = 0;\n\tasc_dvc->pci_fix_asyn_xfer = 0;\n\tasc_dvc->pci_fix_asyn_xfer_always = 0;\n\t \n\tasc_dvc->sdtr_done = 0;\n\tasc_dvc->cur_total_qng = 0;\n\tasc_dvc->is_in_int = false;\n\tasc_dvc->in_critical_cnt = 0;\n\tasc_dvc->last_q_shortage = 0;\n\tasc_dvc->use_tagged_qng = 0;\n\tasc_dvc->no_scam = 0;\n\tasc_dvc->unit_not_ready = 0;\n\tasc_dvc->queue_full_or_busy = 0;\n\tasc_dvc->redo_scam = 0;\n\tasc_dvc->res2 = 0;\n\tasc_dvc->min_sdtr_index = 0;\n\tasc_dvc->cfg->can_tagged_qng = 0;\n\tasc_dvc->cfg->cmd_qng_enabled = 0;\n\tasc_dvc->dvc_cntl = ASC_DEF_DVC_CNTL;\n\tasc_dvc->init_sdtr = 0;\n\tasc_dvc->max_total_qng = ASC_DEF_MAX_TOTAL_QNG;\n\tasc_dvc->scsi_reset_wait = 3;\n\tasc_dvc->start_motor = ASC_SCSI_WIDTH_BIT_SET;\n\tasc_dvc->max_dma_count = AscGetMaxDmaCount(asc_dvc->bus_type);\n\tasc_dvc->cfg->sdtr_enable = ASC_SCSI_WIDTH_BIT_SET;\n\tasc_dvc->cfg->disc_enable = ASC_SCSI_WIDTH_BIT_SET;\n\tasc_dvc->cfg->chip_scsi_id = ASC_DEF_CHIP_SCSI_ID;\n\tchip_version = AscGetChipVersion(iop_base, asc_dvc->bus_type);\n\tasc_dvc->cfg->chip_version = chip_version;\n\tasc_dvc->sdtr_period_tbl = asc_syn_xfer_period;\n\tasc_dvc->max_sdtr_index = 7;\n\tif ((asc_dvc->bus_type & ASC_IS_PCI) &&\n\t    (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3150)) {\n\t\tasc_dvc->bus_type = ASC_IS_PCI_ULTRA;\n\t\tasc_dvc->sdtr_period_tbl = asc_syn_ultra_xfer_period;\n\t\tasc_dvc->max_sdtr_index = 15;\n\t\tif (chip_version == ASC_CHIP_VER_PCI_ULTRA_3150) {\n\t\t\tAscSetExtraControl(iop_base,\n\t\t\t\t\t   (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));\n\t\t} else if (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3050) {\n\t\t\tAscSetExtraControl(iop_base,\n\t\t\t\t\t   (SEC_ACTIVE_NEGATE |\n\t\t\t\t\t    SEC_ENABLE_FILTER));\n\t\t}\n\t}\n\tif (asc_dvc->bus_type == ASC_IS_PCI) {\n\t\tAscSetExtraControl(iop_base,\n\t\t\t\t   (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));\n\t}\n\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tasc_dvc->cur_dvc_qng[i] = 0;\n\t\tasc_dvc->max_dvc_qng[i] = ASC_MAX_SCSI1_QNG;\n\t\tasc_dvc->scsiq_busy_head[i] = (ASC_SCSI_Q *)0L;\n\t\tasc_dvc->scsiq_busy_tail[i] = (ASC_SCSI_Q *)0L;\n\t\tasc_dvc->cfg->max_tag_qng[i] = ASC_MAX_INRAM_TAG_QNG;\n\t}\n}\n\nstatic int AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg)\n{\n\tint retry;\n\n\tfor (retry = 0; retry < ASC_EEP_MAX_RETRY; retry++) {\n\t\tunsigned char read_back;\n\t\tAscSetChipEEPCmd(iop_base, cmd_reg);\n\t\tmdelay(1);\n\t\tread_back = AscGetChipEEPCmd(iop_base);\n\t\tif (read_back == cmd_reg)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void AscWaitEEPRead(void)\n{\n\tmdelay(1);\n}\n\nstatic ushort AscReadEEPWord(PortAddr iop_base, uchar addr)\n{\n\tushort read_wval;\n\tuchar cmd_reg;\n\n\tAscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);\n\tAscWaitEEPRead();\n\tcmd_reg = addr | ASC_EEP_CMD_READ;\n\tAscWriteEEPCmdReg(iop_base, cmd_reg);\n\tAscWaitEEPRead();\n\tread_wval = AscGetChipEEPData(iop_base);\n\tAscWaitEEPRead();\n\treturn read_wval;\n}\n\nstatic ushort AscGetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf,\n\t\t\t      ushort bus_type)\n{\n\tushort wval;\n\tushort sum;\n\tushort *wbuf;\n\tint cfg_beg;\n\tint cfg_end;\n\tint uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;\n\tint s_addr;\n\n\twbuf = (ushort *)cfg_buf;\n\tsum = 0;\n\t \n\tfor (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {\n\t\t*wbuf = AscReadEEPWord(iop_base, (uchar)s_addr);\n\t\tsum += *wbuf;\n\t}\n\tif (bus_type & ASC_IS_VL) {\n\t\tcfg_beg = ASC_EEP_DVC_CFG_BEG_VL;\n\t\tcfg_end = ASC_EEP_MAX_DVC_ADDR_VL;\n\t} else {\n\t\tcfg_beg = ASC_EEP_DVC_CFG_BEG;\n\t\tcfg_end = ASC_EEP_MAX_DVC_ADDR;\n\t}\n\tfor (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {\n\t\twval = AscReadEEPWord(iop_base, (uchar)s_addr);\n\t\tif (s_addr <= uchar_end_in_config) {\n\t\t\t \n\t\t\t*wbuf = le16_to_cpu(wval);\n\t\t} else {\n\t\t\t \n\t\t\t*wbuf = wval;\n\t\t}\n\t\tsum += wval;\t \n\t}\n\t \n\t*wbuf = AscReadEEPWord(iop_base, (uchar)s_addr);\n\treturn sum;\n}\n\nstatic int AscTestExternalLram(ASC_DVC_VAR *asc_dvc)\n{\n\tPortAddr iop_base;\n\tushort q_addr;\n\tushort saved_word;\n\tint sta;\n\n\tiop_base = asc_dvc->iop_base;\n\tsta = 0;\n\tq_addr = ASC_QNO_TO_QADDR(241);\n\tsaved_word = AscReadLramWord(iop_base, q_addr);\n\tAscSetChipLramAddr(iop_base, q_addr);\n\tAscSetChipLramData(iop_base, 0x55AA);\n\tmdelay(10);\n\tAscSetChipLramAddr(iop_base, q_addr);\n\tif (AscGetChipLramData(iop_base) == 0x55AA) {\n\t\tsta = 1;\n\t\tAscWriteLramWord(iop_base, q_addr, saved_word);\n\t}\n\treturn (sta);\n}\n\nstatic void AscWaitEEPWrite(void)\n{\n\tmdelay(20);\n}\n\nstatic int AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)\n{\n\tushort read_back;\n\tint retry;\n\n\tretry = 0;\n\twhile (true) {\n\t\tAscSetChipEEPData(iop_base, data_reg);\n\t\tmdelay(1);\n\t\tread_back = AscGetChipEEPData(iop_base);\n\t\tif (read_back == data_reg) {\n\t\t\treturn (1);\n\t\t}\n\t\tif (retry++ > ASC_EEP_MAX_RETRY) {\n\t\t\treturn (0);\n\t\t}\n\t}\n}\n\nstatic ushort AscWriteEEPWord(PortAddr iop_base, uchar addr, ushort word_val)\n{\n\tushort read_wval;\n\n\tread_wval = AscReadEEPWord(iop_base, addr);\n\tif (read_wval != word_val) {\n\t\tAscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_ABLE);\n\t\tAscWaitEEPRead();\n\t\tAscWriteEEPDataReg(iop_base, word_val);\n\t\tAscWaitEEPRead();\n\t\tAscWriteEEPCmdReg(iop_base,\n\t\t\t\t  (uchar)((uchar)ASC_EEP_CMD_WRITE | addr));\n\t\tAscWaitEEPWrite();\n\t\tAscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);\n\t\tAscWaitEEPRead();\n\t\treturn (AscReadEEPWord(iop_base, addr));\n\t}\n\treturn (read_wval);\n}\n\nstatic int AscSetEEPConfigOnce(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf,\n\t\t\t       ushort bus_type)\n{\n\tint n_error;\n\tushort *wbuf;\n\tushort word;\n\tushort sum;\n\tint s_addr;\n\tint cfg_beg;\n\tint cfg_end;\n\tint uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;\n\n\twbuf = (ushort *)cfg_buf;\n\tn_error = 0;\n\tsum = 0;\n\t \n\tfor (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {\n\t\tsum += *wbuf;\n\t\tif (*wbuf != AscWriteEEPWord(iop_base, (uchar)s_addr, *wbuf)) {\n\t\t\tn_error++;\n\t\t}\n\t}\n\tif (bus_type & ASC_IS_VL) {\n\t\tcfg_beg = ASC_EEP_DVC_CFG_BEG_VL;\n\t\tcfg_end = ASC_EEP_MAX_DVC_ADDR_VL;\n\t} else {\n\t\tcfg_beg = ASC_EEP_DVC_CFG_BEG;\n\t\tcfg_end = ASC_EEP_MAX_DVC_ADDR;\n\t}\n\tfor (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {\n\t\tif (s_addr <= uchar_end_in_config) {\n\t\t\t \n\t\t\tword = cpu_to_le16(*wbuf);\n\t\t\tif (word !=\n\t\t\t    AscWriteEEPWord(iop_base, (uchar)s_addr, word)) {\n\t\t\t\tn_error++;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (*wbuf !=\n\t\t\t    AscWriteEEPWord(iop_base, (uchar)s_addr, *wbuf)) {\n\t\t\t\tn_error++;\n\t\t\t}\n\t\t}\n\t\tsum += *wbuf;\t \n\t}\n\t \n\t*wbuf = sum;\n\tif (sum != AscWriteEEPWord(iop_base, (uchar)s_addr, sum)) {\n\t\tn_error++;\n\t}\n\n\t \n\twbuf = (ushort *)cfg_buf;\n\t \n\tfor (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {\n\t\tif (*wbuf != AscReadEEPWord(iop_base, (uchar)s_addr)) {\n\t\t\tn_error++;\n\t\t}\n\t}\n\tif (bus_type & ASC_IS_VL) {\n\t\tcfg_beg = ASC_EEP_DVC_CFG_BEG_VL;\n\t\tcfg_end = ASC_EEP_MAX_DVC_ADDR_VL;\n\t} else {\n\t\tcfg_beg = ASC_EEP_DVC_CFG_BEG;\n\t\tcfg_end = ASC_EEP_MAX_DVC_ADDR;\n\t}\n\tfor (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {\n\t\tif (s_addr <= uchar_end_in_config) {\n\t\t\t \n\t\t\tword =\n\t\t\t    le16_to_cpu(AscReadEEPWord\n\t\t\t\t\t(iop_base, (uchar)s_addr));\n\t\t} else {\n\t\t\t \n\t\t\tword = AscReadEEPWord(iop_base, (uchar)s_addr);\n\t\t}\n\t\tif (*wbuf != word) {\n\t\t\tn_error++;\n\t\t}\n\t}\n\t \n\tif (AscReadEEPWord(iop_base, (uchar)s_addr) != sum) {\n\t\tn_error++;\n\t}\n\treturn n_error;\n}\n\nstatic int AscSetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf,\n\t\t\t   ushort bus_type)\n{\n\tint retry;\n\tint n_error;\n\n\tretry = 0;\n\twhile (true) {\n\t\tif ((n_error = AscSetEEPConfigOnce(iop_base, cfg_buf,\n\t\t\t\t\t\t   bus_type)) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (++retry > ASC_EEP_MAX_RETRY) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn n_error;\n}\n\nstatic int AscInitFromEEP(ASC_DVC_VAR *asc_dvc)\n{\n\tASCEEP_CONFIG eep_config_buf;\n\tASCEEP_CONFIG *eep_config;\n\tPortAddr iop_base;\n\tushort chksum;\n\tushort warn_code;\n\tushort cfg_msw, cfg_lsw;\n\tint i;\n\tint write_eep = 0;\n\n\tiop_base = asc_dvc->iop_base;\n\twarn_code = 0;\n\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0x00FE);\n\tAscStopQueueExe(iop_base);\n\tif ((AscStopChip(iop_base)) ||\n\t    (AscGetChipScsiCtrl(iop_base) != 0)) {\n\t\tasc_dvc->init_state |= ASC_INIT_RESET_SCSI_DONE;\n\t\tAscResetChipAndScsiBus(asc_dvc);\n\t\tmdelay(asc_dvc->scsi_reset_wait * 1000);  \n\t}\n\tif (!AscIsChipHalted(iop_base)) {\n\t\tasc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;\n\t\treturn (warn_code);\n\t}\n\tAscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);\n\tif (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {\n\t\tasc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;\n\t\treturn (warn_code);\n\t}\n\teep_config = (ASCEEP_CONFIG *)&eep_config_buf;\n\tcfg_msw = AscGetChipCfgMsw(iop_base);\n\tcfg_lsw = AscGetChipCfgLsw(iop_base);\n\tif ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {\n\t\tcfg_msw &= ~ASC_CFG_MSW_CLR_MASK;\n\t\twarn_code |= ASC_WARN_CFG_MSW_RECOVER;\n\t\tAscSetChipCfgMsw(iop_base, cfg_msw);\n\t}\n\tchksum = AscGetEEPConfig(iop_base, eep_config, asc_dvc->bus_type);\n\tASC_DBG(1, \"chksum 0x%x\\n\", chksum);\n\tif (chksum == 0) {\n\t\tchksum = 0xaa55;\n\t}\n\tif (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {\n\t\twarn_code |= ASC_WARN_AUTO_CONFIG;\n\t\tif (asc_dvc->cfg->chip_version == 3) {\n\t\t\tif (eep_config->cfg_lsw != cfg_lsw) {\n\t\t\t\twarn_code |= ASC_WARN_EEPROM_RECOVER;\n\t\t\t\teep_config->cfg_lsw =\n\t\t\t\t    AscGetChipCfgLsw(iop_base);\n\t\t\t}\n\t\t\tif (eep_config->cfg_msw != cfg_msw) {\n\t\t\t\twarn_code |= ASC_WARN_EEPROM_RECOVER;\n\t\t\t\teep_config->cfg_msw =\n\t\t\t\t    AscGetChipCfgMsw(iop_base);\n\t\t\t}\n\t\t}\n\t}\n\teep_config->cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;\n\teep_config->cfg_lsw |= ASC_CFG0_HOST_INT_ON;\n\tASC_DBG(1, \"eep_config->chksum 0x%x\\n\", eep_config->chksum);\n\tif (chksum != eep_config->chksum) {\n\t\tif (AscGetChipVersion(iop_base, asc_dvc->bus_type) ==\n\t\t    ASC_CHIP_VER_PCI_ULTRA_3050) {\n\t\t\tASC_DBG(1, \"chksum error ignored; EEPROM-less board\\n\");\n\t\t\teep_config->init_sdtr = 0xFF;\n\t\t\teep_config->disc_enable = 0xFF;\n\t\t\teep_config->start_motor = 0xFF;\n\t\t\teep_config->use_cmd_qng = 0;\n\t\t\teep_config->max_total_qng = 0xF0;\n\t\t\teep_config->max_tag_qng = 0x20;\n\t\t\teep_config->cntl = 0xBFFF;\n\t\t\tASC_EEP_SET_CHIP_ID(eep_config, 7);\n\t\t\teep_config->no_scam = 0;\n\t\t\teep_config->adapter_info[0] = 0;\n\t\t\teep_config->adapter_info[1] = 0;\n\t\t\teep_config->adapter_info[2] = 0;\n\t\t\teep_config->adapter_info[3] = 0;\n\t\t\teep_config->adapter_info[4] = 0;\n\t\t\t \n\t\t\teep_config->adapter_info[5] = 0xBB;\n\t\t} else {\n\t\t\tASC_PRINT\n\t\t\t    (\"AscInitFromEEP: EEPROM checksum error; Will try to re-write EEPROM.\\n\");\n\t\t\twrite_eep = 1;\n\t\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\t\t}\n\t}\n\tasc_dvc->cfg->sdtr_enable = eep_config->init_sdtr;\n\tasc_dvc->cfg->disc_enable = eep_config->disc_enable;\n\tasc_dvc->cfg->cmd_qng_enabled = eep_config->use_cmd_qng;\n\tasc_dvc->start_motor = eep_config->start_motor;\n\tasc_dvc->dvc_cntl = eep_config->cntl;\n\tasc_dvc->no_scam = eep_config->no_scam;\n\tasc_dvc->cfg->adapter_info[0] = eep_config->adapter_info[0];\n\tasc_dvc->cfg->adapter_info[1] = eep_config->adapter_info[1];\n\tasc_dvc->cfg->adapter_info[2] = eep_config->adapter_info[2];\n\tasc_dvc->cfg->adapter_info[3] = eep_config->adapter_info[3];\n\tasc_dvc->cfg->adapter_info[4] = eep_config->adapter_info[4];\n\tasc_dvc->cfg->adapter_info[5] = eep_config->adapter_info[5];\n\tif (!AscTestExternalLram(asc_dvc)) {\n\t\tif (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) ==\n\t\t     ASC_IS_PCI_ULTRA)) {\n\t\t\teep_config->max_total_qng =\n\t\t\t    ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG;\n\t\t\teep_config->max_tag_qng =\n\t\t\t    ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG;\n\t\t} else {\n\t\t\teep_config->cfg_msw |= 0x0800;\n\t\t\tcfg_msw |= 0x0800;\n\t\t\tAscSetChipCfgMsw(iop_base, cfg_msw);\n\t\t\teep_config->max_total_qng = ASC_MAX_PCI_INRAM_TOTAL_QNG;\n\t\t\teep_config->max_tag_qng = ASC_MAX_INRAM_TAG_QNG;\n\t\t}\n\t} else {\n\t}\n\tif (eep_config->max_total_qng < ASC_MIN_TOTAL_QNG) {\n\t\teep_config->max_total_qng = ASC_MIN_TOTAL_QNG;\n\t}\n\tif (eep_config->max_total_qng > ASC_MAX_TOTAL_QNG) {\n\t\teep_config->max_total_qng = ASC_MAX_TOTAL_QNG;\n\t}\n\tif (eep_config->max_tag_qng > eep_config->max_total_qng) {\n\t\teep_config->max_tag_qng = eep_config->max_total_qng;\n\t}\n\tif (eep_config->max_tag_qng < ASC_MIN_TAG_Q_PER_DVC) {\n\t\teep_config->max_tag_qng = ASC_MIN_TAG_Q_PER_DVC;\n\t}\n\tasc_dvc->max_total_qng = eep_config->max_total_qng;\n\tif ((eep_config->use_cmd_qng & eep_config->disc_enable) !=\n\t    eep_config->use_cmd_qng) {\n\t\teep_config->disc_enable = eep_config->use_cmd_qng;\n\t\twarn_code |= ASC_WARN_CMD_QNG_CONFLICT;\n\t}\n\tASC_EEP_SET_CHIP_ID(eep_config,\n\t\t\t    ASC_EEP_GET_CHIP_ID(eep_config) & ASC_MAX_TID);\n\tasc_dvc->cfg->chip_scsi_id = ASC_EEP_GET_CHIP_ID(eep_config);\n\tif (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) &&\n\t    !(asc_dvc->dvc_cntl & ASC_CNTL_SDTR_ENABLE_ULTRA)) {\n\t\tasc_dvc->min_sdtr_index = ASC_SDTR_ULTRA_PCI_10MB_INDEX;\n\t}\n\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tasc_dvc->dos_int13_table[i] = eep_config->dos_int13_table[i];\n\t\tasc_dvc->cfg->max_tag_qng[i] = eep_config->max_tag_qng;\n\t\tasc_dvc->cfg->sdtr_period_offset[i] =\n\t\t    (uchar)(ASC_DEF_SDTR_OFFSET |\n\t\t\t    (asc_dvc->min_sdtr_index << 4));\n\t}\n\teep_config->cfg_msw = AscGetChipCfgMsw(iop_base);\n\tif (write_eep) {\n\t\tif ((i = AscSetEEPConfig(iop_base, eep_config,\n\t\t\t\t     asc_dvc->bus_type)) != 0) {\n\t\t\tASC_PRINT1\n\t\t\t    (\"AscInitFromEEP: Failed to re-write EEPROM with %d errors.\\n\",\n\t\t\t     i);\n\t\t} else {\n\t\t\tASC_PRINT\n\t\t\t    (\"AscInitFromEEP: Successfully re-wrote EEPROM.\\n\");\n\t\t}\n\t}\n\treturn (warn_code);\n}\n\nstatic int AscInitGetConfig(struct Scsi_Host *shost)\n{\n\tstruct asc_board *board = shost_priv(shost);\n\tASC_DVC_VAR *asc_dvc = &board->dvc_var.asc_dvc_var;\n\tunsigned short warn_code = 0;\n\n\tasc_dvc->init_state = ASC_INIT_STATE_BEG_GET_CFG;\n\tif (asc_dvc->err_code != 0)\n\t\treturn asc_dvc->err_code;\n\n\tif (AscFindSignature(asc_dvc->iop_base)) {\n\t\tAscInitAscDvcVar(asc_dvc);\n\t\twarn_code = AscInitFromEEP(asc_dvc);\n\t\tasc_dvc->init_state |= ASC_INIT_STATE_END_GET_CFG;\n\t\tif (asc_dvc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT)\n\t\t\tasc_dvc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT;\n\t} else {\n\t\tasc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;\n\t}\n\n\tswitch (warn_code) {\n\tcase 0:\t \n\t\tbreak;\n\tcase ASC_WARN_IO_PORT_ROTATE:\n\t\tshost_printk(KERN_WARNING, shost, \"I/O port address \"\n\t\t\t\t\"modified\\n\");\n\t\tbreak;\n\tcase ASC_WARN_AUTO_CONFIG:\n\t\tshost_printk(KERN_WARNING, shost, \"I/O port increment switch \"\n\t\t\t\t\"enabled\\n\");\n\t\tbreak;\n\tcase ASC_WARN_EEPROM_CHKSUM:\n\t\tshost_printk(KERN_WARNING, shost, \"EEPROM checksum error\\n\");\n\t\tbreak;\n\tcase ASC_WARN_IRQ_MODIFIED:\n\t\tshost_printk(KERN_WARNING, shost, \"IRQ modified\\n\");\n\t\tbreak;\n\tcase ASC_WARN_CMD_QNG_CONFLICT:\n\t\tshost_printk(KERN_WARNING, shost, \"tag queuing enabled w/o \"\n\t\t\t\t\"disconnects\\n\");\n\t\tbreak;\n\tdefault:\n\t\tshost_printk(KERN_WARNING, shost, \"unknown warning: 0x%x\\n\",\n\t\t\t\twarn_code);\n\t\tbreak;\n\t}\n\n\tif (asc_dvc->err_code != 0)\n\t\tshost_printk(KERN_ERR, shost, \"error 0x%x at init_state \"\n\t\t\t\"0x%x\\n\", asc_dvc->err_code, asc_dvc->init_state);\n\n\treturn asc_dvc->err_code;\n}\n\nstatic int AscInitSetConfig(struct pci_dev *pdev, struct Scsi_Host *shost)\n{\n\tstruct asc_board *board = shost_priv(shost);\n\tASC_DVC_VAR *asc_dvc = &board->dvc_var.asc_dvc_var;\n\tPortAddr iop_base = asc_dvc->iop_base;\n\tunsigned short cfg_msw;\n\tunsigned short warn_code = 0;\n\n\tasc_dvc->init_state |= ASC_INIT_STATE_BEG_SET_CFG;\n\tif (asc_dvc->err_code != 0)\n\t\treturn asc_dvc->err_code;\n\tif (!AscFindSignature(asc_dvc->iop_base)) {\n\t\tasc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;\n\t\treturn asc_dvc->err_code;\n\t}\n\n\tcfg_msw = AscGetChipCfgMsw(iop_base);\n\tif ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {\n\t\tcfg_msw &= ~ASC_CFG_MSW_CLR_MASK;\n\t\twarn_code |= ASC_WARN_CFG_MSW_RECOVER;\n\t\tAscSetChipCfgMsw(iop_base, cfg_msw);\n\t}\n\tif ((asc_dvc->cfg->cmd_qng_enabled & asc_dvc->cfg->disc_enable) !=\n\t    asc_dvc->cfg->cmd_qng_enabled) {\n\t\tasc_dvc->cfg->disc_enable = asc_dvc->cfg->cmd_qng_enabled;\n\t\twarn_code |= ASC_WARN_CMD_QNG_CONFLICT;\n\t}\n\tif (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {\n\t\twarn_code |= ASC_WARN_AUTO_CONFIG;\n\t}\n#ifdef CONFIG_PCI\n\tif (asc_dvc->bus_type & ASC_IS_PCI) {\n\t\tcfg_msw &= 0xFFC0;\n\t\tAscSetChipCfgMsw(iop_base, cfg_msw);\n\t\tif ((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) {\n\t\t} else {\n\t\t\tif ((pdev->device == PCI_DEVICE_ID_ASP_1200A) ||\n\t\t\t    (pdev->device == PCI_DEVICE_ID_ASP_ABP940)) {\n\t\t\t\tasc_dvc->bug_fix_cntl |= ASC_BUG_FIX_IF_NOT_DWB;\n\t\t\t\tasc_dvc->bug_fix_cntl |=\n\t\t\t\t    ASC_BUG_FIX_ASYN_USE_SYN;\n\t\t\t}\n\t\t}\n\t} else\n#endif  \n\tif (AscSetChipScsiID(iop_base, asc_dvc->cfg->chip_scsi_id) !=\n\t    asc_dvc->cfg->chip_scsi_id) {\n\t\tasc_dvc->err_code |= ASC_IERR_SET_SCSI_ID;\n\t}\n\n\tasc_dvc->init_state |= ASC_INIT_STATE_END_SET_CFG;\n\n\tswitch (warn_code) {\n\tcase 0:\t \n\t\tbreak;\n\tcase ASC_WARN_IO_PORT_ROTATE:\n\t\tshost_printk(KERN_WARNING, shost, \"I/O port address \"\n\t\t\t\t\"modified\\n\");\n\t\tbreak;\n\tcase ASC_WARN_AUTO_CONFIG:\n\t\tshost_printk(KERN_WARNING, shost, \"I/O port increment switch \"\n\t\t\t\t\"enabled\\n\");\n\t\tbreak;\n\tcase ASC_WARN_EEPROM_CHKSUM:\n\t\tshost_printk(KERN_WARNING, shost, \"EEPROM checksum error\\n\");\n\t\tbreak;\n\tcase ASC_WARN_IRQ_MODIFIED:\n\t\tshost_printk(KERN_WARNING, shost, \"IRQ modified\\n\");\n\t\tbreak;\n\tcase ASC_WARN_CMD_QNG_CONFLICT:\n\t\tshost_printk(KERN_WARNING, shost, \"tag queuing w/o \"\n\t\t\t\t\"disconnects\\n\");\n\t\tbreak;\n\tdefault:\n\t\tshost_printk(KERN_WARNING, shost, \"unknown warning: 0x%x\\n\",\n\t\t\t\twarn_code);\n\t\tbreak;\n\t}\n\n\tif (asc_dvc->err_code != 0)\n\t\tshost_printk(KERN_ERR, shost, \"error 0x%x at init_state \"\n\t\t\t\"0x%x\\n\", asc_dvc->err_code, asc_dvc->init_state);\n\n\treturn asc_dvc->err_code;\n}\n\n \n#ifdef CONFIG_PCI\nstatic ADVEEP_3550_CONFIG Default_3550_EEPROM_Config = {\n\tADV_EEPROM_BIOS_ENABLE,\t \n\t0x0000,\t\t\t \n\t0xFFFF,\t\t\t \n\t0xFFFF,\t\t\t \n\t0xFFFF,\t\t\t \n\t0xFFFF,\t\t\t \n\t0xFFFF,\t\t\t \n\t0xFFFF,\t\t\t \n\t0,\t\t\t \n\t7,\t\t\t \n\t0,\t\t\t \n\t3,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0xFFE7,\t\t\t \n\t0xFFFF,\t\t\t \n\t0,\t\t\t \n\tASC_DEF_MAX_HOST_QNG,\t \n\tASC_DEF_MAX_DVC_QNG,\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0\t\t\t \n};\n\nstatic ADVEEP_3550_CONFIG ADVEEP_3550_Config_Field_IsChar = {\n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n\t,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0\t\t\t \n};\n\nstatic ADVEEP_38C0800_CONFIG Default_38C0800_EEPROM_Config = {\n\tADV_EEPROM_BIOS_ENABLE,\t \n\t0x0000,\t\t\t \n\t0xFFFF,\t\t\t \n\t0xFFFF,\t\t\t \n\t0x4444,\t\t\t \n\t0xFFFF,\t\t\t \n\t0xFFFF,\t\t\t \n\t0xFFFF,\t\t\t \n\t0,\t\t\t \n\t7,\t\t\t \n\t0,\t\t\t \n\t3,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0xFFE7,\t\t\t \n\t0x4444,\t\t\t \n\t0x4444,\t\t\t \n\tASC_DEF_MAX_HOST_QNG,\t \n\tASC_DEF_MAX_DVC_QNG,\t \n\t0,\t\t\t \n\t0x4444,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\tPCI_VENDOR_ID_ASP,\t \n\tPCI_DEVICE_ID_38C0800_REV1,\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0\t\t\t \n};\n\nstatic ADVEEP_38C0800_CONFIG ADVEEP_38C0800_Config_Field_IsChar = {\n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n\t,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0\t\t\t \n};\n\nstatic ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config = {\n\tADV_EEPROM_BIOS_ENABLE,\t \n\t0x0000,\t\t\t \n\t0xFFFF,\t\t\t \n\t0xFFFF,\t\t\t \n\t0x5555,\t\t\t \n\t0xFFFF,\t\t\t \n\t0xFFFF,\t\t\t \n\t0xFFFF,\t\t\t \n\t0,\t\t\t \n\t7,\t\t\t \n\t0,\t\t\t \n\t3,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0xFFE7,\t\t\t \n\t0x5555,\t\t\t \n\t0x5555,\t\t\t \n\tASC_DEF_MAX_HOST_QNG,\t \n\tASC_DEF_MAX_DVC_QNG,\t \n\t0,\t\t\t \n\t0x5555,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\tPCI_VENDOR_ID_ASP,\t \n\tPCI_DEVICE_ID_38C1600_REV1,\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0\t\t\t \n};\n\nstatic ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar = {\n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t1,\t\t\t \n\t1,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n\t,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0,\t\t\t \n\t0\t\t\t \n};\n\n \nstatic void AdvWaitEEPCmd(AdvPortAddr iop_base)\n{\n\tint eep_delay_ms;\n\n\tfor (eep_delay_ms = 0; eep_delay_ms < ADV_EEP_DELAY_MS; eep_delay_ms++) {\n\t\tif (AdvReadWordRegister(iop_base, IOPW_EE_CMD) &\n\t\t    ASC_EEP_CMD_DONE) {\n\t\t\tbreak;\n\t\t}\n\t\tmdelay(1);\n\t}\n\tif ((AdvReadWordRegister(iop_base, IOPW_EE_CMD) & ASC_EEP_CMD_DONE) ==\n\t    0)\n\t\tBUG();\n}\n\n \nstatic ushort AdvReadEEPWord(AdvPortAddr iop_base, int eep_word_addr)\n{\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\n\t\t\t     ASC_EEP_CMD_READ | eep_word_addr);\n\tAdvWaitEEPCmd(iop_base);\n\treturn AdvReadWordRegister(iop_base, IOPW_EE_DATA);\n}\n\n \nstatic void AdvSet3550EEPConfig(AdvPortAddr iop_base,\n\t\t\t\tADVEEP_3550_CONFIG *cfg_buf)\n{\n\tushort *wbuf;\n\tushort addr, chksum;\n\tushort *charfields;\n\n\twbuf = (ushort *)cfg_buf;\n\tcharfields = (ushort *)&ADVEEP_3550_Config_Field_IsChar;\n\tchksum = 0;\n\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\n\tAdvWaitEEPCmd(iop_base);\n\n\t \n\tfor (addr = ADV_EEP_DVC_CFG_BEGIN;\n\t     addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {\n\t\tushort word;\n\n\t\tif (*charfields++) {\n\t\t\tword = cpu_to_le16(*wbuf);\n\t\t} else {\n\t\t\tword = *wbuf;\n\t\t}\n\t\tchksum += *wbuf;\t \n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\n\t\t\t\t     ASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iop_base);\n\t\tmdelay(ADV_EEP_DELAY_MS);\n\t}\n\n\t \n\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);\n\tAdvWaitEEPCmd(iop_base);\n\twbuf++;\n\tcharfields++;\n\n\t \n\tfor (addr = ADV_EEP_DVC_CTL_BEGIN;\n\t     addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\n\t\tushort word;\n\n\t\tif (*charfields++) {\n\t\t\tword = cpu_to_le16(*wbuf);\n\t\t} else {\n\t\t\tword = *wbuf;\n\t\t}\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\n\t\t\t\t     ASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iop_base);\n\t}\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);\n\tAdvWaitEEPCmd(iop_base);\n}\n\n \nstatic void AdvSet38C0800EEPConfig(AdvPortAddr iop_base,\n\t\t\t\t   ADVEEP_38C0800_CONFIG *cfg_buf)\n{\n\tushort *wbuf;\n\tushort *charfields;\n\tushort addr, chksum;\n\n\twbuf = (ushort *)cfg_buf;\n\tcharfields = (ushort *)&ADVEEP_38C0800_Config_Field_IsChar;\n\tchksum = 0;\n\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\n\tAdvWaitEEPCmd(iop_base);\n\n\t \n\tfor (addr = ADV_EEP_DVC_CFG_BEGIN;\n\t     addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {\n\t\tushort word;\n\n\t\tif (*charfields++) {\n\t\t\tword = cpu_to_le16(*wbuf);\n\t\t} else {\n\t\t\tword = *wbuf;\n\t\t}\n\t\tchksum += *wbuf;\t \n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\n\t\t\t\t     ASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iop_base);\n\t\tmdelay(ADV_EEP_DELAY_MS);\n\t}\n\n\t \n\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);\n\tAdvWaitEEPCmd(iop_base);\n\twbuf++;\n\tcharfields++;\n\n\t \n\tfor (addr = ADV_EEP_DVC_CTL_BEGIN;\n\t     addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\n\t\tushort word;\n\n\t\tif (*charfields++) {\n\t\t\tword = cpu_to_le16(*wbuf);\n\t\t} else {\n\t\t\tword = *wbuf;\n\t\t}\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\n\t\t\t\t     ASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iop_base);\n\t}\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);\n\tAdvWaitEEPCmd(iop_base);\n}\n\n \nstatic void AdvSet38C1600EEPConfig(AdvPortAddr iop_base,\n\t\t\t\t   ADVEEP_38C1600_CONFIG *cfg_buf)\n{\n\tushort *wbuf;\n\tushort *charfields;\n\tushort addr, chksum;\n\n\twbuf = (ushort *)cfg_buf;\n\tcharfields = (ushort *)&ADVEEP_38C1600_Config_Field_IsChar;\n\tchksum = 0;\n\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\n\tAdvWaitEEPCmd(iop_base);\n\n\t \n\tfor (addr = ADV_EEP_DVC_CFG_BEGIN;\n\t     addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {\n\t\tushort word;\n\n\t\tif (*charfields++) {\n\t\t\tword = cpu_to_le16(*wbuf);\n\t\t} else {\n\t\t\tword = *wbuf;\n\t\t}\n\t\tchksum += *wbuf;\t \n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\n\t\t\t\t     ASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iop_base);\n\t\tmdelay(ADV_EEP_DELAY_MS);\n\t}\n\n\t \n\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);\n\tAdvWaitEEPCmd(iop_base);\n\twbuf++;\n\tcharfields++;\n\n\t \n\tfor (addr = ADV_EEP_DVC_CTL_BEGIN;\n\t     addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\n\t\tushort word;\n\n\t\tif (*charfields++) {\n\t\t\tword = cpu_to_le16(*wbuf);\n\t\t} else {\n\t\t\tword = *wbuf;\n\t\t}\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\n\t\t\t\t     ASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iop_base);\n\t}\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);\n\tAdvWaitEEPCmd(iop_base);\n}\n\n \nstatic ushort AdvGet3550EEPConfig(AdvPortAddr iop_base,\n\t\t\t\t  ADVEEP_3550_CONFIG *cfg_buf)\n{\n\tushort wval, chksum;\n\tushort *wbuf;\n\tint eep_addr;\n\tushort *charfields;\n\n\tcharfields = (ushort *)&ADVEEP_3550_Config_Field_IsChar;\n\twbuf = (ushort *)cfg_buf;\n\tchksum = 0;\n\n\tfor (eep_addr = ADV_EEP_DVC_CFG_BEGIN;\n\t     eep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {\n\t\twval = AdvReadEEPWord(iop_base, eep_addr);\n\t\tchksum += wval;\t \n\t\tif (*charfields++) {\n\t\t\t*wbuf = le16_to_cpu(wval);\n\t\t} else {\n\t\t\t*wbuf = wval;\n\t\t}\n\t}\n\t \n\t*wbuf = AdvReadEEPWord(iop_base, eep_addr);\n\twbuf++;\n\tcharfields++;\n\n\t \n\tfor (eep_addr = ADV_EEP_DVC_CTL_BEGIN;\n\t     eep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {\n\t\t*wbuf = AdvReadEEPWord(iop_base, eep_addr);\n\t\tif (*charfields++) {\n\t\t\t*wbuf = le16_to_cpu(*wbuf);\n\t\t}\n\t}\n\treturn chksum;\n}\n\n \nstatic ushort AdvGet38C0800EEPConfig(AdvPortAddr iop_base,\n\t\t\t\t     ADVEEP_38C0800_CONFIG *cfg_buf)\n{\n\tushort wval, chksum;\n\tushort *wbuf;\n\tint eep_addr;\n\tushort *charfields;\n\n\tcharfields = (ushort *)&ADVEEP_38C0800_Config_Field_IsChar;\n\twbuf = (ushort *)cfg_buf;\n\tchksum = 0;\n\n\tfor (eep_addr = ADV_EEP_DVC_CFG_BEGIN;\n\t     eep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {\n\t\twval = AdvReadEEPWord(iop_base, eep_addr);\n\t\tchksum += wval;\t \n\t\tif (*charfields++) {\n\t\t\t*wbuf = le16_to_cpu(wval);\n\t\t} else {\n\t\t\t*wbuf = wval;\n\t\t}\n\t}\n\t \n\t*wbuf = AdvReadEEPWord(iop_base, eep_addr);\n\twbuf++;\n\tcharfields++;\n\n\t \n\tfor (eep_addr = ADV_EEP_DVC_CTL_BEGIN;\n\t     eep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {\n\t\t*wbuf = AdvReadEEPWord(iop_base, eep_addr);\n\t\tif (*charfields++) {\n\t\t\t*wbuf = le16_to_cpu(*wbuf);\n\t\t}\n\t}\n\treturn chksum;\n}\n\n \nstatic ushort AdvGet38C1600EEPConfig(AdvPortAddr iop_base,\n\t\t\t\t     ADVEEP_38C1600_CONFIG *cfg_buf)\n{\n\tushort wval, chksum;\n\tushort *wbuf;\n\tint eep_addr;\n\tushort *charfields;\n\n\tcharfields = (ushort *)&ADVEEP_38C1600_Config_Field_IsChar;\n\twbuf = (ushort *)cfg_buf;\n\tchksum = 0;\n\n\tfor (eep_addr = ADV_EEP_DVC_CFG_BEGIN;\n\t     eep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {\n\t\twval = AdvReadEEPWord(iop_base, eep_addr);\n\t\tchksum += wval;\t \n\t\tif (*charfields++) {\n\t\t\t*wbuf = le16_to_cpu(wval);\n\t\t} else {\n\t\t\t*wbuf = wval;\n\t\t}\n\t}\n\t \n\t*wbuf = AdvReadEEPWord(iop_base, eep_addr);\n\twbuf++;\n\tcharfields++;\n\n\t \n\tfor (eep_addr = ADV_EEP_DVC_CTL_BEGIN;\n\t     eep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {\n\t\t*wbuf = AdvReadEEPWord(iop_base, eep_addr);\n\t\tif (*charfields++) {\n\t\t\t*wbuf = le16_to_cpu(*wbuf);\n\t\t}\n\t}\n\treturn chksum;\n}\n\n \nstatic int AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)\n{\n\tAdvPortAddr iop_base;\n\tushort warn_code;\n\tADVEEP_3550_CONFIG eep_config;\n\n\tiop_base = asc_dvc->iop_base;\n\n\twarn_code = 0;\n\n\t \n\tif (AdvGet3550EEPConfig(iop_base, &eep_config) != eep_config.check_sum) {\n\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\n\t\t \n\t\tmemcpy(&eep_config, &Default_3550_EEPROM_Config,\n\t\t\tsizeof(ADVEEP_3550_CONFIG));\n\n\t\t \n\t\teep_config.serial_number_word3 =\n\t\t    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);\n\n\t\teep_config.serial_number_word2 =\n\t\t    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);\n\n\t\teep_config.serial_number_word1 =\n\t\t    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);\n\n\t\tAdvSet3550EEPConfig(iop_base, &eep_config);\n\t}\n\t \n\tasc_dvc->wdtr_able = eep_config.wdtr_able;\n\tasc_dvc->sdtr_able = eep_config.sdtr_able;\n\tasc_dvc->ultra_able = eep_config.ultra_able;\n\tasc_dvc->tagqng_able = eep_config.tagqng_able;\n\tasc_dvc->cfg->disc_enable = eep_config.disc_enable;\n\tasc_dvc->max_host_qng = eep_config.max_host_qng;\n\tasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\n\tasc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);\n\tasc_dvc->start_motor = eep_config.start_motor;\n\tasc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;\n\tasc_dvc->bios_ctrl = eep_config.bios_ctrl;\n\tasc_dvc->no_scam = eep_config.scam_tolerant;\n\tasc_dvc->cfg->serial1 = eep_config.serial_number_word1;\n\tasc_dvc->cfg->serial2 = eep_config.serial_number_word2;\n\tasc_dvc->cfg->serial3 = eep_config.serial_number_word3;\n\n\t \n\tif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\n\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {\n\t\t \n\t\tif (eep_config.max_host_qng == 0) {\n\t\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t\t} else {\n\t\t\teep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\n\t\t}\n\t}\n\n\tif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\n\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\n\t\t \n\t\tif (eep_config.max_dvc_qng == 0) {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t\t} else {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\n\t\t}\n\t}\n\n\t \n\tif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\n\t\teep_config.max_dvc_qng = eep_config.max_host_qng;\n\t}\n\n\t \n\tasc_dvc->max_host_qng = eep_config.max_host_qng;\n\tasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\n\n\t \n\tif (eep_config.termination == 0) {\n\t\tasc_dvc->cfg->termination = 0;\t \n\t} else {\n\t\t \n\t\tif (eep_config.termination == 1) {\n\t\t\tasc_dvc->cfg->termination = TERM_CTL_SEL;\n\n\t\t\t \n\t\t} else if (eep_config.termination == 2) {\n\t\t\tasc_dvc->cfg->termination = TERM_CTL_SEL | TERM_CTL_H;\n\n\t\t\t \n\t\t} else if (eep_config.termination == 3) {\n\t\t\tasc_dvc->cfg->termination =\n\t\t\t    TERM_CTL_SEL | TERM_CTL_H | TERM_CTL_L;\n\t\t} else {\n\t\t\t \n\t\t\tasc_dvc->cfg->termination = 0;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\treturn warn_code;\n}\n\n \nstatic int AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)\n{\n\tAdvPortAddr iop_base;\n\tushort warn_code;\n\tADVEEP_38C0800_CONFIG eep_config;\n\tuchar tid, termination;\n\tushort sdtr_speed = 0;\n\n\tiop_base = asc_dvc->iop_base;\n\n\twarn_code = 0;\n\n\t \n\tif (AdvGet38C0800EEPConfig(iop_base, &eep_config) !=\n\t    eep_config.check_sum) {\n\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\n\t\t \n\t\tmemcpy(&eep_config, &Default_38C0800_EEPROM_Config,\n\t\t\tsizeof(ADVEEP_38C0800_CONFIG));\n\n\t\t \n\t\teep_config.serial_number_word3 =\n\t\t    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);\n\n\t\teep_config.serial_number_word2 =\n\t\t    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);\n\n\t\teep_config.serial_number_word1 =\n\t\t    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);\n\n\t\tAdvSet38C0800EEPConfig(iop_base, &eep_config);\n\t}\n\t \n\tasc_dvc->wdtr_able = eep_config.wdtr_able;\n\tasc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;\n\tasc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;\n\tasc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;\n\tasc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;\n\tasc_dvc->tagqng_able = eep_config.tagqng_able;\n\tasc_dvc->cfg->disc_enable = eep_config.disc_enable;\n\tasc_dvc->max_host_qng = eep_config.max_host_qng;\n\tasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\n\tasc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);\n\tasc_dvc->start_motor = eep_config.start_motor;\n\tasc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;\n\tasc_dvc->bios_ctrl = eep_config.bios_ctrl;\n\tasc_dvc->no_scam = eep_config.scam_tolerant;\n\tasc_dvc->cfg->serial1 = eep_config.serial_number_word1;\n\tasc_dvc->cfg->serial2 = eep_config.serial_number_word2;\n\tasc_dvc->cfg->serial3 = eep_config.serial_number_word3;\n\n\t \n\tasc_dvc->sdtr_able = 0;\n\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\tif (tid == 0) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed1;\n\t\t} else if (tid == 4) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed2;\n\t\t} else if (tid == 8) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed3;\n\t\t} else if (tid == 12) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed4;\n\t\t}\n\t\tif (sdtr_speed & ADV_MAX_TID) {\n\t\t\tasc_dvc->sdtr_able |= (1 << tid);\n\t\t}\n\t\tsdtr_speed >>= 4;\n\t}\n\n\t \n\tif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\n\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {\n\t\t \n\t\tif (eep_config.max_host_qng == 0) {\n\t\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t\t} else {\n\t\t\teep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\n\t\t}\n\t}\n\n\tif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\n\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\n\t\t \n\t\tif (eep_config.max_dvc_qng == 0) {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t\t} else {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\n\t\t}\n\t}\n\n\t \n\tif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\n\t\teep_config.max_dvc_qng = eep_config.max_host_qng;\n\t}\n\n\t \n\tasc_dvc->max_host_qng = eep_config.max_host_qng;\n\tasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\n\n\t \n\tif (eep_config.termination_se == 0) {\n\t\ttermination = 0;\t \n\t} else {\n\t\t \n\t\tif (eep_config.termination_se == 1) {\n\t\t\ttermination = 0;\n\n\t\t\t \n\t\t} else if (eep_config.termination_se == 2) {\n\t\t\ttermination = TERM_SE_HI;\n\n\t\t\t \n\t\t} else if (eep_config.termination_se == 3) {\n\t\t\ttermination = TERM_SE;\n\t\t} else {\n\t\t\t \n\t\t\ttermination = 0;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\tif (eep_config.termination_lvd == 0) {\n\t\tasc_dvc->cfg->termination = termination;\t \n\t} else {\n\t\t \n\t\tif (eep_config.termination_lvd == 1) {\n\t\t\tasc_dvc->cfg->termination = termination;\n\n\t\t\t \n\t\t} else if (eep_config.termination_lvd == 2) {\n\t\t\tasc_dvc->cfg->termination = termination | TERM_LVD_HI;\n\n\t\t\t \n\t\t} else if (eep_config.termination_lvd == 3) {\n\t\t\tasc_dvc->cfg->termination = termination | TERM_LVD;\n\t\t} else {\n\t\t\t \n\t\t\tasc_dvc->cfg->termination = termination;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\treturn warn_code;\n}\n\n \nstatic int AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)\n{\n\tAdvPortAddr iop_base;\n\tushort warn_code;\n\tADVEEP_38C1600_CONFIG eep_config;\n\tuchar tid, termination;\n\tushort sdtr_speed = 0;\n\n\tiop_base = asc_dvc->iop_base;\n\n\twarn_code = 0;\n\n\t \n\tif (AdvGet38C1600EEPConfig(iop_base, &eep_config) !=\n\t    eep_config.check_sum) {\n\t\tstruct pci_dev *pdev = adv_dvc_to_pdev(asc_dvc);\n\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\n\t\t \n\t\tmemcpy(&eep_config, &Default_38C1600_EEPROM_Config,\n\t\t\tsizeof(ADVEEP_38C1600_CONFIG));\n\n\t\tif (PCI_FUNC(pdev->devfn) != 0) {\n\t\t\tu8 ints;\n\t\t\t \n\t\t\teep_config.cfg_lsw &= ~ADV_EEPROM_BIOS_ENABLE;\n\t\t\t \n\t\t\tAdvWriteByteRegister(iop_base, IOPB_GPIO_CNTL, 0);\n\t\t\tints = AdvReadByteRegister(iop_base, IOPB_GPIO_DATA);\n\t\t\tif ((ints & 0x01) == 0)\n\t\t\t\teep_config.cfg_lsw &= ~ADV_EEPROM_INTAB;\n\t\t}\n\n\t\t \n\t\teep_config.serial_number_word3 =\n\t\t\tAdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);\n\t\teep_config.serial_number_word2 =\n\t\t\tAdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);\n\t\teep_config.serial_number_word1 =\n\t\t\tAdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);\n\n\t\tAdvSet38C1600EEPConfig(iop_base, &eep_config);\n\t}\n\n\t \n\tasc_dvc->wdtr_able = eep_config.wdtr_able;\n\tasc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;\n\tasc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;\n\tasc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;\n\tasc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;\n\tasc_dvc->ppr_able = 0;\n\tasc_dvc->tagqng_able = eep_config.tagqng_able;\n\tasc_dvc->cfg->disc_enable = eep_config.disc_enable;\n\tasc_dvc->max_host_qng = eep_config.max_host_qng;\n\tasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\n\tasc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ASC_MAX_TID);\n\tasc_dvc->start_motor = eep_config.start_motor;\n\tasc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;\n\tasc_dvc->bios_ctrl = eep_config.bios_ctrl;\n\tasc_dvc->no_scam = eep_config.scam_tolerant;\n\n\t \n\tasc_dvc->sdtr_able = 0;\n\tfor (tid = 0; tid <= ASC_MAX_TID; tid++) {\n\t\tif (tid == 0) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed1;\n\t\t} else if (tid == 4) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed2;\n\t\t} else if (tid == 8) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed3;\n\t\t} else if (tid == 12) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed4;\n\t\t}\n\t\tif (sdtr_speed & ASC_MAX_TID) {\n\t\t\tasc_dvc->sdtr_able |= (1 << tid);\n\t\t}\n\t\tsdtr_speed >>= 4;\n\t}\n\n\t \n\tif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\n\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {\n\t\t \n\t\tif (eep_config.max_host_qng == 0) {\n\t\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t\t} else {\n\t\t\teep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\n\t\t}\n\t}\n\n\tif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\n\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\n\t\t \n\t\tif (eep_config.max_dvc_qng == 0) {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t\t} else {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\n\t\t}\n\t}\n\n\t \n\tif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\n\t\teep_config.max_dvc_qng = eep_config.max_host_qng;\n\t}\n\n\t \n\tasc_dvc->max_host_qng = eep_config.max_host_qng;\n\tasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\n\n\t \n\tif (eep_config.termination_se == 0) {\n\t\ttermination = 0;\t \n\t} else {\n\t\t \n\t\tif (eep_config.termination_se == 1) {\n\t\t\ttermination = 0;\n\n\t\t\t \n\t\t} else if (eep_config.termination_se == 2) {\n\t\t\ttermination = TERM_SE_HI;\n\n\t\t\t \n\t\t} else if (eep_config.termination_se == 3) {\n\t\t\ttermination = TERM_SE;\n\t\t} else {\n\t\t\t \n\t\t\ttermination = 0;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\tif (eep_config.termination_lvd == 0) {\n\t\tasc_dvc->cfg->termination = termination;\t \n\t} else {\n\t\t \n\t\tif (eep_config.termination_lvd == 1) {\n\t\t\tasc_dvc->cfg->termination = termination;\n\n\t\t\t \n\t\t} else if (eep_config.termination_lvd == 2) {\n\t\t\tasc_dvc->cfg->termination = termination | TERM_LVD_HI;\n\n\t\t\t \n\t\t} else if (eep_config.termination_lvd == 3) {\n\t\t\tasc_dvc->cfg->termination = termination | TERM_LVD;\n\t\t} else {\n\t\t\t \n\t\t\tasc_dvc->cfg->termination = termination;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\treturn warn_code;\n}\n\n \nstatic int AdvInitGetConfig(struct pci_dev *pdev, struct Scsi_Host *shost)\n{\n\tstruct asc_board *board = shost_priv(shost);\n\tADV_DVC_VAR *asc_dvc = &board->dvc_var.adv_dvc_var;\n\tunsigned short warn_code = 0;\n\tAdvPortAddr iop_base = asc_dvc->iop_base;\n\tu16 cmd;\n\tint status;\n\n\tasc_dvc->err_code = 0;\n\n\t \n\tasc_dvc->cfg->control_flag = 0;\n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\tif ((cmd & PCI_COMMAND_PARITY) == 0)\n\t\tasc_dvc->cfg->control_flag |= CONTROL_FLAG_IGNORE_PERR;\n\n\tasc_dvc->cfg->chip_version =\n\t    AdvGetChipVersion(iop_base, asc_dvc->bus_type);\n\n\tASC_DBG(1, \"iopb_chip_id_1: 0x%x 0x%x\\n\",\n\t\t (ushort)AdvReadByteRegister(iop_base, IOPB_CHIP_ID_1),\n\t\t (ushort)ADV_CHIP_ID_BYTE);\n\n\tASC_DBG(1, \"iopw_chip_id_0: 0x%x 0x%x\\n\",\n\t\t (ushort)AdvReadWordRegister(iop_base, IOPW_CHIP_ID_0),\n\t\t (ushort)ADV_CHIP_ID_WORD);\n\n\t \n\tif (AdvFindSignature(iop_base) == 0) {\n\t\tasc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;\n\t\treturn ADV_ERROR;\n\t} else {\n\t\t \n\t\tif (asc_dvc->chip_type != ADV_CHIP_ASC3550 &&\n\t\t    asc_dvc->chip_type != ADV_CHIP_ASC38C0800 &&\n\t\t    asc_dvc->chip_type != ADV_CHIP_ASC38C1600) {\n\t\t\tasc_dvc->err_code |= ASC_IERR_BAD_CHIPTYPE;\n\t\t\treturn ADV_ERROR;\n\t\t}\n\n\t\t \n\t\tAdvWriteWordRegister(iop_base, IOPW_CTRL_REG,\n\t\t\t\t     ADV_CTRL_REG_CMD_RESET);\n\t\tmdelay(100);\n\t\tAdvWriteWordRegister(iop_base, IOPW_CTRL_REG,\n\t\t\t\t     ADV_CTRL_REG_CMD_WR_IO_REG);\n\n\t\tif (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {\n\t\t\tstatus = AdvInitFrom38C1600EEP(asc_dvc);\n\t\t} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\t\tstatus = AdvInitFrom38C0800EEP(asc_dvc);\n\t\t} else {\n\t\t\tstatus = AdvInitFrom3550EEP(asc_dvc);\n\t\t}\n\t\twarn_code |= status;\n\t}\n\n\tif (warn_code != 0)\n\t\tshost_printk(KERN_WARNING, shost, \"warning: 0x%x\\n\", warn_code);\n\n\tif (asc_dvc->err_code)\n\t\tshost_printk(KERN_ERR, shost, \"error code 0x%x\\n\",\n\t\t\t\tasc_dvc->err_code);\n\n\treturn asc_dvc->err_code;\n}\n#endif\n\nstatic const struct scsi_host_template advansys_template = {\n\t.proc_name = DRV_NAME,\n#ifdef CONFIG_PROC_FS\n\t.show_info = advansys_show_info,\n#endif\n\t.name = DRV_NAME,\n\t.info = advansys_info,\n\t.queuecommand = advansys_queuecommand,\n\t.eh_host_reset_handler = advansys_reset,\n\t.bios_param = advansys_biosparam,\n\t.slave_configure = advansys_slave_configure,\n\t.cmd_size = sizeof(struct advansys_cmd),\n};\n\nstatic int advansys_wide_init_chip(struct Scsi_Host *shost)\n{\n\tstruct asc_board *board = shost_priv(shost);\n\tstruct adv_dvc_var *adv_dvc = &board->dvc_var.adv_dvc_var;\n\tsize_t sgblk_pool_size;\n\tint warn_code, err_code;\n\n\t \n\tadv_dvc->carrier = dma_alloc_coherent(board->dev,\n\t\tADV_CARRIER_BUFSIZE, &adv_dvc->carrier_addr, GFP_KERNEL);\n\tASC_DBG(1, \"carrier 0x%p\\n\", adv_dvc->carrier);\n\n\tif (!adv_dvc->carrier)\n\t\tgoto kmalloc_failed;\n\n\t \n\tboard->adv_reqp_size = adv_dvc->max_host_qng * sizeof(adv_req_t);\n\tif (board->adv_reqp_size & 0x1f) {\n\t\tASC_DBG(1, \"unaligned reqp %lu bytes\\n\", sizeof(adv_req_t));\n\t\tboard->adv_reqp_size = ADV_32BALIGN(board->adv_reqp_size);\n\t}\n\tboard->adv_reqp = dma_alloc_coherent(board->dev, board->adv_reqp_size,\n\t\t&board->adv_reqp_addr, GFP_KERNEL);\n\n\tif (!board->adv_reqp)\n\t\tgoto kmalloc_failed;\n\n\tASC_DBG(1, \"reqp 0x%p, req_cnt %d, bytes %lu\\n\", board->adv_reqp,\n\t\tadv_dvc->max_host_qng, board->adv_reqp_size);\n\n\t \n\tsgblk_pool_size = sizeof(adv_sgblk_t) * ADV_TOT_SG_BLOCK;\n\tboard->adv_sgblk_pool = dma_pool_create(\"adv_sgblk\", board->dev,\n\t\t\t\t\t\tsgblk_pool_size, 32, 0);\n\n\tASC_DBG(1, \"sg_cnt %d * %lu = %lu bytes\\n\", ADV_TOT_SG_BLOCK,\n\t\tsizeof(adv_sgblk_t), sgblk_pool_size);\n\n\tif (!board->adv_sgblk_pool)\n\t\tgoto kmalloc_failed;\n\n\tif (adv_dvc->chip_type == ADV_CHIP_ASC3550) {\n\t\tASC_DBG(2, \"AdvInitAsc3550Driver()\\n\");\n\t\twarn_code = AdvInitAsc3550Driver(adv_dvc);\n\t} else if (adv_dvc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tASC_DBG(2, \"AdvInitAsc38C0800Driver()\\n\");\n\t\twarn_code = AdvInitAsc38C0800Driver(adv_dvc);\n\t} else {\n\t\tASC_DBG(2, \"AdvInitAsc38C1600Driver()\\n\");\n\t\twarn_code = AdvInitAsc38C1600Driver(adv_dvc);\n\t}\n\terr_code = adv_dvc->err_code;\n\n\tif (warn_code || err_code) {\n\t\tshost_printk(KERN_WARNING, shost, \"error: warn 0x%x, error \"\n\t\t\t\"0x%x\\n\", warn_code, err_code);\n\t}\n\n\tgoto exit;\n\n kmalloc_failed:\n\tshost_printk(KERN_ERR, shost, \"error: kmalloc() failed\\n\");\n\terr_code = ADV_ERROR;\n exit:\n\treturn err_code;\n}\n\nstatic void advansys_wide_free_mem(struct asc_board *board)\n{\n\tstruct adv_dvc_var *adv_dvc = &board->dvc_var.adv_dvc_var;\n\n\tif (adv_dvc->carrier) {\n\t\tdma_free_coherent(board->dev, ADV_CARRIER_BUFSIZE,\n\t\t\t\t  adv_dvc->carrier, adv_dvc->carrier_addr);\n\t\tadv_dvc->carrier = NULL;\n\t}\n\tif (board->adv_reqp) {\n\t\tdma_free_coherent(board->dev, board->adv_reqp_size,\n\t\t\t\t  board->adv_reqp, board->adv_reqp_addr);\n\t\tboard->adv_reqp = NULL;\n\t}\n\tif (board->adv_sgblk_pool) {\n\t\tdma_pool_destroy(board->adv_sgblk_pool);\n\t\tboard->adv_sgblk_pool = NULL;\n\t}\n}\n\nstatic int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,\n\t\t\t\tint bus_type)\n{\n\tstruct pci_dev *pdev;\n\tstruct asc_board *boardp = shost_priv(shost);\n\tASC_DVC_VAR *asc_dvc_varp = NULL;\n\tADV_DVC_VAR *adv_dvc_varp = NULL;\n\tint share_irq, warn_code, ret;\n\n\tpdev = (bus_type == ASC_IS_PCI) ? to_pci_dev(boardp->dev) : NULL;\n\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tASC_DBG(1, \"narrow board\\n\");\n\t\tasc_dvc_varp = &boardp->dvc_var.asc_dvc_var;\n\t\tasc_dvc_varp->bus_type = bus_type;\n\t\tasc_dvc_varp->drv_ptr = boardp;\n\t\tasc_dvc_varp->cfg = &boardp->dvc_cfg.asc_dvc_cfg;\n\t\tasc_dvc_varp->iop_base = iop;\n\t} else {\n#ifdef CONFIG_PCI\n\t\tadv_dvc_varp = &boardp->dvc_var.adv_dvc_var;\n\t\tadv_dvc_varp->drv_ptr = boardp;\n\t\tadv_dvc_varp->cfg = &boardp->dvc_cfg.adv_dvc_cfg;\n\t\tif (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW) {\n\t\t\tASC_DBG(1, \"wide board ASC-3550\\n\");\n\t\t\tadv_dvc_varp->chip_type = ADV_CHIP_ASC3550;\n\t\t} else if (pdev->device == PCI_DEVICE_ID_38C0800_REV1) {\n\t\t\tASC_DBG(1, \"wide board ASC-38C0800\\n\");\n\t\t\tadv_dvc_varp->chip_type = ADV_CHIP_ASC38C0800;\n\t\t} else {\n\t\t\tASC_DBG(1, \"wide board ASC-38C1600\\n\");\n\t\t\tadv_dvc_varp->chip_type = ADV_CHIP_ASC38C1600;\n\t\t}\n\n\t\tboardp->asc_n_io_port = pci_resource_len(pdev, 1);\n\t\tboardp->ioremap_addr = pci_ioremap_bar(pdev, 1);\n\t\tif (!boardp->ioremap_addr) {\n\t\t\tshost_printk(KERN_ERR, shost, \"ioremap(%lx, %d) \"\n\t\t\t\t\t\"returned NULL\\n\",\n\t\t\t\t\t(long)pci_resource_start(pdev, 1),\n\t\t\t\t\tboardp->asc_n_io_port);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_shost;\n\t\t}\n\t\tadv_dvc_varp->iop_base = (AdvPortAddr)boardp->ioremap_addr;\n\t\tASC_DBG(1, \"iop_base: 0x%p\\n\", adv_dvc_varp->iop_base);\n\n\t\t \n\t\tboardp->ioport = iop;\n\n\t\tASC_DBG(1, \"iopb_chip_id_1 0x%x, iopw_chip_id_0 0x%x\\n\",\n\t\t\t\t(ushort)inp(iop + 1), (ushort)inpw(iop));\n#endif  \n\t}\n\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\t \n\t\tswitch (asc_dvc_varp->bus_type) {\n#ifdef CONFIG_ISA\n\t\tcase ASC_IS_VL:\n\t\t\tshare_irq = 0;\n\t\t\tbreak;\n\t\tcase ASC_IS_EISA:\n\t\t\tshare_irq = IRQF_SHARED;\n\t\t\tbreak;\n#endif  \n#ifdef CONFIG_PCI\n\t\tcase ASC_IS_PCI:\n\t\t\tshare_irq = IRQF_SHARED;\n\t\t\tbreak;\n#endif  \n\t\tdefault:\n\t\t\tshost_printk(KERN_ERR, shost, \"unknown adapter type: \"\n\t\t\t\t\t\"%d\\n\", asc_dvc_varp->bus_type);\n\t\t\tshare_irq = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tASC_DBG(2, \"AscInitGetConfig()\\n\");\n\t\tret = AscInitGetConfig(shost) ? -ENODEV : 0;\n\t} else {\n#ifdef CONFIG_PCI\n\t\t \n\t\tshare_irq = IRQF_SHARED;\n\t\tASC_DBG(2, \"AdvInitGetConfig()\\n\");\n\n\t\tret = AdvInitGetConfig(pdev, shost) ? -ENODEV : 0;\n#else\n\t\tshare_irq = 0;\n\t\tret = -ENODEV;\n#endif  \n\t}\n\n\tif (ret)\n\t\tgoto err_unmap;\n\n\t \n\tif (ASC_NARROW_BOARD(boardp)) {\n\n\t\tASCEEP_CONFIG *ep;\n\n\t\t \n\t\tboardp->init_tidmask |=\n\t\t    ADV_TID_TO_TIDMASK(asc_dvc_varp->cfg->chip_scsi_id);\n\n\t\t \n\t\tep = &boardp->eep_config.asc_eep;\n\n\t\tep->init_sdtr = asc_dvc_varp->cfg->sdtr_enable;\n\t\tep->disc_enable = asc_dvc_varp->cfg->disc_enable;\n\t\tep->use_cmd_qng = asc_dvc_varp->cfg->cmd_qng_enabled;\n\t\tASC_EEP_SET_DMA_SPD(ep, ASC_DEF_ISA_DMA_SPEED);\n\t\tep->start_motor = asc_dvc_varp->start_motor;\n\t\tep->cntl = asc_dvc_varp->dvc_cntl;\n\t\tep->no_scam = asc_dvc_varp->no_scam;\n\t\tep->max_total_qng = asc_dvc_varp->max_total_qng;\n\t\tASC_EEP_SET_CHIP_ID(ep, asc_dvc_varp->cfg->chip_scsi_id);\n\t\t \n\t\tep->max_tag_qng = asc_dvc_varp->cfg->max_tag_qng[0];\n\t\tep->adapter_info[0] = asc_dvc_varp->cfg->adapter_info[0];\n\t\tep->adapter_info[1] = asc_dvc_varp->cfg->adapter_info[1];\n\t\tep->adapter_info[2] = asc_dvc_varp->cfg->adapter_info[2];\n\t\tep->adapter_info[3] = asc_dvc_varp->cfg->adapter_info[3];\n\t\tep->adapter_info[4] = asc_dvc_varp->cfg->adapter_info[4];\n\t\tep->adapter_info[5] = asc_dvc_varp->cfg->adapter_info[5];\n\n\t\t \n\t\tASC_DBG(2, \"AscInitSetConfig()\\n\");\n\t\tret = AscInitSetConfig(pdev, shost) ? -ENODEV : 0;\n\t\tif (ret)\n\t\t\tgoto err_unmap;\n\t} else {\n\t\tADVEEP_3550_CONFIG *ep_3550;\n\t\tADVEEP_38C0800_CONFIG *ep_38C0800;\n\t\tADVEEP_38C1600_CONFIG *ep_38C1600;\n\n\t\t \n\t\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\t\tep_3550 = &boardp->eep_config.adv_3550_eep;\n\n\t\t\tep_3550->adapter_scsi_id = adv_dvc_varp->chip_scsi_id;\n\t\t\tep_3550->max_host_qng = adv_dvc_varp->max_host_qng;\n\t\t\tep_3550->max_dvc_qng = adv_dvc_varp->max_dvc_qng;\n\t\t\tep_3550->termination = adv_dvc_varp->cfg->termination;\n\t\t\tep_3550->disc_enable = adv_dvc_varp->cfg->disc_enable;\n\t\t\tep_3550->bios_ctrl = adv_dvc_varp->bios_ctrl;\n\t\t\tep_3550->wdtr_able = adv_dvc_varp->wdtr_able;\n\t\t\tep_3550->sdtr_able = adv_dvc_varp->sdtr_able;\n\t\t\tep_3550->ultra_able = adv_dvc_varp->ultra_able;\n\t\t\tep_3550->tagqng_able = adv_dvc_varp->tagqng_able;\n\t\t\tep_3550->start_motor = adv_dvc_varp->start_motor;\n\t\t\tep_3550->scsi_reset_delay =\n\t\t\t    adv_dvc_varp->scsi_reset_wait;\n\t\t\tep_3550->serial_number_word1 =\n\t\t\t    adv_dvc_varp->cfg->serial1;\n\t\t\tep_3550->serial_number_word2 =\n\t\t\t    adv_dvc_varp->cfg->serial2;\n\t\t\tep_3550->serial_number_word3 =\n\t\t\t    adv_dvc_varp->cfg->serial3;\n\t\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\t\tep_38C0800 = &boardp->eep_config.adv_38C0800_eep;\n\n\t\t\tep_38C0800->adapter_scsi_id =\n\t\t\t    adv_dvc_varp->chip_scsi_id;\n\t\t\tep_38C0800->max_host_qng = adv_dvc_varp->max_host_qng;\n\t\t\tep_38C0800->max_dvc_qng = adv_dvc_varp->max_dvc_qng;\n\t\t\tep_38C0800->termination_lvd =\n\t\t\t    adv_dvc_varp->cfg->termination;\n\t\t\tep_38C0800->disc_enable =\n\t\t\t    adv_dvc_varp->cfg->disc_enable;\n\t\t\tep_38C0800->bios_ctrl = adv_dvc_varp->bios_ctrl;\n\t\t\tep_38C0800->wdtr_able = adv_dvc_varp->wdtr_able;\n\t\t\tep_38C0800->tagqng_able = adv_dvc_varp->tagqng_able;\n\t\t\tep_38C0800->sdtr_speed1 = adv_dvc_varp->sdtr_speed1;\n\t\t\tep_38C0800->sdtr_speed2 = adv_dvc_varp->sdtr_speed2;\n\t\t\tep_38C0800->sdtr_speed3 = adv_dvc_varp->sdtr_speed3;\n\t\t\tep_38C0800->sdtr_speed4 = adv_dvc_varp->sdtr_speed4;\n\t\t\tep_38C0800->tagqng_able = adv_dvc_varp->tagqng_able;\n\t\t\tep_38C0800->start_motor = adv_dvc_varp->start_motor;\n\t\t\tep_38C0800->scsi_reset_delay =\n\t\t\t    adv_dvc_varp->scsi_reset_wait;\n\t\t\tep_38C0800->serial_number_word1 =\n\t\t\t    adv_dvc_varp->cfg->serial1;\n\t\t\tep_38C0800->serial_number_word2 =\n\t\t\t    adv_dvc_varp->cfg->serial2;\n\t\t\tep_38C0800->serial_number_word3 =\n\t\t\t    adv_dvc_varp->cfg->serial3;\n\t\t} else {\n\t\t\tep_38C1600 = &boardp->eep_config.adv_38C1600_eep;\n\n\t\t\tep_38C1600->adapter_scsi_id =\n\t\t\t    adv_dvc_varp->chip_scsi_id;\n\t\t\tep_38C1600->max_host_qng = adv_dvc_varp->max_host_qng;\n\t\t\tep_38C1600->max_dvc_qng = adv_dvc_varp->max_dvc_qng;\n\t\t\tep_38C1600->termination_lvd =\n\t\t\t    adv_dvc_varp->cfg->termination;\n\t\t\tep_38C1600->disc_enable =\n\t\t\t    adv_dvc_varp->cfg->disc_enable;\n\t\t\tep_38C1600->bios_ctrl = adv_dvc_varp->bios_ctrl;\n\t\t\tep_38C1600->wdtr_able = adv_dvc_varp->wdtr_able;\n\t\t\tep_38C1600->tagqng_able = adv_dvc_varp->tagqng_able;\n\t\t\tep_38C1600->sdtr_speed1 = adv_dvc_varp->sdtr_speed1;\n\t\t\tep_38C1600->sdtr_speed2 = adv_dvc_varp->sdtr_speed2;\n\t\t\tep_38C1600->sdtr_speed3 = adv_dvc_varp->sdtr_speed3;\n\t\t\tep_38C1600->sdtr_speed4 = adv_dvc_varp->sdtr_speed4;\n\t\t\tep_38C1600->tagqng_able = adv_dvc_varp->tagqng_able;\n\t\t\tep_38C1600->start_motor = adv_dvc_varp->start_motor;\n\t\t\tep_38C1600->scsi_reset_delay =\n\t\t\t    adv_dvc_varp->scsi_reset_wait;\n\t\t\tep_38C1600->serial_number_word1 =\n\t\t\t    adv_dvc_varp->cfg->serial1;\n\t\t\tep_38C1600->serial_number_word2 =\n\t\t\t    adv_dvc_varp->cfg->serial2;\n\t\t\tep_38C1600->serial_number_word3 =\n\t\t\t    adv_dvc_varp->cfg->serial3;\n\t\t}\n\n\t\t \n\t\tboardp->init_tidmask |=\n\t\t    ADV_TID_TO_TIDMASK(adv_dvc_varp->chip_scsi_id);\n\t}\n\n\t \n\tshost->max_channel = 0;\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tshost->max_id = ASC_MAX_TID + 1;\n\t\tshost->max_lun = ASC_MAX_LUN + 1;\n\t\tshost->max_cmd_len = ASC_MAX_CDB_LEN;\n\n\t\tshost->io_port = asc_dvc_varp->iop_base;\n\t\tboardp->asc_n_io_port = ASC_IOADR_GAP;\n\t\tshost->this_id = asc_dvc_varp->cfg->chip_scsi_id;\n\n\t\t \n\t\tshost->can_queue = asc_dvc_varp->max_total_qng;\n\t} else {\n\t\tshost->max_id = ADV_MAX_TID + 1;\n\t\tshost->max_lun = ADV_MAX_LUN + 1;\n\t\tshost->max_cmd_len = ADV_MAX_CDB_LEN;\n\n\t\t \n\t\tshost->io_port = iop;\n\n\t\tshost->this_id = adv_dvc_varp->chip_scsi_id;\n\n\t\t \n\t\tshost->can_queue = adv_dvc_varp->max_host_qng;\n\t}\n\n\t \n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\t \n\t\tshost->sg_tablesize =\n\t\t    (((asc_dvc_varp->max_total_qng - 2) / 2) *\n\t\t     ASC_SG_LIST_PER_Q) + 1;\n\t} else {\n\t\tshost->sg_tablesize = ADV_MAX_SG_LIST;\n\t}\n\n\t \n\tif (shost->sg_tablesize > SG_ALL) {\n\t\tshost->sg_tablesize = SG_ALL;\n\t}\n\n\tASC_DBG(1, \"sg_tablesize: %d\\n\", shost->sg_tablesize);\n\n\t \n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tshost->base = AscGetChipBiosAddress(asc_dvc_varp->iop_base,\n\t\t\t\t\t\t    asc_dvc_varp->bus_type);\n\t} else {\n\t\t \n\t\tAdvReadWordLram(adv_dvc_varp->iop_base,\n\t\t\t\tBIOS_SIGNATURE, boardp->bios_signature);\n\t\tAdvReadWordLram(adv_dvc_varp->iop_base,\n\t\t\t\tBIOS_VERSION, boardp->bios_version);\n\t\tAdvReadWordLram(adv_dvc_varp->iop_base,\n\t\t\t\tBIOS_CODESEG, boardp->bios_codeseg);\n\t\tAdvReadWordLram(adv_dvc_varp->iop_base,\n\t\t\t\tBIOS_CODELEN, boardp->bios_codelen);\n\n\t\tASC_DBG(1, \"bios_signature 0x%x, bios_version 0x%x\\n\",\n\t\t\t boardp->bios_signature, boardp->bios_version);\n\n\t\tASC_DBG(1, \"bios_codeseg 0x%x, bios_codelen 0x%x\\n\",\n\t\t\t boardp->bios_codeseg, boardp->bios_codelen);\n\n\t\t \n\t\tif (boardp->bios_signature == 0x55AA) {\n\t\t\t \n\t\t\tshost->base = ((ulong)boardp->bios_codeseg << 4);\n\t\t} else {\n\t\t\tshost->base = 0;\n\t\t}\n\t}\n\n\t \n\n\t \n\tshost->dma_channel = NO_ISA_DMA;\t \n\n\t \n\tASC_DBG(2, \"request_irq(%d, %p)\\n\", boardp->irq, shost);\n\n\tret = request_irq(boardp->irq, advansys_interrupt, share_irq,\n\t\t\t  DRV_NAME, shost);\n\n\tif (ret) {\n\t\tif (ret == -EBUSY) {\n\t\t\tshost_printk(KERN_ERR, shost, \"request_irq(): IRQ 0x%x \"\n\t\t\t\t\t\"already in use\\n\", boardp->irq);\n\t\t} else if (ret == -EINVAL) {\n\t\t\tshost_printk(KERN_ERR, shost, \"request_irq(): IRQ 0x%x \"\n\t\t\t\t\t\"not valid\\n\", boardp->irq);\n\t\t} else {\n\t\t\tshost_printk(KERN_ERR, shost, \"request_irq(): IRQ 0x%x \"\n\t\t\t\t\t\"failed with %d\\n\", boardp->irq, ret);\n\t\t}\n\t\tgoto err_unmap;\n\t}\n\n\t \n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tASC_DBG(2, \"AscInitAsc1000Driver()\\n\");\n\n\t\tasc_dvc_varp->overrun_buf = kzalloc(ASC_OVERRUN_BSIZE, GFP_KERNEL);\n\t\tif (!asc_dvc_varp->overrun_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_irq;\n\t\t}\n\t\twarn_code = AscInitAsc1000Driver(asc_dvc_varp);\n\n\t\tif (warn_code || asc_dvc_varp->err_code) {\n\t\t\tshost_printk(KERN_ERR, shost, \"error: init_state 0x%x, \"\n\t\t\t\t\t\"warn 0x%x, error 0x%x\\n\",\n\t\t\t\t\tasc_dvc_varp->init_state, warn_code,\n\t\t\t\t\tasc_dvc_varp->err_code);\n\t\t\tif (!asc_dvc_varp->overrun_dma) {\n\t\t\t\tret = -ENODEV;\n\t\t\t\tgoto err_free_mem;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (advansys_wide_init_chip(shost)) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_free_mem;\n\t\t}\n\t}\n\n\tASC_DBG_PRT_SCSI_HOST(2, shost);\n\n\tret = scsi_add_host(shost, boardp->dev);\n\tif (ret)\n\t\tgoto err_free_mem;\n\n\tscsi_scan_host(shost);\n\treturn 0;\n\n err_free_mem:\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tif (asc_dvc_varp->overrun_dma)\n\t\t\tdma_unmap_single(boardp->dev, asc_dvc_varp->overrun_dma,\n\t\t\t\t\t ASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);\n\t\tkfree(asc_dvc_varp->overrun_buf);\n\t} else\n\t\tadvansys_wide_free_mem(boardp);\n err_free_irq:\n\tfree_irq(boardp->irq, shost);\n err_unmap:\n\tif (boardp->ioremap_addr)\n\t\tiounmap(boardp->ioremap_addr);\n#ifdef CONFIG_PCI\n err_shost:\n#endif\n\treturn ret;\n}\n\n \nstatic int advansys_release(struct Scsi_Host *shost)\n{\n\tstruct asc_board *board = shost_priv(shost);\n\tASC_DBG(1, \"begin\\n\");\n\tscsi_remove_host(shost);\n\tfree_irq(board->irq, shost);\n\n\tif (ASC_NARROW_BOARD(board)) {\n\t\tdma_unmap_single(board->dev,\n\t\t\t\t\tboard->dvc_var.asc_dvc_var.overrun_dma,\n\t\t\t\t\tASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);\n\t\tkfree(board->dvc_var.asc_dvc_var.overrun_buf);\n\t} else {\n\t\tiounmap(board->ioremap_addr);\n\t\tadvansys_wide_free_mem(board);\n\t}\n\tscsi_host_put(shost);\n\tASC_DBG(1, \"end\\n\");\n\treturn 0;\n}\n\n#define ASC_IOADR_TABLE_MAX_IX  11\n\nstatic PortAddr _asc_def_iop_base[ASC_IOADR_TABLE_MAX_IX] = {\n\t0x100, 0x0110, 0x120, 0x0130, 0x140, 0x0150, 0x0190,\n\t0x0210, 0x0230, 0x0250, 0x0330\n};\n\nstatic void advansys_vlb_remove(struct device *dev, unsigned int id)\n{\n\tint ioport = _asc_def_iop_base[id];\n\tadvansys_release(dev_get_drvdata(dev));\n\trelease_region(ioport, ASC_IOADR_GAP);\n}\n\n \nstatic unsigned int advansys_vlb_irq_no(PortAddr iop_base)\n{\n\tunsigned short cfg_lsw = AscGetChipCfgLsw(iop_base);\n\tunsigned int chip_irq = ((cfg_lsw >> 2) & 0x07) + 9;\n\tif ((chip_irq < 10) || (chip_irq == 13) || (chip_irq > 15))\n\t\treturn 0;\n\treturn chip_irq;\n}\n\nstatic int advansys_vlb_probe(struct device *dev, unsigned int id)\n{\n\tint err = -ENODEV;\n\tPortAddr iop_base = _asc_def_iop_base[id];\n\tstruct Scsi_Host *shost;\n\tstruct asc_board *board;\n\n\tif (!request_region(iop_base, ASC_IOADR_GAP, DRV_NAME)) {\n\t\tASC_DBG(1, \"I/O port 0x%x busy\\n\", iop_base);\n\t\treturn -ENODEV;\n\t}\n\tASC_DBG(1, \"probing I/O port 0x%x\\n\", iop_base);\n\tif (!AscFindSignature(iop_base))\n\t\tgoto release_region;\n\t \n\tif (AscGetChipVersion(iop_base, ASC_IS_VL) > ASC_CHIP_MAX_VER_VL)\n\t\tgoto release_region;\n\n\terr = -ENOMEM;\n\tshost = scsi_host_alloc(&advansys_template, sizeof(*board));\n\tif (!shost)\n\t\tgoto release_region;\n\n\tboard = shost_priv(shost);\n\tboard->irq = advansys_vlb_irq_no(iop_base);\n\tboard->dev = dev;\n\tboard->shost = shost;\n\n\terr = advansys_board_found(shost, iop_base, ASC_IS_VL);\n\tif (err)\n\t\tgoto free_host;\n\n\tdev_set_drvdata(dev, shost);\n\treturn 0;\n\n free_host:\n\tscsi_host_put(shost);\n release_region:\n\trelease_region(iop_base, ASC_IOADR_GAP);\n\treturn -ENODEV;\n}\n\nstatic struct isa_driver advansys_vlb_driver = {\n\t.probe\t\t= advansys_vlb_probe,\n\t.remove\t\t= advansys_vlb_remove,\n\t.driver = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"advansys_vlb\",\n\t},\n};\n\nstatic struct eisa_device_id advansys_eisa_table[] = {\n\t{ \"ABP7401\" },\n\t{ \"ABP7501\" },\n\t{ \"\" }\n};\n\nMODULE_DEVICE_TABLE(eisa, advansys_eisa_table);\n\n \nstruct eisa_scsi_data {\n\tstruct Scsi_Host *host[2];\n};\n\n \nstatic unsigned int advansys_eisa_irq_no(struct eisa_device *edev)\n{\n\tunsigned short cfg_lsw = inw(edev->base_addr + 0xc86);\n\tunsigned int chip_irq = ((cfg_lsw >> 8) & 0x07) + 10;\n\tif ((chip_irq == 13) || (chip_irq > 15))\n\t\treturn 0;\n\treturn chip_irq;\n}\n\nstatic int advansys_eisa_probe(struct device *dev)\n{\n\tint i, ioport, irq = 0;\n\tint err;\n\tstruct eisa_device *edev = to_eisa_device(dev);\n\tstruct eisa_scsi_data *data;\n\n\terr = -ENOMEM;\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\tgoto fail;\n\tioport = edev->base_addr + 0xc30;\n\n\terr = -ENODEV;\n\tfor (i = 0; i < 2; i++, ioport += 0x20) {\n\t\tstruct asc_board *board;\n\t\tstruct Scsi_Host *shost;\n\t\tif (!request_region(ioport, ASC_IOADR_GAP, DRV_NAME)) {\n\t\t\tprintk(KERN_WARNING \"Region %x-%x busy\\n\", ioport,\n\t\t\t       ioport + ASC_IOADR_GAP - 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!AscFindSignature(ioport)) {\n\t\t\trelease_region(ioport, ASC_IOADR_GAP);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tinw(ioport + 4);\n\n\t\tif (!irq)\n\t\t\tirq = advansys_eisa_irq_no(edev);\n\n\t\terr = -ENOMEM;\n\t\tshost = scsi_host_alloc(&advansys_template, sizeof(*board));\n\t\tif (!shost)\n\t\t\tgoto release_region;\n\n\t\tboard = shost_priv(shost);\n\t\tboard->irq = irq;\n\t\tboard->dev = dev;\n\t\tboard->shost = shost;\n\n\t\terr = advansys_board_found(shost, ioport, ASC_IS_EISA);\n\t\tif (!err) {\n\t\t\tdata->host[i] = shost;\n\t\t\tcontinue;\n\t\t}\n\n\t\tscsi_host_put(shost);\n release_region:\n\t\trelease_region(ioport, ASC_IOADR_GAP);\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\tgoto free_data;\n\tdev_set_drvdata(dev, data);\n\treturn 0;\n\n free_data:\n\tkfree(data->host[0]);\n\tkfree(data->host[1]);\n\tkfree(data);\n fail:\n\treturn err;\n}\n\nstatic int advansys_eisa_remove(struct device *dev)\n{\n\tint i;\n\tstruct eisa_scsi_data *data = dev_get_drvdata(dev);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tint ioport;\n\t\tstruct Scsi_Host *shost = data->host[i];\n\t\tif (!shost)\n\t\t\tcontinue;\n\t\tioport = shost->io_port;\n\t\tadvansys_release(shost);\n\t\trelease_region(ioport, ASC_IOADR_GAP);\n\t}\n\n\tkfree(data);\n\treturn 0;\n}\n\nstatic struct eisa_driver advansys_eisa_driver = {\n\t.id_table =\t\tadvansys_eisa_table,\n\t.driver = {\n\t\t.name =\t\tDRV_NAME,\n\t\t.probe =\tadvansys_eisa_probe,\n\t\t.remove =\tadvansys_eisa_remove,\n\t}\n};\n\n \nstatic struct pci_device_id advansys_pci_tbl[] = {\n\t{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_1200A,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940U,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940UW,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_38C0800_REV1,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_38C1600_REV1,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, advansys_pci_tbl);\n\nstatic void advansys_set_latency(struct pci_dev *pdev)\n{\n\tif ((pdev->device == PCI_DEVICE_ID_ASP_1200A) ||\n\t    (pdev->device == PCI_DEVICE_ID_ASP_ABP940)) {\n\t\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0);\n\t} else {\n\t\tu8 latency;\n\t\tpci_read_config_byte(pdev, PCI_LATENCY_TIMER, &latency);\n\t\tif (latency < 0x20)\n\t\t\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x20);\n\t}\n}\n\nstatic int advansys_pci_probe(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *ent)\n{\n\tint err, ioport;\n\tstruct Scsi_Host *shost;\n\tstruct asc_board *board;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\tgoto fail;\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err)\n\t\tgoto disable_device;\n\tpci_set_master(pdev);\n\tadvansys_set_latency(pdev);\n\n\terr = -ENODEV;\n\tif (pci_resource_len(pdev, 0) == 0)\n\t\tgoto release_region;\n\n\tioport = pci_resource_start(pdev, 0);\n\n\terr = -ENOMEM;\n\tshost = scsi_host_alloc(&advansys_template, sizeof(*board));\n\tif (!shost)\n\t\tgoto release_region;\n\n\tboard = shost_priv(shost);\n\tboard->irq = pdev->irq;\n\tboard->dev = &pdev->dev;\n\tboard->shost = shost;\n\n\tif (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW ||\n\t    pdev->device == PCI_DEVICE_ID_38C0800_REV1 ||\n\t    pdev->device == PCI_DEVICE_ID_38C1600_REV1) {\n\t\tboard->flags |= ASC_IS_WIDE_BOARD;\n\t}\n\n\terr = advansys_board_found(shost, ioport, ASC_IS_PCI);\n\tif (err)\n\t\tgoto free_host;\n\n\tpci_set_drvdata(pdev, shost);\n\treturn 0;\n\n free_host:\n\tscsi_host_put(shost);\n release_region:\n\tpci_release_regions(pdev);\n disable_device:\n\tpci_disable_device(pdev);\n fail:\n\treturn err;\n}\n\nstatic void advansys_pci_remove(struct pci_dev *pdev)\n{\n\tadvansys_release(pci_get_drvdata(pdev));\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic struct pci_driver advansys_pci_driver = {\n\t.name =\t\tDRV_NAME,\n\t.id_table =\tadvansys_pci_tbl,\n\t.probe =\tadvansys_pci_probe,\n\t.remove =\tadvansys_pci_remove,\n};\n\nstatic int __init advansys_init(void)\n{\n\tint error;\n\n\terror = isa_register_driver(&advansys_vlb_driver,\n\t\t\t\t    ASC_IOADR_TABLE_MAX_IX);\n\tif (error)\n\t\tgoto fail;\n\n\terror = eisa_driver_register(&advansys_eisa_driver);\n\tif (error)\n\t\tgoto unregister_vlb;\n\n\terror = pci_register_driver(&advansys_pci_driver);\n\tif (error)\n\t\tgoto unregister_eisa;\n\n\treturn 0;\n\n unregister_eisa:\n\teisa_driver_unregister(&advansys_eisa_driver);\n unregister_vlb:\n\tisa_unregister_driver(&advansys_vlb_driver);\n fail:\n\treturn error;\n}\n\nstatic void __exit advansys_exit(void)\n{\n\tpci_unregister_driver(&advansys_pci_driver);\n\teisa_driver_unregister(&advansys_eisa_driver);\n\tisa_unregister_driver(&advansys_vlb_driver);\n}\n\nmodule_init(advansys_init);\nmodule_exit(advansys_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"advansys/mcode.bin\");\nMODULE_FIRMWARE(\"advansys/3550.bin\");\nMODULE_FIRMWARE(\"advansys/38C0800.bin\");\nMODULE_FIRMWARE(\"advansys/38C1600.bin\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}