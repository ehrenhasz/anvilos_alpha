{
  "module_name": "nsp32.c",
  "hash_id": "ae8e13f6244318d083cbf9887ebbbce931801b9f0f33ac6660077e491a396e3f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/nsp32.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/ioport.h>\n#include <linux/major.h>\n#include <linux/blkdev.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/ctype.h>\n#include <linux/dma-mapping.h>\n\n#include <asm/dma.h>\n#include <asm/io.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_ioctl.h>\n\n#include \"nsp32.h\"\n\n\n \nstatic int       trans_mode = 0;\t \nmodule_param     (trans_mode, int, 0);\nMODULE_PARM_DESC(trans_mode, \"transfer mode (0: BIOS(default) 1: Async 2: Ultra20M\");\n#define ASYNC_MODE    1\n#define ULTRA20M_MODE 2\n\nstatic bool      auto_param = 0;\t \nmodule_param     (auto_param, bool, 0);\nMODULE_PARM_DESC(auto_param, \"AutoParameter mode (0: ON(default) 1: OFF)\");\n\nstatic bool      disc_priv  = 1;\t \nmodule_param     (disc_priv, bool, 0);\nMODULE_PARM_DESC(disc_priv,  \"disconnection privilege mode (0: ON 1: OFF(default))\");\n\nMODULE_AUTHOR(\"YOKOTA Hiroshi <yokota@netlab.is.tsukuba.ac.jp>, GOTO Masanori <gotom@debian.or.jp>\");\nMODULE_DESCRIPTION(\"Workbit NinjaSCSI-32Bi/UDE CardBus/PCI SCSI host bus adapter module\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const char *nsp32_release_version = \"1.2\";\n\n\n \nstatic struct pci_device_id nsp32_pci_table[] = {\n\t{\n\t\t.vendor      = PCI_VENDOR_ID_IODATA,\n\t\t.device      = PCI_DEVICE_ID_NINJASCSI_32BI_CBSC_II,\n\t\t.subvendor   = PCI_ANY_ID,\n\t\t.subdevice   = PCI_ANY_ID,\n\t\t.driver_data = MODEL_IODATA,\n\t},\n\t{\n\t\t.vendor      = PCI_VENDOR_ID_WORKBIT,\n\t\t.device      = PCI_DEVICE_ID_NINJASCSI_32BI_KME,\n\t\t.subvendor   = PCI_ANY_ID,\n\t\t.subdevice   = PCI_ANY_ID,\n\t\t.driver_data = MODEL_KME,\n\t},\n\t{\n\t\t.vendor      = PCI_VENDOR_ID_WORKBIT,\n\t\t.device      = PCI_DEVICE_ID_NINJASCSI_32BI_WBT,\n\t\t.subvendor   = PCI_ANY_ID,\n\t\t.subdevice   = PCI_ANY_ID,\n\t\t.driver_data = MODEL_WORKBIT,\n\t},\n\t{\n\t\t.vendor      = PCI_VENDOR_ID_WORKBIT,\n\t\t.device      = PCI_DEVICE_ID_WORKBIT_STANDARD,\n\t\t.subvendor   = PCI_ANY_ID,\n\t\t.subdevice   = PCI_ANY_ID,\n\t\t.driver_data = MODEL_PCI_WORKBIT,\n\t},\n\t{\n\t\t.vendor      = PCI_VENDOR_ID_WORKBIT,\n\t\t.device      = PCI_DEVICE_ID_NINJASCSI_32BI_LOGITEC,\n\t\t.subvendor   = PCI_ANY_ID,\n\t\t.subdevice   = PCI_ANY_ID,\n\t\t.driver_data = MODEL_LOGITEC,\n\t},\n\t{\n\t\t.vendor      = PCI_VENDOR_ID_WORKBIT,\n\t\t.device      = PCI_DEVICE_ID_NINJASCSI_32BIB_LOGITEC,\n\t\t.subvendor   = PCI_ANY_ID,\n\t\t.subdevice   = PCI_ANY_ID,\n\t\t.driver_data = MODEL_PCI_LOGITEC,\n\t},\n\t{\n\t\t.vendor      = PCI_VENDOR_ID_WORKBIT,\n\t\t.device      = PCI_DEVICE_ID_NINJASCSI_32UDE_MELCO,\n\t\t.subvendor   = PCI_ANY_ID,\n\t\t.subdevice   = PCI_ANY_ID,\n\t\t.driver_data = MODEL_PCI_MELCO,\n\t},\n\t{\n\t\t.vendor      = PCI_VENDOR_ID_WORKBIT,\n\t\t.device      = PCI_DEVICE_ID_NINJASCSI_32UDE_MELCO_II,\n\t\t.subvendor   = PCI_ANY_ID,\n\t\t.subdevice   = PCI_ANY_ID,\n\t\t.driver_data = MODEL_PCI_MELCO,\n\t},\n\t{0,0,},\n};\nMODULE_DEVICE_TABLE(pci, nsp32_pci_table);\n\nstatic nsp32_hw_data nsp32_data_base;   \n\n\n \nstatic nsp32_sync_table nsp32_sync_table_40M[] = {\n      \n\t{0x1,  0, 0x0c, 0x0c, SMPL_40M},   \n\t{0x2,  0, 0x0d, 0x18, SMPL_40M},   \n\t{0x3,  1, 0x19, 0x19, SMPL_40M},   \n\t{0x4,  1, 0x1a, 0x1f, SMPL_20M},   \n\t{0x5,  2, 0x20, 0x25, SMPL_20M},   \n\t{0x6,  2, 0x26, 0x31, SMPL_20M},   \n\t{0x7,  3, 0x32, 0x32, SMPL_20M},   \n\t{0x8,  3, 0x33, 0x38, SMPL_10M},   \n\t{0x9,  3, 0x39, 0x3e, SMPL_10M},   \n};\n\nstatic nsp32_sync_table nsp32_sync_table_20M[] = {\n\t{0x1,  0, 0x19, 0x19, SMPL_40M},   \n\t{0x2,  0, 0x1a, 0x25, SMPL_20M},   \n\t{0x3,  1, 0x26, 0x32, SMPL_20M},   \n\t{0x4,  1, 0x33, 0x3e, SMPL_10M},   \n\t{0x5,  2, 0x3f, 0x4b, SMPL_10M},   \n\t{0x6,  2, 0x4c, 0x57, SMPL_10M},   \n\t{0x7,  3, 0x58, 0x64, SMPL_10M},   \n\t{0x8,  3, 0x65, 0x70, SMPL_10M},   \n\t{0x9,  3, 0x71, 0x7d, SMPL_10M},   \n};\n\nstatic nsp32_sync_table nsp32_sync_table_pci[] = {\n\t{0x1,  0, 0x0c, 0x0f, SMPL_40M},   \n\t{0x2,  0, 0x10, 0x16, SMPL_40M},   \n\t{0x3,  1, 0x17, 0x1e, SMPL_20M},   \n\t{0x4,  1, 0x1f, 0x25, SMPL_20M},   \n\t{0x5,  2, 0x26, 0x2d, SMPL_20M},   \n\t{0x6,  2, 0x2e, 0x34, SMPL_10M},   \n\t{0x7,  3, 0x35, 0x3c, SMPL_10M},   \n\t{0x8,  3, 0x3d, 0x43, SMPL_10M},   \n\t{0x9,  3, 0x44, 0x4b, SMPL_10M},   \n};\n\n \n \nstatic int nsp32_probe (struct pci_dev *, const struct pci_device_id *);\nstatic void nsp32_remove(struct pci_dev *);\nstatic int  __init init_nsp32  (void);\nstatic void __exit exit_nsp32  (void);\n\n \nstatic int\t   nsp32_show_info   (struct seq_file *, struct Scsi_Host *);\n\nstatic int\t   nsp32_detect      (struct pci_dev *pdev);\nstatic int\t   nsp32_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);\nstatic const char *nsp32_info\t     (struct Scsi_Host *);\nstatic int\t   nsp32_release     (struct Scsi_Host *);\n\n \nstatic int\t   nsp32_eh_abort     (struct scsi_cmnd *);\nstatic int\t   nsp32_eh_host_reset(struct scsi_cmnd *);\n\n \nstatic void nsp32_build_identify(struct scsi_cmnd *);\nstatic void nsp32_build_nop     (struct scsi_cmnd *);\nstatic void nsp32_build_reject  (struct scsi_cmnd *);\nstatic void nsp32_build_sdtr    (struct scsi_cmnd *, unsigned char,\n\t\t\t\t unsigned char);\n\n \nstatic int  nsp32_busfree_occur(struct scsi_cmnd *, unsigned short);\nstatic void nsp32_msgout_occur (struct scsi_cmnd *);\nstatic void nsp32_msgin_occur  (struct scsi_cmnd *, unsigned long,\n\t\t\t\tunsigned short);\n\nstatic int  nsp32_setup_sg_table    (struct scsi_cmnd *);\nstatic int  nsp32_selection_autopara(struct scsi_cmnd *);\nstatic int  nsp32_selection_autoscsi(struct scsi_cmnd *);\nstatic void nsp32_scsi_done\t    (struct scsi_cmnd *);\nstatic int  nsp32_arbitration       (struct scsi_cmnd *, unsigned int);\nstatic int  nsp32_reselection       (struct scsi_cmnd *, unsigned char);\nstatic void nsp32_adjust_busfree    (struct scsi_cmnd *, unsigned int);\nstatic void nsp32_restart_autoscsi  (struct scsi_cmnd *, unsigned short);\n\n \nstatic void nsp32_analyze_sdtr       (struct scsi_cmnd *);\nstatic int  nsp32_search_period_entry(nsp32_hw_data *, nsp32_target *,\n\t\t\t\t      unsigned char);\nstatic void nsp32_set_async\t     (nsp32_hw_data *, nsp32_target *);\nstatic void nsp32_set_max_sync       (nsp32_hw_data *, nsp32_target *,\n\t\t\t\t      unsigned char *, unsigned char *);\nstatic void nsp32_set_sync_entry     (nsp32_hw_data *, nsp32_target *,\n\t\t\t\t      int, unsigned char);\n\n \nstatic void nsp32_wait_req    (nsp32_hw_data *, int);\nstatic void nsp32_wait_sack   (nsp32_hw_data *, int);\nstatic void nsp32_sack_assert (nsp32_hw_data *);\nstatic void nsp32_sack_negate (nsp32_hw_data *);\nstatic void nsp32_do_bus_reset(nsp32_hw_data *);\n\n \nstatic irqreturn_t do_nsp32_isr(int, void *);\n\n \nstatic int  nsp32hw_init(nsp32_hw_data *);\n\n \nstatic int  nsp32_getprom_param (nsp32_hw_data *);\nstatic int  nsp32_getprom_at24  (nsp32_hw_data *);\nstatic int  nsp32_getprom_c16   (nsp32_hw_data *);\nstatic void nsp32_prom_start    (nsp32_hw_data *);\nstatic void nsp32_prom_stop     (nsp32_hw_data *);\nstatic int  nsp32_prom_read     (nsp32_hw_data *, int);\nstatic int  nsp32_prom_read_bit (nsp32_hw_data *);\nstatic void nsp32_prom_write_bit(nsp32_hw_data *, int);\nstatic void nsp32_prom_set      (nsp32_hw_data *, int, int);\nstatic int  nsp32_prom_get      (nsp32_hw_data *, int);\n\n \nstatic void nsp32_message (const char *, int, char *, char *, ...);\n#ifdef NSP32_DEBUG\nstatic void nsp32_dmessage(const char *, int, int,    char *, ...);\n#endif\n\n \nstatic const struct scsi_host_template nsp32_template = {\n\t.proc_name\t\t\t= \"nsp32\",\n\t.name\t\t\t\t= \"Workbit NinjaSCSI-32Bi/UDE\",\n\t.show_info\t\t\t= nsp32_show_info,\n\t.info\t\t\t\t= nsp32_info,\n\t.queuecommand\t\t\t= nsp32_queuecommand,\n\t.can_queue\t\t\t= 1,\n\t.sg_tablesize\t\t\t= NSP32_SG_SIZE,\n\t.max_sectors\t\t\t= 128,\n\t.this_id\t\t\t= NSP32_HOST_SCSIID,\n\t.dma_boundary\t\t\t= PAGE_SIZE - 1,\n\t.eh_abort_handler\t\t= nsp32_eh_abort,\n\t.eh_host_reset_handler\t\t= nsp32_eh_host_reset,\n \n\t.cmd_size\t\t\t= sizeof(struct nsp32_cmd_priv),\n};\n\n#include \"nsp32_io.h\"\n\n \n#ifndef NSP32_DEBUG\n# define NSP32_DEBUG_MASK\t      0x000000\n# define nsp32_msg(type, args...)     nsp32_message (\"\", 0, (type), args)\n# define nsp32_dbg(mask, args...)      \n#else\n# define NSP32_DEBUG_MASK\t      0xffffff\n# define nsp32_msg(type, args...) \\\n\tnsp32_message (__func__, __LINE__, (type), args)\n# define nsp32_dbg(mask, args...) \\\n\tnsp32_dmessage(__func__, __LINE__, (mask), args)\n#endif\n\n#define NSP32_DEBUG_QUEUECOMMAND\tBIT(0)\n#define NSP32_DEBUG_REGISTER\t\tBIT(1)\n#define NSP32_DEBUG_AUTOSCSI\t\tBIT(2)\n#define NSP32_DEBUG_INTR\t\tBIT(3)\n#define NSP32_DEBUG_SGLIST\t\tBIT(4)\n#define NSP32_DEBUG_BUSFREE\t\tBIT(5)\n#define NSP32_DEBUG_CDB_CONTENTS\tBIT(6)\n#define NSP32_DEBUG_RESELECTION\t\tBIT(7)\n#define NSP32_DEBUG_MSGINOCCUR\t\tBIT(8)\n#define NSP32_DEBUG_EEPROM\t\tBIT(9)\n#define NSP32_DEBUG_MSGOUTOCCUR\t\tBIT(10)\n#define NSP32_DEBUG_BUSRESET\t\tBIT(11)\n#define NSP32_DEBUG_RESTART\t\tBIT(12)\n#define NSP32_DEBUG_SYNC\t\tBIT(13)\n#define NSP32_DEBUG_WAIT\t\tBIT(14)\n#define NSP32_DEBUG_TARGETFLAG\t\tBIT(15)\n#define NSP32_DEBUG_PROC\t\tBIT(16)\n#define NSP32_DEBUG_INIT\t\tBIT(17)\n#define NSP32_SPECIAL_PRINT_REGISTER\tBIT(20)\n\n#define NSP32_DEBUG_BUF_LEN\t\t100\n\n__printf(4, 5)\nstatic void nsp32_message(const char *func, int line, char *type, char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[NSP32_DEBUG_BUF_LEN];\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n#ifndef NSP32_DEBUG\n\tprintk(\"%snsp32: %s\\n\", type, buf);\n#else\n\tprintk(\"%snsp32: %s (%d): %s\\n\", type, func, line, buf);\n#endif\n}\n\n#ifdef NSP32_DEBUG\nstatic void nsp32_dmessage(const char *func, int line, int mask, char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[NSP32_DEBUG_BUF_LEN];\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (mask & NSP32_DEBUG_MASK) {\n\t\tprintk(\"nsp32-debug: 0x%x %s (%d): %s\\n\", mask, func, line, buf);\n\t}\n}\n#endif\n\n#ifdef NSP32_DEBUG\n# include \"nsp32_debug.c\"\n#else\n# define show_command(arg)    \n# define show_busphase(arg)   \n# define show_autophase(arg)  \n#endif\n\n \nstatic void nsp32_build_identify(struct scsi_cmnd *SCpnt)\n{\n\tnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tint pos\t\t    = data->msgout_len;\n\tint mode\t    = FALSE;\n\n\t \n\tif (disc_priv == 0) {\n\t\t \n\t}\n\n\tdata->msgoutbuf[pos] = IDENTIFY(mode, SCpnt->device->lun); pos++;\n\n\tdata->msgout_len = pos;\n}\n\n \nstatic void nsp32_build_sdtr(struct scsi_cmnd    *SCpnt,\n\t\t\t     unsigned char period,\n\t\t\t     unsigned char offset)\n{\n\tnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tint pos = data->msgout_len;\n\n\tdata->msgoutbuf[pos] = EXTENDED_MESSAGE;  pos++;\n\tdata->msgoutbuf[pos] = EXTENDED_SDTR_LEN; pos++;\n\tdata->msgoutbuf[pos] = EXTENDED_SDTR;     pos++;\n\tdata->msgoutbuf[pos] = period;\t\t  pos++;\n\tdata->msgoutbuf[pos] = offset;\t\t  pos++;\n\n\tdata->msgout_len = pos;\n}\n\n \nstatic void nsp32_build_nop(struct scsi_cmnd *SCpnt)\n{\n\tnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tint pos  = data->msgout_len;\n\n\tif (pos != 0) {\n\t\tnsp32_msg(KERN_WARNING,\n\t\t\t  \"Some messages are already contained!\");\n\t\treturn;\n\t}\n\n\tdata->msgoutbuf[pos] = NOP; pos++;\n\tdata->msgout_len = pos;\n}\n\n \nstatic void nsp32_build_reject(struct scsi_cmnd *SCpnt)\n{\n\tnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tint pos  = data->msgout_len;\n\n\tdata->msgoutbuf[pos] = MESSAGE_REJECT; pos++;\n\tdata->msgout_len = pos;\n}\n\n \n#if 0\nstatic void nsp32_start_timer(struct scsi_cmnd *SCpnt, int time)\n{\n\tunsigned int base = SCpnt->host->io_port;\n\n\tnsp32_dbg(NSP32_DEBUG_INTR, \"timer=%d\", time);\n\n\tif (time & (~TIMER_CNT_MASK)) {\n\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"timer set overflow\");\n\t}\n\n\tnsp32_write2(base, TIMER_SET, time & TIMER_CNT_MASK);\n}\n#endif\n\n\n \nstatic int nsp32_selection_autopara(struct scsi_cmnd *SCpnt)\n{\n\tnsp32_hw_data  *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tunsigned int\tbase    = SCpnt->device->host->io_port;\n\tunsigned int\thost_id = SCpnt->device->host->this_id;\n\tunsigned char\ttarget  = scmd_id(SCpnt);\n\tnsp32_autoparam *param  = data->autoparam;\n\tunsigned char\tphase;\n\tint\t\ti, ret;\n\tunsigned int\tmsgout;\n\tu16_le\t\ts;\n\n\tnsp32_dbg(NSP32_DEBUG_AUTOSCSI, \"in\");\n\n\t \n\tphase = nsp32_read1(base, SCSI_BUS_MONITOR);\n\tif (phase != BUSMON_BUS_FREE) {\n\t\tnsp32_msg(KERN_WARNING, \"bus busy\");\n\t\tshow_busphase(phase & BUSMON_PHASE_MASK);\n\t\tSCpnt->result = DID_BUS_BUSY << 16;\n\t\treturn FALSE;\n\t}\n\n\t \n\tif (data->msgout_len == 0) {\n\t\tnsp32_msg(KERN_ERR, \"SCSI MsgOut without any message!\");\n\t\tSCpnt->result = DID_ERROR << 16;\n\t\treturn FALSE;\n\t} else if (data->msgout_len > 0 && data->msgout_len <= 3) {\n\t\tmsgout = 0;\n\t\tfor (i = 0; i < data->msgout_len; i++) {\n\t\t\t \n\t\t\tmsgout >>= 8;\n\t\t\tmsgout |= ((unsigned int)(data->msgoutbuf[i]) << 24);\n\t\t}\n\t\tmsgout |= MV_VALID;\t \n\t\tmsgout |= (unsigned int)data->msgout_len;  \n\t} else {\n\t\t \n\t\tmsgout = 0;\n\t}\n\n\t\n\t\n\t\n\n\t \n\tmemset(param, 0, sizeof(nsp32_autoparam));\n\n\t \n\tfor (i = 0; i < SCpnt->cmd_len; i++) {\n\t\tparam->cdb[4 * i] = SCpnt->cmnd[i];\n\t}\n\n\t \n\tparam->msgout = cpu_to_le32(msgout);\n\n\t \n\tparam->syncreg    = data->cur_target->syncreg;\n\tparam->ackwidth   = data->cur_target->ackwidth;\n\tparam->target_id  = BIT(host_id) | BIT(target);\n\tparam->sample_reg = data->cur_target->sample_reg;\n\n\t\n\n\t \n\tparam->command_control = cpu_to_le16(CLEAR_CDB_FIFO_POINTER |\n\t\t\t\t\t     AUTOSCSI_START |\n\t\t\t\t\t     AUTO_MSGIN_00_OR_04 |\n\t\t\t\t\t     AUTO_MSGIN_02 |\n\t\t\t\t\t     AUTO_ATN );\n\n\n\t \n\ts = 0;\n\tswitch (data->trans_method) {\n\tcase NSP32_TRANSFER_BUSMASTER:\n\t\ts |= BM_START;\n\t\tbreak;\n\tcase NSP32_TRANSFER_MMIO:\n\t\ts |= CB_MMIO_MODE;\n\t\tbreak;\n\tcase NSP32_TRANSFER_PIO:\n\t\ts |= CB_IO_MODE;\n\t\tbreak;\n\tdefault:\n\t\tnsp32_msg(KERN_ERR, \"unknown trans_method\");\n\t\tbreak;\n\t}\n\t \n\ts |= (TRANSFER_GO | ALL_COUNTER_CLR);\n\tparam->transfer_control = cpu_to_le16(s);\n\n\t \n\tparam->sgt_pointer = cpu_to_le32(data->cur_lunt->sglun_paddr);\n\n\t \n\tnsp32_write4(base, SGT_ADR, data->auto_paddr);\n\tnsp32_write2(base, COMMAND_CONTROL,\n\t\t     CLEAR_CDB_FIFO_POINTER | AUTO_PARAMETER );\n\n\t \n\tret = nsp32_arbitration(SCpnt, base);\n\n\treturn ret;\n}\n\n\n \nstatic int nsp32_selection_autoscsi(struct scsi_cmnd *SCpnt)\n{\n\tnsp32_hw_data  *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tunsigned int\tbase    = SCpnt->device->host->io_port;\n\tunsigned int\thost_id = SCpnt->device->host->this_id;\n\tunsigned char\ttarget  = scmd_id(SCpnt);\n\tunsigned char\tphase;\n\tint\t\tstatus;\n\tunsigned short\tcommand\t= 0;\n\tunsigned int\tmsgout  = 0;\n\tint\t\ti;\n\n\tnsp32_dbg(NSP32_DEBUG_AUTOSCSI, \"in\");\n\n\t \n\tnsp32_write2(base, IRQ_CONTROL, IRQ_CONTROL_ALL_IRQ_MASK);\n\n\t \n\tphase = nsp32_read1(base, SCSI_BUS_MONITOR);\n\tif ((phase & BUSMON_BSY) || (phase & BUSMON_SEL)) {\n\t\tnsp32_msg(KERN_WARNING, \"bus busy\");\n\t\tSCpnt->result = DID_BUS_BUSY << 16;\n\t\tstatus = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tnsp32_read2(base, SCSI_EXECUTE_PHASE);\n\n\t \n\tnsp32_write2(base, COMMAND_CONTROL, CLEAR_CDB_FIFO_POINTER);\n\n\t \n\tfor (i = 0; i < SCpnt->cmd_len; i++) {\n\t\tnsp32_write1(base, COMMAND_DATA, SCpnt->cmnd[i]);\n\t}\n\tnsp32_dbg(NSP32_DEBUG_CDB_CONTENTS, \"CDB[0]=[0x%x]\", SCpnt->cmnd[0]);\n\n\t \n\tnsp32_write1(base, SCSI_OUT_LATCH_TARGET_ID,\n\t\t     BIT(host_id) | BIT(target));\n\n\t \n\tif (data->msgout_len == 0) {\n\t\tnsp32_msg(KERN_ERR, \"SCSI MsgOut without any message!\");\n\t\tSCpnt->result = DID_ERROR << 16;\n\t\tstatus = 1;\n\t\tgoto out;\n\t} else if (data->msgout_len > 0 && data->msgout_len <= 3) {\n\t\tmsgout = 0;\n\t\tfor (i = 0; i < data->msgout_len; i++) {\n\t\t\t \n\t\t\tmsgout >>= 8;\n\t\t\tmsgout |= ((unsigned int)(data->msgoutbuf[i]) << 24);\n\t\t}\n\t\tmsgout |= MV_VALID;\t \n\t\tmsgout |= (unsigned int)data->msgout_len;  \n\t\tnsp32_write4(base, SCSI_MSG_OUT, msgout);\n\t} else {\n\t\t \n\t\tnsp32_write4(base, SCSI_MSG_OUT, 0);\n\t}\n\n\t \n\tnsp32_write2(base, SEL_TIME_OUT,   SEL_TIMEOUT_TIME);\n\n\t \n\tnsp32_write1(base, SREQ_SMPL_RATE, data->cur_target->sample_reg);\n\n\t \n\tnsp32_write1(base, SET_ARBIT,      ARBIT_CLEAR);\n\n\t \n\tnsp32_write1(base, SYNC_REG,  data->cur_target->syncreg);\n\n\t \n\tnsp32_write1(base, ACK_WIDTH, data->cur_target->ackwidth);\n\n\tnsp32_dbg(NSP32_DEBUG_AUTOSCSI,\n\t\t  \"syncreg=0x%x, ackwidth=0x%x, sgtpaddr=0x%x, id=0x%x\",\n\t\t  nsp32_read1(base, SYNC_REG), nsp32_read1(base, ACK_WIDTH),\n\t\t  nsp32_read4(base, SGT_ADR),\n\t\t  nsp32_read1(base, SCSI_OUT_LATCH_TARGET_ID));\n\tnsp32_dbg(NSP32_DEBUG_AUTOSCSI, \"msgout_len=%d, msgout=0x%x\",\n\t\t  data->msgout_len, msgout);\n\n\t \n\tnsp32_write4(base, SGT_ADR, data->cur_lunt->sglun_paddr);\n\n\t \n\tcommand = 0;\n\tcommand |= (TRANSFER_GO | ALL_COUNTER_CLR);\n\tif (data->trans_method & NSP32_TRANSFER_BUSMASTER) {\n\t\tif (scsi_bufflen(SCpnt) > 0) {\n\t\t\tcommand |= BM_START;\n\t\t}\n\t} else if (data->trans_method & NSP32_TRANSFER_MMIO) {\n\t\tcommand |= CB_MMIO_MODE;\n\t} else if (data->trans_method & NSP32_TRANSFER_PIO) {\n\t\tcommand |= CB_IO_MODE;\n\t}\n\tnsp32_write2(base, TRANSFER_CONTROL, command);\n\n\t \n\tcommand = (CLEAR_CDB_FIFO_POINTER |\n\t\t   AUTOSCSI_START\t  |\n\t\t   AUTO_MSGIN_00_OR_04    |\n\t\t   AUTO_MSGIN_02\t  |\n\t\t   AUTO_ATN);\n\tnsp32_write2(base, COMMAND_CONTROL, command);\n\n\t \n\tstatus = nsp32_arbitration(SCpnt, base);\n\n out:\n\t \n\tnsp32_write2(base, IRQ_CONTROL, 0);\n\n\treturn status;\n}\n\n\n \nstatic int nsp32_arbitration(struct scsi_cmnd *SCpnt, unsigned int base)\n{\n\tunsigned char arbit;\n\tint\t      status = TRUE;\n\tint\t      time   = 0;\n\n\tdo {\n\t\tarbit = nsp32_read1(base, ARBIT_STATUS);\n\t\ttime++;\n\t} while ((arbit & (ARBIT_WIN | ARBIT_FAIL)) == 0 &&\n\t\t (time <= ARBIT_TIMEOUT_TIME));\n\n\tnsp32_dbg(NSP32_DEBUG_AUTOSCSI,\n\t\t  \"arbit: 0x%x, delay time: %d\", arbit, time);\n\n\tif (arbit & ARBIT_WIN) {\n\t\t \n\t\tSCpnt->result = DID_OK << 16;\n\t\tnsp32_index_write1(base, EXT_PORT, LED_ON);  \n\t} else if (arbit & ARBIT_FAIL) {\n\t\t \n\t\tSCpnt->result = DID_BUS_BUSY << 16;\n\t\tstatus = FALSE;\n\t} else {\n\t\t \n\t\tnsp32_dbg(NSP32_DEBUG_AUTOSCSI, \"arbit timeout\");\n\t\tSCpnt->result = DID_NO_CONNECT << 16;\n\t\tstatus = FALSE;\n\t}\n\n\t \n\tnsp32_write1(base, SET_ARBIT, ARBIT_CLEAR);\n\n\treturn status;\n}\n\n\n \nstatic int nsp32_reselection(struct scsi_cmnd *SCpnt, unsigned char newlun)\n{\n\tnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tunsigned int   host_id = SCpnt->device->host->this_id;\n\tunsigned int   base    = SCpnt->device->host->io_port;\n\tunsigned char  tmpid, newid;\n\n\tnsp32_dbg(NSP32_DEBUG_RESELECTION, \"enter\");\n\n\t \n\ttmpid = nsp32_read1(base, RESELECT_ID);\n\ttmpid &= (~BIT(host_id));\n\tnewid = 0;\n\twhile (tmpid) {\n\t\tif (tmpid & 1) {\n\t\t\tbreak;\n\t\t}\n\t\ttmpid >>= 1;\n\t\tnewid++;\n\t}\n\n\t \n\tif (newid >= ARRAY_SIZE(data->lunt) ||\n\t    newlun >= ARRAY_SIZE(data->lunt[0])) {\n\t\tnsp32_msg(KERN_WARNING, \"unknown id/lun\");\n\t\treturn FALSE;\n\t} else if(data->lunt[newid][newlun].SCpnt == NULL) {\n\t\tnsp32_msg(KERN_WARNING, \"no SCSI command is processing\");\n\t\treturn FALSE;\n\t}\n\n\tdata->cur_id    = newid;\n\tdata->cur_lun   = newlun;\n\tdata->cur_target = &(data->target[newid]);\n\tdata->cur_lunt   = &(data->lunt[newid][newlun]);\n\n\t \n\tnsp32_write4(base, CLR_COUNTER, CLRCOUNTER_ALLMASK);\n\n\treturn TRUE;\n}\n\n\n \nstatic int nsp32_setup_sg_table(struct scsi_cmnd *SCpnt)\n{\n\tnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tstruct scatterlist *sg;\n\tnsp32_sgtable *sgt = data->cur_lunt->sglun->sgt;\n\tint num, i;\n\tu32_le l;\n\n\tif (sgt == NULL) {\n\t\tnsp32_dbg(NSP32_DEBUG_SGLIST, \"SGT == null\");\n\t\treturn FALSE;\n\t}\n\n\tnum = scsi_dma_map(SCpnt);\n\tif (!num)\n\t\treturn TRUE;\n\telse if (num < 0)\n\t\treturn FALSE;\n\telse {\n\t\tscsi_for_each_sg(SCpnt, sg, num, i) {\n\t\t\t \n\t\t\tsgt[i].addr = cpu_to_le32(sg_dma_address(sg));\n\t\t\tsgt[i].len  = cpu_to_le32(sg_dma_len(sg));\n\n\t\t\tif (le32_to_cpu(sgt[i].len) > 0x10000) {\n\t\t\t\tnsp32_msg(KERN_ERR,\n\t\t\t\t\t\"can't transfer over 64KB at a time, \"\n\t\t\t\t\t\"size=0x%x\", le32_to_cpu(sgt[i].len));\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tnsp32_dbg(NSP32_DEBUG_SGLIST,\n\t\t\t\t  \"num 0x%x : addr 0x%lx len 0x%lx\",\n\t\t\t\t  i,\n\t\t\t\t  le32_to_cpu(sgt[i].addr),\n\t\t\t\t  le32_to_cpu(sgt[i].len ));\n\t\t}\n\n\t\t \n\t\tl = le32_to_cpu(sgt[num-1].len);\n\t\tsgt[num-1].len = cpu_to_le32(l | SGTEND);\n\t}\n\n\treturn TRUE;\n}\n\nstatic int nsp32_queuecommand_lck(struct scsi_cmnd *SCpnt)\n{\n\tvoid (*done)(struct scsi_cmnd *) = scsi_done;\n\tnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tnsp32_target *target;\n\tnsp32_lunt   *cur_lunt;\n\tint ret;\n\n\tnsp32_dbg(NSP32_DEBUG_QUEUECOMMAND,\n\t\t  \"enter. target: 0x%x LUN: 0x%llx cmnd: 0x%x cmndlen: 0x%x \"\n\t\t  \"use_sg: 0x%x reqbuf: 0x%lx reqlen: 0x%x\",\n\t\t  SCpnt->device->id, SCpnt->device->lun, SCpnt->cmnd[0],\n\t\t  SCpnt->cmd_len, scsi_sg_count(SCpnt), scsi_sglist(SCpnt),\n\t\t  scsi_bufflen(SCpnt));\n\n\tif (data->CurrentSC != NULL) {\n\t\tnsp32_msg(KERN_ERR, \"Currentsc != NULL. Cancel this command request\");\n\t\tdata->CurrentSC = NULL;\n\t\tSCpnt->result   = DID_NO_CONNECT << 16;\n\t\tdone(SCpnt);\n\t\treturn 0;\n\t}\n\n\t \n\tif (scmd_id(SCpnt) == SCpnt->device->host->this_id) {\n\t\tnsp32_dbg(NSP32_DEBUG_QUEUECOMMAND, \"target==host???\");\n\t\tSCpnt->result = DID_BAD_TARGET << 16;\n\t\tdone(SCpnt);\n\t\treturn 0;\n\t}\n\n\t \n\tif (SCpnt->device->lun >= MAX_LUN) {\n\t\tnsp32_dbg(NSP32_DEBUG_QUEUECOMMAND, \"no more lun\");\n\t\tSCpnt->result = DID_BAD_TARGET << 16;\n\t\tdone(SCpnt);\n\t\treturn 0;\n\t}\n\n\tshow_command(SCpnt);\n\n\tdata->CurrentSC      = SCpnt;\n\tnsp32_priv(SCpnt)->status = SAM_STAT_CHECK_CONDITION;\n\tscsi_set_resid(SCpnt, scsi_bufflen(SCpnt));\n\n\t \n\tdata->msgout_len\t= 0;\n\tdata->msgin_len\t\t= 0;\n\tcur_lunt\t\t= &(data->lunt[SCpnt->device->id][SCpnt->device->lun]);\n\tcur_lunt->SCpnt\t\t= SCpnt;\n\tcur_lunt->save_datp\t= 0;\n\tcur_lunt->msgin03\t= FALSE;\n\tdata->cur_lunt\t\t= cur_lunt;\n\tdata->cur_id\t\t= SCpnt->device->id;\n\tdata->cur_lun\t\t= SCpnt->device->lun;\n\n\tret = nsp32_setup_sg_table(SCpnt);\n\tif (ret == FALSE) {\n\t\tnsp32_msg(KERN_ERR, \"SGT fail\");\n\t\tSCpnt->result = DID_ERROR << 16;\n\t\tnsp32_scsi_done(SCpnt);\n\t\treturn 0;\n\t}\n\n\t \n\tnsp32_build_identify(SCpnt);\n\n\t \n\ttarget = &data->target[scmd_id(SCpnt)];\n\tdata->cur_target = target;\n\n\tif (!(target->sync_flag & (SDTR_DONE | SDTR_INITIATOR | SDTR_TARGET))) {\n\t\tunsigned char period, offset;\n\n\t\tif (trans_mode != ASYNC_MODE) {\n\t\t\tnsp32_set_max_sync(data, target, &period, &offset);\n\t\t\tnsp32_build_sdtr(SCpnt, period, offset);\n\t\t\ttarget->sync_flag |= SDTR_INITIATOR;\n\t\t} else {\n\t\t\tnsp32_set_async(data, target);\n\t\t\ttarget->sync_flag |= SDTR_DONE;\n\t\t}\n\n\t\tnsp32_dbg(NSP32_DEBUG_QUEUECOMMAND,\n\t\t\t  \"SDTR: entry: %d start_period: 0x%x offset: 0x%x\\n\",\n\t\t\t  target->limit_entry, period, offset);\n\t} else if (target->sync_flag & SDTR_INITIATOR) {\n\t\t \n\t\tnsp32_set_async(data, target);\n\t\ttarget->sync_flag &= ~SDTR_INITIATOR;\n\t\ttarget->sync_flag |= SDTR_DONE;\n\n\t\tnsp32_dbg(NSP32_DEBUG_QUEUECOMMAND,\n\t\t\t  \"SDTR_INITIATOR: fall back to async\");\n\t} else if (target->sync_flag & SDTR_TARGET) {\n\t\t \n\t\tnsp32_set_async(data, target);\n\t\ttarget->sync_flag &= ~SDTR_TARGET;\n\t\ttarget->sync_flag |= SDTR_DONE;\n\n\t\tnsp32_dbg(NSP32_DEBUG_QUEUECOMMAND,\n\t\t\t  \"Unknown SDTR from target is reached, fall back to async.\");\n\t}\n\n\tnsp32_dbg(NSP32_DEBUG_TARGETFLAG,\n\t\t  \"target: %d sync_flag: 0x%x syncreg: 0x%x ackwidth: 0x%x\",\n\t\t  SCpnt->device->id, target->sync_flag, target->syncreg,\n\t\t  target->ackwidth);\n\n\t \n\tif (auto_param == 0) {\n\t\tret = nsp32_selection_autopara(SCpnt);\n\t} else {\n\t\tret = nsp32_selection_autoscsi(SCpnt);\n\t}\n\n\tif (ret != TRUE) {\n\t\tnsp32_dbg(NSP32_DEBUG_QUEUECOMMAND, \"selection fail\");\n\t\tnsp32_scsi_done(SCpnt);\n\t}\n\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(nsp32_queuecommand)\n\n \nstatic int nsp32hw_init(nsp32_hw_data *data)\n{\n\tunsigned int   base = data->BaseAddress;\n\tunsigned short irq_stat;\n\tunsigned long  lc_reg;\n\tunsigned char  power;\n\n\tlc_reg = nsp32_index_read4(base, CFG_LATE_CACHE);\n\tif ((lc_reg & 0xff00) == 0) {\n\t\tlc_reg |= (0x20 << 8);\n\t\tnsp32_index_write2(base, CFG_LATE_CACHE, lc_reg & 0xffff);\n\t}\n\n\tnsp32_write2(base, IRQ_CONTROL, IRQ_CONTROL_ALL_IRQ_MASK);\n\tnsp32_write2(base, TRANSFER_CONTROL, 0);\n\tnsp32_write4(base, BM_CNT, 0);\n\tnsp32_write2(base, SCSI_EXECUTE_PHASE, 0);\n\n\tdo {\n\t\tirq_stat = nsp32_read2(base, IRQ_STATUS);\n\t\tnsp32_dbg(NSP32_DEBUG_INIT, \"irq_stat 0x%x\", irq_stat);\n\t} while (irq_stat & IRQSTATUS_ANY_IRQ);\n\n\t \n\tif ((data->trans_method & NSP32_TRANSFER_PIO) ||\n\t    (data->trans_method & NSP32_TRANSFER_MMIO)) {\n\t\tnsp32_index_write1(base, FIFO_FULL_SHLD_COUNT,  0x40);\n\t\tnsp32_index_write1(base, FIFO_EMPTY_SHLD_COUNT, 0x40);\n\t} else if (data->trans_method & NSP32_TRANSFER_BUSMASTER) {\n\t\tnsp32_index_write1(base, FIFO_FULL_SHLD_COUNT,  0x10);\n\t\tnsp32_index_write1(base, FIFO_EMPTY_SHLD_COUNT, 0x60);\n\t} else {\n\t\tnsp32_dbg(NSP32_DEBUG_INIT, \"unknown transfer mode\");\n\t}\n\n\tnsp32_dbg(NSP32_DEBUG_INIT, \"full 0x%x emp 0x%x\",\n\t\t  nsp32_index_read1(base, FIFO_FULL_SHLD_COUNT),\n\t\t  nsp32_index_read1(base, FIFO_EMPTY_SHLD_COUNT));\n\n\tnsp32_index_write1(base, CLOCK_DIV, data->clock);\n\tnsp32_index_write1(base, BM_CYCLE,\n\t\t\t   MEMRD_CMD1 | SGT_AUTO_PARA_MEMED_CMD);\n\tnsp32_write1(base, PARITY_CONTROL, 0);\t \n\n\t \n\tnsp32_index_write2(base, MISC_WR,\n\t\t\t   (SCSI_DIRECTION_DETECTOR_SELECT |\n\t\t\t    DELAYED_BMSTART |\n\t\t\t    MASTER_TERMINATION_SELECT |\n\t\t\t    BMREQ_NEGATE_TIMING_SEL |\n\t\t\t    AUTOSEL_TIMING_SEL |\n\t\t\t    BMSTOP_CHANGE2_NONDATA_PHASE));\n\n\tnsp32_index_write1(base, TERM_PWR_CONTROL, 0);\n\tpower = nsp32_index_read1(base, TERM_PWR_CONTROL);\n\tif (!(power & SENSE)) {\n\t\tnsp32_msg(KERN_INFO, \"term power on\");\n\t\tnsp32_index_write1(base, TERM_PWR_CONTROL, BPWR);\n\t}\n\n\tnsp32_write2(base, TIMER_SET, TIMER_STOP);\n\tnsp32_write2(base, TIMER_SET, TIMER_STOP);  \n\n\tnsp32_write1(base, SYNC_REG,     0);\n\tnsp32_write1(base, ACK_WIDTH,    0);\n\tnsp32_write2(base, SEL_TIME_OUT, SEL_TIMEOUT_TIME);\n\n\t \n\tnsp32_index_write2(base, IRQ_SELECT,\n\t\t\t   IRQSELECT_TIMER_IRQ |\n\t\t\t   IRQSELECT_SCSIRESET_IRQ |\n\t\t\t   IRQSELECT_FIFO_SHLD_IRQ |\n\t\t\t   IRQSELECT_RESELECT_IRQ |\n\t\t\t   IRQSELECT_PHASE_CHANGE_IRQ |\n\t\t\t   IRQSELECT_AUTO_SCSI_SEQ_IRQ |\n\t\t\t   \n\t\t\t   IRQSELECT_TARGET_ABORT_IRQ |\n\t\t\t   IRQSELECT_MASTER_ABORT_IRQ );\n\tnsp32_write2(base, IRQ_CONTROL, 0);\n\n\t \n\tnsp32_index_write1(base, EXT_PORT_DDR, LED_OFF);\n\tnsp32_index_write1(base, EXT_PORT,     LED_OFF);\n\n\treturn TRUE;\n}\n\n\n \nstatic irqreturn_t do_nsp32_isr(int irq, void *dev_id)\n{\n\tnsp32_hw_data *data = dev_id;\n\tunsigned int base = data->BaseAddress;\n\tstruct scsi_cmnd *SCpnt = data->CurrentSC;\n\tunsigned short auto_stat, irq_stat, trans_stat;\n\tunsigned char busmon, busphase;\n\tunsigned long flags;\n\tint ret;\n\tint handled = 0;\n\tstruct Scsi_Host *host = data->Host;\n\n\tspin_lock_irqsave(host->host_lock, flags);\n\n\t \n\tirq_stat = nsp32_read2(base, IRQ_STATUS);\n\tnsp32_dbg(NSP32_DEBUG_INTR,\n\t\t  \"enter IRQ: %d, IRQstatus: 0x%x\", irq, irq_stat);\n\t \n\tif ((irq_stat & IRQSTATUS_ANY_IRQ) == 0) {\n\t\tnsp32_dbg(NSP32_DEBUG_INTR,\n\t\t\t  \"shared interrupt: irq other 0x%x\", irq_stat);\n\t\tgoto out2;\n\t}\n\thandled = 1;\n\tnsp32_write2(base, IRQ_CONTROL, IRQ_CONTROL_ALL_IRQ_MASK);\n\n\tbusmon = nsp32_read1(base, SCSI_BUS_MONITOR);\n\tbusphase = busmon & BUSMON_PHASE_MASK;\n\n\ttrans_stat = nsp32_read2(base, TRANSFER_STATUS);\n\tif ((irq_stat == 0xffff) && (trans_stat == 0xffff)) {\n\t\tnsp32_msg(KERN_INFO, \"card disconnect\");\n\t\tif (data->CurrentSC != NULL) {\n\t\t\tnsp32_msg(KERN_INFO, \"clean up current SCSI command\");\n\t\t\tSCpnt->result = DID_BAD_TARGET << 16;\n\t\t\tnsp32_scsi_done(SCpnt);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tif (irq_stat & IRQSTATUS_TIMER_IRQ) {\n\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"timer stop\");\n\t\tnsp32_write2(base, TIMER_SET, TIMER_STOP);\n\t\tgoto out;\n\t}\n\n\t \n\tif (irq_stat & IRQSTATUS_SCSIRESET_IRQ) {\n\t\tnsp32_msg(KERN_INFO, \"detected someone do bus reset\");\n\t\tnsp32_do_bus_reset(data);\n\t\tif (SCpnt != NULL) {\n\t\t\tSCpnt->result = DID_RESET << 16;\n\t\t\tnsp32_scsi_done(SCpnt);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (SCpnt == NULL) {\n\t\tnsp32_msg(KERN_WARNING, \"SCpnt==NULL this can't be happened\");\n\t\tnsp32_msg(KERN_WARNING, \"irq_stat=0x%x trans_stat=0x%x\",\n\t\t\t  irq_stat, trans_stat);\n\t\tgoto out;\n\t}\n\n\t \n\tif(irq_stat & IRQSTATUS_AUTOSCSI_IRQ) {\n\t\t \n\t\tauto_stat = nsp32_read2(base, SCSI_EXECUTE_PHASE);\n\t\tnsp32_write2(base, SCSI_EXECUTE_PHASE, 0);\n\n\t\t \n\t\tif (auto_stat & SELECTION_TIMEOUT) {\n\t\t\tnsp32_dbg(NSP32_DEBUG_INTR,\n\t\t\t\t  \"selection timeout occurred\");\n\n\t\t\tSCpnt->result = DID_TIME_OUT << 16;\n\t\t\tnsp32_scsi_done(SCpnt);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (auto_stat & MSGOUT_PHASE) {\n\t\t\t \n\t\t\tif (!(auto_stat & MSG_IN_OCCUER) &&\n\t\t\t     (data->msgout_len <= 3)) {\n\t\t\t\t \n\t\t\t\tdata->msgout_len = 0;\n\t\t\t}\n\n\t\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"MsgOut phase processed\");\n\t\t}\n\n\t\tif ((auto_stat & DATA_IN_PHASE) &&\n\t\t    (scsi_get_resid(SCpnt) > 0) &&\n\t\t    ((nsp32_read2(base, FIFO_REST_CNT) & FIFO_REST_MASK) != 0)) {\n\t\t\tprintk( \"auto+fifo\\n\");\n\t\t\t\n\t\t}\n\n\t\tif (auto_stat & (DATA_IN_PHASE | DATA_OUT_PHASE)) {\n\t\t\t \n\t\t\tnsp32_dbg(NSP32_DEBUG_INTR,\n\t\t\t\t  \"Data in/out phase processed\");\n\n\t\t\t \n\t\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"BMCNT=0x%lx\",\n\t\t\t\t    nsp32_read4(base, BM_CNT));\n\t\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"addr=0x%lx\",\n\t\t\t\t    nsp32_read4(base, SGT_ADR));\n\t\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"SACK=0x%lx\",\n\t\t\t\t    nsp32_read4(base, SACK_CNT));\n\t\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"SSACK=0x%lx\",\n\t\t\t\t    nsp32_read4(base, SAVED_SACK_CNT));\n\n\t\t\tscsi_set_resid(SCpnt, 0);  \n\t\t}\n\n\t\t \n\t\tif (auto_stat & MSG_IN_OCCUER) {\n\t\t\tnsp32_msgin_occur(SCpnt, irq_stat, auto_stat);\n\t\t}\n\n\t\t \n\t\tif (auto_stat & MSG_OUT_OCCUER) {\n\t\t\tnsp32_msgout_occur(SCpnt);\n\t\t}\n\n\t\t \n\t\tif (auto_stat & BUS_FREE_OCCUER) {\n\t\t\tret = nsp32_busfree_occur(SCpnt, auto_stat);\n\t\t\tif (ret == TRUE) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (auto_stat & STATUS_PHASE) {\n\t\t\t \n\t\t\tSCpnt->result =\t(int)nsp32_read1(base, SCSI_CSB_IN);\n\t\t}\n\n\t\tif (auto_stat & ILLEGAL_PHASE) {\n\t\t\t \n\t\t\tnsp32_msg(KERN_WARNING,\n\t\t\t\t  \"AUTO SCSI ILLEGAL PHASE OCCUR!!!!\");\n\n\t\t\t \n\n\t\t\t \n\t\t\tnsp32_sack_assert(data);\n\t\t\tnsp32_wait_req(data, NEGATE);\n\t\t\tnsp32_sack_negate(data);\n\n\t\t}\n\n\t\tif (auto_stat & COMMAND_PHASE) {\n\t\t\t \n\t\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"Command phase processed\");\n\t\t}\n\n\t\tif (auto_stat & AUTOSCSI_BUSY) {\n\t\t\t \n\t\t}\n\n\t\tshow_autophase(auto_stat);\n\t}\n\n\t \n\tif (irq_stat & IRQSTATUS_FIFO_SHLD_IRQ) {\n\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"FIFO IRQ\");\n\n\t\tswitch(busphase) {\n\t\tcase BUSPHASE_DATA_OUT:\n\t\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"fifo/write\");\n\n\t\t\t \n\n\t\t\tbreak;\n\n\t\tcase BUSPHASE_DATA_IN:\n\t\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"fifo/read\");\n\n\t\t\t \n\n\t\t\tbreak;\n\n\t\tcase BUSPHASE_STATUS:\n\t\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"fifo/status\");\n\n\t\t\tnsp32_priv(SCpnt)->status = nsp32_read1(base, SCSI_CSB_IN);\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"fifo/other phase\");\n\t\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"irq_stat=0x%x trans_stat=0x%x\",\n\t\t\t\t  irq_stat, trans_stat);\n\t\t\tshow_busphase(busphase);\n\t\t\tbreak;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t \n\tif (irq_stat & IRQSTATUS_PHASE_CHANGE_IRQ) {\n\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"phase change IRQ\");\n\n\t\tswitch(busphase) {\n\t\tcase BUSPHASE_MESSAGE_IN:\n\t\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"phase chg/msg in\");\n\t\t\tnsp32_msgin_occur(SCpnt, irq_stat, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnsp32_msg(KERN_WARNING, \"phase chg/other phase?\");\n\t\t\tnsp32_msg(KERN_WARNING, \"irq_stat=0x%x trans_stat=0x%x\\n\",\n\t\t\t\t  irq_stat, trans_stat);\n\t\t\tshow_busphase(busphase);\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tif (irq_stat & IRQSTATUS_PCI_IRQ) {\n\t\tnsp32_dbg(NSP32_DEBUG_INTR, \"PCI IRQ occurred\");\n\t\t \n\t}\n\n\t \n\tif (irq_stat & IRQSTATUS_BMCNTERR_IRQ) {\n\t\tnsp32_msg(KERN_ERR, \"Received unexpected BMCNTERR IRQ! \");\n\t\t \n\t}\n\n#if 0\n\tnsp32_dbg(NSP32_DEBUG_INTR,\n\t\t  \"irq_stat=0x%x trans_stat=0x%x\", irq_stat, trans_stat);\n\tshow_busphase(busphase);\n#endif\n\n out:\n\t \n\tnsp32_write2(base, IRQ_CONTROL, 0);\n\n out2:\n\tspin_unlock_irqrestore(host->host_lock, flags);\n\n\tnsp32_dbg(NSP32_DEBUG_INTR, \"exit\");\n\n\treturn IRQ_RETVAL(handled);\n}\n\n\nstatic int nsp32_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tunsigned long     flags;\n\tnsp32_hw_data    *data;\n\tint\t\t  hostno;\n\tunsigned int      base;\n\tunsigned char     mode_reg;\n\tint\t\t  id, speed;\n\tlong\t\t  model;\n\n\thostno = host->host_no;\n\tdata = (nsp32_hw_data *)host->hostdata;\n\tbase = host->io_port;\n\n\tseq_puts(m, \"NinjaSCSI-32 status\\n\\n\");\n\tseq_printf(m, \"Driver version:        %s, $Revision: 1.33 $\\n\",\n\t\t   nsp32_release_version);\n\tseq_printf(m, \"SCSI host No.:         %d\\n\", hostno);\n\tseq_printf(m, \"IRQ:                   %d\\n\", host->irq);\n\tseq_printf(m, \"IO:                    0x%lx-0x%lx\\n\",\n\t\t   host->io_port, host->io_port + host->n_io_port - 1);\n\tseq_printf(m, \"MMIO(virtual address): 0x%lx-0x%lx\\n\",\n\t\t   host->base, host->base + data->MmioLength - 1);\n\tseq_printf(m, \"sg_tablesize:          %d\\n\",\n\t\t   host->sg_tablesize);\n\tseq_printf(m, \"Chip revision:         0x%x\\n\",\n\t\t   (nsp32_read2(base, INDEX_REG) >> 8) & 0xff);\n\n\tmode_reg = nsp32_index_read1(base, CHIP_MODE);\n\tmodel    = data->pci_devid->driver_data;\n\n#ifdef CONFIG_PM\n\tseq_printf(m, \"Power Management:      %s\\n\",\n\t\t   (mode_reg & OPTF) ? \"yes\" : \"no\");\n#endif\n\tseq_printf(m, \"OEM:                   %ld, %s\\n\",\n\t\t   (mode_reg & (OEM0|OEM1)), nsp32_model[model]);\n\n\tspin_lock_irqsave(&(data->Lock), flags);\n\tseq_printf(m, \"CurrentSC:             0x%p\\n\\n\",      data->CurrentSC);\n\tspin_unlock_irqrestore(&(data->Lock), flags);\n\n\n\tseq_puts(m, \"SDTR status\\n\");\n\tfor (id = 0; id < ARRAY_SIZE(data->target); id++) {\n\n\t\tseq_printf(m, \"id %d: \", id);\n\n\t\tif (id == host->this_id) {\n\t\t\tseq_puts(m, \"----- NinjaSCSI-32 host adapter\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (data->target[id].sync_flag == SDTR_DONE) {\n\t\t\tif (data->target[id].period == 0 &&\n\t\t\t    data->target[id].offset == ASYNC_OFFSET ) {\n\t\t\t\tseq_puts(m, \"async\");\n\t\t\t} else {\n\t\t\t\tseq_puts(m, \" sync\");\n\t\t\t}\n\t\t} else {\n\t\t\tseq_puts(m, \" none\");\n\t\t}\n\n\t\tif (data->target[id].period != 0) {\n\n\t\t\tspeed = 1000000 / (data->target[id].period * 4);\n\n\t\t\tseq_printf(m, \" transfer %d.%dMB/s, offset %d\",\n\t\t\t\tspeed / 1000,\n\t\t\t\tspeed % 1000,\n\t\t\t\tdata->target[id].offset\n\t\t\t\t);\n\t\t}\n\t\tseq_putc(m, '\\n');\n\t}\n\treturn 0;\n}\n\n\n\n \nstatic void nsp32_scsi_done(struct scsi_cmnd *SCpnt)\n{\n\tnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tunsigned int   base = SCpnt->device->host->io_port;\n\n\tscsi_dma_unmap(SCpnt);\n\n\t \n\tnsp32_write2(base, TRANSFER_CONTROL, 0);\n\tnsp32_write4(base, BM_CNT, 0);\n\n\t \n\tscsi_done(SCpnt);\n\n\t \n\tdata->cur_lunt->SCpnt\t= NULL;\n\tdata->cur_lunt\t\t= NULL;\n\tdata->cur_target\t= NULL;\n\tdata->CurrentSC\t\t= NULL;\n}\n\n\n \nstatic int nsp32_busfree_occur(struct scsi_cmnd *SCpnt, unsigned short execph)\n{\n\tnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tunsigned int base   = SCpnt->device->host->io_port;\n\n\tnsp32_dbg(NSP32_DEBUG_BUSFREE, \"enter execph=0x%x\", execph);\n\tshow_autophase(execph);\n\n\tnsp32_write4(base, BM_CNT, 0);\n\tnsp32_write2(base, TRANSFER_CONTROL, 0);\n\n\t \n\tif (execph & MSGIN_02_VALID) {\n\t\tnsp32_dbg(NSP32_DEBUG_BUSFREE, \"MsgIn02_Valid\");\n\n\t\t \n\t\tif (!(execph & MSGIN_00_VALID) &&\n\t\t    ((execph & DATA_IN_PHASE) || (execph & DATA_OUT_PHASE))) {\n\t\t\tunsigned int sacklen, s_sacklen;\n\n\t\t\t \n\t\t\tsacklen   = nsp32_read4(base, SACK_CNT      );\n\t\t\ts_sacklen = nsp32_read4(base, SAVED_SACK_CNT);\n\n\t\t\t \n\t\t\tif (s_sacklen > 0) {\n\t\t\t\t \n\t\t\t\tif (sacklen != s_sacklen) {\n\t\t\t\t\tdata->cur_lunt->msgin03 = FALSE;\n\t\t\t\t} else {\n\t\t\t\t\tdata->cur_lunt->msgin03 = TRUE;\n\t\t\t\t}\n\n\t\t\t\tnsp32_adjust_busfree(SCpnt, s_sacklen);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\t \n\t} else {\n\t\t \n\t}\n\n\tif (execph & MSGIN_03_VALID) {\n\t\t \n\t}\n\n\t \n\tif (data->cur_target->sync_flag & SDTR_INITIATOR) {\n\t\t \n\t\tnsp32_set_async(data, data->cur_target);\n\t\tdata->cur_target->sync_flag &= ~SDTR_INITIATOR;\n\t\tdata->cur_target->sync_flag |= SDTR_DONE;\n\t} else if (data->cur_target->sync_flag & SDTR_TARGET) {\n\t\t \n\t\tif (execph & (MSGIN_00_VALID | MSGIN_04_VALID)) {\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tnsp32_set_async(data, data->cur_target);\n\t\t}\n\t\tdata->cur_target->sync_flag &= ~SDTR_TARGET;\n\t\tdata->cur_target->sync_flag |= SDTR_DONE;\n\t}\n\n\t \n\tif (execph & MSGIN_00_VALID) {\n\t\t \n\t\tnsp32_dbg(NSP32_DEBUG_BUSFREE, \"command complete\");\n\n\t\tnsp32_priv(SCpnt)->status  = nsp32_read1(base, SCSI_CSB_IN);\n\t\tnsp32_dbg(NSP32_DEBUG_BUSFREE,\n\t\t\t  \"normal end stat=0x%x resid=0x%x\\n\",\n\t\t\t  nsp32_priv(SCpnt)->status, scsi_get_resid(SCpnt));\n\t\tSCpnt->result = (DID_OK << 16) |\n\t\t\t(nsp32_priv(SCpnt)->status << 0);\n\t\tnsp32_scsi_done(SCpnt);\n\t\t \n\t\treturn TRUE;\n\t} else if (execph & MSGIN_04_VALID) {\n\t\t \n\t\tnsp32_priv(SCpnt)->status = nsp32_read1(base, SCSI_CSB_IN);\n\n\t\tnsp32_dbg(NSP32_DEBUG_BUSFREE, \"disconnect\");\n\t\treturn TRUE;\n\t} else {\n\t\t \n\t\tnsp32_msg(KERN_WARNING, \"unexpected bus free occurred\");\n\n\t\tSCpnt->result = DID_ERROR << 16;\n\t\tnsp32_scsi_done(SCpnt);\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\n\n \nstatic void nsp32_adjust_busfree(struct scsi_cmnd *SCpnt, unsigned int s_sacklen)\n{\n\tnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tint old_entry = data->cur_entry;\n\tint new_entry;\n\tint sg_num = data->cur_lunt->sg_num;\n\tnsp32_sgtable *sgt = data->cur_lunt->sglun->sgt;\n\tunsigned int restlen, sentlen;\n\tu32_le len, addr;\n\n\tnsp32_dbg(NSP32_DEBUG_SGLIST, \"old resid=0x%x\", scsi_get_resid(SCpnt));\n\n\t \n\ts_sacklen -= le32_to_cpu(sgt[old_entry].addr) & 3;\n\n\t \n\tsentlen = 0;\n\tfor (new_entry = old_entry; new_entry < sg_num; new_entry++) {\n\t\tsentlen += (le32_to_cpu(sgt[new_entry].len) & ~SGTEND);\n\t\tif (sentlen > s_sacklen) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (new_entry == sg_num) {\n\t\tgoto last;\n\t}\n\n\tif (sentlen == s_sacklen) {\n\t\t \n\t\t \n\t}\n\n\t \n\trestlen = sentlen - s_sacklen;\n\n\t \n\tlen  = le32_to_cpu(sgt[new_entry].len);\n\taddr = le32_to_cpu(sgt[new_entry].addr);\n\taddr += (len - restlen);\n\tsgt[new_entry].addr = cpu_to_le32(addr);\n\tsgt[new_entry].len  = cpu_to_le32(restlen);\n\n\t \n\tdata->cur_entry = new_entry;\n\n\treturn;\n\n last:\n\tif (scsi_get_resid(SCpnt) < sentlen) {\n\t\tnsp32_msg(KERN_ERR, \"resid underflow\");\n\t}\n\n\tscsi_set_resid(SCpnt, scsi_get_resid(SCpnt) - sentlen);\n\tnsp32_dbg(NSP32_DEBUG_SGLIST, \"new resid=0x%x\", scsi_get_resid(SCpnt));\n\n\t \n\n\treturn;\n}\n\n\n \nstatic void nsp32_msgout_occur(struct scsi_cmnd *SCpnt)\n{\n\tnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tunsigned int base   = SCpnt->device->host->io_port;\n\tint i;\n\n\tnsp32_dbg(NSP32_DEBUG_MSGOUTOCCUR,\n\t\t  \"enter: msgout_len: 0x%x\", data->msgout_len);\n\n\t \n\tif (data->msgout_len == 0) {\n\t\tnsp32_build_nop(SCpnt);\n\t}\n\n\t \n\tfor (i = 0; i < data->msgout_len; i++) {\n\t\tnsp32_dbg(NSP32_DEBUG_MSGOUTOCCUR,\n\t\t\t  \"%d : 0x%x\", i, data->msgoutbuf[i]);\n\n\t\t \n\t\tnsp32_wait_req(data, ASSERT);\n\n\t\tif (i == (data->msgout_len - 1)) {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tnsp32_write2(base, COMMAND_CONTROL,\n\t\t\t\t\t (CLEAR_CDB_FIFO_POINTER |\n\t\t\t\t\t  AUTO_COMMAND_PHASE |\n\t\t\t\t\t  AUTOSCSI_RESTART |\n\t\t\t\t\t  AUTO_MSGIN_00_OR_04 |\n\t\t\t\t\t  AUTO_MSGIN_02 ));\n\t\t}\n\t\t \n\t\tnsp32_write1(base, SCSI_DATA_WITH_ACK, data->msgoutbuf[i]);\n\t\tnsp32_wait_sack(data, NEGATE);\n\n\t\tnsp32_dbg(NSP32_DEBUG_MSGOUTOCCUR, \"bus: 0x%x\\n\",\n\t\t\t  nsp32_read1(base, SCSI_BUS_MONITOR));\n\t}\n\n\tdata->msgout_len = 0;\n\n\tnsp32_dbg(NSP32_DEBUG_MSGOUTOCCUR, \"exit\");\n}\n\n \nstatic void nsp32_restart_autoscsi(struct scsi_cmnd *SCpnt, unsigned short command)\n{\n\tnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tunsigned int   base = data->BaseAddress;\n\tunsigned short transfer = 0;\n\n\tnsp32_dbg(NSP32_DEBUG_RESTART, \"enter\");\n\n\tif (data->cur_target == NULL || data->cur_lunt == NULL) {\n\t\tnsp32_msg(KERN_ERR, \"Target or Lun is invalid\");\n\t}\n\n\t \n\tnsp32_write1(base, SYNC_REG, data->cur_target->syncreg);\n\n\t \n\tnsp32_write1(base, ACK_WIDTH, data->cur_target->ackwidth);\n\n\t \n\tnsp32_write1(base, SREQ_SMPL_RATE, data->cur_target->sample_reg);\n\n\t \n\tnsp32_write4(base, SGT_ADR, data->cur_lunt->sglun_paddr);\n\n\t \n\ttransfer = 0;\n\ttransfer |= (TRANSFER_GO | ALL_COUNTER_CLR);\n\tif (data->trans_method & NSP32_TRANSFER_BUSMASTER) {\n\t\tif (scsi_bufflen(SCpnt) > 0) {\n\t\t\ttransfer |= BM_START;\n\t\t}\n\t} else if (data->trans_method & NSP32_TRANSFER_MMIO) {\n\t\ttransfer |= CB_MMIO_MODE;\n\t} else if (data->trans_method & NSP32_TRANSFER_PIO) {\n\t\ttransfer |= CB_IO_MODE;\n\t}\n\tnsp32_write2(base, TRANSFER_CONTROL, transfer);\n\n\t \n\tcommand |= (CLEAR_CDB_FIFO_POINTER |\n\t\t    AUTO_COMMAND_PHASE     |\n\t\t    AUTOSCSI_RESTART       );\n\tnsp32_write2(base, COMMAND_CONTROL, command);\n\n\tnsp32_dbg(NSP32_DEBUG_RESTART, \"exit\");\n}\n\n\n \nstatic void nsp32_msgin_occur(struct scsi_cmnd     *SCpnt,\n\t\t\t      unsigned long  irq_status,\n\t\t\t      unsigned short execph)\n{\n\tnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tunsigned int   base = SCpnt->device->host->io_port;\n\tunsigned char  msg;\n\tunsigned char  msgtype;\n\tunsigned char  newlun;\n\tunsigned short command  = 0;\n\tint\t       msgclear = TRUE;\n\tlong\t       new_sgtp;\n\tint\t       ret;\n\n\t \n\tmsg = nsp32_read1(base, SCSI_DATA_IN);\n\tdata->msginbuf[(unsigned char)data->msgin_len] = msg;\n\tmsgtype = data->msginbuf[0];\n\tnsp32_dbg(NSP32_DEBUG_MSGINOCCUR,\n\t\t  \"enter: msglen: 0x%x msgin: 0x%x msgtype: 0x%x\",\n\t\t  data->msgin_len, msg, msgtype);\n\n\t \n\n\t \n\tnsp32_sack_assert(data);\n\n\t \n\tif (msgtype & 0x80) {\n\t\tif (!(irq_status & IRQSTATUS_RESELECT_OCCUER)) {\n\t\t\t \n\t\t\tgoto reject;\n\t\t}\n\n\t\tnewlun = msgtype & 0x1f;  \n\t\tret = nsp32_reselection(SCpnt, newlun);\n\t\tif (ret == TRUE) {\n\t\t\tgoto restart;\n\t\t} else {\n\t\t\tgoto reject;\n\t\t}\n\t}\n\n\t \n\tswitch (msgtype) {\n\t \n\tcase COMMAND_COMPLETE:\n\tcase DISCONNECT:\n\t\t \n\t\tnsp32_msg(KERN_WARNING,\n\t\t\t   \"unexpected message of AutoSCSI MsgIn: 0x%x\", msg);\n\t\tbreak;\n\n\tcase RESTORE_POINTERS:\n\t\t \n\n\t\tif ((execph & DATA_IN_PHASE) || (execph & DATA_OUT_PHASE)) {\n\t\t\tunsigned int s_sacklen;\n\n\t\t\ts_sacklen = nsp32_read4(base, SAVED_SACK_CNT);\n\t\t\tif ((execph & MSGIN_02_VALID) && (s_sacklen > 0)) {\n\t\t\t\tnsp32_adjust_busfree(SCpnt, s_sacklen);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t}\n\t\t}\n\t\tdata->cur_lunt->msgin03 = FALSE;\n\n\t\t \n\n\t\t \n\t\tnsp32_write4(base, CLR_COUNTER, CLRCOUNTER_ALLMASK);\n\n\t\t \n\t\tnew_sgtp = data->cur_lunt->sglun_paddr +\n\t\t\t(data->cur_lunt->cur_entry * sizeof(nsp32_sgtable));\n\t\tnsp32_write4(base, SGT_ADR, new_sgtp);\n\n\t\tbreak;\n\n\tcase SAVE_POINTERS:\n\t\t \n\t\tnsp32_msg (KERN_WARNING,\n\t\t\t   \"unexpected message of AutoSCSI MsgIn: SAVE_POINTERS\");\n\n\t\tbreak;\n\n\tcase MESSAGE_REJECT:\n\t\t \n\t\tif (data->cur_target->sync_flag &\n\t\t\t\t(SDTR_INITIATOR | SDTR_TARGET)) {\n\t\t\t \n\t\t\tnsp32_set_async(data, data->cur_target);\n\t\t\tdata->cur_target->sync_flag &= ~SDTR_INITIATOR;\n\t\t\tdata->cur_target->sync_flag |= SDTR_DONE;\n\n\t\t}\n\t\tbreak;\n\n\tcase LINKED_CMD_COMPLETE:\n\tcase LINKED_FLG_CMD_COMPLETE:\n\t\t \n\t\tnsp32_msg (KERN_WARNING,\n\t\t\t   \"unsupported message: 0x%x\", msgtype);\n\t\tbreak;\n\n\tcase INITIATE_RECOVERY:\n\t\t \n\t\t \n\n\t\tgoto reject;\n\n\t \n\tcase SIMPLE_QUEUE_TAG:\n\tcase 0x23:\n\t\t \n\t\tif (data->msgin_len >= 1) {\n\t\t\tgoto reject;\n\t\t}\n\n\t\t \n\t\tmsgclear = FALSE;\n\n\t\tbreak;\n\n\t \n\tcase EXTENDED_MESSAGE:\n\t\tif (data->msgin_len < 1) {\n\t\t\t \n\t\t\tmsgclear = FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((data->msginbuf[1] + 1) > data->msgin_len) {\n\t\t\t \n\t\t\tmsgclear = FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tswitch (data->msginbuf[2]) {\n\t\tcase EXTENDED_MODIFY_DATA_POINTER:\n\t\t\t \n\t\t\tgoto reject;  \n\t\t\tbreak;\n\n\t\tcase EXTENDED_SDTR:\n\t\t\t \n\t\t\tif (data->msgin_len != EXTENDED_SDTR_LEN + 1) {\n\t\t\t\t \n\t\t\t\tgoto reject;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnsp32_analyze_sdtr(SCpnt);\n\n\t\t\tbreak;\n\n\t\tcase EXTENDED_EXTENDED_IDENTIFY:\n\t\t\t \n\t\t\tgoto reject;  \n\n\t\t\tbreak;\n\n\t\tcase EXTENDED_WDTR:\n\t\t\tgoto reject;  \n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto reject;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tgoto reject;\n\t}\n\n restart:\n\tif (msgclear == TRUE) {\n\t\tdata->msgin_len = 0;\n\n\t\t \n\t\tif (data->msgout_len > 0) {\n\t\t\tnsp32_write4(base, SCSI_MSG_OUT, 0);\n\t\t\tcommand |= AUTO_ATN;\n\t\t}\n\n\t\t \n\t\tcommand |= (AUTO_MSGIN_00_OR_04 | AUTO_MSGIN_02);\n\n\t\t \n\t\tif (data->cur_lunt->msgin03 == TRUE) {\n\t\t\tcommand |= AUTO_MSGIN_03;\n\t\t}\n\t\tdata->cur_lunt->msgin03 = FALSE;\n\t} else {\n\t\tdata->msgin_len++;\n\t}\n\n\t \n\tnsp32_restart_autoscsi(SCpnt, command);\n\n\t \n\tnsp32_wait_req(data, NEGATE);\n\n\t \n\tnsp32_sack_negate(data);\n\n\tnsp32_dbg(NSP32_DEBUG_MSGINOCCUR, \"exit\");\n\n\treturn;\n\n reject:\n\tnsp32_msg(KERN_WARNING,\n\t\t  \"invalid or unsupported MessageIn, rejected. \"\n\t\t  \"current msg: 0x%x (len: 0x%x), processing msg: 0x%x\",\n\t\t  msg, data->msgin_len, msgtype);\n\tnsp32_build_reject(SCpnt);\n\tdata->msgin_len = 0;\n\n\tgoto restart;\n}\n\n \nstatic void nsp32_analyze_sdtr(struct scsi_cmnd *SCpnt)\n{\n\tnsp32_hw_data   *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tnsp32_target    *target     = data->cur_target;\n\tunsigned char    get_period = data->msginbuf[3];\n\tunsigned char    get_offset = data->msginbuf[4];\n\tint\t\t entry;\n\n\tnsp32_dbg(NSP32_DEBUG_MSGINOCCUR, \"enter\");\n\n\t \n\tif (target->sync_flag & SDTR_INITIATOR) {\n\t\t \n\t\tnsp32_dbg(NSP32_DEBUG_MSGINOCCUR, \"target responds SDTR\");\n\n\t\ttarget->sync_flag &= ~SDTR_INITIATOR;\n\t\ttarget->sync_flag |= SDTR_DONE;\n\n\t\t \n\t\tif (get_offset > SYNC_OFFSET) {\n\t\t\t \n\t\t\tgoto reject;\n\t\t}\n\n\t\tif (get_offset == ASYNC_OFFSET) {\n\t\t\t \n\t\t\tgoto async;\n\t\t}\n\n\t\t \n\t\tif (get_period < data->synct[0].period_num) {\n\t\t\t \n\t\t\tgoto reject;\n\t\t}\n\n\t\tentry = nsp32_search_period_entry(data, target, get_period);\n\n\t\tif (entry < 0) {\n\t\t\t \n\t\t\tgoto reject;\n\t\t}\n\n\t\t \n\t\tnsp32_set_sync_entry(data, target, entry, get_offset);\n\t} else {\n\t\t \n\t\tnsp32_dbg(NSP32_DEBUG_MSGINOCCUR, \"target send SDTR\");\n\n\t\ttarget->sync_flag |= SDTR_INITIATOR;\n\n\t\t \n\t\tif (get_offset > SYNC_OFFSET) {\n\t\t\t \n\t\t\tget_offset = SYNC_OFFSET;\n\t\t}\n\n\t\t \n\t\tif (get_period < data->synct[0].period_num) {\n\t\t\tget_period = data->synct[0].period_num;\n\t\t}\n\n\t\tentry = nsp32_search_period_entry(data, target, get_period);\n\n\t\tif (get_offset == ASYNC_OFFSET || entry < 0) {\n\t\t\tnsp32_set_async(data, target);\n\t\t\tnsp32_build_sdtr(SCpnt, 0, ASYNC_OFFSET);\n\t\t} else {\n\t\t\tnsp32_set_sync_entry(data, target, entry, get_offset);\n\t\t\tnsp32_build_sdtr(SCpnt, get_period, get_offset);\n\t\t}\n\t}\n\n\ttarget->period = get_period;\n\tnsp32_dbg(NSP32_DEBUG_MSGINOCCUR, \"exit\");\n\treturn;\n\n reject:\n\t \n\tnsp32_build_reject(SCpnt);\n\n async:\n\tnsp32_set_async(data, target);\t \n\n\ttarget->period = 0;\n\tnsp32_dbg(NSP32_DEBUG_MSGINOCCUR, \"exit: set async\");\n\treturn;\n}\n\n\n \nstatic int nsp32_search_period_entry(nsp32_hw_data *data,\n\t\t\t\t     nsp32_target  *target,\n\t\t\t\t     unsigned char  period)\n{\n\tint i;\n\n\tif (target->limit_entry >= data->syncnum) {\n\t\tnsp32_msg(KERN_ERR, \"limit_entry exceeds syncnum!\");\n\t\ttarget->limit_entry = 0;\n\t}\n\n\tfor (i = target->limit_entry; i < data->syncnum; i++) {\n\t\tif (period >= data->synct[i].start_period &&\n\t\t    period <= data->synct[i].end_period) {\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (i == data->syncnum) {\n\t\ti = -1;\n\t}\n\n\treturn i;\n}\n\n\n \nstatic void nsp32_set_async(nsp32_hw_data *data, nsp32_target *target)\n{\n\tunsigned char period = data->synct[target->limit_entry].period_num;\n\n\ttarget->offset     = ASYNC_OFFSET;\n\ttarget->period     = 0;\n\ttarget->syncreg    = TO_SYNCREG(period, ASYNC_OFFSET);\n\ttarget->ackwidth   = 0;\n\ttarget->sample_reg = 0;\n\n\tnsp32_dbg(NSP32_DEBUG_SYNC, \"set async\");\n}\n\n\n \nstatic void nsp32_set_max_sync(nsp32_hw_data *data,\n\t\t\t       nsp32_target  *target,\n\t\t\t       unsigned char *period,\n\t\t\t       unsigned char *offset)\n{\n\tunsigned char period_num, ackwidth;\n\n\tperiod_num = data->synct[target->limit_entry].period_num;\n\t*period    = data->synct[target->limit_entry].start_period;\n\tackwidth   = data->synct[target->limit_entry].ackwidth;\n\t*offset    = SYNC_OFFSET;\n\n\ttarget->syncreg    = TO_SYNCREG(period_num, *offset);\n\ttarget->ackwidth   = ackwidth;\n\ttarget->offset     = *offset;\n\ttarget->sample_reg = 0;        \n}\n\n\n \nstatic void nsp32_set_sync_entry(nsp32_hw_data *data,\n\t\t\t\t nsp32_target  *target,\n\t\t\t\t int\t\tentry,\n\t\t\t\t unsigned char  offset)\n{\n\tunsigned char period, ackwidth, sample_rate;\n\n\tperiod      = data->synct[entry].period_num;\n\tackwidth    = data->synct[entry].ackwidth;\n\tsample_rate = data->synct[entry].sample_rate;\n\n\ttarget->syncreg    = TO_SYNCREG(period, offset);\n\ttarget->ackwidth   = ackwidth;\n\ttarget->offset     = offset;\n\ttarget->sample_reg = sample_rate | SAMPLING_ENABLE;\n\n\tnsp32_dbg(NSP32_DEBUG_SYNC, \"set sync\");\n}\n\n\n \nstatic void nsp32_wait_req(nsp32_hw_data *data, int state)\n{\n\tunsigned int  base      = data->BaseAddress;\n\tint\t      wait_time = 0;\n\tunsigned char bus, req_bit;\n\n\tif (!((state == ASSERT) || (state == NEGATE))) {\n\t\tnsp32_msg(KERN_ERR, \"unknown state designation\");\n\t}\n\t \n\treq_bit = (state == ASSERT ? BUSMON_REQ : 0);\n\n\tdo {\n\t\tbus = nsp32_read1(base, SCSI_BUS_MONITOR);\n\t\tif ((bus & BUSMON_REQ) == req_bit) {\n\t\t\tnsp32_dbg(NSP32_DEBUG_WAIT,\n\t\t\t\t  \"wait_time: %d\", wait_time);\n\t\t\treturn;\n\t\t}\n\t\tudelay(1);\n\t\twait_time++;\n\t} while (wait_time < REQSACK_TIMEOUT_TIME);\n\n\tnsp32_msg(KERN_WARNING, \"wait REQ timeout, req_bit: 0x%x\", req_bit);\n}\n\n \nstatic void nsp32_wait_sack(nsp32_hw_data *data, int state)\n{\n\tunsigned int  base      = data->BaseAddress;\n\tint\t      wait_time = 0;\n\tunsigned char bus, ack_bit;\n\n\tif (!((state == ASSERT) || (state == NEGATE))) {\n\t\tnsp32_msg(KERN_ERR, \"unknown state designation\");\n\t}\n\t \n\tack_bit = (state == ASSERT ? BUSMON_ACK : 0);\n\n\tdo {\n\t\tbus = nsp32_read1(base, SCSI_BUS_MONITOR);\n\t\tif ((bus & BUSMON_ACK) == ack_bit) {\n\t\t\tnsp32_dbg(NSP32_DEBUG_WAIT,\n\t\t\t\t  \"wait_time: %d\", wait_time);\n\t\t\treturn;\n\t\t}\n\t\tudelay(1);\n\t\twait_time++;\n\t} while (wait_time < REQSACK_TIMEOUT_TIME);\n\n\tnsp32_msg(KERN_WARNING, \"wait SACK timeout, ack_bit: 0x%x\", ack_bit);\n}\n\n \nstatic void nsp32_sack_assert(nsp32_hw_data *data)\n{\n\tunsigned int  base = data->BaseAddress;\n\tunsigned char busctrl;\n\n\tbusctrl  = nsp32_read1(base, SCSI_BUS_CONTROL);\n\tbusctrl\t|= (BUSCTL_ACK | AUTODIRECTION | ACKENB);\n\tnsp32_write1(base, SCSI_BUS_CONTROL, busctrl);\n}\n\n \nstatic void nsp32_sack_negate(nsp32_hw_data *data)\n{\n\tunsigned int  base = data->BaseAddress;\n\tunsigned char busctrl;\n\n\tbusctrl  = nsp32_read1(base, SCSI_BUS_CONTROL);\n\tbusctrl\t&= ~BUSCTL_ACK;\n\tnsp32_write1(base, SCSI_BUS_CONTROL, busctrl);\n}\n\n\n\n \nstatic int nsp32_detect(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host;\t \n\tstruct resource  *res;\n\tnsp32_hw_data    *data;\n\tint\t\t  ret;\n\tint\t\t  i, j;\n\n\tnsp32_dbg(NSP32_DEBUG_REGISTER, \"enter\");\n\n\t \n\thost = scsi_host_alloc(&nsp32_template, sizeof(nsp32_hw_data));\n\tif (host == NULL) {\n\t\tnsp32_msg (KERN_ERR, \"failed to scsi register\");\n\t\tgoto err;\n\t}\n\n\t \n\tdata = (nsp32_hw_data *)host->hostdata;\n\n\tmemcpy(data, &nsp32_data_base, sizeof(nsp32_hw_data));\n\n\thost->irq       = data->IrqNumber;\n\thost->io_port   = data->BaseAddress;\n\thost->unique_id = data->BaseAddress;\n\thost->n_io_port\t= data->NumAddress;\n\thost->base      = (unsigned long)data->MmioAddress;\n\n\tdata->Host      = host;\n\tspin_lock_init(&(data->Lock));\n\n\tdata->cur_lunt   = NULL;\n\tdata->cur_target = NULL;\n\n\t \n\tdata->trans_method = NSP32_TRANSFER_BUSMASTER;\n\n\t \n\tdata->clock = CLOCK_4;\n\n\t \n\tswitch (data->clock) {\n\tcase CLOCK_4:\n\t\t \n\t\tdata->synct   = nsp32_sync_table_40M;\n\t\tdata->syncnum = ARRAY_SIZE(nsp32_sync_table_40M);\n\t\tbreak;\n\tcase CLOCK_2:\n\t\t \n\t\tdata->synct   = nsp32_sync_table_20M;\n\t\tdata->syncnum = ARRAY_SIZE(nsp32_sync_table_20M);\n\t\tbreak;\n\tcase PCICLK:\n\t\t \n\t\tdata->synct   = nsp32_sync_table_pci;\n\t\tdata->syncnum = ARRAY_SIZE(nsp32_sync_table_pci);\n\t\tbreak;\n\tdefault:\n\t\tnsp32_msg(KERN_WARNING,\n\t\t\t  \"Invalid clock div is selected, set CLOCK_4.\");\n\t\t \n\t\tdata->clock   = CLOCK_4;\n\t\tdata->synct   = nsp32_sync_table_40M;\n\t\tdata->syncnum = ARRAY_SIZE(nsp32_sync_table_40M);\n\t}\n\n\t \n\n\t \n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32)) != 0) {\n\t\tnsp32_msg (KERN_ERR, \"failed to set PCI DMA mask\");\n\t\tgoto scsi_unregister;\n\t}\n\n\t \n\tdata->autoparam = dma_alloc_coherent(&pdev->dev,\n\t\t\tsizeof(nsp32_autoparam), &(data->auto_paddr),\n\t\t\tGFP_KERNEL);\n\tif (data->autoparam == NULL) {\n\t\tnsp32_msg(KERN_ERR, \"failed to allocate DMA memory\");\n\t\tgoto scsi_unregister;\n\t}\n\n\t \n\tdata->sg_list = dma_alloc_coherent(&pdev->dev, NSP32_SG_TABLE_SIZE,\n\t\t\t&data->sg_paddr, GFP_KERNEL);\n\tif (data->sg_list == NULL) {\n\t\tnsp32_msg(KERN_ERR, \"failed to allocate DMA memory\");\n\t\tgoto free_autoparam;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data->lunt); i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(data->lunt[0]); j++) {\n\t\t\tint offset = i * ARRAY_SIZE(data->lunt[0]) + j;\n\t\t\tnsp32_lunt tmp = {\n\t\t\t\t.SCpnt       = NULL,\n\t\t\t\t.save_datp   = 0,\n\t\t\t\t.msgin03     = FALSE,\n\t\t\t\t.sg_num      = 0,\n\t\t\t\t.cur_entry   = 0,\n\t\t\t\t.sglun       = &(data->sg_list[offset]),\n\t\t\t\t.sglun_paddr = data->sg_paddr + (offset * sizeof(nsp32_sglun)),\n\t\t\t};\n\n\t\t\tdata->lunt[i][j] = tmp;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->target); i++) {\n\t\tnsp32_target *target = &(data->target[i]);\n\n\t\ttarget->limit_entry  = 0;\n\t\ttarget->sync_flag    = 0;\n\t\tnsp32_set_async(data, target);\n\t}\n\n\t \n\tret = nsp32_getprom_param(data);\n\tif (ret == FALSE) {\n\t\tdata->resettime = 3;\t \n\t}\n\n\t \n\tnsp32hw_init(data);\n\n\tsnprintf(data->info_str, sizeof(data->info_str),\n\t\t \"NinjaSCSI-32Bi/UDE: irq %d, io 0x%lx+0x%x\",\n\t\t host->irq, host->io_port, host->n_io_port);\n\n\t \n\tnsp32_do_bus_reset(data);\n\n\tret = request_irq(host->irq, do_nsp32_isr, IRQF_SHARED, \"nsp32\", data);\n\tif (ret < 0) {\n\t\tnsp32_msg(KERN_ERR, \"Unable to allocate IRQ for NinjaSCSI32 \"\n\t\t\t  \"SCSI PCI controller. Interrupt: %d\", host->irq);\n\t\tgoto free_sg_list;\n\t}\n\n\t \n\tres = request_region(host->io_port, host->n_io_port, \"nsp32\");\n\tif (res == NULL) {\n\t\tnsp32_msg(KERN_ERR,\n\t\t\t  \"I/O region 0x%x+0x%x is already used\",\n\t\t\t  data->BaseAddress, data->NumAddress);\n\t\tgoto free_irq;\n\t}\n\n\tret = scsi_add_host(host, &pdev->dev);\n\tif (ret) {\n\t\tnsp32_msg(KERN_ERR, \"failed to add scsi host\");\n\t\tgoto free_region;\n\t}\n\tscsi_scan_host(host);\n\tpci_set_drvdata(pdev, host);\n\treturn 0;\n\n free_region:\n\trelease_region(host->io_port, host->n_io_port);\n\n free_irq:\n\tfree_irq(host->irq, data);\n\n free_sg_list:\n\tdma_free_coherent(&pdev->dev, NSP32_SG_TABLE_SIZE,\n\t\t\t    data->sg_list, data->sg_paddr);\n\n free_autoparam:\n\tdma_free_coherent(&pdev->dev, sizeof(nsp32_autoparam),\n\t\t\t    data->autoparam, data->auto_paddr);\n\n scsi_unregister:\n\tscsi_host_put(host);\n\n err:\n\treturn 1;\n}\n\nstatic int nsp32_release(struct Scsi_Host *host)\n{\n\tnsp32_hw_data *data = (nsp32_hw_data *)host->hostdata;\n\n\tif (data->autoparam) {\n\t\tdma_free_coherent(&data->Pci->dev, sizeof(nsp32_autoparam),\n\t\t\t\t    data->autoparam, data->auto_paddr);\n\t}\n\n\tif (data->sg_list) {\n\t\tdma_free_coherent(&data->Pci->dev, NSP32_SG_TABLE_SIZE,\n\t\t\t\t    data->sg_list, data->sg_paddr);\n\t}\n\n\tif (host->irq) {\n\t\tfree_irq(host->irq, data);\n\t}\n\n\tif (host->io_port && host->n_io_port) {\n\t\trelease_region(host->io_port, host->n_io_port);\n\t}\n\n\tif (data->MmioAddress) {\n\t\tiounmap(data->MmioAddress);\n\t}\n\n\treturn 0;\n}\n\nstatic const char *nsp32_info(struct Scsi_Host *shpnt)\n{\n\tnsp32_hw_data *data = (nsp32_hw_data *)shpnt->hostdata;\n\n\treturn data->info_str;\n}\n\n\n \nstatic int nsp32_eh_abort(struct scsi_cmnd *SCpnt)\n{\n\tnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\n\tunsigned int   base = SCpnt->device->host->io_port;\n\n\tnsp32_msg(KERN_WARNING, \"abort\");\n\n\tif (data->cur_lunt->SCpnt == NULL) {\n\t\tnsp32_dbg(NSP32_DEBUG_BUSRESET, \"abort failed\");\n\t\treturn FAILED;\n\t}\n\n\tif (data->cur_target->sync_flag & (SDTR_INITIATOR | SDTR_TARGET)) {\n\t\t \n\t\tdata->cur_target->sync_flag = 0;\n\t\tnsp32_set_async(data, data->cur_target);\n\t}\n\n\tnsp32_write2(base, TRANSFER_CONTROL, 0);\n\tnsp32_write2(base, BM_CNT, 0);\n\n\tSCpnt->result = DID_ABORT << 16;\n\tnsp32_scsi_done(SCpnt);\n\n\tnsp32_dbg(NSP32_DEBUG_BUSRESET, \"abort success\");\n\treturn SUCCESS;\n}\n\nstatic void nsp32_do_bus_reset(nsp32_hw_data *data)\n{\n\tunsigned int   base = data->BaseAddress;\n\tint i;\n\tunsigned short __maybe_unused intrdat;\n\n\tnsp32_dbg(NSP32_DEBUG_BUSRESET, \"in\");\n\n\t \n\tnsp32_write2(base, TRANSFER_CONTROL, 0);\n\tnsp32_write4(base, BM_CNT, 0);\n\tnsp32_write4(base, CLR_COUNTER, CLRCOUNTER_ALLMASK);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data->target); i++) {\n\t\tnsp32_target *target = &data->target[i];\n\n\t\ttarget->sync_flag = 0;\n\t\tnsp32_set_async(data, target);\n\t}\n\n\t \n\tnsp32_write1(base, SCSI_BUS_CONTROL, BUSCTL_RST);\n\tmdelay(RESET_HOLD_TIME / 1000);\n\tnsp32_write1(base, SCSI_BUS_CONTROL, 0);\n\tfor(i = 0; i < 5; i++) {\n\t\tintrdat = nsp32_read2(base, IRQ_STATUS);  \n\t\tnsp32_dbg(NSP32_DEBUG_BUSRESET, \"irq:1: 0x%x\", intrdat);\n\t}\n\n\tdata->CurrentSC = NULL;\n}\n\nstatic int nsp32_eh_host_reset(struct scsi_cmnd *SCpnt)\n{\n\tstruct Scsi_Host *host = SCpnt->device->host;\n\tunsigned int      base = SCpnt->device->host->io_port;\n\tnsp32_hw_data    *data = (nsp32_hw_data *)host->hostdata;\n\n\tnsp32_msg(KERN_INFO, \"Host Reset\");\n\tnsp32_dbg(NSP32_DEBUG_BUSRESET, \"SCpnt=0x%x\", SCpnt);\n\n\tspin_lock_irq(SCpnt->device->host->host_lock);\n\n\tnsp32hw_init(data);\n\tnsp32_write2(base, IRQ_CONTROL, IRQ_CONTROL_ALL_IRQ_MASK);\n\tnsp32_do_bus_reset(data);\n\tnsp32_write2(base, IRQ_CONTROL, 0);\n\n\tspin_unlock_irq(SCpnt->device->host->host_lock);\n\treturn SUCCESS;\t \n}\n\n\n \n\n \nstatic int nsp32_getprom_param(nsp32_hw_data *data)\n{\n\tint vendor = data->pci_devid->vendor;\n\tint device = data->pci_devid->device;\n\tint ret, i;\n\tint __maybe_unused val;\n\n\t \n\tret = nsp32_prom_read(data, 0x7e);\n\tif (ret != 0x55) {\n\t\tnsp32_msg(KERN_INFO, \"No EEPROM detected: 0x%x\", ret);\n\t\treturn FALSE;\n\t}\n\tret = nsp32_prom_read(data, 0x7f);\n\tif (ret != 0xaa) {\n\t\tnsp32_msg(KERN_INFO, \"Invalid number: 0x%x\", ret);\n\t\treturn FALSE;\n\t}\n\n\t \n\tif (vendor == PCI_VENDOR_ID_WORKBIT &&\n\t    device == PCI_DEVICE_ID_WORKBIT_STANDARD) {\n\t\tret = nsp32_getprom_c16(data);\n\t} else if (vendor == PCI_VENDOR_ID_WORKBIT &&\n\t\t   device == PCI_DEVICE_ID_NINJASCSI_32BIB_LOGITEC) {\n\t\tret = nsp32_getprom_at24(data);\n\t} else if (vendor == PCI_VENDOR_ID_WORKBIT &&\n\t\t   device == PCI_DEVICE_ID_NINJASCSI_32UDE_MELCO ) {\n\t\tret = nsp32_getprom_at24(data);\n\t} else {\n\t\tnsp32_msg(KERN_WARNING, \"Unknown EEPROM\");\n\t\tret = FALSE;\n\t}\n\n\t \n\tfor (i = 0; i <= 0x1f; i++) {\n\t\tval = nsp32_prom_read(data, i);\n\t\tnsp32_dbg(NSP32_DEBUG_EEPROM,\n\t\t\t  \"rom address 0x%x : 0x%x\", i, val);\n\t}\n\n\treturn ret;\n}\n\n\n \nstatic int nsp32_getprom_at24(nsp32_hw_data *data)\n{\n\tint\t      ret, i;\n\tint\t      auto_sync;\n\tnsp32_target *target;\n\tint\t      entry;\n\n\t \n\tdata->resettime = nsp32_prom_read(data, 0x12);\n\n\t \n\tret = nsp32_prom_read(data, 0x07);\n\tswitch (ret) {\n\tcase 0:\n\t\tauto_sync = TRUE;\n\t\tbreak;\n\tcase 1:\n\t\tauto_sync = FALSE;\n\t\tbreak;\n\tdefault:\n\t\tnsp32_msg(KERN_WARNING,\n\t\t\t  \"Unsupported Auto Sync mode. Fall back to manual mode.\");\n\t\tauto_sync = TRUE;\n\t}\n\n\tif (trans_mode == ULTRA20M_MODE) {\n\t\tauto_sync = TRUE;\n\t}\n\n\t \n\tfor (i = 0; i < NSP32_HOST_SCSIID; i++) {\n\t\ttarget = &data->target[i];\n\t\tif (auto_sync == TRUE) {\n\t\t\ttarget->limit_entry = 0;    \n\t\t} else {\n\t\t\tret   = nsp32_prom_read(data, i);\n\t\t\tentry = nsp32_search_period_entry(data, target, ret);\n\t\t\tif (entry < 0) {\n\t\t\t\t \n\t\t\t\tentry = 0;\n\t\t\t}\n\t\t\ttarget->limit_entry = entry;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\n\n \nstatic int nsp32_getprom_c16(nsp32_hw_data *data)\n{\n\tint\t      ret, i;\n\tnsp32_target *target;\n\tint\t      entry, val;\n\n\t \n\tdata->resettime = nsp32_prom_read(data, 0x11);\n\n\t \n\tfor (i = 0; i < NSP32_HOST_SCSIID; i++) {\n\t\ttarget = &data->target[i];\n\t\tret = nsp32_prom_read(data, i);\n\t\tswitch (ret) {\n\t\tcase 0:\t\t \n\t\t\tval = 0x0c;\n\t\t\tbreak;\n\t\tcase 1:\t\t \n\t\t\tval = 0x19;\n\t\t\tbreak;\n\t\tcase 2:\t\t \n\t\t\tval = 0x32;\n\t\t\tbreak;\n\t\tcase 3:\t\t \n\t\t\tval = 0x00;\n\t\t\tbreak;\n\t\tdefault:\t \n\t\t\tval = 0x0c;\n\t\t\tbreak;\n\t\t}\n\t\tentry = nsp32_search_period_entry(data, target, val);\n\t\tif (entry < 0 || trans_mode == ULTRA20M_MODE) {\n\t\t\t \n\t\t\tentry = 0;\n\t\t}\n\t\ttarget->limit_entry = entry;\n\t}\n\n\treturn TRUE;\n}\n\n\n \nstatic int nsp32_prom_read(nsp32_hw_data *data, int romaddr)\n{\n\tint i, val;\n\n\t \n\tnsp32_prom_start(data);\n\n\t \n\tnsp32_prom_write_bit(data, 1);\t \n\tnsp32_prom_write_bit(data, 0);\t \n\tnsp32_prom_write_bit(data, 1);\t \n\tnsp32_prom_write_bit(data, 0);\t \n\tnsp32_prom_write_bit(data, 0);\t \n\tnsp32_prom_write_bit(data, 0);\t \n\tnsp32_prom_write_bit(data, 0);\t \n\n\t \n\tnsp32_prom_write_bit(data, 0);\n\n\t \n\tnsp32_prom_write_bit(data, 0);\n\n\t \n\tfor (i = 7; i >= 0; i--) {\n\t\tnsp32_prom_write_bit(data, ((romaddr >> i) & 1));\n\t}\n\n\t \n\tnsp32_prom_write_bit(data, 0);\n\n\t \n\tnsp32_prom_start(data);\n\n\t \n\tnsp32_prom_write_bit(data, 1);\t \n\tnsp32_prom_write_bit(data, 0);\t \n\tnsp32_prom_write_bit(data, 1);\t \n\tnsp32_prom_write_bit(data, 0);\t \n\tnsp32_prom_write_bit(data, 0);\t \n\tnsp32_prom_write_bit(data, 0);\t \n\tnsp32_prom_write_bit(data, 0);\t \n\n\t \n\tnsp32_prom_write_bit(data, 1);\n\n\t \n\tnsp32_prom_write_bit(data, 0);\n\n\t \n\tval = 0;\n\tfor (i = 7; i >= 0; i--) {\n\t\tval += (nsp32_prom_read_bit(data) << i);\n\t}\n\n\t \n\tnsp32_prom_write_bit(data, 1);\n\n\t \n\tnsp32_prom_stop(data);\n\n\treturn val;\n}\n\nstatic void nsp32_prom_set(nsp32_hw_data *data, int bit, int val)\n{\n\tint base = data->BaseAddress;\n\tint tmp;\n\n\ttmp = nsp32_index_read1(base, SERIAL_ROM_CTL);\n\n\tif (val == 0) {\n\t\ttmp &= ~bit;\n\t} else {\n\t\ttmp |=  bit;\n\t}\n\n\tnsp32_index_write1(base, SERIAL_ROM_CTL, tmp);\n\n\tudelay(10);\n}\n\nstatic int nsp32_prom_get(nsp32_hw_data *data, int bit)\n{\n\tint base = data->BaseAddress;\n\tint tmp, ret;\n\n\tif (bit != SDA) {\n\t\tnsp32_msg(KERN_ERR, \"return value is not appropriate\");\n\t\treturn 0;\n\t}\n\n\n\ttmp = nsp32_index_read1(base, SERIAL_ROM_CTL) & bit;\n\n\tif (tmp == 0) {\n\t\tret = 0;\n\t} else {\n\t\tret = 1;\n\t}\n\n\tudelay(10);\n\n\treturn ret;\n}\n\nstatic void nsp32_prom_start (nsp32_hw_data *data)\n{\n\t \n\tnsp32_prom_set(data, SCL, 1);\n\tnsp32_prom_set(data, SDA, 1);\n\tnsp32_prom_set(data, ENA, 1);\t \n\tnsp32_prom_set(data, SDA, 0);\t \n\tnsp32_prom_set(data, SCL, 0);\n}\n\nstatic void nsp32_prom_stop (nsp32_hw_data *data)\n{\n\t \n\tnsp32_prom_set(data, SCL, 1);\n\tnsp32_prom_set(data, SDA, 0);\n\tnsp32_prom_set(data, ENA, 1);\t \n\tnsp32_prom_set(data, SDA, 1);\n\tnsp32_prom_set(data, SCL, 0);\n}\n\nstatic void nsp32_prom_write_bit(nsp32_hw_data *data, int val)\n{\n\t \n\tnsp32_prom_set(data, SDA, val);\n\tnsp32_prom_set(data, SCL, 1  );\n\tnsp32_prom_set(data, SCL, 0  );\n}\n\nstatic int nsp32_prom_read_bit(nsp32_hw_data *data)\n{\n\tint val;\n\n\t \n\tnsp32_prom_set(data, ENA, 0);\t \n\tnsp32_prom_set(data, SCL, 1);\n\n\tval = nsp32_prom_get(data, SDA);\n\n\tnsp32_prom_set(data, SCL, 0);\n\tnsp32_prom_set(data, ENA, 1);\t \n\n\treturn val;\n}\n\n\n \n#ifdef CONFIG_PM\n\n \nstatic int nsp32_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\n\tnsp32_msg(KERN_INFO, \"pci-suspend: pdev=0x%p, state.event=%x, slot=%s, host=0x%p\",\n\t\t  pdev, state.event, pci_name(pdev), host);\n\n\tpci_save_state     (pdev);\n\tpci_disable_device (pdev);\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\n\treturn 0;\n}\n\n \nstatic int nsp32_resume(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tnsp32_hw_data    *data = (nsp32_hw_data *)host->hostdata;\n\tunsigned short    reg;\n\n\tnsp32_msg(KERN_INFO, \"pci-resume: pdev=0x%p, slot=%s, host=0x%p\",\n\t\t  pdev, pci_name(pdev), host);\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_enable_wake    (pdev, PCI_D0, 0);\n\tpci_restore_state  (pdev);\n\n\treg = nsp32_read2(data->BaseAddress, INDEX_REG);\n\n\tnsp32_msg(KERN_INFO, \"io=0x%x reg=0x%x\", data->BaseAddress, reg);\n\n\tif (reg == 0xffff) {\n\t\tnsp32_msg(KERN_INFO, \"missing device. abort resume.\");\n\t\treturn 0;\n\t}\n\n\tnsp32hw_init      (data);\n\tnsp32_do_bus_reset(data);\n\n\tnsp32_msg(KERN_INFO, \"resume success\");\n\n\treturn 0;\n}\n\n#endif\n\n \nstatic int nsp32_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint ret;\n\tnsp32_hw_data *data = &nsp32_data_base;\n\n\tnsp32_dbg(NSP32_DEBUG_REGISTER, \"enter\");\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tnsp32_msg(KERN_ERR, \"failed to enable pci device\");\n\t\treturn ret;\n\t}\n\n\tdata->Pci\t  = pdev;\n\tdata->pci_devid   = id;\n\tdata->IrqNumber   = pdev->irq;\n\tdata->BaseAddress = pci_resource_start(pdev, 0);\n\tdata->NumAddress  = pci_resource_len  (pdev, 0);\n\tdata->MmioAddress = pci_ioremap_bar(pdev, 1);\n\tdata->MmioLength  = pci_resource_len  (pdev, 1);\n\n\tpci_set_master(pdev);\n\n\tret = nsp32_detect(pdev);\n\n\tnsp32_msg(KERN_INFO, \"irq: %i mmio: %p+0x%lx slot: %s model: %s\",\n\t\t  pdev->irq,\n\t\t  data->MmioAddress, data->MmioLength,\n\t\t  pci_name(pdev),\n\t\t  nsp32_model[id->driver_data]);\n\n\tnsp32_dbg(NSP32_DEBUG_REGISTER, \"exit %d\", ret);\n\n\treturn ret;\n}\n\nstatic void nsp32_remove(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\n\tnsp32_dbg(NSP32_DEBUG_REGISTER, \"enter\");\n\n\tscsi_remove_host(host);\n\n\tnsp32_release(host);\n\n\tscsi_host_put(host);\n}\n\nstatic struct pci_driver nsp32_driver = {\n\t.name\t\t= \"nsp32\",\n\t.id_table\t= nsp32_pci_table,\n\t.probe\t\t= nsp32_probe,\n\t.remove\t\t= nsp32_remove,\n#ifdef CONFIG_PM\n\t.suspend\t= nsp32_suspend,\n\t.resume\t\t= nsp32_resume,\n#endif\n};\n\n \nstatic int __init init_nsp32(void) {\n\tnsp32_msg(KERN_INFO, \"loading...\");\n\treturn pci_register_driver(&nsp32_driver);\n}\n\nstatic void __exit exit_nsp32(void) {\n\tnsp32_msg(KERN_INFO, \"unloading...\");\n\tpci_unregister_driver(&nsp32_driver);\n}\n\nmodule_init(init_nsp32);\nmodule_exit(exit_nsp32);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}