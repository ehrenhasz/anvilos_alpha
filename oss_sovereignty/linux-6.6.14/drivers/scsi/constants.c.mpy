{
  "module_name": "constants.c",
  "hash_id": "497449da9b0ac739f18c39f54d4ff449084994da0a12fe1a34907e2d98ba465d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/constants.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_dbg.h>\n\n \n#define THIRD_PARTY_COPY_OUT 0x83\n#define THIRD_PARTY_COPY_IN 0x84\n\nstruct sa_name_list {\n\tint opcode;\n\tconst struct value_name_pair *arr;\n\tint arr_sz;\n};\n\nstruct value_name_pair {\n\tint value;\n\tconst char * name;\n};\n\nstatic const char * cdb_byte0_names[] = {\n  \"Test Unit Ready\", \"Rezero Unit/Rewind\", NULL, \"Request Sense\",\n  \"Format Unit/Medium\", \"Read Block Limits\", NULL,\n\t    \"Reassign Blocks\",\n  \"Read(6)\", NULL, \"Write(6)\", \"Seek(6)\", NULL, NULL,\n  NULL, \"Read Reverse\", \"Write Filemarks\", \"Space\", \"Inquiry\",\n  \"Verify(6)\", \"Recover Buffered Data\", \"Mode Select(6)\",\n\t    \"Reserve(6)\",\n  \"Release(6)\", \"Copy\", \"Erase\", \"Mode Sense(6)\",\n  \"Start/Stop Unit\", \"Receive Diagnostic\", \"Send Diagnostic\",\n  \"Prevent/Allow Medium Removal\", NULL,\n   NULL, NULL, NULL,\n  \"Read Format Capacities\", \"Set Window\",\n\t    \"Read Capacity(10)\", NULL, NULL, \"Read(10)\",\n  \"Read Generation\", \"Write(10)\", \"Seek(10)\", \"Erase(10)\",\n            \"Read updated block\",\n  \"Write Verify(10)\", \"Verify(10)\", \"Search High\", \"Search Equal\",\n  \"Search Low\", \"Set Limits\", \"Prefetch/Read Position\",\n  \"Synchronize Cache(10)\", \"Lock/Unlock Cache(10)\",\n\t    \"Read Defect Data(10)\",\n  \"Medium Scan\", \"Compare\", \"Copy Verify\", \"Write Buffer\",\n\t    \"Read Buffer\",\n  \"Update Block\", \"Read Long(10)\",  \"Write Long(10)\",\n  \"Change Definition\", \"Write Same(10)\",\n  \"Unmap/Read sub-channel\", \"Read TOC/PMA/ATIP\",\n\t    \"Read density support\", \"Play audio(10)\", \"Get configuration\",\n\t    \"Play audio msf\", \"Sanitize/Play audio track/index\",\n  \"Play track relative(10)\", \"Get event status notification\",\n            \"Pause/resume\", \"Log Select\", \"Log Sense\", \"Stop play/scan\",\n            NULL,\n  \"Xdwrite\", \"Xpwrite, Read disk info\", \"Xdread, Read track info\",\n            \"Reserve track\", \"Send OPC info\", \"Mode Select(10)\",\n  \"Reserve(10)\", \"Release(10)\", \"Repair track\", \"Read master cue\",\n            \"Mode Sense(10)\", \"Close track/session\",\n  \"Read buffer capacity\", \"Send cue sheet\", \"Persistent reserve in\",\n            \"Persistent reserve out\",\n  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n  NULL, NULL, NULL, NULL, NULL, NULL, \"Extended CDB\",\n\t    \"Variable length\",\n  \"Xdwrite(16)\", \"Rebuild(16)\", \"Regenerate(16)\",\n\t    \"Third party copy out\", \"Third party copy in\",\n  \"ATA command pass through(16)\", \"Access control in\",\n\t    \"Access control out\", \"Read(16)\", \"Compare and Write\",\n  \"Write(16)\", \"ORWrite\", \"Read attributes\", \"Write attributes\",\n            \"Write and verify(16)\", \"Verify(16)\",\n  \"Pre-fetch(16)\", \"Synchronize cache(16)\",\n            \"Lock/unlock cache(16)\", \"Write same(16)\", NULL,\n  NULL, NULL, NULL, NULL, NULL,\n  NULL, NULL, NULL, \"Service action bidirectional\",\n\t    \"Service action in(16)\", \"Service action out(16)\",\n  \"Report luns\", \"ATA command pass through(12)/Blank\",\n            \"Security protocol in\", \"Maintenance in\", \"Maintenance out\",\n\t    \"Move medium/play audio(12)\",\n  \"Exchange medium\", \"Move medium attached\", \"Read(12)\",\n            \"Play track relative(12)\",\n  \"Write(12)\", NULL, \"Erase(12), Get Performance\",\n            \"Read DVD structure\", \"Write and verify(12)\",\n  \"Verify(12)\", \"Search data high(12)\", \"Search data equal(12)\",\n  \"Search data low(12)\", \"Set limits(12)\",\n            \"Read element status attached\",\n  \"Security protocol out\", \"Send volume tag, set streaming\",\n  \"Read defect data(12)\", \"Read element status\", \"Read CD msf\",\n  \"Redundancy group (in), Scan\",\n            \"Redundancy group (out), Set cd-rom speed\", \"Spare (in), Play cd\",\n  \"Spare (out), Mechanism status\", \"Volume set (in), Read cd\",\n            \"Volume set (out), Send DVD structure\",\n};\n\nstatic const struct value_name_pair maint_in_arr[] = {\n\t{0x5, \"Report identifying information\"},\n\t{0xa, \"Report target port groups\"},\n\t{0xb, \"Report aliases\"},\n\t{0xc, \"Report supported operation codes\"},\n\t{0xd, \"Report supported task management functions\"},\n\t{0xe, \"Report priority\"},\n\t{0xf, \"Report timestamp\"},\n\t{0x10, \"Management protocol in\"},\n};\n#define MAINT_IN_SZ ARRAY_SIZE(maint_in_arr)\n\nstatic const struct value_name_pair maint_out_arr[] = {\n\t{0x6, \"Set identifying information\"},\n\t{0xa, \"Set target port groups\"},\n\t{0xb, \"Change aliases\"},\n\t{0xc, \"Remove I_T nexus\"},\n\t{0xe, \"Set priority\"},\n\t{0xf, \"Set timestamp\"},\n\t{0x10, \"Management protocol out\"},\n};\n#define MAINT_OUT_SZ ARRAY_SIZE(maint_out_arr)\n\nstatic const struct value_name_pair serv_in12_arr[] = {\n\t{0x1, \"Read media serial number\"},\n};\n#define SERV_IN12_SZ ARRAY_SIZE(serv_in12_arr)\n\nstatic const struct value_name_pair serv_out12_arr[] = {\n\t{-1, \"dummy entry\"},\n};\n#define SERV_OUT12_SZ ARRAY_SIZE(serv_out12_arr)\n\nstatic const struct value_name_pair serv_bidi_arr[] = {\n\t{-1, \"dummy entry\"},\n};\n#define SERV_BIDI_SZ ARRAY_SIZE(serv_bidi_arr)\n\nstatic const struct value_name_pair serv_in16_arr[] = {\n\t{0x10, \"Read capacity(16)\"},\n\t{0x11, \"Read long(16)\"},\n\t{0x12, \"Get LBA status\"},\n\t{0x13, \"Report referrals\"},\n};\n#define SERV_IN16_SZ ARRAY_SIZE(serv_in16_arr)\n\nstatic const struct value_name_pair serv_out16_arr[] = {\n\t{0x11, \"Write long(16)\"},\n\t{0x1f, \"Notify data transfer device(16)\"},\n};\n#define SERV_OUT16_SZ ARRAY_SIZE(serv_out16_arr)\n\nstatic const struct value_name_pair pr_in_arr[] = {\n\t{0x0, \"Persistent reserve in, read keys\"},\n\t{0x1, \"Persistent reserve in, read reservation\"},\n\t{0x2, \"Persistent reserve in, report capabilities\"},\n\t{0x3, \"Persistent reserve in, read full status\"},\n};\n#define PR_IN_SZ ARRAY_SIZE(pr_in_arr)\n\nstatic const struct value_name_pair pr_out_arr[] = {\n\t{0x0, \"Persistent reserve out, register\"},\n\t{0x1, \"Persistent reserve out, reserve\"},\n\t{0x2, \"Persistent reserve out, release\"},\n\t{0x3, \"Persistent reserve out, clear\"},\n\t{0x4, \"Persistent reserve out, preempt\"},\n\t{0x5, \"Persistent reserve out, preempt and abort\"},\n\t{0x6, \"Persistent reserve out, register and ignore existing key\"},\n\t{0x7, \"Persistent reserve out, register and move\"},\n};\n#define PR_OUT_SZ ARRAY_SIZE(pr_out_arr)\n\n \nstatic const struct value_name_pair tpc_out_arr[] = {\n\t{0x0, \"Extended copy(LID1)\"},\n\t{0x1, \"Extended copy(LID4)\"},\n\t{0x10, \"Populate token\"},\n\t{0x11, \"Write using token\"},\n\t{0x1c, \"Copy operation abort\"},\n};\n#define TPC_OUT_SZ ARRAY_SIZE(tpc_out_arr)\n\nstatic const struct value_name_pair tpc_in_arr[] = {\n\t{0x0, \"Receive copy status(LID1)\"},\n\t{0x1, \"Receive copy data(LID1)\"},\n\t{0x3, \"Receive copy operating parameters\"},\n\t{0x4, \"Receive copy failure details(LID1)\"},\n\t{0x5, \"Receive copy status(LID4)\"},\n\t{0x6, \"Receive copy data(LID4)\"},\n\t{0x7, \"Receive ROD token information\"},\n\t{0x8, \"Report all ROD tokens\"},\n};\n#define TPC_IN_SZ ARRAY_SIZE(tpc_in_arr)\n\n\nstatic const struct value_name_pair variable_length_arr[] = {\n\t{0x1, \"Rebuild(32)\"},\n\t{0x2, \"Regenerate(32)\"},\n\t{0x3, \"Xdread(32)\"},\n\t{0x4, \"Xdwrite(32)\"},\n\t{0x5, \"Xdwrite extended(32)\"},\n\t{0x6, \"Xpwrite(32)\"},\n\t{0x7, \"Xdwriteread(32)\"},\n\t{0x8, \"Xdwrite extended(64)\"},\n\t{0x9, \"Read(32)\"},\n\t{0xa, \"Verify(32)\"},\n\t{0xb, \"Write(32)\"},\n\t{0xc, \"Write an verify(32)\"},\n\t{0xd, \"Write same(32)\"},\n\t{0x8801, \"Format OSD\"},\n\t{0x8802, \"Create (osd)\"},\n\t{0x8803, \"List (osd)\"},\n\t{0x8805, \"Read (osd)\"},\n\t{0x8806, \"Write (osd)\"},\n\t{0x8807, \"Append (osd)\"},\n\t{0x8808, \"Flush (osd)\"},\n\t{0x880a, \"Remove (osd)\"},\n\t{0x880b, \"Create partition (osd)\"},\n\t{0x880c, \"Remove partition (osd)\"},\n\t{0x880e, \"Get attributes (osd)\"},\n\t{0x880f, \"Set attributes (osd)\"},\n\t{0x8812, \"Create and write (osd)\"},\n\t{0x8815, \"Create collection (osd)\"},\n\t{0x8816, \"Remove collection (osd)\"},\n\t{0x8817, \"List collection (osd)\"},\n\t{0x8818, \"Set key (osd)\"},\n\t{0x8819, \"Set master key (osd)\"},\n\t{0x881a, \"Flush collection (osd)\"},\n\t{0x881b, \"Flush partition (osd)\"},\n\t{0x881c, \"Flush OSD\"},\n\t{0x8f7e, \"Perform SCSI command (osd)\"},\n\t{0x8f7f, \"Perform task management function (osd)\"},\n};\n#define VARIABLE_LENGTH_SZ ARRAY_SIZE(variable_length_arr)\n\nstatic struct sa_name_list sa_names_arr[] = {\n\t{VARIABLE_LENGTH_CMD, variable_length_arr, VARIABLE_LENGTH_SZ},\n\t{MAINTENANCE_IN, maint_in_arr, MAINT_IN_SZ},\n\t{MAINTENANCE_OUT, maint_out_arr, MAINT_OUT_SZ},\n\t{PERSISTENT_RESERVE_IN, pr_in_arr, PR_IN_SZ},\n\t{PERSISTENT_RESERVE_OUT, pr_out_arr, PR_OUT_SZ},\n\t{SERVICE_ACTION_IN_12, serv_in12_arr, SERV_IN12_SZ},\n\t{SERVICE_ACTION_OUT_12, serv_out12_arr, SERV_OUT12_SZ},\n\t{SERVICE_ACTION_BIDIRECTIONAL, serv_bidi_arr, SERV_BIDI_SZ},\n\t{SERVICE_ACTION_IN_16, serv_in16_arr, SERV_IN16_SZ},\n\t{SERVICE_ACTION_OUT_16, serv_out16_arr, SERV_OUT16_SZ},\n\t{THIRD_PARTY_COPY_IN, tpc_in_arr, TPC_IN_SZ},\n\t{THIRD_PARTY_COPY_OUT, tpc_out_arr, TPC_OUT_SZ},\n\t{0, NULL, 0},\n};\n\nbool scsi_opcode_sa_name(int opcode, int service_action,\n\t\t\t const char **cdb_name, const char **sa_name)\n{\n\tstruct sa_name_list *sa_name_ptr;\n\tconst struct value_name_pair *arr = NULL;\n\tint arr_sz, k;\n\n\t*cdb_name = NULL;\n\tif (opcode >= VENDOR_SPECIFIC_CDB)\n\t\treturn false;\n\n\tif (opcode < ARRAY_SIZE(cdb_byte0_names))\n\t\t*cdb_name = cdb_byte0_names[opcode];\n\n\tfor (sa_name_ptr = sa_names_arr; sa_name_ptr->arr; ++sa_name_ptr) {\n\t\tif (sa_name_ptr->opcode == opcode) {\n\t\t\tarr = sa_name_ptr->arr;\n\t\t\tarr_sz = sa_name_ptr->arr_sz;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!arr)\n\t\treturn false;\n\n\tfor (k = 0; k < arr_sz; ++k, ++arr) {\n\t\tif (service_action == arr->value)\n\t\t\tbreak;\n\t}\n\tif (k < arr_sz)\n\t\t*sa_name = arr->name;\n\n\treturn true;\n}\n\nstruct error_info {\n\tunsigned short code12;\t \n\tunsigned short size;\n};\n\n \nstatic const struct error_info additional[] =\n{\n#define SENSE_CODE(c, s) {c, sizeof(s)},\n#include \"sense_codes.h\"\n#undef SENSE_CODE\n};\n\nstatic const char *additional_text =\n#define SENSE_CODE(c, s) s \"\\0\"\n#include \"sense_codes.h\"\n#undef SENSE_CODE\n\t;\n\nstruct error_info2 {\n\tunsigned char code1, code2_min, code2_max;\n\tconst char * str;\n\tconst char * fmt;\n};\n\nstatic const struct error_info2 additional2[] =\n{\n\t{0x40, 0x00, 0x7f, \"Ram failure\", \"\"},\n\t{0x40, 0x80, 0xff, \"Diagnostic failure on component\", \"\"},\n\t{0x41, 0x00, 0xff, \"Data path failure\", \"\"},\n\t{0x42, 0x00, 0xff, \"Power-on or self-test failure\", \"\"},\n\t{0x4D, 0x00, 0xff, \"Tagged overlapped commands\", \"task tag \"},\n\t{0x70, 0x00, 0xff, \"Decompression exception\", \"short algorithm id of \"},\n\t{0, 0, 0, NULL, NULL}\n};\n\n \nstatic const char * const snstext[] = {\n\t\"No Sense\",\t     \n\t\"Recovered Error\",   \n\t\"Not Ready\",\t     \n\t\"Medium Error\",\t     \n\t\"Hardware Error\",    \n\t\"Illegal Request\",   \n\t\"Unit Attention\",    \n\t\"Data Protect\",\t     \n\t\"Blank Check\",\t     \n\t\"Vendor Specific(9)\",\n\t\"Copy Aborted\",\t     \n\t\"Aborted Command\",   \n\t\"Equal\",\t     \n\t\"Volume Overflow\",   \n\t\"Miscompare\",\t     \n\t\"Completed\",\t     \n};\n\n \nconst char *\nscsi_sense_key_string(unsigned char key)\n{\n\tif (key < ARRAY_SIZE(snstext))\n\t\treturn snstext[key];\n\treturn NULL;\n}\nEXPORT_SYMBOL(scsi_sense_key_string);\n\n \nconst char *\nscsi_extd_sense_format(unsigned char asc, unsigned char ascq, const char **fmt)\n{\n\tint i;\n\tunsigned short code = ((asc << 8) | ascq);\n\tunsigned offset = 0;\n\n\t*fmt = NULL;\n\tfor (i = 0; i < ARRAY_SIZE(additional); i++) {\n\t\tif (additional[i].code12 == code)\n\t\t\treturn additional_text + offset;\n\t\toffset += additional[i].size;\n\t}\n\tfor (i = 0; additional2[i].fmt; i++) {\n\t\tif (additional2[i].code1 == asc &&\n\t\t    ascq >= additional2[i].code2_min &&\n\t\t    ascq <= additional2[i].code2_max) {\n\t\t\t*fmt = additional2[i].fmt;\n\t\t\treturn additional2[i].str;\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(scsi_extd_sense_format);\n\nstatic const char * const hostbyte_table[]={\n\"DID_OK\", \"DID_NO_CONNECT\", \"DID_BUS_BUSY\", \"DID_TIME_OUT\", \"DID_BAD_TARGET\",\n\"DID_ABORT\", \"DID_PARITY\", \"DID_ERROR\", \"DID_RESET\", \"DID_BAD_INTR\",\n\"DID_PASSTHROUGH\", \"DID_SOFT_ERROR\", \"DID_IMM_RETRY\", \"DID_REQUEUE\",\n\"DID_TRANSPORT_DISRUPTED\", \"DID_TRANSPORT_FAILFAST\", \"DID_TARGET_FAILURE\",\n\"DID_NEXUS_FAILURE\", \"DID_ALLOC_FAILURE\", \"DID_MEDIUM_ERROR\" };\n\nconst char *scsi_hostbyte_string(int result)\n{\n\tenum scsi_host_status hb = host_byte(result);\n\tconst char *hb_string = NULL;\n\n\tif (hb < ARRAY_SIZE(hostbyte_table))\n\t\thb_string = hostbyte_table[hb];\n\treturn hb_string;\n}\nEXPORT_SYMBOL(scsi_hostbyte_string);\n\n#define scsi_mlreturn_name(result)\t{ result, #result }\nstatic const struct value_name_pair scsi_mlreturn_arr[] = {\n\tscsi_mlreturn_name(NEEDS_RETRY),\n\tscsi_mlreturn_name(SUCCESS),\n\tscsi_mlreturn_name(FAILED),\n\tscsi_mlreturn_name(QUEUED),\n\tscsi_mlreturn_name(SOFT_ERROR),\n\tscsi_mlreturn_name(ADD_TO_MLQUEUE),\n\tscsi_mlreturn_name(TIMEOUT_ERROR),\n\tscsi_mlreturn_name(SCSI_RETURN_NOT_HANDLED),\n\tscsi_mlreturn_name(FAST_IO_FAIL)\n};\n\nconst char *scsi_mlreturn_string(int result)\n{\n\tconst struct value_name_pair *arr = scsi_mlreturn_arr;\n\tint k;\n\n\tfor (k = 0; k < ARRAY_SIZE(scsi_mlreturn_arr); ++k, ++arr) {\n\t\tif (result == arr->value)\n\t\t\treturn arr->name;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(scsi_mlreturn_string);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}