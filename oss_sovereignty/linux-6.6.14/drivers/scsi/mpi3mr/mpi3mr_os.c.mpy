{
  "module_name": "mpi3mr_os.c",
  "hash_id": "d08ec4c0b0af6fac83d37ad451b1163dce5062cc47fff201c3e18a3d80a7f92a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mpi3mr/mpi3mr_os.c",
  "human_readable_source": "\n \n\n#include \"mpi3mr.h\"\n\n \nLIST_HEAD(mrioc_list);\nDEFINE_SPINLOCK(mrioc_list_lock);\nstatic int mrioc_ids;\nstatic int warn_non_secure_ctlr;\natomic64_t event_counter;\n\nMODULE_AUTHOR(MPI3MR_DRIVER_AUTHOR);\nMODULE_DESCRIPTION(MPI3MR_DRIVER_DESC);\nMODULE_LICENSE(MPI3MR_DRIVER_LICENSE);\nMODULE_VERSION(MPI3MR_DRIVER_VERSION);\n\n \nint prot_mask = -1;\nmodule_param(prot_mask, int, 0);\nMODULE_PARM_DESC(prot_mask, \"Host protection capabilities mask, def=0x07\");\n\nstatic int prot_guard_mask = 3;\nmodule_param(prot_guard_mask, int, 0);\nMODULE_PARM_DESC(prot_guard_mask, \" Host protection guard mask, def=3\");\nstatic int logging_level;\nmodule_param(logging_level, int, 0);\nMODULE_PARM_DESC(logging_level,\n\t\" bits for enabling additional logging info (default=0)\");\nstatic int max_sgl_entries = MPI3MR_DEFAULT_SGL_ENTRIES;\nmodule_param(max_sgl_entries, int, 0444);\nMODULE_PARM_DESC(max_sgl_entries,\n\t\"Preferred max number of SG entries to be used for a single I/O\\n\"\n\t\"The actual value will be determined by the driver\\n\"\n\t\"(Minimum=256, Maximum=2048, default=256)\");\n\n \nstatic void mpi3mr_send_event_ack(struct mpi3mr_ioc *mrioc, u8 event,\n\tstruct mpi3mr_drv_cmd *cmdparam, u32 event_ctx);\n\n#define MPI3MR_DRIVER_EVENT_TG_QD_REDUCTION\t(0xFFFF)\n\n#define MPI3_EVENT_WAIT_FOR_DEVICES_TO_REFRESH\t(0xFFFE)\n\n \nstatic u16 mpi3mr_host_tag_for_scmd(struct mpi3mr_ioc *mrioc,\n\tstruct scsi_cmnd *scmd)\n{\n\tstruct scmd_priv *priv = NULL;\n\tu32 unique_tag;\n\tu16 host_tag, hw_queue;\n\n\tunique_tag = blk_mq_unique_tag(scsi_cmd_to_rq(scmd));\n\n\thw_queue = blk_mq_unique_tag_to_hwq(unique_tag);\n\tif (hw_queue >= mrioc->num_op_reply_q)\n\t\treturn MPI3MR_HOSTTAG_INVALID;\n\thost_tag = blk_mq_unique_tag_to_tag(unique_tag);\n\n\tif (WARN_ON(host_tag >= mrioc->max_host_ios))\n\t\treturn MPI3MR_HOSTTAG_INVALID;\n\n\tpriv = scsi_cmd_priv(scmd);\n\t \n\tpriv->host_tag = host_tag + 1;\n\tpriv->scmd = scmd;\n\tpriv->in_lld_scope = 1;\n\tpriv->req_q_idx = hw_queue;\n\tpriv->meta_chain_idx = -1;\n\tpriv->chain_idx = -1;\n\tpriv->meta_sg_valid = 0;\n\treturn priv->host_tag;\n}\n\n \nstatic struct scsi_cmnd *mpi3mr_scmd_from_host_tag(\n\tstruct mpi3mr_ioc *mrioc, u16 host_tag, u16 qidx)\n{\n\tstruct scsi_cmnd *scmd = NULL;\n\tstruct scmd_priv *priv = NULL;\n\tu32 unique_tag = host_tag - 1;\n\n\tif (WARN_ON(host_tag > mrioc->max_host_ios))\n\t\tgoto out;\n\n\tunique_tag |= (qidx << BLK_MQ_UNIQUE_TAG_BITS);\n\n\tscmd = scsi_host_find_tag(mrioc->shost, unique_tag);\n\tif (scmd) {\n\t\tpriv = scsi_cmd_priv(scmd);\n\t\tif (!priv->in_lld_scope)\n\t\t\tscmd = NULL;\n\t}\nout:\n\treturn scmd;\n}\n\n \nstatic void mpi3mr_clear_scmd_priv(struct mpi3mr_ioc *mrioc,\n\tstruct scsi_cmnd *scmd)\n{\n\tstruct scmd_priv *priv = NULL;\n\n\tpriv = scsi_cmd_priv(scmd);\n\n\tif (WARN_ON(priv->in_lld_scope == 0))\n\t\treturn;\n\tpriv->host_tag = MPI3MR_HOSTTAG_INVALID;\n\tpriv->req_q_idx = 0xFFFF;\n\tpriv->scmd = NULL;\n\tpriv->in_lld_scope = 0;\n\tpriv->meta_sg_valid = 0;\n\tif (priv->chain_idx >= 0) {\n\t\tclear_bit(priv->chain_idx, mrioc->chain_bitmap);\n\t\tpriv->chain_idx = -1;\n\t}\n\tif (priv->meta_chain_idx >= 0) {\n\t\tclear_bit(priv->meta_chain_idx, mrioc->chain_bitmap);\n\t\tpriv->meta_chain_idx = -1;\n\t}\n}\n\nstatic void mpi3mr_dev_rmhs_send_tm(struct mpi3mr_ioc *mrioc, u16 handle,\n\tstruct mpi3mr_drv_cmd *cmdparam, u8 iou_rc);\nstatic void mpi3mr_fwevt_worker(struct work_struct *work);\n\n \nstatic void mpi3mr_fwevt_free(struct kref *r)\n{\n\tkfree(container_of(r, struct mpi3mr_fwevt, ref_count));\n}\n\n \nstatic void mpi3mr_fwevt_get(struct mpi3mr_fwevt *fwevt)\n{\n\tkref_get(&fwevt->ref_count);\n}\n\n \nstatic void mpi3mr_fwevt_put(struct mpi3mr_fwevt *fwevt)\n{\n\tkref_put(&fwevt->ref_count, mpi3mr_fwevt_free);\n}\n\n \nstatic struct mpi3mr_fwevt *mpi3mr_alloc_fwevt(int len)\n{\n\tstruct mpi3mr_fwevt *fwevt;\n\n\tfwevt = kzalloc(sizeof(*fwevt) + len, GFP_ATOMIC);\n\tif (!fwevt)\n\t\treturn NULL;\n\n\tkref_init(&fwevt->ref_count);\n\treturn fwevt;\n}\n\n \nstatic void mpi3mr_fwevt_add_to_list(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_fwevt *fwevt)\n{\n\tunsigned long flags;\n\n\tif (!mrioc->fwevt_worker_thread)\n\t\treturn;\n\n\tspin_lock_irqsave(&mrioc->fwevt_lock, flags);\n\t \n\tmpi3mr_fwevt_get(fwevt);\n\tINIT_LIST_HEAD(&fwevt->list);\n\tlist_add_tail(&fwevt->list, &mrioc->fwevt_list);\n\tINIT_WORK(&fwevt->work, mpi3mr_fwevt_worker);\n\t \n\tmpi3mr_fwevt_get(fwevt);\n\tqueue_work(mrioc->fwevt_worker_thread, &fwevt->work);\n\tspin_unlock_irqrestore(&mrioc->fwevt_lock, flags);\n}\n\n \nstatic void mpi3mr_fwevt_del_from_list(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_fwevt *fwevt)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mrioc->fwevt_lock, flags);\n\tif (!list_empty(&fwevt->list)) {\n\t\tlist_del_init(&fwevt->list);\n\t\t \n\t\tmpi3mr_fwevt_put(fwevt);\n\t}\n\tspin_unlock_irqrestore(&mrioc->fwevt_lock, flags);\n}\n\n \nstatic struct mpi3mr_fwevt *mpi3mr_dequeue_fwevt(\n\tstruct mpi3mr_ioc *mrioc)\n{\n\tunsigned long flags;\n\tstruct mpi3mr_fwevt *fwevt = NULL;\n\n\tspin_lock_irqsave(&mrioc->fwevt_lock, flags);\n\tif (!list_empty(&mrioc->fwevt_list)) {\n\t\tfwevt = list_first_entry(&mrioc->fwevt_list,\n\t\t    struct mpi3mr_fwevt, list);\n\t\tlist_del_init(&fwevt->list);\n\t\t \n\t\tmpi3mr_fwevt_put(fwevt);\n\t}\n\tspin_unlock_irqrestore(&mrioc->fwevt_lock, flags);\n\n\treturn fwevt;\n}\n\n \nstatic void mpi3mr_cancel_work(struct mpi3mr_fwevt *fwevt)\n{\n\t \n\tif (cancel_work_sync(&fwevt->work)) {\n\t\t \n\t\tmpi3mr_fwevt_put(fwevt);\n\t\t \n\t\tmpi3mr_fwevt_put(fwevt);\n\t}\n}\n\n \nvoid mpi3mr_cleanup_fwevt_list(struct mpi3mr_ioc *mrioc)\n{\n\tstruct mpi3mr_fwevt *fwevt = NULL;\n\n\tif ((list_empty(&mrioc->fwevt_list) && !mrioc->current_event) ||\n\t    !mrioc->fwevt_worker_thread)\n\t\treturn;\n\n\twhile ((fwevt = mpi3mr_dequeue_fwevt(mrioc)))\n\t\tmpi3mr_cancel_work(fwevt);\n\n\tif (mrioc->current_event) {\n\t\tfwevt = mrioc->current_event;\n\t\t \n\t\tif (current_work() == &fwevt->work || fwevt->pending_at_sml) {\n\t\t\tfwevt->discard = 1;\n\t\t\treturn;\n\t\t}\n\n\t\tmpi3mr_cancel_work(fwevt);\n\t}\n}\n\n \nstatic void mpi3mr_queue_qd_reduction_event(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_throttle_group_info *tg)\n{\n\tstruct mpi3mr_fwevt *fwevt;\n\tu16 sz = sizeof(struct mpi3mr_throttle_group_info *);\n\n\t \n\tif (tg->fw_qd != tg->modified_qd)\n\t\treturn;\n\n\tfwevt = mpi3mr_alloc_fwevt(sz);\n\tif (!fwevt) {\n\t\tioc_warn(mrioc, \"failed to queue TG QD reduction event\\n\");\n\t\treturn;\n\t}\n\t*(struct mpi3mr_throttle_group_info **)fwevt->event_data = tg;\n\tfwevt->mrioc = mrioc;\n\tfwevt->event_id = MPI3MR_DRIVER_EVENT_TG_QD_REDUCTION;\n\tfwevt->send_ack = 0;\n\tfwevt->process_evt = 1;\n\tfwevt->evt_ctx = 0;\n\tfwevt->event_data_size = sz;\n\ttg->modified_qd = max_t(u16, (tg->fw_qd * tg->qd_reduction) / 10, 8);\n\n\tdprint_event_bh(mrioc, \"qd reduction event queued for tg_id(%d)\\n\",\n\t    tg->id);\n\tmpi3mr_fwevt_add_to_list(mrioc, fwevt);\n}\n\n \nvoid mpi3mr_invalidate_devhandles(struct mpi3mr_ioc *mrioc)\n{\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\tstruct mpi3mr_stgt_priv_data *tgt_priv;\n\n\tlist_for_each_entry(tgtdev, &mrioc->tgtdev_list, list) {\n\t\ttgtdev->dev_handle = MPI3MR_INVALID_DEV_HANDLE;\n\t\tif (tgtdev->starget && tgtdev->starget->hostdata) {\n\t\t\ttgt_priv = tgtdev->starget->hostdata;\n\t\t\ttgt_priv->dev_handle = MPI3MR_INVALID_DEV_HANDLE;\n\t\t\ttgt_priv->io_throttle_enabled = 0;\n\t\t\ttgt_priv->io_divert = 0;\n\t\t\ttgt_priv->throttle_group = NULL;\n\t\t\ttgt_priv->wslen = 0;\n\t\t\tif (tgtdev->host_exposed)\n\t\t\t\tatomic_set(&tgt_priv->block_io, 1);\n\t\t}\n\t}\n}\n\n \nstatic bool mpi3mr_print_scmd(struct request *rq, void *data)\n{\n\tstruct mpi3mr_ioc *mrioc = (struct mpi3mr_ioc *)data;\n\tstruct scsi_cmnd *scmd = blk_mq_rq_to_pdu(rq);\n\tstruct scmd_priv *priv = NULL;\n\n\tif (scmd) {\n\t\tpriv = scsi_cmd_priv(scmd);\n\t\tif (!priv->in_lld_scope)\n\t\t\tgoto out;\n\n\t\tioc_info(mrioc, \"%s :Host Tag = %d, qid = %d\\n\",\n\t\t    __func__, priv->host_tag, priv->req_q_idx + 1);\n\t\tscsi_print_command(scmd);\n\t}\n\nout:\n\treturn(true);\n}\n\n \n\nstatic bool mpi3mr_flush_scmd(struct request *rq, void *data)\n{\n\tstruct mpi3mr_ioc *mrioc = (struct mpi3mr_ioc *)data;\n\tstruct scsi_cmnd *scmd = blk_mq_rq_to_pdu(rq);\n\tstruct scmd_priv *priv = NULL;\n\n\tif (scmd) {\n\t\tpriv = scsi_cmd_priv(scmd);\n\t\tif (!priv->in_lld_scope)\n\t\t\tgoto out;\n\n\t\tif (priv->meta_sg_valid)\n\t\t\tdma_unmap_sg(&mrioc->pdev->dev, scsi_prot_sglist(scmd),\n\t\t\t    scsi_prot_sg_count(scmd), scmd->sc_data_direction);\n\t\tmpi3mr_clear_scmd_priv(mrioc, scmd);\n\t\tscsi_dma_unmap(scmd);\n\t\tscmd->result = DID_RESET << 16;\n\t\tscsi_print_command(scmd);\n\t\tscsi_done(scmd);\n\t\tmrioc->flush_io_count++;\n\t}\n\nout:\n\treturn(true);\n}\n\n \n\nstatic bool mpi3mr_count_dev_pending(struct request *rq, void *data)\n{\n\tstruct scsi_device *sdev = (struct scsi_device *)data;\n\tstruct mpi3mr_sdev_priv_data *sdev_priv_data = sdev->hostdata;\n\tstruct scsi_cmnd *scmd = blk_mq_rq_to_pdu(rq);\n\tstruct scmd_priv *priv;\n\n\tif (scmd) {\n\t\tpriv = scsi_cmd_priv(scmd);\n\t\tif (!priv->in_lld_scope)\n\t\t\tgoto out;\n\t\tif (scmd->device == sdev)\n\t\t\tsdev_priv_data->pend_count++;\n\t}\n\nout:\n\treturn true;\n}\n\n \n\nstatic bool mpi3mr_count_tgt_pending(struct request *rq, void *data)\n{\n\tstruct scsi_target *starget = (struct scsi_target *)data;\n\tstruct mpi3mr_stgt_priv_data *stgt_priv_data = starget->hostdata;\n\tstruct scsi_cmnd *scmd = blk_mq_rq_to_pdu(rq);\n\tstruct scmd_priv *priv;\n\n\tif (scmd) {\n\t\tpriv = scsi_cmd_priv(scmd);\n\t\tif (!priv->in_lld_scope)\n\t\t\tgoto out;\n\t\tif (scmd->device && (scsi_target(scmd->device) == starget))\n\t\t\tstgt_priv_data->pend_count++;\n\t}\n\nout:\n\treturn true;\n}\n\n \nvoid mpi3mr_flush_host_io(struct mpi3mr_ioc *mrioc)\n{\n\tstruct Scsi_Host *shost = mrioc->shost;\n\n\tmrioc->flush_io_count = 0;\n\tioc_info(mrioc, \"%s :Flushing Host I/O cmds post reset\\n\", __func__);\n\tblk_mq_tagset_busy_iter(&shost->tag_set,\n\t    mpi3mr_flush_scmd, (void *)mrioc);\n\tioc_info(mrioc, \"%s :Flushed %d Host I/O cmds\\n\", __func__,\n\t    mrioc->flush_io_count);\n}\n\n \nvoid mpi3mr_flush_cmds_for_unrecovered_controller(struct mpi3mr_ioc *mrioc)\n{\n\tstruct Scsi_Host *shost = mrioc->shost;\n\tint i;\n\n\tif (!mrioc->unrecoverable)\n\t\treturn;\n\n\tif (mrioc->op_reply_qinfo) {\n\t\tfor (i = 0; i < mrioc->num_queues; i++) {\n\t\t\twhile (atomic_read(&mrioc->op_reply_qinfo[i].in_use))\n\t\t\t\tudelay(500);\n\t\t\tatomic_set(&mrioc->op_reply_qinfo[i].pend_ios, 0);\n\t\t}\n\t}\n\tmrioc->flush_io_count = 0;\n\tblk_mq_tagset_busy_iter(&shost->tag_set,\n\t    mpi3mr_flush_scmd, (void *)mrioc);\n\tmpi3mr_flush_delayed_cmd_lists(mrioc);\n\tmpi3mr_flush_drv_cmds(mrioc);\n}\n\n \nstatic struct mpi3mr_tgt_dev *mpi3mr_alloc_tgtdev(void)\n{\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\n\ttgtdev = kzalloc(sizeof(*tgtdev), GFP_ATOMIC);\n\tif (!tgtdev)\n\t\treturn NULL;\n\tkref_init(&tgtdev->ref_count);\n\treturn tgtdev;\n}\n\n \nstatic void mpi3mr_tgtdev_add_to_list(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_tgt_dev *tgtdev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\tmpi3mr_tgtdev_get(tgtdev);\n\tINIT_LIST_HEAD(&tgtdev->list);\n\tlist_add_tail(&tgtdev->list, &mrioc->tgtdev_list);\n\ttgtdev->state = MPI3MR_DEV_CREATED;\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n}\n\n \nstatic void mpi3mr_tgtdev_del_from_list(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_tgt_dev *tgtdev, bool must_delete)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\tif ((tgtdev->state == MPI3MR_DEV_REMOVE_HS_STARTED) || (must_delete == true)) {\n\t\tif (!list_empty(&tgtdev->list)) {\n\t\t\tlist_del_init(&tgtdev->list);\n\t\t\ttgtdev->state = MPI3MR_DEV_DELETED;\n\t\t\tmpi3mr_tgtdev_put(tgtdev);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n}\n\n \nstatic struct mpi3mr_tgt_dev  *__mpi3mr_get_tgtdev_by_handle(\n\tstruct mpi3mr_ioc *mrioc, u16 handle)\n{\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\n\tassert_spin_locked(&mrioc->tgtdev_lock);\n\tlist_for_each_entry(tgtdev, &mrioc->tgtdev_list, list)\n\t\tif (tgtdev->dev_handle == handle)\n\t\t\tgoto found_tgtdev;\n\treturn NULL;\n\nfound_tgtdev:\n\tmpi3mr_tgtdev_get(tgtdev);\n\treturn tgtdev;\n}\n\n \nstruct mpi3mr_tgt_dev *mpi3mr_get_tgtdev_by_handle(\n\tstruct mpi3mr_ioc *mrioc, u16 handle)\n{\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\ttgtdev = __mpi3mr_get_tgtdev_by_handle(mrioc, handle);\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\treturn tgtdev;\n}\n\n \nstatic struct mpi3mr_tgt_dev  *__mpi3mr_get_tgtdev_by_perst_id(\n\tstruct mpi3mr_ioc *mrioc, u16 persist_id)\n{\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\n\tassert_spin_locked(&mrioc->tgtdev_lock);\n\tlist_for_each_entry(tgtdev, &mrioc->tgtdev_list, list)\n\t\tif (tgtdev->perst_id == persist_id)\n\t\t\tgoto found_tgtdev;\n\treturn NULL;\n\nfound_tgtdev:\n\tmpi3mr_tgtdev_get(tgtdev);\n\treturn tgtdev;\n}\n\n \nstatic struct mpi3mr_tgt_dev *mpi3mr_get_tgtdev_by_perst_id(\n\tstruct mpi3mr_ioc *mrioc, u16 persist_id)\n{\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\ttgtdev = __mpi3mr_get_tgtdev_by_perst_id(mrioc, persist_id);\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\treturn tgtdev;\n}\n\n \nstatic struct mpi3mr_tgt_dev  *__mpi3mr_get_tgtdev_from_tgtpriv(\n\tstruct mpi3mr_ioc *mrioc, struct mpi3mr_stgt_priv_data *tgt_priv)\n{\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\n\tassert_spin_locked(&mrioc->tgtdev_lock);\n\ttgtdev = tgt_priv->tgt_dev;\n\tif (tgtdev)\n\t\tmpi3mr_tgtdev_get(tgtdev);\n\treturn tgtdev;\n}\n\n \nstatic void mpi3mr_set_io_divert_for_all_vd_in_tg(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_throttle_group_info *tg, u8 divert_value)\n{\n\tunsigned long flags;\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\tstruct mpi3mr_stgt_priv_data *tgt_priv;\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\tlist_for_each_entry(tgtdev, &mrioc->tgtdev_list, list) {\n\t\tif (tgtdev->starget && tgtdev->starget->hostdata) {\n\t\t\ttgt_priv = tgtdev->starget->hostdata;\n\t\t\tif (tgt_priv->throttle_group == tg)\n\t\t\t\ttgt_priv->io_divert = divert_value;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n}\n\n \nvoid mpi3mr_print_device_event_notice(struct mpi3mr_ioc *mrioc,\n\tbool device_add)\n{\n\tioc_notice(mrioc, \"Device %s was in progress before the reset and\\n\",\n\t    (device_add ? \"addition\" : \"removal\"));\n\tioc_notice(mrioc, \"completed after reset, verify whether the exposed devices\\n\");\n\tioc_notice(mrioc, \"are matched with attached devices for correctness\\n\");\n}\n\n \nvoid mpi3mr_remove_tgtdev_from_host(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_tgt_dev *tgtdev)\n{\n\tstruct mpi3mr_stgt_priv_data *tgt_priv;\n\n\tioc_info(mrioc, \"%s :Removing handle(0x%04x), wwid(0x%016llx)\\n\",\n\t    __func__, tgtdev->dev_handle, (unsigned long long)tgtdev->wwid);\n\tif (tgtdev->starget && tgtdev->starget->hostdata) {\n\t\ttgt_priv = tgtdev->starget->hostdata;\n\t\tatomic_set(&tgt_priv->block_io, 0);\n\t\ttgt_priv->dev_handle = MPI3MR_INVALID_DEV_HANDLE;\n\t}\n\n\tif (!mrioc->sas_transport_enabled || (tgtdev->dev_type !=\n\t    MPI3_DEVICE_DEVFORM_SAS_SATA) || tgtdev->non_stl) {\n\t\tif (tgtdev->starget) {\n\t\t\tif (mrioc->current_event)\n\t\t\t\tmrioc->current_event->pending_at_sml = 1;\n\t\t\tscsi_remove_target(&tgtdev->starget->dev);\n\t\t\ttgtdev->host_exposed = 0;\n\t\t\tif (mrioc->current_event) {\n\t\t\t\tmrioc->current_event->pending_at_sml = 0;\n\t\t\t\tif (mrioc->current_event->discard) {\n\t\t\t\t\tmpi3mr_print_device_event_notice(mrioc,\n\t\t\t\t\t    false);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else\n\t\tmpi3mr_remove_tgtdev_from_sas_transport(mrioc, tgtdev);\n\n\tioc_info(mrioc, \"%s :Removed handle(0x%04x), wwid(0x%016llx)\\n\",\n\t    __func__, tgtdev->dev_handle, (unsigned long long)tgtdev->wwid);\n}\n\n \nstatic int mpi3mr_report_tgtdev_to_host(struct mpi3mr_ioc *mrioc,\n\tu16 perst_id)\n{\n\tint retval = 0;\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\n\tif (mrioc->reset_in_progress)\n\t\treturn -1;\n\n\ttgtdev = mpi3mr_get_tgtdev_by_perst_id(mrioc, perst_id);\n\tif (!tgtdev) {\n\t\tretval = -1;\n\t\tgoto out;\n\t}\n\tif (tgtdev->is_hidden || tgtdev->host_exposed) {\n\t\tretval = -1;\n\t\tgoto out;\n\t}\n\tif (!mrioc->sas_transport_enabled || (tgtdev->dev_type !=\n\t    MPI3_DEVICE_DEVFORM_SAS_SATA) || tgtdev->non_stl){\n\t\ttgtdev->host_exposed = 1;\n\t\tif (mrioc->current_event)\n\t\t\tmrioc->current_event->pending_at_sml = 1;\n\t\tscsi_scan_target(&mrioc->shost->shost_gendev,\n\t\t    mrioc->scsi_device_channel, tgtdev->perst_id,\n\t\t    SCAN_WILD_CARD, SCSI_SCAN_INITIAL);\n\t\tif (!tgtdev->starget)\n\t\t\ttgtdev->host_exposed = 0;\n\t\tif (mrioc->current_event) {\n\t\t\tmrioc->current_event->pending_at_sml = 0;\n\t\t\tif (mrioc->current_event->discard) {\n\t\t\t\tmpi3mr_print_device_event_notice(mrioc, true);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else\n\t\tmpi3mr_report_tgtdev_to_sas_transport(mrioc, tgtdev);\nout:\n\tif (tgtdev)\n\t\tmpi3mr_tgtdev_put(tgtdev);\n\n\treturn retval;\n}\n\n \nstatic int mpi3mr_change_queue_depth(struct scsi_device *sdev,\n\tint q_depth)\n{\n\tstruct scsi_target *starget = scsi_target(sdev);\n\tstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\n\tint retval = 0;\n\n\tif (!sdev->tagged_supported)\n\t\tq_depth = 1;\n\tif (q_depth > shost->can_queue)\n\t\tq_depth = shost->can_queue;\n\telse if (!q_depth)\n\t\tq_depth = MPI3MR_DEFAULT_SDEV_QD;\n\tretval = scsi_change_queue_depth(sdev, q_depth);\n\tsdev->max_queue_depth = sdev->queue_depth;\n\n\treturn retval;\n}\n\n \nstatic void\nmpi3mr_update_sdev(struct scsi_device *sdev, void *data)\n{\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\n\ttgtdev = (struct mpi3mr_tgt_dev *)data;\n\tif (!tgtdev)\n\t\treturn;\n\n\tmpi3mr_change_queue_depth(sdev, tgtdev->q_depth);\n\tswitch (tgtdev->dev_type) {\n\tcase MPI3_DEVICE_DEVFORM_PCIE:\n\t\t \n\t\tif ((tgtdev->dev_spec.pcie_inf.dev_info &\n\t\t    MPI3_DEVICE0_PCIE_DEVICE_INFO_TYPE_MASK) ==\n\t\t    MPI3_DEVICE0_PCIE_DEVICE_INFO_TYPE_NVME_DEVICE) {\n\t\t\tblk_queue_max_hw_sectors(sdev->request_queue,\n\t\t\t    tgtdev->dev_spec.pcie_inf.mdts / 512);\n\t\t\tif (tgtdev->dev_spec.pcie_inf.pgsz == 0)\n\t\t\t\tblk_queue_virt_boundary(sdev->request_queue,\n\t\t\t\t    ((1 << MPI3MR_DEFAULT_PGSZEXP) - 1));\n\t\t\telse\n\t\t\t\tblk_queue_virt_boundary(sdev->request_queue,\n\t\t\t\t    ((1 << tgtdev->dev_spec.pcie_inf.pgsz) - 1));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \n\nvoid mpi3mr_rfresh_tgtdevs(struct mpi3mr_ioc *mrioc)\n{\n\tstruct mpi3mr_tgt_dev *tgtdev, *tgtdev_next;\n\tstruct mpi3mr_stgt_priv_data *tgt_priv;\n\n\tdprint_reset(mrioc, \"refresh target devices: check for removals\\n\");\n\tlist_for_each_entry_safe(tgtdev, tgtdev_next, &mrioc->tgtdev_list,\n\t    list) {\n\t\tif ((tgtdev->dev_handle == MPI3MR_INVALID_DEV_HANDLE) &&\n\t\t     tgtdev->is_hidden &&\n\t\t     tgtdev->host_exposed && tgtdev->starget &&\n\t\t     tgtdev->starget->hostdata) {\n\t\t\ttgt_priv = tgtdev->starget->hostdata;\n\t\t\ttgt_priv->dev_removed = 1;\n\t\t\tatomic_set(&tgt_priv->block_io, 0);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(tgtdev, tgtdev_next, &mrioc->tgtdev_list,\n\t    list) {\n\t\tif (tgtdev->dev_handle == MPI3MR_INVALID_DEV_HANDLE) {\n\t\t\tdprint_reset(mrioc, \"removing target device with perst_id(%d)\\n\",\n\t\t\t    tgtdev->perst_id);\n\t\t\tif (tgtdev->host_exposed)\n\t\t\t\tmpi3mr_remove_tgtdev_from_host(mrioc, tgtdev);\n\t\t\tmpi3mr_tgtdev_del_from_list(mrioc, tgtdev, true);\n\t\t\tmpi3mr_tgtdev_put(tgtdev);\n\t\t} else if (tgtdev->is_hidden & tgtdev->host_exposed) {\n\t\t\tdprint_reset(mrioc, \"hiding target device with perst_id(%d)\\n\",\n\t\t\t\t     tgtdev->perst_id);\n\t\t\tmpi3mr_remove_tgtdev_from_host(mrioc, tgtdev);\n\t\t}\n\t}\n\n\ttgtdev = NULL;\n\tlist_for_each_entry(tgtdev, &mrioc->tgtdev_list, list) {\n\t\tif ((tgtdev->dev_handle != MPI3MR_INVALID_DEV_HANDLE) &&\n\t\t    !tgtdev->is_hidden) {\n\t\t\tif (!tgtdev->host_exposed)\n\t\t\t\tmpi3mr_report_tgtdev_to_host(mrioc,\n\t\t\t\t\t\t\t     tgtdev->perst_id);\n\t\t\telse if (tgtdev->starget)\n\t\t\t\tstarget_for_each_device(tgtdev->starget,\n\t\t\t\t\t\t\t(void *)tgtdev, mpi3mr_update_sdev);\n\t}\n\t}\n}\n\n \nstatic void mpi3mr_update_tgtdev(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_tgt_dev *tgtdev, struct mpi3_device_page0 *dev_pg0,\n\tbool is_added)\n{\n\tu16 flags = 0;\n\tstruct mpi3mr_stgt_priv_data *scsi_tgt_priv_data = NULL;\n\tstruct mpi3mr_enclosure_node *enclosure_dev = NULL;\n\tu8 prot_mask = 0;\n\n\ttgtdev->perst_id = le16_to_cpu(dev_pg0->persistent_id);\n\ttgtdev->dev_handle = le16_to_cpu(dev_pg0->dev_handle);\n\ttgtdev->dev_type = dev_pg0->device_form;\n\ttgtdev->io_unit_port = dev_pg0->io_unit_port;\n\ttgtdev->encl_handle = le16_to_cpu(dev_pg0->enclosure_handle);\n\ttgtdev->parent_handle = le16_to_cpu(dev_pg0->parent_dev_handle);\n\ttgtdev->slot = le16_to_cpu(dev_pg0->slot);\n\ttgtdev->q_depth = le16_to_cpu(dev_pg0->queue_depth);\n\ttgtdev->wwid = le64_to_cpu(dev_pg0->wwid);\n\ttgtdev->devpg0_flag = le16_to_cpu(dev_pg0->flags);\n\n\tif (tgtdev->encl_handle)\n\t\tenclosure_dev = mpi3mr_enclosure_find_by_handle(mrioc,\n\t\t    tgtdev->encl_handle);\n\tif (enclosure_dev)\n\t\ttgtdev->enclosure_logical_id = le64_to_cpu(\n\t\t    enclosure_dev->pg0.enclosure_logical_id);\n\n\tflags = tgtdev->devpg0_flag;\n\n\ttgtdev->is_hidden = (flags & MPI3_DEVICE0_FLAGS_HIDDEN);\n\n\tif (is_added == true)\n\t\ttgtdev->io_throttle_enabled =\n\t\t    (flags & MPI3_DEVICE0_FLAGS_IO_THROTTLING_REQUIRED) ? 1 : 0;\n\n\tswitch (flags & MPI3_DEVICE0_FLAGS_MAX_WRITE_SAME_MASK) {\n\tcase MPI3_DEVICE0_FLAGS_MAX_WRITE_SAME_256_LB:\n\t\ttgtdev->wslen = MPI3MR_WRITE_SAME_MAX_LEN_256_BLKS;\n\t\tbreak;\n\tcase MPI3_DEVICE0_FLAGS_MAX_WRITE_SAME_2048_LB:\n\t\ttgtdev->wslen = MPI3MR_WRITE_SAME_MAX_LEN_2048_BLKS;\n\t\tbreak;\n\tcase MPI3_DEVICE0_FLAGS_MAX_WRITE_SAME_NO_LIMIT:\n\tdefault:\n\t\ttgtdev->wslen = 0;\n\t\tbreak;\n\t}\n\n\tif (tgtdev->starget && tgtdev->starget->hostdata) {\n\t\tscsi_tgt_priv_data = (struct mpi3mr_stgt_priv_data *)\n\t\t    tgtdev->starget->hostdata;\n\t\tscsi_tgt_priv_data->perst_id = tgtdev->perst_id;\n\t\tscsi_tgt_priv_data->dev_handle = tgtdev->dev_handle;\n\t\tscsi_tgt_priv_data->dev_type = tgtdev->dev_type;\n\t\tscsi_tgt_priv_data->io_throttle_enabled =\n\t\t    tgtdev->io_throttle_enabled;\n\t\tif (is_added == true)\n\t\t\tatomic_set(&scsi_tgt_priv_data->block_io, 0);\n\t\tscsi_tgt_priv_data->wslen = tgtdev->wslen;\n\t}\n\n\tswitch (dev_pg0->access_status) {\n\tcase MPI3_DEVICE0_ASTATUS_NO_ERRORS:\n\tcase MPI3_DEVICE0_ASTATUS_PREPARE:\n\tcase MPI3_DEVICE0_ASTATUS_NEEDS_INITIALIZATION:\n\tcase MPI3_DEVICE0_ASTATUS_DEVICE_MISSING_DELAY:\n\t\tbreak;\n\tdefault:\n\t\ttgtdev->is_hidden = 1;\n\t\tbreak;\n\t}\n\n\tswitch (tgtdev->dev_type) {\n\tcase MPI3_DEVICE_DEVFORM_SAS_SATA:\n\t{\n\t\tstruct mpi3_device0_sas_sata_format *sasinf =\n\t\t    &dev_pg0->device_specific.sas_sata_format;\n\t\tu16 dev_info = le16_to_cpu(sasinf->device_info);\n\n\t\ttgtdev->dev_spec.sas_sata_inf.dev_info = dev_info;\n\t\ttgtdev->dev_spec.sas_sata_inf.sas_address =\n\t\t    le64_to_cpu(sasinf->sas_address);\n\t\ttgtdev->dev_spec.sas_sata_inf.phy_id = sasinf->phy_num;\n\t\ttgtdev->dev_spec.sas_sata_inf.attached_phy_id =\n\t\t    sasinf->attached_phy_identifier;\n\t\tif ((dev_info & MPI3_SAS_DEVICE_INFO_DEVICE_TYPE_MASK) !=\n\t\t    MPI3_SAS_DEVICE_INFO_DEVICE_TYPE_END_DEVICE)\n\t\t\ttgtdev->is_hidden = 1;\n\t\telse if (!(dev_info & (MPI3_SAS_DEVICE_INFO_STP_SATA_TARGET |\n\t\t    MPI3_SAS_DEVICE_INFO_SSP_TARGET)))\n\t\t\ttgtdev->is_hidden = 1;\n\n\t\tif (((tgtdev->devpg0_flag &\n\t\t    MPI3_DEVICE0_FLAGS_ATT_METHOD_DIR_ATTACHED)\n\t\t    && (tgtdev->devpg0_flag &\n\t\t    MPI3_DEVICE0_FLAGS_ATT_METHOD_VIRTUAL)) ||\n\t\t    (tgtdev->parent_handle == 0xFFFF))\n\t\t\ttgtdev->non_stl = 1;\n\t\tif (tgtdev->dev_spec.sas_sata_inf.hba_port)\n\t\t\ttgtdev->dev_spec.sas_sata_inf.hba_port->port_id =\n\t\t\t    dev_pg0->io_unit_port;\n\t\tbreak;\n\t}\n\tcase MPI3_DEVICE_DEVFORM_PCIE:\n\t{\n\t\tstruct mpi3_device0_pcie_format *pcieinf =\n\t\t    &dev_pg0->device_specific.pcie_format;\n\t\tu16 dev_info = le16_to_cpu(pcieinf->device_info);\n\n\t\ttgtdev->dev_spec.pcie_inf.dev_info = dev_info;\n\t\ttgtdev->dev_spec.pcie_inf.capb =\n\t\t    le32_to_cpu(pcieinf->capabilities);\n\t\ttgtdev->dev_spec.pcie_inf.mdts = MPI3MR_DEFAULT_MDTS;\n\t\t \n\t\ttgtdev->dev_spec.pcie_inf.pgsz = 12;\n\t\tif (dev_pg0->access_status == MPI3_DEVICE0_ASTATUS_NO_ERRORS) {\n\t\t\ttgtdev->dev_spec.pcie_inf.mdts =\n\t\t\t    le32_to_cpu(pcieinf->maximum_data_transfer_size);\n\t\t\ttgtdev->dev_spec.pcie_inf.pgsz = pcieinf->page_size;\n\t\t\ttgtdev->dev_spec.pcie_inf.reset_to =\n\t\t\t    max_t(u8, pcieinf->controller_reset_to,\n\t\t\t     MPI3MR_INTADMCMD_TIMEOUT);\n\t\t\ttgtdev->dev_spec.pcie_inf.abort_to =\n\t\t\t    max_t(u8, pcieinf->nvme_abort_to,\n\t\t\t    MPI3MR_INTADMCMD_TIMEOUT);\n\t\t}\n\t\tif (tgtdev->dev_spec.pcie_inf.mdts > (1024 * 1024))\n\t\t\ttgtdev->dev_spec.pcie_inf.mdts = (1024 * 1024);\n\t\tif (((dev_info & MPI3_DEVICE0_PCIE_DEVICE_INFO_TYPE_MASK) !=\n\t\t    MPI3_DEVICE0_PCIE_DEVICE_INFO_TYPE_NVME_DEVICE) &&\n\t\t    ((dev_info & MPI3_DEVICE0_PCIE_DEVICE_INFO_TYPE_MASK) !=\n\t\t    MPI3_DEVICE0_PCIE_DEVICE_INFO_TYPE_SCSI_DEVICE))\n\t\t\ttgtdev->is_hidden = 1;\n\t\ttgtdev->non_stl = 1;\n\t\tif (!mrioc->shost)\n\t\t\tbreak;\n\t\tprot_mask = scsi_host_get_prot(mrioc->shost);\n\t\tif (prot_mask & SHOST_DIX_TYPE0_PROTECTION) {\n\t\t\tscsi_host_set_prot(mrioc->shost, prot_mask & 0x77);\n\t\t\tioc_info(mrioc,\n\t\t\t    \"%s : Disabling DIX0 prot capability\\n\", __func__);\n\t\t\tioc_info(mrioc,\n\t\t\t    \"because HBA does not support DIX0 operation on NVME drives\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase MPI3_DEVICE_DEVFORM_VD:\n\t{\n\t\tstruct mpi3_device0_vd_format *vdinf =\n\t\t    &dev_pg0->device_specific.vd_format;\n\t\tstruct mpi3mr_throttle_group_info *tg = NULL;\n\t\tu16 vdinf_io_throttle_group =\n\t\t    le16_to_cpu(vdinf->io_throttle_group);\n\n\t\ttgtdev->dev_spec.vd_inf.state = vdinf->vd_state;\n\t\tif (vdinf->vd_state == MPI3_DEVICE0_VD_STATE_OFFLINE)\n\t\t\ttgtdev->is_hidden = 1;\n\t\ttgtdev->non_stl = 1;\n\t\ttgtdev->dev_spec.vd_inf.tg_id = vdinf_io_throttle_group;\n\t\ttgtdev->dev_spec.vd_inf.tg_high =\n\t\t    le16_to_cpu(vdinf->io_throttle_group_high) * 2048;\n\t\ttgtdev->dev_spec.vd_inf.tg_low =\n\t\t    le16_to_cpu(vdinf->io_throttle_group_low) * 2048;\n\t\tif (vdinf_io_throttle_group < mrioc->num_io_throttle_group) {\n\t\t\ttg = mrioc->throttle_groups + vdinf_io_throttle_group;\n\t\t\ttg->id = vdinf_io_throttle_group;\n\t\t\ttg->high = tgtdev->dev_spec.vd_inf.tg_high;\n\t\t\ttg->low = tgtdev->dev_spec.vd_inf.tg_low;\n\t\t\ttg->qd_reduction =\n\t\t\t    tgtdev->dev_spec.vd_inf.tg_qd_reduction;\n\t\t\tif (is_added == true)\n\t\t\t\ttg->fw_qd = tgtdev->q_depth;\n\t\t\ttg->modified_qd = tgtdev->q_depth;\n\t\t}\n\t\ttgtdev->dev_spec.vd_inf.tg = tg;\n\t\tif (scsi_tgt_priv_data)\n\t\t\tscsi_tgt_priv_data->throttle_group = tg;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void mpi3mr_devstatuschg_evt_bh(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_fwevt *fwevt)\n{\n\tu16 dev_handle = 0;\n\tu8 uhide = 0, delete = 0, cleanup = 0;\n\tstruct mpi3mr_tgt_dev *tgtdev = NULL;\n\tstruct mpi3_event_data_device_status_change *evtdata =\n\t    (struct mpi3_event_data_device_status_change *)fwevt->event_data;\n\n\tdev_handle = le16_to_cpu(evtdata->dev_handle);\n\tioc_info(mrioc,\n\t    \"%s :device status change: handle(0x%04x): reason code(0x%x)\\n\",\n\t    __func__, dev_handle, evtdata->reason_code);\n\tswitch (evtdata->reason_code) {\n\tcase MPI3_EVENT_DEV_STAT_RC_HIDDEN:\n\t\tdelete = 1;\n\t\tbreak;\n\tcase MPI3_EVENT_DEV_STAT_RC_NOT_HIDDEN:\n\t\tuhide = 1;\n\t\tbreak;\n\tcase MPI3_EVENT_DEV_STAT_RC_VD_NOT_RESPONDING:\n\t\tdelete = 1;\n\t\tcleanup = 1;\n\t\tbreak;\n\tdefault:\n\t\tioc_info(mrioc, \"%s :Unhandled reason code(0x%x)\\n\", __func__,\n\t\t    evtdata->reason_code);\n\t\tbreak;\n\t}\n\n\ttgtdev = mpi3mr_get_tgtdev_by_handle(mrioc, dev_handle);\n\tif (!tgtdev)\n\t\tgoto out;\n\tif (uhide) {\n\t\ttgtdev->is_hidden = 0;\n\t\tif (!tgtdev->host_exposed)\n\t\t\tmpi3mr_report_tgtdev_to_host(mrioc, tgtdev->perst_id);\n\t}\n\n\tif (delete)\n\t\tmpi3mr_remove_tgtdev_from_host(mrioc, tgtdev);\n\n\tif (cleanup) {\n\t\tmpi3mr_tgtdev_del_from_list(mrioc, tgtdev, false);\n\t\tmpi3mr_tgtdev_put(tgtdev);\n\t}\n\nout:\n\tif (tgtdev)\n\t\tmpi3mr_tgtdev_put(tgtdev);\n}\n\n \nstatic void mpi3mr_devinfochg_evt_bh(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_device_page0 *dev_pg0)\n{\n\tstruct mpi3mr_tgt_dev *tgtdev = NULL;\n\tu16 dev_handle = 0, perst_id = 0;\n\n\tperst_id = le16_to_cpu(dev_pg0->persistent_id);\n\tdev_handle = le16_to_cpu(dev_pg0->dev_handle);\n\tioc_info(mrioc,\n\t    \"%s :Device info change: handle(0x%04x): persist_id(0x%x)\\n\",\n\t    __func__, dev_handle, perst_id);\n\ttgtdev = mpi3mr_get_tgtdev_by_handle(mrioc, dev_handle);\n\tif (!tgtdev)\n\t\tgoto out;\n\tmpi3mr_update_tgtdev(mrioc, tgtdev, dev_pg0, false);\n\tif (!tgtdev->is_hidden && !tgtdev->host_exposed)\n\t\tmpi3mr_report_tgtdev_to_host(mrioc, perst_id);\n\tif (tgtdev->is_hidden && tgtdev->host_exposed)\n\t\tmpi3mr_remove_tgtdev_from_host(mrioc, tgtdev);\n\tif (!tgtdev->is_hidden && tgtdev->host_exposed && tgtdev->starget)\n\t\tstarget_for_each_device(tgtdev->starget, (void *)tgtdev,\n\t\t    mpi3mr_update_sdev);\nout:\n\tif (tgtdev)\n\t\tmpi3mr_tgtdev_put(tgtdev);\n}\n\n \nvoid mpi3mr_free_enclosure_list(struct mpi3mr_ioc *mrioc)\n{\n\tstruct mpi3mr_enclosure_node *enclosure_dev, *enclosure_dev_next;\n\n\tlist_for_each_entry_safe(enclosure_dev,\n\t    enclosure_dev_next, &mrioc->enclosure_list, list) {\n\t\tlist_del(&enclosure_dev->list);\n\t\tkfree(enclosure_dev);\n\t}\n}\n\n \nstruct mpi3mr_enclosure_node *mpi3mr_enclosure_find_by_handle(\n\tstruct mpi3mr_ioc *mrioc, u16 handle)\n{\n\tstruct mpi3mr_enclosure_node *enclosure_dev, *r = NULL;\n\n\tlist_for_each_entry(enclosure_dev, &mrioc->enclosure_list, list) {\n\t\tif (le16_to_cpu(enclosure_dev->pg0.enclosure_handle) != handle)\n\t\t\tcontinue;\n\t\tr = enclosure_dev;\n\t\tgoto out;\n\t}\nout:\n\treturn r;\n}\n\n \nstatic void mpi3mr_encldev_add_chg_evt_debug(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_enclosure_page0 *encl_pg0, u8 is_added)\n{\n\tchar *reason_str = NULL;\n\n\tif (!(mrioc->logging_level & MPI3_DEBUG_EVENT_WORK_TASK))\n\t\treturn;\n\n\tif (is_added)\n\t\treason_str = \"enclosure added\";\n\telse\n\t\treason_str = \"enclosure dev status changed\";\n\n\tioc_info(mrioc,\n\t    \"%s: handle(0x%04x), enclosure logical id(0x%016llx)\\n\",\n\t    reason_str, le16_to_cpu(encl_pg0->enclosure_handle),\n\t    (unsigned long long)le64_to_cpu(encl_pg0->enclosure_logical_id));\n\tioc_info(mrioc,\n\t    \"number of slots(%d), port(%d), flags(0x%04x), present(%d)\\n\",\n\t    le16_to_cpu(encl_pg0->num_slots), encl_pg0->io_unit_port,\n\t    le16_to_cpu(encl_pg0->flags),\n\t    ((le16_to_cpu(encl_pg0->flags) &\n\t      MPI3_ENCLS0_FLAGS_ENCL_DEV_PRESENT_MASK) >> 4));\n}\n\n \nstatic void mpi3mr_encldev_add_chg_evt_bh(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_fwevt *fwevt)\n{\n\tstruct mpi3mr_enclosure_node *enclosure_dev = NULL;\n\tstruct mpi3_enclosure_page0 *encl_pg0;\n\tu16 encl_handle;\n\tu8 added, present;\n\n\tencl_pg0 = (struct mpi3_enclosure_page0 *) fwevt->event_data;\n\tadded = (fwevt->event_id == MPI3_EVENT_ENCL_DEVICE_ADDED) ? 1 : 0;\n\tmpi3mr_encldev_add_chg_evt_debug(mrioc, encl_pg0, added);\n\n\n\tencl_handle = le16_to_cpu(encl_pg0->enclosure_handle);\n\tpresent = ((le16_to_cpu(encl_pg0->flags) &\n\t      MPI3_ENCLS0_FLAGS_ENCL_DEV_PRESENT_MASK) >> 4);\n\n\tif (encl_handle)\n\t\tenclosure_dev = mpi3mr_enclosure_find_by_handle(mrioc,\n\t\t    encl_handle);\n\tif (!enclosure_dev && present) {\n\t\tenclosure_dev =\n\t\t\tkzalloc(sizeof(struct mpi3mr_enclosure_node),\n\t\t\t    GFP_KERNEL);\n\t\tif (!enclosure_dev)\n\t\t\treturn;\n\t\tlist_add_tail(&enclosure_dev->list,\n\t\t    &mrioc->enclosure_list);\n\t}\n\tif (enclosure_dev) {\n\t\tif (!present) {\n\t\t\tlist_del(&enclosure_dev->list);\n\t\t\tkfree(enclosure_dev);\n\t\t} else\n\t\t\tmemcpy(&enclosure_dev->pg0, encl_pg0,\n\t\t\t    sizeof(enclosure_dev->pg0));\n\n\t}\n}\n\n \nstatic void\nmpi3mr_sastopochg_evt_debug(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_event_data_sas_topology_change_list *event_data)\n{\n\tint i;\n\tu16 handle;\n\tu8 reason_code, phy_number;\n\tchar *status_str = NULL;\n\tu8 link_rate, prev_link_rate;\n\n\tswitch (event_data->exp_status) {\n\tcase MPI3_EVENT_SAS_TOPO_ES_NOT_RESPONDING:\n\t\tstatus_str = \"remove\";\n\t\tbreak;\n\tcase MPI3_EVENT_SAS_TOPO_ES_RESPONDING:\n\t\tstatus_str =  \"responding\";\n\t\tbreak;\n\tcase MPI3_EVENT_SAS_TOPO_ES_DELAY_NOT_RESPONDING:\n\t\tstatus_str = \"remove delay\";\n\t\tbreak;\n\tcase MPI3_EVENT_SAS_TOPO_ES_NO_EXPANDER:\n\t\tstatus_str = \"direct attached\";\n\t\tbreak;\n\tdefault:\n\t\tstatus_str = \"unknown status\";\n\t\tbreak;\n\t}\n\tioc_info(mrioc, \"%s :sas topology change: (%s)\\n\",\n\t    __func__, status_str);\n\tioc_info(mrioc,\n\t    \"%s :\\texpander_handle(0x%04x), port(%d), enclosure_handle(0x%04x) start_phy(%02d), num_entries(%d)\\n\",\n\t    __func__, le16_to_cpu(event_data->expander_dev_handle),\n\t    event_data->io_unit_port,\n\t    le16_to_cpu(event_data->enclosure_handle),\n\t    event_data->start_phy_num, event_data->num_entries);\n\tfor (i = 0; i < event_data->num_entries; i++) {\n\t\thandle = le16_to_cpu(event_data->phy_entry[i].attached_dev_handle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\tphy_number = event_data->start_phy_num + i;\n\t\treason_code = event_data->phy_entry[i].status &\n\t\t    MPI3_EVENT_SAS_TOPO_PHY_RC_MASK;\n\t\tswitch (reason_code) {\n\t\tcase MPI3_EVENT_SAS_TOPO_PHY_RC_TARG_NOT_RESPONDING:\n\t\t\tstatus_str = \"target remove\";\n\t\t\tbreak;\n\t\tcase MPI3_EVENT_SAS_TOPO_PHY_RC_DELAY_NOT_RESPONDING:\n\t\t\tstatus_str = \"delay target remove\";\n\t\t\tbreak;\n\t\tcase MPI3_EVENT_SAS_TOPO_PHY_RC_PHY_CHANGED:\n\t\t\tstatus_str = \"link status change\";\n\t\t\tbreak;\n\t\tcase MPI3_EVENT_SAS_TOPO_PHY_RC_NO_CHANGE:\n\t\t\tstatus_str = \"link status no change\";\n\t\t\tbreak;\n\t\tcase MPI3_EVENT_SAS_TOPO_PHY_RC_RESPONDING:\n\t\t\tstatus_str = \"target responding\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus_str = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t\tlink_rate = event_data->phy_entry[i].link_rate >> 4;\n\t\tprev_link_rate = event_data->phy_entry[i].link_rate & 0xF;\n\t\tioc_info(mrioc,\n\t\t    \"%s :\\tphy(%02d), attached_handle(0x%04x): %s: link rate: new(0x%02x), old(0x%02x)\\n\",\n\t\t    __func__, phy_number, handle, status_str, link_rate,\n\t\t    prev_link_rate);\n\t}\n}\n\n \nstatic void mpi3mr_sastopochg_evt_bh(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_fwevt *fwevt)\n{\n\tstruct mpi3_event_data_sas_topology_change_list *event_data =\n\t    (struct mpi3_event_data_sas_topology_change_list *)fwevt->event_data;\n\tint i;\n\tu16 handle;\n\tu8 reason_code;\n\tu64 exp_sas_address = 0, parent_sas_address = 0;\n\tstruct mpi3mr_hba_port *hba_port = NULL;\n\tstruct mpi3mr_tgt_dev *tgtdev = NULL;\n\tstruct mpi3mr_sas_node *sas_expander = NULL;\n\tunsigned long flags;\n\tu8 link_rate, prev_link_rate, parent_phy_number;\n\n\tmpi3mr_sastopochg_evt_debug(mrioc, event_data);\n\tif (mrioc->sas_transport_enabled) {\n\t\thba_port = mpi3mr_get_hba_port_by_id(mrioc,\n\t\t    event_data->io_unit_port);\n\t\tif (le16_to_cpu(event_data->expander_dev_handle)) {\n\t\t\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\t\t\tsas_expander = __mpi3mr_expander_find_by_handle(mrioc,\n\t\t\t    le16_to_cpu(event_data->expander_dev_handle));\n\t\t\tif (sas_expander) {\n\t\t\t\texp_sas_address = sas_expander->sas_address;\n\t\t\t\thba_port = sas_expander->hba_port;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\t\t\tparent_sas_address = exp_sas_address;\n\t\t} else\n\t\t\tparent_sas_address = mrioc->sas_hba.sas_address;\n\t}\n\n\tfor (i = 0; i < event_data->num_entries; i++) {\n\t\tif (fwevt->discard)\n\t\t\treturn;\n\t\thandle = le16_to_cpu(event_data->phy_entry[i].attached_dev_handle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\ttgtdev = mpi3mr_get_tgtdev_by_handle(mrioc, handle);\n\t\tif (!tgtdev)\n\t\t\tcontinue;\n\n\t\treason_code = event_data->phy_entry[i].status &\n\t\t    MPI3_EVENT_SAS_TOPO_PHY_RC_MASK;\n\n\t\tswitch (reason_code) {\n\t\tcase MPI3_EVENT_SAS_TOPO_PHY_RC_TARG_NOT_RESPONDING:\n\t\t\tif (tgtdev->host_exposed)\n\t\t\t\tmpi3mr_remove_tgtdev_from_host(mrioc, tgtdev);\n\t\t\tmpi3mr_tgtdev_del_from_list(mrioc, tgtdev, false);\n\t\t\tmpi3mr_tgtdev_put(tgtdev);\n\t\t\tbreak;\n\t\tcase MPI3_EVENT_SAS_TOPO_PHY_RC_RESPONDING:\n\t\tcase MPI3_EVENT_SAS_TOPO_PHY_RC_PHY_CHANGED:\n\t\tcase MPI3_EVENT_SAS_TOPO_PHY_RC_NO_CHANGE:\n\t\t{\n\t\t\tif (!mrioc->sas_transport_enabled || tgtdev->non_stl\n\t\t\t    || tgtdev->is_hidden)\n\t\t\t\tbreak;\n\t\t\tlink_rate = event_data->phy_entry[i].link_rate >> 4;\n\t\t\tprev_link_rate = event_data->phy_entry[i].link_rate & 0xF;\n\t\t\tif (link_rate == prev_link_rate)\n\t\t\t\tbreak;\n\t\t\tif (!parent_sas_address)\n\t\t\t\tbreak;\n\t\t\tparent_phy_number = event_data->start_phy_num + i;\n\t\t\tmpi3mr_update_links(mrioc, parent_sas_address, handle,\n\t\t\t    parent_phy_number, link_rate, hba_port);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (tgtdev)\n\t\t\tmpi3mr_tgtdev_put(tgtdev);\n\t}\n\n\tif (mrioc->sas_transport_enabled && (event_data->exp_status ==\n\t    MPI3_EVENT_SAS_TOPO_ES_NOT_RESPONDING)) {\n\t\tif (sas_expander)\n\t\t\tmpi3mr_expander_remove(mrioc, exp_sas_address,\n\t\t\t    hba_port);\n\t}\n}\n\n \nstatic void\nmpi3mr_pcietopochg_evt_debug(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_event_data_pcie_topology_change_list *event_data)\n{\n\tint i;\n\tu16 handle;\n\tu16 reason_code;\n\tu8 port_number;\n\tchar *status_str = NULL;\n\tu8 link_rate, prev_link_rate;\n\n\tswitch (event_data->switch_status) {\n\tcase MPI3_EVENT_PCIE_TOPO_SS_NOT_RESPONDING:\n\t\tstatus_str = \"remove\";\n\t\tbreak;\n\tcase MPI3_EVENT_PCIE_TOPO_SS_RESPONDING:\n\t\tstatus_str =  \"responding\";\n\t\tbreak;\n\tcase MPI3_EVENT_PCIE_TOPO_SS_DELAY_NOT_RESPONDING:\n\t\tstatus_str = \"remove delay\";\n\t\tbreak;\n\tcase MPI3_EVENT_PCIE_TOPO_SS_NO_PCIE_SWITCH:\n\t\tstatus_str = \"direct attached\";\n\t\tbreak;\n\tdefault:\n\t\tstatus_str = \"unknown status\";\n\t\tbreak;\n\t}\n\tioc_info(mrioc, \"%s :pcie topology change: (%s)\\n\",\n\t    __func__, status_str);\n\tioc_info(mrioc,\n\t    \"%s :\\tswitch_handle(0x%04x), enclosure_handle(0x%04x) start_port(%02d), num_entries(%d)\\n\",\n\t    __func__, le16_to_cpu(event_data->switch_dev_handle),\n\t    le16_to_cpu(event_data->enclosure_handle),\n\t    event_data->start_port_num, event_data->num_entries);\n\tfor (i = 0; i < event_data->num_entries; i++) {\n\t\thandle =\n\t\t    le16_to_cpu(event_data->port_entry[i].attached_dev_handle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\tport_number = event_data->start_port_num + i;\n\t\treason_code = event_data->port_entry[i].port_status;\n\t\tswitch (reason_code) {\n\t\tcase MPI3_EVENT_PCIE_TOPO_PS_NOT_RESPONDING:\n\t\t\tstatus_str = \"target remove\";\n\t\t\tbreak;\n\t\tcase MPI3_EVENT_PCIE_TOPO_PS_DELAY_NOT_RESPONDING:\n\t\t\tstatus_str = \"delay target remove\";\n\t\t\tbreak;\n\t\tcase MPI3_EVENT_PCIE_TOPO_PS_PORT_CHANGED:\n\t\t\tstatus_str = \"link status change\";\n\t\t\tbreak;\n\t\tcase MPI3_EVENT_PCIE_TOPO_PS_NO_CHANGE:\n\t\t\tstatus_str = \"link status no change\";\n\t\t\tbreak;\n\t\tcase MPI3_EVENT_PCIE_TOPO_PS_RESPONDING:\n\t\t\tstatus_str = \"target responding\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus_str = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t\tlink_rate = event_data->port_entry[i].current_port_info &\n\t\t    MPI3_EVENT_PCIE_TOPO_PI_RATE_MASK;\n\t\tprev_link_rate = event_data->port_entry[i].previous_port_info &\n\t\t    MPI3_EVENT_PCIE_TOPO_PI_RATE_MASK;\n\t\tioc_info(mrioc,\n\t\t    \"%s :\\tport(%02d), attached_handle(0x%04x): %s: link rate: new(0x%02x), old(0x%02x)\\n\",\n\t\t    __func__, port_number, handle, status_str, link_rate,\n\t\t    prev_link_rate);\n\t}\n}\n\n \nstatic void mpi3mr_pcietopochg_evt_bh(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_fwevt *fwevt)\n{\n\tstruct mpi3_event_data_pcie_topology_change_list *event_data =\n\t    (struct mpi3_event_data_pcie_topology_change_list *)fwevt->event_data;\n\tint i;\n\tu16 handle;\n\tu8 reason_code;\n\tstruct mpi3mr_tgt_dev *tgtdev = NULL;\n\n\tmpi3mr_pcietopochg_evt_debug(mrioc, event_data);\n\n\tfor (i = 0; i < event_data->num_entries; i++) {\n\t\tif (fwevt->discard)\n\t\t\treturn;\n\t\thandle =\n\t\t    le16_to_cpu(event_data->port_entry[i].attached_dev_handle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\ttgtdev = mpi3mr_get_tgtdev_by_handle(mrioc, handle);\n\t\tif (!tgtdev)\n\t\t\tcontinue;\n\n\t\treason_code = event_data->port_entry[i].port_status;\n\n\t\tswitch (reason_code) {\n\t\tcase MPI3_EVENT_PCIE_TOPO_PS_NOT_RESPONDING:\n\t\t\tif (tgtdev->host_exposed)\n\t\t\t\tmpi3mr_remove_tgtdev_from_host(mrioc, tgtdev);\n\t\t\tmpi3mr_tgtdev_del_from_list(mrioc, tgtdev, false);\n\t\t\tmpi3mr_tgtdev_put(tgtdev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (tgtdev)\n\t\t\tmpi3mr_tgtdev_put(tgtdev);\n\t}\n}\n\n \nstatic void mpi3mr_logdata_evt_bh(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_fwevt *fwevt)\n{\n\tmpi3mr_app_save_logdata(mrioc, fwevt->event_data,\n\t    fwevt->event_data_size);\n}\n\n \nstatic void mpi3mr_update_sdev_qd(struct scsi_device *sdev, void *data)\n{\n\tu16 *q_depth = (u16 *)data;\n\n\tscsi_change_queue_depth(sdev, (int)*q_depth);\n\tsdev->max_queue_depth = sdev->queue_depth;\n}\n\n \nstatic void mpi3mr_set_qd_for_all_vd_in_tg(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_throttle_group_info *tg)\n{\n\tunsigned long flags;\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\tstruct mpi3mr_stgt_priv_data *tgt_priv;\n\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\tlist_for_each_entry(tgtdev, &mrioc->tgtdev_list, list) {\n\t\tif (tgtdev->starget && tgtdev->starget->hostdata) {\n\t\t\ttgt_priv = tgtdev->starget->hostdata;\n\t\t\tif (tgt_priv->throttle_group == tg) {\n\t\t\t\tdprint_event_bh(mrioc,\n\t\t\t\t    \"updating qd due to throttling for persist_id(%d) original_qd(%d), reduced_qd (%d)\\n\",\n\t\t\t\t    tgt_priv->perst_id, tgtdev->q_depth,\n\t\t\t\t    tg->modified_qd);\n\t\t\t\tstarget_for_each_device(tgtdev->starget,\n\t\t\t\t    (void *)&tg->modified_qd,\n\t\t\t\t    mpi3mr_update_sdev_qd);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n}\n\n \nstatic void mpi3mr_fwevt_bh(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_fwevt *fwevt)\n{\n\tstruct mpi3_device_page0 *dev_pg0 = NULL;\n\tu16 perst_id, handle, dev_info;\n\tstruct mpi3_device0_sas_sata_format *sasinf = NULL;\n\n\tmpi3mr_fwevt_del_from_list(mrioc, fwevt);\n\tmrioc->current_event = fwevt;\n\n\tif (mrioc->stop_drv_processing)\n\t\tgoto out;\n\n\tif (mrioc->unrecoverable) {\n\t\tdprint_event_bh(mrioc,\n\t\t    \"ignoring event(0x%02x) in bottom half handler due to unrecoverable controller\\n\",\n\t\t    fwevt->event_id);\n\t\tgoto out;\n\t}\n\n\tif (!fwevt->process_evt)\n\t\tgoto evt_ack;\n\n\tswitch (fwevt->event_id) {\n\tcase MPI3_EVENT_DEVICE_ADDED:\n\t{\n\t\tdev_pg0 = (struct mpi3_device_page0 *)fwevt->event_data;\n\t\tperst_id = le16_to_cpu(dev_pg0->persistent_id);\n\t\thandle = le16_to_cpu(dev_pg0->dev_handle);\n\t\tif (perst_id != MPI3_DEVICE0_PERSISTENTID_INVALID)\n\t\t\tmpi3mr_report_tgtdev_to_host(mrioc, perst_id);\n\t\telse if (mrioc->sas_transport_enabled &&\n\t\t    (dev_pg0->device_form == MPI3_DEVICE_DEVFORM_SAS_SATA)) {\n\t\t\tsasinf = &dev_pg0->device_specific.sas_sata_format;\n\t\t\tdev_info = le16_to_cpu(sasinf->device_info);\n\t\t\tif (!mrioc->sas_hba.num_phys)\n\t\t\t\tmpi3mr_sas_host_add(mrioc);\n\t\t\telse\n\t\t\t\tmpi3mr_sas_host_refresh(mrioc);\n\n\t\t\tif (mpi3mr_is_expander_device(dev_info))\n\t\t\t\tmpi3mr_expander_add(mrioc, handle);\n\t\t}\n\t\tbreak;\n\t}\n\tcase MPI3_EVENT_DEVICE_INFO_CHANGED:\n\t{\n\t\tdev_pg0 = (struct mpi3_device_page0 *)fwevt->event_data;\n\t\tperst_id = le16_to_cpu(dev_pg0->persistent_id);\n\t\tif (perst_id != MPI3_DEVICE0_PERSISTENTID_INVALID)\n\t\t\tmpi3mr_devinfochg_evt_bh(mrioc, dev_pg0);\n\t\tbreak;\n\t}\n\tcase MPI3_EVENT_DEVICE_STATUS_CHANGE:\n\t{\n\t\tmpi3mr_devstatuschg_evt_bh(mrioc, fwevt);\n\t\tbreak;\n\t}\n\tcase MPI3_EVENT_ENCL_DEVICE_ADDED:\n\tcase MPI3_EVENT_ENCL_DEVICE_STATUS_CHANGE:\n\t{\n\t\tmpi3mr_encldev_add_chg_evt_bh(mrioc, fwevt);\n\t\tbreak;\n\t}\n\n\tcase MPI3_EVENT_SAS_TOPOLOGY_CHANGE_LIST:\n\t{\n\t\tmpi3mr_sastopochg_evt_bh(mrioc, fwevt);\n\t\tbreak;\n\t}\n\tcase MPI3_EVENT_PCIE_TOPOLOGY_CHANGE_LIST:\n\t{\n\t\tmpi3mr_pcietopochg_evt_bh(mrioc, fwevt);\n\t\tbreak;\n\t}\n\tcase MPI3_EVENT_LOG_DATA:\n\t{\n\t\tmpi3mr_logdata_evt_bh(mrioc, fwevt);\n\t\tbreak;\n\t}\n\tcase MPI3MR_DRIVER_EVENT_TG_QD_REDUCTION:\n\t{\n\t\tstruct mpi3mr_throttle_group_info *tg;\n\n\t\ttg = *(struct mpi3mr_throttle_group_info **)fwevt->event_data;\n\t\tdprint_event_bh(mrioc,\n\t\t    \"qd reduction event processed for tg_id(%d) reduction_needed(%d)\\n\",\n\t\t    tg->id, tg->need_qd_reduction);\n\t\tif (tg->need_qd_reduction) {\n\t\t\tmpi3mr_set_qd_for_all_vd_in_tg(mrioc, tg);\n\t\t\ttg->need_qd_reduction = 0;\n\t\t}\n\t\tbreak;\n\t}\n\tcase MPI3_EVENT_WAIT_FOR_DEVICES_TO_REFRESH:\n\t{\n\t\twhile (mrioc->device_refresh_on)\n\t\t\tmsleep(500);\n\n\t\tdprint_event_bh(mrioc,\n\t\t    \"scan for non responding and newly added devices after soft reset started\\n\");\n\t\tif (mrioc->sas_transport_enabled) {\n\t\t\tmpi3mr_refresh_sas_ports(mrioc);\n\t\t\tmpi3mr_refresh_expanders(mrioc);\n\t\t}\n\t\tmpi3mr_rfresh_tgtdevs(mrioc);\n\t\tioc_info(mrioc,\n\t\t    \"scan for non responding and newly added devices after soft reset completed\\n\");\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\nevt_ack:\n\tif (fwevt->send_ack)\n\t\tmpi3mr_process_event_ack(mrioc, fwevt->event_id,\n\t\t    fwevt->evt_ctx);\nout:\n\t \n\tmpi3mr_fwevt_put(fwevt);\n\tmrioc->current_event = NULL;\n}\n\n \nstatic void mpi3mr_fwevt_worker(struct work_struct *work)\n{\n\tstruct mpi3mr_fwevt *fwevt = container_of(work, struct mpi3mr_fwevt,\n\t    work);\n\tmpi3mr_fwevt_bh(fwevt->mrioc, fwevt);\n\t \n\tmpi3mr_fwevt_put(fwevt);\n}\n\n \nstatic int mpi3mr_create_tgtdev(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_device_page0 *dev_pg0)\n{\n\tint retval = 0;\n\tstruct mpi3mr_tgt_dev *tgtdev = NULL;\n\tu16 perst_id = 0;\n\tunsigned long flags;\n\n\tperst_id = le16_to_cpu(dev_pg0->persistent_id);\n\tif (perst_id == MPI3_DEVICE0_PERSISTENTID_INVALID)\n\t\treturn retval;\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\ttgtdev = __mpi3mr_get_tgtdev_by_perst_id(mrioc, perst_id);\n\tif (tgtdev)\n\t\ttgtdev->state = MPI3MR_DEV_CREATED;\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\n\tif (tgtdev) {\n\t\tmpi3mr_update_tgtdev(mrioc, tgtdev, dev_pg0, true);\n\t\tmpi3mr_tgtdev_put(tgtdev);\n\t} else {\n\t\ttgtdev = mpi3mr_alloc_tgtdev();\n\t\tif (!tgtdev)\n\t\t\treturn -ENOMEM;\n\t\tmpi3mr_update_tgtdev(mrioc, tgtdev, dev_pg0, true);\n\t\tmpi3mr_tgtdev_add_to_list(mrioc, tgtdev);\n\t}\n\n\treturn retval;\n}\n\n \nvoid mpi3mr_flush_delayed_cmd_lists(struct mpi3mr_ioc *mrioc)\n{\n\tstruct delayed_dev_rmhs_node *_rmhs_node;\n\tstruct delayed_evt_ack_node *_evtack_node;\n\n\tdprint_reset(mrioc, \"flushing delayed dev_remove_hs commands\\n\");\n\twhile (!list_empty(&mrioc->delayed_rmhs_list)) {\n\t\t_rmhs_node = list_entry(mrioc->delayed_rmhs_list.next,\n\t\t    struct delayed_dev_rmhs_node, list);\n\t\tlist_del(&_rmhs_node->list);\n\t\tkfree(_rmhs_node);\n\t}\n\tdprint_reset(mrioc, \"flushing delayed event ack commands\\n\");\n\twhile (!list_empty(&mrioc->delayed_evtack_cmds_list)) {\n\t\t_evtack_node = list_entry(mrioc->delayed_evtack_cmds_list.next,\n\t\t    struct delayed_evt_ack_node, list);\n\t\tlist_del(&_evtack_node->list);\n\t\tkfree(_evtack_node);\n\t}\n}\n\n \nstatic void mpi3mr_dev_rmhs_complete_iou(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_drv_cmd *drv_cmd)\n{\n\tu16 cmd_idx = drv_cmd->host_tag - MPI3MR_HOSTTAG_DEVRMCMD_MIN;\n\tstruct delayed_dev_rmhs_node *delayed_dev_rmhs = NULL;\n\n\tif (drv_cmd->state & MPI3MR_CMD_RESET)\n\t\tgoto clear_drv_cmd;\n\n\tioc_info(mrioc,\n\t    \"%s :dev_rmhs_iouctrl_complete:handle(0x%04x), ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t    __func__, drv_cmd->dev_handle, drv_cmd->ioc_status,\n\t    drv_cmd->ioc_loginfo);\n\tif (drv_cmd->ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tif (drv_cmd->retry_count < MPI3MR_DEV_RMHS_RETRY_COUNT) {\n\t\t\tdrv_cmd->retry_count++;\n\t\t\tioc_info(mrioc,\n\t\t\t    \"%s :dev_rmhs_iouctrl_complete: handle(0x%04x)retrying handshake retry=%d\\n\",\n\t\t\t    __func__, drv_cmd->dev_handle,\n\t\t\t    drv_cmd->retry_count);\n\t\t\tmpi3mr_dev_rmhs_send_tm(mrioc, drv_cmd->dev_handle,\n\t\t\t    drv_cmd, drv_cmd->iou_rc);\n\t\t\treturn;\n\t\t}\n\t\tioc_err(mrioc,\n\t\t    \"%s :dev removal handshake failed after all retries: handle(0x%04x)\\n\",\n\t\t    __func__, drv_cmd->dev_handle);\n\t} else {\n\t\tioc_info(mrioc,\n\t\t    \"%s :dev removal handshake completed successfully: handle(0x%04x)\\n\",\n\t\t    __func__, drv_cmd->dev_handle);\n\t\tclear_bit(drv_cmd->dev_handle, mrioc->removepend_bitmap);\n\t}\n\n\tif (!list_empty(&mrioc->delayed_rmhs_list)) {\n\t\tdelayed_dev_rmhs = list_entry(mrioc->delayed_rmhs_list.next,\n\t\t    struct delayed_dev_rmhs_node, list);\n\t\tdrv_cmd->dev_handle = delayed_dev_rmhs->handle;\n\t\tdrv_cmd->retry_count = 0;\n\t\tdrv_cmd->iou_rc = delayed_dev_rmhs->iou_rc;\n\t\tioc_info(mrioc,\n\t\t    \"%s :dev_rmhs_iouctrl_complete: processing delayed TM: handle(0x%04x)\\n\",\n\t\t    __func__, drv_cmd->dev_handle);\n\t\tmpi3mr_dev_rmhs_send_tm(mrioc, drv_cmd->dev_handle, drv_cmd,\n\t\t    drv_cmd->iou_rc);\n\t\tlist_del(&delayed_dev_rmhs->list);\n\t\tkfree(delayed_dev_rmhs);\n\t\treturn;\n\t}\n\nclear_drv_cmd:\n\tdrv_cmd->state = MPI3MR_CMD_NOTUSED;\n\tdrv_cmd->callback = NULL;\n\tdrv_cmd->retry_count = 0;\n\tdrv_cmd->dev_handle = MPI3MR_INVALID_DEV_HANDLE;\n\tclear_bit(cmd_idx, mrioc->devrem_bitmap);\n}\n\n \nstatic void mpi3mr_dev_rmhs_complete_tm(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_drv_cmd *drv_cmd)\n{\n\tstruct mpi3_iounit_control_request iou_ctrl;\n\tu16 cmd_idx = drv_cmd->host_tag - MPI3MR_HOSTTAG_DEVRMCMD_MIN;\n\tstruct mpi3_scsi_task_mgmt_reply *tm_reply = NULL;\n\tint retval;\n\n\tif (drv_cmd->state & MPI3MR_CMD_RESET)\n\t\tgoto clear_drv_cmd;\n\n\tif (drv_cmd->state & MPI3MR_CMD_REPLY_VALID)\n\t\ttm_reply = (struct mpi3_scsi_task_mgmt_reply *)drv_cmd->reply;\n\n\tif (tm_reply)\n\t\tpr_info(IOCNAME\n\t\t    \"dev_rmhs_tr_complete:handle(0x%04x), ioc_status(0x%04x), loginfo(0x%08x), term_count(%d)\\n\",\n\t\t    mrioc->name, drv_cmd->dev_handle, drv_cmd->ioc_status,\n\t\t    drv_cmd->ioc_loginfo,\n\t\t    le32_to_cpu(tm_reply->termination_count));\n\n\tpr_info(IOCNAME \"Issuing IOU CTL: handle(0x%04x) dev_rmhs idx(%d)\\n\",\n\t    mrioc->name, drv_cmd->dev_handle, cmd_idx);\n\n\tmemset(&iou_ctrl, 0, sizeof(iou_ctrl));\n\n\tdrv_cmd->state = MPI3MR_CMD_PENDING;\n\tdrv_cmd->is_waiting = 0;\n\tdrv_cmd->callback = mpi3mr_dev_rmhs_complete_iou;\n\tiou_ctrl.operation = drv_cmd->iou_rc;\n\tiou_ctrl.param16[0] = cpu_to_le16(drv_cmd->dev_handle);\n\tiou_ctrl.host_tag = cpu_to_le16(drv_cmd->host_tag);\n\tiou_ctrl.function = MPI3_FUNCTION_IO_UNIT_CONTROL;\n\n\tretval = mpi3mr_admin_request_post(mrioc, &iou_ctrl, sizeof(iou_ctrl),\n\t    1);\n\tif (retval) {\n\t\tpr_err(IOCNAME \"Issue DevRmHsTMIOUCTL: Admin post failed\\n\",\n\t\t    mrioc->name);\n\t\tgoto clear_drv_cmd;\n\t}\n\n\treturn;\nclear_drv_cmd:\n\tdrv_cmd->state = MPI3MR_CMD_NOTUSED;\n\tdrv_cmd->callback = NULL;\n\tdrv_cmd->dev_handle = MPI3MR_INVALID_DEV_HANDLE;\n\tdrv_cmd->retry_count = 0;\n\tclear_bit(cmd_idx, mrioc->devrem_bitmap);\n}\n\n \nstatic void mpi3mr_dev_rmhs_send_tm(struct mpi3mr_ioc *mrioc, u16 handle,\n\tstruct mpi3mr_drv_cmd *cmdparam, u8 iou_rc)\n{\n\tstruct mpi3_scsi_task_mgmt_request tm_req;\n\tint retval = 0;\n\tu16 cmd_idx = MPI3MR_NUM_DEVRMCMD;\n\tu8 retrycount = 5;\n\tstruct mpi3mr_drv_cmd *drv_cmd = cmdparam;\n\tstruct delayed_dev_rmhs_node *delayed_dev_rmhs = NULL;\n\tstruct mpi3mr_tgt_dev *tgtdev = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\ttgtdev = __mpi3mr_get_tgtdev_by_handle(mrioc, handle);\n\tif (tgtdev && (iou_rc == MPI3_CTRL_OP_REMOVE_DEVICE))\n\t\ttgtdev->state = MPI3MR_DEV_REMOVE_HS_STARTED;\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\n\tif (drv_cmd)\n\t\tgoto issue_cmd;\n\tdo {\n\t\tcmd_idx = find_first_zero_bit(mrioc->devrem_bitmap,\n\t\t    MPI3MR_NUM_DEVRMCMD);\n\t\tif (cmd_idx < MPI3MR_NUM_DEVRMCMD) {\n\t\t\tif (!test_and_set_bit(cmd_idx, mrioc->devrem_bitmap))\n\t\t\t\tbreak;\n\t\t\tcmd_idx = MPI3MR_NUM_DEVRMCMD;\n\t\t}\n\t} while (retrycount--);\n\n\tif (cmd_idx >= MPI3MR_NUM_DEVRMCMD) {\n\t\tdelayed_dev_rmhs = kzalloc(sizeof(*delayed_dev_rmhs),\n\t\t    GFP_ATOMIC);\n\t\tif (!delayed_dev_rmhs)\n\t\t\treturn;\n\t\tINIT_LIST_HEAD(&delayed_dev_rmhs->list);\n\t\tdelayed_dev_rmhs->handle = handle;\n\t\tdelayed_dev_rmhs->iou_rc = iou_rc;\n\t\tlist_add_tail(&delayed_dev_rmhs->list,\n\t\t    &mrioc->delayed_rmhs_list);\n\t\tioc_info(mrioc, \"%s :DevRmHs: tr:handle(0x%04x) is postponed\\n\",\n\t\t    __func__, handle);\n\t\treturn;\n\t}\n\tdrv_cmd = &mrioc->dev_rmhs_cmds[cmd_idx];\n\nissue_cmd:\n\tcmd_idx = drv_cmd->host_tag - MPI3MR_HOSTTAG_DEVRMCMD_MIN;\n\tioc_info(mrioc,\n\t    \"%s :Issuing TR TM: for devhandle 0x%04x with dev_rmhs %d\\n\",\n\t    __func__, handle, cmd_idx);\n\n\tmemset(&tm_req, 0, sizeof(tm_req));\n\tif (drv_cmd->state & MPI3MR_CMD_PENDING) {\n\t\tioc_err(mrioc, \"%s :Issue TM: Command is in use\\n\", __func__);\n\t\tgoto out;\n\t}\n\tdrv_cmd->state = MPI3MR_CMD_PENDING;\n\tdrv_cmd->is_waiting = 0;\n\tdrv_cmd->callback = mpi3mr_dev_rmhs_complete_tm;\n\tdrv_cmd->dev_handle = handle;\n\tdrv_cmd->iou_rc = iou_rc;\n\ttm_req.dev_handle = cpu_to_le16(handle);\n\ttm_req.task_type = MPI3_SCSITASKMGMT_TASKTYPE_TARGET_RESET;\n\ttm_req.host_tag = cpu_to_le16(drv_cmd->host_tag);\n\ttm_req.task_host_tag = cpu_to_le16(MPI3MR_HOSTTAG_INVALID);\n\ttm_req.function = MPI3_FUNCTION_SCSI_TASK_MGMT;\n\n\tset_bit(handle, mrioc->removepend_bitmap);\n\tretval = mpi3mr_admin_request_post(mrioc, &tm_req, sizeof(tm_req), 1);\n\tif (retval) {\n\t\tioc_err(mrioc, \"%s :Issue DevRmHsTM: Admin Post failed\\n\",\n\t\t    __func__);\n\t\tgoto out_failed;\n\t}\nout:\n\treturn;\nout_failed:\n\tdrv_cmd->state = MPI3MR_CMD_NOTUSED;\n\tdrv_cmd->callback = NULL;\n\tdrv_cmd->dev_handle = MPI3MR_INVALID_DEV_HANDLE;\n\tdrv_cmd->retry_count = 0;\n\tclear_bit(cmd_idx, mrioc->devrem_bitmap);\n}\n\n \nstatic void mpi3mr_complete_evt_ack(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_drv_cmd *drv_cmd)\n{\n\tu16 cmd_idx = drv_cmd->host_tag - MPI3MR_HOSTTAG_EVTACKCMD_MIN;\n\tstruct delayed_evt_ack_node *delayed_evtack = NULL;\n\n\tif (drv_cmd->state & MPI3MR_CMD_RESET)\n\t\tgoto clear_drv_cmd;\n\n\tif (drv_cmd->ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tdprint_event_th(mrioc,\n\t\t    \"immediate event ack failed with ioc_status(0x%04x) log_info(0x%08x)\\n\",\n\t\t    (drv_cmd->ioc_status & MPI3_IOCSTATUS_STATUS_MASK),\n\t\t    drv_cmd->ioc_loginfo);\n\t}\n\n\tif (!list_empty(&mrioc->delayed_evtack_cmds_list)) {\n\t\tdelayed_evtack =\n\t\t\tlist_entry(mrioc->delayed_evtack_cmds_list.next,\n\t\t\t    struct delayed_evt_ack_node, list);\n\t\tmpi3mr_send_event_ack(mrioc, delayed_evtack->event, drv_cmd,\n\t\t    delayed_evtack->event_ctx);\n\t\tlist_del(&delayed_evtack->list);\n\t\tkfree(delayed_evtack);\n\t\treturn;\n\t}\nclear_drv_cmd:\n\tdrv_cmd->state = MPI3MR_CMD_NOTUSED;\n\tdrv_cmd->callback = NULL;\n\tclear_bit(cmd_idx, mrioc->evtack_cmds_bitmap);\n}\n\n \nstatic void mpi3mr_send_event_ack(struct mpi3mr_ioc *mrioc, u8 event,\n\tstruct mpi3mr_drv_cmd *cmdparam, u32 event_ctx)\n{\n\tstruct mpi3_event_ack_request evtack_req;\n\tint retval = 0;\n\tu8 retrycount = 5;\n\tu16 cmd_idx = MPI3MR_NUM_EVTACKCMD;\n\tstruct mpi3mr_drv_cmd *drv_cmd = cmdparam;\n\tstruct delayed_evt_ack_node *delayed_evtack = NULL;\n\n\tif (drv_cmd) {\n\t\tdprint_event_th(mrioc,\n\t\t    \"sending delayed event ack in the top half for event(0x%02x), event_ctx(0x%08x)\\n\",\n\t\t    event, event_ctx);\n\t\tgoto issue_cmd;\n\t}\n\tdprint_event_th(mrioc,\n\t    \"sending event ack in the top half for event(0x%02x), event_ctx(0x%08x)\\n\",\n\t    event, event_ctx);\n\tdo {\n\t\tcmd_idx = find_first_zero_bit(mrioc->evtack_cmds_bitmap,\n\t\t    MPI3MR_NUM_EVTACKCMD);\n\t\tif (cmd_idx < MPI3MR_NUM_EVTACKCMD) {\n\t\t\tif (!test_and_set_bit(cmd_idx,\n\t\t\t    mrioc->evtack_cmds_bitmap))\n\t\t\t\tbreak;\n\t\t\tcmd_idx = MPI3MR_NUM_EVTACKCMD;\n\t\t}\n\t} while (retrycount--);\n\n\tif (cmd_idx >= MPI3MR_NUM_EVTACKCMD) {\n\t\tdelayed_evtack = kzalloc(sizeof(*delayed_evtack),\n\t\t    GFP_ATOMIC);\n\t\tif (!delayed_evtack)\n\t\t\treturn;\n\t\tINIT_LIST_HEAD(&delayed_evtack->list);\n\t\tdelayed_evtack->event = event;\n\t\tdelayed_evtack->event_ctx = event_ctx;\n\t\tlist_add_tail(&delayed_evtack->list,\n\t\t    &mrioc->delayed_evtack_cmds_list);\n\t\tdprint_event_th(mrioc,\n\t\t    \"event ack in the top half for event(0x%02x), event_ctx(0x%08x) is postponed\\n\",\n\t\t    event, event_ctx);\n\t\treturn;\n\t}\n\tdrv_cmd = &mrioc->evtack_cmds[cmd_idx];\n\nissue_cmd:\n\tcmd_idx = drv_cmd->host_tag - MPI3MR_HOSTTAG_EVTACKCMD_MIN;\n\n\tmemset(&evtack_req, 0, sizeof(evtack_req));\n\tif (drv_cmd->state & MPI3MR_CMD_PENDING) {\n\t\tdprint_event_th(mrioc,\n\t\t    \"sending event ack failed due to command in use\\n\");\n\t\tgoto out;\n\t}\n\tdrv_cmd->state = MPI3MR_CMD_PENDING;\n\tdrv_cmd->is_waiting = 0;\n\tdrv_cmd->callback = mpi3mr_complete_evt_ack;\n\tevtack_req.host_tag = cpu_to_le16(drv_cmd->host_tag);\n\tevtack_req.function = MPI3_FUNCTION_EVENT_ACK;\n\tevtack_req.event = event;\n\tevtack_req.event_context = cpu_to_le32(event_ctx);\n\tretval = mpi3mr_admin_request_post(mrioc, &evtack_req,\n\t    sizeof(evtack_req), 1);\n\tif (retval) {\n\t\tdprint_event_th(mrioc,\n\t\t    \"posting event ack request is failed\\n\");\n\t\tgoto out_failed;\n\t}\n\n\tdprint_event_th(mrioc,\n\t    \"event ack in the top half for event(0x%02x), event_ctx(0x%08x) is posted\\n\",\n\t    event, event_ctx);\nout:\n\treturn;\nout_failed:\n\tdrv_cmd->state = MPI3MR_CMD_NOTUSED;\n\tdrv_cmd->callback = NULL;\n\tclear_bit(cmd_idx, mrioc->evtack_cmds_bitmap);\n}\n\n \nstatic void mpi3mr_pcietopochg_evt_th(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_event_notification_reply *event_reply)\n{\n\tstruct mpi3_event_data_pcie_topology_change_list *topo_evt =\n\t    (struct mpi3_event_data_pcie_topology_change_list *)event_reply->event_data;\n\tint i;\n\tu16 handle;\n\tu8 reason_code;\n\tstruct mpi3mr_tgt_dev *tgtdev = NULL;\n\tstruct mpi3mr_stgt_priv_data *scsi_tgt_priv_data = NULL;\n\n\tfor (i = 0; i < topo_evt->num_entries; i++) {\n\t\thandle = le16_to_cpu(topo_evt->port_entry[i].attached_dev_handle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\treason_code = topo_evt->port_entry[i].port_status;\n\t\tscsi_tgt_priv_data =  NULL;\n\t\ttgtdev = mpi3mr_get_tgtdev_by_handle(mrioc, handle);\n\t\tif (tgtdev && tgtdev->starget && tgtdev->starget->hostdata)\n\t\t\tscsi_tgt_priv_data = (struct mpi3mr_stgt_priv_data *)\n\t\t\t    tgtdev->starget->hostdata;\n\t\tswitch (reason_code) {\n\t\tcase MPI3_EVENT_PCIE_TOPO_PS_NOT_RESPONDING:\n\t\t\tif (scsi_tgt_priv_data) {\n\t\t\t\tscsi_tgt_priv_data->dev_removed = 1;\n\t\t\t\tscsi_tgt_priv_data->dev_removedelay = 0;\n\t\t\t\tatomic_set(&scsi_tgt_priv_data->block_io, 0);\n\t\t\t}\n\t\t\tmpi3mr_dev_rmhs_send_tm(mrioc, handle, NULL,\n\t\t\t    MPI3_CTRL_OP_REMOVE_DEVICE);\n\t\t\tbreak;\n\t\tcase MPI3_EVENT_PCIE_TOPO_PS_DELAY_NOT_RESPONDING:\n\t\t\tif (scsi_tgt_priv_data) {\n\t\t\t\tscsi_tgt_priv_data->dev_removedelay = 1;\n\t\t\t\tatomic_inc(&scsi_tgt_priv_data->block_io);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI3_EVENT_PCIE_TOPO_PS_RESPONDING:\n\t\t\tif (scsi_tgt_priv_data &&\n\t\t\t    scsi_tgt_priv_data->dev_removedelay) {\n\t\t\t\tscsi_tgt_priv_data->dev_removedelay = 0;\n\t\t\t\tatomic_dec_if_positive\n\t\t\t\t    (&scsi_tgt_priv_data->block_io);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI3_EVENT_PCIE_TOPO_PS_PORT_CHANGED:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (tgtdev)\n\t\t\tmpi3mr_tgtdev_put(tgtdev);\n\t}\n}\n\n \nstatic void mpi3mr_sastopochg_evt_th(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_event_notification_reply *event_reply)\n{\n\tstruct mpi3_event_data_sas_topology_change_list *topo_evt =\n\t    (struct mpi3_event_data_sas_topology_change_list *)event_reply->event_data;\n\tint i;\n\tu16 handle;\n\tu8 reason_code;\n\tstruct mpi3mr_tgt_dev *tgtdev = NULL;\n\tstruct mpi3mr_stgt_priv_data *scsi_tgt_priv_data = NULL;\n\n\tfor (i = 0; i < topo_evt->num_entries; i++) {\n\t\thandle = le16_to_cpu(topo_evt->phy_entry[i].attached_dev_handle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\treason_code = topo_evt->phy_entry[i].status &\n\t\t    MPI3_EVENT_SAS_TOPO_PHY_RC_MASK;\n\t\tscsi_tgt_priv_data =  NULL;\n\t\ttgtdev = mpi3mr_get_tgtdev_by_handle(mrioc, handle);\n\t\tif (tgtdev && tgtdev->starget && tgtdev->starget->hostdata)\n\t\t\tscsi_tgt_priv_data = (struct mpi3mr_stgt_priv_data *)\n\t\t\t    tgtdev->starget->hostdata;\n\t\tswitch (reason_code) {\n\t\tcase MPI3_EVENT_SAS_TOPO_PHY_RC_TARG_NOT_RESPONDING:\n\t\t\tif (scsi_tgt_priv_data) {\n\t\t\t\tscsi_tgt_priv_data->dev_removed = 1;\n\t\t\t\tscsi_tgt_priv_data->dev_removedelay = 0;\n\t\t\t\tatomic_set(&scsi_tgt_priv_data->block_io, 0);\n\t\t\t}\n\t\t\tmpi3mr_dev_rmhs_send_tm(mrioc, handle, NULL,\n\t\t\t    MPI3_CTRL_OP_REMOVE_DEVICE);\n\t\t\tbreak;\n\t\tcase MPI3_EVENT_SAS_TOPO_PHY_RC_DELAY_NOT_RESPONDING:\n\t\t\tif (scsi_tgt_priv_data) {\n\t\t\t\tscsi_tgt_priv_data->dev_removedelay = 1;\n\t\t\t\tatomic_inc(&scsi_tgt_priv_data->block_io);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI3_EVENT_SAS_TOPO_PHY_RC_RESPONDING:\n\t\t\tif (scsi_tgt_priv_data &&\n\t\t\t    scsi_tgt_priv_data->dev_removedelay) {\n\t\t\t\tscsi_tgt_priv_data->dev_removedelay = 0;\n\t\t\t\tatomic_dec_if_positive\n\t\t\t\t    (&scsi_tgt_priv_data->block_io);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI3_EVENT_SAS_TOPO_PHY_RC_PHY_CHANGED:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (tgtdev)\n\t\t\tmpi3mr_tgtdev_put(tgtdev);\n\t}\n}\n\n \nstatic void mpi3mr_devstatuschg_evt_th(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_event_notification_reply *event_reply)\n{\n\tu16 dev_handle = 0;\n\tu8 ublock = 0, block = 0, hide = 0, delete = 0, remove = 0;\n\tstruct mpi3mr_tgt_dev *tgtdev = NULL;\n\tstruct mpi3mr_stgt_priv_data *scsi_tgt_priv_data = NULL;\n\tstruct mpi3_event_data_device_status_change *evtdata =\n\t    (struct mpi3_event_data_device_status_change *)event_reply->event_data;\n\n\tif (mrioc->stop_drv_processing)\n\t\tgoto out;\n\n\tdev_handle = le16_to_cpu(evtdata->dev_handle);\n\n\tswitch (evtdata->reason_code) {\n\tcase MPI3_EVENT_DEV_STAT_RC_INT_DEVICE_RESET_STRT:\n\tcase MPI3_EVENT_DEV_STAT_RC_INT_IT_NEXUS_RESET_STRT:\n\t\tblock = 1;\n\t\tbreak;\n\tcase MPI3_EVENT_DEV_STAT_RC_HIDDEN:\n\t\tdelete = 1;\n\t\thide = 1;\n\t\tbreak;\n\tcase MPI3_EVENT_DEV_STAT_RC_VD_NOT_RESPONDING:\n\t\tdelete = 1;\n\t\tremove = 1;\n\t\tbreak;\n\tcase MPI3_EVENT_DEV_STAT_RC_INT_DEVICE_RESET_CMP:\n\tcase MPI3_EVENT_DEV_STAT_RC_INT_IT_NEXUS_RESET_CMP:\n\t\tublock = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttgtdev = mpi3mr_get_tgtdev_by_handle(mrioc, dev_handle);\n\tif (!tgtdev)\n\t\tgoto out;\n\tif (hide)\n\t\ttgtdev->is_hidden = hide;\n\tif (tgtdev->starget && tgtdev->starget->hostdata) {\n\t\tscsi_tgt_priv_data = (struct mpi3mr_stgt_priv_data *)\n\t\t    tgtdev->starget->hostdata;\n\t\tif (block)\n\t\t\tatomic_inc(&scsi_tgt_priv_data->block_io);\n\t\tif (delete)\n\t\t\tscsi_tgt_priv_data->dev_removed = 1;\n\t\tif (ublock)\n\t\t\tatomic_dec_if_positive(&scsi_tgt_priv_data->block_io);\n\t}\n\tif (remove)\n\t\tmpi3mr_dev_rmhs_send_tm(mrioc, dev_handle, NULL,\n\t\t    MPI3_CTRL_OP_REMOVE_DEVICE);\n\tif (hide)\n\t\tmpi3mr_dev_rmhs_send_tm(mrioc, dev_handle, NULL,\n\t\t    MPI3_CTRL_OP_HIDDEN_ACK);\n\nout:\n\tif (tgtdev)\n\t\tmpi3mr_tgtdev_put(tgtdev);\n}\n\n \nstatic void mpi3mr_preparereset_evt_th(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_event_notification_reply *event_reply)\n{\n\tstruct mpi3_event_data_prepare_for_reset *evtdata =\n\t    (struct mpi3_event_data_prepare_for_reset *)event_reply->event_data;\n\n\tif (evtdata->reason_code == MPI3_EVENT_PREPARE_RESET_RC_START) {\n\t\tdprint_event_th(mrioc,\n\t\t    \"prepare for reset event top half with rc=start\\n\");\n\t\tif (mrioc->prepare_for_reset)\n\t\t\treturn;\n\t\tmrioc->prepare_for_reset = 1;\n\t\tmrioc->prepare_for_reset_timeout_counter = 0;\n\t} else if (evtdata->reason_code == MPI3_EVENT_PREPARE_RESET_RC_ABORT) {\n\t\tdprint_event_th(mrioc,\n\t\t    \"prepare for reset top half with rc=abort\\n\");\n\t\tmrioc->prepare_for_reset = 0;\n\t\tmrioc->prepare_for_reset_timeout_counter = 0;\n\t}\n\tif ((event_reply->msg_flags & MPI3_EVENT_NOTIFY_MSGFLAGS_ACK_MASK)\n\t    == MPI3_EVENT_NOTIFY_MSGFLAGS_ACK_REQUIRED)\n\t\tmpi3mr_send_event_ack(mrioc, event_reply->event, NULL,\n\t\t    le32_to_cpu(event_reply->event_context));\n}\n\n \nstatic void mpi3mr_energypackchg_evt_th(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_event_notification_reply *event_reply)\n{\n\tstruct mpi3_event_data_energy_pack_change *evtdata =\n\t    (struct mpi3_event_data_energy_pack_change *)event_reply->event_data;\n\tu16 shutdown_timeout = le16_to_cpu(evtdata->shutdown_timeout);\n\n\tif (shutdown_timeout <= 0) {\n\t\tioc_warn(mrioc,\n\t\t    \"%s :Invalid Shutdown Timeout received = %d\\n\",\n\t\t    __func__, shutdown_timeout);\n\t\treturn;\n\t}\n\n\tioc_info(mrioc,\n\t    \"%s :Previous Shutdown Timeout Value = %d New Shutdown Timeout Value = %d\\n\",\n\t    __func__, mrioc->facts.shutdown_timeout, shutdown_timeout);\n\tmrioc->facts.shutdown_timeout = shutdown_timeout;\n}\n\n \nstatic void mpi3mr_cablemgmt_evt_th(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_event_notification_reply *event_reply)\n{\n\tstruct mpi3_event_data_cable_management *evtdata =\n\t    (struct mpi3_event_data_cable_management *)event_reply->event_data;\n\n\tswitch (evtdata->status) {\n\tcase MPI3_EVENT_CABLE_MGMT_STATUS_INSUFFICIENT_POWER:\n\t{\n\t\tioc_info(mrioc, \"An active cable with receptacle_id %d cannot be powered.\\n\"\n\t\t    \"Devices connected to this cable are not detected.\\n\"\n\t\t    \"This cable requires %d mW of power.\\n\",\n\t\t    evtdata->receptacle_id,\n\t\t    le32_to_cpu(evtdata->active_cable_power_requirement));\n\t\tbreak;\n\t}\n\tcase MPI3_EVENT_CABLE_MGMT_STATUS_DEGRADED:\n\t{\n\t\tioc_info(mrioc, \"A cable with receptacle_id %d is not running at optimal speed\\n\",\n\t\t    evtdata->receptacle_id);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nvoid mpi3mr_add_event_wait_for_device_refresh(struct mpi3mr_ioc *mrioc)\n{\n\tstruct mpi3mr_fwevt *fwevt = NULL;\n\n\tfwevt = mpi3mr_alloc_fwevt(0);\n\tif (!fwevt) {\n\t\tdprint_event_th(mrioc,\n\t\t    \"failed to schedule bottom half handler for event(0x%02x)\\n\",\n\t\t    MPI3_EVENT_WAIT_FOR_DEVICES_TO_REFRESH);\n\t\treturn;\n\t}\n\tfwevt->mrioc = mrioc;\n\tfwevt->event_id = MPI3_EVENT_WAIT_FOR_DEVICES_TO_REFRESH;\n\tfwevt->send_ack = 0;\n\tfwevt->process_evt = 1;\n\tfwevt->evt_ctx = 0;\n\tfwevt->event_data_size = 0;\n\tmpi3mr_fwevt_add_to_list(mrioc, fwevt);\n}\n\n \nvoid mpi3mr_os_handle_events(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_event_notification_reply *event_reply)\n{\n\tu16 evt_type, sz;\n\tstruct mpi3mr_fwevt *fwevt = NULL;\n\tbool ack_req = 0, process_evt_bh = 0;\n\n\tif (mrioc->stop_drv_processing)\n\t\treturn;\n\n\tif ((event_reply->msg_flags & MPI3_EVENT_NOTIFY_MSGFLAGS_ACK_MASK)\n\t    == MPI3_EVENT_NOTIFY_MSGFLAGS_ACK_REQUIRED)\n\t\tack_req = 1;\n\n\tevt_type = event_reply->event;\n\n\tswitch (evt_type) {\n\tcase MPI3_EVENT_DEVICE_ADDED:\n\t{\n\t\tstruct mpi3_device_page0 *dev_pg0 =\n\t\t    (struct mpi3_device_page0 *)event_reply->event_data;\n\t\tif (mpi3mr_create_tgtdev(mrioc, dev_pg0))\n\t\t\tioc_err(mrioc,\n\t\t\t    \"%s :Failed to add device in the device add event\\n\",\n\t\t\t    __func__);\n\t\telse\n\t\t\tprocess_evt_bh = 1;\n\t\tbreak;\n\t}\n\tcase MPI3_EVENT_DEVICE_STATUS_CHANGE:\n\t{\n\t\tprocess_evt_bh = 1;\n\t\tmpi3mr_devstatuschg_evt_th(mrioc, event_reply);\n\t\tbreak;\n\t}\n\tcase MPI3_EVENT_SAS_TOPOLOGY_CHANGE_LIST:\n\t{\n\t\tprocess_evt_bh = 1;\n\t\tmpi3mr_sastopochg_evt_th(mrioc, event_reply);\n\t\tbreak;\n\t}\n\tcase MPI3_EVENT_PCIE_TOPOLOGY_CHANGE_LIST:\n\t{\n\t\tprocess_evt_bh = 1;\n\t\tmpi3mr_pcietopochg_evt_th(mrioc, event_reply);\n\t\tbreak;\n\t}\n\tcase MPI3_EVENT_PREPARE_FOR_RESET:\n\t{\n\t\tmpi3mr_preparereset_evt_th(mrioc, event_reply);\n\t\tack_req = 0;\n\t\tbreak;\n\t}\n\tcase MPI3_EVENT_DEVICE_INFO_CHANGED:\n\tcase MPI3_EVENT_LOG_DATA:\n\tcase MPI3_EVENT_ENCL_DEVICE_STATUS_CHANGE:\n\tcase MPI3_EVENT_ENCL_DEVICE_ADDED:\n\t{\n\t\tprocess_evt_bh = 1;\n\t\tbreak;\n\t}\n\tcase MPI3_EVENT_ENERGY_PACK_CHANGE:\n\t{\n\t\tmpi3mr_energypackchg_evt_th(mrioc, event_reply);\n\t\tbreak;\n\t}\n\tcase MPI3_EVENT_CABLE_MGMT:\n\t{\n\t\tmpi3mr_cablemgmt_evt_th(mrioc, event_reply);\n\t\tbreak;\n\t}\n\tcase MPI3_EVENT_SAS_DISCOVERY:\n\tcase MPI3_EVENT_SAS_DEVICE_DISCOVERY_ERROR:\n\tcase MPI3_EVENT_SAS_BROADCAST_PRIMITIVE:\n\tcase MPI3_EVENT_PCIE_ENUMERATION:\n\t\tbreak;\n\tdefault:\n\t\tioc_info(mrioc, \"%s :event 0x%02x is not handled\\n\",\n\t\t    __func__, evt_type);\n\t\tbreak;\n\t}\n\tif (process_evt_bh || ack_req) {\n\t\tsz = event_reply->event_data_length * 4;\n\t\tfwevt = mpi3mr_alloc_fwevt(sz);\n\t\tif (!fwevt) {\n\t\t\tioc_info(mrioc, \"%s :failure at %s:%d/%s()!\\n\",\n\t\t\t    __func__, __FILE__, __LINE__, __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tmemcpy(fwevt->event_data, event_reply->event_data, sz);\n\t\tfwevt->mrioc = mrioc;\n\t\tfwevt->event_id = evt_type;\n\t\tfwevt->send_ack = ack_req;\n\t\tfwevt->process_evt = process_evt_bh;\n\t\tfwevt->evt_ctx = le32_to_cpu(event_reply->event_context);\n\t\tmpi3mr_fwevt_add_to_list(mrioc, fwevt);\n\t}\n}\n\n \nstatic void mpi3mr_setup_eedp(struct mpi3mr_ioc *mrioc,\n\tstruct scsi_cmnd *scmd, struct mpi3_scsi_io_request *scsiio_req)\n{\n\tu16 eedp_flags = 0;\n\tunsigned char prot_op = scsi_get_prot_op(scmd);\n\n\tswitch (prot_op) {\n\tcase SCSI_PROT_NORMAL:\n\t\treturn;\n\tcase SCSI_PROT_READ_STRIP:\n\t\teedp_flags = MPI3_EEDPFLAGS_EEDP_OP_CHECK_REMOVE;\n\t\tbreak;\n\tcase SCSI_PROT_WRITE_INSERT:\n\t\teedp_flags = MPI3_EEDPFLAGS_EEDP_OP_INSERT;\n\t\tbreak;\n\tcase SCSI_PROT_READ_INSERT:\n\t\teedp_flags = MPI3_EEDPFLAGS_EEDP_OP_INSERT;\n\t\tscsiio_req->msg_flags |= MPI3_SCSIIO_MSGFLAGS_METASGL_VALID;\n\t\tbreak;\n\tcase SCSI_PROT_WRITE_STRIP:\n\t\teedp_flags = MPI3_EEDPFLAGS_EEDP_OP_CHECK_REMOVE;\n\t\tscsiio_req->msg_flags |= MPI3_SCSIIO_MSGFLAGS_METASGL_VALID;\n\t\tbreak;\n\tcase SCSI_PROT_READ_PASS:\n\t\teedp_flags = MPI3_EEDPFLAGS_EEDP_OP_CHECK;\n\t\tscsiio_req->msg_flags |= MPI3_SCSIIO_MSGFLAGS_METASGL_VALID;\n\t\tbreak;\n\tcase SCSI_PROT_WRITE_PASS:\n\t\tif (scmd->prot_flags & SCSI_PROT_IP_CHECKSUM) {\n\t\t\teedp_flags = MPI3_EEDPFLAGS_EEDP_OP_CHECK_REGEN;\n\t\t\tscsiio_req->sgl[0].eedp.application_tag_translation_mask =\n\t\t\t    0xffff;\n\t\t} else\n\t\t\teedp_flags = MPI3_EEDPFLAGS_EEDP_OP_CHECK;\n\n\t\tscsiio_req->msg_flags |= MPI3_SCSIIO_MSGFLAGS_METASGL_VALID;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (scmd->prot_flags & SCSI_PROT_GUARD_CHECK)\n\t\teedp_flags |= MPI3_EEDPFLAGS_CHK_GUARD;\n\n\tif (scmd->prot_flags & SCSI_PROT_IP_CHECKSUM)\n\t\teedp_flags |= MPI3_EEDPFLAGS_HOST_GUARD_IP_CHKSUM;\n\n\tif (scmd->prot_flags & SCSI_PROT_REF_CHECK) {\n\t\teedp_flags |= MPI3_EEDPFLAGS_CHK_REF_TAG |\n\t\t\tMPI3_EEDPFLAGS_INCR_PRI_REF_TAG;\n\t\tscsiio_req->cdb.eedp32.primary_reference_tag =\n\t\t\tcpu_to_be32(scsi_prot_ref_tag(scmd));\n\t}\n\n\tif (scmd->prot_flags & SCSI_PROT_REF_INCREMENT)\n\t\teedp_flags |= MPI3_EEDPFLAGS_INCR_PRI_REF_TAG;\n\n\teedp_flags |= MPI3_EEDPFLAGS_ESC_MODE_APPTAG_DISABLE;\n\n\tswitch (scsi_prot_interval(scmd)) {\n\tcase 512:\n\t\tscsiio_req->sgl[0].eedp.user_data_size = MPI3_EEDP_UDS_512;\n\t\tbreak;\n\tcase 520:\n\t\tscsiio_req->sgl[0].eedp.user_data_size = MPI3_EEDP_UDS_520;\n\t\tbreak;\n\tcase 4080:\n\t\tscsiio_req->sgl[0].eedp.user_data_size = MPI3_EEDP_UDS_4080;\n\t\tbreak;\n\tcase 4088:\n\t\tscsiio_req->sgl[0].eedp.user_data_size = MPI3_EEDP_UDS_4088;\n\t\tbreak;\n\tcase 4096:\n\t\tscsiio_req->sgl[0].eedp.user_data_size = MPI3_EEDP_UDS_4096;\n\t\tbreak;\n\tcase 4104:\n\t\tscsiio_req->sgl[0].eedp.user_data_size = MPI3_EEDP_UDS_4104;\n\t\tbreak;\n\tcase 4160:\n\t\tscsiio_req->sgl[0].eedp.user_data_size = MPI3_EEDP_UDS_4160;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tscsiio_req->sgl[0].eedp.eedp_flags = cpu_to_le16(eedp_flags);\n\tscsiio_req->sgl[0].eedp.flags = MPI3_SGE_FLAGS_ELEMENT_TYPE_EXTENDED;\n}\n\n \nstatic inline void mpi3mr_build_sense_buffer(int desc, u8 *buf, u8 key,\n\tu8 asc, u8 ascq)\n{\n\tif (desc) {\n\t\tbuf[0] = 0x72;\t \n\t\tbuf[1] = key;\n\t\tbuf[2] = asc;\n\t\tbuf[3] = ascq;\n\t\tbuf[7] = 0;\n\t} else {\n\t\tbuf[0] = 0x70;\t \n\t\tbuf[2] = key;\n\t\tbuf[7] = 0xa;\n\t\tbuf[12] = asc;\n\t\tbuf[13] = ascq;\n\t}\n}\n\n \nstatic void mpi3mr_map_eedp_error(struct scsi_cmnd *scmd,\n\tu16 ioc_status)\n{\n\tu8 ascq = 0;\n\n\tswitch (ioc_status) {\n\tcase MPI3_IOCSTATUS_EEDP_GUARD_ERROR:\n\t\tascq = 0x01;\n\t\tbreak;\n\tcase MPI3_IOCSTATUS_EEDP_APP_TAG_ERROR:\n\t\tascq = 0x02;\n\t\tbreak;\n\tcase MPI3_IOCSTATUS_EEDP_REF_TAG_ERROR:\n\t\tascq = 0x03;\n\t\tbreak;\n\tdefault:\n\t\tascq = 0x00;\n\t\tbreak;\n\t}\n\n\tmpi3mr_build_sense_buffer(0, scmd->sense_buffer, ILLEGAL_REQUEST,\n\t    0x10, ascq);\n\tscmd->result = (DID_ABORT << 16) | SAM_STAT_CHECK_CONDITION;\n}\n\n \nvoid mpi3mr_process_op_reply_desc(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_default_reply_descriptor *reply_desc, u64 *reply_dma, u16 qidx)\n{\n\tu16 reply_desc_type, host_tag = 0;\n\tu16 ioc_status = MPI3_IOCSTATUS_SUCCESS;\n\tu32 ioc_loginfo = 0;\n\tstruct mpi3_status_reply_descriptor *status_desc = NULL;\n\tstruct mpi3_address_reply_descriptor *addr_desc = NULL;\n\tstruct mpi3_success_reply_descriptor *success_desc = NULL;\n\tstruct mpi3_scsi_io_reply *scsi_reply = NULL;\n\tstruct scsi_cmnd *scmd = NULL;\n\tstruct scmd_priv *priv = NULL;\n\tu8 *sense_buf = NULL;\n\tu8 scsi_state = 0, scsi_status = 0, sense_state = 0;\n\tu32 xfer_count = 0, sense_count = 0, resp_data = 0;\n\tu16 dev_handle = 0xFFFF;\n\tstruct scsi_sense_hdr sshdr;\n\tstruct mpi3mr_stgt_priv_data *stgt_priv_data = NULL;\n\tstruct mpi3mr_sdev_priv_data *sdev_priv_data = NULL;\n\tu32 ioc_pend_data_len = 0, tg_pend_data_len = 0, data_len_blks = 0;\n\tstruct mpi3mr_throttle_group_info *tg = NULL;\n\tu8 throttle_enabled_dev = 0;\n\n\t*reply_dma = 0;\n\treply_desc_type = le16_to_cpu(reply_desc->reply_flags) &\n\t    MPI3_REPLY_DESCRIPT_FLAGS_TYPE_MASK;\n\tswitch (reply_desc_type) {\n\tcase MPI3_REPLY_DESCRIPT_FLAGS_TYPE_STATUS:\n\t\tstatus_desc = (struct mpi3_status_reply_descriptor *)reply_desc;\n\t\thost_tag = le16_to_cpu(status_desc->host_tag);\n\t\tioc_status = le16_to_cpu(status_desc->ioc_status);\n\t\tif (ioc_status &\n\t\t    MPI3_REPLY_DESCRIPT_STATUS_IOCSTATUS_LOGINFOAVAIL)\n\t\t\tioc_loginfo = le32_to_cpu(status_desc->ioc_log_info);\n\t\tioc_status &= MPI3_REPLY_DESCRIPT_STATUS_IOCSTATUS_STATUS_MASK;\n\t\tbreak;\n\tcase MPI3_REPLY_DESCRIPT_FLAGS_TYPE_ADDRESS_REPLY:\n\t\taddr_desc = (struct mpi3_address_reply_descriptor *)reply_desc;\n\t\t*reply_dma = le64_to_cpu(addr_desc->reply_frame_address);\n\t\tscsi_reply = mpi3mr_get_reply_virt_addr(mrioc,\n\t\t    *reply_dma);\n\t\tif (!scsi_reply) {\n\t\t\tpanic(\"%s: scsi_reply is NULL, this shouldn't happen\\n\",\n\t\t\t    mrioc->name);\n\t\t\tgoto out;\n\t\t}\n\t\thost_tag = le16_to_cpu(scsi_reply->host_tag);\n\t\tioc_status = le16_to_cpu(scsi_reply->ioc_status);\n\t\tscsi_status = scsi_reply->scsi_status;\n\t\tscsi_state = scsi_reply->scsi_state;\n\t\tdev_handle = le16_to_cpu(scsi_reply->dev_handle);\n\t\tsense_state = (scsi_state & MPI3_SCSI_STATE_SENSE_MASK);\n\t\txfer_count = le32_to_cpu(scsi_reply->transfer_count);\n\t\tsense_count = le32_to_cpu(scsi_reply->sense_count);\n\t\tresp_data = le32_to_cpu(scsi_reply->response_data);\n\t\tsense_buf = mpi3mr_get_sensebuf_virt_addr(mrioc,\n\t\t    le64_to_cpu(scsi_reply->sense_data_buffer_address));\n\t\tif (ioc_status &\n\t\t    MPI3_REPLY_DESCRIPT_STATUS_IOCSTATUS_LOGINFOAVAIL)\n\t\t\tioc_loginfo = le32_to_cpu(scsi_reply->ioc_log_info);\n\t\tioc_status &= MPI3_REPLY_DESCRIPT_STATUS_IOCSTATUS_STATUS_MASK;\n\t\tif (sense_state == MPI3_SCSI_STATE_SENSE_BUFF_Q_EMPTY)\n\t\t\tpanic(\"%s: Ran out of sense buffers\\n\", mrioc->name);\n\t\tbreak;\n\tcase MPI3_REPLY_DESCRIPT_FLAGS_TYPE_SUCCESS:\n\t\tsuccess_desc = (struct mpi3_success_reply_descriptor *)reply_desc;\n\t\thost_tag = le16_to_cpu(success_desc->host_tag);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tscmd = mpi3mr_scmd_from_host_tag(mrioc, host_tag, qidx);\n\tif (!scmd) {\n\t\tpanic(\"%s: Cannot Identify scmd for host_tag 0x%x\\n\",\n\t\t    mrioc->name, host_tag);\n\t\tgoto out;\n\t}\n\tpriv = scsi_cmd_priv(scmd);\n\n\tdata_len_blks = scsi_bufflen(scmd) >> 9;\n\tsdev_priv_data = scmd->device->hostdata;\n\tif (sdev_priv_data) {\n\t\tstgt_priv_data = sdev_priv_data->tgt_priv_data;\n\t\tif (stgt_priv_data) {\n\t\t\ttg = stgt_priv_data->throttle_group;\n\t\t\tthrottle_enabled_dev =\n\t\t\t    stgt_priv_data->io_throttle_enabled;\n\t\t}\n\t}\n\tif (unlikely((data_len_blks >= mrioc->io_throttle_data_length) &&\n\t    throttle_enabled_dev)) {\n\t\tioc_pend_data_len = atomic_sub_return(data_len_blks,\n\t\t    &mrioc->pend_large_data_sz);\n\t\tif (tg) {\n\t\t\ttg_pend_data_len = atomic_sub_return(data_len_blks,\n\t\t\t    &tg->pend_large_data_sz);\n\t\t\tif (tg->io_divert  && ((ioc_pend_data_len <=\n\t\t\t    mrioc->io_throttle_low) &&\n\t\t\t    (tg_pend_data_len <= tg->low))) {\n\t\t\t\ttg->io_divert = 0;\n\t\t\t\tmpi3mr_set_io_divert_for_all_vd_in_tg(\n\t\t\t\t    mrioc, tg, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tif (ioc_pend_data_len <= mrioc->io_throttle_low)\n\t\t\t\tstgt_priv_data->io_divert = 0;\n\t\t}\n\t} else if (unlikely((stgt_priv_data && stgt_priv_data->io_divert))) {\n\t\tioc_pend_data_len = atomic_read(&mrioc->pend_large_data_sz);\n\t\tif (!tg) {\n\t\t\tif (ioc_pend_data_len <= mrioc->io_throttle_low)\n\t\t\t\tstgt_priv_data->io_divert = 0;\n\n\t\t} else if (ioc_pend_data_len <= mrioc->io_throttle_low) {\n\t\t\ttg_pend_data_len = atomic_read(&tg->pend_large_data_sz);\n\t\t\tif (tg->io_divert  && (tg_pend_data_len <= tg->low)) {\n\t\t\t\ttg->io_divert = 0;\n\t\t\t\tmpi3mr_set_io_divert_for_all_vd_in_tg(\n\t\t\t\t    mrioc, tg, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (success_desc) {\n\t\tscmd->result = DID_OK << 16;\n\t\tgoto out_success;\n\t}\n\n\tscsi_set_resid(scmd, scsi_bufflen(scmd) - xfer_count);\n\tif (ioc_status == MPI3_IOCSTATUS_SCSI_DATA_UNDERRUN &&\n\t    xfer_count == 0 && (scsi_status == MPI3_SCSI_STATUS_BUSY ||\n\t    scsi_status == MPI3_SCSI_STATUS_RESERVATION_CONFLICT ||\n\t    scsi_status == MPI3_SCSI_STATUS_TASK_SET_FULL))\n\t\tioc_status = MPI3_IOCSTATUS_SUCCESS;\n\n\tif ((sense_state == MPI3_SCSI_STATE_SENSE_VALID) && sense_count &&\n\t    sense_buf) {\n\t\tu32 sz = min_t(u32, SCSI_SENSE_BUFFERSIZE, sense_count);\n\n\t\tmemcpy(scmd->sense_buffer, sense_buf, sz);\n\t}\n\n\tswitch (ioc_status) {\n\tcase MPI3_IOCSTATUS_BUSY:\n\tcase MPI3_IOCSTATUS_INSUFFICIENT_RESOURCES:\n\t\tscmd->result = SAM_STAT_BUSY;\n\t\tbreak;\n\tcase MPI3_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tbreak;\n\tcase MPI3_IOCSTATUS_SCSI_IOC_TERMINATED:\n\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\tbreak;\n\tcase MPI3_IOCSTATUS_SCSI_TASK_TERMINATED:\n\tcase MPI3_IOCSTATUS_SCSI_EXT_TERMINATED:\n\t\tscmd->result = DID_RESET << 16;\n\t\tbreak;\n\tcase MPI3_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:\n\t\tif ((xfer_count == 0) || (scmd->underflow > xfer_count))\n\t\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\telse\n\t\t\tscmd->result = (DID_OK << 16) | scsi_status;\n\t\tbreak;\n\tcase MPI3_IOCSTATUS_SCSI_DATA_UNDERRUN:\n\t\tscmd->result = (DID_OK << 16) | scsi_status;\n\t\tif (sense_state == MPI3_SCSI_STATE_SENSE_VALID)\n\t\t\tbreak;\n\t\tif (xfer_count < scmd->underflow) {\n\t\t\tif (scsi_status == SAM_STAT_BUSY)\n\t\t\t\tscmd->result = SAM_STAT_BUSY;\n\t\t\telse\n\t\t\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\t} else if ((scsi_state & (MPI3_SCSI_STATE_NO_SCSI_STATUS)) ||\n\t\t    (sense_state != MPI3_SCSI_STATE_SENSE_NOT_AVAILABLE))\n\t\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\telse if (scsi_state & MPI3_SCSI_STATE_TERMINATED)\n\t\t\tscmd->result = DID_RESET << 16;\n\t\tbreak;\n\tcase MPI3_IOCSTATUS_SCSI_DATA_OVERRUN:\n\t\tscsi_set_resid(scmd, 0);\n\t\tfallthrough;\n\tcase MPI3_IOCSTATUS_SCSI_RECOVERED_ERROR:\n\tcase MPI3_IOCSTATUS_SUCCESS:\n\t\tscmd->result = (DID_OK << 16) | scsi_status;\n\t\tif ((scsi_state & (MPI3_SCSI_STATE_NO_SCSI_STATUS)) ||\n\t\t    (sense_state == MPI3_SCSI_STATE_SENSE_FAILED) ||\n\t\t\t(sense_state == MPI3_SCSI_STATE_SENSE_BUFF_Q_EMPTY))\n\t\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\telse if (scsi_state & MPI3_SCSI_STATE_TERMINATED)\n\t\t\tscmd->result = DID_RESET << 16;\n\t\tbreak;\n\tcase MPI3_IOCSTATUS_EEDP_GUARD_ERROR:\n\tcase MPI3_IOCSTATUS_EEDP_REF_TAG_ERROR:\n\tcase MPI3_IOCSTATUS_EEDP_APP_TAG_ERROR:\n\t\tmpi3mr_map_eedp_error(scmd, ioc_status);\n\t\tbreak;\n\tcase MPI3_IOCSTATUS_SCSI_PROTOCOL_ERROR:\n\tcase MPI3_IOCSTATUS_INVALID_FUNCTION:\n\tcase MPI3_IOCSTATUS_INVALID_SGL:\n\tcase MPI3_IOCSTATUS_INTERNAL_ERROR:\n\tcase MPI3_IOCSTATUS_INVALID_FIELD:\n\tcase MPI3_IOCSTATUS_INVALID_STATE:\n\tcase MPI3_IOCSTATUS_SCSI_IO_DATA_ERROR:\n\tcase MPI3_IOCSTATUS_SCSI_TASK_MGMT_FAILED:\n\tcase MPI3_IOCSTATUS_INSUFFICIENT_POWER:\n\tdefault:\n\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\tbreak;\n\t}\n\n\tif (scmd->result != (DID_OK << 16) && (scmd->cmnd[0] != ATA_12) &&\n\t    (scmd->cmnd[0] != ATA_16) &&\n\t    mrioc->logging_level & MPI3_DEBUG_SCSI_ERROR) {\n\t\tioc_info(mrioc, \"%s :scmd->result 0x%x\\n\", __func__,\n\t\t    scmd->result);\n\t\tscsi_print_command(scmd);\n\t\tioc_info(mrioc,\n\t\t    \"%s :Command issued to handle 0x%02x returned with error 0x%04x loginfo 0x%08x, qid %d\\n\",\n\t\t    __func__, dev_handle, ioc_status, ioc_loginfo,\n\t\t    priv->req_q_idx + 1);\n\t\tioc_info(mrioc,\n\t\t    \" host_tag %d scsi_state 0x%02x scsi_status 0x%02x, xfer_cnt %d resp_data 0x%x\\n\",\n\t\t    host_tag, scsi_state, scsi_status, xfer_count, resp_data);\n\t\tif (sense_buf) {\n\t\t\tscsi_normalize_sense(sense_buf, sense_count, &sshdr);\n\t\t\tioc_info(mrioc,\n\t\t\t    \"%s :sense_count 0x%x, sense_key 0x%x ASC 0x%x, ASCQ 0x%x\\n\",\n\t\t\t    __func__, sense_count, sshdr.sense_key,\n\t\t\t    sshdr.asc, sshdr.ascq);\n\t\t}\n\t}\nout_success:\n\tif (priv->meta_sg_valid) {\n\t\tdma_unmap_sg(&mrioc->pdev->dev, scsi_prot_sglist(scmd),\n\t\t    scsi_prot_sg_count(scmd), scmd->sc_data_direction);\n\t}\n\tmpi3mr_clear_scmd_priv(mrioc, scmd);\n\tscsi_dma_unmap(scmd);\n\tscsi_done(scmd);\nout:\n\tif (sense_buf)\n\t\tmpi3mr_repost_sense_buf(mrioc,\n\t\t    le64_to_cpu(scsi_reply->sense_data_buffer_address));\n}\n\n \nstatic int mpi3mr_get_chain_idx(struct mpi3mr_ioc *mrioc)\n{\n\tu8 retry_count = 5;\n\tint cmd_idx = -1;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mrioc->chain_buf_lock, flags);\n\tdo {\n\t\tcmd_idx = find_first_zero_bit(mrioc->chain_bitmap,\n\t\t    mrioc->chain_buf_count);\n\t\tif (cmd_idx < mrioc->chain_buf_count) {\n\t\t\tset_bit(cmd_idx, mrioc->chain_bitmap);\n\t\t\tbreak;\n\t\t}\n\t\tcmd_idx = -1;\n\t} while (retry_count--);\n\tspin_unlock_irqrestore(&mrioc->chain_buf_lock, flags);\n\treturn cmd_idx;\n}\n\n \nstatic int mpi3mr_prepare_sg_scmd(struct mpi3mr_ioc *mrioc,\n\tstruct scsi_cmnd *scmd, struct mpi3_scsi_io_request *scsiio_req)\n{\n\tdma_addr_t chain_dma;\n\tstruct scatterlist *sg_scmd;\n\tvoid *sg_local, *chain;\n\tu32 chain_length;\n\tint sges_left, chain_idx;\n\tu32 sges_in_segment;\n\tu8 simple_sgl_flags;\n\tu8 simple_sgl_flags_last;\n\tu8 last_chain_sgl_flags;\n\tstruct chain_element *chain_req;\n\tstruct scmd_priv *priv = NULL;\n\tu32 meta_sg = le32_to_cpu(scsiio_req->flags) &\n\t    MPI3_SCSIIO_FLAGS_DMAOPERATION_HOST_PI;\n\n\tpriv = scsi_cmd_priv(scmd);\n\n\tsimple_sgl_flags = MPI3_SGE_FLAGS_ELEMENT_TYPE_SIMPLE |\n\t    MPI3_SGE_FLAGS_DLAS_SYSTEM;\n\tsimple_sgl_flags_last = simple_sgl_flags |\n\t    MPI3_SGE_FLAGS_END_OF_LIST;\n\tlast_chain_sgl_flags = MPI3_SGE_FLAGS_ELEMENT_TYPE_LAST_CHAIN |\n\t    MPI3_SGE_FLAGS_DLAS_SYSTEM;\n\n\tif (meta_sg)\n\t\tsg_local = &scsiio_req->sgl[MPI3_SCSIIO_METASGL_INDEX];\n\telse\n\t\tsg_local = &scsiio_req->sgl;\n\n\tif (!scsiio_req->data_length && !meta_sg) {\n\t\tmpi3mr_build_zero_len_sge(sg_local);\n\t\treturn 0;\n\t}\n\n\tif (meta_sg) {\n\t\tsg_scmd = scsi_prot_sglist(scmd);\n\t\tsges_left = dma_map_sg(&mrioc->pdev->dev,\n\t\t    scsi_prot_sglist(scmd),\n\t\t    scsi_prot_sg_count(scmd),\n\t\t    scmd->sc_data_direction);\n\t\tpriv->meta_sg_valid = 1;  \n\t} else {\n\t\tsg_scmd = scsi_sglist(scmd);\n\t\tsges_left = scsi_dma_map(scmd);\n\t}\n\n\tif (sges_left < 0) {\n\t\tsdev_printk(KERN_ERR, scmd->device,\n\t\t    \"scsi_dma_map failed: request for %d bytes!\\n\",\n\t\t    scsi_bufflen(scmd));\n\t\treturn -ENOMEM;\n\t}\n\tif (sges_left > mrioc->max_sgl_entries) {\n\t\tsdev_printk(KERN_ERR, scmd->device,\n\t\t    \"scsi_dma_map returned unsupported sge count %d!\\n\",\n\t\t    sges_left);\n\t\treturn -ENOMEM;\n\t}\n\n\tsges_in_segment = (mrioc->facts.op_req_sz -\n\t    offsetof(struct mpi3_scsi_io_request, sgl)) / sizeof(struct mpi3_sge_common);\n\n\tif (scsiio_req->sgl[0].eedp.flags ==\n\t    MPI3_SGE_FLAGS_ELEMENT_TYPE_EXTENDED && !meta_sg) {\n\t\tsg_local += sizeof(struct mpi3_sge_common);\n\t\tsges_in_segment--;\n\t\t \n\t}\n\n\tif (scsiio_req->msg_flags ==\n\t    MPI3_SCSIIO_MSGFLAGS_METASGL_VALID && !meta_sg) {\n\t\tsges_in_segment--;\n\t\t \n\t}\n\n\tif (meta_sg)\n\t\tsges_in_segment = 1;\n\n\tif (sges_left <= sges_in_segment)\n\t\tgoto fill_in_last_segment;\n\n\t \n\twhile (sges_in_segment > 1) {\n\t\tmpi3mr_add_sg_single(sg_local, simple_sgl_flags,\n\t\t    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsg_local += sizeof(struct mpi3_sge_common);\n\t\tsges_left--;\n\t\tsges_in_segment--;\n\t}\n\n\tchain_idx = mpi3mr_get_chain_idx(mrioc);\n\tif (chain_idx < 0)\n\t\treturn -1;\n\tchain_req = &mrioc->chain_sgl_list[chain_idx];\n\tif (meta_sg)\n\t\tpriv->meta_chain_idx = chain_idx;\n\telse\n\t\tpriv->chain_idx = chain_idx;\n\n\tchain = chain_req->addr;\n\tchain_dma = chain_req->dma_addr;\n\tsges_in_segment = sges_left;\n\tchain_length = sges_in_segment * sizeof(struct mpi3_sge_common);\n\n\tmpi3mr_add_sg_single(sg_local, last_chain_sgl_flags,\n\t    chain_length, chain_dma);\n\n\tsg_local = chain;\n\nfill_in_last_segment:\n\twhile (sges_left > 0) {\n\t\tif (sges_left == 1)\n\t\t\tmpi3mr_add_sg_single(sg_local,\n\t\t\t    simple_sgl_flags_last, sg_dma_len(sg_scmd),\n\t\t\t    sg_dma_address(sg_scmd));\n\t\telse\n\t\t\tmpi3mr_add_sg_single(sg_local, simple_sgl_flags,\n\t\t\t    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsg_local += sizeof(struct mpi3_sge_common);\n\t\tsges_left--;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mpi3mr_build_sg_scmd(struct mpi3mr_ioc *mrioc,\n\tstruct scsi_cmnd *scmd, struct mpi3_scsi_io_request *scsiio_req)\n{\n\tint ret;\n\n\tret = mpi3mr_prepare_sg_scmd(mrioc, scmd, scsiio_req);\n\tif (ret)\n\t\treturn ret;\n\n\tif (scsiio_req->msg_flags == MPI3_SCSIIO_MSGFLAGS_METASGL_VALID) {\n\t\t \n\t\tscsiio_req->flags |=\n\t\t    cpu_to_le32(MPI3_SCSIIO_FLAGS_DMAOPERATION_HOST_PI);\n\t\tret = mpi3mr_prepare_sg_scmd(mrioc, scmd, scsiio_req);\n\t}\n\n\treturn ret;\n}\n\n \nstatic const char *mpi3mr_tm_response_name(u8 resp_code)\n{\n\tchar *desc;\n\n\tswitch (resp_code) {\n\tcase MPI3_SCSITASKMGMT_RSPCODE_TM_COMPLETE:\n\t\tdesc = \"task management request completed\";\n\t\tbreak;\n\tcase MPI3_SCSITASKMGMT_RSPCODE_INVALID_FRAME:\n\t\tdesc = \"invalid frame\";\n\t\tbreak;\n\tcase MPI3_SCSITASKMGMT_RSPCODE_TM_FUNCTION_NOT_SUPPORTED:\n\t\tdesc = \"task management request not supported\";\n\t\tbreak;\n\tcase MPI3_SCSITASKMGMT_RSPCODE_TM_FAILED:\n\t\tdesc = \"task management request failed\";\n\t\tbreak;\n\tcase MPI3_SCSITASKMGMT_RSPCODE_TM_SUCCEEDED:\n\t\tdesc = \"task management request succeeded\";\n\t\tbreak;\n\tcase MPI3_SCSITASKMGMT_RSPCODE_TM_INVALID_LUN:\n\t\tdesc = \"invalid LUN\";\n\t\tbreak;\n\tcase MPI3_SCSITASKMGMT_RSPCODE_TM_OVERLAPPED_TAG:\n\t\tdesc = \"overlapped tag attempted\";\n\t\tbreak;\n\tcase MPI3_SCSITASKMGMT_RSPCODE_IO_QUEUED_ON_IOC:\n\t\tdesc = \"task queued, however not sent to target\";\n\t\tbreak;\n\tcase MPI3_SCSITASKMGMT_RSPCODE_TM_NVME_DENIED:\n\t\tdesc = \"task management request denied by NVMe device\";\n\t\tbreak;\n\tdefault:\n\t\tdesc = \"unknown\";\n\t\tbreak;\n\t}\n\n\treturn desc;\n}\n\ninline void mpi3mr_poll_pend_io_completions(struct mpi3mr_ioc *mrioc)\n{\n\tint i;\n\tint num_of_reply_queues =\n\t    mrioc->num_op_reply_q + mrioc->op_reply_q_offset;\n\n\tfor (i = mrioc->op_reply_q_offset; i < num_of_reply_queues; i++)\n\t\tmpi3mr_process_op_reply_q(mrioc,\n\t\t    mrioc->intr_info[i].op_reply_q);\n}\n\n \nint mpi3mr_issue_tm(struct mpi3mr_ioc *mrioc, u8 tm_type,\n\tu16 handle, uint lun, u16 htag, ulong timeout,\n\tstruct mpi3mr_drv_cmd *drv_cmd,\n\tu8 *resp_code, struct scsi_cmnd *scmd)\n{\n\tstruct mpi3_scsi_task_mgmt_request tm_req;\n\tstruct mpi3_scsi_task_mgmt_reply *tm_reply = NULL;\n\tint retval = 0;\n\tstruct mpi3mr_tgt_dev *tgtdev = NULL;\n\tstruct mpi3mr_stgt_priv_data *scsi_tgt_priv_data = NULL;\n\tstruct scmd_priv *cmd_priv = NULL;\n\tstruct scsi_device *sdev = NULL;\n\tstruct mpi3mr_sdev_priv_data *sdev_priv_data = NULL;\n\n\tioc_info(mrioc, \"%s :Issue TM: TM type (0x%x) for devhandle 0x%04x\\n\",\n\t     __func__, tm_type, handle);\n\tif (mrioc->unrecoverable) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"%s :Issue TM: Unrecoverable controller\\n\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tmemset(&tm_req, 0, sizeof(tm_req));\n\tmutex_lock(&drv_cmd->mutex);\n\tif (drv_cmd->state & MPI3MR_CMD_PENDING) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"%s :Issue TM: Command is in use\\n\", __func__);\n\t\tmutex_unlock(&drv_cmd->mutex);\n\t\tgoto out;\n\t}\n\tif (mrioc->reset_in_progress) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"%s :Issue TM: Reset in progress\\n\", __func__);\n\t\tmutex_unlock(&drv_cmd->mutex);\n\t\tgoto out;\n\t}\n\n\tdrv_cmd->state = MPI3MR_CMD_PENDING;\n\tdrv_cmd->is_waiting = 1;\n\tdrv_cmd->callback = NULL;\n\ttm_req.dev_handle = cpu_to_le16(handle);\n\ttm_req.task_type = tm_type;\n\ttm_req.host_tag = cpu_to_le16(htag);\n\n\tint_to_scsilun(lun, (struct scsi_lun *)tm_req.lun);\n\ttm_req.function = MPI3_FUNCTION_SCSI_TASK_MGMT;\n\n\ttgtdev = mpi3mr_get_tgtdev_by_handle(mrioc, handle);\n\n\tif (scmd) {\n\t\tsdev = scmd->device;\n\t\tsdev_priv_data = sdev->hostdata;\n\t\tscsi_tgt_priv_data = ((sdev_priv_data) ?\n\t\t    sdev_priv_data->tgt_priv_data : NULL);\n\t} else {\n\t\tif (tgtdev && tgtdev->starget && tgtdev->starget->hostdata)\n\t\t\tscsi_tgt_priv_data = (struct mpi3mr_stgt_priv_data *)\n\t\t\t    tgtdev->starget->hostdata;\n\t}\n\n\tif (scsi_tgt_priv_data)\n\t\tatomic_inc(&scsi_tgt_priv_data->block_io);\n\n\tif (tgtdev && (tgtdev->dev_type == MPI3_DEVICE_DEVFORM_PCIE)) {\n\t\tif (cmd_priv && tgtdev->dev_spec.pcie_inf.abort_to)\n\t\t\ttimeout = tgtdev->dev_spec.pcie_inf.abort_to;\n\t\telse if (!cmd_priv && tgtdev->dev_spec.pcie_inf.reset_to)\n\t\t\ttimeout = tgtdev->dev_spec.pcie_inf.reset_to;\n\t}\n\n\tinit_completion(&drv_cmd->done);\n\tretval = mpi3mr_admin_request_post(mrioc, &tm_req, sizeof(tm_req), 1);\n\tif (retval) {\n\t\tioc_err(mrioc, \"%s :Issue TM: Admin Post failed\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\twait_for_completion_timeout(&drv_cmd->done, (timeout * HZ));\n\n\tif (!(drv_cmd->state & MPI3MR_CMD_COMPLETE)) {\n\t\tdrv_cmd->is_waiting = 0;\n\t\tretval = -1;\n\t\tif (!(drv_cmd->state & MPI3MR_CMD_RESET)) {\n\t\t\tdprint_tm(mrioc,\n\t\t\t    \"task management request timed out after %ld seconds\\n\",\n\t\t\t    timeout);\n\t\t\tif (mrioc->logging_level & MPI3_DEBUG_TM)\n\t\t\t\tdprint_dump_req(&tm_req, sizeof(tm_req)/4);\n\t\t\tmpi3mr_soft_reset_handler(mrioc,\n\t\t\t    MPI3MR_RESET_FROM_TM_TIMEOUT, 1);\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\n\tif (!(drv_cmd->state & MPI3MR_CMD_REPLY_VALID)) {\n\t\tdprint_tm(mrioc, \"invalid task management reply message\\n\");\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\n\ttm_reply = (struct mpi3_scsi_task_mgmt_reply *)drv_cmd->reply;\n\n\tswitch (drv_cmd->ioc_status) {\n\tcase MPI3_IOCSTATUS_SUCCESS:\n\t\t*resp_code = le32_to_cpu(tm_reply->response_data) &\n\t\t\tMPI3MR_RI_MASK_RESPCODE;\n\t\tbreak;\n\tcase MPI3_IOCSTATUS_SCSI_IOC_TERMINATED:\n\t\t*resp_code = MPI3_SCSITASKMGMT_RSPCODE_TM_COMPLETE;\n\t\tbreak;\n\tdefault:\n\t\tdprint_tm(mrioc,\n\t\t    \"task management request to handle(0x%04x) is failed with ioc_status(0x%04x) log_info(0x%08x)\\n\",\n\t\t    handle, drv_cmd->ioc_status, drv_cmd->ioc_loginfo);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (*resp_code) {\n\tcase MPI3_SCSITASKMGMT_RSPCODE_TM_SUCCEEDED:\n\tcase MPI3_SCSITASKMGMT_RSPCODE_TM_COMPLETE:\n\t\tbreak;\n\tcase MPI3_SCSITASKMGMT_RSPCODE_IO_QUEUED_ON_IOC:\n\t\tif (tm_type != MPI3_SCSITASKMGMT_TASKTYPE_QUERY_TASK)\n\t\t\tretval = -1;\n\t\tbreak;\n\tdefault:\n\t\tretval = -1;\n\t\tbreak;\n\t}\n\n\tdprint_tm(mrioc,\n\t    \"task management request type(%d) completed for handle(0x%04x) with ioc_status(0x%04x), log_info(0x%08x), termination_count(%d), response:%s(0x%x)\\n\",\n\t    tm_type, handle, drv_cmd->ioc_status, drv_cmd->ioc_loginfo,\n\t    le32_to_cpu(tm_reply->termination_count),\n\t    mpi3mr_tm_response_name(*resp_code), *resp_code);\n\n\tif (!retval) {\n\t\tmpi3mr_ioc_disable_intr(mrioc);\n\t\tmpi3mr_poll_pend_io_completions(mrioc);\n\t\tmpi3mr_ioc_enable_intr(mrioc);\n\t\tmpi3mr_poll_pend_io_completions(mrioc);\n\t\tmpi3mr_process_admin_reply_q(mrioc);\n\t}\n\tswitch (tm_type) {\n\tcase MPI3_SCSITASKMGMT_TASKTYPE_TARGET_RESET:\n\t\tif (!scsi_tgt_priv_data)\n\t\t\tbreak;\n\t\tscsi_tgt_priv_data->pend_count = 0;\n\t\tblk_mq_tagset_busy_iter(&mrioc->shost->tag_set,\n\t\t    mpi3mr_count_tgt_pending,\n\t\t    (void *)scsi_tgt_priv_data->starget);\n\t\tbreak;\n\tcase MPI3_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET:\n\t\tif (!sdev_priv_data)\n\t\t\tbreak;\n\t\tsdev_priv_data->pend_count = 0;\n\t\tblk_mq_tagset_busy_iter(&mrioc->shost->tag_set,\n\t\t    mpi3mr_count_dev_pending, (void *)sdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nout_unlock:\n\tdrv_cmd->state = MPI3MR_CMD_NOTUSED;\n\tmutex_unlock(&drv_cmd->mutex);\n\tif (scsi_tgt_priv_data)\n\t\tatomic_dec_if_positive(&scsi_tgt_priv_data->block_io);\n\tif (tgtdev)\n\t\tmpi3mr_tgtdev_put(tgtdev);\nout:\n\treturn retval;\n}\n\n \nstatic int mpi3mr_bios_param(struct scsi_device *sdev,\n\tstruct block_device *bdev, sector_t capacity, int params[])\n{\n\tint heads;\n\tint sectors;\n\tsector_t cylinders;\n\tulong dummy;\n\n\theads = 64;\n\tsectors = 32;\n\n\tdummy = heads * sectors;\n\tcylinders = capacity;\n\tsector_div(cylinders, dummy);\n\n\tif ((ulong)capacity >= 0x200000) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\tdummy = heads * sectors;\n\t\tcylinders = capacity;\n\t\tsector_div(cylinders, dummy);\n\t}\n\n\tparams[0] = heads;\n\tparams[1] = sectors;\n\tparams[2] = cylinders;\n\treturn 0;\n}\n\n \nstatic void mpi3mr_map_queues(struct Scsi_Host *shost)\n{\n\tstruct mpi3mr_ioc *mrioc = shost_priv(shost);\n\tint i, qoff, offset;\n\tstruct blk_mq_queue_map *map = NULL;\n\n\toffset = mrioc->op_reply_q_offset;\n\n\tfor (i = 0, qoff = 0; i < HCTX_MAX_TYPES; i++) {\n\t\tmap = &shost->tag_set.map[i];\n\n\t\tmap->nr_queues  = 0;\n\n\t\tif (i == HCTX_TYPE_DEFAULT)\n\t\t\tmap->nr_queues = mrioc->default_qcount;\n\t\telse if (i == HCTX_TYPE_POLL)\n\t\t\tmap->nr_queues = mrioc->active_poll_qcount;\n\n\t\tif (!map->nr_queues) {\n\t\t\tBUG_ON(i == HCTX_TYPE_DEFAULT);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmap->queue_offset = qoff;\n\t\tif (i != HCTX_TYPE_POLL)\n\t\t\tblk_mq_pci_map_queues(map, mrioc->pdev, offset);\n\t\telse\n\t\t\tblk_mq_map_queues(map);\n\n\t\tqoff += map->nr_queues;\n\t\toffset += map->nr_queues;\n\t}\n}\n\n \nstatic inline int mpi3mr_get_fw_pending_ios(struct mpi3mr_ioc *mrioc)\n{\n\tu16 i;\n\tuint pend_ios = 0;\n\n\tfor (i = 0; i < mrioc->num_op_reply_q; i++)\n\t\tpend_ios += atomic_read(&mrioc->op_reply_qinfo[i].pend_ios);\n\treturn pend_ios;\n}\n\n \nstatic void mpi3mr_print_pending_host_io(struct mpi3mr_ioc *mrioc)\n{\n\tstruct Scsi_Host *shost = mrioc->shost;\n\n\tioc_info(mrioc, \"%s :Pending commands prior to reset: %d\\n\",\n\t    __func__, mpi3mr_get_fw_pending_ios(mrioc));\n\tblk_mq_tagset_busy_iter(&shost->tag_set,\n\t    mpi3mr_print_scmd, (void *)mrioc);\n}\n\n \nvoid mpi3mr_wait_for_host_io(struct mpi3mr_ioc *mrioc, u32 timeout)\n{\n\tenum mpi3mr_iocstate iocstate;\n\tint i = 0;\n\n\tiocstate = mpi3mr_get_iocstate(mrioc);\n\tif (iocstate != MRIOC_STATE_READY)\n\t\treturn;\n\n\tif (!mpi3mr_get_fw_pending_ios(mrioc))\n\t\treturn;\n\tioc_info(mrioc,\n\t    \"%s :Waiting for %d seconds prior to reset for %d I/O\\n\",\n\t    __func__, timeout, mpi3mr_get_fw_pending_ios(mrioc));\n\n\tfor (i = 0; i < timeout; i++) {\n\t\tif (!mpi3mr_get_fw_pending_ios(mrioc))\n\t\t\tbreak;\n\t\tiocstate = mpi3mr_get_iocstate(mrioc);\n\t\tif (iocstate != MRIOC_STATE_READY)\n\t\t\tbreak;\n\t\tmsleep(1000);\n\t}\n\n\tioc_info(mrioc, \"%s :Pending I/Os after wait is: %d\\n\", __func__,\n\t    mpi3mr_get_fw_pending_ios(mrioc));\n}\n\n \nstatic inline void mpi3mr_setup_divert_ws(struct mpi3mr_ioc *mrioc,\n\tstruct scsi_cmnd *scmd, struct mpi3_scsi_io_request *scsiio_req,\n\tu32 *scsiio_flags, u16 wslen)\n{\n\tu8 unmap = 0, ndob = 0;\n\tu8 opcode = scmd->cmnd[0];\n\tu32 num_blocks = 0;\n\tu16 sa = (scmd->cmnd[8] << 8) | (scmd->cmnd[9]);\n\n\tif (opcode == WRITE_SAME_16) {\n\t\tunmap = scmd->cmnd[1] & 0x08;\n\t\tndob = scmd->cmnd[1] & 0x01;\n\t\tnum_blocks = get_unaligned_be32(scmd->cmnd + 10);\n\t} else if ((opcode == VARIABLE_LENGTH_CMD) && (sa == WRITE_SAME_32)) {\n\t\tunmap = scmd->cmnd[10] & 0x08;\n\t\tndob = scmd->cmnd[10] & 0x01;\n\t\tnum_blocks = get_unaligned_be32(scmd->cmnd + 28);\n\t} else\n\t\treturn;\n\n\tif ((unmap) && (ndob) && (num_blocks > wslen)) {\n\t\tscsiio_req->msg_flags |=\n\t\t    MPI3_SCSIIO_MSGFLAGS_DIVERT_TO_FIRMWARE;\n\t\t*scsiio_flags |=\n\t\t\tMPI3_SCSIIO_FLAGS_DIVERT_REASON_WRITE_SAME_TOO_LARGE;\n\t}\n}\n\n \nstatic int mpi3mr_eh_host_reset(struct scsi_cmnd *scmd)\n{\n\tstruct mpi3mr_ioc *mrioc = shost_priv(scmd->device->host);\n\tstruct mpi3mr_stgt_priv_data *stgt_priv_data;\n\tstruct mpi3mr_sdev_priv_data *sdev_priv_data;\n\tu8 dev_type = MPI3_DEVICE_DEVFORM_VD;\n\tint retval = FAILED, ret;\n\n\tsdev_priv_data = scmd->device->hostdata;\n\tif (sdev_priv_data && sdev_priv_data->tgt_priv_data) {\n\t\tstgt_priv_data = sdev_priv_data->tgt_priv_data;\n\t\tdev_type = stgt_priv_data->dev_type;\n\t}\n\n\tif (dev_type == MPI3_DEVICE_DEVFORM_VD) {\n\t\tmpi3mr_wait_for_host_io(mrioc,\n\t\t    MPI3MR_RAID_ERRREC_RESET_TIMEOUT);\n\t\tif (!mpi3mr_get_fw_pending_ios(mrioc)) {\n\t\t\tretval = SUCCESS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmpi3mr_print_pending_host_io(mrioc);\n\tret = mpi3mr_soft_reset_handler(mrioc,\n\t    MPI3MR_RESET_FROM_EH_HOS, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tretval = SUCCESS;\nout:\n\tsdev_printk(KERN_INFO, scmd->device,\n\t    \"Host reset is %s for scmd(%p)\\n\",\n\t    ((retval == SUCCESS) ? \"SUCCESS\" : \"FAILED\"), scmd);\n\n\treturn retval;\n}\n\n \nstatic int mpi3mr_eh_target_reset(struct scsi_cmnd *scmd)\n{\n\tstruct mpi3mr_ioc *mrioc = shost_priv(scmd->device->host);\n\tstruct mpi3mr_stgt_priv_data *stgt_priv_data;\n\tstruct mpi3mr_sdev_priv_data *sdev_priv_data;\n\tu16 dev_handle;\n\tu8 resp_code = 0;\n\tint retval = FAILED, ret = 0;\n\n\tsdev_printk(KERN_INFO, scmd->device,\n\t    \"Attempting Target Reset! scmd(%p)\\n\", scmd);\n\tscsi_print_command(scmd);\n\n\tsdev_priv_data = scmd->device->hostdata;\n\tif (!sdev_priv_data || !sdev_priv_data->tgt_priv_data) {\n\t\tsdev_printk(KERN_INFO, scmd->device,\n\t\t    \"SCSI device is not available\\n\");\n\t\tretval = SUCCESS;\n\t\tgoto out;\n\t}\n\n\tstgt_priv_data = sdev_priv_data->tgt_priv_data;\n\tdev_handle = stgt_priv_data->dev_handle;\n\tif (stgt_priv_data->dev_removed) {\n\t\tstruct scmd_priv *cmd_priv = scsi_cmd_priv(scmd);\n\t\tsdev_printk(KERN_INFO, scmd->device,\n\t\t    \"%s:target(handle = 0x%04x) is removed, target reset is not issued\\n\",\n\t\t    mrioc->name, dev_handle);\n\t\tif (!cmd_priv->in_lld_scope || cmd_priv->host_tag == MPI3MR_HOSTTAG_INVALID)\n\t\t\tretval = SUCCESS;\n\t\telse\n\t\t\tretval = FAILED;\n\t\tgoto out;\n\t}\n\tsdev_printk(KERN_INFO, scmd->device,\n\t    \"Target Reset is issued to handle(0x%04x)\\n\",\n\t    dev_handle);\n\n\tret = mpi3mr_issue_tm(mrioc,\n\t    MPI3_SCSITASKMGMT_TASKTYPE_TARGET_RESET, dev_handle,\n\t    sdev_priv_data->lun_id, MPI3MR_HOSTTAG_BLK_TMS,\n\t    MPI3MR_RESETTM_TIMEOUT, &mrioc->host_tm_cmds, &resp_code, scmd);\n\n\tif (ret)\n\t\tgoto out;\n\n\tif (stgt_priv_data->pend_count) {\n\t\tsdev_printk(KERN_INFO, scmd->device,\n\t\t    \"%s: target has %d pending commands, target reset is failed\\n\",\n\t\t    mrioc->name, stgt_priv_data->pend_count);\n\t\tgoto out;\n\t}\n\n\tretval = SUCCESS;\nout:\n\tsdev_printk(KERN_INFO, scmd->device,\n\t    \"%s: target reset is %s for scmd(%p)\\n\", mrioc->name,\n\t    ((retval == SUCCESS) ? \"SUCCESS\" : \"FAILED\"), scmd);\n\n\treturn retval;\n}\n\n \nstatic int mpi3mr_eh_dev_reset(struct scsi_cmnd *scmd)\n{\n\tstruct mpi3mr_ioc *mrioc = shost_priv(scmd->device->host);\n\tstruct mpi3mr_stgt_priv_data *stgt_priv_data;\n\tstruct mpi3mr_sdev_priv_data *sdev_priv_data;\n\tu16 dev_handle;\n\tu8 resp_code = 0;\n\tint retval = FAILED, ret = 0;\n\n\tsdev_printk(KERN_INFO, scmd->device,\n\t    \"Attempting Device(lun) Reset! scmd(%p)\\n\", scmd);\n\tscsi_print_command(scmd);\n\n\tsdev_priv_data = scmd->device->hostdata;\n\tif (!sdev_priv_data || !sdev_priv_data->tgt_priv_data) {\n\t\tsdev_printk(KERN_INFO, scmd->device,\n\t\t    \"SCSI device is not available\\n\");\n\t\tretval = SUCCESS;\n\t\tgoto out;\n\t}\n\n\tstgt_priv_data = sdev_priv_data->tgt_priv_data;\n\tdev_handle = stgt_priv_data->dev_handle;\n\tif (stgt_priv_data->dev_removed) {\n\t\tstruct scmd_priv *cmd_priv = scsi_cmd_priv(scmd);\n\t\tsdev_printk(KERN_INFO, scmd->device,\n\t\t    \"%s: device(handle = 0x%04x) is removed, device(LUN) reset is not issued\\n\",\n\t\t    mrioc->name, dev_handle);\n\t\tif (!cmd_priv->in_lld_scope || cmd_priv->host_tag == MPI3MR_HOSTTAG_INVALID)\n\t\t\tretval = SUCCESS;\n\t\telse\n\t\t\tretval = FAILED;\n\t\tgoto out;\n\t}\n\tsdev_printk(KERN_INFO, scmd->device,\n\t    \"Device(lun) Reset is issued to handle(0x%04x)\\n\", dev_handle);\n\n\tret = mpi3mr_issue_tm(mrioc,\n\t    MPI3_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET, dev_handle,\n\t    sdev_priv_data->lun_id, MPI3MR_HOSTTAG_BLK_TMS,\n\t    MPI3MR_RESETTM_TIMEOUT, &mrioc->host_tm_cmds, &resp_code, scmd);\n\n\tif (ret)\n\t\tgoto out;\n\n\tif (sdev_priv_data->pend_count) {\n\t\tsdev_printk(KERN_INFO, scmd->device,\n\t\t    \"%s: device has %d pending commands, device(LUN) reset is failed\\n\",\n\t\t    mrioc->name, sdev_priv_data->pend_count);\n\t\tgoto out;\n\t}\n\tretval = SUCCESS;\nout:\n\tsdev_printk(KERN_INFO, scmd->device,\n\t    \"%s: device(LUN) reset is %s for scmd(%p)\\n\", mrioc->name,\n\t    ((retval == SUCCESS) ? \"SUCCESS\" : \"FAILED\"), scmd);\n\n\treturn retval;\n}\n\n \nstatic void mpi3mr_scan_start(struct Scsi_Host *shost)\n{\n\tstruct mpi3mr_ioc *mrioc = shost_priv(shost);\n\n\tmrioc->scan_started = 1;\n\tioc_info(mrioc, \"%s :Issuing Port Enable\\n\", __func__);\n\tif (mpi3mr_issue_port_enable(mrioc, 1)) {\n\t\tioc_err(mrioc, \"%s :Issuing port enable failed\\n\", __func__);\n\t\tmrioc->scan_started = 0;\n\t\tmrioc->scan_failed = MPI3_IOCSTATUS_INTERNAL_ERROR;\n\t}\n}\n\n \nstatic int mpi3mr_scan_finished(struct Scsi_Host *shost,\n\tunsigned long time)\n{\n\tstruct mpi3mr_ioc *mrioc = shost_priv(shost);\n\tu32 pe_timeout = MPI3MR_PORTENABLE_TIMEOUT;\n\tu32 ioc_status = readl(&mrioc->sysif_regs->ioc_status);\n\n\tif ((ioc_status & MPI3_SYSIF_IOC_STATUS_RESET_HISTORY) ||\n\t    (ioc_status & MPI3_SYSIF_IOC_STATUS_FAULT)) {\n\t\tioc_err(mrioc, \"port enable failed due to fault or reset\\n\");\n\t\tmpi3mr_print_fault_info(mrioc);\n\t\tmrioc->scan_failed = MPI3_IOCSTATUS_INTERNAL_ERROR;\n\t\tmrioc->scan_started = 0;\n\t\tmrioc->init_cmds.is_waiting = 0;\n\t\tmrioc->init_cmds.callback = NULL;\n\t\tmrioc->init_cmds.state = MPI3MR_CMD_NOTUSED;\n\t}\n\n\tif (time >= (pe_timeout * HZ)) {\n\t\tioc_err(mrioc, \"port enable failed due to time out\\n\");\n\t\tmpi3mr_check_rh_fault_ioc(mrioc,\n\t\t    MPI3MR_RESET_FROM_PE_TIMEOUT);\n\t\tmrioc->scan_failed = MPI3_IOCSTATUS_INTERNAL_ERROR;\n\t\tmrioc->scan_started = 0;\n\t\tmrioc->init_cmds.is_waiting = 0;\n\t\tmrioc->init_cmds.callback = NULL;\n\t\tmrioc->init_cmds.state = MPI3MR_CMD_NOTUSED;\n\t}\n\n\tif (mrioc->scan_started)\n\t\treturn 0;\n\n\tif (mrioc->scan_failed) {\n\t\tioc_err(mrioc,\n\t\t    \"port enable failed with status=0x%04x\\n\",\n\t\t    mrioc->scan_failed);\n\t} else\n\t\tioc_info(mrioc, \"port enable is successfully completed\\n\");\n\n\tmpi3mr_start_watchdog(mrioc);\n\tmrioc->is_driver_loading = 0;\n\tmrioc->stop_bsgs = 0;\n\treturn 1;\n}\n\n \nstatic void mpi3mr_slave_destroy(struct scsi_device *sdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct mpi3mr_ioc *mrioc;\n\tstruct mpi3mr_stgt_priv_data *scsi_tgt_priv_data;\n\tstruct mpi3mr_tgt_dev *tgt_dev = NULL;\n\tunsigned long flags;\n\tstruct scsi_target *starget;\n\tstruct sas_rphy *rphy = NULL;\n\n\tif (!sdev->hostdata)\n\t\treturn;\n\n\tstarget = scsi_target(sdev);\n\tshost = dev_to_shost(&starget->dev);\n\tmrioc = shost_priv(shost);\n\tscsi_tgt_priv_data = starget->hostdata;\n\n\tscsi_tgt_priv_data->num_luns--;\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\tif (starget->channel == mrioc->scsi_device_channel)\n\t\ttgt_dev = __mpi3mr_get_tgtdev_by_perst_id(mrioc, starget->id);\n\telse if (mrioc->sas_transport_enabled && !starget->channel) {\n\t\trphy = dev_to_rphy(starget->dev.parent);\n\t\ttgt_dev = __mpi3mr_get_tgtdev_by_addr_and_rphy(mrioc,\n\t\t    rphy->identify.sas_address, rphy);\n\t}\n\n\tif (tgt_dev && (!scsi_tgt_priv_data->num_luns))\n\t\ttgt_dev->starget = NULL;\n\tif (tgt_dev)\n\t\tmpi3mr_tgtdev_put(tgt_dev);\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\n\tkfree(sdev->hostdata);\n\tsdev->hostdata = NULL;\n}\n\n \nstatic void mpi3mr_target_destroy(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost;\n\tstruct mpi3mr_ioc *mrioc;\n\tstruct mpi3mr_stgt_priv_data *scsi_tgt_priv_data;\n\tstruct mpi3mr_tgt_dev *tgt_dev;\n\tunsigned long flags;\n\n\tif (!starget->hostdata)\n\t\treturn;\n\n\tshost = dev_to_shost(&starget->dev);\n\tmrioc = shost_priv(shost);\n\tscsi_tgt_priv_data = starget->hostdata;\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\ttgt_dev = __mpi3mr_get_tgtdev_from_tgtpriv(mrioc, scsi_tgt_priv_data);\n\tif (tgt_dev && (tgt_dev->starget == starget) &&\n\t    (tgt_dev->perst_id == starget->id))\n\t\ttgt_dev->starget = NULL;\n\tif (tgt_dev) {\n\t\tscsi_tgt_priv_data->tgt_dev = NULL;\n\t\tscsi_tgt_priv_data->perst_id = 0;\n\t\tmpi3mr_tgtdev_put(tgt_dev);\n\t\tmpi3mr_tgtdev_put(tgt_dev);\n\t}\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\n\tkfree(starget->hostdata);\n\tstarget->hostdata = NULL;\n}\n\n \nstatic int mpi3mr_slave_configure(struct scsi_device *sdev)\n{\n\tstruct scsi_target *starget;\n\tstruct Scsi_Host *shost;\n\tstruct mpi3mr_ioc *mrioc;\n\tstruct mpi3mr_tgt_dev *tgt_dev = NULL;\n\tunsigned long flags;\n\tint retval = 0;\n\tstruct sas_rphy *rphy = NULL;\n\n\tstarget = scsi_target(sdev);\n\tshost = dev_to_shost(&starget->dev);\n\tmrioc = shost_priv(shost);\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\tif (starget->channel == mrioc->scsi_device_channel)\n\t\ttgt_dev = __mpi3mr_get_tgtdev_by_perst_id(mrioc, starget->id);\n\telse if (mrioc->sas_transport_enabled && !starget->channel) {\n\t\trphy = dev_to_rphy(starget->dev.parent);\n\t\ttgt_dev = __mpi3mr_get_tgtdev_by_addr_and_rphy(mrioc,\n\t\t    rphy->identify.sas_address, rphy);\n\t}\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\tif (!tgt_dev)\n\t\treturn -ENXIO;\n\n\tmpi3mr_change_queue_depth(sdev, tgt_dev->q_depth);\n\n\tsdev->eh_timeout = MPI3MR_EH_SCMD_TIMEOUT;\n\tblk_queue_rq_timeout(sdev->request_queue, MPI3MR_SCMD_TIMEOUT);\n\n\tswitch (tgt_dev->dev_type) {\n\tcase MPI3_DEVICE_DEVFORM_PCIE:\n\t\t \n\t\tif ((tgt_dev->dev_spec.pcie_inf.dev_info &\n\t\t    MPI3_DEVICE0_PCIE_DEVICE_INFO_TYPE_MASK) ==\n\t\t    MPI3_DEVICE0_PCIE_DEVICE_INFO_TYPE_NVME_DEVICE) {\n\t\t\tblk_queue_max_hw_sectors(sdev->request_queue,\n\t\t\t    tgt_dev->dev_spec.pcie_inf.mdts / 512);\n\t\t\tif (tgt_dev->dev_spec.pcie_inf.pgsz == 0)\n\t\t\t\tblk_queue_virt_boundary(sdev->request_queue,\n\t\t\t\t    ((1 << MPI3MR_DEFAULT_PGSZEXP) - 1));\n\t\t\telse\n\t\t\t\tblk_queue_virt_boundary(sdev->request_queue,\n\t\t\t\t    ((1 << tgt_dev->dev_spec.pcie_inf.pgsz) - 1));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmpi3mr_tgtdev_put(tgt_dev);\n\n\treturn retval;\n}\n\n \nstatic int mpi3mr_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct mpi3mr_ioc *mrioc;\n\tstruct mpi3mr_stgt_priv_data *scsi_tgt_priv_data;\n\tstruct mpi3mr_tgt_dev *tgt_dev = NULL;\n\tstruct mpi3mr_sdev_priv_data *scsi_dev_priv_data;\n\tunsigned long flags;\n\tstruct scsi_target *starget;\n\tint retval = 0;\n\tstruct sas_rphy *rphy = NULL;\n\n\tstarget = scsi_target(sdev);\n\tshost = dev_to_shost(&starget->dev);\n\tmrioc = shost_priv(shost);\n\tscsi_tgt_priv_data = starget->hostdata;\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\n\tif (starget->channel == mrioc->scsi_device_channel)\n\t\ttgt_dev = __mpi3mr_get_tgtdev_by_perst_id(mrioc, starget->id);\n\telse if (mrioc->sas_transport_enabled && !starget->channel) {\n\t\trphy = dev_to_rphy(starget->dev.parent);\n\t\ttgt_dev = __mpi3mr_get_tgtdev_by_addr_and_rphy(mrioc,\n\t\t    rphy->identify.sas_address, rphy);\n\t}\n\n\tif (tgt_dev) {\n\t\tif (tgt_dev->starget == NULL)\n\t\t\ttgt_dev->starget = starget;\n\t\tmpi3mr_tgtdev_put(tgt_dev);\n\t\tretval = 0;\n\t} else {\n\t\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\t\treturn -ENXIO;\n\t}\n\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\n\tscsi_dev_priv_data = kzalloc(sizeof(*scsi_dev_priv_data), GFP_KERNEL);\n\tif (!scsi_dev_priv_data)\n\t\treturn -ENOMEM;\n\n\tscsi_dev_priv_data->lun_id = sdev->lun;\n\tscsi_dev_priv_data->tgt_priv_data = scsi_tgt_priv_data;\n\tsdev->hostdata = scsi_dev_priv_data;\n\n\tscsi_tgt_priv_data->num_luns++;\n\n\treturn retval;\n}\n\n \nstatic int mpi3mr_target_alloc(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\n\tstruct mpi3mr_ioc *mrioc = shost_priv(shost);\n\tstruct mpi3mr_stgt_priv_data *scsi_tgt_priv_data;\n\tstruct mpi3mr_tgt_dev *tgt_dev;\n\tunsigned long flags;\n\tint retval = 0;\n\tstruct sas_rphy *rphy = NULL;\n\n\tscsi_tgt_priv_data = kzalloc(sizeof(*scsi_tgt_priv_data), GFP_KERNEL);\n\tif (!scsi_tgt_priv_data)\n\t\treturn -ENOMEM;\n\n\tstarget->hostdata = scsi_tgt_priv_data;\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\tif (starget->channel == mrioc->scsi_device_channel) {\n\t\ttgt_dev = __mpi3mr_get_tgtdev_by_perst_id(mrioc, starget->id);\n\t\tif (tgt_dev && !tgt_dev->is_hidden) {\n\t\t\tscsi_tgt_priv_data->starget = starget;\n\t\t\tscsi_tgt_priv_data->dev_handle = tgt_dev->dev_handle;\n\t\t\tscsi_tgt_priv_data->perst_id = tgt_dev->perst_id;\n\t\t\tscsi_tgt_priv_data->dev_type = tgt_dev->dev_type;\n\t\t\tscsi_tgt_priv_data->tgt_dev = tgt_dev;\n\t\t\ttgt_dev->starget = starget;\n\t\t\tatomic_set(&scsi_tgt_priv_data->block_io, 0);\n\t\t\tretval = 0;\n\t\t\tif ((tgt_dev->dev_type == MPI3_DEVICE_DEVFORM_PCIE) &&\n\t\t\t    ((tgt_dev->dev_spec.pcie_inf.dev_info &\n\t\t\t    MPI3_DEVICE0_PCIE_DEVICE_INFO_TYPE_MASK) ==\n\t\t\t    MPI3_DEVICE0_PCIE_DEVICE_INFO_TYPE_NVME_DEVICE) &&\n\t\t\t    ((tgt_dev->dev_spec.pcie_inf.dev_info &\n\t\t\t    MPI3_DEVICE0_PCIE_DEVICE_INFO_PITYPE_MASK) !=\n\t\t\t    MPI3_DEVICE0_PCIE_DEVICE_INFO_PITYPE_0))\n\t\t\t\tscsi_tgt_priv_data->dev_nvme_dif = 1;\n\t\t\tscsi_tgt_priv_data->io_throttle_enabled = tgt_dev->io_throttle_enabled;\n\t\t\tscsi_tgt_priv_data->wslen = tgt_dev->wslen;\n\t\t\tif (tgt_dev->dev_type == MPI3_DEVICE_DEVFORM_VD)\n\t\t\t\tscsi_tgt_priv_data->throttle_group = tgt_dev->dev_spec.vd_inf.tg;\n\t\t} else\n\t\t\tretval = -ENXIO;\n\t} else if (mrioc->sas_transport_enabled && !starget->channel) {\n\t\trphy = dev_to_rphy(starget->dev.parent);\n\t\ttgt_dev = __mpi3mr_get_tgtdev_by_addr_and_rphy(mrioc,\n\t\t    rphy->identify.sas_address, rphy);\n\t\tif (tgt_dev && !tgt_dev->is_hidden && !tgt_dev->non_stl &&\n\t\t    (tgt_dev->dev_type == MPI3_DEVICE_DEVFORM_SAS_SATA)) {\n\t\t\tscsi_tgt_priv_data->starget = starget;\n\t\t\tscsi_tgt_priv_data->dev_handle = tgt_dev->dev_handle;\n\t\t\tscsi_tgt_priv_data->perst_id = tgt_dev->perst_id;\n\t\t\tscsi_tgt_priv_data->dev_type = tgt_dev->dev_type;\n\t\t\tscsi_tgt_priv_data->tgt_dev = tgt_dev;\n\t\t\tscsi_tgt_priv_data->io_throttle_enabled = tgt_dev->io_throttle_enabled;\n\t\t\tscsi_tgt_priv_data->wslen = tgt_dev->wslen;\n\t\t\ttgt_dev->starget = starget;\n\t\t\tatomic_set(&scsi_tgt_priv_data->block_io, 0);\n\t\t\tretval = 0;\n\t\t} else\n\t\t\tretval = -ENXIO;\n\t}\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\n\treturn retval;\n}\n\n \nstatic bool mpi3mr_check_return_unmap(struct mpi3mr_ioc *mrioc,\n\tstruct scsi_cmnd *scmd)\n{\n\tunsigned char *buf;\n\tu16 param_len, desc_len, trunc_param_len;\n\n\ttrunc_param_len = param_len = get_unaligned_be16(scmd->cmnd + 7);\n\n\tif (mrioc->pdev->revision) {\n\t\tif ((param_len > 24) && ((param_len - 8) & 0xF)) {\n\t\t\ttrunc_param_len -= (param_len - 8) & 0xF;\n\t\t\tdprint_scsi_command(mrioc, scmd, MPI3_DEBUG_SCSI_ERROR);\n\t\t\tdprint_scsi_err(mrioc,\n\t\t\t    \"truncating param_len from (%d) to (%d)\\n\",\n\t\t\t    param_len, trunc_param_len);\n\t\t\tput_unaligned_be16(trunc_param_len, scmd->cmnd + 7);\n\t\t\tdprint_scsi_command(mrioc, scmd, MPI3_DEBUG_SCSI_ERROR);\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (!param_len) {\n\t\tioc_warn(mrioc,\n\t\t    \"%s: cdb received with zero parameter length\\n\",\n\t\t    __func__);\n\t\tscsi_print_command(scmd);\n\t\tscmd->result = DID_OK << 16;\n\t\tscsi_done(scmd);\n\t\treturn true;\n\t}\n\n\tif (param_len < 24) {\n\t\tioc_warn(mrioc,\n\t\t    \"%s: cdb received with invalid param_len: %d\\n\",\n\t\t    __func__, param_len);\n\t\tscsi_print_command(scmd);\n\t\tscmd->result = SAM_STAT_CHECK_CONDITION;\n\t\tscsi_build_sense_buffer(0, scmd->sense_buffer, ILLEGAL_REQUEST,\n\t\t    0x1A, 0);\n\t\tscsi_done(scmd);\n\t\treturn true;\n\t}\n\tif (param_len != scsi_bufflen(scmd)) {\n\t\tioc_warn(mrioc,\n\t\t    \"%s: cdb received with param_len: %d bufflen: %d\\n\",\n\t\t    __func__, param_len, scsi_bufflen(scmd));\n\t\tscsi_print_command(scmd);\n\t\tscmd->result = SAM_STAT_CHECK_CONDITION;\n\t\tscsi_build_sense_buffer(0, scmd->sense_buffer, ILLEGAL_REQUEST,\n\t\t    0x1A, 0);\n\t\tscsi_done(scmd);\n\t\treturn true;\n\t}\n\tbuf = kzalloc(scsi_bufflen(scmd), GFP_ATOMIC);\n\tif (!buf) {\n\t\tscsi_print_command(scmd);\n\t\tscmd->result = SAM_STAT_CHECK_CONDITION;\n\t\tscsi_build_sense_buffer(0, scmd->sense_buffer, ILLEGAL_REQUEST,\n\t\t    0x55, 0x03);\n\t\tscsi_done(scmd);\n\t\treturn true;\n\t}\n\tscsi_sg_copy_to_buffer(scmd, buf, scsi_bufflen(scmd));\n\tdesc_len = get_unaligned_be16(&buf[2]);\n\n\tif (desc_len < 16) {\n\t\tioc_warn(mrioc,\n\t\t    \"%s: Invalid descriptor length in param list: %d\\n\",\n\t\t    __func__, desc_len);\n\t\tscsi_print_command(scmd);\n\t\tscmd->result = SAM_STAT_CHECK_CONDITION;\n\t\tscsi_build_sense_buffer(0, scmd->sense_buffer, ILLEGAL_REQUEST,\n\t\t    0x26, 0);\n\t\tscsi_done(scmd);\n\t\tkfree(buf);\n\t\treturn true;\n\t}\n\n\tif (param_len > (desc_len + 8)) {\n\t\ttrunc_param_len = desc_len + 8;\n\t\tscsi_print_command(scmd);\n\t\tdprint_scsi_err(mrioc,\n\t\t    \"truncating param_len(%d) to desc_len+8(%d)\\n\",\n\t\t    param_len, trunc_param_len);\n\t\tput_unaligned_be16(trunc_param_len, scmd->cmnd + 7);\n\t\tscsi_print_command(scmd);\n\t}\n\n\tkfree(buf);\n\treturn false;\n}\n\n \n\ninline bool mpi3mr_allow_scmd_to_fw(struct scsi_cmnd *scmd)\n{\n\tswitch (scmd->cmnd[0]) {\n\tcase SYNCHRONIZE_CACHE:\n\tcase START_STOP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic int mpi3mr_qcmd(struct Scsi_Host *shost,\n\tstruct scsi_cmnd *scmd)\n{\n\tstruct mpi3mr_ioc *mrioc = shost_priv(shost);\n\tstruct mpi3mr_stgt_priv_data *stgt_priv_data;\n\tstruct mpi3mr_sdev_priv_data *sdev_priv_data;\n\tstruct scmd_priv *scmd_priv_data = NULL;\n\tstruct mpi3_scsi_io_request *scsiio_req = NULL;\n\tstruct op_req_qinfo *op_req_q = NULL;\n\tint retval = 0;\n\tu16 dev_handle;\n\tu16 host_tag;\n\tu32 scsiio_flags = 0, data_len_blks = 0;\n\tstruct request *rq = scsi_cmd_to_rq(scmd);\n\tint iprio_class;\n\tu8 is_pcie_dev = 0;\n\tu32 tracked_io_sz = 0;\n\tu32 ioc_pend_data_len = 0, tg_pend_data_len = 0;\n\tstruct mpi3mr_throttle_group_info *tg = NULL;\n\n\tif (mrioc->unrecoverable) {\n\t\tscmd->result = DID_ERROR << 16;\n\t\tscsi_done(scmd);\n\t\tgoto out;\n\t}\n\n\tsdev_priv_data = scmd->device->hostdata;\n\tif (!sdev_priv_data || !sdev_priv_data->tgt_priv_data) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(scmd);\n\t\tgoto out;\n\t}\n\n\tif (mrioc->stop_drv_processing &&\n\t    !(mpi3mr_allow_scmd_to_fw(scmd))) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(scmd);\n\t\tgoto out;\n\t}\n\n\tstgt_priv_data = sdev_priv_data->tgt_priv_data;\n\tdev_handle = stgt_priv_data->dev_handle;\n\n\t \n\n\tif (scmd->device->host->shost_state == SHOST_RECOVERY &&\n\t\tscmd->cmnd[0] == TEST_UNIT_READY &&\n\t\t(stgt_priv_data->dev_removed || (dev_handle == MPI3MR_INVALID_DEV_HANDLE))) {\n\t\tscsi_build_sense(scmd, 0, UNIT_ATTENTION, 0x29, 0x07);\n\t\tscsi_done(scmd);\n\t\tgoto out;\n\t}\n\n\tif (mrioc->reset_in_progress) {\n\t\tretval = SCSI_MLQUEUE_HOST_BUSY;\n\t\tgoto out;\n\t}\n\n\tif (atomic_read(&stgt_priv_data->block_io)) {\n\t\tif (mrioc->stop_drv_processing) {\n\t\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\t\tscsi_done(scmd);\n\t\t\tgoto out;\n\t\t}\n\t\tretval = SCSI_MLQUEUE_DEVICE_BUSY;\n\t\tgoto out;\n\t}\n\n\tif (dev_handle == MPI3MR_INVALID_DEV_HANDLE) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(scmd);\n\t\tgoto out;\n\t}\n\tif (stgt_priv_data->dev_removed) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(scmd);\n\t\tgoto out;\n\t}\n\n\tif (stgt_priv_data->dev_type == MPI3_DEVICE_DEVFORM_PCIE)\n\t\tis_pcie_dev = 1;\n\tif ((scmd->cmnd[0] == UNMAP) && is_pcie_dev &&\n\t    (mrioc->pdev->device == MPI3_MFGPAGE_DEVID_SAS4116) &&\n\t    mpi3mr_check_return_unmap(mrioc, scmd))\n\t\tgoto out;\n\n\thost_tag = mpi3mr_host_tag_for_scmd(mrioc, scmd);\n\tif (host_tag == MPI3MR_HOSTTAG_INVALID) {\n\t\tscmd->result = DID_ERROR << 16;\n\t\tscsi_done(scmd);\n\t\tgoto out;\n\t}\n\n\tif (scmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\tscsiio_flags = MPI3_SCSIIO_FLAGS_DATADIRECTION_READ;\n\telse if (scmd->sc_data_direction == DMA_TO_DEVICE)\n\t\tscsiio_flags = MPI3_SCSIIO_FLAGS_DATADIRECTION_WRITE;\n\telse\n\t\tscsiio_flags = MPI3_SCSIIO_FLAGS_DATADIRECTION_NO_DATA_TRANSFER;\n\n\tscsiio_flags |= MPI3_SCSIIO_FLAGS_TASKATTRIBUTE_SIMPLEQ;\n\n\tif (sdev_priv_data->ncq_prio_enable) {\n\t\tiprio_class = IOPRIO_PRIO_CLASS(req_get_ioprio(rq));\n\t\tif (iprio_class == IOPRIO_CLASS_RT)\n\t\t\tscsiio_flags |= 1 << MPI3_SCSIIO_FLAGS_CMDPRI_SHIFT;\n\t}\n\n\tif (scmd->cmd_len > 16)\n\t\tscsiio_flags |= MPI3_SCSIIO_FLAGS_CDB_GREATER_THAN_16;\n\n\tscmd_priv_data = scsi_cmd_priv(scmd);\n\tmemset(scmd_priv_data->mpi3mr_scsiio_req, 0, MPI3MR_ADMIN_REQ_FRAME_SZ);\n\tscsiio_req = (struct mpi3_scsi_io_request *)scmd_priv_data->mpi3mr_scsiio_req;\n\tscsiio_req->function = MPI3_FUNCTION_SCSI_IO;\n\tscsiio_req->host_tag = cpu_to_le16(host_tag);\n\n\tmpi3mr_setup_eedp(mrioc, scmd, scsiio_req);\n\n\tif (stgt_priv_data->wslen)\n\t\tmpi3mr_setup_divert_ws(mrioc, scmd, scsiio_req, &scsiio_flags,\n\t\t    stgt_priv_data->wslen);\n\n\tmemcpy(scsiio_req->cdb.cdb32, scmd->cmnd, scmd->cmd_len);\n\tscsiio_req->data_length = cpu_to_le32(scsi_bufflen(scmd));\n\tscsiio_req->dev_handle = cpu_to_le16(dev_handle);\n\tscsiio_req->flags = cpu_to_le32(scsiio_flags);\n\tint_to_scsilun(sdev_priv_data->lun_id,\n\t    (struct scsi_lun *)scsiio_req->lun);\n\n\tif (mpi3mr_build_sg_scmd(mrioc, scmd, scsiio_req)) {\n\t\tmpi3mr_clear_scmd_priv(mrioc, scmd);\n\t\tretval = SCSI_MLQUEUE_HOST_BUSY;\n\t\tgoto out;\n\t}\n\top_req_q = &mrioc->req_qinfo[scmd_priv_data->req_q_idx];\n\tdata_len_blks = scsi_bufflen(scmd) >> 9;\n\tif ((data_len_blks >= mrioc->io_throttle_data_length) &&\n\t    stgt_priv_data->io_throttle_enabled) {\n\t\ttracked_io_sz = data_len_blks;\n\t\ttg = stgt_priv_data->throttle_group;\n\t\tif (tg) {\n\t\t\tioc_pend_data_len = atomic_add_return(data_len_blks,\n\t\t\t    &mrioc->pend_large_data_sz);\n\t\t\ttg_pend_data_len = atomic_add_return(data_len_blks,\n\t\t\t    &tg->pend_large_data_sz);\n\t\t\tif (!tg->io_divert  && ((ioc_pend_data_len >=\n\t\t\t    mrioc->io_throttle_high) ||\n\t\t\t    (tg_pend_data_len >= tg->high))) {\n\t\t\t\ttg->io_divert = 1;\n\t\t\t\ttg->need_qd_reduction = 1;\n\t\t\t\tmpi3mr_set_io_divert_for_all_vd_in_tg(mrioc,\n\t\t\t\t    tg, 1);\n\t\t\t\tmpi3mr_queue_qd_reduction_event(mrioc, tg);\n\t\t\t}\n\t\t} else {\n\t\t\tioc_pend_data_len = atomic_add_return(data_len_blks,\n\t\t\t    &mrioc->pend_large_data_sz);\n\t\t\tif (ioc_pend_data_len >= mrioc->io_throttle_high)\n\t\t\t\tstgt_priv_data->io_divert = 1;\n\t\t}\n\t}\n\n\tif (stgt_priv_data->io_divert) {\n\t\tscsiio_req->msg_flags |=\n\t\t    MPI3_SCSIIO_MSGFLAGS_DIVERT_TO_FIRMWARE;\n\t\tscsiio_flags |= MPI3_SCSIIO_FLAGS_DIVERT_REASON_IO_THROTTLING;\n\t}\n\tscsiio_req->flags = cpu_to_le32(scsiio_flags);\n\n\tif (mpi3mr_op_request_post(mrioc, op_req_q,\n\t    scmd_priv_data->mpi3mr_scsiio_req)) {\n\t\tmpi3mr_clear_scmd_priv(mrioc, scmd);\n\t\tretval = SCSI_MLQUEUE_HOST_BUSY;\n\t\tif (tracked_io_sz) {\n\t\t\tatomic_sub(tracked_io_sz, &mrioc->pend_large_data_sz);\n\t\t\tif (tg)\n\t\t\t\tatomic_sub(tracked_io_sz,\n\t\t\t\t    &tg->pend_large_data_sz);\n\t\t}\n\t\tgoto out;\n\t}\n\nout:\n\treturn retval;\n}\n\nstatic const struct scsi_host_template mpi3mr_driver_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.name\t\t\t\t= \"MPI3 Storage Controller\",\n\t.proc_name\t\t\t= MPI3MR_DRIVER_NAME,\n\t.queuecommand\t\t\t= mpi3mr_qcmd,\n\t.target_alloc\t\t\t= mpi3mr_target_alloc,\n\t.slave_alloc\t\t\t= mpi3mr_slave_alloc,\n\t.slave_configure\t\t= mpi3mr_slave_configure,\n\t.target_destroy\t\t\t= mpi3mr_target_destroy,\n\t.slave_destroy\t\t\t= mpi3mr_slave_destroy,\n\t.scan_finished\t\t\t= mpi3mr_scan_finished,\n\t.scan_start\t\t\t= mpi3mr_scan_start,\n\t.change_queue_depth\t\t= mpi3mr_change_queue_depth,\n\t.eh_device_reset_handler\t= mpi3mr_eh_dev_reset,\n\t.eh_target_reset_handler\t= mpi3mr_eh_target_reset,\n\t.eh_host_reset_handler\t\t= mpi3mr_eh_host_reset,\n\t.bios_param\t\t\t= mpi3mr_bios_param,\n\t.map_queues\t\t\t= mpi3mr_map_queues,\n\t.mq_poll                        = mpi3mr_blk_mq_poll,\n\t.no_write_same\t\t\t= 1,\n\t.can_queue\t\t\t= 1,\n\t.this_id\t\t\t= -1,\n\t.sg_tablesize\t\t\t= MPI3MR_DEFAULT_SGL_ENTRIES,\n\t \n\t.max_sectors\t\t\t= (MPI3MR_DEFAULT_MAX_IO_SIZE / 512),\n\t.cmd_per_lun\t\t\t= MPI3MR_MAX_CMDS_LUN,\n\t.max_segment_size\t\t= 0xffffffff,\n\t.track_queue_depth\t\t= 1,\n\t.cmd_size\t\t\t= sizeof(struct scmd_priv),\n\t.shost_groups\t\t\t= mpi3mr_host_groups,\n\t.sdev_groups\t\t\t= mpi3mr_dev_groups,\n};\n\n \nstatic inline void mpi3mr_init_drv_cmd(struct mpi3mr_drv_cmd *cmdptr,\n\tu16 host_tag)\n{\n\tmutex_init(&cmdptr->mutex);\n\tcmdptr->reply = NULL;\n\tcmdptr->state = MPI3MR_CMD_NOTUSED;\n\tcmdptr->dev_handle = MPI3MR_INVALID_DEV_HANDLE;\n\tcmdptr->host_tag = host_tag;\n}\n\n \nstatic int\nosintfc_mrioc_security_status(struct pci_dev *pdev)\n{\n\tu32 cap_data;\n\tint base;\n\tu32 ctlr_status;\n\tu32 debug_status;\n\tint retval = 0;\n\n\tbase = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_DSN);\n\tif (!base) {\n\t\tdev_err(&pdev->dev,\n\t\t    \"%s: PCI_EXT_CAP_ID_DSN is not supported\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tpci_read_config_dword(pdev, base + 4, &cap_data);\n\n\tdebug_status = cap_data & MPI3MR_CTLR_SECURE_DBG_STATUS_MASK;\n\tctlr_status = cap_data & MPI3MR_CTLR_SECURITY_STATUS_MASK;\n\n\tswitch (ctlr_status) {\n\tcase MPI3MR_INVALID_DEVICE:\n\t\tdev_err(&pdev->dev,\n\t\t    \"%s: Non secure ctlr (Invalid) is detected: DID: 0x%x: SVID: 0x%x: SDID: 0x%x\\n\",\n\t\t    __func__, pdev->device, pdev->subsystem_vendor,\n\t\t    pdev->subsystem_device);\n\t\tretval = -1;\n\t\tbreak;\n\tcase MPI3MR_CONFIG_SECURE_DEVICE:\n\t\tif (!debug_status)\n\t\t\tdev_info(&pdev->dev,\n\t\t\t    \"%s: Config secure ctlr is detected\\n\",\n\t\t\t    __func__);\n\t\tbreak;\n\tcase MPI3MR_HARD_SECURE_DEVICE:\n\t\tbreak;\n\tcase MPI3MR_TAMPERED_DEVICE:\n\t\tdev_err(&pdev->dev,\n\t\t    \"%s: Non secure ctlr (Tampered) is detected: DID: 0x%x: SVID: 0x%x: SDID: 0x%x\\n\",\n\t\t    __func__, pdev->device, pdev->subsystem_vendor,\n\t\t    pdev->subsystem_device);\n\t\tretval = -1;\n\t\tbreak;\n\tdefault:\n\t\tretval = -1;\n\t\t\tbreak;\n\t}\n\n\tif (!retval && debug_status) {\n\t\tdev_err(&pdev->dev,\n\t\t    \"%s: Non secure ctlr (Secure Dbg) is detected: DID: 0x%x: SVID: 0x%x: SDID: 0x%x\\n\",\n\t\t    __func__, pdev->device, pdev->subsystem_vendor,\n\t\t    pdev->subsystem_device);\n\t\tretval = -1;\n\t}\n\n\treturn retval;\n}\n\n \n\nstatic int\nmpi3mr_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct mpi3mr_ioc *mrioc = NULL;\n\tstruct Scsi_Host *shost = NULL;\n\tint retval = 0, i;\n\n\tif (osintfc_mrioc_security_status(pdev)) {\n\t\twarn_non_secure_ctlr = 1;\n\t\treturn 1;  \n\t}\n\n\tshost = scsi_host_alloc(&mpi3mr_driver_template,\n\t    sizeof(struct mpi3mr_ioc));\n\tif (!shost) {\n\t\tretval = -ENODEV;\n\t\tgoto shost_failed;\n\t}\n\n\tmrioc = shost_priv(shost);\n\tmrioc->id = mrioc_ids++;\n\tsprintf(mrioc->driver_name, \"%s\", MPI3MR_DRIVER_NAME);\n\tsprintf(mrioc->name, \"%s%d\", mrioc->driver_name, mrioc->id);\n\tINIT_LIST_HEAD(&mrioc->list);\n\tspin_lock(&mrioc_list_lock);\n\tlist_add_tail(&mrioc->list, &mrioc_list);\n\tspin_unlock(&mrioc_list_lock);\n\n\tspin_lock_init(&mrioc->admin_req_lock);\n\tspin_lock_init(&mrioc->reply_free_queue_lock);\n\tspin_lock_init(&mrioc->sbq_lock);\n\tspin_lock_init(&mrioc->fwevt_lock);\n\tspin_lock_init(&mrioc->tgtdev_lock);\n\tspin_lock_init(&mrioc->watchdog_lock);\n\tspin_lock_init(&mrioc->chain_buf_lock);\n\tspin_lock_init(&mrioc->sas_node_lock);\n\n\tINIT_LIST_HEAD(&mrioc->fwevt_list);\n\tINIT_LIST_HEAD(&mrioc->tgtdev_list);\n\tINIT_LIST_HEAD(&mrioc->delayed_rmhs_list);\n\tINIT_LIST_HEAD(&mrioc->delayed_evtack_cmds_list);\n\tINIT_LIST_HEAD(&mrioc->sas_expander_list);\n\tINIT_LIST_HEAD(&mrioc->hba_port_table_list);\n\tINIT_LIST_HEAD(&mrioc->enclosure_list);\n\n\tmutex_init(&mrioc->reset_mutex);\n\tmpi3mr_init_drv_cmd(&mrioc->init_cmds, MPI3MR_HOSTTAG_INITCMDS);\n\tmpi3mr_init_drv_cmd(&mrioc->host_tm_cmds, MPI3MR_HOSTTAG_BLK_TMS);\n\tmpi3mr_init_drv_cmd(&mrioc->bsg_cmds, MPI3MR_HOSTTAG_BSG_CMDS);\n\tmpi3mr_init_drv_cmd(&mrioc->cfg_cmds, MPI3MR_HOSTTAG_CFG_CMDS);\n\tmpi3mr_init_drv_cmd(&mrioc->transport_cmds,\n\t    MPI3MR_HOSTTAG_TRANSPORT_CMDS);\n\n\tfor (i = 0; i < MPI3MR_NUM_DEVRMCMD; i++)\n\t\tmpi3mr_init_drv_cmd(&mrioc->dev_rmhs_cmds[i],\n\t\t    MPI3MR_HOSTTAG_DEVRMCMD_MIN + i);\n\n\tfor (i = 0; i < MPI3MR_NUM_EVTACKCMD; i++)\n\t\tmpi3mr_init_drv_cmd(&mrioc->evtack_cmds[i],\n\t\t\t\t    MPI3MR_HOSTTAG_EVTACKCMD_MIN + i);\n\n\tif (pdev->revision)\n\t\tmrioc->enable_segqueue = true;\n\n\tinit_waitqueue_head(&mrioc->reset_waitq);\n\tmrioc->logging_level = logging_level;\n\tmrioc->shost = shost;\n\tmrioc->pdev = pdev;\n\tmrioc->stop_bsgs = 1;\n\n\tmrioc->max_sgl_entries = max_sgl_entries;\n\tif (max_sgl_entries > MPI3MR_MAX_SGL_ENTRIES)\n\t\tmrioc->max_sgl_entries = MPI3MR_MAX_SGL_ENTRIES;\n\telse if (max_sgl_entries < MPI3MR_DEFAULT_SGL_ENTRIES)\n\t\tmrioc->max_sgl_entries = MPI3MR_DEFAULT_SGL_ENTRIES;\n\telse {\n\t\tmrioc->max_sgl_entries /= MPI3MR_DEFAULT_SGL_ENTRIES;\n\t\tmrioc->max_sgl_entries *= MPI3MR_DEFAULT_SGL_ENTRIES;\n\t}\n\n\t \n\tshost->max_cmd_len = MPI3MR_MAX_CDB_LENGTH;\n\tshost->max_lun = -1;\n\tshost->unique_id = mrioc->id;\n\n\tshost->max_channel = 0;\n\tshost->max_id = 0xFFFFFFFF;\n\n\tshost->host_tagset = 1;\n\n\tif (prot_mask >= 0)\n\t\tscsi_host_set_prot(shost, prot_mask);\n\telse {\n\t\tprot_mask = SHOST_DIF_TYPE1_PROTECTION\n\t\t    | SHOST_DIF_TYPE2_PROTECTION\n\t\t    | SHOST_DIF_TYPE3_PROTECTION;\n\t\tscsi_host_set_prot(shost, prot_mask);\n\t}\n\n\tioc_info(mrioc,\n\t    \"%s :host protection capabilities enabled %s%s%s%s%s%s%s\\n\",\n\t    __func__,\n\t    (prot_mask & SHOST_DIF_TYPE1_PROTECTION) ? \" DIF1\" : \"\",\n\t    (prot_mask & SHOST_DIF_TYPE2_PROTECTION) ? \" DIF2\" : \"\",\n\t    (prot_mask & SHOST_DIF_TYPE3_PROTECTION) ? \" DIF3\" : \"\",\n\t    (prot_mask & SHOST_DIX_TYPE0_PROTECTION) ? \" DIX0\" : \"\",\n\t    (prot_mask & SHOST_DIX_TYPE1_PROTECTION) ? \" DIX1\" : \"\",\n\t    (prot_mask & SHOST_DIX_TYPE2_PROTECTION) ? \" DIX2\" : \"\",\n\t    (prot_mask & SHOST_DIX_TYPE3_PROTECTION) ? \" DIX3\" : \"\");\n\n\tif (prot_guard_mask)\n\t\tscsi_host_set_guard(shost, (prot_guard_mask & 3));\n\telse\n\t\tscsi_host_set_guard(shost, SHOST_DIX_GUARD_CRC);\n\n\tsnprintf(mrioc->fwevt_worker_name, sizeof(mrioc->fwevt_worker_name),\n\t    \"%s%d_fwevt_wrkr\", mrioc->driver_name, mrioc->id);\n\tmrioc->fwevt_worker_thread = alloc_ordered_workqueue(\n\t    mrioc->fwevt_worker_name, 0);\n\tif (!mrioc->fwevt_worker_thread) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tretval = -ENODEV;\n\t\tgoto fwevtthread_failed;\n\t}\n\n\tmrioc->is_driver_loading = 1;\n\tmrioc->cpu_count = num_online_cpus();\n\tif (mpi3mr_setup_resources(mrioc)) {\n\t\tioc_err(mrioc, \"setup resources failed\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto resource_alloc_failed;\n\t}\n\tif (mpi3mr_init_ioc(mrioc)) {\n\t\tioc_err(mrioc, \"initializing IOC failed\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto init_ioc_failed;\n\t}\n\n\tshost->nr_hw_queues = mrioc->num_op_reply_q;\n\tif (mrioc->active_poll_qcount)\n\t\tshost->nr_maps = 3;\n\n\tshost->can_queue = mrioc->max_host_ios;\n\tshost->sg_tablesize = mrioc->max_sgl_entries;\n\tshost->max_id = mrioc->facts.max_perids + 1;\n\n\tretval = scsi_add_host(shost, &pdev->dev);\n\tif (retval) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tgoto addhost_failed;\n\t}\n\n\tscsi_scan_host(shost);\n\tmpi3mr_bsg_init(mrioc);\n\treturn retval;\n\naddhost_failed:\n\tmpi3mr_stop_watchdog(mrioc);\n\tmpi3mr_cleanup_ioc(mrioc);\ninit_ioc_failed:\n\tmpi3mr_free_mem(mrioc);\n\tmpi3mr_cleanup_resources(mrioc);\nresource_alloc_failed:\n\tdestroy_workqueue(mrioc->fwevt_worker_thread);\nfwevtthread_failed:\n\tspin_lock(&mrioc_list_lock);\n\tlist_del(&mrioc->list);\n\tspin_unlock(&mrioc_list_lock);\n\tscsi_host_put(shost);\nshost_failed:\n\treturn retval;\n}\n\n \nstatic void mpi3mr_remove(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost = pci_get_drvdata(pdev);\n\tstruct mpi3mr_ioc *mrioc;\n\tstruct workqueue_struct\t*wq;\n\tunsigned long flags;\n\tstruct mpi3mr_tgt_dev *tgtdev, *tgtdev_next;\n\tstruct mpi3mr_hba_port *port, *hba_port_next;\n\tstruct mpi3mr_sas_node *sas_expander, *sas_expander_next;\n\n\tif (!shost)\n\t\treturn;\n\n\tmrioc = shost_priv(shost);\n\twhile (mrioc->reset_in_progress || mrioc->is_driver_loading)\n\t\tssleep(1);\n\n\tif (!pci_device_is_present(mrioc->pdev)) {\n\t\tmrioc->unrecoverable = 1;\n\t\tmpi3mr_flush_cmds_for_unrecovered_controller(mrioc);\n\t}\n\n\tmpi3mr_bsg_exit(mrioc);\n\tmrioc->stop_drv_processing = 1;\n\tmpi3mr_cleanup_fwevt_list(mrioc);\n\tspin_lock_irqsave(&mrioc->fwevt_lock, flags);\n\twq = mrioc->fwevt_worker_thread;\n\tmrioc->fwevt_worker_thread = NULL;\n\tspin_unlock_irqrestore(&mrioc->fwevt_lock, flags);\n\tif (wq)\n\t\tdestroy_workqueue(wq);\n\n\tif (mrioc->sas_transport_enabled)\n\t\tsas_remove_host(shost);\n\telse\n\t\tscsi_remove_host(shost);\n\n\tlist_for_each_entry_safe(tgtdev, tgtdev_next, &mrioc->tgtdev_list,\n\t    list) {\n\t\tmpi3mr_remove_tgtdev_from_host(mrioc, tgtdev);\n\t\tmpi3mr_tgtdev_del_from_list(mrioc, tgtdev, true);\n\t\tmpi3mr_tgtdev_put(tgtdev);\n\t}\n\tmpi3mr_stop_watchdog(mrioc);\n\tmpi3mr_cleanup_ioc(mrioc);\n\tmpi3mr_free_mem(mrioc);\n\tmpi3mr_cleanup_resources(mrioc);\n\n\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\tlist_for_each_entry_safe_reverse(sas_expander, sas_expander_next,\n\t    &mrioc->sas_expander_list, list) {\n\t\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\t\tmpi3mr_expander_node_remove(mrioc, sas_expander);\n\t\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\t}\n\tlist_for_each_entry_safe(port, hba_port_next, &mrioc->hba_port_table_list, list) {\n\t\tioc_info(mrioc,\n\t\t    \"removing hba_port entry: %p port: %d from hba_port list\\n\",\n\t\t    port, port->port_id);\n\t\tlist_del(&port->list);\n\t\tkfree(port);\n\t}\n\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\n\tif (mrioc->sas_hba.num_phys) {\n\t\tkfree(mrioc->sas_hba.phy);\n\t\tmrioc->sas_hba.phy = NULL;\n\t\tmrioc->sas_hba.num_phys = 0;\n\t}\n\n\tspin_lock(&mrioc_list_lock);\n\tlist_del(&mrioc->list);\n\tspin_unlock(&mrioc_list_lock);\n\n\tscsi_host_put(shost);\n}\n\n \nstatic void mpi3mr_shutdown(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost = pci_get_drvdata(pdev);\n\tstruct mpi3mr_ioc *mrioc;\n\tstruct workqueue_struct\t*wq;\n\tunsigned long flags;\n\n\tif (!shost)\n\t\treturn;\n\n\tmrioc = shost_priv(shost);\n\twhile (mrioc->reset_in_progress || mrioc->is_driver_loading)\n\t\tssleep(1);\n\n\tmrioc->stop_drv_processing = 1;\n\tmpi3mr_cleanup_fwevt_list(mrioc);\n\tspin_lock_irqsave(&mrioc->fwevt_lock, flags);\n\twq = mrioc->fwevt_worker_thread;\n\tmrioc->fwevt_worker_thread = NULL;\n\tspin_unlock_irqrestore(&mrioc->fwevt_lock, flags);\n\tif (wq)\n\t\tdestroy_workqueue(wq);\n\n\tmpi3mr_stop_watchdog(mrioc);\n\tmpi3mr_cleanup_ioc(mrioc);\n\tmpi3mr_cleanup_resources(mrioc);\n}\n\n \nstatic int __maybe_unused\nmpi3mr_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct Scsi_Host *shost = pci_get_drvdata(pdev);\n\tstruct mpi3mr_ioc *mrioc;\n\n\tif (!shost)\n\t\treturn 0;\n\n\tmrioc = shost_priv(shost);\n\twhile (mrioc->reset_in_progress || mrioc->is_driver_loading)\n\t\tssleep(1);\n\tmrioc->stop_drv_processing = 1;\n\tmpi3mr_cleanup_fwevt_list(mrioc);\n\tscsi_block_requests(shost);\n\tmpi3mr_stop_watchdog(mrioc);\n\tmpi3mr_cleanup_ioc(mrioc);\n\n\tioc_info(mrioc, \"pdev=0x%p, slot=%s, entering operating state\\n\",\n\t    pdev, pci_name(pdev));\n\tmpi3mr_cleanup_resources(mrioc);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused\nmpi3mr_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct Scsi_Host *shost = pci_get_drvdata(pdev);\n\tstruct mpi3mr_ioc *mrioc;\n\tpci_power_t device_state = pdev->current_state;\n\tint r;\n\n\tif (!shost)\n\t\treturn 0;\n\n\tmrioc = shost_priv(shost);\n\n\tioc_info(mrioc, \"pdev=0x%p, slot=%s, previous operating state [D%d]\\n\",\n\t    pdev, pci_name(pdev), device_state);\n\tmrioc->pdev = pdev;\n\tmrioc->cpu_count = num_online_cpus();\n\tr = mpi3mr_setup_resources(mrioc);\n\tif (r) {\n\t\tioc_info(mrioc, \"%s: Setup resources failed[%d]\\n\",\n\t\t    __func__, r);\n\t\treturn r;\n\t}\n\n\tmrioc->stop_drv_processing = 0;\n\tmpi3mr_invalidate_devhandles(mrioc);\n\tmpi3mr_free_enclosure_list(mrioc);\n\tmpi3mr_memset_buffers(mrioc);\n\tr = mpi3mr_reinit_ioc(mrioc, 1);\n\tif (r) {\n\t\tioc_err(mrioc, \"resuming controller failed[%d]\\n\", r);\n\t\treturn r;\n\t}\n\tssleep(MPI3MR_RESET_TOPOLOGY_SETTLE_TIME);\n\tscsi_unblock_requests(shost);\n\tmrioc->device_refresh_on = 0;\n\tmpi3mr_start_watchdog(mrioc);\n\n\treturn 0;\n}\n\nstatic const struct pci_device_id mpi3mr_pci_id_table[] = {\n\t{\n\t\tPCI_DEVICE_SUB(MPI3_MFGPAGE_VENDORID_BROADCOM,\n\t\t    MPI3_MFGPAGE_DEVID_SAS4116, PCI_ANY_ID, PCI_ANY_ID)\n\t},\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, mpi3mr_pci_id_table);\n\nstatic SIMPLE_DEV_PM_OPS(mpi3mr_pm_ops, mpi3mr_suspend, mpi3mr_resume);\n\nstatic struct pci_driver mpi3mr_pci_driver = {\n\t.name = MPI3MR_DRIVER_NAME,\n\t.id_table = mpi3mr_pci_id_table,\n\t.probe = mpi3mr_probe,\n\t.remove = mpi3mr_remove,\n\t.shutdown = mpi3mr_shutdown,\n\t.driver.pm = &mpi3mr_pm_ops,\n};\n\nstatic ssize_t event_counter_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%llu\\n\", atomic64_read(&event_counter));\n}\nstatic DRIVER_ATTR_RO(event_counter);\n\nstatic int __init mpi3mr_init(void)\n{\n\tint ret_val;\n\n\tpr_info(\"Loading %s version %s\\n\", MPI3MR_DRIVER_NAME,\n\t    MPI3MR_DRIVER_VERSION);\n\n\tmpi3mr_transport_template =\n\t    sas_attach_transport(&mpi3mr_transport_functions);\n\tif (!mpi3mr_transport_template) {\n\t\tpr_err(\"%s failed to load due to sas transport attach failure\\n\",\n\t\t    MPI3MR_DRIVER_NAME);\n\t\treturn -ENODEV;\n\t}\n\n\tret_val = pci_register_driver(&mpi3mr_pci_driver);\n\tif (ret_val) {\n\t\tpr_err(\"%s failed to load due to pci register driver failure\\n\",\n\t\t    MPI3MR_DRIVER_NAME);\n\t\tgoto err_pci_reg_fail;\n\t}\n\n\tret_val = driver_create_file(&mpi3mr_pci_driver.driver,\n\t\t\t\t     &driver_attr_event_counter);\n\tif (ret_val)\n\t\tgoto err_event_counter;\n\n\treturn ret_val;\n\nerr_event_counter:\n\tpci_unregister_driver(&mpi3mr_pci_driver);\n\nerr_pci_reg_fail:\n\tsas_release_transport(mpi3mr_transport_template);\n\treturn ret_val;\n}\n\nstatic void __exit mpi3mr_exit(void)\n{\n\tif (warn_non_secure_ctlr)\n\t\tpr_warn(\n\t\t    \"Unloading %s version %s while managing a non secure controller\\n\",\n\t\t    MPI3MR_DRIVER_NAME, MPI3MR_DRIVER_VERSION);\n\telse\n\t\tpr_info(\"Unloading %s version %s\\n\", MPI3MR_DRIVER_NAME,\n\t\t    MPI3MR_DRIVER_VERSION);\n\n\tdriver_remove_file(&mpi3mr_pci_driver.driver,\n\t\t\t   &driver_attr_event_counter);\n\tpci_unregister_driver(&mpi3mr_pci_driver);\n\tsas_release_transport(mpi3mr_transport_template);\n}\n\nmodule_init(mpi3mr_init);\nmodule_exit(mpi3mr_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}