{
  "module_name": "mpi3mr_app.c",
  "hash_id": "b47872d01efab2029a72fcb840022fb656032187ec840dd601f09b57a4f8f046",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mpi3mr/mpi3mr_app.c",
  "human_readable_source": "\n \n\n#include \"mpi3mr.h\"\n#include <linux/bsg-lib.h>\n#include <uapi/scsi/scsi_bsg_mpi3mr.h>\n\n \nstatic int mpi3mr_bsg_pel_abort(struct mpi3mr_ioc *mrioc)\n{\n\tstruct mpi3_pel_req_action_abort pel_abort_req;\n\tstruct mpi3_pel_reply *pel_reply;\n\tint retval = 0;\n\tu16 pe_log_status;\n\n\tif (mrioc->reset_in_progress) {\n\t\tdprint_bsg_err(mrioc, \"%s: reset in progress\\n\", __func__);\n\t\treturn -1;\n\t}\n\tif (mrioc->stop_bsgs) {\n\t\tdprint_bsg_err(mrioc, \"%s: bsgs are blocked\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tmemset(&pel_abort_req, 0, sizeof(pel_abort_req));\n\tmutex_lock(&mrioc->pel_abort_cmd.mutex);\n\tif (mrioc->pel_abort_cmd.state & MPI3MR_CMD_PENDING) {\n\t\tdprint_bsg_err(mrioc, \"%s: command is in use\\n\", __func__);\n\t\tmutex_unlock(&mrioc->pel_abort_cmd.mutex);\n\t\treturn -1;\n\t}\n\tmrioc->pel_abort_cmd.state = MPI3MR_CMD_PENDING;\n\tmrioc->pel_abort_cmd.is_waiting = 1;\n\tmrioc->pel_abort_cmd.callback = NULL;\n\tpel_abort_req.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_PEL_ABORT);\n\tpel_abort_req.function = MPI3_FUNCTION_PERSISTENT_EVENT_LOG;\n\tpel_abort_req.action = MPI3_PEL_ACTION_ABORT;\n\tpel_abort_req.abort_host_tag = cpu_to_le16(MPI3MR_HOSTTAG_PEL_WAIT);\n\n\tmrioc->pel_abort_requested = 1;\n\tinit_completion(&mrioc->pel_abort_cmd.done);\n\tretval = mpi3mr_admin_request_post(mrioc, &pel_abort_req,\n\t    sizeof(pel_abort_req), 0);\n\tif (retval) {\n\t\tretval = -1;\n\t\tdprint_bsg_err(mrioc, \"%s: admin request post failed\\n\",\n\t\t    __func__);\n\t\tmrioc->pel_abort_requested = 0;\n\t\tgoto out_unlock;\n\t}\n\n\twait_for_completion_timeout(&mrioc->pel_abort_cmd.done,\n\t    (MPI3MR_INTADMCMD_TIMEOUT * HZ));\n\tif (!(mrioc->pel_abort_cmd.state & MPI3MR_CMD_COMPLETE)) {\n\t\tmrioc->pel_abort_cmd.is_waiting = 0;\n\t\tdprint_bsg_err(mrioc, \"%s: command timedout\\n\", __func__);\n\t\tif (!(mrioc->pel_abort_cmd.state & MPI3MR_CMD_RESET))\n\t\t\tmpi3mr_soft_reset_handler(mrioc,\n\t\t\t    MPI3MR_RESET_FROM_PELABORT_TIMEOUT, 1);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\tif ((mrioc->pel_abort_cmd.ioc_status & MPI3_IOCSTATUS_STATUS_MASK)\n\t     != MPI3_IOCSTATUS_SUCCESS) {\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"%s: command failed, ioc_status(0x%04x) log_info(0x%08x)\\n\",\n\t\t    __func__, (mrioc->pel_abort_cmd.ioc_status &\n\t\t    MPI3_IOCSTATUS_STATUS_MASK),\n\t\t    mrioc->pel_abort_cmd.ioc_loginfo);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\tif (mrioc->pel_abort_cmd.state & MPI3MR_CMD_REPLY_VALID) {\n\t\tpel_reply = (struct mpi3_pel_reply *)mrioc->pel_abort_cmd.reply;\n\t\tpe_log_status = le16_to_cpu(pel_reply->pe_log_status);\n\t\tif (pe_log_status != MPI3_PEL_STATUS_SUCCESS) {\n\t\t\tdprint_bsg_err(mrioc,\n\t\t\t    \"%s: command failed, pel_status(0x%04x)\\n\",\n\t\t\t    __func__, pe_log_status);\n\t\t\tretval = -1;\n\t\t}\n\t}\n\nout_unlock:\n\tmrioc->pel_abort_cmd.state = MPI3MR_CMD_NOTUSED;\n\tmutex_unlock(&mrioc->pel_abort_cmd.mutex);\n\treturn retval;\n}\n \nstatic struct mpi3mr_ioc *mpi3mr_bsg_verify_adapter(int ioc_number)\n{\n\tstruct mpi3mr_ioc *mrioc = NULL;\n\n\tspin_lock(&mrioc_list_lock);\n\tlist_for_each_entry(mrioc, &mrioc_list, list) {\n\t\tif (mrioc->id == ioc_number) {\n\t\t\tspin_unlock(&mrioc_list_lock);\n\t\t\treturn mrioc;\n\t\t}\n\t}\n\tspin_unlock(&mrioc_list_lock);\n\treturn NULL;\n}\n\n \nstatic long mpi3mr_enable_logdata(struct mpi3mr_ioc *mrioc,\n\tstruct bsg_job *job)\n{\n\tstruct mpi3mr_logdata_enable logdata_enable;\n\n\tif (!mrioc->logdata_buf) {\n\t\tmrioc->logdata_entry_sz =\n\t\t    (mrioc->reply_sz - (sizeof(struct mpi3_event_notification_reply) - 4))\n\t\t    + MPI3MR_BSG_LOGDATA_ENTRY_HEADER_SZ;\n\t\tmrioc->logdata_buf_idx = 0;\n\t\tmrioc->logdata_buf = kcalloc(MPI3MR_BSG_LOGDATA_MAX_ENTRIES,\n\t\t    mrioc->logdata_entry_sz, GFP_KERNEL);\n\n\t\tif (!mrioc->logdata_buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmemset(&logdata_enable, 0, sizeof(logdata_enable));\n\tlogdata_enable.max_entries =\n\t    MPI3MR_BSG_LOGDATA_MAX_ENTRIES;\n\tif (job->request_payload.payload_len >= sizeof(logdata_enable)) {\n\t\tsg_copy_from_buffer(job->request_payload.sg_list,\n\t\t\t\t    job->request_payload.sg_cnt,\n\t\t\t\t    &logdata_enable, sizeof(logdata_enable));\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n \nstatic long mpi3mr_get_logdata(struct mpi3mr_ioc *mrioc,\n\tstruct bsg_job *job)\n{\n\tu16 num_entries, sz, entry_sz = mrioc->logdata_entry_sz;\n\n\tif ((!mrioc->logdata_buf) || (job->request_payload.payload_len < entry_sz))\n\t\treturn -EINVAL;\n\n\tnum_entries = job->request_payload.payload_len / entry_sz;\n\tif (num_entries > MPI3MR_BSG_LOGDATA_MAX_ENTRIES)\n\t\tnum_entries = MPI3MR_BSG_LOGDATA_MAX_ENTRIES;\n\tsz = num_entries * entry_sz;\n\n\tif (job->request_payload.payload_len >= sz) {\n\t\tsg_copy_from_buffer(job->request_payload.sg_list,\n\t\t\t\t    job->request_payload.sg_cnt,\n\t\t\t\t    mrioc->logdata_buf, sz);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic long mpi3mr_bsg_pel_enable(struct mpi3mr_ioc *mrioc,\n\t\t\t\t  struct bsg_job *job)\n{\n\tlong rval = -EINVAL;\n\tstruct mpi3mr_bsg_out_pel_enable pel_enable;\n\tu8 issue_pel_wait;\n\tu8 tmp_class;\n\tu16 tmp_locale;\n\n\tif (job->request_payload.payload_len != sizeof(pel_enable)) {\n\t\tdprint_bsg_err(mrioc, \"%s: invalid size argument\\n\",\n\t\t    __func__);\n\t\treturn rval;\n\t}\n\n\tif (mrioc->unrecoverable) {\n\t\tdprint_bsg_err(mrioc, \"%s: unrecoverable controller\\n\",\n\t\t\t       __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tif (mrioc->reset_in_progress) {\n\t\tdprint_bsg_err(mrioc, \"%s: reset in progress\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (mrioc->stop_bsgs) {\n\t\tdprint_bsg_err(mrioc, \"%s: bsgs are blocked\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\t\t  job->request_payload.sg_cnt,\n\t\t\t  &pel_enable, sizeof(pel_enable));\n\n\tif (pel_enable.pel_class > MPI3_PEL_CLASS_FAULT) {\n\t\tdprint_bsg_err(mrioc, \"%s: out of range class %d sent\\n\",\n\t\t\t__func__, pel_enable.pel_class);\n\t\trval = 0;\n\t\tgoto out;\n\t}\n\tif (!mrioc->pel_enabled)\n\t\tissue_pel_wait = 1;\n\telse {\n\t\tif ((mrioc->pel_class <= pel_enable.pel_class) &&\n\t\t    !((mrioc->pel_locale & pel_enable.pel_locale) ^\n\t\t      pel_enable.pel_locale)) {\n\t\t\tissue_pel_wait = 0;\n\t\t\trval = 0;\n\t\t} else {\n\t\t\tpel_enable.pel_locale |= mrioc->pel_locale;\n\n\t\t\tif (mrioc->pel_class < pel_enable.pel_class)\n\t\t\t\tpel_enable.pel_class = mrioc->pel_class;\n\n\t\t\trval = mpi3mr_bsg_pel_abort(mrioc);\n\t\t\tif (rval) {\n\t\t\t\tdprint_bsg_err(mrioc,\n\t\t\t\t    \"%s: pel_abort failed, status(%ld)\\n\",\n\t\t\t\t    __func__, rval);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tissue_pel_wait = 1;\n\t\t}\n\t}\n\tif (issue_pel_wait) {\n\t\ttmp_class = mrioc->pel_class;\n\t\ttmp_locale = mrioc->pel_locale;\n\t\tmrioc->pel_class = pel_enable.pel_class;\n\t\tmrioc->pel_locale = pel_enable.pel_locale;\n\t\tmrioc->pel_enabled = 1;\n\t\trval = mpi3mr_pel_get_seqnum_post(mrioc, NULL);\n\t\tif (rval) {\n\t\t\tmrioc->pel_class = tmp_class;\n\t\t\tmrioc->pel_locale = tmp_locale;\n\t\t\tmrioc->pel_enabled = 0;\n\t\t\tdprint_bsg_err(mrioc,\n\t\t\t    \"%s: pel get sequence number failed, status(%ld)\\n\",\n\t\t\t    __func__, rval);\n\t\t}\n\t}\n\nout:\n\treturn rval;\n}\n \nstatic long mpi3mr_get_all_tgt_info(struct mpi3mr_ioc *mrioc,\n\tstruct bsg_job *job)\n{\n\tu16 num_devices = 0, i = 0, size;\n\tunsigned long flags;\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\tstruct mpi3mr_device_map_info *devmap_info = NULL;\n\tstruct mpi3mr_all_tgt_info *alltgt_info = NULL;\n\tuint32_t min_entrylen = 0, kern_entrylen = 0, usr_entrylen = 0;\n\n\tif (job->request_payload.payload_len < sizeof(u32)) {\n\t\tdprint_bsg_err(mrioc, \"%s: invalid size argument\\n\",\n\t\t    __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\tlist_for_each_entry(tgtdev, &mrioc->tgtdev_list, list)\n\t\tnum_devices++;\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\n\tif ((job->request_payload.payload_len <= sizeof(u64)) ||\n\t\tlist_empty(&mrioc->tgtdev_list)) {\n\t\tsg_copy_from_buffer(job->request_payload.sg_list,\n\t\t\t\t    job->request_payload.sg_cnt,\n\t\t\t\t    &num_devices, sizeof(num_devices));\n\t\treturn 0;\n\t}\n\n\tkern_entrylen = num_devices * sizeof(*devmap_info);\n\tsize = sizeof(u64) + kern_entrylen;\n\talltgt_info = kzalloc(size, GFP_KERNEL);\n\tif (!alltgt_info)\n\t\treturn -ENOMEM;\n\n\tdevmap_info = alltgt_info->dmi;\n\tmemset((u8 *)devmap_info, 0xFF, kern_entrylen);\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\tlist_for_each_entry(tgtdev, &mrioc->tgtdev_list, list) {\n\t\tif (i < num_devices) {\n\t\t\tdevmap_info[i].handle = tgtdev->dev_handle;\n\t\t\tdevmap_info[i].perst_id = tgtdev->perst_id;\n\t\t\tif (tgtdev->host_exposed && tgtdev->starget) {\n\t\t\t\tdevmap_info[i].target_id = tgtdev->starget->id;\n\t\t\t\tdevmap_info[i].bus_id =\n\t\t\t\t    tgtdev->starget->channel;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tnum_devices = i;\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\n\talltgt_info->num_devices = num_devices;\n\n\tusr_entrylen = (job->request_payload.payload_len - sizeof(u64)) /\n\t\tsizeof(*devmap_info);\n\tusr_entrylen *= sizeof(*devmap_info);\n\tmin_entrylen = min(usr_entrylen, kern_entrylen);\n\n\tsg_copy_from_buffer(job->request_payload.sg_list,\n\t\t\t    job->request_payload.sg_cnt,\n\t\t\t    alltgt_info, (min_entrylen + sizeof(u64)));\n\tkfree(alltgt_info);\n\treturn 0;\n}\n \nstatic long mpi3mr_get_change_count(struct mpi3mr_ioc *mrioc,\n\tstruct bsg_job *job)\n{\n\tstruct mpi3mr_change_count chgcnt;\n\n\tmemset(&chgcnt, 0, sizeof(chgcnt));\n\tchgcnt.change_count = mrioc->change_count;\n\tif (job->request_payload.payload_len >= sizeof(chgcnt)) {\n\t\tsg_copy_from_buffer(job->request_payload.sg_list,\n\t\t\t\t    job->request_payload.sg_cnt,\n\t\t\t\t    &chgcnt, sizeof(chgcnt));\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic long mpi3mr_bsg_adp_reset(struct mpi3mr_ioc *mrioc,\n\tstruct bsg_job *job)\n{\n\tlong rval = -EINVAL;\n\tu8 save_snapdump;\n\tstruct mpi3mr_bsg_adp_reset adpreset;\n\n\tif (job->request_payload.payload_len !=\n\t\t\tsizeof(adpreset)) {\n\t\tdprint_bsg_err(mrioc, \"%s: invalid size argument\\n\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\t\t  job->request_payload.sg_cnt,\n\t\t\t  &adpreset, sizeof(adpreset));\n\n\tswitch (adpreset.reset_type) {\n\tcase MPI3MR_BSG_ADPRESET_SOFT:\n\t\tsave_snapdump = 0;\n\t\tbreak;\n\tcase MPI3MR_BSG_ADPRESET_DIAG_FAULT:\n\t\tsave_snapdump = 1;\n\t\tbreak;\n\tdefault:\n\t\tdprint_bsg_err(mrioc, \"%s: unknown reset_type(%d)\\n\",\n\t\t    __func__, adpreset.reset_type);\n\t\tgoto out;\n\t}\n\n\trval = mpi3mr_soft_reset_handler(mrioc, MPI3MR_RESET_FROM_APP,\n\t    save_snapdump);\n\n\tif (rval)\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"%s: reset handler returned error(%ld) for reset type %d\\n\",\n\t\t    __func__, rval, adpreset.reset_type);\nout:\n\treturn rval;\n}\n\n \nstatic long mpi3mr_bsg_populate_adpinfo(struct mpi3mr_ioc *mrioc,\n\tstruct bsg_job *job)\n{\n\tenum mpi3mr_iocstate ioc_state;\n\tstruct mpi3mr_bsg_in_adpinfo adpinfo;\n\n\tmemset(&adpinfo, 0, sizeof(adpinfo));\n\tadpinfo.adp_type = MPI3MR_BSG_ADPTYPE_AVGFAMILY;\n\tadpinfo.pci_dev_id = mrioc->pdev->device;\n\tadpinfo.pci_dev_hw_rev = mrioc->pdev->revision;\n\tadpinfo.pci_subsys_dev_id = mrioc->pdev->subsystem_device;\n\tadpinfo.pci_subsys_ven_id = mrioc->pdev->subsystem_vendor;\n\tadpinfo.pci_bus = mrioc->pdev->bus->number;\n\tadpinfo.pci_dev = PCI_SLOT(mrioc->pdev->devfn);\n\tadpinfo.pci_func = PCI_FUNC(mrioc->pdev->devfn);\n\tadpinfo.pci_seg_id = pci_domain_nr(mrioc->pdev->bus);\n\tadpinfo.app_intfc_ver = MPI3MR_IOCTL_VERSION;\n\n\tioc_state = mpi3mr_get_iocstate(mrioc);\n\tif (ioc_state == MRIOC_STATE_UNRECOVERABLE)\n\t\tadpinfo.adp_state = MPI3MR_BSG_ADPSTATE_UNRECOVERABLE;\n\telse if ((mrioc->reset_in_progress) || (mrioc->stop_bsgs))\n\t\tadpinfo.adp_state = MPI3MR_BSG_ADPSTATE_IN_RESET;\n\telse if (ioc_state == MRIOC_STATE_FAULT)\n\t\tadpinfo.adp_state = MPI3MR_BSG_ADPSTATE_FAULT;\n\telse\n\t\tadpinfo.adp_state = MPI3MR_BSG_ADPSTATE_OPERATIONAL;\n\n\tmemcpy((u8 *)&adpinfo.driver_info, (u8 *)&mrioc->driver_info,\n\t    sizeof(adpinfo.driver_info));\n\n\tif (job->request_payload.payload_len >= sizeof(adpinfo)) {\n\t\tsg_copy_from_buffer(job->request_payload.sg_list,\n\t\t\t\t    job->request_payload.sg_cnt,\n\t\t\t\t    &adpinfo, sizeof(adpinfo));\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic long mpi3mr_bsg_process_drv_cmds(struct bsg_job *job)\n{\n\tlong rval = -EINVAL;\n\tstruct mpi3mr_ioc *mrioc = NULL;\n\tstruct mpi3mr_bsg_packet *bsg_req = NULL;\n\tstruct mpi3mr_bsg_drv_cmd *drvrcmd = NULL;\n\n\tbsg_req = job->request;\n\tdrvrcmd = &bsg_req->cmd.drvrcmd;\n\n\tmrioc = mpi3mr_bsg_verify_adapter(drvrcmd->mrioc_id);\n\tif (!mrioc)\n\t\treturn -ENODEV;\n\n\tif (drvrcmd->opcode == MPI3MR_DRVBSG_OPCODE_ADPINFO) {\n\t\trval = mpi3mr_bsg_populate_adpinfo(mrioc, job);\n\t\treturn rval;\n\t}\n\n\tif (mutex_lock_interruptible(&mrioc->bsg_cmds.mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (drvrcmd->opcode) {\n\tcase MPI3MR_DRVBSG_OPCODE_ADPRESET:\n\t\trval = mpi3mr_bsg_adp_reset(mrioc, job);\n\t\tbreak;\n\tcase MPI3MR_DRVBSG_OPCODE_ALLTGTDEVINFO:\n\t\trval = mpi3mr_get_all_tgt_info(mrioc, job);\n\t\tbreak;\n\tcase MPI3MR_DRVBSG_OPCODE_GETCHGCNT:\n\t\trval = mpi3mr_get_change_count(mrioc, job);\n\t\tbreak;\n\tcase MPI3MR_DRVBSG_OPCODE_LOGDATAENABLE:\n\t\trval = mpi3mr_enable_logdata(mrioc, job);\n\t\tbreak;\n\tcase MPI3MR_DRVBSG_OPCODE_GETLOGDATA:\n\t\trval = mpi3mr_get_logdata(mrioc, job);\n\t\tbreak;\n\tcase MPI3MR_DRVBSG_OPCODE_PELENABLE:\n\t\trval = mpi3mr_bsg_pel_enable(mrioc, job);\n\t\tbreak;\n\tcase MPI3MR_DRVBSG_OPCODE_UNKNOWN:\n\tdefault:\n\t\tpr_err(\"%s: unsupported driver command opcode %d\\n\",\n\t\t    MPI3MR_DRIVER_NAME, drvrcmd->opcode);\n\t\tbreak;\n\t}\n\tmutex_unlock(&mrioc->bsg_cmds.mutex);\n\treturn rval;\n}\n\n \nstatic void mpi3mr_bsg_build_sgl(u8 *mpi_req, uint32_t sgl_offset,\n\tstruct mpi3mr_buf_map *drv_bufs, u8 bufcnt, u8 is_rmc,\n\tu8 is_rmr, u8 num_datasges)\n{\n\tu8 *sgl = (mpi_req + sgl_offset), count = 0;\n\tstruct mpi3_mgmt_passthrough_request *rmgmt_req =\n\t    (struct mpi3_mgmt_passthrough_request *)mpi_req;\n\tstruct mpi3mr_buf_map *drv_buf_iter = drv_bufs;\n\tu8 sgl_flags, sgl_flags_last;\n\n\tsgl_flags = MPI3_SGE_FLAGS_ELEMENT_TYPE_SIMPLE |\n\t\tMPI3_SGE_FLAGS_DLAS_SYSTEM | MPI3_SGE_FLAGS_END_OF_BUFFER;\n\tsgl_flags_last = sgl_flags | MPI3_SGE_FLAGS_END_OF_LIST;\n\n\tif (is_rmc) {\n\t\tmpi3mr_add_sg_single(&rmgmt_req->command_sgl,\n\t\t    sgl_flags_last, drv_buf_iter->kern_buf_len,\n\t\t    drv_buf_iter->kern_buf_dma);\n\t\tsgl = (u8 *)drv_buf_iter->kern_buf + drv_buf_iter->bsg_buf_len;\n\t\tdrv_buf_iter++;\n\t\tcount++;\n\t\tif (is_rmr) {\n\t\t\tmpi3mr_add_sg_single(&rmgmt_req->response_sgl,\n\t\t\t    sgl_flags_last, drv_buf_iter->kern_buf_len,\n\t\t\t    drv_buf_iter->kern_buf_dma);\n\t\t\tdrv_buf_iter++;\n\t\t\tcount++;\n\t\t} else\n\t\t\tmpi3mr_build_zero_len_sge(\n\t\t\t    &rmgmt_req->response_sgl);\n\t}\n\tif (!num_datasges) {\n\t\tmpi3mr_build_zero_len_sge(sgl);\n\t\treturn;\n\t}\n\tfor (; count < bufcnt; count++, drv_buf_iter++) {\n\t\tif (drv_buf_iter->data_dir == DMA_NONE)\n\t\t\tcontinue;\n\t\tif (num_datasges == 1 || !is_rmc)\n\t\t\tmpi3mr_add_sg_single(sgl, sgl_flags_last,\n\t\t\t    drv_buf_iter->kern_buf_len, drv_buf_iter->kern_buf_dma);\n\t\telse\n\t\t\tmpi3mr_add_sg_single(sgl, sgl_flags,\n\t\t\t    drv_buf_iter->kern_buf_len, drv_buf_iter->kern_buf_dma);\n\t\tsgl += sizeof(struct mpi3_sge_common);\n\t\tnum_datasges--;\n\t}\n}\n\n \nstatic unsigned int mpi3mr_get_nvme_data_fmt(\n\tstruct mpi3_nvme_encapsulated_request *nvme_encap_request)\n{\n\tu8 format = 0;\n\n\tformat = ((nvme_encap_request->command[0] & 0xc000) >> 14);\n\treturn format;\n\n}\n\n \nstatic int mpi3mr_build_nvme_sgl(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_nvme_encapsulated_request *nvme_encap_request,\n\tstruct mpi3mr_buf_map *drv_bufs, u8 bufcnt)\n{\n\tstruct mpi3mr_nvme_pt_sge *nvme_sgl;\n\tu64 sgl_ptr;\n\tu8 count;\n\tsize_t length = 0;\n\tstruct mpi3mr_buf_map *drv_buf_iter = drv_bufs;\n\tu64 sgemod_mask = ((u64)((mrioc->facts.sge_mod_mask) <<\n\t\t\t    mrioc->facts.sge_mod_shift) << 32);\n\tu64 sgemod_val = ((u64)(mrioc->facts.sge_mod_value) <<\n\t\t\t  mrioc->facts.sge_mod_shift) << 32;\n\n\t \n\tfor (count = 0; count < bufcnt; count++, drv_buf_iter++) {\n\t\tif (drv_buf_iter->data_dir == DMA_NONE)\n\t\t\tcontinue;\n\t\tsgl_ptr = (u64)drv_buf_iter->kern_buf_dma;\n\t\tlength = drv_buf_iter->kern_buf_len;\n\t\tbreak;\n\t}\n\tif (!length)\n\t\treturn 0;\n\n\tif (sgl_ptr & sgemod_mask) {\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"%s: SGL address collides with SGE modifier\\n\",\n\t\t    __func__);\n\t\treturn -1;\n\t}\n\n\tsgl_ptr &= ~sgemod_mask;\n\tsgl_ptr |= sgemod_val;\n\tnvme_sgl = (struct mpi3mr_nvme_pt_sge *)\n\t    ((u8 *)(nvme_encap_request->command) + MPI3MR_NVME_CMD_SGL_OFFSET);\n\tmemset(nvme_sgl, 0, sizeof(struct mpi3mr_nvme_pt_sge));\n\tnvme_sgl->base_addr = sgl_ptr;\n\tnvme_sgl->length = length;\n\treturn 0;\n}\n\n \nstatic int mpi3mr_build_nvme_prp(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_nvme_encapsulated_request *nvme_encap_request,\n\tstruct mpi3mr_buf_map *drv_bufs, u8 bufcnt)\n{\n\tint prp_size = MPI3MR_NVME_PRP_SIZE;\n\t__le64 *prp_entry, *prp1_entry, *prp2_entry;\n\t__le64 *prp_page;\n\tdma_addr_t prp_entry_dma, prp_page_dma, dma_addr;\n\tu32 offset, entry_len, dev_pgsz;\n\tu32 page_mask_result, page_mask;\n\tsize_t length = 0;\n\tu8 count;\n\tstruct mpi3mr_buf_map *drv_buf_iter = drv_bufs;\n\tu64 sgemod_mask = ((u64)((mrioc->facts.sge_mod_mask) <<\n\t\t\t    mrioc->facts.sge_mod_shift) << 32);\n\tu64 sgemod_val = ((u64)(mrioc->facts.sge_mod_value) <<\n\t\t\t  mrioc->facts.sge_mod_shift) << 32;\n\tu16 dev_handle = nvme_encap_request->dev_handle;\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\n\ttgtdev = mpi3mr_get_tgtdev_by_handle(mrioc, dev_handle);\n\tif (!tgtdev) {\n\t\tdprint_bsg_err(mrioc, \"%s: invalid device handle 0x%04x\\n\",\n\t\t\t__func__, dev_handle);\n\t\treturn -1;\n\t}\n\n\tif (tgtdev->dev_spec.pcie_inf.pgsz == 0) {\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"%s: NVMe device page size is zero for handle 0x%04x\\n\",\n\t\t    __func__, dev_handle);\n\t\tmpi3mr_tgtdev_put(tgtdev);\n\t\treturn -1;\n\t}\n\n\tdev_pgsz = 1 << (tgtdev->dev_spec.pcie_inf.pgsz);\n\tmpi3mr_tgtdev_put(tgtdev);\n\n\t \n\tfor (count = 0; count < bufcnt; count++, drv_buf_iter++) {\n\t\tif (drv_buf_iter->data_dir == DMA_NONE)\n\t\t\tcontinue;\n\t\tdma_addr = drv_buf_iter->kern_buf_dma;\n\t\tlength = drv_buf_iter->kern_buf_len;\n\t\tbreak;\n\t}\n\n\tif (!length)\n\t\treturn 0;\n\n\tmrioc->prp_sz = 0;\n\tmrioc->prp_list_virt = dma_alloc_coherent(&mrioc->pdev->dev,\n\t    dev_pgsz, &mrioc->prp_list_dma, GFP_KERNEL);\n\n\tif (!mrioc->prp_list_virt)\n\t\treturn -1;\n\tmrioc->prp_sz = dev_pgsz;\n\n\t \n\tprp1_entry = (__le64 *)((u8 *)(nvme_encap_request->command) +\n\t    MPI3MR_NVME_CMD_PRP1_OFFSET);\n\tprp2_entry = (__le64 *)((u8 *)(nvme_encap_request->command) +\n\t    MPI3MR_NVME_CMD_PRP2_OFFSET);\n\tprp_entry = prp1_entry;\n\t \n\tprp_page = (__le64 *)mrioc->prp_list_virt;\n\tprp_page_dma = mrioc->prp_list_dma;\n\n\t \n\tpage_mask = dev_pgsz - 1;\n\tpage_mask_result = (uintptr_t)((u8 *)prp_page + prp_size) & page_mask;\n\tif (!page_mask_result) {\n\t\tdprint_bsg_err(mrioc, \"%s: PRP page is not page aligned\\n\",\n\t\t    __func__);\n\t\tgoto err_out;\n\t}\n\n\t \n\tprp_entry_dma = prp_page_dma;\n\n\n\t \n\twhile (length) {\n\t\tpage_mask_result = (prp_entry_dma + prp_size) & page_mask;\n\t\tif (!page_mask_result && (length >  dev_pgsz)) {\n\t\t\tdprint_bsg_err(mrioc,\n\t\t\t    \"%s: single PRP page is not sufficient\\n\",\n\t\t\t    __func__);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\t \n\t\toffset = dma_addr & page_mask;\n\t\tentry_len = dev_pgsz - offset;\n\n\t\tif (prp_entry == prp1_entry) {\n\t\t\t \n\t\t\t*prp1_entry = cpu_to_le64(dma_addr);\n\t\t\tif (*prp1_entry & sgemod_mask) {\n\t\t\t\tdprint_bsg_err(mrioc,\n\t\t\t\t    \"%s: PRP1 address collides with SGE modifier\\n\",\n\t\t\t\t    __func__);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t*prp1_entry &= ~sgemod_mask;\n\t\t\t*prp1_entry |= sgemod_val;\n\n\t\t\t \n\t\t\tprp_entry = prp2_entry;\n\t\t} else if (prp_entry == prp2_entry) {\n\t\t\t \n\t\t\tif (length > dev_pgsz) {\n\t\t\t\t \n\t\t\t\t*prp2_entry = cpu_to_le64(prp_entry_dma);\n\t\t\t\tif (*prp2_entry & sgemod_mask) {\n\t\t\t\t\tdprint_bsg_err(mrioc,\n\t\t\t\t\t    \"%s: PRP list address collides with SGE modifier\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\tgoto err_out;\n\t\t\t\t}\n\t\t\t\t*prp2_entry &= ~sgemod_mask;\n\t\t\t\t*prp2_entry |= sgemod_val;\n\n\t\t\t\t \n\t\t\t\tprp_entry = prp_page;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t*prp2_entry = cpu_to_le64(dma_addr);\n\t\t\t\tif (*prp2_entry & sgemod_mask) {\n\t\t\t\t\tdprint_bsg_err(mrioc,\n\t\t\t\t\t    \"%s: PRP2 collides with SGE modifier\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\tgoto err_out;\n\t\t\t\t}\n\t\t\t\t*prp2_entry &= ~sgemod_mask;\n\t\t\t\t*prp2_entry |= sgemod_val;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\t*prp_entry = cpu_to_le64(dma_addr);\n\t\t\tif (*prp_entry & sgemod_mask) {\n\t\t\t\tdprint_bsg_err(mrioc,\n\t\t\t\t    \"%s: PRP address collides with SGE modifier\\n\",\n\t\t\t\t    __func__);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t*prp_entry &= ~sgemod_mask;\n\t\t\t*prp_entry |= sgemod_val;\n\t\t\tprp_entry++;\n\t\t\tprp_entry_dma += prp_size;\n\t\t}\n\n\t\t \n\t\tdma_addr += entry_len;\n\n\t\t \n\t\tif (entry_len > length)\n\t\t\tlength = 0;\n\t\telse\n\t\t\tlength -= entry_len;\n\t}\n\treturn 0;\nerr_out:\n\tif (mrioc->prp_list_virt) {\n\t\tdma_free_coherent(&mrioc->pdev->dev, mrioc->prp_sz,\n\t\t    mrioc->prp_list_virt, mrioc->prp_list_dma);\n\t\tmrioc->prp_list_virt = NULL;\n\t}\n\treturn -1;\n}\n \n\nstatic long mpi3mr_bsg_process_mpt_cmds(struct bsg_job *job, unsigned int *reply_payload_rcv_len)\n{\n\tlong rval = -EINVAL;\n\n\tstruct mpi3mr_ioc *mrioc = NULL;\n\tu8 *mpi_req = NULL, *sense_buff_k = NULL;\n\tu8 mpi_msg_size = 0;\n\tstruct mpi3mr_bsg_packet *bsg_req = NULL;\n\tstruct mpi3mr_bsg_mptcmd *karg;\n\tstruct mpi3mr_buf_entry *buf_entries = NULL;\n\tstruct mpi3mr_buf_map *drv_bufs = NULL, *drv_buf_iter = NULL;\n\tu8 count, bufcnt = 0, is_rmcb = 0, is_rmrb = 0, din_cnt = 0, dout_cnt = 0;\n\tu8 invalid_be = 0, erb_offset = 0xFF, mpirep_offset = 0xFF, sg_entries = 0;\n\tu8 block_io = 0, resp_code = 0, nvme_fmt = 0;\n\tstruct mpi3_request_header *mpi_header = NULL;\n\tstruct mpi3_status_reply_descriptor *status_desc;\n\tstruct mpi3_scsi_task_mgmt_request *tm_req;\n\tu32 erbsz = MPI3MR_SENSE_BUF_SZ, tmplen;\n\tu16 dev_handle;\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\tstruct mpi3mr_stgt_priv_data *stgt_priv = NULL;\n\tstruct mpi3mr_bsg_in_reply_buf *bsg_reply_buf = NULL;\n\tu32 din_size = 0, dout_size = 0;\n\tu8 *din_buf = NULL, *dout_buf = NULL;\n\tu8 *sgl_iter = NULL, *sgl_din_iter = NULL, *sgl_dout_iter = NULL;\n\n\tbsg_req = job->request;\n\tkarg = (struct mpi3mr_bsg_mptcmd *)&bsg_req->cmd.mptcmd;\n\n\tmrioc = mpi3mr_bsg_verify_adapter(karg->mrioc_id);\n\tif (!mrioc)\n\t\treturn -ENODEV;\n\n\tif (karg->timeout < MPI3MR_APP_DEFAULT_TIMEOUT)\n\t\tkarg->timeout = MPI3MR_APP_DEFAULT_TIMEOUT;\n\n\tmpi_req = kzalloc(MPI3MR_ADMIN_REQ_FRAME_SZ, GFP_KERNEL);\n\tif (!mpi_req)\n\t\treturn -ENOMEM;\n\tmpi_header = (struct mpi3_request_header *)mpi_req;\n\n\tbufcnt = karg->buf_entry_list.num_of_entries;\n\tdrv_bufs = kzalloc((sizeof(*drv_bufs) * bufcnt), GFP_KERNEL);\n\tif (!drv_bufs) {\n\t\trval = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdout_buf = kzalloc(job->request_payload.payload_len,\n\t\t\t\t      GFP_KERNEL);\n\tif (!dout_buf) {\n\t\trval = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdin_buf = kzalloc(job->reply_payload.payload_len,\n\t\t\t\t     GFP_KERNEL);\n\tif (!din_buf) {\n\t\trval = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\t\t  job->request_payload.sg_cnt,\n\t\t\t  dout_buf, job->request_payload.payload_len);\n\n\tbuf_entries = karg->buf_entry_list.buf_entry;\n\tsgl_din_iter = din_buf;\n\tsgl_dout_iter = dout_buf;\n\tdrv_buf_iter = drv_bufs;\n\n\tfor (count = 0; count < bufcnt; count++, buf_entries++, drv_buf_iter++) {\n\n\t\tif (sgl_dout_iter > (dout_buf + job->request_payload.payload_len)) {\n\t\t\tdprint_bsg_err(mrioc, \"%s: data_out buffer length mismatch\\n\",\n\t\t\t\t__func__);\n\t\t\trval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sgl_din_iter > (din_buf + job->reply_payload.payload_len)) {\n\t\t\tdprint_bsg_err(mrioc, \"%s: data_in buffer length mismatch\\n\",\n\t\t\t\t__func__);\n\t\t\trval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (buf_entries->buf_type) {\n\t\tcase MPI3MR_BSG_BUFTYPE_RAIDMGMT_CMD:\n\t\t\tsgl_iter = sgl_dout_iter;\n\t\t\tsgl_dout_iter += buf_entries->buf_len;\n\t\t\tdrv_buf_iter->data_dir = DMA_TO_DEVICE;\n\t\t\tis_rmcb = 1;\n\t\t\tif (count != 0)\n\t\t\t\tinvalid_be = 1;\n\t\t\tbreak;\n\t\tcase MPI3MR_BSG_BUFTYPE_RAIDMGMT_RESP:\n\t\t\tsgl_iter = sgl_din_iter;\n\t\t\tsgl_din_iter += buf_entries->buf_len;\n\t\t\tdrv_buf_iter->data_dir = DMA_FROM_DEVICE;\n\t\t\tis_rmrb = 1;\n\t\t\tif (count != 1 || !is_rmcb)\n\t\t\t\tinvalid_be = 1;\n\t\t\tbreak;\n\t\tcase MPI3MR_BSG_BUFTYPE_DATA_IN:\n\t\t\tsgl_iter = sgl_din_iter;\n\t\t\tsgl_din_iter += buf_entries->buf_len;\n\t\t\tdrv_buf_iter->data_dir = DMA_FROM_DEVICE;\n\t\t\tdin_cnt++;\n\t\t\tdin_size += drv_buf_iter->bsg_buf_len;\n\t\t\tif ((din_cnt > 1) && !is_rmcb)\n\t\t\t\tinvalid_be = 1;\n\t\t\tbreak;\n\t\tcase MPI3MR_BSG_BUFTYPE_DATA_OUT:\n\t\t\tsgl_iter = sgl_dout_iter;\n\t\t\tsgl_dout_iter += buf_entries->buf_len;\n\t\t\tdrv_buf_iter->data_dir = DMA_TO_DEVICE;\n\t\t\tdout_cnt++;\n\t\t\tdout_size += drv_buf_iter->bsg_buf_len;\n\t\t\tif ((dout_cnt > 1) && !is_rmcb)\n\t\t\t\tinvalid_be = 1;\n\t\t\tbreak;\n\t\tcase MPI3MR_BSG_BUFTYPE_MPI_REPLY:\n\t\t\tsgl_iter = sgl_din_iter;\n\t\t\tsgl_din_iter += buf_entries->buf_len;\n\t\t\tdrv_buf_iter->data_dir = DMA_NONE;\n\t\t\tmpirep_offset = count;\n\t\t\tbreak;\n\t\tcase MPI3MR_BSG_BUFTYPE_ERR_RESPONSE:\n\t\t\tsgl_iter = sgl_din_iter;\n\t\t\tsgl_din_iter += buf_entries->buf_len;\n\t\t\tdrv_buf_iter->data_dir = DMA_NONE;\n\t\t\terb_offset = count;\n\t\t\tbreak;\n\t\tcase MPI3MR_BSG_BUFTYPE_MPI_REQUEST:\n\t\t\tsgl_iter = sgl_dout_iter;\n\t\t\tsgl_dout_iter += buf_entries->buf_len;\n\t\t\tdrv_buf_iter->data_dir = DMA_NONE;\n\t\t\tmpi_msg_size = buf_entries->buf_len;\n\t\t\tif ((!mpi_msg_size || (mpi_msg_size % 4)) ||\n\t\t\t\t\t(mpi_msg_size > MPI3MR_ADMIN_REQ_FRAME_SZ)) {\n\t\t\t\tdprint_bsg_err(mrioc, \"%s: invalid MPI message size\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\trval = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(mpi_req, sgl_iter, buf_entries->buf_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinvalid_be = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (invalid_be) {\n\t\t\tdprint_bsg_err(mrioc, \"%s: invalid buffer entries passed\\n\",\n\t\t\t\t__func__);\n\t\t\trval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdrv_buf_iter->bsg_buf = sgl_iter;\n\t\tdrv_buf_iter->bsg_buf_len = buf_entries->buf_len;\n\n\t}\n\tif (!is_rmcb && (dout_cnt || din_cnt)) {\n\t\tsg_entries = dout_cnt + din_cnt;\n\t\tif (((mpi_msg_size) + (sg_entries *\n\t\t      sizeof(struct mpi3_sge_common))) > MPI3MR_ADMIN_REQ_FRAME_SZ) {\n\t\t\tdprint_bsg_err(mrioc,\n\t\t\t    \"%s:%d: invalid message size passed\\n\",\n\t\t\t    __func__, __LINE__);\n\t\t\trval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (din_size > MPI3MR_MAX_APP_XFER_SIZE) {\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"%s:%d: invalid data transfer size passed for function 0x%x din_size=%d\\n\",\n\t\t    __func__, __LINE__, mpi_header->function, din_size);\n\t\trval = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (dout_size > MPI3MR_MAX_APP_XFER_SIZE) {\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"%s:%d: invalid data transfer size passed for function 0x%x dout_size = %d\\n\",\n\t\t    __func__, __LINE__, mpi_header->function, dout_size);\n\t\trval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdrv_buf_iter = drv_bufs;\n\tfor (count = 0; count < bufcnt; count++, drv_buf_iter++) {\n\t\tif (drv_buf_iter->data_dir == DMA_NONE)\n\t\t\tcontinue;\n\n\t\tdrv_buf_iter->kern_buf_len = drv_buf_iter->bsg_buf_len;\n\t\tif (is_rmcb && !count)\n\t\t\tdrv_buf_iter->kern_buf_len += ((dout_cnt + din_cnt) *\n\t\t\t    sizeof(struct mpi3_sge_common));\n\n\t\tif (!drv_buf_iter->kern_buf_len)\n\t\t\tcontinue;\n\n\t\tdrv_buf_iter->kern_buf = dma_alloc_coherent(&mrioc->pdev->dev,\n\t\t    drv_buf_iter->kern_buf_len, &drv_buf_iter->kern_buf_dma,\n\t\t    GFP_KERNEL);\n\t\tif (!drv_buf_iter->kern_buf) {\n\t\t\trval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (drv_buf_iter->data_dir == DMA_TO_DEVICE) {\n\t\t\ttmplen = min(drv_buf_iter->kern_buf_len,\n\t\t\t    drv_buf_iter->bsg_buf_len);\n\t\t\tmemcpy(drv_buf_iter->kern_buf, drv_buf_iter->bsg_buf, tmplen);\n\t\t}\n\t}\n\n\tif (erb_offset != 0xFF) {\n\t\tsense_buff_k = kzalloc(erbsz, GFP_KERNEL);\n\t\tif (!sense_buff_k) {\n\t\t\trval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (mutex_lock_interruptible(&mrioc->bsg_cmds.mutex)) {\n\t\trval = -ERESTARTSYS;\n\t\tgoto out;\n\t}\n\tif (mrioc->bsg_cmds.state & MPI3MR_CMD_PENDING) {\n\t\trval = -EAGAIN;\n\t\tdprint_bsg_err(mrioc, \"%s: command is in use\\n\", __func__);\n\t\tmutex_unlock(&mrioc->bsg_cmds.mutex);\n\t\tgoto out;\n\t}\n\tif (mrioc->unrecoverable) {\n\t\tdprint_bsg_err(mrioc, \"%s: unrecoverable controller\\n\",\n\t\t    __func__);\n\t\trval = -EFAULT;\n\t\tmutex_unlock(&mrioc->bsg_cmds.mutex);\n\t\tgoto out;\n\t}\n\tif (mrioc->reset_in_progress) {\n\t\tdprint_bsg_err(mrioc, \"%s: reset in progress\\n\", __func__);\n\t\trval = -EAGAIN;\n\t\tmutex_unlock(&mrioc->bsg_cmds.mutex);\n\t\tgoto out;\n\t}\n\tif (mrioc->stop_bsgs) {\n\t\tdprint_bsg_err(mrioc, \"%s: bsgs are blocked\\n\", __func__);\n\t\trval = -EAGAIN;\n\t\tmutex_unlock(&mrioc->bsg_cmds.mutex);\n\t\tgoto out;\n\t}\n\n\tif (mpi_header->function == MPI3_BSG_FUNCTION_NVME_ENCAPSULATED) {\n\t\tnvme_fmt = mpi3mr_get_nvme_data_fmt(\n\t\t\t(struct mpi3_nvme_encapsulated_request *)mpi_req);\n\t\tif (nvme_fmt == MPI3MR_NVME_DATA_FORMAT_PRP) {\n\t\t\tif (mpi3mr_build_nvme_prp(mrioc,\n\t\t\t    (struct mpi3_nvme_encapsulated_request *)mpi_req,\n\t\t\t    drv_bufs, bufcnt)) {\n\t\t\t\trval = -ENOMEM;\n\t\t\t\tmutex_unlock(&mrioc->bsg_cmds.mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (nvme_fmt == MPI3MR_NVME_DATA_FORMAT_SGL1 ||\n\t\t\tnvme_fmt == MPI3MR_NVME_DATA_FORMAT_SGL2) {\n\t\t\tif (mpi3mr_build_nvme_sgl(mrioc,\n\t\t\t    (struct mpi3_nvme_encapsulated_request *)mpi_req,\n\t\t\t    drv_bufs, bufcnt)) {\n\t\t\t\trval = -EINVAL;\n\t\t\t\tmutex_unlock(&mrioc->bsg_cmds.mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tdprint_bsg_err(mrioc,\n\t\t\t    \"%s:invalid NVMe command format\\n\", __func__);\n\t\t\trval = -EINVAL;\n\t\t\tmutex_unlock(&mrioc->bsg_cmds.mutex);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tmpi3mr_bsg_build_sgl(mpi_req, (mpi_msg_size),\n\t\t    drv_bufs, bufcnt, is_rmcb, is_rmrb,\n\t\t    (dout_cnt + din_cnt));\n\t}\n\n\tif (mpi_header->function == MPI3_BSG_FUNCTION_SCSI_TASK_MGMT) {\n\t\ttm_req = (struct mpi3_scsi_task_mgmt_request *)mpi_req;\n\t\tif (tm_req->task_type !=\n\t\t    MPI3_SCSITASKMGMT_TASKTYPE_ABORT_TASK) {\n\t\t\tdev_handle = tm_req->dev_handle;\n\t\t\tblock_io = 1;\n\t\t}\n\t}\n\tif (block_io) {\n\t\ttgtdev = mpi3mr_get_tgtdev_by_handle(mrioc, dev_handle);\n\t\tif (tgtdev && tgtdev->starget && tgtdev->starget->hostdata) {\n\t\t\tstgt_priv = (struct mpi3mr_stgt_priv_data *)\n\t\t\t    tgtdev->starget->hostdata;\n\t\t\tatomic_inc(&stgt_priv->block_io);\n\t\t\tmpi3mr_tgtdev_put(tgtdev);\n\t\t}\n\t}\n\n\tmrioc->bsg_cmds.state = MPI3MR_CMD_PENDING;\n\tmrioc->bsg_cmds.is_waiting = 1;\n\tmrioc->bsg_cmds.callback = NULL;\n\tmrioc->bsg_cmds.is_sense = 0;\n\tmrioc->bsg_cmds.sensebuf = sense_buff_k;\n\tmemset(mrioc->bsg_cmds.reply, 0, mrioc->reply_sz);\n\tmpi_header->host_tag = cpu_to_le16(MPI3MR_HOSTTAG_BSG_CMDS);\n\tif (mrioc->logging_level & MPI3_DEBUG_BSG_INFO) {\n\t\tdprint_bsg_info(mrioc,\n\t\t    \"%s: posting bsg request to the controller\\n\", __func__);\n\t\tdprint_dump(mpi_req, MPI3MR_ADMIN_REQ_FRAME_SZ,\n\t\t    \"bsg_mpi3_req\");\n\t\tif (mpi_header->function == MPI3_BSG_FUNCTION_MGMT_PASSTHROUGH) {\n\t\t\tdrv_buf_iter = &drv_bufs[0];\n\t\t\tdprint_dump(drv_buf_iter->kern_buf,\n\t\t\t    drv_buf_iter->kern_buf_len, \"mpi3_mgmt_req\");\n\t\t}\n\t}\n\n\tinit_completion(&mrioc->bsg_cmds.done);\n\trval = mpi3mr_admin_request_post(mrioc, mpi_req,\n\t    MPI3MR_ADMIN_REQ_FRAME_SZ, 0);\n\n\n\tif (rval) {\n\t\tmrioc->bsg_cmds.is_waiting = 0;\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"%s: posting bsg request is failed\\n\", __func__);\n\t\trval = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\twait_for_completion_timeout(&mrioc->bsg_cmds.done,\n\t    (karg->timeout * HZ));\n\tif (block_io && stgt_priv)\n\t\tatomic_dec(&stgt_priv->block_io);\n\tif (!(mrioc->bsg_cmds.state & MPI3MR_CMD_COMPLETE)) {\n\t\tmrioc->bsg_cmds.is_waiting = 0;\n\t\trval = -EAGAIN;\n\t\tif (mrioc->bsg_cmds.state & MPI3MR_CMD_RESET)\n\t\t\tgoto out_unlock;\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"%s: bsg request timedout after %d seconds\\n\", __func__,\n\t\t    karg->timeout);\n\t\tif (mrioc->logging_level & MPI3_DEBUG_BSG_ERROR) {\n\t\t\tdprint_dump(mpi_req, MPI3MR_ADMIN_REQ_FRAME_SZ,\n\t\t\t    \"bsg_mpi3_req\");\n\t\t\tif (mpi_header->function ==\n\t\t\t    MPI3_BSG_FUNCTION_MGMT_PASSTHROUGH) {\n\t\t\t\tdrv_buf_iter = &drv_bufs[0];\n\t\t\t\tdprint_dump(drv_buf_iter->kern_buf,\n\t\t\t\t    drv_buf_iter->kern_buf_len, \"mpi3_mgmt_req\");\n\t\t\t}\n\t\t}\n\n\t\tif ((mpi_header->function == MPI3_BSG_FUNCTION_NVME_ENCAPSULATED) ||\n\t\t    (mpi_header->function == MPI3_BSG_FUNCTION_SCSI_IO))\n\t\t\tmpi3mr_issue_tm(mrioc,\n\t\t\t    MPI3_SCSITASKMGMT_TASKTYPE_TARGET_RESET,\n\t\t\t    mpi_header->function_dependent, 0,\n\t\t\t    MPI3MR_HOSTTAG_BLK_TMS, MPI3MR_RESETTM_TIMEOUT,\n\t\t\t    &mrioc->host_tm_cmds, &resp_code, NULL);\n\t\tif (!(mrioc->bsg_cmds.state & MPI3MR_CMD_COMPLETE) &&\n\t\t    !(mrioc->bsg_cmds.state & MPI3MR_CMD_RESET))\n\t\t\tmpi3mr_soft_reset_handler(mrioc,\n\t\t\t    MPI3MR_RESET_FROM_APP_TIMEOUT, 1);\n\t\tgoto out_unlock;\n\t}\n\tdprint_bsg_info(mrioc, \"%s: bsg request is completed\\n\", __func__);\n\n\tif (mrioc->prp_list_virt) {\n\t\tdma_free_coherent(&mrioc->pdev->dev, mrioc->prp_sz,\n\t\t    mrioc->prp_list_virt, mrioc->prp_list_dma);\n\t\tmrioc->prp_list_virt = NULL;\n\t}\n\n\tif ((mrioc->bsg_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK)\n\t     != MPI3_IOCSTATUS_SUCCESS) {\n\t\tdprint_bsg_info(mrioc,\n\t\t    \"%s: command failed, ioc_status(0x%04x) log_info(0x%08x)\\n\",\n\t\t    __func__,\n\t\t    (mrioc->bsg_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK),\n\t\t    mrioc->bsg_cmds.ioc_loginfo);\n\t}\n\n\tif ((mpirep_offset != 0xFF) &&\n\t    drv_bufs[mpirep_offset].bsg_buf_len) {\n\t\tdrv_buf_iter = &drv_bufs[mpirep_offset];\n\t\tdrv_buf_iter->kern_buf_len = (sizeof(*bsg_reply_buf) - 1 +\n\t\t\t\t\t   mrioc->reply_sz);\n\t\tbsg_reply_buf = kzalloc(drv_buf_iter->kern_buf_len, GFP_KERNEL);\n\n\t\tif (!bsg_reply_buf) {\n\t\t\trval = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (mrioc->bsg_cmds.state & MPI3MR_CMD_REPLY_VALID) {\n\t\t\tbsg_reply_buf->mpi_reply_type =\n\t\t\t\tMPI3MR_BSG_MPI_REPLY_BUFTYPE_ADDRESS;\n\t\t\tmemcpy(bsg_reply_buf->reply_buf,\n\t\t\t    mrioc->bsg_cmds.reply, mrioc->reply_sz);\n\t\t} else {\n\t\t\tbsg_reply_buf->mpi_reply_type =\n\t\t\t\tMPI3MR_BSG_MPI_REPLY_BUFTYPE_STATUS;\n\t\t\tstatus_desc = (struct mpi3_status_reply_descriptor *)\n\t\t\t    bsg_reply_buf->reply_buf;\n\t\t\tstatus_desc->ioc_status = mrioc->bsg_cmds.ioc_status;\n\t\t\tstatus_desc->ioc_log_info = mrioc->bsg_cmds.ioc_loginfo;\n\t\t}\n\t\ttmplen = min(drv_buf_iter->kern_buf_len,\n\t\t\tdrv_buf_iter->bsg_buf_len);\n\t\tmemcpy(drv_buf_iter->bsg_buf, bsg_reply_buf, tmplen);\n\t}\n\n\tif (erb_offset != 0xFF && mrioc->bsg_cmds.sensebuf &&\n\t    mrioc->bsg_cmds.is_sense) {\n\t\tdrv_buf_iter = &drv_bufs[erb_offset];\n\t\ttmplen = min(erbsz, drv_buf_iter->bsg_buf_len);\n\t\tmemcpy(drv_buf_iter->bsg_buf, sense_buff_k, tmplen);\n\t}\n\n\tdrv_buf_iter = drv_bufs;\n\tfor (count = 0; count < bufcnt; count++, drv_buf_iter++) {\n\t\tif (drv_buf_iter->data_dir == DMA_NONE)\n\t\t\tcontinue;\n\t\tif (drv_buf_iter->data_dir == DMA_FROM_DEVICE) {\n\t\t\ttmplen = min(drv_buf_iter->kern_buf_len,\n\t\t\t\t     drv_buf_iter->bsg_buf_len);\n\t\t\tmemcpy(drv_buf_iter->bsg_buf,\n\t\t\t       drv_buf_iter->kern_buf, tmplen);\n\t\t}\n\t}\n\nout_unlock:\n\tif (din_buf) {\n\t\t*reply_payload_rcv_len =\n\t\t\tsg_copy_from_buffer(job->reply_payload.sg_list,\n\t\t\t\t\t    job->reply_payload.sg_cnt,\n\t\t\t\t\t    din_buf, job->reply_payload.payload_len);\n\t}\n\tmrioc->bsg_cmds.is_sense = 0;\n\tmrioc->bsg_cmds.sensebuf = NULL;\n\tmrioc->bsg_cmds.state = MPI3MR_CMD_NOTUSED;\n\tmutex_unlock(&mrioc->bsg_cmds.mutex);\nout:\n\tkfree(sense_buff_k);\n\tkfree(dout_buf);\n\tkfree(din_buf);\n\tkfree(mpi_req);\n\tif (drv_bufs) {\n\t\tdrv_buf_iter = drv_bufs;\n\t\tfor (count = 0; count < bufcnt; count++, drv_buf_iter++) {\n\t\t\tif (drv_buf_iter->kern_buf && drv_buf_iter->kern_buf_dma)\n\t\t\t\tdma_free_coherent(&mrioc->pdev->dev,\n\t\t\t\t    drv_buf_iter->kern_buf_len,\n\t\t\t\t    drv_buf_iter->kern_buf,\n\t\t\t\t    drv_buf_iter->kern_buf_dma);\n\t\t}\n\t\tkfree(drv_bufs);\n\t}\n\tkfree(bsg_reply_buf);\n\treturn rval;\n}\n\n \nvoid mpi3mr_app_save_logdata(struct mpi3mr_ioc *mrioc, char *event_data,\n\tu16 event_data_size)\n{\n\tu32 index = mrioc->logdata_buf_idx, sz;\n\tstruct mpi3mr_logdata_entry *entry;\n\n\tif (!(mrioc->logdata_buf))\n\t\treturn;\n\n\tentry = (struct mpi3mr_logdata_entry *)\n\t\t(mrioc->logdata_buf + (index * mrioc->logdata_entry_sz));\n\tentry->valid_entry = 1;\n\tsz = min(mrioc->logdata_entry_sz, event_data_size);\n\tmemcpy(entry->data, event_data, sz);\n\tmrioc->logdata_buf_idx =\n\t\t((++index) % MPI3MR_BSG_LOGDATA_MAX_ENTRIES);\n\tatomic64_inc(&event_counter);\n}\n\n \nstatic int mpi3mr_bsg_request(struct bsg_job *job)\n{\n\tlong rval = -EINVAL;\n\tunsigned int reply_payload_rcv_len = 0;\n\n\tstruct mpi3mr_bsg_packet *bsg_req = job->request;\n\n\tswitch (bsg_req->cmd_type) {\n\tcase MPI3MR_DRV_CMD:\n\t\trval = mpi3mr_bsg_process_drv_cmds(job);\n\t\tbreak;\n\tcase MPI3MR_MPT_CMD:\n\t\trval = mpi3mr_bsg_process_mpt_cmds(job, &reply_payload_rcv_len);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unsupported BSG command(0x%08x)\\n\",\n\t\t    MPI3MR_DRIVER_NAME, bsg_req->cmd_type);\n\t\tbreak;\n\t}\n\n\tbsg_job_done(job, rval, reply_payload_rcv_len);\n\n\treturn 0;\n}\n\n \nvoid mpi3mr_bsg_exit(struct mpi3mr_ioc *mrioc)\n{\n\tstruct device *bsg_dev = &mrioc->bsg_dev;\n\tif (!mrioc->bsg_queue)\n\t\treturn;\n\n\tbsg_remove_queue(mrioc->bsg_queue);\n\tmrioc->bsg_queue = NULL;\n\n\tdevice_del(bsg_dev);\n\tput_device(bsg_dev);\n}\n\n \nstatic void mpi3mr_bsg_node_release(struct device *dev)\n{\n\tput_device(dev->parent);\n}\n\n \nvoid mpi3mr_bsg_init(struct mpi3mr_ioc *mrioc)\n{\n\tstruct device *bsg_dev = &mrioc->bsg_dev;\n\tstruct device *parent = &mrioc->shost->shost_gendev;\n\n\tdevice_initialize(bsg_dev);\n\n\tbsg_dev->parent = get_device(parent);\n\tbsg_dev->release = mpi3mr_bsg_node_release;\n\n\tdev_set_name(bsg_dev, \"mpi3mrctl%u\", mrioc->id);\n\n\tif (device_add(bsg_dev)) {\n\t\tioc_err(mrioc, \"%s: bsg device add failed\\n\",\n\t\t    dev_name(bsg_dev));\n\t\tput_device(bsg_dev);\n\t\treturn;\n\t}\n\n\tmrioc->bsg_queue = bsg_setup_queue(bsg_dev, dev_name(bsg_dev),\n\t\t\tmpi3mr_bsg_request, NULL, 0);\n\tif (IS_ERR(mrioc->bsg_queue)) {\n\t\tioc_err(mrioc, \"%s: bsg registration failed\\n\",\n\t\t    dev_name(bsg_dev));\n\t\tdevice_del(bsg_dev);\n\t\tput_device(bsg_dev);\n\t\treturn;\n\t}\n\n\tblk_queue_max_segments(mrioc->bsg_queue, MPI3MR_MAX_APP_XFER_SEGMENTS);\n\tblk_queue_max_hw_sectors(mrioc->bsg_queue, MPI3MR_MAX_APP_XFER_SECTORS);\n\n\treturn;\n}\n\n \nstatic ssize_t\nversion_fw_show(struct device *dev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct mpi3mr_ioc *mrioc = shost_priv(shost);\n\tstruct mpi3mr_compimg_ver *fwver = &mrioc->facts.fw_ver;\n\n\treturn sysfs_emit(buf, \"%d.%d.%d.%d.%05d-%05d\\n\",\n\t    fwver->gen_major, fwver->gen_minor, fwver->ph_major,\n\t    fwver->ph_minor, fwver->cust_id, fwver->build_num);\n}\nstatic DEVICE_ATTR_RO(version_fw);\n\n \nstatic ssize_t\nfw_queue_depth_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct mpi3mr_ioc *mrioc = shost_priv(shost);\n\n\treturn sysfs_emit(buf, \"%d\\n\", mrioc->facts.max_reqs);\n}\nstatic DEVICE_ATTR_RO(fw_queue_depth);\n\n \nstatic ssize_t\nop_req_q_count_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct mpi3mr_ioc *mrioc = shost_priv(shost);\n\n\treturn sysfs_emit(buf, \"%d\\n\", mrioc->num_op_req_q);\n}\nstatic DEVICE_ATTR_RO(op_req_q_count);\n\n \nstatic ssize_t\nreply_queue_count_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct mpi3mr_ioc *mrioc = shost_priv(shost);\n\n\treturn sysfs_emit(buf, \"%d\\n\", mrioc->num_op_reply_q);\n}\n\nstatic DEVICE_ATTR_RO(reply_queue_count);\n\n \nstatic ssize_t\nlogging_level_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct mpi3mr_ioc *mrioc = shost_priv(shost);\n\n\treturn sysfs_emit(buf, \"%08xh\\n\", mrioc->logging_level);\n}\n\n \nstatic ssize_t\nlogging_level_store(struct device *dev,\n\tstruct device_attribute *attr,\n\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct mpi3mr_ioc *mrioc = shost_priv(shost);\n\tint val = 0;\n\n\tif (kstrtoint(buf, 0, &val) != 0)\n\t\treturn -EINVAL;\n\n\tmrioc->logging_level = val;\n\tioc_info(mrioc, \"logging_level=%08xh\\n\", mrioc->logging_level);\n\treturn strlen(buf);\n}\nstatic DEVICE_ATTR_RW(logging_level);\n\n \nstatic ssize_t\nadp_state_show(struct device *dev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct mpi3mr_ioc *mrioc = shost_priv(shost);\n\tenum mpi3mr_iocstate ioc_state;\n\tuint8_t adp_state;\n\n\tioc_state = mpi3mr_get_iocstate(mrioc);\n\tif (ioc_state == MRIOC_STATE_UNRECOVERABLE)\n\t\tadp_state = MPI3MR_BSG_ADPSTATE_UNRECOVERABLE;\n\telse if ((mrioc->reset_in_progress) || (mrioc->stop_bsgs))\n\t\tadp_state = MPI3MR_BSG_ADPSTATE_IN_RESET;\n\telse if (ioc_state == MRIOC_STATE_FAULT)\n\t\tadp_state = MPI3MR_BSG_ADPSTATE_FAULT;\n\telse\n\t\tadp_state = MPI3MR_BSG_ADPSTATE_OPERATIONAL;\n\n\treturn sysfs_emit(buf, \"%u\\n\", adp_state);\n}\n\nstatic DEVICE_ATTR_RO(adp_state);\n\nstatic struct attribute *mpi3mr_host_attrs[] = {\n\t&dev_attr_version_fw.attr,\n\t&dev_attr_fw_queue_depth.attr,\n\t&dev_attr_op_req_q_count.attr,\n\t&dev_attr_reply_queue_count.attr,\n\t&dev_attr_logging_level.attr,\n\t&dev_attr_adp_state.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mpi3mr_host_attr_group = {\n\t.attrs = mpi3mr_host_attrs\n};\n\nconst struct attribute_group *mpi3mr_host_groups[] = {\n\t&mpi3mr_host_attr_group,\n\tNULL,\n};\n\n\n \n\n \nstatic ssize_t\nsas_address_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct mpi3mr_sdev_priv_data *sdev_priv_data;\n\tstruct mpi3mr_stgt_priv_data *tgt_priv_data;\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\n\tsdev_priv_data = sdev->hostdata;\n\tif (!sdev_priv_data)\n\t\treturn 0;\n\n\ttgt_priv_data = sdev_priv_data->tgt_priv_data;\n\tif (!tgt_priv_data)\n\t\treturn 0;\n\ttgtdev = tgt_priv_data->tgt_dev;\n\tif (!tgtdev || tgtdev->dev_type != MPI3_DEVICE_DEVFORM_SAS_SATA)\n\t\treturn 0;\n\treturn sysfs_emit(buf, \"0x%016llx\\n\",\n\t    (unsigned long long)tgtdev->dev_spec.sas_sata_inf.sas_address);\n}\n\nstatic DEVICE_ATTR_RO(sas_address);\n\n \nstatic ssize_t\ndevice_handle_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct mpi3mr_sdev_priv_data *sdev_priv_data;\n\tstruct mpi3mr_stgt_priv_data *tgt_priv_data;\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\n\tsdev_priv_data = sdev->hostdata;\n\tif (!sdev_priv_data)\n\t\treturn 0;\n\n\ttgt_priv_data = sdev_priv_data->tgt_priv_data;\n\tif (!tgt_priv_data)\n\t\treturn 0;\n\ttgtdev = tgt_priv_data->tgt_dev;\n\tif (!tgtdev)\n\t\treturn 0;\n\treturn sysfs_emit(buf, \"0x%04x\\n\", tgtdev->dev_handle);\n}\n\nstatic DEVICE_ATTR_RO(device_handle);\n\n \nstatic ssize_t\npersistent_id_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct mpi3mr_sdev_priv_data *sdev_priv_data;\n\tstruct mpi3mr_stgt_priv_data *tgt_priv_data;\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\n\tsdev_priv_data = sdev->hostdata;\n\tif (!sdev_priv_data)\n\t\treturn 0;\n\n\ttgt_priv_data = sdev_priv_data->tgt_priv_data;\n\tif (!tgt_priv_data)\n\t\treturn 0;\n\ttgtdev = tgt_priv_data->tgt_dev;\n\tif (!tgtdev)\n\t\treturn 0;\n\treturn sysfs_emit(buf, \"%d\\n\", tgtdev->perst_id);\n}\nstatic DEVICE_ATTR_RO(persistent_id);\n\nstatic struct attribute *mpi3mr_dev_attrs[] = {\n\t&dev_attr_sas_address.attr,\n\t&dev_attr_device_handle.attr,\n\t&dev_attr_persistent_id.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mpi3mr_dev_attr_group = {\n\t.attrs = mpi3mr_dev_attrs\n};\n\nconst struct attribute_group *mpi3mr_dev_groups[] = {\n\t&mpi3mr_dev_attr_group,\n\tNULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}