{
  "module_name": "mpi3mr_transport.c",
  "hash_id": "22c261e0b5b36f03b4dd5adb1a13206a69966908486500ac98afa8c497ff425d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mpi3mr/mpi3mr_transport.c",
  "human_readable_source": "\n \n\n#include \"mpi3mr.h\"\n\n \nstatic int mpi3mr_post_transport_req(struct mpi3mr_ioc *mrioc, void *request,\n\tu16 request_sz, void *reply, u16 reply_sz, int timeout,\n\tu16 *ioc_status)\n{\n\tint retval = 0;\n\n\tmutex_lock(&mrioc->transport_cmds.mutex);\n\tif (mrioc->transport_cmds.state & MPI3MR_CMD_PENDING) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"sending transport request failed due to command in use\\n\");\n\t\tmutex_unlock(&mrioc->transport_cmds.mutex);\n\t\tgoto out;\n\t}\n\tmrioc->transport_cmds.state = MPI3MR_CMD_PENDING;\n\tmrioc->transport_cmds.is_waiting = 1;\n\tmrioc->transport_cmds.callback = NULL;\n\tmrioc->transport_cmds.ioc_status = 0;\n\tmrioc->transport_cmds.ioc_loginfo = 0;\n\n\tinit_completion(&mrioc->transport_cmds.done);\n\tdprint_cfg_info(mrioc, \"posting transport request\\n\");\n\tif (mrioc->logging_level & MPI3_DEBUG_TRANSPORT_INFO)\n\t\tdprint_dump(request, request_sz, \"transport_req\");\n\tretval = mpi3mr_admin_request_post(mrioc, request, request_sz, 1);\n\tif (retval) {\n\t\tioc_err(mrioc, \"posting transport request failed\\n\");\n\t\tgoto out_unlock;\n\t}\n\twait_for_completion_timeout(&mrioc->transport_cmds.done,\n\t    (timeout * HZ));\n\tif (!(mrioc->transport_cmds.state & MPI3MR_CMD_COMPLETE)) {\n\t\tmpi3mr_check_rh_fault_ioc(mrioc,\n\t\t    MPI3MR_RESET_FROM_SAS_TRANSPORT_TIMEOUT);\n\t\tioc_err(mrioc, \"transport request timed out\\n\");\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\t*ioc_status = mrioc->transport_cmds.ioc_status &\n\t\tMPI3_IOCSTATUS_STATUS_MASK;\n\tif ((*ioc_status) != MPI3_IOCSTATUS_SUCCESS)\n\t\tdprint_transport_err(mrioc,\n\t\t    \"transport request returned with ioc_status(0x%04x), log_info(0x%08x)\\n\",\n\t\t    *ioc_status, mrioc->transport_cmds.ioc_loginfo);\n\n\tif ((reply) && (mrioc->transport_cmds.state & MPI3MR_CMD_REPLY_VALID))\n\t\tmemcpy((u8 *)reply, mrioc->transport_cmds.reply, reply_sz);\n\nout_unlock:\n\tmrioc->transport_cmds.state = MPI3MR_CMD_NOTUSED;\n\tmutex_unlock(&mrioc->transport_cmds.mutex);\n\nout:\n\treturn retval;\n}\n\n \nstruct rep_manu_request {\n\tu8 smp_frame_type;\n\tu8 function;\n\tu8 reserved;\n\tu8 request_length;\n};\n\n \nstruct rep_manu_reply {\n\tu8 smp_frame_type;  \n\tu8 function;  \n\tu8 function_result;\n\tu8 response_length;\n\tu16 expander_change_count;\n\tu8 reserved0[2];\n\tu8 sas_format;\n\tu8 reserved2[3];\n\tu8 vendor_id[SAS_EXPANDER_VENDOR_ID_LEN];\n\tu8 product_id[SAS_EXPANDER_PRODUCT_ID_LEN];\n\tu8 product_rev[SAS_EXPANDER_PRODUCT_REV_LEN];\n\tu8 component_vendor_id[SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN];\n\tu16 component_id;\n\tu8 component_revision_id;\n\tu8 reserved3;\n\tu8 vendor_specific[8];\n};\n\n \nstatic int mpi3mr_report_manufacture(struct mpi3mr_ioc *mrioc,\n\tu64 sas_address, struct sas_expander_device *edev, u8 port_id)\n{\n\tstruct mpi3_smp_passthrough_request mpi_request;\n\tstruct mpi3_smp_passthrough_reply mpi_reply;\n\tstruct rep_manu_reply *manufacture_reply;\n\tstruct rep_manu_request *manufacture_request;\n\tint rc = 0;\n\tvoid *psge;\n\tvoid *data_out = NULL;\n\tdma_addr_t data_out_dma;\n\tdma_addr_t data_in_dma;\n\tsize_t data_in_sz;\n\tsize_t data_out_sz;\n\tu8 sgl_flags = MPI3MR_SGEFLAGS_SYSTEM_SIMPLE_END_OF_LIST;\n\tu16 request_sz = sizeof(struct mpi3_smp_passthrough_request);\n\tu16 reply_sz = sizeof(struct mpi3_smp_passthrough_reply);\n\tu16 ioc_status;\n\tu8 *tmp;\n\n\tif (mrioc->reset_in_progress) {\n\t\tioc_err(mrioc, \"%s: host reset in progress!\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tdata_out_sz = sizeof(struct rep_manu_request);\n\tdata_in_sz = sizeof(struct rep_manu_reply);\n\tdata_out = dma_alloc_coherent(&mrioc->pdev->dev,\n\t    data_out_sz + data_in_sz, &data_out_dma, GFP_KERNEL);\n\tif (!data_out) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdata_in_dma = data_out_dma + data_out_sz;\n\tmanufacture_reply = data_out + data_out_sz;\n\n\tmanufacture_request = data_out;\n\tmanufacture_request->smp_frame_type = 0x40;\n\tmanufacture_request->function = 1;\n\tmanufacture_request->reserved = 0;\n\tmanufacture_request->request_length = 0;\n\n\tmemset(&mpi_request, 0, request_sz);\n\tmemset(&mpi_reply, 0, reply_sz);\n\tmpi_request.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_TRANSPORT_CMDS);\n\tmpi_request.function = MPI3_FUNCTION_SMP_PASSTHROUGH;\n\tmpi_request.io_unit_port = (u8) port_id;\n\tmpi_request.sas_address = cpu_to_le64(sas_address);\n\n\tpsge = &mpi_request.request_sge;\n\tmpi3mr_add_sg_single(psge, sgl_flags, data_out_sz, data_out_dma);\n\n\tpsge = &mpi_request.response_sge;\n\tmpi3mr_add_sg_single(psge, sgl_flags, data_in_sz, data_in_dma);\n\n\tdprint_transport_info(mrioc,\n\t    \"sending report manufacturer SMP request to sas_address(0x%016llx), port(%d)\\n\",\n\t    (unsigned long long)sas_address, port_id);\n\n\trc = mpi3mr_post_transport_req(mrioc, &mpi_request, request_sz,\n\t\t\t\t       &mpi_reply, reply_sz,\n\t\t\t\t       MPI3MR_INTADMCMD_TIMEOUT, &ioc_status);\n\tif (rc)\n\t\tgoto out;\n\n\tdprint_transport_info(mrioc,\n\t    \"report manufacturer SMP request completed with ioc_status(0x%04x)\\n\",\n\t    ioc_status);\n\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdprint_transport_info(mrioc,\n\t    \"report manufacturer - reply data transfer size(%d)\\n\",\n\t    le16_to_cpu(mpi_reply.response_data_length));\n\n\tif (le16_to_cpu(mpi_reply.response_data_length) !=\n\t    sizeof(struct rep_manu_reply)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tstrscpy(edev->vendor_id, manufacture_reply->vendor_id,\n\t     SAS_EXPANDER_VENDOR_ID_LEN);\n\tstrscpy(edev->product_id, manufacture_reply->product_id,\n\t     SAS_EXPANDER_PRODUCT_ID_LEN);\n\tstrscpy(edev->product_rev, manufacture_reply->product_rev,\n\t     SAS_EXPANDER_PRODUCT_REV_LEN);\n\tedev->level = manufacture_reply->sas_format & 1;\n\tif (edev->level) {\n\t\tstrscpy(edev->component_vendor_id,\n\t\t    manufacture_reply->component_vendor_id,\n\t\t     SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN);\n\t\ttmp = (u8 *)&manufacture_reply->component_id;\n\t\tedev->component_id = tmp[0] << 8 | tmp[1];\n\t\tedev->component_revision_id =\n\t\t    manufacture_reply->component_revision_id;\n\t}\n\nout:\n\tif (data_out)\n\t\tdma_free_coherent(&mrioc->pdev->dev, data_out_sz + data_in_sz,\n\t\t    data_out, data_out_dma);\n\n\treturn rc;\n}\n\n \nstruct mpi3mr_sas_node *__mpi3mr_expander_find_by_handle(struct mpi3mr_ioc\n\t*mrioc, u16 handle)\n{\n\tstruct mpi3mr_sas_node *sas_expander, *r;\n\n\tr = NULL;\n\tlist_for_each_entry(sas_expander, &mrioc->sas_expander_list, list) {\n\t\tif (sas_expander->handle != handle)\n\t\t\tcontinue;\n\t\tr = sas_expander;\n\t\tgoto out;\n\t}\n out:\n\treturn r;\n}\n\n \nu8 mpi3mr_is_expander_device(u16 device_info)\n{\n\tif ((device_info & MPI3_SAS_DEVICE_INFO_DEVICE_TYPE_MASK) ==\n\t     MPI3_SAS_DEVICE_INFO_DEVICE_TYPE_EXPANDER)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic int mpi3mr_get_sas_address(struct mpi3mr_ioc *mrioc, u16 handle,\n\tu64 *sas_address)\n{\n\tstruct mpi3_device_page0 dev_pg0;\n\tu16 ioc_status;\n\tstruct mpi3_device0_sas_sata_format *sasinf;\n\n\t*sas_address = 0;\n\n\tif ((mpi3mr_cfg_get_dev_pg0(mrioc, &ioc_status, &dev_pg0,\n\t    sizeof(dev_pg0), MPI3_DEVICE_PGAD_FORM_HANDLE,\n\t    handle))) {\n\t\tioc_err(mrioc, \"%s: device page0 read failed\\n\", __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"device page read failed for handle(0x%04x), with ioc_status(0x%04x) failure at %s:%d/%s()!\\n\",\n\t\t    handle, ioc_status, __FILE__, __LINE__, __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tif (le16_to_cpu(dev_pg0.flags) &\n\t    MPI3_DEVICE0_FLAGS_CONTROLLER_DEV_HANDLE)\n\t\t*sas_address = mrioc->sas_hba.sas_address;\n\telse if (dev_pg0.device_form == MPI3_DEVICE_DEVFORM_SAS_SATA) {\n\t\tsasinf = &dev_pg0.device_specific.sas_sata_format;\n\t\t*sas_address = le64_to_cpu(sasinf->sas_address);\n\t} else {\n\t\tioc_err(mrioc, \"%s: device_form(%d) is not SAS_SATA\\n\",\n\t\t    __func__, dev_pg0.device_form);\n\t\treturn -ENXIO;\n\t}\n\treturn 0;\n}\n\n \nstatic struct mpi3mr_tgt_dev *__mpi3mr_get_tgtdev_by_addr(struct mpi3mr_ioc *mrioc,\n\tu64 sas_address, struct mpi3mr_hba_port *hba_port)\n{\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\n\tassert_spin_locked(&mrioc->tgtdev_lock);\n\n\tlist_for_each_entry(tgtdev, &mrioc->tgtdev_list, list)\n\t\tif ((tgtdev->dev_type == MPI3_DEVICE_DEVFORM_SAS_SATA) &&\n\t\t    (tgtdev->dev_spec.sas_sata_inf.sas_address == sas_address)\n\t\t    && (tgtdev->dev_spec.sas_sata_inf.hba_port == hba_port))\n\t\t\tgoto found_device;\n\treturn NULL;\nfound_device:\n\tmpi3mr_tgtdev_get(tgtdev);\n\treturn tgtdev;\n}\n\n \nstatic struct mpi3mr_tgt_dev *mpi3mr_get_tgtdev_by_addr(struct mpi3mr_ioc *mrioc,\n\tu64 sas_address, struct mpi3mr_hba_port *hba_port)\n{\n\tstruct mpi3mr_tgt_dev *tgtdev = NULL;\n\tunsigned long flags;\n\n\tif (!hba_port)\n\t\tgoto out;\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\ttgtdev = __mpi3mr_get_tgtdev_by_addr(mrioc, sas_address, hba_port);\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\nout:\n\treturn tgtdev;\n}\n\n \nstatic void mpi3mr_remove_device_by_sas_address(struct mpi3mr_ioc *mrioc,\n\tu64 sas_address, struct mpi3mr_hba_port *hba_port)\n{\n\tstruct mpi3mr_tgt_dev *tgtdev = NULL;\n\tunsigned long flags;\n\tu8 was_on_tgtdev_list = 0;\n\n\tif (!hba_port)\n\t\treturn;\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\ttgtdev = __mpi3mr_get_tgtdev_by_addr(mrioc,\n\t\t\t sas_address, hba_port);\n\tif (tgtdev) {\n\t\tif (!list_empty(&tgtdev->list)) {\n\t\t\tlist_del_init(&tgtdev->list);\n\t\t\twas_on_tgtdev_list = 1;\n\t\t\tmpi3mr_tgtdev_put(tgtdev);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\tif (was_on_tgtdev_list) {\n\t\tif (tgtdev->host_exposed)\n\t\t\tmpi3mr_remove_tgtdev_from_host(mrioc, tgtdev);\n\t\tmpi3mr_tgtdev_put(tgtdev);\n\t}\n}\n\n \nstruct mpi3mr_tgt_dev *__mpi3mr_get_tgtdev_by_addr_and_rphy(\n\tstruct mpi3mr_ioc *mrioc, u64 sas_address, struct sas_rphy *rphy)\n{\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\n\tassert_spin_locked(&mrioc->tgtdev_lock);\n\n\tlist_for_each_entry(tgtdev, &mrioc->tgtdev_list, list)\n\t\tif ((tgtdev->dev_type == MPI3_DEVICE_DEVFORM_SAS_SATA) &&\n\t\t    (tgtdev->dev_spec.sas_sata_inf.sas_address == sas_address)\n\t\t    && (tgtdev->dev_spec.sas_sata_inf.rphy == rphy))\n\t\t\tgoto found_device;\n\treturn NULL;\nfound_device:\n\tmpi3mr_tgtdev_get(tgtdev);\n\treturn tgtdev;\n}\n\n \nstatic struct mpi3mr_sas_node *mpi3mr_expander_find_by_sas_address(\n\tstruct mpi3mr_ioc *mrioc, u64 sas_address,\n\tstruct mpi3mr_hba_port *hba_port)\n{\n\tstruct mpi3mr_sas_node *sas_expander, *r = NULL;\n\n\tif (!hba_port)\n\t\tgoto out;\n\n\tlist_for_each_entry(sas_expander, &mrioc->sas_expander_list, list) {\n\t\tif ((sas_expander->sas_address != sas_address) ||\n\t\t\t\t\t (sas_expander->hba_port != hba_port))\n\t\t\tcontinue;\n\t\tr = sas_expander;\n\t\tgoto out;\n\t}\nout:\n\treturn r;\n}\n\n \nstatic struct mpi3mr_sas_node *__mpi3mr_sas_node_find_by_sas_address(\n\tstruct mpi3mr_ioc *mrioc, u64 sas_address,\n\tstruct mpi3mr_hba_port *hba_port)\n{\n\n\tif (mrioc->sas_hba.sas_address == sas_address)\n\t\treturn &mrioc->sas_hba;\n\treturn mpi3mr_expander_find_by_sas_address(mrioc, sas_address,\n\t    hba_port);\n}\n\n \nstatic int mpi3mr_parent_present(struct mpi3mr_ioc *mrioc, struct sas_phy *phy)\n{\n\tunsigned long flags;\n\tstruct mpi3mr_hba_port *hba_port = phy->hostdata;\n\n\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\tif (__mpi3mr_sas_node_find_by_sas_address(mrioc,\n\t    phy->identify.sas_address,\n\t    hba_port) == NULL) {\n\t\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\t\treturn -1;\n\t}\n\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\treturn 0;\n}\n\n \nstatic enum sas_linkrate mpi3mr_convert_phy_link_rate(u8 link_rate)\n{\n\tenum sas_linkrate rc;\n\n\tswitch (link_rate) {\n\tcase MPI3_SAS_NEG_LINK_RATE_1_5:\n\t\trc = SAS_LINK_RATE_1_5_GBPS;\n\t\tbreak;\n\tcase MPI3_SAS_NEG_LINK_RATE_3_0:\n\t\trc = SAS_LINK_RATE_3_0_GBPS;\n\t\tbreak;\n\tcase MPI3_SAS_NEG_LINK_RATE_6_0:\n\t\trc = SAS_LINK_RATE_6_0_GBPS;\n\t\tbreak;\n\tcase MPI3_SAS_NEG_LINK_RATE_12_0:\n\t\trc = SAS_LINK_RATE_12_0_GBPS;\n\t\tbreak;\n\tcase MPI3_SAS_NEG_LINK_RATE_22_5:\n\t\trc = SAS_LINK_RATE_22_5_GBPS;\n\t\tbreak;\n\tcase MPI3_SAS_NEG_LINK_RATE_PHY_DISABLED:\n\t\trc = SAS_PHY_DISABLED;\n\t\tbreak;\n\tcase MPI3_SAS_NEG_LINK_RATE_NEGOTIATION_FAILED:\n\t\trc = SAS_LINK_RATE_FAILED;\n\t\tbreak;\n\tcase MPI3_SAS_NEG_LINK_RATE_PORT_SELECTOR:\n\t\trc = SAS_SATA_PORT_SELECTOR;\n\t\tbreak;\n\tcase MPI3_SAS_NEG_LINK_RATE_SMP_RESET_IN_PROGRESS:\n\t\trc = SAS_PHY_RESET_IN_PROGRESS;\n\t\tbreak;\n\tcase MPI3_SAS_NEG_LINK_RATE_SATA_OOB_COMPLETE:\n\tcase MPI3_SAS_NEG_LINK_RATE_UNKNOWN_LINK_RATE:\n\tdefault:\n\t\trc = SAS_LINK_RATE_UNKNOWN;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\n \nstatic void mpi3mr_delete_sas_phy(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_sas_port *mr_sas_port,\n\tstruct mpi3mr_sas_phy *mr_sas_phy)\n{\n\tu64 sas_address = mr_sas_port->remote_identify.sas_address;\n\n\tdev_info(&mr_sas_phy->phy->dev,\n\t    \"remove: sas_address(0x%016llx), phy(%d)\\n\",\n\t    (unsigned long long) sas_address, mr_sas_phy->phy_id);\n\n\tlist_del(&mr_sas_phy->port_siblings);\n\tmr_sas_port->num_phys--;\n\tmr_sas_port->phy_mask &= ~(1 << mr_sas_phy->phy_id);\n\tif (mr_sas_port->lowest_phy == mr_sas_phy->phy_id)\n\t\tmr_sas_port->lowest_phy = ffs(mr_sas_port->phy_mask) - 1;\n\tsas_port_delete_phy(mr_sas_port->port, mr_sas_phy->phy);\n\tmr_sas_phy->phy_belongs_to_port = 0;\n}\n\n \nstatic void mpi3mr_add_sas_phy(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_sas_port *mr_sas_port,\n\tstruct mpi3mr_sas_phy *mr_sas_phy)\n{\n\tu64 sas_address = mr_sas_port->remote_identify.sas_address;\n\n\tdev_info(&mr_sas_phy->phy->dev,\n\t    \"add: sas_address(0x%016llx), phy(%d)\\n\", (unsigned long long)\n\t    sas_address, mr_sas_phy->phy_id);\n\n\tlist_add_tail(&mr_sas_phy->port_siblings, &mr_sas_port->phy_list);\n\tmr_sas_port->num_phys++;\n\tmr_sas_port->phy_mask |= (1 << mr_sas_phy->phy_id);\n\tif (mr_sas_phy->phy_id < mr_sas_port->lowest_phy)\n\t\tmr_sas_port->lowest_phy = ffs(mr_sas_port->phy_mask) - 1;\n\tsas_port_add_phy(mr_sas_port->port, mr_sas_phy->phy);\n\tmr_sas_phy->phy_belongs_to_port = 1;\n}\n\n \nstatic void mpi3mr_add_phy_to_an_existing_port(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_sas_node *mr_sas_node, struct mpi3mr_sas_phy *mr_sas_phy,\n\tu64 sas_address, struct mpi3mr_hba_port *hba_port)\n{\n\tstruct mpi3mr_sas_port *mr_sas_port;\n\tstruct mpi3mr_sas_phy *srch_phy;\n\n\tif (mr_sas_phy->phy_belongs_to_port == 1)\n\t\treturn;\n\n\tif (!hba_port)\n\t\treturn;\n\n\tlist_for_each_entry(mr_sas_port, &mr_sas_node->sas_port_list,\n\t    port_list) {\n\t\tif (mr_sas_port->remote_identify.sas_address !=\n\t\t    sas_address)\n\t\t\tcontinue;\n\t\tif (mr_sas_port->hba_port != hba_port)\n\t\t\tcontinue;\n\t\tlist_for_each_entry(srch_phy, &mr_sas_port->phy_list,\n\t\t    port_siblings) {\n\t\t\tif (srch_phy == mr_sas_phy)\n\t\t\t\treturn;\n\t\t}\n\t\tmpi3mr_add_sas_phy(mrioc, mr_sas_port, mr_sas_phy);\n\t\treturn;\n\t}\n}\n\n \nstatic void  mpi3mr_delete_sas_port(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_sas_port *mr_sas_port)\n{\n\tu64 sas_address = mr_sas_port->remote_identify.sas_address;\n\tstruct mpi3mr_hba_port *hba_port = mr_sas_port->hba_port;\n\tenum sas_device_type device_type =\n\t    mr_sas_port->remote_identify.device_type;\n\n\tdev_info(&mr_sas_port->port->dev,\n\t    \"remove: sas_address(0x%016llx)\\n\",\n\t    (unsigned long long) sas_address);\n\n\tif (device_type == SAS_END_DEVICE)\n\t\tmpi3mr_remove_device_by_sas_address(mrioc, sas_address,\n\t\t    hba_port);\n\n\telse if (device_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t    device_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\tmpi3mr_expander_remove(mrioc, sas_address, hba_port);\n}\n\n \nstatic void mpi3mr_del_phy_from_an_existing_port(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_sas_node *mr_sas_node, struct mpi3mr_sas_phy *mr_sas_phy)\n{\n\tstruct mpi3mr_sas_port *mr_sas_port, *next;\n\tstruct mpi3mr_sas_phy *srch_phy;\n\n\tif (mr_sas_phy->phy_belongs_to_port == 0)\n\t\treturn;\n\n\tlist_for_each_entry_safe(mr_sas_port, next, &mr_sas_node->sas_port_list,\n\t    port_list) {\n\t\tlist_for_each_entry(srch_phy, &mr_sas_port->phy_list,\n\t\t    port_siblings) {\n\t\t\tif (srch_phy != mr_sas_phy)\n\t\t\t\tcontinue;\n\t\t\tif ((mr_sas_port->num_phys == 1) &&\n\t\t\t    !mrioc->reset_in_progress)\n\t\t\t\tmpi3mr_delete_sas_port(mrioc, mr_sas_port);\n\t\t\telse\n\t\t\t\tmpi3mr_delete_sas_phy(mrioc, mr_sas_port,\n\t\t\t\t    mr_sas_phy);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nstatic void mpi3mr_sas_port_sanity_check(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_sas_node *mr_sas_node, u64 sas_address,\n\tstruct mpi3mr_hba_port *hba_port)\n{\n\tint i;\n\n\tfor (i = 0; i < mr_sas_node->num_phys; i++) {\n\t\tif ((mr_sas_node->phy[i].remote_identify.sas_address !=\n\t\t    sas_address) || (mr_sas_node->phy[i].hba_port != hba_port))\n\t\t\tcontinue;\n\t\tif (mr_sas_node->phy[i].phy_belongs_to_port == 1)\n\t\t\tmpi3mr_del_phy_from_an_existing_port(mrioc,\n\t\t\t    mr_sas_node, &mr_sas_node->phy[i]);\n\t}\n}\n\n \nstatic int mpi3mr_set_identify(struct mpi3mr_ioc *mrioc, u16 handle,\n\tstruct sas_identify *identify)\n{\n\n\tstruct mpi3_device_page0 device_pg0;\n\tstruct mpi3_device0_sas_sata_format *sasinf;\n\tu16 device_info;\n\tu16 ioc_status;\n\n\tif (mrioc->reset_in_progress) {\n\t\tioc_err(mrioc, \"%s: host reset in progress!\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tif ((mpi3mr_cfg_get_dev_pg0(mrioc, &ioc_status, &device_pg0,\n\t    sizeof(device_pg0), MPI3_DEVICE_PGAD_FORM_HANDLE, handle))) {\n\t\tioc_err(mrioc, \"%s: device page0 read failed\\n\", __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"device page read failed for handle(0x%04x), with ioc_status(0x%04x) failure at %s:%d/%s()!\\n\",\n\t\t    handle, ioc_status, __FILE__, __LINE__, __func__);\n\t\treturn -EIO;\n\t}\n\n\tmemset(identify, 0, sizeof(struct sas_identify));\n\tsasinf = &device_pg0.device_specific.sas_sata_format;\n\tdevice_info = le16_to_cpu(sasinf->device_info);\n\n\t \n\tidentify->sas_address = le64_to_cpu(sasinf->sas_address);\n\n\t \n\tidentify->phy_identifier = sasinf->phy_num;\n\n\t \n\tswitch (device_info & MPI3_SAS_DEVICE_INFO_DEVICE_TYPE_MASK) {\n\tcase MPI3_SAS_DEVICE_INFO_DEVICE_TYPE_NO_DEVICE:\n\t\tidentify->device_type = SAS_PHY_UNUSED;\n\t\tbreak;\n\tcase MPI3_SAS_DEVICE_INFO_DEVICE_TYPE_END_DEVICE:\n\t\tidentify->device_type = SAS_END_DEVICE;\n\t\tbreak;\n\tcase MPI3_SAS_DEVICE_INFO_DEVICE_TYPE_EXPANDER:\n\t\tidentify->device_type = SAS_EDGE_EXPANDER_DEVICE;\n\t\tbreak;\n\t}\n\n\t \n\tif (device_info & MPI3_SAS_DEVICE_INFO_SSP_INITIATOR)\n\t\tidentify->initiator_port_protocols |= SAS_PROTOCOL_SSP;\n\t \n\tif (device_info & MPI3_SAS_DEVICE_INFO_STP_INITIATOR)\n\t\tidentify->initiator_port_protocols |= (SAS_PROTOCOL_STP |\n\t\t    SAS_PROTOCOL_SATA);\n\tif (device_info & MPI3_SAS_DEVICE_INFO_SMP_INITIATOR)\n\t\tidentify->initiator_port_protocols |= SAS_PROTOCOL_SMP;\n\n\t \n\tif (device_info & MPI3_SAS_DEVICE_INFO_SSP_TARGET)\n\t\tidentify->target_port_protocols |= SAS_PROTOCOL_SSP;\n\t \n\tif (device_info & MPI3_SAS_DEVICE_INFO_STP_SATA_TARGET)\n\t\tidentify->target_port_protocols |= (SAS_PROTOCOL_STP |\n\t\t    SAS_PROTOCOL_SATA);\n\tif (device_info & MPI3_SAS_DEVICE_INFO_SMP_TARGET)\n\t\tidentify->target_port_protocols |= SAS_PROTOCOL_SMP;\n\treturn 0;\n}\n\n \nstatic int mpi3mr_add_host_phy(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_sas_phy *mr_sas_phy, struct mpi3_sas_phy_page0 phy_pg0,\n\tstruct device *parent_dev)\n{\n\tstruct sas_phy *phy;\n\tint phy_index = mr_sas_phy->phy_id;\n\n\n\tINIT_LIST_HEAD(&mr_sas_phy->port_siblings);\n\tphy = sas_phy_alloc(parent_dev, phy_index);\n\tif (!phy) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\tif ((mpi3mr_set_identify(mrioc, mr_sas_phy->handle,\n\t    &mr_sas_phy->identify))) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tsas_phy_free(phy);\n\t\treturn -1;\n\t}\n\tphy->identify = mr_sas_phy->identify;\n\tmr_sas_phy->attached_handle = le16_to_cpu(phy_pg0.attached_dev_handle);\n\tif (mr_sas_phy->attached_handle)\n\t\tmpi3mr_set_identify(mrioc, mr_sas_phy->attached_handle,\n\t\t    &mr_sas_phy->remote_identify);\n\tphy->identify.phy_identifier = mr_sas_phy->phy_id;\n\tphy->negotiated_linkrate = mpi3mr_convert_phy_link_rate(\n\t    (phy_pg0.negotiated_link_rate &\n\t    MPI3_SAS_NEG_LINK_RATE_LOGICAL_MASK) >>\n\t    MPI3_SAS_NEG_LINK_RATE_LOGICAL_SHIFT);\n\tphy->minimum_linkrate_hw = mpi3mr_convert_phy_link_rate(\n\t    phy_pg0.hw_link_rate & MPI3_SAS_HWRATE_MIN_RATE_MASK);\n\tphy->maximum_linkrate_hw = mpi3mr_convert_phy_link_rate(\n\t    phy_pg0.hw_link_rate >> 4);\n\tphy->minimum_linkrate = mpi3mr_convert_phy_link_rate(\n\t    phy_pg0.programmed_link_rate & MPI3_SAS_PRATE_MIN_RATE_MASK);\n\tphy->maximum_linkrate = mpi3mr_convert_phy_link_rate(\n\t    phy_pg0.programmed_link_rate >> 4);\n\tphy->hostdata = mr_sas_phy->hba_port;\n\n\tif ((sas_phy_add(phy))) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tsas_phy_free(phy);\n\t\treturn -1;\n\t}\n\tif ((mrioc->logging_level & MPI3_DEBUG_TRANSPORT_INFO))\n\t\tdev_info(&phy->dev,\n\t\t    \"add: handle(0x%04x), sas_address(0x%016llx)\\n\"\n\t\t    \"\\tattached_handle(0x%04x), sas_address(0x%016llx)\\n\",\n\t\t    mr_sas_phy->handle, (unsigned long long)\n\t\t    mr_sas_phy->identify.sas_address,\n\t\t    mr_sas_phy->attached_handle,\n\t\t    (unsigned long long)\n\t\t    mr_sas_phy->remote_identify.sas_address);\n\tmr_sas_phy->phy = phy;\n\treturn 0;\n}\n\n \nstatic int mpi3mr_add_expander_phy(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_sas_phy *mr_sas_phy,\n\tstruct mpi3_sas_expander_page1 expander_pg1,\n\tstruct device *parent_dev)\n{\n\tstruct sas_phy *phy;\n\tint phy_index = mr_sas_phy->phy_id;\n\n\tINIT_LIST_HEAD(&mr_sas_phy->port_siblings);\n\tphy = sas_phy_alloc(parent_dev, phy_index);\n\tif (!phy) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\tif ((mpi3mr_set_identify(mrioc, mr_sas_phy->handle,\n\t    &mr_sas_phy->identify))) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tsas_phy_free(phy);\n\t\treturn -1;\n\t}\n\tphy->identify = mr_sas_phy->identify;\n\tmr_sas_phy->attached_handle =\n\t    le16_to_cpu(expander_pg1.attached_dev_handle);\n\tif (mr_sas_phy->attached_handle)\n\t\tmpi3mr_set_identify(mrioc, mr_sas_phy->attached_handle,\n\t\t    &mr_sas_phy->remote_identify);\n\tphy->identify.phy_identifier = mr_sas_phy->phy_id;\n\tphy->negotiated_linkrate = mpi3mr_convert_phy_link_rate(\n\t    (expander_pg1.negotiated_link_rate &\n\t    MPI3_SAS_NEG_LINK_RATE_LOGICAL_MASK) >>\n\t    MPI3_SAS_NEG_LINK_RATE_LOGICAL_SHIFT);\n\tphy->minimum_linkrate_hw = mpi3mr_convert_phy_link_rate(\n\t    expander_pg1.hw_link_rate & MPI3_SAS_HWRATE_MIN_RATE_MASK);\n\tphy->maximum_linkrate_hw = mpi3mr_convert_phy_link_rate(\n\t    expander_pg1.hw_link_rate >> 4);\n\tphy->minimum_linkrate = mpi3mr_convert_phy_link_rate(\n\t    expander_pg1.programmed_link_rate & MPI3_SAS_PRATE_MIN_RATE_MASK);\n\tphy->maximum_linkrate = mpi3mr_convert_phy_link_rate(\n\t    expander_pg1.programmed_link_rate >> 4);\n\tphy->hostdata = mr_sas_phy->hba_port;\n\n\tif ((sas_phy_add(phy))) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tsas_phy_free(phy);\n\t\treturn -1;\n\t}\n\tif ((mrioc->logging_level & MPI3_DEBUG_TRANSPORT_INFO))\n\t\tdev_info(&phy->dev,\n\t\t    \"add: handle(0x%04x), sas_address(0x%016llx)\\n\"\n\t\t    \"\\tattached_handle(0x%04x), sas_address(0x%016llx)\\n\",\n\t\t    mr_sas_phy->handle, (unsigned long long)\n\t\t    mr_sas_phy->identify.sas_address,\n\t\t    mr_sas_phy->attached_handle,\n\t\t    (unsigned long long)\n\t\t    mr_sas_phy->remote_identify.sas_address);\n\tmr_sas_phy->phy = phy;\n\treturn 0;\n}\n\n \nstatic struct mpi3mr_hba_port *\nmpi3mr_alloc_hba_port(struct mpi3mr_ioc *mrioc, u16 port_id)\n{\n\tstruct mpi3mr_hba_port *hba_port;\n\n\thba_port = kzalloc(sizeof(struct mpi3mr_hba_port),\n\t    GFP_KERNEL);\n\tif (!hba_port)\n\t\treturn NULL;\n\thba_port->port_id = port_id;\n\tioc_info(mrioc, \"hba_port entry: %p, port: %d is added to hba_port list\\n\",\n\t    hba_port, hba_port->port_id);\n\tlist_add_tail(&hba_port->list, &mrioc->hba_port_table_list);\n\treturn hba_port;\n}\n\n \n\nstruct mpi3mr_hba_port *mpi3mr_get_hba_port_by_id(struct mpi3mr_ioc *mrioc,\n\tu8 port_id)\n{\n\tstruct mpi3mr_hba_port *port, *port_next;\n\n\tlist_for_each_entry_safe(port, port_next,\n\t    &mrioc->hba_port_table_list, list) {\n\t\tif (port->port_id != port_id)\n\t\t\tcontinue;\n\t\tif (port->flags & MPI3MR_HBA_PORT_FLAG_DIRTY)\n\t\t\tcontinue;\n\t\treturn port;\n\t}\n\n\treturn NULL;\n}\n\n \nvoid mpi3mr_update_links(struct mpi3mr_ioc *mrioc,\n\tu64 sas_address_parent, u16 handle, u8 phy_number, u8 link_rate,\n\tstruct mpi3mr_hba_port *hba_port)\n{\n\tunsigned long flags;\n\tstruct mpi3mr_sas_node *mr_sas_node;\n\tstruct mpi3mr_sas_phy *mr_sas_phy;\n\n\tif (mrioc->reset_in_progress)\n\t\treturn;\n\n\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\tmr_sas_node = __mpi3mr_sas_node_find_by_sas_address(mrioc,\n\t    sas_address_parent, hba_port);\n\tif (!mr_sas_node) {\n\t\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\t\treturn;\n\t}\n\n\tmr_sas_phy = &mr_sas_node->phy[phy_number];\n\tmr_sas_phy->attached_handle = handle;\n\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\tif (handle && (link_rate >= MPI3_SAS_NEG_LINK_RATE_1_5)) {\n\t\tmpi3mr_set_identify(mrioc, handle,\n\t\t    &mr_sas_phy->remote_identify);\n\t\tmpi3mr_add_phy_to_an_existing_port(mrioc, mr_sas_node,\n\t\t    mr_sas_phy, mr_sas_phy->remote_identify.sas_address,\n\t\t    hba_port);\n\t} else\n\t\tmemset(&mr_sas_phy->remote_identify, 0, sizeof(struct\n\t\t    sas_identify));\n\n\tif (mr_sas_phy->phy)\n\t\tmr_sas_phy->phy->negotiated_linkrate =\n\t\t    mpi3mr_convert_phy_link_rate(link_rate);\n\n\tif ((mrioc->logging_level & MPI3_DEBUG_TRANSPORT_INFO))\n\t\tdev_info(&mr_sas_phy->phy->dev,\n\t\t    \"refresh: parent sas_address(0x%016llx),\\n\"\n\t\t    \"\\tlink_rate(0x%02x), phy(%d)\\n\"\n\t\t    \"\\tattached_handle(0x%04x), sas_address(0x%016llx)\\n\",\n\t\t    (unsigned long long)sas_address_parent,\n\t\t    link_rate, phy_number, handle, (unsigned long long)\n\t\t    mr_sas_phy->remote_identify.sas_address);\n}\n\n \nvoid mpi3mr_sas_host_refresh(struct mpi3mr_ioc *mrioc)\n{\n\tint i;\n\tu8 link_rate;\n\tu16 sz, port_id, attached_handle;\n\tstruct mpi3_sas_io_unit_page0 *sas_io_unit_pg0 = NULL;\n\n\tdprint_transport_info(mrioc,\n\t    \"updating handles for sas_host(0x%016llx)\\n\",\n\t    (unsigned long long)mrioc->sas_hba.sas_address);\n\n\tsz = offsetof(struct mpi3_sas_io_unit_page0, phy_data) +\n\t    (mrioc->sas_hba.num_phys *\n\t     sizeof(struct mpi3_sas_io_unit0_phy_data));\n\tsas_io_unit_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_io_unit_pg0)\n\t\treturn;\n\tif (mpi3mr_cfg_get_sas_io_unit_pg0(mrioc, sas_io_unit_pg0, sz)) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\tmrioc->sas_hba.handle = 0;\n\tfor (i = 0; i < mrioc->sas_hba.num_phys; i++) {\n\t\tif (sas_io_unit_pg0->phy_data[i].phy_flags &\n\t\t    (MPI3_SASIOUNIT0_PHYFLAGS_HOST_PHY |\n\t\t     MPI3_SASIOUNIT0_PHYFLAGS_VIRTUAL_PHY))\n\t\t\tcontinue;\n\t\tlink_rate =\n\t\t    sas_io_unit_pg0->phy_data[i].negotiated_link_rate >> 4;\n\t\tif (!mrioc->sas_hba.handle)\n\t\t\tmrioc->sas_hba.handle = le16_to_cpu(\n\t\t\t    sas_io_unit_pg0->phy_data[i].controller_dev_handle);\n\t\tport_id = sas_io_unit_pg0->phy_data[i].io_unit_port;\n\t\tif (!(mpi3mr_get_hba_port_by_id(mrioc, port_id)))\n\t\t\tif (!mpi3mr_alloc_hba_port(mrioc, port_id))\n\t\t\t\tgoto out;\n\n\t\tmrioc->sas_hba.phy[i].handle = mrioc->sas_hba.handle;\n\t\tattached_handle = le16_to_cpu(\n\t\t    sas_io_unit_pg0->phy_data[i].attached_dev_handle);\n\t\tif (attached_handle && link_rate < MPI3_SAS_NEG_LINK_RATE_1_5)\n\t\t\tlink_rate = MPI3_SAS_NEG_LINK_RATE_1_5;\n\t\tmrioc->sas_hba.phy[i].hba_port =\n\t\t\tmpi3mr_get_hba_port_by_id(mrioc, port_id);\n\t\tmpi3mr_update_links(mrioc, mrioc->sas_hba.sas_address,\n\t\t    attached_handle, i, link_rate,\n\t\t    mrioc->sas_hba.phy[i].hba_port);\n\t}\n out:\n\tkfree(sas_io_unit_pg0);\n}\n\n \nvoid mpi3mr_sas_host_add(struct mpi3mr_ioc *mrioc)\n{\n\tint i;\n\tu16 sz, num_phys = 1, port_id, ioc_status;\n\tstruct mpi3_sas_io_unit_page0 *sas_io_unit_pg0 = NULL;\n\tstruct mpi3_sas_phy_page0 phy_pg0;\n\tstruct mpi3_device_page0 dev_pg0;\n\tstruct mpi3_enclosure_page0 encl_pg0;\n\tstruct mpi3_device0_sas_sata_format *sasinf;\n\n\tsz = offsetof(struct mpi3_sas_io_unit_page0, phy_data) +\n\t    (num_phys * sizeof(struct mpi3_sas_io_unit0_phy_data));\n\tsas_io_unit_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_io_unit_pg0)\n\t\treturn;\n\n\tif (mpi3mr_cfg_get_sas_io_unit_pg0(mrioc, sas_io_unit_pg0, sz)) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tnum_phys = sas_io_unit_pg0->num_phys;\n\tkfree(sas_io_unit_pg0);\n\n\tmrioc->sas_hba.host_node = 1;\n\tINIT_LIST_HEAD(&mrioc->sas_hba.sas_port_list);\n\tmrioc->sas_hba.parent_dev = &mrioc->shost->shost_gendev;\n\tmrioc->sas_hba.phy = kcalloc(num_phys,\n\t    sizeof(struct mpi3mr_sas_phy), GFP_KERNEL);\n\tif (!mrioc->sas_hba.phy)\n\t\treturn;\n\n\tmrioc->sas_hba.num_phys = num_phys;\n\n\tsz = offsetof(struct mpi3_sas_io_unit_page0, phy_data) +\n\t    (num_phys * sizeof(struct mpi3_sas_io_unit0_phy_data));\n\tsas_io_unit_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_io_unit_pg0)\n\t\treturn;\n\n\tif (mpi3mr_cfg_get_sas_io_unit_pg0(mrioc, sas_io_unit_pg0, sz)) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\tmrioc->sas_hba.handle = 0;\n\tfor (i = 0; i < mrioc->sas_hba.num_phys; i++) {\n\t\tif (sas_io_unit_pg0->phy_data[i].phy_flags &\n\t\t    (MPI3_SASIOUNIT0_PHYFLAGS_HOST_PHY |\n\t\t    MPI3_SASIOUNIT0_PHYFLAGS_VIRTUAL_PHY))\n\t\t\tcontinue;\n\t\tif (mpi3mr_cfg_get_sas_phy_pg0(mrioc, &ioc_status, &phy_pg0,\n\t\t    sizeof(struct mpi3_sas_phy_page0),\n\t\t    MPI3_SAS_PHY_PGAD_FORM_PHY_NUMBER, i)) {\n\t\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!mrioc->sas_hba.handle)\n\t\t\tmrioc->sas_hba.handle = le16_to_cpu(\n\t\t\t    sas_io_unit_pg0->phy_data[i].controller_dev_handle);\n\t\tport_id = sas_io_unit_pg0->phy_data[i].io_unit_port;\n\n\t\tif (!(mpi3mr_get_hba_port_by_id(mrioc, port_id)))\n\t\t\tif (!mpi3mr_alloc_hba_port(mrioc, port_id))\n\t\t\t\tgoto out;\n\n\t\tmrioc->sas_hba.phy[i].handle = mrioc->sas_hba.handle;\n\t\tmrioc->sas_hba.phy[i].phy_id = i;\n\t\tmrioc->sas_hba.phy[i].hba_port =\n\t\t    mpi3mr_get_hba_port_by_id(mrioc, port_id);\n\t\tmpi3mr_add_host_phy(mrioc, &mrioc->sas_hba.phy[i],\n\t\t    phy_pg0, mrioc->sas_hba.parent_dev);\n\t}\n\tif ((mpi3mr_cfg_get_dev_pg0(mrioc, &ioc_status, &dev_pg0,\n\t    sizeof(dev_pg0), MPI3_DEVICE_PGAD_FORM_HANDLE,\n\t    mrioc->sas_hba.handle))) {\n\t\tioc_err(mrioc, \"%s: device page0 read failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"device page read failed for handle(0x%04x), with ioc_status(0x%04x) failure at %s:%d/%s()!\\n\",\n\t\t    mrioc->sas_hba.handle, ioc_status, __FILE__, __LINE__,\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\tmrioc->sas_hba.enclosure_handle =\n\t    le16_to_cpu(dev_pg0.enclosure_handle);\n\tsasinf = &dev_pg0.device_specific.sas_sata_format;\n\tmrioc->sas_hba.sas_address =\n\t    le64_to_cpu(sasinf->sas_address);\n\tioc_info(mrioc,\n\t    \"host_add: handle(0x%04x), sas_addr(0x%016llx), phys(%d)\\n\",\n\t    mrioc->sas_hba.handle,\n\t    (unsigned long long) mrioc->sas_hba.sas_address,\n\t    mrioc->sas_hba.num_phys);\n\n\tif (mrioc->sas_hba.enclosure_handle) {\n\t\tif (!(mpi3mr_cfg_get_enclosure_pg0(mrioc, &ioc_status,\n\t\t    &encl_pg0, sizeof(encl_pg0),\n\t\t    MPI3_ENCLOS_PGAD_FORM_HANDLE,\n\t\t    mrioc->sas_hba.enclosure_handle)) &&\n\t\t    (ioc_status == MPI3_IOCSTATUS_SUCCESS))\n\t\t\tmrioc->sas_hba.enclosure_logical_id =\n\t\t\t\tle64_to_cpu(encl_pg0.enclosure_logical_id);\n\t}\n\nout:\n\tkfree(sas_io_unit_pg0);\n}\n\n \nstatic struct mpi3mr_sas_port *mpi3mr_sas_port_add(struct mpi3mr_ioc *mrioc,\n\tu16 handle, u64 sas_address_parent, struct mpi3mr_hba_port *hba_port)\n{\n\tstruct mpi3mr_sas_phy *mr_sas_phy, *next;\n\tstruct mpi3mr_sas_port *mr_sas_port;\n\tunsigned long flags;\n\tstruct mpi3mr_sas_node *mr_sas_node;\n\tstruct sas_rphy *rphy;\n\tstruct mpi3mr_tgt_dev *tgtdev = NULL;\n\tint i;\n\tstruct sas_port *port;\n\n\tif (!hba_port) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn NULL;\n\t}\n\n\tmr_sas_port = kzalloc(sizeof(struct mpi3mr_sas_port), GFP_KERNEL);\n\tif (!mr_sas_port)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&mr_sas_port->port_list);\n\tINIT_LIST_HEAD(&mr_sas_port->phy_list);\n\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\tmr_sas_node = __mpi3mr_sas_node_find_by_sas_address(mrioc,\n\t    sas_address_parent, hba_port);\n\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\n\tif (!mr_sas_node) {\n\t\tioc_err(mrioc, \"%s:could not find parent sas_address(0x%016llx)!\\n\",\n\t\t    __func__, (unsigned long long)sas_address_parent);\n\t\tgoto out_fail;\n\t}\n\n\tif ((mpi3mr_set_identify(mrioc, handle,\n\t    &mr_sas_port->remote_identify))) {\n\t\tioc_err(mrioc,  \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tgoto out_fail;\n\t}\n\n\tif (mr_sas_port->remote_identify.device_type == SAS_PHY_UNUSED) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tgoto out_fail;\n\t}\n\n\tmr_sas_port->hba_port = hba_port;\n\tmpi3mr_sas_port_sanity_check(mrioc, mr_sas_node,\n\t    mr_sas_port->remote_identify.sas_address, hba_port);\n\n\tfor (i = 0; i < mr_sas_node->num_phys; i++) {\n\t\tif ((mr_sas_node->phy[i].remote_identify.sas_address !=\n\t\t    mr_sas_port->remote_identify.sas_address) ||\n\t\t    (mr_sas_node->phy[i].hba_port != hba_port))\n\t\t\tcontinue;\n\t\tlist_add_tail(&mr_sas_node->phy[i].port_siblings,\n\t\t    &mr_sas_port->phy_list);\n\t\tmr_sas_port->num_phys++;\n\t\tmr_sas_port->phy_mask |= (1 << i);\n\t}\n\n\tif (!mr_sas_port->num_phys) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tgoto out_fail;\n\t}\n\n\tmr_sas_port->lowest_phy = ffs(mr_sas_port->phy_mask) - 1;\n\n\tif (mr_sas_port->remote_identify.device_type == SAS_END_DEVICE) {\n\t\ttgtdev = mpi3mr_get_tgtdev_by_addr(mrioc,\n\t\t    mr_sas_port->remote_identify.sas_address,\n\t\t    mr_sas_port->hba_port);\n\n\t\tif (!tgtdev) {\n\t\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\tgoto out_fail;\n\t\t}\n\t\ttgtdev->dev_spec.sas_sata_inf.pend_sas_rphy_add = 1;\n\t}\n\n\tif (!mr_sas_node->parent_dev) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tgoto out_fail;\n\t}\n\n\tport = sas_port_alloc_num(mr_sas_node->parent_dev);\n\tif ((sas_port_add(port))) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tgoto out_fail;\n\t}\n\n\tlist_for_each_entry(mr_sas_phy, &mr_sas_port->phy_list,\n\t    port_siblings) {\n\t\tif ((mrioc->logging_level & MPI3_DEBUG_TRANSPORT_INFO))\n\t\t\tdev_info(&port->dev,\n\t\t\t    \"add: handle(0x%04x), sas_address(0x%016llx), phy(%d)\\n\",\n\t\t\t    handle, (unsigned long long)\n\t\t\t    mr_sas_port->remote_identify.sas_address,\n\t\t\t    mr_sas_phy->phy_id);\n\t\tsas_port_add_phy(port, mr_sas_phy->phy);\n\t\tmr_sas_phy->phy_belongs_to_port = 1;\n\t\tmr_sas_phy->hba_port = hba_port;\n\t}\n\n\tmr_sas_port->port = port;\n\tif (mr_sas_port->remote_identify.device_type == SAS_END_DEVICE) {\n\t\trphy = sas_end_device_alloc(port);\n\t\ttgtdev->dev_spec.sas_sata_inf.rphy = rphy;\n\t} else {\n\t\trphy = sas_expander_alloc(port,\n\t\t    mr_sas_port->remote_identify.device_type);\n\t}\n\trphy->identify = mr_sas_port->remote_identify;\n\n\tif (mrioc->current_event)\n\t\tmrioc->current_event->pending_at_sml = 1;\n\n\tif ((sas_rphy_add(rphy))) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t}\n\tif (mr_sas_port->remote_identify.device_type == SAS_END_DEVICE) {\n\t\ttgtdev->dev_spec.sas_sata_inf.pend_sas_rphy_add = 0;\n\t\ttgtdev->dev_spec.sas_sata_inf.sas_transport_attached = 1;\n\t\tmpi3mr_tgtdev_put(tgtdev);\n\t}\n\n\tdev_info(&rphy->dev,\n\t    \"%s: added: handle(0x%04x), sas_address(0x%016llx)\\n\",\n\t    __func__, handle, (unsigned long long)\n\t    mr_sas_port->remote_identify.sas_address);\n\n\tmr_sas_port->rphy = rphy;\n\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\tlist_add_tail(&mr_sas_port->port_list, &mr_sas_node->sas_port_list);\n\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\n\tif (mrioc->current_event) {\n\t\tmrioc->current_event->pending_at_sml = 0;\n\t\tif (mrioc->current_event->discard)\n\t\t\tmpi3mr_print_device_event_notice(mrioc, true);\n\t}\n\n\t \n\tif (mr_sas_port->remote_identify.device_type ==\n\t    SAS_EDGE_EXPANDER_DEVICE ||\n\t    mr_sas_port->remote_identify.device_type ==\n\t    SAS_FANOUT_EXPANDER_DEVICE)\n\t\tmpi3mr_report_manufacture(mrioc,\n\t\t    mr_sas_port->remote_identify.sas_address,\n\t\t    rphy_to_expander_device(rphy), hba_port->port_id);\n\n\treturn mr_sas_port;\n\n out_fail:\n\tlist_for_each_entry_safe(mr_sas_phy, next, &mr_sas_port->phy_list,\n\t    port_siblings)\n\t\tlist_del(&mr_sas_phy->port_siblings);\n\tkfree(mr_sas_port);\n\treturn NULL;\n}\n\n \nstatic void mpi3mr_sas_port_remove(struct mpi3mr_ioc *mrioc, u64 sas_address,\n\tu64 sas_address_parent, struct mpi3mr_hba_port *hba_port)\n{\n\tint i;\n\tunsigned long flags;\n\tstruct mpi3mr_sas_port *mr_sas_port, *next;\n\tstruct mpi3mr_sas_node *mr_sas_node;\n\tu8 found = 0;\n\tstruct mpi3mr_sas_phy *mr_sas_phy, *next_phy;\n\tstruct mpi3mr_hba_port *srch_port, *hba_port_next = NULL;\n\n\tif (!hba_port)\n\t\treturn;\n\n\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\tmr_sas_node = __mpi3mr_sas_node_find_by_sas_address(mrioc,\n\t    sas_address_parent, hba_port);\n\tif (!mr_sas_node) {\n\t\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\t\treturn;\n\t}\n\tlist_for_each_entry_safe(mr_sas_port, next, &mr_sas_node->sas_port_list,\n\t    port_list) {\n\t\tif (mr_sas_port->remote_identify.sas_address != sas_address)\n\t\t\tcontinue;\n\t\tif (mr_sas_port->hba_port != hba_port)\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tlist_del(&mr_sas_port->port_list);\n\t\tgoto out;\n\t}\n\n out:\n\tif (!found) {\n\t\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\t\treturn;\n\t}\n\n\tif (mr_sas_node->host_node) {\n\t\tlist_for_each_entry_safe(srch_port, hba_port_next,\n\t\t    &mrioc->hba_port_table_list, list) {\n\t\t\tif (srch_port != hba_port)\n\t\t\t\tcontinue;\n\t\t\tioc_info(mrioc,\n\t\t\t    \"removing hba_port entry: %p port: %d from hba_port list\\n\",\n\t\t\t    srch_port, srch_port->port_id);\n\t\t\tlist_del(&hba_port->list);\n\t\t\tkfree(hba_port);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < mr_sas_node->num_phys; i++) {\n\t\tif (mr_sas_node->phy[i].remote_identify.sas_address ==\n\t\t    sas_address)\n\t\t\tmemset(&mr_sas_node->phy[i].remote_identify, 0,\n\t\t\t    sizeof(struct sas_identify));\n\t}\n\n\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\n\tif (mrioc->current_event)\n\t\tmrioc->current_event->pending_at_sml = 1;\n\n\tlist_for_each_entry_safe(mr_sas_phy, next_phy,\n\t    &mr_sas_port->phy_list, port_siblings) {\n\t\tif ((!mrioc->stop_drv_processing) &&\n\t\t    (mrioc->logging_level & MPI3_DEBUG_TRANSPORT_INFO))\n\t\t\tdev_info(&mr_sas_port->port->dev,\n\t\t\t    \"remove: sas_address(0x%016llx), phy(%d)\\n\",\n\t\t\t    (unsigned long long)\n\t\t\t    mr_sas_port->remote_identify.sas_address,\n\t\t\t    mr_sas_phy->phy_id);\n\t\tmr_sas_phy->phy_belongs_to_port = 0;\n\t\tif (!mrioc->stop_drv_processing)\n\t\t\tsas_port_delete_phy(mr_sas_port->port,\n\t\t\t    mr_sas_phy->phy);\n\t\tlist_del(&mr_sas_phy->port_siblings);\n\t}\n\tif (!mrioc->stop_drv_processing)\n\t\tsas_port_delete(mr_sas_port->port);\n\tioc_info(mrioc, \"%s: removed sas_address(0x%016llx)\\n\",\n\t    __func__, (unsigned long long)sas_address);\n\n\tif (mrioc->current_event) {\n\t\tmrioc->current_event->pending_at_sml = 0;\n\t\tif (mrioc->current_event->discard)\n\t\t\tmpi3mr_print_device_event_notice(mrioc, false);\n\t}\n\n\tkfree(mr_sas_port);\n}\n\n \nstruct host_port {\n\tu64\tsas_address;\n\tu32\tphy_mask;\n\tu16\thandle;\n\tu8\tiounit_port_id;\n\tu8\tused;\n\tu8\tlowest_phy;\n};\n\n \nstatic void\nmpi3mr_update_mr_sas_port(struct mpi3mr_ioc *mrioc, struct host_port *h_port,\n\tstruct mpi3mr_sas_port *mr_sas_port)\n{\n\tstruct mpi3mr_sas_phy *mr_sas_phy;\n\tu32 phy_mask_xor;\n\tu64 phys_to_be_added, phys_to_be_removed;\n\tint i;\n\n\th_port->used = 1;\n\tmr_sas_port->marked_responding = 1;\n\n\tdev_info(&mr_sas_port->port->dev,\n\t    \"sas_address(0x%016llx), old: port_id %d phy_mask 0x%x, new: port_id %d phy_mask:0x%x\\n\",\n\t    mr_sas_port->remote_identify.sas_address,\n\t    mr_sas_port->hba_port->port_id, mr_sas_port->phy_mask,\n\t    h_port->iounit_port_id, h_port->phy_mask);\n\n\tmr_sas_port->hba_port->port_id = h_port->iounit_port_id;\n\tmr_sas_port->hba_port->flags &= ~MPI3MR_HBA_PORT_FLAG_DIRTY;\n\n\t \n\tphy_mask_xor = mr_sas_port->phy_mask ^ h_port->phy_mask;\n\tphys_to_be_added = h_port->phy_mask & phy_mask_xor;\n\tphys_to_be_removed = mr_sas_port->phy_mask & phy_mask_xor;\n\n\t \n\tfor_each_set_bit(i, (ulong *) &phys_to_be_added, BITS_PER_TYPE(u32)) {\n\t\tmr_sas_phy = &mrioc->sas_hba.phy[i];\n\t\tif (mr_sas_phy->phy_belongs_to_port)\n\t\t\tmpi3mr_del_phy_from_an_existing_port(mrioc,\n\t\t\t    &mrioc->sas_hba, mr_sas_phy);\n\t\tmpi3mr_add_phy_to_an_existing_port(mrioc,\n\t\t    &mrioc->sas_hba, mr_sas_phy,\n\t\t    mr_sas_port->remote_identify.sas_address,\n\t\t    mr_sas_port->hba_port);\n\t}\n\n\t \n\tfor_each_set_bit(i, (ulong *) &phys_to_be_removed, BITS_PER_TYPE(u32)) {\n\t\tmr_sas_phy = &mrioc->sas_hba.phy[i];\n\t\tif (mr_sas_phy->phy_belongs_to_port)\n\t\t\tmpi3mr_del_phy_from_an_existing_port(mrioc,\n\t\t\t    &mrioc->sas_hba, mr_sas_phy);\n\t}\n}\n\n \nvoid\nmpi3mr_refresh_sas_ports(struct mpi3mr_ioc *mrioc)\n{\n\tstruct host_port h_port[32];\n\tint i, j, found, host_port_count = 0, port_idx;\n\tu16 sz, attached_handle, ioc_status;\n\tstruct mpi3_sas_io_unit_page0 *sas_io_unit_pg0 = NULL;\n\tstruct mpi3_device_page0 dev_pg0;\n\tstruct mpi3_device0_sas_sata_format *sasinf;\n\tstruct mpi3mr_sas_port *mr_sas_port;\n\n\tsz = offsetof(struct mpi3_sas_io_unit_page0, phy_data) +\n\t\t(mrioc->sas_hba.num_phys *\n\t\t sizeof(struct mpi3_sas_io_unit0_phy_data));\n\tsas_io_unit_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_io_unit_pg0)\n\t\treturn;\n\tif (mpi3mr_cfg_get_sas_io_unit_pg0(mrioc, sas_io_unit_pg0, sz)) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < mrioc->sas_hba.num_phys; i++) {\n\t\tattached_handle = le16_to_cpu(\n\t\t    sas_io_unit_pg0->phy_data[i].attached_dev_handle);\n\t\tif (!attached_handle)\n\t\t\tcontinue;\n\t\tfound = 0;\n\t\tfor (j = 0; j < host_port_count; j++) {\n\t\t\tif (h_port[j].handle == attached_handle) {\n\t\t\t\th_port[j].phy_mask |= (1 << i);\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\tcontinue;\n\t\tif ((mpi3mr_cfg_get_dev_pg0(mrioc, &ioc_status, &dev_pg0,\n\t\t    sizeof(dev_pg0), MPI3_DEVICE_PGAD_FORM_HANDLE,\n\t\t    attached_handle))) {\n\t\t\tdprint_reset(mrioc,\n\t\t\t    \"failed to read dev_pg0 for handle(0x%04x) at %s:%d/%s()!\\n\",\n\t\t\t    attached_handle, __FILE__, __LINE__, __func__);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\t\tdprint_reset(mrioc,\n\t\t\t    \"ioc_status(0x%x) while reading dev_pg0 for handle(0x%04x) at %s:%d/%s()!\\n\",\n\t\t\t    ioc_status, attached_handle,\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\tcontinue;\n\t\t}\n\t\tsasinf = &dev_pg0.device_specific.sas_sata_format;\n\n\t\tport_idx = host_port_count;\n\t\th_port[port_idx].sas_address = le64_to_cpu(sasinf->sas_address);\n\t\th_port[port_idx].handle = attached_handle;\n\t\th_port[port_idx].phy_mask = (1 << i);\n\t\th_port[port_idx].iounit_port_id = sas_io_unit_pg0->phy_data[i].io_unit_port;\n\t\th_port[port_idx].lowest_phy = sasinf->phy_num;\n\t\th_port[port_idx].used = 0;\n\t\thost_port_count++;\n\t}\n\n\tif (!host_port_count)\n\t\tgoto out;\n\n\tif (mrioc->logging_level & MPI3_DEBUG_RESET) {\n\t\tioc_info(mrioc, \"Host port details before reset\\n\");\n\t\tlist_for_each_entry(mr_sas_port, &mrioc->sas_hba.sas_port_list,\n\t\t    port_list) {\n\t\t\tioc_info(mrioc,\n\t\t\t    \"port_id:%d, sas_address:(0x%016llx), phy_mask:(0x%x), lowest phy id:%d\\n\",\n\t\t\t    mr_sas_port->hba_port->port_id,\n\t\t\t    mr_sas_port->remote_identify.sas_address,\n\t\t\t    mr_sas_port->phy_mask, mr_sas_port->lowest_phy);\n\t\t}\n\t\tmr_sas_port = NULL;\n\t\tioc_info(mrioc, \"Host port details after reset\\n\");\n\t\tfor (i = 0; i < host_port_count; i++) {\n\t\t\tioc_info(mrioc,\n\t\t\t    \"port_id:%d, sas_address:(0x%016llx), phy_mask:(0x%x), lowest phy id:%d\\n\",\n\t\t\t    h_port[i].iounit_port_id, h_port[i].sas_address,\n\t\t\t    h_port[i].phy_mask, h_port[i].lowest_phy);\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(mr_sas_port, &mrioc->sas_hba.sas_port_list,\n\t    port_list) {\n\t\tmr_sas_port->marked_responding = 0;\n\t\tmr_sas_port->hba_port->flags |= MPI3MR_HBA_PORT_FLAG_DIRTY;\n\t}\n\n\t \n\tfor (i = 0; i < host_port_count; i++) {\n\t\tmr_sas_port = NULL;\n\t\tlist_for_each_entry(mr_sas_port, &mrioc->sas_hba.sas_port_list,\n\t\t    port_list) {\n\t\t\tif (mr_sas_port->marked_responding)\n\t\t\t\tcontinue;\n\t\t\tif (h_port[i].sas_address != mr_sas_port->remote_identify.sas_address)\n\t\t\t\tcontinue;\n\t\t\tif (h_port[i].lowest_phy == mr_sas_port->lowest_phy) {\n\t\t\t\tmpi3mr_update_mr_sas_port(mrioc, &h_port[i], mr_sas_port);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < host_port_count; i++) {\n\t\tif (h_port[i].used)\n\t\t\tcontinue;\n\t\tmr_sas_port = NULL;\n\t\tlist_for_each_entry(mr_sas_port, &mrioc->sas_hba.sas_port_list,\n\t\t    port_list) {\n\t\t\tif (mr_sas_port->marked_responding)\n\t\t\t\tcontinue;\n\t\t\tif (h_port[i].sas_address != mr_sas_port->remote_identify.sas_address)\n\t\t\t\tcontinue;\n\t\t\tif (h_port[i].phy_mask & mr_sas_port->phy_mask) {\n\t\t\t\tmpi3mr_update_mr_sas_port(mrioc, &h_port[i], mr_sas_port);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < host_port_count; i++) {\n\t\tif (h_port[i].used)\n\t\t\tcontinue;\n\t\tmr_sas_port = NULL;\n\t\tlist_for_each_entry(mr_sas_port, &mrioc->sas_hba.sas_port_list,\n\t\t    port_list) {\n\t\t\tif (mr_sas_port->marked_responding)\n\t\t\t\tcontinue;\n\t\t\tif (h_port[i].sas_address != mr_sas_port->remote_identify.sas_address)\n\t\t\t\tcontinue;\n\t\t\tmpi3mr_update_mr_sas_port(mrioc, &h_port[i], mr_sas_port);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tkfree(sas_io_unit_pg0);\n}\n\n \nvoid\nmpi3mr_refresh_expanders(struct mpi3mr_ioc *mrioc)\n{\n\tstruct mpi3mr_sas_node *sas_expander, *sas_expander_next;\n\tstruct mpi3_sas_expander_page0 expander_pg0;\n\tu16 ioc_status, handle;\n\tu64 sas_address;\n\tint i;\n\tunsigned long flags;\n\tstruct mpi3mr_hba_port *hba_port;\n\n\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\tlist_for_each_entry(sas_expander, &mrioc->sas_expander_list, list) {\n\t\tsas_expander->non_responding = 1;\n\t}\n\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\n\tsas_expander = NULL;\n\n\thandle = 0xffff;\n\n\t \n\twhile (true) {\n\t\tif ((mpi3mr_cfg_get_sas_exp_pg0(mrioc, &ioc_status, &expander_pg0,\n\t\t    sizeof(struct mpi3_sas_expander_page0),\n\t\t    MPI3_SAS_EXPAND_PGAD_FORM_GET_NEXT_HANDLE, handle))) {\n\t\t\tdprint_reset(mrioc,\n\t\t\t    \"failed to read exp pg0 for handle(0x%04x) at %s:%d/%s()!\\n\",\n\t\t\t    handle, __FILE__, __LINE__, __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\t\tdprint_reset(mrioc,\n\t\t\t   \"ioc_status(0x%x) while reading exp pg0 for handle:(0x%04x), %s:%d/%s()!\\n\",\n\t\t\t   ioc_status, handle, __FILE__, __LINE__, __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\thandle = le16_to_cpu(expander_pg0.dev_handle);\n\t\tsas_address = le64_to_cpu(expander_pg0.sas_address);\n\t\thba_port = mpi3mr_get_hba_port_by_id(mrioc, expander_pg0.io_unit_port);\n\n\t\tif (!hba_port) {\n\t\t\tmpi3mr_sas_host_refresh(mrioc);\n\t\t\tmpi3mr_expander_add(mrioc, handle);\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\t\tsas_expander =\n\t\t    mpi3mr_expander_find_by_sas_address(mrioc,\n\t\t    sas_address, hba_port);\n\t\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\n\t\tif (!sas_expander) {\n\t\t\tmpi3mr_sas_host_refresh(mrioc);\n\t\t\tmpi3mr_expander_add(mrioc, handle);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsas_expander->non_responding = 0;\n\t\tif (sas_expander->handle == handle)\n\t\t\tcontinue;\n\n\t\tsas_expander->handle = handle;\n\t\tfor (i = 0 ; i < sas_expander->num_phys ; i++)\n\t\t\tsas_expander->phy[i].handle = handle;\n\t}\n\n\t \n\tsas_expander = NULL;\n\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\tlist_for_each_entry_safe_reverse(sas_expander, sas_expander_next,\n\t    &mrioc->sas_expander_list, list) {\n\t\tif (sas_expander->non_responding) {\n\t\t\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\t\t\tmpi3mr_expander_node_remove(mrioc, sas_expander);\n\t\t\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n}\n\n \nstatic void mpi3mr_expander_node_add(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_sas_node *sas_expander)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\tlist_add_tail(&sas_expander->list, &mrioc->sas_expander_list);\n\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n}\n\n \nint mpi3mr_expander_add(struct mpi3mr_ioc *mrioc, u16 handle)\n{\n\tstruct mpi3mr_sas_node *sas_expander;\n\tstruct mpi3mr_enclosure_node *enclosure_dev;\n\tstruct mpi3_sas_expander_page0 expander_pg0;\n\tstruct mpi3_sas_expander_page1 expander_pg1;\n\tu16 ioc_status, parent_handle, temp_handle;\n\tu64 sas_address, sas_address_parent = 0;\n\tint i;\n\tunsigned long flags;\n\tu8 port_id, link_rate;\n\tstruct mpi3mr_sas_port *mr_sas_port = NULL;\n\tstruct mpi3mr_hba_port *hba_port;\n\tu32 phynum_handle;\n\tint rc = 0;\n\n\tif (!handle)\n\t\treturn -1;\n\n\tif (mrioc->reset_in_progress)\n\t\treturn -1;\n\n\tif ((mpi3mr_cfg_get_sas_exp_pg0(mrioc, &ioc_status, &expander_pg0,\n\t    sizeof(expander_pg0), MPI3_SAS_EXPAND_PGAD_FORM_HANDLE, handle))) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\tparent_handle = le16_to_cpu(expander_pg0.parent_dev_handle);\n\tif (mpi3mr_get_sas_address(mrioc, parent_handle, &sas_address_parent)\n\t    != 0) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\tport_id = expander_pg0.io_unit_port;\n\thba_port = mpi3mr_get_hba_port_by_id(mrioc, port_id);\n\tif (!hba_port) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\tif (sas_address_parent != mrioc->sas_hba.sas_address) {\n\t\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\t\tsas_expander =\n\t\t   mpi3mr_expander_find_by_sas_address(mrioc,\n\t\t    sas_address_parent, hba_port);\n\t\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\t\tif (!sas_expander) {\n\t\t\trc = mpi3mr_expander_add(mrioc, parent_handle);\n\t\t\tif (rc != 0)\n\t\t\t\treturn rc;\n\t\t} else {\n\t\t\t \n\t\t\tfor (i = 0 ; i < sas_expander->num_phys ; i++) {\n\t\t\t\tphynum_handle =\n\t\t\t\t    (i << MPI3_SAS_EXPAND_PGAD_PHYNUM_SHIFT) |\n\t\t\t\t    parent_handle;\n\t\t\t\tif (mpi3mr_cfg_get_sas_exp_pg1(mrioc,\n\t\t\t\t    &ioc_status, &expander_pg1,\n\t\t\t\t    sizeof(expander_pg1),\n\t\t\t\t    MPI3_SAS_EXPAND_PGAD_FORM_HANDLE_PHY_NUM,\n\t\t\t\t    phynum_handle)) {\n\t\t\t\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\t\t\trc = -1;\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\t\t\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\t\t\trc = -1;\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\ttemp_handle = le16_to_cpu(\n\t\t\t\t    expander_pg1.attached_dev_handle);\n\t\t\t\tif (temp_handle != handle)\n\t\t\t\t\tcontinue;\n\t\t\t\tlink_rate = (expander_pg1.negotiated_link_rate &\n\t\t\t\t    MPI3_SAS_NEG_LINK_RATE_LOGICAL_MASK) >>\n\t\t\t\t    MPI3_SAS_NEG_LINK_RATE_LOGICAL_SHIFT;\n\t\t\t\tmpi3mr_update_links(mrioc, sas_address_parent,\n\t\t\t\t    handle, i, link_rate, hba_port);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\tsas_address = le64_to_cpu(expander_pg0.sas_address);\n\tsas_expander = mpi3mr_expander_find_by_sas_address(mrioc,\n\t    sas_address, hba_port);\n\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\n\tif (sas_expander)\n\t\treturn 0;\n\n\tsas_expander = kzalloc(sizeof(struct mpi3mr_sas_node),\n\t    GFP_KERNEL);\n\tif (!sas_expander)\n\t\treturn -ENOMEM;\n\n\tsas_expander->handle = handle;\n\tsas_expander->num_phys = expander_pg0.num_phys;\n\tsas_expander->sas_address_parent = sas_address_parent;\n\tsas_expander->sas_address = sas_address;\n\tsas_expander->hba_port = hba_port;\n\n\tioc_info(mrioc,\n\t    \"expander_add: handle(0x%04x), parent(0x%04x), sas_addr(0x%016llx), phys(%d)\\n\",\n\t    handle, parent_handle, (unsigned long long)\n\t    sas_expander->sas_address, sas_expander->num_phys);\n\n\tif (!sas_expander->num_phys) {\n\t\trc = -1;\n\t\tgoto out_fail;\n\t}\n\tsas_expander->phy = kcalloc(sas_expander->num_phys,\n\t    sizeof(struct mpi3mr_sas_phy), GFP_KERNEL);\n\tif (!sas_expander->phy) {\n\t\trc = -1;\n\t\tgoto out_fail;\n\t}\n\n\tINIT_LIST_HEAD(&sas_expander->sas_port_list);\n\tmr_sas_port = mpi3mr_sas_port_add(mrioc, handle, sas_address_parent,\n\t    sas_expander->hba_port);\n\tif (!mr_sas_port) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\trc = -1;\n\t\tgoto out_fail;\n\t}\n\tsas_expander->parent_dev = &mr_sas_port->rphy->dev;\n\tsas_expander->rphy = mr_sas_port->rphy;\n\n\tfor (i = 0 ; i < sas_expander->num_phys ; i++) {\n\t\tphynum_handle = (i << MPI3_SAS_EXPAND_PGAD_PHYNUM_SHIFT) |\n\t\t    handle;\n\t\tif (mpi3mr_cfg_get_sas_exp_pg1(mrioc, &ioc_status,\n\t\t    &expander_pg1, sizeof(expander_pg1),\n\t\t    MPI3_SAS_EXPAND_PGAD_FORM_HANDLE_PHY_NUM,\n\t\t    phynum_handle)) {\n\t\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\trc = -1;\n\t\t\tgoto out_fail;\n\t\t}\n\t\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\trc = -1;\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tsas_expander->phy[i].handle = handle;\n\t\tsas_expander->phy[i].phy_id = i;\n\t\tsas_expander->phy[i].hba_port = hba_port;\n\n\t\tif ((mpi3mr_add_expander_phy(mrioc, &sas_expander->phy[i],\n\t\t    expander_pg1, sas_expander->parent_dev))) {\n\t\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\trc = -1;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tif (sas_expander->enclosure_handle) {\n\t\tenclosure_dev =\n\t\t\tmpi3mr_enclosure_find_by_handle(mrioc,\n\t\t\t\t\t\tsas_expander->enclosure_handle);\n\t\tif (enclosure_dev)\n\t\t\tsas_expander->enclosure_logical_id = le64_to_cpu(\n\t\t\t    enclosure_dev->pg0.enclosure_logical_id);\n\t}\n\n\tmpi3mr_expander_node_add(mrioc, sas_expander);\n\treturn 0;\n\nout_fail:\n\n\tif (mr_sas_port)\n\t\tmpi3mr_sas_port_remove(mrioc,\n\t\t    sas_expander->sas_address,\n\t\t    sas_address_parent, sas_expander->hba_port);\n\tkfree(sas_expander->phy);\n\tkfree(sas_expander);\n\treturn rc;\n}\n\n \nvoid mpi3mr_expander_node_remove(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_sas_node *sas_expander)\n{\n\tstruct mpi3mr_sas_port *mr_sas_port, *next;\n\tunsigned long flags;\n\tu8 port_id;\n\n\t \n\tlist_for_each_entry_safe(mr_sas_port, next,\n\t   &sas_expander->sas_port_list, port_list) {\n\t\tif (mrioc->reset_in_progress)\n\t\t\treturn;\n\t\tif (mr_sas_port->remote_identify.device_type ==\n\t\t    SAS_END_DEVICE)\n\t\t\tmpi3mr_remove_device_by_sas_address(mrioc,\n\t\t\t    mr_sas_port->remote_identify.sas_address,\n\t\t\t    mr_sas_port->hba_port);\n\t\telse if (mr_sas_port->remote_identify.device_type ==\n\t\t    SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    mr_sas_port->remote_identify.device_type ==\n\t\t    SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\tmpi3mr_expander_remove(mrioc,\n\t\t\t    mr_sas_port->remote_identify.sas_address,\n\t\t\t    mr_sas_port->hba_port);\n\t}\n\n\tport_id = sas_expander->hba_port->port_id;\n\tmpi3mr_sas_port_remove(mrioc, sas_expander->sas_address,\n\t    sas_expander->sas_address_parent, sas_expander->hba_port);\n\n\tioc_info(mrioc, \"expander_remove: handle(0x%04x), sas_addr(0x%016llx), port:%d\\n\",\n\t    sas_expander->handle, (unsigned long long)\n\t    sas_expander->sas_address, port_id);\n\n\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\tlist_del(&sas_expander->list);\n\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\n\tkfree(sas_expander->phy);\n\tkfree(sas_expander);\n}\n\n \nvoid mpi3mr_expander_remove(struct mpi3mr_ioc *mrioc, u64 sas_address,\n\tstruct mpi3mr_hba_port *hba_port)\n{\n\tstruct mpi3mr_sas_node *sas_expander;\n\tunsigned long flags;\n\n\tif (mrioc->reset_in_progress)\n\t\treturn;\n\n\tif (!hba_port)\n\t\treturn;\n\n\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\tsas_expander = mpi3mr_expander_find_by_sas_address(mrioc, sas_address,\n\t    hba_port);\n\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\tif (sas_expander)\n\t\tmpi3mr_expander_node_remove(mrioc, sas_expander);\n\n}\n\n \nstatic u8 mpi3mr_get_sas_negotiated_logical_linkrate(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_tgt_dev *tgtdev)\n{\n\tu8 link_rate = MPI3_SAS_NEG_LINK_RATE_1_5, phy_number;\n\tstruct mpi3_sas_expander_page1 expander_pg1;\n\tstruct mpi3_sas_phy_page0 phy_pg0;\n\tu32 phynum_handle;\n\tu16 ioc_status;\n\n\tphy_number = tgtdev->dev_spec.sas_sata_inf.phy_id;\n\tif (!(tgtdev->devpg0_flag & MPI3_DEVICE0_FLAGS_ATT_METHOD_DIR_ATTACHED)) {\n\t\tphynum_handle = ((phy_number<<MPI3_SAS_EXPAND_PGAD_PHYNUM_SHIFT)\n\t\t\t\t | tgtdev->parent_handle);\n\t\tif (mpi3mr_cfg_get_sas_exp_pg1(mrioc, &ioc_status,\n\t\t    &expander_pg1, sizeof(expander_pg1),\n\t\t    MPI3_SAS_EXPAND_PGAD_FORM_HANDLE_PHY_NUM,\n\t\t    phynum_handle)) {\n\t\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tlink_rate = (expander_pg1.negotiated_link_rate &\n\t\t\t     MPI3_SAS_NEG_LINK_RATE_LOGICAL_MASK) >>\n\t\t\tMPI3_SAS_NEG_LINK_RATE_LOGICAL_SHIFT;\n\t\tgoto out;\n\t}\n\tif (mpi3mr_cfg_get_sas_phy_pg0(mrioc, &ioc_status, &phy_pg0,\n\t    sizeof(struct mpi3_sas_phy_page0),\n\t    MPI3_SAS_PHY_PGAD_FORM_PHY_NUMBER, phy_number)) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tlink_rate = (phy_pg0.negotiated_link_rate &\n\t\t     MPI3_SAS_NEG_LINK_RATE_LOGICAL_MASK) >>\n\t\tMPI3_SAS_NEG_LINK_RATE_LOGICAL_SHIFT;\nout:\n\treturn link_rate;\n}\n\n \nint mpi3mr_report_tgtdev_to_sas_transport(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_tgt_dev *tgtdev)\n{\n\tint retval = 0;\n\tu8 link_rate, parent_phy_number;\n\tu64 sas_address_parent, sas_address;\n\tstruct mpi3mr_hba_port *hba_port;\n\tu8 port_id;\n\n\tif ((tgtdev->dev_type != MPI3_DEVICE_DEVFORM_SAS_SATA) ||\n\t    !mrioc->sas_transport_enabled)\n\t\treturn -1;\n\n\tsas_address = tgtdev->dev_spec.sas_sata_inf.sas_address;\n\tif (!mrioc->sas_hba.num_phys)\n\t\tmpi3mr_sas_host_add(mrioc);\n\telse\n\t\tmpi3mr_sas_host_refresh(mrioc);\n\n\tif (mpi3mr_get_sas_address(mrioc, tgtdev->parent_handle,\n\t    &sas_address_parent) != 0) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\ttgtdev->dev_spec.sas_sata_inf.sas_address_parent = sas_address_parent;\n\n\tparent_phy_number = tgtdev->dev_spec.sas_sata_inf.phy_id;\n\tport_id = tgtdev->io_unit_port;\n\n\thba_port = mpi3mr_get_hba_port_by_id(mrioc, port_id);\n\tif (!hba_port) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\ttgtdev->dev_spec.sas_sata_inf.hba_port = hba_port;\n\n\tlink_rate = mpi3mr_get_sas_negotiated_logical_linkrate(mrioc, tgtdev);\n\n\tmpi3mr_update_links(mrioc, sas_address_parent, tgtdev->dev_handle,\n\t    parent_phy_number, link_rate, hba_port);\n\n\ttgtdev->host_exposed = 1;\n\tif (!mpi3mr_sas_port_add(mrioc, tgtdev->dev_handle,\n\t    sas_address_parent, hba_port)) {\n\t\tretval = -1;\n\t\t} else if ((!tgtdev->starget) && (!mrioc->is_driver_loading)) {\n\t\t\tmpi3mr_sas_port_remove(mrioc, sas_address,\n\t\t\t    sas_address_parent, hba_port);\n\t\tretval = -1;\n\t}\n\tif (retval) {\n\t\ttgtdev->dev_spec.sas_sata_inf.hba_port = NULL;\n\t\ttgtdev->host_exposed = 0;\n\t}\n\treturn retval;\n}\n\n \nvoid mpi3mr_remove_tgtdev_from_sas_transport(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_tgt_dev *tgtdev)\n{\n\tu64 sas_address_parent, sas_address;\n\tstruct mpi3mr_hba_port *hba_port;\n\n\tif ((tgtdev->dev_type != MPI3_DEVICE_DEVFORM_SAS_SATA) ||\n\t    !mrioc->sas_transport_enabled)\n\t\treturn;\n\n\thba_port = tgtdev->dev_spec.sas_sata_inf.hba_port;\n\tsas_address = tgtdev->dev_spec.sas_sata_inf.sas_address;\n\tsas_address_parent = tgtdev->dev_spec.sas_sata_inf.sas_address_parent;\n\tmpi3mr_sas_port_remove(mrioc, sas_address, sas_address_parent,\n\t    hba_port);\n\ttgtdev->host_exposed = 0;\n\ttgtdev->dev_spec.sas_sata_inf.hba_port = NULL;\n}\n\n \nstatic inline u8 mpi3mr_get_port_id_by_sas_phy(struct sas_phy *phy)\n{\n\tu8 port_id = 0xFF;\n\tstruct mpi3mr_hba_port *hba_port = phy->hostdata;\n\n\tif (hba_port)\n\t\tport_id = hba_port->port_id;\n\n\treturn port_id;\n}\n\n \nstatic u8 mpi3mr_get_port_id_by_rphy(struct mpi3mr_ioc *mrioc, struct sas_rphy *rphy)\n{\n\tstruct mpi3mr_sas_node *sas_expander;\n\tstruct mpi3mr_tgt_dev *tgtdev;\n\tunsigned long flags;\n\tu8 port_id = 0xFF;\n\n\tif (!rphy)\n\t\treturn port_id;\n\n\tif (rphy->identify.device_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t    rphy->identify.device_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\tspin_lock_irqsave(&mrioc->sas_node_lock, flags);\n\t\tlist_for_each_entry(sas_expander, &mrioc->sas_expander_list,\n\t\t    list) {\n\t\t\tif (sas_expander->rphy == rphy) {\n\t\t\t\tport_id = sas_expander->hba_port->port_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&mrioc->sas_node_lock, flags);\n\t} else if (rphy->identify.device_type == SAS_END_DEVICE) {\n\t\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\n\t\ttgtdev = __mpi3mr_get_tgtdev_by_addr_and_rphy(mrioc,\n\t\t\t    rphy->identify.sas_address, rphy);\n\t\tif (tgtdev && tgtdev->dev_spec.sas_sata_inf.hba_port) {\n\t\t\tport_id =\n\t\t\t\ttgtdev->dev_spec.sas_sata_inf.hba_port->port_id;\n\t\t\tmpi3mr_tgtdev_put(tgtdev);\n\t\t}\n\t\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\t}\n\treturn port_id;\n}\n\nstatic inline struct mpi3mr_ioc *phy_to_mrioc(struct sas_phy *phy)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\n\treturn shost_priv(shost);\n}\n\nstatic inline struct mpi3mr_ioc *rphy_to_mrioc(struct sas_rphy *rphy)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(rphy->dev.parent->parent);\n\n\treturn shost_priv(shost);\n}\n\n \nstruct phy_error_log_request {\n\tu8 smp_frame_type;  \n\tu8 function;  \n\tu8 allocated_response_length;\n\tu8 request_length;  \n\tu8 reserved_1[5];\n\tu8 phy_identifier;\n\tu8 reserved_2[2];\n};\n\n \nstruct phy_error_log_reply {\n\tu8 smp_frame_type;  \n\tu8 function;  \n\tu8 function_result;\n\tu8 response_length;\n\t__be16 expander_change_count;\n\tu8 reserved_1[3];\n\tu8 phy_identifier;\n\tu8 reserved_2[2];\n\t__be32 invalid_dword;\n\t__be32 running_disparity_error;\n\t__be32 loss_of_dword_sync;\n\t__be32 phy_reset_problem;\n};\n\n\n \nstatic int mpi3mr_get_expander_phy_error_log(struct mpi3mr_ioc *mrioc,\n\tstruct sas_phy *phy)\n{\n\tstruct mpi3_smp_passthrough_request mpi_request;\n\tstruct mpi3_smp_passthrough_reply mpi_reply;\n\tstruct phy_error_log_request *phy_error_log_request;\n\tstruct phy_error_log_reply *phy_error_log_reply;\n\tint rc;\n\tvoid *psge;\n\tvoid *data_out = NULL;\n\tdma_addr_t data_out_dma, data_in_dma;\n\tu32 data_out_sz, data_in_sz, sz;\n\tu8 sgl_flags = MPI3MR_SGEFLAGS_SYSTEM_SIMPLE_END_OF_LIST;\n\tu16 request_sz = sizeof(struct mpi3_smp_passthrough_request);\n\tu16 reply_sz = sizeof(struct mpi3_smp_passthrough_reply);\n\tu16 ioc_status;\n\n\tif (mrioc->reset_in_progress) {\n\t\tioc_err(mrioc, \"%s: host reset in progress!\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tdata_out_sz = sizeof(struct phy_error_log_request);\n\tdata_in_sz = sizeof(struct phy_error_log_reply);\n\tsz = data_out_sz + data_in_sz;\n\tdata_out = dma_alloc_coherent(&mrioc->pdev->dev, sz, &data_out_dma,\n\t    GFP_KERNEL);\n\tif (!data_out) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdata_in_dma = data_out_dma + data_out_sz;\n\tphy_error_log_reply = data_out + data_out_sz;\n\n\trc = -EINVAL;\n\tmemset(data_out, 0, sz);\n\tphy_error_log_request = data_out;\n\tphy_error_log_request->smp_frame_type = 0x40;\n\tphy_error_log_request->function = 0x11;\n\tphy_error_log_request->request_length = 2;\n\tphy_error_log_request->allocated_response_length = 0;\n\tphy_error_log_request->phy_identifier = phy->number;\n\n\tmemset(&mpi_request, 0, request_sz);\n\tmemset(&mpi_reply, 0, reply_sz);\n\tmpi_request.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_TRANSPORT_CMDS);\n\tmpi_request.function = MPI3_FUNCTION_SMP_PASSTHROUGH;\n\tmpi_request.io_unit_port = (u8) mpi3mr_get_port_id_by_sas_phy(phy);\n\tmpi_request.sas_address = cpu_to_le64(phy->identify.sas_address);\n\n\tpsge = &mpi_request.request_sge;\n\tmpi3mr_add_sg_single(psge, sgl_flags, data_out_sz, data_out_dma);\n\n\tpsge = &mpi_request.response_sge;\n\tmpi3mr_add_sg_single(psge, sgl_flags, data_in_sz, data_in_dma);\n\n\tdprint_transport_info(mrioc,\n\t    \"sending phy error log SMP request to sas_address(0x%016llx), phy_id(%d)\\n\",\n\t    (unsigned long long)phy->identify.sas_address, phy->number);\n\n\tif (mpi3mr_post_transport_req(mrioc, &mpi_request, request_sz,\n\t    &mpi_reply, reply_sz, MPI3MR_INTADMCMD_TIMEOUT, &ioc_status))\n\t\tgoto out;\n\n\tdprint_transport_info(mrioc,\n\t    \"phy error log SMP request completed with ioc_status(0x%04x)\\n\",\n\t    ioc_status);\n\n\tif (ioc_status == MPI3_IOCSTATUS_SUCCESS) {\n\t\tdprint_transport_info(mrioc,\n\t\t    \"phy error log - reply data transfer size(%d)\\n\",\n\t\t    le16_to_cpu(mpi_reply.response_data_length));\n\n\t\tif (le16_to_cpu(mpi_reply.response_data_length) !=\n\t\t    sizeof(struct phy_error_log_reply))\n\t\t\tgoto out;\n\n\t\tdprint_transport_info(mrioc,\n\t\t    \"phy error log - function_result(%d)\\n\",\n\t\t    phy_error_log_reply->function_result);\n\n\t\tphy->invalid_dword_count =\n\t\t    be32_to_cpu(phy_error_log_reply->invalid_dword);\n\t\tphy->running_disparity_error_count =\n\t\t    be32_to_cpu(phy_error_log_reply->running_disparity_error);\n\t\tphy->loss_of_dword_sync_count =\n\t\t    be32_to_cpu(phy_error_log_reply->loss_of_dword_sync);\n\t\tphy->phy_reset_problem_count =\n\t\t    be32_to_cpu(phy_error_log_reply->phy_reset_problem);\n\t\trc = 0;\n\t}\n\nout:\n\tif (data_out)\n\t\tdma_free_coherent(&mrioc->pdev->dev, sz, data_out,\n\t\t    data_out_dma);\n\n\treturn rc;\n}\n\n \nstatic int mpi3mr_transport_get_linkerrors(struct sas_phy *phy)\n{\n\tstruct mpi3mr_ioc *mrioc = phy_to_mrioc(phy);\n\tstruct mpi3_sas_phy_page1 phy_pg1;\n\tint rc = 0;\n\tu16 ioc_status;\n\n\trc = mpi3mr_parent_present(mrioc, phy);\n\tif (rc)\n\t\treturn rc;\n\n\tif (phy->identify.sas_address != mrioc->sas_hba.sas_address)\n\t\treturn mpi3mr_get_expander_phy_error_log(mrioc, phy);\n\n\tmemset(&phy_pg1, 0, sizeof(struct mpi3_sas_phy_page1));\n\t \n\tif ((mpi3mr_cfg_get_sas_phy_pg1(mrioc, &ioc_status, &phy_pg1,\n\t    sizeof(struct mpi3_sas_phy_page1),\n\t    MPI3_SAS_PHY_PGAD_FORM_PHY_NUMBER, phy->number))) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn -ENXIO;\n\t}\n\tphy->invalid_dword_count = le32_to_cpu(phy_pg1.invalid_dword_count);\n\tphy->running_disparity_error_count =\n\t\tle32_to_cpu(phy_pg1.running_disparity_error_count);\n\tphy->loss_of_dword_sync_count =\n\t\tle32_to_cpu(phy_pg1.loss_dword_synch_count);\n\tphy->phy_reset_problem_count =\n\t\tle32_to_cpu(phy_pg1.phy_reset_problem_count);\n\treturn 0;\n}\n\n \nstatic int\nmpi3mr_transport_get_enclosure_identifier(struct sas_rphy *rphy,\n\tu64 *identifier)\n{\n\tstruct mpi3mr_ioc *mrioc = rphy_to_mrioc(rphy);\n\tstruct mpi3mr_tgt_dev *tgtdev = NULL;\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\ttgtdev = __mpi3mr_get_tgtdev_by_addr_and_rphy(mrioc,\n\t    rphy->identify.sas_address, rphy);\n\tif (tgtdev) {\n\t\t*identifier =\n\t\t\ttgtdev->enclosure_logical_id;\n\t\trc = 0;\n\t\tmpi3mr_tgtdev_put(tgtdev);\n\t} else {\n\t\t*identifier = 0;\n\t\trc = -ENXIO;\n\t}\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\n\treturn rc;\n}\n\n \nstatic int\nmpi3mr_transport_get_bay_identifier(struct sas_rphy *rphy)\n{\n\tstruct mpi3mr_ioc *mrioc = rphy_to_mrioc(rphy);\n\tstruct mpi3mr_tgt_dev *tgtdev = NULL;\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&mrioc->tgtdev_lock, flags);\n\ttgtdev = __mpi3mr_get_tgtdev_by_addr_and_rphy(mrioc,\n\t    rphy->identify.sas_address, rphy);\n\tif (tgtdev) {\n\t\trc = tgtdev->slot;\n\t\tmpi3mr_tgtdev_put(tgtdev);\n\t} else\n\t\trc = -ENXIO;\n\tspin_unlock_irqrestore(&mrioc->tgtdev_lock, flags);\n\n\treturn rc;\n}\n\n \nstruct phy_control_request {\n\tu8 smp_frame_type;  \n\tu8 function;  \n\tu8 allocated_response_length;\n\tu8 request_length;  \n\tu16 expander_change_count;\n\tu8 reserved_1[3];\n\tu8 phy_identifier;\n\tu8 phy_operation;\n\tu8 reserved_2[13];\n\tu64 attached_device_name;\n\tu8 programmed_min_physical_link_rate;\n\tu8 programmed_max_physical_link_rate;\n\tu8 reserved_3[6];\n};\n\n \nstruct phy_control_reply {\n\tu8 smp_frame_type;  \n\tu8 function;  \n\tu8 function_result;\n\tu8 response_length;\n};\n\n#define SMP_PHY_CONTROL_LINK_RESET\t(0x01)\n#define SMP_PHY_CONTROL_HARD_RESET\t(0x02)\n#define SMP_PHY_CONTROL_DISABLE\t\t(0x03)\n\n \nstatic int\nmpi3mr_expander_phy_control(struct mpi3mr_ioc *mrioc,\n\tstruct sas_phy *phy, u8 phy_operation)\n{\n\tstruct mpi3_smp_passthrough_request mpi_request;\n\tstruct mpi3_smp_passthrough_reply mpi_reply;\n\tstruct phy_control_request *phy_control_request;\n\tstruct phy_control_reply *phy_control_reply;\n\tint rc;\n\tvoid *psge;\n\tvoid *data_out = NULL;\n\tdma_addr_t data_out_dma;\n\tdma_addr_t data_in_dma;\n\tsize_t data_in_sz;\n\tsize_t data_out_sz;\n\tu8 sgl_flags = MPI3MR_SGEFLAGS_SYSTEM_SIMPLE_END_OF_LIST;\n\tu16 request_sz = sizeof(struct mpi3_smp_passthrough_request);\n\tu16 reply_sz = sizeof(struct mpi3_smp_passthrough_reply);\n\tu16 ioc_status;\n\tu16 sz;\n\n\tif (mrioc->reset_in_progress) {\n\t\tioc_err(mrioc, \"%s: host reset in progress!\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tdata_out_sz = sizeof(struct phy_control_request);\n\tdata_in_sz = sizeof(struct phy_control_reply);\n\tsz = data_out_sz + data_in_sz;\n\tdata_out = dma_alloc_coherent(&mrioc->pdev->dev, sz, &data_out_dma,\n\t    GFP_KERNEL);\n\tif (!data_out) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdata_in_dma = data_out_dma + data_out_sz;\n\tphy_control_reply = data_out + data_out_sz;\n\n\trc = -EINVAL;\n\tmemset(data_out, 0, sz);\n\n\tphy_control_request = data_out;\n\tphy_control_request->smp_frame_type = 0x40;\n\tphy_control_request->function = 0x91;\n\tphy_control_request->request_length = 9;\n\tphy_control_request->allocated_response_length = 0;\n\tphy_control_request->phy_identifier = phy->number;\n\tphy_control_request->phy_operation = phy_operation;\n\tphy_control_request->programmed_min_physical_link_rate =\n\t    phy->minimum_linkrate << 4;\n\tphy_control_request->programmed_max_physical_link_rate =\n\t    phy->maximum_linkrate << 4;\n\n\tmemset(&mpi_request, 0, request_sz);\n\tmemset(&mpi_reply, 0, reply_sz);\n\tmpi_request.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_TRANSPORT_CMDS);\n\tmpi_request.function = MPI3_FUNCTION_SMP_PASSTHROUGH;\n\tmpi_request.io_unit_port = (u8) mpi3mr_get_port_id_by_sas_phy(phy);\n\tmpi_request.sas_address = cpu_to_le64(phy->identify.sas_address);\n\n\tpsge = &mpi_request.request_sge;\n\tmpi3mr_add_sg_single(psge, sgl_flags, data_out_sz, data_out_dma);\n\n\tpsge = &mpi_request.response_sge;\n\tmpi3mr_add_sg_single(psge, sgl_flags, data_in_sz, data_in_dma);\n\n\tdprint_transport_info(mrioc,\n\t    \"sending phy control SMP request to sas_address(0x%016llx), phy_id(%d) opcode(%d)\\n\",\n\t    (unsigned long long)phy->identify.sas_address, phy->number,\n\t    phy_operation);\n\n\tif (mpi3mr_post_transport_req(mrioc, &mpi_request, request_sz,\n\t    &mpi_reply, reply_sz, MPI3MR_INTADMCMD_TIMEOUT, &ioc_status))\n\t\tgoto out;\n\n\tdprint_transport_info(mrioc,\n\t    \"phy control SMP request completed with ioc_status(0x%04x)\\n\",\n\t    ioc_status);\n\n\tif (ioc_status == MPI3_IOCSTATUS_SUCCESS) {\n\t\tdprint_transport_info(mrioc,\n\t\t    \"phy control - reply data transfer size(%d)\\n\",\n\t\t    le16_to_cpu(mpi_reply.response_data_length));\n\n\t\tif (le16_to_cpu(mpi_reply.response_data_length) !=\n\t\t    sizeof(struct phy_control_reply))\n\t\t\tgoto out;\n\t\tdprint_transport_info(mrioc,\n\t\t    \"phy control - function_result(%d)\\n\",\n\t\t    phy_control_reply->function_result);\n\t\trc = 0;\n\t}\n out:\n\tif (data_out)\n\t\tdma_free_coherent(&mrioc->pdev->dev, sz, data_out,\n\t\t    data_out_dma);\n\n\treturn rc;\n}\n\n \nstatic int\nmpi3mr_transport_phy_reset(struct sas_phy *phy, int hard_reset)\n{\n\tstruct mpi3mr_ioc *mrioc = phy_to_mrioc(phy);\n\tstruct mpi3_iounit_control_request mpi_request;\n\tstruct mpi3_iounit_control_reply mpi_reply;\n\tu16 request_sz = sizeof(struct mpi3_iounit_control_request);\n\tu16 reply_sz = sizeof(struct mpi3_iounit_control_reply);\n\tint rc = 0;\n\tu16 ioc_status;\n\n\trc = mpi3mr_parent_present(mrioc, phy);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (phy->identify.sas_address != mrioc->sas_hba.sas_address)\n\t\treturn mpi3mr_expander_phy_control(mrioc, phy,\n\t\t    (hard_reset == 1) ? SMP_PHY_CONTROL_HARD_RESET :\n\t\t    SMP_PHY_CONTROL_LINK_RESET);\n\n\t \n\tmemset(&mpi_request, 0, request_sz);\n\tmpi_request.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_TRANSPORT_CMDS);\n\tmpi_request.function = MPI3_FUNCTION_IO_UNIT_CONTROL;\n\tmpi_request.operation = MPI3_CTRL_OP_SAS_PHY_CONTROL;\n\tmpi_request.param8[MPI3_CTRL_OP_SAS_PHY_CONTROL_PARAM8_ACTION_INDEX] =\n\t\t(hard_reset ? MPI3_CTRL_ACTION_HARD_RESET :\n\t\t MPI3_CTRL_ACTION_LINK_RESET);\n\tmpi_request.param8[MPI3_CTRL_OP_SAS_PHY_CONTROL_PARAM8_PHY_INDEX] =\n\t\tphy->number;\n\n\tdprint_transport_info(mrioc,\n\t    \"sending phy reset request to sas_address(0x%016llx), phy_id(%d) hard_reset(%d)\\n\",\n\t    (unsigned long long)phy->identify.sas_address, phy->number,\n\t    hard_reset);\n\n\tif (mpi3mr_post_transport_req(mrioc, &mpi_request, request_sz,\n\t    &mpi_reply, reply_sz, MPI3MR_INTADMCMD_TIMEOUT, &ioc_status)) {\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tdprint_transport_info(mrioc,\n\t    \"phy reset request completed with ioc_status(0x%04x)\\n\",\n\t    ioc_status);\nout:\n\treturn rc;\n}\n\n \nstatic int\nmpi3mr_transport_phy_enable(struct sas_phy *phy, int enable)\n{\n\tstruct mpi3mr_ioc *mrioc = phy_to_mrioc(phy);\n\tstruct mpi3_sas_io_unit_page0 *sas_io_unit_pg0 = NULL;\n\tstruct mpi3_sas_io_unit_page1 *sas_io_unit_pg1 = NULL;\n\tu16 sz;\n\tint rc = 0;\n\tint i, discovery_active;\n\n\trc = mpi3mr_parent_present(mrioc, phy);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (phy->identify.sas_address != mrioc->sas_hba.sas_address)\n\t\treturn mpi3mr_expander_phy_control(mrioc, phy,\n\t\t    (enable == 1) ? SMP_PHY_CONTROL_LINK_RESET :\n\t\t    SMP_PHY_CONTROL_DISABLE);\n\n\t \n\tsz = offsetof(struct mpi3_sas_io_unit_page0, phy_data) +\n\t\t(mrioc->sas_hba.num_phys *\n\t\t sizeof(struct mpi3_sas_io_unit0_phy_data));\n\tsas_io_unit_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_io_unit_pg0) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (mpi3mr_cfg_get_sas_io_unit_pg0(mrioc, sas_io_unit_pg0, sz)) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\trc = -ENXIO;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0, discovery_active = 0; i < mrioc->sas_hba.num_phys ; i++) {\n\t\tif (sas_io_unit_pg0->phy_data[i].port_flags &\n\t\t    MPI3_SASIOUNIT0_PORTFLAGS_DISC_IN_PROGRESS) {\n\t\t\tioc_err(mrioc,\n\t\t\t    \"discovery is active on port = %d, phy = %d\\n\"\n\t\t\t    \"\\tunable to enable/disable phys, try again later!\\n\",\n\t\t\t    sas_io_unit_pg0->phy_data[i].io_unit_port, i);\n\t\t\tdiscovery_active = 1;\n\t\t}\n\t}\n\n\tif (discovery_active) {\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif ((sas_io_unit_pg0->phy_data[phy->number].phy_flags &\n\t     (MPI3_SASIOUNIT0_PHYFLAGS_HOST_PHY |\n\t      MPI3_SASIOUNIT0_PHYFLAGS_VIRTUAL_PHY))) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\trc = -ENXIO;\n\t\tgoto out;\n\t}\n\n\t \n\tsz = offsetof(struct mpi3_sas_io_unit_page1, phy_data) +\n\t\t(mrioc->sas_hba.num_phys *\n\t\t sizeof(struct mpi3_sas_io_unit1_phy_data));\n\tsas_io_unit_pg1 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_io_unit_pg1) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (mpi3mr_cfg_get_sas_io_unit_pg1(mrioc, sas_io_unit_pg1, sz)) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\trc = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tif (enable)\n\t\tsas_io_unit_pg1->phy_data[phy->number].phy_flags\n\t\t    &= ~MPI3_SASIOUNIT1_PHYFLAGS_PHY_DISABLE;\n\telse\n\t\tsas_io_unit_pg1->phy_data[phy->number].phy_flags\n\t\t    |= MPI3_SASIOUNIT1_PHYFLAGS_PHY_DISABLE;\n\n\tmpi3mr_cfg_set_sas_io_unit_pg1(mrioc, sas_io_unit_pg1, sz);\n\n\t \n\tif (enable)\n\t\tmpi3mr_transport_phy_reset(phy, 0);\n\n out:\n\tkfree(sas_io_unit_pg1);\n\tkfree(sas_io_unit_pg0);\n\treturn rc;\n}\n\n \nstatic int\nmpi3mr_transport_phy_speed(struct sas_phy *phy, struct sas_phy_linkrates *rates)\n{\n\tstruct mpi3mr_ioc *mrioc = phy_to_mrioc(phy);\n\tstruct mpi3_sas_io_unit_page1 *sas_io_unit_pg1 = NULL;\n\tstruct mpi3_sas_phy_page0 phy_pg0;\n\tu16 sz, ioc_status;\n\tint rc = 0;\n\n\trc = mpi3mr_parent_present(mrioc, phy);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!rates->minimum_linkrate)\n\t\trates->minimum_linkrate = phy->minimum_linkrate;\n\telse if (rates->minimum_linkrate < phy->minimum_linkrate_hw)\n\t\trates->minimum_linkrate = phy->minimum_linkrate_hw;\n\n\tif (!rates->maximum_linkrate)\n\t\trates->maximum_linkrate = phy->maximum_linkrate;\n\telse if (rates->maximum_linkrate > phy->maximum_linkrate_hw)\n\t\trates->maximum_linkrate = phy->maximum_linkrate_hw;\n\n\t \n\tif (phy->identify.sas_address != mrioc->sas_hba.sas_address) {\n\t\tphy->minimum_linkrate = rates->minimum_linkrate;\n\t\tphy->maximum_linkrate = rates->maximum_linkrate;\n\t\treturn mpi3mr_expander_phy_control(mrioc, phy,\n\t\t    SMP_PHY_CONTROL_LINK_RESET);\n\t}\n\n\t \n\tsz = offsetof(struct mpi3_sas_io_unit_page1, phy_data) +\n\t\t(mrioc->sas_hba.num_phys *\n\t\t sizeof(struct mpi3_sas_io_unit1_phy_data));\n\tsas_io_unit_pg1 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_io_unit_pg1) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (mpi3mr_cfg_get_sas_io_unit_pg1(mrioc, sas_io_unit_pg1, sz)) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\trc = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tsas_io_unit_pg1->phy_data[phy->number].max_min_link_rate =\n\t\t(rates->minimum_linkrate + (rates->maximum_linkrate << 4));\n\n\tif (mpi3mr_cfg_set_sas_io_unit_pg1(mrioc, sas_io_unit_pg1, sz)) {\n\t\tioc_err(mrioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\trc = -ENXIO;\n\t\tgoto out;\n\t}\n\n\t \n\tmpi3mr_transport_phy_reset(phy, 0);\n\n\t \n\tif (!mpi3mr_cfg_get_sas_phy_pg0(mrioc, &ioc_status, &phy_pg0,\n\t    sizeof(struct mpi3_sas_phy_page0),\n\t    MPI3_SAS_PHY_PGAD_FORM_PHY_NUMBER, phy->number) &&\n\t    (ioc_status == MPI3_IOCSTATUS_SUCCESS)) {\n\t\tphy->minimum_linkrate = mpi3mr_convert_phy_link_rate(\n\t\t    phy_pg0.programmed_link_rate &\n\t\t    MPI3_SAS_PRATE_MIN_RATE_MASK);\n\t\tphy->maximum_linkrate = mpi3mr_convert_phy_link_rate(\n\t\t    phy_pg0.programmed_link_rate >> 4);\n\t\tphy->negotiated_linkrate =\n\t\t\tmpi3mr_convert_phy_link_rate(\n\t\t\t    (phy_pg0.negotiated_link_rate &\n\t\t\t    MPI3_SAS_NEG_LINK_RATE_LOGICAL_MASK)\n\t\t\t    >> MPI3_SAS_NEG_LINK_RATE_LOGICAL_SHIFT);\n\t}\n\nout:\n\tkfree(sas_io_unit_pg1);\n\treturn rc;\n}\n\n \nstatic int\nmpi3mr_map_smp_buffer(struct device *dev, struct bsg_buffer *buf,\n\t\tdma_addr_t *dma_addr, size_t *dma_len, void **p)\n{\n\t \n\tif (buf->sg_cnt > 1) {\n\t\t*p = dma_alloc_coherent(dev, buf->payload_len, dma_addr,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!*p)\n\t\t\treturn -ENOMEM;\n\t\t*dma_len = buf->payload_len;\n\t} else {\n\t\tif (!dma_map_sg(dev, buf->sg_list, 1, DMA_BIDIRECTIONAL))\n\t\t\treturn -ENOMEM;\n\t\t*dma_addr = sg_dma_address(buf->sg_list);\n\t\t*dma_len = sg_dma_len(buf->sg_list);\n\t\t*p = NULL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nmpi3mr_unmap_smp_buffer(struct device *dev, struct bsg_buffer *buf,\n\t\tdma_addr_t dma_addr, void *p)\n{\n\tif (p)\n\t\tdma_free_coherent(dev, buf->payload_len, p, dma_addr);\n\telse\n\t\tdma_unmap_sg(dev, buf->sg_list, 1, DMA_BIDIRECTIONAL);\n}\n\n \nstatic void\nmpi3mr_transport_smp_handler(struct bsg_job *job, struct Scsi_Host *shost,\n\tstruct sas_rphy *rphy)\n{\n\tstruct mpi3mr_ioc *mrioc = shost_priv(shost);\n\tstruct mpi3_smp_passthrough_request mpi_request;\n\tstruct mpi3_smp_passthrough_reply mpi_reply;\n\tint rc;\n\tvoid *psge;\n\tdma_addr_t dma_addr_in;\n\tdma_addr_t dma_addr_out;\n\tvoid *addr_in = NULL;\n\tvoid *addr_out = NULL;\n\tsize_t dma_len_in;\n\tsize_t dma_len_out;\n\tunsigned int reslen = 0;\n\tu16 request_sz = sizeof(struct mpi3_smp_passthrough_request);\n\tu16 reply_sz = sizeof(struct mpi3_smp_passthrough_reply);\n\tu8 sgl_flags = MPI3MR_SGEFLAGS_SYSTEM_SIMPLE_END_OF_LIST;\n\tu16 ioc_status;\n\n\tif (mrioc->reset_in_progress) {\n\t\tioc_err(mrioc, \"%s: host reset in progress!\\n\", __func__);\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\trc = mpi3mr_map_smp_buffer(&mrioc->pdev->dev, &job->request_payload,\n\t    &dma_addr_out, &dma_len_out, &addr_out);\n\tif (rc)\n\t\tgoto out;\n\n\tif (addr_out)\n\t\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\t    job->request_payload.sg_cnt, addr_out,\n\t\t    job->request_payload.payload_len);\n\n\trc = mpi3mr_map_smp_buffer(&mrioc->pdev->dev, &job->reply_payload,\n\t\t\t&dma_addr_in, &dma_len_in, &addr_in);\n\tif (rc)\n\t\tgoto unmap_out;\n\n\tmemset(&mpi_request, 0, request_sz);\n\tmemset(&mpi_reply, 0, reply_sz);\n\tmpi_request.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_TRANSPORT_CMDS);\n\tmpi_request.function = MPI3_FUNCTION_SMP_PASSTHROUGH;\n\tmpi_request.io_unit_port = (u8) mpi3mr_get_port_id_by_rphy(mrioc, rphy);\n\tmpi_request.sas_address = ((rphy) ?\n\t    cpu_to_le64(rphy->identify.sas_address) :\n\t    cpu_to_le64(mrioc->sas_hba.sas_address));\n\tpsge = &mpi_request.request_sge;\n\tmpi3mr_add_sg_single(psge, sgl_flags, dma_len_out - 4, dma_addr_out);\n\n\tpsge = &mpi_request.response_sge;\n\tmpi3mr_add_sg_single(psge, sgl_flags, dma_len_in - 4, dma_addr_in);\n\n\tdprint_transport_info(mrioc, \"sending SMP request\\n\");\n\n\trc = mpi3mr_post_transport_req(mrioc, &mpi_request, request_sz,\n\t\t\t\t       &mpi_reply, reply_sz,\n\t\t\t\t       MPI3MR_INTADMCMD_TIMEOUT, &ioc_status);\n\tif (rc)\n\t\tgoto unmap_in;\n\n\tdprint_transport_info(mrioc,\n\t    \"SMP request completed with ioc_status(0x%04x)\\n\", ioc_status);\n\n\tdprint_transport_info(mrioc,\n\t\t    \"SMP request - reply data transfer size(%d)\\n\",\n\t\t    le16_to_cpu(mpi_reply.response_data_length));\n\n\tmemcpy(job->reply, &mpi_reply, reply_sz);\n\tjob->reply_len = reply_sz;\n\treslen = le16_to_cpu(mpi_reply.response_data_length);\n\n\tif (addr_in)\n\t\tsg_copy_from_buffer(job->reply_payload.sg_list,\n\t\t\t\tjob->reply_payload.sg_cnt, addr_in,\n\t\t\t\tjob->reply_payload.payload_len);\n\n\trc = 0;\nunmap_in:\n\tmpi3mr_unmap_smp_buffer(&mrioc->pdev->dev, &job->reply_payload,\n\t\t\tdma_addr_in, addr_in);\nunmap_out:\n\tmpi3mr_unmap_smp_buffer(&mrioc->pdev->dev, &job->request_payload,\n\t\t\tdma_addr_out, addr_out);\nout:\n\tbsg_job_done(job, rc, reslen);\n}\n\nstruct sas_function_template mpi3mr_transport_functions = {\n\t.get_linkerrors\t\t= mpi3mr_transport_get_linkerrors,\n\t.get_enclosure_identifier = mpi3mr_transport_get_enclosure_identifier,\n\t.get_bay_identifier\t= mpi3mr_transport_get_bay_identifier,\n\t.phy_reset\t\t= mpi3mr_transport_phy_reset,\n\t.phy_enable\t\t= mpi3mr_transport_phy_enable,\n\t.set_phy_speed\t\t= mpi3mr_transport_phy_speed,\n\t.smp_handler\t\t= mpi3mr_transport_smp_handler,\n};\n\nstruct scsi_transport_template *mpi3mr_transport_template;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}