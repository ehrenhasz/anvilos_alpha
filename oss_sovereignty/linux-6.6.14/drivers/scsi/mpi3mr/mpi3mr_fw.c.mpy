{
  "module_name": "mpi3mr_fw.c",
  "hash_id": "147ac27a92e0e73f8adffd64f53d964cf1702f8bc3cd1eeca700a7559643382c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mpi3mr/mpi3mr_fw.c",
  "human_readable_source": "\n \n\n#include \"mpi3mr.h\"\n#include <linux/io-64-nonatomic-lo-hi.h>\n\nstatic int\nmpi3mr_issue_reset(struct mpi3mr_ioc *mrioc, u16 reset_type, u32 reset_reason);\nstatic int mpi3mr_setup_admin_qpair(struct mpi3mr_ioc *mrioc);\nstatic void mpi3mr_process_factsdata(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_ioc_facts_data *facts_data);\nstatic void mpi3mr_pel_wait_complete(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_drv_cmd *drv_cmd);\n\nstatic int poll_queues;\nmodule_param(poll_queues, int, 0444);\nMODULE_PARM_DESC(poll_queues, \"Number of queues for io_uring poll mode. (Range 1 - 126)\");\n\n#if defined(writeq) && defined(CONFIG_64BIT)\nstatic inline void mpi3mr_writeq(__u64 b, volatile void __iomem *addr)\n{\n\twriteq(b, addr);\n}\n#else\nstatic inline void mpi3mr_writeq(__u64 b, volatile void __iomem *addr)\n{\n\t__u64 data_out = b;\n\n\twritel((u32)(data_out), addr);\n\twritel((u32)(data_out >> 32), (addr + 4));\n}\n#endif\n\nstatic inline bool\nmpi3mr_check_req_qfull(struct op_req_qinfo *op_req_q)\n{\n\tu16 pi, ci, max_entries;\n\tbool is_qfull = false;\n\n\tpi = op_req_q->pi;\n\tci = READ_ONCE(op_req_q->ci);\n\tmax_entries = op_req_q->num_requests;\n\n\tif ((ci == (pi + 1)) || ((!ci) && (pi == (max_entries - 1))))\n\t\tis_qfull = true;\n\n\treturn is_qfull;\n}\n\nstatic void mpi3mr_sync_irqs(struct mpi3mr_ioc *mrioc)\n{\n\tu16 i, max_vectors;\n\n\tmax_vectors = mrioc->intr_info_count;\n\n\tfor (i = 0; i < max_vectors; i++)\n\t\tsynchronize_irq(pci_irq_vector(mrioc->pdev, i));\n}\n\nvoid mpi3mr_ioc_disable_intr(struct mpi3mr_ioc *mrioc)\n{\n\tmrioc->intr_enabled = 0;\n\tmpi3mr_sync_irqs(mrioc);\n}\n\nvoid mpi3mr_ioc_enable_intr(struct mpi3mr_ioc *mrioc)\n{\n\tmrioc->intr_enabled = 1;\n}\n\nstatic void mpi3mr_cleanup_isr(struct mpi3mr_ioc *mrioc)\n{\n\tu16 i;\n\n\tmpi3mr_ioc_disable_intr(mrioc);\n\n\tif (!mrioc->intr_info)\n\t\treturn;\n\n\tfor (i = 0; i < mrioc->intr_info_count; i++)\n\t\tfree_irq(pci_irq_vector(mrioc->pdev, i),\n\t\t    (mrioc->intr_info + i));\n\n\tkfree(mrioc->intr_info);\n\tmrioc->intr_info = NULL;\n\tmrioc->intr_info_count = 0;\n\tmrioc->is_intr_info_set = false;\n\tpci_free_irq_vectors(mrioc->pdev);\n}\n\nvoid mpi3mr_add_sg_single(void *paddr, u8 flags, u32 length,\n\tdma_addr_t dma_addr)\n{\n\tstruct mpi3_sge_common *sgel = paddr;\n\n\tsgel->flags = flags;\n\tsgel->length = cpu_to_le32(length);\n\tsgel->address = cpu_to_le64(dma_addr);\n}\n\nvoid mpi3mr_build_zero_len_sge(void *paddr)\n{\n\tu8 sgl_flags = MPI3MR_SGEFLAGS_SYSTEM_SIMPLE_END_OF_LIST;\n\n\tmpi3mr_add_sg_single(paddr, sgl_flags, 0, -1);\n}\n\nvoid *mpi3mr_get_reply_virt_addr(struct mpi3mr_ioc *mrioc,\n\tdma_addr_t phys_addr)\n{\n\tif (!phys_addr)\n\t\treturn NULL;\n\n\tif ((phys_addr < mrioc->reply_buf_dma) ||\n\t    (phys_addr > mrioc->reply_buf_dma_max_address))\n\t\treturn NULL;\n\n\treturn mrioc->reply_buf + (phys_addr - mrioc->reply_buf_dma);\n}\n\nvoid *mpi3mr_get_sensebuf_virt_addr(struct mpi3mr_ioc *mrioc,\n\tdma_addr_t phys_addr)\n{\n\tif (!phys_addr)\n\t\treturn NULL;\n\n\treturn mrioc->sense_buf + (phys_addr - mrioc->sense_buf_dma);\n}\n\nstatic void mpi3mr_repost_reply_buf(struct mpi3mr_ioc *mrioc,\n\tu64 reply_dma)\n{\n\tu32 old_idx = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mrioc->reply_free_queue_lock, flags);\n\told_idx  =  mrioc->reply_free_queue_host_index;\n\tmrioc->reply_free_queue_host_index = (\n\t    (mrioc->reply_free_queue_host_index ==\n\t    (mrioc->reply_free_qsz - 1)) ? 0 :\n\t    (mrioc->reply_free_queue_host_index + 1));\n\tmrioc->reply_free_q[old_idx] = cpu_to_le64(reply_dma);\n\twritel(mrioc->reply_free_queue_host_index,\n\t    &mrioc->sysif_regs->reply_free_host_index);\n\tspin_unlock_irqrestore(&mrioc->reply_free_queue_lock, flags);\n}\n\nvoid mpi3mr_repost_sense_buf(struct mpi3mr_ioc *mrioc,\n\tu64 sense_buf_dma)\n{\n\tu32 old_idx = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mrioc->sbq_lock, flags);\n\told_idx  =  mrioc->sbq_host_index;\n\tmrioc->sbq_host_index = ((mrioc->sbq_host_index ==\n\t    (mrioc->sense_buf_q_sz - 1)) ? 0 :\n\t    (mrioc->sbq_host_index + 1));\n\tmrioc->sense_buf_q[old_idx] = cpu_to_le64(sense_buf_dma);\n\twritel(mrioc->sbq_host_index,\n\t    &mrioc->sysif_regs->sense_buffer_free_host_index);\n\tspin_unlock_irqrestore(&mrioc->sbq_lock, flags);\n}\n\nstatic void mpi3mr_print_event_data(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_event_notification_reply *event_reply)\n{\n\tchar *desc = NULL;\n\tu16 event;\n\n\tevent = event_reply->event;\n\n\tswitch (event) {\n\tcase MPI3_EVENT_LOG_DATA:\n\t\tdesc = \"Log Data\";\n\t\tbreak;\n\tcase MPI3_EVENT_CHANGE:\n\t\tdesc = \"Event Change\";\n\t\tbreak;\n\tcase MPI3_EVENT_GPIO_INTERRUPT:\n\t\tdesc = \"GPIO Interrupt\";\n\t\tbreak;\n\tcase MPI3_EVENT_CABLE_MGMT:\n\t\tdesc = \"Cable Management\";\n\t\tbreak;\n\tcase MPI3_EVENT_ENERGY_PACK_CHANGE:\n\t\tdesc = \"Energy Pack Change\";\n\t\tbreak;\n\tcase MPI3_EVENT_DEVICE_ADDED:\n\t{\n\t\tstruct mpi3_device_page0 *event_data =\n\t\t    (struct mpi3_device_page0 *)event_reply->event_data;\n\t\tioc_info(mrioc, \"Device Added: dev=0x%04x Form=0x%x\\n\",\n\t\t    event_data->dev_handle, event_data->device_form);\n\t\treturn;\n\t}\n\tcase MPI3_EVENT_DEVICE_INFO_CHANGED:\n\t{\n\t\tstruct mpi3_device_page0 *event_data =\n\t\t    (struct mpi3_device_page0 *)event_reply->event_data;\n\t\tioc_info(mrioc, \"Device Info Changed: dev=0x%04x Form=0x%x\\n\",\n\t\t    event_data->dev_handle, event_data->device_form);\n\t\treturn;\n\t}\n\tcase MPI3_EVENT_DEVICE_STATUS_CHANGE:\n\t{\n\t\tstruct mpi3_event_data_device_status_change *event_data =\n\t\t    (struct mpi3_event_data_device_status_change *)event_reply->event_data;\n\t\tioc_info(mrioc, \"Device status Change: dev=0x%04x RC=0x%x\\n\",\n\t\t    event_data->dev_handle, event_data->reason_code);\n\t\treturn;\n\t}\n\tcase MPI3_EVENT_SAS_DISCOVERY:\n\t{\n\t\tstruct mpi3_event_data_sas_discovery *event_data =\n\t\t    (struct mpi3_event_data_sas_discovery *)event_reply->event_data;\n\t\tioc_info(mrioc, \"SAS Discovery: (%s) status (0x%08x)\\n\",\n\t\t    (event_data->reason_code == MPI3_EVENT_SAS_DISC_RC_STARTED) ?\n\t\t    \"start\" : \"stop\",\n\t\t    le32_to_cpu(event_data->discovery_status));\n\t\treturn;\n\t}\n\tcase MPI3_EVENT_SAS_BROADCAST_PRIMITIVE:\n\t\tdesc = \"SAS Broadcast Primitive\";\n\t\tbreak;\n\tcase MPI3_EVENT_SAS_NOTIFY_PRIMITIVE:\n\t\tdesc = \"SAS Notify Primitive\";\n\t\tbreak;\n\tcase MPI3_EVENT_SAS_INIT_DEVICE_STATUS_CHANGE:\n\t\tdesc = \"SAS Init Device Status Change\";\n\t\tbreak;\n\tcase MPI3_EVENT_SAS_INIT_TABLE_OVERFLOW:\n\t\tdesc = \"SAS Init Table Overflow\";\n\t\tbreak;\n\tcase MPI3_EVENT_SAS_TOPOLOGY_CHANGE_LIST:\n\t\tdesc = \"SAS Topology Change List\";\n\t\tbreak;\n\tcase MPI3_EVENT_ENCL_DEVICE_STATUS_CHANGE:\n\t\tdesc = \"Enclosure Device Status Change\";\n\t\tbreak;\n\tcase MPI3_EVENT_ENCL_DEVICE_ADDED:\n\t\tdesc = \"Enclosure Added\";\n\t\tbreak;\n\tcase MPI3_EVENT_HARD_RESET_RECEIVED:\n\t\tdesc = \"Hard Reset Received\";\n\t\tbreak;\n\tcase MPI3_EVENT_SAS_PHY_COUNTER:\n\t\tdesc = \"SAS PHY Counter\";\n\t\tbreak;\n\tcase MPI3_EVENT_SAS_DEVICE_DISCOVERY_ERROR:\n\t\tdesc = \"SAS Device Discovery Error\";\n\t\tbreak;\n\tcase MPI3_EVENT_PCIE_TOPOLOGY_CHANGE_LIST:\n\t\tdesc = \"PCIE Topology Change List\";\n\t\tbreak;\n\tcase MPI3_EVENT_PCIE_ENUMERATION:\n\t{\n\t\tstruct mpi3_event_data_pcie_enumeration *event_data =\n\t\t    (struct mpi3_event_data_pcie_enumeration *)event_reply->event_data;\n\t\tioc_info(mrioc, \"PCIE Enumeration: (%s)\",\n\t\t    (event_data->reason_code ==\n\t\t    MPI3_EVENT_PCIE_ENUM_RC_STARTED) ? \"start\" : \"stop\");\n\t\tif (event_data->enumeration_status)\n\t\t\tioc_info(mrioc, \"enumeration_status(0x%08x)\\n\",\n\t\t\t    le32_to_cpu(event_data->enumeration_status));\n\t\treturn;\n\t}\n\tcase MPI3_EVENT_PREPARE_FOR_RESET:\n\t\tdesc = \"Prepare For Reset\";\n\t\tbreak;\n\t}\n\n\tif (!desc)\n\t\treturn;\n\n\tioc_info(mrioc, \"%s\\n\", desc);\n}\n\nstatic void mpi3mr_handle_events(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_default_reply *def_reply)\n{\n\tstruct mpi3_event_notification_reply *event_reply =\n\t    (struct mpi3_event_notification_reply *)def_reply;\n\n\tmrioc->change_count = le16_to_cpu(event_reply->ioc_change_count);\n\tmpi3mr_print_event_data(mrioc, event_reply);\n\tmpi3mr_os_handle_events(mrioc, event_reply);\n}\n\nstatic struct mpi3mr_drv_cmd *\nmpi3mr_get_drv_cmd(struct mpi3mr_ioc *mrioc, u16 host_tag,\n\tstruct mpi3_default_reply *def_reply)\n{\n\tu16 idx;\n\n\tswitch (host_tag) {\n\tcase MPI3MR_HOSTTAG_INITCMDS:\n\t\treturn &mrioc->init_cmds;\n\tcase MPI3MR_HOSTTAG_CFG_CMDS:\n\t\treturn &mrioc->cfg_cmds;\n\tcase MPI3MR_HOSTTAG_BSG_CMDS:\n\t\treturn &mrioc->bsg_cmds;\n\tcase MPI3MR_HOSTTAG_BLK_TMS:\n\t\treturn &mrioc->host_tm_cmds;\n\tcase MPI3MR_HOSTTAG_PEL_ABORT:\n\t\treturn &mrioc->pel_abort_cmd;\n\tcase MPI3MR_HOSTTAG_PEL_WAIT:\n\t\treturn &mrioc->pel_cmds;\n\tcase MPI3MR_HOSTTAG_TRANSPORT_CMDS:\n\t\treturn &mrioc->transport_cmds;\n\tcase MPI3MR_HOSTTAG_INVALID:\n\t\tif (def_reply && def_reply->function ==\n\t\t    MPI3_FUNCTION_EVENT_NOTIFICATION)\n\t\t\tmpi3mr_handle_events(mrioc, def_reply);\n\t\treturn NULL;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (host_tag >= MPI3MR_HOSTTAG_DEVRMCMD_MIN &&\n\t    host_tag <= MPI3MR_HOSTTAG_DEVRMCMD_MAX) {\n\t\tidx = host_tag - MPI3MR_HOSTTAG_DEVRMCMD_MIN;\n\t\treturn &mrioc->dev_rmhs_cmds[idx];\n\t}\n\n\tif (host_tag >= MPI3MR_HOSTTAG_EVTACKCMD_MIN &&\n\t    host_tag <= MPI3MR_HOSTTAG_EVTACKCMD_MAX) {\n\t\tidx = host_tag - MPI3MR_HOSTTAG_EVTACKCMD_MIN;\n\t\treturn &mrioc->evtack_cmds[idx];\n\t}\n\n\treturn NULL;\n}\n\nstatic void mpi3mr_process_admin_reply_desc(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_default_reply_descriptor *reply_desc, u64 *reply_dma)\n{\n\tu16 reply_desc_type, host_tag = 0;\n\tu16 ioc_status = MPI3_IOCSTATUS_SUCCESS;\n\tu32 ioc_loginfo = 0;\n\tstruct mpi3_status_reply_descriptor *status_desc;\n\tstruct mpi3_address_reply_descriptor *addr_desc;\n\tstruct mpi3_success_reply_descriptor *success_desc;\n\tstruct mpi3_default_reply *def_reply = NULL;\n\tstruct mpi3mr_drv_cmd *cmdptr = NULL;\n\tstruct mpi3_scsi_io_reply *scsi_reply;\n\tu8 *sense_buf = NULL;\n\n\t*reply_dma = 0;\n\treply_desc_type = le16_to_cpu(reply_desc->reply_flags) &\n\t    MPI3_REPLY_DESCRIPT_FLAGS_TYPE_MASK;\n\tswitch (reply_desc_type) {\n\tcase MPI3_REPLY_DESCRIPT_FLAGS_TYPE_STATUS:\n\t\tstatus_desc = (struct mpi3_status_reply_descriptor *)reply_desc;\n\t\thost_tag = le16_to_cpu(status_desc->host_tag);\n\t\tioc_status = le16_to_cpu(status_desc->ioc_status);\n\t\tif (ioc_status &\n\t\t    MPI3_REPLY_DESCRIPT_STATUS_IOCSTATUS_LOGINFOAVAIL)\n\t\t\tioc_loginfo = le32_to_cpu(status_desc->ioc_log_info);\n\t\tioc_status &= MPI3_REPLY_DESCRIPT_STATUS_IOCSTATUS_STATUS_MASK;\n\t\tbreak;\n\tcase MPI3_REPLY_DESCRIPT_FLAGS_TYPE_ADDRESS_REPLY:\n\t\taddr_desc = (struct mpi3_address_reply_descriptor *)reply_desc;\n\t\t*reply_dma = le64_to_cpu(addr_desc->reply_frame_address);\n\t\tdef_reply = mpi3mr_get_reply_virt_addr(mrioc, *reply_dma);\n\t\tif (!def_reply)\n\t\t\tgoto out;\n\t\thost_tag = le16_to_cpu(def_reply->host_tag);\n\t\tioc_status = le16_to_cpu(def_reply->ioc_status);\n\t\tif (ioc_status &\n\t\t    MPI3_REPLY_DESCRIPT_STATUS_IOCSTATUS_LOGINFOAVAIL)\n\t\t\tioc_loginfo = le32_to_cpu(def_reply->ioc_log_info);\n\t\tioc_status &= MPI3_REPLY_DESCRIPT_STATUS_IOCSTATUS_STATUS_MASK;\n\t\tif (def_reply->function == MPI3_FUNCTION_SCSI_IO) {\n\t\t\tscsi_reply = (struct mpi3_scsi_io_reply *)def_reply;\n\t\t\tsense_buf = mpi3mr_get_sensebuf_virt_addr(mrioc,\n\t\t\t    le64_to_cpu(scsi_reply->sense_data_buffer_address));\n\t\t}\n\t\tbreak;\n\tcase MPI3_REPLY_DESCRIPT_FLAGS_TYPE_SUCCESS:\n\t\tsuccess_desc = (struct mpi3_success_reply_descriptor *)reply_desc;\n\t\thost_tag = le16_to_cpu(success_desc->host_tag);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcmdptr = mpi3mr_get_drv_cmd(mrioc, host_tag, def_reply);\n\tif (cmdptr) {\n\t\tif (cmdptr->state & MPI3MR_CMD_PENDING) {\n\t\t\tcmdptr->state |= MPI3MR_CMD_COMPLETE;\n\t\t\tcmdptr->ioc_loginfo = ioc_loginfo;\n\t\t\tcmdptr->ioc_status = ioc_status;\n\t\t\tcmdptr->state &= ~MPI3MR_CMD_PENDING;\n\t\t\tif (def_reply) {\n\t\t\t\tcmdptr->state |= MPI3MR_CMD_REPLY_VALID;\n\t\t\t\tmemcpy((u8 *)cmdptr->reply, (u8 *)def_reply,\n\t\t\t\t    mrioc->reply_sz);\n\t\t\t}\n\t\t\tif (sense_buf && cmdptr->sensebuf) {\n\t\t\t\tcmdptr->is_sense = 1;\n\t\t\t\tmemcpy(cmdptr->sensebuf, sense_buf,\n\t\t\t\t       MPI3MR_SENSE_BUF_SZ);\n\t\t\t}\n\t\t\tif (cmdptr->is_waiting) {\n\t\t\t\tcomplete(&cmdptr->done);\n\t\t\t\tcmdptr->is_waiting = 0;\n\t\t\t} else if (cmdptr->callback)\n\t\t\t\tcmdptr->callback(mrioc, cmdptr);\n\t\t}\n\t}\nout:\n\tif (sense_buf)\n\t\tmpi3mr_repost_sense_buf(mrioc,\n\t\t    le64_to_cpu(scsi_reply->sense_data_buffer_address));\n}\n\nint mpi3mr_process_admin_reply_q(struct mpi3mr_ioc *mrioc)\n{\n\tu32 exp_phase = mrioc->admin_reply_ephase;\n\tu32 admin_reply_ci = mrioc->admin_reply_ci;\n\tu32 num_admin_replies = 0;\n\tu64 reply_dma = 0;\n\tstruct mpi3_default_reply_descriptor *reply_desc;\n\n\tif (!atomic_add_unless(&mrioc->admin_reply_q_in_use, 1, 1))\n\t\treturn 0;\n\n\treply_desc = (struct mpi3_default_reply_descriptor *)mrioc->admin_reply_base +\n\t    admin_reply_ci;\n\n\tif ((le16_to_cpu(reply_desc->reply_flags) &\n\t    MPI3_REPLY_DESCRIPT_FLAGS_PHASE_MASK) != exp_phase) {\n\t\tatomic_dec(&mrioc->admin_reply_q_in_use);\n\t\treturn 0;\n\t}\n\n\tdo {\n\t\tif (mrioc->unrecoverable)\n\t\t\tbreak;\n\n\t\tmrioc->admin_req_ci = le16_to_cpu(reply_desc->request_queue_ci);\n\t\tmpi3mr_process_admin_reply_desc(mrioc, reply_desc, &reply_dma);\n\t\tif (reply_dma)\n\t\t\tmpi3mr_repost_reply_buf(mrioc, reply_dma);\n\t\tnum_admin_replies++;\n\t\tif (++admin_reply_ci == mrioc->num_admin_replies) {\n\t\t\tadmin_reply_ci = 0;\n\t\t\texp_phase ^= 1;\n\t\t}\n\t\treply_desc =\n\t\t    (struct mpi3_default_reply_descriptor *)mrioc->admin_reply_base +\n\t\t    admin_reply_ci;\n\t\tif ((le16_to_cpu(reply_desc->reply_flags) &\n\t\t    MPI3_REPLY_DESCRIPT_FLAGS_PHASE_MASK) != exp_phase)\n\t\t\tbreak;\n\t} while (1);\n\n\twritel(admin_reply_ci, &mrioc->sysif_regs->admin_reply_queue_ci);\n\tmrioc->admin_reply_ci = admin_reply_ci;\n\tmrioc->admin_reply_ephase = exp_phase;\n\tatomic_dec(&mrioc->admin_reply_q_in_use);\n\n\treturn num_admin_replies;\n}\n\n \nstatic inline struct mpi3_default_reply_descriptor *\nmpi3mr_get_reply_desc(struct op_reply_qinfo *op_reply_q, u32 reply_ci)\n{\n\tvoid *segment_base_addr;\n\tstruct segments *segments = op_reply_q->q_segments;\n\tstruct mpi3_default_reply_descriptor *reply_desc = NULL;\n\n\tsegment_base_addr =\n\t    segments[reply_ci / op_reply_q->segment_qd].segment;\n\treply_desc = (struct mpi3_default_reply_descriptor *)segment_base_addr +\n\t    (reply_ci % op_reply_q->segment_qd);\n\treturn reply_desc;\n}\n\n \nint mpi3mr_process_op_reply_q(struct mpi3mr_ioc *mrioc,\n\tstruct op_reply_qinfo *op_reply_q)\n{\n\tstruct op_req_qinfo *op_req_q;\n\tu32 exp_phase;\n\tu32 reply_ci;\n\tu32 num_op_reply = 0;\n\tu64 reply_dma = 0;\n\tstruct mpi3_default_reply_descriptor *reply_desc;\n\tu16 req_q_idx = 0, reply_qidx;\n\n\treply_qidx = op_reply_q->qid - 1;\n\n\tif (!atomic_add_unless(&op_reply_q->in_use, 1, 1))\n\t\treturn 0;\n\n\texp_phase = op_reply_q->ephase;\n\treply_ci = op_reply_q->ci;\n\n\treply_desc = mpi3mr_get_reply_desc(op_reply_q, reply_ci);\n\tif ((le16_to_cpu(reply_desc->reply_flags) &\n\t    MPI3_REPLY_DESCRIPT_FLAGS_PHASE_MASK) != exp_phase) {\n\t\tatomic_dec(&op_reply_q->in_use);\n\t\treturn 0;\n\t}\n\n\tdo {\n\t\tif (mrioc->unrecoverable)\n\t\t\tbreak;\n\n\t\treq_q_idx = le16_to_cpu(reply_desc->request_queue_id) - 1;\n\t\top_req_q = &mrioc->req_qinfo[req_q_idx];\n\n\t\tWRITE_ONCE(op_req_q->ci, le16_to_cpu(reply_desc->request_queue_ci));\n\t\tmpi3mr_process_op_reply_desc(mrioc, reply_desc, &reply_dma,\n\t\t    reply_qidx);\n\t\tatomic_dec(&op_reply_q->pend_ios);\n\t\tif (reply_dma)\n\t\t\tmpi3mr_repost_reply_buf(mrioc, reply_dma);\n\t\tnum_op_reply++;\n\n\t\tif (++reply_ci == op_reply_q->num_replies) {\n\t\t\treply_ci = 0;\n\t\t\texp_phase ^= 1;\n\t\t}\n\n\t\treply_desc = mpi3mr_get_reply_desc(op_reply_q, reply_ci);\n\n\t\tif ((le16_to_cpu(reply_desc->reply_flags) &\n\t\t    MPI3_REPLY_DESCRIPT_FLAGS_PHASE_MASK) != exp_phase)\n\t\t\tbreak;\n#ifndef CONFIG_PREEMPT_RT\n\t\t \n\t\tif (num_op_reply > mrioc->max_host_ios) {\n\t\t\top_reply_q->enable_irq_poll = true;\n\t\t\tbreak;\n\t\t}\n#endif\n\t} while (1);\n\n\twritel(reply_ci,\n\t    &mrioc->sysif_regs->oper_queue_indexes[reply_qidx].consumer_index);\n\top_reply_q->ci = reply_ci;\n\top_reply_q->ephase = exp_phase;\n\n\tatomic_dec(&op_reply_q->in_use);\n\treturn num_op_reply;\n}\n\n \nint mpi3mr_blk_mq_poll(struct Scsi_Host *shost, unsigned int queue_num)\n{\n\tint num_entries = 0;\n\tstruct mpi3mr_ioc *mrioc;\n\n\tmrioc = (struct mpi3mr_ioc *)shost->hostdata;\n\n\tif ((mrioc->reset_in_progress || mrioc->prepare_for_reset ||\n\t    mrioc->unrecoverable))\n\t\treturn 0;\n\n\tnum_entries = mpi3mr_process_op_reply_q(mrioc,\n\t\t\t&mrioc->op_reply_qinfo[queue_num]);\n\n\treturn num_entries;\n}\n\nstatic irqreturn_t mpi3mr_isr_primary(int irq, void *privdata)\n{\n\tstruct mpi3mr_intr_info *intr_info = privdata;\n\tstruct mpi3mr_ioc *mrioc;\n\tu16 midx;\n\tu32 num_admin_replies = 0, num_op_reply = 0;\n\n\tif (!intr_info)\n\t\treturn IRQ_NONE;\n\n\tmrioc = intr_info->mrioc;\n\n\tif (!mrioc->intr_enabled)\n\t\treturn IRQ_NONE;\n\n\tmidx = intr_info->msix_index;\n\n\tif (!midx)\n\t\tnum_admin_replies = mpi3mr_process_admin_reply_q(mrioc);\n\tif (intr_info->op_reply_q)\n\t\tnum_op_reply = mpi3mr_process_op_reply_q(mrioc,\n\t\t    intr_info->op_reply_q);\n\n\tif (num_admin_replies || num_op_reply)\n\t\treturn IRQ_HANDLED;\n\telse\n\t\treturn IRQ_NONE;\n}\n\n#ifndef CONFIG_PREEMPT_RT\n\nstatic irqreturn_t mpi3mr_isr(int irq, void *privdata)\n{\n\tstruct mpi3mr_intr_info *intr_info = privdata;\n\tint ret;\n\n\tif (!intr_info)\n\t\treturn IRQ_NONE;\n\n\t \n\tret = mpi3mr_isr_primary(irq, privdata);\n\n\t \n\tif (!intr_info->op_reply_q)\n\t\treturn ret;\n\n\tif (!intr_info->op_reply_q->enable_irq_poll ||\n\t    !atomic_read(&intr_info->op_reply_q->pend_ios))\n\t\treturn ret;\n\n\tdisable_irq_nosync(intr_info->os_irq);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\n \nstatic irqreturn_t mpi3mr_isr_poll(int irq, void *privdata)\n{\n\tstruct mpi3mr_intr_info *intr_info = privdata;\n\tstruct mpi3mr_ioc *mrioc;\n\tu16 midx;\n\tu32 num_op_reply = 0;\n\n\tif (!intr_info || !intr_info->op_reply_q)\n\t\treturn IRQ_NONE;\n\n\tmrioc = intr_info->mrioc;\n\tmidx = intr_info->msix_index;\n\n\t \n\tdo {\n\t\tif (!mrioc->intr_enabled || mrioc->unrecoverable)\n\t\t\tbreak;\n\n\t\tif (!midx)\n\t\t\tmpi3mr_process_admin_reply_q(mrioc);\n\t\tif (intr_info->op_reply_q)\n\t\t\tnum_op_reply +=\n\t\t\t    mpi3mr_process_op_reply_q(mrioc,\n\t\t\t\tintr_info->op_reply_q);\n\n\t\tusleep_range(MPI3MR_IRQ_POLL_SLEEP, 10 * MPI3MR_IRQ_POLL_SLEEP);\n\n\t} while (atomic_read(&intr_info->op_reply_q->pend_ios) &&\n\t    (num_op_reply < mrioc->max_host_ios));\n\n\tintr_info->op_reply_q->enable_irq_poll = false;\n\tenable_irq(intr_info->os_irq);\n\n\treturn IRQ_HANDLED;\n}\n\n#endif\n\n \nstatic inline int mpi3mr_request_irq(struct mpi3mr_ioc *mrioc, u16 index)\n{\n\tstruct pci_dev *pdev = mrioc->pdev;\n\tstruct mpi3mr_intr_info *intr_info = mrioc->intr_info + index;\n\tint retval = 0;\n\n\tintr_info->mrioc = mrioc;\n\tintr_info->msix_index = index;\n\tintr_info->op_reply_q = NULL;\n\n\tsnprintf(intr_info->name, MPI3MR_NAME_LENGTH, \"%s%d-msix%d\",\n\t    mrioc->driver_name, mrioc->id, index);\n\n#ifndef CONFIG_PREEMPT_RT\n\tretval = request_threaded_irq(pci_irq_vector(pdev, index), mpi3mr_isr,\n\t    mpi3mr_isr_poll, IRQF_SHARED, intr_info->name, intr_info);\n#else\n\tretval = request_threaded_irq(pci_irq_vector(pdev, index), mpi3mr_isr_primary,\n\t    NULL, IRQF_SHARED, intr_info->name, intr_info);\n#endif\n\tif (retval) {\n\t\tioc_err(mrioc, \"%s: Unable to allocate interrupt %d!\\n\",\n\t\t    intr_info->name, pci_irq_vector(pdev, index));\n\t\treturn retval;\n\t}\n\n\tintr_info->os_irq = pci_irq_vector(pdev, index);\n\treturn retval;\n}\n\nstatic void mpi3mr_calc_poll_queues(struct mpi3mr_ioc *mrioc, u16 max_vectors)\n{\n\tif (!mrioc->requested_poll_qcount)\n\t\treturn;\n\n\t \n\tif (max_vectors > 2 &&\n\t\t(mrioc->requested_poll_qcount < max_vectors - 2)) {\n\t\tioc_info(mrioc,\n\t\t    \"enabled polled queues (%d) msix (%d)\\n\",\n\t\t    mrioc->requested_poll_qcount, max_vectors);\n\t} else {\n\t\tioc_info(mrioc,\n\t\t    \"disabled polled queues (%d) msix (%d) because of no resources for default queue\\n\",\n\t\t    mrioc->requested_poll_qcount, max_vectors);\n\t\tmrioc->requested_poll_qcount = 0;\n\t}\n}\n\n \nstatic int mpi3mr_setup_isr(struct mpi3mr_ioc *mrioc, u8 setup_one)\n{\n\tunsigned int irq_flags = PCI_IRQ_MSIX;\n\tint max_vectors, min_vec;\n\tint retval;\n\tint i;\n\tstruct irq_affinity desc = { .pre_vectors =  1, .post_vectors = 1 };\n\n\tif (mrioc->is_intr_info_set)\n\t\treturn 0;\n\n\tmpi3mr_cleanup_isr(mrioc);\n\n\tif (setup_one || reset_devices) {\n\t\tmax_vectors = 1;\n\t\tretval = pci_alloc_irq_vectors(mrioc->pdev,\n\t\t    1, max_vectors, irq_flags);\n\t\tif (retval < 0) {\n\t\t\tioc_err(mrioc, \"cannot allocate irq vectors, ret %d\\n\",\n\t\t\t    retval);\n\t\t\tgoto out_failed;\n\t\t}\n\t} else {\n\t\tmax_vectors =\n\t\t    min_t(int, mrioc->cpu_count + 1 +\n\t\t\tmrioc->requested_poll_qcount, mrioc->msix_count);\n\n\t\tmpi3mr_calc_poll_queues(mrioc, max_vectors);\n\n\t\tioc_info(mrioc,\n\t\t    \"MSI-X vectors supported: %d, no of cores: %d,\",\n\t\t    mrioc->msix_count, mrioc->cpu_count);\n\t\tioc_info(mrioc,\n\t\t    \"MSI-x vectors requested: %d poll_queues %d\\n\",\n\t\t    max_vectors, mrioc->requested_poll_qcount);\n\n\t\tdesc.post_vectors = mrioc->requested_poll_qcount;\n\t\tmin_vec = desc.pre_vectors + desc.post_vectors;\n\t\tirq_flags |= PCI_IRQ_AFFINITY | PCI_IRQ_ALL_TYPES;\n\n\t\tretval = pci_alloc_irq_vectors_affinity(mrioc->pdev,\n\t\t\tmin_vec, max_vectors, irq_flags, &desc);\n\n\t\tif (retval < 0) {\n\t\t\tioc_err(mrioc, \"cannot allocate irq vectors, ret %d\\n\",\n\t\t\t    retval);\n\t\t\tgoto out_failed;\n\t\t}\n\n\n\t\t \n\t\tif (retval == min_vec)\n\t\t\tmrioc->op_reply_q_offset = 0;\n\t\telse if (retval != (max_vectors)) {\n\t\t\tioc_info(mrioc,\n\t\t\t    \"allocated vectors (%d) are less than configured (%d)\\n\",\n\t\t\t    retval, max_vectors);\n\t\t}\n\n\t\tmax_vectors = retval;\n\t\tmrioc->op_reply_q_offset = (max_vectors > 1) ? 1 : 0;\n\n\t\tmpi3mr_calc_poll_queues(mrioc, max_vectors);\n\n\t}\n\n\tmrioc->intr_info = kzalloc(sizeof(struct mpi3mr_intr_info) * max_vectors,\n\t    GFP_KERNEL);\n\tif (!mrioc->intr_info) {\n\t\tretval = -ENOMEM;\n\t\tpci_free_irq_vectors(mrioc->pdev);\n\t\tgoto out_failed;\n\t}\n\tfor (i = 0; i < max_vectors; i++) {\n\t\tretval = mpi3mr_request_irq(mrioc, i);\n\t\tif (retval) {\n\t\t\tmrioc->intr_info_count = i;\n\t\t\tgoto out_failed;\n\t\t}\n\t}\n\tif (reset_devices || !setup_one)\n\t\tmrioc->is_intr_info_set = true;\n\tmrioc->intr_info_count = max_vectors;\n\tmpi3mr_ioc_enable_intr(mrioc);\n\treturn 0;\n\nout_failed:\n\tmpi3mr_cleanup_isr(mrioc);\n\n\treturn retval;\n}\n\nstatic const struct {\n\tenum mpi3mr_iocstate value;\n\tchar *name;\n} mrioc_states[] = {\n\t{ MRIOC_STATE_READY, \"ready\" },\n\t{ MRIOC_STATE_FAULT, \"fault\" },\n\t{ MRIOC_STATE_RESET, \"reset\" },\n\t{ MRIOC_STATE_BECOMING_READY, \"becoming ready\" },\n\t{ MRIOC_STATE_RESET_REQUESTED, \"reset requested\" },\n\t{ MRIOC_STATE_UNRECOVERABLE, \"unrecoverable error\" },\n};\n\nstatic const char *mpi3mr_iocstate_name(enum mpi3mr_iocstate mrioc_state)\n{\n\tint i;\n\tchar *name = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(mrioc_states); i++) {\n\t\tif (mrioc_states[i].value == mrioc_state) {\n\t\t\tname = mrioc_states[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn name;\n}\n\n \nstatic const struct {\n\tenum mpi3mr_reset_reason value;\n\tchar *name;\n} mpi3mr_reset_reason_codes[] = {\n\t{ MPI3MR_RESET_FROM_BRINGUP, \"timeout in bringup\" },\n\t{ MPI3MR_RESET_FROM_FAULT_WATCH, \"fault\" },\n\t{ MPI3MR_RESET_FROM_APP, \"application invocation\" },\n\t{ MPI3MR_RESET_FROM_EH_HOS, \"error handling\" },\n\t{ MPI3MR_RESET_FROM_TM_TIMEOUT, \"TM timeout\" },\n\t{ MPI3MR_RESET_FROM_APP_TIMEOUT, \"application command timeout\" },\n\t{ MPI3MR_RESET_FROM_MUR_FAILURE, \"MUR failure\" },\n\t{ MPI3MR_RESET_FROM_CTLR_CLEANUP, \"timeout in controller cleanup\" },\n\t{ MPI3MR_RESET_FROM_CIACTIV_FAULT, \"component image activation fault\" },\n\t{ MPI3MR_RESET_FROM_PE_TIMEOUT, \"port enable timeout\" },\n\t{ MPI3MR_RESET_FROM_TSU_TIMEOUT, \"time stamp update timeout\" },\n\t{ MPI3MR_RESET_FROM_DELREQQ_TIMEOUT, \"delete request queue timeout\" },\n\t{ MPI3MR_RESET_FROM_DELREPQ_TIMEOUT, \"delete reply queue timeout\" },\n\t{\n\t\tMPI3MR_RESET_FROM_CREATEREPQ_TIMEOUT,\n\t\t\"create request queue timeout\"\n\t},\n\t{\n\t\tMPI3MR_RESET_FROM_CREATEREQQ_TIMEOUT,\n\t\t\"create reply queue timeout\"\n\t},\n\t{ MPI3MR_RESET_FROM_IOCFACTS_TIMEOUT, \"IOC facts timeout\" },\n\t{ MPI3MR_RESET_FROM_IOCINIT_TIMEOUT, \"IOC init timeout\" },\n\t{ MPI3MR_RESET_FROM_EVTNOTIFY_TIMEOUT, \"event notify timeout\" },\n\t{ MPI3MR_RESET_FROM_EVTACK_TIMEOUT, \"event acknowledgment timeout\" },\n\t{\n\t\tMPI3MR_RESET_FROM_CIACTVRST_TIMER,\n\t\t\"component image activation timeout\"\n\t},\n\t{\n\t\tMPI3MR_RESET_FROM_GETPKGVER_TIMEOUT,\n\t\t\"get package version timeout\"\n\t},\n\t{ MPI3MR_RESET_FROM_SYSFS, \"sysfs invocation\" },\n\t{ MPI3MR_RESET_FROM_SYSFS_TIMEOUT, \"sysfs TM timeout\" },\n\t{ MPI3MR_RESET_FROM_FIRMWARE, \"firmware asynchronous reset\" },\n\t{ MPI3MR_RESET_FROM_CFG_REQ_TIMEOUT, \"configuration request timeout\"},\n\t{ MPI3MR_RESET_FROM_SAS_TRANSPORT_TIMEOUT, \"timeout of a SAS transport layer request\" },\n};\n\n \nstatic const char *mpi3mr_reset_rc_name(enum mpi3mr_reset_reason reason_code)\n{\n\tint i;\n\tchar *name = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(mpi3mr_reset_reason_codes); i++) {\n\t\tif (mpi3mr_reset_reason_codes[i].value == reason_code) {\n\t\t\tname = mpi3mr_reset_reason_codes[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn name;\n}\n\n \nstatic const struct {\n\tu16 reset_type;\n\tchar *name;\n} mpi3mr_reset_types[] = {\n\t{ MPI3_SYSIF_HOST_DIAG_RESET_ACTION_SOFT_RESET, \"soft\" },\n\t{ MPI3_SYSIF_HOST_DIAG_RESET_ACTION_DIAG_FAULT, \"diag fault\" },\n};\n\n \nstatic const char *mpi3mr_reset_type_name(u16 reset_type)\n{\n\tint i;\n\tchar *name = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(mpi3mr_reset_types); i++) {\n\t\tif (mpi3mr_reset_types[i].reset_type == reset_type) {\n\t\t\tname = mpi3mr_reset_types[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn name;\n}\n\n \nvoid mpi3mr_print_fault_info(struct mpi3mr_ioc *mrioc)\n{\n\tu32 ioc_status, code, code1, code2, code3;\n\n\tioc_status = readl(&mrioc->sysif_regs->ioc_status);\n\n\tif (ioc_status & MPI3_SYSIF_IOC_STATUS_FAULT) {\n\t\tcode = readl(&mrioc->sysif_regs->fault);\n\t\tcode1 = readl(&mrioc->sysif_regs->fault_info[0]);\n\t\tcode2 = readl(&mrioc->sysif_regs->fault_info[1]);\n\t\tcode3 = readl(&mrioc->sysif_regs->fault_info[2]);\n\n\t\tioc_info(mrioc,\n\t\t    \"fault code(0x%08X): Additional code: (0x%08X:0x%08X:0x%08X)\\n\",\n\t\t    code, code1, code2, code3);\n\t}\n}\n\n \nenum mpi3mr_iocstate mpi3mr_get_iocstate(struct mpi3mr_ioc *mrioc)\n{\n\tu32 ioc_status, ioc_config;\n\tu8 ready, enabled;\n\n\tioc_status = readl(&mrioc->sysif_regs->ioc_status);\n\tioc_config = readl(&mrioc->sysif_regs->ioc_configuration);\n\n\tif (mrioc->unrecoverable)\n\t\treturn MRIOC_STATE_UNRECOVERABLE;\n\tif (ioc_status & MPI3_SYSIF_IOC_STATUS_FAULT)\n\t\treturn MRIOC_STATE_FAULT;\n\n\tready = (ioc_status & MPI3_SYSIF_IOC_STATUS_READY);\n\tenabled = (ioc_config & MPI3_SYSIF_IOC_CONFIG_ENABLE_IOC);\n\n\tif (ready && enabled)\n\t\treturn MRIOC_STATE_READY;\n\tif ((!ready) && (!enabled))\n\t\treturn MRIOC_STATE_RESET;\n\tif ((!ready) && (enabled))\n\t\treturn MRIOC_STATE_BECOMING_READY;\n\n\treturn MRIOC_STATE_RESET_REQUESTED;\n}\n\n \nstatic inline void mpi3mr_clear_reset_history(struct mpi3mr_ioc *mrioc)\n{\n\tu32 ioc_status;\n\n\tioc_status = readl(&mrioc->sysif_regs->ioc_status);\n\tif (ioc_status & MPI3_SYSIF_IOC_STATUS_RESET_HISTORY)\n\t\twritel(ioc_status, &mrioc->sysif_regs->ioc_status);\n}\n\n \nstatic int mpi3mr_issue_and_process_mur(struct mpi3mr_ioc *mrioc,\n\tu32 reset_reason)\n{\n\tu32 ioc_config, timeout, ioc_status;\n\tint retval = -1;\n\n\tioc_info(mrioc, \"Issuing Message unit Reset(MUR)\\n\");\n\tif (mrioc->unrecoverable) {\n\t\tioc_info(mrioc, \"IOC is unrecoverable MUR not issued\\n\");\n\t\treturn retval;\n\t}\n\tmpi3mr_clear_reset_history(mrioc);\n\twritel(reset_reason, &mrioc->sysif_regs->scratchpad[0]);\n\tioc_config = readl(&mrioc->sysif_regs->ioc_configuration);\n\tioc_config &= ~MPI3_SYSIF_IOC_CONFIG_ENABLE_IOC;\n\twritel(ioc_config, &mrioc->sysif_regs->ioc_configuration);\n\n\ttimeout = MPI3MR_MUR_TIMEOUT * 10;\n\tdo {\n\t\tioc_status = readl(&mrioc->sysif_regs->ioc_status);\n\t\tif ((ioc_status & MPI3_SYSIF_IOC_STATUS_RESET_HISTORY)) {\n\t\t\tmpi3mr_clear_reset_history(mrioc);\n\t\t\tbreak;\n\t\t}\n\t\tif (ioc_status & MPI3_SYSIF_IOC_STATUS_FAULT) {\n\t\t\tmpi3mr_print_fault_info(mrioc);\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(100);\n\t} while (--timeout);\n\n\tioc_config = readl(&mrioc->sysif_regs->ioc_configuration);\n\tif (timeout && !((ioc_status & MPI3_SYSIF_IOC_STATUS_READY) ||\n\t      (ioc_status & MPI3_SYSIF_IOC_STATUS_FAULT) ||\n\t      (ioc_config & MPI3_SYSIF_IOC_CONFIG_ENABLE_IOC)))\n\t\tretval = 0;\n\n\tioc_info(mrioc, \"Base IOC Sts/Config after %s MUR is (0x%x)/(0x%x)\\n\",\n\t    (!retval) ? \"successful\" : \"failed\", ioc_status, ioc_config);\n\treturn retval;\n}\n\n \nstatic int\nmpi3mr_revalidate_factsdata(struct mpi3mr_ioc *mrioc)\n{\n\tunsigned long *removepend_bitmap;\n\n\tif (mrioc->facts.reply_sz > mrioc->reply_sz) {\n\t\tioc_err(mrioc,\n\t\t    \"cannot increase reply size from %d to %d\\n\",\n\t\t    mrioc->reply_sz, mrioc->facts.reply_sz);\n\t\treturn -EPERM;\n\t}\n\n\tif (mrioc->facts.max_op_reply_q < mrioc->num_op_reply_q) {\n\t\tioc_err(mrioc,\n\t\t    \"cannot reduce number of operational reply queues from %d to %d\\n\",\n\t\t    mrioc->num_op_reply_q,\n\t\t    mrioc->facts.max_op_reply_q);\n\t\treturn -EPERM;\n\t}\n\n\tif (mrioc->facts.max_op_req_q < mrioc->num_op_req_q) {\n\t\tioc_err(mrioc,\n\t\t    \"cannot reduce number of operational request queues from %d to %d\\n\",\n\t\t    mrioc->num_op_req_q, mrioc->facts.max_op_req_q);\n\t\treturn -EPERM;\n\t}\n\n\tif (mrioc->shost->max_sectors != (mrioc->facts.max_data_length / 512))\n\t\tioc_err(mrioc, \"Warning: The maximum data transfer length\\n\"\n\t\t\t    \"\\tchanged after reset: previous(%d), new(%d),\\n\"\n\t\t\t    \"the driver cannot change this at run time\\n\",\n\t\t\t    mrioc->shost->max_sectors * 512, mrioc->facts.max_data_length);\n\n\tif ((mrioc->sas_transport_enabled) && (mrioc->facts.ioc_capabilities &\n\t    MPI3_IOCFACTS_CAPABILITY_MULTIPATH_ENABLED))\n\t\tioc_err(mrioc,\n\t\t    \"critical error: multipath capability is enabled at the\\n\"\n\t\t    \"\\tcontroller while sas transport support is enabled at the\\n\"\n\t\t    \"\\tdriver, please reboot the system or reload the driver\\n\");\n\n\tif (mrioc->facts.max_devhandle > mrioc->dev_handle_bitmap_bits) {\n\t\tremovepend_bitmap = bitmap_zalloc(mrioc->facts.max_devhandle,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!removepend_bitmap) {\n\t\t\tioc_err(mrioc,\n\t\t\t\t\"failed to increase removepend_bitmap bits from %d to %d\\n\",\n\t\t\t\tmrioc->dev_handle_bitmap_bits,\n\t\t\t\tmrioc->facts.max_devhandle);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tbitmap_free(mrioc->removepend_bitmap);\n\t\tmrioc->removepend_bitmap = removepend_bitmap;\n\t\tioc_info(mrioc,\n\t\t\t \"increased bits of dev_handle_bitmap from %d to %d\\n\",\n\t\t\t mrioc->dev_handle_bitmap_bits,\n\t\t\t mrioc->facts.max_devhandle);\n\t\tmrioc->dev_handle_bitmap_bits = mrioc->facts.max_devhandle;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mpi3mr_bring_ioc_ready(struct mpi3mr_ioc *mrioc)\n{\n\tu32 ioc_config, ioc_status, timeout, host_diagnostic;\n\tint retval = 0;\n\tenum mpi3mr_iocstate ioc_state;\n\tu64 base_info;\n\n\tioc_status = readl(&mrioc->sysif_regs->ioc_status);\n\tioc_config = readl(&mrioc->sysif_regs->ioc_configuration);\n\tbase_info = lo_hi_readq(&mrioc->sysif_regs->ioc_information);\n\tioc_info(mrioc, \"ioc_status(0x%08x), ioc_config(0x%08x), ioc_info(0x%016llx) at the bringup\\n\",\n\t    ioc_status, ioc_config, base_info);\n\n\t \n\tmrioc->ready_timeout =\n\t    ((base_info & MPI3_SYSIF_IOC_INFO_LOW_TIMEOUT_MASK) >>\n\t    MPI3_SYSIF_IOC_INFO_LOW_TIMEOUT_SHIFT) * 2;\n\n\tioc_info(mrioc, \"ready timeout: %d seconds\\n\", mrioc->ready_timeout);\n\n\tioc_state = mpi3mr_get_iocstate(mrioc);\n\tioc_info(mrioc, \"controller is in %s state during detection\\n\",\n\t    mpi3mr_iocstate_name(ioc_state));\n\n\tif (ioc_state == MRIOC_STATE_BECOMING_READY ||\n\t    ioc_state == MRIOC_STATE_RESET_REQUESTED) {\n\t\ttimeout = mrioc->ready_timeout * 10;\n\t\tdo {\n\t\t\tmsleep(100);\n\t\t} while (--timeout);\n\n\t\tif (!pci_device_is_present(mrioc->pdev)) {\n\t\t\tmrioc->unrecoverable = 1;\n\t\t\tioc_err(mrioc,\n\t\t\t    \"controller is not present while waiting to reset\\n\");\n\t\t\tretval = -1;\n\t\t\tgoto out_device_not_present;\n\t\t}\n\n\t\tioc_state = mpi3mr_get_iocstate(mrioc);\n\t\tioc_info(mrioc,\n\t\t    \"controller is in %s state after waiting to reset\\n\",\n\t\t    mpi3mr_iocstate_name(ioc_state));\n\t}\n\n\tif (ioc_state == MRIOC_STATE_READY) {\n\t\tioc_info(mrioc, \"issuing message unit reset (MUR) to bring to reset state\\n\");\n\t\tretval = mpi3mr_issue_and_process_mur(mrioc,\n\t\t    MPI3MR_RESET_FROM_BRINGUP);\n\t\tioc_state = mpi3mr_get_iocstate(mrioc);\n\t\tif (retval)\n\t\t\tioc_err(mrioc,\n\t\t\t    \"message unit reset failed with error %d current state %s\\n\",\n\t\t\t    retval, mpi3mr_iocstate_name(ioc_state));\n\t}\n\tif (ioc_state != MRIOC_STATE_RESET) {\n\t\tif (ioc_state == MRIOC_STATE_FAULT) {\n\t\t\ttimeout = MPI3_SYSIF_DIAG_SAVE_TIMEOUT * 10;\n\t\t\tmpi3mr_print_fault_info(mrioc);\n\t\t\tdo {\n\t\t\t\thost_diagnostic =\n\t\t\t\t\treadl(&mrioc->sysif_regs->host_diagnostic);\n\t\t\t\tif (!(host_diagnostic &\n\t\t\t\t      MPI3_SYSIF_HOST_DIAG_SAVE_IN_PROGRESS))\n\t\t\t\t\tbreak;\n\t\t\t\tif (!pci_device_is_present(mrioc->pdev)) {\n\t\t\t\t\tmrioc->unrecoverable = 1;\n\t\t\t\t\tioc_err(mrioc, \"controller is not present at the bringup\\n\");\n\t\t\t\t\tgoto out_device_not_present;\n\t\t\t\t}\n\t\t\t\tmsleep(100);\n\t\t\t} while (--timeout);\n\t\t}\n\t\tmpi3mr_print_fault_info(mrioc);\n\t\tioc_info(mrioc, \"issuing soft reset to bring to reset state\\n\");\n\t\tretval = mpi3mr_issue_reset(mrioc,\n\t\t    MPI3_SYSIF_HOST_DIAG_RESET_ACTION_SOFT_RESET,\n\t\t    MPI3MR_RESET_FROM_BRINGUP);\n\t\tif (retval) {\n\t\t\tioc_err(mrioc,\n\t\t\t    \"soft reset failed with error %d\\n\", retval);\n\t\t\tgoto out_failed;\n\t\t}\n\t}\n\tioc_state = mpi3mr_get_iocstate(mrioc);\n\tif (ioc_state != MRIOC_STATE_RESET) {\n\t\tioc_err(mrioc,\n\t\t    \"cannot bring controller to reset state, current state: %s\\n\",\n\t\t    mpi3mr_iocstate_name(ioc_state));\n\t\tgoto out_failed;\n\t}\n\tmpi3mr_clear_reset_history(mrioc);\n\tretval = mpi3mr_setup_admin_qpair(mrioc);\n\tif (retval) {\n\t\tioc_err(mrioc, \"failed to setup admin queues: error %d\\n\",\n\t\t    retval);\n\t\tgoto out_failed;\n\t}\n\n\tioc_info(mrioc, \"bringing controller to ready state\\n\");\n\tioc_config = readl(&mrioc->sysif_regs->ioc_configuration);\n\tioc_config |= MPI3_SYSIF_IOC_CONFIG_ENABLE_IOC;\n\twritel(ioc_config, &mrioc->sysif_regs->ioc_configuration);\n\n\ttimeout = mrioc->ready_timeout * 10;\n\tdo {\n\t\tioc_state = mpi3mr_get_iocstate(mrioc);\n\t\tif (ioc_state == MRIOC_STATE_READY) {\n\t\t\tioc_info(mrioc,\n\t\t\t    \"successfully transitioned to %s state\\n\",\n\t\t\t    mpi3mr_iocstate_name(ioc_state));\n\t\t\treturn 0;\n\t\t}\n\t\tif (!pci_device_is_present(mrioc->pdev)) {\n\t\t\tmrioc->unrecoverable = 1;\n\t\t\tioc_err(mrioc,\n\t\t\t    \"controller is not present at the bringup\\n\");\n\t\t\tretval = -1;\n\t\t\tgoto out_device_not_present;\n\t\t}\n\t\tmsleep(100);\n\t} while (--timeout);\n\nout_failed:\n\tioc_state = mpi3mr_get_iocstate(mrioc);\n\tioc_err(mrioc,\n\t    \"failed to bring to ready state,  current state: %s\\n\",\n\t    mpi3mr_iocstate_name(ioc_state));\nout_device_not_present:\n\treturn retval;\n}\n\n \nstatic inline bool\nmpi3mr_soft_reset_success(u32 ioc_status, u32 ioc_config)\n{\n\tif (!((ioc_status & MPI3_SYSIF_IOC_STATUS_READY) ||\n\t    (ioc_config & MPI3_SYSIF_IOC_CONFIG_ENABLE_IOC)))\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic inline bool mpi3mr_diagfault_success(struct mpi3mr_ioc *mrioc,\n\tu32 ioc_status)\n{\n\tu32 fault;\n\n\tif (!(ioc_status & MPI3_SYSIF_IOC_STATUS_FAULT))\n\t\treturn false;\n\tfault = readl(&mrioc->sysif_regs->fault) & MPI3_SYSIF_FAULT_CODE_MASK;\n\tif (fault == MPI3_SYSIF_FAULT_CODE_DIAG_FAULT_RESET) {\n\t\tmpi3mr_print_fault_info(mrioc);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic inline void mpi3mr_set_diagsave(struct mpi3mr_ioc *mrioc)\n{\n\tu32 ioc_config;\n\n\tioc_config = readl(&mrioc->sysif_regs->ioc_configuration);\n\tioc_config |= MPI3_SYSIF_IOC_CONFIG_DIAG_SAVE;\n\twritel(ioc_config, &mrioc->sysif_regs->ioc_configuration);\n}\n\n \nstatic int mpi3mr_issue_reset(struct mpi3mr_ioc *mrioc, u16 reset_type,\n\tu32 reset_reason)\n{\n\tint retval = -1;\n\tu8 unlock_retry_count = 0;\n\tu32 host_diagnostic, ioc_status, ioc_config;\n\tu32 timeout = MPI3MR_RESET_ACK_TIMEOUT * 10;\n\n\tif ((reset_type != MPI3_SYSIF_HOST_DIAG_RESET_ACTION_SOFT_RESET) &&\n\t    (reset_type != MPI3_SYSIF_HOST_DIAG_RESET_ACTION_DIAG_FAULT))\n\t\treturn retval;\n\tif (mrioc->unrecoverable)\n\t\treturn retval;\n\tif (reset_reason == MPI3MR_RESET_FROM_FIRMWARE) {\n\t\tretval = 0;\n\t\treturn retval;\n\t}\n\n\tioc_info(mrioc, \"%s reset due to %s(0x%x)\\n\",\n\t    mpi3mr_reset_type_name(reset_type),\n\t    mpi3mr_reset_rc_name(reset_reason), reset_reason);\n\n\tmpi3mr_clear_reset_history(mrioc);\n\tdo {\n\t\tioc_info(mrioc,\n\t\t    \"Write magic sequence to unlock host diag register (retry=%d)\\n\",\n\t\t    ++unlock_retry_count);\n\t\tif (unlock_retry_count >= MPI3MR_HOSTDIAG_UNLOCK_RETRY_COUNT) {\n\t\t\tioc_err(mrioc,\n\t\t\t    \"%s reset failed due to unlock failure, host_diagnostic(0x%08x)\\n\",\n\t\t\t    mpi3mr_reset_type_name(reset_type),\n\t\t\t    host_diagnostic);\n\t\t\tmrioc->unrecoverable = 1;\n\t\t\treturn retval;\n\t\t}\n\n\t\twritel(MPI3_SYSIF_WRITE_SEQUENCE_KEY_VALUE_FLUSH,\n\t\t    &mrioc->sysif_regs->write_sequence);\n\t\twritel(MPI3_SYSIF_WRITE_SEQUENCE_KEY_VALUE_1ST,\n\t\t    &mrioc->sysif_regs->write_sequence);\n\t\twritel(MPI3_SYSIF_WRITE_SEQUENCE_KEY_VALUE_2ND,\n\t\t    &mrioc->sysif_regs->write_sequence);\n\t\twritel(MPI3_SYSIF_WRITE_SEQUENCE_KEY_VALUE_3RD,\n\t\t    &mrioc->sysif_regs->write_sequence);\n\t\twritel(MPI3_SYSIF_WRITE_SEQUENCE_KEY_VALUE_4TH,\n\t\t    &mrioc->sysif_regs->write_sequence);\n\t\twritel(MPI3_SYSIF_WRITE_SEQUENCE_KEY_VALUE_5TH,\n\t\t    &mrioc->sysif_regs->write_sequence);\n\t\twritel(MPI3_SYSIF_WRITE_SEQUENCE_KEY_VALUE_6TH,\n\t\t    &mrioc->sysif_regs->write_sequence);\n\t\tusleep_range(1000, 1100);\n\t\thost_diagnostic = readl(&mrioc->sysif_regs->host_diagnostic);\n\t\tioc_info(mrioc,\n\t\t    \"wrote magic sequence: retry_count(%d), host_diagnostic(0x%08x)\\n\",\n\t\t    unlock_retry_count, host_diagnostic);\n\t} while (!(host_diagnostic & MPI3_SYSIF_HOST_DIAG_DIAG_WRITE_ENABLE));\n\n\twritel(reset_reason, &mrioc->sysif_regs->scratchpad[0]);\n\twritel(host_diagnostic | reset_type,\n\t    &mrioc->sysif_regs->host_diagnostic);\n\tswitch (reset_type) {\n\tcase MPI3_SYSIF_HOST_DIAG_RESET_ACTION_SOFT_RESET:\n\t\tdo {\n\t\t\tioc_status = readl(&mrioc->sysif_regs->ioc_status);\n\t\t\tioc_config =\n\t\t\t    readl(&mrioc->sysif_regs->ioc_configuration);\n\t\t\tif ((ioc_status & MPI3_SYSIF_IOC_STATUS_RESET_HISTORY)\n\t\t\t    && mpi3mr_soft_reset_success(ioc_status, ioc_config)\n\t\t\t    ) {\n\t\t\t\tmpi3mr_clear_reset_history(mrioc);\n\t\t\t\tretval = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(100);\n\t\t} while (--timeout);\n\t\tmpi3mr_print_fault_info(mrioc);\n\t\tbreak;\n\tcase MPI3_SYSIF_HOST_DIAG_RESET_ACTION_DIAG_FAULT:\n\t\tdo {\n\t\t\tioc_status = readl(&mrioc->sysif_regs->ioc_status);\n\t\t\tif (mpi3mr_diagfault_success(mrioc, ioc_status)) {\n\t\t\t\tretval = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(100);\n\t\t} while (--timeout);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\twritel(MPI3_SYSIF_WRITE_SEQUENCE_KEY_VALUE_2ND,\n\t    &mrioc->sysif_regs->write_sequence);\n\n\tioc_config = readl(&mrioc->sysif_regs->ioc_configuration);\n\tioc_status = readl(&mrioc->sysif_regs->ioc_status);\n\tioc_info(mrioc,\n\t    \"ioc_status/ioc_onfig after %s reset is (0x%x)/(0x%x)\\n\",\n\t    (!retval)?\"successful\":\"failed\", ioc_status,\n\t    ioc_config);\n\tif (retval)\n\t\tmrioc->unrecoverable = 1;\n\treturn retval;\n}\n\n \nint mpi3mr_admin_request_post(struct mpi3mr_ioc *mrioc, void *admin_req,\n\tu16 admin_req_sz, u8 ignore_reset)\n{\n\tu16 areq_pi = 0, areq_ci = 0, max_entries = 0;\n\tint retval = 0;\n\tunsigned long flags;\n\tu8 *areq_entry;\n\n\tif (mrioc->unrecoverable) {\n\t\tioc_err(mrioc, \"%s : Unrecoverable controller\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tspin_lock_irqsave(&mrioc->admin_req_lock, flags);\n\tareq_pi = mrioc->admin_req_pi;\n\tareq_ci = mrioc->admin_req_ci;\n\tmax_entries = mrioc->num_admin_req;\n\tif ((areq_ci == (areq_pi + 1)) || ((!areq_ci) &&\n\t    (areq_pi == (max_entries - 1)))) {\n\t\tioc_err(mrioc, \"AdminReqQ full condition detected\\n\");\n\t\tretval = -EAGAIN;\n\t\tgoto out;\n\t}\n\tif (!ignore_reset && mrioc->reset_in_progress) {\n\t\tioc_err(mrioc, \"AdminReqQ submit reset in progress\\n\");\n\t\tretval = -EAGAIN;\n\t\tgoto out;\n\t}\n\tareq_entry = (u8 *)mrioc->admin_req_base +\n\t    (areq_pi * MPI3MR_ADMIN_REQ_FRAME_SZ);\n\tmemset(areq_entry, 0, MPI3MR_ADMIN_REQ_FRAME_SZ);\n\tmemcpy(areq_entry, (u8 *)admin_req, admin_req_sz);\n\n\tif (++areq_pi == max_entries)\n\t\tareq_pi = 0;\n\tmrioc->admin_req_pi = areq_pi;\n\n\twritel(mrioc->admin_req_pi, &mrioc->sysif_regs->admin_request_queue_pi);\n\nout:\n\tspin_unlock_irqrestore(&mrioc->admin_req_lock, flags);\n\n\treturn retval;\n}\n\n \nstatic void mpi3mr_free_op_req_q_segments(struct mpi3mr_ioc *mrioc, u16 q_idx)\n{\n\tu16 j;\n\tint size;\n\tstruct segments *segments;\n\n\tsegments = mrioc->req_qinfo[q_idx].q_segments;\n\tif (!segments)\n\t\treturn;\n\n\tif (mrioc->enable_segqueue) {\n\t\tsize = MPI3MR_OP_REQ_Q_SEG_SIZE;\n\t\tif (mrioc->req_qinfo[q_idx].q_segment_list) {\n\t\t\tdma_free_coherent(&mrioc->pdev->dev,\n\t\t\t    MPI3MR_MAX_SEG_LIST_SIZE,\n\t\t\t    mrioc->req_qinfo[q_idx].q_segment_list,\n\t\t\t    mrioc->req_qinfo[q_idx].q_segment_list_dma);\n\t\t\tmrioc->req_qinfo[q_idx].q_segment_list = NULL;\n\t\t}\n\t} else\n\t\tsize = mrioc->req_qinfo[q_idx].segment_qd *\n\t\t    mrioc->facts.op_req_sz;\n\n\tfor (j = 0; j < mrioc->req_qinfo[q_idx].num_segments; j++) {\n\t\tif (!segments[j].segment)\n\t\t\tcontinue;\n\t\tdma_free_coherent(&mrioc->pdev->dev,\n\t\t    size, segments[j].segment, segments[j].segment_dma);\n\t\tsegments[j].segment = NULL;\n\t}\n\tkfree(mrioc->req_qinfo[q_idx].q_segments);\n\tmrioc->req_qinfo[q_idx].q_segments = NULL;\n\tmrioc->req_qinfo[q_idx].qid = 0;\n}\n\n \nstatic void mpi3mr_free_op_reply_q_segments(struct mpi3mr_ioc *mrioc, u16 q_idx)\n{\n\tu16 j;\n\tint size;\n\tstruct segments *segments;\n\n\tsegments = mrioc->op_reply_qinfo[q_idx].q_segments;\n\tif (!segments)\n\t\treturn;\n\n\tif (mrioc->enable_segqueue) {\n\t\tsize = MPI3MR_OP_REP_Q_SEG_SIZE;\n\t\tif (mrioc->op_reply_qinfo[q_idx].q_segment_list) {\n\t\t\tdma_free_coherent(&mrioc->pdev->dev,\n\t\t\t    MPI3MR_MAX_SEG_LIST_SIZE,\n\t\t\t    mrioc->op_reply_qinfo[q_idx].q_segment_list,\n\t\t\t    mrioc->op_reply_qinfo[q_idx].q_segment_list_dma);\n\t\t\tmrioc->op_reply_qinfo[q_idx].q_segment_list = NULL;\n\t\t}\n\t} else\n\t\tsize = mrioc->op_reply_qinfo[q_idx].segment_qd *\n\t\t    mrioc->op_reply_desc_sz;\n\n\tfor (j = 0; j < mrioc->op_reply_qinfo[q_idx].num_segments; j++) {\n\t\tif (!segments[j].segment)\n\t\t\tcontinue;\n\t\tdma_free_coherent(&mrioc->pdev->dev,\n\t\t    size, segments[j].segment, segments[j].segment_dma);\n\t\tsegments[j].segment = NULL;\n\t}\n\n\tkfree(mrioc->op_reply_qinfo[q_idx].q_segments);\n\tmrioc->op_reply_qinfo[q_idx].q_segments = NULL;\n\tmrioc->op_reply_qinfo[q_idx].qid = 0;\n}\n\n \nstatic int mpi3mr_delete_op_reply_q(struct mpi3mr_ioc *mrioc, u16 qidx)\n{\n\tstruct mpi3_delete_reply_queue_request delq_req;\n\tstruct op_reply_qinfo *op_reply_q = mrioc->op_reply_qinfo + qidx;\n\tint retval = 0;\n\tu16 reply_qid = 0, midx;\n\n\treply_qid = op_reply_q->qid;\n\n\tmidx = REPLY_QUEUE_IDX_TO_MSIX_IDX(qidx, mrioc->op_reply_q_offset);\n\n\tif (!reply_qid)\t{\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"Issue DelRepQ: called with invalid ReqQID\\n\");\n\t\tgoto out;\n\t}\n\n\t(op_reply_q->qtype == MPI3MR_DEFAULT_QUEUE) ? mrioc->default_qcount-- :\n\t    mrioc->active_poll_qcount--;\n\n\tmemset(&delq_req, 0, sizeof(delq_req));\n\tmutex_lock(&mrioc->init_cmds.mutex);\n\tif (mrioc->init_cmds.state & MPI3MR_CMD_PENDING) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"Issue DelRepQ: Init command is in use\\n\");\n\t\tmutex_unlock(&mrioc->init_cmds.mutex);\n\t\tgoto out;\n\t}\n\tmrioc->init_cmds.state = MPI3MR_CMD_PENDING;\n\tmrioc->init_cmds.is_waiting = 1;\n\tmrioc->init_cmds.callback = NULL;\n\tdelq_req.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_INITCMDS);\n\tdelq_req.function = MPI3_FUNCTION_DELETE_REPLY_QUEUE;\n\tdelq_req.queue_id = cpu_to_le16(reply_qid);\n\n\tinit_completion(&mrioc->init_cmds.done);\n\tretval = mpi3mr_admin_request_post(mrioc, &delq_req, sizeof(delq_req),\n\t    1);\n\tif (retval) {\n\t\tioc_err(mrioc, \"Issue DelRepQ: Admin Post failed\\n\");\n\t\tgoto out_unlock;\n\t}\n\twait_for_completion_timeout(&mrioc->init_cmds.done,\n\t    (MPI3MR_INTADMCMD_TIMEOUT * HZ));\n\tif (!(mrioc->init_cmds.state & MPI3MR_CMD_COMPLETE)) {\n\t\tioc_err(mrioc, \"delete reply queue timed out\\n\");\n\t\tmpi3mr_check_rh_fault_ioc(mrioc,\n\t\t    MPI3MR_RESET_FROM_DELREPQ_TIMEOUT);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\tif ((mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK)\n\t    != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc,\n\t\t    \"Issue DelRepQ: Failed ioc_status(0x%04x) Loginfo(0x%08x)\\n\",\n\t\t    (mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK),\n\t\t    mrioc->init_cmds.ioc_loginfo);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\tmrioc->intr_info[midx].op_reply_q = NULL;\n\n\tmpi3mr_free_op_reply_q_segments(mrioc, qidx);\nout_unlock:\n\tmrioc->init_cmds.state = MPI3MR_CMD_NOTUSED;\n\tmutex_unlock(&mrioc->init_cmds.mutex);\nout:\n\n\treturn retval;\n}\n\n \nstatic int mpi3mr_alloc_op_reply_q_segments(struct mpi3mr_ioc *mrioc, u16 qidx)\n{\n\tstruct op_reply_qinfo *op_reply_q = mrioc->op_reply_qinfo + qidx;\n\tint i, size;\n\tu64 *q_segment_list_entry = NULL;\n\tstruct segments *segments;\n\n\tif (mrioc->enable_segqueue) {\n\t\top_reply_q->segment_qd =\n\t\t    MPI3MR_OP_REP_Q_SEG_SIZE / mrioc->op_reply_desc_sz;\n\n\t\tsize = MPI3MR_OP_REP_Q_SEG_SIZE;\n\n\t\top_reply_q->q_segment_list = dma_alloc_coherent(&mrioc->pdev->dev,\n\t\t    MPI3MR_MAX_SEG_LIST_SIZE, &op_reply_q->q_segment_list_dma,\n\t\t    GFP_KERNEL);\n\t\tif (!op_reply_q->q_segment_list)\n\t\t\treturn -ENOMEM;\n\t\tq_segment_list_entry = (u64 *)op_reply_q->q_segment_list;\n\t} else {\n\t\top_reply_q->segment_qd = op_reply_q->num_replies;\n\t\tsize = op_reply_q->num_replies * mrioc->op_reply_desc_sz;\n\t}\n\n\top_reply_q->num_segments = DIV_ROUND_UP(op_reply_q->num_replies,\n\t    op_reply_q->segment_qd);\n\n\top_reply_q->q_segments = kcalloc(op_reply_q->num_segments,\n\t    sizeof(struct segments), GFP_KERNEL);\n\tif (!op_reply_q->q_segments)\n\t\treturn -ENOMEM;\n\n\tsegments = op_reply_q->q_segments;\n\tfor (i = 0; i < op_reply_q->num_segments; i++) {\n\t\tsegments[i].segment =\n\t\t    dma_alloc_coherent(&mrioc->pdev->dev,\n\t\t    size, &segments[i].segment_dma, GFP_KERNEL);\n\t\tif (!segments[i].segment)\n\t\t\treturn -ENOMEM;\n\t\tif (mrioc->enable_segqueue)\n\t\t\tq_segment_list_entry[i] =\n\t\t\t    (unsigned long)segments[i].segment_dma;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mpi3mr_alloc_op_req_q_segments(struct mpi3mr_ioc *mrioc, u16 qidx)\n{\n\tstruct op_req_qinfo *op_req_q = mrioc->req_qinfo + qidx;\n\tint i, size;\n\tu64 *q_segment_list_entry = NULL;\n\tstruct segments *segments;\n\n\tif (mrioc->enable_segqueue) {\n\t\top_req_q->segment_qd =\n\t\t    MPI3MR_OP_REQ_Q_SEG_SIZE / mrioc->facts.op_req_sz;\n\n\t\tsize = MPI3MR_OP_REQ_Q_SEG_SIZE;\n\n\t\top_req_q->q_segment_list = dma_alloc_coherent(&mrioc->pdev->dev,\n\t\t    MPI3MR_MAX_SEG_LIST_SIZE, &op_req_q->q_segment_list_dma,\n\t\t    GFP_KERNEL);\n\t\tif (!op_req_q->q_segment_list)\n\t\t\treturn -ENOMEM;\n\t\tq_segment_list_entry = (u64 *)op_req_q->q_segment_list;\n\n\t} else {\n\t\top_req_q->segment_qd = op_req_q->num_requests;\n\t\tsize = op_req_q->num_requests * mrioc->facts.op_req_sz;\n\t}\n\n\top_req_q->num_segments = DIV_ROUND_UP(op_req_q->num_requests,\n\t    op_req_q->segment_qd);\n\n\top_req_q->q_segments = kcalloc(op_req_q->num_segments,\n\t    sizeof(struct segments), GFP_KERNEL);\n\tif (!op_req_q->q_segments)\n\t\treturn -ENOMEM;\n\n\tsegments = op_req_q->q_segments;\n\tfor (i = 0; i < op_req_q->num_segments; i++) {\n\t\tsegments[i].segment =\n\t\t    dma_alloc_coherent(&mrioc->pdev->dev,\n\t\t    size, &segments[i].segment_dma, GFP_KERNEL);\n\t\tif (!segments[i].segment)\n\t\t\treturn -ENOMEM;\n\t\tif (mrioc->enable_segqueue)\n\t\t\tq_segment_list_entry[i] =\n\t\t\t    (unsigned long)segments[i].segment_dma;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mpi3mr_create_op_reply_q(struct mpi3mr_ioc *mrioc, u16 qidx)\n{\n\tstruct mpi3_create_reply_queue_request create_req;\n\tstruct op_reply_qinfo *op_reply_q = mrioc->op_reply_qinfo + qidx;\n\tint retval = 0;\n\tu16 reply_qid = 0, midx;\n\n\treply_qid = op_reply_q->qid;\n\n\tmidx = REPLY_QUEUE_IDX_TO_MSIX_IDX(qidx, mrioc->op_reply_q_offset);\n\n\tif (reply_qid) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"CreateRepQ: called for duplicate qid %d\\n\",\n\t\t    reply_qid);\n\n\t\treturn retval;\n\t}\n\n\treply_qid = qidx + 1;\n\top_reply_q->num_replies = MPI3MR_OP_REP_Q_QD;\n\tif (!mrioc->pdev->revision)\n\t\top_reply_q->num_replies = MPI3MR_OP_REP_Q_QD4K;\n\top_reply_q->ci = 0;\n\top_reply_q->ephase = 1;\n\tatomic_set(&op_reply_q->pend_ios, 0);\n\tatomic_set(&op_reply_q->in_use, 0);\n\top_reply_q->enable_irq_poll = false;\n\n\tif (!op_reply_q->q_segments) {\n\t\tretval = mpi3mr_alloc_op_reply_q_segments(mrioc, qidx);\n\t\tif (retval) {\n\t\t\tmpi3mr_free_op_reply_q_segments(mrioc, qidx);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&create_req, 0, sizeof(create_req));\n\tmutex_lock(&mrioc->init_cmds.mutex);\n\tif (mrioc->init_cmds.state & MPI3MR_CMD_PENDING) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"CreateRepQ: Init command is in use\\n\");\n\t\tgoto out_unlock;\n\t}\n\tmrioc->init_cmds.state = MPI3MR_CMD_PENDING;\n\tmrioc->init_cmds.is_waiting = 1;\n\tmrioc->init_cmds.callback = NULL;\n\tcreate_req.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_INITCMDS);\n\tcreate_req.function = MPI3_FUNCTION_CREATE_REPLY_QUEUE;\n\tcreate_req.queue_id = cpu_to_le16(reply_qid);\n\n\tif (midx < (mrioc->intr_info_count - mrioc->requested_poll_qcount))\n\t\top_reply_q->qtype = MPI3MR_DEFAULT_QUEUE;\n\telse\n\t\top_reply_q->qtype = MPI3MR_POLL_QUEUE;\n\n\tif (op_reply_q->qtype == MPI3MR_DEFAULT_QUEUE) {\n\t\tcreate_req.flags =\n\t\t\tMPI3_CREATE_REPLY_QUEUE_FLAGS_INT_ENABLE_ENABLE;\n\t\tcreate_req.msix_index =\n\t\t\tcpu_to_le16(mrioc->intr_info[midx].msix_index);\n\t} else {\n\t\tcreate_req.msix_index = cpu_to_le16(mrioc->intr_info_count - 1);\n\t\tioc_info(mrioc, \"create reply queue(polled): for qid(%d), midx(%d)\\n\",\n\t\t\treply_qid, midx);\n\t\tif (!mrioc->active_poll_qcount)\n\t\t\tdisable_irq_nosync(pci_irq_vector(mrioc->pdev,\n\t\t\t    mrioc->intr_info_count - 1));\n\t}\n\n\tif (mrioc->enable_segqueue) {\n\t\tcreate_req.flags |=\n\t\t    MPI3_CREATE_REQUEST_QUEUE_FLAGS_SEGMENTED_SEGMENTED;\n\t\tcreate_req.base_address = cpu_to_le64(\n\t\t    op_reply_q->q_segment_list_dma);\n\t} else\n\t\tcreate_req.base_address = cpu_to_le64(\n\t\t    op_reply_q->q_segments[0].segment_dma);\n\n\tcreate_req.size = cpu_to_le16(op_reply_q->num_replies);\n\n\tinit_completion(&mrioc->init_cmds.done);\n\tretval = mpi3mr_admin_request_post(mrioc, &create_req,\n\t    sizeof(create_req), 1);\n\tif (retval) {\n\t\tioc_err(mrioc, \"CreateRepQ: Admin Post failed\\n\");\n\t\tgoto out_unlock;\n\t}\n\twait_for_completion_timeout(&mrioc->init_cmds.done,\n\t    (MPI3MR_INTADMCMD_TIMEOUT * HZ));\n\tif (!(mrioc->init_cmds.state & MPI3MR_CMD_COMPLETE)) {\n\t\tioc_err(mrioc, \"create reply queue timed out\\n\");\n\t\tmpi3mr_check_rh_fault_ioc(mrioc,\n\t\t    MPI3MR_RESET_FROM_CREATEREPQ_TIMEOUT);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\tif ((mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK)\n\t    != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc,\n\t\t    \"CreateRepQ: Failed ioc_status(0x%04x) Loginfo(0x%08x)\\n\",\n\t\t    (mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK),\n\t\t    mrioc->init_cmds.ioc_loginfo);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\top_reply_q->qid = reply_qid;\n\tif (midx < mrioc->intr_info_count)\n\t\tmrioc->intr_info[midx].op_reply_q = op_reply_q;\n\n\t(op_reply_q->qtype == MPI3MR_DEFAULT_QUEUE) ? mrioc->default_qcount++ :\n\t    mrioc->active_poll_qcount++;\n\nout_unlock:\n\tmrioc->init_cmds.state = MPI3MR_CMD_NOTUSED;\n\tmutex_unlock(&mrioc->init_cmds.mutex);\nout:\n\n\treturn retval;\n}\n\n \nstatic int mpi3mr_create_op_req_q(struct mpi3mr_ioc *mrioc, u16 idx,\n\tu16 reply_qid)\n{\n\tstruct mpi3_create_request_queue_request create_req;\n\tstruct op_req_qinfo *op_req_q = mrioc->req_qinfo + idx;\n\tint retval = 0;\n\tu16 req_qid = 0;\n\n\treq_qid = op_req_q->qid;\n\n\tif (req_qid) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"CreateReqQ: called for duplicate qid %d\\n\",\n\t\t    req_qid);\n\n\t\treturn retval;\n\t}\n\treq_qid = idx + 1;\n\n\top_req_q->num_requests = MPI3MR_OP_REQ_Q_QD;\n\top_req_q->ci = 0;\n\top_req_q->pi = 0;\n\top_req_q->reply_qid = reply_qid;\n\tspin_lock_init(&op_req_q->q_lock);\n\n\tif (!op_req_q->q_segments) {\n\t\tretval = mpi3mr_alloc_op_req_q_segments(mrioc, idx);\n\t\tif (retval) {\n\t\t\tmpi3mr_free_op_req_q_segments(mrioc, idx);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&create_req, 0, sizeof(create_req));\n\tmutex_lock(&mrioc->init_cmds.mutex);\n\tif (mrioc->init_cmds.state & MPI3MR_CMD_PENDING) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"CreateReqQ: Init command is in use\\n\");\n\t\tgoto out_unlock;\n\t}\n\tmrioc->init_cmds.state = MPI3MR_CMD_PENDING;\n\tmrioc->init_cmds.is_waiting = 1;\n\tmrioc->init_cmds.callback = NULL;\n\tcreate_req.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_INITCMDS);\n\tcreate_req.function = MPI3_FUNCTION_CREATE_REQUEST_QUEUE;\n\tcreate_req.queue_id = cpu_to_le16(req_qid);\n\tif (mrioc->enable_segqueue) {\n\t\tcreate_req.flags =\n\t\t    MPI3_CREATE_REQUEST_QUEUE_FLAGS_SEGMENTED_SEGMENTED;\n\t\tcreate_req.base_address = cpu_to_le64(\n\t\t    op_req_q->q_segment_list_dma);\n\t} else\n\t\tcreate_req.base_address = cpu_to_le64(\n\t\t    op_req_q->q_segments[0].segment_dma);\n\tcreate_req.reply_queue_id = cpu_to_le16(reply_qid);\n\tcreate_req.size = cpu_to_le16(op_req_q->num_requests);\n\n\tinit_completion(&mrioc->init_cmds.done);\n\tretval = mpi3mr_admin_request_post(mrioc, &create_req,\n\t    sizeof(create_req), 1);\n\tif (retval) {\n\t\tioc_err(mrioc, \"CreateReqQ: Admin Post failed\\n\");\n\t\tgoto out_unlock;\n\t}\n\twait_for_completion_timeout(&mrioc->init_cmds.done,\n\t    (MPI3MR_INTADMCMD_TIMEOUT * HZ));\n\tif (!(mrioc->init_cmds.state & MPI3MR_CMD_COMPLETE)) {\n\t\tioc_err(mrioc, \"create request queue timed out\\n\");\n\t\tmpi3mr_check_rh_fault_ioc(mrioc,\n\t\t    MPI3MR_RESET_FROM_CREATEREQQ_TIMEOUT);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\tif ((mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK)\n\t    != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc,\n\t\t    \"CreateReqQ: Failed ioc_status(0x%04x) Loginfo(0x%08x)\\n\",\n\t\t    (mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK),\n\t\t    mrioc->init_cmds.ioc_loginfo);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\top_req_q->qid = req_qid;\n\nout_unlock:\n\tmrioc->init_cmds.state = MPI3MR_CMD_NOTUSED;\n\tmutex_unlock(&mrioc->init_cmds.mutex);\nout:\n\n\treturn retval;\n}\n\n \nstatic int mpi3mr_create_op_queues(struct mpi3mr_ioc *mrioc)\n{\n\tint retval = 0;\n\tu16 num_queues = 0, i = 0, msix_count_op_q = 1;\n\n\tnum_queues = min_t(int, mrioc->facts.max_op_reply_q,\n\t    mrioc->facts.max_op_req_q);\n\n\tmsix_count_op_q =\n\t    mrioc->intr_info_count - mrioc->op_reply_q_offset;\n\tif (!mrioc->num_queues)\n\t\tmrioc->num_queues = min_t(int, num_queues, msix_count_op_q);\n\t \n\tnum_queues = mrioc->num_op_reply_q ?\n\t    mrioc->num_op_reply_q : mrioc->num_queues;\n\tioc_info(mrioc, \"trying to create %d operational queue pairs\\n\",\n\t    num_queues);\n\n\tif (!mrioc->req_qinfo) {\n\t\tmrioc->req_qinfo = kcalloc(num_queues,\n\t\t    sizeof(struct op_req_qinfo), GFP_KERNEL);\n\t\tif (!mrioc->req_qinfo) {\n\t\t\tretval = -1;\n\t\t\tgoto out_failed;\n\t\t}\n\n\t\tmrioc->op_reply_qinfo = kzalloc(sizeof(struct op_reply_qinfo) *\n\t\t    num_queues, GFP_KERNEL);\n\t\tif (!mrioc->op_reply_qinfo) {\n\t\t\tretval = -1;\n\t\t\tgoto out_failed;\n\t\t}\n\t}\n\n\tif (mrioc->enable_segqueue)\n\t\tioc_info(mrioc,\n\t\t    \"allocating operational queues through segmented queues\\n\");\n\n\tfor (i = 0; i < num_queues; i++) {\n\t\tif (mpi3mr_create_op_reply_q(mrioc, i)) {\n\t\t\tioc_err(mrioc, \"Cannot create OP RepQ %d\\n\", i);\n\t\t\tbreak;\n\t\t}\n\t\tif (mpi3mr_create_op_req_q(mrioc, i,\n\t\t    mrioc->op_reply_qinfo[i].qid)) {\n\t\t\tioc_err(mrioc, \"Cannot create OP ReqQ %d\\n\", i);\n\t\t\tmpi3mr_delete_op_reply_q(mrioc, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == 0) {\n\t\t \n\t\tretval = -1;\n\t\tgoto out_failed;\n\t}\n\tmrioc->num_op_reply_q = mrioc->num_op_req_q = i;\n\tioc_info(mrioc,\n\t    \"successfully created %d operational queue pairs(default/polled) queue = (%d/%d)\\n\",\n\t    mrioc->num_op_reply_q, mrioc->default_qcount,\n\t    mrioc->active_poll_qcount);\n\n\treturn retval;\nout_failed:\n\tkfree(mrioc->req_qinfo);\n\tmrioc->req_qinfo = NULL;\n\n\tkfree(mrioc->op_reply_qinfo);\n\tmrioc->op_reply_qinfo = NULL;\n\n\treturn retval;\n}\n\n \nint mpi3mr_op_request_post(struct mpi3mr_ioc *mrioc,\n\tstruct op_req_qinfo *op_req_q, u8 *req)\n{\n\tu16 pi = 0, max_entries, reply_qidx = 0, midx;\n\tint retval = 0;\n\tunsigned long flags;\n\tu8 *req_entry;\n\tvoid *segment_base_addr;\n\tu16 req_sz = mrioc->facts.op_req_sz;\n\tstruct segments *segments = op_req_q->q_segments;\n\n\treply_qidx = op_req_q->reply_qid - 1;\n\n\tif (mrioc->unrecoverable)\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&op_req_q->q_lock, flags);\n\tpi = op_req_q->pi;\n\tmax_entries = op_req_q->num_requests;\n\n\tif (mpi3mr_check_req_qfull(op_req_q)) {\n\t\tmidx = REPLY_QUEUE_IDX_TO_MSIX_IDX(\n\t\t    reply_qidx, mrioc->op_reply_q_offset);\n\t\tmpi3mr_process_op_reply_q(mrioc, mrioc->intr_info[midx].op_reply_q);\n\n\t\tif (mpi3mr_check_req_qfull(op_req_q)) {\n\t\t\tretval = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (mrioc->reset_in_progress) {\n\t\tioc_err(mrioc, \"OpReqQ submit reset in progress\\n\");\n\t\tretval = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tsegment_base_addr = segments[pi / op_req_q->segment_qd].segment;\n\treq_entry = (u8 *)segment_base_addr +\n\t    ((pi % op_req_q->segment_qd) * req_sz);\n\n\tmemset(req_entry, 0, req_sz);\n\tmemcpy(req_entry, req, MPI3MR_ADMIN_REQ_FRAME_SZ);\n\n\tif (++pi == max_entries)\n\t\tpi = 0;\n\top_req_q->pi = pi;\n\n#ifndef CONFIG_PREEMPT_RT\n\tif (atomic_inc_return(&mrioc->op_reply_qinfo[reply_qidx].pend_ios)\n\t    > MPI3MR_IRQ_POLL_TRIGGER_IOCOUNT)\n\t\tmrioc->op_reply_qinfo[reply_qidx].enable_irq_poll = true;\n#else\n\tatomic_inc_return(&mrioc->op_reply_qinfo[reply_qidx].pend_ios);\n#endif\n\n\twritel(op_req_q->pi,\n\t    &mrioc->sysif_regs->oper_queue_indexes[reply_qidx].producer_index);\n\nout:\n\tspin_unlock_irqrestore(&op_req_q->q_lock, flags);\n\treturn retval;\n}\n\n \nvoid mpi3mr_check_rh_fault_ioc(struct mpi3mr_ioc *mrioc, u32 reason_code)\n{\n\tu32 ioc_status, host_diagnostic, timeout;\n\n\tif (mrioc->unrecoverable) {\n\t\tioc_err(mrioc, \"controller is unrecoverable\\n\");\n\t\treturn;\n\t}\n\n\tif (!pci_device_is_present(mrioc->pdev)) {\n\t\tmrioc->unrecoverable = 1;\n\t\tioc_err(mrioc, \"controller is not present\\n\");\n\t\treturn;\n\t}\n\n\tioc_status = readl(&mrioc->sysif_regs->ioc_status);\n\tif ((ioc_status & MPI3_SYSIF_IOC_STATUS_RESET_HISTORY) ||\n\t    (ioc_status & MPI3_SYSIF_IOC_STATUS_FAULT)) {\n\t\tmpi3mr_print_fault_info(mrioc);\n\t\treturn;\n\t}\n\tmpi3mr_set_diagsave(mrioc);\n\tmpi3mr_issue_reset(mrioc, MPI3_SYSIF_HOST_DIAG_RESET_ACTION_DIAG_FAULT,\n\t    reason_code);\n\ttimeout = MPI3_SYSIF_DIAG_SAVE_TIMEOUT * 10;\n\tdo {\n\t\thost_diagnostic = readl(&mrioc->sysif_regs->host_diagnostic);\n\t\tif (!(host_diagnostic & MPI3_SYSIF_HOST_DIAG_SAVE_IN_PROGRESS))\n\t\t\tbreak;\n\t\tmsleep(100);\n\t} while (--timeout);\n}\n\n \nstatic int mpi3mr_sync_timestamp(struct mpi3mr_ioc *mrioc)\n{\n\tktime_t current_time;\n\tstruct mpi3_iounit_control_request iou_ctrl;\n\tint retval = 0;\n\n\tmemset(&iou_ctrl, 0, sizeof(iou_ctrl));\n\tmutex_lock(&mrioc->init_cmds.mutex);\n\tif (mrioc->init_cmds.state & MPI3MR_CMD_PENDING) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"Issue IOUCTL time_stamp: command is in use\\n\");\n\t\tmutex_unlock(&mrioc->init_cmds.mutex);\n\t\tgoto out;\n\t}\n\tmrioc->init_cmds.state = MPI3MR_CMD_PENDING;\n\tmrioc->init_cmds.is_waiting = 1;\n\tmrioc->init_cmds.callback = NULL;\n\tiou_ctrl.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_INITCMDS);\n\tiou_ctrl.function = MPI3_FUNCTION_IO_UNIT_CONTROL;\n\tiou_ctrl.operation = MPI3_CTRL_OP_UPDATE_TIMESTAMP;\n\tcurrent_time = ktime_get_real();\n\tiou_ctrl.param64[0] = cpu_to_le64(ktime_to_ms(current_time));\n\n\tinit_completion(&mrioc->init_cmds.done);\n\tretval = mpi3mr_admin_request_post(mrioc, &iou_ctrl,\n\t    sizeof(iou_ctrl), 0);\n\tif (retval) {\n\t\tioc_err(mrioc, \"Issue IOUCTL time_stamp: Admin Post failed\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\twait_for_completion_timeout(&mrioc->init_cmds.done,\n\t    (MPI3MR_INTADMCMD_TIMEOUT * HZ));\n\tif (!(mrioc->init_cmds.state & MPI3MR_CMD_COMPLETE)) {\n\t\tioc_err(mrioc, \"Issue IOUCTL time_stamp: command timed out\\n\");\n\t\tmrioc->init_cmds.is_waiting = 0;\n\t\tif (!(mrioc->init_cmds.state & MPI3MR_CMD_RESET))\n\t\t\tmpi3mr_check_rh_fault_ioc(mrioc,\n\t\t\t    MPI3MR_RESET_FROM_TSU_TIMEOUT);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\tif ((mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK)\n\t    != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc,\n\t\t    \"Issue IOUCTL time_stamp: Failed ioc_status(0x%04x) Loginfo(0x%08x)\\n\",\n\t\t    (mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK),\n\t\t    mrioc->init_cmds.ioc_loginfo);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmrioc->init_cmds.state = MPI3MR_CMD_NOTUSED;\n\tmutex_unlock(&mrioc->init_cmds.mutex);\n\nout:\n\treturn retval;\n}\n\n \nstatic int mpi3mr_print_pkg_ver(struct mpi3mr_ioc *mrioc)\n{\n\tstruct mpi3_ci_upload_request ci_upload;\n\tint retval = -1;\n\tvoid *data = NULL;\n\tdma_addr_t data_dma;\n\tstruct mpi3_ci_manifest_mpi *manifest;\n\tu32 data_len = sizeof(struct mpi3_ci_manifest_mpi);\n\tu8 sgl_flags = MPI3MR_SGEFLAGS_SYSTEM_SIMPLE_END_OF_LIST;\n\n\tdata = dma_alloc_coherent(&mrioc->pdev->dev, data_len, &data_dma,\n\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmemset(&ci_upload, 0, sizeof(ci_upload));\n\tmutex_lock(&mrioc->init_cmds.mutex);\n\tif (mrioc->init_cmds.state & MPI3MR_CMD_PENDING) {\n\t\tioc_err(mrioc, \"sending get package version failed due to command in use\\n\");\n\t\tmutex_unlock(&mrioc->init_cmds.mutex);\n\t\tgoto out;\n\t}\n\tmrioc->init_cmds.state = MPI3MR_CMD_PENDING;\n\tmrioc->init_cmds.is_waiting = 1;\n\tmrioc->init_cmds.callback = NULL;\n\tci_upload.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_INITCMDS);\n\tci_upload.function = MPI3_FUNCTION_CI_UPLOAD;\n\tci_upload.msg_flags = MPI3_CI_UPLOAD_MSGFLAGS_LOCATION_PRIMARY;\n\tci_upload.signature1 = cpu_to_le32(MPI3_IMAGE_HEADER_SIGNATURE1_MANIFEST);\n\tci_upload.image_offset = cpu_to_le32(MPI3_IMAGE_HEADER_SIZE);\n\tci_upload.segment_size = cpu_to_le32(data_len);\n\n\tmpi3mr_add_sg_single(&ci_upload.sgl, sgl_flags, data_len,\n\t    data_dma);\n\tinit_completion(&mrioc->init_cmds.done);\n\tretval = mpi3mr_admin_request_post(mrioc, &ci_upload,\n\t    sizeof(ci_upload), 1);\n\tif (retval) {\n\t\tioc_err(mrioc, \"posting get package version failed\\n\");\n\t\tgoto out_unlock;\n\t}\n\twait_for_completion_timeout(&mrioc->init_cmds.done,\n\t    (MPI3MR_INTADMCMD_TIMEOUT * HZ));\n\tif (!(mrioc->init_cmds.state & MPI3MR_CMD_COMPLETE)) {\n\t\tioc_err(mrioc, \"get package version timed out\\n\");\n\t\tmpi3mr_check_rh_fault_ioc(mrioc,\n\t\t    MPI3MR_RESET_FROM_GETPKGVER_TIMEOUT);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\tif ((mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK)\n\t    == MPI3_IOCSTATUS_SUCCESS) {\n\t\tmanifest = (struct mpi3_ci_manifest_mpi *) data;\n\t\tif (manifest->manifest_type == MPI3_CI_MANIFEST_TYPE_MPI) {\n\t\t\tioc_info(mrioc,\n\t\t\t    \"firmware package version(%d.%d.%d.%d.%05d-%05d)\\n\",\n\t\t\t    manifest->package_version.gen_major,\n\t\t\t    manifest->package_version.gen_minor,\n\t\t\t    manifest->package_version.phase_major,\n\t\t\t    manifest->package_version.phase_minor,\n\t\t\t    manifest->package_version.customer_id,\n\t\t\t    manifest->package_version.build_num);\n\t\t}\n\t}\n\tretval = 0;\nout_unlock:\n\tmrioc->init_cmds.state = MPI3MR_CMD_NOTUSED;\n\tmutex_unlock(&mrioc->init_cmds.mutex);\n\nout:\n\tif (data)\n\t\tdma_free_coherent(&mrioc->pdev->dev, data_len, data,\n\t\t    data_dma);\n\treturn retval;\n}\n\n \nstatic void mpi3mr_watchdog_work(struct work_struct *work)\n{\n\tstruct mpi3mr_ioc *mrioc =\n\t    container_of(work, struct mpi3mr_ioc, watchdog_work.work);\n\tunsigned long flags;\n\tenum mpi3mr_iocstate ioc_state;\n\tu32 fault, host_diagnostic, ioc_status;\n\tu32 reset_reason = MPI3MR_RESET_FROM_FAULT_WATCH;\n\n\tif (mrioc->reset_in_progress)\n\t\treturn;\n\n\tif (!mrioc->unrecoverable && !pci_device_is_present(mrioc->pdev)) {\n\t\tioc_err(mrioc, \"watchdog could not detect the controller\\n\");\n\t\tmrioc->unrecoverable = 1;\n\t}\n\n\tif (mrioc->unrecoverable) {\n\t\tioc_err(mrioc,\n\t\t    \"flush pending commands for unrecoverable controller\\n\");\n\t\tmpi3mr_flush_cmds_for_unrecovered_controller(mrioc);\n\t\treturn;\n\t}\n\n\tif (mrioc->ts_update_counter++ >= MPI3MR_TSUPDATE_INTERVAL) {\n\t\tmrioc->ts_update_counter = 0;\n\t\tmpi3mr_sync_timestamp(mrioc);\n\t}\n\n\tif ((mrioc->prepare_for_reset) &&\n\t    ((mrioc->prepare_for_reset_timeout_counter++) >=\n\t     MPI3MR_PREPARE_FOR_RESET_TIMEOUT)) {\n\t\tmpi3mr_soft_reset_handler(mrioc,\n\t\t    MPI3MR_RESET_FROM_CIACTVRST_TIMER, 1);\n\t\treturn;\n\t}\n\n\tioc_status = readl(&mrioc->sysif_regs->ioc_status);\n\tif (ioc_status & MPI3_SYSIF_IOC_STATUS_RESET_HISTORY) {\n\t\tmpi3mr_soft_reset_handler(mrioc, MPI3MR_RESET_FROM_FIRMWARE, 0);\n\t\treturn;\n\t}\n\n\t \n\tioc_state = mpi3mr_get_iocstate(mrioc);\n\tif (ioc_state != MRIOC_STATE_FAULT)\n\t\tgoto schedule_work;\n\n\tfault = readl(&mrioc->sysif_regs->fault) & MPI3_SYSIF_FAULT_CODE_MASK;\n\thost_diagnostic = readl(&mrioc->sysif_regs->host_diagnostic);\n\tif (host_diagnostic & MPI3_SYSIF_HOST_DIAG_SAVE_IN_PROGRESS) {\n\t\tif (!mrioc->diagsave_timeout) {\n\t\t\tmpi3mr_print_fault_info(mrioc);\n\t\t\tioc_warn(mrioc, \"diag save in progress\\n\");\n\t\t}\n\t\tif ((mrioc->diagsave_timeout++) <= MPI3_SYSIF_DIAG_SAVE_TIMEOUT)\n\t\t\tgoto schedule_work;\n\t}\n\n\tmpi3mr_print_fault_info(mrioc);\n\tmrioc->diagsave_timeout = 0;\n\n\tswitch (fault) {\n\tcase MPI3_SYSIF_FAULT_CODE_COMPLETE_RESET_NEEDED:\n\tcase MPI3_SYSIF_FAULT_CODE_POWER_CYCLE_REQUIRED:\n\t\tioc_warn(mrioc,\n\t\t    \"controller requires system power cycle, marking controller as unrecoverable\\n\");\n\t\tmrioc->unrecoverable = 1;\n\t\tgoto schedule_work;\n\tcase MPI3_SYSIF_FAULT_CODE_SOFT_RESET_IN_PROGRESS:\n\t\tgoto schedule_work;\n\tcase MPI3_SYSIF_FAULT_CODE_CI_ACTIVATION_RESET:\n\t\treset_reason = MPI3MR_RESET_FROM_CIACTIV_FAULT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmpi3mr_soft_reset_handler(mrioc, reset_reason, 0);\n\treturn;\n\nschedule_work:\n\tspin_lock_irqsave(&mrioc->watchdog_lock, flags);\n\tif (mrioc->watchdog_work_q)\n\t\tqueue_delayed_work(mrioc->watchdog_work_q,\n\t\t    &mrioc->watchdog_work,\n\t\t    msecs_to_jiffies(MPI3MR_WATCHDOG_INTERVAL));\n\tspin_unlock_irqrestore(&mrioc->watchdog_lock, flags);\n\treturn;\n}\n\n \nvoid mpi3mr_start_watchdog(struct mpi3mr_ioc *mrioc)\n{\n\tif (mrioc->watchdog_work_q)\n\t\treturn;\n\n\tINIT_DELAYED_WORK(&mrioc->watchdog_work, mpi3mr_watchdog_work);\n\tsnprintf(mrioc->watchdog_work_q_name,\n\t    sizeof(mrioc->watchdog_work_q_name), \"watchdog_%s%d\", mrioc->name,\n\t    mrioc->id);\n\tmrioc->watchdog_work_q =\n\t    create_singlethread_workqueue(mrioc->watchdog_work_q_name);\n\tif (!mrioc->watchdog_work_q) {\n\t\tioc_err(mrioc, \"%s: failed (line=%d)\\n\", __func__, __LINE__);\n\t\treturn;\n\t}\n\n\tif (mrioc->watchdog_work_q)\n\t\tqueue_delayed_work(mrioc->watchdog_work_q,\n\t\t    &mrioc->watchdog_work,\n\t\t    msecs_to_jiffies(MPI3MR_WATCHDOG_INTERVAL));\n}\n\n \nvoid mpi3mr_stop_watchdog(struct mpi3mr_ioc *mrioc)\n{\n\tunsigned long flags;\n\tstruct workqueue_struct *wq;\n\n\tspin_lock_irqsave(&mrioc->watchdog_lock, flags);\n\twq = mrioc->watchdog_work_q;\n\tmrioc->watchdog_work_q = NULL;\n\tspin_unlock_irqrestore(&mrioc->watchdog_lock, flags);\n\tif (wq) {\n\t\tif (!cancel_delayed_work_sync(&mrioc->watchdog_work))\n\t\t\tflush_workqueue(wq);\n\t\tdestroy_workqueue(wq);\n\t}\n}\n\n \nstatic int mpi3mr_setup_admin_qpair(struct mpi3mr_ioc *mrioc)\n{\n\tint retval = 0;\n\tu32 num_admin_entries = 0;\n\n\tmrioc->admin_req_q_sz = MPI3MR_ADMIN_REQ_Q_SIZE;\n\tmrioc->num_admin_req = mrioc->admin_req_q_sz /\n\t    MPI3MR_ADMIN_REQ_FRAME_SZ;\n\tmrioc->admin_req_ci = mrioc->admin_req_pi = 0;\n\n\tmrioc->admin_reply_q_sz = MPI3MR_ADMIN_REPLY_Q_SIZE;\n\tmrioc->num_admin_replies = mrioc->admin_reply_q_sz /\n\t    MPI3MR_ADMIN_REPLY_FRAME_SZ;\n\tmrioc->admin_reply_ci = 0;\n\tmrioc->admin_reply_ephase = 1;\n\tatomic_set(&mrioc->admin_reply_q_in_use, 0);\n\n\tif (!mrioc->admin_req_base) {\n\t\tmrioc->admin_req_base = dma_alloc_coherent(&mrioc->pdev->dev,\n\t\t    mrioc->admin_req_q_sz, &mrioc->admin_req_dma, GFP_KERNEL);\n\n\t\tif (!mrioc->admin_req_base) {\n\t\t\tretval = -1;\n\t\t\tgoto out_failed;\n\t\t}\n\n\t\tmrioc->admin_reply_base = dma_alloc_coherent(&mrioc->pdev->dev,\n\t\t    mrioc->admin_reply_q_sz, &mrioc->admin_reply_dma,\n\t\t    GFP_KERNEL);\n\n\t\tif (!mrioc->admin_reply_base) {\n\t\t\tretval = -1;\n\t\t\tgoto out_failed;\n\t\t}\n\t}\n\n\tnum_admin_entries = (mrioc->num_admin_replies << 16) |\n\t    (mrioc->num_admin_req);\n\twritel(num_admin_entries, &mrioc->sysif_regs->admin_queue_num_entries);\n\tmpi3mr_writeq(mrioc->admin_req_dma,\n\t    &mrioc->sysif_regs->admin_request_queue_address);\n\tmpi3mr_writeq(mrioc->admin_reply_dma,\n\t    &mrioc->sysif_regs->admin_reply_queue_address);\n\twritel(mrioc->admin_req_pi, &mrioc->sysif_regs->admin_request_queue_pi);\n\twritel(mrioc->admin_reply_ci, &mrioc->sysif_regs->admin_reply_queue_ci);\n\treturn retval;\n\nout_failed:\n\n\tif (mrioc->admin_reply_base) {\n\t\tdma_free_coherent(&mrioc->pdev->dev, mrioc->admin_reply_q_sz,\n\t\t    mrioc->admin_reply_base, mrioc->admin_reply_dma);\n\t\tmrioc->admin_reply_base = NULL;\n\t}\n\tif (mrioc->admin_req_base) {\n\t\tdma_free_coherent(&mrioc->pdev->dev, mrioc->admin_req_q_sz,\n\t\t    mrioc->admin_req_base, mrioc->admin_req_dma);\n\t\tmrioc->admin_req_base = NULL;\n\t}\n\treturn retval;\n}\n\n \nstatic int mpi3mr_issue_iocfacts(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_ioc_facts_data *facts_data)\n{\n\tstruct mpi3_ioc_facts_request iocfacts_req;\n\tvoid *data = NULL;\n\tdma_addr_t data_dma;\n\tu32 data_len = sizeof(*facts_data);\n\tint retval = 0;\n\tu8 sgl_flags = MPI3MR_SGEFLAGS_SYSTEM_SIMPLE_END_OF_LIST;\n\n\tdata = dma_alloc_coherent(&mrioc->pdev->dev, data_len, &data_dma,\n\t    GFP_KERNEL);\n\n\tif (!data) {\n\t\tretval = -1;\n\t\tgoto out;\n\t}\n\n\tmemset(&iocfacts_req, 0, sizeof(iocfacts_req));\n\tmutex_lock(&mrioc->init_cmds.mutex);\n\tif (mrioc->init_cmds.state & MPI3MR_CMD_PENDING) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"Issue IOCFacts: Init command is in use\\n\");\n\t\tmutex_unlock(&mrioc->init_cmds.mutex);\n\t\tgoto out;\n\t}\n\tmrioc->init_cmds.state = MPI3MR_CMD_PENDING;\n\tmrioc->init_cmds.is_waiting = 1;\n\tmrioc->init_cmds.callback = NULL;\n\tiocfacts_req.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_INITCMDS);\n\tiocfacts_req.function = MPI3_FUNCTION_IOC_FACTS;\n\n\tmpi3mr_add_sg_single(&iocfacts_req.sgl, sgl_flags, data_len,\n\t    data_dma);\n\n\tinit_completion(&mrioc->init_cmds.done);\n\tretval = mpi3mr_admin_request_post(mrioc, &iocfacts_req,\n\t    sizeof(iocfacts_req), 1);\n\tif (retval) {\n\t\tioc_err(mrioc, \"Issue IOCFacts: Admin Post failed\\n\");\n\t\tgoto out_unlock;\n\t}\n\twait_for_completion_timeout(&mrioc->init_cmds.done,\n\t    (MPI3MR_INTADMCMD_TIMEOUT * HZ));\n\tif (!(mrioc->init_cmds.state & MPI3MR_CMD_COMPLETE)) {\n\t\tioc_err(mrioc, \"ioc_facts timed out\\n\");\n\t\tmpi3mr_check_rh_fault_ioc(mrioc,\n\t\t    MPI3MR_RESET_FROM_IOCFACTS_TIMEOUT);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\tif ((mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK)\n\t    != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc,\n\t\t    \"Issue IOCFacts: Failed ioc_status(0x%04x) Loginfo(0x%08x)\\n\",\n\t\t    (mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK),\n\t\t    mrioc->init_cmds.ioc_loginfo);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\tmemcpy(facts_data, (u8 *)data, data_len);\n\tmpi3mr_process_factsdata(mrioc, facts_data);\nout_unlock:\n\tmrioc->init_cmds.state = MPI3MR_CMD_NOTUSED;\n\tmutex_unlock(&mrioc->init_cmds.mutex);\n\nout:\n\tif (data)\n\t\tdma_free_coherent(&mrioc->pdev->dev, data_len, data, data_dma);\n\n\treturn retval;\n}\n\n \nstatic inline int mpi3mr_check_reset_dma_mask(struct mpi3mr_ioc *mrioc)\n{\n\tstruct pci_dev *pdev = mrioc->pdev;\n\tint r;\n\tu64 facts_dma_mask = DMA_BIT_MASK(mrioc->facts.dma_mask);\n\n\tif (!mrioc->facts.dma_mask || (mrioc->dma_mask <= facts_dma_mask))\n\t\treturn 0;\n\n\tioc_info(mrioc, \"Changing DMA mask from 0x%016llx to 0x%016llx\\n\",\n\t    mrioc->dma_mask, facts_dma_mask);\n\n\tr = dma_set_mask_and_coherent(&pdev->dev, facts_dma_mask);\n\tif (r) {\n\t\tioc_err(mrioc, \"Setting DMA mask to 0x%016llx failed: %d\\n\",\n\t\t    facts_dma_mask, r);\n\t\treturn r;\n\t}\n\tmrioc->dma_mask = facts_dma_mask;\n\treturn r;\n}\n\n \nstatic void mpi3mr_process_factsdata(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_ioc_facts_data *facts_data)\n{\n\tu32 ioc_config, req_sz, facts_flags;\n\n\tif ((le16_to_cpu(facts_data->ioc_facts_data_length)) !=\n\t    (sizeof(*facts_data) / 4)) {\n\t\tioc_warn(mrioc,\n\t\t    \"IOCFactsdata length mismatch driver_sz(%zu) firmware_sz(%d)\\n\",\n\t\t    sizeof(*facts_data),\n\t\t    le16_to_cpu(facts_data->ioc_facts_data_length) * 4);\n\t}\n\n\tioc_config = readl(&mrioc->sysif_regs->ioc_configuration);\n\treq_sz = 1 << ((ioc_config & MPI3_SYSIF_IOC_CONFIG_OPER_REQ_ENT_SZ) >>\n\t    MPI3_SYSIF_IOC_CONFIG_OPER_REQ_ENT_SZ_SHIFT);\n\tif (le16_to_cpu(facts_data->ioc_request_frame_size) != (req_sz / 4)) {\n\t\tioc_err(mrioc,\n\t\t    \"IOCFacts data reqFrameSize mismatch hw_size(%d) firmware_sz(%d)\\n\",\n\t\t    req_sz / 4, le16_to_cpu(facts_data->ioc_request_frame_size));\n\t}\n\n\tmemset(&mrioc->facts, 0, sizeof(mrioc->facts));\n\n\tfacts_flags = le32_to_cpu(facts_data->flags);\n\tmrioc->facts.op_req_sz = req_sz;\n\tmrioc->op_reply_desc_sz = 1 << ((ioc_config &\n\t    MPI3_SYSIF_IOC_CONFIG_OPER_RPY_ENT_SZ) >>\n\t    MPI3_SYSIF_IOC_CONFIG_OPER_RPY_ENT_SZ_SHIFT);\n\n\tmrioc->facts.ioc_num = facts_data->ioc_number;\n\tmrioc->facts.who_init = facts_data->who_init;\n\tmrioc->facts.max_msix_vectors = le16_to_cpu(facts_data->max_msix_vectors);\n\tmrioc->facts.personality = (facts_flags &\n\t    MPI3_IOCFACTS_FLAGS_PERSONALITY_MASK);\n\tmrioc->facts.dma_mask = (facts_flags &\n\t    MPI3_IOCFACTS_FLAGS_DMA_ADDRESS_WIDTH_MASK) >>\n\t    MPI3_IOCFACTS_FLAGS_DMA_ADDRESS_WIDTH_SHIFT;\n\tmrioc->facts.protocol_flags = facts_data->protocol_flags;\n\tmrioc->facts.mpi_version = le32_to_cpu(facts_data->mpi_version.word);\n\tmrioc->facts.max_reqs = le16_to_cpu(facts_data->max_outstanding_requests);\n\tmrioc->facts.product_id = le16_to_cpu(facts_data->product_id);\n\tmrioc->facts.reply_sz = le16_to_cpu(facts_data->reply_frame_size) * 4;\n\tmrioc->facts.exceptions = le16_to_cpu(facts_data->ioc_exceptions);\n\tmrioc->facts.max_perids = le16_to_cpu(facts_data->max_persistent_id);\n\tmrioc->facts.max_vds = le16_to_cpu(facts_data->max_vds);\n\tmrioc->facts.max_hpds = le16_to_cpu(facts_data->max_host_pds);\n\tmrioc->facts.max_advhpds = le16_to_cpu(facts_data->max_adv_host_pds);\n\tmrioc->facts.max_raid_pds = le16_to_cpu(facts_data->max_raid_pds);\n\tmrioc->facts.max_nvme = le16_to_cpu(facts_data->max_nvme);\n\tmrioc->facts.max_pcie_switches =\n\t    le16_to_cpu(facts_data->max_pcie_switches);\n\tmrioc->facts.max_sasexpanders =\n\t    le16_to_cpu(facts_data->max_sas_expanders);\n\tmrioc->facts.max_data_length = le16_to_cpu(facts_data->max_data_length);\n\tmrioc->facts.max_sasinitiators =\n\t    le16_to_cpu(facts_data->max_sas_initiators);\n\tmrioc->facts.max_enclosures = le16_to_cpu(facts_data->max_enclosures);\n\tmrioc->facts.min_devhandle = le16_to_cpu(facts_data->min_dev_handle);\n\tmrioc->facts.max_devhandle = le16_to_cpu(facts_data->max_dev_handle);\n\tmrioc->facts.max_op_req_q =\n\t    le16_to_cpu(facts_data->max_operational_request_queues);\n\tmrioc->facts.max_op_reply_q =\n\t    le16_to_cpu(facts_data->max_operational_reply_queues);\n\tmrioc->facts.ioc_capabilities =\n\t    le32_to_cpu(facts_data->ioc_capabilities);\n\tmrioc->facts.fw_ver.build_num =\n\t    le16_to_cpu(facts_data->fw_version.build_num);\n\tmrioc->facts.fw_ver.cust_id =\n\t    le16_to_cpu(facts_data->fw_version.customer_id);\n\tmrioc->facts.fw_ver.ph_minor = facts_data->fw_version.phase_minor;\n\tmrioc->facts.fw_ver.ph_major = facts_data->fw_version.phase_major;\n\tmrioc->facts.fw_ver.gen_minor = facts_data->fw_version.gen_minor;\n\tmrioc->facts.fw_ver.gen_major = facts_data->fw_version.gen_major;\n\tmrioc->msix_count = min_t(int, mrioc->msix_count,\n\t    mrioc->facts.max_msix_vectors);\n\tmrioc->facts.sge_mod_mask = facts_data->sge_modifier_mask;\n\tmrioc->facts.sge_mod_value = facts_data->sge_modifier_value;\n\tmrioc->facts.sge_mod_shift = facts_data->sge_modifier_shift;\n\tmrioc->facts.shutdown_timeout =\n\t    le16_to_cpu(facts_data->shutdown_timeout);\n\n\tmrioc->facts.max_dev_per_tg =\n\t    facts_data->max_devices_per_throttle_group;\n\tmrioc->facts.io_throttle_data_length =\n\t    le16_to_cpu(facts_data->io_throttle_data_length);\n\tmrioc->facts.max_io_throttle_group =\n\t    le16_to_cpu(facts_data->max_io_throttle_group);\n\tmrioc->facts.io_throttle_low = le16_to_cpu(facts_data->io_throttle_low);\n\tmrioc->facts.io_throttle_high =\n\t    le16_to_cpu(facts_data->io_throttle_high);\n\n\tif (mrioc->facts.max_data_length ==\n\t    MPI3_IOCFACTS_MAX_DATA_LENGTH_NOT_REPORTED)\n\t\tmrioc->facts.max_data_length = MPI3MR_DEFAULT_MAX_IO_SIZE;\n\telse\n\t\tmrioc->facts.max_data_length *= MPI3MR_PAGE_SIZE_4K;\n\t \n\tif (mrioc->facts.io_throttle_data_length)\n\t\tmrioc->io_throttle_data_length =\n\t\t    (mrioc->facts.io_throttle_data_length * 2 * 4);\n\telse\n\t\t \n\t\tmrioc->io_throttle_data_length = (mrioc->facts.max_data_length / 512) + 2;\n\n\tmrioc->io_throttle_high = (mrioc->facts.io_throttle_high * 2 * 1024);\n\tmrioc->io_throttle_low = (mrioc->facts.io_throttle_low * 2 * 1024);\n\n\tioc_info(mrioc, \"ioc_num(%d), maxopQ(%d), maxopRepQ(%d), maxdh(%d),\",\n\t    mrioc->facts.ioc_num, mrioc->facts.max_op_req_q,\n\t    mrioc->facts.max_op_reply_q, mrioc->facts.max_devhandle);\n\tioc_info(mrioc,\n\t    \"maxreqs(%d), mindh(%d) maxvectors(%d) maxperids(%d)\\n\",\n\t    mrioc->facts.max_reqs, mrioc->facts.min_devhandle,\n\t    mrioc->facts.max_msix_vectors, mrioc->facts.max_perids);\n\tioc_info(mrioc, \"SGEModMask 0x%x SGEModVal 0x%x SGEModShift 0x%x \",\n\t    mrioc->facts.sge_mod_mask, mrioc->facts.sge_mod_value,\n\t    mrioc->facts.sge_mod_shift);\n\tioc_info(mrioc, \"DMA mask %d InitialPE status 0x%x max_data_len (%d)\\n\",\n\t    mrioc->facts.dma_mask, (facts_flags &\n\t    MPI3_IOCFACTS_FLAGS_INITIAL_PORT_ENABLE_MASK), mrioc->facts.max_data_length);\n\tioc_info(mrioc,\n\t    \"max_dev_per_throttle_group(%d), max_throttle_groups(%d)\\n\",\n\t    mrioc->facts.max_dev_per_tg, mrioc->facts.max_io_throttle_group);\n\tioc_info(mrioc,\n\t   \"io_throttle_data_len(%dKiB), io_throttle_high(%dMiB), io_throttle_low(%dMiB)\\n\",\n\t   mrioc->facts.io_throttle_data_length * 4,\n\t   mrioc->facts.io_throttle_high, mrioc->facts.io_throttle_low);\n}\n\n \nstatic int mpi3mr_alloc_reply_sense_bufs(struct mpi3mr_ioc *mrioc)\n{\n\tint retval = 0;\n\tu32 sz, i;\n\n\tif (mrioc->init_cmds.reply)\n\t\treturn retval;\n\n\tmrioc->init_cmds.reply = kzalloc(mrioc->reply_sz, GFP_KERNEL);\n\tif (!mrioc->init_cmds.reply)\n\t\tgoto out_failed;\n\n\tmrioc->bsg_cmds.reply = kzalloc(mrioc->reply_sz, GFP_KERNEL);\n\tif (!mrioc->bsg_cmds.reply)\n\t\tgoto out_failed;\n\n\tmrioc->transport_cmds.reply = kzalloc(mrioc->reply_sz, GFP_KERNEL);\n\tif (!mrioc->transport_cmds.reply)\n\t\tgoto out_failed;\n\n\tfor (i = 0; i < MPI3MR_NUM_DEVRMCMD; i++) {\n\t\tmrioc->dev_rmhs_cmds[i].reply = kzalloc(mrioc->reply_sz,\n\t\t    GFP_KERNEL);\n\t\tif (!mrioc->dev_rmhs_cmds[i].reply)\n\t\t\tgoto out_failed;\n\t}\n\n\tfor (i = 0; i < MPI3MR_NUM_EVTACKCMD; i++) {\n\t\tmrioc->evtack_cmds[i].reply = kzalloc(mrioc->reply_sz,\n\t\t    GFP_KERNEL);\n\t\tif (!mrioc->evtack_cmds[i].reply)\n\t\t\tgoto out_failed;\n\t}\n\n\tmrioc->host_tm_cmds.reply = kzalloc(mrioc->reply_sz, GFP_KERNEL);\n\tif (!mrioc->host_tm_cmds.reply)\n\t\tgoto out_failed;\n\n\tmrioc->pel_cmds.reply = kzalloc(mrioc->reply_sz, GFP_KERNEL);\n\tif (!mrioc->pel_cmds.reply)\n\t\tgoto out_failed;\n\n\tmrioc->pel_abort_cmd.reply = kzalloc(mrioc->reply_sz, GFP_KERNEL);\n\tif (!mrioc->pel_abort_cmd.reply)\n\t\tgoto out_failed;\n\n\tmrioc->dev_handle_bitmap_bits = mrioc->facts.max_devhandle;\n\tmrioc->removepend_bitmap = bitmap_zalloc(mrioc->dev_handle_bitmap_bits,\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!mrioc->removepend_bitmap)\n\t\tgoto out_failed;\n\n\tmrioc->devrem_bitmap = bitmap_zalloc(MPI3MR_NUM_DEVRMCMD, GFP_KERNEL);\n\tif (!mrioc->devrem_bitmap)\n\t\tgoto out_failed;\n\n\tmrioc->evtack_cmds_bitmap = bitmap_zalloc(MPI3MR_NUM_EVTACKCMD,\n\t\t\t\t\t\t  GFP_KERNEL);\n\tif (!mrioc->evtack_cmds_bitmap)\n\t\tgoto out_failed;\n\n\tmrioc->num_reply_bufs = mrioc->facts.max_reqs + MPI3MR_NUM_EVT_REPLIES;\n\tmrioc->reply_free_qsz = mrioc->num_reply_bufs + 1;\n\tmrioc->num_sense_bufs = mrioc->facts.max_reqs / MPI3MR_SENSEBUF_FACTOR;\n\tmrioc->sense_buf_q_sz = mrioc->num_sense_bufs + 1;\n\n\t \n\tsz = mrioc->num_reply_bufs * mrioc->reply_sz;\n\tmrioc->reply_buf_pool = dma_pool_create(\"reply_buf pool\",\n\t    &mrioc->pdev->dev, sz, 16, 0);\n\tif (!mrioc->reply_buf_pool) {\n\t\tioc_err(mrioc, \"reply buf pool: dma_pool_create failed\\n\");\n\t\tgoto out_failed;\n\t}\n\n\tmrioc->reply_buf = dma_pool_zalloc(mrioc->reply_buf_pool, GFP_KERNEL,\n\t    &mrioc->reply_buf_dma);\n\tif (!mrioc->reply_buf)\n\t\tgoto out_failed;\n\n\tmrioc->reply_buf_dma_max_address = mrioc->reply_buf_dma + sz;\n\n\t \n\tsz = mrioc->reply_free_qsz * 8;\n\tmrioc->reply_free_q_pool = dma_pool_create(\"reply_free_q pool\",\n\t    &mrioc->pdev->dev, sz, 8, 0);\n\tif (!mrioc->reply_free_q_pool) {\n\t\tioc_err(mrioc, \"reply_free_q pool: dma_pool_create failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tmrioc->reply_free_q = dma_pool_zalloc(mrioc->reply_free_q_pool,\n\t    GFP_KERNEL, &mrioc->reply_free_q_dma);\n\tif (!mrioc->reply_free_q)\n\t\tgoto out_failed;\n\n\t \n\tsz = mrioc->num_sense_bufs * MPI3MR_SENSE_BUF_SZ;\n\tmrioc->sense_buf_pool = dma_pool_create(\"sense_buf pool\",\n\t    &mrioc->pdev->dev, sz, 4, 0);\n\tif (!mrioc->sense_buf_pool) {\n\t\tioc_err(mrioc, \"sense_buf pool: dma_pool_create failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tmrioc->sense_buf = dma_pool_zalloc(mrioc->sense_buf_pool, GFP_KERNEL,\n\t    &mrioc->sense_buf_dma);\n\tif (!mrioc->sense_buf)\n\t\tgoto out_failed;\n\n\t \n\tsz = mrioc->sense_buf_q_sz * 8;\n\tmrioc->sense_buf_q_pool = dma_pool_create(\"sense_buf_q pool\",\n\t    &mrioc->pdev->dev, sz, 8, 0);\n\tif (!mrioc->sense_buf_q_pool) {\n\t\tioc_err(mrioc, \"sense_buf_q pool: dma_pool_create failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tmrioc->sense_buf_q = dma_pool_zalloc(mrioc->sense_buf_q_pool,\n\t    GFP_KERNEL, &mrioc->sense_buf_q_dma);\n\tif (!mrioc->sense_buf_q)\n\t\tgoto out_failed;\n\n\treturn retval;\n\nout_failed:\n\tretval = -1;\n\treturn retval;\n}\n\n \nstatic void mpimr_initialize_reply_sbuf_queues(struct mpi3mr_ioc *mrioc)\n{\n\tu32 sz, i;\n\tdma_addr_t phy_addr;\n\n\tsz = mrioc->num_reply_bufs * mrioc->reply_sz;\n\tioc_info(mrioc,\n\t    \"reply buf pool(0x%p): depth(%d), frame_size(%d), pool_size(%d kB), reply_dma(0x%llx)\\n\",\n\t    mrioc->reply_buf, mrioc->num_reply_bufs, mrioc->reply_sz,\n\t    (sz / 1024), (unsigned long long)mrioc->reply_buf_dma);\n\tsz = mrioc->reply_free_qsz * 8;\n\tioc_info(mrioc,\n\t    \"reply_free_q pool(0x%p): depth(%d), frame_size(%d), pool_size(%d kB), reply_dma(0x%llx)\\n\",\n\t    mrioc->reply_free_q, mrioc->reply_free_qsz, 8, (sz / 1024),\n\t    (unsigned long long)mrioc->reply_free_q_dma);\n\tsz = mrioc->num_sense_bufs * MPI3MR_SENSE_BUF_SZ;\n\tioc_info(mrioc,\n\t    \"sense_buf pool(0x%p): depth(%d), frame_size(%d), pool_size(%d kB), sense_dma(0x%llx)\\n\",\n\t    mrioc->sense_buf, mrioc->num_sense_bufs, MPI3MR_SENSE_BUF_SZ,\n\t    (sz / 1024), (unsigned long long)mrioc->sense_buf_dma);\n\tsz = mrioc->sense_buf_q_sz * 8;\n\tioc_info(mrioc,\n\t    \"sense_buf_q pool(0x%p): depth(%d), frame_size(%d), pool_size(%d kB), sense_dma(0x%llx)\\n\",\n\t    mrioc->sense_buf_q, mrioc->sense_buf_q_sz, 8, (sz / 1024),\n\t    (unsigned long long)mrioc->sense_buf_q_dma);\n\n\t \n\tfor (i = 0, phy_addr = mrioc->reply_buf_dma;\n\t    i < mrioc->num_reply_bufs; i++, phy_addr += mrioc->reply_sz)\n\t\tmrioc->reply_free_q[i] = cpu_to_le64(phy_addr);\n\tmrioc->reply_free_q[i] = cpu_to_le64(0);\n\n\t \n\tfor (i = 0, phy_addr = mrioc->sense_buf_dma;\n\t    i < mrioc->num_sense_bufs; i++, phy_addr += MPI3MR_SENSE_BUF_SZ)\n\t\tmrioc->sense_buf_q[i] = cpu_to_le64(phy_addr);\n\tmrioc->sense_buf_q[i] = cpu_to_le64(0);\n}\n\n \nstatic int mpi3mr_issue_iocinit(struct mpi3mr_ioc *mrioc)\n{\n\tstruct mpi3_ioc_init_request iocinit_req;\n\tstruct mpi3_driver_info_layout *drv_info;\n\tdma_addr_t data_dma;\n\tu32 data_len = sizeof(*drv_info);\n\tint retval = 0;\n\tktime_t current_time;\n\n\tdrv_info = dma_alloc_coherent(&mrioc->pdev->dev, data_len, &data_dma,\n\t    GFP_KERNEL);\n\tif (!drv_info) {\n\t\tretval = -1;\n\t\tgoto out;\n\t}\n\tmpimr_initialize_reply_sbuf_queues(mrioc);\n\n\tdrv_info->information_length = cpu_to_le32(data_len);\n\tstrscpy(drv_info->driver_signature, \"Broadcom\", sizeof(drv_info->driver_signature));\n\tstrscpy(drv_info->os_name, utsname()->sysname, sizeof(drv_info->os_name));\n\tstrscpy(drv_info->os_version, utsname()->release, sizeof(drv_info->os_version));\n\tstrscpy(drv_info->driver_name, MPI3MR_DRIVER_NAME, sizeof(drv_info->driver_name));\n\tstrscpy(drv_info->driver_version, MPI3MR_DRIVER_VERSION, sizeof(drv_info->driver_version));\n\tstrscpy(drv_info->driver_release_date, MPI3MR_DRIVER_RELDATE,\n\t    sizeof(drv_info->driver_release_date));\n\tdrv_info->driver_capabilities = 0;\n\tmemcpy((u8 *)&mrioc->driver_info, (u8 *)drv_info,\n\t    sizeof(mrioc->driver_info));\n\n\tmemset(&iocinit_req, 0, sizeof(iocinit_req));\n\tmutex_lock(&mrioc->init_cmds.mutex);\n\tif (mrioc->init_cmds.state & MPI3MR_CMD_PENDING) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"Issue IOCInit: Init command is in use\\n\");\n\t\tmutex_unlock(&mrioc->init_cmds.mutex);\n\t\tgoto out;\n\t}\n\tmrioc->init_cmds.state = MPI3MR_CMD_PENDING;\n\tmrioc->init_cmds.is_waiting = 1;\n\tmrioc->init_cmds.callback = NULL;\n\tiocinit_req.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_INITCMDS);\n\tiocinit_req.function = MPI3_FUNCTION_IOC_INIT;\n\tiocinit_req.mpi_version.mpi3_version.dev = MPI3_VERSION_DEV;\n\tiocinit_req.mpi_version.mpi3_version.unit = MPI3_VERSION_UNIT;\n\tiocinit_req.mpi_version.mpi3_version.major = MPI3_VERSION_MAJOR;\n\tiocinit_req.mpi_version.mpi3_version.minor = MPI3_VERSION_MINOR;\n\tiocinit_req.who_init = MPI3_WHOINIT_HOST_DRIVER;\n\tiocinit_req.reply_free_queue_depth = cpu_to_le16(mrioc->reply_free_qsz);\n\tiocinit_req.reply_free_queue_address =\n\t    cpu_to_le64(mrioc->reply_free_q_dma);\n\tiocinit_req.sense_buffer_length = cpu_to_le16(MPI3MR_SENSE_BUF_SZ);\n\tiocinit_req.sense_buffer_free_queue_depth =\n\t    cpu_to_le16(mrioc->sense_buf_q_sz);\n\tiocinit_req.sense_buffer_free_queue_address =\n\t    cpu_to_le64(mrioc->sense_buf_q_dma);\n\tiocinit_req.driver_information_address = cpu_to_le64(data_dma);\n\n\tcurrent_time = ktime_get_real();\n\tiocinit_req.time_stamp = cpu_to_le64(ktime_to_ms(current_time));\n\n\tinit_completion(&mrioc->init_cmds.done);\n\tretval = mpi3mr_admin_request_post(mrioc, &iocinit_req,\n\t    sizeof(iocinit_req), 1);\n\tif (retval) {\n\t\tioc_err(mrioc, \"Issue IOCInit: Admin Post failed\\n\");\n\t\tgoto out_unlock;\n\t}\n\twait_for_completion_timeout(&mrioc->init_cmds.done,\n\t    (MPI3MR_INTADMCMD_TIMEOUT * HZ));\n\tif (!(mrioc->init_cmds.state & MPI3MR_CMD_COMPLETE)) {\n\t\tmpi3mr_check_rh_fault_ioc(mrioc,\n\t\t    MPI3MR_RESET_FROM_IOCINIT_TIMEOUT);\n\t\tioc_err(mrioc, \"ioc_init timed out\\n\");\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\tif ((mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK)\n\t    != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc,\n\t\t    \"Issue IOCInit: Failed ioc_status(0x%04x) Loginfo(0x%08x)\\n\",\n\t\t    (mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK),\n\t\t    mrioc->init_cmds.ioc_loginfo);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\n\tmrioc->reply_free_queue_host_index = mrioc->num_reply_bufs;\n\twritel(mrioc->reply_free_queue_host_index,\n\t    &mrioc->sysif_regs->reply_free_host_index);\n\n\tmrioc->sbq_host_index = mrioc->num_sense_bufs;\n\twritel(mrioc->sbq_host_index,\n\t    &mrioc->sysif_regs->sense_buffer_free_host_index);\nout_unlock:\n\tmrioc->init_cmds.state = MPI3MR_CMD_NOTUSED;\n\tmutex_unlock(&mrioc->init_cmds.mutex);\n\nout:\n\tif (drv_info)\n\t\tdma_free_coherent(&mrioc->pdev->dev, data_len, drv_info,\n\t\t    data_dma);\n\n\treturn retval;\n}\n\n \nstatic void mpi3mr_unmask_events(struct mpi3mr_ioc *mrioc, u16 event)\n{\n\tu32 desired_event;\n\tu8 word;\n\n\tif (event >= 128)\n\t\treturn;\n\n\tdesired_event = (1 << (event % 32));\n\tword = event / 32;\n\n\tmrioc->event_masks[word] &= ~desired_event;\n}\n\n \nstatic int mpi3mr_issue_event_notification(struct mpi3mr_ioc *mrioc)\n{\n\tstruct mpi3_event_notification_request evtnotify_req;\n\tint retval = 0;\n\tu8 i;\n\n\tmemset(&evtnotify_req, 0, sizeof(evtnotify_req));\n\tmutex_lock(&mrioc->init_cmds.mutex);\n\tif (mrioc->init_cmds.state & MPI3MR_CMD_PENDING) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"Issue EvtNotify: Init command is in use\\n\");\n\t\tmutex_unlock(&mrioc->init_cmds.mutex);\n\t\tgoto out;\n\t}\n\tmrioc->init_cmds.state = MPI3MR_CMD_PENDING;\n\tmrioc->init_cmds.is_waiting = 1;\n\tmrioc->init_cmds.callback = NULL;\n\tevtnotify_req.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_INITCMDS);\n\tevtnotify_req.function = MPI3_FUNCTION_EVENT_NOTIFICATION;\n\tfor (i = 0; i < MPI3_EVENT_NOTIFY_EVENTMASK_WORDS; i++)\n\t\tevtnotify_req.event_masks[i] =\n\t\t    cpu_to_le32(mrioc->event_masks[i]);\n\tinit_completion(&mrioc->init_cmds.done);\n\tretval = mpi3mr_admin_request_post(mrioc, &evtnotify_req,\n\t    sizeof(evtnotify_req), 1);\n\tif (retval) {\n\t\tioc_err(mrioc, \"Issue EvtNotify: Admin Post failed\\n\");\n\t\tgoto out_unlock;\n\t}\n\twait_for_completion_timeout(&mrioc->init_cmds.done,\n\t    (MPI3MR_INTADMCMD_TIMEOUT * HZ));\n\tif (!(mrioc->init_cmds.state & MPI3MR_CMD_COMPLETE)) {\n\t\tioc_err(mrioc, \"event notification timed out\\n\");\n\t\tmpi3mr_check_rh_fault_ioc(mrioc,\n\t\t    MPI3MR_RESET_FROM_EVTNOTIFY_TIMEOUT);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\tif ((mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK)\n\t    != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc,\n\t\t    \"Issue EvtNotify: Failed ioc_status(0x%04x) Loginfo(0x%08x)\\n\",\n\t\t    (mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK),\n\t\t    mrioc->init_cmds.ioc_loginfo);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmrioc->init_cmds.state = MPI3MR_CMD_NOTUSED;\n\tmutex_unlock(&mrioc->init_cmds.mutex);\nout:\n\treturn retval;\n}\n\n \nint mpi3mr_process_event_ack(struct mpi3mr_ioc *mrioc, u8 event,\n\tu32 event_ctx)\n{\n\tstruct mpi3_event_ack_request evtack_req;\n\tint retval = 0;\n\n\tmemset(&evtack_req, 0, sizeof(evtack_req));\n\tmutex_lock(&mrioc->init_cmds.mutex);\n\tif (mrioc->init_cmds.state & MPI3MR_CMD_PENDING) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"Send EvtAck: Init command is in use\\n\");\n\t\tmutex_unlock(&mrioc->init_cmds.mutex);\n\t\tgoto out;\n\t}\n\tmrioc->init_cmds.state = MPI3MR_CMD_PENDING;\n\tmrioc->init_cmds.is_waiting = 1;\n\tmrioc->init_cmds.callback = NULL;\n\tevtack_req.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_INITCMDS);\n\tevtack_req.function = MPI3_FUNCTION_EVENT_ACK;\n\tevtack_req.event = event;\n\tevtack_req.event_context = cpu_to_le32(event_ctx);\n\n\tinit_completion(&mrioc->init_cmds.done);\n\tretval = mpi3mr_admin_request_post(mrioc, &evtack_req,\n\t    sizeof(evtack_req), 1);\n\tif (retval) {\n\t\tioc_err(mrioc, \"Send EvtAck: Admin Post failed\\n\");\n\t\tgoto out_unlock;\n\t}\n\twait_for_completion_timeout(&mrioc->init_cmds.done,\n\t    (MPI3MR_INTADMCMD_TIMEOUT * HZ));\n\tif (!(mrioc->init_cmds.state & MPI3MR_CMD_COMPLETE)) {\n\t\tioc_err(mrioc, \"Issue EvtNotify: command timed out\\n\");\n\t\tif (!(mrioc->init_cmds.state & MPI3MR_CMD_RESET))\n\t\t\tmpi3mr_check_rh_fault_ioc(mrioc,\n\t\t\t    MPI3MR_RESET_FROM_EVTACK_TIMEOUT);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\tif ((mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK)\n\t    != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc,\n\t\t    \"Send EvtAck: Failed ioc_status(0x%04x) Loginfo(0x%08x)\\n\",\n\t\t    (mrioc->init_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK),\n\t\t    mrioc->init_cmds.ioc_loginfo);\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmrioc->init_cmds.state = MPI3MR_CMD_NOTUSED;\n\tmutex_unlock(&mrioc->init_cmds.mutex);\nout:\n\treturn retval;\n}\n\n \nstatic int mpi3mr_alloc_chain_bufs(struct mpi3mr_ioc *mrioc)\n{\n\tint retval = 0;\n\tu32 sz, i;\n\tu16 num_chains;\n\n\tif (mrioc->chain_sgl_list)\n\t\treturn retval;\n\n\tnum_chains = mrioc->max_host_ios / MPI3MR_CHAINBUF_FACTOR;\n\n\tif (prot_mask & (SHOST_DIX_TYPE0_PROTECTION\n\t    | SHOST_DIX_TYPE1_PROTECTION\n\t    | SHOST_DIX_TYPE2_PROTECTION\n\t    | SHOST_DIX_TYPE3_PROTECTION))\n\t\tnum_chains += (num_chains / MPI3MR_CHAINBUFDIX_FACTOR);\n\n\tmrioc->chain_buf_count = num_chains;\n\tsz = sizeof(struct chain_element) * num_chains;\n\tmrioc->chain_sgl_list = kzalloc(sz, GFP_KERNEL);\n\tif (!mrioc->chain_sgl_list)\n\t\tgoto out_failed;\n\n\tif (mrioc->max_sgl_entries > (mrioc->facts.max_data_length /\n\t\tMPI3MR_PAGE_SIZE_4K))\n\t\tmrioc->max_sgl_entries = mrioc->facts.max_data_length /\n\t\t\tMPI3MR_PAGE_SIZE_4K;\n\tsz = mrioc->max_sgl_entries * sizeof(struct mpi3_sge_common);\n\tioc_info(mrioc, \"number of sgl entries=%d chain buffer size=%dKB\\n\",\n\t\t\tmrioc->max_sgl_entries, sz/1024);\n\n\tmrioc->chain_buf_pool = dma_pool_create(\"chain_buf pool\",\n\t    &mrioc->pdev->dev, sz, 16, 0);\n\tif (!mrioc->chain_buf_pool) {\n\t\tioc_err(mrioc, \"chain buf pool: dma_pool_create failed\\n\");\n\t\tgoto out_failed;\n\t}\n\n\tfor (i = 0; i < num_chains; i++) {\n\t\tmrioc->chain_sgl_list[i].addr =\n\t\t    dma_pool_zalloc(mrioc->chain_buf_pool, GFP_KERNEL,\n\t\t    &mrioc->chain_sgl_list[i].dma_addr);\n\n\t\tif (!mrioc->chain_sgl_list[i].addr)\n\t\t\tgoto out_failed;\n\t}\n\tmrioc->chain_bitmap = bitmap_zalloc(num_chains, GFP_KERNEL);\n\tif (!mrioc->chain_bitmap)\n\t\tgoto out_failed;\n\treturn retval;\nout_failed:\n\tretval = -1;\n\treturn retval;\n}\n\n \nstatic void mpi3mr_port_enable_complete(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_drv_cmd *drv_cmd)\n{\n\tdrv_cmd->callback = NULL;\n\tmrioc->scan_started = 0;\n\tif (drv_cmd->state & MPI3MR_CMD_RESET)\n\t\tmrioc->scan_failed = MPI3_IOCSTATUS_INTERNAL_ERROR;\n\telse\n\t\tmrioc->scan_failed = drv_cmd->ioc_status;\n\tdrv_cmd->state = MPI3MR_CMD_NOTUSED;\n}\n\n \nint mpi3mr_issue_port_enable(struct mpi3mr_ioc *mrioc, u8 async)\n{\n\tstruct mpi3_port_enable_request pe_req;\n\tint retval = 0;\n\tu32 pe_timeout = MPI3MR_PORTENABLE_TIMEOUT;\n\n\tmemset(&pe_req, 0, sizeof(pe_req));\n\tmutex_lock(&mrioc->init_cmds.mutex);\n\tif (mrioc->init_cmds.state & MPI3MR_CMD_PENDING) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"Issue PortEnable: Init command is in use\\n\");\n\t\tmutex_unlock(&mrioc->init_cmds.mutex);\n\t\tgoto out;\n\t}\n\tmrioc->init_cmds.state = MPI3MR_CMD_PENDING;\n\tif (async) {\n\t\tmrioc->init_cmds.is_waiting = 0;\n\t\tmrioc->init_cmds.callback = mpi3mr_port_enable_complete;\n\t} else {\n\t\tmrioc->init_cmds.is_waiting = 1;\n\t\tmrioc->init_cmds.callback = NULL;\n\t\tinit_completion(&mrioc->init_cmds.done);\n\t}\n\tpe_req.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_INITCMDS);\n\tpe_req.function = MPI3_FUNCTION_PORT_ENABLE;\n\n\tretval = mpi3mr_admin_request_post(mrioc, &pe_req, sizeof(pe_req), 1);\n\tif (retval) {\n\t\tioc_err(mrioc, \"Issue PortEnable: Admin Post failed\\n\");\n\t\tgoto out_unlock;\n\t}\n\tif (async) {\n\t\tmutex_unlock(&mrioc->init_cmds.mutex);\n\t\tgoto out;\n\t}\n\n\twait_for_completion_timeout(&mrioc->init_cmds.done, (pe_timeout * HZ));\n\tif (!(mrioc->init_cmds.state & MPI3MR_CMD_COMPLETE)) {\n\t\tioc_err(mrioc, \"port enable timed out\\n\");\n\t\tretval = -1;\n\t\tmpi3mr_check_rh_fault_ioc(mrioc, MPI3MR_RESET_FROM_PE_TIMEOUT);\n\t\tgoto out_unlock;\n\t}\n\tmpi3mr_port_enable_complete(mrioc, &mrioc->init_cmds);\n\nout_unlock:\n\tmrioc->init_cmds.state = MPI3MR_CMD_NOTUSED;\n\tmutex_unlock(&mrioc->init_cmds.mutex);\nout:\n\treturn retval;\n}\n\n \nstatic const struct {\n\tu8 protocol;\n\tchar *name;\n} mpi3mr_protocols[] = {\n\t{ MPI3_IOCFACTS_PROTOCOL_SCSI_INITIATOR, \"Initiator\" },\n\t{ MPI3_IOCFACTS_PROTOCOL_SCSI_TARGET, \"Target\" },\n\t{ MPI3_IOCFACTS_PROTOCOL_NVME, \"NVMe attachment\" },\n};\n\n \nstatic const struct {\n\tu32 capability;\n\tchar *name;\n} mpi3mr_capabilities[] = {\n\t{ MPI3_IOCFACTS_CAPABILITY_RAID_CAPABLE, \"RAID\" },\n\t{ MPI3_IOCFACTS_CAPABILITY_MULTIPATH_ENABLED, \"MultiPath\" },\n};\n\n \nstatic void\nmpi3mr_print_ioc_info(struct mpi3mr_ioc *mrioc)\n{\n\tint i = 0, bytes_written = 0;\n\tchar personality[16];\n\tchar protocol[50] = {0};\n\tchar capabilities[100] = {0};\n\tstruct mpi3mr_compimg_ver *fwver = &mrioc->facts.fw_ver;\n\n\tswitch (mrioc->facts.personality) {\n\tcase MPI3_IOCFACTS_FLAGS_PERSONALITY_EHBA:\n\t\tstrncpy(personality, \"Enhanced HBA\", sizeof(personality));\n\t\tbreak;\n\tcase MPI3_IOCFACTS_FLAGS_PERSONALITY_RAID_DDR:\n\t\tstrncpy(personality, \"RAID\", sizeof(personality));\n\t\tbreak;\n\tdefault:\n\t\tstrncpy(personality, \"Unknown\", sizeof(personality));\n\t\tbreak;\n\t}\n\n\tioc_info(mrioc, \"Running in %s Personality\", personality);\n\n\tioc_info(mrioc, \"FW version(%d.%d.%d.%d.%d.%d)\\n\",\n\t    fwver->gen_major, fwver->gen_minor, fwver->ph_major,\n\t    fwver->ph_minor, fwver->cust_id, fwver->build_num);\n\n\tfor (i = 0; i < ARRAY_SIZE(mpi3mr_protocols); i++) {\n\t\tif (mrioc->facts.protocol_flags &\n\t\t    mpi3mr_protocols[i].protocol) {\n\t\t\tbytes_written += scnprintf(protocol + bytes_written,\n\t\t\t\t    sizeof(protocol) - bytes_written, \"%s%s\",\n\t\t\t\t    bytes_written ? \",\" : \"\",\n\t\t\t\t    mpi3mr_protocols[i].name);\n\t\t}\n\t}\n\n\tbytes_written = 0;\n\tfor (i = 0; i < ARRAY_SIZE(mpi3mr_capabilities); i++) {\n\t\tif (mrioc->facts.protocol_flags &\n\t\t    mpi3mr_capabilities[i].capability) {\n\t\t\tbytes_written += scnprintf(capabilities + bytes_written,\n\t\t\t\t    sizeof(capabilities) - bytes_written, \"%s%s\",\n\t\t\t\t    bytes_written ? \",\" : \"\",\n\t\t\t\t    mpi3mr_capabilities[i].name);\n\t\t}\n\t}\n\n\tioc_info(mrioc, \"Protocol=(%s), Capabilities=(%s)\\n\",\n\t\t protocol, capabilities);\n}\n\n \nvoid mpi3mr_cleanup_resources(struct mpi3mr_ioc *mrioc)\n{\n\tstruct pci_dev *pdev = mrioc->pdev;\n\n\tmpi3mr_cleanup_isr(mrioc);\n\n\tif (mrioc->sysif_regs) {\n\t\tiounmap((void __iomem *)mrioc->sysif_regs);\n\t\tmrioc->sysif_regs = NULL;\n\t}\n\n\tif (pci_is_enabled(pdev)) {\n\t\tif (mrioc->bars)\n\t\t\tpci_release_selected_regions(pdev, mrioc->bars);\n\t\tpci_disable_device(pdev);\n\t}\n}\n\n \nint mpi3mr_setup_resources(struct mpi3mr_ioc *mrioc)\n{\n\tstruct pci_dev *pdev = mrioc->pdev;\n\tu32 memap_sz = 0;\n\tint i, retval = 0, capb = 0;\n\tu16 message_control;\n\tu64 dma_mask = mrioc->dma_mask ? mrioc->dma_mask :\n\t    ((sizeof(dma_addr_t) > 4) ? DMA_BIT_MASK(64) : DMA_BIT_MASK(32));\n\n\tif (pci_enable_device_mem(pdev)) {\n\t\tioc_err(mrioc, \"pci_enable_device_mem: failed\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto out_failed;\n\t}\n\n\tcapb = pci_find_capability(pdev, PCI_CAP_ID_MSIX);\n\tif (!capb) {\n\t\tioc_err(mrioc, \"Unable to find MSI-X Capabilities\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto out_failed;\n\t}\n\tmrioc->bars = pci_select_bars(pdev, IORESOURCE_MEM);\n\n\tif (pci_request_selected_regions(pdev, mrioc->bars,\n\t    mrioc->driver_name)) {\n\t\tioc_err(mrioc, \"pci_request_selected_regions: failed\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto out_failed;\n\t}\n\n\tfor (i = 0; (i < DEVICE_COUNT_RESOURCE); i++) {\n\t\tif (pci_resource_flags(pdev, i) & IORESOURCE_MEM) {\n\t\t\tmrioc->sysif_regs_phys = pci_resource_start(pdev, i);\n\t\t\tmemap_sz = pci_resource_len(pdev, i);\n\t\t\tmrioc->sysif_regs =\n\t\t\t    ioremap(mrioc->sysif_regs_phys, memap_sz);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpci_set_master(pdev);\n\n\tretval = dma_set_mask_and_coherent(&pdev->dev, dma_mask);\n\tif (retval) {\n\t\tif (dma_mask != DMA_BIT_MASK(32)) {\n\t\t\tioc_warn(mrioc, \"Setting 64 bit DMA mask failed\\n\");\n\t\t\tdma_mask = DMA_BIT_MASK(32);\n\t\t\tretval = dma_set_mask_and_coherent(&pdev->dev,\n\t\t\t    dma_mask);\n\t\t}\n\t\tif (retval) {\n\t\t\tmrioc->dma_mask = 0;\n\t\t\tioc_err(mrioc, \"Setting 32 bit DMA mask also failed\\n\");\n\t\t\tgoto out_failed;\n\t\t}\n\t}\n\tmrioc->dma_mask = dma_mask;\n\n\tif (!mrioc->sysif_regs) {\n\t\tioc_err(mrioc,\n\t\t    \"Unable to map adapter memory or resource not found\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto out_failed;\n\t}\n\n\tpci_read_config_word(pdev, capb + 2, &message_control);\n\tmrioc->msix_count = (message_control & 0x3FF) + 1;\n\n\tpci_save_state(pdev);\n\n\tpci_set_drvdata(pdev, mrioc->shost);\n\n\tmpi3mr_ioc_disable_intr(mrioc);\n\n\tioc_info(mrioc, \"iomem(0x%016llx), mapped(0x%p), size(%d)\\n\",\n\t    (unsigned long long)mrioc->sysif_regs_phys,\n\t    mrioc->sysif_regs, memap_sz);\n\tioc_info(mrioc, \"Number of MSI-X vectors found in capabilities: (%d)\\n\",\n\t    mrioc->msix_count);\n\n\tif (!reset_devices && poll_queues > 0)\n\t\tmrioc->requested_poll_qcount = min_t(int, poll_queues,\n\t\t\t\tmrioc->msix_count - 2);\n\treturn retval;\n\nout_failed:\n\tmpi3mr_cleanup_resources(mrioc);\n\treturn retval;\n}\n\n \nstatic int mpi3mr_enable_events(struct mpi3mr_ioc *mrioc)\n{\n\tint retval = 0;\n\tu32  i;\n\n\tfor (i = 0; i < MPI3_EVENT_NOTIFY_EVENTMASK_WORDS; i++)\n\t\tmrioc->event_masks[i] = -1;\n\n\tmpi3mr_unmask_events(mrioc, MPI3_EVENT_DEVICE_ADDED);\n\tmpi3mr_unmask_events(mrioc, MPI3_EVENT_DEVICE_INFO_CHANGED);\n\tmpi3mr_unmask_events(mrioc, MPI3_EVENT_DEVICE_STATUS_CHANGE);\n\tmpi3mr_unmask_events(mrioc, MPI3_EVENT_ENCL_DEVICE_STATUS_CHANGE);\n\tmpi3mr_unmask_events(mrioc, MPI3_EVENT_ENCL_DEVICE_ADDED);\n\tmpi3mr_unmask_events(mrioc, MPI3_EVENT_SAS_TOPOLOGY_CHANGE_LIST);\n\tmpi3mr_unmask_events(mrioc, MPI3_EVENT_SAS_DISCOVERY);\n\tmpi3mr_unmask_events(mrioc, MPI3_EVENT_SAS_DEVICE_DISCOVERY_ERROR);\n\tmpi3mr_unmask_events(mrioc, MPI3_EVENT_SAS_BROADCAST_PRIMITIVE);\n\tmpi3mr_unmask_events(mrioc, MPI3_EVENT_PCIE_TOPOLOGY_CHANGE_LIST);\n\tmpi3mr_unmask_events(mrioc, MPI3_EVENT_PCIE_ENUMERATION);\n\tmpi3mr_unmask_events(mrioc, MPI3_EVENT_PREPARE_FOR_RESET);\n\tmpi3mr_unmask_events(mrioc, MPI3_EVENT_CABLE_MGMT);\n\tmpi3mr_unmask_events(mrioc, MPI3_EVENT_ENERGY_PACK_CHANGE);\n\n\tretval = mpi3mr_issue_event_notification(mrioc);\n\tif (retval)\n\t\tioc_err(mrioc, \"failed to issue event notification %d\\n\",\n\t\t    retval);\n\treturn retval;\n}\n\n \nint mpi3mr_init_ioc(struct mpi3mr_ioc *mrioc)\n{\n\tint retval = 0;\n\tu8 retry = 0;\n\tstruct mpi3_ioc_facts_data facts_data;\n\tu32 sz;\n\nretry_init:\n\tretval = mpi3mr_bring_ioc_ready(mrioc);\n\tif (retval) {\n\t\tioc_err(mrioc, \"Failed to bring ioc ready: error %d\\n\",\n\t\t    retval);\n\t\tgoto out_failed_noretry;\n\t}\n\n\tretval = mpi3mr_setup_isr(mrioc, 1);\n\tif (retval) {\n\t\tioc_err(mrioc, \"Failed to setup ISR error %d\\n\",\n\t\t    retval);\n\t\tgoto out_failed_noretry;\n\t}\n\n\tretval = mpi3mr_issue_iocfacts(mrioc, &facts_data);\n\tif (retval) {\n\t\tioc_err(mrioc, \"Failed to Issue IOC Facts %d\\n\",\n\t\t    retval);\n\t\tgoto out_failed;\n\t}\n\n\tmrioc->max_host_ios = mrioc->facts.max_reqs - MPI3MR_INTERNAL_CMDS_RESVD;\n\tmrioc->shost->max_sectors = mrioc->facts.max_data_length / 512;\n\tmrioc->num_io_throttle_group = mrioc->facts.max_io_throttle_group;\n\tatomic_set(&mrioc->pend_large_data_sz, 0);\n\n\tif (reset_devices)\n\t\tmrioc->max_host_ios = min_t(int, mrioc->max_host_ios,\n\t\t    MPI3MR_HOST_IOS_KDUMP);\n\n\tif (!(mrioc->facts.ioc_capabilities &\n\t    MPI3_IOCFACTS_CAPABILITY_MULTIPATH_ENABLED)) {\n\t\tmrioc->sas_transport_enabled = 1;\n\t\tmrioc->scsi_device_channel = 1;\n\t\tmrioc->shost->max_channel = 1;\n\t\tmrioc->shost->transportt = mpi3mr_transport_template;\n\t}\n\n\tmrioc->reply_sz = mrioc->facts.reply_sz;\n\n\tretval = mpi3mr_check_reset_dma_mask(mrioc);\n\tif (retval) {\n\t\tioc_err(mrioc, \"Resetting dma mask failed %d\\n\",\n\t\t    retval);\n\t\tgoto out_failed_noretry;\n\t}\n\n\tmpi3mr_print_ioc_info(mrioc);\n\n\tif (!mrioc->cfg_page) {\n\t\tdprint_init(mrioc, \"allocating config page buffers\\n\");\n\t\tmrioc->cfg_page_sz = MPI3MR_DEFAULT_CFG_PAGE_SZ;\n\t\tmrioc->cfg_page = dma_alloc_coherent(&mrioc->pdev->dev,\n\t\t    mrioc->cfg_page_sz, &mrioc->cfg_page_dma, GFP_KERNEL);\n\t\tif (!mrioc->cfg_page) {\n\t\t\tretval = -1;\n\t\t\tgoto out_failed_noretry;\n\t\t}\n\t}\n\n\tif (!mrioc->init_cmds.reply) {\n\t\tretval = mpi3mr_alloc_reply_sense_bufs(mrioc);\n\t\tif (retval) {\n\t\t\tioc_err(mrioc,\n\t\t\t    \"%s :Failed to allocated reply sense buffers %d\\n\",\n\t\t\t    __func__, retval);\n\t\t\tgoto out_failed_noretry;\n\t\t}\n\t}\n\n\tif (!mrioc->chain_sgl_list) {\n\t\tretval = mpi3mr_alloc_chain_bufs(mrioc);\n\t\tif (retval) {\n\t\t\tioc_err(mrioc, \"Failed to allocated chain buffers %d\\n\",\n\t\t\t    retval);\n\t\t\tgoto out_failed_noretry;\n\t\t}\n\t}\n\n\tretval = mpi3mr_issue_iocinit(mrioc);\n\tif (retval) {\n\t\tioc_err(mrioc, \"Failed to Issue IOC Init %d\\n\",\n\t\t    retval);\n\t\tgoto out_failed;\n\t}\n\n\tretval = mpi3mr_print_pkg_ver(mrioc);\n\tif (retval) {\n\t\tioc_err(mrioc, \"failed to get package version\\n\");\n\t\tgoto out_failed;\n\t}\n\n\tretval = mpi3mr_setup_isr(mrioc, 0);\n\tif (retval) {\n\t\tioc_err(mrioc, \"Failed to re-setup ISR, error %d\\n\",\n\t\t    retval);\n\t\tgoto out_failed_noretry;\n\t}\n\n\tretval = mpi3mr_create_op_queues(mrioc);\n\tif (retval) {\n\t\tioc_err(mrioc, \"Failed to create OpQueues error %d\\n\",\n\t\t    retval);\n\t\tgoto out_failed;\n\t}\n\n\tif (!mrioc->pel_seqnum_virt) {\n\t\tdprint_init(mrioc, \"allocating memory for pel_seqnum_virt\\n\");\n\t\tmrioc->pel_seqnum_sz = sizeof(struct mpi3_pel_seq);\n\t\tmrioc->pel_seqnum_virt = dma_alloc_coherent(&mrioc->pdev->dev,\n\t\t    mrioc->pel_seqnum_sz, &mrioc->pel_seqnum_dma,\n\t\t    GFP_KERNEL);\n\t\tif (!mrioc->pel_seqnum_virt) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_failed_noretry;\n\t\t}\n\t}\n\n\tif (!mrioc->throttle_groups && mrioc->num_io_throttle_group) {\n\t\tdprint_init(mrioc, \"allocating memory for throttle groups\\n\");\n\t\tsz = sizeof(struct mpi3mr_throttle_group_info);\n\t\tmrioc->throttle_groups = kcalloc(mrioc->num_io_throttle_group, sz, GFP_KERNEL);\n\t\tif (!mrioc->throttle_groups) {\n\t\t\tretval = -1;\n\t\t\tgoto out_failed_noretry;\n\t\t}\n\t}\n\n\tretval = mpi3mr_enable_events(mrioc);\n\tif (retval) {\n\t\tioc_err(mrioc, \"failed to enable events %d\\n\",\n\t\t    retval);\n\t\tgoto out_failed;\n\t}\n\n\tioc_info(mrioc, \"controller initialization completed successfully\\n\");\n\treturn retval;\nout_failed:\n\tif (retry < 2) {\n\t\tretry++;\n\t\tioc_warn(mrioc, \"retrying controller initialization, retry_count:%d\\n\",\n\t\t    retry);\n\t\tmpi3mr_memset_buffers(mrioc);\n\t\tgoto retry_init;\n\t}\n\tretval = -1;\nout_failed_noretry:\n\tioc_err(mrioc, \"controller initialization failed\\n\");\n\tmpi3mr_issue_reset(mrioc, MPI3_SYSIF_HOST_DIAG_RESET_ACTION_DIAG_FAULT,\n\t    MPI3MR_RESET_FROM_CTLR_CLEANUP);\n\tmrioc->unrecoverable = 1;\n\treturn retval;\n}\n\n \nint mpi3mr_reinit_ioc(struct mpi3mr_ioc *mrioc, u8 is_resume)\n{\n\tint retval = 0;\n\tu8 retry = 0;\n\tstruct mpi3_ioc_facts_data facts_data;\n\tu32 pe_timeout, ioc_status;\n\nretry_init:\n\tpe_timeout =\n\t    (MPI3MR_PORTENABLE_TIMEOUT / MPI3MR_PORTENABLE_POLL_INTERVAL);\n\n\tdprint_reset(mrioc, \"bringing up the controller to ready state\\n\");\n\tretval = mpi3mr_bring_ioc_ready(mrioc);\n\tif (retval) {\n\t\tioc_err(mrioc, \"failed to bring to ready state\\n\");\n\t\tgoto out_failed_noretry;\n\t}\n\n\tif (is_resume) {\n\t\tdprint_reset(mrioc, \"setting up single ISR\\n\");\n\t\tretval = mpi3mr_setup_isr(mrioc, 1);\n\t\tif (retval) {\n\t\t\tioc_err(mrioc, \"failed to setup ISR\\n\");\n\t\t\tgoto out_failed_noretry;\n\t\t}\n\t} else\n\t\tmpi3mr_ioc_enable_intr(mrioc);\n\n\tdprint_reset(mrioc, \"getting ioc_facts\\n\");\n\tretval = mpi3mr_issue_iocfacts(mrioc, &facts_data);\n\tif (retval) {\n\t\tioc_err(mrioc, \"failed to get ioc_facts\\n\");\n\t\tgoto out_failed;\n\t}\n\n\tdprint_reset(mrioc, \"validating ioc_facts\\n\");\n\tretval = mpi3mr_revalidate_factsdata(mrioc);\n\tif (retval) {\n\t\tioc_err(mrioc, \"failed to revalidate ioc_facts data\\n\");\n\t\tgoto out_failed_noretry;\n\t}\n\n\tmpi3mr_print_ioc_info(mrioc);\n\n\tdprint_reset(mrioc, \"sending ioc_init\\n\");\n\tretval = mpi3mr_issue_iocinit(mrioc);\n\tif (retval) {\n\t\tioc_err(mrioc, \"failed to send ioc_init\\n\");\n\t\tgoto out_failed;\n\t}\n\n\tdprint_reset(mrioc, \"getting package version\\n\");\n\tretval = mpi3mr_print_pkg_ver(mrioc);\n\tif (retval) {\n\t\tioc_err(mrioc, \"failed to get package version\\n\");\n\t\tgoto out_failed;\n\t}\n\n\tif (is_resume) {\n\t\tdprint_reset(mrioc, \"setting up multiple ISR\\n\");\n\t\tretval = mpi3mr_setup_isr(mrioc, 0);\n\t\tif (retval) {\n\t\t\tioc_err(mrioc, \"failed to re-setup ISR\\n\");\n\t\t\tgoto out_failed_noretry;\n\t\t}\n\t}\n\n\tdprint_reset(mrioc, \"creating operational queue pairs\\n\");\n\tretval = mpi3mr_create_op_queues(mrioc);\n\tif (retval) {\n\t\tioc_err(mrioc, \"failed to create operational queue pairs\\n\");\n\t\tgoto out_failed;\n\t}\n\n\tif (!mrioc->pel_seqnum_virt) {\n\t\tdprint_reset(mrioc, \"allocating memory for pel_seqnum_virt\\n\");\n\t\tmrioc->pel_seqnum_sz = sizeof(struct mpi3_pel_seq);\n\t\tmrioc->pel_seqnum_virt = dma_alloc_coherent(&mrioc->pdev->dev,\n\t\t    mrioc->pel_seqnum_sz, &mrioc->pel_seqnum_dma,\n\t\t    GFP_KERNEL);\n\t\tif (!mrioc->pel_seqnum_virt) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_failed_noretry;\n\t\t}\n\t}\n\n\tif (mrioc->shost->nr_hw_queues > mrioc->num_op_reply_q) {\n\t\tioc_err(mrioc,\n\t\t    \"cannot create minimum number of operational queues expected:%d created:%d\\n\",\n\t\t    mrioc->shost->nr_hw_queues, mrioc->num_op_reply_q);\n\t\tretval = -1;\n\t\tgoto out_failed_noretry;\n\t}\n\n\tdprint_reset(mrioc, \"enabling events\\n\");\n\tretval = mpi3mr_enable_events(mrioc);\n\tif (retval) {\n\t\tioc_err(mrioc, \"failed to enable events\\n\");\n\t\tgoto out_failed;\n\t}\n\n\tmrioc->device_refresh_on = 1;\n\tmpi3mr_add_event_wait_for_device_refresh(mrioc);\n\n\tioc_info(mrioc, \"sending port enable\\n\");\n\tretval = mpi3mr_issue_port_enable(mrioc, 1);\n\tif (retval) {\n\t\tioc_err(mrioc, \"failed to issue port enable\\n\");\n\t\tgoto out_failed;\n\t}\n\tdo {\n\t\tssleep(MPI3MR_PORTENABLE_POLL_INTERVAL);\n\t\tif (mrioc->init_cmds.state == MPI3MR_CMD_NOTUSED)\n\t\t\tbreak;\n\t\tif (!pci_device_is_present(mrioc->pdev))\n\t\t\tmrioc->unrecoverable = 1;\n\t\tif (mrioc->unrecoverable) {\n\t\t\tretval = -1;\n\t\t\tgoto out_failed_noretry;\n\t\t}\n\t\tioc_status = readl(&mrioc->sysif_regs->ioc_status);\n\t\tif ((ioc_status & MPI3_SYSIF_IOC_STATUS_RESET_HISTORY) ||\n\t\t    (ioc_status & MPI3_SYSIF_IOC_STATUS_FAULT)) {\n\t\t\tmpi3mr_print_fault_info(mrioc);\n\t\t\tmrioc->init_cmds.is_waiting = 0;\n\t\t\tmrioc->init_cmds.callback = NULL;\n\t\t\tmrioc->init_cmds.state = MPI3MR_CMD_NOTUSED;\n\t\t\tgoto out_failed;\n\t\t}\n\t} while (--pe_timeout);\n\n\tif (!pe_timeout) {\n\t\tioc_err(mrioc, \"port enable timed out\\n\");\n\t\tmpi3mr_check_rh_fault_ioc(mrioc,\n\t\t    MPI3MR_RESET_FROM_PE_TIMEOUT);\n\t\tmrioc->init_cmds.is_waiting = 0;\n\t\tmrioc->init_cmds.callback = NULL;\n\t\tmrioc->init_cmds.state = MPI3MR_CMD_NOTUSED;\n\t\tgoto out_failed;\n\t} else if (mrioc->scan_failed) {\n\t\tioc_err(mrioc,\n\t\t    \"port enable failed with status=0x%04x\\n\",\n\t\t    mrioc->scan_failed);\n\t} else\n\t\tioc_info(mrioc, \"port enable completed successfully\\n\");\n\n\tioc_info(mrioc, \"controller %s completed successfully\\n\",\n\t    (is_resume)?\"resume\":\"re-initialization\");\n\treturn retval;\nout_failed:\n\tif (retry < 2) {\n\t\tretry++;\n\t\tioc_warn(mrioc, \"retrying controller %s, retry_count:%d\\n\",\n\t\t    (is_resume)?\"resume\":\"re-initialization\", retry);\n\t\tmpi3mr_memset_buffers(mrioc);\n\t\tgoto retry_init;\n\t}\n\tretval = -1;\nout_failed_noretry:\n\tioc_err(mrioc, \"controller %s is failed\\n\",\n\t    (is_resume)?\"resume\":\"re-initialization\");\n\tmpi3mr_issue_reset(mrioc, MPI3_SYSIF_HOST_DIAG_RESET_ACTION_DIAG_FAULT,\n\t    MPI3MR_RESET_FROM_CTLR_CLEANUP);\n\tmrioc->unrecoverable = 1;\n\treturn retval;\n}\n\n \nstatic void mpi3mr_memset_op_reply_q_buffers(struct mpi3mr_ioc *mrioc, u16 qidx)\n{\n\tstruct op_reply_qinfo *op_reply_q = mrioc->op_reply_qinfo + qidx;\n\tstruct segments *segments;\n\tint i, size;\n\n\tif (!op_reply_q->q_segments)\n\t\treturn;\n\n\tsize = op_reply_q->segment_qd * mrioc->op_reply_desc_sz;\n\tsegments = op_reply_q->q_segments;\n\tfor (i = 0; i < op_reply_q->num_segments; i++)\n\t\tmemset(segments[i].segment, 0, size);\n}\n\n \nstatic void mpi3mr_memset_op_req_q_buffers(struct mpi3mr_ioc *mrioc, u16 qidx)\n{\n\tstruct op_req_qinfo *op_req_q = mrioc->req_qinfo + qidx;\n\tstruct segments *segments;\n\tint i, size;\n\n\tif (!op_req_q->q_segments)\n\t\treturn;\n\n\tsize = op_req_q->segment_qd * mrioc->facts.op_req_sz;\n\tsegments = op_req_q->q_segments;\n\tfor (i = 0; i < op_req_q->num_segments; i++)\n\t\tmemset(segments[i].segment, 0, size);\n}\n\n \nvoid mpi3mr_memset_buffers(struct mpi3mr_ioc *mrioc)\n{\n\tu16 i;\n\tstruct mpi3mr_throttle_group_info *tg;\n\n\tmrioc->change_count = 0;\n\tmrioc->active_poll_qcount = 0;\n\tmrioc->default_qcount = 0;\n\tif (mrioc->admin_req_base)\n\t\tmemset(mrioc->admin_req_base, 0, mrioc->admin_req_q_sz);\n\tif (mrioc->admin_reply_base)\n\t\tmemset(mrioc->admin_reply_base, 0, mrioc->admin_reply_q_sz);\n\tatomic_set(&mrioc->admin_reply_q_in_use, 0);\n\n\tif (mrioc->init_cmds.reply) {\n\t\tmemset(mrioc->init_cmds.reply, 0, sizeof(*mrioc->init_cmds.reply));\n\t\tmemset(mrioc->bsg_cmds.reply, 0,\n\t\t    sizeof(*mrioc->bsg_cmds.reply));\n\t\tmemset(mrioc->host_tm_cmds.reply, 0,\n\t\t    sizeof(*mrioc->host_tm_cmds.reply));\n\t\tmemset(mrioc->pel_cmds.reply, 0,\n\t\t    sizeof(*mrioc->pel_cmds.reply));\n\t\tmemset(mrioc->pel_abort_cmd.reply, 0,\n\t\t    sizeof(*mrioc->pel_abort_cmd.reply));\n\t\tmemset(mrioc->transport_cmds.reply, 0,\n\t\t    sizeof(*mrioc->transport_cmds.reply));\n\t\tfor (i = 0; i < MPI3MR_NUM_DEVRMCMD; i++)\n\t\t\tmemset(mrioc->dev_rmhs_cmds[i].reply, 0,\n\t\t\t    sizeof(*mrioc->dev_rmhs_cmds[i].reply));\n\t\tfor (i = 0; i < MPI3MR_NUM_EVTACKCMD; i++)\n\t\t\tmemset(mrioc->evtack_cmds[i].reply, 0,\n\t\t\t    sizeof(*mrioc->evtack_cmds[i].reply));\n\t\tbitmap_clear(mrioc->removepend_bitmap, 0,\n\t\t\t     mrioc->dev_handle_bitmap_bits);\n\t\tbitmap_clear(mrioc->devrem_bitmap, 0, MPI3MR_NUM_DEVRMCMD);\n\t\tbitmap_clear(mrioc->evtack_cmds_bitmap, 0,\n\t\t\t     MPI3MR_NUM_EVTACKCMD);\n\t}\n\n\tfor (i = 0; i < mrioc->num_queues; i++) {\n\t\tmrioc->op_reply_qinfo[i].qid = 0;\n\t\tmrioc->op_reply_qinfo[i].ci = 0;\n\t\tmrioc->op_reply_qinfo[i].num_replies = 0;\n\t\tmrioc->op_reply_qinfo[i].ephase = 0;\n\t\tatomic_set(&mrioc->op_reply_qinfo[i].pend_ios, 0);\n\t\tatomic_set(&mrioc->op_reply_qinfo[i].in_use, 0);\n\t\tmpi3mr_memset_op_reply_q_buffers(mrioc, i);\n\n\t\tmrioc->req_qinfo[i].ci = 0;\n\t\tmrioc->req_qinfo[i].pi = 0;\n\t\tmrioc->req_qinfo[i].num_requests = 0;\n\t\tmrioc->req_qinfo[i].qid = 0;\n\t\tmrioc->req_qinfo[i].reply_qid = 0;\n\t\tspin_lock_init(&mrioc->req_qinfo[i].q_lock);\n\t\tmpi3mr_memset_op_req_q_buffers(mrioc, i);\n\t}\n\n\tatomic_set(&mrioc->pend_large_data_sz, 0);\n\tif (mrioc->throttle_groups) {\n\t\ttg = mrioc->throttle_groups;\n\t\tfor (i = 0; i < mrioc->num_io_throttle_group; i++, tg++) {\n\t\t\ttg->id = 0;\n\t\t\ttg->fw_qd = 0;\n\t\t\ttg->modified_qd = 0;\n\t\t\ttg->io_divert = 0;\n\t\t\ttg->need_qd_reduction = 0;\n\t\t\ttg->high = 0;\n\t\t\ttg->low = 0;\n\t\t\ttg->qd_reduction = 0;\n\t\t\tatomic_set(&tg->pend_large_data_sz, 0);\n\t\t}\n\t}\n}\n\n \nvoid mpi3mr_free_mem(struct mpi3mr_ioc *mrioc)\n{\n\tu16 i;\n\tstruct mpi3mr_intr_info *intr_info;\n\n\tmpi3mr_free_enclosure_list(mrioc);\n\n\tif (mrioc->sense_buf_pool) {\n\t\tif (mrioc->sense_buf)\n\t\t\tdma_pool_free(mrioc->sense_buf_pool, mrioc->sense_buf,\n\t\t\t    mrioc->sense_buf_dma);\n\t\tdma_pool_destroy(mrioc->sense_buf_pool);\n\t\tmrioc->sense_buf = NULL;\n\t\tmrioc->sense_buf_pool = NULL;\n\t}\n\tif (mrioc->sense_buf_q_pool) {\n\t\tif (mrioc->sense_buf_q)\n\t\t\tdma_pool_free(mrioc->sense_buf_q_pool,\n\t\t\t    mrioc->sense_buf_q, mrioc->sense_buf_q_dma);\n\t\tdma_pool_destroy(mrioc->sense_buf_q_pool);\n\t\tmrioc->sense_buf_q = NULL;\n\t\tmrioc->sense_buf_q_pool = NULL;\n\t}\n\n\tif (mrioc->reply_buf_pool) {\n\t\tif (mrioc->reply_buf)\n\t\t\tdma_pool_free(mrioc->reply_buf_pool, mrioc->reply_buf,\n\t\t\t    mrioc->reply_buf_dma);\n\t\tdma_pool_destroy(mrioc->reply_buf_pool);\n\t\tmrioc->reply_buf = NULL;\n\t\tmrioc->reply_buf_pool = NULL;\n\t}\n\tif (mrioc->reply_free_q_pool) {\n\t\tif (mrioc->reply_free_q)\n\t\t\tdma_pool_free(mrioc->reply_free_q_pool,\n\t\t\t    mrioc->reply_free_q, mrioc->reply_free_q_dma);\n\t\tdma_pool_destroy(mrioc->reply_free_q_pool);\n\t\tmrioc->reply_free_q = NULL;\n\t\tmrioc->reply_free_q_pool = NULL;\n\t}\n\n\tfor (i = 0; i < mrioc->num_op_req_q; i++)\n\t\tmpi3mr_free_op_req_q_segments(mrioc, i);\n\n\tfor (i = 0; i < mrioc->num_op_reply_q; i++)\n\t\tmpi3mr_free_op_reply_q_segments(mrioc, i);\n\n\tfor (i = 0; i < mrioc->intr_info_count; i++) {\n\t\tintr_info = mrioc->intr_info + i;\n\t\tintr_info->op_reply_q = NULL;\n\t}\n\n\tkfree(mrioc->req_qinfo);\n\tmrioc->req_qinfo = NULL;\n\tmrioc->num_op_req_q = 0;\n\n\tkfree(mrioc->op_reply_qinfo);\n\tmrioc->op_reply_qinfo = NULL;\n\tmrioc->num_op_reply_q = 0;\n\n\tkfree(mrioc->init_cmds.reply);\n\tmrioc->init_cmds.reply = NULL;\n\n\tkfree(mrioc->bsg_cmds.reply);\n\tmrioc->bsg_cmds.reply = NULL;\n\n\tkfree(mrioc->host_tm_cmds.reply);\n\tmrioc->host_tm_cmds.reply = NULL;\n\n\tkfree(mrioc->pel_cmds.reply);\n\tmrioc->pel_cmds.reply = NULL;\n\n\tkfree(mrioc->pel_abort_cmd.reply);\n\tmrioc->pel_abort_cmd.reply = NULL;\n\n\tfor (i = 0; i < MPI3MR_NUM_EVTACKCMD; i++) {\n\t\tkfree(mrioc->evtack_cmds[i].reply);\n\t\tmrioc->evtack_cmds[i].reply = NULL;\n\t}\n\n\tbitmap_free(mrioc->removepend_bitmap);\n\tmrioc->removepend_bitmap = NULL;\n\n\tbitmap_free(mrioc->devrem_bitmap);\n\tmrioc->devrem_bitmap = NULL;\n\n\tbitmap_free(mrioc->evtack_cmds_bitmap);\n\tmrioc->evtack_cmds_bitmap = NULL;\n\n\tbitmap_free(mrioc->chain_bitmap);\n\tmrioc->chain_bitmap = NULL;\n\n\tkfree(mrioc->transport_cmds.reply);\n\tmrioc->transport_cmds.reply = NULL;\n\n\tfor (i = 0; i < MPI3MR_NUM_DEVRMCMD; i++) {\n\t\tkfree(mrioc->dev_rmhs_cmds[i].reply);\n\t\tmrioc->dev_rmhs_cmds[i].reply = NULL;\n\t}\n\n\tif (mrioc->chain_buf_pool) {\n\t\tfor (i = 0; i < mrioc->chain_buf_count; i++) {\n\t\t\tif (mrioc->chain_sgl_list[i].addr) {\n\t\t\t\tdma_pool_free(mrioc->chain_buf_pool,\n\t\t\t\t    mrioc->chain_sgl_list[i].addr,\n\t\t\t\t    mrioc->chain_sgl_list[i].dma_addr);\n\t\t\t\tmrioc->chain_sgl_list[i].addr = NULL;\n\t\t\t}\n\t\t}\n\t\tdma_pool_destroy(mrioc->chain_buf_pool);\n\t\tmrioc->chain_buf_pool = NULL;\n\t}\n\n\tkfree(mrioc->chain_sgl_list);\n\tmrioc->chain_sgl_list = NULL;\n\n\tif (mrioc->admin_reply_base) {\n\t\tdma_free_coherent(&mrioc->pdev->dev, mrioc->admin_reply_q_sz,\n\t\t    mrioc->admin_reply_base, mrioc->admin_reply_dma);\n\t\tmrioc->admin_reply_base = NULL;\n\t}\n\tif (mrioc->admin_req_base) {\n\t\tdma_free_coherent(&mrioc->pdev->dev, mrioc->admin_req_q_sz,\n\t\t    mrioc->admin_req_base, mrioc->admin_req_dma);\n\t\tmrioc->admin_req_base = NULL;\n\t}\n\tif (mrioc->cfg_page) {\n\t\tdma_free_coherent(&mrioc->pdev->dev, mrioc->cfg_page_sz,\n\t\t    mrioc->cfg_page, mrioc->cfg_page_dma);\n\t\tmrioc->cfg_page = NULL;\n\t}\n\tif (mrioc->pel_seqnum_virt) {\n\t\tdma_free_coherent(&mrioc->pdev->dev, mrioc->pel_seqnum_sz,\n\t\t    mrioc->pel_seqnum_virt, mrioc->pel_seqnum_dma);\n\t\tmrioc->pel_seqnum_virt = NULL;\n\t}\n\n\tkfree(mrioc->throttle_groups);\n\tmrioc->throttle_groups = NULL;\n\n\tkfree(mrioc->logdata_buf);\n\tmrioc->logdata_buf = NULL;\n\n}\n\n \nstatic void mpi3mr_issue_ioc_shutdown(struct mpi3mr_ioc *mrioc)\n{\n\tu32 ioc_config, ioc_status;\n\tu8 retval = 1;\n\tu32 timeout = MPI3MR_DEFAULT_SHUTDOWN_TIME * 10;\n\n\tioc_info(mrioc, \"Issuing shutdown Notification\\n\");\n\tif (mrioc->unrecoverable) {\n\t\tioc_warn(mrioc,\n\t\t    \"IOC is unrecoverable shutdown is not issued\\n\");\n\t\treturn;\n\t}\n\tioc_status = readl(&mrioc->sysif_regs->ioc_status);\n\tif ((ioc_status & MPI3_SYSIF_IOC_STATUS_SHUTDOWN_MASK)\n\t    == MPI3_SYSIF_IOC_STATUS_SHUTDOWN_IN_PROGRESS) {\n\t\tioc_info(mrioc, \"shutdown already in progress\\n\");\n\t\treturn;\n\t}\n\n\tioc_config = readl(&mrioc->sysif_regs->ioc_configuration);\n\tioc_config |= MPI3_SYSIF_IOC_CONFIG_SHUTDOWN_NORMAL;\n\tioc_config |= MPI3_SYSIF_IOC_CONFIG_DEVICE_SHUTDOWN_SEND_REQ;\n\n\twritel(ioc_config, &mrioc->sysif_regs->ioc_configuration);\n\n\tif (mrioc->facts.shutdown_timeout)\n\t\ttimeout = mrioc->facts.shutdown_timeout * 10;\n\n\tdo {\n\t\tioc_status = readl(&mrioc->sysif_regs->ioc_status);\n\t\tif ((ioc_status & MPI3_SYSIF_IOC_STATUS_SHUTDOWN_MASK)\n\t\t    == MPI3_SYSIF_IOC_STATUS_SHUTDOWN_COMPLETE) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(100);\n\t} while (--timeout);\n\n\tioc_status = readl(&mrioc->sysif_regs->ioc_status);\n\tioc_config = readl(&mrioc->sysif_regs->ioc_configuration);\n\n\tif (retval) {\n\t\tif ((ioc_status & MPI3_SYSIF_IOC_STATUS_SHUTDOWN_MASK)\n\t\t    == MPI3_SYSIF_IOC_STATUS_SHUTDOWN_IN_PROGRESS)\n\t\t\tioc_warn(mrioc,\n\t\t\t    \"shutdown still in progress after timeout\\n\");\n\t}\n\n\tioc_info(mrioc,\n\t    \"Base IOC Sts/Config after %s shutdown is (0x%x)/(0x%x)\\n\",\n\t    (!retval) ? \"successful\" : \"failed\", ioc_status,\n\t    ioc_config);\n}\n\n \nvoid mpi3mr_cleanup_ioc(struct mpi3mr_ioc *mrioc)\n{\n\tenum mpi3mr_iocstate ioc_state;\n\n\tdprint_exit(mrioc, \"cleaning up the controller\\n\");\n\tmpi3mr_ioc_disable_intr(mrioc);\n\n\tioc_state = mpi3mr_get_iocstate(mrioc);\n\n\tif ((!mrioc->unrecoverable) && (!mrioc->reset_in_progress) &&\n\t    (ioc_state == MRIOC_STATE_READY)) {\n\t\tif (mpi3mr_issue_and_process_mur(mrioc,\n\t\t    MPI3MR_RESET_FROM_CTLR_CLEANUP))\n\t\t\tmpi3mr_issue_reset(mrioc,\n\t\t\t    MPI3_SYSIF_HOST_DIAG_RESET_ACTION_SOFT_RESET,\n\t\t\t    MPI3MR_RESET_FROM_MUR_FAILURE);\n\t\tmpi3mr_issue_ioc_shutdown(mrioc);\n\t}\n\tdprint_exit(mrioc, \"controller cleanup completed\\n\");\n}\n\n \nstatic inline void mpi3mr_drv_cmd_comp_reset(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_drv_cmd *cmdptr)\n{\n\tif (cmdptr->state & MPI3MR_CMD_PENDING) {\n\t\tcmdptr->state |= MPI3MR_CMD_RESET;\n\t\tcmdptr->state &= ~MPI3MR_CMD_PENDING;\n\t\tif (cmdptr->is_waiting) {\n\t\t\tcomplete(&cmdptr->done);\n\t\t\tcmdptr->is_waiting = 0;\n\t\t} else if (cmdptr->callback)\n\t\t\tcmdptr->callback(mrioc, cmdptr);\n\t}\n}\n\n \nvoid mpi3mr_flush_drv_cmds(struct mpi3mr_ioc *mrioc)\n{\n\tstruct mpi3mr_drv_cmd *cmdptr;\n\tu8 i;\n\n\tcmdptr = &mrioc->init_cmds;\n\tmpi3mr_drv_cmd_comp_reset(mrioc, cmdptr);\n\n\tcmdptr = &mrioc->cfg_cmds;\n\tmpi3mr_drv_cmd_comp_reset(mrioc, cmdptr);\n\n\tcmdptr = &mrioc->bsg_cmds;\n\tmpi3mr_drv_cmd_comp_reset(mrioc, cmdptr);\n\tcmdptr = &mrioc->host_tm_cmds;\n\tmpi3mr_drv_cmd_comp_reset(mrioc, cmdptr);\n\n\tfor (i = 0; i < MPI3MR_NUM_DEVRMCMD; i++) {\n\t\tcmdptr = &mrioc->dev_rmhs_cmds[i];\n\t\tmpi3mr_drv_cmd_comp_reset(mrioc, cmdptr);\n\t}\n\n\tfor (i = 0; i < MPI3MR_NUM_EVTACKCMD; i++) {\n\t\tcmdptr = &mrioc->evtack_cmds[i];\n\t\tmpi3mr_drv_cmd_comp_reset(mrioc, cmdptr);\n\t}\n\n\tcmdptr = &mrioc->pel_cmds;\n\tmpi3mr_drv_cmd_comp_reset(mrioc, cmdptr);\n\n\tcmdptr = &mrioc->pel_abort_cmd;\n\tmpi3mr_drv_cmd_comp_reset(mrioc, cmdptr);\n\n\tcmdptr = &mrioc->transport_cmds;\n\tmpi3mr_drv_cmd_comp_reset(mrioc, cmdptr);\n}\n\n \nstatic void mpi3mr_pel_wait_post(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_drv_cmd *drv_cmd)\n{\n\tstruct mpi3_pel_req_action_wait pel_wait;\n\n\tmrioc->pel_abort_requested = false;\n\n\tmemset(&pel_wait, 0, sizeof(pel_wait));\n\tdrv_cmd->state = MPI3MR_CMD_PENDING;\n\tdrv_cmd->is_waiting = 0;\n\tdrv_cmd->callback = mpi3mr_pel_wait_complete;\n\tdrv_cmd->ioc_status = 0;\n\tdrv_cmd->ioc_loginfo = 0;\n\tpel_wait.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_PEL_WAIT);\n\tpel_wait.function = MPI3_FUNCTION_PERSISTENT_EVENT_LOG;\n\tpel_wait.action = MPI3_PEL_ACTION_WAIT;\n\tpel_wait.starting_sequence_number = cpu_to_le32(mrioc->pel_newest_seqnum);\n\tpel_wait.locale = cpu_to_le16(mrioc->pel_locale);\n\tpel_wait.class = cpu_to_le16(mrioc->pel_class);\n\tpel_wait.wait_time = MPI3_PEL_WAITTIME_INFINITE_WAIT;\n\tdprint_bsg_info(mrioc, \"sending pel_wait seqnum(%d), class(%d), locale(0x%08x)\\n\",\n\t    mrioc->pel_newest_seqnum, mrioc->pel_class, mrioc->pel_locale);\n\n\tif (mpi3mr_admin_request_post(mrioc, &pel_wait, sizeof(pel_wait), 0)) {\n\t\tdprint_bsg_err(mrioc,\n\t\t\t    \"Issuing PELWait: Admin post failed\\n\");\n\t\tdrv_cmd->state = MPI3MR_CMD_NOTUSED;\n\t\tdrv_cmd->callback = NULL;\n\t\tdrv_cmd->retry_count = 0;\n\t\tmrioc->pel_enabled = false;\n\t}\n}\n\n \nint mpi3mr_pel_get_seqnum_post(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_drv_cmd *drv_cmd)\n{\n\tstruct mpi3_pel_req_action_get_sequence_numbers pel_getseq_req;\n\tu8 sgl_flags = MPI3MR_SGEFLAGS_SYSTEM_SIMPLE_END_OF_LIST;\n\tint retval = 0;\n\n\tmemset(&pel_getseq_req, 0, sizeof(pel_getseq_req));\n\tmrioc->pel_cmds.state = MPI3MR_CMD_PENDING;\n\tmrioc->pel_cmds.is_waiting = 0;\n\tmrioc->pel_cmds.ioc_status = 0;\n\tmrioc->pel_cmds.ioc_loginfo = 0;\n\tmrioc->pel_cmds.callback = mpi3mr_pel_get_seqnum_complete;\n\tpel_getseq_req.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_PEL_WAIT);\n\tpel_getseq_req.function = MPI3_FUNCTION_PERSISTENT_EVENT_LOG;\n\tpel_getseq_req.action = MPI3_PEL_ACTION_GET_SEQNUM;\n\tmpi3mr_add_sg_single(&pel_getseq_req.sgl, sgl_flags,\n\t    mrioc->pel_seqnum_sz, mrioc->pel_seqnum_dma);\n\n\tretval = mpi3mr_admin_request_post(mrioc, &pel_getseq_req,\n\t\t\tsizeof(pel_getseq_req), 0);\n\tif (retval) {\n\t\tif (drv_cmd) {\n\t\t\tdrv_cmd->state = MPI3MR_CMD_NOTUSED;\n\t\t\tdrv_cmd->callback = NULL;\n\t\t\tdrv_cmd->retry_count = 0;\n\t\t}\n\t\tmrioc->pel_enabled = false;\n\t}\n\n\treturn retval;\n}\n\n \nstatic void mpi3mr_pel_wait_complete(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_drv_cmd *drv_cmd)\n{\n\tstruct mpi3_pel_reply *pel_reply = NULL;\n\tu16 ioc_status, pe_log_status;\n\tbool do_retry = false;\n\n\tif (drv_cmd->state & MPI3MR_CMD_RESET)\n\t\tgoto cleanup_drv_cmd;\n\n\tioc_status = drv_cmd->ioc_status & MPI3_IOCSTATUS_STATUS_MASK;\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"%s: Failed ioc_status(0x%04x) Loginfo(0x%08x)\\n\",\n\t\t\t__func__, ioc_status, drv_cmd->ioc_loginfo);\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"pel_wait: failed with ioc_status(0x%04x), log_info(0x%08x)\\n\",\n\t\t    ioc_status, drv_cmd->ioc_loginfo);\n\t\tdo_retry = true;\n\t}\n\n\tif (drv_cmd->state & MPI3MR_CMD_REPLY_VALID)\n\t\tpel_reply = (struct mpi3_pel_reply *)drv_cmd->reply;\n\n\tif (!pel_reply) {\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"pel_wait: failed due to no reply\\n\");\n\t\tgoto out_failed;\n\t}\n\n\tpe_log_status = le16_to_cpu(pel_reply->pe_log_status);\n\tif ((pe_log_status != MPI3_PEL_STATUS_SUCCESS) &&\n\t    (pe_log_status != MPI3_PEL_STATUS_ABORTED)) {\n\t\tioc_err(mrioc, \"%s: Failed pe_log_status(0x%04x)\\n\",\n\t\t\t__func__, pe_log_status);\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"pel_wait: failed due to pel_log_status(0x%04x)\\n\",\n\t\t    pe_log_status);\n\t\tdo_retry = true;\n\t}\n\n\tif (do_retry) {\n\t\tif (drv_cmd->retry_count < MPI3MR_PEL_RETRY_COUNT) {\n\t\t\tdrv_cmd->retry_count++;\n\t\t\tdprint_bsg_err(mrioc, \"pel_wait: retrying(%d)\\n\",\n\t\t\t    drv_cmd->retry_count);\n\t\t\tmpi3mr_pel_wait_post(mrioc, drv_cmd);\n\t\t\treturn;\n\t\t}\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"pel_wait: failed after all retries(%d)\\n\",\n\t\t    drv_cmd->retry_count);\n\t\tgoto out_failed;\n\t}\n\tatomic64_inc(&event_counter);\n\tif (!mrioc->pel_abort_requested) {\n\t\tmrioc->pel_cmds.retry_count = 0;\n\t\tmpi3mr_pel_get_seqnum_post(mrioc, &mrioc->pel_cmds);\n\t}\n\n\treturn;\nout_failed:\n\tmrioc->pel_enabled = false;\ncleanup_drv_cmd:\n\tdrv_cmd->state = MPI3MR_CMD_NOTUSED;\n\tdrv_cmd->callback = NULL;\n\tdrv_cmd->retry_count = 0;\n}\n\n \nvoid mpi3mr_pel_get_seqnum_complete(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3mr_drv_cmd *drv_cmd)\n{\n\tstruct mpi3_pel_reply *pel_reply = NULL;\n\tstruct mpi3_pel_seq *pel_seqnum_virt;\n\tu16 ioc_status;\n\tbool do_retry = false;\n\n\tpel_seqnum_virt = (struct mpi3_pel_seq *)mrioc->pel_seqnum_virt;\n\n\tif (drv_cmd->state & MPI3MR_CMD_RESET)\n\t\tgoto cleanup_drv_cmd;\n\n\tioc_status = drv_cmd->ioc_status & MPI3_IOCSTATUS_STATUS_MASK;\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"pel_get_seqnum: failed with ioc_status(0x%04x), log_info(0x%08x)\\n\",\n\t\t    ioc_status, drv_cmd->ioc_loginfo);\n\t\tdo_retry = true;\n\t}\n\n\tif (drv_cmd->state & MPI3MR_CMD_REPLY_VALID)\n\t\tpel_reply = (struct mpi3_pel_reply *)drv_cmd->reply;\n\tif (!pel_reply) {\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"pel_get_seqnum: failed due to no reply\\n\");\n\t\tgoto out_failed;\n\t}\n\n\tif (le16_to_cpu(pel_reply->pe_log_status) != MPI3_PEL_STATUS_SUCCESS) {\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"pel_get_seqnum: failed due to pel_log_status(0x%04x)\\n\",\n\t\t    le16_to_cpu(pel_reply->pe_log_status));\n\t\tdo_retry = true;\n\t}\n\n\tif (do_retry) {\n\t\tif (drv_cmd->retry_count < MPI3MR_PEL_RETRY_COUNT) {\n\t\t\tdrv_cmd->retry_count++;\n\t\t\tdprint_bsg_err(mrioc,\n\t\t\t    \"pel_get_seqnum: retrying(%d)\\n\",\n\t\t\t    drv_cmd->retry_count);\n\t\t\tmpi3mr_pel_get_seqnum_post(mrioc, drv_cmd);\n\t\t\treturn;\n\t\t}\n\n\t\tdprint_bsg_err(mrioc,\n\t\t    \"pel_get_seqnum: failed after all retries(%d)\\n\",\n\t\t    drv_cmd->retry_count);\n\t\tgoto out_failed;\n\t}\n\tmrioc->pel_newest_seqnum = le32_to_cpu(pel_seqnum_virt->newest) + 1;\n\tdrv_cmd->retry_count = 0;\n\tmpi3mr_pel_wait_post(mrioc, drv_cmd);\n\n\treturn;\nout_failed:\n\tmrioc->pel_enabled = false;\ncleanup_drv_cmd:\n\tdrv_cmd->state = MPI3MR_CMD_NOTUSED;\n\tdrv_cmd->callback = NULL;\n\tdrv_cmd->retry_count = 0;\n}\n\n \nint mpi3mr_soft_reset_handler(struct mpi3mr_ioc *mrioc,\n\tu32 reset_reason, u8 snapdump)\n{\n\tint retval = 0, i;\n\tunsigned long flags;\n\tu32 host_diagnostic, timeout = MPI3_SYSIF_DIAG_SAVE_TIMEOUT * 10;\n\n\t \n\tdprint_reset(mrioc,\n\t    \"soft_reset_handler: check and block on diagsave_timeout(%d)\\n\",\n\t    mrioc->diagsave_timeout);\n\twhile (mrioc->diagsave_timeout)\n\t\tssleep(1);\n\t \n\tdprint_reset(mrioc, \"soft_reset_handler: acquiring reset_mutex\\n\");\n\tif (!mutex_trylock(&mrioc->reset_mutex)) {\n\t\tioc_info(mrioc,\n\t\t    \"controller reset triggered by %s is blocked due to another reset in progress\\n\",\n\t\t    mpi3mr_reset_rc_name(reset_reason));\n\t\tdo {\n\t\t\tssleep(1);\n\t\t} while (mrioc->reset_in_progress == 1);\n\t\tioc_info(mrioc,\n\t\t    \"returning previous reset result(%d) for the reset triggered by %s\\n\",\n\t\t    mrioc->prev_reset_result,\n\t\t    mpi3mr_reset_rc_name(reset_reason));\n\t\treturn mrioc->prev_reset_result;\n\t}\n\tioc_info(mrioc, \"controller reset is triggered by %s\\n\",\n\t    mpi3mr_reset_rc_name(reset_reason));\n\n\tmrioc->device_refresh_on = 0;\n\tmrioc->reset_in_progress = 1;\n\tmrioc->stop_bsgs = 1;\n\tmrioc->prev_reset_result = -1;\n\n\tif ((!snapdump) && (reset_reason != MPI3MR_RESET_FROM_FAULT_WATCH) &&\n\t    (reset_reason != MPI3MR_RESET_FROM_FIRMWARE) &&\n\t    (reset_reason != MPI3MR_RESET_FROM_CIACTIV_FAULT)) {\n\t\tfor (i = 0; i < MPI3_EVENT_NOTIFY_EVENTMASK_WORDS; i++)\n\t\t\tmrioc->event_masks[i] = -1;\n\n\t\tdprint_reset(mrioc, \"soft_reset_handler: masking events\\n\");\n\t\tmpi3mr_issue_event_notification(mrioc);\n\t}\n\n\tmpi3mr_wait_for_host_io(mrioc, MPI3MR_RESET_HOST_IOWAIT_TIMEOUT);\n\n\tmpi3mr_ioc_disable_intr(mrioc);\n\n\tif (snapdump) {\n\t\tmpi3mr_set_diagsave(mrioc);\n\t\tretval = mpi3mr_issue_reset(mrioc,\n\t\t    MPI3_SYSIF_HOST_DIAG_RESET_ACTION_DIAG_FAULT, reset_reason);\n\t\tif (!retval) {\n\t\t\tdo {\n\t\t\t\thost_diagnostic =\n\t\t\t\t    readl(&mrioc->sysif_regs->host_diagnostic);\n\t\t\t\tif (!(host_diagnostic &\n\t\t\t\t    MPI3_SYSIF_HOST_DIAG_SAVE_IN_PROGRESS))\n\t\t\t\t\tbreak;\n\t\t\t\tmsleep(100);\n\t\t\t} while (--timeout);\n\t\t}\n\t}\n\n\tretval = mpi3mr_issue_reset(mrioc,\n\t    MPI3_SYSIF_HOST_DIAG_RESET_ACTION_SOFT_RESET, reset_reason);\n\tif (retval) {\n\t\tioc_err(mrioc, \"Failed to issue soft reset to the ioc\\n\");\n\t\tgoto out;\n\t}\n\tif (mrioc->num_io_throttle_group !=\n\t    mrioc->facts.max_io_throttle_group) {\n\t\tioc_err(mrioc,\n\t\t    \"max io throttle group doesn't match old(%d), new(%d)\\n\",\n\t\t    mrioc->num_io_throttle_group,\n\t\t    mrioc->facts.max_io_throttle_group);\n\t\tretval = -EPERM;\n\t\tgoto out;\n\t}\n\n\tmpi3mr_flush_delayed_cmd_lists(mrioc);\n\tmpi3mr_flush_drv_cmds(mrioc);\n\tbitmap_clear(mrioc->devrem_bitmap, 0, MPI3MR_NUM_DEVRMCMD);\n\tbitmap_clear(mrioc->removepend_bitmap, 0,\n\t\t     mrioc->dev_handle_bitmap_bits);\n\tbitmap_clear(mrioc->evtack_cmds_bitmap, 0, MPI3MR_NUM_EVTACKCMD);\n\tmpi3mr_flush_host_io(mrioc);\n\tmpi3mr_cleanup_fwevt_list(mrioc);\n\tmpi3mr_invalidate_devhandles(mrioc);\n\tmpi3mr_free_enclosure_list(mrioc);\n\n\tif (mrioc->prepare_for_reset) {\n\t\tmrioc->prepare_for_reset = 0;\n\t\tmrioc->prepare_for_reset_timeout_counter = 0;\n\t}\n\tmpi3mr_memset_buffers(mrioc);\n\tretval = mpi3mr_reinit_ioc(mrioc, 0);\n\tif (retval) {\n\t\tpr_err(IOCNAME \"reinit after soft reset failed: reason %d\\n\",\n\t\t    mrioc->name, reset_reason);\n\t\tgoto out;\n\t}\n\tssleep(MPI3MR_RESET_TOPOLOGY_SETTLE_TIME);\n\nout:\n\tif (!retval) {\n\t\tmrioc->diagsave_timeout = 0;\n\t\tmrioc->reset_in_progress = 0;\n\t\tmrioc->pel_abort_requested = 0;\n\t\tif (mrioc->pel_enabled) {\n\t\t\tmrioc->pel_cmds.retry_count = 0;\n\t\t\tmpi3mr_pel_wait_post(mrioc, &mrioc->pel_cmds);\n\t\t}\n\n\t\tmrioc->device_refresh_on = 0;\n\n\t\tmrioc->ts_update_counter = 0;\n\t\tspin_lock_irqsave(&mrioc->watchdog_lock, flags);\n\t\tif (mrioc->watchdog_work_q)\n\t\t\tqueue_delayed_work(mrioc->watchdog_work_q,\n\t\t\t    &mrioc->watchdog_work,\n\t\t\t    msecs_to_jiffies(MPI3MR_WATCHDOG_INTERVAL));\n\t\tspin_unlock_irqrestore(&mrioc->watchdog_lock, flags);\n\t\tmrioc->stop_bsgs = 0;\n\t\tif (mrioc->pel_enabled)\n\t\t\tatomic64_inc(&event_counter);\n\t} else {\n\t\tmpi3mr_issue_reset(mrioc,\n\t\t    MPI3_SYSIF_HOST_DIAG_RESET_ACTION_DIAG_FAULT, reset_reason);\n\t\tmrioc->device_refresh_on = 0;\n\t\tmrioc->unrecoverable = 1;\n\t\tmrioc->reset_in_progress = 0;\n\t\tretval = -1;\n\t\tmpi3mr_flush_cmds_for_unrecovered_controller(mrioc);\n\t}\n\tmrioc->prev_reset_result = retval;\n\tmutex_unlock(&mrioc->reset_mutex);\n\tioc_info(mrioc, \"controller reset is %s\\n\",\n\t    ((retval == 0) ? \"successful\" : \"failed\"));\n\treturn retval;\n}\n\n\n \nstatic void mpi3mr_free_config_dma_memory(struct mpi3mr_ioc *mrioc,\n\tstruct dma_memory_desc *mem_desc)\n{\n\tif ((mem_desc->size > mrioc->cfg_page_sz) && mem_desc->addr) {\n\t\tdma_free_coherent(&mrioc->pdev->dev, mem_desc->size,\n\t\t    mem_desc->addr, mem_desc->dma_addr);\n\t\tmem_desc->addr = NULL;\n\t}\n}\n\n \nstatic int mpi3mr_alloc_config_dma_memory(struct mpi3mr_ioc *mrioc,\n\tstruct dma_memory_desc *mem_desc)\n{\n\tif (mem_desc->size > mrioc->cfg_page_sz) {\n\t\tmem_desc->addr = dma_alloc_coherent(&mrioc->pdev->dev,\n\t\t    mem_desc->size, &mem_desc->dma_addr, GFP_KERNEL);\n\t\tif (!mem_desc->addr)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tmem_desc->addr = mrioc->cfg_page;\n\t\tmem_desc->dma_addr = mrioc->cfg_page_dma;\n\t\tmemset(mem_desc->addr, 0, mrioc->cfg_page_sz);\n\t}\n\treturn 0;\n}\n\n \nstatic int mpi3mr_post_cfg_req(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_config_request *cfg_req, int timeout, u16 *ioc_status)\n{\n\tint retval = 0;\n\n\tmutex_lock(&mrioc->cfg_cmds.mutex);\n\tif (mrioc->cfg_cmds.state & MPI3MR_CMD_PENDING) {\n\t\tretval = -1;\n\t\tioc_err(mrioc, \"sending config request failed due to command in use\\n\");\n\t\tmutex_unlock(&mrioc->cfg_cmds.mutex);\n\t\tgoto out;\n\t}\n\tmrioc->cfg_cmds.state = MPI3MR_CMD_PENDING;\n\tmrioc->cfg_cmds.is_waiting = 1;\n\tmrioc->cfg_cmds.callback = NULL;\n\tmrioc->cfg_cmds.ioc_status = 0;\n\tmrioc->cfg_cmds.ioc_loginfo = 0;\n\n\tcfg_req->host_tag = cpu_to_le16(MPI3MR_HOSTTAG_CFG_CMDS);\n\tcfg_req->function = MPI3_FUNCTION_CONFIG;\n\n\tinit_completion(&mrioc->cfg_cmds.done);\n\tdprint_cfg_info(mrioc, \"posting config request\\n\");\n\tif (mrioc->logging_level & MPI3_DEBUG_CFG_INFO)\n\t\tdprint_dump(cfg_req, sizeof(struct mpi3_config_request),\n\t\t    \"mpi3_cfg_req\");\n\tretval = mpi3mr_admin_request_post(mrioc, cfg_req, sizeof(*cfg_req), 1);\n\tif (retval) {\n\t\tioc_err(mrioc, \"posting config request failed\\n\");\n\t\tgoto out_unlock;\n\t}\n\twait_for_completion_timeout(&mrioc->cfg_cmds.done, (timeout * HZ));\n\tif (!(mrioc->cfg_cmds.state & MPI3MR_CMD_COMPLETE)) {\n\t\tmpi3mr_check_rh_fault_ioc(mrioc,\n\t\t    MPI3MR_RESET_FROM_CFG_REQ_TIMEOUT);\n\t\tioc_err(mrioc, \"config request timed out\\n\");\n\t\tretval = -1;\n\t\tgoto out_unlock;\n\t}\n\t*ioc_status = mrioc->cfg_cmds.ioc_status & MPI3_IOCSTATUS_STATUS_MASK;\n\tif ((*ioc_status) != MPI3_IOCSTATUS_SUCCESS)\n\t\tdprint_cfg_err(mrioc,\n\t\t    \"cfg_page request returned with ioc_status(0x%04x), log_info(0x%08x)\\n\",\n\t\t    *ioc_status, mrioc->cfg_cmds.ioc_loginfo);\n\nout_unlock:\n\tmrioc->cfg_cmds.state = MPI3MR_CMD_NOTUSED;\n\tmutex_unlock(&mrioc->cfg_cmds.mutex);\n\nout:\n\treturn retval;\n}\n\n \nstatic int mpi3mr_process_cfg_req(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_config_request *cfg_req,\n\tstruct mpi3_config_page_header *cfg_hdr, int timeout, u16 *ioc_status,\n\tvoid *cfg_buf, u32 cfg_buf_sz)\n{\n\tstruct dma_memory_desc mem_desc;\n\tint retval = -1;\n\tu8 invalid_action = 0;\n\tu8 sgl_flags = MPI3MR_SGEFLAGS_SYSTEM_SIMPLE_END_OF_LIST;\n\n\tmemset(&mem_desc, 0, sizeof(struct dma_memory_desc));\n\n\tif (cfg_req->action == MPI3_CONFIG_ACTION_PAGE_HEADER)\n\t\tmem_desc.size = sizeof(struct mpi3_config_page_header);\n\telse {\n\t\tif (!cfg_hdr) {\n\t\t\tioc_err(mrioc, \"null config header passed for config action(%d), page_type(0x%02x), page_num(%d)\\n\",\n\t\t\t    cfg_req->action, cfg_req->page_type,\n\t\t\t    cfg_req->page_number);\n\t\t\tgoto out;\n\t\t}\n\t\tswitch (cfg_hdr->page_attribute & MPI3_CONFIG_PAGEATTR_MASK) {\n\t\tcase MPI3_CONFIG_PAGEATTR_READ_ONLY:\n\t\t\tif (cfg_req->action\n\t\t\t    != MPI3_CONFIG_ACTION_READ_CURRENT)\n\t\t\t\tinvalid_action = 1;\n\t\t\tbreak;\n\t\tcase MPI3_CONFIG_PAGEATTR_CHANGEABLE:\n\t\t\tif ((cfg_req->action ==\n\t\t\t     MPI3_CONFIG_ACTION_READ_PERSISTENT) ||\n\t\t\t    (cfg_req->action ==\n\t\t\t     MPI3_CONFIG_ACTION_WRITE_PERSISTENT))\n\t\t\t\tinvalid_action = 1;\n\t\t\tbreak;\n\t\tcase MPI3_CONFIG_PAGEATTR_PERSISTENT:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (invalid_action) {\n\t\t\tioc_err(mrioc,\n\t\t\t    \"config action(%d) is not allowed for page_type(0x%02x), page_num(%d) with page_attribute(0x%02x)\\n\",\n\t\t\t    cfg_req->action, cfg_req->page_type,\n\t\t\t    cfg_req->page_number, cfg_hdr->page_attribute);\n\t\t\tgoto out;\n\t\t}\n\t\tmem_desc.size = le16_to_cpu(cfg_hdr->page_length) * 4;\n\t\tcfg_req->page_length = cfg_hdr->page_length;\n\t\tcfg_req->page_version = cfg_hdr->page_version;\n\t}\n\tif (mpi3mr_alloc_config_dma_memory(mrioc, &mem_desc))\n\t\tgoto out;\n\n\tmpi3mr_add_sg_single(&cfg_req->sgl, sgl_flags, mem_desc.size,\n\t    mem_desc.dma_addr);\n\n\tif ((cfg_req->action == MPI3_CONFIG_ACTION_WRITE_PERSISTENT) ||\n\t    (cfg_req->action == MPI3_CONFIG_ACTION_WRITE_CURRENT)) {\n\t\tmemcpy(mem_desc.addr, cfg_buf, min_t(u16, mem_desc.size,\n\t\t    cfg_buf_sz));\n\t\tdprint_cfg_info(mrioc, \"config buffer to be written\\n\");\n\t\tif (mrioc->logging_level & MPI3_DEBUG_CFG_INFO)\n\t\t\tdprint_dump(mem_desc.addr, mem_desc.size, \"cfg_buf\");\n\t}\n\n\tif (mpi3mr_post_cfg_req(mrioc, cfg_req, timeout, ioc_status))\n\t\tgoto out;\n\n\tretval = 0;\n\tif ((*ioc_status == MPI3_IOCSTATUS_SUCCESS) &&\n\t    (cfg_req->action != MPI3_CONFIG_ACTION_WRITE_PERSISTENT) &&\n\t    (cfg_req->action != MPI3_CONFIG_ACTION_WRITE_CURRENT)) {\n\t\tmemcpy(cfg_buf, mem_desc.addr, min_t(u16, mem_desc.size,\n\t\t    cfg_buf_sz));\n\t\tdprint_cfg_info(mrioc, \"config buffer read\\n\");\n\t\tif (mrioc->logging_level & MPI3_DEBUG_CFG_INFO)\n\t\t\tdprint_dump(mem_desc.addr, mem_desc.size, \"cfg_buf\");\n\t}\n\nout:\n\tmpi3mr_free_config_dma_memory(mrioc, &mem_desc);\n\treturn retval;\n}\n\n \nint mpi3mr_cfg_get_dev_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,\n\tstruct mpi3_device_page0 *dev_pg0, u16 pg_sz, u32 form, u32 form_spec)\n{\n\tstruct mpi3_config_page_header cfg_hdr;\n\tstruct mpi3_config_request cfg_req;\n\tu32 page_address;\n\n\tmemset(dev_pg0, 0, pg_sz);\n\tmemset(&cfg_hdr, 0, sizeof(cfg_hdr));\n\tmemset(&cfg_req, 0, sizeof(cfg_req));\n\n\tcfg_req.function = MPI3_FUNCTION_CONFIG;\n\tcfg_req.action = MPI3_CONFIG_ACTION_PAGE_HEADER;\n\tcfg_req.page_type = MPI3_CONFIG_PAGETYPE_DEVICE;\n\tcfg_req.page_number = 0;\n\tcfg_req.page_address = 0;\n\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, NULL,\n\t    MPI3MR_INTADMCMD_TIMEOUT, ioc_status, &cfg_hdr, sizeof(cfg_hdr))) {\n\t\tioc_err(mrioc, \"device page0 header read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tif (*ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"device page0 header read failed with ioc_status(0x%04x)\\n\",\n\t\t    *ioc_status);\n\t\tgoto out_failed;\n\t}\n\tcfg_req.action = MPI3_CONFIG_ACTION_READ_CURRENT;\n\tpage_address = ((form & MPI3_DEVICE_PGAD_FORM_MASK) |\n\t    (form_spec & MPI3_DEVICE_PGAD_HANDLE_MASK));\n\tcfg_req.page_address = cpu_to_le32(page_address);\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, &cfg_hdr,\n\t    MPI3MR_INTADMCMD_TIMEOUT, ioc_status, dev_pg0, pg_sz)) {\n\t\tioc_err(mrioc, \"device page0 read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\treturn 0;\nout_failed:\n\treturn -1;\n}\n\n\n \nint mpi3mr_cfg_get_sas_phy_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,\n\tstruct mpi3_sas_phy_page0 *phy_pg0, u16 pg_sz, u32 form,\n\tu32 form_spec)\n{\n\tstruct mpi3_config_page_header cfg_hdr;\n\tstruct mpi3_config_request cfg_req;\n\tu32 page_address;\n\n\tmemset(phy_pg0, 0, pg_sz);\n\tmemset(&cfg_hdr, 0, sizeof(cfg_hdr));\n\tmemset(&cfg_req, 0, sizeof(cfg_req));\n\n\tcfg_req.function = MPI3_FUNCTION_CONFIG;\n\tcfg_req.action = MPI3_CONFIG_ACTION_PAGE_HEADER;\n\tcfg_req.page_type = MPI3_CONFIG_PAGETYPE_SAS_PHY;\n\tcfg_req.page_number = 0;\n\tcfg_req.page_address = 0;\n\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, NULL,\n\t    MPI3MR_INTADMCMD_TIMEOUT, ioc_status, &cfg_hdr, sizeof(cfg_hdr))) {\n\t\tioc_err(mrioc, \"sas phy page0 header read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tif (*ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"sas phy page0 header read failed with ioc_status(0x%04x)\\n\",\n\t\t    *ioc_status);\n\t\tgoto out_failed;\n\t}\n\tcfg_req.action = MPI3_CONFIG_ACTION_READ_CURRENT;\n\tpage_address = ((form & MPI3_SAS_PHY_PGAD_FORM_MASK) |\n\t    (form_spec & MPI3_SAS_PHY_PGAD_PHY_NUMBER_MASK));\n\tcfg_req.page_address = cpu_to_le32(page_address);\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, &cfg_hdr,\n\t    MPI3MR_INTADMCMD_TIMEOUT, ioc_status, phy_pg0, pg_sz)) {\n\t\tioc_err(mrioc, \"sas phy page0 read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\treturn 0;\nout_failed:\n\treturn -1;\n}\n\n \nint mpi3mr_cfg_get_sas_phy_pg1(struct mpi3mr_ioc *mrioc, u16 *ioc_status,\n\tstruct mpi3_sas_phy_page1 *phy_pg1, u16 pg_sz, u32 form,\n\tu32 form_spec)\n{\n\tstruct mpi3_config_page_header cfg_hdr;\n\tstruct mpi3_config_request cfg_req;\n\tu32 page_address;\n\n\tmemset(phy_pg1, 0, pg_sz);\n\tmemset(&cfg_hdr, 0, sizeof(cfg_hdr));\n\tmemset(&cfg_req, 0, sizeof(cfg_req));\n\n\tcfg_req.function = MPI3_FUNCTION_CONFIG;\n\tcfg_req.action = MPI3_CONFIG_ACTION_PAGE_HEADER;\n\tcfg_req.page_type = MPI3_CONFIG_PAGETYPE_SAS_PHY;\n\tcfg_req.page_number = 1;\n\tcfg_req.page_address = 0;\n\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, NULL,\n\t    MPI3MR_INTADMCMD_TIMEOUT, ioc_status, &cfg_hdr, sizeof(cfg_hdr))) {\n\t\tioc_err(mrioc, \"sas phy page1 header read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tif (*ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"sas phy page1 header read failed with ioc_status(0x%04x)\\n\",\n\t\t    *ioc_status);\n\t\tgoto out_failed;\n\t}\n\tcfg_req.action = MPI3_CONFIG_ACTION_READ_CURRENT;\n\tpage_address = ((form & MPI3_SAS_PHY_PGAD_FORM_MASK) |\n\t    (form_spec & MPI3_SAS_PHY_PGAD_PHY_NUMBER_MASK));\n\tcfg_req.page_address = cpu_to_le32(page_address);\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, &cfg_hdr,\n\t    MPI3MR_INTADMCMD_TIMEOUT, ioc_status, phy_pg1, pg_sz)) {\n\t\tioc_err(mrioc, \"sas phy page1 read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\treturn 0;\nout_failed:\n\treturn -1;\n}\n\n\n \nint mpi3mr_cfg_get_sas_exp_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,\n\tstruct mpi3_sas_expander_page0 *exp_pg0, u16 pg_sz, u32 form,\n\tu32 form_spec)\n{\n\tstruct mpi3_config_page_header cfg_hdr;\n\tstruct mpi3_config_request cfg_req;\n\tu32 page_address;\n\n\tmemset(exp_pg0, 0, pg_sz);\n\tmemset(&cfg_hdr, 0, sizeof(cfg_hdr));\n\tmemset(&cfg_req, 0, sizeof(cfg_req));\n\n\tcfg_req.function = MPI3_FUNCTION_CONFIG;\n\tcfg_req.action = MPI3_CONFIG_ACTION_PAGE_HEADER;\n\tcfg_req.page_type = MPI3_CONFIG_PAGETYPE_SAS_EXPANDER;\n\tcfg_req.page_number = 0;\n\tcfg_req.page_address = 0;\n\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, NULL,\n\t    MPI3MR_INTADMCMD_TIMEOUT, ioc_status, &cfg_hdr, sizeof(cfg_hdr))) {\n\t\tioc_err(mrioc, \"expander page0 header read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tif (*ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"expander page0 header read failed with ioc_status(0x%04x)\\n\",\n\t\t    *ioc_status);\n\t\tgoto out_failed;\n\t}\n\tcfg_req.action = MPI3_CONFIG_ACTION_READ_CURRENT;\n\tpage_address = ((form & MPI3_SAS_EXPAND_PGAD_FORM_MASK) |\n\t    (form_spec & (MPI3_SAS_EXPAND_PGAD_PHYNUM_MASK |\n\t    MPI3_SAS_EXPAND_PGAD_HANDLE_MASK)));\n\tcfg_req.page_address = cpu_to_le32(page_address);\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, &cfg_hdr,\n\t    MPI3MR_INTADMCMD_TIMEOUT, ioc_status, exp_pg0, pg_sz)) {\n\t\tioc_err(mrioc, \"expander page0 read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\treturn 0;\nout_failed:\n\treturn -1;\n}\n\n \nint mpi3mr_cfg_get_sas_exp_pg1(struct mpi3mr_ioc *mrioc, u16 *ioc_status,\n\tstruct mpi3_sas_expander_page1 *exp_pg1, u16 pg_sz, u32 form,\n\tu32 form_spec)\n{\n\tstruct mpi3_config_page_header cfg_hdr;\n\tstruct mpi3_config_request cfg_req;\n\tu32 page_address;\n\n\tmemset(exp_pg1, 0, pg_sz);\n\tmemset(&cfg_hdr, 0, sizeof(cfg_hdr));\n\tmemset(&cfg_req, 0, sizeof(cfg_req));\n\n\tcfg_req.function = MPI3_FUNCTION_CONFIG;\n\tcfg_req.action = MPI3_CONFIG_ACTION_PAGE_HEADER;\n\tcfg_req.page_type = MPI3_CONFIG_PAGETYPE_SAS_EXPANDER;\n\tcfg_req.page_number = 1;\n\tcfg_req.page_address = 0;\n\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, NULL,\n\t    MPI3MR_INTADMCMD_TIMEOUT, ioc_status, &cfg_hdr, sizeof(cfg_hdr))) {\n\t\tioc_err(mrioc, \"expander page1 header read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tif (*ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"expander page1 header read failed with ioc_status(0x%04x)\\n\",\n\t\t    *ioc_status);\n\t\tgoto out_failed;\n\t}\n\tcfg_req.action = MPI3_CONFIG_ACTION_READ_CURRENT;\n\tpage_address = ((form & MPI3_SAS_EXPAND_PGAD_FORM_MASK) |\n\t    (form_spec & (MPI3_SAS_EXPAND_PGAD_PHYNUM_MASK |\n\t    MPI3_SAS_EXPAND_PGAD_HANDLE_MASK)));\n\tcfg_req.page_address = cpu_to_le32(page_address);\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, &cfg_hdr,\n\t    MPI3MR_INTADMCMD_TIMEOUT, ioc_status, exp_pg1, pg_sz)) {\n\t\tioc_err(mrioc, \"expander page1 read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\treturn 0;\nout_failed:\n\treturn -1;\n}\n\n \nint mpi3mr_cfg_get_enclosure_pg0(struct mpi3mr_ioc *mrioc, u16 *ioc_status,\n\tstruct mpi3_enclosure_page0 *encl_pg0, u16 pg_sz, u32 form,\n\tu32 form_spec)\n{\n\tstruct mpi3_config_page_header cfg_hdr;\n\tstruct mpi3_config_request cfg_req;\n\tu32 page_address;\n\n\tmemset(encl_pg0, 0, pg_sz);\n\tmemset(&cfg_hdr, 0, sizeof(cfg_hdr));\n\tmemset(&cfg_req, 0, sizeof(cfg_req));\n\n\tcfg_req.function = MPI3_FUNCTION_CONFIG;\n\tcfg_req.action = MPI3_CONFIG_ACTION_PAGE_HEADER;\n\tcfg_req.page_type = MPI3_CONFIG_PAGETYPE_ENCLOSURE;\n\tcfg_req.page_number = 0;\n\tcfg_req.page_address = 0;\n\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, NULL,\n\t    MPI3MR_INTADMCMD_TIMEOUT, ioc_status, &cfg_hdr, sizeof(cfg_hdr))) {\n\t\tioc_err(mrioc, \"enclosure page0 header read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tif (*ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"enclosure page0 header read failed with ioc_status(0x%04x)\\n\",\n\t\t    *ioc_status);\n\t\tgoto out_failed;\n\t}\n\tcfg_req.action = MPI3_CONFIG_ACTION_READ_CURRENT;\n\tpage_address = ((form & MPI3_ENCLOS_PGAD_FORM_MASK) |\n\t    (form_spec & MPI3_ENCLOS_PGAD_HANDLE_MASK));\n\tcfg_req.page_address = cpu_to_le32(page_address);\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, &cfg_hdr,\n\t    MPI3MR_INTADMCMD_TIMEOUT, ioc_status, encl_pg0, pg_sz)) {\n\t\tioc_err(mrioc, \"enclosure page0 read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\treturn 0;\nout_failed:\n\treturn -1;\n}\n\n\n \nint mpi3mr_cfg_get_sas_io_unit_pg0(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_sas_io_unit_page0 *sas_io_unit_pg0, u16 pg_sz)\n{\n\tstruct mpi3_config_page_header cfg_hdr;\n\tstruct mpi3_config_request cfg_req;\n\tu16 ioc_status = 0;\n\n\tmemset(sas_io_unit_pg0, 0, pg_sz);\n\tmemset(&cfg_hdr, 0, sizeof(cfg_hdr));\n\tmemset(&cfg_req, 0, sizeof(cfg_req));\n\n\tcfg_req.function = MPI3_FUNCTION_CONFIG;\n\tcfg_req.action = MPI3_CONFIG_ACTION_PAGE_HEADER;\n\tcfg_req.page_type = MPI3_CONFIG_PAGETYPE_SAS_IO_UNIT;\n\tcfg_req.page_number = 0;\n\tcfg_req.page_address = 0;\n\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, NULL,\n\t    MPI3MR_INTADMCMD_TIMEOUT, &ioc_status, &cfg_hdr, sizeof(cfg_hdr))) {\n\t\tioc_err(mrioc, \"sas io unit page0 header read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"sas io unit page0 header read failed with ioc_status(0x%04x)\\n\",\n\t\t    ioc_status);\n\t\tgoto out_failed;\n\t}\n\tcfg_req.action = MPI3_CONFIG_ACTION_READ_CURRENT;\n\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, &cfg_hdr,\n\t    MPI3MR_INTADMCMD_TIMEOUT, &ioc_status, sas_io_unit_pg0, pg_sz)) {\n\t\tioc_err(mrioc, \"sas io unit page0 read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"sas io unit page0 read failed with ioc_status(0x%04x)\\n\",\n\t\t    ioc_status);\n\t\tgoto out_failed;\n\t}\n\treturn 0;\nout_failed:\n\treturn -1;\n}\n\n \nint mpi3mr_cfg_get_sas_io_unit_pg1(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_sas_io_unit_page1 *sas_io_unit_pg1, u16 pg_sz)\n{\n\tstruct mpi3_config_page_header cfg_hdr;\n\tstruct mpi3_config_request cfg_req;\n\tu16 ioc_status = 0;\n\n\tmemset(sas_io_unit_pg1, 0, pg_sz);\n\tmemset(&cfg_hdr, 0, sizeof(cfg_hdr));\n\tmemset(&cfg_req, 0, sizeof(cfg_req));\n\n\tcfg_req.function = MPI3_FUNCTION_CONFIG;\n\tcfg_req.action = MPI3_CONFIG_ACTION_PAGE_HEADER;\n\tcfg_req.page_type = MPI3_CONFIG_PAGETYPE_SAS_IO_UNIT;\n\tcfg_req.page_number = 1;\n\tcfg_req.page_address = 0;\n\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, NULL,\n\t    MPI3MR_INTADMCMD_TIMEOUT, &ioc_status, &cfg_hdr, sizeof(cfg_hdr))) {\n\t\tioc_err(mrioc, \"sas io unit page1 header read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"sas io unit page1 header read failed with ioc_status(0x%04x)\\n\",\n\t\t    ioc_status);\n\t\tgoto out_failed;\n\t}\n\tcfg_req.action = MPI3_CONFIG_ACTION_READ_CURRENT;\n\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, &cfg_hdr,\n\t    MPI3MR_INTADMCMD_TIMEOUT, &ioc_status, sas_io_unit_pg1, pg_sz)) {\n\t\tioc_err(mrioc, \"sas io unit page1 read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"sas io unit page1 read failed with ioc_status(0x%04x)\\n\",\n\t\t    ioc_status);\n\t\tgoto out_failed;\n\t}\n\treturn 0;\nout_failed:\n\treturn -1;\n}\n\n \nint mpi3mr_cfg_set_sas_io_unit_pg1(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_sas_io_unit_page1 *sas_io_unit_pg1, u16 pg_sz)\n{\n\tstruct mpi3_config_page_header cfg_hdr;\n\tstruct mpi3_config_request cfg_req;\n\tu16 ioc_status = 0;\n\n\tmemset(&cfg_hdr, 0, sizeof(cfg_hdr));\n\tmemset(&cfg_req, 0, sizeof(cfg_req));\n\n\tcfg_req.function = MPI3_FUNCTION_CONFIG;\n\tcfg_req.action = MPI3_CONFIG_ACTION_PAGE_HEADER;\n\tcfg_req.page_type = MPI3_CONFIG_PAGETYPE_SAS_IO_UNIT;\n\tcfg_req.page_number = 1;\n\tcfg_req.page_address = 0;\n\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, NULL,\n\t    MPI3MR_INTADMCMD_TIMEOUT, &ioc_status, &cfg_hdr, sizeof(cfg_hdr))) {\n\t\tioc_err(mrioc, \"sas io unit page1 header read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"sas io unit page1 header read failed with ioc_status(0x%04x)\\n\",\n\t\t    ioc_status);\n\t\tgoto out_failed;\n\t}\n\tcfg_req.action = MPI3_CONFIG_ACTION_WRITE_CURRENT;\n\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, &cfg_hdr,\n\t    MPI3MR_INTADMCMD_TIMEOUT, &ioc_status, sas_io_unit_pg1, pg_sz)) {\n\t\tioc_err(mrioc, \"sas io unit page1 write current failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"sas io unit page1 write current failed with ioc_status(0x%04x)\\n\",\n\t\t    ioc_status);\n\t\tgoto out_failed;\n\t}\n\n\tcfg_req.action = MPI3_CONFIG_ACTION_WRITE_PERSISTENT;\n\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, &cfg_hdr,\n\t    MPI3MR_INTADMCMD_TIMEOUT, &ioc_status, sas_io_unit_pg1, pg_sz)) {\n\t\tioc_err(mrioc, \"sas io unit page1 write persistent failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"sas io unit page1 write persistent failed with ioc_status(0x%04x)\\n\",\n\t\t    ioc_status);\n\t\tgoto out_failed;\n\t}\n\treturn 0;\nout_failed:\n\treturn -1;\n}\n\n \nint mpi3mr_cfg_get_driver_pg1(struct mpi3mr_ioc *mrioc,\n\tstruct mpi3_driver_page1 *driver_pg1, u16 pg_sz)\n{\n\tstruct mpi3_config_page_header cfg_hdr;\n\tstruct mpi3_config_request cfg_req;\n\tu16 ioc_status = 0;\n\n\tmemset(driver_pg1, 0, pg_sz);\n\tmemset(&cfg_hdr, 0, sizeof(cfg_hdr));\n\tmemset(&cfg_req, 0, sizeof(cfg_req));\n\n\tcfg_req.function = MPI3_FUNCTION_CONFIG;\n\tcfg_req.action = MPI3_CONFIG_ACTION_PAGE_HEADER;\n\tcfg_req.page_type = MPI3_CONFIG_PAGETYPE_DRIVER;\n\tcfg_req.page_number = 1;\n\tcfg_req.page_address = 0;\n\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, NULL,\n\t    MPI3MR_INTADMCMD_TIMEOUT, &ioc_status, &cfg_hdr, sizeof(cfg_hdr))) {\n\t\tioc_err(mrioc, \"driver page1 header read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"driver page1 header read failed with ioc_status(0x%04x)\\n\",\n\t\t    ioc_status);\n\t\tgoto out_failed;\n\t}\n\tcfg_req.action = MPI3_CONFIG_ACTION_READ_CURRENT;\n\n\tif (mpi3mr_process_cfg_req(mrioc, &cfg_req, &cfg_hdr,\n\t    MPI3MR_INTADMCMD_TIMEOUT, &ioc_status, driver_pg1, pg_sz)) {\n\t\tioc_err(mrioc, \"driver page1 read failed\\n\");\n\t\tgoto out_failed;\n\t}\n\tif (ioc_status != MPI3_IOCSTATUS_SUCCESS) {\n\t\tioc_err(mrioc, \"driver page1 read failed with ioc_status(0x%04x)\\n\",\n\t\t    ioc_status);\n\t\tgoto out_failed;\n\t}\n\treturn 0;\nout_failed:\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}