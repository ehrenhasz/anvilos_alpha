{
  "module_name": "fdomain.c",
  "hash_id": "3cec80efa6e11a310afdbf21c4429b0b521cccd53650306be2a16238bb89ab09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/fdomain.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/workqueue.h>\n#include <scsi/scsicam.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include \"fdomain.h\"\n\n \n#define FIFO_COUNT\t2\t \n#define PARITY_MASK\tACTL_PAREN\t \n\nenum chip_type {\n\tunknown\t\t= 0x00,\n\ttmc1800\t\t= 0x01,\n\ttmc18c50\t= 0x02,\n\ttmc18c30\t= 0x03,\n};\n\nstruct fdomain {\n\tint base;\n\tstruct scsi_cmnd *cur_cmd;\n\tenum chip_type chip;\n\tstruct work_struct work;\n};\n\nstatic struct scsi_pointer *fdomain_scsi_pointer(struct scsi_cmnd *cmd)\n{\n\treturn scsi_cmd_priv(cmd);\n}\n\nstatic inline void fdomain_make_bus_idle(struct fdomain *fd)\n{\n\toutb(0, fd->base + REG_BCTL);\n\toutb(0, fd->base + REG_MCTL);\n\tif (fd->chip == tmc18c50 || fd->chip == tmc18c30)\n\t\t \n\t\toutb(ACTL_RESET | ACTL_CLRFIRQ | PARITY_MASK,\n\t\t     fd->base + REG_ACTL);\n\telse\n\t\toutb(ACTL_RESET | PARITY_MASK, fd->base + REG_ACTL);\n}\n\nstatic enum chip_type fdomain_identify(int port)\n{\n\tu16 id = inb(port + REG_ID_LSB) | inb(port + REG_ID_MSB) << 8;\n\n\tswitch (id) {\n\tcase 0x6127:\n\t\treturn tmc1800;\n\tcase 0x60e9:  \n\t\tbreak;\n\tdefault:\n\t\treturn unknown;\n\t}\n\n\t \n\toutb(CFG2_32BIT, port + REG_CFG2);\n\tif ((inb(port + REG_CFG2) & CFG2_32BIT)) {\n\t\toutb(0, port + REG_CFG2);\n\t\tif ((inb(port + REG_CFG2) & CFG2_32BIT) == 0)\n\t\t\treturn tmc18c30;\n\t}\n\t \n\treturn tmc18c50;\n}\n\nstatic int fdomain_test_loopback(int base)\n{\n\tint i;\n\n\tfor (i = 0; i < 255; i++) {\n\t\toutb(i, base + REG_LOOPBACK);\n\t\tif (inb(base + REG_LOOPBACK) != i)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void fdomain_reset(int base)\n{\n\toutb(BCTL_RST, base + REG_BCTL);\n\tmdelay(20);\n\toutb(0, base + REG_BCTL);\n\tmdelay(1150);\n\toutb(0, base + REG_MCTL);\n\toutb(PARITY_MASK, base + REG_ACTL);\n}\n\nstatic int fdomain_select(struct Scsi_Host *sh, int target)\n{\n\tint status;\n\tunsigned long timeout;\n\tstruct fdomain *fd = shost_priv(sh);\n\n\toutb(BCTL_BUSEN | BCTL_SEL, fd->base + REG_BCTL);\n\toutb(BIT(sh->this_id) | BIT(target), fd->base + REG_SCSI_DATA_NOACK);\n\n\t \n\toutb(PARITY_MASK, fd->base + REG_ACTL);\n\n\ttimeout = 350;\t \n\n\tdo {\n\t\tstatus = inb(fd->base + REG_BSTAT);\n\t\tif (status & BSTAT_BSY) {\n\t\t\t \n\t\t\t \n\t\t\toutb(BCTL_BUSEN, fd->base + REG_BCTL);\n\t\t\treturn 0;\n\t\t}\n\t\tmdelay(1);\n\t} while (--timeout);\n\tfdomain_make_bus_idle(fd);\n\treturn 1;\n}\n\nstatic void fdomain_finish_cmd(struct fdomain *fd)\n{\n\toutb(0, fd->base + REG_ICTL);\n\tfdomain_make_bus_idle(fd);\n\tscsi_done(fd->cur_cmd);\n\tfd->cur_cmd = NULL;\n}\n\nstatic void fdomain_read_data(struct scsi_cmnd *cmd)\n{\n\tstruct fdomain *fd = shost_priv(cmd->device->host);\n\tunsigned char *virt, *ptr;\n\tsize_t offset, len;\n\n\twhile ((len = inw(fd->base + REG_FIFO_COUNT)) > 0) {\n\t\toffset = scsi_bufflen(cmd) - scsi_get_resid(cmd);\n\t\tvirt = scsi_kmap_atomic_sg(scsi_sglist(cmd), scsi_sg_count(cmd),\n\t\t\t\t\t   &offset, &len);\n\t\tptr = virt + offset;\n\t\tif (len & 1)\n\t\t\t*ptr++ = inb(fd->base + REG_FIFO);\n\t\tif (len > 1)\n\t\t\tinsw(fd->base + REG_FIFO, ptr, len >> 1);\n\t\tscsi_set_resid(cmd, scsi_get_resid(cmd) - len);\n\t\tscsi_kunmap_atomic_sg(virt);\n\t}\n}\n\nstatic void fdomain_write_data(struct scsi_cmnd *cmd)\n{\n\tstruct fdomain *fd = shost_priv(cmd->device->host);\n\t \n\tint FIFO_Size = fd->chip == tmc18c30 ? 0x800 : 0x2000;\n\tunsigned char *virt, *ptr;\n\tsize_t offset, len;\n\n\twhile ((len = FIFO_Size - inw(fd->base + REG_FIFO_COUNT)) > 512) {\n\t\toffset = scsi_bufflen(cmd) - scsi_get_resid(cmd);\n\t\tif (len + offset > scsi_bufflen(cmd)) {\n\t\t\tlen = scsi_bufflen(cmd) - offset;\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tvirt = scsi_kmap_atomic_sg(scsi_sglist(cmd), scsi_sg_count(cmd),\n\t\t\t\t\t   &offset, &len);\n\t\tptr = virt + offset;\n\t\tif (len & 1)\n\t\t\toutb(*ptr++, fd->base + REG_FIFO);\n\t\tif (len > 1)\n\t\t\toutsw(fd->base + REG_FIFO, ptr, len >> 1);\n\t\tscsi_set_resid(cmd, scsi_get_resid(cmd) - len);\n\t\tscsi_kunmap_atomic_sg(virt);\n\t}\n}\n\nstatic void fdomain_work(struct work_struct *work)\n{\n\tstruct fdomain *fd = container_of(work, struct fdomain, work);\n\tstruct Scsi_Host *sh = container_of((void *)fd, struct Scsi_Host,\n\t\t\t\t\t    hostdata);\n\tstruct scsi_cmnd *cmd = fd->cur_cmd;\n\tstruct scsi_pointer *scsi_pointer = fdomain_scsi_pointer(cmd);\n\tunsigned long flags;\n\tint status;\n\tint done = 0;\n\n\tspin_lock_irqsave(sh->host_lock, flags);\n\n\tif (scsi_pointer->phase & in_arbitration) {\n\t\tstatus = inb(fd->base + REG_ASTAT);\n\t\tif (!(status & ASTAT_ARB)) {\n\t\t\tset_host_byte(cmd, DID_BUS_BUSY);\n\t\t\tfdomain_finish_cmd(fd);\n\t\t\tgoto out;\n\t\t}\n\t\tscsi_pointer->phase = in_selection;\n\n\t\toutb(ICTL_SEL | FIFO_COUNT, fd->base + REG_ICTL);\n\t\toutb(BCTL_BUSEN | BCTL_SEL, fd->base + REG_BCTL);\n\t\toutb(BIT(cmd->device->host->this_id) | BIT(scmd_id(cmd)),\n\t\t     fd->base + REG_SCSI_DATA_NOACK);\n\t\t \n\t\toutb(ACTL_IRQEN | PARITY_MASK, fd->base + REG_ACTL);\n\t\tgoto out;\n\t} else if (scsi_pointer->phase & in_selection) {\n\t\tstatus = inb(fd->base + REG_BSTAT);\n\t\tif (!(status & BSTAT_BSY)) {\n\t\t\t \n\t\t\tif (fdomain_select(cmd->device->host, scmd_id(cmd))) {\n\t\t\t\tset_host_byte(cmd, DID_NO_CONNECT);\n\t\t\t\tfdomain_finish_cmd(fd);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\toutb(ACTL_IRQEN | PARITY_MASK, fd->base + REG_ACTL);\n\t\t}\n\t\tscsi_pointer->phase = in_other;\n\t\toutb(ICTL_FIFO | ICTL_REQ | FIFO_COUNT, fd->base + REG_ICTL);\n\t\toutb(BCTL_BUSEN, fd->base + REG_BCTL);\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = inb(fd->base + REG_BSTAT);\n\n\tif (status & BSTAT_REQ) {\n\t\tswitch (status & (BSTAT_MSG | BSTAT_CMD | BSTAT_IO)) {\n\t\tcase BSTAT_CMD:\t \n\t\t\toutb(cmd->cmnd[scsi_pointer->sent_command++],\n\t\t\t     fd->base + REG_SCSI_DATA);\n\t\t\tbreak;\n\t\tcase 0:\t \n\t\t\tif (fd->chip != tmc1800 && !scsi_pointer->have_data_in) {\n\t\t\t\tscsi_pointer->have_data_in = -1;\n\t\t\t\toutb(ACTL_IRQEN | ACTL_FIFOWR | ACTL_FIFOEN |\n\t\t\t\t     PARITY_MASK, fd->base + REG_ACTL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BSTAT_IO:\t \n\t\t\tif (fd->chip != tmc1800 && !scsi_pointer->have_data_in) {\n\t\t\t\tscsi_pointer->have_data_in = 1;\n\t\t\t\toutb(ACTL_IRQEN | ACTL_FIFOEN | PARITY_MASK,\n\t\t\t\t     fd->base + REG_ACTL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BSTAT_CMD | BSTAT_IO:\t \n\t\t\tscsi_pointer->Status = inb(fd->base + REG_SCSI_DATA);\n\t\t\tbreak;\n\t\tcase BSTAT_MSG | BSTAT_CMD:\t \n\t\t\toutb(MESSAGE_REJECT, fd->base + REG_SCSI_DATA);\n\t\t\tbreak;\n\t\tcase BSTAT_MSG | BSTAT_CMD | BSTAT_IO:\t \n\t\t\tscsi_pointer->Message = inb(fd->base + REG_SCSI_DATA);\n\t\t\tif (scsi_pointer->Message == COMMAND_COMPLETE)\n\t\t\t\t++done;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fd->chip == tmc1800 && !scsi_pointer->have_data_in &&\n\t    scsi_pointer->sent_command >= cmd->cmd_len) {\n\t\tif (cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\t\tscsi_pointer->have_data_in = -1;\n\t\t\toutb(ACTL_IRQEN | ACTL_FIFOWR | ACTL_FIFOEN |\n\t\t\t     PARITY_MASK, fd->base + REG_ACTL);\n\t\t} else {\n\t\t\tscsi_pointer->have_data_in = 1;\n\t\t\toutb(ACTL_IRQEN | ACTL_FIFOEN | PARITY_MASK,\n\t\t\t     fd->base + REG_ACTL);\n\t\t}\n\t}\n\n\tif (scsi_pointer->have_data_in == -1)  \n\t\tfdomain_write_data(cmd);\n\n\tif (scsi_pointer->have_data_in == 1)  \n\t\tfdomain_read_data(cmd);\n\n\tif (done) {\n\t\tset_status_byte(cmd, scsi_pointer->Status);\n\t\tset_host_byte(cmd, DID_OK);\n\t\tscsi_msg_to_host_byte(cmd, scsi_pointer->Message);\n\t\tfdomain_finish_cmd(fd);\n\t} else {\n\t\tif (scsi_pointer->phase & disconnect) {\n\t\t\toutb(ICTL_FIFO | ICTL_SEL | ICTL_REQ | FIFO_COUNT,\n\t\t\t     fd->base + REG_ICTL);\n\t\t\toutb(0, fd->base + REG_BCTL);\n\t\t} else\n\t\t\toutb(ICTL_FIFO | ICTL_REQ | FIFO_COUNT,\n\t\t\t     fd->base + REG_ICTL);\n\t}\nout:\n\tspin_unlock_irqrestore(sh->host_lock, flags);\n}\n\nstatic irqreturn_t fdomain_irq(int irq, void *dev_id)\n{\n\tstruct fdomain *fd = dev_id;\n\n\t \n\tif ((inb(fd->base + REG_ASTAT) & ASTAT_IRQ) == 0)\n\t\treturn IRQ_NONE;\n\n\toutb(0, fd->base + REG_ICTL);\n\n\t \n\tif (!fd->cur_cmd)\t \n\t\treturn IRQ_NONE;\n\n\tschedule_work(&fd->work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int fdomain_queue(struct Scsi_Host *sh, struct scsi_cmnd *cmd)\n{\n\tstruct scsi_pointer *scsi_pointer = fdomain_scsi_pointer(cmd);\n\tstruct fdomain *fd = shost_priv(cmd->device->host);\n\tunsigned long flags;\n\n\tscsi_pointer->Status\t\t= 0;\n\tscsi_pointer->Message\t\t= 0;\n\tscsi_pointer->have_data_in\t= 0;\n\tscsi_pointer->sent_command\t= 0;\n\tscsi_pointer->phase\t\t= in_arbitration;\n\tscsi_set_resid(cmd, scsi_bufflen(cmd));\n\n\tspin_lock_irqsave(sh->host_lock, flags);\n\n\tfd->cur_cmd = cmd;\n\n\tfdomain_make_bus_idle(fd);\n\n\t \n\toutb(0, fd->base + REG_ICTL);\n\toutb(0, fd->base + REG_BCTL);\t \n\t \n\toutb(BIT(cmd->device->host->this_id), fd->base + REG_SCSI_DATA_NOACK);\n\toutb(ICTL_ARB, fd->base + REG_ICTL);\n\t \n\toutb(ACTL_ARB | ACTL_IRQEN | PARITY_MASK, fd->base + REG_ACTL);\n\n\tspin_unlock_irqrestore(sh->host_lock, flags);\n\n\treturn 0;\n}\n\nstatic int fdomain_abort(struct scsi_cmnd *cmd)\n{\n\tstruct Scsi_Host *sh = cmd->device->host;\n\tstruct fdomain *fd = shost_priv(sh);\n\tunsigned long flags;\n\n\tif (!fd->cur_cmd)\n\t\treturn FAILED;\n\n\tspin_lock_irqsave(sh->host_lock, flags);\n\n\tfdomain_make_bus_idle(fd);\n\tfdomain_scsi_pointer(fd->cur_cmd)->phase |= aborted;\n\n\t \n\tset_host_byte(fd->cur_cmd, DID_ABORT);\n\tfdomain_finish_cmd(fd);\n\tspin_unlock_irqrestore(sh->host_lock, flags);\n\treturn SUCCESS;\n}\n\nstatic int fdomain_host_reset(struct scsi_cmnd *cmd)\n{\n\tstruct Scsi_Host *sh = cmd->device->host;\n\tstruct fdomain *fd = shost_priv(sh);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(sh->host_lock, flags);\n\tfdomain_reset(fd->base);\n\tspin_unlock_irqrestore(sh->host_lock, flags);\n\treturn SUCCESS;\n}\n\nstatic int fdomain_biosparam(struct scsi_device *sdev,\n\t\t\t     struct block_device *bdev,\tsector_t capacity,\n\t\t\t     int geom[])\n{\n\tunsigned char *p = scsi_bios_ptable(bdev);\n\n\tif (p && p[65] == 0xaa && p[64] == 0x55  \n\t    && p[4]) {\t  \n\t\tgeom[0] = p[5] + 1;\t \n\t\tgeom[1] = p[6] & 0x3f;\t \n\t} else {\n\t\tif (capacity >= 0x7e0000) {\n\t\t\tgeom[0] = 255;\t \n\t\t\tgeom[1] = 63;\t \n\t\t} else if (capacity >= 0x200000) {\n\t\t\tgeom[0] = 128;\t \n\t\t\tgeom[1] = 63;\t \n\t\t} else {\n\t\t\tgeom[0] = 64;\t \n\t\t\tgeom[1] = 32;\t \n\t\t}\n\t}\n\tgeom[2] = sector_div(capacity, geom[0] * geom[1]);\n\tkfree(p);\n\n\treturn 0;\n}\n\nstatic const struct scsi_host_template fdomain_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"Future Domain TMC-16x0\",\n\t.proc_name\t\t= \"fdomain\",\n\t.queuecommand\t\t= fdomain_queue,\n\t.eh_abort_handler\t= fdomain_abort,\n\t.eh_host_reset_handler\t= fdomain_host_reset,\n\t.bios_param\t\t= fdomain_biosparam,\n\t.can_queue\t\t= 1,\n\t.this_id\t\t= 7,\n\t.sg_tablesize\t\t= 64,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n\t.cmd_size\t\t= sizeof(struct scsi_pointer),\n};\n\nstruct Scsi_Host *fdomain_create(int base, int irq, int this_id,\n\t\t\t\t struct device *dev)\n{\n\tstruct Scsi_Host *sh;\n\tstruct fdomain *fd;\n\tenum chip_type chip;\n\tstatic const char * const chip_names[] = {\n\t\t\"Unknown\", \"TMC-1800\", \"TMC-18C50\", \"TMC-18C30\"\n\t};\n\tunsigned long irq_flags = 0;\n\n\tchip = fdomain_identify(base);\n\tif (!chip)\n\t\treturn NULL;\n\n\tfdomain_reset(base);\n\n\tif (fdomain_test_loopback(base))\n\t\treturn NULL;\n\n\tif (!irq) {\n\t\tdev_err(dev, \"card has no IRQ assigned\");\n\t\treturn NULL;\n\t}\n\n\tsh = scsi_host_alloc(&fdomain_template, sizeof(struct fdomain));\n\tif (!sh)\n\t\treturn NULL;\n\n\tif (this_id)\n\t\tsh->this_id = this_id & 0x07;\n\n\tsh->irq = irq;\n\tsh->io_port = base;\n\tsh->n_io_port = FDOMAIN_REGION_SIZE;\n\n\tfd = shost_priv(sh);\n\tfd->base = base;\n\tfd->chip = chip;\n\tINIT_WORK(&fd->work, fdomain_work);\n\n\tif (dev_is_pci(dev) || !strcmp(dev->bus->name, \"pcmcia\"))\n\t\tirq_flags = IRQF_SHARED;\n\n\tif (request_irq(irq, fdomain_irq, irq_flags, \"fdomain\", fd))\n\t\tgoto fail_put;\n\n\tshost_printk(KERN_INFO, sh, \"%s chip at 0x%x irq %d SCSI ID %d\\n\",\n\t\t     dev_is_pci(dev) ? \"TMC-36C70 (PCI bus)\" : chip_names[chip],\n\t\t     base, irq, sh->this_id);\n\n\tif (scsi_add_host(sh, dev))\n\t\tgoto fail_free_irq;\n\n\tscsi_scan_host(sh);\n\n\treturn sh;\n\nfail_free_irq:\n\tfree_irq(irq, fd);\nfail_put:\n\tscsi_host_put(sh);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(fdomain_create);\n\nint fdomain_destroy(struct Scsi_Host *sh)\n{\n\tstruct fdomain *fd = shost_priv(sh);\n\n\tcancel_work_sync(&fd->work);\n\tscsi_remove_host(sh);\n\tif (sh->irq)\n\t\tfree_irq(sh->irq, fd);\n\tscsi_host_put(sh);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fdomain_destroy);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int fdomain_resume(struct device *dev)\n{\n\tstruct fdomain *fd = shost_priv(dev_get_drvdata(dev));\n\n\tfdomain_reset(fd->base);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(fdomain_pm_ops, NULL, fdomain_resume);\n#endif  \n\nMODULE_AUTHOR(\"Ondrej Zary, Rickard E. Faith\");\nMODULE_DESCRIPTION(\"Future Domain TMC-16x0/TMC-3260 SCSI driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}