{
  "module_name": "a2091.c",
  "hash_id": "d9c75530e2bde867975f1d7c95d08fc2572c762268305e6faec6de09e4c71920",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/a2091.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/zorro.h>\n#include <linux/module.h>\n\n#include <asm/page.h>\n#include <asm/amigaints.h>\n#include <asm/amigahw.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_tcq.h>\n#include \"wd33c93.h\"\n#include \"a2091.h\"\n\n\nstruct a2091_hostdata {\n\tstruct WD33C93_hostdata wh;\n\tstruct a2091_scsiregs *regs;\n\tstruct device *dev;\n};\n\n#define DMA_DIR(d)   ((d == DATA_OUT_DIR) ? DMA_TO_DEVICE : DMA_FROM_DEVICE)\n\nstatic irqreturn_t a2091_intr(int irq, void *data)\n{\n\tstruct Scsi_Host *instance = data;\n\tstruct a2091_hostdata *hdata = shost_priv(instance);\n\tunsigned int status = hdata->regs->ISTR;\n\tunsigned long flags;\n\n\tif (!(status & (ISTR_INT_F | ISTR_INT_P)) || !(status & ISTR_INTS))\n\t\treturn IRQ_NONE;\n\n\tspin_lock_irqsave(instance->host_lock, flags);\n\twd33c93_intr(instance);\n\tspin_unlock_irqrestore(instance->host_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic int dma_setup(struct scsi_cmnd *cmd, int dir_in)\n{\n\tstruct scsi_pointer *scsi_pointer = WD33C93_scsi_pointer(cmd);\n\tunsigned long len = scsi_pointer->this_residual;\n\tstruct Scsi_Host *instance = cmd->device->host;\n\tstruct a2091_hostdata *hdata = shost_priv(instance);\n\tstruct WD33C93_hostdata *wh = &hdata->wh;\n\tstruct a2091_scsiregs *regs = hdata->regs;\n\tunsigned short cntr = CNTR_PDMD | CNTR_INTEN;\n\tdma_addr_t addr;\n\n\taddr = dma_map_single(hdata->dev, scsi_pointer->ptr,\n\t\t\t      len, DMA_DIR(dir_in));\n\tif (dma_mapping_error(hdata->dev, addr)) {\n\t\tdev_warn(hdata->dev, \"cannot map SCSI data block %p\\n\",\n\t\t\t scsi_pointer->ptr);\n\t\treturn 1;\n\t}\n\tscsi_pointer->dma_handle = addr;\n\n\t \n\tif (addr & A2091_XFER_MASK) {\n\t\t \n\t\tdma_unmap_single(hdata->dev, scsi_pointer->dma_handle,\n\t\t\t\t scsi_pointer->this_residual,\n\t\t\t\t DMA_DIR(dir_in));\n\t\tscsi_pointer->dma_handle = (dma_addr_t) NULL;\n\n\t\twh->dma_bounce_len = (scsi_pointer->this_residual + 511) & ~0x1ff;\n\t\twh->dma_bounce_buffer = kmalloc(wh->dma_bounce_len,\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\t \n\t\tif (!wh->dma_bounce_buffer) {\n\t\t\twh->dma_bounce_len = 0;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (!dir_in) {\n\t\t\t \n\t\t\tmemcpy(wh->dma_bounce_buffer, scsi_pointer->ptr,\n\t\t\t       scsi_pointer->this_residual);\n\t\t}\n\n\t\t \n\t\taddr = dma_map_single(hdata->dev, wh->dma_bounce_buffer,\n\t\t\t\t      wh->dma_bounce_len, DMA_DIR(dir_in));\n\t\t \n\t\tif (dma_mapping_error(hdata->dev, addr)) {\n\t\t\tdev_warn(hdata->dev, \"cannot map bounce buffer %p\\n\",\n\t\t\t\t wh->dma_bounce_buffer);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tif (addr & A2091_XFER_MASK) {\n\t\t\t \n\t\t\tkfree(wh->dma_bounce_buffer);\n\t\t\twh->dma_bounce_buffer = NULL;\n\t\t\twh->dma_bounce_len = 0;\n\t\t\treturn 1;\n\t\t}\n\n\t\tscsi_pointer->dma_handle = addr;\n\t}\n\n\t \n\tif (!dir_in)\n\t\tcntr |= CNTR_DDIR;\n\n\t \n\twh->dma_dir = dir_in;\n\n\tregs->CNTR = cntr;\n\n\t \n\tregs->ACR = addr;\n\n\t \n\n\t \n\tregs->ST_DMA = 1;\n\n\t \n\treturn 0;\n}\n\nstatic void dma_stop(struct Scsi_Host *instance, struct scsi_cmnd *SCpnt,\n\t\t     int status)\n{\n\tstruct scsi_pointer *scsi_pointer = WD33C93_scsi_pointer(SCpnt);\n\tstruct a2091_hostdata *hdata = shost_priv(instance);\n\tstruct WD33C93_hostdata *wh = &hdata->wh;\n\tstruct a2091_scsiregs *regs = hdata->regs;\n\n\t \n\tunsigned short cntr = CNTR_PDMD;\n\n\tif (!wh->dma_dir)\n\t\tcntr |= CNTR_DDIR;\n\n\t \n\tregs->CNTR = cntr;\n\n\t \n\tif (wh->dma_dir) {\n\t\tregs->FLUSH = 1;\n\t\twhile (!(regs->ISTR & ISTR_FE_FLG))\n\t\t\t;\n\t}\n\n\t \n\tregs->CINT = 1;\n\n\t \n\tregs->SP_DMA = 1;\n\n\t \n\tregs->CNTR = CNTR_PDMD | CNTR_INTEN;\n\n\tdma_unmap_single(hdata->dev, scsi_pointer->dma_handle,\n\t\t\t scsi_pointer->this_residual,\n\t\t\t DMA_DIR(wh->dma_dir));\n\n\t \n\tif (status && wh->dma_bounce_buffer) {\n\t\tif (wh->dma_dir)\n\t\t\tmemcpy(scsi_pointer->ptr, wh->dma_bounce_buffer,\n\t\t\t       scsi_pointer->this_residual);\n\t\tkfree(wh->dma_bounce_buffer);\n\t\twh->dma_bounce_buffer = NULL;\n\t\twh->dma_bounce_len = 0;\n\t}\n}\n\nstatic const struct scsi_host_template a2091_scsi_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"Commodore A2091/A590 SCSI\",\n\t.show_info\t\t= wd33c93_show_info,\n\t.write_info\t\t= wd33c93_write_info,\n\t.proc_name\t\t= \"A2901\",\n\t.queuecommand\t\t= wd33c93_queuecommand,\n\t.eh_abort_handler\t= wd33c93_abort,\n\t.eh_host_reset_handler\t= wd33c93_host_reset,\n\t.can_queue\t\t= CAN_QUEUE,\n\t.this_id\t\t= 7,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.cmd_per_lun\t\t= CMD_PER_LUN,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n\t.cmd_size\t\t= sizeof(struct scsi_pointer),\n};\n\nstatic int a2091_probe(struct zorro_dev *z, const struct zorro_device_id *ent)\n{\n\tstruct Scsi_Host *instance;\n\tint error;\n\tstruct a2091_scsiregs *regs;\n\twd33c93_regs wdregs;\n\tstruct a2091_hostdata *hdata;\n\n\tif (dma_set_mask_and_coherent(&z->dev, DMA_BIT_MASK(24))) {\n\t\tdev_warn(&z->dev, \"cannot use 24 bit DMA\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!request_mem_region(z->resource.start, 256, \"wd33c93\"))\n\t\treturn -EBUSY;\n\n\tinstance = scsi_host_alloc(&a2091_scsi_template,\n\t\t\t\t   sizeof(struct a2091_hostdata));\n\tif (!instance) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_alloc;\n\t}\n\n\tinstance->irq = IRQ_AMIGA_PORTS;\n\tinstance->unique_id = z->slotaddr;\n\n\tregs = ZTWO_VADDR(z->resource.start);\n\tregs->DAWR = DAWR_A2091;\n\n\twdregs.SASR = &regs->SASR;\n\twdregs.SCMD = &regs->SCMD;\n\n\thdata = shost_priv(instance);\n\thdata->dev = &z->dev;\n\thdata->wh.no_sync = 0xff;\n\thdata->wh.fast = 0;\n\thdata->wh.dma_mode = CTRL_DMA;\n\thdata->regs = regs;\n\n\twd33c93_init(instance, wdregs, dma_setup, dma_stop, WD33C93_FS_8_10);\n\terror = request_irq(IRQ_AMIGA_PORTS, a2091_intr, IRQF_SHARED,\n\t\t\t    \"A2091 SCSI\", instance);\n\tif (error)\n\t\tgoto fail_irq;\n\n\tregs->CNTR = CNTR_PDMD | CNTR_INTEN;\n\n\terror = scsi_add_host(instance, NULL);\n\tif (error)\n\t\tgoto fail_host;\n\n\tzorro_set_drvdata(z, instance);\n\n\tscsi_scan_host(instance);\n\treturn 0;\n\nfail_host:\n\tfree_irq(IRQ_AMIGA_PORTS, instance);\nfail_irq:\n\tscsi_host_put(instance);\nfail_alloc:\n\trelease_mem_region(z->resource.start, 256);\n\treturn error;\n}\n\nstatic void a2091_remove(struct zorro_dev *z)\n{\n\tstruct Scsi_Host *instance = zorro_get_drvdata(z);\n\tstruct a2091_hostdata *hdata = shost_priv(instance);\n\n\thdata->regs->CNTR = 0;\n\tscsi_remove_host(instance);\n\tfree_irq(IRQ_AMIGA_PORTS, instance);\n\tscsi_host_put(instance);\n\trelease_mem_region(z->resource.start, 256);\n}\n\nstatic struct zorro_device_id a2091_zorro_tbl[] = {\n\t{ ZORRO_PROD_CBM_A590_A2091_1 },\n\t{ ZORRO_PROD_CBM_A590_A2091_2 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(zorro, a2091_zorro_tbl);\n\nstatic struct zorro_driver a2091_driver = {\n\t.name\t\t= \"a2091\",\n\t.id_table\t= a2091_zorro_tbl,\n\t.probe\t\t= a2091_probe,\n\t.remove\t\t= a2091_remove,\n};\n\nstatic int __init a2091_init(void)\n{\n\treturn zorro_register_driver(&a2091_driver);\n}\nmodule_init(a2091_init);\n\nstatic void __exit a2091_exit(void)\n{\n\tzorro_unregister_driver(&a2091_driver);\n}\nmodule_exit(a2091_exit);\n\nMODULE_DESCRIPTION(\"Commodore A2091/A590 SCSI\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}