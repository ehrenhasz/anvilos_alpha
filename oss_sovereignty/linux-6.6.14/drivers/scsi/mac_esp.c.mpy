{
  "module_name": "mac_esp.c",
  "hash_id": "f21a9e03abf7242406288de57068f16511f74715acbf074633727d39b4317c12",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mac_esp.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/nubus.h>\n#include <linux/slab.h>\n\n#include <asm/irq.h>\n#include <asm/dma.h>\n#include <asm/macints.h>\n#include <asm/macintosh.h>\n#include <asm/mac_via.h>\n\n#include <scsi/scsi_host.h>\n\n#include \"esp_scsi.h\"\n\n#define DRV_MODULE_NAME     \"mac_esp\"\n#define PFX                 DRV_MODULE_NAME \": \"\n#define DRV_VERSION         \"1.000\"\n#define DRV_MODULE_RELDATE  \"Sept 15, 2007\"\n\n#define MAC_ESP_IO_BASE          0x50F00000\n#define MAC_ESP_REGS_QUADRA      (MAC_ESP_IO_BASE + 0x10000)\n#define MAC_ESP_REGS_QUADRA2     (MAC_ESP_IO_BASE + 0xF000)\n#define MAC_ESP_REGS_QUADRA3     (MAC_ESP_IO_BASE + 0x18000)\n#define MAC_ESP_REGS_SPACING     0x402\n#define MAC_ESP_PDMA_REG         0xF9800024\n#define MAC_ESP_PDMA_REG_SPACING 0x4\n#define MAC_ESP_PDMA_IO_OFFSET   0x100\n\n#define esp_read8(REG)\t\tmac_esp_read8(esp, REG)\n#define esp_write8(VAL, REG)\tmac_esp_write8(esp, VAL, REG)\n\nstruct mac_esp_priv {\n\tstruct esp *esp;\n\tvoid __iomem *pdma_regs;\n\tvoid __iomem *pdma_io;\n};\nstatic struct esp *esp_chips[2];\nstatic DEFINE_SPINLOCK(esp_chips_lock);\n\n#define MAC_ESP_GET_PRIV(esp) ((struct mac_esp_priv *) \\\n\t\t\t       dev_get_drvdata((esp)->dev))\n\nstatic inline void mac_esp_write8(struct esp *esp, u8 val, unsigned long reg)\n{\n\tnubus_writeb(val, esp->regs + reg * 16);\n}\n\nstatic inline u8 mac_esp_read8(struct esp *esp, unsigned long reg)\n{\n\treturn nubus_readb(esp->regs + reg * 16);\n}\n\nstatic void mac_esp_reset_dma(struct esp *esp)\n{\n\t \n}\n\nstatic void mac_esp_dma_drain(struct esp *esp)\n{\n\t \n}\n\nstatic void mac_esp_dma_invalidate(struct esp *esp)\n{\n\t \n}\n\nstatic int mac_esp_dma_error(struct esp *esp)\n{\n\treturn esp->send_cmd_error;\n}\n\nstatic inline int mac_esp_wait_for_empty_fifo(struct esp *esp)\n{\n\tint i = 500000;\n\n\tdo {\n\t\tif (!(esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES))\n\t\t\treturn 0;\n\n\t\tif (esp_read8(ESP_STATUS) & ESP_STAT_INTR)\n\t\t\treturn 1;\n\n\t\tudelay(2);\n\t} while (--i);\n\n\tprintk(KERN_ERR PFX \"FIFO is not empty (sreg %02x)\\n\",\n\t       esp_read8(ESP_STATUS));\n\tesp->send_cmd_error = 1;\n\treturn 1;\n}\n\nstatic inline int mac_esp_wait_for_dreq(struct esp *esp)\n{\n\tstruct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);\n\tint i = 500000;\n\n\tdo {\n\t\tif (mep->pdma_regs == NULL) {\n\t\t\tif (via2_scsi_drq_pending())\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (nubus_readl(mep->pdma_regs) & 0x200)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tif (esp_read8(ESP_STATUS) & ESP_STAT_INTR)\n\t\t\treturn 1;\n\n\t\tudelay(2);\n\t} while (--i);\n\n\tprintk(KERN_ERR PFX \"PDMA timeout (sreg %02x)\\n\",\n\t       esp_read8(ESP_STATUS));\n\tesp->send_cmd_error = 1;\n\treturn 1;\n}\n\n#define MAC_ESP_PDMA_LOOP(operands) \\\n\tasm volatile ( \\\n\t     \"       tstw %1                   \\n\" \\\n\t     \"       jbeq 20f                  \\n\" \\\n\t     \"1:     movew \" operands \"        \\n\" \\\n\t     \"2:     movew \" operands \"        \\n\" \\\n\t     \"3:     movew \" operands \"        \\n\" \\\n\t     \"4:     movew \" operands \"        \\n\" \\\n\t     \"5:     movew \" operands \"        \\n\" \\\n\t     \"6:     movew \" operands \"        \\n\" \\\n\t     \"7:     movew \" operands \"        \\n\" \\\n\t     \"8:     movew \" operands \"        \\n\" \\\n\t     \"9:     movew \" operands \"        \\n\" \\\n\t     \"10:    movew \" operands \"        \\n\" \\\n\t     \"11:    movew \" operands \"        \\n\" \\\n\t     \"12:    movew \" operands \"        \\n\" \\\n\t     \"13:    movew \" operands \"        \\n\" \\\n\t     \"14:    movew \" operands \"        \\n\" \\\n\t     \"15:    movew \" operands \"        \\n\" \\\n\t     \"16:    movew \" operands \"        \\n\" \\\n\t     \"       subqw #1,%1               \\n\" \\\n\t     \"       jbne 1b                   \\n\" \\\n\t     \"20:    tstw %2                   \\n\" \\\n\t     \"       jbeq 30f                  \\n\" \\\n\t     \"21:    movew \" operands \"        \\n\" \\\n\t     \"       subqw #1,%2               \\n\" \\\n\t     \"       jbne 21b                  \\n\" \\\n\t     \"30:    tstw %3                   \\n\" \\\n\t     \"       jbeq 40f                  \\n\" \\\n\t     \"31:    moveb \" operands \"        \\n\" \\\n\t     \"32:    nop                       \\n\" \\\n\t     \"40:                              \\n\" \\\n\t     \"                                 \\n\" \\\n\t     \"       .section __ex_table,\\\"a\\\" \\n\" \\\n\t     \"       .align  4                 \\n\" \\\n\t     \"       .long   1b,40b            \\n\" \\\n\t     \"       .long   2b,40b            \\n\" \\\n\t     \"       .long   3b,40b            \\n\" \\\n\t     \"       .long   4b,40b            \\n\" \\\n\t     \"       .long   5b,40b            \\n\" \\\n\t     \"       .long   6b,40b            \\n\" \\\n\t     \"       .long   7b,40b            \\n\" \\\n\t     \"       .long   8b,40b            \\n\" \\\n\t     \"       .long   9b,40b            \\n\" \\\n\t     \"       .long  10b,40b            \\n\" \\\n\t     \"       .long  11b,40b            \\n\" \\\n\t     \"       .long  12b,40b            \\n\" \\\n\t     \"       .long  13b,40b            \\n\" \\\n\t     \"       .long  14b,40b            \\n\" \\\n\t     \"       .long  15b,40b            \\n\" \\\n\t     \"       .long  16b,40b            \\n\" \\\n\t     \"       .long  21b,40b            \\n\" \\\n\t     \"       .long  31b,40b            \\n\" \\\n\t     \"       .long  32b,40b            \\n\" \\\n\t     \"       .previous                 \\n\" \\\n\t     : \"+a\" (addr), \"+r\" (count32), \"+r\" (count2) \\\n\t     : \"g\" (count1), \"a\" (mep->pdma_io))\n\nstatic void mac_esp_send_pdma_cmd(struct esp *esp, u32 addr, u32 esp_count,\n\t\t\t\t  u32 dma_count, int write, u8 cmd)\n{\n\tstruct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);\n\n\tesp->send_cmd_error = 0;\n\n\tif (!write)\n\t\tscsi_esp_cmd(esp, ESP_CMD_FLUSH);\n\n\tesp_write8((esp_count >> 0) & 0xFF, ESP_TCLOW);\n\tesp_write8((esp_count >> 8) & 0xFF, ESP_TCMED);\n\n\tscsi_esp_cmd(esp, cmd);\n\n\tdo {\n\t\tunsigned int count32 = esp_count >> 5;\n\t\tunsigned int count2 = (esp_count & 0x1F) >> 1;\n\t\tunsigned int count1 = esp_count & 1;\n\t\tunsigned int start_addr = addr;\n\n\t\tif (mac_esp_wait_for_dreq(esp))\n\t\t\tbreak;\n\n\t\tif (write) {\n\t\t\tMAC_ESP_PDMA_LOOP(\"%4@,%0@+\");\n\n\t\t\tesp_count -= addr - start_addr;\n\t\t} else {\n\t\t\tunsigned int n;\n\n\t\t\tMAC_ESP_PDMA_LOOP(\"%0@+,%4@\");\n\n\t\t\tif (mac_esp_wait_for_empty_fifo(esp))\n\t\t\t\tbreak;\n\n\t\t\tn = (esp_read8(ESP_TCMED) << 8) + esp_read8(ESP_TCLOW);\n\t\t\taddr = start_addr + esp_count - n;\n\t\t\tesp_count = n;\n\t\t}\n\t} while (esp_count);\n}\n\nstatic int mac_esp_irq_pending(struct esp *esp)\n{\n\tif (esp_read8(ESP_STATUS) & ESP_STAT_INTR)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic u32 mac_esp_dma_length_limit(struct esp *esp, u32 dma_addr, u32 dma_len)\n{\n\treturn dma_len > 0xFFFF ? 0xFFFF : dma_len;\n}\n\nstatic irqreturn_t mac_scsi_esp_intr(int irq, void *dev_id)\n{\n\tint got_intr;\n\n\t \n\n\tdo {\n\t\tgot_intr = 0;\n\t\tif (esp_chips[0] &&\n\t\t    (mac_esp_read8(esp_chips[0], ESP_STATUS) & ESP_STAT_INTR)) {\n\t\t\t(void)scsi_esp_intr(irq, esp_chips[0]);\n\t\t\tgot_intr = 1;\n\t\t}\n\t\tif (esp_chips[1] &&\n\t\t    (mac_esp_read8(esp_chips[1], ESP_STATUS) & ESP_STAT_INTR)) {\n\t\t\t(void)scsi_esp_intr(irq, esp_chips[1]);\n\t\t\tgot_intr = 1;\n\t\t}\n\t} while (got_intr);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct esp_driver_ops mac_esp_ops = {\n\t.esp_write8       = mac_esp_write8,\n\t.esp_read8        = mac_esp_read8,\n\t.irq_pending      = mac_esp_irq_pending,\n\t.dma_length_limit = mac_esp_dma_length_limit,\n\t.reset_dma        = mac_esp_reset_dma,\n\t.dma_drain        = mac_esp_dma_drain,\n\t.dma_invalidate   = mac_esp_dma_invalidate,\n\t.send_dma_cmd     = mac_esp_send_pdma_cmd,\n\t.dma_error        = mac_esp_dma_error,\n};\n\nstatic int esp_mac_probe(struct platform_device *dev)\n{\n\tconst struct scsi_host_template *tpnt = &scsi_esp_template;\n\tstruct Scsi_Host *host;\n\tstruct esp *esp;\n\tint err;\n\tstruct mac_esp_priv *mep;\n\n\tif (!MACH_IS_MAC)\n\t\treturn -ENODEV;\n\n\tif (dev->id > 1)\n\t\treturn -ENODEV;\n\n\thost = scsi_host_alloc(tpnt, sizeof(struct esp));\n\n\terr = -ENOMEM;\n\tif (!host)\n\t\tgoto fail;\n\n\thost->max_id = 8;\n\thost->dma_boundary = PAGE_SIZE - 1;\n\tesp = shost_priv(host);\n\n\tesp->host = host;\n\tesp->dev = &dev->dev;\n\n\tesp->command_block = kzalloc(16, GFP_KERNEL);\n\tif (!esp->command_block)\n\t\tgoto fail_unlink;\n\tesp->command_block_dma = (dma_addr_t)esp->command_block;\n\n\tesp->scsi_id = 7;\n\thost->this_id = esp->scsi_id;\n\tesp->scsi_id_mask = 1 << esp->scsi_id;\n\n\tmep = kzalloc(sizeof(struct mac_esp_priv), GFP_KERNEL);\n\tif (!mep)\n\t\tgoto fail_free_command_block;\n\tmep->esp = esp;\n\tplatform_set_drvdata(dev, mep);\n\n\tswitch (macintosh_config->scsi_type) {\n\tcase MAC_SCSI_QUADRA:\n\t\tesp->cfreq     = 16500000;\n\t\tesp->regs      = (void __iomem *)MAC_ESP_REGS_QUADRA;\n\t\tmep->pdma_io   = esp->regs + MAC_ESP_PDMA_IO_OFFSET;\n\t\tmep->pdma_regs = NULL;\n\t\tbreak;\n\tcase MAC_SCSI_QUADRA2:\n\t\tesp->cfreq     = 25000000;\n\t\tesp->regs      = (void __iomem *)(MAC_ESP_REGS_QUADRA2 +\n\t\t\t\t dev->id * MAC_ESP_REGS_SPACING);\n\t\tmep->pdma_io   = esp->regs + MAC_ESP_PDMA_IO_OFFSET;\n\t\tmep->pdma_regs = (void __iomem *)(MAC_ESP_PDMA_REG +\n\t\t\t\t dev->id * MAC_ESP_PDMA_REG_SPACING);\n\t\tnubus_writel(0x1d1, mep->pdma_regs);\n\t\tbreak;\n\tcase MAC_SCSI_QUADRA3:\n\t\t \n\t\tesp->cfreq     = 25000000;\n\t\tesp->regs      = (void __iomem *)MAC_ESP_REGS_QUADRA3;\n\t\tmep->pdma_io   = NULL;\n\t\tmep->pdma_regs = NULL;\n\t\tbreak;\n\t}\n\tesp->fifo_reg = esp->regs + ESP_FDATA * 16;\n\n\tesp->ops = &mac_esp_ops;\n\tesp->flags = ESP_FLAG_NO_DMA_MAP;\n\tif (mep->pdma_io == NULL) {\n\t\tprintk(KERN_INFO PFX \"using PIO for controller %d\\n\", dev->id);\n\t\tesp_write8(0, ESP_TCLOW);\n\t\tesp_write8(0, ESP_TCMED);\n\t\tesp->flags |= ESP_FLAG_DISABLE_SYNC;\n\t\tmac_esp_ops.send_dma_cmd = esp_send_pio_cmd;\n\t} else {\n\t\tprintk(KERN_INFO PFX \"using PDMA for controller %d\\n\", dev->id);\n\t}\n\n\thost->irq = IRQ_MAC_SCSI;\n\n\t \n\terr = request_irq(host->irq, mac_scsi_esp_intr, 0, \"ESP\", NULL);\n\tspin_lock(&esp_chips_lock);\n\tif (err < 0 && esp_chips[!dev->id] == NULL) {\n\t\tspin_unlock(&esp_chips_lock);\n\t\tgoto fail_free_priv;\n\t}\n\tesp_chips[dev->id] = esp;\n\tspin_unlock(&esp_chips_lock);\n\n\terr = scsi_esp_register(esp);\n\tif (err)\n\t\tgoto fail_free_irq;\n\n\treturn 0;\n\nfail_free_irq:\n\tspin_lock(&esp_chips_lock);\n\tesp_chips[dev->id] = NULL;\n\tif (esp_chips[!dev->id] == NULL) {\n\t\tspin_unlock(&esp_chips_lock);\n\t\tfree_irq(host->irq, NULL);\n\t} else\n\t\tspin_unlock(&esp_chips_lock);\nfail_free_priv:\n\tkfree(mep);\nfail_free_command_block:\n\tkfree(esp->command_block);\nfail_unlink:\n\tscsi_host_put(host);\nfail:\n\treturn err;\n}\n\nstatic int esp_mac_remove(struct platform_device *dev)\n{\n\tstruct mac_esp_priv *mep = platform_get_drvdata(dev);\n\tstruct esp *esp = mep->esp;\n\tunsigned int irq = esp->host->irq;\n\n\tscsi_esp_unregister(esp);\n\n\tspin_lock(&esp_chips_lock);\n\tesp_chips[dev->id] = NULL;\n\tif (esp_chips[!dev->id] == NULL) {\n\t\tspin_unlock(&esp_chips_lock);\n\t\tfree_irq(irq, NULL);\n\t} else\n\t\tspin_unlock(&esp_chips_lock);\n\n\tkfree(mep);\n\n\tkfree(esp->command_block);\n\n\tscsi_host_put(esp->host);\n\n\treturn 0;\n}\n\nstatic struct platform_driver esp_mac_driver = {\n\t.probe    = esp_mac_probe,\n\t.remove   = esp_mac_remove,\n\t.driver   = {\n\t\t.name\t= DRV_MODULE_NAME,\n\t},\n};\nmodule_platform_driver(esp_mac_driver);\n\nMODULE_DESCRIPTION(\"Mac ESP SCSI driver\");\nMODULE_AUTHOR(\"Finn Thain\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_ALIAS(\"platform:\" DRV_MODULE_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}