{
  "module_name": "qla1280.c",
  "hash_id": "0e350501fd81f454d1d89467a065767f5ac10850510e96102c961568fae9caf6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla1280.c",
  "human_readable_source": "\n \n#define QLA1280_VERSION      \"3.27.1\"\n \n\n\n#include <linux/module.h>\n\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/timer.h>\n#include <linux/pci.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/pci_ids.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/byteorder.h>\n#include <asm/processor.h>\n#include <asm/types.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n\n\n \n#define  DEBUG_QLA1280_INTR\t0\n#define  DEBUG_PRINT_NVRAM\t0\n#define  DEBUG_QLA1280\t\t0\n\n#define\tMEMORY_MAPPED_IO\t1\n\n#include \"qla1280.h\"\n\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\n#define QLA_64BIT_PTR\t1\n#endif\n\n#define NVRAM_DELAY()\t\t\tudelay(500)\t \n\n#define IS_ISP1040(ha) (ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP1020)\n#define IS_ISP1x40(ha) (ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP1020 || \\\n\t\t\tha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP1240)\n#define IS_ISP1x160(ha)        (ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP10160 || \\\n\t\t\t\tha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP12160)\n\n\nstatic int qla1280_probe_one(struct pci_dev *, const struct pci_device_id *);\nstatic void qla1280_remove_one(struct pci_dev *);\n\n \nstatic void qla1280_done(struct scsi_qla_host *);\nstatic int qla1280_get_token(char *);\nstatic int qla1280_setup(char *s) __init;\n\n \nstatic int qla1280_load_firmware(struct scsi_qla_host *);\nstatic int qla1280_init_rings(struct scsi_qla_host *);\nstatic int qla1280_nvram_config(struct scsi_qla_host *);\nstatic int qla1280_mailbox_command(struct scsi_qla_host *,\n\t\t\t\t   uint8_t, uint16_t *);\nstatic int qla1280_bus_reset(struct scsi_qla_host *, int);\nstatic int qla1280_device_reset(struct scsi_qla_host *, int, int);\nstatic int qla1280_abort_command(struct scsi_qla_host *, struct srb *, int);\nstatic int qla1280_abort_isp(struct scsi_qla_host *);\n#ifdef QLA_64BIT_PTR\nstatic int qla1280_64bit_start_scsi(struct scsi_qla_host *, struct srb *);\n#else\nstatic int qla1280_32bit_start_scsi(struct scsi_qla_host *, struct srb *);\n#endif\nstatic void qla1280_nv_write(struct scsi_qla_host *, uint16_t);\nstatic void qla1280_poll(struct scsi_qla_host *);\nstatic void qla1280_reset_adapter(struct scsi_qla_host *);\nstatic void qla1280_marker(struct scsi_qla_host *, int, int, int, u8);\nstatic void qla1280_isp_cmd(struct scsi_qla_host *);\nstatic void qla1280_isr(struct scsi_qla_host *, struct list_head *);\nstatic void qla1280_rst_aen(struct scsi_qla_host *);\nstatic void qla1280_status_entry(struct scsi_qla_host *, struct response *,\n\t\t\t\t struct list_head *);\nstatic void qla1280_error_entry(struct scsi_qla_host *, struct response *,\n\t\t\t\tstruct list_head *);\nstatic uint16_t qla1280_get_nvram_word(struct scsi_qla_host *, uint32_t);\nstatic uint16_t qla1280_nvram_request(struct scsi_qla_host *, uint32_t);\nstatic uint16_t qla1280_debounce_register(volatile uint16_t __iomem *);\nstatic request_t *qla1280_req_pkt(struct scsi_qla_host *);\nstatic int qla1280_check_for_dead_scsi_bus(struct scsi_qla_host *,\n\t\t\t\t\t   unsigned int);\nstatic void qla1280_get_target_parameters(struct scsi_qla_host *,\n\t\t\t\t\t   struct scsi_device *);\nstatic int qla1280_set_target_parameters(struct scsi_qla_host *, int, int);\n\n\nstatic struct qla_driver_setup driver_setup;\n\n \nstatic inline uint16_t\nqla1280_data_direction(struct scsi_cmnd *cmnd)\n{\n\tswitch(cmnd->sc_data_direction) {\n\tcase DMA_FROM_DEVICE:\n\t\treturn BIT_5;\n\tcase DMA_TO_DEVICE:\n\t\treturn BIT_6;\n\tcase DMA_BIDIRECTIONAL:\n\t\treturn BIT_5 | BIT_6;\n\t \n\tcase DMA_NONE:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\t\t\n#if DEBUG_QLA1280\nstatic void __qla1280_print_scsi_cmd(struct scsi_cmnd * cmd);\nstatic void __qla1280_dump_buffer(char *, int);\n#endif\n\n\n \n#ifdef MODULE\nstatic char *qla1280;\n\n \nmodule_param(qla1280, charp, 0);\n#else\n__setup(\"qla1280=\", qla1280_setup);\n#endif\n\n\n#define\tCMD_CDBLEN(Cmnd)\tCmnd->cmd_len\n#define\tCMD_CDBP(Cmnd)\t\tCmnd->cmnd\n#define\tCMD_SNSP(Cmnd)\t\tCmnd->sense_buffer\n#define\tCMD_SNSLEN(Cmnd)\tSCSI_SENSE_BUFFERSIZE\n#define\tCMD_RESULT(Cmnd)\tCmnd->result\n#define\tCMD_HANDLE(Cmnd)\tCmnd->host_scribble\n\n#define CMD_HOST(Cmnd)\t\tCmnd->device->host\n#define SCSI_BUS_32(Cmnd)\tCmnd->device->channel\n#define SCSI_TCN_32(Cmnd)\tCmnd->device->id\n#define SCSI_LUN_32(Cmnd)\tCmnd->device->lun\n\n\n \n \n \n\nstruct qla_boards {\n\tchar *name;\t\t \n\tint numPorts;\t\t \n\tint fw_index;\t\t \n};\n\n \nstatic struct pci_device_id qla1280_pci_tbl[] = {\n\t{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP12160,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1020,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, 1},\n\t{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1080,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, 2},\n\t{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1240,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, 3},\n\t{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1280,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, 4},\n\t{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP10160,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, 5},\n\t{0,}\n};\nMODULE_DEVICE_TABLE(pci, qla1280_pci_tbl);\n\nstatic DEFINE_MUTEX(qla1280_firmware_mutex);\n\nstruct qla_fw {\n\tchar *fwname;\n\tconst struct firmware *fw;\n};\n\n#define QL_NUM_FW_IMAGES 3\n\nstatic struct qla_fw qla1280_fw_tbl[QL_NUM_FW_IMAGES] = {\n\t{\"qlogic/1040.bin\",  NULL},\t \n\t{\"qlogic/1280.bin\",  NULL},\t \n\t{\"qlogic/12160.bin\", NULL},\t \n};\n\n \nstatic struct qla_boards ql1280_board_tbl[] = {\n\t{.name = \"QLA12160\", .numPorts = 2, .fw_index = 2},\n\t{.name = \"QLA1040\" , .numPorts = 1, .fw_index = 0},\n\t{.name = \"QLA1080\" , .numPorts = 1, .fw_index = 1},\n\t{.name = \"QLA1240\" , .numPorts = 2, .fw_index = 1},\n\t{.name = \"QLA1280\" , .numPorts = 2, .fw_index = 1},\n\t{.name = \"QLA10160\", .numPorts = 1, .fw_index = 2},\n\t{.name = \"        \", .numPorts = 0, .fw_index = -1},\n};\n\nstatic int qla1280_verbose = 1;\n\n#if DEBUG_QLA1280\nstatic int ql_debug_level = 1;\n#define dprintk(level, format, a...)\t\\\n\tdo { if (ql_debug_level >= level) printk(KERN_ERR format, ##a); } while(0)\n#define qla1280_dump_buffer(level, buf, size)\t\\\n\tif (ql_debug_level >= level) __qla1280_dump_buffer(buf, size)\n#define qla1280_print_scsi_cmd(level, cmd)\t\\\n\tif (ql_debug_level >= level) __qla1280_print_scsi_cmd(cmd)\n#else\n#define ql_debug_level\t\t\t0\n#define dprintk(level, format, a...)\tdo{}while(0)\n#define qla1280_dump_buffer(a, b, c)\tdo{}while(0)\n#define qla1280_print_scsi_cmd(a, b)\tdo{}while(0)\n#endif\n\n#define ENTER(x)\t\tdprintk(3, \"qla1280 : Entering %s()\\n\", x);\n#define LEAVE(x)\t\tdprintk(3, \"qla1280 : Leaving %s()\\n\", x);\n#define ENTER_INTR(x)\t\tdprintk(4, \"qla1280 : Entering %s()\\n\", x);\n#define LEAVE_INTR(x)\t\tdprintk(4, \"qla1280 : Leaving %s()\\n\", x);\n\n\nstatic int qla1280_read_nvram(struct scsi_qla_host *ha)\n{\n\tuint16_t *wptr;\n\tuint8_t chksum;\n\tint cnt, i;\n\tstruct nvram *nv;\n\n\tENTER(\"qla1280_read_nvram\");\n\n\tif (driver_setup.no_nvram)\n\t\treturn 1;\n\n\tprintk(KERN_INFO \"scsi(%ld): Reading NVRAM\\n\", ha->host_no);\n\n\twptr = (uint16_t *)&ha->nvram;\n\tnv = &ha->nvram;\n\tchksum = 0;\n\tfor (cnt = 0; cnt < 3; cnt++) {\n\t\t*wptr = qla1280_get_nvram_word(ha, cnt);\n\t\tchksum += *wptr & 0xff;\n\t\tchksum += (*wptr >> 8) & 0xff;\n\t\twptr++;\n\t}\n\n\tif (nv->id0 != 'I' || nv->id1 != 'S' ||\n\t    nv->id2 != 'P' || nv->id3 != ' ' || nv->version < 1) {\n\t\tdprintk(2, \"Invalid nvram ID or version!\\n\");\n\t\tchksum = 1;\n\t} else {\n\t\tfor (; cnt < sizeof(struct nvram); cnt++) {\n\t\t\t*wptr = qla1280_get_nvram_word(ha, cnt);\n\t\t\tchksum += *wptr & 0xff;\n\t\t\tchksum += (*wptr >> 8) & 0xff;\n\t\t\twptr++;\n\t\t}\n\t}\n\n\tdprintk(3, \"qla1280_read_nvram: NVRAM Magic ID= %c %c %c %02x\"\n\t       \" version %i\\n\", nv->id0, nv->id1, nv->id2, nv->id3,\n\t       nv->version);\n\n\n\tif (chksum) {\n\t\tif (!driver_setup.no_nvram)\n\t\t\tprintk(KERN_WARNING \"scsi(%ld): Unable to identify or \"\n\t\t\t       \"validate NVRAM checksum, using default \"\n\t\t\t       \"settings\\n\", ha->host_no);\n\t\tha->nvram_valid = 0;\n\t} else\n\t\tha->nvram_valid = 1;\n\n\t \n\tnv->isp_parameter = cpu_to_le16(nv->isp_parameter);\n\tnv->firmware_feature.w = cpu_to_le16(nv->firmware_feature.w);\n\tfor(i = 0; i < MAX_BUSES; i++) {\n\t\tnv->bus[i].selection_timeout = cpu_to_le16(nv->bus[i].selection_timeout);\n\t\tnv->bus[i].max_queue_depth = cpu_to_le16(nv->bus[i].max_queue_depth);\n\t}\n\tdprintk(1, \"qla1280_read_nvram: Completed Reading NVRAM\\n\");\n\tLEAVE(\"qla1280_read_nvram\");\n\n\treturn chksum;\n}\n\n \nstatic const char *\nqla1280_info(struct Scsi_Host *host)\n{\n\tstatic char qla1280_scsi_name_buffer[125];\n\tchar *bp;\n\tstruct scsi_qla_host *ha;\n\tstruct qla_boards *bdp;\n\n\tbp = &qla1280_scsi_name_buffer[0];\n\tha = (struct scsi_qla_host *)host->hostdata;\n\tbdp = &ql1280_board_tbl[ha->devnum];\n\tmemset(bp, 0, sizeof(qla1280_scsi_name_buffer));\n\n\tsprintf (bp,\n\t\t \"QLogic %s PCI to SCSI Host Adapter\\n\"\n\t\t \"       Firmware version: %2d.%02d.%02d, Driver version %s\",\n\t\t &bdp->name[0], ha->fwver1, ha->fwver2, ha->fwver3,\n\t\t QLA1280_VERSION);\n\treturn bp;\n}\n\n \nstatic int qla1280_queuecommand_lck(struct scsi_cmnd *cmd)\n{\n\tstruct Scsi_Host *host = cmd->device->host;\n\tstruct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;\n\tstruct srb *sp = scsi_cmd_priv(cmd);\n\tint status;\n\n\tsp->cmd = cmd;\n\tsp->flags = 0;\n\tsp->wait = NULL;\n\tCMD_HANDLE(cmd) = (unsigned char *)NULL;\n\n\tqla1280_print_scsi_cmd(5, cmd);\n\n#ifdef QLA_64BIT_PTR\n\t \n\tstatus = qla1280_64bit_start_scsi(ha, sp);\n#else\n\tstatus = qla1280_32bit_start_scsi(ha, sp);\n#endif\n\treturn status;\n}\n\nstatic DEF_SCSI_QCMD(qla1280_queuecommand)\n\nenum action {\n\tABORT_COMMAND,\n\tDEVICE_RESET,\n\tBUS_RESET,\n\tADAPTER_RESET,\n};\n\n\nstatic void qla1280_mailbox_timeout(struct timer_list *t)\n{\n\tstruct scsi_qla_host *ha = from_timer(ha, t, mailbox_timer);\n\tstruct device_reg __iomem *reg;\n\treg = ha->iobase;\n\n\tha->mailbox_out[0] = RD_REG_WORD(&reg->mailbox0);\n\tprintk(KERN_ERR \"scsi(%ld): mailbox timed out, mailbox0 %04x, \"\n\t       \"ictrl %04x, istatus %04x\\n\", ha->host_no, ha->mailbox_out[0],\n\t       RD_REG_WORD(&reg->ictrl), RD_REG_WORD(&reg->istatus));\n\tcomplete(ha->mailbox_wait);\n}\n\nstatic int\n_qla1280_wait_for_single_command(struct scsi_qla_host *ha, struct srb *sp,\n\t\t\t\t struct completion *wait)\n{\n\tint\tstatus = FAILED;\n\tstruct scsi_cmnd *cmd = sp->cmd;\n\n\tspin_unlock_irq(ha->host->host_lock);\n\twait_for_completion_timeout(wait, 4*HZ);\n\tspin_lock_irq(ha->host->host_lock);\n\tsp->wait = NULL;\n\tif(CMD_HANDLE(cmd) == COMPLETED_HANDLE) {\n\t\tstatus = SUCCESS;\n\t\tscsi_done(cmd);\n\t}\n\treturn status;\n}\n\nstatic int\nqla1280_wait_for_single_command(struct scsi_qla_host *ha, struct srb *sp)\n{\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\n\tsp->wait = &wait;\n\treturn _qla1280_wait_for_single_command(ha, sp, &wait);\n}\n\nstatic int\nqla1280_wait_for_pending_commands(struct scsi_qla_host *ha, int bus, int target)\n{\n\tint\t\tcnt;\n\tint\t\tstatus;\n\tstruct srb\t*sp;\n\tstruct scsi_cmnd *cmd;\n\n\tstatus = SUCCESS;\n\n\t \n\tfor (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS; cnt++) {\n\t\tsp = ha->outstanding_cmds[cnt];\n\t\tif (sp) {\n\t\t\tcmd = sp->cmd;\n\n\t\t\tif (bus >= 0 && SCSI_BUS_32(cmd) != bus)\n\t\t\t\tcontinue;\n\t\t\tif (target >= 0 && SCSI_TCN_32(cmd) != target)\n\t\t\t\tcontinue;\n\n\t\t\tstatus = qla1280_wait_for_single_command(ha, sp);\n\t\t\tif (status == FAILED)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn status;\n}\n\n \nstatic int\nqla1280_error_action(struct scsi_cmnd *cmd, enum action action)\n{\n\tstruct scsi_qla_host *ha;\n\tint bus, target, lun;\n\tstruct srb *sp;\n\tint i, found;\n\tint result=FAILED;\n\tint wait_for_bus=-1;\n\tint wait_for_target = -1;\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\n\tENTER(\"qla1280_error_action\");\n\n\tha = (struct scsi_qla_host *)(CMD_HOST(cmd)->hostdata);\n\tsp = scsi_cmd_priv(cmd);\n\tbus = SCSI_BUS_32(cmd);\n\ttarget = SCSI_TCN_32(cmd);\n\tlun = SCSI_LUN_32(cmd);\n\n\tdprintk(4, \"error_action %i, istatus 0x%04x\\n\", action,\n\t\tRD_REG_WORD(&ha->iobase->istatus));\n\n\tdprintk(4, \"host_cmd 0x%04x, ictrl 0x%04x, jiffies %li\\n\",\n\t\tRD_REG_WORD(&ha->iobase->host_cmd),\n\t\tRD_REG_WORD(&ha->iobase->ictrl), jiffies);\n\n\tif (qla1280_verbose)\n\t\tprintk(KERN_INFO \"scsi(%li): Resetting Cmnd=0x%p, \"\n\t\t       \"Handle=0x%p, action=0x%x\\n\",\n\t\t       ha->host_no, cmd, CMD_HANDLE(cmd), action);\n\n\t \n\tfound = -1;\n\tfor (i = 0; i < MAX_OUTSTANDING_COMMANDS; i++) {\n\t\tif (sp == ha->outstanding_cmds[i]) {\n\t\t\tfound = i;\n\t\t\tsp->wait = &wait;  \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found < 0) {\t \n\t\tresult = SUCCESS;\n\t\tif (qla1280_verbose) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"scsi(%ld:%d:%d:%d): specified command has \"\n\t\t\t       \"already completed.\\n\", ha->host_no, bus,\n\t\t\t\ttarget, lun);\n\t\t}\n\t}\n\n\tswitch (action) {\n\n\tcase ABORT_COMMAND:\n\t\tdprintk(1, \"qla1280: RISC aborting command\\n\");\n\t\t \n\t\tif (found >= 0)\n\t\t\tqla1280_abort_command(ha, sp, found);\n\t\tbreak;\n\n\tcase DEVICE_RESET:\n\t\tif (qla1280_verbose)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"scsi(%ld:%d:%d:%d): Queueing device reset \"\n\t\t\t       \"command.\\n\", ha->host_no, bus, target, lun);\n\t\tif (qla1280_device_reset(ha, bus, target) == 0) {\n\t\t\t \n\t\t\twait_for_bus = bus;\n\t\t\twait_for_target = target;\n\t\t}\n\t\tbreak;\n\n\tcase BUS_RESET:\n\t\tif (qla1280_verbose)\n\t\t\tprintk(KERN_INFO \"qla1280(%ld:%d): Issued bus \"\n\t\t\t       \"reset.\\n\", ha->host_no, bus);\n\t\tif (qla1280_bus_reset(ha, bus) == 0) {\n\t\t\t \n\t\t\twait_for_bus = bus;\n\t\t}\n\t\tbreak;\n\n\tcase ADAPTER_RESET:\n\tdefault:\n\t\tif (qla1280_verbose) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"scsi(%ld): Issued ADAPTER RESET\\n\",\n\t\t\t       ha->host_no);\n\t\t\tprintk(KERN_INFO \"scsi(%ld): I/O processing will \"\n\t\t\t       \"continue automatically\\n\", ha->host_no);\n\t\t}\n\t\tha->flags.reset_active = 1;\n\n\t\tif (qla1280_abort_isp(ha) != 0) {\t \n\t\t\tresult = FAILED;\n\t\t}\n\n\t\tha->flags.reset_active = 0;\n\t}\n\n\t \n\n\tif (found >= 0)\n\t\tresult = _qla1280_wait_for_single_command(ha, sp, &wait);\n\n\tif (action == ABORT_COMMAND && result != SUCCESS) {\n\t\tprintk(KERN_WARNING\n\t\t       \"scsi(%li:%i:%i:%i): \"\n\t\t       \"Unable to abort command!\\n\",\n\t\t       ha->host_no, bus, target, lun);\n\t}\n\n\t \n\tif (result == SUCCESS && wait_for_bus >= 0) {\n\t\tresult = qla1280_wait_for_pending_commands(ha,\n\t\t\t\t\twait_for_bus, wait_for_target);\n\t}\n\n\tdprintk(1, \"RESET returning %d\\n\", result);\n\n\tLEAVE(\"qla1280_error_action\");\n\treturn result;\n}\n\n \nstatic int\nqla1280_eh_abort(struct scsi_cmnd * cmd)\n{\n\tint rc;\n\n\tspin_lock_irq(cmd->device->host->host_lock);\n\trc = qla1280_error_action(cmd, ABORT_COMMAND);\n\tspin_unlock_irq(cmd->device->host->host_lock);\n\n\treturn rc;\n}\n\n \nstatic int\nqla1280_eh_device_reset(struct scsi_cmnd *cmd)\n{\n\tint rc;\n\n\tspin_lock_irq(cmd->device->host->host_lock);\n\trc = qla1280_error_action(cmd, DEVICE_RESET);\n\tspin_unlock_irq(cmd->device->host->host_lock);\n\n\treturn rc;\n}\n\n \nstatic int\nqla1280_eh_bus_reset(struct scsi_cmnd *cmd)\n{\n\tint rc;\n\n\tspin_lock_irq(cmd->device->host->host_lock);\n\trc = qla1280_error_action(cmd, BUS_RESET);\n\tspin_unlock_irq(cmd->device->host->host_lock);\n\n\treturn rc;\n}\n\n \nstatic int\nqla1280_eh_adapter_reset(struct scsi_cmnd *cmd)\n{\n\tint rc;\n\n\tspin_lock_irq(cmd->device->host->host_lock);\n\trc = qla1280_error_action(cmd, ADAPTER_RESET);\n\tspin_unlock_irq(cmd->device->host->host_lock);\n\n\treturn rc;\n}\n\nstatic int\nqla1280_biosparam(struct scsi_device *sdev, struct block_device *bdev,\n\t\t  sector_t capacity, int geom[])\n{\n\tint heads, sectors, cylinders;\n\n\theads = 64;\n\tsectors = 32;\n\tcylinders = (unsigned long)capacity / (heads * sectors);\n\tif (cylinders > 1024) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\tcylinders = (unsigned long)capacity / (heads * sectors);\n\t\t \n\t}\n\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\n\treturn 0;\n}\n\n \n \nstatic inline void\nqla1280_disable_intrs(struct scsi_qla_host *ha)\n{\n\tWRT_REG_WORD(&ha->iobase->ictrl, 0);\n\tRD_REG_WORD(&ha->iobase->ictrl);\t \n}\n\n \nstatic inline void\nqla1280_enable_intrs(struct scsi_qla_host *ha)\n{\n\tWRT_REG_WORD(&ha->iobase->ictrl, (ISP_EN_INT | ISP_EN_RISC));\n\tRD_REG_WORD(&ha->iobase->ictrl);\t \n}\n\n \nstatic irqreturn_t\nqla1280_intr_handler(int irq, void *dev_id)\n{\n\tstruct scsi_qla_host *ha;\n\tstruct device_reg __iomem *reg;\n\tu16 data;\n\tint handled = 0;\n\n\tENTER_INTR (\"qla1280_intr_handler\");\n\tha = (struct scsi_qla_host *)dev_id;\n\n\tspin_lock(ha->host->host_lock);\n\n\tha->isr_count++;\n\treg = ha->iobase;\n\n\tqla1280_disable_intrs(ha);\n\n\tdata = qla1280_debounce_register(&reg->istatus);\n\t \n\tif (data & RISC_INT) {\t\n\t\tqla1280_isr(ha, &ha->done_q);\n\t\thandled = 1;\n\t}\n\tif (!list_empty(&ha->done_q))\n\t\tqla1280_done(ha);\n\n\tspin_unlock(ha->host->host_lock);\n\n\tqla1280_enable_intrs(ha);\n\n\tLEAVE_INTR(\"qla1280_intr_handler\");\n\treturn IRQ_RETVAL(handled);\n}\n\n\nstatic int\nqla1280_set_target_parameters(struct scsi_qla_host *ha, int bus, int target)\n{\n\tuint8_t mr;\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tstruct nvram *nv;\n\tint status, lun;\n\n\tnv = &ha->nvram;\n\n\tmr = BIT_3 | BIT_2 | BIT_1 | BIT_0;\n\n\t \n\tmb[0] = MBC_SET_TARGET_PARAMETERS;\n\tmb[1] = (uint16_t)((bus ? target | BIT_7 : target) << 8);\n\tmb[2] = nv->bus[bus].target[target].parameter.renegotiate_on_error << 8;\n\tmb[2] |= nv->bus[bus].target[target].parameter.stop_queue_on_check << 9;\n\tmb[2] |= nv->bus[bus].target[target].parameter.auto_request_sense << 10;\n\tmb[2] |= nv->bus[bus].target[target].parameter.tag_queuing << 11;\n\tmb[2] |= nv->bus[bus].target[target].parameter.enable_sync << 12;\n\tmb[2] |= nv->bus[bus].target[target].parameter.enable_wide << 13;\n\tmb[2] |= nv->bus[bus].target[target].parameter.parity_checking << 14;\n\tmb[2] |= nv->bus[bus].target[target].parameter.disconnect_allowed << 15;\n\n\tif (IS_ISP1x160(ha)) {\n\t\tmb[2] |= nv->bus[bus].target[target].ppr_1x160.flags.enable_ppr << 5;\n\t\tmb[3] =\t(nv->bus[bus].target[target].flags.flags1x160.sync_offset << 8);\n\t\tmb[6] =\t(nv->bus[bus].target[target].ppr_1x160.flags.ppr_options << 8) |\n\t\t\t nv->bus[bus].target[target].ppr_1x160.flags.ppr_bus_width;\n\t\tmr |= BIT_6;\n\t} else {\n\t\tmb[3] =\t(nv->bus[bus].target[target].flags.flags1x80.sync_offset << 8);\n\t}\n\tmb[3] |= nv->bus[bus].target[target].sync_period;\n\n\tstatus = qla1280_mailbox_command(ha, mr, mb);\n\n\t \n\tfor (lun = 0; lun < MAX_LUNS; lun++) {\n\t\tmb[0] = MBC_SET_DEVICE_QUEUE;\n\t\tmb[1] = (uint16_t)((bus ? target | BIT_7 : target) << 8);\n\t\tmb[1] |= lun;\n\t\tmb[2] = nv->bus[bus].max_queue_depth;\n\t\tmb[3] = nv->bus[bus].target[target].execution_throttle;\n\t\tstatus |= qla1280_mailbox_command(ha, 0x0f, mb);\n\t}\n\n\tif (status)\n\t\tprintk(KERN_WARNING \"scsi(%ld:%i:%i): \"\n\t\t       \"qla1280_set_target_parameters() failed\\n\",\n\t\t       ha->host_no, bus, target);\n\treturn status;\n}\n\n\n \nstatic int\nqla1280_slave_configure(struct scsi_device *device)\n{\n\tstruct scsi_qla_host *ha;\n\tint default_depth = 3;\n\tint bus = device->channel;\n\tint target = device->id;\n\tint status = 0;\n\tstruct nvram *nv;\n\tunsigned long flags;\n\n\tha = (struct scsi_qla_host *)device->host->hostdata;\n\tnv = &ha->nvram;\n\n\tif (qla1280_check_for_dead_scsi_bus(ha, bus))\n\t\treturn 1;\n\n\tif (device->tagged_supported &&\n\t    (ha->bus_settings[bus].qtag_enables & (BIT_0 << target))) {\n\t\tscsi_change_queue_depth(device, ha->bus_settings[bus].hiwat);\n\t} else {\n\t\tscsi_change_queue_depth(device, default_depth);\n\t}\n\n\tnv->bus[bus].target[target].parameter.enable_sync = device->sdtr;\n\tnv->bus[bus].target[target].parameter.enable_wide = device->wdtr;\n\tnv->bus[bus].target[target].ppr_1x160.flags.enable_ppr = device->ppr;\n\n\tif (driver_setup.no_sync ||\n\t    (driver_setup.sync_mask &&\n\t     (~driver_setup.sync_mask & (1 << target))))\n\t\tnv->bus[bus].target[target].parameter.enable_sync = 0;\n\tif (driver_setup.no_wide ||\n\t    (driver_setup.wide_mask &&\n\t     (~driver_setup.wide_mask & (1 << target))))\n\t\tnv->bus[bus].target[target].parameter.enable_wide = 0;\n\tif (IS_ISP1x160(ha)) {\n\t\tif (driver_setup.no_ppr ||\n\t\t    (driver_setup.ppr_mask &&\n\t\t     (~driver_setup.ppr_mask & (1 << target))))\n\t\t\tnv->bus[bus].target[target].ppr_1x160.flags.enable_ppr = 0;\n\t}\n\n\tspin_lock_irqsave(ha->host->host_lock, flags);\n\tif (nv->bus[bus].target[target].parameter.enable_sync)\n\t\tstatus = qla1280_set_target_parameters(ha, bus, target);\n\tqla1280_get_target_parameters(ha, device);\n\tspin_unlock_irqrestore(ha->host->host_lock, flags);\n\treturn status;\n}\n\n\n \nstatic void\nqla1280_done(struct scsi_qla_host *ha)\n{\n\tstruct srb *sp;\n\tstruct list_head *done_q;\n\tint bus, target;\n\tstruct scsi_cmnd *cmd;\n\n\tENTER(\"qla1280_done\");\n\n\tdone_q = &ha->done_q;\n\n\twhile (!list_empty(done_q)) {\n\t\tsp = list_entry(done_q->next, struct srb, list);\n\n\t\tlist_del(&sp->list);\n\t\n\t\tcmd = sp->cmd;\n\t\tbus = SCSI_BUS_32(cmd);\n\t\ttarget = SCSI_TCN_32(cmd);\n\n\t\tswitch ((CMD_RESULT(cmd) >> 16)) {\n\t\tcase DID_RESET:\n\t\t\t \n\t\t\tif (!ha->flags.abort_isp_active)\n\t\t\t\tqla1280_marker(ha, bus, target, 0, MK_SYNC_ID);\n\t\t\tbreak;\n\t\tcase DID_ABORT:\n\t\t\tsp->flags &= ~SRB_ABORT_PENDING;\n\t\t\tsp->flags |= SRB_ABORTED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tscsi_dma_unmap(cmd);\n\n\t\t \n\t\tha->actthreads--;\n\n\t\tif (sp->wait == NULL)\n\t\t\tscsi_done(cmd);\n\t\telse\n\t\t\tcomplete(sp->wait);\n\t}\n\tLEAVE(\"qla1280_done\");\n}\n\n \nstatic int\nqla1280_return_status(struct response * sts, struct scsi_cmnd *cp)\n{\n\tint host_status = DID_ERROR;\n\tuint16_t comp_status = le16_to_cpu(sts->comp_status);\n\tuint16_t state_flags = le16_to_cpu(sts->state_flags);\n\tuint32_t residual_length = le32_to_cpu(sts->residual_length);\n\tuint16_t scsi_status = le16_to_cpu(sts->scsi_status);\n#if DEBUG_QLA1280_INTR\n\tstatic char *reason[] = {\n\t\t\"DID_OK\",\n\t\t\"DID_NO_CONNECT\",\n\t\t\"DID_BUS_BUSY\",\n\t\t\"DID_TIME_OUT\",\n\t\t\"DID_BAD_TARGET\",\n\t\t\"DID_ABORT\",\n\t\t\"DID_PARITY\",\n\t\t\"DID_ERROR\",\n\t\t\"DID_RESET\",\n\t\t\"DID_BAD_INTR\"\n\t};\n#endif\t\t\t\t \n\n\tENTER(\"qla1280_return_status\");\n\n#if DEBUG_QLA1280_INTR\n\t \n#endif\n\n\tswitch (comp_status) {\n\tcase CS_COMPLETE:\n\t\thost_status = DID_OK;\n\t\tbreak;\n\n\tcase CS_INCOMPLETE:\n\t\tif (!(state_flags & SF_GOT_BUS))\n\t\t\thost_status = DID_NO_CONNECT;\n\t\telse if (!(state_flags & SF_GOT_TARGET))\n\t\t\thost_status = DID_BAD_TARGET;\n\t\telse if (!(state_flags & SF_SENT_CDB))\n\t\t\thost_status = DID_ERROR;\n\t\telse if (!(state_flags & SF_TRANSFERRED_DATA))\n\t\t\thost_status = DID_ERROR;\n\t\telse if (!(state_flags & SF_GOT_STATUS))\n\t\t\thost_status = DID_ERROR;\n\t\telse if (!(state_flags & SF_GOT_SENSE))\n\t\t\thost_status = DID_ERROR;\n\t\tbreak;\n\n\tcase CS_RESET:\n\t\thost_status = DID_RESET;\n\t\tbreak;\n\n\tcase CS_ABORTED:\n\t\thost_status = DID_ABORT;\n\t\tbreak;\n\n\tcase CS_TIMEOUT:\n\t\thost_status = DID_TIME_OUT;\n\t\tbreak;\n\n\tcase CS_DATA_OVERRUN:\n\t\tdprintk(2, \"Data overrun 0x%x\\n\", residual_length);\n\t\tdprintk(2, \"qla1280_return_status: response packet data\\n\");\n\t\tqla1280_dump_buffer(2, (char *)sts, RESPONSE_ENTRY_SIZE);\n\t\thost_status = DID_ERROR;\n\t\tbreak;\n\n\tcase CS_DATA_UNDERRUN:\n\t\tif ((scsi_bufflen(cp) - residual_length) <\n\t\t    cp->underflow) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"scsi: Underflow detected - retrying \"\n\t\t\t       \"command.\\n\");\n\t\t\thost_status = DID_ERROR;\n\t\t} else {\n\t\t\tscsi_set_resid(cp, residual_length);\n\t\t\thost_status = DID_OK;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\thost_status = DID_ERROR;\n\t\tbreak;\n\t}\n\n#if DEBUG_QLA1280_INTR\n\tdprintk(1, \"qla1280 ISP status: host status (%s) scsi status %x\\n\",\n\t\treason[host_status], scsi_status);\n#endif\n\n\tLEAVE(\"qla1280_return_status\");\n\n\treturn (scsi_status & 0xff) | (host_status << 16);\n}\n\n \n \n \n\n \nstatic int\nqla1280_initialize_adapter(struct scsi_qla_host *ha)\n{\n\tstruct device_reg __iomem *reg;\n\tint status;\n\tint bus;\n\tunsigned long flags;\n\n\tENTER(\"qla1280_initialize_adapter\");\n\n\t \n\tha->flags.online = 0;\n\tha->flags.disable_host_adapter = 0;\n\tha->flags.reset_active = 0;\n\tha->flags.abort_isp_active = 0;\n\n\t \n\tif (IS_ISP1040(ha))\n\t\tdriver_setup.no_nvram = 1;\n\n\tdprintk(1, \"Configure PCI space for adapter...\\n\");\n\n\treg = ha->iobase;\n\n\t \n\tWRT_REG_WORD(&reg->semaphore, 0);\n\tWRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);\n\tWRT_REG_WORD(&reg->host_cmd, HC_CLR_HOST_INT);\n\tRD_REG_WORD(&reg->host_cmd);\n\n\tif (qla1280_read_nvram(ha)) {\n\t\tdprintk(2, \"qla1280_initialize_adapter: failed to read \"\n\t\t\t\"NVRAM\\n\");\n\t}\n\n\t \n\tspin_lock_irqsave(ha->host->host_lock, flags);\n\n\tstatus = qla1280_load_firmware(ha);\n\tif (status) {\n\t\tprintk(KERN_ERR \"scsi(%li): initialize: pci probe failed!\\n\",\n\t\t       ha->host_no);\n\t\tgoto out;\n\t}\n\n\t \n\tdprintk(1, \"scsi(%ld): Configure NVRAM parameters\\n\", ha->host_no);\n\tqla1280_nvram_config(ha);\n\n\tif (ha->flags.disable_host_adapter) {\n\t\tstatus = 1;\n\t\tgoto out;\n\t}\n\n\tstatus = qla1280_init_rings(ha);\n\tif (status)\n\t\tgoto out;\n\n\t \n\tfor (bus = 0; bus < ha->ports; bus++) {\n\t\tif (!ha->bus_settings[bus].disable_scsi_reset &&\n\t\t    qla1280_bus_reset(ha, bus) &&\n\t\t    qla1280_bus_reset(ha, bus))\n\t\t\tha->bus_settings[bus].scsi_bus_dead = 1;\n\t}\n\n\tha->flags.online = 1;\n out:\n\tspin_unlock_irqrestore(ha->host->host_lock, flags);\n\n\tif (status)\n\t\tdprintk(2, \"qla1280_initialize_adapter: **** FAILED ****\\n\");\n\n\tLEAVE(\"qla1280_initialize_adapter\");\n\treturn status;\n}\n\n \nstatic const struct firmware *\nqla1280_request_firmware(struct scsi_qla_host *ha)\n{\n\tconst struct firmware *fw;\n\tint err;\n\tint index;\n\tchar *fwname;\n\n\tspin_unlock_irq(ha->host->host_lock);\n\tmutex_lock(&qla1280_firmware_mutex);\n\n\tindex = ql1280_board_tbl[ha->devnum].fw_index;\n\tfw = qla1280_fw_tbl[index].fw;\n\tif (fw)\n\t\tgoto out;\n\n\tfwname = qla1280_fw_tbl[index].fwname;\n\terr = request_firmware(&fw, fwname, &ha->pdev->dev);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"Failed to load image \\\"%s\\\" err %d\\n\",\n\t\t       fwname, err);\n\t\tfw = ERR_PTR(err);\n\t\tgoto unlock;\n\t}\n\tif ((fw->size % 2) || (fw->size < 6)) {\n\t\tprintk(KERN_ERR \"Invalid firmware length %zu in image \\\"%s\\\"\\n\",\n\t\t       fw->size, fwname);\n\t\trelease_firmware(fw);\n\t\tfw = ERR_PTR(-EINVAL);\n\t\tgoto unlock;\n\t}\n\n\tqla1280_fw_tbl[index].fw = fw;\n\n out:\n\tha->fwver1 = fw->data[0];\n\tha->fwver2 = fw->data[1];\n\tha->fwver3 = fw->data[2];\n unlock:\n\tmutex_unlock(&qla1280_firmware_mutex);\n\tspin_lock_irq(ha->host->host_lock);\n\treturn fw;\n}\n\n \nstatic int\nqla1280_chip_diag(struct scsi_qla_host *ha)\n{\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tstruct device_reg __iomem *reg = ha->iobase;\n\tint status = 0;\n\tint cnt;\n\tuint16_t data;\n\tdprintk(3, \"qla1280_chip_diag: testing device at 0x%p \\n\", &reg->id_l);\n\n\tdprintk(1, \"scsi(%ld): Verifying chip\\n\", ha->host_no);\n\n\t \n\tWRT_REG_WORD(&reg->ictrl, ISP_RESET);\n\n\t \n\tudelay(20);\n\tdata = qla1280_debounce_register(&reg->ictrl);\n\t \n\tfor (cnt = 1000000; cnt && data & ISP_RESET; cnt--) {\n\t\tudelay(5);\n\t\tdata = RD_REG_WORD(&reg->ictrl);\n\t}\n\n\tif (!cnt)\n\t\tgoto fail;\n\n\t \n\tdprintk(3, \"qla1280_chip_diag: reset register cleared by chip reset\\n\");\n\n\tWRT_REG_WORD(&reg->cfg_1, 0);\n\n\t \n\tWRT_REG_WORD(&reg->host_cmd, HC_RESET_RISC |\n\t\t     HC_RELEASE_RISC | HC_DISABLE_BIOS);\n\n\tRD_REG_WORD(&reg->id_l);\t \n\tdata = qla1280_debounce_register(&reg->mailbox0);\n\n\t \n\tfor (cnt = 1000000; cnt && data == MBS_BUSY; cnt--) {\n\t\tudelay(5);\n\t\tdata = RD_REG_WORD(&reg->mailbox0);\n\t}\n\n\tif (!cnt)\n\t\tgoto fail;\n\n\t \n\tdprintk(3, \"qla1280_chip_diag: Checking product ID of chip\\n\");\n\n\tif (RD_REG_WORD(&reg->mailbox1) != PROD_ID_1 ||\n\t    (RD_REG_WORD(&reg->mailbox2) != PROD_ID_2 &&\n\t     RD_REG_WORD(&reg->mailbox2) != PROD_ID_2a) ||\n\t    RD_REG_WORD(&reg->mailbox3) != PROD_ID_3 ||\n\t    RD_REG_WORD(&reg->mailbox4) != PROD_ID_4) {\n\t\tprintk(KERN_INFO \"qla1280: Wrong product ID = \"\n\t\t       \"0x%x,0x%x,0x%x,0x%x\\n\",\n\t\t       RD_REG_WORD(&reg->mailbox1),\n\t\t       RD_REG_WORD(&reg->mailbox2),\n\t\t       RD_REG_WORD(&reg->mailbox3),\n\t\t       RD_REG_WORD(&reg->mailbox4));\n\t\tgoto fail;\n\t}\n\n\t \n\tqla1280_enable_intrs(ha);\n\n\tdprintk(1, \"qla1280_chip_diag: Checking mailboxes of chip\\n\");\n\t \n\tmb[0] = MBC_MAILBOX_REGISTER_TEST;\n\tmb[1] = 0xAAAA;\n\tmb[2] = 0x5555;\n\tmb[3] = 0xAA55;\n\tmb[4] = 0x55AA;\n\tmb[5] = 0xA5A5;\n\tmb[6] = 0x5A5A;\n\tmb[7] = 0x2525;\n\n\tstatus = qla1280_mailbox_command(ha, 0xff, mb);\n\tif (status)\n\t\tgoto fail;\n\n\tif (mb[1] != 0xAAAA || mb[2] != 0x5555 || mb[3] != 0xAA55 ||\n\t    mb[4] != 0x55AA || mb[5] != 0xA5A5 || mb[6] != 0x5A5A ||\n\t    mb[7] != 0x2525) {\n\t\tprintk(KERN_INFO \"qla1280: Failed mbox check\\n\");\n\t\tgoto fail;\n\t}\n\n\tdprintk(3, \"qla1280_chip_diag: exiting normally\\n\");\n\treturn 0;\n fail:\n\tdprintk(2, \"qla1280_chip_diag: **** FAILED ****\\n\");\n\treturn status;\n}\n\nstatic int\nqla1280_load_firmware_pio(struct scsi_qla_host *ha)\n{\n\t \n\n\tconst struct firmware *fw;\n\tconst __le16 *fw_data;\n\tuint16_t risc_address, risc_code_size;\n\tuint16_t mb[MAILBOX_REGISTER_COUNT], i;\n\tint err = 0;\n\n\tfw = qla1280_request_firmware(ha);\n\tif (IS_ERR(fw))\n\t\treturn PTR_ERR(fw);\n\n\tfw_data = (const __le16 *)&fw->data[0];\n\tha->fwstart = __le16_to_cpu(fw_data[2]);\n\n\t \n\trisc_address = ha->fwstart;\n\tfw_data = (const __le16 *)&fw->data[6];\n\trisc_code_size = (fw->size - 6) / 2;\n\n\tfor (i = 0; i < risc_code_size; i++) {\n\t\tmb[0] = MBC_WRITE_RAM_WORD;\n\t\tmb[1] = risc_address + i;\n\t\tmb[2] = __le16_to_cpu(fw_data[i]);\n\n\t\terr = qla1280_mailbox_command(ha, BIT_0 | BIT_1 | BIT_2, mb);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"scsi(%li): Failed to load firmware\\n\",\n\t\t\t\t\tha->host_no);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n#ifdef QLA_64BIT_PTR\n#define LOAD_CMD\tMBC_LOAD_RAM_A64_ROM\n#define DUMP_CMD\tMBC_DUMP_RAM_A64_ROM\n#define CMD_ARGS\t(BIT_7 | BIT_6 | BIT_4 | BIT_3 | BIT_2 | BIT_1 | BIT_0)\n#else\n#define LOAD_CMD\tMBC_LOAD_RAM\n#define DUMP_CMD\tMBC_DUMP_RAM\n#define CMD_ARGS\t(BIT_4 | BIT_3 | BIT_2 | BIT_1 | BIT_0)\n#endif\n\n#define DUMP_IT_BACK 0\t\t \nstatic int\nqla1280_load_firmware_dma(struct scsi_qla_host *ha)\n{\n\t \n\tconst struct firmware *fw;\n\tconst __le16 *fw_data;\n\tuint16_t risc_address, risc_code_size;\n\tuint16_t mb[MAILBOX_REGISTER_COUNT], cnt;\n\tint err = 0, num, i;\n#if DUMP_IT_BACK\n\tuint8_t *sp, *tbuf;\n\tdma_addr_t p_tbuf;\n\n\ttbuf = dma_alloc_coherent(&ha->pdev->dev, 8000, &p_tbuf, GFP_KERNEL);\n\tif (!tbuf)\n\t\treturn -ENOMEM;\n#endif\n\n\tfw = qla1280_request_firmware(ha);\n\tif (IS_ERR(fw))\n\t\treturn PTR_ERR(fw);\n\n\tfw_data = (const __le16 *)&fw->data[0];\n\tha->fwstart = __le16_to_cpu(fw_data[2]);\n\n\t \n\trisc_address = ha->fwstart;\n\tfw_data = (const __le16 *)&fw->data[6];\n\trisc_code_size = (fw->size - 6) / 2;\n\n\tdprintk(1, \"%s: DMA RISC code (%i) words\\n\",\n\t\t\t__func__, risc_code_size);\n\n\tnum = 0;\n\twhile (risc_code_size > 0) {\n\t\tint warn __attribute__((unused)) = 0;\n\n\t\tcnt = 2000 >> 1;\n\n\t\tif (cnt > risc_code_size)\n\t\t\tcnt = risc_code_size;\n\n\t\tdprintk(2, \"qla1280_setup_chip:  loading risc @ =(0x%p),\"\n\t\t\t\"%d,%d(0x%x)\\n\",\n\t\t\tfw_data, cnt, num, risc_address);\n\t\tfor(i = 0; i < cnt; i++)\n\t\t\t((__le16 *)ha->request_ring)[i] = fw_data[i];\n\n\t\tmb[0] = LOAD_CMD;\n\t\tmb[1] = risc_address;\n\t\tmb[4] = cnt;\n\t\tmb[3] = ha->request_dma & 0xffff;\n\t\tmb[2] = (ha->request_dma >> 16) & 0xffff;\n\t\tmb[7] = upper_32_bits(ha->request_dma) & 0xffff;\n\t\tmb[6] = upper_32_bits(ha->request_dma) >> 16;\n\t\tdprintk(2, \"%s: op=%d  0x%p = 0x%4x,0x%4x,0x%4x,0x%4x\\n\",\n\t\t\t\t__func__, mb[0],\n\t\t\t\t(void *)(long)ha->request_dma,\n\t\t\t\tmb[6], mb[7], mb[2], mb[3]);\n\t\terr = qla1280_mailbox_command(ha, CMD_ARGS, mb);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"scsi(%li): Failed to load partial \"\n\t\t\t       \"segment of f\\n\", ha->host_no);\n\t\t\tgoto out;\n\t\t}\n\n#if DUMP_IT_BACK\n\t\tmb[0] = DUMP_CMD;\n\t\tmb[1] = risc_address;\n\t\tmb[4] = cnt;\n\t\tmb[3] = p_tbuf & 0xffff;\n\t\tmb[2] = (p_tbuf >> 16) & 0xffff;\n\t\tmb[7] = upper_32_bits(p_tbuf) & 0xffff;\n\t\tmb[6] = upper_32_bits(p_tbuf) >> 16;\n\n\t\terr = qla1280_mailbox_command(ha, CMD_ARGS, mb);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Failed to dump partial segment of f/w\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tsp = (uint8_t *)ha->request_ring;\n\t\tfor (i = 0; i < (cnt << 1); i++) {\n\t\t\tif (tbuf[i] != sp[i] && warn++ < 10) {\n\t\t\t\tprintk(KERN_ERR \"%s: FW compare error @ \"\n\t\t\t\t\t\t\"byte(0x%x) loop#=%x\\n\",\n\t\t\t\t\t\t__func__, i, num);\n\t\t\t\tprintk(KERN_ERR \"%s: FWbyte=%x  \"\n\t\t\t\t\t\t\"FWfromChip=%x\\n\",\n\t\t\t\t\t\t__func__, sp[i], tbuf[i]);\n\t\t\t\t \n\t\t\t}\n\t\t}\n#endif\n\t\trisc_address += cnt;\n\t\trisc_code_size = risc_code_size - cnt;\n\t\tfw_data = fw_data + cnt;\n\t\tnum++;\n\t}\n\n out:\n#if DUMP_IT_BACK\n\tdma_free_coherent(&ha->pdev->dev, 8000, tbuf, p_tbuf);\n#endif\n\treturn err;\n}\n\nstatic int\nqla1280_start_firmware(struct scsi_qla_host *ha)\n{\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tint err;\n\n\tdprintk(1, \"%s: Verifying checksum of loaded RISC code.\\n\",\n\t\t\t__func__);\n\n\t \n\tmb[0] = MBC_VERIFY_CHECKSUM;\n\t \n\tmb[1] = ha->fwstart;\n\terr = qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);\n\tif (err) {\n\t\tprintk(KERN_ERR \"scsi(%li): RISC checksum failed.\\n\", ha->host_no);\n\t\treturn err;\n\t}\n\n\t \n\tdprintk(1, \"%s: start firmware running.\\n\", __func__);\n\tmb[0] = MBC_EXECUTE_FIRMWARE;\n\tmb[1] = ha->fwstart;\n\terr = qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);\n\tif (err) {\n\t\tprintk(KERN_ERR \"scsi(%li): Failed to start firmware\\n\",\n\t\t\t\tha->host_no);\n\t}\n\n\treturn err;\n}\n\nstatic int\nqla1280_load_firmware(struct scsi_qla_host *ha)\n{\n\t \n\tint err;\n\n\terr = qla1280_chip_diag(ha);\n\tif (err)\n\t\tgoto out;\n\tif (IS_ISP1040(ha))\n\t\terr = qla1280_load_firmware_pio(ha);\n\telse\n\t\terr = qla1280_load_firmware_dma(ha);\n\tif (err)\n\t\tgoto out;\n\terr = qla1280_start_firmware(ha);\n out:\n\treturn err;\n}\n\n \nstatic int\nqla1280_init_rings(struct scsi_qla_host *ha)\n{\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tint status = 0;\n\n\tENTER(\"qla1280_init_rings\");\n\n\t \n\tmemset(ha->outstanding_cmds, 0,\n\t       sizeof(struct srb *) * MAX_OUTSTANDING_COMMANDS);\n\n\t \n\tha->request_ring_ptr = ha->request_ring;\n\tha->req_ring_index = 0;\n\tha->req_q_cnt = REQUEST_ENTRY_CNT;\n\t \n\tmb[0] = MBC_INIT_REQUEST_QUEUE_A64;\n\tmb[1] = REQUEST_ENTRY_CNT;\n\tmb[3] = ha->request_dma & 0xffff;\n\tmb[2] = (ha->request_dma >> 16) & 0xffff;\n\tmb[4] = 0;\n\tmb[7] = upper_32_bits(ha->request_dma) & 0xffff;\n\tmb[6] = upper_32_bits(ha->request_dma) >> 16;\n\tif (!(status = qla1280_mailbox_command(ha, BIT_7 | BIT_6 | BIT_4 |\n\t\t\t\t\t       BIT_3 | BIT_2 | BIT_1 | BIT_0,\n\t\t\t\t\t       &mb[0]))) {\n\t\t \n\t\tha->response_ring_ptr = ha->response_ring;\n\t\tha->rsp_ring_index = 0;\n\t\t \n\t\tmb[0] = MBC_INIT_RESPONSE_QUEUE_A64;\n\t\tmb[1] = RESPONSE_ENTRY_CNT;\n\t\tmb[3] = ha->response_dma & 0xffff;\n\t\tmb[2] = (ha->response_dma >> 16) & 0xffff;\n\t\tmb[5] = 0;\n\t\tmb[7] = upper_32_bits(ha->response_dma) & 0xffff;\n\t\tmb[6] = upper_32_bits(ha->response_dma) >> 16;\n\t\tstatus = qla1280_mailbox_command(ha, BIT_7 | BIT_6 | BIT_5 |\n\t\t\t\t\t\t BIT_3 | BIT_2 | BIT_1 | BIT_0,\n\t\t\t\t\t\t &mb[0]);\n\t}\n\n\tif (status)\n\t\tdprintk(2, \"qla1280_init_rings: **** FAILED ****\\n\");\n\n\tLEAVE(\"qla1280_init_rings\");\n\treturn status;\n}\n\nstatic void\nqla1280_print_settings(struct nvram *nv)\n{\n\tdprintk(1, \"qla1280 : initiator scsi id bus[0]=%d\\n\",\n\t\tnv->bus[0].config_1.initiator_id);\n\tdprintk(1, \"qla1280 : initiator scsi id bus[1]=%d\\n\",\n\t\tnv->bus[1].config_1.initiator_id);\n\n\tdprintk(1, \"qla1280 : bus reset delay[0]=%d\\n\",\n\t\tnv->bus[0].bus_reset_delay);\n\tdprintk(1, \"qla1280 : bus reset delay[1]=%d\\n\",\n\t\tnv->bus[1].bus_reset_delay);\n\n\tdprintk(1, \"qla1280 : retry count[0]=%d\\n\", nv->bus[0].retry_count);\n\tdprintk(1, \"qla1280 : retry delay[0]=%d\\n\", nv->bus[0].retry_delay);\n\tdprintk(1, \"qla1280 : retry count[1]=%d\\n\", nv->bus[1].retry_count);\n\tdprintk(1, \"qla1280 : retry delay[1]=%d\\n\", nv->bus[1].retry_delay);\n\n\tdprintk(1, \"qla1280 : async data setup time[0]=%d\\n\",\n\t\tnv->bus[0].config_2.async_data_setup_time);\n\tdprintk(1, \"qla1280 : async data setup time[1]=%d\\n\",\n\t\tnv->bus[1].config_2.async_data_setup_time);\n\n\tdprintk(1, \"qla1280 : req/ack active negation[0]=%d\\n\",\n\t\tnv->bus[0].config_2.req_ack_active_negation);\n\tdprintk(1, \"qla1280 : req/ack active negation[1]=%d\\n\",\n\t\tnv->bus[1].config_2.req_ack_active_negation);\n\n\tdprintk(1, \"qla1280 : data line active negation[0]=%d\\n\",\n\t\tnv->bus[0].config_2.data_line_active_negation);\n\tdprintk(1, \"qla1280 : data line active negation[1]=%d\\n\",\n\t\tnv->bus[1].config_2.data_line_active_negation);\n\n\tdprintk(1, \"qla1280 : disable loading risc code=%d\\n\",\n\t\tnv->cntr_flags_1.disable_loading_risc_code);\n\n\tdprintk(1, \"qla1280 : enable 64bit addressing=%d\\n\",\n\t\tnv->cntr_flags_1.enable_64bit_addressing);\n\n\tdprintk(1, \"qla1280 : selection timeout limit[0]=%d\\n\",\n\t\tnv->bus[0].selection_timeout);\n\tdprintk(1, \"qla1280 : selection timeout limit[1]=%d\\n\",\n\t\tnv->bus[1].selection_timeout);\n\n\tdprintk(1, \"qla1280 : max queue depth[0]=%d\\n\",\n\t\tnv->bus[0].max_queue_depth);\n\tdprintk(1, \"qla1280 : max queue depth[1]=%d\\n\",\n\t\tnv->bus[1].max_queue_depth);\n}\n\nstatic void\nqla1280_set_target_defaults(struct scsi_qla_host *ha, int bus, int target)\n{\n\tstruct nvram *nv = &ha->nvram;\n\n\tnv->bus[bus].target[target].parameter.renegotiate_on_error = 1;\n\tnv->bus[bus].target[target].parameter.auto_request_sense = 1;\n\tnv->bus[bus].target[target].parameter.tag_queuing = 1;\n\tnv->bus[bus].target[target].parameter.enable_sync = 1;\n#if 1\t \n\tnv->bus[bus].target[target].parameter.enable_wide = 1;\n#endif\n\tnv->bus[bus].target[target].execution_throttle =\n\t\tnv->bus[bus].max_queue_depth - 1;\n\tnv->bus[bus].target[target].parameter.parity_checking = 1;\n\tnv->bus[bus].target[target].parameter.disconnect_allowed = 1;\n\n\tif (IS_ISP1x160(ha)) {\n\t\tnv->bus[bus].target[target].flags.flags1x160.device_enable = 1;\n\t\tnv->bus[bus].target[target].flags.flags1x160.sync_offset = 0x0e;\n\t\tnv->bus[bus].target[target].sync_period = 9;\n\t\tnv->bus[bus].target[target].ppr_1x160.flags.enable_ppr = 1;\n\t\tnv->bus[bus].target[target].ppr_1x160.flags.ppr_options = 2;\n\t\tnv->bus[bus].target[target].ppr_1x160.flags.ppr_bus_width = 1;\n\t} else {\n\t\tnv->bus[bus].target[target].flags.flags1x80.device_enable = 1;\n\t\tnv->bus[bus].target[target].flags.flags1x80.sync_offset = 12;\n\t\tnv->bus[bus].target[target].sync_period = 10;\n\t}\n}\n\nstatic void\nqla1280_set_defaults(struct scsi_qla_host *ha)\n{\n\tstruct nvram *nv = &ha->nvram;\n\tint bus, target;\n\n\tdprintk(1, \"Using defaults for NVRAM: \\n\");\n\tmemset(nv, 0, sizeof(struct nvram));\n\n\t \n\tnv->firmware_feature.f.enable_fast_posting = 1;\n\tnv->firmware_feature.f.disable_synchronous_backoff = 1;\n\tnv->termination.scsi_bus_0_control = 3;\n\tnv->termination.scsi_bus_1_control = 3;\n\tnv->termination.auto_term_support = 1;\n\n\t \n\tnv->isp_config.burst_enable = 1;\n\tif (IS_ISP1040(ha))\n\t\tnv->isp_config.fifo_threshold |= 3;\n\telse\n\t\tnv->isp_config.fifo_threshold |= 4;\n\n\tif (IS_ISP1x160(ha))\n\t\tnv->isp_parameter = 0x01;  \n\n\tfor (bus = 0; bus < MAX_BUSES; bus++) {\n\t\tnv->bus[bus].config_1.initiator_id = 7;\n\t\tnv->bus[bus].config_2.req_ack_active_negation = 1;\n\t\tnv->bus[bus].config_2.data_line_active_negation = 1;\n\t\tnv->bus[bus].selection_timeout = 250;\n\t\tnv->bus[bus].max_queue_depth = 32;\n\n\t\tif (IS_ISP1040(ha)) {\n\t\t\tnv->bus[bus].bus_reset_delay = 3;\n\t\t\tnv->bus[bus].config_2.async_data_setup_time = 6;\n\t\t\tnv->bus[bus].retry_delay = 1;\n\t\t} else {\n\t\t\tnv->bus[bus].bus_reset_delay = 5;\n\t\t\tnv->bus[bus].config_2.async_data_setup_time = 8;\n\t\t}\n\n\t\tfor (target = 0; target < MAX_TARGETS; target++)\n\t\t\tqla1280_set_target_defaults(ha, bus, target);\n\t}\n}\n\nstatic int\nqla1280_config_target(struct scsi_qla_host *ha, int bus, int target)\n{\n\tstruct nvram *nv = &ha->nvram;\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tint status, lun;\n\tuint16_t flag;\n\n\t \n\tmb[0] = MBC_SET_TARGET_PARAMETERS;\n\tmb[1] = (uint16_t)((bus ? target | BIT_7 : target) << 8);\n\n\t \n\tmb[2] = (TP_RENEGOTIATE | TP_AUTO_REQUEST_SENSE | TP_TAGGED_QUEUE\n\t\t | TP_WIDE | TP_PARITY | TP_DISCONNECT);\n\n\tif (IS_ISP1x160(ha))\n\t\tmb[3] =\tnv->bus[bus].target[target].flags.flags1x160.sync_offset << 8;\n\telse\n\t\tmb[3] =\tnv->bus[bus].target[target].flags.flags1x80.sync_offset << 8;\n\tmb[3] |= nv->bus[bus].target[target].sync_period;\n\tstatus = qla1280_mailbox_command(ha, 0x0f, mb);\n\n\t \n\tflag = (BIT_0 << target);\n\tif (nv->bus[bus].target[target].parameter.tag_queuing)\n\t\tha->bus_settings[bus].qtag_enables |= flag;\n\n\t \n\tif (IS_ISP1x160(ha)) {\n\t\tif (nv->bus[bus].target[target].flags.flags1x160.device_enable)\n\t\t\tha->bus_settings[bus].device_enables |= flag;\n\t\tha->bus_settings[bus].lun_disables |= 0;\n\t} else {\n\t\tif (nv->bus[bus].target[target].flags.flags1x80.device_enable)\n\t\t\tha->bus_settings[bus].device_enables |= flag;\n\t\t \n\t\tif (nv->bus[bus].target[target].flags.flags1x80.lun_disable)\n\t\t\tha->bus_settings[bus].lun_disables |= flag;\n\t}\n\n\t \n\tfor (lun = 0; lun < MAX_LUNS; lun++) {\n\t\tmb[0] = MBC_SET_DEVICE_QUEUE;\n\t\tmb[1] = (uint16_t)((bus ? target | BIT_7 : target) << 8);\n\t\tmb[1] |= lun;\n\t\tmb[2] = nv->bus[bus].max_queue_depth;\n\t\tmb[3] = nv->bus[bus].target[target].execution_throttle;\n\t\tstatus |= qla1280_mailbox_command(ha, 0x0f, mb);\n\t}\n\n\treturn status;\n}\n\nstatic int\nqla1280_config_bus(struct scsi_qla_host *ha, int bus)\n{\n\tstruct nvram *nv = &ha->nvram;\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tint target, status;\n\n\t \n\tha->bus_settings[bus].disable_scsi_reset =\n\t\tnv->bus[bus].config_1.scsi_reset_disable;\n\n\t \n\tha->bus_settings[bus].id = nv->bus[bus].config_1.initiator_id;\n\tmb[0] = MBC_SET_INITIATOR_ID;\n\tmb[1] = bus ? ha->bus_settings[bus].id | BIT_7 :\n\t\tha->bus_settings[bus].id;\n\tstatus = qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);\n\n\t \n\tha->bus_settings[bus].bus_reset_delay =\n\t\tnv->bus[bus].bus_reset_delay;\n\n\t \n\tha->bus_settings[bus].hiwat = nv->bus[bus].max_queue_depth - 1;\n\n\t \n\tfor (target = 0; target < MAX_TARGETS; target++)\n\t\tstatus |= qla1280_config_target(ha, bus, target);\n\n\treturn status;\n}\n\nstatic int\nqla1280_nvram_config(struct scsi_qla_host *ha)\n{\n\tstruct device_reg __iomem *reg = ha->iobase;\n\tstruct nvram *nv = &ha->nvram;\n\tint bus, target, status = 0;\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\n\tENTER(\"qla1280_nvram_config\");\n\n\tif (ha->nvram_valid) {\n\t\t \n\t\tfor (bus = 0; bus < MAX_BUSES; bus++)\n\t\t\tfor (target = 0; target < MAX_TARGETS; target++) {\n\t\t\t\tnv->bus[bus].target[target].parameter.\n\t\t\t\t\tauto_request_sense = 1;\n\t\t\t}\n\t} else {\n\t\tqla1280_set_defaults(ha);\n\t}\n\n\tqla1280_print_settings(nv);\n\n\t \n\tha->flags.disable_risc_code_load =\n\t\tnv->cntr_flags_1.disable_loading_risc_code;\n\n\tif (IS_ISP1040(ha)) {\n\t\tuint16_t hwrev, cfg1, cdma_conf;\n\n\t\thwrev = RD_REG_WORD(&reg->cfg_0) & ISP_CFG0_HWMSK;\n\n\t\tcfg1 = RD_REG_WORD(&reg->cfg_1) & ~(BIT_4 | BIT_5 | BIT_6);\n\t\tcdma_conf = RD_REG_WORD(&reg->cdma_cfg);\n\n\t\t \n\t\tif (hwrev != ISP_CFG0_1040A)\n\t\t\tcfg1 |= nv->isp_config.fifo_threshold << 4;\n\n\t\tcfg1 |= nv->isp_config.burst_enable << 2;\n\t\tWRT_REG_WORD(&reg->cfg_1, cfg1);\n\n\t\tWRT_REG_WORD(&reg->cdma_cfg, cdma_conf | CDMA_CONF_BENAB);\n\t\tWRT_REG_WORD(&reg->ddma_cfg, cdma_conf | DDMA_CONF_BENAB);\n\t} else {\n\t\tuint16_t cfg1, term;\n\n\t\t \n\t\tcfg1 = nv->isp_config.fifo_threshold << 4;\n\t\tcfg1 |= nv->isp_config.burst_enable << 2;\n\t\t \n\t\tif (ha->ports > 1)\n\t\t\tcfg1 |= BIT_13;\n\t\tWRT_REG_WORD(&reg->cfg_1, cfg1);\n\n\t\t \n\t\tWRT_REG_WORD(&reg->gpio_enable,\n\t\t\t     BIT_7 | BIT_3 | BIT_2 | BIT_1 | BIT_0);\n\t\tterm = nv->termination.scsi_bus_1_control;\n\t\tterm |= nv->termination.scsi_bus_0_control << 2;\n\t\tterm |= nv->termination.auto_term_support << 7;\n\t\tRD_REG_WORD(&reg->id_l);\t \n\t\tWRT_REG_WORD(&reg->gpio_data, term);\n\t}\n\tRD_REG_WORD(&reg->id_l);\t \n\n\t \n\tmb[0] = MBC_SET_SYSTEM_PARAMETER;\n\tmb[1] = nv->isp_parameter;\n\tstatus |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);\n\n\tif (IS_ISP1x40(ha)) {\n\t\t \n\t\tmb[0] = MBC_SET_CLOCK_RATE;\n\t\tmb[1] = 40;\n\t \tstatus |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);\n\t}\n\n\t \n\tmb[0] = MBC_SET_FIRMWARE_FEATURES;\n\tmb[1] = nv->firmware_feature.f.enable_fast_posting;\n\tmb[1] |= nv->firmware_feature.f.report_lvd_bus_transition << 1;\n\tmb[1] |= nv->firmware_feature.f.disable_synchronous_backoff << 5;\n\tstatus |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);\n\n\t \n\tmb[0] = MBC_SET_RETRY_COUNT;\n\tmb[1] = nv->bus[0].retry_count;\n\tmb[2] = nv->bus[0].retry_delay;\n\tmb[6] = nv->bus[1].retry_count;\n\tmb[7] = nv->bus[1].retry_delay;\n\tstatus |= qla1280_mailbox_command(ha, BIT_7 | BIT_6 | BIT_2 |\n\t\t\t\t\t  BIT_1 | BIT_0, &mb[0]);\n\n\t \n\tmb[0] = MBC_SET_ASYNC_DATA_SETUP;\n\tmb[1] = nv->bus[0].config_2.async_data_setup_time;\n\tmb[2] = nv->bus[1].config_2.async_data_setup_time;\n\tstatus |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, &mb[0]);\n\n\t \n\tmb[0] = MBC_SET_ACTIVE_NEGATION;\n\tmb[1] = 0;\n\tif (nv->bus[0].config_2.req_ack_active_negation)\n\t\tmb[1] |= BIT_5;\n\tif (nv->bus[0].config_2.data_line_active_negation)\n\t\tmb[1] |= BIT_4;\n\tmb[2] = 0;\n\tif (nv->bus[1].config_2.req_ack_active_negation)\n\t\tmb[2] |= BIT_5;\n\tif (nv->bus[1].config_2.data_line_active_negation)\n\t\tmb[2] |= BIT_4;\n\tstatus |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, mb);\n\n\tmb[0] = MBC_SET_DATA_OVERRUN_RECOVERY;\n\tmb[1] = 2;\t \n\tstatus |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);\n\n\t \n\tmb[0] = MBC_SET_PCI_CONTROL;\n\tmb[1] = BIT_1;\t \n\tmb[2] = BIT_1;\t \n\tstatus |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, mb);\n\n\tmb[0] = MBC_SET_TAG_AGE_LIMIT;\n\tmb[1] = 8;\n\tstatus |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);\n\n\t \n\tmb[0] = MBC_SET_SELECTION_TIMEOUT;\n\tmb[1] = nv->bus[0].selection_timeout;\n\tmb[2] = nv->bus[1].selection_timeout;\n\tstatus |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, mb);\n\n\tfor (bus = 0; bus < ha->ports; bus++)\n\t\tstatus |= qla1280_config_bus(ha, bus);\n\n\tif (status)\n\t\tdprintk(2, \"qla1280_nvram_config: **** FAILED ****\\n\");\n\n\tLEAVE(\"qla1280_nvram_config\");\n\treturn status;\n}\n\n \nstatic uint16_t\nqla1280_get_nvram_word(struct scsi_qla_host *ha, uint32_t address)\n{\n\tuint32_t nv_cmd;\n\tuint16_t data;\n\n\tnv_cmd = address << 16;\n\tnv_cmd |= NV_READ_OP;\n\n\tdata = le16_to_cpu(qla1280_nvram_request(ha, nv_cmd));\n\n\tdprintk(8, \"qla1280_get_nvram_word: exiting normally NVRAM data = \"\n\t\t\"0x%x\", data);\n\n\treturn data;\n}\n\n \nstatic uint16_t\nqla1280_nvram_request(struct scsi_qla_host *ha, uint32_t nv_cmd)\n{\n\tstruct device_reg __iomem *reg = ha->iobase;\n\tint cnt;\n\tuint16_t data = 0;\n\tuint16_t reg_data;\n\n\t \n\n\tnv_cmd <<= 5;\n\tfor (cnt = 0; cnt < 11; cnt++) {\n\t\tif (nv_cmd & BIT_31)\n\t\t\tqla1280_nv_write(ha, NV_DATA_OUT);\n\t\telse\n\t\t\tqla1280_nv_write(ha, 0);\n\t\tnv_cmd <<= 1;\n\t}\n\n\t \n\n\tfor (cnt = 0; cnt < 16; cnt++) {\n\t\tWRT_REG_WORD(&reg->nvram, (NV_SELECT | NV_CLOCK));\n\t\tRD_REG_WORD(&reg->id_l);\t \n\t\tNVRAM_DELAY();\n\t\tdata <<= 1;\n\t\treg_data = RD_REG_WORD(&reg->nvram);\n\t\tif (reg_data & NV_DATA_IN)\n\t\t\tdata |= BIT_0;\n\t\tWRT_REG_WORD(&reg->nvram, NV_SELECT);\n\t\tRD_REG_WORD(&reg->id_l);\t \n\t\tNVRAM_DELAY();\n\t}\n\n\t \n\n\tWRT_REG_WORD(&reg->nvram, NV_DESELECT);\n\tRD_REG_WORD(&reg->id_l);\t \n\tNVRAM_DELAY();\n\n\treturn data;\n}\n\nstatic void\nqla1280_nv_write(struct scsi_qla_host *ha, uint16_t data)\n{\n\tstruct device_reg __iomem *reg = ha->iobase;\n\n\tWRT_REG_WORD(&reg->nvram, data | NV_SELECT);\n\tRD_REG_WORD(&reg->id_l);\t \n\tNVRAM_DELAY();\n\tWRT_REG_WORD(&reg->nvram, data | NV_SELECT | NV_CLOCK);\n\tRD_REG_WORD(&reg->id_l);\t \n\tNVRAM_DELAY();\n\tWRT_REG_WORD(&reg->nvram, data | NV_SELECT);\n\tRD_REG_WORD(&reg->id_l);\t \n\tNVRAM_DELAY();\n}\n\n \nstatic int\nqla1280_mailbox_command(struct scsi_qla_host *ha, uint8_t mr, uint16_t *mb)\n{\n\tstruct device_reg __iomem *reg = ha->iobase;\n\tint status = 0;\n\tint cnt;\n\tuint16_t *optr, *iptr;\n\tuint16_t __iomem *mptr;\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\n\tENTER(\"qla1280_mailbox_command\");\n\n\tif (ha->mailbox_wait) {\n\t\tprintk(KERN_ERR \"Warning mailbox wait already in use!\\n\");\n\t}\n\tha->mailbox_wait = &wait;\n\n\t \n\t \n\tmptr = (uint16_t __iomem *) &reg->mailbox0;\n\tiptr = mb;\n\tfor (cnt = 0; cnt < MAILBOX_REGISTER_COUNT; cnt++) {\n\t\tif (mr & BIT_0) {\n\t\t\tWRT_REG_WORD(mptr, (*iptr));\n\t\t}\n\n\t\tmr >>= 1;\n\t\tmptr++;\n\t\tiptr++;\n\t}\n\n\t \n\n\t \n\ttimer_setup(&ha->mailbox_timer, qla1280_mailbox_timeout, 0);\n\tmod_timer(&ha->mailbox_timer, jiffies + 20 * HZ);\n\n\tspin_unlock_irq(ha->host->host_lock);\n\tWRT_REG_WORD(&reg->host_cmd, HC_SET_HOST_INT);\n\tqla1280_debounce_register(&reg->istatus);\n\n\twait_for_completion(&wait);\n\tdel_timer_sync(&ha->mailbox_timer);\n\n\tspin_lock_irq(ha->host->host_lock);\n\n\tha->mailbox_wait = NULL;\n\n\t \n\tif (ha->mailbox_out[0] != MBS_CMD_CMP) {\n\t\tprintk(KERN_WARNING \"qla1280_mailbox_command: Command failed, \"\n\t\t       \"mailbox0 = 0x%04x, mailbox_out0 = 0x%04x, istatus = \"\n\t\t       \"0x%04x\\n\", \n\t\t       mb[0], ha->mailbox_out[0], RD_REG_WORD(&reg->istatus));\n\t\tprintk(KERN_WARNING \"m0 %04x, m1 %04x, m2 %04x, m3 %04x\\n\",\n\t\t       RD_REG_WORD(&reg->mailbox0), RD_REG_WORD(&reg->mailbox1),\n\t\t       RD_REG_WORD(&reg->mailbox2), RD_REG_WORD(&reg->mailbox3));\n\t\tprintk(KERN_WARNING \"m4 %04x, m5 %04x, m6 %04x, m7 %04x\\n\",\n\t\t       RD_REG_WORD(&reg->mailbox4), RD_REG_WORD(&reg->mailbox5),\n\t\t       RD_REG_WORD(&reg->mailbox6), RD_REG_WORD(&reg->mailbox7));\n\t\tstatus = 1;\n\t}\n\n\t \n\toptr = mb;\n\tiptr = (uint16_t *) &ha->mailbox_out[0];\n\tmr = MAILBOX_REGISTER_COUNT;\n\tmemcpy(optr, iptr, MAILBOX_REGISTER_COUNT * sizeof(uint16_t));\n\n\tif (ha->flags.reset_marker)\n\t\tqla1280_rst_aen(ha);\n\n\tif (status)\n\t\tdprintk(2, \"qla1280_mailbox_command: **** FAILED, mailbox0 = \"\n\t\t\t\"0x%x ****\\n\", mb[0]);\n\n\tLEAVE(\"qla1280_mailbox_command\");\n\treturn status;\n}\n\n \nstatic void\nqla1280_poll(struct scsi_qla_host *ha)\n{\n\tstruct device_reg __iomem *reg = ha->iobase;\n\tuint16_t data;\n\tLIST_HEAD(done_q);\n\n\t \n\n\t \n\tdata = RD_REG_WORD(&reg->istatus);\n\tif (data & RISC_INT)\n\t\tqla1280_isr(ha, &done_q);\n\n\tif (!ha->mailbox_wait) {\n\t\tif (ha->flags.reset_marker)\n\t\t\tqla1280_rst_aen(ha);\n\t}\n\n\tif (!list_empty(&done_q))\n\t\tqla1280_done(ha);\n\n\t \n}\n\n \nstatic int\nqla1280_bus_reset(struct scsi_qla_host *ha, int bus)\n{\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tuint16_t reset_delay;\n\tint status;\n\n\tdprintk(3, \"qla1280_bus_reset: entered\\n\");\n\n\tif (qla1280_verbose)\n\t\tprintk(KERN_INFO \"scsi(%li:%i): Resetting SCSI BUS\\n\",\n\t\t       ha->host_no, bus);\n\n\treset_delay = ha->bus_settings[bus].bus_reset_delay;\n\tmb[0] = MBC_BUS_RESET;\n\tmb[1] = reset_delay;\n\tmb[2] = (uint16_t) bus;\n\tstatus = qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, &mb[0]);\n\n\tif (status) {\n\t\tif (ha->bus_settings[bus].failed_reset_count > 2)\n\t\t\tha->bus_settings[bus].scsi_bus_dead = 1;\n\t\tha->bus_settings[bus].failed_reset_count++;\n\t} else {\n\t\tspin_unlock_irq(ha->host->host_lock);\n\t\tssleep(reset_delay);\n\t\tspin_lock_irq(ha->host->host_lock);\n\n\t\tha->bus_settings[bus].scsi_bus_dead = 0;\n\t\tha->bus_settings[bus].failed_reset_count = 0;\n\t\tha->bus_settings[bus].reset_marker = 0;\n\t\t \n\t\tqla1280_marker(ha, bus, 0, 0, MK_SYNC_ALL);\n\t}\n\n\t \n\n\tif (status)\n\t\tdprintk(2, \"qla1280_bus_reset: **** FAILED ****\\n\");\n\telse\n\t\tdprintk(3, \"qla1280_bus_reset: exiting normally\\n\");\n\n\treturn status;\n}\n\n \nstatic int\nqla1280_device_reset(struct scsi_qla_host *ha, int bus, int target)\n{\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tint status;\n\n\tENTER(\"qla1280_device_reset\");\n\n\tmb[0] = MBC_ABORT_TARGET;\n\tmb[1] = (bus ? (target | BIT_7) : target) << 8;\n\tmb[2] = 1;\n\tstatus = qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, &mb[0]);\n\n\t \n\tqla1280_marker(ha, bus, target, 0, MK_SYNC_ID);\n\n\tif (status)\n\t\tdprintk(2, \"qla1280_device_reset: **** FAILED ****\\n\");\n\n\tLEAVE(\"qla1280_device_reset\");\n\treturn status;\n}\n\n \nstatic int\nqla1280_abort_command(struct scsi_qla_host *ha, struct srb * sp, int handle)\n{\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tunsigned int bus, target, lun;\n\tint status;\n\n\tENTER(\"qla1280_abort_command\");\n\n\tbus = SCSI_BUS_32(sp->cmd);\n\ttarget = SCSI_TCN_32(sp->cmd);\n\tlun = SCSI_LUN_32(sp->cmd);\n\n\tsp->flags |= SRB_ABORT_PENDING;\n\n\tmb[0] = MBC_ABORT_COMMAND;\n\tmb[1] = (bus ? target | BIT_7 : target) << 8 | lun;\n\tmb[2] = handle >> 16;\n\tmb[3] = handle & 0xffff;\n\tstatus = qla1280_mailbox_command(ha, 0x0f, &mb[0]);\n\n\tif (status) {\n\t\tdprintk(2, \"qla1280_abort_command: **** FAILED ****\\n\");\n\t\tsp->flags &= ~SRB_ABORT_PENDING;\n\t}\n\n\n\tLEAVE(\"qla1280_abort_command\");\n\treturn status;\n}\n\n \nstatic void\nqla1280_reset_adapter(struct scsi_qla_host *ha)\n{\n\tstruct device_reg __iomem *reg = ha->iobase;\n\n\tENTER(\"qla1280_reset_adapter\");\n\n\t \n\tha->flags.online = 0;\n\tWRT_REG_WORD(&reg->ictrl, ISP_RESET);\n\tWRT_REG_WORD(&reg->host_cmd,\n\t\t     HC_RESET_RISC | HC_RELEASE_RISC | HC_DISABLE_BIOS);\n\tRD_REG_WORD(&reg->id_l);\t \n\n\tLEAVE(\"qla1280_reset_adapter\");\n}\n\n \nstatic void\nqla1280_marker(struct scsi_qla_host *ha, int bus, int id, int lun, u8 type)\n{\n\tstruct mrk_entry *pkt;\n\n\tENTER(\"qla1280_marker\");\n\n\t \n\tif ((pkt = (struct mrk_entry *) qla1280_req_pkt(ha))) {\n\t\tpkt->entry_type = MARKER_TYPE;\n\t\tpkt->lun = (uint8_t) lun;\n\t\tpkt->target = (uint8_t) (bus ? (id | BIT_7) : id);\n\t\tpkt->modifier = type;\n\t\tpkt->entry_status = 0;\n\n\t\t \n\t\tqla1280_isp_cmd(ha);\n\t}\n\n\tLEAVE(\"qla1280_marker\");\n}\n\n\n \n#ifdef QLA_64BIT_PTR\nstatic int\nqla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)\n{\n\tstruct device_reg __iomem *reg = ha->iobase;\n\tstruct scsi_cmnd *cmd = sp->cmd;\n\tcmd_a64_entry_t *pkt;\n\t__le32 *dword_ptr;\n\tdma_addr_t dma_handle;\n\tint status = 0;\n\tint cnt;\n\tint req_cnt;\n\tint seg_cnt;\n\tu8 dir;\n\n\tENTER(\"qla1280_64bit_start_scsi:\");\n\n\t \n\treq_cnt = 1;\n\tseg_cnt = scsi_dma_map(cmd);\n\tif (seg_cnt > 0) {\n\t\tif (seg_cnt > 2) {\n\t\t\treq_cnt += (seg_cnt - 2) / 5;\n\t\t\tif ((seg_cnt - 2) % 5)\n\t\t\t\treq_cnt++;\n\t\t}\n\t} else if (seg_cnt < 0) {\n\t\tstatus = 1;\n\t\tgoto out;\n\t}\n\n\tif ((req_cnt + 2) >= ha->req_q_cnt) {\n\t\t \n\t\tcnt = RD_REG_WORD(&reg->mailbox4);\n\t\tif (ha->req_ring_index < cnt)\n\t\t\tha->req_q_cnt = cnt - ha->req_ring_index;\n\t\telse\n\t\t\tha->req_q_cnt =\n\t\t\t\tREQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);\n\t}\n\n\tdprintk(3, \"Number of free entries=(%d) seg_cnt=0x%x\\n\",\n\t\tha->req_q_cnt, seg_cnt);\n\n\t \n\tif ((req_cnt + 2) >= ha->req_q_cnt) {\n\t\tstatus = SCSI_MLQUEUE_HOST_BUSY;\n\t\tdprintk(2, \"qla1280_start_scsi: in-ptr=0x%x  req_q_cnt=\"\n\t\t\t\"0x%xreq_cnt=0x%x\", ha->req_ring_index, ha->req_q_cnt,\n\t\t\treq_cnt);\n\t\tgoto out;\n\t}\n\n\t \n\tfor (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS &&\n\t\t     ha->outstanding_cmds[cnt] != NULL; cnt++);\n\n\tif (cnt >= MAX_OUTSTANDING_COMMANDS) {\n\t\tstatus = SCSI_MLQUEUE_HOST_BUSY;\n\t\tdprintk(2, \"qla1280_start_scsi: NO ROOM IN \"\n\t\t\t\"OUTSTANDING ARRAY, req_q_cnt=0x%x\", ha->req_q_cnt);\n\t\tgoto out;\n\t}\n\n\tha->outstanding_cmds[cnt] = sp;\n\tha->req_q_cnt -= req_cnt;\n\tCMD_HANDLE(sp->cmd) = (unsigned char *)(unsigned long)(cnt + 1);\n\n\tdprintk(2, \"start: cmd=%p sp=%p CDB=%xm, handle %lx\\n\", cmd, sp,\n\t\tcmd->cmnd[0], (long)CMD_HANDLE(sp->cmd));\n\tdprintk(2, \"             bus %i, target %i, lun %i\\n\",\n\t\tSCSI_BUS_32(cmd), SCSI_TCN_32(cmd), SCSI_LUN_32(cmd));\n\tqla1280_dump_buffer(2, cmd->cmnd, MAX_COMMAND_SIZE);\n\n\t \n\tpkt = (cmd_a64_entry_t *) ha->request_ring_ptr;\n\n\tpkt->entry_type = COMMAND_A64_TYPE;\n\tpkt->entry_count = (uint8_t) req_cnt;\n\tpkt->sys_define = (uint8_t) ha->req_ring_index;\n\tpkt->entry_status = 0;\n\tpkt->handle = cpu_to_le32(cnt);\n\n\t \n\tmemset(((char *)pkt + 8), 0, (REQUEST_ENTRY_SIZE - 8));\n\n\t \n\tpkt->timeout = cpu_to_le16(scsi_cmd_to_rq(cmd)->timeout / HZ);\n\n\t \n\tpkt->lun = SCSI_LUN_32(cmd);\n\tpkt->target = SCSI_BUS_32(cmd) ?\n\t\t(SCSI_TCN_32(cmd) | BIT_7) : SCSI_TCN_32(cmd);\n\n\t \n\tif (cmd->device->simple_tags)\n\t\tpkt->control_flags |= cpu_to_le16(BIT_3);\n\n\t \n\tpkt->cdb_len = cpu_to_le16(CMD_CDBLEN(cmd));\n\tmemcpy(pkt->scsi_cdb, CMD_CDBP(cmd), CMD_CDBLEN(cmd));\n\t \n\n\t \n\tdir = qla1280_data_direction(cmd);\n\tpkt->control_flags |= cpu_to_le16(dir);\n\n\t \n\tpkt->dseg_count = cpu_to_le16(seg_cnt);\n\n\t \n\tif (seg_cnt) {\t \n\t\tstruct scatterlist *sg, *s;\n\t\tint remseg = seg_cnt;\n\n\t\tsg = scsi_sglist(cmd);\n\n\t\t \n\t\tdword_ptr = (u32 *)&pkt->dseg_0_address;\n\n\t\t \n\t\tfor_each_sg(sg, s, seg_cnt, cnt) {\n\t\t\tif (cnt == 2)\n\t\t\t\tbreak;\n\n\t\t\tdma_handle = sg_dma_address(s);\n\t\t\t*dword_ptr++ =\n\t\t\t\tcpu_to_le32(lower_32_bits(dma_handle));\n\t\t\t*dword_ptr++ =\n\t\t\t\tcpu_to_le32(upper_32_bits(dma_handle));\n\t\t\t*dword_ptr++ = cpu_to_le32(sg_dma_len(s));\n\t\t\tdprintk(3, \"S/G Segment phys_addr=%x %x, len=0x%x\\n\",\n\t\t\t\tcpu_to_le32(upper_32_bits(dma_handle)),\n\t\t\t\tcpu_to_le32(lower_32_bits(dma_handle)),\n\t\t\t\tcpu_to_le32(sg_dma_len(sg_next(s))));\n\t\t\tremseg--;\n\t\t}\n\t\tdprintk(5, \"qla1280_64bit_start_scsi: Scatter/gather \"\n\t\t\t\"command packet data - b %i, t %i, l %i \\n\",\n\t\t\tSCSI_BUS_32(cmd), SCSI_TCN_32(cmd),\n\t\t\tSCSI_LUN_32(cmd));\n\t\tqla1280_dump_buffer(5, (char *)pkt,\n\t\t\t\t    REQUEST_ENTRY_SIZE);\n\n\t\t \n\t\tdprintk(3, \"S/G Building Continuation...seg_cnt=0x%x \"\n\t\t\t\"remains\\n\", seg_cnt);\n\n\t\twhile (remseg > 0) {\n\t\t\t \n\t\t\tsg = s;\n\t\t\t \n\t\t\tha->req_ring_index++;\n\t\t\tif (ha->req_ring_index == REQUEST_ENTRY_CNT) {\n\t\t\t\tha->req_ring_index = 0;\n\t\t\t\tha->request_ring_ptr =\n\t\t\t\t\tha->request_ring;\n\t\t\t} else\n\t\t\t\tha->request_ring_ptr++;\n\n\t\t\tpkt = (cmd_a64_entry_t *)ha->request_ring_ptr;\n\n\t\t\t \n\t\t\tmemset(pkt, 0, REQUEST_ENTRY_SIZE);\n\n\t\t\t \n\t\t\t((struct cont_a64_entry *) pkt)->entry_type =\n\t\t\t\tCONTINUE_A64_TYPE;\n\t\t\t((struct cont_a64_entry *) pkt)->entry_count = 1;\n\t\t\t((struct cont_a64_entry *) pkt)->sys_define =\n\t\t\t\t(uint8_t)ha->req_ring_index;\n\t\t\t \n\t\t\tdword_ptr =\n\t\t\t\t(u32 *)&((struct cont_a64_entry *) pkt)->dseg_0_address;\n\n\t\t\t \n\t\t\tfor_each_sg(sg, s, remseg, cnt) {\n\t\t\t\tif (cnt == 5)\n\t\t\t\t\tbreak;\n\t\t\t\tdma_handle = sg_dma_address(s);\n\t\t\t\t*dword_ptr++ =\n\t\t\t\t\tcpu_to_le32(lower_32_bits(dma_handle));\n\t\t\t\t*dword_ptr++ =\n\t\t\t\t\tcpu_to_le32(upper_32_bits(dma_handle));\n\t\t\t\t*dword_ptr++ =\n\t\t\t\t\tcpu_to_le32(sg_dma_len(s));\n\t\t\t\tdprintk(3, \"S/G Segment Cont. phys_addr=%x %x, len=0x%x\\n\",\n\t\t\t\t\tcpu_to_le32(upper_32_bits(dma_handle)),\n\t\t\t\t\tcpu_to_le32(lower_32_bits(dma_handle)),\n\t\t\t\t\tcpu_to_le32(sg_dma_len(s)));\n\t\t\t}\n\t\t\tremseg -= cnt;\n\t\t\tdprintk(5, \"qla1280_64bit_start_scsi: \"\n\t\t\t\t\"continuation packet data - b %i, t \"\n\t\t\t\t\"%i, l %i \\n\", SCSI_BUS_32(cmd),\n\t\t\t\tSCSI_TCN_32(cmd), SCSI_LUN_32(cmd));\n\t\t\tqla1280_dump_buffer(5, (char *)pkt,\n\t\t\t\t\t    REQUEST_ENTRY_SIZE);\n\t\t}\n\t} else {\t \n\t\tdprintk(5, \"qla1280_64bit_start_scsi: No data, command \"\n\t\t\t\"packet data - b %i, t %i, l %i \\n\",\n\t\t\tSCSI_BUS_32(cmd), SCSI_TCN_32(cmd), SCSI_LUN_32(cmd));\n\t\tqla1280_dump_buffer(5, (char *)pkt, REQUEST_ENTRY_SIZE);\n\t}\n\t \n\tha->req_ring_index++;\n\tif (ha->req_ring_index == REQUEST_ENTRY_CNT) {\n\t\tha->req_ring_index = 0;\n\t\tha->request_ring_ptr = ha->request_ring;\n\t} else\n\t\tha->request_ring_ptr++;\n\n\t \n\tdprintk(2,\n\t\t\"qla1280_64bit_start_scsi: Wakeup RISC for pending command\\n\");\n\tsp->flags |= SRB_SENT;\n\tha->actthreads++;\n\tWRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);\n\n out:\n\tif (status)\n\t\tdprintk(2, \"qla1280_64bit_start_scsi: **** FAILED ****\\n\");\n\telse\n\t\tdprintk(3, \"qla1280_64bit_start_scsi: exiting normally\\n\");\n\n\treturn status;\n}\n#else  \n\n \nstatic int\nqla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)\n{\n\tstruct device_reg __iomem *reg = ha->iobase;\n\tstruct scsi_cmnd *cmd = sp->cmd;\n\tstruct cmd_entry *pkt;\n\t__le32 *dword_ptr;\n\tint status = 0;\n\tint cnt;\n\tint req_cnt;\n\tint seg_cnt;\n\tu8 dir;\n\n\tENTER(\"qla1280_32bit_start_scsi\");\n\n\tdprintk(1, \"32bit_start: cmd=%p sp=%p CDB=%x\\n\", cmd, sp,\n\t\tcmd->cmnd[0]);\n\n\t \n\treq_cnt = 1;\n\tseg_cnt = scsi_dma_map(cmd);\n\tif (seg_cnt) {\n\t\t \n\t\tif (seg_cnt > 4) {\n\t\t\treq_cnt += (seg_cnt - 4) / 7;\n\t\t\tif ((seg_cnt - 4) % 7)\n\t\t\t\treq_cnt++;\n\t\t}\n\t\tdprintk(3, \"S/G Transfer cmd=%p seg_cnt=0x%x, req_cnt=%x\\n\",\n\t\t\tcmd, seg_cnt, req_cnt);\n\t} else if (seg_cnt < 0) {\n\t\tstatus = 1;\n\t\tgoto out;\n\t}\n\n\tif ((req_cnt + 2) >= ha->req_q_cnt) {\n\t\t \n\t\tcnt = RD_REG_WORD(&reg->mailbox4);\n\t\tif (ha->req_ring_index < cnt)\n\t\t\tha->req_q_cnt = cnt - ha->req_ring_index;\n\t\telse\n\t\t\tha->req_q_cnt =\n\t\t\t\tREQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);\n\t}\n\n\tdprintk(3, \"Number of free entries=(%d) seg_cnt=0x%x\\n\",\n\t\tha->req_q_cnt, seg_cnt);\n\t \n\tif ((req_cnt + 2) >= ha->req_q_cnt) {\n\t\tstatus = SCSI_MLQUEUE_HOST_BUSY;\n\t\tdprintk(2, \"qla1280_32bit_start_scsi: in-ptr=0x%x, \"\n\t\t\t\"req_q_cnt=0x%x, req_cnt=0x%x\", ha->req_ring_index,\n\t\t\tha->req_q_cnt, req_cnt);\n\t\tgoto out;\n\t}\n\n\t \n\tfor (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS &&\n\t     ha->outstanding_cmds[cnt]; cnt++);\n\n\tif (cnt >= MAX_OUTSTANDING_COMMANDS) {\n\t\tstatus = SCSI_MLQUEUE_HOST_BUSY;\n\t\tdprintk(2, \"qla1280_32bit_start_scsi: NO ROOM IN OUTSTANDING \"\n\t\t\t\"ARRAY, req_q_cnt=0x%x\\n\", ha->req_q_cnt);\n\t\tgoto out;\n\t}\n\n\tCMD_HANDLE(sp->cmd) = (unsigned char *) (unsigned long)(cnt + 1);\n\tha->outstanding_cmds[cnt] = sp;\n\tha->req_q_cnt -= req_cnt;\n\n\t \n\tpkt = (struct cmd_entry *) ha->request_ring_ptr;\n\n\tpkt->entry_type = COMMAND_TYPE;\n\tpkt->entry_count = (uint8_t) req_cnt;\n\tpkt->sys_define = (uint8_t) ha->req_ring_index;\n\tpkt->entry_status = 0;\n\tpkt->handle = cpu_to_le32(cnt);\n\n\t \n\tmemset(((char *)pkt + 8), 0, (REQUEST_ENTRY_SIZE - 8));\n\n\t \n\tpkt->timeout = cpu_to_le16(scsi_cmd_to_rq(cmd)->timeout / HZ);\n\n\t \n\tpkt->lun = SCSI_LUN_32(cmd);\n\tpkt->target = SCSI_BUS_32(cmd) ?\n\t\t(SCSI_TCN_32(cmd) | BIT_7) : SCSI_TCN_32(cmd);\n\n\t \n\tif (cmd->device->simple_tags)\n\t\tpkt->control_flags |= cpu_to_le16(BIT_3);\n\n\t \n\tpkt->cdb_len = cpu_to_le16(CMD_CDBLEN(cmd));\n\tmemcpy(pkt->scsi_cdb, CMD_CDBP(cmd), CMD_CDBLEN(cmd));\n\n\t \n\t \n\tdir = qla1280_data_direction(cmd);\n\tpkt->control_flags |= cpu_to_le16(dir);\n\n\t \n\tpkt->dseg_count = cpu_to_le16(seg_cnt);\n\n\t \n\tif (seg_cnt) {\n\t\tstruct scatterlist *sg, *s;\n\t\tint remseg = seg_cnt;\n\n\t\tsg = scsi_sglist(cmd);\n\n\t\t \n\t\tdword_ptr = &pkt->dseg_0_address;\n\n\t\tdprintk(3, \"Building S/G data segments..\\n\");\n\t\tqla1280_dump_buffer(1, (char *)sg, 4 * 16);\n\n\t\t \n\t\tfor_each_sg(sg, s, seg_cnt, cnt) {\n\t\t\tif (cnt == 4)\n\t\t\t\tbreak;\n\t\t\t*dword_ptr++ =\n\t\t\t\tcpu_to_le32(lower_32_bits(sg_dma_address(s)));\n\t\t\t*dword_ptr++ = cpu_to_le32(sg_dma_len(s));\n\t\t\tdprintk(3, \"S/G Segment phys_addr=0x%lx, len=0x%x\\n\",\n\t\t\t\t(lower_32_bits(sg_dma_address(s))),\n\t\t\t\t(sg_dma_len(s)));\n\t\t\tremseg--;\n\t\t}\n\t\t \n\t\tdprintk(3, \"S/G Building Continuation\"\n\t\t\t\"...seg_cnt=0x%x remains\\n\", seg_cnt);\n\t\twhile (remseg > 0) {\n\t\t\t \n\t\t\tsg = s;\n\t\t\t \n\t\t\tha->req_ring_index++;\n\t\t\tif (ha->req_ring_index == REQUEST_ENTRY_CNT) {\n\t\t\t\tha->req_ring_index = 0;\n\t\t\t\tha->request_ring_ptr =\n\t\t\t\t\tha->request_ring;\n\t\t\t} else\n\t\t\t\tha->request_ring_ptr++;\n\n\t\t\tpkt = (struct cmd_entry *)ha->request_ring_ptr;\n\n\t\t\t \n\t\t\tmemset(pkt, 0, REQUEST_ENTRY_SIZE);\n\n\t\t\t \n\t\t\t((struct cont_entry *) pkt)->\n\t\t\t\tentry_type = CONTINUE_TYPE;\n\t\t\t((struct cont_entry *) pkt)->entry_count = 1;\n\n\t\t\t((struct cont_entry *) pkt)->sys_define =\n\t\t\t\t(uint8_t) ha->req_ring_index;\n\n\t\t\t \n\t\t\tdword_ptr =\n\t\t\t\t&((struct cont_entry *) pkt)->dseg_0_address;\n\n\t\t\t \n\t\t\tfor_each_sg(sg, s, remseg, cnt) {\n\t\t\t\tif (cnt == 7)\n\t\t\t\t\tbreak;\n\t\t\t\t*dword_ptr++ =\n\t\t\t\t\tcpu_to_le32(lower_32_bits(sg_dma_address(s)));\n\t\t\t\t*dword_ptr++ =\n\t\t\t\t\tcpu_to_le32(sg_dma_len(s));\n\t\t\t\tdprintk(1,\n\t\t\t\t\t\"S/G Segment Cont. phys_addr=0x%x, \"\n\t\t\t\t\t\"len=0x%x\\n\",\n\t\t\t\t\tcpu_to_le32(lower_32_bits(sg_dma_address(s))),\n\t\t\t\t\tcpu_to_le32(sg_dma_len(s)));\n\t\t\t}\n\t\t\tremseg -= cnt;\n\t\t\tdprintk(5, \"qla1280_32bit_start_scsi: \"\n\t\t\t\t\"continuation packet data - \"\n\t\t\t\t\"scsi(%i:%i:%i)\\n\", SCSI_BUS_32(cmd),\n\t\t\t\tSCSI_TCN_32(cmd), SCSI_LUN_32(cmd));\n\t\t\tqla1280_dump_buffer(5, (char *)pkt,\n\t\t\t\t\t    REQUEST_ENTRY_SIZE);\n\t\t}\n\t} else {\t \n\t\tdprintk(5, \"qla1280_32bit_start_scsi: No data, command \"\n\t\t\t\"packet data - \\n\");\n\t\tqla1280_dump_buffer(5, (char *)pkt, REQUEST_ENTRY_SIZE);\n\t}\n\tdprintk(5, \"qla1280_32bit_start_scsi: First IOCB block:\\n\");\n\tqla1280_dump_buffer(5, (char *)ha->request_ring_ptr,\n\t\t\t    REQUEST_ENTRY_SIZE);\n\n\t \n\tha->req_ring_index++;\n\tif (ha->req_ring_index == REQUEST_ENTRY_CNT) {\n\t\tha->req_ring_index = 0;\n\t\tha->request_ring_ptr = ha->request_ring;\n\t} else\n\t\tha->request_ring_ptr++;\n\n\t \n\tdprintk(2, \"qla1280_32bit_start_scsi: Wakeup RISC \"\n\t\t\"for pending command\\n\");\n\tsp->flags |= SRB_SENT;\n\tha->actthreads++;\n\tWRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);\n\nout:\n\tif (status)\n\t\tdprintk(2, \"qla1280_32bit_start_scsi: **** FAILED ****\\n\");\n\n\tLEAVE(\"qla1280_32bit_start_scsi\");\n\n\treturn status;\n}\n#endif\n\n \nstatic request_t *\nqla1280_req_pkt(struct scsi_qla_host *ha)\n{\n\tstruct device_reg __iomem *reg = ha->iobase;\n\trequest_t *pkt = NULL;\n\tint cnt;\n\tuint32_t timer;\n\n\tENTER(\"qla1280_req_pkt\");\n\n\t \n\t \n\tfor (timer = 15000000; timer; timer--) {\n\t\tif (ha->req_q_cnt > 0) {\n\t\t\t \n\t\t\tcnt = RD_REG_WORD(&reg->mailbox4);\n\t\t\tif (ha->req_ring_index < cnt)\n\t\t\t\tha->req_q_cnt = cnt - ha->req_ring_index;\n\t\t\telse\n\t\t\t\tha->req_q_cnt =\n\t\t\t\t\tREQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);\n\t\t}\n\n\t\t \n\t\tif (ha->req_q_cnt > 0) {\n\t\t\tha->req_q_cnt--;\n\t\t\tpkt = ha->request_ring_ptr;\n\n\t\t\t \n\t\t\tmemset(pkt, 0, REQUEST_ENTRY_SIZE);\n\n\t\t\t \n\t\t\t \n\t\t\tpkt->sys_define = (uint8_t) ha->req_ring_index;\n\n\t\t\t \n\t\t\tpkt->entry_count = 1;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tudelay(2);\t \n\n\t\t \n\t\tqla1280_poll(ha);\n\t}\n\n\tif (!pkt)\n\t\tdprintk(2, \"qla1280_req_pkt: **** FAILED ****\\n\");\n\telse\n\t\tdprintk(3, \"qla1280_req_pkt: exiting normally\\n\");\n\n\treturn pkt;\n}\n\n \nstatic void\nqla1280_isp_cmd(struct scsi_qla_host *ha)\n{\n\tstruct device_reg __iomem *reg = ha->iobase;\n\n\tENTER(\"qla1280_isp_cmd\");\n\n\tdprintk(5, \"qla1280_isp_cmd: IOCB data:\\n\");\n\tqla1280_dump_buffer(5, (char *)ha->request_ring_ptr,\n\t\t\t    REQUEST_ENTRY_SIZE);\n\n\t \n\tha->req_ring_index++;\n\tif (ha->req_ring_index == REQUEST_ENTRY_CNT) {\n\t\tha->req_ring_index = 0;\n\t\tha->request_ring_ptr = ha->request_ring;\n\t} else\n\t\tha->request_ring_ptr++;\n\n\t \n\tWRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);\n\n\tLEAVE(\"qla1280_isp_cmd\");\n}\n\n \n \n \n\n \nstatic void\nqla1280_isr(struct scsi_qla_host *ha, struct list_head *done_q)\n{\n\tstruct device_reg __iomem *reg = ha->iobase;\n\tstruct response *pkt;\n\tstruct srb *sp = NULL;\n\tuint16_t mailbox[MAILBOX_REGISTER_COUNT];\n\tuint16_t *wptr;\n\tuint32_t index;\n\tu16 istatus;\n\n\tENTER(\"qla1280_isr\");\n\n\tistatus = RD_REG_WORD(&reg->istatus);\n\tif (!(istatus & (RISC_INT | PCI_INT)))\n\t\treturn;\n\n\t \n\tmailbox[5] = RD_REG_WORD(&reg->mailbox5);\n\n\t \n\n\tmailbox[0] = RD_REG_WORD_dmasync(&reg->semaphore);\n\n\tif (mailbox[0] & BIT_0) {\n\t\t \n\t\t \n\n\t\twptr = &mailbox[0];\n\t\t*wptr++ = RD_REG_WORD(&reg->mailbox0);\n\t\t*wptr++ = RD_REG_WORD(&reg->mailbox1);\n\t\t*wptr = RD_REG_WORD(&reg->mailbox2);\n\t\tif (mailbox[0] != MBA_SCSI_COMPLETION) {\n\t\t\twptr++;\n\t\t\t*wptr++ = RD_REG_WORD(&reg->mailbox3);\n\t\t\t*wptr++ = RD_REG_WORD(&reg->mailbox4);\n\t\t\twptr++;\n\t\t\t*wptr++ = RD_REG_WORD(&reg->mailbox6);\n\t\t\t*wptr = RD_REG_WORD(&reg->mailbox7);\n\t\t}\n\n\t\t \n\n\t\tWRT_REG_WORD(&reg->semaphore, 0);\n\t\tWRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);\n\n\t\tdprintk(5, \"qla1280_isr: mailbox interrupt mailbox[0] = 0x%x\",\n\t\t\tmailbox[0]);\n\n\t\t \n\t\tswitch (mailbox[0]) {\n\t\tcase MBA_SCSI_COMPLETION:\t \n\t\t\tdprintk(5, \"qla1280_isr: mailbox SCSI response \"\n\t\t\t\t\"completion\\n\");\n\n\t\t\tif (ha->flags.online) {\n\t\t\t\t \n\t\t\t\tindex = mailbox[2] << 16 | mailbox[1];\n\n\t\t\t\t \n\t\t\t\tif (index < MAX_OUTSTANDING_COMMANDS)\n\t\t\t\t\tsp = ha->outstanding_cmds[index];\n\t\t\t\telse\n\t\t\t\t\tsp = NULL;\n\n\t\t\t\tif (sp) {\n\t\t\t\t\t \n\t\t\t\t\tha->outstanding_cmds[index] = NULL;\n\n\t\t\t\t\t \n\t\t\t\t\tCMD_RESULT(sp->cmd) = 0;\n\t\t\t\t\tCMD_HANDLE(sp->cmd) = COMPLETED_HANDLE;\n\n\t\t\t\t\t \n\t\t\t\t\tlist_add_tail(&sp->list, done_q);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t       \"qla1280: ISP invalid handle\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MBA_BUS_RESET:\t \n\t\t\tha->flags.reset_marker = 1;\n\t\t\tindex = mailbox[6] & BIT_0;\n\t\t\tha->bus_settings[index].reset_marker = 1;\n\n\t\t\tprintk(KERN_DEBUG \"qla1280_isr(): index %i \"\n\t\t\t       \"asynchronous BUS_RESET\\n\", index);\n\t\t\tbreak;\n\n\t\tcase MBA_SYSTEM_ERR:\t \n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"qla1280: ISP System Error - mbx1=%xh, mbx2=\"\n\t\t\t       \"%xh, mbx3=%xh\\n\", mailbox[1], mailbox[2],\n\t\t\t       mailbox[3]);\n\t\t\tbreak;\n\n\t\tcase MBA_REQ_TRANSFER_ERR:\t \n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"qla1280: ISP Request Transfer Error\\n\");\n\t\t\tbreak;\n\n\t\tcase MBA_RSP_TRANSFER_ERR:\t \n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"qla1280: ISP Response Transfer Error\\n\");\n\t\t\tbreak;\n\n\t\tcase MBA_WAKEUP_THRES:\t \n\t\t\tdprintk(2, \"qla1280_isr: asynchronous WAKEUP_THRES\\n\");\n\t\t\tbreak;\n\n\t\tcase MBA_TIMEOUT_RESET:\t \n\t\t\tdprintk(2,\n\t\t\t\t\"qla1280_isr: asynchronous TIMEOUT_RESET\\n\");\n\t\t\tbreak;\n\n\t\tcase MBA_DEVICE_RESET:\t \n\t\t\tprintk(KERN_INFO \"qla1280_isr(): asynchronous \"\n\t\t\t       \"BUS_DEVICE_RESET\\n\");\n\n\t\t\tha->flags.reset_marker = 1;\n\t\t\tindex = mailbox[6] & BIT_0;\n\t\t\tha->bus_settings[index].reset_marker = 1;\n\t\t\tbreak;\n\n\t\tcase MBA_BUS_MODE_CHANGE:\n\t\t\tdprintk(2,\n\t\t\t\t\"qla1280_isr: asynchronous BUS_MODE_CHANGE\\n\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tif (mailbox[0] < MBA_ASYNC_EVENT) {\n\t\t\t\twptr = &mailbox[0];\n\t\t\t\tmemcpy((uint16_t *) ha->mailbox_out, wptr,\n\t\t\t\t       MAILBOX_REGISTER_COUNT *\n\t\t\t\t       sizeof(uint16_t));\n\n\t\t\t\tif(ha->mailbox_wait != NULL)\n\t\t\t\t\tcomplete(ha->mailbox_wait);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tWRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);\n\t}\n\n\t \n\tif (!(ha->flags.online && !ha->mailbox_wait)) {\n\t\tdprintk(2, \"qla1280_isr: Response pointer Error\\n\");\n\t\tgoto out;\n\t}\n\n\tif (mailbox[5] >= RESPONSE_ENTRY_CNT)\n\t\tgoto out;\n\n\twhile (ha->rsp_ring_index != mailbox[5]) {\n\t\tpkt = ha->response_ring_ptr;\n\n\t\tdprintk(5, \"qla1280_isr: ha->rsp_ring_index = 0x%x, mailbox[5]\"\n\t\t\t\" = 0x%x\\n\", ha->rsp_ring_index, mailbox[5]);\n\t\tdprintk(5,\"qla1280_isr: response packet data\\n\");\n\t\tqla1280_dump_buffer(5, (char *)pkt, RESPONSE_ENTRY_SIZE);\n\n\t\tif (pkt->entry_type == STATUS_TYPE) {\n\t\t\tif ((le16_to_cpu(pkt->scsi_status) & 0xff)\n\t\t\t    || pkt->comp_status || pkt->entry_status) {\n\t\t\t\tdprintk(2, \"qla1280_isr: ha->rsp_ring_index = \"\n\t\t\t\t\t\"0x%x mailbox[5] = 0x%x, comp_status \"\n\t\t\t\t\t\"= 0x%x, scsi_status = 0x%x\\n\",\n\t\t\t\t\tha->rsp_ring_index, mailbox[5],\n\t\t\t\t\tle16_to_cpu(pkt->comp_status),\n\t\t\t\t\tle16_to_cpu(pkt->scsi_status));\n\t\t\t}\n\t\t} else {\n\t\t\tdprintk(2, \"qla1280_isr: ha->rsp_ring_index = \"\n\t\t\t\t\"0x%x, mailbox[5] = 0x%x\\n\",\n\t\t\t\tha->rsp_ring_index, mailbox[5]);\n\t\t\tdprintk(2, \"qla1280_isr: response packet data\\n\");\n\t\t\tqla1280_dump_buffer(2, (char *)pkt,\n\t\t\t\t\t    RESPONSE_ENTRY_SIZE);\n\t\t}\n\n\t\tif (pkt->entry_type == STATUS_TYPE || pkt->entry_status) {\n\t\t\tdprintk(2, \"status: Cmd %p, handle %i\\n\",\n\t\t\t\tha->outstanding_cmds[pkt->handle]->cmd,\n\t\t\t\tpkt->handle);\n\t\t\tif (pkt->entry_type == STATUS_TYPE)\n\t\t\t\tqla1280_status_entry(ha, pkt, done_q);\n\t\t\telse\n\t\t\t\tqla1280_error_entry(ha, pkt, done_q);\n\t\t\t \n\t\t\tha->rsp_ring_index++;\n\t\t\tif (ha->rsp_ring_index == RESPONSE_ENTRY_CNT) {\n\t\t\t\tha->rsp_ring_index = 0;\n\t\t\t\tha->response_ring_ptr =\tha->response_ring;\n\t\t\t} else\n\t\t\t\tha->response_ring_ptr++;\n\t\t\tWRT_REG_WORD(&reg->mailbox5, ha->rsp_ring_index);\n\t\t}\n\t}\n\t\n out:\n\tLEAVE(\"qla1280_isr\");\n}\n\n \nstatic void\nqla1280_rst_aen(struct scsi_qla_host *ha)\n{\n\tuint8_t bus;\n\n\tENTER(\"qla1280_rst_aen\");\n\n\tif (ha->flags.online && !ha->flags.reset_active &&\n\t    !ha->flags.abort_isp_active) {\n\t\tha->flags.reset_active = 1;\n\t\twhile (ha->flags.reset_marker) {\n\t\t\t \n\t\t\tha->flags.reset_marker = 0;\n\t\t\tfor (bus = 0; bus < ha->ports &&\n\t\t\t\t     !ha->flags.reset_marker; bus++) {\n\t\t\t\tif (ha->bus_settings[bus].reset_marker) {\n\t\t\t\t\tha->bus_settings[bus].reset_marker = 0;\n\t\t\t\t\tqla1280_marker(ha, bus, 0, 0,\n\t\t\t\t\t\t       MK_SYNC_ALL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tLEAVE(\"qla1280_rst_aen\");\n}\n\n\n \nstatic void\nqla1280_status_entry(struct scsi_qla_host *ha, struct response *pkt,\n\t\t     struct list_head *done_q)\n{\n\tint sense_sz;\n\tstruct srb *sp;\n\tstruct scsi_cmnd *cmd;\n\tuint32_t handle = le32_to_cpu(pkt->handle);\n\tuint16_t scsi_status = le16_to_cpu(pkt->scsi_status);\n\tuint16_t comp_status = le16_to_cpu(pkt->comp_status);\n\n\tENTER(\"qla1280_status_entry\");\n\n\t \n\tif (handle < MAX_OUTSTANDING_COMMANDS)\n\t\tsp = ha->outstanding_cmds[handle];\n\telse\n\t\tsp = NULL;\n\n\tif (!sp) {\n\t\tprintk(KERN_WARNING \"qla1280: Status Entry invalid handle\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tha->outstanding_cmds[handle] = NULL;\n\n\tcmd = sp->cmd;\n\n\tif (comp_status || scsi_status) {\n\t\tdprintk(3, \"scsi: comp_status = 0x%x, scsi_status = \"\n\t\t\t\"0x%x, handle = 0x%x\\n\", comp_status,\n\t\t\tscsi_status, handle);\n\t}\n\n\t \n\tif ((scsi_status & 0xFF) == SAM_STAT_TASK_SET_FULL ||\n\t    (scsi_status & 0xFF) == SAM_STAT_BUSY) {\n\t\tCMD_RESULT(cmd) = scsi_status & 0xff;\n\t} else {\n\n\t\t \n\t\tCMD_RESULT(cmd) = qla1280_return_status(pkt, cmd);\n\n\t\tif (scsi_status & SAM_STAT_CHECK_CONDITION) {\n\t\t\tif (comp_status != CS_ARS_FAILED) {\n\t\t\t\tuint16_t req_sense_length =\n\t\t\t\t\tle16_to_cpu(pkt->req_sense_length);\n\t\t\t\tif (req_sense_length < CMD_SNSLEN(cmd))\n\t\t\t\t\tsense_sz = req_sense_length;\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\tsense_sz = CMD_SNSLEN(cmd) - 1;\n\n\t\t\t\tmemcpy(cmd->sense_buffer,\n\t\t\t\t       &pkt->req_sense_data, sense_sz);\n\t\t\t} else\n\t\t\t\tsense_sz = 0;\n\t\t\tmemset(cmd->sense_buffer + sense_sz, 0,\n\t\t\t       SCSI_SENSE_BUFFERSIZE - sense_sz);\n\n\t\t\tdprintk(2, \"qla1280_status_entry: Check \"\n\t\t\t\t\"condition Sense data, b %i, t %i, \"\n\t\t\t\t\"l %i\\n\", SCSI_BUS_32(cmd), SCSI_TCN_32(cmd),\n\t\t\t\tSCSI_LUN_32(cmd));\n\t\t\tif (sense_sz)\n\t\t\t\tqla1280_dump_buffer(2,\n\t\t\t\t\t\t    (char *)cmd->sense_buffer,\n\t\t\t\t\t\t    sense_sz);\n\t\t}\n\t}\n\n\tCMD_HANDLE(sp->cmd) = COMPLETED_HANDLE;\n\n\t \n\tlist_add_tail(&sp->list, done_q);\n out:\n\tLEAVE(\"qla1280_status_entry\");\n}\n\n \nstatic void\nqla1280_error_entry(struct scsi_qla_host *ha, struct response *pkt,\n\t\t    struct list_head *done_q)\n{\n\tstruct srb *sp;\n\tuint32_t handle = le32_to_cpu(pkt->handle);\n\n\tENTER(\"qla1280_error_entry\");\n\n\tif (pkt->entry_status & BIT_3)\n\t\tdprintk(2, \"qla1280_error_entry: BAD PAYLOAD flag error\\n\");\n\telse if (pkt->entry_status & BIT_2)\n\t\tdprintk(2, \"qla1280_error_entry: BAD HEADER flag error\\n\");\n\telse if (pkt->entry_status & BIT_1)\n\t\tdprintk(2, \"qla1280_error_entry: FULL flag error\\n\");\n\telse\n\t\tdprintk(2, \"qla1280_error_entry: UNKNOWN flag error\\n\");\n\n\t \n\tif (handle < MAX_OUTSTANDING_COMMANDS)\n\t\tsp = ha->outstanding_cmds[handle];\n\telse\n\t\tsp = NULL;\n\n\tif (sp) {\n\t\t \n\t\tha->outstanding_cmds[handle] = NULL;\n\n\t\t \n\t\tif (pkt->entry_status & (BIT_3 + BIT_2)) {\n\t\t\t \n\t\t\t \n\t\t\tCMD_RESULT(sp->cmd) = DID_ERROR << 16;\n\t\t} else if (pkt->entry_status & BIT_1) {\t \n\t\t\tCMD_RESULT(sp->cmd) = DID_BUS_BUSY << 16;\n\t\t} else {\n\t\t\t \n\t\t\tCMD_RESULT(sp->cmd) = DID_ERROR << 16;\n\t\t}\n\n\t\tCMD_HANDLE(sp->cmd) = COMPLETED_HANDLE;\n\n\t\t \n\t\tlist_add_tail(&sp->list, done_q);\n\t}\n#ifdef QLA_64BIT_PTR\n\telse if (pkt->entry_type == COMMAND_A64_TYPE) {\n\t\tprintk(KERN_WARNING \"!qla1280: Error Entry invalid handle\");\n\t}\n#endif\n\n\tLEAVE(\"qla1280_error_entry\");\n}\n\n \nstatic int\nqla1280_abort_isp(struct scsi_qla_host *ha)\n{\n\tstruct device_reg __iomem *reg = ha->iobase;\n\tstruct srb *sp;\n\tint status = 0;\n\tint cnt;\n\tint bus;\n\n\tENTER(\"qla1280_abort_isp\");\n\n\tif (ha->flags.abort_isp_active || !ha->flags.online)\n\t\tgoto out;\n\t\n\tha->flags.abort_isp_active = 1;\n\n\t \n\tqla1280_disable_intrs(ha);\n\tWRT_REG_WORD(&reg->host_cmd, HC_PAUSE_RISC);\n\tRD_REG_WORD(&reg->id_l);\n\n\tprintk(KERN_INFO \"scsi(%li): dequeuing outstanding commands\\n\",\n\t       ha->host_no);\n\t \n\tfor (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS; cnt++) {\n\t\tstruct scsi_cmnd *cmd;\n\t\tsp = ha->outstanding_cmds[cnt];\n\t\tif (sp) {\n\t\t\tcmd = sp->cmd;\n\t\t\tCMD_RESULT(cmd) = DID_RESET << 16;\n\t\t\tCMD_HANDLE(cmd) = COMPLETED_HANDLE;\n\t\t\tha->outstanding_cmds[cnt] = NULL;\n\t\t\tlist_add_tail(&sp->list, &ha->done_q);\n\t\t}\n\t}\n\n\tqla1280_done(ha);\n\n\tstatus = qla1280_load_firmware(ha);\n\tif (status)\n\t\tgoto out;\n\n\t \n\tqla1280_nvram_config (ha);\n\n\tstatus = qla1280_init_rings(ha);\n\tif (status)\n\t\tgoto out;\n\t\t\n\t \n\tfor (bus = 0; bus < ha->ports; bus++)\n\t\tqla1280_bus_reset(ha, bus);\n\t\t\n\tha->flags.abort_isp_active = 0;\n out:\n\tif (status) {\n\t\tprintk(KERN_WARNING\n\t\t       \"qla1280: ISP error recovery failed, board disabled\");\n\t\tqla1280_reset_adapter(ha);\n\t\tdprintk(2, \"qla1280_abort_isp: **** FAILED ****\\n\");\n\t}\n\n\tLEAVE(\"qla1280_abort_isp\");\n\treturn status;\n}\n\n\n \nstatic u16\nqla1280_debounce_register(volatile u16 __iomem * addr)\n{\n\tvolatile u16 ret;\n\tvolatile u16 ret2;\n\n\tret = RD_REG_WORD(addr);\n\tret2 = RD_REG_WORD(addr);\n\n\tif (ret == ret2)\n\t\treturn ret;\n\n\tdo {\n\t\tcpu_relax();\n\t\tret = RD_REG_WORD(addr);\n\t\tret2 = RD_REG_WORD(addr);\n\t} while (ret != ret2);\n\n\treturn ret;\n}\n\n\n \n#define SET_SXP_BANK            0x0100\n#define SCSI_PHASE_INVALID      0x87FF\nstatic int\nqla1280_check_for_dead_scsi_bus(struct scsi_qla_host *ha, unsigned int bus)\n{\n\tuint16_t config_reg, scsi_control;\n\tstruct device_reg __iomem *reg = ha->iobase;\n\n\tif (ha->bus_settings[bus].scsi_bus_dead) {\n\t\tWRT_REG_WORD(&reg->host_cmd, HC_PAUSE_RISC);\n\t\tconfig_reg = RD_REG_WORD(&reg->cfg_1);\n\t\tWRT_REG_WORD(&reg->cfg_1, SET_SXP_BANK);\n\t\tscsi_control = RD_REG_WORD(&reg->scsiControlPins);\n\t\tWRT_REG_WORD(&reg->cfg_1, config_reg);\n\t\tWRT_REG_WORD(&reg->host_cmd, HC_RELEASE_RISC);\n\n\t\tif (scsi_control == SCSI_PHASE_INVALID) {\n\t\t\tha->bus_settings[bus].scsi_bus_dead = 1;\n\t\t\treturn 1;\t \n\t\t} else {\n\t\t\tha->bus_settings[bus].scsi_bus_dead = 0;\n\t\t\tha->bus_settings[bus].failed_reset_count = 0;\n\t\t}\n\t}\n\treturn 0;\t\t \n}\n\nstatic void\nqla1280_get_target_parameters(struct scsi_qla_host *ha,\n\t\t\t      struct scsi_device *device)\n{\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tint bus, target, lun;\n\n\tbus = device->channel;\n\ttarget = device->id;\n\tlun = device->lun;\n\n\n\tmb[0] = MBC_GET_TARGET_PARAMETERS;\n\tmb[1] = (uint16_t) (bus ? target | BIT_7 : target);\n\tmb[1] <<= 8;\n\tqla1280_mailbox_command(ha, BIT_6 | BIT_3 | BIT_2 | BIT_1 | BIT_0,\n\t\t\t\t&mb[0]);\n\n\tprintk(KERN_INFO \"scsi(%li:%d:%d:%d):\", ha->host_no, bus, target, lun);\n\n\tif (mb[3] != 0) {\n\t\tprintk(KERN_CONT \" Sync: period %d, offset %d\",\n\t\t       (mb[3] & 0xff), (mb[3] >> 8));\n\t\tif (mb[2] & BIT_13)\n\t\t\tprintk(KERN_CONT \", Wide\");\n\t\tif ((mb[2] & BIT_5) && ((mb[6] >> 8) & 0xff) >= 2)\n\t\t\tprintk(KERN_CONT \", DT\");\n\t} else\n\t\tprintk(KERN_CONT \" Async\");\n\n\tif (device->simple_tags)\n\t\tprintk(KERN_CONT \", Tagged queuing: depth %d\", device->queue_depth);\n\tprintk(KERN_CONT \"\\n\");\n}\n\n\n#if DEBUG_QLA1280\nstatic void\n__qla1280_dump_buffer(char *b, int size)\n{\n\tint cnt;\n\tu8 c;\n\n\tprintk(KERN_DEBUG \" 0   1   2   3   4   5   6   7   8   9   Ah  \"\n\t       \"Bh  Ch  Dh  Eh  Fh\\n\");\n\tprintk(KERN_DEBUG \"---------------------------------------------\"\n\t       \"------------------\\n\");\n\n\tfor (cnt = 0; cnt < size;) {\n\t\tc = *b++;\n\n\t\tprintk(\"0x%02x\", c);\n\t\tcnt++;\n\t\tif (!(cnt % 16))\n\t\t\tprintk(\"\\n\");\n\t\telse\n\t\t\tprintk(\" \");\n\t}\n\tif (cnt % 16)\n\t\tprintk(\"\\n\");\n}\n\n \nstatic void\n__qla1280_print_scsi_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_qla_host *ha;\n\tstruct Scsi_Host *host = CMD_HOST(cmd);\n\tstruct srb *sp;\n\t \n\n\tint i;\n\tha = (struct scsi_qla_host *)host->hostdata;\n\n\tsp = scsi_cmd_priv(cmd);\n\tprintk(\"SCSI Command @= 0x%p, Handle=0x%p\\n\", cmd, CMD_HANDLE(cmd));\n\tprintk(\"  chan=%d, target = 0x%02x, lun = 0x%02x, cmd_len = 0x%02x\\n\",\n\t       SCSI_BUS_32(cmd), SCSI_TCN_32(cmd), SCSI_LUN_32(cmd),\n\t       CMD_CDBLEN(cmd));\n\tprintk(\" CDB = \");\n\tfor (i = 0; i < cmd->cmd_len; i++) {\n\t\tprintk(\"0x%02x \", cmd->cmnd[i]);\n\t}\n\tprintk(\"  seg_cnt =%d\\n\", scsi_sg_count(cmd));\n\tprintk(\"  request buffer=0x%p, request buffer len=0x%x\\n\",\n\t       scsi_sglist(cmd), scsi_bufflen(cmd));\n\t \n\tprintk(\"  tag=%d, transfersize=0x%x \\n\",\n\t       scsi_cmd_to_rq(cmd)->tag, cmd->transfersize);\n\tprintk(\" underflow size = 0x%x, direction=0x%x\\n\",\n\t       cmd->underflow, cmd->sc_data_direction);\n}\n\n \nstatic void\nql1280_dump_device(struct scsi_qla_host *ha)\n{\n\n\tstruct scsi_cmnd *cp;\n\tstruct srb *sp;\n\tint i;\n\n\tprintk(KERN_DEBUG \"Outstanding Commands on controller:\\n\");\n\n\tfor (i = 0; i < MAX_OUTSTANDING_COMMANDS; i++) {\n\t\tif ((sp = ha->outstanding_cmds[i]) == NULL)\n\t\t\tcontinue;\n\t\tif ((cp = sp->cmd) == NULL)\n\t\t\tcontinue;\n\t\tqla1280_print_scsi_cmd(1, cp);\n\t}\n}\n#endif\n\n\nenum tokens {\n\tTOKEN_NVRAM,\n\tTOKEN_SYNC,\n\tTOKEN_WIDE,\n\tTOKEN_PPR,\n\tTOKEN_VERBOSE,\n\tTOKEN_DEBUG,\n};\n\nstruct setup_tokens {\n\tchar *token;\n\tint val;\n};\n\nstatic struct setup_tokens setup_token[] __initdata = \n{\n\t{ \"nvram\", TOKEN_NVRAM },\n\t{ \"sync\", TOKEN_SYNC },\n\t{ \"wide\", TOKEN_WIDE },\n\t{ \"ppr\", TOKEN_PPR },\n\t{ \"verbose\", TOKEN_VERBOSE },\n\t{ \"debug\", TOKEN_DEBUG },\n};\n\n\n \nstatic int __init\nqla1280_setup(char *s)\n{\n\tchar *cp, *ptr;\n\tunsigned long val;\n\n\tcp = s;\n\n\twhile (cp && (ptr = strchr(cp, ':'))) {\n\t\tptr++;\n\t\tif (!strcmp(ptr, \"yes\")) {\n\t\t\tval = 0x10000;\n\t\t\tptr += 3;\n\t\t} else if (!strcmp(ptr, \"no\")) {\n \t\t\tval = 0;\n\t\t\tptr += 2;\n\t\t} else\n\t\t\tval = simple_strtoul(ptr, &ptr, 0);\n\n\t\tswitch (qla1280_get_token(cp)) {\n\t\tcase TOKEN_NVRAM:\n\t\t\tif (!val)\n\t\t\t\tdriver_setup.no_nvram = 1;\n\t\t\tbreak;\n\t\tcase TOKEN_SYNC:\n\t\t\tif (!val)\n\t\t\t\tdriver_setup.no_sync = 1;\n\t\t\telse if (val != 0x10000)\n\t\t\t\tdriver_setup.sync_mask = val;\n\t\t\tbreak;\n\t\tcase TOKEN_WIDE:\n\t\t\tif (!val)\n\t\t\t\tdriver_setup.no_wide = 1;\n\t\t\telse if (val != 0x10000)\n\t\t\t\tdriver_setup.wide_mask = val;\n\t\t\tbreak;\n\t\tcase TOKEN_PPR:\n\t\t\tif (!val)\n\t\t\t\tdriver_setup.no_ppr = 1;\n\t\t\telse if (val != 0x10000)\n\t\t\t\tdriver_setup.ppr_mask = val;\n\t\t\tbreak;\n\t\tcase TOKEN_VERBOSE:\n\t\t\tqla1280_verbose = val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_INFO \"qla1280: unknown boot option %s\\n\",\n\t\t\t       cp);\n\t\t}\n\n\t\tcp = strchr(ptr, ';');\n\t\tif (cp)\n\t\t\tcp++;\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 1;\n}\n\n\nstatic int __init\nqla1280_get_token(char *str)\n{\n\tchar *sep;\n\tlong ret = -1;\n\tint i;\n\n\tsep = strchr(str, ':');\n\n\tif (sep) {\n\t\tfor (i = 0; i < ARRAY_SIZE(setup_token); i++) {\n\t\t\tif (!strncmp(setup_token[i].token, str, (sep - str))) {\n\t\t\t\tret =  setup_token[i].val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nstatic const struct scsi_host_template qla1280_driver_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.proc_name\t\t= \"qla1280\",\n\t.name\t\t\t= \"Qlogic ISP 1280/12160\",\n\t.info\t\t\t= qla1280_info,\n\t.slave_configure\t= qla1280_slave_configure,\n\t.queuecommand\t\t= qla1280_queuecommand,\n\t.eh_abort_handler\t= qla1280_eh_abort,\n\t.eh_device_reset_handler= qla1280_eh_device_reset,\n\t.eh_bus_reset_handler\t= qla1280_eh_bus_reset,\n\t.eh_host_reset_handler\t= qla1280_eh_adapter_reset,\n\t.bios_param\t\t= qla1280_biosparam,\n\t.can_queue\t\t= MAX_OUTSTANDING_COMMANDS,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.cmd_size\t\t= sizeof(struct srb),\n};\n\n\nstatic int\nqla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint devnum = id->driver_data;\n\tstruct qla_boards *bdp = &ql1280_board_tbl[devnum];\n\tstruct Scsi_Host *host;\n\tstruct scsi_qla_host *ha;\n\tint error = -ENODEV;\n\n\t \n\tif (pdev->subsystem_vendor == PCI_VENDOR_ID_AMI) {\n\t\tprintk(KERN_INFO\n\t\t       \"qla1280: Skipping AMI SubSys Vendor ID Chip\\n\");\n\t\tgoto error;\n\t}\n\n\tprintk(KERN_INFO \"qla1280: %s found on PCI bus %i, dev %i\\n\",\n\t       bdp->name, pdev->bus->number, PCI_SLOT(pdev->devfn));\n\t\n\tif (pci_enable_device(pdev)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"qla1280: Failed to enabled pci device, aborting.\\n\");\n\t\tgoto error;\n\t}\n\n\tpci_set_master(pdev);\n\n\terror = -ENOMEM;\n\thost = scsi_host_alloc(&qla1280_driver_template, sizeof(*ha));\n\tif (!host) {\n\t\tprintk(KERN_WARNING\n\t\t       \"qla1280: Failed to register host, aborting.\\n\");\n\t\tgoto error_disable_device;\n\t}\n\n\tha = (struct scsi_qla_host *)host->hostdata;\n\tmemset(ha, 0, sizeof(struct scsi_qla_host));\n\n\tha->pdev = pdev;\n\tha->devnum = devnum;\t \n\n#ifdef QLA_64BIT_PTR\n\tif (dma_set_mask_and_coherent(&ha->pdev->dev, DMA_BIT_MASK(64))) {\n\t\tif (dma_set_mask(&ha->pdev->dev, DMA_BIT_MASK(32))) {\n\t\t\tprintk(KERN_WARNING \"scsi(%li): Unable to set a \"\n\t\t\t       \"suitable DMA mask - aborting\\n\", ha->host_no);\n\t\t\terror = -ENODEV;\n\t\t\tgoto error_put_host;\n\t\t}\n\t} else\n\t\tdprintk(2, \"scsi(%li): 64 Bit PCI Addressing Enabled\\n\",\n\t\t\tha->host_no);\n#else\n\tif (dma_set_mask(&ha->pdev->dev, DMA_BIT_MASK(32))) {\n\t\tprintk(KERN_WARNING \"scsi(%li): Unable to set a \"\n\t\t       \"suitable DMA mask - aborting\\n\", ha->host_no);\n\t\terror = -ENODEV;\n\t\tgoto error_put_host;\n\t}\n#endif\n\n\tha->request_ring = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t((REQUEST_ENTRY_CNT + 1) * sizeof(request_t)),\n\t\t\t&ha->request_dma, GFP_KERNEL);\n\tif (!ha->request_ring) {\n\t\tprintk(KERN_INFO \"qla1280: Failed to get request memory\\n\");\n\t\tgoto error_put_host;\n\t}\n\n\tha->response_ring = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t((RESPONSE_ENTRY_CNT + 1) * sizeof(struct response)),\n\t\t\t&ha->response_dma, GFP_KERNEL);\n\tif (!ha->response_ring) {\n\t\tprintk(KERN_INFO \"qla1280: Failed to get response memory\\n\");\n\t\tgoto error_free_request_ring;\n\t}\n\n\tha->ports = bdp->numPorts;\n\n\tha->host = host;\n\tha->host_no = host->host_no;\n\n\thost->irq = pdev->irq;\n\thost->max_channel = bdp->numPorts - 1;\n\thost->max_lun = MAX_LUNS - 1;\n\thost->max_id = MAX_TARGETS;\n\thost->max_sectors = 1024;\n\thost->unique_id = host->host_no;\n\n\terror = -ENODEV;\n\n#if MEMORY_MAPPED_IO\n\tha->mmpbase = pci_ioremap_bar(ha->pdev, 1);\n\tif (!ha->mmpbase) {\n\t\tprintk(KERN_INFO \"qla1280: Unable to map I/O memory\\n\");\n\t\tgoto error_free_response_ring;\n\t}\n\n\thost->base = (unsigned long)ha->mmpbase;\n\tha->iobase = (struct device_reg __iomem *)ha->mmpbase;\n#else\n\thost->io_port = pci_resource_start(ha->pdev, 0);\n\tif (!request_region(host->io_port, 0xff, \"qla1280\")) {\n\t\tprintk(KERN_INFO \"qla1280: Failed to reserve i/o region \"\n\t\t\t\t \"0x%04lx-0x%04lx - already in use\\n\",\n\t\t       host->io_port, host->io_port + 0xff);\n\t\tgoto error_free_response_ring;\n\t}\n\n\tha->iobase = (struct device_reg *)host->io_port;\n#endif\n\n\tINIT_LIST_HEAD(&ha->done_q);\n\n\t \n\tqla1280_disable_intrs(ha);\n\n\tif (request_irq(pdev->irq, qla1280_intr_handler, IRQF_SHARED,\n\t\t\t\t\"qla1280\", ha)) {\n\t\tprintk(\"qla1280 : Failed to reserve interrupt %d already \"\n\t\t       \"in use\\n\", pdev->irq);\n\t\tgoto error_release_region;\n\t}\n\n\t \n\tif (qla1280_initialize_adapter(ha)) {\n\t\tprintk(KERN_INFO \"qla1x160: Failed to initialize adapter\\n\");\n\t\tgoto error_free_irq;\n\t}\n\n\t \n\thost->this_id = ha->bus_settings[0].id;\n\n\tpci_set_drvdata(pdev, host);\n\n\terror = scsi_add_host(host, &pdev->dev);\n\tif (error)\n\t\tgoto error_disable_adapter;\n\tscsi_scan_host(host);\n\n\treturn 0;\n\n error_disable_adapter:\n\tqla1280_disable_intrs(ha);\n error_free_irq:\n\tfree_irq(pdev->irq, ha);\n error_release_region:\n#if MEMORY_MAPPED_IO\n\tiounmap(ha->mmpbase);\n#else\n\trelease_region(host->io_port, 0xff);\n#endif\n error_free_response_ring:\n\tdma_free_coherent(&ha->pdev->dev,\n\t\t\t((RESPONSE_ENTRY_CNT + 1) * sizeof(struct response)),\n\t\t\tha->response_ring, ha->response_dma);\n error_free_request_ring:\n\tdma_free_coherent(&ha->pdev->dev,\n\t\t\t((REQUEST_ENTRY_CNT + 1) * sizeof(request_t)),\n\t\t\tha->request_ring, ha->request_dma);\n error_put_host:\n\tscsi_host_put(host);\n error_disable_device:\n\tpci_disable_device(pdev);\n error:\n\treturn error;\n}\n\n\nstatic void\nqla1280_remove_one(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;\n\n\tscsi_remove_host(host);\n\n\tqla1280_disable_intrs(ha);\n\n\tfree_irq(pdev->irq, ha);\n\n#if MEMORY_MAPPED_IO\n\tiounmap(ha->mmpbase);\n#else\n\trelease_region(host->io_port, 0xff);\n#endif\n\n\tdma_free_coherent(&ha->pdev->dev,\n\t\t\t((REQUEST_ENTRY_CNT + 1) * (sizeof(request_t))),\n\t\t\tha->request_ring, ha->request_dma);\n\tdma_free_coherent(&ha->pdev->dev,\n\t\t\t((RESPONSE_ENTRY_CNT + 1) * (sizeof(struct response))),\n\t\t\tha->response_ring, ha->response_dma);\n\n\tpci_disable_device(pdev);\n\n\tscsi_host_put(host);\n}\n\nstatic struct pci_driver qla1280_pci_driver = {\n\t.name\t\t= \"qla1280\",\n\t.id_table\t= qla1280_pci_tbl,\n\t.probe\t\t= qla1280_probe_one,\n\t.remove\t\t= qla1280_remove_one,\n};\n\nstatic int __init\nqla1280_init(void)\n{\n#ifdef MODULE\n\t \n\tif (qla1280)\n\t\tqla1280_setup(qla1280);\n#endif\n\n\treturn pci_register_driver(&qla1280_pci_driver);\n}\n\nstatic void __exit\nqla1280_exit(void)\n{\n\tint i;\n\n\tpci_unregister_driver(&qla1280_pci_driver);\n\t \n\tfor (i = 0; i < QL_NUM_FW_IMAGES; i++) {\n\t\trelease_firmware(qla1280_fw_tbl[i].fw);\n\t\tqla1280_fw_tbl[i].fw = NULL;\n\t}\n}\n\nmodule_init(qla1280_init);\nmodule_exit(qla1280_exit);\n\nMODULE_AUTHOR(\"Qlogic & Jes Sorensen\");\nMODULE_DESCRIPTION(\"Qlogic ISP SCSI (qla1x80/qla1x160) driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"qlogic/1040.bin\");\nMODULE_FIRMWARE(\"qlogic/1280.bin\");\nMODULE_FIRMWARE(\"qlogic/12160.bin\");\nMODULE_VERSION(QLA1280_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}