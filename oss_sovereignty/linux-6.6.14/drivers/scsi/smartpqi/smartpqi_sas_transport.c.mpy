{
  "module_name": "smartpqi_sas_transport.c",
  "hash_id": "e90961d1cf7de26f03807e7f4373e104d0fc4cbd24e68df46796cf5d3b7a7480",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/smartpqi/smartpqi_sas_transport.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/bsg-lib.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_transport_sas.h>\n#include <asm/unaligned.h>\n#include \"smartpqi.h\"\n\nstatic struct pqi_sas_phy *pqi_alloc_sas_phy(struct pqi_sas_port *pqi_sas_port)\n{\n\tstruct pqi_sas_phy *pqi_sas_phy;\n\tstruct sas_phy *phy;\n\n\tpqi_sas_phy = kzalloc(sizeof(*pqi_sas_phy), GFP_KERNEL);\n\tif (!pqi_sas_phy)\n\t\treturn NULL;\n\n\tphy = sas_phy_alloc(pqi_sas_port->parent_node->parent_dev,\n\t\tpqi_sas_port->next_phy_index);\n\tif (!phy) {\n\t\tkfree(pqi_sas_phy);\n\t\treturn NULL;\n\t}\n\n\tpqi_sas_port->next_phy_index++;\n\tpqi_sas_phy->phy = phy;\n\tpqi_sas_phy->parent_port = pqi_sas_port;\n\n\treturn pqi_sas_phy;\n}\n\nstatic void pqi_free_sas_phy(struct pqi_sas_phy *pqi_sas_phy)\n{\n\tstruct sas_phy *phy = pqi_sas_phy->phy;\n\n\tsas_port_delete_phy(pqi_sas_phy->parent_port->port, phy);\n\tif (pqi_sas_phy->added_to_port)\n\t\tlist_del(&pqi_sas_phy->phy_list_entry);\n\tsas_phy_delete(phy);\n\tkfree(pqi_sas_phy);\n}\n\nstatic int pqi_sas_port_add_phy(struct pqi_sas_phy *pqi_sas_phy)\n{\n\tint rc;\n\tstruct pqi_sas_port *pqi_sas_port;\n\tstruct sas_phy *phy;\n\tstruct sas_identify *identify;\n\n\tpqi_sas_port = pqi_sas_phy->parent_port;\n\tphy = pqi_sas_phy->phy;\n\n\tidentify = &phy->identify;\n\tmemset(identify, 0, sizeof(*identify));\n\tidentify->sas_address = pqi_sas_port->sas_address;\n\tidentify->device_type = SAS_END_DEVICE;\n\tidentify->initiator_port_protocols = SAS_PROTOCOL_ALL;\n\tidentify->target_port_protocols = SAS_PROTOCOL_ALL;\n\tphy->minimum_linkrate_hw = SAS_LINK_RATE_UNKNOWN;\n\tphy->maximum_linkrate_hw = SAS_LINK_RATE_UNKNOWN;\n\tphy->minimum_linkrate = SAS_LINK_RATE_UNKNOWN;\n\tphy->maximum_linkrate = SAS_LINK_RATE_UNKNOWN;\n\tphy->negotiated_linkrate = SAS_LINK_RATE_UNKNOWN;\n\n\trc = sas_phy_add(pqi_sas_phy->phy);\n\tif (rc)\n\t\treturn rc;\n\n\tsas_port_add_phy(pqi_sas_port->port, pqi_sas_phy->phy);\n\tlist_add_tail(&pqi_sas_phy->phy_list_entry,\n\t\t&pqi_sas_port->phy_list_head);\n\tpqi_sas_phy->added_to_port = true;\n\n\treturn 0;\n}\n\nstatic int pqi_sas_port_add_rphy(struct pqi_sas_port *pqi_sas_port,\n\tstruct sas_rphy *rphy)\n{\n\tstruct sas_identify *identify;\n\n\tidentify = &rphy->identify;\n\tidentify->sas_address = pqi_sas_port->sas_address;\n\tidentify->phy_identifier = pqi_sas_port->device->phy_id;\n\n\tidentify->initiator_port_protocols = SAS_PROTOCOL_ALL;\n\tidentify->target_port_protocols = SAS_PROTOCOL_STP;\n\n\tswitch (pqi_sas_port->device->device_type) {\n\tcase SA_DEVICE_TYPE_SAS:\n\tcase SA_DEVICE_TYPE_SES:\n\tcase SA_DEVICE_TYPE_NVME:\n\t\tidentify->target_port_protocols = SAS_PROTOCOL_SSP;\n\t\tbreak;\n\tcase SA_DEVICE_TYPE_EXPANDER_SMP:\n\t\tidentify->target_port_protocols = SAS_PROTOCOL_SMP;\n\t\tbreak;\n\tcase SA_DEVICE_TYPE_SATA:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn sas_rphy_add(rphy);\n}\n\nstatic struct sas_rphy *pqi_sas_rphy_alloc(struct pqi_sas_port *pqi_sas_port)\n{\n\tif (pqi_sas_port->device && pqi_sas_port->device->is_expander_smp_device)\n\t\treturn sas_expander_alloc(pqi_sas_port->port,\n\t\t\t\tSAS_FANOUT_EXPANDER_DEVICE);\n\n\treturn sas_end_device_alloc(pqi_sas_port->port);\n}\n\nstatic struct pqi_sas_port *pqi_alloc_sas_port(\n\tstruct pqi_sas_node *pqi_sas_node, u64 sas_address,\n\tstruct pqi_scsi_dev *device)\n{\n\tint rc;\n\tstruct pqi_sas_port *pqi_sas_port;\n\tstruct sas_port *port;\n\n\tpqi_sas_port = kzalloc(sizeof(*pqi_sas_port), GFP_KERNEL);\n\tif (!pqi_sas_port)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&pqi_sas_port->phy_list_head);\n\tpqi_sas_port->parent_node = pqi_sas_node;\n\n\tport = sas_port_alloc_num(pqi_sas_node->parent_dev);\n\tif (!port)\n\t\tgoto free_pqi_port;\n\n\trc = sas_port_add(port);\n\tif (rc)\n\t\tgoto free_sas_port;\n\n\tpqi_sas_port->port = port;\n\tpqi_sas_port->sas_address = sas_address;\n\tpqi_sas_port->device = device;\n\tlist_add_tail(&pqi_sas_port->port_list_entry,\n\t\t&pqi_sas_node->port_list_head);\n\n\treturn pqi_sas_port;\n\nfree_sas_port:\n\tsas_port_free(port);\nfree_pqi_port:\n\tkfree(pqi_sas_port);\n\n\treturn NULL;\n}\n\nstatic void pqi_free_sas_port(struct pqi_sas_port *pqi_sas_port)\n{\n\tstruct pqi_sas_phy *pqi_sas_phy;\n\tstruct pqi_sas_phy *next;\n\n\tlist_for_each_entry_safe(pqi_sas_phy, next,\n\t\t&pqi_sas_port->phy_list_head, phy_list_entry)\n\t\t\tpqi_free_sas_phy(pqi_sas_phy);\n\n\tsas_port_delete(pqi_sas_port->port);\n\tlist_del(&pqi_sas_port->port_list_entry);\n\tkfree(pqi_sas_port);\n}\n\nstatic struct pqi_sas_node *pqi_alloc_sas_node(struct device *parent_dev)\n{\n\tstruct pqi_sas_node *pqi_sas_node;\n\n\tpqi_sas_node = kzalloc(sizeof(*pqi_sas_node), GFP_KERNEL);\n\tif (pqi_sas_node) {\n\t\tpqi_sas_node->parent_dev = parent_dev;\n\t\tINIT_LIST_HEAD(&pqi_sas_node->port_list_head);\n\t}\n\n\treturn pqi_sas_node;\n}\n\nstatic void pqi_free_sas_node(struct pqi_sas_node *pqi_sas_node)\n{\n\tstruct pqi_sas_port *pqi_sas_port;\n\tstruct pqi_sas_port *next;\n\n\tif (!pqi_sas_node)\n\t\treturn;\n\n\tlist_for_each_entry_safe(pqi_sas_port, next,\n\t\t&pqi_sas_node->port_list_head, port_list_entry)\n\t\t\tpqi_free_sas_port(pqi_sas_port);\n\n\tkfree(pqi_sas_node);\n}\n\nstruct pqi_scsi_dev *pqi_find_device_by_sas_rphy(\n\tstruct pqi_ctrl_info *ctrl_info, struct sas_rphy *rphy)\n{\n\tstruct pqi_scsi_dev *device;\n\n\tlist_for_each_entry(device, &ctrl_info->scsi_device_list,\n\t\tscsi_device_list_entry) {\n\t\tif (!device->sas_port)\n\t\t\tcontinue;\n\t\tif (device->sas_port->rphy == rphy)\n\t\t\treturn device;\n\t}\n\n\treturn NULL;\n}\n\nint pqi_add_sas_host(struct Scsi_Host *shost, struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tstruct device *parent_dev;\n\tstruct pqi_sas_node *pqi_sas_node;\n\tstruct pqi_sas_port *pqi_sas_port;\n\tstruct pqi_sas_phy *pqi_sas_phy;\n\n\tparent_dev = &shost->shost_dev;\n\n\tpqi_sas_node = pqi_alloc_sas_node(parent_dev);\n\tif (!pqi_sas_node)\n\t\treturn -ENOMEM;\n\n\tpqi_sas_port = pqi_alloc_sas_port(pqi_sas_node,\n\t\tctrl_info->sas_address, NULL);\n\tif (!pqi_sas_port) {\n\t\trc = -ENODEV;\n\t\tgoto free_sas_node;\n\t}\n\n\tpqi_sas_phy = pqi_alloc_sas_phy(pqi_sas_port);\n\tif (!pqi_sas_phy) {\n\t\trc = -ENODEV;\n\t\tgoto free_sas_port;\n\t}\n\n\trc = pqi_sas_port_add_phy(pqi_sas_phy);\n\tif (rc)\n\t\tgoto free_sas_phy;\n\n\tctrl_info->sas_host = pqi_sas_node;\n\n\treturn 0;\n\nfree_sas_phy:\n\tpqi_free_sas_phy(pqi_sas_phy);\nfree_sas_port:\n\tpqi_free_sas_port(pqi_sas_port);\nfree_sas_node:\n\tpqi_free_sas_node(pqi_sas_node);\n\n\treturn rc;\n}\n\nvoid pqi_delete_sas_host(struct pqi_ctrl_info *ctrl_info)\n{\n\tpqi_free_sas_node(ctrl_info->sas_host);\n}\n\nint pqi_add_sas_device(struct pqi_sas_node *pqi_sas_node,\n\tstruct pqi_scsi_dev *device)\n{\n\tint rc;\n\tstruct pqi_sas_port *pqi_sas_port;\n\tstruct sas_rphy *rphy;\n\n\tpqi_sas_port = pqi_alloc_sas_port(pqi_sas_node,\n\t\tdevice->sas_address, device);\n\tif (!pqi_sas_port)\n\t\treturn -ENOMEM;\n\n\trphy = pqi_sas_rphy_alloc(pqi_sas_port);\n\tif (!rphy) {\n\t\trc = -ENODEV;\n\t\tgoto free_sas_port;\n\t}\n\n\tpqi_sas_port->rphy = rphy;\n\tdevice->sas_port = pqi_sas_port;\n\n\trc = pqi_sas_port_add_rphy(pqi_sas_port, rphy);\n\tif (rc)\n\t\tgoto free_sas_rphy;\n\n\treturn 0;\n\nfree_sas_rphy:\n\tsas_rphy_free(rphy);\nfree_sas_port:\n\tpqi_free_sas_port(pqi_sas_port);\n\tdevice->sas_port = NULL;\n\n\treturn rc;\n}\n\nvoid pqi_remove_sas_device(struct pqi_scsi_dev *device)\n{\n\tif (device->sas_port) {\n\t\tpqi_free_sas_port(device->sas_port);\n\t\tdevice->sas_port = NULL;\n\t}\n}\n\nstatic int pqi_sas_get_linkerrors(struct sas_phy *phy)\n{\n\treturn 0;\n}\n\nstatic int pqi_sas_get_enclosure_identifier(struct sas_rphy *rphy,\n\tu64 *identifier)\n{\n\tint rc;\n\tunsigned long flags;\n\tstruct Scsi_Host *shost;\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct pqi_scsi_dev *found_device;\n\tstruct pqi_scsi_dev *device;\n\n\tif (!rphy)\n\t\treturn -ENODEV;\n\n\tshost = rphy_to_shost(rphy);\n\tctrl_info = shost_to_hba(shost);\n\tspin_lock_irqsave(&ctrl_info->scsi_device_list_lock, flags);\n\tfound_device = pqi_find_device_by_sas_rphy(ctrl_info, rphy);\n\n\tif (!found_device) {\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (found_device->devtype == TYPE_ENCLOSURE) {\n\t\t*identifier = get_unaligned_be64(&found_device->wwid[8]);\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (found_device->box_index == 0xff ||\n\t\tfound_device->phys_box_on_bus == 0 ||\n\t\tfound_device->bay == 0xff) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(device, &ctrl_info->scsi_device_list,\n\t\tscsi_device_list_entry) {\n\t\tif (device->devtype == TYPE_ENCLOSURE &&\n\t\t\tdevice->box_index == found_device->box_index &&\n\t\t\tdevice->phys_box_on_bus ==\n\t\t\t\tfound_device->phys_box_on_bus &&\n\t\t\tmemcmp(device->phys_connector,\n\t\t\t\tfound_device->phys_connector, 2) == 0) {\n\t\t\t*identifier =\n\t\t\t\tget_unaligned_be64(&device->wwid[8]);\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (found_device->phy_connected_dev_type != SA_DEVICE_TYPE_CONTROLLER) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(device, &ctrl_info->scsi_device_list,\n\t\tscsi_device_list_entry) {\n\t\tif (device->devtype == TYPE_ENCLOSURE &&\n\t\t\tCISS_GET_DRIVE_NUMBER(device->scsi3addr) ==\n\t\t\t\tPQI_VSEP_CISS_BTL) {\n\t\t\t*identifier = get_unaligned_be64(&device->wwid[8]);\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = -EINVAL;\nout:\n\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\n\treturn rc;\n}\n\nstatic int pqi_sas_get_bay_identifier(struct sas_rphy *rphy)\n{\n\tint rc;\n\tunsigned long flags;\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct pqi_scsi_dev *device;\n\tstruct Scsi_Host *shost;\n\n\tif (!rphy)\n\t\treturn -ENODEV;\n\n\tshost = rphy_to_shost(rphy);\n\tctrl_info = shost_to_hba(shost);\n\tspin_lock_irqsave(&ctrl_info->scsi_device_list_lock, flags);\n\tdevice = pqi_find_device_by_sas_rphy(ctrl_info, rphy);\n\n\tif (!device) {\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (device->bay == 0xff)\n\t\trc = -EINVAL;\n\telse\n\t\trc = device->bay;\n\nout:\n\tspin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);\n\n\treturn rc;\n}\n\nstatic int pqi_sas_phy_reset(struct sas_phy *phy, int hard_reset)\n{\n\treturn 0;\n}\n\nstatic int pqi_sas_phy_enable(struct sas_phy *phy, int enable)\n{\n\treturn 0;\n}\n\nstatic int pqi_sas_phy_setup(struct sas_phy *phy)\n{\n\treturn 0;\n}\n\nstatic void pqi_sas_phy_release(struct sas_phy *phy)\n{\n}\n\nstatic int pqi_sas_phy_speed(struct sas_phy *phy,\n\tstruct sas_phy_linkrates *rates)\n{\n\treturn -EINVAL;\n}\n\n#define CSMI_IOCTL_TIMEOUT\t60\n#define SMP_CRC_FIELD_LENGTH\t4\n\nstatic struct bmic_csmi_smp_passthru_buffer *\npqi_build_csmi_smp_passthru_buffer(struct sas_rphy *rphy,\n\tstruct bsg_job *job)\n{\n\tstruct bmic_csmi_smp_passthru_buffer *smp_buf;\n\tstruct bmic_csmi_ioctl_header *ioctl_header;\n\tstruct bmic_csmi_smp_passthru *parameters;\n\tu32 req_size;\n\tu32 resp_size;\n\n\tsmp_buf = kzalloc(sizeof(*smp_buf), GFP_KERNEL);\n\tif (!smp_buf)\n\t\treturn NULL;\n\n\treq_size = job->request_payload.payload_len;\n\tresp_size = job->reply_payload.payload_len;\n\n\tioctl_header = &smp_buf->ioctl_header;\n\tput_unaligned_le32(sizeof(smp_buf->ioctl_header),\n\t\t&ioctl_header->header_length);\n\tput_unaligned_le32(CSMI_IOCTL_TIMEOUT, &ioctl_header->timeout);\n\tput_unaligned_le32(CSMI_CC_SAS_SMP_PASSTHRU,\n\t\t&ioctl_header->control_code);\n\tput_unaligned_le32(sizeof(smp_buf->parameters), &ioctl_header->length);\n\n\tparameters = &smp_buf->parameters;\n\tparameters->phy_identifier = rphy->identify.phy_identifier;\n\tparameters->port_identifier = 0;\n\tparameters->connection_rate = 0;\n\tput_unaligned_be64(rphy->identify.sas_address,\n\t\t&parameters->destination_sas_address);\n\n\tif (req_size > SMP_CRC_FIELD_LENGTH)\n\t\treq_size -= SMP_CRC_FIELD_LENGTH;\n\n\tput_unaligned_le32(req_size, &parameters->request_length);\n\tput_unaligned_le32(resp_size, &parameters->response_length);\n\n\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\tjob->reply_payload.sg_cnt, &parameters->request,\n\t\treq_size);\n\n\treturn smp_buf;\n}\n\nstatic unsigned int pqi_build_sas_smp_handler_reply(\n\tstruct bmic_csmi_smp_passthru_buffer *smp_buf, struct bsg_job *job,\n\tstruct pqi_raid_error_info *error_info)\n{\n\tsg_copy_from_buffer(job->reply_payload.sg_list,\n\t\tjob->reply_payload.sg_cnt, &smp_buf->parameters.response,\n\t\tle32_to_cpu(smp_buf->parameters.response_length));\n\n\tjob->reply_len = le16_to_cpu(error_info->sense_data_length);\n\tmemcpy(job->reply, error_info->data,\n\t\tle16_to_cpu(error_info->sense_data_length));\n\n\treturn job->reply_payload.payload_len -\n\t\tget_unaligned_le32(&error_info->data_in_transferred);\n}\n\nvoid pqi_sas_smp_handler(struct bsg_job *job, struct Scsi_Host *shost,\n\tstruct sas_rphy *rphy)\n{\n\tint rc;\n\tstruct pqi_ctrl_info *ctrl_info;\n\tstruct bmic_csmi_smp_passthru_buffer *smp_buf;\n\tstruct pqi_raid_error_info error_info;\n\tunsigned int reslen = 0;\n\n\tctrl_info = shost_to_hba(shost);\n\n\tif (job->reply_payload.payload_len == 0) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (!rphy) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (rphy->identify.device_type != SAS_FANOUT_EXPANDER_DEVICE) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (job->request_payload.sg_cnt > 1 || job->reply_payload.sg_cnt > 1) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsmp_buf = pqi_build_csmi_smp_passthru_buffer(rphy, job);\n\tif (!smp_buf) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = pqi_csmi_smp_passthru(ctrl_info, smp_buf, sizeof(*smp_buf),\n\t\t&error_info);\n\tif (rc)\n\t\tgoto out;\n\n\treslen = pqi_build_sas_smp_handler_reply(smp_buf, job, &error_info);\n\nout:\n\tbsg_job_done(job, rc, reslen);\n}\nstruct sas_function_template pqi_sas_transport_functions = {\n\t.get_linkerrors = pqi_sas_get_linkerrors,\n\t.get_enclosure_identifier = pqi_sas_get_enclosure_identifier,\n\t.get_bay_identifier = pqi_sas_get_bay_identifier,\n\t.phy_reset = pqi_sas_phy_reset,\n\t.phy_enable = pqi_sas_phy_enable,\n\t.phy_setup = pqi_sas_phy_setup,\n\t.phy_release = pqi_sas_phy_release,\n\t.set_phy_speed = pqi_sas_phy_speed,\n\t.smp_handler = pqi_sas_smp_handler,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}