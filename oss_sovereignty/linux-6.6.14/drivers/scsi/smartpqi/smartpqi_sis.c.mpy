{
  "module_name": "smartpqi_sis.c",
  "hash_id": "7528cc36045967ab3dc094df481ca9ed2b7b0a472b577fdcf8df041d897f2d38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/smartpqi/smartpqi_sis.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <scsi/scsi_device.h>\n#include <asm/unaligned.h>\n#include \"smartpqi.h\"\n#include \"smartpqi_sis.h\"\n\n \n#define SIS_CMD_GET_ADAPTER_PROPERTIES\t\t0x19\n#define SIS_CMD_INIT_BASE_STRUCT_ADDRESS\t0x1b\n#define SIS_CMD_GET_PQI_CAPABILITIES\t\t0x3000\n\n \n#define SIS_REENABLE_SIS_MODE\t\t\t0x1\n#define SIS_ENABLE_MSIX\t\t\t\t0x40\n#define SIS_ENABLE_INTX\t\t\t\t0x80\n#define SIS_SOFT_RESET\t\t\t\t0x100\n#define SIS_CMD_READY\t\t\t\t0x200\n#define SIS_TRIGGER_SHUTDOWN\t\t\t0x800000\n#define SIS_PQI_RESET_QUIESCE\t\t\t0x1000000\n\n#define SIS_CMD_COMPLETE\t\t\t0x1000\n#define SIS_CLEAR_CTRL_TO_HOST_DOORBELL\t\t0x1000\n\n#define SIS_CMD_STATUS_SUCCESS\t\t\t0x1\n#define SIS_CMD_COMPLETE_TIMEOUT_SECS\t\t30\n#define SIS_CMD_COMPLETE_POLL_INTERVAL_MSECS\t10\n\n \n#define SIS_EXTENDED_PROPERTIES_SUPPORTED\t0x800000\n#define SIS_SMARTARRAY_FEATURES_SUPPORTED\t0x2\n#define SIS_PQI_MODE_SUPPORTED\t\t\t0x4\n#define SIS_PQI_RESET_QUIESCE_SUPPORTED\t\t0x8\n#define SIS_REQUIRED_EXTENDED_PROPERTIES\t\\\n\t(SIS_SMARTARRAY_FEATURES_SUPPORTED | SIS_PQI_MODE_SUPPORTED)\n\n \n#define SIS_BASE_STRUCT_REVISION\t\t9\n#define SIS_BASE_STRUCT_ALIGNMENT\t\t16\n\n#define SIS_CTRL_KERNEL_FW_TRIAGE\t\t0x3\n#define SIS_CTRL_KERNEL_UP\t\t\t0x80\n#define SIS_CTRL_KERNEL_PANIC\t\t\t0x100\n#define SIS_CTRL_READY_TIMEOUT_SECS\t\t180\n#define SIS_CTRL_READY_RESUME_TIMEOUT_SECS\t90\n#define SIS_CTRL_READY_POLL_INTERVAL_MSECS\t10\n\nenum sis_fw_triage_status {\n\tFW_TRIAGE_NOT_STARTED = 0,\n\tFW_TRIAGE_STARTED,\n\tFW_TRIAGE_COND_INVALID,\n\tFW_TRIAGE_COMPLETED\n};\n\n#pragma pack(1)\n\n \nstruct sis_base_struct {\n\t__le32\trevision;\t\t \n\t__le32\tflags;\t\t\t \n\t__le32\terror_buffer_paddr_low;\t \n\t\t\t\t\t \n\t\t\t\t\t \n\t__le32\terror_buffer_paddr_high;\t \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\t__le32\terror_buffer_element_length;\t \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\t__le32\terror_buffer_num_elements;\t \n\t\t\t\t\t\t \n};\n\n#pragma pack()\n\nunsigned int sis_ctrl_ready_timeout_secs = SIS_CTRL_READY_TIMEOUT_SECS;\n\nstatic int sis_wait_for_ctrl_ready_with_timeout(struct pqi_ctrl_info *ctrl_info,\n\tunsigned int timeout_secs)\n{\n\tunsigned long timeout;\n\tu32 status;\n\n\ttimeout = (timeout_secs * HZ) + jiffies;\n\n\twhile (1) {\n\t\tstatus = readl(&ctrl_info->registers->sis_firmware_status);\n\t\tif (status != ~0) {\n\t\t\tif (status & SIS_CTRL_KERNEL_PANIC) {\n\t\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\t\"controller is offline: status code 0x%x\\n\",\n\t\t\t\t\treadl(\n\t\t\t\t\t&ctrl_info->registers->sis_mailbox[7]));\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tif (status & SIS_CTRL_KERNEL_UP)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"controller not ready after %u seconds\\n\",\n\t\t\t\ttimeout_secs);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(SIS_CTRL_READY_POLL_INTERVAL_MSECS);\n\t}\n\n\treturn 0;\n}\n\nint sis_wait_for_ctrl_ready(struct pqi_ctrl_info *ctrl_info)\n{\n\treturn sis_wait_for_ctrl_ready_with_timeout(ctrl_info,\n\t\tsis_ctrl_ready_timeout_secs);\n}\n\nint sis_wait_for_ctrl_ready_resume(struct pqi_ctrl_info *ctrl_info)\n{\n\treturn sis_wait_for_ctrl_ready_with_timeout(ctrl_info,\n\t\tSIS_CTRL_READY_RESUME_TIMEOUT_SECS);\n}\n\nbool sis_is_firmware_running(struct pqi_ctrl_info *ctrl_info)\n{\n\tbool running;\n\tu32 status;\n\n\tstatus = readl(&ctrl_info->registers->sis_firmware_status);\n\n\tif (status != ~0 && (status & SIS_CTRL_KERNEL_PANIC))\n\t\trunning = false;\n\telse\n\t\trunning = true;\n\n\tif (!running)\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"controller is offline: status code 0x%x\\n\",\n\t\t\treadl(&ctrl_info->registers->sis_mailbox[7]));\n\n\treturn running;\n}\n\nbool sis_is_kernel_up(struct pqi_ctrl_info *ctrl_info)\n{\n\treturn readl(&ctrl_info->registers->sis_firmware_status) &\n\t\tSIS_CTRL_KERNEL_UP;\n}\n\nu32 sis_get_product_id(struct pqi_ctrl_info *ctrl_info)\n{\n\treturn readl(&ctrl_info->registers->sis_product_identifier);\n}\n\n \nstruct sis_sync_cmd_params {\n\tu32\tmailbox[6];\t \n};\n\nstatic int sis_send_sync_cmd(struct pqi_ctrl_info *ctrl_info,\n\tu32 cmd, struct sis_sync_cmd_params *params)\n{\n\tstruct pqi_ctrl_registers __iomem *registers;\n\tunsigned int i;\n\tunsigned long timeout;\n\tu32 doorbell;\n\tu32 cmd_status;\n\n\tregisters = ctrl_info->registers;\n\n\t \n\twritel(cmd, &registers->sis_mailbox[0]);\n\n\t \n\tfor (i = 1; i <= 4; i++)\n\t\twritel(params->mailbox[i], &registers->sis_mailbox[i]);\n\n\t \n\twritel(SIS_CLEAR_CTRL_TO_HOST_DOORBELL,\n\t\t&registers->sis_ctrl_to_host_doorbell_clear);\n\n\t \n\twritel(~0, &registers->sis_interrupt_mask);\n\tusleep_range(1000, 2000);\n\n\t \n\treadl(&registers->sis_interrupt_mask);\n\n\t \n\twritel(SIS_CMD_READY, &registers->sis_host_to_ctrl_doorbell);\n\n\t \n\ttimeout = (SIS_CMD_COMPLETE_TIMEOUT_SECS * HZ) + jiffies;\n\twhile (1) {\n\t\tmsleep(SIS_CMD_COMPLETE_POLL_INTERVAL_MSECS);\n\t\tdoorbell = readl(&registers->sis_ctrl_to_host_doorbell);\n\t\tif (doorbell & SIS_CMD_COMPLETE)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tcmd_status = readl(&registers->sis_mailbox[0]);\n\tif (cmd_status != SIS_CMD_STATUS_SUCCESS) {\n\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\"SIS command failed for command 0x%x: status = 0x%x\\n\",\n\t\t\tcmd, cmd_status);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tparams->mailbox[0] = cmd_status;\n\tfor (i = 1; i < ARRAY_SIZE(params->mailbox); i++)\n\t\tparams->mailbox[i] = readl(&registers->sis_mailbox[i]);\n\n\treturn 0;\n}\n\n \n\nint sis_get_ctrl_properties(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tu32 properties;\n\tu32 extended_properties;\n\tstruct sis_sync_cmd_params params;\n\n\tmemset(&params, 0, sizeof(params));\n\n\trc = sis_send_sync_cmd(ctrl_info, SIS_CMD_GET_ADAPTER_PROPERTIES,\n\t\t&params);\n\tif (rc)\n\t\treturn rc;\n\n\tproperties = params.mailbox[1];\n\n\tif (!(properties & SIS_EXTENDED_PROPERTIES_SUPPORTED))\n\t\treturn -ENODEV;\n\n\textended_properties = params.mailbox[4];\n\n\tif ((extended_properties & SIS_REQUIRED_EXTENDED_PROPERTIES) !=\n\t\tSIS_REQUIRED_EXTENDED_PROPERTIES)\n\t\treturn -ENODEV;\n\n\tif (extended_properties & SIS_PQI_RESET_QUIESCE_SUPPORTED)\n\t\tctrl_info->pqi_reset_quiesce_supported = true;\n\n\treturn 0;\n}\n\nint sis_get_pqi_capabilities(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tstruct sis_sync_cmd_params params;\n\n\tmemset(&params, 0, sizeof(params));\n\n\trc = sis_send_sync_cmd(ctrl_info, SIS_CMD_GET_PQI_CAPABILITIES,\n\t\t&params);\n\tif (rc)\n\t\treturn rc;\n\n\tctrl_info->max_sg_entries = params.mailbox[1];\n\tctrl_info->max_transfer_size = params.mailbox[2];\n\tctrl_info->max_outstanding_requests = params.mailbox[3];\n\tctrl_info->config_table_offset = params.mailbox[4];\n\tctrl_info->config_table_length = params.mailbox[5];\n\n\treturn 0;\n}\n\nint sis_init_base_struct_addr(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tvoid *base_struct_unaligned;\n\tstruct sis_base_struct *base_struct;\n\tstruct sis_sync_cmd_params params;\n\tunsigned long error_buffer_paddr;\n\tdma_addr_t bus_address;\n\n\tbase_struct_unaligned = kzalloc(sizeof(*base_struct)\n\t\t+ SIS_BASE_STRUCT_ALIGNMENT - 1, GFP_KERNEL);\n\tif (!base_struct_unaligned)\n\t\treturn -ENOMEM;\n\n\tbase_struct = PTR_ALIGN(base_struct_unaligned,\n\t\tSIS_BASE_STRUCT_ALIGNMENT);\n\terror_buffer_paddr = (unsigned long)ctrl_info->error_buffer_dma_handle;\n\n\tput_unaligned_le32(SIS_BASE_STRUCT_REVISION, &base_struct->revision);\n\tput_unaligned_le32(lower_32_bits(error_buffer_paddr),\n\t\t&base_struct->error_buffer_paddr_low);\n\tput_unaligned_le32(upper_32_bits(error_buffer_paddr),\n\t\t&base_struct->error_buffer_paddr_high);\n\tput_unaligned_le32(PQI_ERROR_BUFFER_ELEMENT_LENGTH,\n\t\t&base_struct->error_buffer_element_length);\n\tput_unaligned_le32(ctrl_info->max_io_slots,\n\t\t&base_struct->error_buffer_num_elements);\n\n\tbus_address = dma_map_single(&ctrl_info->pci_dev->dev, base_struct,\n\t\tsizeof(*base_struct), DMA_TO_DEVICE);\n\tif (dma_mapping_error(&ctrl_info->pci_dev->dev, bus_address)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.mailbox[1] = lower_32_bits((u64)bus_address);\n\tparams.mailbox[2] = upper_32_bits((u64)bus_address);\n\tparams.mailbox[3] = sizeof(*base_struct);\n\n\trc = sis_send_sync_cmd(ctrl_info, SIS_CMD_INIT_BASE_STRUCT_ADDRESS,\n\t\t&params);\n\n\tdma_unmap_single(&ctrl_info->pci_dev->dev, bus_address,\n\t\t\tsizeof(*base_struct), DMA_TO_DEVICE);\nout:\n\tkfree(base_struct_unaligned);\n\n\treturn rc;\n}\n\n#define SIS_DOORBELL_BIT_CLEAR_TIMEOUT_SECS\t30\n\nstatic int sis_wait_for_doorbell_bit_to_clear(\n\tstruct pqi_ctrl_info *ctrl_info, u32 bit)\n{\n\tint rc = 0;\n\tu32 doorbell_register;\n\tunsigned long timeout;\n\n\ttimeout = (SIS_DOORBELL_BIT_CLEAR_TIMEOUT_SECS * HZ) + jiffies;\n\n\twhile (1) {\n\t\tdoorbell_register =\n\t\t\treadl(&ctrl_info->registers->sis_host_to_ctrl_doorbell);\n\t\tif ((doorbell_register & bit) == 0)\n\t\t\tbreak;\n\t\tif (readl(&ctrl_info->registers->sis_firmware_status) &\n\t\t\tSIS_CTRL_KERNEL_PANIC) {\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"doorbell register bit 0x%x not cleared\\n\",\n\t\t\t\tbit);\n\t\t\trc = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn rc;\n}\n\nstatic inline int sis_set_doorbell_bit(struct pqi_ctrl_info *ctrl_info, u32 bit)\n{\n\twritel(bit, &ctrl_info->registers->sis_host_to_ctrl_doorbell);\n\tusleep_range(1000, 2000);\n\n\treturn sis_wait_for_doorbell_bit_to_clear(ctrl_info, bit);\n}\n\nvoid sis_enable_msix(struct pqi_ctrl_info *ctrl_info)\n{\n\tsis_set_doorbell_bit(ctrl_info, SIS_ENABLE_MSIX);\n}\n\nvoid sis_enable_intx(struct pqi_ctrl_info *ctrl_info)\n{\n\tsis_set_doorbell_bit(ctrl_info, SIS_ENABLE_INTX);\n}\n\nvoid sis_shutdown_ctrl(struct pqi_ctrl_info *ctrl_info,\n\tenum pqi_ctrl_shutdown_reason ctrl_shutdown_reason)\n{\n\tif (readl(&ctrl_info->registers->sis_firmware_status) &\n\t\tSIS_CTRL_KERNEL_PANIC)\n\t\treturn;\n\n\tif (ctrl_info->firmware_triage_supported)\n\t\twritel(ctrl_shutdown_reason, &ctrl_info->registers->sis_ctrl_shutdown_reason_code);\n\n\twritel(SIS_TRIGGER_SHUTDOWN, &ctrl_info->registers->sis_host_to_ctrl_doorbell);\n}\n\nint sis_pqi_reset_quiesce(struct pqi_ctrl_info *ctrl_info)\n{\n\treturn sis_set_doorbell_bit(ctrl_info, SIS_PQI_RESET_QUIESCE);\n}\n\nint sis_reenable_sis_mode(struct pqi_ctrl_info *ctrl_info)\n{\n\treturn sis_set_doorbell_bit(ctrl_info, SIS_REENABLE_SIS_MODE);\n}\n\nvoid sis_write_driver_scratch(struct pqi_ctrl_info *ctrl_info, u32 value)\n{\n\twritel(value, &ctrl_info->registers->sis_driver_scratch);\n\tusleep_range(1000, 2000);\n}\n\nu32 sis_read_driver_scratch(struct pqi_ctrl_info *ctrl_info)\n{\n\treturn readl(&ctrl_info->registers->sis_driver_scratch);\n}\n\nstatic inline enum sis_fw_triage_status\n\tsis_read_firmware_triage_status(struct pqi_ctrl_info *ctrl_info)\n{\n\treturn ((enum sis_fw_triage_status)(readl(&ctrl_info->registers->sis_firmware_status) &\n\t\tSIS_CTRL_KERNEL_FW_TRIAGE));\n}\n\nvoid sis_soft_reset(struct pqi_ctrl_info *ctrl_info)\n{\n\twritel(SIS_SOFT_RESET,\n\t\t&ctrl_info->registers->sis_host_to_ctrl_doorbell);\n}\n\n#define SIS_FW_TRIAGE_STATUS_TIMEOUT_SECS\t\t300\n#define SIS_FW_TRIAGE_STATUS_POLL_INTERVAL_SECS\t\t1\n\nint sis_wait_for_fw_triage_completion(struct pqi_ctrl_info *ctrl_info)\n{\n\tint rc;\n\tenum sis_fw_triage_status status;\n\tunsigned long timeout;\n\n\ttimeout = (SIS_FW_TRIAGE_STATUS_TIMEOUT_SECS * HZ) + jiffies;\n\twhile (1) {\n\t\tstatus = sis_read_firmware_triage_status(ctrl_info);\n\t\tif (status == FW_TRIAGE_COND_INVALID) {\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"firmware triage condition invalid\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t} else if (status == FW_TRIAGE_NOT_STARTED ||\n\t\t\tstatus == FW_TRIAGE_COMPLETED) {\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&ctrl_info->pci_dev->dev,\n\t\t\t\t\"timed out waiting for firmware triage status\\n\");\n\t\t\trc = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\tssleep(SIS_FW_TRIAGE_STATUS_POLL_INTERVAL_SECS);\n\t}\n\n\treturn rc;\n}\n\nvoid sis_verify_structures(void)\n{\n\tBUILD_BUG_ON(offsetof(struct sis_base_struct,\n\t\trevision) != 0x0);\n\tBUILD_BUG_ON(offsetof(struct sis_base_struct,\n\t\tflags) != 0x4);\n\tBUILD_BUG_ON(offsetof(struct sis_base_struct,\n\t\terror_buffer_paddr_low) != 0x8);\n\tBUILD_BUG_ON(offsetof(struct sis_base_struct,\n\t\terror_buffer_paddr_high) != 0xc);\n\tBUILD_BUG_ON(offsetof(struct sis_base_struct,\n\t\terror_buffer_element_length) != 0x10);\n\tBUILD_BUG_ON(offsetof(struct sis_base_struct,\n\t\terror_buffer_num_elements) != 0x14);\n\tBUILD_BUG_ON(sizeof(struct sis_base_struct) != 0x18);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}