{
  "module_name": "raid_class.c",
  "hash_id": "ec6b09265607da2fe13c88d6e21196c0fce0eb8933dbae81195499b17e1d6c28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/raid_class.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/raid_class.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n\n#define RAID_NUM_ATTRS\t3\n\nstruct raid_internal {\n\tstruct raid_template r;\n\tstruct raid_function_template *f;\n\t \n\tstruct device_attribute private_attrs[RAID_NUM_ATTRS];\n\t \n\tstruct device_attribute *attrs[RAID_NUM_ATTRS + 1];\n};\n\nstruct raid_component {\n\tstruct list_head node;\n\tstruct device dev;\n\tint num;\n};\n\n#define to_raid_internal(tmpl)\tcontainer_of(tmpl, struct raid_internal, r)\n\n#define tc_to_raid_internal(tcont) ({\t\t\t\t\t\\\n\tstruct raid_template *r =\t\t\t\t\t\\\n\t\tcontainer_of(tcont, struct raid_template, raid_attrs);\t\\\n\tto_raid_internal(r);\t\t\t\t\t\t\\\n})\n\n#define ac_to_raid_internal(acont) ({\t\t\t\t\t\\\n\tstruct transport_container *tc =\t\t\t\t\\\n\t\tcontainer_of(acont, struct transport_container, ac);\t\\\n\ttc_to_raid_internal(tc);\t\t\t\t\t\\\n})\n\n#define device_to_raid_internal(dev) ({\t\t\t\t\\\n\tstruct attribute_container *ac =\t\t\t\t\\\n\t\tattribute_container_classdev_to_container(dev);\t\\\n\tac_to_raid_internal(ac);\t\t\t\t\t\\\n})\n\t\n\nstatic int raid_match(struct attribute_container *cont, struct device *dev)\n{\n\t \n\tstruct raid_internal *i = ac_to_raid_internal(cont);\n\n\tif (IS_ENABLED(CONFIG_SCSI) && scsi_is_sdev_device(dev)) {\n\t\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\t\tif (i->f->cookie != sdev->host->hostt)\n\t\t\treturn 0;\n\n\t\treturn i->f->is_raid(dev);\n\t}\n\t \n\treturn 0;\n}\n\nstatic int raid_setup(struct transport_container *tc, struct device *dev,\n\t\t       struct device *cdev)\n{\n\tstruct raid_data *rd;\n\n\tBUG_ON(dev_get_drvdata(cdev));\n\n\trd = kzalloc(sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&rd->component_list);\n\tdev_set_drvdata(cdev, rd);\n\t\t\n\treturn 0;\n}\n\nstatic int raid_remove(struct transport_container *tc, struct device *dev,\n\t\t       struct device *cdev)\n{\n\tstruct raid_data *rd = dev_get_drvdata(cdev);\n\tstruct raid_component *rc, *next;\n\tdev_printk(KERN_ERR, dev, \"RAID REMOVE\\n\");\n\tdev_set_drvdata(cdev, NULL);\n\tlist_for_each_entry_safe(rc, next, &rd->component_list, node) {\n\t\tlist_del(&rc->node);\n\t\tdev_printk(KERN_ERR, rc->dev.parent, \"RAID COMPONENT REMOVE\\n\");\n\t\tdevice_unregister(&rc->dev);\n\t}\n\tdev_printk(KERN_ERR, dev, \"RAID REMOVE DONE\\n\");\n\tkfree(rd);\n\treturn 0;\n}\n\nstatic DECLARE_TRANSPORT_CLASS(raid_class,\n\t\t\t       \"raid_devices\",\n\t\t\t       raid_setup,\n\t\t\t       raid_remove,\n\t\t\t       NULL);\n\nstatic const struct {\n\tenum raid_state\tvalue;\n\tchar\t\t*name;\n} raid_states[] = {\n\t{ RAID_STATE_UNKNOWN, \"unknown\" },\n\t{ RAID_STATE_ACTIVE, \"active\" },\n\t{ RAID_STATE_DEGRADED, \"degraded\" },\n\t{ RAID_STATE_RESYNCING, \"resyncing\" },\n\t{ RAID_STATE_OFFLINE, \"offline\" },\n};\n\nstatic const char *raid_state_name(enum raid_state state)\n{\n\tint i;\n\tchar *name = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(raid_states); i++) {\n\t\tif (raid_states[i].value == state) {\n\t\t\tname = raid_states[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn name;\n}\n\nstatic struct {\n\tenum raid_level value;\n\tchar *name;\n} raid_levels[] = {\n\t{ RAID_LEVEL_UNKNOWN, \"unknown\" },\n\t{ RAID_LEVEL_LINEAR, \"linear\" },\n\t{ RAID_LEVEL_0, \"raid0\" },\n\t{ RAID_LEVEL_1, \"raid1\" },\n\t{ RAID_LEVEL_10, \"raid10\" },\n\t{ RAID_LEVEL_1E, \"raid1e\" },\n\t{ RAID_LEVEL_3, \"raid3\" },\n\t{ RAID_LEVEL_4, \"raid4\" },\n\t{ RAID_LEVEL_5, \"raid5\" },\n\t{ RAID_LEVEL_50, \"raid50\" },\n\t{ RAID_LEVEL_6, \"raid6\" },\n\t{ RAID_LEVEL_JBOD, \"jbod\" },\n};\n\nstatic const char *raid_level_name(enum raid_level level)\n{\n\tint i;\n\tchar *name = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(raid_levels); i++) {\n\t\tif (raid_levels[i].value == level) {\n\t\t\tname = raid_levels[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn name;\n}\n\n#define raid_attr_show_internal(attr, fmt, var, code)\t\t\t\\\nstatic ssize_t raid_show_##attr(struct device *dev, \t\t\t\\\n\t\t\t\tstruct device_attribute *attr, \t\t\\\n\t\t\t\tchar *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct raid_data *rd = dev_get_drvdata(dev);\t\t\t\\\n\tcode\t\t\t\t\t\t\t\t\\\n\treturn snprintf(buf, 20, #fmt \"\\n\", var);\t\t\t\\\n}\n\n#define raid_attr_ro_states(attr, states, code)\t\t\t\t\\\nraid_attr_show_internal(attr, %s, name,\t\t\t\t\t\\\n\tconst char *name;\t\t\t\t\t\t\\\n\tcode\t\t\t\t\t\t\t\t\\\n\tname = raid_##states##_name(rd->attr);\t\t\t\t\\\n)\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(attr, S_IRUGO, raid_show_##attr, NULL)\n\n\n#define raid_attr_ro_internal(attr, code)\t\t\t\t\\\nraid_attr_show_internal(attr, %d, rd->attr, code)\t\t\t\\\nstatic DEVICE_ATTR(attr, S_IRUGO, raid_show_##attr, NULL)\n\n#define ATTR_CODE(attr)\t\t\t\t\t\t\t\\\n\tstruct raid_internal *i = device_to_raid_internal(dev);\t\t\\\n\tif (i->f->get_##attr)\t\t\t\t\t\t\\\n\t\ti->f->get_##attr(dev->parent);\n\n#define raid_attr_ro(attr)\traid_attr_ro_internal(attr, )\n#define raid_attr_ro_fn(attr)\traid_attr_ro_internal(attr, ATTR_CODE(attr))\n#define raid_attr_ro_state(attr)\traid_attr_ro_states(attr, attr, )\n#define raid_attr_ro_state_fn(attr)\traid_attr_ro_states(attr, attr, ATTR_CODE(attr))\n\n\nraid_attr_ro_state(level);\nraid_attr_ro_fn(resync);\nraid_attr_ro_state_fn(state);\n\nstruct raid_template *\nraid_class_attach(struct raid_function_template *ft)\n{\n\tstruct raid_internal *i = kzalloc(sizeof(struct raid_internal),\n\t\t\t\t\t  GFP_KERNEL);\n\tint count = 0;\n\n\tif (unlikely(!i))\n\t\treturn NULL;\n\n\ti->f = ft;\n\n\ti->r.raid_attrs.ac.class = &raid_class.class;\n\ti->r.raid_attrs.ac.match = raid_match;\n\ti->r.raid_attrs.ac.attrs = &i->attrs[0];\n\n\tattribute_container_register(&i->r.raid_attrs.ac);\n\n\ti->attrs[count++] = &dev_attr_level;\n\ti->attrs[count++] = &dev_attr_resync;\n\ti->attrs[count++] = &dev_attr_state;\n\n\ti->attrs[count] = NULL;\n\tBUG_ON(count > RAID_NUM_ATTRS);\n\n\treturn &i->r;\n}\nEXPORT_SYMBOL(raid_class_attach);\n\nvoid\nraid_class_release(struct raid_template *r)\n{\n\tstruct raid_internal *i = to_raid_internal(r);\n\n\tBUG_ON(attribute_container_unregister(&i->r.raid_attrs.ac));\n\n\tkfree(i);\n}\nEXPORT_SYMBOL(raid_class_release);\n\nstatic __init int raid_init(void)\n{\n\treturn transport_class_register(&raid_class);\n}\n\nstatic __exit void raid_exit(void)\n{\n\ttransport_class_unregister(&raid_class);\n}\n\nMODULE_AUTHOR(\"James Bottomley\");\nMODULE_DESCRIPTION(\"RAID device class\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(raid_init);\nmodule_exit(raid_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}