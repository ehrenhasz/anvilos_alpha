{
  "module_name": "cumana_1.c",
  "hash_id": "89b5fb6dabb0dc23ff437fca54566778e9b45604c206ab639b2c16b0f1c238cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/arm/cumana_1.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n\n#include <asm/ecard.h>\n#include <asm/io.h>\n\n#include <scsi/scsi_host.h>\n\n#define priv(host)\t\t\t((struct NCR5380_hostdata *)(host)->hostdata)\n#define NCR5380_read(reg)\t\tcumanascsi_read(hostdata, reg)\n#define NCR5380_write(reg, value)\tcumanascsi_write(hostdata, reg, value)\n\n#define NCR5380_dma_xfer_len\t\tcumanascsi_dma_xfer_len\n#define NCR5380_dma_recv_setup\t\tcumanascsi_pread\n#define NCR5380_dma_send_setup\t\tcumanascsi_pwrite\n#define NCR5380_dma_residual\t\tNCR5380_dma_residual_none\n\n#define NCR5380_intr\t\t\tcumanascsi_intr\n#define NCR5380_queue_command\t\tcumanascsi_queue_command\n#define NCR5380_info\t\t\tcumanascsi_info\n\n#define NCR5380_implementation_fields\t\\\n\tunsigned ctrl\n\nstruct NCR5380_hostdata;\nstatic u8 cumanascsi_read(struct NCR5380_hostdata *, unsigned int);\nstatic void cumanascsi_write(struct NCR5380_hostdata *, unsigned int, u8);\n\n#include \"../NCR5380.h\"\n\n#define CTRL\t0x16fc\n#define STAT\t0x2004\n#define L(v)\t(((v)<<16)|((v) & 0x0000ffff))\n#define H(v)\t(((v)>>16)|((v) & 0xffff0000))\n\nstatic inline int cumanascsi_pwrite(struct NCR5380_hostdata *hostdata,\n                                    unsigned char *addr, int len)\n{\n  unsigned long *laddr;\n  u8 __iomem *base = hostdata->io;\n  u8 __iomem *dma = hostdata->pdma_io + 0x2000;\n\n  if(!len) return 0;\n\n  writeb(0x02, base + CTRL);\n  laddr = (unsigned long *)addr;\n  while(len >= 32)\n  {\n    unsigned int status;\n    unsigned long v;\n    status = readb(base + STAT);\n    if(status & 0x80)\n      goto end;\n    if(!(status & 0x40))\n      continue;\n    v=*laddr++; writew(L(v), dma); writew(H(v), dma);\n    v=*laddr++; writew(L(v), dma); writew(H(v), dma);\n    v=*laddr++; writew(L(v), dma); writew(H(v), dma);\n    v=*laddr++; writew(L(v), dma); writew(H(v), dma);\n    v=*laddr++; writew(L(v), dma); writew(H(v), dma);\n    v=*laddr++; writew(L(v), dma); writew(H(v), dma);\n    v=*laddr++; writew(L(v), dma); writew(H(v), dma);\n    v=*laddr++; writew(L(v), dma); writew(H(v), dma);\n    len -= 32;\n    if(len == 0)\n      break;\n  }\n\n  addr = (unsigned char *)laddr;\n  writeb(0x12, base + CTRL);\n\n  while(len > 0)\n  {\n    unsigned int status;\n    status = readb(base + STAT);\n    if(status & 0x80)\n      goto end;\n    if(status & 0x40)\n    {\n      writeb(*addr++, dma);\n      if(--len == 0)\n        break;\n    }\n\n    status = readb(base + STAT);\n    if(status & 0x80)\n      goto end;\n    if(status & 0x40)\n    {\n      writeb(*addr++, dma);\n      if(--len == 0)\n        break;\n    }\n  }\nend:\n  writeb(hostdata->ctrl | 0x40, base + CTRL);\n\n\tif (len)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic inline int cumanascsi_pread(struct NCR5380_hostdata *hostdata,\n                                   unsigned char *addr, int len)\n{\n  unsigned long *laddr;\n  u8 __iomem *base = hostdata->io;\n  u8 __iomem *dma = hostdata->pdma_io + 0x2000;\n\n  if(!len) return 0;\n\n  writeb(0x00, base + CTRL);\n  laddr = (unsigned long *)addr;\n  while(len >= 32)\n  {\n    unsigned int status;\n    status = readb(base + STAT);\n    if(status & 0x80)\n      goto end;\n    if(!(status & 0x40))\n      continue;\n    *laddr++ = readw(dma) | (readw(dma) << 16);\n    *laddr++ = readw(dma) | (readw(dma) << 16);\n    *laddr++ = readw(dma) | (readw(dma) << 16);\n    *laddr++ = readw(dma) | (readw(dma) << 16);\n    *laddr++ = readw(dma) | (readw(dma) << 16);\n    *laddr++ = readw(dma) | (readw(dma) << 16);\n    *laddr++ = readw(dma) | (readw(dma) << 16);\n    *laddr++ = readw(dma) | (readw(dma) << 16);\n    len -= 32;\n    if(len == 0)\n      break;\n  }\n\n  addr = (unsigned char *)laddr;\n  writeb(0x10, base + CTRL);\n\n  while(len > 0)\n  {\n    unsigned int status;\n    status = readb(base + STAT);\n    if(status & 0x80)\n      goto end;\n    if(status & 0x40)\n    {\n      *addr++ = readb(dma);\n      if(--len == 0)\n        break;\n    }\n\n    status = readb(base + STAT);\n    if(status & 0x80)\n      goto end;\n    if(status & 0x40)\n    {\n      *addr++ = readb(dma);\n      if(--len == 0)\n        break;\n    }\n  }\nend:\n  writeb(hostdata->ctrl | 0x40, base + CTRL);\n\n\tif (len)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int cumanascsi_dma_xfer_len(struct NCR5380_hostdata *hostdata,\n                                   struct scsi_cmnd *cmd)\n{\n\treturn cmd->transfersize;\n}\n\nstatic u8 cumanascsi_read(struct NCR5380_hostdata *hostdata,\n                          unsigned int reg)\n{\n\tu8 __iomem *base = hostdata->io;\n\tu8 val;\n\n\twriteb(0, base + CTRL);\n\n\tval = readb(base + 0x2100 + (reg << 2));\n\n\thostdata->ctrl = 0x40;\n\twriteb(0x40, base + CTRL);\n\n\treturn val;\n}\n\nstatic void cumanascsi_write(struct NCR5380_hostdata *hostdata,\n                             unsigned int reg, u8 value)\n{\n\tu8 __iomem *base = hostdata->io;\n\n\twriteb(0, base + CTRL);\n\n\twriteb(value, base + 0x2100 + (reg << 2));\n\n\thostdata->ctrl = 0x40;\n\twriteb(0x40, base + CTRL);\n}\n\n#include \"../NCR5380.c\"\n\nstatic const struct scsi_host_template cumanascsi_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"Cumana 16-bit SCSI\",\n\t.info\t\t\t= cumanascsi_info,\n\t.queuecommand\t\t= cumanascsi_queue_command,\n\t.eh_abort_handler\t= NCR5380_abort,\n\t.eh_host_reset_handler\t= NCR5380_host_reset,\n\t.can_queue\t\t= 16,\n\t.this_id\t\t= 7,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.cmd_per_lun\t\t= 2,\n\t.proc_name\t\t= \"CumanaSCSI-1\",\n\t.cmd_size\t\t= sizeof(struct NCR5380_cmd),\n\t.max_sectors\t\t= 128,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n};\n\nstatic int cumanascsi1_probe(struct expansion_card *ec,\n\t\t\t     const struct ecard_id *id)\n{\n\tstruct Scsi_Host *host;\n\tint ret;\n\n\tret = ecard_request_resources(ec);\n\tif (ret)\n\t\tgoto out;\n\n\thost = scsi_host_alloc(&cumanascsi_template, sizeof(struct NCR5380_hostdata));\n\tif (!host) {\n\t\tret = -ENOMEM;\n\t\tgoto out_release;\n\t}\n\n\tpriv(host)->io = ioremap(ecard_resource_start(ec, ECARD_RES_IOCSLOW),\n\t                         ecard_resource_len(ec, ECARD_RES_IOCSLOW));\n\tpriv(host)->pdma_io = ioremap(ecard_resource_start(ec, ECARD_RES_MEMC),\n\t                              ecard_resource_len(ec, ECARD_RES_MEMC));\n\tif (!priv(host)->io || !priv(host)->pdma_io) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\n\thost->irq = ec->irq;\n\n\tret = NCR5380_init(host, FLAG_DMA_FIXUP | FLAG_LATE_DMA_SETUP);\n\tif (ret)\n\t\tgoto out_unmap;\n\n\tNCR5380_maybe_reset_bus(host);\n\n        priv(host)->ctrl = 0;\n        writeb(0, priv(host)->io + CTRL);\n\n\tret = request_irq(host->irq, cumanascsi_intr, 0,\n\t\t\t  \"CumanaSCSI-1\", host);\n\tif (ret) {\n\t\tprintk(\"scsi%d: IRQ%d not free: %d\\n\",\n\t\t    host->host_no, host->irq, ret);\n\t\tgoto out_exit;\n\t}\n\n\tret = scsi_add_host(host, &ec->dev);\n\tif (ret)\n\t\tgoto out_free_irq;\n\n\tscsi_scan_host(host);\n\tgoto out;\n\n out_free_irq:\n\tfree_irq(host->irq, host);\n out_exit:\n\tNCR5380_exit(host);\n out_unmap:\n\tiounmap(priv(host)->io);\n\tiounmap(priv(host)->pdma_io);\n\tscsi_host_put(host);\n out_release:\n\tecard_release_resources(ec);\n out:\n\treturn ret;\n}\n\nstatic void cumanascsi1_remove(struct expansion_card *ec)\n{\n\tstruct Scsi_Host *host = ecard_get_drvdata(ec);\n\tvoid __iomem *base = priv(host)->io;\n\tvoid __iomem *dma = priv(host)->pdma_io;\n\n\tecard_set_drvdata(ec, NULL);\n\n\tscsi_remove_host(host);\n\tfree_irq(host->irq, host);\n\tNCR5380_exit(host);\n\tscsi_host_put(host);\n\tiounmap(base);\n\tiounmap(dma);\n\tecard_release_resources(ec);\n}\n\nstatic const struct ecard_id cumanascsi1_cids[] = {\n\t{ MANU_CUMANA, PROD_CUMANA_SCSI_1 },\n\t{ 0xffff, 0xffff }\n};\n\nstatic struct ecard_driver cumanascsi1_driver = {\n\t.probe\t\t= cumanascsi1_probe,\n\t.remove\t\t= cumanascsi1_remove,\n\t.id_table\t= cumanascsi1_cids,\n\t.drv = {\n\t\t.name\t\t= \"cumanascsi1\",\n\t},\n};\n\nstatic int __init cumanascsi_init(void)\n{\n\treturn ecard_register_driver(&cumanascsi1_driver);\n}\n\nstatic void __exit cumanascsi_exit(void)\n{\n\tecard_remove_driver(&cumanascsi1_driver);\n}\n\nmodule_init(cumanascsi_init);\nmodule_exit(cumanascsi_exit);\n\nMODULE_DESCRIPTION(\"Cumana SCSI-1 driver for Acorn machines\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}