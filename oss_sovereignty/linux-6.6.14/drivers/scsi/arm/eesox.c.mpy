{
  "module_name": "eesox.c",
  "hash_id": "eaa520a40334b96af15406ff615897ee9f944683a8e4ec8725cf0acf1d0b32d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/arm/eesox.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ioport.h>\n#include <linux/proc_fs.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/dma-mapping.h>\n#include <linux/pgtable.h>\n\n#include <asm/io.h>\n#include <asm/dma.h>\n#include <asm/ecard.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include \"fas216.h\"\n#include \"arm_scsi.h\"\n\n#include <scsi/scsicam.h>\n\n#define EESOX_FAS216_OFFSET\t0x3000\n#define EESOX_FAS216_SHIFT\t5\n\n#define EESOX_DMASTAT\t\t0x2800\n#define EESOX_STAT_INTR\t\t0x01\n#define EESOX_STAT_DMA\t\t0x02\n\n#define EESOX_CONTROL\t\t0x2800\n#define EESOX_INTR_ENABLE\t0x04\n#define EESOX_TERM_ENABLE\t0x02\n#define EESOX_RESET\t\t0x01\n\n#define EESOX_DMADATA\t\t0x3800\n\n#define VERSION \"1.10 (17/01/2003 2.5.59)\"\n\n \nstatic int term[MAX_ECARDS] = { 1, 1, 1, 1, 1, 1, 1, 1 };\n\n#define NR_SG\t256\n\nstruct eesoxscsi_info {\n\tFAS216_Info\t\tinfo;\n\tstruct expansion_card\t*ec;\n\tvoid __iomem\t\t*base;\n\tvoid __iomem\t\t*ctl_port;\n\tunsigned int\t\tcontrol;\n\tstruct scatterlist\tsg[NR_SG];\t \n};\n\n \nstatic void\neesoxscsi_irqenable(struct expansion_card *ec, int irqnr)\n{\n\tstruct eesoxscsi_info *info = (struct eesoxscsi_info *)ec->irq_data;\n\n\tinfo->control |= EESOX_INTR_ENABLE;\n\n\twriteb(info->control, info->ctl_port);\n}\n\n \nstatic void\neesoxscsi_irqdisable(struct expansion_card *ec, int irqnr)\n{\n\tstruct eesoxscsi_info *info = (struct eesoxscsi_info *)ec->irq_data;\n\n\tinfo->control &= ~EESOX_INTR_ENABLE;\n\n\twriteb(info->control, info->ctl_port);\n}\n\nstatic const expansioncard_ops_t eesoxscsi_ops = {\n\t.irqenable\t= eesoxscsi_irqenable,\n\t.irqdisable\t= eesoxscsi_irqdisable,\n};\n\n \nstatic void\neesoxscsi_terminator_ctl(struct Scsi_Host *host, int on_off)\n{\n\tstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(host->host_lock, flags);\n\tif (on_off)\n\t\tinfo->control |= EESOX_TERM_ENABLE;\n\telse\n\t\tinfo->control &= ~EESOX_TERM_ENABLE;\n\n\twriteb(info->control, info->ctl_port);\n\tspin_unlock_irqrestore(host->host_lock, flags);\n}\n\n \nstatic irqreturn_t\neesoxscsi_intr(int irq, void *dev_id)\n{\n\tstruct eesoxscsi_info *info = dev_id;\n\n\treturn fas216_intr(&info->info);\n}\n\n \nstatic fasdmatype_t\neesoxscsi_dma_setup(struct Scsi_Host *host, struct scsi_pointer *SCp,\n\t\t       fasdmadir_t direction, fasdmatype_t min_type)\n{\n\tstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\n\tstruct device *dev = scsi_get_device(host);\n\tint dmach = info->info.scsi.dma;\n\n\tif (dmach != NO_DMA &&\n\t    (min_type == fasdma_real_all || SCp->this_residual >= 512)) {\n\t\tint bufs, map_dir, dma_dir;\n\n\t\tbufs = copy_SCp_to_sg(&info->sg[0], SCp, NR_SG);\n\n\t\tif (direction == DMA_OUT) {\n\t\t\tmap_dir = DMA_TO_DEVICE;\n\t\t\tdma_dir = DMA_MODE_WRITE;\n\t\t} else {\n\t\t\tmap_dir = DMA_FROM_DEVICE;\n\t\t\tdma_dir = DMA_MODE_READ;\n\t\t}\n\n\t\tdma_map_sg(dev, info->sg, bufs, map_dir);\n\n\t\tdisable_dma(dmach);\n\t\tset_dma_sg(dmach, info->sg, bufs);\n\t\tset_dma_mode(dmach, dma_dir);\n\t\tenable_dma(dmach);\n\t\treturn fasdma_real_all;\n\t}\n\t \n\treturn fasdma_pseudo;\n}\n\nstatic void eesoxscsi_buffer_in(void *buf, int length, void __iomem *base)\n{\n\tconst void __iomem *reg_fas = base + EESOX_FAS216_OFFSET;\n\tconst void __iomem *reg_dmastat = base + EESOX_DMASTAT;\n\tconst void __iomem *reg_dmadata = base + EESOX_DMADATA;\n\tregister const unsigned long mask = 0xffff;\n\n\tdo {\n\t\tunsigned int status;\n\n\t\t \n\t\tstatus = readb(reg_fas + (REG_STAT << EESOX_FAS216_SHIFT));\n\t\tif (status & STAT_INT)\n\t\t\tbreak;\n\n\t\t \n\t\tstatus = readb(reg_dmastat);\n\t\tif (!(status & EESOX_STAT_DMA))\n\t\t\tcontinue;\n\n\t\t \n\t\tstatus = readb(reg_fas + (REG_CFIS << EESOX_FAS216_SHIFT)) & CFIS_CF;\n\t\tif (status > 16)\n\t\t\tstatus = 16;\n\t\tif (status > length)\n\t\t\tstatus = length;\n\n\t\t \n\t\tif (((u32)buf) & 2 && status >= 2) {\n\t\t\t*(u16 *)buf = readl(reg_dmadata);\n\t\t\tbuf += 2;\n\t\t\tstatus -= 2;\n\t\t\tlength -= 2;\n\t\t}\n\n\t\tif (status >= 8) {\n\t\t\tunsigned long l1, l2;\n\n\t\t\tl1 = readl(reg_dmadata) & mask;\n\t\t\tl1 |= readl(reg_dmadata) << 16;\n\t\t\tl2 = readl(reg_dmadata) & mask;\n\t\t\tl2 |= readl(reg_dmadata) << 16;\n\t\t\t*(u32 *)buf = l1;\n\t\t\tbuf += 4;\n\t\t\t*(u32 *)buf = l2;\n\t\t\tbuf += 4;\n\t\t\tlength -= 8;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (status >= 4) {\n\t\t\tunsigned long l1;\n\n\t\t\tl1 = readl(reg_dmadata) & mask;\n\t\t\tl1 |= readl(reg_dmadata) << 16;\n\n\t\t\t*(u32 *)buf = l1;\n\t\t\tbuf += 4;\n\t\t\tlength -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (status >= 2) {\n\t\t\t*(u16 *)buf = readl(reg_dmadata);\n\t\t\tbuf += 2;\n\t\t\tlength -= 2;\n\t\t}\n\t} while (length);\n}\n\nstatic void eesoxscsi_buffer_out(void *buf, int length, void __iomem *base)\n{\n\tconst void __iomem *reg_fas = base + EESOX_FAS216_OFFSET;\n\tconst void __iomem *reg_dmastat = base + EESOX_DMASTAT;\n\tvoid __iomem *reg_dmadata = base + EESOX_DMADATA;\n\n\tdo {\n\t\tunsigned int status;\n\n\t\t \n\t\tstatus = readb(reg_fas + (REG_STAT << EESOX_FAS216_SHIFT));\n\t\tif (status & STAT_INT)\n\t\t\tbreak;\n\n\t\t \n\t\tstatus = readb(reg_dmastat);\n\t\tif (!(status & EESOX_STAT_DMA))\n\t\t\tcontinue;\n\n\t\t \n\t\tstatus = readb(reg_fas + (REG_CFIS << EESOX_FAS216_SHIFT)) & CFIS_CF;\n\t\tif (status > 16)\n\t\t\tstatus = 16;\n\t\tstatus = 16 - status;\n\t\tif (status > length)\n\t\t\tstatus = length;\n\t\tstatus &= ~1;\n\n\t\t \n\t\tif (((u32)buf) & 2 && status >= 2) {\n\t\t\twritel(*(u16 *)buf << 16, reg_dmadata);\n\t\t\tbuf += 2;\n\t\t\tstatus -= 2;\n\t\t\tlength -= 2;\n\t\t}\n\n\t\tif (status >= 8) {\n\t\t\tunsigned long l1, l2;\n\n\t\t\tl1 = *(u32 *)buf;\n\t\t\tbuf += 4;\n\t\t\tl2 = *(u32 *)buf;\n\t\t\tbuf += 4;\n\n\t\t\twritel(l1 << 16, reg_dmadata);\n\t\t\twritel(l1, reg_dmadata);\n\t\t\twritel(l2 << 16, reg_dmadata);\n\t\t\twritel(l2, reg_dmadata);\n\t\t\tlength -= 8;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (status >= 4) {\n\t\t\tunsigned long l1;\n\n\t\t\tl1 = *(u32 *)buf;\n\t\t\tbuf += 4;\n\n\t\t\twritel(l1 << 16, reg_dmadata);\n\t\t\twritel(l1, reg_dmadata);\n\t\t\tlength -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (status >= 2) {\n\t\t\twritel(*(u16 *)buf << 16, reg_dmadata);\n\t\t\tbuf += 2;\n\t\t\tlength -= 2;\n\t\t}\n\t} while (length);\n}\n\nstatic void\neesoxscsi_dma_pseudo(struct Scsi_Host *host, struct scsi_pointer *SCp,\n\t\t     fasdmadir_t dir, int transfer_size)\n{\n\tstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\n\tif (dir == DMA_IN) {\n\t\teesoxscsi_buffer_in(SCp->ptr, SCp->this_residual, info->base);\n\t} else {\n\t\teesoxscsi_buffer_out(SCp->ptr, SCp->this_residual, info->base);\n\t}\n}\n\n \nstatic void\neesoxscsi_dma_stop(struct Scsi_Host *host, struct scsi_pointer *SCp)\n{\n\tstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\n\tif (info->info.scsi.dma != NO_DMA)\n\t\tdisable_dma(info->info.scsi.dma);\n}\n\n \nconst char *eesoxscsi_info(struct Scsi_Host *host)\n{\n\tstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\n\tstatic char string[150];\n\n\tsprintf(string, \"%s (%s) in slot %d v%s terminators o%s\",\n\t\thost->hostt->name, info->info.scsi.type, info->ec->slot_no,\n\t\tVERSION, info->control & EESOX_TERM_ENABLE ? \"n\" : \"ff\");\n\n\treturn string;\n}\n\n \nstatic int\neesoxscsi_set_proc_info(struct Scsi_Host *host, char *buffer, int length)\n{\n\tint ret = length;\n\n\tif (length >= 9 && strncmp(buffer, \"EESOXSCSI\", 9) == 0) {\n\t\tbuffer += 9;\n\t\tlength -= 9;\n\n\t\tif (length >= 5 && strncmp(buffer, \"term=\", 5) == 0) {\n\t\t\tif (buffer[5] == '1')\n\t\t\t\teesoxscsi_terminator_ctl(host, 1);\n\t\t\telse if (buffer[5] == '0')\n\t\t\t\teesoxscsi_terminator_ctl(host, 0);\n\t\t\telse\n\t\t\t\tret = -EINVAL;\n\t\t} else\n\t\t\tret = -EINVAL;\n\t} else\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic int eesoxscsi_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tstruct eesoxscsi_info *info;\n\n\tinfo = (struct eesoxscsi_info *)host->hostdata;\n\n\tseq_printf(m, \"EESOX SCSI driver v%s\\n\", VERSION);\n\tfas216_print_host(&info->info, m);\n\tseq_printf(m, \"Term    : o%s\\n\",\n\t\t\tinfo->control & EESOX_TERM_ENABLE ? \"n\" : \"ff\");\n\n\tfas216_print_stats(&info->info, m);\n\tfas216_print_devices(&info->info, m);\n\treturn 0;\n}\n\nstatic ssize_t eesoxscsi_show_term(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct expansion_card *ec = ECARD_DEV(dev);\n\tstruct Scsi_Host *host = ecard_get_drvdata(ec);\n\tstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\n\n\treturn sprintf(buf, \"%d\\n\", info->control & EESOX_TERM_ENABLE ? 1 : 0);\n}\n\nstatic ssize_t eesoxscsi_store_term(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct expansion_card *ec = ECARD_DEV(dev);\n\tstruct Scsi_Host *host = ecard_get_drvdata(ec);\n\tstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\n\tunsigned long flags;\n\n\tif (len > 1) {\n\t\tspin_lock_irqsave(host->host_lock, flags);\n\t\tif (buf[0] != '0') {\n\t\t\tinfo->control |= EESOX_TERM_ENABLE;\n\t\t} else {\n\t\t\tinfo->control &= ~EESOX_TERM_ENABLE;\n\t\t}\n\t\twriteb(info->control, info->ctl_port);\n\t\tspin_unlock_irqrestore(host->host_lock, flags);\n\t}\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(bus_term, S_IRUGO | S_IWUSR,\n\t\t   eesoxscsi_show_term, eesoxscsi_store_term);\n\nstatic const struct scsi_host_template eesox_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.show_info\t\t\t= eesoxscsi_show_info,\n\t.write_info\t\t\t= eesoxscsi_set_proc_info,\n\t.name\t\t\t\t= \"EESOX SCSI\",\n\t.info\t\t\t\t= eesoxscsi_info,\n\t.queuecommand\t\t\t= fas216_queue_command,\n\t.eh_host_reset_handler\t\t= fas216_eh_host_reset,\n\t.eh_bus_reset_handler\t\t= fas216_eh_bus_reset,\n\t.eh_device_reset_handler\t= fas216_eh_device_reset,\n\t.eh_abort_handler\t\t= fas216_eh_abort,\n\t.cmd_size\t\t\t= sizeof(struct fas216_cmd_priv),\n\t.can_queue\t\t\t= 1,\n\t.this_id\t\t\t= 7,\n\t.sg_tablesize\t\t\t= SG_MAX_SEGMENTS,\n\t.dma_boundary\t\t\t= IOMD_DMA_BOUNDARY,\n\t.proc_name\t\t\t= \"eesox\",\n};\n\nstatic int eesoxscsi_probe(struct expansion_card *ec, const struct ecard_id *id)\n{\n\tstruct Scsi_Host *host;\n\tstruct eesoxscsi_info *info;\n\tvoid __iomem *base;\n\tint ret;\n\n\tret = ecard_request_resources(ec);\n\tif (ret)\n\t\tgoto out;\n\n\tbase = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);\n\tif (!base) {\n\t\tret = -ENOMEM;\n\t\tgoto out_region;\n\t}\n\n\thost = scsi_host_alloc(&eesox_template,\n\t\t\t       sizeof(struct eesoxscsi_info));\n\tif (!host) {\n\t\tret = -ENOMEM;\n\t\tgoto out_region;\n\t}\n\n\tecard_set_drvdata(ec, host);\n\n\tinfo = (struct eesoxscsi_info *)host->hostdata;\n\tinfo->ec\t= ec;\n\tinfo->base\t= base;\n\tinfo->ctl_port\t= base + EESOX_CONTROL;\n\tinfo->control\t= term[ec->slot_no] ? EESOX_TERM_ENABLE : 0;\n\twriteb(info->control, info->ctl_port);\n\n\tinfo->info.scsi.io_base\t\t= base + EESOX_FAS216_OFFSET;\n\tinfo->info.scsi.io_shift\t= EESOX_FAS216_SHIFT;\n\tinfo->info.scsi.irq\t\t= ec->irq;\n\tinfo->info.scsi.dma\t\t= ec->dma;\n\tinfo->info.ifcfg.clockrate\t= 40;  \n\tinfo->info.ifcfg.select_timeout\t= 255;\n\tinfo->info.ifcfg.asyncperiod\t= 200;  \n\tinfo->info.ifcfg.sync_max_depth\t= 7;\n\tinfo->info.ifcfg.cntl3\t\t= CNTL3_FASTSCSI | CNTL3_FASTCLK;\n\tinfo->info.ifcfg.disconnect_ok\t= 1;\n\tinfo->info.ifcfg.wide_max_size\t= 0;\n\tinfo->info.ifcfg.capabilities\t= FASCAP_PSEUDODMA;\n\tinfo->info.dma.setup\t\t= eesoxscsi_dma_setup;\n\tinfo->info.dma.pseudo\t\t= eesoxscsi_dma_pseudo;\n\tinfo->info.dma.stop\t\t= eesoxscsi_dma_stop;\n\n\tec->irqaddr\t= base + EESOX_DMASTAT;\n\tec->irqmask\t= EESOX_STAT_INTR;\n\n\tecard_setirq(ec, &eesoxscsi_ops, info);\n\n\tdevice_create_file(&ec->dev, &dev_attr_bus_term);\n\n\tret = fas216_init(host);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = request_irq(ec->irq, eesoxscsi_intr, 0, \"eesoxscsi\", info);\n\tif (ret) {\n\t\tprintk(\"scsi%d: IRQ%d not free: %d\\n\",\n\t\t       host->host_no, ec->irq, ret);\n\t\tgoto out_remove;\n\t}\n\n\tif (info->info.scsi.dma != NO_DMA) {\n\t\tif (request_dma(info->info.scsi.dma, \"eesox\")) {\n\t\t\tprintk(\"scsi%d: DMA%d not free, DMA disabled\\n\",\n\t\t\t       host->host_no, info->info.scsi.dma);\n\t\t\tinfo->info.scsi.dma = NO_DMA;\n\t\t} else {\n\t\t\tset_dma_speed(info->info.scsi.dma, 180);\n\t\t\tinfo->info.ifcfg.capabilities |= FASCAP_DMA;\n\t\t\tinfo->info.ifcfg.cntl3 |= CNTL3_BS8;\n\t\t}\n\t}\n\n\tret = fas216_add(host, &ec->dev);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tif (info->info.scsi.dma != NO_DMA)\n\t\tfree_dma(info->info.scsi.dma);\n\tfree_irq(ec->irq, info);\n\n out_remove:\n\tfas216_remove(host);\n\n out_free:\n\tdevice_remove_file(&ec->dev, &dev_attr_bus_term);\n\tscsi_host_put(host);\n\n out_region:\n\tecard_release_resources(ec);\n\n out:\n\treturn ret;\n}\n\nstatic void eesoxscsi_remove(struct expansion_card *ec)\n{\n\tstruct Scsi_Host *host = ecard_get_drvdata(ec);\n\tstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\n\n\tecard_set_drvdata(ec, NULL);\n\tfas216_remove(host);\n\n\tif (info->info.scsi.dma != NO_DMA)\n\t\tfree_dma(info->info.scsi.dma);\n\tfree_irq(ec->irq, info);\n\n\tdevice_remove_file(&ec->dev, &dev_attr_bus_term);\n\n\tfas216_release(host);\n\tscsi_host_put(host);\n\tecard_release_resources(ec);\n}\n\nstatic const struct ecard_id eesoxscsi_cids[] = {\n\t{ MANU_EESOX, PROD_EESOX_SCSI2 },\n\t{ 0xffff, 0xffff },\n};\n\nstatic struct ecard_driver eesoxscsi_driver = {\n\t.probe\t\t= eesoxscsi_probe,\n\t.remove\t\t= eesoxscsi_remove,\n\t.id_table\t= eesoxscsi_cids,\n\t.drv = {\n\t\t.name\t\t= \"eesoxscsi\",\n\t},\n};\n\nstatic int __init eesox_init(void)\n{\n\treturn ecard_register_driver(&eesoxscsi_driver);\n}\n\nstatic void __exit eesox_exit(void)\n{\n\tecard_remove_driver(&eesoxscsi_driver);\n}\n\nmodule_init(eesox_init);\nmodule_exit(eesox_exit);\n\nMODULE_AUTHOR(\"Russell King\");\nMODULE_DESCRIPTION(\"EESOX 'Fast' SCSI driver for Acorn machines\");\nmodule_param_array(term, int, NULL, 0);\nMODULE_PARM_DESC(term, \"SCSI bus termination\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}