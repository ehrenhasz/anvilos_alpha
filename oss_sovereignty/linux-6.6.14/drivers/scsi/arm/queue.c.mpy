{
  "module_name": "queue.c",
  "hash_id": "81f7c2bf226e3b1eb53b50580877ba84fb7e37928152728aab4e43b752ae4f0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/arm/queue.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/init.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_tcq.h>\n\n#define DEBUG\n\ntypedef struct queue_entry {\n\tstruct list_head   list;\n\tstruct scsi_cmnd   *SCpnt;\n#ifdef DEBUG\n\tunsigned long\t   magic;\n#endif\n} QE_t;\n\n#ifdef DEBUG\n#define QUEUE_MAGIC_FREE\t0xf7e1c9a3\n#define QUEUE_MAGIC_USED\t0xf7e1cc33\n\n#define SET_MAGIC(q,m)\t((q)->magic = (m))\n#define BAD_MAGIC(q,m)\t((q)->magic != (m))\n#else\n#define SET_MAGIC(q,m)\tdo { } while (0)\n#define BAD_MAGIC(q,m)\t(0)\n#endif\n\n#include \"queue.h\"\n\n#define NR_QE\t32\n\n \nint queue_initialise (Queue_t *queue)\n{\n\tunsigned int nqueues = NR_QE;\n\tQE_t *q;\n\n\tspin_lock_init(&queue->queue_lock);\n\tINIT_LIST_HEAD(&queue->head);\n\tINIT_LIST_HEAD(&queue->free);\n\n\t \n\tqueue->alloc = q = kmalloc_array(nqueues, sizeof(QE_t), GFP_KERNEL);\n\tif (q) {\n\t\tfor (; nqueues; q++, nqueues--) {\n\t\t\tSET_MAGIC(q, QUEUE_MAGIC_FREE);\n\t\t\tq->SCpnt = NULL;\n\t\t\tlist_add(&q->list, &queue->free);\n\t\t}\n\t}\n\n\treturn queue->alloc != NULL;\n}\n\n \nvoid queue_free (Queue_t *queue)\n{\n\tif (!list_empty(&queue->head))\n\t\tprintk(KERN_WARNING \"freeing non-empty queue %p\\n\", queue);\n\tkfree(queue->alloc);\n}\n     \n\n \nint __queue_add(Queue_t *queue, struct scsi_cmnd *SCpnt, int head)\n{\n\tunsigned long flags;\n\tstruct list_head *l;\n\tQE_t *q;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&queue->queue_lock, flags);\n\tif (list_empty(&queue->free))\n\t\tgoto empty;\n\n\tl = queue->free.next;\n\tlist_del(l);\n\n\tq = list_entry(l, QE_t, list);\n\tBUG_ON(BAD_MAGIC(q, QUEUE_MAGIC_FREE));\n\n\tSET_MAGIC(q, QUEUE_MAGIC_USED);\n\tq->SCpnt = SCpnt;\n\n\tif (head)\n\t\tlist_add(l, &queue->head);\n\telse\n\t\tlist_add_tail(l, &queue->head);\n\n\tret = 1;\nempty:\n\tspin_unlock_irqrestore(&queue->queue_lock, flags);\n\treturn ret;\n}\n\nstatic struct scsi_cmnd *__queue_remove(Queue_t *queue, struct list_head *ent)\n{\n\tQE_t *q;\n\n\t \n\tlist_del(ent);\n\tq = list_entry(ent, QE_t, list);\n\tBUG_ON(BAD_MAGIC(q, QUEUE_MAGIC_USED));\n\n\tSET_MAGIC(q, QUEUE_MAGIC_FREE);\n\tlist_add(ent, &queue->free);\n\n\treturn q->SCpnt;\n}\n\n \nstruct scsi_cmnd *queue_remove_exclude(Queue_t *queue, unsigned long *exclude)\n{\n\tunsigned long flags;\n\tstruct list_head *l;\n\tstruct scsi_cmnd *SCpnt = NULL;\n\n\tspin_lock_irqsave(&queue->queue_lock, flags);\n\tlist_for_each(l, &queue->head) {\n\t\tQE_t *q = list_entry(l, QE_t, list);\n\t\tif (!test_bit(q->SCpnt->device->id * 8 +\n\t\t\t      (u8)(q->SCpnt->device->lun & 0x7), exclude)) {\n\t\t\tSCpnt = __queue_remove(queue, l);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&queue->queue_lock, flags);\n\n\treturn SCpnt;\n}\n\n \nstruct scsi_cmnd *queue_remove(Queue_t *queue)\n{\n\tunsigned long flags;\n\tstruct scsi_cmnd *SCpnt = NULL;\n\n\tspin_lock_irqsave(&queue->queue_lock, flags);\n\tif (!list_empty(&queue->head))\n\t\tSCpnt = __queue_remove(queue, queue->head.next);\n\tspin_unlock_irqrestore(&queue->queue_lock, flags);\n\n\treturn SCpnt;\n}\n\n \nstruct scsi_cmnd *queue_remove_tgtluntag(Queue_t *queue, int target, int lun,\n\t\t\t\t\t int tag)\n{\n\tunsigned long flags;\n\tstruct list_head *l;\n\tstruct scsi_cmnd *SCpnt = NULL;\n\n\tspin_lock_irqsave(&queue->queue_lock, flags);\n\tlist_for_each(l, &queue->head) {\n\t\tQE_t *q = list_entry(l, QE_t, list);\n\t\tif (q->SCpnt->device->id == target && q->SCpnt->device->lun == lun &&\n\t\t    scsi_cmd_to_rq(q->SCpnt)->tag == tag) {\n\t\t\tSCpnt = __queue_remove(queue, l);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&queue->queue_lock, flags);\n\n\treturn SCpnt;\n}\n\n \nvoid queue_remove_all_target(Queue_t *queue, int target)\n{\n\tunsigned long flags;\n\tstruct list_head *l;\n\n\tspin_lock_irqsave(&queue->queue_lock, flags);\n\tlist_for_each(l, &queue->head) {\n\t\tQE_t *q = list_entry(l, QE_t, list);\n\t\tif (q->SCpnt->device->id == target)\n\t\t\t__queue_remove(queue, l);\n\t}\n\tspin_unlock_irqrestore(&queue->queue_lock, flags);\n}\n\n \nint queue_probetgtlun (Queue_t *queue, int target, int lun)\n{\n\tunsigned long flags;\n\tstruct list_head *l;\n\tint found = 0;\n\n\tspin_lock_irqsave(&queue->queue_lock, flags);\n\tlist_for_each(l, &queue->head) {\n\t\tQE_t *q = list_entry(l, QE_t, list);\n\t\tif (q->SCpnt->device->id == target && q->SCpnt->device->lun == lun) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&queue->queue_lock, flags);\n\n\treturn found;\n}\n\n \nint queue_remove_cmd(Queue_t *queue, struct scsi_cmnd *SCpnt)\n{\n\tunsigned long flags;\n\tstruct list_head *l;\n\tint found = 0;\n\n\tspin_lock_irqsave(&queue->queue_lock, flags);\n\tlist_for_each(l, &queue->head) {\n\t\tQE_t *q = list_entry(l, QE_t, list);\n\t\tif (q->SCpnt == SCpnt) {\n\t\t\t__queue_remove(queue, l);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&queue->queue_lock, flags);\n\n\treturn found;\n}\n\nEXPORT_SYMBOL(queue_initialise);\nEXPORT_SYMBOL(queue_free);\nEXPORT_SYMBOL(__queue_add);\nEXPORT_SYMBOL(queue_remove);\nEXPORT_SYMBOL(queue_remove_exclude);\nEXPORT_SYMBOL(queue_remove_tgtluntag);\nEXPORT_SYMBOL(queue_remove_cmd);\nEXPORT_SYMBOL(queue_remove_all_target);\nEXPORT_SYMBOL(queue_probetgtlun);\n\nMODULE_AUTHOR(\"Russell King\");\nMODULE_DESCRIPTION(\"SCSI command queueing\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}