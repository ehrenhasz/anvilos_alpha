{
  "module_name": "oak.c",
  "hash_id": "9f5b39ee88309c4ceb2a2375046761ff6dbe19de2f2e17756411fb0cf89be538",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/arm/oak.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n\n#include <asm/ecard.h>\n#include <asm/io.h>\n\n#include <scsi/scsi_host.h>\n\n#define priv(host)\t\t\t((struct NCR5380_hostdata *)(host)->hostdata)\n\n#define NCR5380_read(reg)           readb(hostdata->io + ((reg) << 2))\n#define NCR5380_write(reg, value)   writeb(value, hostdata->io + ((reg) << 2))\n\n#define NCR5380_dma_xfer_len\t\tNCR5380_dma_xfer_none\n#define NCR5380_dma_recv_setup\t\toakscsi_pread\n#define NCR5380_dma_send_setup\t\toakscsi_pwrite\n#define NCR5380_dma_residual\t\tNCR5380_dma_residual_none\n\n#define NCR5380_queue_command\t\toakscsi_queue_command\n#define NCR5380_info\t\t\toakscsi_info\n\n#define NCR5380_implementation_fields\t \n\n#include \"../NCR5380.h\"\n\n#undef START_DMA_INITIATOR_RECEIVE_REG\n#define START_DMA_INITIATOR_RECEIVE_REG\t(128 + 7)\n\n#define STAT\t((128 + 16) << 2)\n#define DATA\t((128 + 8) << 2)\n\nstatic inline int oakscsi_pwrite(struct NCR5380_hostdata *hostdata,\n                                 unsigned char *addr, int len)\n{\n  u8 __iomem *base = hostdata->io;\n\nprintk(\"writing %p len %d\\n\",addr, len);\n\n  while(1)\n  {\n    int status;\n    while (((status = readw(base + STAT)) & 0x100)==0);\n  }\n  return 0;\n}\n\nstatic inline int oakscsi_pread(struct NCR5380_hostdata *hostdata,\n                                unsigned char *addr, int len)\n{\n  u8 __iomem *base = hostdata->io;\n\nprintk(\"reading %p len %d\\n\", addr, len);\n  while(len > 0)\n  {\n    unsigned int status, timeout;\n    unsigned long b;\n    \n    timeout = 0x01FFFFFF;\n    \n    while (((status = readw(base + STAT)) & 0x100)==0)\n    {\n      timeout--;\n      if(status & 0x200 || !timeout)\n      {\n        printk(\"status = %08X\\n\", status);\n        return -1;\n      }\n    }\n\n    if(len >= 128)\n    {\n      readsw(base + DATA, addr, 128);\n      addr += 128;\n      len -= 128;\n    }\n    else\n    {\n      b = (unsigned long) readw(base + DATA);\n      *addr ++ = b;\n      len -= 1;\n      if(len)\n        *addr ++ = b>>8;\n      len -= 1;\n    }\n  }\n  return 0;\n}\n\n#undef STAT\n#undef DATA\n\n#include \"../NCR5380.c\"\n\nstatic const struct scsi_host_template oakscsi_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"Oak 16-bit SCSI\",\n\t.info\t\t\t= oakscsi_info,\n\t.queuecommand\t\t= oakscsi_queue_command,\n\t.eh_abort_handler\t= NCR5380_abort,\n\t.eh_host_reset_handler\t= NCR5380_host_reset,\n\t.can_queue\t\t= 16,\n\t.this_id\t\t= 7,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.cmd_per_lun\t\t= 2,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n\t.proc_name\t\t= \"oakscsi\",\n\t.cmd_size\t\t= sizeof(struct NCR5380_cmd),\n\t.max_sectors\t\t= 128,\n};\n\nstatic int oakscsi_probe(struct expansion_card *ec, const struct ecard_id *id)\n{\n\tstruct Scsi_Host *host;\n\tint ret;\n\n\tret = ecard_request_resources(ec);\n\tif (ret)\n\t\tgoto out;\n\n\thost = scsi_host_alloc(&oakscsi_template, sizeof(struct NCR5380_hostdata));\n\tif (!host) {\n\t\tret = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\tpriv(host)->io = ioremap(ecard_resource_start(ec, ECARD_RES_MEMC),\n\t                         ecard_resource_len(ec, ECARD_RES_MEMC));\n\tif (!priv(host)->io) {\n\t\tret = -ENOMEM;\n\t\tgoto unreg;\n\t}\n\n\thost->irq = NO_IRQ;\n\n\tret = NCR5380_init(host, FLAG_DMA_FIXUP | FLAG_LATE_DMA_SETUP);\n\tif (ret)\n\t\tgoto out_unmap;\n\n\tNCR5380_maybe_reset_bus(host);\n\n\tret = scsi_add_host(host, &ec->dev);\n\tif (ret)\n\t\tgoto out_exit;\n\n\tscsi_scan_host(host);\n\tgoto out;\n\n out_exit:\n\tNCR5380_exit(host);\n out_unmap:\n\tiounmap(priv(host)->io);\n unreg:\n\tscsi_host_put(host);\n release:\n\tecard_release_resources(ec);\n out:\n\treturn ret;\n}\n\nstatic void oakscsi_remove(struct expansion_card *ec)\n{\n\tstruct Scsi_Host *host = ecard_get_drvdata(ec);\n\tvoid __iomem *base = priv(host)->io;\n\n\tecard_set_drvdata(ec, NULL);\n\tscsi_remove_host(host);\n\n\tNCR5380_exit(host);\n\tscsi_host_put(host);\n\tiounmap(base);\n\tecard_release_resources(ec);\n}\n\nstatic const struct ecard_id oakscsi_cids[] = {\n\t{ MANU_OAK, PROD_OAK_SCSI },\n\t{ 0xffff, 0xffff }\n};\n\nstatic struct ecard_driver oakscsi_driver = {\n\t.probe\t\t= oakscsi_probe,\n\t.remove\t\t= oakscsi_remove,\n\t.id_table\t= oakscsi_cids,\n\t.drv = {\n\t\t.name\t\t= \"oakscsi\",\n\t},\n};\n\nstatic int __init oakscsi_init(void)\n{\n\treturn ecard_register_driver(&oakscsi_driver);\n}\n\nstatic void __exit oakscsi_exit(void)\n{\n\tecard_remove_driver(&oakscsi_driver);\n}\n\nmodule_init(oakscsi_init);\nmodule_exit(oakscsi_exit);\n\nMODULE_AUTHOR(\"Russell King\");\nMODULE_DESCRIPTION(\"Oak SCSI driver\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}