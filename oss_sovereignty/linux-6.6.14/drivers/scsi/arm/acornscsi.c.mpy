{
  "module_name": "acornscsi.c",
  "hash_id": "6229933a9e3f515fbdfaa8dd09879ee5ce53b334337eca2a898064c78f11822d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/arm/acornscsi.c",
  "human_readable_source": "\n \n#define DEBUG_NO_WRITE\t1\n#define DEBUG_QUEUES\t2\n#define DEBUG_DMA\t4\n#define DEBUG_ABORT\t8\n#define DEBUG_DISCON\t16\n#define DEBUG_CONNECT\t32\n#define DEBUG_PHASES\t64\n#define DEBUG_WRITE\t128\n#define DEBUG_LINK\t256\n#define DEBUG_MESSAGES\t512\n#define DEBUG_RESET\t1024\n#define DEBUG_ALL\t(DEBUG_RESET|DEBUG_MESSAGES|DEBUG_LINK|DEBUG_WRITE|\\\n\t\t\t DEBUG_PHASES|DEBUG_CONNECT|DEBUG_DISCON|DEBUG_ABORT|\\\n\t\t\t DEBUG_DMA|DEBUG_QUEUES)\n\n \n\n \n#define SDTR_SIZE\t12\n#define SDTR_PERIOD\t125\n#define DEFAULT_PERIOD\t500\n\n \n#define DEBUG (DEBUG_RESET|DEBUG_WRITE|DEBUG_NO_WRITE)\n \n#define NO_WRITE 0xFE\n \n \n#define TIMEOUT_TIME 10\n \n#undef CONFIG_ACORNSCSI_CONSTANTS\n \n#define USE_DMAC\n\n \n\n#ifdef DEBUG_TARGET\n#define DBG(cmd,xxx...) \\\n  if (cmd->device->id == DEBUG_TARGET) { \\\n    xxx; \\\n  }\n#else\n#define DBG(cmd,xxx...) xxx\n#endif\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/proc_fs.h>\n#include <linux/ioport.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/io.h>\n\n#include <asm/ecard.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport_spi.h>\n#include \"acornscsi.h\"\n#include \"msgqueue.h\"\n#include \"arm_scsi.h\"\n\n#include <scsi/scsicam.h>\n\n#define VER_MAJOR 2\n#define VER_MINOR 0\n#define VER_PATCH 6\n\n#ifdef USE_DMAC\n  \n#define INIT_DEVCON0\t(DEVCON0_RQL|DEVCON0_EXW|DEVCON0_CMP)\n#define INIT_DEVCON1\t(DEVCON1_BHLD)\n#define DMAC_READ\t(MODECON_READ)\n#define DMAC_WRITE\t(MODECON_WRITE)\n#define INIT_SBICDMA\t(CTRL_DMABURST)\n\n#define scsi_xferred\thave_data_in\n\n \n#define DMAC_BUFFER_SIZE\t65536\n#endif\n\n#define STATUS_BUFFER_TO_PRINT\t24\n\nunsigned int sdtr_period = SDTR_PERIOD;\nunsigned int sdtr_size   = SDTR_SIZE;\n\nstatic void acornscsi_done(AS_Host *host, struct scsi_cmnd **SCpntp,\n\t\t\t   unsigned int result);\nstatic int acornscsi_reconnect_finish(AS_Host *host);\nstatic void acornscsi_dma_cleanup(AS_Host *host);\nstatic void acornscsi_abortcmd(AS_Host *host);\n\n \n\n \n#define SBIC_REGIDX\t0x2000\n#define SBIC_REGVAL\t0x2004\n#define DMAC_OFFSET\t0x3000\n\n \n#define INT_REG\t\t0x2000\n#define PAGE_REG\t0x3000\n\nstatic inline void sbic_arm_write(AS_Host *host, unsigned int reg, unsigned int value)\n{\n    writeb(reg, host->base + SBIC_REGIDX);\n    writeb(value, host->base + SBIC_REGVAL);\n}\n\nstatic inline int sbic_arm_read(AS_Host *host, unsigned int reg)\n{\n    if(reg == SBIC_ASR)\n\t   return readl(host->base + SBIC_REGIDX) & 255;\n    writeb(reg, host->base + SBIC_REGIDX);\n    return readl(host->base + SBIC_REGVAL) & 255;\n}\n\n#define sbic_arm_writenext(host, val)\twriteb((val), (host)->base + SBIC_REGVAL)\n#define sbic_arm_readnext(host) \treadb((host)->base + SBIC_REGVAL)\n\n#ifdef USE_DMAC\n#define dmac_read(host,reg) \\\n\treadb((host)->base + DMAC_OFFSET + ((reg) << 2))\n\n#define dmac_write(host,reg,value) \\\n\t({ writeb((value), (host)->base + DMAC_OFFSET + ((reg) << 2)); })\n\n#define dmac_clearintr(host) \twriteb(0, (host)->fast + INT_REG)\n\nstatic inline unsigned int dmac_address(AS_Host *host)\n{\n    return dmac_read(host, DMAC_TXADRHI) << 16 |\n\t   dmac_read(host, DMAC_TXADRMD) << 8 |\n\t   dmac_read(host, DMAC_TXADRLO);\n}\n\nstatic\nvoid acornscsi_dumpdma(AS_Host *host, char *where)\n{\n\tunsigned int mode, addr, len;\n\n\tmode = dmac_read(host, DMAC_MODECON);\n\taddr = dmac_address(host);\n\tlen  = dmac_read(host, DMAC_TXCNTHI) << 8 |\n\t       dmac_read(host, DMAC_TXCNTLO);\n\n\tprintk(\"scsi%d: %s: DMAC %02x @%06x+%04x msk %02x, \",\n\t\thost->host->host_no, where,\n\t\tmode, addr, (len + 1) & 0xffff,\n\t\tdmac_read(host, DMAC_MASKREG));\n\n\tprintk(\"DMA @%06x, \", host->dma.start_addr);\n\tprintk(\"BH @%p +%04x, \", host->scsi.SCp.ptr,\n\t\thost->scsi.SCp.this_residual);\n\tprintk(\"DT @+%04x ST @+%04x\", host->dma.transferred,\n\t\thost->scsi.SCp.scsi_xferred);\n\tprintk(\"\\n\");\n}\n#endif\n\nstatic\nunsigned long acornscsi_sbic_xfcount(AS_Host *host)\n{\n    unsigned long length;\n\n    length = sbic_arm_read(host, SBIC_TRANSCNTH) << 16;\n    length |= sbic_arm_readnext(host) << 8;\n    length |= sbic_arm_readnext(host);\n\n    return length;\n}\n\nstatic int\nacornscsi_sbic_wait(AS_Host *host, int stat_mask, int stat, int timeout, char *msg)\n{\n\tint asr;\n\n\tdo {\n\t\tasr = sbic_arm_read(host, SBIC_ASR);\n\n\t\tif ((asr & stat_mask) == stat)\n\t\t\treturn 0;\n\n\t\tudelay(1);\n\t} while (--timeout);\n\n\tprintk(\"scsi%d: timeout while %s\\n\", host->host->host_no, msg);\n\n\treturn -1;\n}\n\nstatic\nint acornscsi_sbic_issuecmd(AS_Host *host, int command)\n{\n    if (acornscsi_sbic_wait(host, ASR_CIP, 0, 1000, \"issuing command\"))\n\treturn -1;\n\n    sbic_arm_write(host, SBIC_CMND, command);\n\n    return 0;\n}\n\nstatic void\nacornscsi_csdelay(unsigned int cs)\n{\n    unsigned long target_jiffies, flags;\n\n    target_jiffies = jiffies + 1 + cs * HZ / 100;\n\n    local_save_flags(flags);\n    local_irq_enable();\n\n    while (time_before(jiffies, target_jiffies)) barrier();\n\n    local_irq_restore(flags);\n}\n\nstatic\nvoid acornscsi_resetcard(AS_Host *host)\n{\n    unsigned int i, timeout;\n\n     \n    host->card.page_reg = 0x80;\n    writeb(host->card.page_reg, host->fast + PAGE_REG);\n\n     \n    acornscsi_csdelay(3);\n\n    host->card.page_reg = 0;\n    writeb(host->card.page_reg, host->fast + PAGE_REG);\n\n     \n    timeout = 1000;\n    do {\n\tif (readb(host->fast + INT_REG) & 8)\n\t    break;\n\tudelay(1);\n    } while (--timeout);\n\n    if (timeout == 0)\n\tprintk(\"scsi%d: timeout while resetting card\\n\",\n\t\thost->host->host_no);\n\n    sbic_arm_read(host, SBIC_ASR);\n    sbic_arm_read(host, SBIC_SSR);\n\n     \n    sbic_arm_write(host, SBIC_OWNID, OWNID_EAF | host->host->this_id);\n    sbic_arm_write(host, SBIC_CMND, CMND_RESET);\n\n     \n    timeout = 1000;\n    do {\n\tif (readb(host->fast + INT_REG) & 8)\n\t    break;\n\tudelay(1);\n    } while (--timeout);\n\n    if (timeout == 0)\n\tprintk(\"scsi%d: timeout while resetting card\\n\",\n\t\thost->host->host_no);\n\n    sbic_arm_read(host, SBIC_ASR);\n    if (sbic_arm_read(host, SBIC_SSR) != 0x01)\n\tprintk(KERN_CRIT \"scsi%d: WD33C93A didn't give enhanced reset interrupt\\n\",\n\t\thost->host->host_no);\n\n    sbic_arm_write(host, SBIC_CTRL, INIT_SBICDMA | CTRL_IDI);\n    sbic_arm_write(host, SBIC_TIMEOUT, TIMEOUT_TIME);\n    sbic_arm_write(host, SBIC_SYNCHTRANSFER, SYNCHTRANSFER_2DBA);\n    sbic_arm_write(host, SBIC_SOURCEID, SOURCEID_ER | SOURCEID_DSP);\n\n    host->card.page_reg = 0x40;\n    writeb(host->card.page_reg, host->fast + PAGE_REG);\n\n     \n    dmac_write(host, DMAC_INIT, 0);\n#ifdef USE_DMAC\n    dmac_write(host, DMAC_INIT, INIT_8BIT);\n    dmac_write(host, DMAC_CHANNEL, CHANNEL_0);\n    dmac_write(host, DMAC_DEVCON0, INIT_DEVCON0);\n    dmac_write(host, DMAC_DEVCON1, INIT_DEVCON1);\n#endif\n\n    host->SCpnt = NULL;\n    host->scsi.phase = PHASE_IDLE;\n    host->scsi.disconnectable = 0;\n\n    memset(host->busyluns, 0, sizeof(host->busyluns));\n\n    for (i = 0; i < 8; i++) {\n\thost->device[i].sync_state = SYNC_NEGOCIATE;\n\thost->device[i].disconnect_ok = 1;\n    }\n\n     \n    acornscsi_csdelay(25);\n}\n\n \n#ifdef CONFIG_ACORNSCSI_CONSTANTS\nstatic char *acornscsi_interrupttype[] = {\n  \"rst\",  \"suc\",  \"p/a\",  \"3\",\n  \"term\", \"5\",\t  \"6\",\t  \"7\",\n  \"serv\", \"9\",\t  \"a\",\t  \"b\",\n  \"c\",\t  \"d\",\t  \"e\",\t  \"f\"\n};\n\nstatic signed char acornscsi_map[] = {\n  0,  1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,\n -1,  2, -1, -1,  -1, -1,  3, -1,   4,\t5,  6,\t7,   8,  9, 10, 11,\n 12, 13, 14, -1,  -1, -1, -1, -1,   4,\t5,  6,\t7,   8,  9, 10, 11,\n -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,\n 15, 16, 17, 18,  19, -1, -1, 20,   4,\t5,  6,\t7,   8,  9, 10, 11,\n -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,\n -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,\n -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,\n 21, 22, -1, -1,  -1, 23, -1, -1,   4,\t5,  6,\t7,   8,  9, 10, 11,\n -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,\n -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,\n -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,\n -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,\n -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,\n -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,\n -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1\n};      \n\nstatic char *acornscsi_interruptcode[] = {\n     \n    \"reset - normal mode\",\t \n    \"reset - advanced mode\",\t \n\n     \n    \"sel\",\t\t\t \n    \"sel+xfer\", \t\t \n    \"data-out\", \t\t \n    \"data-in\",\t\t\t \n    \"cmd\",\t\t\t \n    \"stat\",\t\t\t \n    \"??-out\",\t\t\t \n    \"??-in\",\t\t\t \n    \"msg-out\",\t\t\t \n    \"msg-in\",\t\t\t \n\n     \n    \"/ACK asserted\",\t\t \n    \"save-data-ptr\",\t\t \n    \"{re}sel\",\t\t\t \n\n     \n    \"inv cmd\",\t\t\t \n    \"unexpected disconnect\",\t \n    \"sel timeout\",\t\t \n    \"P err\",\t\t\t \n    \"P err+ATN\",\t\t \n    \"bad status byte\",\t\t \n\n     \n    \"resel, no id\",\t\t \n    \"resel\",\t\t\t \n    \"discon\",\t\t\t \n};\n\nstatic\nvoid print_scsi_status(unsigned int ssr)\n{\n    if (acornscsi_map[ssr] != -1)\n\tprintk(\"%s:%s\",\n\t\tacornscsi_interrupttype[(ssr >> 4)],\n\t\tacornscsi_interruptcode[acornscsi_map[ssr]]);\n    else\n\tprintk(\"%X:%X\", ssr >> 4, ssr & 0x0f);    \n}    \n#endif\n\nstatic\nvoid print_sbic_status(int asr, int ssr, int cmdphase)\n{\n#ifdef CONFIG_ACORNSCSI_CONSTANTS\n    printk(\"sbic: %c%c%c%c%c%c \",\n\t    asr & ASR_INT ? 'I' : 'i',\n\t    asr & ASR_LCI ? 'L' : 'l',\n\t    asr & ASR_BSY ? 'B' : 'b',\n\t    asr & ASR_CIP ? 'C' : 'c',\n\t    asr & ASR_PE  ? 'P' : 'p',\n\t    asr & ASR_DBR ? 'D' : 'd');\n    printk(\"scsi: \");\n    print_scsi_status(ssr);\n    printk(\" ph %02X\\n\", cmdphase);\n#else\n    printk(\"sbic: %02X scsi: %X:%X ph: %02X\\n\",\n\t    asr, (ssr & 0xf0)>>4, ssr & 0x0f, cmdphase);\n#endif\n}\n\nstatic void\nacornscsi_dumplogline(AS_Host *host, int target, int line)\n{\n\tunsigned long prev;\n\tsigned int ptr;\n\n\tptr = host->status_ptr[target] - STATUS_BUFFER_TO_PRINT;\n\tif (ptr < 0)\n\t\tptr += STATUS_BUFFER_SIZE;\n\n\tprintk(\"%c: %3s:\", target == 8 ? 'H' : '0' + target,\n\t\tline == 0 ? \"ph\" : line == 1 ? \"ssr\" : \"int\");\n\n\tprev = host->status[target][ptr].when;\n\n\tfor (; ptr != host->status_ptr[target]; ptr = (ptr + 1) & (STATUS_BUFFER_SIZE - 1)) {\n\t\tunsigned long time_diff;\n\n\t\tif (!host->status[target][ptr].when)\n\t\t\tcontinue;\n\n\t\tswitch (line) {\n\t\tcase 0:\n\t\t\tprintk(\"%c%02X\", host->status[target][ptr].irq ? '-' : ' ',\n\t\t\t\t\t host->status[target][ptr].ph);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tprintk(\" %02X\", host->status[target][ptr].ssr);\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\ttime_diff = host->status[target][ptr].when - prev;\n\t\t\tprev = host->status[target][ptr].when;\n\t\t\tif (time_diff == 0)\n\t\t\t\tprintk(\"==^\");\n\t\t\telse if (time_diff >= 100)\n\t\t\t\tprintk(\"   \");\n\t\t\telse\n\t\t\t\tprintk(\" %02ld\", time_diff);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintk(\"\\n\");\n}\n\nstatic\nvoid acornscsi_dumplog(AS_Host *host, int target)\n{\n    do {\n\tacornscsi_dumplogline(host, target, 0);\n\tacornscsi_dumplogline(host, target, 1);\n\tacornscsi_dumplogline(host, target, 2);\n\n\tif (target == 8)\n\t    break;\n\n\ttarget = 8;\n    } while (1);\n}\n\nstatic\nchar acornscsi_target(AS_Host *host)\n{\n\tif (host->SCpnt)\n\t\treturn '0' + host->SCpnt->device->id;\n\treturn 'H';\n}\n\n \nstatic inline\ncmdtype_t acornscsi_cmdtype(int command)\n{\n    switch (command) {\n    case WRITE_6:  case WRITE_10:  case WRITE_12:\n\treturn CMD_WRITE;\n    case READ_6:   case READ_10:   case READ_12:\n\treturn CMD_READ;\n    default:\n\treturn CMD_MISC;\n    }\n}\n\n \nstatic\ndatadir_t acornscsi_datadirection(int command)\n{\n    switch (command) {\n    case CHANGE_DEFINITION:\tcase COMPARE:\t\tcase COPY:\n    case COPY_VERIFY:\t\tcase LOG_SELECT:\tcase MODE_SELECT:\n    case MODE_SELECT_10:\tcase SEND_DIAGNOSTIC:\tcase WRITE_BUFFER:\n    case FORMAT_UNIT:\t\tcase REASSIGN_BLOCKS:\tcase RESERVE:\n    case SEARCH_EQUAL:\t\tcase SEARCH_HIGH:\tcase SEARCH_LOW:\n    case WRITE_6:\t\tcase WRITE_10:\t\tcase WRITE_VERIFY:\n    case UPDATE_BLOCK:\t\tcase WRITE_LONG:\tcase WRITE_SAME:\n    case SEARCH_HIGH_12:\tcase SEARCH_EQUAL_12:\tcase SEARCH_LOW_12:\n    case WRITE_12:\t\tcase WRITE_VERIFY_12:\tcase SET_WINDOW:\n    case MEDIUM_SCAN:\t\tcase SEND_VOLUME_TAG:\tcase 0xea:\n\treturn DATADIR_OUT;\n    default:\n\treturn DATADIR_IN;\n    }\n}\n\n \nstatic struct sync_xfer_tbl {\n    unsigned int period_ns;\n    unsigned char reg_value;\n} sync_xfer_table[] = {\n    {\t1, 0x20 },    { 249, 0x20 },\t{ 374, 0x30 },\n    { 499, 0x40 },    { 624, 0x50 },\t{ 749, 0x60 },\n    { 874, 0x70 },    { 999, 0x00 },\t{   0,\t  0 }\n};\n\n \nstatic\nint acornscsi_getperiod(unsigned char syncxfer)\n{\n    int i;\n\n    syncxfer &= 0xf0;\n    if (syncxfer == 0x10)\n\tsyncxfer = 0;\n\n    for (i = 1; sync_xfer_table[i].period_ns; i++)\n\tif (syncxfer == sync_xfer_table[i].reg_value)\n\t    return sync_xfer_table[i].period_ns;\n    return 0;\n}\n\n \nstatic inline\nint round_period(unsigned int period)\n{\n    int i;\n\n    for (i = 1; sync_xfer_table[i].period_ns; i++) {\n\tif ((period <= sync_xfer_table[i].period_ns) &&\n\t    (period > sync_xfer_table[i - 1].period_ns))\n\t    return i;\n    }\n    return 7;\n}\n\n \nstatic\nunsigned char __maybe_unused calc_sync_xfer(unsigned int period,\n\t\t\t\t\t    unsigned int offset)\n{\n    return sync_xfer_table[round_period(period)].reg_value |\n\t\t((offset < SDTR_SIZE) ? offset : SDTR_SIZE);\n}\n\n \n \nstatic\nintr_ret_t acornscsi_kick(AS_Host *host)\n{\n    int from_queue = 0;\n    struct scsi_cmnd *SCpnt;\n\n     \n    SCpnt = host->origSCpnt;\n    host->origSCpnt = NULL;\n\n     \n    if (!SCpnt) {\n\tSCpnt = queue_remove_exclude(&host->queues.issue, host->busyluns);\n\tif (!SCpnt)\n\t    return INTR_IDLE;\n\n\tfrom_queue = 1;\n    }\n\n    if (host->scsi.disconnectable && host->SCpnt) {\n\tqueue_add_cmd_tail(&host->queues.disconnected, host->SCpnt);\n\thost->scsi.disconnectable = 0;\n#if (DEBUG & (DEBUG_QUEUES|DEBUG_DISCON))\n\tDBG(host->SCpnt, printk(\"scsi%d.%c: moved command to disconnected queue\\n\",\n\t\thost->host->host_no, acornscsi_target(host)));\n#endif\n\thost->SCpnt = NULL;\n    }\n\n     \n    if (!(sbic_arm_read(host, SBIC_ASR) & (ASR_INT|ASR_BSY|ASR_CIP))) {\n\tsbic_arm_write(host, SBIC_DESTID, SCpnt->device->id);\n\tsbic_arm_write(host, SBIC_CMND, CMND_SELWITHATN);\n    }\n\n     \n    host->scsi.phase = PHASE_CONNECTING;\n    host->SCpnt = SCpnt;\n    host->scsi.SCp = *arm_scsi_pointer(SCpnt);\n    host->dma.xfer_setup = 0;\n    host->dma.xfer_required = 0;\n    host->dma.xfer_done = 0;\n\n#if (DEBUG & (DEBUG_ABORT|DEBUG_CONNECT))\n    DBG(SCpnt,printk(\"scsi%d.%c: starting cmd %02X\\n\",\n\t    host->host->host_no, '0' + SCpnt->device->id,\n\t    SCpnt->cmnd[0]));\n#endif\n\n    if (from_queue) {\n\t    set_bit(SCpnt->device->id * 8 +\n\t\t    (u8)(SCpnt->device->lun & 0x07), host->busyluns);\n\n\thost->stats.removes += 1;\n\n\tswitch (acornscsi_cmdtype(SCpnt->cmnd[0])) {\n\tcase CMD_WRITE:\n\t    host->stats.writes += 1;\n\t    break;\n\tcase CMD_READ:\n\t    host->stats.reads += 1;\n\t    break;\n\tcase CMD_MISC:\n\t    host->stats.miscs += 1;\n\t    break;\n\t}\n    }\n\n    return INTR_PROCESSING;\n}    \n\n \nstatic void acornscsi_done(AS_Host *host, struct scsi_cmnd **SCpntp,\n\t\t\t   unsigned int result)\n{\n\tstruct scsi_cmnd *SCpnt = *SCpntp;\n\n     \n    sbic_arm_write(host, SBIC_SOURCEID, SOURCEID_ER | SOURCEID_DSP);\n\n    host->stats.fins += 1;\n\n    if (SCpnt) {\n\t*SCpntp = NULL;\n\n\tacornscsi_dma_cleanup(host);\n\n\tset_host_byte(SCpnt, result);\n\tif (result == DID_OK)\n\t\tscsi_msg_to_host_byte(SCpnt, host->scsi.SCp.Message);\n\tset_status_byte(SCpnt, host->scsi.SCp.Status);\n\n\t \n\tif (result == DID_OK) {\n\t\tint xfer_warn = 0;\n\n\t\tif (SCpnt->underflow == 0) {\n\t\t\tif (host->scsi.SCp.ptr &&\n\t\t\t    acornscsi_cmdtype(SCpnt->cmnd[0]) != CMD_MISC)\n\t\t\t\txfer_warn = 1;\n\t\t} else {\n\t\t\tif (host->scsi.SCp.scsi_xferred < SCpnt->underflow ||\n\t\t\t    host->scsi.SCp.scsi_xferred != host->dma.transferred)\n\t\t\t\txfer_warn = 1;\n\t\t}\n\n\t\t \n\t\tif (host->dma.xfer_done)\n\t\t\txfer_warn = 0;\n\n\t\tif (xfer_warn) {\n\t\t    switch (get_status_byte(SCpnt)) {\n\t\t    case SAM_STAT_CHECK_CONDITION:\n\t\t    case SAM_STAT_COMMAND_TERMINATED:\n\t\t    case SAM_STAT_BUSY:\n\t\t    case SAM_STAT_TASK_SET_FULL:\n\t\t    case SAM_STAT_RESERVATION_CONFLICT:\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tscmd_printk(KERN_ERR, SCpnt,\n\t\t\t\t    \"incomplete data transfer detected: \"\n\t\t\t\t    \"result=%08X\", SCpnt->result);\n\t\t\tscsi_print_command(SCpnt);\n\t\t\tacornscsi_dumpdma(host, \"done\");\n\t\t\tacornscsi_dumplog(host, SCpnt->device->id);\n\t\t\tset_host_byte(SCpnt, DID_ERROR);\n\t\t    }\n\t\t}\n\t}\n\n\tclear_bit(SCpnt->device->id * 8 +\n\t\t  (u8)(SCpnt->device->lun & 0x7), host->busyluns);\n\n\tscsi_done(SCpnt);\n    } else\n\tprintk(\"scsi%d: null command in acornscsi_done\", host->host->host_no);\n\n    host->scsi.phase = PHASE_IDLE;\n}\n\n \n \nstatic\nvoid acornscsi_data_updateptr(AS_Host *host, struct scsi_pointer *SCp, unsigned int length)\n{\n    SCp->ptr += length;\n    SCp->this_residual -= length;\n\n    if (SCp->this_residual == 0 && next_SCp(SCp) == 0)\n\thost->dma.xfer_done = 1;\n}\n\n \nstatic\nvoid acornscsi_data_read(AS_Host *host, char *ptr,\n\t\t\t\t unsigned int start_addr, unsigned int length)\n{\n    extern void __acornscsi_in(void __iomem *, char *buf, int len);\n    unsigned int page, offset, len = length;\n\n    page = (start_addr >> 12);\n    offset = start_addr & ((1 << 12) - 1);\n\n    writeb((page & 0x3f) | host->card.page_reg, host->fast + PAGE_REG);\n\n    while (len > 0) {\n\tunsigned int this_len;\n\n\tif (len + offset > (1 << 12))\n\t    this_len = (1 << 12) - offset;\n\telse\n\t    this_len = len;\n\n\t__acornscsi_in(host->base + (offset << 1), ptr, this_len);\n\n\toffset += this_len;\n\tptr += this_len;\n\tlen -= this_len;\n\n\tif (offset == (1 << 12)) {\n\t    offset = 0;\n\t    page ++;\n\t    writeb((page & 0x3f) | host->card.page_reg, host->fast + PAGE_REG);\n\t}\n    }\n    writeb(host->card.page_reg, host->fast + PAGE_REG);\n}\n\n \nstatic\nvoid acornscsi_data_write(AS_Host *host, char *ptr,\n\t\t\t\t unsigned int start_addr, unsigned int length)\n{\n    extern void __acornscsi_out(void __iomem *, char *buf, int len);\n    unsigned int page, offset, len = length;\n\n    page = (start_addr >> 12);\n    offset = start_addr & ((1 << 12) - 1);\n\n    writeb((page & 0x3f) | host->card.page_reg, host->fast + PAGE_REG);\n\n    while (len > 0) {\n\tunsigned int this_len;\n\n\tif (len + offset > (1 << 12))\n\t    this_len = (1 << 12) - offset;\n\telse\n\t    this_len = len;\n\n\t__acornscsi_out(host->base + (offset << 1), ptr, this_len);\n\n\toffset += this_len;\n\tptr += this_len;\n\tlen -= this_len;\n\n\tif (offset == (1 << 12)) {\n\t    offset = 0;\n\t    page ++;\n\t    writeb((page & 0x3f) | host->card.page_reg, host->fast + PAGE_REG);\n\t}\n    }\n    writeb(host->card.page_reg, host->fast + PAGE_REG);\n}\n\n \n#ifdef USE_DMAC\n \nstatic inline\nvoid acornscsi_dma_stop(AS_Host *host)\n{\n    dmac_write(host, DMAC_MASKREG, MASK_ON);\n    dmac_clearintr(host);\n\n#if (DEBUG & DEBUG_DMA)\n    DBG(host->SCpnt, acornscsi_dumpdma(host, \"stop\"));\n#endif\n}\n\n \nstatic\nvoid acornscsi_dma_setup(AS_Host *host, dmadir_t direction)\n{\n    unsigned int address, length, mode;\n\n    host->dma.direction = direction;\n\n    dmac_write(host, DMAC_MASKREG, MASK_ON);\n\n    if (direction == DMA_OUT) {\n#if (DEBUG & DEBUG_NO_WRITE)\n\tif (NO_WRITE & (1 << host->SCpnt->device->id)) {\n\t    printk(KERN_CRIT \"scsi%d.%c: I can't handle DMA_OUT!\\n\",\n\t\t    host->host->host_no, acornscsi_target(host));\n\t    return;\n\t}\n#endif\n\tmode = DMAC_WRITE;\n    } else\n\tmode = DMAC_READ;\n\n     \n    length = min_t(unsigned int, host->scsi.SCp.this_residual, DMAC_BUFFER_SIZE / 2);\n    if (length) {\n\thost->dma.start_addr = address = host->dma.free_addr;\n\thost->dma.free_addr = (host->dma.free_addr + length) &\n\t\t\t\t(DMAC_BUFFER_SIZE - 1);\n\n\t \n\tif (direction == DMA_OUT)\n\t    acornscsi_data_write(host, host->scsi.SCp.ptr, host->dma.start_addr,\n\t\t\t\tlength);\n\n\tlength -= 1;\n\tdmac_write(host, DMAC_TXCNTLO, length);\n\tdmac_write(host, DMAC_TXCNTHI, length >> 8);\n\tdmac_write(host, DMAC_TXADRLO, address);\n\tdmac_write(host, DMAC_TXADRMD, address >> 8);\n\tdmac_write(host, DMAC_TXADRHI, 0);\n\tdmac_write(host, DMAC_MODECON, mode);\n\tdmac_write(host, DMAC_MASKREG, MASK_OFF);\n\n#if (DEBUG & DEBUG_DMA)\n\tDBG(host->SCpnt, acornscsi_dumpdma(host, \"strt\"));\n#endif\n\thost->dma.xfer_setup = 1;\n    }\n}\n\n \nstatic\nvoid acornscsi_dma_cleanup(AS_Host *host)\n{\n    dmac_write(host, DMAC_MASKREG, MASK_ON);\n    dmac_clearintr(host);\n\n     \n    if (host->dma.xfer_required) {\n\thost->dma.xfer_required = 0;\n\tif (host->dma.direction == DMA_IN)\n\t    acornscsi_data_read(host, host->dma.xfer_ptr,\n\t\t\t\t host->dma.xfer_start, host->dma.xfer_length);\n    }\n\n     \n    if (host->dma.xfer_setup) {\n\tunsigned int transferred;\n\n\thost->dma.xfer_setup = 0;\n\n#if (DEBUG & DEBUG_DMA)\n\tDBG(host->SCpnt, acornscsi_dumpdma(host, \"cupi\"));\n#endif\n\n\t \n\ttransferred = dmac_address(host) - host->dma.start_addr;\n\thost->dma.transferred += transferred;\n\n\tif (host->dma.direction == DMA_IN)\n\t    acornscsi_data_read(host, host->scsi.SCp.ptr,\n\t\t\t\t host->dma.start_addr, transferred);\n\n\t \n\tacornscsi_data_updateptr(host, &host->scsi.SCp, transferred);\n#if (DEBUG & DEBUG_DMA)\n\tDBG(host->SCpnt, acornscsi_dumpdma(host, \"cupo\"));\n#endif\n    }\n}\n\n \nstatic\nvoid acornscsi_dma_intr(AS_Host *host)\n{\n    unsigned int address, length, transferred;\n\n#if (DEBUG & DEBUG_DMA)\n    DBG(host->SCpnt, acornscsi_dumpdma(host, \"inti\"));\n#endif\n\n    dmac_write(host, DMAC_MASKREG, MASK_ON);\n    dmac_clearintr(host);\n\n     \n    transferred = dmac_address(host) - host->dma.start_addr;\n    host->dma.transferred += transferred;\n\n     \n    if (host->dma.direction == DMA_IN) {\n\thost->dma.xfer_start = host->dma.start_addr;\n\thost->dma.xfer_length = transferred;\n\thost->dma.xfer_ptr = host->scsi.SCp.ptr;\n\thost->dma.xfer_required = 1;\n    }\n\n    acornscsi_data_updateptr(host, &host->scsi.SCp, transferred);\n\n     \n    length = min_t(unsigned int, host->scsi.SCp.this_residual, DMAC_BUFFER_SIZE / 2);\n    if (length) {\n\thost->dma.start_addr = address = host->dma.free_addr;\n\thost->dma.free_addr = (host->dma.free_addr + length) &\n\t\t\t\t(DMAC_BUFFER_SIZE - 1);\n\n\t \n\tif (host->dma.direction == DMA_OUT)\n\t    acornscsi_data_write(host, host->scsi.SCp.ptr, host->dma.start_addr,\n\t\t\t\tlength);\n\n\tlength -= 1;\n\tdmac_write(host, DMAC_TXCNTLO, length);\n\tdmac_write(host, DMAC_TXCNTHI, length >> 8);\n\tdmac_write(host, DMAC_TXADRLO, address);\n\tdmac_write(host, DMAC_TXADRMD, address >> 8);\n\tdmac_write(host, DMAC_TXADRHI, 0);\n\tdmac_write(host, DMAC_MASKREG, MASK_OFF);\n\n#if (DEBUG & DEBUG_DMA)\n\tDBG(host->SCpnt, acornscsi_dumpdma(host, \"into\"));\n#endif\n    } else {\n\thost->dma.xfer_setup = 0;\n#if 0\n\t \n\tif (dmac_read(host, DMAC_STATUS) & STATUS_RQ0) {\n\t    acornscsi_abortcmd(host);\n\n\t    dmac_write(host, DMAC_TXCNTLO, 0);\n\t    dmac_write(host, DMAC_TXCNTHI, 0);\n\t    dmac_write(host, DMAC_TXADRLO, 0);\n\t    dmac_write(host, DMAC_TXADRMD, 0);\n\t    dmac_write(host, DMAC_TXADRHI, 0);\n\t    dmac_write(host, DMAC_MASKREG, MASK_OFF);\n\t}\n#endif\n    }\n}\n\n \nstatic\nvoid acornscsi_dma_xfer(AS_Host *host)\n{\n    host->dma.xfer_required = 0;\n\n    if (host->dma.direction == DMA_IN)\n\tacornscsi_data_read(host, host->dma.xfer_ptr,\n\t\t\t\thost->dma.xfer_start, host->dma.xfer_length);\n}\n\n \nstatic\nvoid acornscsi_dma_adjust(AS_Host *host)\n{\n    if (host->dma.xfer_setup) {\n\tsigned long transferred;\n#if (DEBUG & (DEBUG_DMA|DEBUG_WRITE))\n\tDBG(host->SCpnt, acornscsi_dumpdma(host, \"adji\"));\n#endif\n\t \n\ttransferred = host->scsi.SCp.scsi_xferred - host->dma.transferred;\n\tif (transferred < 0)\n\t    printk(\"scsi%d.%c: Ack! DMA write correction %ld < 0!\\n\",\n\t\t    host->host->host_no, acornscsi_target(host), transferred);\n\telse if (transferred == 0)\n\t    host->dma.xfer_setup = 0;\n\telse {\n\t    transferred += host->dma.start_addr;\n\t    dmac_write(host, DMAC_TXADRLO, transferred);\n\t    dmac_write(host, DMAC_TXADRMD, transferred >> 8);\n\t    dmac_write(host, DMAC_TXADRHI, transferred >> 16);\n#if (DEBUG & (DEBUG_DMA|DEBUG_WRITE))\n\t    DBG(host->SCpnt, acornscsi_dumpdma(host, \"adjo\"));\n#endif\n\t}\n    }\n}\n#endif\n\n \nstatic int\nacornscsi_write_pio(AS_Host *host, char *bytes, int *ptr, int len, unsigned int max_timeout)\n{\n\tunsigned int asr, timeout = max_timeout;\n\tint my_ptr = *ptr;\n\n\twhile (my_ptr < len) {\n\t\tasr = sbic_arm_read(host, SBIC_ASR);\n\n\t\tif (asr & ASR_DBR) {\n\t\t\ttimeout = max_timeout;\n\n\t\t\tsbic_arm_write(host, SBIC_DATA, bytes[my_ptr++]);\n\t\t} else if (asr & ASR_INT)\n\t\t\tbreak;\n\t\telse if (--timeout == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\t*ptr = my_ptr;\n\n\treturn (timeout == 0) ? -1 : 0;\n}\n\n \nstatic void\nacornscsi_sendcommand(AS_Host *host)\n{\n\tstruct scsi_cmnd *SCpnt = host->SCpnt;\n\n    sbic_arm_write(host, SBIC_TRANSCNTH, 0);\n    sbic_arm_writenext(host, 0);\n    sbic_arm_writenext(host, SCpnt->cmd_len - host->scsi.SCp.sent_command);\n\n    acornscsi_sbic_issuecmd(host, CMND_XFERINFO);\n\n    if (acornscsi_write_pio(host, SCpnt->cmnd,\n\t(int *)&host->scsi.SCp.sent_command, SCpnt->cmd_len, 1000000))\n\tprintk(\"scsi%d: timeout while sending command\\n\", host->host->host_no);\n\n    host->scsi.phase = PHASE_COMMAND;\n}\n\nstatic\nvoid acornscsi_sendmessage(AS_Host *host)\n{\n    unsigned int message_length = msgqueue_msglength(&host->scsi.msgs);\n    unsigned int msgnr;\n    struct message *msg;\n\n#if (DEBUG & DEBUG_MESSAGES)\n    printk(\"scsi%d.%c: sending message \",\n\t    host->host->host_no, acornscsi_target(host));\n#endif\n\n    switch (message_length) {\n    case 0:\n\tacornscsi_sbic_issuecmd(host, CMND_XFERINFO | CMND_SBT);\n\n\tacornscsi_sbic_wait(host, ASR_DBR, ASR_DBR, 1000, \"sending message 1\");\n\n\tsbic_arm_write(host, SBIC_DATA, NOP);\n\n\thost->scsi.last_message = NOP;\n#if (DEBUG & DEBUG_MESSAGES)\n\tprintk(\"NOP\");\n#endif\n\tbreak;\n\n    case 1:\n\tacornscsi_sbic_issuecmd(host, CMND_XFERINFO | CMND_SBT);\n\tmsg = msgqueue_getmsg(&host->scsi.msgs, 0);\n\n\tacornscsi_sbic_wait(host, ASR_DBR, ASR_DBR, 1000, \"sending message 2\");\n\n\tsbic_arm_write(host, SBIC_DATA, msg->msg[0]);\n\n\thost->scsi.last_message = msg->msg[0];\n#if (DEBUG & DEBUG_MESSAGES)\n\tspi_print_msg(msg->msg);\n#endif\n\tbreak;\n\n    default:\n\t \n\tsbic_arm_write(host, SBIC_TRANSCNTH, 0);\n\tsbic_arm_writenext(host, 0);\n\tsbic_arm_writenext(host, message_length);\n\tacornscsi_sbic_issuecmd(host, CMND_XFERINFO);\n\n\tmsgnr = 0;\n\twhile ((msg = msgqueue_getmsg(&host->scsi.msgs, msgnr++)) != NULL) {\n\t    unsigned int i;\n#if (DEBUG & DEBUG_MESSAGES)\n\t    spi_print_msg(msg);\n#endif\n\t    i = 0;\n\t    if (acornscsi_write_pio(host, msg->msg, &i, msg->length, 1000000))\n\t\tprintk(\"scsi%d: timeout while sending message\\n\", host->host->host_no);\n\n\t    host->scsi.last_message = msg->msg[0];\n\t    if (msg->msg[0] == EXTENDED_MESSAGE)\n\t\thost->scsi.last_message |= msg->msg[2] << 8;\n\n\t    if (i != msg->length)\n\t\tbreak;\n\t}\n\tbreak;\n    }\n#if (DEBUG & DEBUG_MESSAGES)\n    printk(\"\\n\");\n#endif\n}\n\n \nstatic\nvoid acornscsi_readstatusbyte(AS_Host *host)\n{\n    acornscsi_sbic_issuecmd(host, CMND_XFERINFO|CMND_SBT);\n    acornscsi_sbic_wait(host, ASR_DBR, ASR_DBR, 1000, \"reading status byte\");\n    host->scsi.SCp.Status = sbic_arm_read(host, SBIC_DATA);\n}\n\n \nstatic\nunsigned char acornscsi_readmessagebyte(AS_Host *host)\n{\n    unsigned char message;\n\n    acornscsi_sbic_issuecmd(host, CMND_XFERINFO | CMND_SBT);\n\n    acornscsi_sbic_wait(host, ASR_DBR, ASR_DBR, 1000, \"for message byte\");\n\n    message = sbic_arm_read(host, SBIC_DATA);\n\n     \n    acornscsi_sbic_wait(host, ASR_INT, ASR_INT, 1000, \"for interrupt after message byte\");\n\n    sbic_arm_read(host, SBIC_SSR);\n\n    return message;\n}\n\n \nstatic\nvoid acornscsi_message(AS_Host *host)\n{\n    struct scsi_pointer *scsi_pointer;\n    unsigned char message[16];\n    unsigned int msgidx = 0, msglen = 1;\n\n    do {\n\tmessage[msgidx] = acornscsi_readmessagebyte(host);\n\n\tswitch (msgidx) {\n\tcase 0:\n\t    if (message[0] == EXTENDED_MESSAGE ||\n\t\t(message[0] >= 0x20 && message[0] <= 0x2f))\n\t\tmsglen = 2;\n\t    break;\n\n\tcase 1:\n\t    if (message[0] == EXTENDED_MESSAGE)\n\t\tmsglen += message[msgidx];\n\t    break;\n\t}\n\tmsgidx += 1;\n\tif (msgidx < msglen) {\n\t    acornscsi_sbic_issuecmd(host, CMND_NEGATEACK);\n\n\t     \n\t    acornscsi_sbic_wait(host, ASR_INT, ASR_INT, 1000, \"for interrupt after negate ack\");\n\t    sbic_arm_read(host, SBIC_SSR);\n\t}\n    } while (msgidx < msglen);\n\n#if (DEBUG & DEBUG_MESSAGES)\n    printk(\"scsi%d.%c: message in: \",\n\t    host->host->host_no, acornscsi_target(host));\n    spi_print_msg(message);\n    printk(\"\\n\");\n#endif\n\n    if (host->scsi.phase == PHASE_RECONNECTED) {\n\t \n\tif (message[0] == SIMPLE_QUEUE_TAG)\n\t    host->scsi.reconnected.tag = message[1];\n\tif (acornscsi_reconnect_finish(host))\n\t    host->scsi.phase = PHASE_MSGIN;\n    }\n\n    switch (message[0]) {\n    case ABORT_TASK_SET:\n    case ABORT_TASK:\n    case COMMAND_COMPLETE:\n\tif (host->scsi.phase != PHASE_STATUSIN) {\n\t    printk(KERN_ERR \"scsi%d.%c: command complete following non-status in phase?\\n\",\n\t\t    host->host->host_no, acornscsi_target(host));\n\t    acornscsi_dumplog(host, host->SCpnt->device->id);\n\t}\n\thost->scsi.phase = PHASE_DONE;\n\thost->scsi.SCp.Message = message[0];\n\tbreak;\n\n    case SAVE_POINTERS:\n\t \n\tacornscsi_dma_cleanup(host);\n\tscsi_pointer = arm_scsi_pointer(host->SCpnt);\n\t*scsi_pointer = host->scsi.SCp;\n\tscsi_pointer->sent_command = 0;\n\thost->scsi.phase = PHASE_MSGIN;\n\tbreak;\n\n    case RESTORE_POINTERS:\n\t \n\tacornscsi_dma_cleanup(host);\n\thost->scsi.SCp = *arm_scsi_pointer(host->SCpnt);\n\thost->scsi.phase = PHASE_MSGIN;\n\tbreak;\n\n    case DISCONNECT:\n\t \n\tacornscsi_dma_cleanup(host);\n\thost->scsi.phase = PHASE_DISCONNECT;\n\tbreak;\n\n    case MESSAGE_REJECT:\n#if 0  \n\t \n\tif (host->device[host->SCpnt->device->id].sync_state == SYNC_SENT_REQUEST)\n\t    host->device[host->SCpnt->device->id].sync_state = SYNC_NEGOCIATE;\n#endif\n\n\t \n\tif (msgqueue_msglength(&host->scsi.msgs))\n\t    acornscsi_sbic_issuecmd(host, CMND_ASSERTATN);\n\n\tswitch (host->scsi.last_message) {\n\tcase EXTENDED_MESSAGE | (EXTENDED_SDTR << 8):\n\t     \n\t    printk(KERN_NOTICE \"scsi%d.%c: Using asynchronous transfer\\n\",\n\t\t    host->host->host_no, acornscsi_target(host));\n\t    host->device[host->SCpnt->device->id].sync_xfer = SYNCHTRANSFER_2DBA;\n\t    host->device[host->SCpnt->device->id].sync_state = SYNC_ASYNCHRONOUS;\n\t    sbic_arm_write(host, SBIC_SYNCHTRANSFER, host->device[host->SCpnt->device->id].sync_xfer);\n\t    break;\n\n\tdefault:\n\t    break;\n\t}\n\tbreak;\n\n    case SIMPLE_QUEUE_TAG:\n\t \n\tprintk(\"scsi%d.%c: reconnect queue tag %02X\\n\",\n\t\thost->host->host_no, acornscsi_target(host),\n\t\tmessage[1]);\n\tbreak;\n\n    case EXTENDED_MESSAGE:\n\tswitch (message[2]) {\n#ifdef CONFIG_SCSI_ACORNSCSI_SYNC\n\tcase EXTENDED_SDTR:\n\t    if (host->device[host->SCpnt->device->id].sync_state == SYNC_SENT_REQUEST) {\n\t\t \n\t\thost->device[host->SCpnt->device->id].sync_state = SYNC_COMPLETED;\n\t\tprintk(KERN_NOTICE \"scsi%d.%c: Using synchronous transfer, offset %d, %d ns\\n\",\n\t\t\thost->host->host_no, acornscsi_target(host),\n\t\t\tmessage[4], message[3] * 4);\n\t\thost->device[host->SCpnt->device->id].sync_xfer =\n\t\t\tcalc_sync_xfer(message[3] * 4, message[4]);\n\t    } else {\n\t\tunsigned char period, length;\n\t\t \n\t\tacornscsi_sbic_issuecmd(host, CMND_ASSERTATN);\n\t\tperiod = max_t(unsigned int, message[3], sdtr_period / 4);\n\t\tlength = min_t(unsigned int, message[4], sdtr_size);\n\t\tmsgqueue_addmsg(&host->scsi.msgs, 5, EXTENDED_MESSAGE, 3,\n\t\t\t\t EXTENDED_SDTR, period, length);\n\t\thost->device[host->SCpnt->device->id].sync_xfer =\n\t\t\tcalc_sync_xfer(period * 4, length);\n\t    }\n\t    sbic_arm_write(host, SBIC_SYNCHTRANSFER, host->device[host->SCpnt->device->id].sync_xfer);\n\t    break;\n#else\n\t     \n#endif\n\n\tcase EXTENDED_WDTR:\n\t     \n\tdefault:\n\t    acornscsi_sbic_issuecmd(host, CMND_ASSERTATN);\n\t    msgqueue_flush(&host->scsi.msgs);\n\t    msgqueue_addmsg(&host->scsi.msgs, 1, MESSAGE_REJECT);\n\t    break;\n\t}\n\tbreak;\n\n    default:  \n\tprintk(KERN_ERR \"scsi%d.%c: unrecognised message %02X, rejecting\\n\",\n\t\thost->host->host_no, acornscsi_target(host),\n\t\tmessage[0]);\n\tacornscsi_sbic_issuecmd(host, CMND_ASSERTATN);\n\tmsgqueue_flush(&host->scsi.msgs);\n\tmsgqueue_addmsg(&host->scsi.msgs, 1, MESSAGE_REJECT);\n\thost->scsi.phase = PHASE_MSGIN;\n\tbreak;\n    }\n    acornscsi_sbic_issuecmd(host, CMND_NEGATEACK);\n}\n\n \nstatic\nvoid acornscsi_buildmessages(AS_Host *host)\n{\n#if 0\n     \n    if (cmd_reset) {\n\tmsgqueue_addmsg(&host->scsi.msgs, 1, BUS_DEVICE_RESET);\n\treturn;\n    }\n#endif\n\n    msgqueue_addmsg(&host->scsi.msgs, 1,\n\t\t     IDENTIFY(host->device[host->SCpnt->device->id].disconnect_ok,\n\t\t\t     host->SCpnt->device->lun));\n\n#if 0\n     \n    if (cmd_aborted) {\n\tacornscsi_abortcmd(host);\n\treturn;\n    }\n#endif\n\n\n#ifdef CONFIG_SCSI_ACORNSCSI_SYNC\n    if (host->device[host->SCpnt->device->id].sync_state == SYNC_NEGOCIATE) {\n\thost->device[host->SCpnt->device->id].sync_state = SYNC_SENT_REQUEST;\n\tmsgqueue_addmsg(&host->scsi.msgs, 5,\n\t\t\t EXTENDED_MESSAGE, 3, EXTENDED_SDTR,\n\t\t\t sdtr_period / 4, sdtr_size);\n    }\n#endif\n}\n\n \nstatic\nint acornscsi_starttransfer(AS_Host *host)\n{\n    int residual;\n\n    if (!host->scsi.SCp.ptr  ) {\n\tprintk(KERN_ERR \"scsi%d.%c: null buffer passed to acornscsi_starttransfer\\n\",\n\t\thost->host->host_no, acornscsi_target(host));\n\treturn 0;\n    }\n\n    residual = scsi_bufflen(host->SCpnt) - host->scsi.SCp.scsi_xferred;\n\n    sbic_arm_write(host, SBIC_SYNCHTRANSFER, host->device[host->SCpnt->device->id].sync_xfer);\n    sbic_arm_writenext(host, residual >> 16);\n    sbic_arm_writenext(host, residual >> 8);\n    sbic_arm_writenext(host, residual);\n    acornscsi_sbic_issuecmd(host, CMND_XFERINFO);\n    return 1;\n}\n\n \n \nstatic\nint acornscsi_reconnect(AS_Host *host)\n{\n    unsigned int target, lun, ok = 0;\n\n    target = sbic_arm_read(host, SBIC_SOURCEID);\n\n    if (!(target & 8))\n\tprintk(KERN_ERR \"scsi%d: invalid source id after reselection \"\n\t\t\"- device fault?\\n\",\n\t\thost->host->host_no);\n\n    target &= 7;\n\n    if (host->SCpnt && !host->scsi.disconnectable) {\n\tprintk(KERN_ERR \"scsi%d.%d: reconnected while command in \"\n\t\t\"progress to target %d?\\n\",\n\t\thost->host->host_no, target, host->SCpnt->device->id);\n\thost->SCpnt = NULL;\n    }\n\n    lun = sbic_arm_read(host, SBIC_DATA) & 7;\n\n    host->scsi.reconnected.target = target;\n    host->scsi.reconnected.lun = lun;\n    host->scsi.reconnected.tag = 0;\n\n    if (host->scsi.disconnectable && host->SCpnt &&\n\thost->SCpnt->device->id == target && host->SCpnt->device->lun == lun)\n\tok = 1;\n\n    if (!ok && queue_probetgtlun(&host->queues.disconnected, target, lun))\n\tok = 1;\n\n    ADD_STATUS(target, 0x81, host->scsi.phase, 0);\n\n    if (ok) {\n\thost->scsi.phase = PHASE_RECONNECTED;\n    } else {\n\t \n\tprintk(KERN_ERR \"scsi%d.%c: reselected with no command \"\n\t\t\"to reconnect with\\n\",\n\t\thost->host->host_no, '0' + target);\n\tacornscsi_dumplog(host, target);\n\tacornscsi_abortcmd(host);\n\tif (host->SCpnt) {\n\t    queue_add_cmd_tail(&host->queues.disconnected, host->SCpnt);\n\t    host->SCpnt = NULL;\n\t}\n    }\n    acornscsi_sbic_issuecmd(host, CMND_NEGATEACK);\n    return !ok;\n}\n\n \nstatic\nint acornscsi_reconnect_finish(AS_Host *host)\n{\n    if (host->scsi.disconnectable && host->SCpnt) {\n\thost->scsi.disconnectable = 0;\n\tif (host->SCpnt->device->id  == host->scsi.reconnected.target &&\n\t    host->SCpnt->device->lun == host->scsi.reconnected.lun &&\n\t    scsi_cmd_to_rq(host->SCpnt)->tag == host->scsi.reconnected.tag) {\n#if (DEBUG & (DEBUG_QUEUES|DEBUG_DISCON))\n\t    DBG(host->SCpnt, printk(\"scsi%d.%c: reconnected\",\n\t\t    host->host->host_no, acornscsi_target(host)));\n#endif\n\t} else {\n\t    queue_add_cmd_tail(&host->queues.disconnected, host->SCpnt);\n#if (DEBUG & (DEBUG_QUEUES|DEBUG_DISCON))\n\t    DBG(host->SCpnt, printk(\"scsi%d.%c: had to move command \"\n\t\t    \"to disconnected queue\\n\",\n\t\t    host->host->host_no, acornscsi_target(host)));\n#endif\n\t    host->SCpnt = NULL;\n\t}\n    }\n    if (!host->SCpnt) {\n\thost->SCpnt = queue_remove_tgtluntag(&host->queues.disconnected,\n\t\t\t\thost->scsi.reconnected.target,\n\t\t\t\thost->scsi.reconnected.lun,\n\t\t\t\thost->scsi.reconnected.tag);\n#if (DEBUG & (DEBUG_QUEUES|DEBUG_DISCON))\n\tDBG(host->SCpnt, printk(\"scsi%d.%c: had to get command\",\n\t\thost->host->host_no, acornscsi_target(host)));\n#endif\n    }\n\n    if (!host->SCpnt)\n\tacornscsi_abortcmd(host);\n    else {\n\t \n\thost->scsi.SCp = *arm_scsi_pointer(host->SCpnt);\n#if (DEBUG & (DEBUG_QUEUES|DEBUG_DISCON))\n\tprintk(\", data pointers: [%p, %X]\",\n\t\thost->scsi.SCp.ptr, host->scsi.SCp.this_residual);\n#endif\n    }\n#if (DEBUG & (DEBUG_QUEUES|DEBUG_DISCON))\n    printk(\"\\n\");\n#endif\n\n    host->dma.transferred = host->scsi.SCp.scsi_xferred;\n\n    return host->SCpnt != NULL;\n}\n\n \nstatic\nvoid acornscsi_disconnect_unexpected(AS_Host *host)\n{\n    printk(KERN_ERR \"scsi%d.%c: unexpected disconnect\\n\",\n\t    host->host->host_no, acornscsi_target(host));\n#if (DEBUG & DEBUG_ABORT)\n    acornscsi_dumplog(host, 8);\n#endif\n\n    acornscsi_done(host, &host->SCpnt, DID_ERROR);\n}\n\n \nstatic\nvoid acornscsi_abortcmd(AS_Host *host)\n{\n    host->scsi.phase = PHASE_ABORTED;\n    sbic_arm_write(host, SBIC_CMND, CMND_ASSERTATN);\n\n    msgqueue_flush(&host->scsi.msgs);\n    msgqueue_addmsg(&host->scsi.msgs, 1, ABORT);\n}\n\n \n \nstatic\nintr_ret_t acornscsi_sbicintr(AS_Host *host, int in_irq)\n{\n    unsigned int asr, ssr;\n\n    asr = sbic_arm_read(host, SBIC_ASR);\n    if (!(asr & ASR_INT))\n\treturn INTR_IDLE;\n\n    ssr = sbic_arm_read(host, SBIC_SSR);\n\n#if (DEBUG & DEBUG_PHASES)\n    print_sbic_status(asr, ssr, host->scsi.phase);\n#endif\n\n    ADD_STATUS(8, ssr, host->scsi.phase, in_irq);\n\n    if (host->SCpnt && !host->scsi.disconnectable)\n\tADD_STATUS(host->SCpnt->device->id, ssr, host->scsi.phase, in_irq);\n\n    switch (ssr) {\n    case 0x00:\t\t\t\t \n\tprintk(KERN_ERR \"scsi%d: reset in standard mode but wanted advanced mode.\\n\",\n\t\thost->host->host_no);\n\t \n\tsbic_arm_write(host, SBIC_OWNID, OWNID_EAF | host->host->this_id);\n\tsbic_arm_write(host, SBIC_CMND, CMND_RESET);\n\treturn INTR_IDLE;\n\n    case 0x01:\t\t\t\t \n\tsbic_arm_write(host, SBIC_CTRL, INIT_SBICDMA | CTRL_IDI);\n\tsbic_arm_write(host, SBIC_TIMEOUT, TIMEOUT_TIME);\n\tsbic_arm_write(host, SBIC_SYNCHTRANSFER, SYNCHTRANSFER_2DBA);\n\tsbic_arm_write(host, SBIC_SOURCEID, SOURCEID_ER | SOURCEID_DSP);\n\tmsgqueue_flush(&host->scsi.msgs);\n\treturn INTR_IDLE;\n\n    case 0x41:\t\t\t\t \n\tacornscsi_disconnect_unexpected(host);\n\treturn INTR_NEXT_COMMAND;\n    }\n\n    switch (host->scsi.phase) {\n    case PHASE_CONNECTING:\t\t \n\tswitch (ssr) {\n\tcase 0x11:\t\t\t \n\t     \n\t    host->scsi.phase = PHASE_CONNECTED;\n\t    msgqueue_flush(&host->scsi.msgs);\n\t    host->dma.transferred = host->scsi.SCp.scsi_xferred;\n\t     \n\t    asr = sbic_arm_read(host, SBIC_ASR);\n\t    if (!(asr & ASR_INT))\n\t\tbreak;\n\t    ssr = sbic_arm_read(host, SBIC_SSR);\n\t    ADD_STATUS(8, ssr, host->scsi.phase, 1);\n\t    ADD_STATUS(host->SCpnt->device->id, ssr, host->scsi.phase, 1);\n\t    goto connected;\n\t    \n\tcase 0x42:\t\t\t \n\t\t\t\t\t \n\t    acornscsi_done(host, &host->SCpnt, DID_NO_CONNECT);\n\t    return INTR_NEXT_COMMAND;\n\n\tcase 0x81:\t\t\t \n\t     \n\t    host->origSCpnt = host->SCpnt;\n\t    host->SCpnt = NULL;\n\t    msgqueue_flush(&host->scsi.msgs);\n\t    acornscsi_reconnect(host);\n\t    break;\n\n\tdefault:\n\t    printk(KERN_ERR \"scsi%d.%c: PHASE_CONNECTING, SSR %02X?\\n\",\n\t\t    host->host->host_no, acornscsi_target(host), ssr);\n\t    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\n\t    acornscsi_abortcmd(host);\n\t}\n\treturn INTR_PROCESSING;\n\n    connected:\n    case PHASE_CONNECTED:\t\t \n\tswitch (ssr) {\n#ifdef NONSTANDARD\n\tcase 0x8a:\t\t\t \n\t     \n\t    acornscsi_sendcommand(host);\n\t    break;\n\n\tcase 0x8b:\t\t\t \n\t     \n\t    acornscsi_readstatusbyte(host);\n\t    host->scsi.phase = PHASE_STATUSIN;\n\t    break;\n#endif\n\n\tcase 0x8e:\t\t\t \n\t     \n\t    host->scsi.phase = PHASE_MSGOUT;\n\t    acornscsi_buildmessages(host);\n\t    acornscsi_sendmessage(host);\n\t    break;\n\n\t \n\tcase 0x85:\t\t\t \n\t    acornscsi_done(host, &host->SCpnt, DID_ERROR);\n\t    break;\n\n\tdefault:\n\t    printk(KERN_ERR \"scsi%d.%c: PHASE_CONNECTED, SSR %02X?\\n\",\n\t\t    host->host->host_no, acornscsi_target(host), ssr);\n\t    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\n\t    acornscsi_abortcmd(host);\n\t}\n\treturn INTR_PROCESSING;\n\n    case PHASE_MSGOUT:\t\t\t \n\t \n\tswitch (ssr) {\n\tcase 0x8a:\t\t\t \n\tcase 0x1a:\t\t\t \n\t     \n\t    acornscsi_sendcommand(host);\n\t    break;\n\n\tcase 0x8b:\t\t\t \n\tcase 0x1b:\t\t\t \n\t     \n\t    acornscsi_readstatusbyte(host);\n\t    host->scsi.phase = PHASE_STATUSIN;\n\t    break;\n\n\tcase 0x8e:\t\t\t \n\t     \n\t    acornscsi_sendmessage(host);\n\t    break;\n\n\tcase 0x4f:\t\t\t \n\tcase 0x1f:\t\t\t \n\t     \n\t    acornscsi_message(host);\n\t    break;\n\n\tdefault:\n\t    printk(KERN_ERR \"scsi%d.%c: PHASE_MSGOUT, SSR %02X?\\n\",\n\t\t    host->host->host_no, acornscsi_target(host), ssr);\n\t    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\n\t}\n\treturn INTR_PROCESSING;\n\n    case PHASE_COMMAND: \t\t \n\tswitch (ssr) {\n\tcase 0x18:\t\t\t \n\t     \n\t    if (host->scsi.SCp.sent_command != host->SCpnt->cmd_len)\n\t\tacornscsi_abortcmd(host);\n\t    acornscsi_dma_setup(host, DMA_OUT);\n\t    if (!acornscsi_starttransfer(host))\n\t\tacornscsi_abortcmd(host);\n\t    host->scsi.phase = PHASE_DATAOUT;\n\t    return INTR_IDLE;\n\n\tcase 0x19:\t\t\t \n\t     \n\t    if (host->scsi.SCp.sent_command != host->SCpnt->cmd_len)\n\t\tacornscsi_abortcmd(host);\n\t    acornscsi_dma_setup(host, DMA_IN);\n\t    if (!acornscsi_starttransfer(host))\n\t\tacornscsi_abortcmd(host);\n\t    host->scsi.phase = PHASE_DATAIN;\n\t    return INTR_IDLE;\n\n\tcase 0x1b:\t\t\t \n\t     \n\t    acornscsi_readstatusbyte(host);\n\t    host->scsi.phase = PHASE_STATUSIN;\n\t    break;\n\n\tcase 0x1e:\t\t\t \n\t     \n\t    acornscsi_sendmessage(host);\n\t    break;\n\n\tcase 0x1f:\t\t\t \n\t     \n\t    acornscsi_message(host);\n\t    break;\n\n\tdefault:\n\t    printk(KERN_ERR \"scsi%d.%c: PHASE_COMMAND, SSR %02X?\\n\",\n\t\t    host->host->host_no, acornscsi_target(host), ssr);\n\t    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\n\t}\n\treturn INTR_PROCESSING;\n\n    case PHASE_DISCONNECT:\t\t \n\tif (ssr == 0x85) {\t\t \n\t    host->scsi.disconnectable = 1;\n\t    host->scsi.reconnected.tag = 0;\n\t    host->scsi.phase = PHASE_IDLE;\n\t    host->stats.disconnects += 1;\n\t} else {\n\t    printk(KERN_ERR \"scsi%d.%c: PHASE_DISCONNECT, SSR %02X instead of disconnect?\\n\",\n\t\t    host->host->host_no, acornscsi_target(host), ssr);\n\t    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\n\t}\n\treturn INTR_NEXT_COMMAND;\n\n    case PHASE_IDLE:\t\t\t \n\tif (ssr == 0x81)\t\t \n\t    acornscsi_reconnect(host);\n\telse {\n\t    printk(KERN_ERR \"scsi%d.%c: PHASE_IDLE, SSR %02X while idle?\\n\",\n\t\t    host->host->host_no, acornscsi_target(host), ssr);\n\t    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\n\t}\n\treturn INTR_PROCESSING;\n\n    case PHASE_RECONNECTED:\t\t \n\t \n\t \n\tif (ssr != 0x8f && !acornscsi_reconnect_finish(host))\n\t    return INTR_IDLE;\n\tADD_STATUS(host->SCpnt->device->id, ssr, host->scsi.phase, in_irq);\n\tswitch (ssr) {\n\tcase 0x88:\t\t\t \n\t\t\t\t\t \n\t     \n\t    acornscsi_dma_setup(host, DMA_OUT);\n\t    if (!acornscsi_starttransfer(host))\n\t\tacornscsi_abortcmd(host);\n\t    host->scsi.phase = PHASE_DATAOUT;\n\t    return INTR_IDLE;\n\n\tcase 0x89:\t\t\t \n\t\t\t\t\t \n\t     \n\t    acornscsi_dma_setup(host, DMA_IN);\n\t    if (!acornscsi_starttransfer(host))\n\t\tacornscsi_abortcmd(host);\n\t    host->scsi.phase = PHASE_DATAIN;\n\t    return INTR_IDLE;\n\n\tcase 0x8a:\t\t\t \n\t     \n\t    acornscsi_sendcommand(host); \n\t    break;\n\n\tcase 0x8b:\t\t\t \n\t\t\t\t\t \n\t     \n\t    acornscsi_readstatusbyte(host);\n\t    host->scsi.phase = PHASE_STATUSIN;\n\t    break;\n\n\tcase 0x8e:\t\t\t \n\t\t\t\t\t \n\t     \n\t    acornscsi_sendmessage(host);\n\t    break;\n\n\tcase 0x8f:\t\t\t \n\t    acornscsi_message(host);\t \n\t    break;\n\n\tdefault:\n\t    printk(KERN_ERR \"scsi%d.%c: PHASE_RECONNECTED, SSR %02X after reconnect?\\n\",\n\t\t    host->host->host_no, acornscsi_target(host), ssr);\n\t    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\n\t}\n\treturn INTR_PROCESSING;\n\n    case PHASE_DATAIN:\t\t\t \n\t \n\tswitch (ssr) {\n\tcase 0x19:\t\t\t \n\tcase 0x89:\t\t\t \n\t    acornscsi_abortcmd(host);\n\t    return INTR_IDLE;\n\n\tcase 0x1b:\t\t\t \n\tcase 0x4b:\t\t\t \n\tcase 0x8b:\t\t\t \n\t     \n\t    host->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -\n\t\t\t\t\t  acornscsi_sbic_xfcount(host);\n\t    acornscsi_dma_stop(host);\n\t    acornscsi_readstatusbyte(host);\n\t    host->scsi.phase = PHASE_STATUSIN;\n\t    break;\n\n\tcase 0x1e:\t\t\t \n\tcase 0x4e:\t\t\t \n\tcase 0x8e:\t\t\t \n\t     \n\t    host->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -\n\t\t\t\t\t  acornscsi_sbic_xfcount(host);\n\t    acornscsi_dma_stop(host);\n\t    acornscsi_sendmessage(host);\n\t    break;\n\n\tcase 0x1f:\t\t\t \n\tcase 0x4f:\t\t\t \n\tcase 0x8f:\t\t\t \n\t     \n\t    host->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -\n\t\t\t\t\t  acornscsi_sbic_xfcount(host);\n\t    acornscsi_dma_stop(host);\n\t    acornscsi_message(host);\t \n\t    break;\n\n\tdefault:\n\t    printk(KERN_ERR \"scsi%d.%c: PHASE_DATAIN, SSR %02X?\\n\",\n\t\t    host->host->host_no, acornscsi_target(host), ssr);\n\t    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\n\t}\n\treturn INTR_PROCESSING;\n\n    case PHASE_DATAOUT: \t\t \n\t \n\tswitch (ssr) {\n\tcase 0x18:\t\t\t \n\tcase 0x88:\t\t\t \n\t    acornscsi_abortcmd(host);\n\t    return INTR_IDLE;\n\n\tcase 0x1b:\t\t\t \n\tcase 0x4b:\t\t\t \n\tcase 0x8b:\t\t\t \n\t     \n\t    host->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -\n\t\t\t\t\t  acornscsi_sbic_xfcount(host);\n\t    acornscsi_dma_stop(host);\n\t    acornscsi_dma_adjust(host);\n\t    acornscsi_readstatusbyte(host);\n\t    host->scsi.phase = PHASE_STATUSIN;\n\t    break;\n\n\tcase 0x1e:\t\t\t \n\tcase 0x4e:\t\t\t \n\tcase 0x8e:\t\t\t \n\t     \n\t    host->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -\n\t\t\t\t\t  acornscsi_sbic_xfcount(host);\n\t    acornscsi_dma_stop(host);\n\t    acornscsi_dma_adjust(host);\n\t    acornscsi_sendmessage(host);\n\t    break;\n\n\tcase 0x1f:\t\t\t \n\tcase 0x4f:\t\t\t \n\tcase 0x8f:\t\t\t \n\t     \n\t    host->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -\n\t\t\t\t\t  acornscsi_sbic_xfcount(host);\n\t    acornscsi_dma_stop(host);\n\t    acornscsi_dma_adjust(host);\n\t    acornscsi_message(host);\t \n\t    break;\n\n\tdefault:\n\t    printk(KERN_ERR \"scsi%d.%c: PHASE_DATAOUT, SSR %02X?\\n\",\n\t\t    host->host->host_no, acornscsi_target(host), ssr);\n\t    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\n\t}\n\treturn INTR_PROCESSING;\n\n    case PHASE_STATUSIN:\t\t \n\tswitch (ssr) {\n\tcase 0x1f:\t\t\t \n\tcase 0x8f:\t\t\t \n\t     \n\t    acornscsi_message(host);\n\t    break;\n\n\tcase 0x1e:\t\t\t \n\tcase 0x8e:\t\t\t \n\t     \n\t    acornscsi_sendmessage(host);\n\t    break;\n\n\tdefault:\n\t    printk(KERN_ERR \"scsi%d.%c: PHASE_STATUSIN, SSR %02X instead of MESSAGE_IN?\\n\",\n\t\t    host->host->host_no, acornscsi_target(host), ssr);\n\t    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\n\t}\n\treturn INTR_PROCESSING;\n\n    case PHASE_MSGIN:\t\t\t \n\tswitch (ssr) {\n\tcase 0x1e:\t\t\t \n\tcase 0x4e:\t\t\t \n\tcase 0x8e:\t\t\t \n\t     \n\t    acornscsi_sendmessage(host);\n\t    break;\n\n\tcase 0x1f:\t\t\t \n\tcase 0x2f:\n\tcase 0x4f:\n\tcase 0x8f:\n\t    acornscsi_message(host);\n\t    break;\n\n\tcase 0x85:\n\t    printk(\"scsi%d.%c: strange message in disconnection\\n\",\n\t\thost->host->host_no, acornscsi_target(host));\n\t    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\n\t    acornscsi_done(host, &host->SCpnt, DID_ERROR);\n\t    break;\n\n\tdefault:\n\t    printk(KERN_ERR \"scsi%d.%c: PHASE_MSGIN, SSR %02X after message in?\\n\",\n\t\t    host->host->host_no, acornscsi_target(host), ssr);\n\t    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\n\t}\n\treturn INTR_PROCESSING;\n\n    case PHASE_DONE:\t\t\t \n\tswitch (ssr) {\n\tcase 0x85:\t\t\t \n\t    acornscsi_done(host, &host->SCpnt, DID_OK);\n\t    return INTR_NEXT_COMMAND;\n\n\tcase 0x1e:\n\tcase 0x8e:\n\t    acornscsi_sendmessage(host);\n\t    break;\n\n\tdefault:\n\t    printk(KERN_ERR \"scsi%d.%c: PHASE_DONE, SSR %02X instead of disconnect?\\n\",\n\t\t    host->host->host_no, acornscsi_target(host), ssr);\n\t    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\n\t}\n\treturn INTR_PROCESSING;\n\n    case PHASE_ABORTED:\n\tswitch (ssr) {\n\tcase 0x85:\n\t    if (host->SCpnt)\n\t\tacornscsi_done(host, &host->SCpnt, DID_ABORT);\n\t    else {\n\t\tclear_bit(host->scsi.reconnected.target * 8 + host->scsi.reconnected.lun,\n\t\t\t  host->busyluns);\n\t\thost->scsi.phase = PHASE_IDLE;\n\t    }\n\t    return INTR_NEXT_COMMAND;\n\n\tcase 0x1e:\n\tcase 0x2e:\n\tcase 0x4e:\n\tcase 0x8e:\n\t    acornscsi_sendmessage(host);\n\t    break;\n\n\tdefault:\n\t    printk(KERN_ERR \"scsi%d.%c: PHASE_ABORTED, SSR %02X?\\n\",\n\t\t    host->host->host_no, acornscsi_target(host), ssr);\n\t    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\n\t}\n\treturn INTR_PROCESSING;\n\n    default:\n\tprintk(KERN_ERR \"scsi%d.%c: unknown driver phase %d\\n\",\n\t\thost->host->host_no, acornscsi_target(host), ssr);\n\tacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\n    }\n    return INTR_PROCESSING;\n}\n\n \nstatic irqreturn_t\nacornscsi_intr(int irq, void *dev_id)\n{\n    AS_Host *host = (AS_Host *)dev_id;\n    intr_ret_t ret;\n    int iostatus;\n    int in_irq = 0;\n\n    do {\n\tret = INTR_IDLE;\n\n\tiostatus = readb(host->fast + INT_REG);\n\n\tif (iostatus & 2) {\n\t    acornscsi_dma_intr(host);\n\t    iostatus = readb(host->fast + INT_REG);\n\t}\n\n\tif (iostatus & 8)\n\t    ret = acornscsi_sbicintr(host, in_irq);\n\n\t \n\tif (host->dma.xfer_required)\n\t    acornscsi_dma_xfer(host);\n\n\tif (ret == INTR_NEXT_COMMAND)\n\t    ret = acornscsi_kick(host);\n\n\tin_irq = 1;\n    } while (ret != INTR_IDLE);\n\n    return IRQ_HANDLED;\n}\n\n \n\n \nstatic int acornscsi_queuecmd_lck(struct scsi_cmnd *SCpnt)\n{\n    struct scsi_pointer *scsi_pointer = arm_scsi_pointer(SCpnt);\n    void (*done)(struct scsi_cmnd *) = scsi_done;\n    AS_Host *host = (AS_Host *)SCpnt->device->host->hostdata;\n\n#if (DEBUG & DEBUG_NO_WRITE)\n    if (acornscsi_cmdtype(SCpnt->cmnd[0]) == CMD_WRITE && (NO_WRITE & (1 << SCpnt->device->id))) {\n\tprintk(KERN_CRIT \"scsi%d.%c: WRITE attempted with NO_WRITE flag set\\n\",\n\t    host->host->host_no, '0' + SCpnt->device->id);\n\tset_host_byte(SCpnt, DID_NO_CONNECT);\n\tdone(SCpnt);\n\treturn 0;\n    }\n#endif\n\n    SCpnt->host_scribble = NULL;\n    SCpnt->result = 0;\n    scsi_pointer->phase = (int)acornscsi_datadirection(SCpnt->cmnd[0]);\n    scsi_pointer->sent_command = 0;\n    scsi_pointer->scsi_xferred = 0;\n\n    init_SCp(SCpnt);\n\n    host->stats.queues += 1;\n\n    {\n\tunsigned long flags;\n\n\tif (!queue_add_cmd_ordered(&host->queues.issue, SCpnt)) {\n\t\tset_host_byte(SCpnt, DID_ERROR);\n\t    done(SCpnt);\n\t    return 0;\n\t}\n\tlocal_irq_save(flags);\n\tif (host->scsi.phase == PHASE_IDLE)\n\t    acornscsi_kick(host);\n\tlocal_irq_restore(flags);\n    }\n    return 0;\n}\n\nDEF_SCSI_QCMD(acornscsi_queuecmd)\n\nenum res_abort { res_not_running, res_success, res_success_clear, res_snooze };\n\n \nstatic enum res_abort acornscsi_do_abort(AS_Host *host, struct scsi_cmnd *SCpnt)\n{\n\tenum res_abort res = res_not_running;\n\n\tif (queue_remove_cmd(&host->queues.issue, SCpnt)) {\n\t\t \n \n\t\tprintk(\"on issue queue \");\n \n\t\tres = res_success;\n\t} else if (queue_remove_cmd(&host->queues.disconnected, SCpnt)) {\n\t\t \n \n\t\tprintk(\"on disconnected queue \");\n \n\t\tres = res_success;\n\t} else if (host->SCpnt == SCpnt) {\n\t\tunsigned long flags;\n\n \n\t\tprintk(\"executing \");\n \n\n\t\tlocal_irq_save(flags);\n\t\tswitch (host->scsi.phase) {\n\t\t \n\t\tcase PHASE_IDLE:\n\t\t\tif (host->scsi.disconnectable) {\n\t\t\t\thost->scsi.disconnectable = 0;\n\t\t\t\thost->SCpnt = NULL;\n\t\t\t\tres = res_success;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t \n\t\tcase PHASE_CONNECTED:\n\t\t\tsbic_arm_write(host, SBIC_CMND, CMND_DISCONNECT);\n\t\t\thost->SCpnt = NULL;\n\t\t\tres = res_success_clear;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tacornscsi_abortcmd(host);\n\t\t\tres = res_snooze;\n\t\t}\n\t\tlocal_irq_restore(flags);\n\t} else if (host->origSCpnt == SCpnt) {\n\t\t \n\t\thost->origSCpnt = NULL;\n \n\t\tprintk(\"waiting for execution \");\n \n\t\tres = res_success_clear;\n\t} else\n\t\tprintk(\"unknown \");\n\n\treturn res;\n}\n\n \nint acornscsi_abort(struct scsi_cmnd *SCpnt)\n{\n\tAS_Host *host = (AS_Host *) SCpnt->device->host->hostdata;\n\tint result;\n\n\thost->stats.aborts += 1;\n\n#if (DEBUG & DEBUG_ABORT)\n\t{\n\t\tint asr, ssr;\n\t\tasr = sbic_arm_read(host, SBIC_ASR);\n\t\tssr = sbic_arm_read(host, SBIC_SSR);\n\n\t\tprintk(KERN_WARNING \"acornscsi_abort: \");\n\t\tprint_sbic_status(asr, ssr, host->scsi.phase);\n\t\tacornscsi_dumplog(host, SCpnt->device->id);\n\t}\n#endif\n\n\tprintk(\"scsi%d: \", host->host->host_no);\n\n\tswitch (acornscsi_do_abort(host, SCpnt)) {\n\t \n\tcase res_success_clear:\n \n\t\tprintk(\"clear \");\n \n\t\tclear_bit(SCpnt->device->id * 8 +\n\t\t\t  (u8)(SCpnt->device->lun & 0x7), host->busyluns);\n\t\tfallthrough;\n\n\t \n\tcase res_success:\n \n\t\tprintk(\"success\\n\");\n \n\t\tresult = SUCCESS;\n\t\tbreak;\n\n\t \n\tcase res_snooze:\n \n\t\tprintk(\"snooze\\n\");\n \n\t\tresult = FAILED;\n\t\tbreak;\n\n\t \n\tdefault:\n\tcase res_not_running:\n\t\tacornscsi_dumplog(host, SCpnt->device->id);\n\t\tresult = FAILED;\n \n\t\tprintk(\"not running\\n\");\n \n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\n \nint acornscsi_host_reset(struct scsi_cmnd *SCpnt)\n{\n\tAS_Host *host = (AS_Host *)SCpnt->device->host->hostdata;\n\tstruct scsi_cmnd *SCptr;\n    \n    host->stats.resets += 1;\n\n#if (DEBUG & DEBUG_RESET)\n    {\n\tint asr, ssr, devidx;\n\n\tasr = sbic_arm_read(host, SBIC_ASR);\n\tssr = sbic_arm_read(host, SBIC_SSR);\n\n\tprintk(KERN_WARNING \"acornscsi_reset: \");\n\tprint_sbic_status(asr, ssr, host->scsi.phase);\n\tfor (devidx = 0; devidx < 9; devidx++)\n\t    acornscsi_dumplog(host, devidx);\n    }\n#endif\n\n    acornscsi_dma_stop(host);\n\n     \n    acornscsi_resetcard(host);\n\n    while ((SCptr = queue_remove(&host->queues.disconnected)) != NULL)\n\t;\n\n    return SUCCESS;\n}\n\n \n\n \nconst\nchar *acornscsi_info(struct Scsi_Host *host)\n{\n    static char string[100], *p;\n\n    p = string;\n    \n    p += sprintf(string, \"%s at port %08lX irq %d v%d.%d.%d\"\n#ifdef CONFIG_SCSI_ACORNSCSI_SYNC\n    \" SYNC\"\n#endif\n#if (DEBUG & DEBUG_NO_WRITE)\n    \" NOWRITE (\" __stringify(NO_WRITE) \")\"\n#endif\n\t\t, host->hostt->name, host->io_port, host->irq,\n\t\tVER_MAJOR, VER_MINOR, VER_PATCH);\n    return string;\n}\n\nstatic int acornscsi_show_info(struct seq_file *m, struct Scsi_Host *instance)\n{\n    int devidx;\n    struct scsi_device *scd;\n    AS_Host *host;\n\n    host  = (AS_Host *)instance->hostdata;\n    \n    seq_printf(m, \"AcornSCSI driver v%d.%d.%d\"\n#ifdef CONFIG_SCSI_ACORNSCSI_SYNC\n    \" SYNC\"\n#endif\n#if (DEBUG & DEBUG_NO_WRITE)\n    \" NOWRITE (\" __stringify(NO_WRITE) \")\"\n#endif\n\t\t\"\\n\\n\", VER_MAJOR, VER_MINOR, VER_PATCH);\n\n    seq_printf(m,\t\"SBIC: WD33C93A  Address: %p    IRQ : %d\\n\",\n\t\t\thost->base + SBIC_REGIDX, host->scsi.irq);\n#ifdef USE_DMAC\n    seq_printf(m,\t\"DMAC: uPC71071  Address: %p  IRQ : %d\\n\\n\",\n\t\t\thost->base + DMAC_OFFSET, host->scsi.irq);\n#endif\n\n    seq_printf(m,\t\"Statistics:\\n\"\n\t\t\t\"Queued commands: %-10u    Issued commands: %-10u\\n\"\n\t\t\t\"Done commands  : %-10u    Reads          : %-10u\\n\"\n\t\t\t\"Writes         : %-10u    Others         : %-10u\\n\"\n\t\t\t\"Disconnects    : %-10u    Aborts         : %-10u\\n\"\n\t\t\t\"Resets         : %-10u\\n\\nLast phases:\",\n\t\t\thost->stats.queues,\t\thost->stats.removes,\n\t\t\thost->stats.fins,\t\thost->stats.reads,\n\t\t\thost->stats.writes,\t\thost->stats.miscs,\n\t\t\thost->stats.disconnects,\thost->stats.aborts,\n\t\t\thost->stats.resets);\n\n    for (devidx = 0; devidx < 9; devidx ++) {\n\tunsigned int statptr, prev;\n\n\tseq_printf(m, \"\\n%c:\", devidx == 8 ? 'H' : ('0' + devidx));\n\tstatptr = host->status_ptr[devidx] - 10;\n\n\tif ((signed int)statptr < 0)\n\t    statptr += STATUS_BUFFER_SIZE;\n\n\tprev = host->status[devidx][statptr].when;\n\n\tfor (; statptr != host->status_ptr[devidx]; statptr = (statptr + 1) & (STATUS_BUFFER_SIZE - 1)) {\n\t    if (host->status[devidx][statptr].when) {\n\t\tseq_printf(m, \"%c%02X:%02X+%2ld\",\n\t\t\thost->status[devidx][statptr].irq ? '-' : ' ',\n\t\t\thost->status[devidx][statptr].ph,\n\t\t\thost->status[devidx][statptr].ssr,\n\t\t\t(host->status[devidx][statptr].when - prev) < 100 ?\n\t\t\t\t(host->status[devidx][statptr].when - prev) : 99);\n\t\tprev = host->status[devidx][statptr].when;\n\t    }\n\t}\n    }\n\n    seq_printf(m, \"\\nAttached devices:\\n\");\n\n    shost_for_each_device(scd, instance) {\n\tseq_printf(m, \"Device/Lun TaggedQ      Sync\\n\");\n\tseq_printf(m, \"     %d/%llu   \", scd->id, scd->lun);\n\tif (scd->tagged_supported)\n\t\tseq_printf(m, \"%3sabled \",\n\t\t\t     scd->simple_tags ? \"en\" : \"dis\");\n\telse\n\t\tseq_printf(m, \"unsupported  \");\n\n\tif (host->device[scd->id].sync_xfer & 15)\n\t\tseq_printf(m, \"offset %d, %d ns\\n\",\n\t\t\t     host->device[scd->id].sync_xfer & 15,\n\t\t\t     acornscsi_getperiod(host->device[scd->id].sync_xfer));\n\telse\n\t\tseq_printf(m, \"async\\n\");\n\n    }\n    return 0;\n}\n\nstatic const struct scsi_host_template acornscsi_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.show_info\t\t= acornscsi_show_info,\n\t.name\t\t\t= \"AcornSCSI\",\n\t.info\t\t\t= acornscsi_info,\n\t.queuecommand\t\t= acornscsi_queuecmd,\n\t.eh_abort_handler\t= acornscsi_abort,\n\t.eh_host_reset_handler\t= acornscsi_host_reset,\n\t.can_queue\t\t= 16,\n\t.this_id\t\t= 7,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.cmd_per_lun\t\t= 2,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n\t.proc_name\t\t= \"acornscsi\",\n\t.cmd_size\t\t= sizeof(struct arm_cmd_priv),\n};\n\nstatic int acornscsi_probe(struct expansion_card *ec, const struct ecard_id *id)\n{\n\tstruct Scsi_Host *host;\n\tAS_Host *ashost;\n\tint ret;\n\n\tret = ecard_request_resources(ec);\n\tif (ret)\n\t\tgoto out;\n\n\thost = scsi_host_alloc(&acornscsi_template, sizeof(AS_Host));\n\tif (!host) {\n\t\tret = -ENOMEM;\n\t\tgoto out_release;\n\t}\n\n\tashost = (AS_Host *)host->hostdata;\n\n\tashost->base = ecardm_iomap(ec, ECARD_RES_MEMC, 0, 0);\n\tashost->fast = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);\n\tif (!ashost->base || !ashost->fast) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\n\thost->irq = ec->irq;\n\tashost->host = host;\n\tashost->scsi.irq = host->irq;\n\n\tec->irqaddr\t= ashost->fast + INT_REG;\n\tec->irqmask\t= 0x0a;\n\n\tret = request_irq(host->irq, acornscsi_intr, 0, \"acornscsi\", ashost);\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"scsi%d: IRQ%d not free: %d\\n\",\n\t\t\thost->host_no, ashost->scsi.irq, ret);\n\t\tgoto out_put;\n\t}\n\n\tmemset(&ashost->stats, 0, sizeof (ashost->stats));\n\tqueue_initialise(&ashost->queues.issue);\n\tqueue_initialise(&ashost->queues.disconnected);\n\tmsgqueue_initialise(&ashost->scsi.msgs);\n\n\tacornscsi_resetcard(ashost);\n\n\tret = scsi_add_host(host, &ec->dev);\n\tif (ret)\n\t\tgoto out_irq;\n\n\tscsi_scan_host(host);\n\tgoto out;\n\n out_irq:\n\tfree_irq(host->irq, ashost);\n\tmsgqueue_free(&ashost->scsi.msgs);\n\tqueue_free(&ashost->queues.disconnected);\n\tqueue_free(&ashost->queues.issue);\n out_put:\n\tecardm_iounmap(ec, ashost->fast);\n\tecardm_iounmap(ec, ashost->base);\n\tscsi_host_put(host);\n out_release:\n\tecard_release_resources(ec);\n out:\n\treturn ret;\n}\n\nstatic void acornscsi_remove(struct expansion_card *ec)\n{\n\tstruct Scsi_Host *host = ecard_get_drvdata(ec);\n\tAS_Host *ashost = (AS_Host *)host->hostdata;\n\n\tecard_set_drvdata(ec, NULL);\n\tscsi_remove_host(host);\n\n\t \n\twriteb(0x80, ashost->fast + PAGE_REG);\n\n\tfree_irq(host->irq, ashost);\n\n\tmsgqueue_free(&ashost->scsi.msgs);\n\tqueue_free(&ashost->queues.disconnected);\n\tqueue_free(&ashost->queues.issue);\n\tecardm_iounmap(ec, ashost->fast);\n\tecardm_iounmap(ec, ashost->base);\n\tscsi_host_put(host);\n\tecard_release_resources(ec);\n}\n\nstatic const struct ecard_id acornscsi_cids[] = {\n\t{ MANU_ACORN, PROD_ACORN_SCSI },\n\t{ 0xffff, 0xffff },\n};\n\nstatic struct ecard_driver acornscsi_driver = {\n\t.probe\t\t= acornscsi_probe,\n\t.remove\t\t= acornscsi_remove,\n\t.id_table\t= acornscsi_cids,\n\t.drv = {\n\t\t.name\t\t= \"acornscsi\",\n\t},\n};\n\nstatic int __init acornscsi_init(void)\n{\n\treturn ecard_register_driver(&acornscsi_driver);\n}\n\nstatic void __exit acornscsi_exit(void)\n{\n\tecard_remove_driver(&acornscsi_driver);\n}\n\nmodule_init(acornscsi_init);\nmodule_exit(acornscsi_exit);\n\nMODULE_AUTHOR(\"Russell King\");\nMODULE_DESCRIPTION(\"AcornSCSI driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}