{
  "module_name": "powertec.c",
  "hash_id": "4d3d528bc5a859aa653fe0abed7a9124aa34b1ad3edf866d121851338418ef19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/arm/powertec.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ioport.h>\n#include <linux/proc_fs.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/dma-mapping.h>\n#include <linux/pgtable.h>\n\n#include <asm/dma.h>\n#include <asm/ecard.h>\n#include <asm/io.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include \"fas216.h\"\n#include \"arm_scsi.h\"\n\n#include <scsi/scsicam.h>\n\n#define POWERTEC_FAS216_OFFSET\t0x3000\n#define POWERTEC_FAS216_SHIFT\t6\n\n#define POWERTEC_INTR_STATUS\t0x2000\n#define POWERTEC_INTR_BIT\t0x80\n\n#define POWERTEC_RESET_CONTROL\t0x1018\n#define POWERTEC_RESET_BIT\t1\n\n#define POWERTEC_TERM_CONTROL\t0x2018\n#define POWERTEC_TERM_ENABLE\t1\n\n#define POWERTEC_INTR_CONTROL\t0x101c\n#define POWERTEC_INTR_ENABLE\t1\n#define POWERTEC_INTR_DISABLE\t0\n\n#define VERSION\t\"1.10 (19/01/2003 2.5.59)\"\n\n \nstatic int term[MAX_ECARDS] = { 1, 1, 1, 1, 1, 1, 1, 1 };\n\n#define NR_SG\t256\n\nstruct powertec_info {\n\tFAS216_Info\t\tinfo;\n\tstruct expansion_card\t*ec;\n\tvoid __iomem\t\t*base;\n\tunsigned int\t\tterm_ctl;\n\tstruct scatterlist\tsg[NR_SG];\n};\n\n \nstatic void\npowertecscsi_irqenable(struct expansion_card *ec, int irqnr)\n{\n\tstruct powertec_info *info = ec->irq_data;\n\twriteb(POWERTEC_INTR_ENABLE, info->base + POWERTEC_INTR_CONTROL);\n}\n\n \nstatic void\npowertecscsi_irqdisable(struct expansion_card *ec, int irqnr)\n{\n\tstruct powertec_info *info = ec->irq_data;\n\twriteb(POWERTEC_INTR_DISABLE, info->base + POWERTEC_INTR_CONTROL);\n}\n\nstatic const expansioncard_ops_t powertecscsi_ops = {\n\t.irqenable\t= powertecscsi_irqenable,\n\t.irqdisable\t= powertecscsi_irqdisable,\n};\n\n \nstatic void\npowertecscsi_terminator_ctl(struct Scsi_Host *host, int on_off)\n{\n\tstruct powertec_info *info = (struct powertec_info *)host->hostdata;\n\n\tinfo->term_ctl = on_off ? POWERTEC_TERM_ENABLE : 0;\n\twriteb(info->term_ctl, info->base + POWERTEC_TERM_CONTROL);\n}\n\n \nstatic irqreturn_t powertecscsi_intr(int irq, void *dev_id)\n{\n\tstruct powertec_info *info = dev_id;\n\n\treturn fas216_intr(&info->info);\n}\n\n \nstatic fasdmatype_t\npowertecscsi_dma_setup(struct Scsi_Host *host, struct scsi_pointer *SCp,\n\t\t       fasdmadir_t direction, fasdmatype_t min_type)\n{\n\tstruct powertec_info *info = (struct powertec_info *)host->hostdata;\n\tstruct device *dev = scsi_get_device(host);\n\tint dmach = info->info.scsi.dma;\n\n\tif (info->info.ifcfg.capabilities & FASCAP_DMA &&\n\t    min_type == fasdma_real_all) {\n\t\tint bufs, map_dir, dma_dir;\n\n\t\tbufs = copy_SCp_to_sg(&info->sg[0], SCp, NR_SG);\n\n\t\tif (direction == DMA_OUT) {\n\t\t\tmap_dir = DMA_TO_DEVICE;\n\t\t\tdma_dir = DMA_MODE_WRITE;\n\t\t} else {\n\t\t\tmap_dir = DMA_FROM_DEVICE;\n\t\t\tdma_dir = DMA_MODE_READ;\n\t\t}\n\n\t\tdma_map_sg(dev, info->sg, bufs, map_dir);\n\n\t\tdisable_dma(dmach);\n\t\tset_dma_sg(dmach, info->sg, bufs);\n\t\tset_dma_mode(dmach, dma_dir);\n\t\tenable_dma(dmach);\n\t\treturn fasdma_real_all;\n\t}\n\n\t \n\treturn fasdma_pio;\n}\n\n \nstatic void\npowertecscsi_dma_stop(struct Scsi_Host *host, struct scsi_pointer *SCp)\n{\n\tstruct powertec_info *info = (struct powertec_info *)host->hostdata;\n\tif (info->info.scsi.dma != NO_DMA)\n\t\tdisable_dma(info->info.scsi.dma);\n}\n\n \nconst char *powertecscsi_info(struct Scsi_Host *host)\n{\n\tstruct powertec_info *info = (struct powertec_info *)host->hostdata;\n\tstatic char string[150];\n\n\tsprintf(string, \"%s (%s) in slot %d v%s terminators o%s\",\n\t\thost->hostt->name, info->info.scsi.type, info->ec->slot_no,\n\t\tVERSION, info->term_ctl ? \"n\" : \"ff\");\n\n\treturn string;\n}\n\n \nstatic int\npowertecscsi_set_proc_info(struct Scsi_Host *host, char *buffer, int length)\n{\n\tint ret = length;\n\n\tif (length >= 12 && strncmp(buffer, \"POWERTECSCSI\", 12) == 0) {\n\t\tbuffer += 12;\n\t\tlength -= 12;\n\n\t\tif (length >= 5 && strncmp(buffer, \"term=\", 5) == 0) {\n\t\t\tif (buffer[5] == '1')\n\t\t\t\tpowertecscsi_terminator_ctl(host, 1);\n\t\t\telse if (buffer[5] == '0')\n\t\t\t\tpowertecscsi_terminator_ctl(host, 0);\n\t\t\telse\n\t\t\t\tret = -EINVAL;\n\t\t} else\n\t\t\tret = -EINVAL;\n\t} else\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\n \nstatic int powertecscsi_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tstruct powertec_info *info;\n\n\tinfo = (struct powertec_info *)host->hostdata;\n\n\tseq_printf(m, \"PowerTec SCSI driver v%s\\n\", VERSION);\n\tfas216_print_host(&info->info, m);\n\tseq_printf(m, \"Term    : o%s\\n\",\n\t\t\tinfo->term_ctl ? \"n\" : \"ff\");\n\n\tfas216_print_stats(&info->info, m);\n\tfas216_print_devices(&info->info, m);\n\treturn 0;\n}\n\nstatic ssize_t powertecscsi_show_term(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct expansion_card *ec = ECARD_DEV(dev);\n\tstruct Scsi_Host *host = ecard_get_drvdata(ec);\n\tstruct powertec_info *info = (struct powertec_info *)host->hostdata;\n\n\treturn sprintf(buf, \"%d\\n\", info->term_ctl ? 1 : 0);\n}\n\nstatic ssize_t\npowertecscsi_store_term(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct expansion_card *ec = ECARD_DEV(dev);\n\tstruct Scsi_Host *host = ecard_get_drvdata(ec);\n\n\tif (len > 1)\n\t\tpowertecscsi_terminator_ctl(host, buf[0] != '0');\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(bus_term, S_IRUGO | S_IWUSR,\n\t\t   powertecscsi_show_term, powertecscsi_store_term);\n\nstatic const struct scsi_host_template powertecscsi_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.show_info\t\t\t= powertecscsi_show_info,\n\t.write_info\t\t\t= powertecscsi_set_proc_info,\n\t.name\t\t\t\t= \"PowerTec SCSI\",\n\t.info\t\t\t\t= powertecscsi_info,\n\t.queuecommand\t\t\t= fas216_queue_command,\n\t.eh_host_reset_handler\t\t= fas216_eh_host_reset,\n\t.eh_bus_reset_handler\t\t= fas216_eh_bus_reset,\n\t.eh_device_reset_handler\t= fas216_eh_device_reset,\n\t.eh_abort_handler\t\t= fas216_eh_abort,\n\t.cmd_size\t\t\t= sizeof(struct fas216_cmd_priv),\n\t.can_queue\t\t\t= 8,\n\t.this_id\t\t\t= 7,\n\t.sg_tablesize\t\t\t= SG_MAX_SEGMENTS,\n\t.dma_boundary\t\t\t= IOMD_DMA_BOUNDARY,\n\t.cmd_per_lun\t\t\t= 2,\n\t.proc_name\t\t\t= \"powertec\",\n};\n\nstatic int powertecscsi_probe(struct expansion_card *ec,\n\t\t\t      const struct ecard_id *id)\n{\n\tstruct Scsi_Host *host;\n\tstruct powertec_info *info;\n\tvoid __iomem *base;\n\tint ret;\n\n\tret = ecard_request_resources(ec);\n\tif (ret)\n\t\tgoto out;\n\n\tbase = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);\n\tif (!base) {\n\t\tret = -ENOMEM;\n\t\tgoto out_region;\n\t}\n\n\thost = scsi_host_alloc(&powertecscsi_template,\n\t\t\t       sizeof (struct powertec_info));\n\tif (!host) {\n\t\tret = -ENOMEM;\n\t\tgoto out_region;\n\t}\n\n\tecard_set_drvdata(ec, host);\n\n\tinfo = (struct powertec_info *)host->hostdata;\n\tinfo->base = base;\n\tpowertecscsi_terminator_ctl(host, term[ec->slot_no]);\n\n\tinfo->ec = ec;\n\tinfo->info.scsi.io_base\t\t= base + POWERTEC_FAS216_OFFSET;\n\tinfo->info.scsi.io_shift\t= POWERTEC_FAS216_SHIFT;\n\tinfo->info.scsi.irq\t\t= ec->irq;\n\tinfo->info.scsi.dma\t\t= ec->dma;\n\tinfo->info.ifcfg.clockrate\t= 40;  \n\tinfo->info.ifcfg.select_timeout\t= 255;\n\tinfo->info.ifcfg.asyncperiod\t= 200;  \n\tinfo->info.ifcfg.sync_max_depth\t= 7;\n\tinfo->info.ifcfg.cntl3\t\t= CNTL3_BS8 | CNTL3_FASTSCSI | CNTL3_FASTCLK;\n\tinfo->info.ifcfg.disconnect_ok\t= 1;\n\tinfo->info.ifcfg.wide_max_size\t= 0;\n\tinfo->info.ifcfg.capabilities\t= 0;\n\tinfo->info.dma.setup\t\t= powertecscsi_dma_setup;\n\tinfo->info.dma.pseudo\t\t= NULL;\n\tinfo->info.dma.stop\t\t= powertecscsi_dma_stop;\n\n\tec->irqaddr\t= base + POWERTEC_INTR_STATUS;\n\tec->irqmask\t= POWERTEC_INTR_BIT;\n\n\tecard_setirq(ec, &powertecscsi_ops, info);\n\n\tdevice_create_file(&ec->dev, &dev_attr_bus_term);\n\n\tret = fas216_init(host);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = request_irq(ec->irq, powertecscsi_intr,\n\t\t\t  0, \"powertec\", info);\n\tif (ret) {\n\t\tprintk(\"scsi%d: IRQ%d not free: %d\\n\",\n\t\t       host->host_no, ec->irq, ret);\n\t\tgoto out_release;\n\t}\n\n\tif (info->info.scsi.dma != NO_DMA) {\n\t\tif (request_dma(info->info.scsi.dma, \"powertec\")) {\n\t\t\tprintk(\"scsi%d: DMA%d not free, using PIO\\n\",\n\t\t\t       host->host_no, info->info.scsi.dma);\n\t\t\tinfo->info.scsi.dma = NO_DMA;\n\t\t} else {\n\t\t\tset_dma_speed(info->info.scsi.dma, 180);\n\t\t\tinfo->info.ifcfg.capabilities |= FASCAP_DMA;\n\t\t}\n\t}\n\n\tret = fas216_add(host, &ec->dev);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tif (info->info.scsi.dma != NO_DMA)\n\t\tfree_dma(info->info.scsi.dma);\n\tfree_irq(ec->irq, info);\n\n out_release:\n\tfas216_release(host);\n\n out_free:\n\tdevice_remove_file(&ec->dev, &dev_attr_bus_term);\n\tscsi_host_put(host);\n\n out_region:\n\tecard_release_resources(ec);\n\n out:\n\treturn ret;\n}\n\nstatic void powertecscsi_remove(struct expansion_card *ec)\n{\n\tstruct Scsi_Host *host = ecard_get_drvdata(ec);\n\tstruct powertec_info *info = (struct powertec_info *)host->hostdata;\n\n\tecard_set_drvdata(ec, NULL);\n\tfas216_remove(host);\n\n\tdevice_remove_file(&ec->dev, &dev_attr_bus_term);\n\n\tif (info->info.scsi.dma != NO_DMA)\n\t\tfree_dma(info->info.scsi.dma);\n\tfree_irq(ec->irq, info);\n\n\tfas216_release(host);\n\tscsi_host_put(host);\n\tecard_release_resources(ec);\n}\n\nstatic const struct ecard_id powertecscsi_cids[] = {\n\t{ MANU_ALSYSTEMS, PROD_ALSYS_SCSIATAPI },\n\t{ 0xffff, 0xffff },\n};\n\nstatic struct ecard_driver powertecscsi_driver = {\n\t.probe\t\t= powertecscsi_probe,\n\t.remove\t\t= powertecscsi_remove,\n\t.id_table\t= powertecscsi_cids,\n\t.drv = {\n\t\t.name\t\t= \"powertecscsi\",\n\t},\n};\n\nstatic int __init powertecscsi_init(void)\n{\n\treturn ecard_register_driver(&powertecscsi_driver);\n}\n\nstatic void __exit powertecscsi_exit(void)\n{\n\tecard_remove_driver(&powertecscsi_driver);\n}\n\nmodule_init(powertecscsi_init);\nmodule_exit(powertecscsi_exit);\n\nMODULE_AUTHOR(\"Russell King\");\nMODULE_DESCRIPTION(\"Powertec SCSI driver\");\nmodule_param_array(term, int, NULL, 0);\nMODULE_PARM_DESC(term, \"SCSI bus termination\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}