{
  "module_name": "msgqueue.c",
  "hash_id": "2506f0cc9cbfc18fc034eef8e74e1863f6b4ae43f656eada8c5a8b226c250c98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/arm/msgqueue.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/init.h>\n\n#include \"msgqueue.h\"\n\n \nstatic struct msgqueue_entry *mqe_alloc(MsgQueue_t *msgq)\n{\n\tstruct msgqueue_entry *mq;\n\n\tif ((mq = msgq->free) != NULL)\n\t\tmsgq->free = mq->next;\n\n\treturn mq;\n}\n\n \nstatic void mqe_free(MsgQueue_t *msgq, struct msgqueue_entry *mq)\n{\n\tif (mq) {\n\t\tmq->next = msgq->free;\n\t\tmsgq->free = mq;\n\t}\n}\n\n \nvoid msgqueue_initialise(MsgQueue_t *msgq)\n{\n\tint i;\n\n\tmsgq->qe = NULL;\n\tmsgq->free = &msgq->entries[0];\n\n\tfor (i = 0; i < NR_MESSAGES; i++)\n\t\tmsgq->entries[i].next = &msgq->entries[i + 1];\n\n\tmsgq->entries[NR_MESSAGES - 1].next = NULL;\n}\n\n\n \nvoid msgqueue_free(MsgQueue_t *msgq)\n{\n}\n\n \nint msgqueue_msglength(MsgQueue_t *msgq)\n{\n\tstruct msgqueue_entry *mq = msgq->qe;\n\tint length = 0;\n\n\tfor (mq = msgq->qe; mq; mq = mq->next)\n\t\tlength += mq->msg.length;\n\n\treturn length;\n}\n\n \nstruct message *msgqueue_getmsg(MsgQueue_t *msgq, int msgno)\n{\n\tstruct msgqueue_entry *mq;\n\n\tfor (mq = msgq->qe; mq && msgno; mq = mq->next, msgno--);\n\n\treturn mq ? &mq->msg : NULL;\n}\n\n \nint msgqueue_addmsg(MsgQueue_t *msgq, int length, ...)\n{\n\tstruct msgqueue_entry *mq = mqe_alloc(msgq);\n\tva_list ap;\n\n\tif (mq) {\n\t\tstruct msgqueue_entry **mqp;\n\t\tint i;\n\n\t\tva_start(ap, length);\n\t\tfor (i = 0; i < length; i++)\n\t\t\tmq->msg.msg[i] = va_arg(ap, unsigned int);\n\t\tva_end(ap);\n\n\t\tmq->msg.length = length;\n\t\tmq->msg.fifo = 0;\n\t\tmq->next = NULL;\n\n\t\tmqp = &msgq->qe;\n\t\twhile (*mqp)\n\t\t\tmqp = &(*mqp)->next;\n\n\t\t*mqp = mq;\n\t}\n\n\treturn mq != NULL;\n}\n\n \nvoid msgqueue_flush(MsgQueue_t *msgq)\n{\n\tstruct msgqueue_entry *mq, *mqnext;\n\n\tfor (mq = msgq->qe; mq; mq = mqnext) {\n\t\tmqnext = mq->next;\n\t\tmqe_free(msgq, mq);\n\t}\n\tmsgq->qe = NULL;\n}\n\nEXPORT_SYMBOL(msgqueue_initialise);\nEXPORT_SYMBOL(msgqueue_free);\nEXPORT_SYMBOL(msgqueue_msglength);\nEXPORT_SYMBOL(msgqueue_getmsg);\nEXPORT_SYMBOL(msgqueue_addmsg);\nEXPORT_SYMBOL(msgqueue_flush);\n\nMODULE_AUTHOR(\"Russell King\");\nMODULE_DESCRIPTION(\"SCSI message queue handling\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}