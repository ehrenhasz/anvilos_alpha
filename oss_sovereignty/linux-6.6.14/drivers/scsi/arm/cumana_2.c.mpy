{
  "module_name": "cumana_2.c",
  "hash_id": "82f8bd8ea6187c4ce4924e9a76034432ab53685bf90caa529670827ca4c0dcdf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/arm/cumana_2.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ioport.h>\n#include <linux/proc_fs.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/dma-mapping.h>\n#include <linux/pgtable.h>\n\n#include <asm/dma.h>\n#include <asm/ecard.h>\n#include <asm/io.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include \"fas216.h\"\n#include \"arm_scsi.h\"\n\n#include <scsi/scsicam.h>\n\n#define CUMANASCSI2_STATUS\t\t(0x0000)\n#define STATUS_INT\t\t\t(1 << 0)\n#define STATUS_DRQ\t\t\t(1 << 1)\n#define STATUS_LATCHED\t\t\t(1 << 3)\n\n#define CUMANASCSI2_ALATCH\t\t(0x0014)\n#define ALATCH_ENA_INT\t\t\t(3)\n#define ALATCH_DIS_INT\t\t\t(2)\n#define ALATCH_ENA_TERM\t\t\t(5)\n#define ALATCH_DIS_TERM\t\t\t(4)\n#define ALATCH_ENA_BIT32\t\t(11)\n#define ALATCH_DIS_BIT32\t\t(10)\n#define ALATCH_ENA_DMA\t\t\t(13)\n#define ALATCH_DIS_DMA\t\t\t(12)\n#define ALATCH_DMA_OUT\t\t\t(15)\n#define ALATCH_DMA_IN\t\t\t(14)\n\n#define CUMANASCSI2_PSEUDODMA\t\t(0x0200)\n\n#define CUMANASCSI2_FAS216_OFFSET\t(0x0300)\n#define CUMANASCSI2_FAS216_SHIFT\t2\n\n \n#define VERSION \"1.00 (13/11/2002 2.5.47)\"\n\n \nstatic int term[MAX_ECARDS] = { 1, 1, 1, 1, 1, 1, 1, 1 };\n\n#define NR_SG\t256\n\nstruct cumanascsi2_info {\n\tFAS216_Info\t\tinfo;\n\tstruct expansion_card\t*ec;\n\tvoid __iomem\t\t*base;\n\tunsigned int\t\tterms;\t\t \n\tstruct scatterlist\tsg[NR_SG];\t \n};\n\n#define CSTATUS_IRQ\t(1 << 0)\n#define CSTATUS_DRQ\t(1 << 1)\n\n \nstatic void\ncumanascsi_2_irqenable(struct expansion_card *ec, int irqnr)\n{\n\tstruct cumanascsi2_info *info = ec->irq_data;\n\twriteb(ALATCH_ENA_INT, info->base + CUMANASCSI2_ALATCH);\n}\n\n \nstatic void\ncumanascsi_2_irqdisable(struct expansion_card *ec, int irqnr)\n{\n\tstruct cumanascsi2_info *info = ec->irq_data;\n\twriteb(ALATCH_DIS_INT, info->base + CUMANASCSI2_ALATCH);\n}\n\nstatic const expansioncard_ops_t cumanascsi_2_ops = {\n\t.irqenable\t= cumanascsi_2_irqenable,\n\t.irqdisable\t= cumanascsi_2_irqdisable,\n};\n\n \nstatic void\ncumanascsi_2_terminator_ctl(struct Scsi_Host *host, int on_off)\n{\n\tstruct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;\n\n\tif (on_off) {\n\t\tinfo->terms = 1;\n\t\twriteb(ALATCH_ENA_TERM, info->base + CUMANASCSI2_ALATCH);\n\t} else {\n\t\tinfo->terms = 0;\n\t\twriteb(ALATCH_DIS_TERM, info->base + CUMANASCSI2_ALATCH);\n\t}\n}\n\n \nstatic irqreturn_t\ncumanascsi_2_intr(int irq, void *dev_id)\n{\n\tstruct cumanascsi2_info *info = dev_id;\n\n\treturn fas216_intr(&info->info);\n}\n\n \nstatic fasdmatype_t\ncumanascsi_2_dma_setup(struct Scsi_Host *host, struct scsi_pointer *SCp,\n\t\t       fasdmadir_t direction, fasdmatype_t min_type)\n{\n\tstruct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;\n\tstruct device *dev = scsi_get_device(host);\n\tint dmach = info->info.scsi.dma;\n\n\twriteb(ALATCH_DIS_DMA, info->base + CUMANASCSI2_ALATCH);\n\n\tif (dmach != NO_DMA &&\n\t    (min_type == fasdma_real_all || SCp->this_residual >= 512)) {\n\t\tint bufs, map_dir, dma_dir, alatch_dir;\n\n\t\tbufs = copy_SCp_to_sg(&info->sg[0], SCp, NR_SG);\n\n\t\tif (direction == DMA_OUT) {\n\t\t\tmap_dir = DMA_TO_DEVICE;\n\t\t\tdma_dir = DMA_MODE_WRITE;\n\t\t\talatch_dir = ALATCH_DMA_OUT;\n\t\t} else {\n\t\t\tmap_dir = DMA_FROM_DEVICE;\n\t\t\tdma_dir = DMA_MODE_READ;\n\t\t\talatch_dir = ALATCH_DMA_IN;\n\t\t}\n\n\t\tdma_map_sg(dev, info->sg, bufs, map_dir);\n\n\t\tdisable_dma(dmach);\n\t\tset_dma_sg(dmach, info->sg, bufs);\n\t\twriteb(alatch_dir, info->base + CUMANASCSI2_ALATCH);\n\t\tset_dma_mode(dmach, dma_dir);\n\t\tenable_dma(dmach);\n\t\twriteb(ALATCH_ENA_DMA, info->base + CUMANASCSI2_ALATCH);\n\t\twriteb(ALATCH_DIS_BIT32, info->base + CUMANASCSI2_ALATCH);\n\t\treturn fasdma_real_all;\n\t}\n\n\t \n\treturn fasdma_pio;\n}\n\n \nstatic void\ncumanascsi_2_dma_pseudo(struct Scsi_Host *host, struct scsi_pointer *SCp,\n\t\t\tfasdmadir_t direction, int transfer)\n{\n\tstruct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;\n\tunsigned int length;\n\tunsigned char *addr;\n\n\tlength = SCp->this_residual;\n\taddr = SCp->ptr;\n\n\tif (direction == DMA_OUT)\n#if 0\n\t\twhile (length > 1) {\n\t\t\tunsigned long word;\n\t\t\tunsigned int status = readb(info->base + CUMANASCSI2_STATUS);\n\n\t\t\tif (status & STATUS_INT)\n\t\t\t\tgoto end;\n\n\t\t\tif (!(status & STATUS_DRQ))\n\t\t\t\tcontinue;\n\n\t\t\tword = *addr | *(addr + 1) << 8;\n\t\t\twritew(word, info->base + CUMANASCSI2_PSEUDODMA);\n\t\t\taddr += 2;\n\t\t\tlength -= 2;\n\t\t}\n#else\n\t\tprintk (\"PSEUDO_OUT???\\n\");\n#endif\n\telse {\n\t\tif (transfer && (transfer & 255)) {\n\t\t\twhile (length >= 256) {\n\t\t\t\tunsigned int status = readb(info->base + CUMANASCSI2_STATUS);\n\n\t\t\t\tif (status & STATUS_INT)\n\t\t\t\t\treturn;\n\t    \n\t\t\t\tif (!(status & STATUS_DRQ))\n\t\t\t\t\tcontinue;\n\n\t\t\t\treadsw(info->base + CUMANASCSI2_PSEUDODMA,\n\t\t\t\t       addr, 256 >> 1);\n\t\t\t\taddr += 256;\n\t\t\t\tlength -= 256;\n\t\t\t}\n\t\t}\n\n\t\twhile (length > 0) {\n\t\t\tunsigned long word;\n\t\t\tunsigned int status = readb(info->base + CUMANASCSI2_STATUS);\n\n\t\t\tif (status & STATUS_INT)\n\t\t\t\treturn;\n\n\t\t\tif (!(status & STATUS_DRQ))\n\t\t\t\tcontinue;\n\n\t\t\tword = readw(info->base + CUMANASCSI2_PSEUDODMA);\n\t\t\t*addr++ = word;\n\t\t\tif (--length > 0) {\n\t\t\t\t*addr++ = word >> 8;\n\t\t\t\tlength --;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void\ncumanascsi_2_dma_stop(struct Scsi_Host *host, struct scsi_pointer *SCp)\n{\n\tstruct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;\n\tif (info->info.scsi.dma != NO_DMA) {\n\t\twriteb(ALATCH_DIS_DMA, info->base + CUMANASCSI2_ALATCH);\n\t\tdisable_dma(info->info.scsi.dma);\n\t}\n}\n\n \nconst char *cumanascsi_2_info(struct Scsi_Host *host)\n{\n\tstruct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;\n\tstatic char string[150];\n\n\tsprintf(string, \"%s (%s) in slot %d v%s terminators o%s\",\n\t\thost->hostt->name, info->info.scsi.type, info->ec->slot_no,\n\t\tVERSION, info->terms ? \"n\" : \"ff\");\n\n\treturn string;\n}\n\n \nstatic int\ncumanascsi_2_set_proc_info(struct Scsi_Host *host, char *buffer, int length)\n{\n\tint ret = length;\n\n\tif (length >= 11 && strncmp(buffer, \"CUMANASCSI2\", 11) == 0) {\n\t\tbuffer += 11;\n\t\tlength -= 11;\n\n\t\tif (length >= 5 && strncmp(buffer, \"term=\", 5) == 0) {\n\t\t\tif (buffer[5] == '1')\n\t\t\t\tcumanascsi_2_terminator_ctl(host, 1);\n\t\t\telse if (buffer[5] == '0')\n\t\t\t\tcumanascsi_2_terminator_ctl(host, 0);\n\t\t\telse\n\t\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int cumanascsi_2_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tstruct cumanascsi2_info *info;\n\tinfo = (struct cumanascsi2_info *)host->hostdata;\n\n\tseq_printf(m, \"Cumana SCSI II driver v%s\\n\", VERSION);\n\tfas216_print_host(&info->info, m);\n\tseq_printf(m, \"Term    : o%s\\n\",\n\t\t\tinfo->terms ? \"n\" : \"ff\");\n\n\tfas216_print_stats(&info->info, m);\n\tfas216_print_devices(&info->info, m);\n\treturn 0;\n}\n\nstatic const struct scsi_host_template cumanascsi2_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.show_info\t\t\t= cumanascsi_2_show_info,\n\t.write_info\t\t\t= cumanascsi_2_set_proc_info,\n\t.name\t\t\t\t= \"Cumana SCSI II\",\n\t.info\t\t\t\t= cumanascsi_2_info,\n\t.queuecommand\t\t\t= fas216_queue_command,\n\t.eh_host_reset_handler\t\t= fas216_eh_host_reset,\n\t.eh_bus_reset_handler\t\t= fas216_eh_bus_reset,\n\t.eh_device_reset_handler\t= fas216_eh_device_reset,\n\t.eh_abort_handler\t\t= fas216_eh_abort,\n\t.cmd_size\t\t\t= sizeof(struct fas216_cmd_priv),\n\t.can_queue\t\t\t= 1,\n\t.this_id\t\t\t= 7,\n\t.sg_tablesize\t\t\t= SG_MAX_SEGMENTS,\n\t.dma_boundary\t\t\t= IOMD_DMA_BOUNDARY,\n\t.proc_name\t\t\t= \"cumanascsi2\",\n};\n\nstatic int cumanascsi2_probe(struct expansion_card *ec,\n\t\t\t     const struct ecard_id *id)\n{\n\tstruct Scsi_Host *host;\n\tstruct cumanascsi2_info *info;\n\tvoid __iomem *base;\n\tint ret;\n\n\tret = ecard_request_resources(ec);\n\tif (ret)\n\t\tgoto out;\n\n\tbase = ecardm_iomap(ec, ECARD_RES_MEMC, 0, 0);\n\tif (!base) {\n\t\tret = -ENOMEM;\n\t\tgoto out_region;\n\t}\n\n\thost = scsi_host_alloc(&cumanascsi2_template,\n\t\t\t       sizeof(struct cumanascsi2_info));\n\tif (!host) {\n\t\tret = -ENOMEM;\n\t\tgoto out_region;\n\t}\n\n\tecard_set_drvdata(ec, host);\n\n\tinfo = (struct cumanascsi2_info *)host->hostdata;\n\tinfo->ec\t= ec;\n\tinfo->base\t= base;\n\n\tcumanascsi_2_terminator_ctl(host, term[ec->slot_no]);\n\n\tinfo->info.scsi.io_base\t\t= base + CUMANASCSI2_FAS216_OFFSET;\n\tinfo->info.scsi.io_shift\t= CUMANASCSI2_FAS216_SHIFT;\n\tinfo->info.scsi.irq\t\t= ec->irq;\n\tinfo->info.scsi.dma\t\t= ec->dma;\n\tinfo->info.ifcfg.clockrate\t= 40;  \n\tinfo->info.ifcfg.select_timeout\t= 255;\n\tinfo->info.ifcfg.asyncperiod\t= 200;  \n\tinfo->info.ifcfg.sync_max_depth\t= 7;\n\tinfo->info.ifcfg.cntl3\t\t= CNTL3_BS8 | CNTL3_FASTSCSI | CNTL3_FASTCLK;\n\tinfo->info.ifcfg.disconnect_ok\t= 1;\n\tinfo->info.ifcfg.wide_max_size\t= 0;\n\tinfo->info.ifcfg.capabilities\t= FASCAP_PSEUDODMA;\n\tinfo->info.dma.setup\t\t= cumanascsi_2_dma_setup;\n\tinfo->info.dma.pseudo\t\t= cumanascsi_2_dma_pseudo;\n\tinfo->info.dma.stop\t\t= cumanascsi_2_dma_stop;\n\n\tec->irqaddr\t= info->base + CUMANASCSI2_STATUS;\n\tec->irqmask\t= STATUS_INT;\n\n\tecard_setirq(ec, &cumanascsi_2_ops, info);\n\n\tret = fas216_init(host);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = request_irq(ec->irq, cumanascsi_2_intr,\n\t\t\t  0, \"cumanascsi2\", info);\n\tif (ret) {\n\t\tprintk(\"scsi%d: IRQ%d not free: %d\\n\",\n\t\t       host->host_no, ec->irq, ret);\n\t\tgoto out_release;\n\t}\n\n\tif (info->info.scsi.dma != NO_DMA) {\n\t\tif (request_dma(info->info.scsi.dma, \"cumanascsi2\")) {\n\t\t\tprintk(\"scsi%d: DMA%d not free, using PIO\\n\",\n\t\t\t       host->host_no, info->info.scsi.dma);\n\t\t\tinfo->info.scsi.dma = NO_DMA;\n\t\t} else {\n\t\t\tset_dma_speed(info->info.scsi.dma, 180);\n\t\t\tinfo->info.ifcfg.capabilities |= FASCAP_DMA;\n\t\t}\n\t}\n\n\tret = fas216_add(host, &ec->dev);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tif (info->info.scsi.dma != NO_DMA)\n\t\tfree_dma(info->info.scsi.dma);\n\tfree_irq(ec->irq, info);\n\n out_release:\n\tfas216_release(host);\n\n out_free:\n\tscsi_host_put(host);\n\n out_region:\n\tecard_release_resources(ec);\n\n out:\n\treturn ret;\n}\n\nstatic void cumanascsi2_remove(struct expansion_card *ec)\n{\n\tstruct Scsi_Host *host = ecard_get_drvdata(ec);\n\tstruct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;\n\n\tecard_set_drvdata(ec, NULL);\n\tfas216_remove(host);\n\n\tif (info->info.scsi.dma != NO_DMA)\n\t\tfree_dma(info->info.scsi.dma);\n\tfree_irq(ec->irq, info);\n\n\tfas216_release(host);\n\tscsi_host_put(host);\n\tecard_release_resources(ec);\n}\n\nstatic const struct ecard_id cumanascsi2_cids[] = {\n\t{ MANU_CUMANA, PROD_CUMANA_SCSI_2 },\n\t{ 0xffff, 0xffff },\n};\n\nstatic struct ecard_driver cumanascsi2_driver = {\n\t.probe\t\t= cumanascsi2_probe,\n\t.remove\t\t= cumanascsi2_remove,\n\t.id_table\t= cumanascsi2_cids,\n\t.drv = {\n\t\t.name\t\t= \"cumanascsi2\",\n\t},\n};\n\nstatic int __init cumanascsi2_init(void)\n{\n\treturn ecard_register_driver(&cumanascsi2_driver);\n}\n\nstatic void __exit cumanascsi2_exit(void)\n{\n\tecard_remove_driver(&cumanascsi2_driver);\n}\n\nmodule_init(cumanascsi2_init);\nmodule_exit(cumanascsi2_exit);\n\nMODULE_AUTHOR(\"Russell King\");\nMODULE_DESCRIPTION(\"Cumana SCSI-2 driver for Acorn machines\");\nmodule_param_array(term, int, NULL, 0);\nMODULE_PARM_DESC(term, \"SCSI bus termination\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}