{
  "module_name": "arxescsi.c",
  "hash_id": "7fccd47768a4667565b7c54a7782104c19a851b73819d3b86afb029671a44dc8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/arm/arxescsi.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ioport.h>\n#include <linux/proc_fs.h>\n#include <linux/unistd.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <asm/ecard.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include \"fas216.h\"\n\nstruct arxescsi_info {\n\tFAS216_Info\t\tinfo;\n\tstruct expansion_card\t*ec;\n\tvoid __iomem\t\t*base;\n};\n\n#define DMADATA_OFFSET\t(0x200)\n\n#define DMASTAT_OFFSET\t(0x600)\n#define DMASTAT_DRQ\t(1 << 0)\n\n#define CSTATUS_IRQ\t(1 << 0)\n\n#define VERSION \"1.10 (23/01/2003 2.5.57)\"\n\n \nstatic fasdmatype_t\narxescsi_dma_setup(struct Scsi_Host *host, struct scsi_pointer *SCp,\n\t\t       fasdmadir_t direction, fasdmatype_t min_type)\n{\n\t \n\treturn fasdma_pseudo;\n}\n\nstatic void arxescsi_pseudo_dma_write(unsigned char *addr, void __iomem *base)\n{\n       __asm__ __volatile__(\n       \"               stmdb   sp!, {r0-r12}\\n\"\n       \"               mov     r3, %0\\n\"\n       \"               mov     r1, %1\\n\"\n       \"               add     r2, r1, #512\\n\"\n       \"               mov     r4, #256\\n\"\n       \".loop_1:       ldmia   r3!, {r6, r8, r10, r12}\\n\"\n       \"               mov     r5, r6, lsl #16\\n\"\n       \"               mov     r7, r8, lsl #16\\n\"\n       \".loop_2:       ldrb    r0, [r1, #1536]\\n\"\n       \"               tst     r0, #1\\n\"\n       \"               beq     .loop_2\\n\"\n       \"               stmia   r2, {r5-r8}\\n\\t\"\n       \"               mov     r9, r10, lsl #16\\n\"\n       \"               mov     r11, r12, lsl #16\\n\"\n       \".loop_3:       ldrb    r0, [r1, #1536]\\n\"\n       \"               tst     r0, #1\\n\"\n       \"               beq     .loop_3\\n\"\n       \"               stmia   r2, {r9-r12}\\n\"\n       \"               subs    r4, r4, #16\\n\"\n       \"               bne     .loop_1\\n\"\n       \"               ldmia   sp!, {r0-r12}\\n\"\n       :\n       : \"r\" (addr), \"r\" (base));\n}\n\n \nstatic void\narxescsi_dma_pseudo(struct Scsi_Host *host, struct scsi_pointer *SCp,\n\t\t    fasdmadir_t direction, int transfer)\n{\n\tstruct arxescsi_info *info = (struct arxescsi_info *)host->hostdata;\n\tunsigned int length, error = 0;\n\tvoid __iomem *base = info->info.scsi.io_base;\n\tunsigned char *addr;\n\n\tlength = SCp->this_residual;\n\taddr = SCp->ptr;\n\n\tif (direction == DMA_OUT) {\n\t\tunsigned int word;\n\t\twhile (length > 256) {\n\t\t\tif (readb(base + 0x80) & STAT_INT) {\n\t\t\t\terror = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tarxescsi_pseudo_dma_write(addr, base);\n\t\t\taddr += 256;\n\t\t\tlength -= 256;\n\t\t}\n\n\t\tif (!error)\n\t\t\twhile (length > 0) {\n\t\t\t\tif (readb(base + 0x80) & STAT_INT)\n\t\t\t\t\tbreak;\n\t \n\t\t\t\tif (!(readb(base + DMASTAT_OFFSET) & DMASTAT_DRQ))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tword = *addr | *(addr + 1) << 8;\n\n\t\t\t\twritew(word, base + DMADATA_OFFSET);\n\t\t\t\tif (length > 1) {\n\t\t\t\t\taddr += 2;\n\t\t\t\t\tlength -= 2;\n\t\t\t\t} else {\n\t\t\t\t\taddr += 1;\n\t\t\t\t\tlength -= 1;\n\t\t\t\t}\n\t\t\t}\n\t}\n\telse {\n\t\tif (transfer && (transfer & 255)) {\n\t\t\twhile (length >= 256) {\n\t\t\t\tif (readb(base + 0x80) & STAT_INT) {\n\t\t\t\t\terror = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t    \n\t\t\t\tif (!(readb(base + DMASTAT_OFFSET) & DMASTAT_DRQ))\n\t\t\t\t\tcontinue;\n\n\t\t\t\treadsw(base + DMADATA_OFFSET, addr, 256 >> 1);\n\t\t\t\taddr += 256;\n\t\t\t\tlength -= 256;\n\t\t\t}\n\t\t}\n\n\t\tif (!(error))\n\t\t\twhile (length > 0) {\n\t\t\t\tunsigned long word;\n\n\t\t\t\tif (readb(base + 0x80) & STAT_INT)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (!(readb(base + DMASTAT_OFFSET) & DMASTAT_DRQ))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tword = readw(base + DMADATA_OFFSET);\n\t\t\t\t*addr++ = word;\n\t\t\t\tif (--length > 0) {\n\t\t\t\t\t*addr++ = word >> 8;\n\t\t\t\t\tlength --;\n\t\t\t\t}\n\t\t\t}\n\t}\n}\n\n \nstatic void arxescsi_dma_stop(struct Scsi_Host *host, struct scsi_pointer *SCp)\n{\n\t \n}\n\n \nstatic const char *arxescsi_info(struct Scsi_Host *host)\n{\n\tstruct arxescsi_info *info = (struct arxescsi_info *)host->hostdata;\n\tstatic char string[150];\n\n\tsprintf(string, \"%s (%s) in slot %d v%s\",\n\t\thost->hostt->name, info->info.scsi.type, info->ec->slot_no,\n\t\tVERSION);\n\n\treturn string;\n}\n\nstatic int\narxescsi_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tstruct arxescsi_info *info;\n\tinfo = (struct arxescsi_info *)host->hostdata;\n\n\tseq_printf(m, \"ARXE 16-bit SCSI driver v%s\\n\", VERSION);\n\tfas216_print_host(&info->info, m);\n\tfas216_print_stats(&info->info, m);\n\tfas216_print_devices(&info->info, m);\n\treturn 0;\n}\n\nstatic const struct scsi_host_template arxescsi_template = {\n\t.show_info\t\t\t= arxescsi_show_info,\n\t.name\t\t\t\t= \"ARXE SCSI card\",\n\t.info\t\t\t\t= arxescsi_info,\n\t.queuecommand\t\t\t= fas216_noqueue_command,\n\t.eh_host_reset_handler\t\t= fas216_eh_host_reset,\n\t.eh_bus_reset_handler\t\t= fas216_eh_bus_reset,\n\t.eh_device_reset_handler\t= fas216_eh_device_reset,\n\t.eh_abort_handler\t\t= fas216_eh_abort,\n\t.cmd_size\t\t\t= sizeof(struct fas216_cmd_priv),\n\t.can_queue\t\t\t= 0,\n\t.this_id\t\t\t= 7,\n\t.sg_tablesize\t\t\t= SG_ALL,\n\t.dma_boundary\t\t\t= PAGE_SIZE - 1,\n\t.proc_name\t\t\t= \"arxescsi\",\n};\n\nstatic int arxescsi_probe(struct expansion_card *ec, const struct ecard_id *id)\n{\n\tstruct Scsi_Host *host;\n\tstruct arxescsi_info *info;\n\tvoid __iomem *base;\n\tint ret;\n\n\tret = ecard_request_resources(ec);\n\tif (ret)\n\t\tgoto out;\n\n\tbase = ecardm_iomap(ec, ECARD_RES_MEMC, 0, 0);\n\tif (!base) {\n\t\tret = -ENOMEM;\n\t\tgoto out_region;\n\t}\n\n\thost = scsi_host_alloc(&arxescsi_template, sizeof(struct arxescsi_info));\n\tif (!host) {\n\t\tret = -ENOMEM;\n\t\tgoto out_region;\n\t}\n\n\tinfo = (struct arxescsi_info *)host->hostdata;\n\tinfo->ec = ec;\n\tinfo->base = base;\n\n\tinfo->info.scsi.io_base\t\t= base + 0x2000;\n\tinfo->info.scsi.irq\t\t= 0;\n\tinfo->info.scsi.dma\t\t= NO_DMA;\n\tinfo->info.scsi.io_shift\t= 5;\n\tinfo->info.ifcfg.clockrate\t= 24;  \n\tinfo->info.ifcfg.select_timeout = 255;\n\tinfo->info.ifcfg.asyncperiod\t= 200;  \n\tinfo->info.ifcfg.sync_max_depth\t= 0;\n\tinfo->info.ifcfg.cntl3\t\t= CNTL3_FASTSCSI | CNTL3_FASTCLK;\n\tinfo->info.ifcfg.disconnect_ok\t= 0;\n\tinfo->info.ifcfg.wide_max_size\t= 0;\n\tinfo->info.ifcfg.capabilities\t= FASCAP_PSEUDODMA;\n\tinfo->info.dma.setup\t\t= arxescsi_dma_setup;\n\tinfo->info.dma.pseudo\t\t= arxescsi_dma_pseudo;\n\tinfo->info.dma.stop\t\t= arxescsi_dma_stop;\n\t\t\n\tec->irqaddr = base;\n\tec->irqmask = CSTATUS_IRQ;\n\n\tret = fas216_init(host);\n\tif (ret)\n\t\tgoto out_unregister;\n\n\tret = fas216_add(host, &ec->dev);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tfas216_release(host);\n out_unregister:\n\tscsi_host_put(host);\n out_region:\n\tecard_release_resources(ec);\n out:\n\treturn ret;\n}\n\nstatic void arxescsi_remove(struct expansion_card *ec)\n{\n\tstruct Scsi_Host *host = ecard_get_drvdata(ec);\n\n\tecard_set_drvdata(ec, NULL);\n\tfas216_remove(host);\n\n\tfas216_release(host);\n\tscsi_host_put(host);\n\tecard_release_resources(ec);\n}\n\nstatic const struct ecard_id arxescsi_cids[] = {\n\t{ MANU_ARXE, PROD_ARXE_SCSI },\n\t{ 0xffff, 0xffff },\n};\n\nstatic struct ecard_driver arxescsi_driver = {\n\t.probe\t\t= arxescsi_probe,\n\t.remove\t\t= arxescsi_remove,\n\t.id_table\t= arxescsi_cids,\n\t.drv = {\n\t\t.name\t\t= \"arxescsi\",\n\t},\n};\n\nstatic int __init init_arxe_scsi_driver(void)\n{\n\treturn ecard_register_driver(&arxescsi_driver);\n}\n\nstatic void __exit exit_arxe_scsi_driver(void)\n{\n\tecard_remove_driver(&arxescsi_driver);\n}\n\nmodule_init(init_arxe_scsi_driver);\nmodule_exit(exit_arxe_scsi_driver);\n\nMODULE_AUTHOR(\"Stefan Hanske\");\nMODULE_DESCRIPTION(\"ARXESCSI driver for Acorn machines\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}