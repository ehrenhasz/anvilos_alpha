{
  "module_name": "fas216.c",
  "hash_id": "24d923da0b085cc803c9e9270b7a7eb9ecc711793f2fffc8d513e7c96c3d5166",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/arm/fas216.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ioport.h>\n#include <linux/proc_fs.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/ecard.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include \"fas216.h\"\n#include \"arm_scsi.h\"\n\n \n#define SCSI2_SYNC\n\n#undef DEBUG_CONNECT\n#undef DEBUG_MESSAGES\n\n#undef CHECK_STRUCTURE\n\n#define LOG_CONNECT\t\t(1 << 0)\n#define LOG_BUSSERVICE\t\t(1 << 1)\n#define LOG_FUNCTIONDONE\t(1 << 2)\n#define LOG_MESSAGES\t\t(1 << 3)\n#define LOG_BUFFER\t\t(1 << 4)\n#define LOG_ERROR\t\t(1 << 8)\n\nstatic int level_mask = LOG_ERROR;\n\nmodule_param(level_mask, int, 0644);\n\n#ifndef MODULE\nstatic int __init fas216_log_setup(char *str)\n{\n\tchar *s;\n\n\tlevel_mask = 0;\n\n\twhile ((s = strsep(&str, \",\")) != NULL) {\n\t\tswitch (s[0]) {\n\t\tcase 'a':\n\t\t\tif (strcmp(s, \"all\") == 0)\n\t\t\t\tlevel_mask |= -1;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (strncmp(s, \"bus\", 3) == 0)\n\t\t\t\tlevel_mask |= LOG_BUSSERVICE;\n\t\t\tif (strncmp(s, \"buf\", 3) == 0)\n\t\t\t\tlevel_mask |= LOG_BUFFER;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tlevel_mask |= LOG_CONNECT;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tlevel_mask |= LOG_ERROR;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tlevel_mask |= LOG_MESSAGES;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (strcmp(s, \"none\") == 0)\n\t\t\t\tlevel_mask = 0;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tlevel_mask |= LOG_FUNCTIONDONE;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 1;\n}\n\n__setup(\"fas216_logging=\", fas216_log_setup);\n#endif\n\nstatic inline unsigned char fas216_readb(FAS216_Info *info, unsigned int reg)\n{\n\tunsigned int off = reg << info->scsi.io_shift;\n\treturn readb(info->scsi.io_base + off);\n}\n\nstatic inline void fas216_writeb(FAS216_Info *info, unsigned int reg, unsigned int val)\n{\n\tunsigned int off = reg << info->scsi.io_shift;\n\twriteb(val, info->scsi.io_base + off);\n}\n\nstatic void fas216_dumpstate(FAS216_Info *info)\n{\n\tunsigned char is, stat, inst;\n\n\tis   = fas216_readb(info, REG_IS);\n\tstat = fas216_readb(info, REG_STAT);\n\tinst = fas216_readb(info, REG_INST);\n\t\n\tprintk(\"FAS216: CTCL=%02X CTCM=%02X CMD=%02X STAT=%02X\"\n\t       \" INST=%02X IS=%02X CFIS=%02X\",\n\t\tfas216_readb(info, REG_CTCL),\n\t\tfas216_readb(info, REG_CTCM),\n\t\tfas216_readb(info, REG_CMD),  stat, inst, is,\n\t\tfas216_readb(info, REG_CFIS));\n\tprintk(\" CNTL1=%02X CNTL2=%02X CNTL3=%02X CTCH=%02X\\n\",\n\t\tfas216_readb(info, REG_CNTL1),\n\t\tfas216_readb(info, REG_CNTL2),\n\t\tfas216_readb(info, REG_CNTL3),\n\t\tfas216_readb(info, REG_CTCH));\n}\n\nstatic void print_SCp(struct scsi_pointer *SCp, const char *prefix, const char *suffix)\n{\n\tprintk(\"%sptr %p this_residual 0x%x buffer %p buffers_residual 0x%x%s\",\n\t\tprefix, SCp->ptr, SCp->this_residual, SCp->buffer,\n\t\tSCp->buffers_residual, suffix);\n}\n\n#ifdef CHECK_STRUCTURE\nstatic void fas216_dumpinfo(FAS216_Info *info)\n{\n\tstatic int used = 0;\n\tint i;\n\n\tif (used++)\n\t\treturn;\n\n\tprintk(\"FAS216_Info=\\n\");\n\tprintk(\"  { magic_start=%lX host=%p SCpnt=%p origSCpnt=%p\\n\",\n\t\tinfo->magic_start, info->host, info->SCpnt,\n\t\tinfo->origSCpnt);\n\tprintk(\"    scsi={ io_shift=%X irq=%X cfg={ %X %X %X %X }\\n\",\n\t\tinfo->scsi.io_shift, info->scsi.irq,\n\t\tinfo->scsi.cfg[0], info->scsi.cfg[1], info->scsi.cfg[2],\n\t\tinfo->scsi.cfg[3]);\n\tprintk(\"           type=%p phase=%X\\n\",\n\t\tinfo->scsi.type, info->scsi.phase);\n\tprint_SCp(&info->scsi.SCp, \"           SCp={ \", \" }\\n\");\n\tprintk(\"      msgs async_stp=%X disconnectable=%d aborting=%d }\\n\",\n\t\tinfo->scsi.async_stp,\n\t\tinfo->scsi.disconnectable, info->scsi.aborting);\n\tprintk(\"    stats={ queues=%X removes=%X fins=%X reads=%X writes=%X miscs=%X\\n\"\n\t       \"            disconnects=%X aborts=%X bus_resets=%X host_resets=%X}\\n\",\n\t\tinfo->stats.queues, info->stats.removes, info->stats.fins,\n\t\tinfo->stats.reads, info->stats.writes, info->stats.miscs,\n\t\tinfo->stats.disconnects, info->stats.aborts, info->stats.bus_resets,\n\t\tinfo->stats.host_resets);\n\tprintk(\"    ifcfg={ clockrate=%X select_timeout=%X asyncperiod=%X sync_max_depth=%X }\\n\",\n\t\tinfo->ifcfg.clockrate, info->ifcfg.select_timeout,\n\t\tinfo->ifcfg.asyncperiod, info->ifcfg.sync_max_depth);\n\tfor (i = 0; i < 8; i++) {\n\t\tprintk(\"    busyluns[%d]=%08lx dev[%d]={ disconnect_ok=%d stp=%X sof=%X sync_state=%X }\\n\",\n\t\t\ti, info->busyluns[i], i,\n\t\t\tinfo->device[i].disconnect_ok, info->device[i].stp,\n\t\t\tinfo->device[i].sof, info->device[i].sync_state);\n\t}\n\tprintk(\"    dma={ transfer_type=%X setup=%p pseudo=%p stop=%p }\\n\",\n\t\tinfo->dma.transfer_type, info->dma.setup,\n\t\tinfo->dma.pseudo, info->dma.stop);\n\tprintk(\"    internal_done=%X magic_end=%lX }\\n\",\n\t\tinfo->internal_done, info->magic_end);\n}\n\nstatic void __fas216_checkmagic(FAS216_Info *info, const char *func)\n{\n\tint corruption = 0;\n\tif (info->magic_start != MAGIC) {\n\t\tprintk(KERN_CRIT \"FAS216 Error: magic at start corrupted\\n\");\n\t\tcorruption++;\n\t}\n\tif (info->magic_end != MAGIC) {\n\t\tprintk(KERN_CRIT \"FAS216 Error: magic at end corrupted\\n\");\n\t\tcorruption++;\n\t}\n\tif (corruption) {\n\t\tfas216_dumpinfo(info);\n\t\tpanic(\"scsi memory space corrupted in %s\", func);\n\t}\n}\n#define fas216_checkmagic(info) __fas216_checkmagic((info), __func__)\n#else\n#define fas216_checkmagic(info)\n#endif\n\nstatic const char *fas216_bus_phase(int stat)\n{\n\tstatic const char *phases[] = {\n\t\t\"DATA OUT\", \"DATA IN\",\n\t\t\"COMMAND\", \"STATUS\",\n\t\t\"MISC OUT\", \"MISC IN\",\n\t\t\"MESG OUT\", \"MESG IN\"\n\t};\n\n\treturn phases[stat & STAT_BUSMASK];\n}\n\nstatic const char *fas216_drv_phase(FAS216_Info *info)\n{\n\tstatic const char *phases[] = {\n\t\t[PHASE_IDLE]\t\t= \"idle\",\n\t\t[PHASE_SELECTION]\t= \"selection\",\n\t\t[PHASE_COMMAND]\t\t= \"command\",\n\t\t[PHASE_DATAOUT]\t\t= \"data out\",\n\t\t[PHASE_DATAIN]\t\t= \"data in\",\n\t\t[PHASE_MSGIN]\t\t= \"message in\",\n\t\t[PHASE_MSGIN_DISCONNECT]= \"disconnect\",\n\t\t[PHASE_MSGOUT_EXPECT]\t= \"expect message out\",\n\t\t[PHASE_MSGOUT]\t\t= \"message out\",\n\t\t[PHASE_STATUS]\t\t= \"status\",\n\t\t[PHASE_DONE]\t\t= \"done\",\n\t};\n\n\tif (info->scsi.phase < ARRAY_SIZE(phases) &&\n\t    phases[info->scsi.phase])\n\t\treturn phases[info->scsi.phase];\n\treturn \"???\";\n}\n\nstatic char fas216_target(FAS216_Info *info)\n{\n\tif (info->SCpnt)\n\t\treturn '0' + info->SCpnt->device->id;\n\telse\n\t\treturn 'H';\n}\n\nstatic void\nfas216_do_log(FAS216_Info *info, char target, char *fmt, va_list ap)\n{\n\tstatic char buf[1024];\n\n\tvsnprintf(buf, sizeof(buf), fmt, ap);\n\tprintk(\"scsi%d.%c: %s\", info->host->host_no, target, buf);\n}\n\nstatic void fas216_log_command(FAS216_Info *info, int level,\n\t\t\t       struct scsi_cmnd *SCpnt, char *fmt, ...)\n{\n\tva_list args;\n\n\tif (level != 0 && !(level & level_mask))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tfas216_do_log(info, '0' + SCpnt->device->id, fmt, args);\n\tva_end(args);\n\n\tscsi_print_command(SCpnt);\n}\n\nstatic void\nfas216_log_target(FAS216_Info *info, int level, int target, char *fmt, ...)\n{\n\tva_list args;\n\n\tif (level != 0 && !(level & level_mask))\n\t\treturn;\n\n\tif (target < 0)\n\t\ttarget = 'H';\n\telse\n\t\ttarget += '0';\n\n\tva_start(args, fmt);\n\tfas216_do_log(info, target, fmt, args);\n\tva_end(args);\n\n\tprintk(\"\\n\");\n}\n\nstatic void fas216_log(FAS216_Info *info, int level, char *fmt, ...)\n{\n\tva_list args;\n\n\tif (level != 0 && !(level & level_mask))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tfas216_do_log(info, fas216_target(info), fmt, args);\n\tva_end(args);\n\n\tprintk(\"\\n\");\n}\n\n#define PH_SIZE\t32\n\nstatic struct { int stat, ssr, isr, ph; } ph_list[PH_SIZE];\nstatic int ph_ptr;\n\nstatic void add_debug_list(int stat, int ssr, int isr, int ph)\n{\n\tph_list[ph_ptr].stat = stat;\n\tph_list[ph_ptr].ssr = ssr;\n\tph_list[ph_ptr].isr = isr;\n\tph_list[ph_ptr].ph = ph;\n\n\tph_ptr = (ph_ptr + 1) & (PH_SIZE-1);\n}\n\nstatic struct { int command; void *from; } cmd_list[8];\nstatic int cmd_ptr;\n\nstatic void fas216_cmd(FAS216_Info *info, unsigned int command)\n{\n\tcmd_list[cmd_ptr].command = command;\n\tcmd_list[cmd_ptr].from = __builtin_return_address(0);\n\n\tcmd_ptr = (cmd_ptr + 1) & 7;\n\n\tfas216_writeb(info, REG_CMD, command);\n}\n\nstatic void print_debug_list(void)\n{\n\tint i;\n\n\ti = ph_ptr;\n\n\tprintk(KERN_ERR \"SCSI IRQ trail\\n\");\n\tdo {\n\t\tprintk(\" %02x:%02x:%02x:%1x\",\n\t\t\tph_list[i].stat, ph_list[i].ssr,\n\t\t\tph_list[i].isr, ph_list[i].ph);\n\t\ti = (i + 1) & (PH_SIZE - 1);\n\t\tif (((i ^ ph_ptr) & 7) == 0)\n\t\t\tprintk(\"\\n\");\n\t} while (i != ph_ptr);\n\tif ((i ^ ph_ptr) & 7)\n\t\tprintk(\"\\n\");\n\n\ti = cmd_ptr;\n\tprintk(KERN_ERR \"FAS216 commands: \");\n\tdo {\n\t\tprintk(\"%02x:%p \", cmd_list[i].command, cmd_list[i].from);\n\t\ti = (i + 1) & 7;\n\t} while (i != cmd_ptr);\n\tprintk(\"\\n\");\n}\n\nstatic void fas216_done(FAS216_Info *info, unsigned int result);\n\n \nstatic inline unsigned short\nfas216_get_last_msg(FAS216_Info *info, int pos)\n{\n\tunsigned short packed_msg = NOP;\n\tstruct message *msg;\n\tint msgnr = 0;\n\n\twhile ((msg = msgqueue_getmsg(&info->scsi.msgs, msgnr++)) != NULL) {\n\t\tif (pos >= msg->fifo)\n\t\t\tbreak;\n\t}\n\n\tif (msg) {\n\t\tif (msg->msg[0] == EXTENDED_MESSAGE)\n\t\t\tpacked_msg = EXTENDED_MESSAGE | msg->msg[2] << 8;\n\t\telse\n\t\t\tpacked_msg = msg->msg[0];\n\t}\n\n\tfas216_log(info, LOG_MESSAGES,\n\t\t\"Message: %04x found at position %02x\\n\", packed_msg, pos);\n\n\treturn packed_msg;\n}\n\n \nstatic int fas216_syncperiod(FAS216_Info *info, int ns)\n{\n\tint value = (info->ifcfg.clockrate * ns) / 1000;\n\n\tfas216_checkmagic(info);\n\n\tif (value < 4)\n\t\tvalue = 4;\n\telse if (value > 35)\n\t\tvalue = 35;\n\n\treturn value & 31;\n}\n\n \nstatic void fas216_set_sync(FAS216_Info *info, int target)\n{\n\tunsigned int cntl3;\n\n\tfas216_writeb(info, REG_SOF, info->device[target].sof);\n\tfas216_writeb(info, REG_STP, info->device[target].stp);\n\n\tcntl3 = info->scsi.cfg[2];\n\tif (info->device[target].period >= (200 / 4))\n\t\tcntl3 = cntl3 & ~CNTL3_FASTSCSI;\n\n\tfas216_writeb(info, REG_CNTL3, cntl3);\n}\n\n \n\n \nstatic void fas216_handlesync(FAS216_Info *info, char *msg)\n{\n\tstruct fas216_device *dev = &info->device[info->SCpnt->device->id];\n\tenum { sync, async, none, reject } res = none;\n\n#ifdef SCSI2_SYNC\n\tswitch (msg[0]) {\n\tcase MESSAGE_REJECT:\n\t\t \n\t\tif (dev->sync_state == neg_inprogress) {\n\t\t\tdev->sync_state = neg_invalid;\n\t\t\tres = async;\n\t\t}\n\t\tbreak;\n\n\tcase EXTENDED_MESSAGE:\n\t\tswitch (dev->sync_state) {\n\t\t \n\t\tcase neg_invalid:\n\t\t\tres = reject;\n\t\t\tbreak;\n\n\t\t \n\t\tdefault:\n\t\t\tfas216_cmd(info, CMD_SETATN);\n\t\t\tif (msg[4] > info->ifcfg.sync_max_depth)\n\t\t\t\tmsg[4] = info->ifcfg.sync_max_depth;\n\t\t\tif (msg[3] < 1000 / info->ifcfg.clockrate)\n\t\t\t\tmsg[3] = 1000 / info->ifcfg.clockrate;\n\n\t\t\tmsgqueue_flush(&info->scsi.msgs);\n\t\t\tmsgqueue_addmsg(&info->scsi.msgs, 5,\n\t\t\t\t\tEXTENDED_MESSAGE, 3, EXTENDED_SDTR,\n\t\t\t\t\tmsg[3], msg[4]);\n\t\t\tinfo->scsi.phase = PHASE_MSGOUT_EXPECT;\n\n\t\t\t \n\t\t\tdev->sync_state = neg_targcomplete;\n\t\t\tres = sync;\n\t\t\tbreak;\n\n\t\t \n\t\tcase neg_inprogress:\n\t\t\tres = reject;\n\t\t\tif (msg[4] <= info->ifcfg.sync_max_depth &&\n\t\t\t    msg[3] >= 1000 / info->ifcfg.clockrate) {\n\t\t\t\tdev->sync_state = neg_complete;\n\t\t\t\tres = sync;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n#else\n\tres = reject;\n#endif\n\n\tswitch (res) {\n\tcase sync:\n\t\tdev->period = msg[3];\n\t\tdev->sof    = msg[4];\n\t\tdev->stp    = fas216_syncperiod(info, msg[3] * 4);\n\t\tfas216_set_sync(info, info->SCpnt->device->id);\n\t\tbreak;\n\n\tcase reject:\n\t\tfas216_cmd(info, CMD_SETATN);\n\t\tmsgqueue_flush(&info->scsi.msgs);\n\t\tmsgqueue_addmsg(&info->scsi.msgs, 1, MESSAGE_REJECT);\n\t\tinfo->scsi.phase = PHASE_MSGOUT_EXPECT;\n\t\tfallthrough;\n\n\tcase async:\n\t\tdev->period = info->ifcfg.asyncperiod / 4;\n\t\tdev->sof    = 0;\n\t\tdev->stp    = info->scsi.async_stp;\n\t\tfas216_set_sync(info, info->SCpnt->device->id);\n\t\tbreak;\n\n\tcase none:\n\t\tbreak;\n\t}\n}\n\n \nstatic void fas216_updateptrs(FAS216_Info *info, int bytes_transferred)\n{\n\tstruct scsi_pointer *SCp = &info->scsi.SCp;\n\n\tfas216_checkmagic(info);\n\n\tBUG_ON(bytes_transferred < 0);\n\n\tSCp->phase -= bytes_transferred;\n\n\twhile (bytes_transferred != 0) {\n\t\tif (SCp->this_residual > bytes_transferred)\n\t\t\tbreak;\n\t\t \n\t\tbytes_transferred -= SCp->this_residual;\n\t\tif (!next_SCp(SCp) && bytes_transferred) {\n\t\t\tprintk(KERN_WARNING \"scsi%d.%c: out of buffers\\n\",\n\t\t\t\tinfo->host->host_no, '0' + info->SCpnt->device->id);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tSCp->this_residual -= bytes_transferred;\n\tif (SCp->this_residual)\n\t\tSCp->ptr += bytes_transferred;\n\telse\n\t\tSCp->ptr = NULL;\n}\n\n \nstatic void fas216_pio(FAS216_Info *info, fasdmadir_t direction)\n{\n\tstruct scsi_pointer *SCp = &info->scsi.SCp;\n\n\tfas216_checkmagic(info);\n\n\tif (direction == DMA_OUT)\n\t\tfas216_writeb(info, REG_FF, get_next_SCp_byte(SCp));\n\telse\n\t\tput_next_SCp_byte(SCp, fas216_readb(info, REG_FF));\n\n\tif (SCp->this_residual == 0)\n\t\tnext_SCp(SCp);\n}\n\nstatic void fas216_set_stc(FAS216_Info *info, unsigned int length)\n{\n\tfas216_writeb(info, REG_STCL, length);\n\tfas216_writeb(info, REG_STCM, length >> 8);\n\tfas216_writeb(info, REG_STCH, length >> 16);\n}\n\nstatic unsigned int fas216_get_ctc(FAS216_Info *info)\n{\n\treturn fas216_readb(info, REG_CTCL) +\n\t       (fas216_readb(info, REG_CTCM) << 8) +\n\t       (fas216_readb(info, REG_CTCH) << 16);\n}\n\n \nstatic void fas216_cleanuptransfer(FAS216_Info *info)\n{\n\tunsigned long total, residual, fifo;\n\tfasdmatype_t dmatype = info->dma.transfer_type;\n\n\tinfo->dma.transfer_type = fasdma_none;\n\n\t \n\tif (dmatype == fasdma_pio || dmatype == fasdma_none)\n\t\treturn;\n\n\tif (dmatype == fasdma_real_all)\n\t\ttotal = info->scsi.SCp.phase;\n\telse\n\t\ttotal = info->scsi.SCp.this_residual;\n\n\tresidual = fas216_get_ctc(info);\n\n\tfifo = fas216_readb(info, REG_CFIS) & CFIS_CF;\n\n\tfas216_log(info, LOG_BUFFER, \"cleaning up from previous \"\n\t\t   \"transfer: length 0x%06x, residual 0x%x, fifo %d\",\n\t\t   total, residual, fifo);\n\n\t \n\tif (info->scsi.phase == PHASE_DATAOUT)\n\t\tresidual += fifo;\n\n\tfas216_updateptrs(info, total - residual);\n}\n\n \nstatic void fas216_transfer(FAS216_Info *info)\n{\n\tfasdmadir_t direction;\n\tfasdmatype_t dmatype;\n\n\tfas216_log(info, LOG_BUFFER,\n\t\t   \"starttransfer: buffer %p length 0x%06x reqlen 0x%06x\",\n\t\t   info->scsi.SCp.ptr, info->scsi.SCp.this_residual,\n\t\t   info->scsi.SCp.phase);\n\n\tif (!info->scsi.SCp.ptr) {\n\t\tfas216_log(info, LOG_ERROR, \"null buffer passed to \"\n\t\t\t   \"fas216_starttransfer\");\n\t\tprint_SCp(&info->scsi.SCp, \"SCp: \", \"\\n\");\n\t\tprint_SCp(arm_scsi_pointer(info->SCpnt), \"Cmnd SCp: \", \"\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (info->device[info->SCpnt->device->id].sof)\n\t\tdmatype = fasdma_real_all;\n\telse\n\t\tdmatype = fasdma_pio;\n\n\tif (info->scsi.phase == PHASE_DATAOUT)\n\t\tdirection = DMA_OUT;\n\telse\n\t\tdirection = DMA_IN;\n\n\tif (info->dma.setup)\n\t\tdmatype = info->dma.setup(info->host, &info->scsi.SCp,\n\t\t\t\t\t  direction, dmatype);\n\tinfo->dma.transfer_type = dmatype;\n\n\tif (dmatype == fasdma_real_all)\n\t\tfas216_set_stc(info, info->scsi.SCp.phase);\n\telse\n\t\tfas216_set_stc(info, info->scsi.SCp.this_residual);\n\n\tswitch (dmatype) {\n\tcase fasdma_pio:\n\t\tfas216_log(info, LOG_BUFFER, \"PIO transfer\");\n\t\tfas216_writeb(info, REG_SOF, 0);\n\t\tfas216_writeb(info, REG_STP, info->scsi.async_stp);\n\t\tfas216_cmd(info, CMD_TRANSFERINFO);\n\t\tfas216_pio(info, direction);\n\t\tbreak;\n\n\tcase fasdma_pseudo:\n\t\tfas216_log(info, LOG_BUFFER, \"pseudo transfer\");\n\t\tfas216_cmd(info, CMD_TRANSFERINFO | CMD_WITHDMA);\n\t\tinfo->dma.pseudo(info->host, &info->scsi.SCp,\n\t\t\t\t direction, info->SCpnt->transfersize);\n\t\tbreak;\n\n\tcase fasdma_real_block:\n\t\tfas216_log(info, LOG_BUFFER, \"block dma transfer\");\n\t\tfas216_cmd(info, CMD_TRANSFERINFO | CMD_WITHDMA);\n\t\tbreak;\n\n\tcase fasdma_real_all:\n\t\tfas216_log(info, LOG_BUFFER, \"total dma transfer\");\n\t\tfas216_cmd(info, CMD_TRANSFERINFO | CMD_WITHDMA);\n\t\tbreak;\n\n\tdefault:\n\t\tfas216_log(info, LOG_BUFFER | LOG_ERROR,\n\t\t\t   \"invalid FAS216 DMA type\");\n\t\tbreak;\n\t}\n}\n\n \nstatic void fas216_stoptransfer(FAS216_Info *info)\n{\n\tfas216_checkmagic(info);\n\n\tif (info->dma.transfer_type == fasdma_real_all ||\n\t    info->dma.transfer_type == fasdma_real_block)\n\t\tinfo->dma.stop(info->host, &info->scsi.SCp);\n\n\tfas216_cleanuptransfer(info);\n\n\tif (info->scsi.phase == PHASE_DATAIN) {\n\t\tunsigned int fifo;\n\n\t\t \n\t\tfifo = fas216_readb(info, REG_CFIS) & CFIS_CF;\n\t\twhile (fifo && info->scsi.SCp.ptr) {\n\t\t\t*info->scsi.SCp.ptr = fas216_readb(info, REG_FF);\n\t\t\tfas216_updateptrs(info, 1);\n\t\t\tfifo--;\n\t\t}\n\t} else {\n\t\t \n\t\tfas216_cmd(info, CMD_FLUSHFIFO);\n\t}\n}\n\nstatic void fas216_aborttransfer(FAS216_Info *info)\n{\n\tfas216_checkmagic(info);\n\n\tif (info->dma.transfer_type == fasdma_real_all ||\n\t    info->dma.transfer_type == fasdma_real_block)\n\t\tinfo->dma.stop(info->host, &info->scsi.SCp);\n\n\tinfo->dma.transfer_type = fasdma_none;\n\tfas216_cmd(info, CMD_FLUSHFIFO);\n}\n\nstatic void fas216_kick(FAS216_Info *info);\n\n \nstatic void fas216_disconnect_intr(FAS216_Info *info)\n{\n\tunsigned long flags;\n\n\tfas216_checkmagic(info);\n\n\tfas216_log(info, LOG_CONNECT, \"disconnect phase=%02x\",\n\t\t   info->scsi.phase);\n\n\tmsgqueue_flush(&info->scsi.msgs);\n\n\tswitch (info->scsi.phase) {\n\tcase PHASE_SELECTION:\t\t\t \n\tcase PHASE_SELSTEPS:\n\t\tfas216_done(info, DID_NO_CONNECT);\n\t\tbreak;\n\n\tcase PHASE_MSGIN_DISCONNECT:\t\t \n\t\tinfo->scsi.disconnectable = 1;\n\t\tinfo->scsi.phase = PHASE_IDLE;\n\t\tinfo->stats.disconnects += 1;\n\t\tspin_lock_irqsave(&info->host_lock, flags);\n\t\tif (info->scsi.phase == PHASE_IDLE)\n\t\t\tfas216_kick(info);\n\t\tspin_unlock_irqrestore(&info->host_lock, flags);\n\t\tbreak;\n\n\tcase PHASE_DONE:\t\t\t \n\t\tfas216_done(info, DID_OK);\n\t\tbreak;\n\n\tcase PHASE_MSGOUT:\t\t\t \n\t\tif (fas216_get_last_msg(info, info->scsi.msgin_fifo) == ABORT) {\n\t\t\tinfo->scsi.aborting = 0;\n\t\t\tfas216_done(info, DID_ABORT);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tdefault:\t\t\t\t \n\t\tprintk(KERN_ERR \"scsi%d.%c: unexpected disconnect in phase %s\\n\",\n\t\t\tinfo->host->host_no, fas216_target(info), fas216_drv_phase(info));\n\t\tprint_debug_list();\n\t\tfas216_stoptransfer(info);\n\t\tfas216_done(info, DID_ERROR);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nfas216_reselected_intr(FAS216_Info *info)\n{\n\tunsigned int cfis, i;\n\tunsigned char msg[4];\n\tunsigned char target, lun, tag;\n\n\tfas216_checkmagic(info);\n\n\tWARN_ON(info->scsi.phase == PHASE_SELECTION ||\n\t\tinfo->scsi.phase == PHASE_SELSTEPS);\n\n\tcfis = fas216_readb(info, REG_CFIS);\n\n\tfas216_log(info, LOG_CONNECT, \"reconnect phase=%02x cfis=%02x\",\n\t\t   info->scsi.phase, cfis);\n\n\tcfis &= CFIS_CF;\n\n\tif (cfis < 2 || cfis > 4) {\n\t\tprintk(KERN_ERR \"scsi%d.H: incorrect number of bytes after reselect\\n\",\n\t\t\tinfo->host->host_no);\n\t\tgoto bad_message;\n\t}\n\n\tfor (i = 0; i < cfis; i++)\n\t\tmsg[i] = fas216_readb(info, REG_FF);\n\n\tif (!(msg[0] & (1 << info->host->this_id)) ||\n\t    !(msg[1] & 0x80))\n\t\tgoto initiator_error;\n\n\ttarget = msg[0] & ~(1 << info->host->this_id);\n\ttarget = ffs(target) - 1;\n\tlun = msg[1] & 7;\n\ttag = 0;\n\n\tif (cfis >= 3) {\n\t\tif (msg[2] != SIMPLE_QUEUE_TAG)\n\t\t\tgoto initiator_error;\n\n\t\ttag = msg[3];\n\t}\n\n\t \n\tfas216_writeb(info, REG_SDID, target);\n\tfas216_set_sync(info, target);\n\tmsgqueue_flush(&info->scsi.msgs);\n\n\tfas216_log(info, LOG_CONNECT, \"Reconnected: target %1x lun %1x tag %02x\",\n\t\t   target, lun, tag);\n\n\tif (info->scsi.disconnectable && info->SCpnt) {\n\t\tinfo->scsi.disconnectable = 0;\n\t\tif (info->SCpnt->device->id  == target &&\n\t\t    info->SCpnt->device->lun == lun &&\n\t\t    scsi_cmd_to_rq(info->SCpnt)->tag == tag) {\n\t\t\tfas216_log(info, LOG_CONNECT, \"reconnected previously executing command\");\n\t\t} else {\n\t\t\tqueue_add_cmd_tail(&info->queues.disconnected, info->SCpnt);\n\t\t\tfas216_log(info, LOG_CONNECT, \"had to move command to disconnected queue\");\n\t\t\tinfo->SCpnt = NULL;\n\t\t}\n\t}\n\tif (!info->SCpnt) {\n\t\tinfo->SCpnt = queue_remove_tgtluntag(&info->queues.disconnected,\n\t\t\t\t\ttarget, lun, tag);\n\t\tfas216_log(info, LOG_CONNECT, \"had to get command\");\n\t}\n\n\tif (info->SCpnt) {\n\t\t \n\t\tinfo->scsi.SCp = *arm_scsi_pointer(info->SCpnt);\n\n\t\tfas216_log(info, LOG_CONNECT, \"data pointers: [%p, %X]\",\n\t\t\tinfo->scsi.SCp.ptr, info->scsi.SCp.this_residual);\n\t\tinfo->scsi.phase = PHASE_MSGIN;\n\t} else {\n\t\t \n\t\tfas216_cmd(info, CMD_SETATN);\n\n#if 0\n\t\tif (tag)\n\t\t\tmsgqueue_addmsg(&info->scsi.msgs, 2, ABORT_TAG, tag);\n\t\telse\n#endif\n\t\t\tmsgqueue_addmsg(&info->scsi.msgs, 1, ABORT);\n\t\tinfo->scsi.phase = PHASE_MSGOUT_EXPECT;\n\t\tinfo->scsi.aborting = 1;\n\t}\n\n\tfas216_cmd(info, CMD_MSGACCEPTED);\n\treturn;\n\n initiator_error:\n\tprintk(KERN_ERR \"scsi%d.H: error during reselection: bytes\",\n\t\tinfo->host->host_no);\n\tfor (i = 0; i < cfis; i++)\n\t\tprintk(\" %02x\", msg[i]);\n\tprintk(\"\\n\");\n bad_message:\n\tfas216_cmd(info, CMD_SETATN);\n\tmsgqueue_flush(&info->scsi.msgs);\n\tmsgqueue_addmsg(&info->scsi.msgs, 1, INITIATOR_ERROR);\n\tinfo->scsi.phase = PHASE_MSGOUT_EXPECT;\n\tfas216_cmd(info, CMD_MSGACCEPTED);\n}\n\nstatic void fas216_parse_message(FAS216_Info *info, unsigned char *message, int msglen)\n{\n\tstruct scsi_pointer *scsi_pointer;\n\tint i;\n\n\tswitch (message[0]) {\n\tcase COMMAND_COMPLETE:\n\t\tif (msglen != 1)\n\t\t\tgoto unrecognised;\n\n\t\tprintk(KERN_ERR \"scsi%d.%c: command complete with no \"\n\t\t\t\"status in MESSAGE_IN?\\n\",\n\t\t\tinfo->host->host_no, fas216_target(info));\n\t\tbreak;\n\n\tcase SAVE_POINTERS:\n\t\tif (msglen != 1)\n\t\t\tgoto unrecognised;\n\n\t\t \n\t\tscsi_pointer = arm_scsi_pointer(info->SCpnt);\n\t\t*scsi_pointer = info->scsi.SCp;\n\t\tscsi_pointer->sent_command = 0;\n\t\tfas216_log(info, LOG_CONNECT | LOG_MESSAGES | LOG_BUFFER,\n\t\t\t\"save data pointers: [%p, %X]\",\n\t\t\tinfo->scsi.SCp.ptr, info->scsi.SCp.this_residual);\n\t\tbreak;\n\n\tcase RESTORE_POINTERS:\n\t\tif (msglen != 1)\n\t\t\tgoto unrecognised;\n\n\t\t \n\t\tinfo->scsi.SCp = *arm_scsi_pointer(info->SCpnt);\n\t\tfas216_log(info, LOG_CONNECT | LOG_MESSAGES | LOG_BUFFER,\n\t\t\t\"restore data pointers: [%p, 0x%x]\",\n\t\t\tinfo->scsi.SCp.ptr, info->scsi.SCp.this_residual);\n\t\tbreak;\n\n\tcase DISCONNECT:\n\t\tif (msglen != 1)\n\t\t\tgoto unrecognised;\n\n\t\tinfo->scsi.phase = PHASE_MSGIN_DISCONNECT;\n\t\tbreak;\n\n\tcase MESSAGE_REJECT:\n\t\tif (msglen != 1)\n\t\t\tgoto unrecognised;\n\n\t\tswitch (fas216_get_last_msg(info, info->scsi.msgin_fifo)) {\n\t\tcase EXTENDED_MESSAGE | EXTENDED_SDTR << 8:\n\t\t\tfas216_handlesync(info, message);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfas216_log(info, 0, \"reject, last message 0x%04x\",\n\t\t\t\tfas216_get_last_msg(info, info->scsi.msgin_fifo));\n\t\t}\n\t\tbreak;\n\n\tcase NOP:\n\t\tbreak;\n\n\tcase EXTENDED_MESSAGE:\n\t\tif (msglen < 3)\n\t\t\tgoto unrecognised;\n\n\t\tswitch (message[2]) {\n\t\tcase EXTENDED_SDTR:\t \n\t\t\tfas216_handlesync(info, message);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto unrecognised;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tgoto unrecognised;\n\t}\n\treturn;\n\nunrecognised:\n\tfas216_log(info, 0, \"unrecognised message, rejecting\");\n\tprintk(\"scsi%d.%c: message was\", info->host->host_no, fas216_target(info));\n\tfor (i = 0; i < msglen; i++)\n\t\tprintk(\"%s%02X\", i & 31 ? \" \" : \"\\n  \", message[i]);\n\tprintk(\"\\n\");\n\n\t \nfas216_cmd(info, CMD_NOP);\nfas216_dumpstate(info);\n\tfas216_cmd(info, CMD_SETATN);\n\tmsgqueue_flush(&info->scsi.msgs);\n\tmsgqueue_addmsg(&info->scsi.msgs, 1, MESSAGE_REJECT);\n\tinfo->scsi.phase = PHASE_MSGOUT_EXPECT;\nfas216_dumpstate(info);\n}\n\nstatic int fas216_wait_cmd(FAS216_Info *info, int cmd)\n{\n\tint tout;\n\tint stat;\n\n\tfas216_cmd(info, cmd);\n\n\tfor (tout = 1000; tout; tout -= 1) {\n\t\tstat = fas216_readb(info, REG_STAT);\n\t\tif (stat & (STAT_INT|STAT_PARITYERROR))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\treturn stat;\n}\n\nstatic int fas216_get_msg_byte(FAS216_Info *info)\n{\n\tunsigned int stat = fas216_wait_cmd(info, CMD_MSGACCEPTED);\n\n\tif ((stat & STAT_INT) == 0)\n\t\tgoto timedout;\n\n\tif ((stat & STAT_BUSMASK) != STAT_MESGIN)\n\t\tgoto unexpected_phase_change;\n\n\tfas216_readb(info, REG_INST);\n\n\tstat = fas216_wait_cmd(info, CMD_TRANSFERINFO);\n\n\tif ((stat & STAT_INT) == 0)\n\t\tgoto timedout;\n\n\tif (stat & STAT_PARITYERROR)\n\t\tgoto parity_error;\n\n\tif ((stat & STAT_BUSMASK) != STAT_MESGIN)\n\t\tgoto unexpected_phase_change;\n\n\tfas216_readb(info, REG_INST);\n\n\treturn fas216_readb(info, REG_FF);\n\ntimedout:\n\tfas216_log(info, LOG_ERROR, \"timed out waiting for message byte\");\n\treturn -1;\n\nunexpected_phase_change:\n\tfas216_log(info, LOG_ERROR, \"unexpected phase change: status = %02x\", stat);\n\treturn -2;\n\nparity_error:\n\tfas216_log(info, LOG_ERROR, \"parity error during message in phase\");\n\treturn -3;\n}\n\n \nstatic void fas216_message(FAS216_Info *info)\n{\n\tunsigned char *message = info->scsi.message;\n\tunsigned int msglen = 1;\n\tint msgbyte = 0;\n\n\tfas216_checkmagic(info);\n\n\tmessage[0] = fas216_readb(info, REG_FF);\n\n\tif (message[0] == EXTENDED_MESSAGE) {\n\t\tmsgbyte = fas216_get_msg_byte(info);\n\n\t\tif (msgbyte >= 0) {\n\t\t\tmessage[1] = msgbyte;\n\n\t\t\tfor (msglen = 2; msglen < message[1] + 2; msglen++) {\n\t\t\t\tmsgbyte = fas216_get_msg_byte(info);\n\n\t\t\t\tif (msgbyte >= 0)\n\t\t\t\t\tmessage[msglen] = msgbyte;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (msgbyte == -3)\n\t\tgoto parity_error;\n\n#ifdef DEBUG_MESSAGES\n\t{\n\t\tint i;\n\n\t\tprintk(\"scsi%d.%c: message in: \",\n\t\t\tinfo->host->host_no, fas216_target(info));\n\t\tfor (i = 0; i < msglen; i++)\n\t\t\tprintk(\"%02X \", message[i]);\n\t\tprintk(\"\\n\");\n\t}\n#endif\n\n\tfas216_parse_message(info, message, msglen);\n\tfas216_cmd(info, CMD_MSGACCEPTED);\n\treturn;\n\nparity_error:\n\tfas216_cmd(info, CMD_SETATN);\n\tmsgqueue_flush(&info->scsi.msgs);\n\tmsgqueue_addmsg(&info->scsi.msgs, 1, MSG_PARITY_ERROR);\n\tinfo->scsi.phase = PHASE_MSGOUT_EXPECT;\n\tfas216_cmd(info, CMD_MSGACCEPTED);\n\treturn;\n}\n\n \nstatic void fas216_send_command(FAS216_Info *info)\n{\n\tint i;\n\n\tfas216_checkmagic(info);\n\n\tfas216_cmd(info, CMD_NOP|CMD_WITHDMA);\n\tfas216_cmd(info, CMD_FLUSHFIFO);\n\n\t \n\tfor (i = info->scsi.SCp.sent_command; i < info->SCpnt->cmd_len; i++)\n\t\tfas216_writeb(info, REG_FF, info->SCpnt->cmnd[i]);\n\n\tfas216_cmd(info, CMD_TRANSFERINFO);\n\n\tinfo->scsi.phase = PHASE_COMMAND;\n}\n\n \nstatic void fas216_send_messageout(FAS216_Info *info, int start)\n{\n\tunsigned int tot_msglen = msgqueue_msglength(&info->scsi.msgs);\n\n\tfas216_checkmagic(info);\n\n\tfas216_cmd(info, CMD_FLUSHFIFO);\n\n\tif (tot_msglen) {\n\t\tstruct message *msg;\n\t\tint msgnr = 0;\n\n\t\twhile ((msg = msgqueue_getmsg(&info->scsi.msgs, msgnr++)) != NULL) {\n\t\t\tint i;\n\n\t\t\tfor (i = start; i < msg->length; i++)\n\t\t\t\tfas216_writeb(info, REG_FF, msg->msg[i]);\n\n\t\t\tmsg->fifo = tot_msglen - (fas216_readb(info, REG_CFIS) & CFIS_CF);\n\t\t\tstart = 0;\n\t\t}\n\t} else\n\t\tfas216_writeb(info, REG_FF, NOP);\n\n\tfas216_cmd(info, CMD_TRANSFERINFO);\n\n\tinfo->scsi.phase = PHASE_MSGOUT;\n}\n\n \nstatic void fas216_busservice_intr(FAS216_Info *info, unsigned int stat, unsigned int is)\n{\n\tfas216_checkmagic(info);\n\n\tfas216_log(info, LOG_BUSSERVICE,\n\t\t   \"bus service: stat=%02x is=%02x phase=%02x\",\n\t\t   stat, is, info->scsi.phase);\n\n\tswitch (info->scsi.phase) {\n\tcase PHASE_SELECTION:\n\t\tif ((is & IS_BITS) != IS_MSGBYTESENT)\n\t\t\tgoto bad_is;\n\t\tbreak;\n\n\tcase PHASE_SELSTEPS:\n\t\tswitch (is & IS_BITS) {\n\t\tcase IS_SELARB:\n\t\tcase IS_MSGBYTESENT:\n\t\t\tgoto bad_is;\n\n\t\tcase IS_NOTCOMMAND:\n\t\tcase IS_EARLYPHASE:\n\t\t\tif ((stat & STAT_BUSMASK) == STAT_MESGIN)\n\t\t\t\tbreak;\n\t\t\tgoto bad_is;\n\n\t\tcase IS_COMPLETE:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfas216_cmd(info, CMD_NOP);\n\n#define STATE(st,ph) ((ph) << 3 | (st))\n\t \n\tswitch (STATE(stat & STAT_BUSMASK, info->scsi.phase)) {\n\tcase STATE(STAT_DATAIN, PHASE_SELSTEPS): \n\tcase STATE(STAT_DATAIN, PHASE_MSGOUT):   \n\tcase STATE(STAT_DATAIN, PHASE_COMMAND):  \n\tcase STATE(STAT_DATAIN, PHASE_MSGIN):    \n\t\tinfo->scsi.phase = PHASE_DATAIN;\n\t\tfas216_transfer(info);\n\t\treturn;\n\n\tcase STATE(STAT_DATAIN, PHASE_DATAIN):   \n\tcase STATE(STAT_DATAOUT, PHASE_DATAOUT): \n\t\tfas216_cleanuptransfer(info);\n\t\tfas216_transfer(info);\n\t\treturn;\n\n\tcase STATE(STAT_DATAOUT, PHASE_SELSTEPS): \n\tcase STATE(STAT_DATAOUT, PHASE_MSGOUT):  \n\tcase STATE(STAT_DATAOUT, PHASE_COMMAND): \n\tcase STATE(STAT_DATAOUT, PHASE_MSGIN):   \n\t\tfas216_cmd(info, CMD_FLUSHFIFO);\n\t\tinfo->scsi.phase = PHASE_DATAOUT;\n\t\tfas216_transfer(info);\n\t\treturn;\n\n\tcase STATE(STAT_STATUS, PHASE_DATAOUT):  \n\tcase STATE(STAT_STATUS, PHASE_DATAIN):   \n\t\tfas216_stoptransfer(info);\n\t\tfallthrough;\n\n\tcase STATE(STAT_STATUS, PHASE_SELSTEPS): \n\tcase STATE(STAT_STATUS, PHASE_MSGOUT):   \n\tcase STATE(STAT_STATUS, PHASE_COMMAND):  \n\tcase STATE(STAT_STATUS, PHASE_MSGIN):    \n\t\tfas216_cmd(info, CMD_INITCMDCOMPLETE);\n\t\tinfo->scsi.phase = PHASE_STATUS;\n\t\treturn;\n\n\tcase STATE(STAT_MESGIN, PHASE_DATAOUT):  \n\tcase STATE(STAT_MESGIN, PHASE_DATAIN):   \n\t\tfas216_stoptransfer(info);\n\t\tfallthrough;\n\n\tcase STATE(STAT_MESGIN, PHASE_COMMAND):\t \n\tcase STATE(STAT_MESGIN, PHASE_SELSTEPS): \n\tcase STATE(STAT_MESGIN, PHASE_MSGOUT):   \n\t\tinfo->scsi.msgin_fifo = fas216_readb(info, REG_CFIS) & CFIS_CF;\n\t\tfas216_cmd(info, CMD_FLUSHFIFO);\n\t\tfas216_cmd(info, CMD_TRANSFERINFO);\n\t\tinfo->scsi.phase = PHASE_MSGIN;\n\t\treturn;\n\n\tcase STATE(STAT_MESGIN, PHASE_MSGIN):\n\t\tinfo->scsi.msgin_fifo = fas216_readb(info, REG_CFIS) & CFIS_CF;\n\t\tfas216_cmd(info, CMD_TRANSFERINFO);\n\t\treturn;\n\n\tcase STATE(STAT_COMMAND, PHASE_MSGOUT):  \n\tcase STATE(STAT_COMMAND, PHASE_MSGIN):   \n\t\tfas216_send_command(info);\n\t\tinfo->scsi.phase = PHASE_COMMAND;\n\t\treturn;\n\n\n\t \n\tcase STATE(STAT_MESGOUT, PHASE_SELECTION):\n\t\tfas216_send_messageout(info, 1);\n\t\treturn;\n\n\t \n\tcase STATE(STAT_MESGOUT, PHASE_SELSTEPS):\n\tcase STATE(STAT_MESGOUT, PHASE_MSGOUT):\n\t\t \n\t\tif (info->device[info->SCpnt->device->id].parity_check) {\n\t\t\t \n\t\t\tinfo->device[info->SCpnt->device->id].parity_check = 0;\n\t\t\tinfo->device[info->SCpnt->device->id].parity_enabled = 1;\n\t\t\tfas216_writeb(info, REG_CNTL1, info->scsi.cfg[0]);\n\t\t}\n\n\t\tif (msgqueue_msglength(&info->scsi.msgs) > 1)\n\t\t\tfas216_cmd(info, CMD_SETATN);\n\t\tfallthrough;\n\n\t \n\tcase STATE(STAT_MESGOUT, PHASE_MSGOUT_EXPECT):\n\t\tfas216_send_messageout(info, 0);\n\t\treturn;\n\n\t \n\tcase STATE(STAT_COMMAND, PHASE_COMMAND): \n\t\t \n\t\tprintk(KERN_ERR \"scsi%d.%c: \"\n\t\t\t\"target trying to receive more command bytes\\n\",\n\t\t\tinfo->host->host_no, fas216_target(info));\n\t\tfas216_cmd(info, CMD_SETATN);\n\t\tfas216_set_stc(info, 15);\n\t\tfas216_cmd(info, CMD_PADBYTES | CMD_WITHDMA);\n\t\tmsgqueue_flush(&info->scsi.msgs);\n\t\tmsgqueue_addmsg(&info->scsi.msgs, 1, INITIATOR_ERROR);\n\t\tinfo->scsi.phase = PHASE_MSGOUT_EXPECT;\n\t\treturn;\n\t}\n\n\tif (info->scsi.phase == PHASE_MSGIN_DISCONNECT) {\n\t\tprintk(KERN_ERR \"scsi%d.%c: disconnect message received, but bus service %s?\\n\",\n\t\t\tinfo->host->host_no, fas216_target(info),\n\t\t\tfas216_bus_phase(stat));\n\t\tmsgqueue_flush(&info->scsi.msgs);\n\t\tfas216_cmd(info, CMD_SETATN);\n\t\tmsgqueue_addmsg(&info->scsi.msgs, 1, INITIATOR_ERROR);\n\t\tinfo->scsi.phase = PHASE_MSGOUT_EXPECT;\n\t\tinfo->scsi.aborting = 1;\n\t\tfas216_cmd(info, CMD_TRANSFERINFO);\n\t\treturn;\n\t}\n\tprintk(KERN_ERR \"scsi%d.%c: bus phase %s after %s?\\n\",\n\t\tinfo->host->host_no, fas216_target(info),\n\t\tfas216_bus_phase(stat),\n\t\tfas216_drv_phase(info));\n\tprint_debug_list();\n\treturn;\n\nbad_is:\n\tfas216_log(info, 0, \"bus service at step %d?\", is & IS_BITS);\n\tfas216_dumpstate(info);\n\tprint_debug_list();\n\n\tfas216_done(info, DID_ERROR);\n}\n\n \nstatic void fas216_funcdone_intr(FAS216_Info *info, unsigned int stat, unsigned int is)\n{\n\tunsigned int fifo_len = fas216_readb(info, REG_CFIS) & CFIS_CF;\n\n\tfas216_checkmagic(info);\n\n\tfas216_log(info, LOG_FUNCTIONDONE,\n\t\t   \"function done: stat=%02x is=%02x phase=%02x\",\n\t\t   stat, is, info->scsi.phase);\n\n\tswitch (info->scsi.phase) {\n\tcase PHASE_STATUS:\t\t\t \n\t\tif (fifo_len != 2) {\n\t\t\tfas216_log(info, 0, \"odd number of bytes in FIFO: %d\", fifo_len);\n\t\t}\n\t\t \n\t\tinfo->scsi.SCp.Status = fas216_readb(info, REG_FF);\n\t\tinfo->scsi.SCp.Message = fas216_readb(info, REG_FF);\n\t\tinfo->scsi.phase = PHASE_DONE;\n\t\tfas216_cmd(info, CMD_MSGACCEPTED);\n\t\tbreak;\n\n\tcase PHASE_IDLE:\n\tcase PHASE_SELECTION:\n\tcase PHASE_SELSTEPS:\n\t\tbreak;\n\n\tcase PHASE_MSGIN:\t\t\t \n\t\tif ((stat & STAT_BUSMASK) == STAT_MESGIN) {\n\t\t\tinfo->scsi.msgin_fifo = fifo_len;\n\t\t\tfas216_message(info);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tdefault:\n\t\tfas216_log(info, 0, \"internal phase %s for function done?\"\n\t\t\t\"  What do I do with this?\",\n\t\t\tfas216_target(info), fas216_drv_phase(info));\n\t}\n}\n\nstatic void fas216_bus_reset(FAS216_Info *info)\n{\n\tneg_t sync_state;\n\tint i;\n\n\tmsgqueue_flush(&info->scsi.msgs);\n\n\tsync_state = neg_invalid;\n\n#ifdef SCSI2_SYNC\n\tif (info->ifcfg.capabilities & (FASCAP_DMA|FASCAP_PSEUDODMA))\n\t\tsync_state = neg_wait;\n#endif\n\n\tinfo->scsi.phase = PHASE_IDLE;\n\tinfo->SCpnt = NULL;  \n\tmemset(&info->scsi.SCp, 0, sizeof(info->scsi.SCp));\n\n\tfor (i = 0; i < 8; i++) {\n\t\tinfo->device[i].disconnect_ok\t= info->ifcfg.disconnect_ok;\n\t\tinfo->device[i].sync_state\t= sync_state;\n\t\tinfo->device[i].period\t\t= info->ifcfg.asyncperiod / 4;\n\t\tinfo->device[i].stp\t\t= info->scsi.async_stp;\n\t\tinfo->device[i].sof\t\t= 0;\n\t\tinfo->device[i].wide_xfer\t= 0;\n\t}\n\n\tinfo->rst_bus_status = 1;\n\twake_up(&info->eh_wait);\n}\n\n \nirqreturn_t fas216_intr(FAS216_Info *info)\n{\n\tunsigned char inst, is, stat;\n\tint handled = IRQ_NONE;\n\n\tfas216_checkmagic(info);\n\n\tstat = fas216_readb(info, REG_STAT);\n\tis = fas216_readb(info, REG_IS);\n\tinst = fas216_readb(info, REG_INST);\n\n\tadd_debug_list(stat, is, inst, info->scsi.phase);\n\n\tif (stat & STAT_INT) {\n\t\tif (inst & INST_BUSRESET) {\n\t\t\tfas216_log(info, 0, \"bus reset detected\");\n\t\t\tfas216_bus_reset(info);\n\t\t\tscsi_report_bus_reset(info->host, 0);\n\t\t} else if (inst & INST_ILLEGALCMD) {\n\t\t\tfas216_log(info, LOG_ERROR, \"illegal command given\\n\");\n\t\t\tfas216_dumpstate(info);\n\t\t\tprint_debug_list();\n\t\t} else if (inst & INST_DISCONNECT)\n\t\t\tfas216_disconnect_intr(info);\n\t\telse if (inst & INST_RESELECTED)\t \n\t\t\tfas216_reselected_intr(info);\n\t\telse if (inst & INST_BUSSERVICE)\t \n\t\t\tfas216_busservice_intr(info, stat, is);\n\t\telse if (inst & INST_FUNCDONE)\t\t \n\t\t\tfas216_funcdone_intr(info, stat, is);\n\t\telse\n\t\t    \tfas216_log(info, 0, \"unknown interrupt received:\"\n\t\t\t\t\" phase %s inst %02X is %02X stat %02X\",\n\t\t\t\tfas216_drv_phase(info), inst, is, stat);\n\t\thandled = IRQ_HANDLED;\n\t}\n\treturn handled;\n}\n\nstatic void __fas216_start_command(FAS216_Info *info, struct scsi_cmnd *SCpnt)\n{\n\tint tot_msglen;\n\n\t \n\tfas216_set_stc(info, 0);\n\tfas216_cmd(info, CMD_NOP | CMD_WITHDMA);\n\n\t \n\tfas216_cmd(info, CMD_FLUSHFIFO);\n\n\t \n\tfas216_writeb(info, REG_SDID, BUSID(SCpnt->device->id));\n\tfas216_writeb(info, REG_STIM, info->ifcfg.select_timeout);\n\n\t \n\tfas216_set_sync(info, SCpnt->device->id);\n\n\ttot_msglen = msgqueue_msglength(&info->scsi.msgs);\n\n#ifdef DEBUG_MESSAGES\n\t{\n\t\tstruct message *msg;\n\t\tint msgnr = 0, i;\n\n\t\tprintk(\"scsi%d.%c: message out: \",\n\t\t\tinfo->host->host_no, '0' + SCpnt->device->id);\n\t\twhile ((msg = msgqueue_getmsg(&info->scsi.msgs, msgnr++)) != NULL) {\n\t\t\tprintk(\"{ \");\n\t\t\tfor (i = 0; i < msg->length; i++)\n\t\t\t\tprintk(\"%02x \", msg->msg[i]);\n\t\t\tprintk(\"} \");\n\t\t}\n\t\tprintk(\"\\n\");\n\t}\n#endif\n\n\tif (tot_msglen == 1 || tot_msglen == 3) {\n\t\t \n\t\tstruct message *msg;\n\t\tint msgnr = 0, i;\n\n\t\tinfo->scsi.phase = PHASE_SELSTEPS;\n\n\t\t \n\t\twhile ((msg = msgqueue_getmsg(&info->scsi.msgs, msgnr++)) != NULL) {\n\t\t\tfor (i = 0; i < msg->length; i++)\n\t\t\t\tfas216_writeb(info, REG_FF, msg->msg[i]);\n\t\t\tmsg->fifo = tot_msglen - (fas216_readb(info, REG_CFIS) & CFIS_CF);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < SCpnt->cmd_len; i++)\n\t\t\tfas216_writeb(info, REG_FF, SCpnt->cmnd[i]);\n\n\t\tif (tot_msglen == 1)\n\t\t\tfas216_cmd(info, CMD_SELECTATN);\n\t\telse\n\t\t\tfas216_cmd(info, CMD_SELECTATN3);\n\t} else {\n\t\t \n\t\tstruct message *msg = msgqueue_getmsg(&info->scsi.msgs, 0);\n\n\t\tfas216_writeb(info, REG_FF, msg->msg[0]);\n\t\tmsg->fifo = 1;\n\n\t\tfas216_cmd(info, CMD_SELECTATNSTOP);\n\t}\n}\n\n \nstatic int parity_test(FAS216_Info *info, int target)\n{\n#if 0\n\tif (target == 3) {\n\t\tinfo->device[target].parity_check = 0;\n\t\treturn 1;\n\t}\n#endif\n\treturn info->device[target].parity_check;\n}\n\nstatic void fas216_start_command(FAS216_Info *info, struct scsi_cmnd *SCpnt)\n{\n\tint disconnect_ok;\n\n\t \n\tinfo->scsi.phase = PHASE_SELECTION;\n\tinfo->scsi.SCp = *arm_scsi_pointer(SCpnt);\n\tinfo->SCpnt = SCpnt;\n\tinfo->dma.transfer_type = fasdma_none;\n\n\tif (parity_test(info, SCpnt->device->id))\n\t\tfas216_writeb(info, REG_CNTL1, info->scsi.cfg[0] | CNTL1_PTE);\n\telse\n\t\tfas216_writeb(info, REG_CNTL1, info->scsi.cfg[0]);\n\n\t \n\tdisconnect_ok = SCpnt->cmnd[0] != REQUEST_SENSE &&\n\t\t\tinfo->device[SCpnt->device->id].disconnect_ok;\n\n\t \n\tmsgqueue_flush(&info->scsi.msgs);\n\tmsgqueue_addmsg(&info->scsi.msgs, 1, IDENTIFY(disconnect_ok, SCpnt->device->lun));\n\n\t \n\tif (SCpnt->device->simple_tags)\n\t\tmsgqueue_addmsg(&info->scsi.msgs, 2, SIMPLE_QUEUE_TAG,\n\t\t\t\tscsi_cmd_to_rq(SCpnt)->tag);\n\n\tdo {\n#ifdef SCSI2_SYNC\n\t\tif ((info->device[SCpnt->device->id].sync_state == neg_wait ||\n\t\t     info->device[SCpnt->device->id].sync_state == neg_complete) &&\n\t\t    (SCpnt->cmnd[0] == REQUEST_SENSE ||\n\t\t     SCpnt->cmnd[0] == INQUIRY)) {\n\t\t\tinfo->device[SCpnt->device->id].sync_state = neg_inprogress;\n\t\t\tmsgqueue_addmsg(&info->scsi.msgs, 5,\n\t\t\t\t\tEXTENDED_MESSAGE, 3, EXTENDED_SDTR,\n\t\t\t\t\t1000 / info->ifcfg.clockrate,\n\t\t\t\t\tinfo->ifcfg.sync_max_depth);\n\t\t\tbreak;\n\t\t}\n#endif\n\t} while (0);\n\n\t__fas216_start_command(info, SCpnt);\n}\n\nstatic void fas216_allocate_tag(FAS216_Info *info, struct scsi_cmnd *SCpnt)\n{\n\tset_bit(SCpnt->device->id * 8 +\n\t\t(u8)(SCpnt->device->lun & 0x7), info->busyluns);\n\n\tinfo->stats.removes += 1;\n\tswitch (SCpnt->cmnd[0]) {\n\tcase WRITE_6:\n\tcase WRITE_10:\n\tcase WRITE_12:\n\t\tinfo->stats.writes += 1;\n\t\tbreak;\n\tcase READ_6:\n\tcase READ_10:\n\tcase READ_12:\n\t\tinfo->stats.reads += 1;\n\t\tbreak;\n\tdefault:\n\t\tinfo->stats.miscs += 1;\n\t\tbreak;\n\t}\n}\n\nstatic void fas216_do_bus_device_reset(FAS216_Info *info,\n\t\t\t\t       struct scsi_cmnd *SCpnt)\n{\n\tstruct message *msg;\n\n\t \n\tinfo->scsi.phase = PHASE_SELECTION;\n\tinfo->scsi.SCp = *arm_scsi_pointer(SCpnt);\n\tinfo->SCpnt = SCpnt;\n\tinfo->dma.transfer_type = fasdma_none;\n\n\tfas216_log(info, LOG_ERROR, \"sending bus device reset\");\n\n\tmsgqueue_flush(&info->scsi.msgs);\n\tmsgqueue_addmsg(&info->scsi.msgs, 1, BUS_DEVICE_RESET);\n\n\t \n\tfas216_set_stc(info, 0);\n\tfas216_cmd(info, CMD_NOP | CMD_WITHDMA);\n\n\t \n\tfas216_cmd(info, CMD_FLUSHFIFO);\n\n\t \n\tfas216_writeb(info, REG_SDID, BUSID(SCpnt->device->id));\n\tfas216_writeb(info, REG_STIM, info->ifcfg.select_timeout);\n\n\t \n\tfas216_set_sync(info, SCpnt->device->id);\n\n\tmsg = msgqueue_getmsg(&info->scsi.msgs, 0);\n\n\tfas216_writeb(info, REG_FF, BUS_DEVICE_RESET);\n\tmsg->fifo = 1;\n\n\tfas216_cmd(info, CMD_SELECTATNSTOP);\n}\n\n \nstatic void fas216_kick(FAS216_Info *info)\n{\n\tstruct scsi_cmnd *SCpnt = NULL;\n#define TYPE_OTHER\t0\n#define TYPE_RESET\t1\n#define TYPE_QUEUE\t2\n\tint where_from = TYPE_OTHER;\n\n\tfas216_checkmagic(info);\n\n\t \n\tdo {\n\t\tif (info->rstSCpnt) {\n\t\t\tSCpnt = info->rstSCpnt;\n\t\t\t \n\t\t\twhere_from = TYPE_RESET;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (info->reqSCpnt) {\n\t\t\tSCpnt = info->reqSCpnt;\n\t\t\tinfo->reqSCpnt = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (info->origSCpnt) {\n\t\t\tSCpnt = info->origSCpnt;\n\t\t\tinfo->origSCpnt = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!SCpnt) {\n\t\t\tSCpnt = queue_remove_exclude(&info->queues.issue,\n\t\t\t\t\t\t     info->busyluns);\n\t\t\twhere_from = TYPE_QUEUE;\n\t\t\tbreak;\n\t\t}\n\t} while (0);\n\n\tif (!SCpnt) {\n\t\t \n\t\tfas216_cmd(info, CMD_ENABLESEL);\n\t\treturn;\n\t}\n\n\t \n\tfas216_cmd(info, CMD_DISABLESEL);\n\n\tif (info->scsi.disconnectable && info->SCpnt) {\n\t\tfas216_log(info, LOG_CONNECT,\n\t\t\t\"moved command for %d to disconnected queue\",\n\t\t\tinfo->SCpnt->device->id);\n\t\tqueue_add_cmd_tail(&info->queues.disconnected, info->SCpnt);\n\t\tinfo->scsi.disconnectable = 0;\n\t\tinfo->SCpnt = NULL;\n\t}\n\n\tfas216_log_command(info, LOG_CONNECT | LOG_MESSAGES, SCpnt,\n\t\t\t   \"starting\");\n\n\tswitch (where_from) {\n\tcase TYPE_QUEUE:\n\t\tfas216_allocate_tag(info, SCpnt);\n\t\tfallthrough;\n\tcase TYPE_OTHER:\n\t\tfas216_start_command(info, SCpnt);\n\t\tbreak;\n\tcase TYPE_RESET:\n\t\tfas216_do_bus_device_reset(info, SCpnt);\n\t\tbreak;\n\t}\n\n\tfas216_log(info, LOG_CONNECT, \"select: data pointers [%p, %X]\",\n\t\tinfo->scsi.SCp.ptr, info->scsi.SCp.this_residual);\n\n\t \n}\n\n \nstatic void fas216_devicereset_done(FAS216_Info *info, struct scsi_cmnd *SCpnt,\n\t\t\t\t    unsigned int result)\n{\n\tfas216_log(info, LOG_ERROR, \"fas216 device reset complete\");\n\n\tinfo->rstSCpnt = NULL;\n\tinfo->rst_dev_status = 1;\n\twake_up(&info->eh_wait);\n}\n\n \nstatic void fas216_rq_sns_done(FAS216_Info *info, struct scsi_cmnd *SCpnt,\n\t\t\t       unsigned int result)\n{\n\tstruct scsi_pointer *scsi_pointer = arm_scsi_pointer(SCpnt);\n\n\tfas216_log_target(info, LOG_CONNECT, SCpnt->device->id,\n\t\t   \"request sense complete, result=0x%04x%02x%02x\",\n\t\t   result, scsi_pointer->Message, scsi_pointer->Status);\n\n\tif (result != DID_OK || scsi_pointer->Status != SAM_STAT_GOOD)\n\t\t \n\t\tmemset(SCpnt->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\n \n \n\t \n\tscsi_eh_restore_cmnd(SCpnt, &info->ses);\n\tfas216_cmd_priv(SCpnt)->scsi_done(SCpnt);\n}\n\n \nstatic void\nfas216_std_done(FAS216_Info *info, struct scsi_cmnd *SCpnt, unsigned int result)\n{\n\tstruct scsi_pointer *scsi_pointer = arm_scsi_pointer(SCpnt);\n\n\tinfo->stats.fins += 1;\n\n\tset_host_byte(SCpnt, result);\n\tif (result == DID_OK)\n\t\tscsi_msg_to_host_byte(SCpnt, info->scsi.SCp.Message);\n\tset_status_byte(SCpnt, info->scsi.SCp.Status);\n\n\tfas216_log_command(info, LOG_CONNECT, SCpnt,\n\t\t\"command complete, result=0x%08x\", SCpnt->result);\n\n\t \n\tif (get_host_byte(SCpnt) != DID_OK)\n\t\tgoto done;\n\n\t \n\tif (get_status_byte(SCpnt) == SAM_STAT_CHECK_CONDITION ||\n\t    get_status_byte(SCpnt) == SAM_STAT_COMMAND_TERMINATED)\n\t\tgoto request_sense;\n\n\t \n\tif (get_status_byte(SCpnt) != SAM_STAT_GOOD)\n\t\tgoto done;\n\n\t \n\tif (info->scsi.SCp.ptr) {\n\t\tswitch (SCpnt->cmnd[0]) {\n\t\tcase INQUIRY:\n\t\tcase START_STOP:\n\t\tcase MODE_SENSE:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tscmd_printk(KERN_ERR, SCpnt,\n\t\t\t\t    \"incomplete data transfer detected: res=%08X ptr=%p len=%X\\n\",\n\t\t\t\t    SCpnt->result, info->scsi.SCp.ptr,\n\t\t\t\t    info->scsi.SCp.this_residual);\n\t\t\tscsi_print_command(SCpnt);\n\t\t\tset_host_byte(SCpnt, DID_ERROR);\n\t\t\tgoto request_sense;\n\t\t}\n\t}\n\ndone:\n\tif (fas216_cmd_priv(SCpnt)->scsi_done) {\n\t\tfas216_cmd_priv(SCpnt)->scsi_done(SCpnt);\n\t\treturn;\n\t}\n\n\tpanic(\"scsi%d.H: null scsi_done function in fas216_done\",\n\t\tinfo->host->host_no);\n\n\nrequest_sense:\n\tif (SCpnt->cmnd[0] == REQUEST_SENSE)\n\t\tgoto done;\n\n\tscsi_eh_prep_cmnd(SCpnt, &info->ses, NULL, 0, ~0);\n\tfas216_log_target(info, LOG_CONNECT, SCpnt->device->id,\n\t\t\t  \"requesting sense\");\n\tinit_SCp(SCpnt);\n\tscsi_pointer->Message = 0;\n\tscsi_pointer->Status = 0;\n\tSCpnt->host_scribble = (void *)fas216_rq_sns_done;\n\n\t \n\tif (info->reqSCpnt)\n\t\tprintk(KERN_WARNING \"scsi%d.%c: losing request command\\n\",\n\t\t\tinfo->host->host_no, '0' + SCpnt->device->id);\n\tinfo->reqSCpnt = SCpnt;\n}\n\n \nstatic void fas216_done(FAS216_Info *info, unsigned int result)\n{\n\tvoid (*fn)(FAS216_Info *, struct scsi_cmnd *, unsigned int);\n\tstruct scsi_cmnd *SCpnt;\n\tunsigned long flags;\n\n\tfas216_checkmagic(info);\n\n\tif (!info->SCpnt)\n\t\tgoto no_command;\n\n\tSCpnt = info->SCpnt;\n\tinfo->SCpnt = NULL;\n    \tinfo->scsi.phase = PHASE_IDLE;\n\n\tif (info->scsi.aborting) {\n\t\tfas216_log(info, 0, \"uncaught abort - returning DID_ABORT\");\n\t\tresult = DID_ABORT;\n\t\tinfo->scsi.aborting = 0;\n\t}\n\n\t \n\tif (info->scsi.SCp.ptr && info->scsi.SCp.this_residual == 0) {\n\t\tscmd_printk(KERN_INFO, SCpnt,\n\t\t\t    \"zero bytes left to transfer, but buffer pointer still valid: ptr=%p len=%08x\\n\",\n\t\t\t    info->scsi.SCp.ptr, info->scsi.SCp.this_residual);\n\t\tinfo->scsi.SCp.ptr = NULL;\n\t\tscsi_print_command(SCpnt);\n\t}\n\n\t \n\tinfo->device[SCpnt->device->id].parity_check = 0;\n\tclear_bit(SCpnt->device->id * 8 +\n\t\t  (u8)(SCpnt->device->lun & 0x7), info->busyluns);\n\n\tfn = (void (*)(FAS216_Info *, struct scsi_cmnd *, unsigned int))SCpnt->host_scribble;\n\tfn(info, SCpnt, result);\n\n\tif (info->scsi.irq) {\n\t\tspin_lock_irqsave(&info->host_lock, flags);\n\t\tif (info->scsi.phase == PHASE_IDLE)\n\t\t\tfas216_kick(info);\n\t\tspin_unlock_irqrestore(&info->host_lock, flags);\n\t}\n\treturn;\n\nno_command:\n\tpanic(\"scsi%d.H: null command in fas216_done\",\n\t\tinfo->host->host_no);\n}\n\n \nstatic int fas216_queue_command_internal(struct scsi_cmnd *SCpnt,\n\t\t\t\t\t void (*done)(struct scsi_cmnd *))\n{\n\tFAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;\n\tint result;\n\n\tfas216_checkmagic(info);\n\n\tfas216_log_command(info, LOG_CONNECT, SCpnt,\n\t\t\t   \"received command (%p)\", SCpnt);\n\n\tfas216_cmd_priv(SCpnt)->scsi_done = done;\n\tSCpnt->host_scribble = (void *)fas216_std_done;\n\tSCpnt->result = 0;\n\n\tinit_SCp(SCpnt);\n\n\tinfo->stats.queues += 1;\n\n\tspin_lock(&info->host_lock);\n\n\t \n\tresult = !queue_add_cmd_ordered(&info->queues.issue, SCpnt);\n\n\t \n\tif (result == 0 && info->scsi.phase == PHASE_IDLE)\n\t\tfas216_kick(info);\n\tspin_unlock(&info->host_lock);\n\n\tfas216_log_target(info, LOG_CONNECT, -1, \"queue %s\",\n\t\tresult ? \"failure\" : \"success\");\n\n\treturn result;\n}\n\nstatic int fas216_queue_command_lck(struct scsi_cmnd *SCpnt)\n{\n\treturn fas216_queue_command_internal(SCpnt, scsi_done);\n}\n\nDEF_SCSI_QCMD(fas216_queue_command)\n\n \nstatic void fas216_internal_done(struct scsi_cmnd *SCpnt)\n{\n\tFAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;\n\n\tfas216_checkmagic(info);\n\n\tinfo->internal_done = 1;\n}\n\n \nstatic int fas216_noqueue_command_lck(struct scsi_cmnd *SCpnt)\n{\n\tFAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;\n\n\tfas216_checkmagic(info);\n\n\t \n\tBUG_ON(info->scsi.irq);\n\n\tinfo->internal_done = 0;\n\tfas216_queue_command_internal(SCpnt, fas216_internal_done);\n\n\t \n\tspin_unlock_irq(info->host->host_lock);\n\n\twhile (!info->internal_done) {\n\t\t \n\t\tif (fas216_readb(info, REG_STAT) & STAT_INT) {\n\t\t\tspin_lock_irq(info->host->host_lock);\n\t\t\tfas216_intr(info);\n\t\t\tspin_unlock_irq(info->host->host_lock);\n\t\t}\n\t}\n\n\tspin_lock_irq(info->host->host_lock);\n\n\tscsi_done(SCpnt);\n\n\treturn 0;\n}\n\nDEF_SCSI_QCMD(fas216_noqueue_command)\n\n \nstatic void fas216_eh_timer(struct timer_list *t)\n{\n\tFAS216_Info *info = from_timer(info, t, eh_timer);\n\n\tfas216_log(info, LOG_ERROR, \"error handling timed out\\n\");\n\n\tdel_timer(&info->eh_timer);\n\n\tif (info->rst_bus_status == 0)\n\t\tinfo->rst_bus_status = -1;\n\tif (info->rst_dev_status == 0)\n\t\tinfo->rst_dev_status = -1;\n\n\twake_up(&info->eh_wait);\n}\n\nenum res_find {\n\tres_failed,\t\t \n\tres_success,\t\t \n\tres_hw_abort\t\t \n};\n\n \nstatic enum res_find fas216_find_command(FAS216_Info *info,\n\t\t\t\t\t struct scsi_cmnd *SCpnt)\n{\n\tenum res_find res = res_failed;\n\n\tif (queue_remove_cmd(&info->queues.issue, SCpnt)) {\n\t\t \n\t\tprintk(\"on issue queue \");\n\n\t\tres = res_success;\n\t} else if (queue_remove_cmd(&info->queues.disconnected, SCpnt)) {\n\t\t \n\t\tprintk(\"on disconnected queue \");\n\n\t\tres = res_hw_abort;\n\t} else if (info->SCpnt == SCpnt) {\n\t\tprintk(\"executing \");\n\n\t\tswitch (info->scsi.phase) {\n\t\t \n\t\tcase PHASE_IDLE:\n\t\t\tif (info->scsi.disconnectable) {\n\t\t\t\tinfo->scsi.disconnectable = 0;\n\t\t\t\tinfo->SCpnt = NULL;\n\t\t\t\tres = res_hw_abort;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (info->origSCpnt == SCpnt) {\n\t\t \n\t\tinfo->origSCpnt = NULL;\n\t\tclear_bit(SCpnt->device->id * 8 +\n\t\t\t  (u8)(SCpnt->device->lun & 0x7), info->busyluns);\n\t\tprintk(\"waiting for execution \");\n\t\tres = res_success;\n\t} else\n\t\tprintk(\"unknown \");\n\n\treturn res;\n}\n\n \nint fas216_eh_abort(struct scsi_cmnd *SCpnt)\n{\n\tFAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;\n\tint result = FAILED;\n\n\tfas216_checkmagic(info);\n\n\tinfo->stats.aborts += 1;\n\n\tscmd_printk(KERN_WARNING, SCpnt, \"abort command\\n\");\n\n\tprint_debug_list();\n\tfas216_dumpstate(info);\n\n\tswitch (fas216_find_command(info, SCpnt)) {\n\t \n\tcase res_success:\n\t\tscmd_printk(KERN_WARNING, SCpnt, \"abort %p success\\n\", SCpnt);\n\t\tresult = SUCCESS;\n\t\tbreak;\n\n\t \n\tcase res_hw_abort:\n\n\t \n\tdefault:\n\tcase res_failed:\n\t\tscmd_printk(KERN_WARNING, SCpnt, \"abort %p failed\\n\", SCpnt);\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\n \nint fas216_eh_device_reset(struct scsi_cmnd *SCpnt)\n{\n\tFAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;\n\tunsigned long flags;\n\tint i, res = FAILED, target = SCpnt->device->id;\n\n\tfas216_log(info, LOG_ERROR, \"device reset for target %d\", target);\n\n\tspin_lock_irqsave(&info->host_lock, flags);\n\n\tdo {\n\t\t \n\t\tif (info->SCpnt && !info->scsi.disconnectable &&\n\t\t    info->SCpnt->device->id == SCpnt->device->id)\n\t\t\tbreak;\n\n\t\t \n\t\tqueue_remove_all_target(&info->queues.issue, target);\n\t\tqueue_remove_all_target(&info->queues.disconnected, target);\n\t\tif (info->origSCpnt && info->origSCpnt->device->id == target)\n\t\t\tinfo->origSCpnt = NULL;\n\t\tif (info->reqSCpnt && info->reqSCpnt->device->id == target)\n\t\t\tinfo->reqSCpnt = NULL;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tclear_bit(target * 8 + i, info->busyluns);\n\n\t\t \n\t\tSCpnt->host_scribble = (void *)fas216_devicereset_done;\n\n\t\tinfo->rst_dev_status = 0;\n\t\tinfo->rstSCpnt = SCpnt;\n\n\t\tif (info->scsi.phase == PHASE_IDLE)\n\t\t\tfas216_kick(info);\n\n\t\tmod_timer(&info->eh_timer, jiffies + 30 * HZ);\n\t\tspin_unlock_irqrestore(&info->host_lock, flags);\n\n\t\t \n\t\twait_event(info->eh_wait, info->rst_dev_status);\n\n\t\tdel_timer_sync(&info->eh_timer);\n\t\tspin_lock_irqsave(&info->host_lock, flags);\n\t\tinfo->rstSCpnt = NULL;\n\n\t\tif (info->rst_dev_status == 1)\n\t\t\tres = SUCCESS;\n\t} while (0);\n\n\tSCpnt->host_scribble = NULL;\n\tspin_unlock_irqrestore(&info->host_lock, flags);\n\n\tfas216_log(info, LOG_ERROR, \"device reset complete: %s\\n\",\n\t\t   res == SUCCESS ? \"success\" : \"failed\");\n\n\treturn res;\n}\n\n \nint fas216_eh_bus_reset(struct scsi_cmnd *SCpnt)\n{\n\tFAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;\n\tunsigned long flags;\n\tstruct scsi_device *SDpnt;\n\n\tfas216_checkmagic(info);\n\tfas216_log(info, LOG_ERROR, \"resetting bus\");\n\n\tinfo->stats.bus_resets += 1;\n\n\tspin_lock_irqsave(&info->host_lock, flags);\n\n\t \n\tfas216_aborttransfer(info);\n\tfas216_writeb(info, REG_CNTL3, info->scsi.cfg[2]);\n\n\t \n\twhile (fas216_readb(info, REG_STAT) & STAT_INT)\n\t\tfas216_readb(info, REG_INST);\n\n\tinfo->rst_bus_status = 0;\n\n\t \n\tshost_for_each_device(SDpnt, info->host) {\n\t\tint i;\n\n\t\tif (SDpnt->soft_reset)\n\t\t\tcontinue;\n\n\t\tqueue_remove_all_target(&info->queues.issue, SDpnt->id);\n\t\tqueue_remove_all_target(&info->queues.disconnected, SDpnt->id);\n\t\tif (info->origSCpnt && info->origSCpnt->device->id == SDpnt->id)\n\t\t\tinfo->origSCpnt = NULL;\n\t\tif (info->reqSCpnt && info->reqSCpnt->device->id == SDpnt->id)\n\t\t\tinfo->reqSCpnt = NULL;\n\t\tinfo->SCpnt = NULL;\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tclear_bit(SDpnt->id * 8 + i, info->busyluns);\n\t}\n\n\tinfo->scsi.phase = PHASE_IDLE;\n\n\t \n\tfas216_cmd(info, CMD_RESETSCSI);\n\n\tmod_timer(&info->eh_timer, jiffies + HZ);\n\tspin_unlock_irqrestore(&info->host_lock, flags);\n\n\t \n\twait_event(info->eh_wait, info->rst_bus_status);\n\tdel_timer_sync(&info->eh_timer);\n\n\tfas216_log(info, LOG_ERROR, \"bus reset complete: %s\\n\",\n\t\t   info->rst_bus_status == 1 ? \"success\" : \"failed\");\n\n\treturn info->rst_bus_status == 1 ? SUCCESS : FAILED;\n}\n\n \nstatic void fas216_init_chip(FAS216_Info *info)\n{\n\tunsigned int clock = ((info->ifcfg.clockrate - 1) / 5 + 1) & 7;\n\tfas216_writeb(info, REG_CLKF, clock);\n\tfas216_writeb(info, REG_CNTL1, info->scsi.cfg[0]);\n\tfas216_writeb(info, REG_CNTL2, info->scsi.cfg[1]);\n\tfas216_writeb(info, REG_CNTL3, info->scsi.cfg[2]);\n\tfas216_writeb(info, REG_STIM, info->ifcfg.select_timeout);\n\tfas216_writeb(info, REG_SOF, 0);\n\tfas216_writeb(info, REG_STP, info->scsi.async_stp);\n\tfas216_writeb(info, REG_CNTL1, info->scsi.cfg[0]);\n}\n\n \nint fas216_eh_host_reset(struct scsi_cmnd *SCpnt)\n{\n\tFAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;\n\n\tspin_lock_irq(info->host->host_lock);\n\n\tfas216_checkmagic(info);\n\n\tfas216_log(info, LOG_ERROR, \"resetting host\");\n\n\t \n\tfas216_cmd(info, CMD_RESETCHIP);\n\n\t \n\tspin_unlock_irq(info->host->host_lock);\n\tmsleep(50 * 1000/100);\n\tspin_lock_irq(info->host->host_lock);\n\n\t \n\tfas216_cmd(info, CMD_NOP);\n\n\tfas216_init_chip(info);\n\n\tspin_unlock_irq(info->host->host_lock);\n\treturn SUCCESS;\n}\n\n#define TYPE_UNKNOWN\t0\n#define TYPE_NCR53C90\t1\n#define TYPE_NCR53C90A\t2\n#define TYPE_NCR53C9x\t3\n#define TYPE_Am53CF94\t4\n#define TYPE_EmFAS216\t5\n#define TYPE_QLFAS216\t6\n\nstatic char *chip_types[] = {\n\t\"unknown\",\n\t\"NS NCR53C90\",\n\t\"NS NCR53C90A\",\n\t\"NS NCR53C9x\",\n\t\"AMD Am53CF94\",\n\t\"Emulex FAS216\",\n\t\"QLogic FAS216\"\n};\n\nstatic int fas216_detect_type(FAS216_Info *info)\n{\n\tint family, rev;\n\n\t \n\tfas216_writeb(info, REG_CMD, CMD_RESETCHIP);\n\tudelay(50);\n\tfas216_writeb(info, REG_CMD, CMD_NOP);\n\n\t \n\tfas216_writeb(info, REG_CNTL3, 0);\n\tfas216_writeb(info, REG_CNTL2, CNTL2_S2FE);\n\n\t \n\tif ((fas216_readb(info, REG_CNTL2) & (~0xe0)) != CNTL2_S2FE)\n\t\treturn TYPE_NCR53C90;\n\n\t \n\tfas216_writeb(info, REG_CNTL2, 0);\n\tfas216_writeb(info, REG_CNTL3, 0);\n\tfas216_writeb(info, REG_CNTL3, 5);\n\n\t \n\tif (fas216_readb(info, REG_CNTL3) != 5)\n\t\treturn TYPE_NCR53C90A;\n\n\t \n\tfas216_writeb(info, REG_CNTL3, 0);\n\n\tfas216_writeb(info, REG_CNTL3, CNTL3_ADIDCHK);\n\tfas216_writeb(info, REG_CNTL3, 0);\n\n\tfas216_writeb(info, REG_CMD, CMD_RESETCHIP);\n\tudelay(50);\n\tfas216_writeb(info, REG_CMD, CMD_WITHDMA | CMD_NOP);\n\n\tfas216_writeb(info, REG_CNTL2, CNTL2_ENF);\n\tfas216_writeb(info, REG_CMD, CMD_RESETCHIP);\n\tudelay(50);\n\tfas216_writeb(info, REG_CMD, CMD_NOP);\n\n\trev     = fas216_readb(info, REG_ID);\n\tfamily  = rev >> 3;\n\trev    &= 7;\n\n\tswitch (family) {\n\tcase 0x01:\n\t\tif (rev == 4)\n\t\t\treturn TYPE_Am53CF94;\n\t\tbreak;\n\n\tcase 0x02:\n\t\tswitch (rev) {\n\t\tcase 2:\n\t\t\treturn TYPE_EmFAS216;\n\t\tcase 3:\n\t\t\treturn TYPE_QLFAS216;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tprintk(\"family %x rev %x\\n\", family, rev);\n\treturn TYPE_NCR53C9x;\n}\n\n \nstatic void fas216_reset_state(FAS216_Info *info)\n{\n\tint i;\n\n\tfas216_checkmagic(info);\n\n\tfas216_bus_reset(info);\n\n\t \n\tmemset(info->busyluns, 0, sizeof(info->busyluns));\n\tinfo->scsi.disconnectable = 0;\n\tinfo->scsi.aborting = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tinfo->device[i].parity_enabled\t= 0;\n\t\tinfo->device[i].parity_check\t= 1;\n\t}\n\n\t \n\twhile (queue_remove(&info->queues.disconnected) != NULL);\n\n\t \n\tinfo->SCpnt     = NULL;\n\tinfo->reqSCpnt  = NULL;\n\tinfo->rstSCpnt  = NULL;\n\tinfo->origSCpnt = NULL;\n}\n\n \nint fas216_init(struct Scsi_Host *host)\n{\n\tFAS216_Info *info = (FAS216_Info *)host->hostdata;\n\n\tinfo->magic_start    = MAGIC;\n\tinfo->magic_end      = MAGIC;\n\tinfo->host           = host;\n\tinfo->scsi.cfg[0]    = host->this_id | CNTL1_PERE;\n\tinfo->scsi.cfg[1]    = CNTL2_ENF | CNTL2_S2FE;\n\tinfo->scsi.cfg[2]    = info->ifcfg.cntl3 |\n\t\t\t       CNTL3_ADIDCHK | CNTL3_QTAG | CNTL3_G2CB | CNTL3_LBTM;\n\tinfo->scsi.async_stp = fas216_syncperiod(info, info->ifcfg.asyncperiod);\n\n\tinfo->rst_dev_status = -1;\n\tinfo->rst_bus_status = -1;\n\tinit_waitqueue_head(&info->eh_wait);\n\ttimer_setup(&info->eh_timer, fas216_eh_timer, 0);\n\t\n\tspin_lock_init(&info->host_lock);\n\n\tmemset(&info->stats, 0, sizeof(info->stats));\n\n\tmsgqueue_initialise(&info->scsi.msgs);\n\n\tif (!queue_initialise(&info->queues.issue))\n\t\treturn -ENOMEM;\n\n\tif (!queue_initialise(&info->queues.disconnected)) {\n\t\tqueue_free(&info->queues.issue);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nint fas216_add(struct Scsi_Host *host, struct device *dev)\n{\n\tFAS216_Info *info = (FAS216_Info *)host->hostdata;\n\tint type, ret;\n\n\tif (info->ifcfg.clockrate <= 10 || info->ifcfg.clockrate > 40) {\n\t\tprintk(KERN_CRIT \"fas216: invalid clock rate %u MHz\\n\",\n\t\t\tinfo->ifcfg.clockrate);\n\t\treturn -EINVAL;\n\t}\n\n\tfas216_reset_state(info);\n\ttype = fas216_detect_type(info);\n\tinfo->scsi.type = chip_types[type];\n\n\tudelay(300);\n\n\t \n\tfas216_init_chip(info);\n\n\t \n\tfas216_writeb(info, REG_CNTL1, info->scsi.cfg[0] | CNTL1_DISR);\n\tfas216_writeb(info, REG_CMD, CMD_RESETSCSI);\n\n\t \n\tspin_unlock_irq(info->host->host_lock);\n\tmsleep(100*1000/100);\n\tspin_lock_irq(info->host->host_lock);\n\n\tfas216_writeb(info, REG_CNTL1, info->scsi.cfg[0]);\n\tfas216_readb(info, REG_INST);\n\n\tfas216_checkmagic(info);\n\n\tret = scsi_add_host(host, dev);\n\tif (ret)\n\t\tfas216_writeb(info, REG_CMD, CMD_RESETCHIP);\n\telse\n\t\tscsi_scan_host(host);\n\n\treturn ret;\n}\n\nvoid fas216_remove(struct Scsi_Host *host)\n{\n\tFAS216_Info *info = (FAS216_Info *)host->hostdata;\n\n\tfas216_checkmagic(info);\n\tscsi_remove_host(host);\n\n\tfas216_writeb(info, REG_CMD, CMD_RESETCHIP);\n\tscsi_host_put(host);\n}\n\n \nvoid fas216_release(struct Scsi_Host *host)\n{\n\tFAS216_Info *info = (FAS216_Info *)host->hostdata;\n\n\tqueue_free(&info->queues.disconnected);\n\tqueue_free(&info->queues.issue);\n}\n\nvoid fas216_print_host(FAS216_Info *info, struct seq_file *m)\n{\n\tseq_printf(m,\n\t\t\t\"\\n\"\n\t\t\t\"Chip    : %s\\n\"\n\t\t\t\" Address: 0x%p\\n\"\n\t\t\t\" IRQ    : %d\\n\"\n\t\t\t\" DMA    : %d\\n\",\n\t\t\tinfo->scsi.type, info->scsi.io_base,\n\t\t\tinfo->scsi.irq, info->scsi.dma);\n}\n\nvoid fas216_print_stats(FAS216_Info *info, struct seq_file *m)\n{\n\tseq_printf(m, \"\\n\"\n\t\t\t\"Command Statistics:\\n\"\n\t\t\t\" Queued     : %u\\n\"\n\t\t\t\" Issued     : %u\\n\"\n\t\t\t\" Completed  : %u\\n\"\n\t\t\t\" Reads      : %u\\n\"\n\t\t\t\" Writes     : %u\\n\"\n\t\t\t\" Others     : %u\\n\"\n\t\t\t\" Disconnects: %u\\n\"\n\t\t\t\" Aborts     : %u\\n\"\n\t\t\t\" Bus resets : %u\\n\"\n\t\t\t\" Host resets: %u\\n\",\n\t\t\tinfo->stats.queues,\t info->stats.removes,\n\t\t\tinfo->stats.fins,\t info->stats.reads,\n\t\t\tinfo->stats.writes,\t info->stats.miscs,\n\t\t\tinfo->stats.disconnects, info->stats.aborts,\n\t\t\tinfo->stats.bus_resets,\t info->stats.host_resets);\n}\n\nvoid fas216_print_devices(FAS216_Info *info, struct seq_file *m)\n{\n\tstruct fas216_device *dev;\n\tstruct scsi_device *scd;\n\n\tseq_puts(m, \"Device/Lun TaggedQ       Parity   Sync\\n\");\n\n\tshost_for_each_device(scd, info->host) {\n\t\tdev = &info->device[scd->id];\n\t\tseq_printf(m, \"     %d/%llu   \", scd->id, scd->lun);\n\t\tif (scd->tagged_supported)\n\t\t\tseq_printf(m, \"%3sabled \",\n\t\t\t\t     scd->simple_tags ? \"en\" : \"dis\");\n\t\telse\n\t\t\tseq_puts(m, \"unsupported   \");\n\n\t\tseq_printf(m, \"%3sabled \", dev->parity_enabled ? \"en\" : \"dis\");\n\n\t\tif (dev->sof)\n\t\t\tseq_printf(m, \"offset %d, %d ns\\n\",\n\t\t\t\t     dev->sof, dev->period * 4);\n\t\telse\n\t\t\tseq_puts(m, \"async\\n\");\n\t}\n}\n\nEXPORT_SYMBOL(fas216_init);\nEXPORT_SYMBOL(fas216_add);\nEXPORT_SYMBOL(fas216_queue_command);\nEXPORT_SYMBOL(fas216_noqueue_command);\nEXPORT_SYMBOL(fas216_intr);\nEXPORT_SYMBOL(fas216_remove);\nEXPORT_SYMBOL(fas216_release);\nEXPORT_SYMBOL(fas216_eh_abort);\nEXPORT_SYMBOL(fas216_eh_device_reset);\nEXPORT_SYMBOL(fas216_eh_bus_reset);\nEXPORT_SYMBOL(fas216_eh_host_reset);\nEXPORT_SYMBOL(fas216_print_host);\nEXPORT_SYMBOL(fas216_print_stats);\nEXPORT_SYMBOL(fas216_print_devices);\n\nMODULE_AUTHOR(\"Russell King\");\nMODULE_DESCRIPTION(\"Generic FAS216/NCR53C9x driver core\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}