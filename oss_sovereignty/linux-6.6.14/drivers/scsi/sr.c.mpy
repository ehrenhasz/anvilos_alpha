{
  "module_name": "sr.c",
  "hash_id": "ec8771b779f4566b20624623620f094350d373cd09ede049b0d648f0e76ee223",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sr.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/compat.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/cdrom.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/major.h>\n#include <linux/blkdev.h>\n#include <linux/blk-pm.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/uaccess.h>\n\n#include <asm/unaligned.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_driver.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_ioctl.h>\t \n\n#include \"scsi_logging.h\"\n#include \"sr.h\"\n\n\nMODULE_DESCRIPTION(\"SCSI cdrom (sr) driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_CDROM_MAJOR);\nMODULE_ALIAS_SCSI_DEVICE(TYPE_ROM);\nMODULE_ALIAS_SCSI_DEVICE(TYPE_WORM);\n\n#define SR_DISKS\t256\n\n#define SR_CAPABILITIES \\\n\t(CDC_CLOSE_TRAY|CDC_OPEN_TRAY|CDC_LOCK|CDC_SELECT_SPEED| \\\n\t CDC_SELECT_DISC|CDC_MULTI_SESSION|CDC_MCN|CDC_MEDIA_CHANGED| \\\n\t CDC_PLAY_AUDIO|CDC_RESET|CDC_DRIVE_STATUS| \\\n\t CDC_CD_R|CDC_CD_RW|CDC_DVD|CDC_DVD_R|CDC_DVD_RAM|CDC_GENERIC_PACKET| \\\n\t CDC_MRW|CDC_MRW_W|CDC_RAM)\n\nstatic int sr_probe(struct device *);\nstatic int sr_remove(struct device *);\nstatic blk_status_t sr_init_command(struct scsi_cmnd *SCpnt);\nstatic int sr_done(struct scsi_cmnd *);\nstatic int sr_runtime_suspend(struct device *dev);\n\nstatic const struct dev_pm_ops sr_pm_ops = {\n\t.runtime_suspend\t= sr_runtime_suspend,\n};\n\nstatic struct scsi_driver sr_template = {\n\t.gendrv = {\n\t\t.name   \t= \"sr\",\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.probe\t\t= sr_probe,\n\t\t.remove\t\t= sr_remove,\n\t\t.pm\t\t= &sr_pm_ops,\n\t},\n\t.init_command\t\t= sr_init_command,\n\t.done\t\t\t= sr_done,\n};\n\nstatic unsigned long sr_index_bits[SR_DISKS / BITS_PER_LONG];\nstatic DEFINE_SPINLOCK(sr_index_lock);\n\nstatic struct lock_class_key sr_bio_compl_lkclass;\n\nstatic int sr_open(struct cdrom_device_info *, int);\nstatic void sr_release(struct cdrom_device_info *);\n\nstatic void get_sectorsize(struct scsi_cd *);\nstatic int get_capabilities(struct scsi_cd *);\n\nstatic unsigned int sr_check_events(struct cdrom_device_info *cdi,\n\t\t\t\t    unsigned int clearing, int slot);\nstatic int sr_packet(struct cdrom_device_info *, struct packet_command *);\nstatic int sr_read_cdda_bpc(struct cdrom_device_info *cdi, void __user *ubuf,\n\t\tu32 lba, u32 nr, u8 *last_sense);\n\nstatic const struct cdrom_device_ops sr_dops = {\n\t.open\t\t\t= sr_open,\n\t.release\t \t= sr_release,\n\t.drive_status\t \t= sr_drive_status,\n\t.check_events\t\t= sr_check_events,\n\t.tray_move\t\t= sr_tray_move,\n\t.lock_door\t\t= sr_lock_door,\n\t.select_speed\t\t= sr_select_speed,\n\t.get_last_session\t= sr_get_last_session,\n\t.get_mcn\t\t= sr_get_mcn,\n\t.reset\t\t\t= sr_reset,\n\t.audio_ioctl\t\t= sr_audio_ioctl,\n\t.generic_packet\t\t= sr_packet,\n\t.read_cdda_bpc\t\t= sr_read_cdda_bpc,\n\t.capability\t\t= SR_CAPABILITIES,\n};\n\nstatic inline struct scsi_cd *scsi_cd(struct gendisk *disk)\n{\n\treturn disk->private_data;\n}\n\nstatic int sr_runtime_suspend(struct device *dev)\n{\n\tstruct scsi_cd *cd = dev_get_drvdata(dev);\n\n\tif (!cd)\t \n\t\treturn 0;\n\n\tif (cd->media_present)\n\t\treturn -EBUSY;\n\telse\n\t\treturn 0;\n}\n\nstatic unsigned int sr_get_events(struct scsi_device *sdev)\n{\n\tu8 buf[8];\n\tu8 cmd[] = { GET_EVENT_STATUS_NOTIFICATION,\n\t\t     1,\t\t\t \n\t\t     0, 0,\t\t \n\t\t     1 << 4,\t\t \n\t\t     0, 0,\t\t \n\t\t     0, sizeof(buf),\t \n\t\t     0,\t\t\t \n\t};\n\tstruct event_header *eh = (void *)buf;\n\tstruct media_event_desc *med = (void *)(buf + 4);\n\tstruct scsi_sense_hdr sshdr;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\tint result;\n\n\tresult = scsi_execute_cmd(sdev, cmd, REQ_OP_DRV_IN, buf, sizeof(buf),\n\t\t\t\t  SR_TIMEOUT, MAX_RETRIES, &exec_args);\n\tif (scsi_sense_valid(&sshdr) && sshdr.sense_key == UNIT_ATTENTION)\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\n\tif (result || be16_to_cpu(eh->data_len) < sizeof(*med))\n\t\treturn 0;\n\n\tif (eh->nea || eh->notification_class != 0x4)\n\t\treturn 0;\n\n\tif (med->media_event_code == 1)\n\t\treturn DISK_EVENT_EJECT_REQUEST;\n\telse if (med->media_event_code == 2)\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\telse if (med->media_event_code == 3)\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\treturn 0;\n}\n\n \nstatic unsigned int sr_check_events(struct cdrom_device_info *cdi,\n\t\t\t\t    unsigned int clearing, int slot)\n{\n\tstruct scsi_cd *cd = cdi->handle;\n\tbool last_present;\n\tstruct scsi_sense_hdr sshdr;\n\tunsigned int events;\n\tint ret;\n\n\t \n\tif (CDSL_CURRENT != slot)\n\t\treturn 0;\n\n\tevents = sr_get_events(cd->device);\n\tcd->get_event_changed |= events & DISK_EVENT_MEDIA_CHANGE;\n\n\t \n\tif (cd->ignore_get_event) {\n\t\tevents &= ~DISK_EVENT_MEDIA_CHANGE;\n\t\tgoto do_tur;\n\t}\n\n\t \n\tif (cd->device->changed) {\n\t\tevents |= DISK_EVENT_MEDIA_CHANGE;\n\t\tcd->device->changed = 0;\n\t\tcd->tur_changed = true;\n\t}\n\n\tif (!(clearing & DISK_EVENT_MEDIA_CHANGE))\n\t\treturn events;\ndo_tur:\n\t \n\tlast_present = cd->media_present;\n\tret = scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr);\n\n\t \n\tcd->media_present = scsi_status_is_good(ret) ||\n\t\t(scsi_sense_valid(&sshdr) && sshdr.asc != 0x3a);\n\n\tif (last_present != cd->media_present)\n\t\tcd->device->changed = 1;\n\n\tif (cd->device->changed) {\n\t\tevents |= DISK_EVENT_MEDIA_CHANGE;\n\t\tcd->device->changed = 0;\n\t\tcd->tur_changed = true;\n\t}\n\n\tif (cd->ignore_get_event)\n\t\treturn events;\n\n\t \n\tif (!cd->tur_changed) {\n\t\tif (cd->get_event_changed) {\n\t\t\tif (cd->tur_mismatch++ > 8) {\n\t\t\t\tsr_printk(KERN_WARNING, cd,\n\t\t\t\t\t  \"GET_EVENT and TUR disagree continuously, suppress GET_EVENT events\\n\");\n\t\t\t\tcd->ignore_get_event = true;\n\t\t\t}\n\t\t} else {\n\t\t\tcd->tur_mismatch = 0;\n\t\t}\n\t}\n\tcd->tur_changed = false;\n\tcd->get_event_changed = false;\n\n\treturn events;\n}\n\n \nstatic int sr_done(struct scsi_cmnd *SCpnt)\n{\n\tint result = SCpnt->result;\n\tint this_count = scsi_bufflen(SCpnt);\n\tint good_bytes = (result == 0 ? this_count : 0);\n\tint block_sectors = 0;\n\tlong error_sector;\n\tstruct request *rq = scsi_cmd_to_rq(SCpnt);\n\tstruct scsi_cd *cd = scsi_cd(rq->q->disk);\n\n#ifdef DEBUG\n\tscmd_printk(KERN_INFO, SCpnt, \"done: %x\\n\", result);\n#endif\n\n\t \n\tif (scsi_status_is_check_condition(result) &&\n\t    (SCpnt->sense_buffer[0] & 0x7f) == 0x70) {  \n\t\tswitch (SCpnt->sense_buffer[2]) {\n\t\tcase MEDIUM_ERROR:\n\t\tcase VOLUME_OVERFLOW:\n\t\tcase ILLEGAL_REQUEST:\n\t\t\tif (!(SCpnt->sense_buffer[0] & 0x90))\n\t\t\t\tbreak;\n\t\t\terror_sector =\n\t\t\t\tget_unaligned_be32(&SCpnt->sense_buffer[3]);\n\t\t\tif (rq->bio != NULL)\n\t\t\t\tblock_sectors = bio_sectors(rq->bio);\n\t\t\tif (block_sectors < 4)\n\t\t\t\tblock_sectors = 4;\n\t\t\tif (cd->device->sector_size == 2048)\n\t\t\t\terror_sector <<= 2;\n\t\t\terror_sector &= ~(block_sectors - 1);\n\t\t\tgood_bytes = (error_sector - blk_rq_pos(rq)) << 9;\n\t\t\tif (good_bytes < 0 || good_bytes >= this_count)\n\t\t\t\tgood_bytes = 0;\n\t\t\t \n\t\t\tif (error_sector < get_capacity(cd->disk) &&\n\t\t\t    cd->capacity - error_sector < 4 * 75)\n\t\t\t\tset_capacity(cd->disk, error_sector);\n\t\t\tbreak;\n\n\t\tcase RECOVERED_ERROR:\n\t\t\tgood_bytes = this_count;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn good_bytes;\n}\n\nstatic blk_status_t sr_init_command(struct scsi_cmnd *SCpnt)\n{\n\tint block = 0, this_count, s_size;\n\tstruct scsi_cd *cd;\n\tstruct request *rq = scsi_cmd_to_rq(SCpnt);\n\tblk_status_t ret;\n\n\tret = scsi_alloc_sgtables(SCpnt);\n\tif (ret != BLK_STS_OK)\n\t\treturn ret;\n\tcd = scsi_cd(rq->q->disk);\n\n\tSCSI_LOG_HLQUEUE(1, scmd_printk(KERN_INFO, SCpnt,\n\t\t\"Doing sr request, block = %d\\n\", block));\n\n\tif (!cd->device || !scsi_device_online(cd->device)) {\n\t\tSCSI_LOG_HLQUEUE(2, scmd_printk(KERN_INFO, SCpnt,\n\t\t\t\"Finishing %u sectors\\n\", blk_rq_sectors(rq)));\n\t\tSCSI_LOG_HLQUEUE(2, scmd_printk(KERN_INFO, SCpnt,\n\t\t\t\"Retry with 0x%p\\n\", SCpnt));\n\t\tgoto out;\n\t}\n\n\tif (cd->device->changed) {\n\t\t \n\t\tgoto out;\n\t}\n\n\ts_size = cd->device->sector_size;\n\tif (s_size != 512 && s_size != 1024 && s_size != 2048) {\n\t\tscmd_printk(KERN_ERR, SCpnt, \"bad sector size %d\\n\", s_size);\n\t\tgoto out;\n\t}\n\n\tswitch (req_op(rq)) {\n\tcase REQ_OP_WRITE:\n\t\tif (!cd->writeable)\n\t\t\tgoto out;\n\t\tSCpnt->cmnd[0] = WRITE_10;\n\t\tcd->cdi.media_written = 1;\n\t\tbreak;\n\tcase REQ_OP_READ:\n\t\tSCpnt->cmnd[0] = READ_10;\n\t\tbreak;\n\tdefault:\n\t\tblk_dump_rq_flags(rq, \"Unknown sr command\");\n\t\tgoto out;\n\t}\n\n\t{\n\t\tstruct scatterlist *sg;\n\t\tint i, size = 0, sg_count = scsi_sg_count(SCpnt);\n\n\t\tscsi_for_each_sg(SCpnt, sg, sg_count, i)\n\t\t\tsize += sg->length;\n\n\t\tif (size != scsi_bufflen(SCpnt)) {\n\t\t\tscmd_printk(KERN_ERR, SCpnt,\n\t\t\t\t\"mismatch count %d, bytes %d\\n\",\n\t\t\t\tsize, scsi_bufflen(SCpnt));\n\t\t\tif (scsi_bufflen(SCpnt) > size)\n\t\t\t\tSCpnt->sdb.length = size;\n\t\t}\n\t}\n\n\t \n\tif (((unsigned int)blk_rq_pos(rq) % (s_size >> 9)) ||\n\t    (scsi_bufflen(SCpnt) % s_size)) {\n\t\tscmd_printk(KERN_NOTICE, SCpnt, \"unaligned transfer\\n\");\n\t\tgoto out;\n\t}\n\n\tthis_count = (scsi_bufflen(SCpnt) >> 9) / (s_size >> 9);\n\n\n\tSCSI_LOG_HLQUEUE(2, scmd_printk(KERN_INFO, SCpnt,\n\t\t\t\t\t\"%s %d/%u 512 byte blocks.\\n\",\n\t\t\t\t\t(rq_data_dir(rq) == WRITE) ?\n\t\t\t\t\t\"writing\" : \"reading\",\n\t\t\t\t\tthis_count, blk_rq_sectors(rq)));\n\n\tSCpnt->cmnd[1] = 0;\n\tblock = (unsigned int)blk_rq_pos(rq) / (s_size >> 9);\n\n\tif (this_count > 0xffff) {\n\t\tthis_count = 0xffff;\n\t\tSCpnt->sdb.length = this_count * s_size;\n\t}\n\n\tput_unaligned_be32(block, &SCpnt->cmnd[2]);\n\tSCpnt->cmnd[6] = SCpnt->cmnd[9] = 0;\n\tput_unaligned_be16(this_count, &SCpnt->cmnd[7]);\n\n\t \n\tSCpnt->transfersize = cd->device->sector_size;\n\tSCpnt->underflow = this_count << 9;\n\tSCpnt->allowed = MAX_RETRIES;\n\tSCpnt->cmd_len = 10;\n\n\t \n\treturn BLK_STS_OK;\n out:\n\tscsi_free_sgtables(SCpnt);\n\treturn BLK_STS_IOERR;\n}\n\nstatic void sr_revalidate_disk(struct scsi_cd *cd)\n{\n\tstruct scsi_sense_hdr sshdr;\n\n\t \n\tif (scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr))\n\t\treturn;\n\tsr_cd_check(&cd->cdi);\n\tget_sectorsize(cd);\n}\n\nstatic int sr_block_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tstruct scsi_cd *cd = scsi_cd(disk);\n\tstruct scsi_device *sdev = cd->device;\n\tint ret;\n\n\tif (scsi_device_get(cd->device))\n\t\treturn -ENXIO;\n\n\tscsi_autopm_get_device(sdev);\n\tif (disk_check_media_change(disk))\n\t\tsr_revalidate_disk(cd);\n\n\tmutex_lock(&cd->lock);\n\tret = cdrom_open(&cd->cdi, mode);\n\tmutex_unlock(&cd->lock);\n\n\tscsi_autopm_put_device(sdev);\n\tif (ret)\n\t\tscsi_device_put(cd->device);\n\treturn ret;\n}\n\nstatic void sr_block_release(struct gendisk *disk)\n{\n\tstruct scsi_cd *cd = scsi_cd(disk);\n\n\tmutex_lock(&cd->lock);\n\tcdrom_release(&cd->cdi);\n\tmutex_unlock(&cd->lock);\n\n\tscsi_device_put(cd->device);\n}\n\nstatic int sr_block_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\tunsigned cmd, unsigned long arg)\n{\n\tstruct scsi_cd *cd = scsi_cd(bdev->bd_disk);\n\tstruct scsi_device *sdev = cd->device;\n\tvoid __user *argp = (void __user *)arg;\n\tint ret;\n\n\tif (bdev_is_partition(bdev) && !capable(CAP_SYS_RAWIO))\n\t\treturn -ENOIOCTLCMD;\n\n\tmutex_lock(&cd->lock);\n\n\tret = scsi_ioctl_block_when_processing_errors(sdev, cmd,\n\t\t\t(mode & BLK_OPEN_NDELAY));\n\tif (ret)\n\t\tgoto out;\n\n\tscsi_autopm_get_device(sdev);\n\n\tif (cmd != CDROMCLOSETRAY && cmd != CDROMEJECT) {\n\t\tret = cdrom_ioctl(&cd->cdi, bdev, cmd, arg);\n\t\tif (ret != -ENOSYS)\n\t\t\tgoto put;\n\t}\n\tret = scsi_ioctl(sdev, mode & BLK_OPEN_WRITE, cmd, argp);\n\nput:\n\tscsi_autopm_put_device(sdev);\nout:\n\tmutex_unlock(&cd->lock);\n\treturn ret;\n}\n\nstatic unsigned int sr_block_check_events(struct gendisk *disk,\n\t\t\t\t\t  unsigned int clearing)\n{\n\tstruct scsi_cd *cd = disk->private_data;\n\n\tif (atomic_read(&cd->device->disk_events_disable_depth))\n\t\treturn 0;\n\treturn cdrom_check_events(&cd->cdi, clearing);\n}\n\nstatic void sr_free_disk(struct gendisk *disk)\n{\n\tstruct scsi_cd *cd = disk->private_data;\n\n\tspin_lock(&sr_index_lock);\n\tclear_bit(MINOR(disk_devt(disk)), sr_index_bits);\n\tspin_unlock(&sr_index_lock);\n\n\tunregister_cdrom(&cd->cdi);\n\tmutex_destroy(&cd->lock);\n\tkfree(cd);\n}\n\nstatic const struct block_device_operations sr_bdops =\n{\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= sr_block_open,\n\t.release\t= sr_block_release,\n\t.ioctl\t\t= sr_block_ioctl,\n\t.compat_ioctl\t= blkdev_compat_ptr_ioctl,\n\t.check_events\t= sr_block_check_events,\n\t.free_disk\t= sr_free_disk,\n};\n\nstatic int sr_open(struct cdrom_device_info *cdi, int purpose)\n{\n\tstruct scsi_cd *cd = cdi->handle;\n\tstruct scsi_device *sdev = cd->device;\n\n\t \n\tif (!scsi_block_when_processing_errors(sdev))\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\n\nstatic void sr_release(struct cdrom_device_info *cdi)\n{\n}\n\nstatic int sr_probe(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct gendisk *disk;\n\tstruct scsi_cd *cd;\n\tint minor, error;\n\n\tscsi_autopm_get_device(sdev);\n\terror = -ENODEV;\n\tif (sdev->type != TYPE_ROM && sdev->type != TYPE_WORM)\n\t\tgoto fail;\n\n\terror = -ENOMEM;\n\tcd = kzalloc(sizeof(*cd), GFP_KERNEL);\n\tif (!cd)\n\t\tgoto fail;\n\n\tdisk = blk_mq_alloc_disk_for_queue(sdev->request_queue,\n\t\t\t\t\t   &sr_bio_compl_lkclass);\n\tif (!disk)\n\t\tgoto fail_free;\n\tmutex_init(&cd->lock);\n\n\tspin_lock(&sr_index_lock);\n\tminor = find_first_zero_bit(sr_index_bits, SR_DISKS);\n\tif (minor == SR_DISKS) {\n\t\tspin_unlock(&sr_index_lock);\n\t\terror = -EBUSY;\n\t\tgoto fail_put;\n\t}\n\t__set_bit(minor, sr_index_bits);\n\tspin_unlock(&sr_index_lock);\n\n\tdisk->major = SCSI_CDROM_MAJOR;\n\tdisk->first_minor = minor;\n\tdisk->minors = 1;\n\tsprintf(disk->disk_name, \"sr%d\", minor);\n\tdisk->fops = &sr_bdops;\n\tdisk->flags |= GENHD_FL_REMOVABLE | GENHD_FL_NO_PART;\n\tdisk->events = DISK_EVENT_MEDIA_CHANGE | DISK_EVENT_EJECT_REQUEST;\n\tdisk->event_flags = DISK_EVENT_FLAG_POLL | DISK_EVENT_FLAG_UEVENT |\n\t\t\t\tDISK_EVENT_FLAG_BLOCK_ON_EXCL_WRITE;\n\n\tblk_queue_rq_timeout(sdev->request_queue, SR_TIMEOUT);\n\n\tcd->device = sdev;\n\tcd->disk = disk;\n\tcd->capacity = 0x1fffff;\n\tcd->device->changed = 1;\t \n\tcd->media_present = 1;\n\tcd->use = 1;\n\tcd->readcd_known = 0;\n\tcd->readcd_cdda = 0;\n\n\tcd->cdi.ops = &sr_dops;\n\tcd->cdi.handle = cd;\n\tcd->cdi.mask = 0;\n\tcd->cdi.capacity = 1;\n\tsprintf(cd->cdi.name, \"sr%d\", minor);\n\n\tsdev->sector_size = 2048;\t \n\n\terror = -ENOMEM;\n\tif (get_capabilities(cd))\n\t\tgoto fail_minor;\n\tsr_vendor_init(cd);\n\n\tset_capacity(disk, cd->capacity);\n\tdisk->private_data = cd;\n\n\tif (register_cdrom(disk, &cd->cdi))\n\t\tgoto fail_minor;\n\n\t \n\tblk_pm_runtime_init(sdev->request_queue, dev);\n\n\tdev_set_drvdata(dev, cd);\n\tsr_revalidate_disk(cd);\n\n\terror = device_add_disk(&sdev->sdev_gendev, disk, NULL);\n\tif (error)\n\t\tgoto unregister_cdrom;\n\n\tsdev_printk(KERN_DEBUG, sdev,\n\t\t    \"Attached scsi CD-ROM %s\\n\", cd->cdi.name);\n\tscsi_autopm_put_device(cd->device);\n\n\treturn 0;\n\nunregister_cdrom:\n\tunregister_cdrom(&cd->cdi);\nfail_minor:\n\tspin_lock(&sr_index_lock);\n\tclear_bit(minor, sr_index_bits);\n\tspin_unlock(&sr_index_lock);\nfail_put:\n\tput_disk(disk);\n\tmutex_destroy(&cd->lock);\nfail_free:\n\tkfree(cd);\nfail:\n\tscsi_autopm_put_device(sdev);\n\treturn error;\n}\n\n\nstatic void get_sectorsize(struct scsi_cd *cd)\n{\n\tunsigned char cmd[10];\n\tunsigned char buffer[8];\n\tint the_result, retries = 3;\n\tint sector_size;\n\tstruct request_queue *queue;\n\n\tdo {\n\t\tcmd[0] = READ_CAPACITY;\n\t\tmemset((void *) &cmd[1], 0, 9);\n\t\tmemset(buffer, 0, sizeof(buffer));\n\n\t\t \n\t\tthe_result = scsi_execute_cmd(cd->device, cmd, REQ_OP_DRV_IN,\n\t\t\t\t\t      buffer, sizeof(buffer),\n\t\t\t\t\t      SR_TIMEOUT, MAX_RETRIES, NULL);\n\n\t\tretries--;\n\n\t} while (the_result && retries);\n\n\n\tif (the_result) {\n\t\tcd->capacity = 0x1fffff;\n\t\tsector_size = 2048;\t \n\t} else {\n\t\tlong last_written;\n\n\t\tcd->capacity = 1 + get_unaligned_be32(&buffer[0]);\n\t\t \n\t\tif (!cdrom_get_last_written(&cd->cdi, &last_written))\n\t\t\tcd->capacity = max_t(long, cd->capacity, last_written);\n\n\t\tsector_size = get_unaligned_be32(&buffer[4]);\n\t\tswitch (sector_size) {\n\t\t\t \n\t\tcase 0:\n\t\tcase 2340:\n\t\tcase 2352:\n\t\t\tsector_size = 2048;\n\t\t\tfallthrough;\n\t\tcase 2048:\n\t\t\tcd->capacity *= 4;\n\t\t\tfallthrough;\n\t\tcase 512:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t  \"unsupported sector size %d.\", sector_size);\n\t\t\tcd->capacity = 0;\n\t\t}\n\n\t\tcd->device->sector_size = sector_size;\n\n\t\t \n\t\tset_capacity(cd->disk, cd->capacity);\n\t}\n\n\tqueue = cd->device->request_queue;\n\tblk_queue_logical_block_size(queue, sector_size);\n\n\treturn;\n}\n\nstatic int get_capabilities(struct scsi_cd *cd)\n{\n\tunsigned char *buffer;\n\tstruct scsi_mode_data data;\n\tstruct scsi_sense_hdr sshdr;\n\tunsigned int ms_len = 128;\n\tint rc, n;\n\n\tstatic const char *loadmech[] =\n\t{\n\t\t\"caddy\",\n\t\t\"tray\",\n\t\t\"pop-up\",\n\t\t\"\",\n\t\t\"changer\",\n\t\t\"cartridge changer\",\n\t\t\"\",\n\t\t\"\"\n\t};\n\n\n\t \n\tbuffer = kmalloc(512, GFP_KERNEL);\n\tif (!buffer) {\n\t\tsr_printk(KERN_ERR, cd, \"out of memory.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tscsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr);\n\n\t \n\trc = scsi_mode_sense(cd->device, 0, 0x2a, 0, buffer, ms_len,\n\t\t\t     SR_TIMEOUT, 3, &data, NULL);\n\n\tif (rc < 0 || data.length > ms_len ||\n\t    data.header_length + data.block_descriptor_length > data.length) {\n\t\t \n\t\tcd->cdi.speed = 1;\n\t\tcd->cdi.mask |= (CDC_CD_R | CDC_CD_RW | CDC_DVD_R |\n\t\t\t\t CDC_DVD | CDC_DVD_RAM |\n\t\t\t\t CDC_SELECT_DISC | CDC_SELECT_SPEED |\n\t\t\t\t CDC_MRW | CDC_MRW_W | CDC_RAM);\n\t\tkfree(buffer);\n\t\tsr_printk(KERN_INFO, cd, \"scsi-1 drive\");\n\t\treturn 0;\n\t}\n\n\tn = data.header_length + data.block_descriptor_length;\n\tcd->cdi.speed = get_unaligned_be16(&buffer[n + 8]) / 176;\n\tcd->readcd_known = 1;\n\tcd->readcd_cdda = buffer[n + 5] & 0x01;\n\t \n\tsr_printk(KERN_INFO, cd,\n\t\t  \"scsi3-mmc drive: %dx/%dx %s%s%s%s%s%s\\n\",\n\t\t  get_unaligned_be16(&buffer[n + 14]) / 176,\n\t\t  cd->cdi.speed,\n\t\t  buffer[n + 3] & 0x01 ? \"writer \" : \"\",  \n\t\t  buffer[n + 3] & 0x20 ? \"dvd-ram \" : \"\",\n\t\t  buffer[n + 2] & 0x02 ? \"cd/rw \" : \"\",  \n\t\t  buffer[n + 4] & 0x20 ? \"xa/form2 \" : \"\",\t \n\t\t  buffer[n + 5] & 0x01 ? \"cdda \" : \"\",  \n\t\t  loadmech[buffer[n + 6] >> 5]);\n\tif ((buffer[n + 6] >> 5) == 0)\n\t\t \n\t\tcd->cdi.mask |= CDC_CLOSE_TRAY;\n\tif ((buffer[n + 2] & 0x8) == 0)\n\t\t \n\t\tcd->cdi.mask |= CDC_DVD;\n\tif ((buffer[n + 3] & 0x20) == 0)\n\t\t \n\t\tcd->cdi.mask |= CDC_DVD_RAM;\n\tif ((buffer[n + 3] & 0x10) == 0)\n\t\t \n\t\tcd->cdi.mask |= CDC_DVD_R;\n\tif ((buffer[n + 3] & 0x2) == 0)\n\t\t \n\t\tcd->cdi.mask |= CDC_CD_RW;\n\tif ((buffer[n + 3] & 0x1) == 0)\n\t\t \n\t\tcd->cdi.mask |= CDC_CD_R;\n\tif ((buffer[n + 6] & 0x8) == 0)\n\t\t \n\t\tcd->cdi.mask |= CDC_OPEN_TRAY;\n\n\tif ((buffer[n + 6] >> 5) == mechtype_individual_changer ||\n\t    (buffer[n + 6] >> 5) == mechtype_cartridge_changer)\n\t\tcd->cdi.capacity =\n\t\t    cdrom_number_of_slots(&cd->cdi);\n\tif (cd->cdi.capacity <= 1)\n\t\t \n\t\tcd->cdi.mask |= CDC_SELECT_DISC;\n\t \n\n\t \n\tif ((cd->cdi.mask & (CDC_DVD_RAM | CDC_MRW_W | CDC_RAM | CDC_CD_RW)) !=\n\t\t\t(CDC_DVD_RAM | CDC_MRW_W | CDC_RAM | CDC_CD_RW)) {\n\t\tcd->writeable = 1;\n\t}\n\n\tkfree(buffer);\n\treturn 0;\n}\n\n \nstatic int sr_packet(struct cdrom_device_info *cdi,\n\t\tstruct packet_command *cgc)\n{\n\tstruct scsi_cd *cd = cdi->handle;\n\tstruct scsi_device *sdev = cd->device;\n\n\tif (cgc->cmd[0] == GPCMD_READ_DISC_INFO && sdev->no_read_disc_info)\n\t\treturn -EDRIVE_CANT_DO_THIS;\n\n\tif (cgc->timeout <= 0)\n\t\tcgc->timeout = IOCTL_TIMEOUT;\n\n\tsr_do_ioctl(cd, cgc);\n\n\treturn cgc->stat;\n}\n\nstatic int sr_read_cdda_bpc(struct cdrom_device_info *cdi, void __user *ubuf,\n\t\tu32 lba, u32 nr, u8 *last_sense)\n{\n\tstruct gendisk *disk = cdi->disk;\n\tu32 len = nr * CD_FRAMESIZE_RAW;\n\tstruct scsi_cmnd *scmd;\n\tstruct request *rq;\n\tstruct bio *bio;\n\tint ret;\n\n\trq = scsi_alloc_request(disk->queue, REQ_OP_DRV_IN, 0);\n\tif (IS_ERR(rq))\n\t\treturn PTR_ERR(rq);\n\tscmd = blk_mq_rq_to_pdu(rq);\n\n\tret = blk_rq_map_user(disk->queue, rq, NULL, ubuf, len, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out_put_request;\n\n\tscmd->cmnd[0] = GPCMD_READ_CD;\n\tscmd->cmnd[1] = 1 << 2;\n\tscmd->cmnd[2] = (lba >> 24) & 0xff;\n\tscmd->cmnd[3] = (lba >> 16) & 0xff;\n\tscmd->cmnd[4] = (lba >>  8) & 0xff;\n\tscmd->cmnd[5] = lba & 0xff;\n\tscmd->cmnd[6] = (nr >> 16) & 0xff;\n\tscmd->cmnd[7] = (nr >>  8) & 0xff;\n\tscmd->cmnd[8] = nr & 0xff;\n\tscmd->cmnd[9] = 0xf8;\n\tscmd->cmd_len = 12;\n\trq->timeout = 60 * HZ;\n\tbio = rq->bio;\n\n\tblk_execute_rq(rq, false);\n\tif (scmd->result) {\n\t\tstruct scsi_sense_hdr sshdr;\n\n\t\tscsi_normalize_sense(scmd->sense_buffer, scmd->sense_len,\n\t\t\t\t     &sshdr);\n\t\t*last_sense = sshdr.sense_key;\n\t\tret = -EIO;\n\t}\n\n\tif (blk_rq_unmap_user(bio))\n\t\tret = -EFAULT;\nout_put_request:\n\tblk_mq_free_request(rq);\n\treturn ret;\n}\n\nstatic int sr_remove(struct device *dev)\n{\n\tstruct scsi_cd *cd = dev_get_drvdata(dev);\n\n\tscsi_autopm_get_device(cd->device);\n\n\tdel_gendisk(cd->disk);\n\tput_disk(cd->disk);\n\n\treturn 0;\n}\n\nstatic int __init init_sr(void)\n{\n\tint rc;\n\n\trc = register_blkdev(SCSI_CDROM_MAJOR, \"sr\");\n\tif (rc)\n\t\treturn rc;\n\trc = scsi_register_driver(&sr_template.gendrv);\n\tif (rc)\n\t\tunregister_blkdev(SCSI_CDROM_MAJOR, \"sr\");\n\n\treturn rc;\n}\n\nstatic void __exit exit_sr(void)\n{\n\tscsi_unregister_driver(&sr_template.gendrv);\n\tunregister_blkdev(SCSI_CDROM_MAJOR, \"sr\");\n}\n\nmodule_init(init_sr);\nmodule_exit(exit_sr);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}