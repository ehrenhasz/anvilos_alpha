{
  "module_name": "scsi_priv.h",
  "hash_id": "b8a4d6ce2493910f80fd6f85a29c33cf54b5df016945cc893a39acab472fd691",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_priv.h",
  "human_readable_source": " \n#ifndef _SCSI_PRIV_H\n#define _SCSI_PRIV_H\n\n#include <linux/device.h>\n#include <scsi/scsi_device.h>\n#include <linux/sbitmap.h>\n\nstruct bsg_device;\nstruct request_queue;\nstruct request;\nstruct scsi_cmnd;\nstruct scsi_device;\nstruct scsi_target;\nstruct scsi_host_template;\nstruct Scsi_Host;\nstruct scsi_nl_hdr;\n\n#define SCSI_CMD_RETRIES_NO_LIMIT -1\n\n \nenum scsi_ml_status {\n\tSCSIML_STAT_OK\t\t\t= 0x00,\n\tSCSIML_STAT_RESV_CONFLICT\t= 0x01,\t \n\tSCSIML_STAT_NOSPC\t\t= 0x02,\t \n\tSCSIML_STAT_MED_ERROR\t\t= 0x03,\t \n\tSCSIML_STAT_TGT_FAILURE\t\t= 0x04,\t \n\tSCSIML_STAT_DL_TIMEOUT\t\t= 0x05,  \n};\n\nstatic inline u8 scsi_ml_byte(int result)\n{\n\treturn (result >> 8) & 0xff;\n}\n\n \n#define SCSI_EH_ABORT_SCHEDULED\t0x0002\t \n\n#define SCSI_SENSE_VALID(scmd) \\\n\t(((scmd)->sense_buffer[0] & 0x70) == 0x70)\n\n \nextern int scsi_init_hosts(void);\nextern void scsi_exit_hosts(void);\n\n \nint scsi_init_sense_cache(struct Scsi_Host *shost);\nvoid scsi_init_command(struct scsi_device *dev, struct scsi_cmnd *cmd);\n#ifdef CONFIG_SCSI_LOGGING\nvoid scsi_log_send(struct scsi_cmnd *cmd);\nvoid scsi_log_completion(struct scsi_cmnd *cmd, int disposition);\n#else\nstatic inline void scsi_log_send(struct scsi_cmnd *cmd) \n\t{ };\nstatic inline void scsi_log_completion(struct scsi_cmnd *cmd, int disposition)\n\t{ };\n#endif\n\n \n\n \nenum scsi_devinfo_key {\n\tSCSI_DEVINFO_GLOBAL = 0,\n\tSCSI_DEVINFO_SPI,\n};\n\nextern blist_flags_t scsi_get_device_flags(struct scsi_device *sdev,\n\t\t\t\t\t   const unsigned char *vendor,\n\t\t\t\t\t   const unsigned char *model);\nextern blist_flags_t scsi_get_device_flags_keyed(struct scsi_device *sdev,\n\t\t\t\t\t\t const unsigned char *vendor,\n\t\t\t\t\t\t const unsigned char *model,\n\t\t\t\t\t\t enum scsi_devinfo_key key);\nextern int scsi_dev_info_list_add_keyed(int compatible, char *vendor,\n\t\t\t\t\tchar *model, char *strflags,\n\t\t\t\t\tblist_flags_t flags,\n\t\t\t\t\tenum scsi_devinfo_key key);\nextern int scsi_dev_info_list_del_keyed(char *vendor, char *model,\n\t\t\t\t\tenum scsi_devinfo_key key);\nextern int scsi_dev_info_add_list(enum scsi_devinfo_key key, const char *name);\nextern int scsi_dev_info_remove_list(enum scsi_devinfo_key key);\n\nextern int __init scsi_init_devinfo(void);\nextern void scsi_exit_devinfo(void);\n\n \nextern void scmd_eh_abort_handler(struct work_struct *work);\nextern enum blk_eh_timer_return scsi_timeout(struct request *req);\nextern int scsi_error_handler(void *host);\nextern enum scsi_disposition scsi_decide_disposition(struct scsi_cmnd *cmd);\nextern void scsi_eh_wakeup(struct Scsi_Host *shost);\nextern void scsi_eh_scmd_add(struct scsi_cmnd *);\nvoid scsi_eh_ready_devs(struct Scsi_Host *shost,\n\t\t\tstruct list_head *work_q,\n\t\t\tstruct list_head *done_q);\nint scsi_eh_get_sense(struct list_head *work_q,\n\t\t      struct list_head *done_q);\nbool scsi_noretry_cmd(struct scsi_cmnd *scmd);\nvoid scsi_eh_done(struct scsi_cmnd *scmd);\n\n \nextern void scsi_device_unbusy(struct scsi_device *sdev, struct scsi_cmnd *cmd);\nextern void scsi_queue_insert(struct scsi_cmnd *cmd, int reason);\nextern void scsi_io_completion(struct scsi_cmnd *, unsigned int);\nextern void scsi_run_host_queues(struct Scsi_Host *shost);\nextern void scsi_requeue_run_queue(struct work_struct *work);\nextern void scsi_start_queue(struct scsi_device *sdev);\nextern int scsi_mq_setup_tags(struct Scsi_Host *shost);\nextern void scsi_mq_free_tags(struct kref *kref);\nextern void scsi_exit_queue(void);\nextern void scsi_evt_thread(struct work_struct *work);\n\n \n#ifdef CONFIG_SCSI_PROC_FS\nextern int scsi_proc_hostdir_add(const struct scsi_host_template *);\nextern void scsi_proc_hostdir_rm(const struct scsi_host_template *);\nextern void scsi_proc_host_add(struct Scsi_Host *);\nextern void scsi_proc_host_rm(struct Scsi_Host *);\nextern int scsi_init_procfs(void);\nextern void scsi_exit_procfs(void);\n#else\n# define scsi_proc_hostdir_add(sht)\t0\n# define scsi_proc_hostdir_rm(sht)\tdo { } while (0)\n# define scsi_proc_host_add(shost)\tdo { } while (0)\n# define scsi_proc_host_rm(shost)\tdo { } while (0)\n# define scsi_init_procfs()\t\t(0)\n# define scsi_exit_procfs()\t\tdo { } while (0)\n#endif  \n\n \nvoid scsi_enable_async_suspend(struct device *dev);\nextern int scsi_complete_async_scans(void);\nextern int scsi_scan_host_selected(struct Scsi_Host *, unsigned int,\n\t\t\t\t   unsigned int, u64, enum scsi_scan_mode);\nextern void scsi_forget_host(struct Scsi_Host *);\n\n \n#ifdef CONFIG_SYSCTL\nextern int scsi_init_sysctl(void);\nextern void scsi_exit_sysctl(void);\n#else\n# define scsi_init_sysctl()\t\t(0)\n# define scsi_exit_sysctl()\t\tdo { } while (0)\n#endif  \n\n \nextern int scsi_sysfs_add_sdev(struct scsi_device *);\nextern int scsi_sysfs_add_host(struct Scsi_Host *);\nextern int scsi_sysfs_register(void);\nextern void scsi_sysfs_unregister(void);\nextern void scsi_sysfs_device_initialize(struct scsi_device *);\nextern struct scsi_transport_template blank_transport_template;\nextern void __scsi_remove_device(struct scsi_device *);\n\nextern struct bus_type scsi_bus_type;\nextern const struct attribute_group *scsi_shost_groups[];\n\n \n#ifdef CONFIG_SCSI_NETLINK\nextern void scsi_netlink_init(void);\nextern void scsi_netlink_exit(void);\nextern struct sock *scsi_nl_sock;\n#else\nstatic inline void scsi_netlink_init(void) {}\nstatic inline void scsi_netlink_exit(void) {}\n#endif\n\n \n#ifdef CONFIG_PM\nextern const struct dev_pm_ops scsi_bus_pm_ops;\n\nextern void scsi_autopm_get_target(struct scsi_target *);\nextern void scsi_autopm_put_target(struct scsi_target *);\nextern int scsi_autopm_get_host(struct Scsi_Host *);\nextern void scsi_autopm_put_host(struct Scsi_Host *);\n#else\nstatic inline void scsi_autopm_get_target(struct scsi_target *t) {}\nstatic inline void scsi_autopm_put_target(struct scsi_target *t) {}\nstatic inline int scsi_autopm_get_host(struct Scsi_Host *h) { return 0; }\nstatic inline void scsi_autopm_put_host(struct Scsi_Host *h) {}\n#endif  \n\n \n#ifdef CONFIG_SCSI_DH\nvoid scsi_dh_add_device(struct scsi_device *sdev);\nvoid scsi_dh_release_device(struct scsi_device *sdev);\n#else\nstatic inline void scsi_dh_add_device(struct scsi_device *sdev) { }\nstatic inline void scsi_dh_release_device(struct scsi_device *sdev) { }\n#endif\n\nstruct bsg_device *scsi_bsg_register_queue(struct scsi_device *sdev);\n\nextern int scsi_device_max_queue_depth(struct scsi_device *sdev);\n\n \n\n#define SCSI_DEVICE_BLOCK_MAX_TIMEOUT\t600\t \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}