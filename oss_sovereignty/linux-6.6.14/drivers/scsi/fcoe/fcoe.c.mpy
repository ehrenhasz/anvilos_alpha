{
  "module_name": "fcoe.c",
  "hash_id": "b40384b4ed643b7846b7e5e819c5505f85a72ad0d0ede7c850e1c0065e4354a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/fcoe/fcoe.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/cpu.h>\n#include <linux/fs.h>\n#include <linux/sysfs.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <net/dcbnl.h>\n#include <net/dcbevent.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsicam.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_fc.h>\n#include <net/rtnetlink.h>\n\n#include <scsi/fc/fc_encaps.h>\n#include <scsi/fc/fc_fip.h>\n#include <scsi/fc/fc_fcoe.h>\n\n#include <scsi/libfc.h>\n#include <scsi/fc_frame.h>\n#include <scsi/libfcoe.h>\n\n#include \"fcoe.h\"\n\nMODULE_AUTHOR(\"Open-FCoE.org\");\nMODULE_DESCRIPTION(\"FCoE\");\nMODULE_LICENSE(\"GPL v2\");\n\n \nstatic unsigned int fcoe_ddp_min = 4096;\nmodule_param_named(ddp_min, fcoe_ddp_min, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ddp_min, \"Minimum I/O size in bytes for \"\t\\\n\t\t \"Direct Data Placement (DDP).\");\n\nunsigned int fcoe_debug_logging;\nmodule_param_named(debug_logging, fcoe_debug_logging, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(debug_logging, \"a bit mask of logging levels\");\n\nstatic unsigned int fcoe_e_d_tov = 2 * 1000;\nmodule_param_named(e_d_tov, fcoe_e_d_tov, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(e_d_tov, \"E_D_TOV in ms, default 2000\");\n\nstatic unsigned int fcoe_r_a_tov = 2 * 2 * 1000;\nmodule_param_named(r_a_tov, fcoe_r_a_tov, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(r_a_tov, \"R_A_TOV in ms, default 4000\");\n\nstatic DEFINE_MUTEX(fcoe_config_mutex);\n\nstatic struct workqueue_struct *fcoe_wq;\n\n \n \nstatic LIST_HEAD(fcoe_hostlist);\nstatic DEFINE_PER_CPU(struct fcoe_percpu_s, fcoe_percpu);\n\n \nstatic int fcoe_reset(struct Scsi_Host *);\nstatic int fcoe_xmit(struct fc_lport *, struct fc_frame *);\nstatic int fcoe_rcv(struct sk_buff *, struct net_device *,\n\t\t    struct packet_type *, struct net_device *);\nstatic void fcoe_percpu_clean(struct fc_lport *);\nstatic int fcoe_link_ok(struct fc_lport *);\n\nstatic struct fc_lport *fcoe_hostlist_lookup(const struct net_device *);\nstatic int fcoe_hostlist_add(const struct fc_lport *);\nstatic void fcoe_hostlist_del(const struct fc_lport *);\n\nstatic int fcoe_device_notification(struct notifier_block *, ulong, void *);\nstatic void fcoe_dev_setup(void);\nstatic void fcoe_dev_cleanup(void);\nstatic struct fcoe_interface\n*fcoe_hostlist_lookup_port(const struct net_device *);\n\nstatic int fcoe_fip_recv(struct sk_buff *, struct net_device *,\n\t\t\t struct packet_type *, struct net_device *);\nstatic int fcoe_fip_vlan_recv(struct sk_buff *, struct net_device *,\n\t\t\t      struct packet_type *, struct net_device *);\n\nstatic void fcoe_fip_send(struct fcoe_ctlr *, struct sk_buff *);\nstatic void fcoe_update_src_mac(struct fc_lport *, u8 *);\nstatic u8 *fcoe_get_src_mac(struct fc_lport *);\nstatic void fcoe_destroy_work(struct work_struct *);\n\nstatic int fcoe_ddp_setup(struct fc_lport *, u16, struct scatterlist *,\n\t\t\t  unsigned int);\nstatic int fcoe_ddp_done(struct fc_lport *, u16);\nstatic int fcoe_ddp_target(struct fc_lport *, u16, struct scatterlist *,\n\t\t\t   unsigned int);\nstatic int fcoe_dcb_app_notification(struct notifier_block *notifier,\n\t\t\t\t     ulong event, void *ptr);\n\nstatic bool fcoe_match(struct net_device *netdev);\nstatic int fcoe_create(struct net_device *netdev, enum fip_mode fip_mode);\nstatic int fcoe_destroy(struct net_device *netdev);\nstatic int fcoe_enable(struct net_device *netdev);\nstatic int fcoe_disable(struct net_device *netdev);\n\n \nstatic int fcoe_ctlr_alloc(struct net_device *netdev);\nstatic int fcoe_ctlr_enabled(struct fcoe_ctlr_device *cdev);\nstatic void fcoe_ctlr_mode(struct fcoe_ctlr_device *ctlr_dev);\n\nstatic struct fc_seq *fcoe_elsct_send(struct fc_lport *,\n\t\t\t\t      u32 did, struct fc_frame *,\n\t\t\t\t      unsigned int op,\n\t\t\t\t      void (*resp)(struct fc_seq *,\n\t\t\t\t\t\t   struct fc_frame *,\n\t\t\t\t\t\t   void *),\n\t\t\t\t      void *, u32 timeout);\nstatic void fcoe_recv_frame(struct sk_buff *skb);\n\n \nstatic struct notifier_block fcoe_notifier = {\n\t.notifier_call = fcoe_device_notification,\n};\n\n \nstatic struct notifier_block dcb_notifier = {\n\t.notifier_call = fcoe_dcb_app_notification,\n};\n\nstatic struct scsi_transport_template *fcoe_nport_scsi_transport;\nstatic struct scsi_transport_template *fcoe_vport_scsi_transport;\n\nstatic int fcoe_vport_destroy(struct fc_vport *);\nstatic int fcoe_vport_create(struct fc_vport *, bool disabled);\nstatic int fcoe_vport_disable(struct fc_vport *, bool disable);\nstatic void fcoe_set_vport_symbolic_name(struct fc_vport *);\nstatic void fcoe_set_port_id(struct fc_lport *, u32, struct fc_frame *);\nstatic void fcoe_fcf_get_vlan_id(struct fcoe_fcf_device *);\nstatic void fcoe_vport_remove(struct fc_lport *);\n\nstatic struct fcoe_sysfs_function_template fcoe_sysfs_templ = {\n\t.set_fcoe_ctlr_mode = fcoe_ctlr_mode,\n\t.set_fcoe_ctlr_enabled = fcoe_ctlr_enabled,\n\t.get_fcoe_ctlr_link_fail = fcoe_ctlr_get_lesb,\n\t.get_fcoe_ctlr_vlink_fail = fcoe_ctlr_get_lesb,\n\t.get_fcoe_ctlr_miss_fka = fcoe_ctlr_get_lesb,\n\t.get_fcoe_ctlr_symb_err = fcoe_ctlr_get_lesb,\n\t.get_fcoe_ctlr_err_block = fcoe_ctlr_get_lesb,\n\t.get_fcoe_ctlr_fcs_error = fcoe_ctlr_get_lesb,\n\n\t.get_fcoe_fcf_selected = fcoe_fcf_get_selected,\n\t.get_fcoe_fcf_vlan_id = fcoe_fcf_get_vlan_id,\n};\n\nstatic struct libfc_function_template fcoe_libfc_fcn_templ = {\n\t.frame_send = fcoe_xmit,\n\t.ddp_setup = fcoe_ddp_setup,\n\t.ddp_done = fcoe_ddp_done,\n\t.ddp_target = fcoe_ddp_target,\n\t.elsct_send = fcoe_elsct_send,\n\t.get_lesb = fcoe_get_lesb,\n\t.lport_set_port_id = fcoe_set_port_id,\n};\n\nstatic struct fc_function_template fcoe_nport_fc_functions = {\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_active_fc4s = 1,\n\t.show_host_maxframe_size = 1,\n\t.show_host_serial_number = 1,\n\t.show_host_manufacturer = 1,\n\t.show_host_model = 1,\n\t.show_host_model_description = 1,\n\t.show_host_hardware_version = 1,\n\t.show_host_driver_version = 1,\n\t.show_host_firmware_version = 1,\n\t.show_host_optionrom_version = 1,\n\n\t.show_host_port_id = 1,\n\t.show_host_supported_speeds = 1,\n\t.get_host_speed = fc_get_host_speed,\n\t.show_host_speed = 1,\n\t.show_host_port_type = 1,\n\t.get_host_port_state = fc_get_host_port_state,\n\t.show_host_port_state = 1,\n\t.show_host_symbolic_name = 1,\n\n\t.dd_fcrport_size = sizeof(struct fc_rport_libfc_priv),\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\n\t.show_host_fabric_name = 1,\n\t.show_starget_node_name = 1,\n\t.show_starget_port_name = 1,\n\t.show_starget_port_id = 1,\n\t.set_rport_dev_loss_tmo = fc_set_rport_loss_tmo,\n\t.show_rport_dev_loss_tmo = 1,\n\t.get_fc_host_stats = fc_get_host_stats,\n\t.issue_fc_host_lip = fcoe_reset,\n\n\t.terminate_rport_io = fc_rport_terminate_io,\n\n\t.vport_create = fcoe_vport_create,\n\t.vport_delete = fcoe_vport_destroy,\n\t.vport_disable = fcoe_vport_disable,\n\t.set_vport_symbolic_name = fcoe_set_vport_symbolic_name,\n\n\t.bsg_request = fc_lport_bsg_request,\n};\n\nstatic struct fc_function_template fcoe_vport_fc_functions = {\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_active_fc4s = 1,\n\t.show_host_maxframe_size = 1,\n\t.show_host_serial_number = 1,\n\t.show_host_manufacturer = 1,\n\t.show_host_model = 1,\n\t.show_host_model_description = 1,\n\t.show_host_hardware_version = 1,\n\t.show_host_driver_version = 1,\n\t.show_host_firmware_version = 1,\n\t.show_host_optionrom_version = 1,\n\n\t.show_host_port_id = 1,\n\t.show_host_supported_speeds = 1,\n\t.get_host_speed = fc_get_host_speed,\n\t.show_host_speed = 1,\n\t.show_host_port_type = 1,\n\t.get_host_port_state = fc_get_host_port_state,\n\t.show_host_port_state = 1,\n\t.show_host_symbolic_name = 1,\n\n\t.dd_fcrport_size = sizeof(struct fc_rport_libfc_priv),\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\n\t.show_host_fabric_name = 1,\n\t.show_starget_node_name = 1,\n\t.show_starget_port_name = 1,\n\t.show_starget_port_id = 1,\n\t.set_rport_dev_loss_tmo = fc_set_rport_loss_tmo,\n\t.show_rport_dev_loss_tmo = 1,\n\t.get_fc_host_stats = fc_get_host_stats,\n\t.issue_fc_host_lip = fcoe_reset,\n\n\t.terminate_rport_io = fc_rport_terminate_io,\n\n\t.bsg_request = fc_lport_bsg_request,\n};\n\nstatic const struct scsi_host_template fcoe_shost_template = {\n\t.module = THIS_MODULE,\n\t.name = \"FCoE Driver\",\n\t.proc_name = FCOE_NAME,\n\t.queuecommand = fc_queuecommand,\n\t.eh_timed_out = fc_eh_timed_out,\n\t.eh_abort_handler = fc_eh_abort,\n\t.eh_device_reset_handler = fc_eh_device_reset,\n\t.eh_host_reset_handler = fc_eh_host_reset,\n\t.slave_alloc = fc_slave_alloc,\n\t.change_queue_depth = scsi_change_queue_depth,\n\t.this_id = -1,\n\t.cmd_per_lun = 3,\n\t.can_queue = FCOE_MAX_OUTSTANDING_COMMANDS,\n\t.sg_tablesize = SG_ALL,\n\t.max_sectors = 0xffff,\n\t.track_queue_depth = 1,\n\t.cmd_size = sizeof(struct libfc_cmd_priv),\n};\n\n \nstatic int fcoe_interface_setup(struct fcoe_interface *fcoe,\n\t\t\t\tstruct net_device *netdev)\n{\n\tstruct fcoe_ctlr *fip = fcoe_to_ctlr(fcoe);\n\tstruct netdev_hw_addr *ha;\n\tstruct net_device *real_dev;\n\tstatic const u8 flogi_maddr[ETH_ALEN] = FC_FCOE_FLOGI_MAC;\n\tconst struct net_device_ops *ops;\n\n\tfcoe->netdev = netdev;\n\n\t \n\tops = netdev->netdev_ops;\n\tif (ops->ndo_fcoe_enable) {\n\t\tif (ops->ndo_fcoe_enable(netdev))\n\t\t\tFCOE_NETDEV_DBG(netdev, \"Failed to enable FCoE\"\n\t\t\t\t\t\" specific feature for LLD.\\n\");\n\t}\n\n\t \n\tif (netif_is_bond_master(netdev)) {\n\t\tFCOE_NETDEV_DBG(netdev, \"Bonded interfaces not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\treal_dev = is_vlan_dev(netdev) ? vlan_dev_real_dev(netdev) : netdev;\n\tfcoe->realdev = real_dev;\n\trcu_read_lock();\n\tfor_each_dev_addr(real_dev, ha) {\n\t\tif ((ha->type == NETDEV_HW_ADDR_T_SAN) &&\n\t\t    (is_valid_ether_addr(ha->addr))) {\n\t\t\tmemcpy(fip->ctl_src_addr, ha->addr, ETH_ALEN);\n\t\t\tfip->spma = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t \n\tif (!fip->spma)\n\t\tmemcpy(fip->ctl_src_addr, netdev->dev_addr, netdev->addr_len);\n\n\t \n\tdev_uc_add(netdev, flogi_maddr);\n\tif (fip->spma)\n\t\tdev_uc_add(netdev, fip->ctl_src_addr);\n\tif (fip->mode == FIP_MODE_VN2VN) {\n\t\tdev_mc_add(netdev, FIP_ALL_VN2VN_MACS);\n\t\tdev_mc_add(netdev, FIP_ALL_P2P_MACS);\n\t} else\n\t\tdev_mc_add(netdev, FIP_ALL_ENODE_MACS);\n\n\t \n\tfcoe->fcoe_packet_type.func = fcoe_rcv;\n\tfcoe->fcoe_packet_type.type = htons(ETH_P_FCOE);\n\tfcoe->fcoe_packet_type.dev = netdev;\n\tdev_add_pack(&fcoe->fcoe_packet_type);\n\n\tfcoe->fip_packet_type.func = fcoe_fip_recv;\n\tfcoe->fip_packet_type.type = htons(ETH_P_FIP);\n\tfcoe->fip_packet_type.dev = netdev;\n\tdev_add_pack(&fcoe->fip_packet_type);\n\n\tif (netdev != real_dev) {\n\t\tfcoe->fip_vlan_packet_type.func = fcoe_fip_vlan_recv;\n\t\tfcoe->fip_vlan_packet_type.type = htons(ETH_P_FIP);\n\t\tfcoe->fip_vlan_packet_type.dev = real_dev;\n\t\tdev_add_pack(&fcoe->fip_vlan_packet_type);\n\t}\n\treturn 0;\n}\n\n \nstatic struct fcoe_interface *fcoe_interface_create(struct net_device *netdev,\n\t\t\t\t\t\t    enum fip_mode fip_mode)\n{\n\tstruct fcoe_ctlr_device *ctlr_dev;\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fcoe_interface *fcoe;\n\tint size;\n\tint err;\n\n\tif (!try_module_get(THIS_MODULE)) {\n\t\tFCOE_NETDEV_DBG(netdev,\n\t\t\t\t\"Could not get a reference to the module\\n\");\n\t\tfcoe = ERR_PTR(-EBUSY);\n\t\tgoto out;\n\t}\n\n\tsize = sizeof(struct fcoe_ctlr) + sizeof(struct fcoe_interface);\n\tctlr_dev = fcoe_ctlr_device_add(&netdev->dev, &fcoe_sysfs_templ,\n\t\t\t\t\tsize);\n\tif (!ctlr_dev) {\n\t\tFCOE_DBG(\"Failed to add fcoe_ctlr_device\\n\");\n\t\tfcoe = ERR_PTR(-ENOMEM);\n\t\tgoto out_putmod;\n\t}\n\n\tctlr = fcoe_ctlr_device_priv(ctlr_dev);\n\tctlr->cdev = ctlr_dev;\n\tfcoe = fcoe_ctlr_priv(ctlr);\n\n\tdev_hold(netdev);\n\n\t \n\tfcoe_ctlr_init(ctlr, fip_mode);\n\tctlr->send = fcoe_fip_send;\n\tctlr->update_mac = fcoe_update_src_mac;\n\tctlr->get_src_addr = fcoe_get_src_mac;\n\n\terr = fcoe_interface_setup(fcoe, netdev);\n\tif (err) {\n\t\tfcoe_ctlr_destroy(ctlr);\n\t\tfcoe_ctlr_device_delete(ctlr_dev);\n\t\tdev_put(netdev);\n\t\tfcoe = ERR_PTR(err);\n\t\tgoto out_putmod;\n\t}\n\n\tgoto out;\n\nout_putmod:\n\tmodule_put(THIS_MODULE);\nout:\n\treturn fcoe;\n}\n\n \nstatic void fcoe_interface_remove(struct fcoe_interface *fcoe)\n{\n\tstruct net_device *netdev = fcoe->netdev;\n\tstruct fcoe_ctlr *fip = fcoe_to_ctlr(fcoe);\n\tstatic const u8 flogi_maddr[ETH_ALEN] = FC_FCOE_FLOGI_MAC;\n\tconst struct net_device_ops *ops;\n\n\t \n\t__dev_remove_pack(&fcoe->fcoe_packet_type);\n\t__dev_remove_pack(&fcoe->fip_packet_type);\n\tif (netdev != fcoe->realdev)\n\t\t__dev_remove_pack(&fcoe->fip_vlan_packet_type);\n\tsynchronize_net();\n\n\t \n\tdev_uc_del(netdev, flogi_maddr);\n\tif (fip->spma)\n\t\tdev_uc_del(netdev, fip->ctl_src_addr);\n\tif (fip->mode == FIP_MODE_VN2VN) {\n\t\tdev_mc_del(netdev, FIP_ALL_VN2VN_MACS);\n\t\tdev_mc_del(netdev, FIP_ALL_P2P_MACS);\n\t} else\n\t\tdev_mc_del(netdev, FIP_ALL_ENODE_MACS);\n\n\t \n\tops = netdev->netdev_ops;\n\tif (ops->ndo_fcoe_disable) {\n\t\tif (ops->ndo_fcoe_disable(netdev))\n\t\t\tFCOE_NETDEV_DBG(netdev, \"Failed to disable FCoE\"\n\t\t\t\t\t\" specific feature for LLD.\\n\");\n\t}\n\tfcoe->removed = 1;\n}\n\n\n \nstatic void fcoe_interface_cleanup(struct fcoe_interface *fcoe)\n{\n\tstruct net_device *netdev = fcoe->netdev;\n\tstruct fcoe_ctlr *fip = fcoe_to_ctlr(fcoe);\n\n\t \n\t \n\tfcoe_ctlr_destroy(fip);\n\tscsi_host_put(fip->lp->host);\n\tdev_put(netdev);\n\tmodule_put(THIS_MODULE);\n}\n\n \nstatic int fcoe_fip_recv(struct sk_buff *skb, struct net_device *netdev,\n\t\t\t struct packet_type *ptype,\n\t\t\t struct net_device *orig_dev)\n{\n\tstruct fcoe_interface *fcoe;\n\tstruct fcoe_ctlr *ctlr;\n\n\tfcoe = container_of(ptype, struct fcoe_interface, fip_packet_type);\n\tctlr = fcoe_to_ctlr(fcoe);\n\tfcoe_ctlr_recv(ctlr, skb);\n\treturn 0;\n}\n\n \nstatic int fcoe_fip_vlan_recv(struct sk_buff *skb, struct net_device *netdev,\n\t\t\t      struct packet_type *ptype,\n\t\t\t      struct net_device *orig_dev)\n{\n\tstruct fcoe_interface *fcoe;\n\tstruct fcoe_ctlr *ctlr;\n\n\tfcoe = container_of(ptype, struct fcoe_interface, fip_vlan_packet_type);\n\tctlr = fcoe_to_ctlr(fcoe);\n\tfcoe_ctlr_recv(ctlr, skb);\n\treturn 0;\n}\n\n \nstatic void fcoe_port_send(struct fcoe_port *port, struct sk_buff *skb)\n{\n\tif (port->fcoe_pending_queue.qlen)\n\t\tfcoe_check_wait_queue(port->lport, skb);\n\telse if (fcoe_start_io(skb))\n\t\tfcoe_check_wait_queue(port->lport, skb);\n}\n\n \nstatic void fcoe_fip_send(struct fcoe_ctlr *fip, struct sk_buff *skb)\n{\n\tstruct fcoe_interface *fcoe = fcoe_from_ctlr(fip);\n\tstruct fip_frame {\n\t\tstruct ethhdr eth;\n\t\tstruct fip_header fip;\n\t} __packed *frame;\n\n\t \n\tframe = (struct fip_frame *)skb->data;\n\tif (ntohs(frame->eth.h_proto) == ETH_P_FIP &&\n\t    ntohs(frame->fip.fip_op) == FIP_OP_VLAN &&\n\t    fcoe->realdev != fcoe->netdev)\n\t\tskb->dev = fcoe->realdev;\n\telse\n\t\tskb->dev = fcoe->netdev;\n\tfcoe_port_send(lport_priv(fip->lp), skb);\n}\n\n \nstatic void fcoe_update_src_mac(struct fc_lport *lport, u8 *addr)\n{\n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct fcoe_interface *fcoe = port->priv;\n\n\tif (!is_zero_ether_addr(port->data_src_addr))\n\t\tdev_uc_del(fcoe->netdev, port->data_src_addr);\n\tif (!is_zero_ether_addr(addr))\n\t\tdev_uc_add(fcoe->netdev, addr);\n\tmemcpy(port->data_src_addr, addr, ETH_ALEN);\n}\n\n \nstatic u8 *fcoe_get_src_mac(struct fc_lport *lport)\n{\n\tstruct fcoe_port *port = lport_priv(lport);\n\n\treturn port->data_src_addr;\n}\n\n \nstatic int fcoe_lport_config(struct fc_lport *lport)\n{\n\tlport->link_up = 0;\n\tlport->qfull = 0;\n\tlport->max_retry_count = 3;\n\tlport->max_rport_retry_count = 3;\n\tlport->e_d_tov = fcoe_e_d_tov;\n\tlport->r_a_tov = fcoe_r_a_tov;\n\tlport->service_params = (FCP_SPPF_INIT_FCN | FCP_SPPF_RD_XRDY_DIS |\n\t\t\t\t FCP_SPPF_RETRY | FCP_SPPF_CONF_COMPL);\n\tlport->does_npiv = 1;\n\n\tfc_lport_init_stats(lport);\n\n\t \n\tfc_lport_config(lport);\n\n\t \n\tlport->crc_offload = 0;\n\tlport->seq_offload = 0;\n\tlport->lro_enabled = 0;\n\tlport->lro_xid = 0;\n\tlport->lso_max = 0;\n\n\treturn 0;\n}\n\n \nstatic void fcoe_netdev_features_change(struct fc_lport *lport,\n\t\t\t\t\tstruct net_device *netdev)\n{\n\tmutex_lock(&lport->lp_mutex);\n\n\tif (netdev->features & NETIF_F_SG)\n\t\tlport->sg_supp = 1;\n\telse\n\t\tlport->sg_supp = 0;\n\n\tif (netdev->features & NETIF_F_FCOE_CRC) {\n\t\tlport->crc_offload = 1;\n\t\tFCOE_NETDEV_DBG(netdev, \"Supports FCCRC offload\\n\");\n\t} else {\n\t\tlport->crc_offload = 0;\n\t}\n\n\tif (netdev->features & NETIF_F_FSO) {\n\t\tlport->seq_offload = 1;\n\t\tlport->lso_max = min(netdev->gso_max_size, GSO_LEGACY_MAX_SIZE);\n\t\tFCOE_NETDEV_DBG(netdev, \"Supports LSO for max len 0x%x\\n\",\n\t\t\t\tlport->lso_max);\n\t} else {\n\t\tlport->seq_offload = 0;\n\t\tlport->lso_max = 0;\n\t}\n\n\tif (netdev->fcoe_ddp_xid) {\n\t\tlport->lro_enabled = 1;\n\t\tlport->lro_xid = netdev->fcoe_ddp_xid;\n\t\tFCOE_NETDEV_DBG(netdev, \"Supports LRO for max xid 0x%x\\n\",\n\t\t\t\tlport->lro_xid);\n\t} else {\n\t\tlport->lro_enabled = 0;\n\t\tlport->lro_xid = 0;\n\t}\n\n\tmutex_unlock(&lport->lp_mutex);\n}\n\n \nstatic int fcoe_netdev_config(struct fc_lport *lport, struct net_device *netdev)\n{\n\tu32 mfs;\n\tu64 wwnn, wwpn;\n\tstruct fcoe_interface *fcoe;\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fcoe_port *port;\n\n\t \n\tport = lport_priv(lport);\n\tfcoe = port->priv;\n\tctlr = fcoe_to_ctlr(fcoe);\n\n\t \n\tif (is_vlan_dev(netdev))\n\t\tlport->vlan = vlan_dev_vlan_id(netdev);\n\telse\n\t\tlport->vlan = 0;\n\n\t \n\tmfs = netdev->mtu;\n\tif (netdev->features & NETIF_F_FCOE_MTU) {\n\t\tmfs = FCOE_MTU;\n\t\tFCOE_NETDEV_DBG(netdev, \"Supports FCOE_MTU of %d bytes\\n\", mfs);\n\t}\n\tmfs -= (sizeof(struct fcoe_hdr) + sizeof(struct fcoe_crc_eof));\n\tif (fc_set_mfs(lport, mfs))\n\t\treturn -EINVAL;\n\n\t \n\tfcoe_netdev_features_change(lport, netdev);\n\n\tskb_queue_head_init(&port->fcoe_pending_queue);\n\tport->fcoe_pending_queue_active = 0;\n\ttimer_setup(&port->timer, fcoe_queue_timer, 0);\n\n\tfcoe_link_speed_update(lport);\n\n\tif (!lport->vport) {\n\t\tif (fcoe_get_wwn(netdev, &wwnn, NETDEV_FCOE_WWNN))\n\t\t\twwnn = fcoe_wwn_from_mac(ctlr->ctl_src_addr, 1, 0);\n\t\tfc_set_wwnn(lport, wwnn);\n\t\tif (fcoe_get_wwn(netdev, &wwpn, NETDEV_FCOE_WWPN))\n\t\t\twwpn = fcoe_wwn_from_mac(ctlr->ctl_src_addr,\n\t\t\t\t\t\t 2, 0);\n\t\tfc_set_wwpn(lport, wwpn);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fcoe_shost_config(struct fc_lport *lport, struct device *dev)\n{\n\tint rc = 0;\n\n\t \n\tlport->host->max_lun = FCOE_MAX_LUN;\n\tlport->host->max_id = FCOE_MAX_FCP_TARGET;\n\tlport->host->max_channel = 0;\n\tlport->host->max_cmd_len = FCOE_MAX_CMD_LEN;\n\n\tif (lport->vport)\n\t\tlport->host->transportt = fcoe_vport_scsi_transport;\n\telse\n\t\tlport->host->transportt = fcoe_nport_scsi_transport;\n\n\t \n\trc = scsi_add_host(lport->host, dev);\n\tif (rc) {\n\t\tFCOE_NETDEV_DBG(fcoe_netdev(lport), \"fcoe_shost_config: \"\n\t\t\t\t\"error on scsi_add_host\\n\");\n\t\treturn rc;\n\t}\n\n\tif (!lport->vport)\n\t\tfc_host_max_npiv_vports(lport->host) = USHRT_MAX;\n\n\tsnprintf(fc_host_symbolic_name(lport->host), FC_SYMBOLIC_NAME_SIZE,\n\t\t \"%s v%s over %s\", FCOE_NAME, FCOE_VERSION,\n\t\t fcoe_netdev(lport)->name);\n\n\treturn 0;\n}\n\n\n \nstatic void fcoe_fdmi_info(struct fc_lport *lport, struct net_device *netdev)\n{\n\tstruct fcoe_interface *fcoe;\n\tstruct fcoe_port *port;\n\tstruct net_device *realdev;\n\tint rc;\n\n\tport = lport_priv(lport);\n\tfcoe = port->priv;\n\trealdev = fcoe->realdev;\n\n\t \n\tif (lport->vport)\n\t\treturn;\n\n\tif (realdev->netdev_ops->ndo_fcoe_get_hbainfo) {\n\t\tstruct netdev_fcoe_hbainfo *fdmi;\n\t\tfdmi = kzalloc(sizeof(*fdmi), GFP_KERNEL);\n\t\tif (!fdmi)\n\t\t\treturn;\n\n\t\trc = realdev->netdev_ops->ndo_fcoe_get_hbainfo(realdev,\n\t\t\t\t\t\t\t       fdmi);\n\t\tif (rc) {\n\t\t\tprintk(KERN_INFO \"fcoe: Failed to retrieve FDMI \"\n\t\t\t\t\t\"information from netdev.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tsnprintf(fc_host_serial_number(lport->host),\n\t\t\t FC_SERIAL_NUMBER_SIZE,\n\t\t\t \"%s\",\n\t\t\t fdmi->serial_number);\n\t\tsnprintf(fc_host_manufacturer(lport->host),\n\t\t\t FC_SERIAL_NUMBER_SIZE,\n\t\t\t \"%s\",\n\t\t\t fdmi->manufacturer);\n\t\tsnprintf(fc_host_model(lport->host),\n\t\t\t FC_SYMBOLIC_NAME_SIZE,\n\t\t\t \"%s\",\n\t\t\t fdmi->model);\n\t\tsnprintf(fc_host_model_description(lport->host),\n\t\t\t FC_SYMBOLIC_NAME_SIZE,\n\t\t\t \"%s\",\n\t\t\t fdmi->model_description);\n\t\tsnprintf(fc_host_hardware_version(lport->host),\n\t\t\t FC_VERSION_STRING_SIZE,\n\t\t\t \"%s\",\n\t\t\t fdmi->hardware_version);\n\t\tsnprintf(fc_host_driver_version(lport->host),\n\t\t\t FC_VERSION_STRING_SIZE,\n\t\t\t \"%s\",\n\t\t\t fdmi->driver_version);\n\t\tsnprintf(fc_host_optionrom_version(lport->host),\n\t\t\t FC_VERSION_STRING_SIZE,\n\t\t\t \"%s\",\n\t\t\t fdmi->optionrom_version);\n\t\tsnprintf(fc_host_firmware_version(lport->host),\n\t\t\t FC_VERSION_STRING_SIZE,\n\t\t\t \"%s\",\n\t\t\t fdmi->firmware_version);\n\n\t\t \n\t\tlport->fdmi_enabled = 1;\n\t\tkfree(fdmi);\n\t} else {\n\t\tlport->fdmi_enabled = 0;\n\t\tprintk(KERN_INFO \"fcoe: No FDMI support.\\n\");\n\t}\n}\n\n \nstatic bool fcoe_oem_match(struct fc_frame *fp)\n{\n\tstruct fc_frame_header *fh = fc_frame_header_get(fp);\n\tstruct fcp_cmnd *fcp;\n\n\tif (fc_fcp_is_read(fr_fsp(fp)) &&\n\t    (fr_fsp(fp)->data_len > fcoe_ddp_min))\n\t\treturn true;\n\telse if ((fr_fsp(fp) == NULL) &&\n\t\t (fh->fh_r_ctl == FC_RCTL_DD_UNSOL_CMD) &&\n\t\t (ntohs(fh->fh_rx_id) == FC_XID_UNKNOWN)) {\n\t\tfcp = fc_frame_payload_get(fp, sizeof(*fcp));\n\t\tif ((fcp->fc_flags & FCP_CFL_WRDATA) &&\n\t\t    (ntohl(fcp->fc_dl) > fcoe_ddp_min))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic inline int fcoe_em_config(struct fc_lport *lport)\n{\n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct fcoe_interface *fcoe = port->priv;\n\tstruct fcoe_interface *oldfcoe = NULL;\n\tstruct net_device *old_real_dev, *cur_real_dev;\n\tu16 min_xid = FCOE_MIN_XID;\n\tu16 max_xid = FCOE_MAX_XID;\n\n\t \n\tif (!lport->lro_enabled || !lport->lro_xid ||\n\t    (lport->lro_xid >= max_xid)) {\n\t\tlport->lro_xid = 0;\n\t\tgoto skip_oem;\n\t}\n\n\t \n\tif (is_vlan_dev(fcoe->netdev))\n\t\tcur_real_dev = vlan_dev_real_dev(fcoe->netdev);\n\telse\n\t\tcur_real_dev = fcoe->netdev;\n\n\tlist_for_each_entry(oldfcoe, &fcoe_hostlist, list) {\n\t\tif (is_vlan_dev(oldfcoe->netdev))\n\t\t\told_real_dev = vlan_dev_real_dev(oldfcoe->netdev);\n\t\telse\n\t\t\told_real_dev = oldfcoe->netdev;\n\n\t\tif (cur_real_dev == old_real_dev) {\n\t\t\tfcoe->oem = oldfcoe->oem;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fcoe->oem) {\n\t\tif (!fc_exch_mgr_add(lport, fcoe->oem, fcoe_oem_match)) {\n\t\t\tprintk(KERN_ERR \"fcoe_em_config: failed to add \"\n\t\t\t       \"offload em:%p on interface:%s\\n\",\n\t\t\t       fcoe->oem, fcoe->netdev->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tfcoe->oem = fc_exch_mgr_alloc(lport, FC_CLASS_3,\n\t\t\t\t\t      FCOE_MIN_XID, lport->lro_xid,\n\t\t\t\t\t      fcoe_oem_match);\n\t\tif (!fcoe->oem) {\n\t\t\tprintk(KERN_ERR \"fcoe_em_config: failed to allocate \"\n\t\t\t       \"em for offload exches on interface:%s\\n\",\n\t\t\t       fcoe->netdev->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tmin_xid += lport->lro_xid + 1;\n\nskip_oem:\n\tif (!fc_exch_mgr_alloc(lport, FC_CLASS_3, min_xid, max_xid, NULL)) {\n\t\tprintk(KERN_ERR \"fcoe_em_config: failed to \"\n\t\t       \"allocate em on interface %s\\n\", fcoe->netdev->name);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void fcoe_if_destroy(struct fc_lport *lport)\n{\n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct fcoe_interface *fcoe = port->priv;\n\tstruct net_device *netdev = fcoe->netdev;\n\n\tFCOE_NETDEV_DBG(netdev, \"Destroying interface\\n\");\n\n\t \n\tfc_fabric_logoff(lport);\n\n\t \n\tfc_lport_destroy(lport);\n\n\t \n\tdel_timer_sync(&port->timer);\n\n\t \n\tfcoe_clean_pending_queue(lport);\n\n\tif (!is_zero_ether_addr(port->data_src_addr))\n\t\tdev_uc_del(netdev, port->data_src_addr);\n\tif (lport->vport)\n\t\tsynchronize_net();\n\telse\n\t\tfcoe_interface_remove(fcoe);\n\n\t \n\tfcoe_percpu_clean(lport);\n\n\t \n\tfc_remove_host(lport->host);\n\tscsi_remove_host(lport->host);\n\n\t \n\tfc_fcp_destroy(lport);\n\n\t \n\tfc_exch_mgr_free(lport);\n\n\t \n\tfc_lport_free_stats(lport);\n\n\t \n\tif (lport->vport)\n\t\tscsi_host_put(lport->host);\n}\n\n \nstatic int fcoe_ddp_setup(struct fc_lport *lport, u16 xid,\n\t\t\t  struct scatterlist *sgl, unsigned int sgc)\n{\n\tstruct net_device *netdev = fcoe_netdev(lport);\n\n\tif (netdev->netdev_ops->ndo_fcoe_ddp_setup)\n\t\treturn netdev->netdev_ops->ndo_fcoe_ddp_setup(netdev,\n\t\t\t\t\t\t\t      xid, sgl,\n\t\t\t\t\t\t\t      sgc);\n\n\treturn 0;\n}\n\n \nstatic int fcoe_ddp_target(struct fc_lport *lport, u16 xid,\n\t\t\t   struct scatterlist *sgl, unsigned int sgc)\n{\n\tstruct net_device *netdev = fcoe_netdev(lport);\n\n\tif (netdev->netdev_ops->ndo_fcoe_ddp_target)\n\t\treturn netdev->netdev_ops->ndo_fcoe_ddp_target(netdev, xid,\n\t\t\t\t\t\t\t       sgl, sgc);\n\n\treturn 0;\n}\n\n\n \nstatic int fcoe_ddp_done(struct fc_lport *lport, u16 xid)\n{\n\tstruct net_device *netdev = fcoe_netdev(lport);\n\n\tif (netdev->netdev_ops->ndo_fcoe_ddp_done)\n\t\treturn netdev->netdev_ops->ndo_fcoe_ddp_done(netdev, xid);\n\treturn 0;\n}\n\n \nstatic struct fc_lport *fcoe_if_create(struct fcoe_interface *fcoe,\n\t\t\t\t       struct device *parent, int npiv)\n{\n\tstruct fcoe_ctlr *ctlr = fcoe_to_ctlr(fcoe);\n\tstruct net_device *netdev = fcoe->netdev;\n\tstruct fc_lport *lport, *n_port;\n\tstruct fcoe_port *port;\n\tstruct Scsi_Host *shost;\n\tint rc;\n\t \n\tstruct fc_vport *vport = dev_to_vport(parent);\n\n\tFCOE_NETDEV_DBG(netdev, \"Create Interface\\n\");\n\n\tif (!npiv)\n\t\tlport = libfc_host_alloc(&fcoe_shost_template, sizeof(*port));\n\telse\n\t\tlport = libfc_vport_create(vport, sizeof(*port));\n\n\tif (!lport) {\n\t\tFCOE_NETDEV_DBG(netdev, \"Could not allocate host structure\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tport = lport_priv(lport);\n\tport->lport = lport;\n\tport->priv = fcoe;\n\tport->get_netdev = fcoe_netdev;\n\tport->max_queue_depth = FCOE_MAX_QUEUE_DEPTH;\n\tport->min_queue_depth = FCOE_MIN_QUEUE_DEPTH;\n\tINIT_WORK(&port->destroy_work, fcoe_destroy_work);\n\n\t \n\tfcoe_hostlist_add(lport);\n\n\t \n\trc = fcoe_lport_config(lport);\n\tif (rc) {\n\t\tFCOE_NETDEV_DBG(netdev, \"Could not configure lport for the \"\n\t\t\t\t\"interface\\n\");\n\t\tgoto out_host_put;\n\t}\n\n\tif (npiv) {\n\t\tFCOE_NETDEV_DBG(netdev, \"Setting vport names, \"\n\t\t\t\t\"%16.16llx %16.16llx\\n\",\n\t\t\t\tvport->node_name, vport->port_name);\n\t\tfc_set_wwnn(lport, vport->node_name);\n\t\tfc_set_wwpn(lport, vport->port_name);\n\t}\n\n\t \n\trc = fcoe_netdev_config(lport, netdev);\n\tif (rc) {\n\t\tFCOE_NETDEV_DBG(netdev, \"Could not configure netdev for the \"\n\t\t\t\t\"interface\\n\");\n\t\tgoto out_lp_destroy;\n\t}\n\n\t \n\trc = fcoe_shost_config(lport, parent);\n\tif (rc) {\n\t\tFCOE_NETDEV_DBG(netdev, \"Could not configure shost for the \"\n\t\t\t\t\"interface\\n\");\n\t\tgoto out_lp_destroy;\n\t}\n\n\t \n\trc = fcoe_libfc_config(lport, ctlr, &fcoe_libfc_fcn_templ, 1);\n\tif (rc) {\n\t\tFCOE_NETDEV_DBG(netdev, \"Could not configure libfc for the \"\n\t\t\t\t\"interface\\n\");\n\t\tgoto out_lp_destroy;\n\t}\n\n\t \n\tfcoe_fdmi_info(lport, netdev);\n\n\t \n\tif (!npiv)\n\t\t \n\t\trc = fcoe_em_config(lport);\n\telse {\n\t\tshost = vport_to_shost(vport);\n\t\tn_port = shost_priv(shost);\n\t\trc = fc_exch_mgr_list_clone(n_port, lport);\n\t}\n\n\tif (rc) {\n\t\tFCOE_NETDEV_DBG(netdev, \"Could not configure the EM\\n\");\n\t\tgoto out_lp_destroy;\n\t}\n\n\treturn lport;\n\nout_lp_destroy:\n\tfc_exch_mgr_free(lport);\nout_host_put:\n\tfcoe_hostlist_del(lport);\n\tscsi_host_put(lport->host);\nout:\n\treturn ERR_PTR(rc);\n}\n\n \nstatic int __init fcoe_if_init(void)\n{\n\t \n\tfcoe_nport_scsi_transport =\n\t\tfc_attach_transport(&fcoe_nport_fc_functions);\n\tif (!fcoe_nport_scsi_transport)\n\t\tgoto err;\n\n\tfcoe_vport_scsi_transport =\n\t\tfc_attach_transport(&fcoe_vport_fc_functions);\n\tif (!fcoe_vport_scsi_transport)\n\t\tgoto err_vport;\n\n\treturn 0;\n\nerr_vport:\n\tfc_release_transport(fcoe_nport_scsi_transport);\nerr:\n\tprintk(KERN_ERR \"fcoe: Failed to attach to the FC transport\\n\");\n\treturn -ENODEV;\n}\n\n \nstatic int __exit fcoe_if_exit(void)\n{\n\tfc_release_transport(fcoe_nport_scsi_transport);\n\tfc_release_transport(fcoe_vport_scsi_transport);\n\tfcoe_nport_scsi_transport = NULL;\n\tfcoe_vport_scsi_transport = NULL;\n\treturn 0;\n}\n\nstatic void fcoe_thread_cleanup_local(unsigned int cpu)\n{\n\tstruct page *crc_eof;\n\tstruct fcoe_percpu_s *p;\n\n\tp = per_cpu_ptr(&fcoe_percpu, cpu);\n\tspin_lock_bh(&p->fcoe_rx_list.lock);\n\tcrc_eof = p->crc_eof_page;\n\tp->crc_eof_page = NULL;\n\tp->crc_eof_offset = 0;\n\tspin_unlock_bh(&p->fcoe_rx_list.lock);\n\n\tif (crc_eof)\n\t\tput_page(crc_eof);\n\tflush_work(&p->work);\n}\n\n \nstatic inline unsigned int fcoe_select_cpu(void)\n{\n\tstatic unsigned int selected_cpu;\n\n\tselected_cpu = cpumask_next(selected_cpu, cpu_online_mask);\n\tif (selected_cpu >= nr_cpu_ids)\n\t\tselected_cpu = cpumask_first(cpu_online_mask);\n\n\treturn selected_cpu;\n}\n\n \nstatic int fcoe_rcv(struct sk_buff *skb, struct net_device *netdev,\n\t     struct packet_type *ptype, struct net_device *olddev)\n{\n\tstruct fc_lport *lport;\n\tstruct fcoe_rcv_info *fr;\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fcoe_interface *fcoe;\n\tstruct fc_frame_header *fh;\n\tstruct fcoe_percpu_s *fps;\n\tstruct ethhdr *eh;\n\tunsigned int cpu;\n\n\tfcoe = container_of(ptype, struct fcoe_interface, fcoe_packet_type);\n\tctlr = fcoe_to_ctlr(fcoe);\n\tlport = ctlr->lp;\n\tif (unlikely(!lport)) {\n\t\tFCOE_NETDEV_DBG(netdev, \"Cannot find hba structure\\n\");\n\t\tgoto err2;\n\t}\n\tif (!lport->link_up)\n\t\tgoto err2;\n\n\tFCOE_NETDEV_DBG(netdev,\n\t\t\t\"skb_info: len:%d data_len:%d head:%p data:%p tail:%p end:%p sum:%d dev:%s\\n\",\n\t\t\tskb->len, skb->data_len, skb->head, skb->data,\n\t\t\tskb_tail_pointer(skb), skb_end_pointer(skb),\n\t\t\tskb->csum, skb->dev ? skb->dev->name : \"<NULL>\");\n\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\n\tif (skb == NULL)\n\t\treturn NET_RX_DROP;\n\n\teh = eth_hdr(skb);\n\n\tif (is_fip_mode(ctlr) &&\n\t    !ether_addr_equal(eh->h_source, ctlr->dest_addr)) {\n\t\tFCOE_NETDEV_DBG(netdev, \"wrong source mac address:%pM\\n\",\n\t\t\t\teh->h_source);\n\t\tgoto err;\n\t}\n\n\t \n\tif (unlikely((skb->len < FCOE_MIN_FRAME) ||\n\t\t     !pskb_may_pull(skb, FCOE_HEADER_LEN)))\n\t\tgoto err;\n\n\tskb_set_transport_header(skb, sizeof(struct fcoe_hdr));\n\tfh = (struct fc_frame_header *) skb_transport_header(skb);\n\n\tif (ntoh24(&eh->h_dest[3]) != ntoh24(fh->fh_d_id)) {\n\t\tFCOE_NETDEV_DBG(netdev, \"FC frame d_id mismatch with MAC:%pM\\n\",\n\t\t\t\teh->h_dest);\n\t\tgoto err;\n\t}\n\n\tfr = fcoe_dev_from_skb(skb);\n\tfr->fr_dev = lport;\n\n\t \n\tif (ntoh24(fh->fh_f_ctl) & FC_FC_EX_CTX)\n\t\tcpu = ntohs(fh->fh_ox_id) & fc_cpu_mask;\n\telse {\n\t\tif (ntohs(fh->fh_rx_id) == FC_XID_UNKNOWN)\n\t\t\tcpu = fcoe_select_cpu();\n\t\telse\n\t\t\tcpu = ntohs(fh->fh_rx_id) & fc_cpu_mask;\n\t}\n\n\tif (cpu >= nr_cpu_ids)\n\t\tgoto err;\n\n\tfps = &per_cpu(fcoe_percpu, cpu);\n\tspin_lock(&fps->fcoe_rx_list.lock);\n\t \n\n\t \n\t__skb_queue_tail(&fps->fcoe_rx_list, skb);\n\tschedule_work_on(cpu, &fps->work);\n\tspin_unlock(&fps->fcoe_rx_list.lock);\n\n\treturn NET_RX_SUCCESS;\nerr:\n\tthis_cpu_inc(lport->stats->ErrorFrames);\nerr2:\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n\n \nstatic int fcoe_alloc_paged_crc_eof(struct sk_buff *skb, int tlen)\n{\n\tstruct fcoe_percpu_s *fps;\n\tint rc;\n\n\tlocal_lock(&fcoe_percpu.lock);\n\tfps = this_cpu_ptr(&fcoe_percpu);\n\trc = fcoe_get_paged_crc_eof(skb, tlen, fps);\n\tlocal_unlock(&fcoe_percpu.lock);\n\n\treturn rc;\n}\n\n \nstatic int fcoe_xmit(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tint wlen;\n\tu32 crc;\n\tstruct ethhdr *eh;\n\tstruct fcoe_crc_eof *cp;\n\tstruct sk_buff *skb;\n\tstruct fc_frame_header *fh;\n\tunsigned int hlen;\t\t \n\tunsigned int tlen;\t\t \n\tunsigned int elen;\t\t \n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct fcoe_interface *fcoe = port->priv;\n\tstruct fcoe_ctlr *ctlr = fcoe_to_ctlr(fcoe);\n\tu8 sof, eof;\n\tstruct fcoe_hdr *hp;\n\n\tWARN_ON((fr_len(fp) % sizeof(u32)) != 0);\n\n\tfh = fc_frame_header_get(fp);\n\tskb = fp_skb(fp);\n\n\tif (!lport->link_up) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(fh->fh_type == FC_TYPE_ELS) &&\n\t    fcoe_ctlr_els_send(ctlr, lport, skb))\n\t\treturn 0;\n\n\tsof = fr_sof(fp);\n\teof = fr_eof(fp);\n\n\telen = sizeof(struct ethhdr);\n\thlen = sizeof(struct fcoe_hdr);\n\ttlen = sizeof(struct fcoe_crc_eof);\n\twlen = (skb->len - tlen + sizeof(crc)) / FCOE_WORD_TO_BYTE;\n\n\t \n\tif (likely(lport->crc_offload)) {\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum_start = skb_headroom(skb);\n\t\tskb->csum_offset = skb->len;\n\t\tcrc = 0;\n\t} else {\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tcrc = fcoe_fc_crc(fp);\n\t}\n\n\t \n\tif (skb_is_nonlinear(skb)) {\n\t\tskb_frag_t *frag;\n\t\tif (fcoe_alloc_paged_crc_eof(skb, tlen)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfrag = &skb_shinfo(skb)->frags[skb_shinfo(skb)->nr_frags - 1];\n\t\tcp = kmap_atomic(skb_frag_page(frag)) + skb_frag_off(frag);\n\t} else {\n\t\tcp = skb_put(skb, tlen);\n\t}\n\n\tmemset(cp, 0, sizeof(*cp));\n\tcp->fcoe_eof = eof;\n\tcp->fcoe_crc32 = cpu_to_le32(~crc);\n\n\tif (skb_is_nonlinear(skb)) {\n\t\tkunmap_atomic(cp);\n\t\tcp = NULL;\n\t}\n\n\t \n\tskb_push(skb, elen + hlen);\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tskb->mac_len = elen;\n\tskb->protocol = htons(ETH_P_FCOE);\n\tskb->priority = fcoe->priority;\n\n\tif (is_vlan_dev(fcoe->netdev) &&\n\t    fcoe->realdev->features & NETIF_F_HW_VLAN_CTAG_TX) {\n\t\t \n\t\tskb->dev = fcoe->realdev;\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\n\t\t\t\t       vlan_dev_vlan_id(fcoe->netdev));\n\t} else\n\t\tskb->dev = fcoe->netdev;\n\n\t \n\teh = eth_hdr(skb);\n\teh->h_proto = htons(ETH_P_FCOE);\n\tmemcpy(eh->h_dest, ctlr->dest_addr, ETH_ALEN);\n\tif (ctlr->map_dest)\n\t\tmemcpy(eh->h_dest + 3, fh->fh_d_id, 3);\n\n\tif (unlikely(ctlr->flogi_oxid != FC_XID_UNKNOWN))\n\t\tmemcpy(eh->h_source, ctlr->ctl_src_addr, ETH_ALEN);\n\telse\n\t\tmemcpy(eh->h_source, port->data_src_addr, ETH_ALEN);\n\n\thp = (struct fcoe_hdr *)(eh + 1);\n\tmemset(hp, 0, sizeof(*hp));\n\tif (FC_FCOE_VER)\n\t\tFC_FCOE_ENCAPS_VER(hp, FC_FCOE_VER);\n\thp->fcoe_sof = sof;\n\n\t \n\tif (lport->seq_offload && fr_max_payload(fp)) {\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_FCOE;\n\t\tskb_shinfo(skb)->gso_size = fr_max_payload(fp);\n\t} else {\n\t\tskb_shinfo(skb)->gso_type = 0;\n\t\tskb_shinfo(skb)->gso_size = 0;\n\t}\n\t \n\tthis_cpu_inc(lport->stats->TxFrames);\n\tthis_cpu_add(lport->stats->TxWords, wlen);\n\n\t \n\tfr_dev(fp) = lport;\n\tfcoe_port_send(port, skb);\n\treturn 0;\n}\n\n \nstatic inline int fcoe_filter_frames(struct fc_lport *lport,\n\t\t\t\t     struct fc_frame *fp)\n{\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fcoe_interface *fcoe;\n\tstruct fc_frame_header *fh;\n\tstruct sk_buff *skb = (struct sk_buff *)fp;\n\n\t \n\tif (lport->crc_offload && skb->ip_summed == CHECKSUM_UNNECESSARY)\n\t\tfr_flags(fp) &= ~FCPHF_CRC_UNCHECKED;\n\telse\n\t\tfr_flags(fp) |= FCPHF_CRC_UNCHECKED;\n\n\tfh = fc_frame_header_get(fp);\n\tif (fh->fh_r_ctl == FC_RCTL_DD_SOL_DATA && fh->fh_type == FC_TYPE_FCP)\n\t\treturn 0;\n\n\tfcoe = ((struct fcoe_port *)lport_priv(lport))->priv;\n\tctlr = fcoe_to_ctlr(fcoe);\n\tif (is_fip_mode(ctlr) && fc_frame_payload_op(fp) == ELS_LOGO &&\n\t    ntoh24(fh->fh_s_id) == FC_FID_FLOGI) {\n\t\tFCOE_DBG(\"fcoe: dropping FCoE lport LOGO in fip mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(fr_flags(fp) & FCPHF_CRC_UNCHECKED) ||\n\t    le32_to_cpu(fr_crc(fp)) == ~crc32(~0, skb->data, skb->len)) {\n\t\tfr_flags(fp) &= ~FCPHF_CRC_UNCHECKED;\n\t\treturn 0;\n\t}\n\n\tif (this_cpu_inc_return(lport->stats->InvalidCRCCount) < 5)\n\t\tprintk(KERN_WARNING \"fcoe: dropping frame with CRC error\\n\");\n\treturn -EINVAL;\n}\n\n \nstatic void fcoe_recv_frame(struct sk_buff *skb)\n{\n\tu32 fr_len;\n\tstruct fc_lport *lport;\n\tstruct fcoe_rcv_info *fr;\n\tstruct fcoe_crc_eof crc_eof;\n\tstruct fc_frame *fp;\n\tstruct fcoe_hdr *hp;\n\n\tfr = fcoe_dev_from_skb(skb);\n\tlport = fr->fr_dev;\n\tif (unlikely(!lport)) {\n\t\tFCOE_NETDEV_DBG(skb->dev, \"NULL lport in skb\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tFCOE_NETDEV_DBG(skb->dev,\n\t\t\t\"skb_info: len:%d data_len:%d head:%p data:%p tail:%p end:%p sum:%d dev:%s\\n\",\n\t\t\tskb->len, skb->data_len,\n\t\t\tskb->head, skb->data, skb_tail_pointer(skb),\n\t\t\tskb_end_pointer(skb), skb->csum,\n\t\t\tskb->dev ? skb->dev->name : \"<NULL>\");\n\n\tskb_linearize(skb);  \n\n\t \n\thp = (struct fcoe_hdr *) skb_network_header(skb);\n\n\tif (unlikely(FC_FCOE_DECAPS_VER(hp) != FC_FCOE_VER)) {\n\t\tstruct fc_stats *stats;\n\n\t\tstats = per_cpu_ptr(lport->stats, raw_smp_processor_id());\n\t\tif (READ_ONCE(stats->ErrorFrames) < 5)\n\t\t\tprintk(KERN_WARNING \"fcoe: FCoE version \"\n\t\t\t       \"mismatch: The frame has \"\n\t\t\t       \"version %x, but the \"\n\t\t\t       \"initiator supports version \"\n\t\t\t       \"%x\\n\", FC_FCOE_DECAPS_VER(hp),\n\t\t\t       FC_FCOE_VER);\n\t\tgoto drop;\n\t}\n\n\tskb_pull(skb, sizeof(struct fcoe_hdr));\n\tfr_len = skb->len - sizeof(struct fcoe_crc_eof);\n\n\tthis_cpu_inc(lport->stats->RxFrames);\n\tthis_cpu_add(lport->stats->RxWords, fr_len / FCOE_WORD_TO_BYTE);\n\n\tfp = (struct fc_frame *)skb;\n\tfc_frame_init(fp);\n\tfr_dev(fp) = lport;\n\tfr_sof(fp) = hp->fcoe_sof;\n\n\t \n\tif (skb_copy_bits(skb, fr_len, &crc_eof, sizeof(crc_eof)))\n\t\tgoto drop;\n\tfr_eof(fp) = crc_eof.fcoe_eof;\n\tfr_crc(fp) = crc_eof.fcoe_crc32;\n\tif (pskb_trim(skb, fr_len))\n\t\tgoto drop;\n\n\tif (!fcoe_filter_frames(lport, fp)) {\n\t\tfc_exch_recv(lport, fp);\n\t\treturn;\n\t}\ndrop:\n\tthis_cpu_inc(lport->stats->ErrorFrames);\n\tkfree_skb(skb);\n}\n\n \nstatic void fcoe_receive_work(struct work_struct *work)\n{\n\tstruct fcoe_percpu_s *p;\n\tstruct sk_buff *skb;\n\tstruct sk_buff_head tmp;\n\n\tp = container_of(work, struct fcoe_percpu_s, work);\n\tskb_queue_head_init(&tmp);\n\n\tspin_lock_bh(&p->fcoe_rx_list.lock);\n\tskb_queue_splice_init(&p->fcoe_rx_list, &tmp);\n\tspin_unlock_bh(&p->fcoe_rx_list.lock);\n\n\tif (!skb_queue_len(&tmp))\n\t\treturn;\n\n\twhile ((skb = __skb_dequeue(&tmp)))\n\t\tfcoe_recv_frame(skb);\n}\n\n \nstatic void fcoe_dev_setup(void)\n{\n\tregister_dcbevent_notifier(&dcb_notifier);\n\tregister_netdevice_notifier(&fcoe_notifier);\n}\n\n \nstatic void fcoe_dev_cleanup(void)\n{\n\tunregister_dcbevent_notifier(&dcb_notifier);\n\tunregister_netdevice_notifier(&fcoe_notifier);\n}\n\nstatic struct fcoe_interface *\nfcoe_hostlist_lookup_realdev_port(struct net_device *netdev)\n{\n\tstruct fcoe_interface *fcoe;\n\tstruct net_device *real_dev;\n\n\tlist_for_each_entry(fcoe, &fcoe_hostlist, list) {\n\t\tif (is_vlan_dev(fcoe->netdev))\n\t\t\treal_dev = vlan_dev_real_dev(fcoe->netdev);\n\t\telse\n\t\t\treal_dev = fcoe->netdev;\n\n\t\tif (netdev == real_dev)\n\t\t\treturn fcoe;\n\t}\n\treturn NULL;\n}\n\nstatic int fcoe_dcb_app_notification(struct notifier_block *notifier,\n\t\t\t\t     ulong event, void *ptr)\n{\n\tstruct dcb_app_type *entry = ptr;\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fcoe_interface *fcoe;\n\tstruct net_device *netdev;\n\tint prio;\n\n\tif (entry->app.selector != DCB_APP_IDTYPE_ETHTYPE)\n\t\treturn NOTIFY_OK;\n\n\tnetdev = dev_get_by_index(&init_net, entry->ifindex);\n\tif (!netdev)\n\t\treturn NOTIFY_OK;\n\n\tfcoe = fcoe_hostlist_lookup_realdev_port(netdev);\n\tdev_put(netdev);\n\tif (!fcoe)\n\t\treturn NOTIFY_OK;\n\n\tctlr = fcoe_to_ctlr(fcoe);\n\n\tif (entry->dcbx & DCB_CAP_DCBX_VER_CEE)\n\t\tprio = ffs(entry->app.priority) - 1;\n\telse\n\t\tprio = entry->app.priority;\n\n\tif (prio < 0)\n\t\treturn NOTIFY_OK;\n\n\tif (entry->app.protocol == ETH_P_FIP ||\n\t    entry->app.protocol == ETH_P_FCOE)\n\t\tctlr->priority = prio;\n\n\tif (entry->app.protocol == ETH_P_FCOE)\n\t\tfcoe->priority = prio;\n\n\treturn NOTIFY_OK;\n}\n\n \nstatic int fcoe_device_notification(struct notifier_block *notifier,\n\t\t\t\t    ulong event, void *ptr)\n{\n\tstruct fcoe_ctlr_device *cdev;\n\tstruct fc_lport *lport = NULL;\n\tstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fcoe_interface *fcoe;\n\tu32 link_possible = 1;\n\tu32 mfs;\n\tint rc = NOTIFY_OK;\n\n\tlist_for_each_entry(fcoe, &fcoe_hostlist, list) {\n\t\tif (fcoe->netdev == netdev) {\n\t\t\tctlr = fcoe_to_ctlr(fcoe);\n\t\t\tlport = ctlr->lp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!lport) {\n\t\trc = NOTIFY_DONE;\n\t\tgoto out;\n\t}\n\n\tswitch (event) {\n\tcase NETDEV_DOWN:\n\tcase NETDEV_GOING_DOWN:\n\t\tlink_possible = 0;\n\t\tbreak;\n\tcase NETDEV_UP:\n\tcase NETDEV_CHANGE:\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\tif (netdev->features & NETIF_F_FCOE_MTU)\n\t\t\tbreak;\n\t\tmfs = netdev->mtu - (sizeof(struct fcoe_hdr) +\n\t\t\t\t     sizeof(struct fcoe_crc_eof));\n\t\tif (mfs >= FC_MIN_MAX_FRAME)\n\t\t\tfc_set_mfs(lport, mfs);\n\t\tbreak;\n\tcase NETDEV_REGISTER:\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\tlist_del(&fcoe->list);\n\t\tfcoe_vport_remove(lport);\n\t\tmutex_lock(&fcoe_config_mutex);\n\t\tfcoe_if_destroy(lport);\n\t\tif (!fcoe->removed)\n\t\t\tfcoe_interface_remove(fcoe);\n\t\tfcoe_interface_cleanup(fcoe);\n\t\tmutex_unlock(&fcoe_config_mutex);\n\t\tfcoe_ctlr_device_delete(fcoe_ctlr_to_ctlr_dev(ctlr));\n\t\tgoto out;\n\tcase NETDEV_FEAT_CHANGE:\n\t\tfcoe_netdev_features_change(lport, netdev);\n\t\tbreak;\n\tdefault:\n\t\tFCOE_NETDEV_DBG(netdev, \"Unknown event %ld \"\n\t\t\t\t\"from netdev netlink\\n\", event);\n\t}\n\n\tfcoe_link_speed_update(lport);\n\n\tcdev = fcoe_ctlr_to_ctlr_dev(ctlr);\n\n\tif (link_possible && !fcoe_link_ok(lport)) {\n\t\tswitch (cdev->enabled) {\n\t\tcase FCOE_CTLR_DISABLED:\n\t\t\tpr_info(\"Link up while interface is disabled.\\n\");\n\t\t\tbreak;\n\t\tcase FCOE_CTLR_ENABLED:\n\t\tcase FCOE_CTLR_UNUSED:\n\t\t\tfcoe_ctlr_link_up(ctlr);\n\t\t}\n\t} else if (fcoe_ctlr_link_down(ctlr)) {\n\t\tswitch (cdev->enabled) {\n\t\tcase FCOE_CTLR_DISABLED:\n\t\t\tpr_info(\"Link down while interface is disabled.\\n\");\n\t\t\tbreak;\n\t\tcase FCOE_CTLR_ENABLED:\n\t\tcase FCOE_CTLR_UNUSED:\n\t\t\tthis_cpu_inc(lport->stats->LinkFailureCount);\n\t\t\tfcoe_clean_pending_queue(lport);\n\t\t}\n\t}\nout:\n\treturn rc;\n}\n\n \nstatic int fcoe_disable(struct net_device *netdev)\n{\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fcoe_interface *fcoe;\n\tint rc = 0;\n\n\tmutex_lock(&fcoe_config_mutex);\n\n\trtnl_lock();\n\tfcoe = fcoe_hostlist_lookup_port(netdev);\n\trtnl_unlock();\n\n\tif (fcoe) {\n\t\tctlr = fcoe_to_ctlr(fcoe);\n\t\tfcoe_ctlr_link_down(ctlr);\n\t\tfcoe_clean_pending_queue(ctlr->lp);\n\t} else\n\t\trc = -ENODEV;\n\n\tmutex_unlock(&fcoe_config_mutex);\n\treturn rc;\n}\n\n \nstatic int fcoe_enable(struct net_device *netdev)\n{\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fcoe_interface *fcoe;\n\tint rc = 0;\n\n\tmutex_lock(&fcoe_config_mutex);\n\trtnl_lock();\n\tfcoe = fcoe_hostlist_lookup_port(netdev);\n\trtnl_unlock();\n\n\tif (!fcoe) {\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tctlr = fcoe_to_ctlr(fcoe);\n\n\tif (!fcoe_link_ok(ctlr->lp))\n\t\tfcoe_ctlr_link_up(ctlr);\n\nout:\n\tmutex_unlock(&fcoe_config_mutex);\n\treturn rc;\n}\n\n \nstatic int fcoe_ctlr_enabled(struct fcoe_ctlr_device *cdev)\n{\n\tstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(cdev);\n\tstruct fc_lport *lport = ctlr->lp;\n\tstruct net_device *netdev = fcoe_netdev(lport);\n\n\tswitch (cdev->enabled) {\n\tcase FCOE_CTLR_ENABLED:\n\t\treturn fcoe_enable(netdev);\n\tcase FCOE_CTLR_DISABLED:\n\t\treturn fcoe_disable(netdev);\n\tcase FCOE_CTLR_UNUSED:\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\n \nstatic void fcoe_ctlr_mode(struct fcoe_ctlr_device *ctlr_dev)\n{\n\tstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(ctlr_dev);\n\tstruct fcoe_interface *fcoe = fcoe_ctlr_priv(ctlr);\n\n\tif (ctlr_dev->mode == FIP_CONN_TYPE_VN2VN &&\n\t    ctlr->mode != FIP_MODE_VN2VN) {\n\t\tdev_mc_del(fcoe->netdev, FIP_ALL_ENODE_MACS);\n\t\tdev_mc_add(fcoe->netdev, FIP_ALL_VN2VN_MACS);\n\t\tdev_mc_add(fcoe->netdev, FIP_ALL_P2P_MACS);\n\t} else if (ctlr->mode != FIP_MODE_FABRIC) {\n\t\tdev_mc_del(fcoe->netdev, FIP_ALL_VN2VN_MACS);\n\t\tdev_mc_del(fcoe->netdev, FIP_ALL_P2P_MACS);\n\t\tdev_mc_add(fcoe->netdev, FIP_ALL_ENODE_MACS);\n\t}\n\tfcoe_ctlr_set_fip_mode(ctlr_dev);\n}\n\n \nstatic int fcoe_destroy(struct net_device *netdev)\n{\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fcoe_interface *fcoe;\n\tstruct fc_lport *lport;\n\tstruct fcoe_port *port;\n\tint rc = 0;\n\n\tmutex_lock(&fcoe_config_mutex);\n\trtnl_lock();\n\tfcoe = fcoe_hostlist_lookup_port(netdev);\n\tif (!fcoe) {\n\t\trc = -ENODEV;\n\t\tgoto out_nodev;\n\t}\n\tctlr = fcoe_to_ctlr(fcoe);\n\tlport = ctlr->lp;\n\tport = lport_priv(lport);\n\tlist_del(&fcoe->list);\n\tqueue_work(fcoe_wq, &port->destroy_work);\nout_nodev:\n\trtnl_unlock();\n\tmutex_unlock(&fcoe_config_mutex);\n\treturn rc;\n}\n\n \nstatic void fcoe_destroy_work(struct work_struct *work)\n{\n\tstruct fcoe_ctlr_device *cdev;\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fcoe_port *port;\n\tstruct fcoe_interface *fcoe;\n\n\tport = container_of(work, struct fcoe_port, destroy_work);\n\n\tfcoe_vport_remove(port->lport);\n\n\tmutex_lock(&fcoe_config_mutex);\n\n\tfcoe = port->priv;\n\tctlr = fcoe_to_ctlr(fcoe);\n\tcdev = fcoe_ctlr_to_ctlr_dev(ctlr);\n\n\trtnl_lock();\n\tfcoe_if_destroy(port->lport);\n\tif (!fcoe->removed)\n\t\tfcoe_interface_remove(fcoe);\n\trtnl_unlock();\n\tfcoe_interface_cleanup(fcoe);\n\n\tmutex_unlock(&fcoe_config_mutex);\n\n\tfcoe_ctlr_device_delete(cdev);\n}\n\n \nstatic bool fcoe_match(struct net_device *netdev)\n{\n\treturn true;\n}\n\n \nstatic void fcoe_dcb_create(struct fcoe_interface *fcoe)\n{\n\tint ctlr_prio = TC_PRIO_BESTEFFORT;\n\tint fcoe_prio = TC_PRIO_INTERACTIVE;\n\tstruct fcoe_ctlr *ctlr = fcoe_to_ctlr(fcoe);\n#ifdef CONFIG_DCB\n\tint dcbx;\n\tu8 fup, up;\n\tstruct net_device *netdev = fcoe->realdev;\n\tstruct dcb_app app = {\n\t\t\t\t.priority = 0,\n\t\t\t\t.protocol = ETH_P_FCOE\n\t\t\t     };\n\n\t \n\tif (netdev && netdev->dcbnl_ops && netdev->dcbnl_ops->getdcbx) {\n\t\tdcbx = netdev->dcbnl_ops->getdcbx(netdev);\n\n\t\tif (dcbx & DCB_CAP_DCBX_VER_IEEE) {\n\t\t\tapp.selector = IEEE_8021QAZ_APP_SEL_ETHERTYPE;\n\t\t\tup = dcb_ieee_getapp_mask(netdev, &app);\n\t\t\tapp.protocol = ETH_P_FIP;\n\t\t\tfup = dcb_ieee_getapp_mask(netdev, &app);\n\t\t} else {\n\t\t\tapp.selector = DCB_APP_IDTYPE_ETHTYPE;\n\t\t\tup = dcb_getapp(netdev, &app);\n\t\t\tapp.protocol = ETH_P_FIP;\n\t\t\tfup = dcb_getapp(netdev, &app);\n\t\t}\n\n\t\tfcoe_prio = ffs(up) ? ffs(up) - 1 : 0;\n\t\tctlr_prio = ffs(fup) ? ffs(fup) - 1 : fcoe_prio;\n\t}\n#endif\n\tfcoe->priority = fcoe_prio;\n\tctlr->priority = ctlr_prio;\n}\n\nenum fcoe_create_link_state {\n\tFCOE_CREATE_LINK_DOWN,\n\tFCOE_CREATE_LINK_UP,\n};\n\n \nstatic int _fcoe_create(struct net_device *netdev, enum fip_mode fip_mode,\n\t\t\tenum fcoe_create_link_state link_state)\n{\n\tint rc = 0;\n\tstruct fcoe_ctlr_device *ctlr_dev;\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fcoe_interface *fcoe;\n\tstruct fc_lport *lport;\n\n\tmutex_lock(&fcoe_config_mutex);\n\trtnl_lock();\n\n\t \n\tif (fcoe_hostlist_lookup(netdev)) {\n\t\trc = -EEXIST;\n\t\tgoto out_nodev;\n\t}\n\n\tfcoe = fcoe_interface_create(netdev, fip_mode);\n\tif (IS_ERR(fcoe)) {\n\t\trc = PTR_ERR(fcoe);\n\t\tgoto out_nodev;\n\t}\n\n\tctlr = fcoe_to_ctlr(fcoe);\n\tctlr_dev = fcoe_ctlr_to_ctlr_dev(ctlr);\n\tlport = fcoe_if_create(fcoe, &ctlr_dev->dev, 0);\n\tif (IS_ERR(lport)) {\n\t\tprintk(KERN_ERR \"fcoe: Failed to create interface (%s)\\n\",\n\t\t       netdev->name);\n\t\trc = -EIO;\n\t\tif (!fcoe->removed)\n\t\t\tfcoe_interface_remove(fcoe);\n\t\trtnl_unlock();\n\t\tfcoe_interface_cleanup(fcoe);\n\t\tmutex_unlock(&fcoe_config_mutex);\n\t\tfcoe_ctlr_device_delete(ctlr_dev);\n\t\treturn rc;\n\t}\n\n\t \n\tctlr->lp = lport;\n\n\t \n\tfcoe_dcb_create(fcoe);\n\n\t \n\tlport->boot_time = jiffies;\n\tfc_fabric_login(lport);\n\n\t \n\tif (link_state == FCOE_CREATE_LINK_UP)\n\t\tctlr_dev->enabled = FCOE_CTLR_ENABLED;\n\telse\n\t\tctlr_dev->enabled = FCOE_CTLR_DISABLED;\n\n\tif (link_state == FCOE_CREATE_LINK_UP &&\n\t    !fcoe_link_ok(lport)) {\n\t\trtnl_unlock();\n\t\tfcoe_ctlr_link_up(ctlr);\n\t\tmutex_unlock(&fcoe_config_mutex);\n\t\treturn rc;\n\t}\n\nout_nodev:\n\trtnl_unlock();\n\tmutex_unlock(&fcoe_config_mutex);\n\n\treturn rc;\n}\n\n \nstatic int fcoe_create(struct net_device *netdev, enum fip_mode fip_mode)\n{\n\treturn _fcoe_create(netdev, fip_mode, FCOE_CREATE_LINK_UP);\n}\n\n \nstatic int fcoe_ctlr_alloc(struct net_device *netdev)\n{\n\treturn _fcoe_create(netdev, FIP_MODE_FABRIC,\n\t\t\t    FCOE_CREATE_LINK_DOWN);\n}\n\n \nstatic int fcoe_link_ok(struct fc_lport *lport)\n{\n\tstruct net_device *netdev = fcoe_netdev(lport);\n\n\tif (netif_oper_up(netdev))\n\t\treturn 0;\n\treturn -1;\n}\n\n \nstatic void fcoe_percpu_clean(struct fc_lport *lport)\n{\n\tstruct fcoe_percpu_s *pp;\n\tunsigned int cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpp = &per_cpu(fcoe_percpu, cpu);\n\n\t\tflush_work(&pp->work);\n\t}\n}\n\n \nstatic int fcoe_reset(struct Scsi_Host *shost)\n{\n\tstruct fc_lport *lport = shost_priv(shost);\n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct fcoe_interface *fcoe = port->priv;\n\tstruct fcoe_ctlr *ctlr = fcoe_to_ctlr(fcoe);\n\tstruct fcoe_ctlr_device *cdev = fcoe_ctlr_to_ctlr_dev(ctlr);\n\n\tfcoe_ctlr_link_down(ctlr);\n\tfcoe_clean_pending_queue(ctlr->lp);\n\n\tif (cdev->enabled != FCOE_CTLR_DISABLED &&\n\t    !fcoe_link_ok(ctlr->lp))\n\t\tfcoe_ctlr_link_up(ctlr);\n\treturn 0;\n}\n\n \nstatic struct fcoe_interface *\nfcoe_hostlist_lookup_port(const struct net_device *netdev)\n{\n\tstruct fcoe_interface *fcoe;\n\n\tlist_for_each_entry(fcoe, &fcoe_hostlist, list) {\n\t\tif (fcoe->netdev == netdev)\n\t\t\treturn fcoe;\n\t}\n\treturn NULL;\n}\n\n \nstatic struct fc_lport *fcoe_hostlist_lookup(const struct net_device *netdev)\n{\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fcoe_interface *fcoe;\n\n\tfcoe = fcoe_hostlist_lookup_port(netdev);\n\tctlr = fcoe_to_ctlr(fcoe);\n\treturn (fcoe) ? ctlr->lp : NULL;\n}\n\n \nstatic int fcoe_hostlist_add(const struct fc_lport *lport)\n{\n\tstruct fcoe_interface *fcoe;\n\tstruct fcoe_port *port;\n\n\tfcoe = fcoe_hostlist_lookup_port(fcoe_netdev(lport));\n\tif (!fcoe) {\n\t\tport = lport_priv(lport);\n\t\tfcoe = port->priv;\n\t\tlist_add_tail(&fcoe->list, &fcoe_hostlist);\n\t}\n\treturn 0;\n}\n\n \nstatic void fcoe_hostlist_del(const struct fc_lport *lport)\n{\n\tstruct fcoe_interface *fcoe;\n\tstruct fcoe_port *port;\n\n\tport = lport_priv(lport);\n\tfcoe = port->priv;\n\tlist_del(&fcoe->list);\n\treturn;\n}\n\nstatic struct fcoe_transport fcoe_sw_transport = {\n\t.name = {FCOE_TRANSPORT_DEFAULT},\n\t.attached = false,\n\t.list = LIST_HEAD_INIT(fcoe_sw_transport.list),\n\t.match = fcoe_match,\n\t.alloc = fcoe_ctlr_alloc,\n\t.create = fcoe_create,\n\t.destroy = fcoe_destroy,\n\t.enable = fcoe_enable,\n\t.disable = fcoe_disable,\n};\n\n \nstatic int __init fcoe_init(void)\n{\n\tstruct fcoe_percpu_s *p;\n\tunsigned int cpu;\n\tint rc = 0;\n\n\tfcoe_wq = alloc_workqueue(\"fcoe\", 0, 0);\n\tif (!fcoe_wq)\n\t\treturn -ENOMEM;\n\n\t \n\trc = fcoe_transport_attach(&fcoe_sw_transport);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"failed to register an fcoe transport, check \"\n\t\t\t\"if libfcoe is loaded\\n\");\n\t\tgoto out_destroy;\n\t}\n\n\tmutex_lock(&fcoe_config_mutex);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tp = per_cpu_ptr(&fcoe_percpu, cpu);\n\t\tINIT_WORK(&p->work, fcoe_receive_work);\n\t\tskb_queue_head_init(&p->fcoe_rx_list);\n\t\tlocal_lock_init(&p->lock);\n\t}\n\n\t \n\tfcoe_dev_setup();\n\n\trc = fcoe_if_init();\n\tif (rc)\n\t\tgoto out_free;\n\n\tmutex_unlock(&fcoe_config_mutex);\n\treturn 0;\n\nout_free:\n\tmutex_unlock(&fcoe_config_mutex);\n\tfcoe_transport_detach(&fcoe_sw_transport);\nout_destroy:\n\tdestroy_workqueue(fcoe_wq);\n\treturn rc;\n}\nmodule_init(fcoe_init);\n\n \nstatic void __exit fcoe_exit(void)\n{\n\tstruct fcoe_interface *fcoe, *tmp;\n\tstruct fcoe_ctlr *ctlr;\n\tstruct fcoe_port *port;\n\tunsigned int cpu;\n\n\tmutex_lock(&fcoe_config_mutex);\n\n\tfcoe_dev_cleanup();\n\n\t \n\trtnl_lock();\n\tlist_for_each_entry_safe(fcoe, tmp, &fcoe_hostlist, list) {\n\t\tctlr = fcoe_to_ctlr(fcoe);\n\t\tport = lport_priv(ctlr->lp);\n\t\tfcoe_hostlist_del(port->lport);\n\t\tqueue_work(fcoe_wq, &port->destroy_work);\n\t}\n\trtnl_unlock();\n\n\tfor_each_possible_cpu(cpu)\n\t\tfcoe_thread_cleanup_local(cpu);\n\n\tmutex_unlock(&fcoe_config_mutex);\n\n\t \n\tdestroy_workqueue(fcoe_wq);\n\n\t \n\tfcoe_if_exit();\n\n\t \n\tfcoe_transport_detach(&fcoe_sw_transport);\n}\nmodule_exit(fcoe_exit);\n\n \nstatic void fcoe_flogi_resp(struct fc_seq *seq, struct fc_frame *fp, void *arg)\n{\n\tstruct fcoe_ctlr *fip = arg;\n\tstruct fc_exch *exch = fc_seq_exch(seq);\n\tstruct fc_lport *lport = exch->lp;\n\tu8 *mac;\n\n\tif (IS_ERR(fp))\n\t\tgoto done;\n\n\tmac = fr_cb(fp)->granted_mac;\n\t \n\tif (is_zero_ether_addr(mac))\n\t\tfcoe_ctlr_recv_flogi(fip, lport, fp);\n\telse\n\t\tfcoe_update_src_mac(lport, mac);\ndone:\n\tfc_lport_flogi_resp(seq, fp, lport);\n}\n\n \nstatic void fcoe_logo_resp(struct fc_seq *seq, struct fc_frame *fp, void *arg)\n{\n\tstruct fc_lport *lport = arg;\n\tstatic u8 zero_mac[ETH_ALEN] = { 0 };\n\n\tif (!IS_ERR(fp))\n\t\tfcoe_update_src_mac(lport, zero_mac);\n\tfc_lport_logo_resp(seq, fp, lport);\n}\n\n \nstatic struct fc_seq *fcoe_elsct_send(struct fc_lport *lport, u32 did,\n\t\t\t\t      struct fc_frame *fp, unsigned int op,\n\t\t\t\t      void (*resp)(struct fc_seq *,\n\t\t\t\t\t\t   struct fc_frame *,\n\t\t\t\t\t\t   void *),\n\t\t\t\t      void *arg, u32 timeout)\n{\n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct fcoe_interface *fcoe = port->priv;\n\tstruct fcoe_ctlr *fip = fcoe_to_ctlr(fcoe);\n\tstruct fc_frame_header *fh = fc_frame_header_get(fp);\n\n\tswitch (op) {\n\tcase ELS_FLOGI:\n\tcase ELS_FDISC:\n\t\tif (lport->point_to_multipoint)\n\t\t\tbreak;\n\t\treturn fc_elsct_send(lport, did, fp, op, fcoe_flogi_resp,\n\t\t\t\t     fip, timeout);\n\tcase ELS_LOGO:\n\t\t \n\t\tif (ntoh24(fh->fh_d_id) != FC_FID_FLOGI)\n\t\t\tbreak;\n\t\treturn fc_elsct_send(lport, did, fp, op, fcoe_logo_resp,\n\t\t\t\t     lport, timeout);\n\t}\n\treturn fc_elsct_send(lport, did, fp, op, resp, arg, timeout);\n}\n\n \nstatic int fcoe_vport_create(struct fc_vport *vport, bool disabled)\n{\n\tstruct Scsi_Host *shost = vport_to_shost(vport);\n\tstruct fc_lport *n_port = shost_priv(shost);\n\tstruct fcoe_port *port = lport_priv(n_port);\n\tstruct fcoe_interface *fcoe = port->priv;\n\tstruct net_device *netdev = fcoe->netdev;\n\tstruct fc_lport *vn_port;\n\tint rc;\n\tchar buf[32];\n\n\trc = fcoe_validate_vport_create(vport);\n\tif (rc) {\n\t\tfcoe_wwn_to_str(vport->port_name, buf, sizeof(buf));\n\t\tprintk(KERN_ERR \"fcoe: Failed to create vport, \"\n\t\t\t\"WWPN (0x%s) already exists\\n\",\n\t\t\tbuf);\n\t\treturn rc;\n\t}\n\n\tmutex_lock(&fcoe_config_mutex);\n\trtnl_lock();\n\tvn_port = fcoe_if_create(fcoe, &vport->dev, 1);\n\trtnl_unlock();\n\tmutex_unlock(&fcoe_config_mutex);\n\n\tif (IS_ERR(vn_port)) {\n\t\tprintk(KERN_ERR \"fcoe: fcoe_vport_create(%s) failed\\n\",\n\t\t       netdev->name);\n\t\treturn -EIO;\n\t}\n\n\tif (disabled) {\n\t\tfc_vport_set_state(vport, FC_VPORT_DISABLED);\n\t} else {\n\t\tvn_port->boot_time = jiffies;\n\t\tfc_fabric_login(vn_port);\n\t\tfc_vport_setlink(vn_port);\n\t}\n\treturn 0;\n}\n\n \nstatic int fcoe_vport_destroy(struct fc_vport *vport)\n{\n\tstruct Scsi_Host *shost = vport_to_shost(vport);\n\tstruct fc_lport *n_port = shost_priv(shost);\n\tstruct fc_lport *vn_port = vport->dd_data;\n\n\tmutex_lock(&n_port->lp_mutex);\n\tlist_del(&vn_port->list);\n\tmutex_unlock(&n_port->lp_mutex);\n\n\tmutex_lock(&fcoe_config_mutex);\n\trtnl_lock();\n\tfcoe_if_destroy(vn_port);\n\trtnl_unlock();\n\tmutex_unlock(&fcoe_config_mutex);\n\n\treturn 0;\n}\n\n \nstatic void fcoe_vport_remove(struct fc_lport *lport)\n{\n\tstruct Scsi_Host *shost;\n\tstruct fc_host_attrs *fc_host;\n\tunsigned long flags;\n\tstruct fc_vport *vport;\n\tstruct fc_vport *next_vport;\n\n\tshost = lport->host;\n\tfc_host = shost_to_fc_host(shost);\n\n\t \n\tspin_lock_irqsave(shost->host_lock, flags);\n\tlist_for_each_entry_safe(vport, next_vport, &fc_host->vports, peers) {\n\t\tif (vport->flags & (FC_VPORT_DEL | FC_VPORT_CREATING)) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tvport->flags |= FC_VPORT_DELETING;\n\t\t\tqueue_work(fc_host_work_q(shost),\n\t\t\t\t   &vport->vport_delete_work);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tflush_workqueue(fc_host_work_q(shost));\n}\n\n \nstatic int fcoe_vport_disable(struct fc_vport *vport, bool disable)\n{\n\tstruct fc_lport *lport = vport->dd_data;\n\n\tif (disable) {\n\t\tfc_vport_set_state(vport, FC_VPORT_DISABLED);\n\t\tfc_fabric_logoff(lport);\n\t} else {\n\t\tlport->boot_time = jiffies;\n\t\tfc_fabric_login(lport);\n\t\tfc_vport_setlink(lport);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void fcoe_set_vport_symbolic_name(struct fc_vport *vport)\n{\n\tstruct fc_lport *lport = vport->dd_data;\n\tstruct fc_frame *fp;\n\tsize_t len;\n\n\tsnprintf(fc_host_symbolic_name(lport->host), FC_SYMBOLIC_NAME_SIZE,\n\t\t \"%s v%s over %s : %s\", FCOE_NAME, FCOE_VERSION,\n\t\t fcoe_netdev(lport)->name, vport->symbolic_name);\n\n\tif (lport->state != LPORT_ST_READY)\n\t\treturn;\n\n\tlen = strnlen(fc_host_symbolic_name(lport->host), 255);\n\tfp = fc_frame_alloc(lport,\n\t\t\t    sizeof(struct fc_ct_hdr) +\n\t\t\t    sizeof(struct fc_ns_rspn) + len);\n\tif (!fp)\n\t\treturn;\n\tlport->tt.elsct_send(lport, FC_FID_DIR_SERV, fp, FC_NS_RSPN_ID,\n\t\t\t     NULL, NULL, 3 * lport->r_a_tov);\n}\n\nstatic void fcoe_fcf_get_vlan_id(struct fcoe_fcf_device *fcf_dev)\n{\n\tstruct fcoe_ctlr_device *ctlr_dev =\n\t\tfcoe_fcf_dev_to_ctlr_dev(fcf_dev);\n\tstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(ctlr_dev);\n\tstruct fcoe_interface *fcoe = fcoe_ctlr_priv(ctlr);\n\n\tfcf_dev->vlan_id = vlan_dev_vlan_id(fcoe->netdev);\n}\n\n \nstatic void fcoe_set_port_id(struct fc_lport *lport,\n\t\t\t     u32 port_id, struct fc_frame *fp)\n{\n\tstruct fcoe_port *port = lport_priv(lport);\n\tstruct fcoe_interface *fcoe = port->priv;\n\tstruct fcoe_ctlr *ctlr = fcoe_to_ctlr(fcoe);\n\n\tif (fp && fc_frame_payload_op(fp) == ELS_FLOGI)\n\t\tfcoe_ctlr_recv_flogi(ctlr, lport, fp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}