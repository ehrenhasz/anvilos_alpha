{
  "module_name": "fcoe_ctlr.c",
  "hash_id": "926330d3ef35fc15d97167d9fceecb4df7a4debdbd10ee448ccec3dc94a45e01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/fcoe/fcoe_ctlr.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <net/rtnetlink.h>\n\n#include <scsi/fc/fc_els.h>\n#include <scsi/fc/fc_fs.h>\n#include <scsi/fc/fc_fip.h>\n#include <scsi/fc/fc_encaps.h>\n#include <scsi/fc/fc_fcoe.h>\n#include <scsi/fc/fc_fcp.h>\n\n#include <scsi/libfc.h>\n#include <scsi/libfcoe.h>\n\n#include \"libfcoe.h\"\n\n#define\tFCOE_CTLR_MIN_FKA\t500\t\t \n#define\tFCOE_CTLR_DEF_FKA\tFIP_DEF_FKA\t \n\nstatic void fcoe_ctlr_timeout(struct timer_list *);\nstatic void fcoe_ctlr_timer_work(struct work_struct *);\nstatic void fcoe_ctlr_recv_work(struct work_struct *);\nstatic int fcoe_ctlr_flogi_retry(struct fcoe_ctlr *);\n\nstatic void fcoe_ctlr_vn_start(struct fcoe_ctlr *);\nstatic int fcoe_ctlr_vn_recv(struct fcoe_ctlr *, struct sk_buff *);\nstatic void fcoe_ctlr_vn_timeout(struct fcoe_ctlr *);\nstatic int fcoe_ctlr_vn_lookup(struct fcoe_ctlr *, u32, u8 *);\n\nstatic int fcoe_ctlr_vlan_recv(struct fcoe_ctlr *, struct sk_buff *);\n\nstatic u8 fcoe_all_fcfs[ETH_ALEN] = FIP_ALL_FCF_MACS;\nstatic u8 fcoe_all_enode[ETH_ALEN] = FIP_ALL_ENODE_MACS;\nstatic u8 fcoe_all_vn2vn[ETH_ALEN] = FIP_ALL_VN2VN_MACS;\nstatic u8 fcoe_all_p2p[ETH_ALEN] = FIP_ALL_P2P_MACS;\n\nstatic const char * const fcoe_ctlr_states[] = {\n\t[FIP_ST_DISABLED] =\t\"DISABLED\",\n\t[FIP_ST_LINK_WAIT] =\t\"LINK_WAIT\",\n\t[FIP_ST_AUTO] =\t\t\"AUTO\",\n\t[FIP_ST_NON_FIP] =\t\"NON_FIP\",\n\t[FIP_ST_ENABLED] =\t\"ENABLED\",\n\t[FIP_ST_VNMP_START] =\t\"VNMP_START\",\n\t[FIP_ST_VNMP_PROBE1] =\t\"VNMP_PROBE1\",\n\t[FIP_ST_VNMP_PROBE2] =\t\"VNMP_PROBE2\",\n\t[FIP_ST_VNMP_CLAIM] =\t\"VNMP_CLAIM\",\n\t[FIP_ST_VNMP_UP] =\t\"VNMP_UP\",\n};\n\nstatic const char *fcoe_ctlr_state(enum fip_state state)\n{\n\tconst char *cp = \"unknown\";\n\n\tif (state < ARRAY_SIZE(fcoe_ctlr_states))\n\t\tcp = fcoe_ctlr_states[state];\n\tif (!cp)\n\t\tcp = \"unknown\";\n\treturn cp;\n}\n\n \nstatic void fcoe_ctlr_set_state(struct fcoe_ctlr *fip, enum fip_state state)\n{\n\tif (state == fip->state)\n\t\treturn;\n\tif (fip->lp)\n\t\tLIBFCOE_FIP_DBG(fip, \"state %s -> %s\\n\",\n\t\t\tfcoe_ctlr_state(fip->state), fcoe_ctlr_state(state));\n\tfip->state = state;\n}\n\n \nstatic inline int fcoe_ctlr_mtu_valid(const struct fcoe_fcf *fcf)\n{\n\treturn (fcf->flags & FIP_FL_SOL) != 0;\n}\n\n \nstatic inline int fcoe_ctlr_fcf_usable(struct fcoe_fcf *fcf)\n{\n\tu16 flags = FIP_FL_SOL | FIP_FL_AVAIL;\n\n\treturn (fcf->flags & flags) == flags;\n}\n\n \nstatic void fcoe_ctlr_map_dest(struct fcoe_ctlr *fip)\n{\n\tif (fip->mode == FIP_MODE_VN2VN)\n\t\thton24(fip->dest_addr, FIP_VN_FC_MAP);\n\telse\n\t\thton24(fip->dest_addr, FIP_DEF_FC_MAP);\n\thton24(fip->dest_addr + 3, 0);\n\tfip->map_dest = 1;\n}\n\n \nvoid fcoe_ctlr_init(struct fcoe_ctlr *fip, enum fip_mode mode)\n{\n\tfcoe_ctlr_set_state(fip, FIP_ST_LINK_WAIT);\n\tfip->mode = mode;\n\tfip->fip_resp = false;\n\tINIT_LIST_HEAD(&fip->fcfs);\n\tmutex_init(&fip->ctlr_mutex);\n\tspin_lock_init(&fip->ctlr_lock);\n\tfip->flogi_oxid = FC_XID_UNKNOWN;\n\ttimer_setup(&fip->timer, fcoe_ctlr_timeout, 0);\n\tINIT_WORK(&fip->timer_work, fcoe_ctlr_timer_work);\n\tINIT_WORK(&fip->recv_work, fcoe_ctlr_recv_work);\n\tskb_queue_head_init(&fip->fip_recv_list);\n}\nEXPORT_SYMBOL(fcoe_ctlr_init);\n\n \nstatic int fcoe_sysfs_fcf_add(struct fcoe_fcf *new)\n{\n\tstruct fcoe_ctlr *fip = new->fip;\n\tstruct fcoe_ctlr_device *ctlr_dev;\n\tstruct fcoe_fcf_device *temp, *fcf_dev;\n\tint rc = -ENOMEM;\n\n\tLIBFCOE_FIP_DBG(fip, \"New FCF fab %16.16llx mac %pM\\n\",\n\t\t\tnew->fabric_name, new->fcf_mac);\n\n\ttemp = kzalloc(sizeof(*temp), GFP_KERNEL);\n\tif (!temp)\n\t\tgoto out;\n\n\ttemp->fabric_name = new->fabric_name;\n\ttemp->switch_name = new->switch_name;\n\ttemp->fc_map = new->fc_map;\n\ttemp->vfid = new->vfid;\n\tmemcpy(temp->mac, new->fcf_mac, ETH_ALEN);\n\ttemp->priority = new->pri;\n\ttemp->fka_period = new->fka_period;\n\ttemp->selected = 0;  \n\n\t \n\n\tctlr_dev = fcoe_ctlr_to_ctlr_dev(fip);\n\tif (ctlr_dev) {\n\t\tmutex_lock(&ctlr_dev->lock);\n\t\tfcf_dev = fcoe_fcf_device_add(ctlr_dev, temp);\n\t\tif (unlikely(!fcf_dev)) {\n\t\t\trc = -ENOMEM;\n\t\t\tmutex_unlock(&ctlr_dev->lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tBUG_ON(fcf_dev->priv);\n\n\t\tfcf_dev->priv = new;\n\t\tnew->fcf_dev = fcf_dev;\n\t\tmutex_unlock(&ctlr_dev->lock);\n\t}\n\n\tlist_add(&new->list, &fip->fcfs);\n\tfip->fcf_count++;\n\trc = 0;\n\nout:\n\tkfree(temp);\n\treturn rc;\n}\n\n \nstatic void fcoe_sysfs_fcf_del(struct fcoe_fcf *new)\n{\n\tstruct fcoe_ctlr *fip = new->fip;\n\tstruct fcoe_ctlr_device *cdev;\n\tstruct fcoe_fcf_device *fcf_dev;\n\n\tlist_del(&new->list);\n\tfip->fcf_count--;\n\n\t \n\tcdev = fcoe_ctlr_to_ctlr_dev(fip);\n\tif (cdev) {\n\t\tmutex_lock(&cdev->lock);\n\t\tfcf_dev = fcoe_fcf_to_fcf_dev(new);\n\t\tWARN_ON(!fcf_dev);\n\t\tnew->fcf_dev = NULL;\n\t\tfcoe_fcf_device_delete(fcf_dev);\n\t\tmutex_unlock(&cdev->lock);\n\t}\n\tkfree(new);\n}\n\n \nstatic void fcoe_ctlr_reset_fcfs(struct fcoe_ctlr *fip)\n{\n\tstruct fcoe_fcf *fcf;\n\tstruct fcoe_fcf *next;\n\n\tfip->sel_fcf = NULL;\n\tlist_for_each_entry_safe(fcf, next, &fip->fcfs, list) {\n\t\tfcoe_sysfs_fcf_del(fcf);\n\t}\n\tWARN_ON(fip->fcf_count);\n\n\tfip->sel_time = 0;\n}\n\n \nvoid fcoe_ctlr_destroy(struct fcoe_ctlr *fip)\n{\n\tcancel_work_sync(&fip->recv_work);\n\tskb_queue_purge(&fip->fip_recv_list);\n\n\tmutex_lock(&fip->ctlr_mutex);\n\tfcoe_ctlr_set_state(fip, FIP_ST_DISABLED);\n\tfcoe_ctlr_reset_fcfs(fip);\n\tmutex_unlock(&fip->ctlr_mutex);\n\tdel_timer_sync(&fip->timer);\n\tcancel_work_sync(&fip->timer_work);\n}\nEXPORT_SYMBOL(fcoe_ctlr_destroy);\n\n \nstatic void fcoe_ctlr_announce(struct fcoe_ctlr *fip)\n{\n\tstruct fcoe_fcf *sel;\n\tstruct fcoe_fcf *fcf;\n\tunsigned long flags;\n\n\tmutex_lock(&fip->ctlr_mutex);\n\tspin_lock_irqsave(&fip->ctlr_lock, flags);\n\n\tkfree_skb(fip->flogi_req);\n\tfip->flogi_req = NULL;\n\tlist_for_each_entry(fcf, &fip->fcfs, list)\n\t\tfcf->flogi_sent = 0;\n\n\tspin_unlock_irqrestore(&fip->ctlr_lock, flags);\n\tsel = fip->sel_fcf;\n\n\tif (sel && ether_addr_equal(sel->fcf_mac, fip->dest_addr))\n\t\tgoto unlock;\n\tif (!is_zero_ether_addr(fip->dest_addr)) {\n\t\tprintk(KERN_NOTICE \"libfcoe: host%d: \"\n\t\t       \"FIP Fibre-Channel Forwarder MAC %pM deselected\\n\",\n\t\t       fip->lp->host->host_no, fip->dest_addr);\n\t\teth_zero_addr(fip->dest_addr);\n\t}\n\tif (sel) {\n\t\tprintk(KERN_INFO \"libfcoe: host%d: FIP selected \"\n\t\t       \"Fibre-Channel Forwarder MAC %pM\\n\",\n\t\t       fip->lp->host->host_no, sel->fcf_mac);\n\t\tmemcpy(fip->dest_addr, sel->fcoe_mac, ETH_ALEN);\n\t\tfip->map_dest = 0;\n\t}\nunlock:\n\tmutex_unlock(&fip->ctlr_mutex);\n}\n\n \nstatic inline u32 fcoe_ctlr_fcoe_size(struct fcoe_ctlr *fip)\n{\n\t \n\treturn fip->lp->mfs + sizeof(struct fc_frame_header) +\n\t\tsizeof(struct fcoe_hdr) + sizeof(struct fcoe_crc_eof);\n}\n\n \nstatic void fcoe_ctlr_solicit(struct fcoe_ctlr *fip, struct fcoe_fcf *fcf)\n{\n\tstruct sk_buff *skb;\n\tstruct fip_sol {\n\t\tstruct ethhdr eth;\n\t\tstruct fip_header fip;\n\t\tstruct {\n\t\t\tstruct fip_mac_desc mac;\n\t\t\tstruct fip_wwn_desc wwnn;\n\t\t\tstruct fip_size_desc size;\n\t\t} __packed desc;\n\t}  __packed * sol;\n\tu32 fcoe_size;\n\n\tskb = dev_alloc_skb(sizeof(*sol));\n\tif (!skb)\n\t\treturn;\n\n\tsol = (struct fip_sol *)skb->data;\n\n\tmemset(sol, 0, sizeof(*sol));\n\tmemcpy(sol->eth.h_dest, fcf ? fcf->fcf_mac : fcoe_all_fcfs, ETH_ALEN);\n\tmemcpy(sol->eth.h_source, fip->ctl_src_addr, ETH_ALEN);\n\tsol->eth.h_proto = htons(ETH_P_FIP);\n\n\tsol->fip.fip_ver = FIP_VER_ENCAPS(FIP_VER);\n\tsol->fip.fip_op = htons(FIP_OP_DISC);\n\tsol->fip.fip_subcode = FIP_SC_SOL;\n\tsol->fip.fip_dl_len = htons(sizeof(sol->desc) / FIP_BPW);\n\tsol->fip.fip_flags = htons(FIP_FL_FPMA);\n\tif (fip->spma)\n\t\tsol->fip.fip_flags |= htons(FIP_FL_SPMA);\n\n\tsol->desc.mac.fd_desc.fip_dtype = FIP_DT_MAC;\n\tsol->desc.mac.fd_desc.fip_dlen = sizeof(sol->desc.mac) / FIP_BPW;\n\tmemcpy(sol->desc.mac.fd_mac, fip->ctl_src_addr, ETH_ALEN);\n\n\tsol->desc.wwnn.fd_desc.fip_dtype = FIP_DT_NAME;\n\tsol->desc.wwnn.fd_desc.fip_dlen = sizeof(sol->desc.wwnn) / FIP_BPW;\n\tput_unaligned_be64(fip->lp->wwnn, &sol->desc.wwnn.fd_wwn);\n\n\tfcoe_size = fcoe_ctlr_fcoe_size(fip);\n\tsol->desc.size.fd_desc.fip_dtype = FIP_DT_FCOE_SIZE;\n\tsol->desc.size.fd_desc.fip_dlen = sizeof(sol->desc.size) / FIP_BPW;\n\tsol->desc.size.fd_size = htons(fcoe_size);\n\n\tskb_put(skb, sizeof(*sol));\n\tskb->protocol = htons(ETH_P_FIP);\n\tskb->priority = fip->priority;\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tfip->send(fip, skb);\n\n\tif (!fcf)\n\t\tfip->sol_time = jiffies;\n}\n\n \nvoid fcoe_ctlr_link_up(struct fcoe_ctlr *fip)\n{\n\tmutex_lock(&fip->ctlr_mutex);\n\tif (fip->state == FIP_ST_NON_FIP || fip->state == FIP_ST_AUTO) {\n\t\tmutex_unlock(&fip->ctlr_mutex);\n\t\tfc_linkup(fip->lp);\n\t} else if (fip->state == FIP_ST_LINK_WAIT) {\n\t\tif (fip->mode == FIP_MODE_NON_FIP)\n\t\t\tfcoe_ctlr_set_state(fip, FIP_ST_NON_FIP);\n\t\telse\n\t\t\tfcoe_ctlr_set_state(fip, FIP_ST_AUTO);\n\t\tswitch (fip->mode) {\n\t\tdefault:\n\t\t\tLIBFCOE_FIP_DBG(fip, \"invalid mode %d\\n\", fip->mode);\n\t\t\tfallthrough;\n\t\tcase FIP_MODE_AUTO:\n\t\t\tLIBFCOE_FIP_DBG(fip, \"%s\", \"setting AUTO mode.\\n\");\n\t\t\tfallthrough;\n\t\tcase FIP_MODE_FABRIC:\n\t\tcase FIP_MODE_NON_FIP:\n\t\t\tmutex_unlock(&fip->ctlr_mutex);\n\t\t\tfc_linkup(fip->lp);\n\t\t\tfcoe_ctlr_solicit(fip, NULL);\n\t\t\tbreak;\n\t\tcase FIP_MODE_VN2VN:\n\t\t\tfcoe_ctlr_vn_start(fip);\n\t\t\tmutex_unlock(&fip->ctlr_mutex);\n\t\t\tfc_linkup(fip->lp);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tmutex_unlock(&fip->ctlr_mutex);\n}\nEXPORT_SYMBOL(fcoe_ctlr_link_up);\n\n \nstatic void fcoe_ctlr_reset(struct fcoe_ctlr *fip)\n{\n\tfcoe_ctlr_reset_fcfs(fip);\n\tdel_timer(&fip->timer);\n\tfip->ctlr_ka_time = 0;\n\tfip->port_ka_time = 0;\n\tfip->sol_time = 0;\n\tfip->flogi_oxid = FC_XID_UNKNOWN;\n\tfcoe_ctlr_map_dest(fip);\n}\n\n \nint fcoe_ctlr_link_down(struct fcoe_ctlr *fip)\n{\n\tint link_dropped;\n\n\tLIBFCOE_FIP_DBG(fip, \"link down.\\n\");\n\tmutex_lock(&fip->ctlr_mutex);\n\tfcoe_ctlr_reset(fip);\n\tlink_dropped = fip->state != FIP_ST_LINK_WAIT;\n\tfcoe_ctlr_set_state(fip, FIP_ST_LINK_WAIT);\n\tmutex_unlock(&fip->ctlr_mutex);\n\n\tif (link_dropped)\n\t\tfc_linkdown(fip->lp);\n\treturn link_dropped;\n}\nEXPORT_SYMBOL(fcoe_ctlr_link_down);\n\n \nstatic void fcoe_ctlr_send_keep_alive(struct fcoe_ctlr *fip,\n\t\t\t\t      struct fc_lport *lport,\n\t\t\t\t      int ports, u8 *sa)\n{\n\tstruct sk_buff *skb;\n\tstruct fip_kal {\n\t\tstruct ethhdr eth;\n\t\tstruct fip_header fip;\n\t\tstruct fip_mac_desc mac;\n\t} __packed * kal;\n\tstruct fip_vn_desc *vn;\n\tu32 len;\n\tstruct fc_lport *lp;\n\tstruct fcoe_fcf *fcf;\n\n\tfcf = fip->sel_fcf;\n\tlp = fip->lp;\n\tif (!fcf || (ports && !lp->port_id))\n\t\treturn;\n\n\tlen = sizeof(*kal) + ports * sizeof(*vn);\n\tskb = dev_alloc_skb(len);\n\tif (!skb)\n\t\treturn;\n\n\tkal = (struct fip_kal *)skb->data;\n\tmemset(kal, 0, len);\n\tmemcpy(kal->eth.h_dest, fcf->fcf_mac, ETH_ALEN);\n\tmemcpy(kal->eth.h_source, sa, ETH_ALEN);\n\tkal->eth.h_proto = htons(ETH_P_FIP);\n\n\tkal->fip.fip_ver = FIP_VER_ENCAPS(FIP_VER);\n\tkal->fip.fip_op = htons(FIP_OP_CTRL);\n\tkal->fip.fip_subcode = FIP_SC_KEEP_ALIVE;\n\tkal->fip.fip_dl_len = htons((sizeof(kal->mac) +\n\t\t\t\t     ports * sizeof(*vn)) / FIP_BPW);\n\tkal->fip.fip_flags = htons(FIP_FL_FPMA);\n\tif (fip->spma)\n\t\tkal->fip.fip_flags |= htons(FIP_FL_SPMA);\n\n\tkal->mac.fd_desc.fip_dtype = FIP_DT_MAC;\n\tkal->mac.fd_desc.fip_dlen = sizeof(kal->mac) / FIP_BPW;\n\tmemcpy(kal->mac.fd_mac, fip->ctl_src_addr, ETH_ALEN);\n\tif (ports) {\n\t\tvn = (struct fip_vn_desc *)(kal + 1);\n\t\tvn->fd_desc.fip_dtype = FIP_DT_VN_ID;\n\t\tvn->fd_desc.fip_dlen = sizeof(*vn) / FIP_BPW;\n\t\tmemcpy(vn->fd_mac, fip->get_src_addr(lport), ETH_ALEN);\n\t\thton24(vn->fd_fc_id, lport->port_id);\n\t\tput_unaligned_be64(lport->wwpn, &vn->fd_wwpn);\n\t}\n\tskb_put(skb, len);\n\tskb->protocol = htons(ETH_P_FIP);\n\tskb->priority = fip->priority;\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tfip->send(fip, skb);\n}\n\n \nstatic int fcoe_ctlr_encaps(struct fcoe_ctlr *fip, struct fc_lport *lport,\n\t\t\t    u8 dtype, struct sk_buff *skb, u32 d_id)\n{\n\tstruct fip_encaps_head {\n\t\tstruct ethhdr eth;\n\t\tstruct fip_header fip;\n\t\tstruct fip_encaps encaps;\n\t} __packed * cap;\n\tstruct fc_frame_header *fh;\n\tstruct fip_mac_desc *mac;\n\tstruct fcoe_fcf *fcf;\n\tsize_t dlen;\n\tu16 fip_flags;\n\tu8 op;\n\n\tfh = (struct fc_frame_header *)skb->data;\n\top = *(u8 *)(fh + 1);\n\tdlen = sizeof(struct fip_encaps) + skb->len;\t \n\tcap = skb_push(skb, sizeof(*cap));\n\tmemset(cap, 0, sizeof(*cap));\n\n\tif (lport->point_to_multipoint) {\n\t\tif (fcoe_ctlr_vn_lookup(fip, d_id, cap->eth.h_dest))\n\t\t\treturn -ENODEV;\n\t\tfip_flags = 0;\n\t} else {\n\t\tfcf = fip->sel_fcf;\n\t\tif (!fcf)\n\t\t\treturn -ENODEV;\n\t\tfip_flags = fcf->flags;\n\t\tfip_flags &= fip->spma ? FIP_FL_SPMA | FIP_FL_FPMA :\n\t\t\t\t\t FIP_FL_FPMA;\n\t\tif (!fip_flags)\n\t\t\treturn -ENODEV;\n\t\tmemcpy(cap->eth.h_dest, fcf->fcf_mac, ETH_ALEN);\n\t}\n\tmemcpy(cap->eth.h_source, fip->ctl_src_addr, ETH_ALEN);\n\tcap->eth.h_proto = htons(ETH_P_FIP);\n\n\tcap->fip.fip_ver = FIP_VER_ENCAPS(FIP_VER);\n\tcap->fip.fip_op = htons(FIP_OP_LS);\n\tif (op == ELS_LS_ACC || op == ELS_LS_RJT)\n\t\tcap->fip.fip_subcode = FIP_SC_REP;\n\telse\n\t\tcap->fip.fip_subcode = FIP_SC_REQ;\n\tcap->fip.fip_flags = htons(fip_flags);\n\n\tcap->encaps.fd_desc.fip_dtype = dtype;\n\tcap->encaps.fd_desc.fip_dlen = dlen / FIP_BPW;\n\n\tif (op != ELS_LS_RJT) {\n\t\tdlen += sizeof(*mac);\n\t\tmac = skb_put_zero(skb, sizeof(*mac));\n\t\tmac->fd_desc.fip_dtype = FIP_DT_MAC;\n\t\tmac->fd_desc.fip_dlen = sizeof(*mac) / FIP_BPW;\n\t\tif (dtype != FIP_DT_FLOGI && dtype != FIP_DT_FDISC) {\n\t\t\tmemcpy(mac->fd_mac, fip->get_src_addr(lport), ETH_ALEN);\n\t\t} else if (fip->mode == FIP_MODE_VN2VN) {\n\t\t\thton24(mac->fd_mac, FIP_VN_FC_MAP);\n\t\t\thton24(mac->fd_mac + 3, fip->port_id);\n\t\t} else if (fip_flags & FIP_FL_SPMA) {\n\t\t\tLIBFCOE_FIP_DBG(fip, \"FLOGI/FDISC sent with SPMA\\n\");\n\t\t\tmemcpy(mac->fd_mac, fip->ctl_src_addr, ETH_ALEN);\n\t\t} else {\n\t\t\tLIBFCOE_FIP_DBG(fip, \"FLOGI/FDISC sent with FPMA\\n\");\n\t\t\t \n\t\t}\n\t}\n\tcap->fip.fip_dl_len = htons(dlen / FIP_BPW);\n\n\tskb->protocol = htons(ETH_P_FIP);\n\tskb->priority = fip->priority;\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\treturn 0;\n}\n\n \nint fcoe_ctlr_els_send(struct fcoe_ctlr *fip, struct fc_lport *lport,\n\t\t       struct sk_buff *skb)\n{\n\tstruct fc_frame *fp;\n\tstruct fc_frame_header *fh;\n\tunsigned long flags;\n\tu16 old_xid;\n\tu8 op;\n\tu8 mac[ETH_ALEN];\n\n\tfp = container_of(skb, struct fc_frame, skb);\n\tfh = (struct fc_frame_header *)skb->data;\n\top = *(u8 *)(fh + 1);\n\n\tif (op == ELS_FLOGI && fip->mode != FIP_MODE_VN2VN) {\n\t\told_xid = fip->flogi_oxid;\n\t\tfip->flogi_oxid = ntohs(fh->fh_ox_id);\n\t\tif (fip->state == FIP_ST_AUTO) {\n\t\t\tif (old_xid == FC_XID_UNKNOWN)\n\t\t\t\tfip->flogi_count = 0;\n\t\t\tfip->flogi_count++;\n\t\t\tif (fip->flogi_count < 3)\n\t\t\t\tgoto drop;\n\t\t\tfcoe_ctlr_map_dest(fip);\n\t\t\treturn 0;\n\t\t}\n\t\tif (fip->state == FIP_ST_NON_FIP)\n\t\t\tfcoe_ctlr_map_dest(fip);\n\t}\n\n\tif (fip->state == FIP_ST_NON_FIP)\n\t\treturn 0;\n\tif (!fip->sel_fcf && fip->mode != FIP_MODE_VN2VN)\n\t\tgoto drop;\n\tswitch (op) {\n\tcase ELS_FLOGI:\n\t\top = FIP_DT_FLOGI;\n\t\tif (fip->mode == FIP_MODE_VN2VN)\n\t\t\tbreak;\n\t\tspin_lock_irqsave(&fip->ctlr_lock, flags);\n\t\tkfree_skb(fip->flogi_req);\n\t\tfip->flogi_req = skb;\n\t\tfip->flogi_req_send = 1;\n\t\tspin_unlock_irqrestore(&fip->ctlr_lock, flags);\n\t\tschedule_work(&fip->timer_work);\n\t\treturn -EINPROGRESS;\n\tcase ELS_FDISC:\n\t\tif (ntoh24(fh->fh_s_id))\n\t\t\treturn 0;\n\t\top = FIP_DT_FDISC;\n\t\tbreak;\n\tcase ELS_LOGO:\n\t\tif (fip->mode == FIP_MODE_VN2VN) {\n\t\t\tif (fip->state != FIP_ST_VNMP_UP)\n\t\t\t\tgoto drop;\n\t\t\tif (ntoh24(fh->fh_d_id) == FC_FID_FLOGI)\n\t\t\t\tgoto drop;\n\t\t} else {\n\t\t\tif (fip->state != FIP_ST_ENABLED)\n\t\t\t\treturn 0;\n\t\t\tif (ntoh24(fh->fh_d_id) != FC_FID_FLOGI)\n\t\t\t\treturn 0;\n\t\t}\n\t\top = FIP_DT_LOGO;\n\t\tbreak;\n\tcase ELS_LS_ACC:\n\t\t \n\t\tif (fip->state == FIP_ST_NON_FIP) {\n\t\t\tif (fip->flogi_oxid == FC_XID_UNKNOWN)\n\t\t\t\treturn 0;\n\t\t\tfip->flogi_oxid = FC_XID_UNKNOWN;\n\t\t\tfc_fcoe_set_mac(mac, fh->fh_d_id);\n\t\t\tfip->update_mac(lport, mac);\n\t\t}\n\t\tfallthrough;\n\tcase ELS_LS_RJT:\n\t\top = fr_encaps(fp);\n\t\tif (op)\n\t\t\tbreak;\n\t\treturn 0;\n\tdefault:\n\t\tif (fip->state != FIP_ST_ENABLED &&\n\t\t    fip->state != FIP_ST_VNMP_UP)\n\t\t\tgoto drop;\n\t\treturn 0;\n\t}\n\tLIBFCOE_FIP_DBG(fip, \"els_send op %u d_id %x\\n\",\n\t\t\top, ntoh24(fh->fh_d_id));\n\tif (fcoe_ctlr_encaps(fip, lport, op, skb, ntoh24(fh->fh_d_id)))\n\t\tgoto drop;\n\tfip->send(fip, skb);\n\treturn -EINPROGRESS;\ndrop:\n\tLIBFCOE_FIP_DBG(fip, \"drop els_send op %u d_id %x\\n\",\n\t\t\top, ntoh24(fh->fh_d_id));\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(fcoe_ctlr_els_send);\n\n \nstatic unsigned long fcoe_ctlr_age_fcfs(struct fcoe_ctlr *fip)\n{\n\tstruct fcoe_fcf *fcf;\n\tstruct fcoe_fcf *next;\n\tunsigned long next_timer = jiffies + msecs_to_jiffies(FIP_VN_KA_PERIOD);\n\tunsigned long deadline;\n\tunsigned long sel_time = 0;\n\tstruct list_head del_list;\n\n\tINIT_LIST_HEAD(&del_list);\n\n\tlist_for_each_entry_safe(fcf, next, &fip->fcfs, list) {\n\t\tdeadline = fcf->time + fcf->fka_period + fcf->fka_period / 2;\n\t\tif (fip->sel_fcf == fcf) {\n\t\t\tif (time_after(jiffies, deadline)) {\n\t\t\t\tu64 miss_cnt;\n\n\t\t\t\tmiss_cnt = this_cpu_inc_return(fip->lp->stats->MissDiscAdvCount);\n\t\t\t\tprintk(KERN_INFO \"libfcoe: host%d: \"\n\t\t\t\t       \"Missing Discovery Advertisement \"\n\t\t\t\t       \"for fab %16.16llx count %lld\\n\",\n\t\t\t\t       fip->lp->host->host_no, fcf->fabric_name,\n\t\t\t\t       miss_cnt);\n\t\t\t} else if (time_after(next_timer, deadline))\n\t\t\t\tnext_timer = deadline;\n\t\t}\n\n\t\tdeadline += fcf->fka_period;\n\t\tif (time_after_eq(jiffies, deadline)) {\n\t\t\tif (fip->sel_fcf == fcf)\n\t\t\t\tfip->sel_fcf = NULL;\n\t\t\t \n\t\t\tlist_del(&fcf->list);\n\t\t\tlist_add(&fcf->list, &del_list);\n\t\t\tthis_cpu_inc(fip->lp->stats->VLinkFailureCount);\n\t\t} else {\n\t\t\tif (time_after(next_timer, deadline))\n\t\t\t\tnext_timer = deadline;\n\t\t\tif (fcoe_ctlr_mtu_valid(fcf) &&\n\t\t\t    (!sel_time || time_before(sel_time, fcf->time)))\n\t\t\t\tsel_time = fcf->time;\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(fcf, next, &del_list, list) {\n\t\t \n\t\tfcoe_sysfs_fcf_del(fcf);\n\t}\n\n\tif (sel_time && !fip->sel_fcf && !fip->sel_time) {\n\t\tsel_time += msecs_to_jiffies(FCOE_CTLR_START_DELAY);\n\t\tfip->sel_time = sel_time;\n\t}\n\n\treturn next_timer;\n}\n\n \nstatic int fcoe_ctlr_parse_adv(struct fcoe_ctlr *fip,\n\t\t\t       struct sk_buff *skb, struct fcoe_fcf *fcf)\n{\n\tstruct fip_header *fiph;\n\tstruct fip_desc *desc = NULL;\n\tstruct fip_wwn_desc *wwn;\n\tstruct fip_fab_desc *fab;\n\tstruct fip_fka_desc *fka;\n\tunsigned long t;\n\tsize_t rlen;\n\tsize_t dlen;\n\tu32 desc_mask;\n\n\tmemset(fcf, 0, sizeof(*fcf));\n\tfcf->fka_period = msecs_to_jiffies(FCOE_CTLR_DEF_FKA);\n\n\tfiph = (struct fip_header *)skb->data;\n\tfcf->flags = ntohs(fiph->fip_flags);\n\n\t \n\tdesc_mask = BIT(FIP_DT_PRI) | BIT(FIP_DT_MAC) | BIT(FIP_DT_NAME) |\n\t\t\tBIT(FIP_DT_FAB) | BIT(FIP_DT_FKA);\n\n\trlen = ntohs(fiph->fip_dl_len) * 4;\n\tif (rlen + sizeof(*fiph) > skb->len)\n\t\treturn -EINVAL;\n\n\tdesc = (struct fip_desc *)(fiph + 1);\n\twhile (rlen > 0) {\n\t\tdlen = desc->fip_dlen * FIP_BPW;\n\t\tif (dlen < sizeof(*desc) || dlen > rlen)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif ((desc->fip_dtype < 32) &&\n\t\t    !(desc_mask & 1U << desc->fip_dtype)) {\n\t\t\tLIBFCOE_FIP_DBG(fip, \"Duplicate Critical \"\n\t\t\t\t\t\"Descriptors in FIP adv\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (desc->fip_dtype) {\n\t\tcase FIP_DT_PRI:\n\t\t\tif (dlen != sizeof(struct fip_pri_desc))\n\t\t\t\tgoto len_err;\n\t\t\tfcf->pri = ((struct fip_pri_desc *)desc)->fd_pri;\n\t\t\tdesc_mask &= ~BIT(FIP_DT_PRI);\n\t\t\tbreak;\n\t\tcase FIP_DT_MAC:\n\t\t\tif (dlen != sizeof(struct fip_mac_desc))\n\t\t\t\tgoto len_err;\n\t\t\tmemcpy(fcf->fcf_mac,\n\t\t\t       ((struct fip_mac_desc *)desc)->fd_mac,\n\t\t\t       ETH_ALEN);\n\t\t\tmemcpy(fcf->fcoe_mac, fcf->fcf_mac, ETH_ALEN);\n\t\t\tif (!is_valid_ether_addr(fcf->fcf_mac)) {\n\t\t\t\tLIBFCOE_FIP_DBG(fip,\n\t\t\t\t\t\"Invalid MAC addr %pM in FIP adv\\n\",\n\t\t\t\t\tfcf->fcf_mac);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tdesc_mask &= ~BIT(FIP_DT_MAC);\n\t\t\tbreak;\n\t\tcase FIP_DT_NAME:\n\t\t\tif (dlen != sizeof(struct fip_wwn_desc))\n\t\t\t\tgoto len_err;\n\t\t\twwn = (struct fip_wwn_desc *)desc;\n\t\t\tfcf->switch_name = get_unaligned_be64(&wwn->fd_wwn);\n\t\t\tdesc_mask &= ~BIT(FIP_DT_NAME);\n\t\t\tbreak;\n\t\tcase FIP_DT_FAB:\n\t\t\tif (dlen != sizeof(struct fip_fab_desc))\n\t\t\t\tgoto len_err;\n\t\t\tfab = (struct fip_fab_desc *)desc;\n\t\t\tfcf->fabric_name = get_unaligned_be64(&fab->fd_wwn);\n\t\t\tfcf->vfid = ntohs(fab->fd_vfid);\n\t\t\tfcf->fc_map = ntoh24(fab->fd_map);\n\t\t\tdesc_mask &= ~BIT(FIP_DT_FAB);\n\t\t\tbreak;\n\t\tcase FIP_DT_FKA:\n\t\t\tif (dlen != sizeof(struct fip_fka_desc))\n\t\t\t\tgoto len_err;\n\t\t\tfka = (struct fip_fka_desc *)desc;\n\t\t\tif (fka->fd_flags & FIP_FKA_ADV_D)\n\t\t\t\tfcf->fd_flags = 1;\n\t\t\tt = ntohl(fka->fd_fka_period);\n\t\t\tif (t >= FCOE_CTLR_MIN_FKA)\n\t\t\t\tfcf->fka_period = msecs_to_jiffies(t);\n\t\t\tdesc_mask &= ~BIT(FIP_DT_FKA);\n\t\t\tbreak;\n\t\tcase FIP_DT_MAP_OUI:\n\t\tcase FIP_DT_FCOE_SIZE:\n\t\tcase FIP_DT_FLOGI:\n\t\tcase FIP_DT_FDISC:\n\t\tcase FIP_DT_LOGO:\n\t\tcase FIP_DT_ELP:\n\t\tdefault:\n\t\t\tLIBFCOE_FIP_DBG(fip, \"unexpected descriptor type %x \"\n\t\t\t\t\t\"in FIP adv\\n\", desc->fip_dtype);\n\t\t\t \n\t\t\tif (desc->fip_dtype < FIP_DT_NON_CRITICAL)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tdesc = (struct fip_desc *)((char *)desc + dlen);\n\t\trlen -= dlen;\n\t}\n\tif (!fcf->fc_map || (fcf->fc_map & 0x10000))\n\t\treturn -EINVAL;\n\tif (!fcf->switch_name)\n\t\treturn -EINVAL;\n\tif (desc_mask) {\n\t\tLIBFCOE_FIP_DBG(fip, \"adv missing descriptors mask %x\\n\",\n\t\t\t\tdesc_mask);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\nlen_err:\n\tLIBFCOE_FIP_DBG(fip, \"FIP length error in descriptor type %x len %zu\\n\",\n\t\t\tdesc->fip_dtype, dlen);\n\treturn -EINVAL;\n}\n\n \nstatic void fcoe_ctlr_recv_adv(struct fcoe_ctlr *fip, struct sk_buff *skb)\n{\n\tstruct fcoe_fcf *fcf;\n\tstruct fcoe_fcf new;\n\tunsigned long sol_tov = msecs_to_jiffies(FCOE_CTLR_SOL_TOV);\n\tint first = 0;\n\tint mtu_valid;\n\tint found = 0;\n\tint rc = 0;\n\n\tif (fcoe_ctlr_parse_adv(fip, skb, &new))\n\t\treturn;\n\n\tmutex_lock(&fip->ctlr_mutex);\n\tfirst = list_empty(&fip->fcfs);\n\tlist_for_each_entry(fcf, &fip->fcfs, list) {\n\t\tif (fcf->switch_name == new.switch_name &&\n\t\t    fcf->fabric_name == new.fabric_name &&\n\t\t    fcf->fc_map == new.fc_map &&\n\t\t    ether_addr_equal(fcf->fcf_mac, new.fcf_mac)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tif (fip->fcf_count >= FCOE_CTLR_FCF_LIMIT)\n\t\t\tgoto out;\n\n\t\tfcf = kmalloc(sizeof(*fcf), GFP_ATOMIC);\n\t\tif (!fcf)\n\t\t\tgoto out;\n\n\t\tmemcpy(fcf, &new, sizeof(new));\n\t\tfcf->fip = fip;\n\t\trc = fcoe_sysfs_fcf_add(fcf);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Failed to allocate sysfs instance \"\n\t\t\t       \"for FCF, fab %16.16llx mac %pM\\n\",\n\t\t\t       new.fabric_name, new.fcf_mac);\n\t\t\tkfree(fcf);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tfcf->fd_flags = new.fd_flags;\n\t\tif (!fcoe_ctlr_fcf_usable(fcf))\n\t\t\tfcf->flags = new.flags;\n\n\t\tif (fcf == fip->sel_fcf && !fcf->fd_flags) {\n\t\t\tfip->ctlr_ka_time -= fcf->fka_period;\n\t\t\tfip->ctlr_ka_time += new.fka_period;\n\t\t\tif (time_before(fip->ctlr_ka_time, fip->timer.expires))\n\t\t\t\tmod_timer(&fip->timer, fip->ctlr_ka_time);\n\t\t}\n\t\tfcf->fka_period = new.fka_period;\n\t\tmemcpy(fcf->fcf_mac, new.fcf_mac, ETH_ALEN);\n\t}\n\n\tmtu_valid = fcoe_ctlr_mtu_valid(fcf);\n\tfcf->time = jiffies;\n\tif (!found)\n\t\tLIBFCOE_FIP_DBG(fip, \"New FCF fab %16.16llx mac %pM\\n\",\n\t\t\t\tfcf->fabric_name, fcf->fcf_mac);\n\n\t \n\tif (!mtu_valid)\n\t\tfcoe_ctlr_solicit(fip, fcf);\n\n\t \n\tif (first && time_after(jiffies, fip->sol_time + sol_tov))\n\t\tfcoe_ctlr_solicit(fip, NULL);\n\n\t \n\tif (mtu_valid)\n\t\tlist_move(&fcf->list, &fip->fcfs);\n\n\t \n\tif (mtu_valid && !fip->sel_fcf && !fip->sel_time &&\n\t    fcoe_ctlr_fcf_usable(fcf)) {\n\t\tfip->sel_time = jiffies +\n\t\t\tmsecs_to_jiffies(FCOE_CTLR_START_DELAY);\n\t\tif (!timer_pending(&fip->timer) ||\n\t\t    time_before(fip->sel_time, fip->timer.expires))\n\t\t\tmod_timer(&fip->timer, fip->sel_time);\n\t}\n\nout:\n\tmutex_unlock(&fip->ctlr_mutex);\n}\n\n \nstatic void fcoe_ctlr_recv_els(struct fcoe_ctlr *fip, struct sk_buff *skb)\n{\n\tstruct fc_lport *lport = fip->lp;\n\tstruct fip_header *fiph;\n\tstruct fc_frame *fp = (struct fc_frame *)skb;\n\tstruct fc_frame_header *fh = NULL;\n\tstruct fip_desc *desc;\n\tstruct fip_encaps *els;\n\tstruct fcoe_fcf *sel;\n\tenum fip_desc_type els_dtype = 0;\n\tu8 els_op;\n\tu8 sub;\n\tu8 granted_mac[ETH_ALEN] = { 0 };\n\tsize_t els_len = 0;\n\tsize_t rlen;\n\tsize_t dlen;\n\tu32 desc_mask = 0;\n\tu32 desc_cnt = 0;\n\n\tfiph = (struct fip_header *)skb->data;\n\tsub = fiph->fip_subcode;\n\tif (sub != FIP_SC_REQ && sub != FIP_SC_REP)\n\t\tgoto drop;\n\n\trlen = ntohs(fiph->fip_dl_len) * 4;\n\tif (rlen + sizeof(*fiph) > skb->len)\n\t\tgoto drop;\n\n\tdesc = (struct fip_desc *)(fiph + 1);\n\twhile (rlen > 0) {\n\t\tdesc_cnt++;\n\t\tdlen = desc->fip_dlen * FIP_BPW;\n\t\tif (dlen < sizeof(*desc) || dlen > rlen)\n\t\t\tgoto drop;\n\t\t \n\t\tif (desc->fip_dtype < 32) {\n\t\t\tif ((desc->fip_dtype != FIP_DT_MAC) &&\n\t\t\t    (desc_mask & 1U << desc->fip_dtype)) {\n\t\t\t\tLIBFCOE_FIP_DBG(fip, \"Duplicate Critical \"\n\t\t\t\t\t\t\"Descriptors in FIP ELS\\n\");\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tdesc_mask |= (1 << desc->fip_dtype);\n\t\t}\n\t\tswitch (desc->fip_dtype) {\n\t\tcase FIP_DT_MAC:\n\t\t\tsel = fip->sel_fcf;\n\t\t\tif (desc_cnt == 1) {\n\t\t\t\tLIBFCOE_FIP_DBG(fip, \"FIP descriptors \"\n\t\t\t\t\t\t\"received out of order\\n\");\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\t \n\t\t\tif (desc_cnt == 2)\n\t\t\t\tmemcpy(granted_mac,\n\t\t\t\t       ((struct fip_mac_desc *)desc)->fd_mac,\n\t\t\t\t       ETH_ALEN);\n\n\t\t\tif (dlen != sizeof(struct fip_mac_desc))\n\t\t\t\tgoto len_err;\n\n\t\t\tif ((desc_cnt == 3) && (sel))\n\t\t\t\tmemcpy(sel->fcoe_mac,\n\t\t\t\t       ((struct fip_mac_desc *)desc)->fd_mac,\n\t\t\t\t       ETH_ALEN);\n\t\t\tbreak;\n\t\tcase FIP_DT_FLOGI:\n\t\tcase FIP_DT_FDISC:\n\t\tcase FIP_DT_LOGO:\n\t\tcase FIP_DT_ELP:\n\t\t\tif (desc_cnt != 1) {\n\t\t\t\tLIBFCOE_FIP_DBG(fip, \"FIP descriptors \"\n\t\t\t\t\t\t\"received out of order\\n\");\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tif (fh)\n\t\t\t\tgoto drop;\n\t\t\tif (dlen < sizeof(*els) + sizeof(*fh) + 1)\n\t\t\t\tgoto len_err;\n\t\t\tels_len = dlen - sizeof(*els);\n\t\t\tels = (struct fip_encaps *)desc;\n\t\t\tfh = (struct fc_frame_header *)(els + 1);\n\t\t\tels_dtype = desc->fip_dtype;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLIBFCOE_FIP_DBG(fip, \"unexpected descriptor type %x \"\n\t\t\t\t\t\"in FIP adv\\n\", desc->fip_dtype);\n\t\t\t \n\t\t\tif (desc->fip_dtype < FIP_DT_NON_CRITICAL)\n\t\t\t\tgoto drop;\n\t\t\tif (desc_cnt <= 2) {\n\t\t\t\tLIBFCOE_FIP_DBG(fip, \"FIP descriptors \"\n\t\t\t\t\t\t\"received out of order\\n\");\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdesc = (struct fip_desc *)((char *)desc + dlen);\n\t\trlen -= dlen;\n\t}\n\n\tif (!fh)\n\t\tgoto drop;\n\tels_op = *(u8 *)(fh + 1);\n\n\tif ((els_dtype == FIP_DT_FLOGI || els_dtype == FIP_DT_FDISC) &&\n\t    sub == FIP_SC_REP && fip->mode != FIP_MODE_VN2VN) {\n\t\tif (els_op == ELS_LS_ACC) {\n\t\t\tif (!is_valid_ether_addr(granted_mac)) {\n\t\t\t\tLIBFCOE_FIP_DBG(fip,\n\t\t\t\t\t\"Invalid MAC address %pM in FIP ELS\\n\",\n\t\t\t\t\tgranted_mac);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tmemcpy(fr_cb(fp)->granted_mac, granted_mac, ETH_ALEN);\n\n\t\t\tif (fip->flogi_oxid == ntohs(fh->fh_ox_id)) {\n\t\t\t\tfip->flogi_oxid = FC_XID_UNKNOWN;\n\t\t\t\tif (els_dtype == FIP_DT_FLOGI)\n\t\t\t\t\tfcoe_ctlr_announce(fip);\n\t\t\t}\n\t\t} else if (els_dtype == FIP_DT_FLOGI &&\n\t\t\t   !fcoe_ctlr_flogi_retry(fip))\n\t\t\tgoto drop;\t \n\t}\n\n\tif ((desc_cnt == 0) || ((els_op != ELS_LS_RJT) &&\n\t    (!(1U << FIP_DT_MAC & desc_mask)))) {\n\t\tLIBFCOE_FIP_DBG(fip, \"Missing critical descriptors \"\n\t\t\t\t\"in FIP ELS\\n\");\n\t\tgoto drop;\n\t}\n\n\t \n\tskb_pull(skb, (u8 *)fh - skb->data);\n\tskb_trim(skb, els_len);\n\tfp = (struct fc_frame *)skb;\n\tfc_frame_init(fp);\n\tfr_sof(fp) = FC_SOF_I3;\n\tfr_eof(fp) = FC_EOF_T;\n\tfr_dev(fp) = lport;\n\tfr_encaps(fp) = els_dtype;\n\n\tthis_cpu_inc(lport->stats->RxFrames);\n\tthis_cpu_add(lport->stats->RxWords, skb->len / FIP_BPW);\n\n\tfc_exch_recv(lport, fp);\n\treturn;\n\nlen_err:\n\tLIBFCOE_FIP_DBG(fip, \"FIP length error in descriptor type %x len %zu\\n\",\n\t\t\tdesc->fip_dtype, dlen);\ndrop:\n\tkfree_skb(skb);\n}\n\n \nstatic void fcoe_ctlr_recv_clr_vlink(struct fcoe_ctlr *fip,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct fip_desc *desc;\n\tstruct fip_mac_desc *mp;\n\tstruct fip_wwn_desc *wp;\n\tstruct fip_vn_desc *vp;\n\tsize_t rlen;\n\tsize_t dlen;\n\tstruct fcoe_fcf *fcf = fip->sel_fcf;\n\tstruct fc_lport *lport = fip->lp;\n\tstruct fc_lport *vn_port = NULL;\n\tu32 desc_mask;\n\tint num_vlink_desc;\n\tint reset_phys_port = 0;\n\tstruct fip_vn_desc **vlink_desc_arr = NULL;\n\tstruct fip_header *fh = (struct fip_header *)skb->data;\n\tstruct ethhdr *eh = eth_hdr(skb);\n\n\tLIBFCOE_FIP_DBG(fip, \"Clear Virtual Link received\\n\");\n\n\tif (!fcf) {\n\t\t \n\t\tLIBFCOE_FIP_DBG(fip, \"Resetting fcoe_ctlr as FCF has not been \"\n\t\t    \"selected yet\\n\");\n\t\tmutex_lock(&fip->ctlr_mutex);\n\t\tfcoe_ctlr_reset(fip);\n\t\tmutex_unlock(&fip->ctlr_mutex);\n\t\treturn;\n\t}\n\n\t \n\tif (!ether_addr_equal(eh->h_source, fcf->fcf_mac)) {\n\t\tLIBFCOE_FIP_DBG(fip, \"Dropping CVL due to source address \"\n\t\t    \"mismatch with FCF src=%pM\\n\", eh->h_source);\n\t\treturn;\n\t}\n\n\t \n\tif (!lport->port_id) {\n\t\tLIBFCOE_FIP_DBG(fip, \"lport not logged in, resoliciting\\n\");\n\t\tmutex_lock(&fip->ctlr_mutex);\n\t\tfcoe_ctlr_reset(fip);\n\t\tmutex_unlock(&fip->ctlr_mutex);\n\t\tfc_lport_reset(fip->lp);\n\t\tfcoe_ctlr_solicit(fip, NULL);\n\t\treturn;\n\t}\n\n\t \n\tdesc_mask = BIT(FIP_DT_MAC) | BIT(FIP_DT_NAME);\n\n\trlen = ntohs(fh->fip_dl_len) * FIP_BPW;\n\tdesc = (struct fip_desc *)(fh + 1);\n\n\t \n\tnum_vlink_desc = rlen / sizeof(*vp);\n\tif (num_vlink_desc)\n\t\tvlink_desc_arr = kmalloc_array(num_vlink_desc, sizeof(vp),\n\t\t\t\t\t       GFP_ATOMIC);\n\tif (!vlink_desc_arr)\n\t\treturn;\n\tnum_vlink_desc = 0;\n\n\twhile (rlen >= sizeof(*desc)) {\n\t\tdlen = desc->fip_dlen * FIP_BPW;\n\t\tif (dlen > rlen)\n\t\t\tgoto err;\n\t\t \n\t\tif ((desc->fip_dtype < 32) &&\n\t\t    (desc->fip_dtype != FIP_DT_VN_ID) &&\n\t\t    !(desc_mask & 1U << desc->fip_dtype)) {\n\t\t\tLIBFCOE_FIP_DBG(fip, \"Duplicate Critical \"\n\t\t\t\t\t\"Descriptors in FIP CVL\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tswitch (desc->fip_dtype) {\n\t\tcase FIP_DT_MAC:\n\t\t\tmp = (struct fip_mac_desc *)desc;\n\t\t\tif (dlen < sizeof(*mp))\n\t\t\t\tgoto err;\n\t\t\tif (!ether_addr_equal(mp->fd_mac, fcf->fcf_mac))\n\t\t\t\tgoto err;\n\t\t\tdesc_mask &= ~BIT(FIP_DT_MAC);\n\t\t\tbreak;\n\t\tcase FIP_DT_NAME:\n\t\t\twp = (struct fip_wwn_desc *)desc;\n\t\t\tif (dlen < sizeof(*wp))\n\t\t\t\tgoto err;\n\t\t\tif (get_unaligned_be64(&wp->fd_wwn) != fcf->switch_name)\n\t\t\t\tgoto err;\n\t\t\tdesc_mask &= ~BIT(FIP_DT_NAME);\n\t\t\tbreak;\n\t\tcase FIP_DT_VN_ID:\n\t\t\tvp = (struct fip_vn_desc *)desc;\n\t\t\tif (dlen < sizeof(*vp))\n\t\t\t\tgoto err;\n\t\t\tvlink_desc_arr[num_vlink_desc++] = vp;\n\t\t\tvn_port = fc_vport_id_lookup(lport,\n\t\t\t\t\t\t      ntoh24(vp->fd_fc_id));\n\t\t\tif (vn_port && (vn_port == lport)) {\n\t\t\t\tmutex_lock(&fip->ctlr_mutex);\n\t\t\t\tthis_cpu_inc(lport->stats->VLinkFailureCount);\n\t\t\t\tfcoe_ctlr_reset(fip);\n\t\t\t\tmutex_unlock(&fip->ctlr_mutex);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tif (desc->fip_dtype < FIP_DT_NON_CRITICAL)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\t}\n\t\tdesc = (struct fip_desc *)((char *)desc + dlen);\n\t\trlen -= dlen;\n\t}\n\n\t \n\tif (desc_mask)\n\t\tLIBFCOE_FIP_DBG(fip, \"missing descriptors mask %x\\n\",\n\t\t\t\tdesc_mask);\n\telse if (!num_vlink_desc) {\n\t\tLIBFCOE_FIP_DBG(fip, \"CVL: no Vx_Port descriptor found\\n\");\n\t\t \n\t\tmutex_lock(&fip->ctlr_mutex);\n\t\tthis_cpu_inc(lport->stats->VLinkFailureCount);\n\t\tfcoe_ctlr_reset(fip);\n\t\tmutex_unlock(&fip->ctlr_mutex);\n\n\t\tmutex_lock(&lport->lp_mutex);\n\t\tlist_for_each_entry(vn_port, &lport->vports, list)\n\t\t\tfc_lport_reset(vn_port);\n\t\tmutex_unlock(&lport->lp_mutex);\n\n\t\tfc_lport_reset(fip->lp);\n\t\tfcoe_ctlr_solicit(fip, NULL);\n\t} else {\n\t\tint i;\n\n\t\tLIBFCOE_FIP_DBG(fip, \"performing Clear Virtual Link\\n\");\n\t\tfor (i = 0; i < num_vlink_desc; i++) {\n\t\t\tvp = vlink_desc_arr[i];\n\t\t\tvn_port = fc_vport_id_lookup(lport,\n\t\t\t\t\t\t     ntoh24(vp->fd_fc_id));\n\t\t\tif (!vn_port)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!ether_addr_equal(fip->get_src_addr(vn_port),\n\t\t\t\t\t      vp->fd_mac) ||\n\t\t\t\tget_unaligned_be64(&vp->fd_wwpn) !=\n\t\t\t\t\t\t\tvn_port->wwpn)\n\t\t\t\tcontinue;\n\n\t\t\tif (vn_port == lport)\n\t\t\t\t \n\t\t\t\treset_phys_port = 1;\n\t\t\telse     \n\t\t\t\tfc_lport_reset(vn_port);\n\t\t}\n\n\t\tif (reset_phys_port) {\n\t\t\tfc_lport_reset(fip->lp);\n\t\t\tfcoe_ctlr_solicit(fip, NULL);\n\t\t}\n\t}\n\nerr:\n\tkfree(vlink_desc_arr);\n}\n\n \nvoid fcoe_ctlr_recv(struct fcoe_ctlr *fip, struct sk_buff *skb)\n{\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\tskb_queue_tail(&fip->fip_recv_list, skb);\n\tschedule_work(&fip->recv_work);\n}\nEXPORT_SYMBOL(fcoe_ctlr_recv);\n\n \nstatic int fcoe_ctlr_recv_handler(struct fcoe_ctlr *fip, struct sk_buff *skb)\n{\n\tstruct fip_header *fiph;\n\tstruct ethhdr *eh;\n\tenum fip_state state;\n\tbool fip_vlan_resp = false;\n\tu16 op;\n\tu8 sub;\n\n\tif (skb_linearize(skb))\n\t\tgoto drop;\n\tif (skb->len < sizeof(*fiph))\n\t\tgoto drop;\n\teh = eth_hdr(skb);\n\tif (fip->mode == FIP_MODE_VN2VN) {\n\t\tif (!ether_addr_equal(eh->h_dest, fip->ctl_src_addr) &&\n\t\t    !ether_addr_equal(eh->h_dest, fcoe_all_vn2vn) &&\n\t\t    !ether_addr_equal(eh->h_dest, fcoe_all_p2p))\n\t\t\tgoto drop;\n\t} else if (!ether_addr_equal(eh->h_dest, fip->ctl_src_addr) &&\n\t\t   !ether_addr_equal(eh->h_dest, fcoe_all_enode))\n\t\tgoto drop;\n\tfiph = (struct fip_header *)skb->data;\n\top = ntohs(fiph->fip_op);\n\tsub = fiph->fip_subcode;\n\n\tif (FIP_VER_DECAPS(fiph->fip_ver) != FIP_VER)\n\t\tgoto drop;\n\tif (ntohs(fiph->fip_dl_len) * FIP_BPW + sizeof(*fiph) > skb->len)\n\t\tgoto drop;\n\n\tmutex_lock(&fip->ctlr_mutex);\n\tstate = fip->state;\n\tif (state == FIP_ST_AUTO) {\n\t\tfip->map_dest = 0;\n\t\tfcoe_ctlr_set_state(fip, FIP_ST_ENABLED);\n\t\tstate = FIP_ST_ENABLED;\n\t\tLIBFCOE_FIP_DBG(fip, \"Using FIP mode\\n\");\n\t}\n\tfip_vlan_resp = fip->fip_resp;\n\tmutex_unlock(&fip->ctlr_mutex);\n\n\tif (fip->mode == FIP_MODE_VN2VN && op == FIP_OP_VN2VN)\n\t\treturn fcoe_ctlr_vn_recv(fip, skb);\n\n\tif (fip_vlan_resp && op == FIP_OP_VLAN) {\n\t\tLIBFCOE_FIP_DBG(fip, \"fip vlan discovery\\n\");\n\t\treturn fcoe_ctlr_vlan_recv(fip, skb);\n\t}\n\n\tif (state != FIP_ST_ENABLED && state != FIP_ST_VNMP_UP &&\n\t    state != FIP_ST_VNMP_CLAIM)\n\t\tgoto drop;\n\n\tif (op == FIP_OP_LS) {\n\t\tfcoe_ctlr_recv_els(fip, skb);\t \n\t\treturn 0;\n\t}\n\n\tif (state != FIP_ST_ENABLED)\n\t\tgoto drop;\n\n\tif (op == FIP_OP_DISC && sub == FIP_SC_ADV)\n\t\tfcoe_ctlr_recv_adv(fip, skb);\n\telse if (op == FIP_OP_CTRL && sub == FIP_SC_CLR_VLINK)\n\t\tfcoe_ctlr_recv_clr_vlink(fip, skb);\n\tkfree_skb(skb);\n\treturn 0;\ndrop:\n\tkfree_skb(skb);\n\treturn -1;\n}\n\n \nstatic struct fcoe_fcf *fcoe_ctlr_select(struct fcoe_ctlr *fip)\n{\n\tstruct fcoe_fcf *fcf;\n\tstruct fcoe_fcf *best = fip->sel_fcf;\n\n\tlist_for_each_entry(fcf, &fip->fcfs, list) {\n\t\tLIBFCOE_FIP_DBG(fip, \"consider FCF fab %16.16llx \"\n\t\t\t\t\"VFID %d mac %pM map %x val %d \"\n\t\t\t\t\"sent %u pri %u\\n\",\n\t\t\t\tfcf->fabric_name, fcf->vfid, fcf->fcf_mac,\n\t\t\t\tfcf->fc_map, fcoe_ctlr_mtu_valid(fcf),\n\t\t\t\tfcf->flogi_sent, fcf->pri);\n\t\tif (!fcoe_ctlr_fcf_usable(fcf)) {\n\t\t\tLIBFCOE_FIP_DBG(fip, \"FCF for fab %16.16llx \"\n\t\t\t\t\t\"map %x %svalid %savailable\\n\",\n\t\t\t\t\tfcf->fabric_name, fcf->fc_map,\n\t\t\t\t\t(fcf->flags & FIP_FL_SOL) ? \"\" : \"in\",\n\t\t\t\t\t(fcf->flags & FIP_FL_AVAIL) ?\n\t\t\t\t\t\"\" : \"un\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!best || fcf->pri < best->pri || best->flogi_sent)\n\t\t\tbest = fcf;\n\t\tif (fcf->fabric_name != best->fabric_name ||\n\t\t    fcf->vfid != best->vfid ||\n\t\t    fcf->fc_map != best->fc_map) {\n\t\t\tLIBFCOE_FIP_DBG(fip, \"Conflicting fabric, VFID, \"\n\t\t\t\t\t\"or FC-MAP\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tfip->sel_fcf = best;\n\tif (best) {\n\t\tLIBFCOE_FIP_DBG(fip, \"using FCF mac %pM\\n\", best->fcf_mac);\n\t\tfip->port_ka_time = jiffies +\n\t\t\tmsecs_to_jiffies(FIP_VN_KA_PERIOD);\n\t\tfip->ctlr_ka_time = jiffies + best->fka_period;\n\t\tif (time_before(fip->ctlr_ka_time, fip->timer.expires))\n\t\t\tmod_timer(&fip->timer, fip->ctlr_ka_time);\n\t}\n\treturn best;\n}\n\n \nstatic int fcoe_ctlr_flogi_send_locked(struct fcoe_ctlr *fip)\n{\n\tstruct sk_buff *skb;\n\tstruct sk_buff *skb_orig;\n\tstruct fc_frame_header *fh;\n\tint error;\n\n\tskb_orig = fip->flogi_req;\n\tif (!skb_orig)\n\t\treturn -EINVAL;\n\n\t \n\tskb = skb_clone(skb_orig, GFP_ATOMIC);\n\tif (!skb) {\n\t\tskb = skb_orig;\n\t\tfip->flogi_req = NULL;\n\t}\n\tfh = (struct fc_frame_header *)skb->data;\n\terror = fcoe_ctlr_encaps(fip, fip->lp, FIP_DT_FLOGI, skb,\n\t\t\t\t ntoh24(fh->fh_d_id));\n\tif (error) {\n\t\tkfree_skb(skb);\n\t\treturn error;\n\t}\n\tfip->send(fip, skb);\n\tfip->sel_fcf->flogi_sent = 1;\n\treturn 0;\n}\n\n \nstatic int fcoe_ctlr_flogi_retry(struct fcoe_ctlr *fip)\n{\n\tstruct fcoe_fcf *fcf;\n\tunsigned long flags;\n\tint error;\n\n\tmutex_lock(&fip->ctlr_mutex);\n\tspin_lock_irqsave(&fip->ctlr_lock, flags);\n\tLIBFCOE_FIP_DBG(fip, \"re-sending FLOGI - reselect\\n\");\n\tfcf = fcoe_ctlr_select(fip);\n\tif (!fcf || fcf->flogi_sent) {\n\t\tkfree_skb(fip->flogi_req);\n\t\tfip->flogi_req = NULL;\n\t\terror = -ENOENT;\n\t} else {\n\t\tfcoe_ctlr_solicit(fip, NULL);\n\t\terror = fcoe_ctlr_flogi_send_locked(fip);\n\t}\n\tspin_unlock_irqrestore(&fip->ctlr_lock, flags);\n\tmutex_unlock(&fip->ctlr_mutex);\n\treturn error;\n}\n\n\n \nstatic void fcoe_ctlr_flogi_send(struct fcoe_ctlr *fip)\n{\n\tstruct fcoe_fcf *fcf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fip->ctlr_lock, flags);\n\tfcf = fip->sel_fcf;\n\tif (!fcf || !fip->flogi_req_send)\n\t\tgoto unlock;\n\n\tLIBFCOE_FIP_DBG(fip, \"sending FLOGI\\n\");\n\n\t \n\tif (fcf->flogi_sent) {\n\t\tLIBFCOE_FIP_DBG(fip, \"sending FLOGI - reselect\\n\");\n\t\tfcf = fcoe_ctlr_select(fip);\n\t\tif (!fcf || fcf->flogi_sent) {\n\t\t\tLIBFCOE_FIP_DBG(fip, \"sending FLOGI - clearing\\n\");\n\t\t\tlist_for_each_entry(fcf, &fip->fcfs, list)\n\t\t\t\tfcf->flogi_sent = 0;\n\t\t\tfcf = fcoe_ctlr_select(fip);\n\t\t}\n\t}\n\tif (fcf) {\n\t\tfcoe_ctlr_flogi_send_locked(fip);\n\t\tfip->flogi_req_send = 0;\n\t} else  \n\t\tLIBFCOE_FIP_DBG(fip, \"No FCF selected - defer send\\n\");\nunlock:\n\tspin_unlock_irqrestore(&fip->ctlr_lock, flags);\n}\n\n \nstatic void fcoe_ctlr_timeout(struct timer_list *t)\n{\n\tstruct fcoe_ctlr *fip = from_timer(fip, t, timer);\n\n\tschedule_work(&fip->timer_work);\n}\n\n \nstatic void fcoe_ctlr_timer_work(struct work_struct *work)\n{\n\tstruct fcoe_ctlr *fip;\n\tstruct fc_lport *vport;\n\tu8 *mac;\n\tu8 reset = 0;\n\tu8 send_ctlr_ka = 0;\n\tu8 send_port_ka = 0;\n\tstruct fcoe_fcf *sel;\n\tstruct fcoe_fcf *fcf;\n\tunsigned long next_timer;\n\n\tfip = container_of(work, struct fcoe_ctlr, timer_work);\n\tif (fip->mode == FIP_MODE_VN2VN)\n\t\treturn fcoe_ctlr_vn_timeout(fip);\n\tmutex_lock(&fip->ctlr_mutex);\n\tif (fip->state == FIP_ST_DISABLED) {\n\t\tmutex_unlock(&fip->ctlr_mutex);\n\t\treturn;\n\t}\n\n\tfcf = fip->sel_fcf;\n\tnext_timer = fcoe_ctlr_age_fcfs(fip);\n\n\tsel = fip->sel_fcf;\n\tif (!sel && fip->sel_time) {\n\t\tif (time_after_eq(jiffies, fip->sel_time)) {\n\t\t\tsel = fcoe_ctlr_select(fip);\n\t\t\tfip->sel_time = 0;\n\t\t} else if (time_after(next_timer, fip->sel_time))\n\t\t\tnext_timer = fip->sel_time;\n\t}\n\n\tif (sel && fip->flogi_req_send)\n\t\tfcoe_ctlr_flogi_send(fip);\n\telse if (!sel && fcf)\n\t\treset = 1;\n\n\tif (sel && !sel->fd_flags) {\n\t\tif (time_after_eq(jiffies, fip->ctlr_ka_time)) {\n\t\t\tfip->ctlr_ka_time = jiffies + sel->fka_period;\n\t\t\tsend_ctlr_ka = 1;\n\t\t}\n\t\tif (time_after(next_timer, fip->ctlr_ka_time))\n\t\t\tnext_timer = fip->ctlr_ka_time;\n\n\t\tif (time_after_eq(jiffies, fip->port_ka_time)) {\n\t\t\tfip->port_ka_time = jiffies +\n\t\t\t\tmsecs_to_jiffies(FIP_VN_KA_PERIOD);\n\t\t\tsend_port_ka = 1;\n\t\t}\n\t\tif (time_after(next_timer, fip->port_ka_time))\n\t\t\tnext_timer = fip->port_ka_time;\n\t}\n\tif (!list_empty(&fip->fcfs))\n\t\tmod_timer(&fip->timer, next_timer);\n\tmutex_unlock(&fip->ctlr_mutex);\n\n\tif (reset) {\n\t\tfc_lport_reset(fip->lp);\n\t\t \n\t\tfcoe_ctlr_solicit(fip, NULL);\n\t}\n\n\tif (send_ctlr_ka)\n\t\tfcoe_ctlr_send_keep_alive(fip, NULL, 0, fip->ctl_src_addr);\n\n\tif (send_port_ka) {\n\t\tmutex_lock(&fip->lp->lp_mutex);\n\t\tmac = fip->get_src_addr(fip->lp);\n\t\tfcoe_ctlr_send_keep_alive(fip, fip->lp, 1, mac);\n\t\tlist_for_each_entry(vport, &fip->lp->vports, list) {\n\t\t\tmac = fip->get_src_addr(vport);\n\t\t\tfcoe_ctlr_send_keep_alive(fip, vport, 1, mac);\n\t\t}\n\t\tmutex_unlock(&fip->lp->lp_mutex);\n\t}\n}\n\n \nstatic void fcoe_ctlr_recv_work(struct work_struct *recv_work)\n{\n\tstruct fcoe_ctlr *fip;\n\tstruct sk_buff *skb;\n\n\tfip = container_of(recv_work, struct fcoe_ctlr, recv_work);\n\twhile ((skb = skb_dequeue(&fip->fip_recv_list)))\n\t\tfcoe_ctlr_recv_handler(fip, skb);\n}\n\n \nint fcoe_ctlr_recv_flogi(struct fcoe_ctlr *fip, struct fc_lport *lport,\n\t\t\t struct fc_frame *fp)\n{\n\tstruct fc_frame_header *fh;\n\tu8 op;\n\tu8 *sa;\n\n\tsa = eth_hdr(&fp->skb)->h_source;\n\tfh = fc_frame_header_get(fp);\n\tif (fh->fh_type != FC_TYPE_ELS)\n\t\treturn 0;\n\n\top = fc_frame_payload_op(fp);\n\tif (op == ELS_LS_ACC && fh->fh_r_ctl == FC_RCTL_ELS_REP &&\n\t    fip->flogi_oxid == ntohs(fh->fh_ox_id)) {\n\n\t\tmutex_lock(&fip->ctlr_mutex);\n\t\tif (fip->state != FIP_ST_AUTO && fip->state != FIP_ST_NON_FIP) {\n\t\t\tmutex_unlock(&fip->ctlr_mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfcoe_ctlr_set_state(fip, FIP_ST_NON_FIP);\n\t\tLIBFCOE_FIP_DBG(fip,\n\t\t\t\t\"received FLOGI LS_ACC using non-FIP mode\\n\");\n\n\t\t \n\t\tif (ether_addr_equal(sa, (u8[6])FC_FCOE_FLOGI_MAC)) {\n\t\t\tfcoe_ctlr_map_dest(fip);\n\t\t} else {\n\t\t\tmemcpy(fip->dest_addr, sa, ETH_ALEN);\n\t\t\tfip->map_dest = 0;\n\t\t}\n\t\tfip->flogi_oxid = FC_XID_UNKNOWN;\n\t\tmutex_unlock(&fip->ctlr_mutex);\n\t\tfc_fcoe_set_mac(fr_cb(fp)->granted_mac, fh->fh_d_id);\n\t} else if (op == ELS_FLOGI && fh->fh_r_ctl == FC_RCTL_ELS_REQ && sa) {\n\t\t \n\t\tmutex_lock(&fip->ctlr_mutex);\n\t\tif (fip->state == FIP_ST_AUTO || fip->state == FIP_ST_NON_FIP) {\n\t\t\tmemcpy(fip->dest_addr, sa, ETH_ALEN);\n\t\t\tfip->map_dest = 0;\n\t\t\tif (fip->state == FIP_ST_AUTO)\n\t\t\t\tLIBFCOE_FIP_DBG(fip, \"received non-FIP FLOGI. \"\n\t\t\t\t\t\t\"Setting non-FIP mode\\n\");\n\t\t\tfcoe_ctlr_set_state(fip, FIP_ST_NON_FIP);\n\t\t}\n\t\tmutex_unlock(&fip->ctlr_mutex);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(fcoe_ctlr_recv_flogi);\n\n \nu64 fcoe_wwn_from_mac(unsigned char mac[ETH_ALEN],\n\t\t      unsigned int scheme, unsigned int port)\n{\n\tu64 wwn;\n\tu64 host_mac;\n\n\t \n\thost_mac = ((u64) mac[0] << 40) |\n\t\t((u64) mac[1] << 32) |\n\t\t((u64) mac[2] << 24) |\n\t\t((u64) mac[3] << 16) |\n\t\t((u64) mac[4] << 8) |\n\t\t(u64) mac[5];\n\n\tWARN_ON(host_mac >= (1ULL << 48));\n\twwn = host_mac | ((u64) scheme << 60);\n\tswitch (scheme) {\n\tcase 1:\n\t\tWARN_ON(port != 0);\n\t\tbreak;\n\tcase 2:\n\t\tWARN_ON(port >= 0xfff);\n\t\twwn |= (u64) port << 48;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn wwn;\n}\nEXPORT_SYMBOL_GPL(fcoe_wwn_from_mac);\n\n \nstatic inline struct fcoe_rport *fcoe_ctlr_rport(struct fc_rport_priv *rdata)\n{\n\treturn container_of(rdata, struct fcoe_rport, rdata);\n}\n\n \nstatic void fcoe_ctlr_vn_send(struct fcoe_ctlr *fip,\n\t\t\t      enum fip_vn2vn_subcode sub,\n\t\t\t      const u8 *dest, size_t min_len)\n{\n\tstruct sk_buff *skb;\n\tstruct fip_vn2vn_probe_frame {\n\t\tstruct ethhdr eth;\n\t\tstruct fip_header fip;\n\t\tstruct fip_mac_desc mac;\n\t\tstruct fip_wwn_desc wwnn;\n\t\tstruct fip_vn_desc vn;\n\t} __packed * frame;\n\tstruct fip_fc4_feat *ff;\n\tstruct fip_size_desc *size;\n\tu32 fcp_feat;\n\tsize_t len;\n\tsize_t dlen;\n\n\tlen = sizeof(*frame);\n\tdlen = 0;\n\tif (sub == FIP_SC_VN_CLAIM_NOTIFY || sub == FIP_SC_VN_CLAIM_REP) {\n\t\tdlen = sizeof(struct fip_fc4_feat) +\n\t\t       sizeof(struct fip_size_desc);\n\t\tlen += dlen;\n\t}\n\tdlen += sizeof(frame->mac) + sizeof(frame->wwnn) + sizeof(frame->vn);\n\tlen = max(len, min_len + sizeof(struct ethhdr));\n\n\tskb = dev_alloc_skb(len);\n\tif (!skb)\n\t\treturn;\n\n\tframe = (struct fip_vn2vn_probe_frame *)skb->data;\n\tmemset(frame, 0, len);\n\tmemcpy(frame->eth.h_dest, dest, ETH_ALEN);\n\n\tif (sub == FIP_SC_VN_BEACON) {\n\t\thton24(frame->eth.h_source, FIP_VN_FC_MAP);\n\t\thton24(frame->eth.h_source + 3, fip->port_id);\n\t} else {\n\t\tmemcpy(frame->eth.h_source, fip->ctl_src_addr, ETH_ALEN);\n\t}\n\tframe->eth.h_proto = htons(ETH_P_FIP);\n\n\tframe->fip.fip_ver = FIP_VER_ENCAPS(FIP_VER);\n\tframe->fip.fip_op = htons(FIP_OP_VN2VN);\n\tframe->fip.fip_subcode = sub;\n\tframe->fip.fip_dl_len = htons(dlen / FIP_BPW);\n\n\tframe->mac.fd_desc.fip_dtype = FIP_DT_MAC;\n\tframe->mac.fd_desc.fip_dlen = sizeof(frame->mac) / FIP_BPW;\n\tmemcpy(frame->mac.fd_mac, fip->ctl_src_addr, ETH_ALEN);\n\n\tframe->wwnn.fd_desc.fip_dtype = FIP_DT_NAME;\n\tframe->wwnn.fd_desc.fip_dlen = sizeof(frame->wwnn) / FIP_BPW;\n\tput_unaligned_be64(fip->lp->wwnn, &frame->wwnn.fd_wwn);\n\n\tframe->vn.fd_desc.fip_dtype = FIP_DT_VN_ID;\n\tframe->vn.fd_desc.fip_dlen = sizeof(frame->vn) / FIP_BPW;\n\thton24(frame->vn.fd_mac, FIP_VN_FC_MAP);\n\thton24(frame->vn.fd_mac + 3, fip->port_id);\n\thton24(frame->vn.fd_fc_id, fip->port_id);\n\tput_unaligned_be64(fip->lp->wwpn, &frame->vn.fd_wwpn);\n\n\t \n\tif (sub == FIP_SC_VN_CLAIM_NOTIFY || sub == FIP_SC_VN_CLAIM_REP) {\n\t\tff = (struct fip_fc4_feat *)(frame + 1);\n\t\tff->fd_desc.fip_dtype = FIP_DT_FC4F;\n\t\tff->fd_desc.fip_dlen = sizeof(*ff) / FIP_BPW;\n\t\tff->fd_fts = fip->lp->fcts;\n\n\t\tfcp_feat = 0;\n\t\tif (fip->lp->service_params & FCP_SPPF_INIT_FCN)\n\t\t\tfcp_feat |= FCP_FEAT_INIT;\n\t\tif (fip->lp->service_params & FCP_SPPF_TARG_FCN)\n\t\t\tfcp_feat |= FCP_FEAT_TARG;\n\t\tfcp_feat <<= (FC_TYPE_FCP * 4) % 32;\n\t\tff->fd_ff.fd_feat[FC_TYPE_FCP * 4 / 32] = htonl(fcp_feat);\n\n\t\tsize = (struct fip_size_desc *)(ff + 1);\n\t\tsize->fd_desc.fip_dtype = FIP_DT_FCOE_SIZE;\n\t\tsize->fd_desc.fip_dlen = sizeof(*size) / FIP_BPW;\n\t\tsize->fd_size = htons(fcoe_ctlr_fcoe_size(fip));\n\t}\n\n\tskb_put(skb, len);\n\tskb->protocol = htons(ETH_P_FIP);\n\tskb->priority = fip->priority;\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\n\tfip->send(fip, skb);\n}\n\n \nstatic void fcoe_ctlr_vn_rport_callback(struct fc_lport *lport,\n\t\t\t\t\tstruct fc_rport_priv *rdata,\n\t\t\t\t\tenum fc_rport_event event)\n{\n\tstruct fcoe_ctlr *fip = lport->disc.priv;\n\tstruct fcoe_rport *frport = fcoe_ctlr_rport(rdata);\n\n\tLIBFCOE_FIP_DBG(fip, \"vn_rport_callback %x event %d\\n\",\n\t\t\trdata->ids.port_id, event);\n\n\tmutex_lock(&fip->ctlr_mutex);\n\tswitch (event) {\n\tcase RPORT_EV_READY:\n\t\tfrport->login_count = 0;\n\t\tbreak;\n\tcase RPORT_EV_LOGO:\n\tcase RPORT_EV_FAILED:\n\tcase RPORT_EV_STOP:\n\t\tfrport->login_count++;\n\t\tif (frport->login_count > FCOE_CTLR_VN2VN_LOGIN_LIMIT) {\n\t\t\tLIBFCOE_FIP_DBG(fip,\n\t\t\t\t\t\"rport FLOGI limited port_id %6.6x\\n\",\n\t\t\t\t\trdata->ids.port_id);\n\t\t\tfc_rport_logoff(rdata);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&fip->ctlr_mutex);\n}\n\nstatic struct fc_rport_operations fcoe_ctlr_vn_rport_ops = {\n\t.event_callback = fcoe_ctlr_vn_rport_callback,\n};\n\n \nstatic void fcoe_ctlr_disc_stop_locked(struct fc_lport *lport)\n{\n\tstruct fc_rport_priv *rdata;\n\n\tmutex_lock(&lport->disc.disc_mutex);\n\tlist_for_each_entry_rcu(rdata, &lport->disc.rports, peers) {\n\t\tif (kref_get_unless_zero(&rdata->kref)) {\n\t\t\tfc_rport_logoff(rdata);\n\t\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t\t}\n\t}\n\tlport->disc.disc_callback = NULL;\n\tmutex_unlock(&lport->disc.disc_mutex);\n}\n\n \nstatic void fcoe_ctlr_disc_stop(struct fc_lport *lport)\n{\n\tstruct fcoe_ctlr *fip = lport->disc.priv;\n\n\tmutex_lock(&fip->ctlr_mutex);\n\tfcoe_ctlr_disc_stop_locked(lport);\n\tmutex_unlock(&fip->ctlr_mutex);\n}\n\n \nstatic void fcoe_ctlr_disc_stop_final(struct fc_lport *lport)\n{\n\tfcoe_ctlr_disc_stop(lport);\n\tfc_rport_flush_queue();\n\tsynchronize_rcu();\n}\n\n \nstatic void fcoe_ctlr_vn_restart(struct fcoe_ctlr *fip)\n{\n\tunsigned long wait;\n\tu32 port_id;\n\n\tfcoe_ctlr_disc_stop_locked(fip->lp);\n\n\t \n\tport_id = fip->port_id;\n\tif (fip->probe_tries)\n\t\tport_id = prandom_u32_state(&fip->rnd_state) & 0xffff;\n\telse if (!port_id)\n\t\tport_id = fip->lp->wwpn & 0xffff;\n\tif (!port_id || port_id == 0xffff)\n\t\tport_id = 1;\n\tfip->port_id = port_id;\n\n\tif (fip->probe_tries < FIP_VN_RLIM_COUNT) {\n\t\tfip->probe_tries++;\n\t\twait = get_random_u32_below(FIP_VN_PROBE_WAIT);\n\t} else\n\t\twait = FIP_VN_RLIM_INT;\n\tmod_timer(&fip->timer, jiffies + msecs_to_jiffies(wait));\n\tfcoe_ctlr_set_state(fip, FIP_ST_VNMP_START);\n}\n\n \nstatic void fcoe_ctlr_vn_start(struct fcoe_ctlr *fip)\n{\n\tfip->probe_tries = 0;\n\tprandom_seed_state(&fip->rnd_state, fip->lp->wwpn);\n\tfcoe_ctlr_vn_restart(fip);\n}\n\n \nstatic int fcoe_ctlr_vn_parse(struct fcoe_ctlr *fip,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      struct fcoe_rport *frport)\n{\n\tstruct fip_header *fiph;\n\tstruct fip_desc *desc = NULL;\n\tstruct fip_mac_desc *macd = NULL;\n\tstruct fip_wwn_desc *wwn = NULL;\n\tstruct fip_vn_desc *vn = NULL;\n\tstruct fip_size_desc *size = NULL;\n\tsize_t rlen;\n\tsize_t dlen;\n\tu32 desc_mask = 0;\n\tu32 dtype;\n\tu8 sub;\n\n\tfiph = (struct fip_header *)skb->data;\n\tfrport->flags = ntohs(fiph->fip_flags);\n\n\tsub = fiph->fip_subcode;\n\tswitch (sub) {\n\tcase FIP_SC_VN_PROBE_REQ:\n\tcase FIP_SC_VN_PROBE_REP:\n\tcase FIP_SC_VN_BEACON:\n\t\tdesc_mask = BIT(FIP_DT_MAC) | BIT(FIP_DT_NAME) |\n\t\t\t    BIT(FIP_DT_VN_ID);\n\t\tbreak;\n\tcase FIP_SC_VN_CLAIM_NOTIFY:\n\tcase FIP_SC_VN_CLAIM_REP:\n\t\tdesc_mask = BIT(FIP_DT_MAC) | BIT(FIP_DT_NAME) |\n\t\t\t    BIT(FIP_DT_VN_ID) | BIT(FIP_DT_FC4F) |\n\t\t\t    BIT(FIP_DT_FCOE_SIZE);\n\t\tbreak;\n\tdefault:\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_parse unknown subcode %u\\n\", sub);\n\t\treturn -EINVAL;\n\t}\n\n\trlen = ntohs(fiph->fip_dl_len) * 4;\n\tif (rlen + sizeof(*fiph) > skb->len)\n\t\treturn -EINVAL;\n\n\tdesc = (struct fip_desc *)(fiph + 1);\n\twhile (rlen > 0) {\n\t\tdlen = desc->fip_dlen * FIP_BPW;\n\t\tif (dlen < sizeof(*desc) || dlen > rlen)\n\t\t\treturn -EINVAL;\n\n\t\tdtype = desc->fip_dtype;\n\t\tif (dtype < 32) {\n\t\t\tif (!(desc_mask & BIT(dtype))) {\n\t\t\t\tLIBFCOE_FIP_DBG(fip,\n\t\t\t\t\t\t\"unexpected or duplicated desc \"\n\t\t\t\t\t\t\"desc type %u in \"\n\t\t\t\t\t\t\"FIP VN2VN subtype %u\\n\",\n\t\t\t\t\t\tdtype, sub);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tdesc_mask &= ~BIT(dtype);\n\t\t}\n\n\t\tswitch (dtype) {\n\t\tcase FIP_DT_MAC:\n\t\t\tif (dlen != sizeof(struct fip_mac_desc))\n\t\t\t\tgoto len_err;\n\t\t\tmacd = (struct fip_mac_desc *)desc;\n\t\t\tif (!is_valid_ether_addr(macd->fd_mac)) {\n\t\t\t\tLIBFCOE_FIP_DBG(fip,\n\t\t\t\t\t\"Invalid MAC addr %pM in FIP VN2VN\\n\",\n\t\t\t\t\t macd->fd_mac);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmemcpy(frport->enode_mac, macd->fd_mac, ETH_ALEN);\n\t\t\tbreak;\n\t\tcase FIP_DT_NAME:\n\t\t\tif (dlen != sizeof(struct fip_wwn_desc))\n\t\t\t\tgoto len_err;\n\t\t\twwn = (struct fip_wwn_desc *)desc;\n\t\t\tfrport->rdata.ids.node_name =\n\t\t\t\tget_unaligned_be64(&wwn->fd_wwn);\n\t\t\tbreak;\n\t\tcase FIP_DT_VN_ID:\n\t\t\tif (dlen != sizeof(struct fip_vn_desc))\n\t\t\t\tgoto len_err;\n\t\t\tvn = (struct fip_vn_desc *)desc;\n\t\t\tmemcpy(frport->vn_mac, vn->fd_mac, ETH_ALEN);\n\t\t\tfrport->rdata.ids.port_id = ntoh24(vn->fd_fc_id);\n\t\t\tfrport->rdata.ids.port_name =\n\t\t\t\tget_unaligned_be64(&vn->fd_wwpn);\n\t\t\tbreak;\n\t\tcase FIP_DT_FC4F:\n\t\t\tif (dlen != sizeof(struct fip_fc4_feat))\n\t\t\t\tgoto len_err;\n\t\t\tbreak;\n\t\tcase FIP_DT_FCOE_SIZE:\n\t\t\tif (dlen != sizeof(struct fip_size_desc))\n\t\t\t\tgoto len_err;\n\t\t\tsize = (struct fip_size_desc *)desc;\n\t\t\tfrport->fcoe_len = ntohs(size->fd_size);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLIBFCOE_FIP_DBG(fip, \"unexpected descriptor type %x \"\n\t\t\t\t\t\"in FIP probe\\n\", dtype);\n\t\t\t \n\t\t\tif (dtype < FIP_DT_NON_CRITICAL)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tdesc = (struct fip_desc *)((char *)desc + dlen);\n\t\trlen -= dlen;\n\t}\n\treturn 0;\n\nlen_err:\n\tLIBFCOE_FIP_DBG(fip, \"FIP length error in descriptor type %x len %zu\\n\",\n\t\t\tdtype, dlen);\n\treturn -EINVAL;\n}\n\n \nstatic void fcoe_ctlr_vn_send_claim(struct fcoe_ctlr *fip)\n{\n\tfcoe_ctlr_vn_send(fip, FIP_SC_VN_CLAIM_NOTIFY, fcoe_all_vn2vn, 0);\n\tfip->sol_time = jiffies;\n}\n\n \nstatic void fcoe_ctlr_vn_probe_req(struct fcoe_ctlr *fip,\n\t\t\t\t   struct fcoe_rport *frport)\n{\n\tif (frport->rdata.ids.port_id != fip->port_id)\n\t\treturn;\n\n\tswitch (fip->state) {\n\tcase FIP_ST_VNMP_CLAIM:\n\tcase FIP_ST_VNMP_UP:\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_probe_req: send reply, state %x\\n\",\n\t\t\t\tfip->state);\n\t\tfcoe_ctlr_vn_send(fip, FIP_SC_VN_PROBE_REP,\n\t\t\t\t  frport->enode_mac, 0);\n\t\tbreak;\n\tcase FIP_ST_VNMP_PROBE1:\n\tcase FIP_ST_VNMP_PROBE2:\n\t\t \n\t\tif (fip->lp->wwpn > frport->rdata.ids.port_name &&\n\t\t    !(frport->flags & FIP_FL_REC_OR_P2P)) {\n\t\t\tLIBFCOE_FIP_DBG(fip, \"vn_probe_req: \"\n\t\t\t\t\t\"port_id collision\\n\");\n\t\t\tfcoe_ctlr_vn_send(fip, FIP_SC_VN_PROBE_REP,\n\t\t\t\t\t  frport->enode_mac, 0);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase FIP_ST_VNMP_START:\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_probe_req: \"\n\t\t\t\t\"restart VN2VN negotiation\\n\");\n\t\tfcoe_ctlr_vn_restart(fip);\n\t\tbreak;\n\tdefault:\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_probe_req: ignore state %x\\n\",\n\t\t\t\tfip->state);\n\t\tbreak;\n\t}\n}\n\n \nstatic void fcoe_ctlr_vn_probe_reply(struct fcoe_ctlr *fip,\n\t\t\t\t     struct fcoe_rport *frport)\n{\n\tif (frport->rdata.ids.port_id != fip->port_id)\n\t\treturn;\n\tswitch (fip->state) {\n\tcase FIP_ST_VNMP_START:\n\tcase FIP_ST_VNMP_PROBE1:\n\tcase FIP_ST_VNMP_PROBE2:\n\tcase FIP_ST_VNMP_CLAIM:\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_probe_reply: restart state %x\\n\",\n\t\t\t\tfip->state);\n\t\tfcoe_ctlr_vn_restart(fip);\n\t\tbreak;\n\tcase FIP_ST_VNMP_UP:\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_probe_reply: send claim notify\\n\");\n\t\tfcoe_ctlr_vn_send_claim(fip);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void fcoe_ctlr_vn_add(struct fcoe_ctlr *fip, struct fcoe_rport *new)\n{\n\tstruct fc_lport *lport = fip->lp;\n\tstruct fc_rport_priv *rdata;\n\tstruct fc_rport_identifiers *ids;\n\tstruct fcoe_rport *frport;\n\tu32 port_id;\n\n\tport_id = new->rdata.ids.port_id;\n\tif (port_id == fip->port_id)\n\t\treturn;\n\n\tmutex_lock(&lport->disc.disc_mutex);\n\trdata = fc_rport_create(lport, port_id);\n\tif (!rdata) {\n\t\tmutex_unlock(&lport->disc.disc_mutex);\n\t\treturn;\n\t}\n\tmutex_lock(&rdata->rp_mutex);\n\tmutex_unlock(&lport->disc.disc_mutex);\n\n\trdata->ops = &fcoe_ctlr_vn_rport_ops;\n\trdata->disc_id = lport->disc.disc_id;\n\n\tids = &rdata->ids;\n\tif ((ids->port_name != -1 &&\n\t     ids->port_name != new->rdata.ids.port_name) ||\n\t    (ids->node_name != -1 &&\n\t     ids->node_name != new->rdata.ids.node_name)) {\n\t\tmutex_unlock(&rdata->rp_mutex);\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_add rport logoff %6.6x\\n\", port_id);\n\t\tfc_rport_logoff(rdata);\n\t\tmutex_lock(&rdata->rp_mutex);\n\t}\n\tids->port_name = new->rdata.ids.port_name;\n\tids->node_name = new->rdata.ids.node_name;\n\tmutex_unlock(&rdata->rp_mutex);\n\n\tfrport = fcoe_ctlr_rport(rdata);\n\tLIBFCOE_FIP_DBG(fip, \"vn_add rport %6.6x %s state %d\\n\",\n\t\t\tport_id, frport->fcoe_len ? \"old\" : \"new\",\n\t\t\trdata->rp_state);\n\tfrport->fcoe_len = new->fcoe_len;\n\tfrport->flags = new->flags;\n\tfrport->login_count = new->login_count;\n\tmemcpy(frport->enode_mac, new->enode_mac, ETH_ALEN);\n\tmemcpy(frport->vn_mac, new->vn_mac, ETH_ALEN);\n\tfrport->time = 0;\n}\n\n \nstatic int fcoe_ctlr_vn_lookup(struct fcoe_ctlr *fip, u32 port_id, u8 *mac)\n{\n\tstruct fc_lport *lport = fip->lp;\n\tstruct fc_rport_priv *rdata;\n\tstruct fcoe_rport *frport;\n\tint ret = -1;\n\n\trdata = fc_rport_lookup(lport, port_id);\n\tif (rdata) {\n\t\tfrport = fcoe_ctlr_rport(rdata);\n\t\tmemcpy(mac, frport->enode_mac, ETH_ALEN);\n\t\tret = 0;\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t}\n\treturn ret;\n}\n\n \nstatic void fcoe_ctlr_vn_claim_notify(struct fcoe_ctlr *fip,\n\t\t\t\t      struct fcoe_rport *new)\n{\n\tif (new->flags & FIP_FL_REC_OR_P2P) {\n\t\tLIBFCOE_FIP_DBG(fip, \"send probe req for P2P/REC\\n\");\n\t\tfcoe_ctlr_vn_send(fip, FIP_SC_VN_PROBE_REQ, fcoe_all_vn2vn, 0);\n\t\treturn;\n\t}\n\tswitch (fip->state) {\n\tcase FIP_ST_VNMP_START:\n\tcase FIP_ST_VNMP_PROBE1:\n\tcase FIP_ST_VNMP_PROBE2:\n\t\tif (new->rdata.ids.port_id == fip->port_id) {\n\t\t\tLIBFCOE_FIP_DBG(fip, \"vn_claim_notify: \"\n\t\t\t\t\t\"restart, state %d\\n\",\n\t\t\t\t\tfip->state);\n\t\t\tfcoe_ctlr_vn_restart(fip);\n\t\t}\n\t\tbreak;\n\tcase FIP_ST_VNMP_CLAIM:\n\tcase FIP_ST_VNMP_UP:\n\t\tif (new->rdata.ids.port_id == fip->port_id) {\n\t\t\tif (new->rdata.ids.port_name > fip->lp->wwpn) {\n\t\t\t\tLIBFCOE_FIP_DBG(fip, \"vn_claim_notify: \"\n\t\t\t\t\t\t\"restart, port_id collision\\n\");\n\t\t\t\tfcoe_ctlr_vn_restart(fip);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tLIBFCOE_FIP_DBG(fip, \"vn_claim_notify: \"\n\t\t\t\t\t\"send claim notify\\n\");\n\t\t\tfcoe_ctlr_vn_send_claim(fip);\n\t\t\tbreak;\n\t\t}\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_claim_notify: send reply to %x\\n\",\n\t\t\t\tnew->rdata.ids.port_id);\n\t\tfcoe_ctlr_vn_send(fip, FIP_SC_VN_CLAIM_REP, new->enode_mac,\n\t\t\t\t  min((u32)new->fcoe_len,\n\t\t\t\t      fcoe_ctlr_fcoe_size(fip)));\n\t\tfcoe_ctlr_vn_add(fip, new);\n\t\tbreak;\n\tdefault:\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_claim_notify: \"\n\t\t\t\t\"ignoring claim from %x\\n\",\n\t\t\t\tnew->rdata.ids.port_id);\n\t\tbreak;\n\t}\n}\n\n \nstatic void fcoe_ctlr_vn_claim_resp(struct fcoe_ctlr *fip,\n\t\t\t\t    struct fcoe_rport *new)\n{\n\tLIBFCOE_FIP_DBG(fip, \"claim resp from from rport %x - state %s\\n\",\n\t\t\tnew->rdata.ids.port_id, fcoe_ctlr_state(fip->state));\n\tif (fip->state == FIP_ST_VNMP_UP || fip->state == FIP_ST_VNMP_CLAIM)\n\t\tfcoe_ctlr_vn_add(fip, new);\n}\n\n \nstatic void fcoe_ctlr_vn_beacon(struct fcoe_ctlr *fip,\n\t\t\t\tstruct fcoe_rport *new)\n{\n\tstruct fc_lport *lport = fip->lp;\n\tstruct fc_rport_priv *rdata;\n\tstruct fcoe_rport *frport;\n\n\tif (new->flags & FIP_FL_REC_OR_P2P) {\n\t\tLIBFCOE_FIP_DBG(fip, \"p2p beacon while in vn2vn mode\\n\");\n\t\tfcoe_ctlr_vn_send(fip, FIP_SC_VN_PROBE_REQ, fcoe_all_vn2vn, 0);\n\t\treturn;\n\t}\n\trdata = fc_rport_lookup(lport, new->rdata.ids.port_id);\n\tif (rdata) {\n\t\tif (rdata->ids.node_name == new->rdata.ids.node_name &&\n\t\t    rdata->ids.port_name == new->rdata.ids.port_name) {\n\t\t\tfrport = fcoe_ctlr_rport(rdata);\n\n\t\t\tLIBFCOE_FIP_DBG(fip, \"beacon from rport %x\\n\",\n\t\t\t\t\trdata->ids.port_id);\n\t\t\tif (!frport->time && fip->state == FIP_ST_VNMP_UP) {\n\t\t\t\tLIBFCOE_FIP_DBG(fip, \"beacon expired \"\n\t\t\t\t\t\t\"for rport %x\\n\",\n\t\t\t\t\t\trdata->ids.port_id);\n\t\t\t\tfc_rport_login(rdata);\n\t\t\t}\n\t\t\tfrport->time = jiffies;\n\t\t}\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t\treturn;\n\t}\n\tif (fip->state != FIP_ST_VNMP_UP)\n\t\treturn;\n\n\t \n\tLIBFCOE_FIP_DBG(fip, \"beacon from new rport %x. sending claim notify\\n\",\n\t\t\tnew->rdata.ids.port_id);\n\tif (time_after(jiffies,\n\t\t       fip->sol_time + msecs_to_jiffies(FIP_VN_ANN_WAIT)))\n\t\tfcoe_ctlr_vn_send_claim(fip);\n}\n\n \nstatic unsigned long fcoe_ctlr_vn_age(struct fcoe_ctlr *fip)\n{\n\tstruct fc_lport *lport = fip->lp;\n\tstruct fc_rport_priv *rdata;\n\tstruct fcoe_rport *frport;\n\tunsigned long next_time;\n\tunsigned long deadline;\n\n\tnext_time = jiffies + msecs_to_jiffies(FIP_VN_BEACON_INT * 10);\n\tmutex_lock(&lport->disc.disc_mutex);\n\tlist_for_each_entry_rcu(rdata, &lport->disc.rports, peers) {\n\t\tif (!kref_get_unless_zero(&rdata->kref))\n\t\t\tcontinue;\n\t\tfrport = fcoe_ctlr_rport(rdata);\n\t\tif (!frport->time) {\n\t\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t\t\tcontinue;\n\t\t}\n\t\tdeadline = frport->time +\n\t\t\t   msecs_to_jiffies(FIP_VN_BEACON_INT * 25 / 10);\n\t\tif (time_after_eq(jiffies, deadline)) {\n\t\t\tfrport->time = 0;\n\t\t\tLIBFCOE_FIP_DBG(fip,\n\t\t\t\t\"port %16.16llx fc_id %6.6x beacon expired\\n\",\n\t\t\t\trdata->ids.port_name, rdata->ids.port_id);\n\t\t\tfc_rport_logoff(rdata);\n\t\t} else if (time_before(deadline, next_time))\n\t\t\tnext_time = deadline;\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t}\n\tmutex_unlock(&lport->disc.disc_mutex);\n\treturn next_time;\n}\n\n \nstatic int fcoe_ctlr_vn_recv(struct fcoe_ctlr *fip, struct sk_buff *skb)\n{\n\tstruct fip_header *fiph;\n\tenum fip_vn2vn_subcode sub;\n\tstruct fcoe_rport frport = { };\n\tint rc, vlan_id = 0;\n\n\tfiph = (struct fip_header *)skb->data;\n\tsub = fiph->fip_subcode;\n\n\tif (fip->lp->vlan)\n\t\tvlan_id = skb_vlan_tag_get_id(skb);\n\n\tif (vlan_id && vlan_id != fip->lp->vlan) {\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_recv drop frame sub %x vlan %d\\n\",\n\t\t\t\tsub, vlan_id);\n\t\trc = -EAGAIN;\n\t\tgoto drop;\n\t}\n\n\trc = fcoe_ctlr_vn_parse(fip, skb, &frport);\n\tif (rc) {\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_recv vn_parse error %d\\n\", rc);\n\t\tgoto drop;\n\t}\n\n\tmutex_lock(&fip->ctlr_mutex);\n\tswitch (sub) {\n\tcase FIP_SC_VN_PROBE_REQ:\n\t\tfcoe_ctlr_vn_probe_req(fip, &frport);\n\t\tbreak;\n\tcase FIP_SC_VN_PROBE_REP:\n\t\tfcoe_ctlr_vn_probe_reply(fip, &frport);\n\t\tbreak;\n\tcase FIP_SC_VN_CLAIM_NOTIFY:\n\t\tfcoe_ctlr_vn_claim_notify(fip, &frport);\n\t\tbreak;\n\tcase FIP_SC_VN_CLAIM_REP:\n\t\tfcoe_ctlr_vn_claim_resp(fip, &frport);\n\t\tbreak;\n\tcase FIP_SC_VN_BEACON:\n\t\tfcoe_ctlr_vn_beacon(fip, &frport);\n\t\tbreak;\n\tdefault:\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_recv unknown subcode %d\\n\", sub);\n\t\trc = -1;\n\t\tbreak;\n\t}\n\tmutex_unlock(&fip->ctlr_mutex);\ndrop:\n\tkfree_skb(skb);\n\treturn rc;\n}\n\n \nstatic int fcoe_ctlr_vlan_parse(struct fcoe_ctlr *fip,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      struct fcoe_rport *frport)\n{\n\tstruct fip_header *fiph;\n\tstruct fip_desc *desc = NULL;\n\tstruct fip_mac_desc *macd = NULL;\n\tstruct fip_wwn_desc *wwn = NULL;\n\tsize_t rlen;\n\tsize_t dlen;\n\tu32 desc_mask = 0;\n\tu32 dtype;\n\tu8 sub;\n\n\tfiph = (struct fip_header *)skb->data;\n\tfrport->flags = ntohs(fiph->fip_flags);\n\n\tsub = fiph->fip_subcode;\n\tswitch (sub) {\n\tcase FIP_SC_VL_REQ:\n\t\tdesc_mask = BIT(FIP_DT_MAC) | BIT(FIP_DT_NAME);\n\t\tbreak;\n\tdefault:\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_parse unknown subcode %u\\n\", sub);\n\t\treturn -EINVAL;\n\t}\n\n\trlen = ntohs(fiph->fip_dl_len) * 4;\n\tif (rlen + sizeof(*fiph) > skb->len)\n\t\treturn -EINVAL;\n\n\tdesc = (struct fip_desc *)(fiph + 1);\n\twhile (rlen > 0) {\n\t\tdlen = desc->fip_dlen * FIP_BPW;\n\t\tif (dlen < sizeof(*desc) || dlen > rlen)\n\t\t\treturn -EINVAL;\n\n\t\tdtype = desc->fip_dtype;\n\t\tif (dtype < 32) {\n\t\t\tif (!(desc_mask & BIT(dtype))) {\n\t\t\t\tLIBFCOE_FIP_DBG(fip,\n\t\t\t\t\t\t\"unexpected or duplicated desc \"\n\t\t\t\t\t\t\"desc type %u in \"\n\t\t\t\t\t\t\"FIP VN2VN subtype %u\\n\",\n\t\t\t\t\t\tdtype, sub);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tdesc_mask &= ~BIT(dtype);\n\t\t}\n\n\t\tswitch (dtype) {\n\t\tcase FIP_DT_MAC:\n\t\t\tif (dlen != sizeof(struct fip_mac_desc))\n\t\t\t\tgoto len_err;\n\t\t\tmacd = (struct fip_mac_desc *)desc;\n\t\t\tif (!is_valid_ether_addr(macd->fd_mac)) {\n\t\t\t\tLIBFCOE_FIP_DBG(fip,\n\t\t\t\t\t\"Invalid MAC addr %pM in FIP VN2VN\\n\",\n\t\t\t\t\t macd->fd_mac);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmemcpy(frport->enode_mac, macd->fd_mac, ETH_ALEN);\n\t\t\tbreak;\n\t\tcase FIP_DT_NAME:\n\t\t\tif (dlen != sizeof(struct fip_wwn_desc))\n\t\t\t\tgoto len_err;\n\t\t\twwn = (struct fip_wwn_desc *)desc;\n\t\t\tfrport->rdata.ids.node_name =\n\t\t\t\tget_unaligned_be64(&wwn->fd_wwn);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLIBFCOE_FIP_DBG(fip, \"unexpected descriptor type %x \"\n\t\t\t\t\t\"in FIP probe\\n\", dtype);\n\t\t\t \n\t\t\tif (dtype < FIP_DT_NON_CRITICAL)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tdesc = (struct fip_desc *)((char *)desc + dlen);\n\t\trlen -= dlen;\n\t}\n\treturn 0;\n\nlen_err:\n\tLIBFCOE_FIP_DBG(fip, \"FIP length error in descriptor type %x len %zu\\n\",\n\t\t\tdtype, dlen);\n\treturn -EINVAL;\n}\n\n \nstatic void fcoe_ctlr_vlan_send(struct fcoe_ctlr *fip,\n\t\t\t      enum fip_vlan_subcode sub,\n\t\t\t      const u8 *dest)\n{\n\tstruct sk_buff *skb;\n\tstruct fip_vlan_notify_frame {\n\t\tstruct ethhdr eth;\n\t\tstruct fip_header fip;\n\t\tstruct fip_mac_desc mac;\n\t\tstruct fip_vlan_desc vlan;\n\t} __packed * frame;\n\tsize_t len;\n\tsize_t dlen;\n\n\tlen = sizeof(*frame);\n\tdlen = sizeof(frame->mac) + sizeof(frame->vlan);\n\tlen = max(len, sizeof(struct ethhdr));\n\n\tskb = dev_alloc_skb(len);\n\tif (!skb)\n\t\treturn;\n\n\tLIBFCOE_FIP_DBG(fip, \"fip %s vlan notification, vlan %d\\n\",\n\t\t\tfip->mode == FIP_MODE_VN2VN ? \"vn2vn\" : \"fcf\",\n\t\t\tfip->lp->vlan);\n\n\tframe = (struct fip_vlan_notify_frame *)skb->data;\n\tmemset(frame, 0, len);\n\tmemcpy(frame->eth.h_dest, dest, ETH_ALEN);\n\n\tmemcpy(frame->eth.h_source, fip->ctl_src_addr, ETH_ALEN);\n\tframe->eth.h_proto = htons(ETH_P_FIP);\n\n\tframe->fip.fip_ver = FIP_VER_ENCAPS(FIP_VER);\n\tframe->fip.fip_op = htons(FIP_OP_VLAN);\n\tframe->fip.fip_subcode = sub;\n\tframe->fip.fip_dl_len = htons(dlen / FIP_BPW);\n\n\tframe->mac.fd_desc.fip_dtype = FIP_DT_MAC;\n\tframe->mac.fd_desc.fip_dlen = sizeof(frame->mac) / FIP_BPW;\n\tmemcpy(frame->mac.fd_mac, fip->ctl_src_addr, ETH_ALEN);\n\n\tframe->vlan.fd_desc.fip_dtype = FIP_DT_VLAN;\n\tframe->vlan.fd_desc.fip_dlen = sizeof(frame->vlan) / FIP_BPW;\n\tput_unaligned_be16(fip->lp->vlan, &frame->vlan.fd_vlan);\n\n\tskb_put(skb, len);\n\tskb->protocol = htons(ETH_P_FIP);\n\tskb->priority = fip->priority;\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\n\tfip->send(fip, skb);\n}\n\n \nstatic void fcoe_ctlr_vlan_disc_reply(struct fcoe_ctlr *fip,\n\t\t\t\t      struct fcoe_rport *frport)\n{\n\tenum fip_vlan_subcode sub = FIP_SC_VL_NOTE;\n\n\tif (fip->mode == FIP_MODE_VN2VN)\n\t\tsub = FIP_SC_VL_VN2VN_NOTE;\n\n\tfcoe_ctlr_vlan_send(fip, sub, frport->enode_mac);\n}\n\n \nstatic int fcoe_ctlr_vlan_recv(struct fcoe_ctlr *fip, struct sk_buff *skb)\n{\n\tstruct fip_header *fiph;\n\tenum fip_vlan_subcode sub;\n\tstruct fcoe_rport frport = { };\n\tint rc;\n\n\tfiph = (struct fip_header *)skb->data;\n\tsub = fiph->fip_subcode;\n\trc = fcoe_ctlr_vlan_parse(fip, skb, &frport);\n\tif (rc) {\n\t\tLIBFCOE_FIP_DBG(fip, \"vlan_recv vlan_parse error %d\\n\", rc);\n\t\tgoto drop;\n\t}\n\tmutex_lock(&fip->ctlr_mutex);\n\tif (sub == FIP_SC_VL_REQ)\n\t\tfcoe_ctlr_vlan_disc_reply(fip, &frport);\n\tmutex_unlock(&fip->ctlr_mutex);\n\ndrop:\n\tkfree_skb(skb);\n\treturn rc;\n}\n\n \nstatic void fcoe_ctlr_disc_recv(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct fc_seq_els_data rjt_data;\n\n\trjt_data.reason = ELS_RJT_UNSUP;\n\trjt_data.explan = ELS_EXPL_NONE;\n\tfc_seq_els_rsp_send(fp, ELS_LS_RJT, &rjt_data);\n\tfc_frame_free(fp);\n}\n\n \nstatic void fcoe_ctlr_disc_start(void (*callback)(struct fc_lport *,\n\t\t\t\t\t\t  enum fc_disc_event),\n\t\t\t\t struct fc_lport *lport)\n{\n\tstruct fc_disc *disc = &lport->disc;\n\tstruct fcoe_ctlr *fip = disc->priv;\n\n\tmutex_lock(&disc->disc_mutex);\n\tdisc->disc_callback = callback;\n\tdisc->disc_id = (disc->disc_id + 2) | 1;\n\tdisc->pending = 1;\n\tschedule_work(&fip->timer_work);\n\tmutex_unlock(&disc->disc_mutex);\n}\n\n \nstatic void fcoe_ctlr_vn_disc(struct fcoe_ctlr *fip)\n{\n\tstruct fc_lport *lport = fip->lp;\n\tstruct fc_disc *disc = &lport->disc;\n\tstruct fc_rport_priv *rdata;\n\tstruct fcoe_rport *frport;\n\tvoid (*callback)(struct fc_lport *, enum fc_disc_event);\n\n\tmutex_lock(&disc->disc_mutex);\n\tcallback = disc->pending ? disc->disc_callback : NULL;\n\tdisc->pending = 0;\n\tlist_for_each_entry_rcu(rdata, &disc->rports, peers) {\n\t\tif (!kref_get_unless_zero(&rdata->kref))\n\t\t\tcontinue;\n\t\tfrport = fcoe_ctlr_rport(rdata);\n\t\tif (frport->time)\n\t\t\tfc_rport_login(rdata);\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t}\n\tmutex_unlock(&disc->disc_mutex);\n\tif (callback)\n\t\tcallback(lport, DISC_EV_SUCCESS);\n}\n\n \nstatic void fcoe_ctlr_vn_timeout(struct fcoe_ctlr *fip)\n{\n\tunsigned long next_time;\n\tu8 mac[ETH_ALEN];\n\tu32 new_port_id = 0;\n\n\tmutex_lock(&fip->ctlr_mutex);\n\tswitch (fip->state) {\n\tcase FIP_ST_VNMP_START:\n\t\tfcoe_ctlr_set_state(fip, FIP_ST_VNMP_PROBE1);\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_timeout: send 1st probe request\\n\");\n\t\tfcoe_ctlr_vn_send(fip, FIP_SC_VN_PROBE_REQ, fcoe_all_vn2vn, 0);\n\t\tnext_time = jiffies + msecs_to_jiffies(FIP_VN_PROBE_WAIT);\n\t\tbreak;\n\tcase FIP_ST_VNMP_PROBE1:\n\t\tfcoe_ctlr_set_state(fip, FIP_ST_VNMP_PROBE2);\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_timeout: send 2nd probe request\\n\");\n\t\tfcoe_ctlr_vn_send(fip, FIP_SC_VN_PROBE_REQ, fcoe_all_vn2vn, 0);\n\t\tnext_time = jiffies + msecs_to_jiffies(FIP_VN_ANN_WAIT);\n\t\tbreak;\n\tcase FIP_ST_VNMP_PROBE2:\n\t\tfcoe_ctlr_set_state(fip, FIP_ST_VNMP_CLAIM);\n\t\tnew_port_id = fip->port_id;\n\t\thton24(mac, FIP_VN_FC_MAP);\n\t\thton24(mac + 3, new_port_id);\n\t\tfcoe_ctlr_map_dest(fip);\n\t\tfip->update_mac(fip->lp, mac);\n\t\tLIBFCOE_FIP_DBG(fip, \"vn_timeout: send claim notify\\n\");\n\t\tfcoe_ctlr_vn_send_claim(fip);\n\t\tnext_time = jiffies + msecs_to_jiffies(FIP_VN_ANN_WAIT);\n\t\tbreak;\n\tcase FIP_ST_VNMP_CLAIM:\n\t\t \n\t\tnext_time = fip->sol_time + msecs_to_jiffies(FIP_VN_ANN_WAIT);\n\t\tif (time_after_eq(jiffies, next_time)) {\n\t\t\tfcoe_ctlr_set_state(fip, FIP_ST_VNMP_UP);\n\t\t\tLIBFCOE_FIP_DBG(fip, \"vn_timeout: send vn2vn beacon\\n\");\n\t\t\tfcoe_ctlr_vn_send(fip, FIP_SC_VN_BEACON,\n\t\t\t\t\t  fcoe_all_vn2vn, 0);\n\t\t\tnext_time = jiffies + msecs_to_jiffies(FIP_VN_ANN_WAIT);\n\t\t\tfip->port_ka_time = next_time;\n\t\t}\n\t\tfcoe_ctlr_vn_disc(fip);\n\t\tbreak;\n\tcase FIP_ST_VNMP_UP:\n\t\tnext_time = fcoe_ctlr_vn_age(fip);\n\t\tif (time_after_eq(jiffies, fip->port_ka_time)) {\n\t\t\tLIBFCOE_FIP_DBG(fip, \"vn_timeout: send vn2vn beacon\\n\");\n\t\t\tfcoe_ctlr_vn_send(fip, FIP_SC_VN_BEACON,\n\t\t\t\t\t  fcoe_all_vn2vn, 0);\n\t\t\tfip->port_ka_time = jiffies +\n\t\t\t\t msecs_to_jiffies(FIP_VN_BEACON_INT +\n\t\t\t\t\tget_random_u32_below(FIP_VN_BEACON_FUZZ));\n\t\t}\n\t\tif (time_before(fip->port_ka_time, next_time))\n\t\t\tnext_time = fip->port_ka_time;\n\t\tbreak;\n\tcase FIP_ST_LINK_WAIT:\n\t\tgoto unlock;\n\tdefault:\n\t\tWARN(1, \"unexpected state %d\\n\", fip->state);\n\t\tgoto unlock;\n\t}\n\tmod_timer(&fip->timer, next_time);\nunlock:\n\tmutex_unlock(&fip->ctlr_mutex);\n\n\t \n\tif (new_port_id)\n\t\tfc_lport_set_local_id(fip->lp, new_port_id);\n}\n\n \nstatic void fcoe_ctlr_mode_set(struct fc_lport *lport, struct fcoe_ctlr *fip,\n\t\t\t       enum fip_mode fip_mode)\n{\n\tvoid *priv;\n\n\tWARN_ON(lport->state != LPORT_ST_RESET &&\n\t\tlport->state != LPORT_ST_DISABLED);\n\n\tif (fip_mode == FIP_MODE_VN2VN) {\n\t\tlport->rport_priv_size = sizeof(struct fcoe_rport);\n\t\tlport->point_to_multipoint = 1;\n\t\tlport->tt.disc_recv_req = fcoe_ctlr_disc_recv;\n\t\tlport->tt.disc_start = fcoe_ctlr_disc_start;\n\t\tlport->tt.disc_stop = fcoe_ctlr_disc_stop;\n\t\tlport->tt.disc_stop_final = fcoe_ctlr_disc_stop_final;\n\t\tpriv = fip;\n\t} else {\n\t\tlport->rport_priv_size = 0;\n\t\tlport->point_to_multipoint = 0;\n\t\tlport->tt.disc_recv_req = NULL;\n\t\tlport->tt.disc_start = NULL;\n\t\tlport->tt.disc_stop = NULL;\n\t\tlport->tt.disc_stop_final = NULL;\n\t\tpriv = lport;\n\t}\n\n\tfc_disc_config(lport, priv);\n}\n\n \nint fcoe_libfc_config(struct fc_lport *lport, struct fcoe_ctlr *fip,\n\t\t      const struct libfc_function_template *tt, int init_fcp)\n{\n\t \n\tmemcpy(&lport->tt, tt, sizeof(*tt));\n\tif (init_fcp && fc_fcp_init(lport))\n\t\treturn -ENOMEM;\n\tfc_exch_init(lport);\n\tfc_elsct_init(lport);\n\tfc_lport_init(lport);\n\tfc_disc_init(lport);\n\tfcoe_ctlr_mode_set(lport, fip, fip->mode);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fcoe_libfc_config);\n\nvoid fcoe_fcf_get_selected(struct fcoe_fcf_device *fcf_dev)\n{\n\tstruct fcoe_ctlr_device *ctlr_dev = fcoe_fcf_dev_to_ctlr_dev(fcf_dev);\n\tstruct fcoe_ctlr *fip = fcoe_ctlr_device_priv(ctlr_dev);\n\tstruct fcoe_fcf *fcf;\n\n\tmutex_lock(&fip->ctlr_mutex);\n\tmutex_lock(&ctlr_dev->lock);\n\n\tfcf = fcoe_fcf_device_priv(fcf_dev);\n\tif (fcf)\n\t\tfcf_dev->selected = (fcf == fip->sel_fcf) ? 1 : 0;\n\telse\n\t\tfcf_dev->selected = 0;\n\n\tmutex_unlock(&ctlr_dev->lock);\n\tmutex_unlock(&fip->ctlr_mutex);\n}\nEXPORT_SYMBOL(fcoe_fcf_get_selected);\n\nvoid fcoe_ctlr_set_fip_mode(struct fcoe_ctlr_device *ctlr_dev)\n{\n\tstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(ctlr_dev);\n\tstruct fc_lport *lport = ctlr->lp;\n\n\tmutex_lock(&ctlr->ctlr_mutex);\n\tswitch (ctlr_dev->mode) {\n\tcase FIP_CONN_TYPE_VN2VN:\n\t\tctlr->mode = FIP_MODE_VN2VN;\n\t\tbreak;\n\tcase FIP_CONN_TYPE_FABRIC:\n\tdefault:\n\t\tctlr->mode = FIP_MODE_FABRIC;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&ctlr->ctlr_mutex);\n\n\tfcoe_ctlr_mode_set(lport, ctlr, ctlr->mode);\n}\nEXPORT_SYMBOL(fcoe_ctlr_set_fip_mode);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}