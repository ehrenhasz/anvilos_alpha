{
  "module_name": "fcoe_sysfs.c",
  "hash_id": "ee0a046bd5bdcccce29c45f326197af3f7ca3af6c2828eb8988d64bc83fbb4c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/fcoe/fcoe_sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/etherdevice.h>\n#include <linux/ctype.h>\n\n#include <scsi/fcoe_sysfs.h>\n#include <scsi/libfcoe.h>\n\n \n#include \"libfcoe.h\"\n\nstatic atomic_t ctlr_num;\nstatic atomic_t fcf_num;\n\n \nstatic unsigned int fcoe_fcf_dev_loss_tmo = 1800;   \n\nmodule_param_named(fcf_dev_loss_tmo, fcoe_fcf_dev_loss_tmo,\n\t\t   uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(fcf_dev_loss_tmo,\n\t\t \"Maximum number of seconds that libfcoe should\"\n\t\t \" insulate the loss of a fcf. Once this value is\"\n\t\t \" exceeded, the fcf is removed.\");\n\n \n#define fcoe_ctlr_id(x)\t\t\t\t\\\n\t((x)->id)\n#define fcoe_ctlr_work_q_name(x)\t\t\\\n\t((x)->work_q_name)\n#define fcoe_ctlr_work_q(x)\t\t\t\\\n\t((x)->work_q)\n#define fcoe_ctlr_devloss_work_q_name(x)\t\\\n\t((x)->devloss_work_q_name)\n#define fcoe_ctlr_devloss_work_q(x)\t\t\\\n\t((x)->devloss_work_q)\n#define fcoe_ctlr_mode(x)\t\t\t\\\n\t((x)->mode)\n#define fcoe_ctlr_fcf_dev_loss_tmo(x)\t\t\\\n\t((x)->fcf_dev_loss_tmo)\n#define fcoe_ctlr_link_fail(x)\t\t\t\\\n\t((x)->lesb.lesb_link_fail)\n#define fcoe_ctlr_vlink_fail(x)\t\t\t\\\n\t((x)->lesb.lesb_vlink_fail)\n#define fcoe_ctlr_miss_fka(x)\t\t\t\\\n\t((x)->lesb.lesb_miss_fka)\n#define fcoe_ctlr_symb_err(x)\t\t\t\\\n\t((x)->lesb.lesb_symb_err)\n#define fcoe_ctlr_err_block(x)\t\t\t\\\n\t((x)->lesb.lesb_err_block)\n#define fcoe_ctlr_fcs_error(x)\t\t\t\\\n\t((x)->lesb.lesb_fcs_error)\n#define fcoe_ctlr_enabled(x)\t\t\t\\\n\t((x)->enabled)\n#define fcoe_fcf_state(x)\t\t\t\\\n\t((x)->state)\n#define fcoe_fcf_fabric_name(x)\t\t\t\\\n\t((x)->fabric_name)\n#define fcoe_fcf_switch_name(x)\t\t\t\\\n\t((x)->switch_name)\n#define fcoe_fcf_fc_map(x)\t\t\t\\\n\t((x)->fc_map)\n#define fcoe_fcf_vfid(x)\t\t\t\\\n\t((x)->vfid)\n#define fcoe_fcf_mac(x)\t\t\t\t\\\n\t((x)->mac)\n#define fcoe_fcf_priority(x)\t\t\t\\\n\t((x)->priority)\n#define fcoe_fcf_fka_period(x)\t\t\t\\\n\t((x)->fka_period)\n#define fcoe_fcf_dev_loss_tmo(x)\t\t\\\n\t((x)->dev_loss_tmo)\n#define fcoe_fcf_selected(x)\t\t\t\\\n\t((x)->selected)\n#define fcoe_fcf_vlan_id(x)\t\t\t\\\n\t((x)->vlan_id)\n\n \nstatic int fcoe_str_to_dev_loss(const char *buf, unsigned long *val)\n{\n\tint ret;\n\n\tret = kstrtoul(buf, 0, val);\n\tif (ret)\n\t\treturn -EINVAL;\n\t \n\tif (*val > UINT_MAX)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int fcoe_fcf_set_dev_loss_tmo(struct fcoe_fcf_device *fcf,\n\t\t\t\t     unsigned long val)\n{\n\tif ((fcf->state == FCOE_FCF_STATE_UNKNOWN) ||\n\t    (fcf->state == FCOE_FCF_STATE_DISCONNECTED) ||\n\t    (fcf->state == FCOE_FCF_STATE_DELETED))\n\t\treturn -EBUSY;\n\t \n\tif (val > UINT_MAX)\n\t\treturn -EINVAL;\n\n\tfcoe_fcf_dev_loss_tmo(fcf) = val;\n\treturn 0;\n}\n\n#define FCOE_DEVICE_ATTR(_prefix, _name, _mode, _show, _store)\t\\\nstruct device_attribute device_attr_fcoe_##_prefix##_##_name =\t\\\n\t__ATTR(_name, _mode, _show, _store)\n\n#define fcoe_ctlr_show_function(field, format_string, sz, cast)\t\\\nstatic ssize_t show_fcoe_ctlr_device_##field(struct device *dev, \\\n\t\t\t\t\t    struct device_attribute *attr, \\\n\t\t\t\t\t    char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\t\t\\\n\tif (ctlr->f->get_fcoe_ctlr_##field)\t\t\t\t\\\n\t\tctlr->f->get_fcoe_ctlr_##field(ctlr);\t\t\t\\\n\treturn snprintf(buf, sz, format_string,\t\t\t\t\\\n\t\t\tcast fcoe_ctlr_##field(ctlr));\t\t\t\\\n}\n\n#define fcoe_fcf_show_function(field, format_string, sz, cast)\t\\\nstatic ssize_t show_fcoe_fcf_device_##field(struct device *dev,\t\\\n\t\t\t\t\t   struct device_attribute *attr, \\\n\t\t\t\t\t   char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct fcoe_fcf_device *fcf = dev_to_fcf(dev);\t\t\t\\\n\tstruct fcoe_ctlr_device *ctlr = fcoe_fcf_dev_to_ctlr_dev(fcf);\t\\\n\tif (ctlr->f->get_fcoe_fcf_##field)\t\t\t\t\\\n\t\tctlr->f->get_fcoe_fcf_##field(fcf);\t\t\t\\\n\treturn snprintf(buf, sz, format_string,\t\t\t\t\\\n\t\t\tcast fcoe_fcf_##field(fcf));\t\t\t\\\n}\n\n#define fcoe_ctlr_private_show_function(field, format_string, sz, cast)\t\\\nstatic ssize_t show_fcoe_ctlr_device_##field(struct device *dev, \\\n\t\t\t\t\t    struct device_attribute *attr, \\\n\t\t\t\t\t    char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\t\t\\\n\treturn snprintf(buf, sz, format_string, cast fcoe_ctlr_##field(ctlr)); \\\n}\n\n#define fcoe_fcf_private_show_function(field, format_string, sz, cast)\t\\\nstatic ssize_t show_fcoe_fcf_device_##field(struct device *dev,\t\\\n\t\t\t\t\t   struct device_attribute *attr, \\\n\t\t\t\t\t   char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct fcoe_fcf_device *fcf = dev_to_fcf(dev);\t\t\t\\\n\treturn snprintf(buf, sz, format_string, cast fcoe_fcf_##field(fcf)); \\\n}\n\n#define fcoe_ctlr_private_rd_attr(field, format_string, sz)\t\t\\\n\tfcoe_ctlr_private_show_function(field, format_string, sz, )\t\\\n\tstatic FCOE_DEVICE_ATTR(ctlr, field, S_IRUGO,\t\t\t\\\n\t\t\t\tshow_fcoe_ctlr_device_##field, NULL)\n\n#define fcoe_ctlr_rd_attr(field, format_string, sz)\t\t\t\\\n\tfcoe_ctlr_show_function(field, format_string, sz, )\t\t\\\n\tstatic FCOE_DEVICE_ATTR(ctlr, field, S_IRUGO,\t\t\t\\\n\t\t\t\tshow_fcoe_ctlr_device_##field, NULL)\n\n#define fcoe_fcf_rd_attr(field, format_string, sz)\t\t\t\\\n\tfcoe_fcf_show_function(field, format_string, sz, )\t\t\\\n\tstatic FCOE_DEVICE_ATTR(fcf, field, S_IRUGO,\t\t\t\\\n\t\t\t\tshow_fcoe_fcf_device_##field, NULL)\n\n#define fcoe_fcf_private_rd_attr(field, format_string, sz)\t\t\\\n\tfcoe_fcf_private_show_function(field, format_string, sz, )\t\\\n\tstatic FCOE_DEVICE_ATTR(fcf, field, S_IRUGO,\t\t\t\\\n\t\t\t\tshow_fcoe_fcf_device_##field, NULL)\n\n#define fcoe_ctlr_private_rd_attr_cast(field, format_string, sz, cast)\t\\\n\tfcoe_ctlr_private_show_function(field, format_string, sz, (cast)) \\\n\tstatic FCOE_DEVICE_ATTR(ctlr, field, S_IRUGO,\t\t\t\\\n\t\t\t\tshow_fcoe_ctlr_device_##field, NULL)\n\n#define fcoe_fcf_private_rd_attr_cast(field, format_string, sz, cast)\t\\\n\tfcoe_fcf_private_show_function(field, format_string, sz, (cast)) \\\n\tstatic FCOE_DEVICE_ATTR(fcf, field, S_IRUGO,\t\t\t\\\n\t\t\t\tshow_fcoe_fcf_device_##field, NULL)\n\n#define fcoe_enum_name_search(title, table_type, table)\t\t\t\\\nstatic const char *get_fcoe_##title##_name(enum table_type table_key)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (table_key < 0 || table_key >= ARRAY_SIZE(table))\t\t\\\n\t\treturn NULL;\t\t\t\t\t\t\\\n\treturn table[table_key];\t\t\t\t\t\\\n}\n\nstatic char *fip_conn_type_names[] = {\n\t[ FIP_CONN_TYPE_UNKNOWN ] = \"Unknown\",\n\t[ FIP_CONN_TYPE_FABRIC ]  = \"Fabric\",\n\t[ FIP_CONN_TYPE_VN2VN ]   = \"VN2VN\",\n};\nfcoe_enum_name_search(ctlr_mode, fip_conn_type, fip_conn_type_names)\n\nstatic enum fip_conn_type fcoe_parse_mode(const char *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fip_conn_type_names); i++) {\n\t\tif (strcasecmp(buf, fip_conn_type_names[i]) == 0)\n\t\t\treturn i;\n\t}\n\n\treturn FIP_CONN_TYPE_UNKNOWN;\n}\n\nstatic char *fcf_state_names[] = {\n\t[ FCOE_FCF_STATE_UNKNOWN ]      = \"Unknown\",\n\t[ FCOE_FCF_STATE_DISCONNECTED ] = \"Disconnected\",\n\t[ FCOE_FCF_STATE_CONNECTED ]    = \"Connected\",\n};\nfcoe_enum_name_search(fcf_state, fcf_state, fcf_state_names)\n#define FCOE_FCF_STATE_MAX_NAMELEN 50\n\nstatic ssize_t show_fcf_state(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct fcoe_fcf_device *fcf = dev_to_fcf(dev);\n\tconst char *name;\n\tname = get_fcoe_fcf_state_name(fcf->state);\n\tif (!name)\n\t\treturn -EINVAL;\n\treturn snprintf(buf, FCOE_FCF_STATE_MAX_NAMELEN, \"%s\\n\", name);\n}\nstatic FCOE_DEVICE_ATTR(fcf, state, S_IRUGO, show_fcf_state, NULL);\n\n#define FCOE_MAX_MODENAME_LEN 20\nstatic ssize_t show_ctlr_mode(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\n\tconst char *name;\n\n\tname = get_fcoe_ctlr_mode_name(ctlr->mode);\n\tif (!name)\n\t\treturn -EINVAL;\n\treturn snprintf(buf, FCOE_MAX_MODENAME_LEN,\n\t\t\t\"%s\\n\", name);\n}\n\nstatic ssize_t store_ctlr_mode(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\n\tchar mode[FCOE_MAX_MODENAME_LEN + 1];\n\n\tif (count > FCOE_MAX_MODENAME_LEN)\n\t\treturn -EINVAL;\n\n\tstrncpy(mode, buf, count);\n\n\tif (mode[count - 1] == '\\n')\n\t\tmode[count - 1] = '\\0';\n\telse\n\t\tmode[count] = '\\0';\n\n\tswitch (ctlr->enabled) {\n\tcase FCOE_CTLR_ENABLED:\n\t\tLIBFCOE_SYSFS_DBG(ctlr, \"Cannot change mode when enabled.\\n\");\n\t\treturn -EBUSY;\n\tcase FCOE_CTLR_DISABLED:\n\t\tif (!ctlr->f->set_fcoe_ctlr_mode) {\n\t\t\tLIBFCOE_SYSFS_DBG(ctlr,\n\t\t\t\t\t  \"Mode change not supported by LLD.\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tctlr->mode = fcoe_parse_mode(mode);\n\t\tif (ctlr->mode == FIP_CONN_TYPE_UNKNOWN) {\n\t\t\tLIBFCOE_SYSFS_DBG(ctlr, \"Unknown mode %s provided.\\n\",\n\t\t\t\t\t  buf);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tctlr->f->set_fcoe_ctlr_mode(ctlr);\n\t\tLIBFCOE_SYSFS_DBG(ctlr, \"Mode changed to %s.\\n\", buf);\n\n\t\treturn count;\n\tcase FCOE_CTLR_UNUSED:\n\tdefault:\n\t\tLIBFCOE_SYSFS_DBG(ctlr, \"Mode change not supported.\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic FCOE_DEVICE_ATTR(ctlr, mode, S_IRUGO | S_IWUSR,\n\t\t\tshow_ctlr_mode, store_ctlr_mode);\n\nstatic ssize_t store_ctlr_enabled(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\n\tbool enabled;\n\tint rc;\n\n\tif (*buf == '1')\n\t\tenabled = true;\n\telse if (*buf == '0')\n\t\tenabled = false;\n\telse\n\t\treturn -EINVAL;\n\n\tswitch (ctlr->enabled) {\n\tcase FCOE_CTLR_ENABLED:\n\t\tif (enabled)\n\t\t\treturn count;\n\t\tctlr->enabled = FCOE_CTLR_DISABLED;\n\t\tbreak;\n\tcase FCOE_CTLR_DISABLED:\n\t\tif (!enabled)\n\t\t\treturn count;\n\t\tctlr->enabled = FCOE_CTLR_ENABLED;\n\t\tbreak;\n\tcase FCOE_CTLR_UNUSED:\n\t\treturn -ENOTSUPP;\n\t}\n\n\trc = ctlr->f->set_fcoe_ctlr_enabled(ctlr);\n\tif (rc)\n\t\treturn rc;\n\n\treturn count;\n}\n\nstatic char *ctlr_enabled_state_names[] = {\n\t[ FCOE_CTLR_ENABLED ]  = \"1\",\n\t[ FCOE_CTLR_DISABLED ] = \"0\",\n};\nfcoe_enum_name_search(ctlr_enabled_state, ctlr_enabled_state,\n\t\t      ctlr_enabled_state_names)\n#define FCOE_CTLR_ENABLED_MAX_NAMELEN 50\n\nstatic ssize_t show_ctlr_enabled_state(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\n\tconst char *name;\n\n\tname = get_fcoe_ctlr_enabled_state_name(ctlr->enabled);\n\tif (!name)\n\t\treturn -EINVAL;\n\treturn snprintf(buf, FCOE_CTLR_ENABLED_MAX_NAMELEN,\n\t\t\t\"%s\\n\", name);\n}\n\nstatic FCOE_DEVICE_ATTR(ctlr, enabled, S_IRUGO | S_IWUSR,\n\t\t\tshow_ctlr_enabled_state,\n\t\t\tstore_ctlr_enabled);\n\nstatic ssize_t store_ctlr_fip_resp(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\n\tstruct fcoe_ctlr *fip = fcoe_ctlr_device_priv(ctlr);\n\n\tmutex_lock(&fip->ctlr_mutex);\n\tif ((buf[1] == '\\0') || ((buf[1] == '\\n') && (buf[2] == '\\0'))) {\n\t\tif (buf[0] == '1') {\n\t\t\tfip->fip_resp = 1;\n\t\t\tmutex_unlock(&fip->ctlr_mutex);\n\t\t\treturn count;\n\t\t}\n\t\tif (buf[0] == '0') {\n\t\t\tfip->fip_resp = 0;\n\t\t\tmutex_unlock(&fip->ctlr_mutex);\n\t\t\treturn count;\n\t\t}\n\t}\n\tmutex_unlock(&fip->ctlr_mutex);\n\treturn -EINVAL;\n}\n\nstatic ssize_t show_ctlr_fip_resp(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\n\tstruct fcoe_ctlr *fip = fcoe_ctlr_device_priv(ctlr);\n\n\treturn sprintf(buf, \"%d\\n\", fip->fip_resp ? 1 : 0);\n}\n\nstatic FCOE_DEVICE_ATTR(ctlr, fip_vlan_responder, S_IRUGO | S_IWUSR,\n\t\t\tshow_ctlr_fip_resp,\n\t\t\tstore_ctlr_fip_resp);\n\nstatic ssize_t\nfcoe_ctlr_var_store(u32 *var, const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long v;\n\n\terr = kstrtoul(buf, 10, &v);\n\tif (err || v > UINT_MAX)\n\t\treturn -EINVAL;\n\n\t*var = v;\n\n\treturn count;\n}\n\nstatic ssize_t store_ctlr_r_a_tov(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct fcoe_ctlr_device *ctlr_dev = dev_to_ctlr(dev);\n\tstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(ctlr_dev);\n\n\tif (ctlr_dev->enabled == FCOE_CTLR_ENABLED)\n\t\treturn -EBUSY;\n\tif (ctlr_dev->enabled == FCOE_CTLR_DISABLED)\n\t\treturn fcoe_ctlr_var_store(&ctlr->lp->r_a_tov, buf, count);\n\treturn -ENOTSUPP;\n}\n\nstatic ssize_t show_ctlr_r_a_tov(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct fcoe_ctlr_device *ctlr_dev = dev_to_ctlr(dev);\n\tstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(ctlr_dev);\n\n\treturn sprintf(buf, \"%d\\n\", ctlr->lp->r_a_tov);\n}\n\nstatic FCOE_DEVICE_ATTR(ctlr, r_a_tov, S_IRUGO | S_IWUSR,\n\t\t\tshow_ctlr_r_a_tov, store_ctlr_r_a_tov);\n\nstatic ssize_t store_ctlr_e_d_tov(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct fcoe_ctlr_device *ctlr_dev = dev_to_ctlr(dev);\n\tstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(ctlr_dev);\n\n\tif (ctlr_dev->enabled == FCOE_CTLR_ENABLED)\n\t\treturn -EBUSY;\n\tif (ctlr_dev->enabled == FCOE_CTLR_DISABLED)\n\t\treturn fcoe_ctlr_var_store(&ctlr->lp->e_d_tov, buf, count);\n\treturn -ENOTSUPP;\n}\n\nstatic ssize_t show_ctlr_e_d_tov(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct fcoe_ctlr_device *ctlr_dev = dev_to_ctlr(dev);\n\tstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(ctlr_dev);\n\n\treturn sprintf(buf, \"%d\\n\", ctlr->lp->e_d_tov);\n}\n\nstatic FCOE_DEVICE_ATTR(ctlr, e_d_tov, S_IRUGO | S_IWUSR,\n\t\t\tshow_ctlr_e_d_tov, store_ctlr_e_d_tov);\n\nstatic ssize_t\nstore_private_fcoe_ctlr_fcf_dev_loss_tmo(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\n\tstruct fcoe_fcf_device *fcf;\n\tunsigned long val;\n\tint rc;\n\n\trc = fcoe_str_to_dev_loss(buf, &val);\n\tif (rc)\n\t\treturn rc;\n\n\tfcoe_ctlr_fcf_dev_loss_tmo(ctlr) = val;\n\tmutex_lock(&ctlr->lock);\n\tlist_for_each_entry(fcf, &ctlr->fcfs, peers)\n\t\tfcoe_fcf_set_dev_loss_tmo(fcf, val);\n\tmutex_unlock(&ctlr->lock);\n\treturn count;\n}\nfcoe_ctlr_private_show_function(fcf_dev_loss_tmo, \"%d\\n\", 20, );\nstatic FCOE_DEVICE_ATTR(ctlr, fcf_dev_loss_tmo, S_IRUGO | S_IWUSR,\n\t\t\tshow_fcoe_ctlr_device_fcf_dev_loss_tmo,\n\t\t\tstore_private_fcoe_ctlr_fcf_dev_loss_tmo);\n\n \nfcoe_ctlr_rd_attr(link_fail, \"%u\\n\", 20);\nfcoe_ctlr_rd_attr(vlink_fail, \"%u\\n\", 20);\nfcoe_ctlr_rd_attr(miss_fka, \"%u\\n\", 20);\nfcoe_ctlr_rd_attr(symb_err, \"%u\\n\", 20);\nfcoe_ctlr_rd_attr(err_block, \"%u\\n\", 20);\nfcoe_ctlr_rd_attr(fcs_error, \"%u\\n\", 20);\n\nfcoe_fcf_private_rd_attr_cast(fabric_name, \"0x%llx\\n\", 20, unsigned long long);\nfcoe_fcf_private_rd_attr_cast(switch_name, \"0x%llx\\n\", 20, unsigned long long);\nfcoe_fcf_private_rd_attr(priority, \"%u\\n\", 20);\nfcoe_fcf_private_rd_attr(fc_map, \"0x%x\\n\", 20);\nfcoe_fcf_private_rd_attr(vfid, \"%u\\n\", 20);\nfcoe_fcf_private_rd_attr(mac, \"%pM\\n\", 20);\nfcoe_fcf_private_rd_attr(fka_period, \"%u\\n\", 20);\nfcoe_fcf_rd_attr(selected, \"%u\\n\", 20);\nfcoe_fcf_rd_attr(vlan_id, \"%u\\n\", 20);\n\nfcoe_fcf_private_show_function(dev_loss_tmo, \"%d\\n\", 20, )\nstatic ssize_t\nstore_fcoe_fcf_dev_loss_tmo(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct fcoe_fcf_device *fcf = dev_to_fcf(dev);\n\tunsigned long val;\n\tint rc;\n\n\trc = fcoe_str_to_dev_loss(buf, &val);\n\tif (rc)\n\t\treturn rc;\n\n\trc = fcoe_fcf_set_dev_loss_tmo(fcf, val);\n\tif (rc)\n\t\treturn rc;\n\treturn count;\n}\nstatic FCOE_DEVICE_ATTR(fcf, dev_loss_tmo, S_IRUGO | S_IWUSR,\n\t\t\tshow_fcoe_fcf_device_dev_loss_tmo,\n\t\t\tstore_fcoe_fcf_dev_loss_tmo);\n\nstatic struct attribute *fcoe_ctlr_lesb_attrs[] = {\n\t&device_attr_fcoe_ctlr_link_fail.attr,\n\t&device_attr_fcoe_ctlr_vlink_fail.attr,\n\t&device_attr_fcoe_ctlr_miss_fka.attr,\n\t&device_attr_fcoe_ctlr_symb_err.attr,\n\t&device_attr_fcoe_ctlr_err_block.attr,\n\t&device_attr_fcoe_ctlr_fcs_error.attr,\n\tNULL,\n};\n\nstatic struct attribute_group fcoe_ctlr_lesb_attr_group = {\n\t.name = \"lesb\",\n\t.attrs = fcoe_ctlr_lesb_attrs,\n};\n\nstatic struct attribute *fcoe_ctlr_attrs[] = {\n\t&device_attr_fcoe_ctlr_fip_vlan_responder.attr,\n\t&device_attr_fcoe_ctlr_fcf_dev_loss_tmo.attr,\n\t&device_attr_fcoe_ctlr_r_a_tov.attr,\n\t&device_attr_fcoe_ctlr_e_d_tov.attr,\n\t&device_attr_fcoe_ctlr_enabled.attr,\n\t&device_attr_fcoe_ctlr_mode.attr,\n\tNULL,\n};\n\nstatic struct attribute_group fcoe_ctlr_attr_group = {\n\t.attrs = fcoe_ctlr_attrs,\n};\n\nstatic const struct attribute_group *fcoe_ctlr_attr_groups[] = {\n\t&fcoe_ctlr_attr_group,\n\t&fcoe_ctlr_lesb_attr_group,\n\tNULL,\n};\n\nstatic struct attribute *fcoe_fcf_attrs[] = {\n\t&device_attr_fcoe_fcf_fabric_name.attr,\n\t&device_attr_fcoe_fcf_switch_name.attr,\n\t&device_attr_fcoe_fcf_dev_loss_tmo.attr,\n\t&device_attr_fcoe_fcf_fc_map.attr,\n\t&device_attr_fcoe_fcf_vfid.attr,\n\t&device_attr_fcoe_fcf_mac.attr,\n\t&device_attr_fcoe_fcf_priority.attr,\n\t&device_attr_fcoe_fcf_fka_period.attr,\n\t&device_attr_fcoe_fcf_state.attr,\n\t&device_attr_fcoe_fcf_selected.attr,\n\t&device_attr_fcoe_fcf_vlan_id.attr,\n\tNULL\n};\n\nstatic struct attribute_group fcoe_fcf_attr_group = {\n\t.attrs = fcoe_fcf_attrs,\n};\n\nstatic const struct attribute_group *fcoe_fcf_attr_groups[] = {\n\t&fcoe_fcf_attr_group,\n\tNULL,\n};\n\nstatic struct bus_type fcoe_bus_type;\n\nstatic int fcoe_bus_match(struct device *dev,\n\t\t\t  struct device_driver *drv)\n{\n\tif (dev->bus == &fcoe_bus_type)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic void fcoe_ctlr_device_release(struct device *dev)\n{\n\tstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\n\tkfree(ctlr);\n}\n\n \nstatic void fcoe_fcf_device_release(struct device *dev)\n{\n\tstruct fcoe_fcf_device *fcf = dev_to_fcf(dev);\n\tkfree(fcf);\n}\n\nstatic const struct device_type fcoe_ctlr_device_type = {\n\t.name = \"fcoe_ctlr\",\n\t.groups = fcoe_ctlr_attr_groups,\n\t.release = fcoe_ctlr_device_release,\n};\n\nstatic const struct device_type fcoe_fcf_device_type = {\n\t.name = \"fcoe_fcf\",\n\t.groups = fcoe_fcf_attr_groups,\n\t.release = fcoe_fcf_device_release,\n};\n\nstatic ssize_t ctlr_create_store(const struct bus_type *bus, const char *buf,\n\t\t\t\t size_t count)\n{\n\treturn fcoe_ctlr_create_store(buf, count);\n}\nstatic BUS_ATTR_WO(ctlr_create);\n\nstatic ssize_t ctlr_destroy_store(const struct bus_type *bus, const char *buf,\n\t\t\t\t  size_t count)\n{\n\treturn fcoe_ctlr_destroy_store(buf, count);\n}\nstatic BUS_ATTR_WO(ctlr_destroy);\n\nstatic struct attribute *fcoe_bus_attrs[] = {\n\t&bus_attr_ctlr_create.attr,\n\t&bus_attr_ctlr_destroy.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(fcoe_bus);\n\nstatic struct bus_type fcoe_bus_type = {\n\t.name = \"fcoe\",\n\t.match = &fcoe_bus_match,\n\t.bus_groups = fcoe_bus_groups,\n};\n\n \nstatic void fcoe_ctlr_device_flush_work(struct fcoe_ctlr_device *ctlr)\n{\n\tif (!fcoe_ctlr_work_q(ctlr)) {\n\t\tprintk(KERN_ERR\n\t\t       \"ERROR: FIP Ctlr '%d' attempted to flush work, \"\n\t\t       \"when no workqueue created.\\n\", ctlr->id);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\tflush_workqueue(fcoe_ctlr_work_q(ctlr));\n}\n\n \nstatic int fcoe_ctlr_device_queue_work(struct fcoe_ctlr_device *ctlr,\n\t\t\t\t       struct work_struct *work)\n{\n\tif (unlikely(!fcoe_ctlr_work_q(ctlr))) {\n\t\tprintk(KERN_ERR\n\t\t       \"ERROR: FIP Ctlr '%d' attempted to queue work, \"\n\t\t       \"when no workqueue created.\\n\", ctlr->id);\n\t\tdump_stack();\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn queue_work(fcoe_ctlr_work_q(ctlr), work);\n}\n\n \nstatic void fcoe_ctlr_device_flush_devloss(struct fcoe_ctlr_device *ctlr)\n{\n\tif (!fcoe_ctlr_devloss_work_q(ctlr)) {\n\t\tprintk(KERN_ERR\n\t\t       \"ERROR: FIP Ctlr '%d' attempted to flush work, \"\n\t\t       \"when no workqueue created.\\n\", ctlr->id);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\tflush_workqueue(fcoe_ctlr_devloss_work_q(ctlr));\n}\n\n \nstatic int fcoe_ctlr_device_queue_devloss_work(struct fcoe_ctlr_device *ctlr,\n\t\t\t\t\t       struct delayed_work *work,\n\t\t\t\t\t       unsigned long delay)\n{\n\tif (unlikely(!fcoe_ctlr_devloss_work_q(ctlr))) {\n\t\tprintk(KERN_ERR\n\t\t       \"ERROR: FIP Ctlr '%d' attempted to queue work, \"\n\t\t       \"when no workqueue created.\\n\", ctlr->id);\n\t\tdump_stack();\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn queue_delayed_work(fcoe_ctlr_devloss_work_q(ctlr), work, delay);\n}\n\nstatic int fcoe_fcf_device_match(struct fcoe_fcf_device *new,\n\t\t\t\t struct fcoe_fcf_device *old)\n{\n\tif (new->switch_name == old->switch_name &&\n\t    new->fabric_name == old->fabric_name &&\n\t    new->fc_map == old->fc_map &&\n\t    ether_addr_equal(new->mac, old->mac))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstruct fcoe_ctlr_device *fcoe_ctlr_device_add(struct device *parent,\n\t\t\t\t    struct fcoe_sysfs_function_template *f,\n\t\t\t\t    int priv_size)\n{\n\tstruct fcoe_ctlr_device *ctlr;\n\tint error = 0;\n\n\tctlr = kzalloc(sizeof(struct fcoe_ctlr_device) + priv_size,\n\t\t       GFP_KERNEL);\n\tif (!ctlr)\n\t\tgoto out;\n\n\tctlr->id = atomic_inc_return(&ctlr_num) - 1;\n\tctlr->f = f;\n\tctlr->mode = FIP_CONN_TYPE_FABRIC;\n\tINIT_LIST_HEAD(&ctlr->fcfs);\n\tmutex_init(&ctlr->lock);\n\tctlr->dev.parent = parent;\n\tctlr->dev.bus = &fcoe_bus_type;\n\tctlr->dev.type = &fcoe_ctlr_device_type;\n\n\tctlr->fcf_dev_loss_tmo = fcoe_fcf_dev_loss_tmo;\n\n\tsnprintf(ctlr->work_q_name, sizeof(ctlr->work_q_name),\n\t\t \"ctlr_wq_%d\", ctlr->id);\n\tctlr->work_q = create_singlethread_workqueue(\n\t\tctlr->work_q_name);\n\tif (!ctlr->work_q)\n\t\tgoto out_del;\n\n\tsnprintf(ctlr->devloss_work_q_name,\n\t\t sizeof(ctlr->devloss_work_q_name),\n\t\t \"ctlr_dl_wq_%d\", ctlr->id);\n\tctlr->devloss_work_q = create_singlethread_workqueue(\n\t\tctlr->devloss_work_q_name);\n\tif (!ctlr->devloss_work_q)\n\t\tgoto out_del_q;\n\n\tdev_set_name(&ctlr->dev, \"ctlr_%d\", ctlr->id);\n\terror = device_register(&ctlr->dev);\n\tif (error) {\n\t\tdestroy_workqueue(ctlr->devloss_work_q);\n\t\tdestroy_workqueue(ctlr->work_q);\n\t\tput_device(&ctlr->dev);\n\t\treturn NULL;\n\t}\n\n\treturn ctlr;\n\nout_del_q:\n\tdestroy_workqueue(ctlr->work_q);\n\tctlr->work_q = NULL;\nout_del:\n\tkfree(ctlr);\nout:\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(fcoe_ctlr_device_add);\n\n \nvoid fcoe_ctlr_device_delete(struct fcoe_ctlr_device *ctlr)\n{\n\tstruct fcoe_fcf_device *fcf, *next;\n\t \n\tmutex_lock(&ctlr->lock);\n\tlist_for_each_entry_safe(fcf, next,\n\t\t\t\t &ctlr->fcfs, peers) {\n\t\tlist_del(&fcf->peers);\n\t\tfcf->state = FCOE_FCF_STATE_DELETED;\n\t\tfcoe_ctlr_device_queue_work(ctlr, &fcf->delete_work);\n\t}\n\tmutex_unlock(&ctlr->lock);\n\n\tfcoe_ctlr_device_flush_work(ctlr);\n\n\tdestroy_workqueue(ctlr->devloss_work_q);\n\tctlr->devloss_work_q = NULL;\n\tdestroy_workqueue(ctlr->work_q);\n\tctlr->work_q = NULL;\n\n\tdevice_unregister(&ctlr->dev);\n}\nEXPORT_SYMBOL_GPL(fcoe_ctlr_device_delete);\n\n \nstatic void fcoe_fcf_device_final_delete(struct work_struct *work)\n{\n\tstruct fcoe_fcf_device *fcf =\n\t\tcontainer_of(work, struct fcoe_fcf_device, delete_work);\n\tstruct fcoe_ctlr_device *ctlr = fcoe_fcf_dev_to_ctlr_dev(fcf);\n\n\t \n\tif (!cancel_delayed_work(&fcf->dev_loss_work))\n\t\tfcoe_ctlr_device_flush_devloss(ctlr);\n\n\tdevice_unregister(&fcf->dev);\n}\n\n \nstatic void fip_timeout_deleted_fcf(struct work_struct *work)\n{\n\tstruct fcoe_fcf_device *fcf =\n\t\tcontainer_of(work, struct fcoe_fcf_device, dev_loss_work.work);\n\tstruct fcoe_ctlr_device *ctlr = fcoe_fcf_dev_to_ctlr_dev(fcf);\n\n\tmutex_lock(&ctlr->lock);\n\n\t \n\tif (fcf->state != FCOE_FCF_STATE_DISCONNECTED)\n\t\tgoto out;\n\n\tdev_printk(KERN_ERR, &fcf->dev,\n\t\t   \"FIP fcf connection time out: removing fcf\\n\");\n\n\tlist_del(&fcf->peers);\n\tfcf->state = FCOE_FCF_STATE_DELETED;\n\tfcoe_ctlr_device_queue_work(ctlr, &fcf->delete_work);\n\nout:\n\tmutex_unlock(&ctlr->lock);\n}\n\n \nvoid fcoe_fcf_device_delete(struct fcoe_fcf_device *fcf)\n{\n\tstruct fcoe_ctlr_device *ctlr = fcoe_fcf_dev_to_ctlr_dev(fcf);\n\tint timeout = fcf->dev_loss_tmo;\n\n\tif (fcf->state != FCOE_FCF_STATE_CONNECTED)\n\t\treturn;\n\n\tfcf->state = FCOE_FCF_STATE_DISCONNECTED;\n\n\t \n\tfcf->priv = NULL;\n\n\tfcoe_ctlr_device_queue_devloss_work(ctlr, &fcf->dev_loss_work,\n\t\t\t\t\t   timeout * HZ);\n}\nEXPORT_SYMBOL_GPL(fcoe_fcf_device_delete);\n\n \nstruct fcoe_fcf_device *fcoe_fcf_device_add(struct fcoe_ctlr_device *ctlr,\n\t\t\t\t\t    struct fcoe_fcf_device *new_fcf)\n{\n\tstruct fcoe_fcf_device *fcf;\n\tint error = 0;\n\n\tlist_for_each_entry(fcf, &ctlr->fcfs, peers) {\n\t\tif (fcoe_fcf_device_match(new_fcf, fcf)) {\n\t\t\tif (fcf->state == FCOE_FCF_STATE_CONNECTED)\n\t\t\t\treturn fcf;\n\n\t\t\tfcf->state = FCOE_FCF_STATE_CONNECTED;\n\n\t\t\tif (!cancel_delayed_work(&fcf->dev_loss_work))\n\t\t\t\tfcoe_ctlr_device_flush_devloss(ctlr);\n\n\t\t\treturn fcf;\n\t\t}\n\t}\n\n\tfcf = kzalloc(sizeof(struct fcoe_fcf_device), GFP_ATOMIC);\n\tif (unlikely(!fcf))\n\t\tgoto out;\n\n\tINIT_WORK(&fcf->delete_work, fcoe_fcf_device_final_delete);\n\tINIT_DELAYED_WORK(&fcf->dev_loss_work, fip_timeout_deleted_fcf);\n\n\tfcf->dev.parent = &ctlr->dev;\n\tfcf->dev.bus = &fcoe_bus_type;\n\tfcf->dev.type = &fcoe_fcf_device_type;\n\tfcf->id = atomic_inc_return(&fcf_num) - 1;\n\tfcf->state = FCOE_FCF_STATE_UNKNOWN;\n\n\tfcf->dev_loss_tmo = ctlr->fcf_dev_loss_tmo;\n\n\tdev_set_name(&fcf->dev, \"fcf_%d\", fcf->id);\n\n\tfcf->fabric_name = new_fcf->fabric_name;\n\tfcf->switch_name = new_fcf->switch_name;\n\tfcf->fc_map = new_fcf->fc_map;\n\tfcf->vfid = new_fcf->vfid;\n\tmemcpy(fcf->mac, new_fcf->mac, ETH_ALEN);\n\tfcf->priority = new_fcf->priority;\n\tfcf->fka_period = new_fcf->fka_period;\n\tfcf->selected = new_fcf->selected;\n\n\terror = device_register(&fcf->dev);\n\tif (error) {\n\t\tput_device(&fcf->dev);\n\t\tgoto out;\n\t}\n\n\tfcf->state = FCOE_FCF_STATE_CONNECTED;\n\tlist_add_tail(&fcf->peers, &ctlr->fcfs);\n\n\treturn fcf;\n\nout:\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(fcoe_fcf_device_add);\n\nint __init fcoe_sysfs_setup(void)\n{\n\tatomic_set(&ctlr_num, 0);\n\tatomic_set(&fcf_num, 0);\n\n\treturn bus_register(&fcoe_bus_type);\n}\n\nvoid __exit fcoe_sysfs_teardown(void)\n{\n\tbus_unregister(&fcoe_bus_type);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}