{
  "module_name": "fcoe_transport.c",
  "hash_id": "5e92ec18bdfa72cea5c93c6590d9fb7abc3d9493f245418e24b76c9ff794845f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/fcoe/fcoe_transport.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/errno.h>\n#include <linux/crc32.h>\n#include <scsi/libfcoe.h>\n\n#include \"libfcoe.h\"\n\nMODULE_AUTHOR(\"Open-FCoE.org\");\nMODULE_DESCRIPTION(\"FIP discovery protocol and FCoE transport for FCoE HBAs\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic int fcoe_transport_create(const char *, const struct kernel_param *);\nstatic int fcoe_transport_destroy(const char *, const struct kernel_param *);\nstatic int fcoe_transport_show(char *buffer, const struct kernel_param *kp);\nstatic struct fcoe_transport *fcoe_transport_lookup(struct net_device *device);\nstatic struct fcoe_transport *fcoe_netdev_map_lookup(struct net_device *device);\nstatic int fcoe_transport_enable(const char *, const struct kernel_param *);\nstatic int fcoe_transport_disable(const char *, const struct kernel_param *);\nstatic int libfcoe_device_notification(struct notifier_block *notifier,\n\t\t\t\t    ulong event, void *ptr);\n\nstatic LIST_HEAD(fcoe_transports);\nstatic DEFINE_MUTEX(ft_mutex);\nstatic LIST_HEAD(fcoe_netdevs);\nstatic DEFINE_MUTEX(fn_mutex);\n\nunsigned int libfcoe_debug_logging;\nmodule_param_named(debug_logging, libfcoe_debug_logging, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(debug_logging, \"a bit mask of logging levels\");\n\nmodule_param_call(show, NULL, fcoe_transport_show, NULL, S_IRUSR);\n__MODULE_PARM_TYPE(show, \"string\");\nMODULE_PARM_DESC(show, \" Show attached FCoE transports\");\n\nmodule_param_call(create, fcoe_transport_create, NULL,\n\t\t  (void *)FIP_MODE_FABRIC, S_IWUSR);\n__MODULE_PARM_TYPE(create, \"string\");\nMODULE_PARM_DESC(create, \" Creates fcoe instance on an ethernet interface\");\n\nmodule_param_call(create_vn2vn, fcoe_transport_create, NULL,\n\t\t  (void *)FIP_MODE_VN2VN, S_IWUSR);\n__MODULE_PARM_TYPE(create_vn2vn, \"string\");\nMODULE_PARM_DESC(create_vn2vn, \" Creates a VN_node to VN_node FCoE instance \"\n\t\t \"on an Ethernet interface\");\n\nmodule_param_call(destroy, fcoe_transport_destroy, NULL, NULL, S_IWUSR);\n__MODULE_PARM_TYPE(destroy, \"string\");\nMODULE_PARM_DESC(destroy, \" Destroys fcoe instance on an ethernet interface\");\n\nmodule_param_call(enable, fcoe_transport_enable, NULL, NULL, S_IWUSR);\n__MODULE_PARM_TYPE(enable, \"string\");\nMODULE_PARM_DESC(enable, \" Enables fcoe on an ethernet interface.\");\n\nmodule_param_call(disable, fcoe_transport_disable, NULL, NULL, S_IWUSR);\n__MODULE_PARM_TYPE(disable, \"string\");\nMODULE_PARM_DESC(disable, \" Disables fcoe on an ethernet interface.\");\n\n \nstatic struct notifier_block libfcoe_notifier = {\n\t.notifier_call = libfcoe_device_notification,\n};\n\nstatic const struct {\n\tu32 fc_port_speed;\n#define SPEED_2000\t2000\n#define SPEED_4000\t4000\n#define SPEED_8000\t8000\n#define SPEED_16000\t16000\n#define SPEED_32000\t32000\n\tu32 eth_port_speed;\n} fcoe_port_speed_mapping[] = {\n\t{ FC_PORTSPEED_1GBIT,   SPEED_1000   },\n\t{ FC_PORTSPEED_2GBIT,   SPEED_2000   },\n\t{ FC_PORTSPEED_4GBIT,   SPEED_4000   },\n\t{ FC_PORTSPEED_8GBIT,   SPEED_8000   },\n\t{ FC_PORTSPEED_10GBIT,  SPEED_10000  },\n\t{ FC_PORTSPEED_16GBIT,  SPEED_16000  },\n\t{ FC_PORTSPEED_20GBIT,  SPEED_20000  },\n\t{ FC_PORTSPEED_25GBIT,  SPEED_25000  },\n\t{ FC_PORTSPEED_32GBIT,  SPEED_32000  },\n\t{ FC_PORTSPEED_40GBIT,  SPEED_40000  },\n\t{ FC_PORTSPEED_50GBIT,  SPEED_50000  },\n\t{ FC_PORTSPEED_100GBIT, SPEED_100000 },\n};\n\nstatic inline u32 eth2fc_speed(u32 eth_port_speed)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fcoe_port_speed_mapping); i++) {\n\t\tif (fcoe_port_speed_mapping[i].eth_port_speed == eth_port_speed)\n\t\t\treturn fcoe_port_speed_mapping[i].fc_port_speed;\n\t}\n\n\treturn FC_PORTSPEED_UNKNOWN;\n}\n\n \nint fcoe_link_speed_update(struct fc_lport *lport)\n{\n\tstruct net_device *netdev = fcoe_get_netdev(lport);\n\tstruct ethtool_link_ksettings ecmd;\n\n\tif (!__ethtool_get_link_ksettings(netdev, &ecmd)) {\n\t\tlport->link_supported_speeds &= ~(FC_PORTSPEED_1GBIT  |\n\t\t                                  FC_PORTSPEED_10GBIT |\n\t\t                                  FC_PORTSPEED_20GBIT |\n\t\t                                  FC_PORTSPEED_40GBIT);\n\n\t\tif (ecmd.link_modes.supported[0] & (\n\t\t\t    SUPPORTED_1000baseT_Half |\n\t\t\t    SUPPORTED_1000baseT_Full |\n\t\t\t    SUPPORTED_1000baseKX_Full))\n\t\t\tlport->link_supported_speeds |= FC_PORTSPEED_1GBIT;\n\n\t\tif (ecmd.link_modes.supported[0] & (\n\t\t\t    SUPPORTED_10000baseT_Full   |\n\t\t\t    SUPPORTED_10000baseKX4_Full |\n\t\t\t    SUPPORTED_10000baseKR_Full  |\n\t\t\t    SUPPORTED_10000baseR_FEC))\n\t\t\tlport->link_supported_speeds |= FC_PORTSPEED_10GBIT;\n\n\t\tif (ecmd.link_modes.supported[0] & (\n\t\t\t    SUPPORTED_20000baseMLD2_Full |\n\t\t\t    SUPPORTED_20000baseKR2_Full))\n\t\t\tlport->link_supported_speeds |= FC_PORTSPEED_20GBIT;\n\n\t\tif (ecmd.link_modes.supported[0] & (\n\t\t\t    SUPPORTED_40000baseKR4_Full |\n\t\t\t    SUPPORTED_40000baseCR4_Full |\n\t\t\t    SUPPORTED_40000baseSR4_Full |\n\t\t\t    SUPPORTED_40000baseLR4_Full))\n\t\t\tlport->link_supported_speeds |= FC_PORTSPEED_40GBIT;\n\n\t\tlport->link_speed = eth2fc_speed(ecmd.base.speed);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(fcoe_link_speed_update);\n\n \nvoid __fcoe_get_lesb(struct fc_lport *lport,\n\t\t     struct fc_els_lesb *fc_lesb,\n\t\t     struct net_device *netdev)\n{\n\tunsigned int cpu;\n\tu32 lfc, vlfc, mdac;\n\tstruct fc_stats *stats;\n\tstruct fcoe_fc_els_lesb *lesb;\n\tstruct rtnl_link_stats64 temp;\n\n\tlfc = 0;\n\tvlfc = 0;\n\tmdac = 0;\n\tlesb = (struct fcoe_fc_els_lesb *)fc_lesb;\n\tmemset(lesb, 0, sizeof(*lesb));\n\tfor_each_possible_cpu(cpu) {\n\t\tstats = per_cpu_ptr(lport->stats, cpu);\n\t\tlfc += READ_ONCE(stats->LinkFailureCount);\n\t\tvlfc += READ_ONCE(stats->VLinkFailureCount);\n\t\tmdac += READ_ONCE(stats->MissDiscAdvCount);\n\t}\n\tlesb->lesb_link_fail = htonl(lfc);\n\tlesb->lesb_vlink_fail = htonl(vlfc);\n\tlesb->lesb_miss_fka = htonl(mdac);\n\tlesb->lesb_fcs_error =\n\t\t\thtonl(dev_get_stats(netdev, &temp)->rx_crc_errors);\n}\nEXPORT_SYMBOL_GPL(__fcoe_get_lesb);\n\n \nvoid fcoe_get_lesb(struct fc_lport *lport,\n\t\t\t struct fc_els_lesb *fc_lesb)\n{\n\tstruct net_device *netdev = fcoe_get_netdev(lport);\n\n\t__fcoe_get_lesb(lport, fc_lesb, netdev);\n}\nEXPORT_SYMBOL_GPL(fcoe_get_lesb);\n\n \nvoid fcoe_ctlr_get_lesb(struct fcoe_ctlr_device *ctlr_dev)\n{\n\tstruct fcoe_ctlr *fip = fcoe_ctlr_device_priv(ctlr_dev);\n\tstruct net_device *netdev = fcoe_get_netdev(fip->lp);\n\tstruct fc_els_lesb *fc_lesb;\n\n\tfc_lesb = (struct fc_els_lesb *)(&ctlr_dev->lesb);\n\t__fcoe_get_lesb(fip->lp, fc_lesb, netdev);\n}\nEXPORT_SYMBOL_GPL(fcoe_ctlr_get_lesb);\n\nvoid fcoe_wwn_to_str(u64 wwn, char *buf, int len)\n{\n\tu8 wwpn[8];\n\n\tu64_to_wwn(wwn, wwpn);\n\tsnprintf(buf, len, \"%02x%02x%02x%02x%02x%02x%02x%02x\",\n\t\t wwpn[0], wwpn[1], wwpn[2], wwpn[3],\n\t\t wwpn[4], wwpn[5], wwpn[6], wwpn[7]);\n}\nEXPORT_SYMBOL_GPL(fcoe_wwn_to_str);\n\n \nint fcoe_validate_vport_create(struct fc_vport *vport)\n{\n\tstruct Scsi_Host *shost = vport_to_shost(vport);\n\tstruct fc_lport *n_port = shost_priv(shost);\n\tstruct fc_lport *vn_port;\n\tint rc = 0;\n\tchar buf[32];\n\n\tmutex_lock(&n_port->lp_mutex);\n\n\tfcoe_wwn_to_str(vport->port_name, buf, sizeof(buf));\n\t \n\tif (!memcmp(&n_port->wwpn, &vport->port_name, sizeof(u64))) {\n\t\tLIBFCOE_TRANSPORT_DBG(\"vport WWPN 0x%s is same as that of the \"\n\t\t\t\t      \"base port WWPN\\n\", buf);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tlist_for_each_entry(vn_port, &n_port->vports, list) {\n\t\tif (!memcmp(&vn_port->wwpn, &vport->port_name, sizeof(u64))) {\n\t\t\tLIBFCOE_TRANSPORT_DBG(\"vport with given WWPN 0x%s \"\n\t\t\t\t\t      \"already exists\\n\", buf);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&n_port->lp_mutex);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(fcoe_validate_vport_create);\n\n \nint fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type)\n{\n\tconst struct net_device_ops *ops = netdev->netdev_ops;\n\n\tif (ops->ndo_fcoe_get_wwn)\n\t\treturn ops->ndo_fcoe_get_wwn(netdev, wwn, type);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(fcoe_get_wwn);\n\n \nu32 fcoe_fc_crc(struct fc_frame *fp)\n{\n\tstruct sk_buff *skb = fp_skb(fp);\n\tskb_frag_t *frag;\n\tunsigned char *data;\n\tunsigned long off, len, clen;\n\tu32 crc;\n\tunsigned i;\n\n\tcrc = crc32(~0, skb->data, skb_headlen(skb));\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tfrag = &skb_shinfo(skb)->frags[i];\n\t\toff = skb_frag_off(frag);\n\t\tlen = skb_frag_size(frag);\n\t\twhile (len > 0) {\n\t\t\tclen = min(len, PAGE_SIZE - (off & ~PAGE_MASK));\n\t\t\tdata = kmap_atomic(\n\t\t\t\tskb_frag_page(frag) + (off >> PAGE_SHIFT));\n\t\t\tcrc = crc32(crc, data + (off & ~PAGE_MASK), clen);\n\t\t\tkunmap_atomic(data);\n\t\t\toff += clen;\n\t\t\tlen -= clen;\n\t\t}\n\t}\n\treturn crc;\n}\nEXPORT_SYMBOL_GPL(fcoe_fc_crc);\n\n \nint fcoe_start_io(struct sk_buff *skb)\n{\n\tstruct sk_buff *nskb;\n\tint rc;\n\n\tnskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn -ENOMEM;\n\trc = dev_queue_xmit(nskb);\n\tif (rc != 0)\n\t\treturn rc;\n\tkfree_skb(skb);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fcoe_start_io);\n\n\n \nvoid fcoe_clean_pending_queue(struct fc_lport *lport)\n{\n\tstruct fcoe_port  *port = lport_priv(lport);\n\tstruct sk_buff *skb;\n\n\tspin_lock_bh(&port->fcoe_pending_queue.lock);\n\twhile ((skb = __skb_dequeue(&port->fcoe_pending_queue)) != NULL) {\n\t\tspin_unlock_bh(&port->fcoe_pending_queue.lock);\n\t\tkfree_skb(skb);\n\t\tspin_lock_bh(&port->fcoe_pending_queue.lock);\n\t}\n\tspin_unlock_bh(&port->fcoe_pending_queue.lock);\n}\nEXPORT_SYMBOL_GPL(fcoe_clean_pending_queue);\n\n \nvoid fcoe_check_wait_queue(struct fc_lport *lport, struct sk_buff *skb)\n{\n\tstruct fcoe_port *port = lport_priv(lport);\n\tint rc;\n\n\tspin_lock_bh(&port->fcoe_pending_queue.lock);\n\n\tif (skb)\n\t\t__skb_queue_tail(&port->fcoe_pending_queue, skb);\n\n\tif (port->fcoe_pending_queue_active)\n\t\tgoto out;\n\tport->fcoe_pending_queue_active = 1;\n\n\twhile (port->fcoe_pending_queue.qlen) {\n\t\t \n\t\tport->fcoe_pending_queue.qlen++;\n\t\tskb = __skb_dequeue(&port->fcoe_pending_queue);\n\n\t\tspin_unlock_bh(&port->fcoe_pending_queue.lock);\n\t\trc = fcoe_start_io(skb);\n\t\tspin_lock_bh(&port->fcoe_pending_queue.lock);\n\n\t\tif (rc) {\n\t\t\t__skb_queue_head(&port->fcoe_pending_queue, skb);\n\t\t\t \n\t\t\tport->fcoe_pending_queue.qlen--;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tport->fcoe_pending_queue.qlen--;\n\t}\n\n\tif (port->fcoe_pending_queue.qlen < port->min_queue_depth)\n\t\tlport->qfull = 0;\n\tif (port->fcoe_pending_queue.qlen && !timer_pending(&port->timer))\n\t\tmod_timer(&port->timer, jiffies + 2);\n\tport->fcoe_pending_queue_active = 0;\nout:\n\tif (port->fcoe_pending_queue.qlen > port->max_queue_depth)\n\t\tlport->qfull = 1;\n\tspin_unlock_bh(&port->fcoe_pending_queue.lock);\n}\nEXPORT_SYMBOL_GPL(fcoe_check_wait_queue);\n\n \nvoid fcoe_queue_timer(struct timer_list *t)\n{\n\tstruct fcoe_port *port = from_timer(port, t, timer);\n\n\tfcoe_check_wait_queue(port->lport, NULL);\n}\nEXPORT_SYMBOL_GPL(fcoe_queue_timer);\n\n \nint fcoe_get_paged_crc_eof(struct sk_buff *skb, int tlen,\n\t\t\t   struct fcoe_percpu_s *fps)\n{\n\tstruct page *page;\n\n\tpage = fps->crc_eof_page;\n\tif (!page) {\n\t\tpage = alloc_page(GFP_ATOMIC);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tfps->crc_eof_page = page;\n\t\tfps->crc_eof_offset = 0;\n\t}\n\n\tget_page(page);\n\tskb_fill_page_desc(skb, skb_shinfo(skb)->nr_frags, page,\n\t\t\t   fps->crc_eof_offset, tlen);\n\tskb->len += tlen;\n\tskb->data_len += tlen;\n\tskb->truesize += tlen;\n\tfps->crc_eof_offset += sizeof(struct fcoe_crc_eof);\n\n\tif (fps->crc_eof_offset >= PAGE_SIZE) {\n\t\tfps->crc_eof_page = NULL;\n\t\tfps->crc_eof_offset = 0;\n\t\tput_page(page);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fcoe_get_paged_crc_eof);\n\n \nstatic struct fcoe_transport *fcoe_transport_lookup(struct net_device *netdev)\n{\n\tstruct fcoe_transport *ft = NULL;\n\n\tlist_for_each_entry(ft, &fcoe_transports, list)\n\t\tif (ft->match && ft->match(netdev))\n\t\t\treturn ft;\n\treturn NULL;\n}\n\n \nint fcoe_transport_attach(struct fcoe_transport *ft)\n{\n\tint rc = 0;\n\n\tmutex_lock(&ft_mutex);\n\tif (ft->attached) {\n\t\tLIBFCOE_TRANSPORT_DBG(\"transport %s already attached\\n\",\n\t\t\t\t       ft->name);\n\t\trc = -EEXIST;\n\t\tgoto out_attach;\n\t}\n\n\t \n\tif (strcmp(ft->name, FCOE_TRANSPORT_DEFAULT))\n\t\tlist_add(&ft->list, &fcoe_transports);\n\telse\n\t\tlist_add_tail(&ft->list, &fcoe_transports);\n\n\tft->attached = true;\n\tLIBFCOE_TRANSPORT_DBG(\"attaching transport %s\\n\", ft->name);\n\nout_attach:\n\tmutex_unlock(&ft_mutex);\n\treturn rc;\n}\nEXPORT_SYMBOL(fcoe_transport_attach);\n\n \nint fcoe_transport_detach(struct fcoe_transport *ft)\n{\n\tint rc = 0;\n\tstruct fcoe_netdev_mapping *nm = NULL, *tmp;\n\n\tmutex_lock(&ft_mutex);\n\tif (!ft->attached) {\n\t\tLIBFCOE_TRANSPORT_DBG(\"transport %s already detached\\n\",\n\t\t\tft->name);\n\t\trc = -ENODEV;\n\t\tgoto out_attach;\n\t}\n\n\t \n\tmutex_lock(&fn_mutex);\n\tlist_for_each_entry_safe(nm, tmp, &fcoe_netdevs, list) {\n\t\tif (nm->ft == ft) {\n\t\t\tLIBFCOE_TRANSPORT_DBG(\"transport %s going away, \"\n\t\t\t\t\"remove its netdev mapping for %s\\n\",\n\t\t\t\tft->name, nm->netdev->name);\n\t\t\tlist_del(&nm->list);\n\t\t\tkfree(nm);\n\t\t}\n\t}\n\tmutex_unlock(&fn_mutex);\n\n\tlist_del(&ft->list);\n\tft->attached = false;\n\tLIBFCOE_TRANSPORT_DBG(\"detaching transport %s\\n\", ft->name);\n\nout_attach:\n\tmutex_unlock(&ft_mutex);\n\treturn rc;\n\n}\nEXPORT_SYMBOL(fcoe_transport_detach);\n\nstatic int fcoe_transport_show(char *buffer, const struct kernel_param *kp)\n{\n\tint i, j;\n\tstruct fcoe_transport *ft = NULL;\n\n\ti = j = sprintf(buffer, \"Attached FCoE transports:\");\n\tmutex_lock(&ft_mutex);\n\tlist_for_each_entry(ft, &fcoe_transports, list) {\n\t\tif (i >= PAGE_SIZE - IFNAMSIZ)\n\t\t\tbreak;\n\t\ti += snprintf(&buffer[i], IFNAMSIZ, \"%s \", ft->name);\n\t}\n\tmutex_unlock(&ft_mutex);\n\tif (i == j)\n\t\ti += snprintf(&buffer[i], IFNAMSIZ, \"none\");\n\treturn i;\n}\n\nstatic int __init fcoe_transport_init(void)\n{\n\tregister_netdevice_notifier(&libfcoe_notifier);\n\treturn 0;\n}\n\nstatic int fcoe_transport_exit(void)\n{\n\tstruct fcoe_transport *ft;\n\n\tunregister_netdevice_notifier(&libfcoe_notifier);\n\tmutex_lock(&ft_mutex);\n\tlist_for_each_entry(ft, &fcoe_transports, list)\n\t\tprintk(KERN_ERR \"FCoE transport %s is still attached!\\n\",\n\t\t      ft->name);\n\tmutex_unlock(&ft_mutex);\n\treturn 0;\n}\n\n\nstatic int fcoe_add_netdev_mapping(struct net_device *netdev,\n\t\t\t\t\tstruct fcoe_transport *ft)\n{\n\tstruct fcoe_netdev_mapping *nm;\n\n\tnm = kmalloc(sizeof(*nm), GFP_KERNEL);\n\tif (!nm) {\n\t\tprintk(KERN_ERR \"Unable to allocate netdev_mapping\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnm->netdev = netdev;\n\tnm->ft = ft;\n\n\tmutex_lock(&fn_mutex);\n\tlist_add(&nm->list, &fcoe_netdevs);\n\tmutex_unlock(&fn_mutex);\n\treturn 0;\n}\n\n\nstatic void fcoe_del_netdev_mapping(struct net_device *netdev)\n{\n\tstruct fcoe_netdev_mapping *nm = NULL, *tmp;\n\n\tmutex_lock(&fn_mutex);\n\tlist_for_each_entry_safe(nm, tmp, &fcoe_netdevs, list) {\n\t\tif (nm->netdev == netdev) {\n\t\t\tlist_del(&nm->list);\n\t\t\tkfree(nm);\n\t\t\tmutex_unlock(&fn_mutex);\n\t\t\treturn;\n\t\t}\n\t}\n\tmutex_unlock(&fn_mutex);\n}\n\n\n \nstatic struct fcoe_transport *fcoe_netdev_map_lookup(struct net_device *netdev)\n{\n\tstruct fcoe_transport *ft = NULL;\n\tstruct fcoe_netdev_mapping *nm;\n\n\tmutex_lock(&fn_mutex);\n\tlist_for_each_entry(nm, &fcoe_netdevs, list) {\n\t\tif (netdev == nm->netdev) {\n\t\t\tft = nm->ft;\n\t\t\tmutex_unlock(&fn_mutex);\n\t\t\treturn ft;\n\t\t}\n\t}\n\n\tmutex_unlock(&fn_mutex);\n\treturn NULL;\n}\n\n \nstatic struct net_device *fcoe_if_to_netdev(const char *buffer)\n{\n\tchar *cp;\n\tchar ifname[IFNAMSIZ + 2];\n\n\tif (buffer) {\n\t\tstrscpy(ifname, buffer, IFNAMSIZ);\n\t\tcp = ifname + strlen(ifname);\n\t\twhile (--cp >= ifname && *cp == '\\n')\n\t\t\t*cp = '\\0';\n\t\treturn dev_get_by_name(&init_net, ifname);\n\t}\n\treturn NULL;\n}\n\n \nstatic int libfcoe_device_notification(struct notifier_block *notifier,\n\t\t\t\t    ulong event, void *ptr)\n{\n\tstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\n\n\tswitch (event) {\n\tcase NETDEV_UNREGISTER:\n\t\tLIBFCOE_TRANSPORT_DBG(\"NETDEV_UNREGISTER %s\\n\",\n\t\t\t\t      netdev->name);\n\t\tfcoe_del_netdev_mapping(netdev);\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nssize_t fcoe_ctlr_create_store(const char *buf, size_t count)\n{\n\tstruct net_device *netdev = NULL;\n\tstruct fcoe_transport *ft = NULL;\n\tint rc = 0;\n\tint err;\n\n\tmutex_lock(&ft_mutex);\n\n\tnetdev = fcoe_if_to_netdev(buf);\n\tif (!netdev) {\n\t\tLIBFCOE_TRANSPORT_DBG(\"Invalid device %s.\\n\", buf);\n\t\trc = -ENODEV;\n\t\tgoto out_nodev;\n\t}\n\n\tft = fcoe_netdev_map_lookup(netdev);\n\tif (ft) {\n\t\tLIBFCOE_TRANSPORT_DBG(\"transport %s already has existing \"\n\t\t\t\t      \"FCoE instance on %s.\\n\",\n\t\t\t\t      ft->name, netdev->name);\n\t\trc = -EEXIST;\n\t\tgoto out_putdev;\n\t}\n\n\tft = fcoe_transport_lookup(netdev);\n\tif (!ft) {\n\t\tLIBFCOE_TRANSPORT_DBG(\"no FCoE transport found for %s.\\n\",\n\t\t\t\t      netdev->name);\n\t\trc = -ENODEV;\n\t\tgoto out_putdev;\n\t}\n\n\t \n\terr = ft->alloc ? ft->alloc(netdev) : -ENODEV;\n\tif (err) {\n\t\tfcoe_del_netdev_mapping(netdev);\n\t\trc = -ENOMEM;\n\t\tgoto out_putdev;\n\t}\n\n\terr = fcoe_add_netdev_mapping(netdev, ft);\n\tif (err) {\n\t\tLIBFCOE_TRANSPORT_DBG(\"failed to add new netdev mapping \"\n\t\t\t\t      \"for FCoE transport %s for %s.\\n\",\n\t\t\t\t      ft->name, netdev->name);\n\t\trc = -ENODEV;\n\t\tgoto out_putdev;\n\t}\n\n\tLIBFCOE_TRANSPORT_DBG(\"transport %s succeeded to create fcoe on %s.\\n\",\n\t\t\t      ft->name, netdev->name);\n\nout_putdev:\n\tdev_put(netdev);\nout_nodev:\n\tmutex_unlock(&ft_mutex);\n\tif (rc)\n\t\treturn rc;\n\treturn count;\n}\n\nssize_t fcoe_ctlr_destroy_store(const char *buf, size_t count)\n{\n\tint rc = -ENODEV;\n\tstruct net_device *netdev = NULL;\n\tstruct fcoe_transport *ft = NULL;\n\n\tmutex_lock(&ft_mutex);\n\n\tnetdev = fcoe_if_to_netdev(buf);\n\tif (!netdev) {\n\t\tLIBFCOE_TRANSPORT_DBG(\"invalid device %s.\\n\", buf);\n\t\tgoto out_nodev;\n\t}\n\n\tft = fcoe_netdev_map_lookup(netdev);\n\tif (!ft) {\n\t\tLIBFCOE_TRANSPORT_DBG(\"no FCoE transport found for %s.\\n\",\n\t\t\t\t      netdev->name);\n\t\tgoto out_putdev;\n\t}\n\n\t \n\trc = ft->destroy(netdev);\n\tif (rc)\n\t\tgoto out_putdev;\n\n\tfcoe_del_netdev_mapping(netdev);\n\tLIBFCOE_TRANSPORT_DBG(\"transport %s %s to destroy fcoe on %s.\\n\",\n\t\t\t      ft->name, (rc) ? \"failed\" : \"succeeded\",\n\t\t\t      netdev->name);\n\trc = count;  \nout_putdev:\n\tdev_put(netdev);\nout_nodev:\n\tmutex_unlock(&ft_mutex);\n\treturn rc;\n}\n\n \nstatic int fcoe_transport_create(const char *buffer,\n\t\t\t\t const struct kernel_param *kp)\n{\n\tint rc = -ENODEV;\n\tstruct net_device *netdev = NULL;\n\tstruct fcoe_transport *ft = NULL;\n\tenum fip_mode fip_mode = (enum fip_mode)(uintptr_t)kp->arg;\n\n\tmutex_lock(&ft_mutex);\n\n\tnetdev = fcoe_if_to_netdev(buffer);\n\tif (!netdev) {\n\t\tLIBFCOE_TRANSPORT_DBG(\"Invalid device %s.\\n\", buffer);\n\t\tgoto out_nodev;\n\t}\n\n\tft = fcoe_netdev_map_lookup(netdev);\n\tif (ft) {\n\t\tLIBFCOE_TRANSPORT_DBG(\"transport %s already has existing \"\n\t\t\t\t      \"FCoE instance on %s.\\n\",\n\t\t\t\t      ft->name, netdev->name);\n\t\trc = -EEXIST;\n\t\tgoto out_putdev;\n\t}\n\n\tft = fcoe_transport_lookup(netdev);\n\tif (!ft) {\n\t\tLIBFCOE_TRANSPORT_DBG(\"no FCoE transport found for %s.\\n\",\n\t\t\t\t      netdev->name);\n\t\tgoto out_putdev;\n\t}\n\n\trc = fcoe_add_netdev_mapping(netdev, ft);\n\tif (rc) {\n\t\tLIBFCOE_TRANSPORT_DBG(\"failed to add new netdev mapping \"\n\t\t\t\t      \"for FCoE transport %s for %s.\\n\",\n\t\t\t\t      ft->name, netdev->name);\n\t\tgoto out_putdev;\n\t}\n\n\t \n\trc = ft->create ? ft->create(netdev, fip_mode) : -ENODEV;\n\tif (rc)\n\t\tfcoe_del_netdev_mapping(netdev);\n\n\tLIBFCOE_TRANSPORT_DBG(\"transport %s %s to create fcoe on %s.\\n\",\n\t\t\t      ft->name, (rc) ? \"failed\" : \"succeeded\",\n\t\t\t      netdev->name);\n\nout_putdev:\n\tdev_put(netdev);\nout_nodev:\n\tmutex_unlock(&ft_mutex);\n\treturn rc;\n}\n\n \nstatic int fcoe_transport_destroy(const char *buffer,\n\t\t\t\t  const struct kernel_param *kp)\n{\n\tint rc = -ENODEV;\n\tstruct net_device *netdev = NULL;\n\tstruct fcoe_transport *ft = NULL;\n\n\tmutex_lock(&ft_mutex);\n\n\tnetdev = fcoe_if_to_netdev(buffer);\n\tif (!netdev) {\n\t\tLIBFCOE_TRANSPORT_DBG(\"invalid device %s.\\n\", buffer);\n\t\tgoto out_nodev;\n\t}\n\n\tft = fcoe_netdev_map_lookup(netdev);\n\tif (!ft) {\n\t\tLIBFCOE_TRANSPORT_DBG(\"no FCoE transport found for %s.\\n\",\n\t\t\t\t      netdev->name);\n\t\tgoto out_putdev;\n\t}\n\n\t \n\trc = ft->destroy ? ft->destroy(netdev) : -ENODEV;\n\tfcoe_del_netdev_mapping(netdev);\n\tLIBFCOE_TRANSPORT_DBG(\"transport %s %s to destroy fcoe on %s.\\n\",\n\t\t\t      ft->name, (rc) ? \"failed\" : \"succeeded\",\n\t\t\t      netdev->name);\n\nout_putdev:\n\tdev_put(netdev);\nout_nodev:\n\tmutex_unlock(&ft_mutex);\n\treturn rc;\n}\n\n \nstatic int fcoe_transport_disable(const char *buffer,\n\t\t\t\t  const struct kernel_param *kp)\n{\n\tint rc = -ENODEV;\n\tstruct net_device *netdev = NULL;\n\tstruct fcoe_transport *ft = NULL;\n\n\tmutex_lock(&ft_mutex);\n\n\tnetdev = fcoe_if_to_netdev(buffer);\n\tif (!netdev)\n\t\tgoto out_nodev;\n\n\tft = fcoe_netdev_map_lookup(netdev);\n\tif (!ft)\n\t\tgoto out_putdev;\n\n\trc = ft->disable ? ft->disable(netdev) : -ENODEV;\n\nout_putdev:\n\tdev_put(netdev);\nout_nodev:\n\tmutex_unlock(&ft_mutex);\n\treturn rc;\n}\n\n \nstatic int fcoe_transport_enable(const char *buffer,\n\t\t\t\t const struct kernel_param *kp)\n{\n\tint rc = -ENODEV;\n\tstruct net_device *netdev = NULL;\n\tstruct fcoe_transport *ft = NULL;\n\n\tmutex_lock(&ft_mutex);\n\n\tnetdev = fcoe_if_to_netdev(buffer);\n\tif (!netdev)\n\t\tgoto out_nodev;\n\n\tft = fcoe_netdev_map_lookup(netdev);\n\tif (!ft)\n\t\tgoto out_putdev;\n\n\trc = ft->enable ? ft->enable(netdev) : -ENODEV;\n\nout_putdev:\n\tdev_put(netdev);\nout_nodev:\n\tmutex_unlock(&ft_mutex);\n\treturn rc;\n}\n\n \nstatic int __init libfcoe_init(void)\n{\n\tint rc = 0;\n\n\trc = fcoe_transport_init();\n\tif (rc)\n\t\treturn rc;\n\n\trc = fcoe_sysfs_setup();\n\tif (rc)\n\t\tfcoe_transport_exit();\n\n\treturn rc;\n}\nmodule_init(libfcoe_init);\n\n \nstatic void __exit libfcoe_exit(void)\n{\n\tfcoe_sysfs_teardown();\n\tfcoe_transport_exit();\n}\nmodule_exit(libfcoe_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}