{
  "module_name": "ses.c",
  "hash_id": "cfcfd94dcf020068f70465eb88b41bb5cfd3b72963edf8431877405646f15e86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/ses.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/enclosure.h>\n#include <asm/unaligned.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_driver.h>\n#include <scsi/scsi_host.h>\n\n#include <scsi/scsi_transport_sas.h>\n\nstruct ses_device {\n\tunsigned char *page1;\n\tunsigned char *page1_types;\n\tunsigned char *page2;\n\tunsigned char *page10;\n\tshort page1_len;\n\tshort page1_num_types;\n\tshort page2_len;\n\tshort page10_len;\n};\n\nstruct ses_component {\n\tu64 addr;\n};\n\nstatic bool ses_page2_supported(struct enclosure_device *edev)\n{\n\tstruct ses_device *ses_dev = edev->scratch;\n\n\treturn (ses_dev->page2 != NULL);\n}\n\nstatic int ses_probe(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tint err = -ENODEV;\n\n\tif (sdev->type != TYPE_ENCLOSURE)\n\t\tgoto out;\n\n\terr = 0;\n\tsdev_printk(KERN_NOTICE, sdev, \"Attached Enclosure device\\n\");\n\n out:\n\treturn err;\n}\n\n#define SES_TIMEOUT (30 * HZ)\n#define SES_RETRIES 3\n\nstatic void init_device_slot_control(unsigned char *dest_desc,\n\t\t\t\t     struct enclosure_component *ecomp,\n\t\t\t\t     unsigned char *status)\n{\n\tmemcpy(dest_desc, status, 4);\n\tdest_desc[0] = 0;\n\t \n\tif (ecomp->type == ENCLOSURE_COMPONENT_DEVICE)\n\t\tdest_desc[1] = 0;\n\tdest_desc[2] &= 0xde;\n\tdest_desc[3] &= 0x3c;\n}\n\n\nstatic int ses_recv_diag(struct scsi_device *sdev, int page_code,\n\t\t\t void *buf, int bufflen)\n{\n\tint ret;\n\tunsigned char cmd[] = {\n\t\tRECEIVE_DIAGNOSTIC,\n\t\t1,\t\t \n\t\tpage_code,\n\t\tbufflen >> 8,\n\t\tbufflen & 0xff,\n\t\t0\n\t};\n\tunsigned char recv_page_code;\n\tunsigned int retries = SES_RETRIES;\n\tstruct scsi_sense_hdr sshdr;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\n\tdo {\n\t\tret = scsi_execute_cmd(sdev, cmd, REQ_OP_DRV_IN, buf, bufflen,\n\t\t\t\t       SES_TIMEOUT, 1, &exec_args);\n\t} while (ret > 0 && --retries && scsi_sense_valid(&sshdr) &&\n\t\t (sshdr.sense_key == NOT_READY ||\n\t\t  (sshdr.sense_key == UNIT_ATTENTION && sshdr.asc == 0x29)));\n\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\trecv_page_code = ((unsigned char *)buf)[0];\n\n\tif (likely(recv_page_code == page_code))\n\t\treturn ret;\n\n\t \n\n\tsdev_printk(KERN_ERR, sdev,\n\t\t    \"Wrong diagnostic page; asked for %d got %u\\n\",\n\t\t    page_code, recv_page_code);\n\n\treturn -EINVAL;\n}\n\nstatic int ses_send_diag(struct scsi_device *sdev, int page_code,\n\t\t\t void *buf, int bufflen)\n{\n\tint result;\n\n\tunsigned char cmd[] = {\n\t\tSEND_DIAGNOSTIC,\n\t\t0x10,\t\t \n\t\t0,\n\t\tbufflen >> 8,\n\t\tbufflen & 0xff,\n\t\t0\n\t};\n\tstruct scsi_sense_hdr sshdr;\n\tunsigned int retries = SES_RETRIES;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\n\tdo {\n\t\tresult = scsi_execute_cmd(sdev, cmd, REQ_OP_DRV_OUT, buf,\n\t\t\t\t\t  bufflen, SES_TIMEOUT, 1, &exec_args);\n\t} while (result > 0 && --retries && scsi_sense_valid(&sshdr) &&\n\t\t (sshdr.sense_key == NOT_READY ||\n\t\t  (sshdr.sense_key == UNIT_ATTENTION && sshdr.asc == 0x29)));\n\n\tif (result)\n\t\tsdev_printk(KERN_ERR, sdev, \"SEND DIAGNOSTIC result: %8x\\n\",\n\t\t\t    result);\n\treturn result;\n}\n\nstatic int ses_set_page2_descriptor(struct enclosure_device *edev,\n\t\t\t\t      struct enclosure_component *ecomp,\n\t\t\t\t      unsigned char *desc)\n{\n\tint i, j, count = 0, descriptor = ecomp->number;\n\tstruct scsi_device *sdev = to_scsi_device(edev->edev.parent);\n\tstruct ses_device *ses_dev = edev->scratch;\n\tunsigned char *type_ptr = ses_dev->page1_types;\n\tunsigned char *desc_ptr = ses_dev->page2 + 8;\n\n\t \n\tmemset(desc_ptr, 0, ses_dev->page2_len - 8);\n\tfor (i = 0; i < ses_dev->page1_num_types; i++, type_ptr += 4) {\n\t\tfor (j = 0; j < type_ptr[1]; j++) {\n\t\t\tdesc_ptr += 4;\n\t\t\tif (type_ptr[0] != ENCLOSURE_COMPONENT_DEVICE &&\n\t\t\t    type_ptr[0] != ENCLOSURE_COMPONENT_ARRAY_DEVICE)\n\t\t\t\tcontinue;\n\t\t\tif (count++ == descriptor) {\n\t\t\t\tmemcpy(desc_ptr, desc, 4);\n\t\t\t\t \n\t\t\t\tdesc_ptr[0] |= 0x80;\n\t\t\t\t \n\t\t\t\tdesc_ptr[0] &= 0xf0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ses_send_diag(sdev, 2, ses_dev->page2, ses_dev->page2_len);\n}\n\nstatic unsigned char *ses_get_page2_descriptor(struct enclosure_device *edev,\n\t\t\t\t      struct enclosure_component *ecomp)\n{\n\tint i, j, count = 0, descriptor = ecomp->number;\n\tstruct scsi_device *sdev = to_scsi_device(edev->edev.parent);\n\tstruct ses_device *ses_dev = edev->scratch;\n\tunsigned char *type_ptr = ses_dev->page1_types;\n\tunsigned char *desc_ptr = ses_dev->page2 + 8;\n\n\tif (ses_recv_diag(sdev, 2, ses_dev->page2, ses_dev->page2_len) < 0)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ses_dev->page1_num_types; i++, type_ptr += 4) {\n\t\tfor (j = 0; j < type_ptr[1]; j++) {\n\t\t\tdesc_ptr += 4;\n\t\t\tif (type_ptr[0] != ENCLOSURE_COMPONENT_DEVICE &&\n\t\t\t    type_ptr[0] != ENCLOSURE_COMPONENT_ARRAY_DEVICE)\n\t\t\t\tcontinue;\n\t\t\tif (count++ == descriptor)\n\t\t\t\treturn desc_ptr;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic void ses_get_fault(struct enclosure_device *edev,\n\t\t\t  struct enclosure_component *ecomp)\n{\n\tunsigned char *desc;\n\n\tif (!ses_page2_supported(edev)) {\n\t\tecomp->fault = 0;\n\t\treturn;\n\t}\n\tdesc = ses_get_page2_descriptor(edev, ecomp);\n\tif (desc)\n\t\tecomp->fault = (desc[3] & 0x60) >> 4;\n}\n\nstatic int ses_set_fault(struct enclosure_device *edev,\n\t\t\t  struct enclosure_component *ecomp,\n\t\t\t enum enclosure_component_setting val)\n{\n\tunsigned char desc[4];\n\tunsigned char *desc_ptr;\n\n\tif (!ses_page2_supported(edev))\n\t\treturn -EINVAL;\n\n\tdesc_ptr = ses_get_page2_descriptor(edev, ecomp);\n\n\tif (!desc_ptr)\n\t\treturn -EIO;\n\n\tinit_device_slot_control(desc, ecomp, desc_ptr);\n\n\tswitch (val) {\n\tcase ENCLOSURE_SETTING_DISABLED:\n\t\tdesc[3] &= 0xdf;\n\t\tbreak;\n\tcase ENCLOSURE_SETTING_ENABLED:\n\t\tdesc[3] |= 0x20;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treturn ses_set_page2_descriptor(edev, ecomp, desc);\n}\n\nstatic void ses_get_status(struct enclosure_device *edev,\n\t\t\t   struct enclosure_component *ecomp)\n{\n\tunsigned char *desc;\n\n\tif (!ses_page2_supported(edev)) {\n\t\tecomp->status = 0;\n\t\treturn;\n\t}\n\tdesc = ses_get_page2_descriptor(edev, ecomp);\n\tif (desc)\n\t\tecomp->status = (desc[0] & 0x0f);\n}\n\nstatic void ses_get_locate(struct enclosure_device *edev,\n\t\t\t   struct enclosure_component *ecomp)\n{\n\tunsigned char *desc;\n\n\tif (!ses_page2_supported(edev)) {\n\t\tecomp->locate = 0;\n\t\treturn;\n\t}\n\tdesc = ses_get_page2_descriptor(edev, ecomp);\n\tif (desc)\n\t\tecomp->locate = (desc[2] & 0x02) ? 1 : 0;\n}\n\nstatic int ses_set_locate(struct enclosure_device *edev,\n\t\t\t  struct enclosure_component *ecomp,\n\t\t\t  enum enclosure_component_setting val)\n{\n\tunsigned char desc[4];\n\tunsigned char *desc_ptr;\n\n\tif (!ses_page2_supported(edev))\n\t\treturn -EINVAL;\n\n\tdesc_ptr = ses_get_page2_descriptor(edev, ecomp);\n\n\tif (!desc_ptr)\n\t\treturn -EIO;\n\n\tinit_device_slot_control(desc, ecomp, desc_ptr);\n\n\tswitch (val) {\n\tcase ENCLOSURE_SETTING_DISABLED:\n\t\tdesc[2] &= 0xfd;\n\t\tbreak;\n\tcase ENCLOSURE_SETTING_ENABLED:\n\t\tdesc[2] |= 0x02;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\treturn ses_set_page2_descriptor(edev, ecomp, desc);\n}\n\nstatic int ses_set_active(struct enclosure_device *edev,\n\t\t\t  struct enclosure_component *ecomp,\n\t\t\t  enum enclosure_component_setting val)\n{\n\tunsigned char desc[4];\n\tunsigned char *desc_ptr;\n\n\tif (!ses_page2_supported(edev))\n\t\treturn -EINVAL;\n\n\tdesc_ptr = ses_get_page2_descriptor(edev, ecomp);\n\n\tif (!desc_ptr)\n\t\treturn -EIO;\n\n\tinit_device_slot_control(desc, ecomp, desc_ptr);\n\n\tswitch (val) {\n\tcase ENCLOSURE_SETTING_DISABLED:\n\t\tdesc[2] &= 0x7f;\n\t\tecomp->active = 0;\n\t\tbreak;\n\tcase ENCLOSURE_SETTING_ENABLED:\n\t\tdesc[2] |= 0x80;\n\t\tecomp->active = 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\treturn ses_set_page2_descriptor(edev, ecomp, desc);\n}\n\nstatic int ses_show_id(struct enclosure_device *edev, char *buf)\n{\n\tstruct ses_device *ses_dev = edev->scratch;\n\tunsigned long long id = get_unaligned_be64(ses_dev->page1+8+4);\n\n\treturn sprintf(buf, \"%#llx\\n\", id);\n}\n\nstatic void ses_get_power_status(struct enclosure_device *edev,\n\t\t\t\t struct enclosure_component *ecomp)\n{\n\tunsigned char *desc;\n\n\tif (!ses_page2_supported(edev)) {\n\t\tecomp->power_status = 0;\n\t\treturn;\n\t}\n\n\tdesc = ses_get_page2_descriptor(edev, ecomp);\n\tif (desc)\n\t\tecomp->power_status = (desc[3] & 0x10) ? 0 : 1;\n}\n\nstatic int ses_set_power_status(struct enclosure_device *edev,\n\t\t\t\tstruct enclosure_component *ecomp,\n\t\t\t\tint val)\n{\n\tunsigned char desc[4];\n\tunsigned char *desc_ptr;\n\n\tif (!ses_page2_supported(edev))\n\t\treturn -EINVAL;\n\n\tdesc_ptr = ses_get_page2_descriptor(edev, ecomp);\n\n\tif (!desc_ptr)\n\t\treturn -EIO;\n\n\tinit_device_slot_control(desc, ecomp, desc_ptr);\n\n\tswitch (val) {\n\t \n\tcase 0:\n\t\tdesc[3] |= 0x10;\n\t\tbreak;\n\tcase 1:\n\t\tdesc[3] &= 0xef;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tecomp->power_status = val;\n\treturn ses_set_page2_descriptor(edev, ecomp, desc);\n}\n\nstatic struct enclosure_component_callbacks ses_enclosure_callbacks = {\n\t.get_fault\t\t= ses_get_fault,\n\t.set_fault\t\t= ses_set_fault,\n\t.get_status\t\t= ses_get_status,\n\t.get_locate\t\t= ses_get_locate,\n\t.set_locate\t\t= ses_set_locate,\n\t.get_power_status\t= ses_get_power_status,\n\t.set_power_status\t= ses_set_power_status,\n\t.set_active\t\t= ses_set_active,\n\t.show_id\t\t= ses_show_id,\n};\n\nstruct ses_host_edev {\n\tstruct Scsi_Host *shost;\n\tstruct enclosure_device *edev;\n};\n\n#if 0\nint ses_match_host(struct enclosure_device *edev, void *data)\n{\n\tstruct ses_host_edev *sed = data;\n\tstruct scsi_device *sdev;\n\n\tif (!scsi_is_sdev_device(edev->edev.parent))\n\t\treturn 0;\n\n\tsdev = to_scsi_device(edev->edev.parent);\n\n\tif (sdev->host != sed->shost)\n\t\treturn 0;\n\n\tsed->edev = edev;\n\treturn 1;\n}\n#endif   \n\nstatic int ses_process_descriptor(struct enclosure_component *ecomp,\n\t\t\t\t   unsigned char *desc, int max_desc_len)\n{\n\tint eip = desc[0] & 0x10;\n\tint invalid = desc[0] & 0x80;\n\tenum scsi_protocol proto = desc[0] & 0x0f;\n\tu64 addr = 0;\n\tint slot = -1;\n\tstruct ses_component *scomp = ecomp->scratch;\n\tunsigned char *d;\n\n\tif (invalid)\n\t\treturn 0;\n\n\tswitch (proto) {\n\tcase SCSI_PROTOCOL_FCP:\n\t\tif (eip) {\n\t\t\tif (max_desc_len <= 7)\n\t\t\t\treturn 1;\n\t\t\td = desc + 4;\n\t\t\tslot = d[3];\n\t\t}\n\t\tbreak;\n\tcase SCSI_PROTOCOL_SAS:\n\n\t\tif (eip) {\n\t\t\tif (max_desc_len <= 27)\n\t\t\t\treturn 1;\n\t\t\td = desc + 4;\n\t\t\tslot = d[3];\n\t\t\td = desc + 8;\n\t\t} else {\n\t\t\tif (max_desc_len <= 23)\n\t\t\t\treturn 1;\n\t\t\td = desc + 4;\n\t\t}\n\n\n\t\t \n\t\taddr = (u64)d[12] << 56 |\n\t\t\t(u64)d[13] << 48 |\n\t\t\t(u64)d[14] << 40 |\n\t\t\t(u64)d[15] << 32 |\n\t\t\t(u64)d[16] << 24 |\n\t\t\t(u64)d[17] << 16 |\n\t\t\t(u64)d[18] << 8 |\n\t\t\t(u64)d[19];\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\tecomp->slot = slot;\n\tscomp->addr = addr;\n\n\treturn 0;\n}\n\nstruct efd {\n\tu64 addr;\n\tstruct device *dev;\n};\n\nstatic int ses_enclosure_find_by_addr(struct enclosure_device *edev,\n\t\t\t\t      void *data)\n{\n\tstruct efd *efd = data;\n\tint i;\n\tstruct ses_component *scomp;\n\n\tfor (i = 0; i < edev->components; i++) {\n\t\tscomp = edev->component[i].scratch;\n\t\tif (scomp->addr != efd->addr)\n\t\t\tcontinue;\n\n\t\tif (enclosure_add_device(edev, i, efd->dev) == 0)\n\t\t\tkobject_uevent(&efd->dev->kobj, KOBJ_CHANGE);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#define INIT_ALLOC_SIZE 32\n\nstatic void ses_enclosure_data_process(struct enclosure_device *edev,\n\t\t\t\t       struct scsi_device *sdev,\n\t\t\t\t       int create)\n{\n\tu32 result;\n\tunsigned char *buf = NULL, *type_ptr, *desc_ptr, *addl_desc_ptr = NULL;\n\tint i, j, page7_len, len, components;\n\tstruct ses_device *ses_dev = edev->scratch;\n\tint types = ses_dev->page1_num_types;\n\tunsigned char *hdr_buf = kzalloc(INIT_ALLOC_SIZE, GFP_KERNEL);\n\n\tif (!hdr_buf)\n\t\tgoto simple_populate;\n\n\t \n\tif (ses_dev->page10)\n\t\tses_recv_diag(sdev, 10, ses_dev->page10, ses_dev->page10_len);\n\t \n\tresult = ses_recv_diag(sdev, 7, hdr_buf, INIT_ALLOC_SIZE);\n\tif (result)\n\t\tgoto simple_populate;\n\n\tpage7_len = len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;\n\t \n\tbuf = kzalloc(len + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto simple_populate;\n\tresult = ses_recv_diag(sdev, 7, buf, len);\n\tif (result) {\n simple_populate:\n\t\tkfree(buf);\n\t\tbuf = NULL;\n\t\tdesc_ptr = NULL;\n\t\tlen = 0;\n\t\tpage7_len = 0;\n\t} else {\n\t\tdesc_ptr = buf + 8;\n\t\tlen = (desc_ptr[2] << 8) + desc_ptr[3];\n\t\t \n\t\tdesc_ptr += len + 4;\n\t}\n\tif (ses_dev->page10 && ses_dev->page10_len > 9)\n\t\taddl_desc_ptr = ses_dev->page10 + 8;\n\ttype_ptr = ses_dev->page1_types;\n\tcomponents = 0;\n\tfor (i = 0; i < types; i++, type_ptr += 4) {\n\t\tfor (j = 0; j < type_ptr[1]; j++) {\n\t\t\tchar *name = NULL;\n\t\t\tstruct enclosure_component *ecomp;\n\t\t\tint max_desc_len;\n\n\t\t\tif (desc_ptr) {\n\t\t\t\tif (desc_ptr + 3 >= buf + page7_len) {\n\t\t\t\t\tdesc_ptr = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tlen = (desc_ptr[2] << 8) + desc_ptr[3];\n\t\t\t\t\tdesc_ptr += 4;\n\t\t\t\t\tif (desc_ptr + len > buf + page7_len)\n\t\t\t\t\t\tdesc_ptr = NULL;\n\t\t\t\t\telse {\n\t\t\t\t\t\t \n\t\t\t\t\t\tdesc_ptr[len] = '\\0';\n\t\t\t\t\t\tname = desc_ptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||\n\t\t\t    type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE) {\n\n\t\t\t\tif (create)\n\t\t\t\t\tecomp =\tenclosure_component_alloc(\n\t\t\t\t\t\tedev,\n\t\t\t\t\t\tcomponents++,\n\t\t\t\t\t\ttype_ptr[0],\n\t\t\t\t\t\tname);\n\t\t\t\telse if (components < edev->components)\n\t\t\t\t\tecomp = &edev->component[components++];\n\t\t\t\telse\n\t\t\t\t\tecomp = ERR_PTR(-EINVAL);\n\n\t\t\t\tif (!IS_ERR(ecomp)) {\n\t\t\t\t\tif (addl_desc_ptr) {\n\t\t\t\t\t\tmax_desc_len = ses_dev->page10_len -\n\t\t\t\t\t\t    (addl_desc_ptr - ses_dev->page10);\n\t\t\t\t\t\tif (ses_process_descriptor(ecomp,\n\t\t\t\t\t\t    addl_desc_ptr,\n\t\t\t\t\t\t    max_desc_len))\n\t\t\t\t\t\t\taddl_desc_ptr = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (create)\n\t\t\t\t\t\tenclosure_component_register(\n\t\t\t\t\t\t\tecomp);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (desc_ptr)\n\t\t\t\tdesc_ptr += len;\n\n\t\t\tif (addl_desc_ptr &&\n\t\t\t     \n\t\t\t    (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||\n\t\t\t     type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE ||\n\t\t\t     type_ptr[0] == ENCLOSURE_COMPONENT_SAS_EXPANDER ||\n\t\t\t      \n\t\t\t     type_ptr[0] == ENCLOSURE_COMPONENT_SCSI_TARGET_PORT ||\n\t\t\t     type_ptr[0] == ENCLOSURE_COMPONENT_SCSI_INITIATOR_PORT ||\n\t\t\t     type_ptr[0] == ENCLOSURE_COMPONENT_CONTROLLER_ELECTRONICS)) {\n\t\t\t\taddl_desc_ptr += addl_desc_ptr[1] + 2;\n\t\t\t\tif (addl_desc_ptr + 1 >= ses_dev->page10 + ses_dev->page10_len)\n\t\t\t\t\taddl_desc_ptr = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tkfree(buf);\n\tkfree(hdr_buf);\n}\n\nstatic void ses_match_to_enclosure(struct enclosure_device *edev,\n\t\t\t\t   struct scsi_device *sdev,\n\t\t\t\t   int refresh)\n{\n\tstruct scsi_device *edev_sdev = to_scsi_device(edev->edev.parent);\n\tstruct efd efd = {\n\t\t.addr = 0,\n\t};\n\n\tif (refresh)\n\t\tses_enclosure_data_process(edev, edev_sdev, 0);\n\n\tif (scsi_is_sas_rphy(sdev->sdev_target->dev.parent))\n\t\tefd.addr = sas_get_address(sdev);\n\n\tif (efd.addr) {\n\t\tefd.dev = &sdev->sdev_gendev;\n\n\t\tenclosure_for_each_device(ses_enclosure_find_by_addr, &efd);\n\t}\n}\n\nstatic int ses_intf_add(struct device *cdev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(cdev->parent);\n\tstruct scsi_device *tmp_sdev;\n\tunsigned char *buf = NULL, *hdr_buf, *type_ptr, page;\n\tstruct ses_device *ses_dev;\n\tu32 result;\n\tint i, types, len, components = 0;\n\tint err = -ENOMEM;\n\tint num_enclosures;\n\tstruct enclosure_device *edev;\n\tstruct ses_component *scomp = NULL;\n\n\tif (!scsi_device_enclosure(sdev)) {\n\t\t \n\t\tstruct enclosure_device *prev = NULL;\n\n\t\twhile ((edev = enclosure_find(&sdev->host->shost_gendev, prev)) != NULL) {\n\t\t\tses_match_to_enclosure(edev, sdev, 1);\n\t\t\tprev = edev;\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (sdev->type != TYPE_ENCLOSURE)\n\t\tsdev_printk(KERN_NOTICE, sdev, \"Embedded Enclosure Device\\n\");\n\n\tses_dev = kzalloc(sizeof(*ses_dev), GFP_KERNEL);\n\thdr_buf = kzalloc(INIT_ALLOC_SIZE, GFP_KERNEL);\n\tif (!hdr_buf || !ses_dev)\n\t\tgoto err_init_free;\n\n\tpage = 1;\n\tresult = ses_recv_diag(sdev, page, hdr_buf, INIT_ALLOC_SIZE);\n\tif (result)\n\t\tgoto recv_failed;\n\n\tlen = (hdr_buf[2] << 8) + hdr_buf[3] + 4;\n\tbuf = kzalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err_free;\n\n\tresult = ses_recv_diag(sdev, page, buf, len);\n\tif (result)\n\t\tgoto recv_failed;\n\n\ttypes = 0;\n\n\t \n\tnum_enclosures = buf[1] + 1;\n\n\t \n\ttype_ptr = buf + 8;\n\t \n\tfor (i = 0; i < num_enclosures && type_ptr < buf + len; i++) {\n\t\ttypes += type_ptr[2];\n\t\ttype_ptr += type_ptr[3] + 4;\n\t}\n\n\tses_dev->page1_types = type_ptr;\n\tses_dev->page1_num_types = types;\n\n\tfor (i = 0; i < types && type_ptr < buf + len; i++, type_ptr += 4) {\n\t\tif (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||\n\t\t    type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE)\n\t\t\tcomponents += type_ptr[1];\n\t}\n\n\tses_dev->page1 = buf;\n\tses_dev->page1_len = len;\n\tbuf = NULL;\n\n\tpage = 2;\n\tresult = ses_recv_diag(sdev, page, hdr_buf, INIT_ALLOC_SIZE);\n\tif (result)\n\t\tgoto page2_not_supported;\n\n\tlen = (hdr_buf[2] << 8) + hdr_buf[3] + 4;\n\tbuf = kzalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err_free;\n\n\t \n\tresult = ses_recv_diag(sdev, 2, buf, len);\n\tif (result)\n\t\tgoto recv_failed;\n\tses_dev->page2 = buf;\n\tses_dev->page2_len = len;\n\tbuf = NULL;\n\n\t \n\tpage = 10;\n\tresult = ses_recv_diag(sdev, page, hdr_buf, INIT_ALLOC_SIZE);\n\tif (!result) {\n\n\t\tlen = (hdr_buf[2] << 8) + hdr_buf[3] + 4;\n\t\tbuf = kzalloc(len, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto err_free;\n\n\t\tresult = ses_recv_diag(sdev, page, buf, len);\n\t\tif (result)\n\t\t\tgoto recv_failed;\n\t\tses_dev->page10 = buf;\n\t\tses_dev->page10_len = len;\n\t\tbuf = NULL;\n\t}\npage2_not_supported:\n\tif (components > 0) {\n\t\tscomp = kcalloc(components, sizeof(struct ses_component), GFP_KERNEL);\n\t\tif (!scomp)\n\t\t\tgoto err_free;\n\t}\n\n\tedev = enclosure_register(cdev->parent, dev_name(&sdev->sdev_gendev),\n\t\t\t\t  components, &ses_enclosure_callbacks);\n\tif (IS_ERR(edev)) {\n\t\terr = PTR_ERR(edev);\n\t\tgoto err_free;\n\t}\n\n\tkfree(hdr_buf);\n\n\tedev->scratch = ses_dev;\n\tfor (i = 0; i < components; i++)\n\t\tedev->component[i].scratch = scomp + i;\n\n\tses_enclosure_data_process(edev, sdev, 1);\n\n\t \n\tshost_for_each_device(tmp_sdev, sdev->host) {\n\t\tif (tmp_sdev->lun != 0 || scsi_device_enclosure(tmp_sdev))\n\t\t\tcontinue;\n\t\tses_match_to_enclosure(edev, tmp_sdev, 0);\n\t}\n\n\treturn 0;\n\n recv_failed:\n\tsdev_printk(KERN_ERR, sdev, \"Failed to get diagnostic page 0x%x\\n\",\n\t\t    page);\n\terr = -ENODEV;\n err_free:\n\tkfree(buf);\n\tkfree(scomp);\n\tkfree(ses_dev->page10);\n\tkfree(ses_dev->page2);\n\tkfree(ses_dev->page1);\n err_init_free:\n\tkfree(ses_dev);\n\tkfree(hdr_buf);\n\tsdev_printk(KERN_ERR, sdev, \"Failed to bind enclosure %d\\n\", err);\n\treturn err;\n}\n\nstatic int ses_remove(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic void ses_intf_remove_component(struct scsi_device *sdev)\n{\n\tstruct enclosure_device *edev, *prev = NULL;\n\n\twhile ((edev = enclosure_find(&sdev->host->shost_gendev, prev)) != NULL) {\n\t\tprev = edev;\n\t\tif (!enclosure_remove_device(edev, &sdev->sdev_gendev))\n\t\t\tbreak;\n\t}\n\tif (edev)\n\t\tput_device(&edev->edev);\n}\n\nstatic void ses_intf_remove_enclosure(struct scsi_device *sdev)\n{\n\tstruct enclosure_device *edev;\n\tstruct ses_device *ses_dev;\n\n\t \n\tedev = enclosure_find(&sdev->sdev_gendev, NULL);\n\tif (!edev)\n\t\treturn;\n\n\tses_dev = edev->scratch;\n\tedev->scratch = NULL;\n\n\tkfree(ses_dev->page10);\n\tkfree(ses_dev->page1);\n\tkfree(ses_dev->page2);\n\tkfree(ses_dev);\n\n\tif (edev->components)\n\t\tkfree(edev->component[0].scratch);\n\n\tput_device(&edev->edev);\n\tenclosure_unregister(edev);\n}\n\nstatic void ses_intf_remove(struct device *cdev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(cdev->parent);\n\n\tif (!scsi_device_enclosure(sdev))\n\t\tses_intf_remove_component(sdev);\n\telse\n\t\tses_intf_remove_enclosure(sdev);\n}\n\nstatic struct class_interface ses_interface = {\n\t.add_dev\t= ses_intf_add,\n\t.remove_dev\t= ses_intf_remove,\n};\n\nstatic struct scsi_driver ses_template = {\n\t.gendrv = {\n\t\t.name\t\t= \"ses\",\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.probe\t\t= ses_probe,\n\t\t.remove\t\t= ses_remove,\n\t},\n};\n\nstatic int __init ses_init(void)\n{\n\tint err;\n\n\terr = scsi_register_interface(&ses_interface);\n\tif (err)\n\t\treturn err;\n\n\terr = scsi_register_driver(&ses_template.gendrv);\n\tif (err)\n\t\tgoto out_unreg;\n\n\treturn 0;\n\n out_unreg:\n\tscsi_unregister_interface(&ses_interface);\n\treturn err;\n}\n\nstatic void __exit ses_exit(void)\n{\n\tscsi_unregister_driver(&ses_template.gendrv);\n\tscsi_unregister_interface(&ses_interface);\n}\n\nmodule_init(ses_init);\nmodule_exit(ses_exit);\n\nMODULE_ALIAS_SCSI_DEVICE(TYPE_ENCLOSURE);\n\nMODULE_AUTHOR(\"James Bottomley\");\nMODULE_DESCRIPTION(\"SCSI Enclosure Services (ses) driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}