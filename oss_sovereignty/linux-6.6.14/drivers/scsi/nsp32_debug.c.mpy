{
  "module_name": "nsp32_debug.c",
  "hash_id": "2374f8f9109a6e2b959fdc29d88aad1f0a6263ca9d69f35df7e050372c7724b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/nsp32_debug.c",
  "human_readable_source": " \n\n \nstatic const char unknown[] = \"UNKNOWN\";\n\nstatic const char * group_0_commands[] = {\n  \"Test Unit Ready\", \"Rezero Unit\", unknown, \"Request Sense\",\n  \"Format Unit\", \"Read Block Limits\", unknown, \"Reassign Blocks\",\n  \"Read (6)\", unknown, \"Write (6)\", \"Seek (6)\", unknown, unknown,\n  unknown, \"Read Reverse\", \"Write Filemarks\", \"Space\", \"Inquiry\",  \n  unknown, \"Recover Buffered Data\", \"Mode Select\", \"Reserve\",\n  \"Release\", \"Copy\", \"Erase\", \"Mode Sense\", \"Start/Stop Unit\",\n  \"Receive Diagnostic\", \"Send Diagnostic\", \n  \"Prevent/Allow Medium Removal\", unknown,\n};\n\n\nstatic const char *group_1_commands[] = {\n   unknown, unknown, unknown,\n  unknown, unknown, \"Read Capacity\", unknown, unknown, \"Read (10)\",\n  unknown, \"Write (10)\", \"Seek (10)\", unknown, unknown,\n  \"Write Verify\",\"Verify\", \"Search High\", \"Search Equal\",\n  \"Search Low\", \"Set Limits\", \"Prefetch or Read Position\", \n  \"Synchronize Cache\",\"Lock/Unlock Cache\", \"Read Defect Data\",\n  \"Medium Scan\", \"Compare\",\"Copy Verify\", \"Write Buffer\", \"Read Buffer\",\n  \"Update Block\", \"Read Long\",  \"Write Long\",\n};\n\n\nstatic const char *group_2_commands[] = {\n  \"Change Definition\", \"Write Same\", \n  \"Read Sub-Ch(cd)\", \"Read TOC\", \"Read Header(cd)\", \"Play Audio(cd)\", unknown, \"Play Audio MSF(cd)\", \"Play Audio Track/Index(cd)\", \n  \"Play Track Relative(10)(cd)\", unknown, \"Pause/Resume(cd)\", \"Log Select\", \"Log Sense\", unknown, unknown,\n  unknown, unknown, unknown, unknown, unknown, \"Mode Select (10)\",\n  unknown, unknown, unknown, unknown, \"Mode Sense (10)\", unknown,\n  unknown, unknown, unknown,\n};\n\n#define group(opcode) (((opcode) >> 5) & 7)\n\n#define RESERVED_GROUP  0\n#define VENDOR_GROUP    1\n#define NOTEXT_GROUP    2\n\nstatic const char **commands[] = {\n    group_0_commands, group_1_commands, group_2_commands, \n    (const char **) RESERVED_GROUP, (const char **) RESERVED_GROUP, \n    (const char **) NOTEXT_GROUP, (const char **) VENDOR_GROUP, \n    (const char **) VENDOR_GROUP\n};\n\nstatic const char reserved[] = \"RESERVED\";\nstatic const char vendor[] = \"VENDOR SPECIFIC\";\n\nstatic void print_opcodek(unsigned char opcode)\n{\n\tconst char **table = commands[ group(opcode) ];\n\n\tswitch ((unsigned long) table) {\n\tcase RESERVED_GROUP:\n\t\tprintk(\"%s[%02x] \", reserved, opcode); \n\t\tbreak;\n\tcase NOTEXT_GROUP:\n\t\tprintk(\"%s(notext)[%02x] \", unknown, opcode); \n\t\tbreak;\n\tcase VENDOR_GROUP:\n\t\tprintk(\"%s[%02x] \", vendor, opcode); \n\t\tbreak;\n\tdefault:\n\t\tif (table[opcode & 0x1f] != unknown)\n\t\t\tprintk(\"%s[%02x] \", table[opcode & 0x1f], opcode);\n\t\telse\n\t\t\tprintk(\"%s[%02x] \", unknown, opcode);\n\t\tbreak;\n\t}\n}\n\nstatic void print_commandk (unsigned char *command)\n{\n\tint i,s;\n\n\tprint_opcodek(command[0]);\n\t \n\tif ((command[0] >> 5) == 6 ||\n\t    (command[0] >> 5) == 7 ) {\n\t\ts = 12;  \n\t} else {\n\t\ts = COMMAND_SIZE(command[0]);\n\t}\n\n\tfor ( i = 1; i < s; ++i) {\n\t\tprintk(\"%02x \", command[i]);\n\t}\n\n\tswitch (s) {\n\tcase 6:\n\t\tprintk(\"LBA=%d len=%d\",\n\t\t       (((unsigned int)command[1] & 0x0f) << 16) |\n\t\t       ( (unsigned int)command[2]         <<  8) |\n\t\t       ( (unsigned int)command[3]              ),\n\t\t       (unsigned int)command[4]\n\t\t\t);\n\t\tbreak;\n\tcase 10:\n\t\tprintk(\"LBA=%d len=%d\",\n\t\t       ((unsigned int)command[2] << 24) |\n\t\t       ((unsigned int)command[3] << 16) |\n\t\t       ((unsigned int)command[4] <<  8) |\n\t\t       ((unsigned int)command[5]      ),\n\t\t       ((unsigned int)command[7] <<  8) |\n\t\t       ((unsigned int)command[8]      )\n\t\t       );\n\t\tbreak;\n\tcase 12:\n\t\tprintk(\"LBA=%d len=%d\",\n\t\t       ((unsigned int)command[2] << 24) |\n\t\t       ((unsigned int)command[3] << 16) |\n\t\t       ((unsigned int)command[4] <<  8) |\n\t\t       ((unsigned int)command[5]      ),\n\t\t       ((unsigned int)command[6] << 24) |\n\t\t       ((unsigned int)command[7] << 16) |\n\t\t       ((unsigned int)command[8] <<  8) |\n\t\t       ((unsigned int)command[9]      )\n\t\t       );\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tprintk(\"\\n\");\n}\n\nstatic void show_command(struct scsi_cmnd *SCpnt)\n{\n\tprint_commandk(SCpnt->cmnd);\n}\n\nstatic void show_busphase(unsigned char stat)\n{\n\tswitch(stat) {\n\tcase BUSPHASE_COMMAND:\n\t\tprintk( \"BUSPHASE_COMMAND\\n\");\n\t\tbreak;\n\tcase BUSPHASE_MESSAGE_IN:\n\t\tprintk( \"BUSPHASE_MESSAGE_IN\\n\");\n\t\tbreak;\n\tcase BUSPHASE_MESSAGE_OUT:\n\t\tprintk( \"BUSPHASE_MESSAGE_OUT\\n\");\n\t\tbreak;\n\tcase BUSPHASE_DATA_IN:\n\t\tprintk( \"BUSPHASE_DATA_IN\\n\");\n\t\tbreak;\n\tcase BUSPHASE_DATA_OUT:\n\t\tprintk( \"BUSPHASE_DATA_OUT\\n\");\n\t\tbreak;\n\tcase BUSPHASE_STATUS:\n\t\tprintk( \"BUSPHASE_STATUS\\n\");\n\t\tbreak;\n\tcase BUSPHASE_SELECT:\n\t\tprintk( \"BUSPHASE_SELECT\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintk( \"BUSPHASE_other: 0x%x\\n\", stat);\n\t\tbreak;\n\t}\n}\n\nstatic void show_autophase(unsigned short i)\n{\n\tprintk(\"auto: 0x%x,\", i);\n\n\tif(i & COMMAND_PHASE) {\n\t\tprintk(\" cmd\");\n\t}\n\tif(i & DATA_IN_PHASE) {\n\t\tprintk(\" din\");\n\t}\n\tif(i & DATA_OUT_PHASE) {\n\t\tprintk(\" dout\");\n\t}\n\tif(i & MSGOUT_PHASE) {\n\t\tprintk(\" mout\");\n\t}\n\tif(i & STATUS_PHASE) {\n\t\tprintk(\" stat\");\n\t}\n\tif(i & ILLEGAL_PHASE) {\n\t\tprintk(\" ill\");\n\t}\n\tif(i & BUS_FREE_OCCUER) {\n\t\tprintk(\" bfree-o\");\n\t}\n\tif(i & MSG_IN_OCCUER) {\n\t\tprintk(\" min-o\");\n\t}\n\tif(i & MSG_OUT_OCCUER) {\n\t\tprintk(\" mout-o\");\n\t}\n\tif(i & SELECTION_TIMEOUT) {\n\t\tprintk(\" sel\");\n\t}\n\tif(i & MSGIN_00_VALID) {\n\t\tprintk(\" m0\");\n\t}\n\tif(i & MSGIN_02_VALID) {\n\t\tprintk(\" m2\");\n\t}\n\tif(i & MSGIN_03_VALID) {\n\t\tprintk(\" m3\");\n\t}\n\tif(i & MSGIN_04_VALID) {\n\t\tprintk(\" m4\");\n\t}\n\tif(i & AUTOSCSI_BUSY) {\n\t\tprintk(\" busy\");\n\t}\n\n\tprintk(\"\\n\");\n}\n\nstatic void nsp32_print_register(int base)\n{\n\tif (!(NSP32_DEBUG_MASK & NSP32_SPECIAL_PRINT_REGISTER))\n\t\treturn;\n\n\tprintk(\"Phase=0x%x, \", nsp32_read1(base, SCSI_BUS_MONITOR));\n\tprintk(\"OldPhase=0x%x, \", nsp32_index_read1(base, OLD_SCSI_PHASE));\n\tprintk(\"syncreg=0x%x, \", nsp32_read1(base, SYNC_REG));\n\tprintk(\"ackwidth=0x%x, \", nsp32_read1(base, ACK_WIDTH));\n\tprintk(\"sgtpaddr=0x%lx, \", nsp32_read4(base, SGT_ADR));\n\tprintk(\"scsioutlatch=0x%x, \", nsp32_read1(base, SCSI_OUT_LATCH_TARGET_ID));\n\tprintk(\"msgout=0x%lx, \", nsp32_read4(base, SCSI_MSG_OUT));\n\tprintk(\"miscrd=0x%x, \", nsp32_index_read2(base, MISC_WR));\n\tprintk(\"seltimeout=0x%x, \", nsp32_read2(base, SEL_TIME_OUT));\n\tprintk(\"sreqrate=0x%x, \", nsp32_read1(base, SREQ_SMPL_RATE));\n\tprintk(\"transStatus=0x%x, \", nsp32_read2(base, TRANSFER_STATUS));\n\tprintk(\"reselectid=0x%x, \", nsp32_read2(base, COMMAND_CONTROL));\n\tprintk(\"arbit=0x%x, \", nsp32_read1(base, ARBIT_STATUS));\n\tprintk(\"BmStart=0x%lx, \", nsp32_read4(base, BM_START_ADR));\n\tprintk(\"BmCount=0x%lx, \", nsp32_read4(base, BM_CNT));\n\tprintk(\"SackCnt=0x%lx, \", nsp32_read4(base, SACK_CNT));\n\tprintk(\"SReqCnt=0x%lx, \", nsp32_read4(base, SREQ_CNT));\n\tprintk(\"SavedSackCnt=0x%lx, \", nsp32_read4(base, SAVED_SACK_CNT));\n\tprintk(\"ScsiBusControl=0x%x, \", nsp32_read1(base, SCSI_BUS_CONTROL));\n\tprintk(\"FifoRestCnt=0x%x, \", nsp32_read2(base, FIFO_REST_CNT));\n\tprintk(\"CdbIn=0x%x, \", nsp32_read1(base, SCSI_CSB_IN));\n\tprintk(\"\\n\");\n\n\tif (0) {\n\t\tprintk(\"execph=0x%x, \", nsp32_read2(base, SCSI_EXECUTE_PHASE));\n\t\tprintk(\"IrqStatus=0x%x, \", nsp32_read2(base, IRQ_STATUS));\n\t\tprintk(\"\\n\");\n\t}\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}