{
  "module_name": "libiscsi_tcp.c",
  "hash_id": "6f9b8ecc5196959248eee85a5c7470b4dae1f27d744051e8fd1e2037a47b1bc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libiscsi_tcp.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/kfifo.h>\n#include <linux/scatterlist.h>\n#include <linux/module.h>\n#include <net/tcp.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_transport_iscsi.h>\n#include <trace/events/iscsi.h>\n\n#include \"iscsi_tcp.h\"\n\nMODULE_AUTHOR(\"Mike Christie <michaelc@cs.wisc.edu>, \"\n\t      \"Dmitry Yusupov <dmitry_yus@yahoo.com>, \"\n\t      \"Alex Aizman <itn780@yahoo.com>\");\nMODULE_DESCRIPTION(\"iSCSI/TCP data-path\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int iscsi_dbg_libtcp;\nmodule_param_named(debug_libiscsi_tcp, iscsi_dbg_libtcp, int,\n\t\t   S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug_libiscsi_tcp, \"Turn on debugging for libiscsi_tcp \"\n\t\t \"module. Set to 1 to turn on, and zero to turn off. Default \"\n\t\t \"is off.\");\n\n#define ISCSI_DBG_TCP(_conn, dbg_fmt, arg...)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (iscsi_dbg_libtcp)\t\t\t\t\\\n\t\t\tiscsi_conn_printk(KERN_INFO, _conn,\t\\\n\t\t\t\t\t     \"%s \" dbg_fmt,\t\\\n\t\t\t\t\t     __func__, ##arg);\t\\\n\t\tiscsi_dbg_trace(trace_iscsi_dbg_tcp,\t\t\\\n\t\t\t\t&(_conn)->cls_conn->dev,\t\\\n\t\t\t\t\"%s \" dbg_fmt, __func__, ##arg);\\\n\t} while (0);\n\nstatic int iscsi_tcp_hdr_recv_done(struct iscsi_tcp_conn *tcp_conn,\n\t\t\t\t   struct iscsi_segment *segment);\n\n \n\n \nstatic inline void\niscsi_tcp_segment_init_sg(struct iscsi_segment *segment,\n\t\t\t  struct scatterlist *sg, unsigned int offset)\n{\n\tsegment->sg = sg;\n\tsegment->sg_offset = offset;\n\tsegment->size = min(sg->length - offset,\n\t\t\t    segment->total_size - segment->total_copied);\n\tsegment->data = NULL;\n}\n\n \nstatic void iscsi_tcp_segment_map(struct iscsi_segment *segment, int recv)\n{\n\tstruct scatterlist *sg;\n\n\tif (segment->data != NULL || !segment->sg)\n\t\treturn;\n\n\tsg = segment->sg;\n\tBUG_ON(segment->sg_mapped);\n\tBUG_ON(sg->length == 0);\n\n\t \n\tif (!recv && sendpage_ok(sg_page(sg)))\n\t\treturn;\n\n\tif (recv) {\n\t\tsegment->atomic_mapped = true;\n\t\tsegment->sg_mapped = kmap_atomic(sg_page(sg));\n\t} else {\n\t\tsegment->atomic_mapped = false;\n\t\t \n\t\tsegment->sg_mapped = kmap(sg_page(sg));\n\t}\n\n\tsegment->data = segment->sg_mapped + sg->offset + segment->sg_offset;\n}\n\nvoid iscsi_tcp_segment_unmap(struct iscsi_segment *segment)\n{\n\tif (segment->sg_mapped) {\n\t\tif (segment->atomic_mapped)\n\t\t\tkunmap_atomic(segment->sg_mapped);\n\t\telse\n\t\t\tkunmap(sg_page(segment->sg));\n\t\tsegment->sg_mapped = NULL;\n\t\tsegment->data = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(iscsi_tcp_segment_unmap);\n\n \nstatic inline void\niscsi_tcp_segment_splice_digest(struct iscsi_segment *segment, void *digest)\n{\n\tsegment->data = digest;\n\tsegment->digest_len = ISCSI_DIGEST_SIZE;\n\tsegment->total_size += ISCSI_DIGEST_SIZE;\n\tsegment->size = ISCSI_DIGEST_SIZE;\n\tsegment->copied = 0;\n\tsegment->sg = NULL;\n\tsegment->hash = NULL;\n}\n\n \nint iscsi_tcp_segment_done(struct iscsi_tcp_conn *tcp_conn,\n\t\t\t   struct iscsi_segment *segment, int recv,\n\t\t\t   unsigned copied)\n{\n\tstruct scatterlist sg;\n\tunsigned int pad;\n\n\tISCSI_DBG_TCP(tcp_conn->iscsi_conn, \"copied %u %u size %u %s\\n\",\n\t\t      segment->copied, copied, segment->size,\n\t\t      recv ? \"recv\" : \"xmit\");\n\tif (segment->hash && copied) {\n\t\t \n\t\tiscsi_tcp_segment_unmap(segment);\n\n\t\tif (!segment->data) {\n\t\t\tsg_init_table(&sg, 1);\n\t\t\tsg_set_page(&sg, sg_page(segment->sg), copied,\n\t\t\t\t    segment->copied + segment->sg_offset +\n\t\t\t\t\t\t\tsegment->sg->offset);\n\t\t} else\n\t\t\tsg_init_one(&sg, segment->data + segment->copied,\n\t\t\t\t    copied);\n\t\tahash_request_set_crypt(segment->hash, &sg, NULL, copied);\n\t\tcrypto_ahash_update(segment->hash);\n\t}\n\n\tsegment->copied += copied;\n\tif (segment->copied < segment->size) {\n\t\tiscsi_tcp_segment_map(segment, recv);\n\t\treturn 0;\n\t}\n\n\tsegment->total_copied += segment->copied;\n\tsegment->copied = 0;\n\tsegment->size = 0;\n\n\t \n\tiscsi_tcp_segment_unmap(segment);\n\n\t \n\tISCSI_DBG_TCP(tcp_conn->iscsi_conn, \"total copied %u total size %u\\n\",\n\t\t      segment->total_copied, segment->total_size);\n\tif (segment->total_copied < segment->total_size) {\n\t\t \n\t\tiscsi_tcp_segment_init_sg(segment, sg_next(segment->sg),\n\t\t\t\t\t  0);\n\t\tiscsi_tcp_segment_map(segment, recv);\n\t\tBUG_ON(segment->size == 0);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!(tcp_conn->iscsi_conn->session->tt->caps & CAP_PADDING_OFFLOAD)) {\n\t\tpad = iscsi_padding(segment->total_copied);\n\t\tif (pad != 0) {\n\t\t\tISCSI_DBG_TCP(tcp_conn->iscsi_conn,\n\t\t\t\t      \"consume %d pad bytes\\n\", pad);\n\t\t\tsegment->total_size += pad;\n\t\t\tsegment->size = pad;\n\t\t\tsegment->data = segment->padbuf;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (segment->hash) {\n\t\tahash_request_set_crypt(segment->hash, NULL,\n\t\t\t\t\tsegment->digest, 0);\n\t\tcrypto_ahash_final(segment->hash);\n\t\tiscsi_tcp_segment_splice_digest(segment,\n\t\t\t\t recv ? segment->recv_digest : segment->digest);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(iscsi_tcp_segment_done);\n\n \nstatic int\niscsi_tcp_segment_recv(struct iscsi_tcp_conn *tcp_conn,\n\t\t       struct iscsi_segment *segment, const void *ptr,\n\t\t       unsigned int len)\n{\n\tunsigned int copy = 0, copied = 0;\n\n\twhile (!iscsi_tcp_segment_done(tcp_conn, segment, 1, copy)) {\n\t\tif (copied == len) {\n\t\t\tISCSI_DBG_TCP(tcp_conn->iscsi_conn,\n\t\t\t\t      \"copied %d bytes\\n\", len);\n\t\t\tbreak;\n\t\t}\n\n\t\tcopy = min(len - copied, segment->size - segment->copied);\n\t\tISCSI_DBG_TCP(tcp_conn->iscsi_conn, \"copying %d\\n\", copy);\n\t\tmemcpy(segment->data + segment->copied, ptr + copied, copy);\n\t\tcopied += copy;\n\t}\n\treturn copied;\n}\n\ninline void\niscsi_tcp_dgst_header(struct ahash_request *hash, const void *hdr,\n\t\t      size_t hdrlen, unsigned char digest[ISCSI_DIGEST_SIZE])\n{\n\tstruct scatterlist sg;\n\n\tsg_init_one(&sg, hdr, hdrlen);\n\tahash_request_set_crypt(hash, &sg, digest, hdrlen);\n\tcrypto_ahash_digest(hash);\n}\nEXPORT_SYMBOL_GPL(iscsi_tcp_dgst_header);\n\nstatic inline int\niscsi_tcp_dgst_verify(struct iscsi_tcp_conn *tcp_conn,\n\t\t      struct iscsi_segment *segment)\n{\n\tif (!segment->digest_len)\n\t\treturn 1;\n\n\tif (memcmp(segment->recv_digest, segment->digest,\n\t\t   segment->digest_len)) {\n\t\tISCSI_DBG_TCP(tcp_conn->iscsi_conn, \"digest mismatch\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic inline void\n__iscsi_segment_init(struct iscsi_segment *segment, size_t size,\n\t\t     iscsi_segment_done_fn_t *done, struct ahash_request *hash)\n{\n\tmemset(segment, 0, sizeof(*segment));\n\tsegment->total_size = size;\n\tsegment->done = done;\n\n\tif (hash) {\n\t\tsegment->hash = hash;\n\t\tcrypto_ahash_init(hash);\n\t}\n}\n\ninline void\niscsi_segment_init_linear(struct iscsi_segment *segment, void *data,\n\t\t\t  size_t size, iscsi_segment_done_fn_t *done,\n\t\t\t  struct ahash_request *hash)\n{\n\t__iscsi_segment_init(segment, size, done, hash);\n\tsegment->data = data;\n\tsegment->size = size;\n}\nEXPORT_SYMBOL_GPL(iscsi_segment_init_linear);\n\ninline int\niscsi_segment_seek_sg(struct iscsi_segment *segment,\n\t\t      struct scatterlist *sg_list, unsigned int sg_count,\n\t\t      unsigned int offset, size_t size,\n\t\t      iscsi_segment_done_fn_t *done,\n\t\t      struct ahash_request *hash)\n{\n\tstruct scatterlist *sg;\n\tunsigned int i;\n\n\t__iscsi_segment_init(segment, size, done, hash);\n\tfor_each_sg(sg_list, sg, sg_count, i) {\n\t\tif (offset < sg->length) {\n\t\t\tiscsi_tcp_segment_init_sg(segment, sg, offset);\n\t\t\treturn 0;\n\t\t}\n\t\toffset -= sg->length;\n\t}\n\n\treturn ISCSI_ERR_DATA_OFFSET;\n}\nEXPORT_SYMBOL_GPL(iscsi_segment_seek_sg);\n\n \nvoid iscsi_tcp_hdr_recv_prep(struct iscsi_tcp_conn *tcp_conn)\n{\n\tISCSI_DBG_TCP(tcp_conn->iscsi_conn,\n\t\t      \"(%s)\\n\", tcp_conn->iscsi_conn->hdrdgst_en ?\n\t\t      \"digest enabled\" : \"digest disabled\");\n\tiscsi_segment_init_linear(&tcp_conn->in.segment,\n\t\t\t\ttcp_conn->in.hdr_buf, sizeof(struct iscsi_hdr),\n\t\t\t\tiscsi_tcp_hdr_recv_done, NULL);\n}\nEXPORT_SYMBOL_GPL(iscsi_tcp_hdr_recv_prep);\n\n \nstatic int\niscsi_tcp_data_recv_done(struct iscsi_tcp_conn *tcp_conn,\n\t\t\t struct iscsi_segment *segment)\n{\n\tstruct iscsi_conn *conn = tcp_conn->iscsi_conn;\n\tint rc = 0;\n\n\tif (!iscsi_tcp_dgst_verify(tcp_conn, segment))\n\t\treturn ISCSI_ERR_DATA_DGST;\n\n\trc = iscsi_complete_pdu(conn, tcp_conn->in.hdr,\n\t\t\tconn->data, tcp_conn->in.datalen);\n\tif (rc)\n\t\treturn rc;\n\n\tiscsi_tcp_hdr_recv_prep(tcp_conn);\n\treturn 0;\n}\n\nstatic void\niscsi_tcp_data_recv_prep(struct iscsi_tcp_conn *tcp_conn)\n{\n\tstruct iscsi_conn *conn = tcp_conn->iscsi_conn;\n\tstruct ahash_request *rx_hash = NULL;\n\n\tif (conn->datadgst_en &&\n\t    !(conn->session->tt->caps & CAP_DIGEST_OFFLOAD))\n\t\trx_hash = tcp_conn->rx_hash;\n\n\tiscsi_segment_init_linear(&tcp_conn->in.segment,\n\t\t\t\tconn->data, tcp_conn->in.datalen,\n\t\t\t\tiscsi_tcp_data_recv_done, rx_hash);\n}\n\n \nvoid iscsi_tcp_cleanup_task(struct iscsi_task *task)\n{\n\tstruct iscsi_tcp_task *tcp_task = task->dd_data;\n\tstruct iscsi_r2t_info *r2t;\n\n\t \n\tif (!task->sc)\n\t\treturn;\n\n\tspin_lock_bh(&tcp_task->queue2pool);\n\t \n\twhile (kfifo_out(&tcp_task->r2tqueue, (void*)&r2t, sizeof(void*))) {\n\t\tkfifo_in(&tcp_task->r2tpool.queue, (void*)&r2t,\n\t\t\t    sizeof(void*));\n\t\tISCSI_DBG_TCP(task->conn, \"pending r2t dropped\\n\");\n\t}\n\n\tr2t = tcp_task->r2t;\n\tif (r2t != NULL) {\n\t\tkfifo_in(&tcp_task->r2tpool.queue, (void*)&r2t,\n\t\t\t    sizeof(void*));\n\t\ttcp_task->r2t = NULL;\n\t}\n\tspin_unlock_bh(&tcp_task->queue2pool);\n}\nEXPORT_SYMBOL_GPL(iscsi_tcp_cleanup_task);\n\n \nstatic int iscsi_tcp_data_in(struct iscsi_conn *conn, struct iscsi_task *task)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_tcp_task *tcp_task = task->dd_data;\n\tstruct iscsi_data_rsp *rhdr = (struct iscsi_data_rsp *)tcp_conn->in.hdr;\n\tint datasn = be32_to_cpu(rhdr->datasn);\n\tunsigned total_in_length = task->sc->sdb.length;\n\n\t \n\tif (!(rhdr->flags & ISCSI_FLAG_DATA_STATUS))\n\t\tiscsi_update_cmdsn(conn->session, (struct iscsi_nopin*)rhdr);\n\n\tif (tcp_conn->in.datalen == 0)\n\t\treturn 0;\n\n\tif (tcp_task->exp_datasn != datasn) {\n\t\tISCSI_DBG_TCP(conn, \"task->exp_datasn(%d) != rhdr->datasn(%d)\"\n\t\t\t      \"\\n\", tcp_task->exp_datasn, datasn);\n\t\treturn ISCSI_ERR_DATASN;\n\t}\n\n\ttcp_task->exp_datasn++;\n\n\ttcp_task->data_offset = be32_to_cpu(rhdr->offset);\n\tif (tcp_task->data_offset + tcp_conn->in.datalen > total_in_length) {\n\t\tISCSI_DBG_TCP(conn, \"data_offset(%d) + data_len(%d) > \"\n\t\t\t      \"total_length_in(%d)\\n\", tcp_task->data_offset,\n\t\t\t      tcp_conn->in.datalen, total_in_length);\n\t\treturn ISCSI_ERR_DATA_OFFSET;\n\t}\n\n\tconn->datain_pdus_cnt++;\n\treturn 0;\n}\n\n \nstatic int iscsi_tcp_r2t_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr)\n{\n\tstruct iscsi_session *session = conn->session;\n\tstruct iscsi_tcp_task *tcp_task;\n\tstruct iscsi_tcp_conn *tcp_conn;\n\tstruct iscsi_r2t_rsp *rhdr;\n\tstruct iscsi_r2t_info *r2t;\n\tstruct iscsi_task *task;\n\tu32 data_length;\n\tu32 data_offset;\n\tint r2tsn;\n\tint rc;\n\n\tspin_lock(&session->back_lock);\n\ttask = iscsi_itt_to_ctask(conn, hdr->itt);\n\tif (!task) {\n\t\tspin_unlock(&session->back_lock);\n\t\treturn ISCSI_ERR_BAD_ITT;\n\t} else if (task->sc->sc_data_direction != DMA_TO_DEVICE) {\n\t\tspin_unlock(&session->back_lock);\n\t\treturn ISCSI_ERR_PROTO;\n\t}\n\t \n\tif (task->state != ISCSI_TASK_RUNNING) {\n\t\tspin_unlock(&session->back_lock);\n\t\t \n\t\treturn 0;\n\t}\n\ttask->last_xfer = jiffies;\n\tif (!iscsi_get_task(task)) {\n\t\tspin_unlock(&session->back_lock);\n\t\t \n\t\treturn 0;\n\t}\n\n\ttcp_conn = conn->dd_data;\n\trhdr = (struct iscsi_r2t_rsp *)tcp_conn->in.hdr;\n\t \n\tiscsi_update_cmdsn(session, (struct iscsi_nopin *)rhdr);\n\tspin_unlock(&session->back_lock);\n\n\tif (tcp_conn->in.datalen) {\n\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t  \"invalid R2t with datalen %d\\n\",\n\t\t\t\t  tcp_conn->in.datalen);\n\t\trc = ISCSI_ERR_DATALEN;\n\t\tgoto put_task;\n\t}\n\n\ttcp_task = task->dd_data;\n\tr2tsn = be32_to_cpu(rhdr->r2tsn);\n\tif (tcp_task->exp_datasn != r2tsn){\n\t\tISCSI_DBG_TCP(conn, \"task->exp_datasn(%d) != rhdr->r2tsn(%d)\\n\",\n\t\t\t      tcp_task->exp_datasn, r2tsn);\n\t\trc = ISCSI_ERR_R2TSN;\n\t\tgoto put_task;\n\t}\n\n\tif (session->state != ISCSI_STATE_LOGGED_IN) {\n\t\tiscsi_conn_printk(KERN_INFO, conn,\n\t\t\t\t  \"dropping R2T itt %d in recovery.\\n\",\n\t\t\t\t  task->itt);\n\t\trc = 0;\n\t\tgoto put_task;\n\t}\n\n\tdata_length = be32_to_cpu(rhdr->data_length);\n\tif (data_length == 0) {\n\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t  \"invalid R2T with zero data len\\n\");\n\t\trc = ISCSI_ERR_DATALEN;\n\t\tgoto put_task;\n\t}\n\n\tif (data_length > session->max_burst)\n\t\tISCSI_DBG_TCP(conn, \"invalid R2T with data len %u and max \"\n\t\t\t      \"burst %u. Attempting to execute request.\\n\",\n\t\t\t      data_length, session->max_burst);\n\n\tdata_offset = be32_to_cpu(rhdr->data_offset);\n\tif (data_offset + data_length > task->sc->sdb.length) {\n\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t  \"invalid R2T with data len %u at offset %u \"\n\t\t\t\t  \"and total length %d\\n\", data_length,\n\t\t\t\t  data_offset, task->sc->sdb.length);\n\t\trc = ISCSI_ERR_DATALEN;\n\t\tgoto put_task;\n\t}\n\n\tspin_lock(&tcp_task->pool2queue);\n\trc = kfifo_out(&tcp_task->r2tpool.queue, (void *)&r2t, sizeof(void *));\n\tif (!rc) {\n\t\tiscsi_conn_printk(KERN_ERR, conn, \"Could not allocate R2T. \"\n\t\t\t\t  \"Target has sent more R2Ts than it \"\n\t\t\t\t  \"negotiated for or driver has leaked.\\n\");\n\t\tspin_unlock(&tcp_task->pool2queue);\n\t\trc = ISCSI_ERR_PROTO;\n\t\tgoto put_task;\n\t}\n\n\tr2t->exp_statsn = rhdr->statsn;\n\tr2t->data_length = data_length;\n\tr2t->data_offset = data_offset;\n\n\tr2t->ttt = rhdr->ttt;  \n\tr2t->datasn = 0;\n\tr2t->sent = 0;\n\n\ttcp_task->exp_datasn = r2tsn + 1;\n\tkfifo_in(&tcp_task->r2tqueue, (void*)&r2t, sizeof(void*));\n\tconn->r2t_pdus_cnt++;\n\tspin_unlock(&tcp_task->pool2queue);\n\n\tiscsi_requeue_task(task);\n\treturn 0;\n\nput_task:\n\tiscsi_put_task(task);\n\treturn rc;\n}\n\n \nstatic int\niscsi_tcp_process_data_in(struct iscsi_tcp_conn *tcp_conn,\n\t\t\t  struct iscsi_segment *segment)\n{\n\tstruct iscsi_conn *conn = tcp_conn->iscsi_conn;\n\tstruct iscsi_hdr *hdr = tcp_conn->in.hdr;\n\tint rc;\n\n\tif (!iscsi_tcp_dgst_verify(tcp_conn, segment))\n\t\treturn ISCSI_ERR_DATA_DGST;\n\n\t \n\tif (hdr->flags & ISCSI_FLAG_DATA_STATUS) {\n\t\trc = iscsi_complete_pdu(conn, tcp_conn->in.hdr, NULL, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tiscsi_tcp_hdr_recv_prep(tcp_conn);\n\treturn 0;\n}\n\n \nstatic int\niscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)\n{\n\tint rc = 0, opcode, ahslen;\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_task *task;\n\n\t \n\ttcp_conn->in.datalen = ntoh24(hdr->dlength);\n\tif (tcp_conn->in.datalen > conn->max_recv_dlength) {\n\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t  \"iscsi_tcp: datalen %d > %d\\n\",\n\t\t\t\t  tcp_conn->in.datalen, conn->max_recv_dlength);\n\t\treturn ISCSI_ERR_DATALEN;\n\t}\n\n\t \n\tahslen = hdr->hlength << 2;\n\n\topcode = hdr->opcode & ISCSI_OPCODE_MASK;\n\t \n\trc = iscsi_verify_itt(conn, hdr->itt);\n\tif (rc)\n\t\treturn rc;\n\n\tISCSI_DBG_TCP(conn, \"opcode 0x%x ahslen %d datalen %d\\n\",\n\t\t      opcode, ahslen, tcp_conn->in.datalen);\n\n\tswitch(opcode) {\n\tcase ISCSI_OP_SCSI_DATA_IN:\n\t\tspin_lock(&conn->session->back_lock);\n\t\ttask = iscsi_itt_to_ctask(conn, hdr->itt);\n\t\tif (!task)\n\t\t\trc = ISCSI_ERR_BAD_ITT;\n\t\telse\n\t\t\trc = iscsi_tcp_data_in(conn, task);\n\t\tif (rc) {\n\t\t\tspin_unlock(&conn->session->back_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tcp_conn->in.datalen) {\n\t\t\tstruct iscsi_tcp_task *tcp_task = task->dd_data;\n\t\t\tstruct ahash_request *rx_hash = NULL;\n\t\t\tstruct scsi_data_buffer *sdb = &task->sc->sdb;\n\n\t\t\t \n\t\t\tif (conn->datadgst_en &&\n\t\t\t    !(conn->session->tt->caps & CAP_DIGEST_OFFLOAD))\n\t\t\t\trx_hash = tcp_conn->rx_hash;\n\n\t\t\tISCSI_DBG_TCP(conn, \"iscsi_tcp_begin_data_in( \"\n\t\t\t\t     \"offset=%d, datalen=%d)\\n\",\n\t\t\t\t      tcp_task->data_offset,\n\t\t\t\t      tcp_conn->in.datalen);\n\t\t\ttask->last_xfer = jiffies;\n\t\t\trc = iscsi_segment_seek_sg(&tcp_conn->in.segment,\n\t\t\t\t\t\t   sdb->table.sgl,\n\t\t\t\t\t\t   sdb->table.nents,\n\t\t\t\t\t\t   tcp_task->data_offset,\n\t\t\t\t\t\t   tcp_conn->in.datalen,\n\t\t\t\t\t\t   iscsi_tcp_process_data_in,\n\t\t\t\t\t\t   rx_hash);\n\t\t\tspin_unlock(&conn->session->back_lock);\n\t\t\treturn rc;\n\t\t}\n\t\trc = __iscsi_complete_pdu(conn, hdr, NULL, 0);\n\t\tspin_unlock(&conn->session->back_lock);\n\t\tbreak;\n\tcase ISCSI_OP_SCSI_CMD_RSP:\n\t\tif (tcp_conn->in.datalen) {\n\t\t\tiscsi_tcp_data_recv_prep(tcp_conn);\n\t\t\treturn 0;\n\t\t}\n\t\trc = iscsi_complete_pdu(conn, hdr, NULL, 0);\n\t\tbreak;\n\tcase ISCSI_OP_R2T:\n\t\tif (ahslen) {\n\t\t\trc = ISCSI_ERR_AHSLEN;\n\t\t\tbreak;\n\t\t}\n\t\trc = iscsi_tcp_r2t_rsp(conn, hdr);\n\t\tbreak;\n\tcase ISCSI_OP_LOGIN_RSP:\n\tcase ISCSI_OP_TEXT_RSP:\n\tcase ISCSI_OP_REJECT:\n\tcase ISCSI_OP_ASYNC_EVENT:\n\t\t \n\t\tif (ISCSI_DEF_MAX_RECV_SEG_LEN < tcp_conn->in.datalen) {\n\t\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t\t  \"iscsi_tcp: received buffer of \"\n\t\t\t\t\t  \"len %u but conn buffer is only %u \"\n\t\t\t\t\t  \"(opcode %0x)\\n\",\n\t\t\t\t\t  tcp_conn->in.datalen,\n\t\t\t\t\t  ISCSI_DEF_MAX_RECV_SEG_LEN, opcode);\n\t\t\trc = ISCSI_ERR_PROTO;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (tcp_conn->in.datalen) {\n\t\t\tiscsi_tcp_data_recv_prep(tcp_conn);\n\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tcase ISCSI_OP_LOGOUT_RSP:\n\tcase ISCSI_OP_NOOP_IN:\n\tcase ISCSI_OP_SCSI_TMFUNC_RSP:\n\t\trc = iscsi_complete_pdu(conn, hdr, NULL, 0);\n\t\tbreak;\n\tdefault:\n\t\trc = ISCSI_ERR_BAD_OPCODE;\n\t\tbreak;\n\t}\n\n\tif (rc == 0) {\n\t\t \n\t\tif (tcp_conn->in.datalen)\n\t\t\treturn ISCSI_ERR_PROTO;\n\t\tiscsi_tcp_hdr_recv_prep(tcp_conn);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int\niscsi_tcp_hdr_recv_done(struct iscsi_tcp_conn *tcp_conn,\n\t\t\tstruct iscsi_segment *segment)\n{\n\tstruct iscsi_conn *conn = tcp_conn->iscsi_conn;\n\tstruct iscsi_hdr *hdr;\n\n\t \n\thdr = (struct iscsi_hdr *) tcp_conn->in.hdr_buf;\n\tif (segment->copied == sizeof(struct iscsi_hdr) && hdr->hlength) {\n\t\t \n\t\tunsigned int ahslen = hdr->hlength << 2;\n\n\t\t \n\t\tif (sizeof(*hdr) + ahslen > sizeof(tcp_conn->in.hdr_buf))\n\t\t\treturn ISCSI_ERR_AHSLEN;\n\n\t\tsegment->total_size += ahslen;\n\t\tsegment->size += ahslen;\n\t\treturn 0;\n\t}\n\n\t \n\tif (conn->hdrdgst_en &&\n\t    !(conn->session->tt->caps & CAP_DIGEST_OFFLOAD)) {\n\t\tif (segment->digest_len == 0) {\n\t\t\t \n\t\t\tiscsi_tcp_segment_splice_digest(segment,\n\t\t\t\t\t\t\tsegment->recv_digest);\n\t\t\treturn 0;\n\t\t}\n\n\t\tiscsi_tcp_dgst_header(tcp_conn->rx_hash, hdr,\n\t\t\t\t      segment->total_copied - ISCSI_DIGEST_SIZE,\n\t\t\t\t      segment->digest);\n\n\t\tif (!iscsi_tcp_dgst_verify(tcp_conn, segment))\n\t\t\treturn ISCSI_ERR_HDR_DGST;\n\t}\n\n\ttcp_conn->in.hdr = hdr;\n\treturn iscsi_tcp_hdr_dissect(conn, hdr);\n}\n\n \ninline int iscsi_tcp_recv_segment_is_hdr(struct iscsi_tcp_conn *tcp_conn)\n{\n\treturn tcp_conn->in.segment.done == iscsi_tcp_hdr_recv_done;\n}\nEXPORT_SYMBOL_GPL(iscsi_tcp_recv_segment_is_hdr);\n\n \nint iscsi_tcp_recv_skb(struct iscsi_conn *conn, struct sk_buff *skb,\n\t\t       unsigned int offset, bool offloaded, int *status)\n{\n\tstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\n\tstruct iscsi_segment *segment = &tcp_conn->in.segment;\n\tstruct skb_seq_state seq;\n\tunsigned int consumed = 0;\n\tint rc = 0;\n\n\tISCSI_DBG_TCP(conn, \"in %d bytes\\n\", skb->len - offset);\n\t \n\tconn->last_recv = jiffies;\n\n\tif (unlikely(test_bit(ISCSI_CONN_FLAG_SUSPEND_RX, &conn->flags))) {\n\t\tISCSI_DBG_TCP(conn, \"Rx suspended!\\n\");\n\t\t*status = ISCSI_TCP_SUSPENDED;\n\t\treturn 0;\n\t}\n\n\tif (offloaded) {\n\t\tsegment->total_copied = segment->total_size;\n\t\tgoto segment_done;\n\t}\n\n\tskb_prepare_seq_read(skb, offset, skb->len, &seq);\n\twhile (1) {\n\t\tunsigned int avail;\n\t\tconst u8 *ptr;\n\n\t\tavail = skb_seq_read(consumed, &ptr, &seq);\n\t\tif (avail == 0) {\n\t\t\tISCSI_DBG_TCP(conn, \"no more data avail. Consumed %d\\n\",\n\t\t\t\t      consumed);\n\t\t\t*status = ISCSI_TCP_SKB_DONE;\n\t\t\tgoto skb_done;\n\t\t}\n\t\tBUG_ON(segment->copied >= segment->size);\n\n\t\tISCSI_DBG_TCP(conn, \"skb %p ptr=%p avail=%u\\n\", skb, ptr,\n\t\t\t      avail);\n\t\trc = iscsi_tcp_segment_recv(tcp_conn, segment, ptr, avail);\n\t\tBUG_ON(rc == 0);\n\t\tconsumed += rc;\n\n\t\tif (segment->total_copied >= segment->total_size) {\n\t\t\tskb_abort_seq_read(&seq);\n\t\t\tgoto segment_done;\n\t\t}\n\t}\n\nsegment_done:\n\t*status = ISCSI_TCP_SEGMENT_DONE;\n\tISCSI_DBG_TCP(conn, \"segment done\\n\");\n\trc = segment->done(tcp_conn, segment);\n\tif (rc != 0) {\n\t\t*status = ISCSI_TCP_CONN_ERR;\n\t\tISCSI_DBG_TCP(conn, \"Error receiving PDU, errno=%d\\n\", rc);\n\t\tiscsi_conn_failure(conn, rc);\n\t\treturn 0;\n\t}\n\t \n\nskb_done:\n\tconn->rxdata_octets += consumed;\n\treturn consumed;\n}\nEXPORT_SYMBOL_GPL(iscsi_tcp_recv_skb);\n\n \nint iscsi_tcp_task_init(struct iscsi_task *task)\n{\n\tstruct iscsi_tcp_task *tcp_task = task->dd_data;\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct scsi_cmnd *sc = task->sc;\n\tint err;\n\n\tif (!sc) {\n\t\t \n\t\tISCSI_DBG_TCP(conn, \"mtask deq [itt 0x%x]\\n\", task->itt);\n\n\t\treturn conn->session->tt->init_pdu(task, 0, task->data_count);\n\t}\n\n\tBUG_ON(kfifo_len(&tcp_task->r2tqueue));\n\ttcp_task->exp_datasn = 0;\n\n\t \n\tISCSI_DBG_TCP(conn, \"task deq [itt 0x%x imm %d unsol %d]\\n\",\n\t\t      task->itt, task->imm_count, task->unsol_r2t.data_length);\n\n\terr = conn->session->tt->init_pdu(task, 0, task->imm_count);\n\tif (err)\n\t\treturn err;\n\ttask->imm_count = 0;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iscsi_tcp_task_init);\n\nstatic struct iscsi_r2t_info *iscsi_tcp_get_curr_r2t(struct iscsi_task *task)\n{\n\tstruct iscsi_tcp_task *tcp_task = task->dd_data;\n\tstruct iscsi_r2t_info *r2t = NULL;\n\n\tif (iscsi_task_has_unsol_data(task))\n\t\tr2t = &task->unsol_r2t;\n\telse {\n\t\tspin_lock_bh(&tcp_task->queue2pool);\n\t\tif (tcp_task->r2t) {\n\t\t\tr2t = tcp_task->r2t;\n\t\t\t \n\t\t\tif (r2t->data_length <= r2t->sent) {\n\t\t\t\tISCSI_DBG_TCP(task->conn,\n\t\t\t\t\t      \"  done with r2t %p\\n\", r2t);\n\t\t\t\tkfifo_in(&tcp_task->r2tpool.queue,\n\t\t\t\t\t    (void *)&tcp_task->r2t,\n\t\t\t\t\t    sizeof(void *));\n\t\t\t\ttcp_task->r2t = r2t = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (r2t == NULL) {\n\t\t\tif (kfifo_out(&tcp_task->r2tqueue,\n\t\t\t    (void *)&tcp_task->r2t, sizeof(void *)) !=\n\t\t\t    sizeof(void *))\n\t\t\t\tr2t = NULL;\n\t\t\telse\n\t\t\t\tr2t = tcp_task->r2t;\n\t\t}\n\t\tspin_unlock_bh(&tcp_task->queue2pool);\n\t}\n\n\treturn r2t;\n}\n\n \nint iscsi_tcp_task_xmit(struct iscsi_task *task)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct iscsi_session *session = conn->session;\n\tstruct iscsi_r2t_info *r2t;\n\tint rc = 0;\n\nflush:\n\t \n\trc = session->tt->xmit_pdu(task);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (!task->sc) {\n\t\tif (task->hdr->itt == RESERVED_ITT)\n\t\t\tiscsi_put_task(task);\n\t\treturn 0;\n\t}\n\n\t \n\tif (task->sc->sc_data_direction != DMA_TO_DEVICE)\n\t\treturn 0;\n\n\tr2t = iscsi_tcp_get_curr_r2t(task);\n\tif (r2t == NULL) {\n\t\t \n\t\tISCSI_DBG_TCP(conn, \"no R2Ts yet\\n\");\n\t\treturn 0;\n\t}\n\n\trc = conn->session->tt->alloc_pdu(task, ISCSI_OP_SCSI_DATA_OUT);\n\tif (rc)\n\t\treturn rc;\n\tiscsi_prep_data_out_pdu(task, r2t, (struct iscsi_data *) task->hdr);\n\n\tISCSI_DBG_TCP(conn, \"sol dout %p [dsn %d itt 0x%x doff %d dlen %d]\\n\",\n\t\t      r2t, r2t->datasn - 1, task->hdr->itt,\n\t\t      r2t->data_offset + r2t->sent, r2t->data_count);\n\n\trc = conn->session->tt->init_pdu(task, r2t->data_offset + r2t->sent,\n\t\t\t\t\t r2t->data_count);\n\tif (rc) {\n\t\tiscsi_conn_failure(conn, ISCSI_ERR_XMIT_FAILED);\n\t\treturn rc;\n\t}\n\n\tr2t->sent += r2t->data_count;\n\tgoto flush;\n}\nEXPORT_SYMBOL_GPL(iscsi_tcp_task_xmit);\n\nstruct iscsi_cls_conn *\niscsi_tcp_conn_setup(struct iscsi_cls_session *cls_session, int dd_data_size,\n\t\t      uint32_t conn_idx)\n\n{\n\tstruct iscsi_conn *conn;\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct iscsi_tcp_conn *tcp_conn;\n\n\tcls_conn = iscsi_conn_setup(cls_session,\n\t\t\t\t    sizeof(*tcp_conn) + dd_data_size, conn_idx);\n\tif (!cls_conn)\n\t\treturn NULL;\n\tconn = cls_conn->dd_data;\n\t \n\tconn->max_recv_dlength = ISCSI_DEF_MAX_RECV_SEG_LEN;\n\n\ttcp_conn = conn->dd_data;\n\ttcp_conn->iscsi_conn = conn;\n\ttcp_conn->dd_data = conn->dd_data + sizeof(*tcp_conn);\n\treturn cls_conn;\n}\nEXPORT_SYMBOL_GPL(iscsi_tcp_conn_setup);\n\nvoid iscsi_tcp_conn_teardown(struct iscsi_cls_conn *cls_conn)\n{\n\tiscsi_conn_teardown(cls_conn);\n}\nEXPORT_SYMBOL_GPL(iscsi_tcp_conn_teardown);\n\nint iscsi_tcp_r2tpool_alloc(struct iscsi_session *session)\n{\n\tint i;\n\tint cmd_i;\n\n\t \n\tfor (cmd_i = 0; cmd_i < session->cmds_max; cmd_i++) {\n\t        struct iscsi_task *task = session->cmds[cmd_i];\n\t\tstruct iscsi_tcp_task *tcp_task = task->dd_data;\n\n\t\t \n\n\t\t \n\t\tif (iscsi_pool_init(&tcp_task->r2tpool,\n\t\t\t\t    session->max_r2t * 2, NULL,\n\t\t\t\t    sizeof(struct iscsi_r2t_info))) {\n\t\t\tgoto r2t_alloc_fail;\n\t\t}\n\n\t\t \n\t\tif (kfifo_alloc(&tcp_task->r2tqueue,\n\t\t      session->max_r2t * 4 * sizeof(void*), GFP_KERNEL)) {\n\t\t\tiscsi_pool_free(&tcp_task->r2tpool);\n\t\t\tgoto r2t_alloc_fail;\n\t\t}\n\t\tspin_lock_init(&tcp_task->pool2queue);\n\t\tspin_lock_init(&tcp_task->queue2pool);\n\t}\n\n\treturn 0;\n\nr2t_alloc_fail:\n\tfor (i = 0; i < cmd_i; i++) {\n\t\tstruct iscsi_task *task = session->cmds[i];\n\t\tstruct iscsi_tcp_task *tcp_task = task->dd_data;\n\n\t\tkfifo_free(&tcp_task->r2tqueue);\n\t\tiscsi_pool_free(&tcp_task->r2tpool);\n\t}\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(iscsi_tcp_r2tpool_alloc);\n\nvoid iscsi_tcp_r2tpool_free(struct iscsi_session *session)\n{\n\tint i;\n\n\tfor (i = 0; i < session->cmds_max; i++) {\n\t\tstruct iscsi_task *task = session->cmds[i];\n\t\tstruct iscsi_tcp_task *tcp_task = task->dd_data;\n\n\t\tkfifo_free(&tcp_task->r2tqueue);\n\t\tiscsi_pool_free(&tcp_task->r2tpool);\n\t}\n}\nEXPORT_SYMBOL_GPL(iscsi_tcp_r2tpool_free);\n\nint iscsi_tcp_set_max_r2t(struct iscsi_conn *conn, char *buf)\n{\n\tstruct iscsi_session *session = conn->session;\n\tunsigned short r2ts = 0;\n\n\tsscanf(buf, \"%hu\", &r2ts);\n\tif (session->max_r2t == r2ts)\n\t\treturn 0;\n\n\tif (!r2ts || !is_power_of_2(r2ts))\n\t\treturn -EINVAL;\n\n\tsession->max_r2t = r2ts;\n\tiscsi_tcp_r2tpool_free(session);\n\treturn iscsi_tcp_r2tpool_alloc(session);\n}\nEXPORT_SYMBOL_GPL(iscsi_tcp_set_max_r2t);\n\nvoid iscsi_tcp_conn_get_stats(struct iscsi_cls_conn *cls_conn,\n\t\t\t      struct iscsi_stats *stats)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\n\tstats->txdata_octets = conn->txdata_octets;\n\tstats->rxdata_octets = conn->rxdata_octets;\n\tstats->scsicmd_pdus = conn->scsicmd_pdus_cnt;\n\tstats->dataout_pdus = conn->dataout_pdus_cnt;\n\tstats->scsirsp_pdus = conn->scsirsp_pdus_cnt;\n\tstats->datain_pdus = conn->datain_pdus_cnt;\n\tstats->r2t_pdus = conn->r2t_pdus_cnt;\n\tstats->tmfcmd_pdus = conn->tmfcmd_pdus_cnt;\n\tstats->tmfrsp_pdus = conn->tmfrsp_pdus_cnt;\n}\nEXPORT_SYMBOL_GPL(iscsi_tcp_conn_get_stats);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}