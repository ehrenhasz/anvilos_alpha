{
  "module_name": "sym53c500_cs.c",
  "hash_id": "8e1ce35089cea01c57fb380d49a4d2f7317cc110d9f153e0e3b3620d5c4732f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/pcmcia/sym53c500_cs.c",
  "human_readable_source": "\n \n\n#define SYM53C500_DEBUG 0\n#define VERBOSE_SYM53C500_DEBUG 0\n\n \n#define USE_FAST_PIO 1\n\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/ioport.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n\n#include <asm/io.h>\n#include <asm/dma.h>\n#include <asm/irq.h>\n\n#include <scsi/scsi_ioctl.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ds.h>\n#include <pcmcia/ciscode.h>\n\n\n \n\n#define SYNC_MODE 0 \t\t \n\n \n#define C1_IMG   0x07\t\t \n#define C2_IMG   0x48\t\t \n#define C3_IMG   0x20\t\t \n#define C4_IMG   0x04\t\t \n#define C5_IMG   0xa4\t\t \n#define C7_IMG   0x80\t\t \n\n \n\n \n#define TC_LSB\t\t0x00\t\t \n#define TC_MSB\t\t0x01\t\t \n#define SCSI_FIFO\t0x02\t\t \n#define CMD_REG\t\t0x03\t\t \n#define STAT_REG\t0x04\t\t \n#define DEST_ID\t\t0x04\t\t \n#define INT_REG\t\t0x05\t\t \n#define SRTIMOUT\t0x05\t\t \n#define SEQ_REG\t\t0x06\t\t \n#define SYNCPRD\t\t0x06\t\t \n#define FIFO_FLAGS\t0x07\t\t \n#define SYNCOFF\t\t0x07\t\t \n#define CONFIG1\t\t0x08\t\t \n#define CLKCONV\t\t0x09\t\t \n \t\t \n#define CONFIG2\t\t0x0B\t\t \n#define CONFIG3\t\t0x0C\t\t \n#define CONFIG4\t\t0x0D\t\t \n#define TC_HIGH\t\t0x0E\t\t \n \t\t \n\n \n \t\t \n \t\t \n \t\t \n#define PIO_FIFO\t0x04\t\t \n \t\t \n \t\t \n \t\t \n#define PIO_STATUS\t0x08\t\t \n \t\t \n \t\t \n#define PIO_FLAG\t0x0B\t\t \n#define CONFIG5\t\t0x09\t\t \n \t\t \n \t\t \n#define CONFIG7\t\t0x0d\n\n \n#define REG0(x)\t\t(outb(C4_IMG, (x) + CONFIG4))\n \n#define REG1(x)\t\toutb(C7_IMG, (x) + CONFIG7); outb(C5_IMG, (x) + CONFIG5)\n\n#if SYM53C500_DEBUG\n#define DEB(x) x\n#else\n#define DEB(x)\n#endif\n\n#if VERBOSE_SYM53C500_DEBUG\n#define VDEB(x) x\n#else\n#define VDEB(x)\n#endif\n\n#define LOAD_DMA_COUNT(x, count) \\\n  outb(count & 0xff, (x) + TC_LSB); \\\n  outb((count >> 8) & 0xff, (x) + TC_MSB); \\\n  outb((count >> 16) & 0xff, (x) + TC_HIGH);\n\n \n#define DMA_OP               0x80\n\n#define SCSI_NOP             0x00\n#define FLUSH_FIFO           0x01\n#define CHIP_RESET           0x02\n#define SCSI_RESET           0x03\n#define RESELECT             0x40\n#define SELECT_NO_ATN        0x41\n#define SELECT_ATN           0x42\n#define SELECT_ATN_STOP      0x43\n#define ENABLE_SEL           0x44\n#define DISABLE_SEL          0x45\n#define SELECT_ATN3          0x46\n#define RESELECT3            0x47\n#define TRANSFER_INFO        0x10\n#define INIT_CMD_COMPLETE    0x11\n#define MSG_ACCEPT           0x12\n#define TRANSFER_PAD         0x18\n#define SET_ATN              0x1a\n#define RESET_ATN            0x1b\n#define SEND_MSG             0x20\n#define SEND_STATUS          0x21\n#define SEND_DATA            0x22\n#define DISCONN_SEQ          0x23\n#define TERMINATE_SEQ        0x24\n#define TARG_CMD_COMPLETE    0x25\n#define DISCONN              0x27\n#define RECV_MSG             0x28\n#define RECV_CMD             0x29\n#define RECV_DATA            0x2a\n#define RECV_CMD_SEQ         0x2b\n#define TARGET_ABORT_DMA     0x04\n\n \n\nstruct scsi_info_t {\n\tstruct pcmcia_device\t*p_dev;\n\tstruct Scsi_Host *host;\n\tunsigned short manf_id;\n};\n\n \nstruct sym53c500_data {\n\tstruct scsi_cmnd *current_SC;\n\tint fast_pio;\n};\n\nstruct sym53c500_cmd_priv {\n\tint status;\n\tint message;\n\tint phase;\n};\n\nenum Phase {\n    idle,\n    data_out,\n    data_in,\n    command_ph,\n    status_ph,\n    message_out,\n    message_in\n};\n\n \n\nstatic void\nchip_init(int io_port)\n{\n\tREG1(io_port);\n\toutb(0x01, io_port + PIO_STATUS);\n\toutb(0x00, io_port + PIO_FLAG);\n\n\toutb(C4_IMG, io_port + CONFIG4);\t \n\toutb(C3_IMG, io_port + CONFIG3);\n\toutb(C2_IMG, io_port + CONFIG2);\n\toutb(C1_IMG, io_port + CONFIG1);\n\n\toutb(0x05, io_port + CLKCONV);\t \n\toutb(0x9C, io_port + SRTIMOUT);\t \n\toutb(0x05, io_port + SYNCPRD);\t \n\toutb(SYNC_MODE, io_port + SYNCOFF);\t   \n}\n\nstatic void\nSYM53C500_int_host_reset(int io_port)\n{\n\toutb(C4_IMG, io_port + CONFIG4);\t \n\toutb(CHIP_RESET, io_port + CMD_REG);\n\toutb(SCSI_NOP, io_port + CMD_REG);\t \n\toutb(SCSI_RESET, io_port + CMD_REG);\n\tchip_init(io_port);\n}\n\nstatic __inline__ int\nSYM53C500_pio_read(int fast_pio, int base, unsigned char *request, unsigned int reqlen)\n{\n\tint i;\n\tint len;\t \n\n\tREG1(base);\n\twhile (reqlen) {\n\t\ti = inb(base + PIO_STATUS);\n\t\t \n\t\tif (i & 0x80) \n\t\t\treturn 0;\n\n\t\tswitch (i & 0x1e) {\n\t\tdefault:\n\t\tcase 0x10:\t \n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase 0x0:\n\t\t\tlen = 1;\n\t\t\tbreak; \n\t\tcase 0x8:\t \n\t\t\tlen = 42;\n\t\t\tbreak;\n\t\tcase 0xc:\t \n\t\t\tlen = 84;\n\t\t\tbreak;\n\t\tcase 0xe:\t \n\t\t\tlen = 128;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((i & 0x40) && len == 0) {  \n\t\t\treturn 0;\n\t\t}\n\n\t\tif (len) {\n\t\t\tif (len > reqlen) \n\t\t\t\tlen = reqlen;\n\n\t\t\tif (fast_pio && len > 3) {\n\t\t\t\tinsl(base + PIO_FIFO, request, len >> 2);\n\t\t\t\trequest += len & 0xfc; \n\t\t\t\treqlen -= len & 0xfc; \n\t\t\t} else {\n\t\t\t\twhile (len--) {\n\t\t\t\t\t*request++ = inb(base + PIO_FIFO);\n\t\t\t\t\treqlen--;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic __inline__ int\nSYM53C500_pio_write(int fast_pio, int base, unsigned char *request, unsigned int reqlen)\n{\n\tint i = 0;\n\tint len;\t \n\n\tREG1(base);\n\twhile (reqlen && !(i & 0x40)) {\n\t\ti = inb(base + PIO_STATUS);\n\t\t \n\t\tif (i & 0x80)\t \n\t\t\treturn 0;\n\n\t\tswitch (i & 0x1e) {\n\t\tcase 0x10:\n\t\t\tlen = 128;\n\t\t\tbreak;\n\t\tcase 0x0:\n\t\t\tlen = 84;\n\t\t\tbreak;\n\t\tcase 0x8:\n\t\t\tlen = 42;\n\t\t\tbreak;\n\t\tcase 0xc:\n\t\t\tlen = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase 0xe:\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (len) {\n\t\t\tif (len > reqlen)\n\t\t\t\tlen = reqlen;\n\n\t\t\tif (fast_pio && len > 3) {\n\t\t\t\toutsl(base + PIO_FIFO, request, len >> 2);\n\t\t\t\trequest += len & 0xfc;\n\t\t\t\treqlen -= len & 0xfc;\n\t\t\t} else {\n\t\t\t\twhile (len--) {\n\t\t\t\t\toutb(*request++, base + PIO_FIFO);\n\t\t\t\t\treqlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic irqreturn_t\nSYM53C500_intr(int irq, void *dev_id)\n{\n\tunsigned long flags;\n\tstruct Scsi_Host *dev = dev_id;\n\tDEB(unsigned char fifo_size;)\n\tDEB(unsigned char seq_reg;)\n\tunsigned char status, int_reg;\n\tunsigned char pio_status;\n\tint port_base = dev->io_port;\n\tstruct sym53c500_data *data =\n\t    (struct sym53c500_data *)dev->hostdata;\n\tstruct scsi_cmnd *curSC = data->current_SC;\n\tstruct sym53c500_cmd_priv *scp = scsi_cmd_priv(curSC);\n\tint fast_pio = data->fast_pio;\n\n\tspin_lock_irqsave(dev->host_lock, flags);\n\n\tVDEB(printk(\"SYM53C500_intr called\\n\"));\n\n\tREG1(port_base);\n\tpio_status = inb(port_base + PIO_STATUS);\n\tREG0(port_base);\n\tstatus = inb(port_base + STAT_REG);\n\tDEB(seq_reg = inb(port_base + SEQ_REG));\n\tint_reg = inb(port_base + INT_REG);\n\tDEB(fifo_size = inb(port_base + FIFO_FLAGS) & 0x1f);\n\n#if SYM53C500_DEBUG\n\tprintk(\"status=%02x, seq_reg=%02x, int_reg=%02x, fifo_size=%02x\", \n\t    status, seq_reg, int_reg, fifo_size);\n\tprintk(\", pio=%02x\\n\", pio_status);\n#endif  \n\n\tif (int_reg & 0x80) {\t \n\t\tDEB(printk(\"SYM53C500: reset intr received\\n\"));\n\t\tcurSC->result = DID_RESET << 16;\n\t\tgoto idle_out;\n\t}\n\n\tif (pio_status & 0x80) {\n\t\tprintk(\"SYM53C500: Warning: PIO error!\\n\");\n\t\tcurSC->result = DID_ERROR << 16;\n\t\tgoto idle_out;\n\t}\n\n\tif (status & 0x20) {\t\t \n\t\tprintk(\"SYM53C500: Warning: parity error!\\n\");\n\t\tcurSC->result = DID_PARITY << 16;\n\t\tgoto idle_out;\n\t}\n\n\tif (status & 0x40) {\t\t \n\t\tprintk(\"SYM53C500: Warning: gross error!\\n\");\n\t\tcurSC->result = DID_ERROR << 16;\n\t\tgoto idle_out;\n\t}\n\n\tif (int_reg & 0x20) {\t\t \n\t\tDEB(printk(\"SYM53C500: disconnect intr received\\n\"));\n\t\tif (scp->phase != message_in) {\t \n\t\t\tcurSC->result = DID_NO_CONNECT << 16;\n\t\t} else {\t \n\t\t\tcurSC->result = (scp->status & 0xff) |\n\t\t\t\t((scp->message & 0xff) << 8) | (DID_OK << 16);\n\t\t}\n\t\tgoto idle_out;\n\t}\n\n\tswitch (status & 0x07) {\t \n\tcase 0x00:\t\t\t \n\t\tif (int_reg & 0x10) {\t \n\t\t\tstruct scatterlist *sg;\n\t\t\tint i;\n\n\t\t\tscp->phase = data_out;\n\t\t\tVDEB(printk(\"SYM53C500: Data-Out phase\\n\"));\n\t\t\toutb(FLUSH_FIFO, port_base + CMD_REG);\n\t\t\tLOAD_DMA_COUNT(port_base, scsi_bufflen(curSC));\t \n\t\t\toutb(TRANSFER_INFO | DMA_OP, port_base + CMD_REG);\n\n\t\t\tscsi_for_each_sg(curSC, sg, scsi_sg_count(curSC), i) {\n\t\t\t\tSYM53C500_pio_write(fast_pio, port_base,\n\t\t\t\t    sg_virt(sg), sg->length);\n\t\t\t}\n\t\t\tREG0(port_base);\n\t\t}\n\t\tbreak;\n\n\tcase 0x01:\t\t \n\t\tif (int_reg & 0x10) {\t \n\t\t\tstruct scatterlist *sg;\n\t\t\tint i;\n\n\t\t\tscp->phase = data_in;\n\t\t\tVDEB(printk(\"SYM53C500: Data-In phase\\n\"));\n\t\t\toutb(FLUSH_FIFO, port_base + CMD_REG);\n\t\t\tLOAD_DMA_COUNT(port_base, scsi_bufflen(curSC));\t \n\t\t\toutb(TRANSFER_INFO | DMA_OP, port_base + CMD_REG);\n\n\t\t\tscsi_for_each_sg(curSC, sg, scsi_sg_count(curSC), i) {\n\t\t\t\tSYM53C500_pio_read(fast_pio, port_base,\n\t\t\t\t\tsg_virt(sg), sg->length);\n\t\t\t}\n\t\t\tREG0(port_base);\n\t\t}\n\t\tbreak;\n\n\tcase 0x02:\t\t \n\t\tscp->phase = command_ph;\n\t\tprintk(\"SYM53C500: Warning: Unknown interrupt occurred in command phase!\\n\");\n\t\tbreak;\n\n\tcase 0x03:\t\t \n\t\tscp->phase = status_ph;\n\t\tVDEB(printk(\"SYM53C500: Status phase\\n\"));\n\t\toutb(FLUSH_FIFO, port_base + CMD_REG);\n\t\toutb(INIT_CMD_COMPLETE, port_base + CMD_REG);\n\t\tbreak;\n\n\tcase 0x04:\t\t \n\tcase 0x05:\t\t \n\t\tprintk(\"SYM53C500: WARNING: Reserved phase!!!\\n\");\n\t\tbreak;\n\n\tcase 0x06:\t\t \n\t\tDEB(printk(\"SYM53C500: Message-Out phase\\n\"));\n\t\tscp->phase = message_out;\n\t\toutb(SET_ATN, port_base + CMD_REG);\t \n\t\toutb(MSG_ACCEPT, port_base + CMD_REG);\n\t\tbreak;\n\n\tcase 0x07:\t\t \n\t\tVDEB(printk(\"SYM53C500: Message-In phase\\n\"));\n\t\tscp->phase = message_in;\n\n\t\tscp->status = inb(port_base + SCSI_FIFO);\n\t\tscp->message = inb(port_base + SCSI_FIFO);\n\n\t\tVDEB(printk(\"SCSI FIFO size=%d\\n\", inb(port_base + FIFO_FLAGS) & 0x1f));\n\t\tDEB(printk(\"Status = %02x  Message = %02x\\n\", scp->status, scp->message));\n\n\t\tif (scp->message == SAVE_POINTERS || scp->message == DISCONNECT) {\n\t\t\toutb(SET_ATN, port_base + CMD_REG);\t \n\t\t\tDEB(printk(\"Discarding SAVE_POINTERS message\\n\"));\n\t\t}\n\t\toutb(MSG_ACCEPT, port_base + CMD_REG);\n\t\tbreak;\n\t}\nout:\n\tspin_unlock_irqrestore(dev->host_lock, flags);\n\treturn IRQ_HANDLED;\n\nidle_out:\n\tscp->phase = idle;\n\tscsi_done(curSC);\n\tgoto out;\n}\n\nstatic void\nSYM53C500_release(struct pcmcia_device *link)\n{\n\tstruct scsi_info_t *info = link->priv;\n\tstruct Scsi_Host *shost = info->host;\n\n\tdev_dbg(&link->dev, \"SYM53C500_release\\n\");\n\n\t \n\tscsi_remove_host(shost);\n\n\t \n\tif (shost->irq)\n\t\tfree_irq(shost->irq, shost);\n\tif (shost->io_port && shost->n_io_port)\n\t\trelease_region(shost->io_port, shost->n_io_port);\n\n\tpcmcia_disable_device(link);\n\n\tscsi_host_put(shost);\n}  \n\nstatic const char*\nSYM53C500_info(struct Scsi_Host *SChost)\n{\n\tstatic char info_msg[256];\n\tstruct sym53c500_data *data =\n\t    (struct sym53c500_data *)SChost->hostdata;\n\n\tDEB(printk(\"SYM53C500_info called\\n\"));\n\t(void)snprintf(info_msg, sizeof(info_msg),\n\t    \"SYM53C500 at 0x%lx, IRQ %d, %s PIO mode.\", \n\t    SChost->io_port, SChost->irq, data->fast_pio ? \"fast\" : \"slow\");\n\treturn (info_msg);\n}\n\nstatic int SYM53C500_queue_lck(struct scsi_cmnd *SCpnt)\n{\n\tstruct sym53c500_cmd_priv *scp = scsi_cmd_priv(SCpnt);\n\tint i;\n\tint port_base = SCpnt->device->host->io_port;\n\tstruct sym53c500_data *data =\n\t    (struct sym53c500_data *)SCpnt->device->host->hostdata;\n\n\tVDEB(printk(\"SYM53C500_queue called\\n\"));\n\n\tDEB(printk(\"cmd=%02x, cmd_len=%02x, target=%02x, lun=%02x, bufflen=%d\\n\", \n\t    SCpnt->cmnd[0], SCpnt->cmd_len, SCpnt->device->id, \n\t\t   (u8)SCpnt->device->lun,  scsi_bufflen(SCpnt)));\n\n\tVDEB(for (i = 0; i < SCpnt->cmd_len; i++)\n\t    printk(\"cmd[%d]=%02x  \", i, SCpnt->cmnd[i]));\n\tVDEB(printk(\"\\n\"));\n\n\tdata->current_SC = SCpnt;\n\tscp->phase = command_ph;\n\tscp->status = 0;\n\tscp->message = 0;\n\n\t \n\tREG0(port_base);\n\toutb(scmd_id(SCpnt), port_base + DEST_ID);\t \n\toutb(FLUSH_FIFO, port_base + CMD_REG);\t \n\n\tfor (i = 0; i < SCpnt->cmd_len; i++) {\n\t\toutb(SCpnt->cmnd[i], port_base + SCSI_FIFO);\n\t}\n\toutb(SELECT_NO_ATN, port_base + CMD_REG);\n\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(SYM53C500_queue)\n\nstatic int \nSYM53C500_host_reset(struct scsi_cmnd *SCpnt)\n{\n\tint port_base = SCpnt->device->host->io_port;\n\n\tDEB(printk(\"SYM53C500_host_reset called\\n\"));\n\tspin_lock_irq(SCpnt->device->host->host_lock);\n\tSYM53C500_int_host_reset(port_base);\n\tspin_unlock_irq(SCpnt->device->host->host_lock);\n\n\treturn SUCCESS;\n}\n\nstatic int \nSYM53C500_biosparm(struct scsi_device *disk,\n    struct block_device *dev,\n    sector_t capacity, int *info_array)\n{\n\tint size;\n\n\tDEB(printk(\"SYM53C500_biosparm called\\n\"));\n\n\tsize = capacity;\n\tinfo_array[0] = 64;\t\t \n\tinfo_array[1] = 32;\t\t \n\tinfo_array[2] = size >> 11;\t \n\tif (info_array[2] > 1024) {\t \n\t\tinfo_array[0] = 255;\n\t\tinfo_array[1] = 63;\n\t\tinfo_array[2] = size / (255 * 63);\n\t}\n\treturn 0;\n}\n\nstatic ssize_t\nSYM53C500_show_pio(struct device *dev, struct device_attribute *attr,\n\t\t   char *buf)\n{\n\tstruct Scsi_Host *SHp = class_to_shost(dev);\n\tstruct sym53c500_data *data =\n\t    (struct sym53c500_data *)SHp->hostdata;\n\n\treturn snprintf(buf, 4, \"%d\\n\", data->fast_pio);\n}\n\nstatic ssize_t\nSYM53C500_store_pio(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tint pio;\n\tstruct Scsi_Host *SHp = class_to_shost(dev);\n\tstruct sym53c500_data *data =\n\t    (struct sym53c500_data *)SHp->hostdata;\n\n\tpio = simple_strtoul(buf, NULL, 0);\n\tif (pio == 0 || pio == 1) {\n\t\tdata->fast_pio = pio;\n\t\treturn count;\n\t}\n\telse\n\t\treturn -EINVAL;\n}\n\n \nstatic struct device_attribute SYM53C500_pio_attr = {\n\t.attr = {\n\t\t.name = \"fast_pio\",\n\t\t.mode = (S_IRUGO | S_IWUSR),\n\t},\n\t.show = SYM53C500_show_pio,\n\t.store = SYM53C500_store_pio,\n};\n\nstatic struct attribute *SYM53C500_shost_attrs[] = {\n\t&SYM53C500_pio_attr.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(SYM53C500_shost);\n\n \nstatic const struct scsi_host_template sym53c500_driver_template = {\n     .module\t\t\t= THIS_MODULE,\n     .name\t\t\t= \"SYM53C500\",\n     .info\t\t\t= SYM53C500_info,\n     .queuecommand\t\t= SYM53C500_queue,\n     .eh_host_reset_handler\t= SYM53C500_host_reset,\n     .bios_param\t\t= SYM53C500_biosparm,\n     .proc_name\t\t\t= \"SYM53C500\",\n     .can_queue\t\t\t= 1,\n     .this_id\t\t\t= 7,\n     .sg_tablesize\t\t= 32,\n     .shost_groups\t\t= SYM53C500_shost_groups,\n     .cmd_size\t\t\t= sizeof(struct sym53c500_cmd_priv),\n};\n\nstatic int SYM53C500_config_check(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tp_dev->io_lines = 10;\n\tp_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\n\n\tif (p_dev->resource[0]->start == 0)\n\t\treturn -ENODEV;\n\n\treturn pcmcia_request_io(p_dev);\n}\n\nstatic int\nSYM53C500_config(struct pcmcia_device *link)\n{\n\tstruct scsi_info_t *info = link->priv;\n\tint ret;\n\tint irq_level, port_base;\n\tstruct Scsi_Host *host;\n\tconst struct scsi_host_template *tpnt = &sym53c500_driver_template;\n\tstruct sym53c500_data *data;\n\n\tdev_dbg(&link->dev, \"SYM53C500_config\\n\");\n\n\tinfo->manf_id = link->manf_id;\n\n\tret = pcmcia_loop_config(link, SYM53C500_config_check, NULL);\n\tif (ret)\n\t\tgoto failed;\n\n\tif (!link->irq)\n\t\tgoto failed;\n\n\tret = pcmcia_enable_device(link);\n\tif (ret)\n\t\tgoto failed;\n\n\t \n\tif ((info->manf_id == MANFID_MACNICA) ||\n\t    (info->manf_id == MANFID_PIONEER) ||\n\t    (info->manf_id == 0x0098)) {\n\t\t \n\t\toutb(0xb4, link->resource[0]->start + 0xd);\n\t\toutb(0x24, link->resource[0]->start + 0x9);\n\t\toutb(0x04, link->resource[0]->start + 0xd);\n\t}\n\n\t \n\tport_base = link->resource[0]->start;\n\tirq_level = link->irq;\n\n\tDEB(printk(\"SYM53C500: port_base=0x%x, irq=%d, fast_pio=%d\\n\",\n\t    port_base, irq_level, USE_FAST_PIO);)\n\n\tchip_init(port_base);\n\n\thost = scsi_host_alloc(tpnt, sizeof(struct sym53c500_data));\n\tif (!host) {\n\t\tprintk(\"SYM53C500: Unable to register host, giving up.\\n\");\n\t\tgoto err_release;\n\t}\n\n\tdata = (struct sym53c500_data *)host->hostdata;\n\n\tif (irq_level > 0) {\n\t\tif (request_irq(irq_level, SYM53C500_intr, IRQF_SHARED, \"SYM53C500\", host)) {\n\t\t\tprintk(\"SYM53C500: unable to allocate IRQ %d\\n\", irq_level);\n\t\t\tgoto err_free_scsi;\n\t\t}\n\t\tDEB(printk(\"SYM53C500: allocated IRQ %d\\n\", irq_level));\n\t} else if (irq_level == 0) {\n\t\tDEB(printk(\"SYM53C500: No interrupts detected\\n\"));\n\t\tgoto err_free_scsi;\n\t} else {\n\t\tDEB(printk(\"SYM53C500: Shouldn't get here!\\n\"));\n\t\tgoto err_free_scsi;\n\t}\n\n\thost->unique_id = port_base;\n\thost->irq = irq_level;\n\thost->io_port = port_base;\n\thost->n_io_port = 0x10;\n\thost->dma_channel = -1;\n\n\t \n\tdata->fast_pio = USE_FAST_PIO;\n\n\tinfo->host = host;\n\n\tif (scsi_add_host(host, NULL))\n\t\tgoto err_free_irq;\n\n\tscsi_scan_host(host);\n\n\treturn 0;\n\nerr_free_irq:\n\tfree_irq(irq_level, host);\nerr_free_scsi:\n\tscsi_host_put(host);\nerr_release:\n\trelease_region(port_base, 0x10);\n\tprintk(KERN_INFO \"sym53c500_cs: no SCSI devices found\\n\");\n\treturn -ENODEV;\n\nfailed:\n\tSYM53C500_release(link);\n\treturn -ENODEV;\n}  \n\nstatic int sym53c500_resume(struct pcmcia_device *link)\n{\n\tstruct scsi_info_t *info = link->priv;\n\n\t \n\tif ((info->manf_id == MANFID_MACNICA) ||\n\t    (info->manf_id == MANFID_PIONEER) ||\n\t    (info->manf_id == 0x0098)) {\n\t\toutb(0x80, link->resource[0]->start + 0xd);\n\t\toutb(0x24, link->resource[0]->start + 0x9);\n\t\toutb(0x04, link->resource[0]->start + 0xd);\n\t}\n\t \n\tSYM53C500_int_host_reset(link->resource[0]->start);\n\n\treturn 0;\n}\n\nstatic void\nSYM53C500_detach(struct pcmcia_device *link)\n{\n\tdev_dbg(&link->dev, \"SYM53C500_detach\\n\");\n\n\tSYM53C500_release(link);\n\n\tkfree(link->priv);\n\tlink->priv = NULL;\n}  \n\nstatic int\nSYM53C500_probe(struct pcmcia_device *link)\n{\n\tstruct scsi_info_t *info;\n\n\tdev_dbg(&link->dev, \"SYM53C500_attach()\\n\");\n\n\t \n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->p_dev = link;\n\tlink->priv = info;\n\tlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\n\n\treturn SYM53C500_config(link);\n}  \n\nMODULE_AUTHOR(\"Bob Tracy <rct@frus.com>\");\nMODULE_DESCRIPTION(\"SYM53C500 PCMCIA SCSI driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const struct pcmcia_device_id sym53c500_ids[] = {\n\tPCMCIA_DEVICE_PROD_ID12(\"BASICS by New Media Corporation\", \"SCSI Sym53C500\", 0x23c78a9d, 0x0099e7f7),\n\tPCMCIA_DEVICE_PROD_ID12(\"New Media Corporation\", \"SCSI Bus Toaster Sym53C500\", 0x085a850b, 0x45432eb8),\n\tPCMCIA_DEVICE_PROD_ID2(\"SCSI9000\", 0x21648f44),\n\tPCMCIA_DEVICE_NULL,\n};\nMODULE_DEVICE_TABLE(pcmcia, sym53c500_ids);\n\nstatic struct pcmcia_driver sym53c500_cs_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"sym53c500_cs\",\n\t.probe\t\t= SYM53C500_probe,\n\t.remove\t\t= SYM53C500_detach,\n\t.id_table       = sym53c500_ids,\n\t.resume\t\t= sym53c500_resume,\n};\nmodule_pcmcia_driver(sym53c500_cs_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}