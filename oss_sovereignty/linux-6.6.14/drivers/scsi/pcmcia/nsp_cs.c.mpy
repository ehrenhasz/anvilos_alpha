{
  "module_name": "nsp_cs.c",
  "hash_id": "2086627363f35a42c85c6b7de2aae8696acfadcb75a99131d38d660fda1734ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/pcmcia/nsp_cs.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/major.h>\n#include <linux/blkdev.h>\n#include <linux/stat.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_ioctl.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/cisreg.h>\n#include <pcmcia/ds.h>\n\n#include \"nsp_cs.h\"\n\nMODULE_AUTHOR(\"YOKOTA Hiroshi <yokota@netlab.is.tsukuba.ac.jp>\");\nMODULE_DESCRIPTION(\"WorkBit NinjaSCSI-3 / NinjaSCSI-32Bi(16bit) PCMCIA SCSI host adapter module\");\nMODULE_LICENSE(\"GPL\");\n\n#include \"nsp_io.h\"\n\n \n \n\nstatic int       nsp_burst_mode = BURST_MEM32;\nmodule_param(nsp_burst_mode, int, 0);\nMODULE_PARM_DESC(nsp_burst_mode, \"Burst transfer mode (0=io8, 1=io32, 2=mem32(default))\");\n\n \nstatic bool       free_ports = 0;\nmodule_param(free_ports, bool, 0);\nMODULE_PARM_DESC(free_ports, \"Release IO ports after configuration? (default: 0 (=no))\");\n\nstatic struct scsi_pointer *nsp_priv(struct scsi_cmnd *cmd)\n{\n\treturn scsi_cmd_priv(cmd);\n}\n\nstatic struct scsi_host_template nsp_driver_template = {\n\t.proc_name\t         = \"nsp_cs\",\n\t.show_info\t\t = nsp_show_info,\n\t.name\t\t\t = \"WorkBit NinjaSCSI-3/32Bi(16bit)\",\n\t.info\t\t\t = nsp_info,\n\t.queuecommand\t\t = nsp_queuecommand,\n \n\t.eh_bus_reset_handler\t = nsp_eh_bus_reset,\n\t.eh_host_reset_handler\t = nsp_eh_host_reset,\n\t.can_queue\t\t = 1,\n\t.this_id\t\t = NSP_INITIATOR_ID,\n\t.sg_tablesize\t\t = SG_ALL,\n\t.dma_boundary\t\t = PAGE_SIZE - 1,\n\t.cmd_size\t\t = sizeof(struct scsi_pointer),\n};\n\nstatic nsp_hw_data nsp_data_base;  \n\n\n\n \n#ifndef NSP_DEBUG\n# define NSP_DEBUG_MASK\t\t0x000000\n# define nsp_msg(type, args...) nsp_cs_message(\"\", 0, (type), args)\n# define nsp_dbg(mask, args...)  \n#else\n# define NSP_DEBUG_MASK\t\t0xffffff\n# define nsp_msg(type, args...) \\\n\tnsp_cs_message (__func__, __LINE__, (type), args)\n# define nsp_dbg(mask, args...) \\\n\tnsp_cs_dmessage(__func__, __LINE__, (mask), args)\n#endif\n\n#define NSP_DEBUG_QUEUECOMMAND\t\tBIT(0)\n#define NSP_DEBUG_REGISTER\t\tBIT(1)\n#define NSP_DEBUG_AUTOSCSI\t\tBIT(2)\n#define NSP_DEBUG_INTR\t\t\tBIT(3)\n#define NSP_DEBUG_SGLIST\t\tBIT(4)\n#define NSP_DEBUG_BUSFREE\t\tBIT(5)\n#define NSP_DEBUG_CDB_CONTENTS\t\tBIT(6)\n#define NSP_DEBUG_RESELECTION\t\tBIT(7)\n#define NSP_DEBUG_MSGINOCCUR\t\tBIT(8)\n#define NSP_DEBUG_EEPROM\t\tBIT(9)\n#define NSP_DEBUG_MSGOUTOCCUR\t\tBIT(10)\n#define NSP_DEBUG_BUSRESET\t\tBIT(11)\n#define NSP_DEBUG_RESTART\t\tBIT(12)\n#define NSP_DEBUG_SYNC\t\t\tBIT(13)\n#define NSP_DEBUG_WAIT\t\t\tBIT(14)\n#define NSP_DEBUG_TARGETFLAG\t\tBIT(15)\n#define NSP_DEBUG_PROC\t\t\tBIT(16)\n#define NSP_DEBUG_INIT\t\t\tBIT(17)\n#define NSP_DEBUG_DATA_IO      \t\tBIT(18)\n#define NSP_SPECIAL_PRINT_REGISTER\tBIT(20)\n\n#define NSP_DEBUG_BUF_LEN\t\t150\n\nstatic inline void nsp_inc_resid(struct scsi_cmnd *SCpnt, int residInc)\n{\n\tscsi_set_resid(SCpnt, scsi_get_resid(SCpnt) + residInc);\n}\n\n__printf(4, 5)\nstatic void nsp_cs_message(const char *func, int line, char *type, char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[NSP_DEBUG_BUF_LEN];\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n#ifndef NSP_DEBUG\n\tprintk(\"%snsp_cs: %s\\n\", type, buf);\n#else\n\tprintk(\"%snsp_cs: %s (%d): %s\\n\", type, func, line, buf);\n#endif\n}\n\n#ifdef NSP_DEBUG\nstatic void nsp_cs_dmessage(const char *func, int line, int mask, char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[NSP_DEBUG_BUF_LEN];\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (mask & NSP_DEBUG_MASK) {\n\t\tprintk(\"nsp_cs-debug: 0x%x %s (%d): %s\\n\", mask, func, line, buf);\n\t}\n}\n#endif\n\n \n\n \nstatic void nsp_scsi_done(struct scsi_cmnd *SCpnt)\n{\n\tnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\n\n\tdata->CurrentSC = NULL;\n\n\tscsi_done(SCpnt);\n}\n\nstatic int nsp_queuecommand_lck(struct scsi_cmnd *const SCpnt)\n{\n\tstruct scsi_pointer *scsi_pointer = nsp_priv(SCpnt);\n#ifdef NSP_DEBUG\n\t \n\t \n\tunsigned char target = scmd_id(SCpnt);\n#endif\n\tnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\n\n\tnsp_dbg(NSP_DEBUG_QUEUECOMMAND,\n\t\t\"SCpnt=0x%p target=%d lun=%llu sglist=0x%p bufflen=%d sg_count=%d\",\n\t\tSCpnt, target, SCpnt->device->lun, scsi_sglist(SCpnt),\n\t\tscsi_bufflen(SCpnt), scsi_sg_count(SCpnt));\n\t\n\n\tif (data->CurrentSC != NULL) {\n\t\tnsp_msg(KERN_DEBUG, \"CurrentSC!=NULL this can't be happen\");\n\t\tSCpnt->result   = DID_BAD_TARGET << 16;\n\t\tnsp_scsi_done(SCpnt);\n\t\treturn 0;\n\t}\n\n#if 0\n\t \n\tif (data->ScsiInfo->stop != 0) {\n\t\tnsp_msg(KERN_INFO, \"suspending device. reject command.\");\n\t\tSCpnt->result  = DID_BAD_TARGET << 16;\n\t\tnsp_scsi_done(SCpnt);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n#endif\n\n\tshow_command(SCpnt);\n\n\tdata->CurrentSC\t\t= SCpnt;\n\n\tscsi_pointer->Status\t   = SAM_STAT_CHECK_CONDITION;\n\tscsi_pointer->Message\t   = 0;\n\tscsi_pointer->have_data_in = IO_UNKNOWN;\n\tscsi_pointer->sent_command = 0;\n\tscsi_pointer->phase\t   = PH_UNDETERMINED;\n\tscsi_set_resid(SCpnt, scsi_bufflen(SCpnt));\n\n\t \n\tif (scsi_bufflen(SCpnt)) {\n\t\tscsi_pointer->buffer\t       = scsi_sglist(SCpnt);\n\t\tscsi_pointer->ptr\t       = BUFFER_ADDR(SCpnt);\n\t\tscsi_pointer->this_residual    = scsi_pointer->buffer->length;\n\t\tscsi_pointer->buffers_residual = scsi_sg_count(SCpnt) - 1;\n\t} else {\n\t\tscsi_pointer->ptr\t       = NULL;\n\t\tscsi_pointer->this_residual    = 0;\n\t\tscsi_pointer->buffer\t       = NULL;\n\t\tscsi_pointer->buffers_residual = 0;\n\t}\n\n\tif (!nsphw_start_selection(SCpnt)) {\n\t\tnsp_dbg(NSP_DEBUG_QUEUECOMMAND, \"selection fail\");\n\t\tSCpnt->result   = DID_BUS_BUSY << 16;\n\t\tnsp_scsi_done(SCpnt);\n\t\treturn 0;\n\t}\n\n\n\t\n#ifdef NSP_DEBUG\n\tdata->CmdId++;\n#endif\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(nsp_queuecommand)\n\n \nstatic void nsp_setup_fifo(nsp_hw_data *data, bool enabled)\n{\n\tunsigned int  base = data->BaseAddress;\n\tunsigned char transfer_mode_reg;\n\n\t\n\n\tif (enabled) {\n\t\ttransfer_mode_reg = TRANSFER_GO | BRAIND;\n\t} else {\n\t\ttransfer_mode_reg = 0;\n\t}\n\n\ttransfer_mode_reg |= data->TransferMode;\n\n\tnsp_index_write(base, TRANSFERMODE, transfer_mode_reg);\n}\n\nstatic void nsphw_init_sync(nsp_hw_data *data)\n{\n\tsync_data tmp_sync = { .SyncNegotiation = SYNC_NOT_YET,\n\t\t\t       .SyncPeriod      = 0,\n\t\t\t       .SyncOffset      = 0\n\t};\n\tint i;\n\n\t \n\tfor ( i = 0; i < ARRAY_SIZE(data->Sync); i++ ) {\n\t\tdata->Sync[i] = tmp_sync;\n\t}\n}\n\n \nstatic void nsphw_init(nsp_hw_data *data)\n{\n\tunsigned int base     = data->BaseAddress;\n\n\tnsp_dbg(NSP_DEBUG_INIT, \"in base=0x%x\", base);\n\n\tdata->ScsiClockDiv = CLOCK_40M | FAST_20;\n\tdata->CurrentSC    = NULL;\n\tdata->FifoCount    = 0;\n\tdata->TransferMode = MODE_IO8;\n\n\tnsphw_init_sync(data);\n\n\t \n\tnsp_write(base,\t      IRQCONTROL,   IRQCONTROL_ALLMASK);\n\n\t \n\tnsp_write(base,\t      IFSELECT,\t    IF_IFSEL);\n\n\tnsp_index_write(base, SCSIIRQMODE,  0);\n\n\tnsp_index_write(base, TRANSFERMODE, MODE_IO8);\n\tnsp_index_write(base, CLOCKDIV,\t    data->ScsiClockDiv);\n\n\tnsp_index_write(base, PARITYCTRL,   0);\n\tnsp_index_write(base, POINTERCLR,   POINTER_CLEAR     |\n\t\t\t\t\t    ACK_COUNTER_CLEAR |\n\t\t\t\t\t    REQ_COUNTER_CLEAR |\n\t\t\t\t\t    HOST_COUNTER_CLEAR);\n\n\t \n\tnsp_write(base,\t      IFSELECT,\t    IF_REGSEL);\n\tnsp_index_write(base, TERMPWRCTRL,  0);\n\tif ((nsp_index_read(base, OTHERCONTROL) & TPWR_SENSE) == 0) {\n\t\tnsp_msg(KERN_INFO, \"terminator power on\");\n\t\tnsp_index_write(base, TERMPWRCTRL, POWER_ON);\n\t}\n\n\tnsp_index_write(base, TIMERCOUNT,   0);\n\tnsp_index_write(base, TIMERCOUNT,   0);  \n\n\tnsp_index_write(base, SYNCREG,\t    0);\n\tnsp_index_write(base, ACKWIDTH,\t    0);\n\n\t \n\tnsp_index_write(base, SCSIIRQMODE,  SCSI_PHASE_CHANGE_EI |\n\t\t\t\t\t    RESELECT_EI\t\t |\n\t\t\t\t\t    SCSI_RESET_IRQ_EI\t );\n\tnsp_write(base,\t      IRQCONTROL,   IRQCONTROL_ALLCLEAR);\n\n\tnsp_setup_fifo(data, false);\n}\n\n \nstatic bool nsphw_start_selection(struct scsi_cmnd *const SCpnt)\n{\n\tstruct scsi_pointer *scsi_pointer = nsp_priv(SCpnt);\n\tunsigned int  host_id\t = SCpnt->device->host->this_id;\n\tunsigned int  base\t = SCpnt->device->host->io_port;\n\tunsigned char target\t = scmd_id(SCpnt);\n\tnsp_hw_data  *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\n\tint\t      time_out;\n\tunsigned char phase, arbit;\n\n\t\n\n\tphase = nsp_index_read(base, SCSIBUSMON);\n\tif(phase != BUSMON_BUS_FREE) {\n\t\t\n\t\treturn false;\n\t}\n\n\t \n\t\n\tscsi_pointer->phase = PH_ARBSTART;\n\tnsp_index_write(base, SETARBIT, ARBIT_GO);\n\n\ttime_out = 1000;\n\tdo {\n\t\t \n\t\tarbit = nsp_index_read(base, ARBITSTATUS);\n\t\t\n\t\tudelay(1);  \n\t} while((arbit & (ARBIT_WIN | ARBIT_FAIL)) == 0 &&\n\t\t(time_out-- != 0));\n\n\tif (!(arbit & ARBIT_WIN)) {\n\t\t\n\t\tnsp_index_write(base, SETARBIT, ARBIT_FLAG_CLEAR);\n\t\treturn false;\n\t}\n\n\t \n\t\n\tscsi_pointer->phase = PH_SELSTART;\n\tudelay(3);  \n\tnsp_index_write(base, SCSIDATALATCH, BIT(host_id) | BIT(target));\n\tnsp_index_write(base, SCSIBUSCTRL,   SCSI_SEL | SCSI_BSY                    | SCSI_ATN);\n\tudelay(2);  \n\tnsp_index_write(base, SCSIBUSCTRL,   SCSI_SEL | SCSI_BSY | SCSI_DATAOUT_ENB | SCSI_ATN);\n\tnsp_index_write(base, SETARBIT,\t     ARBIT_FLAG_CLEAR);\n\t   \n\tnsp_index_write(base, SCSIBUSCTRL,   SCSI_SEL            | SCSI_DATAOUT_ENB | SCSI_ATN);\n\n\t \n\tnsp_start_timer(SCpnt, 1000/51);\n\tdata->SelectionTimeOut = 1;\n\n\treturn true;\n}\n\nstruct nsp_sync_table {\n\tunsigned int min_period;\n\tunsigned int max_period;\n\tunsigned int chip_period;\n\tunsigned int ack_width;\n};\n\nstatic struct nsp_sync_table nsp_sync_table_40M[] = {\n\t{0x0c, 0x0c, 0x1, 0},\t \n\t{0x19, 0x19, 0x3, 1},\t  \n\t{0x1a, 0x25, 0x5, 2},\t  \n\t{0x26, 0x32, 0x7, 3},\t \n\t{   0,    0,   0, 0},\n};\n\nstatic struct nsp_sync_table nsp_sync_table_20M[] = {\n\t{0x19, 0x19, 0x1, 0},\t  \n\t{0x1a, 0x25, 0x2, 0},\t  \n\t{0x26, 0x32, 0x3, 1},\t \n\t{   0,    0,   0, 0},\n};\n\n \nstatic int nsp_analyze_sdtr(struct scsi_cmnd *SCpnt)\n{\n\tunsigned char\t       target = scmd_id(SCpnt);\n\n\tnsp_hw_data           *data   = (nsp_hw_data *)SCpnt->device->host->hostdata;\n\tsync_data\t      *sync   = &(data->Sync[target]);\n\tstruct nsp_sync_table *sync_table;\n\tunsigned int\t       period, offset;\n\n\tnsp_dbg(NSP_DEBUG_SYNC, \"in\");\n\n\tperiod = sync->SyncPeriod;\n\toffset = sync->SyncOffset;\n\n\tnsp_dbg(NSP_DEBUG_SYNC, \"period=0x%x, offset=0x%x\", period, offset);\n\n\tif ((data->ScsiClockDiv & (BIT(0)|BIT(1))) == CLOCK_20M) {\n\t\tsync_table = nsp_sync_table_20M;\n\t} else {\n\t\tsync_table = nsp_sync_table_40M;\n\t}\n\n\tfor (; sync_table->max_period != 0; sync_table++) {\n\t\tif ( period >= sync_table->min_period &&\n\t\t     period <= sync_table->max_period\t ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (period != 0 && sync_table->max_period == 0) {\n\t\t \n\t\tnsp_dbg(NSP_DEBUG_SYNC, \"no proper period/offset\");\n\n\t\tsync->SyncPeriod      = 0;\n\t\tsync->SyncOffset      = 0;\n\t\tsync->SyncRegister    = 0;\n\t\tsync->AckWidth\t      = 0;\n\n\t\treturn false;\n\t}\n\n\tsync->SyncRegister    = (sync_table->chip_period << SYNCREG_PERIOD_SHIFT) |\n\t\t                (offset & SYNCREG_OFFSET_MASK);\n\tsync->AckWidth\t      = sync_table->ack_width;\n\n\tnsp_dbg(NSP_DEBUG_SYNC, \"sync_reg=0x%x, ack_width=0x%x\", sync->SyncRegister, sync->AckWidth);\n\n\treturn true;\n}\n\n\n \nstatic void nsp_start_timer(struct scsi_cmnd *SCpnt, int time)\n{\n\tunsigned int base = SCpnt->device->host->io_port;\n\tnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\n\n\t\n\tdata->TimerCount = time;\n\tnsp_index_write(base, TIMERCOUNT, time);\n}\n\n \nstatic int nsp_negate_signal(struct scsi_cmnd *SCpnt, unsigned char mask,\n\t\t\t     char *str)\n{\n\tunsigned int  base = SCpnt->device->host->io_port;\n\tunsigned char reg;\n\tint\t      time_out;\n\n\t\n\n\ttime_out = 100;\n\n\tdo {\n\t\treg = nsp_index_read(base, SCSIBUSMON);\n\t\tif (reg == 0xff) {\n\t\t\tbreak;\n\t\t}\n\t} while ((--time_out != 0) && (reg & mask) != 0);\n\n\tif (time_out == 0) {\n\t\tnsp_msg(KERN_DEBUG, \" %s signal off timeout\", str);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int nsp_expect_signal(struct scsi_cmnd *SCpnt,\n\t\t\t     unsigned char current_phase,\n\t\t\t     unsigned char mask)\n{\n\tunsigned int  base\t = SCpnt->device->host->io_port;\n\tint\t      time_out;\n\tunsigned char phase, i_src;\n\n\t\n\n\ttime_out = 100;\n\tdo {\n\t\tphase = nsp_index_read(base, SCSIBUSMON);\n\t\tif (phase == 0xff) {\n\t\t\t\n\t\t\treturn -1;\n\t\t}\n\t\ti_src = nsp_read(base, IRQSTATUS);\n\t\tif (i_src & IRQSTATUS_SCSI) {\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\t\tif ((phase & mask) != 0 && (phase & BUSMON_PHASE_MASK) == current_phase) {\n\t\t\t\n\t\t\treturn 1;\n\t\t}\n\t} while(time_out-- != 0);\n\n\t\n\treturn -1;\n}\n\n \nstatic int nsp_xfer(struct scsi_cmnd *const SCpnt, int phase)\n{\n\tstruct scsi_pointer *scsi_pointer = nsp_priv(SCpnt);\n\tunsigned int  base = SCpnt->device->host->io_port;\n\tnsp_hw_data  *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\n\tchar\t     *buf  = data->MsgBuffer;\n\tint\t      len  = min(MSGBUF_SIZE, data->MsgLen);\n\tint\t      ptr;\n\tint\t      ret;\n\n\t\n\tfor (ptr = 0; len > 0; len--, ptr++) {\n\n\t\tret = nsp_expect_signal(SCpnt, phase, BUSMON_REQ);\n\t\tif (ret <= 0) {\n\t\t\tnsp_dbg(NSP_DEBUG_DATA_IO, \"xfer quit\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (len == 1 && scsi_pointer->phase == PH_MSG_OUT) {\n\t\t\tnsp_index_write(base, SCSIBUSCTRL, AUTODIRECTION | ACKENB);\n\t\t}\n\n\t\t \n\t\tif (phase & BUSMON_IO) {\n\t\t\tnsp_dbg(NSP_DEBUG_DATA_IO, \"read msg\");\n\t\t\tbuf[ptr] = nsp_index_read(base, SCSIDATAWITHACK);\n\t\t} else {\n\t\t\tnsp_dbg(NSP_DEBUG_DATA_IO, \"write msg\");\n\t\t\tnsp_index_write(base, SCSIDATAWITHACK, buf[ptr]);\n\t\t}\n\t\tnsp_negate_signal(SCpnt, BUSMON_ACK, \"xfer<ack>\");\n\n\t}\n\treturn len;\n}\n\n \nstatic int nsp_dataphase_bypass(struct scsi_cmnd *const SCpnt)\n{\n\tstruct scsi_pointer *scsi_pointer = nsp_priv(SCpnt);\n\tnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\n\tunsigned int count;\n\n\t\n\n\tif (scsi_pointer->have_data_in != IO_IN) {\n\t\treturn 0;\n\t}\n\n\tcount = nsp_fifo_count(SCpnt);\n\tif (data->FifoCount == count) {\n\t\t\n\t\treturn 0;\n\t}\n\n\t \n\tnsp_dbg(NSP_DEBUG_DATA_IO, \"use bypass quirk\");\n\tscsi_pointer->phase = PH_DATA;\n\tnsp_pio_read(SCpnt);\n\tnsp_setup_fifo(data, false);\n\n\treturn 0;\n}\n\n \nstatic void nsp_reselected(struct scsi_cmnd *SCpnt)\n{\n\tunsigned int  base    = SCpnt->device->host->io_port;\n\tunsigned int  host_id = SCpnt->device->host->this_id;\n\t\n\tunsigned char bus_reg;\n\tunsigned char id_reg, tmp;\n\tint target;\n\n\tnsp_dbg(NSP_DEBUG_RESELECTION, \"in\");\n\n\tid_reg = nsp_index_read(base, RESELECTID);\n\ttmp    = id_reg & (~BIT(host_id));\n\ttarget = 0;\n\twhile(tmp != 0) {\n\t\tif (tmp & BIT(0)) {\n\t\t\tbreak;\n\t\t}\n\t\ttmp >>= 1;\n\t\ttarget++;\n\t}\n\n\tif (scmd_id(SCpnt) != target) {\n\t\tnsp_msg(KERN_ERR, \"XXX: reselect ID must be %d in this implementation.\", target);\n\t}\n\n\tnsp_negate_signal(SCpnt, BUSMON_SEL, \"reselect<SEL>\");\n\n\tnsp_nexus(SCpnt);\n\tbus_reg = nsp_index_read(base, SCSIBUSCTRL) & ~(SCSI_BSY | SCSI_ATN);\n\tnsp_index_write(base, SCSIBUSCTRL, bus_reg);\n\tnsp_index_write(base, SCSIBUSCTRL, bus_reg | AUTODIRECTION | ACKENB);\n}\n\n \nstatic int nsp_fifo_count(struct scsi_cmnd *SCpnt)\n{\n\tunsigned int base = SCpnt->device->host->io_port;\n\tunsigned int count;\n\tunsigned int l, m, h;\n\n\tnsp_index_write(base, POINTERCLR, POINTER_CLEAR | ACK_COUNTER);\n\n\tl     = nsp_index_read(base, TRANSFERCOUNT);\n\tm     = nsp_index_read(base, TRANSFERCOUNT);\n\th     = nsp_index_read(base, TRANSFERCOUNT);\n\tnsp_index_read(base, TRANSFERCOUNT);  \n\n\tcount = (h << 16) | (m << 8) | (l << 0);\n\n\t\n\n\treturn count;\n}\n\n \n#define RFIFO_CRIT 64\n#define WFIFO_CRIT 64\n\n \nstatic void nsp_pio_read(struct scsi_cmnd *const SCpnt)\n{\n\tstruct scsi_pointer *scsi_pointer = nsp_priv(SCpnt);\n\tunsigned int  base      = SCpnt->device->host->io_port;\n\tunsigned long mmio_base = SCpnt->device->host->base;\n\tnsp_hw_data  *data      = (nsp_hw_data *)SCpnt->device->host->hostdata;\n\tlong\t      time_out;\n\tint\t      ocount, res;\n\tunsigned char stat, fifo_stat;\n\n\tocount = data->FifoCount;\n\n\tnsp_dbg(NSP_DEBUG_DATA_IO, \"in SCpnt=0x%p resid=%d ocount=%d ptr=0x%p this_residual=%d buffers=0x%p nbuf=%d\",\n\t\tSCpnt, scsi_get_resid(SCpnt), ocount, scsi_pointer->ptr,\n\t\tscsi_pointer->this_residual, scsi_pointer->buffer,\n\t\tscsi_pointer->buffers_residual);\n\n\ttime_out = 1000;\n\n\twhile ((time_out-- != 0) &&\n\t       (scsi_pointer->this_residual > 0 ||\n\t\tscsi_pointer->buffers_residual > 0)) {\n\n\t\tstat = nsp_index_read(base, SCSIBUSMON);\n\t\tstat &= BUSMON_PHASE_MASK;\n\n\n\t\tres = nsp_fifo_count(SCpnt) - ocount;\n\t\t\n\t\tif (res == 0) {  \n\t\t\tif (stat == BUSPHASE_DATA_IN) {  \n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tnsp_dbg(NSP_DEBUG_DATA_IO, \"phase changed stat=0x%x\", stat);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfifo_stat = nsp_read(base, FIFOSTATUS);\n\t\tif ((fifo_stat & FIFOSTATUS_FULL_EMPTY) == 0 &&\n\t\t    stat                                == BUSPHASE_DATA_IN) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tres = min(res, scsi_pointer->this_residual);\n\n\t\tswitch (data->TransferMode) {\n\t\tcase MODE_IO32:\n\t\t\tres &= ~(BIT(1)|BIT(0));  \n\t\t\tnsp_fifo32_read(base, scsi_pointer->ptr, res >> 2);\n\t\t\tbreak;\n\t\tcase MODE_IO8:\n\t\t\tnsp_fifo8_read(base, scsi_pointer->ptr, res);\n\t\t\tbreak;\n\n\t\tcase MODE_MEM32:\n\t\t\tres &= ~(BIT(1)|BIT(0));  \n\t\t\tnsp_mmio_fifo32_read(mmio_base, scsi_pointer->ptr,\n\t\t\t\t\t     res >> 2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tnsp_dbg(NSP_DEBUG_DATA_IO, \"unknown read mode\");\n\t\t\treturn;\n\t\t}\n\n\t\tnsp_inc_resid(SCpnt, -res);\n\t\tscsi_pointer->ptr += res;\n\t\tscsi_pointer->this_residual -= res;\n\t\tocount\t\t\t += res;\n\t\t\n\n\t\t \n\t\tif (scsi_pointer->this_residual\t== 0 &&\n\t\t    scsi_pointer->buffers_residual != 0 ) {\n\t\t\t\n\t\t\tscsi_pointer->buffers_residual--;\n\t\t\tscsi_pointer->buffer = sg_next(scsi_pointer->buffer);\n\t\t\tscsi_pointer->ptr = BUFFER_ADDR(SCpnt);\n\t\t\tscsi_pointer->this_residual =\n\t\t\t\tscsi_pointer->buffer->length;\n\t\t\ttime_out = 1000;\n\n\t\t\t\n\t\t}\n\t}\n\n\tdata->FifoCount = ocount;\n\n\tif (time_out < 0) {\n\t\tnsp_msg(KERN_DEBUG, \"pio read timeout resid=%d this_residual=%d buffers_residual=%d\",\n\t\t\tscsi_get_resid(SCpnt), scsi_pointer->this_residual,\n\t\t\tscsi_pointer->buffers_residual);\n\t}\n\tnsp_dbg(NSP_DEBUG_DATA_IO, \"read ocount=0x%x\", ocount);\n\tnsp_dbg(NSP_DEBUG_DATA_IO, \"r cmd=%d resid=0x%x\\n\", data->CmdId,\n\t                                                scsi_get_resid(SCpnt));\n}\n\n \nstatic void nsp_pio_write(struct scsi_cmnd *SCpnt)\n{\n\tstruct scsi_pointer *scsi_pointer = nsp_priv(SCpnt);\n\tunsigned int  base      = SCpnt->device->host->io_port;\n\tunsigned long mmio_base = SCpnt->device->host->base;\n\tnsp_hw_data  *data      = (nsp_hw_data *)SCpnt->device->host->hostdata;\n\tint\t      time_out;\n\tint           ocount, res;\n\tunsigned char stat;\n\n\tocount\t = data->FifoCount;\n\n\tnsp_dbg(NSP_DEBUG_DATA_IO, \"in fifocount=%d ptr=0x%p this_residual=%d buffers=0x%p nbuf=%d resid=0x%x\",\n\t\tdata->FifoCount, scsi_pointer->ptr, scsi_pointer->this_residual,\n\t\tscsi_pointer->buffer, scsi_pointer->buffers_residual,\n\t\tscsi_get_resid(SCpnt));\n\n\ttime_out = 1000;\n\n\twhile ((time_out-- != 0) &&\n\t       (scsi_pointer->this_residual > 0 ||\n\t\tscsi_pointer->buffers_residual > 0)) {\n\t\tstat = nsp_index_read(base, SCSIBUSMON);\n\t\tstat &= BUSMON_PHASE_MASK;\n\n\t\tif (stat != BUSPHASE_DATA_OUT) {\n\t\t\tres = ocount - nsp_fifo_count(SCpnt);\n\n\t\t\tnsp_dbg(NSP_DEBUG_DATA_IO, \"phase changed stat=0x%x, res=%d\\n\", stat, res);\n\t\t\t \n\t\t\tnsp_inc_resid(SCpnt, res);\n\t\t\tscsi_pointer->ptr -= res;\n\t\t\tscsi_pointer->this_residual += res;\n\t\t\tocount -= res;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tres = ocount - nsp_fifo_count(SCpnt);\n\t\tif (res > 0) {  \n\t\t\tnsp_dbg(NSP_DEBUG_DATA_IO, \"wait for all data out. ocount=0x%x res=%d\", ocount, res);\n\t\t\tcontinue;\n\t\t}\n\n\t\tres = min(scsi_pointer->this_residual, WFIFO_CRIT);\n\n\t\t\n\t\tswitch (data->TransferMode) {\n\t\tcase MODE_IO32:\n\t\t\tres &= ~(BIT(1)|BIT(0));  \n\t\t\tnsp_fifo32_write(base, scsi_pointer->ptr, res >> 2);\n\t\t\tbreak;\n\t\tcase MODE_IO8:\n\t\t\tnsp_fifo8_write(base, scsi_pointer->ptr, res);\n\t\t\tbreak;\n\n\t\tcase MODE_MEM32:\n\t\t\tres &= ~(BIT(1)|BIT(0));  \n\t\t\tnsp_mmio_fifo32_write(mmio_base, scsi_pointer->ptr,\n\t\t\t\t\t      res >> 2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tnsp_dbg(NSP_DEBUG_DATA_IO, \"unknown write mode\");\n\t\t\tbreak;\n\t\t}\n\n\t\tnsp_inc_resid(SCpnt, -res);\n\t\tscsi_pointer->ptr += res;\n\t\tscsi_pointer->this_residual -= res;\n\t\tocount += res;\n\n\t\t \n\t\tif (scsi_pointer->this_residual\t== 0 &&\n\t\t    scsi_pointer->buffers_residual != 0 ) {\n\t\t\t\n\t\t\tscsi_pointer->buffers_residual--;\n\t\t\tscsi_pointer->buffer = sg_next(scsi_pointer->buffer);\n\t\t\tscsi_pointer->ptr = BUFFER_ADDR(SCpnt);\n\t\t\tscsi_pointer->this_residual =\n\t\t\t\tscsi_pointer->buffer->length;\n\t\t\ttime_out = 1000;\n\t\t}\n\t}\n\n\tdata->FifoCount = ocount;\n\n\tif (time_out < 0) {\n\t\tnsp_msg(KERN_DEBUG, \"pio write timeout resid=0x%x\",\n\t\t                                        scsi_get_resid(SCpnt));\n\t}\n\tnsp_dbg(NSP_DEBUG_DATA_IO, \"write ocount=0x%x\", ocount);\n\tnsp_dbg(NSP_DEBUG_DATA_IO, \"w cmd=%d resid=0x%x\\n\", data->CmdId,\n\t                                                scsi_get_resid(SCpnt));\n}\n#undef RFIFO_CRIT\n#undef WFIFO_CRIT\n\n \nstatic int nsp_nexus(struct scsi_cmnd *SCpnt)\n{\n\tunsigned int   base   = SCpnt->device->host->io_port;\n\tunsigned char  target = scmd_id(SCpnt);\n\n\tnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\n\tsync_data     *sync   = &(data->Sync[target]);\n\n\t\n\n\t \n\tnsp_index_write(base, SYNCREG,\tsync->SyncRegister);\n\tnsp_index_write(base, ACKWIDTH, sync->AckWidth);\n\n\tif (scsi_get_resid(SCpnt) % 4 != 0 ||\n\t    scsi_get_resid(SCpnt) <= PAGE_SIZE ) {\n\t\tdata->TransferMode = MODE_IO8;\n\t} else if (nsp_burst_mode == BURST_MEM32) {\n\t\tdata->TransferMode = MODE_MEM32;\n\t} else if (nsp_burst_mode == BURST_IO32) {\n\t\tdata->TransferMode = MODE_IO32;\n\t} else {\n\t\tdata->TransferMode = MODE_IO8;\n\t}\n\n\t \n\tnsp_setup_fifo(data, true);\n\n\t \n \tdata->FifoCount = 0;\n\tnsp_index_write(base, POINTERCLR, POINTER_CLEAR\t    |\n\t\t\t\t\t  ACK_COUNTER_CLEAR |\n\t\t\t\t\t  REQ_COUNTER_CLEAR |\n\t\t\t\t\t  HOST_COUNTER_CLEAR);\n\n\treturn 0;\n}\n\n#include \"nsp_message.c\"\n \nstatic irqreturn_t nspintr(int irq, void *dev_id)\n{\n\tunsigned int   base;\n\tunsigned char  irq_status, irq_phase, phase;\n\tstruct scsi_cmnd *tmpSC;\n\tstruct scsi_pointer *scsi_pointer;\n\tunsigned char  target, lun;\n\tunsigned int  *sync_neg;\n\tint            i, tmp;\n\tnsp_hw_data   *data;\n\n\n\t\n\t\n\n\tif (                dev_id        != NULL &&\n\t    ((scsi_info_t *)dev_id)->host != NULL  ) {\n\t\tscsi_info_t *info = (scsi_info_t *)dev_id;\n\n\t\tdata = (nsp_hw_data *)info->host->hostdata;\n\t} else {\n\t\tnsp_dbg(NSP_DEBUG_INTR, \"host data wrong\");\n\t\treturn IRQ_NONE;\n\t}\n\n\t\n\n\tbase = data->BaseAddress;\n\t\n\n\t \n\tnsp_write(base, IRQCONTROL, IRQCONTROL_IRQDISABLE);\n\tirq_status = nsp_read(base, IRQSTATUS);\n\t\n\tif ((irq_status == 0xff) || ((irq_status & IRQSTATUS_MASK) == 0)) {\n\t\tnsp_write(base, IRQCONTROL, 0);\n\t\t\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tphase = nsp_index_read(base, SCSIBUSMON);\n\tif((irq_status & IRQSTATUS_SCSI) != 0) {\n\t\tirq_phase = nsp_index_read(base, IRQPHASESENCE);\n\t} else {\n\t\tirq_phase = 0;\n\t}\n\n\t\n\n\t \n\t\n\tif (data->TimerCount != 0) {\n\t\t\n\t\tnsp_index_write(base, TIMERCOUNT, 0);\n\t\tnsp_index_write(base, TIMERCOUNT, 0);\n\t\tdata->TimerCount = 0;\n\t}\n\n\tif ((irq_status & IRQSTATUS_MASK) == IRQSTATUS_TIMER &&\n\t    data->SelectionTimeOut == 0) {\n\t\t\n\t\tnsp_write(base, IRQCONTROL, IRQCONTROL_TIMER_CLEAR);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tnsp_write(base, IRQCONTROL, IRQCONTROL_TIMER_CLEAR | IRQCONTROL_FIFO_CLEAR);\n\n\tif ((irq_status & IRQSTATUS_SCSI) &&\n\t    (irq_phase  & SCSI_RESET_IRQ)) {\n\t\tnsp_msg(KERN_ERR, \"bus reset (power off?)\");\n\n\t\tnsphw_init(data);\n\t\tnsp_bus_reset(data);\n\n\t\tif(data->CurrentSC != NULL) {\n\t\t\ttmpSC = data->CurrentSC;\n\t\t\tscsi_pointer = nsp_priv(tmpSC);\n\t\t\ttmpSC->result = (DID_RESET              << 16) |\n\t\t\t\t((scsi_pointer->Message & 0xff) <<  8) |\n\t\t\t\t((scsi_pointer->Status  & 0xff) <<  0);\n\t\t\tnsp_scsi_done(tmpSC);\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (data->CurrentSC == NULL) {\n\t\tnsp_msg(KERN_ERR, \"CurrentSC==NULL irq_status=0x%x phase=0x%x irq_phase=0x%x this can't be happen. reset everything\", irq_status, phase, irq_phase);\n\t\tnsphw_init(data);\n\t\tnsp_bus_reset(data);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\ttmpSC    = data->CurrentSC;\n\tscsi_pointer = nsp_priv(tmpSC);\n\ttarget   = tmpSC->device->id;\n\tlun      = tmpSC->device->lun;\n\tsync_neg = &(data->Sync[target].SyncNegotiation);\n\n\t \n\tif (irq_status & IRQSTATUS_SCSI) {\n\t\tif (irq_phase & RESELECT_IRQ) {\n\t\t\tnsp_dbg(NSP_DEBUG_INTR, \"reselect\");\n\t\t\tnsp_write(base, IRQCONTROL, IRQCONTROL_RESELECT_CLEAR);\n\t\t\tnsp_reselected(tmpSC);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tif ((irq_phase & (PHASE_CHANGE_IRQ | LATCHED_BUS_FREE)) == 0) {\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n\n\t\n\n\tswitch (scsi_pointer->phase) {\n\tcase PH_SELSTART:\n\t\t\n\t\tif ((phase & BUSMON_BSY) == 0) {\n\t\t\t\n\t\t\tif (data->SelectionTimeOut >= NSP_SELTIMEOUT) {\n\t\t\t\tnsp_dbg(NSP_DEBUG_INTR, \"selection time out\");\n\t\t\t\tdata->SelectionTimeOut = 0;\n\t\t\t\tnsp_index_write(base, SCSIBUSCTRL, 0);\n\n\t\t\t\ttmpSC->result   = DID_TIME_OUT << 16;\n\t\t\t\tnsp_scsi_done(tmpSC);\n\n\t\t\t\treturn IRQ_HANDLED;\n\t\t\t}\n\t\t\tdata->SelectionTimeOut += 1;\n\t\t\tnsp_start_timer(tmpSC, 1000/51);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\t \n\t\t\n\t\tdata->SelectionTimeOut = 0;\n\t\tscsi_pointer->phase = PH_SELECTED;\n\t\tnsp_index_write(base, SCSIBUSCTRL, SCSI_ATN);\n\t\tudelay(1);\n\t\tnsp_index_write(base, SCSIBUSCTRL, SCSI_ATN | AUTODIRECTION | ACKENB);\n\t\treturn IRQ_HANDLED;\n\n\tcase PH_RESELECT:\n\t\t\n\t\t\n\t\tif ((phase & BUSMON_PHASE_MASK) != BUSPHASE_MESSAGE_IN) {\n\n\t\t\ttmpSC->result\t= DID_ABORT << 16;\n\t\t\tnsp_scsi_done(tmpSC);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tif ((irq_status & (IRQSTATUS_SCSI | IRQSTATUS_FIFO)) == 0) {\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\t\n\n\t \n\tif ((scsi_pointer->phase == PH_MSG_IN ||\n\t     scsi_pointer->phase == PH_MSG_OUT) &&\n\t    (irq_phase & LATCHED_BUS_FREE) != 0) {\n\t\tnsp_dbg(NSP_DEBUG_INTR, \"normal disconnect irq_status=0x%x, phase=0x%x, irq_phase=0x%x\", irq_status, phase, irq_phase);\n\n\t\t\n\n\t\t \n\t\tif (scsi_pointer->Message == COMMAND_COMPLETE) {\n\t\t\ttmpSC->result = (DID_OK\t\t        << 16) |\n\t\t\t\t((scsi_pointer->Message & 0xff) <<  8) |\n\t\t\t\t((scsi_pointer->Status  & 0xff) <<  0);\n\t\t\tnsp_dbg(NSP_DEBUG_INTR, \"command complete result=0x%x\", tmpSC->result);\n\t\t\tnsp_scsi_done(tmpSC);\n\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\n\t \n\tif (phase == 0) {\n\t\tnsp_msg(KERN_DEBUG, \"unexpected bus free. irq_status=0x%x, phase=0x%x, irq_phase=0x%x\", irq_status, phase, irq_phase);\n\n\t\t*sync_neg       = SYNC_NG;\n\t\ttmpSC->result   = DID_ERROR << 16;\n\t\tnsp_scsi_done(tmpSC);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tswitch (phase & BUSMON_PHASE_MASK) {\n\tcase BUSPHASE_COMMAND:\n\t\tnsp_dbg(NSP_DEBUG_INTR, \"BUSPHASE_COMMAND\");\n\t\tif ((phase & BUSMON_REQ) == 0) {\n\t\t\tnsp_dbg(NSP_DEBUG_INTR, \"REQ == 0\");\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tscsi_pointer->phase = PH_COMMAND;\n\n\t\tnsp_nexus(tmpSC);\n\n\t\t \n\t\tnsp_dbg(NSP_DEBUG_INTR, \"cmd_len=%d\", tmpSC->cmd_len);\n\t\tnsp_index_write(base, COMMANDCTRL, CLEAR_COMMAND_POINTER);\n\t\tfor (i = 0; i < tmpSC->cmd_len; i++) {\n\t\t\tnsp_index_write(base, COMMANDDATA, tmpSC->cmnd[i]);\n\t\t}\n\t\tnsp_index_write(base, COMMANDCTRL, CLEAR_COMMAND_POINTER | AUTO_COMMAND_GO);\n\t\tbreak;\n\n\tcase BUSPHASE_DATA_OUT:\n\t\tnsp_dbg(NSP_DEBUG_INTR, \"BUSPHASE_DATA_OUT\");\n\n\t\tscsi_pointer->phase        = PH_DATA;\n\t\tscsi_pointer->have_data_in = IO_OUT;\n\n\t\tnsp_pio_write(tmpSC);\n\n\t\tbreak;\n\n\tcase BUSPHASE_DATA_IN:\n\t\tnsp_dbg(NSP_DEBUG_INTR, \"BUSPHASE_DATA_IN\");\n\n\t\tscsi_pointer->phase        = PH_DATA;\n\t\tscsi_pointer->have_data_in = IO_IN;\n\n\t\tnsp_pio_read(tmpSC);\n\n\t\tbreak;\n\n\tcase BUSPHASE_STATUS:\n\t\tnsp_dataphase_bypass(tmpSC);\n\t\tnsp_dbg(NSP_DEBUG_INTR, \"BUSPHASE_STATUS\");\n\n\t\tscsi_pointer->phase = PH_STATUS;\n\n\t\tscsi_pointer->Status = nsp_index_read(base, SCSIDATAWITHACK);\n\t\tnsp_dbg(NSP_DEBUG_INTR, \"message=0x%x status=0x%x\",\n\t\t\tscsi_pointer->Message, scsi_pointer->Status);\n\n\t\tbreak;\n\n\tcase BUSPHASE_MESSAGE_OUT:\n\t\tnsp_dbg(NSP_DEBUG_INTR, \"BUSPHASE_MESSAGE_OUT\");\n\t\tif ((phase & BUSMON_REQ) == 0) {\n\t\t\tgoto timer_out;\n\t\t}\n\n\t\tscsi_pointer->phase = PH_MSG_OUT;\n\n\t\t\n\n\t\tdata->MsgLen = i = 0;\n\t\tdata->MsgBuffer[i] = IDENTIFY(true, lun); i++;\n\n\t\tif (*sync_neg == SYNC_NOT_YET) {\n\t\t\tdata->Sync[target].SyncPeriod = 0;\n\t\t\tdata->Sync[target].SyncOffset = 0;\n\n\t\t\t \n\t\t\tdata->MsgBuffer[i] = EXTENDED_MESSAGE; i++;\n\t\t\tdata->MsgBuffer[i] = 3;            i++;\n\t\t\tdata->MsgBuffer[i] = EXTENDED_SDTR; i++;\n\t\t\tdata->MsgBuffer[i] = 0x0c;         i++;\n\t\t\tdata->MsgBuffer[i] = 15;           i++;\n\t\t\t \n\t\t}\n\t\tdata->MsgLen = i;\n\n\t\tnsp_analyze_sdtr(tmpSC);\n\t\tshow_message(data);\n\t\tnsp_message_out(tmpSC);\n\t\tbreak;\n\n\tcase BUSPHASE_MESSAGE_IN:\n\t\tnsp_dataphase_bypass(tmpSC);\n\t\tnsp_dbg(NSP_DEBUG_INTR, \"BUSPHASE_MESSAGE_IN\");\n\t\tif ((phase & BUSMON_REQ) == 0) {\n\t\t\tgoto timer_out;\n\t\t}\n\n\t\tscsi_pointer->phase = PH_MSG_IN;\n\t\tnsp_message_in(tmpSC);\n\n\t\t \n\t\tif (*sync_neg == SYNC_NOT_YET) {\n\t\t\t\n\n\t\t\tif (data->MsgLen       >= 5            &&\n\t\t\t    data->MsgBuffer[0] == EXTENDED_MESSAGE &&\n\t\t\t    data->MsgBuffer[1] == 3            &&\n\t\t\t    data->MsgBuffer[2] == EXTENDED_SDTR ) {\n\t\t\t\tdata->Sync[target].SyncPeriod = data->MsgBuffer[3];\n\t\t\t\tdata->Sync[target].SyncOffset = data->MsgBuffer[4];\n\t\t\t\t\n\t\t\t\t*sync_neg = SYNC_OK;\n\t\t\t} else {\n\t\t\t\tdata->Sync[target].SyncPeriod = 0;\n\t\t\t\tdata->Sync[target].SyncOffset = 0;\n\t\t\t\t*sync_neg = SYNC_NG;\n\t\t\t}\n\t\t\tnsp_analyze_sdtr(tmpSC);\n\t\t}\n\t\t \n\n\t\t \n\t\ttmp = -1;\n\t\tfor (i = 0; i < data->MsgLen; i++) {\n\t\t\ttmp = data->MsgBuffer[i];\n\t\t\tif (data->MsgBuffer[i] == EXTENDED_MESSAGE) {\n\t\t\t\ti += (1 + data->MsgBuffer[i+1]);\n\t\t\t}\n\t\t}\n\t\tscsi_pointer->Message = tmp;\n\n\t\tnsp_dbg(NSP_DEBUG_INTR, \"message=0x%x len=%d\",\n\t\t\tscsi_pointer->Message, data->MsgLen);\n\t\tshow_message(data);\n\n\t\tbreak;\n\n\tcase BUSPHASE_SELECT:\n\tdefault:\n\t\tnsp_dbg(NSP_DEBUG_INTR, \"BUSPHASE other\");\n\n\t\tbreak;\n\t}\n\n\t\n\treturn IRQ_HANDLED; \t\n\ntimer_out:\n\tnsp_start_timer(tmpSC, 1000/102);\n\treturn IRQ_HANDLED;\n}\n\n#ifdef NSP_DEBUG\n#include \"nsp_debug.c\"\n#endif\t \n\n \n \n \nstatic struct Scsi_Host *nsp_detect(struct scsi_host_template *sht)\n{\n\tstruct Scsi_Host *host;\t \n\tnsp_hw_data *data_b = &nsp_data_base, *data;\n\n\tnsp_dbg(NSP_DEBUG_INIT, \"this_id=%d\", sht->this_id);\n\thost = scsi_host_alloc(&nsp_driver_template, sizeof(nsp_hw_data));\n\tif (host == NULL) {\n\t\tnsp_dbg(NSP_DEBUG_INIT, \"host failed\");\n\t\treturn NULL;\n\t}\n\n\tmemcpy(host->hostdata, data_b, sizeof(nsp_hw_data));\n\tdata = (nsp_hw_data *)host->hostdata;\n\tdata->ScsiInfo->host = host;\n#ifdef NSP_DEBUG\n\tdata->CmdId = 0;\n#endif\n\n\tnsp_dbg(NSP_DEBUG_INIT, \"irq=%d,%d\", data_b->IrqNumber, ((nsp_hw_data *)host->hostdata)->IrqNumber);\n\n\thost->unique_id\t  = data->BaseAddress;\n\thost->io_port\t  = data->BaseAddress;\n\thost->n_io_port\t  = data->NumAddress;\n\thost->irq\t  = data->IrqNumber;\n\thost->base        = data->MmioAddress;\n\n\tspin_lock_init(&(data->Lock));\n\n\tsnprintf(data->nspinfo,\n\t\t sizeof(data->nspinfo),\n\t\t \"NinjaSCSI-3/32Bi Driver $Revision: 1.23 $ IO:0x%04lx-0x%04lx MMIO(virt addr):0x%04lx IRQ:%02d\",\n\t\t host->io_port, host->io_port + host->n_io_port - 1,\n\t\t host->base,\n\t\t host->irq);\n\tsht->name\t  = data->nspinfo;\n\n\tnsp_dbg(NSP_DEBUG_INIT, \"end\");\n\n\n\treturn host;  \n}\n\n \n \n \nstatic const char *nsp_info(struct Scsi_Host *shpnt)\n{\n\tnsp_hw_data *data = (nsp_hw_data *)shpnt->hostdata;\n\n\treturn data->nspinfo;\n}\n\nstatic int nsp_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tint id;\n\tint speed;\n\tunsigned long flags;\n\tnsp_hw_data *data;\n\tint hostno;\n\n\thostno = host->host_no;\n\tdata = (nsp_hw_data *)host->hostdata;\n\n\tseq_puts(m, \"NinjaSCSI status\\n\\n\"\n\t\t\"Driver version:        $Revision: 1.23 $\\n\");\n\tseq_printf(m, \"SCSI host No.:         %d\\n\",          hostno);\n\tseq_printf(m, \"IRQ:                   %d\\n\",          host->irq);\n\tseq_printf(m, \"IO:                    0x%lx-0x%lx\\n\", host->io_port, host->io_port + host->n_io_port - 1);\n\tseq_printf(m, \"MMIO(virtual address): 0x%lx-0x%lx\\n\", host->base, host->base + data->MmioLength - 1);\n\tseq_printf(m, \"sg_tablesize:          %d\\n\",          host->sg_tablesize);\n\n\tseq_puts(m, \"burst transfer mode:   \");\n\tswitch (nsp_burst_mode) {\n\tcase BURST_IO8:\n\t\tseq_puts(m, \"io8\");\n\t\tbreak;\n\tcase BURST_IO32:\n\t\tseq_puts(m, \"io32\");\n\t\tbreak;\n\tcase BURST_MEM32:\n\t\tseq_puts(m, \"mem32\");\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(m, \"???\");\n\t\tbreak;\n\t}\n\tseq_putc(m, '\\n');\n\n\n\tspin_lock_irqsave(&(data->Lock), flags);\n\tseq_printf(m, \"CurrentSC:             0x%p\\n\\n\",      data->CurrentSC);\n\tspin_unlock_irqrestore(&(data->Lock), flags);\n\n\tseq_puts(m, \"SDTR status\\n\");\n\tfor(id = 0; id < ARRAY_SIZE(data->Sync); id++) {\n\n\t\tseq_printf(m, \"id %d: \", id);\n\n\t\tif (id == host->this_id) {\n\t\t\tseq_puts(m, \"----- NinjaSCSI-3 host adapter\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch(data->Sync[id].SyncNegotiation) {\n\t\tcase SYNC_OK:\n\t\t\tseq_puts(m, \" sync\");\n\t\t\tbreak;\n\t\tcase SYNC_NG:\n\t\t\tseq_puts(m, \"async\");\n\t\t\tbreak;\n\t\tcase SYNC_NOT_YET:\n\t\t\tseq_puts(m, \" none\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_puts(m, \"?????\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (data->Sync[id].SyncPeriod != 0) {\n\t\t\tspeed = 1000000 / (data->Sync[id].SyncPeriod * 4);\n\n\t\t\tseq_printf(m, \" transfer %d.%dMB/s, offset %d\",\n\t\t\t\tspeed / 1000,\n\t\t\t\tspeed % 1000,\n\t\t\t\tdata->Sync[id].SyncOffset\n\t\t\t\t);\n\t\t}\n\t\tseq_putc(m, '\\n');\n\t}\n\treturn 0;\n}\n\n \n \n \n\n \n\nstatic int nsp_bus_reset(nsp_hw_data *data)\n{\n\tunsigned int base = data->BaseAddress;\n\tint\t     i;\n\n\tnsp_write(base, IRQCONTROL, IRQCONTROL_ALLMASK);\n\n\tnsp_index_write(base, SCSIBUSCTRL, SCSI_RST);\n\tmdelay(100);  \n\tnsp_index_write(base, SCSIBUSCTRL, 0);\n\tfor(i = 0; i < 5; i++) {\n\t\tnsp_index_read(base, IRQPHASESENCE);  \n\t}\n\n\tnsphw_init_sync(data);\n\n\tnsp_write(base, IRQCONTROL, IRQCONTROL_ALLCLEAR);\n\n\treturn SUCCESS;\n}\n\nstatic int nsp_eh_bus_reset(struct scsi_cmnd *SCpnt)\n{\n\tnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\n\n\tnsp_dbg(NSP_DEBUG_BUSRESET, \"SCpnt=0x%p\", SCpnt);\n\n\treturn nsp_bus_reset(data);\n}\n\nstatic int nsp_eh_host_reset(struct scsi_cmnd *SCpnt)\n{\n\tnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\n\n\tnsp_dbg(NSP_DEBUG_BUSRESET, \"in\");\n\n\tnsphw_init(data);\n\n\treturn SUCCESS;\n}\n\n\n \n\nstatic int nsp_cs_probe(struct pcmcia_device *link)\n{\n\tscsi_info_t  *info;\n\tnsp_hw_data  *data = &nsp_data_base;\n\tint ret;\n\n\tnsp_dbg(NSP_DEBUG_INIT, \"in\");\n\n\t \n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (info == NULL) { return -ENOMEM; }\n\tinfo->p_dev = link;\n\tlink->priv = info;\n\tdata->ScsiInfo = info;\n\n\tnsp_dbg(NSP_DEBUG_INIT, \"info=0x%p\", info);\n\n\tret = nsp_cs_config(link);\n\n\tnsp_dbg(NSP_DEBUG_INIT, \"link=0x%p\", link);\n\treturn ret;\n}  \n\n\nstatic void nsp_cs_detach(struct pcmcia_device *link)\n{\n\tnsp_dbg(NSP_DEBUG_INIT, \"in, link=0x%p\", link);\n\n\t((scsi_info_t *)link->priv)->stop = 1;\n\tnsp_cs_release(link);\n\n\tkfree(link->priv);\n\tlink->priv = NULL;\n}  \n\n\nstatic int nsp_cs_config_check(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tnsp_hw_data\t\t*data = priv_data;\n\n\tif (p_dev->config_index == 0)\n\t\treturn -ENODEV;\n\n\t \n\tif (pcmcia_request_io(p_dev) != 0)\n\t\tgoto next_entry;\n\n\tif (resource_size(p_dev->resource[2])) {\n\t\tp_dev->resource[2]->flags |= (WIN_DATA_WIDTH_16 |\n\t\t\t\t\tWIN_MEMORY_TYPE_CM |\n\t\t\t\t\tWIN_ENABLE);\n\t\tif (p_dev->resource[2]->end < 0x1000)\n\t\t\tp_dev->resource[2]->end = 0x1000;\n\t\tif (pcmcia_request_window(p_dev, p_dev->resource[2], 0) != 0)\n\t\t\tgoto next_entry;\n\t\tif (pcmcia_map_mem_page(p_dev, p_dev->resource[2],\n\t\t\t\t\t\tp_dev->card_addr) != 0)\n\t\t\tgoto next_entry;\n\n\t\tdata->MmioAddress = (unsigned long)\n\t\t\tioremap(p_dev->resource[2]->start,\n\t\t\t\t\tresource_size(p_dev->resource[2]));\n\t\tif (!data->MmioAddress)\n\t\t\tgoto next_entry;\n\n\t\tdata->MmioLength  = resource_size(p_dev->resource[2]);\n\t}\n\t \n\treturn 0;\n\nnext_entry:\n\tnsp_dbg(NSP_DEBUG_INIT, \"next\");\n\tpcmcia_disable_device(p_dev);\n\treturn -ENODEV;\n}\n\nstatic int nsp_cs_config(struct pcmcia_device *link)\n{\n\tint\t\t  ret;\n\tscsi_info_t\t *info\t = link->priv;\n\tstruct Scsi_Host *host;\n\tnsp_hw_data      *data = &nsp_data_base;\n\n\tnsp_dbg(NSP_DEBUG_INIT, \"in\");\n\n\tlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_CHECK_VCC |\n\t\tCONF_AUTO_SET_VPP | CONF_AUTO_AUDIO | CONF_AUTO_SET_IOMEM |\n\t\tCONF_AUTO_SET_IO;\n\n\tret = pcmcia_loop_config(link, nsp_cs_config_check, data);\n\tif (ret)\n\t\tgoto cs_failed;\n\n\tif (pcmcia_request_irq(link, nspintr))\n\t\tgoto cs_failed;\n\n\tret = pcmcia_enable_device(link);\n\tif (ret)\n\t\tgoto cs_failed;\n\n\tif (free_ports) {\n\t\tif (link->resource[0]) {\n\t\t\trelease_region(link->resource[0]->start,\n\t\t\t\t\tresource_size(link->resource[0]));\n\t\t}\n\t\tif (link->resource[1]) {\n\t\t\trelease_region(link->resource[1]->start,\n\t\t\t\t\tresource_size(link->resource[1]));\n\t\t}\n\t}\n\n\t \n\tdata->BaseAddress = link->resource[0]->start;\n\tdata->NumAddress  = resource_size(link->resource[0]);\n\tdata->IrqNumber   = link->irq;\n\n\tnsp_dbg(NSP_DEBUG_INIT, \"I/O[0x%x+0x%x] IRQ %d\",\n\t\tdata->BaseAddress, data->NumAddress, data->IrqNumber);\n\n\tnsphw_init(data);\n\n\thost = nsp_detect(&nsp_driver_template);\n\n\tif (host == NULL) {\n\t\tnsp_dbg(NSP_DEBUG_INIT, \"detect failed\");\n\t\tgoto cs_failed;\n\t}\n\n\n\tret = scsi_add_host (host, NULL);\n\tif (ret)\n\t\tgoto cs_failed;\n\n\tscsi_scan_host(host);\n\n\tinfo->host = host;\n\n\treturn 0;\n\n cs_failed:\n\tnsp_dbg(NSP_DEBUG_INIT, \"config fail\");\n\tnsp_cs_release(link);\n\n\treturn -ENODEV;\n}  \n\n\nstatic void nsp_cs_release(struct pcmcia_device *link)\n{\n\tscsi_info_t *info = link->priv;\n\tnsp_hw_data *data = NULL;\n\n\tif (info->host == NULL) {\n\t\tnsp_msg(KERN_DEBUG, \"unexpected card release call.\");\n\t} else {\n\t\tdata = (nsp_hw_data *)info->host->hostdata;\n\t}\n\n\tnsp_dbg(NSP_DEBUG_INIT, \"link=0x%p\", link);\n\n\t \n\tif (info->host != NULL) {\n\t\tscsi_remove_host(info->host);\n\t}\n\n\tif (resource_size(link->resource[2])) {\n\t\tif (data != NULL) {\n\t\t\tiounmap((void *)(data->MmioAddress));\n\t\t}\n\t}\n\tpcmcia_disable_device(link);\n\n\tif (info->host != NULL) {\n\t\tscsi_host_put(info->host);\n\t}\n}  \n\nstatic int nsp_cs_suspend(struct pcmcia_device *link)\n{\n\tscsi_info_t *info = link->priv;\n\tnsp_hw_data *data;\n\n\tnsp_dbg(NSP_DEBUG_INIT, \"event: suspend\");\n\n\tif (info->host != NULL) {\n\t\tnsp_msg(KERN_INFO, \"clear SDTR status\");\n\n\t\tdata = (nsp_hw_data *)info->host->hostdata;\n\n\t\tnsphw_init_sync(data);\n\t}\n\n\tinfo->stop = 1;\n\n\treturn 0;\n}\n\nstatic int nsp_cs_resume(struct pcmcia_device *link)\n{\n\tscsi_info_t *info = link->priv;\n\tnsp_hw_data *data;\n\n\tnsp_dbg(NSP_DEBUG_INIT, \"event: resume\");\n\n\tinfo->stop = 0;\n\n\tif (info->host != NULL) {\n\t\tnsp_msg(KERN_INFO, \"reset host and bus\");\n\n\t\tdata = (nsp_hw_data *)info->host->hostdata;\n\n\t\tnsphw_init   (data);\n\t\tnsp_bus_reset(data);\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct pcmcia_device_id nsp_cs_ids[] = {\n\tPCMCIA_DEVICE_PROD_ID123(\"IO DATA\", \"CBSC16       \", \"1\", 0x547e66dc, 0x0d63a3fd, 0x51de003a),\n\tPCMCIA_DEVICE_PROD_ID123(\"KME    \", \"SCSI-CARD-001\", \"1\", 0x534c02bc, 0x52008408, 0x51de003a),\n\tPCMCIA_DEVICE_PROD_ID123(\"KME    \", \"SCSI-CARD-002\", \"1\", 0x534c02bc, 0xcb09d5b2, 0x51de003a),\n\tPCMCIA_DEVICE_PROD_ID123(\"KME    \", \"SCSI-CARD-003\", \"1\", 0x534c02bc, 0xbc0ee524, 0x51de003a),\n\tPCMCIA_DEVICE_PROD_ID123(\"KME    \", \"SCSI-CARD-004\", \"1\", 0x534c02bc, 0x226a7087, 0x51de003a),\n\tPCMCIA_DEVICE_PROD_ID123(\"WBT\", \"NinjaSCSI-3\", \"R1.0\", 0xc7ba805f, 0xfdc7c97d, 0x6973710e),\n\tPCMCIA_DEVICE_PROD_ID123(\"WORKBIT\", \"UltraNinja-16\", \"1\", 0x28191418, 0xb70f4b09, 0x51de003a),\n\tPCMCIA_DEVICE_NULL\n};\nMODULE_DEVICE_TABLE(pcmcia, nsp_cs_ids);\n\nstatic struct pcmcia_driver nsp_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"nsp_cs\",\n\t.probe\t\t= nsp_cs_probe,\n\t.remove\t\t= nsp_cs_detach,\n\t.id_table\t= nsp_cs_ids,\n\t.suspend\t= nsp_cs_suspend,\n\t.resume\t\t= nsp_cs_resume,\n};\nmodule_pcmcia_driver(nsp_driver);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}