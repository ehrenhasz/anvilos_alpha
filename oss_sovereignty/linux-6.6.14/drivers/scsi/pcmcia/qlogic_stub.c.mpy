{
  "module_name": "qlogic_stub.c",
  "hash_id": "79dd926bc7cee9b04a6d4bcca44395e09408fe610f6ea419c3066bc2e244055c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/pcmcia/qlogic_stub.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/ioport.h>\n#include <asm/io.h>\n#include <linux/major.h>\n#include <linux/blkdev.h>\n#include <linux/interrupt.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_ioctl.h>\n#include <scsi/scsi_tcq.h>\n#include \"../qlogicfas408.h\"\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ds.h>\n#include <pcmcia/ciscode.h>\n\n \n#define INT_TYPE\t0\n\nstatic char qlogic_name[] = \"qlogic_cs\";\n\nstatic struct scsi_host_template qlogicfas_driver_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= qlogic_name,\n\t.proc_name\t\t= qlogic_name,\n\t.info\t\t\t= qlogicfas408_info,\n\t.queuecommand\t\t= qlogicfas408_queuecommand,\n\t.eh_abort_handler\t= qlogicfas408_abort,\n\t.eh_host_reset_handler\t= qlogicfas408_host_reset,\n\t.bios_param\t\t= qlogicfas408_biosparam,\n\t.can_queue\t\t= 1,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n};\n\n \n\ntypedef struct scsi_info_t {\n\tstruct pcmcia_device\t*p_dev;\n\tstruct Scsi_Host *host;\n\tunsigned short manf_id;\n} scsi_info_t;\n\nstatic void qlogic_release(struct pcmcia_device *link);\nstatic void qlogic_detach(struct pcmcia_device *p_dev);\nstatic int qlogic_config(struct pcmcia_device * link);\n\nstatic struct Scsi_Host *qlogic_detect(struct scsi_host_template *host,\n\t\t\t\tstruct pcmcia_device *link, int qbase, int qlirq)\n{\n\tint qltyp;\t\t \n\tint qinitid;\n\tstruct Scsi_Host *shost;\t \n\tstruct qlogicfas408_priv *priv;\n\n\tqltyp = qlogicfas408_get_chip_type(qbase, INT_TYPE);\n\tqinitid = host->this_id;\n\tif (qinitid < 0)\n\t\tqinitid = 7;\t \n\n\tqlogicfas408_setup(qbase, qinitid, INT_TYPE);\n\n\thost->name = qlogic_name;\n\tshost = scsi_host_alloc(host, sizeof(struct qlogicfas408_priv));\n\tif (!shost)\n\t\tgoto err;\n\tshost->io_port = qbase;\n\tshost->n_io_port = 16;\n\tshost->dma_channel = -1;\n\tif (qlirq != -1)\n\t\tshost->irq = qlirq;\n\n\tpriv = get_priv_by_host(shost);\n\tpriv->qlirq = qlirq;\n\tpriv->qbase = qbase;\n\tpriv->qinitid = qinitid;\n\tpriv->shost = shost;\n\tpriv->int_type = INT_TYPE;\t\t\t\t\t\n\n\tif (request_irq(qlirq, qlogicfas408_ihandl, 0, qlogic_name, shost))\n\t\tgoto free_scsi_host;\n\n\tsprintf(priv->qinfo,\n\t\t\"Qlogicfas Driver version 0.46, chip %02X at %03X, IRQ %d, TPdma:%d\",\n\t\tqltyp, qbase, qlirq, QL_TURBO_PDMA);\n\n\tif (scsi_add_host(shost, NULL))\n\t\tgoto free_interrupt;\n\n\tscsi_scan_host(shost);\n\n\treturn shost;\n\nfree_interrupt:\n\tfree_irq(qlirq, shost);\n\nfree_scsi_host:\n\tscsi_host_put(shost);\n\t\nerr:\n\treturn NULL;\n}\nstatic int qlogic_probe(struct pcmcia_device *link)\n{\n\tscsi_info_t *info;\n\n\tdev_dbg(&link->dev, \"qlogic_attach()\\n\");\n\n\t \n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->p_dev = link;\n\tlink->priv = info;\n\tlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\n\tlink->config_regs = PRESENT_OPTION;\n\n\treturn qlogic_config(link);\n}\t\t\t\t \n\n \n\nstatic void qlogic_detach(struct pcmcia_device *link)\n{\n\tdev_dbg(&link->dev, \"qlogic_detach\\n\");\n\n\tqlogic_release(link);\n\tkfree(link->priv);\n\n}\t\t\t\t \n\n \n\nstatic int qlogic_config_check(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tp_dev->io_lines = 10;\n\tp_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\n\n\tif (p_dev->resource[0]->start == 0)\n\t\treturn -ENODEV;\n\n\treturn pcmcia_request_io(p_dev);\n}\n\nstatic int qlogic_config(struct pcmcia_device * link)\n{\n\tscsi_info_t *info = link->priv;\n\tint ret;\n\tstruct Scsi_Host *host;\n\n\tdev_dbg(&link->dev, \"qlogic_config\\n\");\n\n\tret = pcmcia_loop_config(link, qlogic_config_check, NULL);\n\tif (ret)\n\t\tgoto failed;\n\n\tif (!link->irq)\n\t\tgoto failed;\n\n\tret = pcmcia_enable_device(link);\n\tif (ret)\n\t\tgoto failed;\n\n\tif ((info->manf_id == MANFID_MACNICA) || (info->manf_id == MANFID_PIONEER) || (info->manf_id == 0x0098)) {\n\t\t \n\t\toutb(0xb4, link->resource[0]->start + 0xd);\n\t\toutb(0x24, link->resource[0]->start + 0x9);\n\t\toutb(0x04, link->resource[0]->start + 0xd);\n\t}\n\n\t \n\tif (resource_size(link->resource[0]) == 32)\n\t\thost = qlogic_detect(&qlogicfas_driver_template, link,\n\t\t\tlink->resource[0]->start + 16, link->irq);\n\telse\n\t\thost = qlogic_detect(&qlogicfas_driver_template, link,\n\t\t\tlink->resource[0]->start, link->irq);\n\t\n\tif (!host) {\n\t\tprintk(KERN_INFO \"%s: no SCSI devices found\\n\", qlogic_name);\n\t\tgoto failed;\n\t}\n\n\tinfo->host = host;\n\n\treturn 0;\n\nfailed:\n\tpcmcia_disable_device(link);\n\treturn -ENODEV;\n}\t\t\t\t \n\n \n\nstatic void qlogic_release(struct pcmcia_device *link)\n{\n\tscsi_info_t *info = link->priv;\n\n\tdev_dbg(&link->dev, \"qlogic_release\\n\");\n\n\tscsi_remove_host(info->host);\n\n\tfree_irq(link->irq, info->host);\n\tpcmcia_disable_device(link);\n\n\tscsi_host_put(info->host);\n}\n\n \n\nstatic int qlogic_resume(struct pcmcia_device *link)\n{\n\tscsi_info_t *info = link->priv;\n\tint ret;\n\n\tret = pcmcia_enable_device(link);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((info->manf_id == MANFID_MACNICA) ||\n\t    (info->manf_id == MANFID_PIONEER) ||\n\t    (info->manf_id == 0x0098)) {\n\t\toutb(0x80, link->resource[0]->start + 0xd);\n\t\toutb(0x24, link->resource[0]->start + 0x9);\n\t\toutb(0x04, link->resource[0]->start + 0xd);\n\t}\n\t \n\tqlogicfas408_host_reset(NULL);\n\n\treturn 0;\n}\n\nstatic const struct pcmcia_device_id qlogic_ids[] = {\n\tPCMCIA_DEVICE_PROD_ID12(\"EIger Labs\", \"PCMCIA-to-SCSI Adapter\", 0x88395fa7, 0x33b7a5e6),\n\tPCMCIA_DEVICE_PROD_ID12(\"EPSON\", \"SCSI-2 PC Card SC200\", 0xd361772f, 0x299d1751),\n\tPCMCIA_DEVICE_PROD_ID12(\"MACNICA\", \"MIRACLE SCSI-II mPS110\", 0x20841b68, 0xab3c3b6d),\n\tPCMCIA_DEVICE_PROD_ID12(\"MIDORI ELECTRONICS \", \"CN-SC43\", 0x6534382a, 0xd67eee79),\n\tPCMCIA_DEVICE_PROD_ID12(\"NEC\", \"PC-9801N-J03R\", 0x18df0ba0, 0x24662e8a),\n\tPCMCIA_DEVICE_PROD_ID12(\"KME \", \"KXLC003\", 0x82375a27, 0xf68e5bf7),\n\tPCMCIA_DEVICE_PROD_ID12(\"KME \", \"KXLC004\", 0x82375a27, 0x68eace54),\n\tPCMCIA_DEVICE_PROD_ID12(\"KME\", \"KXLC101\", 0x3faee676, 0x194250ec),\n\tPCMCIA_DEVICE_PROD_ID12(\"QLOGIC CORPORATION\", \"pc05\", 0xd77b2930, 0xa85b2735),\n\tPCMCIA_DEVICE_PROD_ID12(\"QLOGIC CORPORATION\", \"pc05 rev 1.10\", 0xd77b2930, 0x70f8b5f8),\n\tPCMCIA_DEVICE_PROD_ID123(\"KME\", \"KXLC002\", \"00\", 0x3faee676, 0x81896b61, 0xf99f065f),\n\tPCMCIA_DEVICE_PROD_ID12(\"RATOC System Inc.\", \"SCSI2 CARD 37\", 0x85c10e17, 0x1a2640c1),\n\tPCMCIA_DEVICE_PROD_ID12(\"TOSHIBA\", \"SCSC200A PC CARD SCSI\", 0xb4585a1a, 0xa6f06ebe),\n\tPCMCIA_DEVICE_PROD_ID12(\"TOSHIBA\", \"SCSC200B PC CARD SCSI-10\", 0xb4585a1a, 0x0a88dea0),\n\t \n\t \n\t \n\tPCMCIA_DEVICE_NULL,\n};\nMODULE_DEVICE_TABLE(pcmcia, qlogic_ids);\n\nstatic struct pcmcia_driver qlogic_cs_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"qlogic_cs\",\n\t.probe\t\t= qlogic_probe,\n\t.remove\t\t= qlogic_detach,\n\t.id_table       = qlogic_ids,\n\t.resume\t\t= qlogic_resume,\n};\n\nMODULE_AUTHOR(\"Tom Zerucha, Michael Griffith\");\nMODULE_DESCRIPTION(\"Driver for the PCMCIA Qlogic FAS SCSI controllers\");\nMODULE_LICENSE(\"GPL\");\nmodule_pcmcia_driver(qlogic_cs_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}