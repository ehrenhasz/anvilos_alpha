{
  "module_name": "scsi_proc.c",
  "hash_id": "74beb3b91744acf494b471599fa0b573165a7bb028eb0bb91d96e6a3f02e2267",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_proc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/errno.h>\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport.h>\n\n#include \"scsi_priv.h\"\n#include \"scsi_logging.h\"\n\n\n \n#define PROC_BLOCK_SIZE (3*1024)\n\nstatic struct proc_dir_entry *proc_scsi;\n\n \nstatic DEFINE_MUTEX(global_host_template_mutex);\nstatic LIST_HEAD(scsi_proc_list);\n\n \nstruct scsi_proc_entry {\n\tstruct list_head\tentry;\n\tconst struct scsi_host_template *sht;\n\tstruct proc_dir_entry\t*proc_dir;\n\tunsigned int\t\tpresent;\n};\n\nstatic ssize_t proc_scsi_host_write(struct file *file, const char __user *buf,\n                           size_t count, loff_t *ppos)\n{\n\tstruct Scsi_Host *shost = pde_data(file_inode(file));\n\tssize_t ret = -ENOMEM;\n\tchar *page;\n    \n\tif (count > PROC_BLOCK_SIZE)\n\t\treturn -EOVERFLOW;\n\n\tif (!shost->hostt->write_info)\n\t\treturn -EINVAL;\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (page) {\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(page, buf, count))\n\t\t\tgoto out;\n\t\tret = shost->hostt->write_info(shost, page, count);\n\t}\nout:\n\tfree_page((unsigned long)page);\n\treturn ret;\n}\n\nstatic int proc_scsi_show(struct seq_file *m, void *v)\n{\n\tstruct Scsi_Host *shost = m->private;\n\treturn shost->hostt->show_info(m, shost);\n}\n\nstatic int proc_scsi_host_open(struct inode *inode, struct file *file)\n{\n\treturn single_open_size(file, proc_scsi_show, pde_data(inode),\n\t\t\t\t4 * PAGE_SIZE);\n}\n\nstatic struct scsi_proc_entry *\n__scsi_lookup_proc_entry(const struct scsi_host_template *sht)\n{\n\tstruct scsi_proc_entry *e;\n\n\tlockdep_assert_held(&global_host_template_mutex);\n\n\tlist_for_each_entry(e, &scsi_proc_list, entry)\n\t\tif (e->sht == sht)\n\t\t\treturn e;\n\n\treturn NULL;\n}\n\nstatic struct scsi_proc_entry *\nscsi_lookup_proc_entry(const struct scsi_host_template *sht)\n{\n\tstruct scsi_proc_entry *e;\n\n\tmutex_lock(&global_host_template_mutex);\n\te = __scsi_lookup_proc_entry(sht);\n\tmutex_unlock(&global_host_template_mutex);\n\n\treturn e;\n}\n\n \nstruct proc_dir_entry *\nscsi_template_proc_dir(const struct scsi_host_template *sht)\n{\n\tstruct scsi_proc_entry *e = scsi_lookup_proc_entry(sht);\n\n\treturn e ? e->proc_dir : NULL;\n}\nEXPORT_SYMBOL_GPL(scsi_template_proc_dir);\n\nstatic const struct proc_ops proc_scsi_ops = {\n\t.proc_open\t= proc_scsi_host_open,\n\t.proc_release\t= single_release,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= proc_scsi_host_write\n};\n\n \nint scsi_proc_hostdir_add(const struct scsi_host_template *sht)\n{\n\tstruct scsi_proc_entry *e;\n\tint ret;\n\n\tif (!sht->show_info)\n\t\treturn 0;\n\n\tmutex_lock(&global_host_template_mutex);\n\te = __scsi_lookup_proc_entry(sht);\n\tif (!e) {\n\t\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\t\tif (!e) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tif (e->present++)\n\t\tgoto success;\n\te->proc_dir = proc_mkdir(sht->proc_name, proc_scsi);\n\tif (!e->proc_dir) {\n\t\tprintk(KERN_ERR \"%s: proc_mkdir failed for %s\\n\", __func__,\n\t\t       sht->proc_name);\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\te->sht = sht;\n\tlist_add_tail(&e->entry, &scsi_proc_list);\nsuccess:\n\te = NULL;\n\tret = 0;\nunlock:\n\tmutex_unlock(&global_host_template_mutex);\n\n\tkfree(e);\n\treturn ret;\n}\n\n \nvoid scsi_proc_hostdir_rm(const struct scsi_host_template *sht)\n{\n\tstruct scsi_proc_entry *e;\n\n\tif (!sht->show_info)\n\t\treturn;\n\n\tmutex_lock(&global_host_template_mutex);\n\te = __scsi_lookup_proc_entry(sht);\n\tif (e && !--e->present) {\n\t\tremove_proc_entry(sht->proc_name, proc_scsi);\n\t\tlist_del(&e->entry);\n\t\tkfree(e);\n\t}\n\tmutex_unlock(&global_host_template_mutex);\n}\n\n\n \nvoid scsi_proc_host_add(struct Scsi_Host *shost)\n{\n\tconst struct scsi_host_template *sht = shost->hostt;\n\tstruct scsi_proc_entry *e;\n\tstruct proc_dir_entry *p;\n\tchar name[10];\n\n\tif (!sht->show_info)\n\t\treturn;\n\n\te = scsi_lookup_proc_entry(sht);\n\tif (!e)\n\t\tgoto err;\n\n\tsprintf(name,\"%d\", shost->host_no);\n\tp = proc_create_data(name, S_IRUGO | S_IWUSR, e->proc_dir,\n\t\t\t     &proc_scsi_ops, shost);\n\tif (!p)\n\t\tgoto err;\n\treturn;\n\nerr:\n\tshost_printk(KERN_ERR, shost,\n\t\t     \"%s: Failed to register host (%s failed)\\n\", __func__,\n\t\t     e ? \"proc_create_data()\" : \"scsi_proc_hostdir_add()\");\n}\n\n \nvoid scsi_proc_host_rm(struct Scsi_Host *shost)\n{\n\tconst struct scsi_host_template *sht = shost->hostt;\n\tstruct scsi_proc_entry *e;\n\tchar name[10];\n\n\tif (!sht->show_info)\n\t\treturn;\n\n\te = scsi_lookup_proc_entry(sht);\n\tif (!e)\n\t\treturn;\n\n\tsprintf(name,\"%d\", shost->host_no);\n\tremove_proc_entry(name, e->proc_dir);\n}\n \nstatic int proc_print_scsidevice(struct device *dev, void *data)\n{\n\tstruct scsi_device *sdev;\n\tstruct seq_file *s = data;\n\tint i;\n\n\tif (!scsi_is_sdev_device(dev))\n\t\tgoto out;\n\n\tsdev = to_scsi_device(dev);\n\tseq_printf(s,\n\t\t\"Host: scsi%d Channel: %02d Id: %02d Lun: %02llu\\n  Vendor: \",\n\t\tsdev->host->host_no, sdev->channel, sdev->id, sdev->lun);\n\tfor (i = 0; i < 8; i++) {\n\t\tif (sdev->vendor[i] >= 0x20)\n\t\t\tseq_putc(s, sdev->vendor[i]);\n\t\telse\n\t\t\tseq_putc(s, ' ');\n\t}\n\n\tseq_puts(s, \" Model: \");\n\tfor (i = 0; i < 16; i++) {\n\t\tif (sdev->model[i] >= 0x20)\n\t\t\tseq_putc(s, sdev->model[i]);\n\t\telse\n\t\t\tseq_putc(s, ' ');\n\t}\n\n\tseq_puts(s, \" Rev: \");\n\tfor (i = 0; i < 4; i++) {\n\t\tif (sdev->rev[i] >= 0x20)\n\t\t\tseq_putc(s, sdev->rev[i]);\n\t\telse\n\t\t\tseq_putc(s, ' ');\n\t}\n\n\tseq_putc(s, '\\n');\n\n\tseq_printf(s, \"  Type:   %s \", scsi_device_type(sdev->type));\n\tseq_printf(s, \"               ANSI  SCSI revision: %02x\",\n\t\t\tsdev->scsi_level - (sdev->scsi_level > 1));\n\tif (sdev->scsi_level == 2)\n\t\tseq_puts(s, \" CCS\\n\");\n\telse\n\t\tseq_putc(s, '\\n');\n\nout:\n\treturn 0;\n}\n\n \n\nstatic int scsi_add_single_device(uint host, uint channel, uint id, uint lun)\n{\n\tstruct Scsi_Host *shost;\n\tint error = -ENXIO;\n\n\tshost = scsi_host_lookup(host);\n\tif (!shost)\n\t\treturn error;\n\n\tif (shost->transportt->user_scan)\n\t\terror = shost->transportt->user_scan(shost, channel, id, lun);\n\telse\n\t\terror = scsi_scan_host_selected(shost, channel, id, lun,\n\t\t\t\t\t\tSCSI_SCAN_MANUAL);\n\tscsi_host_put(shost);\n\treturn error;\n}\n\n \nstatic int scsi_remove_single_device(uint host, uint channel, uint id, uint lun)\n{\n\tstruct scsi_device *sdev;\n\tstruct Scsi_Host *shost;\n\tint error = -ENXIO;\n\n\tshost = scsi_host_lookup(host);\n\tif (!shost)\n\t\treturn error;\n\tsdev = scsi_device_lookup(shost, channel, id, lun);\n\tif (sdev) {\n\t\tscsi_remove_device(sdev);\n\t\tscsi_device_put(sdev);\n\t\terror = 0;\n\t}\n\n\tscsi_host_put(shost);\n\treturn error;\n}\n\n \n\n\nstatic ssize_t proc_scsi_write(struct file *file, const char __user *buf,\n\t\t\t       size_t length, loff_t *ppos)\n{\n\tint host, channel, id, lun;\n\tchar *buffer, *end, *p;\n\tint err;\n\n\tif (!buf || length > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuffer = (char *)__get_free_page(GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\terr = -EFAULT;\n\tif (copy_from_user(buffer, buf, length))\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif (length < PAGE_SIZE) {\n\t\tend = buffer + length;\n\t\t*end = '\\0';\n\t} else {\n\t\tend = buffer + PAGE_SIZE - 1;\n\t\tif (*end)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (!strncmp(\"scsi add-single-device\", buffer, 22)) {\n\t\tp = buffer + 23;\n\n\t\thost    = (p     < end) ? simple_strtoul(p, &p, 0) : 0;\n\t\tchannel = (p + 1 < end) ? simple_strtoul(p + 1, &p, 0) : 0;\n\t\tid      = (p + 1 < end) ? simple_strtoul(p + 1, &p, 0) : 0;\n\t\tlun     = (p + 1 < end) ? simple_strtoul(p + 1, &p, 0) : 0;\n\n\t\terr = scsi_add_single_device(host, channel, id, lun);\n\n\t \n\t} else if (!strncmp(\"scsi remove-single-device\", buffer, 25)) {\n\t\tp = buffer + 26;\n\n\t\thost    = (p     < end) ? simple_strtoul(p, &p, 0) : 0;\n\t\tchannel = (p + 1 < end) ? simple_strtoul(p + 1, &p, 0) : 0;\n\t\tid      = (p + 1 < end) ? simple_strtoul(p + 1, &p, 0) : 0;\n\t\tlun     = (p + 1 < end) ? simple_strtoul(p + 1, &p, 0) : 0;\n\n\t\terr = scsi_remove_single_device(host, channel, id, lun);\n\t}\n\n\t \n\tif (!err)\n\t\terr = length;\n\n out:\n\tfree_page((unsigned long)buffer);\n\treturn err;\n}\n\nstatic inline struct device *next_scsi_device(struct device *start)\n{\n\tstruct device *next = bus_find_next_device(&scsi_bus_type, start);\n\n\tput_device(start);\n\treturn next;\n}\n\nstatic void *scsi_seq_start(struct seq_file *sfile, loff_t *pos)\n{\n\tstruct device *dev = NULL;\n\tloff_t n = *pos;\n\n\twhile ((dev = next_scsi_device(dev))) {\n\t\tif (!n--)\n\t\t\tbreak;\n\t\tsfile->private++;\n\t}\n\treturn dev;\n}\n\nstatic void *scsi_seq_next(struct seq_file *sfile, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\tsfile->private++;\n\treturn next_scsi_device(v);\n}\n\nstatic void scsi_seq_stop(struct seq_file *sfile, void *v)\n{\n\tput_device(v);\n}\n\nstatic int scsi_seq_show(struct seq_file *sfile, void *dev)\n{\n\tif (!sfile->private)\n\t\tseq_puts(sfile, \"Attached devices:\\n\");\n\n\treturn proc_print_scsidevice(dev, sfile);\n}\n\nstatic const struct seq_operations scsi_seq_ops = {\n\t.start\t= scsi_seq_start,\n\t.next\t= scsi_seq_next,\n\t.stop\t= scsi_seq_stop,\n\t.show\t= scsi_seq_show\n};\n\n \nstatic int proc_scsi_open(struct inode *inode, struct file *file)\n{\n\t \n\treturn seq_open(file, &scsi_seq_ops);\n}\n\nstatic const struct proc_ops scsi_scsi_proc_ops = {\n\t.proc_open\t= proc_scsi_open,\n\t.proc_read\t= seq_read,\n\t.proc_write\t= proc_scsi_write,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= seq_release,\n};\n\n \nint __init scsi_init_procfs(void)\n{\n\tstruct proc_dir_entry *pde;\n\n\tproc_scsi = proc_mkdir(\"scsi\", NULL);\n\tif (!proc_scsi)\n\t\tgoto err1;\n\n\tpde = proc_create(\"scsi/scsi\", 0, NULL, &scsi_scsi_proc_ops);\n\tif (!pde)\n\t\tgoto err2;\n\n\treturn 0;\n\nerr2:\n\tremove_proc_entry(\"scsi\", NULL);\nerr1:\n\treturn -ENOMEM;\n}\n\n \nvoid scsi_exit_procfs(void)\n{\n\tremove_proc_entry(\"scsi/scsi\", NULL);\n\tremove_proc_entry(\"scsi\", NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}