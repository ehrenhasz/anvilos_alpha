{
  "module_name": "zorro_esp.c",
  "hash_id": "9d89520d8fa403bdf528af0ebb0801e5c97065f41c195203e856ae0cb7360b45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/zorro_esp.c",
  "human_readable_source": "\n \n \n \n\n#define pr_fmt(fmt)        KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/delay.h>\n#include <linux/zorro.h>\n#include <linux/slab.h>\n#include <linux/pgtable.h>\n\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/amigahw.h>\n#include <asm/amigaints.h>\n\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_spi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_tcq.h>\n\n#include \"esp_scsi.h\"\n\nMODULE_AUTHOR(\"Michael Schmitz <schmitz@debian.org>\");\nMODULE_DESCRIPTION(\"Amiga Zorro NCR5C9x (ESP) driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n\n \n\nstruct blz1230_dma_registers {\n\tunsigned char dma_addr;\t\t \n\tunsigned char dmapad2[0x7fff];\n\tunsigned char dma_latch;\t \n};\n\n \n\nstruct blz1230II_dma_registers {\n\tunsigned char dma_addr;\t\t \n\tunsigned char dmapad2[0xf];\n\tunsigned char dma_latch;\t \n};\n\n \n\nstruct blz2060_dma_registers {\n\tunsigned char dma_led_ctrl;\t \n\tunsigned char dmapad1[0x0f];\n\tunsigned char dma_addr0;\t \n\tunsigned char dmapad2[0x03];\n\tunsigned char dma_addr1;\t \n\tunsigned char dmapad3[0x03];\n\tunsigned char dma_addr2;\t \n\tunsigned char dmapad4[0x03];\n\tunsigned char dma_addr3;\t \n};\n\n \n#define DMA_WRITE 0x80000000\n\n \n\nstruct cyber_dma_registers {\n\tunsigned char dma_addr0;\t \n\tunsigned char dmapad1[1];\n\tunsigned char dma_addr1;\t \n\tunsigned char dmapad2[1];\n\tunsigned char dma_addr2;\t \n\tunsigned char dmapad3[1];\n\tunsigned char dma_addr3;\t \n\tunsigned char dmapad4[0x3fb];\n\tunsigned char cond_reg;\t\t \n#define ctrl_reg  cond_reg\t\t \n};\n\n \n#define CYBER_DMA_WRITE  0x40\t \n#define CYBER_DMA_Z3     0x20\t \n\n \n#define CYBER_DMA_HNDL_INTR 0x80\t \n\n \nstruct cyberII_dma_registers {\n\tunsigned char cond_reg;\t\t \n#define ctrl_reg  cond_reg\t\t \n\tunsigned char dmapad4[0x3f];\n\tunsigned char dma_addr0;\t \n\tunsigned char dmapad1[3];\n\tunsigned char dma_addr1;\t \n\tunsigned char dmapad2[3];\n\tunsigned char dma_addr2;\t \n\tunsigned char dmapad3[3];\n\tunsigned char dma_addr3;\t \n};\n\n \n\nstruct fastlane_dma_registers {\n\tunsigned char cond_reg;\t\t \n#define ctrl_reg  cond_reg\t\t \n\tchar dmapad1[0x3f];\n\tunsigned char clear_strobe;\t \n};\n\n \n#define FASTLANE_ESP_ADDR\t0x1000001\n\n \n#define FASTLANE_DMA_MINT\t0x80\n#define FASTLANE_DMA_IACT\t0x40\n#define FASTLANE_DMA_CREQ\t0x20\n\n \n#define FASTLANE_DMA_FCODE\t0xa0\n#define FASTLANE_DMA_MASK\t0xf3\n#define FASTLANE_DMA_WRITE\t0x08\t \n#define FASTLANE_DMA_ENABLE\t0x04\t \n#define FASTLANE_DMA_EDI\t0x02\t \n#define FASTLANE_DMA_ESI\t0x01\t \n\n \nstruct zorro_esp_priv {\n\tstruct esp *esp;\t\t \n\tvoid __iomem *board_base;\t \n\tint zorro3;\t\t\t \n\tunsigned char ctrl_data;\t \n};\n\n \n\nstatic void zorro_esp_write8(struct esp *esp, u8 val, unsigned long reg)\n{\n\twriteb(val, esp->regs + (reg * 4UL));\n}\n\nstatic u8 zorro_esp_read8(struct esp *esp, unsigned long reg)\n{\n\treturn readb(esp->regs + (reg * 4UL));\n}\n\nstatic int zorro_esp_irq_pending(struct esp *esp)\n{\n\t \n\tif (zorro_esp_read8(esp, ESP_STATUS) & ESP_STAT_INTR)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int cyber_esp_irq_pending(struct esp *esp)\n{\n\tstruct cyber_dma_registers __iomem *dregs = esp->dma_regs;\n\tunsigned char dma_status = readb(&dregs->cond_reg);\n\n\t \n\treturn ((zorro_esp_read8(esp, ESP_STATUS) & ESP_STAT_INTR) &&\n\t\t(dma_status & CYBER_DMA_HNDL_INTR));\n}\n\nstatic int fastlane_esp_irq_pending(struct esp *esp)\n{\n\tstruct fastlane_dma_registers __iomem *dregs = esp->dma_regs;\n\tunsigned char dma_status;\n\n\tdma_status = readb(&dregs->cond_reg);\n\n\tif (dma_status & FASTLANE_DMA_IACT)\n\t\treturn 0;\t \n\n\t \n\treturn (\n\t   (dma_status & FASTLANE_DMA_CREQ) &&\n\t   (!(dma_status & FASTLANE_DMA_MINT)) &&\n\t   (zorro_esp_read8(esp, ESP_STATUS) & ESP_STAT_INTR));\n}\n\nstatic u32 zorro_esp_dma_length_limit(struct esp *esp, u32 dma_addr,\n\t\t\t\t\tu32 dma_len)\n{\n\treturn dma_len > (1U << 16) ? (1U << 16) : dma_len;\n}\n\nstatic u32 fastlane_esp_dma_length_limit(struct esp *esp, u32 dma_addr,\n\t\t\t\t\tu32 dma_len)\n{\n\t \n\treturn dma_len > 0xfffc ? 0xfffc : dma_len;\n}\n\nstatic void zorro_esp_reset_dma(struct esp *esp)\n{\n\t \n}\n\nstatic void zorro_esp_dma_drain(struct esp *esp)\n{\n\t \n}\n\nstatic void zorro_esp_dma_invalidate(struct esp *esp)\n{\n\t \n}\n\nstatic void fastlane_esp_dma_invalidate(struct esp *esp)\n{\n\tstruct zorro_esp_priv *zep = dev_get_drvdata(esp->dev);\n\tstruct fastlane_dma_registers __iomem *dregs = esp->dma_regs;\n\tunsigned char *ctrl_data = &zep->ctrl_data;\n\n\t*ctrl_data = (*ctrl_data & FASTLANE_DMA_MASK);\n\twriteb(0, &dregs->clear_strobe);\n\tz_writel(0, zep->board_base);\n}\n\n \n\nstatic void zorro_esp_send_blz1230_dma_cmd(struct esp *esp, u32 addr,\n\t\t\tu32 esp_count, u32 dma_count, int write, u8 cmd)\n{\n\tstruct blz1230_dma_registers __iomem *dregs = esp->dma_regs;\n\tu8 phase = esp->sreg & ESP_STAT_PMASK;\n\n\t \n\tif (phase == ESP_MIP && addr == esp->command_block_dma) {\n\t\tesp_send_pio_cmd(esp, (u32)esp->command_block, esp_count,\n\t\t\t\t dma_count, write, cmd);\n\t\treturn;\n\t}\n\n\t \n\tesp->send_cmd_error = 0;\n\tesp->send_cmd_residual = 0;\n\n\tif (write)\n\t\t \n\t\tdma_sync_single_for_device(esp->dev, addr, esp_count,\n\t\t\t\tDMA_FROM_DEVICE);\n\telse\n\t\t \n\t\tdma_sync_single_for_device(esp->dev, addr, esp_count,\n\t\t\t\tDMA_TO_DEVICE);\n\n\taddr >>= 1;\n\tif (write)\n\t\taddr &= ~(DMA_WRITE);\n\telse\n\t\taddr |= DMA_WRITE;\n\n\twriteb((addr >> 24) & 0xff, &dregs->dma_latch);\n\twriteb((addr >> 24) & 0xff, &dregs->dma_addr);\n\twriteb((addr >> 16) & 0xff, &dregs->dma_addr);\n\twriteb((addr >>  8) & 0xff, &dregs->dma_addr);\n\twriteb(addr & 0xff, &dregs->dma_addr);\n\n\tscsi_esp_cmd(esp, ESP_CMD_DMA);\n\tzorro_esp_write8(esp, (esp_count >> 0) & 0xff, ESP_TCLOW);\n\tzorro_esp_write8(esp, (esp_count >> 8) & 0xff, ESP_TCMED);\n\n\tscsi_esp_cmd(esp, cmd);\n}\n\n \n\nstatic void zorro_esp_send_blz1230II_dma_cmd(struct esp *esp, u32 addr,\n\t\t\tu32 esp_count, u32 dma_count, int write, u8 cmd)\n{\n\tstruct blz1230II_dma_registers __iomem *dregs = esp->dma_regs;\n\tu8 phase = esp->sreg & ESP_STAT_PMASK;\n\n\t \n\tif (phase == ESP_MIP && addr == esp->command_block_dma) {\n\t\tesp_send_pio_cmd(esp, (u32)esp->command_block, esp_count,\n\t\t\t\t dma_count, write, cmd);\n\t\treturn;\n\t}\n\n\tesp->send_cmd_error = 0;\n\tesp->send_cmd_residual = 0;\n\n\tif (write)\n\t\t \n\t\tdma_sync_single_for_device(esp->dev, addr, esp_count,\n\t\t\t\tDMA_FROM_DEVICE);\n\telse\n\t\t \n\t\tdma_sync_single_for_device(esp->dev, addr, esp_count,\n\t\t\t\tDMA_TO_DEVICE);\n\n\taddr >>= 1;\n\tif (write)\n\t\taddr &= ~(DMA_WRITE);\n\telse\n\t\taddr |= DMA_WRITE;\n\n\twriteb((addr >> 24) & 0xff, &dregs->dma_latch);\n\twriteb((addr >> 16) & 0xff, &dregs->dma_addr);\n\twriteb((addr >>  8) & 0xff, &dregs->dma_addr);\n\twriteb(addr & 0xff, &dregs->dma_addr);\n\n\tscsi_esp_cmd(esp, ESP_CMD_DMA);\n\tzorro_esp_write8(esp, (esp_count >> 0) & 0xff, ESP_TCLOW);\n\tzorro_esp_write8(esp, (esp_count >> 8) & 0xff, ESP_TCMED);\n\n\tscsi_esp_cmd(esp, cmd);\n}\n\n \n\nstatic void zorro_esp_send_blz2060_dma_cmd(struct esp *esp, u32 addr,\n\t\t\tu32 esp_count, u32 dma_count, int write, u8 cmd)\n{\n\tstruct blz2060_dma_registers __iomem *dregs = esp->dma_regs;\n\tu8 phase = esp->sreg & ESP_STAT_PMASK;\n\n\t \n\tif (phase == ESP_MIP && addr == esp->command_block_dma) {\n\t\tesp_send_pio_cmd(esp, (u32)esp->command_block, esp_count,\n\t\t\t\t dma_count, write, cmd);\n\t\treturn;\n\t}\n\n\tesp->send_cmd_error = 0;\n\tesp->send_cmd_residual = 0;\n\n\tif (write)\n\t\t \n\t\tdma_sync_single_for_device(esp->dev, addr, esp_count,\n\t\t\t\tDMA_FROM_DEVICE);\n\telse\n\t\t \n\t\tdma_sync_single_for_device(esp->dev, addr, esp_count,\n\t\t\t\tDMA_TO_DEVICE);\n\n\taddr >>= 1;\n\tif (write)\n\t\taddr &= ~(DMA_WRITE);\n\telse\n\t\taddr |= DMA_WRITE;\n\n\twriteb(addr & 0xff, &dregs->dma_addr3);\n\twriteb((addr >>  8) & 0xff, &dregs->dma_addr2);\n\twriteb((addr >> 16) & 0xff, &dregs->dma_addr1);\n\twriteb((addr >> 24) & 0xff, &dregs->dma_addr0);\n\n\tscsi_esp_cmd(esp, ESP_CMD_DMA);\n\tzorro_esp_write8(esp, (esp_count >> 0) & 0xff, ESP_TCLOW);\n\tzorro_esp_write8(esp, (esp_count >> 8) & 0xff, ESP_TCMED);\n\n\tscsi_esp_cmd(esp, cmd);\n}\n\n \n\nstatic void zorro_esp_send_cyber_dma_cmd(struct esp *esp, u32 addr,\n\t\t\tu32 esp_count, u32 dma_count, int write, u8 cmd)\n{\n\tstruct zorro_esp_priv *zep = dev_get_drvdata(esp->dev);\n\tstruct cyber_dma_registers __iomem *dregs = esp->dma_regs;\n\tu8 phase = esp->sreg & ESP_STAT_PMASK;\n\tunsigned char *ctrl_data = &zep->ctrl_data;\n\n\t \n\tif (phase == ESP_MIP && addr == esp->command_block_dma) {\n\t\tesp_send_pio_cmd(esp, (u32)esp->command_block, esp_count,\n\t\t\t\t dma_count, write, cmd);\n\t\treturn;\n\t}\n\n\tesp->send_cmd_error = 0;\n\tesp->send_cmd_residual = 0;\n\n\tzorro_esp_write8(esp, (esp_count >> 0) & 0xff, ESP_TCLOW);\n\tzorro_esp_write8(esp, (esp_count >> 8) & 0xff, ESP_TCMED);\n\n\tif (write) {\n\t\t \n\t\tdma_sync_single_for_device(esp->dev, addr, esp_count,\n\t\t\t\tDMA_FROM_DEVICE);\n\t\taddr &= ~(1);\n\t} else {\n\t\t \n\t\tdma_sync_single_for_device(esp->dev, addr, esp_count,\n\t\t\t\tDMA_TO_DEVICE);\n\t\taddr |= 1;\n\t}\n\n\twriteb((addr >> 24) & 0xff, &dregs->dma_addr0);\n\twriteb((addr >> 16) & 0xff, &dregs->dma_addr1);\n\twriteb((addr >>  8) & 0xff, &dregs->dma_addr2);\n\twriteb(addr & 0xff, &dregs->dma_addr3);\n\n\tif (write)\n\t\t*ctrl_data &= ~(CYBER_DMA_WRITE);\n\telse\n\t\t*ctrl_data |= CYBER_DMA_WRITE;\n\n\t*ctrl_data &= ~(CYBER_DMA_Z3);\t \n\n\twriteb(*ctrl_data, &dregs->ctrl_reg);\n\n\tscsi_esp_cmd(esp, cmd);\n}\n\n \n\nstatic void zorro_esp_send_cyberII_dma_cmd(struct esp *esp, u32 addr,\n\t\t\tu32 esp_count, u32 dma_count, int write, u8 cmd)\n{\n\tstruct cyberII_dma_registers __iomem *dregs = esp->dma_regs;\n\tu8 phase = esp->sreg & ESP_STAT_PMASK;\n\n\t \n\tif (phase == ESP_MIP && addr == esp->command_block_dma) {\n\t\tesp_send_pio_cmd(esp, (u32)esp->command_block, esp_count,\n\t\t\t\t dma_count, write, cmd);\n\t\treturn;\n\t}\n\n\tesp->send_cmd_error = 0;\n\tesp->send_cmd_residual = 0;\n\n\tzorro_esp_write8(esp, (esp_count >> 0) & 0xff, ESP_TCLOW);\n\tzorro_esp_write8(esp, (esp_count >> 8) & 0xff, ESP_TCMED);\n\n\tif (write) {\n\t\t \n\t\tdma_sync_single_for_device(esp->dev, addr, esp_count,\n\t\t\t\tDMA_FROM_DEVICE);\n\t\taddr &= ~(1);\n\t} else {\n\t\t \n\t\tdma_sync_single_for_device(esp->dev, addr, esp_count,\n\t\t\t\tDMA_TO_DEVICE);\n\t\taddr |= 1;\n\t}\n\n\twriteb((addr >> 24) & 0xff, &dregs->dma_addr0);\n\twriteb((addr >> 16) & 0xff, &dregs->dma_addr1);\n\twriteb((addr >>  8) & 0xff, &dregs->dma_addr2);\n\twriteb(addr & 0xff, &dregs->dma_addr3);\n\n\tscsi_esp_cmd(esp, cmd);\n}\n\n \n\nstatic void zorro_esp_send_fastlane_dma_cmd(struct esp *esp, u32 addr,\n\t\t\tu32 esp_count, u32 dma_count, int write, u8 cmd)\n{\n\tstruct zorro_esp_priv *zep = dev_get_drvdata(esp->dev);\n\tstruct fastlane_dma_registers __iomem *dregs = esp->dma_regs;\n\tu8 phase = esp->sreg & ESP_STAT_PMASK;\n\tunsigned char *ctrl_data = &zep->ctrl_data;\n\n\t \n\tif (phase == ESP_MIP && addr == esp->command_block_dma) {\n\t\tesp_send_pio_cmd(esp, (u32)esp->command_block, esp_count,\n\t\t\t\t dma_count, write, cmd);\n\t\treturn;\n\t}\n\n\tesp->send_cmd_error = 0;\n\tesp->send_cmd_residual = 0;\n\n\tzorro_esp_write8(esp, (esp_count >> 0) & 0xff, ESP_TCLOW);\n\tzorro_esp_write8(esp, (esp_count >> 8) & 0xff, ESP_TCMED);\n\n\tif (write) {\n\t\t \n\t\tdma_sync_single_for_device(esp->dev, addr, esp_count,\n\t\t\t\tDMA_FROM_DEVICE);\n\t\taddr &= ~(1);\n\t} else {\n\t\t \n\t\tdma_sync_single_for_device(esp->dev, addr, esp_count,\n\t\t\t\tDMA_TO_DEVICE);\n\t\taddr |= 1;\n\t}\n\n\twriteb(0, &dregs->clear_strobe);\n\tz_writel(addr, ((addr & 0x00ffffff) + zep->board_base));\n\n\tif (write) {\n\t\t*ctrl_data = (*ctrl_data & FASTLANE_DMA_MASK) |\n\t\t\t\tFASTLANE_DMA_ENABLE;\n\t} else {\n\t\t*ctrl_data = ((*ctrl_data & FASTLANE_DMA_MASK) |\n\t\t\t\tFASTLANE_DMA_ENABLE |\n\t\t\t\tFASTLANE_DMA_WRITE);\n\t}\n\n\twriteb(*ctrl_data, &dregs->ctrl_reg);\n\n\tscsi_esp_cmd(esp, cmd);\n}\n\nstatic int zorro_esp_dma_error(struct esp *esp)\n{\n\treturn esp->send_cmd_error;\n}\n\n \n\nstatic const struct esp_driver_ops blz1230_esp_ops = {\n\t.esp_write8\t\t= zorro_esp_write8,\n\t.esp_read8\t\t= zorro_esp_read8,\n\t.irq_pending\t\t= zorro_esp_irq_pending,\n\t.dma_length_limit\t= zorro_esp_dma_length_limit,\n\t.reset_dma\t\t= zorro_esp_reset_dma,\n\t.dma_drain\t\t= zorro_esp_dma_drain,\n\t.dma_invalidate\t\t= zorro_esp_dma_invalidate,\n\t.send_dma_cmd\t\t= zorro_esp_send_blz1230_dma_cmd,\n\t.dma_error\t\t= zorro_esp_dma_error,\n};\n\nstatic const struct esp_driver_ops blz1230II_esp_ops = {\n\t.esp_write8\t\t= zorro_esp_write8,\n\t.esp_read8\t\t= zorro_esp_read8,\n\t.irq_pending\t\t= zorro_esp_irq_pending,\n\t.dma_length_limit\t= zorro_esp_dma_length_limit,\n\t.reset_dma\t\t= zorro_esp_reset_dma,\n\t.dma_drain\t\t= zorro_esp_dma_drain,\n\t.dma_invalidate\t\t= zorro_esp_dma_invalidate,\n\t.send_dma_cmd\t\t= zorro_esp_send_blz1230II_dma_cmd,\n\t.dma_error\t\t= zorro_esp_dma_error,\n};\n\nstatic const struct esp_driver_ops blz2060_esp_ops = {\n\t.esp_write8\t\t= zorro_esp_write8,\n\t.esp_read8\t\t= zorro_esp_read8,\n\t.irq_pending\t\t= zorro_esp_irq_pending,\n\t.dma_length_limit\t= zorro_esp_dma_length_limit,\n\t.reset_dma\t\t= zorro_esp_reset_dma,\n\t.dma_drain\t\t= zorro_esp_dma_drain,\n\t.dma_invalidate\t\t= zorro_esp_dma_invalidate,\n\t.send_dma_cmd\t\t= zorro_esp_send_blz2060_dma_cmd,\n\t.dma_error\t\t= zorro_esp_dma_error,\n};\n\nstatic const struct esp_driver_ops cyber_esp_ops = {\n\t.esp_write8\t\t= zorro_esp_write8,\n\t.esp_read8\t\t= zorro_esp_read8,\n\t.irq_pending\t\t= cyber_esp_irq_pending,\n\t.dma_length_limit\t= zorro_esp_dma_length_limit,\n\t.reset_dma\t\t= zorro_esp_reset_dma,\n\t.dma_drain\t\t= zorro_esp_dma_drain,\n\t.dma_invalidate\t\t= zorro_esp_dma_invalidate,\n\t.send_dma_cmd\t\t= zorro_esp_send_cyber_dma_cmd,\n\t.dma_error\t\t= zorro_esp_dma_error,\n};\n\nstatic const struct esp_driver_ops cyberII_esp_ops = {\n\t.esp_write8\t\t= zorro_esp_write8,\n\t.esp_read8\t\t= zorro_esp_read8,\n\t.irq_pending\t\t= zorro_esp_irq_pending,\n\t.dma_length_limit\t= zorro_esp_dma_length_limit,\n\t.reset_dma\t\t= zorro_esp_reset_dma,\n\t.dma_drain\t\t= zorro_esp_dma_drain,\n\t.dma_invalidate\t\t= zorro_esp_dma_invalidate,\n\t.send_dma_cmd\t\t= zorro_esp_send_cyberII_dma_cmd,\n\t.dma_error\t\t= zorro_esp_dma_error,\n};\n\nstatic const struct esp_driver_ops fastlane_esp_ops = {\n\t.esp_write8\t\t= zorro_esp_write8,\n\t.esp_read8\t\t= zorro_esp_read8,\n\t.irq_pending\t\t= fastlane_esp_irq_pending,\n\t.dma_length_limit\t= fastlane_esp_dma_length_limit,\n\t.reset_dma\t\t= zorro_esp_reset_dma,\n\t.dma_drain\t\t= zorro_esp_dma_drain,\n\t.dma_invalidate\t\t= fastlane_esp_dma_invalidate,\n\t.send_dma_cmd\t\t= zorro_esp_send_fastlane_dma_cmd,\n\t.dma_error\t\t= zorro_esp_dma_error,\n};\n\n \n\nstruct zorro_driver_data {\n\tconst char *name;\n\tunsigned long offset;\n\tunsigned long dma_offset;\n\tint absolute;\t \n\tint scsi_option;\n\tconst struct esp_driver_ops *esp_ops;\n};\n\n \n\nenum {\n\tZORRO_BLZ1230,\n\tZORRO_BLZ1230II,\n\tZORRO_BLZ2060,\n\tZORRO_CYBER,\n\tZORRO_CYBERII,\n\tZORRO_FASTLANE,\n};\n\n \n\nstatic const struct zorro_driver_data zorro_esp_boards[] = {\n\t[ZORRO_BLZ1230] = {\n\t\t\t\t.name\t\t= \"Blizzard 1230\",\n\t\t\t\t.offset\t\t= 0x8000,\n\t\t\t\t.dma_offset\t= 0x10000,\n\t\t\t\t.scsi_option\t= 1,\n\t\t\t\t.esp_ops\t= &blz1230_esp_ops,\n\t},\n\t[ZORRO_BLZ1230II] = {\n\t\t\t\t.name\t\t= \"Blizzard 1230II\",\n\t\t\t\t.offset\t\t= 0x10000,\n\t\t\t\t.dma_offset\t= 0x10021,\n\t\t\t\t.scsi_option\t= 1,\n\t\t\t\t.esp_ops\t= &blz1230II_esp_ops,\n\t},\n\t[ZORRO_BLZ2060] = {\n\t\t\t\t.name\t\t= \"Blizzard 2060\",\n\t\t\t\t.offset\t\t= 0x1ff00,\n\t\t\t\t.dma_offset\t= 0x1ffe0,\n\t\t\t\t.esp_ops\t= &blz2060_esp_ops,\n\t},\n\t[ZORRO_CYBER] = {\n\t\t\t\t.name\t\t= \"CyberStormI\",\n\t\t\t\t.offset\t\t= 0xf400,\n\t\t\t\t.dma_offset\t= 0xf800,\n\t\t\t\t.esp_ops\t= &cyber_esp_ops,\n\t},\n\t[ZORRO_CYBERII] = {\n\t\t\t\t.name\t\t= \"CyberStormII\",\n\t\t\t\t.offset\t\t= 0x1ff03,\n\t\t\t\t.dma_offset\t= 0x1ff43,\n\t\t\t\t.scsi_option\t= 1,\n\t\t\t\t.esp_ops\t= &cyberII_esp_ops,\n\t},\n\t[ZORRO_FASTLANE] = {\n\t\t\t\t.name\t\t= \"Fastlane\",\n\t\t\t\t.offset\t\t= 0x1000001,\n\t\t\t\t.dma_offset\t= 0x1000041,\n\t\t\t\t.esp_ops\t= &fastlane_esp_ops,\n\t},\n};\n\nstatic const struct zorro_device_id zorro_esp_zorro_tbl[] = {\n\t{\t \n\t\t.id = ZORRO_ID(PHASE5, 0x11, 0),\n\t\t.driver_data = ZORRO_BLZ1230,\n\t},\n\t{\t \n\t\t.id = ZORRO_ID(PHASE5, 0x0B, 0),\n\t\t.driver_data = ZORRO_BLZ1230II,\n\t},\n\t{\t \n\t\t.id = ZORRO_ID(PHASE5, 0x18, 0),\n\t\t.driver_data = ZORRO_BLZ2060,\n\t},\n\t{\t \n\t\t.id = ZORRO_ID(PHASE5, 0x0C, 0),\n\t\t.driver_data = ZORRO_CYBER,\n\t},\n\t{\t \n\t\t.id = ZORRO_ID(PHASE5, 0x19, 0),\n\t\t.driver_data = ZORRO_CYBERII,\n\t},\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(zorro, zorro_esp_zorro_tbl);\n\nstatic int zorro_esp_probe(struct zorro_dev *z,\n\t\t\t\t       const struct zorro_device_id *ent)\n{\n\tconst struct scsi_host_template *tpnt = &scsi_esp_template;\n\tstruct Scsi_Host *host;\n\tstruct esp *esp;\n\tconst struct zorro_driver_data *zdd;\n\tstruct zorro_esp_priv *zep;\n\tunsigned long board, ioaddr, dmaaddr;\n\tint err;\n\n\tboard = zorro_resource_start(z);\n\tzdd = &zorro_esp_boards[ent->driver_data];\n\n\tpr_info(\"%s found at address 0x%lx.\\n\", zdd->name, board);\n\n\tzep = kzalloc(sizeof(*zep), GFP_KERNEL);\n\tif (!zep) {\n\t\tpr_err(\"Can't allocate device private data!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif ((z->rom.er_Type & ERT_TYPEMASK) == ERT_ZORROIII) {\n\t\tif (board > 0xffffff)\n\t\t\tzep->zorro3 = 1;\n\t} else {\n\t\t \n\t\tz->dev.coherent_dma_mask = DMA_BIT_MASK(32);\n\t}\n\n\t \n\tif (zep->zorro3 && ent->driver_data == ZORRO_BLZ1230II) {\n\t\tpr_info(\"%s at address 0x%lx is Fastlane Z3, fixing data!\\n\",\n\t\t\tzdd->name, board);\n\t\tzdd = &zorro_esp_boards[ZORRO_FASTLANE];\n\t}\n\n\tif (zdd->absolute) {\n\t\tioaddr  = zdd->offset;\n\t\tdmaaddr = zdd->dma_offset;\n\t} else {\n\t\tioaddr  = board + zdd->offset;\n\t\tdmaaddr = board + zdd->dma_offset;\n\t}\n\n\tif (!zorro_request_device(z, zdd->name)) {\n\t\tpr_err(\"cannot reserve region 0x%lx, abort\\n\",\n\t\t       board);\n\t\terr = -EBUSY;\n\t\tgoto fail_free_zep;\n\t}\n\n\thost = scsi_host_alloc(tpnt, sizeof(struct esp));\n\n\tif (!host) {\n\t\tpr_err(\"No host detected; board configuration problem?\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail_release_device;\n\t}\n\n\thost->base\t\t= ioaddr;\n\thost->this_id\t\t= 7;\n\n\tesp\t\t\t= shost_priv(host);\n\tesp->host\t\t= host;\n\tesp->dev\t\t= &z->dev;\n\n\tesp->scsi_id\t\t= host->this_id;\n\tesp->scsi_id_mask\t= (1 << esp->scsi_id);\n\n\tesp->cfreq = 40000000;\n\n\tzep->esp = esp;\n\n\tdev_set_drvdata(esp->dev, zep);\n\n\t \n\tif (zep->zorro3 && ent->driver_data == ZORRO_BLZ1230II) {\n\t\t \n\t\tzep->board_base = ioremap(board, FASTLANE_ESP_ADDR - 1);\n\t\tif (!zep->board_base) {\n\t\t\tpr_err(\"Cannot allocate board address space\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail_free_host;\n\t\t}\n\t\t \n\t\tzep->ctrl_data = (FASTLANE_DMA_FCODE |\n\t\t\t\t  FASTLANE_DMA_EDI | FASTLANE_DMA_ESI);\n\t}\n\n\tesp->ops = zdd->esp_ops;\n\n\tif (ioaddr > 0xffffff)\n\t\tesp->regs = ioremap(ioaddr, 0x20);\n\telse\n\t\t \n\t\tesp->regs = ZTWO_VADDR(ioaddr);\n\n\tif (!esp->regs) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_unmap_fastlane;\n\t}\n\n\tesp->fifo_reg = esp->regs + ESP_FDATA * 4;\n\n\t \n\tif (zdd->scsi_option) {\n\t\tzorro_esp_write8(esp, (ESP_CONFIG1_PENABLE | 7), ESP_CFG1);\n\t\tif (zorro_esp_read8(esp, ESP_CFG1) != (ESP_CONFIG1_PENABLE|7)) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto fail_unmap_regs;\n\t\t}\n\t}\n\n\tif (zep->zorro3) {\n\t\t \n\t\tesp->dma_regs = ioremap(dmaaddr,\n\t\t\t\t\tsizeof(struct fastlane_dma_registers));\n\t} else\n\t\t \n\t\tesp->dma_regs = ZTWO_VADDR(dmaaddr);\n\n\tif (!esp->dma_regs) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_unmap_regs;\n\t}\n\n\tesp->command_block = dma_alloc_coherent(esp->dev, 16,\n\t\t\t\t\t\t&esp->command_block_dma,\n\t\t\t\t\t\tGFP_KERNEL);\n\n\tif (!esp->command_block) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_unmap_dma_regs;\n\t}\n\n\thost->irq = IRQ_AMIGA_PORTS;\n\terr = request_irq(host->irq, scsi_esp_intr, IRQF_SHARED,\n\t\t\t  \"Amiga Zorro ESP\", esp);\n\tif (err < 0) {\n\t\terr = -ENODEV;\n\t\tgoto fail_free_command_block;\n\t}\n\n\t \n\terr = scsi_esp_register(esp);\n\n\tif (err) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_free_irq;\n\t}\n\n\treturn 0;\n\nfail_free_irq:\n\tfree_irq(host->irq, esp);\n\nfail_free_command_block:\n\tdma_free_coherent(esp->dev, 16,\n\t\t\t  esp->command_block,\n\t\t\t  esp->command_block_dma);\n\nfail_unmap_dma_regs:\n\tif (zep->zorro3)\n\t\tiounmap(esp->dma_regs);\n\nfail_unmap_regs:\n\tif (ioaddr > 0xffffff)\n\t\tiounmap(esp->regs);\n\nfail_unmap_fastlane:\n\tif (zep->zorro3)\n\t\tiounmap(zep->board_base);\n\nfail_free_host:\n\tscsi_host_put(host);\n\nfail_release_device:\n\tzorro_release_device(z);\n\nfail_free_zep:\n\tkfree(zep);\n\n\treturn err;\n}\n\nstatic void zorro_esp_remove(struct zorro_dev *z)\n{\n\tstruct zorro_esp_priv *zep = dev_get_drvdata(&z->dev);\n\tstruct esp *esp\t= zep->esp;\n\tstruct Scsi_Host *host = esp->host;\n\n\tscsi_esp_unregister(esp);\n\n\tfree_irq(host->irq, esp);\n\tdma_free_coherent(esp->dev, 16,\n\t\t\t  esp->command_block,\n\t\t\t  esp->command_block_dma);\n\n\tif (zep->zorro3) {\n\t\tiounmap(zep->board_base);\n\t\tiounmap(esp->dma_regs);\n\t}\n\n\tif (host->base > 0xffffff)\n\t\tiounmap(esp->regs);\n\n\tscsi_host_put(host);\n\n\tzorro_release_device(z);\n\n\tkfree(zep);\n}\n\nstatic struct zorro_driver zorro_esp_driver = {\n\t.name\t  = KBUILD_MODNAME,\n\t.id_table = zorro_esp_zorro_tbl,\n\t.probe\t  = zorro_esp_probe,\n\t.remove\t  = zorro_esp_remove,\n};\n\nstatic int __init zorro_esp_scsi_init(void)\n{\n\treturn zorro_register_driver(&zorro_esp_driver);\n}\n\nstatic void __exit zorro_esp_scsi_exit(void)\n{\n\tzorro_unregister_driver(&zorro_esp_driver);\n}\n\nmodule_init(zorro_esp_scsi_init);\nmodule_exit(zorro_esp_scsi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}