{
  "module_name": "am53c974.c",
  "hash_id": "e400b4c12cd329acc85a95f74b76521daf8178f360160e3c1086fda4da871a51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/am53c974.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n\n#include <scsi/scsi_host.h>\n\n#include \"esp_scsi.h\"\n\n#define DRV_MODULE_NAME \"am53c974\"\n#define DRV_MODULE_VERSION \"1.00\"\n\nstatic bool am53c974_debug;\nstatic bool am53c974_fenab = true;\n\n#define esp_dma_log(f, a...)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (am53c974_debug)\t\t\t\t\t\\\n\t\t\tshost_printk(KERN_DEBUG, esp->host, f, ##a);\t\\\n\t} while (0)\n\n#define ESP_DMA_CMD 0x10\n#define ESP_DMA_STC 0x11\n#define ESP_DMA_SPA 0x12\n#define ESP_DMA_WBC 0x13\n#define ESP_DMA_WAC 0x14\n#define ESP_DMA_STATUS 0x15\n#define ESP_DMA_SMDLA 0x16\n#define ESP_DMA_WMAC 0x17\n\n#define ESP_DMA_CMD_IDLE 0x00\n#define ESP_DMA_CMD_BLAST 0x01\n#define ESP_DMA_CMD_ABORT 0x02\n#define ESP_DMA_CMD_START 0x03\n#define ESP_DMA_CMD_MASK  0x03\n#define ESP_DMA_CMD_DIAG 0x04\n#define ESP_DMA_CMD_MDL 0x10\n#define ESP_DMA_CMD_INTE_P 0x20\n#define ESP_DMA_CMD_INTE_D 0x40\n#define ESP_DMA_CMD_DIR 0x80\n\n#define ESP_DMA_STAT_PWDN 0x01\n#define ESP_DMA_STAT_ERROR 0x02\n#define ESP_DMA_STAT_ABORT 0x04\n#define ESP_DMA_STAT_DONE 0x08\n#define ESP_DMA_STAT_SCSIINT 0x10\n#define ESP_DMA_STAT_BCMPLT 0x20\n\n \n#define DC390_EEPROM_READ 0x80\n#define DC390_EEPROM_LEN 0x40\n\n \n\n \n#define DC390_EE_MODE1 0x00\n#define DC390_EE_SPEED 0x01\n\n \n#define DC390_EE_ADAPT_SCSI_ID 0x40\n#define DC390_EE_MODE2 0x41\n#define DC390_EE_DELAY 0x42\n#define DC390_EE_TAG_CMD_NUM 0x43\n\n#define DC390_EE_MODE1_PARITY_CHK   0x01\n#define DC390_EE_MODE1_SYNC_NEGO    0x02\n#define DC390_EE_MODE1_EN_DISC      0x04\n#define DC390_EE_MODE1_SEND_START   0x08\n#define DC390_EE_MODE1_TCQ          0x10\n\n#define DC390_EE_MODE2_MORE_2DRV    0x01\n#define DC390_EE_MODE2_GREATER_1G   0x02\n#define DC390_EE_MODE2_RST_SCSI_BUS 0x04\n#define DC390_EE_MODE2_ACTIVE_NEGATION 0x08\n#define DC390_EE_MODE2_NO_SEEK      0x10\n#define DC390_EE_MODE2_LUN_CHECK    0x20\n\nstruct pci_esp_priv {\n\tstruct esp *esp;\n\tu8 dma_status;\n};\n\nstatic void pci_esp_dma_drain(struct esp *esp);\n\nstatic inline struct pci_esp_priv *pci_esp_get_priv(struct esp *esp)\n{\n\treturn dev_get_drvdata(esp->dev);\n}\n\nstatic void pci_esp_write8(struct esp *esp, u8 val, unsigned long reg)\n{\n\tiowrite8(val, esp->regs + (reg * 4UL));\n}\n\nstatic u8 pci_esp_read8(struct esp *esp, unsigned long reg)\n{\n\treturn ioread8(esp->regs + (reg * 4UL));\n}\n\nstatic void pci_esp_write32(struct esp *esp, u32 val, unsigned long reg)\n{\n\treturn iowrite32(val, esp->regs + (reg * 4UL));\n}\n\nstatic int pci_esp_irq_pending(struct esp *esp)\n{\n\tstruct pci_esp_priv *pep = pci_esp_get_priv(esp);\n\n\tpep->dma_status = pci_esp_read8(esp, ESP_DMA_STATUS);\n\tesp_dma_log(\"dma intr dreg[%02x]\\n\", pep->dma_status);\n\n\tif (pep->dma_status & (ESP_DMA_STAT_ERROR |\n\t\t\t       ESP_DMA_STAT_ABORT |\n\t\t\t       ESP_DMA_STAT_DONE |\n\t\t\t       ESP_DMA_STAT_SCSIINT))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void pci_esp_reset_dma(struct esp *esp)\n{\n\t \n}\n\nstatic void pci_esp_dma_drain(struct esp *esp)\n{\n\tu8 resid;\n\tint lim = 1000;\n\n\n\tif ((esp->sreg & ESP_STAT_PMASK) == ESP_DOP ||\n\t    (esp->sreg & ESP_STAT_PMASK) == ESP_DIP)\n\t\t \n\t\treturn;\n\n\twhile (--lim > 0) {\n\t\tresid = pci_esp_read8(esp, ESP_FFLAGS) & ESP_FF_FBYTES;\n\t\tif (resid <= 1)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\n\t \n\tlim = 1000;\n\tpci_esp_write8(esp, ESP_DMA_CMD_DIR | ESP_DMA_CMD_BLAST, ESP_DMA_CMD);\n\twhile (pci_esp_read8(esp, ESP_DMA_STATUS) & ESP_DMA_STAT_BCMPLT) {\n\t\tif (--lim == 0)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\tpci_esp_write8(esp, ESP_DMA_CMD_DIR | ESP_DMA_CMD_IDLE, ESP_DMA_CMD);\n\tesp_dma_log(\"DMA blast done (%d tries, %d bytes left)\\n\", lim, resid);\n\t \n\tif (WARN_ON_ONCE(resid == 1)) {\n\t\tstruct esp_cmd_entry *ent = esp->active_cmd;\n\n\t\tent->flags |= ESP_CMD_FLAG_RESIDUAL;\n\t}\n}\n\nstatic void pci_esp_dma_invalidate(struct esp *esp)\n{\n\tstruct pci_esp_priv *pep = pci_esp_get_priv(esp);\n\n\tesp_dma_log(\"invalidate DMA\\n\");\n\n\tpci_esp_write8(esp, ESP_DMA_CMD_IDLE, ESP_DMA_CMD);\n\tpep->dma_status = 0;\n}\n\nstatic int pci_esp_dma_error(struct esp *esp)\n{\n\tstruct pci_esp_priv *pep = pci_esp_get_priv(esp);\n\n\tif (pep->dma_status & ESP_DMA_STAT_ERROR) {\n\t\tu8 dma_cmd = pci_esp_read8(esp, ESP_DMA_CMD);\n\n\t\tif ((dma_cmd & ESP_DMA_CMD_MASK) == ESP_DMA_CMD_START)\n\t\t\tpci_esp_write8(esp, ESP_DMA_CMD_ABORT, ESP_DMA_CMD);\n\n\t\treturn 1;\n\t}\n\tif (pep->dma_status & ESP_DMA_STAT_ABORT) {\n\t\tpci_esp_write8(esp, ESP_DMA_CMD_IDLE, ESP_DMA_CMD);\n\t\tpep->dma_status = pci_esp_read8(esp, ESP_DMA_CMD);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void pci_esp_send_dma_cmd(struct esp *esp, u32 addr, u32 esp_count,\n\t\t\t\t u32 dma_count, int write, u8 cmd)\n{\n\tstruct pci_esp_priv *pep = pci_esp_get_priv(esp);\n\tu32 val = 0;\n\n\tBUG_ON(!(cmd & ESP_CMD_DMA));\n\n\tpep->dma_status = 0;\n\n\t \n\tif (write)\n\t\t \n\t\tval |= ESP_DMA_CMD_DIR;\n\tpci_esp_write8(esp, ESP_DMA_CMD_IDLE | val, ESP_DMA_CMD);\n\n\tpci_esp_write8(esp, (esp_count >> 0) & 0xff, ESP_TCLOW);\n\tpci_esp_write8(esp, (esp_count >> 8) & 0xff, ESP_TCMED);\n\tif (esp->config2 & ESP_CONFIG2_FENAB)\n\t\tpci_esp_write8(esp, (esp_count >> 16) & 0xff, ESP_TCHI);\n\n\tpci_esp_write32(esp, esp_count, ESP_DMA_STC);\n\tpci_esp_write32(esp, addr, ESP_DMA_SPA);\n\n\tesp_dma_log(\"start dma addr[%x] count[%d:%d]\\n\",\n\t\t    addr, esp_count, dma_count);\n\n\tscsi_esp_cmd(esp, cmd);\n\t \n\tpci_esp_write8(esp, ESP_DMA_CMD_START | val, ESP_DMA_CMD);\n}\n\nstatic u32 pci_esp_dma_length_limit(struct esp *esp, u32 dma_addr, u32 dma_len)\n{\n\tint dma_limit = 16;\n\tu32 base, end;\n\n\t \n\tif (esp->config2 & ESP_CONFIG2_FENAB)\n\t\tdma_limit = 24;\n\n\tif (dma_len > (1U << dma_limit))\n\t\tdma_len = (1U << dma_limit);\n\n\t \n\tbase = dma_addr & ((1U << 24) - 1U);\n\tend = base + dma_len;\n\tif (end > (1U << 24))\n\t\tend = (1U <<24);\n\tdma_len = end - base;\n\n\treturn dma_len;\n}\n\nstatic const struct esp_driver_ops pci_esp_ops = {\n\t.esp_write8\t=\tpci_esp_write8,\n\t.esp_read8\t=\tpci_esp_read8,\n\t.irq_pending\t=\tpci_esp_irq_pending,\n\t.reset_dma\t=\tpci_esp_reset_dma,\n\t.dma_drain\t=\tpci_esp_dma_drain,\n\t.dma_invalidate\t=\tpci_esp_dma_invalidate,\n\t.send_dma_cmd\t=\tpci_esp_send_dma_cmd,\n\t.dma_error\t=\tpci_esp_dma_error,\n\t.dma_length_limit =\tpci_esp_dma_length_limit,\n};\n\n \nstatic void dc390_eeprom_prepare_read(struct pci_dev *pdev, u8 cmd)\n{\n\tu8 carry_flag = 1, j = 0x80, bval;\n\tint i;\n\n\tfor (i = 0; i < 9; i++) {\n\t\tif (carry_flag) {\n\t\t\tpci_write_config_byte(pdev, 0x80, 0x40);\n\t\t\tbval = 0xc0;\n\t\t} else\n\t\t\tbval = 0x80;\n\n\t\tudelay(160);\n\t\tpci_write_config_byte(pdev, 0x80, bval);\n\t\tudelay(160);\n\t\tpci_write_config_byte(pdev, 0x80, 0);\n\t\tudelay(160);\n\n\t\tcarry_flag = (cmd & j) ? 1 : 0;\n\t\tj >>= 1;\n\t}\n}\n\nstatic u16 dc390_eeprom_get_data(struct pci_dev *pdev)\n{\n\tint i;\n\tu16 wval = 0;\n\tu8 bval;\n\n\tfor (i = 0; i < 16; i++) {\n\t\twval <<= 1;\n\n\t\tpci_write_config_byte(pdev, 0x80, 0x80);\n\t\tudelay(160);\n\t\tpci_write_config_byte(pdev, 0x80, 0x40);\n\t\tudelay(160);\n\t\tpci_read_config_byte(pdev, 0x00, &bval);\n\n\t\tif (bval == 0x22)\n\t\t\twval |= 1;\n\t}\n\n\treturn wval;\n}\n\nstatic void dc390_read_eeprom(struct pci_dev *pdev, u16 *ptr)\n{\n\tu8 cmd = DC390_EEPROM_READ, i;\n\n\tfor (i = 0; i < DC390_EEPROM_LEN; i++) {\n\t\tpci_write_config_byte(pdev, 0xc0, 0);\n\t\tudelay(160);\n\n\t\tdc390_eeprom_prepare_read(pdev, cmd++);\n\t\t*ptr++ = dc390_eeprom_get_data(pdev);\n\n\t\tpci_write_config_byte(pdev, 0x80, 0);\n\t\tpci_write_config_byte(pdev, 0x80, 0);\n\t\tudelay(160);\n\t}\n}\n\nstatic void dc390_check_eeprom(struct esp *esp)\n{\n\tstruct pci_dev *pdev = to_pci_dev(esp->dev);\n\tu8 EEbuf[128];\n\tu16 *ptr = (u16 *)EEbuf, wval = 0;\n\tint i;\n\n\tdc390_read_eeprom(pdev, ptr);\n\n\tfor (i = 0; i < DC390_EEPROM_LEN; i++, ptr++)\n\t\twval += *ptr;\n\n\t \n\tif (wval != 0x1234) {\n\t\tdev_printk(KERN_INFO, &pdev->dev,\n\t\t\t   \"No valid Tekram EEprom found\\n\");\n\t\treturn;\n\t}\n\tesp->scsi_id = EEbuf[DC390_EE_ADAPT_SCSI_ID];\n\tesp->num_tags = 2 << EEbuf[DC390_EE_TAG_CMD_NUM];\n\tif (EEbuf[DC390_EE_MODE2] & DC390_EE_MODE2_ACTIVE_NEGATION)\n\t\tesp->config4 |= ESP_CONFIG4_RADE | ESP_CONFIG4_RAE;\n}\n\nstatic int pci_esp_probe_one(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *id)\n{\n\tconst struct scsi_host_template *hostt = &scsi_esp_template;\n\tint err = -ENODEV;\n\tstruct Scsi_Host *shost;\n\tstruct esp *esp;\n\tstruct pci_esp_priv *pep;\n\n\tif (pci_enable_device(pdev)) {\n\t\tdev_printk(KERN_INFO, &pdev->dev, \"cannot enable device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tdev_printk(KERN_INFO, &pdev->dev,\n\t\t\t   \"failed to set 32bit DMA mask\\n\");\n\t\tgoto fail_disable_device;\n\t}\n\n\tshost = scsi_host_alloc(hostt, sizeof(struct esp));\n\tif (!shost) {\n\t\tdev_printk(KERN_INFO, &pdev->dev,\n\t\t\t   \"failed to allocate scsi host\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail_disable_device;\n\t}\n\n\tpep = kzalloc(sizeof(struct pci_esp_priv), GFP_KERNEL);\n\tif (!pep) {\n\t\tdev_printk(KERN_INFO, &pdev->dev,\n\t\t\t   \"failed to allocate esp_priv\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail_host_alloc;\n\t}\n\n\tesp = shost_priv(shost);\n\tesp->host = shost;\n\tesp->dev = &pdev->dev;\n\tesp->ops = &pci_esp_ops;\n\t \n\tesp->flags |= ESP_FLAG_USE_FIFO;\n\t \n\tif (am53c974_fenab)\n\t\tesp->config2 |= ESP_CONFIG2_FENAB;\n\n\tpep->esp = esp;\n\n\tif (pci_request_regions(pdev, DRV_MODULE_NAME)) {\n\t\tdev_printk(KERN_ERR, &pdev->dev,\n\t\t\t   \"pci memory selection failed\\n\");\n\t\tgoto fail_priv_alloc;\n\t}\n\n\tesp->regs = pci_iomap(pdev, 0, pci_resource_len(pdev, 0));\n\tif (!esp->regs) {\n\t\tdev_printk(KERN_ERR, &pdev->dev, \"pci I/O map failed\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail_release_regions;\n\t}\n\tesp->dma_regs = esp->regs;\n\n\tpci_set_master(pdev);\n\n\tesp->command_block = dma_alloc_coherent(&pdev->dev, 16,\n\t\t\t&esp->command_block_dma, GFP_KERNEL);\n\tif (!esp->command_block) {\n\t\tdev_printk(KERN_ERR, &pdev->dev,\n\t\t\t   \"failed to allocate command block\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail_unmap_regs;\n\t}\n\n\tpci_set_drvdata(pdev, pep);\n\n\terr = request_irq(pdev->irq, scsi_esp_intr, IRQF_SHARED,\n\t\t\t  DRV_MODULE_NAME, esp);\n\tif (err < 0) {\n\t\tdev_printk(KERN_ERR, &pdev->dev, \"failed to register IRQ\\n\");\n\t\tgoto fail_unmap_command_block;\n\t}\n\n\tesp->scsi_id = 7;\n\tdc390_check_eeprom(esp);\n\n\tshost->this_id = esp->scsi_id;\n\tshost->max_id = 8;\n\tshost->irq = pdev->irq;\n\tshost->io_port = pci_resource_start(pdev, 0);\n\tshost->n_io_port = pci_resource_len(pdev, 0);\n\tshost->unique_id = shost->io_port;\n\tesp->scsi_id_mask = (1 << esp->scsi_id);\n\t \n\tesp->cfreq = 40000000;\n\n\terr = scsi_esp_register(esp);\n\tif (err)\n\t\tgoto fail_free_irq;\n\n\treturn 0;\n\nfail_free_irq:\n\tfree_irq(pdev->irq, esp);\nfail_unmap_command_block:\n\tpci_set_drvdata(pdev, NULL);\n\tdma_free_coherent(&pdev->dev, 16, esp->command_block,\n\t\t\t  esp->command_block_dma);\nfail_unmap_regs:\n\tpci_iounmap(pdev, esp->regs);\nfail_release_regions:\n\tpci_release_regions(pdev);\nfail_priv_alloc:\n\tkfree(pep);\nfail_host_alloc:\n\tscsi_host_put(shost);\nfail_disable_device:\n\tpci_disable_device(pdev);\n\n\treturn err;\n}\n\nstatic void pci_esp_remove_one(struct pci_dev *pdev)\n{\n\tstruct pci_esp_priv *pep = pci_get_drvdata(pdev);\n\tstruct esp *esp = pep->esp;\n\n\tscsi_esp_unregister(esp);\n\tfree_irq(pdev->irq, esp);\n\tpci_set_drvdata(pdev, NULL);\n\tdma_free_coherent(&pdev->dev, 16, esp->command_block,\n\t\t\t  esp->command_block_dma);\n\tpci_iounmap(pdev, esp->regs);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tkfree(pep);\n\n\tscsi_host_put(esp->host);\n}\n\nstatic struct pci_device_id am53c974_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_SCSI,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, am53c974_pci_tbl);\n\nstatic struct pci_driver am53c974_driver = {\n\t.name           = DRV_MODULE_NAME,\n\t.id_table       = am53c974_pci_tbl,\n\t.probe          = pci_esp_probe_one,\n\t.remove         = pci_esp_remove_one,\n};\n\nmodule_pci_driver(am53c974_driver);\n\nMODULE_DESCRIPTION(\"AM53C974 SCSI driver\");\nMODULE_AUTHOR(\"Hannes Reinecke <hare@suse.de>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_MODULE_VERSION);\nMODULE_ALIAS(\"tmscsim\");\n\nmodule_param(am53c974_debug, bool, 0644);\nMODULE_PARM_DESC(am53c974_debug, \"Enable debugging\");\n\nmodule_param(am53c974_fenab, bool, 0444);\nMODULE_PARM_DESC(am53c974_fenab, \"Enable 24-bit DMA transfer sizes\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}