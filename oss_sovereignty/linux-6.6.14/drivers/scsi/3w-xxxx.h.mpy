{
  "module_name": "3w-xxxx.h",
  "hash_id": "8bf42171167bc0c5717c1605cfe2bf3155fe7f9b6750aac5fab140ef4955cf3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/3w-xxxx.h",
  "human_readable_source": " \n\n#ifndef _3W_XXXX_H\n#define _3W_XXXX_H\n\n#include <linux/types.h>\n\n \nstatic char *tw_aen_string[] = {\n\t[0x000] = \"INFO: AEN queue empty\",\n\t[0x001] = \"INFO: Soft reset occurred\",\n\t[0x002] = \"ERROR: Unit degraded: Unit #\",\n\t[0x003] = \"ERROR: Controller error\",\n\t[0x004] = \"ERROR: Rebuild failed: Unit #\",\n\t[0x005] = \"INFO: Rebuild complete: Unit #\",\n\t[0x006] = \"ERROR: Incomplete unit detected: Unit #\",\n\t[0x007] = \"INFO: Initialization complete: Unit #\",\n\t[0x008] = \"WARNING: Unclean shutdown detected: Unit #\",\n\t[0x009] = \"WARNING: ATA port timeout: Port #\",\n\t[0x00A] = \"ERROR: Drive error: Port #\",\n\t[0x00B] = \"INFO: Rebuild started: Unit #\",\n\t[0x00C] = \"INFO: Initialization started: Unit #\",\n\t[0x00D] = \"ERROR: Logical unit deleted: Unit #\",\n\t[0x00F] = \"WARNING: SMART threshold exceeded: Port #\",\n\t[0x021] = \"WARNING: ATA UDMA downgrade: Port #\",\n\t[0x022] = \"WARNING: ATA UDMA upgrade: Port #\",\n\t[0x023] = \"WARNING: Sector repair occurred: Port #\",\n\t[0x024] = \"ERROR: SBUF integrity check failure\",\n\t[0x025] = \"ERROR: Lost cached write: Port #\",\n\t[0x026] = \"ERROR: Drive ECC error detected: Port #\",\n\t[0x027] = \"ERROR: DCB checksum error: Port #\",\n\t[0x028] = \"ERROR: DCB unsupported version: Port #\",\n\t[0x029] = \"INFO: Verify started: Unit #\",\n\t[0x02A] = \"ERROR: Verify failed: Port #\",\n\t[0x02B] = \"INFO: Verify complete: Unit #\",\n\t[0x02C] = \"WARNING: Overwrote bad sector during rebuild: Port #\",\n\t[0x02D] = \"ERROR: Encountered bad sector during rebuild: Port #\",\n\t[0x02E] = \"ERROR: Replacement drive is too small: Port #\",\n\t[0x02F] = \"WARNING: Verify error: Unit not previously initialized: Unit #\",\n\t[0x030] = \"ERROR: Drive not supported: Port #\"\n};\n\n \nstatic unsigned char tw_sense_table[][4] =\n{\n   \n\t\n\t{0x01, 0x03, 0x13, 0x00}, \n\t{0x04, 0x0b, 0x00, 0x00}, \n\t{0x10, 0x0b, 0x14, 0x00}, \n\t{0x40, 0x03, 0x11, 0x00}, \n\t{0x61, 0x04, 0x00, 0x00}, \n\t{0x84, 0x0b, 0x47, 0x00}, \n\t{0xd0, 0x0b, 0x00, 0x00}, \n\t{0xd1, 0x0b, 0x00, 0x00}, \n\t{0x37, 0x02, 0x04, 0x00}, \n\t{0x09, 0x02, 0x04, 0x00}, \n\n\t \n\t\n\t{0x51, 0x0b, 0x00, 0x00}  \n};\n\n \n#define TW_CONTROL_CLEAR_HOST_INTERRUPT\t       0x00080000\n#define TW_CONTROL_CLEAR_ATTENTION_INTERRUPT   0x00040000\n#define TW_CONTROL_MASK_COMMAND_INTERRUPT      0x00020000\n#define TW_CONTROL_MASK_RESPONSE_INTERRUPT     0x00010000\n#define TW_CONTROL_UNMASK_COMMAND_INTERRUPT    0x00008000\n#define TW_CONTROL_UNMASK_RESPONSE_INTERRUPT   0x00004000\n#define TW_CONTROL_CLEAR_ERROR_STATUS\t       0x00000200\n#define TW_CONTROL_ISSUE_SOFT_RESET\t       0x00000100\n#define TW_CONTROL_ENABLE_INTERRUPTS\t       0x00000080\n#define TW_CONTROL_DISABLE_INTERRUPTS\t       0x00000040\n#define TW_CONTROL_ISSUE_HOST_INTERRUPT\t       0x00000020\n#define TW_CONTROL_CLEAR_PARITY_ERROR\t       0x00800000\n#define TW_CONTROL_CLEAR_QUEUE_ERROR\t       0x00400000\n#define TW_CONTROL_CLEAR_PCI_ABORT\t       0x00100000\n#define TW_CONTROL_CLEAR_SBUF_WRITE_ERROR      0x00000008\n\n \n#define TW_STATUS_MAJOR_VERSION_MASK\t       0xF0000000\n#define TW_STATUS_MINOR_VERSION_MASK\t       0x0F000000\n#define TW_STATUS_PCI_PARITY_ERROR\t       0x00800000\n#define TW_STATUS_QUEUE_ERROR\t\t       0x00400000\n#define TW_STATUS_MICROCONTROLLER_ERROR\t       0x00200000\n#define TW_STATUS_PCI_ABORT\t\t       0x00100000\n#define TW_STATUS_HOST_INTERRUPT\t       0x00080000\n#define TW_STATUS_ATTENTION_INTERRUPT\t       0x00040000\n#define TW_STATUS_COMMAND_INTERRUPT\t       0x00020000\n#define TW_STATUS_RESPONSE_INTERRUPT\t       0x00010000\n#define TW_STATUS_COMMAND_QUEUE_FULL\t       0x00008000\n#define TW_STATUS_RESPONSE_QUEUE_EMPTY\t       0x00004000\n#define TW_STATUS_MICROCONTROLLER_READY\t       0x00002000\n#define TW_STATUS_COMMAND_QUEUE_EMPTY\t       0x00001000\n#define TW_STATUS_ALL_INTERRUPTS\t       0x000F0000\n#define TW_STATUS_CLEARABLE_BITS\t       0x00D00000\n#define TW_STATUS_EXPECTED_BITS\t\t       0x00002000\n#define TW_STATUS_UNEXPECTED_BITS\t       0x00F00008\n#define TW_STATUS_SBUF_WRITE_ERROR\t       0x00000008\n#define TW_STATUS_VALID_INTERRUPT\t       0x00DF0008\n\n \n#define TW_RESPONSE_ID_MASK\t\t       0x00000FF0\n\n \n#define TW_IO_ADDRESS_RANGE\t\t       0x10\n#define TW_DEVICE_NAME\t\t\t       \"3ware Storage Controller\"\n#define TW_VENDOR_ID (0x13C1)\t \n#define TW_DEVICE_ID (0x1000)\t \n#define TW_DEVICE_ID2 (0x1001)   \n#define TW_NUMDEVICES 2\n#define TW_PCI_CLEAR_PARITY_ERRORS 0xc100\n#define TW_PCI_CLEAR_PCI_ABORT     0x2000\n\n \n#define TW_OP_NOP\t      0x0\n#define TW_OP_INIT_CONNECTION 0x1\n#define TW_OP_READ\t      0x2\n#define TW_OP_WRITE\t      0x3\n#define TW_OP_VERIFY\t      0x4\n#define TW_OP_GET_PARAM\t      0x12\n#define TW_OP_SET_PARAM\t      0x13\n#define TW_OP_SECTOR_INFO     0x1a\n#define TW_OP_AEN_LISTEN      0x1c\n#define TW_OP_FLUSH_CACHE     0x0e\n#define TW_CMD_PACKET\t      0x1d\n#define TW_CMD_PACKET_WITH_DATA 0x1f\n\n \n#define TW_AEN_QUEUE_EMPTY       0x0000\n#define TW_AEN_SOFT_RESET\t 0x0001\n#define TW_AEN_DEGRADED_MIRROR   0x0002\n#define TW_AEN_CONTROLLER_ERROR  0x0003\n#define TW_AEN_REBUILD_FAIL      0x0004\n#define TW_AEN_REBUILD_DONE      0x0005\n#define TW_AEN_QUEUE_FULL\t 0x00ff\n#define TW_AEN_TABLE_UNDEFINED   0x15\n#define TW_AEN_APORT_TIMEOUT     0x0009\n#define TW_AEN_DRIVE_ERROR       0x000A\n#define TW_AEN_SMART_FAIL\t 0x000F\n#define TW_AEN_SBUF_FAIL\t 0x0024\n\n \n#define TW_ALIGNMENT_6000\t\t      64  \n#define TW_ALIGNMENT_7000\t\t      4   \n#define TW_MAX_UNITS\t\t\t      16\n#define TW_COMMAND_ALIGNMENT_MASK\t      0x1ff\n#define TW_INIT_MESSAGE_CREDITS\t\t      0x100\n#define TW_INIT_COMMAND_PACKET_SIZE\t      0x3\n#define TW_POLL_MAX_RETRIES\t\t      20000\n#define TW_MAX_SGL_LENGTH\t\t      62\n#define TW_ATA_PASS_SGL_MAX\t\t      60\n#define TW_Q_LENGTH\t\t\t      256\n#define TW_Q_START\t\t\t      0\n#define TW_MAX_SLOT\t\t\t      32\n#define TW_MAX_PCI_BUSES\t\t      255\n#define TW_MAX_RESET_TRIES\t\t      3\n#define TW_UNIT_INFORMATION_TABLE_BASE\t      0x300\n#define TW_MAX_CMDS_PER_LUN\t\t      254  \n#define TW_BLOCK_SIZE\t\t\t      0x200  \n#define TW_IOCTL\t\t\t      0x80\n#define TW_UNIT_ONLINE\t\t\t      1\n#define TW_IN_INTR\t\t\t      1\n#define TW_IN_RESET\t\t\t      2\n#define TW_IN_CHRDEV_IOCTL\t\t      3\n#define TW_MAX_SECTORS\t\t\t      256\n#define TW_MAX_IOCTL_SECTORS\t\t      512\n#define TW_AEN_WAIT_TIME\t\t      1000\n#define TW_IOCTL_WAIT_TIME\t\t      (1 * HZ)  \n#define TW_ISR_DONT_COMPLETE\t\t      2\n#define TW_ISR_DONT_RESULT\t\t      3\n#define TW_IOCTL_TIMEOUT\t\t      25  \n#define TW_IOCTL_CHRDEV_TIMEOUT\t\t      60  \n#define TW_IOCTL_CHRDEV_FREE\t\t      -1\n#define TW_MAX_CDB_LEN\t\t\t      16\n\n \n\n \n#define TW_OPSGL_IN(x,y) ((x << 5) | (y & 0x1f))\n#define TW_SGL_OUT(x) ((x >> 5) & 0x7)\n\n \n#define TW_RESID_OUT(x) ((x >> 4) & 0xff)\n\n \n#define TW_UNITHOST_IN(x,y) ((x << 4) | ( y & 0xf))\n#define TW_UNIT_OUT(x) (x & 0xf)\n\n \n#define TW_CONTROL_REG_ADDR(x) (x->base_addr)\n#define TW_STATUS_REG_ADDR(x) (x->base_addr + 0x4)\n#define TW_COMMAND_QUEUE_REG_ADDR(x) (x->base_addr + 0x8)\n#define TW_RESPONSE_QUEUE_REG_ADDR(x) (x->base_addr + 0xC)\n#define TW_CLEAR_ALL_INTERRUPTS(x)\t\t\t\t\t\\\n\t(outl(TW_STATUS_VALID_INTERRUPT, TW_CONTROL_REG_ADDR(x)))\n#define TW_CLEAR_ATTENTION_INTERRUPT(x)\t\t\t\t\t\\\n\t(outl(TW_CONTROL_CLEAR_ATTENTION_INTERRUPT, TW_CONTROL_REG_ADDR(x)))\n#define TW_CLEAR_HOST_INTERRUPT(x)\t\t\t\t\t\\\n\t(outl(TW_CONTROL_CLEAR_HOST_INTERRUPT, TW_CONTROL_REG_ADDR(x)))\n#define TW_DISABLE_INTERRUPTS(x)\t\t\t\t\t\\\n\t(outl(TW_CONTROL_DISABLE_INTERRUPTS, TW_CONTROL_REG_ADDR(x)))\n#define TW_ENABLE_AND_CLEAR_INTERRUPTS(x)\t\t\t\t\\\n\t(outl(TW_CONTROL_CLEAR_ATTENTION_INTERRUPT |\t\t\t\\\n\t      TW_CONTROL_UNMASK_RESPONSE_INTERRUPT |\t\t\t\\\n\t      TW_CONTROL_ENABLE_INTERRUPTS, TW_CONTROL_REG_ADDR(x)))\n#define TW_MASK_COMMAND_INTERRUPT(x)\t\t\t\t\t\\\n\t(outl(TW_CONTROL_MASK_COMMAND_INTERRUPT, TW_CONTROL_REG_ADDR(x)))\n#define TW_UNMASK_COMMAND_INTERRUPT(x)\t\t\t\t\t\\\n\t(outl(TW_CONTROL_UNMASK_COMMAND_INTERRUPT, TW_CONTROL_REG_ADDR(x)))\n#define TW_SOFT_RESET(x) (outl(TW_CONTROL_ISSUE_SOFT_RESET |\t\t\\\n\t\t\t       TW_CONTROL_CLEAR_HOST_INTERRUPT |\t\\\n\t\t\t       TW_CONTROL_CLEAR_ATTENTION_INTERRUPT |\t\\\n\t\t\t       TW_CONTROL_MASK_COMMAND_INTERRUPT |\t\\\n\t\t\t       TW_CONTROL_MASK_RESPONSE_INTERRUPT |\t\\\n\t\t\t       TW_CONTROL_CLEAR_ERROR_STATUS |\t\t\\\n\t\t\t       TW_CONTROL_DISABLE_INTERRUPTS, TW_CONTROL_REG_ADDR(x)))\n#define TW_STATUS_ERRORS(x)\t\t\t\t\\\n\t(((x & TW_STATUS_PCI_ABORT) ||\t\t\t\\\n\t  (x & TW_STATUS_PCI_PARITY_ERROR) ||\t\t\\\n\t  (x & TW_STATUS_QUEUE_ERROR) ||\t\t\\\n\t  (x & TW_STATUS_MICROCONTROLLER_ERROR)) &&\t\\\n\t (x & TW_STATUS_MICROCONTROLLER_READY))\n\n#ifdef TW_DEBUG\n#define dprintk(msg...) printk(msg)\n#else\n#define dprintk(msg...) do { } while(0)\n#endif\n\n#pragma pack(1)\n\n \ntypedef struct TAG_TW_SG_Entry {\n\tu32 address;\n\tu32 length;\n} TW_SG_Entry;\n\ntypedef unsigned char TW_Sector[512];\n\n \ntypedef struct TW_Command {\n\tunsigned char opcode__sgloffset;\n\tunsigned char size;\n\tunsigned char request_id;\n\tunsigned char unit__hostid;\n\t \n\tunsigned char status;\n\tunsigned char flags;\n\tunion {\n\t\tunsigned short block_count;\n\t\tunsigned short parameter_count;\n\t\tunsigned short message_credits;\n\t} byte6;\n\tunion {\n\t\tstruct {\n\t\t\tu32 lba;\n\t\t\tTW_SG_Entry sgl[TW_MAX_SGL_LENGTH];\n\t\t\tu32 padding;\t \n\t\t} io;\n\t\tstruct {\n\t\t\tTW_SG_Entry sgl[TW_MAX_SGL_LENGTH];\n\t\t\tu32 padding[2];\n\t\t} param;\n\t\tstruct {\n\t\t\tu32 response_queue_pointer;\n\t\t\tu32 padding[125];\n\t\t} init_connection;\n\t\tstruct {\n\t\t\tchar version[504];\n\t\t} ioctl_miniport_version;\n\t} byte8;\n} TW_Command;\n\n#pragma pack()\n\ntypedef struct TAG_TW_Ioctl {\n\tunsigned char opcode;\n\tunsigned short table_id;\n\tunsigned char parameter_id;\n\tunsigned char parameter_size_bytes;\n\tunsigned char unit_index;\n\tunsigned char data[1];\n} TW_Ioctl;\n\n#pragma pack(1)\n\n \ntypedef struct TAG_TW_New_Ioctl {\n\tunsigned int data_buffer_length;\n\tunsigned char padding [508];\n\tTW_Command firmware_command;\n\tchar data_buffer[];\n} TW_New_Ioctl;\n\n \ntypedef struct {\n\tunsigned short\ttable_id;\n\tunsigned char\tparameter_id;\n\tunsigned char\tparameter_size_bytes;\n\tunsigned char\tdata[1];\n} TW_Param, *PTW_Param;\n\n \ntypedef union TAG_TW_Response_Queue {\n\tu32 response_id;\n\tu32 value;\n} TW_Response_Queue;\n\ntypedef int TW_Cmd_State;\n\n#define TW_S_INITIAL   0x1   \n#define TW_S_STARTED   0x2   \n#define TW_S_POSTED    0x4   \n#define TW_S_PENDING   0x8   \n#define TW_S_COMPLETED 0x10  \n#define TW_S_FINISHED  0x20  \n#define TW_START_MASK (TW_S_STARTED | TW_S_POSTED | TW_S_PENDING | TW_S_COMPLETED)\n\n \ntypedef struct TAG_TW_Passthru\n{\n\tunsigned char opcode__sgloffset;\n\tunsigned char size;\n\tunsigned char request_id;\n\tunsigned char aport__hostid;\n\tunsigned char status;\n\tunsigned char flags;\n\tunsigned short param;\n\tunsigned short features;\n\tunsigned short sector_count;\n\tunsigned short sector_num;\n\tunsigned short cylinder_lo;\n\tunsigned short cylinder_hi;\n\tunsigned char drive_head;\n\tunsigned char command;\n\tTW_SG_Entry sg_list[TW_ATA_PASS_SGL_MAX];\n\tunsigned char padding[12];\n} TW_Passthru;\n\n#pragma pack()\n\ntypedef struct TAG_TW_Device_Extension {\n\tu32\t\t\tbase_addr;\n\tunsigned long\t\t*alignment_virtual_address[TW_Q_LENGTH];\n\tunsigned long\t\talignment_physical_address[TW_Q_LENGTH];\n\tint\t\t\tis_unit_present[TW_MAX_UNITS];\n\tunsigned long\t\t*command_packet_virtual_address[TW_Q_LENGTH];\n\tunsigned long\t\tcommand_packet_physical_address[TW_Q_LENGTH];\n\tstruct pci_dev\t\t*tw_pci_dev;\n\tstruct scsi_cmnd\t*srb[TW_Q_LENGTH];\n\tunsigned char\t\tfree_queue[TW_Q_LENGTH];\n\tunsigned char\t\tfree_head;\n\tunsigned char\t\tfree_tail;\n\tunsigned char\t\tpending_queue[TW_Q_LENGTH];\n\tunsigned char\t\tpending_head;\n\tunsigned char\t\tpending_tail;\n\tTW_Cmd_State\t\tstate[TW_Q_LENGTH];\n\tu32\t\t\tposted_request_count;\n\tu32\t\t\tmax_posted_request_count;\n\tu32\t\t\trequest_count_marked_pending;\n\tu32\t\t\tpending_request_count;\n\tu32\t\t\tmax_pending_request_count;\n\tu32\t\t\tmax_sgl_entries;\n\tu32\t\t\tsgl_entries;\n\tu32\t\t\tnum_resets;\n\tu32\t\t\tsector_count;\n\tu32\t\t\tmax_sector_count;\n\tu32\t\t\taen_count;\n\tstruct Scsi_Host\t*host;\n\tstruct mutex\t\tioctl_lock;\n\tunsigned short\t\taen_queue[TW_Q_LENGTH];\n\tunsigned char\t\taen_head;\n\tunsigned char\t\taen_tail;\n\tvolatile long\t\tflags;  \n\tint\t\t\treset_print;\n\tvolatile int\t\tchrdev_request_id;\n\twait_queue_head_t\tioctl_wqueue;\n} TW_Device_Extension;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}