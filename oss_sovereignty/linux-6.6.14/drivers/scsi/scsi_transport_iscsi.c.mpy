{
  "module_name": "scsi_transport_iscsi.c",
  "hash_id": "77f08e45a6b9be0243b203216840fae0b98d447654d0a4ca38c524c1c956df9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_transport_iscsi.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/bsg-lib.h>\n#include <linux/idr.h>\n#include <net/tcp.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_iscsi.h>\n#include <scsi/iscsi_if.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_bsg_iscsi.h>\n\n#define ISCSI_TRANSPORT_VERSION \"2.0-870\"\n\n#define ISCSI_SEND_MAX_ALLOWED  10\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/iscsi.h>\n\n \nEXPORT_TRACEPOINT_SYMBOL_GPL(iscsi_dbg_conn);\nEXPORT_TRACEPOINT_SYMBOL_GPL(iscsi_dbg_eh);\nEXPORT_TRACEPOINT_SYMBOL_GPL(iscsi_dbg_session);\nEXPORT_TRACEPOINT_SYMBOL_GPL(iscsi_dbg_tcp);\nEXPORT_TRACEPOINT_SYMBOL_GPL(iscsi_dbg_sw_tcp);\n\nstatic int dbg_session;\nmodule_param_named(debug_session, dbg_session, int,\n\t\t   S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug_session,\n\t\t \"Turn on debugging for sessions in scsi_transport_iscsi \"\n\t\t \"module. Set to 1 to turn on, and zero to turn off. Default \"\n\t\t \"is off.\");\n\nstatic int dbg_conn;\nmodule_param_named(debug_conn, dbg_conn, int,\n\t\t   S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug_conn,\n\t\t \"Turn on debugging for connections in scsi_transport_iscsi \"\n\t\t \"module. Set to 1 to turn on, and zero to turn off. Default \"\n\t\t \"is off.\");\n\n#define ISCSI_DBG_TRANS_SESSION(_session, dbg_fmt, arg...)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (dbg_session)\t\t\t\t\t\\\n\t\t\tiscsi_cls_session_printk(KERN_INFO, _session,\t\\\n\t\t\t\t\t\t \"%s: \" dbg_fmt,\t\\\n\t\t\t\t\t\t __func__, ##arg);\t\\\n\t\tiscsi_dbg_trace(trace_iscsi_dbg_trans_session,\t\t\\\n\t\t\t\t&(_session)->dev,\t\t\t\\\n\t\t\t\t\"%s \" dbg_fmt, __func__, ##arg);\t\\\n\t} while (0);\n\n#define ISCSI_DBG_TRANS_CONN(_conn, dbg_fmt, arg...)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (dbg_conn)\t\t\t\t\t\t\\\n\t\t\tiscsi_cls_conn_printk(KERN_INFO, _conn,\t\t\\\n\t\t\t\t\t      \"%s: \" dbg_fmt,\t\t\\\n\t\t\t\t\t      __func__, ##arg);\t\t\\\n\t\tiscsi_dbg_trace(trace_iscsi_dbg_trans_conn,\t\t\\\n\t\t\t\t&(_conn)->dev,\t\t\t\t\\\n\t\t\t\t\"%s \" dbg_fmt, __func__, ##arg);\t\\\n\t} while (0);\n\nstruct iscsi_internal {\n\tstruct scsi_transport_template t;\n\tstruct iscsi_transport *iscsi_transport;\n\tstruct list_head list;\n\tstruct device dev;\n\n\tstruct transport_container conn_cont;\n\tstruct transport_container session_cont;\n};\n\nstatic DEFINE_IDR(iscsi_ep_idr);\nstatic DEFINE_MUTEX(iscsi_ep_idr_mutex);\n\nstatic atomic_t iscsi_session_nr;  \n\nstatic struct workqueue_struct *iscsi_conn_cleanup_workq;\n\nstatic DEFINE_IDA(iscsi_sess_ida);\n \nstatic LIST_HEAD(iscsi_transports);\nstatic DEFINE_SPINLOCK(iscsi_transport_lock);\n\n#define to_iscsi_internal(tmpl) \\\n\tcontainer_of(tmpl, struct iscsi_internal, t)\n\n#define dev_to_iscsi_internal(_dev) \\\n\tcontainer_of(_dev, struct iscsi_internal, dev)\n\nstatic void iscsi_transport_release(struct device *dev)\n{\n\tstruct iscsi_internal *priv = dev_to_iscsi_internal(dev);\n\tkfree(priv);\n}\n\n \nstatic struct class iscsi_transport_class = {\n\t.name = \"iscsi_transport\",\n\t.dev_release = iscsi_transport_release,\n};\n\nstatic ssize_t\nshow_transport_handle(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct iscsi_internal *priv = dev_to_iscsi_internal(dev);\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t  (unsigned long long)iscsi_handle(priv->iscsi_transport));\n}\nstatic DEVICE_ATTR(handle, S_IRUGO, show_transport_handle, NULL);\n\n#define show_transport_attr(name, format)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_transport_##name(struct device *dev, \t\t\t\t\\\n\t\t      struct device_attribute *attr,char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct iscsi_internal *priv = dev_to_iscsi_internal(dev);\t\\\n\treturn sysfs_emit(buf, format\"\\n\", priv->iscsi_transport->name);\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(name, S_IRUGO, show_transport_##name, NULL);\n\nshow_transport_attr(caps, \"0x%x\");\n\nstatic struct attribute *iscsi_transport_attrs[] = {\n\t&dev_attr_handle.attr,\n\t&dev_attr_caps.attr,\n\tNULL,\n};\n\nstatic struct attribute_group iscsi_transport_group = {\n\t.attrs = iscsi_transport_attrs,\n};\n\n \n#define iscsi_dev_to_endpoint(_dev) \\\n\tcontainer_of(_dev, struct iscsi_endpoint, dev)\n\n#define ISCSI_ATTR(_prefix,_name,_mode,_show,_store)\t\\\nstruct device_attribute dev_attr_##_prefix##_##_name =\t\\\n        __ATTR(_name,_mode,_show,_store)\n\nstatic void iscsi_endpoint_release(struct device *dev)\n{\n\tstruct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);\n\n\tmutex_lock(&iscsi_ep_idr_mutex);\n\tidr_remove(&iscsi_ep_idr, ep->id);\n\tmutex_unlock(&iscsi_ep_idr_mutex);\n\n\tkfree(ep);\n}\n\nstatic struct class iscsi_endpoint_class = {\n\t.name = \"iscsi_endpoint\",\n\t.dev_release = iscsi_endpoint_release,\n};\n\nstatic ssize_t\nshow_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);\n\treturn sysfs_emit(buf, \"%d\\n\", ep->id);\n}\nstatic ISCSI_ATTR(ep, handle, S_IRUGO, show_ep_handle, NULL);\n\nstatic struct attribute *iscsi_endpoint_attrs[] = {\n\t&dev_attr_ep_handle.attr,\n\tNULL,\n};\n\nstatic struct attribute_group iscsi_endpoint_group = {\n\t.attrs = iscsi_endpoint_attrs,\n};\n\nstruct iscsi_endpoint *\niscsi_create_endpoint(int dd_size)\n{\n\tstruct iscsi_endpoint *ep;\n\tint err, id;\n\n\tep = kzalloc(sizeof(*ep) + dd_size, GFP_KERNEL);\n\tif (!ep)\n\t\treturn NULL;\n\n\tmutex_lock(&iscsi_ep_idr_mutex);\n\n\t \n\tid = idr_alloc(&iscsi_ep_idr, ep, 1, -1, GFP_NOIO);\n\tif (id < 0) {\n\t\tmutex_unlock(&iscsi_ep_idr_mutex);\n\t\tprintk(KERN_ERR \"Could not allocate endpoint ID. Error %d.\\n\",\n\t\t       id);\n\t\tgoto free_ep;\n\t}\n\tmutex_unlock(&iscsi_ep_idr_mutex);\n\n\tep->id = id;\n\tep->dev.class = &iscsi_endpoint_class;\n\tdev_set_name(&ep->dev, \"ep-%d\", id);\n\terr = device_register(&ep->dev);\n        if (err)\n\t\tgoto put_dev;\n\n\terr = sysfs_create_group(&ep->dev.kobj, &iscsi_endpoint_group);\n\tif (err)\n\t\tgoto unregister_dev;\n\n\tif (dd_size)\n\t\tep->dd_data = &ep[1];\n\treturn ep;\n\nunregister_dev:\n\tdevice_unregister(&ep->dev);\n\treturn NULL;\n\nput_dev:\n\tmutex_lock(&iscsi_ep_idr_mutex);\n\tidr_remove(&iscsi_ep_idr, id);\n\tmutex_unlock(&iscsi_ep_idr_mutex);\n\tput_device(&ep->dev);\n\treturn NULL;\nfree_ep:\n\tkfree(ep);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(iscsi_create_endpoint);\n\nvoid iscsi_destroy_endpoint(struct iscsi_endpoint *ep)\n{\n\tsysfs_remove_group(&ep->dev.kobj, &iscsi_endpoint_group);\n\tdevice_unregister(&ep->dev);\n}\nEXPORT_SYMBOL_GPL(iscsi_destroy_endpoint);\n\nvoid iscsi_put_endpoint(struct iscsi_endpoint *ep)\n{\n\tput_device(&ep->dev);\n}\nEXPORT_SYMBOL_GPL(iscsi_put_endpoint);\n\n \nstruct iscsi_endpoint *iscsi_lookup_endpoint(u64 handle)\n{\n\tstruct iscsi_endpoint *ep;\n\n\tmutex_lock(&iscsi_ep_idr_mutex);\n\tep = idr_find(&iscsi_ep_idr, handle);\n\tif (!ep)\n\t\tgoto unlock;\n\n\tget_device(&ep->dev);\nunlock:\n\tmutex_unlock(&iscsi_ep_idr_mutex);\n\treturn ep;\n}\nEXPORT_SYMBOL_GPL(iscsi_lookup_endpoint);\n\n \n\nstatic void iscsi_iface_release(struct device *dev)\n{\n\tstruct iscsi_iface *iface = iscsi_dev_to_iface(dev);\n\tstruct device *parent = iface->dev.parent;\n\n\tkfree(iface);\n\tput_device(parent);\n}\n\n\nstatic struct class iscsi_iface_class = {\n\t.name = \"iscsi_iface\",\n\t.dev_release = iscsi_iface_release,\n};\n\n#define ISCSI_IFACE_ATTR(_prefix, _name, _mode, _show, _store)\t\\\nstruct device_attribute dev_attr_##_prefix##_##_name =\t\t\\\n\t__ATTR(_name, _mode, _show, _store)\n\n \n#define iscsi_iface_attr_show(type, name, param_type, param)\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_##type##_##name(struct device *dev, struct device_attribute *attr,\t\\\n\t\t     char *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct iscsi_iface *iface = iscsi_dev_to_iface(dev);\t\t\\\n\tstruct iscsi_transport *t = iface->transport;\t\t\t\\\n\treturn t->get_iface_param(iface, param_type, param, buf);\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\n#define iscsi_iface_net_attr(type, name, param)\t\t\t\t\\\n\tiscsi_iface_attr_show(type, name, ISCSI_NET_PARAM, param)\t\\\nstatic ISCSI_IFACE_ATTR(type, name, S_IRUGO, show_##type##_##name, NULL);\n\n#define iscsi_iface_attr(type, name, param)\t\t\t\t\\\n\tiscsi_iface_attr_show(type, name, ISCSI_IFACE_PARAM, param)\t\\\nstatic ISCSI_IFACE_ATTR(type, name, S_IRUGO, show_##type##_##name, NULL);\n\n \niscsi_iface_net_attr(ipv4_iface, ipaddress, ISCSI_NET_PARAM_IPV4_ADDR);\niscsi_iface_net_attr(ipv4_iface, gateway, ISCSI_NET_PARAM_IPV4_GW);\niscsi_iface_net_attr(ipv4_iface, subnet, ISCSI_NET_PARAM_IPV4_SUBNET);\niscsi_iface_net_attr(ipv4_iface, bootproto, ISCSI_NET_PARAM_IPV4_BOOTPROTO);\niscsi_iface_net_attr(ipv4_iface, dhcp_dns_address_en,\n\t\t     ISCSI_NET_PARAM_IPV4_DHCP_DNS_ADDR_EN);\niscsi_iface_net_attr(ipv4_iface, dhcp_slp_da_info_en,\n\t\t     ISCSI_NET_PARAM_IPV4_DHCP_SLP_DA_EN);\niscsi_iface_net_attr(ipv4_iface, tos_en, ISCSI_NET_PARAM_IPV4_TOS_EN);\niscsi_iface_net_attr(ipv4_iface, tos, ISCSI_NET_PARAM_IPV4_TOS);\niscsi_iface_net_attr(ipv4_iface, grat_arp_en,\n\t\t     ISCSI_NET_PARAM_IPV4_GRAT_ARP_EN);\niscsi_iface_net_attr(ipv4_iface, dhcp_alt_client_id_en,\n\t\t     ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID_EN);\niscsi_iface_net_attr(ipv4_iface, dhcp_alt_client_id,\n\t\t     ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID);\niscsi_iface_net_attr(ipv4_iface, dhcp_req_vendor_id_en,\n\t\t     ISCSI_NET_PARAM_IPV4_DHCP_REQ_VENDOR_ID_EN);\niscsi_iface_net_attr(ipv4_iface, dhcp_use_vendor_id_en,\n\t\t     ISCSI_NET_PARAM_IPV4_DHCP_USE_VENDOR_ID_EN);\niscsi_iface_net_attr(ipv4_iface, dhcp_vendor_id,\n\t\t     ISCSI_NET_PARAM_IPV4_DHCP_VENDOR_ID);\niscsi_iface_net_attr(ipv4_iface, dhcp_learn_iqn_en,\n\t\t     ISCSI_NET_PARAM_IPV4_DHCP_LEARN_IQN_EN);\niscsi_iface_net_attr(ipv4_iface, fragment_disable,\n\t\t     ISCSI_NET_PARAM_IPV4_FRAGMENT_DISABLE);\niscsi_iface_net_attr(ipv4_iface, incoming_forwarding_en,\n\t\t     ISCSI_NET_PARAM_IPV4_IN_FORWARD_EN);\niscsi_iface_net_attr(ipv4_iface, ttl, ISCSI_NET_PARAM_IPV4_TTL);\n\n \niscsi_iface_net_attr(ipv6_iface, ipaddress, ISCSI_NET_PARAM_IPV6_ADDR);\niscsi_iface_net_attr(ipv6_iface, link_local_addr,\n\t\t     ISCSI_NET_PARAM_IPV6_LINKLOCAL);\niscsi_iface_net_attr(ipv6_iface, router_addr, ISCSI_NET_PARAM_IPV6_ROUTER);\niscsi_iface_net_attr(ipv6_iface, ipaddr_autocfg,\n\t\t     ISCSI_NET_PARAM_IPV6_ADDR_AUTOCFG);\niscsi_iface_net_attr(ipv6_iface, link_local_autocfg,\n\t\t     ISCSI_NET_PARAM_IPV6_LINKLOCAL_AUTOCFG);\niscsi_iface_net_attr(ipv6_iface, link_local_state,\n\t\t     ISCSI_NET_PARAM_IPV6_LINKLOCAL_STATE);\niscsi_iface_net_attr(ipv6_iface, router_state,\n\t\t     ISCSI_NET_PARAM_IPV6_ROUTER_STATE);\niscsi_iface_net_attr(ipv6_iface, grat_neighbor_adv_en,\n\t\t     ISCSI_NET_PARAM_IPV6_GRAT_NEIGHBOR_ADV_EN);\niscsi_iface_net_attr(ipv6_iface, mld_en, ISCSI_NET_PARAM_IPV6_MLD_EN);\niscsi_iface_net_attr(ipv6_iface, flow_label, ISCSI_NET_PARAM_IPV6_FLOW_LABEL);\niscsi_iface_net_attr(ipv6_iface, traffic_class,\n\t\t     ISCSI_NET_PARAM_IPV6_TRAFFIC_CLASS);\niscsi_iface_net_attr(ipv6_iface, hop_limit, ISCSI_NET_PARAM_IPV6_HOP_LIMIT);\niscsi_iface_net_attr(ipv6_iface, nd_reachable_tmo,\n\t\t     ISCSI_NET_PARAM_IPV6_ND_REACHABLE_TMO);\niscsi_iface_net_attr(ipv6_iface, nd_rexmit_time,\n\t\t     ISCSI_NET_PARAM_IPV6_ND_REXMIT_TIME);\niscsi_iface_net_attr(ipv6_iface, nd_stale_tmo,\n\t\t     ISCSI_NET_PARAM_IPV6_ND_STALE_TMO);\niscsi_iface_net_attr(ipv6_iface, dup_addr_detect_cnt,\n\t\t     ISCSI_NET_PARAM_IPV6_DUP_ADDR_DETECT_CNT);\niscsi_iface_net_attr(ipv6_iface, router_adv_link_mtu,\n\t\t     ISCSI_NET_PARAM_IPV6_RTR_ADV_LINK_MTU);\n\n \niscsi_iface_net_attr(iface, enabled, ISCSI_NET_PARAM_IFACE_ENABLE);\niscsi_iface_net_attr(iface, vlan_id, ISCSI_NET_PARAM_VLAN_ID);\niscsi_iface_net_attr(iface, vlan_priority, ISCSI_NET_PARAM_VLAN_PRIORITY);\niscsi_iface_net_attr(iface, vlan_enabled, ISCSI_NET_PARAM_VLAN_ENABLED);\niscsi_iface_net_attr(iface, mtu, ISCSI_NET_PARAM_MTU);\niscsi_iface_net_attr(iface, port, ISCSI_NET_PARAM_PORT);\niscsi_iface_net_attr(iface, ipaddress_state, ISCSI_NET_PARAM_IPADDR_STATE);\niscsi_iface_net_attr(iface, delayed_ack_en, ISCSI_NET_PARAM_DELAYED_ACK_EN);\niscsi_iface_net_attr(iface, tcp_nagle_disable,\n\t\t     ISCSI_NET_PARAM_TCP_NAGLE_DISABLE);\niscsi_iface_net_attr(iface, tcp_wsf_disable, ISCSI_NET_PARAM_TCP_WSF_DISABLE);\niscsi_iface_net_attr(iface, tcp_wsf, ISCSI_NET_PARAM_TCP_WSF);\niscsi_iface_net_attr(iface, tcp_timer_scale, ISCSI_NET_PARAM_TCP_TIMER_SCALE);\niscsi_iface_net_attr(iface, tcp_timestamp_en, ISCSI_NET_PARAM_TCP_TIMESTAMP_EN);\niscsi_iface_net_attr(iface, cache_id, ISCSI_NET_PARAM_CACHE_ID);\niscsi_iface_net_attr(iface, redirect_en, ISCSI_NET_PARAM_REDIRECT_EN);\n\n \niscsi_iface_attr(iface, def_taskmgmt_tmo, ISCSI_IFACE_PARAM_DEF_TASKMGMT_TMO);\niscsi_iface_attr(iface, header_digest, ISCSI_IFACE_PARAM_HDRDGST_EN);\niscsi_iface_attr(iface, data_digest, ISCSI_IFACE_PARAM_DATADGST_EN);\niscsi_iface_attr(iface, immediate_data, ISCSI_IFACE_PARAM_IMM_DATA_EN);\niscsi_iface_attr(iface, initial_r2t, ISCSI_IFACE_PARAM_INITIAL_R2T_EN);\niscsi_iface_attr(iface, data_seq_in_order,\n\t\t ISCSI_IFACE_PARAM_DATASEQ_INORDER_EN);\niscsi_iface_attr(iface, data_pdu_in_order, ISCSI_IFACE_PARAM_PDU_INORDER_EN);\niscsi_iface_attr(iface, erl, ISCSI_IFACE_PARAM_ERL);\niscsi_iface_attr(iface, max_recv_dlength, ISCSI_IFACE_PARAM_MAX_RECV_DLENGTH);\niscsi_iface_attr(iface, first_burst_len, ISCSI_IFACE_PARAM_FIRST_BURST);\niscsi_iface_attr(iface, max_outstanding_r2t, ISCSI_IFACE_PARAM_MAX_R2T);\niscsi_iface_attr(iface, max_burst_len, ISCSI_IFACE_PARAM_MAX_BURST);\niscsi_iface_attr(iface, chap_auth, ISCSI_IFACE_PARAM_CHAP_AUTH_EN);\niscsi_iface_attr(iface, bidi_chap, ISCSI_IFACE_PARAM_BIDI_CHAP_EN);\niscsi_iface_attr(iface, discovery_auth_optional,\n\t\t ISCSI_IFACE_PARAM_DISCOVERY_AUTH_OPTIONAL);\niscsi_iface_attr(iface, discovery_logout,\n\t\t ISCSI_IFACE_PARAM_DISCOVERY_LOGOUT_EN);\niscsi_iface_attr(iface, strict_login_comp_en,\n\t\t ISCSI_IFACE_PARAM_STRICT_LOGIN_COMP_EN);\niscsi_iface_attr(iface, initiator_name, ISCSI_IFACE_PARAM_INITIATOR_NAME);\n\nstatic umode_t iscsi_iface_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t  struct attribute *attr, int i)\n{\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct iscsi_iface *iface = iscsi_dev_to_iface(dev);\n\tstruct iscsi_transport *t = iface->transport;\n\tint param = -1;\n\n\tif (attr == &dev_attr_iface_def_taskmgmt_tmo.attr)\n\t\tparam = ISCSI_IFACE_PARAM_DEF_TASKMGMT_TMO;\n\telse if (attr == &dev_attr_iface_header_digest.attr)\n\t\tparam = ISCSI_IFACE_PARAM_HDRDGST_EN;\n\telse if (attr == &dev_attr_iface_data_digest.attr)\n\t\tparam = ISCSI_IFACE_PARAM_DATADGST_EN;\n\telse if (attr == &dev_attr_iface_immediate_data.attr)\n\t\tparam = ISCSI_IFACE_PARAM_IMM_DATA_EN;\n\telse if (attr == &dev_attr_iface_initial_r2t.attr)\n\t\tparam = ISCSI_IFACE_PARAM_INITIAL_R2T_EN;\n\telse if (attr == &dev_attr_iface_data_seq_in_order.attr)\n\t\tparam = ISCSI_IFACE_PARAM_DATASEQ_INORDER_EN;\n\telse if (attr == &dev_attr_iface_data_pdu_in_order.attr)\n\t\tparam = ISCSI_IFACE_PARAM_PDU_INORDER_EN;\n\telse if (attr == &dev_attr_iface_erl.attr)\n\t\tparam = ISCSI_IFACE_PARAM_ERL;\n\telse if (attr == &dev_attr_iface_max_recv_dlength.attr)\n\t\tparam = ISCSI_IFACE_PARAM_MAX_RECV_DLENGTH;\n\telse if (attr == &dev_attr_iface_first_burst_len.attr)\n\t\tparam = ISCSI_IFACE_PARAM_FIRST_BURST;\n\telse if (attr == &dev_attr_iface_max_outstanding_r2t.attr)\n\t\tparam = ISCSI_IFACE_PARAM_MAX_R2T;\n\telse if (attr == &dev_attr_iface_max_burst_len.attr)\n\t\tparam = ISCSI_IFACE_PARAM_MAX_BURST;\n\telse if (attr == &dev_attr_iface_chap_auth.attr)\n\t\tparam = ISCSI_IFACE_PARAM_CHAP_AUTH_EN;\n\telse if (attr == &dev_attr_iface_bidi_chap.attr)\n\t\tparam = ISCSI_IFACE_PARAM_BIDI_CHAP_EN;\n\telse if (attr == &dev_attr_iface_discovery_auth_optional.attr)\n\t\tparam = ISCSI_IFACE_PARAM_DISCOVERY_AUTH_OPTIONAL;\n\telse if (attr == &dev_attr_iface_discovery_logout.attr)\n\t\tparam = ISCSI_IFACE_PARAM_DISCOVERY_LOGOUT_EN;\n\telse if (attr == &dev_attr_iface_strict_login_comp_en.attr)\n\t\tparam = ISCSI_IFACE_PARAM_STRICT_LOGIN_COMP_EN;\n\telse if (attr == &dev_attr_iface_initiator_name.attr)\n\t\tparam = ISCSI_IFACE_PARAM_INITIATOR_NAME;\n\n\tif (param != -1)\n\t\treturn t->attr_is_visible(ISCSI_IFACE_PARAM, param);\n\n\tif (attr == &dev_attr_iface_enabled.attr)\n\t\tparam = ISCSI_NET_PARAM_IFACE_ENABLE;\n\telse if (attr == &dev_attr_iface_vlan_id.attr)\n\t\tparam = ISCSI_NET_PARAM_VLAN_ID;\n\telse if (attr == &dev_attr_iface_vlan_priority.attr)\n\t\tparam = ISCSI_NET_PARAM_VLAN_PRIORITY;\n\telse if (attr == &dev_attr_iface_vlan_enabled.attr)\n\t\tparam = ISCSI_NET_PARAM_VLAN_ENABLED;\n\telse if (attr == &dev_attr_iface_mtu.attr)\n\t\tparam = ISCSI_NET_PARAM_MTU;\n\telse if (attr == &dev_attr_iface_port.attr)\n\t\tparam = ISCSI_NET_PARAM_PORT;\n\telse if (attr == &dev_attr_iface_ipaddress_state.attr)\n\t\tparam = ISCSI_NET_PARAM_IPADDR_STATE;\n\telse if (attr == &dev_attr_iface_delayed_ack_en.attr)\n\t\tparam = ISCSI_NET_PARAM_DELAYED_ACK_EN;\n\telse if (attr == &dev_attr_iface_tcp_nagle_disable.attr)\n\t\tparam = ISCSI_NET_PARAM_TCP_NAGLE_DISABLE;\n\telse if (attr == &dev_attr_iface_tcp_wsf_disable.attr)\n\t\tparam = ISCSI_NET_PARAM_TCP_WSF_DISABLE;\n\telse if (attr == &dev_attr_iface_tcp_wsf.attr)\n\t\tparam = ISCSI_NET_PARAM_TCP_WSF;\n\telse if (attr == &dev_attr_iface_tcp_timer_scale.attr)\n\t\tparam = ISCSI_NET_PARAM_TCP_TIMER_SCALE;\n\telse if (attr == &dev_attr_iface_tcp_timestamp_en.attr)\n\t\tparam = ISCSI_NET_PARAM_TCP_TIMESTAMP_EN;\n\telse if (attr == &dev_attr_iface_cache_id.attr)\n\t\tparam = ISCSI_NET_PARAM_CACHE_ID;\n\telse if (attr == &dev_attr_iface_redirect_en.attr)\n\t\tparam = ISCSI_NET_PARAM_REDIRECT_EN;\n\telse if (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\tif (attr == &dev_attr_ipv4_iface_ipaddress.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_ADDR;\n\t\telse if (attr == &dev_attr_ipv4_iface_gateway.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_GW;\n\t\telse if (attr == &dev_attr_ipv4_iface_subnet.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_SUBNET;\n\t\telse if (attr == &dev_attr_ipv4_iface_bootproto.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_BOOTPROTO;\n\t\telse if (attr ==\n\t\t\t &dev_attr_ipv4_iface_dhcp_dns_address_en.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_DHCP_DNS_ADDR_EN;\n\t\telse if (attr ==\n\t\t\t &dev_attr_ipv4_iface_dhcp_slp_da_info_en.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_DHCP_SLP_DA_EN;\n\t\telse if (attr == &dev_attr_ipv4_iface_tos_en.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_TOS_EN;\n\t\telse if (attr == &dev_attr_ipv4_iface_tos.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_TOS;\n\t\telse if (attr == &dev_attr_ipv4_iface_grat_arp_en.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_GRAT_ARP_EN;\n\t\telse if (attr ==\n\t\t\t &dev_attr_ipv4_iface_dhcp_alt_client_id_en.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID_EN;\n\t\telse if (attr == &dev_attr_ipv4_iface_dhcp_alt_client_id.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID;\n\t\telse if (attr ==\n\t\t\t &dev_attr_ipv4_iface_dhcp_req_vendor_id_en.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_DHCP_REQ_VENDOR_ID_EN;\n\t\telse if (attr ==\n\t\t\t &dev_attr_ipv4_iface_dhcp_use_vendor_id_en.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_DHCP_USE_VENDOR_ID_EN;\n\t\telse if (attr == &dev_attr_ipv4_iface_dhcp_vendor_id.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_DHCP_VENDOR_ID;\n\t\telse if (attr ==\n\t\t\t &dev_attr_ipv4_iface_dhcp_learn_iqn_en.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_DHCP_LEARN_IQN_EN;\n\t\telse if (attr ==\n\t\t\t &dev_attr_ipv4_iface_fragment_disable.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_FRAGMENT_DISABLE;\n\t\telse if (attr ==\n\t\t\t &dev_attr_ipv4_iface_incoming_forwarding_en.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_IN_FORWARD_EN;\n\t\telse if (attr == &dev_attr_ipv4_iface_ttl.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV4_TTL;\n\t\telse\n\t\t\treturn 0;\n\t} else if (iface->iface_type == ISCSI_IFACE_TYPE_IPV6) {\n\t\tif (attr == &dev_attr_ipv6_iface_ipaddress.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_ADDR;\n\t\telse if (attr == &dev_attr_ipv6_iface_link_local_addr.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_LINKLOCAL;\n\t\telse if (attr == &dev_attr_ipv6_iface_router_addr.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_ROUTER;\n\t\telse if (attr == &dev_attr_ipv6_iface_ipaddr_autocfg.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_ADDR_AUTOCFG;\n\t\telse if (attr == &dev_attr_ipv6_iface_link_local_autocfg.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_LINKLOCAL_AUTOCFG;\n\t\telse if (attr == &dev_attr_ipv6_iface_link_local_state.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_LINKLOCAL_STATE;\n\t\telse if (attr == &dev_attr_ipv6_iface_router_state.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_ROUTER_STATE;\n\t\telse if (attr ==\n\t\t\t &dev_attr_ipv6_iface_grat_neighbor_adv_en.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_GRAT_NEIGHBOR_ADV_EN;\n\t\telse if (attr == &dev_attr_ipv6_iface_mld_en.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_MLD_EN;\n\t\telse if (attr == &dev_attr_ipv6_iface_flow_label.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_FLOW_LABEL;\n\t\telse if (attr == &dev_attr_ipv6_iface_traffic_class.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_TRAFFIC_CLASS;\n\t\telse if (attr == &dev_attr_ipv6_iface_hop_limit.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_HOP_LIMIT;\n\t\telse if (attr == &dev_attr_ipv6_iface_nd_reachable_tmo.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_ND_REACHABLE_TMO;\n\t\telse if (attr == &dev_attr_ipv6_iface_nd_rexmit_time.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_ND_REXMIT_TIME;\n\t\telse if (attr == &dev_attr_ipv6_iface_nd_stale_tmo.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_ND_STALE_TMO;\n\t\telse if (attr == &dev_attr_ipv6_iface_dup_addr_detect_cnt.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_DUP_ADDR_DETECT_CNT;\n\t\telse if (attr == &dev_attr_ipv6_iface_router_adv_link_mtu.attr)\n\t\t\tparam = ISCSI_NET_PARAM_IPV6_RTR_ADV_LINK_MTU;\n\t\telse\n\t\t\treturn 0;\n\t} else {\n\t\tWARN_ONCE(1, \"Invalid iface attr\");\n\t\treturn 0;\n\t}\n\n\treturn t->attr_is_visible(ISCSI_NET_PARAM, param);\n}\n\nstatic struct attribute *iscsi_iface_attrs[] = {\n\t&dev_attr_iface_enabled.attr,\n\t&dev_attr_iface_vlan_id.attr,\n\t&dev_attr_iface_vlan_priority.attr,\n\t&dev_attr_iface_vlan_enabled.attr,\n\t&dev_attr_ipv4_iface_ipaddress.attr,\n\t&dev_attr_ipv4_iface_gateway.attr,\n\t&dev_attr_ipv4_iface_subnet.attr,\n\t&dev_attr_ipv4_iface_bootproto.attr,\n\t&dev_attr_ipv6_iface_ipaddress.attr,\n\t&dev_attr_ipv6_iface_link_local_addr.attr,\n\t&dev_attr_ipv6_iface_router_addr.attr,\n\t&dev_attr_ipv6_iface_ipaddr_autocfg.attr,\n\t&dev_attr_ipv6_iface_link_local_autocfg.attr,\n\t&dev_attr_iface_mtu.attr,\n\t&dev_attr_iface_port.attr,\n\t&dev_attr_iface_ipaddress_state.attr,\n\t&dev_attr_iface_delayed_ack_en.attr,\n\t&dev_attr_iface_tcp_nagle_disable.attr,\n\t&dev_attr_iface_tcp_wsf_disable.attr,\n\t&dev_attr_iface_tcp_wsf.attr,\n\t&dev_attr_iface_tcp_timer_scale.attr,\n\t&dev_attr_iface_tcp_timestamp_en.attr,\n\t&dev_attr_iface_cache_id.attr,\n\t&dev_attr_iface_redirect_en.attr,\n\t&dev_attr_iface_def_taskmgmt_tmo.attr,\n\t&dev_attr_iface_header_digest.attr,\n\t&dev_attr_iface_data_digest.attr,\n\t&dev_attr_iface_immediate_data.attr,\n\t&dev_attr_iface_initial_r2t.attr,\n\t&dev_attr_iface_data_seq_in_order.attr,\n\t&dev_attr_iface_data_pdu_in_order.attr,\n\t&dev_attr_iface_erl.attr,\n\t&dev_attr_iface_max_recv_dlength.attr,\n\t&dev_attr_iface_first_burst_len.attr,\n\t&dev_attr_iface_max_outstanding_r2t.attr,\n\t&dev_attr_iface_max_burst_len.attr,\n\t&dev_attr_iface_chap_auth.attr,\n\t&dev_attr_iface_bidi_chap.attr,\n\t&dev_attr_iface_discovery_auth_optional.attr,\n\t&dev_attr_iface_discovery_logout.attr,\n\t&dev_attr_iface_strict_login_comp_en.attr,\n\t&dev_attr_iface_initiator_name.attr,\n\t&dev_attr_ipv4_iface_dhcp_dns_address_en.attr,\n\t&dev_attr_ipv4_iface_dhcp_slp_da_info_en.attr,\n\t&dev_attr_ipv4_iface_tos_en.attr,\n\t&dev_attr_ipv4_iface_tos.attr,\n\t&dev_attr_ipv4_iface_grat_arp_en.attr,\n\t&dev_attr_ipv4_iface_dhcp_alt_client_id_en.attr,\n\t&dev_attr_ipv4_iface_dhcp_alt_client_id.attr,\n\t&dev_attr_ipv4_iface_dhcp_req_vendor_id_en.attr,\n\t&dev_attr_ipv4_iface_dhcp_use_vendor_id_en.attr,\n\t&dev_attr_ipv4_iface_dhcp_vendor_id.attr,\n\t&dev_attr_ipv4_iface_dhcp_learn_iqn_en.attr,\n\t&dev_attr_ipv4_iface_fragment_disable.attr,\n\t&dev_attr_ipv4_iface_incoming_forwarding_en.attr,\n\t&dev_attr_ipv4_iface_ttl.attr,\n\t&dev_attr_ipv6_iface_link_local_state.attr,\n\t&dev_attr_ipv6_iface_router_state.attr,\n\t&dev_attr_ipv6_iface_grat_neighbor_adv_en.attr,\n\t&dev_attr_ipv6_iface_mld_en.attr,\n\t&dev_attr_ipv6_iface_flow_label.attr,\n\t&dev_attr_ipv6_iface_traffic_class.attr,\n\t&dev_attr_ipv6_iface_hop_limit.attr,\n\t&dev_attr_ipv6_iface_nd_reachable_tmo.attr,\n\t&dev_attr_ipv6_iface_nd_rexmit_time.attr,\n\t&dev_attr_ipv6_iface_nd_stale_tmo.attr,\n\t&dev_attr_ipv6_iface_dup_addr_detect_cnt.attr,\n\t&dev_attr_ipv6_iface_router_adv_link_mtu.attr,\n\tNULL,\n};\n\nstatic struct attribute_group iscsi_iface_group = {\n\t.attrs = iscsi_iface_attrs,\n\t.is_visible = iscsi_iface_attr_is_visible,\n};\n\n \nstatic const struct {\n\tenum iscsi_ipaddress_state\tvalue;\n\tchar\t\t\t\t*name;\n} iscsi_ipaddress_state_names[] = {\n\t{ISCSI_IPDDRESS_STATE_UNCONFIGURED,\t\"Unconfigured\" },\n\t{ISCSI_IPDDRESS_STATE_ACQUIRING,\t\"Acquiring\" },\n\t{ISCSI_IPDDRESS_STATE_TENTATIVE,\t\"Tentative\" },\n\t{ISCSI_IPDDRESS_STATE_VALID,\t\t\"Valid\" },\n\t{ISCSI_IPDDRESS_STATE_DISABLING,\t\"Disabling\" },\n\t{ISCSI_IPDDRESS_STATE_INVALID,\t\t\"Invalid\" },\n\t{ISCSI_IPDDRESS_STATE_DEPRECATED,\t\"Deprecated\" },\n};\n\nchar *iscsi_get_ipaddress_state_name(enum iscsi_ipaddress_state port_state)\n{\n\tint i;\n\tchar *state = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(iscsi_ipaddress_state_names); i++) {\n\t\tif (iscsi_ipaddress_state_names[i].value == port_state) {\n\t\t\tstate = iscsi_ipaddress_state_names[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn state;\n}\nEXPORT_SYMBOL_GPL(iscsi_get_ipaddress_state_name);\n\n \nstatic const struct {\n\tenum iscsi_router_state\tvalue;\n\tchar\t\t\t*name;\n} iscsi_router_state_names[] = {\n\t{ISCSI_ROUTER_STATE_UNKNOWN,\t\t\"Unknown\" },\n\t{ISCSI_ROUTER_STATE_ADVERTISED,\t\t\"Advertised\" },\n\t{ISCSI_ROUTER_STATE_MANUAL,\t\t\"Manual\" },\n\t{ISCSI_ROUTER_STATE_STALE,\t\t\"Stale\" },\n};\n\nchar *iscsi_get_router_state_name(enum iscsi_router_state router_state)\n{\n\tint i;\n\tchar *state = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(iscsi_router_state_names); i++) {\n\t\tif (iscsi_router_state_names[i].value == router_state) {\n\t\t\tstate = iscsi_router_state_names[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn state;\n}\nEXPORT_SYMBOL_GPL(iscsi_get_router_state_name);\n\nstruct iscsi_iface *\niscsi_create_iface(struct Scsi_Host *shost, struct iscsi_transport *transport,\n\t\t   uint32_t iface_type, uint32_t iface_num, int dd_size)\n{\n\tstruct iscsi_iface *iface;\n\tint err;\n\n\tiface = kzalloc(sizeof(*iface) + dd_size, GFP_KERNEL);\n\tif (!iface)\n\t\treturn NULL;\n\n\tiface->transport = transport;\n\tiface->iface_type = iface_type;\n\tiface->iface_num = iface_num;\n\tiface->dev.release = iscsi_iface_release;\n\tiface->dev.class = &iscsi_iface_class;\n\t \n\tiface->dev.parent = get_device(&shost->shost_gendev);\n\tif (iface_type == ISCSI_IFACE_TYPE_IPV4)\n\t\tdev_set_name(&iface->dev, \"ipv4-iface-%u-%u\", shost->host_no,\n\t\t\t     iface_num);\n\telse\n\t\tdev_set_name(&iface->dev, \"ipv6-iface-%u-%u\", shost->host_no,\n\t\t\t     iface_num);\n\n\terr = device_register(&iface->dev);\n\tif (err)\n\t\tgoto put_dev;\n\n\terr = sysfs_create_group(&iface->dev.kobj, &iscsi_iface_group);\n\tif (err)\n\t\tgoto unreg_iface;\n\n\tif (dd_size)\n\t\tiface->dd_data = &iface[1];\n\treturn iface;\n\nunreg_iface:\n\tdevice_unregister(&iface->dev);\n\treturn NULL;\n\nput_dev:\n\tput_device(&iface->dev);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(iscsi_create_iface);\n\nvoid iscsi_destroy_iface(struct iscsi_iface *iface)\n{\n\tsysfs_remove_group(&iface->dev.kobj, &iscsi_iface_group);\n\tdevice_unregister(&iface->dev);\n}\nEXPORT_SYMBOL_GPL(iscsi_destroy_iface);\n\n \n\n#define ISCSI_FLASHNODE_ATTR(_prefix, _name, _mode, _show, _store)\t\\\nstruct device_attribute dev_attr_##_prefix##_##_name =\t\t\t\\\n\t__ATTR(_name, _mode, _show, _store)\n\n \n#define iscsi_flashnode_sess_attr_show(type, name, param)\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_##type##_##name(struct device *dev, struct device_attribute *attr,\t\\\n\t\t     char *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct iscsi_bus_flash_session *fnode_sess =\t\t\t\\\n\t\t\t\t\tiscsi_dev_to_flash_session(dev);\\\n\tstruct iscsi_transport *t = fnode_sess->transport;\t\t\\\n\treturn t->get_flashnode_param(fnode_sess, param, buf);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\n\n#define iscsi_flashnode_sess_attr(type, name, param)\t\t\t\\\n\tiscsi_flashnode_sess_attr_show(type, name, param)\t\t\\\nstatic ISCSI_FLASHNODE_ATTR(type, name, S_IRUGO,\t\t\t\\\n\t\t\t    show_##type##_##name, NULL);\n\n \n\niscsi_flashnode_sess_attr(fnode, auto_snd_tgt_disable,\n\t\t\t  ISCSI_FLASHNODE_AUTO_SND_TGT_DISABLE);\niscsi_flashnode_sess_attr(fnode, discovery_session,\n\t\t\t  ISCSI_FLASHNODE_DISCOVERY_SESS);\niscsi_flashnode_sess_attr(fnode, portal_type, ISCSI_FLASHNODE_PORTAL_TYPE);\niscsi_flashnode_sess_attr(fnode, entry_enable, ISCSI_FLASHNODE_ENTRY_EN);\niscsi_flashnode_sess_attr(fnode, immediate_data, ISCSI_FLASHNODE_IMM_DATA_EN);\niscsi_flashnode_sess_attr(fnode, initial_r2t, ISCSI_FLASHNODE_INITIAL_R2T_EN);\niscsi_flashnode_sess_attr(fnode, data_seq_in_order,\n\t\t\t  ISCSI_FLASHNODE_DATASEQ_INORDER);\niscsi_flashnode_sess_attr(fnode, data_pdu_in_order,\n\t\t\t  ISCSI_FLASHNODE_PDU_INORDER);\niscsi_flashnode_sess_attr(fnode, chap_auth, ISCSI_FLASHNODE_CHAP_AUTH_EN);\niscsi_flashnode_sess_attr(fnode, discovery_logout,\n\t\t\t  ISCSI_FLASHNODE_DISCOVERY_LOGOUT_EN);\niscsi_flashnode_sess_attr(fnode, bidi_chap, ISCSI_FLASHNODE_BIDI_CHAP_EN);\niscsi_flashnode_sess_attr(fnode, discovery_auth_optional,\n\t\t\t  ISCSI_FLASHNODE_DISCOVERY_AUTH_OPTIONAL);\niscsi_flashnode_sess_attr(fnode, erl, ISCSI_FLASHNODE_ERL);\niscsi_flashnode_sess_attr(fnode, first_burst_len, ISCSI_FLASHNODE_FIRST_BURST);\niscsi_flashnode_sess_attr(fnode, def_time2wait, ISCSI_FLASHNODE_DEF_TIME2WAIT);\niscsi_flashnode_sess_attr(fnode, def_time2retain,\n\t\t\t  ISCSI_FLASHNODE_DEF_TIME2RETAIN);\niscsi_flashnode_sess_attr(fnode, max_outstanding_r2t, ISCSI_FLASHNODE_MAX_R2T);\niscsi_flashnode_sess_attr(fnode, isid, ISCSI_FLASHNODE_ISID);\niscsi_flashnode_sess_attr(fnode, tsid, ISCSI_FLASHNODE_TSID);\niscsi_flashnode_sess_attr(fnode, max_burst_len, ISCSI_FLASHNODE_MAX_BURST);\niscsi_flashnode_sess_attr(fnode, def_taskmgmt_tmo,\n\t\t\t  ISCSI_FLASHNODE_DEF_TASKMGMT_TMO);\niscsi_flashnode_sess_attr(fnode, targetalias, ISCSI_FLASHNODE_ALIAS);\niscsi_flashnode_sess_attr(fnode, targetname, ISCSI_FLASHNODE_NAME);\niscsi_flashnode_sess_attr(fnode, tpgt, ISCSI_FLASHNODE_TPGT);\niscsi_flashnode_sess_attr(fnode, discovery_parent_idx,\n\t\t\t  ISCSI_FLASHNODE_DISCOVERY_PARENT_IDX);\niscsi_flashnode_sess_attr(fnode, discovery_parent_type,\n\t\t\t  ISCSI_FLASHNODE_DISCOVERY_PARENT_TYPE);\niscsi_flashnode_sess_attr(fnode, chap_in_idx, ISCSI_FLASHNODE_CHAP_IN_IDX);\niscsi_flashnode_sess_attr(fnode, chap_out_idx, ISCSI_FLASHNODE_CHAP_OUT_IDX);\niscsi_flashnode_sess_attr(fnode, username, ISCSI_FLASHNODE_USERNAME);\niscsi_flashnode_sess_attr(fnode, username_in, ISCSI_FLASHNODE_USERNAME_IN);\niscsi_flashnode_sess_attr(fnode, password, ISCSI_FLASHNODE_PASSWORD);\niscsi_flashnode_sess_attr(fnode, password_in, ISCSI_FLASHNODE_PASSWORD_IN);\niscsi_flashnode_sess_attr(fnode, is_boot_target, ISCSI_FLASHNODE_IS_BOOT_TGT);\n\nstatic struct attribute *iscsi_flashnode_sess_attrs[] = {\n\t&dev_attr_fnode_auto_snd_tgt_disable.attr,\n\t&dev_attr_fnode_discovery_session.attr,\n\t&dev_attr_fnode_portal_type.attr,\n\t&dev_attr_fnode_entry_enable.attr,\n\t&dev_attr_fnode_immediate_data.attr,\n\t&dev_attr_fnode_initial_r2t.attr,\n\t&dev_attr_fnode_data_seq_in_order.attr,\n\t&dev_attr_fnode_data_pdu_in_order.attr,\n\t&dev_attr_fnode_chap_auth.attr,\n\t&dev_attr_fnode_discovery_logout.attr,\n\t&dev_attr_fnode_bidi_chap.attr,\n\t&dev_attr_fnode_discovery_auth_optional.attr,\n\t&dev_attr_fnode_erl.attr,\n\t&dev_attr_fnode_first_burst_len.attr,\n\t&dev_attr_fnode_def_time2wait.attr,\n\t&dev_attr_fnode_def_time2retain.attr,\n\t&dev_attr_fnode_max_outstanding_r2t.attr,\n\t&dev_attr_fnode_isid.attr,\n\t&dev_attr_fnode_tsid.attr,\n\t&dev_attr_fnode_max_burst_len.attr,\n\t&dev_attr_fnode_def_taskmgmt_tmo.attr,\n\t&dev_attr_fnode_targetalias.attr,\n\t&dev_attr_fnode_targetname.attr,\n\t&dev_attr_fnode_tpgt.attr,\n\t&dev_attr_fnode_discovery_parent_idx.attr,\n\t&dev_attr_fnode_discovery_parent_type.attr,\n\t&dev_attr_fnode_chap_in_idx.attr,\n\t&dev_attr_fnode_chap_out_idx.attr,\n\t&dev_attr_fnode_username.attr,\n\t&dev_attr_fnode_username_in.attr,\n\t&dev_attr_fnode_password.attr,\n\t&dev_attr_fnode_password_in.attr,\n\t&dev_attr_fnode_is_boot_target.attr,\n\tNULL,\n};\n\nstatic umode_t iscsi_flashnode_sess_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t\t    struct attribute *attr,\n\t\t\t\t\t\t    int i)\n{\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct iscsi_bus_flash_session *fnode_sess =\n\t\t\t\t\t\tiscsi_dev_to_flash_session(dev);\n\tstruct iscsi_transport *t = fnode_sess->transport;\n\tint param;\n\n\tif (attr == &dev_attr_fnode_auto_snd_tgt_disable.attr) {\n\t\tparam = ISCSI_FLASHNODE_AUTO_SND_TGT_DISABLE;\n\t} else if (attr == &dev_attr_fnode_discovery_session.attr) {\n\t\tparam = ISCSI_FLASHNODE_DISCOVERY_SESS;\n\t} else if (attr == &dev_attr_fnode_portal_type.attr) {\n\t\tparam = ISCSI_FLASHNODE_PORTAL_TYPE;\n\t} else if (attr == &dev_attr_fnode_entry_enable.attr) {\n\t\tparam = ISCSI_FLASHNODE_ENTRY_EN;\n\t} else if (attr == &dev_attr_fnode_immediate_data.attr) {\n\t\tparam = ISCSI_FLASHNODE_IMM_DATA_EN;\n\t} else if (attr == &dev_attr_fnode_initial_r2t.attr) {\n\t\tparam = ISCSI_FLASHNODE_INITIAL_R2T_EN;\n\t} else if (attr == &dev_attr_fnode_data_seq_in_order.attr) {\n\t\tparam = ISCSI_FLASHNODE_DATASEQ_INORDER;\n\t} else if (attr == &dev_attr_fnode_data_pdu_in_order.attr) {\n\t\tparam = ISCSI_FLASHNODE_PDU_INORDER;\n\t} else if (attr == &dev_attr_fnode_chap_auth.attr) {\n\t\tparam = ISCSI_FLASHNODE_CHAP_AUTH_EN;\n\t} else if (attr == &dev_attr_fnode_discovery_logout.attr) {\n\t\tparam = ISCSI_FLASHNODE_DISCOVERY_LOGOUT_EN;\n\t} else if (attr == &dev_attr_fnode_bidi_chap.attr) {\n\t\tparam = ISCSI_FLASHNODE_BIDI_CHAP_EN;\n\t} else if (attr == &dev_attr_fnode_discovery_auth_optional.attr) {\n\t\tparam = ISCSI_FLASHNODE_DISCOVERY_AUTH_OPTIONAL;\n\t} else if (attr == &dev_attr_fnode_erl.attr) {\n\t\tparam = ISCSI_FLASHNODE_ERL;\n\t} else if (attr == &dev_attr_fnode_first_burst_len.attr) {\n\t\tparam = ISCSI_FLASHNODE_FIRST_BURST;\n\t} else if (attr == &dev_attr_fnode_def_time2wait.attr) {\n\t\tparam = ISCSI_FLASHNODE_DEF_TIME2WAIT;\n\t} else if (attr == &dev_attr_fnode_def_time2retain.attr) {\n\t\tparam = ISCSI_FLASHNODE_DEF_TIME2RETAIN;\n\t} else if (attr == &dev_attr_fnode_max_outstanding_r2t.attr) {\n\t\tparam = ISCSI_FLASHNODE_MAX_R2T;\n\t} else if (attr == &dev_attr_fnode_isid.attr) {\n\t\tparam = ISCSI_FLASHNODE_ISID;\n\t} else if (attr == &dev_attr_fnode_tsid.attr) {\n\t\tparam = ISCSI_FLASHNODE_TSID;\n\t} else if (attr == &dev_attr_fnode_max_burst_len.attr) {\n\t\tparam = ISCSI_FLASHNODE_MAX_BURST;\n\t} else if (attr == &dev_attr_fnode_def_taskmgmt_tmo.attr) {\n\t\tparam = ISCSI_FLASHNODE_DEF_TASKMGMT_TMO;\n\t} else if (attr == &dev_attr_fnode_targetalias.attr) {\n\t\tparam = ISCSI_FLASHNODE_ALIAS;\n\t} else if (attr == &dev_attr_fnode_targetname.attr) {\n\t\tparam = ISCSI_FLASHNODE_NAME;\n\t} else if (attr == &dev_attr_fnode_tpgt.attr) {\n\t\tparam = ISCSI_FLASHNODE_TPGT;\n\t} else if (attr == &dev_attr_fnode_discovery_parent_idx.attr) {\n\t\tparam = ISCSI_FLASHNODE_DISCOVERY_PARENT_IDX;\n\t} else if (attr == &dev_attr_fnode_discovery_parent_type.attr) {\n\t\tparam = ISCSI_FLASHNODE_DISCOVERY_PARENT_TYPE;\n\t} else if (attr == &dev_attr_fnode_chap_in_idx.attr) {\n\t\tparam = ISCSI_FLASHNODE_CHAP_IN_IDX;\n\t} else if (attr == &dev_attr_fnode_chap_out_idx.attr) {\n\t\tparam = ISCSI_FLASHNODE_CHAP_OUT_IDX;\n\t} else if (attr == &dev_attr_fnode_username.attr) {\n\t\tparam = ISCSI_FLASHNODE_USERNAME;\n\t} else if (attr == &dev_attr_fnode_username_in.attr) {\n\t\tparam = ISCSI_FLASHNODE_USERNAME_IN;\n\t} else if (attr == &dev_attr_fnode_password.attr) {\n\t\tparam = ISCSI_FLASHNODE_PASSWORD;\n\t} else if (attr == &dev_attr_fnode_password_in.attr) {\n\t\tparam = ISCSI_FLASHNODE_PASSWORD_IN;\n\t} else if (attr == &dev_attr_fnode_is_boot_target.attr) {\n\t\tparam = ISCSI_FLASHNODE_IS_BOOT_TGT;\n\t} else {\n\t\tWARN_ONCE(1, \"Invalid flashnode session attr\");\n\t\treturn 0;\n\t}\n\n\treturn t->attr_is_visible(ISCSI_FLASHNODE_PARAM, param);\n}\n\nstatic struct attribute_group iscsi_flashnode_sess_attr_group = {\n\t.attrs = iscsi_flashnode_sess_attrs,\n\t.is_visible = iscsi_flashnode_sess_attr_is_visible,\n};\n\nstatic const struct attribute_group *iscsi_flashnode_sess_attr_groups[] = {\n\t&iscsi_flashnode_sess_attr_group,\n\tNULL,\n};\n\nstatic void iscsi_flashnode_sess_release(struct device *dev)\n{\n\tstruct iscsi_bus_flash_session *fnode_sess =\n\t\t\t\t\t\tiscsi_dev_to_flash_session(dev);\n\n\tkfree(fnode_sess->targetname);\n\tkfree(fnode_sess->targetalias);\n\tkfree(fnode_sess->portal_type);\n\tkfree(fnode_sess);\n}\n\nstatic const struct device_type iscsi_flashnode_sess_dev_type = {\n\t.name = \"iscsi_flashnode_sess_dev_type\",\n\t.groups = iscsi_flashnode_sess_attr_groups,\n\t.release = iscsi_flashnode_sess_release,\n};\n\n \n#define iscsi_flashnode_conn_attr_show(type, name, param)\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_##type##_##name(struct device *dev, struct device_attribute *attr,\t\\\n\t\t     char *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct iscsi_bus_flash_conn *fnode_conn = iscsi_dev_to_flash_conn(dev);\\\n\tstruct iscsi_bus_flash_session *fnode_sess =\t\t\t\\\n\t\t\t\tiscsi_flash_conn_to_flash_session(fnode_conn);\\\n\tstruct iscsi_transport *t = fnode_conn->transport;\t\t\\\n\treturn t->get_flashnode_param(fnode_sess, param, buf);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\n\n#define iscsi_flashnode_conn_attr(type, name, param)\t\t\t\\\n\tiscsi_flashnode_conn_attr_show(type, name, param)\t\t\\\nstatic ISCSI_FLASHNODE_ATTR(type, name, S_IRUGO,\t\t\t\\\n\t\t\t    show_##type##_##name, NULL);\n\n \n\niscsi_flashnode_conn_attr(fnode, is_fw_assigned_ipv6,\n\t\t\t  ISCSI_FLASHNODE_IS_FW_ASSIGNED_IPV6);\niscsi_flashnode_conn_attr(fnode, header_digest, ISCSI_FLASHNODE_HDR_DGST_EN);\niscsi_flashnode_conn_attr(fnode, data_digest, ISCSI_FLASHNODE_DATA_DGST_EN);\niscsi_flashnode_conn_attr(fnode, snack_req, ISCSI_FLASHNODE_SNACK_REQ_EN);\niscsi_flashnode_conn_attr(fnode, tcp_timestamp_stat,\n\t\t\t  ISCSI_FLASHNODE_TCP_TIMESTAMP_STAT);\niscsi_flashnode_conn_attr(fnode, tcp_nagle_disable,\n\t\t\t  ISCSI_FLASHNODE_TCP_NAGLE_DISABLE);\niscsi_flashnode_conn_attr(fnode, tcp_wsf_disable,\n\t\t\t  ISCSI_FLASHNODE_TCP_WSF_DISABLE);\niscsi_flashnode_conn_attr(fnode, tcp_timer_scale,\n\t\t\t  ISCSI_FLASHNODE_TCP_TIMER_SCALE);\niscsi_flashnode_conn_attr(fnode, tcp_timestamp_enable,\n\t\t\t  ISCSI_FLASHNODE_TCP_TIMESTAMP_EN);\niscsi_flashnode_conn_attr(fnode, fragment_disable,\n\t\t\t  ISCSI_FLASHNODE_IP_FRAG_DISABLE);\niscsi_flashnode_conn_attr(fnode, keepalive_tmo, ISCSI_FLASHNODE_KEEPALIVE_TMO);\niscsi_flashnode_conn_attr(fnode, port, ISCSI_FLASHNODE_PORT);\niscsi_flashnode_conn_attr(fnode, ipaddress, ISCSI_FLASHNODE_IPADDR);\niscsi_flashnode_conn_attr(fnode, max_recv_dlength,\n\t\t\t  ISCSI_FLASHNODE_MAX_RECV_DLENGTH);\niscsi_flashnode_conn_attr(fnode, max_xmit_dlength,\n\t\t\t  ISCSI_FLASHNODE_MAX_XMIT_DLENGTH);\niscsi_flashnode_conn_attr(fnode, local_port, ISCSI_FLASHNODE_LOCAL_PORT);\niscsi_flashnode_conn_attr(fnode, ipv4_tos, ISCSI_FLASHNODE_IPV4_TOS);\niscsi_flashnode_conn_attr(fnode, ipv6_traffic_class, ISCSI_FLASHNODE_IPV6_TC);\niscsi_flashnode_conn_attr(fnode, ipv6_flow_label,\n\t\t\t  ISCSI_FLASHNODE_IPV6_FLOW_LABEL);\niscsi_flashnode_conn_attr(fnode, redirect_ipaddr,\n\t\t\t  ISCSI_FLASHNODE_REDIRECT_IPADDR);\niscsi_flashnode_conn_attr(fnode, max_segment_size,\n\t\t\t  ISCSI_FLASHNODE_MAX_SEGMENT_SIZE);\niscsi_flashnode_conn_attr(fnode, link_local_ipv6,\n\t\t\t  ISCSI_FLASHNODE_LINK_LOCAL_IPV6);\niscsi_flashnode_conn_attr(fnode, tcp_xmit_wsf, ISCSI_FLASHNODE_TCP_XMIT_WSF);\niscsi_flashnode_conn_attr(fnode, tcp_recv_wsf, ISCSI_FLASHNODE_TCP_RECV_WSF);\niscsi_flashnode_conn_attr(fnode, statsn, ISCSI_FLASHNODE_STATSN);\niscsi_flashnode_conn_attr(fnode, exp_statsn, ISCSI_FLASHNODE_EXP_STATSN);\n\nstatic struct attribute *iscsi_flashnode_conn_attrs[] = {\n\t&dev_attr_fnode_is_fw_assigned_ipv6.attr,\n\t&dev_attr_fnode_header_digest.attr,\n\t&dev_attr_fnode_data_digest.attr,\n\t&dev_attr_fnode_snack_req.attr,\n\t&dev_attr_fnode_tcp_timestamp_stat.attr,\n\t&dev_attr_fnode_tcp_nagle_disable.attr,\n\t&dev_attr_fnode_tcp_wsf_disable.attr,\n\t&dev_attr_fnode_tcp_timer_scale.attr,\n\t&dev_attr_fnode_tcp_timestamp_enable.attr,\n\t&dev_attr_fnode_fragment_disable.attr,\n\t&dev_attr_fnode_max_recv_dlength.attr,\n\t&dev_attr_fnode_max_xmit_dlength.attr,\n\t&dev_attr_fnode_keepalive_tmo.attr,\n\t&dev_attr_fnode_port.attr,\n\t&dev_attr_fnode_ipaddress.attr,\n\t&dev_attr_fnode_redirect_ipaddr.attr,\n\t&dev_attr_fnode_max_segment_size.attr,\n\t&dev_attr_fnode_local_port.attr,\n\t&dev_attr_fnode_ipv4_tos.attr,\n\t&dev_attr_fnode_ipv6_traffic_class.attr,\n\t&dev_attr_fnode_ipv6_flow_label.attr,\n\t&dev_attr_fnode_link_local_ipv6.attr,\n\t&dev_attr_fnode_tcp_xmit_wsf.attr,\n\t&dev_attr_fnode_tcp_recv_wsf.attr,\n\t&dev_attr_fnode_statsn.attr,\n\t&dev_attr_fnode_exp_statsn.attr,\n\tNULL,\n};\n\nstatic umode_t iscsi_flashnode_conn_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t\t    struct attribute *attr,\n\t\t\t\t\t\t    int i)\n{\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct iscsi_bus_flash_conn *fnode_conn = iscsi_dev_to_flash_conn(dev);\n\tstruct iscsi_transport *t = fnode_conn->transport;\n\tint param;\n\n\tif (attr == &dev_attr_fnode_is_fw_assigned_ipv6.attr) {\n\t\tparam = ISCSI_FLASHNODE_IS_FW_ASSIGNED_IPV6;\n\t} else if (attr == &dev_attr_fnode_header_digest.attr) {\n\t\tparam = ISCSI_FLASHNODE_HDR_DGST_EN;\n\t} else if (attr == &dev_attr_fnode_data_digest.attr) {\n\t\tparam = ISCSI_FLASHNODE_DATA_DGST_EN;\n\t} else if (attr == &dev_attr_fnode_snack_req.attr) {\n\t\tparam = ISCSI_FLASHNODE_SNACK_REQ_EN;\n\t} else if (attr == &dev_attr_fnode_tcp_timestamp_stat.attr) {\n\t\tparam = ISCSI_FLASHNODE_TCP_TIMESTAMP_STAT;\n\t} else if (attr == &dev_attr_fnode_tcp_nagle_disable.attr) {\n\t\tparam = ISCSI_FLASHNODE_TCP_NAGLE_DISABLE;\n\t} else if (attr == &dev_attr_fnode_tcp_wsf_disable.attr) {\n\t\tparam = ISCSI_FLASHNODE_TCP_WSF_DISABLE;\n\t} else if (attr == &dev_attr_fnode_tcp_timer_scale.attr) {\n\t\tparam = ISCSI_FLASHNODE_TCP_TIMER_SCALE;\n\t} else if (attr == &dev_attr_fnode_tcp_timestamp_enable.attr) {\n\t\tparam = ISCSI_FLASHNODE_TCP_TIMESTAMP_EN;\n\t} else if (attr == &dev_attr_fnode_fragment_disable.attr) {\n\t\tparam = ISCSI_FLASHNODE_IP_FRAG_DISABLE;\n\t} else if (attr == &dev_attr_fnode_max_recv_dlength.attr) {\n\t\tparam = ISCSI_FLASHNODE_MAX_RECV_DLENGTH;\n\t} else if (attr == &dev_attr_fnode_max_xmit_dlength.attr) {\n\t\tparam = ISCSI_FLASHNODE_MAX_XMIT_DLENGTH;\n\t} else if (attr == &dev_attr_fnode_keepalive_tmo.attr) {\n\t\tparam = ISCSI_FLASHNODE_KEEPALIVE_TMO;\n\t} else if (attr == &dev_attr_fnode_port.attr) {\n\t\tparam = ISCSI_FLASHNODE_PORT;\n\t} else if (attr == &dev_attr_fnode_ipaddress.attr) {\n\t\tparam = ISCSI_FLASHNODE_IPADDR;\n\t} else if (attr == &dev_attr_fnode_redirect_ipaddr.attr) {\n\t\tparam = ISCSI_FLASHNODE_REDIRECT_IPADDR;\n\t} else if (attr == &dev_attr_fnode_max_segment_size.attr) {\n\t\tparam = ISCSI_FLASHNODE_MAX_SEGMENT_SIZE;\n\t} else if (attr == &dev_attr_fnode_local_port.attr) {\n\t\tparam = ISCSI_FLASHNODE_LOCAL_PORT;\n\t} else if (attr == &dev_attr_fnode_ipv4_tos.attr) {\n\t\tparam = ISCSI_FLASHNODE_IPV4_TOS;\n\t} else if (attr == &dev_attr_fnode_ipv6_traffic_class.attr) {\n\t\tparam = ISCSI_FLASHNODE_IPV6_TC;\n\t} else if (attr == &dev_attr_fnode_ipv6_flow_label.attr) {\n\t\tparam = ISCSI_FLASHNODE_IPV6_FLOW_LABEL;\n\t} else if (attr == &dev_attr_fnode_link_local_ipv6.attr) {\n\t\tparam = ISCSI_FLASHNODE_LINK_LOCAL_IPV6;\n\t} else if (attr == &dev_attr_fnode_tcp_xmit_wsf.attr) {\n\t\tparam = ISCSI_FLASHNODE_TCP_XMIT_WSF;\n\t} else if (attr == &dev_attr_fnode_tcp_recv_wsf.attr) {\n\t\tparam = ISCSI_FLASHNODE_TCP_RECV_WSF;\n\t} else if (attr == &dev_attr_fnode_statsn.attr) {\n\t\tparam = ISCSI_FLASHNODE_STATSN;\n\t} else if (attr == &dev_attr_fnode_exp_statsn.attr) {\n\t\tparam = ISCSI_FLASHNODE_EXP_STATSN;\n\t} else {\n\t\tWARN_ONCE(1, \"Invalid flashnode connection attr\");\n\t\treturn 0;\n\t}\n\n\treturn t->attr_is_visible(ISCSI_FLASHNODE_PARAM, param);\n}\n\nstatic struct attribute_group iscsi_flashnode_conn_attr_group = {\n\t.attrs = iscsi_flashnode_conn_attrs,\n\t.is_visible = iscsi_flashnode_conn_attr_is_visible,\n};\n\nstatic const struct attribute_group *iscsi_flashnode_conn_attr_groups[] = {\n\t&iscsi_flashnode_conn_attr_group,\n\tNULL,\n};\n\nstatic void iscsi_flashnode_conn_release(struct device *dev)\n{\n\tstruct iscsi_bus_flash_conn *fnode_conn = iscsi_dev_to_flash_conn(dev);\n\n\tkfree(fnode_conn->ipaddress);\n\tkfree(fnode_conn->redirect_ipaddr);\n\tkfree(fnode_conn->link_local_ipv6_addr);\n\tkfree(fnode_conn);\n}\n\nstatic const struct device_type iscsi_flashnode_conn_dev_type = {\n\t.name = \"iscsi_flashnode_conn_dev_type\",\n\t.groups = iscsi_flashnode_conn_attr_groups,\n\t.release = iscsi_flashnode_conn_release,\n};\n\nstatic struct bus_type iscsi_flashnode_bus;\n\nint iscsi_flashnode_bus_match(struct device *dev,\n\t\t\t\t     struct device_driver *drv)\n{\n\tif (dev->bus == &iscsi_flashnode_bus)\n\t\treturn 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iscsi_flashnode_bus_match);\n\nstatic struct bus_type iscsi_flashnode_bus = {\n\t.name = \"iscsi_flashnode\",\n\t.match = &iscsi_flashnode_bus_match,\n};\n\n \nstruct iscsi_bus_flash_session *\niscsi_create_flashnode_sess(struct Scsi_Host *shost, int index,\n\t\t\t    struct iscsi_transport *transport,\n\t\t\t    int dd_size)\n{\n\tstruct iscsi_bus_flash_session *fnode_sess;\n\tint err;\n\n\tfnode_sess = kzalloc(sizeof(*fnode_sess) + dd_size, GFP_KERNEL);\n\tif (!fnode_sess)\n\t\treturn NULL;\n\n\tfnode_sess->transport = transport;\n\tfnode_sess->target_id = index;\n\tfnode_sess->dev.type = &iscsi_flashnode_sess_dev_type;\n\tfnode_sess->dev.bus = &iscsi_flashnode_bus;\n\tfnode_sess->dev.parent = &shost->shost_gendev;\n\tdev_set_name(&fnode_sess->dev, \"flashnode_sess-%u:%u\",\n\t\t     shost->host_no, index);\n\n\terr = device_register(&fnode_sess->dev);\n\tif (err)\n\t\tgoto put_dev;\n\n\tif (dd_size)\n\t\tfnode_sess->dd_data = &fnode_sess[1];\n\n\treturn fnode_sess;\n\nput_dev:\n\tput_device(&fnode_sess->dev);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(iscsi_create_flashnode_sess);\n\n \nstruct iscsi_bus_flash_conn *\niscsi_create_flashnode_conn(struct Scsi_Host *shost,\n\t\t\t    struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t    struct iscsi_transport *transport,\n\t\t\t    int dd_size)\n{\n\tstruct iscsi_bus_flash_conn *fnode_conn;\n\tint err;\n\n\tfnode_conn = kzalloc(sizeof(*fnode_conn) + dd_size, GFP_KERNEL);\n\tif (!fnode_conn)\n\t\treturn NULL;\n\n\tfnode_conn->transport = transport;\n\tfnode_conn->dev.type = &iscsi_flashnode_conn_dev_type;\n\tfnode_conn->dev.bus = &iscsi_flashnode_bus;\n\tfnode_conn->dev.parent = &fnode_sess->dev;\n\tdev_set_name(&fnode_conn->dev, \"flashnode_conn-%u:%u:0\",\n\t\t     shost->host_no, fnode_sess->target_id);\n\n\terr = device_register(&fnode_conn->dev);\n\tif (err)\n\t\tgoto put_dev;\n\n\tif (dd_size)\n\t\tfnode_conn->dd_data = &fnode_conn[1];\n\n\treturn fnode_conn;\n\nput_dev:\n\tput_device(&fnode_conn->dev);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(iscsi_create_flashnode_conn);\n\n \nstatic int iscsi_is_flashnode_conn_dev(struct device *dev, void *data)\n{\n\treturn dev->bus == &iscsi_flashnode_bus;\n}\n\nstatic int iscsi_destroy_flashnode_conn(struct iscsi_bus_flash_conn *fnode_conn)\n{\n\tdevice_unregister(&fnode_conn->dev);\n\treturn 0;\n}\n\nstatic int flashnode_match_index(struct device *dev, void *data)\n{\n\tstruct iscsi_bus_flash_session *fnode_sess = NULL;\n\tint ret = 0;\n\n\tif (!iscsi_flashnode_bus_match(dev, NULL))\n\t\tgoto exit_match_index;\n\n\tfnode_sess = iscsi_dev_to_flash_session(dev);\n\tret = (fnode_sess->target_id == *((int *)data)) ? 1 : 0;\n\nexit_match_index:\n\treturn ret;\n}\n\n \nstatic struct iscsi_bus_flash_session *\niscsi_get_flashnode_by_index(struct Scsi_Host *shost, uint32_t idx)\n{\n\tstruct iscsi_bus_flash_session *fnode_sess = NULL;\n\tstruct device *dev;\n\n\tdev = device_find_child(&shost->shost_gendev, &idx,\n\t\t\t\tflashnode_match_index);\n\tif (dev)\n\t\tfnode_sess = iscsi_dev_to_flash_session(dev);\n\n\treturn fnode_sess;\n}\n\n \nstruct device *\niscsi_find_flashnode_sess(struct Scsi_Host *shost, void *data,\n\t\t\t  int (*fn)(struct device *dev, void *data))\n{\n\treturn device_find_child(&shost->shost_gendev, data, fn);\n}\nEXPORT_SYMBOL_GPL(iscsi_find_flashnode_sess);\n\n \nstruct device *\niscsi_find_flashnode_conn(struct iscsi_bus_flash_session *fnode_sess)\n{\n\treturn device_find_child(&fnode_sess->dev, NULL,\n\t\t\t\t iscsi_is_flashnode_conn_dev);\n}\nEXPORT_SYMBOL_GPL(iscsi_find_flashnode_conn);\n\nstatic int iscsi_iter_destroy_flashnode_conn_fn(struct device *dev, void *data)\n{\n\tif (!iscsi_is_flashnode_conn_dev(dev, NULL))\n\t\treturn 0;\n\n\treturn iscsi_destroy_flashnode_conn(iscsi_dev_to_flash_conn(dev));\n}\n\n \nvoid iscsi_destroy_flashnode_sess(struct iscsi_bus_flash_session *fnode_sess)\n{\n\tint err;\n\n\terr = device_for_each_child(&fnode_sess->dev, NULL,\n\t\t\t\t    iscsi_iter_destroy_flashnode_conn_fn);\n\tif (err)\n\t\tpr_err(\"Could not delete all connections for %s. Error %d.\\n\",\n\t\t       fnode_sess->dev.kobj.name, err);\n\n\tdevice_unregister(&fnode_sess->dev);\n}\nEXPORT_SYMBOL_GPL(iscsi_destroy_flashnode_sess);\n\nstatic int iscsi_iter_destroy_flashnode_fn(struct device *dev, void *data)\n{\n\tif (!iscsi_flashnode_bus_match(dev, NULL))\n\t\treturn 0;\n\n\tiscsi_destroy_flashnode_sess(iscsi_dev_to_flash_session(dev));\n\treturn 0;\n}\n\n \nvoid iscsi_destroy_all_flashnode(struct Scsi_Host *shost)\n{\n\tdevice_for_each_child(&shost->shost_gendev, NULL,\n\t\t\t      iscsi_iter_destroy_flashnode_fn);\n}\nEXPORT_SYMBOL_GPL(iscsi_destroy_all_flashnode);\n\n \n \nstatic int iscsi_bsg_host_dispatch(struct bsg_job *job)\n{\n\tstruct Scsi_Host *shost = iscsi_job_to_shost(job);\n\tstruct iscsi_bsg_request *req = job->request;\n\tstruct iscsi_bsg_reply *reply = job->reply;\n\tstruct iscsi_internal *i = to_iscsi_internal(shost->transportt);\n\tint cmdlen = sizeof(uint32_t);\t \n\tint ret;\n\n\t \n\tif (job->request_len < sizeof(uint32_t)) {\n\t\tret = -ENOMSG;\n\t\tgoto fail_host_msg;\n\t}\n\n\t \n\tswitch (req->msgcode) {\n\tcase ISCSI_BSG_HST_VENDOR:\n\t\tcmdlen += sizeof(struct iscsi_bsg_host_vendor);\n\t\tif ((shost->hostt->vendor_id == 0L) ||\n\t\t    (req->rqst_data.h_vendor.vendor_id !=\n\t\t\tshost->hostt->vendor_id)) {\n\t\t\tret = -ESRCH;\n\t\t\tgoto fail_host_msg;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EBADR;\n\t\tgoto fail_host_msg;\n\t}\n\n\t \n\tif (job->request_len < cmdlen) {\n\t\tret = -ENOMSG;\n\t\tgoto fail_host_msg;\n\t}\n\n\tret = i->iscsi_transport->bsg_request(job);\n\tif (!ret)\n\t\treturn 0;\n\nfail_host_msg:\n\t \n\tBUG_ON(job->reply_len < sizeof(uint32_t));\n\treply->reply_payload_rcv_len = 0;\n\treply->result = ret;\n\tjob->reply_len = sizeof(uint32_t);\n\tbsg_job_done(job, ret, 0);\n\treturn 0;\n}\n\n \nstatic int\niscsi_bsg_host_add(struct Scsi_Host *shost, struct iscsi_cls_host *ihost)\n{\n\tstruct device *dev = &shost->shost_gendev;\n\tstruct iscsi_internal *i = to_iscsi_internal(shost->transportt);\n\tstruct request_queue *q;\n\tchar bsg_name[20];\n\n\tif (!i->iscsi_transport->bsg_request)\n\t\treturn -ENOTSUPP;\n\n\tsnprintf(bsg_name, sizeof(bsg_name), \"iscsi_host%d\", shost->host_no);\n\tq = bsg_setup_queue(dev, bsg_name, iscsi_bsg_host_dispatch, NULL, 0);\n\tif (IS_ERR(q)) {\n\t\tshost_printk(KERN_ERR, shost, \"bsg interface failed to \"\n\t\t\t     \"initialize - no request queue\\n\");\n\t\treturn PTR_ERR(q);\n\t}\n\t__scsi_init_queue(shost, q);\n\n\tihost->bsg_q = q;\n\treturn 0;\n}\n\nstatic int iscsi_setup_host(struct transport_container *tc, struct device *dev,\n\t\t\t    struct device *cdev)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(dev);\n\tstruct iscsi_cls_host *ihost = shost->shost_data;\n\n\tmemset(ihost, 0, sizeof(*ihost));\n\tmutex_init(&ihost->mutex);\n\n\tiscsi_bsg_host_add(shost, ihost);\n\t \n\n\treturn 0;\n}\n\nstatic int iscsi_remove_host(struct transport_container *tc,\n\t\t\t     struct device *dev, struct device *cdev)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(dev);\n\tstruct iscsi_cls_host *ihost = shost->shost_data;\n\n\tbsg_remove_queue(ihost->bsg_q);\n\treturn 0;\n}\n\nstatic DECLARE_TRANSPORT_CLASS(iscsi_host_class,\n\t\t\t       \"iscsi_host\",\n\t\t\t       iscsi_setup_host,\n\t\t\t       iscsi_remove_host,\n\t\t\t       NULL);\n\nstatic DECLARE_TRANSPORT_CLASS(iscsi_session_class,\n\t\t\t       \"iscsi_session\",\n\t\t\t       NULL,\n\t\t\t       NULL,\n\t\t\t       NULL);\n\nstatic DECLARE_TRANSPORT_CLASS(iscsi_connection_class,\n\t\t\t       \"iscsi_connection\",\n\t\t\t       NULL,\n\t\t\t       NULL,\n\t\t\t       NULL);\n\nstatic struct sock *nls;\nstatic DEFINE_MUTEX(rx_queue_mutex);\n\nstatic LIST_HEAD(sesslist);\nstatic DEFINE_SPINLOCK(sesslock);\nstatic LIST_HEAD(connlist);\nstatic LIST_HEAD(connlist_err);\nstatic DEFINE_SPINLOCK(connlock);\n\nstatic uint32_t iscsi_conn_get_sid(struct iscsi_cls_conn *conn)\n{\n\tstruct iscsi_cls_session *sess = iscsi_dev_to_session(conn->dev.parent);\n\treturn sess->sid;\n}\n\n \nstatic struct iscsi_cls_session *iscsi_session_lookup(uint32_t sid)\n{\n\tunsigned long flags;\n\tstruct iscsi_cls_session *sess;\n\n\tspin_lock_irqsave(&sesslock, flags);\n\tlist_for_each_entry(sess, &sesslist, sess_list) {\n\t\tif (sess->sid == sid) {\n\t\t\tspin_unlock_irqrestore(&sesslock, flags);\n\t\t\treturn sess;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&sesslock, flags);\n\treturn NULL;\n}\n\n \nstatic struct iscsi_cls_conn *iscsi_conn_lookup(uint32_t sid, uint32_t cid)\n{\n\tunsigned long flags;\n\tstruct iscsi_cls_conn *conn;\n\n\tspin_lock_irqsave(&connlock, flags);\n\tlist_for_each_entry(conn, &connlist, conn_list) {\n\t\tif ((conn->cid == cid) && (iscsi_conn_get_sid(conn) == sid)) {\n\t\t\tspin_unlock_irqrestore(&connlock, flags);\n\t\t\treturn conn;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&connlock, flags);\n\treturn NULL;\n}\n\n \nstatic struct {\n\tint value;\n\tchar *name;\n} iscsi_session_state_names[] = {\n\t{ ISCSI_SESSION_LOGGED_IN,\t\"LOGGED_IN\" },\n\t{ ISCSI_SESSION_FAILED,\t\t\"FAILED\" },\n\t{ ISCSI_SESSION_FREE,\t\t\"FREE\" },\n};\n\nstatic const char *iscsi_session_state_name(int state)\n{\n\tint i;\n\tchar *name = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(iscsi_session_state_names); i++) {\n\t\tif (iscsi_session_state_names[i].value == state) {\n\t\t\tname = iscsi_session_state_names[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn name;\n}\n\nstatic char *iscsi_session_target_state_name[] = {\n\t[ISCSI_SESSION_TARGET_UNBOUND]   = \"UNBOUND\",\n\t[ISCSI_SESSION_TARGET_ALLOCATED] = \"ALLOCATED\",\n\t[ISCSI_SESSION_TARGET_SCANNED]   = \"SCANNED\",\n\t[ISCSI_SESSION_TARGET_UNBINDING] = \"UNBINDING\",\n};\n\nint iscsi_session_chkready(struct iscsi_cls_session *session)\n{\n\tint err;\n\n\tswitch (session->state) {\n\tcase ISCSI_SESSION_LOGGED_IN:\n\t\terr = 0;\n\t\tbreak;\n\tcase ISCSI_SESSION_FAILED:\n\t\terr = DID_IMM_RETRY << 16;\n\t\tbreak;\n\tcase ISCSI_SESSION_FREE:\n\t\terr = DID_TRANSPORT_FAILFAST << 16;\n\t\tbreak;\n\tdefault:\n\t\terr = DID_NO_CONNECT << 16;\n\t\tbreak;\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(iscsi_session_chkready);\n\nint iscsi_is_session_online(struct iscsi_cls_session *session)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&session->lock, flags);\n\tif (session->state == ISCSI_SESSION_LOGGED_IN)\n\t\tret = 1;\n\tspin_unlock_irqrestore(&session->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iscsi_is_session_online);\n\nstatic void iscsi_session_release(struct device *dev)\n{\n\tstruct iscsi_cls_session *session = iscsi_dev_to_session(dev);\n\tstruct Scsi_Host *shost;\n\n\tshost = iscsi_session_to_shost(session);\n\tscsi_host_put(shost);\n\tISCSI_DBG_TRANS_SESSION(session, \"Completing session release\\n\");\n\tkfree(session);\n}\n\nint iscsi_is_session_dev(const struct device *dev)\n{\n\treturn dev->release == iscsi_session_release;\n}\nEXPORT_SYMBOL_GPL(iscsi_is_session_dev);\n\nstatic int iscsi_iter_session_fn(struct device *dev, void *data)\n{\n\tvoid (* fn) (struct iscsi_cls_session *) = data;\n\n\tif (!iscsi_is_session_dev(dev))\n\t\treturn 0;\n\tfn(iscsi_dev_to_session(dev));\n\treturn 0;\n}\n\nvoid iscsi_host_for_each_session(struct Scsi_Host *shost,\n\t\t\t\t void (*fn)(struct iscsi_cls_session *))\n{\n\tdevice_for_each_child(&shost->shost_gendev, fn,\n\t\t\t      iscsi_iter_session_fn);\n}\nEXPORT_SYMBOL_GPL(iscsi_host_for_each_session);\n\nstruct iscsi_scan_data {\n\tunsigned int channel;\n\tunsigned int id;\n\tu64 lun;\n\tenum scsi_scan_mode rescan;\n};\n\nstatic int iscsi_user_scan_session(struct device *dev, void *data)\n{\n\tstruct iscsi_scan_data *scan_data = data;\n\tstruct iscsi_cls_session *session;\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_cls_host *ihost;\n\tunsigned long flags;\n\tunsigned int id;\n\n\tif (!iscsi_is_session_dev(dev))\n\t\treturn 0;\n\n\tsession = iscsi_dev_to_session(dev);\n\n\tISCSI_DBG_TRANS_SESSION(session, \"Scanning session\\n\");\n\n\tshost = iscsi_session_to_shost(session);\n\tihost = shost->shost_data;\n\n\tmutex_lock(&ihost->mutex);\n\tspin_lock_irqsave(&session->lock, flags);\n\tif (session->state != ISCSI_SESSION_LOGGED_IN) {\n\t\tspin_unlock_irqrestore(&session->lock, flags);\n\t\tgoto user_scan_exit;\n\t}\n\tid = session->target_id;\n\tspin_unlock_irqrestore(&session->lock, flags);\n\n\tif (id != ISCSI_MAX_TARGET) {\n\t\tif ((scan_data->channel == SCAN_WILD_CARD ||\n\t\t     scan_data->channel == 0) &&\n\t\t    (scan_data->id == SCAN_WILD_CARD ||\n\t\t     scan_data->id == id)) {\n\t\t\tscsi_scan_target(&session->dev, 0, id,\n\t\t\t\t\t scan_data->lun, scan_data->rescan);\n\t\t\tspin_lock_irqsave(&session->lock, flags);\n\t\t\tsession->target_state = ISCSI_SESSION_TARGET_SCANNED;\n\t\t\tspin_unlock_irqrestore(&session->lock, flags);\n\t\t}\n\t}\n\nuser_scan_exit:\n\tmutex_unlock(&ihost->mutex);\n\tISCSI_DBG_TRANS_SESSION(session, \"Completed session scan\\n\");\n\treturn 0;\n}\n\nstatic int iscsi_user_scan(struct Scsi_Host *shost, uint channel,\n\t\t\t   uint id, u64 lun)\n{\n\tstruct iscsi_scan_data scan_data;\n\n\tscan_data.channel = channel;\n\tscan_data.id = id;\n\tscan_data.lun = lun;\n\tscan_data.rescan = SCSI_SCAN_MANUAL;\n\n\treturn device_for_each_child(&shost->shost_gendev, &scan_data,\n\t\t\t\t     iscsi_user_scan_session);\n}\n\nstatic void iscsi_scan_session(struct work_struct *work)\n{\n\tstruct iscsi_cls_session *session =\n\t\t\tcontainer_of(work, struct iscsi_cls_session, scan_work);\n\tstruct iscsi_scan_data scan_data;\n\n\tscan_data.channel = 0;\n\tscan_data.id = SCAN_WILD_CARD;\n\tscan_data.lun = SCAN_WILD_CARD;\n\tscan_data.rescan = SCSI_SCAN_RESCAN;\n\n\tiscsi_user_scan_session(&session->dev, &scan_data);\n}\n\n \nint iscsi_block_scsi_eh(struct scsi_cmnd *cmd)\n{\n\tstruct iscsi_cls_session *session =\n\t\t\tstarget_to_session(scsi_target(cmd->device));\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&session->lock, flags);\n\twhile (session->state != ISCSI_SESSION_LOGGED_IN) {\n\t\tif (session->state == ISCSI_SESSION_FREE) {\n\t\t\tret = FAST_IO_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&session->lock, flags);\n\t\tmsleep(1000);\n\t\tspin_lock_irqsave(&session->lock, flags);\n\t}\n\tspin_unlock_irqrestore(&session->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iscsi_block_scsi_eh);\n\nstatic void session_recovery_timedout(struct work_struct *work)\n{\n\tstruct iscsi_cls_session *session =\n\t\tcontainer_of(work, struct iscsi_cls_session,\n\t\t\t     recovery_work.work);\n\tunsigned long flags;\n\n\tiscsi_cls_session_printk(KERN_INFO, session,\n\t\t\t\t \"session recovery timed out after %d secs\\n\",\n\t\t\t\t session->recovery_tmo);\n\n\tspin_lock_irqsave(&session->lock, flags);\n\tswitch (session->state) {\n\tcase ISCSI_SESSION_FAILED:\n\t\tsession->state = ISCSI_SESSION_FREE;\n\t\tbreak;\n\tcase ISCSI_SESSION_LOGGED_IN:\n\tcase ISCSI_SESSION_FREE:\n\t\t \n\t\tspin_unlock_irqrestore(&session->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&session->lock, flags);\n\n\tISCSI_DBG_TRANS_SESSION(session, \"Unblocking SCSI target\\n\");\n\tscsi_target_unblock(&session->dev, SDEV_TRANSPORT_OFFLINE);\n\tISCSI_DBG_TRANS_SESSION(session, \"Completed unblocking SCSI target\\n\");\n\n\tif (session->transport->session_recovery_timedout)\n\t\tsession->transport->session_recovery_timedout(session);\n}\n\nstatic void __iscsi_unblock_session(struct work_struct *work)\n{\n\tstruct iscsi_cls_session *session =\n\t\t\tcontainer_of(work, struct iscsi_cls_session,\n\t\t\t\t     unblock_work);\n\tunsigned long flags;\n\n\tISCSI_DBG_TRANS_SESSION(session, \"Unblocking session\\n\");\n\n\tcancel_delayed_work_sync(&session->recovery_work);\n\tspin_lock_irqsave(&session->lock, flags);\n\tsession->state = ISCSI_SESSION_LOGGED_IN;\n\tspin_unlock_irqrestore(&session->lock, flags);\n\t \n\tscsi_target_unblock(&session->dev, SDEV_RUNNING);\n\tISCSI_DBG_TRANS_SESSION(session, \"Completed unblocking session\\n\");\n}\n\n \nvoid iscsi_unblock_session(struct iscsi_cls_session *session)\n{\n\tif (!cancel_work_sync(&session->block_work))\n\t\tcancel_delayed_work_sync(&session->recovery_work);\n\n\tqueue_work(session->workq, &session->unblock_work);\n\t \n\tflush_work(&session->unblock_work);\n}\nEXPORT_SYMBOL_GPL(iscsi_unblock_session);\n\nstatic void __iscsi_block_session(struct work_struct *work)\n{\n\tstruct iscsi_cls_session *session =\n\t\t\tcontainer_of(work, struct iscsi_cls_session,\n\t\t\t\t     block_work);\n\tstruct Scsi_Host *shost = iscsi_session_to_shost(session);\n\tunsigned long flags;\n\n\tISCSI_DBG_TRANS_SESSION(session, \"Blocking session\\n\");\n\tspin_lock_irqsave(&session->lock, flags);\n\tsession->state = ISCSI_SESSION_FAILED;\n\tspin_unlock_irqrestore(&session->lock, flags);\n\tscsi_block_targets(shost, &session->dev);\n\tISCSI_DBG_TRANS_SESSION(session, \"Completed SCSI target blocking\\n\");\n\tif (session->recovery_tmo >= 0)\n\t\tqueue_delayed_work(session->workq,\n\t\t\t\t   &session->recovery_work,\n\t\t\t\t   session->recovery_tmo * HZ);\n}\n\nvoid iscsi_block_session(struct iscsi_cls_session *session)\n{\n\tqueue_work(session->workq, &session->block_work);\n}\nEXPORT_SYMBOL_GPL(iscsi_block_session);\n\nstatic void __iscsi_unbind_session(struct work_struct *work)\n{\n\tstruct iscsi_cls_session *session =\n\t\t\tcontainer_of(work, struct iscsi_cls_session,\n\t\t\t\t     unbind_work);\n\tstruct Scsi_Host *shost = iscsi_session_to_shost(session);\n\tstruct iscsi_cls_host *ihost = shost->shost_data;\n\tunsigned long flags;\n\tunsigned int target_id;\n\tbool remove_target = true;\n\n\tISCSI_DBG_TRANS_SESSION(session, \"Unbinding session\\n\");\n\n\t \n\tmutex_lock(&ihost->mutex);\n\tspin_lock_irqsave(&session->lock, flags);\n\tif (session->target_state == ISCSI_SESSION_TARGET_ALLOCATED) {\n\t\tremove_target = false;\n\t} else if (session->target_state != ISCSI_SESSION_TARGET_SCANNED) {\n\t\tspin_unlock_irqrestore(&session->lock, flags);\n\t\tmutex_unlock(&ihost->mutex);\n\t\tISCSI_DBG_TRANS_SESSION(session,\n\t\t\t\"Skipping target unbinding: Session is unbound/unbinding.\\n\");\n\t\treturn;\n\t}\n\n\tsession->target_state = ISCSI_SESSION_TARGET_UNBINDING;\n\ttarget_id = session->target_id;\n\tsession->target_id = ISCSI_MAX_TARGET;\n\tspin_unlock_irqrestore(&session->lock, flags);\n\tmutex_unlock(&ihost->mutex);\n\n\tif (remove_target)\n\t\tscsi_remove_target(&session->dev);\n\n\tif (session->ida_used)\n\t\tida_free(&iscsi_sess_ida, target_id);\n\n\tiscsi_session_event(session, ISCSI_KEVENT_UNBIND_SESSION);\n\tISCSI_DBG_TRANS_SESSION(session, \"Completed target removal\\n\");\n\n\tspin_lock_irqsave(&session->lock, flags);\n\tsession->target_state = ISCSI_SESSION_TARGET_UNBOUND;\n\tspin_unlock_irqrestore(&session->lock, flags);\n}\n\nstatic void __iscsi_destroy_session(struct work_struct *work)\n{\n\tstruct iscsi_cls_session *session =\n\t\tcontainer_of(work, struct iscsi_cls_session, destroy_work);\n\n\tsession->transport->destroy_session(session);\n}\n\nstruct iscsi_cls_session *\niscsi_alloc_session(struct Scsi_Host *shost, struct iscsi_transport *transport,\n\t\t    int dd_size)\n{\n\tstruct iscsi_cls_session *session;\n\n\tsession = kzalloc(sizeof(*session) + dd_size,\n\t\t\t  GFP_KERNEL);\n\tif (!session)\n\t\treturn NULL;\n\n\tsession->transport = transport;\n\tsession->creator = -1;\n\tsession->recovery_tmo = 120;\n\tsession->recovery_tmo_sysfs_override = false;\n\tsession->state = ISCSI_SESSION_FREE;\n\tINIT_DELAYED_WORK(&session->recovery_work, session_recovery_timedout);\n\tINIT_LIST_HEAD(&session->sess_list);\n\tINIT_WORK(&session->unblock_work, __iscsi_unblock_session);\n\tINIT_WORK(&session->block_work, __iscsi_block_session);\n\tINIT_WORK(&session->unbind_work, __iscsi_unbind_session);\n\tINIT_WORK(&session->scan_work, iscsi_scan_session);\n\tINIT_WORK(&session->destroy_work, __iscsi_destroy_session);\n\tspin_lock_init(&session->lock);\n\n\t \n\tscsi_host_get(shost);\n\tsession->dev.parent = &shost->shost_gendev;\n\tsession->dev.release = iscsi_session_release;\n\tdevice_initialize(&session->dev);\n\tif (dd_size)\n\t\tsession->dd_data = &session[1];\n\n\tISCSI_DBG_TRANS_SESSION(session, \"Completed session allocation\\n\");\n\treturn session;\n}\nEXPORT_SYMBOL_GPL(iscsi_alloc_session);\n\nint iscsi_add_session(struct iscsi_cls_session *session, unsigned int target_id)\n{\n\tstruct Scsi_Host *shost = iscsi_session_to_shost(session);\n\tunsigned long flags;\n\tint id = 0;\n\tint err;\n\n\tsession->sid = atomic_add_return(1, &iscsi_session_nr);\n\n\tsession->workq = alloc_workqueue(\"iscsi_ctrl_%d:%d\",\n\t\t\tWQ_SYSFS | WQ_MEM_RECLAIM | WQ_UNBOUND, 0,\n\t\t\tshost->host_no, session->sid);\n\tif (!session->workq)\n\t\treturn -ENOMEM;\n\n\tif (target_id == ISCSI_MAX_TARGET) {\n\t\tid = ida_alloc(&iscsi_sess_ida, GFP_KERNEL);\n\n\t\tif (id < 0) {\n\t\t\tiscsi_cls_session_printk(KERN_ERR, session,\n\t\t\t\t\t\"Failure in Target ID Allocation\\n\");\n\t\t\terr = id;\n\t\t\tgoto destroy_wq;\n\t\t}\n\t\tsession->target_id = (unsigned int)id;\n\t\tsession->ida_used = true;\n\t} else\n\t\tsession->target_id = target_id;\n\tspin_lock_irqsave(&session->lock, flags);\n\tsession->target_state = ISCSI_SESSION_TARGET_ALLOCATED;\n\tspin_unlock_irqrestore(&session->lock, flags);\n\n\tdev_set_name(&session->dev, \"session%u\", session->sid);\n\terr = device_add(&session->dev);\n\tif (err) {\n\t\tiscsi_cls_session_printk(KERN_ERR, session,\n\t\t\t\t\t \"could not register session's dev\\n\");\n\t\tgoto release_ida;\n\t}\n\terr = transport_register_device(&session->dev);\n\tif (err) {\n\t\tiscsi_cls_session_printk(KERN_ERR, session,\n\t\t\t\t\t \"could not register transport's dev\\n\");\n\t\tgoto release_dev;\n\t}\n\n\tspin_lock_irqsave(&sesslock, flags);\n\tlist_add(&session->sess_list, &sesslist);\n\tspin_unlock_irqrestore(&sesslock, flags);\n\n\tiscsi_session_event(session, ISCSI_KEVENT_CREATE_SESSION);\n\tISCSI_DBG_TRANS_SESSION(session, \"Completed session adding\\n\");\n\treturn 0;\n\nrelease_dev:\n\tdevice_del(&session->dev);\nrelease_ida:\n\tif (session->ida_used)\n\t\tida_free(&iscsi_sess_ida, session->target_id);\ndestroy_wq:\n\tdestroy_workqueue(session->workq);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(iscsi_add_session);\n\n \nstruct iscsi_cls_session *\niscsi_create_session(struct Scsi_Host *shost, struct iscsi_transport *transport,\n\t\t     int dd_size, unsigned int target_id)\n{\n\tstruct iscsi_cls_session *session;\n\n\tsession = iscsi_alloc_session(shost, transport, dd_size);\n\tif (!session)\n\t\treturn NULL;\n\n\tif (iscsi_add_session(session, target_id)) {\n\t\tiscsi_free_session(session);\n\t\treturn NULL;\n\t}\n\treturn session;\n}\nEXPORT_SYMBOL_GPL(iscsi_create_session);\n\nstatic void iscsi_conn_release(struct device *dev)\n{\n\tstruct iscsi_cls_conn *conn = iscsi_dev_to_conn(dev);\n\tstruct device *parent = conn->dev.parent;\n\n\tISCSI_DBG_TRANS_CONN(conn, \"Releasing conn\\n\");\n\tkfree(conn);\n\tput_device(parent);\n}\n\nstatic int iscsi_is_conn_dev(const struct device *dev)\n{\n\treturn dev->release == iscsi_conn_release;\n}\n\nstatic int iscsi_iter_destroy_conn_fn(struct device *dev, void *data)\n{\n\tif (!iscsi_is_conn_dev(dev))\n\t\treturn 0;\n\n\tiscsi_remove_conn(iscsi_dev_to_conn(dev));\n\treturn 0;\n}\n\nvoid iscsi_remove_session(struct iscsi_cls_session *session)\n{\n\tunsigned long flags;\n\tint err;\n\n\tISCSI_DBG_TRANS_SESSION(session, \"Removing session\\n\");\n\n\tspin_lock_irqsave(&sesslock, flags);\n\tif (!list_empty(&session->sess_list))\n\t\tlist_del(&session->sess_list);\n\tspin_unlock_irqrestore(&sesslock, flags);\n\n\tif (!cancel_work_sync(&session->block_work))\n\t\tcancel_delayed_work_sync(&session->recovery_work);\n\tcancel_work_sync(&session->unblock_work);\n\t \n\tspin_lock_irqsave(&session->lock, flags);\n\tsession->state = ISCSI_SESSION_FREE;\n\tspin_unlock_irqrestore(&session->lock, flags);\n\n\tscsi_target_unblock(&session->dev, SDEV_TRANSPORT_OFFLINE);\n\t \n\tflush_work(&session->scan_work);\n\t \n\tflush_work(&session->unbind_work);\n\t__iscsi_unbind_session(&session->unbind_work);\n\n\t \n\terr = device_for_each_child(&session->dev, NULL,\n\t\t\t\t    iscsi_iter_destroy_conn_fn);\n\tif (err)\n\t\tiscsi_cls_session_printk(KERN_ERR, session,\n\t\t\t\t\t \"Could not delete all connections \"\n\t\t\t\t\t \"for session. Error %d.\\n\", err);\n\n\ttransport_unregister_device(&session->dev);\n\n\tdestroy_workqueue(session->workq);\n\n\tISCSI_DBG_TRANS_SESSION(session, \"Completing session removal\\n\");\n\tdevice_del(&session->dev);\n}\nEXPORT_SYMBOL_GPL(iscsi_remove_session);\n\nstatic void iscsi_stop_conn(struct iscsi_cls_conn *conn, int flag)\n{\n\tISCSI_DBG_TRANS_CONN(conn, \"Stopping conn.\\n\");\n\n\tswitch (flag) {\n\tcase STOP_CONN_RECOVER:\n\t\tWRITE_ONCE(conn->state, ISCSI_CONN_FAILED);\n\t\tbreak;\n\tcase STOP_CONN_TERM:\n\t\tWRITE_ONCE(conn->state, ISCSI_CONN_DOWN);\n\t\tbreak;\n\tdefault:\n\t\tiscsi_cls_conn_printk(KERN_ERR, conn, \"invalid stop flag %d\\n\",\n\t\t\t\t      flag);\n\t\treturn;\n\t}\n\n\tconn->transport->stop_conn(conn, flag);\n\tISCSI_DBG_TRANS_CONN(conn, \"Stopping conn done.\\n\");\n}\n\nstatic void iscsi_ep_disconnect(struct iscsi_cls_conn *conn, bool is_active)\n{\n\tstruct iscsi_cls_session *session = iscsi_conn_to_session(conn);\n\tstruct iscsi_endpoint *ep;\n\n\tISCSI_DBG_TRANS_CONN(conn, \"disconnect ep.\\n\");\n\tWRITE_ONCE(conn->state, ISCSI_CONN_FAILED);\n\n\tif (!conn->ep || !session->transport->ep_disconnect)\n\t\treturn;\n\n\tep = conn->ep;\n\tconn->ep = NULL;\n\n\tsession->transport->unbind_conn(conn, is_active);\n\tsession->transport->ep_disconnect(ep);\n\tISCSI_DBG_TRANS_CONN(conn, \"disconnect ep done.\\n\");\n}\n\nstatic void iscsi_if_disconnect_bound_ep(struct iscsi_cls_conn *conn,\n\t\t\t\t\t struct iscsi_endpoint *ep,\n\t\t\t\t\t bool is_active)\n{\n\t \n\tspin_lock_irq(&conn->lock);\n\tif (!test_bit(ISCSI_CLS_CONN_BIT_CLEANUP, &conn->flags)) {\n\t\tspin_unlock_irq(&conn->lock);\n\t\tiscsi_ep_disconnect(conn, is_active);\n\t} else {\n\t\tspin_unlock_irq(&conn->lock);\n\t\tISCSI_DBG_TRANS_CONN(conn, \"flush kernel conn cleanup.\\n\");\n\t\tmutex_unlock(&conn->ep_mutex);\n\n\t\tflush_work(&conn->cleanup_work);\n\t\t \n\t\tiscsi_put_endpoint(ep);\n\t\tmutex_lock(&conn->ep_mutex);\n\t}\n}\n\nstatic int iscsi_if_stop_conn(struct iscsi_cls_conn *conn, int flag)\n{\n\tISCSI_DBG_TRANS_CONN(conn, \"iscsi if conn stop.\\n\");\n\t \n\tmutex_lock(&conn->ep_mutex);\n\tif (conn->ep)\n\t\tiscsi_if_disconnect_bound_ep(conn, conn->ep, true);\n\tmutex_unlock(&conn->ep_mutex);\n\n\t \n\tif (flag == STOP_CONN_TERM) {\n\t\tcancel_work_sync(&conn->cleanup_work);\n\t\tiscsi_stop_conn(conn, flag);\n\t} else {\n\t\t \n\t\tspin_lock_irq(&conn->lock);\n\t\tif (!test_and_set_bit(ISCSI_CLS_CONN_BIT_CLEANUP, &conn->flags)) {\n\t\t\tspin_unlock_irq(&conn->lock);\n\t\t\tiscsi_stop_conn(conn, flag);\n\t\t} else {\n\t\t\tspin_unlock_irq(&conn->lock);\n\t\t\tISCSI_DBG_TRANS_CONN(conn,\n\t\t\t\t\t     \"flush kernel conn cleanup.\\n\");\n\t\t\tflush_work(&conn->cleanup_work);\n\t\t}\n\t\t \n\t\tspin_lock_irq(&conn->lock);\n\t\tclear_bit(ISCSI_CLS_CONN_BIT_CLEANUP, &conn->flags);\n\t\tspin_unlock_irq(&conn->lock);\n\t}\n\tISCSI_DBG_TRANS_CONN(conn, \"iscsi if conn stop done.\\n\");\n\treturn 0;\n}\n\nstatic void iscsi_cleanup_conn_work_fn(struct work_struct *work)\n{\n\tstruct iscsi_cls_conn *conn = container_of(work, struct iscsi_cls_conn,\n\t\t\t\t\t\t   cleanup_work);\n\tstruct iscsi_cls_session *session = iscsi_conn_to_session(conn);\n\n\tmutex_lock(&conn->ep_mutex);\n\t \n\tif (conn->ep)\n\t\tget_device(&conn->ep->dev);\n\tiscsi_ep_disconnect(conn, false);\n\n\tif (system_state != SYSTEM_RUNNING) {\n\t\t \n\t\tif (session->recovery_tmo > 0)\n\t\t\tsession->recovery_tmo = 0;\n\t}\n\n\tiscsi_stop_conn(conn, STOP_CONN_RECOVER);\n\tmutex_unlock(&conn->ep_mutex);\n\tISCSI_DBG_TRANS_CONN(conn, \"cleanup done.\\n\");\n}\n\nstatic int iscsi_iter_force_destroy_conn_fn(struct device *dev, void *data)\n{\n\tstruct iscsi_transport *transport;\n\tstruct iscsi_cls_conn *conn;\n\n\tif (!iscsi_is_conn_dev(dev))\n\t\treturn 0;\n\n\tconn = iscsi_dev_to_conn(dev);\n\ttransport = conn->transport;\n\n\tif (READ_ONCE(conn->state) != ISCSI_CONN_DOWN)\n\t\tiscsi_if_stop_conn(conn, STOP_CONN_TERM);\n\n\ttransport->destroy_conn(conn);\n\treturn 0;\n}\n\n \nvoid iscsi_force_destroy_session(struct iscsi_cls_session *session)\n{\n\tstruct iscsi_transport *transport = session->transport;\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(system_state == SYSTEM_RUNNING);\n\n\tspin_lock_irqsave(&sesslock, flags);\n\tif (list_empty(&session->sess_list)) {\n\t\tspin_unlock_irqrestore(&sesslock, flags);\n\t\t \n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&sesslock, flags);\n\n\tdevice_for_each_child(&session->dev, NULL,\n\t\t\t      iscsi_iter_force_destroy_conn_fn);\n\ttransport->destroy_session(session);\n}\nEXPORT_SYMBOL_GPL(iscsi_force_destroy_session);\n\nvoid iscsi_free_session(struct iscsi_cls_session *session)\n{\n\tISCSI_DBG_TRANS_SESSION(session, \"Freeing session\\n\");\n\tiscsi_session_event(session, ISCSI_KEVENT_DESTROY_SESSION);\n\tput_device(&session->dev);\n}\nEXPORT_SYMBOL_GPL(iscsi_free_session);\n\n \nstruct iscsi_cls_conn *\niscsi_alloc_conn(struct iscsi_cls_session *session, int dd_size, uint32_t cid)\n{\n\tstruct iscsi_transport *transport = session->transport;\n\tstruct iscsi_cls_conn *conn;\n\n\tconn = kzalloc(sizeof(*conn) + dd_size, GFP_KERNEL);\n\tif (!conn)\n\t\treturn NULL;\n\tif (dd_size)\n\t\tconn->dd_data = &conn[1];\n\n\tmutex_init(&conn->ep_mutex);\n\tspin_lock_init(&conn->lock);\n\tINIT_LIST_HEAD(&conn->conn_list);\n\tINIT_WORK(&conn->cleanup_work, iscsi_cleanup_conn_work_fn);\n\tconn->transport = transport;\n\tconn->cid = cid;\n\tWRITE_ONCE(conn->state, ISCSI_CONN_DOWN);\n\n\t \n\tif (!get_device(&session->dev))\n\t\tgoto free_conn;\n\n\tdev_set_name(&conn->dev, \"connection%d:%u\", session->sid, cid);\n\tdevice_initialize(&conn->dev);\n\tconn->dev.parent = &session->dev;\n\tconn->dev.release = iscsi_conn_release;\n\n\treturn conn;\n\nfree_conn:\n\tkfree(conn);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(iscsi_alloc_conn);\n\n \nint iscsi_add_conn(struct iscsi_cls_conn *conn)\n{\n\tint err;\n\tunsigned long flags;\n\tstruct iscsi_cls_session *session = iscsi_dev_to_session(conn->dev.parent);\n\n\terr = device_add(&conn->dev);\n\tif (err) {\n\t\tiscsi_cls_session_printk(KERN_ERR, session,\n\t\t\t\t\t \"could not register connection's dev\\n\");\n\t\treturn err;\n\t}\n\terr = transport_register_device(&conn->dev);\n\tif (err) {\n\t\tiscsi_cls_session_printk(KERN_ERR, session,\n\t\t\t\t\t \"could not register transport's dev\\n\");\n\t\tdevice_del(&conn->dev);\n\t\treturn err;\n\t}\n\n\tspin_lock_irqsave(&connlock, flags);\n\tlist_add(&conn->conn_list, &connlist);\n\tspin_unlock_irqrestore(&connlock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iscsi_add_conn);\n\n \nvoid iscsi_remove_conn(struct iscsi_cls_conn *conn)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&connlock, flags);\n\tlist_del(&conn->conn_list);\n\tspin_unlock_irqrestore(&connlock, flags);\n\n\ttransport_unregister_device(&conn->dev);\n\tdevice_del(&conn->dev);\n}\nEXPORT_SYMBOL_GPL(iscsi_remove_conn);\n\nvoid iscsi_put_conn(struct iscsi_cls_conn *conn)\n{\n\tput_device(&conn->dev);\n}\nEXPORT_SYMBOL_GPL(iscsi_put_conn);\n\nvoid iscsi_get_conn(struct iscsi_cls_conn *conn)\n{\n\tget_device(&conn->dev);\n}\nEXPORT_SYMBOL_GPL(iscsi_get_conn);\n\n \nstatic struct iscsi_internal *\niscsi_if_transport_lookup(struct iscsi_transport *tt)\n{\n\tstruct iscsi_internal *priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&iscsi_transport_lock, flags);\n\tlist_for_each_entry(priv, &iscsi_transports, list) {\n\t\tif (tt == priv->iscsi_transport) {\n\t\t\tspin_unlock_irqrestore(&iscsi_transport_lock, flags);\n\t\t\treturn priv;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&iscsi_transport_lock, flags);\n\treturn NULL;\n}\n\nstatic int\niscsi_multicast_skb(struct sk_buff *skb, uint32_t group, gfp_t gfp)\n{\n\treturn nlmsg_multicast(nls, skb, 0, group, gfp);\n}\n\nstatic int\niscsi_unicast_skb(struct sk_buff *skb, u32 portid)\n{\n\treturn nlmsg_unicast(nls, skb, portid);\n}\n\nint iscsi_recv_pdu(struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,\n\t\t   char *data, uint32_t data_size)\n{\n\tstruct nlmsghdr\t*nlh;\n\tstruct sk_buff *skb;\n\tstruct iscsi_uevent *ev;\n\tchar *pdu;\n\tstruct iscsi_internal *priv;\n\tint len = nlmsg_total_size(sizeof(*ev) + sizeof(struct iscsi_hdr) +\n\t\t\t\t   data_size);\n\n\tpriv = iscsi_if_transport_lookup(conn->transport);\n\tif (!priv)\n\t\treturn -EINVAL;\n\n\tskb = alloc_skb(len, GFP_ATOMIC);\n\tif (!skb) {\n\t\tiscsi_conn_error_event(conn, ISCSI_ERR_CONN_FAILED);\n\t\tiscsi_cls_conn_printk(KERN_ERR, conn, \"can not deliver \"\n\t\t\t\t      \"control PDU: OOM\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnlh = __nlmsg_put(skb, 0, 0, 0, (len - sizeof(*nlh)), 0);\n\tev = nlmsg_data(nlh);\n\tmemset(ev, 0, sizeof(*ev));\n\tev->transport_handle = iscsi_handle(conn->transport);\n\tev->type = ISCSI_KEVENT_RECV_PDU;\n\tev->r.recv_req.cid = conn->cid;\n\tev->r.recv_req.sid = iscsi_conn_get_sid(conn);\n\tpdu = (char*)ev + sizeof(*ev);\n\tmemcpy(pdu, hdr, sizeof(struct iscsi_hdr));\n\tmemcpy(pdu + sizeof(struct iscsi_hdr), data, data_size);\n\n\treturn iscsi_multicast_skb(skb, ISCSI_NL_GRP_ISCSID, GFP_ATOMIC);\n}\nEXPORT_SYMBOL_GPL(iscsi_recv_pdu);\n\nint iscsi_offload_mesg(struct Scsi_Host *shost,\n\t\t       struct iscsi_transport *transport, uint32_t type,\n\t\t       char *data, uint16_t data_size)\n{\n\tstruct nlmsghdr\t*nlh;\n\tstruct sk_buff *skb;\n\tstruct iscsi_uevent *ev;\n\tint len = nlmsg_total_size(sizeof(*ev) + data_size);\n\n\tskb = alloc_skb(len, GFP_ATOMIC);\n\tif (!skb) {\n\t\tprintk(KERN_ERR \"can not deliver iscsi offload message:OOM\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnlh = __nlmsg_put(skb, 0, 0, 0, (len - sizeof(*nlh)), 0);\n\tev = nlmsg_data(nlh);\n\tmemset(ev, 0, sizeof(*ev));\n\tev->type = type;\n\tev->transport_handle = iscsi_handle(transport);\n\tswitch (type) {\n\tcase ISCSI_KEVENT_PATH_REQ:\n\t\tev->r.req_path.host_no = shost->host_no;\n\t\tbreak;\n\tcase ISCSI_KEVENT_IF_DOWN:\n\t\tev->r.notify_if_down.host_no = shost->host_no;\n\t\tbreak;\n\t}\n\n\tmemcpy((char *)ev + sizeof(*ev), data, data_size);\n\n\treturn iscsi_multicast_skb(skb, ISCSI_NL_GRP_UIP, GFP_ATOMIC);\n}\nEXPORT_SYMBOL_GPL(iscsi_offload_mesg);\n\nvoid iscsi_conn_error_event(struct iscsi_cls_conn *conn, enum iscsi_err error)\n{\n\tstruct nlmsghdr\t*nlh;\n\tstruct sk_buff\t*skb;\n\tstruct iscsi_uevent *ev;\n\tstruct iscsi_internal *priv;\n\tint len = nlmsg_total_size(sizeof(*ev));\n\tunsigned long flags;\n\tint state;\n\n\tspin_lock_irqsave(&conn->lock, flags);\n\t \n\tstate = READ_ONCE(conn->state);\n\tswitch (state) {\n\tcase ISCSI_CONN_BOUND:\n\tcase ISCSI_CONN_UP:\n\t\tif (!test_and_set_bit(ISCSI_CLS_CONN_BIT_CLEANUP,\n\t\t\t\t      &conn->flags)) {\n\t\t\tqueue_work(iscsi_conn_cleanup_workq,\n\t\t\t\t   &conn->cleanup_work);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tISCSI_DBG_TRANS_CONN(conn, \"Got conn error in state %d\\n\",\n\t\t\t\t     state);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&conn->lock, flags);\n\n\tpriv = iscsi_if_transport_lookup(conn->transport);\n\tif (!priv)\n\t\treturn;\n\n\tskb = alloc_skb(len, GFP_ATOMIC);\n\tif (!skb) {\n\t\tiscsi_cls_conn_printk(KERN_ERR, conn, \"gracefully ignored \"\n\t\t\t\t      \"conn error (%d)\\n\", error);\n\t\treturn;\n\t}\n\n\tnlh = __nlmsg_put(skb, 0, 0, 0, (len - sizeof(*nlh)), 0);\n\tev = nlmsg_data(nlh);\n\tev->transport_handle = iscsi_handle(conn->transport);\n\tev->type = ISCSI_KEVENT_CONN_ERROR;\n\tev->r.connerror.error = error;\n\tev->r.connerror.cid = conn->cid;\n\tev->r.connerror.sid = iscsi_conn_get_sid(conn);\n\n\tiscsi_multicast_skb(skb, ISCSI_NL_GRP_ISCSID, GFP_ATOMIC);\n\n\tiscsi_cls_conn_printk(KERN_INFO, conn, \"detected conn error (%d)\\n\",\n\t\t\t      error);\n}\nEXPORT_SYMBOL_GPL(iscsi_conn_error_event);\n\nvoid iscsi_conn_login_event(struct iscsi_cls_conn *conn,\n\t\t\t    enum iscsi_conn_state state)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff  *skb;\n\tstruct iscsi_uevent *ev;\n\tstruct iscsi_internal *priv;\n\tint len = nlmsg_total_size(sizeof(*ev));\n\n\tpriv = iscsi_if_transport_lookup(conn->transport);\n\tif (!priv)\n\t\treturn;\n\n\tskb = alloc_skb(len, GFP_ATOMIC);\n\tif (!skb) {\n\t\tiscsi_cls_conn_printk(KERN_ERR, conn, \"gracefully ignored \"\n\t\t\t\t      \"conn login (%d)\\n\", state);\n\t\treturn;\n\t}\n\n\tnlh = __nlmsg_put(skb, 0, 0, 0, (len - sizeof(*nlh)), 0);\n\tev = nlmsg_data(nlh);\n\tev->transport_handle = iscsi_handle(conn->transport);\n\tev->type = ISCSI_KEVENT_CONN_LOGIN_STATE;\n\tev->r.conn_login.state = state;\n\tev->r.conn_login.cid = conn->cid;\n\tev->r.conn_login.sid = iscsi_conn_get_sid(conn);\n\tiscsi_multicast_skb(skb, ISCSI_NL_GRP_ISCSID, GFP_ATOMIC);\n\n\tiscsi_cls_conn_printk(KERN_INFO, conn, \"detected conn login (%d)\\n\",\n\t\t\t      state);\n}\nEXPORT_SYMBOL_GPL(iscsi_conn_login_event);\n\nvoid iscsi_post_host_event(uint32_t host_no, struct iscsi_transport *transport,\n\t\t\t   enum iscsi_host_event_code code, uint32_t data_size,\n\t\t\t   uint8_t *data)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tstruct iscsi_uevent *ev;\n\tint len = nlmsg_total_size(sizeof(*ev) + data_size);\n\n\tskb = alloc_skb(len, GFP_NOIO);\n\tif (!skb) {\n\t\tprintk(KERN_ERR \"gracefully ignored host event (%d):%d OOM\\n\",\n\t\t       host_no, code);\n\t\treturn;\n\t}\n\n\tnlh = __nlmsg_put(skb, 0, 0, 0, (len - sizeof(*nlh)), 0);\n\tev = nlmsg_data(nlh);\n\tev->transport_handle = iscsi_handle(transport);\n\tev->type = ISCSI_KEVENT_HOST_EVENT;\n\tev->r.host_event.host_no = host_no;\n\tev->r.host_event.code = code;\n\tev->r.host_event.data_size = data_size;\n\n\tif (data_size)\n\t\tmemcpy((char *)ev + sizeof(*ev), data, data_size);\n\n\tiscsi_multicast_skb(skb, ISCSI_NL_GRP_ISCSID, GFP_NOIO);\n}\nEXPORT_SYMBOL_GPL(iscsi_post_host_event);\n\nvoid iscsi_ping_comp_event(uint32_t host_no, struct iscsi_transport *transport,\n\t\t\t   uint32_t status, uint32_t pid, uint32_t data_size,\n\t\t\t   uint8_t *data)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tstruct iscsi_uevent *ev;\n\tint len = nlmsg_total_size(sizeof(*ev) + data_size);\n\n\tskb = alloc_skb(len, GFP_NOIO);\n\tif (!skb) {\n\t\tprintk(KERN_ERR \"gracefully ignored ping comp: OOM\\n\");\n\t\treturn;\n\t}\n\n\tnlh = __nlmsg_put(skb, 0, 0, 0, (len - sizeof(*nlh)), 0);\n\tev = nlmsg_data(nlh);\n\tev->transport_handle = iscsi_handle(transport);\n\tev->type = ISCSI_KEVENT_PING_COMP;\n\tev->r.ping_comp.host_no = host_no;\n\tev->r.ping_comp.status = status;\n\tev->r.ping_comp.pid = pid;\n\tev->r.ping_comp.data_size = data_size;\n\tmemcpy((char *)ev + sizeof(*ev), data, data_size);\n\n\tiscsi_multicast_skb(skb, ISCSI_NL_GRP_ISCSID, GFP_NOIO);\n}\nEXPORT_SYMBOL_GPL(iscsi_ping_comp_event);\n\nstatic int\niscsi_if_send_reply(u32 portid, int type, void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tint len = nlmsg_total_size(size);\n\n\tskb = alloc_skb(len, GFP_ATOMIC);\n\tif (!skb) {\n\t\tprintk(KERN_ERR \"Could not allocate skb to send reply.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnlh = __nlmsg_put(skb, 0, 0, type, (len - sizeof(*nlh)), 0);\n\tmemcpy(nlmsg_data(nlh), payload, size);\n\treturn iscsi_unicast_skb(skb, portid);\n}\n\nstatic int\niscsi_if_get_stats(struct iscsi_transport *transport, struct nlmsghdr *nlh)\n{\n\tstruct iscsi_uevent *ev = nlmsg_data(nlh);\n\tstruct iscsi_stats *stats;\n\tstruct sk_buff *skbstat;\n\tstruct iscsi_cls_conn *conn;\n\tstruct nlmsghdr\t*nlhstat;\n\tstruct iscsi_uevent *evstat;\n\tstruct iscsi_internal *priv;\n\tint len = nlmsg_total_size(sizeof(*ev) +\n\t\t\t\t   sizeof(struct iscsi_stats) +\n\t\t\t\t   sizeof(struct iscsi_stats_custom) *\n\t\t\t\t   ISCSI_STATS_CUSTOM_MAX);\n\tint err = 0;\n\n\tpriv = iscsi_if_transport_lookup(transport);\n\tif (!priv)\n\t\treturn -EINVAL;\n\n\tconn = iscsi_conn_lookup(ev->u.get_stats.sid, ev->u.get_stats.cid);\n\tif (!conn)\n\t\treturn -EEXIST;\n\n\tdo {\n\t\tint actual_size;\n\n\t\tskbstat = alloc_skb(len, GFP_ATOMIC);\n\t\tif (!skbstat) {\n\t\t\tiscsi_cls_conn_printk(KERN_ERR, conn, \"can not \"\n\t\t\t\t\t      \"deliver stats: OOM\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnlhstat = __nlmsg_put(skbstat, 0, 0, 0,\n\t\t\t\t      (len - sizeof(*nlhstat)), 0);\n\t\tevstat = nlmsg_data(nlhstat);\n\t\tmemset(evstat, 0, sizeof(*evstat));\n\t\tevstat->transport_handle = iscsi_handle(conn->transport);\n\t\tevstat->type = nlh->nlmsg_type;\n\t\tevstat->u.get_stats.cid =\n\t\t\tev->u.get_stats.cid;\n\t\tevstat->u.get_stats.sid =\n\t\t\tev->u.get_stats.sid;\n\t\tstats = (struct iscsi_stats *)\n\t\t\t((char*)evstat + sizeof(*evstat));\n\t\tmemset(stats, 0, sizeof(*stats));\n\n\t\ttransport->get_stats(conn, stats);\n\t\tactual_size = nlmsg_total_size(sizeof(struct iscsi_uevent) +\n\t\t\t\t\t       sizeof(struct iscsi_stats) +\n\t\t\t\t\t       sizeof(struct iscsi_stats_custom) *\n\t\t\t\t\t       stats->custom_length);\n\t\tactual_size -= sizeof(*nlhstat);\n\t\tactual_size = nlmsg_msg_size(actual_size);\n\t\tskb_trim(skbstat, NLMSG_ALIGN(actual_size));\n\t\tnlhstat->nlmsg_len = actual_size;\n\n\t\terr = iscsi_multicast_skb(skbstat, ISCSI_NL_GRP_ISCSID,\n\t\t\t\t\t  GFP_ATOMIC);\n\t} while (err < 0 && err != -ECONNREFUSED);\n\n\treturn err;\n}\n\n \nint iscsi_session_event(struct iscsi_cls_session *session,\n\t\t\tenum iscsi_uevent_e event)\n{\n\tstruct iscsi_internal *priv;\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_uevent *ev;\n\tstruct sk_buff  *skb;\n\tstruct nlmsghdr *nlh;\n\tint rc, len = nlmsg_total_size(sizeof(*ev));\n\n\tpriv = iscsi_if_transport_lookup(session->transport);\n\tif (!priv)\n\t\treturn -EINVAL;\n\tshost = iscsi_session_to_shost(session);\n\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (!skb) {\n\t\tiscsi_cls_session_printk(KERN_ERR, session,\n\t\t\t\t\t \"Cannot notify userspace of session \"\n\t\t\t\t\t \"event %u\\n\", event);\n\t\treturn -ENOMEM;\n\t}\n\n\tnlh = __nlmsg_put(skb, 0, 0, 0, (len - sizeof(*nlh)), 0);\n\tev = nlmsg_data(nlh);\n\tev->transport_handle = iscsi_handle(session->transport);\n\n\tev->type = event;\n\tswitch (event) {\n\tcase ISCSI_KEVENT_DESTROY_SESSION:\n\t\tev->r.d_session.host_no = shost->host_no;\n\t\tev->r.d_session.sid = session->sid;\n\t\tbreak;\n\tcase ISCSI_KEVENT_CREATE_SESSION:\n\t\tev->r.c_session_ret.host_no = shost->host_no;\n\t\tev->r.c_session_ret.sid = session->sid;\n\t\tbreak;\n\tcase ISCSI_KEVENT_UNBIND_SESSION:\n\t\tev->r.unbind_session.host_no = shost->host_no;\n\t\tev->r.unbind_session.sid = session->sid;\n\t\tbreak;\n\tdefault:\n\t\tiscsi_cls_session_printk(KERN_ERR, session, \"Invalid event \"\n\t\t\t\t\t \"%u.\\n\", event);\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trc = iscsi_multicast_skb(skb, ISCSI_NL_GRP_ISCSID, GFP_KERNEL);\n\tif (rc == -ESRCH)\n\t\tiscsi_cls_session_printk(KERN_ERR, session,\n\t\t\t\t\t \"Cannot notify userspace of session \"\n\t\t\t\t\t \"event %u. Check iscsi daemon\\n\",\n\t\t\t\t\t event);\n\n\tISCSI_DBG_TRANS_SESSION(session, \"Completed handling event %d rc %d\\n\",\n\t\t\t\tevent, rc);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(iscsi_session_event);\n\nstatic int\niscsi_if_create_session(struct iscsi_internal *priv, struct iscsi_endpoint *ep,\n\t\t\tstruct iscsi_uevent *ev, pid_t pid,\n\t\t\tuint32_t initial_cmdsn,\tuint16_t cmds_max,\n\t\t\tuint16_t queue_depth)\n{\n\tstruct iscsi_transport *transport = priv->iscsi_transport;\n\tstruct iscsi_cls_session *session;\n\tstruct Scsi_Host *shost;\n\n\tsession = transport->create_session(ep, cmds_max, queue_depth,\n\t\t\t\t\t    initial_cmdsn);\n\tif (!session)\n\t\treturn -ENOMEM;\n\n\tsession->creator = pid;\n\tshost = iscsi_session_to_shost(session);\n\tev->r.c_session_ret.host_no = shost->host_no;\n\tev->r.c_session_ret.sid = session->sid;\n\tISCSI_DBG_TRANS_SESSION(session,\n\t\t\t\t\"Completed creating transport session\\n\");\n\treturn 0;\n}\n\nstatic int\niscsi_if_create_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev)\n{\n\tstruct iscsi_cls_conn *conn;\n\tstruct iscsi_cls_session *session;\n\n\tsession = iscsi_session_lookup(ev->u.c_conn.sid);\n\tif (!session) {\n\t\tprintk(KERN_ERR \"iscsi: invalid session %d.\\n\",\n\t\t       ev->u.c_conn.sid);\n\t\treturn -EINVAL;\n\t}\n\n\tconn = transport->create_conn(session, ev->u.c_conn.cid);\n\tif (!conn) {\n\t\tiscsi_cls_session_printk(KERN_ERR, session,\n\t\t\t\t\t \"couldn't create a new connection.\");\n\t\treturn -ENOMEM;\n\t}\n\n\tev->r.c_conn_ret.sid = session->sid;\n\tev->r.c_conn_ret.cid = conn->cid;\n\n\tISCSI_DBG_TRANS_CONN(conn, \"Completed creating transport conn\\n\");\n\treturn 0;\n}\n\nstatic int\niscsi_if_destroy_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev)\n{\n\tstruct iscsi_cls_conn *conn;\n\n\tconn = iscsi_conn_lookup(ev->u.d_conn.sid, ev->u.d_conn.cid);\n\tif (!conn)\n\t\treturn -EINVAL;\n\n\tISCSI_DBG_TRANS_CONN(conn, \"Flushing cleanup during destruction\\n\");\n\tflush_work(&conn->cleanup_work);\n\tISCSI_DBG_TRANS_CONN(conn, \"Destroying transport conn\\n\");\n\n\tif (transport->destroy_conn)\n\t\ttransport->destroy_conn(conn);\n\treturn 0;\n}\n\nstatic int\niscsi_if_set_param(struct iscsi_transport *transport, struct iscsi_uevent *ev, u32 rlen)\n{\n\tchar *data = (char*)ev + sizeof(*ev);\n\tstruct iscsi_cls_conn *conn;\n\tstruct iscsi_cls_session *session;\n\tint err = 0, value = 0, state;\n\n\tif (ev->u.set_param.len > rlen ||\n\t    ev->u.set_param.len > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tsession = iscsi_session_lookup(ev->u.set_param.sid);\n\tconn = iscsi_conn_lookup(ev->u.set_param.sid, ev->u.set_param.cid);\n\tif (!conn || !session)\n\t\treturn -EINVAL;\n\n\t \n\tif (strlen(data) > ev->u.set_param.len)\n\t\treturn -EINVAL;\n\n\tswitch (ev->u.set_param.param) {\n\tcase ISCSI_PARAM_SESS_RECOVERY_TMO:\n\t\tsscanf(data, \"%d\", &value);\n\t\tif (!session->recovery_tmo_sysfs_override)\n\t\t\tsession->recovery_tmo = value;\n\t\tbreak;\n\tdefault:\n\t\tstate = READ_ONCE(conn->state);\n\t\tif (state == ISCSI_CONN_BOUND || state == ISCSI_CONN_UP) {\n\t\t\terr = transport->set_param(conn, ev->u.set_param.param,\n\t\t\t\t\tdata, ev->u.set_param.len);\n\t\t} else {\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int iscsi_if_ep_connect(struct iscsi_transport *transport,\n\t\t\t       struct iscsi_uevent *ev, int msg_type)\n{\n\tstruct iscsi_endpoint *ep;\n\tstruct sockaddr *dst_addr;\n\tstruct Scsi_Host *shost = NULL;\n\tint non_blocking, err = 0;\n\n\tif (!transport->ep_connect)\n\t\treturn -EINVAL;\n\n\tif (msg_type == ISCSI_UEVENT_TRANSPORT_EP_CONNECT_THROUGH_HOST) {\n\t\tshost = scsi_host_lookup(ev->u.ep_connect_through_host.host_no);\n\t\tif (!shost) {\n\t\t\tprintk(KERN_ERR \"ep connect failed. Could not find \"\n\t\t\t       \"host no %u\\n\",\n\t\t\t       ev->u.ep_connect_through_host.host_no);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tnon_blocking = ev->u.ep_connect_through_host.non_blocking;\n\t} else\n\t\tnon_blocking = ev->u.ep_connect.non_blocking;\n\n\tdst_addr = (struct sockaddr *)((char*)ev + sizeof(*ev));\n\tep = transport->ep_connect(shost, dst_addr, non_blocking);\n\tif (IS_ERR(ep)) {\n\t\terr = PTR_ERR(ep);\n\t\tgoto release_host;\n\t}\n\n\tev->r.ep_connect_ret.handle = ep->id;\nrelease_host:\n\tif (shost)\n\t\tscsi_host_put(shost);\n\treturn err;\n}\n\nstatic int iscsi_if_ep_disconnect(struct iscsi_transport *transport,\n\t\t\t\t  u64 ep_handle)\n{\n\tstruct iscsi_cls_conn *conn;\n\tstruct iscsi_endpoint *ep;\n\n\tif (!transport->ep_disconnect)\n\t\treturn -EINVAL;\n\n\tep = iscsi_lookup_endpoint(ep_handle);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tconn = ep->conn;\n\tif (!conn) {\n\t\t \n\t\ttransport->ep_disconnect(ep);\n\t\tgoto put_ep;\n\t}\n\n\tmutex_lock(&conn->ep_mutex);\n\tiscsi_if_disconnect_bound_ep(conn, ep, false);\n\tmutex_unlock(&conn->ep_mutex);\nput_ep:\n\tiscsi_put_endpoint(ep);\n\treturn 0;\n}\n\nstatic int\niscsi_if_transport_ep(struct iscsi_transport *transport,\n\t\t      struct iscsi_uevent *ev, int msg_type, u32 rlen)\n{\n\tstruct iscsi_endpoint *ep;\n\tint rc = 0;\n\n\tswitch (msg_type) {\n\tcase ISCSI_UEVENT_TRANSPORT_EP_CONNECT_THROUGH_HOST:\n\tcase ISCSI_UEVENT_TRANSPORT_EP_CONNECT:\n\t\tif (rlen < sizeof(struct sockaddr))\n\t\t\trc = -EINVAL;\n\t\telse\n\t\t\trc = iscsi_if_ep_connect(transport, ev, msg_type);\n\t\tbreak;\n\tcase ISCSI_UEVENT_TRANSPORT_EP_POLL:\n\t\tif (!transport->ep_poll)\n\t\t\treturn -EINVAL;\n\n\t\tep = iscsi_lookup_endpoint(ev->u.ep_poll.ep_handle);\n\t\tif (!ep)\n\t\t\treturn -EINVAL;\n\n\t\tev->r.retcode = transport->ep_poll(ep,\n\t\t\t\t\t\t   ev->u.ep_poll.timeout_ms);\n\t\tiscsi_put_endpoint(ep);\n\t\tbreak;\n\tcase ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT:\n\t\trc = iscsi_if_ep_disconnect(transport,\n\t\t\t\t\t    ev->u.ep_disconnect.ep_handle);\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic int\niscsi_tgt_dscvr(struct iscsi_transport *transport,\n\t\tstruct iscsi_uevent *ev, u32 rlen)\n{\n\tstruct Scsi_Host *shost;\n\tstruct sockaddr *dst_addr;\n\tint err;\n\n\tif (rlen < sizeof(*dst_addr))\n\t\treturn -EINVAL;\n\n\tif (!transport->tgt_dscvr)\n\t\treturn -EINVAL;\n\n\tshost = scsi_host_lookup(ev->u.tgt_dscvr.host_no);\n\tif (!shost) {\n\t\tprintk(KERN_ERR \"target discovery could not find host no %u\\n\",\n\t\t       ev->u.tgt_dscvr.host_no);\n\t\treturn -ENODEV;\n\t}\n\n\n\tdst_addr = (struct sockaddr *)((char*)ev + sizeof(*ev));\n\terr = transport->tgt_dscvr(shost, ev->u.tgt_dscvr.type,\n\t\t\t\t   ev->u.tgt_dscvr.enable, dst_addr);\n\tscsi_host_put(shost);\n\treturn err;\n}\n\nstatic int\niscsi_set_host_param(struct iscsi_transport *transport,\n\t\t     struct iscsi_uevent *ev, u32 rlen)\n{\n\tchar *data = (char*)ev + sizeof(*ev);\n\tstruct Scsi_Host *shost;\n\tint err;\n\n\tif (!transport->set_host_param)\n\t\treturn -ENOSYS;\n\n\tif (ev->u.set_host_param.len > rlen ||\n\t    ev->u.set_host_param.len > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tshost = scsi_host_lookup(ev->u.set_host_param.host_no);\n\tif (!shost) {\n\t\tprintk(KERN_ERR \"set_host_param could not find host no %u\\n\",\n\t\t       ev->u.set_host_param.host_no);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (strlen(data) > ev->u.set_host_param.len)\n\t\treturn -EINVAL;\n\n\terr = transport->set_host_param(shost, ev->u.set_host_param.param,\n\t\t\t\t\tdata, ev->u.set_host_param.len);\n\tscsi_host_put(shost);\n\treturn err;\n}\n\nstatic int\niscsi_set_path(struct iscsi_transport *transport, struct iscsi_uevent *ev, u32 rlen)\n{\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_path *params;\n\tint err;\n\n\tif (rlen < sizeof(*params))\n\t\treturn -EINVAL;\n\n\tif (!transport->set_path)\n\t\treturn -ENOSYS;\n\n\tshost = scsi_host_lookup(ev->u.set_path.host_no);\n\tif (!shost) {\n\t\tprintk(KERN_ERR \"set path could not find host no %u\\n\",\n\t\t       ev->u.set_path.host_no);\n\t\treturn -ENODEV;\n\t}\n\n\tparams = (struct iscsi_path *)((char *)ev + sizeof(*ev));\n\terr = transport->set_path(shost, params);\n\n\tscsi_host_put(shost);\n\treturn err;\n}\n\nstatic int iscsi_session_has_conns(int sid)\n{\n\tstruct iscsi_cls_conn *conn;\n\tunsigned long flags;\n\tint found = 0;\n\n\tspin_lock_irqsave(&connlock, flags);\n\tlist_for_each_entry(conn, &connlist, conn_list) {\n\t\tif (iscsi_conn_get_sid(conn) == sid) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&connlock, flags);\n\n\treturn found;\n}\n\nstatic int\niscsi_set_iface_params(struct iscsi_transport *transport,\n\t\t       struct iscsi_uevent *ev, uint32_t len)\n{\n\tchar *data = (char *)ev + sizeof(*ev);\n\tstruct Scsi_Host *shost;\n\tint err;\n\n\tif (!transport->set_iface_param)\n\t\treturn -ENOSYS;\n\n\tshost = scsi_host_lookup(ev->u.set_iface_params.host_no);\n\tif (!shost) {\n\t\tprintk(KERN_ERR \"set_iface_params could not find host no %u\\n\",\n\t\t       ev->u.set_iface_params.host_no);\n\t\treturn -ENODEV;\n\t}\n\n\terr = transport->set_iface_param(shost, data, len);\n\tscsi_host_put(shost);\n\treturn err;\n}\n\nstatic int\niscsi_send_ping(struct iscsi_transport *transport, struct iscsi_uevent *ev, u32 rlen)\n{\n\tstruct Scsi_Host *shost;\n\tstruct sockaddr *dst_addr;\n\tint err;\n\n\tif (rlen < sizeof(*dst_addr))\n\t\treturn -EINVAL;\n\n\tif (!transport->send_ping)\n\t\treturn -ENOSYS;\n\n\tshost = scsi_host_lookup(ev->u.iscsi_ping.host_no);\n\tif (!shost) {\n\t\tprintk(KERN_ERR \"iscsi_ping could not find host no %u\\n\",\n\t\t       ev->u.iscsi_ping.host_no);\n\t\treturn -ENODEV;\n\t}\n\n\tdst_addr = (struct sockaddr *)((char *)ev + sizeof(*ev));\n\terr = transport->send_ping(shost, ev->u.iscsi_ping.iface_num,\n\t\t\t\t   ev->u.iscsi_ping.iface_type,\n\t\t\t\t   ev->u.iscsi_ping.payload_size,\n\t\t\t\t   ev->u.iscsi_ping.pid,\n\t\t\t\t   dst_addr);\n\tscsi_host_put(shost);\n\treturn err;\n}\n\nstatic int\niscsi_get_chap(struct iscsi_transport *transport, struct nlmsghdr *nlh)\n{\n\tstruct iscsi_uevent *ev = nlmsg_data(nlh);\n\tstruct Scsi_Host *shost = NULL;\n\tstruct iscsi_chap_rec *chap_rec;\n\tstruct iscsi_internal *priv;\n\tstruct sk_buff *skbchap;\n\tstruct nlmsghdr *nlhchap;\n\tstruct iscsi_uevent *evchap;\n\tuint32_t chap_buf_size;\n\tint len, err = 0;\n\tchar *buf;\n\n\tif (!transport->get_chap)\n\t\treturn -EINVAL;\n\n\tpriv = iscsi_if_transport_lookup(transport);\n\tif (!priv)\n\t\treturn -EINVAL;\n\n\tchap_buf_size = (ev->u.get_chap.num_entries * sizeof(*chap_rec));\n\tlen = nlmsg_total_size(sizeof(*ev) + chap_buf_size);\n\n\tshost = scsi_host_lookup(ev->u.get_chap.host_no);\n\tif (!shost) {\n\t\tprintk(KERN_ERR \"%s: failed. Could not find host no %u\\n\",\n\t\t       __func__, ev->u.get_chap.host_no);\n\t\treturn -ENODEV;\n\t}\n\n\tdo {\n\t\tint actual_size;\n\n\t\tskbchap = alloc_skb(len, GFP_KERNEL);\n\t\tif (!skbchap) {\n\t\t\tprintk(KERN_ERR \"can not deliver chap: OOM\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit_get_chap;\n\t\t}\n\n\t\tnlhchap = __nlmsg_put(skbchap, 0, 0, 0,\n\t\t\t\t      (len - sizeof(*nlhchap)), 0);\n\t\tevchap = nlmsg_data(nlhchap);\n\t\tmemset(evchap, 0, sizeof(*evchap));\n\t\tevchap->transport_handle = iscsi_handle(transport);\n\t\tevchap->type = nlh->nlmsg_type;\n\t\tevchap->u.get_chap.host_no = ev->u.get_chap.host_no;\n\t\tevchap->u.get_chap.chap_tbl_idx = ev->u.get_chap.chap_tbl_idx;\n\t\tevchap->u.get_chap.num_entries = ev->u.get_chap.num_entries;\n\t\tbuf = (char *)evchap + sizeof(*evchap);\n\t\tmemset(buf, 0, chap_buf_size);\n\n\t\terr = transport->get_chap(shost, ev->u.get_chap.chap_tbl_idx,\n\t\t\t\t    &evchap->u.get_chap.num_entries, buf);\n\n\t\tactual_size = nlmsg_total_size(sizeof(*ev) + chap_buf_size);\n\t\tskb_trim(skbchap, NLMSG_ALIGN(actual_size));\n\t\tnlhchap->nlmsg_len = actual_size;\n\n\t\terr = iscsi_multicast_skb(skbchap, ISCSI_NL_GRP_ISCSID,\n\t\t\t\t\t  GFP_KERNEL);\n\t} while (err < 0 && err != -ECONNREFUSED);\n\nexit_get_chap:\n\tscsi_host_put(shost);\n\treturn err;\n}\n\nstatic int iscsi_set_chap(struct iscsi_transport *transport,\n\t\t\t  struct iscsi_uevent *ev, uint32_t len)\n{\n\tchar *data = (char *)ev + sizeof(*ev);\n\tstruct Scsi_Host *shost;\n\tint err = 0;\n\n\tif (!transport->set_chap)\n\t\treturn -ENOSYS;\n\n\tshost = scsi_host_lookup(ev->u.set_path.host_no);\n\tif (!shost) {\n\t\tpr_err(\"%s could not find host no %u\\n\",\n\t\t       __func__, ev->u.set_path.host_no);\n\t\treturn -ENODEV;\n\t}\n\n\terr = transport->set_chap(shost, data, len);\n\tscsi_host_put(shost);\n\treturn err;\n}\n\nstatic int iscsi_delete_chap(struct iscsi_transport *transport,\n\t\t\t     struct iscsi_uevent *ev)\n{\n\tstruct Scsi_Host *shost;\n\tint err = 0;\n\n\tif (!transport->delete_chap)\n\t\treturn -ENOSYS;\n\n\tshost = scsi_host_lookup(ev->u.delete_chap.host_no);\n\tif (!shost) {\n\t\tprintk(KERN_ERR \"%s could not find host no %u\\n\",\n\t\t       __func__, ev->u.delete_chap.host_no);\n\t\treturn -ENODEV;\n\t}\n\n\terr = transport->delete_chap(shost, ev->u.delete_chap.chap_tbl_idx);\n\tscsi_host_put(shost);\n\treturn err;\n}\n\nstatic const struct {\n\tenum iscsi_discovery_parent_type value;\n\tchar\t\t\t\t*name;\n} iscsi_discovery_parent_names[] = {\n\t{ISCSI_DISC_PARENT_UNKNOWN,\t\"Unknown\" },\n\t{ISCSI_DISC_PARENT_SENDTGT,\t\"Sendtarget\" },\n\t{ISCSI_DISC_PARENT_ISNS,\t\"isns\" },\n};\n\nchar *iscsi_get_discovery_parent_name(int parent_type)\n{\n\tint i;\n\tchar *state = \"Unknown!\";\n\n\tfor (i = 0; i < ARRAY_SIZE(iscsi_discovery_parent_names); i++) {\n\t\tif (iscsi_discovery_parent_names[i].value & parent_type) {\n\t\t\tstate = iscsi_discovery_parent_names[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn state;\n}\nEXPORT_SYMBOL_GPL(iscsi_get_discovery_parent_name);\n\nstatic int iscsi_set_flashnode_param(struct iscsi_transport *transport,\n\t\t\t\t     struct iscsi_uevent *ev, uint32_t len)\n{\n\tchar *data = (char *)ev + sizeof(*ev);\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_bus_flash_session *fnode_sess;\n\tstruct iscsi_bus_flash_conn *fnode_conn;\n\tstruct device *dev;\n\tuint32_t idx;\n\tint err = 0;\n\n\tif (!transport->set_flashnode_param) {\n\t\terr = -ENOSYS;\n\t\tgoto exit_set_fnode;\n\t}\n\n\tshost = scsi_host_lookup(ev->u.set_flashnode.host_no);\n\tif (!shost) {\n\t\tpr_err(\"%s could not find host no %u\\n\",\n\t\t       __func__, ev->u.set_flashnode.host_no);\n\t\terr = -ENODEV;\n\t\tgoto exit_set_fnode;\n\t}\n\n\tidx = ev->u.set_flashnode.flashnode_idx;\n\tfnode_sess = iscsi_get_flashnode_by_index(shost, idx);\n\tif (!fnode_sess) {\n\t\tpr_err(\"%s could not find flashnode %u for host no %u\\n\",\n\t\t       __func__, idx, ev->u.set_flashnode.host_no);\n\t\terr = -ENODEV;\n\t\tgoto put_host;\n\t}\n\n\tdev = iscsi_find_flashnode_conn(fnode_sess);\n\tif (!dev) {\n\t\terr = -ENODEV;\n\t\tgoto put_sess;\n\t}\n\n\tfnode_conn = iscsi_dev_to_flash_conn(dev);\n\terr = transport->set_flashnode_param(fnode_sess, fnode_conn, data, len);\n\tput_device(dev);\n\nput_sess:\n\tput_device(&fnode_sess->dev);\n\nput_host:\n\tscsi_host_put(shost);\n\nexit_set_fnode:\n\treturn err;\n}\n\nstatic int iscsi_new_flashnode(struct iscsi_transport *transport,\n\t\t\t       struct iscsi_uevent *ev, uint32_t len)\n{\n\tchar *data = (char *)ev + sizeof(*ev);\n\tstruct Scsi_Host *shost;\n\tint index;\n\tint err = 0;\n\n\tif (!transport->new_flashnode) {\n\t\terr = -ENOSYS;\n\t\tgoto exit_new_fnode;\n\t}\n\n\tshost = scsi_host_lookup(ev->u.new_flashnode.host_no);\n\tif (!shost) {\n\t\tpr_err(\"%s could not find host no %u\\n\",\n\t\t       __func__, ev->u.new_flashnode.host_no);\n\t\terr = -ENODEV;\n\t\tgoto put_host;\n\t}\n\n\tindex = transport->new_flashnode(shost, data, len);\n\n\tif (index >= 0)\n\t\tev->r.new_flashnode_ret.flashnode_idx = index;\n\telse\n\t\terr = -EIO;\n\nput_host:\n\tscsi_host_put(shost);\n\nexit_new_fnode:\n\treturn err;\n}\n\nstatic int iscsi_del_flashnode(struct iscsi_transport *transport,\n\t\t\t       struct iscsi_uevent *ev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_bus_flash_session *fnode_sess;\n\tuint32_t idx;\n\tint err = 0;\n\n\tif (!transport->del_flashnode) {\n\t\terr = -ENOSYS;\n\t\tgoto exit_del_fnode;\n\t}\n\n\tshost = scsi_host_lookup(ev->u.del_flashnode.host_no);\n\tif (!shost) {\n\t\tpr_err(\"%s could not find host no %u\\n\",\n\t\t       __func__, ev->u.del_flashnode.host_no);\n\t\terr = -ENODEV;\n\t\tgoto put_host;\n\t}\n\n\tidx = ev->u.del_flashnode.flashnode_idx;\n\tfnode_sess = iscsi_get_flashnode_by_index(shost, idx);\n\tif (!fnode_sess) {\n\t\tpr_err(\"%s could not find flashnode %u for host no %u\\n\",\n\t\t       __func__, idx, ev->u.del_flashnode.host_no);\n\t\terr = -ENODEV;\n\t\tgoto put_host;\n\t}\n\n\terr = transport->del_flashnode(fnode_sess);\n\tput_device(&fnode_sess->dev);\n\nput_host:\n\tscsi_host_put(shost);\n\nexit_del_fnode:\n\treturn err;\n}\n\nstatic int iscsi_login_flashnode(struct iscsi_transport *transport,\n\t\t\t\t struct iscsi_uevent *ev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_bus_flash_session *fnode_sess;\n\tstruct iscsi_bus_flash_conn *fnode_conn;\n\tstruct device *dev;\n\tuint32_t idx;\n\tint err = 0;\n\n\tif (!transport->login_flashnode) {\n\t\terr = -ENOSYS;\n\t\tgoto exit_login_fnode;\n\t}\n\n\tshost = scsi_host_lookup(ev->u.login_flashnode.host_no);\n\tif (!shost) {\n\t\tpr_err(\"%s could not find host no %u\\n\",\n\t\t       __func__, ev->u.login_flashnode.host_no);\n\t\terr = -ENODEV;\n\t\tgoto put_host;\n\t}\n\n\tidx = ev->u.login_flashnode.flashnode_idx;\n\tfnode_sess = iscsi_get_flashnode_by_index(shost, idx);\n\tif (!fnode_sess) {\n\t\tpr_err(\"%s could not find flashnode %u for host no %u\\n\",\n\t\t       __func__, idx, ev->u.login_flashnode.host_no);\n\t\terr = -ENODEV;\n\t\tgoto put_host;\n\t}\n\n\tdev = iscsi_find_flashnode_conn(fnode_sess);\n\tif (!dev) {\n\t\terr = -ENODEV;\n\t\tgoto put_sess;\n\t}\n\n\tfnode_conn = iscsi_dev_to_flash_conn(dev);\n\terr = transport->login_flashnode(fnode_sess, fnode_conn);\n\tput_device(dev);\n\nput_sess:\n\tput_device(&fnode_sess->dev);\n\nput_host:\n\tscsi_host_put(shost);\n\nexit_login_fnode:\n\treturn err;\n}\n\nstatic int iscsi_logout_flashnode(struct iscsi_transport *transport,\n\t\t\t\t  struct iscsi_uevent *ev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_bus_flash_session *fnode_sess;\n\tstruct iscsi_bus_flash_conn *fnode_conn;\n\tstruct device *dev;\n\tuint32_t idx;\n\tint err = 0;\n\n\tif (!transport->logout_flashnode) {\n\t\terr = -ENOSYS;\n\t\tgoto exit_logout_fnode;\n\t}\n\n\tshost = scsi_host_lookup(ev->u.logout_flashnode.host_no);\n\tif (!shost) {\n\t\tpr_err(\"%s could not find host no %u\\n\",\n\t\t       __func__, ev->u.logout_flashnode.host_no);\n\t\terr = -ENODEV;\n\t\tgoto put_host;\n\t}\n\n\tidx = ev->u.logout_flashnode.flashnode_idx;\n\tfnode_sess = iscsi_get_flashnode_by_index(shost, idx);\n\tif (!fnode_sess) {\n\t\tpr_err(\"%s could not find flashnode %u for host no %u\\n\",\n\t\t       __func__, idx, ev->u.logout_flashnode.host_no);\n\t\terr = -ENODEV;\n\t\tgoto put_host;\n\t}\n\n\tdev = iscsi_find_flashnode_conn(fnode_sess);\n\tif (!dev) {\n\t\terr = -ENODEV;\n\t\tgoto put_sess;\n\t}\n\n\tfnode_conn = iscsi_dev_to_flash_conn(dev);\n\n\terr = transport->logout_flashnode(fnode_sess, fnode_conn);\n\tput_device(dev);\n\nput_sess:\n\tput_device(&fnode_sess->dev);\n\nput_host:\n\tscsi_host_put(shost);\n\nexit_logout_fnode:\n\treturn err;\n}\n\nstatic int iscsi_logout_flashnode_sid(struct iscsi_transport *transport,\n\t\t\t\t      struct iscsi_uevent *ev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_cls_session *session;\n\tint err = 0;\n\n\tif (!transport->logout_flashnode_sid) {\n\t\terr = -ENOSYS;\n\t\tgoto exit_logout_sid;\n\t}\n\n\tshost = scsi_host_lookup(ev->u.logout_flashnode_sid.host_no);\n\tif (!shost) {\n\t\tpr_err(\"%s could not find host no %u\\n\",\n\t\t       __func__, ev->u.logout_flashnode.host_no);\n\t\terr = -ENODEV;\n\t\tgoto put_host;\n\t}\n\n\tsession = iscsi_session_lookup(ev->u.logout_flashnode_sid.sid);\n\tif (!session) {\n\t\tpr_err(\"%s could not find session id %u\\n\",\n\t\t       __func__, ev->u.logout_flashnode_sid.sid);\n\t\terr = -EINVAL;\n\t\tgoto put_host;\n\t}\n\n\terr = transport->logout_flashnode_sid(session);\n\nput_host:\n\tscsi_host_put(shost);\n\nexit_logout_sid:\n\treturn err;\n}\n\nstatic int\niscsi_get_host_stats(struct iscsi_transport *transport, struct nlmsghdr *nlh)\n{\n\tstruct iscsi_uevent *ev = nlmsg_data(nlh);\n\tstruct Scsi_Host *shost = NULL;\n\tstruct iscsi_internal *priv;\n\tstruct sk_buff *skbhost_stats;\n\tstruct nlmsghdr *nlhhost_stats;\n\tstruct iscsi_uevent *evhost_stats;\n\tint host_stats_size = 0;\n\tint len, err = 0;\n\tchar *buf;\n\n\tif (!transport->get_host_stats)\n\t\treturn -ENOSYS;\n\n\tpriv = iscsi_if_transport_lookup(transport);\n\tif (!priv)\n\t\treturn -EINVAL;\n\n\thost_stats_size = sizeof(struct iscsi_offload_host_stats);\n\tlen = nlmsg_total_size(sizeof(*ev) + host_stats_size);\n\n\tshost = scsi_host_lookup(ev->u.get_host_stats.host_no);\n\tif (!shost) {\n\t\tpr_err(\"%s: failed. Could not find host no %u\\n\",\n\t\t       __func__, ev->u.get_host_stats.host_no);\n\t\treturn -ENODEV;\n\t}\n\n\tdo {\n\t\tint actual_size;\n\n\t\tskbhost_stats = alloc_skb(len, GFP_KERNEL);\n\t\tif (!skbhost_stats) {\n\t\t\tpr_err(\"cannot deliver host stats: OOM\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit_host_stats;\n\t\t}\n\n\t\tnlhhost_stats = __nlmsg_put(skbhost_stats, 0, 0, 0,\n\t\t\t\t      (len - sizeof(*nlhhost_stats)), 0);\n\t\tevhost_stats = nlmsg_data(nlhhost_stats);\n\t\tmemset(evhost_stats, 0, sizeof(*evhost_stats));\n\t\tevhost_stats->transport_handle = iscsi_handle(transport);\n\t\tevhost_stats->type = nlh->nlmsg_type;\n\t\tevhost_stats->u.get_host_stats.host_no =\n\t\t\t\t\tev->u.get_host_stats.host_no;\n\t\tbuf = (char *)evhost_stats + sizeof(*evhost_stats);\n\t\tmemset(buf, 0, host_stats_size);\n\n\t\terr = transport->get_host_stats(shost, buf, host_stats_size);\n\t\tif (err) {\n\t\t\tkfree_skb(skbhost_stats);\n\t\t\tgoto exit_host_stats;\n\t\t}\n\n\t\tactual_size = nlmsg_total_size(sizeof(*ev) + host_stats_size);\n\t\tskb_trim(skbhost_stats, NLMSG_ALIGN(actual_size));\n\t\tnlhhost_stats->nlmsg_len = actual_size;\n\n\t\terr = iscsi_multicast_skb(skbhost_stats, ISCSI_NL_GRP_ISCSID,\n\t\t\t\t\t  GFP_KERNEL);\n\t} while (err < 0 && err != -ECONNREFUSED);\n\nexit_host_stats:\n\tscsi_host_put(shost);\n\treturn err;\n}\n\nstatic int iscsi_if_transport_conn(struct iscsi_transport *transport,\n\t\t\t\t   struct nlmsghdr *nlh, u32 pdu_len)\n{\n\tstruct iscsi_uevent *ev = nlmsg_data(nlh);\n\tstruct iscsi_cls_session *session;\n\tstruct iscsi_cls_conn *conn = NULL;\n\tstruct iscsi_endpoint *ep;\n\tint err = 0;\n\n\tswitch (nlh->nlmsg_type) {\n\tcase ISCSI_UEVENT_CREATE_CONN:\n\t\treturn iscsi_if_create_conn(transport, ev);\n\tcase ISCSI_UEVENT_DESTROY_CONN:\n\t\treturn iscsi_if_destroy_conn(transport, ev);\n\tcase ISCSI_UEVENT_STOP_CONN:\n\t\tconn = iscsi_conn_lookup(ev->u.stop_conn.sid,\n\t\t\t\t\t ev->u.stop_conn.cid);\n\t\tif (!conn)\n\t\t\treturn -EINVAL;\n\n\t\treturn iscsi_if_stop_conn(conn, ev->u.stop_conn.flag);\n\t}\n\n\t \n\tswitch (nlh->nlmsg_type) {\n\tcase ISCSI_UEVENT_START_CONN:\n\t\tconn = iscsi_conn_lookup(ev->u.start_conn.sid,\n\t\t\t\t\t ev->u.start_conn.cid);\n\t\tbreak;\n\tcase ISCSI_UEVENT_BIND_CONN:\n\t\tconn = iscsi_conn_lookup(ev->u.b_conn.sid, ev->u.b_conn.cid);\n\t\tbreak;\n\tcase ISCSI_UEVENT_SEND_PDU:\n\t\tconn = iscsi_conn_lookup(ev->u.send_pdu.sid, ev->u.send_pdu.cid);\n\t\tbreak;\n\t}\n\n\tif (!conn)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&conn->ep_mutex);\n\tspin_lock_irq(&conn->lock);\n\tif (test_bit(ISCSI_CLS_CONN_BIT_CLEANUP, &conn->flags)) {\n\t\tspin_unlock_irq(&conn->lock);\n\t\tmutex_unlock(&conn->ep_mutex);\n\t\tev->r.retcode = -ENOTCONN;\n\t\treturn 0;\n\t}\n\tspin_unlock_irq(&conn->lock);\n\n\tswitch (nlh->nlmsg_type) {\n\tcase ISCSI_UEVENT_BIND_CONN:\n\t\tsession = iscsi_session_lookup(ev->u.b_conn.sid);\n\t\tif (!session) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tev->r.retcode =\ttransport->bind_conn(session, conn,\n\t\t\t\t\t\tev->u.b_conn.transport_eph,\n\t\t\t\t\t\tev->u.b_conn.is_leading);\n\t\tif (!ev->r.retcode)\n\t\t\tWRITE_ONCE(conn->state, ISCSI_CONN_BOUND);\n\n\t\tif (ev->r.retcode || !transport->ep_connect)\n\t\t\tbreak;\n\n\t\tep = iscsi_lookup_endpoint(ev->u.b_conn.transport_eph);\n\t\tif (ep) {\n\t\t\tep->conn = conn;\n\t\t\tconn->ep = ep;\n\t\t\tiscsi_put_endpoint(ep);\n\t\t} else {\n\t\t\terr = -ENOTCONN;\n\t\t\tiscsi_cls_conn_printk(KERN_ERR, conn,\n\t\t\t\t\t      \"Could not set ep conn binding\\n\");\n\t\t}\n\t\tbreak;\n\tcase ISCSI_UEVENT_START_CONN:\n\t\tev->r.retcode = transport->start_conn(conn);\n\t\tif (!ev->r.retcode)\n\t\t\tWRITE_ONCE(conn->state, ISCSI_CONN_UP);\n\n\t\tbreak;\n\tcase ISCSI_UEVENT_SEND_PDU:\n\t\tif ((ev->u.send_pdu.hdr_size > pdu_len) ||\n\t\t    (ev->u.send_pdu.data_size > (pdu_len - ev->u.send_pdu.hdr_size))) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tev->r.retcode =\ttransport->send_pdu(conn,\n\t\t\t\t(struct iscsi_hdr *)((char *)ev + sizeof(*ev)),\n\t\t\t\t(char *)ev + sizeof(*ev) + ev->u.send_pdu.hdr_size,\n\t\t\t\tev->u.send_pdu.data_size);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOSYS;\n\t}\n\n\tmutex_unlock(&conn->ep_mutex);\n\treturn err;\n}\n\nstatic int\niscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, uint32_t *group)\n{\n\tint err = 0;\n\tu32 portid;\n\tstruct iscsi_uevent *ev = nlmsg_data(nlh);\n\tstruct iscsi_transport *transport = NULL;\n\tstruct iscsi_internal *priv;\n\tstruct iscsi_cls_session *session;\n\tstruct iscsi_endpoint *ep = NULL;\n\tu32 rlen;\n\n\tif (!netlink_capable(skb, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (nlh->nlmsg_type == ISCSI_UEVENT_PATH_UPDATE)\n\t\t*group = ISCSI_NL_GRP_UIP;\n\telse\n\t\t*group = ISCSI_NL_GRP_ISCSID;\n\n\tpriv = iscsi_if_transport_lookup(iscsi_ptr(ev->transport_handle));\n\tif (!priv)\n\t\treturn -EINVAL;\n\ttransport = priv->iscsi_transport;\n\n\tif (!try_module_get(transport->owner))\n\t\treturn -EINVAL;\n\n\tportid = NETLINK_CB(skb).portid;\n\n\t \n\trlen = nlmsg_attrlen(nlh, sizeof(*ev));\n\n\tswitch (nlh->nlmsg_type) {\n\tcase ISCSI_UEVENT_CREATE_SESSION:\n\t\terr = iscsi_if_create_session(priv, ep, ev,\n\t\t\t\t\t      portid,\n\t\t\t\t\t      ev->u.c_session.initial_cmdsn,\n\t\t\t\t\t      ev->u.c_session.cmds_max,\n\t\t\t\t\t      ev->u.c_session.queue_depth);\n\t\tbreak;\n\tcase ISCSI_UEVENT_CREATE_BOUND_SESSION:\n\t\tep = iscsi_lookup_endpoint(ev->u.c_bound_session.ep_handle);\n\t\tif (!ep) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = iscsi_if_create_session(priv, ep, ev,\n\t\t\t\t\tportid,\n\t\t\t\t\tev->u.c_bound_session.initial_cmdsn,\n\t\t\t\t\tev->u.c_bound_session.cmds_max,\n\t\t\t\t\tev->u.c_bound_session.queue_depth);\n\t\tiscsi_put_endpoint(ep);\n\t\tbreak;\n\tcase ISCSI_UEVENT_DESTROY_SESSION:\n\t\tsession = iscsi_session_lookup(ev->u.d_session.sid);\n\t\tif (!session)\n\t\t\terr = -EINVAL;\n\t\telse if (iscsi_session_has_conns(ev->u.d_session.sid))\n\t\t\terr = -EBUSY;\n\t\telse\n\t\t\ttransport->destroy_session(session);\n\t\tbreak;\n\tcase ISCSI_UEVENT_DESTROY_SESSION_ASYNC:\n\t\tsession = iscsi_session_lookup(ev->u.d_session.sid);\n\t\tif (!session)\n\t\t\terr = -EINVAL;\n\t\telse if (iscsi_session_has_conns(ev->u.d_session.sid))\n\t\t\terr = -EBUSY;\n\t\telse {\n\t\t\tunsigned long flags;\n\n\t\t\t \n\t\t\tspin_lock_irqsave(&sesslock, flags);\n\t\t\tlist_del_init(&session->sess_list);\n\t\t\tspin_unlock_irqrestore(&sesslock, flags);\n\n\t\t\tqueue_work(system_unbound_wq, &session->destroy_work);\n\t\t}\n\t\tbreak;\n\tcase ISCSI_UEVENT_UNBIND_SESSION:\n\t\tsession = iscsi_session_lookup(ev->u.d_session.sid);\n\t\tif (session)\n\t\t\tqueue_work(session->workq, &session->unbind_work);\n\t\telse\n\t\t\terr = -EINVAL;\n\t\tbreak;\n\tcase ISCSI_UEVENT_SET_PARAM:\n\t\terr = iscsi_if_set_param(transport, ev, rlen);\n\t\tbreak;\n\tcase ISCSI_UEVENT_CREATE_CONN:\n\tcase ISCSI_UEVENT_DESTROY_CONN:\n\tcase ISCSI_UEVENT_STOP_CONN:\n\tcase ISCSI_UEVENT_START_CONN:\n\tcase ISCSI_UEVENT_BIND_CONN:\n\tcase ISCSI_UEVENT_SEND_PDU:\n\t\terr = iscsi_if_transport_conn(transport, nlh, rlen);\n\t\tbreak;\n\tcase ISCSI_UEVENT_GET_STATS:\n\t\terr = iscsi_if_get_stats(transport, nlh);\n\t\tbreak;\n\tcase ISCSI_UEVENT_TRANSPORT_EP_CONNECT:\n\tcase ISCSI_UEVENT_TRANSPORT_EP_POLL:\n\tcase ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT:\n\tcase ISCSI_UEVENT_TRANSPORT_EP_CONNECT_THROUGH_HOST:\n\t\terr = iscsi_if_transport_ep(transport, ev, nlh->nlmsg_type, rlen);\n\t\tbreak;\n\tcase ISCSI_UEVENT_TGT_DSCVR:\n\t\terr = iscsi_tgt_dscvr(transport, ev, rlen);\n\t\tbreak;\n\tcase ISCSI_UEVENT_SET_HOST_PARAM:\n\t\terr = iscsi_set_host_param(transport, ev, rlen);\n\t\tbreak;\n\tcase ISCSI_UEVENT_PATH_UPDATE:\n\t\terr = iscsi_set_path(transport, ev, rlen);\n\t\tbreak;\n\tcase ISCSI_UEVENT_SET_IFACE_PARAMS:\n\t\terr = iscsi_set_iface_params(transport, ev, rlen);\n\t\tbreak;\n\tcase ISCSI_UEVENT_PING:\n\t\terr = iscsi_send_ping(transport, ev, rlen);\n\t\tbreak;\n\tcase ISCSI_UEVENT_GET_CHAP:\n\t\terr = iscsi_get_chap(transport, nlh);\n\t\tbreak;\n\tcase ISCSI_UEVENT_DELETE_CHAP:\n\t\terr = iscsi_delete_chap(transport, ev);\n\t\tbreak;\n\tcase ISCSI_UEVENT_SET_FLASHNODE_PARAMS:\n\t\terr = iscsi_set_flashnode_param(transport, ev, rlen);\n\t\tbreak;\n\tcase ISCSI_UEVENT_NEW_FLASHNODE:\n\t\terr = iscsi_new_flashnode(transport, ev, rlen);\n\t\tbreak;\n\tcase ISCSI_UEVENT_DEL_FLASHNODE:\n\t\terr = iscsi_del_flashnode(transport, ev);\n\t\tbreak;\n\tcase ISCSI_UEVENT_LOGIN_FLASHNODE:\n\t\terr = iscsi_login_flashnode(transport, ev);\n\t\tbreak;\n\tcase ISCSI_UEVENT_LOGOUT_FLASHNODE:\n\t\terr = iscsi_logout_flashnode(transport, ev);\n\t\tbreak;\n\tcase ISCSI_UEVENT_LOGOUT_FLASHNODE_SID:\n\t\terr = iscsi_logout_flashnode_sid(transport, ev);\n\t\tbreak;\n\tcase ISCSI_UEVENT_SET_CHAP:\n\t\terr = iscsi_set_chap(transport, ev, rlen);\n\t\tbreak;\n\tcase ISCSI_UEVENT_GET_HOST_STATS:\n\t\terr = iscsi_get_host_stats(transport, nlh);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOSYS;\n\t\tbreak;\n\t}\n\n\tmodule_put(transport->owner);\n\treturn err;\n}\n\n \nstatic void\niscsi_if_rx(struct sk_buff *skb)\n{\n\tu32 portid = NETLINK_CB(skb).portid;\n\n\tmutex_lock(&rx_queue_mutex);\n\twhile (skb->len >= NLMSG_HDRLEN) {\n\t\tint err;\n\t\tuint32_t rlen;\n\t\tstruct nlmsghdr\t*nlh;\n\t\tstruct iscsi_uevent *ev;\n\t\tuint32_t group;\n\t\tint retries = ISCSI_SEND_MAX_ALLOWED;\n\n\t\tnlh = nlmsg_hdr(skb);\n\t\tif (nlh->nlmsg_len < sizeof(*nlh) + sizeof(*ev) ||\n\t\t    skb->len < nlh->nlmsg_len) {\n\t\t\tbreak;\n\t\t}\n\n\t\tev = nlmsg_data(nlh);\n\t\trlen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (rlen > skb->len)\n\t\t\trlen = skb->len;\n\n\t\terr = iscsi_if_recv_msg(skb, nlh, &group);\n\t\tif (err) {\n\t\t\tev->type = ISCSI_KEVENT_IF_ERROR;\n\t\t\tev->iferror = err;\n\t\t}\n\t\tdo {\n\t\t\t \n\t\t\tif (ev->type == ISCSI_UEVENT_GET_STATS && !err)\n\t\t\t\tbreak;\n\t\t\tif (ev->type == ISCSI_UEVENT_GET_CHAP && !err)\n\t\t\t\tbreak;\n\t\t\terr = iscsi_if_send_reply(portid, nlh->nlmsg_type,\n\t\t\t\t\t\t  ev, sizeof(*ev));\n\t\t\tif (err == -EAGAIN && --retries < 0) {\n\t\t\t\tprintk(KERN_WARNING \"Send reply failed, error %d\\n\", err);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (err < 0 && err != -ECONNREFUSED && err != -ESRCH);\n\t\tskb_pull(skb, rlen);\n\t}\n\tmutex_unlock(&rx_queue_mutex);\n}\n\n#define ISCSI_CLASS_ATTR(_prefix,_name,_mode,_show,_store)\t\t\\\nstruct device_attribute dev_attr_##_prefix##_##_name =\t\\\n\t__ATTR(_name,_mode,_show,_store)\n\n \n#define iscsi_conn_attr_show(param)\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_conn_param_##param(struct device *dev, \t\t\t\t\\\n\t\t\tstruct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct iscsi_cls_conn *conn = iscsi_dev_to_conn(dev->parent);\t\\\n\tstruct iscsi_transport *t = conn->transport;\t\t\t\\\n\treturn t->get_conn_param(conn, param, buf);\t\t\t\\\n}\n\n#define iscsi_conn_attr(field, param)\t\t\t\t\t\\\n\tiscsi_conn_attr_show(param)\t\t\t\t\t\\\nstatic ISCSI_CLASS_ATTR(conn, field, S_IRUGO, show_conn_param_##param,\t\\\n\t\t\tNULL);\n\niscsi_conn_attr(max_recv_dlength, ISCSI_PARAM_MAX_RECV_DLENGTH);\niscsi_conn_attr(max_xmit_dlength, ISCSI_PARAM_MAX_XMIT_DLENGTH);\niscsi_conn_attr(header_digest, ISCSI_PARAM_HDRDGST_EN);\niscsi_conn_attr(data_digest, ISCSI_PARAM_DATADGST_EN);\niscsi_conn_attr(ifmarker, ISCSI_PARAM_IFMARKER_EN);\niscsi_conn_attr(ofmarker, ISCSI_PARAM_OFMARKER_EN);\niscsi_conn_attr(persistent_port, ISCSI_PARAM_PERSISTENT_PORT);\niscsi_conn_attr(exp_statsn, ISCSI_PARAM_EXP_STATSN);\niscsi_conn_attr(persistent_address, ISCSI_PARAM_PERSISTENT_ADDRESS);\niscsi_conn_attr(ping_tmo, ISCSI_PARAM_PING_TMO);\niscsi_conn_attr(recv_tmo, ISCSI_PARAM_RECV_TMO);\niscsi_conn_attr(local_port, ISCSI_PARAM_LOCAL_PORT);\niscsi_conn_attr(statsn, ISCSI_PARAM_STATSN);\niscsi_conn_attr(keepalive_tmo, ISCSI_PARAM_KEEPALIVE_TMO);\niscsi_conn_attr(max_segment_size, ISCSI_PARAM_MAX_SEGMENT_SIZE);\niscsi_conn_attr(tcp_timestamp_stat, ISCSI_PARAM_TCP_TIMESTAMP_STAT);\niscsi_conn_attr(tcp_wsf_disable, ISCSI_PARAM_TCP_WSF_DISABLE);\niscsi_conn_attr(tcp_nagle_disable, ISCSI_PARAM_TCP_NAGLE_DISABLE);\niscsi_conn_attr(tcp_timer_scale, ISCSI_PARAM_TCP_TIMER_SCALE);\niscsi_conn_attr(tcp_timestamp_enable, ISCSI_PARAM_TCP_TIMESTAMP_EN);\niscsi_conn_attr(fragment_disable, ISCSI_PARAM_IP_FRAGMENT_DISABLE);\niscsi_conn_attr(ipv4_tos, ISCSI_PARAM_IPV4_TOS);\niscsi_conn_attr(ipv6_traffic_class, ISCSI_PARAM_IPV6_TC);\niscsi_conn_attr(ipv6_flow_label, ISCSI_PARAM_IPV6_FLOW_LABEL);\niscsi_conn_attr(is_fw_assigned_ipv6, ISCSI_PARAM_IS_FW_ASSIGNED_IPV6);\niscsi_conn_attr(tcp_xmit_wsf, ISCSI_PARAM_TCP_XMIT_WSF);\niscsi_conn_attr(tcp_recv_wsf, ISCSI_PARAM_TCP_RECV_WSF);\niscsi_conn_attr(local_ipaddr, ISCSI_PARAM_LOCAL_IPADDR);\n\nstatic const char *const connection_state_names[] = {\n\t[ISCSI_CONN_UP] = \"up\",\n\t[ISCSI_CONN_DOWN] = \"down\",\n\t[ISCSI_CONN_FAILED] = \"failed\",\n\t[ISCSI_CONN_BOUND] = \"bound\"\n};\n\nstatic ssize_t show_conn_state(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct iscsi_cls_conn *conn = iscsi_dev_to_conn(dev->parent);\n\tconst char *state = \"unknown\";\n\tint conn_state = READ_ONCE(conn->state);\n\n\tif (conn_state >= 0 &&\n\t    conn_state < ARRAY_SIZE(connection_state_names))\n\t\tstate = connection_state_names[conn_state];\n\n\treturn sysfs_emit(buf, \"%s\\n\", state);\n}\nstatic ISCSI_CLASS_ATTR(conn, state, S_IRUGO, show_conn_state,\n\t\t\tNULL);\n\n#define iscsi_conn_ep_attr_show(param)\t\t\t\t\t\\\nstatic ssize_t show_conn_ep_param_##param(struct device *dev,\t\t\\\n\t\t\t\t\t  struct device_attribute *attr,\\\n\t\t\t\t\t  char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct iscsi_cls_conn *conn = iscsi_dev_to_conn(dev->parent);\t\\\n\tstruct iscsi_transport *t = conn->transport;\t\t\t\\\n\tstruct iscsi_endpoint *ep;\t\t\t\t\t\\\n\tssize_t rc;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\t\t\t\\\n\tmutex_lock(&conn->ep_mutex);\t\t\t\t\t\\\n\tep = conn->ep;\t\t\t\t\t\t\t\\\n\tif (!ep && t->ep_connect) {\t\t\t\t\t\\\n\t\tmutex_unlock(&conn->ep_mutex);\t\t\t\t\\\n\t\treturn -ENOTCONN;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (ep)\t\t\t\t\t\t\t\t\\\n\t\trc = t->get_ep_param(ep, param, buf);\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\trc = t->get_conn_param(conn, param, buf);\t\t\\\n\tmutex_unlock(&conn->ep_mutex);\t\t\t\t\t\\\n\treturn rc;\t\t\t\t\t\t\t\\\n}\n\n#define iscsi_conn_ep_attr(field, param)\t\t\t\t\\\n\tiscsi_conn_ep_attr_show(param)\t\t\t\t\t\\\nstatic ISCSI_CLASS_ATTR(conn, field, S_IRUGO,\t\t\t\t\\\n\t\t\tshow_conn_ep_param_##param, NULL);\n\niscsi_conn_ep_attr(address, ISCSI_PARAM_CONN_ADDRESS);\niscsi_conn_ep_attr(port, ISCSI_PARAM_CONN_PORT);\n\nstatic struct attribute *iscsi_conn_attrs[] = {\n\t&dev_attr_conn_max_recv_dlength.attr,\n\t&dev_attr_conn_max_xmit_dlength.attr,\n\t&dev_attr_conn_header_digest.attr,\n\t&dev_attr_conn_data_digest.attr,\n\t&dev_attr_conn_ifmarker.attr,\n\t&dev_attr_conn_ofmarker.attr,\n\t&dev_attr_conn_address.attr,\n\t&dev_attr_conn_port.attr,\n\t&dev_attr_conn_exp_statsn.attr,\n\t&dev_attr_conn_persistent_address.attr,\n\t&dev_attr_conn_persistent_port.attr,\n\t&dev_attr_conn_ping_tmo.attr,\n\t&dev_attr_conn_recv_tmo.attr,\n\t&dev_attr_conn_local_port.attr,\n\t&dev_attr_conn_statsn.attr,\n\t&dev_attr_conn_keepalive_tmo.attr,\n\t&dev_attr_conn_max_segment_size.attr,\n\t&dev_attr_conn_tcp_timestamp_stat.attr,\n\t&dev_attr_conn_tcp_wsf_disable.attr,\n\t&dev_attr_conn_tcp_nagle_disable.attr,\n\t&dev_attr_conn_tcp_timer_scale.attr,\n\t&dev_attr_conn_tcp_timestamp_enable.attr,\n\t&dev_attr_conn_fragment_disable.attr,\n\t&dev_attr_conn_ipv4_tos.attr,\n\t&dev_attr_conn_ipv6_traffic_class.attr,\n\t&dev_attr_conn_ipv6_flow_label.attr,\n\t&dev_attr_conn_is_fw_assigned_ipv6.attr,\n\t&dev_attr_conn_tcp_xmit_wsf.attr,\n\t&dev_attr_conn_tcp_recv_wsf.attr,\n\t&dev_attr_conn_local_ipaddr.attr,\n\t&dev_attr_conn_state.attr,\n\tNULL,\n};\n\nstatic umode_t iscsi_conn_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t struct attribute *attr, int i)\n{\n\tstruct device *cdev = container_of(kobj, struct device, kobj);\n\tstruct iscsi_cls_conn *conn = transport_class_to_conn(cdev);\n\tstruct iscsi_transport *t = conn->transport;\n\tint param;\n\n\tif (attr == &dev_attr_conn_max_recv_dlength.attr)\n\t\tparam = ISCSI_PARAM_MAX_RECV_DLENGTH;\n\telse if (attr == &dev_attr_conn_max_xmit_dlength.attr)\n\t\tparam = ISCSI_PARAM_MAX_XMIT_DLENGTH;\n\telse if (attr == &dev_attr_conn_header_digest.attr)\n\t\tparam = ISCSI_PARAM_HDRDGST_EN;\n\telse if (attr == &dev_attr_conn_data_digest.attr)\n\t\tparam = ISCSI_PARAM_DATADGST_EN;\n\telse if (attr == &dev_attr_conn_ifmarker.attr)\n\t\tparam = ISCSI_PARAM_IFMARKER_EN;\n\telse if (attr == &dev_attr_conn_ofmarker.attr)\n\t\tparam = ISCSI_PARAM_OFMARKER_EN;\n\telse if (attr == &dev_attr_conn_address.attr)\n\t\tparam = ISCSI_PARAM_CONN_ADDRESS;\n\telse if (attr == &dev_attr_conn_port.attr)\n\t\tparam = ISCSI_PARAM_CONN_PORT;\n\telse if (attr == &dev_attr_conn_exp_statsn.attr)\n\t\tparam = ISCSI_PARAM_EXP_STATSN;\n\telse if (attr == &dev_attr_conn_persistent_address.attr)\n\t\tparam = ISCSI_PARAM_PERSISTENT_ADDRESS;\n\telse if (attr == &dev_attr_conn_persistent_port.attr)\n\t\tparam = ISCSI_PARAM_PERSISTENT_PORT;\n\telse if (attr == &dev_attr_conn_ping_tmo.attr)\n\t\tparam = ISCSI_PARAM_PING_TMO;\n\telse if (attr == &dev_attr_conn_recv_tmo.attr)\n\t\tparam = ISCSI_PARAM_RECV_TMO;\n\telse if (attr == &dev_attr_conn_local_port.attr)\n\t\tparam = ISCSI_PARAM_LOCAL_PORT;\n\telse if (attr == &dev_attr_conn_statsn.attr)\n\t\tparam = ISCSI_PARAM_STATSN;\n\telse if (attr == &dev_attr_conn_keepalive_tmo.attr)\n\t\tparam = ISCSI_PARAM_KEEPALIVE_TMO;\n\telse if (attr == &dev_attr_conn_max_segment_size.attr)\n\t\tparam = ISCSI_PARAM_MAX_SEGMENT_SIZE;\n\telse if (attr == &dev_attr_conn_tcp_timestamp_stat.attr)\n\t\tparam = ISCSI_PARAM_TCP_TIMESTAMP_STAT;\n\telse if (attr == &dev_attr_conn_tcp_wsf_disable.attr)\n\t\tparam = ISCSI_PARAM_TCP_WSF_DISABLE;\n\telse if (attr == &dev_attr_conn_tcp_nagle_disable.attr)\n\t\tparam = ISCSI_PARAM_TCP_NAGLE_DISABLE;\n\telse if (attr == &dev_attr_conn_tcp_timer_scale.attr)\n\t\tparam = ISCSI_PARAM_TCP_TIMER_SCALE;\n\telse if (attr == &dev_attr_conn_tcp_timestamp_enable.attr)\n\t\tparam = ISCSI_PARAM_TCP_TIMESTAMP_EN;\n\telse if (attr == &dev_attr_conn_fragment_disable.attr)\n\t\tparam = ISCSI_PARAM_IP_FRAGMENT_DISABLE;\n\telse if (attr == &dev_attr_conn_ipv4_tos.attr)\n\t\tparam = ISCSI_PARAM_IPV4_TOS;\n\telse if (attr == &dev_attr_conn_ipv6_traffic_class.attr)\n\t\tparam = ISCSI_PARAM_IPV6_TC;\n\telse if (attr == &dev_attr_conn_ipv6_flow_label.attr)\n\t\tparam = ISCSI_PARAM_IPV6_FLOW_LABEL;\n\telse if (attr == &dev_attr_conn_is_fw_assigned_ipv6.attr)\n\t\tparam = ISCSI_PARAM_IS_FW_ASSIGNED_IPV6;\n\telse if (attr == &dev_attr_conn_tcp_xmit_wsf.attr)\n\t\tparam = ISCSI_PARAM_TCP_XMIT_WSF;\n\telse if (attr == &dev_attr_conn_tcp_recv_wsf.attr)\n\t\tparam = ISCSI_PARAM_TCP_RECV_WSF;\n\telse if (attr == &dev_attr_conn_local_ipaddr.attr)\n\t\tparam = ISCSI_PARAM_LOCAL_IPADDR;\n\telse if (attr == &dev_attr_conn_state.attr)\n\t\treturn S_IRUGO;\n\telse {\n\t\tWARN_ONCE(1, \"Invalid conn attr\");\n\t\treturn 0;\n\t}\n\n\treturn t->attr_is_visible(ISCSI_PARAM, param);\n}\n\nstatic struct attribute_group iscsi_conn_group = {\n\t.attrs = iscsi_conn_attrs,\n\t.is_visible = iscsi_conn_attr_is_visible,\n};\n\n \n#define iscsi_session_attr_show(param, perm)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_session_param_##param(struct device *dev,\t\t\t\t\\\n\t\t\t   struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct iscsi_cls_session *session = \t\t\t\t\\\n\t\tiscsi_dev_to_session(dev->parent);\t\t\t\\\n\tstruct iscsi_transport *t = session->transport;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (perm && !capable(CAP_SYS_ADMIN))\t\t\t\t\\\n\t\treturn -EACCES;\t\t\t\t\t\t\\\n\treturn t->get_session_param(session, param, buf);\t\t\\\n}\n\n#define iscsi_session_attr(field, param, perm)\t\t\t\t\\\n\tiscsi_session_attr_show(param, perm)\t\t\t\t\\\nstatic ISCSI_CLASS_ATTR(sess, field, S_IRUGO, show_session_param_##param, \\\n\t\t\tNULL);\niscsi_session_attr(targetname, ISCSI_PARAM_TARGET_NAME, 0);\niscsi_session_attr(initial_r2t, ISCSI_PARAM_INITIAL_R2T_EN, 0);\niscsi_session_attr(max_outstanding_r2t, ISCSI_PARAM_MAX_R2T, 0);\niscsi_session_attr(immediate_data, ISCSI_PARAM_IMM_DATA_EN, 0);\niscsi_session_attr(first_burst_len, ISCSI_PARAM_FIRST_BURST, 0);\niscsi_session_attr(max_burst_len, ISCSI_PARAM_MAX_BURST, 0);\niscsi_session_attr(data_pdu_in_order, ISCSI_PARAM_PDU_INORDER_EN, 0);\niscsi_session_attr(data_seq_in_order, ISCSI_PARAM_DATASEQ_INORDER_EN, 0);\niscsi_session_attr(erl, ISCSI_PARAM_ERL, 0);\niscsi_session_attr(tpgt, ISCSI_PARAM_TPGT, 0);\niscsi_session_attr(username, ISCSI_PARAM_USERNAME, 1);\niscsi_session_attr(username_in, ISCSI_PARAM_USERNAME_IN, 1);\niscsi_session_attr(password, ISCSI_PARAM_PASSWORD, 1);\niscsi_session_attr(password_in, ISCSI_PARAM_PASSWORD_IN, 1);\niscsi_session_attr(chap_out_idx, ISCSI_PARAM_CHAP_OUT_IDX, 1);\niscsi_session_attr(chap_in_idx, ISCSI_PARAM_CHAP_IN_IDX, 1);\niscsi_session_attr(fast_abort, ISCSI_PARAM_FAST_ABORT, 0);\niscsi_session_attr(abort_tmo, ISCSI_PARAM_ABORT_TMO, 0);\niscsi_session_attr(lu_reset_tmo, ISCSI_PARAM_LU_RESET_TMO, 0);\niscsi_session_attr(tgt_reset_tmo, ISCSI_PARAM_TGT_RESET_TMO, 0);\niscsi_session_attr(ifacename, ISCSI_PARAM_IFACE_NAME, 0);\niscsi_session_attr(initiatorname, ISCSI_PARAM_INITIATOR_NAME, 0);\niscsi_session_attr(targetalias, ISCSI_PARAM_TARGET_ALIAS, 0);\niscsi_session_attr(boot_root, ISCSI_PARAM_BOOT_ROOT, 0);\niscsi_session_attr(boot_nic, ISCSI_PARAM_BOOT_NIC, 0);\niscsi_session_attr(boot_target, ISCSI_PARAM_BOOT_TARGET, 0);\niscsi_session_attr(auto_snd_tgt_disable, ISCSI_PARAM_AUTO_SND_TGT_DISABLE, 0);\niscsi_session_attr(discovery_session, ISCSI_PARAM_DISCOVERY_SESS, 0);\niscsi_session_attr(portal_type, ISCSI_PARAM_PORTAL_TYPE, 0);\niscsi_session_attr(chap_auth, ISCSI_PARAM_CHAP_AUTH_EN, 0);\niscsi_session_attr(discovery_logout, ISCSI_PARAM_DISCOVERY_LOGOUT_EN, 0);\niscsi_session_attr(bidi_chap, ISCSI_PARAM_BIDI_CHAP_EN, 0);\niscsi_session_attr(discovery_auth_optional,\n\t\t   ISCSI_PARAM_DISCOVERY_AUTH_OPTIONAL, 0);\niscsi_session_attr(def_time2wait, ISCSI_PARAM_DEF_TIME2WAIT, 0);\niscsi_session_attr(def_time2retain, ISCSI_PARAM_DEF_TIME2RETAIN, 0);\niscsi_session_attr(isid, ISCSI_PARAM_ISID, 0);\niscsi_session_attr(tsid, ISCSI_PARAM_TSID, 0);\niscsi_session_attr(def_taskmgmt_tmo, ISCSI_PARAM_DEF_TASKMGMT_TMO, 0);\niscsi_session_attr(discovery_parent_idx, ISCSI_PARAM_DISCOVERY_PARENT_IDX, 0);\niscsi_session_attr(discovery_parent_type, ISCSI_PARAM_DISCOVERY_PARENT_TYPE, 0);\n\nstatic ssize_t\nshow_priv_session_target_state(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct iscsi_cls_session *session = iscsi_dev_to_session(dev->parent);\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\tiscsi_session_target_state_name[session->target_state]);\n}\n\nstatic ISCSI_CLASS_ATTR(priv_sess, target_state, S_IRUGO,\n\t\t\tshow_priv_session_target_state, NULL);\n\nstatic ssize_t\nshow_priv_session_state(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct iscsi_cls_session *session = iscsi_dev_to_session(dev->parent);\n\treturn sysfs_emit(buf, \"%s\\n\", iscsi_session_state_name(session->state));\n}\nstatic ISCSI_CLASS_ATTR(priv_sess, state, S_IRUGO, show_priv_session_state,\n\t\t\tNULL);\nstatic ssize_t\nshow_priv_session_creator(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct iscsi_cls_session *session = iscsi_dev_to_session(dev->parent);\n\treturn sysfs_emit(buf, \"%d\\n\", session->creator);\n}\nstatic ISCSI_CLASS_ATTR(priv_sess, creator, S_IRUGO, show_priv_session_creator,\n\t\t\tNULL);\nstatic ssize_t\nshow_priv_session_target_id(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct iscsi_cls_session *session = iscsi_dev_to_session(dev->parent);\n\treturn sysfs_emit(buf, \"%d\\n\", session->target_id);\n}\nstatic ISCSI_CLASS_ATTR(priv_sess, target_id, S_IRUGO,\n\t\t\tshow_priv_session_target_id, NULL);\n\n#define iscsi_priv_session_attr_show(field, format)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_priv_session_##field(struct device *dev, \t\t\t\t\\\n\t\t\t  struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct iscsi_cls_session *session = \t\t\t\t\\\n\t\t\tiscsi_dev_to_session(dev->parent);\t\t\\\n\tif (session->field == -1)\t\t\t\t\t\\\n\t\treturn sysfs_emit(buf, \"off\\n\");\t\t\t\\\n\treturn sysfs_emit(buf, format\"\\n\", session->field);\t\t\\\n}\n\n#define iscsi_priv_session_attr_store(field)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nstore_priv_session_##field(struct device *dev,\t\t\t\t\\\n\t\t\t   struct device_attribute *attr,\t\t\\\n\t\t\t   const char *buf, size_t count)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint val;\t\t\t\t\t\t\t\\\n\tchar *cp;\t\t\t\t\t\t\t\\\n\tstruct iscsi_cls_session *session =\t\t\t\t\\\n\t\tiscsi_dev_to_session(dev->parent);\t\t\t\\\n\tif ((session->state == ISCSI_SESSION_FREE) ||\t\t\t\\\n\t    (session->state == ISCSI_SESSION_FAILED))\t\t\t\\\n\t\treturn -EBUSY;\t\t\t\t\t\t\\\n\tif (strncmp(buf, \"off\", 3) == 0) {\t\t\t\t\\\n\t\tsession->field = -1;\t\t\t\t\t\\\n\t\tsession->field##_sysfs_override = true;\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tval = simple_strtoul(buf, &cp, 0);\t\t\t\\\n\t\tif (*cp != '\\0' && *cp != '\\n')\t\t\t\t\\\n\t\t\treturn -EINVAL;\t\t\t\t\t\\\n\t\tsession->field = val;\t\t\t\t\t\\\n\t\tsession->field##_sysfs_override = true;\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define iscsi_priv_session_rw_attr(field, format)\t\t\t\\\n\tiscsi_priv_session_attr_show(field, format)\t\t\t\\\n\tiscsi_priv_session_attr_store(field)\t\t\t\t\\\nstatic ISCSI_CLASS_ATTR(priv_sess, field, S_IRUGO | S_IWUSR,\t\t\\\n\t\t\tshow_priv_session_##field,\t\t\t\\\n\t\t\tstore_priv_session_##field)\n\niscsi_priv_session_rw_attr(recovery_tmo, \"%d\");\n\nstatic struct attribute *iscsi_session_attrs[] = {\n\t&dev_attr_sess_initial_r2t.attr,\n\t&dev_attr_sess_max_outstanding_r2t.attr,\n\t&dev_attr_sess_immediate_data.attr,\n\t&dev_attr_sess_first_burst_len.attr,\n\t&dev_attr_sess_max_burst_len.attr,\n\t&dev_attr_sess_data_pdu_in_order.attr,\n\t&dev_attr_sess_data_seq_in_order.attr,\n\t&dev_attr_sess_erl.attr,\n\t&dev_attr_sess_targetname.attr,\n\t&dev_attr_sess_tpgt.attr,\n\t&dev_attr_sess_password.attr,\n\t&dev_attr_sess_password_in.attr,\n\t&dev_attr_sess_username.attr,\n\t&dev_attr_sess_username_in.attr,\n\t&dev_attr_sess_fast_abort.attr,\n\t&dev_attr_sess_abort_tmo.attr,\n\t&dev_attr_sess_lu_reset_tmo.attr,\n\t&dev_attr_sess_tgt_reset_tmo.attr,\n\t&dev_attr_sess_ifacename.attr,\n\t&dev_attr_sess_initiatorname.attr,\n\t&dev_attr_sess_targetalias.attr,\n\t&dev_attr_sess_boot_root.attr,\n\t&dev_attr_sess_boot_nic.attr,\n\t&dev_attr_sess_boot_target.attr,\n\t&dev_attr_priv_sess_recovery_tmo.attr,\n\t&dev_attr_priv_sess_state.attr,\n\t&dev_attr_priv_sess_target_state.attr,\n\t&dev_attr_priv_sess_creator.attr,\n\t&dev_attr_sess_chap_out_idx.attr,\n\t&dev_attr_sess_chap_in_idx.attr,\n\t&dev_attr_priv_sess_target_id.attr,\n\t&dev_attr_sess_auto_snd_tgt_disable.attr,\n\t&dev_attr_sess_discovery_session.attr,\n\t&dev_attr_sess_portal_type.attr,\n\t&dev_attr_sess_chap_auth.attr,\n\t&dev_attr_sess_discovery_logout.attr,\n\t&dev_attr_sess_bidi_chap.attr,\n\t&dev_attr_sess_discovery_auth_optional.attr,\n\t&dev_attr_sess_def_time2wait.attr,\n\t&dev_attr_sess_def_time2retain.attr,\n\t&dev_attr_sess_isid.attr,\n\t&dev_attr_sess_tsid.attr,\n\t&dev_attr_sess_def_taskmgmt_tmo.attr,\n\t&dev_attr_sess_discovery_parent_idx.attr,\n\t&dev_attr_sess_discovery_parent_type.attr,\n\tNULL,\n};\n\nstatic umode_t iscsi_session_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t    struct attribute *attr, int i)\n{\n\tstruct device *cdev = container_of(kobj, struct device, kobj);\n\tstruct iscsi_cls_session *session = transport_class_to_session(cdev);\n\tstruct iscsi_transport *t = session->transport;\n\tint param;\n\n\tif (attr == &dev_attr_sess_initial_r2t.attr)\n\t\tparam = ISCSI_PARAM_INITIAL_R2T_EN;\n\telse if (attr == &dev_attr_sess_max_outstanding_r2t.attr)\n\t\tparam = ISCSI_PARAM_MAX_R2T;\n\telse if (attr == &dev_attr_sess_immediate_data.attr)\n\t\tparam = ISCSI_PARAM_IMM_DATA_EN;\n\telse if (attr == &dev_attr_sess_first_burst_len.attr)\n\t\tparam = ISCSI_PARAM_FIRST_BURST;\n\telse if (attr == &dev_attr_sess_max_burst_len.attr)\n\t\tparam = ISCSI_PARAM_MAX_BURST;\n\telse if (attr == &dev_attr_sess_data_pdu_in_order.attr)\n\t\tparam = ISCSI_PARAM_PDU_INORDER_EN;\n\telse if (attr == &dev_attr_sess_data_seq_in_order.attr)\n\t\tparam = ISCSI_PARAM_DATASEQ_INORDER_EN;\n\telse if (attr == &dev_attr_sess_erl.attr)\n\t\tparam = ISCSI_PARAM_ERL;\n\telse if (attr == &dev_attr_sess_targetname.attr)\n\t\tparam = ISCSI_PARAM_TARGET_NAME;\n\telse if (attr == &dev_attr_sess_tpgt.attr)\n\t\tparam = ISCSI_PARAM_TPGT;\n\telse if (attr == &dev_attr_sess_chap_in_idx.attr)\n\t\tparam = ISCSI_PARAM_CHAP_IN_IDX;\n\telse if (attr == &dev_attr_sess_chap_out_idx.attr)\n\t\tparam = ISCSI_PARAM_CHAP_OUT_IDX;\n\telse if (attr == &dev_attr_sess_password.attr)\n\t\tparam = ISCSI_PARAM_USERNAME;\n\telse if (attr == &dev_attr_sess_password_in.attr)\n\t\tparam = ISCSI_PARAM_USERNAME_IN;\n\telse if (attr == &dev_attr_sess_username.attr)\n\t\tparam = ISCSI_PARAM_PASSWORD;\n\telse if (attr == &dev_attr_sess_username_in.attr)\n\t\tparam = ISCSI_PARAM_PASSWORD_IN;\n\telse if (attr == &dev_attr_sess_fast_abort.attr)\n\t\tparam = ISCSI_PARAM_FAST_ABORT;\n\telse if (attr == &dev_attr_sess_abort_tmo.attr)\n\t\tparam = ISCSI_PARAM_ABORT_TMO;\n\telse if (attr == &dev_attr_sess_lu_reset_tmo.attr)\n\t\tparam = ISCSI_PARAM_LU_RESET_TMO;\n\telse if (attr == &dev_attr_sess_tgt_reset_tmo.attr)\n\t\tparam = ISCSI_PARAM_TGT_RESET_TMO;\n\telse if (attr == &dev_attr_sess_ifacename.attr)\n\t\tparam = ISCSI_PARAM_IFACE_NAME;\n\telse if (attr == &dev_attr_sess_initiatorname.attr)\n\t\tparam = ISCSI_PARAM_INITIATOR_NAME;\n\telse if (attr == &dev_attr_sess_targetalias.attr)\n\t\tparam = ISCSI_PARAM_TARGET_ALIAS;\n\telse if (attr == &dev_attr_sess_boot_root.attr)\n\t\tparam = ISCSI_PARAM_BOOT_ROOT;\n\telse if (attr == &dev_attr_sess_boot_nic.attr)\n\t\tparam = ISCSI_PARAM_BOOT_NIC;\n\telse if (attr == &dev_attr_sess_boot_target.attr)\n\t\tparam = ISCSI_PARAM_BOOT_TARGET;\n\telse if (attr == &dev_attr_sess_auto_snd_tgt_disable.attr)\n\t\tparam = ISCSI_PARAM_AUTO_SND_TGT_DISABLE;\n\telse if (attr == &dev_attr_sess_discovery_session.attr)\n\t\tparam = ISCSI_PARAM_DISCOVERY_SESS;\n\telse if (attr == &dev_attr_sess_portal_type.attr)\n\t\tparam = ISCSI_PARAM_PORTAL_TYPE;\n\telse if (attr == &dev_attr_sess_chap_auth.attr)\n\t\tparam = ISCSI_PARAM_CHAP_AUTH_EN;\n\telse if (attr == &dev_attr_sess_discovery_logout.attr)\n\t\tparam = ISCSI_PARAM_DISCOVERY_LOGOUT_EN;\n\telse if (attr == &dev_attr_sess_bidi_chap.attr)\n\t\tparam = ISCSI_PARAM_BIDI_CHAP_EN;\n\telse if (attr == &dev_attr_sess_discovery_auth_optional.attr)\n\t\tparam = ISCSI_PARAM_DISCOVERY_AUTH_OPTIONAL;\n\telse if (attr == &dev_attr_sess_def_time2wait.attr)\n\t\tparam = ISCSI_PARAM_DEF_TIME2WAIT;\n\telse if (attr == &dev_attr_sess_def_time2retain.attr)\n\t\tparam = ISCSI_PARAM_DEF_TIME2RETAIN;\n\telse if (attr == &dev_attr_sess_isid.attr)\n\t\tparam = ISCSI_PARAM_ISID;\n\telse if (attr == &dev_attr_sess_tsid.attr)\n\t\tparam = ISCSI_PARAM_TSID;\n\telse if (attr == &dev_attr_sess_def_taskmgmt_tmo.attr)\n\t\tparam = ISCSI_PARAM_DEF_TASKMGMT_TMO;\n\telse if (attr == &dev_attr_sess_discovery_parent_idx.attr)\n\t\tparam = ISCSI_PARAM_DISCOVERY_PARENT_IDX;\n\telse if (attr == &dev_attr_sess_discovery_parent_type.attr)\n\t\tparam = ISCSI_PARAM_DISCOVERY_PARENT_TYPE;\n\telse if (attr == &dev_attr_priv_sess_recovery_tmo.attr)\n\t\treturn S_IRUGO | S_IWUSR;\n\telse if (attr == &dev_attr_priv_sess_state.attr)\n\t\treturn S_IRUGO;\n\telse if (attr == &dev_attr_priv_sess_target_state.attr)\n\t\treturn S_IRUGO;\n\telse if (attr == &dev_attr_priv_sess_creator.attr)\n\t\treturn S_IRUGO;\n\telse if (attr == &dev_attr_priv_sess_target_id.attr)\n\t\treturn S_IRUGO;\n\telse {\n\t\tWARN_ONCE(1, \"Invalid session attr\");\n\t\treturn 0;\n\t}\n\n\treturn t->attr_is_visible(ISCSI_PARAM, param);\n}\n\nstatic struct attribute_group iscsi_session_group = {\n\t.attrs = iscsi_session_attrs,\n\t.is_visible = iscsi_session_attr_is_visible,\n};\n\n \n#define iscsi_host_attr_show(param)\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_host_param_##param(struct device *dev, \t\t\t\t\\\n\t\t\tstruct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct Scsi_Host *shost = transport_class_to_shost(dev);\t\\\n\tstruct iscsi_internal *priv = to_iscsi_internal(shost->transportt); \\\n\treturn priv->iscsi_transport->get_host_param(shost, param, buf); \\\n}\n\n#define iscsi_host_attr(field, param)\t\t\t\t\t\\\n\tiscsi_host_attr_show(param)\t\t\t\t\t\\\nstatic ISCSI_CLASS_ATTR(host, field, S_IRUGO, show_host_param_##param,\t\\\n\t\t\tNULL);\n\niscsi_host_attr(netdev, ISCSI_HOST_PARAM_NETDEV_NAME);\niscsi_host_attr(hwaddress, ISCSI_HOST_PARAM_HWADDRESS);\niscsi_host_attr(ipaddress, ISCSI_HOST_PARAM_IPADDRESS);\niscsi_host_attr(initiatorname, ISCSI_HOST_PARAM_INITIATOR_NAME);\niscsi_host_attr(port_state, ISCSI_HOST_PARAM_PORT_STATE);\niscsi_host_attr(port_speed, ISCSI_HOST_PARAM_PORT_SPEED);\n\nstatic struct attribute *iscsi_host_attrs[] = {\n\t&dev_attr_host_netdev.attr,\n\t&dev_attr_host_hwaddress.attr,\n\t&dev_attr_host_ipaddress.attr,\n\t&dev_attr_host_initiatorname.attr,\n\t&dev_attr_host_port_state.attr,\n\t&dev_attr_host_port_speed.attr,\n\tNULL,\n};\n\nstatic umode_t iscsi_host_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t struct attribute *attr, int i)\n{\n\tstruct device *cdev = container_of(kobj, struct device, kobj);\n\tstruct Scsi_Host *shost = transport_class_to_shost(cdev);\n\tstruct iscsi_internal *priv = to_iscsi_internal(shost->transportt);\n\tint param;\n\n\tif (attr == &dev_attr_host_netdev.attr)\n\t\tparam = ISCSI_HOST_PARAM_NETDEV_NAME;\n\telse if (attr == &dev_attr_host_hwaddress.attr)\n\t\tparam = ISCSI_HOST_PARAM_HWADDRESS;\n\telse if (attr == &dev_attr_host_ipaddress.attr)\n\t\tparam = ISCSI_HOST_PARAM_IPADDRESS;\n\telse if (attr == &dev_attr_host_initiatorname.attr)\n\t\tparam = ISCSI_HOST_PARAM_INITIATOR_NAME;\n\telse if (attr == &dev_attr_host_port_state.attr)\n\t\tparam = ISCSI_HOST_PARAM_PORT_STATE;\n\telse if (attr == &dev_attr_host_port_speed.attr)\n\t\tparam = ISCSI_HOST_PARAM_PORT_SPEED;\n\telse {\n\t\tWARN_ONCE(1, \"Invalid host attr\");\n\t\treturn 0;\n\t}\n\n\treturn priv->iscsi_transport->attr_is_visible(ISCSI_HOST_PARAM, param);\n}\n\nstatic struct attribute_group iscsi_host_group = {\n\t.attrs = iscsi_host_attrs,\n\t.is_visible = iscsi_host_attr_is_visible,\n};\n\n \nstatic const struct {\n\tenum iscsi_port_speed\tvalue;\n\tchar\t\t\t*name;\n} iscsi_port_speed_names[] = {\n\t{ISCSI_PORT_SPEED_UNKNOWN,\t\"Unknown\" },\n\t{ISCSI_PORT_SPEED_10MBPS,\t\"10 Mbps\" },\n\t{ISCSI_PORT_SPEED_100MBPS,\t\"100 Mbps\" },\n\t{ISCSI_PORT_SPEED_1GBPS,\t\"1 Gbps\" },\n\t{ISCSI_PORT_SPEED_10GBPS,\t\"10 Gbps\" },\n\t{ISCSI_PORT_SPEED_25GBPS,       \"25 Gbps\" },\n\t{ISCSI_PORT_SPEED_40GBPS,       \"40 Gbps\" },\n};\n\nchar *iscsi_get_port_speed_name(struct Scsi_Host *shost)\n{\n\tint i;\n\tchar *speed = \"Unknown!\";\n\tstruct iscsi_cls_host *ihost = shost->shost_data;\n\tuint32_t port_speed = ihost->port_speed;\n\n\tfor (i = 0; i < ARRAY_SIZE(iscsi_port_speed_names); i++) {\n\t\tif (iscsi_port_speed_names[i].value & port_speed) {\n\t\t\tspeed = iscsi_port_speed_names[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn speed;\n}\nEXPORT_SYMBOL_GPL(iscsi_get_port_speed_name);\n\n \nstatic const struct {\n\tenum iscsi_port_state\tvalue;\n\tchar\t\t\t*name;\n} iscsi_port_state_names[] = {\n\t{ISCSI_PORT_STATE_DOWN,\t\t\"LINK DOWN\" },\n\t{ISCSI_PORT_STATE_UP,\t\t\"LINK UP\" },\n};\n\nchar *iscsi_get_port_state_name(struct Scsi_Host *shost)\n{\n\tint i;\n\tchar *state = \"Unknown!\";\n\tstruct iscsi_cls_host *ihost = shost->shost_data;\n\tuint32_t port_state = ihost->port_state;\n\n\tfor (i = 0; i < ARRAY_SIZE(iscsi_port_state_names); i++) {\n\t\tif (iscsi_port_state_names[i].value & port_state) {\n\t\t\tstate = iscsi_port_state_names[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn state;\n}\nEXPORT_SYMBOL_GPL(iscsi_get_port_state_name);\n\nstatic int iscsi_session_match(struct attribute_container *cont,\n\t\t\t   struct device *dev)\n{\n\tstruct iscsi_cls_session *session;\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_internal *priv;\n\n\tif (!iscsi_is_session_dev(dev))\n\t\treturn 0;\n\n\tsession = iscsi_dev_to_session(dev);\n\tshost = iscsi_session_to_shost(session);\n\tif (!shost->transportt)\n\t\treturn 0;\n\n\tpriv = to_iscsi_internal(shost->transportt);\n\tif (priv->session_cont.ac.class != &iscsi_session_class.class)\n\t\treturn 0;\n\n\treturn &priv->session_cont.ac == cont;\n}\n\nstatic int iscsi_conn_match(struct attribute_container *cont,\n\t\t\t   struct device *dev)\n{\n\tstruct iscsi_cls_session *session;\n\tstruct iscsi_cls_conn *conn;\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_internal *priv;\n\n\tif (!iscsi_is_conn_dev(dev))\n\t\treturn 0;\n\n\tconn = iscsi_dev_to_conn(dev);\n\tsession = iscsi_dev_to_session(conn->dev.parent);\n\tshost = iscsi_session_to_shost(session);\n\n\tif (!shost->transportt)\n\t\treturn 0;\n\n\tpriv = to_iscsi_internal(shost->transportt);\n\tif (priv->conn_cont.ac.class != &iscsi_connection_class.class)\n\t\treturn 0;\n\n\treturn &priv->conn_cont.ac == cont;\n}\n\nstatic int iscsi_host_match(struct attribute_container *cont,\n\t\t\t    struct device *dev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_internal *priv;\n\n\tif (!scsi_is_host_device(dev))\n\t\treturn 0;\n\n\tshost = dev_to_shost(dev);\n\tif (!shost->transportt  ||\n\t    shost->transportt->host_attrs.ac.class != &iscsi_host_class.class)\n\t\treturn 0;\n\n        priv = to_iscsi_internal(shost->transportt);\n        return &priv->t.host_attrs.ac == cont;\n}\n\nstruct scsi_transport_template *\niscsi_register_transport(struct iscsi_transport *tt)\n{\n\tstruct iscsi_internal *priv;\n\tunsigned long flags;\n\tint err;\n\n\tBUG_ON(!tt);\n\tWARN_ON(tt->ep_disconnect && !tt->unbind_conn);\n\n\tpriv = iscsi_if_transport_lookup(tt);\n\tif (priv)\n\t\treturn NULL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&priv->list);\n\tpriv->iscsi_transport = tt;\n\tpriv->t.user_scan = iscsi_user_scan;\n\n\tpriv->dev.class = &iscsi_transport_class;\n\tdev_set_name(&priv->dev, \"%s\", tt->name);\n\terr = device_register(&priv->dev);\n\tif (err)\n\t\tgoto put_dev;\n\n\terr = sysfs_create_group(&priv->dev.kobj, &iscsi_transport_group);\n\tif (err)\n\t\tgoto unregister_dev;\n\n\t \n\tpriv->t.host_attrs.ac.class = &iscsi_host_class.class;\n\tpriv->t.host_attrs.ac.match = iscsi_host_match;\n\tpriv->t.host_attrs.ac.grp = &iscsi_host_group;\n\tpriv->t.host_size = sizeof(struct iscsi_cls_host);\n\ttransport_container_register(&priv->t.host_attrs);\n\n\t \n\tpriv->conn_cont.ac.class = &iscsi_connection_class.class;\n\tpriv->conn_cont.ac.match = iscsi_conn_match;\n\tpriv->conn_cont.ac.grp = &iscsi_conn_group;\n\ttransport_container_register(&priv->conn_cont);\n\n\t \n\tpriv->session_cont.ac.class = &iscsi_session_class.class;\n\tpriv->session_cont.ac.match = iscsi_session_match;\n\tpriv->session_cont.ac.grp = &iscsi_session_group;\n\ttransport_container_register(&priv->session_cont);\n\n\tspin_lock_irqsave(&iscsi_transport_lock, flags);\n\tlist_add(&priv->list, &iscsi_transports);\n\tspin_unlock_irqrestore(&iscsi_transport_lock, flags);\n\n\tprintk(KERN_NOTICE \"iscsi: registered transport (%s)\\n\", tt->name);\n\treturn &priv->t;\n\nunregister_dev:\n\tdevice_unregister(&priv->dev);\n\treturn NULL;\nput_dev:\n\tput_device(&priv->dev);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(iscsi_register_transport);\n\nvoid iscsi_unregister_transport(struct iscsi_transport *tt)\n{\n\tstruct iscsi_internal *priv;\n\tunsigned long flags;\n\n\tBUG_ON(!tt);\n\n\tmutex_lock(&rx_queue_mutex);\n\n\tpriv = iscsi_if_transport_lookup(tt);\n\tBUG_ON (!priv);\n\n\tspin_lock_irqsave(&iscsi_transport_lock, flags);\n\tlist_del(&priv->list);\n\tspin_unlock_irqrestore(&iscsi_transport_lock, flags);\n\n\ttransport_container_unregister(&priv->conn_cont);\n\ttransport_container_unregister(&priv->session_cont);\n\ttransport_container_unregister(&priv->t.host_attrs);\n\n\tsysfs_remove_group(&priv->dev.kobj, &iscsi_transport_group);\n\tdevice_unregister(&priv->dev);\n\tmutex_unlock(&rx_queue_mutex);\n}\nEXPORT_SYMBOL_GPL(iscsi_unregister_transport);\n\nvoid iscsi_dbg_trace(void (*trace)(struct device *dev, struct va_format *),\n\t\t     struct device *dev, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\ttrace(dev, &vaf);\n\tva_end(args);\n}\nEXPORT_SYMBOL_GPL(iscsi_dbg_trace);\n\nstatic __init int iscsi_transport_init(void)\n{\n\tint err;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t= 1,\n\t\t.input\t= iscsi_if_rx,\n\t};\n\tprintk(KERN_INFO \"Loading iSCSI transport class v%s.\\n\",\n\t\tISCSI_TRANSPORT_VERSION);\n\n\tatomic_set(&iscsi_session_nr, 0);\n\n\terr = class_register(&iscsi_transport_class);\n\tif (err)\n\t\treturn err;\n\n\terr = class_register(&iscsi_endpoint_class);\n\tif (err)\n\t\tgoto unregister_transport_class;\n\n\terr = class_register(&iscsi_iface_class);\n\tif (err)\n\t\tgoto unregister_endpoint_class;\n\n\terr = transport_class_register(&iscsi_host_class);\n\tif (err)\n\t\tgoto unregister_iface_class;\n\n\terr = transport_class_register(&iscsi_connection_class);\n\tif (err)\n\t\tgoto unregister_host_class;\n\n\terr = transport_class_register(&iscsi_session_class);\n\tif (err)\n\t\tgoto unregister_conn_class;\n\n\terr = bus_register(&iscsi_flashnode_bus);\n\tif (err)\n\t\tgoto unregister_session_class;\n\n\tnls = netlink_kernel_create(&init_net, NETLINK_ISCSI, &cfg);\n\tif (!nls) {\n\t\terr = -ENOBUFS;\n\t\tgoto unregister_flashnode_bus;\n\t}\n\n\tiscsi_conn_cleanup_workq = alloc_workqueue(\"%s\",\n\t\t\tWQ_SYSFS | WQ_MEM_RECLAIM | WQ_UNBOUND, 0,\n\t\t\t\"iscsi_conn_cleanup\");\n\tif (!iscsi_conn_cleanup_workq) {\n\t\terr = -ENOMEM;\n\t\tgoto release_nls;\n\t}\n\n\treturn 0;\n\nrelease_nls:\n\tnetlink_kernel_release(nls);\nunregister_flashnode_bus:\n\tbus_unregister(&iscsi_flashnode_bus);\nunregister_session_class:\n\ttransport_class_unregister(&iscsi_session_class);\nunregister_conn_class:\n\ttransport_class_unregister(&iscsi_connection_class);\nunregister_host_class:\n\ttransport_class_unregister(&iscsi_host_class);\nunregister_iface_class:\n\tclass_unregister(&iscsi_iface_class);\nunregister_endpoint_class:\n\tclass_unregister(&iscsi_endpoint_class);\nunregister_transport_class:\n\tclass_unregister(&iscsi_transport_class);\n\treturn err;\n}\n\nstatic void __exit iscsi_transport_exit(void)\n{\n\tdestroy_workqueue(iscsi_conn_cleanup_workq);\n\tnetlink_kernel_release(nls);\n\tbus_unregister(&iscsi_flashnode_bus);\n\ttransport_class_unregister(&iscsi_connection_class);\n\ttransport_class_unregister(&iscsi_session_class);\n\ttransport_class_unregister(&iscsi_host_class);\n\tclass_unregister(&iscsi_endpoint_class);\n\tclass_unregister(&iscsi_iface_class);\n\tclass_unregister(&iscsi_transport_class);\n}\n\nmodule_init(iscsi_transport_init);\nmodule_exit(iscsi_transport_exit);\n\nMODULE_AUTHOR(\"Mike Christie <michaelc@cs.wisc.edu>, \"\n\t      \"Dmitry Yusupov <dmitry_yus@yahoo.com>, \"\n\t      \"Alex Aizman <itn780@yahoo.com>\");\nMODULE_DESCRIPTION(\"iSCSI Transport Interface\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(ISCSI_TRANSPORT_VERSION);\nMODULE_ALIAS_NET_PF_PROTO(PF_NETLINK, NETLINK_ISCSI);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}