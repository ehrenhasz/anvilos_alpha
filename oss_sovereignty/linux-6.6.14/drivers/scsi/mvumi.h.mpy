{
  "module_name": "mvumi.h",
  "hash_id": "3a53fc0f08167c263464fabc9d36eb6ed8ee4ae2f0b7ea2f971ff299d6ac3dac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mvumi.h",
  "human_readable_source": " \n \n\n#ifndef MVUMI_H\n#define MVUMI_H\n\n#define MAX_BASE_ADDRESS\t6\n\n#define VER_MAJOR\t\t1\n#define VER_MINOR\t\t1\n#define VER_OEM\t\t\t0\n#define VER_BUILD\t\t1500\n\n#define MV_DRIVER_NAME\t\t\t\"mvumi\"\n#define PCI_DEVICE_ID_MARVELL_MV9143\t0x9143\n#define PCI_DEVICE_ID_MARVELL_MV9580\t0x9580\n\n#define MVUMI_INTERNAL_CMD_WAIT_TIME\t45\n#define MVUMI_INQUIRY_LENGTH\t\t44\n#define MVUMI_INQUIRY_UUID_OFF\t\t36\n#define MVUMI_INQUIRY_UUID_LEN\t\t8\n\n#define IS_DMA64\t\t\t(sizeof(dma_addr_t) == 8)\n\nenum mvumi_qc_result {\n\tMV_QUEUE_COMMAND_RESULT_SENT = 0,\n\tMV_QUEUE_COMMAND_RESULT_NO_RESOURCE,\n};\n\nstruct mvumi_hw_regs {\n\t \n\tvoid *main_int_cause_reg;\n\tvoid *enpointa_mask_reg;\n\tvoid *enpointb_mask_reg;\n\tvoid *rstoutn_en_reg;\n\tvoid *ctrl_sts_reg;\n\tvoid *rstoutn_mask_reg;\n\tvoid *sys_soft_rst_reg;\n\n\t \n\tvoid *pciea_to_arm_drbl_reg;\n\tvoid *arm_to_pciea_drbl_reg;\n\tvoid *arm_to_pciea_mask_reg;\n\tvoid *pciea_to_arm_msg0;\n\tvoid *pciea_to_arm_msg1;\n\tvoid *arm_to_pciea_msg0;\n\tvoid *arm_to_pciea_msg1;\n\n\t \n\tvoid *reset_request;\n\tvoid *reset_enable;\n\n\t \n\tvoid *inb_list_basel;\n\tvoid *inb_list_baseh;\n\tvoid *inb_aval_count_basel;\n\tvoid *inb_aval_count_baseh;\n\tvoid *inb_write_pointer;\n\tvoid *inb_read_pointer;\n\tvoid *outb_list_basel;\n\tvoid *outb_list_baseh;\n\tvoid *outb_copy_basel;\n\tvoid *outb_copy_baseh;\n\tvoid *outb_copy_pointer;\n\tvoid *outb_read_pointer;\n\tvoid *inb_isr_cause;\n\tvoid *outb_isr_cause;\n\tvoid *outb_coal_cfg;\n\tvoid *outb_coal_timeout;\n\n\t \n\tu32 int_comaout;\n\tu32 int_comaerr;\n\tu32 int_dl_cpu2pciea;\n\tu32 int_mu;\n\tu32 int_drbl_int_mask;\n\tu32 int_main_int_mask;\n\tu32 cl_pointer_toggle;\n\tu32 cl_slot_num_mask;\n\tu32 clic_irq;\n\tu32 clic_in_err;\n\tu32 clic_out_err;\n};\n\nstruct mvumi_dyn_list_entry {\n\tu32 src_low_addr;\n\tu32 src_high_addr;\n\tu32 if_length;\n\tu32 reserve;\n};\n\n#define SCSI_CMD_MARVELL_SPECIFIC\t0xE1\n#define CDB_CORE_MODULE\t\t\t0x1\n#define CDB_CORE_SHUTDOWN\t\t0xB\n\nenum {\n\tDRBL_HANDSHAKE\t\t\t= 1 << 0,\n\tDRBL_SOFT_RESET\t\t\t= 1 << 1,\n\tDRBL_BUS_CHANGE\t\t\t= 1 << 2,\n\tDRBL_EVENT_NOTIFY\t\t= 1 << 3,\n\tDRBL_MU_RESET\t\t\t= 1 << 4,\n\tDRBL_HANDSHAKE_ISR\t\t= DRBL_HANDSHAKE,\n\n\t \n\t \n\tCMD_FLAG_NON_DATA\t\t= 1 << 0,\n\tCMD_FLAG_DMA\t\t\t= 1 << 1,\n\tCMD_FLAG_PIO\t\t\t= 1 << 2,\n\t \n\tCMD_FLAG_DATA_IN\t\t= 1 << 3,\n\t \n\tCMD_FLAG_DATA_OUT\t\t= 1 << 4,\n\tCMD_FLAG_PRDT_IN_HOST\t\t= 1 << 5,\n};\n\n#define APICDB0_EVENT\t\t\t0xF4\n#define APICDB1_EVENT_GETEVENT\t\t0\n#define APICDB1_HOST_GETEVENT\t\t1\n#define MAX_EVENTS_RETURNED\t\t6\n\n#define DEVICE_OFFLINE\t0\n#define DEVICE_ONLINE\t1\n\nstruct mvumi_hotplug_event {\n\tu16 size;\n\tu8 dummy[2];\n\tu8 bitmap[];\n};\n\nstruct mvumi_driver_event {\n\tu32\ttime_stamp;\n\tu32\tsequence_no;\n\tu32\tevent_id;\n\tu8\tseverity;\n\tu8\tparam_count;\n\tu16\tdevice_id;\n\tu32\tparams[4];\n\tu8\tsense_data_length;\n\tu8\tReserved1;\n\tu8\tsense_data[30];\n};\n\nstruct mvumi_event_req {\n\tunsigned char\tcount;\n\tunsigned char\treserved[3];\n\tstruct mvumi_driver_event  events[MAX_EVENTS_RETURNED];\n};\n\nstruct mvumi_events_wq {\n\tstruct work_struct work_q;\n\tstruct mvumi_hba *mhba;\n\tunsigned int event;\n\tvoid *param;\n};\n\n#define HS_CAPABILITY_SUPPORT_COMPACT_SG\t(1U << 4)\n#define HS_CAPABILITY_SUPPORT_PRD_HOST\t\t(1U << 5)\n#define HS_CAPABILITY_SUPPORT_DYN_SRC\t\t(1U << 6)\n#define HS_CAPABILITY_NEW_PAGE_IO_DEPTH_DEF\t(1U << 14)\n\n#define MVUMI_MAX_SG_ENTRY\t32\n#define SGD_EOT\t\t\t(1L << 27)\n#define SGD_EOT_CP\t\t(1L << 22)\n\nstruct mvumi_sgl {\n\tu32\tbaseaddr_l;\n\tu32\tbaseaddr_h;\n\tu32\tflags;\n\tu32\tsize;\n};\nstruct mvumi_compact_sgl {\n\tu32\tbaseaddr_l;\n\tu32\tbaseaddr_h;\n\tu32\tflags;\n};\n\n#define GET_COMPACT_SGD_SIZE(sgd)\t\\\n\t((((struct mvumi_compact_sgl *)(sgd))->flags) & 0x3FFFFFL)\n\n#define SET_COMPACT_SGD_SIZE(sgd, sz) do {\t\t\t\\\n\t(((struct mvumi_compact_sgl *)(sgd))->flags) &= ~0x3FFFFFL;\t\\\n\t(((struct mvumi_compact_sgl *)(sgd))->flags) |= (sz);\t\t\\\n} while (0)\n#define sgd_getsz(_mhba, sgd, sz) do {\t\t\t\t\\\n\tif (_mhba->hba_capability & HS_CAPABILITY_SUPPORT_COMPACT_SG)\t\\\n\t\t(sz) = GET_COMPACT_SGD_SIZE(sgd);\t\\\n\telse \\\n\t\t(sz) = (sgd)->size;\t\t\t\\\n} while (0)\n\n#define sgd_setsz(_mhba, sgd, sz) do {\t\t\t\t\\\n\tif (_mhba->hba_capability & HS_CAPABILITY_SUPPORT_COMPACT_SG)\t\\\n\t\tSET_COMPACT_SGD_SIZE(sgd, sz);\t\t\\\n\telse \\\n\t\t(sgd)->size = (sz);\t\t\t\\\n} while (0)\n\n#define sgd_inc(_mhba, sgd) do {\t\\\n\tif (_mhba->hba_capability & HS_CAPABILITY_SUPPORT_COMPACT_SG)\t\\\n\t\tsgd = (struct mvumi_sgl *)(((unsigned char *) (sgd)) + 12); \\\n\telse \\\n\t\tsgd = (struct mvumi_sgl *)(((unsigned char *) (sgd)) + 16); \\\n} while (0)\n\nstruct mvumi_res {\n\tstruct list_head entry;\n\tdma_addr_t bus_addr;\n\tvoid *virt_addr;\n\tunsigned int size;\n\tunsigned short type;\t \n};\n\n \nenum resource_type {\n\tRESOURCE_CACHED_MEMORY = 0,\n\tRESOURCE_UNCACHED_MEMORY\n};\n\nstruct mvumi_sense_data {\n\tu8 error_code:7;\n\tu8 valid:1;\n\tu8 segment_number;\n\tu8 sense_key:4;\n\tu8 reserved:1;\n\tu8 incorrect_length:1;\n\tu8 end_of_media:1;\n\tu8 file_mark:1;\n\tu8 information[4];\n\tu8 additional_sense_length;\n\tu8 command_specific_information[4];\n\tu8 additional_sense_code;\n\tu8 additional_sense_code_qualifier;\n\tu8 field_replaceable_unit_code;\n\tu8 sense_key_specific[3];\n};\n\n \n#define REQ_STATUS_PENDING\t\t0x80\n\nstruct mvumi_cmd {\n\tstruct list_head queue_pointer;\n\tstruct mvumi_msg_frame *frame;\n\tdma_addr_t frame_phys;\n\tstruct scsi_cmnd *scmd;\n\tatomic_t sync_cmd;\n\tvoid *data_buf;\n\tunsigned short request_id;\n\tunsigned char cmd_status;\n};\n\nstruct mvumi_cmd_priv {\n\tstruct mvumi_cmd *cmd_priv;\n};\n\nstatic inline struct mvumi_cmd_priv *mvumi_priv(struct scsi_cmnd *cmd)\n{\n\treturn scsi_cmd_priv(cmd);\n}\n\n \n#define CL_FUN_SCSI_CMD\t\t\t0x1\n\nstruct mvumi_msg_frame {\n\tu16 device_id;\n\tu16 tag;\n\tu8 cmd_flag;\n\tu8 req_function;\n\tu8 cdb_length;\n\tu8 sg_counts;\n\tu32 data_transfer_length;\n\tu16 request_id;\n\tu16 reserved1;\n\tu8 cdb[MAX_COMMAND_SIZE];\n\tu32 payload[];\n};\n\n \n#define CL_RSP_FLAG_NODATA\t\t0x0\n#define CL_RSP_FLAG_SENSEDATA\t\t0x1\n\nstruct mvumi_rsp_frame {\n\tu16 device_id;\n\tu16 tag;\n\tu8 req_status;\n\tu8 rsp_flag;\t \n\tu16 request_id;\n\tu32 payload[];\n};\n\nstruct mvumi_ob_data {\n\tstruct list_head list;\n\tunsigned char data[];\n};\n\nstruct version_info {\n\tu32 ver_major;\n\tu32 ver_minor;\n\tu32 ver_oem;\n\tu32 ver_build;\n};\n\n#define FW_MAX_DELAY\t\t\t30\n#define MVUMI_FW_BUSY\t\t\t(1U << 0)\n#define MVUMI_FW_ATTACH\t\t\t(1U << 1)\n#define MVUMI_FW_ALLOC\t\t\t(1U << 2)\n\n \n#define FW_STATE_IDLE\t\t\t0\n#define FW_STATE_STARTING\t\t1\n#define FW_STATE_HANDSHAKING\t\t2\n#define FW_STATE_STARTED\t\t3\n#define FW_STATE_ABORT\t\t\t4\n\n#define HANDSHAKE_SIGNATURE\t\t0x5A5A5A5AL\n#define HANDSHAKE_READYSTATE\t\t0x55AA5AA5L\n#define HANDSHAKE_DONESTATE\t\t0x55AAA55AL\n\n \n#define HS_STATUS_OK\t\t\t1\n#define HS_STATUS_ERR\t\t\t2\n#define HS_STATUS_INVALID\t\t3\n\n \n#define HS_S_START\t\t\t1\n#define HS_S_RESET\t\t\t2\n#define HS_S_PAGE_ADDR\t\t\t3\n#define HS_S_QUERY_PAGE\t\t\t4\n#define HS_S_SEND_PAGE\t\t\t5\n#define HS_S_END\t\t\t6\n#define HS_S_ABORT\t\t\t7\n#define HS_PAGE_VERIFY_SIZE\t\t128\n\n#define HS_GET_STATE(a)\t\t\t(a & 0xFFFF)\n#define HS_GET_STATUS(a)\t\t((a & 0xFFFF0000) >> 16)\n#define HS_SET_STATE(a, b)\t\t(a |= (b & 0xFFFF))\n#define HS_SET_STATUS(a, b)\t\t(a |= ((b & 0xFFFF) << 16))\n\n \nstruct mvumi_hs_frame {\n\tu16 size;\n\t \n\tu8 host_type;\n\tu8 reserved_1[1];\n\tstruct version_info host_ver;  \n\n\t \n\tu32 system_io_bus;\n\tu32 slot_number;\n\tu32 intr_level;\n\tu32 intr_vector;\n\n\t \n\tu32 ib_baseaddr_l;\n\tu32 ib_baseaddr_h;\n\tu32 ob_baseaddr_l;\n\tu32 ob_baseaddr_h;\n\n\tu8 ib_entry_size;\n\tu8 ob_entry_size;\n\tu8 ob_depth;\n\tu8 ib_depth;\n\n\t \n\tu64 seconds_since1970;\n};\n\nstruct mvumi_hs_header {\n\tu8\tpage_code;\n\tu8\tchecksum;\n\tu16\tframe_length;\n\tu32\tframe_content[];\n};\n\n \n#define HS_PAGE_FIRM_CAP\t0x1\n#define HS_PAGE_HOST_INFO\t0x2\n#define HS_PAGE_FIRM_CTL\t0x3\n#define HS_PAGE_CL_INFO\t\t0x4\n#define HS_PAGE_TOTAL\t\t0x5\n\n#define HSP_SIZE(i)\tsizeof(struct mvumi_hs_page##i)\n\n#define HSP_MAX_SIZE ({\t\t\t\t\t\\\n\tint size, m1, m2;\t\t\t\t\\\n\tm1 = max(HSP_SIZE(1), HSP_SIZE(3));\t\t\\\n\tm2 = max(HSP_SIZE(2), HSP_SIZE(4));\t\t\\\n\tsize = max(m1, m2);\t\t\t\t\\\n\tsize;\t\t\t\t\t\t\\\n})\n\n \nstruct mvumi_hs_page1 {\n\tu8 pagecode;\n\tu8 checksum;\n\tu16 frame_length;\n\n\tu16 number_of_ports;\n\tu16 max_devices_support;\n\tu16 max_io_support;\n\tu16 umi_ver;\n\tu32 max_transfer_size;\n\tstruct version_info fw_ver;\n\tu8 cl_in_max_entry_size;\n\tu8 cl_out_max_entry_size;\n\tu8 cl_inout_list_depth;\n\tu8 total_pages;\n\tu16 capability;\n\tu16 reserved1;\n};\n\n \nstruct mvumi_hs_page2 {\n\tu8 pagecode;\n\tu8 checksum;\n\tu16 frame_length;\n\n\tu8 host_type;\n\tu8 host_cap;\n\tu8 reserved[2];\n\tstruct version_info host_ver;\n\tu32 system_io_bus;\n\tu32 slot_number;\n\tu32 intr_level;\n\tu32 intr_vector;\n\tu64 seconds_since1970;\n};\n\n \nstruct mvumi_hs_page3 {\n\tu8\tpagecode;\n\tu8\tchecksum;\n\tu16\tframe_length;\n\tu16\tcontrol;\n\tu8\treserved[2];\n\tu32\thost_bufferaddr_l;\n\tu32\thost_bufferaddr_h;\n\tu32\thost_eventaddr_l;\n\tu32\thost_eventaddr_h;\n};\n\nstruct mvumi_hs_page4 {\n\tu8\tpagecode;\n\tu8\tchecksum;\n\tu16\tframe_length;\n\tu32\tib_baseaddr_l;\n\tu32\tib_baseaddr_h;\n\tu32\tob_baseaddr_l;\n\tu32\tob_baseaddr_h;\n\tu8\tib_entry_size;\n\tu8\tob_entry_size;\n\tu8\tob_depth;\n\tu8\tib_depth;\n};\n\nstruct mvumi_tag {\n\tunsigned short *stack;\n\tunsigned short top;\n\tunsigned short size;\n};\n\nstruct mvumi_device {\n\tstruct list_head list;\n\tstruct scsi_device *sdev;\n\tu64\twwid;\n\tu8\tdev_type;\n\tint\tid;\n};\n\nstruct mvumi_hba {\n\tvoid *base_addr[MAX_BASE_ADDRESS];\n\tu32 pci_base[MAX_BASE_ADDRESS];\n\tvoid *mmio;\n\tstruct list_head cmd_pool;\n\tstruct Scsi_Host *shost;\n\twait_queue_head_t int_cmd_wait_q;\n\tstruct pci_dev *pdev;\n\tunsigned int unique_id;\n\tatomic_t fw_outstanding;\n\tstruct mvumi_instance_template *instancet;\n\n\tvoid *ib_list;\n\tdma_addr_t ib_list_phys;\n\n\tvoid *ib_frame;\n\tdma_addr_t ib_frame_phys;\n\n\tvoid *ob_list;\n\tdma_addr_t ob_list_phys;\n\n\tvoid *ib_shadow;\n\tdma_addr_t ib_shadow_phys;\n\n\tvoid *ob_shadow;\n\tdma_addr_t ob_shadow_phys;\n\n\tvoid *handshake_page;\n\tdma_addr_t handshake_page_phys;\n\n\tunsigned int global_isr;\n\tunsigned int isr_status;\n\n\tunsigned short max_sge;\n\tunsigned short max_target_id;\n\tunsigned char *target_map;\n\tunsigned int max_io;\n\tunsigned int list_num_io;\n\tunsigned int ib_max_size;\n\tunsigned int ob_max_size;\n\tunsigned int ib_max_size_setting;\n\tunsigned int ob_max_size_setting;\n\tunsigned int max_transfer_size;\n\tunsigned char hba_total_pages;\n\tunsigned char fw_flag;\n\tunsigned char request_id_enabled;\n\tunsigned char eot_flag;\n\tunsigned short hba_capability;\n\tunsigned short io_seq;\n\n\tunsigned int ib_cur_slot;\n\tunsigned int ob_cur_slot;\n\tunsigned int fw_state;\n\tstruct mutex sas_discovery_mutex;\n\n\tstruct list_head ob_data_list;\n\tstruct list_head free_ob_list;\n\tstruct list_head res_list;\n\tstruct list_head waiting_req_list;\n\n\tstruct mvumi_tag tag_pool;\n\tstruct mvumi_cmd **tag_cmd;\n\tstruct mvumi_hw_regs *regs;\n\tstruct mutex device_lock;\n\tstruct list_head mhba_dev_list;\n\tstruct list_head shost_dev_list;\n\tstruct task_struct *dm_thread;\n\tatomic_t pnp_count;\n};\n\nstruct mvumi_instance_template {\n\tvoid (*fire_cmd) (struct mvumi_hba *, struct mvumi_cmd *);\n\tvoid (*enable_intr) (struct mvumi_hba *);\n\tvoid (*disable_intr) (struct mvumi_hba *);\n\tint (*clear_intr) (void *);\n\tunsigned int (*read_fw_status_reg) (struct mvumi_hba *);\n\tunsigned int (*check_ib_list) (struct mvumi_hba *);\n\tint (*check_ob_list) (struct mvumi_hba *, unsigned int *,\n\t\t\t      unsigned int *);\n\tint (*reset_host) (struct mvumi_hba *);\n};\n\nextern struct timezone sys_tz;\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}