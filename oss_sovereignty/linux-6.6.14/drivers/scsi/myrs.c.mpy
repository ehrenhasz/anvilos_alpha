{
  "module_name": "myrs.c",
  "hash_id": "84ec70d6c7b50f9887c278bfd22dc18271bfc45831e9b59ea579324408eecc7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/myrs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/raid_class.h>\n#include <asm/unaligned.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_tcq.h>\n#include \"myrs.h\"\n\nstatic struct raid_template *myrs_raid_template;\n\nstatic struct myrs_devstate_name_entry {\n\tenum myrs_devstate state;\n\tchar *name;\n} myrs_devstate_name_list[] = {\n\t{ MYRS_DEVICE_UNCONFIGURED, \"Unconfigured\" },\n\t{ MYRS_DEVICE_ONLINE, \"Online\" },\n\t{ MYRS_DEVICE_REBUILD, \"Rebuild\" },\n\t{ MYRS_DEVICE_MISSING, \"Missing\" },\n\t{ MYRS_DEVICE_SUSPECTED_CRITICAL, \"SuspectedCritical\" },\n\t{ MYRS_DEVICE_OFFLINE, \"Offline\" },\n\t{ MYRS_DEVICE_CRITICAL, \"Critical\" },\n\t{ MYRS_DEVICE_SUSPECTED_DEAD, \"SuspectedDead\" },\n\t{ MYRS_DEVICE_COMMANDED_OFFLINE, \"CommandedOffline\" },\n\t{ MYRS_DEVICE_STANDBY, \"Standby\" },\n\t{ MYRS_DEVICE_INVALID_STATE, \"Invalid\" },\n};\n\nstatic char *myrs_devstate_name(enum myrs_devstate state)\n{\n\tstruct myrs_devstate_name_entry *entry = myrs_devstate_name_list;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(myrs_devstate_name_list); i++) {\n\t\tif (entry[i].state == state)\n\t\t\treturn entry[i].name;\n\t}\n\treturn NULL;\n}\n\nstatic struct myrs_raid_level_name_entry {\n\tenum myrs_raid_level level;\n\tchar *name;\n} myrs_raid_level_name_list[] = {\n\t{ MYRS_RAID_LEVEL0, \"RAID0\" },\n\t{ MYRS_RAID_LEVEL1, \"RAID1\" },\n\t{ MYRS_RAID_LEVEL3, \"RAID3 right asymmetric parity\" },\n\t{ MYRS_RAID_LEVEL5, \"RAID5 right asymmetric parity\" },\n\t{ MYRS_RAID_LEVEL6, \"RAID6\" },\n\t{ MYRS_RAID_JBOD, \"JBOD\" },\n\t{ MYRS_RAID_NEWSPAN, \"New Mylex SPAN\" },\n\t{ MYRS_RAID_LEVEL3F, \"RAID3 fixed parity\" },\n\t{ MYRS_RAID_LEVEL3L, \"RAID3 left symmetric parity\" },\n\t{ MYRS_RAID_SPAN, \"Mylex SPAN\" },\n\t{ MYRS_RAID_LEVEL5L, \"RAID5 left symmetric parity\" },\n\t{ MYRS_RAID_LEVELE, \"RAIDE (concatenation)\" },\n\t{ MYRS_RAID_PHYSICAL, \"Physical device\" },\n};\n\nstatic char *myrs_raid_level_name(enum myrs_raid_level level)\n{\n\tstruct myrs_raid_level_name_entry *entry = myrs_raid_level_name_list;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(myrs_raid_level_name_list); i++) {\n\t\tif (entry[i].level == level)\n\t\t\treturn entry[i].name;\n\t}\n\treturn NULL;\n}\n\n \nstatic inline void myrs_reset_cmd(struct myrs_cmdblk *cmd_blk)\n{\n\tunion myrs_cmd_mbox *mbox = &cmd_blk->mbox;\n\n\tmemset(mbox, 0, sizeof(union myrs_cmd_mbox));\n\tcmd_blk->status = 0;\n}\n\n \nstatic void myrs_qcmd(struct myrs_hba *cs, struct myrs_cmdblk *cmd_blk)\n{\n\tvoid __iomem *base = cs->io_base;\n\tunion myrs_cmd_mbox *mbox = &cmd_blk->mbox;\n\tunion myrs_cmd_mbox *next_mbox = cs->next_cmd_mbox;\n\n\tcs->write_cmd_mbox(next_mbox, mbox);\n\n\tif (cs->prev_cmd_mbox1->words[0] == 0 ||\n\t    cs->prev_cmd_mbox2->words[0] == 0)\n\t\tcs->get_cmd_mbox(base);\n\n\tcs->prev_cmd_mbox2 = cs->prev_cmd_mbox1;\n\tcs->prev_cmd_mbox1 = next_mbox;\n\n\tif (++next_mbox > cs->last_cmd_mbox)\n\t\tnext_mbox = cs->first_cmd_mbox;\n\n\tcs->next_cmd_mbox = next_mbox;\n}\n\n \nstatic void myrs_exec_cmd(struct myrs_hba *cs,\n\t\tstruct myrs_cmdblk *cmd_blk)\n{\n\tDECLARE_COMPLETION_ONSTACK(complete);\n\tunsigned long flags;\n\n\tcmd_blk->complete = &complete;\n\tspin_lock_irqsave(&cs->queue_lock, flags);\n\tmyrs_qcmd(cs, cmd_blk);\n\tspin_unlock_irqrestore(&cs->queue_lock, flags);\n\n\twait_for_completion(&complete);\n}\n\n \nstatic void myrs_report_progress(struct myrs_hba *cs, unsigned short ldev_num,\n\t\tunsigned char *msg, unsigned long blocks,\n\t\tunsigned long size)\n{\n\tshost_printk(KERN_INFO, cs->host,\n\t\t     \"Logical Drive %d: %s in Progress: %d%% completed\\n\",\n\t\t     ldev_num, msg,\n\t\t     (100 * (int)(blocks >> 7)) / (int)(size >> 7));\n}\n\n \nstatic unsigned char myrs_get_ctlr_info(struct myrs_hba *cs)\n{\n\tstruct myrs_cmdblk *cmd_blk = &cs->dcmd_blk;\n\tunion myrs_cmd_mbox *mbox = &cmd_blk->mbox;\n\tdma_addr_t ctlr_info_addr;\n\tunion myrs_sgl *sgl;\n\tunsigned char status;\n\tunsigned short ldev_present, ldev_critical, ldev_offline;\n\n\tldev_present = cs->ctlr_info->ldev_present;\n\tldev_critical = cs->ctlr_info->ldev_critical;\n\tldev_offline = cs->ctlr_info->ldev_offline;\n\n\tctlr_info_addr = dma_map_single(&cs->pdev->dev, cs->ctlr_info,\n\t\t\t\t\tsizeof(struct myrs_ctlr_info),\n\t\t\t\t\tDMA_FROM_DEVICE);\n\tif (dma_mapping_error(&cs->pdev->dev, ctlr_info_addr))\n\t\treturn MYRS_STATUS_FAILED;\n\n\tmutex_lock(&cs->dcmd_mutex);\n\tmyrs_reset_cmd(cmd_blk);\n\tmbox->ctlr_info.id = MYRS_DCMD_TAG;\n\tmbox->ctlr_info.opcode = MYRS_CMD_OP_IOCTL;\n\tmbox->ctlr_info.control.dma_ctrl_to_host = true;\n\tmbox->ctlr_info.control.no_autosense = true;\n\tmbox->ctlr_info.dma_size = sizeof(struct myrs_ctlr_info);\n\tmbox->ctlr_info.ctlr_num = 0;\n\tmbox->ctlr_info.ioctl_opcode = MYRS_IOCTL_GET_CTLR_INFO;\n\tsgl = &mbox->ctlr_info.dma_addr;\n\tsgl->sge[0].sge_addr = ctlr_info_addr;\n\tsgl->sge[0].sge_count = mbox->ctlr_info.dma_size;\n\tdev_dbg(&cs->host->shost_gendev, \"Sending GetControllerInfo\\n\");\n\tmyrs_exec_cmd(cs, cmd_blk);\n\tstatus = cmd_blk->status;\n\tmutex_unlock(&cs->dcmd_mutex);\n\tdma_unmap_single(&cs->pdev->dev, ctlr_info_addr,\n\t\t\t sizeof(struct myrs_ctlr_info), DMA_FROM_DEVICE);\n\tif (status == MYRS_STATUS_SUCCESS) {\n\t\tif (cs->ctlr_info->bg_init_active +\n\t\t    cs->ctlr_info->ldev_init_active +\n\t\t    cs->ctlr_info->pdev_init_active +\n\t\t    cs->ctlr_info->cc_active +\n\t\t    cs->ctlr_info->rbld_active +\n\t\t    cs->ctlr_info->exp_active != 0)\n\t\t\tcs->needs_update = true;\n\t\tif (cs->ctlr_info->ldev_present != ldev_present ||\n\t\t    cs->ctlr_info->ldev_critical != ldev_critical ||\n\t\t    cs->ctlr_info->ldev_offline != ldev_offline)\n\t\t\tshost_printk(KERN_INFO, cs->host,\n\t\t\t\t     \"Logical drive count changes (%d/%d/%d)\\n\",\n\t\t\t\t     cs->ctlr_info->ldev_critical,\n\t\t\t\t     cs->ctlr_info->ldev_offline,\n\t\t\t\t     cs->ctlr_info->ldev_present);\n\t}\n\n\treturn status;\n}\n\n \nstatic unsigned char myrs_get_ldev_info(struct myrs_hba *cs,\n\t\tunsigned short ldev_num, struct myrs_ldev_info *ldev_info)\n{\n\tstruct myrs_cmdblk *cmd_blk = &cs->dcmd_blk;\n\tunion myrs_cmd_mbox *mbox = &cmd_blk->mbox;\n\tdma_addr_t ldev_info_addr;\n\tstruct myrs_ldev_info ldev_info_orig;\n\tunion myrs_sgl *sgl;\n\tunsigned char status;\n\n\tmemcpy(&ldev_info_orig, ldev_info, sizeof(struct myrs_ldev_info));\n\tldev_info_addr = dma_map_single(&cs->pdev->dev, ldev_info,\n\t\t\t\t\tsizeof(struct myrs_ldev_info),\n\t\t\t\t\tDMA_FROM_DEVICE);\n\tif (dma_mapping_error(&cs->pdev->dev, ldev_info_addr))\n\t\treturn MYRS_STATUS_FAILED;\n\n\tmutex_lock(&cs->dcmd_mutex);\n\tmyrs_reset_cmd(cmd_blk);\n\tmbox->ldev_info.id = MYRS_DCMD_TAG;\n\tmbox->ldev_info.opcode = MYRS_CMD_OP_IOCTL;\n\tmbox->ldev_info.control.dma_ctrl_to_host = true;\n\tmbox->ldev_info.control.no_autosense = true;\n\tmbox->ldev_info.dma_size = sizeof(struct myrs_ldev_info);\n\tmbox->ldev_info.ldev.ldev_num = ldev_num;\n\tmbox->ldev_info.ioctl_opcode = MYRS_IOCTL_GET_LDEV_INFO_VALID;\n\tsgl = &mbox->ldev_info.dma_addr;\n\tsgl->sge[0].sge_addr = ldev_info_addr;\n\tsgl->sge[0].sge_count = mbox->ldev_info.dma_size;\n\tdev_dbg(&cs->host->shost_gendev,\n\t\t\"Sending GetLogicalDeviceInfoValid for ldev %d\\n\", ldev_num);\n\tmyrs_exec_cmd(cs, cmd_blk);\n\tstatus = cmd_blk->status;\n\tmutex_unlock(&cs->dcmd_mutex);\n\tdma_unmap_single(&cs->pdev->dev, ldev_info_addr,\n\t\t\t sizeof(struct myrs_ldev_info), DMA_FROM_DEVICE);\n\tif (status == MYRS_STATUS_SUCCESS) {\n\t\tunsigned short ldev_num = ldev_info->ldev_num;\n\t\tstruct myrs_ldev_info *new = ldev_info;\n\t\tstruct myrs_ldev_info *old = &ldev_info_orig;\n\t\tunsigned long ldev_size = new->cfg_devsize;\n\n\t\tif (new->dev_state != old->dev_state) {\n\t\t\tconst char *name;\n\n\t\t\tname = myrs_devstate_name(new->dev_state);\n\t\t\tshost_printk(KERN_INFO, cs->host,\n\t\t\t\t     \"Logical Drive %d is now %s\\n\",\n\t\t\t\t     ldev_num, name ? name : \"Invalid\");\n\t\t}\n\t\tif ((new->soft_errs != old->soft_errs) ||\n\t\t    (new->cmds_failed != old->cmds_failed) ||\n\t\t    (new->deferred_write_errs != old->deferred_write_errs))\n\t\t\tshost_printk(KERN_INFO, cs->host,\n\t\t\t\t     \"Logical Drive %d Errors: Soft = %d, Failed = %d, Deferred Write = %d\\n\",\n\t\t\t\t     ldev_num, new->soft_errs,\n\t\t\t\t     new->cmds_failed,\n\t\t\t\t     new->deferred_write_errs);\n\t\tif (new->bg_init_active)\n\t\t\tmyrs_report_progress(cs, ldev_num,\n\t\t\t\t\t     \"Background Initialization\",\n\t\t\t\t\t     new->bg_init_lba, ldev_size);\n\t\telse if (new->fg_init_active)\n\t\t\tmyrs_report_progress(cs, ldev_num,\n\t\t\t\t\t     \"Foreground Initialization\",\n\t\t\t\t\t     new->fg_init_lba, ldev_size);\n\t\telse if (new->migration_active)\n\t\t\tmyrs_report_progress(cs, ldev_num,\n\t\t\t\t\t     \"Data Migration\",\n\t\t\t\t\t     new->migration_lba, ldev_size);\n\t\telse if (new->patrol_active)\n\t\t\tmyrs_report_progress(cs, ldev_num,\n\t\t\t\t\t     \"Patrol Operation\",\n\t\t\t\t\t     new->patrol_lba, ldev_size);\n\t\tif (old->bg_init_active && !new->bg_init_active)\n\t\t\tshost_printk(KERN_INFO, cs->host,\n\t\t\t\t     \"Logical Drive %d: Background Initialization %s\\n\",\n\t\t\t\t     ldev_num,\n\t\t\t\t     (new->ldev_control.ldev_init_done ?\n\t\t\t\t      \"Completed\" : \"Failed\"));\n\t}\n\treturn status;\n}\n\n \nstatic unsigned char myrs_get_pdev_info(struct myrs_hba *cs,\n\t\tunsigned char channel, unsigned char target, unsigned char lun,\n\t\tstruct myrs_pdev_info *pdev_info)\n{\n\tstruct myrs_cmdblk *cmd_blk = &cs->dcmd_blk;\n\tunion myrs_cmd_mbox *mbox = &cmd_blk->mbox;\n\tdma_addr_t pdev_info_addr;\n\tunion myrs_sgl *sgl;\n\tunsigned char status;\n\n\tpdev_info_addr = dma_map_single(&cs->pdev->dev, pdev_info,\n\t\t\t\t\tsizeof(struct myrs_pdev_info),\n\t\t\t\t\tDMA_FROM_DEVICE);\n\tif (dma_mapping_error(&cs->pdev->dev, pdev_info_addr))\n\t\treturn MYRS_STATUS_FAILED;\n\n\tmutex_lock(&cs->dcmd_mutex);\n\tmyrs_reset_cmd(cmd_blk);\n\tmbox->pdev_info.opcode = MYRS_CMD_OP_IOCTL;\n\tmbox->pdev_info.id = MYRS_DCMD_TAG;\n\tmbox->pdev_info.control.dma_ctrl_to_host = true;\n\tmbox->pdev_info.control.no_autosense = true;\n\tmbox->pdev_info.dma_size = sizeof(struct myrs_pdev_info);\n\tmbox->pdev_info.pdev.lun = lun;\n\tmbox->pdev_info.pdev.target = target;\n\tmbox->pdev_info.pdev.channel = channel;\n\tmbox->pdev_info.ioctl_opcode = MYRS_IOCTL_GET_PDEV_INFO_VALID;\n\tsgl = &mbox->pdev_info.dma_addr;\n\tsgl->sge[0].sge_addr = pdev_info_addr;\n\tsgl->sge[0].sge_count = mbox->pdev_info.dma_size;\n\tdev_dbg(&cs->host->shost_gendev,\n\t\t\"Sending GetPhysicalDeviceInfoValid for pdev %d:%d:%d\\n\",\n\t\tchannel, target, lun);\n\tmyrs_exec_cmd(cs, cmd_blk);\n\tstatus = cmd_blk->status;\n\tmutex_unlock(&cs->dcmd_mutex);\n\tdma_unmap_single(&cs->pdev->dev, pdev_info_addr,\n\t\t\t sizeof(struct myrs_pdev_info), DMA_FROM_DEVICE);\n\treturn status;\n}\n\n \nstatic unsigned char myrs_dev_op(struct myrs_hba *cs,\n\t\tenum myrs_ioctl_opcode opcode, enum myrs_opdev opdev)\n{\n\tstruct myrs_cmdblk *cmd_blk = &cs->dcmd_blk;\n\tunion myrs_cmd_mbox *mbox = &cmd_blk->mbox;\n\tunsigned char status;\n\n\tmutex_lock(&cs->dcmd_mutex);\n\tmyrs_reset_cmd(cmd_blk);\n\tmbox->dev_op.opcode = MYRS_CMD_OP_IOCTL;\n\tmbox->dev_op.id = MYRS_DCMD_TAG;\n\tmbox->dev_op.control.dma_ctrl_to_host = true;\n\tmbox->dev_op.control.no_autosense = true;\n\tmbox->dev_op.ioctl_opcode = opcode;\n\tmbox->dev_op.opdev = opdev;\n\tmyrs_exec_cmd(cs, cmd_blk);\n\tstatus = cmd_blk->status;\n\tmutex_unlock(&cs->dcmd_mutex);\n\treturn status;\n}\n\n \nstatic unsigned char myrs_translate_pdev(struct myrs_hba *cs,\n\t\tunsigned char channel, unsigned char target, unsigned char lun,\n\t\tstruct myrs_devmap *devmap)\n{\n\tstruct pci_dev *pdev = cs->pdev;\n\tdma_addr_t devmap_addr;\n\tstruct myrs_cmdblk *cmd_blk;\n\tunion myrs_cmd_mbox *mbox;\n\tunion myrs_sgl *sgl;\n\tunsigned char status;\n\n\tmemset(devmap, 0x0, sizeof(struct myrs_devmap));\n\tdevmap_addr = dma_map_single(&pdev->dev, devmap,\n\t\t\t\t     sizeof(struct myrs_devmap),\n\t\t\t\t     DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&pdev->dev, devmap_addr))\n\t\treturn MYRS_STATUS_FAILED;\n\n\tmutex_lock(&cs->dcmd_mutex);\n\tcmd_blk = &cs->dcmd_blk;\n\tmbox = &cmd_blk->mbox;\n\tmbox->pdev_info.opcode = MYRS_CMD_OP_IOCTL;\n\tmbox->pdev_info.control.dma_ctrl_to_host = true;\n\tmbox->pdev_info.control.no_autosense = true;\n\tmbox->pdev_info.dma_size = sizeof(struct myrs_devmap);\n\tmbox->pdev_info.pdev.target = target;\n\tmbox->pdev_info.pdev.channel = channel;\n\tmbox->pdev_info.pdev.lun = lun;\n\tmbox->pdev_info.ioctl_opcode = MYRS_IOCTL_XLATE_PDEV_TO_LDEV;\n\tsgl = &mbox->pdev_info.dma_addr;\n\tsgl->sge[0].sge_addr = devmap_addr;\n\tsgl->sge[0].sge_count = mbox->pdev_info.dma_size;\n\n\tmyrs_exec_cmd(cs, cmd_blk);\n\tstatus = cmd_blk->status;\n\tmutex_unlock(&cs->dcmd_mutex);\n\tdma_unmap_single(&pdev->dev, devmap_addr,\n\t\t\t sizeof(struct myrs_devmap), DMA_FROM_DEVICE);\n\treturn status;\n}\n\n \nstatic unsigned char myrs_get_event(struct myrs_hba *cs,\n\t\tunsigned int event_num, struct myrs_event *event_buf)\n{\n\tstruct pci_dev *pdev = cs->pdev;\n\tdma_addr_t event_addr;\n\tstruct myrs_cmdblk *cmd_blk = &cs->mcmd_blk;\n\tunion myrs_cmd_mbox *mbox = &cmd_blk->mbox;\n\tunion myrs_sgl *sgl;\n\tunsigned char status;\n\n\tevent_addr = dma_map_single(&pdev->dev, event_buf,\n\t\t\t\t    sizeof(struct myrs_event), DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&pdev->dev, event_addr))\n\t\treturn MYRS_STATUS_FAILED;\n\n\tmbox->get_event.opcode = MYRS_CMD_OP_IOCTL;\n\tmbox->get_event.dma_size = sizeof(struct myrs_event);\n\tmbox->get_event.evnum_upper = event_num >> 16;\n\tmbox->get_event.ctlr_num = 0;\n\tmbox->get_event.ioctl_opcode = MYRS_IOCTL_GET_EVENT;\n\tmbox->get_event.evnum_lower = event_num & 0xFFFF;\n\tsgl = &mbox->get_event.dma_addr;\n\tsgl->sge[0].sge_addr = event_addr;\n\tsgl->sge[0].sge_count = mbox->get_event.dma_size;\n\tmyrs_exec_cmd(cs, cmd_blk);\n\tstatus = cmd_blk->status;\n\tdma_unmap_single(&pdev->dev, event_addr,\n\t\t\t sizeof(struct myrs_event), DMA_FROM_DEVICE);\n\n\treturn status;\n}\n\n \nstatic unsigned char myrs_get_fwstatus(struct myrs_hba *cs)\n{\n\tstruct myrs_cmdblk *cmd_blk = &cs->mcmd_blk;\n\tunion myrs_cmd_mbox *mbox = &cmd_blk->mbox;\n\tunion myrs_sgl *sgl;\n\tunsigned char status = cmd_blk->status;\n\n\tmyrs_reset_cmd(cmd_blk);\n\tmbox->common.opcode = MYRS_CMD_OP_IOCTL;\n\tmbox->common.id = MYRS_MCMD_TAG;\n\tmbox->common.control.dma_ctrl_to_host = true;\n\tmbox->common.control.no_autosense = true;\n\tmbox->common.dma_size = sizeof(struct myrs_fwstat);\n\tmbox->common.ioctl_opcode = MYRS_IOCTL_GET_HEALTH_STATUS;\n\tsgl = &mbox->common.dma_addr;\n\tsgl->sge[0].sge_addr = cs->fwstat_addr;\n\tsgl->sge[0].sge_count = mbox->ctlr_info.dma_size;\n\tdev_dbg(&cs->host->shost_gendev, \"Sending GetHealthStatus\\n\");\n\tmyrs_exec_cmd(cs, cmd_blk);\n\tstatus = cmd_blk->status;\n\n\treturn status;\n}\n\n \nstatic bool myrs_enable_mmio_mbox(struct myrs_hba *cs,\n\t\tenable_mbox_t enable_mbox_fn)\n{\n\tvoid __iomem *base = cs->io_base;\n\tstruct pci_dev *pdev = cs->pdev;\n\tunion myrs_cmd_mbox *cmd_mbox;\n\tstruct myrs_stat_mbox *stat_mbox;\n\tunion myrs_cmd_mbox *mbox;\n\tdma_addr_t mbox_addr;\n\tunsigned char status = MYRS_STATUS_FAILED;\n\n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(64)))\n\t\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\t\tdev_err(&pdev->dev, \"DMA mask out of range\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t \n\tmbox = dma_alloc_coherent(&pdev->dev, sizeof(union myrs_cmd_mbox),\n\t\t\t\t  &mbox_addr, GFP_KERNEL);\n\tif (dma_mapping_error(&pdev->dev, mbox_addr))\n\t\treturn false;\n\n\t \n\tcs->cmd_mbox_size = MYRS_MAX_CMD_MBOX * sizeof(union myrs_cmd_mbox);\n\tcmd_mbox = dma_alloc_coherent(&pdev->dev, cs->cmd_mbox_size,\n\t\t\t\t      &cs->cmd_mbox_addr, GFP_KERNEL);\n\tif (dma_mapping_error(&pdev->dev, cs->cmd_mbox_addr)) {\n\t\tdev_err(&pdev->dev, \"Failed to map command mailbox\\n\");\n\t\tgoto out_free;\n\t}\n\tcs->first_cmd_mbox = cmd_mbox;\n\tcmd_mbox += MYRS_MAX_CMD_MBOX - 1;\n\tcs->last_cmd_mbox = cmd_mbox;\n\tcs->next_cmd_mbox = cs->first_cmd_mbox;\n\tcs->prev_cmd_mbox1 = cs->last_cmd_mbox;\n\tcs->prev_cmd_mbox2 = cs->last_cmd_mbox - 1;\n\n\t \n\tcs->stat_mbox_size = MYRS_MAX_STAT_MBOX * sizeof(struct myrs_stat_mbox);\n\tstat_mbox = dma_alloc_coherent(&pdev->dev, cs->stat_mbox_size,\n\t\t\t\t       &cs->stat_mbox_addr, GFP_KERNEL);\n\tif (dma_mapping_error(&pdev->dev, cs->stat_mbox_addr)) {\n\t\tdev_err(&pdev->dev, \"Failed to map status mailbox\\n\");\n\t\tgoto out_free;\n\t}\n\n\tcs->first_stat_mbox = stat_mbox;\n\tstat_mbox += MYRS_MAX_STAT_MBOX - 1;\n\tcs->last_stat_mbox = stat_mbox;\n\tcs->next_stat_mbox = cs->first_stat_mbox;\n\n\tcs->fwstat_buf = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t    sizeof(struct myrs_fwstat),\n\t\t\t\t\t    &cs->fwstat_addr, GFP_KERNEL);\n\tif (dma_mapping_error(&pdev->dev, cs->fwstat_addr)) {\n\t\tdev_err(&pdev->dev, \"Failed to map firmware health buffer\\n\");\n\t\tcs->fwstat_buf = NULL;\n\t\tgoto out_free;\n\t}\n\tcs->ctlr_info = kzalloc(sizeof(struct myrs_ctlr_info), GFP_KERNEL);\n\tif (!cs->ctlr_info)\n\t\tgoto out_free;\n\n\tcs->event_buf = kzalloc(sizeof(struct myrs_event), GFP_KERNEL);\n\tif (!cs->event_buf)\n\t\tgoto out_free;\n\n\t \n\tmemset(mbox, 0, sizeof(union myrs_cmd_mbox));\n\tmbox->set_mbox.id = 1;\n\tmbox->set_mbox.opcode = MYRS_CMD_OP_IOCTL;\n\tmbox->set_mbox.control.no_autosense = true;\n\tmbox->set_mbox.first_cmd_mbox_size_kb =\n\t\t(MYRS_MAX_CMD_MBOX * sizeof(union myrs_cmd_mbox)) >> 10;\n\tmbox->set_mbox.first_stat_mbox_size_kb =\n\t\t(MYRS_MAX_STAT_MBOX * sizeof(struct myrs_stat_mbox)) >> 10;\n\tmbox->set_mbox.second_cmd_mbox_size_kb = 0;\n\tmbox->set_mbox.second_stat_mbox_size_kb = 0;\n\tmbox->set_mbox.sense_len = 0;\n\tmbox->set_mbox.ioctl_opcode = MYRS_IOCTL_SET_MEM_MBOX;\n\tmbox->set_mbox.fwstat_buf_size_kb = 1;\n\tmbox->set_mbox.fwstat_buf_addr = cs->fwstat_addr;\n\tmbox->set_mbox.first_cmd_mbox_addr = cs->cmd_mbox_addr;\n\tmbox->set_mbox.first_stat_mbox_addr = cs->stat_mbox_addr;\n\tstatus = enable_mbox_fn(base, mbox_addr);\n\nout_free:\n\tdma_free_coherent(&pdev->dev, sizeof(union myrs_cmd_mbox),\n\t\t\t  mbox, mbox_addr);\n\tif (status != MYRS_STATUS_SUCCESS)\n\t\tdev_err(&pdev->dev, \"Failed to enable mailbox, status %X\\n\",\n\t\t\tstatus);\n\treturn (status == MYRS_STATUS_SUCCESS);\n}\n\n \nstatic int myrs_get_config(struct myrs_hba *cs)\n{\n\tstruct myrs_ctlr_info *info = cs->ctlr_info;\n\tstruct Scsi_Host *shost = cs->host;\n\tunsigned char status;\n\tunsigned char model[20];\n\tunsigned char fw_version[12];\n\tint i, model_len;\n\n\t \n\tmutex_lock(&cs->cinfo_mutex);\n\tstatus = myrs_get_ctlr_info(cs);\n\tmutex_unlock(&cs->cinfo_mutex);\n\tif (status != MYRS_STATUS_SUCCESS) {\n\t\tshost_printk(KERN_ERR, shost,\n\t\t\t     \"Failed to get controller information\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tmodel_len = sizeof(info->ctlr_name);\n\tif (model_len > sizeof(model)-1)\n\t\tmodel_len = sizeof(model)-1;\n\tmemcpy(model, info->ctlr_name, model_len);\n\tmodel_len--;\n\twhile (model[model_len] == ' ' || model[model_len] == '\\0')\n\t\tmodel_len--;\n\tmodel[++model_len] = '\\0';\n\tstrcpy(cs->model_name, \"DAC960 \");\n\tstrcat(cs->model_name, model);\n\t \n\tsprintf(fw_version, \"%d.%02d-%02d\",\n\t\tinfo->fw_major_version, info->fw_minor_version,\n\t\tinfo->fw_turn_number);\n\tif (info->fw_major_version == 6 &&\n\t    info->fw_minor_version == 0 &&\n\t    info->fw_turn_number < 1) {\n\t\tshost_printk(KERN_WARNING, shost,\n\t\t\t\"FIRMWARE VERSION %s DOES NOT PROVIDE THE CONTROLLER\\n\"\n\t\t\t\"STATUS MONITORING FUNCTIONALITY NEEDED BY THIS DRIVER.\\n\"\n\t\t\t\"PLEASE UPGRADE TO VERSION 6.00-01 OR ABOVE.\\n\",\n\t\t\tfw_version);\n\t\treturn -ENODEV;\n\t}\n\t \n\tshost->max_channel = info->physchan_present + info->virtchan_present;\n\tshost->max_id = info->max_targets[0];\n\tfor (i = 1; i < 16; i++) {\n\t\tif (!info->max_targets[i])\n\t\t\tcontinue;\n\t\tif (shost->max_id < info->max_targets[i])\n\t\t\tshost->max_id = info->max_targets[i];\n\t}\n\n\t \n\tshost->can_queue = info->max_tcq - 3;\n\tif (shost->can_queue > MYRS_MAX_CMD_MBOX - 3)\n\t\tshost->can_queue = MYRS_MAX_CMD_MBOX - 3;\n\tshost->max_sectors = info->max_transfer_size;\n\tshost->sg_tablesize = info->max_sge;\n\tif (shost->sg_tablesize > MYRS_SG_LIMIT)\n\t\tshost->sg_tablesize = MYRS_SG_LIMIT;\n\n\tshost_printk(KERN_INFO, shost,\n\t\t\"Configuring %s PCI RAID Controller\\n\", model);\n\tshost_printk(KERN_INFO, shost,\n\t\t\"  Firmware Version: %s, Channels: %d, Memory Size: %dMB\\n\",\n\t\tfw_version, info->physchan_present, info->mem_size_mb);\n\n\tshost_printk(KERN_INFO, shost,\n\t\t     \"  Controller Queue Depth: %d, Maximum Blocks per Command: %d\\n\",\n\t\t     shost->can_queue, shost->max_sectors);\n\n\tshost_printk(KERN_INFO, shost,\n\t\t     \"  Driver Queue Depth: %d, Scatter/Gather Limit: %d of %d Segments\\n\",\n\t\t     shost->can_queue, shost->sg_tablesize, MYRS_SG_LIMIT);\n\tfor (i = 0; i < info->physchan_max; i++) {\n\t\tif (!info->max_targets[i])\n\t\t\tcontinue;\n\t\tshost_printk(KERN_INFO, shost,\n\t\t\t     \"  Device Channel %d: max %d devices\\n\",\n\t\t\t     i, info->max_targets[i]);\n\t}\n\tshost_printk(KERN_INFO, shost,\n\t\t     \"  Physical: %d/%d channels, %d disks, %d devices\\n\",\n\t\t     info->physchan_present, info->physchan_max,\n\t\t     info->pdisk_present, info->pdev_present);\n\n\tshost_printk(KERN_INFO, shost,\n\t\t     \"  Logical: %d/%d channels, %d disks\\n\",\n\t\t     info->virtchan_present, info->virtchan_max,\n\t\t     info->ldev_present);\n\treturn 0;\n}\n\n \nstatic struct {\n\tint ev_code;\n\tunsigned char *ev_msg;\n} myrs_ev_list[] = {\n\t \n\t{ 0x0001, \"P Online\" },\n\t{ 0x0002, \"P Standby\" },\n\t{ 0x0005, \"P Automatic Rebuild Started\" },\n\t{ 0x0006, \"P Manual Rebuild Started\" },\n\t{ 0x0007, \"P Rebuild Completed\" },\n\t{ 0x0008, \"P Rebuild Cancelled\" },\n\t{ 0x0009, \"P Rebuild Failed for Unknown Reasons\" },\n\t{ 0x000A, \"P Rebuild Failed due to New Physical Device\" },\n\t{ 0x000B, \"P Rebuild Failed due to Logical Drive Failure\" },\n\t{ 0x000C, \"S Offline\" },\n\t{ 0x000D, \"P Found\" },\n\t{ 0x000E, \"P Removed\" },\n\t{ 0x000F, \"P Unconfigured\" },\n\t{ 0x0010, \"P Expand Capacity Started\" },\n\t{ 0x0011, \"P Expand Capacity Completed\" },\n\t{ 0x0012, \"P Expand Capacity Failed\" },\n\t{ 0x0013, \"P Command Timed Out\" },\n\t{ 0x0014, \"P Command Aborted\" },\n\t{ 0x0015, \"P Command Retried\" },\n\t{ 0x0016, \"P Parity Error\" },\n\t{ 0x0017, \"P Soft Error\" },\n\t{ 0x0018, \"P Miscellaneous Error\" },\n\t{ 0x0019, \"P Reset\" },\n\t{ 0x001A, \"P Active Spare Found\" },\n\t{ 0x001B, \"P Warm Spare Found\" },\n\t{ 0x001C, \"S Sense Data Received\" },\n\t{ 0x001D, \"P Initialization Started\" },\n\t{ 0x001E, \"P Initialization Completed\" },\n\t{ 0x001F, \"P Initialization Failed\" },\n\t{ 0x0020, \"P Initialization Cancelled\" },\n\t{ 0x0021, \"P Failed because Write Recovery Failed\" },\n\t{ 0x0022, \"P Failed because SCSI Bus Reset Failed\" },\n\t{ 0x0023, \"P Failed because of Double Check Condition\" },\n\t{ 0x0024, \"P Failed because Device Cannot Be Accessed\" },\n\t{ 0x0025, \"P Failed because of Gross Error on SCSI Processor\" },\n\t{ 0x0026, \"P Failed because of Bad Tag from Device\" },\n\t{ 0x0027, \"P Failed because of Command Timeout\" },\n\t{ 0x0028, \"P Failed because of System Reset\" },\n\t{ 0x0029, \"P Failed because of Busy Status or Parity Error\" },\n\t{ 0x002A, \"P Failed because Host Set Device to Failed State\" },\n\t{ 0x002B, \"P Failed because of Selection Timeout\" },\n\t{ 0x002C, \"P Failed because of SCSI Bus Phase Error\" },\n\t{ 0x002D, \"P Failed because Device Returned Unknown Status\" },\n\t{ 0x002E, \"P Failed because Device Not Ready\" },\n\t{ 0x002F, \"P Failed because Device Not Found at Startup\" },\n\t{ 0x0030, \"P Failed because COD Write Operation Failed\" },\n\t{ 0x0031, \"P Failed because BDT Write Operation Failed\" },\n\t{ 0x0039, \"P Missing at Startup\" },\n\t{ 0x003A, \"P Start Rebuild Failed due to Physical Drive Too Small\" },\n\t{ 0x003C, \"P Temporarily Offline Device Automatically Made Online\" },\n\t{ 0x003D, \"P Standby Rebuild Started\" },\n\t \n\t{ 0x0080, \"M Consistency Check Started\" },\n\t{ 0x0081, \"M Consistency Check Completed\" },\n\t{ 0x0082, \"M Consistency Check Cancelled\" },\n\t{ 0x0083, \"M Consistency Check Completed With Errors\" },\n\t{ 0x0084, \"M Consistency Check Failed due to Logical Drive Failure\" },\n\t{ 0x0085, \"M Consistency Check Failed due to Physical Device Failure\" },\n\t{ 0x0086, \"L Offline\" },\n\t{ 0x0087, \"L Critical\" },\n\t{ 0x0088, \"L Online\" },\n\t{ 0x0089, \"M Automatic Rebuild Started\" },\n\t{ 0x008A, \"M Manual Rebuild Started\" },\n\t{ 0x008B, \"M Rebuild Completed\" },\n\t{ 0x008C, \"M Rebuild Cancelled\" },\n\t{ 0x008D, \"M Rebuild Failed for Unknown Reasons\" },\n\t{ 0x008E, \"M Rebuild Failed due to New Physical Device\" },\n\t{ 0x008F, \"M Rebuild Failed due to Logical Drive Failure\" },\n\t{ 0x0090, \"M Initialization Started\" },\n\t{ 0x0091, \"M Initialization Completed\" },\n\t{ 0x0092, \"M Initialization Cancelled\" },\n\t{ 0x0093, \"M Initialization Failed\" },\n\t{ 0x0094, \"L Found\" },\n\t{ 0x0095, \"L Deleted\" },\n\t{ 0x0096, \"M Expand Capacity Started\" },\n\t{ 0x0097, \"M Expand Capacity Completed\" },\n\t{ 0x0098, \"M Expand Capacity Failed\" },\n\t{ 0x0099, \"L Bad Block Found\" },\n\t{ 0x009A, \"L Size Changed\" },\n\t{ 0x009B, \"L Type Changed\" },\n\t{ 0x009C, \"L Bad Data Block Found\" },\n\t{ 0x009E, \"L Read of Data Block in BDT\" },\n\t{ 0x009F, \"L Write Back Data for Disk Block Lost\" },\n\t{ 0x00A0, \"L Temporarily Offline RAID-5/3 Drive Made Online\" },\n\t{ 0x00A1, \"L Temporarily Offline RAID-6/1/0/7 Drive Made Online\" },\n\t{ 0x00A2, \"L Standby Rebuild Started\" },\n\t \n\t{ 0x0140, \"E Fan %d Failed\" },\n\t{ 0x0141, \"E Fan %d OK\" },\n\t{ 0x0142, \"E Fan %d Not Present\" },\n\t{ 0x0143, \"E Power Supply %d Failed\" },\n\t{ 0x0144, \"E Power Supply %d OK\" },\n\t{ 0x0145, \"E Power Supply %d Not Present\" },\n\t{ 0x0146, \"E Temperature Sensor %d Temperature Exceeds Safe Limit\" },\n\t{ 0x0147, \"E Temperature Sensor %d Temperature Exceeds Working Limit\" },\n\t{ 0x0148, \"E Temperature Sensor %d Temperature Normal\" },\n\t{ 0x0149, \"E Temperature Sensor %d Not Present\" },\n\t{ 0x014A, \"E Enclosure Management Unit %d Access Critical\" },\n\t{ 0x014B, \"E Enclosure Management Unit %d Access OK\" },\n\t{ 0x014C, \"E Enclosure Management Unit %d Access Offline\" },\n\t \n\t{ 0x0181, \"C Cache Write Back Error\" },\n\t{ 0x0188, \"C Battery Backup Unit Found\" },\n\t{ 0x0189, \"C Battery Backup Unit Charge Level Low\" },\n\t{ 0x018A, \"C Battery Backup Unit Charge Level OK\" },\n\t{ 0x0193, \"C Installation Aborted\" },\n\t{ 0x0195, \"C Battery Backup Unit Physically Removed\" },\n\t{ 0x0196, \"C Memory Error During Warm Boot\" },\n\t{ 0x019E, \"C Memory Soft ECC Error Corrected\" },\n\t{ 0x019F, \"C Memory Hard ECC Error Corrected\" },\n\t{ 0x01A2, \"C Battery Backup Unit Failed\" },\n\t{ 0x01AB, \"C Mirror Race Recovery Failed\" },\n\t{ 0x01AC, \"C Mirror Race on Critical Drive\" },\n\t \n\t{ 0x0380, \"C Internal Controller Hung\" },\n\t{ 0x0381, \"C Internal Controller Firmware Breakpoint\" },\n\t{ 0x0390, \"C Internal Controller i960 Processor Specific Error\" },\n\t{ 0x03A0, \"C Internal Controller StrongARM Processor Specific Error\" },\n\t{ 0, \"\" }\n};\n\nstatic void myrs_log_event(struct myrs_hba *cs, struct myrs_event *ev)\n{\n\tunsigned char msg_buf[MYRS_LINE_BUFFER_SIZE];\n\tint ev_idx = 0, ev_code;\n\tunsigned char ev_type, *ev_msg;\n\tstruct Scsi_Host *shost = cs->host;\n\tstruct scsi_device *sdev;\n\tstruct scsi_sense_hdr sshdr = {0};\n\tunsigned char sense_info[4];\n\tunsigned char cmd_specific[4];\n\n\tif (ev->ev_code == 0x1C) {\n\t\tif (!scsi_normalize_sense(ev->sense_data, 40, &sshdr)) {\n\t\t\tmemset(&sshdr, 0x0, sizeof(sshdr));\n\t\t\tmemset(sense_info, 0x0, sizeof(sense_info));\n\t\t\tmemset(cmd_specific, 0x0, sizeof(cmd_specific));\n\t\t} else {\n\t\t\tmemcpy(sense_info, &ev->sense_data[3], 4);\n\t\t\tmemcpy(cmd_specific, &ev->sense_data[7], 4);\n\t\t}\n\t}\n\tif (sshdr.sense_key == VENDOR_SPECIFIC &&\n\t    (sshdr.asc == 0x80 || sshdr.asc == 0x81))\n\t\tev->ev_code = ((sshdr.asc - 0x80) << 8 | sshdr.ascq);\n\twhile (true) {\n\t\tev_code = myrs_ev_list[ev_idx].ev_code;\n\t\tif (ev_code == ev->ev_code || ev_code == 0)\n\t\t\tbreak;\n\t\tev_idx++;\n\t}\n\tev_type = myrs_ev_list[ev_idx].ev_msg[0];\n\tev_msg = &myrs_ev_list[ev_idx].ev_msg[2];\n\tif (ev_code == 0) {\n\t\tshost_printk(KERN_WARNING, shost,\n\t\t\t     \"Unknown Controller Event Code %04X\\n\",\n\t\t\t     ev->ev_code);\n\t\treturn;\n\t}\n\tswitch (ev_type) {\n\tcase 'P':\n\t\tsdev = scsi_device_lookup(shost, ev->channel,\n\t\t\t\t\t  ev->target, 0);\n\t\tsdev_printk(KERN_INFO, sdev, \"event %d: Physical Device %s\\n\",\n\t\t\t    ev->ev_seq, ev_msg);\n\t\tif (sdev && sdev->hostdata &&\n\t\t    sdev->channel < cs->ctlr_info->physchan_present) {\n\t\t\tstruct myrs_pdev_info *pdev_info = sdev->hostdata;\n\n\t\t\tswitch (ev->ev_code) {\n\t\t\tcase 0x0001:\n\t\t\tcase 0x0007:\n\t\t\t\tpdev_info->dev_state = MYRS_DEVICE_ONLINE;\n\t\t\t\tbreak;\n\t\t\tcase 0x0002:\n\t\t\t\tpdev_info->dev_state = MYRS_DEVICE_STANDBY;\n\t\t\t\tbreak;\n\t\t\tcase 0x000C:\n\t\t\t\tpdev_info->dev_state = MYRS_DEVICE_OFFLINE;\n\t\t\t\tbreak;\n\t\t\tcase 0x000E:\n\t\t\t\tpdev_info->dev_state = MYRS_DEVICE_MISSING;\n\t\t\t\tbreak;\n\t\t\tcase 0x000F:\n\t\t\t\tpdev_info->dev_state = MYRS_DEVICE_UNCONFIGURED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'L':\n\t\tshost_printk(KERN_INFO, shost,\n\t\t\t     \"event %d: Logical Drive %d %s\\n\",\n\t\t\t     ev->ev_seq, ev->lun, ev_msg);\n\t\tcs->needs_update = true;\n\t\tbreak;\n\tcase 'M':\n\t\tshost_printk(KERN_INFO, shost,\n\t\t\t     \"event %d: Logical Drive %d %s\\n\",\n\t\t\t     ev->ev_seq, ev->lun, ev_msg);\n\t\tcs->needs_update = true;\n\t\tbreak;\n\tcase 'S':\n\t\tif (sshdr.sense_key == NO_SENSE ||\n\t\t    (sshdr.sense_key == NOT_READY &&\n\t\t     sshdr.asc == 0x04 && (sshdr.ascq == 0x01 ||\n\t\t\t\t\t    sshdr.ascq == 0x02)))\n\t\t\tbreak;\n\t\tshost_printk(KERN_INFO, shost,\n\t\t\t     \"event %d: Physical Device %d:%d %s\\n\",\n\t\t\t     ev->ev_seq, ev->channel, ev->target, ev_msg);\n\t\tshost_printk(KERN_INFO, shost,\n\t\t\t     \"Physical Device %d:%d Sense Key = %X, ASC = %02X, ASCQ = %02X\\n\",\n\t\t\t     ev->channel, ev->target,\n\t\t\t     sshdr.sense_key, sshdr.asc, sshdr.ascq);\n\t\tshost_printk(KERN_INFO, shost,\n\t\t\t     \"Physical Device %d:%d Sense Information = %02X%02X%02X%02X %02X%02X%02X%02X\\n\",\n\t\t\t     ev->channel, ev->target,\n\t\t\t     sense_info[0], sense_info[1],\n\t\t\t     sense_info[2], sense_info[3],\n\t\t\t     cmd_specific[0], cmd_specific[1],\n\t\t\t     cmd_specific[2], cmd_specific[3]);\n\t\tbreak;\n\tcase 'E':\n\t\tif (cs->disable_enc_msg)\n\t\t\tbreak;\n\t\tsprintf(msg_buf, ev_msg, ev->lun);\n\t\tshost_printk(KERN_INFO, shost, \"event %d: Enclosure %d %s\\n\",\n\t\t\t     ev->ev_seq, ev->target, msg_buf);\n\t\tbreak;\n\tcase 'C':\n\t\tshost_printk(KERN_INFO, shost, \"event %d: Controller %s\\n\",\n\t\t\t     ev->ev_seq, ev_msg);\n\t\tbreak;\n\tdefault:\n\t\tshost_printk(KERN_INFO, shost,\n\t\t\t     \"event %d: Unknown Event Code %04X\\n\",\n\t\t\t     ev->ev_seq, ev->ev_code);\n\t\tbreak;\n\t}\n}\n\n \nstatic ssize_t raid_state_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrs_hba *cs = shost_priv(sdev->host);\n\tint ret;\n\n\tif (!sdev->hostdata)\n\t\treturn snprintf(buf, 16, \"Unknown\\n\");\n\n\tif (sdev->channel >= cs->ctlr_info->physchan_present) {\n\t\tstruct myrs_ldev_info *ldev_info = sdev->hostdata;\n\t\tconst char *name;\n\n\t\tname = myrs_devstate_name(ldev_info->dev_state);\n\t\tif (name)\n\t\t\tret = snprintf(buf, 32, \"%s\\n\", name);\n\t\telse\n\t\t\tret = snprintf(buf, 32, \"Invalid (%02X)\\n\",\n\t\t\t\t       ldev_info->dev_state);\n\t} else {\n\t\tstruct myrs_pdev_info *pdev_info;\n\t\tconst char *name;\n\n\t\tpdev_info = sdev->hostdata;\n\t\tname = myrs_devstate_name(pdev_info->dev_state);\n\t\tif (name)\n\t\t\tret = snprintf(buf, 32, \"%s\\n\", name);\n\t\telse\n\t\t\tret = snprintf(buf, 32, \"Invalid (%02X)\\n\",\n\t\t\t\t       pdev_info->dev_state);\n\t}\n\treturn ret;\n}\n\nstatic ssize_t raid_state_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrs_hba *cs = shost_priv(sdev->host);\n\tstruct myrs_cmdblk *cmd_blk;\n\tunion myrs_cmd_mbox *mbox;\n\tenum myrs_devstate new_state;\n\tunsigned short ldev_num;\n\tunsigned char status;\n\n\tif (!strncmp(buf, \"offline\", 7) ||\n\t    !strncmp(buf, \"kill\", 4))\n\t\tnew_state = MYRS_DEVICE_OFFLINE;\n\telse if (!strncmp(buf, \"online\", 6))\n\t\tnew_state = MYRS_DEVICE_ONLINE;\n\telse if (!strncmp(buf, \"standby\", 7))\n\t\tnew_state = MYRS_DEVICE_STANDBY;\n\telse\n\t\treturn -EINVAL;\n\n\tif (sdev->channel < cs->ctlr_info->physchan_present) {\n\t\tstruct myrs_pdev_info *pdev_info = sdev->hostdata;\n\t\tstruct myrs_devmap *pdev_devmap =\n\t\t\t(struct myrs_devmap *)&pdev_info->rsvd13;\n\n\t\tif (pdev_info->dev_state == new_state) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Device already in %s\\n\",\n\t\t\t\t    myrs_devstate_name(new_state));\n\t\t\treturn count;\n\t\t}\n\t\tstatus = myrs_translate_pdev(cs, sdev->channel, sdev->id,\n\t\t\t\t\t     sdev->lun, pdev_devmap);\n\t\tif (status != MYRS_STATUS_SUCCESS)\n\t\t\treturn -ENXIO;\n\t\tldev_num = pdev_devmap->ldev_num;\n\t} else {\n\t\tstruct myrs_ldev_info *ldev_info = sdev->hostdata;\n\n\t\tif (ldev_info->dev_state == new_state) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Device already in %s\\n\",\n\t\t\t\t    myrs_devstate_name(new_state));\n\t\t\treturn count;\n\t\t}\n\t\tldev_num = ldev_info->ldev_num;\n\t}\n\tmutex_lock(&cs->dcmd_mutex);\n\tcmd_blk = &cs->dcmd_blk;\n\tmyrs_reset_cmd(cmd_blk);\n\tmbox = &cmd_blk->mbox;\n\tmbox->common.opcode = MYRS_CMD_OP_IOCTL;\n\tmbox->common.id = MYRS_DCMD_TAG;\n\tmbox->common.control.dma_ctrl_to_host = true;\n\tmbox->common.control.no_autosense = true;\n\tmbox->set_devstate.ioctl_opcode = MYRS_IOCTL_SET_DEVICE_STATE;\n\tmbox->set_devstate.state = new_state;\n\tmbox->set_devstate.ldev.ldev_num = ldev_num;\n\tmyrs_exec_cmd(cs, cmd_blk);\n\tstatus = cmd_blk->status;\n\tmutex_unlock(&cs->dcmd_mutex);\n\tif (status == MYRS_STATUS_SUCCESS) {\n\t\tif (sdev->channel < cs->ctlr_info->physchan_present) {\n\t\t\tstruct myrs_pdev_info *pdev_info = sdev->hostdata;\n\n\t\t\tpdev_info->dev_state = new_state;\n\t\t} else {\n\t\t\tstruct myrs_ldev_info *ldev_info = sdev->hostdata;\n\n\t\t\tldev_info->dev_state = new_state;\n\t\t}\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Set device state to %s\\n\",\n\t\t\t    myrs_devstate_name(new_state));\n\t\treturn count;\n\t}\n\tsdev_printk(KERN_INFO, sdev,\n\t\t    \"Failed to set device state to %s, status 0x%02x\\n\",\n\t\t    myrs_devstate_name(new_state), status);\n\treturn -EINVAL;\n}\nstatic DEVICE_ATTR_RW(raid_state);\n\nstatic ssize_t raid_level_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrs_hba *cs = shost_priv(sdev->host);\n\tconst char *name = NULL;\n\n\tif (!sdev->hostdata)\n\t\treturn snprintf(buf, 16, \"Unknown\\n\");\n\n\tif (sdev->channel >= cs->ctlr_info->physchan_present) {\n\t\tstruct myrs_ldev_info *ldev_info;\n\n\t\tldev_info = sdev->hostdata;\n\t\tname = myrs_raid_level_name(ldev_info->raid_level);\n\t\tif (!name)\n\t\t\treturn snprintf(buf, 32, \"Invalid (%02X)\\n\",\n\t\t\t\t\tldev_info->dev_state);\n\n\t} else\n\t\tname = myrs_raid_level_name(MYRS_RAID_PHYSICAL);\n\n\treturn snprintf(buf, 32, \"%s\\n\", name);\n}\nstatic DEVICE_ATTR_RO(raid_level);\n\nstatic ssize_t rebuild_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrs_hba *cs = shost_priv(sdev->host);\n\tstruct myrs_ldev_info *ldev_info;\n\tunsigned short ldev_num;\n\tunsigned char status;\n\n\tif (sdev->channel < cs->ctlr_info->physchan_present)\n\t\treturn snprintf(buf, 32, \"physical device - not rebuilding\\n\");\n\n\tldev_info = sdev->hostdata;\n\tldev_num = ldev_info->ldev_num;\n\tstatus = myrs_get_ldev_info(cs, ldev_num, ldev_info);\n\tif (status != MYRS_STATUS_SUCCESS) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Failed to get device information, status 0x%02x\\n\",\n\t\t\t    status);\n\t\treturn -EIO;\n\t}\n\tif (ldev_info->rbld_active) {\n\t\treturn snprintf(buf, 32, \"rebuilding block %zu of %zu\\n\",\n\t\t\t\t(size_t)ldev_info->rbld_lba,\n\t\t\t\t(size_t)ldev_info->cfg_devsize);\n\t} else\n\t\treturn snprintf(buf, 32, \"not rebuilding\\n\");\n}\n\nstatic ssize_t rebuild_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrs_hba *cs = shost_priv(sdev->host);\n\tstruct myrs_ldev_info *ldev_info;\n\tstruct myrs_cmdblk *cmd_blk;\n\tunion myrs_cmd_mbox *mbox;\n\tunsigned short ldev_num;\n\tunsigned char status;\n\tint rebuild, ret;\n\n\tif (sdev->channel < cs->ctlr_info->physchan_present)\n\t\treturn -EINVAL;\n\n\tldev_info = sdev->hostdata;\n\tif (!ldev_info)\n\t\treturn -ENXIO;\n\tldev_num = ldev_info->ldev_num;\n\n\tret = kstrtoint(buf, 0, &rebuild);\n\tif (ret)\n\t\treturn ret;\n\n\tstatus = myrs_get_ldev_info(cs, ldev_num, ldev_info);\n\tif (status != MYRS_STATUS_SUCCESS) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Failed to get device information, status 0x%02x\\n\",\n\t\t\t    status);\n\t\treturn -EIO;\n\t}\n\n\tif (rebuild && ldev_info->rbld_active) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Rebuild Not Initiated; already in progress\\n\");\n\t\treturn -EALREADY;\n\t}\n\tif (!rebuild && !ldev_info->rbld_active) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Rebuild Not Cancelled; no rebuild in progress\\n\");\n\t\treturn count;\n\t}\n\n\tmutex_lock(&cs->dcmd_mutex);\n\tcmd_blk = &cs->dcmd_blk;\n\tmyrs_reset_cmd(cmd_blk);\n\tmbox = &cmd_blk->mbox;\n\tmbox->common.opcode = MYRS_CMD_OP_IOCTL;\n\tmbox->common.id = MYRS_DCMD_TAG;\n\tmbox->common.control.dma_ctrl_to_host = true;\n\tmbox->common.control.no_autosense = true;\n\tif (rebuild) {\n\t\tmbox->ldev_info.ldev.ldev_num = ldev_num;\n\t\tmbox->ldev_info.ioctl_opcode = MYRS_IOCTL_RBLD_DEVICE_START;\n\t} else {\n\t\tmbox->ldev_info.ldev.ldev_num = ldev_num;\n\t\tmbox->ldev_info.ioctl_opcode = MYRS_IOCTL_RBLD_DEVICE_STOP;\n\t}\n\tmyrs_exec_cmd(cs, cmd_blk);\n\tstatus = cmd_blk->status;\n\tmutex_unlock(&cs->dcmd_mutex);\n\tif (status) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Rebuild Not %s, status 0x%02x\\n\",\n\t\t\t    rebuild ? \"Initiated\" : \"Cancelled\", status);\n\t\tret = -EIO;\n\t} else {\n\t\tsdev_printk(KERN_INFO, sdev, \"Rebuild %s\\n\",\n\t\t\t    rebuild ? \"Initiated\" : \"Cancelled\");\n\t\tret = count;\n\t}\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RW(rebuild);\n\nstatic ssize_t consistency_check_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrs_hba *cs = shost_priv(sdev->host);\n\tstruct myrs_ldev_info *ldev_info;\n\tunsigned short ldev_num;\n\n\tif (sdev->channel < cs->ctlr_info->physchan_present)\n\t\treturn snprintf(buf, 32, \"physical device - not checking\\n\");\n\n\tldev_info = sdev->hostdata;\n\tif (!ldev_info)\n\t\treturn -ENXIO;\n\tldev_num = ldev_info->ldev_num;\n\tmyrs_get_ldev_info(cs, ldev_num, ldev_info);\n\tif (ldev_info->cc_active)\n\t\treturn snprintf(buf, 32, \"checking block %zu of %zu\\n\",\n\t\t\t\t(size_t)ldev_info->cc_lba,\n\t\t\t\t(size_t)ldev_info->cfg_devsize);\n\telse\n\t\treturn snprintf(buf, 32, \"not checking\\n\");\n}\n\nstatic ssize_t consistency_check_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrs_hba *cs = shost_priv(sdev->host);\n\tstruct myrs_ldev_info *ldev_info;\n\tstruct myrs_cmdblk *cmd_blk;\n\tunion myrs_cmd_mbox *mbox;\n\tunsigned short ldev_num;\n\tunsigned char status;\n\tint check, ret;\n\n\tif (sdev->channel < cs->ctlr_info->physchan_present)\n\t\treturn -EINVAL;\n\n\tldev_info = sdev->hostdata;\n\tif (!ldev_info)\n\t\treturn -ENXIO;\n\tldev_num = ldev_info->ldev_num;\n\n\tret = kstrtoint(buf, 0, &check);\n\tif (ret)\n\t\treturn ret;\n\n\tstatus = myrs_get_ldev_info(cs, ldev_num, ldev_info);\n\tif (status != MYRS_STATUS_SUCCESS) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Failed to get device information, status 0x%02x\\n\",\n\t\t\t    status);\n\t\treturn -EIO;\n\t}\n\tif (check && ldev_info->cc_active) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Consistency Check Not Initiated; \"\n\t\t\t    \"already in progress\\n\");\n\t\treturn -EALREADY;\n\t}\n\tif (!check && !ldev_info->cc_active) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Consistency Check Not Cancelled; \"\n\t\t\t    \"check not in progress\\n\");\n\t\treturn count;\n\t}\n\n\tmutex_lock(&cs->dcmd_mutex);\n\tcmd_blk = &cs->dcmd_blk;\n\tmyrs_reset_cmd(cmd_blk);\n\tmbox = &cmd_blk->mbox;\n\tmbox->common.opcode = MYRS_CMD_OP_IOCTL;\n\tmbox->common.id = MYRS_DCMD_TAG;\n\tmbox->common.control.dma_ctrl_to_host = true;\n\tmbox->common.control.no_autosense = true;\n\tif (check) {\n\t\tmbox->cc.ldev.ldev_num = ldev_num;\n\t\tmbox->cc.ioctl_opcode = MYRS_IOCTL_CC_START;\n\t\tmbox->cc.restore_consistency = true;\n\t\tmbox->cc.initialized_area_only = false;\n\t} else {\n\t\tmbox->cc.ldev.ldev_num = ldev_num;\n\t\tmbox->cc.ioctl_opcode = MYRS_IOCTL_CC_STOP;\n\t}\n\tmyrs_exec_cmd(cs, cmd_blk);\n\tstatus = cmd_blk->status;\n\tmutex_unlock(&cs->dcmd_mutex);\n\tif (status != MYRS_STATUS_SUCCESS) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Consistency Check Not %s, status 0x%02x\\n\",\n\t\t\t    check ? \"Initiated\" : \"Cancelled\", status);\n\t\tret = -EIO;\n\t} else {\n\t\tsdev_printk(KERN_INFO, sdev, \"Consistency Check %s\\n\",\n\t\t\t    check ? \"Initiated\" : \"Cancelled\");\n\t\tret = count;\n\t}\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RW(consistency_check);\n\nstatic struct attribute *myrs_sdev_attrs[] = {\n\t&dev_attr_consistency_check.attr,\n\t&dev_attr_rebuild.attr,\n\t&dev_attr_raid_state.attr,\n\t&dev_attr_raid_level.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(myrs_sdev);\n\nstatic ssize_t serial_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct myrs_hba *cs = shost_priv(shost);\n\tchar serial[17];\n\n\tmemcpy(serial, cs->ctlr_info->serial_number, 16);\n\tserial[16] = '\\0';\n\treturn snprintf(buf, 16, \"%s\\n\", serial);\n}\nstatic DEVICE_ATTR_RO(serial);\n\nstatic ssize_t ctlr_num_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct myrs_hba *cs = shost_priv(shost);\n\n\treturn snprintf(buf, 20, \"%d\\n\", cs->host->host_no);\n}\nstatic DEVICE_ATTR_RO(ctlr_num);\n\nstatic struct myrs_cpu_type_tbl {\n\tenum myrs_cpu_type type;\n\tchar *name;\n} myrs_cpu_type_names[] = {\n\t{ MYRS_CPUTYPE_i960CA, \"i960CA\" },\n\t{ MYRS_CPUTYPE_i960RD, \"i960RD\" },\n\t{ MYRS_CPUTYPE_i960RN, \"i960RN\" },\n\t{ MYRS_CPUTYPE_i960RP, \"i960RP\" },\n\t{ MYRS_CPUTYPE_NorthBay, \"NorthBay\" },\n\t{ MYRS_CPUTYPE_StrongArm, \"StrongARM\" },\n\t{ MYRS_CPUTYPE_i960RM, \"i960RM\" },\n};\n\nstatic ssize_t processor_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct myrs_hba *cs = shost_priv(shost);\n\tstruct myrs_cpu_type_tbl *tbl;\n\tconst char *first_processor = NULL;\n\tconst char *second_processor = NULL;\n\tstruct myrs_ctlr_info *info = cs->ctlr_info;\n\tssize_t ret;\n\tint i;\n\n\tif (info->cpu[0].cpu_count) {\n\t\ttbl = myrs_cpu_type_names;\n\t\tfor (i = 0; i < ARRAY_SIZE(myrs_cpu_type_names); i++) {\n\t\t\tif (tbl[i].type == info->cpu[0].cpu_type) {\n\t\t\t\tfirst_processor = tbl[i].name;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (info->cpu[1].cpu_count) {\n\t\ttbl = myrs_cpu_type_names;\n\t\tfor (i = 0; i < ARRAY_SIZE(myrs_cpu_type_names); i++) {\n\t\t\tif (tbl[i].type == info->cpu[1].cpu_type) {\n\t\t\t\tsecond_processor = tbl[i].name;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (first_processor && second_processor)\n\t\tret = snprintf(buf, 64, \"1: %s (%s, %d cpus)\\n\"\n\t\t\t       \"2: %s (%s, %d cpus)\\n\",\n\t\t\t       info->cpu[0].cpu_name,\n\t\t\t       first_processor, info->cpu[0].cpu_count,\n\t\t\t       info->cpu[1].cpu_name,\n\t\t\t       second_processor, info->cpu[1].cpu_count);\n\telse if (first_processor && !second_processor)\n\t\tret = snprintf(buf, 64, \"1: %s (%s, %d cpus)\\n2: absent\\n\",\n\t\t\t       info->cpu[0].cpu_name,\n\t\t\t       first_processor, info->cpu[0].cpu_count);\n\telse if (!first_processor && second_processor)\n\t\tret = snprintf(buf, 64, \"1: absent\\n2: %s (%s, %d cpus)\\n\",\n\t\t\t       info->cpu[1].cpu_name,\n\t\t\t       second_processor, info->cpu[1].cpu_count);\n\telse\n\t\tret = snprintf(buf, 64, \"1: absent\\n2: absent\\n\");\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(processor);\n\nstatic ssize_t model_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct myrs_hba *cs = shost_priv(shost);\n\n\treturn snprintf(buf, 28, \"%s\\n\", cs->model_name);\n}\nstatic DEVICE_ATTR_RO(model);\n\nstatic ssize_t ctlr_type_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct myrs_hba *cs = shost_priv(shost);\n\n\treturn snprintf(buf, 4, \"%d\\n\", cs->ctlr_info->ctlr_type);\n}\nstatic DEVICE_ATTR_RO(ctlr_type);\n\nstatic ssize_t cache_size_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct myrs_hba *cs = shost_priv(shost);\n\n\treturn snprintf(buf, 8, \"%d MB\\n\", cs->ctlr_info->cache_size_mb);\n}\nstatic DEVICE_ATTR_RO(cache_size);\n\nstatic ssize_t firmware_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct myrs_hba *cs = shost_priv(shost);\n\n\treturn snprintf(buf, 16, \"%d.%02d-%02d\\n\",\n\t\t\tcs->ctlr_info->fw_major_version,\n\t\t\tcs->ctlr_info->fw_minor_version,\n\t\t\tcs->ctlr_info->fw_turn_number);\n}\nstatic DEVICE_ATTR_RO(firmware);\n\nstatic ssize_t discovery_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct myrs_hba *cs = shost_priv(shost);\n\tstruct myrs_cmdblk *cmd_blk;\n\tunion myrs_cmd_mbox *mbox;\n\tunsigned char status;\n\n\tmutex_lock(&cs->dcmd_mutex);\n\tcmd_blk = &cs->dcmd_blk;\n\tmyrs_reset_cmd(cmd_blk);\n\tmbox = &cmd_blk->mbox;\n\tmbox->common.opcode = MYRS_CMD_OP_IOCTL;\n\tmbox->common.id = MYRS_DCMD_TAG;\n\tmbox->common.control.dma_ctrl_to_host = true;\n\tmbox->common.control.no_autosense = true;\n\tmbox->common.ioctl_opcode = MYRS_IOCTL_START_DISCOVERY;\n\tmyrs_exec_cmd(cs, cmd_blk);\n\tstatus = cmd_blk->status;\n\tmutex_unlock(&cs->dcmd_mutex);\n\tif (status != MYRS_STATUS_SUCCESS) {\n\t\tshost_printk(KERN_INFO, shost,\n\t\t\t     \"Discovery Not Initiated, status %02X\\n\",\n\t\t\t     status);\n\t\treturn -EINVAL;\n\t}\n\tshost_printk(KERN_INFO, shost, \"Discovery Initiated\\n\");\n\tcs->next_evseq = 0;\n\tcs->needs_update = true;\n\tqueue_delayed_work(cs->work_q, &cs->monitor_work, 1);\n\tflush_delayed_work(&cs->monitor_work);\n\tshost_printk(KERN_INFO, shost, \"Discovery Completed\\n\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(discovery);\n\nstatic ssize_t flush_cache_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct myrs_hba *cs = shost_priv(shost);\n\tunsigned char status;\n\n\tstatus = myrs_dev_op(cs, MYRS_IOCTL_FLUSH_DEVICE_DATA,\n\t\t\t     MYRS_RAID_CONTROLLER);\n\tif (status == MYRS_STATUS_SUCCESS) {\n\t\tshost_printk(KERN_INFO, shost, \"Cache Flush Completed\\n\");\n\t\treturn count;\n\t}\n\tshost_printk(KERN_INFO, shost,\n\t\t     \"Cache Flush failed, status 0x%02x\\n\", status);\n\treturn -EIO;\n}\nstatic DEVICE_ATTR_WO(flush_cache);\n\nstatic ssize_t disable_enclosure_messages_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct myrs_hba *cs = shost_priv(shost);\n\n\treturn snprintf(buf, 3, \"%d\\n\", cs->disable_enc_msg);\n}\n\nstatic ssize_t disable_enclosure_messages_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrs_hba *cs = shost_priv(sdev->host);\n\tint value, ret;\n\n\tret = kstrtoint(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (value > 2)\n\t\treturn -EINVAL;\n\n\tcs->disable_enc_msg = value;\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(disable_enclosure_messages);\n\nstatic struct attribute *myrs_shost_attrs[] = {\n\t&dev_attr_serial.attr,\n\t&dev_attr_ctlr_num.attr,\n\t&dev_attr_processor.attr,\n\t&dev_attr_model.attr,\n\t&dev_attr_ctlr_type.attr,\n\t&dev_attr_cache_size.attr,\n\t&dev_attr_firmware.attr,\n\t&dev_attr_discovery.attr,\n\t&dev_attr_flush_cache.attr,\n\t&dev_attr_disable_enclosure_messages.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(myrs_shost);\n\n \nstatic int myrs_host_reset(struct scsi_cmnd *scmd)\n{\n\tstruct Scsi_Host *shost = scmd->device->host;\n\tstruct myrs_hba *cs = shost_priv(shost);\n\n\tcs->reset(cs->io_base);\n\treturn SUCCESS;\n}\n\nstatic void myrs_mode_sense(struct myrs_hba *cs, struct scsi_cmnd *scmd,\n\t\tstruct myrs_ldev_info *ldev_info)\n{\n\tunsigned char modes[32], *mode_pg;\n\tbool dbd;\n\tsize_t mode_len;\n\n\tdbd = (scmd->cmnd[1] & 0x08) == 0x08;\n\tif (dbd) {\n\t\tmode_len = 24;\n\t\tmode_pg = &modes[4];\n\t} else {\n\t\tmode_len = 32;\n\t\tmode_pg = &modes[12];\n\t}\n\tmemset(modes, 0, sizeof(modes));\n\tmodes[0] = mode_len - 1;\n\tmodes[2] = 0x10;  \n\tif (ldev_info->ldev_control.wce == MYRS_LOGICALDEVICE_RO)\n\t\tmodes[2] |= 0x80;\n\tif (!dbd) {\n\t\tunsigned char *block_desc = &modes[4];\n\n\t\tmodes[3] = 8;\n\t\tput_unaligned_be32(ldev_info->cfg_devsize, &block_desc[0]);\n\t\tput_unaligned_be32(ldev_info->devsize_bytes, &block_desc[5]);\n\t}\n\tmode_pg[0] = 0x08;\n\tmode_pg[1] = 0x12;\n\tif (ldev_info->ldev_control.rce == MYRS_READCACHE_DISABLED)\n\t\tmode_pg[2] |= 0x01;\n\tif (ldev_info->ldev_control.wce == MYRS_WRITECACHE_ENABLED ||\n\t    ldev_info->ldev_control.wce == MYRS_INTELLIGENT_WRITECACHE_ENABLED)\n\t\tmode_pg[2] |= 0x04;\n\tif (ldev_info->cacheline_size) {\n\t\tmode_pg[2] |= 0x08;\n\t\tput_unaligned_be16(1 << ldev_info->cacheline_size,\n\t\t\t\t   &mode_pg[14]);\n\t}\n\n\tscsi_sg_copy_from_buffer(scmd, modes, mode_len);\n}\n\nstatic int myrs_queuecommand(struct Scsi_Host *shost,\n\t\tstruct scsi_cmnd *scmd)\n{\n\tstruct request *rq = scsi_cmd_to_rq(scmd);\n\tstruct myrs_hba *cs = shost_priv(shost);\n\tstruct myrs_cmdblk *cmd_blk = scsi_cmd_priv(scmd);\n\tunion myrs_cmd_mbox *mbox = &cmd_blk->mbox;\n\tstruct scsi_device *sdev = scmd->device;\n\tunion myrs_sgl *hw_sge;\n\tdma_addr_t sense_addr;\n\tstruct scatterlist *sgl;\n\tunsigned long flags, timeout;\n\tint nsge;\n\n\tif (!scmd->device->hostdata) {\n\t\tscmd->result = (DID_NO_CONNECT << 16);\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tswitch (scmd->cmnd[0]) {\n\tcase REPORT_LUNS:\n\t\tscsi_build_sense(scmd, 0, ILLEGAL_REQUEST, 0x20, 0x0);\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\tcase MODE_SENSE:\n\t\tif (scmd->device->channel >= cs->ctlr_info->physchan_present) {\n\t\t\tstruct myrs_ldev_info *ldev_info = sdev->hostdata;\n\n\t\t\tif ((scmd->cmnd[2] & 0x3F) != 0x3F &&\n\t\t\t    (scmd->cmnd[2] & 0x3F) != 0x08) {\n\t\t\t\t \n\t\t\t\tscsi_build_sense(scmd, 0, ILLEGAL_REQUEST, 0x24, 0);\n\t\t\t} else {\n\t\t\t\tmyrs_mode_sense(cs, scmd, ldev_info);\n\t\t\t\tscmd->result = (DID_OK << 16);\n\t\t\t}\n\t\t\tscsi_done(scmd);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tmyrs_reset_cmd(cmd_blk);\n\tcmd_blk->sense = dma_pool_alloc(cs->sense_pool, GFP_ATOMIC,\n\t\t\t\t\t&sense_addr);\n\tif (!cmd_blk->sense)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\tcmd_blk->sense_addr = sense_addr;\n\n\ttimeout = rq->timeout;\n\tif (scmd->cmd_len <= 10) {\n\t\tif (scmd->device->channel >= cs->ctlr_info->physchan_present) {\n\t\t\tstruct myrs_ldev_info *ldev_info = sdev->hostdata;\n\n\t\t\tmbox->SCSI_10.opcode = MYRS_CMD_OP_SCSI_10;\n\t\t\tmbox->SCSI_10.pdev.lun = ldev_info->lun;\n\t\t\tmbox->SCSI_10.pdev.target = ldev_info->target;\n\t\t\tmbox->SCSI_10.pdev.channel = ldev_info->channel;\n\t\t\tmbox->SCSI_10.pdev.ctlr = 0;\n\t\t} else {\n\t\t\tmbox->SCSI_10.opcode = MYRS_CMD_OP_SCSI_10_PASSTHRU;\n\t\t\tmbox->SCSI_10.pdev.lun = sdev->lun;\n\t\t\tmbox->SCSI_10.pdev.target = sdev->id;\n\t\t\tmbox->SCSI_10.pdev.channel = sdev->channel;\n\t\t}\n\t\tmbox->SCSI_10.id = rq->tag + 3;\n\t\tmbox->SCSI_10.control.dma_ctrl_to_host =\n\t\t\t(scmd->sc_data_direction == DMA_FROM_DEVICE);\n\t\tif (rq->cmd_flags & REQ_FUA)\n\t\t\tmbox->SCSI_10.control.fua = true;\n\t\tmbox->SCSI_10.dma_size = scsi_bufflen(scmd);\n\t\tmbox->SCSI_10.sense_addr = cmd_blk->sense_addr;\n\t\tmbox->SCSI_10.sense_len = MYRS_SENSE_SIZE;\n\t\tmbox->SCSI_10.cdb_len = scmd->cmd_len;\n\t\tif (timeout > 60) {\n\t\t\tmbox->SCSI_10.tmo.tmo_scale = MYRS_TMO_SCALE_MINUTES;\n\t\t\tmbox->SCSI_10.tmo.tmo_val = timeout / 60;\n\t\t} else {\n\t\t\tmbox->SCSI_10.tmo.tmo_scale = MYRS_TMO_SCALE_SECONDS;\n\t\t\tmbox->SCSI_10.tmo.tmo_val = timeout;\n\t\t}\n\t\tmemcpy(&mbox->SCSI_10.cdb, scmd->cmnd, scmd->cmd_len);\n\t\thw_sge = &mbox->SCSI_10.dma_addr;\n\t\tcmd_blk->dcdb = NULL;\n\t} else {\n\t\tdma_addr_t dcdb_dma;\n\n\t\tcmd_blk->dcdb = dma_pool_alloc(cs->dcdb_pool, GFP_ATOMIC,\n\t\t\t\t\t       &dcdb_dma);\n\t\tif (!cmd_blk->dcdb) {\n\t\t\tdma_pool_free(cs->sense_pool, cmd_blk->sense,\n\t\t\t\t      cmd_blk->sense_addr);\n\t\t\tcmd_blk->sense = NULL;\n\t\t\tcmd_blk->sense_addr = 0;\n\t\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t\t}\n\t\tcmd_blk->dcdb_dma = dcdb_dma;\n\t\tif (scmd->device->channel >= cs->ctlr_info->physchan_present) {\n\t\t\tstruct myrs_ldev_info *ldev_info = sdev->hostdata;\n\n\t\t\tmbox->SCSI_255.opcode = MYRS_CMD_OP_SCSI_256;\n\t\t\tmbox->SCSI_255.pdev.lun = ldev_info->lun;\n\t\t\tmbox->SCSI_255.pdev.target = ldev_info->target;\n\t\t\tmbox->SCSI_255.pdev.channel = ldev_info->channel;\n\t\t\tmbox->SCSI_255.pdev.ctlr = 0;\n\t\t} else {\n\t\t\tmbox->SCSI_255.opcode = MYRS_CMD_OP_SCSI_255_PASSTHRU;\n\t\t\tmbox->SCSI_255.pdev.lun = sdev->lun;\n\t\t\tmbox->SCSI_255.pdev.target = sdev->id;\n\t\t\tmbox->SCSI_255.pdev.channel = sdev->channel;\n\t\t}\n\t\tmbox->SCSI_255.id = rq->tag + 3;\n\t\tmbox->SCSI_255.control.dma_ctrl_to_host =\n\t\t\t(scmd->sc_data_direction == DMA_FROM_DEVICE);\n\t\tif (rq->cmd_flags & REQ_FUA)\n\t\t\tmbox->SCSI_255.control.fua = true;\n\t\tmbox->SCSI_255.dma_size = scsi_bufflen(scmd);\n\t\tmbox->SCSI_255.sense_addr = cmd_blk->sense_addr;\n\t\tmbox->SCSI_255.sense_len = MYRS_SENSE_SIZE;\n\t\tmbox->SCSI_255.cdb_len = scmd->cmd_len;\n\t\tmbox->SCSI_255.cdb_addr = cmd_blk->dcdb_dma;\n\t\tif (timeout > 60) {\n\t\t\tmbox->SCSI_255.tmo.tmo_scale = MYRS_TMO_SCALE_MINUTES;\n\t\t\tmbox->SCSI_255.tmo.tmo_val = timeout / 60;\n\t\t} else {\n\t\t\tmbox->SCSI_255.tmo.tmo_scale = MYRS_TMO_SCALE_SECONDS;\n\t\t\tmbox->SCSI_255.tmo.tmo_val = timeout;\n\t\t}\n\t\tmemcpy(cmd_blk->dcdb, scmd->cmnd, scmd->cmd_len);\n\t\thw_sge = &mbox->SCSI_255.dma_addr;\n\t}\n\tif (scmd->sc_data_direction == DMA_NONE)\n\t\tgoto submit;\n\tnsge = scsi_dma_map(scmd);\n\tif (nsge == 1) {\n\t\tsgl = scsi_sglist(scmd);\n\t\thw_sge->sge[0].sge_addr = (u64)sg_dma_address(sgl);\n\t\thw_sge->sge[0].sge_count = (u64)sg_dma_len(sgl);\n\t} else {\n\t\tstruct myrs_sge *hw_sgl;\n\t\tdma_addr_t hw_sgl_addr;\n\t\tint i;\n\n\t\tif (nsge > 2) {\n\t\t\thw_sgl = dma_pool_alloc(cs->sg_pool, GFP_ATOMIC,\n\t\t\t\t\t\t&hw_sgl_addr);\n\t\t\tif (WARN_ON(!hw_sgl)) {\n\t\t\t\tif (cmd_blk->dcdb) {\n\t\t\t\t\tdma_pool_free(cs->dcdb_pool,\n\t\t\t\t\t\t      cmd_blk->dcdb,\n\t\t\t\t\t\t      cmd_blk->dcdb_dma);\n\t\t\t\t\tcmd_blk->dcdb = NULL;\n\t\t\t\t\tcmd_blk->dcdb_dma = 0;\n\t\t\t\t}\n\t\t\t\tdma_pool_free(cs->sense_pool,\n\t\t\t\t\t      cmd_blk->sense,\n\t\t\t\t\t      cmd_blk->sense_addr);\n\t\t\t\tcmd_blk->sense = NULL;\n\t\t\t\tcmd_blk->sense_addr = 0;\n\t\t\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t\t\t}\n\t\t\tcmd_blk->sgl = hw_sgl;\n\t\t\tcmd_blk->sgl_addr = hw_sgl_addr;\n\t\t\tif (scmd->cmd_len <= 10)\n\t\t\t\tmbox->SCSI_10.control.add_sge_mem = true;\n\t\t\telse\n\t\t\t\tmbox->SCSI_255.control.add_sge_mem = true;\n\t\t\thw_sge->ext.sge0_len = nsge;\n\t\t\thw_sge->ext.sge0_addr = cmd_blk->sgl_addr;\n\t\t} else\n\t\t\thw_sgl = hw_sge->sge;\n\n\t\tscsi_for_each_sg(scmd, sgl, nsge, i) {\n\t\t\tif (WARN_ON(!hw_sgl)) {\n\t\t\t\tscsi_dma_unmap(scmd);\n\t\t\t\tscmd->result = (DID_ERROR << 16);\n\t\t\t\tscsi_done(scmd);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\thw_sgl->sge_addr = (u64)sg_dma_address(sgl);\n\t\t\thw_sgl->sge_count = (u64)sg_dma_len(sgl);\n\t\t\thw_sgl++;\n\t\t}\n\t}\nsubmit:\n\tspin_lock_irqsave(&cs->queue_lock, flags);\n\tmyrs_qcmd(cs, cmd_blk);\n\tspin_unlock_irqrestore(&cs->queue_lock, flags);\n\n\treturn 0;\n}\n\nstatic unsigned short myrs_translate_ldev(struct myrs_hba *cs,\n\t\tstruct scsi_device *sdev)\n{\n\tunsigned short ldev_num;\n\tunsigned int chan_offset =\n\t\tsdev->channel - cs->ctlr_info->physchan_present;\n\n\tldev_num = sdev->id + chan_offset * sdev->host->max_id;\n\n\treturn ldev_num;\n}\n\nstatic int myrs_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct myrs_hba *cs = shost_priv(sdev->host);\n\tunsigned char status;\n\n\tif (sdev->channel > sdev->host->max_channel)\n\t\treturn 0;\n\n\tif (sdev->channel >= cs->ctlr_info->physchan_present) {\n\t\tstruct myrs_ldev_info *ldev_info;\n\t\tunsigned short ldev_num;\n\n\t\tif (sdev->lun > 0)\n\t\t\treturn -ENXIO;\n\n\t\tldev_num = myrs_translate_ldev(cs, sdev);\n\n\t\tldev_info = kzalloc(sizeof(*ldev_info), GFP_KERNEL);\n\t\tif (!ldev_info)\n\t\t\treturn -ENOMEM;\n\n\t\tstatus = myrs_get_ldev_info(cs, ldev_num, ldev_info);\n\t\tif (status != MYRS_STATUS_SUCCESS) {\n\t\t\tsdev->hostdata = NULL;\n\t\t\tkfree(ldev_info);\n\t\t} else {\n\t\t\tenum raid_level level;\n\n\t\t\tdev_dbg(&sdev->sdev_gendev,\n\t\t\t\t\"Logical device mapping %d:%d:%d -> %d\\n\",\n\t\t\t\tldev_info->channel, ldev_info->target,\n\t\t\t\tldev_info->lun, ldev_info->ldev_num);\n\n\t\t\tsdev->hostdata = ldev_info;\n\t\t\tswitch (ldev_info->raid_level) {\n\t\t\tcase MYRS_RAID_LEVEL0:\n\t\t\t\tlevel = RAID_LEVEL_LINEAR;\n\t\t\t\tbreak;\n\t\t\tcase MYRS_RAID_LEVEL1:\n\t\t\t\tlevel = RAID_LEVEL_1;\n\t\t\t\tbreak;\n\t\t\tcase MYRS_RAID_LEVEL3:\n\t\t\tcase MYRS_RAID_LEVEL3F:\n\t\t\tcase MYRS_RAID_LEVEL3L:\n\t\t\t\tlevel = RAID_LEVEL_3;\n\t\t\t\tbreak;\n\t\t\tcase MYRS_RAID_LEVEL5:\n\t\t\tcase MYRS_RAID_LEVEL5L:\n\t\t\t\tlevel = RAID_LEVEL_5;\n\t\t\t\tbreak;\n\t\t\tcase MYRS_RAID_LEVEL6:\n\t\t\t\tlevel = RAID_LEVEL_6;\n\t\t\t\tbreak;\n\t\t\tcase MYRS_RAID_LEVELE:\n\t\t\tcase MYRS_RAID_NEWSPAN:\n\t\t\tcase MYRS_RAID_SPAN:\n\t\t\t\tlevel = RAID_LEVEL_LINEAR;\n\t\t\t\tbreak;\n\t\t\tcase MYRS_RAID_JBOD:\n\t\t\t\tlevel = RAID_LEVEL_JBOD;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlevel = RAID_LEVEL_UNKNOWN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\traid_set_level(myrs_raid_template,\n\t\t\t\t       &sdev->sdev_gendev, level);\n\t\t\tif (ldev_info->dev_state != MYRS_DEVICE_ONLINE) {\n\t\t\t\tconst char *name;\n\n\t\t\t\tname = myrs_devstate_name(ldev_info->dev_state);\n\t\t\t\tsdev_printk(KERN_DEBUG, sdev,\n\t\t\t\t\t    \"logical device in state %s\\n\",\n\t\t\t\t\t    name ? name : \"Invalid\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct myrs_pdev_info *pdev_info;\n\n\t\tpdev_info = kzalloc(sizeof(*pdev_info), GFP_KERNEL);\n\t\tif (!pdev_info)\n\t\t\treturn -ENOMEM;\n\n\t\tstatus = myrs_get_pdev_info(cs, sdev->channel,\n\t\t\t\t\t    sdev->id, sdev->lun,\n\t\t\t\t\t    pdev_info);\n\t\tif (status != MYRS_STATUS_SUCCESS) {\n\t\t\tsdev->hostdata = NULL;\n\t\t\tkfree(pdev_info);\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tsdev->hostdata = pdev_info;\n\t}\n\treturn 0;\n}\n\nstatic int myrs_slave_configure(struct scsi_device *sdev)\n{\n\tstruct myrs_hba *cs = shost_priv(sdev->host);\n\tstruct myrs_ldev_info *ldev_info;\n\n\tif (sdev->channel > sdev->host->max_channel)\n\t\treturn -ENXIO;\n\n\tif (sdev->channel < cs->ctlr_info->physchan_present) {\n\t\t \n\t\tif (sdev->type == TYPE_RAID)\n\t\t\treturn -ENXIO;\n\t\tsdev->no_uld_attach = 1;\n\t\treturn 0;\n\t}\n\tif (sdev->lun != 0)\n\t\treturn -ENXIO;\n\n\tldev_info = sdev->hostdata;\n\tif (!ldev_info)\n\t\treturn -ENXIO;\n\tif (ldev_info->ldev_control.wce == MYRS_WRITECACHE_ENABLED ||\n\t    ldev_info->ldev_control.wce == MYRS_INTELLIGENT_WRITECACHE_ENABLED)\n\t\tsdev->wce_default_on = 1;\n\tsdev->tagged_supported = 1;\n\treturn 0;\n}\n\nstatic void myrs_slave_destroy(struct scsi_device *sdev)\n{\n\tkfree(sdev->hostdata);\n}\n\nstatic const struct scsi_host_template myrs_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"DAC960\",\n\t.proc_name\t\t= \"myrs\",\n\t.queuecommand\t\t= myrs_queuecommand,\n\t.eh_host_reset_handler\t= myrs_host_reset,\n\t.slave_alloc\t\t= myrs_slave_alloc,\n\t.slave_configure\t= myrs_slave_configure,\n\t.slave_destroy\t\t= myrs_slave_destroy,\n\t.cmd_size\t\t= sizeof(struct myrs_cmdblk),\n\t.shost_groups\t\t= myrs_shost_groups,\n\t.sdev_groups\t\t= myrs_sdev_groups,\n\t.this_id\t\t= -1,\n};\n\nstatic struct myrs_hba *myrs_alloc_host(struct pci_dev *pdev,\n\t\tconst struct pci_device_id *entry)\n{\n\tstruct Scsi_Host *shost;\n\tstruct myrs_hba *cs;\n\n\tshost = scsi_host_alloc(&myrs_template, sizeof(struct myrs_hba));\n\tif (!shost)\n\t\treturn NULL;\n\n\tshost->max_cmd_len = 16;\n\tshost->max_lun = 256;\n\tcs = shost_priv(shost);\n\tmutex_init(&cs->dcmd_mutex);\n\tmutex_init(&cs->cinfo_mutex);\n\tcs->host = shost;\n\n\treturn cs;\n}\n\n \n\n \nstatic int\nmyrs_is_raid(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrs_hba *cs = shost_priv(sdev->host);\n\n\treturn (sdev->channel >= cs->ctlr_info->physchan_present) ? 1 : 0;\n}\n\n \nstatic void\nmyrs_get_resync(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrs_hba *cs = shost_priv(sdev->host);\n\tstruct myrs_ldev_info *ldev_info = sdev->hostdata;\n\tu64 percent_complete = 0;\n\n\tif (sdev->channel < cs->ctlr_info->physchan_present || !ldev_info)\n\t\treturn;\n\tif (ldev_info->rbld_active) {\n\t\tunsigned short ldev_num = ldev_info->ldev_num;\n\n\t\tmyrs_get_ldev_info(cs, ldev_num, ldev_info);\n\t\tpercent_complete = ldev_info->rbld_lba * 100;\n\t\tdo_div(percent_complete, ldev_info->cfg_devsize);\n\t}\n\traid_set_resync(myrs_raid_template, dev, percent_complete);\n}\n\n \nstatic void\nmyrs_get_state(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrs_hba *cs = shost_priv(sdev->host);\n\tstruct myrs_ldev_info *ldev_info = sdev->hostdata;\n\tenum raid_state state = RAID_STATE_UNKNOWN;\n\n\tif (sdev->channel < cs->ctlr_info->physchan_present || !ldev_info)\n\t\tstate = RAID_STATE_UNKNOWN;\n\telse {\n\t\tswitch (ldev_info->dev_state) {\n\t\tcase MYRS_DEVICE_ONLINE:\n\t\t\tstate = RAID_STATE_ACTIVE;\n\t\t\tbreak;\n\t\tcase MYRS_DEVICE_SUSPECTED_CRITICAL:\n\t\tcase MYRS_DEVICE_CRITICAL:\n\t\t\tstate = RAID_STATE_DEGRADED;\n\t\t\tbreak;\n\t\tcase MYRS_DEVICE_REBUILD:\n\t\t\tstate = RAID_STATE_RESYNCING;\n\t\t\tbreak;\n\t\tcase MYRS_DEVICE_UNCONFIGURED:\n\t\tcase MYRS_DEVICE_INVALID_STATE:\n\t\t\tstate = RAID_STATE_UNKNOWN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstate = RAID_STATE_OFFLINE;\n\t\t}\n\t}\n\traid_set_state(myrs_raid_template, dev, state);\n}\n\nstatic struct raid_function_template myrs_raid_functions = {\n\t.cookie\t\t= &myrs_template,\n\t.is_raid\t= myrs_is_raid,\n\t.get_resync\t= myrs_get_resync,\n\t.get_state\t= myrs_get_state,\n};\n\n \nstatic void myrs_flush_cache(struct myrs_hba *cs)\n{\n\tmyrs_dev_op(cs, MYRS_IOCTL_FLUSH_DEVICE_DATA, MYRS_RAID_CONTROLLER);\n}\n\nstatic void myrs_handle_scsi(struct myrs_hba *cs, struct myrs_cmdblk *cmd_blk,\n\t\tstruct scsi_cmnd *scmd)\n{\n\tunsigned char status;\n\n\tif (!cmd_blk)\n\t\treturn;\n\n\tscsi_dma_unmap(scmd);\n\tstatus = cmd_blk->status;\n\tif (cmd_blk->sense) {\n\t\tif (status == MYRS_STATUS_FAILED && cmd_blk->sense_len) {\n\t\t\tunsigned int sense_len = SCSI_SENSE_BUFFERSIZE;\n\n\t\t\tif (sense_len > cmd_blk->sense_len)\n\t\t\t\tsense_len = cmd_blk->sense_len;\n\t\t\tmemcpy(scmd->sense_buffer, cmd_blk->sense, sense_len);\n\t\t}\n\t\tdma_pool_free(cs->sense_pool, cmd_blk->sense,\n\t\t\t      cmd_blk->sense_addr);\n\t\tcmd_blk->sense = NULL;\n\t\tcmd_blk->sense_addr = 0;\n\t}\n\tif (cmd_blk->dcdb) {\n\t\tdma_pool_free(cs->dcdb_pool, cmd_blk->dcdb,\n\t\t\t      cmd_blk->dcdb_dma);\n\t\tcmd_blk->dcdb = NULL;\n\t\tcmd_blk->dcdb_dma = 0;\n\t}\n\tif (cmd_blk->sgl) {\n\t\tdma_pool_free(cs->sg_pool, cmd_blk->sgl,\n\t\t\t      cmd_blk->sgl_addr);\n\t\tcmd_blk->sgl = NULL;\n\t\tcmd_blk->sgl_addr = 0;\n\t}\n\tif (cmd_blk->residual)\n\t\tscsi_set_resid(scmd, cmd_blk->residual);\n\tif (status == MYRS_STATUS_DEVICE_NON_RESPONSIVE ||\n\t    status == MYRS_STATUS_DEVICE_NON_RESPONSIVE2)\n\t\tscmd->result = (DID_BAD_TARGET << 16);\n\telse\n\t\tscmd->result = (DID_OK << 16) | status;\n\tscsi_done(scmd);\n}\n\nstatic void myrs_handle_cmdblk(struct myrs_hba *cs, struct myrs_cmdblk *cmd_blk)\n{\n\tif (!cmd_blk)\n\t\treturn;\n\n\tif (cmd_blk->complete) {\n\t\tcomplete(cmd_blk->complete);\n\t\tcmd_blk->complete = NULL;\n\t}\n}\n\nstatic void myrs_monitor(struct work_struct *work)\n{\n\tstruct myrs_hba *cs = container_of(work, struct myrs_hba,\n\t\t\t\t\t   monitor_work.work);\n\tstruct Scsi_Host *shost = cs->host;\n\tstruct myrs_ctlr_info *info = cs->ctlr_info;\n\tunsigned int epoch = cs->fwstat_buf->epoch;\n\tunsigned long interval = MYRS_PRIMARY_MONITOR_INTERVAL;\n\tunsigned char status;\n\n\tdev_dbg(&shost->shost_gendev, \"monitor tick\\n\");\n\n\tstatus = myrs_get_fwstatus(cs);\n\n\tif (cs->needs_update) {\n\t\tcs->needs_update = false;\n\t\tmutex_lock(&cs->cinfo_mutex);\n\t\tstatus = myrs_get_ctlr_info(cs);\n\t\tmutex_unlock(&cs->cinfo_mutex);\n\t}\n\tif (cs->fwstat_buf->next_evseq - cs->next_evseq > 0) {\n\t\tstatus = myrs_get_event(cs, cs->next_evseq,\n\t\t\t\t\tcs->event_buf);\n\t\tif (status == MYRS_STATUS_SUCCESS) {\n\t\t\tmyrs_log_event(cs, cs->event_buf);\n\t\t\tcs->next_evseq++;\n\t\t\tinterval = 1;\n\t\t}\n\t}\n\n\tif (time_after(jiffies, cs->secondary_monitor_time\n\t\t       + MYRS_SECONDARY_MONITOR_INTERVAL))\n\t\tcs->secondary_monitor_time = jiffies;\n\n\tif (info->bg_init_active +\n\t    info->ldev_init_active +\n\t    info->pdev_init_active +\n\t    info->cc_active +\n\t    info->rbld_active +\n\t    info->exp_active != 0) {\n\t\tstruct scsi_device *sdev;\n\n\t\tshost_for_each_device(sdev, shost) {\n\t\t\tstruct myrs_ldev_info *ldev_info;\n\t\t\tint ldev_num;\n\n\t\t\tif (sdev->channel < info->physchan_present)\n\t\t\t\tcontinue;\n\t\t\tldev_info = sdev->hostdata;\n\t\t\tif (!ldev_info)\n\t\t\t\tcontinue;\n\t\t\tldev_num = ldev_info->ldev_num;\n\t\t\tmyrs_get_ldev_info(cs, ldev_num, ldev_info);\n\t\t}\n\t\tcs->needs_update = true;\n\t}\n\tif (epoch == cs->epoch &&\n\t    cs->fwstat_buf->next_evseq == cs->next_evseq &&\n\t    (cs->needs_update == false ||\n\t     time_before(jiffies, cs->primary_monitor_time\n\t\t\t + MYRS_PRIMARY_MONITOR_INTERVAL))) {\n\t\tinterval = MYRS_SECONDARY_MONITOR_INTERVAL;\n\t}\n\n\tif (interval > 1)\n\t\tcs->primary_monitor_time = jiffies;\n\tqueue_delayed_work(cs->work_q, &cs->monitor_work, interval);\n}\n\nstatic bool myrs_create_mempools(struct pci_dev *pdev, struct myrs_hba *cs)\n{\n\tstruct Scsi_Host *shost = cs->host;\n\tsize_t elem_size, elem_align;\n\n\telem_align = sizeof(struct myrs_sge);\n\telem_size = shost->sg_tablesize * elem_align;\n\tcs->sg_pool = dma_pool_create(\"myrs_sg\", &pdev->dev,\n\t\t\t\t      elem_size, elem_align, 0);\n\tif (cs->sg_pool == NULL) {\n\t\tshost_printk(KERN_ERR, shost,\n\t\t\t     \"Failed to allocate SG pool\\n\");\n\t\treturn false;\n\t}\n\n\tcs->sense_pool = dma_pool_create(\"myrs_sense\", &pdev->dev,\n\t\t\t\t\t MYRS_SENSE_SIZE, sizeof(int), 0);\n\tif (cs->sense_pool == NULL) {\n\t\tdma_pool_destroy(cs->sg_pool);\n\t\tcs->sg_pool = NULL;\n\t\tshost_printk(KERN_ERR, shost,\n\t\t\t     \"Failed to allocate sense data pool\\n\");\n\t\treturn false;\n\t}\n\n\tcs->dcdb_pool = dma_pool_create(\"myrs_dcdb\", &pdev->dev,\n\t\t\t\t\tMYRS_DCDB_SIZE,\n\t\t\t\t\tsizeof(unsigned char), 0);\n\tif (!cs->dcdb_pool) {\n\t\tdma_pool_destroy(cs->sg_pool);\n\t\tcs->sg_pool = NULL;\n\t\tdma_pool_destroy(cs->sense_pool);\n\t\tcs->sense_pool = NULL;\n\t\tshost_printk(KERN_ERR, shost,\n\t\t\t     \"Failed to allocate DCDB pool\\n\");\n\t\treturn false;\n\t}\n\n\tsnprintf(cs->work_q_name, sizeof(cs->work_q_name),\n\t\t \"myrs_wq_%d\", shost->host_no);\n\tcs->work_q = create_singlethread_workqueue(cs->work_q_name);\n\tif (!cs->work_q) {\n\t\tdma_pool_destroy(cs->dcdb_pool);\n\t\tcs->dcdb_pool = NULL;\n\t\tdma_pool_destroy(cs->sg_pool);\n\t\tcs->sg_pool = NULL;\n\t\tdma_pool_destroy(cs->sense_pool);\n\t\tcs->sense_pool = NULL;\n\t\tshost_printk(KERN_ERR, shost,\n\t\t\t     \"Failed to create workqueue\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tINIT_DELAYED_WORK(&cs->monitor_work, myrs_monitor);\n\tqueue_delayed_work(cs->work_q, &cs->monitor_work, 1);\n\n\treturn true;\n}\n\nstatic void myrs_destroy_mempools(struct myrs_hba *cs)\n{\n\tcancel_delayed_work_sync(&cs->monitor_work);\n\tdestroy_workqueue(cs->work_q);\n\n\tdma_pool_destroy(cs->sg_pool);\n\tdma_pool_destroy(cs->dcdb_pool);\n\tdma_pool_destroy(cs->sense_pool);\n}\n\nstatic void myrs_unmap(struct myrs_hba *cs)\n{\n\tkfree(cs->event_buf);\n\tkfree(cs->ctlr_info);\n\tif (cs->fwstat_buf) {\n\t\tdma_free_coherent(&cs->pdev->dev, sizeof(struct myrs_fwstat),\n\t\t\t\t  cs->fwstat_buf, cs->fwstat_addr);\n\t\tcs->fwstat_buf = NULL;\n\t}\n\tif (cs->first_stat_mbox) {\n\t\tdma_free_coherent(&cs->pdev->dev, cs->stat_mbox_size,\n\t\t\t\t  cs->first_stat_mbox, cs->stat_mbox_addr);\n\t\tcs->first_stat_mbox = NULL;\n\t}\n\tif (cs->first_cmd_mbox) {\n\t\tdma_free_coherent(&cs->pdev->dev, cs->cmd_mbox_size,\n\t\t\t\t  cs->first_cmd_mbox, cs->cmd_mbox_addr);\n\t\tcs->first_cmd_mbox = NULL;\n\t}\n}\n\nstatic void myrs_cleanup(struct myrs_hba *cs)\n{\n\tstruct pci_dev *pdev = cs->pdev;\n\n\t \n\tmyrs_unmap(cs);\n\n\tif (cs->mmio_base) {\n\t\tif (cs->disable_intr)\n\t\t\tcs->disable_intr(cs);\n\t\tiounmap(cs->mmio_base);\n\t\tcs->mmio_base = NULL;\n\t}\n\tif (cs->irq)\n\t\tfree_irq(cs->irq, cs);\n\tif (cs->io_addr)\n\t\trelease_region(cs->io_addr, 0x80);\n\tpci_set_drvdata(pdev, NULL);\n\tpci_disable_device(pdev);\n\tscsi_host_put(cs->host);\n}\n\nstatic struct myrs_hba *myrs_detect(struct pci_dev *pdev,\n\t\tconst struct pci_device_id *entry)\n{\n\tstruct myrs_privdata *privdata =\n\t\t(struct myrs_privdata *)entry->driver_data;\n\tirq_handler_t irq_handler = privdata->irq_handler;\n\tunsigned int mmio_size = privdata->mmio_size;\n\tstruct myrs_hba *cs = NULL;\n\n\tcs = myrs_alloc_host(pdev, entry);\n\tif (!cs) {\n\t\tdev_err(&pdev->dev, \"Unable to allocate Controller\\n\");\n\t\treturn NULL;\n\t}\n\tcs->pdev = pdev;\n\n\tif (pci_enable_device(pdev))\n\t\tgoto Failure;\n\n\tcs->pci_addr = pci_resource_start(pdev, 0);\n\n\tpci_set_drvdata(pdev, cs);\n\tspin_lock_init(&cs->queue_lock);\n\t \n\tif (mmio_size < PAGE_SIZE)\n\t\tmmio_size = PAGE_SIZE;\n\tcs->mmio_base = ioremap(cs->pci_addr & PAGE_MASK, mmio_size);\n\tif (cs->mmio_base == NULL) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to map Controller Register Window\\n\");\n\t\tgoto Failure;\n\t}\n\n\tcs->io_base = cs->mmio_base + (cs->pci_addr & ~PAGE_MASK);\n\tif (privdata->hw_init(pdev, cs, cs->io_base))\n\t\tgoto Failure;\n\n\t \n\tif (request_irq(pdev->irq, irq_handler, IRQF_SHARED, \"myrs\", cs) < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to acquire IRQ Channel %d\\n\", pdev->irq);\n\t\tgoto Failure;\n\t}\n\tcs->irq = pdev->irq;\n\treturn cs;\n\nFailure:\n\tdev_err(&pdev->dev,\n\t\t\"Failed to initialize Controller\\n\");\n\tmyrs_cleanup(cs);\n\treturn NULL;\n}\n\n \n\nstatic bool myrs_err_status(struct myrs_hba *cs, unsigned char status,\n\t\tunsigned char parm0, unsigned char parm1)\n{\n\tstruct pci_dev *pdev = cs->pdev;\n\n\tswitch (status) {\n\tcase 0x00:\n\t\tdev_info(&pdev->dev,\n\t\t\t \"Physical Device %d:%d Not Responding\\n\",\n\t\t\t parm1, parm0);\n\t\tbreak;\n\tcase 0x08:\n\t\tdev_notice(&pdev->dev, \"Spinning Up Drives\\n\");\n\t\tbreak;\n\tcase 0x30:\n\t\tdev_notice(&pdev->dev, \"Configuration Checksum Error\\n\");\n\t\tbreak;\n\tcase 0x60:\n\t\tdev_notice(&pdev->dev, \"Mirror Race Recovery Failed\\n\");\n\t\tbreak;\n\tcase 0x70:\n\t\tdev_notice(&pdev->dev, \"Mirror Race Recovery In Progress\\n\");\n\t\tbreak;\n\tcase 0x90:\n\t\tdev_notice(&pdev->dev, \"Physical Device %d:%d COD Mismatch\\n\",\n\t\t\t   parm1, parm0);\n\t\tbreak;\n\tcase 0xA0:\n\t\tdev_notice(&pdev->dev, \"Logical Drive Installation Aborted\\n\");\n\t\tbreak;\n\tcase 0xB0:\n\t\tdev_notice(&pdev->dev, \"Mirror Race On A Critical Logical Drive\\n\");\n\t\tbreak;\n\tcase 0xD0:\n\t\tdev_notice(&pdev->dev, \"New Controller Configuration Found\\n\");\n\t\tbreak;\n\tcase 0xF0:\n\t\tdev_err(&pdev->dev, \"Fatal Memory Parity Error\\n\");\n\t\treturn true;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unknown Initialization Error %02X\\n\",\n\t\t\tstatus);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \n\n \n\nstatic inline void DAC960_GEM_hw_mbox_new_cmd(void __iomem *base)\n{\n\t__le32 val = cpu_to_le32(DAC960_GEM_IDB_HWMBOX_NEW_CMD << 24);\n\n\twritel(val, base + DAC960_GEM_IDB_READ_OFFSET);\n}\n\nstatic inline void DAC960_GEM_ack_hw_mbox_status(void __iomem *base)\n{\n\t__le32 val = cpu_to_le32(DAC960_GEM_IDB_HWMBOX_ACK_STS << 24);\n\n\twritel(val, base + DAC960_GEM_IDB_CLEAR_OFFSET);\n}\n\nstatic inline void DAC960_GEM_reset_ctrl(void __iomem *base)\n{\n\t__le32 val = cpu_to_le32(DAC960_GEM_IDB_CTRL_RESET << 24);\n\n\twritel(val, base + DAC960_GEM_IDB_READ_OFFSET);\n}\n\nstatic inline void DAC960_GEM_mem_mbox_new_cmd(void __iomem *base)\n{\n\t__le32 val = cpu_to_le32(DAC960_GEM_IDB_HWMBOX_NEW_CMD << 24);\n\n\twritel(val, base + DAC960_GEM_IDB_READ_OFFSET);\n}\n\nstatic inline bool DAC960_GEM_hw_mbox_is_full(void __iomem *base)\n{\n\t__le32 val;\n\n\tval = readl(base + DAC960_GEM_IDB_READ_OFFSET);\n\treturn (le32_to_cpu(val) >> 24) & DAC960_GEM_IDB_HWMBOX_FULL;\n}\n\nstatic inline bool DAC960_GEM_init_in_progress(void __iomem *base)\n{\n\t__le32 val;\n\n\tval = readl(base + DAC960_GEM_IDB_READ_OFFSET);\n\treturn (le32_to_cpu(val) >> 24) & DAC960_GEM_IDB_INIT_IN_PROGRESS;\n}\n\nstatic inline void DAC960_GEM_ack_hw_mbox_intr(void __iomem *base)\n{\n\t__le32 val = cpu_to_le32(DAC960_GEM_ODB_HWMBOX_ACK_IRQ << 24);\n\n\twritel(val, base + DAC960_GEM_ODB_CLEAR_OFFSET);\n}\n\nstatic inline void DAC960_GEM_ack_intr(void __iomem *base)\n{\n\t__le32 val = cpu_to_le32((DAC960_GEM_ODB_HWMBOX_ACK_IRQ |\n\t\t\t\t  DAC960_GEM_ODB_MMBOX_ACK_IRQ) << 24);\n\n\twritel(val, base + DAC960_GEM_ODB_CLEAR_OFFSET);\n}\n\nstatic inline bool DAC960_GEM_hw_mbox_status_available(void __iomem *base)\n{\n\t__le32 val;\n\n\tval = readl(base + DAC960_GEM_ODB_READ_OFFSET);\n\treturn (le32_to_cpu(val) >> 24) & DAC960_GEM_ODB_HWMBOX_STS_AVAIL;\n}\n\nstatic inline void DAC960_GEM_enable_intr(void __iomem *base)\n{\n\t__le32 val = cpu_to_le32((DAC960_GEM_IRQMASK_HWMBOX_IRQ |\n\t\t\t\t  DAC960_GEM_IRQMASK_MMBOX_IRQ) << 24);\n\twritel(val, base + DAC960_GEM_IRQMASK_CLEAR_OFFSET);\n}\n\nstatic inline void DAC960_GEM_disable_intr(void __iomem *base)\n{\n\t__le32 val = 0;\n\n\twritel(val, base + DAC960_GEM_IRQMASK_READ_OFFSET);\n}\n\nstatic inline void DAC960_GEM_write_cmd_mbox(union myrs_cmd_mbox *mem_mbox,\n\t\tunion myrs_cmd_mbox *mbox)\n{\n\tmemcpy(&mem_mbox->words[1], &mbox->words[1],\n\t       sizeof(union myrs_cmd_mbox) - sizeof(unsigned int));\n\t \n\twmb();\n\tmem_mbox->words[0] = mbox->words[0];\n\t \n\tmb();\n}\n\nstatic inline void DAC960_GEM_write_hw_mbox(void __iomem *base,\n\t\tdma_addr_t cmd_mbox_addr)\n{\n\tdma_addr_writeql(cmd_mbox_addr, base + DAC960_GEM_CMDMBX_OFFSET);\n}\n\nstatic inline unsigned char DAC960_GEM_read_cmd_status(void __iomem *base)\n{\n\treturn readw(base + DAC960_GEM_CMDSTS_OFFSET + 2);\n}\n\nstatic inline bool\nDAC960_GEM_read_error_status(void __iomem *base, unsigned char *error,\n\t\tunsigned char *param0, unsigned char *param1)\n{\n\t__le32 val;\n\n\tval = readl(base + DAC960_GEM_ERRSTS_READ_OFFSET);\n\tif (!((le32_to_cpu(val) >> 24) & DAC960_GEM_ERRSTS_PENDING))\n\t\treturn false;\n\t*error = val & ~(DAC960_GEM_ERRSTS_PENDING << 24);\n\t*param0 = readb(base + DAC960_GEM_CMDMBX_OFFSET + 0);\n\t*param1 = readb(base + DAC960_GEM_CMDMBX_OFFSET + 1);\n\twritel(0x03000000, base + DAC960_GEM_ERRSTS_CLEAR_OFFSET);\n\treturn true;\n}\n\nstatic inline unsigned char\nDAC960_GEM_mbox_init(void __iomem *base, dma_addr_t mbox_addr)\n{\n\tunsigned char status;\n\n\twhile (DAC960_GEM_hw_mbox_is_full(base))\n\t\tudelay(1);\n\tDAC960_GEM_write_hw_mbox(base, mbox_addr);\n\tDAC960_GEM_hw_mbox_new_cmd(base);\n\twhile (!DAC960_GEM_hw_mbox_status_available(base))\n\t\tudelay(1);\n\tstatus = DAC960_GEM_read_cmd_status(base);\n\tDAC960_GEM_ack_hw_mbox_intr(base);\n\tDAC960_GEM_ack_hw_mbox_status(base);\n\n\treturn status;\n}\n\nstatic int DAC960_GEM_hw_init(struct pci_dev *pdev,\n\t\tstruct myrs_hba *cs, void __iomem *base)\n{\n\tint timeout = 0;\n\tunsigned char status, parm0, parm1;\n\n\tDAC960_GEM_disable_intr(base);\n\tDAC960_GEM_ack_hw_mbox_status(base);\n\tudelay(1000);\n\twhile (DAC960_GEM_init_in_progress(base) &&\n\t       timeout < MYRS_MAILBOX_TIMEOUT) {\n\t\tif (DAC960_GEM_read_error_status(base, &status,\n\t\t\t\t\t\t &parm0, &parm1) &&\n\t\t    myrs_err_status(cs, status, parm0, parm1))\n\t\t\treturn -EIO;\n\t\tudelay(10);\n\t\ttimeout++;\n\t}\n\tif (timeout == MYRS_MAILBOX_TIMEOUT) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Timeout waiting for Controller Initialisation\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (!myrs_enable_mmio_mbox(cs, DAC960_GEM_mbox_init)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to Enable Memory Mailbox Interface\\n\");\n\t\tDAC960_GEM_reset_ctrl(base);\n\t\treturn -EAGAIN;\n\t}\n\tDAC960_GEM_enable_intr(base);\n\tcs->write_cmd_mbox = DAC960_GEM_write_cmd_mbox;\n\tcs->get_cmd_mbox = DAC960_GEM_mem_mbox_new_cmd;\n\tcs->disable_intr = DAC960_GEM_disable_intr;\n\tcs->reset = DAC960_GEM_reset_ctrl;\n\treturn 0;\n}\n\nstatic irqreturn_t DAC960_GEM_intr_handler(int irq, void *arg)\n{\n\tstruct myrs_hba *cs = arg;\n\tvoid __iomem *base = cs->io_base;\n\tstruct myrs_stat_mbox *next_stat_mbox;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cs->queue_lock, flags);\n\tDAC960_GEM_ack_intr(base);\n\tnext_stat_mbox = cs->next_stat_mbox;\n\twhile (next_stat_mbox->id > 0) {\n\t\tunsigned short id = next_stat_mbox->id;\n\t\tstruct scsi_cmnd *scmd = NULL;\n\t\tstruct myrs_cmdblk *cmd_blk = NULL;\n\n\t\tif (id == MYRS_DCMD_TAG)\n\t\t\tcmd_blk = &cs->dcmd_blk;\n\t\telse if (id == MYRS_MCMD_TAG)\n\t\t\tcmd_blk = &cs->mcmd_blk;\n\t\telse {\n\t\t\tscmd = scsi_host_find_tag(cs->host, id - 3);\n\t\t\tif (scmd)\n\t\t\t\tcmd_blk = scsi_cmd_priv(scmd);\n\t\t}\n\t\tif (cmd_blk) {\n\t\t\tcmd_blk->status = next_stat_mbox->status;\n\t\t\tcmd_blk->sense_len = next_stat_mbox->sense_len;\n\t\t\tcmd_blk->residual = next_stat_mbox->residual;\n\t\t} else\n\t\t\tdev_err(&cs->pdev->dev,\n\t\t\t\t\"Unhandled command completion %d\\n\", id);\n\n\t\tmemset(next_stat_mbox, 0, sizeof(struct myrs_stat_mbox));\n\t\tif (++next_stat_mbox > cs->last_stat_mbox)\n\t\t\tnext_stat_mbox = cs->first_stat_mbox;\n\n\t\tif (cmd_blk) {\n\t\t\tif (id < 3)\n\t\t\t\tmyrs_handle_cmdblk(cs, cmd_blk);\n\t\t\telse\n\t\t\t\tmyrs_handle_scsi(cs, cmd_blk, scmd);\n\t\t}\n\t}\n\tcs->next_stat_mbox = next_stat_mbox;\n\tspin_unlock_irqrestore(&cs->queue_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct myrs_privdata DAC960_GEM_privdata = {\n\t.hw_init =\t\tDAC960_GEM_hw_init,\n\t.irq_handler =\t\tDAC960_GEM_intr_handler,\n\t.mmio_size =\t\tDAC960_GEM_mmio_size,\n};\n\n \n\nstatic inline void DAC960_BA_hw_mbox_new_cmd(void __iomem *base)\n{\n\twriteb(DAC960_BA_IDB_HWMBOX_NEW_CMD, base + DAC960_BA_IDB_OFFSET);\n}\n\nstatic inline void DAC960_BA_ack_hw_mbox_status(void __iomem *base)\n{\n\twriteb(DAC960_BA_IDB_HWMBOX_ACK_STS, base + DAC960_BA_IDB_OFFSET);\n}\n\nstatic inline void DAC960_BA_reset_ctrl(void __iomem *base)\n{\n\twriteb(DAC960_BA_IDB_CTRL_RESET, base + DAC960_BA_IDB_OFFSET);\n}\n\nstatic inline void DAC960_BA_mem_mbox_new_cmd(void __iomem *base)\n{\n\twriteb(DAC960_BA_IDB_MMBOX_NEW_CMD, base + DAC960_BA_IDB_OFFSET);\n}\n\nstatic inline bool DAC960_BA_hw_mbox_is_full(void __iomem *base)\n{\n\tu8 val;\n\n\tval = readb(base + DAC960_BA_IDB_OFFSET);\n\treturn !(val & DAC960_BA_IDB_HWMBOX_EMPTY);\n}\n\nstatic inline bool DAC960_BA_init_in_progress(void __iomem *base)\n{\n\tu8 val;\n\n\tval = readb(base + DAC960_BA_IDB_OFFSET);\n\treturn !(val & DAC960_BA_IDB_INIT_DONE);\n}\n\nstatic inline void DAC960_BA_ack_hw_mbox_intr(void __iomem *base)\n{\n\twriteb(DAC960_BA_ODB_HWMBOX_ACK_IRQ, base + DAC960_BA_ODB_OFFSET);\n}\n\nstatic inline void DAC960_BA_ack_intr(void __iomem *base)\n{\n\twriteb(DAC960_BA_ODB_HWMBOX_ACK_IRQ | DAC960_BA_ODB_MMBOX_ACK_IRQ,\n\t       base + DAC960_BA_ODB_OFFSET);\n}\n\nstatic inline bool DAC960_BA_hw_mbox_status_available(void __iomem *base)\n{\n\tu8 val;\n\n\tval = readb(base + DAC960_BA_ODB_OFFSET);\n\treturn val & DAC960_BA_ODB_HWMBOX_STS_AVAIL;\n}\n\nstatic inline void DAC960_BA_enable_intr(void __iomem *base)\n{\n\twriteb(~DAC960_BA_IRQMASK_DISABLE_IRQ, base + DAC960_BA_IRQMASK_OFFSET);\n}\n\nstatic inline void DAC960_BA_disable_intr(void __iomem *base)\n{\n\twriteb(0xFF, base + DAC960_BA_IRQMASK_OFFSET);\n}\n\nstatic inline void DAC960_BA_write_cmd_mbox(union myrs_cmd_mbox *mem_mbox,\n\t\tunion myrs_cmd_mbox *mbox)\n{\n\tmemcpy(&mem_mbox->words[1], &mbox->words[1],\n\t       sizeof(union myrs_cmd_mbox) - sizeof(unsigned int));\n\t \n\twmb();\n\tmem_mbox->words[0] = mbox->words[0];\n\t \n\tmb();\n}\n\n\nstatic inline void DAC960_BA_write_hw_mbox(void __iomem *base,\n\t\tdma_addr_t cmd_mbox_addr)\n{\n\tdma_addr_writeql(cmd_mbox_addr, base + DAC960_BA_CMDMBX_OFFSET);\n}\n\nstatic inline unsigned char DAC960_BA_read_cmd_status(void __iomem *base)\n{\n\treturn readw(base + DAC960_BA_CMDSTS_OFFSET + 2);\n}\n\nstatic inline bool\nDAC960_BA_read_error_status(void __iomem *base, unsigned char *error,\n\t\tunsigned char *param0, unsigned char *param1)\n{\n\tu8 val;\n\n\tval = readb(base + DAC960_BA_ERRSTS_OFFSET);\n\tif (!(val & DAC960_BA_ERRSTS_PENDING))\n\t\treturn false;\n\tval &= ~DAC960_BA_ERRSTS_PENDING;\n\t*error = val;\n\t*param0 = readb(base + DAC960_BA_CMDMBX_OFFSET + 0);\n\t*param1 = readb(base + DAC960_BA_CMDMBX_OFFSET + 1);\n\twriteb(0xFF, base + DAC960_BA_ERRSTS_OFFSET);\n\treturn true;\n}\n\nstatic inline unsigned char\nDAC960_BA_mbox_init(void __iomem *base, dma_addr_t mbox_addr)\n{\n\tunsigned char status;\n\n\twhile (DAC960_BA_hw_mbox_is_full(base))\n\t\tudelay(1);\n\tDAC960_BA_write_hw_mbox(base, mbox_addr);\n\tDAC960_BA_hw_mbox_new_cmd(base);\n\twhile (!DAC960_BA_hw_mbox_status_available(base))\n\t\tudelay(1);\n\tstatus = DAC960_BA_read_cmd_status(base);\n\tDAC960_BA_ack_hw_mbox_intr(base);\n\tDAC960_BA_ack_hw_mbox_status(base);\n\n\treturn status;\n}\n\nstatic int DAC960_BA_hw_init(struct pci_dev *pdev,\n\t\tstruct myrs_hba *cs, void __iomem *base)\n{\n\tint timeout = 0;\n\tunsigned char status, parm0, parm1;\n\n\tDAC960_BA_disable_intr(base);\n\tDAC960_BA_ack_hw_mbox_status(base);\n\tudelay(1000);\n\twhile (DAC960_BA_init_in_progress(base) &&\n\t       timeout < MYRS_MAILBOX_TIMEOUT) {\n\t\tif (DAC960_BA_read_error_status(base, &status,\n\t\t\t\t\t      &parm0, &parm1) &&\n\t\t    myrs_err_status(cs, status, parm0, parm1))\n\t\t\treturn -EIO;\n\t\tudelay(10);\n\t\ttimeout++;\n\t}\n\tif (timeout == MYRS_MAILBOX_TIMEOUT) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Timeout waiting for Controller Initialisation\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (!myrs_enable_mmio_mbox(cs, DAC960_BA_mbox_init)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to Enable Memory Mailbox Interface\\n\");\n\t\tDAC960_BA_reset_ctrl(base);\n\t\treturn -EAGAIN;\n\t}\n\tDAC960_BA_enable_intr(base);\n\tcs->write_cmd_mbox = DAC960_BA_write_cmd_mbox;\n\tcs->get_cmd_mbox = DAC960_BA_mem_mbox_new_cmd;\n\tcs->disable_intr = DAC960_BA_disable_intr;\n\tcs->reset = DAC960_BA_reset_ctrl;\n\treturn 0;\n}\n\nstatic irqreturn_t DAC960_BA_intr_handler(int irq, void *arg)\n{\n\tstruct myrs_hba *cs = arg;\n\tvoid __iomem *base = cs->io_base;\n\tstruct myrs_stat_mbox *next_stat_mbox;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cs->queue_lock, flags);\n\tDAC960_BA_ack_intr(base);\n\tnext_stat_mbox = cs->next_stat_mbox;\n\twhile (next_stat_mbox->id > 0) {\n\t\tunsigned short id = next_stat_mbox->id;\n\t\tstruct scsi_cmnd *scmd = NULL;\n\t\tstruct myrs_cmdblk *cmd_blk = NULL;\n\n\t\tif (id == MYRS_DCMD_TAG)\n\t\t\tcmd_blk = &cs->dcmd_blk;\n\t\telse if (id == MYRS_MCMD_TAG)\n\t\t\tcmd_blk = &cs->mcmd_blk;\n\t\telse {\n\t\t\tscmd = scsi_host_find_tag(cs->host, id - 3);\n\t\t\tif (scmd)\n\t\t\t\tcmd_blk = scsi_cmd_priv(scmd);\n\t\t}\n\t\tif (cmd_blk) {\n\t\t\tcmd_blk->status = next_stat_mbox->status;\n\t\t\tcmd_blk->sense_len = next_stat_mbox->sense_len;\n\t\t\tcmd_blk->residual = next_stat_mbox->residual;\n\t\t} else\n\t\t\tdev_err(&cs->pdev->dev,\n\t\t\t\t\"Unhandled command completion %d\\n\", id);\n\n\t\tmemset(next_stat_mbox, 0, sizeof(struct myrs_stat_mbox));\n\t\tif (++next_stat_mbox > cs->last_stat_mbox)\n\t\t\tnext_stat_mbox = cs->first_stat_mbox;\n\n\t\tif (cmd_blk) {\n\t\t\tif (id < 3)\n\t\t\t\tmyrs_handle_cmdblk(cs, cmd_blk);\n\t\t\telse\n\t\t\t\tmyrs_handle_scsi(cs, cmd_blk, scmd);\n\t\t}\n\t}\n\tcs->next_stat_mbox = next_stat_mbox;\n\tspin_unlock_irqrestore(&cs->queue_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct myrs_privdata DAC960_BA_privdata = {\n\t.hw_init =\t\tDAC960_BA_hw_init,\n\t.irq_handler =\t\tDAC960_BA_intr_handler,\n\t.mmio_size =\t\tDAC960_BA_mmio_size,\n};\n\n \n\nstatic inline void DAC960_LP_hw_mbox_new_cmd(void __iomem *base)\n{\n\twriteb(DAC960_LP_IDB_HWMBOX_NEW_CMD, base + DAC960_LP_IDB_OFFSET);\n}\n\nstatic inline void DAC960_LP_ack_hw_mbox_status(void __iomem *base)\n{\n\twriteb(DAC960_LP_IDB_HWMBOX_ACK_STS, base + DAC960_LP_IDB_OFFSET);\n}\n\nstatic inline void DAC960_LP_reset_ctrl(void __iomem *base)\n{\n\twriteb(DAC960_LP_IDB_CTRL_RESET, base + DAC960_LP_IDB_OFFSET);\n}\n\nstatic inline void DAC960_LP_mem_mbox_new_cmd(void __iomem *base)\n{\n\twriteb(DAC960_LP_IDB_MMBOX_NEW_CMD, base + DAC960_LP_IDB_OFFSET);\n}\n\nstatic inline bool DAC960_LP_hw_mbox_is_full(void __iomem *base)\n{\n\tu8 val;\n\n\tval = readb(base + DAC960_LP_IDB_OFFSET);\n\treturn val & DAC960_LP_IDB_HWMBOX_FULL;\n}\n\nstatic inline bool DAC960_LP_init_in_progress(void __iomem *base)\n{\n\tu8 val;\n\n\tval = readb(base + DAC960_LP_IDB_OFFSET);\n\treturn val & DAC960_LP_IDB_INIT_IN_PROGRESS;\n}\n\nstatic inline void DAC960_LP_ack_hw_mbox_intr(void __iomem *base)\n{\n\twriteb(DAC960_LP_ODB_HWMBOX_ACK_IRQ, base + DAC960_LP_ODB_OFFSET);\n}\n\nstatic inline void DAC960_LP_ack_intr(void __iomem *base)\n{\n\twriteb(DAC960_LP_ODB_HWMBOX_ACK_IRQ | DAC960_LP_ODB_MMBOX_ACK_IRQ,\n\t       base + DAC960_LP_ODB_OFFSET);\n}\n\nstatic inline bool DAC960_LP_hw_mbox_status_available(void __iomem *base)\n{\n\tu8 val;\n\n\tval = readb(base + DAC960_LP_ODB_OFFSET);\n\treturn val & DAC960_LP_ODB_HWMBOX_STS_AVAIL;\n}\n\nstatic inline void DAC960_LP_enable_intr(void __iomem *base)\n{\n\twriteb(~DAC960_LP_IRQMASK_DISABLE_IRQ, base + DAC960_LP_IRQMASK_OFFSET);\n}\n\nstatic inline void DAC960_LP_disable_intr(void __iomem *base)\n{\n\twriteb(0xFF, base + DAC960_LP_IRQMASK_OFFSET);\n}\n\nstatic inline void DAC960_LP_write_cmd_mbox(union myrs_cmd_mbox *mem_mbox,\n\t\tunion myrs_cmd_mbox *mbox)\n{\n\tmemcpy(&mem_mbox->words[1], &mbox->words[1],\n\t       sizeof(union myrs_cmd_mbox) - sizeof(unsigned int));\n\t \n\twmb();\n\tmem_mbox->words[0] = mbox->words[0];\n\t \n\tmb();\n}\n\nstatic inline void DAC960_LP_write_hw_mbox(void __iomem *base,\n\t\tdma_addr_t cmd_mbox_addr)\n{\n\tdma_addr_writeql(cmd_mbox_addr, base + DAC960_LP_CMDMBX_OFFSET);\n}\n\nstatic inline unsigned char DAC960_LP_read_cmd_status(void __iomem *base)\n{\n\treturn readw(base + DAC960_LP_CMDSTS_OFFSET + 2);\n}\n\nstatic inline bool\nDAC960_LP_read_error_status(void __iomem *base, unsigned char *error,\n\t\tunsigned char *param0, unsigned char *param1)\n{\n\tu8 val;\n\n\tval = readb(base + DAC960_LP_ERRSTS_OFFSET);\n\tif (!(val & DAC960_LP_ERRSTS_PENDING))\n\t\treturn false;\n\tval &= ~DAC960_LP_ERRSTS_PENDING;\n\t*error = val;\n\t*param0 = readb(base + DAC960_LP_CMDMBX_OFFSET + 0);\n\t*param1 = readb(base + DAC960_LP_CMDMBX_OFFSET + 1);\n\twriteb(0xFF, base + DAC960_LP_ERRSTS_OFFSET);\n\treturn true;\n}\n\nstatic inline unsigned char\nDAC960_LP_mbox_init(void __iomem *base, dma_addr_t mbox_addr)\n{\n\tunsigned char status;\n\n\twhile (DAC960_LP_hw_mbox_is_full(base))\n\t\tudelay(1);\n\tDAC960_LP_write_hw_mbox(base, mbox_addr);\n\tDAC960_LP_hw_mbox_new_cmd(base);\n\twhile (!DAC960_LP_hw_mbox_status_available(base))\n\t\tudelay(1);\n\tstatus = DAC960_LP_read_cmd_status(base);\n\tDAC960_LP_ack_hw_mbox_intr(base);\n\tDAC960_LP_ack_hw_mbox_status(base);\n\n\treturn status;\n}\n\nstatic int DAC960_LP_hw_init(struct pci_dev *pdev,\n\t\tstruct myrs_hba *cs, void __iomem *base)\n{\n\tint timeout = 0;\n\tunsigned char status, parm0, parm1;\n\n\tDAC960_LP_disable_intr(base);\n\tDAC960_LP_ack_hw_mbox_status(base);\n\tudelay(1000);\n\twhile (DAC960_LP_init_in_progress(base) &&\n\t       timeout < MYRS_MAILBOX_TIMEOUT) {\n\t\tif (DAC960_LP_read_error_status(base, &status,\n\t\t\t\t\t      &parm0, &parm1) &&\n\t\t    myrs_err_status(cs, status, parm0, parm1))\n\t\t\treturn -EIO;\n\t\tudelay(10);\n\t\ttimeout++;\n\t}\n\tif (timeout == MYRS_MAILBOX_TIMEOUT) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Timeout waiting for Controller Initialisation\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (!myrs_enable_mmio_mbox(cs, DAC960_LP_mbox_init)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to Enable Memory Mailbox Interface\\n\");\n\t\tDAC960_LP_reset_ctrl(base);\n\t\treturn -ENODEV;\n\t}\n\tDAC960_LP_enable_intr(base);\n\tcs->write_cmd_mbox = DAC960_LP_write_cmd_mbox;\n\tcs->get_cmd_mbox = DAC960_LP_mem_mbox_new_cmd;\n\tcs->disable_intr = DAC960_LP_disable_intr;\n\tcs->reset = DAC960_LP_reset_ctrl;\n\n\treturn 0;\n}\n\nstatic irqreturn_t DAC960_LP_intr_handler(int irq, void *arg)\n{\n\tstruct myrs_hba *cs = arg;\n\tvoid __iomem *base = cs->io_base;\n\tstruct myrs_stat_mbox *next_stat_mbox;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cs->queue_lock, flags);\n\tDAC960_LP_ack_intr(base);\n\tnext_stat_mbox = cs->next_stat_mbox;\n\twhile (next_stat_mbox->id > 0) {\n\t\tunsigned short id = next_stat_mbox->id;\n\t\tstruct scsi_cmnd *scmd = NULL;\n\t\tstruct myrs_cmdblk *cmd_blk = NULL;\n\n\t\tif (id == MYRS_DCMD_TAG)\n\t\t\tcmd_blk = &cs->dcmd_blk;\n\t\telse if (id == MYRS_MCMD_TAG)\n\t\t\tcmd_blk = &cs->mcmd_blk;\n\t\telse {\n\t\t\tscmd = scsi_host_find_tag(cs->host, id - 3);\n\t\t\tif (scmd)\n\t\t\t\tcmd_blk = scsi_cmd_priv(scmd);\n\t\t}\n\t\tif (cmd_blk) {\n\t\t\tcmd_blk->status = next_stat_mbox->status;\n\t\t\tcmd_blk->sense_len = next_stat_mbox->sense_len;\n\t\t\tcmd_blk->residual = next_stat_mbox->residual;\n\t\t} else\n\t\t\tdev_err(&cs->pdev->dev,\n\t\t\t\t\"Unhandled command completion %d\\n\", id);\n\n\t\tmemset(next_stat_mbox, 0, sizeof(struct myrs_stat_mbox));\n\t\tif (++next_stat_mbox > cs->last_stat_mbox)\n\t\t\tnext_stat_mbox = cs->first_stat_mbox;\n\n\t\tif (cmd_blk) {\n\t\t\tif (id < 3)\n\t\t\t\tmyrs_handle_cmdblk(cs, cmd_blk);\n\t\t\telse\n\t\t\t\tmyrs_handle_scsi(cs, cmd_blk, scmd);\n\t\t}\n\t}\n\tcs->next_stat_mbox = next_stat_mbox;\n\tspin_unlock_irqrestore(&cs->queue_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct myrs_privdata DAC960_LP_privdata = {\n\t.hw_init =\t\tDAC960_LP_hw_init,\n\t.irq_handler =\t\tDAC960_LP_intr_handler,\n\t.mmio_size =\t\tDAC960_LP_mmio_size,\n};\n\n \nstatic int\nmyrs_probe(struct pci_dev *dev, const struct pci_device_id *entry)\n{\n\tstruct myrs_hba *cs;\n\tint ret;\n\n\tcs = myrs_detect(dev, entry);\n\tif (!cs)\n\t\treturn -ENODEV;\n\n\tret = myrs_get_config(cs);\n\tif (ret < 0) {\n\t\tmyrs_cleanup(cs);\n\t\treturn ret;\n\t}\n\n\tif (!myrs_create_mempools(dev, cs)) {\n\t\tret = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tret = scsi_add_host(cs->host, &dev->dev);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"scsi_add_host failed with %d\\n\", ret);\n\t\tmyrs_destroy_mempools(cs);\n\t\tgoto failed;\n\t}\n\tscsi_scan_host(cs->host);\n\treturn 0;\nfailed:\n\tmyrs_cleanup(cs);\n\treturn ret;\n}\n\n\nstatic void myrs_remove(struct pci_dev *pdev)\n{\n\tstruct myrs_hba *cs = pci_get_drvdata(pdev);\n\n\tif (cs == NULL)\n\t\treturn;\n\n\tshost_printk(KERN_NOTICE, cs->host, \"Flushing Cache...\");\n\tmyrs_flush_cache(cs);\n\tmyrs_destroy_mempools(cs);\n\tmyrs_cleanup(cs);\n}\n\n\nstatic const struct pci_device_id myrs_id_table[] = {\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_MYLEX,\n\t\t\t       PCI_DEVICE_ID_MYLEX_DAC960_GEM,\n\t\t\t       PCI_VENDOR_ID_MYLEX, PCI_ANY_ID),\n\t\t.driver_data\t= (unsigned long) &DAC960_GEM_privdata,\n\t},\n\t{\n\t\tPCI_DEVICE_DATA(MYLEX, DAC960_BA, &DAC960_BA_privdata),\n\t},\n\t{\n\t\tPCI_DEVICE_DATA(MYLEX, DAC960_LP, &DAC960_LP_privdata),\n\t},\n\t{0, },\n};\n\nMODULE_DEVICE_TABLE(pci, myrs_id_table);\n\nstatic struct pci_driver myrs_pci_driver = {\n\t.name\t\t= \"myrs\",\n\t.id_table\t= myrs_id_table,\n\t.probe\t\t= myrs_probe,\n\t.remove\t\t= myrs_remove,\n};\n\nstatic int __init myrs_init_module(void)\n{\n\tint ret;\n\n\tmyrs_raid_template = raid_class_attach(&myrs_raid_functions);\n\tif (!myrs_raid_template)\n\t\treturn -ENODEV;\n\n\tret = pci_register_driver(&myrs_pci_driver);\n\tif (ret)\n\t\traid_class_release(myrs_raid_template);\n\n\treturn ret;\n}\n\nstatic void __exit myrs_cleanup_module(void)\n{\n\tpci_unregister_driver(&myrs_pci_driver);\n\traid_class_release(myrs_raid_template);\n}\n\nmodule_init(myrs_init_module);\nmodule_exit(myrs_cleanup_module);\n\nMODULE_DESCRIPTION(\"Mylex DAC960/AcceleRAID/eXtremeRAID driver (SCSI Interface)\");\nMODULE_AUTHOR(\"Hannes Reinecke <hare@suse.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}