{
  "module_name": "dc395x.c",
  "hash_id": "9455a313747cdea056eed95b9f73e49dcff939293cd302236ce1bff08746029a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/dc395x.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/ctype.h>\n#include <linux/blkdev.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_spi.h>\n\n#include \"dc395x.h\"\n\n#define DC395X_NAME\t\"dc395x\"\n#define DC395X_BANNER\t\"Tekram DC395(U/UW/F), DC315(U) - ASIC TRM-S1040\"\n#define DC395X_VERSION\t\"v2.05, 2004/03/08\"\n\n \n \n \n \n \n \n\n \n \n#define DBG_KG\t\t0x0001\n#define DBG_0\t\t0x0002\n#define DBG_1\t\t0x0004\n#define DBG_SG\t\t0x0020\n#define DBG_FIFO\t0x0040\n#define DBG_PIO\t\t0x0080\n\n\n \n \n \n\n\n \n#define dprintkl(level, format, arg...)  \\\n    printk(level DC395X_NAME \": \" format , ## arg)\n\n\n#ifdef DEBUG_MASK\n \n#define dprintkdbg(type, format, arg...) \\\n\tdo { \\\n\t\tif ((type) & (DEBUG_MASK)) \\\n\t\t\tdprintkl(KERN_DEBUG , format , ## arg); \\\n\t} while (0)\n\n \n#define debug_enabled(type)\t((DEBUG_MASK) & (type))\n\n#else\n \n#define dprintkdbg(type, format, arg...) \\\n\tdo {} while (0)\n#define debug_enabled(type)\t(0)\n\n#endif\n\n\n#ifndef PCI_VENDOR_ID_TEKRAM\n#define PCI_VENDOR_ID_TEKRAM                    0x1DE1\t \n#endif\n#ifndef PCI_DEVICE_ID_TEKRAM_TRMS1040\n#define PCI_DEVICE_ID_TEKRAM_TRMS1040           0x0391\t \n#endif\n\n\n#define DC395x_LOCK_IO(dev,flags)\t\tspin_lock_irqsave(((struct Scsi_Host *)dev)->host_lock, flags)\n#define DC395x_UNLOCK_IO(dev,flags)\t\tspin_unlock_irqrestore(((struct Scsi_Host *)dev)->host_lock, flags)\n\n#define DC395x_read8(acb,address)\t\t(u8)(inb(acb->io_port_base + (address)))\n#define DC395x_read16(acb,address)\t\t(u16)(inw(acb->io_port_base + (address)))\n#define DC395x_read32(acb,address)\t\t(u32)(inl(acb->io_port_base + (address)))\n#define DC395x_write8(acb,address,value)\toutb((value), acb->io_port_base + (address))\n#define DC395x_write16(acb,address,value)\toutw((value), acb->io_port_base + (address))\n#define DC395x_write32(acb,address,value)\toutl((value), acb->io_port_base + (address))\n\n#define TAG_NONE 255\n\n \n#define SEGMENTX_LEN\t(sizeof(struct SGentry)*DC395x_MAX_SG_LISTENTRY)\n\n\nstruct SGentry {\n\tu32 address;\t\t \n\tu32 length;\n};\n\n \nstruct NVRamTarget {\n\tu8 cfg0;\t\t \n\tu8 period;\t\t \n\tu8 cfg2;\t\t \n\tu8 cfg3;\t\t \n};\n\nstruct NvRamType {\n\tu8 sub_vendor_id[2];\t \n\tu8 sub_sys_id[2];\t \n\tu8 sub_class;\t\t \n\tu8 vendor_id[2];\t \n\tu8 device_id[2];\t \n\tu8 reserved;\t\t \n\tstruct NVRamTarget target[DC395x_MAX_SCSI_ID];\n\t\t\t\t\t\t \n\tu8 scsi_id;\t\t \n\tu8 channel_cfg;\t\t \n\tu8 delay_time;\t\t \n\tu8 max_tag;\t\t \n\tu8 reserved0;\t\t \n\tu8 boot_target;\t\t \n\tu8 boot_lun;\t\t \n\tu8 reserved1;\t\t \n\tu16 reserved2[22];\t \n\tu16 cksum;\t\t \n};\n\nstruct ScsiReqBlk {\n\tstruct list_head list;\t\t \n\tstruct DeviceCtlBlk *dcb;\n\tstruct scsi_cmnd *cmd;\n\n\tstruct SGentry *segment_x;\t \n\tdma_addr_t sg_bus_addr;\t         \n\n\tu8 sg_count;\t\t\t \n\tu8 sg_index;\t\t\t \n\tsize_t total_xfer_length;\t \n\tsize_t request_length;\t\t \n\t \n\tsize_t xferred;\t\t         \n\n\tu16 state;\n\n\tu8 msgin_buf[6];\n\tu8 msgout_buf[6];\n\n\tu8 adapter_status;\n\tu8 target_status;\n\tu8 msg_count;\n\tu8 end_message;\n\n\tu8 tag_number;\n\tu8 status;\n\tu8 retry_count;\n\tu8 flag;\n\n\tu8 scsi_phase;\n};\n\nstruct DeviceCtlBlk {\n\tstruct list_head list;\t\t \n\tstruct AdapterCtlBlk *acb;\n\tstruct list_head srb_going_list;\t \n\tstruct list_head srb_waiting_list;\t \n\n\tstruct ScsiReqBlk *active_srb;\n\tu32 tag_mask;\n\n\tu16 max_command;\n\n\tu8 target_id;\t\t \n\tu8 target_lun;\t\t \n\tu8 identify_msg;\n\tu8 dev_mode;\n\n\tu8 inquiry7;\t\t \n\tu8 sync_mode;\t\t \n\tu8 min_nego_period;\t \n\tu8 sync_period;\t\t \n\n\tu8 sync_offset;\t\t \n\tu8 flag;\n\tu8 dev_type;\n\tu8 init_tcq_flag;\n};\n\nstruct AdapterCtlBlk {\n\tstruct Scsi_Host *scsi_host;\n\n\tunsigned long io_port_base;\n\tunsigned long io_port_len;\n\n\tstruct list_head dcb_list;\t\t \n\tstruct DeviceCtlBlk *dcb_run_robin;\n\tstruct DeviceCtlBlk *active_dcb;\n\n\tstruct list_head srb_free_list;\t\t \n\tstruct ScsiReqBlk *tmp_srb;\n\tstruct timer_list waiting_timer;\n\tstruct timer_list selto_timer;\n\n\tunsigned long last_reset;\n\n\tu16 srb_count;\n\n\tu8 sel_timeout;\n\n\tunsigned int irq_level;\n\tu8 tag_max_num;\n\tu8 acb_flag;\n\tu8 gmode2;\n\n\tu8 config;\n\tu8 lun_chk;\n\tu8 scan_devices;\n\tu8 hostid_bit;\n\n\tu8 dcb_map[DC395x_MAX_SCSI_ID];\n\tstruct DeviceCtlBlk *children[DC395x_MAX_SCSI_ID][32];\n\n\tstruct pci_dev *dev;\n\n\tu8 msg_len;\n\n\tstruct ScsiReqBlk srb_array[DC395x_MAX_SRB_CNT];\n\tstruct ScsiReqBlk srb;\n\n\tstruct NvRamType eeprom;\t \n};\n\n\n \nstatic void data_out_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status);\nstatic void data_in_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status);\nstatic void command_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status);\nstatic void status_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status);\nstatic void msgout_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status);\nstatic void msgin_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status);\nstatic void data_out_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status);\nstatic void data_in_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status);\nstatic void command_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status);\nstatic void status_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status);\nstatic void msgout_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status);\nstatic void msgin_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status);\nstatic void nop0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status);\nstatic void nop1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb, \n\t\tu16 *pscsi_status);\nstatic void set_basic_config(struct AdapterCtlBlk *acb);\nstatic void cleanup_after_transfer(struct AdapterCtlBlk *acb,\n\t\tstruct ScsiReqBlk *srb);\nstatic void reset_scsi_bus(struct AdapterCtlBlk *acb);\nstatic void data_io_transfer(struct AdapterCtlBlk *acb,\n\t\tstruct ScsiReqBlk *srb, u16 io_dir);\nstatic void disconnect(struct AdapterCtlBlk *acb);\nstatic void reselect(struct AdapterCtlBlk *acb);\nstatic u8 start_scsi(struct AdapterCtlBlk *acb, struct DeviceCtlBlk *dcb,\n\t\tstruct ScsiReqBlk *srb);\nstatic inline void enable_msgout_abort(struct AdapterCtlBlk *acb,\n\t\tstruct ScsiReqBlk *srb);\nstatic void build_srb(struct scsi_cmnd *cmd, struct DeviceCtlBlk *dcb,\n\t\tstruct ScsiReqBlk *srb);\nstatic void doing_srb_done(struct AdapterCtlBlk *acb, u8 did_code,\n\t\tstruct scsi_cmnd *cmd, u8 force);\nstatic void scsi_reset_detect(struct AdapterCtlBlk *acb);\nstatic void pci_unmap_srb(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb);\nstatic void pci_unmap_srb_sense(struct AdapterCtlBlk *acb,\n\t\tstruct ScsiReqBlk *srb);\nstatic void srb_done(struct AdapterCtlBlk *acb, struct DeviceCtlBlk *dcb,\n\t\tstruct ScsiReqBlk *srb);\nstatic void request_sense(struct AdapterCtlBlk *acb, struct DeviceCtlBlk *dcb,\n\t\tstruct ScsiReqBlk *srb);\nstatic void set_xfer_rate(struct AdapterCtlBlk *acb,\n\t\tstruct DeviceCtlBlk *dcb);\nstatic void waiting_timeout(struct timer_list *t);\n\n\n \nstatic u16 current_sync_offset = 0;\n\nstatic void *dc395x_scsi_phase0[] = {\n\tdata_out_phase0, \n\tdata_in_phase0,\t \n\tcommand_phase0,\t \n\tstatus_phase0,\t \n\tnop0,\t\t \n\tnop0,\t\t \n\tmsgout_phase0,\t \n\tmsgin_phase0,\t \n};\n\nstatic void *dc395x_scsi_phase1[] = {\n\tdata_out_phase1, \n\tdata_in_phase1,\t \n\tcommand_phase1,\t \n\tstatus_phase1,\t \n\tnop1,\t\t \n\tnop1,\t\t \n\tmsgout_phase1,\t \n\tmsgin_phase1,\t \n};\n\n \n \n\n \nstatic u8 clock_period[] = { 12, 18, 25, 31, 37, 43, 50, 62 };\nstatic u16 clock_speed[] = { 200, 133, 100, 80, 67, 58, 50, 40 };\n\n\n \n \n\n \n#define CFG_ADAPTER_ID\t\t0\n#define CFG_MAX_SPEED\t\t1\n#define CFG_DEV_MODE\t\t2\n#define CFG_ADAPTER_MODE\t3\n#define CFG_TAGS\t\t4\n#define CFG_RESET_DELAY\t\t5\n\n#define CFG_NUM\t\t\t6\t \n\n\n \n#define CFG_PARAM_UNSET -1\n\n\n \nstruct ParameterData {\n\tint value;\t\t \n\tint min;\t\t \n\tint max;\t\t \n\tint def;\t\t \n\tint safe;\t\t \n};\nstatic struct ParameterData cfg_data[] = {\n\t{  \n\t\tCFG_PARAM_UNSET,\n\t\t0,\n\t\t15,\n\t\t7,\n\t\t7\n\t},\n\t{  \n\t\tCFG_PARAM_UNSET,\n\t\t  0,\n\t\t  7,\n\t\t  1,\t \n\t\t  4,\t \n\t},\n\t{  \n\t\tCFG_PARAM_UNSET,\n\t\t0,\n\t\t0x3f,\n\t\tNTC_DO_PARITY_CHK | NTC_DO_DISCONNECT | NTC_DO_SYNC_NEGO |\n\t\t\tNTC_DO_WIDE_NEGO | NTC_DO_TAG_QUEUEING |\n\t\t\tNTC_DO_SEND_START,\n\t\tNTC_DO_PARITY_CHK | NTC_DO_SEND_START\n\t},\n\t{  \n\t\tCFG_PARAM_UNSET,\n\t\t0,\n\t\t0x2f,\n\t\tNAC_SCANLUN |\n\t\tNAC_GT2DRIVES | NAC_GREATER_1G | NAC_POWERON_SCSI_RESET\n\t\t\t ,\n\t\tNAC_GT2DRIVES | NAC_GREATER_1G | NAC_POWERON_SCSI_RESET | 0x08\n\t},\n\t{  \n\t\tCFG_PARAM_UNSET,\n\t\t0,\n\t\t5,\n\t\t3,\t \n\t\t2,\n\t},\n\t{  \n\t\tCFG_PARAM_UNSET,\n\t\t0,\n\t\t180,\n\t\t1,\t \n\t\t10,\t \n\t}\n};\n\n\n \nstatic bool use_safe_settings = 0;\nmodule_param_named(safe, use_safe_settings, bool, 0);\nMODULE_PARM_DESC(safe, \"Use safe and slow settings only. Default: false\");\n\n\nmodule_param_named(adapter_id, cfg_data[CFG_ADAPTER_ID].value, int, 0);\nMODULE_PARM_DESC(adapter_id, \"Adapter SCSI ID. Default 7 (0-15)\");\n\nmodule_param_named(max_speed, cfg_data[CFG_MAX_SPEED].value, int, 0);\nMODULE_PARM_DESC(max_speed, \"Maximum bus speed. Default 1 (0-7) Speeds: 0=20, 1=13.3, 2=10, 3=8, 4=6.7, 5=5.8, 6=5, 7=4 Mhz\");\n\nmodule_param_named(dev_mode, cfg_data[CFG_DEV_MODE].value, int, 0);\nMODULE_PARM_DESC(dev_mode, \"Device mode.\");\n\nmodule_param_named(adapter_mode, cfg_data[CFG_ADAPTER_MODE].value, int, 0);\nMODULE_PARM_DESC(adapter_mode, \"Adapter mode.\");\n\nmodule_param_named(tags, cfg_data[CFG_TAGS].value, int, 0);\nMODULE_PARM_DESC(tags, \"Number of tags (1<<x). Default 3 (0-5)\");\n\nmodule_param_named(reset_delay, cfg_data[CFG_RESET_DELAY].value, int, 0);\nMODULE_PARM_DESC(reset_delay, \"Reset delay in seconds. Default 1 (0-180)\");\n\n\n \nstatic void set_safe_settings(void)\n{\n\tif (use_safe_settings)\n\t{\n\t\tint i;\n\n\t\tdprintkl(KERN_INFO, \"Using safe settings.\\n\");\n\t\tfor (i = 0; i < CFG_NUM; i++)\n\t\t{\n\t\t\tcfg_data[i].value = cfg_data[i].safe;\n\t\t}\n\t}\n}\n\n\n \nstatic void fix_settings(void)\n{\n\tint i;\n\n\tdprintkdbg(DBG_1,\n\t\t\"setup: AdapterId=%08x MaxSpeed=%08x DevMode=%08x \"\n\t\t\"AdapterMode=%08x Tags=%08x ResetDelay=%08x\\n\",\n\t\tcfg_data[CFG_ADAPTER_ID].value,\n\t\tcfg_data[CFG_MAX_SPEED].value,\n\t\tcfg_data[CFG_DEV_MODE].value,\n\t\tcfg_data[CFG_ADAPTER_MODE].value,\n\t\tcfg_data[CFG_TAGS].value,\n\t\tcfg_data[CFG_RESET_DELAY].value);\n\tfor (i = 0; i < CFG_NUM; i++)\n\t{\n\t\tif (cfg_data[i].value < cfg_data[i].min\n\t\t    || cfg_data[i].value > cfg_data[i].max)\n\t\t\tcfg_data[i].value = cfg_data[i].def;\n\t}\n}\n\n\n\n \nstatic char eeprom_index_to_delay_map[] =\n\t{ 1, 3, 5, 10, 16, 30, 60, 120 };\n\n\n \nstatic void eeprom_index_to_delay(struct NvRamType *eeprom)\n{\n\teeprom->delay_time = eeprom_index_to_delay_map[eeprom->delay_time];\n}\n\n\n \nstatic int delay_to_eeprom_index(int delay)\n{\n\tu8 idx = 0;\n\twhile (idx < 7 && eeprom_index_to_delay_map[idx] < delay)\n\t\tidx++;\n\treturn idx;\n}\n\n\n \nstatic void eeprom_override(struct NvRamType *eeprom)\n{\n\tu8 id;\n\n\t \n\tif (cfg_data[CFG_ADAPTER_ID].value != CFG_PARAM_UNSET)\n\t\teeprom->scsi_id = (u8)cfg_data[CFG_ADAPTER_ID].value;\n\n\tif (cfg_data[CFG_ADAPTER_MODE].value != CFG_PARAM_UNSET)\n\t\teeprom->channel_cfg = (u8)cfg_data[CFG_ADAPTER_MODE].value;\n\n\tif (cfg_data[CFG_RESET_DELAY].value != CFG_PARAM_UNSET)\n\t\teeprom->delay_time = delay_to_eeprom_index(\n\t\t\t\t\tcfg_data[CFG_RESET_DELAY].value);\n\n\tif (cfg_data[CFG_TAGS].value != CFG_PARAM_UNSET)\n\t\teeprom->max_tag = (u8)cfg_data[CFG_TAGS].value;\n\n\t \n\tfor (id = 0; id < DC395x_MAX_SCSI_ID; id++) {\n\t\tif (cfg_data[CFG_DEV_MODE].value != CFG_PARAM_UNSET)\n\t\t\teeprom->target[id].cfg0 =\n\t\t\t\t(u8)cfg_data[CFG_DEV_MODE].value;\n\n\t\tif (cfg_data[CFG_MAX_SPEED].value != CFG_PARAM_UNSET)\n\t\t\teeprom->target[id].period =\n\t\t\t\t(u8)cfg_data[CFG_MAX_SPEED].value;\n\n\t}\n}\n\n\n \n\nstatic unsigned int list_size(struct list_head *head)\n{\n\tunsigned int count = 0;\n\tstruct list_head *pos;\n\tlist_for_each(pos, head)\n\t\tcount++;\n\treturn count;\n}\n\n\nstatic struct DeviceCtlBlk *dcb_get_next(struct list_head *head,\n\t\tstruct DeviceCtlBlk *pos)\n{\n\tint use_next = 0;\n\tstruct DeviceCtlBlk* next = NULL;\n\tstruct DeviceCtlBlk* i;\n\n\tif (list_empty(head))\n\t\treturn NULL;\n\n\t \n\tlist_for_each_entry(i, head, list)\n\t\tif (use_next) {\n\t\t\tnext = i;\n\t\t\tbreak;\n\t\t} else if (i == pos) {\n\t\t\tuse_next = 1;\n\t\t}\n\t \n\tif (!next)\n        \tlist_for_each_entry(i, head, list) {\n        \t\tnext = i;\n        \t\tbreak;\n        \t}\n\n\treturn next;\n}\n\n\nstatic void free_tag(struct DeviceCtlBlk *dcb, struct ScsiReqBlk *srb)\n{\n\tif (srb->tag_number < 255) {\n\t\tdcb->tag_mask &= ~(1 << srb->tag_number);\t \n\t\tsrb->tag_number = 255;\n\t}\n}\n\n\n \nstatic inline struct ScsiReqBlk *find_cmd(struct scsi_cmnd *cmd,\n\t\tstruct list_head *head)\n{\n\tstruct ScsiReqBlk *i;\n\tlist_for_each_entry(i, head, list)\n\t\tif (i->cmd == cmd)\n\t\t\treturn i;\n\treturn NULL;\n}\n\n \nstatic void waiting_set_timer(struct AdapterCtlBlk *acb, unsigned long to)\n{\n\tif (timer_pending(&acb->waiting_timer))\n\t\treturn;\n\tif (time_before(jiffies + to, acb->last_reset - HZ / 2))\n\t\tacb->waiting_timer.expires =\n\t\t    acb->last_reset - HZ / 2 + 1;\n\telse\n\t\tacb->waiting_timer.expires = jiffies + to + 1;\n\tadd_timer(&acb->waiting_timer);\n}\n\n\n \nstatic void waiting_process_next(struct AdapterCtlBlk *acb)\n{\n\tstruct DeviceCtlBlk *start = NULL;\n\tstruct DeviceCtlBlk *pos;\n\tstruct DeviceCtlBlk *dcb;\n\tstruct ScsiReqBlk *srb;\n\tstruct list_head *dcb_list_head = &acb->dcb_list;\n\n\tif (acb->active_dcb\n\t    || (acb->acb_flag & (RESET_DETECT + RESET_DONE + RESET_DEV)))\n\t\treturn;\n\n\tif (timer_pending(&acb->waiting_timer))\n\t\tdel_timer(&acb->waiting_timer);\n\n\tif (list_empty(dcb_list_head))\n\t\treturn;\n\n\t \n\tlist_for_each_entry(dcb, dcb_list_head, list)\n\t\tif (dcb == acb->dcb_run_robin) {\n\t\t\tstart = dcb;\n\t\t\tbreak;\n\t\t}\n\tif (!start) {\n\t\t \n\t\tstart = list_entry(dcb_list_head->next, typeof(*start), list);\n\t\tacb->dcb_run_robin = start;\n\t}\n\n\n\t \n\tpos = start;\n\tdo {\n\t\tstruct list_head *waiting_list_head = &pos->srb_waiting_list;\n\n\t\t \n\t\tacb->dcb_run_robin = dcb_get_next(dcb_list_head,\n\t\t\t\t\t\t  acb->dcb_run_robin);\n\n\t\tif (list_empty(waiting_list_head) ||\n\t\t    pos->max_command <= list_size(&pos->srb_going_list)) {\n\t\t\t \n\t\t\tpos = dcb_get_next(dcb_list_head, pos);\n\t\t} else {\n\t\t\tsrb = list_entry(waiting_list_head->next,\n\t\t\t\t\t struct ScsiReqBlk, list);\n\n\t\t\t \n\t\t\tif (!start_scsi(acb, pos, srb))\n\t\t\t\tlist_move(&srb->list, &pos->srb_going_list);\n\t\t\telse\n\t\t\t\twaiting_set_timer(acb, HZ/50);\n\t\t\tbreak;\n\t\t}\n\t} while (pos != start);\n}\n\n\n \nstatic void waiting_timeout(struct timer_list *t)\n{\n\tunsigned long flags;\n\tstruct AdapterCtlBlk *acb = from_timer(acb, t, waiting_timer);\n\tdprintkdbg(DBG_1,\n\t\t\"waiting_timeout: Queue woken up by timer. acb=%p\\n\", acb);\n\tDC395x_LOCK_IO(acb->scsi_host, flags);\n\twaiting_process_next(acb);\n\tDC395x_UNLOCK_IO(acb->scsi_host, flags);\n}\n\n\n \nstatic struct DeviceCtlBlk *find_dcb(struct AdapterCtlBlk *acb, u8 id, u8 lun)\n{\n\treturn acb->children[id][lun];\n}\n\n\n \nstatic void send_srb(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb)\n{\n\tstruct DeviceCtlBlk *dcb = srb->dcb;\n\n\tif (dcb->max_command <= list_size(&dcb->srb_going_list) ||\n\t    acb->active_dcb ||\n\t    (acb->acb_flag & (RESET_DETECT + RESET_DONE + RESET_DEV))) {\n\t\tlist_add_tail(&srb->list, &dcb->srb_waiting_list);\n\t\twaiting_process_next(acb);\n\t\treturn;\n\t}\n\n\tif (!start_scsi(acb, dcb, srb)) {\n\t\tlist_add_tail(&srb->list, &dcb->srb_going_list);\n\t} else {\n\t\tlist_add(&srb->list, &dcb->srb_waiting_list);\n\t\twaiting_set_timer(acb, HZ / 50);\n\t}\n}\n\n \nstatic void build_srb(struct scsi_cmnd *cmd, struct DeviceCtlBlk *dcb,\n\t\tstruct ScsiReqBlk *srb)\n{\n\tint nseg;\n\tenum dma_data_direction dir = cmd->sc_data_direction;\n\tdprintkdbg(DBG_0, \"build_srb: (0x%p) <%02i-%i>\\n\",\n\t\tcmd, dcb->target_id, dcb->target_lun);\n\n\tsrb->dcb = dcb;\n\tsrb->cmd = cmd;\n\tsrb->sg_count = 0;\n\tsrb->total_xfer_length = 0;\n\tsrb->sg_bus_addr = 0;\n\tsrb->sg_index = 0;\n\tsrb->adapter_status = 0;\n\tsrb->target_status = 0;\n\tsrb->msg_count = 0;\n\tsrb->status = 0;\n\tsrb->flag = 0;\n\tsrb->state = 0;\n\tsrb->retry_count = 0;\n\tsrb->tag_number = TAG_NONE;\n\tsrb->scsi_phase = PH_BUS_FREE;\t \n\tsrb->end_message = 0;\n\n\tnseg = scsi_dma_map(cmd);\n\tBUG_ON(nseg < 0);\n\n\tif (dir == DMA_NONE || !nseg) {\n\t\tdprintkdbg(DBG_0,\n\t\t\t\"build_srb: [0] len=%d buf=%p use_sg=%d !MAP=%08x\\n\",\n\t\t\t   cmd->bufflen, scsi_sglist(cmd), scsi_sg_count(cmd),\n\t\t\t   srb->segment_x[0].address);\n\t} else {\n\t\tint i;\n\t\tu32 reqlen = scsi_bufflen(cmd);\n\t\tstruct scatterlist *sg;\n\t\tstruct SGentry *sgp = srb->segment_x;\n\n\t\tsrb->sg_count = nseg;\n\n\t\tdprintkdbg(DBG_0,\n\t\t\t   \"build_srb: [n] len=%d buf=%p use_sg=%d segs=%d\\n\",\n\t\t\t   reqlen, scsi_sglist(cmd), scsi_sg_count(cmd),\n\t\t\t   srb->sg_count);\n\n\t\tscsi_for_each_sg(cmd, sg, srb->sg_count, i) {\n\t\t\tu32 busaddr = (u32)sg_dma_address(sg);\n\t\t\tu32 seglen = (u32)sg->length;\n\t\t\tsgp[i].address = busaddr;\n\t\t\tsgp[i].length = seglen;\n\t\t\tsrb->total_xfer_length += seglen;\n\t\t}\n\t\tsgp += srb->sg_count - 1;\n\n\t\t \n\t\tif (srb->total_xfer_length > reqlen) {\n\t\t\tsgp->length -= (srb->total_xfer_length - reqlen);\n\t\t\tsrb->total_xfer_length = reqlen;\n\t\t}\n\n\t\t \n\t\tif (dcb->sync_period & WIDE_SYNC &&\n\t\t    srb->total_xfer_length % 2) {\n\t\t\tsrb->total_xfer_length++;\n\t\t\tsgp->length++;\n\t\t}\n\n\t\tsrb->sg_bus_addr = dma_map_single(&dcb->acb->dev->dev,\n\t\t\t\tsrb->segment_x, SEGMENTX_LEN, DMA_TO_DEVICE);\n\n\t\tdprintkdbg(DBG_SG, \"build_srb: [n] map sg %p->%08x(%05x)\\n\",\n\t\t\tsrb->segment_x, srb->sg_bus_addr, SEGMENTX_LEN);\n\t}\n\n\tsrb->request_length = srb->total_xfer_length;\n}\n\n\n \nstatic int dc395x_queue_command_lck(struct scsi_cmnd *cmd)\n{\n\tvoid (*done)(struct scsi_cmnd *) = scsi_done;\n\tstruct DeviceCtlBlk *dcb;\n\tstruct ScsiReqBlk *srb;\n\tstruct AdapterCtlBlk *acb =\n\t    (struct AdapterCtlBlk *)cmd->device->host->hostdata;\n\tdprintkdbg(DBG_0, \"queue_command: (0x%p) <%02i-%i> cmnd=0x%02x\\n\",\n\t\tcmd, cmd->device->id, (u8)cmd->device->lun, cmd->cmnd[0]);\n\n\t \n\tset_host_byte(cmd, DID_BAD_TARGET);\n\n\t \n\tif (cmd->device->id >= acb->scsi_host->max_id ||\n\t    cmd->device->lun >= acb->scsi_host->max_lun ||\n\t    cmd->device->lun >31) {\n\t\tgoto complete;\n\t}\n\n\t \n\tif (!(acb->dcb_map[cmd->device->id] & (1 << cmd->device->lun))) {\n\t\tdprintkl(KERN_INFO, \"queue_command: Ignore target <%02i-%i>\\n\",\n\t\t\tcmd->device->id, (u8)cmd->device->lun);\n\t\tgoto complete;\n\t}\n\n\t \n\tdcb = find_dcb(acb, cmd->device->id, cmd->device->lun);\n\tif (!dcb) {\n\t\t \n\t\tdprintkl(KERN_ERR, \"queue_command: No such device <%02i-%i>\",\n\t\t\tcmd->device->id, (u8)cmd->device->lun);\n\t\tgoto complete;\n\t}\n\n\tset_host_byte(cmd, DID_OK);\n\tset_status_byte(cmd, SAM_STAT_GOOD);\n\n\tsrb = list_first_entry_or_null(&acb->srb_free_list,\n\t\t\tstruct ScsiReqBlk, list);\n\tif (!srb) {\n\t\t \n\t\tdprintkdbg(DBG_0, \"queue_command: No free srb's\\n\");\n\t\treturn 1;\n\t}\n\tlist_del(&srb->list);\n\n\tbuild_srb(cmd, dcb, srb);\n\n\tif (!list_empty(&dcb->srb_waiting_list)) {\n\t\t \n\t\tlist_add_tail(&srb->list, &dcb->srb_waiting_list);\n\t\twaiting_process_next(acb);\n\t} else {\n\t\t \n\t\tsend_srb(acb, srb);\n\t}\n\tdprintkdbg(DBG_1, \"queue_command: (0x%p) done\\n\", cmd);\n\treturn 0;\n\ncomplete:\n\t \n\tdone(cmd);\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(dc395x_queue_command)\n\nstatic void dump_register_info(struct AdapterCtlBlk *acb,\n\t\tstruct DeviceCtlBlk *dcb, struct ScsiReqBlk *srb)\n{\n\tu16 pstat;\n\tstruct pci_dev *dev = acb->dev;\n\tpci_read_config_word(dev, PCI_STATUS, &pstat);\n\tif (!dcb)\n\t\tdcb = acb->active_dcb;\n\tif (!srb && dcb)\n\t\tsrb = dcb->active_srb;\n\tif (srb) {\n\t\tif (!srb->cmd)\n\t\t\tdprintkl(KERN_INFO, \"dump: srb=%p cmd=%p OOOPS!\\n\",\n\t\t\t\tsrb, srb->cmd);\n\t\telse\n\t\t\tdprintkl(KERN_INFO, \"dump: srb=%p cmd=%p \"\n\t\t\t\t \"cmnd=0x%02x <%02i-%i>\\n\",\n\t\t\t\tsrb, srb->cmd,\n\t\t\t\tsrb->cmd->cmnd[0], srb->cmd->device->id,\n\t\t\t\t(u8)srb->cmd->device->lun);\n\t\tprintk(\"  sglist=%p cnt=%i idx=%i len=%zu\\n\",\n\t\t       srb->segment_x, srb->sg_count, srb->sg_index,\n\t\t       srb->total_xfer_length);\n\t\tprintk(\"  state=0x%04x status=0x%02x phase=0x%02x (%sconn.)\\n\",\n\t\t       srb->state, srb->status, srb->scsi_phase,\n\t\t       (acb->active_dcb) ? \"\" : \"not\");\n\t}\n\tdprintkl(KERN_INFO, \"dump: SCSI{status=0x%04x fifocnt=0x%02x \"\n\t\t\"signals=0x%02x irqstat=0x%02x sync=0x%02x target=0x%02x \"\n\t\t\"rselid=0x%02x ctr=0x%08x irqen=0x%02x config=0x%04x \"\n\t\t\"config2=0x%02x cmd=0x%02x selto=0x%02x}\\n\",\n\t\tDC395x_read16(acb, TRM_S1040_SCSI_STATUS),\n\t\tDC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT),\n\t\tDC395x_read8(acb, TRM_S1040_SCSI_SIGNAL),\n\t\tDC395x_read8(acb, TRM_S1040_SCSI_INTSTATUS),\n\t\tDC395x_read8(acb, TRM_S1040_SCSI_SYNC),\n\t\tDC395x_read8(acb, TRM_S1040_SCSI_TARGETID),\n\t\tDC395x_read8(acb, TRM_S1040_SCSI_IDMSG),\n\t\tDC395x_read32(acb, TRM_S1040_SCSI_COUNTER),\n\t\tDC395x_read8(acb, TRM_S1040_SCSI_INTEN),\n\t\tDC395x_read16(acb, TRM_S1040_SCSI_CONFIG0),\n\t\tDC395x_read8(acb, TRM_S1040_SCSI_CONFIG2),\n\t\tDC395x_read8(acb, TRM_S1040_SCSI_COMMAND),\n\t\tDC395x_read8(acb, TRM_S1040_SCSI_TIMEOUT));\n\tdprintkl(KERN_INFO, \"dump: DMA{cmd=0x%04x fifocnt=0x%02x fstat=0x%02x \"\n\t\t\"irqstat=0x%02x irqen=0x%02x cfg=0x%04x tctr=0x%08x \"\n\t\t\"ctctr=0x%08x addr=0x%08x:0x%08x}\\n\",\n\t\tDC395x_read16(acb, TRM_S1040_DMA_COMMAND),\n\t\tDC395x_read8(acb, TRM_S1040_DMA_FIFOCNT),\n\t\tDC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT),\n\t\tDC395x_read8(acb, TRM_S1040_DMA_STATUS),\n\t\tDC395x_read8(acb, TRM_S1040_DMA_INTEN),\n\t\tDC395x_read16(acb, TRM_S1040_DMA_CONFIG),\n\t\tDC395x_read32(acb, TRM_S1040_DMA_XCNT),\n\t\tDC395x_read32(acb, TRM_S1040_DMA_CXCNT),\n\t\tDC395x_read32(acb, TRM_S1040_DMA_XHIGHADDR),\n\t\tDC395x_read32(acb, TRM_S1040_DMA_XLOWADDR));\n\tdprintkl(KERN_INFO, \"dump: gen{gctrl=0x%02x gstat=0x%02x gtmr=0x%02x} \"\n\t\t\"pci{status=0x%04x}\\n\",\n\t\tDC395x_read8(acb, TRM_S1040_GEN_CONTROL),\n\t\tDC395x_read8(acb, TRM_S1040_GEN_STATUS),\n\t\tDC395x_read8(acb, TRM_S1040_GEN_TIMER),\n\t\tpstat);\n}\n\n\nstatic inline void clear_fifo(struct AdapterCtlBlk *acb, char *txt)\n{\n#if debug_enabled(DBG_FIFO)\n\tu8 lines = DC395x_read8(acb, TRM_S1040_SCSI_SIGNAL);\n\tu8 fifocnt = DC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT);\n\tif (!(fifocnt & 0x40))\n\t\tdprintkdbg(DBG_FIFO,\n\t\t\t\"clear_fifo: (%i bytes) on phase %02x in %s\\n\",\n\t\t\tfifocnt & 0x3f, lines, txt);\n#endif\n\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_CLRFIFO);\n}\n\n\nstatic void reset_dev_param(struct AdapterCtlBlk *acb)\n{\n\tstruct DeviceCtlBlk *dcb;\n\tstruct NvRamType *eeprom = &acb->eeprom;\n\tdprintkdbg(DBG_0, \"reset_dev_param: acb=%p\\n\", acb);\n\n\tlist_for_each_entry(dcb, &acb->dcb_list, list) {\n\t\tu8 period_index;\n\n\t\tdcb->sync_mode &= ~(SYNC_NEGO_DONE + WIDE_NEGO_DONE);\n\t\tdcb->sync_period = 0;\n\t\tdcb->sync_offset = 0;\n\n\t\tdcb->dev_mode = eeprom->target[dcb->target_id].cfg0;\n\t\tperiod_index = eeprom->target[dcb->target_id].period & 0x07;\n\t\tdcb->min_nego_period = clock_period[period_index];\n\t\tif (!(dcb->dev_mode & NTC_DO_WIDE_NEGO)\n\t\t    || !(acb->config & HCC_WIDE_CARD))\n\t\t\tdcb->sync_mode &= ~WIDE_NEGO_ENABLE;\n\t}\n}\n\n\n \nstatic int __dc395x_eh_bus_reset(struct scsi_cmnd *cmd)\n{\n\tstruct AdapterCtlBlk *acb =\n\t\t(struct AdapterCtlBlk *)cmd->device->host->hostdata;\n\tdprintkl(KERN_INFO,\n\t\t\"eh_bus_reset: (0%p) target=<%02i-%i> cmd=%p\\n\",\n\t\tcmd, cmd->device->id, (u8)cmd->device->lun, cmd);\n\n\tif (timer_pending(&acb->waiting_timer))\n\t\tdel_timer(&acb->waiting_timer);\n\n\t \n\tDC395x_write8(acb, TRM_S1040_DMA_INTEN, 0x00);\n\tDC395x_write8(acb, TRM_S1040_SCSI_INTEN, 0x00);\n\tDC395x_write8(acb, TRM_S1040_SCSI_CONTROL, DO_RSTMODULE);\n\tDC395x_write8(acb, TRM_S1040_DMA_CONTROL, DMARESETMODULE);\n\n\treset_scsi_bus(acb);\n\tudelay(500);\n\n\t \n\tacb->last_reset =\n\t    jiffies + 3 * HZ / 2 +\n\t    HZ * acb->eeprom.delay_time;\n\n\t \n\t \n\tDC395x_write8(acb, TRM_S1040_DMA_CONTROL, CLRXFIFO);\n\tclear_fifo(acb, \"eh_bus_reset\");\n\t \n\tDC395x_read8(acb, TRM_S1040_SCSI_INTSTATUS);\n\tset_basic_config(acb);\n\n\treset_dev_param(acb);\n\tdoing_srb_done(acb, DID_RESET, cmd, 0);\n\tacb->active_dcb = NULL;\n\tacb->acb_flag = 0;\t \n\twaiting_process_next(acb);\n\n\treturn SUCCESS;\n}\n\nstatic int dc395x_eh_bus_reset(struct scsi_cmnd *cmd)\n{\n\tint rc;\n\n\tspin_lock_irq(cmd->device->host->host_lock);\n\trc = __dc395x_eh_bus_reset(cmd);\n\tspin_unlock_irq(cmd->device->host->host_lock);\n\n\treturn rc;\n}\n\n \nstatic int dc395x_eh_abort(struct scsi_cmnd *cmd)\n{\n\t \n\tstruct AdapterCtlBlk *acb =\n\t    (struct AdapterCtlBlk *)cmd->device->host->hostdata;\n\tstruct DeviceCtlBlk *dcb;\n\tstruct ScsiReqBlk *srb;\n\tdprintkl(KERN_INFO, \"eh_abort: (0x%p) target=<%02i-%i> cmd=%p\\n\",\n\t\tcmd, cmd->device->id, (u8)cmd->device->lun, cmd);\n\n\tdcb = find_dcb(acb, cmd->device->id, cmd->device->lun);\n\tif (!dcb) {\n\t\tdprintkl(KERN_DEBUG, \"eh_abort: No such device\\n\");\n\t\treturn FAILED;\n\t}\n\n\tsrb = find_cmd(cmd, &dcb->srb_waiting_list);\n\tif (srb) {\n\t\tlist_del(&srb->list);\n\t\tpci_unmap_srb_sense(acb, srb);\n\t\tpci_unmap_srb(acb, srb);\n\t\tfree_tag(dcb, srb);\n\t\tlist_add_tail(&srb->list, &acb->srb_free_list);\n\t\tdprintkl(KERN_DEBUG, \"eh_abort: Command was waiting\\n\");\n\t\tset_host_byte(cmd, DID_ABORT);\n\t\treturn SUCCESS;\n\t}\n\tsrb = find_cmd(cmd, &dcb->srb_going_list);\n\tif (srb) {\n\t\tdprintkl(KERN_DEBUG, \"eh_abort: Command in progress\\n\");\n\t\t \n\t} else {\n\t\tdprintkl(KERN_DEBUG, \"eh_abort: Command not found\\n\");\n\t}\n\treturn FAILED;\n}\n\n\n \nstatic void build_sdtr(struct AdapterCtlBlk *acb, struct DeviceCtlBlk *dcb,\n\t\tstruct ScsiReqBlk *srb)\n{\n\tu8 *ptr = srb->msgout_buf + srb->msg_count;\n\tif (srb->msg_count > 1) {\n\t\tdprintkl(KERN_INFO,\n\t\t\t\"build_sdtr: msgout_buf BUSY (%i: %02x %02x)\\n\",\n\t\t\tsrb->msg_count, srb->msgout_buf[0],\n\t\t\tsrb->msgout_buf[1]);\n\t\treturn;\n\t}\n\tif (!(dcb->dev_mode & NTC_DO_SYNC_NEGO)) {\n\t\tdcb->sync_offset = 0;\n\t\tdcb->min_nego_period = 200 >> 2;\n\t} else if (dcb->sync_offset == 0)\n\t\tdcb->sync_offset = SYNC_NEGO_OFFSET;\n\n\tsrb->msg_count += spi_populate_sync_msg(ptr, dcb->min_nego_period,\n\t\t\t\t\t\tdcb->sync_offset);\n\tsrb->state |= SRB_DO_SYNC_NEGO;\n}\n\n\n \nstatic void build_wdtr(struct AdapterCtlBlk *acb, struct DeviceCtlBlk *dcb,\n\t\tstruct ScsiReqBlk *srb)\n{\n\tu8 wide = ((dcb->dev_mode & NTC_DO_WIDE_NEGO) &\n\t\t   (acb->config & HCC_WIDE_CARD)) ? 1 : 0;\n\tu8 *ptr = srb->msgout_buf + srb->msg_count;\n\tif (srb->msg_count > 1) {\n\t\tdprintkl(KERN_INFO,\n\t\t\t\"build_wdtr: msgout_buf BUSY (%i: %02x %02x)\\n\",\n\t\t\tsrb->msg_count, srb->msgout_buf[0],\n\t\t\tsrb->msgout_buf[1]);\n\t\treturn;\n\t}\n\tsrb->msg_count += spi_populate_width_msg(ptr, wide);\n\tsrb->state |= SRB_DO_WIDE_NEGO;\n}\n\n\n#if 0\n \nvoid selection_timeout_missed(unsigned long ptr);\n \nstatic void selto_timer(struct AdapterCtlBlk *acb)\n{\n\tif (timer_pending(&acb->selto_timer))\n\t\treturn;\n\tacb->selto_timer.function = selection_timeout_missed;\n\tacb->selto_timer.data = (unsigned long) acb;\n\tif (time_before\n\t    (jiffies + HZ, acb->last_reset + HZ / 2))\n\t\tacb->selto_timer.expires =\n\t\t    acb->last_reset + HZ / 2 + 1;\n\telse\n\t\tacb->selto_timer.expires = jiffies + HZ + 1;\n\tadd_timer(&acb->selto_timer);\n}\n\n\nvoid selection_timeout_missed(unsigned long ptr)\n{\n\tunsigned long flags;\n\tstruct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)ptr;\n\tstruct ScsiReqBlk *srb;\n\tdprintkl(KERN_DEBUG, \"Chip forgot to produce SelTO IRQ!\\n\");\n\tif (!acb->active_dcb || !acb->active_dcb->active_srb) {\n\t\tdprintkl(KERN_DEBUG, \"... but no cmd pending? Oops!\\n\");\n\t\treturn;\n\t}\n\tDC395x_LOCK_IO(acb->scsi_host, flags);\n\tsrb = acb->active_dcb->active_srb;\n\tdisconnect(acb);\n\tDC395x_UNLOCK_IO(acb->scsi_host, flags);\n}\n#endif\n\n\nstatic u8 start_scsi(struct AdapterCtlBlk* acb, struct DeviceCtlBlk* dcb,\n\t\tstruct ScsiReqBlk* srb)\n{\n\tu16 __maybe_unused s_stat2, return_code;\n\tu8 s_stat, scsicommand, i, identify_message;\n\tu8 *ptr;\n\tdprintkdbg(DBG_0, \"start_scsi: (0x%p) <%02i-%i> srb=%p\\n\",\n\t\tdcb->target_id, dcb->target_lun, srb);\n\n\tsrb->tag_number = TAG_NONE;\t \n\n\ts_stat = DC395x_read8(acb, TRM_S1040_SCSI_SIGNAL);\n\ts_stat2 = 0;\n\ts_stat2 = DC395x_read16(acb, TRM_S1040_SCSI_STATUS);\n#if 1\n\tif (s_stat & 0x20   ) {\n\t\tdprintkdbg(DBG_KG, \"start_scsi: (0x%p) BUSY %02x %04x\\n\",\n\t\t\ts_stat, s_stat2);\n\t\t \n\t\t \n\t\treturn 1;\n\t}\n#endif\n\tif (acb->active_dcb) {\n\t\tdprintkl(KERN_DEBUG, \"start_scsi: (0x%p) Attempt to start a\"\n\t\t\t\"command while another command (0x%p) is active.\",\n\t\t\tsrb->cmd,\n\t\t\tacb->active_dcb->active_srb ?\n\t\t\t    acb->active_dcb->active_srb->cmd : 0);\n\t\treturn 1;\n\t}\n\tif (DC395x_read16(acb, TRM_S1040_SCSI_STATUS) & SCSIINTERRUPT) {\n\t\tdprintkdbg(DBG_KG, \"start_scsi: (0x%p) Failed (busy)\\n\", srb->cmd);\n\t\treturn 1;\n\t}\n\t \n\tif (time_before(jiffies, acb->last_reset - HZ / 2)) {\n\t\tdprintkdbg(DBG_KG, \"start_scsi: Refuse cmds (reset wait)\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tclear_fifo(acb, \"start_scsi\");\n\tDC395x_write8(acb, TRM_S1040_SCSI_HOSTID, acb->scsi_host->this_id);\n\tDC395x_write8(acb, TRM_S1040_SCSI_TARGETID, dcb->target_id);\n\tDC395x_write8(acb, TRM_S1040_SCSI_SYNC, dcb->sync_period);\n\tDC395x_write8(acb, TRM_S1040_SCSI_OFFSET, dcb->sync_offset);\n\tsrb->scsi_phase = PH_BUS_FREE;\t \n\n\tidentify_message = dcb->identify_msg;\n\t \n\t \n\tif (srb->flag & AUTO_REQSENSE)\n\t\tidentify_message &= 0xBF;\n\n\tif (((srb->cmd->cmnd[0] == INQUIRY)\n\t     || (srb->cmd->cmnd[0] == REQUEST_SENSE)\n\t     || (srb->flag & AUTO_REQSENSE))\n\t    && (((dcb->sync_mode & WIDE_NEGO_ENABLE)\n\t\t && !(dcb->sync_mode & WIDE_NEGO_DONE))\n\t\t|| ((dcb->sync_mode & SYNC_NEGO_ENABLE)\n\t\t    && !(dcb->sync_mode & SYNC_NEGO_DONE)))\n\t    && (dcb->target_lun == 0)) {\n\t\tsrb->msgout_buf[0] = identify_message;\n\t\tsrb->msg_count = 1;\n\t\tscsicommand = SCMD_SEL_ATNSTOP;\n\t\tsrb->state = SRB_MSGOUT;\n#ifndef SYNC_FIRST\n\t\tif (dcb->sync_mode & WIDE_NEGO_ENABLE\n\t\t    && dcb->inquiry7 & SCSI_INQ_WBUS16) {\n\t\t\tbuild_wdtr(acb, dcb, srb);\n\t\t\tgoto no_cmd;\n\t\t}\n#endif\n\t\tif (dcb->sync_mode & SYNC_NEGO_ENABLE\n\t\t    && dcb->inquiry7 & SCSI_INQ_SYNC) {\n\t\t\tbuild_sdtr(acb, dcb, srb);\n\t\t\tgoto no_cmd;\n\t\t}\n\t\tif (dcb->sync_mode & WIDE_NEGO_ENABLE\n\t\t    && dcb->inquiry7 & SCSI_INQ_WBUS16) {\n\t\t\tbuild_wdtr(acb, dcb, srb);\n\t\t\tgoto no_cmd;\n\t\t}\n\t\tsrb->msg_count = 0;\n\t}\n\t \n\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, identify_message);\n\n\tscsicommand = SCMD_SEL_ATN;\n\tsrb->state = SRB_START_;\n#ifndef DC395x_NO_TAGQ\n\tif ((dcb->sync_mode & EN_TAG_QUEUEING)\n\t    && (identify_message & 0xC0)) {\n\t\t \n\t\tu32 tag_mask = 1;\n\t\tu8 tag_number = 0;\n\t\twhile (tag_mask & dcb->tag_mask\n\t\t       && tag_number < dcb->max_command) {\n\t\t\ttag_mask = tag_mask << 1;\n\t\t\ttag_number++;\n\t\t}\n\t\tif (tag_number >= dcb->max_command) {\n\t\t\tdprintkl(KERN_WARNING, \"start_scsi: (0x%p) \"\n\t\t\t\t\"Out of tags target=<%02i-%i>)\\n\",\n\t\t\t\tsrb->cmd, srb->cmd->device->id,\n\t\t\t\t(u8)srb->cmd->device->lun);\n\t\t\tsrb->state = SRB_READY;\n\t\t\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL,\n\t\t\t\t       DO_HWRESELECT);\n\t\t\treturn 1;\n\t\t}\n\t\t \n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, SIMPLE_QUEUE_TAG);\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, tag_number);\n\t\tdcb->tag_mask |= tag_mask;\n\t\tsrb->tag_number = tag_number;\n\t\tscsicommand = SCMD_SEL_ATN3;\n\t\tsrb->state = SRB_START_;\n\t}\n#endif\n \n\t \n\tdprintkdbg(DBG_KG, \"start_scsi: (0x%p) <%02i-%i> cmnd=0x%02x tag=%i\\n\",\n\t\tsrb->cmd, srb->cmd->device->id, (u8)srb->cmd->device->lun,\n\t\tsrb->cmd->cmnd[0], srb->tag_number);\n\tif (srb->flag & AUTO_REQSENSE) {\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, REQUEST_SENSE);\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, (dcb->target_lun << 5));\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 0);\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 0);\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, SCSI_SENSE_BUFFERSIZE);\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 0);\n\t} else {\n\t\tptr = (u8 *)srb->cmd->cmnd;\n\t\tfor (i = 0; i < srb->cmd->cmd_len; i++)\n\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, *ptr++);\n\t}\n      no_cmd:\n\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL,\n\t\t       DO_HWRESELECT | DO_DATALATCH);\n\tif (DC395x_read16(acb, TRM_S1040_SCSI_STATUS) & SCSIINTERRUPT) {\n\t\t \n\t\tdprintkdbg(DBG_0, \"start_scsi: (0x%p) <%02i-%i> Failed - busy\\n\",\n\t\t\tsrb->cmd, dcb->target_id, dcb->target_lun);\n\t\tsrb->state = SRB_READY;\n\t\tfree_tag(dcb, srb);\n\t\tsrb->msg_count = 0;\n\t\treturn_code = 1;\n\t\t \n\t} else {\n\t\t \n\t\tsrb->scsi_phase = PH_BUS_FREE;\t \n\t\tdcb->active_srb = srb;\n\t\tacb->active_dcb = dcb;\n\t\treturn_code = 0;\n\t\t \n\t\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL,\n\t\t\t       DO_DATALATCH | DO_HWRESELECT);\n\t\t \n\t\tDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, scsicommand);\n\t}\n\treturn return_code;\n}\n\n\n#define DC395x_ENABLE_MSGOUT \\\n DC395x_write16 (acb, TRM_S1040_SCSI_CONTROL, DO_SETATN); \\\n srb->state |= SRB_MSGOUT\n\n\n \nstatic inline void enable_msgout_abort(struct AdapterCtlBlk *acb,\n\t\tstruct ScsiReqBlk *srb)\n{\n\tsrb->msgout_buf[0] = ABORT;\n\tsrb->msg_count = 1;\n\tDC395x_ENABLE_MSGOUT;\n\tsrb->state &= ~SRB_MSGIN;\n\tsrb->state |= SRB_MSGOUT;\n}\n\n\n \nstatic void dc395x_handle_interrupt(struct AdapterCtlBlk *acb,\n\t\tu16 scsi_status)\n{\n\tstruct DeviceCtlBlk *dcb;\n\tstruct ScsiReqBlk *srb;\n\tu16 phase;\n\tu8 scsi_intstatus;\n\tunsigned long flags;\n\tvoid (*dc395x_statev)(struct AdapterCtlBlk *, struct ScsiReqBlk *, \n\t\t\t      u16 *);\n\n\tDC395x_LOCK_IO(acb->scsi_host, flags);\n\n\t \n\tscsi_intstatus = DC395x_read8(acb, TRM_S1040_SCSI_INTSTATUS);\n\tif ((scsi_status & 0x2007) == 0x2002)\n\t\tdprintkl(KERN_DEBUG,\n\t\t\t\"COP after COP completed? %04x\\n\", scsi_status);\n\tif (debug_enabled(DBG_KG)) {\n\t\tif (scsi_intstatus & INT_SELTIMEOUT)\n\t\t\tdprintkdbg(DBG_KG, \"handle_interrupt: Selection timeout\\n\");\n\t}\n\t \n\n\tif (timer_pending(&acb->selto_timer))\n\t\tdel_timer(&acb->selto_timer);\n\n\tif (scsi_intstatus & (INT_SELTIMEOUT | INT_DISCONNECT)) {\n\t\tdisconnect(acb);\t \n\t\tgoto out_unlock;\n\t}\n\tif (scsi_intstatus & INT_RESELECTED) {\n\t\treselect(acb);\n\t\tgoto out_unlock;\n\t}\n\tif (scsi_intstatus & INT_SELECT) {\n\t\tdprintkl(KERN_INFO, \"Host does not support target mode!\\n\");\n\t\tgoto out_unlock;\n\t}\n\tif (scsi_intstatus & INT_SCSIRESET) {\n\t\tscsi_reset_detect(acb);\n\t\tgoto out_unlock;\n\t}\n\tif (scsi_intstatus & (INT_BUSSERVICE | INT_CMDDONE)) {\n\t\tdcb = acb->active_dcb;\n\t\tif (!dcb) {\n\t\t\tdprintkl(KERN_DEBUG,\n\t\t\t\t\"Oops: BusService (%04x %02x) w/o ActiveDCB!\\n\",\n\t\t\t\tscsi_status, scsi_intstatus);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tsrb = dcb->active_srb;\n\t\tif (dcb->flag & ABORT_DEV_) {\n\t\t\tdprintkdbg(DBG_0, \"MsgOut Abort Device.....\\n\");\n\t\t\tenable_msgout_abort(acb, srb);\n\t\t}\n\n\t\t \n\t\tphase = (u16)srb->scsi_phase;\n\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\tdc395x_statev = dc395x_scsi_phase0[phase];\n\t\tdc395x_statev(acb, srb, &scsi_status);\n\n\t\t \n\t\tsrb->scsi_phase = scsi_status & PHASEMASK;\n\t\tphase = (u16)scsi_status & PHASEMASK;\n\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\tdc395x_statev = dc395x_scsi_phase1[phase];\n\t\tdc395x_statev(acb, srb, &scsi_status);\n\t}\n      out_unlock:\n\tDC395x_UNLOCK_IO(acb->scsi_host, flags);\n}\n\n\nstatic irqreturn_t dc395x_interrupt(int irq, void *dev_id)\n{\n\tstruct AdapterCtlBlk *acb = dev_id;\n\tu16 scsi_status;\n\tu8 dma_status;\n\tirqreturn_t handled = IRQ_NONE;\n\n\t \n\tscsi_status = DC395x_read16(acb, TRM_S1040_SCSI_STATUS);\n\tdma_status = DC395x_read8(acb, TRM_S1040_DMA_STATUS);\n\tif (scsi_status & SCSIINTERRUPT) {\n\t\t \n\t\tdc395x_handle_interrupt(acb, scsi_status);\n\t\thandled = IRQ_HANDLED;\n\t}\n\telse if (dma_status & 0x20) {\n\t\t \n\t\tdprintkl(KERN_INFO, \"Interrupt from DMA engine: 0x%02x!\\n\", dma_status);\n#if 0\n\t\tdprintkl(KERN_INFO, \"This means DMA error! Try to handle ...\\n\");\n\t\tif (acb->active_dcb) {\n\t\t\tacb->active_dcb-> flag |= ABORT_DEV_;\n\t\t\tif (acb->active_dcb->active_srb)\n\t\t\t\tenable_msgout_abort(acb, acb->active_dcb->active_srb);\n\t\t}\n\t\tDC395x_write8(acb, TRM_S1040_DMA_CONTROL, ABORTXFER | CLRXFIFO);\n#else\n\t\tdprintkl(KERN_INFO, \"Ignoring DMA error (probably a bad thing) ...\\n\");\n\t\tacb = NULL;\n#endif\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\treturn handled;\n}\n\n\nstatic void msgout_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status)\n{\n\tdprintkdbg(DBG_0, \"msgout_phase0: (0x%p)\\n\", srb->cmd);\n\tif (srb->state & (SRB_UNEXPECT_RESEL + SRB_ABORT_SENT))\n\t\t*pscsi_status = PH_BUS_FREE;\t \n\n\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\t \n\tsrb->state &= ~SRB_MSGOUT;\n}\n\n\nstatic void msgout_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status)\n{\n\tu16 i;\n\tu8 *ptr;\n\tdprintkdbg(DBG_0, \"msgout_phase1: (0x%p)\\n\", srb->cmd);\n\n\tclear_fifo(acb, \"msgout_phase1\");\n\tif (!(srb->state & SRB_MSGOUT)) {\n\t\tsrb->state |= SRB_MSGOUT;\n\t\tdprintkl(KERN_DEBUG,\n\t\t\t\"msgout_phase1: (0x%p) Phase unexpected\\n\",\n\t\t\tsrb->cmd);\t \n\t}\n\tif (!srb->msg_count) {\n\t\tdprintkdbg(DBG_0, \"msgout_phase1: (0x%p) NOP msg\\n\",\n\t\t\tsrb->cmd);\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, NOP);\n\t\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\n\t\t \n\t\tDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_FIFO_OUT);\n\t\treturn;\n\t}\n\tptr = (u8 *)srb->msgout_buf;\n\tfor (i = 0; i < srb->msg_count; i++)\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, *ptr++);\n\tsrb->msg_count = 0;\n\tif (srb->msgout_buf[0] == ABORT_TASK_SET)\n\t\tsrb->state = SRB_ABORT_SENT;\n\n\tDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_FIFO_OUT);\n}\n\n\nstatic void command_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status)\n{\n\tdprintkdbg(DBG_0, \"command_phase0: (0x%p)\\n\", srb->cmd);\n\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\n}\n\n\nstatic void command_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status)\n{\n\tstruct DeviceCtlBlk *dcb;\n\tu8 *ptr;\n\tu16 i;\n\tdprintkdbg(DBG_0, \"command_phase1: (0x%p)\\n\", srb->cmd);\n\n\tclear_fifo(acb, \"command_phase1\");\n\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_CLRATN);\n\tif (!(srb->flag & AUTO_REQSENSE)) {\n\t\tptr = (u8 *)srb->cmd->cmnd;\n\t\tfor (i = 0; i < srb->cmd->cmd_len; i++) {\n\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, *ptr);\n\t\t\tptr++;\n\t\t}\n\t} else {\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, REQUEST_SENSE);\n\t\tdcb = acb->active_dcb;\n\t\t \n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, (dcb->target_lun << 5));\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 0);\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 0);\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, SCSI_SENSE_BUFFERSIZE);\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 0);\n\t}\n\tsrb->state |= SRB_COMMAND;\n\t \n\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\n\t \n\tDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_FIFO_OUT);\n}\n\n\n \nstatic void sg_verify_length(struct ScsiReqBlk *srb)\n{\n\tif (debug_enabled(DBG_SG)) {\n\t\tunsigned len = 0;\n\t\tunsigned idx = srb->sg_index;\n\t\tstruct SGentry *psge = srb->segment_x + idx;\n\t\tfor (; idx < srb->sg_count; psge++, idx++)\n\t\t\tlen += psge->length;\n\t\tif (len != srb->total_xfer_length)\n\t\t\tdprintkdbg(DBG_SG,\n\t\t\t       \"Inconsistent SRB S/G lengths (Tot=%i, Count=%i) !!\\n\",\n\t\t\t       srb->total_xfer_length, len);\n\t}\t\t\t       \n}\n\n\n \nstatic void sg_update_list(struct ScsiReqBlk *srb, u32 left)\n{\n\tu8 idx;\n\tu32 xferred = srb->total_xfer_length - left;  \n\tstruct SGentry *psge = srb->segment_x + srb->sg_index;\n\n\tdprintkdbg(DBG_0,\n\t\t\"sg_update_list: Transferred %i of %i bytes, %i remain\\n\",\n\t\txferred, srb->total_xfer_length, left);\n\tif (xferred == 0) {\n\t\t \n\t\treturn;\n\t}\n\n\tsg_verify_length(srb);\n\tsrb->total_xfer_length = left;\t \n\tfor (idx = srb->sg_index; idx < srb->sg_count; idx++) {\n\t\tif (xferred >= psge->length) {\n\t\t\t \n\t\t\txferred -= psge->length;\n\t\t} else {\n\t\t\t \n\t\t\tdma_sync_single_for_cpu(&srb->dcb->acb->dev->dev,\n\t\t\t\t\tsrb->sg_bus_addr, SEGMENTX_LEN,\n\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\tpsge->length -= xferred;\n\t\t\tpsge->address += xferred;\n\t\t\tsrb->sg_index = idx;\n\t\t\tdma_sync_single_for_device(&srb->dcb->acb->dev->dev,\n\t\t\t\t\tsrb->sg_bus_addr, SEGMENTX_LEN,\n\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\tbreak;\n\t\t}\n\t\tpsge++;\n\t}\n\tsg_verify_length(srb);\n}\n\n\n \nstatic void sg_subtract_one(struct ScsiReqBlk *srb)\n{\n\tsg_update_list(srb, srb->total_xfer_length - 1);\n}\n\n\n \nstatic void cleanup_after_transfer(struct AdapterCtlBlk *acb,\n\t\tstruct ScsiReqBlk *srb)\n{\n\t \n\tif (DC395x_read16(acb, TRM_S1040_DMA_COMMAND) & 0x0001) {\t \n\t\tif (!(DC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT) & 0x40))\n\t\t\tclear_fifo(acb, \"cleanup/in\");\n\t\tif (!(DC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT) & 0x80))\n\t\t\tDC395x_write8(acb, TRM_S1040_DMA_CONTROL, CLRXFIFO);\n\t} else {\t\t \n\t\tif (!(DC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT) & 0x80))\n\t\t\tDC395x_write8(acb, TRM_S1040_DMA_CONTROL, CLRXFIFO);\n\t\tif (!(DC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT) & 0x40))\n\t\t\tclear_fifo(acb, \"cleanup/out\");\n\t}\n\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\n}\n\n\n \n#define DC395x_LASTPIO 4\n\n\nstatic void data_out_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status)\n{\n\tstruct DeviceCtlBlk *dcb = srb->dcb;\n\tu16 scsi_status = *pscsi_status;\n\tu32 d_left_counter = 0;\n\tdprintkdbg(DBG_0, \"data_out_phase0: (0x%p) <%02i-%i>\\n\",\n\t\tsrb->cmd, srb->cmd->device->id, (u8)srb->cmd->device->lun);\n\n\t \n\t \n\tdprintkdbg(DBG_PIO, \"data_out_phase0: \"\n\t\t\"DMA{fifocnt=0x%02x fifostat=0x%02x} \"\n\t\t\"SCSI{fifocnt=0x%02x cnt=0x%06x status=0x%04x} total=0x%06x\\n\",\n\t\tDC395x_read8(acb, TRM_S1040_DMA_FIFOCNT),\n\t\tDC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT),\n\t\tDC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT),\n\t\tDC395x_read32(acb, TRM_S1040_SCSI_COUNTER), scsi_status,\n\t\tsrb->total_xfer_length);\n\tDC395x_write8(acb, TRM_S1040_DMA_CONTROL, STOPDMAXFER | CLRXFIFO);\n\n\tif (!(srb->state & SRB_XFERPAD)) {\n\t\tif (scsi_status & PARITYERROR)\n\t\t\tsrb->status |= PARITY_ERROR;\n\n\t\t \n\t\tif (!(scsi_status & SCSIXFERDONE)) {\n\t\t\t \n\t\t\td_left_counter =\n\t\t\t    (u32)(DC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT) &\n\t\t\t\t  0x1F);\n\t\t\tif (dcb->sync_period & WIDE_SYNC)\n\t\t\t\td_left_counter <<= 1;\n\n\t\t\tdprintkdbg(DBG_KG, \"data_out_phase0: FIFO contains %i %s\\n\"\n\t\t\t\t\"SCSI{fifocnt=0x%02x cnt=0x%08x} \"\n\t\t\t\t\"DMA{fifocnt=0x%04x cnt=0x%02x ctr=0x%08x}\\n\",\n\t\t\t\tDC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT),\n\t\t\t\t(dcb->sync_period & WIDE_SYNC) ? \"words\" : \"bytes\",\n\t\t\t\tDC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT),\n\t\t\t\tDC395x_read32(acb, TRM_S1040_SCSI_COUNTER),\n\t\t\t\tDC395x_read8(acb, TRM_S1040_DMA_FIFOCNT),\n\t\t\t\tDC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT),\n\t\t\t\tDC395x_read32(acb, TRM_S1040_DMA_CXCNT));\n\t\t}\n\t\t \n\t\tif (srb->total_xfer_length > DC395x_LASTPIO)\n\t\t\td_left_counter +=\n\t\t\t    DC395x_read32(acb, TRM_S1040_SCSI_COUNTER);\n\n\t\t \n\t\t \n\t\t \n\t\tif (d_left_counter == 1 && dcb->sync_period & WIDE_SYNC\n\t\t    && scsi_bufflen(srb->cmd) % 2) {\n\t\t\td_left_counter = 0;\n\t\t\tdprintkl(KERN_INFO,\n\t\t\t\t\"data_out_phase0: Discard 1 byte (0x%02x)\\n\",\n\t\t\t\tscsi_status);\n\t\t}\n\t\t \n\t\t \n\t\tif (d_left_counter == 0) {\n\t\t\tsrb->total_xfer_length = 0;\n\t\t} else {\n\t\t\t \n\t\t\tlong oldxferred =\n\t\t\t    srb->total_xfer_length - d_left_counter;\n\t\t\tconst int diff =\n\t\t\t    (dcb->sync_period & WIDE_SYNC) ? 2 : 1;\n\t\t\tsg_update_list(srb, d_left_counter);\n\t\t\t \n\t\t\tif ((srb->segment_x[srb->sg_index].length ==\n\t\t\t     diff && scsi_sg_count(srb->cmd))\n\t\t\t    || ((oldxferred & ~PAGE_MASK) ==\n\t\t\t\t(PAGE_SIZE - diff))\n\t\t\t    ) {\n\t\t\t\tdprintkl(KERN_INFO, \"data_out_phase0: \"\n\t\t\t\t\t\"Work around chip bug (%i)?\\n\", diff);\n\t\t\t\td_left_counter =\n\t\t\t\t    srb->total_xfer_length - diff;\n\t\t\t\tsg_update_list(srb, d_left_counter);\n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t}\n\t\t}\n\t}\n\tif ((*pscsi_status & PHASEMASK) != PH_DATA_OUT) {\n\t\tcleanup_after_transfer(acb, srb);\n\t}\n}\n\n\nstatic void data_out_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status)\n{\n\tdprintkdbg(DBG_0, \"data_out_phase1: (0x%p) <%02i-%i>\\n\",\n\t\tsrb->cmd, srb->cmd->device->id, (u8)srb->cmd->device->lun);\n\tclear_fifo(acb, \"data_out_phase1\");\n\t \n\tdata_io_transfer(acb, srb, XFERDATAOUT);\n}\n\nstatic void data_in_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status)\n{\n\tu16 scsi_status = *pscsi_status;\n\n\tdprintkdbg(DBG_0, \"data_in_phase0: (0x%p) <%02i-%i>\\n\",\n\t\tsrb->cmd, srb->cmd->device->id, (u8)srb->cmd->device->lun);\n\n\t \n\tif (!(srb->state & SRB_XFERPAD)) {\n\t\tu32 d_left_counter;\n\t\tunsigned int sc, fc;\n\n\t\tif (scsi_status & PARITYERROR) {\n\t\t\tdprintkl(KERN_INFO, \"data_in_phase0: (0x%p) \"\n\t\t\t\t\"Parity Error\\n\", srb->cmd);\n\t\t\tsrb->status |= PARITY_ERROR;\n\t\t}\n\t\t \n\t\tif (!(DC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT) & 0x80)) {\n#if 0\n\t\t\tint ctr = 6000000;\n\t\t\tdprintkl(KERN_DEBUG,\n\t\t\t\t\"DIP0: Wait for DMA FIFO to flush ...\\n\");\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\twhile (!\n\t\t\t       (DC395x_read16(acb, TRM_S1040_DMA_FIFOSTAT) &\n\t\t\t\t0x80) && --ctr);\n\t\t\tif (ctr < 6000000 - 1)\n\t\t\t\tdprintkl(KERN_DEBUG\n\t\t\t\t       \"DIP0: Had to wait for DMA ...\\n\");\n\t\t\tif (!ctr)\n\t\t\t\tdprintkl(KERN_ERR,\n\t\t\t\t       \"Deadlock in DIP0 waiting for DMA FIFO empty!!\\n\");\n\t\t\t \n#endif\n\t\t\tdprintkdbg(DBG_KG, \"data_in_phase0: \"\n\t\t\t\t\"DMA{fifocnt=0x%02x fifostat=0x%02x}\\n\",\n\t\t\t\tDC395x_read8(acb, TRM_S1040_DMA_FIFOCNT),\n\t\t\t\tDC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT));\n\t\t}\n\t\t \n\t\tsc = DC395x_read32(acb, TRM_S1040_SCSI_COUNTER);\n\t\tfc = DC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT);\n\t\td_left_counter = sc + ((fc & 0x1f)\n\t\t       << ((srb->dcb->sync_period & WIDE_SYNC) ? 1 :\n\t\t\t   0));\n\t\tdprintkdbg(DBG_KG, \"data_in_phase0: \"\n\t\t\t\"SCSI{fifocnt=0x%02x%s ctr=0x%08x} \"\n\t\t\t\"DMA{fifocnt=0x%02x fifostat=0x%02x ctr=0x%08x} \"\n\t\t\t\"Remain{totxfer=%i scsi_fifo+ctr=%i}\\n\",\n\t\t\tfc,\n\t\t\t(srb->dcb->sync_period & WIDE_SYNC) ? \"words\" : \"bytes\",\n\t\t\tsc,\n\t\t\tfc,\n\t\t\tDC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT),\n\t\t\tDC395x_read32(acb, TRM_S1040_DMA_CXCNT),\n\t\t\tsrb->total_xfer_length, d_left_counter);\n#if DC395x_LASTPIO\n\t\t \n\t\tif (d_left_counter\n\t\t    && srb->total_xfer_length <= DC395x_LASTPIO) {\n\t\t\tsize_t left_io = srb->total_xfer_length;\n\n\t\t\t \n\t\t\t \n\t\t\tdprintkdbg(DBG_PIO, \"data_in_phase0: PIO (%i %s) \"\n\t\t\t\t   \"for remaining %i bytes:\",\n\t\t\t\tfc & 0x1f,\n\t\t\t\t(srb->dcb->sync_period & WIDE_SYNC) ?\n\t\t\t\t    \"words\" : \"bytes\",\n\t\t\t\tsrb->total_xfer_length);\n\t\t\tif (srb->dcb->sync_period & WIDE_SYNC)\n\t\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_CONFIG2,\n\t\t\t\t\t      CFG2_WIDEFIFO);\n\t\t\twhile (left_io) {\n\t\t\t\tunsigned char *virt, *base = NULL;\n\t\t\t\tunsigned long flags = 0;\n\t\t\t\tsize_t len = left_io;\n\t\t\t\tsize_t offset = srb->request_length - left_io;\n\n\t\t\t\tlocal_irq_save(flags);\n\t\t\t\t \n\t\t\t\tbase = scsi_kmap_atomic_sg(scsi_sglist(srb->cmd),\n\t\t\t\t\t\t\t   srb->sg_count, &offset, &len);\n\t\t\t\tvirt = base + offset;\n\n\t\t\t\tleft_io -= len;\n\n\t\t\t\twhile (len) {\n\t\t\t\t\tu8 byte;\n\t\t\t\t\tbyte = DC395x_read8(acb, TRM_S1040_SCSI_FIFO);\n\t\t\t\t\t*virt++ = byte;\n\n\t\t\t\t\tif (debug_enabled(DBG_PIO))\n\t\t\t\t\t\tprintk(\" %02x\", byte);\n\n\t\t\t\t\td_left_counter--;\n\t\t\t\t\tsg_subtract_one(srb);\n\n\t\t\t\t\tlen--;\n\n\t\t\t\t\tfc = DC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT);\n\n\t\t\t\t\tif (fc == 0x40) {\n\t\t\t\t\t\tleft_io = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tWARN_ON((fc != 0x40) == !d_left_counter);\n\n\t\t\t\tif (fc == 0x40 && (srb->dcb->sync_period & WIDE_SYNC)) {\n\t\t\t\t\t \n\t\t\t\t\tif (srb->total_xfer_length > 0) {\n\t\t\t\t\t\tu8 byte = DC395x_read8(acb, TRM_S1040_SCSI_FIFO);\n\n\t\t\t\t\t\t*virt++ = byte;\n\t\t\t\t\t\tsrb->total_xfer_length--;\n\t\t\t\t\t\tif (debug_enabled(DBG_PIO))\n\t\t\t\t\t\t\tprintk(\" %02x\", byte);\n\t\t\t\t\t}\n\n\t\t\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_CONFIG2, 0);\n\t\t\t\t}\n\n\t\t\t\tscsi_kunmap_atomic_sg(base);\n\t\t\t\tlocal_irq_restore(flags);\n\t\t\t}\n\t\t\t \n\t\t\t \n\t\t\tif (debug_enabled(DBG_PIO))\n\t\t\t\tprintk(\"\\n\");\n\t\t}\n#endif\t\t\t\t \n\n#if 0\n\t\t \n\t\tif (!(scsi_status & SCSIXFERDONE)) {\n\t\t\t \n\t\t\td_left_counter =\n\t\t\t    (u32)(DC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT) &\n\t\t\t\t  0x1F);\n\t\t\tif (srb->dcb->sync_period & WIDE_SYNC)\n\t\t\t\td_left_counter <<= 1;\n\t\t\t \n\t\t}\n#endif\n\t\t \n\t\tif (d_left_counter == 0\n\t\t    || (scsi_status & SCSIXFERCNT_2_ZERO)) {\n#if 0\n\t\t\tint ctr = 6000000;\n\t\t\tu8 TempDMAstatus;\n\t\t\tdo {\n\t\t\t\tTempDMAstatus =\n\t\t\t\t    DC395x_read8(acb, TRM_S1040_DMA_STATUS);\n\t\t\t} while (!(TempDMAstatus & DMAXFERCOMP) && --ctr);\n\t\t\tif (!ctr)\n\t\t\t\tdprintkl(KERN_ERR,\n\t\t\t\t       \"Deadlock in DataInPhase0 waiting for DMA!!\\n\");\n\t\t\tsrb->total_xfer_length = 0;\n#endif\n\t\t\tsrb->total_xfer_length = d_left_counter;\n\t\t} else {\t \n\t\t\t \n\t\t\tsg_update_list(srb, d_left_counter);\n\t\t}\n\t}\n\t \n\tif ((*pscsi_status & PHASEMASK) != PH_DATA_IN) {\n\t\tcleanup_after_transfer(acb, srb);\n\t}\n}\n\n\nstatic void data_in_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status)\n{\n\tdprintkdbg(DBG_0, \"data_in_phase1: (0x%p) <%02i-%i>\\n\",\n\t\tsrb->cmd, srb->cmd->device->id, (u8)srb->cmd->device->lun);\n\tdata_io_transfer(acb, srb, XFERDATAIN);\n}\n\n\nstatic void data_io_transfer(struct AdapterCtlBlk *acb, \n\t\tstruct ScsiReqBlk *srb, u16 io_dir)\n{\n\tstruct DeviceCtlBlk *dcb = srb->dcb;\n\tu8 bval;\n\tdprintkdbg(DBG_0,\n\t\t\"data_io_transfer: (0x%p) <%02i-%i> %c len=%i, sg=(%i/%i)\\n\",\n\t\tsrb->cmd, srb->cmd->device->id, (u8)srb->cmd->device->lun,\n\t\t((io_dir & DMACMD_DIR) ? 'r' : 'w'),\n\t\tsrb->total_xfer_length, srb->sg_index, srb->sg_count);\n\tif (srb == acb->tmp_srb)\n\t\tdprintkl(KERN_ERR, \"data_io_transfer: Using tmp_srb!\\n\");\n\tif (srb->sg_index >= srb->sg_count) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (srb->total_xfer_length > DC395x_LASTPIO) {\n\t\tu8 dma_status = DC395x_read8(acb, TRM_S1040_DMA_STATUS);\n\t\t \n\t\tif (dma_status & XFERPENDING) {\n\t\t\tdprintkl(KERN_DEBUG, \"data_io_transfer: Xfer pending! \"\n\t\t\t\t\"Expect trouble!\\n\");\n\t\t\tdump_register_info(acb, dcb, srb);\n\t\t\tDC395x_write8(acb, TRM_S1040_DMA_CONTROL, CLRXFIFO);\n\t\t}\n\t\t \n\t\t \n\t\tsrb->state |= SRB_DATA_XFER;\n\t\tDC395x_write32(acb, TRM_S1040_DMA_XHIGHADDR, 0);\n\t\tif (scsi_sg_count(srb->cmd)) {\t \n\t\t\tio_dir |= DMACMD_SG;\n\t\t\tDC395x_write32(acb, TRM_S1040_DMA_XLOWADDR,\n\t\t\t\t       srb->sg_bus_addr +\n\t\t\t\t       sizeof(struct SGentry) *\n\t\t\t\t       srb->sg_index);\n\t\t\t \n\t\t\tDC395x_write32(acb, TRM_S1040_DMA_XCNT,\n\t\t\t\t       ((u32)(srb->sg_count -\n\t\t\t\t\t      srb->sg_index) << 3));\n\t\t} else {\t \n\t\t\tio_dir &= ~DMACMD_SG;\n\t\t\tDC395x_write32(acb, TRM_S1040_DMA_XLOWADDR,\n\t\t\t\t       srb->segment_x[0].address);\n\t\t\tDC395x_write32(acb, TRM_S1040_DMA_XCNT,\n\t\t\t\t       srb->segment_x[0].length);\n\t\t}\n\t\t \n\t\tDC395x_write32(acb, TRM_S1040_SCSI_COUNTER,\n\t\t\t       srb->total_xfer_length);\n\t\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\t \n\t\tif (io_dir & DMACMD_DIR) {\t \n\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_COMMAND,\n\t\t\t\t      SCMD_DMA_IN);\n\t\t\tDC395x_write16(acb, TRM_S1040_DMA_COMMAND, io_dir);\n\t\t} else {\n\t\t\tDC395x_write16(acb, TRM_S1040_DMA_COMMAND, io_dir);\n\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_COMMAND,\n\t\t\t\t      SCMD_DMA_OUT);\n\t\t}\n\n\t}\n#if DC395x_LASTPIO\n\telse if (srb->total_xfer_length > 0) {\t \n\t\t \n\t\tsrb->state |= SRB_DATA_XFER;\n\t\t \n\t\tDC395x_write32(acb, TRM_S1040_SCSI_COUNTER,\n\t\t\t       srb->total_xfer_length);\n\t\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\t \n\t\tif (io_dir & DMACMD_DIR) {\t \n\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_COMMAND,\n\t\t\t\t      SCMD_FIFO_IN);\n\t\t} else {\t \n\t\t\tint ln = srb->total_xfer_length;\n\t\t\tsize_t left_io = srb->total_xfer_length;\n\n\t\t\tif (srb->dcb->sync_period & WIDE_SYNC)\n\t\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_CONFIG2,\n\t\t\t\t     CFG2_WIDEFIFO);\n\n\t\t\twhile (left_io) {\n\t\t\t\tunsigned char *virt, *base = NULL;\n\t\t\t\tunsigned long flags = 0;\n\t\t\t\tsize_t len = left_io;\n\t\t\t\tsize_t offset = srb->request_length - left_io;\n\n\t\t\t\tlocal_irq_save(flags);\n\t\t\t\t \n\t\t\t\tbase = scsi_kmap_atomic_sg(scsi_sglist(srb->cmd),\n\t\t\t\t\t\t\t   srb->sg_count, &offset, &len);\n\t\t\t\tvirt = base + offset;\n\n\t\t\t\tleft_io -= len;\n\n\t\t\t\twhile (len--) {\n\t\t\t\t\tif (debug_enabled(DBG_PIO))\n\t\t\t\t\t\tprintk(\" %02x\", *virt);\n\n\t\t\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, *virt++);\n\n\t\t\t\t\tsg_subtract_one(srb);\n\t\t\t\t}\n\n\t\t\t\tscsi_kunmap_atomic_sg(base);\n\t\t\t\tlocal_irq_restore(flags);\n\t\t\t}\n\t\t\tif (srb->dcb->sync_period & WIDE_SYNC) {\n\t\t\t\tif (ln % 2) {\n\t\t\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 0);\n\t\t\t\t\tif (debug_enabled(DBG_PIO))\n\t\t\t\t\t\tprintk(\" |00\");\n\t\t\t\t}\n\t\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_CONFIG2, 0);\n\t\t\t}\n\t\t\t \n\t\t\tif (debug_enabled(DBG_PIO))\n\t\t\t\tprintk(\"\\n\");\n\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_COMMAND,\n\t\t\t\t\t  SCMD_FIFO_OUT);\n\t\t}\n\t}\n#endif\t\t\t\t \n\telse {\t\t \n\t\tif (srb->sg_count) {\n\t\t\tsrb->adapter_status = H_OVER_UNDER_RUN;\n\t\t\tsrb->status |= OVER_RUN;\n\t\t}\n\t\t \n\t\tif (dcb->sync_period & WIDE_SYNC) {\n\t\t\tDC395x_write32(acb, TRM_S1040_SCSI_COUNTER, 2);\n\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_CONFIG2,\n\t\t\t\t      CFG2_WIDEFIFO);\n\t\t\tif (io_dir & DMACMD_DIR) {\n\t\t\t\tDC395x_read8(acb, TRM_S1040_SCSI_FIFO);\n\t\t\t\tDC395x_read8(acb, TRM_S1040_SCSI_FIFO);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 'K');\n\t\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 'G');\n\t\t\t}\n\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_CONFIG2, 0);\n\t\t} else {\n\t\t\tDC395x_write32(acb, TRM_S1040_SCSI_COUNTER, 1);\n\t\t\t \n\t\t\tif (io_dir & DMACMD_DIR)\n\t\t\t\tDC395x_read8(acb, TRM_S1040_SCSI_FIFO);\n\t\t\telse\n\t\t\t\tDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 'K');\n\t\t}\n\t\tsrb->state |= SRB_XFERPAD;\n\t\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\t \n\t\t \n\t\tbval = (io_dir & DMACMD_DIR) ? SCMD_FIFO_IN : SCMD_FIFO_OUT;\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, bval);\n\t}\n}\n\n\nstatic void status_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status)\n{\n\tdprintkdbg(DBG_0, \"status_phase0: (0x%p) <%02i-%i>\\n\",\n\t\tsrb->cmd, srb->cmd->device->id, (u8)srb->cmd->device->lun);\n\tsrb->target_status = DC395x_read8(acb, TRM_S1040_SCSI_FIFO);\n\tsrb->end_message = DC395x_read8(acb, TRM_S1040_SCSI_FIFO);\t \n\tsrb->state = SRB_COMPLETED;\n\t*pscsi_status = PH_BUS_FREE;\t \n\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\t \n\tDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_MSGACCEPT);\n}\n\n\nstatic void status_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status)\n{\n\tdprintkdbg(DBG_0, \"status_phase1: (0x%p) <%02i-%i>\\n\",\n\t\tsrb->cmd, srb->cmd->device->id, (u8)srb->cmd->device->lun);\n\tsrb->state = SRB_STATUS;\n\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\t \n\tDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_COMP);\n}\n\n\n \nstatic inline u8 msgin_completed(u8 * msgbuf, u32 len)\n{\n\tif (*msgbuf == EXTENDED_MESSAGE) {\n\t\tif (len < 2)\n\t\t\treturn 0;\n\t\tif (len < msgbuf[1] + 2)\n\t\t\treturn 0;\n\t} else if (*msgbuf >= 0x20 && *msgbuf <= 0x2f)\t \n\t\tif (len < 2)\n\t\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic inline void msgin_reject(struct AdapterCtlBlk *acb,\n\t\tstruct ScsiReqBlk *srb)\n{\n\tsrb->msgout_buf[0] = MESSAGE_REJECT;\n\tsrb->msg_count = 1;\n\tDC395x_ENABLE_MSGOUT;\n\tsrb->state &= ~SRB_MSGIN;\n\tsrb->state |= SRB_MSGOUT;\n\tdprintkl(KERN_INFO, \"msgin_reject: 0x%02x <%02i-%i>\\n\",\n\t\tsrb->msgin_buf[0],\n\t\tsrb->dcb->target_id, srb->dcb->target_lun);\n}\n\n\nstatic struct ScsiReqBlk *msgin_qtag(struct AdapterCtlBlk *acb,\n\t\tstruct DeviceCtlBlk *dcb, u8 tag)\n{\n\tstruct ScsiReqBlk *srb = NULL;\n\tstruct ScsiReqBlk *i;\n\tdprintkdbg(DBG_0, \"msgin_qtag: (0x%p) tag=%i srb=%p\\n\",\n\t\t   srb->cmd, tag, srb);\n\n\tif (!(dcb->tag_mask & (1 << tag)))\n\t\tdprintkl(KERN_DEBUG,\n\t\t\t\"msgin_qtag: tag_mask=0x%08x does not reserve tag %i!\\n\",\n\t\t\tdcb->tag_mask, tag);\n\n\tif (list_empty(&dcb->srb_going_list))\n\t\tgoto mingx0;\n\tlist_for_each_entry(i, &dcb->srb_going_list, list) {\n\t\tif (i->tag_number == tag) {\n\t\t\tsrb = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!srb)\n\t\tgoto mingx0;\n\n\tdprintkdbg(DBG_0, \"msgin_qtag: (0x%p) <%02i-%i>\\n\",\n\t\tsrb->cmd, srb->dcb->target_id, srb->dcb->target_lun);\n\tif (dcb->flag & ABORT_DEV_) {\n\t\t \n\t\tenable_msgout_abort(acb, srb);\n\t}\n\n\tif (!(srb->state & SRB_DISCONNECT))\n\t\tgoto mingx0;\n\n\tmemcpy(srb->msgin_buf, dcb->active_srb->msgin_buf, acb->msg_len);\n\tsrb->state |= dcb->active_srb->state;\n\tsrb->state |= SRB_DATA_XFER;\n\tdcb->active_srb = srb;\n\t \n\treturn srb;\n\n      mingx0:\n\tsrb = acb->tmp_srb;\n\tsrb->state = SRB_UNEXPECT_RESEL;\n\tdcb->active_srb = srb;\n\tsrb->msgout_buf[0] = ABORT_TASK;\n\tsrb->msg_count = 1;\n\tDC395x_ENABLE_MSGOUT;\n\tdprintkl(KERN_DEBUG, \"msgin_qtag: Unknown tag %i - abort\\n\", tag);\n\treturn srb;\n}\n\n\nstatic inline void reprogram_regs(struct AdapterCtlBlk *acb,\n\t\tstruct DeviceCtlBlk *dcb)\n{\n\tDC395x_write8(acb, TRM_S1040_SCSI_TARGETID, dcb->target_id);\n\tDC395x_write8(acb, TRM_S1040_SCSI_SYNC, dcb->sync_period);\n\tDC395x_write8(acb, TRM_S1040_SCSI_OFFSET, dcb->sync_offset);\n\tset_xfer_rate(acb, dcb);\n}\n\n\n \nstatic void msgin_set_async(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb)\n{\n\tstruct DeviceCtlBlk *dcb = srb->dcb;\n\tdprintkl(KERN_DEBUG, \"msgin_set_async: No sync transfers <%02i-%i>\\n\",\n\t\tdcb->target_id, dcb->target_lun);\n\n\tdcb->sync_mode &= ~(SYNC_NEGO_ENABLE);\n\tdcb->sync_mode |= SYNC_NEGO_DONE;\n\t \n\tdcb->sync_offset = 0;\n\tdcb->min_nego_period = 200 >> 2;\t \n\tsrb->state &= ~SRB_DO_SYNC_NEGO;\n\treprogram_regs(acb, dcb);\n\tif ((dcb->sync_mode & WIDE_NEGO_ENABLE)\n\t    && !(dcb->sync_mode & WIDE_NEGO_DONE)) {\n\t\tbuild_wdtr(acb, dcb, srb);\n\t\tDC395x_ENABLE_MSGOUT;\n\t\tdprintkdbg(DBG_0, \"msgin_set_async(rej): Try WDTR anyway\\n\");\n\t}\n}\n\n\n \nstatic void msgin_set_sync(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb)\n{\n\tstruct DeviceCtlBlk *dcb = srb->dcb;\n\tu8 bval;\n\tint fact;\n\tdprintkdbg(DBG_1, \"msgin_set_sync: <%02i> Sync: %ins \"\n\t\t\"(%02i.%01i MHz) Offset %i\\n\",\n\t\tdcb->target_id, srb->msgin_buf[3] << 2,\n\t\t(250 / srb->msgin_buf[3]),\n\t\t((250 % srb->msgin_buf[3]) * 10) / srb->msgin_buf[3],\n\t\tsrb->msgin_buf[4]);\n\n\tif (srb->msgin_buf[4] > 15)\n\t\tsrb->msgin_buf[4] = 15;\n\tif (!(dcb->dev_mode & NTC_DO_SYNC_NEGO))\n\t\tdcb->sync_offset = 0;\n\telse if (dcb->sync_offset == 0)\n\t\tdcb->sync_offset = srb->msgin_buf[4];\n\tif (srb->msgin_buf[4] > dcb->sync_offset)\n\t\tsrb->msgin_buf[4] = dcb->sync_offset;\n\telse\n\t\tdcb->sync_offset = srb->msgin_buf[4];\n\tbval = 0;\n\twhile (bval < 7 && (srb->msgin_buf[3] > clock_period[bval]\n\t\t\t    || dcb->min_nego_period >\n\t\t\t    clock_period[bval]))\n\t\tbval++;\n\tif (srb->msgin_buf[3] < clock_period[bval])\n\t\tdprintkl(KERN_INFO,\n\t\t\t\"msgin_set_sync: Increase sync nego period to %ins\\n\",\n\t\t\tclock_period[bval] << 2);\n\tsrb->msgin_buf[3] = clock_period[bval];\n\tdcb->sync_period &= 0xf0;\n\tdcb->sync_period |= ALT_SYNC | bval;\n\tdcb->min_nego_period = srb->msgin_buf[3];\n\n\tif (dcb->sync_period & WIDE_SYNC)\n\t\tfact = 500;\n\telse\n\t\tfact = 250;\n\n\tdprintkl(KERN_INFO,\n\t\t\"Target %02i: %s Sync: %ins Offset %i (%02i.%01i MB/s)\\n\",\n\t\tdcb->target_id, (fact == 500) ? \"Wide16\" : \"\",\n\t\tdcb->min_nego_period << 2, dcb->sync_offset,\n\t\t(fact / dcb->min_nego_period),\n\t\t((fact % dcb->min_nego_period) * 10 +\n\t\tdcb->min_nego_period / 2) / dcb->min_nego_period);\n\n\tif (!(srb->state & SRB_DO_SYNC_NEGO)) {\n\t\t \n\t\tdprintkl(KERN_DEBUG, \"msgin_set_sync: answer w/%ins %i\\n\",\n\t\t\tsrb->msgin_buf[3] << 2, srb->msgin_buf[4]);\n\n\t\tmemcpy(srb->msgout_buf, srb->msgin_buf, 5);\n\t\tsrb->msg_count = 5;\n\t\tDC395x_ENABLE_MSGOUT;\n\t\tdcb->sync_mode |= SYNC_NEGO_DONE;\n\t} else {\n\t\tif ((dcb->sync_mode & WIDE_NEGO_ENABLE)\n\t\t    && !(dcb->sync_mode & WIDE_NEGO_DONE)) {\n\t\t\tbuild_wdtr(acb, dcb, srb);\n\t\t\tDC395x_ENABLE_MSGOUT;\n\t\t\tdprintkdbg(DBG_0, \"msgin_set_sync: Also try WDTR\\n\");\n\t\t}\n\t}\n\tsrb->state &= ~SRB_DO_SYNC_NEGO;\n\tdcb->sync_mode |= SYNC_NEGO_DONE | SYNC_NEGO_ENABLE;\n\n\treprogram_regs(acb, dcb);\n}\n\n\nstatic inline void msgin_set_nowide(struct AdapterCtlBlk *acb,\n\t\tstruct ScsiReqBlk *srb)\n{\n\tstruct DeviceCtlBlk *dcb = srb->dcb;\n\tdprintkdbg(DBG_1, \"msgin_set_nowide: <%02i>\\n\", dcb->target_id);\n\n\tdcb->sync_period &= ~WIDE_SYNC;\n\tdcb->sync_mode &= ~(WIDE_NEGO_ENABLE);\n\tdcb->sync_mode |= WIDE_NEGO_DONE;\n\tsrb->state &= ~SRB_DO_WIDE_NEGO;\n\treprogram_regs(acb, dcb);\n\tif ((dcb->sync_mode & SYNC_NEGO_ENABLE)\n\t    && !(dcb->sync_mode & SYNC_NEGO_DONE)) {\n\t\tbuild_sdtr(acb, dcb, srb);\n\t\tDC395x_ENABLE_MSGOUT;\n\t\tdprintkdbg(DBG_0, \"msgin_set_nowide: Rejected. Try SDTR anyway\\n\");\n\t}\n}\n\nstatic void msgin_set_wide(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb)\n{\n\tstruct DeviceCtlBlk *dcb = srb->dcb;\n\tu8 wide = (dcb->dev_mode & NTC_DO_WIDE_NEGO\n\t\t   && acb->config & HCC_WIDE_CARD) ? 1 : 0;\n\tdprintkdbg(DBG_1, \"msgin_set_wide: <%02i>\\n\", dcb->target_id);\n\n\tif (srb->msgin_buf[3] > wide)\n\t\tsrb->msgin_buf[3] = wide;\n\t \n\tif (!(srb->state & SRB_DO_WIDE_NEGO)) {\n\t\tdprintkl(KERN_DEBUG,\n\t\t\t\"msgin_set_wide: Wide nego initiated <%02i>\\n\",\n\t\t\tdcb->target_id);\n\t\tmemcpy(srb->msgout_buf, srb->msgin_buf, 4);\n\t\tsrb->msg_count = 4;\n\t\tsrb->state |= SRB_DO_WIDE_NEGO;\n\t\tDC395x_ENABLE_MSGOUT;\n\t}\n\n\tdcb->sync_mode |= (WIDE_NEGO_ENABLE | WIDE_NEGO_DONE);\n\tif (srb->msgin_buf[3] > 0)\n\t\tdcb->sync_period |= WIDE_SYNC;\n\telse\n\t\tdcb->sync_period &= ~WIDE_SYNC;\n\tsrb->state &= ~SRB_DO_WIDE_NEGO;\n\t \n\tdprintkdbg(DBG_1,\n\t\t\"msgin_set_wide: Wide (%i bit) negotiated <%02i>\\n\",\n\t\t(8 << srb->msgin_buf[3]), dcb->target_id);\n\treprogram_regs(acb, dcb);\n\tif ((dcb->sync_mode & SYNC_NEGO_ENABLE)\n\t    && !(dcb->sync_mode & SYNC_NEGO_DONE)) {\n\t\tbuild_sdtr(acb, dcb, srb);\n\t\tDC395x_ENABLE_MSGOUT;\n\t\tdprintkdbg(DBG_0, \"msgin_set_wide: Also try SDTR.\\n\");\n\t}\n}\n\n\n \nstatic void msgin_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status)\n{\n\tstruct DeviceCtlBlk *dcb = acb->active_dcb;\n\tdprintkdbg(DBG_0, \"msgin_phase0: (0x%p)\\n\", srb->cmd);\n\n\tsrb->msgin_buf[acb->msg_len++] = DC395x_read8(acb, TRM_S1040_SCSI_FIFO);\n\tif (msgin_completed(srb->msgin_buf, acb->msg_len)) {\n\t\t \n\t\tswitch (srb->msgin_buf[0]) {\n\t\tcase DISCONNECT:\n\t\t\tsrb->state = SRB_DISCONNECT;\n\t\t\tbreak;\n\n\t\tcase SIMPLE_QUEUE_TAG:\n\t\tcase HEAD_OF_QUEUE_TAG:\n\t\tcase ORDERED_QUEUE_TAG:\n\t\t\tsrb =\n\t\t\t    msgin_qtag(acb, dcb,\n\t\t\t\t\t      srb->msgin_buf[1]);\n\t\t\tbreak;\n\n\t\tcase MESSAGE_REJECT:\n\t\t\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL,\n\t\t\t\t       DO_CLRATN | DO_DATALATCH);\n\t\t\t \n\t\t\tif (srb->state & SRB_DO_SYNC_NEGO) {\n\t\t\t\tmsgin_set_async(acb, srb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (srb->state & SRB_DO_WIDE_NEGO) {\n\t\t\t\tmsgin_set_nowide(acb, srb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tenable_msgout_abort(acb, srb);\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase EXTENDED_MESSAGE:\n\t\t\t \n\t\t\tif (srb->msgin_buf[1] == 3\n\t\t\t    && srb->msgin_buf[2] == EXTENDED_SDTR) {\n\t\t\t\tmsgin_set_sync(acb, srb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (srb->msgin_buf[1] == 2\n\t\t\t    && srb->msgin_buf[2] == EXTENDED_WDTR\n\t\t\t    && srb->msgin_buf[3] <= 2) {  \n\t\t\t\tmsgin_set_wide(acb, srb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsgin_reject(acb, srb);\n\t\t\tbreak;\n\n\t\tcase IGNORE_WIDE_RESIDUE:\n\t\t\t \n\t\t\tdprintkdbg(DBG_0, \"msgin_phase0: Ignore Wide Residual!\\n\");\n\t\t\tbreak;\n\n\t\tcase COMMAND_COMPLETE:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase SAVE_POINTERS:\n\t\t\t \n\t\t\tdprintkdbg(DBG_0, \"msgin_phase0: (0x%p) \"\n\t\t\t\t\"SAVE POINTER rem=%i Ignore\\n\",\n\t\t\t\tsrb->cmd, srb->total_xfer_length);\n\t\t\tbreak;\n\n\t\tcase RESTORE_POINTERS:\n\t\t\tdprintkdbg(DBG_0, \"msgin_phase0: RESTORE POINTER. Ignore\\n\");\n\t\t\tbreak;\n\n\t\tcase ABORT:\n\t\t\tdprintkdbg(DBG_0, \"msgin_phase0: (0x%p) \"\n\t\t\t\t\"<%02i-%i> ABORT msg\\n\",\n\t\t\t\tsrb->cmd, dcb->target_id,\n\t\t\t\tdcb->target_lun);\n\t\t\tdcb->flag |= ABORT_DEV_;\n\t\t\tenable_msgout_abort(acb, srb);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tif (srb->msgin_buf[0] & IDENTIFY_BASE) {\n\t\t\t\tdprintkdbg(DBG_0, \"msgin_phase0: Identify msg\\n\");\n\t\t\t\tsrb->msg_count = 1;\n\t\t\t\tsrb->msgout_buf[0] = dcb->identify_msg;\n\t\t\t\tDC395x_ENABLE_MSGOUT;\n\t\t\t\tsrb->state |= SRB_MSGOUT;\n\t\t\t\t \n\t\t\t}\n\t\t\tmsgin_reject(acb, srb);\n\t\t}\n\n\t\t \n\t\tsrb->state &= ~SRB_MSGIN;\n\t\tacb->msg_len = 0;\n\t}\n\t*pscsi_status = PH_BUS_FREE;\n\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\t \n\tDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_MSGACCEPT);\n}\n\n\nstatic void msgin_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status)\n{\n\tdprintkdbg(DBG_0, \"msgin_phase1: (0x%p)\\n\", srb->cmd);\n\tclear_fifo(acb, \"msgin_phase1\");\n\tDC395x_write32(acb, TRM_S1040_SCSI_COUNTER, 1);\n\tif (!(srb->state & SRB_MSGIN)) {\n\t\tsrb->state &= ~SRB_DISCONNECT;\n\t\tsrb->state |= SRB_MSGIN;\n\t}\n\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\t \n\t \n\tDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_FIFO_IN);\n}\n\n\nstatic void nop0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status)\n{\n}\n\n\nstatic void nop1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\n\t\tu16 *pscsi_status)\n{\n}\n\n\nstatic void set_xfer_rate(struct AdapterCtlBlk *acb, struct DeviceCtlBlk *dcb)\n{\n\tstruct DeviceCtlBlk *i;\n\n\t \n\tif (dcb->identify_msg & 0x07)\n\t\treturn;\n\n\tif (acb->scan_devices) {\n\t\tcurrent_sync_offset = dcb->sync_offset;\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(i, &acb->dcb_list, list)\n\t\tif (i->target_id == dcb->target_id) {\n\t\t\ti->sync_period = dcb->sync_period;\n\t\t\ti->sync_offset = dcb->sync_offset;\n\t\t\ti->sync_mode = dcb->sync_mode;\n\t\t\ti->min_nego_period = dcb->min_nego_period;\n\t\t}\n}\n\n\nstatic void disconnect(struct AdapterCtlBlk *acb)\n{\n\tstruct DeviceCtlBlk *dcb = acb->active_dcb;\n\tstruct ScsiReqBlk *srb;\n\n\tif (!dcb) {\n\t\tdprintkl(KERN_ERR, \"disconnect: No such device\\n\");\n\t\tudelay(500);\n\t\t \n\t\tacb->last_reset =\n\t\t    jiffies + HZ / 2 +\n\t\t    HZ * acb->eeprom.delay_time;\n\t\tclear_fifo(acb, \"disconnectEx\");\n\t\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_HWRESELECT);\n\t\treturn;\n\t}\n\tsrb = dcb->active_srb;\n\tacb->active_dcb = NULL;\n\tdprintkdbg(DBG_0, \"disconnect: (0x%p)\\n\", srb->cmd);\n\n\tsrb->scsi_phase = PH_BUS_FREE;\t \n\tclear_fifo(acb, \"disconnect\");\n\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_HWRESELECT);\n\tif (srb->state & SRB_UNEXPECT_RESEL) {\n\t\tdprintkl(KERN_ERR,\n\t\t\t\"disconnect: Unexpected reselection <%02i-%i>\\n\",\n\t\t\tdcb->target_id, dcb->target_lun);\n\t\tsrb->state = 0;\n\t\twaiting_process_next(acb);\n\t} else if (srb->state & SRB_ABORT_SENT) {\n\t\tdcb->flag &= ~ABORT_DEV_;\n\t\tacb->last_reset = jiffies + HZ / 2 + 1;\n\t\tdprintkl(KERN_ERR, \"disconnect: SRB_ABORT_SENT\\n\");\n\t\tdoing_srb_done(acb, DID_ABORT, srb->cmd, 1);\n\t\twaiting_process_next(acb);\n\t} else {\n\t\tif ((srb->state & (SRB_START_ + SRB_MSGOUT))\n\t\t    || !(srb->\n\t\t\t state & (SRB_DISCONNECT | SRB_COMPLETED))) {\n\t\t\t \n\t\t\t \n\t\t\tif (srb->state != SRB_START_\n\t\t\t    && srb->state != SRB_MSGOUT) {\n\t\t\t\tsrb->state = SRB_READY;\n\t\t\t\tdprintkl(KERN_DEBUG,\n\t\t\t\t\t\"disconnect: (0x%p) Unexpected\\n\",\n\t\t\t\t\tsrb->cmd);\n\t\t\t\tsrb->target_status = SCSI_STAT_SEL_TIMEOUT;\n\t\t\t\tgoto disc1;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdprintkdbg(DBG_KG, \"disconnect: (0x%p) \"\n\t\t\t\t\t\"<%02i-%i> SelTO\\n\", srb->cmd,\n\t\t\t\t\tdcb->target_id, dcb->target_lun);\n\t\t\t\tif (srb->retry_count++ > DC395x_MAX_RETRIES\n\t\t\t\t    || acb->scan_devices) {\n\t\t\t\t\tsrb->target_status =\n\t\t\t\t\t    SCSI_STAT_SEL_TIMEOUT;\n\t\t\t\t\tgoto disc1;\n\t\t\t\t}\n\t\t\t\tfree_tag(dcb, srb);\n\t\t\t\tlist_move(&srb->list, &dcb->srb_waiting_list);\n\t\t\t\tdprintkdbg(DBG_KG,\n\t\t\t\t\t\"disconnect: (0x%p) Retry\\n\",\n\t\t\t\t\tsrb->cmd);\n\t\t\t\twaiting_set_timer(acb, HZ / 20);\n\t\t\t}\n\t\t} else if (srb->state & SRB_DISCONNECT) {\n\t\t\tu8 bval = DC395x_read8(acb, TRM_S1040_SCSI_SIGNAL);\n\t\t\t \n\t\t\tif (bval & 0x40) {\n\t\t\t\tdprintkdbg(DBG_0, \"disconnect: SCSI bus stat \"\n\t\t\t\t\t\" 0x%02x: ACK set! Other controllers?\\n\",\n\t\t\t\t\tbval);\n\t\t\t\t \n\t\t\t} else\n\t\t\t\twaiting_process_next(acb);\n\t\t} else if (srb->state & SRB_COMPLETED) {\n\t\t      disc1:\n\t\t\t \n\t\t\tfree_tag(dcb, srb);\n\t\t\tdcb->active_srb = NULL;\n\t\t\tsrb->state = SRB_FREE;\n\t\t\tsrb_done(acb, dcb, srb);\n\t\t}\n\t}\n}\n\n\nstatic void reselect(struct AdapterCtlBlk *acb)\n{\n\tstruct DeviceCtlBlk *dcb = acb->active_dcb;\n\tstruct ScsiReqBlk *srb = NULL;\n\tu16 rsel_tar_lun_id;\n\tu8 id, lun;\n\tdprintkdbg(DBG_0, \"reselect: acb=%p\\n\", acb);\n\n\tclear_fifo(acb, \"reselect\");\n\t \n\t \n\trsel_tar_lun_id = DC395x_read16(acb, TRM_S1040_SCSI_TARGETID);\n\tif (dcb) {\t\t \n\t\tsrb = dcb->active_srb;\n\t\tif (!srb) {\n\t\t\tdprintkl(KERN_DEBUG, \"reselect: Arb lost Resel won, \"\n\t\t\t\t\"but active_srb == NULL\\n\");\n\t\t\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\t \n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (!acb->scan_devices) {\n\t\t\tdprintkdbg(DBG_KG, \"reselect: (0x%p) <%02i-%i> \"\n\t\t\t\t\"Arb lost but Resel win rsel=%i stat=0x%04x\\n\",\n\t\t\t\tsrb->cmd, dcb->target_id,\n\t\t\t\tdcb->target_lun, rsel_tar_lun_id,\n\t\t\t\tDC395x_read16(acb, TRM_S1040_SCSI_STATUS));\n\t\t\t \n\n\t\t\tsrb->state = SRB_READY;\n\t\t\tfree_tag(dcb, srb);\n\t\t\tlist_move(&srb->list, &dcb->srb_waiting_list);\n\t\t\twaiting_set_timer(acb, HZ / 20);\n\n\t\t\t \n\t\t}\n\t}\n\t \n\tif (!(rsel_tar_lun_id & (IDENTIFY_BASE << 8)))\n\t\tdprintkl(KERN_DEBUG, \"reselect: Expects identify msg. \"\n\t\t\t\"Got %i!\\n\", rsel_tar_lun_id);\n\tid = rsel_tar_lun_id & 0xff;\n\tlun = (rsel_tar_lun_id >> 8) & 7;\n\tdcb = find_dcb(acb, id, lun);\n\tif (!dcb) {\n\t\tdprintkl(KERN_ERR, \"reselect: From non existent device \"\n\t\t\t\"<%02i-%i>\\n\", id, lun);\n\t\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\t \n\t\treturn;\n\t}\n\tacb->active_dcb = dcb;\n\n\tif (!(dcb->dev_mode & NTC_DO_DISCONNECT))\n\t\tdprintkl(KERN_DEBUG, \"reselect: in spite of forbidden \"\n\t\t\t\"disconnection? <%02i-%i>\\n\",\n\t\t\tdcb->target_id, dcb->target_lun);\n\n\tif (dcb->sync_mode & EN_TAG_QUEUEING) {\n\t\tsrb = acb->tmp_srb;\n\t\tdcb->active_srb = srb;\n\t} else {\n\t\t \n\t\tsrb = dcb->active_srb;\n\t\tif (!srb || !(srb->state & SRB_DISCONNECT)) {\n\t\t\t \n\t\t\tdprintkl(KERN_DEBUG,\n\t\t\t\t\"reselect: w/o disconnected cmds <%02i-%i>\\n\",\n\t\t\t\tdcb->target_id, dcb->target_lun);\n\t\t\tsrb = acb->tmp_srb;\n\t\t\tsrb->state = SRB_UNEXPECT_RESEL;\n\t\t\tdcb->active_srb = srb;\n\t\t\tenable_msgout_abort(acb, srb);\n\t\t} else {\n\t\t\tif (dcb->flag & ABORT_DEV_) {\n\t\t\t\t \n\t\t\t\tenable_msgout_abort(acb, srb);\n\t\t\t} else\n\t\t\t\tsrb->state = SRB_DATA_XFER;\n\n\t\t}\n\t}\n\tsrb->scsi_phase = PH_BUS_FREE;\t \n\n\t \n\tdprintkdbg(DBG_0, \"reselect: select <%i>\\n\", dcb->target_id);\n\tDC395x_write8(acb, TRM_S1040_SCSI_HOSTID, acb->scsi_host->this_id);\t \n\tDC395x_write8(acb, TRM_S1040_SCSI_TARGETID, dcb->target_id);\t\t \n\tDC395x_write8(acb, TRM_S1040_SCSI_OFFSET, dcb->sync_offset);\t\t \n\tDC395x_write8(acb, TRM_S1040_SCSI_SYNC, dcb->sync_period);\t\t \n\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\t\t \n\t \n\tDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_MSGACCEPT);\n}\n\n\nstatic inline u8 tagq_blacklist(char *name)\n{\n#ifndef DC395x_NO_TAGQ\n#if 0\n\tu8 i;\n\tfor (i = 0; i < BADDEVCNT; i++)\n\t\tif (memcmp(name, DC395x_baddevname1[i], 28) == 0)\n\t\t\treturn 1;\n#endif\n\treturn 0;\n#else\n\treturn 1;\n#endif\n}\n\n\nstatic void disc_tagq_set(struct DeviceCtlBlk *dcb, struct ScsiInqData *ptr)\n{\n\t \n\tif ((ptr->Vers & 0x07) >= 2 || (ptr->RDF & 0x0F) == 2) {\n\t\tif ((ptr->Flags & SCSI_INQ_CMDQUEUE)\n\t\t    && (dcb->dev_mode & NTC_DO_TAG_QUEUEING) &&\n\t\t     \n\t\t     \n\t\t    !tagq_blacklist(((char *)ptr) + 8)) {\n\t\t\tif (dcb->max_command == 1)\n\t\t\t\tdcb->max_command =\n\t\t\t\t    dcb->acb->tag_max_num;\n\t\t\tdcb->sync_mode |= EN_TAG_QUEUEING;\n\t\t\t \n\t\t} else\n\t\t\tdcb->max_command = 1;\n\t}\n}\n\n\nstatic void add_dev(struct AdapterCtlBlk *acb, struct DeviceCtlBlk *dcb,\n\t\tstruct ScsiInqData *ptr)\n{\n\tu8 bval1 = ptr->DevType & SCSI_DEVTYPE;\n\tdcb->dev_type = bval1;\n\t \n\tdisc_tagq_set(dcb, ptr);\n}\n\n\n \nstatic void pci_unmap_srb(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb)\n{\n\tstruct scsi_cmnd *cmd = srb->cmd;\n\tenum dma_data_direction dir = cmd->sc_data_direction;\n\n\tif (scsi_sg_count(cmd) && dir != DMA_NONE) {\n\t\t \n\t\tdprintkdbg(DBG_SG, \"pci_unmap_srb: list=%08x(%05x)\\n\",\n\t\t\tsrb->sg_bus_addr, SEGMENTX_LEN);\n\t\tdma_unmap_single(&acb->dev->dev, srb->sg_bus_addr, SEGMENTX_LEN,\n\t\t\t\tDMA_TO_DEVICE);\n\t\tdprintkdbg(DBG_SG, \"pci_unmap_srb: segs=%i buffer=%p\\n\",\n\t\t\t   scsi_sg_count(cmd), scsi_bufflen(cmd));\n\t\t \n\t\tscsi_dma_unmap(cmd);\n\t}\n}\n\n\n \nstatic void pci_unmap_srb_sense(struct AdapterCtlBlk *acb,\n\t\tstruct ScsiReqBlk *srb)\n{\n\tif (!(srb->flag & AUTO_REQSENSE))\n\t\treturn;\n\t \n\tdprintkdbg(DBG_SG, \"pci_unmap_srb_sense: buffer=%08x\\n\",\n\t       srb->segment_x[0].address);\n\tdma_unmap_single(&acb->dev->dev, srb->segment_x[0].address,\n\t\t\t srb->segment_x[0].length, DMA_FROM_DEVICE);\n\t \n\tsrb->total_xfer_length = srb->xferred;\n\tsrb->segment_x[0].address =\n\t    srb->segment_x[DC395x_MAX_SG_LISTENTRY - 1].address;\n\tsrb->segment_x[0].length =\n\t    srb->segment_x[DC395x_MAX_SG_LISTENTRY - 1].length;\n}\n\n\n \nstatic void srb_done(struct AdapterCtlBlk *acb, struct DeviceCtlBlk *dcb,\n\t\tstruct ScsiReqBlk *srb)\n{\n\tu8 tempcnt, status;\n\tstruct scsi_cmnd *cmd = srb->cmd;\n\tenum dma_data_direction dir = cmd->sc_data_direction;\n\tint ckc_only = 1;\n\n\tdprintkdbg(DBG_1, \"srb_done: (0x%p) <%02i-%i>\\n\", srb->cmd,\n\t\tsrb->cmd->device->id, (u8)srb->cmd->device->lun);\n\tdprintkdbg(DBG_SG, \"srb_done: srb=%p sg=%i(%i/%i) buf=%p\\n\",\n\t\t   srb, scsi_sg_count(cmd), srb->sg_index, srb->sg_count,\n\t\t   scsi_sgtalbe(cmd));\n\tstatus = srb->target_status;\n\tset_host_byte(cmd, DID_OK);\n\tset_status_byte(cmd, SAM_STAT_GOOD);\n\tif (srb->flag & AUTO_REQSENSE) {\n\t\tdprintkdbg(DBG_0, \"srb_done: AUTO_REQSENSE1\\n\");\n\t\tpci_unmap_srb_sense(acb, srb);\n\t\t \n\t\tsrb->flag &= ~AUTO_REQSENSE;\n\t\tsrb->adapter_status = 0;\n\t\tsrb->target_status = SAM_STAT_CHECK_CONDITION;\n\t\tif (debug_enabled(DBG_1)) {\n\t\t\tswitch (cmd->sense_buffer[2] & 0x0f) {\n\t\t\tcase NOT_READY:\n\t\t\t\tdprintkl(KERN_DEBUG,\n\t\t\t\t     \"ReqSense: NOT_READY cmnd=0x%02x <%02i-%i> stat=%i scan=%i \",\n\t\t\t\t     cmd->cmnd[0], dcb->target_id,\n\t\t\t\t     dcb->target_lun, status, acb->scan_devices);\n\t\t\t\tbreak;\n\t\t\tcase UNIT_ATTENTION:\n\t\t\t\tdprintkl(KERN_DEBUG,\n\t\t\t\t     \"ReqSense: UNIT_ATTENTION cmnd=0x%02x <%02i-%i> stat=%i scan=%i \",\n\t\t\t\t     cmd->cmnd[0], dcb->target_id,\n\t\t\t\t     dcb->target_lun, status, acb->scan_devices);\n\t\t\t\tbreak;\n\t\t\tcase ILLEGAL_REQUEST:\n\t\t\t\tdprintkl(KERN_DEBUG,\n\t\t\t\t     \"ReqSense: ILLEGAL_REQUEST cmnd=0x%02x <%02i-%i> stat=%i scan=%i \",\n\t\t\t\t     cmd->cmnd[0], dcb->target_id,\n\t\t\t\t     dcb->target_lun, status, acb->scan_devices);\n\t\t\t\tbreak;\n\t\t\tcase MEDIUM_ERROR:\n\t\t\t\tdprintkl(KERN_DEBUG,\n\t\t\t\t     \"ReqSense: MEDIUM_ERROR cmnd=0x%02x <%02i-%i> stat=%i scan=%i \",\n\t\t\t\t     cmd->cmnd[0], dcb->target_id,\n\t\t\t\t     dcb->target_lun, status, acb->scan_devices);\n\t\t\t\tbreak;\n\t\t\tcase HARDWARE_ERROR:\n\t\t\t\tdprintkl(KERN_DEBUG,\n\t\t\t\t     \"ReqSense: HARDWARE_ERROR cmnd=0x%02x <%02i-%i> stat=%i scan=%i \",\n\t\t\t\t     cmd->cmnd[0], dcb->target_id,\n\t\t\t\t     dcb->target_lun, status, acb->scan_devices);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cmd->sense_buffer[7] >= 6)\n\t\t\t\tprintk(\"sense=0x%02x ASC=0x%02x ASCQ=0x%02x \"\n\t\t\t\t\t\"(0x%08x 0x%08x)\\n\",\n\t\t\t\t\tcmd->sense_buffer[2], cmd->sense_buffer[12],\n\t\t\t\t\tcmd->sense_buffer[13],\n\t\t\t\t\t*((unsigned int *)(cmd->sense_buffer + 3)),\n\t\t\t\t\t*((unsigned int *)(cmd->sense_buffer + 8)));\n\t\t\telse\n\t\t\t\tprintk(\"sense=0x%02x No ASC/ASCQ (0x%08x)\\n\",\n\t\t\t\t\tcmd->sense_buffer[2],\n\t\t\t\t\t*((unsigned int *)(cmd->sense_buffer + 3)));\n\t\t}\n\n\t\tif (status == SAM_STAT_CHECK_CONDITION) {\n\t\t\tset_host_byte(cmd, DID_BAD_TARGET);\n\t\t\tgoto ckc_e;\n\t\t}\n\t\tdprintkdbg(DBG_0, \"srb_done: AUTO_REQSENSE2\\n\");\n\n\t\tset_status_byte(cmd, SAM_STAT_CHECK_CONDITION);\n\n\t\tgoto ckc_e;\n\t}\n\n \n\tif (status) {\n\t\t \n\t\tif (status == SAM_STAT_CHECK_CONDITION) {\n\t\t\trequest_sense(acb, dcb, srb);\n\t\t\treturn;\n\t\t} else if (status == SAM_STAT_TASK_SET_FULL) {\n\t\t\ttempcnt = (u8)list_size(&dcb->srb_going_list);\n\t\t\tdprintkl(KERN_INFO, \"QUEUE_FULL for dev <%02i-%i> with %i cmnds\\n\",\n\t\t\t     dcb->target_id, dcb->target_lun, tempcnt);\n\t\t\tif (tempcnt > 1)\n\t\t\t\ttempcnt--;\n\t\t\tdcb->max_command = tempcnt;\n\t\t\tfree_tag(dcb, srb);\n\t\t\tlist_move(&srb->list, &dcb->srb_waiting_list);\n\t\t\twaiting_set_timer(acb, HZ / 20);\n\t\t\tsrb->adapter_status = 0;\n\t\t\tsrb->target_status = 0;\n\t\t\treturn;\n\t\t} else if (status == SCSI_STAT_SEL_TIMEOUT) {\n\t\t\tsrb->adapter_status = H_SEL_TIMEOUT;\n\t\t\tsrb->target_status = 0;\n\t\t\tset_host_byte(cmd, DID_NO_CONNECT);\n\t\t} else {\n\t\t\tsrb->adapter_status = 0;\n\t\t\tset_host_byte(cmd, DID_ERROR);\n\t\t\tset_status_byte(cmd, status);\n\t\t}\n\t} else {\n\t\t \n\t\tstatus = srb->adapter_status;\n\t\tif (status & H_OVER_UNDER_RUN) {\n\t\t\tsrb->target_status = 0;\n\t\t\tscsi_msg_to_host_byte(cmd, srb->end_message);\n\t\t} else if (srb->status & PARITY_ERROR) {\n\t\t\tset_host_byte(cmd, DID_PARITY);\n\t\t} else {\t \n\n\t\t\tsrb->adapter_status = 0;\n\t\t\tsrb->target_status = 0;\n\t\t}\n\t}\n\n\tckc_only = 0;\n \n      ckc_e:\n\n\tpci_unmap_srb(acb, srb);\n\n\tif (cmd->cmnd[0] == INQUIRY) {\n\t\tunsigned char *base = NULL;\n\t\tstruct ScsiInqData *ptr;\n\t\tunsigned long flags = 0;\n\t\tstruct scatterlist* sg = scsi_sglist(cmd);\n\t\tsize_t offset = 0, len = sizeof(struct ScsiInqData);\n\n\t\tlocal_irq_save(flags);\n\t\tbase = scsi_kmap_atomic_sg(sg, scsi_sg_count(cmd), &offset, &len);\n\t\tptr = (struct ScsiInqData *)(base + offset);\n\n\t\tif (!ckc_only && get_host_byte(cmd) == DID_OK\n\t\t    && cmd->cmnd[2] == 0 && scsi_bufflen(cmd) >= 8\n\t\t    && dir != DMA_NONE && ptr && (ptr->Vers & 0x07) >= 2)\n\t\t\tdcb->inquiry7 = ptr->Flags;\n\n\t \n\t \n\t\tif ((get_host_byte(cmd) == DID_OK) ||\n\t\t    (get_status_byte(cmd) == SAM_STAT_CHECK_CONDITION)) {\n\t\t\tif (!dcb->init_tcq_flag) {\n\t\t\t\tadd_dev(acb, dcb, ptr);\n\t\t\t\tdcb->init_tcq_flag = 1;\n\t\t\t}\n\t\t}\n\n\t\tscsi_kunmap_atomic_sg(base);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\t \n\tscsi_set_resid(cmd, srb->total_xfer_length);\n\tif (debug_enabled(DBG_KG)) {\n\t\tif (srb->total_xfer_length)\n\t\t\tdprintkdbg(DBG_KG, \"srb_done: (0x%p) <%02i-%i> \"\n\t\t\t\t\"cmnd=0x%02x Missed %i bytes\\n\",\n\t\t\t\tcmd, cmd->device->id, (u8)cmd->device->lun,\n\t\t\t\tcmd->cmnd[0], srb->total_xfer_length);\n\t}\n\n\tif (srb != acb->tmp_srb) {\n\t\t \n\t\tdprintkdbg(DBG_0, \"srb_done: (0x%p) done result=0x%08x\\n\",\n\t\t\t   cmd, cmd->result);\n\t\tlist_move_tail(&srb->list, &acb->srb_free_list);\n\t} else {\n\t\tdprintkl(KERN_ERR, \"srb_done: ERROR! Completed cmd with tmp_srb\\n\");\n\t}\n\n\tscsi_done(cmd);\n\twaiting_process_next(acb);\n}\n\n\n \nstatic void doing_srb_done(struct AdapterCtlBlk *acb, u8 did_flag,\n\t\tstruct scsi_cmnd *cmd, u8 force)\n{\n\tstruct DeviceCtlBlk *dcb;\n\tdprintkl(KERN_INFO, \"doing_srb_done: pids \");\n\n\tlist_for_each_entry(dcb, &acb->dcb_list, list) {\n\t\tstruct ScsiReqBlk *srb;\n\t\tstruct ScsiReqBlk *tmp;\n\t\tstruct scsi_cmnd *p;\n\n\t\tlist_for_each_entry_safe(srb, tmp, &dcb->srb_going_list, list) {\n\t\t\tp = srb->cmd;\n\t\t\tprintk(\"G:%p(%02i-%i) \", p,\n\t\t\t       p->device->id, (u8)p->device->lun);\n\t\t\tlist_del(&srb->list);\n\t\t\tfree_tag(dcb, srb);\n\t\t\tlist_add_tail(&srb->list, &acb->srb_free_list);\n\t\t\tset_host_byte(p, did_flag);\n\t\t\tset_status_byte(p, SAM_STAT_GOOD);\n\t\t\tpci_unmap_srb_sense(acb, srb);\n\t\t\tpci_unmap_srb(acb, srb);\n\t\t\tif (force) {\n\t\t\t\t \n\t\t\t\tscsi_done(p);\n\t\t\t}\n\t\t}\n\t\tif (!list_empty(&dcb->srb_going_list))\n\t\t\tdprintkl(KERN_DEBUG, \n\t\t\t       \"How could the ML send cmnds to the Going queue? <%02i-%i>\\n\",\n\t\t\t       dcb->target_id, dcb->target_lun);\n\t\tif (dcb->tag_mask)\n\t\t\tdprintkl(KERN_DEBUG,\n\t\t\t       \"tag_mask for <%02i-%i> should be empty, is %08x!\\n\",\n\t\t\t       dcb->target_id, dcb->target_lun,\n\t\t\t       dcb->tag_mask);\n\n\t\t \n\t\tlist_for_each_entry_safe(srb, tmp, &dcb->srb_waiting_list, list) {\n\t\t\tp = srb->cmd;\n\n\t\t\tprintk(\"W:%p<%02i-%i>\", p, p->device->id,\n\t\t\t       (u8)p->device->lun);\n\t\t\tlist_move_tail(&srb->list, &acb->srb_free_list);\n\t\t\tset_host_byte(p, did_flag);\n\t\t\tset_status_byte(p, SAM_STAT_GOOD);\n\t\t\tpci_unmap_srb_sense(acb, srb);\n\t\t\tpci_unmap_srb(acb, srb);\n\t\t\tif (force) {\n\t\t\t\t \n\t\t\t\tscsi_done(cmd);\n\t\t\t}\n\t\t}\n\t\tif (!list_empty(&dcb->srb_waiting_list))\n\t\t\tdprintkl(KERN_DEBUG, \"ML queued %i cmnds again to <%02i-%i>\\n\",\n\t\t\t     list_size(&dcb->srb_waiting_list), dcb->target_id,\n\t\t\t     dcb->target_lun);\n\t\tdcb->flag &= ~ABORT_DEV_;\n\t}\n\tprintk(\"\\n\");\n}\n\n\nstatic void reset_scsi_bus(struct AdapterCtlBlk *acb)\n{\n\tdprintkdbg(DBG_0, \"reset_scsi_bus: acb=%p\\n\", acb);\n\tacb->acb_flag |= RESET_DEV;\t \n\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_RSTSCSI);\n\n\twhile (!(DC395x_read8(acb, TRM_S1040_SCSI_INTSTATUS) & INT_SCSIRESET))\n\t\t ;\n}\n\n\nstatic void set_basic_config(struct AdapterCtlBlk *acb)\n{\n\tu8 bval;\n\tu16 wval;\n\tDC395x_write8(acb, TRM_S1040_SCSI_TIMEOUT, acb->sel_timeout);\n\tif (acb->config & HCC_PARITY)\n\t\tbval = PHASELATCH | INITIATOR | BLOCKRST | PARITYCHECK;\n\telse\n\t\tbval = PHASELATCH | INITIATOR | BLOCKRST;\n\n\tDC395x_write8(acb, TRM_S1040_SCSI_CONFIG0, bval);\n\n\t \n\tDC395x_write8(acb, TRM_S1040_SCSI_CONFIG1, 0x03);\t \n\t \n\tDC395x_write8(acb, TRM_S1040_SCSI_HOSTID, acb->scsi_host->this_id);\n\t \n\tDC395x_write8(acb, TRM_S1040_SCSI_OFFSET, 0x00);\n\t \n\twval = DC395x_read16(acb, TRM_S1040_GEN_CONTROL) & 0x7F;\n\tDC395x_write16(acb, TRM_S1040_GEN_CONTROL, wval);\n\t \n\twval = DC395x_read16(acb, TRM_S1040_DMA_CONFIG) & ~DMA_FIFO_CTRL;\n\twval |=\n\t    DMA_FIFO_HALF_HALF | DMA_ENHANCE   ;\n\tDC395x_write16(acb, TRM_S1040_DMA_CONFIG, wval);\n\t \n\tDC395x_read8(acb, TRM_S1040_SCSI_INTSTATUS);\n\t \n\tDC395x_write8(acb, TRM_S1040_SCSI_INTEN, 0x7F);\n\tDC395x_write8(acb, TRM_S1040_DMA_INTEN, EN_SCSIINTR | EN_DMAXFERERROR\n\t\t       \n\t\t      );\n}\n\n\nstatic void scsi_reset_detect(struct AdapterCtlBlk *acb)\n{\n\tdprintkl(KERN_INFO, \"scsi_reset_detect: acb=%p\\n\", acb);\n\t \n\tif (timer_pending(&acb->waiting_timer))\n\t\tdel_timer(&acb->waiting_timer);\n\n\tDC395x_write8(acb, TRM_S1040_SCSI_CONTROL, DO_RSTMODULE);\n\tDC395x_write8(acb, TRM_S1040_DMA_CONTROL, DMARESETMODULE);\n\t \n\tudelay(500);\n\t \n\tacb->last_reset =\n\t    jiffies + 5 * HZ / 2 +\n\t    HZ * acb->eeprom.delay_time;\n\n\tclear_fifo(acb, \"scsi_reset_detect\");\n\tset_basic_config(acb);\n\t \n\t \n\n\tif (acb->acb_flag & RESET_DEV) {\t \n\t\tacb->acb_flag |= RESET_DONE;\n\t} else {\n\t\tacb->acb_flag |= RESET_DETECT;\n\t\treset_dev_param(acb);\n\t\tdoing_srb_done(acb, DID_RESET, NULL, 1);\n\t\t \n\t\tacb->active_dcb = NULL;\n\t\tacb->acb_flag = 0;\n\t\twaiting_process_next(acb);\n\t}\n}\n\n\nstatic void request_sense(struct AdapterCtlBlk *acb, struct DeviceCtlBlk *dcb,\n\t\tstruct ScsiReqBlk *srb)\n{\n\tstruct scsi_cmnd *cmd = srb->cmd;\n\tdprintkdbg(DBG_1, \"request_sense: (0x%p) <%02i-%i>\\n\",\n\t\tcmd, cmd->device->id, (u8)cmd->device->lun);\n\n\tsrb->flag |= AUTO_REQSENSE;\n\tsrb->adapter_status = 0;\n\tsrb->target_status = 0;\n\n\t \n\tmemset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\n\n\t \n\tsrb->segment_x[DC395x_MAX_SG_LISTENTRY - 1].address =\n\t    srb->segment_x[0].address;\n\tsrb->segment_x[DC395x_MAX_SG_LISTENTRY - 1].length =\n\t    srb->segment_x[0].length;\n\tsrb->xferred = srb->total_xfer_length;\n\t \n\tsrb->total_xfer_length = SCSI_SENSE_BUFFERSIZE;\n\tsrb->segment_x[0].length = SCSI_SENSE_BUFFERSIZE;\n\t \n\tsrb->segment_x[0].address = dma_map_single(&acb->dev->dev,\n\t\t\tcmd->sense_buffer, SCSI_SENSE_BUFFERSIZE,\n\t\t\tDMA_FROM_DEVICE);\n\tdprintkdbg(DBG_SG, \"request_sense: map buffer %p->%08x(%05x)\\n\",\n\t       cmd->sense_buffer, srb->segment_x[0].address,\n\t       SCSI_SENSE_BUFFERSIZE);\n\tsrb->sg_count = 1;\n\tsrb->sg_index = 0;\n\n\tif (start_scsi(acb, dcb, srb)) {\t \n\t\tdprintkl(KERN_DEBUG,\n\t\t\t\"request_sense: (0x%p) failed <%02i-%i>\\n\",\n\t\t\tsrb->cmd, dcb->target_id, dcb->target_lun);\n\t\tlist_move(&srb->list, &dcb->srb_waiting_list);\n\t\twaiting_set_timer(acb, HZ / 100);\n\t}\n}\n\n\n \nstatic struct DeviceCtlBlk *device_alloc(struct AdapterCtlBlk *acb,\n\t\tu8 target, u8 lun)\n{\n\tstruct NvRamType *eeprom = &acb->eeprom;\n\tu8 period_index = eeprom->target[target].period & 0x07;\n\tstruct DeviceCtlBlk *dcb;\n\n\tdcb = kmalloc(sizeof(struct DeviceCtlBlk), GFP_ATOMIC);\n\tdprintkdbg(DBG_0, \"device_alloc: <%02i-%i>\\n\", target, lun);\n\tif (!dcb)\n\t\treturn NULL;\n\tdcb->acb = NULL;\n\tINIT_LIST_HEAD(&dcb->srb_going_list);\n\tINIT_LIST_HEAD(&dcb->srb_waiting_list);\n\tdcb->active_srb = NULL;\n\tdcb->tag_mask = 0;\n\tdcb->max_command = 1;\n\tdcb->target_id = target;\n\tdcb->target_lun = lun;\n\tdcb->dev_mode = eeprom->target[target].cfg0;\n#ifndef DC395x_NO_DISCONNECT\n\tdcb->identify_msg =\n\t    IDENTIFY(dcb->dev_mode & NTC_DO_DISCONNECT, lun);\n#else\n\tdcb->identify_msg = IDENTIFY(0, lun);\n#endif\n\tdcb->inquiry7 = 0;\n\tdcb->sync_mode = 0;\n\tdcb->min_nego_period = clock_period[period_index];\n\tdcb->sync_period = 0;\n\tdcb->sync_offset = 0;\n\tdcb->flag = 0;\n\n#ifndef DC395x_NO_WIDE\n\tif ((dcb->dev_mode & NTC_DO_WIDE_NEGO)\n\t    && (acb->config & HCC_WIDE_CARD))\n\t\tdcb->sync_mode |= WIDE_NEGO_ENABLE;\n#endif\n#ifndef DC395x_NO_SYNC\n\tif (dcb->dev_mode & NTC_DO_SYNC_NEGO)\n\t\tif (!(lun) || current_sync_offset)\n\t\t\tdcb->sync_mode |= SYNC_NEGO_ENABLE;\n#endif\n\tif (dcb->target_lun != 0) {\n\t\t \n\t\tstruct DeviceCtlBlk *p = NULL, *iter;\n\n\t\tlist_for_each_entry(iter, &acb->dcb_list, list)\n\t\t\tif (iter->target_id == dcb->target_id) {\n\t\t\t\tp = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!p) {\n\t\t\tkfree(dcb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdprintkdbg(DBG_1, \n\t\t       \"device_alloc: <%02i-%i> copy from <%02i-%i>\\n\",\n\t\t       dcb->target_id, dcb->target_lun,\n\t\t       p->target_id, p->target_lun);\n\t\tdcb->sync_mode = p->sync_mode;\n\t\tdcb->sync_period = p->sync_period;\n\t\tdcb->min_nego_period = p->min_nego_period;\n\t\tdcb->sync_offset = p->sync_offset;\n\t\tdcb->inquiry7 = p->inquiry7;\n\t}\n\treturn dcb;\n}\n\n\n \nstatic void adapter_add_device(struct AdapterCtlBlk *acb,\n\t\tstruct DeviceCtlBlk *dcb)\n{\n\t \n\tdcb->acb = acb;\n\t\n\t \n\tif (list_empty(&acb->dcb_list))\n\t\tacb->dcb_run_robin = dcb;\n\n\t \n\tlist_add_tail(&dcb->list, &acb->dcb_list);\n\n\t \n\tacb->dcb_map[dcb->target_id] |= (1 << dcb->target_lun);\n\tacb->children[dcb->target_id][dcb->target_lun] = dcb;\n}\n\n\n \nstatic void adapter_remove_device(struct AdapterCtlBlk *acb,\n\t\tstruct DeviceCtlBlk *dcb)\n{\n\tstruct DeviceCtlBlk *i;\n\tstruct DeviceCtlBlk *tmp;\n\tdprintkdbg(DBG_0, \"adapter_remove_device: <%02i-%i>\\n\",\n\t\tdcb->target_id, dcb->target_lun);\n\n\t \n\tif (acb->active_dcb == dcb)\n\t\tacb->active_dcb = NULL;\n\tif (acb->dcb_run_robin == dcb)\n\t\tacb->dcb_run_robin = dcb_get_next(&acb->dcb_list, dcb);\n\n\t \n\tlist_for_each_entry_safe(i, tmp, &acb->dcb_list, list)\n\t\tif (dcb == i) {\n\t\t\tlist_del(&i->list);\n\t\t\tbreak;\n\t\t}\n\n\t \t\n\tacb->dcb_map[dcb->target_id] &= ~(1 << dcb->target_lun);\n\tacb->children[dcb->target_id][dcb->target_lun] = NULL;\n\tdcb->acb = NULL;\n}\n\n\n \nstatic void adapter_remove_and_free_device(struct AdapterCtlBlk *acb,\n\t\tstruct DeviceCtlBlk *dcb)\n{\n\tif (list_size(&dcb->srb_going_list) > 1) {\n\t\tdprintkdbg(DBG_1, \"adapter_remove_and_free_device: <%02i-%i> \"\n\t\t           \"Won't remove because of %i active requests.\\n\",\n\t\t\t   dcb->target_id, dcb->target_lun,\n\t\t\t   list_size(&dcb->srb_going_list));\n\t\treturn;\n\t}\n\tadapter_remove_device(acb, dcb);\n\tkfree(dcb);\n}\n\n\n \nstatic void adapter_remove_and_free_all_devices(struct AdapterCtlBlk* acb)\n{\n\tstruct DeviceCtlBlk *dcb;\n\tstruct DeviceCtlBlk *tmp;\n\tdprintkdbg(DBG_1, \"adapter_remove_and_free_all_devices: num=%i\\n\",\n\t\t   list_size(&acb->dcb_list));\n\n\tlist_for_each_entry_safe(dcb, tmp, &acb->dcb_list, list)\n\t\tadapter_remove_and_free_device(acb, dcb);\n}\n\n\n \nstatic int dc395x_slave_alloc(struct scsi_device *scsi_device)\n{\n\tstruct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)scsi_device->host->hostdata;\n\tstruct DeviceCtlBlk *dcb;\n\n\tdcb = device_alloc(acb, scsi_device->id, scsi_device->lun);\n\tif (!dcb)\n\t\treturn -ENOMEM;\n\tadapter_add_device(acb, dcb);\n\n\treturn 0;\n}\n\n\n \nstatic void dc395x_slave_destroy(struct scsi_device *scsi_device)\n{\n\tstruct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)scsi_device->host->hostdata;\n\tstruct DeviceCtlBlk *dcb = find_dcb(acb, scsi_device->id, scsi_device->lun);\n\tif (dcb)\n\t\tadapter_remove_and_free_device(acb, dcb);\n}\n\n\n\n\n \nstatic void trms1040_wait_30us(unsigned long io_port)\n{\n\t \n\toutb(5, io_port + TRM_S1040_GEN_TIMER);\n\twhile (!(inb(io_port + TRM_S1040_GEN_STATUS) & GTIMEOUT))\n\t\t  ;\n}\n\n\n \nstatic void trms1040_write_cmd(unsigned long io_port, u8 cmd, u8 addr)\n{\n\tint i;\n\tu8 send_data;\n\n\t \n\tfor (i = 0; i < 3; i++, cmd <<= 1) {\n\t\tsend_data = NVR_SELECT;\n\t\tif (cmd & 0x04)\t \n\t\t\tsend_data |= NVR_BITOUT;\n\n\t\toutb(send_data, io_port + TRM_S1040_GEN_NVRAM);\n\t\ttrms1040_wait_30us(io_port);\n\t\toutb((send_data | NVR_CLOCK),\n\t\t     io_port + TRM_S1040_GEN_NVRAM);\n\t\ttrms1040_wait_30us(io_port);\n\t}\n\n\t \n\tfor (i = 0; i < 7; i++, addr <<= 1) {\n\t\tsend_data = NVR_SELECT;\n\t\tif (addr & 0x40)\t \n\t\t\tsend_data |= NVR_BITOUT;\n\n\t\toutb(send_data, io_port + TRM_S1040_GEN_NVRAM);\n\t\ttrms1040_wait_30us(io_port);\n\t\toutb((send_data | NVR_CLOCK),\n\t\t     io_port + TRM_S1040_GEN_NVRAM);\n\t\ttrms1040_wait_30us(io_port);\n\t}\n\toutb(NVR_SELECT, io_port + TRM_S1040_GEN_NVRAM);\n\ttrms1040_wait_30us(io_port);\n}\n\n\n \nstatic void trms1040_set_data(unsigned long io_port, u8 addr, u8 byte)\n{\n\tint i;\n\tu8 send_data;\n\n\t \n\ttrms1040_write_cmd(io_port, 0x05, addr);\n\n\t \n\tfor (i = 0; i < 8; i++, byte <<= 1) {\n\t\tsend_data = NVR_SELECT;\n\t\tif (byte & 0x80)\t \n\t\t\tsend_data |= NVR_BITOUT;\n\n\t\toutb(send_data, io_port + TRM_S1040_GEN_NVRAM);\n\t\ttrms1040_wait_30us(io_port);\n\t\toutb((send_data | NVR_CLOCK), io_port + TRM_S1040_GEN_NVRAM);\n\t\ttrms1040_wait_30us(io_port);\n\t}\n\toutb(NVR_SELECT, io_port + TRM_S1040_GEN_NVRAM);\n\ttrms1040_wait_30us(io_port);\n\n\t \n\toutb(0, io_port + TRM_S1040_GEN_NVRAM);\n\ttrms1040_wait_30us(io_port);\n\n\toutb(NVR_SELECT, io_port + TRM_S1040_GEN_NVRAM);\n\ttrms1040_wait_30us(io_port);\n\n\t \n\twhile (1) {\n\t\toutb((NVR_SELECT | NVR_CLOCK), io_port + TRM_S1040_GEN_NVRAM);\n\t\ttrms1040_wait_30us(io_port);\n\n\t\toutb(NVR_SELECT, io_port + TRM_S1040_GEN_NVRAM);\n\t\ttrms1040_wait_30us(io_port);\n\n\t\tif (inb(io_port + TRM_S1040_GEN_NVRAM) & NVR_BITIN)\n\t\t\tbreak;\n\t}\n\n\t \n\toutb(0, io_port + TRM_S1040_GEN_NVRAM);\n}\n\n\n \nstatic void trms1040_write_all(struct NvRamType *eeprom, unsigned long io_port)\n{\n\tu8 *b_eeprom = (u8 *)eeprom;\n\tu8 addr;\n\n\t \n\toutb((inb(io_port + TRM_S1040_GEN_CONTROL) | EN_EEPROM),\n\t     io_port + TRM_S1040_GEN_CONTROL);\n\n\t \n\ttrms1040_write_cmd(io_port, 0x04, 0xFF);\n\toutb(0, io_port + TRM_S1040_GEN_NVRAM);\n\ttrms1040_wait_30us(io_port);\n\n\t \n\tfor (addr = 0; addr < 128; addr++, b_eeprom++)\n\t\ttrms1040_set_data(io_port, addr, *b_eeprom);\n\n\t \n\ttrms1040_write_cmd(io_port, 0x04, 0x00);\n\toutb(0, io_port + TRM_S1040_GEN_NVRAM);\n\ttrms1040_wait_30us(io_port);\n\n\t \n\toutb((inb(io_port + TRM_S1040_GEN_CONTROL) & ~EN_EEPROM),\n\t     io_port + TRM_S1040_GEN_CONTROL);\n}\n\n\n \nstatic u8 trms1040_get_data(unsigned long io_port, u8 addr)\n{\n\tint i;\n\tu8 read_byte;\n\tu8 result = 0;\n\n\t \n\ttrms1040_write_cmd(io_port, 0x06, addr);\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\toutb((NVR_SELECT | NVR_CLOCK), io_port + TRM_S1040_GEN_NVRAM);\n\t\ttrms1040_wait_30us(io_port);\n\t\toutb(NVR_SELECT, io_port + TRM_S1040_GEN_NVRAM);\n\n\t\t \n\t\tread_byte = inb(io_port + TRM_S1040_GEN_NVRAM);\n\t\tresult <<= 1;\n\t\tif (read_byte & NVR_BITIN)\n\t\t\tresult |= 1;\n\n\t\ttrms1040_wait_30us(io_port);\n\t}\n\n\t \n\toutb(0, io_port + TRM_S1040_GEN_NVRAM);\n\treturn result;\n}\n\n\n \nstatic void trms1040_read_all(struct NvRamType *eeprom, unsigned long io_port)\n{\n\tu8 *b_eeprom = (u8 *)eeprom;\n\tu8 addr;\n\n\t \n\toutb((inb(io_port + TRM_S1040_GEN_CONTROL) | EN_EEPROM),\n\t     io_port + TRM_S1040_GEN_CONTROL);\n\n\t \n\tfor (addr = 0; addr < 128; addr++, b_eeprom++)\n\t\t*b_eeprom = trms1040_get_data(io_port, addr);\n\n\t \n\toutb((inb(io_port + TRM_S1040_GEN_CONTROL) & ~EN_EEPROM),\n\t     io_port + TRM_S1040_GEN_CONTROL);\n}\n\n\n\n \nstatic void check_eeprom(struct NvRamType *eeprom, unsigned long io_port)\n{\n\tu16 *w_eeprom = (u16 *)eeprom;\n\tu16 w_addr;\n\tu16 cksum;\n\tu32 d_addr;\n\tu32 *d_eeprom;\n\n\ttrms1040_read_all(eeprom, io_port);\t \n\n\tcksum = 0;\n\tfor (w_addr = 0, w_eeprom = (u16 *)eeprom; w_addr < 64;\n\t     w_addr++, w_eeprom++)\n\t\tcksum += *w_eeprom;\n\tif (cksum != 0x1234) {\n\t\t \n\t\tdprintkl(KERN_WARNING,\n\t\t\t\"EEProm checksum error: using default values and options.\\n\");\n\t\teeprom->sub_vendor_id[0] = (u8)PCI_VENDOR_ID_TEKRAM;\n\t\teeprom->sub_vendor_id[1] = (u8)(PCI_VENDOR_ID_TEKRAM >> 8);\n\t\teeprom->sub_sys_id[0] = (u8)PCI_DEVICE_ID_TEKRAM_TRMS1040;\n\t\teeprom->sub_sys_id[1] =\n\t\t    (u8)(PCI_DEVICE_ID_TEKRAM_TRMS1040 >> 8);\n\t\teeprom->sub_class = 0x00;\n\t\teeprom->vendor_id[0] = (u8)PCI_VENDOR_ID_TEKRAM;\n\t\teeprom->vendor_id[1] = (u8)(PCI_VENDOR_ID_TEKRAM >> 8);\n\t\teeprom->device_id[0] = (u8)PCI_DEVICE_ID_TEKRAM_TRMS1040;\n\t\teeprom->device_id[1] =\n\t\t    (u8)(PCI_DEVICE_ID_TEKRAM_TRMS1040 >> 8);\n\t\teeprom->reserved = 0x00;\n\n\t\tfor (d_addr = 0, d_eeprom = (u32 *)eeprom->target;\n\t\t     d_addr < 16; d_addr++, d_eeprom++)\n\t\t\t*d_eeprom = 0x00000077;\t \n\n\t\t*d_eeprom++ = 0x04000F07;\t \n\t\t*d_eeprom++ = 0x00000015;\t \n\t\tfor (d_addr = 0; d_addr < 12; d_addr++, d_eeprom++)\n\t\t\t*d_eeprom = 0x00;\n\n\t\t \n\t\tset_safe_settings();\n\t\tfix_settings();\n\t\teeprom_override(eeprom);\n\n\t\teeprom->cksum = 0x00;\n\t\tfor (w_addr = 0, cksum = 0, w_eeprom = (u16 *)eeprom;\n\t\t     w_addr < 63; w_addr++, w_eeprom++)\n\t\t\tcksum += *w_eeprom;\n\n\t\t*w_eeprom = 0x1234 - cksum;\n\t\ttrms1040_write_all(eeprom, io_port);\n\t\teeprom->delay_time = cfg_data[CFG_RESET_DELAY].value;\n\t} else {\n\t\tset_safe_settings();\n\t\teeprom_index_to_delay(eeprom);\n\t\teeprom_override(eeprom);\n\t}\n}\n\n\n \nstatic void print_eeprom_settings(struct NvRamType *eeprom)\n{\n\tdprintkl(KERN_INFO, \"Used settings: AdapterID=%02i, Speed=%i(%02i.%01iMHz), dev_mode=0x%02x\\n\",\n\t\teeprom->scsi_id,\n\t\teeprom->target[0].period,\n\t\tclock_speed[eeprom->target[0].period] / 10,\n\t\tclock_speed[eeprom->target[0].period] % 10,\n\t\teeprom->target[0].cfg0);\n\tdprintkl(KERN_INFO, \"               AdaptMode=0x%02x, Tags=%i(%02i), DelayReset=%is\\n\",\n\t\teeprom->channel_cfg, eeprom->max_tag,\n\t\t1 << eeprom->max_tag, eeprom->delay_time);\n}\n\n\n \nstatic void adapter_sg_tables_free(struct AdapterCtlBlk *acb)\n{\n\tint i;\n\tconst unsigned srbs_per_page = PAGE_SIZE/SEGMENTX_LEN;\n\n\tfor (i = 0; i < DC395x_MAX_SRB_CNT; i += srbs_per_page)\n\t\tkfree(acb->srb_array[i].segment_x);\n}\n\n\n \nstatic int adapter_sg_tables_alloc(struct AdapterCtlBlk *acb)\n{\n\tconst unsigned mem_needed = (DC395x_MAX_SRB_CNT+1)\n\t                            *SEGMENTX_LEN;\n\tint pages = (mem_needed+(PAGE_SIZE-1))/PAGE_SIZE;\n\tconst unsigned srbs_per_page = PAGE_SIZE/SEGMENTX_LEN;\n\tint srb_idx = 0;\n\tunsigned i = 0;\n\tstruct SGentry *ptr;\n\n\tfor (i = 0; i < DC395x_MAX_SRB_CNT; i++)\n\t\tacb->srb_array[i].segment_x = NULL;\n\n\tdprintkdbg(DBG_1, \"Allocate %i pages for SG tables\\n\", pages);\n\twhile (pages--) {\n\t\tptr = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\t\tif (!ptr) {\n\t\t\tadapter_sg_tables_free(acb);\n\t\t\treturn 1;\n\t\t}\n\t\tdprintkdbg(DBG_1, \"Allocate %li bytes at %p for SG segments %i\\n\",\n\t\t\tPAGE_SIZE, ptr, srb_idx);\n\t\ti = 0;\n\t\twhile (i < srbs_per_page && srb_idx < DC395x_MAX_SRB_CNT)\n\t\t\tacb->srb_array[srb_idx++].segment_x =\n\t\t\t    ptr + (i++ * DC395x_MAX_SG_LISTENTRY);\n\t}\n\tif (i < srbs_per_page)\n\t\tacb->srb.segment_x =\n\t\t    ptr + (i * DC395x_MAX_SG_LISTENTRY);\n\telse\n\t\tdprintkl(KERN_DEBUG, \"No space for tmsrb SG table reserved?!\\n\");\n\treturn 0;\n}\n\n\n\n \nstatic void adapter_print_config(struct AdapterCtlBlk *acb)\n{\n\tu8 bval;\n\n\tbval = DC395x_read8(acb, TRM_S1040_GEN_STATUS);\n\tdprintkl(KERN_INFO, \"%sConnectors: \",\n\t\t((bval & WIDESCSI) ? \"(Wide) \" : \"\"));\n\tif (!(bval & CON5068))\n\t\tprintk(\"ext%s \", !(bval & EXT68HIGH) ? \"68\" : \"50\");\n\tif (!(bval & CON68))\n\t\tprintk(\"int68%s \", !(bval & INT68HIGH) ? \"\" : \"(50)\");\n\tif (!(bval & CON50))\n\t\tprintk(\"int50 \");\n\tif ((bval & (CON5068 | CON50 | CON68)) ==\n\t    0   )\n\t\tprintk(\" Oops! (All 3?) \");\n\tbval = DC395x_read8(acb, TRM_S1040_GEN_CONTROL);\n\tprintk(\" Termination: \");\n\tif (bval & DIS_TERM)\n\t\tprintk(\"Disabled\\n\");\n\telse {\n\t\tif (bval & AUTOTERM)\n\t\t\tprintk(\"Auto \");\n\t\tif (bval & LOW8TERM)\n\t\t\tprintk(\"Low \");\n\t\tif (bval & UP8TERM)\n\t\t\tprintk(\"High \");\n\t\tprintk(\"\\n\");\n\t}\n}\n\n\n \nstatic void adapter_init_params(struct AdapterCtlBlk *acb)\n{\n\tstruct NvRamType *eeprom = &acb->eeprom;\n\tint i;\n\n\t \n\t \n\t \n\n\tINIT_LIST_HEAD(&acb->dcb_list);\n\tacb->dcb_run_robin = NULL;\n\tacb->active_dcb = NULL;\n\n\tINIT_LIST_HEAD(&acb->srb_free_list);\n\t \n\tacb->tmp_srb = &acb->srb;\n\ttimer_setup(&acb->waiting_timer, waiting_timeout, 0);\n\ttimer_setup(&acb->selto_timer, NULL, 0);\n\n\tacb->srb_count = DC395x_MAX_SRB_CNT;\n\n\tacb->sel_timeout = DC395x_SEL_TIMEOUT;\t \n\t \n\n\tacb->tag_max_num = 1 << eeprom->max_tag;\n\tif (acb->tag_max_num > 30)\n\t\tacb->tag_max_num = 30;\n\n\tacb->acb_flag = 0;\t \n\tacb->gmode2 = eeprom->channel_cfg;\n\tacb->config = 0;\t \n\n\tif (eeprom->channel_cfg & NAC_SCANLUN)\n\t\tacb->lun_chk = 1;\n\tacb->scan_devices = 1;\n\n\tacb->scsi_host->this_id = eeprom->scsi_id;\n\tacb->hostid_bit = (1 << acb->scsi_host->this_id);\n\n\tfor (i = 0; i < DC395x_MAX_SCSI_ID; i++)\n\t\tacb->dcb_map[i] = 0;\n\n\tacb->msg_len = 0;\n\t\n\t \n\tfor (i = 0; i < acb->srb_count - 1; i++)\n\t\tlist_add_tail(&acb->srb_array[i].list, &acb->srb_free_list);\n}\n\n\n \nstatic void adapter_init_scsi_host(struct Scsi_Host *host)\n{\n        struct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)host->hostdata;\n\tstruct NvRamType *eeprom = &acb->eeprom;\n        \n\thost->max_cmd_len = 24;\n\thost->can_queue = DC395x_MAX_CMD_QUEUE;\n\thost->cmd_per_lun = DC395x_MAX_CMD_PER_LUN;\n\thost->this_id = (int)eeprom->scsi_id;\n\thost->io_port = acb->io_port_base;\n\thost->n_io_port = acb->io_port_len;\n\thost->dma_channel = -1;\n\thost->unique_id = acb->io_port_base;\n\thost->irq = acb->irq_level;\n\tacb->last_reset = jiffies;\n\n\thost->max_id = 16;\n\tif (host->max_id - 1 == eeprom->scsi_id)\n\t\thost->max_id--;\n\n\tif (eeprom->channel_cfg & NAC_SCANLUN)\n\t\thost->max_lun = 8;\n\telse\n\t\thost->max_lun = 1;\n}\n\n\n \nstatic void adapter_init_chip(struct AdapterCtlBlk *acb)\n{\n        struct NvRamType *eeprom = &acb->eeprom;\n        \n         \n\tDC395x_write8(acb, TRM_S1040_DMA_INTEN, 0x00);\n\tDC395x_write8(acb, TRM_S1040_SCSI_INTEN, 0x00);\n\n\t \n\tDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_RSTMODULE);\n\n\t \n\tDC395x_write8(acb, TRM_S1040_DMA_CONTROL, DMARESETMODULE);\n\tudelay(20);\n\n\t \n\tacb->config = HCC_AUTOTERM | HCC_PARITY;\n\tif (DC395x_read8(acb, TRM_S1040_GEN_STATUS) & WIDESCSI)\n\t\tacb->config |= HCC_WIDE_CARD;\n\n\tif (eeprom->channel_cfg & NAC_POWERON_SCSI_RESET)\n\t\tacb->config |= HCC_SCSI_RESET;\n\n\tif (acb->config & HCC_SCSI_RESET) {\n\t\tdprintkl(KERN_INFO, \"Performing initial SCSI bus reset\\n\");\n\t\tDC395x_write8(acb, TRM_S1040_SCSI_CONTROL, DO_RSTSCSI);\n\n\t\t \n\t\t \n\t\tudelay(500);\n\n\t\tacb->last_reset =\n\t\t    jiffies + HZ / 2 +\n\t\t    HZ * acb->eeprom.delay_time;\n\n\t\t \n\t}\n}\n\n\n \nstatic int adapter_init(struct AdapterCtlBlk *acb, unsigned long io_port,\n\t\t\tu32 io_port_len, unsigned int irq)\n{\n\tif (!request_region(io_port, io_port_len, DC395X_NAME)) {\n\t\tdprintkl(KERN_ERR, \"Failed to reserve IO region 0x%lx\\n\", io_port);\n\t\tgoto failed;\n\t}\n\t \n\tacb->io_port_base = io_port;\n\tacb->io_port_len = io_port_len;\n\t\n\tif (request_irq(irq, dc395x_interrupt, IRQF_SHARED, DC395X_NAME, acb)) {\n\t    \t \n\t\tdprintkl(KERN_INFO, \"Failed to register IRQ\\n\");\n\t\tgoto failed;\n\t}\n\t \n\tacb->irq_level = irq;\n\n\t \n\tcheck_eeprom(&acb->eeprom, io_port);\n \tprint_eeprom_settings(&acb->eeprom);\n\n\t \t\n\tadapter_init_params(acb);\n\t\n\t \n \tadapter_print_config(acb);\n\n\tif (adapter_sg_tables_alloc(acb)) {\n\t\tdprintkl(KERN_DEBUG, \"Memory allocation for SG tables failed\\n\");\n\t\tgoto failed;\n\t}\n\tadapter_init_scsi_host(acb->scsi_host);\n\tadapter_init_chip(acb);\n\tset_basic_config(acb);\n\n\tdprintkdbg(DBG_0,\n\t\t\"adapter_init: acb=%p, pdcb_map=%p psrb_array=%p \"\n\t\t\"size{acb=0x%04x dcb=0x%04x srb=0x%04x}\\n\",\n\t\tacb, acb->dcb_map, acb->srb_array, sizeof(struct AdapterCtlBlk),\n\t\tsizeof(struct DeviceCtlBlk), sizeof(struct ScsiReqBlk));\n\treturn 0;\n\nfailed:\n\tif (acb->irq_level)\n\t\tfree_irq(acb->irq_level, acb);\n\tif (acb->io_port_base)\n\t\trelease_region(acb->io_port_base, acb->io_port_len);\n\tadapter_sg_tables_free(acb);\n\n\treturn 1;\n}\n\n\n \nstatic void adapter_uninit_chip(struct AdapterCtlBlk *acb)\n{\n\t \n\tDC395x_write8(acb, TRM_S1040_DMA_INTEN, 0);\n\tDC395x_write8(acb, TRM_S1040_SCSI_INTEN, 0);\n\n\t \n\tif (acb->config & HCC_SCSI_RESET)\n\t\treset_scsi_bus(acb);\n\n\t \n\tDC395x_read8(acb, TRM_S1040_SCSI_INTSTATUS);\n}\n\n\n\n \nstatic void adapter_uninit(struct AdapterCtlBlk *acb)\n{\n\tunsigned long flags;\n\tDC395x_LOCK_IO(acb->scsi_host, flags);\n\n\t \n\tif (timer_pending(&acb->waiting_timer))\n\t\tdel_timer(&acb->waiting_timer);\n\tif (timer_pending(&acb->selto_timer))\n\t\tdel_timer(&acb->selto_timer);\n\n\tadapter_uninit_chip(acb);\n\tadapter_remove_and_free_all_devices(acb);\n\tDC395x_UNLOCK_IO(acb->scsi_host, flags);\n\n\tif (acb->irq_level)\n\t\tfree_irq(acb->irq_level, acb);\n\tif (acb->io_port_base)\n\t\trelease_region(acb->io_port_base, acb->io_port_len);\n\n\tadapter_sg_tables_free(acb);\n}\n\n\n#undef YESNO\n#define YESNO(YN) \\\n if (YN) seq_printf(m, \" Yes \");\\\n else seq_printf(m, \" No  \")\n\nstatic int dc395x_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tstruct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)host->hostdata;\n\tint spd, spd1;\n\tstruct DeviceCtlBlk *dcb;\n\tunsigned long flags;\n\tint dev;\n\n\tseq_puts(m, DC395X_BANNER \" PCI SCSI Host Adapter\\n\"\n\t\t\" Driver Version \" DC395X_VERSION \"\\n\");\n\n\tDC395x_LOCK_IO(acb->scsi_host, flags);\n\n\tseq_printf(m, \"SCSI Host Nr %i, \", host->host_no);\n\tseq_printf(m, \"DC395U/UW/F DC315/U %s\\n\",\n\t\t(acb->config & HCC_WIDE_CARD) ? \"Wide\" : \"\");\n\tseq_printf(m, \"io_port_base 0x%04lx, \", acb->io_port_base);\n\tseq_printf(m, \"irq_level 0x%04x, \", acb->irq_level);\n\tseq_printf(m, \" SelTimeout %ims\\n\", (1638 * acb->sel_timeout) / 1000);\n\n\tseq_printf(m, \"MaxID %i, MaxLUN %llu, \", host->max_id, host->max_lun);\n\tseq_printf(m, \"AdapterID %i\\n\", host->this_id);\n\n\tseq_printf(m, \"tag_max_num %i\", acb->tag_max_num);\n\t \n\tseq_printf(m, \", FilterCfg 0x%02x\",\n\t\tDC395x_read8(acb, TRM_S1040_SCSI_CONFIG1));\n\tseq_printf(m, \", DelayReset %is\\n\", acb->eeprom.delay_time);\n\t \n\n\tseq_printf(m, \"Nr of DCBs: %i\\n\", list_size(&acb->dcb_list));\n\tseq_printf(m, \"Map of attached LUNs: %8ph\\n\", &acb->dcb_map[0]);\n\tseq_printf(m, \"                      %8ph\\n\", &acb->dcb_map[8]);\n\n\tseq_puts(m,\n\t\t \"Un ID LUN Prty Sync Wide DsCn SndS TagQ nego_period SyncFreq SyncOffs MaxCmd\\n\");\n\n\tdev = 0;\n\tlist_for_each_entry(dcb, &acb->dcb_list, list) {\n\t\tint nego_period;\n\t\tseq_printf(m, \"%02i %02i  %02i \", dev, dcb->target_id,\n\t\t\tdcb->target_lun);\n\t\tYESNO(dcb->dev_mode & NTC_DO_PARITY_CHK);\n\t\tYESNO(dcb->sync_offset);\n\t\tYESNO(dcb->sync_period & WIDE_SYNC);\n\t\tYESNO(dcb->dev_mode & NTC_DO_DISCONNECT);\n\t\tYESNO(dcb->dev_mode & NTC_DO_SEND_START);\n\t\tYESNO(dcb->sync_mode & EN_TAG_QUEUEING);\n\t\tnego_period = clock_period[dcb->sync_period & 0x07] << 2;\n\t\tif (dcb->sync_offset)\n\t\t\tseq_printf(m, \"  %03i ns \", nego_period);\n\t\telse\n\t\t\tseq_printf(m, \" (%03i ns)\", (dcb->min_nego_period << 2));\n\n\t\tif (dcb->sync_offset & 0x0f) {\n\t\t\tspd = 1000 / (nego_period);\n\t\t\tspd1 = 1000 % (nego_period);\n\t\t\tspd1 = (spd1 * 10 + nego_period / 2) / (nego_period);\n\t\t\tseq_printf(m, \"   %2i.%1i M     %02i \", spd, spd1,\n\t\t\t\t(dcb->sync_offset & 0x0f));\n\t\t} else\n\t\t\tseq_puts(m, \"                 \");\n\n\t\t \n\t\tseq_printf(m, \"     %02i\\n\", dcb->max_command);\n\t\tdev++;\n\t}\n\n\tif (timer_pending(&acb->waiting_timer))\n\t\tseq_puts(m, \"Waiting queue timer running\\n\");\n\telse\n\t\tseq_putc(m, '\\n');\n\n\tlist_for_each_entry(dcb, &acb->dcb_list, list) {\n\t\tstruct ScsiReqBlk *srb;\n\t\tif (!list_empty(&dcb->srb_waiting_list))\n\t\t\tseq_printf(m, \"DCB (%02i-%i): Waiting: %i:\",\n\t\t\t\tdcb->target_id, dcb->target_lun,\n\t\t\t\tlist_size(&dcb->srb_waiting_list));\n                list_for_each_entry(srb, &dcb->srb_waiting_list, list)\n\t\t\tseq_printf(m, \" %p\", srb->cmd);\n\t\tif (!list_empty(&dcb->srb_going_list))\n\t\t\tseq_printf(m, \"\\nDCB (%02i-%i): Going  : %i:\",\n\t\t\t\tdcb->target_id, dcb->target_lun,\n\t\t\t\tlist_size(&dcb->srb_going_list));\n\t\tlist_for_each_entry(srb, &dcb->srb_going_list, list)\n\t\t\tseq_printf(m, \" %p\", srb->cmd);\n\t\tif (!list_empty(&dcb->srb_waiting_list) || !list_empty(&dcb->srb_going_list))\n\t\t\tseq_putc(m, '\\n');\n\t}\n\n\tif (debug_enabled(DBG_1)) {\n\t\tseq_printf(m, \"DCB list for ACB %p:\\n\", acb);\n\t\tlist_for_each_entry(dcb, &acb->dcb_list, list) {\n\t\t\tseq_printf(m, \"%p -> \", dcb);\n\t\t}\n\t\tseq_puts(m, \"END\\n\");\n\t}\n\n\tDC395x_UNLOCK_IO(acb->scsi_host, flags);\n\treturn 0;\n}\n\n\nstatic const struct scsi_host_template dc395x_driver_template = {\n\t.module                 = THIS_MODULE,\n\t.proc_name              = DC395X_NAME,\n\t.show_info              = dc395x_show_info,\n\t.name                   = DC395X_BANNER \" \" DC395X_VERSION,\n\t.queuecommand           = dc395x_queue_command,\n\t.slave_alloc            = dc395x_slave_alloc,\n\t.slave_destroy          = dc395x_slave_destroy,\n\t.can_queue              = DC395x_MAX_CAN_QUEUE,\n\t.this_id                = 7,\n\t.sg_tablesize           = DC395x_MAX_SG_TABLESIZE,\n\t.cmd_per_lun            = DC395x_MAX_CMD_PER_LUN,\n\t.eh_abort_handler       = dc395x_eh_abort,\n\t.eh_bus_reset_handler   = dc395x_eh_bus_reset,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n};\n\n\n \nstatic void banner_display(void)\n{\n\tstatic int banner_done = 0;\n\tif (!banner_done)\n\t{\n\t\tdprintkl(KERN_INFO, \"%s %s\\n\", DC395X_BANNER, DC395X_VERSION);\n\t\tbanner_done = 1;\n\t}\n}\n\n\n \nstatic int dc395x_init_one(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct Scsi_Host *scsi_host = NULL;\n\tstruct AdapterCtlBlk *acb = NULL;\n\tunsigned long io_port_base;\n\tunsigned int io_port_len;\n\tunsigned int irq;\n\t\n\tdprintkdbg(DBG_0, \"Init one instance (%s)\\n\", pci_name(dev));\n\tbanner_display();\n\n\tif (pci_enable_device(dev))\n\t{\n\t\tdprintkl(KERN_INFO, \"PCI Enable device failed.\\n\");\n\t\treturn -ENODEV;\n\t}\n\tio_port_base = pci_resource_start(dev, 0) & PCI_BASE_ADDRESS_IO_MASK;\n\tio_port_len = pci_resource_len(dev, 0);\n\tirq = dev->irq;\n\tdprintkdbg(DBG_0, \"IO_PORT=0x%04lx, IRQ=0x%x\\n\", io_port_base, dev->irq);\n\n\t \n\tscsi_host = scsi_host_alloc(&dc395x_driver_template,\n\t\t\t\t    sizeof(struct AdapterCtlBlk));\n\tif (!scsi_host) {\n\t\tdprintkl(KERN_INFO, \"scsi_host_alloc failed\\n\");\n\t\tgoto fail;\n\t}\n \tacb = (struct AdapterCtlBlk*)scsi_host->hostdata;\n \tacb->scsi_host = scsi_host;\n \tacb->dev = dev;\n\n\t \n \tif (adapter_init(acb, io_port_base, io_port_len, irq)) {\n\t\tdprintkl(KERN_INFO, \"adapter init failed\\n\");\n\t\tacb = NULL;\n\t\tgoto fail;\n\t}\n\n\tpci_set_master(dev);\n\n\t \n\tif (scsi_add_host(scsi_host, &dev->dev)) {\n\t\tdprintkl(KERN_ERR, \"scsi_add_host failed\\n\");\n\t\tgoto fail;\n\t}\n\tpci_set_drvdata(dev, scsi_host);\n\tscsi_scan_host(scsi_host);\n        \t\n\treturn 0;\n\nfail:\n\tif (acb != NULL)\n\t\tadapter_uninit(acb);\n\tif (scsi_host != NULL)\n\t\tscsi_host_put(scsi_host);\n\tpci_disable_device(dev);\n\treturn -ENODEV;\n}\n\n\n \nstatic void dc395x_remove_one(struct pci_dev *dev)\n{\n\tstruct Scsi_Host *scsi_host = pci_get_drvdata(dev);\n\tstruct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)(scsi_host->hostdata);\n\n\tdprintkdbg(DBG_0, \"dc395x_remove_one: acb=%p\\n\", acb);\n\n\tscsi_remove_host(scsi_host);\n\tadapter_uninit(acb);\n\tpci_disable_device(dev);\n\tscsi_host_put(scsi_host);\n}\n\n\nstatic struct pci_device_id dc395x_pci_table[] = {\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_TEKRAM,\n\t\t.device\t\t= PCI_DEVICE_ID_TEKRAM_TRMS1040,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t },\n\t{}\t\t\t \n};\nMODULE_DEVICE_TABLE(pci, dc395x_pci_table);\n\n\nstatic struct pci_driver dc395x_driver = {\n\t.name           = DC395X_NAME,\n\t.id_table       = dc395x_pci_table,\n\t.probe          = dc395x_init_one,\n\t.remove         = dc395x_remove_one,\n};\nmodule_pci_driver(dc395x_driver);\n\nMODULE_AUTHOR(\"C.L. Huang / Erich Chen / Kurt Garloff\");\nMODULE_DESCRIPTION(\"SCSI host adapter driver for Tekram TRM-S1040 based adapters: Tekram DC395 and DC315 series\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}