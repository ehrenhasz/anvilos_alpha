{
  "module_name": "3w-9xxx.h",
  "hash_id": "4d08f4ecd9dd2f521f712e4d48de6de54d2ad928bdb10dc16a3f8355d4ec03e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/3w-9xxx.h",
  "human_readable_source": " \n\n#ifndef _3W_9XXX_H\n#define _3W_9XXX_H\n\n \ntypedef struct TAG_twa_message_type {\n\tunsigned int   code;\n\tchar           *text;\n} twa_message_type;\n\n \nstatic twa_message_type twa_aen_table[] = {\n\t{0x0000, \"AEN queue empty\"},\n\t{0x0001, \"Controller reset occurred\"},\n\t{0x0002, \"Degraded unit detected\"},\n\t{0x0003, \"Controller error occurred\"},\n\t{0x0004, \"Background rebuild failed\"},\n\t{0x0005, \"Background rebuild done\"},\n\t{0x0006, \"Incomplete unit detected\"},\n\t{0x0007, \"Background initialize done\"},\n\t{0x0008, \"Unclean shutdown detected\"},\n\t{0x0009, \"Drive timeout detected\"},\n\t{0x000A, \"Drive error detected\"},\n\t{0x000B, \"Rebuild started\"},\n\t{0x000C, \"Background initialize started\"},\n\t{0x000D, \"Entire logical unit was deleted\"},\n\t{0x000E, \"Background initialize failed\"},\n\t{0x000F, \"SMART attribute exceeded threshold\"},\n\t{0x0010, \"Power supply reported AC under range\"},\n\t{0x0011, \"Power supply reported DC out of range\"},\n\t{0x0012, \"Power supply reported a malfunction\"},\n\t{0x0013, \"Power supply predicted malfunction\"},\n\t{0x0014, \"Battery charge is below threshold\"},\n\t{0x0015, \"Fan speed is below threshold\"},\n\t{0x0016, \"Temperature sensor is above threshold\"},\n\t{0x0017, \"Power supply was removed\"},\n\t{0x0018, \"Power supply was inserted\"},\n\t{0x0019, \"Drive was removed from a bay\"},\n\t{0x001A, \"Drive was inserted into a bay\"},\n\t{0x001B, \"Drive bay cover door was opened\"},\n\t{0x001C, \"Drive bay cover door was closed\"},\n\t{0x001D, \"Product case was opened\"},\n\t{0x0020, \"Prepare for shutdown (power-off)\"},\n\t{0x0021, \"Downgrade UDMA mode to lower speed\"},\n\t{0x0022, \"Upgrade UDMA mode to higher speed\"},\n\t{0x0023, \"Sector repair completed\"},\n\t{0x0024, \"Sbuf memory test failed\"},\n\t{0x0025, \"Error flushing cached write data to array\"},\n\t{0x0026, \"Drive reported data ECC error\"},\n\t{0x0027, \"DCB has checksum error\"},\n\t{0x0028, \"DCB version is unsupported\"},\n\t{0x0029, \"Background verify started\"},\n\t{0x002A, \"Background verify failed\"},\n\t{0x002B, \"Background verify done\"},\n\t{0x002C, \"Bad sector overwritten during rebuild\"},\n\t{0x002D, \"Background rebuild error on source drive\"},\n\t{0x002E, \"Replace failed because replacement drive too small\"},\n\t{0x002F, \"Verify failed because array was never initialized\"},\n\t{0x0030, \"Unsupported ATA drive\"},\n\t{0x0031, \"Synchronize host/controller time\"},\n\t{0x0032, \"Spare capacity is inadequate for some units\"},\n\t{0x0033, \"Background migration started\"},\n\t{0x0034, \"Background migration failed\"},\n\t{0x0035, \"Background migration done\"},\n\t{0x0036, \"Verify detected and fixed data/parity mismatch\"},\n\t{0x0037, \"SO-DIMM incompatible\"},\n\t{0x0038, \"SO-DIMM not detected\"},\n\t{0x0039, \"Corrected Sbuf ECC error\"},\n\t{0x003A, \"Drive power on reset detected\"},\n\t{0x003B, \"Background rebuild paused\"},\n\t{0x003C, \"Background initialize paused\"},\n\t{0x003D, \"Background verify paused\"},\n\t{0x003E, \"Background migration paused\"},\n\t{0x003F, \"Corrupt flash file system detected\"},\n\t{0x0040, \"Flash file system repaired\"},\n\t{0x0041, \"Unit number assignments were lost\"},\n\t{0x0042, \"Error during read of primary DCB\"},\n\t{0x0043, \"Latent error found in backup DCB\"},\n\t{0x00FC, \"Recovered/finished array membership update\"},\n\t{0x00FD, \"Handler lockup\"},\n\t{0x00FE, \"Retrying PCI transfer\"},\n\t{0x00FF, \"AEN queue is full\"},\n\t{0xFFFFFFFF, (char*) 0}\n};\n\n \nstatic char *twa_aen_severity_table[] =\n{\n\t\"None\", \"ERROR\", \"WARNING\", \"INFO\", \"DEBUG\", (char*) 0\n};\n\n \nstatic twa_message_type twa_error_table[] = {\n\t{0x0100, \"SGL entry contains zero data\"},\n\t{0x0101, \"Invalid command opcode\"},\n\t{0x0102, \"SGL entry has unaligned address\"},\n\t{0x0103, \"SGL size does not match command\"},\n\t{0x0104, \"SGL entry has illegal length\"},\n\t{0x0105, \"Command packet is not aligned\"},\n\t{0x0106, \"Invalid request ID\"},\n\t{0x0107, \"Duplicate request ID\"},\n\t{0x0108, \"ID not locked\"},\n\t{0x0109, \"LBA out of range\"},\n\t{0x010A, \"Logical unit not supported\"},\n\t{0x010B, \"Parameter table does not exist\"},\n\t{0x010C, \"Parameter index does not exist\"},\n\t{0x010D, \"Invalid field in CDB\"},\n\t{0x010E, \"Specified port has invalid drive\"},\n\t{0x010F, \"Parameter item size mismatch\"},\n\t{0x0110, \"Failed memory allocation\"},\n\t{0x0111, \"Memory request too large\"},\n\t{0x0112, \"Out of memory segments\"},\n\t{0x0113, \"Invalid address to deallocate\"},\n\t{0x0114, \"Out of memory\"},\n\t{0x0115, \"Out of heap\"},\n\t{0x0120, \"Double degrade\"},\n\t{0x0121, \"Drive not degraded\"},\n\t{0x0122, \"Reconstruct error\"},\n\t{0x0123, \"Replace not accepted\"},\n\t{0x0124, \"Replace drive capacity too small\"},\n\t{0x0125, \"Sector count not allowed\"},\n\t{0x0126, \"No spares left\"},\n\t{0x0127, \"Reconstruct error\"},\n\t{0x0128, \"Unit is offline\"},\n\t{0x0129, \"Cannot update status to DCB\"},\n\t{0x0130, \"Invalid stripe handle\"},\n\t{0x0131, \"Handle that was not locked\"},\n\t{0x0132, \"Handle that was not empty\"},\n\t{0x0133, \"Handle has different owner\"},\n\t{0x0140, \"IPR has parent\"},\n\t{0x0150, \"Illegal Pbuf address alignment\"},\n\t{0x0151, \"Illegal Pbuf transfer length\"},\n\t{0x0152, \"Illegal Sbuf address alignment\"},\n\t{0x0153, \"Illegal Sbuf transfer length\"},\n\t{0x0160, \"Command packet too large\"},\n\t{0x0161, \"SGL exceeds maximum length\"},\n\t{0x0162, \"SGL has too many entries\"},\n\t{0x0170, \"Insufficient resources for rebuilder\"},\n\t{0x0171, \"Verify error (data != parity)\"},\n\t{0x0180, \"Requested segment not in directory of this DCB\"},\n\t{0x0181, \"DCB segment has unsupported version\"},\n\t{0x0182, \"DCB segment has checksum error\"},\n\t{0x0183, \"DCB support (settings) segment invalid\"},\n\t{0x0184, \"DCB UDB (unit descriptor block) segment invalid\"},\n\t{0x0185, \"DCB GUID (globally unique identifier) segment invalid\"},\n\t{0x01A0, \"Could not clear Sbuf\"},\n\t{0x01C0, \"Flash identify failed\"},\n\t{0x01C1, \"Flash out of bounds\"},\n\t{0x01C2, \"Flash verify error\"},\n\t{0x01C3, \"Flash file object not found\"},\n\t{0x01C4, \"Flash file already present\"},\n\t{0x01C5, \"Flash file system full\"},\n\t{0x01C6, \"Flash file not present\"},\n\t{0x01C7, \"Flash file size error\"},\n\t{0x01C8, \"Bad flash file checksum\"},\n\t{0x01CA, \"Corrupt flash file system detected\"},\n\t{0x01D0, \"Invalid field in parameter list\"},\n\t{0x01D1, \"Parameter list length error\"},\n\t{0x01D2, \"Parameter item is not changeable\"},\n\t{0x01D3, \"Parameter item is not saveable\"},\n\t{0x0200, \"UDMA CRC error\"},\n\t{0x0201, \"Internal CRC error\"},\n\t{0x0202, \"Data ECC error\"},\n\t{0x0203, \"ADP level 1 error\"},\n\t{0x0204, \"Port timeout\"},\n\t{0x0205, \"Drive power on reset\"},\n\t{0x0206, \"ADP level 2 error\"},\n\t{0x0207, \"Soft reset failed\"},\n\t{0x0208, \"Drive not ready\"},\n\t{0x0209, \"Unclassified port error\"},\n\t{0x020A, \"Drive aborted command\"},\n\t{0x0210, \"Internal CRC error\"},\n\t{0x0211, \"PCI abort error\"},\n\t{0x0212, \"PCI parity error\"},\n\t{0x0213, \"Port handler error\"},\n\t{0x0214, \"Token interrupt count error\"},\n\t{0x0215, \"Timeout waiting for PCI transfer\"},\n\t{0x0216, \"Corrected buffer ECC\"},\n\t{0x0217, \"Uncorrected buffer ECC\"},\n\t{0x0230, \"Unsupported command during flash recovery\"},\n\t{0x0231, \"Next image buffer expected\"},\n\t{0x0232, \"Binary image architecture incompatible\"},\n\t{0x0233, \"Binary image has no signature\"},\n\t{0x0234, \"Binary image has bad checksum\"},\n\t{0x0235, \"Image downloaded overflowed buffer\"},\n\t{0x0240, \"I2C device not found\"},\n\t{0x0241, \"I2C transaction aborted\"},\n\t{0x0242, \"SO-DIMM parameter(s) incompatible using defaults\"},\n\t{0x0243, \"SO-DIMM unsupported\"},\n\t{0x0248, \"SPI transfer status error\"},\n\t{0x0249, \"SPI transfer timeout error\"},\n\t{0x0250, \"Invalid unit descriptor size in CreateUnit\"},\n\t{0x0251, \"Unit descriptor size exceeds data buffer in CreateUnit\"},\n\t{0x0252, \"Invalid value in CreateUnit descriptor\"},\n\t{0x0253, \"Inadequate disk space to support descriptor in CreateUnit\"},\n\t{0x0254, \"Unable to create data channel for this unit descriptor\"},\n\t{0x0255, \"CreateUnit descriptor specifies a drive already in use\"},\n\t{0x0256, \"Unable to write configuration to all disks during CreateUnit\"},\n\t{0x0257, \"CreateUnit does not support this descriptor version\"},\n\t{0x0258, \"Invalid subunit for RAID 0 or 5 in CreateUnit\"},\n\t{0x0259, \"Too many descriptors in CreateUnit\"},\n\t{0x025A, \"Invalid configuration specified in CreateUnit descriptor\"},\n\t{0x025B, \"Invalid LBA offset specified in CreateUnit descriptor\"},\n\t{0x025C, \"Invalid stripelet size specified in CreateUnit descriptor\"},\n\t{0x0260, \"SMART attribute exceeded threshold\"},\n\t{0xFFFFFFFF, (char*) 0}\n};\n\n \n#define TW_CONTROL_CLEAR_HOST_INTERRUPT\t       0x00080000\n#define TW_CONTROL_CLEAR_ATTENTION_INTERRUPT   0x00040000\n#define TW_CONTROL_MASK_COMMAND_INTERRUPT      0x00020000\n#define TW_CONTROL_MASK_RESPONSE_INTERRUPT     0x00010000\n#define TW_CONTROL_UNMASK_COMMAND_INTERRUPT    0x00008000\n#define TW_CONTROL_UNMASK_RESPONSE_INTERRUPT   0x00004000\n#define TW_CONTROL_CLEAR_ERROR_STATUS\t       0x00000200\n#define TW_CONTROL_ISSUE_SOFT_RESET\t       0x00000100\n#define TW_CONTROL_ENABLE_INTERRUPTS\t       0x00000080\n#define TW_CONTROL_DISABLE_INTERRUPTS\t       0x00000040\n#define TW_CONTROL_ISSUE_HOST_INTERRUPT\t       0x00000020\n#define TW_CONTROL_CLEAR_PARITY_ERROR\t       0x00800000\n#define TW_CONTROL_CLEAR_QUEUE_ERROR\t       0x00400000\n#define TW_CONTROL_CLEAR_PCI_ABORT\t       0x00100000\n\n \n#define TW_STATUS_MAJOR_VERSION_MASK\t       0xF0000000\n#define TW_STATUS_MINOR_VERSION_MASK\t       0x0F000000\n#define TW_STATUS_PCI_PARITY_ERROR\t       0x00800000\n#define TW_STATUS_QUEUE_ERROR\t\t       0x00400000\n#define TW_STATUS_MICROCONTROLLER_ERROR\t       0x00200000\n#define TW_STATUS_PCI_ABORT\t\t       0x00100000\n#define TW_STATUS_HOST_INTERRUPT\t       0x00080000\n#define TW_STATUS_ATTENTION_INTERRUPT\t       0x00040000\n#define TW_STATUS_COMMAND_INTERRUPT\t       0x00020000\n#define TW_STATUS_RESPONSE_INTERRUPT\t       0x00010000\n#define TW_STATUS_COMMAND_QUEUE_FULL\t       0x00008000\n#define TW_STATUS_RESPONSE_QUEUE_EMPTY\t       0x00004000\n#define TW_STATUS_MICROCONTROLLER_READY\t       0x00002000\n#define TW_STATUS_COMMAND_QUEUE_EMPTY\t       0x00001000\n#define TW_STATUS_EXPECTED_BITS\t\t       0x00002000\n#define TW_STATUS_UNEXPECTED_BITS\t       0x00F00000\n#define TW_STATUS_VALID_INTERRUPT\t       0x00DF0000\n\n \n#define TW_PCI_CLEAR_PARITY_ERRORS 0xc100\n#define TW_PCI_CLEAR_PCI_ABORT     0x2000\n\n \n#define TW_OP_INIT_CONNECTION\t0x1\n#define TW_OP_GET_PARAM\t\t0x12\n#define TW_OP_SET_PARAM\t\t0x13\n#define TW_OP_EXECUTE_SCSI\t0x10\n#define TW_OP_DOWNLOAD_FIRMWARE 0x16\n#define TW_OP_RESET\t\t0x1C\n\n \n#define TW_AEN_QUEUE_EMPTY\t0x0000\n#define TW_AEN_SOFT_RESET\t0x0001\n#define TW_AEN_SYNC_TIME_WITH_HOST 0x031\n#define TW_AEN_SEVERITY_ERROR\t0x1\n#define TW_AEN_SEVERITY_DEBUG    0x4\n#define TW_AEN_NOT_RETRIEVED 0x1\n#define TW_AEN_RETRIEVED 0x2\n\n \n#define TW_S_INITIAL   0x1   \n#define TW_S_STARTED   0x2   \n#define TW_S_POSTED    0x4   \n#define TW_S_PENDING   0x8   \n#define TW_S_COMPLETED 0x10  \n#define TW_S_FINISHED  0x20  \n\n \n#define TW_9000_ARCH_ID 0x5\n#define TW_CURRENT_DRIVER_SRL 35\n#define TW_CURRENT_DRIVER_BUILD 0\n#define TW_CURRENT_DRIVER_BRANCH 0\n\n \n#define TW_9550SX_DRAIN_COMPLETED\t      0xFFFF\n#define TW_SECTOR_SIZE\t\t\t      512\n#define TW_ALIGNMENT_9000\t\t      4   \n#define TW_ALIGNMENT_9000_SGL\t\t      0x3\n#define TW_MAX_UNITS\t\t\t      16\n#define TW_MAX_UNITS_9650SE\t\t      32\n#define TW_INIT_MESSAGE_CREDITS\t\t      0x100\n#define TW_INIT_COMMAND_PACKET_SIZE\t      0x3\n#define TW_INIT_COMMAND_PACKET_SIZE_EXTENDED  0x6\n#define TW_EXTENDED_INIT_CONNECT\t      0x2\n#define TW_BUNDLED_FW_SAFE_TO_FLASH\t      0x4\n#define TW_CTLR_FW_RECOMMENDS_FLASH\t      0x8\n#define TW_CTLR_FW_COMPATIBLE\t\t      0x2\n#define TW_BASE_FW_SRL\t\t\t      24\n#define TW_BASE_FW_BRANCH\t\t      0\n#define TW_BASE_FW_BUILD\t\t      1\n#define TW_FW_SRL_LUNS_SUPPORTED\t      28\n#define TW_Q_LENGTH\t\t\t      256\n#define TW_Q_START\t\t\t      0\n#define TW_MAX_SLOT\t\t\t      32\n#define TW_MAX_RESET_TRIES\t\t      2\n#define TW_MAX_CMDS_PER_LUN\t\t      254\n#define TW_MAX_RESPONSE_DRAIN\t\t      256\n#define TW_MAX_AEN_DRAIN\t\t      255\n#define TW_IN_RESET\t\t\t      2\n#define TW_USING_MSI\t\t\t      3\n#define TW_IN_ATTENTION_LOOP\t\t      4\n#define TW_MAX_SECTORS\t\t\t      256\n#define TW_AEN_WAIT_TIME\t\t      1000\n#define TW_IOCTL_WAIT_TIME\t\t      (1 * HZ)  \n#define TW_MAX_CDB_LEN\t\t\t      16\n#define TW_ISR_DONT_COMPLETE\t\t      2\n#define TW_ISR_DONT_RESULT\t\t      3\n#define TW_IOCTL_CHRDEV_TIMEOUT\t\t      60  \n#define TW_IOCTL_CHRDEV_FREE\t\t      -1\n#define TW_COMMAND_OFFSET\t\t      128  \n#define TW_VERSION_TABLE\t\t      0x0402\n#define TW_TIMEKEEP_TABLE\t\t      0x040A\n#define TW_INFORMATION_TABLE\t\t      0x0403\n#define TW_PARAM_FWVER\t\t\t      3\n#define TW_PARAM_FWVER_LENGTH\t\t      16\n#define TW_PARAM_BIOSVER\t\t      4\n#define TW_PARAM_BIOSVER_LENGTH\t\t      16\n#define TW_PARAM_PORTCOUNT\t\t      3\n#define TW_PARAM_PORTCOUNT_LENGTH\t      1\n#define TW_MIN_SGL_LENGTH\t\t      0x200  \n#define TW_MAX_SENSE_LENGTH\t\t      256\n#define TW_EVENT_SOURCE_AEN\t\t      0x1000\n#define TW_EVENT_SOURCE_COMMAND\t\t      0x1001\n#define TW_EVENT_SOURCE_PCHIP\t\t      0x1002\n#define TW_EVENT_SOURCE_DRIVER\t\t      0x1003\n#define TW_IOCTL_GET_COMPATIBILITY_INFO\t      0x101\n#define TW_IOCTL_GET_LAST_EVENT\t\t      0x102\n#define TW_IOCTL_GET_FIRST_EVENT\t      0x103\n#define TW_IOCTL_GET_NEXT_EVENT\t\t      0x104\n#define TW_IOCTL_GET_PREVIOUS_EVENT\t      0x105\n#define TW_IOCTL_GET_LOCK\t\t      0x106\n#define TW_IOCTL_RELEASE_LOCK\t\t      0x107\n#define TW_IOCTL_FIRMWARE_PASS_THROUGH\t      0x108\n#define TW_IOCTL_ERROR_STATUS_NOT_LOCKED      0x1001 \n#define TW_IOCTL_ERROR_STATUS_LOCKED\t      0x1002 \n#define TW_IOCTL_ERROR_STATUS_NO_MORE_EVENTS  0x1003 \n#define TW_IOCTL_ERROR_STATUS_AEN_CLOBBER     0x1004 \n#define TW_IOCTL_ERROR_OS_EFAULT\t      -EFAULT \n#define TW_IOCTL_ERROR_OS_EINTR\t\t      -EINTR  \n#define TW_IOCTL_ERROR_OS_EINVAL\t      -EINVAL \n#define TW_IOCTL_ERROR_OS_ENOMEM\t      -ENOMEM \n#define TW_IOCTL_ERROR_OS_ERESTARTSYS\t      -ERESTARTSYS \n#define TW_IOCTL_ERROR_OS_EIO\t\t      -EIO \n#define TW_IOCTL_ERROR_OS_ENOTTY\t      -ENOTTY \n#define TW_IOCTL_ERROR_OS_ENODEV\t      -ENODEV \n#define TW_ALLOCATION_LENGTH\t\t      128\n#define TW_SENSE_DATA_LENGTH\t\t      18\n#define TW_STATUS_CHECK_CONDITION\t      2\n#define TW_ERROR_LOGICAL_UNIT_NOT_SUPPORTED   0x10a\n#define TW_ERROR_UNIT_OFFLINE\t\t      0x128\n#define TW_MESSAGE_SOURCE_CONTROLLER_ERROR    3\n#define TW_MESSAGE_SOURCE_CONTROLLER_EVENT    4\n#define TW_MESSAGE_SOURCE_LINUX_DRIVER\t      6\n#define TW_DRIVER TW_MESSAGE_SOURCE_LINUX_DRIVER\n#define TW_MESSAGE_SOURCE_LINUX_OS\t      9\n#define TW_OS TW_MESSAGE_SOURCE_LINUX_OS\n#ifndef PCI_DEVICE_ID_3WARE_9000\n#define PCI_DEVICE_ID_3WARE_9000 0x1002\n#endif\n#ifndef PCI_DEVICE_ID_3WARE_9550SX\n#define PCI_DEVICE_ID_3WARE_9550SX 0x1003\n#endif\n#ifndef PCI_DEVICE_ID_3WARE_9650SE\n#define PCI_DEVICE_ID_3WARE_9650SE 0x1004\n#endif\n#ifndef PCI_DEVICE_ID_3WARE_9690SA\n#define PCI_DEVICE_ID_3WARE_9690SA 0x1005\n#endif\n\n \n\n \n#define TW_OPRES_IN(x,y) ((x << 5) | (y & 0x1f))\n#define TW_OP_OUT(x) (x & 0x1f)\n\n \n#define TW_OPSGL_IN(x,y) ((x << 5) | (y & 0x1f))\n#define TW_SGL_OUT(x) ((x >> 5) & 0x7)\n\n \n#define TW_SEV_OUT(x) (x & 0x7)\n\n \n#define TW_RESID_OUT(x) ((x >> 4) & 0xff)\n\n \n#define TW_REQ_LUN_IN(lun, request_id)\t\t\t\\\n\tcpu_to_le16(((lun << 12) & 0xf000) | (request_id & 0xfff))\n#define TW_LUN_OUT(lun) ((le16_to_cpu(lun) >> 12) & 0xf)\n\n \n#define TW_CONTROL_REG_ADDR(x) (x->base_addr)\n#define TW_STATUS_REG_ADDR(x) ((unsigned char __iomem *)x->base_addr + 0x4)\n#define TW_COMMAND_QUEUE_REG_ADDR(x) \\\n\t(sizeof(dma_addr_t) > 4 ? ((unsigned char __iomem *)x->base_addr + 0x20) : ((unsigned char __iomem *)x->base_addr + 0x8))\n#define TW_COMMAND_QUEUE_REG_ADDR_LARGE(x) \\\n\t((unsigned char __iomem *)x->base_addr + 0x20)\n#define TW_RESPONSE_QUEUE_REG_ADDR(x) \\\n\t((unsigned char __iomem *)x->base_addr + 0xC)\n#define TW_RESPONSE_QUEUE_REG_ADDR_LARGE(x) \\\n\t((unsigned char __iomem *)x->base_addr + 0x30)\n#define TW_CLEAR_ALL_INTERRUPTS(x) \\\n\t(writel(TW_STATUS_VALID_INTERRUPT, TW_CONTROL_REG_ADDR(x)))\n#define TW_CLEAR_ATTENTION_INTERRUPT(x) \\\n\t(writel(TW_CONTROL_CLEAR_ATTENTION_INTERRUPT, TW_CONTROL_REG_ADDR(x)))\n#define TW_CLEAR_HOST_INTERRUPT(x) \\\n\t(writel(TW_CONTROL_CLEAR_HOST_INTERRUPT, TW_CONTROL_REG_ADDR(x)))\n#define TW_DISABLE_INTERRUPTS(x) \\\n\t(writel(TW_CONTROL_DISABLE_INTERRUPTS, TW_CONTROL_REG_ADDR(x)))\n#define TW_ENABLE_AND_CLEAR_INTERRUPTS(x)\t\t\t\t\\\n\t(writel(TW_CONTROL_CLEAR_ATTENTION_INTERRUPT |\t\t\t\\\n\t\tTW_CONTROL_UNMASK_RESPONSE_INTERRUPT |\t\t\t\\\n\t\tTW_CONTROL_ENABLE_INTERRUPTS, TW_CONTROL_REG_ADDR(x)))\n#define TW_MASK_COMMAND_INTERRUPT(x)\t\t\t\t\t\\\n\t(writel(TW_CONTROL_MASK_COMMAND_INTERRUPT, TW_CONTROL_REG_ADDR(x)))\n#define TW_UNMASK_COMMAND_INTERRUPT(x)\t\t\t\t\t\\\n\t(writel(TW_CONTROL_UNMASK_COMMAND_INTERRUPT, TW_CONTROL_REG_ADDR(x)))\n#define TW_SOFT_RESET(x) (writel(TW_CONTROL_ISSUE_SOFT_RESET |\t\\\n\t\t\tTW_CONTROL_CLEAR_HOST_INTERRUPT | \\\n\t\t\tTW_CONTROL_CLEAR_ATTENTION_INTERRUPT | \\\n\t\t\tTW_CONTROL_MASK_COMMAND_INTERRUPT | \\\n\t\t\tTW_CONTROL_MASK_RESPONSE_INTERRUPT | \\\n\t\t\tTW_CONTROL_CLEAR_ERROR_STATUS | \\\n\t\t\tTW_CONTROL_DISABLE_INTERRUPTS, TW_CONTROL_REG_ADDR(x)))\n#define TW_PRINTK(h,a,b,c) { \\\nif (h) \\\nprintk(KERN_WARNING \"3w-9xxx: scsi%d: ERROR: (0x%02X:0x%04X): %s.\\n\",h->host_no,a,b,c); \\\nelse \\\nprintk(KERN_WARNING \"3w-9xxx: ERROR: (0x%02X:0x%04X): %s.\\n\",a,b,c); \\\n}\n#define TW_MAX_LUNS(srl) (srl < TW_FW_SRL_LUNS_SUPPORTED ? 1 : 16)\n#define TW_COMMAND_SIZE (sizeof(dma_addr_t) > 4 ? 5 : 4)\n#define TW_APACHE_MAX_SGL_LENGTH (sizeof(dma_addr_t) > 4 ? 72 : 109)\n#define TW_ESCALADE_MAX_SGL_LENGTH (sizeof(dma_addr_t) > 4 ? 41 : 62)\n#define TW_PADDING_LENGTH (sizeof(dma_addr_t) > 4 ? 8 : 0)\n\n#if IS_ENABLED(CONFIG_ARCH_DMA_ADDR_T_64BIT)\ntypedef __le64 twa_addr_t;\n#define TW_CPU_TO_SGL(x) cpu_to_le64(x)\n#else\ntypedef __le32 twa_addr_t;\n#define TW_CPU_TO_SGL(x) cpu_to_le32(x)\n#endif\n\n \ntypedef struct TAG_TW_SG_Entry {\n\ttwa_addr_t\taddress;\n\t__le32\t\tlength;\n} __packed TW_SG_Entry;\n\n \ntypedef struct TW_Command {\n\tu8\topcode__sgloffset;\n\tu8\tsize;\n\tu8\trequest_id;\n\tu8\tunit__hostid;\n\t \n\tu8\tstatus;\n\tu8\tflags;\n\tunion {\n\t\t__le16\tblock_count;\n\t\t__le16\tparameter_count;\n\t} byte6_offset;\n\tunion {\n\t\tstruct {\n\t\t\t__le32\t\tlba;\n\t\t\tTW_SG_Entry\tsgl[TW_ESCALADE_MAX_SGL_LENGTH];\n\t\t\ttwa_addr_t\tpadding;\n\t\t} io;\n\t\tstruct {\n\t\t\tTW_SG_Entry\tsgl[TW_ESCALADE_MAX_SGL_LENGTH];\n\t\t\t__le32\t\tpadding;\n\t\t\ttwa_addr_t\tpadding2;\n\t\t} param;\n\t} byte8_offset;\n} TW_Command;\n\n \ntypedef struct TAG_TW_Command_Apache {\n\tu8\t\topcode__reserved;\n\tu8\t\tunit;\n\t__le16\t\trequest_id__lunl;\n\tu8\t\tstatus;\n\tu8\t\tsgl_offset;\n\t__le16\t\tsgl_entries__lunh;\n\tu8\t\tcdb[16];\n\tTW_SG_Entry\tsg_list[TW_APACHE_MAX_SGL_LENGTH];\n\tu8\t\tpadding[TW_PADDING_LENGTH];\n} TW_Command_Apache;\n\n \ntypedef struct TAG_TW_Command_Apache_Header {\n\tunsigned char sense_data[TW_SENSE_DATA_LENGTH];\n\tstruct {\n\t\tu8\treserved[4];\n\t\t__le16\terror;\n\t\tu8\tpadding;\n\t\tu8\tseverity__reserved;\n\t} status_block;\n\tunsigned char err_specific_desc[98];\n\tstruct {\n\t\tu8\tsize_header;\n\t\tu8\treserved[2];\n\t\tu8\tsize_sense;\n\t} header_desc;\n} TW_Command_Apache_Header;\n\n \ntypedef struct TAG_TW_Command_Full {\n\tTW_Command_Apache_Header header;\n\tunion {\n\t\tTW_Command oldcommand;\n\t\tTW_Command_Apache newcommand;\n\t} command;\n} TW_Command_Full;\n\n \ntypedef struct TAG_TW_Initconnect {\n\tu8\topcode__reserved;\n\tu8\tsize;\n\tu8\trequest_id;\n\tu8\tres2;\n\tu8\tstatus;\n\tu8\tflags;\n\t__le16\tmessage_credits;\n\t__le32\tfeatures;\n\t__le16\tfw_srl;\n\t__le16\tfw_arch_id;\n\t__le16\tfw_branch;\n\t__le16\tfw_build;\n\t__le32\tresult;\n} TW_Initconnect;\n\n \ntypedef struct TAG_TW_Event\n{\n\tunsigned int sequence_id;\n\tunsigned int time_stamp_sec;\n\tunsigned short aen_code;\n\tunsigned char severity;\n\tunsigned char retrieved;\n\tunsigned char repeat_count;\n\tunsigned char parameter_len;\n\tunsigned char parameter_data[98];\n} TW_Event;\n\ntypedef struct TAG_TW_Ioctl_Driver_Command {\n\tunsigned int control_code;\n\tunsigned int status;\n\tunsigned int unique_id;\n\tunsigned int sequence_id;\n\tunsigned int os_specific;\n\tunsigned int buffer_length;\n} TW_Ioctl_Driver_Command;\n\ntypedef struct TAG_TW_Ioctl_Apache {\n\tTW_Ioctl_Driver_Command driver_command;\n\tchar padding[488];\n\tTW_Command_Full firmware_command;\n\tchar data_buffer[];\n} TW_Ioctl_Buf_Apache;\n\n \ntypedef struct TAG_TW_Lock {\n\tunsigned long timeout_msec;\n\tunsigned long time_remaining_msec;\n\tunsigned long force_flag;\n} TW_Lock;\n\n \ntypedef struct {\n\t__le16\ttable_id;\n\t__le16\tparameter_id;\n\t__le16\tparameter_size_bytes;\n\t__le16  actual_parameter_size_bytes;\n\tu8\tdata[];\n} TW_Param_Apache, *PTW_Param_Apache;\n\n \ntypedef union TAG_TW_Response_Queue {\n\tu32 response_id;\n\tu32 value;\n} TW_Response_Queue;\n\n \ntypedef struct TAG_TW_Compatibility_Info\n{\n\tchar driver_version[32];\n\tunsigned short working_srl;\n\tunsigned short working_branch;\n\tunsigned short working_build;\n\tunsigned short driver_srl_high;\n\tunsigned short driver_branch_high;\n\tunsigned short driver_build_high;\n\tunsigned short driver_srl_low;\n\tunsigned short driver_branch_low;\n\tunsigned short driver_build_low;\n\tunsigned short fw_on_ctlr_srl;\n\tunsigned short fw_on_ctlr_branch;\n\tunsigned short fw_on_ctlr_build;\n} TW_Compatibility_Info;\n\ntypedef struct TAG_TW_Device_Extension {\n\tu32\t\t\t__iomem *base_addr;\n\tunsigned long\t\t*generic_buffer_virt[TW_Q_LENGTH];\n\tdma_addr_t\t\tgeneric_buffer_phys[TW_Q_LENGTH];\n\tTW_Command_Full\t\t*command_packet_virt[TW_Q_LENGTH];\n\tdma_addr_t\t\tcommand_packet_phys[TW_Q_LENGTH];\n\tstruct pci_dev\t\t*tw_pci_dev;\n\tstruct scsi_cmnd\t*srb[TW_Q_LENGTH];\n\tunsigned char\t\tfree_queue[TW_Q_LENGTH];\n\tunsigned char\t\tfree_head;\n\tunsigned char\t\tfree_tail;\n\tunsigned char\t\tpending_queue[TW_Q_LENGTH];\n\tunsigned char\t\tpending_head;\n\tunsigned char\t\tpending_tail;\n\tint\t\t\tstate[TW_Q_LENGTH];\n\tunsigned int\t\tposted_request_count;\n\tunsigned int\t\tmax_posted_request_count;\n\tunsigned int\t\tpending_request_count;\n\tunsigned int\t\tmax_pending_request_count;\n\tunsigned int\t\tmax_sgl_entries;\n\tunsigned int\t\tsgl_entries;\n\tunsigned int\t\tnum_resets;\n\tunsigned int\t\tsector_count;\n\tunsigned int\t\tmax_sector_count;\n\tunsigned int\t\taen_count;\n\tstruct Scsi_Host\t*host;\n\tlong\t\t\tflags;\n\tint\t\t\treset_print;\n\tTW_Event\t\t*event_queue[TW_Q_LENGTH];\n\tunsigned char\t\terror_index;\n\tunsigned char\t\tevent_queue_wrapped;\n\tunsigned int\t\terror_sequence_id;\n\tint\t\t\tioctl_sem_lock;\n\tktime_t\t\t\tioctl_time;\n\tint\t\t\tchrdev_request_id;\n\twait_queue_head_t\tioctl_wqueue;\n\tstruct mutex\t\tioctl_lock;\n\tchar\t\t\taen_clobber;\n\tTW_Compatibility_Info\ttw_compat_info;\n} TW_Device_Extension;\n\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}