{
  "module_name": "megaraid.h",
  "hash_id": "02f9aad8029216984d55ea49dd4dc7d0e91159eeca3c7b0cda0bc93f93de46c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/megaraid.h",
  "human_readable_source": " \n#ifndef __MEGARAID_H__\n#define __MEGARAID_H__\n\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <scsi/scsi_cmnd.h>\n\n#define MEGARAID_VERSION\t\\\n\t\"v2.00.4 (Release Date: Thu Feb 9 08:51:30 EST 2006)\\n\"\n\n \n\n \n#define MEGA_HAVE_COALESCING\t0\n\n \n#define MEGA_HAVE_CLUSTERING\t1\n\n \n#define MEGA_HAVE_STATS\t\t0\n\n \n#define MEGA_HAVE_ENH_PROC\t1\n\n#define MAX_DEV_TYPE\t32\n\n#define PCI_DEVICE_ID_DISCOVERY\t\t0x000E\n#define PCI_DEVICE_ID_PERC4_DI\t\t0x000F\n#define PCI_DEVICE_ID_PERC4_QC_VERDE\t0x0407\n\n#define HBA_SIGNATURE\t      \t\t0x3344\n#define HBA_SIGNATURE_471\t  \t0xCCCC\n#define HBA_SIGNATURE_64BIT\t\t0x0299\n\n#define MBOX_BUSY_WAIT\t\t\t10\t \n#define DEFAULT_INITIATOR_ID\t7\n\n#define MAX_SGLIST\t\t64\t \n#define MIN_SGLIST\t\t26\t \n#define MAX_COMMANDS\t\t126\n#define CMDID_INT_CMDS\t\tMAX_COMMANDS+1\t \n\n#define MAX_CDB_LEN\t     \t10\n#define MAX_EXT_CDB_LEN\t\t16\t \n\n#define DEF_CMD_PER_LUN\t\t63\n#define MAX_CMD_PER_LUN\t\tMAX_COMMANDS\n#define MAX_FIRMWARE_STATUS\t46\n#define MAX_XFER_PER_CMD\t(64*1024)\n#define MAX_SECTORS_PER_IO\t128\n\n#define MAX_LOGICAL_DRIVES_40LD\t\t40\n#define FC_MAX_PHYSICAL_DEVICES\t\t256\n#define MAX_LOGICAL_DRIVES_8LD\t\t8\n#define MAX_CHANNELS\t\t\t5\n#define MAX_TARGET\t\t\t15\n#define MAX_PHYSICAL_DRIVES\t\tMAX_CHANNELS*MAX_TARGET\n#define MAX_ROW_SIZE_40LD\t\t32\n#define MAX_ROW_SIZE_8LD\t\t8\n#define MAX_SPAN_DEPTH\t\t\t8\n\n#define NVIRT_CHAN\t\t4\t \nstruct mbox_out {\n\t  u8 cmd;\n\t  u8 cmdid;\n\t  u16 numsectors;\n\t  u32 lba;\n\t  u32 xferaddr;\n\t  u8 logdrv;\n\t  u8 numsgelements;\n\t  u8 resvd;\n} __attribute__ ((packed));\n\nstruct mbox_in {\n\t  volatile u8 busy;\n\t  volatile u8 numstatus;\n\t  volatile u8 status;\n\t  volatile u8 completed[MAX_FIRMWARE_STATUS];\n\tvolatile u8 poll;\n\tvolatile u8 ack;\n} __attribute__ ((packed));\n\ntypedef struct {\n\tstruct mbox_out\tm_out;\n\tstruct mbox_in\tm_in;\n} __attribute__ ((packed)) mbox_t;\n\ntypedef struct {\n\tu32 xfer_segment_lo;\n\tu32 xfer_segment_hi;\n\tmbox_t mbox;\n} __attribute__ ((packed)) mbox64_t;\n\n\n \n#define MAX_REQ_SENSE_LEN       0x20\n\ntypedef struct {\n\tu8 timeout:3;\t\t \n\tu8 ars:1;\n\tu8 reserved:3;\n\tu8 islogical:1;\n\tu8 logdrv;\t\t \n\tu8 channel;\t\t \n\tu8 target;\t\t \n\tu8 queuetag;\t\t \n\tu8 queueaction;\t\t \n\tu8 cdb[MAX_CDB_LEN];\n\tu8 cdblen;\n\tu8 reqsenselen;\n\tu8 reqsensearea[MAX_REQ_SENSE_LEN];\n\tu8 numsgelements;\n\tu8 scsistatus;\n\tu32 dataxferaddr;\n\tu32 dataxferlen;\n} __attribute__ ((packed)) mega_passthru;\n\n\n \ntypedef struct {\n\tu8 timeout:3;\t\t \n\tu8 ars:1;\n\tu8 rsvd1:1;\n\tu8 cd_rom:1;\n\tu8 rsvd2:1;\n\tu8 islogical:1;\n\tu8 logdrv;\t\t \n\tu8 channel;\t\t \n\tu8 target;\t\t \n\tu8 queuetag;\t\t \n\tu8 queueaction;\t\t \n\tu8 cdblen;\n\tu8 rsvd3;\n\tu8 cdb[MAX_EXT_CDB_LEN];\n\tu8 numsgelements;\n\tu8 status;\n\tu8 reqsenselen;\n\tu8 reqsensearea[MAX_REQ_SENSE_LEN];\n\tu8 rsvd4;\n\tu32 dataxferaddr;\n\tu32 dataxferlen;\n} __attribute__ ((packed)) mega_ext_passthru;\n\ntypedef struct {\n\tu64 address;\n\tu32 length;\n} __attribute__ ((packed)) mega_sgl64;\n\ntypedef struct {\n\tu32 address;\n\tu32 length;\n} __attribute__ ((packed)) mega_sglist;\n\n\n \ntypedef struct {\n\tint\tidx;\n\tu32\tstate;\n\tstruct list_head\tlist;\n\tu8\traw_mbox[66];\n\tu32\tdma_type;\n\tu32\tdma_direction;\n\n\tstruct scsi_cmnd\t*cmd;\n\tdma_addr_t\tdma_h_bulkdata;\n\tdma_addr_t\tdma_h_sgdata;\n\n\tmega_sglist\t*sgl;\n\tmega_sgl64\t*sgl64;\n\tdma_addr_t\tsgl_dma_addr;\n\n\tmega_passthru\t\t*pthru;\n\tdma_addr_t\t\tpthru_dma_addr;\n\tmega_ext_passthru\t*epthru;\n\tdma_addr_t\t\tepthru_dma_addr;\n} scb_t;\n\n \n#define SCB_FREE\t0x0000\t \n#define SCB_ACTIVE\t0x0001\t \n#define SCB_PENDQ\t0x0002\t \n#define SCB_ISSUED\t0x0004\t \n#define SCB_ABORT\t0x0008\t \n#define SCB_RESET\t0x0010\t \n\n \ntypedef struct {\n\tu32\tdata_size;  \n\n\tu32\tconfig_signature;\n\t\t \n\n\tu8\tfw_version[16];\t\t \n\tu8\tbios_version[16];\t \n\tu8\tproduct_name[80];\t \n\n\tu8\tmax_commands;\t\t \n\tu8\tnchannels;\t\t \n\tu8\tfc_loop_present;\t \n\tu8\tmem_type;\t\t \n\n\tu32\tsignature;\n\tu16\tdram_size;\t\t \n\tu16\tsubsysid;\n\n\tu16\tsubsysvid;\n\tu8\tnotify_counters;\n\tu8\tpad1k[889];\t\t \n} __attribute__ ((packed)) mega_product_info;\n\nstruct notify {\n\tu32 global_counter;\t \n\n\tu8 param_counter;\t \n\tu8 param_id;\t\t \n\tu16 param_val;\t\t \n\n\tu8 write_config_counter;\t \n\tu8 write_config_rsvd[3];\n\n\tu8 ldrv_op_counter;\t \n\tu8 ldrv_opid;\t\t \n\tu8 ldrv_opcmd;\t\t \n\tu8 ldrv_opstatus;\t \n\n\tu8 ldrv_state_counter;\t \n\tu8 ldrv_state_id;\t\t \n\tu8 ldrv_state_new;\t \n\tu8 ldrv_state_old;\t \n\n\tu8 pdrv_state_counter;\t \n\tu8 pdrv_state_id;\t\t \n\tu8 pdrv_state_new;\t \n\tu8 pdrv_state_old;\t \n\n\tu8 pdrv_fmt_counter;\t \n\tu8 pdrv_fmt_id;\t\t \n\tu8 pdrv_fmt_val;\t\t \n\tu8 pdrv_fmt_rsvd;\n\n\tu8 targ_xfer_counter;\t \n\tu8 targ_xfer_id;\t \n\tu8 targ_xfer_val;\t\t \n\tu8 targ_xfer_rsvd;\n\n\tu8 fcloop_id_chg_counter;\t \n\tu8 fcloopid_pdrvid;\t\t \n\tu8 fcloop_id0;\t\t\t \n\tu8 fcloop_id1;\t\t\t \n\n\tu8 fcloop_state_counter;\t \n\tu8 fcloop_state0;\t\t \n\tu8 fcloop_state1;\t\t \n\tu8 fcloop_state_rsvd;\n} __attribute__ ((packed));\n\n#define MAX_NOTIFY_SIZE     0x80\n#define CUR_NOTIFY_SIZE     sizeof(struct notify)\n\ntypedef struct {\n\tu32\tdata_size;  \n\n\tstruct notify notify;\n\n\tu8\tnotify_rsvd[MAX_NOTIFY_SIZE - CUR_NOTIFY_SIZE];\n\n\tu8\trebuild_rate;\t\t \n\tu8\tcache_flush_interval;\t \n\tu8\tsense_alert;\n\tu8\tdrive_insert_count;\t \n\n\tu8\tbattery_status;\n\tu8\tnum_ldrv;\t\t \n\tu8\trecon_state[MAX_LOGICAL_DRIVES_40LD / 8];\t \n\tu16\tldrv_op_status[MAX_LOGICAL_DRIVES_40LD / 8];  \n\n\tu32\tldrv_size[MAX_LOGICAL_DRIVES_40LD]; \n\tu8\tldrv_prop[MAX_LOGICAL_DRIVES_40LD];\n\tu8\tldrv_state[MAX_LOGICAL_DRIVES_40LD]; \n\tu8\tpdrv_state[FC_MAX_PHYSICAL_DEVICES]; \n\tu16\tpdrv_format[FC_MAX_PHYSICAL_DEVICES / 16];\n\n\tu8\ttarg_xfer[80];\t \n\tu8\tpad1k[263];\t \n} __attribute__ ((packed)) mega_inquiry3;\n\n\n \ntypedef struct {\n\tu8\tmax_commands;\t \n\tu8\trebuild_rate;\t \n\tu8\tmax_targ_per_chan;\t \n\tu8\tnchannels;\t \n\tu8\tfw_version[4];\t \n\tu16\tage_of_flash;\t \n\tu8\tchip_set_value;\t \n\tu8\tdram_size;\t \n\tu8\tcache_flush_interval;\t \n\tu8\tbios_version[4];\n\tu8\tboard_type;\n\tu8\tsense_alert;\n\tu8\twrite_config_count;\t \n\tu8\tdrive_inserted_count;\t \n\tu8\tinserted_drive;\t \n\tu8\tbattery_status;\t \n\tu8\tdec_fault_bus_info;\n} __attribute__ ((packed)) mega_adp_info;\n\n\ntypedef struct {\n\tu8\tnum_ldrv;\t \n\tu8\trsvd[3];\n\tu32\tldrv_size[MAX_LOGICAL_DRIVES_8LD];\n\tu8\tldrv_prop[MAX_LOGICAL_DRIVES_8LD];\n\tu8\tldrv_state[MAX_LOGICAL_DRIVES_8LD];\n} __attribute__ ((packed)) mega_ldrv_info;\n\ntypedef struct {\n\tu8\tpdrv_state[MAX_PHYSICAL_DRIVES];\n\tu8\trsvd;\n} __attribute__ ((packed)) mega_pdrv_info;\n\n \ntypedef struct {\n\tmega_adp_info\tadapter_info;\n\tmega_ldrv_info\tlogdrv_info;\n\tmega_pdrv_info\tpdrv_info;\n} __attribute__ ((packed)) mraid_inquiry;\n\n\n \ntypedef struct {\n\tmraid_inquiry\traid_inq;\n\tu16\tphys_drv_format[MAX_CHANNELS];\n\tu8\tstack_attn;\n\tu8\tmodem_status;\n\tu8\trsvd[2];\n} __attribute__ ((packed)) mraid_ext_inquiry;\n\n\ntypedef struct {\n\tu8\tchannel;\n\tu8\ttarget;\n}__attribute__ ((packed)) adp_device;\n\ntypedef struct {\n\tu32\t\tstart_blk;\t \n\tu32\t\tnum_blks;\t \n\tadp_device\tdevice[MAX_ROW_SIZE_40LD];\n}__attribute__ ((packed)) adp_span_40ld;\n\ntypedef struct {\n\tu32\t\tstart_blk;\t \n\tu32\t\tnum_blks;\t \n\tadp_device\tdevice[MAX_ROW_SIZE_8LD];\n}__attribute__ ((packed)) adp_span_8ld;\n\ntypedef struct {\n\tu8\tspan_depth;\t \n\tu8\tlevel;\t\t \n\tu8\tread_ahead;\t \n\tu8\tstripe_sz;\t \n\tu8\tstatus;\t\t \n\tu8\twrite_mode;\t \n\tu8\tdirect_io;\t \n\tu8\trow_size;\t \n} __attribute__ ((packed)) logdrv_param;\n\ntypedef struct {\n\tlogdrv_param\tlparam;\n\tadp_span_40ld\tspan[MAX_SPAN_DEPTH];\n}__attribute__ ((packed)) logdrv_40ld;\n\ntypedef struct {\n\tlogdrv_param\tlparam;\n\tadp_span_8ld\tspan[MAX_SPAN_DEPTH];\n}__attribute__ ((packed)) logdrv_8ld;\n\ntypedef struct {\n\tu8\ttype;\t\t \n\tu8\tcur_status;\t \n\tu8\ttag_depth;\t \n\tu8\tsync_neg;\t \n\tu32\tsize;\t\t \n}__attribute__ ((packed)) phys_drv;\n\ntypedef struct {\n\tu8\t\tnlog_drives;\t\t \n\tu8\t\tresvd[3];\n\tlogdrv_40ld\tldrv[MAX_LOGICAL_DRIVES_40LD];\n\tphys_drv\tpdrv[MAX_PHYSICAL_DRIVES];\n}__attribute__ ((packed)) disk_array_40ld;\n\ntypedef struct {\n\tu8\t\tnlog_drives;\t \n\tu8\t\tresvd[3];\n\tlogdrv_8ld\tldrv[MAX_LOGICAL_DRIVES_8LD];\n\tphys_drv\tpdrv[MAX_PHYSICAL_DRIVES];\n}__attribute__ ((packed)) disk_array_8ld;\n\n\n \n \n#define IOCTL_MAX_DATALEN       4096\n\nstruct uioctl_t {\n\tu32 inlen;\n\tu32 outlen;\n\tunion {\n\t\tu8 fca[16];\n\t\tstruct {\n\t\t\tu8 opcode;\n\t\t\tu8 subopcode;\n\t\t\tu16 adapno;\n#if BITS_PER_LONG == 32\n\t\t\tu8 *buffer;\n\t\t\tu8 pad[4];\n#endif\n#if BITS_PER_LONG == 64\n\t\t\tu8 *buffer;\n#endif\n\t\t\tu32 length;\n\t\t} __attribute__ ((packed)) fcs;\n\t} __attribute__ ((packed)) ui;\n\tu8 mbox[18];\t\t \n\tmega_passthru pthru;\n#if BITS_PER_LONG == 32\n\tchar __user *data;\t\t \n\tchar pad[4];\n#endif\n#if BITS_PER_LONG == 64\n\tchar __user *data;\n#endif\n} __attribute__ ((packed));\n\n \n#define MAX_CONTROLLERS 32\n\nstruct mcontroller {\n\tu64 base;\n\tu8 irq;\n\tu8 numldrv;\n\tu8 pcibus;\n\tu16 pcidev;\n\tu8 pcifun;\n\tu16 pciid;\n\tu16 pcivendor;\n\tu8 pcislot;\n\tu32 uid;\n};\n\n \ntypedef struct {\n\tu8\tcmd;\n\tu8\tcmdid;\n\tu8\topcode;\n\tu8\tsubopcode;\n\tu32\tlba;\n\tu32\txferaddr;\n\tu8\tlogdrv;\n\tu8\trsvd[3];\n\tu8\tnumstatus;\n\tu8\tstatus;\n} __attribute__ ((packed)) megacmd_t;\n\n \n#define MEGAIOC_MAGIC  \t'm'\n\n#define MEGAIOC_QNADAP\t\t'm'\t \n#define MEGAIOC_QDRVRVER\t'e'\t \n#define MEGAIOC_QADAPINFO   \t'g'\t \n#define MKADAP(adapno)\t  \t(MEGAIOC_MAGIC << 8 | (adapno) )\n#define GETADAP(mkadap)\t \t( (mkadap) ^ MEGAIOC_MAGIC << 8 )\n\n \n\n \n#define VENDOR_SPECIFIC_COMMANDS\t0xE0\n#define MEGA_INTERNAL_CMD\t\tVENDOR_SPECIFIC_COMMANDS + 0x01\n\n \n#define USCSICMD\tVENDOR_SPECIFIC_COMMANDS\n\n \n#define UIOC_RD\t\t0x00001\n#define UIOC_WR\t\t0x00002\n\n \n#define MBOX_CMD\t0x00000\t \n#define GET_DRIVER_VER\t0x10000\t \n#define GET_N_ADAP\t0x20000\t \n#define GET_ADAP_INFO\t0x30000\t \n#define GET_CAP\t\t0x40000\t \n#define GET_STATS\t0x50000\t \n\n\n \ntypedef struct {\n\tchar\t\tsignature[8];\t \n\tu32\t\topcode;\t\t \n\tu32\t\tadapno;\t\t \n\tunion {\n\t\tu8\t__raw_mbox[18];\n\t\tvoid __user *__uaddr;  \n\t}__ua;\n\n#define uioc_rmbox\t__ua.__raw_mbox\n#define MBOX(uioc)\t((megacmd_t *)&((uioc).__ua.__raw_mbox[0]))\n#define MBOX_P(uioc)\t((megacmd_t __user *)&((uioc)->__ua.__raw_mbox[0]))\n#define uioc_uaddr\t__ua.__uaddr\n\n\tu32\t\txferlen;\t \n\tu32\t\tflags;\t\t \n}nitioctl_t;\n\n\n \ntypedef struct {\n\tint\tnum_ldrv;\t \n\tu32\tnreads[MAX_LOGICAL_DRIVES_40LD];\t \n\tu32\tnreadblocks[MAX_LOGICAL_DRIVES_40LD];\t \n\tu32\tnwrites[MAX_LOGICAL_DRIVES_40LD];\t \n\tu32\tnwriteblocks[MAX_LOGICAL_DRIVES_40LD];\t \n\tu32\trd_errors[MAX_LOGICAL_DRIVES_40LD];\t \n\tu32\twr_errors[MAX_LOGICAL_DRIVES_40LD];\t \n}megastat_t;\n\n\nstruct private_bios_data {\n\tu8\tgeometry:4;\t \n\tu8\tunused:4;\t \n\tu8\tboot_drv;\t \n\tu8\trsvd[12];\n\tu16\tcksum;\t \n} __attribute__ ((packed));\n\n\n\n\n \n\n#define MEGA_MBOXCMD_LREAD\t0x01\n#define MEGA_MBOXCMD_LWRITE\t0x02\n#define MEGA_MBOXCMD_PASSTHRU\t0x03\n#define MEGA_MBOXCMD_ADPEXTINQ\t0x04\n#define MEGA_MBOXCMD_ADAPTERINQ\t0x05\n#define MEGA_MBOXCMD_LREAD64\t0xA7\n#define MEGA_MBOXCMD_LWRITE64\t0xA8\n#define MEGA_MBOXCMD_PASSTHRU64\t0xC3\n#define MEGA_MBOXCMD_EXTPTHRU\t0xE3\n\n#define MAIN_MISC_OPCODE\t0xA4\t \n#define GET_MAX_SG_SUPPORT\t0x01\t \n\n#define FC_NEW_CONFIG\t\t0xA1\n#define NC_SUBOP_PRODUCT_INFO\t0x0E\n#define NC_SUBOP_ENQUIRY3\t0x0F\n#define ENQ3_GET_SOLICITED_FULL\t0x02\n#define OP_DCMD_READ_CONFIG\t0x04\n#define NEW_READ_CONFIG_8LD\t0x67\n#define READ_CONFIG_8LD\t\t0x07\n#define FLUSH_ADAPTER\t\t0x0A\n#define FLUSH_SYSTEM\t\t0xFE\n\n \n#define\tFC_DEL_LOGDRV\t\t0xA4\t \n#define\tOP_SUP_DEL_LOGDRV\t0x2A\t \n#define OP_GET_LDID_MAP\t\t0x18\t \n#define OP_DEL_LOGDRV\t\t0x1C\t \n\n \n#define IS_BIOS_ENABLED\t\t0x62\n#define GET_BIOS\t\t0x01\n#define CHNL_CLASS\t\t0xA9\n#define GET_CHNL_CLASS\t\t0x00\n#define SET_CHNL_CLASS\t\t0x01\n#define CH_RAID\t\t\t0x01\n#define CH_SCSI\t\t\t0x00\n#define BIOS_PVT_DATA\t\t0x40\n#define GET_BIOS_PVT_DATA\t0x00\n\n\n \n#define MEGA_GET_TARGET_ID\t0x7D\n#define MEGA_CLUSTER_OP\t\t0x70\n#define MEGA_GET_CLUSTER_MODE\t0x02\n#define MEGA_CLUSTER_CMD\t0x6E\n#define MEGA_RESERVE_LD\t\t0x01\n#define MEGA_RELEASE_LD\t\t0x02\n#define MEGA_RESET_RESERVATIONS\t0x03\n#define MEGA_RESERVATION_STATUS\t0x04\n#define MEGA_RESERVE_PD\t\t0x05\n#define MEGA_RELEASE_PD\t\t0x06\n\n\n \n#define MEGA_BATT_MODULE_MISSING\t0x01\n#define MEGA_BATT_LOW_VOLTAGE\t\t0x02\n#define MEGA_BATT_TEMP_HIGH\t\t0x04\n#define MEGA_BATT_PACK_MISSING\t\t0x08\n#define MEGA_BATT_CHARGE_MASK\t\t0x30\n#define MEGA_BATT_CHARGE_DONE\t\t0x00\n#define MEGA_BATT_CHARGE_INPROG\t\t0x10\n#define MEGA_BATT_CHARGE_FAIL\t\t0x20\n#define MEGA_BATT_CYCLES_EXCEEDED\t0x40\n\n \n#define PDRV_UNCNF\t0\n#define PDRV_ONLINE\t3\n#define PDRV_FAILED\t4\n#define PDRV_RBLD\t5\n#define PDRV_HOTSPARE\t6\n\n\n \n#define RDRV_OFFLINE\t0\n#define RDRV_DEGRADED\t1\n#define RDRV_OPTIMAL\t2\n#define RDRV_DELETED\t3\n\n \n#define NO_READ_AHEAD\t\t0\n#define READ_AHEAD\t\t1\n#define ADAP_READ_AHEAD\t\t2\n#define WRMODE_WRITE_THRU\t0\n#define WRMODE_WRITE_BACK\t1\n#define CACHED_IO\t\t0\n#define DIRECT_IO\t\t1\n\nstruct megaraid_cmd_priv {\n\tstruct list_head entry;\n};\n\n#define SCSI_LIST(scp)\t\t\t\t\t\t\t\\\n\t(&((struct megaraid_cmd_priv *)scsi_cmd_priv(scp))->entry)\n\nstruct scsi_cmd_and_priv {\n\tstruct scsi_cmnd\t cmd;\n\tstruct megaraid_cmd_priv priv;\n};\n\nstatic inline struct scsi_cmnd *\nmegaraid_to_scsi_cmd(struct megaraid_cmd_priv *cmd_priv)\n{\n\t \n\tBUILD_BUG_ON(sizeof(struct scsi_cmd_and_priv) !=\n\t\t     sizeof(struct scsi_cmnd) +\n\t\t     sizeof(struct megaraid_cmd_priv));\n\n\treturn &container_of(cmd_priv, struct scsi_cmd_and_priv, priv)->cmd;\n}\n\n \ntypedef struct {\n\tint\tthis_id;\t \n\tu32\tflag;\n\n\tunsigned long\t\tbase;\n\tvoid __iomem\t\t*mmio_base;\n\n\t \n\tmbox64_t\t*una_mbox64;\n\tdma_addr_t\tuna_mbox64_dma;\n\n\tvolatile mbox64_t\t*mbox64; \n\tvolatile mbox_t\t\t*mbox;\t \n\tdma_addr_t\t\tmbox_dma;\n\n\tstruct pci_dev\t*dev;\n\n\tstruct list_head\tfree_list;\n\tstruct list_head\tpending_list;\n\tstruct list_head\tcompleted_list;\n\n\tstruct Scsi_Host\t*host;\n\n#define MEGA_BUFFER_SIZE (2*1024)\n\tu8\t\t*mega_buffer;\n\tdma_addr_t\tbuf_dma_handle;\n\n\tmega_product_info\tproduct_info;\n\n\tu8\t\tmax_cmds;\n\tscb_t\t\t*scb_list;\n\n\tatomic_t\tpend_cmds;\t \n\n#if MEGA_HAVE_STATS\n\tu32\tnreads[MAX_LOGICAL_DRIVES_40LD];\n\tu32\tnreadblocks[MAX_LOGICAL_DRIVES_40LD];\n\tu32\tnwrites[MAX_LOGICAL_DRIVES_40LD];\n\tu32\tnwriteblocks[MAX_LOGICAL_DRIVES_40LD];\n\tu32\trd_errors[MAX_LOGICAL_DRIVES_40LD];\n\tu32\twr_errors[MAX_LOGICAL_DRIVES_40LD];\n#endif\n\n\t \n\tu8\tnumldrv;\n\tu8\tfw_version[7];\n\tu8\tbios_version[7];\n\n#ifdef CONFIG_PROC_FS\n\tstruct proc_dir_entry\t*controller_proc_dir_entry;\n#endif\n\n\tint\thas_64bit_addr;\t\t \n\tint\tsupport_ext_cdb;\n\tint\tboot_ldrv_enabled;\n\tint\tboot_ldrv;\n\tint\tboot_pdrv_enabled;\t \n\tint\tboot_pdrv_ch;\t\t \n\tint\tboot_pdrv_tgt;\t\t \n\n\n\tint\tsupport_random_del;\t \n\tint\tread_ldidmap;\t \n\tatomic_t\tquiescent;\t \n\tspinlock_t\tlock;\n\n\tu8\tlogdrv_chan[MAX_CHANNELS+NVIRT_CHAN];  \n\tint\tmega_ch_class;\n\n\tu8\tsglen;\t \n\n\tscb_t\t\t\tint_scb;\n\tstruct mutex\t\tint_mtx;\t \n\tint\t\t\tint_status;\t \n\tstruct completion\tint_waitq;\t \n\n\tint\thas_cluster;\t \n}adapter_t;\n\n\nstruct mega_hbas {\n\tint is_bios_enabled;\n\tadapter_t *hostdata_addr;\n};\n\n\n \n#define IN_ABORT\t0x80000000L\n#define IN_RESET\t0x40000000L\n#define BOARD_MEMMAP\t0x20000000L\n#define BOARD_IOMAP\t0x10000000L\n#define BOARD_40LD   \t0x08000000L\n#define BOARD_64BIT\t0x04000000L\n\n#define INTR_VALID\t\t\t0x40\n\n#define PCI_CONF_AMISIG\t\t\t0xa0\n#define PCI_CONF_AMISIG64\t\t0xa4\n\n\n#define MEGA_DMA_TYPE_NONE\t\t0xFFFF\n#define MEGA_BULK_DATA\t\t\t0x0001\n#define MEGA_SGLIST\t\t\t0x0002\n\n \n\n \n#define CMD_PORT\t \t0x00\n#define ACK_PORT\t \t0x00\n#define TOGGLE_PORT\t\t0x01\n#define INTR_PORT\t  \t0x0a\n\n#define MBOX_BUSY_PORT     \t0x00\n#define MBOX_PORT0\t \t0x04\n#define MBOX_PORT1\t \t0x05\n#define MBOX_PORT2\t \t0x06\n#define MBOX_PORT3\t \t0x07\n#define ENABLE_MBOX_REGION \t0x0B\n\n \n#define ISSUE_BYTE\t \t0x10\n#define ACK_BYTE\t   \t0x08\n#define ENABLE_INTR_BYTE   \t0xc0\n#define DISABLE_INTR_BYTE  \t0x00\n#define VALID_INTR_BYTE    \t0x40\n#define MBOX_BUSY_BYTE     \t0x10\n#define ENABLE_MBOX_BYTE   \t0x00\n\n\n \n#define issue_command(adapter)\t\\\n\t\toutb_p(ISSUE_BYTE, (adapter)->base + CMD_PORT)\n\n#define irq_state(adapter)\tinb_p((adapter)->base + INTR_PORT)\n\n#define set_irq_state(adapter, value)\t\\\n\t\toutb_p((value), (adapter)->base + INTR_PORT)\n\n#define irq_ack(adapter)\t\\\n\t\toutb_p(ACK_BYTE, (adapter)->base + ACK_PORT)\n\n#define irq_enable(adapter)\t\\\n\toutb_p(ENABLE_INTR_BYTE, (adapter)->base + TOGGLE_PORT)\n\n#define irq_disable(adapter)\t\\\n\toutb_p(DISABLE_INTR_BYTE, (adapter)->base + TOGGLE_PORT)\n\n\n \n\n \n\nconst char *megaraid_info (struct Scsi_Host *);\n\nstatic int mega_query_adapter(adapter_t *);\nstatic int issue_scb(adapter_t *, scb_t *);\nstatic int mega_setup_mailbox(adapter_t *);\n\nstatic int megaraid_queue (struct Scsi_Host *, struct scsi_cmnd *);\nstatic scb_t * mega_build_cmd(adapter_t *, struct scsi_cmnd *, int *);\nstatic void __mega_runpendq(adapter_t *);\nstatic int issue_scb_block(adapter_t *, u_char *);\n\nstatic irqreturn_t megaraid_isr_memmapped(int, void *);\nstatic irqreturn_t megaraid_isr_iomapped(int, void *);\n\nstatic void mega_free_scb(adapter_t *, scb_t *);\n\nstatic int megaraid_abort(struct scsi_cmnd *);\nstatic int megaraid_reset(struct scsi_cmnd *);\nstatic int megaraid_abort_and_reset(adapter_t *, struct scsi_cmnd *, int);\nstatic int megaraid_biosparam(struct scsi_device *, struct block_device *,\n\t\tsector_t, int []);\n\nstatic int mega_build_sglist (adapter_t *adapter, scb_t *scb,\n\t\t\t      u32 *buffer, u32 *length);\nstatic int __mega_busywait_mbox (adapter_t *);\nstatic void mega_rundoneq (adapter_t *);\nstatic void mega_cmd_done(adapter_t *, u8 [], int, int);\nstatic inline void mega_free_sgl (adapter_t *adapter);\nstatic void mega_8_to_40ld (mraid_inquiry *inquiry,\n\t\tmega_inquiry3 *enquiry3, mega_product_info *);\n\nstatic int megadev_open (struct inode *, struct file *);\nstatic int megadev_ioctl (struct file *, unsigned int, unsigned long);\nstatic int mega_m_to_n(void __user *, nitioctl_t *);\nstatic int mega_n_to_m(void __user *, megacmd_t *);\n\nstatic int mega_init_scb (adapter_t *);\n\nstatic int mega_is_bios_enabled (adapter_t *);\n\n#ifdef CONFIG_PROC_FS\nstatic void mega_create_proc_entry(int, struct proc_dir_entry *);\nstatic int mega_adapinq(adapter_t *, dma_addr_t);\nstatic int mega_internal_dev_inquiry(adapter_t *, u8, u8, dma_addr_t);\n#endif\n\nstatic int mega_support_ext_cdb(adapter_t *);\nstatic mega_passthru* mega_prepare_passthru(adapter_t *, scb_t *,\n\t\tstruct scsi_cmnd *, int, int);\nstatic mega_ext_passthru* mega_prepare_extpassthru(adapter_t *,\n\t\tscb_t *, struct scsi_cmnd *, int, int);\nstatic void mega_enum_raid_scsi(adapter_t *);\nstatic void mega_get_boot_drv(adapter_t *);\nstatic int mega_support_random_del(adapter_t *);\nstatic int mega_del_logdrv(adapter_t *, int);\nstatic int mega_do_del_logdrv(adapter_t *, int);\nstatic void mega_get_max_sgl(adapter_t *);\nstatic int mega_internal_command(adapter_t *, megacmd_t *, mega_passthru *);\nstatic int mega_support_cluster(adapter_t *);\n#endif\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}