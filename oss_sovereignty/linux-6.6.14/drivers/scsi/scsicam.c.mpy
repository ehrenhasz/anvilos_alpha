{
  "module_name": "scsicam.c",
  "hash_id": "95988a0255397893206033048f12a990771e9de6197b00107f3a4d21cc0ade7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsicam.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/msdos_partition.h>\n#include <asm/unaligned.h>\n\n#include <scsi/scsicam.h>\n\n \nunsigned char *scsi_bios_ptable(struct block_device *dev)\n{\n\tstruct address_space *mapping = bdev_whole(dev)->bd_inode->i_mapping;\n\tunsigned char *res = NULL;\n\tstruct folio *folio;\n\n\tfolio = read_mapping_folio(mapping, 0, NULL);\n\tif (IS_ERR(folio))\n\t\treturn NULL;\n\n\tres = kmemdup(folio_address(folio) + 0x1be, 66, GFP_KERNEL);\n\tfolio_put(folio);\n\treturn res;\n}\nEXPORT_SYMBOL(scsi_bios_ptable);\n\n \nbool scsi_partsize(struct block_device *bdev, sector_t capacity, int geom[3])\n{\n\tint cyl, ext_cyl, end_head, end_cyl, end_sector;\n\tunsigned int logical_end, physical_end, ext_physical_end;\n\tstruct msdos_partition *p, *largest = NULL;\n\tvoid *buf;\n\tint ret = false;\n\n\tbuf = scsi_bios_ptable(bdev);\n\tif (!buf)\n\t\treturn false;\n\n\tif (*(unsigned short *) (buf + 64) == 0xAA55) {\n\t\tint largest_cyl = -1, i;\n\n\t\tfor (i = 0, p = buf; i < 4; i++, p++) {\n\t\t\tif (!p->sys_ind)\n\t\t\t\tcontinue;\n#ifdef DEBUG\n\t\t\tprintk(\"scsicam_bios_param : partition %d has system \\n\",\n\t\t\t       i);\n#endif\n\t\t\tcyl = p->cyl + ((p->sector & 0xc0) << 2);\n\t\t\tif (cyl > largest_cyl) {\n\t\t\t\tlargest_cyl = cyl;\n\t\t\t\tlargest = p;\n\t\t\t}\n\t\t}\n\t}\n\tif (largest) {\n\t\tend_cyl = largest->end_cyl + ((largest->end_sector & 0xc0) << 2);\n\t\tend_head = largest->end_head;\n\t\tend_sector = largest->end_sector & 0x3f;\n\n\t\tif (end_head + 1 == 0 || end_sector == 0)\n\t\t\tgoto out_free_buf;\n\n#ifdef DEBUG\n\t\tprintk(\"scsicam_bios_param : end at h = %d, c = %d, s = %d\\n\",\n\t\t       end_head, end_cyl, end_sector);\n#endif\n\n\t\tphysical_end = end_cyl * (end_head + 1) * end_sector +\n\t\t    end_head * end_sector + end_sector;\n\n\t\t \n\t\tlogical_end = get_unaligned_le32(&largest->start_sect)\n\t\t    + get_unaligned_le32(&largest->nr_sects);\n\n\t\t \n\t\text_cyl = (logical_end - (end_head * end_sector + end_sector))\n\t\t    / (end_head + 1) / end_sector;\n\t\text_physical_end = ext_cyl * (end_head + 1) * end_sector +\n\t\t    end_head * end_sector + end_sector;\n\n#ifdef DEBUG\n\t\tprintk(\"scsicam_bios_param : logical_end=%d physical_end=%d ext_physical_end=%d ext_cyl=%d\\n\"\n\t\t  ,logical_end, physical_end, ext_physical_end, ext_cyl);\n#endif\n\n\t\tif (logical_end == physical_end ||\n\t\t    (end_cyl == 1023 && ext_physical_end == logical_end)) {\n\t\t\tgeom[0] = end_head + 1;\n\t\t\tgeom[1] = end_sector;\n\t\t\tgeom[2] = (unsigned long)capacity /\n\t\t\t\t((end_head + 1) * end_sector);\n\t\t\tret = true;\n\t\t\tgoto out_free_buf;\n\t\t}\n#ifdef DEBUG\n\t\tprintk(\"scsicam_bios_param : logical (%u) != physical (%u)\\n\",\n\t\t       logical_end, physical_end);\n#endif\n\t}\n\nout_free_buf:\n\tkfree(buf);\n\treturn ret;\n}\nEXPORT_SYMBOL(scsi_partsize);\n\n \n\nstatic int setsize(unsigned long capacity, unsigned int *cyls, unsigned int *hds,\n\t\t   unsigned int *secs)\n{\n\tunsigned int rv = 0;\n\tunsigned long heads, sectors, cylinders, temp;\n\n\tcylinders = 1024L;\t \n\tsectors = 62L;\t\t \n\n\ttemp = cylinders * sectors;\t \n\theads = capacity / temp;\t \n\tif (capacity % temp) {\t \n\t\theads++;\t \n\t\ttemp = cylinders * heads;\t \n\t\tsectors = capacity / temp;\t \n\t\tif (capacity % temp) {\t \n\t\t\tsectors++;\t \n\t\t\ttemp = heads * sectors;\t\t \n\t\t\tcylinders = capacity / temp;\t \n\t\t}\n\t}\n\tif (cylinders == 0)\n\t\trv = (unsigned) -1;\t \n\n\t*cyls = (unsigned int) cylinders;\t \n\t*secs = (unsigned int) sectors;\n\t*hds = (unsigned int) heads;\n\treturn (rv);\n}\n\n \nint scsicam_bios_param(struct block_device *bdev, sector_t capacity, int *ip)\n{\n\tu64 capacity64 = capacity;\t \n\tint ret = 0;\n\n\t \n\tif (scsi_partsize(bdev, capacity, ip))\n\t\treturn 0;\n\n\tif (capacity64 < (1ULL << 32)) {\n\t\t \n\t\tret = setsize((unsigned long)capacity, (unsigned int *)ip + 2,\n\t\t       (unsigned int *)ip + 0, (unsigned int *)ip + 1);\n\t}\n\n\t \n\tif (ret || ip[0] > 255 || ip[1] > 63) {\n\t\tif ((capacity >> 11) > 65534) {\n\t\t\tip[0] = 255;\n\t\t\tip[1] = 63;\n\t\t} else {\n\t\t\tip[0] = 64;\n\t\t\tip[1] = 32;\n\t\t}\n\n\t\tif (capacity > 65535*63*255)\n\t\t\tip[2] = 65535;\n\t\telse\n\t\t\tip[2] = (unsigned long)capacity / (ip[0] * ip[1]);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(scsicam_bios_param);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}