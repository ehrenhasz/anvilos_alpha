{
  "module_name": "sd_zbc.c",
  "hash_id": "cd8d0f7dbb06aabe1ca896a1d5ec1f7c1540f3e8497c66bcf14ad6343c715184",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sd_zbc.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/mm.h>\n#include <linux/mutex.h>\n\n#include <asm/unaligned.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n\n#include \"sd.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"sd_trace.h\"\n\n \nstatic unsigned int sd_zbc_get_zone_wp_offset(struct blk_zone *zone)\n{\n\tif (zone->type == ZBC_ZONE_TYPE_CONV)\n\t\treturn 0;\n\n\tswitch (zone->cond) {\n\tcase BLK_ZONE_COND_IMP_OPEN:\n\tcase BLK_ZONE_COND_EXP_OPEN:\n\tcase BLK_ZONE_COND_CLOSED:\n\t\treturn zone->wp - zone->start;\n\tcase BLK_ZONE_COND_FULL:\n\t\treturn zone->len;\n\tcase BLK_ZONE_COND_EMPTY:\n\tcase BLK_ZONE_COND_OFFLINE:\n\tcase BLK_ZONE_COND_READONLY:\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n}\n\n \nstatic bool sd_zbc_is_gap_zone(const u8 buf[64])\n{\n\treturn (buf[0] & 0xf) == ZBC_ZONE_TYPE_GAP;\n}\n\n \nstatic int sd_zbc_parse_report(struct scsi_disk *sdkp, const u8 buf[64],\n\t\t\t       unsigned int idx, report_zones_cb cb, void *data)\n{\n\tstruct scsi_device *sdp = sdkp->device;\n\tstruct blk_zone zone = { 0 };\n\tsector_t start_lba, gran;\n\tint ret;\n\n\tif (WARN_ON_ONCE(sd_zbc_is_gap_zone(buf)))\n\t\treturn -EINVAL;\n\n\tzone.type = buf[0] & 0x0f;\n\tzone.cond = (buf[1] >> 4) & 0xf;\n\tif (buf[1] & 0x01)\n\t\tzone.reset = 1;\n\tif (buf[1] & 0x02)\n\t\tzone.non_seq = 1;\n\n\tstart_lba = get_unaligned_be64(&buf[16]);\n\tzone.start = logical_to_sectors(sdp, start_lba);\n\tzone.capacity = logical_to_sectors(sdp, get_unaligned_be64(&buf[8]));\n\tzone.len = zone.capacity;\n\tif (sdkp->zone_starting_lba_gran) {\n\t\tgran = logical_to_sectors(sdp, sdkp->zone_starting_lba_gran);\n\t\tif (zone.len > gran) {\n\t\t\tsd_printk(KERN_ERR, sdkp,\n\t\t\t\t  \"Invalid zone at LBA %llu with capacity %llu and length %llu; granularity = %llu\\n\",\n\t\t\t\t  start_lba,\n\t\t\t\t  sectors_to_logical(sdp, zone.capacity),\n\t\t\t\t  sectors_to_logical(sdp, zone.len),\n\t\t\t\t  sectors_to_logical(sdp, gran));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tzone.len = gran;\n\t}\n\tif (zone.cond == ZBC_ZONE_COND_FULL)\n\t\tzone.wp = zone.start + zone.len;\n\telse\n\t\tzone.wp = logical_to_sectors(sdp, get_unaligned_be64(&buf[24]));\n\n\tret = cb(&zone, idx, data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sdkp->rev_wp_offset)\n\t\tsdkp->rev_wp_offset[idx] = sd_zbc_get_zone_wp_offset(&zone);\n\n\treturn 0;\n}\n\n \nstatic int sd_zbc_do_report_zones(struct scsi_disk *sdkp, unsigned char *buf,\n\t\t\t\t  unsigned int buflen, sector_t lba,\n\t\t\t\t  bool partial)\n{\n\tstruct scsi_device *sdp = sdkp->device;\n\tconst int timeout = sdp->request_queue->rq_timeout;\n\tstruct scsi_sense_hdr sshdr;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\tunsigned char cmd[16];\n\tunsigned int rep_len;\n\tint result;\n\n\tmemset(cmd, 0, 16);\n\tcmd[0] = ZBC_IN;\n\tcmd[1] = ZI_REPORT_ZONES;\n\tput_unaligned_be64(lba, &cmd[2]);\n\tput_unaligned_be32(buflen, &cmd[10]);\n\tif (partial)\n\t\tcmd[14] = ZBC_REPORT_ZONE_PARTIAL;\n\n\tresult = scsi_execute_cmd(sdp, cmd, REQ_OP_DRV_IN, buf, buflen,\n\t\t\t\t  timeout, SD_MAX_RETRIES, &exec_args);\n\tif (result) {\n\t\tsd_printk(KERN_ERR, sdkp,\n\t\t\t  \"REPORT ZONES start lba %llu failed\\n\", lba);\n\t\tsd_print_result(sdkp, \"REPORT ZONES\", result);\n\t\tif (result > 0 && scsi_sense_valid(&sshdr))\n\t\t\tsd_print_sense_hdr(sdkp, &sshdr);\n\t\treturn -EIO;\n\t}\n\n\trep_len = get_unaligned_be32(&buf[0]);\n\tif (rep_len < 64) {\n\t\tsd_printk(KERN_ERR, sdkp,\n\t\t\t  \"REPORT ZONES report invalid length %u\\n\",\n\t\t\t  rep_len);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void *sd_zbc_alloc_report_buffer(struct scsi_disk *sdkp,\n\t\t\t\t\tunsigned int nr_zones, size_t *buflen)\n{\n\tstruct request_queue *q = sdkp->disk->queue;\n\tsize_t bufsize;\n\tvoid *buf;\n\n\t \n\tnr_zones = min(nr_zones, sdkp->zone_info.nr_zones);\n\tbufsize = roundup((nr_zones + 1) * 64, SECTOR_SIZE);\n\tbufsize = min_t(size_t, bufsize,\n\t\t\tqueue_max_hw_sectors(q) << SECTOR_SHIFT);\n\tbufsize = min_t(size_t, bufsize, queue_max_segments(q) << PAGE_SHIFT);\n\n\twhile (bufsize >= SECTOR_SIZE) {\n\t\tbuf = __vmalloc(bufsize,\n\t\t\t\tGFP_KERNEL | __GFP_ZERO | __GFP_NORETRY);\n\t\tif (buf) {\n\t\t\t*buflen = bufsize;\n\t\t\treturn buf;\n\t\t}\n\t\tbufsize = rounddown(bufsize >> 1, SECTOR_SIZE);\n\t}\n\n\treturn NULL;\n}\n\n \nstatic inline sector_t sd_zbc_zone_sectors(struct scsi_disk *sdkp)\n{\n\treturn logical_to_sectors(sdkp->device, sdkp->zone_info.zone_blocks);\n}\n\n \nint sd_zbc_report_zones(struct gendisk *disk, sector_t sector,\n\t\t\tunsigned int nr_zones, report_zones_cb cb, void *data)\n{\n\tstruct scsi_disk *sdkp = scsi_disk(disk);\n\tsector_t lba = sectors_to_logical(sdkp->device, sector);\n\tunsigned int nr, i;\n\tunsigned char *buf;\n\tu64 zone_length, start_lba;\n\tsize_t offset, buflen = 0;\n\tint zone_idx = 0;\n\tint ret;\n\n\tif (!sd_is_zoned(sdkp))\n\t\t \n\t\treturn -EOPNOTSUPP;\n\n\tif (!sdkp->capacity)\n\t\t \n\t\treturn -ENODEV;\n\n\tbuf = sd_zbc_alloc_report_buffer(sdkp, nr_zones, &buflen);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile (zone_idx < nr_zones && lba < sdkp->capacity) {\n\t\tret = sd_zbc_do_report_zones(sdkp, buf, buflen, lba, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\toffset = 0;\n\t\tnr = min(nr_zones, get_unaligned_be32(&buf[0]) / 64);\n\t\tif (!nr)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr && zone_idx < nr_zones; i++) {\n\t\t\toffset += 64;\n\t\t\tstart_lba = get_unaligned_be64(&buf[offset + 16]);\n\t\t\tzone_length = get_unaligned_be64(&buf[offset + 8]);\n\t\t\tif ((zone_idx == 0 &&\n\t\t\t    (lba < start_lba ||\n\t\t\t     lba >= start_lba + zone_length)) ||\n\t\t\t    (zone_idx > 0 && start_lba != lba) ||\n\t\t\t    start_lba + zone_length < start_lba) {\n\t\t\t\tsd_printk(KERN_ERR, sdkp,\n\t\t\t\t\t  \"Zone %d at LBA %llu is invalid: %llu + %llu\\n\",\n\t\t\t\t\t  zone_idx, lba, start_lba, zone_length);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlba = start_lba + zone_length;\n\t\t\tif (sd_zbc_is_gap_zone(&buf[offset])) {\n\t\t\t\tif (sdkp->zone_starting_lba_gran)\n\t\t\t\t\tcontinue;\n\t\t\t\tsd_printk(KERN_ERR, sdkp,\n\t\t\t\t\t  \"Gap zone without constant LBA offsets\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = sd_zbc_parse_report(sdkp, buf + offset, zone_idx,\n\t\t\t\t\t\t  cb, data);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tzone_idx++;\n\t\t}\n\t}\n\n\tret = zone_idx;\nout:\n\tkvfree(buf);\n\treturn ret;\n}\n\nstatic blk_status_t sd_zbc_cmnd_checks(struct scsi_cmnd *cmd)\n{\n\tstruct request *rq = scsi_cmd_to_rq(cmd);\n\tstruct scsi_disk *sdkp = scsi_disk(rq->q->disk);\n\tsector_t sector = blk_rq_pos(rq);\n\n\tif (!sd_is_zoned(sdkp))\n\t\t \n\t\treturn BLK_STS_IOERR;\n\n\tif (sdkp->device->changed)\n\t\treturn BLK_STS_IOERR;\n\n\tif (sector & (sd_zbc_zone_sectors(sdkp) - 1))\n\t\t \n\t\treturn BLK_STS_IOERR;\n\n\treturn BLK_STS_OK;\n}\n\n#define SD_ZBC_INVALID_WP_OFST\t(~0u)\n#define SD_ZBC_UPDATING_WP_OFST\t(SD_ZBC_INVALID_WP_OFST - 1)\n\nstatic int sd_zbc_update_wp_offset_cb(struct blk_zone *zone, unsigned int idx,\n\t\t\t\t    void *data)\n{\n\tstruct scsi_disk *sdkp = data;\n\n\tlockdep_assert_held(&sdkp->zones_wp_offset_lock);\n\n\tsdkp->zones_wp_offset[idx] = sd_zbc_get_zone_wp_offset(zone);\n\n\treturn 0;\n}\n\n \nstatic void sd_zbc_update_wp_offset_workfn(struct work_struct *work)\n{\n\tstruct scsi_disk *sdkp;\n\tunsigned long flags;\n\tsector_t zno;\n\tint ret;\n\n\tsdkp = container_of(work, struct scsi_disk, zone_wp_offset_work);\n\n\tspin_lock_irqsave(&sdkp->zones_wp_offset_lock, flags);\n\tfor (zno = 0; zno < sdkp->zone_info.nr_zones; zno++) {\n\t\tif (sdkp->zones_wp_offset[zno] != SD_ZBC_UPDATING_WP_OFST)\n\t\t\tcontinue;\n\n\t\tspin_unlock_irqrestore(&sdkp->zones_wp_offset_lock, flags);\n\t\tret = sd_zbc_do_report_zones(sdkp, sdkp->zone_wp_update_buf,\n\t\t\t\t\t     SD_BUF_SIZE,\n\t\t\t\t\t     zno * sdkp->zone_info.zone_blocks, true);\n\t\tspin_lock_irqsave(&sdkp->zones_wp_offset_lock, flags);\n\t\tif (!ret)\n\t\t\tsd_zbc_parse_report(sdkp, sdkp->zone_wp_update_buf + 64,\n\t\t\t\t\t    zno, sd_zbc_update_wp_offset_cb,\n\t\t\t\t\t    sdkp);\n\t}\n\tspin_unlock_irqrestore(&sdkp->zones_wp_offset_lock, flags);\n\n\tscsi_device_put(sdkp->device);\n}\n\n \nblk_status_t sd_zbc_prepare_zone_append(struct scsi_cmnd *cmd, sector_t *lba,\n\t\t\t\t\tunsigned int nr_blocks)\n{\n\tstruct request *rq = scsi_cmd_to_rq(cmd);\n\tstruct scsi_disk *sdkp = scsi_disk(rq->q->disk);\n\tunsigned int wp_offset, zno = blk_rq_zone_no(rq);\n\tunsigned long flags;\n\tblk_status_t ret;\n\n\tret = sd_zbc_cmnd_checks(cmd);\n\tif (ret != BLK_STS_OK)\n\t\treturn ret;\n\n\tif (!blk_rq_zone_is_seq(rq))\n\t\treturn BLK_STS_IOERR;\n\n\t \n\tif (!blk_req_zone_write_trylock(rq))\n\t\treturn BLK_STS_ZONE_RESOURCE;\n\n\tspin_lock_irqsave(&sdkp->zones_wp_offset_lock, flags);\n\twp_offset = sdkp->zones_wp_offset[zno];\n\tswitch (wp_offset) {\n\tcase SD_ZBC_INVALID_WP_OFST:\n\t\t \n\t\tif (scsi_device_get(sdkp->device)) {\n\t\t\tret = BLK_STS_IOERR;\n\t\t\tbreak;\n\t\t}\n\t\tsdkp->zones_wp_offset[zno] = SD_ZBC_UPDATING_WP_OFST;\n\t\tschedule_work(&sdkp->zone_wp_offset_work);\n\t\tfallthrough;\n\tcase SD_ZBC_UPDATING_WP_OFST:\n\t\tret = BLK_STS_DEV_RESOURCE;\n\t\tbreak;\n\tdefault:\n\t\twp_offset = sectors_to_logical(sdkp->device, wp_offset);\n\t\tif (wp_offset + nr_blocks > sdkp->zone_info.zone_blocks) {\n\t\t\tret = BLK_STS_IOERR;\n\t\t\tbreak;\n\t\t}\n\n\t\ttrace_scsi_prepare_zone_append(cmd, *lba, wp_offset);\n\t\t*lba += wp_offset;\n\t}\n\tspin_unlock_irqrestore(&sdkp->zones_wp_offset_lock, flags);\n\tif (ret)\n\t\tblk_req_zone_write_unlock(rq);\n\treturn ret;\n}\n\n \nblk_status_t sd_zbc_setup_zone_mgmt_cmnd(struct scsi_cmnd *cmd,\n\t\t\t\t\t unsigned char op, bool all)\n{\n\tstruct request *rq = scsi_cmd_to_rq(cmd);\n\tsector_t sector = blk_rq_pos(rq);\n\tstruct scsi_disk *sdkp = scsi_disk(rq->q->disk);\n\tsector_t block = sectors_to_logical(sdkp->device, sector);\n\tblk_status_t ret;\n\n\tret = sd_zbc_cmnd_checks(cmd);\n\tif (ret != BLK_STS_OK)\n\t\treturn ret;\n\n\tcmd->cmd_len = 16;\n\tmemset(cmd->cmnd, 0, cmd->cmd_len);\n\tcmd->cmnd[0] = ZBC_OUT;\n\tcmd->cmnd[1] = op;\n\tif (all)\n\t\tcmd->cmnd[14] = 0x1;\n\telse\n\t\tput_unaligned_be64(block, &cmd->cmnd[2]);\n\n\trq->timeout = SD_TIMEOUT;\n\tcmd->sc_data_direction = DMA_NONE;\n\tcmd->transfersize = 0;\n\tcmd->allowed = 0;\n\n\treturn BLK_STS_OK;\n}\n\nstatic bool sd_zbc_need_zone_wp_update(struct request *rq)\n{\n\tswitch (req_op(rq)) {\n\tcase REQ_OP_ZONE_APPEND:\n\tcase REQ_OP_ZONE_FINISH:\n\tcase REQ_OP_ZONE_RESET:\n\tcase REQ_OP_ZONE_RESET_ALL:\n\t\treturn true;\n\tcase REQ_OP_WRITE:\n\tcase REQ_OP_WRITE_ZEROES:\n\t\treturn blk_rq_zone_is_seq(rq);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic unsigned int sd_zbc_zone_wp_update(struct scsi_cmnd *cmd,\n\t\t\t\t\t  unsigned int good_bytes)\n{\n\tint result = cmd->result;\n\tstruct request *rq = scsi_cmd_to_rq(cmd);\n\tstruct scsi_disk *sdkp = scsi_disk(rq->q->disk);\n\tunsigned int zno = blk_rq_zone_no(rq);\n\tenum req_op op = req_op(rq);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&sdkp->zones_wp_offset_lock, flags);\n\n\tif (result && op != REQ_OP_ZONE_RESET_ALL) {\n\t\tif (op == REQ_OP_ZONE_APPEND) {\n\t\t\t \n\t\t\tgood_bytes = 0;\n\t\t\tscsi_set_resid(cmd, blk_rq_bytes(rq));\n\t\t}\n\n\t\t \n\t\tif (sdkp->zones_wp_offset[zno] != SD_ZBC_UPDATING_WP_OFST)\n\t\t\tsdkp->zones_wp_offset[zno] = SD_ZBC_INVALID_WP_OFST;\n\t\tgoto unlock_wp_offset;\n\t}\n\n\tswitch (op) {\n\tcase REQ_OP_ZONE_APPEND:\n\t\ttrace_scsi_zone_wp_update(cmd, rq->__sector,\n\t\t\t\t  sdkp->zones_wp_offset[zno], good_bytes);\n\t\trq->__sector += sdkp->zones_wp_offset[zno];\n\t\tfallthrough;\n\tcase REQ_OP_WRITE_ZEROES:\n\tcase REQ_OP_WRITE:\n\t\tif (sdkp->zones_wp_offset[zno] < sd_zbc_zone_sectors(sdkp))\n\t\t\tsdkp->zones_wp_offset[zno] +=\n\t\t\t\t\t\tgood_bytes >> SECTOR_SHIFT;\n\t\tbreak;\n\tcase REQ_OP_ZONE_RESET:\n\t\tsdkp->zones_wp_offset[zno] = 0;\n\t\tbreak;\n\tcase REQ_OP_ZONE_FINISH:\n\t\tsdkp->zones_wp_offset[zno] = sd_zbc_zone_sectors(sdkp);\n\t\tbreak;\n\tcase REQ_OP_ZONE_RESET_ALL:\n\t\tmemset(sdkp->zones_wp_offset, 0,\n\t\t       sdkp->zone_info.nr_zones * sizeof(unsigned int));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nunlock_wp_offset:\n\tspin_unlock_irqrestore(&sdkp->zones_wp_offset_lock, flags);\n\n\treturn good_bytes;\n}\n\n \nunsigned int sd_zbc_complete(struct scsi_cmnd *cmd, unsigned int good_bytes,\n\t\t     struct scsi_sense_hdr *sshdr)\n{\n\tint result = cmd->result;\n\tstruct request *rq = scsi_cmd_to_rq(cmd);\n\n\tif (op_is_zone_mgmt(req_op(rq)) &&\n\t    result &&\n\t    sshdr->sense_key == ILLEGAL_REQUEST &&\n\t    sshdr->asc == 0x24) {\n\t\t \n\t\trq->rq_flags |= RQF_QUIET;\n\t} else if (sd_zbc_need_zone_wp_update(rq))\n\t\tgood_bytes = sd_zbc_zone_wp_update(cmd, good_bytes);\n\n\tif (req_op(rq) == REQ_OP_ZONE_APPEND)\n\t\tblk_req_zone_write_unlock(rq);\n\n\treturn good_bytes;\n}\n\n \nstatic int sd_zbc_check_zoned_characteristics(struct scsi_disk *sdkp,\n\t\t\t\t\t      unsigned char *buf)\n{\n\tu64 zone_starting_lba_gran;\n\n\tif (scsi_get_vpd_page(sdkp->device, 0xb6, buf, 64)) {\n\t\tsd_printk(KERN_NOTICE, sdkp,\n\t\t\t  \"Read zoned characteristics VPD page failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (sdkp->device->type != TYPE_ZBC) {\n\t\t \n\t\tsdkp->urswrz = 1;\n\t\tsdkp->zones_optimal_open = get_unaligned_be32(&buf[8]);\n\t\tsdkp->zones_optimal_nonseq = get_unaligned_be32(&buf[12]);\n\t\tsdkp->zones_max_open = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tsdkp->urswrz = buf[4] & 1;\n\tsdkp->zones_optimal_open = 0;\n\tsdkp->zones_optimal_nonseq = 0;\n\tsdkp->zones_max_open = get_unaligned_be32(&buf[16]);\n\t \n\tswitch (buf[23] & 0xf) {\n\tcase 0:\n\tcase ZBC_CONSTANT_ZONE_LENGTH:\n\t\t \n\t\tbreak;\n\tcase ZBC_CONSTANT_ZONE_START_OFFSET:\n\t\tzone_starting_lba_gran = get_unaligned_be64(&buf[24]);\n\t\tif (zone_starting_lba_gran == 0 ||\n\t\t    !is_power_of_2(zone_starting_lba_gran) ||\n\t\t    logical_to_sectors(sdkp->device, zone_starting_lba_gran) >\n\t\t    UINT_MAX) {\n\t\t\tsd_printk(KERN_ERR, sdkp,\n\t\t\t\t  \"Invalid zone starting LBA granularity %llu\\n\",\n\t\t\t\t  zone_starting_lba_gran);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tsdkp->zone_starting_lba_gran = zone_starting_lba_gran;\n\t\tbreak;\n\tdefault:\n\t\tsd_printk(KERN_ERR, sdkp, \"Invalid zone alignment method\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (!sdkp->urswrz) {\n\t\tif (sdkp->first_scan)\n\t\t\tsd_printk(KERN_NOTICE, sdkp,\n\t\t\t  \"constrained reads devices are not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sd_zbc_check_capacity(struct scsi_disk *sdkp, unsigned char *buf,\n\t\t\t\t u32 *zblocks)\n{\n\tu64 zone_blocks;\n\tsector_t max_lba;\n\tunsigned char *rec;\n\tint ret;\n\n\t \n\tret = sd_zbc_do_report_zones(sdkp, buf, SD_BUF_SIZE, 0, false);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sdkp->rc_basis == 0) {\n\t\t \n\t\tmax_lba = get_unaligned_be64(&buf[8]);\n\t\tif (sdkp->capacity != max_lba + 1) {\n\t\t\tif (sdkp->first_scan)\n\t\t\t\tsd_printk(KERN_WARNING, sdkp,\n\t\t\t\t\t\"Changing capacity from %llu to max LBA+1 %llu\\n\",\n\t\t\t\t\t(unsigned long long)sdkp->capacity,\n\t\t\t\t\t(unsigned long long)max_lba + 1);\n\t\t\tsdkp->capacity = max_lba + 1;\n\t\t}\n\t}\n\n\tif (sdkp->zone_starting_lba_gran == 0) {\n\t\t \n\t\trec = buf + 64;\n\t\tzone_blocks = get_unaligned_be64(&rec[8]);\n\t\tif (logical_to_sectors(sdkp->device, zone_blocks) > UINT_MAX) {\n\t\t\tif (sdkp->first_scan)\n\t\t\t\tsd_printk(KERN_NOTICE, sdkp,\n\t\t\t\t\t  \"Zone size too large\\n\");\n\t\t\treturn -EFBIG;\n\t\t}\n\t} else {\n\t\tzone_blocks = sdkp->zone_starting_lba_gran;\n\t}\n\n\tif (!is_power_of_2(zone_blocks)) {\n\t\tsd_printk(KERN_ERR, sdkp,\n\t\t\t  \"Zone size %llu is not a power of two.\\n\",\n\t\t\t  zone_blocks);\n\t\treturn -EINVAL;\n\t}\n\n\t*zblocks = zone_blocks;\n\n\treturn 0;\n}\n\nstatic void sd_zbc_print_zones(struct scsi_disk *sdkp)\n{\n\tif (!sd_is_zoned(sdkp) || !sdkp->capacity)\n\t\treturn;\n\n\tif (sdkp->capacity & (sdkp->zone_info.zone_blocks - 1))\n\t\tsd_printk(KERN_NOTICE, sdkp,\n\t\t\t  \"%u zones of %u logical blocks + 1 runt zone\\n\",\n\t\t\t  sdkp->zone_info.nr_zones - 1,\n\t\t\t  sdkp->zone_info.zone_blocks);\n\telse\n\t\tsd_printk(KERN_NOTICE, sdkp,\n\t\t\t  \"%u zones of %u logical blocks\\n\",\n\t\t\t  sdkp->zone_info.nr_zones,\n\t\t\t  sdkp->zone_info.zone_blocks);\n}\n\nstatic int sd_zbc_init_disk(struct scsi_disk *sdkp)\n{\n\tsdkp->zones_wp_offset = NULL;\n\tspin_lock_init(&sdkp->zones_wp_offset_lock);\n\tsdkp->rev_wp_offset = NULL;\n\tmutex_init(&sdkp->rev_mutex);\n\tINIT_WORK(&sdkp->zone_wp_offset_work, sd_zbc_update_wp_offset_workfn);\n\tsdkp->zone_wp_update_buf = kzalloc(SD_BUF_SIZE, GFP_KERNEL);\n\tif (!sdkp->zone_wp_update_buf)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid sd_zbc_free_zone_info(struct scsi_disk *sdkp)\n{\n\tif (!sdkp->zone_wp_update_buf)\n\t\treturn;\n\n\t \n\tmutex_lock(&sdkp->rev_mutex);\n\n\tkvfree(sdkp->zones_wp_offset);\n\tsdkp->zones_wp_offset = NULL;\n\tkfree(sdkp->zone_wp_update_buf);\n\tsdkp->zone_wp_update_buf = NULL;\n\n\tsdkp->early_zone_info = (struct zoned_disk_info){ };\n\tsdkp->zone_info = (struct zoned_disk_info){ };\n\n\tmutex_unlock(&sdkp->rev_mutex);\n}\n\nstatic void sd_zbc_revalidate_zones_cb(struct gendisk *disk)\n{\n\tstruct scsi_disk *sdkp = scsi_disk(disk);\n\n\tswap(sdkp->zones_wp_offset, sdkp->rev_wp_offset);\n}\n\n \nint sd_zbc_revalidate_zones(struct scsi_disk *sdkp)\n{\n\tstruct gendisk *disk = sdkp->disk;\n\tstruct request_queue *q = disk->queue;\n\tu32 zone_blocks = sdkp->early_zone_info.zone_blocks;\n\tunsigned int nr_zones = sdkp->early_zone_info.nr_zones;\n\tint ret = 0;\n\tunsigned int flags;\n\n\t \n\tif (sd_is_zoned(sdkp) && !sdkp->zone_wp_update_buf) {\n\t\tret = sd_zbc_init_disk(sdkp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (!blk_queue_is_zoned(q))\n\t\treturn 0;\n\n\t \n\tmutex_lock(&sdkp->rev_mutex);\n\n\tif (sdkp->zone_info.zone_blocks == zone_blocks &&\n\t    sdkp->zone_info.nr_zones == nr_zones &&\n\t    disk->nr_zones == nr_zones)\n\t\tgoto unlock;\n\n\tflags = memalloc_noio_save();\n\tsdkp->zone_info.zone_blocks = zone_blocks;\n\tsdkp->zone_info.nr_zones = nr_zones;\n\tsdkp->rev_wp_offset = kvcalloc(nr_zones, sizeof(u32), GFP_KERNEL);\n\tif (!sdkp->rev_wp_offset) {\n\t\tret = -ENOMEM;\n\t\tmemalloc_noio_restore(flags);\n\t\tgoto unlock;\n\t}\n\n\tblk_queue_chunk_sectors(q,\n\t\t\tlogical_to_sectors(sdkp->device, zone_blocks));\n\tblk_queue_max_zone_append_sectors(q,\n\t\t\tq->limits.max_segments << PAGE_SECTORS_SHIFT);\n\n\tret = blk_revalidate_disk_zones(disk, sd_zbc_revalidate_zones_cb);\n\n\tmemalloc_noio_restore(flags);\n\tkvfree(sdkp->rev_wp_offset);\n\tsdkp->rev_wp_offset = NULL;\n\n\tif (ret) {\n\t\tsdkp->zone_info = (struct zoned_disk_info){ };\n\t\tsdkp->capacity = 0;\n\t\tgoto unlock;\n\t}\n\n\tsd_zbc_print_zones(sdkp);\n\nunlock:\n\tmutex_unlock(&sdkp->rev_mutex);\n\n\treturn ret;\n}\n\n \nint sd_zbc_read_zones(struct scsi_disk *sdkp, u8 buf[SD_BUF_SIZE])\n{\n\tstruct gendisk *disk = sdkp->disk;\n\tstruct request_queue *q = disk->queue;\n\tunsigned int nr_zones;\n\tu32 zone_blocks = 0;\n\tint ret;\n\n\tif (!sd_is_zoned(sdkp)) {\n\t\t \n\t\tsd_zbc_free_zone_info(sdkp);\n\t\treturn 0;\n\t}\n\n\t \n\tsdkp->device->use_16_for_rw = 1;\n\tsdkp->device->use_10_for_rw = 0;\n\tsdkp->device->use_16_for_sync = 1;\n\n\tif (!blk_queue_is_zoned(q)) {\n\t\t \n\t\tsd_zbc_free_zone_info(sdkp);\n\t\treturn 0;\n\t}\n\n\t \n\tret = sd_zbc_check_zoned_characteristics(sdkp, buf);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = sd_zbc_check_capacity(sdkp, buf, &zone_blocks);\n\tif (ret != 0)\n\t\tgoto err;\n\n\t \n\tblk_queue_flag_set(QUEUE_FLAG_ZONE_RESETALL, q);\n\tblk_queue_required_elevator_features(q, ELEVATOR_F_ZBD_SEQ_WRITE);\n\tif (sdkp->zones_max_open == U32_MAX)\n\t\tdisk_set_max_open_zones(disk, 0);\n\telse\n\t\tdisk_set_max_open_zones(disk, sdkp->zones_max_open);\n\tdisk_set_max_active_zones(disk, 0);\n\tnr_zones = round_up(sdkp->capacity, zone_blocks) >> ilog2(zone_blocks);\n\n\tsdkp->early_zone_info.nr_zones = nr_zones;\n\tsdkp->early_zone_info.zone_blocks = zone_blocks;\n\n\treturn 0;\n\nerr:\n\tsdkp->capacity = 0;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}