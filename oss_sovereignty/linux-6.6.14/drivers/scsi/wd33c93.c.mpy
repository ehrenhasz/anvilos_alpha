{
  "module_name": "wd33c93.c",
  "hash_id": "e6447a6b801651e99c1ad01ed0e3853e132db17b92240fc03e7d61f39c24b292",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/wd33c93.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n\n#include <asm/irq.h>\n\n#include \"wd33c93.h\"\n\n#define optimum_sx_per(hostdata) (hostdata)->sx_table[1].period_ns\n\n\n#define WD33C93_VERSION    \"1.26++\"\n#define WD33C93_DATE       \"10/Feb/2007\"\n\nMODULE_AUTHOR(\"John Shifflett\");\nMODULE_DESCRIPTION(\"Generic WD33C93 SCSI driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n\n \nstatic char *setup_args[] = { \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" };\n\nstatic char *setup_strings;\nmodule_param(setup_strings, charp, 0);\n\nstatic void wd33c93_execute(struct Scsi_Host *instance);\n\nstatic inline uchar\nread_wd33c93(const wd33c93_regs regs, uchar reg_num)\n{\n\t*regs.SASR = reg_num;\n\tmb();\n\treturn (*regs.SCMD);\n}\n\nstatic unsigned long\nread_wd33c93_count(const wd33c93_regs regs)\n{\n\tunsigned long value;\n\n\t*regs.SASR = WD_TRANSFER_COUNT_MSB;\n\tmb();\n\tvalue = *regs.SCMD << 16;\n\tvalue |= *regs.SCMD << 8;\n\tvalue |= *regs.SCMD;\n\tmb();\n\treturn value;\n}\n\nstatic inline uchar\nread_aux_stat(const wd33c93_regs regs)\n{\n\treturn *regs.SASR;\n}\n\nstatic inline void\nwrite_wd33c93(const wd33c93_regs regs, uchar reg_num, uchar value)\n{\n\t*regs.SASR = reg_num;\n\tmb();\n\t*regs.SCMD = value;\n\tmb();\n}\n\nstatic void\nwrite_wd33c93_count(const wd33c93_regs regs, unsigned long value)\n{\n\t*regs.SASR = WD_TRANSFER_COUNT_MSB;\n\tmb();\n\t*regs.SCMD = value >> 16;\n\t*regs.SCMD = value >> 8;\n\t*regs.SCMD = value;\n\tmb();\n}\n\nstatic inline void\nwrite_wd33c93_cmd(const wd33c93_regs regs, uchar cmd)\n{\n\t*regs.SASR = WD_COMMAND;\n\tmb();\n\t*regs.SCMD = cmd;\n\tmb();\n}\n\nstatic inline void\nwrite_wd33c93_cdb(const wd33c93_regs regs, uint len, uchar cmnd[])\n{\n\tint i;\n\n\t*regs.SASR = WD_CDB_1;\n\tfor (i = 0; i < len; i++)\n\t\t*regs.SCMD = cmnd[i];\n}\n\nstatic inline uchar\nread_1_byte(const wd33c93_regs regs)\n{\n\tuchar asr;\n\tuchar x = 0;\n\n\twrite_wd33c93(regs, WD_CONTROL, CTRL_IDI | CTRL_EDI | CTRL_POLLED);\n\twrite_wd33c93_cmd(regs, WD_CMD_TRANS_INFO | 0x80);\n\tdo {\n\t\tasr = read_aux_stat(regs);\n\t\tif (asr & ASR_DBR)\n\t\t\tx = read_wd33c93(regs, WD_DATA);\n\t} while (!(asr & ASR_INT));\n\treturn x;\n}\n\nstatic int\nround_period(unsigned int period, const struct sx_period *sx_table)\n{\n\tint x;\n\n\tfor (x = 1; sx_table[x].period_ns; x++) {\n\t\tif ((period <= sx_table[x - 0].period_ns) &&\n\t\t    (period > sx_table[x - 1].period_ns)) {\n\t\t\treturn x;\n\t\t}\n\t}\n\treturn 7;\n}\n\n \nstatic uchar\ncalc_sync_xfer(unsigned int period, unsigned int offset, unsigned int fast,\n               const struct sx_period *sx_table)\n{\n\t \n\tuchar result;\n\n\tif (offset && fast) {\n\t\tfast = STR_FSS;\n\t\tperiod *= 2;\n\t} else {\n\t\tfast = 0;\n\t}\n\tperiod *= 4;\t\t \n\tresult = sx_table[round_period(period,sx_table)].reg_value;\n\tresult |= (offset < OPTIMUM_SX_OFF) ? offset : OPTIMUM_SX_OFF;\n\tresult |= fast;\n\treturn result;\n}\n\n \nstatic inline void\ncalc_sync_msg(unsigned int period, unsigned int offset, unsigned int fast,\n                uchar  msg[2])\n{\n\t \n\tperiod /= 4;\n\tif (offset && fast)\n\t\tperiod /= 2;\n\tmsg[0] = period;\n\tmsg[1] = offset;\n}\n\nstatic int wd33c93_queuecommand_lck(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_pointer *scsi_pointer = WD33C93_scsi_pointer(cmd);\n\tstruct WD33C93_hostdata *hostdata;\n\tstruct scsi_cmnd *tmp;\n\n\thostdata = (struct WD33C93_hostdata *) cmd->device->host->hostdata;\n\n\tDB(DB_QUEUE_COMMAND,\n\t   printk(\"Q-%d-%02x( \", cmd->device->id, cmd->cmnd[0]))\n\n \n\tcmd->host_scribble = NULL;\n\tcmd->result = 0;\n\n \n\n\tif (scsi_bufflen(cmd)) {\n\t\tscsi_pointer->buffer = scsi_sglist(cmd);\n\t\tscsi_pointer->buffers_residual = scsi_sg_count(cmd) - 1;\n\t\tscsi_pointer->ptr = sg_virt(scsi_pointer->buffer);\n\t\tscsi_pointer->this_residual = scsi_pointer->buffer->length;\n\t} else {\n\t\tscsi_pointer->buffer = NULL;\n\t\tscsi_pointer->buffers_residual = 0;\n\t\tscsi_pointer->ptr = NULL;\n\t\tscsi_pointer->this_residual = 0;\n\t}\n\n \n\n\tscsi_pointer->Status = ILLEGAL_STATUS_BYTE;\n\n\t \n\n\tspin_lock_irq(&hostdata->lock);\n\n\tif (!(hostdata->input_Q) || (cmd->cmnd[0] == REQUEST_SENSE)) {\n\t\tcmd->host_scribble = (uchar *) hostdata->input_Q;\n\t\thostdata->input_Q = cmd;\n\t} else {\t\t \n\t\tfor (tmp = (struct scsi_cmnd *) hostdata->input_Q;\n\t\t     tmp->host_scribble;\n\t\t     tmp = (struct scsi_cmnd *) tmp->host_scribble) ;\n\t\ttmp->host_scribble = (uchar *) cmd;\n\t}\n\n \n\n\twd33c93_execute(cmd->device->host);\n\n\tDB(DB_QUEUE_COMMAND, printk(\")Q \"))\n\n\tspin_unlock_irq(&hostdata->lock);\n\treturn 0;\n}\n\nDEF_SCSI_QCMD(wd33c93_queuecommand)\n\n \nstatic void\nwd33c93_execute(struct Scsi_Host *instance)\n{\n\tstruct scsi_pointer *scsi_pointer;\n\tstruct WD33C93_hostdata *hostdata =\n\t    (struct WD33C93_hostdata *) instance->hostdata;\n\tconst wd33c93_regs regs = hostdata->regs;\n\tstruct scsi_cmnd *cmd, *prev;\n\n\tDB(DB_EXECUTE, printk(\"EX(\"))\n\tif (hostdata->selecting || hostdata->connected) {\n\t\tDB(DB_EXECUTE, printk(\")EX-0 \"))\n\t\treturn;\n\t}\n\n\t \n\n\tcmd = (struct scsi_cmnd *) hostdata->input_Q;\n\tprev = NULL;\n\twhile (cmd) {\n\t\tif (!(hostdata->busy[cmd->device->id] &\n\t\t      (1 << (cmd->device->lun & 0xff))))\n\t\t\tbreak;\n\t\tprev = cmd;\n\t\tcmd = (struct scsi_cmnd *) cmd->host_scribble;\n\t}\n\n\t \n\n\tif (!cmd) {\n\t\tDB(DB_EXECUTE, printk(\")EX-1 \"))\n\t\treturn;\n\t}\n\n\t \n\n\tif (prev)\n\t\tprev->host_scribble = cmd->host_scribble;\n\telse\n\t\thostdata->input_Q = (struct scsi_cmnd *) cmd->host_scribble;\n\n#ifdef PROC_STATISTICS\n\thostdata->cmd_cnt[cmd->device->id]++;\n#endif\n\n\t \n\n\tif (cmd->sc_data_direction == DMA_TO_DEVICE)\n\t\twrite_wd33c93(regs, WD_DESTINATION_ID, cmd->device->id);\n\telse\n\t\twrite_wd33c93(regs, WD_DESTINATION_ID, cmd->device->id | DSTID_DPD);\n\n \n\n\tscsi_pointer = WD33C93_scsi_pointer(cmd);\n\tscsi_pointer->phase = 0;\t \n\tif (hostdata->disconnect == DIS_NEVER)\n\t\tgoto no;\n\tif (hostdata->disconnect == DIS_ALWAYS)\n\t\tgoto yes;\n\tif (cmd->device->type == 1)\t \n\t\tgoto yes;\n\tif (hostdata->disconnected_Q)\t \n\t\tgoto yes;\n\tif (!(hostdata->input_Q))\t \n\t\tgoto no;\n\tfor (prev = (struct scsi_cmnd *) hostdata->input_Q; prev;\n\t     prev = (struct scsi_cmnd *) prev->host_scribble) {\n\t\tif ((prev->device->id != cmd->device->id) ||\n\t\t    (prev->device->lun != cmd->device->lun)) {\n\t\t\tfor (prev = (struct scsi_cmnd *) hostdata->input_Q; prev;\n\t\t\t     prev = (struct scsi_cmnd *) prev->host_scribble)\n\t\t\t\tWD33C93_scsi_pointer(prev)->phase = 1;\n\t\t\tgoto yes;\n\t\t}\n\t}\n\n\tgoto no;\n\n yes:\n\tscsi_pointer->phase = 1;\n\n#ifdef PROC_STATISTICS\n\thostdata->disc_allowed_cnt[cmd->device->id]++;\n#endif\n\n no:\n\n\twrite_wd33c93(regs, WD_SOURCE_ID, scsi_pointer->phase ? SRCID_ER : 0);\n\n\twrite_wd33c93(regs, WD_TARGET_LUN, (u8)cmd->device->lun);\n\twrite_wd33c93(regs, WD_SYNCHRONOUS_TRANSFER,\n\t\t      hostdata->sync_xfer[cmd->device->id]);\n\thostdata->busy[cmd->device->id] |= (1 << (cmd->device->lun & 0xFF));\n\n\tif ((hostdata->level2 == L2_NONE) ||\n\t    (hostdata->sync_stat[cmd->device->id] == SS_UNSET)) {\n\n\t\t \n\n\t\thostdata->selecting = cmd;\n\n \n\t\tif (hostdata->sync_stat[cmd->device->id] == SS_UNSET)\n\t\t\thostdata->sync_stat[cmd->device->id] = SS_FIRST;\n\t\thostdata->state = S_SELECTING;\n\t\twrite_wd33c93_count(regs, 0);\t \n\t\twrite_wd33c93_cmd(regs, WD_CMD_SEL_ATN);\n\t} else {\n\n\t\t \n\n\t\thostdata->connected = cmd;\n\t\twrite_wd33c93(regs, WD_COMMAND_PHASE, 0);\n\n\t\t \n\n\t\twrite_wd33c93_cdb(regs, cmd->cmd_len, cmd->cmnd);\n\n\t\t \n\n\t\twrite_wd33c93(regs, WD_OWN_ID, cmd->cmd_len);\n\n\t\t \n\n\t\tif (scsi_pointer->phase == 0 && hostdata->no_dma == 0) {\n\t\t\tif (hostdata->dma_setup(cmd,\n\t\t\t    (cmd->sc_data_direction == DMA_TO_DEVICE) ?\n\t\t\t     DATA_OUT_DIR : DATA_IN_DIR))\n\t\t\t\twrite_wd33c93_count(regs, 0);\t \n\t\t\telse {\n\t\t\t\twrite_wd33c93_count(regs,\n\t\t\t\t\t\tscsi_pointer->this_residual);\n\t\t\t\twrite_wd33c93(regs, WD_CONTROL,\n\t\t\t\t\t      CTRL_IDI | CTRL_EDI | hostdata->dma_mode);\n\t\t\t\thostdata->dma = D_DMA_RUNNING;\n\t\t\t}\n\t\t} else\n\t\t\twrite_wd33c93_count(regs, 0);\t \n\n\t\thostdata->state = S_RUNNING_LEVEL2;\n\t\twrite_wd33c93_cmd(regs, WD_CMD_SEL_ATN_XFER);\n\t}\n\n\t \n\n\tDB(DB_EXECUTE,\n\t   printk(\"%s)EX-2 \", scsi_pointer->phase ? \"d:\" : \"\"))\n}\n\nstatic void\ntransfer_pio(const wd33c93_regs regs, uchar * buf, int cnt,\n\t     int data_in_dir, struct WD33C93_hostdata *hostdata)\n{\n\tuchar asr;\n\n\tDB(DB_TRANSFER,\n\t   printk(\"(%p,%d,%s:\", buf, cnt, data_in_dir ? \"in\" : \"out\"))\n\n\twrite_wd33c93(regs, WD_CONTROL, CTRL_IDI | CTRL_EDI | CTRL_POLLED);\n\twrite_wd33c93_count(regs, cnt);\n\twrite_wd33c93_cmd(regs, WD_CMD_TRANS_INFO);\n\tif (data_in_dir) {\n\t\tdo {\n\t\t\tasr = read_aux_stat(regs);\n\t\t\tif (asr & ASR_DBR)\n\t\t\t\t*buf++ = read_wd33c93(regs, WD_DATA);\n\t\t} while (!(asr & ASR_INT));\n\t} else {\n\t\tdo {\n\t\t\tasr = read_aux_stat(regs);\n\t\t\tif (asr & ASR_DBR)\n\t\t\t\twrite_wd33c93(regs, WD_DATA, *buf++);\n\t\t} while (!(asr & ASR_INT));\n\t}\n\n\t \n\n}\n\nstatic void\ntransfer_bytes(const wd33c93_regs regs, struct scsi_cmnd *cmd,\n\t\tint data_in_dir)\n{\n\tstruct scsi_pointer *scsi_pointer = WD33C93_scsi_pointer(cmd);\n\tstruct WD33C93_hostdata *hostdata;\n\tunsigned long length;\n\n\thostdata = (struct WD33C93_hostdata *) cmd->device->host->hostdata;\n\n \n\tif (!scsi_pointer->this_residual && scsi_pointer->buffers_residual) {\n\t\tscsi_pointer->buffer = sg_next(scsi_pointer->buffer);\n\t\t--scsi_pointer->buffers_residual;\n\t\tscsi_pointer->this_residual = scsi_pointer->buffer->length;\n\t\tscsi_pointer->ptr = sg_virt(scsi_pointer->buffer);\n\t}\n\tif (!scsi_pointer->this_residual)  \n\t\treturn;\n\n\twrite_wd33c93(regs, WD_SYNCHRONOUS_TRANSFER,\n\t\t      hostdata->sync_xfer[cmd->device->id]);\n\n \n\n\tif (hostdata->no_dma || hostdata->dma_setup(cmd, data_in_dir)) {\n#ifdef PROC_STATISTICS\n\t\thostdata->pio_cnt++;\n#endif\n\t\ttransfer_pio(regs, (uchar *) scsi_pointer->ptr,\n\t\t\t     scsi_pointer->this_residual, data_in_dir,\n\t\t\t     hostdata);\n\t\tlength = scsi_pointer->this_residual;\n\t\tscsi_pointer->this_residual = read_wd33c93_count(regs);\n\t\tscsi_pointer->ptr += length - scsi_pointer->this_residual;\n\t}\n\n \n\n\telse {\n#ifdef PROC_STATISTICS\n\t\thostdata->dma_cnt++;\n#endif\n\t\twrite_wd33c93(regs, WD_CONTROL, CTRL_IDI | CTRL_EDI | hostdata->dma_mode);\n\t\twrite_wd33c93_count(regs, scsi_pointer->this_residual);\n\n\t\tif ((hostdata->level2 >= L2_DATA) ||\n\t\t    (hostdata->level2 == L2_BASIC && scsi_pointer->phase == 0)) {\n\t\t\twrite_wd33c93(regs, WD_COMMAND_PHASE, 0x45);\n\t\t\twrite_wd33c93_cmd(regs, WD_CMD_SEL_ATN_XFER);\n\t\t\thostdata->state = S_RUNNING_LEVEL2;\n\t\t} else\n\t\t\twrite_wd33c93_cmd(regs, WD_CMD_TRANS_INFO);\n\n\t\thostdata->dma = D_DMA_RUNNING;\n\t}\n}\n\nvoid\nwd33c93_intr(struct Scsi_Host *instance)\n{\n\tstruct scsi_pointer *scsi_pointer;\n\tstruct WD33C93_hostdata *hostdata =\n\t    (struct WD33C93_hostdata *) instance->hostdata;\n\tconst wd33c93_regs regs = hostdata->regs;\n\tstruct scsi_cmnd *patch, *cmd;\n\tuchar asr, sr, phs, id, lun, *ucp, msg;\n\tunsigned long length, flags;\n\n\tasr = read_aux_stat(regs);\n\tif (!(asr & ASR_INT) || (asr & ASR_BSY))\n\t\treturn;\n\n\tspin_lock_irqsave(&hostdata->lock, flags);\n\n#ifdef PROC_STATISTICS\n\thostdata->int_cnt++;\n#endif\n\n\tcmd = (struct scsi_cmnd *) hostdata->connected;\t \n\tscsi_pointer = WD33C93_scsi_pointer(cmd);\n\tsr = read_wd33c93(regs, WD_SCSI_STATUS);\t \n\tphs = read_wd33c93(regs, WD_COMMAND_PHASE);\n\n\tDB(DB_INTR, printk(\"{%02x:%02x-\", asr, sr))\n\n \n\t    if (hostdata->dma == D_DMA_RUNNING) {\n\t\tDB(DB_TRANSFER,\n\t\t   printk(\"[%p/%d:\", scsi_pointer->ptr, scsi_pointer->this_residual))\n\t\t    hostdata->dma_stop(cmd->device->host, cmd, 1);\n\t\thostdata->dma = D_DMA_OFF;\n\t\tlength = scsi_pointer->this_residual;\n\t\tscsi_pointer->this_residual = read_wd33c93_count(regs);\n\t\tscsi_pointer->ptr += length - scsi_pointer->this_residual;\n\t\tDB(DB_TRANSFER,\n\t\t   printk(\"%p/%d]\", scsi_pointer->ptr, scsi_pointer->this_residual))\n\t}\n\n \n\tswitch (sr) {\n\tcase CSR_TIMEOUT:\n\t\tDB(DB_INTR, printk(\"TIMEOUT\"))\n\n\t\t    if (hostdata->state == S_RUNNING_LEVEL2)\n\t\t\thostdata->connected = NULL;\n\t\telse {\n\t\t\tcmd = (struct scsi_cmnd *) hostdata->selecting;\t \n\t\t\thostdata->selecting = NULL;\n\t\t}\n\n\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\thostdata->busy[cmd->device->id] &= ~(1 << (cmd->device->lun & 0xff));\n\t\thostdata->state = S_UNCONNECTED;\n\t\tscsi_done(cmd);\n\n\t\t \n\n\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\n \n\n\t\twd33c93_execute(instance);\n\t\tbreak;\n\n \n\n\tcase CSR_SELECT:\n\t\tDB(DB_INTR, printk(\"SELECT\"))\n\t\t    hostdata->connected = cmd =\n\t\t    (struct scsi_cmnd *) hostdata->selecting;\n\t\thostdata->selecting = NULL;\n\n\t\t \n\n\t\thostdata->outgoing_msg[0] = IDENTIFY(0, cmd->device->lun);\n\t\tif (scsi_pointer->phase)\n\t\t\thostdata->outgoing_msg[0] |= 0x40;\n\n\t\tif (hostdata->sync_stat[cmd->device->id] == SS_FIRST) {\n\n\t\t\thostdata->sync_stat[cmd->device->id] = SS_WAITING;\n\n \n\n\t\t\thostdata->outgoing_msg[1] = EXTENDED_MESSAGE;\n\t\t\thostdata->outgoing_msg[2] = 3;\n\t\t\thostdata->outgoing_msg[3] = EXTENDED_SDTR;\n\t\t\tif (hostdata->no_sync & (1 << cmd->device->id)) {\n\t\t\t\tcalc_sync_msg(hostdata->default_sx_per, 0,\n\t\t\t\t\t\t0, hostdata->outgoing_msg + 4);\n\t\t\t} else {\n\t\t\t\tcalc_sync_msg(optimum_sx_per(hostdata),\n\t\t\t\t\t\tOPTIMUM_SX_OFF,\n\t\t\t\t\t\thostdata->fast,\n\t\t\t\t\t\thostdata->outgoing_msg + 4);\n\t\t\t}\n\t\t\thostdata->outgoing_len = 6;\n#ifdef SYNC_DEBUG\n\t\t\tucp = hostdata->outgoing_msg + 1;\n\t\t\tprintk(\" sending SDTR %02x03%02x%02x%02x \",\n\t\t\t\tucp[0], ucp[2], ucp[3], ucp[4]);\n#endif\n\t\t} else\n\t\t\thostdata->outgoing_len = 1;\n\n\t\thostdata->state = S_CONNECTED;\n\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\t\tbreak;\n\n\tcase CSR_XFER_DONE | PHS_DATA_IN:\n\tcase CSR_UNEXP | PHS_DATA_IN:\n\tcase CSR_SRV_REQ | PHS_DATA_IN:\n\t\tDB(DB_INTR,\n\t\t   printk(\"IN-%d.%d\", scsi_pointer->this_residual,\n\t\t\t  scsi_pointer->buffers_residual))\n\t\t    transfer_bytes(regs, cmd, DATA_IN_DIR);\n\t\tif (hostdata->state != S_RUNNING_LEVEL2)\n\t\t\thostdata->state = S_CONNECTED;\n\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\t\tbreak;\n\n\tcase CSR_XFER_DONE | PHS_DATA_OUT:\n\tcase CSR_UNEXP | PHS_DATA_OUT:\n\tcase CSR_SRV_REQ | PHS_DATA_OUT:\n\t\tDB(DB_INTR,\n\t\t   printk(\"OUT-%d.%d\", scsi_pointer->this_residual,\n\t\t\t  scsi_pointer->buffers_residual))\n\t\t    transfer_bytes(regs, cmd, DATA_OUT_DIR);\n\t\tif (hostdata->state != S_RUNNING_LEVEL2)\n\t\t\thostdata->state = S_CONNECTED;\n\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\t\tbreak;\n\n \n\n\tcase CSR_XFER_DONE | PHS_COMMAND:\n\tcase CSR_UNEXP | PHS_COMMAND:\n\tcase CSR_SRV_REQ | PHS_COMMAND:\n\t\tDB(DB_INTR, printk(\"CMND-%02x\", cmd->cmnd[0]))\n\t\t    transfer_pio(regs, cmd->cmnd, cmd->cmd_len, DATA_OUT_DIR,\n\t\t\t\t hostdata);\n\t\thostdata->state = S_CONNECTED;\n\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\t\tbreak;\n\n\tcase CSR_XFER_DONE | PHS_STATUS:\n\tcase CSR_UNEXP | PHS_STATUS:\n\tcase CSR_SRV_REQ | PHS_STATUS:\n\t\tDB(DB_INTR, printk(\"STATUS=\"))\n\t\tscsi_pointer->Status = read_1_byte(regs);\n\t\tDB(DB_INTR, printk(\"%02x\", scsi_pointer->Status))\n\t\t    if (hostdata->level2 >= L2_BASIC) {\n\t\t\tsr = read_wd33c93(regs, WD_SCSI_STATUS);\t \n\t\t\tudelay(7);\n\t\t\thostdata->state = S_RUNNING_LEVEL2;\n\t\t\twrite_wd33c93(regs, WD_COMMAND_PHASE, 0x50);\n\t\t\twrite_wd33c93_cmd(regs, WD_CMD_SEL_ATN_XFER);\n\t\t} else {\n\t\t\thostdata->state = S_CONNECTED;\n\t\t}\n\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\t\tbreak;\n\n\tcase CSR_XFER_DONE | PHS_MESS_IN:\n\tcase CSR_UNEXP | PHS_MESS_IN:\n\tcase CSR_SRV_REQ | PHS_MESS_IN:\n\t\tDB(DB_INTR, printk(\"MSG_IN=\"))\n\n\t\tmsg = read_1_byte(regs);\n\t\tsr = read_wd33c93(regs, WD_SCSI_STATUS);\t \n\t\tudelay(7);\n\n\t\thostdata->incoming_msg[hostdata->incoming_ptr] = msg;\n\t\tif (hostdata->incoming_msg[0] == EXTENDED_MESSAGE)\n\t\t\tmsg = EXTENDED_MESSAGE;\n\t\telse\n\t\t\thostdata->incoming_ptr = 0;\n\n\t\tscsi_pointer->Message = msg;\n\t\tswitch (msg) {\n\n\t\tcase COMMAND_COMPLETE:\n\t\t\tDB(DB_INTR, printk(\"CCMP\"))\n\t\t\t    write_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\n\t\t\thostdata->state = S_PRE_CMP_DISC;\n\t\t\tbreak;\n\n\t\tcase SAVE_POINTERS:\n\t\t\tDB(DB_INTR, printk(\"SDP\"))\n\t\t\t    write_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\n\t\t\thostdata->state = S_CONNECTED;\n\t\t\tbreak;\n\n\t\tcase RESTORE_POINTERS:\n\t\t\tDB(DB_INTR, printk(\"RDP\"))\n\t\t\t    if (hostdata->level2 >= L2_BASIC) {\n\t\t\t\twrite_wd33c93(regs, WD_COMMAND_PHASE, 0x45);\n\t\t\t\twrite_wd33c93_cmd(regs, WD_CMD_SEL_ATN_XFER);\n\t\t\t\thostdata->state = S_RUNNING_LEVEL2;\n\t\t\t} else {\n\t\t\t\twrite_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\n\t\t\t\thostdata->state = S_CONNECTED;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DISCONNECT:\n\t\t\tDB(DB_INTR, printk(\"DIS\"))\n\t\t\t    cmd->device->disconnect = 1;\n\t\t\twrite_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\n\t\t\thostdata->state = S_PRE_TMP_DISC;\n\t\t\tbreak;\n\n\t\tcase MESSAGE_REJECT:\n\t\t\tDB(DB_INTR, printk(\"REJ\"))\n#ifdef SYNC_DEBUG\n\t\t\t    printk(\"-REJ-\");\n#endif\n\t\t\tif (hostdata->sync_stat[cmd->device->id] == SS_WAITING) {\n\t\t\t\thostdata->sync_stat[cmd->device->id] = SS_SET;\n\t\t\t\t \n\t\t\t\thostdata->sync_xfer[cmd->device->id] =\n\t\t\t\t\tcalc_sync_xfer(hostdata->default_sx_per\n\t\t\t\t\t\t/ 4, 0, 0, hostdata->sx_table);\n\t\t\t}\n\t\t\twrite_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\n\t\t\thostdata->state = S_CONNECTED;\n\t\t\tbreak;\n\n\t\tcase EXTENDED_MESSAGE:\n\t\t\tDB(DB_INTR, printk(\"EXT\"))\n\n\t\t\t    ucp = hostdata->incoming_msg;\n\n#ifdef SYNC_DEBUG\n\t\t\tprintk(\"%02x\", ucp[hostdata->incoming_ptr]);\n#endif\n\t\t\t \n\n\t\t\tif ((hostdata->incoming_ptr >= 2) &&\n\t\t\t    (hostdata->incoming_ptr == (ucp[1] + 1))) {\n\n\t\t\t\tswitch (ucp[2]) {\t \n\t\t\t\tcase EXTENDED_SDTR:\n\t\t\t\t\t \n\t\t\t\t\tid = calc_sync_xfer(hostdata->\n\t\t\t\t\t\t\tdefault_sx_per / 4, 0,\n\t\t\t\t\t\t\t0, hostdata->sx_table);\n\t\t\t\t\tif (hostdata->sync_stat[cmd->device->id] !=\n\t\t\t\t\t    SS_WAITING) {\n\n \n\n\t\t\t\t\t\twrite_wd33c93_cmd(regs, WD_CMD_ASSERT_ATN);\t \n\t\t\t\t\t\thostdata->outgoing_msg[0] =\n\t\t\t\t\t\t    EXTENDED_MESSAGE;\n\t\t\t\t\t\thostdata->outgoing_msg[1] = 3;\n\t\t\t\t\t\thostdata->outgoing_msg[2] =\n\t\t\t\t\t\t    EXTENDED_SDTR;\n\t\t\t\t\t\tcalc_sync_msg(hostdata->\n\t\t\t\t\t\t\tdefault_sx_per, 0,\n\t\t\t\t\t\t\t0, hostdata->outgoing_msg + 3);\n\t\t\t\t\t\thostdata->outgoing_len = 5;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ucp[4])  \n\t\t\t\t\t\t\tid = calc_sync_xfer(ucp[3], ucp[4],\n\t\t\t\t\t\t\t\t\thostdata->fast,\n\t\t\t\t\t\t\t\t\thostdata->sx_table);\n\t\t\t\t\t\telse if (ucp[3])  \n\t\t\t\t\t\t\tid = calc_sync_xfer(ucp[3], ucp[4],\n\t\t\t\t\t\t\t\t\t0, hostdata->sx_table);\n\t\t\t\t\t}\n\t\t\t\t\thostdata->sync_xfer[cmd->device->id] = id;\n#ifdef SYNC_DEBUG\n\t\t\t\t\tprintk(\" sync_xfer=%02x\\n\",\n\t\t\t\t\t       hostdata->sync_xfer[cmd->device->id]);\n#endif\n\t\t\t\t\thostdata->sync_stat[cmd->device->id] =\n\t\t\t\t\t    SS_SET;\n\t\t\t\t\twrite_wd33c93_cmd(regs,\n\t\t\t\t\t\t\t  WD_CMD_NEGATE_ACK);\n\t\t\t\t\thostdata->state = S_CONNECTED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase EXTENDED_WDTR:\n\t\t\t\t\twrite_wd33c93_cmd(regs, WD_CMD_ASSERT_ATN);\t \n\t\t\t\t\tprintk(\"sending WDTR \");\n\t\t\t\t\thostdata->outgoing_msg[0] =\n\t\t\t\t\t    EXTENDED_MESSAGE;\n\t\t\t\t\thostdata->outgoing_msg[1] = 2;\n\t\t\t\t\thostdata->outgoing_msg[2] =\n\t\t\t\t\t    EXTENDED_WDTR;\n\t\t\t\t\thostdata->outgoing_msg[3] = 0;\t \n\t\t\t\t\thostdata->outgoing_len = 4;\n\t\t\t\t\twrite_wd33c93_cmd(regs,\n\t\t\t\t\t\t\t  WD_CMD_NEGATE_ACK);\n\t\t\t\t\thostdata->state = S_CONNECTED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twrite_wd33c93_cmd(regs, WD_CMD_ASSERT_ATN);\t \n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"Rejecting Unknown Extended Message(%02x). \",\n\t\t\t\t\t     ucp[2]);\n\t\t\t\t\thostdata->outgoing_msg[0] =\n\t\t\t\t\t    MESSAGE_REJECT;\n\t\t\t\t\thostdata->outgoing_len = 1;\n\t\t\t\t\twrite_wd33c93_cmd(regs,\n\t\t\t\t\t\t\t  WD_CMD_NEGATE_ACK);\n\t\t\t\t\thostdata->state = S_CONNECTED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\thostdata->incoming_ptr = 0;\n\t\t\t}\n\n\t\t\t \n\n\t\t\telse {\n\t\t\t\thostdata->incoming_ptr++;\n\t\t\t\twrite_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\n\t\t\t\thostdata->state = S_CONNECTED;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(\"Rejecting Unknown Message(%02x) \", msg);\n\t\t\twrite_wd33c93_cmd(regs, WD_CMD_ASSERT_ATN);\t \n\t\t\thostdata->outgoing_msg[0] = MESSAGE_REJECT;\n\t\t\thostdata->outgoing_len = 1;\n\t\t\twrite_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\n\t\t\thostdata->state = S_CONNECTED;\n\t\t}\n\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\t\tbreak;\n\n \n\n\tcase CSR_SEL_XFER_DONE:\n\n \n\n\t\twrite_wd33c93(regs, WD_SOURCE_ID, SRCID_ER);\n\t\tif (phs == 0x60) {\n\t\t\tDB(DB_INTR, printk(\"SX-DONE\"))\n\t\t\t    scsi_pointer->Message = COMMAND_COMPLETE;\n\t\t\tlun = read_wd33c93(regs, WD_TARGET_LUN);\n\t\t\tDB(DB_INTR, printk(\":%d.%d\", scsi_pointer->Status, lun))\n\t\t\t    hostdata->connected = NULL;\n\t\t\thostdata->busy[cmd->device->id] &= ~(1 << (cmd->device->lun & 0xff));\n\t\t\thostdata->state = S_UNCONNECTED;\n\t\t\tif (scsi_pointer->Status == ILLEGAL_STATUS_BYTE)\n\t\t\t\tscsi_pointer->Status = lun;\n\t\t\tif (cmd->cmnd[0] == REQUEST_SENSE\n\t\t\t    && scsi_pointer->Status != SAM_STAT_GOOD) {\n\t\t\t\tset_host_byte(cmd, DID_ERROR);\n\t\t\t} else {\n\t\t\t\tset_host_byte(cmd, DID_OK);\n\t\t\t\tscsi_msg_to_host_byte(cmd, scsi_pointer->Message);\n\t\t\t\tset_status_byte(cmd, scsi_pointer->Status);\n\t\t\t}\n\t\t\tscsi_done(cmd);\n\n \n\t\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\t\t\twd33c93_execute(instance);\n\t\t} else {\n\t\t\tprintk\n\t\t\t    (\"%02x:%02x:%02x: Unknown SEL_XFER_DONE phase!!---\",\n\t\t\t     asr, sr, phs);\n\t\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\t\t}\n\t\tbreak;\n\n \n\n\tcase CSR_SDP:\n\t\tDB(DB_INTR, printk(\"SDP\"))\n\t\t    hostdata->state = S_RUNNING_LEVEL2;\n\t\twrite_wd33c93(regs, WD_COMMAND_PHASE, 0x41);\n\t\twrite_wd33c93_cmd(regs, WD_CMD_SEL_ATN_XFER);\n\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\t\tbreak;\n\n\tcase CSR_XFER_DONE | PHS_MESS_OUT:\n\tcase CSR_UNEXP | PHS_MESS_OUT:\n\tcase CSR_SRV_REQ | PHS_MESS_OUT:\n\t\tDB(DB_INTR, printk(\"MSG_OUT=\"))\n\n \n\t\t    if (hostdata->outgoing_len == 0) {\n\t\t\thostdata->outgoing_len = 1;\n\t\t\thostdata->outgoing_msg[0] = NOP;\n\t\t}\n\t\ttransfer_pio(regs, hostdata->outgoing_msg,\n\t\t\t     hostdata->outgoing_len, DATA_OUT_DIR, hostdata);\n\t\tDB(DB_INTR, printk(\"%02x\", hostdata->outgoing_msg[0]))\n\t\t    hostdata->outgoing_len = 0;\n\t\thostdata->state = S_CONNECTED;\n\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\t\tbreak;\n\n\tcase CSR_UNEXP_DISC:\n\n \n\n \n\n\t\twrite_wd33c93(regs, WD_SOURCE_ID, SRCID_ER);\n\t\tif (cmd == NULL) {\n\t\t\tprintk(\" - Already disconnected! \");\n\t\t\thostdata->state = S_UNCONNECTED;\n\t\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\t\t\treturn;\n\t\t}\n\t\tDB(DB_INTR, printk(\"UNEXP_DISC\"))\n\t\t    hostdata->connected = NULL;\n\t\thostdata->busy[cmd->device->id] &= ~(1 << (cmd->device->lun & 0xff));\n\t\thostdata->state = S_UNCONNECTED;\n\t\tif (cmd->cmnd[0] == REQUEST_SENSE &&\n\t\t    scsi_pointer->Status != SAM_STAT_GOOD) {\n\t\t\tset_host_byte(cmd, DID_ERROR);\n\t\t} else {\n\t\t\tset_host_byte(cmd, DID_OK);\n\t\t\tscsi_msg_to_host_byte(cmd, scsi_pointer->Message);\n\t\t\tset_status_byte(cmd, scsi_pointer->Status);\n\t\t}\n\t\tscsi_done(cmd);\n\n \n\t\t \n\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\t\twd33c93_execute(instance);\n\t\tbreak;\n\n\tcase CSR_DISC:\n\n \n\n\t\twrite_wd33c93(regs, WD_SOURCE_ID, SRCID_ER);\n\t\tDB(DB_INTR, printk(\"DISC\"))\n\t\t    if (cmd == NULL) {\n\t\t\tprintk(\" - Already disconnected! \");\n\t\t\thostdata->state = S_UNCONNECTED;\n\t\t}\n\t\tswitch (hostdata->state) {\n\t\tcase S_PRE_CMP_DISC:\n\t\t\thostdata->connected = NULL;\n\t\t\thostdata->busy[cmd->device->id] &= ~(1 << (cmd->device->lun & 0xff));\n\t\t\thostdata->state = S_UNCONNECTED;\n\t\t\tDB(DB_INTR, printk(\":%d\", scsi_pointer->Status))\n\t\t\tif (cmd->cmnd[0] == REQUEST_SENSE\n\t\t\t    && scsi_pointer->Status != SAM_STAT_GOOD) {\n\t\t\t\tset_host_byte(cmd, DID_ERROR);\n\t\t\t} else {\n\t\t\t\tset_host_byte(cmd, DID_OK);\n\t\t\t\tscsi_msg_to_host_byte(cmd, scsi_pointer->Message);\n\t\t\t\tset_status_byte(cmd, scsi_pointer->Status);\n\t\t\t}\n\t\t\tscsi_done(cmd);\n\t\t\tbreak;\n\t\tcase S_PRE_TMP_DISC:\n\t\tcase S_RUNNING_LEVEL2:\n\t\t\tcmd->host_scribble = (uchar *) hostdata->disconnected_Q;\n\t\t\thostdata->disconnected_Q = cmd;\n\t\t\thostdata->connected = NULL;\n\t\t\thostdata->state = S_UNCONNECTED;\n\n#ifdef PROC_STATISTICS\n\t\t\thostdata->disc_done_cnt[cmd->device->id]++;\n#endif\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"*** Unexpected DISCONNECT interrupt! ***\");\n\t\t\thostdata->state = S_UNCONNECTED;\n\t\t}\n\n \n\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\t\twd33c93_execute(instance);\n\t\tbreak;\n\n\tcase CSR_RESEL_AM:\n\tcase CSR_RESEL:\n\t\tDB(DB_INTR, printk(\"RESEL%s\", sr == CSR_RESEL_AM ? \"_AM\" : \"\"))\n\n\t\t     \n\t\t    if (hostdata->level2 <= L2_NONE) {\n\n\t\t\tif (hostdata->selecting) {\n\t\t\t\tcmd = (struct scsi_cmnd *) hostdata->selecting;\n\t\t\t\thostdata->selecting = NULL;\n\t\t\t\thostdata->busy[cmd->device->id] &= ~(1 << (cmd->device->lun & 0xff));\n\t\t\t\tcmd->host_scribble =\n\t\t\t\t    (uchar *) hostdata->input_Q;\n\t\t\t\thostdata->input_Q = cmd;\n\t\t\t}\n\t\t}\n\n\t\telse {\n\n\t\t\tif (cmd) {\n\t\t\t\tif (phs == 0x00) {\n\t\t\t\t\thostdata->busy[cmd->device->id] &=\n\t\t\t\t\t\t~(1 << (cmd->device->lun & 0xff));\n\t\t\t\t\tcmd->host_scribble =\n\t\t\t\t\t    (uchar *) hostdata->input_Q;\n\t\t\t\t\thostdata->input_Q = cmd;\n\t\t\t\t} else {\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"---%02x:%02x:%02x-TROUBLE: Intrusive ReSelect!---\",\n\t\t\t\t\t     asr, sr, phs);\n\t\t\t\t\twhile (1)\n\t\t\t\t\t\tprintk(\"\\r\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t \n\n\t\tid = read_wd33c93(regs, WD_SOURCE_ID);\n\t\tid &= SRCID_MASK;\n\n\t\t \n\n\t\tif (sr == CSR_RESEL_AM) {\n\t\t\tlun = read_wd33c93(regs, WD_DATA);\n\t\t\tif (hostdata->level2 < L2_RESELECT)\n\t\t\t\twrite_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\n\t\t\tlun &= 7;\n\t\t} else {\n\t\t\t \n\t\t\tfor (lun = 255; lun; lun--) {\n\t\t\t\tif ((asr = read_aux_stat(regs)) & ASR_INT)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(10);\n\t\t\t}\n\t\t\tif (!(asr & ASR_INT)) {\n\t\t\t\tprintk\n\t\t\t\t    (\"wd33c93: Reselected without IDENTIFY\\n\");\n\t\t\t\tlun = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsr = read_wd33c93(regs, WD_SCSI_STATUS);\n\t\t\t\tudelay(7);\n\t\t\t\tif (sr == (CSR_ABORT | PHS_MESS_IN) ||\n\t\t\t\t    sr == (CSR_UNEXP | PHS_MESS_IN) ||\n\t\t\t\t    sr == (CSR_SRV_REQ | PHS_MESS_IN)) {\n\t\t\t\t\t \n\t\t\t\t\tlun = read_1_byte(regs);\n\t\t\t\t\t \n\t\t\t\t\tasr = read_aux_stat(regs);\n\t\t\t\t\tif (!(asr & ASR_INT)) {\n\t\t\t\t\t\tudelay(10);\n\t\t\t\t\t\tasr = read_aux_stat(regs);\n\t\t\t\t\t\tif (!(asr & ASR_INT))\n\t\t\t\t\t\t\tprintk\n\t\t\t\t\t\t\t    (\"wd33c93: No int after LUN on RESEL (%02x)\\n\",\n\t\t\t\t\t\t\t     asr);\n\t\t\t\t\t}\n\t\t\t\t\tsr = read_wd33c93(regs, WD_SCSI_STATUS);\n\t\t\t\t\tudelay(7);\n\t\t\t\t\tif (sr != CSR_MSGIN)\n\t\t\t\t\t\tprintk\n\t\t\t\t\t\t    (\"wd33c93: Not paused with ACK on RESEL (%02x)\\n\",\n\t\t\t\t\t\t     sr);\n\t\t\t\t\tlun &= 7;\n\t\t\t\t\twrite_wd33c93_cmd(regs,\n\t\t\t\t\t\t\t  WD_CMD_NEGATE_ACK);\n\t\t\t\t} else {\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"wd33c93: Not MSG_IN on reselect (%02x)\\n\",\n\t\t\t\t\t     sr);\n\t\t\t\t\tlun = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tcmd = (struct scsi_cmnd *) hostdata->disconnected_Q;\n\t\tpatch = NULL;\n\t\twhile (cmd) {\n\t\t\tif (id == cmd->device->id && lun == (u8)cmd->device->lun)\n\t\t\t\tbreak;\n\t\t\tpatch = cmd;\n\t\t\tcmd = (struct scsi_cmnd *) cmd->host_scribble;\n\t\t}\n\n\t\t \n\n\t\tif (!cmd) {\n\t\t\tprintk\n\t\t\t    (\"---TROUBLE: target %d.%d not in disconnect queue---\",\n\t\t\t     id, (u8)lun);\n\t\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\n\t\tif (patch)\n\t\t\tpatch->host_scribble = cmd->host_scribble;\n\t\telse\n\t\t\thostdata->disconnected_Q =\n\t\t\t    (struct scsi_cmnd *) cmd->host_scribble;\n\t\thostdata->connected = cmd;\n\n\t\t \n\n\t\tif (cmd->sc_data_direction == DMA_TO_DEVICE)\n\t\t\twrite_wd33c93(regs, WD_DESTINATION_ID, cmd->device->id);\n\t\telse\n\t\t\twrite_wd33c93(regs, WD_DESTINATION_ID,\n\t\t\t\t      cmd->device->id | DSTID_DPD);\n\t\tif (hostdata->level2 >= L2_RESELECT) {\n\t\t\twrite_wd33c93_count(regs, 0);\t \n\t\t\twrite_wd33c93(regs, WD_COMMAND_PHASE, 0x45);\n\t\t\twrite_wd33c93_cmd(regs, WD_CMD_SEL_ATN_XFER);\n\t\t\thostdata->state = S_RUNNING_LEVEL2;\n\t\t} else\n\t\t\thostdata->state = S_CONNECTED;\n\n\t\t    spin_unlock_irqrestore(&hostdata->lock, flags);\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(\"--UNKNOWN INTERRUPT:%02x:%02x:%02x--\", asr, sr, phs);\n\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\t}\n\n\tDB(DB_INTR, printk(\"} \"))\n\n}\n\nstatic void\nreset_wd33c93(struct Scsi_Host *instance)\n{\n\tstruct WD33C93_hostdata *hostdata =\n\t    (struct WD33C93_hostdata *) instance->hostdata;\n\tconst wd33c93_regs regs = hostdata->regs;\n\tuchar sr;\n\n#ifdef CONFIG_SGI_IP22\n\t{\n\t\tint busycount = 0;\n\t\textern void sgiwd93_reset(unsigned long);\n\t\t \n\t\twhile ((read_aux_stat(regs) & ASR_BSY) && busycount++ < 100)\n\t\t\tudelay (10);\n\t \n\t \n\tif (read_aux_stat(regs) & ASR_BSY)\n\t\tsgiwd93_reset(instance->base);  \n\t}\n#endif\n\n\twrite_wd33c93(regs, WD_OWN_ID, OWNID_EAF | OWNID_RAF |\n\t\t      instance->this_id | hostdata->clock_freq);\n\twrite_wd33c93(regs, WD_CONTROL, CTRL_IDI | CTRL_EDI | CTRL_POLLED);\n\twrite_wd33c93(regs, WD_SYNCHRONOUS_TRANSFER,\n\t\t      calc_sync_xfer(hostdata->default_sx_per / 4,\n\t\t\t\t     DEFAULT_SX_OFF, 0, hostdata->sx_table));\n\twrite_wd33c93(regs, WD_COMMAND, WD_CMD_RESET);\n\n\n#ifdef CONFIG_MVME147_SCSI\n\tudelay(25);\t\t \n#endif\n\n\twhile (!(read_aux_stat(regs) & ASR_INT))\n\t\t;\n\tsr = read_wd33c93(regs, WD_SCSI_STATUS);\n\n\thostdata->microcode = read_wd33c93(regs, WD_CDB_1);\n\tif (sr == 0x00)\n\t\thostdata->chip = C_WD33C93;\n\telse if (sr == 0x01) {\n\t\twrite_wd33c93(regs, WD_QUEUE_TAG, 0xa5);\t \n\t\tsr = read_wd33c93(regs, WD_QUEUE_TAG);\n\t\tif (sr == 0xa5) {\n\t\t\thostdata->chip = C_WD33C93B;\n\t\t\twrite_wd33c93(regs, WD_QUEUE_TAG, 0);\n\t\t} else\n\t\t\thostdata->chip = C_WD33C93A;\n\t} else\n\t\thostdata->chip = C_UNKNOWN_CHIP;\n\n\tif (hostdata->chip != C_WD33C93B)\t \n\t\thostdata->fast = 0;\n\n\twrite_wd33c93(regs, WD_TIMEOUT_PERIOD, TIMEOUT_PERIOD_VALUE);\n\twrite_wd33c93(regs, WD_CONTROL, CTRL_IDI | CTRL_EDI | CTRL_POLLED);\n}\n\nint\nwd33c93_host_reset(struct scsi_cmnd * SCpnt)\n{\n\tstruct Scsi_Host *instance;\n\tstruct WD33C93_hostdata *hostdata;\n\tint i;\n\n\tinstance = SCpnt->device->host;\n\tspin_lock_irq(instance->host_lock);\n\thostdata = (struct WD33C93_hostdata *) instance->hostdata;\n\n\tprintk(\"scsi%d: reset. \", instance->host_no);\n\tdisable_irq(instance->irq);\n\n\thostdata->dma_stop(instance, NULL, 0);\n\tfor (i = 0; i < 8; i++) {\n\t\thostdata->busy[i] = 0;\n\t\thostdata->sync_xfer[i] =\n\t\t\tcalc_sync_xfer(DEFAULT_SX_PER / 4, DEFAULT_SX_OFF,\n\t\t\t\t\t0, hostdata->sx_table);\n\t\thostdata->sync_stat[i] = SS_UNSET;\t \n\t}\n\thostdata->input_Q = NULL;\n\thostdata->selecting = NULL;\n\thostdata->connected = NULL;\n\thostdata->disconnected_Q = NULL;\n\thostdata->state = S_UNCONNECTED;\n\thostdata->dma = D_DMA_OFF;\n\thostdata->incoming_ptr = 0;\n\thostdata->outgoing_len = 0;\n\n\treset_wd33c93(instance);\n\tSCpnt->result = DID_RESET << 16;\n\tenable_irq(instance->irq);\n\tspin_unlock_irq(instance->host_lock);\n\treturn SUCCESS;\n}\n\nint\nwd33c93_abort(struct scsi_cmnd * cmd)\n{\n\tstruct Scsi_Host *instance;\n\tstruct WD33C93_hostdata *hostdata;\n\twd33c93_regs regs;\n\tstruct scsi_cmnd *tmp, *prev;\n\n\tdisable_irq(cmd->device->host->irq);\n\n\tinstance = cmd->device->host;\n\thostdata = (struct WD33C93_hostdata *) instance->hostdata;\n\tregs = hostdata->regs;\n\n \n\n\ttmp = (struct scsi_cmnd *) hostdata->input_Q;\n\tprev = NULL;\n\twhile (tmp) {\n\t\tif (tmp == cmd) {\n\t\t\tif (prev)\n\t\t\t\tprev->host_scribble = cmd->host_scribble;\n\t\t\telse\n\t\t\t\thostdata->input_Q =\n\t\t\t\t    (struct scsi_cmnd *) cmd->host_scribble;\n\t\t\tcmd->host_scribble = NULL;\n\t\t\tcmd->result = DID_ABORT << 16;\n\t\t\tprintk\n\t\t\t    (\"scsi%d: Abort - removing command from input_Q. \",\n\t\t\t     instance->host_no);\n\t\t\tenable_irq(cmd->device->host->irq);\n\t\t\tscsi_done(cmd);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = tmp;\n\t\ttmp = (struct scsi_cmnd *) tmp->host_scribble;\n\t}\n\n \n\n\tif (hostdata->connected == cmd) {\n\t\tuchar sr, asr;\n\t\tunsigned long timeout;\n\n\t\tprintk(\"scsi%d: Aborting connected command - \",\n\t\t       instance->host_no);\n\n\t\tprintk(\"stopping DMA - \");\n\t\tif (hostdata->dma == D_DMA_RUNNING) {\n\t\t\thostdata->dma_stop(instance, cmd, 0);\n\t\t\thostdata->dma = D_DMA_OFF;\n\t\t}\n\n\t\tprintk(\"sending wd33c93 ABORT command - \");\n\t\twrite_wd33c93(regs, WD_CONTROL,\n\t\t\t      CTRL_IDI | CTRL_EDI | CTRL_POLLED);\n\t\twrite_wd33c93_cmd(regs, WD_CMD_ABORT);\n\n \n\n\t\tprintk(\"flushing fifo - \");\n\t\ttimeout = 1000000;\n\t\tdo {\n\t\t\tasr = read_aux_stat(regs);\n\t\t\tif (asr & ASR_DBR)\n\t\t\t\tread_wd33c93(regs, WD_DATA);\n\t\t} while (!(asr & ASR_INT) && timeout-- > 0);\n\t\tsr = read_wd33c93(regs, WD_SCSI_STATUS);\n\t\tprintk\n\t\t    (\"asr=%02x, sr=%02x, %ld bytes un-transferred (timeout=%ld) - \",\n\t\t     asr, sr, read_wd33c93_count(regs), timeout);\n\n\t\t \n\n\t\tprintk(\"sending wd33c93 DISCONNECT command - \");\n\t\twrite_wd33c93_cmd(regs, WD_CMD_DISCONNECT);\n\n\t\ttimeout = 1000000;\n\t\tasr = read_aux_stat(regs);\n\t\twhile ((asr & ASR_CIP) && timeout-- > 0)\n\t\t\tasr = read_aux_stat(regs);\n\t\tsr = read_wd33c93(regs, WD_SCSI_STATUS);\n\t\tprintk(\"asr=%02x, sr=%02x.\", asr, sr);\n\n\t\thostdata->busy[cmd->device->id] &= ~(1 << (cmd->device->lun & 0xff));\n\t\thostdata->connected = NULL;\n\t\thostdata->state = S_UNCONNECTED;\n\t\tcmd->result = DID_ABORT << 16;\n\n \n\t\twd33c93_execute(instance);\n\n\t\tenable_irq(cmd->device->host->irq);\n\t\tscsi_done(cmd);\n\t\treturn SUCCESS;\n\t}\n\n \n\n\ttmp = (struct scsi_cmnd *) hostdata->disconnected_Q;\n\twhile (tmp) {\n\t\tif (tmp == cmd) {\n\t\t\tprintk\n\t\t\t    (\"scsi%d: Abort - command found on disconnected_Q - \",\n\t\t\t     instance->host_no);\n\t\t\tprintk(\"Abort SNOOZE. \");\n\t\t\tenable_irq(cmd->device->host->irq);\n\t\t\treturn FAILED;\n\t\t}\n\t\ttmp = (struct scsi_cmnd *) tmp->host_scribble;\n\t}\n\n \n\n \n\twd33c93_execute(instance);\n\n\tenable_irq(cmd->device->host->irq);\n\tprintk(\"scsi%d: warning : SCSI command probably completed successfully\"\n\t       \"         before abortion. \", instance->host_no);\n\treturn FAILED;\n}\n\n#define MAX_WD33C93_HOSTS 4\n#define MAX_SETUP_ARGS ARRAY_SIZE(setup_args)\n#define SETUP_BUFFER_SIZE 200\nstatic char setup_buffer[SETUP_BUFFER_SIZE];\nstatic char setup_used[MAX_SETUP_ARGS];\nstatic int done_setup = 0;\n\nstatic int\nwd33c93_setup(char *str)\n{\n\tint i;\n\tchar *p1, *p2;\n\n\t \n\n\tp1 = setup_buffer;\n\t*p1 = '\\0';\n\tif (str)\n\t\tstrncpy(p1, str, SETUP_BUFFER_SIZE - strlen(setup_buffer));\n\tsetup_buffer[SETUP_BUFFER_SIZE - 1] = '\\0';\n\tp1 = setup_buffer;\n\ti = 0;\n\twhile (*p1 && (i < MAX_SETUP_ARGS)) {\n\t\tp2 = strchr(p1, ',');\n\t\tif (p2) {\n\t\t\t*p2 = '\\0';\n\t\t\tif (p1 != p2)\n\t\t\t\tsetup_args[i] = p1;\n\t\t\tp1 = p2 + 1;\n\t\t\ti++;\n\t\t} else {\n\t\t\tsetup_args[i] = p1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 0; i < MAX_SETUP_ARGS; i++)\n\t\tsetup_used[i] = 0;\n\tdone_setup = 1;\n\n\treturn 1;\n}\n__setup(\"wd33c93=\", wd33c93_setup);\n\n \nstatic int\ncheck_setup_args(char *key, int *flags, int *val, char *buf)\n{\n\tint x;\n\tchar *cp;\n\n\tfor (x = 0; x < MAX_SETUP_ARGS; x++) {\n\t\tif (setup_used[x])\n\t\t\tcontinue;\n\t\tif (!strncmp(setup_args[x], key, strlen(key)))\n\t\t\tbreak;\n\t\tif (!strncmp(setup_args[x], \"next\", strlen(\"next\")))\n\t\t\treturn 0;\n\t}\n\tif (x == MAX_SETUP_ARGS)\n\t\treturn 0;\n\tsetup_used[x] = 1;\n\tcp = setup_args[x] + strlen(key);\n\t*val = -1;\n\tif (*cp != ':')\n\t\treturn ++x;\n\tcp++;\n\tif ((*cp >= '0') && (*cp <= '9')) {\n\t\t*val = simple_strtoul(cp, NULL, 0);\n\t}\n\treturn ++x;\n}\n\n \nstatic inline unsigned int\nround_4(unsigned int x)\n{\n\tswitch (x & 3) {\n\t\tcase 1: --x;\n\t\t\tbreak;\n\t\tcase 2: ++x;\n\t\t\tfallthrough;\n\t\tcase 3: ++x;\n\t}\n\treturn x;\n}\n\nstatic void\ncalc_sx_table(unsigned int mhz, struct sx_period sx_table[9])\n{\n\tunsigned int d, i;\n\tif (mhz < 11)\n\t\td = 2;\t \n\telse if (mhz < 16)\n\t\td = 3;\t \n\telse\n\t\td = 4;\t \n\n\td = (100000 * d) / 2 / mhz;  \n\n\tsx_table[0].period_ns = 1;\n\tsx_table[0].reg_value = 0x20;\n\tfor (i = 1; i < 8; i++) {\n\t\tsx_table[i].period_ns = round_4((i+1)*d / 100);\n\t\tsx_table[i].reg_value = (i+1)*0x10;\n\t}\n\tsx_table[7].reg_value = 0;\n\tsx_table[8].period_ns = 0;\n\tsx_table[8].reg_value = 0;\n}\n\n \nstatic uchar\nset_clk_freq(int freq, int *mhz)\n{\n\tint x = freq;\n\tif (WD33C93_FS_8_10 == freq)\n\t\tfreq = 8;\n\telse if (WD33C93_FS_12_15 == freq)\n\t\tfreq = 12;\n\telse if (WD33C93_FS_16_20 == freq)\n\t\tfreq = 16;\n\telse if (freq > 7 && freq < 11)\n\t\tx = WD33C93_FS_8_10;\n\t\telse if (freq > 11 && freq < 16)\n\t\tx = WD33C93_FS_12_15;\n\t\telse if (freq > 15 && freq < 21)\n\t\tx = WD33C93_FS_16_20;\n\telse {\n\t\t\t \n\t\tx = WD33C93_FS_8_10;\n\t\tfreq = 8;\n\t}\n\t*mhz = freq;\n\treturn x;\n}\n\n \nstatic inline void set_resync ( struct WD33C93_hostdata *hd, int mask )\n{\n\tint i;\n\tfor (i = 0; i < 8; i++)\n\t\tif (mask & (1 << i))\n\t\t\thd->sync_stat[i] = SS_UNSET;\n}\n\nvoid\nwd33c93_init(struct Scsi_Host *instance, const wd33c93_regs regs,\n\t     dma_setup_t setup, dma_stop_t stop, int clock_freq)\n{\n\tstruct WD33C93_hostdata *hostdata;\n\tint i;\n\tint flags;\n\tint val;\n\tchar buf[32];\n\n\tif (!done_setup && setup_strings)\n\t\twd33c93_setup(setup_strings);\n\n\thostdata = (struct WD33C93_hostdata *) instance->hostdata;\n\n\thostdata->regs = regs;\n\thostdata->clock_freq = set_clk_freq(clock_freq, &i);\n\tcalc_sx_table(i, hostdata->sx_table);\n\thostdata->dma_setup = setup;\n\thostdata->dma_stop = stop;\n\thostdata->dma_bounce_buffer = NULL;\n\thostdata->dma_bounce_len = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\thostdata->busy[i] = 0;\n\t\thostdata->sync_xfer[i] =\n\t\t\tcalc_sync_xfer(DEFAULT_SX_PER / 4, DEFAULT_SX_OFF,\n\t\t\t\t\t0, hostdata->sx_table);\n\t\thostdata->sync_stat[i] = SS_UNSET;\t \n#ifdef PROC_STATISTICS\n\t\thostdata->cmd_cnt[i] = 0;\n\t\thostdata->disc_allowed_cnt[i] = 0;\n\t\thostdata->disc_done_cnt[i] = 0;\n#endif\n\t}\n\thostdata->input_Q = NULL;\n\thostdata->selecting = NULL;\n\thostdata->connected = NULL;\n\thostdata->disconnected_Q = NULL;\n\thostdata->state = S_UNCONNECTED;\n\thostdata->dma = D_DMA_OFF;\n\thostdata->level2 = L2_BASIC;\n\thostdata->disconnect = DIS_ADAPTIVE;\n\thostdata->args = DEBUG_DEFAULTS;\n\thostdata->incoming_ptr = 0;\n\thostdata->outgoing_len = 0;\n\thostdata->default_sx_per = DEFAULT_SX_PER;\n\thostdata->no_dma = 0;\t \n\n#ifdef PROC_INTERFACE\n\thostdata->proc = PR_VERSION | PR_INFO | PR_STATISTICS |\n\t    PR_CONNECTED | PR_INPUTQ | PR_DISCQ | PR_STOP;\n#ifdef PROC_STATISTICS\n\thostdata->dma_cnt = 0;\n\thostdata->pio_cnt = 0;\n\thostdata->int_cnt = 0;\n#endif\n#endif\n\n\tif (check_setup_args(\"clock\", &flags, &val, buf)) {\n\t\thostdata->clock_freq = set_clk_freq(val, &val);\n\t\tcalc_sx_table(val, hostdata->sx_table);\n\t}\n\n\tif (check_setup_args(\"nosync\", &flags, &val, buf))\n\t\thostdata->no_sync = val;\n\n\tif (check_setup_args(\"nodma\", &flags, &val, buf))\n\t\thostdata->no_dma = (val == -1) ? 1 : val;\n\n\tif (check_setup_args(\"period\", &flags, &val, buf))\n\t\thostdata->default_sx_per =\n\t\t    hostdata->sx_table[round_period((unsigned int) val,\n\t\t                                    hostdata->sx_table)].period_ns;\n\n\tif (check_setup_args(\"disconnect\", &flags, &val, buf)) {\n\t\tif ((val >= DIS_NEVER) && (val <= DIS_ALWAYS))\n\t\t\thostdata->disconnect = val;\n\t\telse\n\t\t\thostdata->disconnect = DIS_ADAPTIVE;\n\t}\n\n\tif (check_setup_args(\"level2\", &flags, &val, buf))\n\t\thostdata->level2 = val;\n\n\tif (check_setup_args(\"debug\", &flags, &val, buf))\n\t\thostdata->args = val & DB_MASK;\n\n\tif (check_setup_args(\"burst\", &flags, &val, buf))\n\t\thostdata->dma_mode = val ? CTRL_BURST:CTRL_DMA;\n\n\tif (WD33C93_FS_16_20 == hostdata->clock_freq  \n\t\t&& check_setup_args(\"fast\", &flags, &val, buf))\n\t\thostdata->fast = !!val;\n\n\tif ((i = check_setup_args(\"next\", &flags, &val, buf))) {\n\t\twhile (i)\n\t\t\tsetup_used[--i] = 1;\n\t}\n#ifdef PROC_INTERFACE\n\tif (check_setup_args(\"proc\", &flags, &val, buf))\n\t\thostdata->proc = val;\n#endif\n\n\tspin_lock_irq(&hostdata->lock);\n\treset_wd33c93(instance);\n\tspin_unlock_irq(&hostdata->lock);\n\n\tprintk(\"wd33c93-%d: chip=%s/%d no_sync=0x%x no_dma=%d\",\n\t       instance->host_no,\n\t       (hostdata->chip == C_WD33C93) ? \"WD33c93\" : (hostdata->chip ==\n\t\t\t\t\t\t\t    C_WD33C93A) ?\n\t       \"WD33c93A\" : (hostdata->chip ==\n\t\t\t     C_WD33C93B) ? \"WD33c93B\" : \"unknown\",\n\t       hostdata->microcode, hostdata->no_sync, hostdata->no_dma);\n#ifdef DEBUGGING_ON\n\tprintk(\" debug_flags=0x%02x\\n\", hostdata->args);\n#else\n\tprintk(\" debugging=OFF\\n\");\n#endif\n\tprintk(\"           setup_args=\");\n\tfor (i = 0; i < MAX_SETUP_ARGS; i++)\n\t\tprintk(\"%s,\", setup_args[i]);\n\tprintk(\"\\n\");\n\tprintk(\"           Version %s - %s\\n\", WD33C93_VERSION, WD33C93_DATE);\n}\n\nint wd33c93_write_info(struct Scsi_Host *instance, char *buf, int len)\n{\n#ifdef PROC_INTERFACE\n\tchar *bp;\n\tstruct WD33C93_hostdata *hd;\n\tint x;\n\n\thd = (struct WD33C93_hostdata *) instance->hostdata;\n\n \n\n\tbuf[len] = '\\0';\n\tfor (bp = buf; *bp; ) {\n\t\twhile (',' == *bp || ' ' == *bp)\n\t\t\t++bp;\n\tif (!strncmp(bp, \"debug:\", 6)) {\n\t\t\thd->args = simple_strtoul(bp+6, &bp, 0) & DB_MASK;\n\t} else if (!strncmp(bp, \"disconnect:\", 11)) {\n\t\t\tx = simple_strtoul(bp+11, &bp, 0);\n\t\tif (x < DIS_NEVER || x > DIS_ALWAYS)\n\t\t\tx = DIS_ADAPTIVE;\n\t\thd->disconnect = x;\n\t} else if (!strncmp(bp, \"period:\", 7)) {\n\t\tx = simple_strtoul(bp+7, &bp, 0);\n\t\thd->default_sx_per =\n\t\t\thd->sx_table[round_period((unsigned int) x,\n\t\t\t\t\t\t  hd->sx_table)].period_ns;\n\t} else if (!strncmp(bp, \"resync:\", 7)) {\n\t\t\tset_resync(hd, (int)simple_strtoul(bp+7, &bp, 0));\n\t} else if (!strncmp(bp, \"proc:\", 5)) {\n\t\t\thd->proc = simple_strtoul(bp+5, &bp, 0);\n\t} else if (!strncmp(bp, \"nodma:\", 6)) {\n\t\t\thd->no_dma = simple_strtoul(bp+6, &bp, 0);\n\t} else if (!strncmp(bp, \"level2:\", 7)) {\n\t\t\thd->level2 = simple_strtoul(bp+7, &bp, 0);\n\t\t} else if (!strncmp(bp, \"burst:\", 6)) {\n\t\t\thd->dma_mode =\n\t\t\t\tsimple_strtol(bp+6, &bp, 0) ? CTRL_BURST:CTRL_DMA;\n\t\t} else if (!strncmp(bp, \"fast:\", 5)) {\n\t\t\tx = !!simple_strtol(bp+5, &bp, 0);\n\t\t\tif (x != hd->fast)\n\t\t\t\tset_resync(hd, 0xff);\n\t\t\thd->fast = x;\n\t\t} else if (!strncmp(bp, \"nosync:\", 7)) {\n\t\t\tx = simple_strtoul(bp+7, &bp, 0);\n\t\t\tset_resync(hd, x ^ hd->no_sync);\n\t\t\thd->no_sync = x;\n\t\t} else {\n\t\t\tbreak;  \n\t\t}\n\t}\n\treturn len;\n#else\n\treturn 0;\n#endif\n}\n\nint\nwd33c93_show_info(struct seq_file *m, struct Scsi_Host *instance)\n{\n#ifdef PROC_INTERFACE\n\tstruct WD33C93_hostdata *hd;\n\tstruct scsi_cmnd *cmd;\n\tint x;\n\n\thd = (struct WD33C93_hostdata *) instance->hostdata;\n\n\tspin_lock_irq(&hd->lock);\n\tif (hd->proc & PR_VERSION)\n\t\tseq_printf(m, \"\\nVersion %s - %s.\",\n\t\t\tWD33C93_VERSION, WD33C93_DATE);\n\n\tif (hd->proc & PR_INFO) {\n\t\tseq_printf(m, \"\\nclock_freq=%02x no_sync=%02x no_dma=%d\"\n\t\t\t\" dma_mode=%02x fast=%d\",\n\t\t\thd->clock_freq, hd->no_sync, hd->no_dma, hd->dma_mode, hd->fast);\n\t\tseq_puts(m, \"\\nsync_xfer[] =       \");\n\t\tfor (x = 0; x < 7; x++)\n\t\t\tseq_printf(m, \"\\t%02x\", hd->sync_xfer[x]);\n\t\tseq_puts(m, \"\\nsync_stat[] =       \");\n\t\tfor (x = 0; x < 7; x++)\n\t\t\tseq_printf(m, \"\\t%02x\", hd->sync_stat[x]);\n\t}\n#ifdef PROC_STATISTICS\n\tif (hd->proc & PR_STATISTICS) {\n\t\tseq_puts(m, \"\\ncommands issued:    \");\n\t\tfor (x = 0; x < 7; x++)\n\t\t\tseq_printf(m, \"\\t%ld\", hd->cmd_cnt[x]);\n\t\tseq_puts(m, \"\\ndisconnects allowed:\");\n\t\tfor (x = 0; x < 7; x++)\n\t\t\tseq_printf(m, \"\\t%ld\", hd->disc_allowed_cnt[x]);\n\t\tseq_puts(m, \"\\ndisconnects done:   \");\n\t\tfor (x = 0; x < 7; x++)\n\t\t\tseq_printf(m, \"\\t%ld\", hd->disc_done_cnt[x]);\n\t\tseq_printf(m,\n\t\t\t\"\\ninterrupts: %ld, DATA_PHASE ints: %ld DMA, %ld PIO\",\n\t\t\thd->int_cnt, hd->dma_cnt, hd->pio_cnt);\n\t}\n#endif\n\tif (hd->proc & PR_CONNECTED) {\n\t\tseq_puts(m, \"\\nconnected:     \");\n\t\tif (hd->connected) {\n\t\t\tcmd = (struct scsi_cmnd *) hd->connected;\n\t\t\tseq_printf(m, \" %d:%llu(%02x)\",\n\t\t\t\tcmd->device->id, cmd->device->lun, cmd->cmnd[0]);\n\t\t}\n\t}\n\tif (hd->proc & PR_INPUTQ) {\n\t\tseq_puts(m, \"\\ninput_Q:       \");\n\t\tcmd = (struct scsi_cmnd *) hd->input_Q;\n\t\twhile (cmd) {\n\t\t\tseq_printf(m, \" %d:%llu(%02x)\",\n\t\t\t\tcmd->device->id, cmd->device->lun, cmd->cmnd[0]);\n\t\t\tcmd = (struct scsi_cmnd *) cmd->host_scribble;\n\t\t}\n\t}\n\tif (hd->proc & PR_DISCQ) {\n\t\tseq_puts(m, \"\\ndisconnected_Q:\");\n\t\tcmd = (struct scsi_cmnd *) hd->disconnected_Q;\n\t\twhile (cmd) {\n\t\t\tseq_printf(m, \" %d:%llu(%02x)\",\n\t\t\t\tcmd->device->id, cmd->device->lun, cmd->cmnd[0]);\n\t\t\tcmd = (struct scsi_cmnd *) cmd->host_scribble;\n\t\t}\n\t}\n\tseq_putc(m, '\\n');\n\tspin_unlock_irq(&hd->lock);\n#endif\t\t\t\t \n\treturn 0;\n}\n\nEXPORT_SYMBOL(wd33c93_host_reset);\nEXPORT_SYMBOL(wd33c93_init);\nEXPORT_SYMBOL(wd33c93_abort);\nEXPORT_SYMBOL(wd33c93_queuecommand);\nEXPORT_SYMBOL(wd33c93_intr);\nEXPORT_SYMBOL(wd33c93_show_info);\nEXPORT_SYMBOL(wd33c93_write_info);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}