{
  "module_name": "esas2r_int.c",
  "hash_id": "12fea90ce16e6194f3e0eca51ed7f54e249fbeb99c7945974051e922b7a559ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/esas2r/esas2r_int.c",
  "human_readable_source": " \n \n \n \n\n#include \"esas2r.h\"\n\n \nstatic void esas2r_doorbell_interrupt(struct esas2r_adapter *a, u32 doorbell);\nstatic void esas2r_get_outbound_responses(struct esas2r_adapter *a);\nstatic void esas2r_process_bus_reset(struct esas2r_adapter *a);\n\n \nvoid esas2r_polled_interrupt(struct esas2r_adapter *a)\n{\n\tu32 intstat;\n\tu32 doorbell;\n\n\tesas2r_disable_chip_interrupts(a);\n\n\tintstat = esas2r_read_register_dword(a, MU_INT_STATUS_OUT);\n\n\tif (intstat & MU_INTSTAT_POST_OUT) {\n\t\t \n\n\t\tesas2r_write_register_dword(a, MU_OUT_LIST_INT_STAT,\n\t\t\t\t\t    MU_OLIS_INT);\n\t\tesas2r_flush_register_dword(a, MU_OUT_LIST_INT_STAT);\n\n\t\tesas2r_get_outbound_responses(a);\n\t}\n\n\tif (intstat & MU_INTSTAT_DRBL) {\n\t\tdoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\n\t\tif (doorbell != 0)\n\t\t\tesas2r_doorbell_interrupt(a, doorbell);\n\t}\n\n\tesas2r_enable_chip_interrupts(a);\n\n\tif (atomic_read(&a->disable_cnt) == 0)\n\t\tesas2r_do_deferred_processes(a);\n}\n\n \nirqreturn_t esas2r_interrupt(int irq, void *dev_id)\n{\n\tstruct esas2r_adapter *a = (struct esas2r_adapter *)dev_id;\n\n\tif (!esas2r_adapter_interrupt_pending(a))\n\t\treturn IRQ_NONE;\n\n\tset_bit(AF2_INT_PENDING, &a->flags2);\n\tesas2r_schedule_tasklet(a);\n\n\treturn IRQ_HANDLED;\n}\n\nvoid esas2r_adapter_interrupt(struct esas2r_adapter *a)\n{\n\tu32 doorbell;\n\n\tif (likely(a->int_stat & MU_INTSTAT_POST_OUT)) {\n\t\t \n\t\tesas2r_write_register_dword(a, MU_OUT_LIST_INT_STAT,\n\t\t\t\t\t    MU_OLIS_INT);\n\t\tesas2r_flush_register_dword(a, MU_OUT_LIST_INT_STAT);\n\t\tesas2r_get_outbound_responses(a);\n\t}\n\n\tif (unlikely(a->int_stat & MU_INTSTAT_DRBL)) {\n\t\tdoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\n\t\tif (doorbell != 0)\n\t\t\tesas2r_doorbell_interrupt(a, doorbell);\n\t}\n\n\ta->int_mask = ESAS2R_INT_STS_MASK;\n\n\tesas2r_enable_chip_interrupts(a);\n\n\tif (likely(atomic_read(&a->disable_cnt) == 0))\n\t\tesas2r_do_deferred_processes(a);\n}\n\nirqreturn_t esas2r_msi_interrupt(int irq, void *dev_id)\n{\n\tstruct esas2r_adapter *a = (struct esas2r_adapter *)dev_id;\n\tu32 intstat;\n\tu32 doorbell;\n\n\tintstat = esas2r_read_register_dword(a, MU_INT_STATUS_OUT);\n\n\tif (likely(intstat & MU_INTSTAT_POST_OUT)) {\n\t\t \n\n\t\tesas2r_write_register_dword(a, MU_OUT_LIST_INT_STAT,\n\t\t\t\t\t    MU_OLIS_INT);\n\t\tesas2r_flush_register_dword(a, MU_OUT_LIST_INT_STAT);\n\n\t\tesas2r_get_outbound_responses(a);\n\t}\n\n\tif (unlikely(intstat & MU_INTSTAT_DRBL)) {\n\t\tdoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\n\t\tif (doorbell != 0)\n\t\t\tesas2r_doorbell_interrupt(a, doorbell);\n\t}\n\n\t \n\tesas2r_disable_chip_interrupts(a);\n\tesas2r_enable_chip_interrupts(a);\n\n\tif (likely(atomic_read(&a->disable_cnt) == 0))\n\t\tesas2r_do_deferred_processes(a);\n\n\tesas2r_do_tasklet_tasks(a);\n\n\treturn 1;\n}\n\n\n\nstatic void esas2r_handle_outbound_rsp_err(struct esas2r_adapter *a,\n\t\t\t\t\t   struct esas2r_request *rq,\n\t\t\t\t\t   struct atto_vda_ob_rsp *rsp)\n{\n\n\t \n\tif (unlikely(rq->req_stat != RS_SUCCESS)) {\n\t\tmemcpy(&rq->func_rsp, &rsp->func_rsp, sizeof(rsp->func_rsp));\n\n\t\tif (rq->req_stat == RS_ABORTED) {\n\t\t\tif (rq->timeout > RQ_MAX_TIMEOUT)\n\t\t\t\trq->req_stat = RS_TIMEOUT;\n\t\t} else if (rq->req_stat == RS_SCSI_ERROR) {\n\t\t\tu8 scsistatus = rq->func_rsp.scsi_rsp.scsi_stat;\n\n\t\t\tesas2r_trace(\"scsistatus: %x\", scsistatus);\n\n\t\t\t \n\t\t\tif (scsistatus == SAM_STAT_GOOD || scsistatus ==\n\t\t\t    SAM_STAT_CONDITION_MET || scsistatus ==\n\t\t\t    SAM_STAT_INTERMEDIATE || scsistatus ==\n\t\t\t    SAM_STAT_INTERMEDIATE_CONDITION_MET) {\n\t\t\t\trq->req_stat = RS_SUCCESS;\n\t\t\t\trq->func_rsp.scsi_rsp.scsi_stat =\n\t\t\t\t\tSAM_STAT_GOOD;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void esas2r_get_outbound_responses(struct esas2r_adapter *a)\n{\n\tstruct atto_vda_ob_rsp *rsp;\n\tu32 rspput_ptr;\n\tu32 rspget_ptr;\n\tstruct esas2r_request *rq;\n\tu32 handle;\n\tunsigned long flags;\n\n\tLIST_HEAD(comp_list);\n\n\tesas2r_trace_enter();\n\n\tspin_lock_irqsave(&a->queue_lock, flags);\n\n\t \n\trspput_ptr = le32_to_cpu(*a->outbound_copy) & MU_OLC_WRT_PTR;\n\trspget_ptr = a->last_read;\n\n\tesas2r_trace(\"rspput_ptr: %x, rspget_ptr: %x\", rspput_ptr, rspget_ptr);\n\n\t \n\tif (unlikely(rspget_ptr == rspput_ptr)) {\n\t\tspin_unlock_irqrestore(&a->queue_lock, flags);\n\t\tesas2r_trace_exit();\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(rspput_ptr >= a->list_size)) {\n\t\tspin_unlock_irqrestore(&a->queue_lock, flags);\n\t\tesas2r_bugon();\n\t\tesas2r_local_reset_adapter(a);\n\t\tesas2r_trace_exit();\n\t\treturn;\n\t}\n\n\tdo {\n\t\trspget_ptr++;\n\n\t\tif (rspget_ptr >= a->list_size)\n\t\t\trspget_ptr = 0;\n\n\t\trsp = (struct atto_vda_ob_rsp *)a->outbound_list_md.virt_addr\n\t\t      + rspget_ptr;\n\n\t\thandle = rsp->handle;\n\n\t\t \n\t\tif (unlikely(LOWORD(handle) == 0\n\t\t\t     || LOWORD(handle) > num_requests +\n\t\t\t     num_ae_requests + 1)) {\n\t\t\tesas2r_bugon();\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\trq = a->req_table[LOWORD(handle)];\n\n\t\tif (unlikely(rq == NULL || rq->vrq->scsi.handle != handle)) {\n\t\t\tesas2r_bugon();\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&rq->req_list);\n\n\t\t \n\t\trq->req_stat = rsp->req_stat;\n\n\t\tesas2r_trace(\"handle: %x\", handle);\n\t\tesas2r_trace(\"rq: %p\", rq);\n\t\tesas2r_trace(\"req_status: %x\", rq->req_stat);\n\n\t\tif (likely(rq->vrq->scsi.function == VDA_FUNC_SCSI)) {\n\t\t\tesas2r_handle_outbound_rsp_err(a, rq, rsp);\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(&rq->func_rsp, &rsp->func_rsp,\n\t\t\t       sizeof(rsp->func_rsp));\n\t\t}\n\n\t\t \n\t\tlist_add_tail(&rq->comp_list, &comp_list);\n\n\t} while (rspget_ptr != rspput_ptr);\n\n\ta->last_read = rspget_ptr;\n\tspin_unlock_irqrestore(&a->queue_lock, flags);\n\n\tesas2r_comp_list_drain(a, &comp_list);\n\tesas2r_trace_exit();\n}\n\n \nvoid esas2r_do_deferred_processes(struct esas2r_adapter *a)\n{\n\tint startreqs = 2;\n\tstruct esas2r_request *rq;\n\tunsigned long flags;\n\n\t \n\n\tif (test_bit(AF_CHPRST_PENDING, &a->flags) ||\n\t    test_bit(AF_FLASHING, &a->flags))\n\t\tstartreqs = 0;\n\telse if (test_bit(AF_DISC_PENDING, &a->flags))\n\t\tstartreqs = 1;\n\n\tatomic_inc(&a->disable_cnt);\n\n\t \n\n\tif (esas2r_is_tasklet_pending(a)) {\n\t\tesas2r_schedule_tasklet(a);\n\n\t\tstartreqs = 0;\n\t}\n\n\t \n\tif (startreqs && !list_empty(&a->defer_list)) {\n\t\tLIST_HEAD(comp_list);\n\t\tstruct list_head *element, *next;\n\n\t\tspin_lock_irqsave(&a->queue_lock, flags);\n\n\t\tlist_for_each_safe(element, next, &a->defer_list) {\n\t\t\trq = list_entry(element, struct esas2r_request,\n\t\t\t\t\treq_list);\n\n\t\t\tif (rq->req_stat != RS_PENDING) {\n\t\t\t\tlist_del(element);\n\t\t\t\tlist_add_tail(&rq->comp_list, &comp_list);\n\t\t\t}\n\t\t\t \n\t\t\telse if (rq->req_type == RT_DISC_REQ) {\n\t\t\t\tlist_del(element);\n\t\t\t\tesas2r_disc_local_start_request(a, rq);\n\t\t\t} else if (startreqs == 2) {\n\t\t\t\tlist_del(element);\n\t\t\t\tesas2r_local_start_request(a, rq);\n\n\t\t\t\t \n\t\t\t\tif (test_bit(AF_FLASHING, &a->flags))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock_irqrestore(&a->queue_lock, flags);\n\t\tesas2r_comp_list_drain(a, &comp_list);\n\t}\n\n\tatomic_dec(&a->disable_cnt);\n}\n\n \nvoid esas2r_process_adapter_reset(struct esas2r_adapter *a)\n{\n\tstruct esas2r_request *rq = &a->general_req;\n\tunsigned long flags;\n\tstruct esas2r_disc_context *dc;\n\n\tLIST_HEAD(comp_list);\n\tstruct list_head *element;\n\n\tesas2r_trace_enter();\n\n\tspin_lock_irqsave(&a->queue_lock, flags);\n\n\t \n\n\tif (rq->interrupt_cx) {\n\t\tdc = (struct esas2r_disc_context *)rq->interrupt_cx;\n\n\t\tdc->disc_evt = 0;\n\n\t\tclear_bit(AF_DISC_IN_PROG, &a->flags);\n\t}\n\n\t \n\n\trq->interrupt_cx = NULL;\n\trq->interrupt_cb = NULL;\n\n\trq->comp_cb = esas2r_dummy_complete;\n\n\t \n\n\t*a->outbound_copy =\n\t\ta->last_write =\n\t\t\ta->last_read = a->list_size - 1;\n\n\tset_bit(AF_COMM_LIST_TOGGLE, &a->flags);\n\n\t \n\tlist_for_each(element, &a->defer_list) {\n\t\trq = list_entry(element, struct esas2r_request, req_list);\n\n\t\tif (rq->req_stat == RS_STARTED)\n\t\t\tif (esas2r_ioreq_aborted(a, rq, RS_ABORTED))\n\t\t\t\tlist_add_tail(&rq->comp_list, &comp_list);\n\t}\n\n\tspin_unlock_irqrestore(&a->queue_lock, flags);\n\tesas2r_comp_list_drain(a, &comp_list);\n\tesas2r_process_bus_reset(a);\n\tesas2r_trace_exit();\n}\n\nstatic void esas2r_process_bus_reset(struct esas2r_adapter *a)\n{\n\tstruct esas2r_request *rq;\n\tstruct list_head *element;\n\tunsigned long flags;\n\n\tLIST_HEAD(comp_list);\n\n\tesas2r_trace_enter();\n\n\tesas2r_hdebug(\"reset detected\");\n\n\tspin_lock_irqsave(&a->queue_lock, flags);\n\n\t \n\tlist_for_each(element, &a->defer_list) {\n\t\trq = list_entry(element, struct esas2r_request, req_list);\n\t\tif (esas2r_ioreq_aborted(a, rq, RS_ABORTED))\n\t\t\tlist_add_tail(&rq->comp_list, &comp_list);\n\t}\n\n\tspin_unlock_irqrestore(&a->queue_lock, flags);\n\n\tesas2r_comp_list_drain(a, &comp_list);\n\n\tif (atomic_read(&a->disable_cnt) == 0)\n\t\tesas2r_do_deferred_processes(a);\n\n\tclear_bit(AF_OS_RESET, &a->flags);\n\n\tesas2r_trace_exit();\n}\n\nstatic void esas2r_chip_rst_needed_during_tasklet(struct esas2r_adapter *a)\n{\n\n\tclear_bit(AF_CHPRST_NEEDED, &a->flags);\n\tclear_bit(AF_BUSRST_NEEDED, &a->flags);\n\tclear_bit(AF_BUSRST_DETECTED, &a->flags);\n\tclear_bit(AF_BUSRST_PENDING, &a->flags);\n\t \n\tif (!esas2r_is_adapter_present(a) || (a->chip_uptime >=\n\t\t\t\t\t      ESAS2R_CHP_UPTIME_MAX)) {\n\t\tesas2r_hdebug(\"*** adapter disabled ***\");\n\n\t\t \n\n\t\tset_bit(AF_DEGRADED_MODE, &a->flags);\n\t\tset_bit(AF_DISABLED, &a->flags);\n\t\tclear_bit(AF_CHPRST_PENDING, &a->flags);\n\t\tclear_bit(AF_DISC_PENDING, &a->flags);\n\n\t\tesas2r_disable_chip_interrupts(a);\n\t\ta->int_mask = 0;\n\t\tesas2r_process_adapter_reset(a);\n\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"Adapter disabled because of hardware failure\");\n\t} else {\n\t\tbool alrdyrst = test_and_set_bit(AF_CHPRST_STARTED, &a->flags);\n\n\t\tif (!alrdyrst)\n\t\t\t \n\t\t\tesas2r_disable_chip_interrupts(a);\n\n\t\tif ((test_bit(AF_POWER_MGT, &a->flags)) &&\n\t\t    !test_bit(AF_FIRST_INIT, &a->flags) && !alrdyrst) {\n\t\t\t \n\t\t} else {\n\t\t\tesas2r_hdebug(\"*** resetting chip ***\");\n\t\t\tesas2r_reset_chip(a);\n\t\t}\n\n\t\t \n\t\ta->chip_uptime += ESAS2R_CHP_UPTIME_CNT;\n\t\ta->chip_init_time = jiffies_to_msecs(jiffies);\n\t\tif (!test_bit(AF_POWER_MGT, &a->flags)) {\n\t\t\tesas2r_process_adapter_reset(a);\n\n\t\t\tif (!alrdyrst) {\n\t\t\t\t \n\t\t\t\ta->prev_dev_cnt =\n\t\t\t\t\tesas2r_targ_db_get_tgt_cnt(a);\n\t\t\t\tesas2r_targ_db_remove_all(a, false);\n\t\t\t}\n\t\t}\n\n\t\ta->int_mask = 0;\n\t}\n}\n\nstatic void esas2r_handle_chip_rst_during_tasklet(struct esas2r_adapter *a)\n{\n\twhile (test_bit(AF_CHPRST_DETECTED, &a->flags)) {\n\t\t \n\t\tif (!test_bit(AF_DEGRADED_MODE, &a->flags) &&\n\t\t    !test_bit(AF_POWER_MGT, &a->flags))\n\t\t\tesas2r_disable_chip_interrupts(a);\n\n\t\t \n\t\tesas2r_check_adapter(a);\n\t\tesas2r_init_adapter_hw(a, 0);\n\n\t\tif (test_bit(AF_CHPRST_NEEDED, &a->flags))\n\t\t\tbreak;\n\n\t\tif (test_bit(AF_POWER_MGT, &a->flags)) {\n\t\t\t \n\t\t\tif (test_bit(AF_FIRST_INIT, &a->flags)) {\n\t\t\t\t \n\t\t\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t\t\t   \"The firmware was reset during a normal power-up sequence\");\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tclear_bit(AF_POWER_MGT, &a->flags);\n\t\t\t\tesas2r_send_reset_ae(a, true);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (test_bit(AF_FIRST_INIT, &a->flags)) {\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tesas2r_send_reset_ae(a, false);\n\t\t\t}\n\n\t\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t\t   \"Recovering from a chip reset while the chip was online\");\n\t\t}\n\n\t\tclear_bit(AF_CHPRST_STARTED, &a->flags);\n\t\tesas2r_enable_chip_interrupts(a);\n\n\t\t \n\t\tclear_bit(AF_CHPRST_DETECTED, &a->flags);\n\t}\n}\n\n\n \nvoid esas2r_do_tasklet_tasks(struct esas2r_adapter *a)\n{\n\n\tif (test_bit(AF_CHPRST_NEEDED, &a->flags) ||\n\t    test_bit(AF_CHPRST_DETECTED, &a->flags)) {\n\t\tif (test_bit(AF_CHPRST_NEEDED, &a->flags))\n\t\t\tesas2r_chip_rst_needed_during_tasklet(a);\n\n\t\tesas2r_handle_chip_rst_during_tasklet(a);\n\t}\n\n\tif (test_bit(AF_BUSRST_NEEDED, &a->flags)) {\n\t\tesas2r_hdebug(\"hard resetting bus\");\n\n\t\tclear_bit(AF_BUSRST_NEEDED, &a->flags);\n\n\t\tif (test_bit(AF_FLASHING, &a->flags))\n\t\t\tset_bit(AF_BUSRST_DETECTED, &a->flags);\n\t\telse\n\t\t\tesas2r_write_register_dword(a, MU_DOORBELL_IN,\n\t\t\t\t\t\t    DRBL_RESET_BUS);\n\t}\n\n\tif (test_bit(AF_BUSRST_DETECTED, &a->flags)) {\n\t\tesas2r_process_bus_reset(a);\n\n\t\tesas2r_log_dev(ESAS2R_LOG_WARN,\n\t\t\t       &(a->host->shost_gendev),\n\t\t\t       \"scsi_report_bus_reset() called\");\n\n\t\tscsi_report_bus_reset(a->host, 0);\n\n\t\tclear_bit(AF_BUSRST_DETECTED, &a->flags);\n\t\tclear_bit(AF_BUSRST_PENDING, &a->flags);\n\n\t\tesas2r_log(ESAS2R_LOG_WARN, \"Bus reset complete\");\n\t}\n\n\tif (test_bit(AF_PORT_CHANGE, &a->flags)) {\n\t\tclear_bit(AF_PORT_CHANGE, &a->flags);\n\n\t\tesas2r_targ_db_report_changes(a);\n\t}\n\n\tif (atomic_read(&a->disable_cnt) == 0)\n\t\tesas2r_do_deferred_processes(a);\n}\n\nstatic void esas2r_doorbell_interrupt(struct esas2r_adapter *a, u32 doorbell)\n{\n\tif (!(doorbell & DRBL_FORCE_INT)) {\n\t\tesas2r_trace_enter();\n\t\tesas2r_trace(\"doorbell: %x\", doorbell);\n\t}\n\n\t \n\tesas2r_write_register_dword(a, MU_DOORBELL_OUT, doorbell);\n\n\tif (doorbell & DRBL_RESET_BUS)\n\t\tset_bit(AF_BUSRST_DETECTED, &a->flags);\n\n\tif (doorbell & DRBL_FORCE_INT)\n\t\tclear_bit(AF_HEARTBEAT, &a->flags);\n\n\tif (doorbell & DRBL_PANIC_REASON_MASK) {\n\t\tesas2r_hdebug(\"*** Firmware Panic ***\");\n\t\tesas2r_log(ESAS2R_LOG_CRIT, \"The firmware has panicked\");\n\t}\n\n\tif (doorbell & DRBL_FW_RESET) {\n\t\tset_bit(AF2_COREDUMP_AVAIL, &a->flags2);\n\t\tesas2r_local_reset_adapter(a);\n\t}\n\n\tif (!(doorbell & DRBL_FORCE_INT)) {\n\t\tesas2r_trace_exit();\n\t}\n}\n\nvoid esas2r_force_interrupt(struct esas2r_adapter *a)\n{\n\tesas2r_write_register_dword(a, MU_DOORBELL_IN, DRBL_FORCE_INT |\n\t\t\t\t    DRBL_DRV_VER);\n}\n\n\nstatic void esas2r_lun_event(struct esas2r_adapter *a, union atto_vda_ae *ae,\n\t\t\t     u16 target, u32 length)\n{\n\tstruct esas2r_target *t = a->targetdb + target;\n\tu32 cplen = length;\n\tunsigned long flags;\n\n\tif (cplen > sizeof(t->lu_event))\n\t\tcplen = sizeof(t->lu_event);\n\n\tesas2r_trace(\"ae->lu.dwevent: %x\", ae->lu.dwevent);\n\tesas2r_trace(\"ae->lu.bystate: %x\", ae->lu.bystate);\n\n\tspin_lock_irqsave(&a->mem_lock, flags);\n\n\tt->new_target_state = TS_INVALID;\n\n\tif (ae->lu.dwevent  & VDAAE_LU_LOST) {\n\t\tt->new_target_state = TS_NOT_PRESENT;\n\t} else {\n\t\tswitch (ae->lu.bystate) {\n\t\tcase VDAAE_LU_NOT_PRESENT:\n\t\tcase VDAAE_LU_OFFLINE:\n\t\tcase VDAAE_LU_DELETED:\n\t\tcase VDAAE_LU_FACTORY_DISABLED:\n\t\t\tt->new_target_state = TS_NOT_PRESENT;\n\t\t\tbreak;\n\n\t\tcase VDAAE_LU_ONLINE:\n\t\tcase VDAAE_LU_DEGRADED:\n\t\t\tt->new_target_state = TS_PRESENT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (t->new_target_state != TS_INVALID) {\n\t\tmemcpy(&t->lu_event, &ae->lu, cplen);\n\n\t\tesas2r_disc_queue_event(a, DCDE_DEV_CHANGE);\n\t}\n\n\tspin_unlock_irqrestore(&a->mem_lock, flags);\n}\n\n\n\nvoid esas2r_ae_complete(struct esas2r_adapter *a, struct esas2r_request *rq)\n{\n\tunion atto_vda_ae *ae =\n\t\t(union atto_vda_ae *)rq->vda_rsp_data->ae_data.event_data;\n\tu32 length = le32_to_cpu(rq->func_rsp.ae_rsp.length);\n\tunion atto_vda_ae *last =\n\t\t(union atto_vda_ae *)(rq->vda_rsp_data->ae_data.event_data\n\t\t\t\t      + length);\n\n\tesas2r_trace_enter();\n\tesas2r_trace(\"length: %d\", length);\n\n\tif (length > sizeof(struct atto_vda_ae_data)\n\t    || (length & 3) != 0\n\t    || length == 0) {\n\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t   \"The AE request response length (%p) is too long: %d\",\n\t\t\t   rq, length);\n\n\t\tesas2r_hdebug(\"aereq->length (0x%x) too long\", length);\n\t\tesas2r_bugon();\n\n\t\tlast = ae;\n\t}\n\n\twhile (ae < last) {\n\t\tu16 target;\n\n\t\tesas2r_trace(\"ae: %p\", ae);\n\t\tesas2r_trace(\"ae->hdr: %p\", &(ae->hdr));\n\n\t\tlength = ae->hdr.bylength;\n\n\t\tif (length > (u32)((u8 *)last - (u8 *)ae)\n\t\t    || (length & 3) != 0\n\t\t    || length == 0) {\n\t\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t\t   \"the async event length is invalid (%p): %d\",\n\t\t\t\t   ae, length);\n\n\t\t\tesas2r_hdebug(\"ae->hdr.length (0x%x) invalid\", length);\n\t\t\tesas2r_bugon();\n\n\t\t\tbreak;\n\t\t}\n\n\t\tesas2r_nuxi_ae_data(ae);\n\n\t\tesas2r_queue_fw_event(a, fw_event_vda_ae, ae,\n\t\t\t\t      sizeof(union atto_vda_ae));\n\n\t\tswitch (ae->hdr.bytype) {\n\t\tcase VDAAE_HDR_TYPE_RAID:\n\n\t\t\tif (ae->raid.dwflags & (VDAAE_GROUP_STATE\n\t\t\t\t\t\t| VDAAE_RBLD_STATE\n\t\t\t\t\t\t| VDAAE_MEMBER_CHG\n\t\t\t\t\t\t| VDAAE_PART_CHG)) {\n\t\t\t\tesas2r_log(ESAS2R_LOG_INFO,\n\t\t\t\t\t   \"RAID event received - name:%s rebuild_state:%d group_state:%d\",\n\t\t\t\t\t   ae->raid.acname,\n\t\t\t\t\t   ae->raid.byrebuild_state,\n\t\t\t\t\t   ae->raid.bygroup_state);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase VDAAE_HDR_TYPE_LU:\n\t\t\tesas2r_log(ESAS2R_LOG_INFO,\n\t\t\t\t   \"LUN event received: event:%d target_id:%d LUN:%d state:%d\",\n\t\t\t\t   ae->lu.dwevent,\n\t\t\t\t   ae->lu.id.tgtlun.wtarget_id,\n\t\t\t\t   ae->lu.id.tgtlun.bylun,\n\t\t\t\t   ae->lu.bystate);\n\n\t\t\ttarget = ae->lu.id.tgtlun.wtarget_id;\n\n\t\t\tif (target < ESAS2R_MAX_TARGETS)\n\t\t\t\tesas2r_lun_event(a, ae, target, length);\n\n\t\t\tbreak;\n\n\t\tcase VDAAE_HDR_TYPE_DISK:\n\t\t\tesas2r_log(ESAS2R_LOG_INFO, \"Disk event received\");\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\t \n\n\t\t\tbreak;\n\t\t}\n\n\t\tae = (union atto_vda_ae *)((u8 *)ae + length);\n\t}\n\n\t \n\tesas2r_start_ae_request(a, rq);\n\tesas2r_trace_exit();\n}\n\n \nvoid esas2r_send_reset_ae(struct esas2r_adapter *a, bool pwr_mgt)\n{\n\tstruct atto_vda_ae_hdr ae;\n\n\tif (pwr_mgt)\n\t\tae.bytype = VDAAE_HDR_TYPE_PWRMGT;\n\telse\n\t\tae.bytype = VDAAE_HDR_TYPE_RESET;\n\n\tae.byversion = VDAAE_HDR_VER_0;\n\tae.byflags = 0;\n\tae.bylength = (u8)sizeof(struct atto_vda_ae_hdr);\n\n\tif (pwr_mgt) {\n\t\tesas2r_hdebug(\"*** sending power management AE ***\");\n\t} else {\n\t\tesas2r_hdebug(\"*** sending reset AE ***\");\n\t}\n\n\tesas2r_queue_fw_event(a, fw_event_vda_ae, &ae,\n\t\t\t      sizeof(union atto_vda_ae));\n}\n\nvoid esas2r_dummy_complete(struct esas2r_adapter *a, struct esas2r_request *rq)\n{}\n\nstatic void esas2r_check_req_rsp_sense(struct esas2r_adapter *a,\n\t\t\t\t       struct esas2r_request *rq)\n{\n\tu8 snslen, snslen2;\n\n\tsnslen = snslen2 = rq->func_rsp.scsi_rsp.sense_len;\n\n\tif (snslen > rq->sense_len)\n\t\tsnslen = rq->sense_len;\n\n\tif (snslen) {\n\t\tif (rq->sense_buf)\n\t\t\tmemcpy(rq->sense_buf, rq->data_buf, snslen);\n\t\telse\n\t\t\trq->sense_buf = (u8 *)rq->data_buf;\n\n\t\t \n\t\tif (snslen2 > 0x0c) {\n\t\t\tu8 *s = (u8 *)rq->data_buf;\n\n\t\t\tesas2r_trace_enter();\n\n\t\t\t \n\t\t\tif (s[0x0c] == 0x3f && s[0x0d] == 0x0E) {\n\t\t\t\tesas2r_trace(\"rq->target_id: %d\",\n\t\t\t\t\t     rq->target_id);\n\t\t\t\tesas2r_target_state_changed(a, rq->target_id,\n\t\t\t\t\t\t\t    TS_LUN_CHANGE);\n\t\t\t}\n\n\t\t\tesas2r_trace(\"add_sense_key=%x\", s[0x0c]);\n\t\t\tesas2r_trace(\"add_sense_qual=%x\", s[0x0d]);\n\t\t\tesas2r_trace_exit();\n\t\t}\n\t}\n\n\trq->sense_len = snslen;\n}\n\n\nvoid esas2r_complete_request(struct esas2r_adapter *a,\n\t\t\t     struct esas2r_request *rq)\n{\n\tif (rq->vrq->scsi.function == VDA_FUNC_FLASH\n\t    && rq->vrq->flash.sub_func == VDA_FLASH_COMMIT)\n\t\tclear_bit(AF_FLASHING, &a->flags);\n\n\t \n\n\tif (rq->interrupt_cb) {\n\t\t(*rq->interrupt_cb)(a, rq);\n\n\t\tif (rq->req_stat == RS_PENDING) {\n\t\t\tesas2r_start_request(a, rq);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (likely(rq->vrq->scsi.function == VDA_FUNC_SCSI)\n\t    && unlikely(rq->req_stat != RS_SUCCESS)) {\n\t\tesas2r_check_req_rsp_sense(a, rq);\n\t\tesas2r_log_request_failure(a, rq);\n\t}\n\n\t(*rq->comp_cb)(a, rq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}