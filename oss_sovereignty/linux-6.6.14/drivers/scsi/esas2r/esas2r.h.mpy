{
  "module_name": "esas2r.h",
  "hash_id": "ef5939384aba185988d1d41a749b429f6ae7299d29862747f1d02c53e890c319",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/esas2r/esas2r.h",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/proc_fs.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_tcq.h>\n\n#include \"esas2r_log.h\"\n#include \"atioctl.h\"\n#include \"atvda.h\"\n\n#ifndef ESAS2R_H\n#define ESAS2R_H\n\n \nextern struct esas2r_adapter *esas2r_adapters[];\nextern u8 *esas2r_buffered_ioctl;\nextern dma_addr_t esas2r_buffered_ioctl_addr;\nextern u32 esas2r_buffered_ioctl_size;\nextern struct pci_dev *esas2r_buffered_ioctl_pcid;\n#define SGL_PG_SZ_MIN   64\n#define SGL_PG_SZ_MAX   1024\nextern int sgl_page_size;\n#define NUM_SGL_MIN     8\n#define NUM_SGL_MAX     2048\nextern int num_sg_lists;\n#define NUM_REQ_MIN     4\n#define NUM_REQ_MAX     256\nextern int num_requests;\n#define NUM_AE_MIN      2\n#define NUM_AE_MAX      8\nextern int num_ae_requests;\nextern int cmd_per_lun;\nextern int can_queue;\nextern int esas2r_max_sectors;\nextern int sg_tablesize;\nextern int interrupt_mode;\nextern int num_io_requests;\n\n \n#define ESAS2R_MAX_ID        255\n#define MAX_ADAPTERS         32\n#define ESAS2R_DRVR_NAME     \"esas2r\"\n#define ESAS2R_LONGNAME      \"ATTO ExpressSAS 6GB RAID Adapter\"\n#define ESAS2R_MAX_DEVICES     32\n#define ATTONODE_NAME         \"ATTONode\"\n#define ESAS2R_MAJOR_REV       1\n#define ESAS2R_MINOR_REV       00\n#define ESAS2R_VERSION_STR     DEFINED_NUM_TO_STR(ESAS2R_MAJOR_REV) \".\" \\\n\tDEFINED_NUM_TO_STR(ESAS2R_MINOR_REV)\n#define ESAS2R_COPYRIGHT_YEARS \"2001-2013\"\n#define ESAS2R_DEFAULT_SGL_PAGE_SIZE 384\n#define ESAS2R_DEFAULT_CMD_PER_LUN   64\n#define ESAS2R_DEFAULT_NUM_SG_LISTS 1024\n#define DEFINED_NUM_TO_STR(num) NUM_TO_STR(num)\n#define NUM_TO_STR(num) #num\n\n#define ESAS2R_SGL_ALIGN    16\n#define ESAS2R_LIST_ALIGN   16\n#define ESAS2R_LIST_EXTRA   ESAS2R_NUM_EXTRA\n#define ESAS2R_DATA_BUF_LEN         256\n#define ESAS2R_DEFAULT_TMO          5000\n#define ESAS2R_DISC_BUF_LEN         512\n#define ESAS2R_FWCOREDUMP_SZ        0x80000\n#define ESAS2R_NUM_PHYS             8\n#define ESAS2R_TARG_ID_INV          0xFFFF\n#define ESAS2R_INT_STS_MASK         MU_INTSTAT_MASK\n#define ESAS2R_INT_ENB_MASK         MU_INTSTAT_MASK\n#define ESAS2R_INT_DIS_MASK         0\n#define ESAS2R_MAX_TARGETS          256\n#define ESAS2R_KOBJ_NAME_LEN        20\n\n \n#define LOBYTE(w) ((u8)(u16)(w))\n#define HIBYTE(w) ((u8)(((u16)(w)) >> 8))\n#define MAKEWORD(lo, hi) ((u16)((u8)(lo) | ((u16)(u8)(hi) << 8)))\n\n \n#define LOWORD(d) ((u16)(u32)(d))\n#define HIWORD(d) ((u16)(((u32)(d)) >> 16))\n#define MAKEDWORD(lo, hi) ((u32)((u16)(lo) | ((u32)(u16)(hi) << 16)))\n\n \n#define LOBIT(x) ((x) & (0 - (x)))\n\n \n#define esas2r_read_register_dword(a, reg)                             \\\n\treadl((void __iomem *)a->regs + (reg) + MW_REG_OFFSET_HWREG)\n\n#define esas2r_write_register_dword(a, reg, data)                      \\\n\twritel(data, (void __iomem *)(a->regs + (reg) + MW_REG_OFFSET_HWREG))\n\n#define esas2r_flush_register_dword(a, r) esas2r_read_register_dword(a, r)\n\n \n#define esas2r_read_data_byte(a, reg)                                  \\\n\treadb((void __iomem *)a->data_window + (reg))\n\n \n#define ATTO_VENDOR_ID          0x117C\n#define ATTO_DID_INTEL_IOP348   0x002C\n#define ATTO_DID_MV_88RC9580    0x0049\n#define ATTO_DID_MV_88RC9580TS  0x0066\n#define ATTO_DID_MV_88RC9580TSE 0x0067\n#define ATTO_DID_MV_88RC9580TL  0x0068\n\n \n#define ATTO_SSDID_TBT      0x4000\n#define ATTO_TSSC_3808      0x4066\n#define ATTO_TSSC_3808E     0x4067\n#define ATTO_TLSH_1068      0x4068\n#define ATTO_ESAS_R680      0x0049\n#define ATTO_ESAS_R608      0x004A\n#define ATTO_ESAS_R60F      0x004B\n#define ATTO_ESAS_R6F0      0x004C\n#define ATTO_ESAS_R644      0x004D\n#define ATTO_ESAS_R648      0x004E\n\n \n#define FBT_CPYR        0xAA00\n#define FBT_SETUP       0xAA02\n#define FBT_FLASH_VER   0xAA04\n\n \n#define FLS_OFFSET_BOOT (u32)(0x00700000)\n#define FLS_OFFSET_NVR  (u32)(0x007C0000)\n#define FLS_OFFSET_CPYR FLS_OFFSET_NVR\n#define FLS_LENGTH_BOOT (FLS_OFFSET_CPYR - FLS_OFFSET_BOOT)\n#define FLS_BLOCK_SIZE  (u32)(0x00020000)\n#define FI_NVR_2KB  0x0800\n#define FI_NVR_8KB  0x2000\n#define FM_BUF_SZ   0x800\n\n \n#define MVR_FREY_B2     0xB2\n\n \n#define MW_REG_WINDOW_SIZE      (u32)(0x00040000)\n#define MW_REG_OFFSET_HWREG     (u32)(0x00000000)\n#define MW_REG_OFFSET_PCI       (u32)(0x00008000)\n#define MW_REG_PCI_HWREG_DELTA  (MW_REG_OFFSET_PCI - MW_REG_OFFSET_HWREG)\n#define MW_DATA_WINDOW_SIZE     (u32)(0x00020000)\n#define MW_DATA_ADDR_SER_FLASH  (u32)(0xEC000000)\n#define MW_DATA_ADDR_SRAM       (u32)(0xF4000000)\n#define MW_DATA_ADDR_PAR_FLASH  (u32)(0xFC000000)\n\n \n#define MU_IN_LIST_ADDR_LO      (u32)(0x00004000)\n#define MU_IN_LIST_ADDR_HI      (u32)(0x00004004)\n\n#define MU_IN_LIST_WRITE        (u32)(0x00004018)\n    #define MU_ILW_TOGGLE       (u32)(0x00004000)\n\n#define MU_IN_LIST_READ         (u32)(0x0000401C)\n    #define MU_ILR_TOGGLE       (u32)(0x00004000)\n    #define MU_ILIC_LIST        (u32)(0x0000000F)\n    #define MU_ILIC_LIST_F0     (u32)(0x00000000)\n    #define MU_ILIC_DEST        (u32)(0x00000F00)\n    #define MU_ILIC_DEST_DDR    (u32)(0x00000200)\n#define MU_IN_LIST_IFC_CONFIG   (u32)(0x00004028)\n\n#define MU_IN_LIST_CONFIG       (u32)(0x0000402C)\n    #define MU_ILC_ENABLE       (u32)(0x00000001)\n    #define MU_ILC_ENTRY_MASK   (u32)(0x000000F0)\n    #define MU_ILC_ENTRY_4_DW   (u32)(0x00000020)\n    #define MU_ILC_DYNAMIC_SRC  (u32)(0x00008000)\n    #define MU_ILC_NUMBER_MASK  (u32)(0x7FFF0000)\n    #define MU_ILC_NUMBER_SHIFT            16\n\n#define MU_OUT_LIST_ADDR_LO     (u32)(0x00004050)\n#define MU_OUT_LIST_ADDR_HI     (u32)(0x00004054)\n\n#define MU_OUT_LIST_COPY_PTR_LO (u32)(0x00004058)\n#define MU_OUT_LIST_COPY_PTR_HI (u32)(0x0000405C)\n\n#define MU_OUT_LIST_WRITE       (u32)(0x00004068)\n    #define MU_OLW_TOGGLE       (u32)(0x00004000)\n\n#define MU_OUT_LIST_COPY        (u32)(0x0000406C)\n    #define MU_OLC_TOGGLE       (u32)(0x00004000)\n    #define MU_OLC_WRT_PTR      (u32)(0x00003FFF)\n\n#define MU_OUT_LIST_IFC_CONFIG  (u32)(0x00004078)\n    #define MU_OLIC_LIST        (u32)(0x0000000F)\n    #define MU_OLIC_LIST_F0     (u32)(0x00000000)\n    #define MU_OLIC_SOURCE      (u32)(0x00000F00)\n    #define MU_OLIC_SOURCE_DDR  (u32)(0x00000200)\n\n#define MU_OUT_LIST_CONFIG      (u32)(0x0000407C)\n    #define MU_OLC_ENABLE       (u32)(0x00000001)\n    #define MU_OLC_ENTRY_MASK   (u32)(0x000000F0)\n    #define MU_OLC_ENTRY_4_DW   (u32)(0x00000020)\n    #define MU_OLC_NUMBER_MASK  (u32)(0x7FFF0000)\n    #define MU_OLC_NUMBER_SHIFT            16\n\n#define MU_OUT_LIST_INT_STAT    (u32)(0x00004088)\n    #define MU_OLIS_INT         (u32)(0x00000001)\n\n#define MU_OUT_LIST_INT_MASK    (u32)(0x0000408C)\n    #define MU_OLIS_MASK        (u32)(0x00000001)\n\n \n#define ESAS2R_MAX_NUM_REQS         256\n#define ESAS2R_NUM_EXTRA            2\n#define ESAS2R_MAX_COMM_LIST_SIZE   (ESAS2R_MAX_NUM_REQS + ESAS2R_NUM_EXTRA)\n\n \n#define MU_CTL_STATUS_IN        (u32)(0x00010108)\n    #define MU_CTL_IN_FULL_RST  (u32)(0x00000020)\n#define MU_CTL_STATUS_IN_B2     (u32)(0x00010130)\n    #define MU_CTL_IN_FULL_RST2 (u32)(0x80000000)\n#define MU_DOORBELL_IN          (u32)(0x00010460)\n    #define DRBL_RESET_BUS      (u32)(0x00000002)\n    #define DRBL_PAUSE_AE       (u32)(0x00000004)\n    #define DRBL_RESUME_AE      (u32)(0x00000008)\n    #define DRBL_MSG_IFC_DOWN   (u32)(0x00000010)\n    #define DRBL_FLASH_REQ      (u32)(0x00000020)\n    #define DRBL_FLASH_DONE     (u32)(0x00000040)\n    #define DRBL_FORCE_INT      (u32)(0x00000080)\n    #define DRBL_MSG_IFC_INIT   (u32)(0x00000100)\n    #define DRBL_POWER_DOWN     (u32)(0x00000200)\n    #define DRBL_DRV_VER_1      (u32)(0x00010000)\n    #define DRBL_DRV_VER        DRBL_DRV_VER_1\n#define MU_DOORBELL_IN_ENB      (u32)(0x00010464)\n#define MU_DOORBELL_OUT         (u32)(0x00010480)\n #define DRBL_PANIC_REASON_MASK (u32)(0x00F00000)\n    #define DRBL_UNUSED_HANDLER (u32)(0x00100000)\n    #define DRBL_UNDEF_INSTR    (u32)(0x00200000)\n    #define DRBL_PREFETCH_ABORT (u32)(0x00300000)\n    #define DRBL_DATA_ABORT     (u32)(0x00400000)\n    #define DRBL_JUMP_TO_ZERO   (u32)(0x00500000)\n  #define DRBL_FW_RESET         (u32)(0x00080000)\n  #define DRBL_FW_VER_MSK       (u32)(0x00070000)\n  #define DRBL_FW_VER_0         (u32)(0x00000000)\n  #define DRBL_FW_VER_1         (u32)(0x00010000)\n  #define DRBL_FW_VER           DRBL_FW_VER_1\n#define MU_DOORBELL_OUT_ENB     (u32)(0x00010484)\n    #define DRBL_ENB_MASK       (u32)(0x00F803FF)\n#define MU_INT_STATUS_OUT       (u32)(0x00010200)\n    #define MU_INTSTAT_POST_OUT (u32)(0x00000010)\n    #define MU_INTSTAT_DRBL_IN  (u32)(0x00000100)\n    #define MU_INTSTAT_DRBL     (u32)(0x00001000)\n    #define MU_INTSTAT_MASK     (u32)(0x00001010)\n#define MU_INT_MASK_OUT         (u32)(0x0001020C)\n\n \n#define MVR_PCI_WIN1_REMAP      (u32)(0x00008438)\n    #define MVRPW1R_ENABLE      (u32)(0x00000001)\n\n\n \n\n \nstruct esas2r_inbound_list_source_entry {\n\tu64 address;\n\tu32 length;\n\t#define HWILSE_INTERFACE_F0  0x00000000\n\tu32 reserved;\n};\n\n \nstruct __packed esas2r_boot_header {\n\tchar signature[4];\n\tu16 vendor_id;\n\tu16 device_id;\n\tu16 VPD;\n\tu16 struct_length;\n\tu8 struct_revision;\n\tu8 class_code[3];\n\tu16 image_length;\n\tu16 code_revision;\n\tu8 code_type;\n\t#define CODE_TYPE_PC    0\n\t#define CODE_TYPE_OPEN  1\n\t#define CODE_TYPE_EFI   3\n\tu8 indicator;\n\t#define INDICATOR_LAST  0x80\n\tu8 reserved[2];\n};\n\nstruct __packed esas2r_boot_image {\n\tu16 signature;\n\tu8 reserved[22];\n\tu16 header_offset;\n\tu16 pnp_offset;\n};\n\nstruct __packed esas2r_pc_image {\n\tu16 signature;\n\tu8 length;\n\tu8 entry_point[3];\n\tu8 checksum;\n\tu16 image_end;\n\tu16 min_size;\n\tu8 rom_flags;\n\tu8 reserved[12];\n\tu16 header_offset;\n\tu16 pnp_offset;\n\tstruct esas2r_boot_header boot_image;\n};\n\nstruct __packed esas2r_efi_image {\n\tu16 signature;\n\tu16 length;\n\tu32 efi_signature;\n\t#define EFI_ROM_SIG     0x00000EF1\n\tu16 image_type;\n\t#define EFI_IMAGE_APP   10\n\t#define EFI_IMAGE_BSD   11\n\t#define EFI_IMAGE_RTD   12\n\tu16 machine_type;\n\t#define EFI_MACHINE_IA32 0x014c\n\t#define EFI_MACHINE_IA64 0x0200\n\t#define EFI_MACHINE_X64  0x8664\n\t#define EFI_MACHINE_EBC  0x0EBC\n\tu16 compression;\n\t#define EFI_UNCOMPRESSED 0x0000\n\t#define EFI_COMPRESSED   0x0001\n\tu8 reserved[8];\n\tu16 efi_offset;\n\tu16 header_offset;\n\tu16 reserved2;\n\tstruct esas2r_boot_header boot_image;\n};\n\nstruct esas2r_adapter;\nstruct esas2r_sg_context;\nstruct esas2r_request;\n\ntypedef void (*RQCALLBK)     (struct esas2r_adapter *a,\n\t\t\t      struct esas2r_request *rq);\ntypedef bool (*RQBUILDSGL)   (struct esas2r_adapter *a,\n\t\t\t      struct esas2r_sg_context *sgc);\n\nstruct esas2r_component_header {\n\tu8 img_type;\n\t#define CH_IT_FW    0x00\n\t#define CH_IT_NVR   0x01\n\t#define CH_IT_BIOS  0x02\n\t#define CH_IT_MAC   0x03\n\t#define CH_IT_CFG   0x04\n\t#define CH_IT_EFI   0x05\n\tu8 status;\n\t#define CH_STAT_PENDING 0xff\n\t#define CH_STAT_FAILED  0x00\n\t#define CH_STAT_SUCCESS 0x01\n\t#define CH_STAT_RETRY   0x02\n\t#define CH_STAT_INVALID 0x03\n\tu8 pad[2];\n\tu32 version;\n\tu32 length;\n\tu32 image_offset;\n};\n\n#define FI_REL_VER_SZ   16\n\nstruct esas2r_flash_img_v0 {\n\tu8 fi_version;\n\t#define FI_VERSION_0    00\n\tu8 status;\n\tu8 adap_typ;\n\tu8 action;\n\tu32 length;\n\tu16 checksum;\n\tu16 driver_error;\n\tu16 flags;\n\tu16 num_comps;\n\t#define FI_NUM_COMPS_V0 5\n\tu8 rel_version[FI_REL_VER_SZ];\n\tstruct esas2r_component_header cmp_hdr[FI_NUM_COMPS_V0];\n\tu8 scratch_buf[FM_BUF_SZ];\n};\n\nstruct esas2r_flash_img {\n\tu8 fi_version;\n\t#define FI_VERSION_1    01\n\tu8 status;\n\t#define FI_STAT_SUCCESS  0x00\n\t#define FI_STAT_FAILED   0x01\n\t#define FI_STAT_REBOOT   0x02\n\t#define FI_STAT_ADAPTYP  0x03\n\t#define FI_STAT_INVALID  0x04\n\t#define FI_STAT_CHKSUM   0x05\n\t#define FI_STAT_LENGTH   0x06\n\t#define FI_STAT_UNKNOWN  0x07\n\t#define FI_STAT_IMG_VER  0x08\n\t#define FI_STAT_BUSY     0x09\n\t#define FI_STAT_DUAL     0x0A\n\t#define FI_STAT_MISSING  0x0B\n\t#define FI_STAT_UNSUPP   0x0C\n\t#define FI_STAT_ERASE    0x0D\n\t#define FI_STAT_FLASH    0x0E\n\t#define FI_STAT_DEGRADED 0x0F\n\tu8 adap_typ;\n\t#define FI_AT_UNKNWN    0xFF\n\t#define FI_AT_SUN_LAKE  0x0B\n\t#define FI_AT_MV_9580   0x0F\n\tu8 action;\n\t#define FI_ACT_DOWN     0x00\n\t#define FI_ACT_UP       0x01\n\t#define FI_ACT_UPSZ     0x02\n\t#define FI_ACT_MAX      0x02\n\t#define FI_ACT_DOWN1    0x80\n\tu32 length;\n\tu16 checksum;\n\tu16 driver_error;\n\tu16 flags;\n\t#define FI_FLG_NVR_DEF  0x0001\n\tu16 num_comps;\n\t#define FI_NUM_COMPS_V1 6\n\tu8 rel_version[FI_REL_VER_SZ];\n\tstruct esas2r_component_header cmp_hdr[FI_NUM_COMPS_V1];\n\tu8 scratch_buf[FM_BUF_SZ];\n};\n\n \nstruct esas2r_ioctlfs_command {\n\tu8 command;\n\t#define ESAS2R_FS_CMD_ERASE    0\n\t#define ESAS2R_FS_CMD_READ     1\n\t#define ESAS2R_FS_CMD_BEGINW   2\n\t#define ESAS2R_FS_CMD_WRITE    3\n\t#define ESAS2R_FS_CMD_COMMIT   4\n\t#define ESAS2R_FS_CMD_CANCEL   5\n\tu8 checksum;\n\tu8 reserved[2];\n\tu32 flash_addr;\n\tu32 length;\n\tu32 image_offset;\n};\n\nstruct esas2r_ioctl_fs {\n\tu8 version;\n\t#define ESAS2R_FS_VER      0\n\tu8 status;\n\tu8 driver_error;\n\tu8 adap_type;\n\t#define ESAS2R_FS_AT_ESASRAID2     3\n\t#define ESAS2R_FS_AT_TSSASRAID2    4\n\t#define ESAS2R_FS_AT_TSSASRAID2E   5\n\t#define ESAS2R_FS_AT_TLSASHBA      6\n\tu8 driver_ver;\n\tu8 reserved[11];\n\tstruct esas2r_ioctlfs_command command;\n\tu8 data[1];\n};\n\nstruct esas2r_sas_nvram {\n\tu8 signature[4];\n\tu8 version;\n\t#define SASNVR_VERSION_0    0x00\n\t#define SASNVR_VERSION      SASNVR_VERSION_0\n\tu8 checksum;\n\t#define SASNVR_CKSUM_SEED   0x5A\n\tu8 max_lun_for_target;\n\tu8 pci_latency;\n\t#define SASNVR_PCILAT_DIS   0x00\n\t#define SASNVR_PCILAT_MIN   0x10\n\t#define SASNVR_PCILAT_MAX   0xF8\n\tu8 options1;\n\t#define SASNVR1_BOOT_DRVR   0x01\n\t#define SASNVR1_BOOT_SCAN   0x02\n\t#define SASNVR1_DIS_PCI_MWI 0x04\n\t#define SASNVR1_FORCE_ORD_Q 0x08\n\t#define SASNVR1_CACHELINE_0 0x10\n\t#define SASNVR1_DIS_DEVSORT 0x20\n\t#define SASNVR1_PWR_MGT_EN  0x40\n\t#define SASNVR1_WIDEPORT    0x80\n\tu8 options2;\n\t#define SASNVR2_SINGLE_BUS  0x01\n\t#define SASNVR2_SLOT_BIND   0x02\n\t#define SASNVR2_EXP_PROG    0x04\n\t#define SASNVR2_CMDTHR_LUN  0x08\n\t#define SASNVR2_HEARTBEAT   0x10\n\t#define SASNVR2_INT_CONNECT 0x20\n\t#define SASNVR2_SW_MUX_CTRL 0x40\n\t#define SASNVR2_DISABLE_NCQ 0x80\n\tu8 int_coalescing;\n\t#define SASNVR_COAL_DIS     0x00\n\t#define SASNVR_COAL_LOW     0x01\n\t#define SASNVR_COAL_MED     0x02\n\t#define SASNVR_COAL_HI      0x03\n\tu8 cmd_throttle;\n\t#define SASNVR_CMDTHR_NONE  0x00\n\tu8 dev_wait_time;\n\tu8 dev_wait_count;\n\tu8 spin_up_delay;\n\t#define SASNVR_SPINUP_MAX   0x14\n\tu8 ssp_align_rate;\n\tu8 sas_addr[8];\n\tu8 phy_speed[16];\n\t#define SASNVR_SPEED_AUTO   0x00\n\t#define SASNVR_SPEED_1_5GB  0x01\n\t#define SASNVR_SPEED_3GB    0x02\n\t#define SASNVR_SPEED_6GB    0x03\n\t#define SASNVR_SPEED_12GB   0x04\n\tu8 phy_mux[16];\n\t#define SASNVR_MUX_DISABLED 0x00\n\t#define SASNVR_MUX_1_5GB    0x01\n\t#define SASNVR_MUX_3GB      0x02\n\t#define SASNVR_MUX_6GB      0x03\n\tu8 phy_flags[16];\n\t#define SASNVR_PHF_DISABLED 0x01\n\t#define SASNVR_PHF_RD_ONLY  0x02\n\tu8 sort_type;\n\t#define SASNVR_SORT_SAS_ADDR    0x00\n\t#define SASNVR_SORT_H308_CONN   0x01\n\t#define SASNVR_SORT_PHY_ID      0x02\n\t#define SASNVR_SORT_SLOT_ID     0x03\n\tu8 dpm_reqcmd_lmt;\n\tu8 dpm_stndby_time;\n\tu8 dpm_active_time;\n\tu8 phy_target_id[16];\n\t#define SASNVR_PTI_DISABLED     0xFF\n\tu8 virt_ses_mode;\n\t#define SASNVR_VSMH_DISABLED    0x00\n\tu8 read_write_mode;\n\t#define SASNVR_RWM_DEFAULT      0x00\n\tu8 link_down_to;\n\tu8 reserved[0xA1];\n};\n\ntypedef u32 (*PGETPHYSADDR) (struct esas2r_sg_context *sgc, u64 *addr);\n\nstruct esas2r_sg_context {\n\tstruct esas2r_adapter *adapter;\n\tstruct esas2r_request *first_req;\n\tu32 length;\n\tu8 *cur_offset;\n\tPGETPHYSADDR get_phys_addr;\n\tunion {\n\t\tstruct {\n\t\t\tstruct atto_vda_sge *curr;\n\t\t\tstruct atto_vda_sge *last;\n\t\t\tstruct atto_vda_sge *limit;\n\t\t\tstruct atto_vda_sge *chain;\n\t\t} a64;\n\t\tstruct {\n\t\t\tstruct atto_physical_region_description *curr;\n\t\t\tstruct atto_physical_region_description *chain;\n\t\t\tu32 sgl_max_cnt;\n\t\t\tu32 sge_cnt;\n\t\t} prd;\n\t} sge;\n\tstruct scatterlist *cur_sgel;\n\tu8 *exp_offset;\n\tint num_sgel;\n\tint sgel_count;\n};\n\nstruct esas2r_target {\n\tu8 flags;\n\t#define TF_PASS_THRU    0x01\n\t#define TF_USED         0x02\n\tu8 new_target_state;\n\tu8 target_state;\n\tu8 buffered_target_state;\n#define TS_NOT_PRESENT      0x00\n#define TS_PRESENT          0x05\n#define TS_LUN_CHANGE       0x06\n#define TS_INVALID          0xFF\n\tu32 block_size;\n\tu32 inter_block;\n\tu32 inter_byte;\n\tu16 virt_targ_id;\n\tu16 phys_targ_id;\n\tu8 identifier_len;\n\tu64 sas_addr;\n\tu8 identifier[60];\n\tstruct atto_vda_ae_lu lu_event;\n};\n\nstruct esas2r_request {\n\tstruct list_head comp_list;\n\tstruct list_head req_list;\n\tunion atto_vda_req *vrq;\n\tstruct esas2r_mem_desc *vrq_md;\n\tunion {\n\t\tvoid *data_buf;\n\t\tunion atto_vda_rsp_data *vda_rsp_data;\n\t};\n\tu8 *sense_buf;\n\tstruct list_head sg_table_head;\n\tstruct esas2r_mem_desc *sg_table;\n\tu32 timeout;\n\t#define RQ_TIMEOUT_S1     0xFFFFFFFF\n\t#define RQ_TIMEOUT_S2     0xFFFFFFFE\n\t#define RQ_MAX_TIMEOUT    0xFFFFFFFD\n\tu16 target_id;\n\tu8 req_type;\n\t#define RT_INI_REQ          0x01\n\t#define RT_DISC_REQ         0x02\n\tu8 sense_len;\n\tunion atto_vda_func_rsp func_rsp;\n\tRQCALLBK comp_cb;\n\tRQCALLBK interrupt_cb;\n\tvoid *interrupt_cx;\n\tu8 flags;\n\t#define RF_1ST_IBLK_BASE    0x04\n\t#define RF_FAILURE_OK       0x08\n\tu8 req_stat;\n\tu16 vda_req_sz;\n\t#define RQ_SIZE_DEFAULT   0\n\tu64 lba;\n\tRQCALLBK aux_req_cb;\n\tvoid *aux_req_cx;\n\tu32 blk_len;\n\tu32 max_blk_len;\n\tunion {\n\t\tstruct scsi_cmnd *cmd;\n\t\tu8 *task_management_status_ptr;\n\t};\n};\n\nstruct esas2r_flash_context {\n\tstruct esas2r_flash_img *fi;\n\tRQCALLBK interrupt_cb;\n\tu8 *sgc_offset;\n\tu8 *scratch;\n\tu32 fi_hdr_len;\n\tu8 task;\n\t#define     FMTSK_ERASE_BOOT    0\n\t#define     FMTSK_WRTBIOS       1\n\t#define     FMTSK_READBIOS      2\n\t#define     FMTSK_WRTMAC        3\n\t#define     FMTSK_READMAC       4\n\t#define     FMTSK_WRTEFI        5\n\t#define     FMTSK_READEFI       6\n\t#define     FMTSK_WRTCFG        7\n\t#define     FMTSK_READCFG       8\n\tu8 func;\n\tu16 num_comps;\n\tu32 cmp_len;\n\tu32 flsh_addr;\n\tu32 curr_len;\n\tu8 comp_typ;\n\tstruct esas2r_sg_context sgc;\n};\n\nstruct esas2r_disc_context {\n\tu8 disc_evt;\n\t#define DCDE_DEV_CHANGE     0x01\n\t#define DCDE_DEV_SCAN       0x02\n\tu8 state;\n\t#define DCS_DEV_RMV         0x00\n\t#define DCS_DEV_ADD         0x01\n\t#define DCS_BLOCK_DEV_SCAN  0x02\n\t#define DCS_RAID_GRP_INFO   0x03\n\t#define DCS_PART_INFO       0x04\n\t#define DCS_PT_DEV_INFO     0x05\n\t#define DCS_PT_DEV_ADDR     0x06\n\t#define DCS_DISC_DONE       0xFF\n\tu16 flags;\n\t#define DCF_DEV_CHANGE      0x0001\n\t#define DCF_DEV_SCAN        0x0002\n\t#define DCF_POLLED          0x8000\n\tu32 interleave;\n\tu32 block_size;\n\tu16 dev_ix;\n\tu8 part_num;\n\tu8 raid_grp_ix;\n\tchar raid_grp_name[16];\n\tstruct esas2r_target *curr_targ;\n\tu16 curr_virt_id;\n\tu16 curr_phys_id;\n\tu8 scan_gen;\n\tu8 dev_addr_type;\n\tu64 sas_addr;\n};\n\nstruct esas2r_mem_desc {\n\tstruct list_head next_desc;\n\tvoid *virt_addr;\n\tu64 phys_addr;\n\tvoid *pad;\n\tvoid *esas2r_data;\n\tu32 esas2r_param;\n\tu32 size;\n};\n\nenum fw_event_type {\n\tfw_event_null,\n\tfw_event_lun_change,\n\tfw_event_present,\n\tfw_event_not_present,\n\tfw_event_vda_ae\n};\n\nstruct esas2r_vda_ae {\n\tu32 signature;\n#define ESAS2R_VDA_EVENT_SIG  0x4154544F\n\tu8 bus_number;\n\tu8 devfn;\n\tu8 pad[2];\n\tunion atto_vda_ae vda_ae;\n};\n\nstruct esas2r_fw_event_work {\n\tstruct list_head list;\n\tstruct delayed_work work;\n\tstruct esas2r_adapter *a;\n\tenum fw_event_type type;\n\tu8 data[sizeof(struct esas2r_vda_ae)];\n};\n\nenum state {\n\tFW_INVALID_ST,\n\tFW_STATUS_ST,\n\tFW_COMMAND_ST\n};\n\nstruct esas2r_firmware {\n\tenum state state;\n\tstruct esas2r_flash_img header;\n\tu8 *data;\n\tu64 phys;\n\tint orig_len;\n\tvoid *header_buff;\n\tu64 header_buff_phys;\n};\n\nstruct esas2r_adapter {\n\tstruct esas2r_target targetdb[ESAS2R_MAX_TARGETS];\n\tstruct esas2r_target *targetdb_end;\n\tunsigned char *regs;\n\tunsigned char *data_window;\n\tlong flags;\n\t#define AF_PORT_CHANGE      0\n\t#define AF_CHPRST_NEEDED    1\n\t#define AF_CHPRST_PENDING   2\n\t#define AF_CHPRST_DETECTED  3\n\t#define AF_BUSRST_NEEDED    4\n\t#define AF_BUSRST_PENDING   5\n\t#define AF_BUSRST_DETECTED  6\n\t#define AF_DISABLED         7\n\t#define AF_FLASH_LOCK       8\n\t#define AF_OS_RESET         9\n\t#define AF_FLASHING         10\n\t#define AF_POWER_MGT        11\n\t#define AF_NVR_VALID        12\n\t#define AF_DEGRADED_MODE    13\n\t#define AF_DISC_PENDING     14\n\t#define AF_TASKLET_SCHEDULED    15\n\t#define AF_HEARTBEAT        16\n\t#define AF_HEARTBEAT_ENB    17\n\t#define AF_NOT_PRESENT      18\n\t#define AF_CHPRST_STARTED   19\n\t#define AF_FIRST_INIT       20\n\t#define AF_POWER_DOWN       21\n\t#define AF_DISC_IN_PROG     22\n\t#define AF_COMM_LIST_TOGGLE 23\n\t#define AF_LEGACY_SGE_MODE  24\n\t#define AF_DISC_POLLED      25\n\tlong flags2;\n\t#define AF2_SERIAL_FLASH    0\n\t#define AF2_DEV_SCAN        1\n\t#define AF2_DEV_CNT_OK      2\n\t#define AF2_COREDUMP_AVAIL  3\n\t#define AF2_COREDUMP_SAVED  4\n\t#define AF2_VDA_POWER_DOWN  5\n\t#define AF2_THUNDERLINK     6\n\t#define AF2_THUNDERBOLT     7\n\t#define AF2_INIT_DONE       8\n\t#define AF2_INT_PENDING     9\n\t#define AF2_TIMER_TICK      10\n\t#define AF2_IRQ_CLAIMED     11\n\t#define AF2_MSI_ENABLED     12\n\tatomic_t disable_cnt;\n\tatomic_t dis_ints_cnt;\n\tu32 int_stat;\n\tu32 int_mask;\n\tu32 volatile *outbound_copy;\n\tstruct list_head avail_request;\n\tspinlock_t request_lock;\n\tspinlock_t sg_list_lock;\n\tspinlock_t queue_lock;\n\tspinlock_t mem_lock;\n\tstruct list_head free_sg_list_head;\n\tstruct esas2r_mem_desc *sg_list_mds;\n\tstruct list_head active_list;\n\tstruct list_head defer_list;\n\tstruct esas2r_request **req_table;\n\tunion {\n\t\tu16 prev_dev_cnt;\n\t\tu32 heartbeat_time;\n\t#define ESAS2R_HEARTBEAT_TIME       (3000)\n\t};\n\tu32 chip_uptime;\n\t#define ESAS2R_CHP_UPTIME_MAX       (60000)\n\t#define ESAS2R_CHP_UPTIME_CNT       (20000)\n\tu64 uncached_phys;\n\tu8 *uncached;\n\tstruct esas2r_sas_nvram *nvram;\n\tstruct esas2r_request general_req;\n\tu8 init_msg;\n\t#define ESAS2R_INIT_MSG_START       1\n\t#define ESAS2R_INIT_MSG_INIT        2\n\t#define ESAS2R_INIT_MSG_GET_INIT    3\n\t#define ESAS2R_INIT_MSG_REINIT      4\n\tu16 cmd_ref_no;\n\tu32 fw_version;\n\tu32 fw_build;\n\tu32 chip_init_time;\n\t#define ESAS2R_CHPRST_TIME         (180000)\n\t#define ESAS2R_CHPRST_WAIT_TIME    (2000)\n\tu32 last_tick_time;\n\tu32 window_base;\n\tRQBUILDSGL build_sgl;\n\tstruct esas2r_request *first_ae_req;\n\tu32 list_size;\n\tu32 last_write;\n\tu32 last_read;\n\tu16 max_vdareq_size;\n\tu16 disc_wait_cnt;\n\tstruct esas2r_mem_desc inbound_list_md;\n\tstruct esas2r_mem_desc outbound_list_md;\n\tstruct esas2r_disc_context disc_ctx;\n\tu8 *disc_buffer;\n\tu32 disc_start_time;\n\tu32 disc_wait_time;\n\tu32 flash_ver;\n\tchar flash_rev[16];\n\tchar fw_rev[16];\n\tchar image_type[16];\n\tstruct esas2r_flash_context flash_context;\n\tu32 num_targets_backend;\n\tu32 ioctl_tunnel;\n\tstruct tasklet_struct tasklet;\n\tstruct pci_dev *pcid;\n\tstruct Scsi_Host *host;\n\tunsigned int index;\n\tchar name[32];\n\tstruct timer_list timer;\n\tstruct esas2r_firmware firmware;\n\twait_queue_head_t nvram_waiter;\n\tint nvram_command_done;\n\twait_queue_head_t fm_api_waiter;\n\tint fm_api_command_done;\n\twait_queue_head_t vda_waiter;\n\tint vda_command_done;\n\tu8 *vda_buffer;\n\tu64 ppvda_buffer;\n#define VDA_BUFFER_HEADER_SZ (offsetof(struct atto_ioctl_vda, data))\n#define VDA_MAX_BUFFER_SIZE  (0x40000 + VDA_BUFFER_HEADER_SZ)\n\twait_queue_head_t fs_api_waiter;\n\tint fs_api_command_done;\n\tu64 ppfs_api_buffer;\n\tu8 *fs_api_buffer;\n\tu32 fs_api_buffer_size;\n\twait_queue_head_t buffered_ioctl_waiter;\n\tint buffered_ioctl_done;\n\tint uncached_size;\n\tstruct workqueue_struct *fw_event_q;\n\tstruct list_head fw_event_list;\n\tspinlock_t fw_event_lock;\n\tu8 fw_events_off;                        \n\tchar fw_event_q_name[ESAS2R_KOBJ_NAME_LEN];\n\t \n\tint intr_mode;\n#define INTR_MODE_LEGACY 0\n#define INTR_MODE_MSI    1\n#define INTR_MODE_MSIX   2\n\tstruct esas2r_sg_context fm_api_sgc;\n\tu8 *save_offset;\n\tstruct list_head vrq_mds_head;\n\tstruct esas2r_mem_desc *vrq_mds;\n\tint num_vrqs;\n\tstruct mutex fm_api_mutex;\n\tstruct mutex fs_api_mutex;\n\tstruct semaphore nvram_semaphore;\n\tstruct atto_ioctl *local_atto_ioctl;\n\tu8 fw_coredump_buff[ESAS2R_FWCOREDUMP_SZ];\n\tunsigned int sysfs_fw_created:1;\n\tunsigned int sysfs_fs_created:1;\n\tunsigned int sysfs_vda_created:1;\n\tunsigned int sysfs_hw_created:1;\n\tunsigned int sysfs_live_nvram_created:1;\n\tunsigned int sysfs_default_nvram_created:1;\n};\n\n \nconst char *esas2r_info(struct Scsi_Host *);\nint esas2r_write_params(struct esas2r_adapter *a, struct esas2r_request *rq,\n\t\t\tstruct esas2r_sas_nvram *data);\nint esas2r_ioctl_handler(void *hostdata, unsigned int cmd, void __user *arg);\nint esas2r_ioctl(struct scsi_device *dev, unsigned int cmd, void __user *arg);\nu8 handle_hba_ioctl(struct esas2r_adapter *a,\n\t\t    struct atto_ioctl *ioctl_hba);\nint esas2r_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd);\nint esas2r_show_info(struct seq_file *m, struct Scsi_Host *sh);\nlong esas2r_proc_ioctl(struct file *fp, unsigned int cmd, unsigned long arg);\n\n \nint esas2r_eh_abort(struct scsi_cmnd *cmd);\nint esas2r_device_reset(struct scsi_cmnd *cmd);\nint esas2r_host_reset(struct scsi_cmnd *cmd);\nint esas2r_bus_reset(struct scsi_cmnd *cmd);\nint esas2r_target_reset(struct scsi_cmnd *cmd);\n\n \nint esas2r_init_adapter(struct Scsi_Host *host, struct pci_dev *pcid,\n\t\t\tint index);\nint esas2r_read_fw(struct esas2r_adapter *a, char *buf, long off, int count);\nint esas2r_write_fw(struct esas2r_adapter *a, const char *buf, long off,\n\t\t    int count);\nint esas2r_read_vda(struct esas2r_adapter *a, char *buf, long off, int count);\nint esas2r_write_vda(struct esas2r_adapter *a, const char *buf, long off,\n\t\t     int count);\nint esas2r_read_fs(struct esas2r_adapter *a, char *buf, long off, int count);\nint esas2r_write_fs(struct esas2r_adapter *a, const char *buf, long off,\n\t\t    int count);\nvoid esas2r_adapter_tasklet(unsigned long context);\nirqreturn_t esas2r_interrupt(int irq, void *dev_id);\nirqreturn_t esas2r_msi_interrupt(int irq, void *dev_id);\nvoid esas2r_kickoff_timer(struct esas2r_adapter *a);\n\nextern const struct dev_pm_ops esas2r_pm_ops;\n\nvoid esas2r_fw_event_off(struct esas2r_adapter *a);\nvoid esas2r_fw_event_on(struct esas2r_adapter *a);\nbool esas2r_nvram_write(struct esas2r_adapter *a, struct esas2r_request *rq,\n\t\t\tstruct esas2r_sas_nvram *nvram);\nvoid esas2r_nvram_get_defaults(struct esas2r_adapter *a,\n\t\t\t       struct esas2r_sas_nvram *nvram);\nvoid esas2r_complete_request_cb(struct esas2r_adapter *a,\n\t\t\t\tstruct esas2r_request *rq);\nvoid esas2r_reset_detected(struct esas2r_adapter *a);\nvoid esas2r_target_state_changed(struct esas2r_adapter *ha, u16 targ_id,\n\t\t\t\t u8 state);\nint esas2r_req_status_to_error(u8 req_stat);\nvoid esas2r_kill_adapter(int i);\nvoid esas2r_free_request(struct esas2r_adapter *a, struct esas2r_request *rq);\nstruct esas2r_request *esas2r_alloc_request(struct esas2r_adapter *a);\nu32 esas2r_get_uncached_size(struct esas2r_adapter *a);\nbool esas2r_init_adapter_struct(struct esas2r_adapter *a,\n\t\t\t\tvoid **uncached_area);\nbool esas2r_check_adapter(struct esas2r_adapter *a);\nbool esas2r_init_adapter_hw(struct esas2r_adapter *a, bool init_poll);\nvoid esas2r_start_request(struct esas2r_adapter *a, struct esas2r_request *rq);\nbool esas2r_send_task_mgmt(struct esas2r_adapter *a,\n\t\t\t   struct esas2r_request *rqaux, u8 task_mgt_func);\nvoid esas2r_do_tasklet_tasks(struct esas2r_adapter *a);\nvoid esas2r_adapter_interrupt(struct esas2r_adapter *a);\nvoid esas2r_do_deferred_processes(struct esas2r_adapter *a);\nvoid esas2r_reset_bus(struct esas2r_adapter *a);\nvoid esas2r_reset_adapter(struct esas2r_adapter *a);\nvoid esas2r_timer_tick(struct esas2r_adapter *a);\nconst char *esas2r_get_model_name(struct esas2r_adapter *a);\nconst char *esas2r_get_model_name_short(struct esas2r_adapter *a);\nu32 esas2r_stall_execution(struct esas2r_adapter *a, u32 start_time,\n\t\t\t   u32 *delay);\nvoid esas2r_build_flash_req(struct esas2r_adapter *a,\n\t\t\t    struct esas2r_request *rq,\n\t\t\t    u8 sub_func,\n\t\t\t    u8 cksum,\n\t\t\t    u32 addr,\n\t\t\t    u32 length);\nvoid esas2r_build_mgt_req(struct esas2r_adapter *a,\n\t\t\t  struct esas2r_request *rq,\n\t\t\t  u8 sub_func,\n\t\t\t  u8 scan_gen,\n\t\t\t  u16 dev_index,\n\t\t\t  u32 length,\n\t\t\t  void *data);\nvoid esas2r_build_ae_req(struct esas2r_adapter *a, struct esas2r_request *rq);\nvoid esas2r_build_cli_req(struct esas2r_adapter *a,\n\t\t\t  struct esas2r_request *rq,\n\t\t\t  u32 length,\n\t\t\t  u32 cmd_rsp_len);\nvoid esas2r_build_ioctl_req(struct esas2r_adapter *a,\n\t\t\t    struct esas2r_request *rq,\n\t\t\t    u32 length,\n\t\t\t    u8 sub_func);\nvoid esas2r_build_cfg_req(struct esas2r_adapter *a,\n\t\t\t  struct esas2r_request *rq,\n\t\t\t  u8 sub_func,\n\t\t\t  u32 length,\n\t\t\t  void *data);\nvoid esas2r_power_down(struct esas2r_adapter *a);\nbool esas2r_power_up(struct esas2r_adapter *a, bool init_poll);\nvoid esas2r_wait_request(struct esas2r_adapter *a, struct esas2r_request *rq);\nu32 esas2r_map_data_window(struct esas2r_adapter *a, u32 addr_lo);\nbool esas2r_process_fs_ioctl(struct esas2r_adapter *a,\n\t\t\t     struct esas2r_ioctl_fs *fs,\n\t\t\t     struct esas2r_request *rq,\n\t\t\t     struct esas2r_sg_context *sgc);\nbool esas2r_read_flash_block(struct esas2r_adapter *a, void *to, u32 from,\n\t\t\t     u32 size);\nbool esas2r_read_mem_block(struct esas2r_adapter *a, void *to, u32 from,\n\t\t\t   u32 size);\nbool esas2r_fm_api(struct esas2r_adapter *a, struct esas2r_flash_img *fi,\n\t\t   struct esas2r_request *rq, struct esas2r_sg_context *sgc);\nvoid esas2r_force_interrupt(struct esas2r_adapter *a);\nvoid esas2r_local_start_request(struct esas2r_adapter *a,\n\t\t\t\tstruct esas2r_request *rq);\nvoid esas2r_process_adapter_reset(struct esas2r_adapter *a);\nvoid esas2r_complete_request(struct esas2r_adapter *a,\n\t\t\t     struct esas2r_request *rq);\nvoid esas2r_dummy_complete(struct esas2r_adapter *a,\n\t\t\t   struct esas2r_request *rq);\nvoid esas2r_ae_complete(struct esas2r_adapter *a, struct esas2r_request *rq);\nvoid esas2r_start_vda_request(struct esas2r_adapter *a,\n\t\t\t      struct esas2r_request *rq);\nbool esas2r_read_flash_rev(struct esas2r_adapter *a);\nbool esas2r_read_image_type(struct esas2r_adapter *a);\nbool esas2r_nvram_read_direct(struct esas2r_adapter *a);\nbool esas2r_nvram_validate(struct esas2r_adapter *a);\nvoid esas2r_nvram_set_defaults(struct esas2r_adapter *a);\nbool esas2r_print_flash_rev(struct esas2r_adapter *a);\nvoid esas2r_send_reset_ae(struct esas2r_adapter *a, bool pwr_mgt);\nbool esas2r_init_msgs(struct esas2r_adapter *a);\nbool esas2r_is_adapter_present(struct esas2r_adapter *a);\nvoid esas2r_nuxi_mgt_data(u8 function, void *data);\nvoid esas2r_nuxi_cfg_data(u8 function, void *data);\nvoid esas2r_nuxi_ae_data(union atto_vda_ae *ae);\nvoid esas2r_reset_chip(struct esas2r_adapter *a);\nvoid esas2r_log_request_failure(struct esas2r_adapter *a,\n\t\t\t\tstruct esas2r_request *rq);\nvoid esas2r_polled_interrupt(struct esas2r_adapter *a);\nbool esas2r_ioreq_aborted(struct esas2r_adapter *a, struct esas2r_request *rq,\n\t\t\t  u8 status);\nbool esas2r_build_sg_list_sge(struct esas2r_adapter *a,\n\t\t\t      struct esas2r_sg_context *sgc);\nbool esas2r_build_sg_list_prd(struct esas2r_adapter *a,\n\t\t\t      struct esas2r_sg_context *sgc);\nvoid esas2r_targ_db_initialize(struct esas2r_adapter *a);\nvoid esas2r_targ_db_remove_all(struct esas2r_adapter *a, bool notify);\nvoid esas2r_targ_db_report_changes(struct esas2r_adapter *a);\nstruct esas2r_target *esas2r_targ_db_add_raid(struct esas2r_adapter *a,\n\t\t\t\t\t      struct esas2r_disc_context *dc);\nstruct esas2r_target *esas2r_targ_db_add_pthru(struct esas2r_adapter *a,\n\t\t\t\t\t       struct esas2r_disc_context *dc,\n\t\t\t\t\t       u8 *ident,\n\t\t\t\t\t       u8 ident_len);\nvoid esas2r_targ_db_remove(struct esas2r_adapter *a, struct esas2r_target *t);\nstruct esas2r_target *esas2r_targ_db_find_by_sas_addr(struct esas2r_adapter *a,\n\t\t\t\t\t\t      u64 *sas_addr);\nstruct esas2r_target *esas2r_targ_db_find_by_ident(struct esas2r_adapter *a,\n\t\t\t\t\t\t   void *identifier,\n\t\t\t\t\t\t   u8 ident_len);\nu16 esas2r_targ_db_find_next_present(struct esas2r_adapter *a, u16 target_id);\nstruct esas2r_target *esas2r_targ_db_find_by_virt_id(struct esas2r_adapter *a,\n\t\t\t\t\t\t     u16 virt_id);\nu16 esas2r_targ_db_get_tgt_cnt(struct esas2r_adapter *a);\nvoid esas2r_disc_initialize(struct esas2r_adapter *a);\nvoid esas2r_disc_start_waiting(struct esas2r_adapter *a);\nvoid esas2r_disc_check_for_work(struct esas2r_adapter *a);\nvoid esas2r_disc_check_complete(struct esas2r_adapter *a);\nvoid esas2r_disc_queue_event(struct esas2r_adapter *a, u8 disc_evt);\nbool esas2r_disc_start_port(struct esas2r_adapter *a);\nvoid esas2r_disc_local_start_request(struct esas2r_adapter *a,\n\t\t\t\t     struct esas2r_request *rq);\nbool esas2r_set_degraded_mode(struct esas2r_adapter *a, char *error_str);\nbool esas2r_process_vda_ioctl(struct esas2r_adapter *a,\n\t\t\t      struct atto_ioctl_vda *vi,\n\t\t\t      struct esas2r_request *rq,\n\t\t\t      struct esas2r_sg_context *sgc);\nvoid esas2r_queue_fw_event(struct esas2r_adapter *a,\n\t\t\t   enum fw_event_type type,\n\t\t\t   void *data,\n\t\t\t   int data_sz);\n\n \n\n \nstatic inline struct esas2r_mem_desc *esas2r_alloc_sgl(struct esas2r_adapter *a)\n{\n\tunsigned long flags;\n\tstruct list_head *sgl;\n\tstruct esas2r_mem_desc *result = NULL;\n\n\tspin_lock_irqsave(&a->sg_list_lock, flags);\n\tif (likely(!list_empty(&a->free_sg_list_head))) {\n\t\tsgl = a->free_sg_list_head.next;\n\t\tresult = list_entry(sgl, struct esas2r_mem_desc, next_desc);\n\t\tlist_del_init(sgl);\n\t}\n\tspin_unlock_irqrestore(&a->sg_list_lock, flags);\n\n\treturn result;\n}\n\n \nstatic inline void esas2r_sgc_init(struct esas2r_sg_context *sgc,\n\t\t\t\t   struct esas2r_adapter *a,\n\t\t\t\t   struct esas2r_request *rq,\n\t\t\t\t   struct atto_vda_sge *first)\n{\n\tsgc->adapter = a;\n\tsgc->first_req = rq;\n\n\t \n\tsgc->sge.a64.limit = (struct atto_vda_sge *)((u8 *)rq->vrq\n\t\t\t\t\t\t     + (sizeof(union\n\t\t\t\t\t\t\t       atto_vda_req) /\n\t\t\t\t\t\t\t8)\n\t\t\t\t\t\t     - sizeof(struct\n\t\t\t\t\t\t\t      atto_vda_sge));\n\tif (first) {\n\t\tsgc->sge.a64.last =\n\t\t\tsgc->sge.a64.curr = first;\n\t\trq->vrq->scsi.sg_list_offset = (u8)\n\t\t\t\t\t       ((u8 *)first -\n\t\t\t\t\t\t(u8 *)rq->vrq);\n\t} else {\n\t\tsgc->sge.a64.last =\n\t\t\tsgc->sge.a64.curr = &rq->vrq->scsi.u.sge[0];\n\t\trq->vrq->scsi.sg_list_offset =\n\t\t\t(u8)offsetof(struct atto_vda_scsi_req, u.sge);\n\t}\n\tsgc->sge.a64.chain = NULL;\n}\n\nstatic inline void esas2r_rq_init_request(struct esas2r_request *rq,\n\t\t\t\t\t  struct esas2r_adapter *a)\n{\n\tunion atto_vda_req *vrq = rq->vrq;\n\n\tINIT_LIST_HEAD(&rq->sg_table_head);\n\trq->data_buf = (void *)(vrq + 1);\n\trq->interrupt_cb = NULL;\n\trq->comp_cb = esas2r_complete_request_cb;\n\trq->flags = 0;\n\trq->timeout = 0;\n\trq->req_stat = RS_PENDING;\n\trq->req_type = RT_INI_REQ;\n\n\t \n\trq->func_rsp.dwords[0] = 0;\n\trq->func_rsp.dwords[1] = 0;\n\n\t \n\trq->vda_req_sz = RQ_SIZE_DEFAULT;\n\n\t \n\n\tif (a->req_table[LOWORD(vrq->scsi.handle)]) {\n\t\tesas2r_bugon();\n\t}\n\n\t \n\ta->req_table[LOWORD(vrq->scsi.handle)] = rq;\n\n\t \n\tvrq->scsi.handle = (a->cmd_ref_no++ << 16) | (u16)vrq->scsi.handle;\n\n\t \n\tvrq->scsi.function = VDA_FUNC_SCSI;\n\tvrq->scsi.sense_len = SENSE_DATA_SZ;\n\n\t \n\tvrq->scsi.sg_list_offset = 0;\n\tvrq->scsi.chain_offset = 0;\n\tvrq->scsi.flags = 0;\n\tvrq->scsi.reserved = 0;\n\n\t \n\tvrq->scsi.ppsense_buf\n\t\t= cpu_to_le64(rq->vrq_md->phys_addr +\n\t\t\t      sizeof(union atto_vda_req));\n}\n\nstatic inline void esas2r_rq_free_sg_lists(struct esas2r_request *rq,\n\t\t\t\t\t   struct esas2r_adapter *a)\n{\n\tunsigned long flags;\n\n\tif (list_empty(&rq->sg_table_head))\n\t\treturn;\n\n\tspin_lock_irqsave(&a->sg_list_lock, flags);\n\tlist_splice_tail_init(&rq->sg_table_head, &a->free_sg_list_head);\n\tspin_unlock_irqrestore(&a->sg_list_lock, flags);\n}\n\nstatic inline void esas2r_rq_destroy_request(struct esas2r_request *rq,\n\t\t\t\t\t     struct esas2r_adapter *a)\n\n{\n\tesas2r_rq_free_sg_lists(rq, a);\n\ta->req_table[LOWORD(rq->vrq->scsi.handle)] = NULL;\n\trq->data_buf = NULL;\n}\n\nstatic inline bool esas2r_is_tasklet_pending(struct esas2r_adapter *a)\n{\n\n\treturn test_bit(AF_BUSRST_NEEDED, &a->flags) ||\n\t       test_bit(AF_BUSRST_DETECTED, &a->flags) ||\n\t       test_bit(AF_CHPRST_NEEDED, &a->flags) ||\n\t       test_bit(AF_CHPRST_DETECTED, &a->flags) ||\n\t       test_bit(AF_PORT_CHANGE, &a->flags);\n\n}\n\n \nstatic inline bool esas2r_build_sg_list(struct esas2r_adapter *a,\n\t\t\t\t\tstruct esas2r_request *rq,\n\t\t\t\t\tstruct esas2r_sg_context *sgc)\n{\n\tif (unlikely(le32_to_cpu(rq->vrq->scsi.length) == 0))\n\t\treturn true;\n\n\treturn (*a->build_sgl)(a, sgc);\n}\n\nstatic inline void esas2r_disable_chip_interrupts(struct esas2r_adapter *a)\n{\n\tif (atomic_inc_return(&a->dis_ints_cnt) == 1)\n\t\tesas2r_write_register_dword(a, MU_INT_MASK_OUT,\n\t\t\t\t\t    ESAS2R_INT_DIS_MASK);\n}\n\nstatic inline void esas2r_enable_chip_interrupts(struct esas2r_adapter *a)\n{\n\tif (atomic_dec_return(&a->dis_ints_cnt) == 0)\n\t\tesas2r_write_register_dword(a, MU_INT_MASK_OUT,\n\t\t\t\t\t    ESAS2R_INT_ENB_MASK);\n}\n\n \nstatic inline void esas2r_schedule_tasklet(struct esas2r_adapter *a)\n{\n\t \n\tif (!test_and_set_bit(AF_TASKLET_SCHEDULED, &a->flags))\n\t\ttasklet_hi_schedule(&a->tasklet);\n}\n\nstatic inline void esas2r_enable_heartbeat(struct esas2r_adapter *a)\n{\n\tif (!test_bit(AF_DEGRADED_MODE, &a->flags) &&\n\t    !test_bit(AF_CHPRST_PENDING, &a->flags) &&\n\t    (a->nvram->options2 & SASNVR2_HEARTBEAT))\n\t\tset_bit(AF_HEARTBEAT_ENB, &a->flags);\n\telse\n\t\tclear_bit(AF_HEARTBEAT_ENB, &a->flags);\n}\n\nstatic inline void esas2r_disable_heartbeat(struct esas2r_adapter *a)\n{\n\tclear_bit(AF_HEARTBEAT_ENB, &a->flags);\n\tclear_bit(AF_HEARTBEAT, &a->flags);\n}\n\n \nstatic inline void esas2r_local_reset_adapter(struct esas2r_adapter *a)\n{\n\tesas2r_disable_heartbeat(a);\n\n\tset_bit(AF_CHPRST_NEEDED, &a->flags);\n\tset_bit(AF_CHPRST_PENDING, &a->flags);\n\tset_bit(AF_DISC_PENDING, &a->flags);\n}\n\n \nstatic inline bool esas2r_adapter_interrupt_pending(struct esas2r_adapter *a)\n{\n\tu32 intstat;\n\n\tif (a->int_mask == 0)\n\t\treturn false;\n\n\tintstat = esas2r_read_register_dword(a, MU_INT_STATUS_OUT);\n\n\tif ((intstat & a->int_mask) == 0)\n\t\treturn false;\n\n\tesas2r_disable_chip_interrupts(a);\n\n\ta->int_stat = intstat;\n\ta->int_mask = 0;\n\n\treturn true;\n}\n\nstatic inline u16 esas2r_targ_get_id(struct esas2r_target *t,\n\t\t\t\t     struct esas2r_adapter *a)\n{\n\treturn (u16)(uintptr_t)(t - a->targetdb);\n}\n\n \nstatic inline void esas2r_start_ae_request(struct esas2r_adapter *a,\n\t\t\t\t\t   struct esas2r_request *rq)\n{\n\tunsigned long flags;\n\n\tesas2r_build_ae_req(a, rq);\n\n\tspin_lock_irqsave(&a->queue_lock, flags);\n\tesas2r_start_vda_request(a, rq);\n\tspin_unlock_irqrestore(&a->queue_lock, flags);\n}\n\nstatic inline void esas2r_comp_list_drain(struct esas2r_adapter *a,\n\t\t\t\t\t  struct list_head *comp_list)\n{\n\tstruct esas2r_request *rq;\n\tstruct list_head *element, *next;\n\n\tlist_for_each_safe(element, next, comp_list) {\n\t\trq = list_entry(element, struct esas2r_request, comp_list);\n\t\tlist_del_init(element);\n\t\tesas2r_complete_request(a, rq);\n\t}\n}\n\n \nextern struct bin_attribute bin_attr_fw;\nextern struct bin_attribute bin_attr_fs;\nextern struct bin_attribute bin_attr_vda;\nextern struct bin_attribute bin_attr_hw;\nextern struct bin_attribute bin_attr_live_nvram;\nextern struct bin_attribute bin_attr_default_nvram;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}