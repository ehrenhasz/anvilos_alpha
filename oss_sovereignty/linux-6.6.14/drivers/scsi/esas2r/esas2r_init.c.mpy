{
  "module_name": "esas2r_init.c",
  "hash_id": "8422acaea04aa1c73ba4a0f8a7e00cffade5ec11aad2bc3e58fe2864c61a465f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/esas2r/esas2r_init.c",
  "human_readable_source": " \n\n#include \"esas2r.h\"\n\nstatic bool esas2r_initmem_alloc(struct esas2r_adapter *a,\n\t\t\t\t struct esas2r_mem_desc *mem_desc,\n\t\t\t\t u32 align)\n{\n\tmem_desc->esas2r_param = mem_desc->size + align;\n\tmem_desc->virt_addr = NULL;\n\tmem_desc->phys_addr = 0;\n\tmem_desc->esas2r_data = dma_alloc_coherent(&a->pcid->dev,\n\t\t\t\t\t\t   (size_t)mem_desc->\n\t\t\t\t\t\t   esas2r_param,\n\t\t\t\t\t\t   (dma_addr_t *)&mem_desc->\n\t\t\t\t\t\t   phys_addr,\n\t\t\t\t\t\t   GFP_KERNEL);\n\n\tif (mem_desc->esas2r_data == NULL) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"failed to allocate %lu bytes of consistent memory!\",\n\t\t\t   (long\n\t\t\t    unsigned\n\t\t\t    int)mem_desc->esas2r_param);\n\t\treturn false;\n\t}\n\n\tmem_desc->virt_addr = PTR_ALIGN(mem_desc->esas2r_data, align);\n\tmem_desc->phys_addr = ALIGN(mem_desc->phys_addr, align);\n\tmemset(mem_desc->virt_addr, 0, mem_desc->size);\n\treturn true;\n}\n\nstatic void esas2r_initmem_free(struct esas2r_adapter *a,\n\t\t\t\tstruct esas2r_mem_desc *mem_desc)\n{\n\tif (mem_desc->virt_addr == NULL)\n\t\treturn;\n\n\t \n\tif (mem_desc->phys_addr) {\n\t\tint unalign = ((u8 *)mem_desc->virt_addr) -\n\t\t\t      ((u8 *)mem_desc->esas2r_data);\n\n\t\tdma_free_coherent(&a->pcid->dev,\n\t\t\t\t  (size_t)mem_desc->esas2r_param,\n\t\t\t\t  mem_desc->esas2r_data,\n\t\t\t\t  (dma_addr_t)(mem_desc->phys_addr - unalign));\n\t} else {\n\t\tkfree(mem_desc->esas2r_data);\n\t}\n\n\tmem_desc->virt_addr = NULL;\n}\n\nstatic bool alloc_vda_req(struct esas2r_adapter *a,\n\t\t\t  struct esas2r_request *rq)\n{\n\tstruct esas2r_mem_desc *memdesc = kzalloc(\n\t\tsizeof(struct esas2r_mem_desc), GFP_KERNEL);\n\n\tif (memdesc == NULL) {\n\t\tesas2r_hdebug(\"could not alloc mem for vda request memdesc\\n\");\n\t\treturn false;\n\t}\n\n\tmemdesc->size = sizeof(union atto_vda_req) +\n\t\t\tESAS2R_DATA_BUF_LEN;\n\n\tif (!esas2r_initmem_alloc(a, memdesc, 256)) {\n\t\tesas2r_hdebug(\"could not alloc mem for vda request\\n\");\n\t\tkfree(memdesc);\n\t\treturn false;\n\t}\n\n\ta->num_vrqs++;\n\tlist_add(&memdesc->next_desc, &a->vrq_mds_head);\n\n\trq->vrq_md = memdesc;\n\trq->vrq = (union atto_vda_req *)memdesc->virt_addr;\n\trq->vrq->scsi.handle = a->num_vrqs;\n\n\treturn true;\n}\n\nstatic void esas2r_unmap_regions(struct esas2r_adapter *a)\n{\n\tif (a->regs)\n\t\tiounmap((void __iomem *)a->regs);\n\n\ta->regs = NULL;\n\n\tpci_release_region(a->pcid, 2);\n\n\tif (a->data_window)\n\t\tiounmap((void __iomem *)a->data_window);\n\n\ta->data_window = NULL;\n\n\tpci_release_region(a->pcid, 0);\n}\n\nstatic int esas2r_map_regions(struct esas2r_adapter *a)\n{\n\tint error;\n\n\ta->regs = NULL;\n\ta->data_window = NULL;\n\n\terror = pci_request_region(a->pcid, 2, a->name);\n\tif (error != 0) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"pci_request_region(2) failed, error %d\",\n\t\t\t   error);\n\n\t\treturn error;\n\t}\n\n\ta->regs = (void __force *)ioremap(pci_resource_start(a->pcid, 2),\n\t\t\t\t\t  pci_resource_len(a->pcid, 2));\n\tif (a->regs == NULL) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"ioremap failed for regs mem region\\n\");\n\t\tpci_release_region(a->pcid, 2);\n\t\treturn -EFAULT;\n\t}\n\n\terror = pci_request_region(a->pcid, 0, a->name);\n\tif (error != 0) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"pci_request_region(2) failed, error %d\",\n\t\t\t   error);\n\t\tesas2r_unmap_regions(a);\n\t\treturn error;\n\t}\n\n\ta->data_window = (void __force *)ioremap(pci_resource_start(a->pcid,\n\t\t\t\t\t\t\t\t    0),\n\t\t\t\t\t\t pci_resource_len(a->pcid, 0));\n\tif (a->data_window == NULL) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"ioremap failed for data_window mem region\\n\");\n\t\tesas2r_unmap_regions(a);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic void esas2r_setup_interrupts(struct esas2r_adapter *a, int intr_mode)\n{\n\tint i;\n\n\t \n\tswitch (intr_mode) {\n\tcase INTR_MODE_LEGACY:\nuse_legacy_interrupts:\n\t\ta->intr_mode = INTR_MODE_LEGACY;\n\t\tbreak;\n\n\tcase INTR_MODE_MSI:\n\t\ti = pci_enable_msi(a->pcid);\n\t\tif (i != 0) {\n\t\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t\t   \"failed to enable MSI for adapter %d, \"\n\t\t\t\t   \"falling back to legacy interrupts \"\n\t\t\t\t   \"(err=%d)\", a->index,\n\t\t\t\t   i);\n\t\t\tgoto use_legacy_interrupts;\n\t\t}\n\t\ta->intr_mode = INTR_MODE_MSI;\n\t\tset_bit(AF2_MSI_ENABLED, &a->flags2);\n\t\tbreak;\n\n\n\tdefault:\n\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t   \"unknown interrupt_mode %d requested, \"\n\t\t\t   \"falling back to legacy interrupt\",\n\t\t\t   interrupt_mode);\n\t\tgoto use_legacy_interrupts;\n\t}\n}\n\nstatic void esas2r_claim_interrupts(struct esas2r_adapter *a)\n{\n\tunsigned long flags = 0;\n\n\tif (a->intr_mode == INTR_MODE_LEGACY)\n\t\tflags |= IRQF_SHARED;\n\n\tesas2r_log(ESAS2R_LOG_INFO,\n\t\t   \"esas2r_claim_interrupts irq=%d (%p, %s, %lx)\",\n\t\t   a->pcid->irq, a, a->name, flags);\n\n\tif (request_irq(a->pcid->irq,\n\t\t\t(a->intr_mode ==\n\t\t\t INTR_MODE_LEGACY) ? esas2r_interrupt :\n\t\t\tesas2r_msi_interrupt,\n\t\t\tflags,\n\t\t\ta->name,\n\t\t\ta)) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT, \"unable to request IRQ %02X\",\n\t\t\t   a->pcid->irq);\n\t\treturn;\n\t}\n\n\tset_bit(AF2_IRQ_CLAIMED, &a->flags2);\n\tesas2r_log(ESAS2R_LOG_INFO,\n\t\t   \"claimed IRQ %d flags: 0x%lx\",\n\t\t   a->pcid->irq, flags);\n}\n\nint esas2r_init_adapter(struct Scsi_Host *host, struct pci_dev *pcid,\n\t\t\tint index)\n{\n\tstruct esas2r_adapter *a;\n\tu64 bus_addr = 0;\n\tint i;\n\tvoid *next_uncached;\n\tstruct esas2r_request *first_request, *last_request;\n\tbool dma64 = false;\n\n\tif (index >= MAX_ADAPTERS) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"tried to init invalid adapter index %u!\",\n\t\t\t   index);\n\t\treturn 0;\n\t}\n\n\tif (esas2r_adapters[index]) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"tried to init existing adapter index %u!\",\n\t\t\t   index);\n\t\treturn 0;\n\t}\n\n\ta = (struct esas2r_adapter *)host->hostdata;\n\tmemset(a, 0, sizeof(struct esas2r_adapter));\n\ta->pcid = pcid;\n\ta->host = host;\n\n\tif (sizeof(dma_addr_t) > 4 &&\n\t    dma_get_required_mask(&pcid->dev) > DMA_BIT_MASK(32) &&\n\t    !dma_set_mask_and_coherent(&pcid->dev, DMA_BIT_MASK(64)))\n\t\tdma64 = true;\n\n\tif (!dma64 && dma_set_mask_and_coherent(&pcid->dev, DMA_BIT_MASK(32))) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT, \"failed to set DMA mask\");\n\t\tesas2r_kill_adapter(index);\n\t\treturn 0;\n\t}\n\n\tesas2r_log_dev(ESAS2R_LOG_INFO, &pcid->dev,\n\t\t       \"%s-bit PCI addressing enabled\\n\", dma64 ? \"64\" : \"32\");\n\n\tesas2r_adapters[index] = a;\n\tsprintf(a->name, ESAS2R_DRVR_NAME \"_%02d\", index);\n\tesas2r_debug(\"new adapter %p, name %s\", a, a->name);\n\tspin_lock_init(&a->request_lock);\n\tspin_lock_init(&a->fw_event_lock);\n\tmutex_init(&a->fm_api_mutex);\n\tmutex_init(&a->fs_api_mutex);\n\tsema_init(&a->nvram_semaphore, 1);\n\n\tesas2r_fw_event_off(a);\n\tsnprintf(a->fw_event_q_name, ESAS2R_KOBJ_NAME_LEN, \"esas2r/%d\",\n\t\t a->index);\n\ta->fw_event_q = create_singlethread_workqueue(a->fw_event_q_name);\n\n\tinit_waitqueue_head(&a->buffered_ioctl_waiter);\n\tinit_waitqueue_head(&a->nvram_waiter);\n\tinit_waitqueue_head(&a->fm_api_waiter);\n\tinit_waitqueue_head(&a->fs_api_waiter);\n\tinit_waitqueue_head(&a->vda_waiter);\n\n\tINIT_LIST_HEAD(&a->general_req.req_list);\n\tINIT_LIST_HEAD(&a->active_list);\n\tINIT_LIST_HEAD(&a->defer_list);\n\tINIT_LIST_HEAD(&a->free_sg_list_head);\n\tINIT_LIST_HEAD(&a->avail_request);\n\tINIT_LIST_HEAD(&a->vrq_mds_head);\n\tINIT_LIST_HEAD(&a->fw_event_list);\n\n\tfirst_request = (struct esas2r_request *)((u8 *)(a + 1));\n\n\tfor (last_request = first_request, i = 1; i < num_requests;\n\t     last_request++, i++) {\n\t\tINIT_LIST_HEAD(&last_request->req_list);\n\t\tlist_add_tail(&last_request->comp_list, &a->avail_request);\n\t\tif (!alloc_vda_req(a, last_request)) {\n\t\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t\t   \"failed to allocate a VDA request!\");\n\t\t\tesas2r_kill_adapter(index);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tesas2r_debug(\"requests: %p to %p (%d, %d)\", first_request,\n\t\t     last_request,\n\t\t     sizeof(*first_request),\n\t\t     num_requests);\n\n\tif (esas2r_map_regions(a) != 0) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT, \"could not map PCI regions!\");\n\t\tesas2r_kill_adapter(index);\n\t\treturn 0;\n\t}\n\n\ta->index = index;\n\n\t \n\tatomic_inc(&a->dis_ints_cnt);\n\tatomic_inc(&a->disable_cnt);\n\tset_bit(AF_CHPRST_PENDING, &a->flags);\n\tset_bit(AF_DISC_PENDING, &a->flags);\n\tset_bit(AF_FIRST_INIT, &a->flags);\n\tset_bit(AF_LEGACY_SGE_MODE, &a->flags);\n\n\ta->init_msg = ESAS2R_INIT_MSG_START;\n\ta->max_vdareq_size = 128;\n\ta->build_sgl = esas2r_build_sg_list_sge;\n\n\tesas2r_setup_interrupts(a, interrupt_mode);\n\n\ta->uncached_size = esas2r_get_uncached_size(a);\n\ta->uncached = dma_alloc_coherent(&pcid->dev,\n\t\t\t\t\t (size_t)a->uncached_size,\n\t\t\t\t\t (dma_addr_t *)&bus_addr,\n\t\t\t\t\t GFP_KERNEL);\n\tif (a->uncached == NULL) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"failed to allocate %d bytes of consistent memory!\",\n\t\t\t   a->uncached_size);\n\t\tesas2r_kill_adapter(index);\n\t\treturn 0;\n\t}\n\n\ta->uncached_phys = bus_addr;\n\n\tesas2r_debug(\"%d bytes uncached memory allocated @ %p (%x:%x)\",\n\t\t     a->uncached_size,\n\t\t     a->uncached,\n\t\t     upper_32_bits(bus_addr),\n\t\t     lower_32_bits(bus_addr));\n\tmemset(a->uncached, 0, a->uncached_size);\n\tnext_uncached = a->uncached;\n\n\tif (!esas2r_init_adapter_struct(a,\n\t\t\t\t\t&next_uncached)) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"failed to initialize adapter structure (2)!\");\n\t\tesas2r_kill_adapter(index);\n\t\treturn 0;\n\t}\n\n\ttasklet_init(&a->tasklet,\n\t\t     esas2r_adapter_tasklet,\n\t\t     (unsigned long)a);\n\n\t \n\tesas2r_disable_chip_interrupts(a);\n\tesas2r_check_adapter(a);\n\n\tif (!esas2r_init_adapter_hw(a, true)) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT, \"failed to initialize hardware!\");\n\t} else {\n\t\tesas2r_debug(\"esas2r_init_adapter ok\");\n\t}\n\n\tesas2r_claim_interrupts(a);\n\n\tif (test_bit(AF2_IRQ_CLAIMED, &a->flags2))\n\t\tesas2r_enable_chip_interrupts(a);\n\n\tset_bit(AF2_INIT_DONE, &a->flags2);\n\tif (!test_bit(AF_DEGRADED_MODE, &a->flags))\n\t\tesas2r_kickoff_timer(a);\n\tesas2r_debug(\"esas2r_init_adapter done for %p (%d)\",\n\t\t     a, a->disable_cnt);\n\n\treturn 1;\n}\n\nstatic void esas2r_adapter_power_down(struct esas2r_adapter *a,\n\t\t\t\t      int power_management)\n{\n\tstruct esas2r_mem_desc *memdesc, *next;\n\n\tif ((test_bit(AF2_INIT_DONE, &a->flags2))\n\t    &&  (!test_bit(AF_DEGRADED_MODE, &a->flags))) {\n\t\tif (!power_management) {\n\t\t\tdel_timer_sync(&a->timer);\n\t\t\ttasklet_kill(&a->tasklet);\n\t\t}\n\t\tesas2r_power_down(a);\n\n\t\t \n\t\tmdelay(500);\n\t\tesas2r_debug(\"chip halted\");\n\t}\n\n\t \n\tif (a->sysfs_fw_created) {\n\t\tsysfs_remove_bin_file(&a->host->shost_dev.kobj, &bin_attr_fw);\n\t\ta->sysfs_fw_created = 0;\n\t}\n\n\tif (a->sysfs_fs_created) {\n\t\tsysfs_remove_bin_file(&a->host->shost_dev.kobj, &bin_attr_fs);\n\t\ta->sysfs_fs_created = 0;\n\t}\n\n\tif (a->sysfs_vda_created) {\n\t\tsysfs_remove_bin_file(&a->host->shost_dev.kobj, &bin_attr_vda);\n\t\ta->sysfs_vda_created = 0;\n\t}\n\n\tif (a->sysfs_hw_created) {\n\t\tsysfs_remove_bin_file(&a->host->shost_dev.kobj, &bin_attr_hw);\n\t\ta->sysfs_hw_created = 0;\n\t}\n\n\tif (a->sysfs_live_nvram_created) {\n\t\tsysfs_remove_bin_file(&a->host->shost_dev.kobj,\n\t\t\t\t      &bin_attr_live_nvram);\n\t\ta->sysfs_live_nvram_created = 0;\n\t}\n\n\tif (a->sysfs_default_nvram_created) {\n\t\tsysfs_remove_bin_file(&a->host->shost_dev.kobj,\n\t\t\t\t      &bin_attr_default_nvram);\n\t\ta->sysfs_default_nvram_created = 0;\n\t}\n\n\t \n\tif (test_bit(AF2_IRQ_CLAIMED, &a->flags2)) {\n\t\tesas2r_log_dev(ESAS2R_LOG_INFO,\n\t\t\t       &(a->pcid->dev),\n\t\t\t       \"free_irq(%d) called\", a->pcid->irq);\n\n\t\tfree_irq(a->pcid->irq, a);\n\t\tesas2r_debug(\"IRQ released\");\n\t\tclear_bit(AF2_IRQ_CLAIMED, &a->flags2);\n\t}\n\n\tif (test_bit(AF2_MSI_ENABLED, &a->flags2)) {\n\t\tpci_disable_msi(a->pcid);\n\t\tclear_bit(AF2_MSI_ENABLED, &a->flags2);\n\t\tesas2r_debug(\"MSI disabled\");\n\t}\n\n\tif (a->inbound_list_md.virt_addr)\n\t\tesas2r_initmem_free(a, &a->inbound_list_md);\n\n\tif (a->outbound_list_md.virt_addr)\n\t\tesas2r_initmem_free(a, &a->outbound_list_md);\n\n\tlist_for_each_entry_safe(memdesc, next, &a->free_sg_list_head,\n\t\t\t\t next_desc) {\n\t\tesas2r_initmem_free(a, memdesc);\n\t}\n\n\t \n\tlist_for_each_entry_safe(memdesc, next, &a->vrq_mds_head, next_desc) {\n\t\tesas2r_initmem_free(a, memdesc);\n\t\tlist_del(&memdesc->next_desc);\n\t\tkfree(memdesc);\n\t}\n\n\tkfree(a->first_ae_req);\n\ta->first_ae_req = NULL;\n\n\tkfree(a->sg_list_mds);\n\ta->sg_list_mds = NULL;\n\n\tkfree(a->req_table);\n\ta->req_table = NULL;\n\n\tif (a->regs) {\n\t\tesas2r_unmap_regions(a);\n\t\ta->regs = NULL;\n\t\ta->data_window = NULL;\n\t\tesas2r_debug(\"regions unmapped\");\n\t}\n}\n\n \nvoid esas2r_kill_adapter(int i)\n{\n\tstruct esas2r_adapter *a = esas2r_adapters[i];\n\n\tif (a) {\n\t\tunsigned long flags;\n\t\tstruct workqueue_struct *wq;\n\t\tesas2r_debug(\"killing adapter %p [%d] \", a, i);\n\t\tesas2r_fw_event_off(a);\n\t\tesas2r_adapter_power_down(a, 0);\n\t\tif (esas2r_buffered_ioctl &&\n\t\t    (a->pcid == esas2r_buffered_ioctl_pcid)) {\n\t\t\tdma_free_coherent(&a->pcid->dev,\n\t\t\t\t\t  (size_t)esas2r_buffered_ioctl_size,\n\t\t\t\t\t  esas2r_buffered_ioctl,\n\t\t\t\t\t  esas2r_buffered_ioctl_addr);\n\t\t\tesas2r_buffered_ioctl = NULL;\n\t\t}\n\n\t\tif (a->vda_buffer) {\n\t\t\tdma_free_coherent(&a->pcid->dev,\n\t\t\t\t\t  (size_t)VDA_MAX_BUFFER_SIZE,\n\t\t\t\t\t  a->vda_buffer,\n\t\t\t\t\t  (dma_addr_t)a->ppvda_buffer);\n\t\t\ta->vda_buffer = NULL;\n\t\t}\n\t\tif (a->fs_api_buffer) {\n\t\t\tdma_free_coherent(&a->pcid->dev,\n\t\t\t\t\t  (size_t)a->fs_api_buffer_size,\n\t\t\t\t\t  a->fs_api_buffer,\n\t\t\t\t\t  (dma_addr_t)a->ppfs_api_buffer);\n\t\t\ta->fs_api_buffer = NULL;\n\t\t}\n\n\t\tkfree(a->local_atto_ioctl);\n\t\ta->local_atto_ioctl = NULL;\n\n\t\tspin_lock_irqsave(&a->fw_event_lock, flags);\n\t\twq = a->fw_event_q;\n\t\ta->fw_event_q = NULL;\n\t\tspin_unlock_irqrestore(&a->fw_event_lock, flags);\n\t\tif (wq)\n\t\t\tdestroy_workqueue(wq);\n\n\t\tif (a->uncached) {\n\t\t\tdma_free_coherent(&a->pcid->dev,\n\t\t\t\t\t  (size_t)a->uncached_size,\n\t\t\t\t\t  a->uncached,\n\t\t\t\t\t  (dma_addr_t)a->uncached_phys);\n\t\t\ta->uncached = NULL;\n\t\t\tesas2r_debug(\"uncached area freed\");\n\t\t}\n\n\t\tesas2r_log_dev(ESAS2R_LOG_INFO,\n\t\t\t       &(a->pcid->dev),\n\t\t\t       \"pci_disable_device() called.  msix_enabled: %d \"\n\t\t\t       \"msi_enabled: %d irq: %d pin: %d\",\n\t\t\t       a->pcid->msix_enabled,\n\t\t\t       a->pcid->msi_enabled,\n\t\t\t       a->pcid->irq,\n\t\t\t       a->pcid->pin);\n\n\t\tesas2r_log_dev(ESAS2R_LOG_INFO,\n\t\t\t       &(a->pcid->dev),\n\t\t\t       \"before pci_disable_device() enable_cnt: %d\",\n\t\t\t       a->pcid->enable_cnt.counter);\n\n\t\tpci_disable_device(a->pcid);\n\t\tesas2r_log_dev(ESAS2R_LOG_INFO,\n\t\t\t       &(a->pcid->dev),\n\t\t\t       \"after pci_disable_device() enable_cnt: %d\",\n\t\t\t       a->pcid->enable_cnt.counter);\n\n\t\tesas2r_log_dev(ESAS2R_LOG_INFO,\n\t\t\t       &(a->pcid->dev),\n\t\t\t       \"pci_set_drv_data(%p, NULL) called\",\n\t\t\t       a->pcid);\n\n\t\tpci_set_drvdata(a->pcid, NULL);\n\t\tesas2r_adapters[i] = NULL;\n\n\t\tif (test_bit(AF2_INIT_DONE, &a->flags2)) {\n\t\t\tclear_bit(AF2_INIT_DONE, &a->flags2);\n\n\t\t\tset_bit(AF_DEGRADED_MODE, &a->flags);\n\n\t\t\tesas2r_log_dev(ESAS2R_LOG_INFO,\n\t\t\t\t       &(a->host->shost_gendev),\n\t\t\t\t       \"scsi_remove_host() called\");\n\n\t\t\tscsi_remove_host(a->host);\n\n\t\t\tesas2r_log_dev(ESAS2R_LOG_INFO,\n\t\t\t\t       &(a->host->shost_gendev),\n\t\t\t\t       \"scsi_host_put() called\");\n\n\t\t\tscsi_host_put(a->host);\n\t\t}\n\t}\n}\n\nstatic int __maybe_unused esas2r_suspend(struct device *dev)\n{\n\tstruct Scsi_Host *host = dev_get_drvdata(dev);\n\tstruct esas2r_adapter *a = (struct esas2r_adapter *)host->hostdata;\n\n\tesas2r_log_dev(ESAS2R_LOG_INFO, dev, \"suspending adapter()\");\n\tif (!a)\n\t\treturn -ENODEV;\n\n\tesas2r_adapter_power_down(a, 1);\n\tesas2r_log_dev(ESAS2R_LOG_INFO, dev, \"esas2r_suspend(): 0\");\n\treturn 0;\n}\n\nstatic int __maybe_unused esas2r_resume(struct device *dev)\n{\n\tstruct Scsi_Host *host = dev_get_drvdata(dev);\n\tstruct esas2r_adapter *a = (struct esas2r_adapter *)host->hostdata;\n\tint rez = 0;\n\n\tesas2r_log_dev(ESAS2R_LOG_INFO, dev, \"resuming adapter()\");\n\n\tif (!a) {\n\t\trez = -ENODEV;\n\t\tgoto error_exit;\n\t}\n\n\tif (esas2r_map_regions(a) != 0) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT, \"could not re-map PCI regions!\");\n\t\trez = -ENOMEM;\n\t\tgoto error_exit;\n\t}\n\n\t \n\tesas2r_setup_interrupts(a, a->intr_mode);\n\n\t \n\tesas2r_disable_chip_interrupts(a);\n\tif (!esas2r_power_up(a, true)) {\n\t\tesas2r_debug(\"yikes, esas2r_power_up failed\");\n\t\trez = -ENOMEM;\n\t\tgoto error_exit;\n\t}\n\n\tesas2r_claim_interrupts(a);\n\n\tif (test_bit(AF2_IRQ_CLAIMED, &a->flags2)) {\n\t\t \n\t\tesas2r_enable_chip_interrupts(a);\n\t\tesas2r_kickoff_timer(a);\n\t} else {\n\t\tesas2r_debug(\"yikes, unable to claim IRQ\");\n\t\tesas2r_log(ESAS2R_LOG_CRIT, \"could not re-claim IRQ!\");\n\t\trez = -ENOMEM;\n\t\tgoto error_exit;\n\t}\n\nerror_exit:\n\tesas2r_log_dev(ESAS2R_LOG_CRIT, dev, \"esas2r_resume(): %d\",\n\t\t       rez);\n\treturn rez;\n}\n\nSIMPLE_DEV_PM_OPS(esas2r_pm_ops, esas2r_suspend, esas2r_resume);\n\nbool esas2r_set_degraded_mode(struct esas2r_adapter *a, char *error_str)\n{\n\tset_bit(AF_DEGRADED_MODE, &a->flags);\n\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t   \"setting adapter to degraded mode: %s\\n\", error_str);\n\treturn false;\n}\n\nu32 esas2r_get_uncached_size(struct esas2r_adapter *a)\n{\n\treturn sizeof(struct esas2r_sas_nvram)\n\t       + ALIGN(ESAS2R_DISC_BUF_LEN, 8)\n\t       + ALIGN(sizeof(u32), 8)  \n\t       + 8\n\t       + (num_sg_lists * (u16)sgl_page_size)\n\t       + ALIGN((num_requests + num_ae_requests + 1 +\n\t\t\tESAS2R_LIST_EXTRA) *\n\t\t       sizeof(struct esas2r_inbound_list_source_entry),\n\t\t       8)\n\t       + ALIGN((num_requests + num_ae_requests + 1 +\n\t\t\tESAS2R_LIST_EXTRA) *\n\t\t       sizeof(struct atto_vda_ob_rsp), 8)\n\t       + 256;  \n}\n\nstatic void esas2r_init_pci_cfg_space(struct esas2r_adapter *a)\n{\n\tif (pci_is_pcie(a->pcid)) {\n\t\tu16 devcontrol;\n\n\t\tpcie_capability_read_word(a->pcid, PCI_EXP_DEVCTL, &devcontrol);\n\n\t\tif ((devcontrol & PCI_EXP_DEVCTL_READRQ) >\n\t\t     PCI_EXP_DEVCTL_READRQ_512B) {\n\t\t\tesas2r_log(ESAS2R_LOG_INFO,\n\t\t\t\t   \"max read request size > 512B\");\n\n\t\t\tdevcontrol &= ~PCI_EXP_DEVCTL_READRQ;\n\t\t\tdevcontrol |= PCI_EXP_DEVCTL_READRQ_512B;\n\t\t\tpcie_capability_write_word(a->pcid, PCI_EXP_DEVCTL,\n\t\t\t\t\t\t   devcontrol);\n\t\t}\n\t}\n}\n\n \nbool esas2r_init_adapter_struct(struct esas2r_adapter *a,\n\t\t\t\tvoid **uncached_area)\n{\n\tu32 i;\n\tu8 *high;\n\tstruct esas2r_inbound_list_source_entry *element;\n\tstruct esas2r_request *rq;\n\tstruct esas2r_mem_desc *sgl;\n\n\tspin_lock_init(&a->sg_list_lock);\n\tspin_lock_init(&a->mem_lock);\n\tspin_lock_init(&a->queue_lock);\n\n\ta->targetdb_end = &a->targetdb[ESAS2R_MAX_TARGETS];\n\n\tif (!alloc_vda_req(a, &a->general_req)) {\n\t\tesas2r_hdebug(\n\t\t\t\"failed to allocate a VDA request for the general req!\");\n\t\treturn false;\n\t}\n\n\t \n\ta->first_ae_req =\n\t\tkcalloc(num_ae_requests, sizeof(struct esas2r_request),\n\t\t\tGFP_KERNEL);\n\n\tif (a->first_ae_req == NULL) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"failed to allocate memory for asynchronous events\");\n\t\treturn false;\n\t}\n\n\t \n\ta->sg_list_mds = kcalloc(num_sg_lists, sizeof(struct esas2r_mem_desc),\n\t\t\t\t GFP_KERNEL);\n\n\tif (a->sg_list_mds == NULL) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"failed to allocate memory for s/g list descriptors\");\n\t\treturn false;\n\t}\n\n\t \n\ta->req_table =\n\t\tkcalloc(num_requests + num_ae_requests + 1,\n\t\t\tsizeof(struct esas2r_request *),\n\t\t\tGFP_KERNEL);\n\n\tif (a->req_table == NULL) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"failed to allocate memory for the request table\");\n\t\treturn false;\n\t}\n\n\t \n\tesas2r_init_pci_cfg_space(a);\n\n\t \n\tif ((a->pcid->subsystem_vendor == ATTO_VENDOR_ID)\n\t    && (a->pcid->subsystem_device & ATTO_SSDID_TBT))\n\t\ta->flags2 |= AF2_THUNDERBOLT;\n\n\tif (test_bit(AF2_THUNDERBOLT, &a->flags2))\n\t\ta->flags2 |= AF2_SERIAL_FLASH;\n\n\tif (a->pcid->subsystem_device == ATTO_TLSH_1068)\n\t\ta->flags2 |= AF2_THUNDERLINK;\n\n\t \n\thigh = (u8 *)*uncached_area;\n\n\t \n\n\tfor (i = 0, sgl = a->sg_list_mds; i < num_sg_lists; i++, sgl++) {\n\t\tsgl->size = sgl_page_size;\n\n\t\tlist_add_tail(&sgl->next_desc, &a->free_sg_list_head);\n\n\t\tif (!esas2r_initmem_alloc(a, sgl, ESAS2R_SGL_ALIGN)) {\n\t\t\t \n\t\t\tif (i < NUM_SGL_MIN)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\ta->list_size = num_requests + ESAS2R_LIST_EXTRA;\n\n\t \n\ta->inbound_list_md.size = a->list_size *\n\t\t\t\t  sizeof(struct\n\t\t\t\t\t esas2r_inbound_list_source_entry);\n\n\tif (!esas2r_initmem_alloc(a, &a->inbound_list_md, ESAS2R_LIST_ALIGN)) {\n\t\tesas2r_hdebug(\"failed to allocate IB list\");\n\t\treturn false;\n\t}\n\n\t \n\ta->outbound_list_md.size = a->list_size *\n\t\t\t\t   sizeof(struct atto_vda_ob_rsp);\n\n\tif (!esas2r_initmem_alloc(a, &a->outbound_list_md,\n\t\t\t\t  ESAS2R_LIST_ALIGN)) {\n\t\tesas2r_hdebug(\"failed to allocate IB list\");\n\t\treturn false;\n\t}\n\n\t \n\ta->nvram = (struct esas2r_sas_nvram *)high;\n\thigh += sizeof(struct esas2r_sas_nvram);\n\n\t \n\ta->disc_buffer = high;\n\thigh += ESAS2R_DISC_BUF_LEN;\n\thigh = PTR_ALIGN(high, 8);\n\n\t \n\ta->outbound_copy = (u32 volatile *)high;\n\thigh += sizeof(u32);\n\n\tif (!test_bit(AF_NVR_VALID, &a->flags))\n\t\tesas2r_nvram_set_defaults(a);\n\n\t \n\t*uncached_area = (void *)high;\n\n\t \n\tif (test_bit(AF_FIRST_INIT, &a->flags)) {\n\t\tesas2r_targ_db_initialize(a);\n\n\t\t \n\t\telement =\n\t\t\t(struct esas2r_inbound_list_source_entry *)a->\n\t\t\tinbound_list_md.\n\t\t\tvirt_addr;\n\n\t\tfor (i = 0; i < a->list_size; i++) {\n\t\t\telement->address = 0;\n\t\t\telement->reserved = 0;\n\t\t\telement->length = cpu_to_le32(HWILSE_INTERFACE_F0\n\t\t\t\t\t\t      | (sizeof(union\n\t\t\t\t\t\t\t\tatto_vda_req)\n\t\t\t\t\t\t\t /\n\t\t\t\t\t\t\t sizeof(u32)));\n\t\t\telement++;\n\t\t}\n\n\t\t \n\t\tfor (rq = a->first_ae_req, i = 0; i < num_ae_requests; rq++,\n\t\t     i++) {\n\t\t\tINIT_LIST_HEAD(&rq->req_list);\n\t\t\tif (!alloc_vda_req(a, rq)) {\n\t\t\t\tesas2r_hdebug(\n\t\t\t\t\t\"failed to allocate a VDA request!\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tesas2r_rq_init_request(rq, a);\n\n\t\t\t \n\t\t\trq->comp_cb = esas2r_ae_complete;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nbool esas2r_check_adapter(struct esas2r_adapter *a)\n{\n\tu32 starttime;\n\tu32 doorbell;\n\tu64 ppaddr;\n\tu32 dw;\n\n\t \n\tif (test_bit(AF_CHPRST_DETECTED, &a->flags))\n\t\tgoto skip_chip_reset;\n\n\t \n\tesas2r_write_register_dword(a, MU_INT_MASK_OUT, ESAS2R_INT_DIS_MASK);\n\tesas2r_flush_register_dword(a, MU_INT_MASK_OUT);\n\n\t \n\tstarttime = jiffies_to_msecs(jiffies);\n\n\twhile (true) {\n\t\tesas2r_force_interrupt(a);\n\t\tdoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\n\t\tif (doorbell == 0xFFFFFFFF) {\n\t\t\t \n\t\t\tif ((jiffies_to_msecs(jiffies) - starttime) > 2000)\n\t\t\t\treturn esas2r_set_degraded_mode(a,\n\t\t\t\t\t\t\t\t\"unable to access registers\");\n\t\t} else if (doorbell & DRBL_FORCE_INT) {\n\t\t\tu32 ver = (doorbell & DRBL_FW_VER_MSK);\n\n\t\t\t \n\t\t\tesas2r_write_register_dword(a, MU_DOORBELL_OUT,\n\t\t\t\t\t\t    doorbell);\n\n\t\t\tif (ver == DRBL_FW_VER_0) {\n\t\t\t\tset_bit(AF_LEGACY_SGE_MODE, &a->flags);\n\n\t\t\t\ta->max_vdareq_size = 128;\n\t\t\t\ta->build_sgl = esas2r_build_sg_list_sge;\n\t\t\t} else if (ver == DRBL_FW_VER_1) {\n\t\t\t\tclear_bit(AF_LEGACY_SGE_MODE, &a->flags);\n\n\t\t\t\ta->max_vdareq_size = 1024;\n\t\t\t\ta->build_sgl = esas2r_build_sg_list_prd;\n\t\t\t} else {\n\t\t\t\treturn esas2r_set_degraded_mode(a,\n\t\t\t\t\t\t\t\t\"unknown firmware version\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(100));\n\n\t\tif ((jiffies_to_msecs(jiffies) - starttime) > 180000) {\n\t\t\tesas2r_hdebug(\"FW ready TMO\");\n\t\t\tesas2r_bugon();\n\n\t\t\treturn esas2r_set_degraded_mode(a,\n\t\t\t\t\t\t\t\"firmware start has timed out\");\n\t\t}\n\t}\n\n\t \n\tesas2r_write_register_dword(a, MU_DOORBELL_IN, DRBL_MSG_IFC_DOWN);\n\tstarttime = jiffies_to_msecs(jiffies);\n\n\twhile (true) {\n\t\tdoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\n\t\tif (doorbell & DRBL_MSG_IFC_DOWN) {\n\t\t\tesas2r_write_register_dword(a, MU_DOORBELL_OUT,\n\t\t\t\t\t\t    doorbell);\n\t\t\tbreak;\n\t\t}\n\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(50));\n\n\t\tif ((jiffies_to_msecs(jiffies) - starttime) > 3000) {\n\t\t\tesas2r_hdebug(\"timeout waiting for interface down\");\n\t\t\tbreak;\n\t\t}\n\t}\nskip_chip_reset:\n\t \n\tdw = esas2r_read_register_dword(a, MU_IN_LIST_CONFIG);\n\tdw &= ~MU_ILC_ENABLE;\n\tesas2r_write_register_dword(a, MU_IN_LIST_CONFIG, dw);\n\tdw = esas2r_read_register_dword(a, MU_OUT_LIST_CONFIG);\n\tdw &= ~MU_OLC_ENABLE;\n\tesas2r_write_register_dword(a, MU_OUT_LIST_CONFIG, dw);\n\n\t \n\tppaddr = a->inbound_list_md.phys_addr;\n\tesas2r_write_register_dword(a, MU_IN_LIST_ADDR_LO,\n\t\t\t\t    lower_32_bits(ppaddr));\n\tesas2r_write_register_dword(a, MU_IN_LIST_ADDR_HI,\n\t\t\t\t    upper_32_bits(ppaddr));\n\tppaddr = a->outbound_list_md.phys_addr;\n\tesas2r_write_register_dword(a, MU_OUT_LIST_ADDR_LO,\n\t\t\t\t    lower_32_bits(ppaddr));\n\tesas2r_write_register_dword(a, MU_OUT_LIST_ADDR_HI,\n\t\t\t\t    upper_32_bits(ppaddr));\n\tppaddr = a->uncached_phys +\n\t\t ((u8 *)a->outbound_copy - a->uncached);\n\tesas2r_write_register_dword(a, MU_OUT_LIST_COPY_PTR_LO,\n\t\t\t\t    lower_32_bits(ppaddr));\n\tesas2r_write_register_dword(a, MU_OUT_LIST_COPY_PTR_HI,\n\t\t\t\t    upper_32_bits(ppaddr));\n\n\t \n\t*a->outbound_copy =\n\t\ta->last_write =\n\t\t\ta->last_read = a->list_size - 1;\n\tset_bit(AF_COMM_LIST_TOGGLE, &a->flags);\n\tesas2r_write_register_dword(a, MU_IN_LIST_WRITE, MU_ILW_TOGGLE |\n\t\t\t\t    a->last_write);\n\tesas2r_write_register_dword(a, MU_OUT_LIST_COPY, MU_OLC_TOGGLE |\n\t\t\t\t    a->last_write);\n\tesas2r_write_register_dword(a, MU_IN_LIST_READ, MU_ILR_TOGGLE |\n\t\t\t\t    a->last_write);\n\tesas2r_write_register_dword(a, MU_OUT_LIST_WRITE,\n\t\t\t\t    MU_OLW_TOGGLE | a->last_write);\n\n\t \n\tdw = esas2r_read_register_dword(a, MU_IN_LIST_IFC_CONFIG);\n\tdw &= ~(MU_ILIC_LIST | MU_ILIC_DEST);\n\tesas2r_write_register_dword(a, MU_IN_LIST_IFC_CONFIG,\n\t\t\t\t    (dw | MU_ILIC_LIST_F0 | MU_ILIC_DEST_DDR));\n\tdw = esas2r_read_register_dword(a, MU_OUT_LIST_IFC_CONFIG);\n\tdw &= ~(MU_OLIC_LIST | MU_OLIC_SOURCE);\n\tesas2r_write_register_dword(a, MU_OUT_LIST_IFC_CONFIG,\n\t\t\t\t    (dw | MU_OLIC_LIST_F0 |\n\t\t\t\t     MU_OLIC_SOURCE_DDR));\n\n\t \n\tdw = esas2r_read_register_dword(a, MU_IN_LIST_CONFIG);\n\tdw &= ~(MU_ILC_ENTRY_MASK | MU_ILC_NUMBER_MASK);\n\tdw |= MU_ILC_ENTRY_4_DW | MU_ILC_DYNAMIC_SRC\n\t      | (a->list_size << MU_ILC_NUMBER_SHIFT);\n\tesas2r_write_register_dword(a, MU_IN_LIST_CONFIG, dw);\n\tdw = esas2r_read_register_dword(a, MU_OUT_LIST_CONFIG);\n\tdw &= ~(MU_OLC_ENTRY_MASK | MU_OLC_NUMBER_MASK);\n\tdw |= MU_OLC_ENTRY_4_DW | (a->list_size << MU_OLC_NUMBER_SHIFT);\n\tesas2r_write_register_dword(a, MU_OUT_LIST_CONFIG, dw);\n\n\t \n\tesas2r_write_register_dword(a, MU_DOORBELL_IN, DRBL_MSG_IFC_INIT);\n\tstarttime = jiffies_to_msecs(jiffies);\n\n\twhile (true) {\n\t\tdoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\n\t\tif (doorbell & DRBL_MSG_IFC_INIT) {\n\t\t\tesas2r_write_register_dword(a, MU_DOORBELL_OUT,\n\t\t\t\t\t\t    doorbell);\n\t\t\tbreak;\n\t\t}\n\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(100));\n\n\t\tif ((jiffies_to_msecs(jiffies) - starttime) > 3000) {\n\t\t\tesas2r_hdebug(\n\t\t\t\t\"timeout waiting for communication list init\");\n\t\t\tesas2r_bugon();\n\t\t\treturn esas2r_set_degraded_mode(a,\n\t\t\t\t\t\t\t\"timeout waiting for communication list init\");\n\t\t}\n\t}\n\n\t \n\tdoorbell = esas2r_read_register_dword(a, MU_DOORBELL_IN_ENB);\n\tif (doorbell & DRBL_POWER_DOWN)\n\t\tset_bit(AF2_VDA_POWER_DOWN, &a->flags2);\n\telse\n\t\tclear_bit(AF2_VDA_POWER_DOWN, &a->flags2);\n\n\t \n\tesas2r_write_register_dword(a, MU_OUT_LIST_INT_MASK, MU_OLIS_MASK);\n\tesas2r_write_register_dword(a, MU_DOORBELL_OUT_ENB, DRBL_ENB_MASK);\n\treturn true;\n}\n\n \nstatic bool esas2r_format_init_msg(struct esas2r_adapter *a,\n\t\t\t\t   struct esas2r_request *rq)\n{\n\tu32 msg = a->init_msg;\n\tstruct atto_vda_cfg_init *ci;\n\n\ta->init_msg = 0;\n\n\tswitch (msg) {\n\tcase ESAS2R_INIT_MSG_START:\n\tcase ESAS2R_INIT_MSG_REINIT:\n\t{\n\t\tesas2r_hdebug(\"CFG init\");\n\t\tesas2r_build_cfg_req(a,\n\t\t\t\t     rq,\n\t\t\t\t     VDA_CFG_INIT,\n\t\t\t\t     0,\n\t\t\t\t     NULL);\n\t\tci = (struct atto_vda_cfg_init *)&rq->vrq->cfg.data.init;\n\t\tci->sgl_page_size = cpu_to_le32(sgl_page_size);\n\t\t \n\t\tci->epoch_time = cpu_to_le32(ktime_get_real_seconds());\n\t\trq->flags |= RF_FAILURE_OK;\n\t\ta->init_msg = ESAS2R_INIT_MSG_INIT;\n\t\tbreak;\n\t}\n\n\tcase ESAS2R_INIT_MSG_INIT:\n\t\tif (rq->req_stat == RS_SUCCESS) {\n\t\t\tu32 major;\n\t\t\tu32 minor;\n\t\t\tu16 fw_release;\n\n\t\t\ta->fw_version = le16_to_cpu(\n\t\t\t\trq->func_rsp.cfg_rsp.vda_version);\n\t\t\ta->fw_build = rq->func_rsp.cfg_rsp.fw_build;\n\t\t\tfw_release = le16_to_cpu(\n\t\t\t\trq->func_rsp.cfg_rsp.fw_release);\n\t\t\tmajor = LOBYTE(fw_release);\n\t\t\tminor = HIBYTE(fw_release);\n\t\t\ta->fw_version += (major << 16) + (minor << 24);\n\t\t} else {\n\t\t\tesas2r_hdebug(\"FAILED\");\n\t\t}\n\n\t\t \n\n\t\tif ((test_bit(AF2_THUNDERBOLT, &a->flags2))\n\t\t    || (be32_to_cpu(a->fw_version) > 0x00524702)) {\n\t\t\tesas2r_hdebug(\"CFG get init\");\n\t\t\tesas2r_build_cfg_req(a,\n\t\t\t\t\t     rq,\n\t\t\t\t\t     VDA_CFG_GET_INIT2,\n\t\t\t\t\t     sizeof(struct atto_vda_cfg_init),\n\t\t\t\t\t     NULL);\n\n\t\t\trq->vrq->cfg.sg_list_offset = offsetof(\n\t\t\t\tstruct atto_vda_cfg_req,\n\t\t\t\tdata.sge);\n\t\t\trq->vrq->cfg.data.prde.ctl_len =\n\t\t\t\tcpu_to_le32(sizeof(struct atto_vda_cfg_init));\n\t\t\trq->vrq->cfg.data.prde.address = cpu_to_le64(\n\t\t\t\trq->vrq_md->phys_addr +\n\t\t\t\tsizeof(union atto_vda_req));\n\t\t\trq->flags |= RF_FAILURE_OK;\n\t\t\ta->init_msg = ESAS2R_INIT_MSG_GET_INIT;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tcase ESAS2R_INIT_MSG_GET_INIT:\n\t\tif (msg == ESAS2R_INIT_MSG_GET_INIT) {\n\t\t\tci = (struct atto_vda_cfg_init *)rq->data_buf;\n\t\t\tif (rq->req_stat == RS_SUCCESS) {\n\t\t\t\ta->num_targets_backend =\n\t\t\t\t\tle32_to_cpu(ci->num_targets_backend);\n\t\t\t\ta->ioctl_tunnel =\n\t\t\t\t\tle32_to_cpu(ci->ioctl_tunnel);\n\t\t\t} else {\n\t\t\t\tesas2r_hdebug(\"FAILED\");\n\t\t\t}\n\t\t}\n\t\tfallthrough;\n\n\tdefault:\n\t\trq->req_stat = RS_SUCCESS;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nbool esas2r_init_msgs(struct esas2r_adapter *a)\n{\n\tbool success = true;\n\tstruct esas2r_request *rq = &a->general_req;\n\n\tesas2r_rq_init_request(rq, a);\n\trq->comp_cb = esas2r_dummy_complete;\n\n\tif (a->init_msg == 0)\n\t\ta->init_msg = ESAS2R_INIT_MSG_REINIT;\n\n\twhile (a->init_msg) {\n\t\tif (esas2r_format_init_msg(a, rq)) {\n\t\t\tunsigned long flags;\n\t\t\twhile (true) {\n\t\t\t\tspin_lock_irqsave(&a->queue_lock, flags);\n\t\t\t\tesas2r_start_vda_request(a, rq);\n\t\t\t\tspin_unlock_irqrestore(&a->queue_lock, flags);\n\t\t\t\tesas2r_wait_request(a, rq);\n\t\t\t\tif (rq->req_stat != RS_PENDING)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (rq->req_stat == RS_SUCCESS\n\t\t    || ((rq->flags & RF_FAILURE_OK)\n\t\t\t&& rq->req_stat != RS_TIMEOUT))\n\t\t\tcontinue;\n\n\t\tesas2r_log(ESAS2R_LOG_CRIT, \"init message %x failed (%x, %x)\",\n\t\t\t   a->init_msg, rq->req_stat, rq->flags);\n\t\ta->init_msg = ESAS2R_INIT_MSG_START;\n\t\tsuccess = false;\n\t\tbreak;\n\t}\n\n\tesas2r_rq_destroy_request(rq, a);\n\treturn success;\n}\n\n \nbool esas2r_init_adapter_hw(struct esas2r_adapter *a, bool init_poll)\n{\n\tbool rslt = false;\n\tstruct esas2r_request *rq;\n\tu32 i;\n\n\tif (test_bit(AF_DEGRADED_MODE, &a->flags))\n\t\tgoto exit;\n\n\tif (!test_bit(AF_NVR_VALID, &a->flags)) {\n\t\tif (!esas2r_nvram_read_direct(a))\n\t\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t\t   \"invalid/missing NVRAM parameters\");\n\t}\n\n\tif (!esas2r_init_msgs(a)) {\n\t\tesas2r_set_degraded_mode(a, \"init messages failed\");\n\t\tgoto exit;\n\t}\n\n\t \n\tclear_bit(AF_DEGRADED_MODE, &a->flags);\n\tclear_bit(AF_CHPRST_PENDING, &a->flags);\n\n\t \n\tfor (i = 0, rq = a->first_ae_req; i < num_ae_requests; i++, rq++)\n\t\tesas2r_start_ae_request(a, rq);\n\n\tif (!a->flash_rev[0])\n\t\tesas2r_read_flash_rev(a);\n\n\tif (!a->image_type[0])\n\t\tesas2r_read_image_type(a);\n\n\tif (a->fw_version == 0)\n\t\ta->fw_rev[0] = 0;\n\telse\n\t\tsprintf(a->fw_rev, \"%1d.%02d\",\n\t\t\t(int)LOBYTE(HIWORD(a->fw_version)),\n\t\t\t(int)HIBYTE(HIWORD(a->fw_version)));\n\n\tesas2r_hdebug(\"firmware revision: %s\", a->fw_rev);\n\n\tif (test_bit(AF_CHPRST_DETECTED, &a->flags)\n\t    && (test_bit(AF_FIRST_INIT, &a->flags))) {\n\t\tesas2r_enable_chip_interrupts(a);\n\t\treturn true;\n\t}\n\n\t \n\tesas2r_disc_initialize(a);\n\n\t \n\tif (init_poll) {\n\t\tu32 currtime = a->disc_start_time;\n\t\tu32 nexttick = 100;\n\t\tu32 deltatime;\n\n\t\t \n\t\tset_bit(AF_TASKLET_SCHEDULED, &a->flags);\n\t\tset_bit(AF_DISC_POLLED, &a->flags);\n\n\t\t \n\t\tif (test_bit(AF_FIRST_INIT, &a->flags))\n\t\t\tatomic_dec(&a->disable_cnt);\n\n\t\twhile (test_bit(AF_DISC_PENDING, &a->flags)) {\n\t\t\tschedule_timeout_interruptible(msecs_to_jiffies(100));\n\n\t\t\t \n\t\t\tdeltatime = jiffies_to_msecs(jiffies) - currtime;\n\t\t\tcurrtime += deltatime;\n\n\t\t\t \n\t\t\tif (!test_bit(AF_CHPRST_PENDING, &a->flags))\n\t\t\t\tesas2r_disc_check_for_work(a);\n\n\t\t\t \n\t\t\tif (nexttick <= deltatime) {\n\n\t\t\t\t \n\t\t\t\tnexttick += 100;\n\t\t\t\tesas2r_timer_tick(a);\n\t\t\t}\n\n\t\t\tif (nexttick > deltatime)\n\t\t\t\tnexttick -= deltatime;\n\n\t\t\t \n\t\t\tif (esas2r_is_tasklet_pending(a))\n\t\t\t\tesas2r_do_tasklet_tasks(a);\n\n\t\t}\n\n\t\tif (test_bit(AF_FIRST_INIT, &a->flags))\n\t\t\tatomic_inc(&a->disable_cnt);\n\n\t\tclear_bit(AF_DISC_POLLED, &a->flags);\n\t\tclear_bit(AF_TASKLET_SCHEDULED, &a->flags);\n\t}\n\n\n\tesas2r_targ_db_report_changes(a);\n\n\t \n\tesas2r_disc_start_waiting(a);\n\n\t \n\ta->int_mask = ESAS2R_INT_STS_MASK;\n\tesas2r_enable_chip_interrupts(a);\n\tesas2r_enable_heartbeat(a);\n\trslt = true;\n\nexit:\n\t \n\n\tif (test_bit(AF_CHPRST_DETECTED, &a->flags) &&\n\t    test_bit(AF_FIRST_INIT, &a->flags)) {\n\t\t \n\t\tif (!rslt)\n\t\t\tclear_bit(AF_CHPRST_PENDING, &a->flags);\n\t} else {\n\t\t \n\t\tif (!rslt) {\n\t\t\tclear_bit(AF_CHPRST_PENDING, &a->flags);\n\t\t\tclear_bit(AF_DISC_PENDING, &a->flags);\n\t\t}\n\n\n\t\t \n\t\tif (test_bit(AF_FIRST_INIT, &a->flags)) {\n\t\t\tclear_bit(AF_FIRST_INIT, &a->flags);\n\n\t\t\tif (atomic_dec_return(&a->disable_cnt) == 0)\n\t\t\t\tesas2r_do_deferred_processes(a);\n\t\t}\n\t}\n\n\treturn rslt;\n}\n\nvoid esas2r_reset_adapter(struct esas2r_adapter *a)\n{\n\tset_bit(AF_OS_RESET, &a->flags);\n\tesas2r_local_reset_adapter(a);\n\tesas2r_schedule_tasklet(a);\n}\n\nvoid esas2r_reset_chip(struct esas2r_adapter *a)\n{\n\tif (!esas2r_is_adapter_present(a))\n\t\treturn;\n\n\t \n\tif (test_bit(AF2_COREDUMP_AVAIL, &a->flags2) &&\n\t    !test_bit(AF2_COREDUMP_SAVED, &a->flags2)) {\n\t\tesas2r_read_mem_block(a,\n\t\t\t\t      a->fw_coredump_buff,\n\t\t\t\t      MW_DATA_ADDR_SRAM + 0x80000,\n\t\t\t\t      ESAS2R_FWCOREDUMP_SZ);\n\n\t\tset_bit(AF2_COREDUMP_SAVED, &a->flags2);\n\t}\n\n\tclear_bit(AF2_COREDUMP_AVAIL, &a->flags2);\n\n\t \n\tif (a->pcid->revision == MVR_FREY_B2)\n\t\tesas2r_write_register_dword(a, MU_CTL_STATUS_IN_B2,\n\t\t\t\t\t    MU_CTL_IN_FULL_RST2);\n\telse\n\t\tesas2r_write_register_dword(a, MU_CTL_STATUS_IN,\n\t\t\t\t\t    MU_CTL_IN_FULL_RST);\n\n\n\t \n\tmdelay(10);\n}\n\nstatic void esas2r_power_down_notify_firmware(struct esas2r_adapter *a)\n{\n\tu32 starttime;\n\tu32 doorbell;\n\n\tesas2r_write_register_dword(a, MU_DOORBELL_IN, DRBL_POWER_DOWN);\n\tstarttime = jiffies_to_msecs(jiffies);\n\n\twhile (true) {\n\t\tdoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\n\t\tif (doorbell & DRBL_POWER_DOWN) {\n\t\t\tesas2r_write_register_dword(a, MU_DOORBELL_OUT,\n\t\t\t\t\t\t    doorbell);\n\t\t\tbreak;\n\t\t}\n\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(100));\n\n\t\tif ((jiffies_to_msecs(jiffies) - starttime) > 30000) {\n\t\t\tesas2r_hdebug(\"Timeout waiting for power down\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nvoid esas2r_power_down(struct esas2r_adapter *a)\n{\n\tset_bit(AF_POWER_MGT, &a->flags);\n\tset_bit(AF_POWER_DOWN, &a->flags);\n\n\tif (!test_bit(AF_DEGRADED_MODE, &a->flags)) {\n\t\tu32 starttime;\n\t\tu32 doorbell;\n\n\t\t \n\t\tesas2r_disable_chip_interrupts(a);\n\t\tesas2r_disable_heartbeat(a);\n\n\t\t \n\t\tesas2r_write_register_dword(a, MU_DOORBELL_IN,\n\t\t\t\t\t    DRBL_MSG_IFC_DOWN);\n\t\tstarttime = jiffies_to_msecs(jiffies);\n\n\t\twhile (true) {\n\t\t\tdoorbell =\n\t\t\t\tesas2r_read_register_dword(a, MU_DOORBELL_OUT);\n\t\t\tif (doorbell & DRBL_MSG_IFC_DOWN) {\n\t\t\t\tesas2r_write_register_dword(a, MU_DOORBELL_OUT,\n\t\t\t\t\t\t\t    doorbell);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tschedule_timeout_interruptible(msecs_to_jiffies(100));\n\n\t\t\tif ((jiffies_to_msecs(jiffies) - starttime) > 3000) {\n\t\t\t\tesas2r_hdebug(\n\t\t\t\t\t\"timeout waiting for interface down\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (test_bit(AF2_VDA_POWER_DOWN, &a->flags2))\n\t\t\tesas2r_power_down_notify_firmware(a);\n\t}\n\n\t \n\tset_bit(AF_OS_RESET, &a->flags);\n\tset_bit(AF_DISC_PENDING, &a->flags);\n\tset_bit(AF_CHPRST_PENDING, &a->flags);\n\n\tesas2r_process_adapter_reset(a);\n\n\t \n\ta->prev_dev_cnt = esas2r_targ_db_get_tgt_cnt(a);\n\tesas2r_targ_db_remove_all(a, false);\n}\n\n \nbool esas2r_power_up(struct esas2r_adapter *a, bool init_poll)\n{\n\tbool ret;\n\n\tclear_bit(AF_POWER_DOWN, &a->flags);\n\tesas2r_init_pci_cfg_space(a);\n\tset_bit(AF_FIRST_INIT, &a->flags);\n\tatomic_inc(&a->disable_cnt);\n\n\t \n\tret = esas2r_check_adapter(a);\n\tif (!esas2r_init_adapter_hw(a, init_poll))\n\t\tret = false;\n\n\t \n\tesas2r_send_reset_ae(a, true);\n\n\t \n\tclear_bit(AF_POWER_MGT, &a->flags);\n\treturn ret;\n}\n\nbool esas2r_is_adapter_present(struct esas2r_adapter *a)\n{\n\tif (test_bit(AF_NOT_PRESENT, &a->flags))\n\t\treturn false;\n\n\tif (esas2r_read_register_dword(a, MU_DOORBELL_OUT) == 0xFFFFFFFF) {\n\t\tset_bit(AF_NOT_PRESENT, &a->flags);\n\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst char *esas2r_get_model_name(struct esas2r_adapter *a)\n{\n\tswitch (a->pcid->subsystem_device) {\n\tcase ATTO_ESAS_R680:\n\t\treturn \"ATTO ExpressSAS R680\";\n\n\tcase ATTO_ESAS_R608:\n\t\treturn \"ATTO ExpressSAS R608\";\n\n\tcase ATTO_ESAS_R60F:\n\t\treturn \"ATTO ExpressSAS R60F\";\n\n\tcase ATTO_ESAS_R6F0:\n\t\treturn \"ATTO ExpressSAS R6F0\";\n\n\tcase ATTO_ESAS_R644:\n\t\treturn \"ATTO ExpressSAS R644\";\n\n\tcase ATTO_ESAS_R648:\n\t\treturn \"ATTO ExpressSAS R648\";\n\n\tcase ATTO_TSSC_3808:\n\t\treturn \"ATTO ThunderStream SC 3808D\";\n\n\tcase ATTO_TSSC_3808E:\n\t\treturn \"ATTO ThunderStream SC 3808E\";\n\n\tcase ATTO_TLSH_1068:\n\t\treturn \"ATTO ThunderLink SH 1068\";\n\t}\n\n\treturn \"ATTO SAS Controller\";\n}\n\nconst char *esas2r_get_model_name_short(struct esas2r_adapter *a)\n{\n\tswitch (a->pcid->subsystem_device) {\n\tcase ATTO_ESAS_R680:\n\t\treturn \"R680\";\n\n\tcase ATTO_ESAS_R608:\n\t\treturn \"R608\";\n\n\tcase ATTO_ESAS_R60F:\n\t\treturn \"R60F\";\n\n\tcase ATTO_ESAS_R6F0:\n\t\treturn \"R6F0\";\n\n\tcase ATTO_ESAS_R644:\n\t\treturn \"R644\";\n\n\tcase ATTO_ESAS_R648:\n\t\treturn \"R648\";\n\n\tcase ATTO_TSSC_3808:\n\t\treturn \"SC 3808D\";\n\n\tcase ATTO_TSSC_3808E:\n\t\treturn \"SC 3808E\";\n\n\tcase ATTO_TLSH_1068:\n\t\treturn \"SH 1068\";\n\t}\n\n\treturn \"unknown\";\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}