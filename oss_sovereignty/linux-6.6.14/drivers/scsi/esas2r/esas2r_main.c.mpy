{
  "module_name": "esas2r_main.c",
  "hash_id": "5c5382230bf6f679fb9fde3e4a589d176605ccbcd299924a6c48ee9a473ec710",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/esas2r/esas2r_main.c",
  "human_readable_source": " \n\n#include \"esas2r.h\"\n\nMODULE_DESCRIPTION(ESAS2R_DRVR_NAME \": \" ESAS2R_LONGNAME \" driver\");\nMODULE_AUTHOR(\"ATTO Technology, Inc.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(ESAS2R_VERSION_STR);\n\n \n\nstatic int found_adapters;\nstruct esas2r_adapter *esas2r_adapters[MAX_ADAPTERS];\n\n#define ESAS2R_VDA_EVENT_PORT1       54414\n#define ESAS2R_VDA_EVENT_PORT2       54415\n#define ESAS2R_VDA_EVENT_SOCK_COUNT  2\n\nstatic struct esas2r_adapter *esas2r_adapter_from_kobj(struct kobject *kobj)\n{\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\n\treturn (struct esas2r_adapter *)host->hostdata;\n}\n\nstatic ssize_t read_fw(struct file *file, struct kobject *kobj,\n\t\t       struct bin_attribute *attr,\n\t\t       char *buf, loff_t off, size_t count)\n{\n\tstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\n\n\treturn esas2r_read_fw(a, buf, off, count);\n}\n\nstatic ssize_t write_fw(struct file *file, struct kobject *kobj,\n\t\t\tstruct bin_attribute *attr,\n\t\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\n\n\treturn esas2r_write_fw(a, buf, off, count);\n}\n\nstatic ssize_t read_fs(struct file *file, struct kobject *kobj,\n\t\t       struct bin_attribute *attr,\n\t\t       char *buf, loff_t off, size_t count)\n{\n\tstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\n\n\treturn esas2r_read_fs(a, buf, off, count);\n}\n\nstatic ssize_t write_fs(struct file *file, struct kobject *kobj,\n\t\t\tstruct bin_attribute *attr,\n\t\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\n\tint length = min(sizeof(struct esas2r_ioctl_fs), count);\n\tint result = 0;\n\n\tresult = esas2r_write_fs(a, buf, off, count);\n\n\tif (result < 0)\n\t\tresult = 0;\n\n\treturn length;\n}\n\nstatic ssize_t read_vda(struct file *file, struct kobject *kobj,\n\t\t\tstruct bin_attribute *attr,\n\t\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\n\n\treturn esas2r_read_vda(a, buf, off, count);\n}\n\nstatic ssize_t write_vda(struct file *file, struct kobject *kobj,\n\t\t\t struct bin_attribute *attr,\n\t\t\t char *buf, loff_t off, size_t count)\n{\n\tstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\n\n\treturn esas2r_write_vda(a, buf, off, count);\n}\n\nstatic ssize_t read_live_nvram(struct file *file, struct kobject *kobj,\n\t\t\t       struct bin_attribute *attr,\n\t\t\t       char *buf, loff_t off, size_t count)\n{\n\tstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\n\tint length = min_t(size_t, sizeof(struct esas2r_sas_nvram), PAGE_SIZE);\n\n\tmemcpy(buf, a->nvram, length);\n\treturn length;\n}\n\nstatic ssize_t write_live_nvram(struct file *file, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *attr,\n\t\t\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\n\tstruct esas2r_request *rq;\n\tint result = -EFAULT;\n\n\trq = esas2r_alloc_request(a);\n\tif (rq == NULL)\n\t\treturn -ENOMEM;\n\n\tif (esas2r_write_params(a, rq, (struct esas2r_sas_nvram *)buf))\n\t\tresult = count;\n\n\tesas2r_free_request(a, rq);\n\n\treturn result;\n}\n\nstatic ssize_t read_default_nvram(struct file *file, struct kobject *kobj,\n\t\t\t\t  struct bin_attribute *attr,\n\t\t\t\t  char *buf, loff_t off, size_t count)\n{\n\tstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\n\n\tesas2r_nvram_get_defaults(a, (struct esas2r_sas_nvram *)buf);\n\n\treturn sizeof(struct esas2r_sas_nvram);\n}\n\nstatic ssize_t read_hw(struct file *file, struct kobject *kobj,\n\t\t       struct bin_attribute *attr,\n\t\t       char *buf, loff_t off, size_t count)\n{\n\tstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\n\tint length = min_t(size_t, sizeof(struct atto_ioctl), PAGE_SIZE);\n\n\tif (!a->local_atto_ioctl)\n\t\treturn -ENOMEM;\n\n\tif (handle_hba_ioctl(a, a->local_atto_ioctl) != IOCTL_SUCCESS)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, a->local_atto_ioctl, length);\n\n\treturn length;\n}\n\nstatic ssize_t write_hw(struct file *file, struct kobject *kobj,\n\t\t\tstruct bin_attribute *attr,\n\t\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\n\tint length = min(sizeof(struct atto_ioctl), count);\n\n\tif (!a->local_atto_ioctl) {\n\t\ta->local_atto_ioctl = kmalloc(sizeof(struct atto_ioctl),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (a->local_atto_ioctl == NULL) {\n\t\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t\t   \"write_hw kzalloc failed for %zu bytes\",\n\t\t\t\t   sizeof(struct atto_ioctl));\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tmemset(a->local_atto_ioctl, 0, sizeof(struct atto_ioctl));\n\tmemcpy(a->local_atto_ioctl, buf, length);\n\n\treturn length;\n}\n\n#define ESAS2R_RW_BIN_ATTR(_name) \\\n\tstruct bin_attribute bin_attr_ ## _name = { \\\n\t\t.attr\t= \\\n\t\t{ .name = __stringify(_name), .mode  = S_IRUSR | S_IWUSR }, \\\n\t\t.size\t= 0, \\\n\t\t.read\t= read_ ## _name, \\\n\t\t.write\t= write_ ## _name }\n\nESAS2R_RW_BIN_ATTR(fw);\nESAS2R_RW_BIN_ATTR(fs);\nESAS2R_RW_BIN_ATTR(vda);\nESAS2R_RW_BIN_ATTR(hw);\nESAS2R_RW_BIN_ATTR(live_nvram);\n\nstruct bin_attribute bin_attr_default_nvram = {\n\t.attr\t= { .name = \"default_nvram\", .mode = S_IRUGO },\n\t.size\t= 0,\n\t.read\t= read_default_nvram,\n\t.write\t= NULL\n};\n\nstatic const struct scsi_host_template driver_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.show_info\t\t\t= esas2r_show_info,\n\t.name\t\t\t\t= ESAS2R_LONGNAME,\n\t.info\t\t\t\t= esas2r_info,\n\t.ioctl\t\t\t\t= esas2r_ioctl,\n\t.queuecommand\t\t\t= esas2r_queuecommand,\n\t.eh_abort_handler\t\t= esas2r_eh_abort,\n\t.eh_device_reset_handler\t= esas2r_device_reset,\n\t.eh_bus_reset_handler\t\t= esas2r_bus_reset,\n\t.eh_host_reset_handler\t\t= esas2r_host_reset,\n\t.eh_target_reset_handler\t= esas2r_target_reset,\n\t.can_queue\t\t\t= 128,\n\t.this_id\t\t\t= -1,\n\t.sg_tablesize\t\t\t= SG_CHUNK_SIZE,\n\t.cmd_per_lun\t\t\t=\n\t\tESAS2R_DEFAULT_CMD_PER_LUN,\n\t.proc_name\t\t\t= ESAS2R_DRVR_NAME,\n\t.change_queue_depth\t\t= scsi_change_queue_depth,\n\t.max_sectors\t\t\t= 0xFFFF,\n};\n\nint sgl_page_size = 512;\nmodule_param(sgl_page_size, int, 0);\nMODULE_PARM_DESC(sgl_page_size,\n\t\t \"Scatter/gather list (SGL) page size in number of S/G \"\n\t\t \"entries.  If your application is doing a lot of very large \"\n\t\t \"transfers, you may want to increase the SGL page size.  \"\n\t\t \"Default 512.\");\n\nint num_sg_lists = 1024;\nmodule_param(num_sg_lists, int, 0);\nMODULE_PARM_DESC(num_sg_lists,\n\t\t \"Number of scatter/gather lists.  Default 1024.\");\n\nint sg_tablesize = SG_CHUNK_SIZE;\nmodule_param(sg_tablesize, int, 0);\nMODULE_PARM_DESC(sg_tablesize,\n\t\t \"Maximum number of entries in a scatter/gather table.\");\n\nint num_requests = 256;\nmodule_param(num_requests, int, 0);\nMODULE_PARM_DESC(num_requests,\n\t\t \"Number of requests.  Default 256.\");\n\nint num_ae_requests = 4;\nmodule_param(num_ae_requests, int, 0);\nMODULE_PARM_DESC(num_ae_requests,\n\t\t \"Number of VDA asynchronous event requests.  Default 4.\");\n\nint cmd_per_lun = ESAS2R_DEFAULT_CMD_PER_LUN;\nmodule_param(cmd_per_lun, int, 0);\nMODULE_PARM_DESC(cmd_per_lun,\n\t\t \"Maximum number of commands per LUN.  Default \"\n\t\t DEFINED_NUM_TO_STR(ESAS2R_DEFAULT_CMD_PER_LUN) \".\");\n\nint can_queue = 128;\nmodule_param(can_queue, int, 0);\nMODULE_PARM_DESC(can_queue,\n\t\t \"Maximum number of commands per adapter.  Default 128.\");\n\nint esas2r_max_sectors = 0xFFFF;\nmodule_param(esas2r_max_sectors, int, 0);\nMODULE_PARM_DESC(esas2r_max_sectors,\n\t\t \"Maximum number of disk sectors in a single data transfer.  \"\n\t\t \"Default 65535 (largest possible setting).\");\n\nint interrupt_mode = 1;\nmodule_param(interrupt_mode, int, 0);\nMODULE_PARM_DESC(interrupt_mode,\n\t\t \"Defines the interrupt mode to use.  0 for legacy\"\n\t\t \", 1 for MSI.  Default is MSI (1).\");\n\nstatic const struct pci_device_id\n\tesas2r_pci_table[] = {\n\t{ ATTO_VENDOR_ID, 0x0049,\t  ATTO_VENDOR_ID, 0x0049,\n\t  0,\n\t  0, 0 },\n\t{ ATTO_VENDOR_ID, 0x0049,\t  ATTO_VENDOR_ID, 0x004A,\n\t  0,\n\t  0, 0 },\n\t{ ATTO_VENDOR_ID, 0x0049,\t  ATTO_VENDOR_ID, 0x004B,\n\t  0,\n\t  0, 0 },\n\t{ ATTO_VENDOR_ID, 0x0049,\t  ATTO_VENDOR_ID, 0x004C,\n\t  0,\n\t  0, 0 },\n\t{ ATTO_VENDOR_ID, 0x0049,\t  ATTO_VENDOR_ID, 0x004D,\n\t  0,\n\t  0, 0 },\n\t{ ATTO_VENDOR_ID, 0x0049,\t  ATTO_VENDOR_ID, 0x004E,\n\t  0,\n\t  0, 0 },\n\t{ 0,\t\t  0,\t\t  0,\t\t  0,\n\t  0,\n\t  0, 0 }\n};\n\nMODULE_DEVICE_TABLE(pci, esas2r_pci_table);\n\nstatic int\nesas2r_probe(struct pci_dev *pcid, const struct pci_device_id *id);\n\nstatic void\nesas2r_remove(struct pci_dev *pcid);\n\nstatic struct pci_driver\n\tesas2r_pci_driver = {\n\t.name\t\t= ESAS2R_DRVR_NAME,\n\t.id_table\t= esas2r_pci_table,\n\t.probe\t\t= esas2r_probe,\n\t.remove\t\t= esas2r_remove,\n\t.driver.pm\t= &esas2r_pm_ops,\n};\n\nstatic int esas2r_probe(struct pci_dev *pcid,\n\t\t\tconst struct pci_device_id *id)\n{\n\tstruct Scsi_Host *host = NULL;\n\tstruct esas2r_adapter *a;\n\tint err;\n\n\tsize_t host_alloc_size = sizeof(struct esas2r_adapter)\n\t\t\t\t + ((num_requests) +\n\t\t\t\t    1) * sizeof(struct esas2r_request);\n\n\tesas2r_log_dev(ESAS2R_LOG_DEBG, &(pcid->dev),\n\t\t       \"esas2r_probe() 0x%02x 0x%02x 0x%02x 0x%02x\",\n\t\t       pcid->vendor,\n\t\t       pcid->device,\n\t\t       pcid->subsystem_vendor,\n\t\t       pcid->subsystem_device);\n\n\tesas2r_log_dev(ESAS2R_LOG_INFO, &(pcid->dev),\n\t\t       \"before pci_enable_device() \"\n\t\t       \"enable_cnt: %d\",\n\t\t       pcid->enable_cnt.counter);\n\n\terr = pci_enable_device(pcid);\n\tif (err != 0) {\n\t\tesas2r_log_dev(ESAS2R_LOG_CRIT, &(pcid->dev),\n\t\t\t       \"pci_enable_device() FAIL (%d)\",\n\t\t\t       err);\n\t\treturn -ENODEV;\n\t}\n\n\tesas2r_log_dev(ESAS2R_LOG_INFO, &(pcid->dev),\n\t\t       \"pci_enable_device() OK\");\n\tesas2r_log_dev(ESAS2R_LOG_INFO, &(pcid->dev),\n\t\t       \"after pci_enable_device() enable_cnt: %d\",\n\t\t       pcid->enable_cnt.counter);\n\n\thost = scsi_host_alloc(&driver_template, host_alloc_size);\n\tif (host == NULL) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT, \"scsi_host_alloc() FAIL\");\n\t\treturn -ENODEV;\n\t}\n\n\tmemset(host->hostdata, 0, host_alloc_size);\n\n\ta = (struct esas2r_adapter *)host->hostdata;\n\n\tesas2r_log(ESAS2R_LOG_INFO, \"scsi_host_alloc() OK host: %p\", host);\n\n\t \n\n\thost->max_id = ESAS2R_MAX_ID + 1;\n\thost->max_lun = 255;\n\n\t \n\n\thost->max_cmd_len = 16;\n\n\thost->can_queue = can_queue;\n\thost->cmd_per_lun = cmd_per_lun;\n\thost->this_id = host->max_id + 1;\n\thost->max_channel = 0;\n\thost->unique_id = found_adapters;\n\thost->sg_tablesize = sg_tablesize;\n\thost->max_sectors = esas2r_max_sectors;\n\n\t \n\n\tesas2r_log(ESAS2R_LOG_INFO, \"pci_set_master() called\");\n\n\tpci_set_master(pcid);\n\n\tif (!esas2r_init_adapter(host, pcid, found_adapters)) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"unable to initialize device at PCI bus %x:%x\",\n\t\t\t   pcid->bus->number,\n\t\t\t   pcid->devfn);\n\n\t\tesas2r_log_dev(ESAS2R_LOG_INFO, &(host->shost_gendev),\n\t\t\t       \"scsi_host_put() called\");\n\n\t\tscsi_host_put(host);\n\n\t\treturn 0;\n\n\t}\n\n\tesas2r_log(ESAS2R_LOG_INFO, \"pci_set_drvdata(%p, %p) called\", pcid,\n\t\t   host->hostdata);\n\n\tpci_set_drvdata(pcid, host);\n\n\tesas2r_log(ESAS2R_LOG_INFO, \"scsi_add_host() called\");\n\n\terr = scsi_add_host(host, &pcid->dev);\n\n\tif (err) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT, \"scsi_add_host returned %d\", err);\n\t\tesas2r_log_dev(ESAS2R_LOG_CRIT, &(host->shost_gendev),\n\t\t\t       \"scsi_add_host() FAIL\");\n\n\t\tesas2r_log_dev(ESAS2R_LOG_INFO, &(host->shost_gendev),\n\t\t\t       \"scsi_host_put() called\");\n\n\t\tscsi_host_put(host);\n\n\t\tesas2r_log_dev(ESAS2R_LOG_INFO, &(host->shost_gendev),\n\t\t\t       \"pci_set_drvdata(%p, NULL) called\",\n\t\t\t       pcid);\n\n\t\tpci_set_drvdata(pcid, NULL);\n\n\t\treturn -ENODEV;\n\t}\n\n\n\tesas2r_fw_event_on(a);\n\n\tesas2r_log_dev(ESAS2R_LOG_INFO, &(host->shost_gendev),\n\t\t       \"scsi_scan_host() called\");\n\n\tscsi_scan_host(host);\n\n\t \n\tif (sysfs_create_bin_file(&host->shost_dev.kobj, &bin_attr_fw))\n\t\tesas2r_log_dev(ESAS2R_LOG_WARN, &(host->shost_gendev),\n\t\t\t       \"Failed to create sysfs binary file: fw\");\n\telse\n\t\ta->sysfs_fw_created = 1;\n\n\tif (sysfs_create_bin_file(&host->shost_dev.kobj, &bin_attr_fs))\n\t\tesas2r_log_dev(ESAS2R_LOG_WARN, &(host->shost_gendev),\n\t\t\t       \"Failed to create sysfs binary file: fs\");\n\telse\n\t\ta->sysfs_fs_created = 1;\n\n\tif (sysfs_create_bin_file(&host->shost_dev.kobj, &bin_attr_vda))\n\t\tesas2r_log_dev(ESAS2R_LOG_WARN, &(host->shost_gendev),\n\t\t\t       \"Failed to create sysfs binary file: vda\");\n\telse\n\t\ta->sysfs_vda_created = 1;\n\n\tif (sysfs_create_bin_file(&host->shost_dev.kobj, &bin_attr_hw))\n\t\tesas2r_log_dev(ESAS2R_LOG_WARN, &(host->shost_gendev),\n\t\t\t       \"Failed to create sysfs binary file: hw\");\n\telse\n\t\ta->sysfs_hw_created = 1;\n\n\tif (sysfs_create_bin_file(&host->shost_dev.kobj, &bin_attr_live_nvram))\n\t\tesas2r_log_dev(ESAS2R_LOG_WARN, &(host->shost_gendev),\n\t\t\t       \"Failed to create sysfs binary file: live_nvram\");\n\telse\n\t\ta->sysfs_live_nvram_created = 1;\n\n\tif (sysfs_create_bin_file(&host->shost_dev.kobj,\n\t\t\t\t  &bin_attr_default_nvram))\n\t\tesas2r_log_dev(ESAS2R_LOG_WARN, &(host->shost_gendev),\n\t\t\t       \"Failed to create sysfs binary file: default_nvram\");\n\telse\n\t\ta->sysfs_default_nvram_created = 1;\n\n\tfound_adapters++;\n\n\treturn 0;\n}\n\nstatic void esas2r_remove(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct esas2r_adapter *a = (struct esas2r_adapter *)host->hostdata;\n\n\tesas2r_log_dev(ESAS2R_LOG_INFO, &(pdev->dev),\n\t\t       \"esas2r_remove(%p) called; \"\n\t\t       \"host:%p\", pdev,\n\t\t       host);\n\n\tesas2r_kill_adapter(a->index);\n\tfound_adapters--;\n}\n\nstatic int __init esas2r_init(void)\n{\n\tint i;\n\n\tesas2r_log(ESAS2R_LOG_INFO, \"%s called\", __func__);\n\n\t \n\n\tif (can_queue < 1) {\n\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t   \"warning: can_queue must be at least 1, value \"\n\t\t\t   \"forced.\");\n\t\tcan_queue = 1;\n\t} else if (can_queue > 2048) {\n\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t   \"warning: can_queue must be no larger than 2048, \"\n\t\t\t   \"value forced.\");\n\t\tcan_queue = 2048;\n\t}\n\n\tif (cmd_per_lun < 1) {\n\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t   \"warning: cmd_per_lun must be at least 1, value \"\n\t\t\t   \"forced.\");\n\t\tcmd_per_lun = 1;\n\t} else if (cmd_per_lun > 2048) {\n\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t   \"warning: cmd_per_lun must be no larger than \"\n\t\t\t   \"2048, value forced.\");\n\t\tcmd_per_lun = 2048;\n\t}\n\n\tif (sg_tablesize < 32) {\n\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t   \"warning: sg_tablesize must be at least 32, \"\n\t\t\t   \"value forced.\");\n\t\tsg_tablesize = 32;\n\t}\n\n\tif (esas2r_max_sectors < 1) {\n\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t   \"warning: esas2r_max_sectors must be at least \"\n\t\t\t   \"1, value forced.\");\n\t\tesas2r_max_sectors = 1;\n\t} else if (esas2r_max_sectors > 0xffff) {\n\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t   \"warning: esas2r_max_sectors must be no larger \"\n\t\t\t   \"than 0xffff, value forced.\");\n\t\tesas2r_max_sectors = 0xffff;\n\t}\n\n\tsgl_page_size &= ~(ESAS2R_SGL_ALIGN - 1);\n\n\tif (sgl_page_size < SGL_PG_SZ_MIN)\n\t\tsgl_page_size = SGL_PG_SZ_MIN;\n\telse if (sgl_page_size > SGL_PG_SZ_MAX)\n\t\tsgl_page_size = SGL_PG_SZ_MAX;\n\n\tif (num_sg_lists < NUM_SGL_MIN)\n\t\tnum_sg_lists = NUM_SGL_MIN;\n\telse if (num_sg_lists > NUM_SGL_MAX)\n\t\tnum_sg_lists = NUM_SGL_MAX;\n\n\tif (num_requests < NUM_REQ_MIN)\n\t\tnum_requests = NUM_REQ_MIN;\n\telse if (num_requests > NUM_REQ_MAX)\n\t\tnum_requests = NUM_REQ_MAX;\n\n\tif (num_ae_requests < NUM_AE_MIN)\n\t\tnum_ae_requests = NUM_AE_MIN;\n\telse if (num_ae_requests > NUM_AE_MAX)\n\t\tnum_ae_requests = NUM_AE_MAX;\n\n\t \n\n\tfor (i = 0; i < MAX_ADAPTERS; i++)\n\t\tesas2r_adapters[i] = NULL;\n\n\treturn pci_register_driver(&esas2r_pci_driver);\n}\n\n \nstatic const struct file_operations esas2r_proc_fops = {\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.unlocked_ioctl = esas2r_proc_ioctl,\n};\n\nstatic const struct proc_ops esas2r_proc_ops = {\n\t.proc_lseek\t\t= default_llseek,\n\t.proc_ioctl\t\t= esas2r_proc_ioctl,\n#ifdef CONFIG_COMPAT\n\t.proc_compat_ioctl\t= compat_ptr_ioctl,\n#endif\n};\n\nstatic struct Scsi_Host *esas2r_proc_host;\nstatic int esas2r_proc_major;\n\nlong esas2r_proc_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)\n{\n\treturn esas2r_ioctl_handler(esas2r_proc_host->hostdata,\n\t\t\t\t    cmd, (void __user *)arg);\n}\n\nstatic void __exit esas2r_exit(void)\n{\n\tesas2r_log(ESAS2R_LOG_INFO, \"%s called\", __func__);\n\n\tif (esas2r_proc_major > 0) {\n\t\tstruct proc_dir_entry *proc_dir;\n\n\t\tesas2r_log(ESAS2R_LOG_INFO, \"unregister proc\");\n\n\t\tproc_dir = scsi_template_proc_dir(esas2r_proc_host->hostt);\n\t\tif (proc_dir)\n\t\t\tremove_proc_entry(ATTONODE_NAME, proc_dir);\n\t\tunregister_chrdev(esas2r_proc_major, ESAS2R_DRVR_NAME);\n\n\t\tesas2r_proc_major = 0;\n\t}\n\n\tesas2r_log(ESAS2R_LOG_INFO, \"pci_unregister_driver() called\");\n\n\tpci_unregister_driver(&esas2r_pci_driver);\n}\n\nint esas2r_show_info(struct seq_file *m, struct Scsi_Host *sh)\n{\n\tstruct esas2r_adapter *a = (struct esas2r_adapter *)sh->hostdata;\n\n\tstruct esas2r_target *t;\n\tint dev_count = 0;\n\n\tesas2r_log(ESAS2R_LOG_DEBG, \"esas2r_show_info (%p,%d)\", m, sh->host_no);\n\n\tseq_printf(m, ESAS2R_LONGNAME \"\\n\"\n\t\t   \"Driver version: \"ESAS2R_VERSION_STR \"\\n\"\n\t\t   \"Flash version: %s\\n\"\n\t\t   \"Firmware version: %s\\n\"\n\t\t   \"Copyright \"ESAS2R_COPYRIGHT_YEARS \"\\n\"\n\t\t   \"http://www.attotech.com\\n\"\n\t\t   \"\\n\",\n\t\t   a->flash_rev,\n\t\t   a->fw_rev[0] ? a->fw_rev : \"(none)\");\n\n\n\tseq_printf(m, \"Adapter information:\\n\"\n\t\t   \"--------------------\\n\"\n\t\t   \"Model: %s\\n\"\n\t\t   \"SAS address: %02X%02X%02X%02X:%02X%02X%02X%02X\\n\",\n\t\t   esas2r_get_model_name(a),\n\t\t   a->nvram->sas_addr[0],\n\t\t   a->nvram->sas_addr[1],\n\t\t   a->nvram->sas_addr[2],\n\t\t   a->nvram->sas_addr[3],\n\t\t   a->nvram->sas_addr[4],\n\t\t   a->nvram->sas_addr[5],\n\t\t   a->nvram->sas_addr[6],\n\t\t   a->nvram->sas_addr[7]);\n\n\tseq_puts(m, \"\\n\"\n\t\t   \"Discovered devices:\\n\"\n\t\t   \"\\n\"\n\t\t   \"   #  Target ID\\n\"\n\t\t   \"---------------\\n\");\n\n\tfor (t = a->targetdb; t < a->targetdb_end; t++)\n\t\tif (t->buffered_target_state == TS_PRESENT) {\n\t\t\tseq_printf(m, \" %3d   %3d\\n\",\n\t\t\t\t   ++dev_count,\n\t\t\t\t   (u16)(uintptr_t)(t - a->targetdb));\n\t\t}\n\n\tif (dev_count == 0)\n\t\tseq_puts(m, \"none\\n\");\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n\n}\n\nconst char *esas2r_info(struct Scsi_Host *sh)\n{\n\tstruct esas2r_adapter *a = (struct esas2r_adapter *)sh->hostdata;\n\tstatic char esas2r_info_str[512];\n\n\tesas2r_log_dev(ESAS2R_LOG_INFO, &(sh->shost_gendev),\n\t\t       \"esas2r_info() called\");\n\n\t \n\n\tif (esas2r_proc_major <= 0) {\n\t\tesas2r_proc_host = sh;\n\n\t\tesas2r_proc_major = register_chrdev(0, ESAS2R_DRVR_NAME,\n\t\t\t\t\t\t    &esas2r_proc_fops);\n\n\t\tesas2r_log_dev(ESAS2R_LOG_DEBG, &(sh->shost_gendev),\n\t\t\t       \"register_chrdev (major %d)\",\n\t\t\t       esas2r_proc_major);\n\n\t\tif (esas2r_proc_major > 0) {\n\t\t\tstruct proc_dir_entry *proc_dir;\n\t\t\tstruct proc_dir_entry *pde = NULL;\n\n\t\t\tproc_dir = scsi_template_proc_dir(sh->hostt);\n\t\t\tif (proc_dir)\n\t\t\t\tpde = proc_create(ATTONODE_NAME, 0, proc_dir,\n\t\t\t\t\t\t  &esas2r_proc_ops);\n\n\t\t\tif (!pde) {\n\t\t\t\tesas2r_log_dev(ESAS2R_LOG_WARN,\n\t\t\t\t\t       &(sh->shost_gendev),\n\t\t\t\t\t       \"failed to create_proc_entry\");\n\t\t\t\tesas2r_proc_major = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tsprintf(esas2r_info_str,\n\t\tESAS2R_LONGNAME \" (bus 0x%02X, device 0x%02X, IRQ 0x%02X)\"\n\t\t\" driver version: \"ESAS2R_VERSION_STR \"  firmware version: \"\n\t\t\"%s\\n\",\n\t\ta->pcid->bus->number, a->pcid->devfn, a->pcid->irq,\n\t\ta->fw_rev[0] ? a->fw_rev : \"(none)\");\n\n\treturn esas2r_info_str;\n}\n\n \nstatic u32 get_physaddr_from_sgc(struct esas2r_sg_context *sgc, u64 *addr)\n{\n\tu32 len;\n\n\tif (likely(sgc->cur_offset == sgc->exp_offset)) {\n\t\t \n\n\t\tif (sgc->sgel_count < sgc->num_sgel) {\n\t\t\t \n\t\t\tif (sgc->exp_offset > (u8 *)0) {\n\t\t\t\t \n\t\t\t\tsgc->cur_sgel = sg_next(sgc->cur_sgel);\n\t\t\t\t++(sgc->sgel_count);\n\t\t\t}\n\n\n\t\t\tlen = sg_dma_len(sgc->cur_sgel);\n\t\t\t(*addr) = sg_dma_address(sgc->cur_sgel);\n\n\t\t\t \n\t\t\tsgc->exp_offset += len;\n\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\n\t} else if (sgc->cur_offset < sgc->exp_offset) {\n\t\t \n\n\t\tlen = sg_dma_len(sgc->cur_sgel);\n\t\t(*addr) = sg_dma_address(sgc->cur_sgel);\n\n\t\tsgc->exp_offset -= len;\n\n\t\t \n\t\t*addr = *addr +\n\t\t\t(sgc->cur_offset - sgc->exp_offset);\n\n\t\tsgc->exp_offset += len;\n\n\t\t \n\t\tlen = lower_32_bits(\n\t\t\tsgc->exp_offset - sgc->cur_offset);\n\t} else {    \n\t\t    \n\t\tlen = 0;\n\t}\n\n\treturn len;\n}\n\nint esas2r_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)\n{\n\tstruct esas2r_adapter *a =\n\t\t(struct esas2r_adapter *)cmd->device->host->hostdata;\n\tstruct esas2r_request *rq;\n\tstruct esas2r_sg_context sgc;\n\tunsigned bufflen;\n\n\t \n\tcmd->result = DID_OK << 16;\n\n\tif (unlikely(test_bit(AF_DEGRADED_MODE, &a->flags))) {\n\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\tscsi_done(cmd);\n\t\treturn 0;\n\t}\n\n\trq = esas2r_alloc_request(a);\n\tif (unlikely(rq == NULL)) {\n\t\tesas2r_debug(\"esas2r_alloc_request failed\");\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\trq->cmd = cmd;\n\tbufflen = scsi_bufflen(cmd);\n\n\tif (likely(bufflen != 0)) {\n\t\tif (cmd->sc_data_direction == DMA_TO_DEVICE)\n\t\t\trq->vrq->scsi.flags |= cpu_to_le32(FCP_CMND_WRD);\n\t\telse if (cmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\t\trq->vrq->scsi.flags |= cpu_to_le32(FCP_CMND_RDD);\n\t}\n\n\tmemcpy(rq->vrq->scsi.cdb, cmd->cmnd, cmd->cmd_len);\n\trq->vrq->scsi.length = cpu_to_le32(bufflen);\n\trq->target_id = cmd->device->id;\n\trq->vrq->scsi.flags |= cpu_to_le32(cmd->device->lun);\n\trq->sense_buf = cmd->sense_buffer;\n\trq->sense_len = SCSI_SENSE_BUFFERSIZE;\n\n\tesas2r_sgc_init(&sgc, a, rq, NULL);\n\n\tsgc.length = bufflen;\n\tsgc.cur_offset = NULL;\n\n\tsgc.cur_sgel = scsi_sglist(cmd);\n\tsgc.exp_offset = NULL;\n\tsgc.num_sgel = scsi_dma_map(cmd);\n\tsgc.sgel_count = 0;\n\n\tif (unlikely(sgc.num_sgel < 0)) {\n\t\tesas2r_free_request(a, rq);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tsgc.get_phys_addr = (PGETPHYSADDR)get_physaddr_from_sgc;\n\n\tif (unlikely(!esas2r_build_sg_list(a, rq, &sgc))) {\n\t\tscsi_dma_unmap(cmd);\n\t\tesas2r_free_request(a, rq);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tesas2r_debug(\"start request %p to %d:%d\\n\", rq, (int)cmd->device->id,\n\t\t     (int)cmd->device->lun);\n\n\tesas2r_start_request(a, rq);\n\n\treturn 0;\n}\n\nstatic void complete_task_management_request(struct esas2r_adapter *a,\n\t\t\t\t\t     struct esas2r_request *rq)\n{\n\t(*rq->task_management_status_ptr) = rq->req_stat;\n\tesas2r_free_request(a, rq);\n}\n\n \nstatic int esas2r_check_active_queue(struct esas2r_adapter *a,\n\t\t\t\t     struct esas2r_request **abort_request,\n\t\t\t\t     struct scsi_cmnd *cmd,\n\t\t\t\t     struct list_head *queue)\n{\n\tbool found = false;\n\tstruct esas2r_request *ar = *abort_request;\n\tstruct esas2r_request *rq;\n\tstruct list_head *element, *next;\n\n\tlist_for_each_safe(element, next, queue) {\n\n\t\trq = list_entry(element, struct esas2r_request, req_list);\n\n\t\tif (rq->cmd == cmd) {\n\n\t\t\t \n\t\t\tif (queue == &a->active_list) {\n\t\t\t\t \n\t\t\t\tar = esas2r_alloc_request(a);\n\t\t\t\tif (ar == NULL) {\n\t\t\t\t\tesas2r_log_dev(ESAS2R_LOG_WARN,\n\t\t\t\t\t\t       &(a->host->shost_gendev),\n\t\t\t\t\t\t       \"unable to allocate an abort request for cmd %p\",\n\t\t\t\t\t\t       cmd);\n\t\t\t\t\treturn 0;  \n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tar->sense_len = 0;\n\t\t\t\tar->vrq->scsi.length = 0;\n\t\t\t\tar->target_id = rq->target_id;\n\t\t\t\tar->vrq->scsi.flags |= cpu_to_le32(\n\t\t\t\t\t(u8)le32_to_cpu(rq->vrq->scsi.flags));\n\n\t\t\t\tmemset(ar->vrq->scsi.cdb, 0,\n\t\t\t\t       sizeof(ar->vrq->scsi.cdb));\n\n\t\t\t\tar->vrq->scsi.flags |= cpu_to_le32(\n\t\t\t\t\tFCP_CMND_TRM);\n\t\t\t\tar->vrq->scsi.u.abort_handle =\n\t\t\t\t\trq->vrq->scsi.handle;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tlist_del_init(&rq->req_list);\n\t\t\t\tesas2r_free_request(a, rq);\n\t\t\t}\n\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (!found)\n\t\treturn 1;        \n\n\treturn 2;                \n\n\n}\n\nint esas2r_eh_abort(struct scsi_cmnd *cmd)\n{\n\tstruct esas2r_adapter *a =\n\t\t(struct esas2r_adapter *)cmd->device->host->hostdata;\n\tstruct esas2r_request *abort_request = NULL;\n\tunsigned long flags;\n\tstruct list_head *queue;\n\tint result;\n\n\tesas2r_log(ESAS2R_LOG_INFO, \"eh_abort (%p)\", cmd);\n\n\tif (test_bit(AF_DEGRADED_MODE, &a->flags)) {\n\t\tcmd->result = DID_ABORT << 16;\n\n\t\tscsi_set_resid(cmd, 0);\n\n\t\tscsi_done(cmd);\n\n\t\treturn SUCCESS;\n\t}\n\n\tspin_lock_irqsave(&a->queue_lock, flags);\n\n\t \n\n\tqueue = &a->defer_list;\n\ncheck_active_queue:\n\n\tresult = esas2r_check_active_queue(a, &abort_request, cmd, queue);\n\n\tif (!result) {\n\t\tspin_unlock_irqrestore(&a->queue_lock, flags);\n\t\treturn FAILED;\n\t} else if (result == 2 && (queue == &a->defer_list)) {\n\t\tqueue = &a->active_list;\n\t\tgoto check_active_queue;\n\t}\n\n\tspin_unlock_irqrestore(&a->queue_lock, flags);\n\n\tif (abort_request) {\n\t\tu8 task_management_status = RS_PENDING;\n\n\t\t \n\n\t\tabort_request->comp_cb = complete_task_management_request;\n\t\tabort_request->task_management_status_ptr =\n\t\t\t&task_management_status;\n\n\t\tesas2r_start_request(a, abort_request);\n\n\t\tif (atomic_read(&a->disable_cnt) == 0)\n\t\t\tesas2r_do_deferred_processes(a);\n\n\t\twhile (task_management_status == RS_PENDING)\n\t\t\tmsleep(10);\n\n\t\t \n\n\t\treturn SUCCESS;\n\t}\n\n\t \n\n\tcmd->result = DID_ABORT << 16;\n\n\tscsi_set_resid(cmd, 0);\n\n\tscsi_done(cmd);\n\n\treturn SUCCESS;\n}\n\nstatic int esas2r_host_bus_reset(struct scsi_cmnd *cmd, bool host_reset)\n{\n\tstruct esas2r_adapter *a =\n\t\t(struct esas2r_adapter *)cmd->device->host->hostdata;\n\n\tif (test_bit(AF_DEGRADED_MODE, &a->flags))\n\t\treturn FAILED;\n\n\tif (host_reset)\n\t\tesas2r_reset_adapter(a);\n\telse\n\t\tesas2r_reset_bus(a);\n\n\t \n\n\twhile (test_bit(AF_OS_RESET, &a->flags)) {\n\t\tmsleep(10);\n\n\t\tif (test_bit(AF_DEGRADED_MODE, &a->flags))\n\t\t\treturn FAILED;\n\t}\n\n\tif (test_bit(AF_DEGRADED_MODE, &a->flags))\n\t\treturn FAILED;\n\n\treturn SUCCESS;\n}\n\nint esas2r_host_reset(struct scsi_cmnd *cmd)\n{\n\tesas2r_log(ESAS2R_LOG_INFO, \"host_reset (%p)\", cmd);\n\n\treturn esas2r_host_bus_reset(cmd, true);\n}\n\nint esas2r_bus_reset(struct scsi_cmnd *cmd)\n{\n\tesas2r_log(ESAS2R_LOG_INFO, \"bus_reset (%p)\", cmd);\n\n\treturn esas2r_host_bus_reset(cmd, false);\n}\n\nstatic int esas2r_dev_targ_reset(struct scsi_cmnd *cmd, bool target_reset)\n{\n\tstruct esas2r_adapter *a =\n\t\t(struct esas2r_adapter *)cmd->device->host->hostdata;\n\tstruct esas2r_request *rq;\n\tu8 task_management_status = RS_PENDING;\n\tbool completed;\n\n\tif (test_bit(AF_DEGRADED_MODE, &a->flags))\n\t\treturn FAILED;\n\nretry:\n\trq = esas2r_alloc_request(a);\n\tif (rq == NULL) {\n\t\tif (target_reset) {\n\t\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t\t   \"unable to allocate a request for a \"\n\t\t\t\t   \"target reset (%d)!\",\n\t\t\t\t   cmd->device->id);\n\t\t} else {\n\t\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t\t   \"unable to allocate a request for a \"\n\t\t\t\t   \"device reset (%d:%llu)!\",\n\t\t\t\t   cmd->device->id,\n\t\t\t\t   cmd->device->lun);\n\t\t}\n\n\n\t\treturn FAILED;\n\t}\n\n\trq->target_id = cmd->device->id;\n\trq->vrq->scsi.flags |= cpu_to_le32(cmd->device->lun);\n\trq->req_stat = RS_PENDING;\n\n\trq->comp_cb = complete_task_management_request;\n\trq->task_management_status_ptr = &task_management_status;\n\n\tif (target_reset) {\n\t\tesas2r_debug(\"issuing target reset (%p) to id %d\", rq,\n\t\t\t     cmd->device->id);\n\t\tcompleted = esas2r_send_task_mgmt(a, rq, 0x20);\n\t} else {\n\t\tesas2r_debug(\"issuing device reset (%p) to id %d lun %d\", rq,\n\t\t\t     cmd->device->id, cmd->device->lun);\n\t\tcompleted = esas2r_send_task_mgmt(a, rq, 0x10);\n\t}\n\n\tif (completed) {\n\t\t \n\n\t\tesas2r_free_request(a, rq);\n\t} else {\n\t\t \n\t\twhile (task_management_status == RS_PENDING)\n\t\t\tmsleep(10);\n\t}\n\n\tif (test_bit(AF_DEGRADED_MODE, &a->flags))\n\t\treturn FAILED;\n\n\tif (task_management_status == RS_BUSY) {\n\t\t \n\t\tmsleep(100);\n\t\tgoto retry;\n\t}\n\n\treturn SUCCESS;\n}\n\nint esas2r_device_reset(struct scsi_cmnd *cmd)\n{\n\tesas2r_log(ESAS2R_LOG_INFO, \"device_reset (%p)\", cmd);\n\n\treturn esas2r_dev_targ_reset(cmd, false);\n\n}\n\nint esas2r_target_reset(struct scsi_cmnd *cmd)\n{\n\tesas2r_log(ESAS2R_LOG_INFO, \"target_reset (%p)\", cmd);\n\n\treturn esas2r_dev_targ_reset(cmd, true);\n}\n\nvoid esas2r_log_request_failure(struct esas2r_adapter *a,\n\t\t\t\tstruct esas2r_request *rq)\n{\n\tu8 reqstatus = rq->req_stat;\n\n\tif (reqstatus == RS_SUCCESS)\n\t\treturn;\n\n\tif (rq->vrq->scsi.function == VDA_FUNC_SCSI) {\n\t\tif (reqstatus == RS_SCSI_ERROR) {\n\t\t\tif (rq->func_rsp.scsi_rsp.sense_len >= 13) {\n\t\t\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t\t\t   \"request failure - SCSI error %x ASC:%x ASCQ:%x CDB:%x\",\n\t\t\t\t\t   rq->sense_buf[2], rq->sense_buf[12],\n\t\t\t\t\t   rq->sense_buf[13],\n\t\t\t\t\t   rq->vrq->scsi.cdb[0]);\n\t\t\t} else {\n\t\t\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t\t\t   \"request failure - SCSI error CDB:%x\\n\",\n\t\t\t\t\t   rq->vrq->scsi.cdb[0]);\n\t\t\t}\n\t\t} else if ((rq->vrq->scsi.cdb[0] != INQUIRY\n\t\t\t    && rq->vrq->scsi.cdb[0] != REPORT_LUNS)\n\t\t\t   || (reqstatus != RS_SEL\n\t\t\t       && reqstatus != RS_SEL2)) {\n\t\t\tif ((reqstatus == RS_UNDERRUN) &&\n\t\t\t    (rq->vrq->scsi.cdb[0] == INQUIRY)) {\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t\t\t   \"request failure - cdb:%x reqstatus:%d target:%d\",\n\t\t\t\t\t   rq->vrq->scsi.cdb[0], reqstatus,\n\t\t\t\t\t   rq->target_id);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid esas2r_wait_request(struct esas2r_adapter *a, struct esas2r_request *rq)\n{\n\tu32 starttime;\n\tu32 timeout;\n\n\tstarttime = jiffies_to_msecs(jiffies);\n\ttimeout = rq->timeout ? rq->timeout : 5000;\n\n\twhile (true) {\n\t\tesas2r_polled_interrupt(a);\n\n\t\tif (rq->req_stat != RS_STARTED)\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(100));\n\n\t\tif ((jiffies_to_msecs(jiffies) - starttime) > timeout) {\n\t\t\tesas2r_hdebug(\"request TMO\");\n\t\t\tesas2r_bugon();\n\n\t\t\trq->req_stat = RS_TIMEOUT;\n\n\t\t\tesas2r_local_reset_adapter(a);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nu32 esas2r_map_data_window(struct esas2r_adapter *a, u32 addr_lo)\n{\n\tu32 offset = addr_lo & (MW_DATA_WINDOW_SIZE - 1);\n\tu32 base = addr_lo & -(signed int)MW_DATA_WINDOW_SIZE;\n\n\tif (a->window_base != base) {\n\t\tesas2r_write_register_dword(a, MVR_PCI_WIN1_REMAP,\n\t\t\t\t\t    base | MVRPW1R_ENABLE);\n\t\tesas2r_flush_register_dword(a, MVR_PCI_WIN1_REMAP);\n\t\ta->window_base = base;\n\t}\n\n\treturn offset;\n}\n\n \nbool esas2r_read_mem_block(struct esas2r_adapter *a,\n\t\t\t   void *to,\n\t\t\t   u32 from,\n\t\t\t   u32 size)\n{\n\tu8 *end = (u8 *)to;\n\n\twhile (size) {\n\t\tu32 len;\n\t\tu32 offset;\n\t\tu32 iatvr;\n\n\t\tiatvr = (from & -(signed int)MW_DATA_WINDOW_SIZE);\n\n\t\tesas2r_map_data_window(a, iatvr);\n\n\t\toffset = from & (MW_DATA_WINDOW_SIZE - 1);\n\t\tlen = size;\n\n\t\tif (len > MW_DATA_WINDOW_SIZE - offset)\n\t\t\tlen = MW_DATA_WINDOW_SIZE - offset;\n\n\t\tfrom += len;\n\t\tsize -= len;\n\n\t\twhile (len--) {\n\t\t\t*end++ = esas2r_read_data_byte(a, offset);\n\t\t\toffset++;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid esas2r_nuxi_mgt_data(u8 function, void *data)\n{\n\tstruct atto_vda_grp_info *g;\n\tstruct atto_vda_devinfo *d;\n\tstruct atto_vdapart_info *p;\n\tstruct atto_vda_dh_info *h;\n\tstruct atto_vda_metrics_info *m;\n\tstruct atto_vda_schedule_info *s;\n\tstruct atto_vda_buzzer_info *b;\n\tu8 i;\n\n\tswitch (function) {\n\tcase VDAMGT_BUZZER_INFO:\n\tcase VDAMGT_BUZZER_SET:\n\n\t\tb = (struct atto_vda_buzzer_info *)data;\n\n\t\tb->duration = le32_to_cpu(b->duration);\n\t\tbreak;\n\n\tcase VDAMGT_SCHEDULE_INFO:\n\tcase VDAMGT_SCHEDULE_EVENT:\n\n\t\ts = (struct atto_vda_schedule_info *)data;\n\n\t\ts->id = le32_to_cpu(s->id);\n\n\t\tbreak;\n\n\tcase VDAMGT_DEV_INFO:\n\tcase VDAMGT_DEV_CLEAN:\n\tcase VDAMGT_DEV_PT_INFO:\n\tcase VDAMGT_DEV_FEATURES:\n\tcase VDAMGT_DEV_PT_FEATURES:\n\tcase VDAMGT_DEV_OPERATION:\n\n\t\td = (struct atto_vda_devinfo *)data;\n\n\t\td->capacity = le64_to_cpu(d->capacity);\n\t\td->block_size = le32_to_cpu(d->block_size);\n\t\td->ses_dev_index = le16_to_cpu(d->ses_dev_index);\n\t\td->target_id = le16_to_cpu(d->target_id);\n\t\td->lun = le16_to_cpu(d->lun);\n\t\td->features = le16_to_cpu(d->features);\n\t\tbreak;\n\n\tcase VDAMGT_GRP_INFO:\n\tcase VDAMGT_GRP_CREATE:\n\tcase VDAMGT_GRP_DELETE:\n\tcase VDAMGT_ADD_STORAGE:\n\tcase VDAMGT_MEMBER_ADD:\n\tcase VDAMGT_GRP_COMMIT:\n\tcase VDAMGT_GRP_REBUILD:\n\tcase VDAMGT_GRP_COMMIT_INIT:\n\tcase VDAMGT_QUICK_RAID:\n\tcase VDAMGT_GRP_FEATURES:\n\tcase VDAMGT_GRP_COMMIT_INIT_AUTOMAP:\n\tcase VDAMGT_QUICK_RAID_INIT_AUTOMAP:\n\tcase VDAMGT_SPARE_LIST:\n\tcase VDAMGT_SPARE_ADD:\n\tcase VDAMGT_SPARE_REMOVE:\n\tcase VDAMGT_LOCAL_SPARE_ADD:\n\tcase VDAMGT_GRP_OPERATION:\n\n\t\tg = (struct atto_vda_grp_info *)data;\n\n\t\tg->capacity = le64_to_cpu(g->capacity);\n\t\tg->block_size = le32_to_cpu(g->block_size);\n\t\tg->interleave = le32_to_cpu(g->interleave);\n\t\tg->features = le16_to_cpu(g->features);\n\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tg->members[i] = le16_to_cpu(g->members[i]);\n\n\t\tbreak;\n\n\tcase VDAMGT_PART_INFO:\n\tcase VDAMGT_PART_MAP:\n\tcase VDAMGT_PART_UNMAP:\n\tcase VDAMGT_PART_AUTOMAP:\n\tcase VDAMGT_PART_SPLIT:\n\tcase VDAMGT_PART_MERGE:\n\n\t\tp = (struct atto_vdapart_info *)data;\n\n\t\tp->part_size = le64_to_cpu(p->part_size);\n\t\tp->start_lba = le32_to_cpu(p->start_lba);\n\t\tp->block_size = le32_to_cpu(p->block_size);\n\t\tp->target_id = le16_to_cpu(p->target_id);\n\t\tbreak;\n\n\tcase VDAMGT_DEV_HEALTH_REQ:\n\n\t\th = (struct atto_vda_dh_info *)data;\n\n\t\th->med_defect_cnt = le32_to_cpu(h->med_defect_cnt);\n\t\th->info_exc_cnt = le32_to_cpu(h->info_exc_cnt);\n\t\tbreak;\n\n\tcase VDAMGT_DEV_METRICS:\n\n\t\tm = (struct atto_vda_metrics_info *)data;\n\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tm->dev_indexes[i] = le16_to_cpu(m->dev_indexes[i]);\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid esas2r_nuxi_cfg_data(u8 function, void *data)\n{\n\tstruct atto_vda_cfg_init *ci;\n\n\tswitch (function) {\n\tcase VDA_CFG_INIT:\n\tcase VDA_CFG_GET_INIT:\n\tcase VDA_CFG_GET_INIT2:\n\n\t\tci = (struct atto_vda_cfg_init *)data;\n\n\t\tci->date_time.year = le16_to_cpu(ci->date_time.year);\n\t\tci->sgl_page_size = le32_to_cpu(ci->sgl_page_size);\n\t\tci->vda_version = le32_to_cpu(ci->vda_version);\n\t\tci->epoch_time = le32_to_cpu(ci->epoch_time);\n\t\tci->ioctl_tunnel = le32_to_cpu(ci->ioctl_tunnel);\n\t\tci->num_targets_backend = le32_to_cpu(ci->num_targets_backend);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid esas2r_nuxi_ae_data(union atto_vda_ae *ae)\n{\n\tstruct atto_vda_ae_raid *r = &ae->raid;\n\tstruct atto_vda_ae_lu *l = &ae->lu;\n\n\tswitch (ae->hdr.bytype) {\n\tcase VDAAE_HDR_TYPE_RAID:\n\n\t\tr->dwflags = le32_to_cpu(r->dwflags);\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_LU:\n\n\t\tl->dwevent = le32_to_cpu(l->dwevent);\n\t\tl->wphys_target_id = le16_to_cpu(l->wphys_target_id);\n\t\tl->id.tgtlun.wtarget_id = le16_to_cpu(l->id.tgtlun.wtarget_id);\n\n\t\tif (l->hdr.bylength >= offsetof(struct atto_vda_ae_lu, id)\n\t\t    + sizeof(struct atto_vda_ae_lu_tgt_lun_raid)) {\n\t\t\tl->id.tgtlun_raid.dwinterleave\n\t\t\t\t= le32_to_cpu(l->id.tgtlun_raid.dwinterleave);\n\t\t\tl->id.tgtlun_raid.dwblock_size\n\t\t\t\t= le32_to_cpu(l->id.tgtlun_raid.dwblock_size);\n\t\t}\n\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_DISK:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid esas2r_free_request(struct esas2r_adapter *a, struct esas2r_request *rq)\n{\n\tunsigned long flags;\n\n\tesas2r_rq_destroy_request(rq, a);\n\tspin_lock_irqsave(&a->request_lock, flags);\n\tlist_add(&rq->comp_list, &a->avail_request);\n\tspin_unlock_irqrestore(&a->request_lock, flags);\n}\n\nstruct esas2r_request *esas2r_alloc_request(struct esas2r_adapter *a)\n{\n\tstruct esas2r_request *rq;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&a->request_lock, flags);\n\n\tif (unlikely(list_empty(&a->avail_request))) {\n\t\tspin_unlock_irqrestore(&a->request_lock, flags);\n\t\treturn NULL;\n\t}\n\n\trq = list_first_entry(&a->avail_request, struct esas2r_request,\n\t\t\t      comp_list);\n\tlist_del(&rq->comp_list);\n\tspin_unlock_irqrestore(&a->request_lock, flags);\n\tesas2r_rq_init_request(rq, a);\n\n\treturn rq;\n\n}\n\nvoid esas2r_complete_request_cb(struct esas2r_adapter *a,\n\t\t\t\tstruct esas2r_request *rq)\n{\n\tesas2r_debug(\"completing request %p\\n\", rq);\n\n\tscsi_dma_unmap(rq->cmd);\n\n\tif (unlikely(rq->req_stat != RS_SUCCESS)) {\n\t\tesas2r_debug(\"[%x STATUS %x:%x (%x)]\", rq->target_id,\n\t\t\t     rq->req_stat,\n\t\t\t     rq->func_rsp.scsi_rsp.scsi_stat,\n\t\t\t     rq->cmd);\n\n\t\trq->cmd->result =\n\t\t\t((esas2r_req_status_to_error(rq->req_stat) << 16)\n\t\t\t | rq->func_rsp.scsi_rsp.scsi_stat);\n\n\t\tif (rq->req_stat == RS_UNDERRUN)\n\t\t\tscsi_set_resid(rq->cmd,\n\t\t\t\t       le32_to_cpu(rq->func_rsp.scsi_rsp.\n\t\t\t\t\t\t   residual_length));\n\t\telse\n\t\t\tscsi_set_resid(rq->cmd, 0);\n\t}\n\n\tscsi_done(rq->cmd);\n\n\tesas2r_free_request(a, rq);\n}\n\n \nvoid esas2r_adapter_tasklet(unsigned long context)\n{\n\tstruct esas2r_adapter *a = (struct esas2r_adapter *)context;\n\n\tif (unlikely(test_bit(AF2_TIMER_TICK, &a->flags2))) {\n\t\tclear_bit(AF2_TIMER_TICK, &a->flags2);\n\t\tesas2r_timer_tick(a);\n\t}\n\n\tif (likely(test_bit(AF2_INT_PENDING, &a->flags2))) {\n\t\tclear_bit(AF2_INT_PENDING, &a->flags2);\n\t\tesas2r_adapter_interrupt(a);\n\t}\n\n\tif (esas2r_is_tasklet_pending(a))\n\t\tesas2r_do_tasklet_tasks(a);\n\n\tif (esas2r_is_tasklet_pending(a)\n\t    || (test_bit(AF2_INT_PENDING, &a->flags2))\n\t    || (test_bit(AF2_TIMER_TICK, &a->flags2))) {\n\t\tclear_bit(AF_TASKLET_SCHEDULED, &a->flags);\n\t\tesas2r_schedule_tasklet(a);\n\t} else {\n\t\tclear_bit(AF_TASKLET_SCHEDULED, &a->flags);\n\t}\n}\n\nstatic void esas2r_timer_callback(struct timer_list *t);\n\nvoid esas2r_kickoff_timer(struct esas2r_adapter *a)\n{\n\ttimer_setup(&a->timer, esas2r_timer_callback, 0);\n\n\ta->timer.expires = jiffies +\n\t\t\t   msecs_to_jiffies(100);\n\n\tadd_timer(&a->timer);\n}\n\nstatic void esas2r_timer_callback(struct timer_list *t)\n{\n\tstruct esas2r_adapter *a = from_timer(a, t, timer);\n\n\tset_bit(AF2_TIMER_TICK, &a->flags2);\n\n\tesas2r_schedule_tasklet(a);\n\n\tesas2r_kickoff_timer(a);\n}\n\n \n\nstatic void\nesas2r_free_fw_event(struct esas2r_fw_event_work *fw_event)\n{\n\tunsigned long flags;\n\tstruct esas2r_adapter *a = fw_event->a;\n\n\tspin_lock_irqsave(&a->fw_event_lock, flags);\n\tlist_del(&fw_event->list);\n\tkfree(fw_event);\n\tspin_unlock_irqrestore(&a->fw_event_lock, flags);\n}\n\nvoid\nesas2r_fw_event_off(struct esas2r_adapter *a)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&a->fw_event_lock, flags);\n\ta->fw_events_off = 1;\n\tspin_unlock_irqrestore(&a->fw_event_lock, flags);\n}\n\nvoid\nesas2r_fw_event_on(struct esas2r_adapter *a)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&a->fw_event_lock, flags);\n\ta->fw_events_off = 0;\n\tspin_unlock_irqrestore(&a->fw_event_lock, flags);\n}\n\nstatic void esas2r_add_device(struct esas2r_adapter *a, u16 target_id)\n{\n\tint ret;\n\tstruct scsi_device *scsi_dev;\n\n\tscsi_dev = scsi_device_lookup(a->host, 0, target_id, 0);\n\n\tif (scsi_dev) {\n\t\tesas2r_log_dev(\n\t\t\tESAS2R_LOG_WARN,\n\t\t\t&(scsi_dev->\n\t\t\t  sdev_gendev),\n\t\t\t\"scsi device already exists at id %d\", target_id);\n\n\t\tscsi_device_put(scsi_dev);\n\t} else {\n\t\tesas2r_log_dev(\n\t\t\tESAS2R_LOG_INFO,\n\t\t\t&(a->host->\n\t\t\t  shost_gendev),\n\t\t\t\"scsi_add_device() called for 0:%d:0\",\n\t\t\ttarget_id);\n\n\t\tret = scsi_add_device(a->host, 0, target_id, 0);\n\t\tif (ret) {\n\t\t\tesas2r_log_dev(\n\t\t\t\tESAS2R_LOG_CRIT,\n\t\t\t\t&(a->host->\n\t\t\t\t  shost_gendev),\n\t\t\t\t\"scsi_add_device failed with %d for id %d\",\n\t\t\t\tret, target_id);\n\t\t}\n\t}\n}\n\nstatic void esas2r_remove_device(struct esas2r_adapter *a, u16 target_id)\n{\n\tstruct scsi_device *scsi_dev;\n\n\tscsi_dev = scsi_device_lookup(a->host, 0, target_id, 0);\n\n\tif (scsi_dev) {\n\t\tscsi_device_set_state(scsi_dev, SDEV_OFFLINE);\n\n\t\tesas2r_log_dev(\n\t\t\tESAS2R_LOG_INFO,\n\t\t\t&(scsi_dev->\n\t\t\t  sdev_gendev),\n\t\t\t\"scsi_remove_device() called for 0:%d:0\",\n\t\t\ttarget_id);\n\n\t\tscsi_remove_device(scsi_dev);\n\n\t\tesas2r_log_dev(\n\t\t\tESAS2R_LOG_INFO,\n\t\t\t&(scsi_dev->\n\t\t\t  sdev_gendev),\n\t\t\t\"scsi_device_put() called\");\n\n\t\tscsi_device_put(scsi_dev);\n\t} else {\n\t\tesas2r_log_dev(\n\t\t\tESAS2R_LOG_WARN,\n\t\t\t&(a->host->shost_gendev),\n\t\t\t\"no target found at id %d\",\n\t\t\ttarget_id);\n\t}\n}\n\n \nstatic void esas2r_send_ae_event(struct esas2r_fw_event_work *fw_event)\n{\n\tstruct esas2r_vda_ae *ae = (struct esas2r_vda_ae *)fw_event->data;\n\tchar *type;\n\n\tswitch (ae->vda_ae.hdr.bytype) {\n\tcase VDAAE_HDR_TYPE_RAID:\n\t\ttype = \"RAID group state change\";\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_LU:\n\t\ttype = \"Mapped destination LU change\";\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_DISK:\n\t\ttype = \"Physical disk inventory change\";\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_RESET:\n\t\ttype = \"Firmware reset\";\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_LOG_INFO:\n\t\ttype = \"Event Log message (INFO level)\";\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_LOG_WARN:\n\t\ttype = \"Event Log message (WARN level)\";\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_LOG_CRIT:\n\t\ttype = \"Event Log message (CRIT level)\";\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_LOG_FAIL:\n\t\ttype = \"Event Log message (FAIL level)\";\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_NVC:\n\t\ttype = \"NVCache change\";\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_TLG_INFO:\n\t\ttype = \"Time stamped log message (INFO level)\";\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_TLG_WARN:\n\t\ttype = \"Time stamped log message (WARN level)\";\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_TLG_CRIT:\n\t\ttype = \"Time stamped log message (CRIT level)\";\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_PWRMGT:\n\t\ttype = \"Power management\";\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_MUTE:\n\t\ttype = \"Mute button pressed\";\n\t\tbreak;\n\n\tcase VDAAE_HDR_TYPE_DEV:\n\t\ttype = \"Device attribute change\";\n\t\tbreak;\n\n\tdefault:\n\t\ttype = \"Unknown\";\n\t\tbreak;\n\t}\n\n\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t   \"An async event of type \\\"%s\\\" was received from the firmware.  The event contents are:\",\n\t\t   type);\n\tesas2r_log_hexdump(ESAS2R_LOG_WARN, &ae->vda_ae,\n\t\t\t   ae->vda_ae.hdr.bylength);\n\n}\n\nstatic void\nesas2r_firmware_event_work(struct work_struct *work)\n{\n\tstruct esas2r_fw_event_work *fw_event =\n\t\tcontainer_of(work, struct esas2r_fw_event_work, work.work);\n\n\tstruct esas2r_adapter *a = fw_event->a;\n\n\tu16 target_id = *(u16 *)&fw_event->data[0];\n\n\tif (a->fw_events_off)\n\t\tgoto done;\n\n\tswitch (fw_event->type) {\n\tcase fw_event_null:\n\t\tbreak;  \n\n\tcase fw_event_lun_change:\n\t\tesas2r_remove_device(a, target_id);\n\t\tesas2r_add_device(a, target_id);\n\t\tbreak;\n\n\tcase fw_event_present:\n\t\tesas2r_add_device(a, target_id);\n\t\tbreak;\n\n\tcase fw_event_not_present:\n\t\tesas2r_remove_device(a, target_id);\n\t\tbreak;\n\n\tcase fw_event_vda_ae:\n\t\tesas2r_send_ae_event(fw_event);\n\t\tbreak;\n\t}\n\ndone:\n\tesas2r_free_fw_event(fw_event);\n}\n\nvoid esas2r_queue_fw_event(struct esas2r_adapter *a,\n\t\t\t   enum fw_event_type type,\n\t\t\t   void *data,\n\t\t\t   int data_sz)\n{\n\tstruct esas2r_fw_event_work *fw_event;\n\tunsigned long flags;\n\n\tfw_event = kzalloc(sizeof(struct esas2r_fw_event_work), GFP_ATOMIC);\n\tif (!fw_event) {\n\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t   \"esas2r_queue_fw_event failed to alloc\");\n\t\treturn;\n\t}\n\n\tif (type == fw_event_vda_ae) {\n\t\tstruct esas2r_vda_ae *ae =\n\t\t\t(struct esas2r_vda_ae *)fw_event->data;\n\n\t\tae->signature = ESAS2R_VDA_EVENT_SIG;\n\t\tae->bus_number = a->pcid->bus->number;\n\t\tae->devfn = a->pcid->devfn;\n\t\tmemcpy(&ae->vda_ae, data, sizeof(ae->vda_ae));\n\t} else {\n\t\tmemcpy(fw_event->data, data, data_sz);\n\t}\n\n\tfw_event->type = type;\n\tfw_event->a = a;\n\n\tspin_lock_irqsave(&a->fw_event_lock, flags);\n\tlist_add_tail(&fw_event->list, &a->fw_event_list);\n\tINIT_DELAYED_WORK(&fw_event->work, esas2r_firmware_event_work);\n\tqueue_delayed_work_on(\n\t\tsmp_processor_id(), a->fw_event_q, &fw_event->work,\n\t\tmsecs_to_jiffies(1));\n\tspin_unlock_irqrestore(&a->fw_event_lock, flags);\n}\n\nvoid esas2r_target_state_changed(struct esas2r_adapter *a, u16 targ_id,\n\t\t\t\t u8 state)\n{\n\tif (state == TS_LUN_CHANGE)\n\t\tesas2r_queue_fw_event(a, fw_event_lun_change, &targ_id,\n\t\t\t\t      sizeof(targ_id));\n\telse if (state == TS_PRESENT)\n\t\tesas2r_queue_fw_event(a, fw_event_present, &targ_id,\n\t\t\t\t      sizeof(targ_id));\n\telse if (state == TS_NOT_PRESENT)\n\t\tesas2r_queue_fw_event(a, fw_event_not_present, &targ_id,\n\t\t\t\t      sizeof(targ_id));\n}\n\n \nint esas2r_req_status_to_error(u8 req_stat)\n{\n\tswitch (req_stat) {\n\tcase RS_OVERRUN:\n\tcase RS_UNDERRUN:\n\tcase RS_SUCCESS:\n\t \n\tcase RS_SCSI_ERROR:\n\t\treturn DID_OK;\n\n\tcase RS_SEL:\n\tcase RS_SEL2:\n\t\treturn DID_NO_CONNECT;\n\n\tcase RS_RESET:\n\t\treturn DID_RESET;\n\n\tcase RS_ABORTED:\n\t\treturn DID_ABORT;\n\n\tcase RS_BUSY:\n\t\treturn DID_BUS_BUSY;\n\t}\n\n\t \n\n\treturn DID_ERROR;\n}\n\nmodule_init(esas2r_init);\nmodule_exit(esas2r_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}