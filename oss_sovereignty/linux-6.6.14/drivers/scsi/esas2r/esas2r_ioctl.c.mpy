{
  "module_name": "esas2r_ioctl.c",
  "hash_id": "06e08be7b83fd7b1ecd5094e37ad272dfdb1d040668686ff85cc7799d2ff6f2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/esas2r/esas2r_ioctl.c",
  "human_readable_source": " \n\n#include \"esas2r.h\"\n\n \n\nu8 *esas2r_buffered_ioctl;\ndma_addr_t esas2r_buffered_ioctl_addr;\nu32 esas2r_buffered_ioctl_size;\nstruct pci_dev *esas2r_buffered_ioctl_pcid;\n\nstatic DEFINE_SEMAPHORE(buffered_ioctl_semaphore, 1);\ntypedef int (*BUFFERED_IOCTL_CALLBACK)(struct esas2r_adapter *,\n\t\t\t\t       struct esas2r_request *,\n\t\t\t\t       struct esas2r_sg_context *,\n\t\t\t\t       void *);\ntypedef void (*BUFFERED_IOCTL_DONE_CALLBACK)(struct esas2r_adapter *,\n\t\t\t\t\t     struct esas2r_request *, void *);\n\nstruct esas2r_buffered_ioctl {\n\tstruct esas2r_adapter *a;\n\tvoid *ioctl;\n\tu32 length;\n\tu32 control_code;\n\tu32 offset;\n\tBUFFERED_IOCTL_CALLBACK\n\t\tcallback;\n\tvoid *context;\n\tBUFFERED_IOCTL_DONE_CALLBACK\n\t\tdone_callback;\n\tvoid *done_context;\n\n};\n\nstatic void complete_fm_api_req(struct esas2r_adapter *a,\n\t\t\t\tstruct esas2r_request *rq)\n{\n\ta->fm_api_command_done = 1;\n\twake_up_interruptible(&a->fm_api_waiter);\n}\n\n \nstatic u32 get_physaddr_fm_api(struct esas2r_sg_context *sgc, u64 *addr)\n{\n\tstruct esas2r_adapter *a = (struct esas2r_adapter *)sgc->adapter;\n\tint offset = sgc->cur_offset - a->save_offset;\n\n\t(*addr) = a->firmware.phys + offset;\n\treturn a->firmware.orig_len - offset;\n}\n\nstatic u32 get_physaddr_fm_api_header(struct esas2r_sg_context *sgc, u64 *addr)\n{\n\tstruct esas2r_adapter *a = (struct esas2r_adapter *)sgc->adapter;\n\tint offset = sgc->cur_offset - a->save_offset;\n\n\t(*addr) = a->firmware.header_buff_phys + offset;\n\treturn sizeof(struct esas2r_flash_img) - offset;\n}\n\n \nstatic void do_fm_api(struct esas2r_adapter *a, struct esas2r_flash_img *fi)\n{\n\tstruct esas2r_request *rq;\n\n\tif (mutex_lock_interruptible(&a->fm_api_mutex)) {\n\t\tfi->status = FI_STAT_BUSY;\n\t\treturn;\n\t}\n\n\trq = esas2r_alloc_request(a);\n\tif (rq == NULL) {\n\t\tfi->status = FI_STAT_BUSY;\n\t\tgoto free_sem;\n\t}\n\n\tif (fi == &a->firmware.header) {\n\t\ta->firmware.header_buff = dma_alloc_coherent(&a->pcid->dev,\n\t\t\t\t\t\t\t     (size_t)sizeof(\n\t\t\t\t\t\t\t\t     struct\n\t\t\t\t\t\t\t\t     esas2r_flash_img),\n\t\t\t\t\t\t\t     (dma_addr_t *)&a->\n\t\t\t\t\t\t\t     firmware.\n\t\t\t\t\t\t\t     header_buff_phys,\n\t\t\t\t\t\t\t     GFP_KERNEL);\n\n\t\tif (a->firmware.header_buff == NULL) {\n\t\t\tesas2r_debug(\"failed to allocate header buffer!\");\n\t\t\tfi->status = FI_STAT_BUSY;\n\t\t\tgoto free_req;\n\t\t}\n\n\t\tmemcpy(a->firmware.header_buff, fi,\n\t\t       sizeof(struct esas2r_flash_img));\n\t\ta->save_offset = a->firmware.header_buff;\n\t\ta->fm_api_sgc.get_phys_addr =\n\t\t\t(PGETPHYSADDR)get_physaddr_fm_api_header;\n\t} else {\n\t\ta->save_offset = (u8 *)fi;\n\t\ta->fm_api_sgc.get_phys_addr =\n\t\t\t(PGETPHYSADDR)get_physaddr_fm_api;\n\t}\n\n\trq->comp_cb = complete_fm_api_req;\n\ta->fm_api_command_done = 0;\n\ta->fm_api_sgc.cur_offset = a->save_offset;\n\n\tif (!esas2r_fm_api(a, (struct esas2r_flash_img *)a->save_offset, rq,\n\t\t\t   &a->fm_api_sgc))\n\t\tgoto all_done;\n\n\t \n\twhile (!a->fm_api_command_done)\n\t\twait_event_interruptible(a->fm_api_waiter,\n\t\t\t\t\t a->fm_api_command_done);\nall_done:\n\tif (fi == &a->firmware.header) {\n\t\tmemcpy(fi, a->firmware.header_buff,\n\t\t       sizeof(struct esas2r_flash_img));\n\n\t\tdma_free_coherent(&a->pcid->dev,\n\t\t\t\t  (size_t)sizeof(struct esas2r_flash_img),\n\t\t\t\t  a->firmware.header_buff,\n\t\t\t\t  (dma_addr_t)a->firmware.header_buff_phys);\n\t}\nfree_req:\n\tesas2r_free_request(a, (struct esas2r_request *)rq);\nfree_sem:\n\tmutex_unlock(&a->fm_api_mutex);\n\treturn;\n\n}\n\nstatic void complete_nvr_req(struct esas2r_adapter *a,\n\t\t\t     struct esas2r_request *rq)\n{\n\ta->nvram_command_done = 1;\n\twake_up_interruptible(&a->nvram_waiter);\n}\n\n \nstatic u32 get_physaddr_buffered_ioctl(struct esas2r_sg_context *sgc,\n\t\t\t\t       u64 *addr)\n{\n\tint offset = (u8 *)sgc->cur_offset - esas2r_buffered_ioctl;\n\n\t(*addr) = esas2r_buffered_ioctl_addr + offset;\n\treturn esas2r_buffered_ioctl_size - offset;\n}\n\nstatic void complete_buffered_ioctl_req(struct esas2r_adapter *a,\n\t\t\t\t\tstruct esas2r_request *rq)\n{\n\ta->buffered_ioctl_done = 1;\n\twake_up_interruptible(&a->buffered_ioctl_waiter);\n}\n\nstatic u8 handle_buffered_ioctl(struct esas2r_buffered_ioctl *bi)\n{\n\tstruct esas2r_adapter *a = bi->a;\n\tstruct esas2r_request *rq;\n\tstruct esas2r_sg_context sgc;\n\tu8 result = IOCTL_SUCCESS;\n\n\tif (down_interruptible(&buffered_ioctl_semaphore))\n\t\treturn IOCTL_OUT_OF_RESOURCES;\n\n\t \n\tif (esas2r_buffered_ioctl) {\n\t\tif (esas2r_buffered_ioctl_size < bi->length) {\n\t\t\t \n\t\t\tdma_free_coherent(&a->pcid->dev,\n\t\t\t\t\t  (size_t)esas2r_buffered_ioctl_size,\n\t\t\t\t\t  esas2r_buffered_ioctl,\n\t\t\t\t\t  esas2r_buffered_ioctl_addr);\n\n\t\t\tgoto allocate_buffer;\n\t\t}\n\t} else {\nallocate_buffer:\n\t\tesas2r_buffered_ioctl_size = bi->length;\n\t\tesas2r_buffered_ioctl_pcid = a->pcid;\n\t\tesas2r_buffered_ioctl = dma_alloc_coherent(&a->pcid->dev,\n\t\t\t\t\t\t\t   (size_t)\n\t\t\t\t\t\t\t   esas2r_buffered_ioctl_size,\n\t\t\t\t\t\t\t   &\n\t\t\t\t\t\t\t   esas2r_buffered_ioctl_addr,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t}\n\n\tif (!esas2r_buffered_ioctl) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"could not allocate %d bytes of consistent memory \"\n\t\t\t   \"for a buffered ioctl!\",\n\t\t\t   bi->length);\n\n\t\tesas2r_debug(\"buffered ioctl alloc failure\");\n\t\tresult = IOCTL_OUT_OF_RESOURCES;\n\t\tgoto exit_cleanly;\n\t}\n\n\tmemcpy(esas2r_buffered_ioctl, bi->ioctl, bi->length);\n\n\trq = esas2r_alloc_request(a);\n\tif (rq == NULL) {\n\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t   \"could not allocate an internal request\");\n\n\t\tresult = IOCTL_OUT_OF_RESOURCES;\n\t\tesas2r_debug(\"buffered ioctl - no requests\");\n\t\tgoto exit_cleanly;\n\t}\n\n\ta->buffered_ioctl_done = 0;\n\trq->comp_cb = complete_buffered_ioctl_req;\n\tsgc.cur_offset = esas2r_buffered_ioctl + bi->offset;\n\tsgc.get_phys_addr = (PGETPHYSADDR)get_physaddr_buffered_ioctl;\n\tsgc.length = esas2r_buffered_ioctl_size;\n\n\tif (!(*bi->callback)(a, rq, &sgc, bi->context)) {\n\t\t \n\t\ta->buffered_ioctl_done = 0;\n\t\tgoto free_andexit_cleanly;\n\t}\n\n\t \n\twhile (!a->buffered_ioctl_done)\n\t\twait_event_interruptible(a->buffered_ioctl_waiter,\n\t\t\t\t\t a->buffered_ioctl_done);\n\nfree_andexit_cleanly:\n\tif (result == IOCTL_SUCCESS && bi->done_callback)\n\t\t(*bi->done_callback)(a, rq, bi->done_context);\n\n\tesas2r_free_request(a, rq);\n\nexit_cleanly:\n\tif (result == IOCTL_SUCCESS)\n\t\tmemcpy(bi->ioctl, esas2r_buffered_ioctl, bi->length);\n\n\tup(&buffered_ioctl_semaphore);\n\treturn result;\n}\n\n \nstatic int smp_ioctl_callback(struct esas2r_adapter *a,\n\t\t\t      struct esas2r_request *rq,\n\t\t\t      struct esas2r_sg_context *sgc, void *context)\n{\n\tstruct atto_ioctl_smp *si =\n\t\t(struct atto_ioctl_smp *)esas2r_buffered_ioctl;\n\n\tesas2r_sgc_init(sgc, a, rq, rq->vrq->ioctl.sge);\n\tesas2r_build_ioctl_req(a, rq, sgc->length, VDA_IOCTL_SMP);\n\n\tif (!esas2r_build_sg_list(a, rq, sgc)) {\n\t\tsi->status = ATTO_STS_OUT_OF_RSRC;\n\t\treturn false;\n\t}\n\n\tesas2r_start_request(a, rq);\n\treturn true;\n}\n\nstatic u8 handle_smp_ioctl(struct esas2r_adapter *a, struct atto_ioctl_smp *si)\n{\n\tstruct esas2r_buffered_ioctl bi;\n\n\tmemset(&bi, 0, sizeof(bi));\n\n\tbi.a = a;\n\tbi.ioctl = si;\n\tbi.length = sizeof(struct atto_ioctl_smp)\n\t\t    + le32_to_cpu(si->req_length)\n\t\t    + le32_to_cpu(si->rsp_length);\n\tbi.offset = 0;\n\tbi.callback = smp_ioctl_callback;\n\treturn handle_buffered_ioctl(&bi);\n}\n\n\n \nstatic void esas2r_csmi_ioctl_tunnel_comp_cb(struct esas2r_adapter *a,\n\t\t\t\t\t     struct esas2r_request *rq)\n{\n\trq->target_id = le16_to_cpu(rq->func_rsp.ioctl_rsp.csmi.target_id);\n\trq->vrq->scsi.flags |= cpu_to_le32(rq->func_rsp.ioctl_rsp.csmi.lun);\n\n\t \n\t(*rq->aux_req_cb)(a, rq);\n}\n\n \nstatic bool csmi_ioctl_tunnel(struct esas2r_adapter *a,\n\t\t\t      union atto_ioctl_csmi *ci,\n\t\t\t      struct esas2r_request *rq,\n\t\t\t      struct esas2r_sg_context *sgc,\n\t\t\t      u32 ctrl_code,\n\t\t\t      u16 target_id)\n{\n\tstruct atto_vda_ioctl_req *ioctl = &rq->vrq->ioctl;\n\n\tif (test_bit(AF_DEGRADED_MODE, &a->flags))\n\t\treturn false;\n\n\tesas2r_sgc_init(sgc, a, rq, rq->vrq->ioctl.sge);\n\tesas2r_build_ioctl_req(a, rq, sgc->length, VDA_IOCTL_CSMI);\n\tioctl->csmi.ctrl_code = cpu_to_le32(ctrl_code);\n\tioctl->csmi.target_id = cpu_to_le16(target_id);\n\tioctl->csmi.lun = (u8)le32_to_cpu(rq->vrq->scsi.flags);\n\n\t \n\trq->aux_req_cx = ci;\n\trq->aux_req_cb = rq->comp_cb;\n\trq->comp_cb = esas2r_csmi_ioctl_tunnel_comp_cb;\n\n\tif (!esas2r_build_sg_list(a, rq, sgc))\n\t\treturn false;\n\n\tesas2r_start_request(a, rq);\n\treturn true;\n}\n\nstatic bool check_lun(struct scsi_lun lun)\n{\n\tbool result;\n\n\tresult = ((lun.scsi_lun[7] == 0) &&\n\t\t  (lun.scsi_lun[6] == 0) &&\n\t\t  (lun.scsi_lun[5] == 0) &&\n\t\t  (lun.scsi_lun[4] == 0) &&\n\t\t  (lun.scsi_lun[3] == 0) &&\n\t\t  (lun.scsi_lun[2] == 0) &&\n \n\t\t  (lun.scsi_lun[0] == 0));\n\n\treturn result;\n}\n\nstatic int csmi_ioctl_callback(struct esas2r_adapter *a,\n\t\t\t       struct esas2r_request *rq,\n\t\t\t       struct esas2r_sg_context *sgc, void *context)\n{\n\tstruct atto_csmi *ci = (struct atto_csmi *)context;\n\tunion atto_ioctl_csmi *ioctl_csmi =\n\t\t(union atto_ioctl_csmi *)esas2r_buffered_ioctl;\n\tu8 path = 0;\n\tu8 tid = 0;\n\tu8 lun = 0;\n\tu32 sts = CSMI_STS_SUCCESS;\n\tstruct esas2r_target *t;\n\tunsigned long flags;\n\n\tif (ci->control_code == CSMI_CC_GET_DEV_ADDR) {\n\t\tstruct atto_csmi_get_dev_addr *gda = &ci->data.dev_addr;\n\n\t\tpath = gda->path_id;\n\t\ttid = gda->target_id;\n\t\tlun = gda->lun;\n\t} else if (ci->control_code == CSMI_CC_TASK_MGT) {\n\t\tstruct atto_csmi_task_mgmt *tm = &ci->data.tsk_mgt;\n\n\t\tpath = tm->path_id;\n\t\ttid = tm->target_id;\n\t\tlun = tm->lun;\n\t}\n\n\tif (path > 0) {\n\t\trq->func_rsp.ioctl_rsp.csmi.csmi_status = cpu_to_le32(\n\t\t\tCSMI_STS_INV_PARAM);\n\t\treturn false;\n\t}\n\n\trq->target_id = tid;\n\trq->vrq->scsi.flags |= cpu_to_le32(lun);\n\n\tswitch (ci->control_code) {\n\tcase CSMI_CC_GET_DRVR_INFO:\n\t{\n\t\tstruct atto_csmi_get_driver_info *gdi = &ioctl_csmi->drvr_info;\n\n\t\tstrcpy(gdi->description, esas2r_get_model_name(a));\n\t\tgdi->csmi_major_rev = CSMI_MAJOR_REV;\n\t\tgdi->csmi_minor_rev = CSMI_MINOR_REV;\n\t\tbreak;\n\t}\n\n\tcase CSMI_CC_GET_CNTLR_CFG:\n\t{\n\t\tstruct atto_csmi_get_cntlr_cfg *gcc = &ioctl_csmi->cntlr_cfg;\n\n\t\tgcc->base_io_addr = 0;\n\t\tpci_read_config_dword(a->pcid, PCI_BASE_ADDRESS_2,\n\t\t\t\t      &gcc->base_memaddr_lo);\n\t\tpci_read_config_dword(a->pcid, PCI_BASE_ADDRESS_3,\n\t\t\t\t      &gcc->base_memaddr_hi);\n\t\tgcc->board_id = MAKEDWORD(a->pcid->subsystem_device,\n\t\t\t\t\t  a->pcid->subsystem_vendor);\n\t\tgcc->slot_num = CSMI_SLOT_NUM_UNKNOWN;\n\t\tgcc->cntlr_class = CSMI_CNTLR_CLASS_HBA;\n\t\tgcc->io_bus_type = CSMI_BUS_TYPE_PCI;\n\t\tgcc->pci_addr.bus_num = a->pcid->bus->number;\n\t\tgcc->pci_addr.device_num = PCI_SLOT(a->pcid->devfn);\n\t\tgcc->pci_addr.function_num = PCI_FUNC(a->pcid->devfn);\n\n\t\tmemset(gcc->serial_num, 0, sizeof(gcc->serial_num));\n\n\t\tgcc->major_rev = LOBYTE(LOWORD(a->fw_version));\n\t\tgcc->minor_rev = HIBYTE(LOWORD(a->fw_version));\n\t\tgcc->build_rev = LOBYTE(HIWORD(a->fw_version));\n\t\tgcc->release_rev = HIBYTE(HIWORD(a->fw_version));\n\t\tgcc->bios_major_rev = HIBYTE(HIWORD(a->flash_ver));\n\t\tgcc->bios_minor_rev = LOBYTE(HIWORD(a->flash_ver));\n\t\tgcc->bios_build_rev = LOWORD(a->flash_ver);\n\n\t\tif (test_bit(AF2_THUNDERLINK, &a->flags2))\n\t\t\tgcc->cntlr_flags = CSMI_CNTLRF_SAS_HBA\n\t\t\t\t\t   | CSMI_CNTLRF_SATA_HBA;\n\t\telse\n\t\t\tgcc->cntlr_flags = CSMI_CNTLRF_SAS_RAID\n\t\t\t\t\t   | CSMI_CNTLRF_SATA_RAID;\n\n\t\tgcc->rrom_major_rev = 0;\n\t\tgcc->rrom_minor_rev = 0;\n\t\tgcc->rrom_build_rev = 0;\n\t\tgcc->rrom_release_rev = 0;\n\t\tgcc->rrom_biosmajor_rev = 0;\n\t\tgcc->rrom_biosminor_rev = 0;\n\t\tgcc->rrom_biosbuild_rev = 0;\n\t\tgcc->rrom_biosrelease_rev = 0;\n\t\tbreak;\n\t}\n\n\tcase CSMI_CC_GET_CNTLR_STS:\n\t{\n\t\tstruct atto_csmi_get_cntlr_sts *gcs = &ioctl_csmi->cntlr_sts;\n\n\t\tif (test_bit(AF_DEGRADED_MODE, &a->flags))\n\t\t\tgcs->status = CSMI_CNTLR_STS_FAILED;\n\t\telse\n\t\t\tgcs->status = CSMI_CNTLR_STS_GOOD;\n\n\t\tgcs->offline_reason = CSMI_OFFLINE_NO_REASON;\n\t\tbreak;\n\t}\n\n\tcase CSMI_CC_FW_DOWNLOAD:\n\tcase CSMI_CC_GET_RAID_INFO:\n\tcase CSMI_CC_GET_RAID_CFG:\n\n\t\tsts = CSMI_STS_BAD_CTRL_CODE;\n\t\tbreak;\n\n\tcase CSMI_CC_SMP_PASSTHRU:\n\tcase CSMI_CC_SSP_PASSTHRU:\n\tcase CSMI_CC_STP_PASSTHRU:\n\tcase CSMI_CC_GET_PHY_INFO:\n\tcase CSMI_CC_SET_PHY_INFO:\n\tcase CSMI_CC_GET_LINK_ERRORS:\n\tcase CSMI_CC_GET_SATA_SIG:\n\tcase CSMI_CC_GET_CONN_INFO:\n\tcase CSMI_CC_PHY_CTRL:\n\n\t\tif (!csmi_ioctl_tunnel(a, ioctl_csmi, rq, sgc,\n\t\t\t\t       ci->control_code,\n\t\t\t\t       ESAS2R_TARG_ID_INV)) {\n\t\t\tsts = CSMI_STS_FAILED;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\n\tcase CSMI_CC_GET_SCSI_ADDR:\n\t{\n\t\tstruct atto_csmi_get_scsi_addr *gsa = &ioctl_csmi->scsi_addr;\n\n\t\tstruct scsi_lun lun;\n\n\t\tmemcpy(&lun, gsa->sas_lun, sizeof(struct scsi_lun));\n\n\t\tif (!check_lun(lun)) {\n\t\t\tsts = CSMI_STS_NO_SCSI_ADDR;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tspin_lock_irqsave(&a->mem_lock, flags);\n\t\tt = esas2r_targ_db_find_by_sas_addr(a, (u64 *)gsa->sas_addr);\n\t\tspin_unlock_irqrestore(&a->mem_lock, flags);\n\n\t\tif (t == NULL) {\n\t\t\tsts = CSMI_STS_NO_SCSI_ADDR;\n\t\t\tbreak;\n\t\t}\n\n\t\tgsa->host_index = 0xFF;\n\t\tgsa->lun = gsa->sas_lun[1];\n\t\trq->target_id = esas2r_targ_get_id(t, a);\n\t\tbreak;\n\t}\n\n\tcase CSMI_CC_GET_DEV_ADDR:\n\t{\n\t\tstruct atto_csmi_get_dev_addr *gda = &ioctl_csmi->dev_addr;\n\n\t\t \n\t\tt = a->targetdb + rq->target_id;\n\n\t\tif (t >= a->targetdb_end\n\t\t    || t->target_state != TS_PRESENT\n\t\t    || t->sas_addr == 0) {\n\t\t\tsts = CSMI_STS_NO_DEV_ADDR;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\t*(u64 *)gda->sas_addr = t->sas_addr;\n\t\tmemset(gda->sas_lun, 0, sizeof(gda->sas_lun));\n\t\tgda->sas_lun[1] = (u8)le32_to_cpu(rq->vrq->scsi.flags);\n\t\tbreak;\n\t}\n\n\tcase CSMI_CC_TASK_MGT:\n\n\t\t \n\t\tt = a->targetdb + rq->target_id;\n\n\t\tif (t >= a->targetdb_end\n\t\t    || t->target_state != TS_PRESENT\n\t\t    || !(t->flags & TF_PASS_THRU)) {\n\t\t\tsts = CSMI_STS_NO_DEV_ADDR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!csmi_ioctl_tunnel(a, ioctl_csmi, rq, sgc,\n\t\t\t\t       ci->control_code,\n\t\t\t\t       t->phys_targ_id)) {\n\t\t\tsts = CSMI_STS_FAILED;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\n\tdefault:\n\n\t\tsts = CSMI_STS_BAD_CTRL_CODE;\n\t\tbreak;\n\t}\n\n\trq->func_rsp.ioctl_rsp.csmi.csmi_status = cpu_to_le32(sts);\n\n\treturn false;\n}\n\n\nstatic void csmi_ioctl_done_callback(struct esas2r_adapter *a,\n\t\t\t\t     struct esas2r_request *rq, void *context)\n{\n\tstruct atto_csmi *ci = (struct atto_csmi *)context;\n\tunion atto_ioctl_csmi *ioctl_csmi =\n\t\t(union atto_ioctl_csmi *)esas2r_buffered_ioctl;\n\n\tswitch (ci->control_code) {\n\tcase CSMI_CC_GET_DRVR_INFO:\n\t{\n\t\tstruct atto_csmi_get_driver_info *gdi =\n\t\t\t&ioctl_csmi->drvr_info;\n\n\t\tstrcpy(gdi->name, ESAS2R_VERSION_STR);\n\n\t\tgdi->major_rev = ESAS2R_MAJOR_REV;\n\t\tgdi->minor_rev = ESAS2R_MINOR_REV;\n\t\tgdi->build_rev = 0;\n\t\tgdi->release_rev = 0;\n\t\tbreak;\n\t}\n\n\tcase CSMI_CC_GET_SCSI_ADDR:\n\t{\n\t\tstruct atto_csmi_get_scsi_addr *gsa = &ioctl_csmi->scsi_addr;\n\n\t\tif (le32_to_cpu(rq->func_rsp.ioctl_rsp.csmi.csmi_status) ==\n\t\t    CSMI_STS_SUCCESS) {\n\t\t\tgsa->target_id = rq->target_id;\n\t\t\tgsa->path_id = 0;\n\t\t}\n\n\t\tbreak;\n\t}\n\t}\n\n\tci->status = le32_to_cpu(rq->func_rsp.ioctl_rsp.csmi.csmi_status);\n}\n\n\nstatic u8 handle_csmi_ioctl(struct esas2r_adapter *a, struct atto_csmi *ci)\n{\n\tstruct esas2r_buffered_ioctl bi;\n\n\tmemset(&bi, 0, sizeof(bi));\n\n\tbi.a = a;\n\tbi.ioctl = &ci->data;\n\tbi.length = sizeof(union atto_ioctl_csmi);\n\tbi.offset = 0;\n\tbi.callback = csmi_ioctl_callback;\n\tbi.context = ci;\n\tbi.done_callback = csmi_ioctl_done_callback;\n\tbi.done_context = ci;\n\n\treturn handle_buffered_ioctl(&bi);\n}\n\n \n\n \nstatic bool hba_ioctl_tunnel(struct esas2r_adapter *a,\n\t\t\t     struct atto_ioctl *hi,\n\t\t\t     struct esas2r_request *rq,\n\t\t\t     struct esas2r_sg_context *sgc)\n{\n\tesas2r_sgc_init(sgc, a, rq, rq->vrq->ioctl.sge);\n\n\tesas2r_build_ioctl_req(a, rq, sgc->length, VDA_IOCTL_HBA);\n\n\tif (!esas2r_build_sg_list(a, rq, sgc)) {\n\t\thi->status = ATTO_STS_OUT_OF_RSRC;\n\n\t\treturn false;\n\t}\n\n\tesas2r_start_request(a, rq);\n\n\treturn true;\n}\n\nstatic void scsi_passthru_comp_cb(struct esas2r_adapter *a,\n\t\t\t\t  struct esas2r_request *rq)\n{\n\tstruct atto_ioctl *hi = (struct atto_ioctl *)rq->aux_req_cx;\n\tstruct atto_hba_scsi_pass_thru *spt = &hi->data.scsi_pass_thru;\n\tu8 sts = ATTO_SPT_RS_FAILED;\n\n\tspt->scsi_status = rq->func_rsp.scsi_rsp.scsi_stat;\n\tspt->sense_length = rq->sense_len;\n\tspt->residual_length =\n\t\tle32_to_cpu(rq->func_rsp.scsi_rsp.residual_length);\n\n\tswitch (rq->req_stat) {\n\tcase RS_SUCCESS:\n\tcase RS_SCSI_ERROR:\n\t\tsts = ATTO_SPT_RS_SUCCESS;\n\t\tbreak;\n\tcase RS_UNDERRUN:\n\t\tsts = ATTO_SPT_RS_UNDERRUN;\n\t\tbreak;\n\tcase RS_OVERRUN:\n\t\tsts = ATTO_SPT_RS_OVERRUN;\n\t\tbreak;\n\tcase RS_SEL:\n\tcase RS_SEL2:\n\t\tsts = ATTO_SPT_RS_NO_DEVICE;\n\t\tbreak;\n\tcase RS_NO_LUN:\n\t\tsts = ATTO_SPT_RS_NO_LUN;\n\t\tbreak;\n\tcase RS_TIMEOUT:\n\t\tsts = ATTO_SPT_RS_TIMEOUT;\n\t\tbreak;\n\tcase RS_DEGRADED:\n\t\tsts = ATTO_SPT_RS_DEGRADED;\n\t\tbreak;\n\tcase RS_BUSY:\n\t\tsts = ATTO_SPT_RS_BUSY;\n\t\tbreak;\n\tcase RS_ABORTED:\n\t\tsts = ATTO_SPT_RS_ABORTED;\n\t\tbreak;\n\tcase RS_RESET:\n\t\tsts = ATTO_SPT_RS_BUS_RESET;\n\t\tbreak;\n\t}\n\n\tspt->req_status = sts;\n\n\t \n\tspt->target_id =\n\t\tesas2r_targ_db_find_next_present(a, (u16)spt->target_id);\n\n\t \n\t(*rq->aux_req_cb)(a, rq);\n}\n\nstatic int hba_ioctl_callback(struct esas2r_adapter *a,\n\t\t\t      struct esas2r_request *rq,\n\t\t\t      struct esas2r_sg_context *sgc,\n\t\t\t      void *context)\n{\n\tstruct atto_ioctl *hi = (struct atto_ioctl *)esas2r_buffered_ioctl;\n\n\thi->status = ATTO_STS_SUCCESS;\n\n\tswitch (hi->function) {\n\tcase ATTO_FUNC_GET_ADAP_INFO:\n\t{\n\t\tu8 *class_code = (u8 *)&a->pcid->class;\n\n\t\tstruct atto_hba_get_adapter_info *gai =\n\t\t\t&hi->data.get_adap_info;\n\n\t\tif (hi->flags & HBAF_TUNNEL) {\n\t\t\thi->status = ATTO_STS_UNSUPPORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hi->version > ATTO_VER_GET_ADAP_INFO0) {\n\t\t\thi->status = ATTO_STS_INV_VERSION;\n\t\t\thi->version = ATTO_VER_GET_ADAP_INFO0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(gai, 0, sizeof(*gai));\n\n\t\tgai->pci.vendor_id = a->pcid->vendor;\n\t\tgai->pci.device_id = a->pcid->device;\n\t\tgai->pci.ss_vendor_id = a->pcid->subsystem_vendor;\n\t\tgai->pci.ss_device_id = a->pcid->subsystem_device;\n\t\tgai->pci.class_code[0] = class_code[0];\n\t\tgai->pci.class_code[1] = class_code[1];\n\t\tgai->pci.class_code[2] = class_code[2];\n\t\tgai->pci.rev_id = a->pcid->revision;\n\t\tgai->pci.bus_num = a->pcid->bus->number;\n\t\tgai->pci.dev_num = PCI_SLOT(a->pcid->devfn);\n\t\tgai->pci.func_num = PCI_FUNC(a->pcid->devfn);\n\n\t\tif (pci_is_pcie(a->pcid)) {\n\t\t\tu16 stat;\n\t\t\tu32 caps;\n\n\t\t\tpcie_capability_read_word(a->pcid, PCI_EXP_LNKSTA,\n\t\t\t\t\t\t  &stat);\n\t\t\tpcie_capability_read_dword(a->pcid, PCI_EXP_LNKCAP,\n\t\t\t\t\t\t   &caps);\n\n\t\t\tgai->pci.link_speed_curr =\n\t\t\t\t(u8)(stat & PCI_EXP_LNKSTA_CLS);\n\t\t\tgai->pci.link_speed_max =\n\t\t\t\t(u8)(caps & PCI_EXP_LNKCAP_SLS);\n\t\t\tgai->pci.link_width_curr =\n\t\t\t\t(u8)((stat & PCI_EXP_LNKSTA_NLW)\n\t\t\t\t     >> PCI_EXP_LNKSTA_NLW_SHIFT);\n\t\t\tgai->pci.link_width_max =\n\t\t\t\t(u8)((caps & PCI_EXP_LNKCAP_MLW)\n\t\t\t\t     >> 4);\n\t\t}\n\n\t\tgai->pci.msi_vector_cnt = 1;\n\n\t\tif (a->pcid->msix_enabled)\n\t\t\tgai->pci.interrupt_mode = ATTO_GAI_PCIIM_MSIX;\n\t\telse if (a->pcid->msi_enabled)\n\t\t\tgai->pci.interrupt_mode = ATTO_GAI_PCIIM_MSI;\n\t\telse\n\t\t\tgai->pci.interrupt_mode = ATTO_GAI_PCIIM_LEGACY;\n\n\t\tgai->adap_type = ATTO_GAI_AT_ESASRAID2;\n\n\t\tif (test_bit(AF2_THUNDERLINK, &a->flags2))\n\t\t\tgai->adap_type = ATTO_GAI_AT_TLSASHBA;\n\n\t\tif (test_bit(AF_DEGRADED_MODE, &a->flags))\n\t\t\tgai->adap_flags |= ATTO_GAI_AF_DEGRADED;\n\n\t\tgai->adap_flags |= ATTO_GAI_AF_SPT_SUPP |\n\t\t\t\t   ATTO_GAI_AF_DEVADDR_SUPP;\n\n\t\tif (a->pcid->subsystem_device == ATTO_ESAS_R60F\n\t\t    || a->pcid->subsystem_device == ATTO_ESAS_R608\n\t\t    || a->pcid->subsystem_device == ATTO_ESAS_R644\n\t\t    || a->pcid->subsystem_device == ATTO_TSSC_3808E)\n\t\t\tgai->adap_flags |= ATTO_GAI_AF_VIRT_SES;\n\n\t\tgai->num_ports = ESAS2R_NUM_PHYS;\n\t\tgai->num_phys = ESAS2R_NUM_PHYS;\n\n\t\tstrcpy(gai->firmware_rev, a->fw_rev);\n\t\tstrcpy(gai->flash_rev, a->flash_rev);\n\t\tstrcpy(gai->model_name_short, esas2r_get_model_name_short(a));\n\t\tstrcpy(gai->model_name, esas2r_get_model_name(a));\n\n\t\tgai->num_targets = ESAS2R_MAX_TARGETS;\n\n\t\tgai->num_busses = 1;\n\t\tgai->num_targsper_bus = gai->num_targets;\n\t\tgai->num_lunsper_targ = 256;\n\n\t\tif (a->pcid->subsystem_device == ATTO_ESAS_R6F0\n\t\t    || a->pcid->subsystem_device == ATTO_ESAS_R60F)\n\t\t\tgai->num_connectors = 4;\n\t\telse\n\t\t\tgai->num_connectors = 2;\n\n\t\tgai->adap_flags2 |= ATTO_GAI_AF2_ADAP_CTRL_SUPP;\n\n\t\tgai->num_targets_backend = a->num_targets_backend;\n\n\t\tgai->tunnel_flags = a->ioctl_tunnel\n\t\t\t\t    & (ATTO_GAI_TF_MEM_RW\n\t\t\t\t       | ATTO_GAI_TF_TRACE\n\t\t\t\t       | ATTO_GAI_TF_SCSI_PASS_THRU\n\t\t\t\t       | ATTO_GAI_TF_GET_DEV_ADDR\n\t\t\t\t       | ATTO_GAI_TF_PHY_CTRL\n\t\t\t\t       | ATTO_GAI_TF_CONN_CTRL\n\t\t\t\t       | ATTO_GAI_TF_GET_DEV_INFO);\n\t\tbreak;\n\t}\n\n\tcase ATTO_FUNC_GET_ADAP_ADDR:\n\t{\n\t\tstruct atto_hba_get_adapter_address *gaa =\n\t\t\t&hi->data.get_adap_addr;\n\n\t\tif (hi->flags & HBAF_TUNNEL) {\n\t\t\thi->status = ATTO_STS_UNSUPPORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hi->version > ATTO_VER_GET_ADAP_ADDR0) {\n\t\t\thi->status = ATTO_STS_INV_VERSION;\n\t\t\thi->version = ATTO_VER_GET_ADAP_ADDR0;\n\t\t} else if (gaa->addr_type == ATTO_GAA_AT_PORT\n\t\t\t   || gaa->addr_type == ATTO_GAA_AT_NODE) {\n\t\t\tif (gaa->addr_type == ATTO_GAA_AT_PORT\n\t\t\t    && gaa->port_id >= ESAS2R_NUM_PHYS) {\n\t\t\t\thi->status = ATTO_STS_NOT_APPL;\n\t\t\t} else {\n\t\t\t\tmemcpy((u64 *)gaa->address,\n\t\t\t\t       &a->nvram->sas_addr[0], sizeof(u64));\n\t\t\t\tgaa->addr_len = sizeof(u64);\n\t\t\t}\n\t\t} else {\n\t\t\thi->status = ATTO_STS_INV_PARAM;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase ATTO_FUNC_MEM_RW:\n\t{\n\t\tif (hi->flags & HBAF_TUNNEL) {\n\t\t\tif (hba_ioctl_tunnel(a, hi, rq, sgc))\n\t\t\t\treturn true;\n\n\t\t\tbreak;\n\t\t}\n\n\t\thi->status = ATTO_STS_UNSUPPORTED;\n\n\t\tbreak;\n\t}\n\n\tcase ATTO_FUNC_TRACE:\n\t{\n\t\tstruct atto_hba_trace *trc = &hi->data.trace;\n\n\t\tif (hi->flags & HBAF_TUNNEL) {\n\t\t\tif (hba_ioctl_tunnel(a, hi, rq, sgc))\n\t\t\t\treturn true;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hi->version > ATTO_VER_TRACE1) {\n\t\t\thi->status = ATTO_STS_INV_VERSION;\n\t\t\thi->version = ATTO_VER_TRACE1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (trc->trace_type == ATTO_TRC_TT_FWCOREDUMP\n\t\t    && hi->version >= ATTO_VER_TRACE1) {\n\t\t\tif (trc->trace_func == ATTO_TRC_TF_UPLOAD) {\n\t\t\t\tu32 len = hi->data_length;\n\t\t\t\tu32 offset = trc->current_offset;\n\t\t\t\tu32 total_len = ESAS2R_FWCOREDUMP_SZ;\n\n\t\t\t\t \n\t\t\t\tif (!test_bit(AF2_COREDUMP_SAVED, &a->flags2))\n\t\t\t\t\ttotal_len = 0;\n\n\t\t\t\tif (len > total_len)\n\t\t\t\t\tlen = total_len;\n\n\t\t\t\tif (offset >= total_len\n\t\t\t\t    || offset + len > total_len\n\t\t\t\t    || len == 0) {\n\t\t\t\t\thi->status = ATTO_STS_INV_PARAM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(trc->contents,\n\t\t\t\t       a->fw_coredump_buff + offset,\n\t\t\t\t       len);\n\t\t\t\thi->data_length = len;\n\t\t\t} else if (trc->trace_func == ATTO_TRC_TF_RESET) {\n\t\t\t\tmemset(a->fw_coredump_buff, 0,\n\t\t\t\t       ESAS2R_FWCOREDUMP_SZ);\n\n\t\t\t\tclear_bit(AF2_COREDUMP_SAVED, &a->flags2);\n\t\t\t} else if (trc->trace_func != ATTO_TRC_TF_GET_INFO) {\n\t\t\t\thi->status = ATTO_STS_UNSUPPORTED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\ttrc->trace_mask = 0;\n\t\t\ttrc->current_offset = 0;\n\t\t\ttrc->total_length = ESAS2R_FWCOREDUMP_SZ;\n\n\t\t\t \n\t\t\tif (!test_bit(AF2_COREDUMP_SAVED, &a->flags2))\n\t\t\t\ttrc->total_length = 0;\n\t\t} else {\n\t\t\thi->status = ATTO_STS_UNSUPPORTED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase ATTO_FUNC_SCSI_PASS_THRU:\n\t{\n\t\tstruct atto_hba_scsi_pass_thru *spt = &hi->data.scsi_pass_thru;\n\t\tstruct scsi_lun lun;\n\n\t\tmemcpy(&lun, spt->lun, sizeof(struct scsi_lun));\n\n\t\tif (hi->flags & HBAF_TUNNEL) {\n\t\t\tif (hba_ioctl_tunnel(a, hi, rq, sgc))\n\t\t\t\treturn true;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hi->version > ATTO_VER_SCSI_PASS_THRU0) {\n\t\t\thi->status = ATTO_STS_INV_VERSION;\n\t\t\thi->version = ATTO_VER_SCSI_PASS_THRU0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (spt->target_id >= ESAS2R_MAX_TARGETS || !check_lun(lun)) {\n\t\t\thi->status = ATTO_STS_INV_PARAM;\n\t\t\tbreak;\n\t\t}\n\n\t\tesas2r_sgc_init(sgc, a, rq, NULL);\n\n\t\tsgc->length = hi->data_length;\n\t\tsgc->cur_offset += offsetof(struct atto_ioctl, data.byte)\n\t\t\t\t   + sizeof(struct atto_hba_scsi_pass_thru);\n\n\t\t \n\t\trq->target_id = (u16)spt->target_id;\n\t\trq->vrq->scsi.flags |= cpu_to_le32(spt->lun[1]);\n\t\tmemcpy(rq->vrq->scsi.cdb, spt->cdb, 16);\n\t\trq->vrq->scsi.length = cpu_to_le32(hi->data_length);\n\t\trq->sense_len = spt->sense_length;\n\t\trq->sense_buf = (u8 *)spt->sense_data;\n\t\t \n\n\t\t \n\n\t\trq->aux_req_cx = hi;\n\t\trq->aux_req_cb = rq->comp_cb;\n\t\trq->comp_cb = scsi_passthru_comp_cb;\n\n\t\tif (spt->flags & ATTO_SPTF_DATA_IN) {\n\t\t\trq->vrq->scsi.flags |= cpu_to_le32(FCP_CMND_RDD);\n\t\t} else if (spt->flags & ATTO_SPTF_DATA_OUT) {\n\t\t\trq->vrq->scsi.flags |= cpu_to_le32(FCP_CMND_WRD);\n\t\t} else {\n\t\t\tif (sgc->length) {\n\t\t\t\thi->status = ATTO_STS_INV_PARAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (spt->flags & ATTO_SPTF_ORDERED_Q)\n\t\t\trq->vrq->scsi.flags |=\n\t\t\t\tcpu_to_le32(FCP_CMND_TA_ORDRD_Q);\n\t\telse if (spt->flags & ATTO_SPTF_HEAD_OF_Q)\n\t\t\trq->vrq->scsi.flags |= cpu_to_le32(FCP_CMND_TA_HEAD_Q);\n\n\n\t\tif (!esas2r_build_sg_list(a, rq, sgc)) {\n\t\t\thi->status = ATTO_STS_OUT_OF_RSRC;\n\t\t\tbreak;\n\t\t}\n\n\t\tesas2r_start_request(a, rq);\n\n\t\treturn true;\n\t}\n\n\tcase ATTO_FUNC_GET_DEV_ADDR:\n\t{\n\t\tstruct atto_hba_get_device_address *gda =\n\t\t\t&hi->data.get_dev_addr;\n\t\tstruct esas2r_target *t;\n\n\t\tif (hi->flags & HBAF_TUNNEL) {\n\t\t\tif (hba_ioctl_tunnel(a, hi, rq, sgc))\n\t\t\t\treturn true;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hi->version > ATTO_VER_GET_DEV_ADDR0) {\n\t\t\thi->status = ATTO_STS_INV_VERSION;\n\t\t\thi->version = ATTO_VER_GET_DEV_ADDR0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (gda->target_id >= ESAS2R_MAX_TARGETS) {\n\t\t\thi->status = ATTO_STS_INV_PARAM;\n\t\t\tbreak;\n\t\t}\n\n\t\tt = a->targetdb + (u16)gda->target_id;\n\n\t\tif (t->target_state != TS_PRESENT) {\n\t\t\thi->status = ATTO_STS_FAILED;\n\t\t} else if (gda->addr_type == ATTO_GDA_AT_PORT) {\n\t\t\tif (t->sas_addr == 0) {\n\t\t\t\thi->status = ATTO_STS_UNSUPPORTED;\n\t\t\t} else {\n\t\t\t\t*(u64 *)gda->address = t->sas_addr;\n\n\t\t\t\tgda->addr_len = sizeof(u64);\n\t\t\t}\n\t\t} else if (gda->addr_type == ATTO_GDA_AT_NODE) {\n\t\t\thi->status = ATTO_STS_NOT_APPL;\n\t\t} else {\n\t\t\thi->status = ATTO_STS_INV_PARAM;\n\t\t}\n\n\t\t \n\n\t\tgda->target_id =\n\t\t\tesas2r_targ_db_find_next_present(a,\n\t\t\t\t\t\t\t (u16)gda->target_id);\n\t\tbreak;\n\t}\n\n\tcase ATTO_FUNC_PHY_CTRL:\n\tcase ATTO_FUNC_CONN_CTRL:\n\t{\n\t\tif (hba_ioctl_tunnel(a, hi, rq, sgc))\n\t\t\treturn true;\n\n\t\tbreak;\n\t}\n\n\tcase ATTO_FUNC_ADAP_CTRL:\n\t{\n\t\tstruct atto_hba_adap_ctrl *ac = &hi->data.adap_ctrl;\n\n\t\tif (hi->flags & HBAF_TUNNEL) {\n\t\t\thi->status = ATTO_STS_UNSUPPORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hi->version > ATTO_VER_ADAP_CTRL0) {\n\t\t\thi->status = ATTO_STS_INV_VERSION;\n\t\t\thi->version = ATTO_VER_ADAP_CTRL0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ac->adap_func == ATTO_AC_AF_HARD_RST) {\n\t\t\tesas2r_reset_adapter(a);\n\t\t} else if (ac->adap_func != ATTO_AC_AF_GET_STATE) {\n\t\t\thi->status = ATTO_STS_UNSUPPORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (test_bit(AF_CHPRST_NEEDED, &a->flags))\n\t\t\tac->adap_state = ATTO_AC_AS_RST_SCHED;\n\t\telse if (test_bit(AF_CHPRST_PENDING, &a->flags))\n\t\t\tac->adap_state = ATTO_AC_AS_RST_IN_PROG;\n\t\telse if (test_bit(AF_DISC_PENDING, &a->flags))\n\t\t\tac->adap_state = ATTO_AC_AS_RST_DISC;\n\t\telse if (test_bit(AF_DISABLED, &a->flags))\n\t\t\tac->adap_state = ATTO_AC_AS_DISABLED;\n\t\telse if (test_bit(AF_DEGRADED_MODE, &a->flags))\n\t\t\tac->adap_state = ATTO_AC_AS_DEGRADED;\n\t\telse\n\t\t\tac->adap_state = ATTO_AC_AS_OK;\n\n\t\tbreak;\n\t}\n\n\tcase ATTO_FUNC_GET_DEV_INFO:\n\t{\n\t\tstruct atto_hba_get_device_info *gdi = &hi->data.get_dev_info;\n\t\tstruct esas2r_target *t;\n\n\t\tif (hi->flags & HBAF_TUNNEL) {\n\t\t\tif (hba_ioctl_tunnel(a, hi, rq, sgc))\n\t\t\t\treturn true;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hi->version > ATTO_VER_GET_DEV_INFO0) {\n\t\t\thi->status = ATTO_STS_INV_VERSION;\n\t\t\thi->version = ATTO_VER_GET_DEV_INFO0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (gdi->target_id >= ESAS2R_MAX_TARGETS) {\n\t\t\thi->status = ATTO_STS_INV_PARAM;\n\t\t\tbreak;\n\t\t}\n\n\t\tt = a->targetdb + (u16)gdi->target_id;\n\n\t\t \n\n\t\tgdi->target_id =\n\t\t\tesas2r_targ_db_find_next_present(a,\n\t\t\t\t\t\t\t (u16)gdi->target_id);\n\n\t\tif (t->target_state != TS_PRESENT) {\n\t\t\thi->status = ATTO_STS_FAILED;\n\t\t\tbreak;\n\t\t}\n\n\t\thi->status = ATTO_STS_UNSUPPORTED;\n\t\tbreak;\n\t}\n\n\tdefault:\n\n\t\thi->status = ATTO_STS_INV_FUNC;\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic void hba_ioctl_done_callback(struct esas2r_adapter *a,\n\t\t\t\t    struct esas2r_request *rq, void *context)\n{\n\tstruct atto_ioctl *ioctl_hba =\n\t\t(struct atto_ioctl *)esas2r_buffered_ioctl;\n\n\tesas2r_debug(\"hba_ioctl_done_callback %d\", a->index);\n\n\tif (ioctl_hba->function == ATTO_FUNC_GET_ADAP_INFO) {\n\t\tstruct atto_hba_get_adapter_info *gai =\n\t\t\t&ioctl_hba->data.get_adap_info;\n\n\t\tesas2r_debug(\"ATTO_FUNC_GET_ADAP_INFO\");\n\n\t\tgai->drvr_rev_major = ESAS2R_MAJOR_REV;\n\t\tgai->drvr_rev_minor = ESAS2R_MINOR_REV;\n\n\t\tstrcpy(gai->drvr_rev_ascii, ESAS2R_VERSION_STR);\n\t\tstrcpy(gai->drvr_name, ESAS2R_DRVR_NAME);\n\n\t\tgai->num_busses = 1;\n\t\tgai->num_targsper_bus = ESAS2R_MAX_ID + 1;\n\t\tgai->num_lunsper_targ = 1;\n\t}\n}\n\nu8 handle_hba_ioctl(struct esas2r_adapter *a,\n\t\t    struct atto_ioctl *ioctl_hba)\n{\n\tstruct esas2r_buffered_ioctl bi;\n\n\tmemset(&bi, 0, sizeof(bi));\n\n\tbi.a = a;\n\tbi.ioctl = ioctl_hba;\n\tbi.length = sizeof(struct atto_ioctl) + ioctl_hba->data_length;\n\tbi.callback = hba_ioctl_callback;\n\tbi.context = NULL;\n\tbi.done_callback = hba_ioctl_done_callback;\n\tbi.done_context = NULL;\n\tbi.offset = 0;\n\n\treturn handle_buffered_ioctl(&bi);\n}\n\n\nint esas2r_write_params(struct esas2r_adapter *a, struct esas2r_request *rq,\n\t\t\tstruct esas2r_sas_nvram *data)\n{\n\tint result = 0;\n\n\ta->nvram_command_done = 0;\n\trq->comp_cb = complete_nvr_req;\n\n\tif (esas2r_nvram_write(a, rq, data)) {\n\t\t \n\t\twhile (!a->nvram_command_done)\n\t\t\twait_event_interruptible(a->nvram_waiter,\n\t\t\t\t\t\t a->nvram_command_done);\n\t\t;\n\n\t\t \n\t\tif (rq->req_stat == RS_SUCCESS)\n\t\t\tresult = 1;\n\t}\n\treturn result;\n}\n\n\n \nint esas2r_ioctl_handler(void *hostdata, unsigned int cmd, void __user *arg)\n{\n\tstruct atto_express_ioctl *ioctl = NULL;\n\tstruct esas2r_adapter *a;\n\tstruct esas2r_request *rq;\n\tu16 code;\n\tint err;\n\n\tesas2r_log(ESAS2R_LOG_DEBG, \"ioctl (%p, %x, %p)\", hostdata, cmd, arg);\n\n\tif ((arg == NULL)\n\t    || (cmd < EXPRESS_IOCTL_MIN)\n\t    || (cmd > EXPRESS_IOCTL_MAX))\n\t\treturn -ENOTSUPP;\n\n\tioctl = memdup_user(arg, sizeof(struct atto_express_ioctl));\n\tif (IS_ERR(ioctl)) {\n\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t   \"ioctl_handler access_ok failed for cmd %u, address %p\",\n\t\t\t   cmd, arg);\n\t\treturn PTR_ERR(ioctl);\n\t}\n\n\t \n\n\tif (memcmp(ioctl->header.signature,\n\t\t   EXPRESS_IOCTL_SIGNATURE,\n\t\t   EXPRESS_IOCTL_SIGNATURE_SIZE) != 0) {\n\t\tesas2r_log(ESAS2R_LOG_WARN, \"invalid signature\");\n\t\tkfree(ioctl);\n\n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\n\tioctl->header.return_code = IOCTL_SUCCESS;\n\terr = 0;\n\n\t \n\n\tif (cmd == EXPRESS_IOCTL_GET_CHANNELS) {\n\t\tint i = 0, k = 0;\n\n\t\tioctl->data.chanlist.num_channels = 0;\n\n\t\twhile (i < MAX_ADAPTERS) {\n\t\t\tif (esas2r_adapters[i]) {\n\t\t\t\tioctl->data.chanlist.num_channels++;\n\t\t\t\tioctl->data.chanlist.channel[k] = i;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tgoto ioctl_done;\n\t}\n\n\t \n\n\tif (ioctl->header.channel == 0xFF) {\n\t\ta = (struct esas2r_adapter *)hostdata;\n\t} else {\n\t\tif (ioctl->header.channel >= MAX_ADAPTERS ||\n\t\t\tesas2r_adapters[ioctl->header.channel] == NULL) {\n\t\t\tioctl->header.return_code = IOCTL_BAD_CHANNEL;\n\t\t\tesas2r_log(ESAS2R_LOG_WARN, \"bad channel value\");\n\t\t\tkfree(ioctl);\n\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\ta = esas2r_adapters[ioctl->header.channel];\n\t}\n\n\tswitch (cmd) {\n\tcase EXPRESS_IOCTL_RW_FIRMWARE:\n\n\t\tif (ioctl->data.fwrw.img_type == FW_IMG_FM_API) {\n\t\t\terr = esas2r_write_fw(a,\n\t\t\t\t\t      (char *)ioctl->data.fwrw.image,\n\t\t\t\t\t      0,\n\t\t\t\t\t      sizeof(struct\n\t\t\t\t\t\t     atto_express_ioctl));\n\n\t\t\tif (err >= 0) {\n\t\t\t\terr = esas2r_read_fw(a,\n\t\t\t\t\t\t     (char *)ioctl->data.fwrw.\n\t\t\t\t\t\t     image,\n\t\t\t\t\t\t     0,\n\t\t\t\t\t\t     sizeof(struct\n\t\t\t\t\t\t\t    atto_express_ioctl));\n\t\t\t}\n\t\t} else if (ioctl->data.fwrw.img_type == FW_IMG_FS_API) {\n\t\t\terr = esas2r_write_fs(a,\n\t\t\t\t\t      (char *)ioctl->data.fwrw.image,\n\t\t\t\t\t      0,\n\t\t\t\t\t      sizeof(struct\n\t\t\t\t\t\t     atto_express_ioctl));\n\n\t\t\tif (err >= 0) {\n\t\t\t\terr = esas2r_read_fs(a,\n\t\t\t\t\t\t     (char *)ioctl->data.fwrw.\n\t\t\t\t\t\t     image,\n\t\t\t\t\t\t     0,\n\t\t\t\t\t\t     sizeof(struct\n\t\t\t\t\t\t\t    atto_express_ioctl));\n\t\t\t}\n\t\t} else {\n\t\t\tioctl->header.return_code = IOCTL_BAD_FLASH_IMGTYPE;\n\t\t}\n\n\t\tbreak;\n\n\tcase EXPRESS_IOCTL_READ_PARAMS:\n\n\t\tmemcpy(ioctl->data.prw.data_buffer, a->nvram,\n\t\t       sizeof(struct esas2r_sas_nvram));\n\t\tioctl->data.prw.code = 1;\n\t\tbreak;\n\n\tcase EXPRESS_IOCTL_WRITE_PARAMS:\n\n\t\trq = esas2r_alloc_request(a);\n\t\tif (rq == NULL) {\n\t\t\tkfree(ioctl);\n\t\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t   \"could not allocate an internal request\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcode = esas2r_write_params(a, rq,\n\t\t\t\t\t   (struct esas2r_sas_nvram *)ioctl->data.prw.data_buffer);\n\t\tioctl->data.prw.code = code;\n\n\t\tesas2r_free_request(a, rq);\n\n\t\tbreak;\n\n\tcase EXPRESS_IOCTL_DEFAULT_PARAMS:\n\n\t\tesas2r_nvram_get_defaults(a,\n\t\t\t\t\t  (struct esas2r_sas_nvram *)ioctl->data.prw.data_buffer);\n\t\tioctl->data.prw.code = 1;\n\t\tbreak;\n\n\tcase EXPRESS_IOCTL_CHAN_INFO:\n\n\t\tioctl->data.chaninfo.major_rev = ESAS2R_MAJOR_REV;\n\t\tioctl->data.chaninfo.minor_rev = ESAS2R_MINOR_REV;\n\t\tioctl->data.chaninfo.IRQ = a->pcid->irq;\n\t\tioctl->data.chaninfo.device_id = a->pcid->device;\n\t\tioctl->data.chaninfo.vendor_id = a->pcid->vendor;\n\t\tioctl->data.chaninfo.ven_dev_id = a->pcid->subsystem_device;\n\t\tioctl->data.chaninfo.revision_id = a->pcid->revision;\n\t\tioctl->data.chaninfo.pci_bus = a->pcid->bus->number;\n\t\tioctl->data.chaninfo.pci_dev_func = a->pcid->devfn;\n\t\tioctl->data.chaninfo.core_rev = 0;\n\t\tioctl->data.chaninfo.host_no = a->host->host_no;\n\t\tioctl->data.chaninfo.hbaapi_rev = 0;\n\t\tbreak;\n\n\tcase EXPRESS_IOCTL_SMP:\n\t\tioctl->header.return_code = handle_smp_ioctl(a,\n\t\t\t\t\t\t\t     &ioctl->data.\n\t\t\t\t\t\t\t     ioctl_smp);\n\t\tbreak;\n\n\tcase EXPRESS_CSMI:\n\t\tioctl->header.return_code =\n\t\t\thandle_csmi_ioctl(a, &ioctl->data.csmi);\n\t\tbreak;\n\n\tcase EXPRESS_IOCTL_HBA:\n\t\tioctl->header.return_code = handle_hba_ioctl(a,\n\t\t\t\t\t\t\t     &ioctl->data.\n\t\t\t\t\t\t\t     ioctl_hba);\n\t\tbreak;\n\n\tcase EXPRESS_IOCTL_VDA:\n\t\terr = esas2r_write_vda(a,\n\t\t\t\t       (char *)&ioctl->data.ioctl_vda,\n\t\t\t\t       0,\n\t\t\t\t       sizeof(struct atto_ioctl_vda) +\n\t\t\t\t       ioctl->data.ioctl_vda.data_length);\n\n\t\tif (err >= 0) {\n\t\t\terr = esas2r_read_vda(a,\n\t\t\t\t\t      (char *)&ioctl->data.ioctl_vda,\n\t\t\t\t\t      0,\n\t\t\t\t\t      sizeof(struct atto_ioctl_vda) +\n\t\t\t\t\t      ioctl->data.ioctl_vda.data_length);\n\t\t}\n\n\n\n\n\t\tbreak;\n\n\tcase EXPRESS_IOCTL_GET_MOD_INFO:\n\n\t\tioctl->data.modinfo.adapter = a;\n\t\tioctl->data.modinfo.pci_dev = a->pcid;\n\t\tioctl->data.modinfo.scsi_host = a->host;\n\t\tioctl->data.modinfo.host_no = a->host->host_no;\n\n\t\tbreak;\n\n\tdefault:\n\t\tesas2r_debug(\"esas2r_ioctl invalid cmd %p!\", cmd);\n\t\tioctl->header.return_code = IOCTL_ERR_INVCMD;\n\t}\n\nioctl_done:\n\n\tif (err < 0) {\n\t\tesas2r_log(ESAS2R_LOG_WARN, \"err %d on ioctl cmd %u\", err,\n\t\t\t   cmd);\n\n\t\tswitch (err) {\n\t\tcase -ENOMEM:\n\t\tcase -EBUSY:\n\t\t\tioctl->header.return_code = IOCTL_OUT_OF_RESOURCES;\n\t\t\tbreak;\n\n\t\tcase -ENOSYS:\n\t\tcase -EINVAL:\n\t\t\tioctl->header.return_code = IOCTL_INVALID_PARAM;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tioctl->header.return_code = IOCTL_GENERAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\t \n\terr = copy_to_user(arg, ioctl, sizeof(struct atto_express_ioctl));\n\tif (err != 0) {\n\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t   \"ioctl_handler copy_to_user didn't copy everything (err %d, cmd %u)\",\n\t\t\t   err, cmd);\n\t\tkfree(ioctl);\n\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(ioctl);\n\n\treturn 0;\n}\n\nint esas2r_ioctl(struct scsi_device *sd, unsigned int cmd, void __user *arg)\n{\n\treturn esas2r_ioctl_handler(sd->host->hostdata, cmd, arg);\n}\n\nstatic void free_fw_buffers(struct esas2r_adapter *a)\n{\n\tif (a->firmware.data) {\n\t\tdma_free_coherent(&a->pcid->dev,\n\t\t\t\t  (size_t)a->firmware.orig_len,\n\t\t\t\t  a->firmware.data,\n\t\t\t\t  (dma_addr_t)a->firmware.phys);\n\n\t\ta->firmware.data = NULL;\n\t}\n}\n\nstatic int allocate_fw_buffers(struct esas2r_adapter *a, u32 length)\n{\n\tfree_fw_buffers(a);\n\n\ta->firmware.orig_len = length;\n\n\ta->firmware.data = dma_alloc_coherent(&a->pcid->dev,\n\t\t\t\t\t      (size_t)length,\n\t\t\t\t\t      (dma_addr_t *)&a->firmware.phys,\n\t\t\t\t\t      GFP_KERNEL);\n\n\tif (!a->firmware.data) {\n\t\tesas2r_debug(\"buffer alloc failed!\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nint esas2r_read_fw(struct esas2r_adapter *a, char *buf, long off, int count)\n{\n\tesas2r_trace_enter();\n\t \n\tif (a->firmware.state == FW_STATUS_ST) {\n\t\tint size = min_t(int, count, sizeof(a->firmware.header));\n\t\tesas2r_trace_exit();\n\t\tmemcpy(buf, &a->firmware.header, size);\n\t\tesas2r_debug(\"esas2r_read_fw: STATUS size %d\", size);\n\t\treturn size;\n\t}\n\n\t \n\n\tif (a->firmware.state == FW_COMMAND_ST) {\n\t\tu32 length = a->firmware.header.length;\n\t\tesas2r_trace_exit();\n\n\t\tesas2r_debug(\"esas2r_read_fw: COMMAND length %d off %d\",\n\t\t\t     length,\n\t\t\t     off);\n\n\t\tif (off == 0) {\n\t\t\tif (a->firmware.header.action == FI_ACT_UP) {\n\t\t\t\tif (!allocate_fw_buffers(a, length))\n\t\t\t\t\treturn -ENOMEM;\n\n\n\t\t\t\t \n\n\t\t\t\tmemcpy(a->firmware.data,\n\t\t\t\t       &a->firmware.header,\n\t\t\t\t       sizeof(a->firmware.header));\n\n\t\t\t\tdo_fm_api(a,\n\t\t\t\t\t  (struct esas2r_flash_img *)a->firmware.data);\n\t\t\t} else if (a->firmware.header.action == FI_ACT_UPSZ) {\n\t\t\t\tint size =\n\t\t\t\t\tmin((int)count,\n\t\t\t\t\t    (int)sizeof(a->firmware.header));\n\t\t\t\tdo_fm_api(a, &a->firmware.header);\n\t\t\t\tmemcpy(buf, &a->firmware.header, size);\n\t\t\t\tesas2r_debug(\"FI_ACT_UPSZ size %d\", size);\n\t\t\t\treturn size;\n\t\t\t} else {\n\t\t\t\tesas2r_debug(\"invalid action %d\",\n\t\t\t\t\t     a->firmware.header.action);\n\t\t\t\treturn -ENOSYS;\n\t\t\t}\n\t\t}\n\n\t\tif (count + off > length)\n\t\t\tcount = length - off;\n\n\t\tif (count < 0)\n\t\t\treturn 0;\n\n\t\tif (!a->firmware.data) {\n\t\t\tesas2r_debug(\n\t\t\t\t\"read: nonzero offset but no buffer available!\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tesas2r_debug(\"esas2r_read_fw: off %d count %d length %d \", off,\n\t\t\t     count,\n\t\t\t     length);\n\n\t\tmemcpy(buf, &a->firmware.data[off], count);\n\n\t\t \n\n\t\tif (length <= off + count) {\n\t\t\tesas2r_debug(\"esas2r_read_fw: freeing buffer!\");\n\n\t\t\tfree_fw_buffers(a);\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tesas2r_trace_exit();\n\tesas2r_debug(\"esas2r_read_fw: invalid firmware state %d\",\n\t\t     a->firmware.state);\n\n\treturn -EINVAL;\n}\n\n \nint esas2r_write_fw(struct esas2r_adapter *a, const char *buf, long off,\n\t\t    int count)\n{\n\tu32 length;\n\n\tif (off == 0) {\n\t\tstruct esas2r_flash_img *header =\n\t\t\t(struct esas2r_flash_img *)buf;\n\n\t\t \n\n\t\tint min_size = sizeof(struct esas2r_flash_img_v0);\n\n\t\ta->firmware.state = FW_INVALID_ST;\n\n\t\t \n\n\t\tif (count < 4\n\t\t    ||  header->fi_version > FI_VERSION_1) {\n\t\t\tesas2r_debug(\n\t\t\t\t\"esas2r_write_fw: short header or invalid version\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\n\t\tif (header->fi_version == FI_VERSION_1)\n\t\t\tmin_size = sizeof(struct esas2r_flash_img);\n\n\t\t \n\t\tif (count < min_size) {\n\t\t\tesas2r_debug(\"esas2r_write_fw: short header, aborting\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tlength = header->length;\n\n\t\tif (length > 1024 * 1024) {\n\t\t\tesas2r_debug(\n\t\t\t\t\"esas2r_write_fw: hosed, length %d  fi_version %d\",\n\t\t\t\tlength, header->fi_version);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\n\t\tif (header->action == FI_ACT_DOWN) {\n\t\t\tif (!allocate_fw_buffers(a, length))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t \n\t\t\tmemcpy(&a->firmware.header,\n\t\t\t       buf,\n\t\t\t       sizeof(*header));\n\t\t} else if (header->action == FI_ACT_UP\n\t\t\t   ||  header->action == FI_ACT_UPSZ) {\n\t\t\t \n\t\t\tmemcpy(&a->firmware.header,\n\t\t\t       buf,\n\t\t\t       sizeof(*header));\n\n\t\t\ta->firmware.state = FW_COMMAND_ST;\n\n\t\t\tesas2r_debug(\n\t\t\t\t\"esas2r_write_fw: COMMAND, count %d, action %d \",\n\t\t\t\tcount, header->action);\n\n\t\t\t \n\n\t\t\treturn count;\n\t\t} else {\n\t\t\tesas2r_debug(\"esas2r_write_fw: invalid action %d \",\n\t\t\t\t     a->firmware.header.action);\n\t\t\treturn -ENOSYS;\n\t\t}\n\t} else {\n\t\tlength = a->firmware.header.length;\n\t}\n\n\t \n\n\tif (off + count > length)\n\t\tcount = length - off;\n\n\tif (count > 0) {\n\t\tesas2r_debug(\"esas2r_write_fw: off %d count %d length %d\", off,\n\t\t\t     count,\n\t\t\t     length);\n\n\t\t \n\t\tif (a->firmware.header.action == FI_ACT_UP)\n\t\t\treturn count;\n\n\t\tif (!a->firmware.data) {\n\t\t\tesas2r_debug(\n\t\t\t\t\"write: nonzero offset but no buffer available!\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemcpy(&a->firmware.data[off], buf, count);\n\n\t\tif (length == off + count) {\n\t\t\tdo_fm_api(a,\n\t\t\t\t  (struct esas2r_flash_img *)a->firmware.data);\n\n\t\t\t \n\t\t\tmemcpy(&a->firmware.header,\n\t\t\t       a->firmware.data,\n\t\t\t       sizeof(a->firmware.header));\n\n\t\t\ta->firmware.state = FW_STATUS_ST;\n\n\t\t\tesas2r_debug(\"write completed\");\n\n\t\t\t \n\t\t\tfree_fw_buffers(a);\n\t\t}\n\t}\n\n\treturn count;\n}\n\n \nstatic void vda_complete_req(struct esas2r_adapter *a,\n\t\t\t     struct esas2r_request *rq)\n{\n\ta->vda_command_done = 1;\n\twake_up_interruptible(&a->vda_waiter);\n}\n\n \nstatic u32 get_physaddr_vda(struct esas2r_sg_context *sgc, u64 *addr)\n{\n\tstruct esas2r_adapter *a = (struct esas2r_adapter *)sgc->adapter;\n\tint offset = (u8 *)sgc->cur_offset - (u8 *)a->vda_buffer;\n\n\t(*addr) = a->ppvda_buffer + offset;\n\treturn VDA_MAX_BUFFER_SIZE - offset;\n}\n\n \nint esas2r_read_vda(struct esas2r_adapter *a, char *buf, long off, int count)\n{\n\tif (!a->vda_buffer)\n\t\treturn -ENOMEM;\n\n\tif (off == 0) {\n\t\tstruct esas2r_request *rq;\n\t\tstruct atto_ioctl_vda *vi =\n\t\t\t(struct atto_ioctl_vda *)a->vda_buffer;\n\t\tstruct esas2r_sg_context sgc;\n\t\tbool wait_for_completion;\n\n\t\t \n\n\t\t \n\t\trq = esas2r_alloc_request(a);\n\t\tif (rq == NULL) {\n\t\t\tesas2r_debug(\"esas2r_read_vda: out of requests\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\trq->comp_cb = vda_complete_req;\n\n\t\tsgc.first_req = rq;\n\t\tsgc.adapter = a;\n\t\tsgc.cur_offset = a->vda_buffer + VDA_BUFFER_HEADER_SZ;\n\t\tsgc.get_phys_addr = (PGETPHYSADDR)get_physaddr_vda;\n\n\t\ta->vda_command_done = 0;\n\n\t\twait_for_completion =\n\t\t\tesas2r_process_vda_ioctl(a, vi, rq, &sgc);\n\n\t\tif (wait_for_completion) {\n\t\t\t \n\n\t\t\twhile (!a->vda_command_done)\n\t\t\t\twait_event_interruptible(a->vda_waiter,\n\t\t\t\t\t\t\t a->vda_command_done);\n\t\t}\n\n\t\tesas2r_free_request(a, (struct esas2r_request *)rq);\n\t}\n\n\tif (off > VDA_MAX_BUFFER_SIZE)\n\t\treturn 0;\n\n\tif (count + off > VDA_MAX_BUFFER_SIZE)\n\t\tcount = VDA_MAX_BUFFER_SIZE - off;\n\n\tif (count < 0)\n\t\treturn 0;\n\n\tmemcpy(buf, a->vda_buffer + off, count);\n\n\treturn count;\n}\n\n \nint esas2r_write_vda(struct esas2r_adapter *a, const char *buf, long off,\n\t\t     int count)\n{\n\t \n\n\tif (!a->vda_buffer) {\n\t\tdma_addr_t dma_addr;\n\t\ta->vda_buffer = dma_alloc_coherent(&a->pcid->dev,\n\t\t\t\t\t\t   (size_t)\n\t\t\t\t\t\t   VDA_MAX_BUFFER_SIZE,\n\t\t\t\t\t\t   &dma_addr,\n\t\t\t\t\t\t   GFP_KERNEL);\n\n\t\ta->ppvda_buffer = dma_addr;\n\t}\n\n\tif (!a->vda_buffer)\n\t\treturn -ENOMEM;\n\n\tif (off > VDA_MAX_BUFFER_SIZE)\n\t\treturn 0;\n\n\tif (count + off > VDA_MAX_BUFFER_SIZE)\n\t\tcount = VDA_MAX_BUFFER_SIZE - off;\n\n\tif (count < 1)\n\t\treturn 0;\n\n\tmemcpy(a->vda_buffer + off, buf, count);\n\n\treturn count;\n}\n\n \nstatic void fs_api_complete_req(struct esas2r_adapter *a,\n\t\t\t\tstruct esas2r_request *rq)\n{\n\ta->fs_api_command_done = 1;\n\n\twake_up_interruptible(&a->fs_api_waiter);\n}\n\n \nstatic u32 get_physaddr_fs_api(struct esas2r_sg_context *sgc, u64 *addr)\n{\n\tstruct esas2r_adapter *a = (struct esas2r_adapter *)sgc->adapter;\n\tstruct esas2r_ioctl_fs *fs =\n\t\t(struct esas2r_ioctl_fs *)a->fs_api_buffer;\n\tu32 offset = (u8 *)sgc->cur_offset - (u8 *)fs;\n\n\t(*addr) = a->ppfs_api_buffer + offset;\n\n\treturn a->fs_api_buffer_size - offset;\n}\n\n \nint esas2r_read_fs(struct esas2r_adapter *a, char *buf, long off, int count)\n{\n\tif (!a->fs_api_buffer)\n\t\treturn -ENOMEM;\n\n\tif (off == 0) {\n\t\tstruct esas2r_request *rq;\n\t\tstruct esas2r_sg_context sgc;\n\t\tstruct esas2r_ioctl_fs *fs =\n\t\t\t(struct esas2r_ioctl_fs *)a->fs_api_buffer;\n\n\t\t \n\t\tif (mutex_lock_interruptible(&a->fs_api_mutex)) {\nbusy:\n\t\t\tfs->status = ATTO_STS_OUT_OF_RSRC;\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\n\t\trq = esas2r_alloc_request(a);\n\t\tif (rq == NULL) {\n\t\t\tesas2r_debug(\"esas2r_read_fs: out of requests\");\n\t\t\tmutex_unlock(&a->fs_api_mutex);\n\t\t\tgoto busy;\n\t\t}\n\n\t\trq->comp_cb = fs_api_complete_req;\n\n\t\t \n\n\t\tsgc.cur_offset = fs->data;\n\t\tsgc.get_phys_addr = (PGETPHYSADDR)get_physaddr_fs_api;\n\n\t\ta->fs_api_command_done = 0;\n\n\t\tif (!esas2r_process_fs_ioctl(a, fs, rq, &sgc)) {\n\t\t\tif (fs->status == ATTO_STS_OUT_OF_RSRC)\n\t\t\t\tcount = -EBUSY;\n\n\t\t\tgoto dont_wait;\n\t\t}\n\n\t\t \n\n\t\twhile (!a->fs_api_command_done)\n\t\t\twait_event_interruptible(a->fs_api_waiter,\n\t\t\t\t\t\t a->fs_api_command_done);\n\t\t;\ndont_wait:\n\t\t \n\t\tmutex_unlock(&a->fs_api_mutex);\n\t\tesas2r_free_request(a, (struct esas2r_request *)rq);\n\n\t\t \n\t\tif (count < 0)\n\t\t\treturn count;\n\t}\n\n\tif (off > a->fs_api_buffer_size)\n\t\treturn 0;\n\n\tif (count + off > a->fs_api_buffer_size)\n\t\tcount = a->fs_api_buffer_size - off;\n\n\tif (count < 0)\n\t\treturn 0;\n\n\tmemcpy(buf, a->fs_api_buffer + off, count);\n\n\treturn count;\n}\n\n \nint esas2r_write_fs(struct esas2r_adapter *a, const char *buf, long off,\n\t\t    int count)\n{\n\tif (off == 0) {\n\t\tstruct esas2r_ioctl_fs *fs = (struct esas2r_ioctl_fs *)buf;\n\t\tu32 length = fs->command.length + offsetof(\n\t\t\tstruct esas2r_ioctl_fs,\n\t\t\tdata);\n\n\t\t \n\n\t\tif (fs->command.command == ESAS2R_FS_CMD_BEGINW)\n\t\t\tlength = offsetof(struct esas2r_ioctl_fs, data);\n\n\t\t \n\n\t\tif (count < offsetof(struct esas2r_ioctl_fs, data))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (a->fs_api_buffer) {\n\t\t\tif (a->fs_api_buffer_size < length) {\n\t\t\t\t \n\t\t\t\tdma_free_coherent(&a->pcid->dev,\n\t\t\t\t\t\t  (size_t)a->fs_api_buffer_size,\n\t\t\t\t\t\t  a->fs_api_buffer,\n\t\t\t\t\t\t  (dma_addr_t)a->ppfs_api_buffer);\n\n\t\t\t\tgoto re_allocate_buffer;\n\t\t\t}\n\t\t} else {\nre_allocate_buffer:\n\t\t\ta->fs_api_buffer_size = length;\n\n\t\t\ta->fs_api_buffer = dma_alloc_coherent(&a->pcid->dev,\n\t\t\t\t\t\t\t      (size_t)a->fs_api_buffer_size,\n\t\t\t\t\t\t\t      (dma_addr_t *)&a->ppfs_api_buffer,\n\t\t\t\t\t\t\t      GFP_KERNEL);\n\t\t}\n\t}\n\n\tif (!a->fs_api_buffer)\n\t\treturn -ENOMEM;\n\n\tif (off > a->fs_api_buffer_size)\n\t\treturn 0;\n\n\tif (count + off > a->fs_api_buffer_size)\n\t\tcount = a->fs_api_buffer_size - off;\n\n\tif (count < 1)\n\t\treturn 0;\n\n\tmemcpy(a->fs_api_buffer + off, buf, count);\n\n\treturn count;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}