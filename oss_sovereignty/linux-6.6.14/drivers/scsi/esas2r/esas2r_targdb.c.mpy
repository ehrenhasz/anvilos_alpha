{
  "module_name": "esas2r_targdb.c",
  "hash_id": "0d470c8c8faac1d6d6613de4c5c8540b51ffcaae3df8065a596e8af4d04544b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/esas2r/esas2r_targdb.c",
  "human_readable_source": " \n\n#include \"esas2r.h\"\n\nvoid esas2r_targ_db_initialize(struct esas2r_adapter *a)\n{\n\tstruct esas2r_target *t;\n\n\tfor (t = a->targetdb; t < a->targetdb_end; t++) {\n\t\tmemset(t, 0, sizeof(struct esas2r_target));\n\n\t\tt->target_state = TS_NOT_PRESENT;\n\t\tt->buffered_target_state = TS_NOT_PRESENT;\n\t\tt->new_target_state = TS_INVALID;\n\t}\n}\n\nvoid esas2r_targ_db_remove_all(struct esas2r_adapter *a, bool notify)\n{\n\tstruct esas2r_target *t;\n\tunsigned long flags;\n\n\tfor (t = a->targetdb; t < a->targetdb_end; t++) {\n\t\tif (t->target_state != TS_PRESENT)\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&a->mem_lock, flags);\n\t\tesas2r_targ_db_remove(a, t);\n\t\tspin_unlock_irqrestore(&a->mem_lock, flags);\n\n\t\tif (notify) {\n\t\t\tesas2r_trace(\"remove id:%d\", esas2r_targ_get_id(t,\n\t\t\t\t\t\t\t\t\ta));\n\t\t\tesas2r_target_state_changed(a, esas2r_targ_get_id(t,\n\t\t\t\t\t\t\t\t\t  a),\n\t\t\t\t\t\t    TS_NOT_PRESENT);\n\t\t}\n\t}\n}\n\nvoid esas2r_targ_db_report_changes(struct esas2r_adapter *a)\n{\n\tstruct esas2r_target *t;\n\tunsigned long flags;\n\n\tesas2r_trace_enter();\n\n\tif (test_bit(AF_DISC_PENDING, &a->flags)) {\n\t\tesas2r_trace_exit();\n\t\treturn;\n\t}\n\n\tfor (t = a->targetdb; t < a->targetdb_end; t++) {\n\t\tu8 state = TS_INVALID;\n\n\t\tspin_lock_irqsave(&a->mem_lock, flags);\n\t\tif (t->buffered_target_state != t->target_state)\n\t\t\tstate = t->buffered_target_state = t->target_state;\n\n\t\tspin_unlock_irqrestore(&a->mem_lock, flags);\n\t\tif (state != TS_INVALID) {\n\t\t\tesas2r_trace(\"targ_db_report_changes:%d\",\n\t\t\t\t     esas2r_targ_get_id(\n\t\t\t\t\t     t,\n\t\t\t\t\t     a));\n\t\t\tesas2r_trace(\"state:%d\", state);\n\n\t\t\tesas2r_target_state_changed(a,\n\t\t\t\t\t\t    esas2r_targ_get_id(t,\n\t\t\t\t\t\t\t\t       a),\n\t\t\t\t\t\t    state);\n\t\t}\n\t}\n\n\tesas2r_trace_exit();\n}\n\nstruct esas2r_target *esas2r_targ_db_add_raid(struct esas2r_adapter *a,\n\t\t\t\t\t      struct esas2r_disc_context *\n\t\t\t\t\t      dc)\n{\n\tstruct esas2r_target *t;\n\n\tesas2r_trace_enter();\n\n\tif (dc->curr_virt_id >= ESAS2R_MAX_TARGETS) {\n\t\tesas2r_bugon();\n\t\tesas2r_trace_exit();\n\t\treturn NULL;\n\t}\n\n\tt = a->targetdb + dc->curr_virt_id;\n\n\tif (t->target_state == TS_PRESENT) {\n\t\tesas2r_trace_exit();\n\t\treturn NULL;\n\t}\n\n\tesas2r_hdebug(\"add RAID %s, T:%d\", dc->raid_grp_name,\n\t\t      esas2r_targ_get_id(\n\t\t\t      t,\n\t\t\t      a));\n\n\tif (dc->interleave == 0\n\t    || dc->block_size  == 0) {\n\t\t \n\n\t\tesas2r_hdebug(\"invalid RAID group dimensions\");\n\n\t\tesas2r_trace_exit();\n\n\t\treturn NULL;\n\t}\n\n\tt->block_size = dc->block_size;\n\tt->inter_byte = dc->interleave;\n\tt->inter_block = dc->interleave / dc->block_size;\n\tt->virt_targ_id = dc->curr_virt_id;\n\tt->phys_targ_id = ESAS2R_TARG_ID_INV;\n\n\tt->flags &= ~TF_PASS_THRU;\n\tt->flags |= TF_USED;\n\n\tt->identifier_len = 0;\n\n\tt->target_state = TS_PRESENT;\n\n\treturn t;\n}\n\nstruct esas2r_target *esas2r_targ_db_add_pthru(struct esas2r_adapter *a,\n\t\t\t\t\t       struct esas2r_disc_context *dc,\n\t\t\t\t\t       u8 *ident,\n\t\t\t\t\t       u8 ident_len)\n{\n\tstruct esas2r_target *t;\n\n\tesas2r_trace_enter();\n\n\tif (dc->curr_virt_id >= ESAS2R_MAX_TARGETS) {\n\t\tesas2r_bugon();\n\t\tesas2r_trace_exit();\n\t\treturn NULL;\n\t}\n\n\t \n\n\tt = esas2r_targ_db_find_by_ident(a, ident, ident_len);\n\n\tif (t == NULL) {\n\t\tt = a->targetdb + dc->curr_virt_id;\n\n\t\tif (ident_len > sizeof(t->identifier)\n\t\t    || t->target_state == TS_PRESENT) {\n\t\t\tesas2r_trace_exit();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tesas2r_hdebug(\"add PT; T:%d, V:%d, P:%d\", esas2r_targ_get_id(t, a),\n\t\t      dc->curr_virt_id,\n\t\t      dc->curr_phys_id);\n\n\tt->block_size = 0;\n\tt->inter_byte = 0;\n\tt->inter_block = 0;\n\tt->virt_targ_id = dc->curr_virt_id;\n\tt->phys_targ_id = dc->curr_phys_id;\n\tt->identifier_len = ident_len;\n\n\tmemcpy(t->identifier, ident, ident_len);\n\n\tt->flags |= TF_PASS_THRU | TF_USED;\n\n\tt->target_state = TS_PRESENT;\n\n\treturn t;\n}\n\nvoid esas2r_targ_db_remove(struct esas2r_adapter *a, struct esas2r_target *t)\n{\n\tesas2r_trace_enter();\n\n\tt->target_state = TS_NOT_PRESENT;\n\n\tesas2r_trace(\"remove id:%d\", esas2r_targ_get_id(t, a));\n\n\tesas2r_trace_exit();\n}\n\nstruct esas2r_target *esas2r_targ_db_find_by_sas_addr(struct esas2r_adapter *a,\n\t\t\t\t\t\t      u64 *sas_addr)\n{\n\tstruct esas2r_target *t;\n\n\tfor (t = a->targetdb; t < a->targetdb_end; t++)\n\t\tif (t->sas_addr == *sas_addr)\n\t\t\treturn t;\n\n\treturn NULL;\n}\n\nstruct esas2r_target *esas2r_targ_db_find_by_ident(struct esas2r_adapter *a,\n\t\t\t\t\t\t   void *identifier,\n\t\t\t\t\t\t   u8 ident_len)\n{\n\tstruct esas2r_target *t;\n\n\tfor (t = a->targetdb; t < a->targetdb_end; t++) {\n\t\tif (ident_len == t->identifier_len\n\t\t    && memcmp(&t->identifier[0], identifier,\n\t\t\t      ident_len) == 0)\n\t\t\treturn t;\n\t}\n\n\treturn NULL;\n}\n\nu16 esas2r_targ_db_find_next_present(struct esas2r_adapter *a, u16 target_id)\n{\n\tu16 id = target_id + 1;\n\n\twhile (id < ESAS2R_MAX_TARGETS) {\n\t\tstruct esas2r_target *t = a->targetdb + id;\n\n\t\tif (t->target_state == TS_PRESENT)\n\t\t\tbreak;\n\n\t\tid++;\n\t}\n\n\treturn id;\n}\n\nstruct esas2r_target *esas2r_targ_db_find_by_virt_id(struct esas2r_adapter *a,\n\t\t\t\t\t\t     u16 virt_id)\n{\n\tstruct esas2r_target *t;\n\n\tfor (t = a->targetdb; t < a->targetdb_end; t++) {\n\t\tif (t->target_state != TS_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (t->virt_targ_id == virt_id)\n\t\t\treturn t;\n\t}\n\n\treturn NULL;\n}\n\nu16 esas2r_targ_db_get_tgt_cnt(struct esas2r_adapter *a)\n{\n\tu16 devcnt = 0;\n\tstruct esas2r_target *t;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&a->mem_lock, flags);\n\tfor (t = a->targetdb; t < a->targetdb_end; t++)\n\t\tif (t->target_state == TS_PRESENT)\n\t\t\tdevcnt++;\n\n\tspin_unlock_irqrestore(&a->mem_lock, flags);\n\n\treturn devcnt;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}