{
  "module_name": "esas2r_vda.c",
  "hash_id": "13d3ad3bbe635f5a736e5f1903441288cf067214ca0761f51c8c23a5222327dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/esas2r/esas2r_vda.c",
  "human_readable_source": " \n \n \n \n\n#include \"esas2r.h\"\n\nstatic u8 esas2r_vdaioctl_versions[] = {\n\tATTO_VDA_VER_UNSUPPORTED,\n\tATTO_VDA_FLASH_VER,\n\tATTO_VDA_VER_UNSUPPORTED,\n\tATTO_VDA_VER_UNSUPPORTED,\n\tATTO_VDA_CLI_VER,\n\tATTO_VDA_VER_UNSUPPORTED,\n\tATTO_VDA_CFG_VER,\n\tATTO_VDA_MGT_VER,\n\tATTO_VDA_GSV_VER\n};\n\nstatic void clear_vda_request(struct esas2r_request *rq);\n\nstatic void esas2r_complete_vda_ioctl(struct esas2r_adapter *a,\n\t\t\t\t      struct esas2r_request *rq);\n\n \nbool esas2r_process_vda_ioctl(struct esas2r_adapter *a,\n\t\t\t      struct atto_ioctl_vda *vi,\n\t\t\t      struct esas2r_request *rq,\n\t\t\t      struct esas2r_sg_context *sgc)\n{\n\tu32 datalen = 0;\n\tstruct atto_vda_sge *firstsg = NULL;\n\tu8 vercnt = (u8)ARRAY_SIZE(esas2r_vdaioctl_versions);\n\n\tvi->status = ATTO_STS_SUCCESS;\n\tvi->vda_status = RS_PENDING;\n\n\tif (vi->function >= vercnt) {\n\t\tvi->status = ATTO_STS_INV_FUNC;\n\t\treturn false;\n\t}\n\n\tif (vi->version > esas2r_vdaioctl_versions[vi->function]) {\n\t\tvi->status = ATTO_STS_INV_VERSION;\n\t\treturn false;\n\t}\n\n\tif (test_bit(AF_DEGRADED_MODE, &a->flags)) {\n\t\tvi->status = ATTO_STS_DEGRADED;\n\t\treturn false;\n\t}\n\n\tif (vi->function != VDA_FUNC_SCSI)\n\t\tclear_vda_request(rq);\n\n\trq->vrq->scsi.function = vi->function;\n\trq->interrupt_cb = esas2r_complete_vda_ioctl;\n\trq->interrupt_cx = vi;\n\n\tswitch (vi->function) {\n\tcase VDA_FUNC_FLASH:\n\n\t\tif (vi->cmd.flash.sub_func != VDA_FLASH_FREAD\n\t\t    && vi->cmd.flash.sub_func != VDA_FLASH_FWRITE\n\t\t    && vi->cmd.flash.sub_func != VDA_FLASH_FINFO) {\n\t\t\tvi->status = ATTO_STS_INV_FUNC;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (vi->cmd.flash.sub_func != VDA_FLASH_FINFO)\n\t\t\tdatalen = vi->data_length;\n\n\t\trq->vrq->flash.length = cpu_to_le32(datalen);\n\t\trq->vrq->flash.sub_func = vi->cmd.flash.sub_func;\n\n\t\tmemcpy(rq->vrq->flash.data.file.file_name,\n\t\t       vi->cmd.flash.data.file.file_name,\n\t\t       sizeof(vi->cmd.flash.data.file.file_name));\n\n\t\tfirstsg = rq->vrq->flash.data.file.sge;\n\t\tbreak;\n\n\tcase VDA_FUNC_CLI:\n\n\t\tdatalen = vi->data_length;\n\n\t\trq->vrq->cli.cmd_rsp_len =\n\t\t\tcpu_to_le32(vi->cmd.cli.cmd_rsp_len);\n\t\trq->vrq->cli.length = cpu_to_le32(datalen);\n\n\t\tfirstsg = rq->vrq->cli.sge;\n\t\tbreak;\n\n\tcase VDA_FUNC_MGT:\n\t{\n\t\tu8 *cmdcurr_offset = sgc->cur_offset\n\t\t\t\t     - offsetof(struct atto_ioctl_vda, data)\n\t\t\t\t     + offsetof(struct atto_ioctl_vda, cmd)\n\t\t\t\t     + offsetof(struct atto_ioctl_vda_mgt_cmd,\n\t\t\t\t\t\tdata);\n\t\t \n\n\t\tif (vi->data_length) {\n\t\t\tu32 payldlen = 0;\n\n\t\t\tif (vi->cmd.mgt.mgt_func == VDAMGT_DEV_HEALTH_REQ\n\t\t\t    || vi->cmd.mgt.mgt_func == VDAMGT_DEV_METRICS) {\n\t\t\t\trq->vrq->mgt.payld_sglst_offset =\n\t\t\t\t\t(u8)offsetof(struct atto_vda_mgmt_req,\n\t\t\t\t\t\t     payld_sge);\n\n\t\t\t\tpayldlen = vi->data_length;\n\t\t\t\tdatalen = vi->cmd.mgt.data_length;\n\t\t\t} else if (vi->cmd.mgt.mgt_func == VDAMGT_DEV_INFO2\n\t\t\t\t   || vi->cmd.mgt.mgt_func ==\n\t\t\t\t   VDAMGT_DEV_INFO2_BYADDR) {\n\t\t\t\tdatalen = vi->data_length;\n\t\t\t\tcmdcurr_offset = sgc->cur_offset;\n\t\t\t} else {\n\t\t\t\tvi->status = ATTO_STS_INV_PARAM;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t \n\t\t\trq->vrq->mgt.length = cpu_to_le32(datalen);\n\n\t\t\tif (payldlen) {\n\t\t\t\trq->vrq->mgt.payld_length =\n\t\t\t\t\tcpu_to_le32(payldlen);\n\n\t\t\t\tesas2r_sgc_init(sgc, a, rq,\n\t\t\t\t\t\trq->vrq->mgt.payld_sge);\n\t\t\t\tsgc->length = payldlen;\n\n\t\t\t\tif (!esas2r_build_sg_list(a, rq, sgc)) {\n\t\t\t\t\tvi->status = ATTO_STS_OUT_OF_RSRC;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdatalen = vi->cmd.mgt.data_length;\n\n\t\t\trq->vrq->mgt.length = cpu_to_le32(datalen);\n\t\t}\n\n\t\t \n\t\tfirstsg = rq->vrq->mgt.sge;\n\t\tsgc->cur_offset = cmdcurr_offset;\n\n\t\t \n\t\trq->vrq->mgt.mgt_func = vi->cmd.mgt.mgt_func;\n\t\trq->vrq->mgt.scan_generation = vi->cmd.mgt.scan_generation;\n\t\trq->vrq->mgt.dev_index =\n\t\t\tcpu_to_le32(vi->cmd.mgt.dev_index);\n\n\t\tesas2r_nuxi_mgt_data(rq->vrq->mgt.mgt_func, &vi->cmd.mgt.data);\n\t\tbreak;\n\t}\n\n\tcase VDA_FUNC_CFG:\n\n\t\tif (vi->data_length\n\t\t    || vi->cmd.cfg.data_length == 0) {\n\t\t\tvi->status = ATTO_STS_INV_PARAM;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (vi->cmd.cfg.cfg_func == VDA_CFG_INIT) {\n\t\t\tvi->status = ATTO_STS_INV_FUNC;\n\t\t\treturn false;\n\t\t}\n\n\t\trq->vrq->cfg.sub_func = vi->cmd.cfg.cfg_func;\n\t\trq->vrq->cfg.length = cpu_to_le32(vi->cmd.cfg.data_length);\n\n\t\tif (vi->cmd.cfg.cfg_func == VDA_CFG_GET_INIT) {\n\t\t\tmemcpy(&rq->vrq->cfg.data,\n\t\t\t       &vi->cmd.cfg.data,\n\t\t\t       vi->cmd.cfg.data_length);\n\n\t\t\tesas2r_nuxi_cfg_data(rq->vrq->cfg.sub_func,\n\t\t\t\t\t     &rq->vrq->cfg.data);\n\t\t} else {\n\t\t\tvi->status = ATTO_STS_INV_FUNC;\n\n\t\t\treturn false;\n\t\t}\n\n\t\tbreak;\n\n\tcase VDA_FUNC_GSV:\n\n\t\tvi->cmd.gsv.rsp_len = vercnt;\n\n\t\tmemcpy(vi->cmd.gsv.version_info, esas2r_vdaioctl_versions,\n\t\t       vercnt);\n\n\t\tvi->vda_status = RS_SUCCESS;\n\t\tbreak;\n\n\tdefault:\n\n\t\tvi->status = ATTO_STS_INV_FUNC;\n\t\treturn false;\n\t}\n\n\tif (datalen) {\n\t\tesas2r_sgc_init(sgc, a, rq, firstsg);\n\t\tsgc->length = datalen;\n\n\t\tif (!esas2r_build_sg_list(a, rq, sgc)) {\n\t\t\tvi->status = ATTO_STS_OUT_OF_RSRC;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tesas2r_start_request(a, rq);\n\n\treturn true;\n}\n\nstatic void esas2r_complete_vda_ioctl(struct esas2r_adapter *a,\n\t\t\t\t      struct esas2r_request *rq)\n{\n\tstruct atto_ioctl_vda *vi = (struct atto_ioctl_vda *)rq->interrupt_cx;\n\n\tvi->vda_status = rq->req_stat;\n\n\tswitch (vi->function) {\n\tcase VDA_FUNC_FLASH:\n\n\t\tif (vi->cmd.flash.sub_func == VDA_FLASH_FINFO\n\t\t    || vi->cmd.flash.sub_func == VDA_FLASH_FREAD)\n\t\t\tvi->cmd.flash.data.file.file_size =\n\t\t\t\tle32_to_cpu(rq->func_rsp.flash_rsp.file_size);\n\n\t\tbreak;\n\n\tcase VDA_FUNC_MGT:\n\n\t\tvi->cmd.mgt.scan_generation =\n\t\t\trq->func_rsp.mgt_rsp.scan_generation;\n\t\tvi->cmd.mgt.dev_index = le16_to_cpu(\n\t\t\trq->func_rsp.mgt_rsp.dev_index);\n\n\t\tif (vi->data_length == 0)\n\t\t\tvi->cmd.mgt.data_length =\n\t\t\t\tle32_to_cpu(rq->func_rsp.mgt_rsp.length);\n\n\t\tesas2r_nuxi_mgt_data(rq->vrq->mgt.mgt_func, &vi->cmd.mgt.data);\n\t\tbreak;\n\n\tcase VDA_FUNC_CFG:\n\n\t\tif (vi->cmd.cfg.cfg_func == VDA_CFG_GET_INIT) {\n\t\t\tstruct atto_ioctl_vda_cfg_cmd *cfg = &vi->cmd.cfg;\n\t\t\tstruct atto_vda_cfg_rsp *rsp = &rq->func_rsp.cfg_rsp;\n\t\t\tchar buf[sizeof(cfg->data.init.fw_release) + 1];\n\n\t\t\tcfg->data_length =\n\t\t\t\tcpu_to_le32(sizeof(struct atto_vda_cfg_init));\n\t\t\tcfg->data.init.vda_version =\n\t\t\t\tle32_to_cpu(rsp->vda_version);\n\t\t\tcfg->data.init.fw_build = rsp->fw_build;\n\n\t\t\tsnprintf(buf, sizeof(buf), \"%1.1u.%2.2u\",\n\t\t\t\t (int)LOBYTE(le16_to_cpu(rsp->fw_release)),\n\t\t\t\t (int)HIBYTE(le16_to_cpu(rsp->fw_release)));\n\n\t\t\tmemcpy(&cfg->data.init.fw_release, buf,\n\t\t\t       sizeof(cfg->data.init.fw_release));\n\n\t\t\tif (LOWORD(LOBYTE(cfg->data.init.fw_build)) == 'A')\n\t\t\t\tcfg->data.init.fw_version =\n\t\t\t\t\tcfg->data.init.fw_build;\n\t\t\telse\n\t\t\t\tcfg->data.init.fw_version =\n\t\t\t\t\tcfg->data.init.fw_release;\n\t\t} else {\n\t\t\tesas2r_nuxi_cfg_data(rq->vrq->cfg.sub_func,\n\t\t\t\t\t     &vi->cmd.cfg.data);\n\t\t}\n\n\t\tbreak;\n\n\tcase VDA_FUNC_CLI:\n\n\t\tvi->cmd.cli.cmd_rsp_len =\n\t\t\tle32_to_cpu(rq->func_rsp.cli_rsp.cmd_rsp_len);\n\t\tbreak;\n\n\tdefault:\n\n\t\tbreak;\n\t}\n}\n\n \nvoid esas2r_build_flash_req(struct esas2r_adapter *a,\n\t\t\t    struct esas2r_request *rq,\n\t\t\t    u8 sub_func,\n\t\t\t    u8 cksum,\n\t\t\t    u32 addr,\n\t\t\t    u32 length)\n{\n\tstruct atto_vda_flash_req *vrq = &rq->vrq->flash;\n\n\tclear_vda_request(rq);\n\n\trq->vrq->scsi.function = VDA_FUNC_FLASH;\n\n\tif (sub_func == VDA_FLASH_BEGINW\n\t    || sub_func == VDA_FLASH_WRITE\n\t    || sub_func == VDA_FLASH_READ)\n\t\tvrq->sg_list_offset = (u8)offsetof(struct atto_vda_flash_req,\n\t\t\t\t\t\t   data.sge);\n\n\tvrq->length = cpu_to_le32(length);\n\tvrq->flash_addr = cpu_to_le32(addr);\n\tvrq->checksum = cksum;\n\tvrq->sub_func = sub_func;\n}\n\n \nvoid esas2r_build_mgt_req(struct esas2r_adapter *a,\n\t\t\t  struct esas2r_request *rq,\n\t\t\t  u8 sub_func,\n\t\t\t  u8 scan_gen,\n\t\t\t  u16 dev_index,\n\t\t\t  u32 length,\n\t\t\t  void *data)\n{\n\tstruct atto_vda_mgmt_req *vrq = &rq->vrq->mgt;\n\n\tclear_vda_request(rq);\n\n\trq->vrq->scsi.function = VDA_FUNC_MGT;\n\n\tvrq->mgt_func = sub_func;\n\tvrq->scan_generation = scan_gen;\n\tvrq->dev_index = cpu_to_le16(dev_index);\n\tvrq->length = cpu_to_le32(length);\n\n\tif (vrq->length) {\n\t\tif (test_bit(AF_LEGACY_SGE_MODE, &a->flags)) {\n\t\t\tvrq->sg_list_offset = (u8)offsetof(\n\t\t\t\tstruct atto_vda_mgmt_req, sge);\n\n\t\t\tvrq->sge[0].length = cpu_to_le32(SGE_LAST | length);\n\t\t\tvrq->sge[0].address = cpu_to_le64(\n\t\t\t\trq->vrq_md->phys_addr +\n\t\t\t\tsizeof(union atto_vda_req));\n\t\t} else {\n\t\t\tvrq->sg_list_offset = (u8)offsetof(\n\t\t\t\tstruct atto_vda_mgmt_req, prde);\n\n\t\t\tvrq->prde[0].ctl_len = cpu_to_le32(length);\n\t\t\tvrq->prde[0].address = cpu_to_le64(\n\t\t\t\trq->vrq_md->phys_addr +\n\t\t\t\tsizeof(union atto_vda_req));\n\t\t}\n\t}\n\n\tif (data) {\n\t\tesas2r_nuxi_mgt_data(sub_func, data);\n\n\t\tmemcpy(&rq->vda_rsp_data->mgt_data.data.bytes[0], data,\n\t\t       length);\n\t}\n}\n\n \nvoid esas2r_build_ae_req(struct esas2r_adapter *a, struct esas2r_request *rq)\n{\n\tstruct atto_vda_ae_req *vrq = &rq->vrq->ae;\n\n\tclear_vda_request(rq);\n\n\trq->vrq->scsi.function = VDA_FUNC_AE;\n\n\tvrq->length = cpu_to_le32(sizeof(struct atto_vda_ae_data));\n\n\tif (test_bit(AF_LEGACY_SGE_MODE, &a->flags)) {\n\t\tvrq->sg_list_offset =\n\t\t\t(u8)offsetof(struct atto_vda_ae_req, sge);\n\t\tvrq->sge[0].length = cpu_to_le32(SGE_LAST | vrq->length);\n\t\tvrq->sge[0].address = cpu_to_le64(\n\t\t\trq->vrq_md->phys_addr +\n\t\t\tsizeof(union atto_vda_req));\n\t} else {\n\t\tvrq->sg_list_offset = (u8)offsetof(struct atto_vda_ae_req,\n\t\t\t\t\t\t   prde);\n\t\tvrq->prde[0].ctl_len = cpu_to_le32(vrq->length);\n\t\tvrq->prde[0].address = cpu_to_le64(\n\t\t\trq->vrq_md->phys_addr +\n\t\t\tsizeof(union atto_vda_req));\n\t}\n}\n\n \nvoid esas2r_build_cli_req(struct esas2r_adapter *a,\n\t\t\t  struct esas2r_request *rq,\n\t\t\t  u32 length,\n\t\t\t  u32 cmd_rsp_len)\n{\n\tstruct atto_vda_cli_req *vrq = &rq->vrq->cli;\n\n\tclear_vda_request(rq);\n\n\trq->vrq->scsi.function = VDA_FUNC_CLI;\n\n\tvrq->length = cpu_to_le32(length);\n\tvrq->cmd_rsp_len = cpu_to_le32(cmd_rsp_len);\n\tvrq->sg_list_offset = (u8)offsetof(struct atto_vda_cli_req, sge);\n}\n\n \nvoid esas2r_build_ioctl_req(struct esas2r_adapter *a,\n\t\t\t    struct esas2r_request *rq,\n\t\t\t    u32 length,\n\t\t\t    u8 sub_func)\n{\n\tstruct atto_vda_ioctl_req *vrq = &rq->vrq->ioctl;\n\n\tclear_vda_request(rq);\n\n\trq->vrq->scsi.function = VDA_FUNC_IOCTL;\n\n\tvrq->length = cpu_to_le32(length);\n\tvrq->sub_func = sub_func;\n\tvrq->sg_list_offset = (u8)offsetof(struct atto_vda_ioctl_req, sge);\n}\n\n \nvoid esas2r_build_cfg_req(struct esas2r_adapter *a,\n\t\t\t  struct esas2r_request *rq,\n\t\t\t  u8 sub_func,\n\t\t\t  u32 length,\n\t\t\t  void *data)\n{\n\tstruct atto_vda_cfg_req *vrq = &rq->vrq->cfg;\n\n\tclear_vda_request(rq);\n\n\trq->vrq->scsi.function = VDA_FUNC_CFG;\n\n\tvrq->sub_func = sub_func;\n\tvrq->length = cpu_to_le32(length);\n\n\tif (data) {\n\t\tesas2r_nuxi_cfg_data(sub_func, data);\n\n\t\tmemcpy(&vrq->data, data, length);\n\t}\n}\n\nstatic void clear_vda_request(struct esas2r_request *rq)\n{\n\tu32 handle = rq->vrq->scsi.handle;\n\n\tmemset(rq->vrq, 0, sizeof(*rq->vrq));\n\n\trq->vrq->scsi.handle = handle;\n\n\trq->req_stat = RS_PENDING;\n\n\t \n\n\tmemset(rq->data_buf, 0, ESAS2R_DATA_BUF_LEN);\n\n\t \n\n\tINIT_LIST_HEAD(&rq->req_list);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}