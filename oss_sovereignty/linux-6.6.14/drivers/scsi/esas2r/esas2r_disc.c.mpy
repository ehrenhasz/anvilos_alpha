{
  "module_name": "esas2r_disc.c",
  "hash_id": "012b5a9214c961c70881b211548e09cb8a6d7e047f54e9dda831b9708463efbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/esas2r/esas2r_disc.c",
  "human_readable_source": " \n \n \n \n\n#include \"esas2r.h\"\n\n \nstatic void esas2r_disc_abort(struct esas2r_adapter *a,\n\t\t\t      struct esas2r_request *rq);\nstatic bool esas2r_disc_continue(struct esas2r_adapter *a,\n\t\t\t\t struct esas2r_request *rq);\nstatic void esas2r_disc_fix_curr_requests(struct esas2r_adapter *a);\nstatic u32 esas2r_disc_get_phys_addr(struct esas2r_sg_context *sgc, u64 *addr);\nstatic bool esas2r_disc_start_request(struct esas2r_adapter *a,\n\t\t\t\t      struct esas2r_request *rq);\n\n \nstatic bool esas2r_disc_block_dev_scan(struct esas2r_adapter *a,\n\t\t\t\t       struct esas2r_request *rq);\nstatic void esas2r_disc_block_dev_scan_cb(struct esas2r_adapter *a,\n\t\t\t\t\t  struct esas2r_request *rq);\nstatic bool esas2r_disc_dev_add(struct esas2r_adapter *a,\n\t\t\t\tstruct esas2r_request *rq);\nstatic bool esas2r_disc_dev_remove(struct esas2r_adapter *a,\n\t\t\t\t   struct esas2r_request *rq);\nstatic bool esas2r_disc_part_info(struct esas2r_adapter *a,\n\t\t\t\t  struct esas2r_request *rq);\nstatic void esas2r_disc_part_info_cb(struct esas2r_adapter *a,\n\t\t\t\t     struct esas2r_request *rq);\nstatic bool esas2r_disc_passthru_dev_info(struct esas2r_adapter *a,\n\t\t\t\t\t  struct esas2r_request *rq);\nstatic void esas2r_disc_passthru_dev_info_cb(struct esas2r_adapter *a,\n\t\t\t\t\t     struct esas2r_request *rq);\nstatic bool esas2r_disc_passthru_dev_addr(struct esas2r_adapter *a,\n\t\t\t\t\t  struct esas2r_request *rq);\nstatic void esas2r_disc_passthru_dev_addr_cb(struct esas2r_adapter *a,\n\t\t\t\t\t     struct esas2r_request *rq);\nstatic bool esas2r_disc_raid_grp_info(struct esas2r_adapter *a,\n\t\t\t\t      struct esas2r_request *rq);\nstatic void esas2r_disc_raid_grp_info_cb(struct esas2r_adapter *a,\n\t\t\t\t\t struct esas2r_request *rq);\n\nvoid esas2r_disc_initialize(struct esas2r_adapter *a)\n{\n\tstruct esas2r_sas_nvram *nvr = a->nvram;\n\n\tesas2r_trace_enter();\n\n\tclear_bit(AF_DISC_IN_PROG, &a->flags);\n\tclear_bit(AF2_DEV_SCAN, &a->flags2);\n\tclear_bit(AF2_DEV_CNT_OK, &a->flags2);\n\n\ta->disc_start_time = jiffies_to_msecs(jiffies);\n\ta->disc_wait_time = nvr->dev_wait_time * 1000;\n\ta->disc_wait_cnt = nvr->dev_wait_count;\n\n\tif (a->disc_wait_cnt > ESAS2R_MAX_TARGETS)\n\t\ta->disc_wait_cnt = ESAS2R_MAX_TARGETS;\n\n\t \n\n\tesas2r_hdebug(\"starting discovery...\");\n\n\ta->general_req.interrupt_cx = NULL;\n\n\tif (test_bit(AF_CHPRST_DETECTED, &a->flags) ||\n\t    test_bit(AF_POWER_MGT, &a->flags)) {\n\t\tif (a->prev_dev_cnt == 0) {\n\t\t\t \n\t\t\ta->disc_wait_time = 0;\n\t\t} else {\n\t\t\t \n\t\t\ta->disc_wait_cnt = a->prev_dev_cnt;\n\n\t\t\t \n\t\t\tif (a->disc_wait_time < 15000)\n\t\t\t\ta->disc_wait_time = 15000;\n\t\t}\n\t}\n\n\tesas2r_trace(\"disc wait count: %d\", a->disc_wait_cnt);\n\tesas2r_trace(\"disc wait time: %d\", a->disc_wait_time);\n\n\tif (a->disc_wait_time == 0)\n\t\tesas2r_disc_check_complete(a);\n\n\tesas2r_trace_exit();\n}\n\nvoid esas2r_disc_start_waiting(struct esas2r_adapter *a)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&a->mem_lock, flags);\n\n\tif (a->disc_ctx.disc_evt)\n\t\tesas2r_disc_start_port(a);\n\n\tspin_unlock_irqrestore(&a->mem_lock, flags);\n}\n\nvoid esas2r_disc_check_for_work(struct esas2r_adapter *a)\n{\n\tstruct esas2r_request *rq = &a->general_req;\n\n\t \n\n\tesas2r_polled_interrupt(a);\n\n\t \n\n\tesas2r_disc_start_waiting(a);\n\n\tif (rq->interrupt_cx == NULL)\n\t\treturn;\n\n\tif (rq->req_stat == RS_STARTED\n\t    && rq->timeout <= RQ_MAX_TIMEOUT) {\n\t\t \n\t\tesas2r_wait_request(a, rq);\n\n\t\tif (rq->req_stat == RS_TIMEOUT) {\n\t\t\tesas2r_disc_abort(a, rq);\n\t\t\tesas2r_local_reset_adapter(a);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (rq->req_stat == RS_PENDING\n\t    || rq->req_stat == RS_STARTED)\n\t\treturn;\n\n\tesas2r_disc_continue(a, rq);\n}\n\nvoid esas2r_disc_check_complete(struct esas2r_adapter *a)\n{\n\tunsigned long flags;\n\n\tesas2r_trace_enter();\n\n\t \n\tif (a->disc_wait_time) {\n\t\tu32 currtime = jiffies_to_msecs(jiffies);\n\t\tu32 time = currtime - a->disc_start_time;\n\n\t\t \n\t\tif (time < a->disc_wait_time\n\t\t    && (esas2r_targ_db_get_tgt_cnt(a) < a->disc_wait_cnt\n\t\t\t|| a->disc_wait_cnt == 0)) {\n\t\t\t \n\t\t\tif (time >= 3000\n\t\t\t    && !test_and_set_bit(AF2_DEV_SCAN, &a->flags2)) {\n\t\t\t\tspin_lock_irqsave(&a->mem_lock, flags);\n\t\t\t\tesas2r_disc_queue_event(a, DCDE_DEV_SCAN);\n\t\t\t\tspin_unlock_irqrestore(&a->mem_lock, flags);\n\t\t\t}\n\n\t\t\tesas2r_trace_exit();\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (!test_and_set_bit(AF2_DEV_CNT_OK, &a->flags2))\n\t\t\ta->disc_wait_time = time + 3000;\n\n\t\t \n\t\tif (!test_and_set_bit(AF2_DEV_SCAN, &a->flags2)) {\n\t\t\tspin_lock_irqsave(&a->mem_lock, flags);\n\t\t\tesas2r_disc_queue_event(a, DCDE_DEV_SCAN);\n\t\t\tspin_unlock_irqrestore(&a->mem_lock, flags);\n\t\t\tesas2r_trace_exit();\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (time < a->disc_wait_time) {\n\t\t\tesas2r_trace_exit();\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (!test_and_set_bit(AF2_DEV_SCAN, &a->flags2)) {\n\t\t\tspin_lock_irqsave(&a->mem_lock, flags);\n\t\t\tesas2r_disc_queue_event(a, DCDE_DEV_SCAN);\n\t\t\tspin_unlock_irqrestore(&a->mem_lock, flags);\n\t\t}\n\t}\n\n\t \n\ta->disc_wait_time = 0;\n\n\tif (test_bit(AF_DISC_POLLED, &a->flags) &&\n\t    test_bit(AF_DISC_IN_PROG, &a->flags)) {\n\t\t \n\t} else {\n\t\t \n\t\tesas2r_disc_fix_curr_requests(a);\n\t\tclear_bit(AF_DISC_PENDING, &a->flags);\n\n\t\t \n\t\tset_bit(AF_PORT_CHANGE, &a->flags);\n\t}\n\n\tesas2r_trace_exit();\n}\n\nvoid esas2r_disc_queue_event(struct esas2r_adapter *a, u8 disc_evt)\n{\n\tstruct esas2r_disc_context *dc = &a->disc_ctx;\n\n\tesas2r_trace_enter();\n\n\tesas2r_trace(\"disc_event: %d\", disc_evt);\n\n\t \n\tdc->disc_evt |= disc_evt;\n\n\t \n\tif (!test_bit(AF_CHPRST_PENDING, &a->flags) &&\n\t    !test_bit(AF_DISC_POLLED, &a->flags))\n\t\tesas2r_disc_start_port(a);\n\n\tesas2r_trace_exit();\n}\n\nbool esas2r_disc_start_port(struct esas2r_adapter *a)\n{\n\tstruct esas2r_request *rq = &a->general_req;\n\tstruct esas2r_disc_context *dc = &a->disc_ctx;\n\tbool ret;\n\n\tesas2r_trace_enter();\n\n\tif (test_bit(AF_DISC_IN_PROG, &a->flags)) {\n\t\tesas2r_trace_exit();\n\n\t\treturn false;\n\t}\n\n\t \n\tif (dc->disc_evt) {\n\t\tif (test_bit(AF_DISC_POLLED, &a->flags)\n\t\t    && a->disc_wait_time == 0) {\n\t\t\t \n\n\t\t\tesas2r_trace_exit();\n\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t \n\n\t\tesas2r_hdebug(\"disc done\");\n\n\t\tset_bit(AF_PORT_CHANGE, &a->flags);\n\n\t\tesas2r_trace_exit();\n\n\t\treturn false;\n\t}\n\n\t \n\tesas2r_trace(\"disc_evt: %d\", dc->disc_evt);\n\tset_bit(AF_DISC_IN_PROG, &a->flags);\n\tdc->flags = 0;\n\n\tif (test_bit(AF_DISC_POLLED, &a->flags))\n\t\tdc->flags |= DCF_POLLED;\n\n\trq->interrupt_cx = dc;\n\trq->req_stat = RS_SUCCESS;\n\n\t \n\tif (dc->disc_evt & DCDE_DEV_SCAN) {\n\t\tdc->disc_evt &= ~DCDE_DEV_SCAN;\n\n\t\tdc->flags |= DCF_DEV_SCAN;\n\t\tdc->state = DCS_BLOCK_DEV_SCAN;\n\t} else if (dc->disc_evt & DCDE_DEV_CHANGE) {\n\t\tdc->disc_evt &= ~DCDE_DEV_CHANGE;\n\n\t\tdc->flags |= DCF_DEV_CHANGE;\n\t\tdc->state = DCS_DEV_RMV;\n\t}\n\n\t \n\tif (!test_bit(AF_DISC_POLLED, &a->flags))\n\t\tret = esas2r_disc_continue(a, rq);\n\telse\n\t\tret = true;\n\n\tesas2r_trace_exit();\n\n\treturn ret;\n}\n\nstatic bool esas2r_disc_continue(struct esas2r_adapter *a,\n\t\t\t\t struct esas2r_request *rq)\n{\n\tstruct esas2r_disc_context *dc =\n\t\t(struct esas2r_disc_context *)rq->interrupt_cx;\n\tbool rslt;\n\n\t \n\twhile (dc->flags & (DCF_DEV_CHANGE | DCF_DEV_SCAN)) {\n\t\trslt = false;\n\n\t\tswitch (dc->state) {\n\t\tcase DCS_DEV_RMV:\n\n\t\t\trslt = esas2r_disc_dev_remove(a, rq);\n\t\t\tbreak;\n\n\t\tcase DCS_DEV_ADD:\n\n\t\t\trslt = esas2r_disc_dev_add(a, rq);\n\t\t\tbreak;\n\n\t\tcase DCS_BLOCK_DEV_SCAN:\n\n\t\t\trslt = esas2r_disc_block_dev_scan(a, rq);\n\t\t\tbreak;\n\n\t\tcase DCS_RAID_GRP_INFO:\n\n\t\t\trslt = esas2r_disc_raid_grp_info(a, rq);\n\t\t\tbreak;\n\n\t\tcase DCS_PART_INFO:\n\n\t\t\trslt = esas2r_disc_part_info(a, rq);\n\t\t\tbreak;\n\n\t\tcase DCS_PT_DEV_INFO:\n\n\t\t\trslt = esas2r_disc_passthru_dev_info(a, rq);\n\t\t\tbreak;\n\t\tcase DCS_PT_DEV_ADDR:\n\n\t\t\trslt = esas2r_disc_passthru_dev_addr(a, rq);\n\t\t\tbreak;\n\t\tcase DCS_DISC_DONE:\n\n\t\t\tdc->flags &= ~(DCF_DEV_CHANGE | DCF_DEV_SCAN);\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tesas2r_bugon();\n\t\t\tdc->state = DCS_DISC_DONE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rslt)\n\t\t\treturn true;\n\t}\n\n\t \n\trq->interrupt_cx = NULL;\n\n\tif (!test_bit(AF_DISC_PENDING, &a->flags))\n\t\tesas2r_disc_fix_curr_requests(a);\n\n\tclear_bit(AF_DISC_IN_PROG, &a->flags);\n\n\t \n\treturn esas2r_disc_start_port(a);\n}\n\nstatic bool esas2r_disc_start_request(struct esas2r_adapter *a,\n\t\t\t\t      struct esas2r_request *rq)\n{\n\tunsigned long flags;\n\n\t \n\tif (rq->timeout < ESAS2R_DEFAULT_TMO)\n\t\trq->timeout = ESAS2R_DEFAULT_TMO;\n\n\t \n\trq->req_type = RT_DISC_REQ;\n\n\tspin_lock_irqsave(&a->queue_lock, flags);\n\n\tif (!test_bit(AF_CHPRST_PENDING, &a->flags) &&\n\t    !test_bit(AF_FLASHING, &a->flags))\n\t\tesas2r_disc_local_start_request(a, rq);\n\telse\n\t\tlist_add_tail(&rq->req_list, &a->defer_list);\n\n\tspin_unlock_irqrestore(&a->queue_lock, flags);\n\n\treturn true;\n}\n\nvoid esas2r_disc_local_start_request(struct esas2r_adapter *a,\n\t\t\t\t     struct esas2r_request *rq)\n{\n\tesas2r_trace_enter();\n\n\tlist_add_tail(&rq->req_list, &a->active_list);\n\n\tesas2r_start_vda_request(a, rq);\n\n\tesas2r_trace_exit();\n\n\treturn;\n}\n\nstatic void esas2r_disc_abort(struct esas2r_adapter *a,\n\t\t\t      struct esas2r_request *rq)\n{\n\tstruct esas2r_disc_context *dc =\n\t\t(struct esas2r_disc_context *)rq->interrupt_cx;\n\n\tesas2r_trace_enter();\n\n\t \n\n\tdc->state = DCS_DISC_DONE;\n\n\tesas2r_trace_exit();\n}\n\nstatic bool esas2r_disc_block_dev_scan(struct esas2r_adapter *a,\n\t\t\t\t       struct esas2r_request *rq)\n{\n\tstruct esas2r_disc_context *dc =\n\t\t(struct esas2r_disc_context *)rq->interrupt_cx;\n\tbool rslt;\n\n\tesas2r_trace_enter();\n\n\tesas2r_rq_init_request(rq, a);\n\n\tesas2r_build_mgt_req(a,\n\t\t\t     rq,\n\t\t\t     VDAMGT_DEV_SCAN,\n\t\t\t     0,\n\t\t\t     0,\n\t\t\t     0,\n\t\t\t     NULL);\n\n\trq->comp_cb = esas2r_disc_block_dev_scan_cb;\n\n\trq->timeout = 30000;\n\trq->interrupt_cx = dc;\n\n\trslt = esas2r_disc_start_request(a, rq);\n\n\tesas2r_trace_exit();\n\n\treturn rslt;\n}\n\nstatic void esas2r_disc_block_dev_scan_cb(struct esas2r_adapter *a,\n\t\t\t\t\t  struct esas2r_request *rq)\n{\n\tstruct esas2r_disc_context *dc =\n\t\t(struct esas2r_disc_context *)rq->interrupt_cx;\n\tunsigned long flags;\n\n\tesas2r_trace_enter();\n\n\tspin_lock_irqsave(&a->mem_lock, flags);\n\n\tif (rq->req_stat == RS_SUCCESS)\n\t\tdc->scan_gen = rq->func_rsp.mgt_rsp.scan_generation;\n\n\tdc->state = DCS_RAID_GRP_INFO;\n\tdc->raid_grp_ix = 0;\n\n\tesas2r_rq_destroy_request(rq, a);\n\n\t \n\n\tif (!(dc->flags & DCF_POLLED))\n\t\tesas2r_disc_continue(a, rq);\n\n\tspin_unlock_irqrestore(&a->mem_lock, flags);\n\n\tesas2r_trace_exit();\n}\n\nstatic bool esas2r_disc_raid_grp_info(struct esas2r_adapter *a,\n\t\t\t\t      struct esas2r_request *rq)\n{\n\tstruct esas2r_disc_context *dc =\n\t\t(struct esas2r_disc_context *)rq->interrupt_cx;\n\tbool rslt;\n\tstruct atto_vda_grp_info *grpinfo;\n\n\tesas2r_trace_enter();\n\n\tesas2r_trace(\"raid_group_idx: %d\", dc->raid_grp_ix);\n\n\tif (dc->raid_grp_ix >= VDA_MAX_RAID_GROUPS) {\n\t\tdc->state = DCS_DISC_DONE;\n\n\t\tesas2r_trace_exit();\n\n\t\treturn false;\n\t}\n\n\tesas2r_rq_init_request(rq, a);\n\n\tgrpinfo = &rq->vda_rsp_data->mgt_data.data.grp_info;\n\n\tmemset(grpinfo, 0, sizeof(struct atto_vda_grp_info));\n\n\tesas2r_build_mgt_req(a,\n\t\t\t     rq,\n\t\t\t     VDAMGT_GRP_INFO,\n\t\t\t     dc->scan_gen,\n\t\t\t     0,\n\t\t\t     sizeof(struct atto_vda_grp_info),\n\t\t\t     NULL);\n\n\tgrpinfo->grp_index = dc->raid_grp_ix;\n\n\trq->comp_cb = esas2r_disc_raid_grp_info_cb;\n\n\trq->interrupt_cx = dc;\n\n\trslt = esas2r_disc_start_request(a, rq);\n\n\tesas2r_trace_exit();\n\n\treturn rslt;\n}\n\nstatic void esas2r_disc_raid_grp_info_cb(struct esas2r_adapter *a,\n\t\t\t\t\t struct esas2r_request *rq)\n{\n\tstruct esas2r_disc_context *dc =\n\t\t(struct esas2r_disc_context *)rq->interrupt_cx;\n\tunsigned long flags;\n\tstruct atto_vda_grp_info *grpinfo;\n\n\tesas2r_trace_enter();\n\n\tspin_lock_irqsave(&a->mem_lock, flags);\n\n\tif (rq->req_stat == RS_SCAN_GEN) {\n\t\tdc->scan_gen = rq->func_rsp.mgt_rsp.scan_generation;\n\t\tdc->raid_grp_ix = 0;\n\t\tgoto done;\n\t}\n\n\tif (rq->req_stat == RS_SUCCESS) {\n\t\tgrpinfo = &rq->vda_rsp_data->mgt_data.data.grp_info;\n\n\t\tif (grpinfo->status != VDA_GRP_STAT_ONLINE\n\t\t    && grpinfo->status != VDA_GRP_STAT_DEGRADED) {\n\t\t\t \n\n\t\t\tdc->raid_grp_ix++;\n\t\t} else {\n\t\t\tmemcpy(&dc->raid_grp_name[0],\n\t\t\t       &grpinfo->grp_name[0],\n\t\t\t       sizeof(grpinfo->grp_name));\n\n\t\t\tdc->interleave = le32_to_cpu(grpinfo->interleave);\n\t\t\tdc->block_size = le32_to_cpu(grpinfo->block_size);\n\n\t\t\tdc->state = DCS_PART_INFO;\n\t\t\tdc->part_num = 0;\n\t\t}\n\t} else {\n\t\tif (!(rq->req_stat == RS_GRP_INVALID)) {\n\t\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t\t   \"A request for RAID group info failed - \"\n\t\t\t\t   \"returned with %x\",\n\t\t\t\t   rq->req_stat);\n\t\t}\n\n\t\tdc->dev_ix = 0;\n\t\tdc->state = DCS_PT_DEV_INFO;\n\t}\n\ndone:\n\n\tesas2r_rq_destroy_request(rq, a);\n\n\t \n\n\tif (!(dc->flags & DCF_POLLED))\n\t\tesas2r_disc_continue(a, rq);\n\n\tspin_unlock_irqrestore(&a->mem_lock, flags);\n\n\tesas2r_trace_exit();\n}\n\nstatic bool esas2r_disc_part_info(struct esas2r_adapter *a,\n\t\t\t\t  struct esas2r_request *rq)\n{\n\tstruct esas2r_disc_context *dc =\n\t\t(struct esas2r_disc_context *)rq->interrupt_cx;\n\tbool rslt;\n\tstruct atto_vdapart_info *partinfo;\n\n\tesas2r_trace_enter();\n\n\tesas2r_trace(\"part_num: %d\", dc->part_num);\n\n\tif (dc->part_num >= VDA_MAX_PARTITIONS) {\n\t\tdc->state = DCS_RAID_GRP_INFO;\n\t\tdc->raid_grp_ix++;\n\n\t\tesas2r_trace_exit();\n\n\t\treturn false;\n\t}\n\n\tesas2r_rq_init_request(rq, a);\n\n\tpartinfo = &rq->vda_rsp_data->mgt_data.data.part_info;\n\n\tmemset(partinfo, 0, sizeof(struct atto_vdapart_info));\n\n\tesas2r_build_mgt_req(a,\n\t\t\t     rq,\n\t\t\t     VDAMGT_PART_INFO,\n\t\t\t     dc->scan_gen,\n\t\t\t     0,\n\t\t\t     sizeof(struct atto_vdapart_info),\n\t\t\t     NULL);\n\n\tpartinfo->part_no = dc->part_num;\n\n\tmemcpy(&partinfo->grp_name[0],\n\t       &dc->raid_grp_name[0],\n\t       sizeof(partinfo->grp_name));\n\n\trq->comp_cb = esas2r_disc_part_info_cb;\n\n\trq->interrupt_cx = dc;\n\n\trslt = esas2r_disc_start_request(a, rq);\n\n\tesas2r_trace_exit();\n\n\treturn rslt;\n}\n\nstatic void esas2r_disc_part_info_cb(struct esas2r_adapter *a,\n\t\t\t\t     struct esas2r_request *rq)\n{\n\tstruct esas2r_disc_context *dc =\n\t\t(struct esas2r_disc_context *)rq->interrupt_cx;\n\tunsigned long flags;\n\tstruct atto_vdapart_info *partinfo;\n\n\tesas2r_trace_enter();\n\n\tspin_lock_irqsave(&a->mem_lock, flags);\n\n\tif (rq->req_stat == RS_SCAN_GEN) {\n\t\tdc->scan_gen = rq->func_rsp.mgt_rsp.scan_generation;\n\t\tdc->raid_grp_ix = 0;\n\t\tdc->state = DCS_RAID_GRP_INFO;\n\t} else if (rq->req_stat == RS_SUCCESS) {\n\t\tpartinfo = &rq->vda_rsp_data->mgt_data.data.part_info;\n\n\t\tdc->part_num = partinfo->part_no;\n\n\t\tdc->curr_virt_id = le16_to_cpu(partinfo->target_id);\n\n\t\tesas2r_targ_db_add_raid(a, dc);\n\n\t\tdc->part_num++;\n\t} else {\n\t\tif (!(rq->req_stat == RS_PART_LAST)) {\n\t\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t\t   \"A request for RAID group partition info \"\n\t\t\t\t   \"failed - status:%d\", rq->req_stat);\n\t\t}\n\n\t\tdc->state = DCS_RAID_GRP_INFO;\n\t\tdc->raid_grp_ix++;\n\t}\n\n\tesas2r_rq_destroy_request(rq, a);\n\n\t \n\n\tif (!(dc->flags & DCF_POLLED))\n\t\tesas2r_disc_continue(a, rq);\n\n\tspin_unlock_irqrestore(&a->mem_lock, flags);\n\n\tesas2r_trace_exit();\n}\n\nstatic bool esas2r_disc_passthru_dev_info(struct esas2r_adapter *a,\n\t\t\t\t\t  struct esas2r_request *rq)\n{\n\tstruct esas2r_disc_context *dc =\n\t\t(struct esas2r_disc_context *)rq->interrupt_cx;\n\tbool rslt;\n\tstruct atto_vda_devinfo *devinfo;\n\n\tesas2r_trace_enter();\n\n\tesas2r_trace(\"dev_ix: %d\", dc->dev_ix);\n\n\tesas2r_rq_init_request(rq, a);\n\n\tdevinfo = &rq->vda_rsp_data->mgt_data.data.dev_info;\n\n\tmemset(devinfo, 0, sizeof(struct atto_vda_devinfo));\n\n\tesas2r_build_mgt_req(a,\n\t\t\t     rq,\n\t\t\t     VDAMGT_DEV_PT_INFO,\n\t\t\t     dc->scan_gen,\n\t\t\t     dc->dev_ix,\n\t\t\t     sizeof(struct atto_vda_devinfo),\n\t\t\t     NULL);\n\n\trq->comp_cb = esas2r_disc_passthru_dev_info_cb;\n\n\trq->interrupt_cx = dc;\n\n\trslt = esas2r_disc_start_request(a, rq);\n\n\tesas2r_trace_exit();\n\n\treturn rslt;\n}\n\nstatic void esas2r_disc_passthru_dev_info_cb(struct esas2r_adapter *a,\n\t\t\t\t\t     struct esas2r_request *rq)\n{\n\tstruct esas2r_disc_context *dc =\n\t\t(struct esas2r_disc_context *)rq->interrupt_cx;\n\tunsigned long flags;\n\tstruct atto_vda_devinfo *devinfo;\n\n\tesas2r_trace_enter();\n\n\tspin_lock_irqsave(&a->mem_lock, flags);\n\n\tif (rq->req_stat == RS_SCAN_GEN) {\n\t\tdc->scan_gen = rq->func_rsp.mgt_rsp.scan_generation;\n\t\tdc->dev_ix = 0;\n\t\tdc->state = DCS_PT_DEV_INFO;\n\t} else if (rq->req_stat == RS_SUCCESS) {\n\t\tdevinfo = &rq->vda_rsp_data->mgt_data.data.dev_info;\n\n\t\tdc->dev_ix = le16_to_cpu(rq->func_rsp.mgt_rsp.dev_index);\n\n\t\tdc->curr_virt_id = le16_to_cpu(devinfo->target_id);\n\n\t\tif (le16_to_cpu(devinfo->features) & VDADEVFEAT_PHYS_ID) {\n\t\t\tdc->curr_phys_id =\n\t\t\t\tle16_to_cpu(devinfo->phys_target_id);\n\t\t\tdc->dev_addr_type = ATTO_GDA_AT_PORT;\n\t\t\tdc->state = DCS_PT_DEV_ADDR;\n\n\t\t\tesas2r_trace(\"curr_virt_id: %d\", dc->curr_virt_id);\n\t\t\tesas2r_trace(\"curr_phys_id: %d\", dc->curr_phys_id);\n\t\t} else {\n\t\t\tdc->dev_ix++;\n\t\t}\n\t} else {\n\t\tif (!(rq->req_stat == RS_DEV_INVALID)) {\n\t\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t\t   \"A request for device information failed - \"\n\t\t\t\t   \"status:%d\", rq->req_stat);\n\t\t}\n\n\t\tdc->state = DCS_DISC_DONE;\n\t}\n\n\tesas2r_rq_destroy_request(rq, a);\n\n\t \n\n\tif (!(dc->flags & DCF_POLLED))\n\t\tesas2r_disc_continue(a, rq);\n\n\tspin_unlock_irqrestore(&a->mem_lock, flags);\n\n\tesas2r_trace_exit();\n}\n\nstatic bool esas2r_disc_passthru_dev_addr(struct esas2r_adapter *a,\n\t\t\t\t\t  struct esas2r_request *rq)\n{\n\tstruct esas2r_disc_context *dc =\n\t\t(struct esas2r_disc_context *)rq->interrupt_cx;\n\tbool rslt;\n\tstruct atto_ioctl *hi;\n\tstruct esas2r_sg_context sgc;\n\n\tesas2r_trace_enter();\n\n\tesas2r_rq_init_request(rq, a);\n\n\t \n\n\tsgc.cur_offset = NULL;\n\tsgc.get_phys_addr = (PGETPHYSADDR)esas2r_disc_get_phys_addr;\n\tsgc.length = offsetof(struct atto_ioctl, data)\n\t\t     + sizeof(struct atto_hba_get_device_address);\n\n\tesas2r_sgc_init(&sgc, a, rq, rq->vrq->ioctl.sge);\n\n\tesas2r_build_ioctl_req(a, rq, sgc.length, VDA_IOCTL_HBA);\n\n\tif (!esas2r_build_sg_list(a, rq, &sgc)) {\n\t\tesas2r_rq_destroy_request(rq, a);\n\n\t\tesas2r_trace_exit();\n\n\t\treturn false;\n\t}\n\n\trq->comp_cb = esas2r_disc_passthru_dev_addr_cb;\n\n\trq->interrupt_cx = dc;\n\n\t \n\n\thi = (struct atto_ioctl *)a->disc_buffer;\n\n\tmemset(a->disc_buffer, 0, ESAS2R_DISC_BUF_LEN);\n\n\thi->version = ATTO_VER_GET_DEV_ADDR0;\n\thi->function = ATTO_FUNC_GET_DEV_ADDR;\n\thi->flags = HBAF_TUNNEL;\n\n\thi->data.get_dev_addr.target_id = le32_to_cpu(dc->curr_phys_id);\n\thi->data.get_dev_addr.addr_type = dc->dev_addr_type;\n\n\t \n\n\trslt = esas2r_disc_start_request(a, rq);\n\n\tesas2r_trace_exit();\n\n\treturn rslt;\n}\n\nstatic void esas2r_disc_passthru_dev_addr_cb(struct esas2r_adapter *a,\n\t\t\t\t\t     struct esas2r_request *rq)\n{\n\tstruct esas2r_disc_context *dc =\n\t\t(struct esas2r_disc_context *)rq->interrupt_cx;\n\tstruct esas2r_target *t = NULL;\n\tunsigned long flags;\n\tstruct atto_ioctl *hi;\n\tu16 addrlen;\n\n\tesas2r_trace_enter();\n\n\tspin_lock_irqsave(&a->mem_lock, flags);\n\n\thi = (struct atto_ioctl *)a->disc_buffer;\n\n\tif (rq->req_stat == RS_SUCCESS\n\t    && hi->status == ATTO_STS_SUCCESS) {\n\t\taddrlen = le16_to_cpu(hi->data.get_dev_addr.addr_len);\n\n\t\tif (dc->dev_addr_type == ATTO_GDA_AT_PORT) {\n\t\t\tif (addrlen == sizeof(u64))\n\t\t\t\tmemcpy(&dc->sas_addr,\n\t\t\t\t       &hi->data.get_dev_addr.address[0],\n\t\t\t\t       addrlen);\n\t\t\telse\n\t\t\t\tmemset(&dc->sas_addr, 0, sizeof(dc->sas_addr));\n\n\t\t\t \n\t\t\tdc->dev_addr_type = ATTO_GDA_AT_UNIQUE;\n\n\t\t\tgoto next_dev_addr;\n\t\t} else {\n\t\t\t \n\t\t\tif (HIBYTE(addrlen) == 0) {\n\t\t\t\tt = esas2r_targ_db_add_pthru(a,\n\t\t\t\t\t\t\t     dc,\n\t\t\t\t\t\t\t     &hi->data.\n\t\t\t\t\t\t\t     get_dev_addr.\n\t\t\t\t\t\t\t     address[0],\n\t\t\t\t\t\t\t     (u8)hi->data.\n\t\t\t\t\t\t\t     get_dev_addr.\n\t\t\t\t\t\t\t     addr_len);\n\n\t\t\t\tif (t)\n\t\t\t\t\tmemcpy(&t->sas_addr, &dc->sas_addr,\n\t\t\t\t\t       sizeof(t->sas_addr));\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t\t\t   \"an error occurred retrieving the \"\n\t\t\t\t\t   \"back end data (%s:%d)\",\n\t\t\t\t\t   __func__,\n\t\t\t\t\t   __LINE__);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\n\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t   \"an error occurred retrieving the back end data - \"\n\t\t\t   \"rq->req_stat:%d hi->status:%d\",\n\t\t\t   rq->req_stat, hi->status);\n\t}\n\n\t \n\n\tif (dc->flags & DCF_DEV_SCAN) {\n\t\tdc->dev_ix++;\n\t\tdc->state = DCS_PT_DEV_INFO;\n\t} else if (dc->flags & DCF_DEV_CHANGE) {\n\t\tdc->curr_targ++;\n\t\tdc->state = DCS_DEV_ADD;\n\t} else {\n\t\tesas2r_bugon();\n\t}\n\nnext_dev_addr:\n\tesas2r_rq_destroy_request(rq, a);\n\n\t \n\n\tif (!(dc->flags & DCF_POLLED))\n\t\tesas2r_disc_continue(a, rq);\n\n\tspin_unlock_irqrestore(&a->mem_lock, flags);\n\n\tesas2r_trace_exit();\n}\n\nstatic u32 esas2r_disc_get_phys_addr(struct esas2r_sg_context *sgc, u64 *addr)\n{\n\tstruct esas2r_adapter *a = sgc->adapter;\n\n\tif (sgc->length > ESAS2R_DISC_BUF_LEN) {\n\t\tesas2r_bugon();\n\t}\n\n\t*addr = a->uncached_phys\n\t\t+ (u64)((u8 *)a->disc_buffer - a->uncached);\n\n\treturn sgc->length;\n}\n\nstatic bool esas2r_disc_dev_remove(struct esas2r_adapter *a,\n\t\t\t\t   struct esas2r_request *rq)\n{\n\tstruct esas2r_disc_context *dc =\n\t\t(struct esas2r_disc_context *)rq->interrupt_cx;\n\tstruct esas2r_target *t;\n\tstruct esas2r_target *t2;\n\n\tesas2r_trace_enter();\n\n\t \n\n\tfor (t = a->targetdb; t < a->targetdb_end; t++) {\n\t\tif (t->new_target_state != TS_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tt->new_target_state = TS_INVALID;\n\n\t\t \n\n\t\tt2 =\n\t\t\tesas2r_targ_db_find_by_virt_id(a,\n\t\t\t\t\t\t       esas2r_targ_get_id(t,\n\t\t\t\t\t\t\t\t\t  a));\n\n\t\tif (t2)\n\t\t\tesas2r_targ_db_remove(a, t2);\n\t}\n\n\t \n\n\tdc->state = DCS_DEV_ADD;\n\tdc->curr_targ = a->targetdb;\n\n\tesas2r_trace_exit();\n\n\treturn false;\n}\n\nstatic bool esas2r_disc_dev_add(struct esas2r_adapter *a,\n\t\t\t\tstruct esas2r_request *rq)\n{\n\tstruct esas2r_disc_context *dc =\n\t\t(struct esas2r_disc_context *)rq->interrupt_cx;\n\tstruct esas2r_target *t = dc->curr_targ;\n\n\tif (t >= a->targetdb_end) {\n\t\t \n\n\t\tdc->state = DCS_DISC_DONE;\n\t} else if (t->new_target_state == TS_PRESENT) {\n\t\tstruct atto_vda_ae_lu *luevt = &t->lu_event;\n\n\t\tesas2r_trace_enter();\n\n\t\t \n\n\t\tt->new_target_state = TS_INVALID;\n\n\t\t \n\n\t\tdc->curr_virt_id = esas2r_targ_get_id(t, a);\n\n\t\tif ((luevt->hdr.bylength >= offsetof(struct atto_vda_ae_lu, id)\n\t\t     + sizeof(struct atto_vda_ae_lu_tgt_lun_raid))\n\t\t    && !(luevt->dwevent & VDAAE_LU_PASSTHROUGH)) {\n\t\t\tdc->block_size = luevt->id.tgtlun_raid.dwblock_size;\n\t\t\tdc->interleave = luevt->id.tgtlun_raid.dwinterleave;\n\t\t} else {\n\t\t\tdc->block_size = 0;\n\t\t\tdc->interleave = 0;\n\t\t}\n\n\t\t \n\n\t\tif (luevt->dwevent & VDAAE_LU_PASSTHROUGH) {\n\t\t\tif (luevt->dwevent & VDAAE_LU_PHYS_ID) {\n\t\t\t\tdc->state = DCS_PT_DEV_ADDR;\n\t\t\t\tdc->dev_addr_type = ATTO_GDA_AT_PORT;\n\t\t\t\tdc->curr_phys_id = luevt->wphys_target_id;\n\t\t\t} else {\n\t\t\t\tesas2r_log(ESAS2R_LOG_WARN,\n\t\t\t\t\t   \"luevt->dwevent does not have the \"\n\t\t\t\t\t   \"VDAAE_LU_PHYS_ID bit set (%s:%d)\",\n\t\t\t\t\t   __func__, __LINE__);\n\t\t\t}\n\t\t} else {\n\t\t\tdc->raid_grp_name[0] = 0;\n\n\t\t\tesas2r_targ_db_add_raid(a, dc);\n\t\t}\n\n\t\tesas2r_trace(\"curr_virt_id: %d\", dc->curr_virt_id);\n\t\tesas2r_trace(\"curr_phys_id: %d\", dc->curr_phys_id);\n\t\tesas2r_trace(\"dwevent: %d\", luevt->dwevent);\n\n\t\tesas2r_trace_exit();\n\t}\n\n\tif (dc->state == DCS_DEV_ADD) {\n\t\t \n\n\t\tdc->curr_targ++;\n\t}\n\n\treturn false;\n}\n\n \nstatic void esas2r_disc_fix_curr_requests(struct esas2r_adapter *a)\n{\n\tunsigned long flags;\n\tstruct esas2r_target *t;\n\tstruct esas2r_request *rq;\n\tstruct list_head *element;\n\n\t \n\n\tspin_lock_irqsave(&a->queue_lock, flags);\n\n\tlist_for_each(element, &a->defer_list) {\n\t\trq = list_entry(element, struct esas2r_request, req_list);\n\t\tif (rq->vrq->scsi.function == VDA_FUNC_SCSI) {\n\t\t\tt = a->targetdb + rq->target_id;\n\n\t\t\tif (t->target_state == TS_PRESENT)\n\t\t\t\trq->vrq->scsi.target_id = le16_to_cpu(\n\t\t\t\t\tt->virt_targ_id);\n\t\t\telse\n\t\t\t\trq->req_stat = RS_SEL;\n\t\t}\n\n\t}\n\n\tspin_unlock_irqrestore(&a->queue_lock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}