{
  "module_name": "esas2r_io.c",
  "hash_id": "2beb25ad74d7b2bc204c948af8be580d6f50fc3304a780ad06565d4425b1722a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/esas2r/esas2r_io.c",
  "human_readable_source": " \n\n#include \"esas2r.h\"\n\nvoid esas2r_start_request(struct esas2r_adapter *a, struct esas2r_request *rq)\n{\n\tstruct esas2r_target *t = NULL;\n\tstruct esas2r_request *startrq = rq;\n\tunsigned long flags;\n\n\tif (unlikely(test_bit(AF_DEGRADED_MODE, &a->flags) ||\n\t\t     test_bit(AF_POWER_DOWN, &a->flags))) {\n\t\tif (rq->vrq->scsi.function == VDA_FUNC_SCSI)\n\t\t\trq->req_stat = RS_SEL2;\n\t\telse\n\t\t\trq->req_stat = RS_DEGRADED;\n\t} else if (likely(rq->vrq->scsi.function == VDA_FUNC_SCSI)) {\n\t\tt = a->targetdb + rq->target_id;\n\n\t\tif (unlikely(t >= a->targetdb_end\n\t\t\t     || !(t->flags & TF_USED))) {\n\t\t\trq->req_stat = RS_SEL;\n\t\t} else {\n\t\t\t \n\t\t\trq->vrq->scsi.target_id = cpu_to_le16(t->virt_targ_id);\n\n\t\t\t \n\t\t\tif (unlikely(t->target_state != TS_PRESENT &&\n\t\t\t\t     !test_bit(AF_DISC_PENDING, &a->flags)))\n\t\t\t\trq->req_stat = RS_SEL;\n\t\t}\n\t}\n\n\tif (unlikely(rq->req_stat != RS_PENDING)) {\n\t\tesas2r_complete_request(a, rq);\n\t\treturn;\n\t}\n\n\tesas2r_trace(\"rq=%p\", rq);\n\tesas2r_trace(\"rq->vrq->scsi.handle=%x\", rq->vrq->scsi.handle);\n\n\tif (rq->vrq->scsi.function == VDA_FUNC_SCSI) {\n\t\tesas2r_trace(\"rq->target_id=%d\", rq->target_id);\n\t\tesas2r_trace(\"rq->vrq->scsi.flags=%x\", rq->vrq->scsi.flags);\n\t}\n\n\tspin_lock_irqsave(&a->queue_lock, flags);\n\n\tif (likely(list_empty(&a->defer_list) &&\n\t\t   !test_bit(AF_CHPRST_PENDING, &a->flags) &&\n\t\t   !test_bit(AF_FLASHING, &a->flags) &&\n\t\t   !test_bit(AF_DISC_PENDING, &a->flags)))\n\t\tesas2r_local_start_request(a, startrq);\n\telse\n\t\tlist_add_tail(&startrq->req_list, &a->defer_list);\n\n\tspin_unlock_irqrestore(&a->queue_lock, flags);\n}\n\n \nvoid esas2r_local_start_request(struct esas2r_adapter *a,\n\t\t\t\tstruct esas2r_request *rq)\n{\n\tesas2r_trace_enter();\n\tesas2r_trace(\"rq=%p\", rq);\n\tesas2r_trace(\"rq->vrq:%p\", rq->vrq);\n\tesas2r_trace(\"rq->vrq_md->phys_addr:%x\", rq->vrq_md->phys_addr);\n\n\tif (unlikely(rq->vrq->scsi.function == VDA_FUNC_FLASH\n\t\t     && rq->vrq->flash.sub_func == VDA_FLASH_COMMIT))\n\t\tset_bit(AF_FLASHING, &a->flags);\n\n\tlist_add_tail(&rq->req_list, &a->active_list);\n\tesas2r_start_vda_request(a, rq);\n\tesas2r_trace_exit();\n\treturn;\n}\n\nvoid esas2r_start_vda_request(struct esas2r_adapter *a,\n\t\t\t      struct esas2r_request *rq)\n{\n\tstruct esas2r_inbound_list_source_entry *element;\n\tu32 dw;\n\n\trq->req_stat = RS_STARTED;\n\t \n\ta->last_write++;\n\tif (a->last_write >= a->list_size) {\n\t\ta->last_write = 0;\n\t\t \n\t\tif (test_bit(AF_COMM_LIST_TOGGLE, &a->flags))\n\t\t\tclear_bit(AF_COMM_LIST_TOGGLE, &a->flags);\n\t\telse\n\t\t\tset_bit(AF_COMM_LIST_TOGGLE, &a->flags);\n\t}\n\n\telement =\n\t\t(struct esas2r_inbound_list_source_entry *)a->inbound_list_md.\n\t\tvirt_addr\n\t\t+ a->last_write;\n\n\t \n\tif (rq->vda_req_sz == RQ_SIZE_DEFAULT)\n\t\trq->vda_req_sz = (u16)(a->max_vdareq_size / sizeof(u32));\n\n\telement->address = cpu_to_le64(rq->vrq_md->phys_addr);\n\telement->length = cpu_to_le32(rq->vda_req_sz);\n\n\t \n\tdw = a->last_write;\n\n\tif (test_bit(AF_COMM_LIST_TOGGLE, &a->flags))\n\t\tdw |= MU_ILW_TOGGLE;\n\n\tesas2r_trace(\"rq->vrq->scsi.handle:%x\", rq->vrq->scsi.handle);\n\tesas2r_trace(\"dw:%x\", dw);\n\tesas2r_trace(\"rq->vda_req_sz:%x\", rq->vda_req_sz);\n\tesas2r_write_register_dword(a, MU_IN_LIST_WRITE, dw);\n}\n\n \nbool esas2r_build_sg_list_sge(struct esas2r_adapter *a,\n\t\t\t      struct esas2r_sg_context *sgc)\n{\n\tstruct esas2r_request *rq = sgc->first_req;\n\tunion atto_vda_req *vrq = rq->vrq;\n\n\twhile (sgc->length) {\n\t\tu32 rem = 0;\n\t\tu64 addr;\n\t\tu32 len;\n\n\t\tlen = (*sgc->get_phys_addr)(sgc, &addr);\n\n\t\tif (unlikely(len == 0))\n\t\t\treturn false;\n\n\t\t \n\t\tif (unlikely(len > sgc->length))\n\t\t\tlen = sgc->length;\n\nanother_entry:\n\t\t \n\t\tif (len > SGE_LEN_MAX) {\n\t\t\t \n\t\t\trem = len - SGE_LEN_MAX;\n\t\t\tlen = SGE_LEN_MAX;\n\t\t}\n\n\t\t \n\t\tif (unlikely(sgc->sge.a64.curr > sgc->sge.a64.limit)) {\n\t\t\tu8 sgelen;\n\t\t\tstruct esas2r_mem_desc *sgl;\n\n\t\t\t \n\t\t\tsgl = esas2r_alloc_sgl(a);\n\n\t\t\tif (unlikely(sgl == NULL))\n\t\t\t\treturn false;\n\n\t\t\t \n\t\t\tsgelen = (u8)((u8 *)sgc->sge.a64.curr\n\t\t\t\t      - (u8 *)sgc->sge.a64.last);\n\n\t\t\t \n\t\t\tmemcpy(sgl->virt_addr, sgc->sge.a64.last, sgelen);\n\n\t\t\t \n\t\t\tsgc->sge.a64.curr =\n\t\t\t\t(struct atto_vda_sge *)((u8 *)sgl->virt_addr +\n\t\t\t\t\t\t\tsgelen);\n\n\t\t\t \n\t\t\tsgc->sge.a64.limit =\n\t\t\t\t(struct atto_vda_sge *)((u8 *)sgl->virt_addr\n\t\t\t\t\t\t\t+ sgl_page_size\n\t\t\t\t\t\t\t- sizeof(struct\n\t\t\t\t\t\t\t\t atto_vda_sge));\n\t\t\tsgc->sge.a64.last->length = cpu_to_le32(\n\t\t\t\tSGE_CHAIN | SGE_ADDR_64);\n\t\t\tsgc->sge.a64.last->address =\n\t\t\t\tcpu_to_le64(sgl->phys_addr);\n\n\t\t\t \n\t\t\tif (sgc->sge.a64.chain) {\n\t\t\t\tsgc->sge.a64.chain->length |=\n\t\t\t\t\tcpu_to_le32(\n\t\t\t\t\t\t((u8 *)(sgc->sge.a64.\n\t\t\t\t\t\t\tlast + 1)\n\t\t\t\t\t\t - (u8 *)rq->sg_table->\n\t\t\t\t\t\t virt_addr)\n\t\t\t\t\t\t+ sizeof(struct atto_vda_sge) *\n\t\t\t\t\t\tLOBIT(SGE_CHAIN_SZ));\n\t\t\t} else {\n\t\t\t\tvrq->scsi.chain_offset = (u8)\n\t\t\t\t\t\t\t ((u8 *)sgc->\n\t\t\t\t\t\t\t  sge.a64.last -\n\t\t\t\t\t\t\t  (u8 *)vrq);\n\n\t\t\t\t \n\t\t\t\trq->vda_req_sz =\n\t\t\t\t\t(vrq->scsi.chain_offset +\n\t\t\t\t\t sizeof(struct atto_vda_sge) +\n\t\t\t\t\t 3)\n\t\t\t\t\t/ sizeof(u32);\n\t\t\t}\n\n\t\t\t \n\t\t\tsgc->sge.a64.chain = sgc->sge.a64.last;\n\n\t\t\t \n\t\t\tlist_add(&sgl->next_desc, &rq->sg_table_head);\n\t\t}\n\n\t\t \n\t\tsgc->sge.a64.last = sgc->sge.a64.curr;\n\n\t\t \n\t\tsgc->sge.a64.curr->length = cpu_to_le32(SGE_ADDR_64 | len);\n\t\tsgc->sge.a64.curr->address = cpu_to_le32(addr);\n\t\tsgc->sge.a64.curr++;\n\t\tsgc->cur_offset += len;\n\t\tsgc->length -= len;\n\n\t\t \n\t\tif (rem) {\n\t\t\taddr += len;\n\t\t\tlen = rem;\n\t\t\trem = 0;\n\t\t\tgoto another_entry;\n\t\t}\n\t}\n\n\t \n\tsgc->sge.a64.last->length |= cpu_to_le32(SGE_LAST);\n\n\t \n\tif (sgc->sge.a64.chain) {\n\t\tsgc->sge.a64.chain->length |= cpu_to_le32(\n\t\t\t((u8 *)(sgc->sge.a64.curr) -\n\t\t\t (u8 *)rq->sg_table->virt_addr));\n\t} else {\n\t\tu16 reqsize;\n\n\t\t \n\t\treqsize =\n\t\t\t((u16)((u8 *)sgc->sge.a64.last - (u8 *)vrq)\n\t\t\t + sizeof(struct atto_vda_sge) + 3) / sizeof(u32);\n\n\t\t \n\t\tif (reqsize > rq->vda_req_sz)\n\t\t\trq->vda_req_sz = reqsize;\n\t}\n\treturn true;\n}\n\n\n \nstatic bool esas2r_build_prd_iblk(struct esas2r_adapter *a,\n\t\t\t\t  struct esas2r_sg_context *sgc)\n{\n\tstruct esas2r_request *rq = sgc->first_req;\n\tu64 addr;\n\tu32 len;\n\tstruct esas2r_mem_desc *sgl;\n\tu32 numchain = 1;\n\tu32 rem = 0;\n\n\twhile (sgc->length) {\n\t\t \n\n\t\tlen = (*sgc->get_phys_addr)(sgc, &addr);\n\n\t\tif (unlikely(len == 0))\n\t\t\treturn false;\n\n\t\t \n\n\t\tif (unlikely(len > sgc->length))\n\t\t\tlen = sgc->length;\n\nanother_entry:\n\t\t \n\n\t\tif (len > PRD_LEN_MAX) {\n\t\t\t \n\t\t\trem = len - PRD_LEN_MAX;\n\t\t\tlen = PRD_LEN_MAX;\n\t\t}\n\n\t\t \n\t\tif (sgc->sge.prd.sge_cnt == 0) {\n\t\t\tif (len == sgc->length) {\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\tsgc->sge.prd.curr->ctl_len = cpu_to_le32(\n\t\t\t\t\tPRD_DATA | len);\n\t\t\t\tsgc->sge.prd.curr->address = cpu_to_le64(addr);\n\n\t\t\t\t \n\t\t\t\tsgc->cur_offset += len;\n\t\t\t\tsgc->length -= len;\n\n\t\t\t\t \n\t\t\t\tnumchain = 0;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (sgc->sge.prd.chain) {\n\t\t\t\t \n\n\t\t\t\tsgc->sge.prd.chain->ctl_len |= cpu_to_le32(\n\t\t\t\t\tsgc->sge.prd.sgl_max_cnt);\n\t\t\t}\n\n\t\t\t \n\n\t\t\tsgl = esas2r_alloc_sgl(a);\n\n\t\t\tif (unlikely(sgl == NULL))\n\t\t\t\treturn false;\n\n\t\t\t \n\t\t\tlist_add(&sgl->next_desc, &rq->sg_table_head);\n\n\t\t\t \n\n\t\t\tsgc->sge.prd.chain = sgc->sge.prd.curr;\n\n\t\t\tsgc->sge.prd.chain->ctl_len = cpu_to_le32(PRD_CHAIN);\n\t\t\tsgc->sge.prd.chain->address =\n\t\t\t\tcpu_to_le64(sgl->phys_addr);\n\n\t\t\t \n\n\t\t\tsgc->sge.prd.curr =\n\t\t\t\t(struct atto_physical_region_description *)sgl\n\t\t\t\t->\n\t\t\t\tvirt_addr;\n\t\t\tsgc->sge.prd.sge_cnt = sgc->sge.prd.sgl_max_cnt - 1;\n\t\t}\n\n\t\tsgc->sge.prd.sge_cnt--;\n\t\t \n\t\tsgc->sge.prd.curr->ctl_len = cpu_to_le32(PRD_DATA | len);\n\t\tsgc->sge.prd.curr->address = cpu_to_le64(addr);\n\n\t\t \n\n\t\tsgc->sge.prd.curr++;\n\n\t\t \n\n\t\tsgc->cur_offset += len;\n\t\tsgc->length -= len;\n\n\t\t \n\n\t\tif (rem) {\n\t\t\taddr += len;\n\t\t\tlen = rem;\n\t\t\trem = 0;\n\t\t\tgoto another_entry;\n\t\t}\n\t}\n\n\tif (!list_empty(&rq->sg_table_head)) {\n\t\tif (sgc->sge.prd.chain) {\n\t\t\tsgc->sge.prd.chain->ctl_len |=\n\t\t\t\tcpu_to_le32(sgc->sge.prd.sgl_max_cnt\n\t\t\t\t\t    - sgc->sge.prd.sge_cnt\n\t\t\t\t\t    - numchain);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool esas2r_build_sg_list_prd(struct esas2r_adapter *a,\n\t\t\t      struct esas2r_sg_context *sgc)\n{\n\tstruct esas2r_request *rq = sgc->first_req;\n\tu32 len = sgc->length;\n\tstruct esas2r_target *t = a->targetdb + rq->target_id;\n\tu8 is_i_o = 0;\n\tu16 reqsize;\n\tstruct atto_physical_region_description *curr_iblk_chn;\n\tu8 *cdb = (u8 *)&rq->vrq->scsi.cdb[0];\n\n\t \n\n\tif (rq->vrq->scsi.function == VDA_FUNC_SCSI\n\t    && t->target_state == TS_PRESENT\n\t    && !(t->flags & TF_PASS_THRU)) {\n\t\tu32 lbalo = 0;\n\n\t\tswitch (rq->vrq->scsi.cdb[0]) {\n\t\tcase    READ_16:\n\t\tcase    WRITE_16:\n\t\t{\n\t\t\tlbalo =\n\t\t\t\tMAKEDWORD(MAKEWORD(cdb[9],\n\t\t\t\t\t\t   cdb[8]),\n\t\t\t\t\t  MAKEWORD(cdb[7],\n\t\t\t\t\t\t   cdb[6]));\n\t\t\tis_i_o = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase    READ_12:\n\t\tcase    WRITE_12:\n\t\tcase    READ_10:\n\t\tcase    WRITE_10:\n\t\t{\n\t\t\tlbalo =\n\t\t\t\tMAKEDWORD(MAKEWORD(cdb[5],\n\t\t\t\t\t\t   cdb[4]),\n\t\t\t\t\t  MAKEWORD(cdb[3],\n\t\t\t\t\t\t   cdb[2]));\n\t\t\tis_i_o = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase    READ_6:\n\t\tcase    WRITE_6:\n\t\t{\n\t\t\tlbalo =\n\t\t\t\tMAKEDWORD(MAKEWORD(cdb[3],\n\t\t\t\t\t\t   cdb[2]),\n\t\t\t\t\t  MAKEWORD(cdb[1] & 0x1F,\n\t\t\t\t\t\t   0));\n\t\t\tis_i_o = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_i_o) {\n\t\t\tu32 startlba;\n\n\t\t\trq->vrq->scsi.iblk_cnt_prd = 0;\n\n\t\t\t \n\t\t\tstartlba = t->inter_block - (lbalo & (t->inter_block -\n\t\t\t\t\t\t\t      1));\n\t\t\tsgc->length = startlba * t->block_size;\n\n\t\t\t \n\t\t\tif ((lbalo & (t->inter_block - 1)) == 0)\n\t\t\t\trq->flags |= RF_1ST_IBLK_BASE;\n\n\t\t\tif (sgc->length > len)\n\t\t\t\tsgc->length = len;\n\t\t} else {\n\t\t\tsgc->length = len;\n\t\t}\n\t} else {\n\t\tsgc->length = len;\n\t}\n\n\t \n\n\tcurr_iblk_chn =\n\t\t(struct atto_physical_region_description *)sgc->sge.a64.curr;\n\n\tsgc->sge.prd.sgl_max_cnt = sgl_page_size /\n\t\t\t\t   sizeof(struct\n\t\t\t\t\t  atto_physical_region_description);\n\n\t \n\n\twhile (len) {\n\t\tsgc->sge.prd.sge_cnt = 0;\n\t\tsgc->sge.prd.chain = NULL;\n\t\tsgc->sge.prd.curr = curr_iblk_chn;\n\n\t\t \n\n\t\tlen -= sgc->length;\n\n\t\t \n\n\t\tif (unlikely(!esas2r_build_prd_iblk(a, sgc)))\n\t\t\treturn false;\n\n\t\tcurr_iblk_chn++;\n\n\t\tif (is_i_o) {\n\t\t\trq->vrq->scsi.iblk_cnt_prd++;\n\n\t\t\tif (len > t->inter_byte)\n\t\t\t\tsgc->length = t->inter_byte;\n\t\t\telse\n\t\t\t\tsgc->length = len;\n\t\t}\n\t}\n\n\t \n\n\treqsize = ((u16)((u8 *)curr_iblk_chn - (u8 *)rq->vrq))\n\t\t  / sizeof(u32);\n\n\t \n\n\tif (reqsize > rq->vda_req_sz)\n\t\trq->vda_req_sz = reqsize;\n\n\treturn true;\n}\n\nstatic void esas2r_handle_pending_reset(struct esas2r_adapter *a, u32 currtime)\n{\n\tu32 delta = currtime - a->chip_init_time;\n\n\tif (delta <= ESAS2R_CHPRST_WAIT_TIME) {\n\t\t \n\t} else if (delta >= ESAS2R_CHPRST_TIME) {\n\t\t \n\t\tesas2r_local_reset_adapter(a);\n\t} else {\n\t\t \n\t\tu32 doorbell;\n\n\t\tdoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\n\t\tif (doorbell == 0xFFFFFFFF || !(doorbell & DRBL_FORCE_INT)) {\n\t\t\tesas2r_force_interrupt(a);\n\t\t} else {\n\t\t\tu32 ver = (doorbell & DRBL_FW_VER_MSK);\n\n\t\t\t \n\t\t\tesas2r_write_register_dword(a, MU_DOORBELL_OUT,\n\t\t\t\t\t\t    doorbell);\n\t\t\tif (ver == DRBL_FW_VER_0) {\n\t\t\t\tset_bit(AF_CHPRST_DETECTED, &a->flags);\n\t\t\t\tset_bit(AF_LEGACY_SGE_MODE, &a->flags);\n\n\t\t\t\ta->max_vdareq_size = 128;\n\t\t\t\ta->build_sgl = esas2r_build_sg_list_sge;\n\t\t\t} else if (ver == DRBL_FW_VER_1) {\n\t\t\t\tset_bit(AF_CHPRST_DETECTED, &a->flags);\n\t\t\t\tclear_bit(AF_LEGACY_SGE_MODE, &a->flags);\n\n\t\t\t\ta->max_vdareq_size = 1024;\n\t\t\t\ta->build_sgl = esas2r_build_sg_list_prd;\n\t\t\t} else {\n\t\t\t\tesas2r_local_reset_adapter(a);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n \nvoid esas2r_timer_tick(struct esas2r_adapter *a)\n{\n\tu32 currtime = jiffies_to_msecs(jiffies);\n\tu32 deltatime = currtime - a->last_tick_time;\n\n\ta->last_tick_time = currtime;\n\n\t \n\tif (a->chip_uptime &&\n\t    !test_bit(AF_CHPRST_PENDING, &a->flags) &&\n\t    !test_bit(AF_DISC_PENDING, &a->flags)) {\n\t\tif (deltatime >= a->chip_uptime)\n\t\t\ta->chip_uptime = 0;\n\t\telse\n\t\t\ta->chip_uptime -= deltatime;\n\t}\n\n\tif (test_bit(AF_CHPRST_PENDING, &a->flags)) {\n\t\tif (!test_bit(AF_CHPRST_NEEDED, &a->flags) &&\n\t\t    !test_bit(AF_CHPRST_DETECTED, &a->flags))\n\t\t\tesas2r_handle_pending_reset(a, currtime);\n\t} else {\n\t\tif (test_bit(AF_DISC_PENDING, &a->flags))\n\t\t\tesas2r_disc_check_complete(a);\n\t\tif (test_bit(AF_HEARTBEAT_ENB, &a->flags)) {\n\t\t\tif (test_bit(AF_HEARTBEAT, &a->flags)) {\n\t\t\t\tif ((currtime - a->heartbeat_time) >=\n\t\t\t\t    ESAS2R_HEARTBEAT_TIME) {\n\t\t\t\t\tclear_bit(AF_HEARTBEAT, &a->flags);\n\t\t\t\t\tesas2r_hdebug(\"heartbeat failed\");\n\t\t\t\t\tesas2r_log(ESAS2R_LOG_CRIT,\n\t\t\t\t\t\t   \"heartbeat failed\");\n\t\t\t\t\tesas2r_bugon();\n\t\t\t\t\tesas2r_local_reset_adapter(a);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tset_bit(AF_HEARTBEAT, &a->flags);\n\t\t\t\ta->heartbeat_time = currtime;\n\t\t\t\tesas2r_force_interrupt(a);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (atomic_read(&a->disable_cnt) == 0)\n\t\tesas2r_do_deferred_processes(a);\n}\n\n \nbool esas2r_send_task_mgmt(struct esas2r_adapter *a,\n\t\t\t   struct esas2r_request *rqaux, u8 task_mgt_func)\n{\n\tu16 targetid = rqaux->target_id;\n\tu8 lun = (u8)le32_to_cpu(rqaux->vrq->scsi.flags);\n\tbool ret = false;\n\tstruct esas2r_request *rq;\n\tstruct list_head *next, *element;\n\tunsigned long flags;\n\n\tLIST_HEAD(comp_list);\n\n\tesas2r_trace_enter();\n\tesas2r_trace(\"rqaux:%p\", rqaux);\n\tesas2r_trace(\"task_mgt_func:%x\", task_mgt_func);\n\tspin_lock_irqsave(&a->queue_lock, flags);\n\n\t \n\tlist_for_each_safe(element, next, &a->defer_list) {\n\t\trq = list_entry(element, struct esas2r_request, req_list);\n\n\t\tif (rq->vrq->scsi.function == VDA_FUNC_SCSI\n\t\t    && rq->target_id == targetid\n\t\t    && (((u8)le32_to_cpu(rq->vrq->scsi.flags)) == lun\n\t\t\t|| task_mgt_func == 0x20)) {  \n\t\t\t \n\t\t\tif (rq->req_stat == RS_PENDING) {\n\t\t\t\t \n\t\t\t\tif (esas2r_ioreq_aborted(a, rq, RS_ABORTED))\n\t\t\t\t\tlist_add_tail(&rq->comp_list,\n\t\t\t\t\t\t      &comp_list);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\trqaux->sense_len = 0;\n\trqaux->vrq->scsi.length = 0;\n\trqaux->target_id = targetid;\n\trqaux->vrq->scsi.flags |= cpu_to_le32(lun);\n\tmemset(rqaux->vrq->scsi.cdb, 0, sizeof(rqaux->vrq->scsi.cdb));\n\trqaux->vrq->scsi.flags |=\n\t\tcpu_to_le16(task_mgt_func * LOBIT(FCP_CMND_TM_MASK));\n\n\tif (test_bit(AF_FLASHING, &a->flags)) {\n\t\t \n\t\trqaux->req_stat = RS_SUCCESS;\n\n\t\tlist_for_each_safe(element, next, &a->active_list) {\n\t\t\trq = list_entry(element, struct esas2r_request,\n\t\t\t\t\treq_list);\n\t\t\tif (rq->vrq->scsi.function == VDA_FUNC_SCSI\n\t\t\t    && rq->target_id == targetid\n\t\t\t    && (((u8)le32_to_cpu(rq->vrq->scsi.flags)) == lun\n\t\t\t\t|| task_mgt_func == 0x20))   \n\t\t\t\trqaux->req_stat = RS_BUSY;\n\t\t}\n\n\t\tret = true;\n\t}\n\n\tspin_unlock_irqrestore(&a->queue_lock, flags);\n\n\tif (!test_bit(AF_FLASHING, &a->flags))\n\t\tesas2r_start_request(a, rqaux);\n\n\tesas2r_comp_list_drain(a, &comp_list);\n\n\tif (atomic_read(&a->disable_cnt) == 0)\n\t\tesas2r_do_deferred_processes(a);\n\n\tesas2r_trace_exit();\n\n\treturn ret;\n}\n\nvoid esas2r_reset_bus(struct esas2r_adapter *a)\n{\n\tesas2r_log(ESAS2R_LOG_INFO, \"performing a bus reset\");\n\n\tif (!test_bit(AF_DEGRADED_MODE, &a->flags) &&\n\t    !test_bit(AF_CHPRST_PENDING, &a->flags) &&\n\t    !test_bit(AF_DISC_PENDING, &a->flags)) {\n\t\tset_bit(AF_BUSRST_NEEDED, &a->flags);\n\t\tset_bit(AF_BUSRST_PENDING, &a->flags);\n\t\tset_bit(AF_OS_RESET, &a->flags);\n\n\t\tesas2r_schedule_tasklet(a);\n\t}\n}\n\nbool esas2r_ioreq_aborted(struct esas2r_adapter *a, struct esas2r_request *rq,\n\t\t\t  u8 status)\n{\n\tesas2r_trace_enter();\n\tesas2r_trace(\"rq:%p\", rq);\n\tlist_del_init(&rq->req_list);\n\tif (rq->timeout > RQ_MAX_TIMEOUT) {\n\t\t \n\t\trq->req_stat = RS_BUSY;\n\t\tesas2r_trace_exit();\n\t\treturn true;\n\t}\n\n\trq->req_stat = status;\n\tesas2r_trace_exit();\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}