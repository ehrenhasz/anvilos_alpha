{
  "module_name": "esas2r_flash.c",
  "hash_id": "176dfb2823a259209e097ae66e64767b7c3b904b65d3e75a90706dbd00f237c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/esas2r/esas2r_flash.c",
  "human_readable_source": "\n \n\n#include \"esas2r.h\"\n\n \n#define esas2r_nvramcalc_cksum(n)     \\\n\t(esas2r_calc_byte_cksum((u8 *)(n), sizeof(struct esas2r_sas_nvram), \\\n\t\t\t\tSASNVR_CKSUM_SEED))\n#define esas2r_nvramcalc_xor_cksum(n)  \\\n\t(esas2r_calc_byte_xor_cksum((u8 *)(n), \\\n\t\t\t\t    sizeof(struct esas2r_sas_nvram), 0))\n\n#define ESAS2R_FS_DRVR_VER 2\n\nstatic struct esas2r_sas_nvram default_sas_nvram = {\n\t{ 'E',\t'S',  'A',  'S'\t\t\t     },  \n\tSASNVR_VERSION,                                  \n\t0,                                               \n\t31,                                              \n\tSASNVR_PCILAT_MAX,                               \n\tSASNVR1_BOOT_DRVR,                               \n\tSASNVR2_HEARTBEAT   | SASNVR2_SINGLE_BUS         \n\t| SASNVR2_SW_MUX_CTRL,\n\tSASNVR_COAL_DIS,                                 \n\tSASNVR_CMDTHR_NONE,                              \n\t3,                                               \n\t1,                                               \n\t0,                                               \n\t0,                                               \n\t{ 0x50, 0x01, 0x08, 0x60,                        \n\t  0x00, 0x00, 0x00, 0x00 },\n\t{ SASNVR_SPEED_AUTO },                           \n\t{ SASNVR_MUX_DISABLED },                         \n\t{ 0 },                                           \n\tSASNVR_SORT_SAS_ADDR,                            \n\t3,                                               \n\t3,                                               \n\t0,                                               \n\t{ 0 },                                           \n\tSASNVR_VSMH_DISABLED,                            \n\tSASNVR_RWM_DEFAULT,                              \n\t0,                                               \n\t{ 0 }                                            \n};\n\nstatic u8 cmd_to_fls_func[] = {\n\t0xFF,\n\tVDA_FLASH_READ,\n\tVDA_FLASH_BEGINW,\n\tVDA_FLASH_WRITE,\n\tVDA_FLASH_COMMIT,\n\tVDA_FLASH_CANCEL\n};\n\nstatic u8 esas2r_calc_byte_xor_cksum(u8 *addr, u32 len, u8 seed)\n{\n\tu32 cksum = seed;\n\tu8 *p = (u8 *)&cksum;\n\n\twhile (len) {\n\t\tif (((uintptr_t)addr & 3) == 0)\n\t\t\tbreak;\n\n\t\tcksum = cksum ^ *addr;\n\t\taddr++;\n\t\tlen--;\n\t}\n\twhile (len >= sizeof(u32)) {\n\t\tcksum = cksum ^ *(u32 *)addr;\n\t\taddr += 4;\n\t\tlen -= 4;\n\t}\n\twhile (len--) {\n\t\tcksum = cksum ^ *addr;\n\t\taddr++;\n\t}\n\treturn p[0] ^ p[1] ^ p[2] ^ p[3];\n}\n\nstatic u8 esas2r_calc_byte_cksum(void *addr, u32 len, u8 seed)\n{\n\tu8 *p = (u8 *)addr;\n\tu8 cksum = seed;\n\n\twhile (len--)\n\t\tcksum = cksum + p[len];\n\treturn cksum;\n}\n\n \nstatic void esas2r_fmapi_callback(struct esas2r_adapter *a,\n\t\t\t\t  struct esas2r_request *rq)\n{\n\tstruct atto_vda_flash_req *vrq = &rq->vrq->flash;\n\tstruct esas2r_flash_context *fc =\n\t\t(struct esas2r_flash_context *)rq->interrupt_cx;\n\n\tif (rq->req_stat == RS_SUCCESS) {\n\t\t \n\t\tswitch (vrq->sub_func) {\n\t\tcase VDA_FLASH_BEGINW:\n\t\t\tif (fc->sgc.cur_offset == NULL)\n\t\t\t\tgoto commit;\n\n\t\t\tvrq->sub_func = VDA_FLASH_WRITE;\n\t\t\trq->req_stat = RS_PENDING;\n\t\t\tbreak;\n\n\t\tcase VDA_FLASH_WRITE:\ncommit:\n\t\t\tvrq->sub_func = VDA_FLASH_COMMIT;\n\t\t\trq->req_stat = RS_PENDING;\n\t\t\trq->interrupt_cb = fc->interrupt_cb;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rq->req_stat != RS_PENDING)\n\t\t \n\t\t(*fc->interrupt_cb)(a, rq);\n}\n\n \nstatic void build_flash_msg(struct esas2r_adapter *a,\n\t\t\t    struct esas2r_request *rq)\n{\n\tstruct esas2r_flash_context *fc =\n\t\t(struct esas2r_flash_context *)rq->interrupt_cx;\n\tstruct esas2r_sg_context *sgc = &fc->sgc;\n\tu8 cksum = 0;\n\n\t \n\tif (fc->func == VDA_FLASH_BEGINW) {\n\t\tif (sgc->cur_offset)\n\t\t\tcksum = esas2r_calc_byte_xor_cksum(sgc->cur_offset,\n\t\t\t\t\t\t\t   sgc->length,\n\t\t\t\t\t\t\t   0);\n\t\trq->interrupt_cb = esas2r_fmapi_callback;\n\t} else {\n\t\trq->interrupt_cb = fc->interrupt_cb;\n\t}\n\tesas2r_build_flash_req(a,\n\t\t\t       rq,\n\t\t\t       fc->func,\n\t\t\t       cksum,\n\t\t\t       fc->flsh_addr,\n\t\t\t       sgc->length);\n\n\tesas2r_rq_free_sg_lists(rq, a);\n\n\t \n\tfc->curr_len = fc->sgc.length;\n\n\tif (sgc->cur_offset) {\n\t\t \n\t\tesas2r_sgc_init(sgc, a, rq, &rq->vrq->flash.data.sge[0]);\n\n\t\tif (!esas2r_build_sg_list(a, rq, sgc)) {\n\t\t\trq->req_stat = RS_BUSY;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tfc->sgc.length = 0;\n\t}\n\n\t \n\tfc->flsh_addr += fc->curr_len;\n}\n\n \nstatic bool load_image(struct esas2r_adapter *a, struct esas2r_request *rq)\n{\n\t \n\trq->req_stat = RS_PENDING;\n\tif (test_bit(AF_DEGRADED_MODE, &a->flags))\n\t\t ;\n\telse\n\t\tbuild_flash_msg(a, rq);\n\n\treturn rq->req_stat == RS_PENDING;\n}\n\n \nstatic void fix_bios(struct esas2r_adapter *a, struct esas2r_flash_img *fi)\n{\n\tstruct esas2r_component_header *ch = &fi->cmp_hdr[CH_IT_BIOS];\n\tstruct esas2r_pc_image *pi;\n\tstruct esas2r_boot_header *bh;\n\n\tpi = (struct esas2r_pc_image *)((u8 *)fi + ch->image_offset);\n\tbh =\n\t\t(struct esas2r_boot_header *)((u8 *)pi +\n\t\t\t\t\t      le16_to_cpu(pi->header_offset));\n\tbh->device_id = cpu_to_le16(a->pcid->device);\n\n\t \n\tif (pi->pnp_offset) {\n\t\tu8 *pnp_header_bytes =\n\t\t\t((u8 *)pi + le16_to_cpu(pi->pnp_offset));\n\n\t\t \n\t\t*((u32 *)&pnp_header_bytes[10]) =\n\t\t\tcpu_to_le32(MAKEDWORD(a->pcid->subsystem_vendor,\n\t\t\t\t\t      a->pcid->subsystem_device));\n\n\t\t \n\t\tpnp_header_bytes[9] -= esas2r_calc_byte_cksum(pnp_header_bytes,\n\t\t\t\t\t\t\t      32, 0);\n\t}\n\n\t \n\tpi->checksum = pi->checksum -\n\t\t       esas2r_calc_byte_cksum((u8 *)pi, ch->length, 0);\n}\n\nstatic void fix_efi(struct esas2r_adapter *a, struct esas2r_flash_img *fi)\n{\n\tstruct esas2r_component_header *ch = &fi->cmp_hdr[CH_IT_EFI];\n\tu32 len = ch->length;\n\tu32 offset = ch->image_offset;\n\tstruct esas2r_efi_image *ei;\n\tstruct esas2r_boot_header *bh;\n\n\twhile (len) {\n\t\tu32 thislen;\n\n\t\tei = (struct esas2r_efi_image *)((u8 *)fi + offset);\n\t\tbh = (struct esas2r_boot_header *)((u8 *)ei +\n\t\t\t\t\t\t   le16_to_cpu(\n\t\t\t\t\t\t\t   ei->header_offset));\n\t\tbh->device_id = cpu_to_le16(a->pcid->device);\n\t\tthislen = (u32)le16_to_cpu(bh->image_length) * 512;\n\n\t\tif (thislen > len)\n\t\t\tbreak;\n\n\t\tlen -= thislen;\n\t\toffset += thislen;\n\t}\n}\n\n \nstatic bool complete_fmapi_req(struct esas2r_adapter *a,\n\t\t\t       struct esas2r_request *rq, u8 fi_stat)\n{\n\tstruct esas2r_flash_context *fc =\n\t\t(struct esas2r_flash_context *)rq->interrupt_cx;\n\tstruct esas2r_flash_img *fi = fc->fi;\n\n\tfi->status = fi_stat;\n\tfi->driver_error = rq->req_stat;\n\trq->interrupt_cb = NULL;\n\trq->req_stat = RS_SUCCESS;\n\n\tif (fi_stat != FI_STAT_IMG_VER)\n\t\tmemset(fc->scratch, 0, FM_BUF_SZ);\n\n\tesas2r_enable_heartbeat(a);\n\tclear_bit(AF_FLASH_LOCK, &a->flags);\n\treturn false;\n}\n\n \nstatic void fw_download_proc(struct esas2r_adapter *a,\n\t\t\t     struct esas2r_request *rq)\n{\n\tstruct esas2r_flash_context *fc =\n\t\t(struct esas2r_flash_context *)rq->interrupt_cx;\n\tstruct esas2r_flash_img *fi = fc->fi;\n\tstruct esas2r_component_header *ch;\n\tu32 len;\n\tu8 *p, *q;\n\n\t \n\tif (rq->req_stat != RS_SUCCESS)\n\t\tgoto error;\n\n\t \n\tif (fc->func == VDA_FLASH_READ\n\t    && fc->cmp_len) {\n\t\tch = &fi->cmp_hdr[fc->comp_typ];\n\n\t\tp = fc->scratch;\n\t\tq = (u8 *)fi                     \n\t\t    + ch->image_offset           \n\t\t    + ch->length                 \n\t\t    - fc->cmp_len;               \n\n\t\t \n\t\tfor (len = fc->curr_len; len; len--)\n\t\t\tif (*p++ != *q++)\n\t\t\t\tgoto error;\n\n\t\tfc->cmp_len -= fc->curr_len;  \n\n\t\t \n\t\tif (fc->cmp_len > FM_BUF_SZ)\n\t\t\tfc->sgc.length = FM_BUF_SZ;\n\t\telse\n\t\t\tfc->sgc.length = fc->cmp_len;\n\n\t\tfc->sgc.cur_offset = fc->sgc_offset +\n\t\t\t\t     ((u8 *)fc->scratch - (u8 *)fi);\n\t}\n\n\t \n\twhile (fc->sgc.length == 0) {\n\t\tch = &fi->cmp_hdr[fc->comp_typ];\n\n\t\tswitch (fc->task) {\n\t\tcase FMTSK_ERASE_BOOT:\n\t\t\t \n\t\t\tch = &fi->cmp_hdr[CH_IT_BIOS];\n\t\t\tif (ch->length == 0)\n\t\t\t\tgoto no_bios;\n\n\t\t\tfc->task = FMTSK_WRTBIOS;\n\t\t\tfc->func = VDA_FLASH_BEGINW;\n\t\t\tfc->comp_typ = CH_IT_BIOS;\n\t\t\tfc->flsh_addr = FLS_OFFSET_BOOT;\n\t\t\tfc->sgc.length = ch->length;\n\t\t\tfc->sgc.cur_offset = fc->sgc_offset +\n\t\t\t\t\t     ch->image_offset;\n\t\t\tbreak;\n\n\t\tcase FMTSK_WRTBIOS:\n\t\t\t \n\t\t\tfc->task = FMTSK_READBIOS;\n\t\t\tfc->func = VDA_FLASH_READ;\n\t\t\tfc->flsh_addr = FLS_OFFSET_BOOT;\n\t\t\tfc->cmp_len = ch->length;\n\t\t\tfc->sgc.length = FM_BUF_SZ;\n\t\t\tfc->sgc.cur_offset = fc->sgc_offset\n\t\t\t\t\t     + ((u8 *)fc->scratch -\n\t\t\t\t\t\t(u8 *)fi);\n\t\t\tbreak;\n\n\t\tcase FMTSK_READBIOS:\nno_bios:\n\t\t\t \n\t\t\tch->status = CH_STAT_SUCCESS;\n\n\t\t\t \n\t\t\tch = &fi->cmp_hdr[CH_IT_MAC];\n\t\t\tif (ch->length == 0)\n\t\t\t\tgoto no_mac;\n\n\t\t\tfc->task = FMTSK_WRTMAC;\n\t\t\tfc->func = VDA_FLASH_BEGINW;\n\t\t\tfc->comp_typ = CH_IT_MAC;\n\t\t\tfc->flsh_addr = FLS_OFFSET_BOOT\n\t\t\t\t\t+ fi->cmp_hdr[CH_IT_BIOS].length;\n\t\t\tfc->sgc.length = ch->length;\n\t\t\tfc->sgc.cur_offset = fc->sgc_offset +\n\t\t\t\t\t     ch->image_offset;\n\t\t\tbreak;\n\n\t\tcase FMTSK_WRTMAC:\n\t\t\t \n\t\t\tfc->task = FMTSK_READMAC;\n\t\t\tfc->func = VDA_FLASH_READ;\n\t\t\tfc->flsh_addr -= ch->length;\n\t\t\tfc->cmp_len = ch->length;\n\t\t\tfc->sgc.length = FM_BUF_SZ;\n\t\t\tfc->sgc.cur_offset = fc->sgc_offset\n\t\t\t\t\t     + ((u8 *)fc->scratch -\n\t\t\t\t\t\t(u8 *)fi);\n\t\t\tbreak;\n\n\t\tcase FMTSK_READMAC:\nno_mac:\n\t\t\t \n\t\t\tch->status = CH_STAT_SUCCESS;\n\n\t\t\t \n\t\t\tch = &fi->cmp_hdr[CH_IT_EFI];\n\t\t\tif (ch->length == 0)\n\t\t\t\tgoto no_efi;\n\n\t\t\tfc->task = FMTSK_WRTEFI;\n\t\t\tfc->func = VDA_FLASH_BEGINW;\n\t\t\tfc->comp_typ = CH_IT_EFI;\n\t\t\tfc->flsh_addr = FLS_OFFSET_BOOT\n\t\t\t\t\t+ fi->cmp_hdr[CH_IT_BIOS].length\n\t\t\t\t\t+ fi->cmp_hdr[CH_IT_MAC].length;\n\t\t\tfc->sgc.length = ch->length;\n\t\t\tfc->sgc.cur_offset = fc->sgc_offset +\n\t\t\t\t\t     ch->image_offset;\n\t\t\tbreak;\n\n\t\tcase FMTSK_WRTEFI:\n\t\t\t \n\t\t\tfc->task = FMTSK_READEFI;\n\t\t\tfc->func = VDA_FLASH_READ;\n\t\t\tfc->flsh_addr -= ch->length;\n\t\t\tfc->cmp_len = ch->length;\n\t\t\tfc->sgc.length = FM_BUF_SZ;\n\t\t\tfc->sgc.cur_offset = fc->sgc_offset\n\t\t\t\t\t     + ((u8 *)fc->scratch -\n\t\t\t\t\t\t(u8 *)fi);\n\t\t\tbreak;\n\n\t\tcase FMTSK_READEFI:\nno_efi:\n\t\t\t \n\t\t\tch->status = CH_STAT_SUCCESS;\n\n\t\t\t \n\t\t\tch = &fi->cmp_hdr[CH_IT_CFG];\n\n\t\t\tif (ch->length == 0)\n\t\t\t\tgoto no_cfg;\n\t\t\tfc->task = FMTSK_WRTCFG;\n\t\t\tfc->func = VDA_FLASH_BEGINW;\n\t\t\tfc->comp_typ = CH_IT_CFG;\n\t\t\tfc->flsh_addr = FLS_OFFSET_CPYR - ch->length;\n\t\t\tfc->sgc.length = ch->length;\n\t\t\tfc->sgc.cur_offset = fc->sgc_offset +\n\t\t\t\t\t     ch->image_offset;\n\t\t\tbreak;\n\n\t\tcase FMTSK_WRTCFG:\n\t\t\t \n\t\t\tfc->task = FMTSK_READCFG;\n\t\t\tfc->func = VDA_FLASH_READ;\n\t\t\tfc->flsh_addr = FLS_OFFSET_CPYR - ch->length;\n\t\t\tfc->cmp_len = ch->length;\n\t\t\tfc->sgc.length = FM_BUF_SZ;\n\t\t\tfc->sgc.cur_offset = fc->sgc_offset\n\t\t\t\t\t     + ((u8 *)fc->scratch -\n\t\t\t\t\t\t(u8 *)fi);\n\t\t\tbreak;\n\n\t\tcase FMTSK_READCFG:\nno_cfg:\n\t\t\t \n\t\t\tch->status = CH_STAT_SUCCESS;\n\n\t\t\t \n\t\t\tif (test_bit(AF_DEGRADED_MODE, &a->flags))\n\t\t\t\tesas2r_local_reset_adapter(a);\n\n\t\t\ta->flash_ver = fi->cmp_hdr[CH_IT_BIOS].version;\n\t\t\tesas2r_print_flash_rev(a);\n\n\t\t\t \n\t\t\tmemcpy(a->image_type, fi->rel_version,\n\t\t\t       sizeof(fi->rel_version));\n\t\t\tcomplete_fmapi_req(a, rq, FI_STAT_SUCCESS);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (fc->func == VDA_FLASH_READ\n\t\t    && fc->sgc.length > fc->cmp_len)\n\t\t\tfc->sgc.length = fc->cmp_len;\n\t}\n\n\t \n\tif (!load_image(a, rq)) {\nerror:\n\t\tif (fc->comp_typ < fi->num_comps) {\n\t\t\tch = &fi->cmp_hdr[fc->comp_typ];\n\t\t\tch->status = CH_STAT_FAILED;\n\t\t}\n\n\t\tcomplete_fmapi_req(a, rq, FI_STAT_FAILED);\n\t}\n}\n\n \nstatic u8 get_fi_adap_type(struct esas2r_adapter *a)\n{\n\tu8 type;\n\n\t \n\tswitch (a->pcid->device) {\n\tcase ATTO_DID_INTEL_IOP348:\n\t\ttype = FI_AT_SUN_LAKE;\n\t\tbreak;\n\n\tcase ATTO_DID_MV_88RC9580:\n\tcase ATTO_DID_MV_88RC9580TS:\n\tcase ATTO_DID_MV_88RC9580TSE:\n\tcase ATTO_DID_MV_88RC9580TL:\n\t\ttype = FI_AT_MV_9580;\n\t\tbreak;\n\n\tdefault:\n\t\ttype = FI_AT_UNKNWN;\n\t\tbreak;\n\t}\n\n\treturn type;\n}\n\n \nstatic u32 chk_cfg(u8 *cfg, u32 length, u32 *flash_ver)\n{\n\tu16 *pw = (u16 *)cfg - 1;\n\tu32 sz = 0;\n\tu32 len = length;\n\n\tif (len == 0)\n\t\tlen = FM_BUF_SZ;\n\n\tif (flash_ver)\n\t\t*flash_ver = 0;\n\n\twhile (true) {\n\t\tu16 type;\n\t\tu16 size;\n\n\t\ttype = le16_to_cpu(*pw--);\n\t\tsize = le16_to_cpu(*pw--);\n\n\t\tif (type != FBT_CPYR\n\t\t    && type != FBT_SETUP\n\t\t    && type != FBT_FLASH_VER)\n\t\t\tbreak;\n\n\t\tif (type == FBT_FLASH_VER\n\t\t    && flash_ver)\n\t\t\t*flash_ver = le32_to_cpu(*(u32 *)(pw - 1));\n\n\t\tsz += size + (2 * sizeof(u16));\n\t\tpw -= size / sizeof(u16);\n\n\t\tif (sz > len - (2 * sizeof(u16)))\n\t\t\tbreak;\n\t}\n\n\t \n\tif (length && sz != length)\n\t\treturn 0;\n\n\treturn sz;\n}\n\n \nstatic u8 chk_boot(u8 *boot_img, u32 length)\n{\n\tstruct esas2r_boot_image *bi = (struct esas2r_boot_image *)boot_img;\n\tu16 hdroffset = le16_to_cpu(bi->header_offset);\n\tstruct esas2r_boot_header *bh;\n\n\tif (bi->signature != le16_to_cpu(0xaa55)\n\t    || (long)hdroffset >\n\t    (long)(65536L - sizeof(struct esas2r_boot_header))\n\t    || (hdroffset & 3)\n\t    || (hdroffset < sizeof(struct esas2r_boot_image))\n\t    || ((u32)hdroffset + sizeof(struct esas2r_boot_header) > length))\n\t\treturn 0xff;\n\n\tbh = (struct esas2r_boot_header *)((char *)bi + hdroffset);\n\n\tif (bh->signature[0] != 'P'\n\t    || bh->signature[1] != 'C'\n\t    || bh->signature[2] != 'I'\n\t    || bh->signature[3] != 'R'\n\t    || le16_to_cpu(bh->struct_length) <\n\t    (u16)sizeof(struct esas2r_boot_header)\n\t    || bh->class_code[2] != 0x01\n\t    || bh->class_code[1] != 0x04\n\t    || bh->class_code[0] != 0x00\n\t    || (bh->code_type != CODE_TYPE_PC\n\t\t&& bh->code_type != CODE_TYPE_OPEN\n\t\t&& bh->code_type != CODE_TYPE_EFI))\n\t\treturn 0xff;\n\n\treturn bh->code_type;\n}\n\n \nstatic u16 calc_fi_checksum(struct esas2r_flash_context *fc)\n{\n\tstruct esas2r_flash_img *fi = fc->fi;\n\tu16 cksum;\n\tu32 len;\n\tu16 *pw;\n\n\tfor (len = (fi->length - fc->fi_hdr_len) / 2,\n\t     pw = (u16 *)((u8 *)fi + fc->fi_hdr_len),\n\t     cksum = 0;\n\t     len;\n\t     len--, pw++)\n\t\tcksum = cksum + le16_to_cpu(*pw);\n\n\treturn cksum;\n}\n\n \nstatic bool verify_fi(struct esas2r_adapter *a,\n\t\t      struct esas2r_flash_context *fc)\n{\n\tstruct esas2r_flash_img *fi = fc->fi;\n\tu8 type;\n\tbool imgerr;\n\tu16 i;\n\tu32 len;\n\tstruct esas2r_component_header *ch;\n\n\t \n\tlen = fi->length;\n\n\tif ((len & 1)\n\t    || len < fc->fi_hdr_len) {\n\t\tfi->status = FI_STAT_LENGTH;\n\t\treturn false;\n\t}\n\n\t \n\ttype = get_fi_adap_type(a);\n\tif ((type == FI_AT_UNKNWN) || (fi->adap_typ != type)) {\n\t\tfi->status = FI_STAT_ADAPTYP;\n\t\treturn false;\n\t}\n\n\t \n\timgerr = false;\n\n\tfor (i = 0, len = 0, ch = fi->cmp_hdr;\n\t     i < fi->num_comps;\n\t     i++, ch++) {\n\t\tbool cmperr = false;\n\n\t\t \n\t\tif (i != ch->img_type) {\n\t\t\timgerr = true;\n\t\t\tch->status = CH_STAT_INVALID;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (ch->img_type) {\n\t\tcase CH_IT_BIOS:\n\t\t\ttype = CODE_TYPE_PC;\n\t\t\tbreak;\n\n\t\tcase CH_IT_MAC:\n\t\t\ttype = CODE_TYPE_OPEN;\n\t\t\tbreak;\n\n\t\tcase CH_IT_EFI:\n\t\t\ttype = CODE_TYPE_EFI;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ch->img_type) {\n\t\tcase CH_IT_FW:\n\t\tcase CH_IT_NVR:\n\t\t\tbreak;\n\n\t\tcase CH_IT_BIOS:\n\t\tcase CH_IT_MAC:\n\t\tcase CH_IT_EFI:\n\t\t\tif (ch->length & 0x1ff)\n\t\t\t\tcmperr = true;\n\n\t\t\t \n\t\t\tif (ch->length == 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (chk_boot((u8 *)fi + ch->image_offset, ch->length)\n\t\t\t    != type)\n\t\t\t\tcmperr = true;\n\n\t\t\tbreak;\n\n\t\tcase CH_IT_CFG:\n\n\t\t\t \n\t\t\tif (ch->length == 0) {\n\t\t\t\tcmperr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!chk_cfg((u8 *)fi + ch->image_offset + ch->length,\n\t\t\t\t     ch->length, NULL))\n\t\t\t\tcmperr = true;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tfi->status = FI_STAT_UNKNOWN;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (cmperr) {\n\t\t\timgerr = true;\n\t\t\tch->status = CH_STAT_INVALID;\n\t\t} else {\n\t\t\tch->status = CH_STAT_PENDING;\n\t\t\tlen += ch->length;\n\t\t}\n\t}\n\n\tif (imgerr) {\n\t\tfi->status = FI_STAT_MISSING;\n\t\treturn false;\n\t}\n\n\t \n\tif (len != fi->length - fc->fi_hdr_len) {\n\t\tfi->status = FI_STAT_LENGTH;\n\t\treturn false;\n\t}\n\n\t \n\tif (fi->checksum != calc_fi_checksum(fc)) {\n\t\tfi->status = FI_STAT_CHKSUM;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic void esas2r_complete_fs_ioctl(struct esas2r_adapter *a,\n\t\t\t\t     struct esas2r_request *rq)\n{\n\tstruct esas2r_ioctl_fs *fs =\n\t\t(struct esas2r_ioctl_fs *)rq->interrupt_cx;\n\n\tif (rq->vrq->flash.sub_func == VDA_FLASH_COMMIT)\n\t\tesas2r_enable_heartbeat(a);\n\n\tfs->driver_error = rq->req_stat;\n\n\tif (fs->driver_error == RS_SUCCESS)\n\t\tfs->status = ATTO_STS_SUCCESS;\n\telse\n\t\tfs->status = ATTO_STS_FAILED;\n}\n\n \nbool esas2r_process_fs_ioctl(struct esas2r_adapter *a,\n\t\t\t     struct esas2r_ioctl_fs *fs,\n\t\t\t     struct esas2r_request *rq,\n\t\t\t     struct esas2r_sg_context *sgc)\n{\n\tu8 cmdcnt = (u8)ARRAY_SIZE(cmd_to_fls_func);\n\tstruct esas2r_ioctlfs_command *fsc = &fs->command;\n\tu8 func = 0;\n\tu32 datalen;\n\n\tfs->status = ATTO_STS_FAILED;\n\tfs->driver_error = RS_PENDING;\n\n\tif (fs->version > ESAS2R_FS_VER) {\n\t\tfs->status = ATTO_STS_INV_VERSION;\n\t\treturn false;\n\t}\n\n\tif (fsc->command >= cmdcnt) {\n\t\tfs->status = ATTO_STS_INV_FUNC;\n\t\treturn false;\n\t}\n\n\tfunc = cmd_to_fls_func[fsc->command];\n\tif (func == 0xFF) {\n\t\tfs->status = ATTO_STS_INV_FUNC;\n\t\treturn false;\n\t}\n\n\tif (fsc->command != ESAS2R_FS_CMD_CANCEL) {\n\t\tif ((a->pcid->device != ATTO_DID_MV_88RC9580\n\t\t     || fs->adap_type != ESAS2R_FS_AT_ESASRAID2)\n\t\t    && (a->pcid->device != ATTO_DID_MV_88RC9580TS\n\t\t\t|| fs->adap_type != ESAS2R_FS_AT_TSSASRAID2)\n\t\t    && (a->pcid->device != ATTO_DID_MV_88RC9580TSE\n\t\t\t|| fs->adap_type != ESAS2R_FS_AT_TSSASRAID2E)\n\t\t    && (a->pcid->device != ATTO_DID_MV_88RC9580TL\n\t\t\t|| fs->adap_type != ESAS2R_FS_AT_TLSASHBA)) {\n\t\t\tfs->status = ATTO_STS_INV_ADAPTER;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fs->driver_ver > ESAS2R_FS_DRVR_VER) {\n\t\t\tfs->status = ATTO_STS_INV_DRVR_VER;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (test_bit(AF_DEGRADED_MODE, &a->flags)) {\n\t\tfs->status = ATTO_STS_DEGRADED;\n\t\treturn false;\n\t}\n\n\trq->interrupt_cb = esas2r_complete_fs_ioctl;\n\trq->interrupt_cx = fs;\n\tdatalen = le32_to_cpu(fsc->length);\n\tesas2r_build_flash_req(a,\n\t\t\t       rq,\n\t\t\t       func,\n\t\t\t       fsc->checksum,\n\t\t\t       le32_to_cpu(fsc->flash_addr),\n\t\t\t       datalen);\n\n\tif (func == VDA_FLASH_WRITE\n\t    || func == VDA_FLASH_READ) {\n\t\tif (datalen == 0) {\n\t\t\tfs->status = ATTO_STS_INV_FUNC;\n\t\t\treturn false;\n\t\t}\n\n\t\tesas2r_sgc_init(sgc, a, rq, rq->vrq->flash.data.sge);\n\t\tsgc->length = datalen;\n\n\t\tif (!esas2r_build_sg_list(a, rq, sgc)) {\n\t\t\tfs->status = ATTO_STS_OUT_OF_RSRC;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (func == VDA_FLASH_COMMIT)\n\t\tesas2r_disable_heartbeat(a);\n\n\tesas2r_start_request(a, rq);\n\n\treturn true;\n}\n\nstatic bool esas2r_flash_access(struct esas2r_adapter *a, u32 function)\n{\n\tu32 starttime;\n\tu32 timeout;\n\tu32 intstat;\n\tu32 doorbell;\n\n\t \n\tif (function == DRBL_FLASH_REQ)\n\t\tesas2r_disable_chip_interrupts(a);\n\n\t \n\tesas2r_write_register_dword(a, MU_DOORBELL_IN, function);\n\n\t \n\tstarttime = jiffies_to_msecs(jiffies);\n\n\tif (test_bit(AF_CHPRST_PENDING, &a->flags) ||\n\t    test_bit(AF_DISC_PENDING, &a->flags))\n\t\ttimeout = 40000;\n\telse\n\t\ttimeout = 5000;\n\n\twhile (true) {\n\t\tintstat = esas2r_read_register_dword(a, MU_INT_STATUS_OUT);\n\n\t\tif (intstat & MU_INTSTAT_DRBL) {\n\t\t\t \n\t\t\tdoorbell =\n\t\t\t\tesas2r_read_register_dword(a, MU_DOORBELL_OUT);\n\t\t\tesas2r_write_register_dword(a, MU_DOORBELL_OUT,\n\t\t\t\t\t\t    doorbell);\n\t\t\tif (doorbell & function)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(100));\n\n\t\tif ((jiffies_to_msecs(jiffies) - starttime) > timeout) {\n\t\t\t \n\t\t\tif (function == DRBL_FLASH_REQ) {\n\t\t\t\tesas2r_hdebug(\"flash access timeout\");\n\t\t\t\tesas2r_write_register_dword(a, MU_DOORBELL_IN,\n\t\t\t\t\t\t\t    DRBL_FLASH_DONE);\n\t\t\t\tesas2r_enable_chip_interrupts(a);\n\t\t\t} else {\n\t\t\t\tesas2r_hdebug(\"flash release timeout\");\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\tif (function == DRBL_FLASH_DONE)\n\t\tesas2r_enable_chip_interrupts(a);\n\n\treturn true;\n}\n\n#define WINDOW_SIZE ((signed int)MW_DATA_WINDOW_SIZE)\n\nbool esas2r_read_flash_block(struct esas2r_adapter *a,\n\t\t\t     void *to,\n\t\t\t     u32 from,\n\t\t\t     u32 size)\n{\n\tu8 *end = (u8 *)to;\n\n\t \n\tif (!esas2r_flash_access(a, DRBL_FLASH_REQ))\n\t\treturn false;\n\n\twhile (size) {\n\t\tu32 len;\n\t\tu32 offset;\n\t\tu32 iatvr;\n\n\t\tif (test_bit(AF2_SERIAL_FLASH, &a->flags2))\n\t\t\tiatvr = MW_DATA_ADDR_SER_FLASH + (from & -WINDOW_SIZE);\n\t\telse\n\t\t\tiatvr = MW_DATA_ADDR_PAR_FLASH + (from & -WINDOW_SIZE);\n\n\t\tesas2r_map_data_window(a, iatvr);\n\t\toffset = from & (WINDOW_SIZE - 1);\n\t\tlen = size;\n\n\t\tif (len > WINDOW_SIZE - offset)\n\t\t\tlen = WINDOW_SIZE - offset;\n\n\t\tfrom += len;\n\t\tsize -= len;\n\n\t\twhile (len--) {\n\t\t\t*end++ = esas2r_read_data_byte(a, offset);\n\t\t\toffset++;\n\t\t}\n\t}\n\n\t \n\tesas2r_flash_access(a, DRBL_FLASH_DONE);\n\treturn true;\n}\n\nbool esas2r_read_flash_rev(struct esas2r_adapter *a)\n{\n\tu8 bytes[256];\n\tu16 *pw;\n\tu16 *pwstart;\n\tu16 type;\n\tu16 size;\n\tu32 sz;\n\n\tsz = sizeof(bytes);\n\tpw = (u16 *)(bytes + sz);\n\tpwstart = (u16 *)bytes + 2;\n\n\tif (!esas2r_read_flash_block(a, bytes, FLS_OFFSET_CPYR - sz, sz))\n\t\tgoto invalid_rev;\n\n\twhile (pw >= pwstart) {\n\t\tpw--;\n\t\ttype = le16_to_cpu(*pw);\n\t\tpw--;\n\t\tsize = le16_to_cpu(*pw);\n\t\tpw -= size / 2;\n\n\t\tif (type == FBT_CPYR\n\t\t    || type == FBT_SETUP\n\t\t    || pw < pwstart)\n\t\t\tcontinue;\n\n\t\tif (type == FBT_FLASH_VER)\n\t\t\ta->flash_ver = le32_to_cpu(*(u32 *)pw);\n\n\t\tbreak;\n\t}\n\ninvalid_rev:\n\treturn esas2r_print_flash_rev(a);\n}\n\nbool esas2r_print_flash_rev(struct esas2r_adapter *a)\n{\n\tu16 year = LOWORD(a->flash_ver);\n\tu8 day = LOBYTE(HIWORD(a->flash_ver));\n\tu8 month = HIBYTE(HIWORD(a->flash_ver));\n\n\tif (day == 0\n\t    || month == 0\n\t    || day > 31\n\t    || month > 12\n\t    || year < 2006\n\t    || year > 9999) {\n\t\tstrcpy(a->flash_rev, \"not found\");\n\t\ta->flash_ver = 0;\n\t\treturn false;\n\t}\n\n\tsprintf(a->flash_rev, \"%02d/%02d/%04d\", month, day, year);\n\tesas2r_hdebug(\"flash version: %s\", a->flash_rev);\n\treturn true;\n}\n\n \nbool esas2r_read_image_type(struct esas2r_adapter *a)\n{\n\tu8 bytes[256];\n\tstruct esas2r_boot_image *bi;\n\tstruct esas2r_boot_header *bh;\n\tu32 sz;\n\tu32 len;\n\tu32 offset;\n\n\t \n\tsz = sizeof(bytes);\n\tlen = FLS_LENGTH_BOOT;\n\toffset = 0;\n\n\twhile (true) {\n\t\tif (!esas2r_read_flash_block(a, bytes, FLS_OFFSET_BOOT +\n\t\t\t\t\t     offset,\n\t\t\t\t\t     sz))\n\t\t\tgoto invalid_rev;\n\n\t\tbi = (struct esas2r_boot_image *)bytes;\n\t\tbh = (struct esas2r_boot_header *)((u8 *)bi +\n\t\t\t\t\t\t   le16_to_cpu(\n\t\t\t\t\t\t\t   bi->header_offset));\n\t\tif (bi->signature != cpu_to_le16(0xAA55))\n\t\t\tgoto invalid_rev;\n\n\t\tif (bh->code_type == CODE_TYPE_PC) {\n\t\t\tstrcpy(a->image_type, \"BIOS\");\n\n\t\t\treturn true;\n\t\t} else if (bh->code_type == CODE_TYPE_EFI) {\n\t\t\tstruct esas2r_efi_image *ei;\n\n\t\t\t \n\t\t\tei = (struct esas2r_efi_image *)bytes;\n\n\t\t\tswitch (le16_to_cpu(ei->machine_type)) {\n\t\t\tcase EFI_MACHINE_IA32:\n\t\t\t\tstrcpy(a->image_type, \"EFI 32-bit\");\n\t\t\t\treturn true;\n\n\t\t\tcase EFI_MACHINE_IA64:\n\t\t\t\tstrcpy(a->image_type, \"EFI itanium\");\n\t\t\t\treturn true;\n\n\t\t\tcase EFI_MACHINE_X64:\n\t\t\t\tstrcpy(a->image_type, \"EFI 64-bit\");\n\t\t\t\treturn true;\n\n\t\t\tcase EFI_MACHINE_EBC:\n\t\t\t\tstrcpy(a->image_type, \"EFI EBC\");\n\t\t\t\treturn true;\n\n\t\t\tdefault:\n\t\t\t\tgoto invalid_rev;\n\t\t\t}\n\t\t} else {\n\t\t\tu32 thislen;\n\n\t\t\t \n\t\t\tthislen = (u32)le16_to_cpu(bh->image_length) * 512;\n\t\t\tif (thislen == 0\n\t\t\t    || thislen + offset > len\n\t\t\t    || bh->indicator == INDICATOR_LAST)\n\t\t\t\tbreak;\n\n\t\t\toffset += thislen;\n\t\t}\n\t}\n\ninvalid_rev:\n\tstrcpy(a->image_type, \"no boot images\");\n\treturn false;\n}\n\n \nbool esas2r_nvram_read_direct(struct esas2r_adapter *a)\n{\n\tbool result;\n\n\tif (down_interruptible(&a->nvram_semaphore))\n\t\treturn false;\n\n\tif (!esas2r_read_flash_block(a, a->nvram, FLS_OFFSET_NVR,\n\t\t\t\t     sizeof(struct esas2r_sas_nvram))) {\n\t\tesas2r_hdebug(\"NVRAM read failed, using defaults\");\n\t\tup(&a->nvram_semaphore);\n\t\treturn false;\n\t}\n\n\tresult = esas2r_nvram_validate(a);\n\n\tup(&a->nvram_semaphore);\n\n\treturn result;\n}\n\n \nstatic void esas2r_nvram_callback(struct esas2r_adapter *a,\n\t\t\t\t  struct esas2r_request *rq)\n{\n\tstruct atto_vda_flash_req *vrq = &rq->vrq->flash;\n\n\tif (rq->req_stat == RS_SUCCESS) {\n\t\t \n\n\t\tswitch (vrq->sub_func) {\n\t\tcase VDA_FLASH_BEGINW:\n\t\t\tvrq->sub_func = VDA_FLASH_WRITE;\n\t\t\trq->req_stat = RS_PENDING;\n\t\t\tbreak;\n\n\t\tcase VDA_FLASH_WRITE:\n\t\t\tvrq->sub_func = VDA_FLASH_COMMIT;\n\t\t\trq->req_stat = RS_PENDING;\n\t\t\tbreak;\n\n\t\tcase VDA_FLASH_READ:\n\t\t\tesas2r_nvram_validate(a);\n\t\t\tbreak;\n\n\t\tcase VDA_FLASH_COMMIT:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rq->req_stat != RS_PENDING) {\n\t\t \n\t\tif (rq->req_stat == RS_SUCCESS)\n\t\t\tset_bit(AF_NVR_VALID, &a->flags);\n\t\telse\n\t\t\tclear_bit(AF_NVR_VALID, &a->flags);\n\n\t\tesas2r_enable_heartbeat(a);\n\n\t\tup(&a->nvram_semaphore);\n\t}\n}\n\n \nbool esas2r_nvram_write(struct esas2r_adapter *a, struct esas2r_request *rq,\n\t\t\tstruct esas2r_sas_nvram *nvram)\n{\n\tstruct esas2r_sas_nvram *n = nvram;\n\tu8 sas_address_bytes[8];\n\tu32 *sas_address_dwords = (u32 *)&sas_address_bytes[0];\n\tstruct atto_vda_flash_req *vrq = &rq->vrq->flash;\n\n\tif (test_bit(AF_DEGRADED_MODE, &a->flags))\n\t\treturn false;\n\n\tif (down_interruptible(&a->nvram_semaphore))\n\t\treturn false;\n\n\tif (n == NULL)\n\t\tn = a->nvram;\n\n\t \n\tif (n->version > SASNVR_VERSION) {\n\t\tup(&a->nvram_semaphore);\n\t\treturn false;\n\t}\n\n\tmemcpy(&sas_address_bytes[0], n->sas_addr, 8);\n\n\tif (sas_address_bytes[0] != 0x50\n\t    || sas_address_bytes[1] != 0x01\n\t    || sas_address_bytes[2] != 0x08\n\t    || (sas_address_bytes[3] & 0xF0) != 0x60\n\t    || ((sas_address_bytes[3] & 0x0F) | sas_address_dwords[1]) == 0) {\n\t\tup(&a->nvram_semaphore);\n\t\treturn false;\n\t}\n\n\tif (n->spin_up_delay > SASNVR_SPINUP_MAX)\n\t\tn->spin_up_delay = SASNVR_SPINUP_MAX;\n\n\tn->version = SASNVR_VERSION;\n\tn->checksum = n->checksum - esas2r_nvramcalc_cksum(n);\n\tmemcpy(a->nvram, n, sizeof(struct esas2r_sas_nvram));\n\n\t \n\tn = a->nvram;\n\tesas2r_disable_heartbeat(a);\n\n\tesas2r_build_flash_req(a,\n\t\t\t       rq,\n\t\t\t       VDA_FLASH_BEGINW,\n\t\t\t       esas2r_nvramcalc_xor_cksum(n),\n\t\t\t       FLS_OFFSET_NVR,\n\t\t\t       sizeof(struct esas2r_sas_nvram));\n\n\tif (test_bit(AF_LEGACY_SGE_MODE, &a->flags)) {\n\n\t\tvrq->data.sge[0].length =\n\t\t\tcpu_to_le32(SGE_LAST |\n\t\t\t\t    sizeof(struct esas2r_sas_nvram));\n\t\tvrq->data.sge[0].address = cpu_to_le64(\n\t\t\ta->uncached_phys + (u64)((u8 *)n - a->uncached));\n\t} else {\n\t\tvrq->data.prde[0].ctl_len =\n\t\t\tcpu_to_le32(sizeof(struct esas2r_sas_nvram));\n\t\tvrq->data.prde[0].address = cpu_to_le64(\n\t\t\ta->uncached_phys\n\t\t\t+ (u64)((u8 *)n - a->uncached));\n\t}\n\trq->interrupt_cb = esas2r_nvram_callback;\n\tesas2r_start_request(a, rq);\n\treturn true;\n}\n\n \nbool esas2r_nvram_validate(struct esas2r_adapter *a)\n{\n\tstruct esas2r_sas_nvram *n = a->nvram;\n\tbool rslt = false;\n\n\tif (n->signature[0] != 'E'\n\t    || n->signature[1] != 'S'\n\t    || n->signature[2] != 'A'\n\t    || n->signature[3] != 'S') {\n\t\tesas2r_hdebug(\"invalid NVRAM signature\");\n\t} else if (esas2r_nvramcalc_cksum(n)) {\n\t\tesas2r_hdebug(\"invalid NVRAM checksum\");\n\t} else if (n->version > SASNVR_VERSION) {\n\t\tesas2r_hdebug(\"invalid NVRAM version\");\n\t} else {\n\t\tset_bit(AF_NVR_VALID, &a->flags);\n\t\trslt = true;\n\t}\n\n\tif (rslt == false) {\n\t\tesas2r_hdebug(\"using defaults\");\n\t\tesas2r_nvram_set_defaults(a);\n\t}\n\n\treturn rslt;\n}\n\n \nvoid esas2r_nvram_set_defaults(struct esas2r_adapter *a)\n{\n\tstruct esas2r_sas_nvram *n = a->nvram;\n\tu32 time = jiffies_to_msecs(jiffies);\n\n\tclear_bit(AF_NVR_VALID, &a->flags);\n\t*n = default_sas_nvram;\n\tn->sas_addr[3] |= 0x0F;\n\tn->sas_addr[4] = HIBYTE(LOWORD(time));\n\tn->sas_addr[5] = LOBYTE(LOWORD(time));\n\tn->sas_addr[6] = a->pcid->bus->number;\n\tn->sas_addr[7] = a->pcid->devfn;\n}\n\nvoid esas2r_nvram_get_defaults(struct esas2r_adapter *a,\n\t\t\t       struct esas2r_sas_nvram *nvram)\n{\n\tu8 sas_addr[8];\n\n\t \n\tmemcpy(&sas_addr[0], a->nvram->sas_addr, 8);\n\t*nvram = default_sas_nvram;\n\tmemcpy(&nvram->sas_addr[0], &sas_addr[0], 8);\n}\n\nbool esas2r_fm_api(struct esas2r_adapter *a, struct esas2r_flash_img *fi,\n\t\t   struct esas2r_request *rq, struct esas2r_sg_context *sgc)\n{\n\tstruct esas2r_flash_context *fc = &a->flash_context;\n\tu8 j;\n\tstruct esas2r_component_header *ch;\n\n\tif (test_and_set_bit(AF_FLASH_LOCK, &a->flags)) {\n\t\t \n\t\tfi->status = FI_STAT_BUSY;\n\t\treturn false;\n\t}\n\n\tmemcpy(&fc->sgc, sgc, sizeof(struct esas2r_sg_context));\n\tsgc = &fc->sgc;\n\tfc->fi = fi;\n\tfc->sgc_offset = sgc->cur_offset;\n\trq->req_stat = RS_SUCCESS;\n\trq->interrupt_cx = fc;\n\n\tswitch (fi->fi_version) {\n\tcase FI_VERSION_1:\n\t\tfc->scratch = ((struct esas2r_flash_img *)fi)->scratch_buf;\n\t\tfc->num_comps = FI_NUM_COMPS_V1;\n\t\tfc->fi_hdr_len = sizeof(struct esas2r_flash_img);\n\t\tbreak;\n\n\tdefault:\n\t\treturn complete_fmapi_req(a, rq, FI_STAT_IMG_VER);\n\t}\n\n\tif (test_bit(AF_DEGRADED_MODE, &a->flags))\n\t\treturn complete_fmapi_req(a, rq, FI_STAT_DEGRADED);\n\n\tswitch (fi->action) {\n\tcase FI_ACT_DOWN:  \n\t\t \n\t\tif (!verify_fi(a, fc))\n\t\t\treturn complete_fmapi_req(a, rq, fi->status);\n\n\t\t \n\t\tch = &fi->cmp_hdr[CH_IT_BIOS];\n\n\t\tif (ch->length)\n\t\t\tfix_bios(a, fi);\n\n\t\t \n\t\tch = &fi->cmp_hdr[CH_IT_EFI];\n\n\t\tif (ch->length)\n\t\t\tfix_efi(a, fi);\n\n\t\t \n\t\tfi->checksum = calc_fi_checksum(fc);\n\n\t\t \n\t\tesas2r_disable_heartbeat(a);\n\n\t\t \n\t\tfc->task = FMTSK_ERASE_BOOT;\n\t\tfc->func = VDA_FLASH_BEGINW;\n\t\tfc->comp_typ = CH_IT_CFG;\n\t\tfc->flsh_addr = FLS_OFFSET_BOOT;\n\t\tfc->sgc.length = FLS_LENGTH_BOOT;\n\t\tfc->sgc.cur_offset = NULL;\n\n\t\t \n\t\tfc->interrupt_cb = fw_download_proc;\n\t\tbreak;\n\n\tcase FI_ACT_UPSZ:  \n\t\tfi->adap_typ = get_fi_adap_type(a);\n\t\tfi->flags = 0;\n\t\tfi->num_comps = fc->num_comps;\n\t\tfi->length = fc->fi_hdr_len;\n\n\t\t \n\t\tmemcpy(fi->rel_version, a->image_type,\n\t\t       sizeof(fi->rel_version));\n\n\t\t \n\t\tfor (j = 0, ch = fi->cmp_hdr;\n\t\t     j < fi->num_comps;\n\t\t     j++, ch++) {\n\t\t\tch->img_type = j;\n\t\t\tch->status = CH_STAT_PENDING;\n\t\t\tch->length = 0;\n\t\t\tch->version = 0xffffffff;\n\t\t\tch->image_offset = 0;\n\t\t\tch->pad[0] = 0;\n\t\t\tch->pad[1] = 0;\n\t\t}\n\n\t\tif (a->flash_ver != 0) {\n\t\t\tfi->cmp_hdr[CH_IT_BIOS].version =\n\t\t\t\tfi->cmp_hdr[CH_IT_MAC].version =\n\t\t\t\t\tfi->cmp_hdr[CH_IT_EFI].version =\n\t\t\t\t\t\tfi->cmp_hdr[CH_IT_CFG].version\n\t\t\t\t\t\t\t= a->flash_ver;\n\n\t\t\tfi->cmp_hdr[CH_IT_BIOS].status =\n\t\t\t\tfi->cmp_hdr[CH_IT_MAC].status =\n\t\t\t\t\tfi->cmp_hdr[CH_IT_EFI].status =\n\t\t\t\t\t\tfi->cmp_hdr[CH_IT_CFG].status =\n\t\t\t\t\t\t\tCH_STAT_SUCCESS;\n\n\t\t\treturn complete_fmapi_req(a, rq, FI_STAT_SUCCESS);\n\t\t}\n\n\t\tfallthrough;\n\n\tcase FI_ACT_UP:  \n\tdefault:\n\t\treturn complete_fmapi_req(a, rq, FI_STAT_INVALID);\n\t}\n\n\t \n\tif (!load_image(a, rq))\n\t\treturn complete_fmapi_req(a, rq, FI_STAT_FAILED);\n\n\tesas2r_start_request(a, rq);\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}