{
  "module_name": "sun3_scsi.c",
  "hash_id": "67a03c408c2d43f267ddd64db556634ce9bd59c9e9f935ad70607f7950068607",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sun3_scsi.c",
  "human_readable_source": "\n \n \n \n\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/platform_device.h>\n\n#include <asm/io.h>\n#include <asm/dvma.h>\n\n#include <scsi/scsi_host.h>\n\n \n#define DMA_MIN_SIZE                    129\n\n \n\n#define NCR5380_implementation_fields    \n\n#define NCR5380_read(reg)               in_8(hostdata->io + (reg))\n#define NCR5380_write(reg, value)       out_8(hostdata->io + (reg), value)\n\n#define NCR5380_queue_command           sun3scsi_queue_command\n#define NCR5380_host_reset              sun3scsi_host_reset\n#define NCR5380_abort                   sun3scsi_abort\n#define NCR5380_info                    sun3scsi_info\n\n#define NCR5380_dma_xfer_len            sun3scsi_dma_xfer_len\n#define NCR5380_dma_recv_setup          sun3scsi_dma_count\n#define NCR5380_dma_send_setup          sun3scsi_dma_count\n#define NCR5380_dma_residual            sun3scsi_dma_residual\n\n#include \"NCR5380.h\"\n\n \nstruct sun3_dma_regs {\n\tunsigned short dma_addr_hi;  \n\tunsigned short dma_addr_lo;  \n\tunsigned short dma_count_hi;  \n\tunsigned short dma_count_lo;  \n\tunsigned short udc_data;  \n\tunsigned short udc_addr;  \n\tunsigned short fifo_data;  \n\tunsigned short fifo_count;\n\tunsigned short csr;  \n\tunsigned short bpack_hi;  \n\tunsigned short bpack_lo;  \n\tunsigned short ivect;  \n\tunsigned short fifo_count_hi;  \n};\n\n \nstruct sun3_udc_regs {\n\tunsigned short rsel;  \n\tunsigned short addr_hi;  \n\tunsigned short addr_lo;  \n\tunsigned short count;  \n\tunsigned short mode_hi;  \n\tunsigned short mode_lo;  \n};\n\n \n#define UDC_MODE 0x38\n#define UDC_CSR 0x2e  \n#define UDC_CHN_HI 0x26  \n#define UDC_CHN_LO 0x22  \n#define UDC_CURA_HI 0x1a  \n#define UDC_CURA_LO 0x0a  \n#define UDC_CURB_HI 0x12  \n#define UDC_CURB_LO 0x02  \n#define UDC_MODE_HI 0x56  \n#define UDC_MODE_LO 0x52  \n#define UDC_COUNT 0x32  \n\n \n#define UDC_RESET 0\n#define UDC_CHN_START 0xa0  \n#define UDC_INT_ENABLE 0x32  \n\n \n#define UDC_MODE_HIWORD 0x40\n#define UDC_MODE_LSEND 0xc2\n#define UDC_MODE_LRECV 0xd2\n\n \n#define UDC_RSEL_SEND 0x282\n#define UDC_RSEL_RECV 0x182\n\n \n#define CSR_DMA_ACTIVE 0x8000\n#define CSR_DMA_CONFLICT 0x4000\n#define CSR_DMA_BUSERR 0x2000\n\n#define CSR_FIFO_EMPTY 0x400  \n#define CSR_SDB_INT 0x200  \n#define CSR_DMA_INT 0x100  \n\n#define CSR_LEFT 0xc0\n#define CSR_LEFT_3 0xc0\n#define CSR_LEFT_2 0x80\n#define CSR_LEFT_1 0x40\n#define CSR_PACK_ENABLE 0x20\n\n#define CSR_DMA_ENABLE 0x10\n\n#define CSR_SEND 0x8  \n#define CSR_FIFO 0x2  \n#define CSR_INTR 0x4  \n#define CSR_SCSI 0x1\n\n#define VME_DATA24 0x3d00\n\nextern int sun3_map_test(unsigned long, char *);\n\nstatic int setup_can_queue = -1;\nmodule_param(setup_can_queue, int, 0);\nstatic int setup_cmd_per_lun = -1;\nmodule_param(setup_cmd_per_lun, int, 0);\nstatic int setup_sg_tablesize = -1;\nmodule_param(setup_sg_tablesize, int, 0);\nstatic int setup_hostid = -1;\nmodule_param(setup_hostid, int, 0);\n\n \n#define SUN3_DMA_DELAY 10\n\n \n#define SUN3_DVMA_BUFSIZE 0xe000\n\nstatic struct scsi_cmnd *sun3_dma_setup_done;\nstatic volatile struct sun3_dma_regs *dregs;\nstatic struct sun3_udc_regs *udc_regs;\nstatic unsigned char *sun3_dma_orig_addr;\nstatic unsigned long sun3_dma_orig_count;\nstatic int sun3_dma_active;\nstatic unsigned long last_residual;\n\n#ifndef SUN3_SCSI_VME\n \n\nstatic inline unsigned short sun3_udc_read(unsigned char reg)\n{\n\tunsigned short ret;\n\n\tdregs->udc_addr = UDC_CSR;\n\tudelay(SUN3_DMA_DELAY);\n\tret = dregs->udc_data;\n\tudelay(SUN3_DMA_DELAY);\n\t\n\treturn ret;\n}\n\nstatic inline void sun3_udc_write(unsigned short val, unsigned char reg)\n{\n\tdregs->udc_addr = reg;\n\tudelay(SUN3_DMA_DELAY);\n\tdregs->udc_data = val;\n\tudelay(SUN3_DMA_DELAY);\n}\n#endif\n\n \n#define CSR_GOOD 0x060f\n\nstatic irqreturn_t scsi_sun3_intr(int irq, void *dev)\n{\n\tstruct Scsi_Host *instance = dev;\n\tunsigned short csr = dregs->csr;\n\tint handled = 0;\n\n#ifdef SUN3_SCSI_VME\n\tdregs->csr &= ~CSR_DMA_ENABLE;\n#endif\n\n\tif(csr & ~CSR_GOOD) {\n\t\tif (csr & CSR_DMA_BUSERR)\n\t\t\tshost_printk(KERN_ERR, instance, \"bus error in DMA\\n\");\n\t\tif (csr & CSR_DMA_CONFLICT)\n\t\t\tshost_printk(KERN_ERR, instance, \"DMA conflict\\n\");\n\t\thandled = 1;\n\t}\n\n\tif(csr & (CSR_SDB_INT | CSR_DMA_INT)) {\n\t\tNCR5380_intr(irq, dev);\n\t\thandled = 1;\n\t}\n\n\treturn IRQ_RETVAL(handled);\n}\n\n \nstatic int sun3scsi_dma_setup(struct NCR5380_hostdata *hostdata,\n                              unsigned char *data, int count, int write_flag)\n{\n\tvoid *addr;\n\n\tif(sun3_dma_orig_addr != NULL)\n\t\tdvma_unmap(sun3_dma_orig_addr);\n\n#ifdef SUN3_SCSI_VME\n\taddr = (void *)dvma_map_vme((unsigned long) data, count);\n#else\n\taddr = (void *)dvma_map((unsigned long) data, count);\n#endif\n\t\t\n\tsun3_dma_orig_addr = addr;\n\tsun3_dma_orig_count = count;\n\n#ifndef SUN3_SCSI_VME\n\tdregs->fifo_count = 0;\n\tsun3_udc_write(UDC_RESET, UDC_CSR);\n\t\n\t \n\tdregs->csr &= ~CSR_FIFO;\n\tdregs->csr |= CSR_FIFO;\n#endif\n\t\n\t \n\tif(write_flag)\n\t\tdregs->csr |= CSR_SEND;\n\telse\n\t\tdregs->csr &= ~CSR_SEND;\n\t\n#ifdef SUN3_SCSI_VME\n\tdregs->csr |= CSR_PACK_ENABLE;\n\n\tdregs->dma_addr_hi = ((unsigned long)addr >> 16);\n\tdregs->dma_addr_lo = ((unsigned long)addr & 0xffff);\n\n\tdregs->dma_count_hi = 0;\n\tdregs->dma_count_lo = 0;\n\tdregs->fifo_count_hi = 0;\n\tdregs->fifo_count = 0;\n#else\n\t \n\tdregs->fifo_count = count;\n\n\tsun3_udc_write(UDC_RESET, UDC_CSR);\n\t\n\t \n\tdregs->csr &= ~CSR_FIFO;\n\tdregs->csr |= CSR_FIFO;\n\t\n\tif(dregs->fifo_count != count) { \n\t\tshost_printk(KERN_ERR, hostdata->host,\n\t\t             \"FIFO mismatch %04x not %04x\\n\",\n\t\t             dregs->fifo_count, (unsigned int) count);\n\t\tNCR5380_dprint(NDEBUG_DMA, hostdata->host);\n\t}\n\n\t \n\tudc_regs->addr_hi = (((unsigned long)(addr) & 0xff0000) >> 8);\n\tudc_regs->addr_lo = ((unsigned long)(addr) & 0xffff);\n\tudc_regs->count = count/2;  \n\tudc_regs->mode_hi = UDC_MODE_HIWORD;\n\tif(write_flag) {\n\t\tif(count & 1)\n\t\t\tudc_regs->count++;\n\t\tudc_regs->mode_lo = UDC_MODE_LSEND;\n\t\tudc_regs->rsel = UDC_RSEL_SEND;\n\t} else {\n\t\tudc_regs->mode_lo = UDC_MODE_LRECV;\n\t\tudc_regs->rsel = UDC_RSEL_RECV;\n\t}\n\t\n\t \n\tsun3_udc_write(((dvma_vtob(udc_regs) & 0xff0000) >> 8),\n\t\t       UDC_CHN_HI); \n\n\tsun3_udc_write((dvma_vtob(udc_regs) & 0xffff), UDC_CHN_LO);\n\n\t \n\tsun3_udc_write(0xd, UDC_MODE);\n\n\t \n\tsun3_udc_write(UDC_INT_ENABLE, UDC_CSR);\n#endif\n\t\n       \treturn count;\n\n}\n\nstatic int sun3scsi_dma_count(struct NCR5380_hostdata *hostdata,\n                              unsigned char *data, int count)\n{\n\treturn count;\n}\n\nstatic inline int sun3scsi_dma_recv_setup(struct NCR5380_hostdata *hostdata,\n                                          unsigned char *data, int count)\n{\n\treturn sun3scsi_dma_setup(hostdata, data, count, 0);\n}\n\nstatic inline int sun3scsi_dma_send_setup(struct NCR5380_hostdata *hostdata,\n                                          unsigned char *data, int count)\n{\n\treturn sun3scsi_dma_setup(hostdata, data, count, 1);\n}\n\nstatic int sun3scsi_dma_residual(struct NCR5380_hostdata *hostdata)\n{\n\treturn last_residual;\n}\n\nstatic int sun3scsi_dma_xfer_len(struct NCR5380_hostdata *hostdata,\n                                 struct scsi_cmnd *cmd)\n{\n\tint wanted_len = NCR5380_to_ncmd(cmd)->this_residual;\n\n\tif (wanted_len < DMA_MIN_SIZE || blk_rq_is_passthrough(scsi_cmd_to_rq(cmd)))\n\t\treturn 0;\n\n\treturn wanted_len;\n}\n\nstatic inline int sun3scsi_dma_start(unsigned long count, unsigned char *data)\n{\n#ifdef SUN3_SCSI_VME\n\tunsigned short csr;\n\n\tcsr = dregs->csr;\n\n\tdregs->dma_count_hi = (sun3_dma_orig_count >> 16);\n\tdregs->dma_count_lo = (sun3_dma_orig_count & 0xffff);\n\n\tdregs->fifo_count_hi = (sun3_dma_orig_count >> 16);\n\tdregs->fifo_count = (sun3_dma_orig_count & 0xffff);\n\n \n#else\n    sun3_udc_write(UDC_CHN_START, UDC_CSR);\n#endif\n    \n    return 0;\n}\n\n \nstatic int sun3scsi_dma_finish(enum dma_data_direction data_dir)\n{\n\tconst bool write_flag = data_dir == DMA_TO_DEVICE;\n\tunsigned short __maybe_unused count;\n\tunsigned short fifo;\n\tint ret = 0;\n\t\n\tsun3_dma_active = 0;\n\n#ifdef SUN3_SCSI_VME\n\tdregs->csr &= ~CSR_DMA_ENABLE;\n\n\tfifo = dregs->fifo_count;\n\tif (write_flag) {\n\t\tif ((fifo > 0) && (fifo < sun3_dma_orig_count))\n\t\t\tfifo++;\n\t}\n\n\tlast_residual = fifo;\n\t \n\tif ((!write_flag) && (dregs->csr & CSR_LEFT)) {\n\t\tunsigned char *vaddr;\n\n\t\tvaddr = (unsigned char *)dvma_vmetov(sun3_dma_orig_addr);\n\n\t\tvaddr += (sun3_dma_orig_count - fifo);\n\t\tvaddr--;\n\n\t\tswitch (dregs->csr & CSR_LEFT) {\n\t\tcase CSR_LEFT_3:\n\t\t\t*vaddr = (dregs->bpack_lo & 0xff00) >> 8;\n\t\t\tvaddr--;\n\t\t\tfallthrough;\n\n\t\tcase CSR_LEFT_2:\n\t\t\t*vaddr = (dregs->bpack_hi & 0x00ff);\n\t\t\tvaddr--;\n\t\t\tfallthrough;\n\n\t\tcase CSR_LEFT_1:\n\t\t\t*vaddr = (dregs->bpack_hi & 0xff00) >> 8;\n\t\t\tbreak;\n\t\t}\n\t}\n#else\n\t\n\tif(!write_flag) {\n\t\tint tmo = 20000;  \n\t\t\n\t\twhile(1) {\n\t\t\tif(dregs->csr & CSR_FIFO_EMPTY)\n\t\t\t\tbreak;\n\n\t\t\tif(--tmo <= 0) {\n\t\t\t\tprintk(\"sun3scsi: fifo failed to empty!\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tudelay(10);\n\t\t}\n\t}\n\n\tdregs->udc_addr = 0x32;\n\tudelay(SUN3_DMA_DELAY);\n\tcount = 2 * dregs->udc_data;\n\tudelay(SUN3_DMA_DELAY);\n\n\tfifo = dregs->fifo_count;\n\tlast_residual = fifo;\n\n\t \n\tif((!write_flag) && (count - fifo) == 2) {\n\t\tunsigned short data;\n\t\tunsigned char *vaddr;\n\n\t\tdata = dregs->fifo_data;\n\t\tvaddr = (unsigned char *)dvma_btov(sun3_dma_orig_addr);\n\t\t\n\t\tvaddr += (sun3_dma_orig_count - fifo);\n\n\t\tvaddr[-2] = (data & 0xff00) >> 8;\n\t\tvaddr[-1] = (data & 0xff);\n\t}\n#endif\n\n\tdvma_unmap(sun3_dma_orig_addr);\n\tsun3_dma_orig_addr = NULL;\n\n#ifdef SUN3_SCSI_VME\n\tdregs->dma_addr_hi = 0;\n\tdregs->dma_addr_lo = 0;\n\tdregs->dma_count_hi = 0;\n\tdregs->dma_count_lo = 0;\n\n\tdregs->fifo_count = 0;\n\tdregs->fifo_count_hi = 0;\n\n\tdregs->csr &= ~CSR_SEND;\n \n#else\n\tsun3_udc_write(UDC_RESET, UDC_CSR);\n\tdregs->fifo_count = 0;\n\tdregs->csr &= ~CSR_SEND;\n\n\t \n\tdregs->csr &= ~CSR_FIFO;\n\tdregs->csr |= CSR_FIFO;\n#endif\n\t\n\tsun3_dma_setup_done = NULL;\n\n\treturn ret;\n\n}\n\t\n#include \"NCR5380.c\"\n\n#ifdef SUN3_SCSI_VME\n#define SUN3_SCSI_NAME          \"Sun3 NCR5380 VME SCSI\"\n#define DRV_MODULE_NAME         \"sun3_scsi_vme\"\n#else\n#define SUN3_SCSI_NAME          \"Sun3 NCR5380 SCSI\"\n#define DRV_MODULE_NAME         \"sun3_scsi\"\n#endif\n\n#define PFX                     DRV_MODULE_NAME \": \"\n\nstatic struct scsi_host_template sun3_scsi_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.proc_name\t\t= DRV_MODULE_NAME,\n\t.name\t\t\t= SUN3_SCSI_NAME,\n\t.info\t\t\t= sun3scsi_info,\n\t.queuecommand\t\t= sun3scsi_queue_command,\n\t.eh_abort_handler\t= sun3scsi_abort,\n\t.eh_host_reset_handler\t= sun3scsi_host_reset,\n\t.can_queue\t\t= 16,\n\t.this_id\t\t= 7,\n\t.sg_tablesize\t\t= 1,\n\t.cmd_per_lun\t\t= 2,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n\t.cmd_size\t\t= sizeof(struct NCR5380_cmd),\n};\n\nstatic int __init sun3_scsi_probe(struct platform_device *pdev)\n{\n\tstruct Scsi_Host *instance;\n\tstruct NCR5380_hostdata *hostdata;\n\tint error;\n\tstruct resource *irq, *mem;\n\tvoid __iomem *ioaddr;\n\tint host_flags = 0;\n#ifdef SUN3_SCSI_VME\n\tint i;\n#endif\n\n\tif (setup_can_queue > 0)\n\t\tsun3_scsi_template.can_queue = setup_can_queue;\n\tif (setup_cmd_per_lun > 0)\n\t\tsun3_scsi_template.cmd_per_lun = setup_cmd_per_lun;\n\tif (setup_sg_tablesize > 0)\n\t\tsun3_scsi_template.sg_tablesize = setup_sg_tablesize;\n\tif (setup_hostid >= 0)\n\t\tsun3_scsi_template.this_id = setup_hostid & 7;\n\n#ifdef SUN3_SCSI_VME\n\tioaddr = NULL;\n\tfor (i = 0; i < 2; i++) {\n\t\tunsigned char x;\n\n\t\tirq = platform_get_resource(pdev, IORESOURCE_IRQ, i);\n\t\tmem = platform_get_resource(pdev, IORESOURCE_MEM, i);\n\t\tif (!irq || !mem)\n\t\t\tbreak;\n\n\t\tioaddr = sun3_ioremap(mem->start, resource_size(mem),\n\t\t                      SUN3_PAGE_TYPE_VME16);\n\t\tdregs = (struct sun3_dma_regs *)(ioaddr + 8);\n\n\t\tif (sun3_map_test((unsigned long)dregs, &x)) {\n\t\t\tunsigned short oldcsr;\n\n\t\t\toldcsr = dregs->csr;\n\t\t\tdregs->csr = 0;\n\t\t\tudelay(SUN3_DMA_DELAY);\n\t\t\tif (dregs->csr == 0x1400)\n\t\t\t\tbreak;\n\n\t\t\tdregs->csr = oldcsr;\n\t\t}\n\n\t\tiounmap(ioaddr);\n\t\tioaddr = NULL;\n\t}\n\tif (!ioaddr)\n\t\treturn -ENODEV;\n#else\n\tirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!irq || !mem)\n\t\treturn -ENODEV;\n\n\tioaddr = ioremap(mem->start, resource_size(mem));\n\tdregs = (struct sun3_dma_regs *)(ioaddr + 8);\n\n\tudc_regs = dvma_malloc(sizeof(struct sun3_udc_regs));\n\tif (!udc_regs) {\n\t\tpr_err(PFX \"couldn't allocate DVMA memory!\\n\");\n\t\tiounmap(ioaddr);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\n\tinstance = scsi_host_alloc(&sun3_scsi_template,\n\t                           sizeof(struct NCR5380_hostdata));\n\tif (!instance) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_alloc;\n\t}\n\n\tinstance->irq = irq->start;\n\n\thostdata = shost_priv(instance);\n\thostdata->base = mem->start;\n\thostdata->io = ioaddr;\n\n\terror = NCR5380_init(instance, host_flags);\n\tif (error)\n\t\tgoto fail_init;\n\n\terror = request_irq(instance->irq, scsi_sun3_intr, 0,\n\t                    \"NCR5380\", instance);\n\tif (error) {\n\t\tpr_err(PFX \"scsi%d: IRQ %d not free, bailing out\\n\",\n\t\t       instance->host_no, instance->irq);\n\t\tgoto fail_irq;\n\t}\n\n\tdregs->csr = 0;\n\tudelay(SUN3_DMA_DELAY);\n\tdregs->csr = CSR_SCSI | CSR_FIFO | CSR_INTR;\n\tudelay(SUN3_DMA_DELAY);\n\tdregs->fifo_count = 0;\n#ifdef SUN3_SCSI_VME\n\tdregs->fifo_count_hi = 0;\n\tdregs->dma_addr_hi = 0;\n\tdregs->dma_addr_lo = 0;\n\tdregs->dma_count_hi = 0;\n\tdregs->dma_count_lo = 0;\n\n\tdregs->ivect = VME_DATA24 | (instance->irq & 0xff);\n#endif\n\n\tNCR5380_maybe_reset_bus(instance);\n\n\terror = scsi_add_host(instance, NULL);\n\tif (error)\n\t\tgoto fail_host;\n\n\tplatform_set_drvdata(pdev, instance);\n\n\tscsi_scan_host(instance);\n\treturn 0;\n\nfail_host:\n\tfree_irq(instance->irq, instance);\nfail_irq:\n\tNCR5380_exit(instance);\nfail_init:\n\tscsi_host_put(instance);\nfail_alloc:\n\tif (udc_regs)\n\t\tdvma_free(udc_regs);\n\tiounmap(ioaddr);\n\treturn error;\n}\n\nstatic int __exit sun3_scsi_remove(struct platform_device *pdev)\n{\n\tstruct Scsi_Host *instance = platform_get_drvdata(pdev);\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tvoid __iomem *ioaddr = hostdata->io;\n\n\tscsi_remove_host(instance);\n\tfree_irq(instance->irq, instance);\n\tNCR5380_exit(instance);\n\tscsi_host_put(instance);\n\tif (udc_regs)\n\t\tdvma_free(udc_regs);\n\tiounmap(ioaddr);\n\treturn 0;\n}\n\nstatic struct platform_driver sun3_scsi_driver = {\n\t.remove = __exit_p(sun3_scsi_remove),\n\t.driver = {\n\t\t.name\t= DRV_MODULE_NAME,\n\t},\n};\n\nmodule_platform_driver_probe(sun3_scsi_driver, sun3_scsi_probe);\n\nMODULE_ALIAS(\"platform:\" DRV_MODULE_NAME);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}