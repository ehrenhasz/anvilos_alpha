{
  "module_name": "BusLogic.c",
  "hash_id": "423d85f710da13ad94bfa5324ee81b34fd398c86751edb404666d2ee38d09f98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/BusLogic.c",
  "human_readable_source": "\n\n \n\n#define blogic_drvr_version\t\t\"2.1.17\"\n#define blogic_drvr_date\t\t\"12 September 2013\"\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/types.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/jiffies.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/msdos_partition.h>\n#include <scsi/scsicam.h>\n\n#include <asm/dma.h>\n#include <asm/io.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include \"BusLogic.h\"\n#include \"FlashPoint.c\"\n\n#ifndef FAILURE\n#define FAILURE (-1)\n#endif\n\nstatic const struct scsi_host_template blogic_template;\n\n \n\nstatic int blogic_drvr_options_count;\n\n\n \n\nstatic struct blogic_drvr_options blogic_drvr_options[BLOGIC_MAX_ADAPTERS];\n\n\n \n\nMODULE_LICENSE(\"GPL\");\n#ifdef MODULE\nstatic char *BusLogic;\nmodule_param(BusLogic, charp, 0);\n#endif\n\n\n \n\nstatic struct blogic_probe_options blogic_probe_options;\n\n\n \n\nstatic struct blogic_global_options blogic_global_options;\n\nstatic LIST_HEAD(blogic_host_list);\n\n \n\nstatic int blogic_probeinfo_count;\n\n\n \n\nstatic struct blogic_probeinfo *blogic_probeinfo_list;\n\n\n \n\nstatic char *blogic_cmd_failure_reason;\n\n \n\nstatic void blogic_announce_drvr(struct blogic_adapter *adapter)\n{\n\tblogic_announce(\"***** BusLogic SCSI Driver Version \" blogic_drvr_version \" of \" blogic_drvr_date \" *****\\n\", adapter);\n\tblogic_announce(\"Copyright 1995-1998 by Leonard N. Zubkoff <lnz@dandelion.com>\\n\", adapter);\n}\n\n\n \n\nstatic const char *blogic_drvr_info(struct Scsi_Host *host)\n{\n\tstruct blogic_adapter *adapter =\n\t\t\t\t(struct blogic_adapter *) host->hostdata;\n\treturn adapter->full_model;\n}\n\n \n\nstatic void blogic_init_ccbs(struct blogic_adapter *adapter, void *blk_pointer,\n\t\t\t\tint blk_size, dma_addr_t blkp)\n{\n\tstruct blogic_ccb *ccb = (struct blogic_ccb *) blk_pointer;\n\tunsigned int offset = 0;\n\tmemset(blk_pointer, 0, blk_size);\n\tccb->allocgrp_head = blkp;\n\tccb->allocgrp_size = blk_size;\n\twhile ((blk_size -= sizeof(struct blogic_ccb)) >= 0) {\n\t\tccb->status = BLOGIC_CCB_FREE;\n\t\tccb->adapter = adapter;\n\t\tccb->dma_handle = (u32) blkp + offset;\n\t\tif (blogic_flashpoint_type(adapter)) {\n\t\t\tccb->callback = blogic_qcompleted_ccb;\n\t\t\tccb->base_addr = adapter->fpinfo.base_addr;\n\t\t}\n\t\tccb->next = adapter->free_ccbs;\n\t\tccb->next_all = adapter->all_ccbs;\n\t\tadapter->free_ccbs = ccb;\n\t\tadapter->all_ccbs = ccb;\n\t\tadapter->alloc_ccbs++;\n\t\tccb++;\n\t\toffset += sizeof(struct blogic_ccb);\n\t}\n}\n\n\n \n\nstatic bool __init blogic_create_initccbs(struct blogic_adapter *adapter)\n{\n\tint blk_size = BLOGIC_CCB_GRP_ALLOCSIZE * sizeof(struct blogic_ccb);\n\tvoid *blk_pointer;\n\tdma_addr_t blkp;\n\n\twhile (adapter->alloc_ccbs < adapter->initccbs) {\n\t\tblk_pointer = dma_alloc_coherent(&adapter->pci_device->dev,\n\t\t\t\tblk_size, &blkp, GFP_KERNEL);\n\t\tif (blk_pointer == NULL) {\n\t\t\tblogic_err(\"UNABLE TO ALLOCATE CCB GROUP - DETACHING\\n\",\n\t\t\t\t\tadapter);\n\t\t\treturn false;\n\t\t}\n\t\tblogic_init_ccbs(adapter, blk_pointer, blk_size, blkp);\n\t}\n\treturn true;\n}\n\n\n \n\nstatic void blogic_destroy_ccbs(struct blogic_adapter *adapter)\n{\n\tstruct blogic_ccb *next_ccb = adapter->all_ccbs, *ccb, *lastccb = NULL;\n\tadapter->all_ccbs = NULL;\n\tadapter->free_ccbs = NULL;\n\twhile ((ccb = next_ccb) != NULL) {\n\t\tnext_ccb = ccb->next_all;\n\t\tif (ccb->allocgrp_head) {\n\t\t\tif (lastccb)\n\t\t\t\tdma_free_coherent(&adapter->pci_device->dev,\n\t\t\t\t\t\tlastccb->allocgrp_size, lastccb,\n\t\t\t\t\t\tlastccb->allocgrp_head);\n\t\t\tlastccb = ccb;\n\t\t}\n\t}\n\tif (lastccb)\n\t\tdma_free_coherent(&adapter->pci_device->dev,\n\t\t\t\tlastccb->allocgrp_size, lastccb,\n\t\t\t\tlastccb->allocgrp_head);\n}\n\n\n \n\nstatic void blogic_create_addlccbs(struct blogic_adapter *adapter,\n\t\t\t\t\tint addl_ccbs, bool print_success)\n{\n\tint blk_size = BLOGIC_CCB_GRP_ALLOCSIZE * sizeof(struct blogic_ccb);\n\tint prev_alloc = adapter->alloc_ccbs;\n\tvoid *blk_pointer;\n\tdma_addr_t blkp;\n\tif (addl_ccbs <= 0)\n\t\treturn;\n\twhile (adapter->alloc_ccbs - prev_alloc < addl_ccbs) {\n\t\tblk_pointer = dma_alloc_coherent(&adapter->pci_device->dev,\n\t\t\t\tblk_size, &blkp, GFP_KERNEL);\n\t\tif (blk_pointer == NULL)\n\t\t\tbreak;\n\t\tblogic_init_ccbs(adapter, blk_pointer, blk_size, blkp);\n\t}\n\tif (adapter->alloc_ccbs > prev_alloc) {\n\t\tif (print_success)\n\t\t\tblogic_notice(\"Allocated %d additional CCBs (total now %d)\\n\", adapter, adapter->alloc_ccbs - prev_alloc, adapter->alloc_ccbs);\n\t\treturn;\n\t}\n\tblogic_notice(\"Failed to allocate additional CCBs\\n\", adapter);\n\tif (adapter->drvr_qdepth > adapter->alloc_ccbs - adapter->tgt_count) {\n\t\tadapter->drvr_qdepth = adapter->alloc_ccbs - adapter->tgt_count;\n\t\tadapter->scsi_host->can_queue = adapter->drvr_qdepth;\n\t}\n}\n\n \n\nstatic struct blogic_ccb *blogic_alloc_ccb(struct blogic_adapter *adapter)\n{\n\tstatic unsigned long serial;\n\tstruct blogic_ccb *ccb;\n\tccb = adapter->free_ccbs;\n\tif (ccb != NULL) {\n\t\tccb->serial = ++serial;\n\t\tadapter->free_ccbs = ccb->next;\n\t\tccb->next = NULL;\n\t\tif (adapter->free_ccbs == NULL)\n\t\t\tblogic_create_addlccbs(adapter, adapter->inc_ccbs,\n\t\t\t\t\t\ttrue);\n\t\treturn ccb;\n\t}\n\tblogic_create_addlccbs(adapter, adapter->inc_ccbs, true);\n\tccb = adapter->free_ccbs;\n\tif (ccb == NULL)\n\t\treturn NULL;\n\tccb->serial = ++serial;\n\tadapter->free_ccbs = ccb->next;\n\tccb->next = NULL;\n\treturn ccb;\n}\n\n\n \n\nstatic void blogic_dealloc_ccb(struct blogic_ccb *ccb, int dma_unmap)\n{\n\tstruct blogic_adapter *adapter = ccb->adapter;\n\n\tif (ccb->command != NULL)\n\t\tscsi_dma_unmap(ccb->command);\n\tif (dma_unmap)\n\t\tdma_unmap_single(&adapter->pci_device->dev, ccb->sensedata,\n\t\t\t ccb->sense_datalen, DMA_FROM_DEVICE);\n\n\tccb->command = NULL;\n\tccb->status = BLOGIC_CCB_FREE;\n\tccb->next = adapter->free_ccbs;\n\tadapter->free_ccbs = ccb;\n}\n\n\n \n\nstatic int blogic_cmd(struct blogic_adapter *adapter, enum blogic_opcode opcode,\n\t\t\tvoid *param, int paramlen, void *reply, int replylen)\n{\n\tunsigned char *param_p = (unsigned char *) param;\n\tunsigned char *reply_p = (unsigned char *) reply;\n\tunion blogic_stat_reg statusreg;\n\tunion blogic_int_reg intreg;\n\tunsigned long processor_flag = 0;\n\tint reply_b = 0, result;\n\tlong timeout;\n\t \n\tif (replylen > 0)\n\t\tmemset(reply, 0, replylen);\n\t \n\tif (!adapter->irq_acquired)\n\t\tlocal_irq_save(processor_flag);\n\t \n\ttimeout = 10000;\n\twhile (--timeout >= 0) {\n\t\tstatusreg.all = blogic_rdstatus(adapter);\n\t\tif (statusreg.sr.adapter_ready && !statusreg.sr.cmd_param_busy)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\tif (timeout < 0) {\n\t\tblogic_cmd_failure_reason =\n\t\t\t\t\"Timeout waiting for Host Adapter Ready\";\n\t\tresult = -2;\n\t\tgoto done;\n\t}\n\t \n\tadapter->adapter_cmd_complete = false;\n\tblogic_setcmdparam(adapter, opcode);\n\t \n\ttimeout = 10000;\n\twhile (paramlen > 0 && --timeout >= 0) {\n\t\t \n\t\tudelay(100);\n\t\tintreg.all = blogic_rdint(adapter);\n\t\tstatusreg.all = blogic_rdstatus(adapter);\n\t\tif (intreg.ir.cmd_complete)\n\t\t\tbreak;\n\t\tif (adapter->adapter_cmd_complete)\n\t\t\tbreak;\n\t\tif (statusreg.sr.datain_ready)\n\t\t\tbreak;\n\t\tif (statusreg.sr.cmd_param_busy)\n\t\t\tcontinue;\n\t\tblogic_setcmdparam(adapter, *param_p++);\n\t\tparamlen--;\n\t}\n\tif (timeout < 0) {\n\t\tblogic_cmd_failure_reason =\n\t\t\t\t\"Timeout waiting for Parameter Acceptance\";\n\t\tresult = -2;\n\t\tgoto done;\n\t}\n\t \n\tif (opcode == BLOGIC_MOD_IOADDR) {\n\t\tstatusreg.all = blogic_rdstatus(adapter);\n\t\tif (statusreg.sr.cmd_invalid) {\n\t\t\tblogic_cmd_failure_reason =\n\t\t\t\t\t\"Modify I/O Address Invalid\";\n\t\t\tresult = -1;\n\t\t\tgoto done;\n\t\t}\n\t\tif (blogic_global_options.trace_config)\n\t\t\tblogic_notice(\"blogic_cmd(%02X) Status = %02X: (Modify I/O Address)\\n\", adapter, opcode, statusreg.all);\n\t\tresult = 0;\n\t\tgoto done;\n\t}\n\t \n\tswitch (opcode) {\n\tcase BLOGIC_INQ_DEV0TO7:\n\tcase BLOGIC_INQ_DEV8TO15:\n\tcase BLOGIC_INQ_DEV:\n\t\t \n\t\ttimeout = 60 * 10000;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\ttimeout = 10000;\n\t\tbreak;\n\t}\n\t \n\twhile (--timeout >= 0) {\n\t\tintreg.all = blogic_rdint(adapter);\n\t\tstatusreg.all = blogic_rdstatus(adapter);\n\t\tif (intreg.ir.cmd_complete)\n\t\t\tbreak;\n\t\tif (adapter->adapter_cmd_complete)\n\t\t\tbreak;\n\t\tif (statusreg.sr.datain_ready) {\n\t\t\tif (++reply_b <= replylen)\n\t\t\t\t*reply_p++ = blogic_rddatain(adapter);\n\t\t\telse\n\t\t\t\tblogic_rddatain(adapter);\n\t\t}\n\t\tif (opcode == BLOGIC_FETCH_LOCALRAM &&\n\t\t\t\tstatusreg.sr.adapter_ready)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\tif (timeout < 0) {\n\t\tblogic_cmd_failure_reason =\n\t\t\t\t\t\"Timeout waiting for Command Complete\";\n\t\tresult = -2;\n\t\tgoto done;\n\t}\n\t \n\tblogic_intreset(adapter);\n\t \n\tif (blogic_global_options.trace_config) {\n\t\tint i;\n\t\tblogic_notice(\"blogic_cmd(%02X) Status = %02X: %2d ==> %2d:\",\n\t\t\t\tadapter, opcode, statusreg.all, replylen,\n\t\t\t\treply_b);\n\t\tif (replylen > reply_b)\n\t\t\treplylen = reply_b;\n\t\tfor (i = 0; i < replylen; i++)\n\t\t\tblogic_notice(\" %02X\", adapter,\n\t\t\t\t\t((unsigned char *) reply)[i]);\n\t\tblogic_notice(\"\\n\", adapter);\n\t}\n\t \n\tif (statusreg.sr.cmd_invalid) {\n\t\t \n\t\tudelay(1000);\n\t\tstatusreg.all = blogic_rdstatus(adapter);\n\t\tif (statusreg.sr.cmd_invalid || statusreg.sr.rsvd ||\n\t\t\t\tstatusreg.sr.datain_ready ||\n\t\t\t\tstatusreg.sr.cmd_param_busy ||\n\t\t\t\t!statusreg.sr.adapter_ready ||\n\t\t\t\t!statusreg.sr.init_reqd ||\n\t\t\t\tstatusreg.sr.diag_active ||\n\t\t\t\tstatusreg.sr.diag_failed) {\n\t\t\tblogic_softreset(adapter);\n\t\t\tudelay(1000);\n\t\t}\n\t\tblogic_cmd_failure_reason = \"Command Invalid\";\n\t\tresult = -1;\n\t\tgoto done;\n\t}\n\t \n\tif (paramlen > 0) {\n\t\tblogic_cmd_failure_reason = \"Excess Parameters Supplied\";\n\t\tresult = -1;\n\t\tgoto done;\n\t}\n\t \n\tblogic_cmd_failure_reason = NULL;\n\tresult = reply_b;\n\t \ndone:\n\tif (!adapter->irq_acquired)\n\t\tlocal_irq_restore(processor_flag);\n\treturn result;\n}\n\n\n \n\nstatic void __init blogic_sort_probeinfo(struct blogic_probeinfo\n\t\t\t\t\t*probeinfo_list, int probeinfo_cnt)\n{\n\tint last_exchange = probeinfo_cnt - 1, bound, j;\n\n\twhile (last_exchange > 0) {\n\t\tbound = last_exchange;\n\t\tlast_exchange = 0;\n\t\tfor (j = 0; j < bound; j++) {\n\t\t\tstruct blogic_probeinfo *probeinfo1 =\n\t\t\t\t\t\t\t&probeinfo_list[j];\n\t\t\tstruct blogic_probeinfo *probeinfo2 =\n\t\t\t\t\t\t\t&probeinfo_list[j + 1];\n\t\t\tif (probeinfo1->bus > probeinfo2->bus ||\n\t\t\t\t(probeinfo1->bus == probeinfo2->bus &&\n\t\t\t\t(probeinfo1->dev > probeinfo2->dev))) {\n\t\t\t\tstruct blogic_probeinfo tmp_probeinfo;\n\n\t\t\t\tmemcpy(&tmp_probeinfo, probeinfo1,\n\t\t\t\t\tsizeof(struct blogic_probeinfo));\n\t\t\t\tmemcpy(probeinfo1, probeinfo2,\n\t\t\t\t\tsizeof(struct blogic_probeinfo));\n\t\t\t\tmemcpy(probeinfo2, &tmp_probeinfo,\n\t\t\t\t\tsizeof(struct blogic_probeinfo));\n\t\t\t\tlast_exchange = j;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n \n\nstatic int __init blogic_init_mm_probeinfo(struct blogic_adapter *adapter)\n{\n\tstruct blogic_probeinfo *pr_probeinfo =\n\t\t&blogic_probeinfo_list[blogic_probeinfo_count];\n\tint nonpr_mmindex = blogic_probeinfo_count + 1;\n\tint nonpr_mmcount = 0, mmcount = 0;\n\tbool force_scan_order = false;\n\tbool force_scan_order_checked = false;\n\tstruct pci_dev *pci_device = NULL;\n\tint i;\n\tif (blogic_probeinfo_count >= BLOGIC_MAX_ADAPTERS)\n\t\treturn 0;\n\tblogic_probeinfo_count++;\n\t \n\tpr_probeinfo->io_addr = 0;\n\twhile ((pci_device = pci_get_device(PCI_VENDOR_ID_BUSLOGIC,\n\t\t\t\t\tPCI_DEVICE_ID_BUSLOGIC_MULTIMASTER,\n\t\t\t\t\tpci_device)) != NULL) {\n\t\tstruct blogic_adapter *host_adapter = adapter;\n\t\tstruct blogic_adapter_info adapter_info;\n\t\tenum blogic_isa_ioport mod_ioaddr_req;\n\t\tunsigned char bus;\n\t\tunsigned char device;\n\t\tunsigned int irq_ch;\n\t\tunsigned long base_addr0;\n\t\tunsigned long base_addr1;\n\t\tunsigned long io_addr;\n\t\tunsigned long pci_addr;\n\n\t\tif (pci_enable_device(pci_device))\n\t\t\tcontinue;\n\n\t\tif (dma_set_mask(&pci_device->dev, DMA_BIT_MASK(32)))\n\t\t\tcontinue;\n\n\t\tbus = pci_device->bus->number;\n\t\tdevice = pci_device->devfn >> 3;\n\t\tirq_ch = pci_device->irq;\n\t\tio_addr = base_addr0 = pci_resource_start(pci_device, 0);\n\t\tpci_addr = base_addr1 = pci_resource_start(pci_device, 1);\n\n\t\tif (pci_resource_flags(pci_device, 0) & IORESOURCE_MEM) {\n\t\t\tblogic_err(\"BusLogic: Base Address0 0x%lX not I/O for MultiMaster Host Adapter\\n\", NULL, base_addr0);\n\t\t\tblogic_err(\"at PCI Bus %d Device %d I/O Address 0x%lX\\n\", NULL, bus, device, io_addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pci_resource_flags(pci_device, 1) & IORESOURCE_IO) {\n\t\t\tblogic_err(\"BusLogic: Base Address1 0x%lX not Memory for MultiMaster Host Adapter\\n\", NULL, base_addr1);\n\t\t\tblogic_err(\"at PCI Bus %d Device %d PCI Address 0x%lX\\n\", NULL, bus, device, pci_addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (irq_ch == 0) {\n\t\t\tblogic_err(\"BusLogic: IRQ Channel %d invalid for MultiMaster Host Adapter\\n\", NULL, irq_ch);\n\t\t\tblogic_err(\"at PCI Bus %d Device %d I/O Address 0x%lX\\n\", NULL, bus, device, io_addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (blogic_global_options.trace_probe) {\n\t\t\tblogic_notice(\"BusLogic: PCI MultiMaster Host Adapter detected at\\n\", NULL);\n\t\t\tblogic_notice(\"BusLogic: PCI Bus %d Device %d I/O Address 0x%lX PCI Address 0x%lX\\n\", NULL, bus, device, io_addr, pci_addr);\n\t\t}\n\t\t \n\t\thost_adapter->io_addr = io_addr;\n\t\tblogic_intreset(host_adapter);\n\t\tif (blogic_cmd(host_adapter, BLOGIC_INQ_PCI_INFO, NULL, 0,\n\t\t\t\t&adapter_info, sizeof(adapter_info)) !=\n\t\t\t\tsizeof(adapter_info))\n\t\t\tadapter_info.isa_port = BLOGIC_IO_DISABLE;\n\t\t \n\t\tmod_ioaddr_req = BLOGIC_IO_DISABLE;\n\t\tblogic_cmd(host_adapter, BLOGIC_MOD_IOADDR, &mod_ioaddr_req,\n\t\t\t\tsizeof(mod_ioaddr_req), NULL, 0);\n\t\t \n\t\tif (!force_scan_order_checked) {\n\t\t\tstruct blogic_fetch_localram fetch_localram;\n\t\t\tstruct blogic_autoscsi_byte45 autoscsi_byte45;\n\t\t\tstruct blogic_board_id id;\n\n\t\t\tfetch_localram.offset = BLOGIC_AUTOSCSI_BASE + 45;\n\t\t\tfetch_localram.count = sizeof(autoscsi_byte45);\n\t\t\tblogic_cmd(host_adapter, BLOGIC_FETCH_LOCALRAM,\n\t\t\t\t\t&fetch_localram, sizeof(fetch_localram),\n\t\t\t\t\t&autoscsi_byte45,\n\t\t\t\t\tsizeof(autoscsi_byte45));\n\t\t\tblogic_cmd(host_adapter, BLOGIC_GET_BOARD_ID, NULL, 0,\n\t\t\t\t\t&id, sizeof(id));\n\t\t\tif (id.fw_ver_digit1 == '5')\n\t\t\t\tforce_scan_order =\n\t\t\t\t\tautoscsi_byte45.force_scan_order;\n\t\t\tforce_scan_order_checked = true;\n\t\t}\n\t\t \n\t\tif (adapter_info.isa_port == BLOGIC_IO_330) {\n\t\t\tpr_probeinfo->adapter_type = BLOGIC_MULTIMASTER;\n\t\t\tpr_probeinfo->adapter_bus_type = BLOGIC_PCI_BUS;\n\t\t\tpr_probeinfo->io_addr = io_addr;\n\t\t\tpr_probeinfo->pci_addr = pci_addr;\n\t\t\tpr_probeinfo->bus = bus;\n\t\t\tpr_probeinfo->dev = device;\n\t\t\tpr_probeinfo->irq_ch = irq_ch;\n\t\t\tpr_probeinfo->pci_device = pci_dev_get(pci_device);\n\t\t\tmmcount++;\n\t\t} else if (blogic_probeinfo_count < BLOGIC_MAX_ADAPTERS) {\n\t\t\tstruct blogic_probeinfo *probeinfo =\n\t\t\t\t&blogic_probeinfo_list[blogic_probeinfo_count++];\n\t\t\tprobeinfo->adapter_type = BLOGIC_MULTIMASTER;\n\t\t\tprobeinfo->adapter_bus_type = BLOGIC_PCI_BUS;\n\t\t\tprobeinfo->io_addr = io_addr;\n\t\t\tprobeinfo->pci_addr = pci_addr;\n\t\t\tprobeinfo->bus = bus;\n\t\t\tprobeinfo->dev = device;\n\t\t\tprobeinfo->irq_ch = irq_ch;\n\t\t\tprobeinfo->pci_device = pci_dev_get(pci_device);\n\t\t\tnonpr_mmcount++;\n\t\t\tmmcount++;\n\t\t} else\n\t\t\tblogic_warn(\"BusLogic: Too many Host Adapters detected\\n\", NULL);\n\t}\n\t \n\tif (force_scan_order)\n\t\tblogic_sort_probeinfo(&blogic_probeinfo_list[nonpr_mmindex],\n\t\t\t\t\tnonpr_mmcount);\n\t \n\tpci_device = NULL;\n\twhile ((pci_device = pci_get_device(PCI_VENDOR_ID_BUSLOGIC,\n\t\t\t\t\tPCI_DEVICE_ID_BUSLOGIC_MULTIMASTER_NC,\n\t\t\t\t\tpci_device)) != NULL) {\n\t\tunsigned char bus;\n\t\tunsigned char device;\n\t\tunsigned int irq_ch;\n\t\tunsigned long io_addr;\n\n\t\tif (pci_enable_device(pci_device))\n\t\t\tcontinue;\n\n\t\tif (dma_set_mask(&pci_device->dev, DMA_BIT_MASK(32)))\n\t\t\tcontinue;\n\n\t\tbus = pci_device->bus->number;\n\t\tdevice = pci_device->devfn >> 3;\n\t\tirq_ch = pci_device->irq;\n\t\tio_addr = pci_resource_start(pci_device, 0);\n\n\t\tif (io_addr == 0 || irq_ch == 0)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < blogic_probeinfo_count; i++) {\n\t\t\tstruct blogic_probeinfo *probeinfo =\n\t\t\t\t\t\t&blogic_probeinfo_list[i];\n\t\t\tif (probeinfo->io_addr == io_addr &&\n\t\t\t\tprobeinfo->adapter_type == BLOGIC_MULTIMASTER) {\n\t\t\t\tprobeinfo->adapter_bus_type = BLOGIC_PCI_BUS;\n\t\t\t\tprobeinfo->pci_addr = 0;\n\t\t\t\tprobeinfo->bus = bus;\n\t\t\t\tprobeinfo->dev = device;\n\t\t\t\tprobeinfo->irq_ch = irq_ch;\n\t\t\t\tprobeinfo->pci_device = pci_dev_get(pci_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn mmcount;\n}\n\n\n \n\nstatic int __init blogic_init_fp_probeinfo(struct blogic_adapter *adapter)\n{\n\tint fpindex = blogic_probeinfo_count, fpcount = 0;\n\tstruct pci_dev *pci_device = NULL;\n\t \n\twhile ((pci_device = pci_get_device(PCI_VENDOR_ID_BUSLOGIC,\n\t\t\t\t\tPCI_DEVICE_ID_BUSLOGIC_FLASHPOINT,\n\t\t\t\t\tpci_device)) != NULL) {\n\t\tunsigned char bus;\n\t\tunsigned char device;\n\t\tunsigned int irq_ch;\n\t\tunsigned long base_addr0;\n\t\tunsigned long base_addr1;\n\t\tunsigned long io_addr;\n\t\tunsigned long pci_addr;\n\n\t\tif (pci_enable_device(pci_device))\n\t\t\tcontinue;\n\n\t\tif (dma_set_mask(&pci_device->dev, DMA_BIT_MASK(32)))\n\t\t\tcontinue;\n\n\t\tbus = pci_device->bus->number;\n\t\tdevice = pci_device->devfn >> 3;\n\t\tirq_ch = pci_device->irq;\n\t\tio_addr = base_addr0 = pci_resource_start(pci_device, 0);\n\t\tpci_addr = base_addr1 = pci_resource_start(pci_device, 1);\n#ifdef CONFIG_SCSI_FLASHPOINT\n\t\tif (pci_resource_flags(pci_device, 0) & IORESOURCE_MEM) {\n\t\t\tblogic_err(\"BusLogic: Base Address0 0x%lX not I/O for FlashPoint Host Adapter\\n\", NULL, base_addr0);\n\t\t\tblogic_err(\"at PCI Bus %d Device %d I/O Address 0x%lX\\n\", NULL, bus, device, io_addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pci_resource_flags(pci_device, 1) & IORESOURCE_IO) {\n\t\t\tblogic_err(\"BusLogic: Base Address1 0x%lX not Memory for FlashPoint Host Adapter\\n\", NULL, base_addr1);\n\t\t\tblogic_err(\"at PCI Bus %d Device %d PCI Address 0x%lX\\n\", NULL, bus, device, pci_addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (irq_ch == 0) {\n\t\t\tblogic_err(\"BusLogic: IRQ Channel %d invalid for FlashPoint Host Adapter\\n\", NULL, irq_ch);\n\t\t\tblogic_err(\"at PCI Bus %d Device %d I/O Address 0x%lX\\n\", NULL, bus, device, io_addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (blogic_global_options.trace_probe) {\n\t\t\tblogic_notice(\"BusLogic: FlashPoint Host Adapter detected at\\n\", NULL);\n\t\t\tblogic_notice(\"BusLogic: PCI Bus %d Device %d I/O Address 0x%lX PCI Address 0x%lX\\n\", NULL, bus, device, io_addr, pci_addr);\n\t\t}\n\t\tif (blogic_probeinfo_count < BLOGIC_MAX_ADAPTERS) {\n\t\t\tstruct blogic_probeinfo *probeinfo =\n\t\t\t\t&blogic_probeinfo_list[blogic_probeinfo_count++];\n\t\t\tprobeinfo->adapter_type = BLOGIC_FLASHPOINT;\n\t\t\tprobeinfo->adapter_bus_type = BLOGIC_PCI_BUS;\n\t\t\tprobeinfo->io_addr = io_addr;\n\t\t\tprobeinfo->pci_addr = pci_addr;\n\t\t\tprobeinfo->bus = bus;\n\t\t\tprobeinfo->dev = device;\n\t\t\tprobeinfo->irq_ch = irq_ch;\n\t\t\tprobeinfo->pci_device = pci_dev_get(pci_device);\n\t\t\tfpcount++;\n\t\t} else\n\t\t\tblogic_warn(\"BusLogic: Too many Host Adapters detected\\n\", NULL);\n#else\n\t\tblogic_err(\"BusLogic: FlashPoint Host Adapter detected at PCI Bus %d Device %d\\n\", NULL, bus, device);\n\t\tblogic_err(\"BusLogic: I/O Address 0x%lX PCI Address 0x%lX, irq %d, but FlashPoint\\n\", NULL, io_addr, pci_addr, irq_ch);\n\t\tblogic_err(\"BusLogic: support was omitted in this kernel configuration.\\n\", NULL);\n#endif\n\t}\n\t \n\tblogic_sort_probeinfo(&blogic_probeinfo_list[fpindex], fpcount);\n\treturn fpcount;\n}\n\n\n \n\nstatic void __init blogic_init_probeinfo_list(struct blogic_adapter *adapter)\n{\n\t \n\tif (!blogic_probe_options.noprobe_pci) {\n\t\tif (blogic_probe_options.multimaster_first) {\n\t\t\tblogic_init_mm_probeinfo(adapter);\n\t\t\tblogic_init_fp_probeinfo(adapter);\n\t\t} else if (blogic_probe_options.flashpoint_first) {\n\t\t\tblogic_init_fp_probeinfo(adapter);\n\t\t\tblogic_init_mm_probeinfo(adapter);\n\t\t} else {\n\t\t\tint fpcount = blogic_init_fp_probeinfo(adapter);\n\t\t\tint mmcount = blogic_init_mm_probeinfo(adapter);\n\t\t\tif (fpcount > 0 && mmcount > 0) {\n\t\t\t\tstruct blogic_probeinfo *probeinfo =\n\t\t\t\t\t&blogic_probeinfo_list[fpcount];\n\t\t\t\tstruct blogic_adapter *myadapter = adapter;\n\t\t\t\tstruct blogic_fetch_localram fetch_localram;\n\t\t\t\tstruct blogic_bios_drvmap d0_mapbyte;\n\n\t\t\t\twhile (probeinfo->adapter_bus_type !=\n\t\t\t\t\t\tBLOGIC_PCI_BUS)\n\t\t\t\t\tprobeinfo++;\n\t\t\t\tmyadapter->io_addr = probeinfo->io_addr;\n\t\t\t\tfetch_localram.offset =\n\t\t\t\t\tBLOGIC_BIOS_BASE + BLOGIC_BIOS_DRVMAP;\n\t\t\t\tfetch_localram.count = sizeof(d0_mapbyte);\n\t\t\t\tblogic_cmd(myadapter, BLOGIC_FETCH_LOCALRAM,\n\t\t\t\t\t\t&fetch_localram,\n\t\t\t\t\t\tsizeof(fetch_localram),\n\t\t\t\t\t\t&d0_mapbyte,\n\t\t\t\t\t\tsizeof(d0_mapbyte));\n\t\t\t\t \n\t\t\t\tif (d0_mapbyte.diskgeom != BLOGIC_BIOS_NODISK) {\n\t\t\t\t\tstruct blogic_probeinfo saved_probeinfo[BLOGIC_MAX_ADAPTERS];\n\t\t\t\t\tint mmcount = blogic_probeinfo_count - fpcount;\n\n\t\t\t\t\tmemcpy(saved_probeinfo,\n\t\t\t\t\t\tblogic_probeinfo_list,\n\t\t\t\t\t\tblogic_probeinfo_count * sizeof(struct blogic_probeinfo));\n\t\t\t\t\tmemcpy(&blogic_probeinfo_list[0],\n\t\t\t\t\t\t&saved_probeinfo[fpcount],\n\t\t\t\t\t\tmmcount * sizeof(struct blogic_probeinfo));\n\t\t\t\t\tmemcpy(&blogic_probeinfo_list[mmcount],\n\t\t\t\t\t\t&saved_probeinfo[0],\n\t\t\t\t\t\tfpcount * sizeof(struct blogic_probeinfo));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n \n\nstatic bool blogic_failure(struct blogic_adapter *adapter, char *msg)\n{\n\tblogic_announce_drvr(adapter);\n\tif (adapter->adapter_bus_type == BLOGIC_PCI_BUS) {\n\t\tblogic_err(\"While configuring BusLogic PCI Host Adapter at\\n\",\n\t\t\t\tadapter);\n\t\tblogic_err(\"Bus %d Device %d I/O Address 0x%lX PCI Address 0x%lX:\\n\", adapter, adapter->bus, adapter->dev, adapter->io_addr, adapter->pci_addr);\n\t} else\n\t\tblogic_err(\"While configuring BusLogic Host Adapter at I/O Address 0x%lX:\\n\", adapter, adapter->io_addr);\n\tblogic_err(\"%s FAILED - DETACHING\\n\", adapter, msg);\n\tif (blogic_cmd_failure_reason != NULL)\n\t\tblogic_err(\"ADDITIONAL FAILURE INFO - %s\\n\", adapter,\n\t\t\t\tblogic_cmd_failure_reason);\n\treturn false;\n}\n\n\n \n\nstatic bool __init blogic_probe(struct blogic_adapter *adapter)\n{\n\tunion blogic_stat_reg statusreg;\n\tunion blogic_int_reg intreg;\n\tunion blogic_geo_reg georeg;\n\t \n\tif (blogic_flashpoint_type(adapter)) {\n\t\tstruct fpoint_info *fpinfo = &adapter->fpinfo;\n\t\tfpinfo->base_addr = (u32) adapter->io_addr;\n\t\tfpinfo->irq_ch = adapter->irq_ch;\n\t\tfpinfo->present = false;\n\t\tif (!(FlashPoint_ProbeHostAdapter(fpinfo) == 0 &&\n\t\t\t\t\tfpinfo->present)) {\n\t\t\tblogic_err(\"BusLogic: FlashPoint Host Adapter detected at PCI Bus %d Device %d\\n\", adapter, adapter->bus, adapter->dev);\n\t\t\tblogic_err(\"BusLogic: I/O Address 0x%lX PCI Address 0x%lX, but FlashPoint\\n\", adapter, adapter->io_addr, adapter->pci_addr);\n\t\t\tblogic_err(\"BusLogic: Probe Function failed to validate it.\\n\", adapter);\n\t\t\treturn false;\n\t\t}\n\t\tif (blogic_global_options.trace_probe)\n\t\t\tblogic_notice(\"BusLogic_Probe(0x%lX): FlashPoint Found\\n\", adapter, adapter->io_addr);\n\t\t \n\t\treturn true;\n\t}\n\t \n\tstatusreg.all = blogic_rdstatus(adapter);\n\tintreg.all = blogic_rdint(adapter);\n\tgeoreg.all = blogic_rdgeom(adapter);\n\tif (blogic_global_options.trace_probe)\n\t\tblogic_notice(\"BusLogic_Probe(0x%lX): Status 0x%02X, Interrupt 0x%02X, Geometry 0x%02X\\n\", adapter, adapter->io_addr, statusreg.all, intreg.all, georeg.all);\n\tif (statusreg.all == 0 || statusreg.sr.diag_active ||\n\t\t\tstatusreg.sr.cmd_param_busy || statusreg.sr.rsvd ||\n\t\t\tstatusreg.sr.cmd_invalid || intreg.ir.rsvd != 0)\n\t\treturn false;\n\t \n\tif (georeg.all == 0xFF)\n\t\treturn false;\n\t \n\treturn true;\n}\n\n\n \n\nstatic bool blogic_hwreset(struct blogic_adapter *adapter, bool hard_reset)\n{\n\tunion blogic_stat_reg statusreg;\n\tint timeout;\n\t \n\tif (blogic_flashpoint_type(adapter)) {\n\t\tstruct fpoint_info *fpinfo = &adapter->fpinfo;\n\t\tfpinfo->softreset = !hard_reset;\n\t\tfpinfo->report_underrun = true;\n\t\tadapter->cardhandle =\n\t\t\tFlashPoint_HardwareResetHostAdapter(fpinfo);\n\t\tif (adapter->cardhandle == (void *)FPOINT_BADCARD_HANDLE)\n\t\t\treturn false;\n\t\t \n\t\treturn true;\n\t}\n\t \n\tif (hard_reset)\n\t\tblogic_hardreset(adapter);\n\telse\n\t\tblogic_softreset(adapter);\n\t \n\ttimeout = 5 * 10000;\n\twhile (--timeout >= 0) {\n\t\tstatusreg.all = blogic_rdstatus(adapter);\n\t\tif (statusreg.sr.diag_active)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\tif (blogic_global_options.trace_hw_reset)\n\t\tblogic_notice(\"BusLogic_HardwareReset(0x%lX): Diagnostic Active, Status 0x%02X\\n\", adapter, adapter->io_addr, statusreg.all);\n\tif (timeout < 0)\n\t\treturn false;\n\t \n\tudelay(100);\n\t \n\ttimeout = 10 * 10000;\n\twhile (--timeout >= 0) {\n\t\tstatusreg.all = blogic_rdstatus(adapter);\n\t\tif (!statusreg.sr.diag_active)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\tif (blogic_global_options.trace_hw_reset)\n\t\tblogic_notice(\"BusLogic_HardwareReset(0x%lX): Diagnostic Completed, Status 0x%02X\\n\", adapter, adapter->io_addr, statusreg.all);\n\tif (timeout < 0)\n\t\treturn false;\n\t \n\ttimeout = 10000;\n\twhile (--timeout >= 0) {\n\t\tstatusreg.all = blogic_rdstatus(adapter);\n\t\tif (statusreg.sr.diag_failed || statusreg.sr.adapter_ready ||\n\t\t\t\tstatusreg.sr.datain_ready)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\tif (blogic_global_options.trace_hw_reset)\n\t\tblogic_notice(\"BusLogic_HardwareReset(0x%lX): Host Adapter Ready, Status 0x%02X\\n\", adapter, adapter->io_addr, statusreg.all);\n\tif (timeout < 0)\n\t\treturn false;\n\t \n\tif (statusreg.sr.diag_failed || !statusreg.sr.adapter_ready) {\n\t\tblogic_cmd_failure_reason = NULL;\n\t\tblogic_failure(adapter, \"HARD RESET DIAGNOSTICS\");\n\t\tblogic_err(\"HOST ADAPTER STATUS REGISTER = %02X\\n\", adapter,\n\t\t\t\tstatusreg.all);\n\t\tif (statusreg.sr.datain_ready)\n\t\t\tblogic_err(\"HOST ADAPTER ERROR CODE = %d\\n\", adapter,\n\t\t\t\t\tblogic_rddatain(adapter));\n\t\treturn false;\n\t}\n\t \n\treturn true;\n}\n\n\n \n\nstatic bool __init blogic_checkadapter(struct blogic_adapter *adapter)\n{\n\tstruct blogic_ext_setup ext_setupinfo;\n\tunsigned char req_replylen;\n\tbool result = true;\n\t \n\tif (blogic_flashpoint_type(adapter))\n\t\treturn true;\n\t \n\treq_replylen = sizeof(ext_setupinfo);\n\tif (blogic_cmd(adapter, BLOGIC_INQ_EXTSETUP, &req_replylen,\n\t\t\t\tsizeof(req_replylen), &ext_setupinfo,\n\t\t\t\tsizeof(ext_setupinfo)) != sizeof(ext_setupinfo))\n\t\tresult = false;\n\t \n\tif (blogic_global_options.trace_probe)\n\t\tblogic_notice(\"BusLogic_Check(0x%lX): MultiMaster %s\\n\", adapter,\n\t\t\t\tadapter->io_addr,\n\t\t\t\t(result ? \"Found\" : \"Not Found\"));\n\treturn result;\n}\n\n\n \n\nstatic bool __init blogic_rdconfig(struct blogic_adapter *adapter)\n{\n\tstruct blogic_board_id id;\n\tstruct blogic_config config;\n\tstruct blogic_setup_info setupinfo;\n\tstruct blogic_ext_setup ext_setupinfo;\n\tunsigned char model[5];\n\tunsigned char fw_ver_digit3;\n\tunsigned char fw_ver_letter;\n\tstruct blogic_adapter_info adapter_info;\n\tstruct blogic_fetch_localram fetch_localram;\n\tstruct blogic_autoscsi autoscsi;\n\tunion blogic_geo_reg georeg;\n\tunsigned char req_replylen;\n\tunsigned char *tgt, ch;\n\tint tgt_id, i;\n\t \n\tif (blogic_flashpoint_type(adapter)) {\n\t\tstruct fpoint_info *fpinfo = &adapter->fpinfo;\n\t\ttgt = adapter->model;\n\t\t*tgt++ = 'B';\n\t\t*tgt++ = 'T';\n\t\t*tgt++ = '-';\n\t\tfor (i = 0; i < sizeof(fpinfo->model); i++)\n\t\t\t*tgt++ = fpinfo->model[i];\n\t\t*tgt++ = '\\0';\n\t\tstrcpy(adapter->fw_ver, FLASHPOINT_FW_VER);\n\t\tadapter->scsi_id = fpinfo->scsi_id;\n\t\tadapter->ext_trans_enable = fpinfo->ext_trans_enable;\n\t\tadapter->parity = fpinfo->parity;\n\t\tadapter->reset_enabled = !fpinfo->softreset;\n\t\tadapter->level_int = true;\n\t\tadapter->wide = fpinfo->wide;\n\t\tadapter->differential = false;\n\t\tadapter->scam = true;\n\t\tadapter->ultra = true;\n\t\tadapter->ext_lun = true;\n\t\tadapter->terminfo_valid = true;\n\t\tadapter->low_term = fpinfo->low_term;\n\t\tadapter->high_term = fpinfo->high_term;\n\t\tadapter->scam_enabled = fpinfo->scam_enabled;\n\t\tadapter->scam_lev2 = fpinfo->scam_lev2;\n\t\tadapter->drvr_sglimit = BLOGIC_SG_LIMIT;\n\t\tadapter->maxdev = (adapter->wide ? 16 : 8);\n\t\tadapter->maxlun = 32;\n\t\tadapter->initccbs = 4 * BLOGIC_CCB_GRP_ALLOCSIZE;\n\t\tadapter->inc_ccbs = BLOGIC_CCB_GRP_ALLOCSIZE;\n\t\tadapter->drvr_qdepth = 255;\n\t\tadapter->adapter_qdepth = adapter->drvr_qdepth;\n\t\tadapter->sync_ok = fpinfo->sync_ok;\n\t\tadapter->fast_ok = fpinfo->fast_ok;\n\t\tadapter->ultra_ok = fpinfo->ultra_ok;\n\t\tadapter->wide_ok = fpinfo->wide_ok;\n\t\tadapter->discon_ok = fpinfo->discon_ok;\n\t\tadapter->tagq_ok = 0xFFFF;\n\t\tgoto common;\n\t}\n\t \n\tif (blogic_cmd(adapter, BLOGIC_GET_BOARD_ID, NULL, 0, &id,\n\t\t\t\tsizeof(id)) != sizeof(id))\n\t\treturn blogic_failure(adapter, \"INQUIRE BOARD ID\");\n\t \n\tif (blogic_cmd(adapter, BLOGIC_INQ_CONFIG, NULL, 0, &config,\n\t\t\t\tsizeof(config))\n\t    != sizeof(config))\n\t\treturn blogic_failure(adapter, \"INQUIRE CONFIGURATION\");\n\t \n\treq_replylen = sizeof(setupinfo);\n\tif (blogic_cmd(adapter, BLOGIC_INQ_SETUPINFO, &req_replylen,\n\t\t\t\tsizeof(req_replylen), &setupinfo,\n\t\t\t\tsizeof(setupinfo)) != sizeof(setupinfo))\n\t\treturn blogic_failure(adapter, \"INQUIRE SETUP INFORMATION\");\n\t \n\treq_replylen = sizeof(ext_setupinfo);\n\tif (blogic_cmd(adapter, BLOGIC_INQ_EXTSETUP, &req_replylen,\n\t\t\t\tsizeof(req_replylen), &ext_setupinfo,\n\t\t\t\tsizeof(ext_setupinfo)) != sizeof(ext_setupinfo))\n\t\treturn blogic_failure(adapter,\n\t\t\t\t\t\"INQUIRE EXTENDED SETUP INFORMATION\");\n\t \n\tfw_ver_digit3 = '\\0';\n\tif (id.fw_ver_digit1 > '0')\n\t\tif (blogic_cmd(adapter, BLOGIC_INQ_FWVER_D3, NULL, 0,\n\t\t\t\t&fw_ver_digit3,\n\t\t\t\tsizeof(fw_ver_digit3)) != sizeof(fw_ver_digit3))\n\t\t\treturn blogic_failure(adapter,\n\t\t\t\t\t\t\"INQUIRE FIRMWARE 3RD DIGIT\");\n\t \n\tif (ext_setupinfo.bus_type == 'A' && id.fw_ver_digit1 == '2')\n\t\t \n\t\tstrcpy(model, \"542B\");\n\telse if (ext_setupinfo.bus_type == 'E' && id.fw_ver_digit1 == '2' &&\n\t\t\t(id.fw_ver_digit2 <= '1' || (id.fw_ver_digit2 == '2' &&\n\t\t\t\t\t\t     fw_ver_digit3 == '0')))\n\t\t \n\t\tstrcpy(model, \"742A\");\n\telse if (ext_setupinfo.bus_type == 'E' && id.fw_ver_digit1 == '0')\n\t\t \n\t\tstrcpy(model, \"747A\");\n\telse {\n\t\treq_replylen = sizeof(model);\n\t\tif (blogic_cmd(adapter, BLOGIC_INQ_MODELNO, &req_replylen,\n\t\t\t\t\tsizeof(req_replylen), &model,\n\t\t\t\t\tsizeof(model)) != sizeof(model))\n\t\t\treturn blogic_failure(adapter,\n\t\t\t\t\t\"INQUIRE HOST ADAPTER MODEL NUMBER\");\n\t}\n\t \n\t \n\ttgt = adapter->model;\n\t*tgt++ = 'B';\n\t*tgt++ = 'T';\n\t*tgt++ = '-';\n\tfor (i = 0; i < sizeof(model); i++) {\n\t\tch = model[i];\n\t\tif (ch == ' ' || ch == '\\0')\n\t\t\tbreak;\n\t\t*tgt++ = ch;\n\t}\n\t*tgt++ = '\\0';\n\t \n\ttgt = adapter->fw_ver;\n\t*tgt++ = id.fw_ver_digit1;\n\t*tgt++ = '.';\n\t*tgt++ = id.fw_ver_digit2;\n\tif (fw_ver_digit3 != ' ' && fw_ver_digit3 != '\\0')\n\t\t*tgt++ = fw_ver_digit3;\n\t*tgt = '\\0';\n\t \n\tif (strcmp(adapter->fw_ver, \"3.3\") >= 0) {\n\t\tif (blogic_cmd(adapter, BLOGIC_INQ_FWVER_LETTER, NULL, 0,\n\t\t\t\t&fw_ver_letter,\n\t\t\t\tsizeof(fw_ver_letter)) != sizeof(fw_ver_letter))\n\t\t\treturn blogic_failure(adapter,\n\t\t\t\t\t\"INQUIRE FIRMWARE VERSION LETTER\");\n\t\tif (fw_ver_letter != ' ' && fw_ver_letter != '\\0')\n\t\t\t*tgt++ = fw_ver_letter;\n\t\t*tgt = '\\0';\n\t}\n\t \n\tadapter->scsi_id = config.id;\n\t \n\tadapter->adapter_bus_type =\n\t\t\tblogic_adater_bus_types[adapter->model[3] - '4'];\n\tif (adapter->irq_ch == 0) {\n\t\tif (config.irq_ch9)\n\t\t\tadapter->irq_ch = 9;\n\t\telse if (config.irq_ch10)\n\t\t\tadapter->irq_ch = 10;\n\t\telse if (config.irq_ch11)\n\t\t\tadapter->irq_ch = 11;\n\t\telse if (config.irq_ch12)\n\t\t\tadapter->irq_ch = 12;\n\t\telse if (config.irq_ch14)\n\t\t\tadapter->irq_ch = 14;\n\t\telse if (config.irq_ch15)\n\t\t\tadapter->irq_ch = 15;\n\t}\n\t \n\tgeoreg.all = blogic_rdgeom(adapter);\n\tadapter->ext_trans_enable = georeg.gr.ext_trans_enable;\n\t \n\tadapter->adapter_sglimit = ext_setupinfo.sg_limit;\n\tadapter->drvr_sglimit = adapter->adapter_sglimit;\n\tif (adapter->adapter_sglimit > BLOGIC_SG_LIMIT)\n\t\tadapter->drvr_sglimit = BLOGIC_SG_LIMIT;\n\tif (ext_setupinfo.misc.level_int)\n\t\tadapter->level_int = true;\n\tadapter->wide = ext_setupinfo.wide;\n\tadapter->differential = ext_setupinfo.differential;\n\tadapter->scam = ext_setupinfo.scam;\n\tadapter->ultra = ext_setupinfo.ultra;\n\t \n\tif (adapter->fw_ver[0] == '5' || (adapter->fw_ver[0] == '4' &&\n\t\t\t\tadapter->wide))\n\t\tadapter->ext_lun = true;\n\t \n\tif (adapter->fw_ver[0] == '5') {\n\t\tif (blogic_cmd(adapter, BLOGIC_INQ_PCI_INFO, NULL, 0,\n\t\t\t\t&adapter_info,\n\t\t\t\tsizeof(adapter_info)) != sizeof(adapter_info))\n\t\t\treturn blogic_failure(adapter,\n\t\t\t\t\t\"INQUIRE PCI HOST ADAPTER INFORMATION\");\n\t\t \n\t\tif (adapter_info.genericinfo_valid) {\n\t\t\tadapter->terminfo_valid = true;\n\t\t\tadapter->low_term = adapter_info.low_term;\n\t\t\tadapter->high_term = adapter_info.high_term;\n\t\t}\n\t}\n\t \n\tif (adapter->fw_ver[0] >= '4') {\n\t\tfetch_localram.offset = BLOGIC_AUTOSCSI_BASE;\n\t\tfetch_localram.count = sizeof(autoscsi);\n\t\tif (blogic_cmd(adapter, BLOGIC_FETCH_LOCALRAM, &fetch_localram,\n\t\t\t\t\tsizeof(fetch_localram), &autoscsi,\n\t\t\t\t\tsizeof(autoscsi)) != sizeof(autoscsi))\n\t\t\treturn blogic_failure(adapter,\n\t\t\t\t\t\t\"FETCH HOST ADAPTER LOCAL RAM\");\n\t\t \n\t\tadapter->parity = autoscsi.parity;\n\t\tadapter->reset_enabled = autoscsi.reset_enabled;\n\t\tif (adapter->fw_ver[0] == '4') {\n\t\t\tadapter->terminfo_valid = true;\n\t\t\tadapter->low_term = autoscsi.low_term;\n\t\t\tadapter->high_term = autoscsi.high_term;\n\t\t}\n\t\t \n\t\tadapter->wide_ok = autoscsi.wide_ok;\n\t\tadapter->fast_ok = autoscsi.fast_ok;\n\t\tadapter->sync_ok = autoscsi.sync_ok;\n\t\tadapter->discon_ok = autoscsi.discon_ok;\n\t\tif (adapter->ultra)\n\t\t\tadapter->ultra_ok = autoscsi.ultra_ok;\n\t\tif (adapter->scam) {\n\t\t\tadapter->scam_enabled = autoscsi.scam_enabled;\n\t\t\tadapter->scam_lev2 = autoscsi.scam_lev2;\n\t\t}\n\t}\n\t \n\tif (adapter->fw_ver[0] < '4') {\n\t\tif (setupinfo.sync) {\n\t\t\tadapter->sync_ok = 0xFF;\n\t\t\tif (adapter->adapter_bus_type == BLOGIC_EISA_BUS) {\n\t\t\t\tif (ext_setupinfo.misc.fast_on_eisa)\n\t\t\t\t\tadapter->fast_ok = 0xFF;\n\t\t\t\tif (strcmp(adapter->model, \"BT-757\") == 0)\n\t\t\t\t\tadapter->wide_ok = 0xFF;\n\t\t\t}\n\t\t}\n\t\tadapter->discon_ok = 0xFF;\n\t\tadapter->parity = setupinfo.parity;\n\t\tadapter->reset_enabled = true;\n\t}\n\t \n\tadapter->maxdev = (adapter->wide ? 16 : 8);\n\tadapter->maxlun = (adapter->ext_lun ? 32 : 8);\n\t \n\tif (adapter->fw_ver[0] == '5')\n\t\tadapter->adapter_qdepth = 192;\n\telse if (adapter->fw_ver[0] == '4')\n\t\tadapter->adapter_qdepth = 100;\n\telse\n\t\tadapter->adapter_qdepth = 30;\n\tif (strcmp(adapter->fw_ver, \"3.31\") >= 0) {\n\t\tadapter->strict_rr = true;\n\t\tadapter->mbox_count = BLOGIC_MAX_MAILBOX;\n\t} else {\n\t\tadapter->strict_rr = false;\n\t\tadapter->mbox_count = 32;\n\t}\n\tadapter->drvr_qdepth = adapter->mbox_count;\n\tadapter->initccbs = 4 * BLOGIC_CCB_GRP_ALLOCSIZE;\n\tadapter->inc_ccbs = BLOGIC_CCB_GRP_ALLOCSIZE;\n\t \n\tadapter->tagq_ok = 0;\n\tswitch (adapter->fw_ver[0]) {\n\tcase '5':\n\t\tadapter->tagq_ok = 0xFFFF;\n\t\tbreak;\n\tcase '4':\n\t\tif (strcmp(adapter->fw_ver, \"4.22\") >= 0)\n\t\t\tadapter->tagq_ok = 0xFFFF;\n\t\tbreak;\n\tcase '3':\n\t\tif (strcmp(adapter->fw_ver, \"3.35\") >= 0)\n\t\t\tadapter->tagq_ok = 0xFFFF;\n\t\tbreak;\n\t}\n\t \n\tadapter->bios_addr = ext_setupinfo.bios_addr << 12;\n\t \n\tif (adapter->bios_addr > 0 &&\n\t    strcmp(adapter->model, \"BT-445S\") == 0 &&\n\t    strcmp(adapter->fw_ver, \"3.37\") < 0)\n\t\treturn blogic_failure(adapter, \"Too old firmware\");\n\t \ncommon:\n\t \n\tstrcpy(adapter->full_model, \"BusLogic \");\n\tstrcat(adapter->full_model, adapter->model);\n\t \n\tfor (tgt_id = 0; tgt_id < BLOGIC_MAXDEV; tgt_id++) {\n\t\tunsigned char qdepth = 0;\n\t\tif (adapter->drvr_opts != NULL &&\n\t\t\t\tadapter->drvr_opts->qdepth[tgt_id] > 0)\n\t\t\tqdepth = adapter->drvr_opts->qdepth[tgt_id];\n\t\tadapter->qdepth[tgt_id] = qdepth;\n\t}\n\tadapter->untag_qdepth = BLOGIC_UNTAG_DEPTH;\n\tif (adapter->drvr_opts != NULL)\n\t\tadapter->common_qdepth = adapter->drvr_opts->common_qdepth;\n\tif (adapter->common_qdepth > 0 &&\n\t\t\tadapter->common_qdepth < adapter->untag_qdepth)\n\t\tadapter->untag_qdepth = adapter->common_qdepth;\n\t \n\tadapter->tagq_ok &= adapter->discon_ok;\n\t \n\tif (adapter->drvr_opts != NULL)\n\t\tadapter->tagq_ok = (adapter->drvr_opts->tagq_ok &\n\t\t\t\tadapter->drvr_opts->tagq_ok_mask) |\n\t\t\t(adapter->tagq_ok & ~adapter->drvr_opts->tagq_ok_mask);\n\n\t \n\tif (adapter->drvr_opts != NULL &&\n\t\t\tadapter->drvr_opts->bus_settle_time > 0)\n\t\tadapter->bus_settle_time = adapter->drvr_opts->bus_settle_time;\n\telse\n\t\tadapter->bus_settle_time = BLOGIC_BUS_SETTLE_TIME;\n\t \n\treturn true;\n}\n\n\n \n\nstatic bool __init blogic_reportconfig(struct blogic_adapter *adapter)\n{\n\tunsigned short alltgt_mask = (1 << adapter->maxdev) - 1;\n\tunsigned short sync_ok, fast_ok;\n\tunsigned short ultra_ok, wide_ok;\n\tunsigned short discon_ok, tagq_ok;\n\tbool common_syncneg, common_tagq_depth;\n\tchar syncstr[BLOGIC_MAXDEV + 1];\n\tchar widestr[BLOGIC_MAXDEV + 1];\n\tchar discon_str[BLOGIC_MAXDEV + 1];\n\tchar tagq_str[BLOGIC_MAXDEV + 1];\n\tchar *syncmsg = syncstr;\n\tchar *widemsg = widestr;\n\tchar *discon_msg = discon_str;\n\tchar *tagq_msg = tagq_str;\n\tint tgt_id;\n\n\tblogic_info(\"Configuring BusLogic Model %s %s%s%s%s SCSI Host Adapter\\n\", adapter, adapter->model, blogic_adapter_busnames[adapter->adapter_bus_type], (adapter->wide ? \" Wide\" : \"\"), (adapter->differential ? \" Differential\" : \"\"), (adapter->ultra ? \" Ultra\" : \"\"));\n\tblogic_info(\"  Firmware Version: %s, I/O Address: 0x%lX, IRQ Channel: %d/%s\\n\", adapter, adapter->fw_ver, adapter->io_addr, adapter->irq_ch, (adapter->level_int ? \"Level\" : \"Edge\"));\n\tif (adapter->adapter_bus_type != BLOGIC_PCI_BUS) {\n\t\tblogic_info(\"  DMA Channel: None, \", adapter);\n\t\tif (adapter->bios_addr > 0)\n\t\t\tblogic_info(\"BIOS Address: 0x%X, \", adapter,\n\t\t\t\t\tadapter->bios_addr);\n\t\telse\n\t\t\tblogic_info(\"BIOS Address: None, \", adapter);\n\t} else {\n\t\tblogic_info(\"  PCI Bus: %d, Device: %d, Address: \", adapter,\n\t\t\t\tadapter->bus, adapter->dev);\n\t\tif (adapter->pci_addr > 0)\n\t\t\tblogic_info(\"0x%lX, \", adapter, adapter->pci_addr);\n\t\telse\n\t\t\tblogic_info(\"Unassigned, \", adapter);\n\t}\n\tblogic_info(\"Host Adapter SCSI ID: %d\\n\", adapter, adapter->scsi_id);\n\tblogic_info(\"  Parity Checking: %s, Extended Translation: %s\\n\",\n\t\t\tadapter, (adapter->parity ? \"Enabled\" : \"Disabled\"),\n\t\t\t(adapter->ext_trans_enable ? \"Enabled\" : \"Disabled\"));\n\talltgt_mask &= ~(1 << adapter->scsi_id);\n\tsync_ok = adapter->sync_ok & alltgt_mask;\n\tfast_ok = adapter->fast_ok & alltgt_mask;\n\tultra_ok = adapter->ultra_ok & alltgt_mask;\n\tif ((blogic_multimaster_type(adapter) &&\n\t\t\t(adapter->fw_ver[0] >= '4' ||\n\t\t\t adapter->adapter_bus_type == BLOGIC_EISA_BUS)) ||\n\t\t\tblogic_flashpoint_type(adapter)) {\n\t\tcommon_syncneg = false;\n\t\tif (sync_ok == 0) {\n\t\t\tsyncmsg = \"Disabled\";\n\t\t\tcommon_syncneg = true;\n\t\t} else if (sync_ok == alltgt_mask) {\n\t\t\tif (fast_ok == 0) {\n\t\t\t\tsyncmsg = \"Slow\";\n\t\t\t\tcommon_syncneg = true;\n\t\t\t} else if (fast_ok == alltgt_mask) {\n\t\t\t\tif (ultra_ok == 0) {\n\t\t\t\t\tsyncmsg = \"Fast\";\n\t\t\t\t\tcommon_syncneg = true;\n\t\t\t\t} else if (ultra_ok == alltgt_mask) {\n\t\t\t\t\tsyncmsg = \"Ultra\";\n\t\t\t\t\tcommon_syncneg = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!common_syncneg) {\n\t\t\tfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\n\t\t\t\tsyncstr[tgt_id] = ((!(sync_ok & (1 << tgt_id))) ? 'N' : (!(fast_ok & (1 << tgt_id)) ? 'S' : (!(ultra_ok & (1 << tgt_id)) ? 'F' : 'U')));\n\t\t\tsyncstr[adapter->scsi_id] = '#';\n\t\t\tsyncstr[adapter->maxdev] = '\\0';\n\t\t}\n\t} else\n\t\tsyncmsg = (sync_ok == 0 ? \"Disabled\" : \"Enabled\");\n\twide_ok = adapter->wide_ok & alltgt_mask;\n\tif (wide_ok == 0)\n\t\twidemsg = \"Disabled\";\n\telse if (wide_ok == alltgt_mask)\n\t\twidemsg = \"Enabled\";\n\telse {\n\t\tfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\n\t\t\twidestr[tgt_id] = ((wide_ok & (1 << tgt_id)) ? 'Y' : 'N');\n\t\twidestr[adapter->scsi_id] = '#';\n\t\twidestr[adapter->maxdev] = '\\0';\n\t}\n\tdiscon_ok = adapter->discon_ok & alltgt_mask;\n\tif (discon_ok == 0)\n\t\tdiscon_msg = \"Disabled\";\n\telse if (discon_ok == alltgt_mask)\n\t\tdiscon_msg = \"Enabled\";\n\telse {\n\t\tfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\n\t\t\tdiscon_str[tgt_id] = ((discon_ok & (1 << tgt_id)) ? 'Y' : 'N');\n\t\tdiscon_str[adapter->scsi_id] = '#';\n\t\tdiscon_str[adapter->maxdev] = '\\0';\n\t}\n\ttagq_ok = adapter->tagq_ok & alltgt_mask;\n\tif (tagq_ok == 0)\n\t\ttagq_msg = \"Disabled\";\n\telse if (tagq_ok == alltgt_mask)\n\t\ttagq_msg = \"Enabled\";\n\telse {\n\t\tfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\n\t\t\ttagq_str[tgt_id] = ((tagq_ok & (1 << tgt_id)) ? 'Y' : 'N');\n\t\ttagq_str[adapter->scsi_id] = '#';\n\t\ttagq_str[adapter->maxdev] = '\\0';\n\t}\n\tblogic_info(\"  Synchronous Negotiation: %s, Wide Negotiation: %s\\n\",\n\t\t\tadapter, syncmsg, widemsg);\n\tblogic_info(\"  Disconnect/Reconnect: %s, Tagged Queuing: %s\\n\", adapter,\n\t\t\tdiscon_msg, tagq_msg);\n\tif (blogic_multimaster_type(adapter)) {\n\t\tblogic_info(\"  Scatter/Gather Limit: %d of %d segments, Mailboxes: %d\\n\", adapter, adapter->drvr_sglimit, adapter->adapter_sglimit, adapter->mbox_count);\n\t\tblogic_info(\"  Driver Queue Depth: %d, Host Adapter Queue Depth: %d\\n\", adapter, adapter->drvr_qdepth, adapter->adapter_qdepth);\n\t} else\n\t\tblogic_info(\"  Driver Queue Depth: %d, Scatter/Gather Limit: %d segments\\n\", adapter, adapter->drvr_qdepth, adapter->drvr_sglimit);\n\tblogic_info(\"  Tagged Queue Depth: \", adapter);\n\tcommon_tagq_depth = true;\n\tfor (tgt_id = 1; tgt_id < adapter->maxdev; tgt_id++)\n\t\tif (adapter->qdepth[tgt_id] != adapter->qdepth[0]) {\n\t\t\tcommon_tagq_depth = false;\n\t\t\tbreak;\n\t\t}\n\tif (common_tagq_depth) {\n\t\tif (adapter->qdepth[0] > 0)\n\t\t\tblogic_info(\"%d\", adapter, adapter->qdepth[0]);\n\t\telse\n\t\t\tblogic_info(\"Automatic\", adapter);\n\t} else\n\t\tblogic_info(\"Individual\", adapter);\n\tblogic_info(\", Untagged Queue Depth: %d\\n\", adapter,\n\t\t\tadapter->untag_qdepth);\n\tif (adapter->terminfo_valid) {\n\t\tif (adapter->wide)\n\t\t\tblogic_info(\"  SCSI Bus Termination: %s\", adapter,\n\t\t\t\t(adapter->low_term ? (adapter->high_term ? \"Both Enabled\" : \"Low Enabled\") : (adapter->high_term ? \"High Enabled\" : \"Both Disabled\")));\n\t\telse\n\t\t\tblogic_info(\"  SCSI Bus Termination: %s\", adapter,\n\t\t\t\t(adapter->low_term ? \"Enabled\" : \"Disabled\"));\n\t\tif (adapter->scam)\n\t\t\tblogic_info(\", SCAM: %s\", adapter,\n\t\t\t\t(adapter->scam_enabled ? (adapter->scam_lev2 ? \"Enabled, Level 2\" : \"Enabled, Level 1\") : \"Disabled\"));\n\t\tblogic_info(\"\\n\", adapter);\n\t}\n\t \n\treturn true;\n}\n\n\n \n\nstatic bool __init blogic_getres(struct blogic_adapter *adapter)\n{\n\tif (adapter->irq_ch == 0) {\n\t\tblogic_err(\"NO LEGAL INTERRUPT CHANNEL ASSIGNED - DETACHING\\n\",\n\t\t\t\tadapter);\n\t\treturn false;\n\t}\n\t \n\tif (request_irq(adapter->irq_ch, blogic_inthandler, IRQF_SHARED,\n\t\t\t\tadapter->full_model, adapter) < 0) {\n\t\tblogic_err(\"UNABLE TO ACQUIRE IRQ CHANNEL %d - DETACHING\\n\",\n\t\t\t\tadapter, adapter->irq_ch);\n\t\treturn false;\n\t}\n\tadapter->irq_acquired = true;\n\t \n\treturn true;\n}\n\n\n \n\nstatic void blogic_relres(struct blogic_adapter *adapter)\n{\n\t \n\tif (adapter->irq_acquired)\n\t\tfree_irq(adapter->irq_ch, adapter);\n\t \n\tif (adapter->mbox_space)\n\t\tdma_free_coherent(&adapter->pci_device->dev, adapter->mbox_sz,\n\t\t\tadapter->mbox_space, adapter->mbox_space_handle);\n\tpci_dev_put(adapter->pci_device);\n\tadapter->mbox_space = NULL;\n\tadapter->mbox_space_handle = 0;\n\tadapter->mbox_sz = 0;\n}\n\n\n \n\nstatic bool blogic_initadapter(struct blogic_adapter *adapter)\n{\n\tstruct blogic_extmbox_req extmbox_req;\n\tenum blogic_rr_req rr_req;\n\tenum blogic_setccb_fmt setccb_fmt;\n\tint tgt_id;\n\n\t \n\tadapter->firstccb = NULL;\n\tadapter->lastccb = NULL;\n\n\t \n\tfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++) {\n\t\tadapter->bdr_pend[tgt_id] = NULL;\n\t\tadapter->tgt_flags[tgt_id].tagq_active = false;\n\t\tadapter->tgt_flags[tgt_id].cmd_good = false;\n\t\tadapter->active_cmds[tgt_id] = 0;\n\t\tadapter->cmds_since_rst[tgt_id] = 0;\n\t}\n\n\t \n\tif (blogic_flashpoint_type(adapter))\n\t\tgoto done;\n\n\t \n\tadapter->mbox_sz = adapter->mbox_count * (sizeof(struct blogic_outbox) + sizeof(struct blogic_inbox));\n\tadapter->mbox_space = dma_alloc_coherent(&adapter->pci_device->dev,\n\t\t\t\tadapter->mbox_sz, &adapter->mbox_space_handle,\n\t\t\t\tGFP_KERNEL);\n\tif (adapter->mbox_space == NULL)\n\t\treturn blogic_failure(adapter, \"MAILBOX ALLOCATION\");\n\tadapter->first_outbox = (struct blogic_outbox *) adapter->mbox_space;\n\tadapter->last_outbox = adapter->first_outbox + adapter->mbox_count - 1;\n\tadapter->next_outbox = adapter->first_outbox;\n\tadapter->first_inbox = (struct blogic_inbox *) (adapter->last_outbox + 1);\n\tadapter->last_inbox = adapter->first_inbox + adapter->mbox_count - 1;\n\tadapter->next_inbox = adapter->first_inbox;\n\n\t \n\tmemset(adapter->first_outbox, 0,\n\t\t\tadapter->mbox_count * sizeof(struct blogic_outbox));\n\tmemset(adapter->first_inbox, 0,\n\t\t\tadapter->mbox_count * sizeof(struct blogic_inbox));\n\n\t \n\textmbox_req.mbox_count = adapter->mbox_count;\n\textmbox_req.base_mbox_addr = (u32) adapter->mbox_space_handle;\n\tif (blogic_cmd(adapter, BLOGIC_INIT_EXT_MBOX, &extmbox_req,\n\t\t\t\tsizeof(extmbox_req), NULL, 0) < 0)\n\t\treturn blogic_failure(adapter, \"MAILBOX INITIALIZATION\");\n\t \n\tif (adapter->strict_rr) {\n\t\trr_req = BLOGIC_STRICT_RR_MODE;\n\t\tif (blogic_cmd(adapter, BLOGIC_STRICT_RR, &rr_req,\n\t\t\t\t\tsizeof(rr_req), NULL, 0) < 0)\n\t\t\treturn blogic_failure(adapter,\n\t\t\t\t\t\"ENABLE STRICT ROUND ROBIN MODE\");\n\t}\n\n\t \n\tif (adapter->ext_lun) {\n\t\tsetccb_fmt = BLOGIC_EXT_LUN_CCB;\n\t\tif (blogic_cmd(adapter, BLOGIC_SETCCB_FMT, &setccb_fmt,\n\t\t\t\t\tsizeof(setccb_fmt), NULL, 0) < 0)\n\t\t\treturn blogic_failure(adapter, \"SET CCB FORMAT\");\n\t}\n\n\t \ndone:\n\tif (!adapter->adapter_initd) {\n\t\tblogic_info(\"*** %s Initialized Successfully ***\\n\", adapter,\n\t\t\t\tadapter->full_model);\n\t\tblogic_info(\"\\n\", adapter);\n\t} else\n\t\tblogic_warn(\"*** %s Initialized Successfully ***\\n\", adapter,\n\t\t\t\tadapter->full_model);\n\tadapter->adapter_initd = true;\n\n\t \n\treturn true;\n}\n\n\n \n\nstatic bool __init blogic_inquiry(struct blogic_adapter *adapter)\n{\n\tu16 installed_devs;\n\tu8 installed_devs0to7[8];\n\tstruct blogic_setup_info setupinfo;\n\tu8 sync_period[BLOGIC_MAXDEV];\n\tunsigned char req_replylen;\n\tint tgt_id;\n\n\t \n\tblogic_delay(adapter->bus_settle_time);\n\t \n\tif (blogic_flashpoint_type(adapter))\n\t\treturn true;\n\t \n\tif (adapter->drvr_opts != NULL && adapter->drvr_opts->stop_tgt_inquiry)\n\t\treturn true;\n\t \n\tif (strcmp(adapter->fw_ver, \"4.25\") >= 0) {\n\n\t\t \n\n\t\tif (blogic_cmd(adapter, BLOGIC_INQ_DEV, NULL, 0,\n\t\t\t\t\t&installed_devs, sizeof(installed_devs))\n\t\t    != sizeof(installed_devs))\n\t\t\treturn blogic_failure(adapter, \"INQUIRE TARGET DEVICES\");\n\t\tfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\n\t\t\tadapter->tgt_flags[tgt_id].tgt_exists =\n\t\t\t\t(installed_devs & (1 << tgt_id) ? true : false);\n\t} else {\n\n\t\t \n\n\t\tif (blogic_cmd(adapter, BLOGIC_INQ_DEV0TO7, NULL, 0,\n\t\t\t\t&installed_devs0to7, sizeof(installed_devs0to7))\n\t\t    != sizeof(installed_devs0to7))\n\t\t\treturn blogic_failure(adapter,\n\t\t\t\t\t\"INQUIRE INSTALLED DEVICES ID 0 TO 7\");\n\t\tfor (tgt_id = 0; tgt_id < 8; tgt_id++)\n\t\t\tadapter->tgt_flags[tgt_id].tgt_exists =\n\t\t\t\tinstalled_devs0to7[tgt_id] != 0;\n\t}\n\t \n\treq_replylen = sizeof(setupinfo);\n\tif (blogic_cmd(adapter, BLOGIC_INQ_SETUPINFO, &req_replylen,\n\t\t\tsizeof(req_replylen), &setupinfo, sizeof(setupinfo))\n\t    != sizeof(setupinfo))\n\t\treturn blogic_failure(adapter, \"INQUIRE SETUP INFORMATION\");\n\tfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\n\t\tadapter->sync_offset[tgt_id] = (tgt_id < 8 ? setupinfo.sync0to7[tgt_id].offset : setupinfo.sync8to15[tgt_id - 8].offset);\n\tif (strcmp(adapter->fw_ver, \"5.06L\") >= 0)\n\t\tfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\n\t\t\tadapter->tgt_flags[tgt_id].wide_active = (tgt_id < 8 ? (setupinfo.wide_tx_active0to7 & (1 << tgt_id) ? true : false) : (setupinfo.wide_tx_active8to15 & (1 << (tgt_id - 8)) ? true : false));\n\t \n\tif (adapter->fw_ver[0] >= '3') {\n\n\t\t \n\n\t\treq_replylen = sizeof(sync_period);\n\t\tif (blogic_cmd(adapter, BLOGIC_INQ_SYNC_PERIOD, &req_replylen,\n\t\t\t\tsizeof(req_replylen), &sync_period,\n\t\t\t\tsizeof(sync_period)) != sizeof(sync_period))\n\t\t\treturn blogic_failure(adapter,\n\t\t\t\t\t\"INQUIRE SYNCHRONOUS PERIOD\");\n\t\tfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\n\t\t\tadapter->sync_period[tgt_id] = sync_period[tgt_id];\n\t} else\n\t\tfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\n\t\t\tif (setupinfo.sync0to7[tgt_id].offset > 0)\n\t\t\t\tadapter->sync_period[tgt_id] = 20 + 5 * setupinfo.sync0to7[tgt_id].tx_period;\n\t \n\treturn true;\n}\n\n \n\nstatic void __init blogic_inithoststruct(struct blogic_adapter *adapter,\n\t\tstruct Scsi_Host *host)\n{\n\thost->max_id = adapter->maxdev;\n\thost->max_lun = adapter->maxlun;\n\thost->max_channel = 0;\n\thost->unique_id = adapter->io_addr;\n\thost->this_id = adapter->scsi_id;\n\thost->can_queue = adapter->drvr_qdepth;\n\thost->sg_tablesize = adapter->drvr_sglimit;\n\thost->cmd_per_lun = adapter->untag_qdepth;\n}\n\n \nstatic int blogic_slaveconfig(struct scsi_device *dev)\n{\n\tstruct blogic_adapter *adapter =\n\t\t(struct blogic_adapter *) dev->host->hostdata;\n\tint tgt_id = dev->id;\n\tint qdepth = adapter->qdepth[tgt_id];\n\n\tif (adapter->tgt_flags[tgt_id].tagq_ok &&\n\t\t\t(adapter->tagq_ok & (1 << tgt_id))) {\n\t\tif (qdepth == 0)\n\t\t\tqdepth = BLOGIC_MAX_AUTO_TAG_DEPTH;\n\t\tadapter->qdepth[tgt_id] = qdepth;\n\t\tscsi_change_queue_depth(dev, qdepth);\n\t} else {\n\t\tadapter->tagq_ok &= ~(1 << tgt_id);\n\t\tqdepth = adapter->untag_qdepth;\n\t\tadapter->qdepth[tgt_id] = qdepth;\n\t\tscsi_change_queue_depth(dev, qdepth);\n\t}\n\tqdepth = 0;\n\tfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\n\t\tif (adapter->tgt_flags[tgt_id].tgt_exists)\n\t\t\tqdepth += adapter->qdepth[tgt_id];\n\tif (qdepth > adapter->alloc_ccbs)\n\t\tblogic_create_addlccbs(adapter, qdepth - adapter->alloc_ccbs,\n\t\t\t\tfalse);\n\treturn 0;\n}\n\n \n\nstatic int __init blogic_init(void)\n{\n\tint drvr_optindex = 0, probeindex;\n\tstruct blogic_adapter *adapter;\n\tint ret = 0;\n\n#ifdef MODULE\n\tif (BusLogic)\n\t\tblogic_setup(BusLogic);\n#endif\n\n\tif (blogic_probe_options.noprobe)\n\t\treturn -ENODEV;\n\tblogic_probeinfo_list =\n\t    kcalloc(BLOGIC_MAX_ADAPTERS, sizeof(struct blogic_probeinfo),\n\t\t\t    GFP_KERNEL);\n\tif (blogic_probeinfo_list == NULL) {\n\t\tblogic_err(\"BusLogic: Unable to allocate Probe Info List\\n\",\n\t\t\t\tNULL);\n\t\treturn -ENOMEM;\n\t}\n\n\tadapter = kzalloc(sizeof(struct blogic_adapter), GFP_KERNEL);\n\tif (adapter == NULL) {\n\t\tkfree(blogic_probeinfo_list);\n\t\tblogic_err(\"BusLogic: Unable to allocate Prototype Host Adapter\\n\", NULL);\n\t\treturn -ENOMEM;\n\t}\n\n#ifdef MODULE\n\tif (BusLogic != NULL)\n\t\tblogic_setup(BusLogic);\n#endif\n\tblogic_init_probeinfo_list(adapter);\n\tfor (probeindex = 0; probeindex < blogic_probeinfo_count; probeindex++) {\n\t\tstruct blogic_probeinfo *probeinfo =\n\t\t\t&blogic_probeinfo_list[probeindex];\n\t\tstruct blogic_adapter *myadapter = adapter;\n\t\tstruct Scsi_Host *host;\n\n\t\tif (probeinfo->io_addr == 0)\n\t\t\tcontinue;\n\t\tmemset(myadapter, 0, sizeof(struct blogic_adapter));\n\t\tmyadapter->adapter_type = probeinfo->adapter_type;\n\t\tmyadapter->adapter_bus_type = probeinfo->adapter_bus_type;\n\t\tmyadapter->io_addr = probeinfo->io_addr;\n\t\tmyadapter->pci_addr = probeinfo->pci_addr;\n\t\tmyadapter->bus = probeinfo->bus;\n\t\tmyadapter->dev = probeinfo->dev;\n\t\tmyadapter->pci_device = probeinfo->pci_device;\n\t\tmyadapter->irq_ch = probeinfo->irq_ch;\n\t\tmyadapter->addr_count =\n\t\t\tblogic_adapter_addr_count[myadapter->adapter_type];\n\n\t\t \n\t\tif (!request_region(myadapter->io_addr, myadapter->addr_count,\n\t\t\t\t\t\"BusLogic\"))\n\t\t\tcontinue;\n\t\t \n\t\tif (!blogic_probe(myadapter)) {\n\t\t\trelease_region(myadapter->io_addr,\n\t\t\t\t\tmyadapter->addr_count);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (!blogic_hwreset(myadapter, true)) {\n\t\t\trelease_region(myadapter->io_addr,\n\t\t\t\t\tmyadapter->addr_count);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (!blogic_checkadapter(myadapter)) {\n\t\t\trelease_region(myadapter->io_addr,\n\t\t\t\t\tmyadapter->addr_count);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (drvr_optindex < blogic_drvr_options_count)\n\t\t\tmyadapter->drvr_opts =\n\t\t\t\t&blogic_drvr_options[drvr_optindex++];\n\t\t \n\t\tblogic_announce_drvr(myadapter);\n\t\t \n\n\t\thost = scsi_host_alloc(&blogic_template,\n\t\t\t\tsizeof(struct blogic_adapter));\n\t\tif (host == NULL) {\n\t\t\trelease_region(myadapter->io_addr,\n\t\t\t\t\tmyadapter->addr_count);\n\t\t\tcontinue;\n\t\t}\n\t\tmyadapter = (struct blogic_adapter *) host->hostdata;\n\t\tmemcpy(myadapter, adapter, sizeof(struct blogic_adapter));\n\t\tmyadapter->scsi_host = host;\n\t\tmyadapter->host_no = host->host_no;\n\t\t \n\t\tlist_add_tail(&myadapter->host_list, &blogic_host_list);\n\n\t\t \n\t\tif (blogic_rdconfig(myadapter) &&\n\t\t    blogic_reportconfig(myadapter) &&\n\t\t    blogic_getres(myadapter) &&\n\t\t    blogic_create_initccbs(myadapter) &&\n\t\t    blogic_initadapter(myadapter) &&\n\t\t    blogic_inquiry(myadapter)) {\n\t\t\t \n\t\t\trelease_region(myadapter->io_addr,\n\t\t\t\t       myadapter->addr_count);\n\t\t\tif (!request_region(myadapter->io_addr,\n\t\t\t\t\t    myadapter->addr_count,\n\t\t\t\t\t    myadapter->full_model)) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\"BusLogic: Release and re-register of \"\n\t\t\t\t\t\"port 0x%04lx failed \\n\",\n\t\t\t\t\t(unsigned long)myadapter->io_addr);\n\t\t\t\tblogic_destroy_ccbs(myadapter);\n\t\t\t\tblogic_relres(myadapter);\n\t\t\t\tlist_del(&myadapter->host_list);\n\t\t\t\tscsi_host_put(host);\n\t\t\t\tret = -ENOMEM;\n\t\t\t} else {\n\t\t\t\tblogic_inithoststruct(myadapter,\n\t\t\t\t\t\t\t\t host);\n\t\t\t\tif (scsi_add_host(host, myadapter->pci_device\n\t\t\t\t\t\t? &myadapter->pci_device->dev\n\t\t\t\t\t\t  : NULL)) {\n\t\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t       \"BusLogic: scsi_add_host()\"\n\t\t\t\t\t       \"failed!\\n\");\n\t\t\t\t\tblogic_destroy_ccbs(myadapter);\n\t\t\t\t\tblogic_relres(myadapter);\n\t\t\t\t\tlist_del(&myadapter->host_list);\n\t\t\t\t\tscsi_host_put(host);\n\t\t\t\t\tret = -ENODEV;\n\t\t\t\t} else\n\t\t\t\t\tscsi_scan_host(host);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tblogic_destroy_ccbs(myadapter);\n\t\t\tblogic_relres(myadapter);\n\t\t\tlist_del(&myadapter->host_list);\n\t\t\tscsi_host_put(host);\n\t\t\tret = -ENODEV;\n\t\t}\n\t}\n\tkfree(adapter);\n\tkfree(blogic_probeinfo_list);\n\tblogic_probeinfo_list = NULL;\n\treturn ret;\n}\n\n\n \n\nstatic int __exit blogic_deladapter(struct blogic_adapter *adapter)\n{\n\tstruct Scsi_Host *host = adapter->scsi_host;\n\n\tscsi_remove_host(host);\n\n\t \n\tif (blogic_flashpoint_type(adapter))\n\t\tFlashPoint_ReleaseHostAdapter(adapter->cardhandle);\n\t \n\tblogic_destroy_ccbs(adapter);\n\tblogic_relres(adapter);\n\t \n\trelease_region(adapter->io_addr, adapter->addr_count);\n\t \n\tlist_del(&adapter->host_list);\n\n\tscsi_host_put(host);\n\treturn 0;\n}\n\n\n \n\nstatic void blogic_qcompleted_ccb(struct blogic_ccb *ccb)\n{\n\tstruct blogic_adapter *adapter = ccb->adapter;\n\n\tccb->status = BLOGIC_CCB_COMPLETE;\n\tccb->next = NULL;\n\tif (adapter->firstccb == NULL) {\n\t\tadapter->firstccb = ccb;\n\t\tadapter->lastccb = ccb;\n\t} else {\n\t\tadapter->lastccb->next = ccb;\n\t\tadapter->lastccb = ccb;\n\t}\n\tadapter->active_cmds[ccb->tgt_id]--;\n}\n\n\n \n\nstatic int blogic_resultcode(struct blogic_adapter *adapter,\n\t\tenum blogic_adapter_status adapter_status,\n\t\tenum blogic_tgt_status tgt_status)\n{\n\tint hoststatus;\n\n\tswitch (adapter_status) {\n\tcase BLOGIC_CMD_CMPLT_NORMAL:\n\tcase BLOGIC_LINK_CMD_CMPLT:\n\tcase BLOGIC_LINK_CMD_CMPLT_FLAG:\n\t\thoststatus = DID_OK;\n\t\tbreak;\n\tcase BLOGIC_SELECT_TIMEOUT:\n\t\thoststatus = DID_TIME_OUT;\n\t\tbreak;\n\tcase BLOGIC_INVALID_OUTBOX_CODE:\n\tcase BLOGIC_INVALID_CMD_CODE:\n\tcase BLOGIC_BAD_CMD_PARAM:\n\t\tblogic_warn(\"BusLogic Driver Protocol Error 0x%02X\\n\",\n\t\t\t\tadapter, adapter_status);\n\t\tfallthrough;\n\tcase BLOGIC_DATA_UNDERRUN:\n\tcase BLOGIC_DATA_OVERRUN:\n\tcase BLOGIC_NOEXPECT_BUSFREE:\n\tcase BLOGIC_LINKCCB_BADLUN:\n\tcase BLOGIC_AUTOREQSENSE_FAIL:\n\tcase BLOGIC_TAGQUEUE_REJECT:\n\tcase BLOGIC_BAD_MSG_RCVD:\n\tcase BLOGIC_HW_FAIL:\n\tcase BLOGIC_BAD_RECONNECT:\n\tcase BLOGIC_ABRT_QUEUE:\n\tcase BLOGIC_ADAPTER_SW_ERROR:\n\tcase BLOGIC_HW_TIMEOUT:\n\tcase BLOGIC_PARITY_ERR:\n\t\thoststatus = DID_ERROR;\n\t\tbreak;\n\tcase BLOGIC_INVALID_BUSPHASE:\n\tcase BLOGIC_NORESPONSE_TO_ATN:\n\tcase BLOGIC_HW_RESET:\n\tcase BLOGIC_RST_FROM_OTHERDEV:\n\tcase BLOGIC_HW_BDR:\n\t\thoststatus = DID_RESET;\n\t\tbreak;\n\tdefault:\n\t\tblogic_warn(\"Unknown Host Adapter Status 0x%02X\\n\", adapter,\n\t\t\t\tadapter_status);\n\t\thoststatus = DID_ERROR;\n\t\tbreak;\n\t}\n\treturn (hoststatus << 16) | tgt_status;\n}\n\n \nstatic struct blogic_ccb *\nblogic_inbox_to_ccb(struct blogic_adapter *adapter, struct blogic_inbox *inbox)\n{\n\tstruct blogic_ccb *ccb;\n\n\tfor (ccb = adapter->all_ccbs; ccb; ccb = ccb->next_all)\n\t\tif (inbox->ccb == ccb->dma_handle)\n\t\t\tbreak;\n\n\treturn ccb;\n}\n\n \nstatic void blogic_scan_inbox(struct blogic_adapter *adapter)\n{\n\t \n\tstruct blogic_inbox *next_inbox = adapter->next_inbox;\n\tenum blogic_cmplt_code comp_code;\n\n\twhile ((comp_code = next_inbox->comp_code) != BLOGIC_INBOX_FREE) {\n\t\tstruct blogic_ccb *ccb = blogic_inbox_to_ccb(adapter, next_inbox);\n\t\tif (!ccb) {\n\t\t\t \n\t\t\tblogic_warn(\"Could not find CCB for dma address %x\\n\", adapter, next_inbox->ccb);\n\t\t} else if (comp_code != BLOGIC_CMD_NOTFOUND) {\n\t\t\tif (ccb->status == BLOGIC_CCB_ACTIVE ||\n\t\t\t\t\tccb->status == BLOGIC_CCB_RESET) {\n\t\t\t\t \n\t\t\t\tccb->comp_code = comp_code;\n\t\t\t\tblogic_qcompleted_ccb(ccb);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tblogic_warn(\"Illegal CCB #%ld status %d in Incoming Mailbox\\n\", adapter, ccb->serial, ccb->status);\n\t\t\t}\n\t\t}\n\t\tnext_inbox->comp_code = BLOGIC_INBOX_FREE;\n\t\tif (++next_inbox > adapter->last_inbox)\n\t\t\tnext_inbox = adapter->first_inbox;\n\t}\n\tadapter->next_inbox = next_inbox;\n}\n\n\n \n\nstatic void blogic_process_ccbs(struct blogic_adapter *adapter)\n{\n\tif (adapter->processing_ccbs)\n\t\treturn;\n\tadapter->processing_ccbs = true;\n\twhile (adapter->firstccb != NULL) {\n\t\tstruct blogic_ccb *ccb = adapter->firstccb;\n\t\tstruct scsi_cmnd *command = ccb->command;\n\t\tadapter->firstccb = ccb->next;\n\t\tif (adapter->firstccb == NULL)\n\t\t\tadapter->lastccb = NULL;\n\t\t \n\t\tif (ccb->opcode == BLOGIC_BDR) {\n\t\t\tint tgt_id = ccb->tgt_id;\n\n\t\t\tblogic_warn(\"Bus Device Reset CCB #%ld to Target %d Completed\\n\", adapter, ccb->serial, tgt_id);\n\t\t\tblogic_inc_count(&adapter->tgt_stats[tgt_id].bdr_done);\n\t\t\tadapter->tgt_flags[tgt_id].tagq_active = false;\n\t\t\tadapter->cmds_since_rst[tgt_id] = 0;\n\t\t\tadapter->last_resetdone[tgt_id] = jiffies;\n\t\t\t \n\t\t\tblogic_dealloc_ccb(ccb, 1);\n#if 0\t\t\t \n\t\t\t \n\t\t\twhile (command != NULL) {\n\t\t\t\tstruct scsi_cmnd *nxt_cmd =\n\t\t\t\t\tcommand->reset_chain;\n\t\t\t\tcommand->reset_chain = NULL;\n\t\t\t\tcommand->result = DID_RESET << 16;\n\t\t\t\tscsi_done(command);\n\t\t\t\tcommand = nxt_cmd;\n\t\t\t}\n#endif\n\t\t\t \n\t\t\tfor (ccb = adapter->all_ccbs; ccb != NULL;\n\t\t\t\t\tccb = ccb->next_all)\n\t\t\t\tif (ccb->status == BLOGIC_CCB_RESET &&\n\t\t\t\t\t\tccb->tgt_id == tgt_id) {\n\t\t\t\t\tcommand = ccb->command;\n\t\t\t\t\tblogic_dealloc_ccb(ccb, 1);\n\t\t\t\t\tadapter->active_cmds[tgt_id]--;\n\t\t\t\t\tcommand->result = DID_RESET << 16;\n\t\t\t\t\tscsi_done(command);\n\t\t\t\t}\n\t\t\tadapter->bdr_pend[tgt_id] = NULL;\n\t\t} else {\n\t\t\t \n\t\t\tswitch (ccb->comp_code) {\n\t\t\tcase BLOGIC_INBOX_FREE:\n\t\t\tcase BLOGIC_CMD_NOTFOUND:\n\t\t\tcase BLOGIC_INVALID_CCB:\n\t\t\t\tblogic_warn(\"CCB #%ld to Target %d Impossible State\\n\", adapter, ccb->serial, ccb->tgt_id);\n\t\t\t\tbreak;\n\t\t\tcase BLOGIC_CMD_COMPLETE_GOOD:\n\t\t\t\tadapter->tgt_stats[ccb->tgt_id]\n\t\t\t\t    .cmds_complete++;\n\t\t\t\tadapter->tgt_flags[ccb->tgt_id]\n\t\t\t\t    .cmd_good = true;\n\t\t\t\tcommand->result = DID_OK << 16;\n\t\t\t\tbreak;\n\t\t\tcase BLOGIC_CMD_ABORT_BY_HOST:\n\t\t\t\tblogic_warn(\"CCB #%ld to Target %d Aborted\\n\",\n\t\t\t\t\tadapter, ccb->serial, ccb->tgt_id);\n\t\t\t\tblogic_inc_count(&adapter->tgt_stats[ccb->tgt_id].aborts_done);\n\t\t\t\tcommand->result = DID_ABORT << 16;\n\t\t\t\tbreak;\n\t\t\tcase BLOGIC_CMD_COMPLETE_ERROR:\n\t\t\t\tcommand->result = blogic_resultcode(adapter,\n\t\t\t\t\tccb->adapter_status, ccb->tgt_status);\n\t\t\t\tif (ccb->adapter_status != BLOGIC_SELECT_TIMEOUT) {\n\t\t\t\t\tadapter->tgt_stats[ccb->tgt_id]\n\t\t\t\t\t    .cmds_complete++;\n\t\t\t\t\tif (blogic_global_options.trace_err) {\n\t\t\t\t\t\tint i;\n\t\t\t\t\t\tblogic_notice(\"CCB #%ld Target %d: Result %X Host \"\n\t\t\t\t\t\t\t\t\"Adapter Status %02X Target Status %02X\\n\", adapter, ccb->serial, ccb->tgt_id, command->result, ccb->adapter_status, ccb->tgt_status);\n\t\t\t\t\t\tblogic_notice(\"CDB   \", adapter);\n\t\t\t\t\t\tfor (i = 0; i < ccb->cdblen; i++)\n\t\t\t\t\t\t\tblogic_notice(\" %02X\", adapter, ccb->cdb[i]);\n\t\t\t\t\t\tblogic_notice(\"\\n\", adapter);\n\t\t\t\t\t\tblogic_notice(\"Sense \", adapter);\n\t\t\t\t\t\tfor (i = 0; i < ccb->sense_datalen; i++)\n\t\t\t\t\t\t\tblogic_notice(\" %02X\", adapter, command->sense_buffer[i]);\n\t\t\t\t\t\tblogic_notice(\"\\n\", adapter);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (ccb->cdb[0] == INQUIRY && ccb->cdb[1] == 0 &&\n\t\t\t\tccb->adapter_status == BLOGIC_CMD_CMPLT_NORMAL) {\n\t\t\t\tstruct blogic_tgt_flags *tgt_flags =\n\t\t\t\t\t&adapter->tgt_flags[ccb->tgt_id];\n\t\t\t\tstruct scsi_inquiry *inquiry =\n\t\t\t\t\t(struct scsi_inquiry *) scsi_sglist(command);\n\t\t\t\ttgt_flags->tgt_exists = true;\n\t\t\t\ttgt_flags->tagq_ok = inquiry->CmdQue;\n\t\t\t\ttgt_flags->wide_ok = inquiry->WBus16;\n\t\t\t}\n\t\t\t \n\t\t\tblogic_dealloc_ccb(ccb, 1);\n\t\t\t \n\t\t\tscsi_done(command);\n\t\t}\n\t}\n\tadapter->processing_ccbs = false;\n}\n\n\n \n\nstatic irqreturn_t blogic_inthandler(int irq_ch, void *devid)\n{\n\tstruct blogic_adapter *adapter = (struct blogic_adapter *) devid;\n\tunsigned long processor_flag;\n\t \n\tspin_lock_irqsave(adapter->scsi_host->host_lock, processor_flag);\n\t \n\tif (blogic_multimaster_type(adapter)) {\n\t\tunion blogic_int_reg intreg;\n\t\t \n\t\tintreg.all = blogic_rdint(adapter);\n\t\tif (intreg.ir.int_valid) {\n\t\t\t \n\t\t\tblogic_intreset(adapter);\n\t\t\t \n\t\t\tif (intreg.ir.ext_busreset)\n\t\t\t\tadapter->adapter_extreset = true;\n\t\t\telse if (intreg.ir.mailin_loaded)\n\t\t\t\tblogic_scan_inbox(adapter);\n\t\t\telse if (intreg.ir.cmd_complete)\n\t\t\t\tadapter->adapter_cmd_complete = true;\n\t\t}\n\t} else {\n\t\t \n\t\tif (FlashPoint_InterruptPending(adapter->cardhandle))\n\t\t\tswitch (FlashPoint_HandleInterrupt(adapter->cardhandle)) {\n\t\t\tcase FPOINT_NORMAL_INT:\n\t\t\t\tbreak;\n\t\t\tcase FPOINT_EXT_RESET:\n\t\t\t\tadapter->adapter_extreset = true;\n\t\t\t\tbreak;\n\t\t\tcase FPOINT_INTERN_ERR:\n\t\t\t\tblogic_warn(\"Internal FlashPoint Error detected - Resetting Host Adapter\\n\", adapter);\n\t\t\t\tadapter->adapter_intern_err = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\t \n\tif (adapter->firstccb != NULL)\n\t\tblogic_process_ccbs(adapter);\n\t \n\tif (adapter->adapter_extreset) {\n\t\tblogic_warn(\"Resetting %s due to External SCSI Bus Reset\\n\", adapter, adapter->full_model);\n\t\tblogic_inc_count(&adapter->ext_resets);\n\t\tblogic_resetadapter(adapter, false);\n\t\tadapter->adapter_extreset = false;\n\t} else if (adapter->adapter_intern_err) {\n\t\tblogic_warn(\"Resetting %s due to Host Adapter Internal Error\\n\", adapter, adapter->full_model);\n\t\tblogic_inc_count(&adapter->adapter_intern_errors);\n\t\tblogic_resetadapter(adapter, true);\n\t\tadapter->adapter_intern_err = false;\n\t}\n\t \n\tspin_unlock_irqrestore(adapter->scsi_host->host_lock, processor_flag);\n\treturn IRQ_HANDLED;\n}\n\n\n \n\nstatic bool blogic_write_outbox(struct blogic_adapter *adapter,\n\t\tenum blogic_action action, struct blogic_ccb *ccb)\n{\n\tstruct blogic_outbox *next_outbox;\n\n\tnext_outbox = adapter->next_outbox;\n\tif (next_outbox->action == BLOGIC_OUTBOX_FREE) {\n\t\tccb->status = BLOGIC_CCB_ACTIVE;\n\t\t \n\t\tnext_outbox->ccb = ccb->dma_handle;\n\t\tnext_outbox->action = action;\n\t\tblogic_execmbox(adapter);\n\t\tif (++next_outbox > adapter->last_outbox)\n\t\t\tnext_outbox = adapter->first_outbox;\n\t\tadapter->next_outbox = next_outbox;\n\t\tif (action == BLOGIC_MBOX_START) {\n\t\t\tadapter->active_cmds[ccb->tgt_id]++;\n\t\t\tif (ccb->opcode != BLOGIC_BDR)\n\t\t\t\tadapter->tgt_stats[ccb->tgt_id].cmds_tried++;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \n\nstatic int blogic_hostreset(struct scsi_cmnd *SCpnt)\n{\n\tstruct blogic_adapter *adapter =\n\t\t(struct blogic_adapter *) SCpnt->device->host->hostdata;\n\n\tunsigned int id = SCpnt->device->id;\n\tstruct blogic_tgt_stats *stats = &adapter->tgt_stats[id];\n\tint rc;\n\n\tspin_lock_irq(SCpnt->device->host->host_lock);\n\n\tblogic_inc_count(&stats->adapter_reset_req);\n\n\trc = blogic_resetadapter(adapter, false);\n\tspin_unlock_irq(SCpnt->device->host->host_lock);\n\treturn rc;\n}\n\n \n\nstatic int blogic_qcmd_lck(struct scsi_cmnd *command)\n{\n\tvoid (*comp_cb)(struct scsi_cmnd *) = scsi_done;\n\tstruct blogic_adapter *adapter =\n\t\t(struct blogic_adapter *) command->device->host->hostdata;\n\tstruct blogic_tgt_flags *tgt_flags =\n\t\t&adapter->tgt_flags[command->device->id];\n\tstruct blogic_tgt_stats *tgt_stats = adapter->tgt_stats;\n\tunsigned char *cdb = command->cmnd;\n\tint cdblen = command->cmd_len;\n\tint tgt_id = command->device->id;\n\tint lun = command->device->lun;\n\tint buflen = scsi_bufflen(command);\n\tint count;\n\tstruct blogic_ccb *ccb;\n\tdma_addr_t sense_buf;\n\n\t \n\tif (cdb[0] == REQUEST_SENSE && command->sense_buffer[0] != 0) {\n\t\tcommand->result = DID_OK << 16;\n\t\tcomp_cb(command);\n\t\treturn 0;\n\t}\n\t \n\tccb = blogic_alloc_ccb(adapter);\n\tif (ccb == NULL) {\n\t\tspin_unlock_irq(adapter->scsi_host->host_lock);\n\t\tblogic_delay(1);\n\t\tspin_lock_irq(adapter->scsi_host->host_lock);\n\t\tccb = blogic_alloc_ccb(adapter);\n\t\tif (ccb == NULL) {\n\t\t\tcommand->result = DID_ERROR << 16;\n\t\t\tcomp_cb(command);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tcount = scsi_dma_map(command);\n\tBUG_ON(count < 0);\n\tif (count) {\n\t\tstruct scatterlist *sg;\n\t\tint i;\n\n\t\tccb->opcode = BLOGIC_INITIATOR_CCB_SG;\n\t\tccb->datalen = count * sizeof(struct blogic_sg_seg);\n\t\tif (blogic_multimaster_type(adapter))\n\t\t\tccb->data = (unsigned int) ccb->dma_handle +\n\t\t\t\t\t((unsigned long) &ccb->sglist -\n\t\t\t\t\t(unsigned long) ccb);\n\t\telse\n\t\t\tccb->data = virt_to_32bit_virt(ccb->sglist);\n\n\t\tscsi_for_each_sg(command, sg, count, i) {\n\t\t\tccb->sglist[i].segbytes = sg_dma_len(sg);\n\t\t\tccb->sglist[i].segdata = sg_dma_address(sg);\n\t\t}\n\t} else if (!count) {\n\t\tccb->opcode = BLOGIC_INITIATOR_CCB;\n\t\tccb->datalen = buflen;\n\t\tccb->data = 0;\n\t}\n\n\tswitch (cdb[0]) {\n\tcase READ_6:\n\tcase READ_10:\n\t\tccb->datadir = BLOGIC_DATAIN_CHECKED;\n\t\ttgt_stats[tgt_id].read_cmds++;\n\t\tblogic_addcount(&tgt_stats[tgt_id].bytesread, buflen);\n\t\tblogic_incszbucket(tgt_stats[tgt_id].read_sz_buckets, buflen);\n\t\tbreak;\n\tcase WRITE_6:\n\tcase WRITE_10:\n\t\tccb->datadir = BLOGIC_DATAOUT_CHECKED;\n\t\ttgt_stats[tgt_id].write_cmds++;\n\t\tblogic_addcount(&tgt_stats[tgt_id].byteswritten, buflen);\n\t\tblogic_incszbucket(tgt_stats[tgt_id].write_sz_buckets, buflen);\n\t\tbreak;\n\tdefault:\n\t\tccb->datadir = BLOGIC_UNCHECKED_TX;\n\t\tbreak;\n\t}\n\tccb->cdblen = cdblen;\n\tccb->adapter_status = 0;\n\tccb->tgt_status = 0;\n\tccb->tgt_id = tgt_id;\n\tccb->lun = lun;\n\tccb->tag_enable = false;\n\tccb->legacytag_enable = false;\n\t \n\tif (adapter->cmds_since_rst[tgt_id]++ >= BLOGIC_MAX_TAG_DEPTH &&\n\t\t\t!tgt_flags->tagq_active &&\n\t\t\tadapter->active_cmds[tgt_id] == 0\n\t\t\t&& tgt_flags->tagq_ok &&\n\t\t\t(adapter->tagq_ok & (1 << tgt_id))) {\n\t\ttgt_flags->tagq_active = true;\n\t\tblogic_notice(\"Tagged Queuing now active for Target %d\\n\",\n\t\t\t\t\tadapter, tgt_id);\n\t}\n\tif (tgt_flags->tagq_active) {\n\t\tenum blogic_queuetag queuetag = BLOGIC_SIMPLETAG;\n\t\t \n\t\tif (adapter->active_cmds[tgt_id] == 0)\n\t\t\tadapter->last_seqpoint[tgt_id] = jiffies;\n\t\telse if (time_after(jiffies,\n\t\t\t\tadapter->last_seqpoint[tgt_id] + 4 * HZ)) {\n\t\t\tadapter->last_seqpoint[tgt_id] = jiffies;\n\t\t\tqueuetag = BLOGIC_ORDEREDTAG;\n\t\t}\n\t\tif (adapter->ext_lun) {\n\t\t\tccb->tag_enable = true;\n\t\t\tccb->queuetag = queuetag;\n\t\t} else {\n\t\t\tccb->legacytag_enable = true;\n\t\t\tccb->legacy_tag = queuetag;\n\t\t}\n\t}\n\tmemcpy(ccb->cdb, cdb, cdblen);\n\tccb->sense_datalen = SCSI_SENSE_BUFFERSIZE;\n\tccb->command = command;\n\tsense_buf = dma_map_single(&adapter->pci_device->dev,\n\t\t\t\tcommand->sense_buffer, ccb->sense_datalen,\n\t\t\t\tDMA_FROM_DEVICE);\n\tif (dma_mapping_error(&adapter->pci_device->dev, sense_buf)) {\n\t\tblogic_err(\"DMA mapping for sense data buffer failed\\n\",\n\t\t\t\tadapter);\n\t\tblogic_dealloc_ccb(ccb, 0);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\tccb->sensedata = sense_buf;\n\tif (blogic_multimaster_type(adapter)) {\n\t\t \n\t\tif (!blogic_write_outbox(adapter, BLOGIC_MBOX_START, ccb)) {\n\t\t\tspin_unlock_irq(adapter->scsi_host->host_lock);\n\t\t\tblogic_warn(\"Unable to write Outgoing Mailbox - Pausing for 1 second\\n\", adapter);\n\t\t\tblogic_delay(1);\n\t\t\tspin_lock_irq(adapter->scsi_host->host_lock);\n\t\t\tif (!blogic_write_outbox(adapter, BLOGIC_MBOX_START,\n\t\t\t\t\t\tccb)) {\n\t\t\t\tblogic_warn(\"Still unable to write Outgoing Mailbox - Host Adapter Dead?\\n\", adapter);\n\t\t\t\tblogic_dealloc_ccb(ccb, 1);\n\t\t\t\tcommand->result = DID_ERROR << 16;\n\t\t\t\tscsi_done(command);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tccb->status = BLOGIC_CCB_ACTIVE;\n\t\tadapter->active_cmds[tgt_id]++;\n\t\ttgt_stats[tgt_id].cmds_tried++;\n\t\tFlashPoint_StartCCB(adapter->cardhandle, ccb);\n\t\t \n\t\tif (ccb->status == BLOGIC_CCB_COMPLETE)\n\t\t\tblogic_process_ccbs(adapter);\n\t}\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(blogic_qcmd)\n\n#if 0\n \n\nstatic int blogic_abort(struct scsi_cmnd *command)\n{\n\tstruct blogic_adapter *adapter =\n\t\t(struct blogic_adapter *) command->device->host->hostdata;\n\n\tint tgt_id = command->device->id;\n\tstruct blogic_ccb *ccb;\n\tblogic_inc_count(&adapter->tgt_stats[tgt_id].aborts_request);\n\n\t \n\tfor (ccb = adapter->all_ccbs; ccb != NULL; ccb = ccb->next_all)\n\t\tif (ccb->command == command)\n\t\t\tbreak;\n\tif (ccb == NULL) {\n\t\tblogic_warn(\"Unable to Abort Command to Target %d - No CCB Found\\n\", adapter, tgt_id);\n\t\treturn SUCCESS;\n\t} else if (ccb->status == BLOGIC_CCB_COMPLETE) {\n\t\tblogic_warn(\"Unable to Abort Command to Target %d - CCB Completed\\n\", adapter, tgt_id);\n\t\treturn SUCCESS;\n\t} else if (ccb->status == BLOGIC_CCB_RESET) {\n\t\tblogic_warn(\"Unable to Abort Command to Target %d - CCB Reset\\n\", adapter, tgt_id);\n\t\treturn SUCCESS;\n\t}\n\tif (blogic_multimaster_type(adapter)) {\n\t\t \n\t\tif (adapter->tgt_flags[tgt_id].tagq_active &&\n\t\t\t\tadapter->fw_ver[0] < '5') {\n\t\t\tblogic_warn(\"Unable to Abort CCB #%ld to Target %d - Abort Tag Not Supported\\n\", adapter, ccb->serial, tgt_id);\n\t\t\treturn FAILURE;\n\t\t} else if (blogic_write_outbox(adapter, BLOGIC_MBOX_ABORT,\n\t\t\t\t\tccb)) {\n\t\t\tblogic_warn(\"Aborting CCB #%ld to Target %d\\n\",\n\t\t\t\t\tadapter, ccb->serial, tgt_id);\n\t\t\tblogic_inc_count(&adapter->tgt_stats[tgt_id].aborts_tried);\n\t\t\treturn SUCCESS;\n\t\t} else {\n\t\t\tblogic_warn(\"Unable to Abort CCB #%ld to Target %d - No Outgoing Mailboxes\\n\", adapter, ccb->serial, tgt_id);\n\t\t\treturn FAILURE;\n\t\t}\n\t} else {\n\t\t \n\t\tblogic_warn(\"Aborting CCB #%ld to Target %d\\n\", adapter,\n\t\t\t\tccb->serial, tgt_id);\n\t\tblogic_inc_count(&adapter->tgt_stats[tgt_id].aborts_tried);\n\t\tFlashPoint_AbortCCB(adapter->cardhandle, ccb);\n\t\t \n\t\tif (ccb->status == BLOGIC_CCB_COMPLETE)\n\t\t\tblogic_process_ccbs(adapter);\n\t\treturn SUCCESS;\n\t}\n\treturn SUCCESS;\n}\n\n#endif\n \n\nstatic int blogic_resetadapter(struct blogic_adapter *adapter, bool hard_reset)\n{\n\tstruct blogic_ccb *ccb;\n\tint tgt_id;\n\n\t \n\n\tif (!(blogic_hwreset(adapter, hard_reset) &&\n\t\t\t\tblogic_initadapter(adapter))) {\n\t\tblogic_err(\"Resetting %s Failed\\n\", adapter,\n\t\t\t\t\t\tadapter->full_model);\n\t\treturn FAILURE;\n\t}\n\n\t \n\n\tfor (ccb = adapter->all_ccbs; ccb != NULL; ccb = ccb->next_all)\n\t\tif (ccb->status == BLOGIC_CCB_ACTIVE)\n\t\t\tblogic_dealloc_ccb(ccb, 1);\n\t \n\n\tif (hard_reset) {\n\t\tspin_unlock_irq(adapter->scsi_host->host_lock);\n\t\tblogic_delay(adapter->bus_settle_time);\n\t\tspin_lock_irq(adapter->scsi_host->host_lock);\n\t}\n\n\tfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++) {\n\t\tadapter->last_resettried[tgt_id] = jiffies;\n\t\tadapter->last_resetdone[tgt_id] = jiffies;\n\t}\n\treturn SUCCESS;\n}\n\n \n\nstatic int blogic_diskparam(struct scsi_device *sdev, struct block_device *dev,\n\t\tsector_t capacity, int *params)\n{\n\tstruct blogic_adapter *adapter =\n\t\t\t\t(struct blogic_adapter *) sdev->host->hostdata;\n\tstruct bios_diskparam *diskparam = (struct bios_diskparam *) params;\n\tunsigned char *buf;\n\n\tif (adapter->ext_trans_enable && capacity >= 2 * 1024 * 1024  ) {\n\t\tif (capacity >= 4 * 1024 * 1024  ) {\n\t\t\tdiskparam->heads = 255;\n\t\t\tdiskparam->sectors = 63;\n\t\t} else {\n\t\t\tdiskparam->heads = 128;\n\t\t\tdiskparam->sectors = 32;\n\t\t}\n\t} else {\n\t\tdiskparam->heads = 64;\n\t\tdiskparam->sectors = 32;\n\t}\n\tdiskparam->cylinders = (unsigned long) capacity / (diskparam->heads * diskparam->sectors);\n\tbuf = scsi_bios_ptable(dev);\n\tif (buf == NULL)\n\t\treturn 0;\n\t \n\tif (*(unsigned short *) (buf + 64) == MSDOS_LABEL_MAGIC) {\n\t\tstruct msdos_partition *part1_entry =\n\t\t\t\t(struct msdos_partition *)buf;\n\t\tstruct msdos_partition *part_entry = part1_entry;\n\t\tint saved_cyl = diskparam->cylinders, part_no;\n\t\tunsigned char part_end_head = 0, part_end_sector = 0;\n\n\t\tfor (part_no = 0; part_no < 4; part_no++) {\n\t\t\tpart_end_head = part_entry->end_head;\n\t\t\tpart_end_sector = part_entry->end_sector & 0x3F;\n\t\t\tif (part_end_head == 64 - 1) {\n\t\t\t\tdiskparam->heads = 64;\n\t\t\t\tdiskparam->sectors = 32;\n\t\t\t\tbreak;\n\t\t\t} else if (part_end_head == 128 - 1) {\n\t\t\t\tdiskparam->heads = 128;\n\t\t\t\tdiskparam->sectors = 32;\n\t\t\t\tbreak;\n\t\t\t} else if (part_end_head == 255 - 1) {\n\t\t\t\tdiskparam->heads = 255;\n\t\t\t\tdiskparam->sectors = 63;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpart_entry++;\n\t\t}\n\t\tif (part_no == 4) {\n\t\t\tpart_end_head = part1_entry->end_head;\n\t\t\tpart_end_sector = part1_entry->end_sector & 0x3F;\n\t\t}\n\t\tdiskparam->cylinders = (unsigned long) capacity / (diskparam->heads * diskparam->sectors);\n\t\tif (part_no < 4 && part_end_sector == diskparam->sectors) {\n\t\t\tif (diskparam->cylinders != saved_cyl)\n\t\t\t\tblogic_warn(\"Adopting Geometry %d/%d from Partition Table\\n\", adapter, diskparam->heads, diskparam->sectors);\n\t\t} else if (part_end_head > 0 || part_end_sector > 0) {\n\t\t\tblogic_warn(\"Warning: Partition Table appears to have Geometry %d/%d which is\\n\", adapter, part_end_head + 1, part_end_sector);\n\t\t\tblogic_warn(\"not compatible with current BusLogic Host Adapter Geometry %d/%d\\n\", adapter, diskparam->heads, diskparam->sectors);\n\t\t}\n\t}\n\tkfree(buf);\n\treturn 0;\n}\n\n\n \n\nstatic int blogic_write_info(struct Scsi_Host *shost, char *procbuf,\n\t\t\t\tint bytes_avail)\n{\n\tstruct blogic_adapter *adapter =\n\t\t\t\t(struct blogic_adapter *) shost->hostdata;\n\tstruct blogic_tgt_stats *tgt_stats;\n\n\ttgt_stats = adapter->tgt_stats;\n\tadapter->ext_resets = 0;\n\tadapter->adapter_intern_errors = 0;\n\tmemset(tgt_stats, 0, BLOGIC_MAXDEV * sizeof(struct blogic_tgt_stats));\n\treturn 0;\n}\n\nstatic int blogic_show_info(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct blogic_adapter *adapter = (struct blogic_adapter *) shost->hostdata;\n\tstruct blogic_tgt_stats *tgt_stats;\n\tint tgt;\n\n\ttgt_stats = adapter->tgt_stats;\n\tseq_write(m, adapter->msgbuf, adapter->msgbuflen);\n\tseq_printf(m, \"\\n\\\nCurrent Driver Queue Depth:\t%d\\n\\\nCurrently Allocated CCBs:\t%d\\n\", adapter->drvr_qdepth, adapter->alloc_ccbs);\n\tseq_puts(m, \"\\n\\n\\\n\t\t\t   DATA TRANSFER STATISTICS\\n\\\n\\n\\\nTarget\tTagged Queuing\tQueue Depth  Active  Attempted\tCompleted\\n\\\n======\t==============\t===========  ======  =========\t=========\\n\");\n\tfor (tgt = 0; tgt < adapter->maxdev; tgt++) {\n\t\tstruct blogic_tgt_flags *tgt_flags = &adapter->tgt_flags[tgt];\n\t\tif (!tgt_flags->tgt_exists)\n\t\t\tcontinue;\n\t\tseq_printf(m, \"  %2d\t%s\", tgt, (tgt_flags->tagq_ok ? (tgt_flags->tagq_active ? \"    Active\" : (adapter->tagq_ok & (1 << tgt)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    ? \"  Permitted\" : \"   Disabled\"))\n\t\t\t\t\t\t\t\t\t  : \"Not Supported\"));\n\t\tseq_printf(m,\n\t\t\t\t  \"\t    %3d       %3u    %9u\t%9u\\n\", adapter->qdepth[tgt], adapter->active_cmds[tgt], tgt_stats[tgt].cmds_tried, tgt_stats[tgt].cmds_complete);\n\t}\n\tseq_puts(m, \"\\n\\\nTarget  Read Commands  Write Commands   Total Bytes Read    Total Bytes Written\\n\\\n======  =============  ==============  ===================  ===================\\n\");\n\tfor (tgt = 0; tgt < adapter->maxdev; tgt++) {\n\t\tstruct blogic_tgt_flags *tgt_flags = &adapter->tgt_flags[tgt];\n\t\tif (!tgt_flags->tgt_exists)\n\t\t\tcontinue;\n\t\tseq_printf(m, \"  %2d\t  %9u\t %9u\", tgt, tgt_stats[tgt].read_cmds, tgt_stats[tgt].write_cmds);\n\t\tif (tgt_stats[tgt].bytesread.billions > 0)\n\t\t\tseq_printf(m, \"     %9u%09u\", tgt_stats[tgt].bytesread.billions, tgt_stats[tgt].bytesread.units);\n\t\telse\n\t\t\tseq_printf(m, \"\t\t%9u\", tgt_stats[tgt].bytesread.units);\n\t\tif (tgt_stats[tgt].byteswritten.billions > 0)\n\t\t\tseq_printf(m, \"   %9u%09u\\n\", tgt_stats[tgt].byteswritten.billions, tgt_stats[tgt].byteswritten.units);\n\t\telse\n\t\t\tseq_printf(m, \"\t     %9u\\n\", tgt_stats[tgt].byteswritten.units);\n\t}\n\tseq_puts(m, \"\\n\\\nTarget  Command    0-1KB      1-2KB      2-4KB      4-8KB     8-16KB\\n\\\n======  =======  =========  =========  =========  =========  =========\\n\");\n\tfor (tgt = 0; tgt < adapter->maxdev; tgt++) {\n\t\tstruct blogic_tgt_flags *tgt_flags = &adapter->tgt_flags[tgt];\n\t\tif (!tgt_flags->tgt_exists)\n\t\t\tcontinue;\n\t\tseq_printf(m,\n\t\t\t    \"  %2d\t Read\t %9u  %9u  %9u  %9u  %9u\\n\", tgt,\n\t\t\t    tgt_stats[tgt].read_sz_buckets[0],\n\t\t\t    tgt_stats[tgt].read_sz_buckets[1], tgt_stats[tgt].read_sz_buckets[2], tgt_stats[tgt].read_sz_buckets[3], tgt_stats[tgt].read_sz_buckets[4]);\n\t\tseq_printf(m,\n\t\t\t    \"  %2d\t Write\t %9u  %9u  %9u  %9u  %9u\\n\", tgt,\n\t\t\t    tgt_stats[tgt].write_sz_buckets[0],\n\t\t\t    tgt_stats[tgt].write_sz_buckets[1], tgt_stats[tgt].write_sz_buckets[2], tgt_stats[tgt].write_sz_buckets[3], tgt_stats[tgt].write_sz_buckets[4]);\n\t}\n\tseq_puts(m, \"\\n\\\nTarget  Command   16-32KB    32-64KB   64-128KB   128-256KB   256KB+\\n\\\n======  =======  =========  =========  =========  =========  =========\\n\");\n\tfor (tgt = 0; tgt < adapter->maxdev; tgt++) {\n\t\tstruct blogic_tgt_flags *tgt_flags = &adapter->tgt_flags[tgt];\n\t\tif (!tgt_flags->tgt_exists)\n\t\t\tcontinue;\n\t\tseq_printf(m,\n\t\t\t    \"  %2d\t Read\t %9u  %9u  %9u  %9u  %9u\\n\", tgt,\n\t\t\t    tgt_stats[tgt].read_sz_buckets[5],\n\t\t\t    tgt_stats[tgt].read_sz_buckets[6], tgt_stats[tgt].read_sz_buckets[7], tgt_stats[tgt].read_sz_buckets[8], tgt_stats[tgt].read_sz_buckets[9]);\n\t\tseq_printf(m,\n\t\t\t    \"  %2d\t Write\t %9u  %9u  %9u  %9u  %9u\\n\", tgt,\n\t\t\t    tgt_stats[tgt].write_sz_buckets[5],\n\t\t\t    tgt_stats[tgt].write_sz_buckets[6], tgt_stats[tgt].write_sz_buckets[7], tgt_stats[tgt].write_sz_buckets[8], tgt_stats[tgt].write_sz_buckets[9]);\n\t}\n\tseq_puts(m, \"\\n\\n\\\n\t\t\t   ERROR RECOVERY STATISTICS\\n\\\n\\n\\\n\t  Command Aborts      Bus Device Resets\t  Host Adapter Resets\\n\\\nTarget\tRequested Completed  Requested Completed  Requested Completed\\n\\\n  ID\t\\\\\\\\\\\\\\\\ Attempted \n======\t ===== ===== =====    ===== ===== =====\t   ===== ===== =====\\n\");\n\tfor (tgt = 0; tgt < adapter->maxdev; tgt++) {\n\t\tstruct blogic_tgt_flags *tgt_flags = &adapter->tgt_flags[tgt];\n\t\tif (!tgt_flags->tgt_exists)\n\t\t\tcontinue;\n\t\tseq_printf(m, \"  %2d\t %5d %5d %5d    %5d %5d %5d\t   %5d %5d %5d\\n\",\n\t\t\t   tgt, tgt_stats[tgt].aborts_request,\n\t\t\t   tgt_stats[tgt].aborts_tried,\n\t\t\t   tgt_stats[tgt].aborts_done,\n\t\t\t   tgt_stats[tgt].bdr_request,\n\t\t\t   tgt_stats[tgt].bdr_tried,\n\t\t\t   tgt_stats[tgt].bdr_done,\n\t\t\t   tgt_stats[tgt].adapter_reset_req,\n\t\t\t   tgt_stats[tgt].adapter_reset_attempt,\n\t\t\t   tgt_stats[tgt].adapter_reset_done);\n\t}\n\tseq_printf(m, \"\\nExternal Host Adapter Resets: %d\\n\", adapter->ext_resets);\n\tseq_printf(m, \"Host Adapter Internal Errors: %d\\n\", adapter->adapter_intern_errors);\n\treturn 0;\n}\n\n\n/*\n  blogic_msg prints Driver Messages.\n*/\n__printf(2, 4)\nstatic void blogic_msg(enum blogic_msglevel msglevel, char *fmt,\n\t\t\tstruct blogic_adapter *adapter, ...)\n{\n\tstatic char buf[BLOGIC_LINEBUF_SIZE];\n\tstatic bool begin = true;\n\tva_list args;\n\tint len = 0;\n\n\tva_start(args, adapter);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif (msglevel == BLOGIC_ANNOUNCE_LEVEL) {\n\t\tstatic int msglines = 0;\n\t\tstrcpy(&adapter->msgbuf[adapter->msgbuflen], buf);\n\t\tadapter->msgbuflen += len;\n\t\tif (++msglines <= 2)\n\t\t\tprintk(\"%sscsi: %s\", blogic_msglevelmap[msglevel], buf);\n\t} else if (msglevel == BLOGIC_INFO_LEVEL) {\n\t\tstrcpy(&adapter->msgbuf[adapter->msgbuflen], buf);\n\t\tadapter->msgbuflen += len;\n\t\tif (begin) {\n\t\t\tif (buf[0] != '\\n' || len > 1)\n\t\t\t\tprintk(\"%sscsi%d: %s\", blogic_msglevelmap[msglevel], adapter->host_no, buf);\n\t\t} else\n\t\t\tpr_cont(\"%s\", buf);\n\t} else {\n\t\tif (begin) {\n\t\t\tif (adapter != NULL && adapter->adapter_initd)\n\t\t\t\tprintk(\"%sscsi%d: %s\", blogic_msglevelmap[msglevel], adapter->host_no, buf);\n\t\t\telse\n\t\t\t\tprintk(\"%s%s\", blogic_msglevelmap[msglevel], buf);\n\t\t} else\n\t\t\tpr_cont(\"%s\", buf);\n\t}\n\tbegin = (buf[len - 1] == '\\n');\n}\n\n\n/*\n  blogic_parse parses an individual option keyword.  It returns true\n  and updates the pointer if the keyword is recognized and false otherwise.\n*/\n\nstatic bool __init blogic_parse(char **str, char *keyword)\n{\n\tchar *pointer = *str;\n\twhile (*keyword != '\\0') {\n\t\tchar strch = *pointer++;\n\t\tchar keywordch = *keyword++;\n\t\tif (strch >= 'A' && strch <= 'Z')\n\t\t\tstrch += 'a' - 'Z';\n\t\tif (keywordch >= 'A' && keywordch <= 'Z')\n\t\t\tkeywordch += 'a' - 'Z';\n\t\tif (strch != keywordch)\n\t\t\treturn false;\n\t}\n\t*str = pointer;\n\treturn true;\n}\n\n\n/*\n  blogic_parseopts handles processing of BusLogic Driver Options\n  specifications.\n\n  BusLogic Driver Options may be specified either via the Linux Kernel Command\n  Line or via the Loadable Kernel Module Installation Facility.  Driver Options\n  for multiple host adapters may be specified either by separating the option\n  strings by a semicolon, or by specifying multiple \"BusLogic=\" strings on the\n  command line.  Individual option specifications for a single host adapter are\n  separated by commas.  The Probing and Debugging Options apply to all host\n  adapters whereas the remaining options apply individually only to the\n  selected host adapter.\n\n  The BusLogic Driver Probing Options are described in\n  <file:Documentation/scsi/BusLogic.rst>.\n*/\n\nstatic int __init blogic_parseopts(char *options)\n{\n\twhile (true) {\n\t\tstruct blogic_drvr_options *drvr_opts =\n\t\t\t&blogic_drvr_options[blogic_drvr_options_count++];\n\t\tint tgt_id;\n\n\t\tmemset(drvr_opts, 0, sizeof(struct blogic_drvr_options));\n\t\twhile (*options != '\\0' && *options != ';') {\n\t\t\tif (blogic_parse(&options, \"NoProbePCI\"))\n\t\t\t\tblogic_probe_options.noprobe_pci = true;\n\t\t\telse if (blogic_parse(&options, \"NoProbe\"))\n\t\t\t\tblogic_probe_options.noprobe = true;\n\t\t\telse if (blogic_parse(&options, \"NoSortPCI\"))\n\t\t\t\tblogic_probe_options.nosort_pci = true;\n\t\t\telse if (blogic_parse(&options, \"MultiMasterFirst\"))\n\t\t\t\tblogic_probe_options.multimaster_first = true;\n\t\t\telse if (blogic_parse(&options, \"FlashPointFirst\"))\n\t\t\t\tblogic_probe_options.flashpoint_first = true;\n\t\t\t/* Tagged Queuing Options. */\n\t\t\telse if (blogic_parse(&options, \"QueueDepth:[\") ||\n\t\t\t\t\tblogic_parse(&options, \"QD:[\")) {\n\t\t\t\tfor (tgt_id = 0; tgt_id < BLOGIC_MAXDEV; tgt_id++) {\n\t\t\t\t\tunsigned short qdepth = simple_strtoul(options, &options, 0);\n\t\t\t\t\tif (qdepth > BLOGIC_MAX_TAG_DEPTH) {\n\t\t\t\t\t\tblogic_err(\"BusLogic: Invalid Driver Options (invalid Queue Depth %d)\\n\", NULL, qdepth);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tdrvr_opts->qdepth[tgt_id] = qdepth;\n\t\t\t\t\tif (*options == ',')\n\t\t\t\t\t\toptions++;\n\t\t\t\t\telse if (*options == ']')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse {\n\t\t\t\t\t\tblogic_err(\"BusLogic: Invalid Driver Options (',' or ']' expected at '%s')\\n\", NULL, options);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*options != ']') {\n\t\t\t\t\tblogic_err(\"BusLogic: Invalid Driver Options (']' expected at '%s')\\n\", NULL, options);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\toptions++;\n\t\t\t} else if (blogic_parse(&options, \"QueueDepth:\") || blogic_parse(&options, \"QD:\")) {\n\t\t\t\tunsigned short qdepth = simple_strtoul(options, &options, 0);\n\t\t\t\tif (qdepth == 0 ||\n\t\t\t\t\t\tqdepth > BLOGIC_MAX_TAG_DEPTH) {\n\t\t\t\t\tblogic_err(\"BusLogic: Invalid Driver Options (invalid Queue Depth %d)\\n\", NULL, qdepth);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tdrvr_opts->common_qdepth = qdepth;\n\t\t\t\tfor (tgt_id = 0; tgt_id < BLOGIC_MAXDEV; tgt_id++)\n\t\t\t\t\tdrvr_opts->qdepth[tgt_id] = qdepth;\n\t\t\t} else if (blogic_parse(&options, \"TaggedQueuing:\") ||\n\t\t\t\t\tblogic_parse(&options, \"TQ:\")) {\n\t\t\t\tif (blogic_parse(&options, \"Default\")) {\n\t\t\t\t\tdrvr_opts->tagq_ok = 0x0000;\n\t\t\t\t\tdrvr_opts->tagq_ok_mask = 0x0000;\n\t\t\t\t} else if (blogic_parse(&options, \"Enable\")) {\n\t\t\t\t\tdrvr_opts->tagq_ok = 0xFFFF;\n\t\t\t\t\tdrvr_opts->tagq_ok_mask = 0xFFFF;\n\t\t\t\t} else if (blogic_parse(&options, \"Disable\")) {\n\t\t\t\t\tdrvr_opts->tagq_ok = 0x0000;\n\t\t\t\t\tdrvr_opts->tagq_ok_mask = 0xFFFF;\n\t\t\t\t} else {\n\t\t\t\t\tunsigned short tgt_bit;\n\t\t\t\t\tfor (tgt_id = 0, tgt_bit = 1;\n\t\t\t\t\t\ttgt_id < BLOGIC_MAXDEV;\n\t\t\t\t\t\ttgt_id++, tgt_bit <<= 1)\n\t\t\t\t\t\tswitch (*options++) {\n\t\t\t\t\t\tcase 'Y':\n\t\t\t\t\t\t\tdrvr_opts->tagq_ok |= tgt_bit;\n\t\t\t\t\t\t\tdrvr_opts->tagq_ok_mask |= tgt_bit;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'N':\n\t\t\t\t\t\t\tdrvr_opts->tagq_ok &= ~tgt_bit;\n\t\t\t\t\t\t\tdrvr_opts->tagq_ok_mask |= tgt_bit;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'X':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\toptions--;\n\t\t\t\t\t\t\ttgt_id = BLOGIC_MAXDEV;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Miscellaneous Options. */\n\t\t\telse if (blogic_parse(&options, \"BusSettleTime:\") ||\n\t\t\t\t\tblogic_parse(&options, \"BST:\")) {\n\t\t\t\tunsigned short bus_settle_time =\n\t\t\t\t\tsimple_strtoul(options, &options, 0);\n\t\t\t\tif (bus_settle_time > 5 * 60) {\n\t\t\t\t\tblogic_err(\"BusLogic: Invalid Driver Options (invalid Bus Settle Time %d)\\n\", NULL, bus_settle_time);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tdrvr_opts->bus_settle_time = bus_settle_time;\n\t\t\t} else if (blogic_parse(&options,\n\t\t\t\t\t\t\"InhibitTargetInquiry\"))\n\t\t\t\tdrvr_opts->stop_tgt_inquiry = true;\n\t\t\t/* Debugging Options. */\n\t\t\telse if (blogic_parse(&options, \"TraceProbe\"))\n\t\t\t\tblogic_global_options.trace_probe = true;\n\t\t\telse if (blogic_parse(&options, \"TraceHardwareReset\"))\n\t\t\t\tblogic_global_options.trace_hw_reset = true;\n\t\t\telse if (blogic_parse(&options, \"TraceConfiguration\"))\n\t\t\t\tblogic_global_options.trace_config = true;\n\t\t\telse if (blogic_parse(&options, \"TraceErrors\"))\n\t\t\t\tblogic_global_options.trace_err = true;\n\t\t\telse if (blogic_parse(&options, \"Debug\")) {\n\t\t\t\tblogic_global_options.trace_probe = true;\n\t\t\t\tblogic_global_options.trace_hw_reset = true;\n\t\t\t\tblogic_global_options.trace_config = true;\n\t\t\t\tblogic_global_options.trace_err = true;\n\t\t\t}\n\t\t\tif (*options == ',')\n\t\t\t\toptions++;\n\t\t\telse if (*options != ';' && *options != '\\0') {\n\t\t\t\tblogic_err(\"BusLogic: Unexpected Driver Option '%s' ignored\\n\", NULL, options);\n\t\t\t\t*options = '\\0';\n\t\t\t}\n\t\t}\n\t\tif (!(blogic_drvr_options_count == 0 ||\n\t\t\tblogic_probeinfo_count == 0 ||\n\t\t\tblogic_drvr_options_count == blogic_probeinfo_count)) {\n\t\t\tblogic_err(\"BusLogic: Invalid Driver Options (all or no I/O Addresses must be specified)\\n\", NULL);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t   Tagged Queuing is disabled when the Queue Depth is 1 since queuing\n\t\t   multiple commands is not possible.\n\t\t */\n\t\tfor (tgt_id = 0; tgt_id < BLOGIC_MAXDEV; tgt_id++)\n\t\t\tif (drvr_opts->qdepth[tgt_id] == 1) {\n\t\t\t\tunsigned short tgt_bit = 1 << tgt_id;\n\t\t\t\tdrvr_opts->tagq_ok &= ~tgt_bit;\n\t\t\t\tdrvr_opts->tagq_ok_mask |= tgt_bit;\n\t\t\t}\n\t\tif (*options == ';')\n\t\t\toptions++;\n\t\tif (*options == '\\0')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/*\n  Get it all started\n*/\n\nstatic const struct scsi_host_template blogic_template = {\n\t.module = THIS_MODULE,\n\t.proc_name = \"BusLogic\",\n\t.write_info = blogic_write_info,\n\t.show_info = blogic_show_info,\n\t.name = \"BusLogic\",\n\t.info = blogic_drvr_info,\n\t.queuecommand = blogic_qcmd,\n\t.slave_configure = blogic_slaveconfig,\n\t.bios_param = blogic_diskparam,\n\t.eh_host_reset_handler = blogic_hostreset,\n#if 0\n\t.eh_abort_handler = blogic_abort,\n#endif\n\t.max_sectors = 128,\n};\n\n/*\n  blogic_setup handles processing of Kernel Command Line Arguments.\n*/\n\nstatic int __init blogic_setup(char *str)\n{\n\tint ints[3];\n\n\t(void) get_options(str, ARRAY_SIZE(ints), ints);\n\n\tif (ints[0] != 0) {\n\t\tblogic_err(\"BusLogic: Obsolete Command Line Entry Format Ignored\\n\", NULL);\n\t\treturn 0;\n\t}\n\tif (str == NULL || *str == '\\0')\n\t\treturn 0;\n\treturn blogic_parseopts(str);\n}\n\n/*\n * Exit function.  Deletes all hosts associated with this driver.\n */\n\nstatic void __exit blogic_exit(void)\n{\n\tstruct blogic_adapter *ha, *next;\n\n\tlist_for_each_entry_safe(ha, next, &blogic_host_list, host_list)\n\t\tblogic_deladapter(ha);\n}\n\n__setup(\"BusLogic=\", blogic_setup);\n\n#ifdef MODULE\n \nstatic const struct pci_device_id blogic_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_BUSLOGIC, PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BUSLOGIC, PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER_NC)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BUSLOGIC, PCI_DEVICE_ID_BUSLOGIC_FLASHPOINT)},\n\t{0, },\n};\n#endif\nMODULE_DEVICE_TABLE(pci, blogic_pci_tbl);\n\nmodule_init(blogic_init);\nmodule_exit(blogic_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}