{
  "module_name": "ch.c",
  "hash_id": "39f0459a541367f22085899c814507a143c882eb71a5b7a178ad50f29b0bbdc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/ch.c",
  "human_readable_source": "\n \n\n#define VERSION \"0.25\"\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/compat.h>\n#include <linux/chio.h>\t\t\t \n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_driver.h>\n#include <scsi/scsi_ioctl.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_dbg.h>\n\n#define CH_DT_MAX       16\n#define CH_TYPES        8\n#define CH_MAX_DEVS     128\n\nMODULE_DESCRIPTION(\"device driver for scsi media changer devices\");\nMODULE_AUTHOR(\"Gerd Knorr <kraxel@bytesex.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_CHARDEV_MAJOR(SCSI_CHANGER_MAJOR);\nMODULE_ALIAS_SCSI_DEVICE(TYPE_MEDIUM_CHANGER);\n\nstatic int init = 1;\nmodule_param(init, int, 0444);\nMODULE_PARM_DESC(init, \\\n    \"initialize element status on driver load (default: on)\");\n\nstatic int timeout_move = 300;\nmodule_param(timeout_move, int, 0644);\nMODULE_PARM_DESC(timeout_move,\"timeout for move commands \"\n\t\t \"(default: 300 seconds)\");\n\nstatic int timeout_init = 3600;\nmodule_param(timeout_init, int, 0644);\nMODULE_PARM_DESC(timeout_init,\"timeout for INITIALIZE ELEMENT STATUS \"\n\t\t \"(default: 3600 seconds)\");\n\nstatic int verbose = 1;\nmodule_param(verbose, int, 0644);\nMODULE_PARM_DESC(verbose,\"be verbose (default: on)\");\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug,\"enable/disable debug messages, also prints more \"\n\t\t \"detailed sense codes on scsi errors (default: off)\");\n\nstatic int dt_id[CH_DT_MAX] = { [ 0 ... (CH_DT_MAX-1) ] = -1 };\nstatic int dt_lun[CH_DT_MAX];\nmodule_param_array(dt_id,  int, NULL, 0444);\nmodule_param_array(dt_lun, int, NULL, 0444);\n\n \nstatic int vendor_firsts[CH_TYPES-4];\nstatic int vendor_counts[CH_TYPES-4];\nmodule_param_array(vendor_firsts, int, NULL, 0444);\nmodule_param_array(vendor_counts, int, NULL, 0444);\n\nstatic const char * vendor_labels[CH_TYPES-4] = {\n\t\"v0\", \"v1\", \"v2\", \"v3\"\n};\n\n\n#define ch_printk(prefix, ch, fmt, a...) \\\n\tsdev_prefix_printk(prefix, (ch)->device, (ch)->name, fmt, ##a)\n\n#define DPRINTK(fmt, arg...)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\t\\\n\t\tch_printk(KERN_DEBUG, ch, fmt, ##arg);\t\t\t\\\n} while (0)\n#define VPRINTK(level, fmt, arg...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (verbose)\t\t\t\t\t\t\t\\\n\t\tch_printk(level, ch, fmt, ##arg);\t\t\t\\\n} while (0)\n\n \n\n#define MAX_RETRIES   1\n\nstatic struct class * ch_sysfs_class;\n\ntypedef struct {\n\tstruct kref         ref;\n\tstruct list_head    list;\n\tint                 minor;\n\tchar                name[8];\n\tstruct scsi_device  *device;\n\tstruct scsi_device  **dt;         \n\tu_int               firsts[CH_TYPES];\n\tu_int               counts[CH_TYPES];\n\tu_int               unit_attention;\n\tu_int\t\t    voltags;\n\tstruct mutex\t    lock;\n} scsi_changer;\n\nstatic DEFINE_IDR(ch_index_idr);\nstatic DEFINE_SPINLOCK(ch_index_lock);\n\nstatic const struct {\n\tunsigned char  sense;\n\tunsigned char  asc;\n\tunsigned char  ascq;\n\tint\t       errno;\n} ch_err[] = {\n \n\t{\n\t\t.sense  = ILLEGAL_REQUEST,\n\t\t.asc    = 0x21,\n\t\t.ascq   = 0x01,\n\t\t.errno  = EBADSLT,  \n\t},{\n\t\t.sense  = ILLEGAL_REQUEST,\n\t\t.asc    = 0x28,\n\t\t.ascq   = 0x01,\n\t\t.errno  = EBADE,    \n\t},{\n\t\t.sense  = ILLEGAL_REQUEST,\n\t\t.asc    = 0x3B,\n\t\t.ascq   = 0x0D,\n\t\t.errno  = EXFULL,   \n\t},{\n\t\t.sense  = ILLEGAL_REQUEST,\n\t\t.asc    = 0x3B,\n\t\t.ascq   = 0x0E,\n\t\t.errno  = EBADE,    \n\t},{\n\t\t.sense  = ILLEGAL_REQUEST,\n\t\t.asc    = 0x20,\n\t\t.ascq   = 0x00,\n\t\t.errno  = EBADRQC,  \n\t},{\n\t         \n\t}\n};\n\n \n\nstatic int ch_find_errno(struct scsi_sense_hdr *sshdr)\n{\n\tint i,errno = 0;\n\n\t \n\tif (scsi_sense_valid(sshdr) &&\n\t    sshdr->asc != 0) {\n\t\tfor (i = 0; ch_err[i].errno != 0; i++) {\n\t\t\tif (ch_err[i].sense == sshdr->sense_key &&\n\t\t\t    ch_err[i].asc   == sshdr->asc &&\n\t\t\t    ch_err[i].ascq  == sshdr->ascq) {\n\t\t\t\terrno = -ch_err[i].errno;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (errno == 0)\n\t\terrno = -EIO;\n\treturn errno;\n}\n\nstatic int\nch_do_scsi(scsi_changer *ch, unsigned char *cmd, int cmd_len,\n\t   void *buffer, unsigned int buflength, enum req_op op)\n{\n\tint errno, retries = 0, timeout, result;\n\tstruct scsi_sense_hdr sshdr;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\n\ttimeout = (cmd[0] == INITIALIZE_ELEMENT_STATUS)\n\t\t? timeout_init : timeout_move;\n\n retry:\n\terrno = 0;\n\tresult = scsi_execute_cmd(ch->device, cmd, op, buffer, buflength,\n\t\t\t\t  timeout * HZ, MAX_RETRIES, &exec_args);\n\tif (result < 0)\n\t\treturn result;\n\tif (scsi_sense_valid(&sshdr)) {\n\t\tif (debug)\n\t\t\tscsi_print_sense_hdr(ch->device, ch->name, &sshdr);\n\t\terrno = ch_find_errno(&sshdr);\n\n\t\tswitch(sshdr.sense_key) {\n\t\tcase UNIT_ATTENTION:\n\t\t\tch->unit_attention = 1;\n\t\t\tif (retries++ < 3)\n\t\t\t\tgoto retry;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn errno;\n}\n\n \n\nstatic int\nch_elem_to_typecode(scsi_changer *ch, u_int elem)\n{\n\tint i;\n\n\tfor (i = 0; i < CH_TYPES; i++) {\n\t\tif (elem >= ch->firsts[i]  &&\n\t\t    elem <  ch->firsts[i] +\n\t            ch->counts[i])\n\t\t\treturn i+1;\n\t}\n\treturn 0;\n}\n\nstatic int\nch_read_element_status(scsi_changer *ch, u_int elem, char *data)\n{\n\tu_char  cmd[12];\n\tu_char  *buffer;\n\tint     result;\n\n\tbuffer = kmalloc(512, GFP_KERNEL);\n\tif(!buffer)\n\t\treturn -ENOMEM;\n\n retry:\n\tmemset(cmd,0,sizeof(cmd));\n\tcmd[0] = READ_ELEMENT_STATUS;\n\tcmd[1] = ((ch->device->lun & 0x7) << 5) |\n\t\t(ch->voltags ? 0x10 : 0) |\n\t\tch_elem_to_typecode(ch,elem);\n\tcmd[2] = (elem >> 8) & 0xff;\n\tcmd[3] = elem        & 0xff;\n\tcmd[5] = 1;\n\tcmd[9] = 255;\n\tif (0 == (result = ch_do_scsi(ch, cmd, 12,\n\t\t\t\t      buffer, 256, REQ_OP_DRV_IN))) {\n\t\tif (((buffer[16] << 8) | buffer[17]) != elem) {\n\t\t\tDPRINTK(\"asked for element 0x%02x, got 0x%02x\\n\",\n\t\t\t\telem,(buffer[16] << 8) | buffer[17]);\n\t\t\tkfree(buffer);\n\t\t\treturn -EIO;\n\t\t}\n\t\tmemcpy(data,buffer+16,16);\n\t} else {\n\t\tif (ch->voltags) {\n\t\t\tch->voltags = 0;\n\t\t\tVPRINTK(KERN_INFO, \"device has no volume tag support\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\tDPRINTK(\"READ ELEMENT STATUS for element 0x%x failed\\n\",elem);\n\t}\n\tkfree(buffer);\n\treturn result;\n}\n\nstatic int\nch_init_elem(scsi_changer *ch)\n{\n\tint err;\n\tu_char cmd[6];\n\n\tVPRINTK(KERN_INFO, \"INITIALIZE ELEMENT STATUS, may take some time ...\\n\");\n\tmemset(cmd,0,sizeof(cmd));\n\tcmd[0] = INITIALIZE_ELEMENT_STATUS;\n\tcmd[1] = (ch->device->lun & 0x7) << 5;\n\terr = ch_do_scsi(ch, cmd, 6, NULL, 0, REQ_OP_DRV_IN);\n\tVPRINTK(KERN_INFO, \"... finished\\n\");\n\treturn err;\n}\n\nstatic int\nch_readconfig(scsi_changer *ch)\n{\n\tu_char  cmd[10], data[16];\n\tu_char  *buffer;\n\tint     result,id,lun,i;\n\tu_int   elem;\n\n\tbuffer = kzalloc(512, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tmemset(cmd,0,sizeof(cmd));\n\tcmd[0] = MODE_SENSE;\n\tcmd[1] = (ch->device->lun & 0x7) << 5;\n\tcmd[2] = 0x1d;\n\tcmd[4] = 255;\n\tresult = ch_do_scsi(ch, cmd, 10, buffer, 255, REQ_OP_DRV_IN);\n\tif (0 != result) {\n\t\tcmd[1] |= (1<<3);\n\t\tresult  = ch_do_scsi(ch, cmd, 10, buffer, 255, REQ_OP_DRV_IN);\n\t}\n\tif (0 == result) {\n\t\tch->firsts[CHET_MT] =\n\t\t\t(buffer[buffer[3]+ 6] << 8) | buffer[buffer[3]+ 7];\n\t\tch->counts[CHET_MT] =\n\t\t\t(buffer[buffer[3]+ 8] << 8) | buffer[buffer[3]+ 9];\n\t\tch->firsts[CHET_ST] =\n\t\t\t(buffer[buffer[3]+10] << 8) | buffer[buffer[3]+11];\n\t\tch->counts[CHET_ST] =\n\t\t\t(buffer[buffer[3]+12] << 8) | buffer[buffer[3]+13];\n\t\tch->firsts[CHET_IE] =\n\t\t\t(buffer[buffer[3]+14] << 8) | buffer[buffer[3]+15];\n\t\tch->counts[CHET_IE] =\n\t\t\t(buffer[buffer[3]+16] << 8) | buffer[buffer[3]+17];\n\t\tch->firsts[CHET_DT] =\n\t\t\t(buffer[buffer[3]+18] << 8) | buffer[buffer[3]+19];\n\t\tch->counts[CHET_DT] =\n\t\t\t(buffer[buffer[3]+20] << 8) | buffer[buffer[3]+21];\n\t\tVPRINTK(KERN_INFO, \"type #1 (mt): 0x%x+%d [medium transport]\\n\",\n\t\t\tch->firsts[CHET_MT],\n\t\t\tch->counts[CHET_MT]);\n\t\tVPRINTK(KERN_INFO, \"type #2 (st): 0x%x+%d [storage]\\n\",\n\t\t\tch->firsts[CHET_ST],\n\t\t\tch->counts[CHET_ST]);\n\t\tVPRINTK(KERN_INFO, \"type #3 (ie): 0x%x+%d [import/export]\\n\",\n\t\t\tch->firsts[CHET_IE],\n\t\t\tch->counts[CHET_IE]);\n\t\tVPRINTK(KERN_INFO, \"type #4 (dt): 0x%x+%d [data transfer]\\n\",\n\t\t\tch->firsts[CHET_DT],\n\t\t\tch->counts[CHET_DT]);\n\t} else {\n\t\tVPRINTK(KERN_INFO, \"reading element address assignment page failed!\\n\");\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tif (0 == vendor_counts[i])\n\t\t\tcontinue;\n\t\tif (NULL == vendor_labels[i])\n\t\t\tcontinue;\n\t\tch->firsts[CHET_V1+i] = vendor_firsts[i];\n\t\tch->counts[CHET_V1+i] = vendor_counts[i];\n\t\tVPRINTK(KERN_INFO, \"type #%d (v%d): 0x%x+%d [%s, vendor specific]\\n\",\n\t\t\ti+5,i+1,vendor_firsts[i],vendor_counts[i],\n\t\t\tvendor_labels[i]);\n\t}\n\n\t \n\tch->dt = kcalloc(ch->counts[CHET_DT], sizeof(*ch->dt),\n\t\t\t GFP_KERNEL);\n\n\tif (!ch->dt) {\n\t\tkfree(buffer);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (elem = 0; elem < ch->counts[CHET_DT]; elem++) {\n\t\tid  = -1;\n\t\tlun = 0;\n\t\tif (elem < CH_DT_MAX  &&  -1 != dt_id[elem]) {\n\t\t\tid  = dt_id[elem];\n\t\t\tlun = dt_lun[elem];\n\t\t\tVPRINTK(KERN_INFO, \"dt 0x%x: [insmod option] \",\n\t\t\t\telem+ch->firsts[CHET_DT]);\n\t\t} else if (0 != ch_read_element_status\n\t\t\t   (ch,elem+ch->firsts[CHET_DT],data)) {\n\t\t\tVPRINTK(KERN_INFO, \"dt 0x%x: READ ELEMENT STATUS failed\\n\",\n\t\t\t\telem+ch->firsts[CHET_DT]);\n\t\t} else {\n\t\t\tVPRINTK(KERN_INFO, \"dt 0x%x: \",elem+ch->firsts[CHET_DT]);\n\t\t\tif (data[6] & 0x80) {\n\t\t\t\tVPRINTK(KERN_CONT, \"not this SCSI bus\\n\");\n\t\t\t\tch->dt[elem] = NULL;\n\t\t\t} else if (0 == (data[6] & 0x30)) {\n\t\t\t\tVPRINTK(KERN_CONT, \"ID/LUN unknown\\n\");\n\t\t\t\tch->dt[elem] = NULL;\n\t\t\t} else {\n\t\t\t\tid  = ch->device->id;\n\t\t\t\tlun = 0;\n\t\t\t\tif (data[6] & 0x20) id  = data[7];\n\t\t\t\tif (data[6] & 0x10) lun = data[6] & 7;\n\t\t\t}\n\t\t}\n\t\tif (-1 != id) {\n\t\t\tVPRINTK(KERN_CONT, \"ID %i, LUN %i, \",id,lun);\n\t\t\tch->dt[elem] =\n\t\t\t\tscsi_device_lookup(ch->device->host,\n\t\t\t\t\t\t   ch->device->channel,\n\t\t\t\t\t\t   id,lun);\n\t\t\tif (!ch->dt[elem]) {\n\t\t\t\t \n\t\t\t\tVPRINTK(KERN_CONT, \"Huh? device not found!\\n\");\n\t\t\t} else {\n\t\t\t\tVPRINTK(KERN_CONT, \"name: %8.8s %16.16s %4.4s\\n\",\n\t\t\t\t\tch->dt[elem]->vendor,\n\t\t\t\t\tch->dt[elem]->model,\n\t\t\t\t\tch->dt[elem]->rev);\n\t\t\t}\n\t\t}\n\t}\n\tch->voltags = 1;\n\tkfree(buffer);\n\n\treturn 0;\n}\n\n \n\nstatic int\nch_position(scsi_changer *ch, u_int trans, u_int elem, int rotate)\n{\n\tu_char  cmd[10];\n\n\tDPRINTK(\"position: 0x%x\\n\",elem);\n\tif (0 == trans)\n\t\ttrans = ch->firsts[CHET_MT];\n\tmemset(cmd,0,sizeof(cmd));\n\tcmd[0]  = POSITION_TO_ELEMENT;\n\tcmd[1]  = (ch->device->lun & 0x7) << 5;\n\tcmd[2]  = (trans >> 8) & 0xff;\n\tcmd[3]  =  trans       & 0xff;\n\tcmd[4]  = (elem  >> 8) & 0xff;\n\tcmd[5]  =  elem        & 0xff;\n\tcmd[8]  = rotate ? 1 : 0;\n\treturn ch_do_scsi(ch, cmd, 10, NULL, 0, REQ_OP_DRV_IN);\n}\n\nstatic int\nch_move(scsi_changer *ch, u_int trans, u_int src, u_int dest, int rotate)\n{\n\tu_char  cmd[12];\n\n\tDPRINTK(\"move: 0x%x => 0x%x\\n\",src,dest);\n\tif (0 == trans)\n\t\ttrans = ch->firsts[CHET_MT];\n\tmemset(cmd,0,sizeof(cmd));\n\tcmd[0]  = MOVE_MEDIUM;\n\tcmd[1]  = (ch->device->lun & 0x7) << 5;\n\tcmd[2]  = (trans >> 8) & 0xff;\n\tcmd[3]  =  trans       & 0xff;\n\tcmd[4]  = (src   >> 8) & 0xff;\n\tcmd[5]  =  src         & 0xff;\n\tcmd[6]  = (dest  >> 8) & 0xff;\n\tcmd[7]  =  dest        & 0xff;\n\tcmd[10] = rotate ? 1 : 0;\n\treturn ch_do_scsi(ch, cmd, 12, NULL, 0, REQ_OP_DRV_IN);\n}\n\nstatic int\nch_exchange(scsi_changer *ch, u_int trans, u_int src,\n\t    u_int dest1, u_int dest2, int rotate1, int rotate2)\n{\n\tu_char  cmd[12];\n\n\tDPRINTK(\"exchange: 0x%x => 0x%x => 0x%x\\n\",\n\t\tsrc,dest1,dest2);\n\tif (0 == trans)\n\t\ttrans = ch->firsts[CHET_MT];\n\tmemset(cmd,0,sizeof(cmd));\n\tcmd[0]  = EXCHANGE_MEDIUM;\n\tcmd[1]  = (ch->device->lun & 0x7) << 5;\n\tcmd[2]  = (trans >> 8) & 0xff;\n\tcmd[3]  =  trans       & 0xff;\n\tcmd[4]  = (src   >> 8) & 0xff;\n\tcmd[5]  =  src         & 0xff;\n\tcmd[6]  = (dest1 >> 8) & 0xff;\n\tcmd[7]  =  dest1       & 0xff;\n\tcmd[8]  = (dest2 >> 8) & 0xff;\n\tcmd[9]  =  dest2       & 0xff;\n\tcmd[10] = (rotate1 ? 1 : 0) | (rotate2 ? 2 : 0);\n\n\treturn ch_do_scsi(ch, cmd, 12, NULL, 0, REQ_OP_DRV_IN);\n}\n\nstatic void\nch_check_voltag(char *tag)\n{\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\t \n\t\tif (tag[i] >= 0x7f || tag[i] < 0x20)\n\t\t\ttag[i] = ' ';\n\t\t \n\t\tif (tag[i] == '?' ||\n\t\t    tag[i] == '*')\n\t\t\ttag[i] = ' ';\n\t}\n}\n\nstatic int\nch_set_voltag(scsi_changer *ch, u_int elem,\n\t      int alternate, int clear, u_char *tag)\n{\n\tu_char  cmd[12];\n\tu_char  *buffer;\n\tint result;\n\n\tbuffer = kzalloc(512, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tDPRINTK(\"%s %s voltag: 0x%x => \\\"%s\\\"\\n\",\n\t\tclear     ? \"clear\"     : \"set\",\n\t\talternate ? \"alternate\" : \"primary\",\n\t\telem, tag);\n\tmemset(cmd,0,sizeof(cmd));\n\tcmd[0]  = SEND_VOLUME_TAG;\n\tcmd[1] = ((ch->device->lun & 0x7) << 5) |\n\t\tch_elem_to_typecode(ch,elem);\n\tcmd[2] = (elem >> 8) & 0xff;\n\tcmd[3] = elem        & 0xff;\n\tcmd[5] = clear\n\t\t? (alternate ? 0x0d : 0x0c)\n\t\t: (alternate ? 0x0b : 0x0a);\n\n\tcmd[9] = 255;\n\n\tmemcpy(buffer,tag,32);\n\tch_check_voltag(buffer);\n\n\tresult = ch_do_scsi(ch, cmd, 12, buffer, 256, REQ_OP_DRV_OUT);\n\tkfree(buffer);\n\treturn result;\n}\n\nstatic int ch_gstatus(scsi_changer *ch, int type, unsigned char __user *dest)\n{\n\tint retval = 0;\n\tu_char data[16];\n\tunsigned int i;\n\n\tmutex_lock(&ch->lock);\n\tfor (i = 0; i < ch->counts[type]; i++) {\n\t\tif (0 != ch_read_element_status\n\t\t    (ch, ch->firsts[type]+i,data)) {\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tput_user(data[2], dest+i);\n\t\tif (data[2] & CESTATUS_EXCEPT)\n\t\t\tVPRINTK(KERN_INFO, \"element 0x%x: asc=0x%x, ascq=0x%x\\n\",\n\t\t\t\tch->firsts[type]+i,\n\t\t\t\t(int)data[4],(int)data[5]);\n\t\tretval = ch_read_element_status\n\t\t\t(ch, ch->firsts[type]+i,data);\n\t\tif (0 != retval)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&ch->lock);\n\treturn retval;\n}\n\n \n\nstatic void ch_destroy(struct kref *ref)\n{\n\tscsi_changer *ch = container_of(ref, scsi_changer, ref);\n\n\tch->device = NULL;\n\tkfree(ch->dt);\n\tkfree(ch);\n}\n\nstatic int\nch_release(struct inode *inode, struct file *file)\n{\n\tscsi_changer *ch = file->private_data;\n\n\tscsi_device_put(ch->device);\n\tfile->private_data = NULL;\n\tkref_put(&ch->ref, ch_destroy);\n\treturn 0;\n}\n\nstatic int\nch_open(struct inode *inode, struct file *file)\n{\n\tscsi_changer *ch;\n\tint minor = iminor(inode);\n\n\tspin_lock(&ch_index_lock);\n\tch = idr_find(&ch_index_idr, minor);\n\n\tif (ch == NULL || !kref_get_unless_zero(&ch->ref)) {\n\t\tspin_unlock(&ch_index_lock);\n\t\treturn -ENXIO;\n\t}\n\tspin_unlock(&ch_index_lock);\n\tif (scsi_device_get(ch->device)) {\n\t\tkref_put(&ch->ref, ch_destroy);\n\t\treturn -ENXIO;\n\t}\n\t \n\tmutex_lock(&ch->lock);\n\tfile->private_data = ch;\n\tmutex_unlock(&ch->lock);\n\treturn 0;\n}\n\nstatic int\nch_checkrange(scsi_changer *ch, unsigned int type, unsigned int unit)\n{\n\tif (type >= CH_TYPES  ||  unit >= ch->counts[type])\n\t\treturn -1;\n\treturn 0;\n}\n\nstruct changer_element_status32 {\n\tint\t\tces_type;\n\tcompat_uptr_t\tces_data;\n};\n#define CHIOGSTATUS32  _IOW('c', 8, struct changer_element_status32)\n\nstatic long ch_ioctl(struct file *file,\n\t\t    unsigned int cmd, unsigned long arg)\n{\n\tscsi_changer *ch = file->private_data;\n\tint retval;\n\tvoid __user *argp = (void __user *)arg;\n\n\tretval = scsi_ioctl_block_when_processing_errors(ch->device, cmd,\n\t\t\tfile->f_flags & O_NDELAY);\n\tif (retval)\n\t\treturn retval;\n\n\tswitch (cmd) {\n\tcase CHIOGPARAMS:\n\t{\n\t\tstruct changer_params params;\n\n\t\tparams.cp_curpicker = 0;\n\t\tparams.cp_npickers  = ch->counts[CHET_MT];\n\t\tparams.cp_nslots    = ch->counts[CHET_ST];\n\t\tparams.cp_nportals  = ch->counts[CHET_IE];\n\t\tparams.cp_ndrives   = ch->counts[CHET_DT];\n\n\t\tif (copy_to_user(argp, &params, sizeof(params)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase CHIOGVPARAMS:\n\t{\n\t\tstruct changer_vendor_params vparams;\n\n\t\tmemset(&vparams,0,sizeof(vparams));\n\t\tif (ch->counts[CHET_V1]) {\n\t\t\tvparams.cvp_n1  = ch->counts[CHET_V1];\n\t\t\tstrncpy(vparams.cvp_label1,vendor_labels[0],16);\n\t\t}\n\t\tif (ch->counts[CHET_V2]) {\n\t\t\tvparams.cvp_n2  = ch->counts[CHET_V2];\n\t\t\tstrncpy(vparams.cvp_label2,vendor_labels[1],16);\n\t\t}\n\t\tif (ch->counts[CHET_V3]) {\n\t\t\tvparams.cvp_n3  = ch->counts[CHET_V3];\n\t\t\tstrncpy(vparams.cvp_label3,vendor_labels[2],16);\n\t\t}\n\t\tif (ch->counts[CHET_V4]) {\n\t\t\tvparams.cvp_n4  = ch->counts[CHET_V4];\n\t\t\tstrncpy(vparams.cvp_label4,vendor_labels[3],16);\n\t\t}\n\t\tif (copy_to_user(argp, &vparams, sizeof(vparams)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase CHIOPOSITION:\n\t{\n\t\tstruct changer_position pos;\n\n\t\tif (copy_from_user(&pos, argp, sizeof (pos)))\n\t\t\treturn -EFAULT;\n\n\t\tif (0 != ch_checkrange(ch, pos.cp_type, pos.cp_unit)) {\n\t\t\tDPRINTK(\"CHIOPOSITION: invalid parameter\\n\");\n\t\t\treturn -EBADSLT;\n\t\t}\n\t\tmutex_lock(&ch->lock);\n\t\tretval = ch_position(ch,0,\n\t\t\t\t     ch->firsts[pos.cp_type] + pos.cp_unit,\n\t\t\t\t     pos.cp_flags & CP_INVERT);\n\t\tmutex_unlock(&ch->lock);\n\t\treturn retval;\n\t}\n\n\tcase CHIOMOVE:\n\t{\n\t\tstruct changer_move mv;\n\n\t\tif (copy_from_user(&mv, argp, sizeof (mv)))\n\t\t\treturn -EFAULT;\n\n\t\tif (0 != ch_checkrange(ch, mv.cm_fromtype, mv.cm_fromunit) ||\n\t\t    0 != ch_checkrange(ch, mv.cm_totype,   mv.cm_tounit  )) {\n\t\t\tDPRINTK(\"CHIOMOVE: invalid parameter\\n\");\n\t\t\treturn -EBADSLT;\n\t\t}\n\n\t\tmutex_lock(&ch->lock);\n\t\tretval = ch_move(ch,0,\n\t\t\t\t ch->firsts[mv.cm_fromtype] + mv.cm_fromunit,\n\t\t\t\t ch->firsts[mv.cm_totype]   + mv.cm_tounit,\n\t\t\t\t mv.cm_flags & CM_INVERT);\n\t\tmutex_unlock(&ch->lock);\n\t\treturn retval;\n\t}\n\n\tcase CHIOEXCHANGE:\n\t{\n\t\tstruct changer_exchange mv;\n\n\t\tif (copy_from_user(&mv, argp, sizeof (mv)))\n\t\t\treturn -EFAULT;\n\n\t\tif (0 != ch_checkrange(ch, mv.ce_srctype,  mv.ce_srcunit ) ||\n\t\t    0 != ch_checkrange(ch, mv.ce_fdsttype, mv.ce_fdstunit) ||\n\t\t    0 != ch_checkrange(ch, mv.ce_sdsttype, mv.ce_sdstunit)) {\n\t\t\tDPRINTK(\"CHIOEXCHANGE: invalid parameter\\n\");\n\t\t\treturn -EBADSLT;\n\t\t}\n\n\t\tmutex_lock(&ch->lock);\n\t\tretval = ch_exchange\n\t\t\t(ch,0,\n\t\t\t ch->firsts[mv.ce_srctype]  + mv.ce_srcunit,\n\t\t\t ch->firsts[mv.ce_fdsttype] + mv.ce_fdstunit,\n\t\t\t ch->firsts[mv.ce_sdsttype] + mv.ce_sdstunit,\n\t\t\t mv.ce_flags & CE_INVERT1, mv.ce_flags & CE_INVERT2);\n\t\tmutex_unlock(&ch->lock);\n\t\treturn retval;\n\t}\n\n\tcase CHIOGSTATUS:\n\t{\n\t\tstruct changer_element_status ces;\n\n\t\tif (copy_from_user(&ces, argp, sizeof (ces)))\n\t\t\treturn -EFAULT;\n\t\tif (ces.ces_type < 0 || ces.ces_type >= CH_TYPES)\n\t\t\treturn -EINVAL;\n\n\t\treturn ch_gstatus(ch, ces.ces_type, ces.ces_data);\n\t}\n#ifdef CONFIG_COMPAT\n\tcase CHIOGSTATUS32:\n\t{\n\t\tstruct changer_element_status32 ces32;\n\n\t\tif (copy_from_user(&ces32, argp, sizeof(ces32)))\n\t\t\treturn -EFAULT;\n\t\tif (ces32.ces_type < 0 || ces32.ces_type >= CH_TYPES)\n\t\t\treturn -EINVAL;\n\n\t\treturn ch_gstatus(ch, ces32.ces_type,\n\t\t\t\t  compat_ptr(ces32.ces_data));\n\t}\n#endif\n\tcase CHIOGELEM:\n\t{\n\t\tstruct changer_get_element cge;\n\t\tu_char ch_cmd[12];\n\t\tu_char *buffer;\n\t\tunsigned int elem;\n\t\tint     result,i;\n\n\t\tif (copy_from_user(&cge, argp, sizeof (cge)))\n\t\t\treturn -EFAULT;\n\n\t\tif (0 != ch_checkrange(ch, cge.cge_type, cge.cge_unit))\n\t\t\treturn -EINVAL;\n\t\telem = ch->firsts[cge.cge_type] + cge.cge_unit;\n\n\t\tbuffer = kmalloc(512, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t\tmutex_lock(&ch->lock);\n\n\tvoltag_retry:\n\t\tmemset(ch_cmd, 0, sizeof(ch_cmd));\n\t\tch_cmd[0] = READ_ELEMENT_STATUS;\n\t\tch_cmd[1] = ((ch->device->lun & 0x7) << 5) |\n\t\t\t(ch->voltags ? 0x10 : 0) |\n\t\t\tch_elem_to_typecode(ch,elem);\n\t\tch_cmd[2] = (elem >> 8) & 0xff;\n\t\tch_cmd[3] = elem        & 0xff;\n\t\tch_cmd[5] = 1;\n\t\tch_cmd[9] = 255;\n\n\t\tresult = ch_do_scsi(ch, ch_cmd, 12, buffer, 256, REQ_OP_DRV_IN);\n\t\tif (!result) {\n\t\t\tcge.cge_status = buffer[18];\n\t\t\tcge.cge_flags = 0;\n\t\t\tif (buffer[18] & CESTATUS_EXCEPT) {\n\t\t\t\tcge.cge_errno = EIO;\n\t\t\t}\n\t\t\tif (buffer[25] & 0x80) {\n\t\t\t\tcge.cge_flags |= CGE_SRC;\n\t\t\t\tif (buffer[25] & 0x40)\n\t\t\t\t\tcge.cge_flags |= CGE_INVERT;\n\t\t\t\telem = (buffer[26]<<8) | buffer[27];\n\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\tif (elem >= ch->firsts[i] &&\n\t\t\t\t\t    elem <  ch->firsts[i] + ch->counts[i]) {\n\t\t\t\t\t\tcge.cge_srctype = i;\n\t\t\t\t\t\tcge.cge_srcunit = elem-ch->firsts[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((buffer[22] & 0x30) == 0x30) {\n\t\t\t\tcge.cge_flags |= CGE_IDLUN;\n\t\t\t\tcge.cge_id  = buffer[23];\n\t\t\t\tcge.cge_lun = buffer[22] & 7;\n\t\t\t}\n\t\t\tif (buffer[9] & 0x80) {\n\t\t\t\tcge.cge_flags |= CGE_PVOLTAG;\n\t\t\t\tmemcpy(cge.cge_pvoltag,buffer+28,36);\n\t\t\t}\n\t\t\tif (buffer[9] & 0x40) {\n\t\t\t\tcge.cge_flags |= CGE_AVOLTAG;\n\t\t\t\tmemcpy(cge.cge_avoltag,buffer+64,36);\n\t\t\t}\n\t\t} else if (ch->voltags) {\n\t\t\tch->voltags = 0;\n\t\t\tVPRINTK(KERN_INFO, \"device has no volume tag support\\n\");\n\t\t\tgoto voltag_retry;\n\t\t}\n\t\tkfree(buffer);\n\t\tmutex_unlock(&ch->lock);\n\n\t\tif (copy_to_user(argp, &cge, sizeof (cge)))\n\t\t\treturn -EFAULT;\n\t\treturn result;\n\t}\n\n\tcase CHIOINITELEM:\n\t{\n\t\tmutex_lock(&ch->lock);\n\t\tretval = ch_init_elem(ch);\n\t\tmutex_unlock(&ch->lock);\n\t\treturn retval;\n\t}\n\n\tcase CHIOSVOLTAG:\n\t{\n\t\tstruct changer_set_voltag csv;\n\t\tint elem;\n\n\t\tif (copy_from_user(&csv, argp, sizeof(csv)))\n\t\t\treturn -EFAULT;\n\n\t\tif (0 != ch_checkrange(ch, csv.csv_type, csv.csv_unit)) {\n\t\t\tDPRINTK(\"CHIOSVOLTAG: invalid parameter\\n\");\n\t\t\treturn -EBADSLT;\n\t\t}\n\t\telem = ch->firsts[csv.csv_type] + csv.csv_unit;\n\t\tmutex_lock(&ch->lock);\n\t\tretval = ch_set_voltag(ch, elem,\n\t\t\t\t       csv.csv_flags & CSV_AVOLTAG,\n\t\t\t\t       csv.csv_flags & CSV_CLEARTAG,\n\t\t\t\t       csv.csv_voltag);\n\t\tmutex_unlock(&ch->lock);\n\t\treturn retval;\n\t}\n\n\tdefault:\n\t\treturn scsi_ioctl(ch->device, file->f_mode & FMODE_WRITE, cmd,\n\t\t\t\t  argp);\n\n\t}\n}\n\n \n\nstatic int ch_probe(struct device *dev)\n{\n\tstruct scsi_device *sd = to_scsi_device(dev);\n\tstruct device *class_dev;\n\tint ret;\n\tscsi_changer *ch;\n\n\tif (sd->type != TYPE_MEDIUM_CHANGER)\n\t\treturn -ENODEV;\n\n\tch = kzalloc(sizeof(*ch), GFP_KERNEL);\n\tif (NULL == ch)\n\t\treturn -ENOMEM;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&ch_index_lock);\n\tret = idr_alloc(&ch_index_idr, ch, 0, CH_MAX_DEVS + 1, GFP_NOWAIT);\n\tspin_unlock(&ch_index_lock);\n\tidr_preload_end();\n\n\tif (ret < 0) {\n\t\tif (ret == -ENOSPC)\n\t\t\tret = -ENODEV;\n\t\tgoto free_ch;\n\t}\n\n\tch->minor = ret;\n\tsprintf(ch->name,\"ch%d\",ch->minor);\n\tret = scsi_device_get(sd);\n\tif (ret) {\n\t\tsdev_printk(KERN_WARNING, sd, \"ch%d: failed to get device\\n\",\n\t\t\t    ch->minor);\n\t\tgoto remove_idr;\n\t}\n\n\tmutex_init(&ch->lock);\n\tkref_init(&ch->ref);\n\tch->device = sd;\n\tclass_dev = device_create(ch_sysfs_class, dev,\n\t\t\t\t  MKDEV(SCSI_CHANGER_MAJOR, ch->minor), ch,\n\t\t\t\t  \"s%s\", ch->name);\n\tif (IS_ERR(class_dev)) {\n\t\tsdev_printk(KERN_WARNING, sd, \"ch%d: device_create failed\\n\",\n\t\t\t    ch->minor);\n\t\tret = PTR_ERR(class_dev);\n\t\tgoto put_device;\n\t}\n\n\tmutex_lock(&ch->lock);\n\tret = ch_readconfig(ch);\n\tif (ret) {\n\t\tmutex_unlock(&ch->lock);\n\t\tgoto destroy_dev;\n\t}\n\tif (init)\n\t\tch_init_elem(ch);\n\n\tmutex_unlock(&ch->lock);\n\tdev_set_drvdata(dev, ch);\n\tsdev_printk(KERN_INFO, sd, \"Attached scsi changer %s\\n\", ch->name);\n\n\treturn 0;\ndestroy_dev:\n\tdevice_destroy(ch_sysfs_class, MKDEV(SCSI_CHANGER_MAJOR, ch->minor));\nput_device:\n\tscsi_device_put(sd);\nremove_idr:\n\tidr_remove(&ch_index_idr, ch->minor);\nfree_ch:\n\tkfree(ch);\n\treturn ret;\n}\n\nstatic int ch_remove(struct device *dev)\n{\n\tscsi_changer *ch = dev_get_drvdata(dev);\n\n\tspin_lock(&ch_index_lock);\n\tidr_remove(&ch_index_idr, ch->minor);\n\tdev_set_drvdata(dev, NULL);\n\tspin_unlock(&ch_index_lock);\n\n\tdevice_destroy(ch_sysfs_class, MKDEV(SCSI_CHANGER_MAJOR,ch->minor));\n\tscsi_device_put(ch->device);\n\tkref_put(&ch->ref, ch_destroy);\n\treturn 0;\n}\n\nstatic struct scsi_driver ch_template = {\n\t.gendrv     \t= {\n\t\t.name\t= \"ch\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.probe  = ch_probe,\n\t\t.remove = ch_remove,\n\t},\n};\n\nstatic const struct file_operations changer_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ch_open,\n\t.release\t= ch_release,\n\t.unlocked_ioctl\t= ch_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int __init init_ch_module(void)\n{\n\tint rc;\n\n\tprintk(KERN_INFO \"SCSI Media Changer driver v\" VERSION \" \\n\");\n        ch_sysfs_class = class_create(\"scsi_changer\");\n        if (IS_ERR(ch_sysfs_class)) {\n\t\trc = PTR_ERR(ch_sysfs_class);\n\t\treturn rc;\n        }\n\trc = register_chrdev(SCSI_CHANGER_MAJOR,\"ch\",&changer_fops);\n\tif (rc < 0) {\n\t\tprintk(\"Unable to get major %d for SCSI-Changer\\n\",\n\t\t       SCSI_CHANGER_MAJOR);\n\t\tgoto fail1;\n\t}\n\trc = scsi_register_driver(&ch_template.gendrv);\n\tif (rc < 0)\n\t\tgoto fail2;\n\treturn 0;\n\n fail2:\n\tunregister_chrdev(SCSI_CHANGER_MAJOR, \"ch\");\n fail1:\n\tclass_destroy(ch_sysfs_class);\n\treturn rc;\n}\n\nstatic void __exit exit_ch_module(void)\n{\n\tscsi_unregister_driver(&ch_template.gendrv);\n\tunregister_chrdev(SCSI_CHANGER_MAJOR, \"ch\");\n\tclass_destroy(ch_sysfs_class);\n\tidr_destroy(&ch_index_idr);\n}\n\nmodule_init(init_ch_module);\nmodule_exit(exit_ch_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}