{
  "module_name": "scsi.c",
  "hash_id": "8ff7cb303f56d860b96514e04d689093642e4cfaa40ad0b90865bbd334f76687",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/completion.h>\n#include <linux/unistd.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/mutex.h>\n#include <asm/unaligned.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_driver.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n\n#include \"scsi_priv.h\"\n#include \"scsi_logging.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/scsi.h>\n\n \n\n \nunsigned int scsi_logging_level;\n#if defined(CONFIG_SCSI_LOGGING)\nEXPORT_SYMBOL(scsi_logging_level);\n#endif\n\n#ifdef CONFIG_SCSI_LOGGING\nvoid scsi_log_send(struct scsi_cmnd *cmd)\n{\n\tunsigned int level;\n\n\t \n\tif (unlikely(scsi_logging_level)) {\n\t\tlevel = SCSI_LOG_LEVEL(SCSI_LOG_MLQUEUE_SHIFT,\n\t\t\t\t       SCSI_LOG_MLQUEUE_BITS);\n\t\tif (level > 1) {\n\t\t\tscmd_printk(KERN_INFO, cmd,\n\t\t\t\t    \"Send: scmd 0x%p\\n\", cmd);\n\t\t\tscsi_print_command(cmd);\n\t\t}\n\t}\n}\n\nvoid scsi_log_completion(struct scsi_cmnd *cmd, int disposition)\n{\n\tunsigned int level;\n\n\t \n\tif (unlikely(scsi_logging_level)) {\n\t\tlevel = SCSI_LOG_LEVEL(SCSI_LOG_MLCOMPLETE_SHIFT,\n\t\t\t\t       SCSI_LOG_MLCOMPLETE_BITS);\n\t\tif (((level > 0) && (cmd->result || disposition != SUCCESS)) ||\n\t\t    (level > 1)) {\n\t\t\tscsi_print_result(cmd, \"Done\", disposition);\n\t\t\tscsi_print_command(cmd);\n\t\t\tif (scsi_status_is_check_condition(cmd->result))\n\t\t\t\tscsi_print_sense(cmd);\n\t\t\tif (level > 3)\n\t\t\t\tscmd_printk(KERN_INFO, cmd,\n\t\t\t\t\t    \"scsi host busy %d failed %d\\n\",\n\t\t\t\t\t    scsi_host_busy(cmd->device->host),\n\t\t\t\t\t    cmd->device->host->host_failed);\n\t\t}\n\t}\n}\n#endif\n\n \nvoid scsi_finish_command(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_device *sdev = cmd->device;\n\tstruct scsi_target *starget = scsi_target(sdev);\n\tstruct Scsi_Host *shost = sdev->host;\n\tstruct scsi_driver *drv;\n\tunsigned int good_bytes;\n\n\tscsi_device_unbusy(sdev, cmd);\n\n\t \n\tif (atomic_read(&shost->host_blocked))\n\t\tatomic_set(&shost->host_blocked, 0);\n\tif (atomic_read(&starget->target_blocked))\n\t\tatomic_set(&starget->target_blocked, 0);\n\tif (atomic_read(&sdev->device_blocked))\n\t\tatomic_set(&sdev->device_blocked, 0);\n\n\tSCSI_LOG_MLCOMPLETE(4, sdev_printk(KERN_INFO, sdev,\n\t\t\t\t\"Notifying upper driver of completion \"\n\t\t\t\t\"(result %x)\\n\", cmd->result));\n\n\tgood_bytes = scsi_bufflen(cmd);\n\tif (!blk_rq_is_passthrough(scsi_cmd_to_rq(cmd))) {\n\t\tint old_good_bytes = good_bytes;\n\t\tdrv = scsi_cmd_to_driver(cmd);\n\t\tif (drv->done)\n\t\t\tgood_bytes = drv->done(cmd);\n\t\t \n\t\tif (good_bytes == old_good_bytes)\n\t\t\tgood_bytes -= scsi_get_resid(cmd);\n\t}\n\tscsi_io_completion(cmd, good_bytes);\n}\n\n\n \nint scsi_device_max_queue_depth(struct scsi_device *sdev)\n{\n\treturn min_t(int, sdev->host->can_queue, 4096);\n}\n\n \nint scsi_change_queue_depth(struct scsi_device *sdev, int depth)\n{\n\tdepth = min_t(int, depth, scsi_device_max_queue_depth(sdev));\n\n\tif (depth > 0) {\n\t\tsdev->queue_depth = depth;\n\t\twmb();\n\t}\n\n\tif (sdev->request_queue)\n\t\tblk_set_queue_depth(sdev->request_queue, depth);\n\n\tsbitmap_resize(&sdev->budget_map, sdev->queue_depth);\n\n\treturn sdev->queue_depth;\n}\nEXPORT_SYMBOL(scsi_change_queue_depth);\n\n \nint scsi_track_queue_full(struct scsi_device *sdev, int depth)\n{\n\n\t \n\tif ((jiffies >> 4) == (sdev->last_queue_full_time >> 4))\n\t\treturn 0;\n\n\tsdev->last_queue_full_time = jiffies;\n\tif (sdev->last_queue_full_depth != depth) {\n\t\tsdev->last_queue_full_count = 1;\n\t\tsdev->last_queue_full_depth = depth;\n\t} else {\n\t\tsdev->last_queue_full_count++;\n\t}\n\n\tif (sdev->last_queue_full_count <= 10)\n\t\treturn 0;\n\n\treturn scsi_change_queue_depth(sdev, depth);\n}\nEXPORT_SYMBOL(scsi_track_queue_full);\n\n \nstatic int scsi_vpd_inquiry(struct scsi_device *sdev, unsigned char *buffer,\n\t\t\t\t\t\t\tu8 page, unsigned len)\n{\n\tint result;\n\tunsigned char cmd[16];\n\n\tif (len < 4)\n\t\treturn -EINVAL;\n\n\tcmd[0] = INQUIRY;\n\tcmd[1] = 1;\t\t \n\tcmd[2] = page;\n\tcmd[3] = len >> 8;\n\tcmd[4] = len & 0xff;\n\tcmd[5] = 0;\t\t \n\n\t \n\tresult = scsi_execute_cmd(sdev, cmd, REQ_OP_DRV_IN, buffer, len,\n\t\t\t\t  30 * HZ, 3, NULL);\n\tif (result)\n\t\treturn -EIO;\n\n\t \n\tif (buffer[1] != page)\n\t\treturn -EIO;\n\n\tresult = get_unaligned_be16(&buffer[2]);\n\tif (!result)\n\t\treturn -EIO;\n\n\treturn result + 4;\n}\n\nstatic int scsi_get_vpd_size(struct scsi_device *sdev, u8 page)\n{\n\tunsigned char vpd_header[SCSI_VPD_HEADER_SIZE] __aligned(4);\n\tint result;\n\n\tif (sdev->no_vpd_size)\n\t\treturn SCSI_DEFAULT_VPD_LEN;\n\n\t \n\tresult = scsi_vpd_inquiry(sdev, vpd_header, page, sizeof(vpd_header));\n\tif (result < 0)\n\t\treturn 0;\n\n\tif (result < SCSI_VPD_HEADER_SIZE) {\n\t\tdev_warn_once(&sdev->sdev_gendev,\n\t\t\t      \"%s: short VPD page 0x%02x length: %d bytes\\n\",\n\t\t\t      __func__, page, result);\n\t\treturn 0;\n\t}\n\n\treturn result;\n}\n\n \nint scsi_get_vpd_page(struct scsi_device *sdev, u8 page, unsigned char *buf,\n\t\t      int buf_len)\n{\n\tint result, vpd_len;\n\n\tif (!scsi_device_supports_vpd(sdev))\n\t\treturn -EINVAL;\n\n\tvpd_len = scsi_get_vpd_size(sdev, page);\n\tif (vpd_len <= 0)\n\t\treturn -EINVAL;\n\n\tvpd_len = min(vpd_len, buf_len);\n\n\t \n\tmemset(buf, 0, buf_len);\n\tresult = scsi_vpd_inquiry(sdev, buf, page, vpd_len);\n\tif (result < 0)\n\t\treturn -EINVAL;\n\telse if (result > vpd_len)\n\t\tdev_warn_once(&sdev->sdev_gendev,\n\t\t\t      \"%s: VPD page 0x%02x result %d > %d bytes\\n\",\n\t\t\t      __func__, page, result, vpd_len);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(scsi_get_vpd_page);\n\n \nstatic struct scsi_vpd *scsi_get_vpd_buf(struct scsi_device *sdev, u8 page)\n{\n\tstruct scsi_vpd *vpd_buf;\n\tint vpd_len, result;\n\n\tvpd_len = scsi_get_vpd_size(sdev, page);\n\tif (vpd_len <= 0)\n\t\treturn NULL;\n\nretry_pg:\n\t \n\tvpd_buf = kmalloc(sizeof(*vpd_buf) + vpd_len, GFP_KERNEL);\n\tif (!vpd_buf)\n\t\treturn NULL;\n\n\tresult = scsi_vpd_inquiry(sdev, vpd_buf->data, page, vpd_len);\n\tif (result < 0) {\n\t\tkfree(vpd_buf);\n\t\treturn NULL;\n\t}\n\tif (result > vpd_len) {\n\t\tdev_warn_once(&sdev->sdev_gendev,\n\t\t\t      \"%s: VPD page 0x%02x result %d > %d bytes\\n\",\n\t\t\t      __func__, page, result, vpd_len);\n\t\tvpd_len = result;\n\t\tkfree(vpd_buf);\n\t\tgoto retry_pg;\n\t}\n\n\tvpd_buf->len = result;\n\n\treturn vpd_buf;\n}\n\nstatic void scsi_update_vpd_page(struct scsi_device *sdev, u8 page,\n\t\t\t\t struct scsi_vpd __rcu **sdev_vpd_buf)\n{\n\tstruct scsi_vpd *vpd_buf;\n\n\tvpd_buf = scsi_get_vpd_buf(sdev, page);\n\tif (!vpd_buf)\n\t\treturn;\n\n\tmutex_lock(&sdev->inquiry_mutex);\n\tvpd_buf = rcu_replace_pointer(*sdev_vpd_buf, vpd_buf,\n\t\t\t\t      lockdep_is_held(&sdev->inquiry_mutex));\n\tmutex_unlock(&sdev->inquiry_mutex);\n\n\tif (vpd_buf)\n\t\tkfree_rcu(vpd_buf, rcu);\n}\n\n \nvoid scsi_attach_vpd(struct scsi_device *sdev)\n{\n\tint i;\n\tstruct scsi_vpd *vpd_buf;\n\n\tif (!scsi_device_supports_vpd(sdev))\n\t\treturn;\n\n\t \n\tvpd_buf = scsi_get_vpd_buf(sdev, 0);\n\tif (!vpd_buf)\n\t\treturn;\n\n\tfor (i = 4; i < vpd_buf->len; i++) {\n\t\tif (vpd_buf->data[i] == 0x0)\n\t\t\tscsi_update_vpd_page(sdev, 0x0, &sdev->vpd_pg0);\n\t\tif (vpd_buf->data[i] == 0x80)\n\t\t\tscsi_update_vpd_page(sdev, 0x80, &sdev->vpd_pg80);\n\t\tif (vpd_buf->data[i] == 0x83)\n\t\t\tscsi_update_vpd_page(sdev, 0x83, &sdev->vpd_pg83);\n\t\tif (vpd_buf->data[i] == 0x89)\n\t\t\tscsi_update_vpd_page(sdev, 0x89, &sdev->vpd_pg89);\n\t\tif (vpd_buf->data[i] == 0xb0)\n\t\t\tscsi_update_vpd_page(sdev, 0xb0, &sdev->vpd_pgb0);\n\t\tif (vpd_buf->data[i] == 0xb1)\n\t\t\tscsi_update_vpd_page(sdev, 0xb1, &sdev->vpd_pgb1);\n\t\tif (vpd_buf->data[i] == 0xb2)\n\t\t\tscsi_update_vpd_page(sdev, 0xb2, &sdev->vpd_pgb2);\n\t}\n\tkfree(vpd_buf);\n}\n\n \nint scsi_report_opcode(struct scsi_device *sdev, unsigned char *buffer,\n\t\t       unsigned int len, unsigned char opcode,\n\t\t       unsigned short sa)\n{\n\tunsigned char cmd[16];\n\tstruct scsi_sense_hdr sshdr;\n\tint result, request_len;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\n\tif (sdev->no_report_opcodes || sdev->scsi_level < SCSI_SPC_3)\n\t\treturn -EINVAL;\n\n\t \n\trequest_len = 4 + COMMAND_SIZE(opcode);\n\tif (request_len > len) {\n\t\tdev_warn_once(&sdev->sdev_gendev,\n\t\t\t      \"%s: len %u bytes, opcode 0x%02x needs %u\\n\",\n\t\t\t      __func__, len, opcode, request_len);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(cmd, 0, 16);\n\tcmd[0] = MAINTENANCE_IN;\n\tcmd[1] = MI_REPORT_SUPPORTED_OPERATION_CODES;\n\tif (!sa) {\n\t\tcmd[2] = 1;\t \n\t\tcmd[3] = opcode;\n\t} else {\n\t\tcmd[2] = 3;\t \n\t\tcmd[3] = opcode;\n\t\tput_unaligned_be16(sa, &cmd[4]);\n\t}\n\tput_unaligned_be32(request_len, &cmd[6]);\n\tmemset(buffer, 0, len);\n\n\tresult = scsi_execute_cmd(sdev, cmd, REQ_OP_DRV_IN, buffer,\n\t\t\t\t  request_len, 30 * HZ, 3, &exec_args);\n\tif (result < 0)\n\t\treturn result;\n\tif (result && scsi_sense_valid(&sshdr) &&\n\t    sshdr.sense_key == ILLEGAL_REQUEST &&\n\t    (sshdr.asc == 0x20 || sshdr.asc == 0x24) && sshdr.ascq == 0x00)\n\t\treturn -EINVAL;\n\n\tif ((buffer[1] & 3) == 3)  \n\t\treturn 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(scsi_report_opcode);\n\n#define SCSI_CDL_CHECK_BUF_LEN\t64\n\nstatic bool scsi_cdl_check_cmd(struct scsi_device *sdev, u8 opcode, u16 sa,\n\t\t\t       unsigned char *buf)\n{\n\tint ret;\n\tu8 cdlp;\n\n\t \n\tret = scsi_report_opcode(sdev, buf, SCSI_CDL_CHECK_BUF_LEN, opcode, sa);\n\tif (ret <= 0)\n\t\treturn false;\n\n\tif ((buf[1] & 0x03) != 0x03)\n\t\treturn false;\n\n\t \n\tcdlp = (buf[1] & 0x18) >> 3;\n\n\treturn cdlp == 0x01 || cdlp == 0x02;\n}\n\n \nvoid scsi_cdl_check(struct scsi_device *sdev)\n{\n\tbool cdl_supported;\n\tunsigned char *buf;\n\n\t \n\tif (sdev->scsi_level < SCSI_SPC_5) {\n\t\tsdev->cdl_supported = 0;\n\t\treturn;\n\t}\n\n\tbuf = kmalloc(SCSI_CDL_CHECK_BUF_LEN, GFP_KERNEL);\n\tif (!buf) {\n\t\tsdev->cdl_supported = 0;\n\t\treturn;\n\t}\n\n\t \n\tcdl_supported =\n\t\tscsi_cdl_check_cmd(sdev, READ_16, 0, buf) ||\n\t\tscsi_cdl_check_cmd(sdev, WRITE_16, 0, buf) ||\n\t\tscsi_cdl_check_cmd(sdev, VARIABLE_LENGTH_CMD, READ_32, buf) ||\n\t\tscsi_cdl_check_cmd(sdev, VARIABLE_LENGTH_CMD, WRITE_32, buf);\n\tif (cdl_supported) {\n\t\t \n\t\tsdev->use_16_for_rw = 1;\n\t\tsdev->use_10_for_rw = 0;\n\n\t\tsdev->cdl_supported = 1;\n\t} else {\n\t\tsdev->cdl_supported = 0;\n\t}\n\n\tkfree(buf);\n}\n\n \nint scsi_cdl_enable(struct scsi_device *sdev, bool enable)\n{\n\tstruct scsi_mode_data data;\n\tstruct scsi_sense_hdr sshdr;\n\tstruct scsi_vpd *vpd;\n\tbool is_ata = false;\n\tchar buf[64];\n\tint ret;\n\n\tif (!sdev->cdl_supported)\n\t\treturn -EOPNOTSUPP;\n\n\trcu_read_lock();\n\tvpd = rcu_dereference(sdev->vpd_pg89);\n\tif (vpd)\n\t\tis_ata = true;\n\trcu_read_unlock();\n\n\t \n\tif (is_ata) {\n\t\tchar *buf_data;\n\t\tint len;\n\n\t\tret = scsi_mode_sense(sdev, 0x08, 0x0a, 0xf2, buf, sizeof(buf),\n\t\t\t\t      5 * HZ, 3, &data, NULL);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tlen = min_t(size_t, sizeof(buf),\n\t\t\t    data.length - data.header_length -\n\t\t\t    data.block_descriptor_length);\n\t\tbuf_data = buf + data.header_length +\n\t\t\tdata.block_descriptor_length;\n\t\tif (enable)\n\t\t\tbuf_data[4] = 0x02;\n\t\telse\n\t\t\tbuf_data[4] = 0;\n\n\t\tret = scsi_mode_select(sdev, 1, 0, buf_data, len, 5 * HZ, 3,\n\t\t\t\t       &data, &sshdr);\n\t\tif (ret) {\n\t\t\tif (scsi_sense_valid(&sshdr))\n\t\t\t\tscsi_print_sense_hdr(sdev,\n\t\t\t\t\tdev_name(&sdev->sdev_gendev), &sshdr);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tsdev->cdl_enable = enable;\n\n\treturn 0;\n}\n\n \nint scsi_device_get(struct scsi_device *sdev)\n{\n\tif (sdev->sdev_state == SDEV_DEL || sdev->sdev_state == SDEV_CANCEL)\n\t\tgoto fail;\n\tif (!try_module_get(sdev->host->hostt->module))\n\t\tgoto fail;\n\tif (!get_device(&sdev->sdev_gendev))\n\t\tgoto fail_put_module;\n\treturn 0;\n\nfail_put_module:\n\tmodule_put(sdev->host->hostt->module);\nfail:\n\treturn -ENXIO;\n}\nEXPORT_SYMBOL(scsi_device_get);\n\n \nvoid scsi_device_put(struct scsi_device *sdev)\n{\n\tstruct module *mod = sdev->host->hostt->module;\n\n\tput_device(&sdev->sdev_gendev);\n\tmodule_put(mod);\n}\nEXPORT_SYMBOL(scsi_device_put);\n\n \nstruct scsi_device *__scsi_iterate_devices(struct Scsi_Host *shost,\n\t\t\t\t\t   struct scsi_device *prev)\n{\n\tstruct list_head *list = (prev ? &prev->siblings : &shost->__devices);\n\tstruct scsi_device *next = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\twhile (list->next != &shost->__devices) {\n\t\tnext = list_entry(list->next, struct scsi_device, siblings);\n\t\t \n\t\tif (!scsi_device_get(next))\n\t\t\tbreak;\n\t\tnext = NULL;\n\t\tlist = list->next;\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tif (prev)\n\t\tscsi_device_put(prev);\n\treturn next;\n}\nEXPORT_SYMBOL(__scsi_iterate_devices);\n\n \nvoid starget_for_each_device(struct scsi_target *starget, void *data,\n\t\t     void (*fn)(struct scsi_device *, void *))\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct scsi_device *sdev;\n\n\tshost_for_each_device(sdev, shost) {\n\t\tif ((sdev->channel == starget->channel) &&\n\t\t    (sdev->id == starget->id))\n\t\t\tfn(sdev, data);\n\t}\n}\nEXPORT_SYMBOL(starget_for_each_device);\n\n \nvoid __starget_for_each_device(struct scsi_target *starget, void *data,\n\t\t\t       void (*fn)(struct scsi_device *, void *))\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct scsi_device *sdev;\n\n\t__shost_for_each_device(sdev, shost) {\n\t\tif ((sdev->channel == starget->channel) &&\n\t\t    (sdev->id == starget->id))\n\t\t\tfn(sdev, data);\n\t}\n}\nEXPORT_SYMBOL(__starget_for_each_device);\n\n \nstruct scsi_device *__scsi_device_lookup_by_target(struct scsi_target *starget,\n\t\t\t\t\t\t   u64 lun)\n{\n\tstruct scsi_device *sdev;\n\n\tlist_for_each_entry(sdev, &starget->devices, same_target_siblings) {\n\t\tif (sdev->sdev_state == SDEV_DEL)\n\t\t\tcontinue;\n\t\tif (sdev->lun ==lun)\n\t\t\treturn sdev;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(__scsi_device_lookup_by_target);\n\n \nstruct scsi_device *scsi_device_lookup_by_target(struct scsi_target *starget,\n\t\t\t\t\t\t u64 lun)\n{\n\tstruct scsi_device *sdev;\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tsdev = __scsi_device_lookup_by_target(starget, lun);\n\tif (sdev && scsi_device_get(sdev))\n\t\tsdev = NULL;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\treturn sdev;\n}\nEXPORT_SYMBOL(scsi_device_lookup_by_target);\n\n \nstruct scsi_device *__scsi_device_lookup(struct Scsi_Host *shost,\n\t\tuint channel, uint id, u64 lun)\n{\n\tstruct scsi_device *sdev;\n\n\tlist_for_each_entry(sdev, &shost->__devices, siblings) {\n\t\tif (sdev->sdev_state == SDEV_DEL)\n\t\t\tcontinue;\n\t\tif (sdev->channel == channel && sdev->id == id &&\n\t\t\t\tsdev->lun ==lun)\n\t\t\treturn sdev;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(__scsi_device_lookup);\n\n \nstruct scsi_device *scsi_device_lookup(struct Scsi_Host *shost,\n\t\tuint channel, uint id, u64 lun)\n{\n\tstruct scsi_device *sdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tsdev = __scsi_device_lookup(shost, channel, id, lun);\n\tif (sdev && scsi_device_get(sdev))\n\t\tsdev = NULL;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\treturn sdev;\n}\nEXPORT_SYMBOL(scsi_device_lookup);\n\nMODULE_DESCRIPTION(\"SCSI core\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(scsi_logging_level, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(scsi_logging_level, \"a bit mask of logging levels\");\n\nstatic int __init init_scsi(void)\n{\n\tint error;\n\n\terror = scsi_init_procfs();\n\tif (error)\n\t\tgoto cleanup_queue;\n\terror = scsi_init_devinfo();\n\tif (error)\n\t\tgoto cleanup_procfs;\n\terror = scsi_init_hosts();\n\tif (error)\n\t\tgoto cleanup_devlist;\n\terror = scsi_init_sysctl();\n\tif (error)\n\t\tgoto cleanup_hosts;\n\terror = scsi_sysfs_register();\n\tif (error)\n\t\tgoto cleanup_sysctl;\n\n\tscsi_netlink_init();\n\n\tprintk(KERN_NOTICE \"SCSI subsystem initialized\\n\");\n\treturn 0;\n\ncleanup_sysctl:\n\tscsi_exit_sysctl();\ncleanup_hosts:\n\tscsi_exit_hosts();\ncleanup_devlist:\n\tscsi_exit_devinfo();\ncleanup_procfs:\n\tscsi_exit_procfs();\ncleanup_queue:\n\tscsi_exit_queue();\n\tprintk(KERN_ERR \"SCSI subsystem failed to initialize, error = %d\\n\",\n\t       -error);\n\treturn error;\n}\n\nstatic void __exit exit_scsi(void)\n{\n\tscsi_netlink_exit();\n\tscsi_sysfs_unregister();\n\tscsi_exit_sysctl();\n\tscsi_exit_hosts();\n\tscsi_exit_devinfo();\n\tscsi_exit_procfs();\n\tscsi_exit_queue();\n}\n\nsubsys_initcall(init_scsi);\nmodule_exit(exit_scsi);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}