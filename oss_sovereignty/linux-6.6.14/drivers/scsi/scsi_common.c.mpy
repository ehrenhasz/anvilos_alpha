{
  "module_name": "scsi_common.c",
  "hash_id": "c13a98e278102276e6c1dfadd087517eab0b6c30cef462fdceef8ab8a4c47531",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_common.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <uapi/linux/pr.h>\n#include <asm/unaligned.h>\n#include <scsi/scsi_common.h>\n\nMODULE_LICENSE(\"GPL v2\");\n\n \nconst unsigned char scsi_command_size_tbl[8] = {\n\t6, 10, 10, 12, 16, 12, 10, 10\n};\nEXPORT_SYMBOL(scsi_command_size_tbl);\n\n \nstatic const char *const scsi_device_types[] = {\n\t\"Direct-Access    \",\n\t\"Sequential-Access\",\n\t\"Printer          \",\n\t\"Processor        \",\n\t\"WORM             \",\n\t\"CD-ROM           \",\n\t\"Scanner          \",\n\t\"Optical Device   \",\n\t\"Medium Changer   \",\n\t\"Communications   \",\n\t\"ASC IT8          \",\n\t\"ASC IT8          \",\n\t\"RAID             \",\n\t\"Enclosure        \",\n\t\"Direct-Access-RBC\",\n\t\"Optical card     \",\n\t\"Bridge controller\",\n\t\"Object storage   \",\n\t\"Automation/Drive \",\n\t\"Security Manager \",\n\t\"Direct-Access-ZBC\",\n};\n\n \nconst char *scsi_device_type(unsigned type)\n{\n\tif (type == 0x1e)\n\t\treturn \"Well-known LUN   \";\n\tif (type == 0x1f)\n\t\treturn \"No Device        \";\n\tif (type >= ARRAY_SIZE(scsi_device_types))\n\t\treturn \"Unknown          \";\n\treturn scsi_device_types[type];\n}\nEXPORT_SYMBOL(scsi_device_type);\n\nenum pr_type scsi_pr_type_to_block(enum scsi_pr_type type)\n{\n\tswitch (type) {\n\tcase SCSI_PR_WRITE_EXCLUSIVE:\n\t\treturn PR_WRITE_EXCLUSIVE;\n\tcase SCSI_PR_EXCLUSIVE_ACCESS:\n\t\treturn PR_EXCLUSIVE_ACCESS;\n\tcase SCSI_PR_WRITE_EXCLUSIVE_REG_ONLY:\n\t\treturn PR_WRITE_EXCLUSIVE_REG_ONLY;\n\tcase SCSI_PR_EXCLUSIVE_ACCESS_REG_ONLY:\n\t\treturn PR_EXCLUSIVE_ACCESS_REG_ONLY;\n\tcase SCSI_PR_WRITE_EXCLUSIVE_ALL_REGS:\n\t\treturn PR_WRITE_EXCLUSIVE_ALL_REGS;\n\tcase SCSI_PR_EXCLUSIVE_ACCESS_ALL_REGS:\n\t\treturn PR_EXCLUSIVE_ACCESS_ALL_REGS;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(scsi_pr_type_to_block);\n\nenum scsi_pr_type block_pr_type_to_scsi(enum pr_type type)\n{\n\tswitch (type) {\n\tcase PR_WRITE_EXCLUSIVE:\n\t\treturn SCSI_PR_WRITE_EXCLUSIVE;\n\tcase PR_EXCLUSIVE_ACCESS:\n\t\treturn SCSI_PR_EXCLUSIVE_ACCESS;\n\tcase PR_WRITE_EXCLUSIVE_REG_ONLY:\n\t\treturn SCSI_PR_WRITE_EXCLUSIVE_REG_ONLY;\n\tcase PR_EXCLUSIVE_ACCESS_REG_ONLY:\n\t\treturn SCSI_PR_EXCLUSIVE_ACCESS_REG_ONLY;\n\tcase PR_WRITE_EXCLUSIVE_ALL_REGS:\n\t\treturn SCSI_PR_WRITE_EXCLUSIVE_ALL_REGS;\n\tcase PR_EXCLUSIVE_ACCESS_ALL_REGS:\n\t\treturn SCSI_PR_EXCLUSIVE_ACCESS_ALL_REGS;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(block_pr_type_to_scsi);\n\n \nu64 scsilun_to_int(struct scsi_lun *scsilun)\n{\n\tint i;\n\tu64 lun;\n\n\tlun = 0;\n\tfor (i = 0; i < sizeof(lun); i += 2)\n\t\tlun = lun | (((u64)scsilun->scsi_lun[i] << ((i + 1) * 8)) |\n\t\t\t     ((u64)scsilun->scsi_lun[i + 1] << (i * 8)));\n\treturn lun;\n}\nEXPORT_SYMBOL(scsilun_to_int);\n\n \nvoid int_to_scsilun(u64 lun, struct scsi_lun *scsilun)\n{\n\tint i;\n\n\tmemset(scsilun->scsi_lun, 0, sizeof(scsilun->scsi_lun));\n\n\tfor (i = 0; i < sizeof(lun); i += 2) {\n\t\tscsilun->scsi_lun[i] = (lun >> 8) & 0xFF;\n\t\tscsilun->scsi_lun[i+1] = lun & 0xFF;\n\t\tlun = lun >> 16;\n\t}\n}\nEXPORT_SYMBOL(int_to_scsilun);\n\n \nbool scsi_normalize_sense(const u8 *sense_buffer, int sb_len,\n\t\t\t  struct scsi_sense_hdr *sshdr)\n{\n\tmemset(sshdr, 0, sizeof(struct scsi_sense_hdr));\n\n\tif (!sense_buffer || !sb_len)\n\t\treturn false;\n\n\tsshdr->response_code = (sense_buffer[0] & 0x7f);\n\n\tif (!scsi_sense_valid(sshdr))\n\t\treturn false;\n\n\tif (sshdr->response_code >= 0x72) {\n\t\t \n\t\tif (sb_len > 1)\n\t\t\tsshdr->sense_key = (sense_buffer[1] & 0xf);\n\t\tif (sb_len > 2)\n\t\t\tsshdr->asc = sense_buffer[2];\n\t\tif (sb_len > 3)\n\t\t\tsshdr->ascq = sense_buffer[3];\n\t\tif (sb_len > 7)\n\t\t\tsshdr->additional_length = sense_buffer[7];\n\t} else {\n\t\t \n\t\tif (sb_len > 2)\n\t\t\tsshdr->sense_key = (sense_buffer[2] & 0xf);\n\t\tif (sb_len > 7) {\n\t\t\tsb_len = min(sb_len, sense_buffer[7] + 8);\n\t\t\tif (sb_len > 12)\n\t\t\t\tsshdr->asc = sense_buffer[12];\n\t\t\tif (sb_len > 13)\n\t\t\t\tsshdr->ascq = sense_buffer[13];\n\t\t}\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(scsi_normalize_sense);\n\n \nconst u8 * scsi_sense_desc_find(const u8 * sense_buffer, int sb_len,\n\t\t\t\tint desc_type)\n{\n\tint add_sen_len, add_len, desc_len, k;\n\tconst u8 * descp;\n\n\tif ((sb_len < 8) || (0 == (add_sen_len = sense_buffer[7])))\n\t\treturn NULL;\n\tif ((sense_buffer[0] < 0x72) || (sense_buffer[0] > 0x73))\n\t\treturn NULL;\n\tadd_sen_len = (add_sen_len < (sb_len - 8)) ?\n\t\t\tadd_sen_len : (sb_len - 8);\n\tdescp = &sense_buffer[8];\n\tfor (desc_len = 0, k = 0; k < add_sen_len; k += desc_len) {\n\t\tdescp += desc_len;\n\t\tadd_len = (k < (add_sen_len - 1)) ? descp[1]: -1;\n\t\tdesc_len = add_len + 2;\n\t\tif (descp[0] == desc_type)\n\t\t\treturn descp;\n\t\tif (add_len < 0) \n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(scsi_sense_desc_find);\n\n \nvoid scsi_build_sense_buffer(int desc, u8 *buf, u8 key, u8 asc, u8 ascq)\n{\n\tif (desc) {\n\t\tbuf[0] = 0x72;\t \n\t\tbuf[1] = key;\n\t\tbuf[2] = asc;\n\t\tbuf[3] = ascq;\n\t\tbuf[7] = 0;\n\t} else {\n\t\tbuf[0] = 0x70;\t \n\t\tbuf[2] = key;\n\t\tbuf[7] = 0xa;\n\t\tbuf[12] = asc;\n\t\tbuf[13] = ascq;\n\t}\n}\nEXPORT_SYMBOL(scsi_build_sense_buffer);\n\n \nint scsi_set_sense_information(u8 *buf, int buf_len, u64 info)\n{\n\tif ((buf[0] & 0x7f) == 0x72) {\n\t\tu8 *ucp, len;\n\n\t\tlen = buf[7];\n\t\tucp = (char *)scsi_sense_desc_find(buf, len + 8, 0);\n\t\tif (!ucp) {\n\t\t\tbuf[7] = len + 0xc;\n\t\t\tucp = buf + 8 + len;\n\t\t}\n\n\t\tif (buf_len < len + 0xc)\n\t\t\t \n\t\t\treturn -EINVAL;\n\n\t\tucp[0] = 0;\n\t\tucp[1] = 0xa;\n\t\tucp[2] = 0x80;  \n\t\tucp[3] = 0;\n\t\tput_unaligned_be64(info, &ucp[4]);\n\t} else if ((buf[0] & 0x7f) == 0x70) {\n\t\t \n\t\tif (info <= 0xffffffffUL)\n\t\t\tbuf[0] |= 0x80;\n\t\telse\n\t\t\tbuf[0] &= 0x7f;\n\t\tput_unaligned_be32((u32)info, &buf[3]);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(scsi_set_sense_information);\n\n \nint scsi_set_sense_field_pointer(u8 *buf, int buf_len, u16 fp, u8 bp, bool cd)\n{\n\tu8 *ucp, len;\n\n\tif ((buf[0] & 0x7f) == 0x72) {\n\t\tlen = buf[7];\n\t\tucp = (char *)scsi_sense_desc_find(buf, len + 8, 2);\n\t\tif (!ucp) {\n\t\t\tbuf[7] = len + 8;\n\t\t\tucp = buf + 8 + len;\n\t\t}\n\n\t\tif (buf_len < len + 8)\n\t\t\t \n\t\t\treturn -EINVAL;\n\n\t\tucp[0] = 2;\n\t\tucp[1] = 6;\n\t\tucp[4] = 0x80;  \n\t\tif (cd)\n\t\t\tucp[4] |= 0x40;\n\t\tif (bp < 0x8)\n\t\t\tucp[4] |= 0x8 | bp;\n\t\tput_unaligned_be16(fp, &ucp[5]);\n\t} else if ((buf[0] & 0x7f) == 0x70) {\n\t\tlen = buf[7];\n\t\tif (len < 18)\n\t\t\tbuf[7] = 18;\n\n\t\tbuf[15] = 0x80;\n\t\tif (cd)\n\t\t\tbuf[15] |= 0x40;\n\t\tif (bp < 0x8)\n\t\t\tbuf[15] |= 0x8 | bp;\n\t\tput_unaligned_be16(fp, &buf[16]);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(scsi_set_sense_field_pointer);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}