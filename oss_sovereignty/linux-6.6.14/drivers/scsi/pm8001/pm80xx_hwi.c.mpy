{
  "module_name": "pm80xx_hwi.c",
  "hash_id": "fd33a3df0d89c1fee8663830128b2b3b6b9de47732df274dd30f1440dd7e2934",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/pm8001/pm80xx_hwi.c",
  "human_readable_source": " \n #include <linux/slab.h>\n #include \"pm8001_sas.h\"\n #include \"pm80xx_hwi.h\"\n #include \"pm8001_chips.h\"\n #include \"pm8001_ctl.h\"\n#include \"pm80xx_tracepoints.h\"\n\n#define SMP_DIRECT 1\n#define SMP_INDIRECT 2\n\n\nint pm80xx_bar4_shift(struct pm8001_hba_info *pm8001_ha, u32 shift_value)\n{\n\tu32 reg_val;\n\tunsigned long start;\n\tpm8001_cw32(pm8001_ha, 0, MEMBASE_II_SHIFT_REGISTER, shift_value);\n\t \n\tstart = jiffies + HZ;  \n\tdo {\n\t\treg_val = pm8001_cr32(pm8001_ha, 0, MEMBASE_II_SHIFT_REGISTER);\n\t} while ((reg_val != shift_value) && time_before(jiffies, start));\n\tif (reg_val != shift_value) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"TIMEOUT:MEMBASE_II_SHIFT_REGISTER = 0x%x\\n\",\n\t\t\t   reg_val);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void pm80xx_pci_mem_copy(struct pm8001_hba_info  *pm8001_ha, u32 soffset,\n\t\t\t\t__le32 *destination,\n\t\t\t\tu32 dw_count, u32 bus_base_number)\n{\n\tu32 index, value, offset;\n\n\tfor (index = 0; index < dw_count; index += 4, destination++) {\n\t\toffset = (soffset + index);\n\t\tif (offset < (64 * 1024)) {\n\t\t\tvalue = pm8001_cr32(pm8001_ha, bus_base_number, offset);\n\t\t\t*destination = cpu_to_le32(value);\n\t\t}\n\t}\n\treturn;\n}\n\nssize_t pm80xx_get_fatal_dump(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tvoid __iomem *fatal_table_address = pm8001_ha->fatal_tbl_addr;\n\tu32 accum_len, reg_val, index, *temp;\n\tu32 status = 1;\n\tunsigned long start;\n\tu8 *direct_data;\n\tchar *fatal_error_data = buf;\n\tu32 length_to_read;\n\tu32 offset;\n\n\tpm8001_ha->forensic_info.data_buf.direct_data = buf;\n\tif (pm8001_ha->chip_id == chip_8001) {\n\t\tpm8001_ha->forensic_info.data_buf.direct_data +=\n\t\t\tsprintf(pm8001_ha->forensic_info.data_buf.direct_data,\n\t\t\t\"Not supported for SPC controller\");\n\t\treturn (char *)pm8001_ha->forensic_info.data_buf.direct_data -\n\t\t\t(char *)buf;\n\t}\n\t \n\tif (pm8001_ha->forensic_info.data_buf.direct_offset == 0) {\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"forensic_info TYPE_NON_FATAL..............\\n\");\n\t\tdirect_data = (u8 *)fatal_error_data;\n\t\tpm8001_ha->forensic_info.data_type = TYPE_NON_FATAL;\n\t\tpm8001_ha->forensic_info.data_buf.direct_len = SYSFS_OFFSET;\n\t\tpm8001_ha->forensic_info.data_buf.direct_offset = 0;\n\t\tpm8001_ha->forensic_info.data_buf.read_len = 0;\n\t\tpm8001_ha->forensic_preserved_accumulated_transfer = 0;\n\n\t\t \n\t\tpm8001_mw32(fatal_table_address,\n\t\t\t\tMPI_FATAL_EDUMP_TABLE_SIGNATURE, 0x1234abcd);\n\n\t\tpm8001_ha->forensic_info.data_buf.direct_data = direct_data;\n\t\tpm8001_dbg(pm8001_ha, IO, \"ossaHwCB: status1 %d\\n\", status);\n\t\tpm8001_dbg(pm8001_ha, IO, \"ossaHwCB: read_len 0x%x\\n\",\n\t\t\t   pm8001_ha->forensic_info.data_buf.read_len);\n\t\tpm8001_dbg(pm8001_ha, IO, \"ossaHwCB: direct_len 0x%x\\n\",\n\t\t\t   pm8001_ha->forensic_info.data_buf.direct_len);\n\t\tpm8001_dbg(pm8001_ha, IO, \"ossaHwCB: direct_offset 0x%x\\n\",\n\t\t\t   pm8001_ha->forensic_info.data_buf.direct_offset);\n\t}\n\tif (pm8001_ha->forensic_info.data_buf.direct_offset == 0) {\n\t\t \n\t\t \n\t\tpm8001_cw32(pm8001_ha, 0, MEMBASE_II_SHIFT_REGISTER,\n\t\t\t\tpm8001_ha->fatal_forensic_shift_offset);\n\t\tpm8001_ha->forensic_last_offset = 0;\n\t\tpm8001_ha->forensic_fatal_step = 0;\n\t\tpm8001_ha->fatal_bar_loc = 0;\n\t}\n\n\t \n\taccum_len = pm8001_mr32(fatal_table_address,\n\t\t\t\tMPI_FATAL_EDUMP_TABLE_ACCUM_LEN);\n\t \n\tlength_to_read =\n\t\taccum_len - pm8001_ha->forensic_preserved_accumulated_transfer;\n\tpm8001_dbg(pm8001_ha, IO, \"get_fatal_spcv: accum_len 0x%x\\n\",\n\t\t   accum_len);\n\tpm8001_dbg(pm8001_ha, IO, \"get_fatal_spcv: length_to_read 0x%x\\n\",\n\t\t   length_to_read);\n\tpm8001_dbg(pm8001_ha, IO, \"get_fatal_spcv: last_offset 0x%x\\n\",\n\t\t   pm8001_ha->forensic_last_offset);\n\tpm8001_dbg(pm8001_ha, IO, \"get_fatal_spcv: read_len 0x%x\\n\",\n\t\t   pm8001_ha->forensic_info.data_buf.read_len);\n\tpm8001_dbg(pm8001_ha, IO, \"get_fatal_spcv:: direct_len 0x%x\\n\",\n\t\t   pm8001_ha->forensic_info.data_buf.direct_len);\n\tpm8001_dbg(pm8001_ha, IO, \"get_fatal_spcv:: direct_offset 0x%x\\n\",\n\t\t   pm8001_ha->forensic_info.data_buf.direct_offset);\n\n\t \n\tif (accum_len == 0xFFFFFFFF) {\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"Possible PCI issue 0x%x not expected\\n\",\n\t\t\t   accum_len);\n\t\treturn status;\n\t}\n\t \n\tif (accum_len == 0) {\n\t\tpm8001_ha->forensic_info.data_buf.direct_data +=\n\t\t\tsprintf(pm8001_ha->forensic_info.data_buf.direct_data,\n\t\t\t\"%08x \", 0xFFFFFFFF);\n\t\treturn (char *)pm8001_ha->forensic_info.data_buf.direct_data -\n\t\t\t(char *)buf;\n\t}\n\t \n\ttemp = (u32 *)pm8001_ha->memoryMap.region[FORENSIC_MEM].virt_ptr;\n\tif (pm8001_ha->forensic_fatal_step == 0) {\nmoreData:\n\t\t \n\t\tif (pm8001_ha->forensic_last_offset + SYSFS_OFFSET\n\t\t\t\t> length_to_read) {\n\t\t\tpm8001_ha->forensic_info.data_buf.direct_len =\n\t\t\t\tlength_to_read -\n\t\t\t\tpm8001_ha->forensic_last_offset;\n\t\t} else {\n\t\t\tpm8001_ha->forensic_info.data_buf.direct_len =\n\t\t\t\tSYSFS_OFFSET;\n\t\t}\n\t\tif (pm8001_ha->forensic_info.data_buf.direct_data) {\n\t\t\t \n\t\t\tpm80xx_pci_mem_copy(pm8001_ha,\n\t\t\tpm8001_ha->fatal_bar_loc,\n\t\t\tpm8001_ha->memoryMap.region[FORENSIC_MEM].virt_ptr,\n\t\t\tpm8001_ha->forensic_info.data_buf.direct_len, 1);\n\t\t}\n\t\tpm8001_ha->fatal_bar_loc +=\n\t\t\tpm8001_ha->forensic_info.data_buf.direct_len;\n\t\tpm8001_ha->forensic_info.data_buf.direct_offset +=\n\t\t\tpm8001_ha->forensic_info.data_buf.direct_len;\n\t\tpm8001_ha->forensic_last_offset\t+=\n\t\t\tpm8001_ha->forensic_info.data_buf.direct_len;\n\t\tpm8001_ha->forensic_info.data_buf.read_len =\n\t\t\tpm8001_ha->forensic_info.data_buf.direct_len;\n\n\t\tif (pm8001_ha->forensic_last_offset  >= length_to_read) {\n\t\t\tpm8001_ha->forensic_info.data_buf.direct_data +=\n\t\t\tsprintf(pm8001_ha->forensic_info.data_buf.direct_data,\n\t\t\t\t\"%08x \", 3);\n\t\t\tfor (index = 0; index <\n\t\t\t\t(pm8001_ha->forensic_info.data_buf.direct_len\n\t\t\t\t / 4); index++) {\n\t\t\t\tpm8001_ha->forensic_info.data_buf.direct_data +=\n\t\t\t\tsprintf(\n\t\t\t\tpm8001_ha->forensic_info.data_buf.direct_data,\n\t\t\t\t\"%08x \", *(temp + index));\n\t\t\t}\n\n\t\t\tpm8001_ha->fatal_bar_loc = 0;\n\t\t\tpm8001_ha->forensic_fatal_step = 1;\n\t\t\tpm8001_ha->fatal_forensic_shift_offset = 0;\n\t\t\tpm8001_ha->forensic_last_offset\t= 0;\n\t\t\tstatus = 0;\n\t\t\toffset = (int)\n\t\t\t((char *)pm8001_ha->forensic_info.data_buf.direct_data\n\t\t\t- (char *)buf);\n\t\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t\t   \"get_fatal_spcv:return1 0x%x\\n\", offset);\n\t\t\treturn (char *)pm8001_ha->\n\t\t\t\tforensic_info.data_buf.direct_data -\n\t\t\t\t(char *)buf;\n\t\t}\n\t\tif (pm8001_ha->fatal_bar_loc < (64 * 1024)) {\n\t\t\tpm8001_ha->forensic_info.data_buf.direct_data +=\n\t\t\t\tsprintf(pm8001_ha->\n\t\t\t\t\tforensic_info.data_buf.direct_data,\n\t\t\t\t\t\"%08x \", 2);\n\t\t\tfor (index = 0; index <\n\t\t\t\t(pm8001_ha->forensic_info.data_buf.direct_len\n\t\t\t\t / 4); index++) {\n\t\t\t\tpm8001_ha->forensic_info.data_buf.direct_data\n\t\t\t\t\t+= sprintf(pm8001_ha->\n\t\t\t\t\tforensic_info.data_buf.direct_data,\n\t\t\t\t\t\"%08x \", *(temp + index));\n\t\t\t}\n\t\t\tstatus = 0;\n\t\t\toffset = (int)\n\t\t\t((char *)pm8001_ha->forensic_info.data_buf.direct_data\n\t\t\t- (char *)buf);\n\t\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t\t   \"get_fatal_spcv:return2 0x%x\\n\", offset);\n\t\t\treturn (char *)pm8001_ha->\n\t\t\t\tforensic_info.data_buf.direct_data -\n\t\t\t\t(char *)buf;\n\t\t}\n\n\t\t \n\t\tpm8001_ha->forensic_info.data_buf.direct_data +=\n\t\t\tsprintf(pm8001_ha->forensic_info.data_buf.direct_data,\n\t\t\t\t\"%08x \", 2);\n\t\tfor (index = 0; index <\n\t\t\t(pm8001_ha->forensic_info.data_buf.direct_len\n\t\t\t / 4) ; index++) {\n\t\t\tpm8001_ha->forensic_info.data_buf.direct_data +=\n\t\t\t\tsprintf(pm8001_ha->\n\t\t\t\tforensic_info.data_buf.direct_data,\n\t\t\t\t\"%08x \", *(temp + index));\n\t\t}\n\t\tpm8001_ha->fatal_forensic_shift_offset += 0x100;\n\t\tpm8001_cw32(pm8001_ha, 0, MEMBASE_II_SHIFT_REGISTER,\n\t\t\tpm8001_ha->fatal_forensic_shift_offset);\n\t\tpm8001_ha->fatal_bar_loc = 0;\n\t\tstatus = 0;\n\t\toffset = (int)\n\t\t\t((char *)pm8001_ha->forensic_info.data_buf.direct_data\n\t\t\t- (char *)buf);\n\t\tpm8001_dbg(pm8001_ha, IO, \"get_fatal_spcv: return3 0x%x\\n\",\n\t\t\t   offset);\n\t\treturn (char *)pm8001_ha->forensic_info.data_buf.direct_data -\n\t\t\t(char *)buf;\n\t}\n\tif (pm8001_ha->forensic_fatal_step == 1) {\n\t\t \n\t\tpm8001_ha->forensic_preserved_accumulated_transfer =\n\t\t\tpm8001_mr32(fatal_table_address,\n\t\t\tMPI_FATAL_EDUMP_TABLE_ACCUM_LEN);\n\n\t\t \n\t\tif (pm8001_mr32(fatal_table_address,\n\t\t\tMPI_FATAL_EDUMP_TABLE_STATUS) <\n\t\t\tMPI_FATAL_EDUMP_TABLE_STAT_NF_SUCCESS_DONE) {\n\n\t\t\t \n\t\t\tpm8001_mw32(fatal_table_address,\n\t\t\t\t\tMPI_FATAL_EDUMP_TABLE_STATUS, 0x0);\n\n\t\t\t \n\t\t\tpm8001_mw32(fatal_table_address,\n\t\t\t\tMPI_FATAL_EDUMP_TABLE_HANDSHAKE,\n\t\t\t\tMPI_FATAL_EDUMP_HANDSHAKE_RDY);\n\n\t\t\t \n\t\t\tstart = jiffies + (2 * HZ);  \n\n\t\t\tdo {\n\t\t\t\treg_val = pm8001_mr32(fatal_table_address,\n\t\t\t\t\tMPI_FATAL_EDUMP_TABLE_HANDSHAKE);\n\t\t\t} while ((reg_val) && time_before(jiffies, start));\n\n\t\t\tif (reg_val != 0) {\n\t\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t\t   \"TIMEOUT:MPI_FATAL_EDUMP_TABLE_HDSHAKE 0x%x\\n\",\n\t\t\t\t\t   reg_val);\n\t\t\t        \n\t\t\t\tpm8001_ha->forensic_info.data_buf.direct_data +=\n\t\t\t\tsprintf(\n\t\t\t\tpm8001_ha->forensic_info.data_buf.direct_data,\n\t\t\t\t\"%08x \", 0xFFFFFFFF);\n\t\t\t\treturn((char *)\n\t\t\t\tpm8001_ha->forensic_info.data_buf.direct_data\n\t\t\t\t- (char *)buf);\n\t\t\t}\n\t\t\t \n\t\t\tstart = jiffies + (2 * HZ);  \n\n\t\t\tdo {\n\t\t\t\treg_val = pm8001_mr32(fatal_table_address,\n\t\t\t\t\tMPI_FATAL_EDUMP_TABLE_STATUS);\n\t\t\t} while (((reg_val != 2) && (reg_val != 3)) &&\n\t\t\t\t\ttime_before(jiffies, start));\n\n\t\t\tif (reg_val < 2) {\n\t\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t\t   \"TIMEOUT:MPI_FATAL_EDUMP_TABLE_STATUS = 0x%x\\n\",\n\t\t\t\t\t   reg_val);\n\t\t\t\t \n\t\t\t\tpm8001_ha->forensic_info.data_buf.direct_data +=\n\t\t\t\tsprintf(\n\t\t\t\tpm8001_ha->forensic_info.data_buf.direct_data,\n\t\t\t\t\"%08x \", 0xFFFFFFFF);\n\t\t\t\treturn((char *)pm8001_ha->forensic_info.data_buf.direct_data -\n\t\t\t\t\t\t(char *)buf);\n\t\t\t}\n\t \n\t\t\tpm8001_ha->fatal_forensic_shift_offset = 0;  \n\t\t\tpm8001_cw32(pm8001_ha, 0,\n\t\t\t\t\tMEMBASE_II_SHIFT_REGISTER,\n\t\t\t\t\tpm8001_ha->fatal_forensic_shift_offset);\n\t\t}\n\t\t \n\t\tlength_to_read = pm8001_mr32(fatal_table_address,\n\t\tMPI_FATAL_EDUMP_TABLE_ACCUM_LEN) -\n\t\tpm8001_ha->forensic_preserved_accumulated_transfer;\n\t\tif (length_to_read != 0x0) {\n\t\t\tpm8001_ha->forensic_fatal_step = 0;\n\t\t\tgoto moreData;\n\t\t} else {\n\t\t\tpm8001_ha->forensic_info.data_buf.direct_data +=\n\t\t\tsprintf(pm8001_ha->forensic_info.data_buf.direct_data,\n\t\t\t\t\"%08x \", 4);\n\t\t\tpm8001_ha->forensic_info.data_buf.read_len = 0xFFFFFFFF;\n\t\t\tpm8001_ha->forensic_info.data_buf.direct_len =  0;\n\t\t\tpm8001_ha->forensic_info.data_buf.direct_offset = 0;\n\t\t\tpm8001_ha->forensic_info.data_buf.read_len = 0;\n\t\t}\n\t}\n\toffset = (int)((char *)pm8001_ha->forensic_info.data_buf.direct_data\n\t\t\t- (char *)buf);\n\tpm8001_dbg(pm8001_ha, IO, \"get_fatal_spcv: return4 0x%x\\n\", offset);\n\treturn ((char *)pm8001_ha->forensic_info.data_buf.direct_data -\n\t\t(char *)buf);\n}\n\n \nssize_t pm80xx_get_non_fatal_dump(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tvoid __iomem *nonfatal_table_address = pm8001_ha->fatal_tbl_addr;\n\tu32 accum_len = 0;\n\tu32 total_len = 0;\n\tu32 reg_val = 0;\n\tu32 *temp = NULL;\n\tu32 index = 0;\n\tu32 output_length;\n\tunsigned long start = 0;\n\tchar *buf_copy = buf;\n\n\ttemp = (u32 *)pm8001_ha->memoryMap.region[FORENSIC_MEM].virt_ptr;\n\tif (++pm8001_ha->non_fatal_count == 1) {\n\t\tif (pm8001_ha->chip_id == chip_8001) {\n\t\t\tsnprintf(pm8001_ha->forensic_info.data_buf.direct_data,\n\t\t\t\tPAGE_SIZE, \"Not supported for SPC controller\");\n\t\t\treturn 0;\n\t\t}\n\t\tpm8001_dbg(pm8001_ha, IO, \"forensic_info TYPE_NON_FATAL...\\n\");\n\t\t \n\t\tpm8001_mw32(nonfatal_table_address,\n\t\tMPI_FATAL_EDUMP_TABLE_LO_OFFSET,\n\t\tpm8001_ha->memoryMap.region[FORENSIC_MEM].phys_addr_lo);\n\n\t\tpm8001_mw32(nonfatal_table_address,\n\t\tMPI_FATAL_EDUMP_TABLE_HI_OFFSET,\n\t\tpm8001_ha->memoryMap.region[FORENSIC_MEM].phys_addr_hi);\n\n\t\tpm8001_mw32(nonfatal_table_address,\n\t\tMPI_FATAL_EDUMP_TABLE_LENGTH, SYSFS_OFFSET);\n\n\t\t \n\t\tpm8001_mw32(nonfatal_table_address,\n\t\tMPI_FATAL_EDUMP_TABLE_HANDSHAKE, MPI_FATAL_EDUMP_HANDSHAKE_RDY);\n\n\t\t \n\t\tpm8001_mw32(nonfatal_table_address,\n\t\t\t\tMPI_FATAL_EDUMP_TABLE_ACCUM_LEN, 0);\n\n\t\t \n\t\tpm8001_ha->forensic_preserved_accumulated_transfer = 0;\n\t\tpm8001_ha->non_fatal_read_length = 0;\n\t}\n\n\ttotal_len = pm8001_mr32(nonfatal_table_address,\n\t\t\tMPI_FATAL_EDUMP_TABLE_TOTAL_LEN);\n\t \n\tpm8001_mw32(nonfatal_table_address, MPI_FATAL_EDUMP_TABLE_STATUS, 0);\n\tpm8001_cw32(pm8001_ha, 0, MSGU_IBDB_SET,\n\t\t\tSPCv_MSGU_CFG_TABLE_NONFATAL_DUMP);\n\n\t \n\tstart = jiffies + (2 * HZ);  \n\tdo {\n\t\treg_val = pm8001_cr32(pm8001_ha, 0, MSGU_IBDB_SET) &\n\t\t\tSPCv_MSGU_CFG_TABLE_NONFATAL_DUMP;\n\t} while ((reg_val != 0) && time_before(jiffies, start));\n\n\t \n\tstart = jiffies + (2 * HZ);  \n\tdo {\n\t\treg_val = pm8001_mr32(nonfatal_table_address,\n\t\t\t\tMPI_FATAL_EDUMP_TABLE_STATUS);\n\t} while ((!reg_val) && time_before(jiffies, start));\n\n\tif ((reg_val == 0x00) ||\n\t\t(reg_val == MPI_FATAL_EDUMP_TABLE_STAT_DMA_FAILED) ||\n\t\t(reg_val > MPI_FATAL_EDUMP_TABLE_STAT_NF_SUCCESS_DONE)) {\n\t\tpm8001_ha->non_fatal_read_length = 0;\n\t\tbuf_copy += snprintf(buf_copy, PAGE_SIZE, \"%08x \", 0xFFFFFFFF);\n\t\tpm8001_ha->non_fatal_count = 0;\n\t\treturn (buf_copy - buf);\n\t} else if (reg_val ==\n\t\t\tMPI_FATAL_EDUMP_TABLE_STAT_NF_SUCCESS_MORE_DATA) {\n\t\tbuf_copy += snprintf(buf_copy, PAGE_SIZE, \"%08x \", 2);\n\t} else if ((reg_val == MPI_FATAL_EDUMP_TABLE_STAT_NF_SUCCESS_DONE) ||\n\t\t(pm8001_ha->non_fatal_read_length >= total_len)) {\n\t\tpm8001_ha->non_fatal_read_length = 0;\n\t\tbuf_copy += snprintf(buf_copy, PAGE_SIZE, \"%08x \", 4);\n\t\tpm8001_ha->non_fatal_count = 0;\n\t}\n\taccum_len = pm8001_mr32(nonfatal_table_address,\n\t\t\tMPI_FATAL_EDUMP_TABLE_ACCUM_LEN);\n\toutput_length = accum_len -\n\t\tpm8001_ha->forensic_preserved_accumulated_transfer;\n\n\tfor (index = 0; index < output_length/4; index++)\n\t\tbuf_copy += snprintf(buf_copy, PAGE_SIZE,\n\t\t\t\t\"%08x \", *(temp+index));\n\n\tpm8001_ha->non_fatal_read_length += output_length;\n\n\t \n\tpm8001_ha->forensic_preserved_accumulated_transfer = accum_len;\n\treturn (buf_copy - buf);\n}\n\n \nstatic void read_main_config_table(struct pm8001_hba_info *pm8001_ha)\n{\n\tvoid __iomem *address = pm8001_ha->main_cfg_tbl_addr;\n\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.signature\t=\n\t\tpm8001_mr32(address, MAIN_SIGNATURE_OFFSET);\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.interface_rev =\n\t\tpm8001_mr32(address, MAIN_INTERFACE_REVISION);\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.firmware_rev\t=\n\t\tpm8001_mr32(address, MAIN_FW_REVISION);\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.max_out_io\t=\n\t\tpm8001_mr32(address, MAIN_MAX_OUTSTANDING_IO_OFFSET);\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.max_sgl\t=\n\t\tpm8001_mr32(address, MAIN_MAX_SGL_OFFSET);\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.ctrl_cap_flag =\n\t\tpm8001_mr32(address, MAIN_CNTRL_CAP_OFFSET);\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.gst_offset\t=\n\t\tpm8001_mr32(address, MAIN_GST_OFFSET);\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.inbound_queue_offset =\n\t\tpm8001_mr32(address, MAIN_IBQ_OFFSET);\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.outbound_queue_offset =\n\t\tpm8001_mr32(address, MAIN_OBQ_OFFSET);\n\n\t \n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.fatal_err_dump_offset0 =\n\t\tpm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP0_OFFSET);\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.fatal_err_dump_length0 =\n\t\tpm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP0_LENGTH);\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.fatal_err_dump_offset1 =\n\t\tpm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP1_OFFSET);\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.fatal_err_dump_length1 =\n\t\tpm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP1_LENGTH);\n\n\t \n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.gpio_led_mapping =\n\t\tpm8001_mr32(address, MAIN_GPIO_LED_FLAGS_OFFSET);\n\n\t \n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.analog_setup_table_offset =\n\t\tpm8001_mr32(address, MAIN_ANALOG_SETUP_OFFSET);\n\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.int_vec_table_offset =\n\t\tpm8001_mr32(address, MAIN_INT_VECTOR_TABLE_OFFSET);\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.phy_attr_table_offset =\n\t\tpm8001_mr32(address, MAIN_SAS_PHY_ATTR_TABLE_OFFSET);\n\t \n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.port_recovery_timer =\n\t\tpm8001_mr32(address, MAIN_PORT_RECOVERY_TIMER);\n\t \n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.ila_version =\n\t\tpm8001_mr32(address, MAIN_MPI_ILA_RELEASE_TYPE);\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.inc_fw_version =\n\t\tpm8001_mr32(address, MAIN_MPI_INACTIVE_FW_VERSION);\n\n\tpm8001_dbg(pm8001_ha, DEV,\n\t\t   \"Main cfg table: sign:%x interface rev:%x fw_rev:%x\\n\",\n\t\t   pm8001_ha->main_cfg_tbl.pm80xx_tbl.signature,\n\t\t   pm8001_ha->main_cfg_tbl.pm80xx_tbl.interface_rev,\n\t\t   pm8001_ha->main_cfg_tbl.pm80xx_tbl.firmware_rev);\n\n\tpm8001_dbg(pm8001_ha, DEV,\n\t\t   \"table offset: gst:%x iq:%x oq:%x int vec:%x phy attr:%x\\n\",\n\t\t   pm8001_ha->main_cfg_tbl.pm80xx_tbl.gst_offset,\n\t\t   pm8001_ha->main_cfg_tbl.pm80xx_tbl.inbound_queue_offset,\n\t\t   pm8001_ha->main_cfg_tbl.pm80xx_tbl.outbound_queue_offset,\n\t\t   pm8001_ha->main_cfg_tbl.pm80xx_tbl.int_vec_table_offset,\n\t\t   pm8001_ha->main_cfg_tbl.pm80xx_tbl.phy_attr_table_offset);\n\n\tpm8001_dbg(pm8001_ha, DEV,\n\t\t   \"Main cfg table; ila rev:%x Inactive fw rev:%x\\n\",\n\t\t   pm8001_ha->main_cfg_tbl.pm80xx_tbl.ila_version,\n\t\t   pm8001_ha->main_cfg_tbl.pm80xx_tbl.inc_fw_version);\n}\n\n \nstatic void read_general_status_table(struct pm8001_hba_info *pm8001_ha)\n{\n\tvoid __iomem *address = pm8001_ha->general_stat_tbl_addr;\n\tpm8001_ha->gs_tbl.pm80xx_tbl.gst_len_mpistate\t=\n\t\t\tpm8001_mr32(address, GST_GSTLEN_MPIS_OFFSET);\n\tpm8001_ha->gs_tbl.pm80xx_tbl.iq_freeze_state0\t=\n\t\t\tpm8001_mr32(address, GST_IQ_FREEZE_STATE0_OFFSET);\n\tpm8001_ha->gs_tbl.pm80xx_tbl.iq_freeze_state1\t=\n\t\t\tpm8001_mr32(address, GST_IQ_FREEZE_STATE1_OFFSET);\n\tpm8001_ha->gs_tbl.pm80xx_tbl.msgu_tcnt\t\t=\n\t\t\tpm8001_mr32(address, GST_MSGUTCNT_OFFSET);\n\tpm8001_ha->gs_tbl.pm80xx_tbl.iop_tcnt\t\t=\n\t\t\tpm8001_mr32(address, GST_IOPTCNT_OFFSET);\n\tpm8001_ha->gs_tbl.pm80xx_tbl.gpio_input_val\t=\n\t\t\tpm8001_mr32(address, GST_GPIO_INPUT_VAL);\n\tpm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[0] =\n\t\t\tpm8001_mr32(address, GST_RERRINFO_OFFSET0);\n\tpm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[1] =\n\t\t\tpm8001_mr32(address, GST_RERRINFO_OFFSET1);\n\tpm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[2] =\n\t\t\tpm8001_mr32(address, GST_RERRINFO_OFFSET2);\n\tpm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[3] =\n\t\t\tpm8001_mr32(address, GST_RERRINFO_OFFSET3);\n\tpm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[4] =\n\t\t\tpm8001_mr32(address, GST_RERRINFO_OFFSET4);\n\tpm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[5] =\n\t\t\tpm8001_mr32(address, GST_RERRINFO_OFFSET5);\n\tpm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[6] =\n\t\t\tpm8001_mr32(address, GST_RERRINFO_OFFSET6);\n\tpm8001_ha->gs_tbl.pm80xx_tbl.recover_err_info[7] =\n\t\t\t pm8001_mr32(address, GST_RERRINFO_OFFSET7);\n}\n \nstatic void read_phy_attr_table(struct pm8001_hba_info *pm8001_ha)\n{\n\tvoid __iomem *address = pm8001_ha->pspa_q_tbl_addr;\n\tpm8001_ha->phy_attr_table.phystart1_16[0] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE0_OFFSET);\n\tpm8001_ha->phy_attr_table.phystart1_16[1] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE1_OFFSET);\n\tpm8001_ha->phy_attr_table.phystart1_16[2] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE2_OFFSET);\n\tpm8001_ha->phy_attr_table.phystart1_16[3] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE3_OFFSET);\n\tpm8001_ha->phy_attr_table.phystart1_16[4] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE4_OFFSET);\n\tpm8001_ha->phy_attr_table.phystart1_16[5] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE5_OFFSET);\n\tpm8001_ha->phy_attr_table.phystart1_16[6] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE6_OFFSET);\n\tpm8001_ha->phy_attr_table.phystart1_16[7] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE7_OFFSET);\n\tpm8001_ha->phy_attr_table.phystart1_16[8] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE8_OFFSET);\n\tpm8001_ha->phy_attr_table.phystart1_16[9] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE9_OFFSET);\n\tpm8001_ha->phy_attr_table.phystart1_16[10] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE10_OFFSET);\n\tpm8001_ha->phy_attr_table.phystart1_16[11] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE11_OFFSET);\n\tpm8001_ha->phy_attr_table.phystart1_16[12] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE12_OFFSET);\n\tpm8001_ha->phy_attr_table.phystart1_16[13] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE13_OFFSET);\n\tpm8001_ha->phy_attr_table.phystart1_16[14] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE14_OFFSET);\n\tpm8001_ha->phy_attr_table.phystart1_16[15] =\n\t\t\tpm8001_mr32(address, PSPA_PHYSTATE15_OFFSET);\n\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[0] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID0_OFFSET);\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[1] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID1_OFFSET);\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[2] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID2_OFFSET);\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[3] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID3_OFFSET);\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[4] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID4_OFFSET);\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[5] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID5_OFFSET);\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[6] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID6_OFFSET);\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[7] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID7_OFFSET);\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[8] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID8_OFFSET);\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[9] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID9_OFFSET);\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[10] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID10_OFFSET);\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[11] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID11_OFFSET);\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[12] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID12_OFFSET);\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[13] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID13_OFFSET);\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[14] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID14_OFFSET);\n\tpm8001_ha->phy_attr_table.outbound_hw_event_pid1_16[15] =\n\t\t\tpm8001_mr32(address, PSPA_OB_HW_EVENT_PID15_OFFSET);\n\n}\n\n \nstatic void read_inbnd_queue_table(struct pm8001_hba_info *pm8001_ha)\n{\n\tint i;\n\tvoid __iomem *address = pm8001_ha->inbnd_q_tbl_addr;\n\tfor (i = 0; i < PM8001_MAX_INB_NUM; i++) {\n\t\tu32 offset = i * 0x20;\n\t\tpm8001_ha->inbnd_q_tbl[i].pi_pci_bar =\n\t\t\tget_pci_bar_index(pm8001_mr32(address,\n\t\t\t\t(offset + IB_PIPCI_BAR)));\n\t\tpm8001_ha->inbnd_q_tbl[i].pi_offset =\n\t\t\tpm8001_mr32(address, (offset + IB_PIPCI_BAR_OFFSET));\n\t}\n}\n\n \nstatic void read_outbnd_queue_table(struct pm8001_hba_info *pm8001_ha)\n{\n\tint i;\n\tvoid __iomem *address = pm8001_ha->outbnd_q_tbl_addr;\n\tfor (i = 0; i < PM8001_MAX_OUTB_NUM; i++) {\n\t\tu32 offset = i * 0x24;\n\t\tpm8001_ha->outbnd_q_tbl[i].ci_pci_bar =\n\t\t\tget_pci_bar_index(pm8001_mr32(address,\n\t\t\t\t(offset + OB_CIPCI_BAR)));\n\t\tpm8001_ha->outbnd_q_tbl[i].ci_offset =\n\t\t\tpm8001_mr32(address, (offset + OB_CIPCI_BAR_OFFSET));\n\t}\n}\n\n \nstatic void init_default_table_values(struct pm8001_hba_info *pm8001_ha)\n{\n\tint i;\n\tu32 offsetib, offsetob;\n\tvoid __iomem *addressib = pm8001_ha->inbnd_q_tbl_addr;\n\tvoid __iomem *addressob = pm8001_ha->outbnd_q_tbl_addr;\n\tu32 ib_offset = pm8001_ha->ib_offset;\n\tu32 ob_offset = pm8001_ha->ob_offset;\n\tu32 ci_offset = pm8001_ha->ci_offset;\n\tu32 pi_offset = pm8001_ha->pi_offset;\n\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.upper_event_log_addr\t\t=\n\t\tpm8001_ha->memoryMap.region[AAP1].phys_addr_hi;\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.lower_event_log_addr\t\t=\n\t\tpm8001_ha->memoryMap.region[AAP1].phys_addr_lo;\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.event_log_size\t\t=\n\t\t\t\t\t\t\tPM8001_EVENT_LOG_SIZE;\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.event_log_severity\t\t= 0x01;\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.upper_pcs_event_log_addr\t=\n\t\tpm8001_ha->memoryMap.region[IOP].phys_addr_hi;\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.lower_pcs_event_log_addr\t=\n\t\tpm8001_ha->memoryMap.region[IOP].phys_addr_lo;\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.pcs_event_log_size\t\t=\n\t\t\t\t\t\t\tPM8001_EVENT_LOG_SIZE;\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.pcs_event_log_severity\t= 0x01;\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.fatal_err_interrupt\t\t= 0x01;\n\n\t \n\tif (pm8001_ha->max_q_num > 32)\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.fatal_err_interrupt |=\n\t\t\t\t\t\t\t1 << 16;\n\t \n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.crc_core_dump = (0x1 << 16);\n\n\tfor (i = 0; i < pm8001_ha->max_q_num; i++) {\n\t\tpm8001_ha->inbnd_q_tbl[i].element_pri_size_cnt\t=\n\t\t\tPM8001_MPI_QUEUE | (pm8001_ha->iomb_size << 16) | (0x00<<30);\n\t\tpm8001_ha->inbnd_q_tbl[i].upper_base_addr\t=\n\t\t\tpm8001_ha->memoryMap.region[ib_offset + i].phys_addr_hi;\n\t\tpm8001_ha->inbnd_q_tbl[i].lower_base_addr\t=\n\t\tpm8001_ha->memoryMap.region[ib_offset + i].phys_addr_lo;\n\t\tpm8001_ha->inbnd_q_tbl[i].base_virt\t\t=\n\t\t  (u8 *)pm8001_ha->memoryMap.region[ib_offset + i].virt_ptr;\n\t\tpm8001_ha->inbnd_q_tbl[i].total_length\t\t=\n\t\t\tpm8001_ha->memoryMap.region[ib_offset + i].total_len;\n\t\tpm8001_ha->inbnd_q_tbl[i].ci_upper_base_addr\t=\n\t\t\tpm8001_ha->memoryMap.region[ci_offset + i].phys_addr_hi;\n\t\tpm8001_ha->inbnd_q_tbl[i].ci_lower_base_addr\t=\n\t\t\tpm8001_ha->memoryMap.region[ci_offset + i].phys_addr_lo;\n\t\tpm8001_ha->inbnd_q_tbl[i].ci_virt\t\t=\n\t\t\tpm8001_ha->memoryMap.region[ci_offset + i].virt_ptr;\n\t\tpm8001_write_32(pm8001_ha->inbnd_q_tbl[i].ci_virt, 0, 0);\n\t\toffsetib = i * 0x20;\n\t\tpm8001_ha->inbnd_q_tbl[i].pi_pci_bar\t\t=\n\t\t\tget_pci_bar_index(pm8001_mr32(addressib,\n\t\t\t\t(offsetib + 0x14)));\n\t\tpm8001_ha->inbnd_q_tbl[i].pi_offset\t\t=\n\t\t\tpm8001_mr32(addressib, (offsetib + 0x18));\n\t\tpm8001_ha->inbnd_q_tbl[i].producer_idx\t\t= 0;\n\t\tpm8001_ha->inbnd_q_tbl[i].consumer_index\t= 0;\n\n\t\tpm8001_dbg(pm8001_ha, DEV,\n\t\t\t   \"IQ %d pi_bar 0x%x pi_offset 0x%x\\n\", i,\n\t\t\t   pm8001_ha->inbnd_q_tbl[i].pi_pci_bar,\n\t\t\t   pm8001_ha->inbnd_q_tbl[i].pi_offset);\n\t}\n\tfor (i = 0; i < pm8001_ha->max_q_num; i++) {\n\t\tpm8001_ha->outbnd_q_tbl[i].element_size_cnt\t=\n\t\t\tPM8001_MPI_QUEUE | (pm8001_ha->iomb_size << 16) | (0x01<<30);\n\t\tpm8001_ha->outbnd_q_tbl[i].upper_base_addr\t=\n\t\t\tpm8001_ha->memoryMap.region[ob_offset + i].phys_addr_hi;\n\t\tpm8001_ha->outbnd_q_tbl[i].lower_base_addr\t=\n\t\t\tpm8001_ha->memoryMap.region[ob_offset + i].phys_addr_lo;\n\t\tpm8001_ha->outbnd_q_tbl[i].base_virt\t\t=\n\t\t  (u8 *)pm8001_ha->memoryMap.region[ob_offset + i].virt_ptr;\n\t\tpm8001_ha->outbnd_q_tbl[i].total_length\t\t=\n\t\t\tpm8001_ha->memoryMap.region[ob_offset + i].total_len;\n\t\tpm8001_ha->outbnd_q_tbl[i].pi_upper_base_addr\t=\n\t\t\tpm8001_ha->memoryMap.region[pi_offset + i].phys_addr_hi;\n\t\tpm8001_ha->outbnd_q_tbl[i].pi_lower_base_addr\t=\n\t\t\tpm8001_ha->memoryMap.region[pi_offset + i].phys_addr_lo;\n\t\t \n\t\tpm8001_ha->outbnd_q_tbl[i].interrup_vec_cnt_delay = (i << 24);\n\t\tpm8001_ha->outbnd_q_tbl[i].pi_virt\t\t=\n\t\t\tpm8001_ha->memoryMap.region[pi_offset + i].virt_ptr;\n\t\tpm8001_write_32(pm8001_ha->outbnd_q_tbl[i].pi_virt, 0, 0);\n\t\toffsetob = i * 0x24;\n\t\tpm8001_ha->outbnd_q_tbl[i].ci_pci_bar\t\t=\n\t\t\tget_pci_bar_index(pm8001_mr32(addressob,\n\t\t\toffsetob + 0x14));\n\t\tpm8001_ha->outbnd_q_tbl[i].ci_offset\t\t=\n\t\t\tpm8001_mr32(addressob, (offsetob + 0x18));\n\t\tpm8001_ha->outbnd_q_tbl[i].consumer_idx\t\t= 0;\n\t\tpm8001_ha->outbnd_q_tbl[i].producer_index\t= 0;\n\n\t\tpm8001_dbg(pm8001_ha, DEV,\n\t\t\t   \"OQ %d ci_bar 0x%x ci_offset 0x%x\\n\", i,\n\t\t\t   pm8001_ha->outbnd_q_tbl[i].ci_pci_bar,\n\t\t\t   pm8001_ha->outbnd_q_tbl[i].ci_offset);\n\t}\n}\n\n \nstatic void update_main_config_table(struct pm8001_hba_info *pm8001_ha)\n{\n\tvoid __iomem *address = pm8001_ha->main_cfg_tbl_addr;\n\tpm8001_mw32(address, MAIN_IQNPPD_HPPD_OFFSET,\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.inbound_q_nppd_hppd);\n\tpm8001_mw32(address, MAIN_EVENT_LOG_ADDR_HI,\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.upper_event_log_addr);\n\tpm8001_mw32(address, MAIN_EVENT_LOG_ADDR_LO,\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.lower_event_log_addr);\n\tpm8001_mw32(address, MAIN_EVENT_LOG_BUFF_SIZE,\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.event_log_size);\n\tpm8001_mw32(address, MAIN_EVENT_LOG_OPTION,\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.event_log_severity);\n\tpm8001_mw32(address, MAIN_PCS_EVENT_LOG_ADDR_HI,\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.upper_pcs_event_log_addr);\n\tpm8001_mw32(address, MAIN_PCS_EVENT_LOG_ADDR_LO,\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.lower_pcs_event_log_addr);\n\tpm8001_mw32(address, MAIN_PCS_EVENT_LOG_BUFF_SIZE,\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.pcs_event_log_size);\n\tpm8001_mw32(address, MAIN_PCS_EVENT_LOG_OPTION,\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.pcs_event_log_severity);\n\t \n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.fatal_err_interrupt |=\n\t\t\t\t\t((pm8001_ha->max_q_num - 1) << 8);\n\tpm8001_mw32(address, MAIN_FATAL_ERROR_INTERRUPT,\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.fatal_err_interrupt);\n\tpm8001_dbg(pm8001_ha, DEV,\n\t\t   \"Updated Fatal error interrupt vector 0x%x\\n\",\n\t\t   pm8001_mr32(address, MAIN_FATAL_ERROR_INTERRUPT));\n\n\tpm8001_mw32(address, MAIN_EVENT_CRC_CHECK,\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.crc_core_dump);\n\n\t \n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.gpio_led_mapping &= 0xCFFFFFFF;\n\t \n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.gpio_led_mapping |= 0x20000000;\n\tpm8001_mw32(address, MAIN_GPIO_LED_FLAGS_OFFSET,\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.gpio_led_mapping);\n\tpm8001_dbg(pm8001_ha, DEV,\n\t\t   \"Programming DW 0x21 in main cfg table with 0x%x\\n\",\n\t\t   pm8001_mr32(address, MAIN_GPIO_LED_FLAGS_OFFSET));\n\n\tpm8001_mw32(address, MAIN_PORT_RECOVERY_TIMER,\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.port_recovery_timer);\n\tpm8001_mw32(address, MAIN_INT_REASSERTION_DELAY,\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.interrupt_reassertion_delay);\n\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.port_recovery_timer &= 0xffff0000;\n\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.port_recovery_timer |=\n\t\t\t\t\t\t\tPORT_RECOVERY_TIMEOUT;\n\tif (pm8001_ha->chip_id == chip_8006) {\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.port_recovery_timer &=\n\t\t\t\t\t0x0000ffff;\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.port_recovery_timer |=\n\t\t\t\t\tCHIP_8006_PORT_RECOVERY_TIMEOUT;\n\t}\n\tpm8001_mw32(address, MAIN_PORT_RECOVERY_TIMER,\n\t\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.port_recovery_timer);\n}\n\n \nstatic void update_inbnd_queue_table(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\t int number)\n{\n\tvoid __iomem *address = pm8001_ha->inbnd_q_tbl_addr;\n\tu16 offset = number * 0x20;\n\tpm8001_mw32(address, offset + IB_PROPERITY_OFFSET,\n\t\tpm8001_ha->inbnd_q_tbl[number].element_pri_size_cnt);\n\tpm8001_mw32(address, offset + IB_BASE_ADDR_HI_OFFSET,\n\t\tpm8001_ha->inbnd_q_tbl[number].upper_base_addr);\n\tpm8001_mw32(address, offset + IB_BASE_ADDR_LO_OFFSET,\n\t\tpm8001_ha->inbnd_q_tbl[number].lower_base_addr);\n\tpm8001_mw32(address, offset + IB_CI_BASE_ADDR_HI_OFFSET,\n\t\tpm8001_ha->inbnd_q_tbl[number].ci_upper_base_addr);\n\tpm8001_mw32(address, offset + IB_CI_BASE_ADDR_LO_OFFSET,\n\t\tpm8001_ha->inbnd_q_tbl[number].ci_lower_base_addr);\n\n\tpm8001_dbg(pm8001_ha, DEV,\n\t\t   \"IQ %d: Element pri size 0x%x\\n\",\n\t\t   number,\n\t\t   pm8001_ha->inbnd_q_tbl[number].element_pri_size_cnt);\n\n\tpm8001_dbg(pm8001_ha, DEV,\n\t\t   \"IQ upr base addr 0x%x IQ lwr base addr 0x%x\\n\",\n\t\t   pm8001_ha->inbnd_q_tbl[number].upper_base_addr,\n\t\t   pm8001_ha->inbnd_q_tbl[number].lower_base_addr);\n\n\tpm8001_dbg(pm8001_ha, DEV,\n\t\t   \"CI upper base addr 0x%x CI lower base addr 0x%x\\n\",\n\t\t   pm8001_ha->inbnd_q_tbl[number].ci_upper_base_addr,\n\t\t   pm8001_ha->inbnd_q_tbl[number].ci_lower_base_addr);\n}\n\n \nstatic void update_outbnd_queue_table(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\t\t int number)\n{\n\tvoid __iomem *address = pm8001_ha->outbnd_q_tbl_addr;\n\tu16 offset = number * 0x24;\n\tpm8001_mw32(address, offset + OB_PROPERITY_OFFSET,\n\t\tpm8001_ha->outbnd_q_tbl[number].element_size_cnt);\n\tpm8001_mw32(address, offset + OB_BASE_ADDR_HI_OFFSET,\n\t\tpm8001_ha->outbnd_q_tbl[number].upper_base_addr);\n\tpm8001_mw32(address, offset + OB_BASE_ADDR_LO_OFFSET,\n\t\tpm8001_ha->outbnd_q_tbl[number].lower_base_addr);\n\tpm8001_mw32(address, offset + OB_PI_BASE_ADDR_HI_OFFSET,\n\t\tpm8001_ha->outbnd_q_tbl[number].pi_upper_base_addr);\n\tpm8001_mw32(address, offset + OB_PI_BASE_ADDR_LO_OFFSET,\n\t\tpm8001_ha->outbnd_q_tbl[number].pi_lower_base_addr);\n\tpm8001_mw32(address, offset + OB_INTERRUPT_COALES_OFFSET,\n\t\tpm8001_ha->outbnd_q_tbl[number].interrup_vec_cnt_delay);\n\n\tpm8001_dbg(pm8001_ha, DEV,\n\t\t   \"OQ %d: Element pri size 0x%x\\n\",\n\t\t   number,\n\t\t   pm8001_ha->outbnd_q_tbl[number].element_size_cnt);\n\n\tpm8001_dbg(pm8001_ha, DEV,\n\t\t   \"OQ upr base addr 0x%x OQ lwr base addr 0x%x\\n\",\n\t\t   pm8001_ha->outbnd_q_tbl[number].upper_base_addr,\n\t\t   pm8001_ha->outbnd_q_tbl[number].lower_base_addr);\n\n\tpm8001_dbg(pm8001_ha, DEV,\n\t\t   \"PI upper base addr 0x%x PI lower base addr 0x%x\\n\",\n\t\t   pm8001_ha->outbnd_q_tbl[number].pi_upper_base_addr,\n\t\t   pm8001_ha->outbnd_q_tbl[number].pi_lower_base_addr);\n}\n\n \nstatic int mpi_init_check(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32 max_wait_count;\n\tu32 value;\n\tu32 gst_len_mpistate;\n\n\t \n\tpm8001_cw32(pm8001_ha, 0, MSGU_IBDB_SET, SPCv_MSGU_CFG_TABLE_UPDATE);\n\t \n\tif (IS_SPCV_12G(pm8001_ha->pdev)) {\n\t\tmax_wait_count = SPCV_DOORBELL_CLEAR_TIMEOUT;\n\t} else {\n\t\tmax_wait_count = SPC_DOORBELL_CLEAR_TIMEOUT;\n\t}\n\tdo {\n\t\tmsleep(FW_READY_INTERVAL);\n\t\tvalue = pm8001_cr32(pm8001_ha, 0, MSGU_IBDB_SET);\n\t\tvalue &= SPCv_MSGU_CFG_TABLE_UPDATE;\n\t} while ((value != 0) && (--max_wait_count));\n\n\tif (!max_wait_count) {\n\t\t \n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"Inb doorbell clear not toggled[value:%x]\\n\",\n\t\t\t   value);\n\t\treturn -EBUSY;\n\t}\n\t \n\tmax_wait_count = 5; \n\tdo {\n\t\tmsleep(FW_READY_INTERVAL);\n\t\tgst_len_mpistate =\n\t\t\tpm8001_mr32(pm8001_ha->general_stat_tbl_addr,\n\t\t\t\t\tGST_GSTLEN_MPIS_OFFSET);\n\t} while ((GST_MPI_STATE_INIT !=\n\t\t(gst_len_mpistate & GST_MPI_STATE_MASK)) && (--max_wait_count));\n\tif (!max_wait_count)\n\t\treturn -EBUSY;\n\n\t \n\tgst_len_mpistate = gst_len_mpistate >> 16;\n\tif (0x0000 != gst_len_mpistate)\n\t\treturn -EBUSY;\n\n\t \n\tmsleep(500);\n\n\treturn 0;\n}\n\n \nstatic int check_fw_ready(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32 value;\n\tu32 max_wait_count;\n\tu32 max_wait_time;\n\tu32 expected_mask;\n\tint ret = 0;\n\n\t \n\tmax_wait_time = max_wait_count = 5;\t \n\tdo {\n\t\tmsleep(FW_READY_INTERVAL);\n\t\tvalue = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\n\t} while ((value == 0xFFFFFFFF) && (--max_wait_count));\n\n\t \n\tif ((pm8001_ha->chip_id != chip_8008) &&\n\t\t\t(pm8001_ha->chip_id != chip_8009)) {\n\t\tmax_wait_time = max_wait_count = 180;    \n\t\texpected_mask = SCRATCH_PAD_ILA_READY |\n\t\t\tSCRATCH_PAD_RAAE_READY |\n\t\t\tSCRATCH_PAD_IOP0_READY |\n\t\t\tSCRATCH_PAD_IOP1_READY;\n\t} else {\n\t\tmax_wait_time = max_wait_count = 170;    \n\t\texpected_mask = SCRATCH_PAD_ILA_READY |\n\t\t\tSCRATCH_PAD_RAAE_READY |\n\t\t\tSCRATCH_PAD_IOP0_READY;\n\t}\n\tdo {\n\t\tmsleep(FW_READY_INTERVAL);\n\t\tvalue = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\n\t} while (((value & expected_mask) !=\n\t\t\t\t expected_mask) && (--max_wait_count));\n\tif (!max_wait_count) {\n\t\tpm8001_dbg(pm8001_ha, INIT,\n\t\t\"At least one FW component failed to load within %d millisec: Scratchpad1: 0x%x\\n\",\n\t\t\tmax_wait_time * FW_READY_INTERVAL, value);\n\t\tret = -1;\n\t} else {\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t\"All FW components ready by %d ms\\n\",\n\t\t\t(max_wait_time - max_wait_count) * FW_READY_INTERVAL);\n\t}\n\treturn ret;\n}\n\nstatic int init_pci_device_addresses(struct pm8001_hba_info *pm8001_ha)\n{\n\tvoid __iomem *base_addr;\n\tu32\tvalue;\n\tu32\toffset;\n\tu32\tpcibar;\n\tu32\tpcilogic;\n\n\tvalue = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_0);\n\n\t \n\toffset = value & 0x03FFFFFF;  \n\n\tpm8001_dbg(pm8001_ha, DEV, \"Scratchpad 0 Offset: 0x%x value 0x%x\\n\",\n\t\t   offset, value);\n\t \n\tpcilogic = (value & 0xFC000000) >> 26;\n\tpcibar = get_pci_bar_index(pcilogic);\n\tpm8001_dbg(pm8001_ha, INIT, \"Scratchpad 0 PCI BAR: %d\\n\", pcibar);\n\n\t \n\tif (offset > pm8001_ha->io_mem[pcibar].memsize) {\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\"Main cfg tbl offset outside %u > %u\\n\",\n\t\t\t\toffset, pm8001_ha->io_mem[pcibar].memsize);\n\t\treturn -EBUSY;\n\t}\n\tpm8001_ha->main_cfg_tbl_addr = base_addr =\n\t\tpm8001_ha->io_mem[pcibar].memvirtaddr + offset;\n\n\t \n\tvalue = pm8001_mr32(pm8001_ha->main_cfg_tbl_addr, 0);\n\tif (memcmp(&value, \"PMCS\", 4) != 0) {\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\"BAD main config signature 0x%x\\n\",\n\t\t\t\tvalue);\n\t\treturn -EBUSY;\n\t}\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t\t\"VALID main config signature 0x%x\\n\", value);\n\tpm8001_ha->general_stat_tbl_addr =\n\t\tbase_addr + (pm8001_cr32(pm8001_ha, pcibar, offset + 0x18) &\n\t\t\t\t\t0xFFFFFF);\n\tpm8001_ha->inbnd_q_tbl_addr =\n\t\tbase_addr + (pm8001_cr32(pm8001_ha, pcibar, offset + 0x1C) &\n\t\t\t\t\t0xFFFFFF);\n\tpm8001_ha->outbnd_q_tbl_addr =\n\t\tbase_addr + (pm8001_cr32(pm8001_ha, pcibar, offset + 0x20) &\n\t\t\t\t\t0xFFFFFF);\n\tpm8001_ha->ivt_tbl_addr =\n\t\tbase_addr + (pm8001_cr32(pm8001_ha, pcibar, offset + 0x8C) &\n\t\t\t\t\t0xFFFFFF);\n\tpm8001_ha->pspa_q_tbl_addr =\n\t\tbase_addr + (pm8001_cr32(pm8001_ha, pcibar, offset + 0x90) &\n\t\t\t\t\t0xFFFFFF);\n\tpm8001_ha->fatal_tbl_addr =\n\t\tbase_addr + (pm8001_cr32(pm8001_ha, pcibar, offset + 0xA0) &\n\t\t\t\t\t0xFFFFFF);\n\n\tpm8001_dbg(pm8001_ha, INIT, \"GST OFFSET 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, pcibar, offset + 0x18));\n\tpm8001_dbg(pm8001_ha, INIT, \"INBND OFFSET 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, pcibar, offset + 0x1C));\n\tpm8001_dbg(pm8001_ha, INIT, \"OBND OFFSET 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, pcibar, offset + 0x20));\n\tpm8001_dbg(pm8001_ha, INIT, \"IVT OFFSET 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, pcibar, offset + 0x8C));\n\tpm8001_dbg(pm8001_ha, INIT, \"PSPA OFFSET 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, pcibar, offset + 0x90));\n\tpm8001_dbg(pm8001_ha, INIT, \"addr - main cfg %p general status %p\\n\",\n\t\t   pm8001_ha->main_cfg_tbl_addr,\n\t\t   pm8001_ha->general_stat_tbl_addr);\n\tpm8001_dbg(pm8001_ha, INIT, \"addr - inbnd %p obnd %p\\n\",\n\t\t   pm8001_ha->inbnd_q_tbl_addr,\n\t\t   pm8001_ha->outbnd_q_tbl_addr);\n\tpm8001_dbg(pm8001_ha, INIT, \"addr - pspa %p ivt %p\\n\",\n\t\t   pm8001_ha->pspa_q_tbl_addr,\n\t\t   pm8001_ha->ivt_tbl_addr);\n\treturn 0;\n}\n\n \nint\npm80xx_set_thermal_config(struct pm8001_hba_info *pm8001_ha)\n{\n\tstruct set_ctrl_cfg_req payload;\n\tint rc;\n\tu32 tag;\n\tu32 opc = OPC_INB_SET_CONTROLLER_CONFIG;\n\tu32 page_code;\n\n\tmemset(&payload, 0, sizeof(struct set_ctrl_cfg_req));\n\trc = pm8001_tag_alloc(pm8001_ha, &tag);\n\tif (rc)\n\t\treturn rc;\n\n\tpayload.tag = cpu_to_le32(tag);\n\n\tif (IS_SPCV_12G(pm8001_ha->pdev))\n\t\tpage_code = THERMAL_PAGE_CODE_7H;\n\telse\n\t\tpage_code = THERMAL_PAGE_CODE_8H;\n\n\tpayload.cfg_pg[0] =\n\t\tcpu_to_le32((THERMAL_LOG_ENABLE << 9) |\n\t\t\t    (THERMAL_ENABLE << 8) | page_code);\n\tpayload.cfg_pg[1] =\n\t\tcpu_to_le32((LTEMPHIL << 24) | (RTEMPHIL << 8));\n\n\tpm8001_dbg(pm8001_ha, DEV,\n\t\t   \"Setting up thermal config. cfg_pg 0 0x%x cfg_pg 1 0x%x\\n\",\n\t\t   payload.cfg_pg[0], payload.cfg_pg[1]);\n\n\trc = pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &payload,\n\t\t\tsizeof(payload), 0);\n\tif (rc)\n\t\tpm8001_tag_free(pm8001_ha, tag);\n\treturn rc;\n\n}\n\n \nstatic int\npm80xx_set_sas_protocol_timer_config(struct pm8001_hba_info *pm8001_ha)\n{\n\tstruct set_ctrl_cfg_req payload;\n\tSASProtocolTimerConfig_t SASConfigPage;\n\tint rc;\n\tu32 tag;\n\tu32 opc = OPC_INB_SET_CONTROLLER_CONFIG;\n\n\tmemset(&payload, 0, sizeof(struct set_ctrl_cfg_req));\n\tmemset(&SASConfigPage, 0, sizeof(SASProtocolTimerConfig_t));\n\n\trc = pm8001_tag_alloc(pm8001_ha, &tag);\n\tif (rc)\n\t\treturn rc;\n\n\tpayload.tag = cpu_to_le32(tag);\n\n\tSASConfigPage.pageCode = cpu_to_le32(SAS_PROTOCOL_TIMER_CONFIG_PAGE);\n\tSASConfigPage.MST_MSI = cpu_to_le32(3 << 15);\n\tSASConfigPage.STP_SSP_MCT_TMO =\n\t\tcpu_to_le32((STP_MCT_TMO << 16) | SSP_MCT_TMO);\n\tSASConfigPage.STP_FRM_TMO =\n\t\tcpu_to_le32((SAS_MAX_OPEN_TIME << 24) |\n\t\t\t    (SMP_MAX_CONN_TIMER << 16) | STP_FRM_TIMER);\n\tSASConfigPage.STP_IDLE_TMO = cpu_to_le32(STP_IDLE_TIME);\n\n\tSASConfigPage.OPNRJT_RTRY_INTVL =\n\t\tcpu_to_le32((SAS_MFD << 16) | SAS_OPNRJT_RTRY_INTVL);\n\tSASConfigPage.Data_Cmd_OPNRJT_RTRY_TMO =\n\t\tcpu_to_le32((SAS_DOPNRJT_RTRY_TMO << 16) | SAS_COPNRJT_RTRY_TMO);\n\tSASConfigPage.Data_Cmd_OPNRJT_RTRY_THR =\n\t\tcpu_to_le32((SAS_DOPNRJT_RTRY_THR << 16) | SAS_COPNRJT_RTRY_THR);\n\tSASConfigPage.MAX_AIP = cpu_to_le32(SAS_MAX_AIP);\n\n\tpm8001_dbg(pm8001_ha, INIT, \"SASConfigPage.pageCode 0x%08x\\n\",\n\t\t   le32_to_cpu(SASConfigPage.pageCode));\n\tpm8001_dbg(pm8001_ha, INIT, \"SASConfigPage.MST_MSI  0x%08x\\n\",\n\t\t   le32_to_cpu(SASConfigPage.MST_MSI));\n\tpm8001_dbg(pm8001_ha, INIT, \"SASConfigPage.STP_SSP_MCT_TMO  0x%08x\\n\",\n\t\t   le32_to_cpu(SASConfigPage.STP_SSP_MCT_TMO));\n\tpm8001_dbg(pm8001_ha, INIT, \"SASConfigPage.STP_FRM_TMO  0x%08x\\n\",\n\t\t   le32_to_cpu(SASConfigPage.STP_FRM_TMO));\n\tpm8001_dbg(pm8001_ha, INIT, \"SASConfigPage.STP_IDLE_TMO  0x%08x\\n\",\n\t\t   le32_to_cpu(SASConfigPage.STP_IDLE_TMO));\n\tpm8001_dbg(pm8001_ha, INIT, \"SASConfigPage.OPNRJT_RTRY_INTVL  0x%08x\\n\",\n\t\t   le32_to_cpu(SASConfigPage.OPNRJT_RTRY_INTVL));\n\tpm8001_dbg(pm8001_ha, INIT, \"SASConfigPage.Data_Cmd_OPNRJT_RTRY_TMO  0x%08x\\n\",\n\t\t   le32_to_cpu(SASConfigPage.Data_Cmd_OPNRJT_RTRY_TMO));\n\tpm8001_dbg(pm8001_ha, INIT, \"SASConfigPage.Data_Cmd_OPNRJT_RTRY_THR  0x%08x\\n\",\n\t\t   le32_to_cpu(SASConfigPage.Data_Cmd_OPNRJT_RTRY_THR));\n\tpm8001_dbg(pm8001_ha, INIT, \"SASConfigPage.MAX_AIP  0x%08x\\n\",\n\t\t   le32_to_cpu(SASConfigPage.MAX_AIP));\n\n\tmemcpy(&payload.cfg_pg, &SASConfigPage,\n\t\t\t sizeof(SASProtocolTimerConfig_t));\n\n\trc = pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &payload,\n\t\t\tsizeof(payload), 0);\n\tif (rc)\n\t\tpm8001_tag_free(pm8001_ha, tag);\n\n\treturn rc;\n}\n\n \nstatic int\npm80xx_get_encrypt_info(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32 scratch3_value;\n\tint ret = -1;\n\n\t \n\tscratch3_value = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_3);\n\n\tif ((scratch3_value & SCRATCH_PAD3_ENC_MASK) ==\n\t\t\t\t\tSCRATCH_PAD3_ENC_READY) {\n\t\tif (scratch3_value & SCRATCH_PAD3_XTS_ENABLED)\n\t\t\tpm8001_ha->encrypt_info.cipher_mode = CIPHER_MODE_XTS;\n\t\tif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\n\t\t\t\t\t\tSCRATCH_PAD3_SMF_ENABLED)\n\t\t\tpm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMF;\n\t\tif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\n\t\t\t\t\t\tSCRATCH_PAD3_SMA_ENABLED)\n\t\t\tpm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMA;\n\t\tif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\n\t\t\t\t\t\tSCRATCH_PAD3_SMB_ENABLED)\n\t\t\tpm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMB;\n\t\tpm8001_ha->encrypt_info.status = 0;\n\t\tpm8001_dbg(pm8001_ha, INIT,\n\t\t\t   \"Encryption: SCRATCH_PAD3_ENC_READY 0x%08X.Cipher mode 0x%x Sec mode 0x%x status 0x%x\\n\",\n\t\t\t   scratch3_value,\n\t\t\t   pm8001_ha->encrypt_info.cipher_mode,\n\t\t\t   pm8001_ha->encrypt_info.sec_mode,\n\t\t\t   pm8001_ha->encrypt_info.status);\n\t\tret = 0;\n\t} else if ((scratch3_value & SCRATCH_PAD3_ENC_READY) ==\n\t\t\t\t\tSCRATCH_PAD3_ENC_DISABLED) {\n\t\tpm8001_dbg(pm8001_ha, INIT,\n\t\t\t   \"Encryption: SCRATCH_PAD3_ENC_DISABLED 0x%08X\\n\",\n\t\t\t   scratch3_value);\n\t\tpm8001_ha->encrypt_info.status = 0xFFFFFFFF;\n\t\tpm8001_ha->encrypt_info.cipher_mode = 0;\n\t\tpm8001_ha->encrypt_info.sec_mode = 0;\n\t\tret = 0;\n\t} else if ((scratch3_value & SCRATCH_PAD3_ENC_MASK) ==\n\t\t\t\tSCRATCH_PAD3_ENC_DIS_ERR) {\n\t\tpm8001_ha->encrypt_info.status =\n\t\t\t(scratch3_value & SCRATCH_PAD3_ERR_CODE) >> 16;\n\t\tif (scratch3_value & SCRATCH_PAD3_XTS_ENABLED)\n\t\t\tpm8001_ha->encrypt_info.cipher_mode = CIPHER_MODE_XTS;\n\t\tif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\n\t\t\t\t\tSCRATCH_PAD3_SMF_ENABLED)\n\t\t\tpm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMF;\n\t\tif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\n\t\t\t\t\tSCRATCH_PAD3_SMA_ENABLED)\n\t\t\tpm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMA;\n\t\tif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\n\t\t\t\t\tSCRATCH_PAD3_SMB_ENABLED)\n\t\t\tpm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMB;\n\t\tpm8001_dbg(pm8001_ha, INIT,\n\t\t\t   \"Encryption: SCRATCH_PAD3_DIS_ERR 0x%08X.Cipher mode 0x%x sec mode 0x%x status 0x%x\\n\",\n\t\t\t   scratch3_value,\n\t\t\t   pm8001_ha->encrypt_info.cipher_mode,\n\t\t\t   pm8001_ha->encrypt_info.sec_mode,\n\t\t\t   pm8001_ha->encrypt_info.status);\n\t} else if ((scratch3_value & SCRATCH_PAD3_ENC_MASK) ==\n\t\t\t\t SCRATCH_PAD3_ENC_ENA_ERR) {\n\n\t\tpm8001_ha->encrypt_info.status =\n\t\t\t(scratch3_value & SCRATCH_PAD3_ERR_CODE) >> 16;\n\t\tif (scratch3_value & SCRATCH_PAD3_XTS_ENABLED)\n\t\t\tpm8001_ha->encrypt_info.cipher_mode = CIPHER_MODE_XTS;\n\t\tif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\n\t\t\t\t\tSCRATCH_PAD3_SMF_ENABLED)\n\t\t\tpm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMF;\n\t\tif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\n\t\t\t\t\tSCRATCH_PAD3_SMA_ENABLED)\n\t\t\tpm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMA;\n\t\tif ((scratch3_value & SCRATCH_PAD3_SM_MASK) ==\n\t\t\t\t\tSCRATCH_PAD3_SMB_ENABLED)\n\t\t\tpm8001_ha->encrypt_info.sec_mode = SEC_MODE_SMB;\n\n\t\tpm8001_dbg(pm8001_ha, INIT,\n\t\t\t   \"Encryption: SCRATCH_PAD3_ENA_ERR 0x%08X.Cipher mode 0x%x sec mode 0x%x status 0x%x\\n\",\n\t\t\t   scratch3_value,\n\t\t\t   pm8001_ha->encrypt_info.cipher_mode,\n\t\t\t   pm8001_ha->encrypt_info.sec_mode,\n\t\t\t   pm8001_ha->encrypt_info.status);\n\t}\n\treturn ret;\n}\n\n \nstatic int pm80xx_encrypt_update(struct pm8001_hba_info *pm8001_ha)\n{\n\tstruct kek_mgmt_req payload;\n\tint rc;\n\tu32 tag;\n\tu32 opc = OPC_INB_KEK_MANAGEMENT;\n\n\tmemset(&payload, 0, sizeof(struct kek_mgmt_req));\n\trc = pm8001_tag_alloc(pm8001_ha, &tag);\n\tif (rc)\n\t\treturn rc;\n\n\tpayload.tag = cpu_to_le32(tag);\n\t \n\tpayload.new_curidx_ksop =\n\t\tcpu_to_le32(((1 << 24) | (1 << 16) | (1 << 8) |\n\t\t\t     KEK_MGMT_SUBOP_KEYCARDUPDATE));\n\n\tpm8001_dbg(pm8001_ha, DEV,\n\t\t   \"Saving Encryption info to flash. payload 0x%x\\n\",\n\t\t   le32_to_cpu(payload.new_curidx_ksop));\n\n\trc = pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &payload,\n\t\t\tsizeof(payload), 0);\n\tif (rc)\n\t\tpm8001_tag_free(pm8001_ha, tag);\n\n\treturn rc;\n}\n\n \nstatic int pm80xx_chip_init(struct pm8001_hba_info *pm8001_ha)\n{\n\tint ret;\n\tu8 i = 0;\n\n\t \n\tif (-1 == check_fw_ready(pm8001_ha)) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"Firmware is not ready!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tpm8001_ha->controller_fatal_error = false;\n\n\t \n\tret = init_pci_device_addresses(pm8001_ha);\n\tif (ret) {\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\"Failed to init pci addresses\");\n\t\treturn ret;\n\t}\n\tinit_default_table_values(pm8001_ha);\n\tread_main_config_table(pm8001_ha);\n\tread_general_status_table(pm8001_ha);\n\tread_inbnd_queue_table(pm8001_ha);\n\tread_outbnd_queue_table(pm8001_ha);\n\tread_phy_attr_table(pm8001_ha);\n\n\t \n\tupdate_main_config_table(pm8001_ha);\n\tfor (i = 0; i < pm8001_ha->max_q_num; i++) {\n\t\tupdate_inbnd_queue_table(pm8001_ha, i);\n\t\tupdate_outbnd_queue_table(pm8001_ha, i);\n\t}\n\t \n\tif (0 == mpi_init_check(pm8001_ha)) {\n\t\tpm8001_dbg(pm8001_ha, INIT, \"MPI initialize successful!\\n\");\n\t} else\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic void pm80xx_chip_post_init(struct pm8001_hba_info *pm8001_ha)\n{\n\t \n\tpm80xx_set_sas_protocol_timer_config(pm8001_ha);\n\n\t \n\tif (pm8001_ha->chip->encrypt) {\n\t\tint ret;\n\n\t\tpm8001_dbg(pm8001_ha, INIT, \"Checking for encryption\\n\");\n\t\tret = pm80xx_get_encrypt_info(pm8001_ha);\n\t\tif (ret == -1) {\n\t\t\tpm8001_dbg(pm8001_ha, INIT, \"Encryption error !!\\n\");\n\t\t\tif (pm8001_ha->encrypt_info.status == 0x81) {\n\t\t\t\tpm8001_dbg(pm8001_ha, INIT,\n\t\t\t\t\t   \"Encryption enabled with error.Saving encryption key to flash\\n\");\n\t\t\t\tpm80xx_encrypt_update(pm8001_ha);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int mpi_uninit_check(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32 max_wait_count;\n\tu32 value;\n\tu32 gst_len_mpistate;\n\tint ret;\n\n\tret = init_pci_device_addresses(pm8001_ha);\n\tif (ret) {\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\"Failed to init pci addresses\");\n\t\treturn ret;\n\t}\n\n\t \n\tpm8001_cw32(pm8001_ha, 0, MSGU_IBDB_SET, SPCv_MSGU_CFG_TABLE_RESET);\n\n\t \n\tif (IS_SPCV_12G(pm8001_ha->pdev)) {\n\t\tmax_wait_count = SPCV_DOORBELL_CLEAR_TIMEOUT;\n\t} else {\n\t\tmax_wait_count = SPC_DOORBELL_CLEAR_TIMEOUT;\n\t}\n\tdo {\n\t\tmsleep(FW_READY_INTERVAL);\n\t\tvalue = pm8001_cr32(pm8001_ha, 0, MSGU_IBDB_SET);\n\t\tvalue &= SPCv_MSGU_CFG_TABLE_RESET;\n\t} while ((value != 0) && (--max_wait_count));\n\n\tif (!max_wait_count) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"TIMEOUT:IBDB value/=%x\\n\", value);\n\t\treturn -1;\n\t}\n\n\t \n\t \n\tmax_wait_count = 100;  \n\tdo {\n\t\tmsleep(FW_READY_INTERVAL);\n\t\tgst_len_mpistate =\n\t\t\tpm8001_mr32(pm8001_ha->general_stat_tbl_addr,\n\t\t\tGST_GSTLEN_MPIS_OFFSET);\n\t\tif (GST_MPI_STATE_UNINIT ==\n\t\t\t(gst_len_mpistate & GST_MPI_STATE_MASK))\n\t\t\tbreak;\n\t} while (--max_wait_count);\n\tif (!max_wait_count) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \" TIME OUT MPI State = 0x%x\\n\",\n\t\t\t   gst_len_mpistate & GST_MPI_STATE_MASK);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nint\npm80xx_fatal_errors(struct pm8001_hba_info *pm8001_ha)\n{\n\tint ret = 0;\n\tu32 scratch_pad_rsvd0 = pm8001_cr32(pm8001_ha, 0,\n\t\t\t\t\t    MSGU_SCRATCH_PAD_RSVD_0);\n\tu32 scratch_pad_rsvd1 = pm8001_cr32(pm8001_ha, 0,\n\t\t\t\t\t    MSGU_SCRATCH_PAD_RSVD_1);\n\tu32 scratch_pad1 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\n\tu32 scratch_pad2 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_2);\n\tu32 scratch_pad3 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_3);\n\n\tif (pm8001_ha->chip_id != chip_8006 &&\n\t\t\tpm8001_ha->chip_id != chip_8074 &&\n\t\t\tpm8001_ha->chip_id != chip_8076) {\n\t\treturn 0;\n\t}\n\n\tif (MSGU_SCRATCHPAD1_STATE_FATAL_ERROR(scratch_pad1)) {\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\"Fatal error SCRATCHPAD1 = 0x%x SCRATCHPAD2 = 0x%x SCRATCHPAD3 = 0x%x SCRATCHPAD_RSVD0 = 0x%x SCRATCHPAD_RSVD1 = 0x%x\\n\",\n\t\t\t\tscratch_pad1, scratch_pad2, scratch_pad3,\n\t\t\t\tscratch_pad_rsvd0, scratch_pad_rsvd1);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic int\npm80xx_chip_soft_rst(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32 regval;\n\tu32 bootloader_state;\n\tu32 ibutton0, ibutton1;\n\n\t \n\tif (!pm8001_ha->controller_fatal_error) {\n\t\t \n\t\tif (mpi_uninit_check(pm8001_ha) != 0) {\n\t\t\tu32 r0 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_0);\n\t\t\tu32 r1 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\n\t\t\tu32 r2 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_2);\n\t\t\tu32 r3 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_3);\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"MPI state is not ready scratch: %x:%x:%x:%x\\n\",\n\t\t\t\t   r0, r1, r2, r3);\n\t\t\t \n\t\t\tif (r1 & SCRATCH_PAD1_BOOTSTATE_MASK)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\t \n\tregval = pm8001_cr32(pm8001_ha, 0, SPC_REG_SOFT_RESET);\n\tpm8001_dbg(pm8001_ha, INIT, \"reset register before write : 0x%x\\n\",\n\t\t   regval);\n\n\tpm8001_cw32(pm8001_ha, 0, SPC_REG_SOFT_RESET, SPCv_NORMAL_RESET_VALUE);\n\tmsleep(500);\n\n\tregval = pm8001_cr32(pm8001_ha, 0, SPC_REG_SOFT_RESET);\n\tpm8001_dbg(pm8001_ha, INIT, \"reset register after write 0x%x\\n\",\n\t\t   regval);\n\n\tif ((regval & SPCv_SOFT_RESET_READ_MASK) ==\n\t\t\tSPCv_SOFT_RESET_NORMAL_RESET_OCCURED) {\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \" soft reset successful [regval: 0x%x]\\n\",\n\t\t\t   regval);\n\t} else {\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \" soft reset failed [regval: 0x%x]\\n\",\n\t\t\t   regval);\n\n\t\t \n\t\tbootloader_state =\n\t\t\tpm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1) &\n\t\t\tSCRATCH_PAD1_BOOTSTATE_MASK;\n\n\t\tif (bootloader_state == SCRATCH_PAD1_BOOTSTATE_HDA_SEEPROM) {\n\t\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t\t   \"Bootloader state - HDA mode SEEPROM\\n\");\n\t\t} else if (bootloader_state ==\n\t\t\t\tSCRATCH_PAD1_BOOTSTATE_HDA_BOOTSTRAP) {\n\t\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t\t   \"Bootloader state - HDA mode Bootstrap Pin\\n\");\n\t\t} else if (bootloader_state ==\n\t\t\t\tSCRATCH_PAD1_BOOTSTATE_HDA_SOFTRESET) {\n\t\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t\t   \"Bootloader state - HDA mode soft reset\\n\");\n\t\t} else if (bootloader_state ==\n\t\t\t\t\tSCRATCH_PAD1_BOOTSTATE_CRIT_ERROR) {\n\t\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t\t   \"Bootloader state-HDA mode critical error\\n\");\n\t\t}\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (-1 == check_fw_ready(pm8001_ha)) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"Firmware is not ready!\\n\");\n\t\t \n\t\tif (pm8001_ha->pdev->subsystem_vendor !=\n\t\t\tPCI_VENDOR_ID_ADAPTEC2 &&\n\t\t\tpm8001_ha->pdev->subsystem_vendor !=\n\t\t\tPCI_VENDOR_ID_ATTO &&\n\t\t\tpm8001_ha->pdev->subsystem_vendor != 0) {\n\t\t\tibutton0 = pm8001_cr32(pm8001_ha, 0,\n\t\t\t\t\t       MSGU_SCRATCH_PAD_RSVD_0);\n\t\t\tibutton1 = pm8001_cr32(pm8001_ha, 0,\n\t\t\t\t\t       MSGU_SCRATCH_PAD_RSVD_1);\n\t\t\tif (!ibutton0 && !ibutton1) {\n\t\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t\t   \"iButton Feature is not Available!!!\\n\");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tif (ibutton0 == 0xdeadbeef && ibutton1 == 0xdeadbeef) {\n\t\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t\t   \"CRC Check for iButton Feature Failed!!!\\n\");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\tpm8001_dbg(pm8001_ha, INIT, \"SPCv soft reset Complete\\n\");\n\treturn 0;\n}\n\nstatic void pm80xx_hw_chip_rst(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32 i;\n\n\tpm8001_dbg(pm8001_ha, INIT, \"chip reset start\\n\");\n\n\t \n\tpm8001_cw32(pm8001_ha, 0, SPC_REG_SOFT_RESET, 0x11);\n\tpm8001_dbg(pm8001_ha, INIT, \"SPC soft reset Complete\\n\");\n\n\t \n\t \n\tudelay(10);\n\n\t \n\ti = 20;\n\tdo {\n\t\tmdelay(1);\n\t} while ((--i) != 0);\n\n\tpm8001_dbg(pm8001_ha, INIT, \"chip reset finished\\n\");\n}\n\n \nstatic void\npm80xx_chip_intx_interrupt_enable(struct pm8001_hba_info *pm8001_ha)\n{\n\tpm8001_cw32(pm8001_ha, 0, MSGU_ODMR, ODMR_CLEAR_ALL);\n\tpm8001_cw32(pm8001_ha, 0, MSGU_ODCR, ODCR_CLEAR_ALL);\n}\n\n \nstatic void\npm80xx_chip_intx_interrupt_disable(struct pm8001_hba_info *pm8001_ha)\n{\n\tpm8001_cw32(pm8001_ha, 0, MSGU_ODMR_CLR, ODMR_MASK_ALL);\n}\n\n \nstatic void\npm80xx_chip_interrupt_enable(struct pm8001_hba_info *pm8001_ha, u8 vec)\n{\n#ifdef PM8001_USE_MSIX\n\tif (vec < 32)\n\t\tpm8001_cw32(pm8001_ha, 0, MSGU_ODMR_CLR, 1U << vec);\n\telse\n\t\tpm8001_cw32(pm8001_ha, 0, MSGU_ODMR_CLR_U,\n\t\t\t    1U << (vec - 32));\n\treturn;\n#endif\n\tpm80xx_chip_intx_interrupt_enable(pm8001_ha);\n\n}\n\n \nstatic void\npm80xx_chip_interrupt_disable(struct pm8001_hba_info *pm8001_ha, u8 vec)\n{\n#ifdef PM8001_USE_MSIX\n\tif (vec == 0xFF) {\n\t\t \n\t\tpm8001_cw32(pm8001_ha, 0, MSGU_ODMR, 0xFFFFFFFF);\n\t\tpm8001_cw32(pm8001_ha, 0, MSGU_ODMR_U, 0xFFFFFFFF);\n\t} else if (vec < 32)\n\t\tpm8001_cw32(pm8001_ha, 0, MSGU_ODMR, 1U << vec);\n\telse\n\t\tpm8001_cw32(pm8001_ha, 0, MSGU_ODMR_U,\n\t\t\t    1U << (vec - 32));\n\treturn;\n#endif\n\tpm80xx_chip_intx_interrupt_disable(pm8001_ha);\n}\n\n \nstatic void\nmpi_ssp_completion(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct sas_task *t;\n\tstruct pm8001_ccb_info *ccb;\n\tunsigned long flags;\n\tu32 status;\n\tu32 param;\n\tu32 tag;\n\tstruct ssp_completion_resp *psspPayload;\n\tstruct task_status_struct *ts;\n\tstruct ssp_response_iu *iu;\n\tstruct pm8001_device *pm8001_dev;\n\tpsspPayload = (struct ssp_completion_resp *)(piomb + 4);\n\tstatus = le32_to_cpu(psspPayload->status);\n\ttag = le32_to_cpu(psspPayload->tag);\n\tccb = &pm8001_ha->ccb_info[tag];\n\tif ((status == IO_ABORTED) && ccb->open_retry) {\n\t\t \n\t\tccb->open_retry = 0;\n\t\treturn;\n\t}\n\tpm8001_dev = ccb->device;\n\tparam = le32_to_cpu(psspPayload->param);\n\tt = ccb->task;\n\n\tif (status && status != IO_UNDERFLOW)\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"sas IO status 0x%x\\n\", status);\n\tif (unlikely(!t || !t->lldd_task || !t->dev))\n\t\treturn;\n\tts = &t->task_status;\n\n\tpm8001_dbg(pm8001_ha, DEV,\n\t\t   \"tag::0x%x, status::0x%x task::0x%p\\n\", tag, status, t);\n\n\t \n\tif ((status != IO_SUCCESS) && (status != IO_OVERFLOW) &&\n\t\t(status != IO_UNDERFLOW))\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"SAS Address of IO Failure Drive:%016llx\\n\",\n\t\t\t   SAS_ADDR(t->dev->sas_addr));\n\n\tswitch (status) {\n\tcase IO_SUCCESS:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_SUCCESS ,param = 0x%x\\n\",\n\t\t\t   param);\n\t\tif (param == 0) {\n\t\t\tts->resp = SAS_TASK_COMPLETE;\n\t\t\tts->stat = SAS_SAM_STAT_GOOD;\n\t\t} else {\n\t\t\tts->resp = SAS_TASK_COMPLETE;\n\t\t\tts->stat = SAS_PROTO_RESPONSE;\n\t\t\tts->residual = param;\n\t\t\tiu = &psspPayload->ssp_resp_iu;\n\t\t\tsas_ssp_task_response(pm8001_ha->dev, t, iu);\n\t\t}\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_ABORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_ABORTED IOMB Tag\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_ABORTED_TASK;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_UNDERFLOW:\n\t\t \n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_UNDERFLOW ,param = 0x%x\\n\",\n\t\t\t   param);\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_UNDERRUN;\n\t\tts->residual = param;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_NO_DEVICE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_NO_DEVICE\\n\");\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_PHY_DOWN;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\t \n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_PHY_NOT_READY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_PHY_NOT_READY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_INVALID_SSP_RSP_FRAME:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_XFER_ERROR_INVALID_SSP_RSP_FRAME\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_EPROTO;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_ZONE_VIOLATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\n\tcase IO_XFER_OPEN_RETRY_BACKOFF_THRESHOLD_REACHED:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_TMO:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_NO_DEST:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_COLLIDE:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_PATHWAY_BLOCKED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tif (!t->uldd_task)\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_BAD_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_BAD_DEST;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_CONN_RATE;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_WRONG_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_WRONG_DEST;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_NAK_RECEIVED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_NAK_RECEIVED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_ACK_NAK_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_ACK_NAK_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_NAK_R_ERR;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_DMA:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_DMA\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_OPEN_RETRY_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_OPEN_RETRY_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_OFFSET_MISMATCH:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_OFFSET_MISMATCH\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_PORT_IN_RESET:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_PORT_IN_RESET\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_DS_NON_OPERATIONAL:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_DS_NON_OPERATIONAL\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tif (!t->uldd_task)\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_DS_NON_OPERATIONAL);\n\t\tbreak;\n\tcase IO_DS_IN_RECOVERY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_DS_IN_RECOVERY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_TM_TAG_NOT_FOUND:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_TM_TAG_NOT_FOUND\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_SSP_EXT_IU_ZERO_LEN_ERROR:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_SSP_EXT_IU_ZERO_LEN_ERROR\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO, \"Unknown status 0x%x\\n\", status);\n\t\t \n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\t}\n\tpm8001_dbg(pm8001_ha, IO, \"scsi_status = 0x%x\\n \",\n\t\t   psspPayload->ssp_resp_iu.status);\n\tspin_lock_irqsave(&t->task_state_lock, flags);\n\tt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\tt->task_state_flags |= SAS_TASK_STATE_DONE;\n\tif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"task 0x%p done with io_status 0x%x resp 0x%x stat 0x%x but aborted by upper layer!\\n\",\n\t\t\t   t, status, ts->resp, ts->stat);\n\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t\tif (t->slow_task)\n\t\t\tcomplete(&t->slow_task->completion);\n\t} else {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tpm8001_ccb_task_free_done(pm8001_ha, ccb);\n\t}\n}\n\n \nstatic void mpi_ssp_event(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct sas_task *t;\n\tunsigned long flags;\n\tstruct task_status_struct *ts;\n\tstruct pm8001_ccb_info *ccb;\n\tstruct pm8001_device *pm8001_dev;\n\tstruct ssp_event_resp *psspPayload =\n\t\t(struct ssp_event_resp *)(piomb + 4);\n\tu32 event = le32_to_cpu(psspPayload->event);\n\tu32 tag = le32_to_cpu(psspPayload->tag);\n\tu32 port_id = le32_to_cpu(psspPayload->port_id);\n\n\tccb = &pm8001_ha->ccb_info[tag];\n\tt = ccb->task;\n\tpm8001_dev = ccb->device;\n\tif (event)\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"sas IO status 0x%x\\n\", event);\n\tif (unlikely(!t || !t->lldd_task || !t->dev))\n\t\treturn;\n\tts = &t->task_status;\n\tpm8001_dbg(pm8001_ha, IOERR, \"port_id:0x%x, tag:0x%x, event:0x%x\\n\",\n\t\t   port_id, tag, event);\n\tswitch (event) {\n\tcase IO_OVERFLOW:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_UNDERFLOW\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tts->residual = 0;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_BREAK\\n\");\n\t\tpm8001_handle_event(pm8001_ha, t, IO_XFER_ERROR_BREAK);\n\t\treturn;\n\tcase IO_XFER_ERROR_PHY_NOT_READY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_PHY_NOT_READY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_EPROTO;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_ZONE_VIOLATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\n\tcase IO_XFER_OPEN_RETRY_BACKOFF_THRESHOLD_REACHED:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_TMO:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_NO_DEST:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_COLLIDE:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_PATHWAY_BLOCKED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tif (!t->uldd_task)\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_BAD_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_BAD_DEST;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_CONN_RATE;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_WRONG_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_WRONG_DEST;\n\t\tbreak;\n\tcase IO_XFER_ERROR_NAK_RECEIVED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_NAK_RECEIVED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_XFER_ERROR_ACK_NAK_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_ACK_NAK_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_NAK_R_ERR;\n\t\tbreak;\n\tcase IO_XFER_OPEN_RETRY_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_OPEN_RETRY_TIMEOUT\\n\");\n\t\tpm8001_handle_event(pm8001_ha, t, IO_XFER_OPEN_RETRY_TIMEOUT);\n\t\treturn;\n\tcase IO_XFER_ERROR_UNEXPECTED_PHASE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_UNEXPECTED_PHASE\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tbreak;\n\tcase IO_XFER_ERROR_XFER_RDY_OVERRUN:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_XFER_RDY_OVERRUN\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tbreak;\n\tcase IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tbreak;\n\tcase IO_XFER_ERROR_CMD_ISSUE_ACK_NAK_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_XFER_ERROR_CMD_ISSUE_ACK_NAK_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tbreak;\n\tcase IO_XFER_ERROR_OFFSET_MISMATCH:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_OFFSET_MISMATCH\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tbreak;\n\tcase IO_XFER_ERROR_XFER_ZERO_DATA_LEN:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_XFER_ERROR_XFER_ZERO_DATA_LEN\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tbreak;\n\tcase IO_XFER_ERROR_INTERNAL_CRC_ERROR:\n\t\tpm8001_dbg(pm8001_ha, IOERR,\n\t\t\t   \"IO_XFR_ERROR_INTERNAL_CRC_ERROR\\n\");\n\t\t \n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tbreak;\n\tcase IO_XFER_CMD_FRAME_ISSUED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_CMD_FRAME_ISSUED\\n\");\n\t\treturn;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO, \"Unknown status 0x%x\\n\", event);\n\t\t \n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tbreak;\n\t}\n\tspin_lock_irqsave(&t->task_state_lock, flags);\n\tt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\tt->task_state_flags |= SAS_TASK_STATE_DONE;\n\tif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"task 0x%p done with event 0x%x resp 0x%x stat 0x%x but aborted by upper layer!\\n\",\n\t\t\t   t, event, ts->resp, ts->stat);\n\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t} else {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tpm8001_ccb_task_free_done(pm8001_ha, ccb);\n\t}\n}\n\n \nstatic void\nmpi_sata_completion(struct pm8001_hba_info *pm8001_ha,\n\t\tstruct outbound_queue_table *circularQ, void *piomb)\n{\n\tstruct sas_task *t;\n\tstruct pm8001_ccb_info *ccb;\n\tu32 param;\n\tu32 status;\n\tu32 tag;\n\tint i, j;\n\tu8 sata_addr_low[4];\n\tu32 temp_sata_addr_low, temp_sata_addr_hi;\n\tu8 sata_addr_hi[4];\n\tstruct sata_completion_resp *psataPayload;\n\tstruct task_status_struct *ts;\n\tstruct ata_task_resp *resp ;\n\tu32 *sata_resp;\n\tstruct pm8001_device *pm8001_dev;\n\tunsigned long flags;\n\n\tpsataPayload = (struct sata_completion_resp *)(piomb + 4);\n\tstatus = le32_to_cpu(psataPayload->status);\n\tparam = le32_to_cpu(psataPayload->param);\n\ttag = le32_to_cpu(psataPayload->tag);\n\n\tccb = &pm8001_ha->ccb_info[tag];\n\tt = ccb->task;\n\tpm8001_dev = ccb->device;\n\n\tif (t) {\n\t\tif (t->dev && (t->dev->lldd_dev))\n\t\t\tpm8001_dev = t->dev->lldd_dev;\n\t} else {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"task null, freeing CCB tag %d\\n\",\n\t\t\t   ccb->ccb_tag);\n\t\tpm8001_ccb_free(pm8001_ha, ccb);\n\t\treturn;\n\t}\n\n\n\tif (pm8001_dev && unlikely(!t->lldd_task || !t->dev))\n\t\treturn;\n\n\tts = &t->task_status;\n\n\tif (status != IO_SUCCESS) {\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\"IO failed device_id %u status 0x%x tag %d\\n\",\n\t\t\tpm8001_dev->device_id, status, tag);\n\t}\n\n\t \n\tif ((status != IO_SUCCESS) && (status != IO_OVERFLOW) &&\n\t\t(status != IO_UNDERFLOW)) {\n\t\tif (!((t->dev->parent) &&\n\t\t\t(dev_is_expander(t->dev->parent->dev_type)))) {\n\t\t\tfor (i = 0, j = 4; i <= 3 && j <= 7; i++, j++)\n\t\t\t\tsata_addr_low[i] = pm8001_ha->sas_addr[j];\n\t\t\tfor (i = 0, j = 0; i <= 3 && j <= 3; i++, j++)\n\t\t\t\tsata_addr_hi[i] = pm8001_ha->sas_addr[j];\n\t\t\tmemcpy(&temp_sata_addr_low, sata_addr_low,\n\t\t\t\tsizeof(sata_addr_low));\n\t\t\tmemcpy(&temp_sata_addr_hi, sata_addr_hi,\n\t\t\t\tsizeof(sata_addr_hi));\n\t\t\ttemp_sata_addr_hi = (((temp_sata_addr_hi >> 24) & 0xff)\n\t\t\t\t\t\t|((temp_sata_addr_hi << 8) &\n\t\t\t\t\t\t0xff0000) |\n\t\t\t\t\t\t((temp_sata_addr_hi >> 8)\n\t\t\t\t\t\t& 0xff00) |\n\t\t\t\t\t\t((temp_sata_addr_hi << 24) &\n\t\t\t\t\t\t0xff000000));\n\t\t\ttemp_sata_addr_low = ((((temp_sata_addr_low >> 24)\n\t\t\t\t\t\t& 0xff) |\n\t\t\t\t\t\t((temp_sata_addr_low << 8)\n\t\t\t\t\t\t& 0xff0000) |\n\t\t\t\t\t\t((temp_sata_addr_low >> 8)\n\t\t\t\t\t\t& 0xff00) |\n\t\t\t\t\t\t((temp_sata_addr_low << 24)\n\t\t\t\t\t\t& 0xff000000)) +\n\t\t\t\t\t\tpm8001_dev->attached_phy +\n\t\t\t\t\t\t0x10);\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"SAS Address of IO Failure Drive:%08x%08x\\n\",\n\t\t\t\t   temp_sata_addr_hi,\n\t\t\t\t   temp_sata_addr_low);\n\n\t\t} else {\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"SAS Address of IO Failure Drive:%016llx\\n\",\n\t\t\t\t   SAS_ADDR(t->dev->sas_addr));\n\t\t}\n\t}\n\tswitch (status) {\n\tcase IO_SUCCESS:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_SUCCESS\\n\");\n\t\tif (param == 0) {\n\t\t\tts->resp = SAS_TASK_COMPLETE;\n\t\t\tts->stat = SAS_SAM_STAT_GOOD;\n\t\t} else {\n\t\t\tu8 len;\n\t\t\tts->resp = SAS_TASK_COMPLETE;\n\t\t\tts->stat = SAS_PROTO_RESPONSE;\n\t\t\tts->residual = param;\n\t\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t\t   \"SAS_PROTO_RESPONSE len = %d\\n\",\n\t\t\t\t   param);\n\t\t\tsata_resp = &psataPayload->sata_resp[0];\n\t\t\tresp = (struct ata_task_resp *)ts->buf;\n\t\t\tif (t->ata_task.dma_xfer == 0 &&\n\t\t\t    t->data_dir == DMA_FROM_DEVICE) {\n\t\t\t\tlen = sizeof(struct pio_setup_fis);\n\t\t\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t\t\t   \"PIO read len = %d\\n\", len);\n\t\t\t} else if (t->ata_task.use_ncq &&\n\t\t\t\t   t->data_dir != DMA_NONE) {\n\t\t\t\tlen = sizeof(struct set_dev_bits_fis);\n\t\t\t\tpm8001_dbg(pm8001_ha, IO, \"FPDMA len = %d\\n\",\n\t\t\t\t\t   len);\n\t\t\t} else {\n\t\t\t\tlen = sizeof(struct dev_to_host_fis);\n\t\t\t\tpm8001_dbg(pm8001_ha, IO, \"other len = %d\\n\",\n\t\t\t\t\t   len);\n\t\t\t}\n\t\t\tif (SAS_STATUS_BUF_SIZE >= sizeof(*resp)) {\n\t\t\t\tresp->frame_len = len;\n\t\t\t\tmemcpy(&resp->ending_fis[0], sata_resp, len);\n\t\t\t\tts->buf_valid_size = sizeof(*resp);\n\t\t\t} else\n\t\t\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t\t\t   \"response too large\\n\");\n\t\t}\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_ABORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_ABORTED IOMB Tag\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_ABORTED_TASK;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\t\t \n\tcase IO_UNDERFLOW:\n\t\t \n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_UNDERFLOW param = %d\\n\", param);\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_UNDERRUN;\n\t\tts->residual = param;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_NO_DEVICE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_NO_DEVICE\\n\");\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_PHY_DOWN;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_INTERRUPTED;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_PHY_NOT_READY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_PHY_NOT_READY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_EPROTO;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_ZONE_VIOLATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_CONT0;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\n\tcase IO_XFER_OPEN_RETRY_BACKOFF_THRESHOLD_REACHED:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_TMO:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_NO_DEST:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_COLLIDE:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_PATHWAY_BLOCKED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (!t->uldd_task) {\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\n\t\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\t\tts->stat = SAS_QUEUE_FULL;\n\t\t\tspin_unlock_irqrestore(&circularQ->oq_lock,\n\t\t\t\t\tcircularQ->lock_flags);\n\t\t\tpm8001_ccb_task_free_done(pm8001_ha, ccb);\n\t\t\tspin_lock_irqsave(&circularQ->oq_lock,\n\t\t\t\t\tcircularQ->lock_flags);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_BAD_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_BAD_DEST;\n\t\tif (!t->uldd_task) {\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\n\t\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\t\tts->stat = SAS_QUEUE_FULL;\n\t\t\tspin_unlock_irqrestore(&circularQ->oq_lock,\n\t\t\t\t\tcircularQ->lock_flags);\n\t\t\tpm8001_ccb_task_free_done(pm8001_ha, ccb);\n\t\t\tspin_lock_irqsave(&circularQ->oq_lock,\n\t\t\t\t\tcircularQ->lock_flags);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_CONN_RATE;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_STP_RESOURCES_BUSY:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_STP_RESOURCES_BUSY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (!t->uldd_task) {\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_OPEN_CNX_ERROR_STP_RESOURCES_BUSY);\n\t\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\t\tts->stat = SAS_QUEUE_FULL;\n\t\t\tspin_unlock_irqrestore(&circularQ->oq_lock,\n\t\t\t\t\tcircularQ->lock_flags);\n\t\t\tpm8001_ccb_task_free_done(pm8001_ha, ccb);\n\t\t\tspin_lock_irqsave(&circularQ->oq_lock,\n\t\t\t\t\tcircularQ->lock_flags);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_WRONG_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_WRONG_DEST;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_NAK_RECEIVED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_NAK_RECEIVED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_NAK_R_ERR;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_ACK_NAK_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_ACK_NAK_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_NAK_R_ERR;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_DMA:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_DMA\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_ABORTED_TASK;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_SATA_LINK_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_SATA_LINK_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_REJECTED_NCQ_MODE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_REJECTED_NCQ_MODE\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_UNDERRUN;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_OPEN_RETRY_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_OPEN_RETRY_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_PORT_IN_RESET:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_PORT_IN_RESET\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_DS_NON_OPERATIONAL:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_DS_NON_OPERATIONAL\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (!t->uldd_task) {\n\t\t\tpm8001_handle_event(pm8001_ha, pm8001_dev,\n\t\t\t\t\tIO_DS_NON_OPERATIONAL);\n\t\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\t\tts->stat = SAS_QUEUE_FULL;\n\t\t\tspin_unlock_irqrestore(&circularQ->oq_lock,\n\t\t\t\t\tcircularQ->lock_flags);\n\t\t\tpm8001_ccb_task_free_done(pm8001_ha, ccb);\n\t\t\tspin_lock_irqsave(&circularQ->oq_lock,\n\t\t\t\t\tcircularQ->lock_flags);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase IO_DS_IN_RECOVERY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_DS_IN_RECOVERY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_DS_IN_ERROR:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_DS_IN_ERROR\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (!t->uldd_task) {\n\t\t\tpm8001_handle_event(pm8001_ha, pm8001_dev,\n\t\t\t\t\tIO_DS_IN_ERROR);\n\t\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\t\tts->stat = SAS_QUEUE_FULL;\n\t\t\tspin_unlock_irqrestore(&circularQ->oq_lock,\n\t\t\t\t\tcircularQ->lock_flags);\n\t\t\tpm8001_ccb_task_free_done(pm8001_ha, ccb);\n\t\t\tspin_lock_irqsave(&circularQ->oq_lock,\n\t\t\t\t\tcircularQ->lock_flags);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO,\n\t\t\t\t\"Unknown status device_id %u status 0x%x tag %d\\n\",\n\t\t\tpm8001_dev->device_id, status, tag);\n\t\t \n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\t}\n\tspin_lock_irqsave(&t->task_state_lock, flags);\n\tt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\tt->task_state_flags |= SAS_TASK_STATE_DONE;\n\tif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"task 0x%p done with io_status 0x%x resp 0x%x stat 0x%x but aborted by upper layer!\\n\",\n\t\t\t   t, status, ts->resp, ts->stat);\n\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t\tif (t->slow_task)\n\t\t\tcomplete(&t->slow_task->completion);\n\t} else {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tspin_unlock_irqrestore(&circularQ->oq_lock,\n\t\t\t\tcircularQ->lock_flags);\n\t\tpm8001_ccb_task_free_done(pm8001_ha, ccb);\n\t\tspin_lock_irqsave(&circularQ->oq_lock,\n\t\t\t\tcircularQ->lock_flags);\n\t}\n}\n\n \nstatic void mpi_sata_event(struct pm8001_hba_info *pm8001_ha,\n\t\tstruct outbound_queue_table *circularQ, void *piomb)\n{\n\tstruct sas_task *t;\n\tstruct task_status_struct *ts;\n\tstruct pm8001_ccb_info *ccb;\n\tstruct pm8001_device *pm8001_dev;\n\tstruct sata_event_resp *psataPayload =\n\t\t(struct sata_event_resp *)(piomb + 4);\n\tu32 event = le32_to_cpu(psataPayload->event);\n\tu32 tag = le32_to_cpu(psataPayload->tag);\n\tu32 port_id = le32_to_cpu(psataPayload->port_id);\n\tu32 dev_id = le32_to_cpu(psataPayload->device_id);\n\n\tif (event)\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"SATA EVENT 0x%x\\n\", event);\n\n\t \n\tif (event == IO_XFER_ERROR_ABORTED_NCQ_MODE) {\n\t\t \n\t\tpm8001_dev = pm8001_find_dev(pm8001_ha, dev_id);\n\t\t \n\t\tif (pm8001_dev)\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_XFER_ERROR_ABORTED_NCQ_MODE);\n\t\treturn;\n\t}\n\n\tccb = &pm8001_ha->ccb_info[tag];\n\tt = ccb->task;\n\tpm8001_dev = ccb->device;\n\tif (unlikely(!t)) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"task null, freeing CCB tag %d\\n\",\n\t\t\t   ccb->ccb_tag);\n\t\tpm8001_ccb_free(pm8001_ha, ccb);\n\t\treturn;\n\t}\n\n\tif (unlikely(!t->lldd_task || !t->dev))\n\t\treturn;\n\n\tts = &t->task_status;\n\tpm8001_dbg(pm8001_ha, IOERR, \"port_id:0x%x, tag:0x%x, event:0x%x\\n\",\n\t\t   port_id, tag, event);\n\tswitch (event) {\n\tcase IO_OVERFLOW:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_UNDERFLOW\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tts->residual = 0;\n\t\tbreak;\n\tcase IO_XFER_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_INTERRUPTED;\n\t\tbreak;\n\tcase IO_XFER_ERROR_PHY_NOT_READY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_PHY_NOT_READY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_EPROTO;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_ZONE_VIOLATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_CONT0;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\n\tcase IO_XFER_OPEN_RETRY_BACKOFF_THRESHOLD_REACHED:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_TMO:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_NO_DEST:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_COLLIDE:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_PATHWAY_BLOCKED:\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\\n\");\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (!t->uldd_task) {\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\n\t\t\tts->resp = SAS_TASK_COMPLETE;\n\t\t\tts->stat = SAS_QUEUE_FULL;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_BAD_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_BAD_DEST;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_CONN_RATE;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_WRONG_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_WRONG_DEST;\n\t\tbreak;\n\tcase IO_XFER_ERROR_NAK_RECEIVED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_NAK_RECEIVED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_NAK_R_ERR;\n\t\tbreak;\n\tcase IO_XFER_ERROR_PEER_ABORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_PEER_ABORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_NAK_R_ERR;\n\t\tbreak;\n\tcase IO_XFER_ERROR_REJECTED_NCQ_MODE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_REJECTED_NCQ_MODE\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_UNDERRUN;\n\t\tbreak;\n\tcase IO_XFER_OPEN_RETRY_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_OPEN_RETRY_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tcase IO_XFER_ERROR_UNEXPECTED_PHASE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_UNEXPECTED_PHASE\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tcase IO_XFER_ERROR_XFER_RDY_OVERRUN:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_XFER_RDY_OVERRUN\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tcase IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tcase IO_XFER_ERROR_OFFSET_MISMATCH:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_OFFSET_MISMATCH\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tcase IO_XFER_ERROR_XFER_ZERO_DATA_LEN:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_XFER_ERROR_XFER_ZERO_DATA_LEN\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tcase IO_XFER_CMD_FRAME_ISSUED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_CMD_FRAME_ISSUED\\n\");\n\t\tbreak;\n\tcase IO_XFER_PIO_SETUP_ERROR:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_PIO_SETUP_ERROR\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tcase IO_XFER_ERROR_INTERNAL_CRC_ERROR:\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"IO_XFR_ERROR_INTERNAL_CRC_ERROR\\n\");\n\t\t \n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tcase IO_XFER_DMA_ACTIVATE_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"IO_XFR_DMA_ACTIVATE_TIMEOUT\\n\");\n\t\t \n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, IO, \"Unknown status 0x%x\\n\", event);\n\t\t \n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nmpi_smp_completion(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tu32 param, i;\n\tstruct sas_task *t;\n\tstruct pm8001_ccb_info *ccb;\n\tunsigned long flags;\n\tu32 status;\n\tu32 tag;\n\tstruct smp_completion_resp *psmpPayload;\n\tstruct task_status_struct *ts;\n\tstruct pm8001_device *pm8001_dev;\n\n\tpsmpPayload = (struct smp_completion_resp *)(piomb + 4);\n\tstatus = le32_to_cpu(psmpPayload->status);\n\ttag = le32_to_cpu(psmpPayload->tag);\n\n\tccb = &pm8001_ha->ccb_info[tag];\n\tparam = le32_to_cpu(psmpPayload->param);\n\tt = ccb->task;\n\tts = &t->task_status;\n\tpm8001_dev = ccb->device;\n\tif (status)\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"smp IO status 0x%x\\n\", status);\n\tif (unlikely(!t || !t->lldd_task || !t->dev))\n\t\treturn;\n\n\tpm8001_dbg(pm8001_ha, DEV, \"tag::0x%x status::0x%x\\n\", tag, status);\n\n\tswitch (status) {\n\n\tcase IO_SUCCESS:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_SUCCESS\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_SAM_STAT_GOOD;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tif (pm8001_ha->smp_exp_mode == SMP_DIRECT) {\n\t\t\tstruct scatterlist *sg_resp = &t->smp_task.smp_resp;\n\t\t\tu8 *payload;\n\t\t\tvoid *to;\n\n\t\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t\t   \"DIRECT RESPONSE Length:%d\\n\",\n\t\t\t\t   param);\n\t\t\tto = kmap_atomic(sg_page(sg_resp));\n\t\t\tpayload = to + sg_resp->offset;\n\t\t\tfor (i = 0; i < param; i++) {\n\t\t\t\t*(payload + i) = psmpPayload->_r_a[i];\n\t\t\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t\t\t   \"SMP Byte%d DMA data 0x%x psmp 0x%x\\n\",\n\t\t\t\t\t   i, *(payload + i),\n\t\t\t\t\t   psmpPayload->_r_a[i]);\n\t\t\t}\n\t\t\tkunmap_atomic(to);\n\t\t}\n\t\tbreak;\n\tcase IO_ABORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_ABORTED IOMB\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_ABORTED_TASK;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OVERFLOW:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_UNDERFLOW\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tts->residual = 0;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_NO_DEVICE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_NO_DEVICE\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_PHY_DOWN;\n\t\tbreak;\n\tcase IO_ERROR_HW_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_ERROR_HW_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_SAM_STAT_BUSY;\n\t\tbreak;\n\tcase IO_XFER_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_SAM_STAT_BUSY;\n\t\tbreak;\n\tcase IO_XFER_ERROR_PHY_NOT_READY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_PHY_NOT_READY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_SAM_STAT_BUSY;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_ZONE_VIOLATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_CONT0;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\n\tcase IO_XFER_OPEN_RETRY_BACKOFF_THRESHOLD_REACHED:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_TMO:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_NO_DEST:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_OPEN_COLLIDE:\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS_PATHWAY_BLOCKED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_BAD_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_BAD_DEST;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_CONN_RATE;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_WRONG_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_WRONG_DEST;\n\t\tbreak;\n\tcase IO_XFER_ERROR_RX_FRAME:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_RX_FRAME\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tbreak;\n\tcase IO_XFER_OPEN_RETRY_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_OPEN_RETRY_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_ERROR_INTERNAL_SMP_RESOURCE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_ERROR_INTERNAL_SMP_RESOURCE\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_QUEUE_FULL;\n\t\tbreak;\n\tcase IO_PORT_IN_RESET:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_PORT_IN_RESET\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_DS_NON_OPERATIONAL:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_DS_NON_OPERATIONAL\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tbreak;\n\tcase IO_DS_IN_RECOVERY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_DS_IN_RECOVERY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO, \"Unknown status 0x%x\\n\", status);\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\t \n\t\tbreak;\n\t}\n\tspin_lock_irqsave(&t->task_state_lock, flags);\n\tt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\tt->task_state_flags |= SAS_TASK_STATE_DONE;\n\tif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"task 0x%p done with io_status 0x%x resp 0x%xstat 0x%x but aborted by upper layer!\\n\",\n\t\t\t   t, status, ts->resp, ts->stat);\n\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t} else {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t\tmb(); \n\t\tt->task_done(t);\n\t}\n}\n\n \nstatic void pm80xx_hw_event_ack_req(struct pm8001_hba_info *pm8001_ha,\n\tu32 Qnum, u32 SEA, u32 port_id, u32 phyId, u32 param0, u32 param1)\n{\n\tstruct hw_event_ack_req\t payload;\n\tu32 opc = OPC_INB_SAS_HW_EVENT_ACK;\n\n\tmemset((u8 *)&payload, 0, sizeof(payload));\n\tpayload.tag = cpu_to_le32(1);\n\tpayload.phyid_sea_portid = cpu_to_le32(((SEA & 0xFFFF) << 8) |\n\t\t((phyId & 0xFF) << 24) | (port_id & 0xFF));\n\tpayload.param0 = cpu_to_le32(param0);\n\tpayload.param1 = cpu_to_le32(param1);\n\n\tpm8001_mpi_build_cmd(pm8001_ha, Qnum, opc, &payload,\n\t\t\t     sizeof(payload), 0);\n}\n\nstatic int pm80xx_chip_phy_ctl_req(struct pm8001_hba_info *pm8001_ha,\n\tu32 phyId, u32 phy_op);\n\nstatic void hw_event_port_recover(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\tvoid *piomb)\n{\n\tstruct hw_event_resp *pPayload = (struct hw_event_resp *)(piomb + 4);\n\tu32 phyid_npip_portstate = le32_to_cpu(pPayload->phyid_npip_portstate);\n\tu8 phy_id = (u8)((phyid_npip_portstate & 0xFF0000) >> 16);\n\tu32 lr_status_evt_portid =\n\t\tle32_to_cpu(pPayload->lr_status_evt_portid);\n\tu8 deviceType = pPayload->sas_identify.dev_type;\n\tu8 link_rate = (u8)((lr_status_evt_portid & 0xF0000000) >> 28);\n\tstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\n\tu8 port_id = (u8)(lr_status_evt_portid & 0x000000FF);\n\tstruct pm8001_port *port = &pm8001_ha->port[port_id];\n\n\tif (deviceType == SAS_END_DEVICE) {\n\t\tpm80xx_chip_phy_ctl_req(pm8001_ha, phy_id,\n\t\t\t\t\tPHY_NOTIFY_ENABLE_SPINUP);\n\t}\n\n\tport->wide_port_phymap |= (1U << phy_id);\n\tpm8001_get_lrate_mode(phy, link_rate);\n\tphy->sas_phy.oob_mode = SAS_OOB_MODE;\n\tphy->phy_state = PHY_STATE_LINK_UP_SPCV;\n\tphy->phy_attached = 1;\n}\n\n \nstatic void\nhw_event_sas_phy_up(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct hw_event_resp *pPayload =\n\t\t(struct hw_event_resp *)(piomb + 4);\n\tu32 lr_status_evt_portid =\n\t\tle32_to_cpu(pPayload->lr_status_evt_portid);\n\tu32 phyid_npip_portstate = le32_to_cpu(pPayload->phyid_npip_portstate);\n\n\tu8 link_rate =\n\t\t(u8)((lr_status_evt_portid & 0xF0000000) >> 28);\n\tu8 port_id = (u8)(lr_status_evt_portid & 0x000000FF);\n\tu8 phy_id =\n\t\t(u8)((phyid_npip_portstate & 0xFF0000) >> 16);\n\tu8 portstate = (u8)(phyid_npip_portstate & 0x0000000F);\n\n\tstruct pm8001_port *port = &pm8001_ha->port[port_id];\n\tstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\n\tunsigned long flags;\n\tu8 deviceType = pPayload->sas_identify.dev_type;\n\tphy->port = port;\n\tport->port_id = port_id;\n\tport->port_state = portstate;\n\tport->wide_port_phymap |= (1U << phy_id);\n\tphy->phy_state = PHY_STATE_LINK_UP_SPCV;\n\tpm8001_dbg(pm8001_ha, MSG,\n\t\t   \"portid:%d; phyid:%d; linkrate:%d; portstate:%x; devicetype:%x\\n\",\n\t\t   port_id, phy_id, link_rate, portstate, deviceType);\n\n\tswitch (deviceType) {\n\tcase SAS_PHY_UNUSED:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"device type no device.\\n\");\n\t\tbreak;\n\tcase SAS_END_DEVICE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"end device.\\n\");\n\t\tpm80xx_chip_phy_ctl_req(pm8001_ha, phy_id,\n\t\t\tPHY_NOTIFY_ENABLE_SPINUP);\n\t\tport->port_attached = 1;\n\t\tpm8001_get_lrate_mode(phy, link_rate);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"expander device.\\n\");\n\t\tport->port_attached = 1;\n\t\tpm8001_get_lrate_mode(phy, link_rate);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"fanout expander device.\\n\");\n\t\tport->port_attached = 1;\n\t\tpm8001_get_lrate_mode(phy, link_rate);\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO, \"unknown device type(%x)\\n\",\n\t\t\t   deviceType);\n\t\tbreak;\n\t}\n\tphy->phy_type |= PORT_TYPE_SAS;\n\tphy->identify.device_type = deviceType;\n\tphy->phy_attached = 1;\n\tif (phy->identify.device_type == SAS_END_DEVICE)\n\t\tphy->identify.target_port_protocols = SAS_PROTOCOL_SSP;\n\telse if (phy->identify.device_type != SAS_PHY_UNUSED)\n\t\tphy->identify.target_port_protocols = SAS_PROTOCOL_SMP;\n\tphy->sas_phy.oob_mode = SAS_OOB_MODE;\n\tsas_notify_phy_event(&phy->sas_phy, PHYE_OOB_DONE, GFP_ATOMIC);\n\tspin_lock_irqsave(&phy->sas_phy.frame_rcvd_lock, flags);\n\tmemcpy(phy->frame_rcvd, &pPayload->sas_identify,\n\t\tsizeof(struct sas_identify_frame)-4);\n\tphy->frame_rcvd_size = sizeof(struct sas_identify_frame) - 4;\n\tpm8001_get_attached_sas_addr(phy, phy->sas_phy.attached_sas_addr);\n\tspin_unlock_irqrestore(&phy->sas_phy.frame_rcvd_lock, flags);\n\tif (pm8001_ha->flags == PM8001F_RUN_TIME)\n\t\tmdelay(200);  \n\tpm8001_bytes_dmaed(pm8001_ha, phy_id);\n}\n\n \nstatic void\nhw_event_sata_phy_up(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct hw_event_resp *pPayload =\n\t\t(struct hw_event_resp *)(piomb + 4);\n\tu32 phyid_npip_portstate = le32_to_cpu(pPayload->phyid_npip_portstate);\n\tu32 lr_status_evt_portid =\n\t\tle32_to_cpu(pPayload->lr_status_evt_portid);\n\tu8 link_rate =\n\t\t(u8)((lr_status_evt_portid & 0xF0000000) >> 28);\n\tu8 port_id = (u8)(lr_status_evt_portid & 0x000000FF);\n\tu8 phy_id =\n\t\t(u8)((phyid_npip_portstate & 0xFF0000) >> 16);\n\n\tu8 portstate = (u8)(phyid_npip_portstate & 0x0000000F);\n\n\tstruct pm8001_port *port = &pm8001_ha->port[port_id];\n\tstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\n\tunsigned long flags;\n\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t   \"HW_EVENT_SATA_PHY_UP phyid:%#x port_id:%#x link_rate:%d portstate:%#x\\n\",\n\t\t   phy_id, port_id, link_rate, portstate);\n\n\tphy->port = port;\n\tport->port_id = port_id;\n\tport->port_state = portstate;\n\tphy->phy_state = PHY_STATE_LINK_UP_SPCV;\n\tport->port_attached = 1;\n\tpm8001_get_lrate_mode(phy, link_rate);\n\tphy->phy_type |= PORT_TYPE_SATA;\n\tphy->phy_attached = 1;\n\tphy->sas_phy.oob_mode = SATA_OOB_MODE;\n\tsas_notify_phy_event(&phy->sas_phy, PHYE_OOB_DONE, GFP_ATOMIC);\n\tspin_lock_irqsave(&phy->sas_phy.frame_rcvd_lock, flags);\n\tmemcpy(phy->frame_rcvd, ((u8 *)&pPayload->sata_fis - 4),\n\t\tsizeof(struct dev_to_host_fis));\n\tphy->frame_rcvd_size = sizeof(struct dev_to_host_fis);\n\tphy->identify.target_port_protocols = SAS_PROTOCOL_SATA;\n\tphy->identify.device_type = SAS_SATA_DEV;\n\tpm8001_get_attached_sas_addr(phy, phy->sas_phy.attached_sas_addr);\n\tspin_unlock_irqrestore(&phy->sas_phy.frame_rcvd_lock, flags);\n\tpm8001_bytes_dmaed(pm8001_ha, phy_id);\n}\n\n \nstatic void\nhw_event_phy_down(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct hw_event_resp *pPayload =\n\t\t(struct hw_event_resp *)(piomb + 4);\n\n\tu32 lr_status_evt_portid =\n\t\tle32_to_cpu(pPayload->lr_status_evt_portid);\n\tu8 port_id = (u8)(lr_status_evt_portid & 0x000000FF);\n\tu32 phyid_npip_portstate = le32_to_cpu(pPayload->phyid_npip_portstate);\n\tu8 phy_id =\n\t\t(u8)((phyid_npip_portstate & 0xFF0000) >> 16);\n\tu8 portstate = (u8)(phyid_npip_portstate & 0x0000000F);\n\n\tstruct pm8001_port *port = &pm8001_ha->port[port_id];\n\tstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\n\tu32 port_sata = (phy->phy_type & PORT_TYPE_SATA);\n\tport->port_state = portstate;\n\tphy->identify.device_type = 0;\n\tphy->phy_attached = 0;\n\tswitch (portstate) {\n\tcase PORT_VALID:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t\"HW_EVENT_PHY_DOWN phyid:%#x port_id:%#x portstate: PORT_VALID\\n\",\n\t\t\tphy_id, port_id);\n\t\tbreak;\n\tcase PORT_INVALID:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t\"HW_EVENT_PHY_DOWN phyid:%#x port_id:%#x portstate: PORT_INVALID\\n\",\n\t\t\tphy_id, port_id);\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \" Last phy Down and port invalid\\n\");\n\t\tif (port_sata) {\n\t\t\tphy->phy_type = 0;\n\t\t\tport->port_attached = 0;\n\t\t\tpm80xx_hw_event_ack_req(pm8001_ha, 0, HW_EVENT_PHY_DOWN,\n\t\t\t\t\tport_id, phy_id, 0, 0);\n\t\t}\n\t\tsas_phy_disconnected(&phy->sas_phy);\n\t\tbreak;\n\tcase PORT_IN_RESET:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t\"HW_EVENT_PHY_DOWN phyid:%#x port_id:%#x portstate: PORT_IN_RESET\\n\",\n\t\t\tphy_id, port_id);\n\t\tbreak;\n\tcase PORT_NOT_ESTABLISHED:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t\"HW_EVENT_PHY_DOWN phyid:%#x port_id:%#x portstate: PORT_NOT_ESTABLISHED\\n\",\n\t\t\tphy_id, port_id);\n\t\tport->port_attached = 0;\n\t\tbreak;\n\tcase PORT_LOSTCOMM:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t\"HW_EVENT_PHY_DOWN phyid:%#x port_id:%#x portstate: PORT_LOSTCOMM\\n\",\n\t\t\tphy_id, port_id);\n\t\tpm8001_dbg(pm8001_ha, MSG, \" Last phy Down and port invalid\\n\");\n\t\tif (port_sata) {\n\t\t\tport->port_attached = 0;\n\t\t\tphy->phy_type = 0;\n\t\t\tpm80xx_hw_event_ack_req(pm8001_ha, 0, HW_EVENT_PHY_DOWN,\n\t\t\t\t\tport_id, phy_id, 0, 0);\n\t\t}\n\t\tsas_phy_disconnected(&phy->sas_phy);\n\t\tbreak;\n\tdefault:\n\t\tport->port_attached = 0;\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t\"HW_EVENT_PHY_DOWN phyid:%#x port_id:%#x portstate:%#x\\n\",\n\t\t\tphy_id, port_id, portstate);\n\t\tbreak;\n\n\t}\n\tif (port_sata && (portstate != PORT_IN_RESET))\n\t\tsas_notify_phy_event(&phy->sas_phy, PHYE_LOSS_OF_SIGNAL,\n\t\t\t\tGFP_ATOMIC);\n}\n\nstatic int mpi_phy_start_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct phy_start_resp *pPayload =\n\t\t(struct phy_start_resp *)(piomb + 4);\n\tu32 status =\n\t\tle32_to_cpu(pPayload->status);\n\tu32 phy_id =\n\t\tle32_to_cpu(pPayload->phyid) & 0xFF;\n\tstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\n\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"phy start resp status:0x%x, phyid:0x%x\\n\",\n\t\t   status, phy_id);\n\tif (status == 0)\n\t\tphy->phy_state = PHY_LINK_DOWN;\n\n\tif (pm8001_ha->flags == PM8001F_RUN_TIME &&\n\t\t\tphy->enable_completion != NULL) {\n\t\tcomplete(phy->enable_completion);\n\t\tphy->enable_completion = NULL;\n\t}\n\treturn 0;\n\n}\n\n \nstatic int mpi_thermal_hw_event(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct thermal_hw_event *pPayload =\n\t\t(struct thermal_hw_event *)(piomb + 4);\n\n\tu32 thermal_event = le32_to_cpu(pPayload->thermal_event);\n\tu32 rht_lht = le32_to_cpu(pPayload->rht_lht);\n\n\tif (thermal_event & 0x40) {\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"Thermal Event: Local high temperature violated!\\n\");\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"Thermal Event: Measured local high temperature %d\\n\",\n\t\t\t   ((rht_lht & 0xFF00) >> 8));\n\t}\n\tif (thermal_event & 0x10) {\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"Thermal Event: Remote high temperature violated!\\n\");\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"Thermal Event: Measured remote high temperature %d\\n\",\n\t\t\t   ((rht_lht & 0xFF000000) >> 24));\n\t}\n\treturn 0;\n}\n\n \nstatic int mpi_hw_event(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tunsigned long flags, i;\n\tstruct hw_event_resp *pPayload =\n\t\t(struct hw_event_resp *)(piomb + 4);\n\tu32 lr_status_evt_portid =\n\t\tle32_to_cpu(pPayload->lr_status_evt_portid);\n\tu32 phyid_npip_portstate = le32_to_cpu(pPayload->phyid_npip_portstate);\n\tu8 port_id = (u8)(lr_status_evt_portid & 0x000000FF);\n\tu8 phy_id =\n\t\t(u8)((phyid_npip_portstate & 0xFF0000) >> 16);\n\tu8 portstate = (u8)(phyid_npip_portstate & 0x0000000F);\n\tu16 eventType =\n\t\t(u16)((lr_status_evt_portid & 0x00FFFF00) >> 8);\n\tu8 status =\n\t\t(u8)((lr_status_evt_portid & 0x0F000000) >> 24);\n\tstruct sas_ha_struct *sas_ha = pm8001_ha->sas;\n\tstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\n\tstruct pm8001_port *port = &pm8001_ha->port[port_id];\n\tstruct asd_sas_phy *sas_phy = sas_ha->sas_phy[phy_id];\n\tpm8001_dbg(pm8001_ha, DEV,\n\t\t   \"portid:%d phyid:%d event:0x%x status:0x%x\\n\",\n\t\t   port_id, phy_id, eventType, status);\n\n\tswitch (eventType) {\n\n\tcase HW_EVENT_SAS_PHY_UP:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_SAS_PHY_UP phyid:%#x port_id:%#x\\n\",\n\t\t\t   phy_id, port_id);\n\t\thw_event_sas_phy_up(pm8001_ha, piomb);\n\t\tbreak;\n\tcase HW_EVENT_SATA_PHY_UP:\n\t\thw_event_sata_phy_up(pm8001_ha, piomb);\n\t\tbreak;\n\tcase HW_EVENT_SATA_SPINUP_HOLD:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_SATA_SPINUP_HOLD phyid:%#x port_id:%#x\\n\",\n\t\t\t   phy_id, port_id);\n\t\tsas_notify_phy_event(&phy->sas_phy, PHYE_SPINUP_HOLD,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_PHY_DOWN:\n\t\thw_event_phy_down(pm8001_ha, piomb);\n\t\tphy->phy_state = PHY_LINK_DISABLE;\n\t\tbreak;\n\tcase HW_EVENT_PORT_INVALID:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_PORT_INVALID phyid:%#x port_id:%#x\\n\",\n\t\t\t   phy_id, port_id);\n\t\tsas_phy_disconnected(sas_phy);\n\t\tphy->phy_attached = 0;\n\t\tsas_notify_port_event(sas_phy, PORTE_LINK_RESET_ERR,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\t \n\tcase HW_EVENT_BROADCAST_CHANGE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_BROADCAST_CHANGE\\n\");\n\t\tpm80xx_hw_event_ack_req(pm8001_ha, 0, HW_EVENT_BROADCAST_CHANGE,\n\t\t\tport_id, phy_id, 1, 0);\n\t\tspin_lock_irqsave(&sas_phy->sas_prim_lock, flags);\n\t\tsas_phy->sas_prim = HW_EVENT_BROADCAST_CHANGE;\n\t\tspin_unlock_irqrestore(&sas_phy->sas_prim_lock, flags);\n\t\tsas_notify_port_event(sas_phy, PORTE_BROADCAST_RCVD,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_PHY_ERROR:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_PHY_ERROR phyid:%#x port_id:%#x\\n\",\n\t\t\t   phy_id, port_id);\n\t\tsas_phy_disconnected(&phy->sas_phy);\n\t\tphy->phy_attached = 0;\n\t\tsas_notify_phy_event(&phy->sas_phy, PHYE_OOB_ERROR, GFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_BROADCAST_EXP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_BROADCAST_EXP\\n\");\n\t\tspin_lock_irqsave(&sas_phy->sas_prim_lock, flags);\n\t\tsas_phy->sas_prim = HW_EVENT_BROADCAST_EXP;\n\t\tspin_unlock_irqrestore(&sas_phy->sas_prim_lock, flags);\n\t\tsas_notify_port_event(sas_phy, PORTE_BROADCAST_RCVD,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_LINK_ERR_INVALID_DWORD:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_LINK_ERR_INVALID_DWORD phyid:%#x port_id:%#x\\n\",\n\t\t\t   phy_id, port_id);\n\t\tpm80xx_hw_event_ack_req(pm8001_ha, 0,\n\t\t\tHW_EVENT_LINK_ERR_INVALID_DWORD, port_id, phy_id, 0, 0);\n\t\tbreak;\n\tcase HW_EVENT_LINK_ERR_DISPARITY_ERROR:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_LINK_ERR_DISPARITY_ERROR phyid:%#x port_id:%#x\\n\",\n\t\t\t   phy_id, port_id);\n\t\tpm80xx_hw_event_ack_req(pm8001_ha, 0,\n\t\t\tHW_EVENT_LINK_ERR_DISPARITY_ERROR,\n\t\t\tport_id, phy_id, 0, 0);\n\t\tbreak;\n\tcase HW_EVENT_LINK_ERR_CODE_VIOLATION:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_LINK_ERR_CODE_VIOLATION phyid:%#x port_id:%#x\\n\",\n\t\t\t   phy_id, port_id);\n\t\tpm80xx_hw_event_ack_req(pm8001_ha, 0,\n\t\t\tHW_EVENT_LINK_ERR_CODE_VIOLATION,\n\t\t\tport_id, phy_id, 0, 0);\n\t\tbreak;\n\tcase HW_EVENT_LINK_ERR_LOSS_OF_DWORD_SYNCH:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_LINK_ERR_LOSS_OF_DWORD_SYNCH phyid:%#x port_id:%#x\\n\",\n\t\t\t   phy_id, port_id);\n\t\tpm80xx_hw_event_ack_req(pm8001_ha, 0,\n\t\t\tHW_EVENT_LINK_ERR_LOSS_OF_DWORD_SYNCH,\n\t\t\tport_id, phy_id, 0, 0);\n\t\tbreak;\n\tcase HW_EVENT_MALFUNCTION:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_MALFUNCTION phyid:%#x\\n\", phy_id);\n\t\tbreak;\n\tcase HW_EVENT_BROADCAST_SES:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_BROADCAST_SES\\n\");\n\t\tspin_lock_irqsave(&sas_phy->sas_prim_lock, flags);\n\t\tsas_phy->sas_prim = HW_EVENT_BROADCAST_SES;\n\t\tspin_unlock_irqrestore(&sas_phy->sas_prim_lock, flags);\n\t\tsas_notify_port_event(sas_phy, PORTE_BROADCAST_RCVD,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_INBOUND_CRC_ERROR:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_INBOUND_CRC_ERROR phyid:%#x port_id:%#x\\n\",\n\t\t\t   phy_id, port_id);\n\t\tpm80xx_hw_event_ack_req(pm8001_ha, 0,\n\t\t\tHW_EVENT_INBOUND_CRC_ERROR,\n\t\t\tport_id, phy_id, 0, 0);\n\t\tbreak;\n\tcase HW_EVENT_HARD_RESET_RECEIVED:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_HARD_RESET_RECEIVED phyid:%#x\\n\", phy_id);\n\t\tsas_notify_port_event(sas_phy, PORTE_HARD_RESET, GFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_ID_FRAME_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_ID_FRAME_TIMEOUT phyid:%#x\\n\", phy_id);\n\t\tsas_phy_disconnected(sas_phy);\n\t\tphy->phy_attached = 0;\n\t\tsas_notify_port_event(sas_phy, PORTE_LINK_RESET_ERR,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_LINK_ERR_PHY_RESET_FAILED:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_LINK_ERR_PHY_RESET_FAILED phyid:%#x port_id:%#x\\n\",\n\t\t\t   phy_id, port_id);\n\t\tpm80xx_hw_event_ack_req(pm8001_ha, 0,\n\t\t\tHW_EVENT_LINK_ERR_PHY_RESET_FAILED,\n\t\t\tport_id, phy_id, 0, 0);\n\t\tsas_phy_disconnected(sas_phy);\n\t\tphy->phy_attached = 0;\n\t\tsas_notify_port_event(sas_phy, PORTE_LINK_RESET_ERR,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_PORT_RESET_TIMER_TMO:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_PORT_RESET_TIMER_TMO phyid:%#x port_id:%#x portstate:%#x\\n\",\n\t\t\t   phy_id, port_id, portstate);\n\t\tif (!pm8001_ha->phy[phy_id].reset_completion) {\n\t\t\tpm80xx_hw_event_ack_req(pm8001_ha, 0, HW_EVENT_PHY_DOWN,\n\t\t\t\tport_id, phy_id, 0, 0);\n\t\t}\n\t\tsas_phy_disconnected(sas_phy);\n\t\tphy->phy_attached = 0;\n\t\tport->port_state = portstate;\n\t\tsas_notify_port_event(sas_phy, PORTE_LINK_RESET_ERR,\n\t\t\tGFP_ATOMIC);\n\t\tif (pm8001_ha->phy[phy_id].reset_completion) {\n\t\t\tpm8001_ha->phy[phy_id].port_reset_status =\n\t\t\t\t\tPORT_RESET_TMO;\n\t\t\tcomplete(pm8001_ha->phy[phy_id].reset_completion);\n\t\t\tpm8001_ha->phy[phy_id].reset_completion = NULL;\n\t\t}\n\t\tbreak;\n\tcase HW_EVENT_PORT_RECOVERY_TIMER_TMO:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_PORT_RECOVERY_TIMER_TMO phyid:%#x port_id:%#x\\n\",\n\t\t\t   phy_id, port_id);\n\t\tpm80xx_hw_event_ack_req(pm8001_ha, 0,\n\t\t\tHW_EVENT_PORT_RECOVERY_TIMER_TMO,\n\t\t\tport_id, phy_id, 0, 0);\n\t\tfor (i = 0; i < pm8001_ha->chip->n_phy; i++) {\n\t\t\tif (port->wide_port_phymap & (1 << i)) {\n\t\t\t\tphy = &pm8001_ha->phy[i];\n\t\t\t\tsas_notify_phy_event(&phy->sas_phy,\n\t\t\t\t\tPHYE_LOSS_OF_SIGNAL, GFP_ATOMIC);\n\t\t\t\tport->wide_port_phymap &= ~(1 << i);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase HW_EVENT_PORT_RECOVER:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_PORT_RECOVER phyid:%#x port_id:%#x\\n\",\n\t\t\t   phy_id, port_id);\n\t\thw_event_port_recover(pm8001_ha, piomb);\n\t\tbreak;\n\tcase HW_EVENT_PORT_RESET_COMPLETE:\n\t\tpm8001_dbg(pm8001_ha, EVENT,\n\t\t\t   \"HW_EVENT_PORT_RESET_COMPLETE phyid:%#x port_id:%#x portstate:%#x\\n\",\n\t\t\t   phy_id, port_id, portstate);\n\t\tif (pm8001_ha->phy[phy_id].reset_completion) {\n\t\t\tpm8001_ha->phy[phy_id].port_reset_status =\n\t\t\t\t\tPORT_RESET_SUCCESS;\n\t\t\tcomplete(pm8001_ha->phy[phy_id].reset_completion);\n\t\t\tpm8001_ha->phy[phy_id].reset_completion = NULL;\n\t\t}\n\t\tphy->phy_attached = 1;\n\t\tphy->phy_state = PHY_STATE_LINK_UP_SPCV;\n\t\tport->port_state = portstate;\n\t\tbreak;\n\tcase EVENT_BROADCAST_ASYNCH_EVENT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"EVENT_BROADCAST_ASYNCH_EVENT\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO,\n\t\t\t   \"Unknown event portid:%d phyid:%d event:0x%x status:0x%x\\n\",\n\t\t\t   port_id, phy_id, eventType, status);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int mpi_phy_stop_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct phy_stop_resp *pPayload =\n\t\t(struct phy_stop_resp *)(piomb + 4);\n\tu32 status =\n\t\tle32_to_cpu(pPayload->status);\n\tu32 phyid =\n\t\tle32_to_cpu(pPayload->phyid) & 0xFF;\n\tstruct pm8001_phy *phy = &pm8001_ha->phy[phyid];\n\tpm8001_dbg(pm8001_ha, MSG, \"phy:0x%x status:0x%x\\n\",\n\t\t   phyid, status);\n\tif (status == PHY_STOP_SUCCESS ||\n\t\tstatus == PHY_STOP_ERR_DEVICE_ATTACHED) {\n\t\tphy->phy_state = PHY_LINK_DISABLE;\n\t\tphy->sas_phy.phy->negotiated_linkrate = SAS_PHY_DISABLED;\n\t\tphy->sas_phy.linkrate = SAS_PHY_DISABLED;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mpi_set_controller_config_resp(struct pm8001_hba_info *pm8001_ha,\n\t\t\tvoid *piomb)\n{\n\tstruct set_ctrl_cfg_resp *pPayload =\n\t\t\t(struct set_ctrl_cfg_resp *)(piomb + 4);\n\tu32 status = le32_to_cpu(pPayload->status);\n\tu32 err_qlfr_pgcd = le32_to_cpu(pPayload->err_qlfr_pgcd);\n\tu32 tag = le32_to_cpu(pPayload->tag);\n\n\tpm8001_dbg(pm8001_ha, MSG,\n\t\t   \"SET CONTROLLER RESP: status 0x%x qlfr_pgcd 0x%x\\n\",\n\t\t   status, err_qlfr_pgcd);\n\tpm8001_tag_free(pm8001_ha, tag);\n\n\treturn 0;\n}\n\n \nstatic int mpi_get_controller_config_resp(struct pm8001_hba_info *pm8001_ha,\n\t\t\tvoid *piomb)\n{\n\tpm8001_dbg(pm8001_ha, MSG, \" pm80xx_addition_functionality\\n\");\n\n\treturn 0;\n}\n\n \nstatic int mpi_get_phy_profile_resp(struct pm8001_hba_info *pm8001_ha,\n\t\t\tvoid *piomb)\n{\n\tpm8001_dbg(pm8001_ha, MSG, \" pm80xx_addition_functionality\\n\");\n\n\treturn 0;\n}\n\n \nstatic int mpi_flash_op_ext_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tpm8001_dbg(pm8001_ha, MSG, \" pm80xx_addition_functionality\\n\");\n\n\treturn 0;\n}\n\n \nstatic int mpi_set_phy_profile_resp(struct pm8001_hba_info *pm8001_ha,\n\t\t\tvoid *piomb)\n{\n\tu32 tag;\n\tu8 page_code;\n\tint rc = 0;\n\tstruct set_phy_profile_resp *pPayload =\n\t\t(struct set_phy_profile_resp *)(piomb + 4);\n\tu32 ppc_phyid = le32_to_cpu(pPayload->ppc_phyid);\n\tu32 status = le32_to_cpu(pPayload->status);\n\n\ttag = le32_to_cpu(pPayload->tag);\n\tpage_code = (u8)((ppc_phyid & 0xFF00) >> 8);\n\tif (status) {\n\t\t \n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"PhyProfile command failed  with status 0x%08X\\n\",\n\t\t\t   status);\n\t\trc = -1;\n\t} else {\n\t\tif (page_code != SAS_PHY_ANALOG_SETTINGS_PAGE) {\n\t\t\tpm8001_dbg(pm8001_ha, FAIL, \"Invalid page code 0x%X\\n\",\n\t\t\t\t   page_code);\n\t\t\trc = -1;\n\t\t}\n\t}\n\tpm8001_tag_free(pm8001_ha, tag);\n\treturn rc;\n}\n\n \nstatic int mpi_kek_management_resp(struct pm8001_hba_info *pm8001_ha,\n\t\t\tvoid *piomb)\n{\n\tstruct kek_mgmt_resp *pPayload = (struct kek_mgmt_resp *)(piomb + 4);\n\n\tu32 status = le32_to_cpu(pPayload->status);\n\tu32 kidx_new_curr_ksop = le32_to_cpu(pPayload->kidx_new_curr_ksop);\n\tu32 err_qlfr = le32_to_cpu(pPayload->err_qlfr);\n\n\tpm8001_dbg(pm8001_ha, MSG,\n\t\t   \"KEK MGMT RESP. Status 0x%x idx_ksop 0x%x err_qlfr 0x%x\\n\",\n\t\t   status, kidx_new_curr_ksop, err_qlfr);\n\n\treturn 0;\n}\n\n \nstatic int mpi_dek_management_resp(struct pm8001_hba_info *pm8001_ha,\n\t\t\tvoid *piomb)\n{\n\tpm8001_dbg(pm8001_ha, MSG, \" pm80xx_addition_functionality\\n\");\n\n\treturn 0;\n}\n\n \nstatic int ssp_coalesced_comp_resp(struct pm8001_hba_info *pm8001_ha,\n\t\t\tvoid *piomb)\n{\n\tpm8001_dbg(pm8001_ha, MSG, \" pm80xx_addition_functionality\\n\");\n\n\treturn 0;\n}\n\n \nstatic void process_one_iomb(struct pm8001_hba_info *pm8001_ha,\n\t\tstruct outbound_queue_table *circularQ, void *piomb)\n{\n\t__le32 pHeader = *(__le32 *)piomb;\n\tu32 opc = (u32)((le32_to_cpu(pHeader)) & 0xFFF);\n\n\tswitch (opc) {\n\tcase OPC_OUB_ECHO:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_ECHO\\n\");\n\t\tbreak;\n\tcase OPC_OUB_HW_EVENT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_HW_EVENT\\n\");\n\t\tmpi_hw_event(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_THERM_HW_EVENT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_THERMAL_EVENT\\n\");\n\t\tmpi_thermal_hw_event(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SSP_COMP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SSP_COMP\\n\");\n\t\tmpi_ssp_completion(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SMP_COMP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SMP_COMP\\n\");\n\t\tmpi_smp_completion(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_LOCAL_PHY_CNTRL:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_LOCAL_PHY_CNTRL\\n\");\n\t\tpm8001_mpi_local_phy_ctl(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_DEV_REGIST:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_DEV_REGIST\\n\");\n\t\tpm8001_mpi_reg_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_DEREG_DEV:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"unregister the device\\n\");\n\t\tpm8001_mpi_dereg_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_GET_DEV_HANDLE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_GET_DEV_HANDLE\\n\");\n\t\tbreak;\n\tcase OPC_OUB_SATA_COMP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SATA_COMP\\n\");\n\t\tmpi_sata_completion(pm8001_ha, circularQ, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SATA_EVENT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SATA_EVENT\\n\");\n\t\tmpi_sata_event(pm8001_ha, circularQ, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SSP_EVENT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SSP_EVENT\\n\");\n\t\tmpi_ssp_event(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_DEV_HANDLE_ARRIV:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_DEV_HANDLE_ARRIV\\n\");\n\t\t \n\t\tbreak;\n\tcase OPC_OUB_SSP_RECV_EVENT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SSP_RECV_EVENT\\n\");\n\t\t \n\t\tbreak;\n\tcase OPC_OUB_FW_FLASH_UPDATE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_FW_FLASH_UPDATE\\n\");\n\t\tpm8001_mpi_fw_flash_update_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_GPIO_RESPONSE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_GPIO_RESPONSE\\n\");\n\t\tbreak;\n\tcase OPC_OUB_GPIO_EVENT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_GPIO_EVENT\\n\");\n\t\tbreak;\n\tcase OPC_OUB_GENERAL_EVENT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_GENERAL_EVENT\\n\");\n\t\tpm8001_mpi_general_event(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SSP_ABORT_RSP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SSP_ABORT_RSP\\n\");\n\t\tpm8001_mpi_task_abort_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SATA_ABORT_RSP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SATA_ABORT_RSP\\n\");\n\t\tpm8001_mpi_task_abort_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SAS_DIAG_MODE_START_END:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"OPC_OUB_SAS_DIAG_MODE_START_END\\n\");\n\t\tbreak;\n\tcase OPC_OUB_SAS_DIAG_EXECUTE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SAS_DIAG_EXECUTE\\n\");\n\t\tbreak;\n\tcase OPC_OUB_GET_TIME_STAMP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_GET_TIME_STAMP\\n\");\n\t\tbreak;\n\tcase OPC_OUB_SAS_HW_EVENT_ACK:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SAS_HW_EVENT_ACK\\n\");\n\t\tbreak;\n\tcase OPC_OUB_PORT_CONTROL:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_PORT_CONTROL\\n\");\n\t\tbreak;\n\tcase OPC_OUB_SMP_ABORT_RSP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SMP_ABORT_RSP\\n\");\n\t\tpm8001_mpi_task_abort_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_GET_NVMD_DATA:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_GET_NVMD_DATA\\n\");\n\t\tpm8001_mpi_get_nvmd_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SET_NVMD_DATA:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SET_NVMD_DATA\\n\");\n\t\tpm8001_mpi_set_nvmd_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_DEVICE_HANDLE_REMOVAL:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_DEVICE_HANDLE_REMOVAL\\n\");\n\t\tbreak;\n\tcase OPC_OUB_SET_DEVICE_STATE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SET_DEVICE_STATE\\n\");\n\t\tpm8001_mpi_set_dev_state_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_GET_DEVICE_STATE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_GET_DEVICE_STATE\\n\");\n\t\tbreak;\n\tcase OPC_OUB_SET_DEV_INFO:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SET_DEV_INFO\\n\");\n\t\tbreak;\n\t \n\tcase OPC_OUB_PHY_START_RESP:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"OPC_OUB_PHY_START_RESP opcode:%x\\n\", opc);\n\t\tmpi_phy_start_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_PHY_STOP_RESP:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"OPC_OUB_PHY_STOP_RESP opcode:%x\\n\", opc);\n\t\tmpi_phy_stop_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SET_CONTROLLER_CONFIG:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"OPC_OUB_SET_CONTROLLER_CONFIG opcode:%x\\n\", opc);\n\t\tmpi_set_controller_config_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_GET_CONTROLLER_CONFIG:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"OPC_OUB_GET_CONTROLLER_CONFIG opcode:%x\\n\", opc);\n\t\tmpi_get_controller_config_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_GET_PHY_PROFILE:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"OPC_OUB_GET_PHY_PROFILE opcode:%x\\n\", opc);\n\t\tmpi_get_phy_profile_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_FLASH_OP_EXT:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"OPC_OUB_FLASH_OP_EXT opcode:%x\\n\", opc);\n\t\tmpi_flash_op_ext_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SET_PHY_PROFILE:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"OPC_OUB_SET_PHY_PROFILE opcode:%x\\n\", opc);\n\t\tmpi_set_phy_profile_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_KEK_MANAGEMENT_RESP:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"OPC_OUB_KEK_MANAGEMENT_RESP opcode:%x\\n\", opc);\n\t\tmpi_kek_management_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_DEK_MANAGEMENT_RESP:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"OPC_OUB_DEK_MANAGEMENT_RESP opcode:%x\\n\", opc);\n\t\tmpi_dek_management_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SSP_COALESCED_COMP_RESP:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"OPC_OUB_SSP_COALESCED_COMP_RESP opcode:%x\\n\", opc);\n\t\tssp_coalesced_comp_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO,\n\t\t\t   \"Unknown outbound Queue IOMB OPC = 0x%x\\n\", opc);\n\t\tbreak;\n\t}\n}\n\nstatic void print_scratchpad_registers(struct pm8001_hba_info *pm8001_ha)\n{\n\tpm8001_dbg(pm8001_ha, FAIL, \"MSGU_SCRATCH_PAD_0: 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_0));\n\tpm8001_dbg(pm8001_ha, FAIL, \"MSGU_SCRATCH_PAD_1:0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1));\n\tpm8001_dbg(pm8001_ha, FAIL, \"MSGU_SCRATCH_PAD_2: 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_2));\n\tpm8001_dbg(pm8001_ha, FAIL, \"MSGU_SCRATCH_PAD_3: 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_3));\n\tpm8001_dbg(pm8001_ha, FAIL, \"MSGU_HOST_SCRATCH_PAD_0: 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 0, MSGU_HOST_SCRATCH_PAD_0));\n\tpm8001_dbg(pm8001_ha, FAIL, \"MSGU_HOST_SCRATCH_PAD_1: 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 0, MSGU_HOST_SCRATCH_PAD_1));\n\tpm8001_dbg(pm8001_ha, FAIL, \"MSGU_HOST_SCRATCH_PAD_2: 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 0, MSGU_HOST_SCRATCH_PAD_2));\n\tpm8001_dbg(pm8001_ha, FAIL, \"MSGU_HOST_SCRATCH_PAD_3: 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 0, MSGU_HOST_SCRATCH_PAD_3));\n\tpm8001_dbg(pm8001_ha, FAIL, \"MSGU_HOST_SCRATCH_PAD_4: 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 0, MSGU_HOST_SCRATCH_PAD_4));\n\tpm8001_dbg(pm8001_ha, FAIL, \"MSGU_HOST_SCRATCH_PAD_5: 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 0, MSGU_HOST_SCRATCH_PAD_5));\n\tpm8001_dbg(pm8001_ha, FAIL, \"MSGU_RSVD_SCRATCH_PAD_0: 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_RSVD_0));\n\tpm8001_dbg(pm8001_ha, FAIL, \"MSGU_RSVD_SCRATCH_PAD_1: 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_RSVD_1));\n}\n\nstatic int process_oq(struct pm8001_hba_info *pm8001_ha, u8 vec)\n{\n\tstruct outbound_queue_table *circularQ;\n\tvoid *pMsg1 = NULL;\n\tu8 bc;\n\tu32 ret = MPI_IO_STATUS_FAIL;\n\tu32 regval;\n\n\t \n\tif (vec == (pm8001_ha->max_q_num - 1)) {\n\t\tu32 mipsall_ready;\n\n\t\tif (pm8001_ha->chip_id == chip_8008 ||\n\t\t    pm8001_ha->chip_id == chip_8009)\n\t\t\tmipsall_ready = SCRATCH_PAD_MIPSALL_READY_8PORT;\n\t\telse\n\t\t\tmipsall_ready = SCRATCH_PAD_MIPSALL_READY_16PORT;\n\n\t\tregval = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\n\t\tif ((regval & mipsall_ready) != mipsall_ready) {\n\t\t\tpm8001_ha->controller_fatal_error = true;\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"Firmware Fatal error! Regval:0x%x\\n\",\n\t\t\t\t   regval);\n\t\t\tpm8001_handle_event(pm8001_ha, NULL, IO_FATAL_ERROR);\n\t\t\tprint_scratchpad_registers(pm8001_ha);\n\t\t\treturn ret;\n\t\t} else {\n\t\t\t \n\t\t\tregval = pm8001_cr32(pm8001_ha, 0,\n\t\t\t\t\t     MSGU_SCRATCH_PAD_RSVD_0);\n\t\t\tswitch (regval) {\n\t\t\tcase NON_FATAL_SPBC_LBUS_ECC_ERR:\n\t\t\tcase NON_FATAL_BDMA_ERR:\n\t\t\tcase NON_FATAL_THERM_OVERTEMP_ERR:\n\t\t\t\t \n\t\t\t\tpm8001_cw32(pm8001_ha, 0,\n\t\t\t\t\t    MSGU_SCRATCH_PAD_RSVD_0,\n\t\t\t\t\t    0x00000000);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcircularQ = &pm8001_ha->outbnd_q_tbl[vec];\n\tspin_lock_irqsave(&circularQ->oq_lock, circularQ->lock_flags);\n\tdo {\n\t\t \n\t\tif (!circularQ->pi_virt)\n\t\t\tbreak;\n\t\tret = pm8001_mpi_msg_consume(pm8001_ha, circularQ, &pMsg1, &bc);\n\t\tif (MPI_IO_STATUS_SUCCESS == ret) {\n\t\t\t \n\t\t\tprocess_one_iomb(pm8001_ha, circularQ,\n\t\t\t\t\t\t(void *)(pMsg1 - 4));\n\t\t\t \n\t\t\tpm8001_mpi_msg_free_set(pm8001_ha, pMsg1,\n\t\t\t\t\t\t\tcircularQ, bc);\n\t\t}\n\t\tif (MPI_IO_STATUS_BUSY == ret) {\n\t\t\t \n\t\t\tcircularQ->producer_index =\n\t\t\t\tcpu_to_le32(pm8001_read_32(circularQ->pi_virt));\n\t\t\tif (le32_to_cpu(circularQ->producer_index) ==\n\t\t\t\tcircularQ->consumer_idx)\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t}\n\t} while (1);\n\tspin_unlock_irqrestore(&circularQ->oq_lock, circularQ->lock_flags);\n\treturn ret;\n}\n\n \nstatic const u8 data_dir_flags[] = {\n\t[DMA_BIDIRECTIONAL]\t= DATA_DIR_BYRECIPIENT,\t \n\t[DMA_TO_DEVICE]\t\t= DATA_DIR_OUT,\t\t \n\t[DMA_FROM_DEVICE]\t= DATA_DIR_IN,\t\t \n\t[DMA_NONE]\t\t= DATA_DIR_NONE,\t \n};\n\nstatic void build_smp_cmd(u32 deviceID, __le32 hTag,\n\t\t\tstruct smp_req *psmp_cmd, int mode, int length)\n{\n\tpsmp_cmd->tag = hTag;\n\tpsmp_cmd->device_id = cpu_to_le32(deviceID);\n\tif (mode == SMP_DIRECT) {\n\t\tlength = length - 4;  \n\t\tpsmp_cmd->len_ip_ir = cpu_to_le32(length << 16);\n\t} else {\n\t\tpsmp_cmd->len_ip_ir = cpu_to_le32(1|(1 << 1));\n\t}\n}\n\n \nstatic int pm80xx_chip_smp_req(struct pm8001_hba_info *pm8001_ha,\n\tstruct pm8001_ccb_info *ccb)\n{\n\tint elem, rc;\n\tstruct sas_task *task = ccb->task;\n\tstruct domain_device *dev = task->dev;\n\tstruct pm8001_device *pm8001_dev = dev->lldd_dev;\n\tstruct scatterlist *sg_req, *sg_resp, *smp_req;\n\tu32 req_len, resp_len;\n\tstruct smp_req smp_cmd;\n\tu32 opc;\n\tu32 i, length;\n\tu8 *payload;\n\tu8 *to;\n\n\tmemset(&smp_cmd, 0, sizeof(smp_cmd));\n\t \n\tsg_req = &task->smp_task.smp_req;\n\telem = dma_map_sg(pm8001_ha->dev, sg_req, 1, DMA_TO_DEVICE);\n\tif (!elem)\n\t\treturn -ENOMEM;\n\treq_len = sg_dma_len(sg_req);\n\n\tsg_resp = &task->smp_task.smp_resp;\n\telem = dma_map_sg(pm8001_ha->dev, sg_resp, 1, DMA_FROM_DEVICE);\n\tif (!elem) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tresp_len = sg_dma_len(sg_resp);\n\t \n\tif ((req_len & 0x3) || (resp_len & 0x3)) {\n\t\trc = -EINVAL;\n\t\tgoto err_out_2;\n\t}\n\n\topc = OPC_INB_SMP_REQUEST;\n\tsmp_cmd.tag = cpu_to_le32(ccb->ccb_tag);\n\n\tlength = sg_req->length;\n\tpm8001_dbg(pm8001_ha, IO, \"SMP Frame Length %d\\n\", sg_req->length);\n\tif (!(length - 8))\n\t\tpm8001_ha->smp_exp_mode = SMP_DIRECT;\n\telse\n\t\tpm8001_ha->smp_exp_mode = SMP_INDIRECT;\n\n\n\tsmp_req = &task->smp_task.smp_req;\n\tto = kmap_atomic(sg_page(smp_req));\n\tpayload = to + smp_req->offset;\n\n\t \n\tif (pm8001_ha->smp_exp_mode == SMP_INDIRECT) {\n\t\tpm8001_dbg(pm8001_ha, IO, \"SMP REQUEST INDIRECT MODE\\n\");\n\t\t \n\t\tfor (i = 0; i < 4; i++)\n\t\t\tsmp_cmd.smp_req16[i] = *(payload + i);\n\t\t \n\t\tsmp_cmd.long_smp_req.long_req_addr =\n\t\t\tcpu_to_le64((u64)sg_dma_address\n\t\t\t\t(&task->smp_task.smp_req) + 4);\n\t\t \n\t\tsmp_cmd.long_smp_req.long_req_size =\n\t\t\tcpu_to_le32((u32)sg_dma_len(&task->smp_task.smp_req)-8);\n\t\tsmp_cmd.long_smp_req.long_resp_addr =\n\t\t\t\tcpu_to_le64((u64)sg_dma_address\n\t\t\t\t\t(&task->smp_task.smp_resp));\n\t\tsmp_cmd.long_smp_req.long_resp_size =\n\t\t\t\tcpu_to_le32((u32)sg_dma_len\n\t\t\t\t\t(&task->smp_task.smp_resp)-4);\n\t} else {  \n\t\tsmp_cmd.long_smp_req.long_req_addr =\n\t\t\tcpu_to_le64((u64)sg_dma_address\n\t\t\t\t\t(&task->smp_task.smp_req));\n\t\tsmp_cmd.long_smp_req.long_req_size =\n\t\t\tcpu_to_le32((u32)sg_dma_len(&task->smp_task.smp_req)-4);\n\t\tsmp_cmd.long_smp_req.long_resp_addr =\n\t\t\tcpu_to_le64((u64)sg_dma_address\n\t\t\t\t(&task->smp_task.smp_resp));\n\t\tsmp_cmd.long_smp_req.long_resp_size =\n\t\t\tcpu_to_le32\n\t\t\t((u32)sg_dma_len(&task->smp_task.smp_resp)-4);\n\t}\n\tif (pm8001_ha->smp_exp_mode == SMP_DIRECT) {\n\t\tpm8001_dbg(pm8001_ha, IO, \"SMP REQUEST DIRECT MODE\\n\");\n\t\tfor (i = 0; i < length; i++)\n\t\t\tif (i < 16) {\n\t\t\t\tsmp_cmd.smp_req16[i] = *(payload + i);\n\t\t\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t\t\t   \"Byte[%d]:%x (DMA data:%x)\\n\",\n\t\t\t\t\t   i, smp_cmd.smp_req16[i],\n\t\t\t\t\t   *(payload));\n\t\t\t} else {\n\t\t\t\tsmp_cmd.smp_req[i] = *(payload + i);\n\t\t\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t\t\t   \"Byte[%d]:%x (DMA data:%x)\\n\",\n\t\t\t\t\t   i, smp_cmd.smp_req[i],\n\t\t\t\t\t   *(payload));\n\t\t\t}\n\t}\n\tkunmap_atomic(to);\n\tbuild_smp_cmd(pm8001_dev->device_id, smp_cmd.tag,\n\t\t\t\t&smp_cmd, pm8001_ha->smp_exp_mode, length);\n\trc = pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &smp_cmd,\n\t\t\t\t  sizeof(smp_cmd), 0);\n\tif (rc)\n\t\tgoto err_out_2;\n\treturn 0;\n\nerr_out_2:\n\tdma_unmap_sg(pm8001_ha->dev, &ccb->task->smp_task.smp_resp, 1,\n\t\t\tDMA_FROM_DEVICE);\nerr_out:\n\tdma_unmap_sg(pm8001_ha->dev, &ccb->task->smp_task.smp_req, 1,\n\t\t\tDMA_TO_DEVICE);\n\treturn rc;\n}\n\nstatic int check_enc_sas_cmd(struct sas_task *task)\n{\n\tu8 cmd = task->ssp_task.cmd->cmnd[0];\n\n\tif (cmd == READ_10 || cmd == WRITE_10 || cmd == WRITE_VERIFY)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int check_enc_sat_cmd(struct sas_task *task)\n{\n\tint ret = 0;\n\tswitch (task->ata_task.fis.command) {\n\tcase ATA_CMD_FPDMA_READ:\n\tcase ATA_CMD_READ_EXT:\n\tcase ATA_CMD_READ:\n\tcase ATA_CMD_FPDMA_WRITE:\n\tcase ATA_CMD_WRITE_EXT:\n\tcase ATA_CMD_WRITE:\n\tcase ATA_CMD_PIO_READ:\n\tcase ATA_CMD_PIO_READ_EXT:\n\tcase ATA_CMD_PIO_WRITE:\n\tcase ATA_CMD_PIO_WRITE_EXT:\n\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic u32 pm80xx_chip_get_q_index(struct sas_task *task)\n{\n\tstruct request *rq = sas_task_find_rq(task);\n\n\tif (!rq)\n\t\treturn 0;\n\n\treturn blk_mq_unique_tag_to_hwq(blk_mq_unique_tag(rq));\n}\n\n \nstatic int pm80xx_chip_ssp_io_req(struct pm8001_hba_info *pm8001_ha,\n\tstruct pm8001_ccb_info *ccb)\n{\n\tstruct sas_task *task = ccb->task;\n\tstruct domain_device *dev = task->dev;\n\tstruct pm8001_device *pm8001_dev = dev->lldd_dev;\n\tstruct ssp_ini_io_start_req ssp_cmd;\n\tu32 tag = ccb->ccb_tag;\n\tu64 phys_addr, end_addr;\n\tu32 end_addr_high, end_addr_low;\n\tu32 q_index;\n\tu32 opc = OPC_INB_SSPINIIOSTART;\n\n\tmemset(&ssp_cmd, 0, sizeof(ssp_cmd));\n\tmemcpy(ssp_cmd.ssp_iu.lun, task->ssp_task.LUN, 8);\n\n\t \n\tssp_cmd.dad_dir_m_tlr =\n\t\tcpu_to_le32(data_dir_flags[task->data_dir] << 8 | 0x0);\n\tssp_cmd.data_len = cpu_to_le32(task->total_xfer_len);\n\tssp_cmd.device_id = cpu_to_le32(pm8001_dev->device_id);\n\tssp_cmd.tag = cpu_to_le32(tag);\n\tssp_cmd.ssp_iu.efb_prio_attr |= (task->ssp_task.task_attr & 7);\n\tmemcpy(ssp_cmd.ssp_iu.cdb, task->ssp_task.cmd->cmnd,\n\t\t       task->ssp_task.cmd->cmd_len);\n\tq_index = pm80xx_chip_get_q_index(task);\n\n\t \n\tif (pm8001_ha->chip->encrypt &&\n\t\t!(pm8001_ha->encrypt_info.status) && check_enc_sas_cmd(task)) {\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"Encryption enabled.Sending Encrypt SAS command 0x%x\\n\",\n\t\t\t   task->ssp_task.cmd->cmnd[0]);\n\t\topc = OPC_INB_SSP_INI_DIF_ENC_IO;\n\t\t \n\t\tssp_cmd.dad_dir_m_tlr =\tcpu_to_le32\n\t\t\t((data_dir_flags[task->data_dir] << 8) | 0x20 | 0x0);\n\n\t\t \n\t\tif (task->num_scatter > 1) {\n\t\t\tpm8001_chip_make_sg(task->scatter,\n\t\t\t\t\t\tccb->n_elem, ccb->buf_prd);\n\t\t\tphys_addr = ccb->ccb_dma_handle;\n\t\t\tssp_cmd.enc_addr_low =\n\t\t\t\tcpu_to_le32(lower_32_bits(phys_addr));\n\t\t\tssp_cmd.enc_addr_high =\n\t\t\t\tcpu_to_le32(upper_32_bits(phys_addr));\n\t\t\tssp_cmd.enc_esgl = cpu_to_le32(1<<31);\n\t\t} else if (task->num_scatter == 1) {\n\t\t\tu64 dma_addr = sg_dma_address(task->scatter);\n\n\t\t\tssp_cmd.enc_addr_low =\n\t\t\t\tcpu_to_le32(lower_32_bits(dma_addr));\n\t\t\tssp_cmd.enc_addr_high =\n\t\t\t\tcpu_to_le32(upper_32_bits(dma_addr));\n\t\t\tssp_cmd.enc_len = cpu_to_le32(task->total_xfer_len);\n\t\t\tssp_cmd.enc_esgl = 0;\n\n\t\t\t \n\t\t\tend_addr = dma_addr + le32_to_cpu(ssp_cmd.enc_len) - 1;\n\t\t\tend_addr_low = lower_32_bits(end_addr);\n\t\t\tend_addr_high = upper_32_bits(end_addr);\n\n\t\t\tif (end_addr_high != le32_to_cpu(ssp_cmd.enc_addr_high)) {\n\t\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t\t   \"The sg list address start_addr=0x%016llx data_len=0x%x end_addr_high=0x%08x end_addr_low=0x%08x has crossed 4G boundary\\n\",\n\t\t\t\t\t   dma_addr,\n\t\t\t\t\t   le32_to_cpu(ssp_cmd.enc_len),\n\t\t\t\t\t   end_addr_high, end_addr_low);\n\t\t\t\tpm8001_chip_make_sg(task->scatter, 1,\n\t\t\t\t\tccb->buf_prd);\n\t\t\t\tphys_addr = ccb->ccb_dma_handle;\n\t\t\t\tssp_cmd.enc_addr_low =\n\t\t\t\t\tcpu_to_le32(lower_32_bits(phys_addr));\n\t\t\t\tssp_cmd.enc_addr_high =\n\t\t\t\t\tcpu_to_le32(upper_32_bits(phys_addr));\n\t\t\t\tssp_cmd.enc_esgl = cpu_to_le32(1U<<31);\n\t\t\t}\n\t\t} else if (task->num_scatter == 0) {\n\t\t\tssp_cmd.enc_addr_low = 0;\n\t\t\tssp_cmd.enc_addr_high = 0;\n\t\t\tssp_cmd.enc_len = cpu_to_le32(task->total_xfer_len);\n\t\t\tssp_cmd.enc_esgl = 0;\n\t\t}\n\n\t\t \n\t\tssp_cmd.key_cmode = cpu_to_le32(0x6 << 4);\n\n\t\t \n\t\tssp_cmd.twk_val0 = cpu_to_le32((task->ssp_task.cmd->cmnd[2] << 24) |\n\t\t\t\t\t\t(task->ssp_task.cmd->cmnd[3] << 16) |\n\t\t\t\t\t\t(task->ssp_task.cmd->cmnd[4] << 8) |\n\t\t\t\t\t\t(task->ssp_task.cmd->cmnd[5]));\n\t} else {\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"Sending Normal SAS command 0x%x inb q %x\\n\",\n\t\t\t   task->ssp_task.cmd->cmnd[0], q_index);\n\t\t \n\t\tif (task->num_scatter > 1) {\n\t\t\tpm8001_chip_make_sg(task->scatter, ccb->n_elem,\n\t\t\t\t\tccb->buf_prd);\n\t\t\tphys_addr = ccb->ccb_dma_handle;\n\t\t\tssp_cmd.addr_low =\n\t\t\t\tcpu_to_le32(lower_32_bits(phys_addr));\n\t\t\tssp_cmd.addr_high =\n\t\t\t\tcpu_to_le32(upper_32_bits(phys_addr));\n\t\t\tssp_cmd.esgl = cpu_to_le32(1<<31);\n\t\t} else if (task->num_scatter == 1) {\n\t\t\tu64 dma_addr = sg_dma_address(task->scatter);\n\n\t\t\tssp_cmd.addr_low = cpu_to_le32(lower_32_bits(dma_addr));\n\t\t\tssp_cmd.addr_high =\n\t\t\t\tcpu_to_le32(upper_32_bits(dma_addr));\n\t\t\tssp_cmd.len = cpu_to_le32(task->total_xfer_len);\n\t\t\tssp_cmd.esgl = 0;\n\n\t\t\t \n\t\t\tend_addr = dma_addr + le32_to_cpu(ssp_cmd.len) - 1;\n\t\t\tend_addr_low = lower_32_bits(end_addr);\n\t\t\tend_addr_high = upper_32_bits(end_addr);\n\t\t\tif (end_addr_high != le32_to_cpu(ssp_cmd.addr_high)) {\n\t\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t\t   \"The sg list address start_addr=0x%016llx data_len=0x%x end_addr_high=0x%08x end_addr_low=0x%08x has crossed 4G boundary\\n\",\n\t\t\t\t\t   dma_addr,\n\t\t\t\t\t   le32_to_cpu(ssp_cmd.len),\n\t\t\t\t\t   end_addr_high, end_addr_low);\n\t\t\t\tpm8001_chip_make_sg(task->scatter, 1,\n\t\t\t\t\tccb->buf_prd);\n\t\t\t\tphys_addr = ccb->ccb_dma_handle;\n\t\t\t\tssp_cmd.addr_low =\n\t\t\t\t\tcpu_to_le32(lower_32_bits(phys_addr));\n\t\t\t\tssp_cmd.addr_high =\n\t\t\t\t\tcpu_to_le32(upper_32_bits(phys_addr));\n\t\t\t\tssp_cmd.esgl = cpu_to_le32(1<<31);\n\t\t\t}\n\t\t} else if (task->num_scatter == 0) {\n\t\t\tssp_cmd.addr_low = 0;\n\t\t\tssp_cmd.addr_high = 0;\n\t\t\tssp_cmd.len = cpu_to_le32(task->total_xfer_len);\n\t\t\tssp_cmd.esgl = 0;\n\t\t}\n\t}\n\n\treturn pm8001_mpi_build_cmd(pm8001_ha, q_index, opc, &ssp_cmd,\n\t\t\t\t    sizeof(ssp_cmd), q_index);\n}\n\nstatic int pm80xx_chip_sata_req(struct pm8001_hba_info *pm8001_ha,\n\tstruct pm8001_ccb_info *ccb)\n{\n\tstruct sas_task *task = ccb->task;\n\tstruct domain_device *dev = task->dev;\n\tstruct pm8001_device *pm8001_ha_dev = dev->lldd_dev;\n\tstruct ata_queued_cmd *qc = task->uldd_task;\n\tu32 tag = ccb->ccb_tag, q_index;\n\tstruct sata_start_req sata_cmd;\n\tu32 hdr_tag, ncg_tag = 0;\n\tu64 phys_addr, end_addr;\n\tu32 end_addr_high, end_addr_low;\n\tu32 ATAP = 0x0;\n\tu32 dir, retfis = 0;\n\tu32 opc = OPC_INB_SATA_HOST_OPSTART;\n\tmemset(&sata_cmd, 0, sizeof(sata_cmd));\n\n\tq_index = pm80xx_chip_get_q_index(task);\n\n\tif (task->data_dir == DMA_NONE && !task->ata_task.use_ncq) {\n\t\tATAP = 0x04;  \n\t\tpm8001_dbg(pm8001_ha, IO, \"no data\\n\");\n\t} else if (likely(!task->ata_task.device_control_reg_update)) {\n\t\tif (task->ata_task.use_ncq &&\n\t\t    dev->sata_dev.class != ATA_DEV_ATAPI) {\n\t\t\tATAP = 0x07;  \n\t\t\tpm8001_dbg(pm8001_ha, IO, \"FPDMA\\n\");\n\t\t} else if (task->ata_task.dma_xfer) {\n\t\t\tATAP = 0x06;  \n\t\t\tpm8001_dbg(pm8001_ha, IO, \"DMA\\n\");\n\t\t} else {\n\t\t\tATAP = 0x05;  \n\t\t\tpm8001_dbg(pm8001_ha, IO, \"PIO\\n\");\n\t\t}\n\t}\n\tif (task->ata_task.use_ncq && pm8001_get_ncq_tag(task, &hdr_tag)) {\n\t\ttask->ata_task.fis.sector_count |= (u8) (hdr_tag << 3);\n\t\tncg_tag = hdr_tag;\n\t}\n\tdir = data_dir_flags[task->data_dir] << 8;\n\tsata_cmd.tag = cpu_to_le32(tag);\n\tsata_cmd.device_id = cpu_to_le32(pm8001_ha_dev->device_id);\n\tsata_cmd.data_len = cpu_to_le32(task->total_xfer_len);\n\tif (task->ata_task.return_fis_on_success)\n\t\tretfis = 1;\n\tsata_cmd.sata_fis = task->ata_task.fis;\n\tif (likely(!task->ata_task.device_control_reg_update))\n\t\tsata_cmd.sata_fis.flags |= 0x80; \n\tsata_cmd.sata_fis.flags &= 0xF0; \n\n\t \n\tif (pm8001_ha->chip->encrypt &&\n\t\t!(pm8001_ha->encrypt_info.status) && check_enc_sat_cmd(task)) {\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"Encryption enabled.Sending Encrypt SATA cmd 0x%x\\n\",\n\t\t\t   sata_cmd.sata_fis.command);\n\t\topc = OPC_INB_SATA_DIF_ENC_IO;\n\t\t \n\t\tsata_cmd.retfis_ncqtag_atap_dir_m_dad =\n\t\t\tcpu_to_le32((retfis << 24) | ((ncg_tag & 0xff) << 16) |\n\t\t\t\t    ((ATAP & 0x3f) << 10) | 0x20 | dir);\n\t\t \n\t\tif (task->num_scatter > 1) {\n\t\t\tpm8001_chip_make_sg(task->scatter,\n\t\t\t\t\t\tccb->n_elem, ccb->buf_prd);\n\t\t\tphys_addr = ccb->ccb_dma_handle;\n\t\t\tsata_cmd.enc_addr_low =\n\t\t\t\tcpu_to_le32(lower_32_bits(phys_addr));\n\t\t\tsata_cmd.enc_addr_high =\n\t\t\t\tcpu_to_le32(upper_32_bits(phys_addr));\n\t\t\tsata_cmd.enc_esgl = cpu_to_le32(1 << 31);\n\t\t} else if (task->num_scatter == 1) {\n\t\t\tu64 dma_addr = sg_dma_address(task->scatter);\n\n\t\t\tsata_cmd.enc_addr_low =\n\t\t\t\tcpu_to_le32(lower_32_bits(dma_addr));\n\t\t\tsata_cmd.enc_addr_high =\n\t\t\t\tcpu_to_le32(upper_32_bits(dma_addr));\n\t\t\tsata_cmd.enc_len = cpu_to_le32(task->total_xfer_len);\n\t\t\tsata_cmd.enc_esgl = 0;\n\n\t\t\t \n\t\t\tend_addr = dma_addr + le32_to_cpu(sata_cmd.enc_len) - 1;\n\t\t\tend_addr_low = lower_32_bits(end_addr);\n\t\t\tend_addr_high = upper_32_bits(end_addr);\n\t\t\tif (end_addr_high != le32_to_cpu(sata_cmd.enc_addr_high)) {\n\t\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t\t   \"The sg list address start_addr=0x%016llx data_len=0x%x end_addr_high=0x%08x end_addr_low=0x%08x has crossed 4G boundary\\n\",\n\t\t\t\t\t   dma_addr,\n\t\t\t\t\t   le32_to_cpu(sata_cmd.enc_len),\n\t\t\t\t\t   end_addr_high, end_addr_low);\n\t\t\t\tpm8001_chip_make_sg(task->scatter, 1,\n\t\t\t\t\tccb->buf_prd);\n\t\t\t\tphys_addr = ccb->ccb_dma_handle;\n\t\t\t\tsata_cmd.enc_addr_low =\n\t\t\t\t\tcpu_to_le32(lower_32_bits(phys_addr));\n\t\t\t\tsata_cmd.enc_addr_high =\n\t\t\t\t\tcpu_to_le32(upper_32_bits(phys_addr));\n\t\t\t\tsata_cmd.enc_esgl =\n\t\t\t\t\tcpu_to_le32(1 << 31);\n\t\t\t}\n\t\t} else if (task->num_scatter == 0) {\n\t\t\tsata_cmd.enc_addr_low = 0;\n\t\t\tsata_cmd.enc_addr_high = 0;\n\t\t\tsata_cmd.enc_len = cpu_to_le32(task->total_xfer_len);\n\t\t\tsata_cmd.enc_esgl = 0;\n\t\t}\n\t\t \n\t\tsata_cmd.key_index_mode = cpu_to_le32(0x6 << 4);\n\n\t\t \n\t\tsata_cmd.twk_val0 =\n\t\t\tcpu_to_le32((sata_cmd.sata_fis.lbal_exp << 24) |\n\t\t\t\t\t(sata_cmd.sata_fis.lbah << 16) |\n\t\t\t\t\t(sata_cmd.sata_fis.lbam << 8) |\n\t\t\t\t\t(sata_cmd.sata_fis.lbal));\n\t\tsata_cmd.twk_val1 =\n\t\t\tcpu_to_le32((sata_cmd.sata_fis.lbah_exp << 8) |\n\t\t\t\t\t (sata_cmd.sata_fis.lbam_exp));\n\t} else {\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"Sending Normal SATA command 0x%x inb %x\\n\",\n\t\t\t   sata_cmd.sata_fis.command, q_index);\n\t\t \n\t\tsata_cmd.retfis_ncqtag_atap_dir_m_dad =\n\t\t\tcpu_to_le32((retfis << 24) | ((ncg_tag & 0xff) << 16) |\n\t\t\t\t    ((ATAP & 0x3f) << 10) | dir);\n\t\t \n\t\tif (task->num_scatter > 1) {\n\t\t\tpm8001_chip_make_sg(task->scatter,\n\t\t\t\t\tccb->n_elem, ccb->buf_prd);\n\t\t\tphys_addr = ccb->ccb_dma_handle;\n\t\t\tsata_cmd.addr_low = lower_32_bits(phys_addr);\n\t\t\tsata_cmd.addr_high = upper_32_bits(phys_addr);\n\t\t\tsata_cmd.esgl = cpu_to_le32(1U << 31);\n\t\t} else if (task->num_scatter == 1) {\n\t\t\tu64 dma_addr = sg_dma_address(task->scatter);\n\n\t\t\tsata_cmd.addr_low = lower_32_bits(dma_addr);\n\t\t\tsata_cmd.addr_high = upper_32_bits(dma_addr);\n\t\t\tsata_cmd.len = cpu_to_le32(task->total_xfer_len);\n\t\t\tsata_cmd.esgl = 0;\n\n\t\t\t \n\t\t\tend_addr = dma_addr + le32_to_cpu(sata_cmd.len) - 1;\n\t\t\tend_addr_low = lower_32_bits(end_addr);\n\t\t\tend_addr_high = upper_32_bits(end_addr);\n\t\t\tif (end_addr_high != sata_cmd.addr_high) {\n\t\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t\t   \"The sg list address start_addr=0x%016llx data_len=0x%xend_addr_high=0x%08x end_addr_low=0x%08x has crossed 4G boundary\\n\",\n\t\t\t\t\t   dma_addr,\n\t\t\t\t\t   le32_to_cpu(sata_cmd.len),\n\t\t\t\t\t   end_addr_high, end_addr_low);\n\t\t\t\tpm8001_chip_make_sg(task->scatter, 1,\n\t\t\t\t\tccb->buf_prd);\n\t\t\t\tphys_addr = ccb->ccb_dma_handle;\n\t\t\t\tsata_cmd.addr_low = lower_32_bits(phys_addr);\n\t\t\t\tsata_cmd.addr_high = upper_32_bits(phys_addr);\n\t\t\t\tsata_cmd.esgl = cpu_to_le32(1U << 31);\n\t\t\t}\n\t\t} else if (task->num_scatter == 0) {\n\t\t\tsata_cmd.addr_low = 0;\n\t\t\tsata_cmd.addr_high = 0;\n\t\t\tsata_cmd.len = cpu_to_le32(task->total_xfer_len);\n\t\t\tsata_cmd.esgl = 0;\n\t\t}\n\n\t\t \n\t\tsata_cmd.atapi_scsi_cdb[0] =\n\t\t\tcpu_to_le32(((task->ata_task.atapi_packet[0]) |\n\t\t\t\t     (task->ata_task.atapi_packet[1] << 8) |\n\t\t\t\t     (task->ata_task.atapi_packet[2] << 16) |\n\t\t\t\t     (task->ata_task.atapi_packet[3] << 24)));\n\t\tsata_cmd.atapi_scsi_cdb[1] =\n\t\t\tcpu_to_le32(((task->ata_task.atapi_packet[4]) |\n\t\t\t\t     (task->ata_task.atapi_packet[5] << 8) |\n\t\t\t\t     (task->ata_task.atapi_packet[6] << 16) |\n\t\t\t\t     (task->ata_task.atapi_packet[7] << 24)));\n\t\tsata_cmd.atapi_scsi_cdb[2] =\n\t\t\tcpu_to_le32(((task->ata_task.atapi_packet[8]) |\n\t\t\t\t     (task->ata_task.atapi_packet[9] << 8) |\n\t\t\t\t     (task->ata_task.atapi_packet[10] << 16) |\n\t\t\t\t     (task->ata_task.atapi_packet[11] << 24)));\n\t\tsata_cmd.atapi_scsi_cdb[3] =\n\t\t\tcpu_to_le32(((task->ata_task.atapi_packet[12]) |\n\t\t\t\t     (task->ata_task.atapi_packet[13] << 8) |\n\t\t\t\t     (task->ata_task.atapi_packet[14] << 16) |\n\t\t\t\t     (task->ata_task.atapi_packet[15] << 24)));\n\t}\n\n\ttrace_pm80xx_request_issue(pm8001_ha->id,\n\t\t\t\tccb->device ? ccb->device->attached_phy : PM8001_MAX_PHYS,\n\t\t\t\tccb->ccb_tag, opc,\n\t\t\t\tqc ? qc->tf.command : 0, \n\t\t\t\tccb->device ? atomic_read(&ccb->device->running_req) : 0);\n\treturn pm8001_mpi_build_cmd(pm8001_ha, q_index, opc, &sata_cmd,\n\t\t\t\t    sizeof(sata_cmd), q_index);\n}\n\n \nstatic int\npm80xx_chip_phy_start_req(struct pm8001_hba_info *pm8001_ha, u8 phy_id)\n{\n\tstruct phy_start_req payload;\n\tu32 tag = 0x01;\n\tu32 opcode = OPC_INB_PHYSTART;\n\n\tmemset(&payload, 0, sizeof(payload));\n\tpayload.tag = cpu_to_le32(tag);\n\n\tpm8001_dbg(pm8001_ha, INIT, \"PHY START REQ for phy_id %d\\n\", phy_id);\n\n\tpayload.ase_sh_lm_slr_phyid = cpu_to_le32(SPINHOLD_DISABLE |\n\t\t\tLINKMODE_AUTO | pm8001_ha->link_rate | phy_id);\n\t \n\t \n\n\tpayload.sas_identify.dev_type = SAS_END_DEVICE;\n\tpayload.sas_identify.initiator_bits = SAS_PROTOCOL_ALL;\n\tmemcpy(payload.sas_identify.sas_addr,\n\t\t&pm8001_ha->phy[phy_id].dev_sas_addr, SAS_ADDR_SIZE);\n\tpayload.sas_identify.phy_id = phy_id;\n\n\treturn pm8001_mpi_build_cmd(pm8001_ha, 0, opcode, &payload,\n\t\t\t\t    sizeof(payload), 0);\n}\n\n \nstatic int pm80xx_chip_phy_stop_req(struct pm8001_hba_info *pm8001_ha,\n\tu8 phy_id)\n{\n\tstruct phy_stop_req payload;\n\tu32 tag = 0x01;\n\tu32 opcode = OPC_INB_PHYSTOP;\n\n\tmemset(&payload, 0, sizeof(payload));\n\tpayload.tag = cpu_to_le32(tag);\n\tpayload.phy_id = cpu_to_le32(phy_id);\n\n\treturn pm8001_mpi_build_cmd(pm8001_ha, 0, opcode, &payload,\n\t\t\t\t    sizeof(payload), 0);\n}\n\n \nstatic int pm80xx_chip_reg_dev_req(struct pm8001_hba_info *pm8001_ha,\n\tstruct pm8001_device *pm8001_dev, u32 flag)\n{\n\tstruct reg_dev_req payload;\n\tu32\topc;\n\tu32 stp_sspsmp_sata = 0x4;\n\tu32 linkrate, phy_id;\n\tint rc;\n\tstruct pm8001_ccb_info *ccb;\n\tu8 retryFlag = 0x1;\n\tu16 firstBurstSize = 0;\n\tu16 ITNT = 2000;\n\tstruct domain_device *dev = pm8001_dev->sas_device;\n\tstruct domain_device *parent_dev = dev->parent;\n\tstruct pm8001_port *port = dev->port->lldd_port;\n\n\tmemset(&payload, 0, sizeof(payload));\n\tccb = pm8001_ccb_alloc(pm8001_ha, pm8001_dev, NULL);\n\tif (!ccb)\n\t\treturn -SAS_QUEUE_FULL;\n\n\tpayload.tag = cpu_to_le32(ccb->ccb_tag);\n\n\tif (flag == 1) {\n\t\tstp_sspsmp_sata = 0x02;  \n\t} else {\n\t\tif (pm8001_dev->dev_type == SAS_SATA_DEV)\n\t\t\tstp_sspsmp_sata = 0x00;  \n\t\telse if (pm8001_dev->dev_type == SAS_END_DEVICE ||\n\t\t\tdev_is_expander(pm8001_dev->dev_type))\n\t\t\tstp_sspsmp_sata = 0x01;  \n\t}\n\tif (parent_dev && dev_is_expander(parent_dev->dev_type))\n\t\tphy_id = parent_dev->ex_dev.ex_phy->phy_id;\n\telse\n\t\tphy_id = pm8001_dev->attached_phy;\n\n\topc = OPC_INB_REG_DEV;\n\n\tlinkrate = (pm8001_dev->sas_device->linkrate < dev->port->linkrate) ?\n\t\t\tpm8001_dev->sas_device->linkrate : dev->port->linkrate;\n\n\tpayload.phyid_portid =\n\t\tcpu_to_le32(((port->port_id) & 0xFF) |\n\t\t((phy_id & 0xFF) << 8));\n\n\tpayload.dtype_dlr_mcn_ir_retry = cpu_to_le32((retryFlag & 0x01) |\n\t\t((linkrate & 0x0F) << 24) |\n\t\t((stp_sspsmp_sata & 0x03) << 28));\n\tpayload.firstburstsize_ITNexustimeout =\n\t\tcpu_to_le32(ITNT | (firstBurstSize * 0x10000));\n\n\tmemcpy(payload.sas_addr, pm8001_dev->sas_device->sas_addr,\n\t\tSAS_ADDR_SIZE);\n\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"register device req phy_id 0x%x port_id 0x%x\\n\", phy_id,\n\t\t   (port->port_id & 0xFF));\n\trc = pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &payload,\n\t\t\tsizeof(payload), 0);\n\tif (rc)\n\t\tpm8001_ccb_free(pm8001_ha, ccb);\n\n\treturn rc;\n}\n\n \nstatic int pm80xx_chip_phy_ctl_req(struct pm8001_hba_info *pm8001_ha,\n\tu32 phyId, u32 phy_op)\n{\n\tu32 tag;\n\tint rc;\n\tstruct local_phy_ctl_req payload;\n\tu32 opc = OPC_INB_LOCAL_PHY_CONTROL;\n\n\tmemset(&payload, 0, sizeof(payload));\n\trc = pm8001_tag_alloc(pm8001_ha, &tag);\n\tif (rc)\n\t\treturn rc;\n\n\tpayload.tag = cpu_to_le32(tag);\n\tpayload.phyop_phyid =\n\t\tcpu_to_le32(((phy_op & 0xFF) << 8) | (phyId & 0xFF));\n\n\trc = pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &payload,\n\t\t\t\t  sizeof(payload), 0);\n\tif (rc)\n\t\tpm8001_tag_free(pm8001_ha, tag);\n\n\treturn rc;\n}\n\nstatic u32 pm80xx_chip_is_our_interrupt(struct pm8001_hba_info *pm8001_ha)\n{\n#ifdef PM8001_USE_MSIX\n\treturn 1;\n#else\n\tu32 value;\n\n\tvalue = pm8001_cr32(pm8001_ha, 0, MSGU_ODR);\n\tif (value)\n\t\treturn 1;\n\treturn 0;\n#endif\n}\n\n \nstatic irqreturn_t\npm80xx_chip_isr(struct pm8001_hba_info *pm8001_ha, u8 vec)\n{\n\tpm80xx_chip_interrupt_disable(pm8001_ha, vec);\n\tpm8001_dbg(pm8001_ha, DEVIO,\n\t\t   \"irq vec %d, ODMR:0x%x\\n\",\n\t\t   vec, pm8001_cr32(pm8001_ha, 0, 0x30));\n\tprocess_oq(pm8001_ha, vec);\n\tpm80xx_chip_interrupt_enable(pm8001_ha, vec);\n\treturn IRQ_HANDLED;\n}\n\nstatic void mpi_set_phy_profile_req(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t    u32 operation, u32 phyid,\n\t\t\t\t    u32 length, u32 *buf)\n{\n\tu32 tag, i, j = 0;\n\tint rc;\n\tstruct set_phy_profile_req payload;\n\tu32 opc = OPC_INB_SET_PHY_PROFILE;\n\n\tmemset(&payload, 0, sizeof(payload));\n\trc = pm8001_tag_alloc(pm8001_ha, &tag);\n\tif (rc) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"Invalid tag\\n\");\n\t\treturn;\n\t}\n\n\tpayload.tag = cpu_to_le32(tag);\n\tpayload.ppc_phyid =\n\t\tcpu_to_le32(((operation & 0xF) << 8) | (phyid  & 0xFF));\n\tpm8001_dbg(pm8001_ha, DISC,\n\t\t   \" phy profile command for phy %x ,length is %d\\n\",\n\t\t   le32_to_cpu(payload.ppc_phyid), length);\n\tfor (i = length; i < (length + PHY_DWORD_LENGTH - 1); i++) {\n\t\tpayload.reserved[j] = cpu_to_le32(*((u32 *)buf + i));\n\t\tj++;\n\t}\n\trc = pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &payload,\n\t\t\t\t  sizeof(payload), 0);\n\tif (rc)\n\t\tpm8001_tag_free(pm8001_ha, tag);\n}\n\nvoid pm8001_set_phy_profile(struct pm8001_hba_info *pm8001_ha,\n\tu32 length, u8 *buf)\n{\n\tu32 i;\n\n\tfor (i = 0; i < pm8001_ha->chip->n_phy; i++) {\n\t\tmpi_set_phy_profile_req(pm8001_ha,\n\t\t\tSAS_PHY_ANALOG_SETTINGS_PAGE, i, length, (u32 *)buf);\n\t\tlength = length + PHY_DWORD_LENGTH;\n\t}\n\tpm8001_dbg(pm8001_ha, INIT, \"phy settings completed\\n\");\n}\n\nvoid pm8001_set_phy_profile_single(struct pm8001_hba_info *pm8001_ha,\n\t\tu32 phy, u32 length, u32 *buf)\n{\n\tu32 tag, opc;\n\tint rc, i;\n\tstruct set_phy_profile_req payload;\n\n\tmemset(&payload, 0, sizeof(payload));\n\n\trc = pm8001_tag_alloc(pm8001_ha, &tag);\n\tif (rc) {\n\t\tpm8001_dbg(pm8001_ha, INIT, \"Invalid tag\\n\");\n\t\treturn;\n\t}\n\n\topc = OPC_INB_SET_PHY_PROFILE;\n\n\tpayload.tag = cpu_to_le32(tag);\n\tpayload.ppc_phyid =\n\t\tcpu_to_le32(((SAS_PHY_ANALOG_SETTINGS_PAGE & 0xF) << 8)\n\t\t\t    | (phy & 0xFF));\n\n\tfor (i = 0; i < length; i++)\n\t\tpayload.reserved[i] = cpu_to_le32(*(buf + i));\n\n\trc = pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &payload,\n\t\t\tsizeof(payload), 0);\n\tif (rc)\n\t\tpm8001_tag_free(pm8001_ha, tag);\n\n\tpm8001_dbg(pm8001_ha, INIT, \"PHY %d settings applied\\n\", phy);\n}\nconst struct pm8001_dispatch pm8001_80xx_dispatch = {\n\t.name\t\t\t= \"pmc80xx\",\n\t.chip_init\t\t= pm80xx_chip_init,\n\t.chip_post_init\t\t= pm80xx_chip_post_init,\n\t.chip_soft_rst\t\t= pm80xx_chip_soft_rst,\n\t.chip_rst\t\t= pm80xx_hw_chip_rst,\n\t.chip_iounmap\t\t= pm8001_chip_iounmap,\n\t.isr\t\t\t= pm80xx_chip_isr,\n\t.is_our_interrupt\t= pm80xx_chip_is_our_interrupt,\n\t.isr_process_oq\t\t= process_oq,\n\t.interrupt_enable\t= pm80xx_chip_interrupt_enable,\n\t.interrupt_disable\t= pm80xx_chip_interrupt_disable,\n\t.make_prd\t\t= pm8001_chip_make_sg,\n\t.smp_req\t\t= pm80xx_chip_smp_req,\n\t.ssp_io_req\t\t= pm80xx_chip_ssp_io_req,\n\t.sata_req\t\t= pm80xx_chip_sata_req,\n\t.phy_start_req\t\t= pm80xx_chip_phy_start_req,\n\t.phy_stop_req\t\t= pm80xx_chip_phy_stop_req,\n\t.reg_dev_req\t\t= pm80xx_chip_reg_dev_req,\n\t.dereg_dev_req\t\t= pm8001_chip_dereg_dev_req,\n\t.phy_ctl_req\t\t= pm80xx_chip_phy_ctl_req,\n\t.task_abort\t\t= pm8001_chip_abort_task,\n\t.ssp_tm_req\t\t= pm8001_chip_ssp_tm_req,\n\t.get_nvmd_req\t\t= pm8001_chip_get_nvmd_req,\n\t.set_nvmd_req\t\t= pm8001_chip_set_nvmd_req,\n\t.fw_flash_update_req\t= pm8001_chip_fw_flash_update_req,\n\t.set_dev_state_req\t= pm8001_chip_set_dev_state_req,\n\t.fatal_errors\t\t= pm80xx_fatal_errors,\n\t.hw_event_ack_req\t= pm80xx_hw_event_ack_req,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}