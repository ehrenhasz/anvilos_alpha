{
  "module_name": "pm8001_sas.c",
  "hash_id": "692e689a310b6b2992d8642cd0055c8a5dd967f336cef319d8e6fcfff4978897",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/pm8001/pm8001_sas.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include \"pm8001_sas.h\"\n#include \"pm80xx_tracepoints.h\"\n\n \nstatic int pm8001_find_tag(struct sas_task *task, u32 *tag)\n{\n\tif (task->lldd_task) {\n\t\tstruct pm8001_ccb_info *ccb;\n\t\tccb = task->lldd_task;\n\t\t*tag = ccb->ccb_tag;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nvoid pm8001_tag_free(struct pm8001_hba_info *pm8001_ha, u32 tag)\n{\n\tvoid *bitmap = pm8001_ha->rsvd_tags;\n\tunsigned long flags;\n\n\tif (tag >= PM8001_RESERVE_SLOT)\n\t\treturn;\n\n\tspin_lock_irqsave(&pm8001_ha->bitmap_lock, flags);\n\t__clear_bit(tag, bitmap);\n\tspin_unlock_irqrestore(&pm8001_ha->bitmap_lock, flags);\n}\n\n \nint pm8001_tag_alloc(struct pm8001_hba_info *pm8001_ha, u32 *tag_out)\n{\n\tvoid *bitmap = pm8001_ha->rsvd_tags;\n\tunsigned long flags;\n\tunsigned int tag;\n\n\tspin_lock_irqsave(&pm8001_ha->bitmap_lock, flags);\n\ttag = find_first_zero_bit(bitmap, PM8001_RESERVE_SLOT);\n\tif (tag >= PM8001_RESERVE_SLOT) {\n\t\tspin_unlock_irqrestore(&pm8001_ha->bitmap_lock, flags);\n\t\treturn -SAS_QUEUE_FULL;\n\t}\n\t__set_bit(tag, bitmap);\n\tspin_unlock_irqrestore(&pm8001_ha->bitmap_lock, flags);\n\n\t \n\t*tag_out = tag;\n\treturn 0;\n}\n\n \nint pm8001_mem_alloc(struct pci_dev *pdev, void **virt_addr,\n\tdma_addr_t *pphys_addr, u32 *pphys_addr_hi,\n\tu32 *pphys_addr_lo, u32 mem_size, u32 align)\n{\n\tcaddr_t mem_virt_alloc;\n\tdma_addr_t mem_dma_handle;\n\tu64 phys_align;\n\tu64 align_offset = 0;\n\tif (align)\n\t\talign_offset = (dma_addr_t)align - 1;\n\tmem_virt_alloc = dma_alloc_coherent(&pdev->dev, mem_size + align,\n\t\t\t\t\t    &mem_dma_handle, GFP_KERNEL);\n\tif (!mem_virt_alloc)\n\t\treturn -ENOMEM;\n\t*pphys_addr = mem_dma_handle;\n\tphys_align = (*pphys_addr + align_offset) & ~align_offset;\n\t*virt_addr = (void *)mem_virt_alloc + phys_align - *pphys_addr;\n\t*pphys_addr_hi = upper_32_bits(phys_align);\n\t*pphys_addr_lo = lower_32_bits(phys_align);\n\treturn 0;\n}\n\n \nstatic\nstruct pm8001_hba_info *pm8001_find_ha_by_dev(struct domain_device *dev)\n{\n\tstruct sas_ha_struct *sha = dev->port->ha;\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\treturn pm8001_ha;\n}\n\n \nint pm8001_phy_control(struct asd_sas_phy *sas_phy, enum phy_func func,\n\tvoid *funcdata)\n{\n\tint rc = 0, phy_id = sas_phy->id;\n\tstruct pm8001_hba_info *pm8001_ha = NULL;\n\tstruct sas_phy_linkrates *rates;\n\tstruct pm8001_phy *phy;\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tunsigned long flags;\n\tpm8001_ha = sas_phy->ha->lldd_ha;\n\tphy = &pm8001_ha->phy[phy_id];\n\tpm8001_ha->phy[phy_id].enable_completion = &completion;\n\n\tif (PM8001_CHIP_DISP->fatal_errors(pm8001_ha)) {\n\t\t \n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"Phy control failed due to fatal errors\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tswitch (func) {\n\tcase PHY_FUNC_SET_LINK_RATE:\n\t\trates = funcdata;\n\t\tif (rates->minimum_linkrate) {\n\t\t\tpm8001_ha->phy[phy_id].minimum_linkrate =\n\t\t\t\trates->minimum_linkrate;\n\t\t}\n\t\tif (rates->maximum_linkrate) {\n\t\t\tpm8001_ha->phy[phy_id].maximum_linkrate =\n\t\t\t\trates->maximum_linkrate;\n\t\t}\n\t\tif (pm8001_ha->phy[phy_id].phy_state ==  PHY_LINK_DISABLE) {\n\t\t\tPM8001_CHIP_DISP->phy_start_req(pm8001_ha, phy_id);\n\t\t\twait_for_completion(&completion);\n\t\t}\n\t\tPM8001_CHIP_DISP->phy_ctl_req(pm8001_ha, phy_id,\n\t\t\t\t\t      PHY_LINK_RESET);\n\t\tbreak;\n\tcase PHY_FUNC_HARD_RESET:\n\t\tif (pm8001_ha->phy[phy_id].phy_state == PHY_LINK_DISABLE) {\n\t\t\tPM8001_CHIP_DISP->phy_start_req(pm8001_ha, phy_id);\n\t\t\twait_for_completion(&completion);\n\t\t}\n\t\tPM8001_CHIP_DISP->phy_ctl_req(pm8001_ha, phy_id,\n\t\t\t\t\t      PHY_HARD_RESET);\n\t\tbreak;\n\tcase PHY_FUNC_LINK_RESET:\n\t\tif (pm8001_ha->phy[phy_id].phy_state == PHY_LINK_DISABLE) {\n\t\t\tPM8001_CHIP_DISP->phy_start_req(pm8001_ha, phy_id);\n\t\t\twait_for_completion(&completion);\n\t\t}\n\t\tPM8001_CHIP_DISP->phy_ctl_req(pm8001_ha, phy_id,\n\t\t\t\t\t      PHY_LINK_RESET);\n\t\tbreak;\n\tcase PHY_FUNC_RELEASE_SPINUP_HOLD:\n\t\tPM8001_CHIP_DISP->phy_ctl_req(pm8001_ha, phy_id,\n\t\t\t\t\t      PHY_LINK_RESET);\n\t\tbreak;\n\tcase PHY_FUNC_DISABLE:\n\t\tif (pm8001_ha->chip_id != chip_8001) {\n\t\t\tif (pm8001_ha->phy[phy_id].phy_state ==\n\t\t\t\tPHY_STATE_LINK_UP_SPCV) {\n\t\t\t\tsas_phy_disconnected(&phy->sas_phy);\n\t\t\t\tsas_notify_phy_event(&phy->sas_phy,\n\t\t\t\t\tPHYE_LOSS_OF_SIGNAL, GFP_KERNEL);\n\t\t\t\tphy->phy_attached = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (pm8001_ha->phy[phy_id].phy_state ==\n\t\t\t\tPHY_STATE_LINK_UP_SPC) {\n\t\t\t\tsas_phy_disconnected(&phy->sas_phy);\n\t\t\t\tsas_notify_phy_event(&phy->sas_phy,\n\t\t\t\t\tPHYE_LOSS_OF_SIGNAL, GFP_KERNEL);\n\t\t\t\tphy->phy_attached = 0;\n\t\t\t}\n\t\t}\n\t\tPM8001_CHIP_DISP->phy_stop_req(pm8001_ha, phy_id);\n\t\tbreak;\n\tcase PHY_FUNC_GET_EVENTS:\n\t\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\t\tif (pm8001_ha->chip_id == chip_8001) {\n\t\t\tif (-1 == pm8001_bar4_shift(pm8001_ha,\n\t\t\t\t\t(phy_id < 4) ? 0x30000 : 0x40000)) {\n\t\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tstruct sas_phy *phy = sas_phy->phy;\n\t\t\tu32 __iomem *qp = pm8001_ha->io_mem[2].memvirtaddr\n\t\t\t\t+ 0x1034 + (0x4000 * (phy_id & 3));\n\n\t\t\tphy->invalid_dword_count = readl(qp);\n\t\t\tphy->running_disparity_error_count = readl(&qp[1]);\n\t\t\tphy->loss_of_dword_sync_count = readl(&qp[3]);\n\t\t\tphy->phy_reset_problem_count = readl(&qp[4]);\n\t\t}\n\t\tif (pm8001_ha->chip_id == chip_8001)\n\t\t\tpm8001_bar4_shift(pm8001_ha, 0);\n\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\treturn 0;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO, \"func 0x%x\\n\", func);\n\t\trc = -EOPNOTSUPP;\n\t}\n\tmsleep(300);\n\treturn rc;\n}\n\n \nvoid pm8001_scan_start(struct Scsi_Host *shost)\n{\n\tint i;\n\tstruct pm8001_hba_info *pm8001_ha;\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tpm8001_ha = sha->lldd_ha;\n\t \n\tif (pm8001_ha->chip_id == chip_8001)\n\t\tPM8001_CHIP_DISP->sas_re_init_req(pm8001_ha);\n\tfor (i = 0; i < pm8001_ha->chip->n_phy; ++i) {\n\t\tpm8001_ha->phy[i].enable_completion = &completion;\n\t\tPM8001_CHIP_DISP->phy_start_req(pm8001_ha, i);\n\t\twait_for_completion(&completion);\n\t\tmsleep(300);\n\t}\n}\n\nint pm8001_scan_finished(struct Scsi_Host *shost, unsigned long time)\n{\n\tstruct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\n\n\t \n\tif (time < HZ)\n\t\treturn 0;\n\t \n\tsas_drain_work(ha);\n\treturn 1;\n}\n\n \nstatic int pm8001_task_prep_smp(struct pm8001_hba_info *pm8001_ha,\n\tstruct pm8001_ccb_info *ccb)\n{\n\treturn PM8001_CHIP_DISP->smp_req(pm8001_ha, ccb);\n}\n\nu32 pm8001_get_ncq_tag(struct sas_task *task, u32 *tag)\n{\n\tstruct ata_queued_cmd *qc = task->uldd_task;\n\n\tif (qc && ata_is_ncq(qc->tf.protocol)) {\n\t\t*tag = qc->tag;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pm8001_task_prep_ata(struct pm8001_hba_info *pm8001_ha,\n\tstruct pm8001_ccb_info *ccb)\n{\n\treturn PM8001_CHIP_DISP->sata_req(pm8001_ha, ccb);\n}\n\n \nstatic int pm8001_task_prep_internal_abort(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\t   struct pm8001_ccb_info *ccb)\n{\n\treturn PM8001_CHIP_DISP->task_abort(pm8001_ha, ccb);\n}\n\n \nstatic int pm8001_task_prep_ssp_tm(struct pm8001_hba_info *pm8001_ha,\n\tstruct pm8001_ccb_info *ccb, struct sas_tmf_task *tmf)\n{\n\treturn PM8001_CHIP_DISP->ssp_tm_req(pm8001_ha, ccb, tmf);\n}\n\n \nstatic int pm8001_task_prep_ssp(struct pm8001_hba_info *pm8001_ha,\n\tstruct pm8001_ccb_info *ccb)\n{\n\treturn PM8001_CHIP_DISP->ssp_io_req(pm8001_ha, ccb);\n}\n\n  \nstatic int sas_find_local_port_id(struct domain_device *dev)\n{\n\tstruct domain_device *pdev = dev->parent;\n\n\t \n\tif (!pdev)\n\t\treturn dev->port->id;\n\twhile (pdev) {\n\t\tstruct domain_device *pdev_p = pdev->parent;\n\t\tif (!pdev_p)\n\t\t\treturn pdev->port->id;\n\t\tpdev = pdev->parent;\n\t}\n\treturn 0;\n}\n\n#define DEV_IS_GONE(pm8001_dev)\t\\\n\t((!pm8001_dev || (pm8001_dev->dev_type == SAS_PHY_UNUSED)))\n\n\nstatic int pm8001_deliver_command(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t  struct pm8001_ccb_info *ccb)\n{\n\tstruct sas_task *task = ccb->task;\n\tenum sas_protocol task_proto = task->task_proto;\n\tstruct sas_tmf_task *tmf = task->tmf;\n\tint is_tmf = !!tmf;\n\n\tswitch (task_proto) {\n\tcase SAS_PROTOCOL_SMP:\n\t\treturn pm8001_task_prep_smp(pm8001_ha, ccb);\n\tcase SAS_PROTOCOL_SSP:\n\t\tif (is_tmf)\n\t\t\treturn pm8001_task_prep_ssp_tm(pm8001_ha, ccb, tmf);\n\t\treturn pm8001_task_prep_ssp(pm8001_ha, ccb);\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\t\treturn pm8001_task_prep_ata(pm8001_ha, ccb);\n\tcase SAS_PROTOCOL_INTERNAL_ABORT:\n\t\treturn pm8001_task_prep_internal_abort(pm8001_ha, ccb);\n\tdefault:\n\t\tdev_err(pm8001_ha->dev, \"unknown sas_task proto: 0x%x\\n\",\n\t\t\ttask_proto);\n\t}\n\n\treturn -EINVAL;\n}\n\n \nint pm8001_queue_command(struct sas_task *task, gfp_t gfp_flags)\n{\n\tstruct task_status_struct *ts = &task->task_status;\n\tenum sas_protocol task_proto = task->task_proto;\n\tstruct domain_device *dev = task->dev;\n\tstruct pm8001_device *pm8001_dev = dev->lldd_dev;\n\tbool internal_abort = sas_is_internal_abort(task);\n\tstruct pm8001_hba_info *pm8001_ha;\n\tstruct pm8001_port *port = NULL;\n\tstruct pm8001_ccb_info *ccb;\n\tunsigned long flags;\n\tu32 n_elem = 0;\n\tint rc = 0;\n\n\tif (!internal_abort && !dev->port) {\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_PHY_DOWN;\n\t\tif (dev->dev_type != SAS_SATA_DEV)\n\t\t\ttask->task_done(task);\n\t\treturn 0;\n\t}\n\n\tpm8001_ha = pm8001_find_ha_by_dev(dev);\n\tif (pm8001_ha->controller_fatal_error) {\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\ttask->task_done(task);\n\t\treturn 0;\n\t}\n\n\tpm8001_dbg(pm8001_ha, IO, \"pm8001_task_exec device\\n\");\n\n\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\n\tpm8001_dev = dev->lldd_dev;\n\tport = &pm8001_ha->port[sas_find_local_port_id(dev)];\n\n\tif (!internal_abort &&\n\t    (DEV_IS_GONE(pm8001_dev) || !port->port_attached)) {\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_PHY_DOWN;\n\t\tif (sas_protocol_ata(task_proto)) {\n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\ttask->task_done(task);\n\t\t\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\t\t} else {\n\t\t\ttask->task_done(task);\n\t\t}\n\t\trc = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\tccb = pm8001_ccb_alloc(pm8001_ha, pm8001_dev, task);\n\tif (!ccb) {\n\t\trc = -SAS_QUEUE_FULL;\n\t\tgoto err_out;\n\t}\n\n\tif (!sas_protocol_ata(task_proto)) {\n\t\tif (task->num_scatter) {\n\t\t\tn_elem = dma_map_sg(pm8001_ha->dev, task->scatter,\n\t\t\t\t\t    task->num_scatter, task->data_dir);\n\t\t\tif (!n_elem) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto err_out_ccb;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tn_elem = task->num_scatter;\n\t}\n\n\ttask->lldd_task = ccb;\n\tccb->n_elem = n_elem;\n\n\tatomic_inc(&pm8001_dev->running_req);\n\n\trc = pm8001_deliver_command(pm8001_ha, ccb);\n\tif (rc) {\n\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tif (!sas_protocol_ata(task_proto) && n_elem)\n\t\t\tdma_unmap_sg(pm8001_ha->dev, task->scatter,\n\t\t\t\t     task->num_scatter, task->data_dir);\nerr_out_ccb:\n\t\tpm8001_ccb_free(pm8001_ha, ccb);\n\nerr_out:\n\t\tpm8001_dbg(pm8001_ha, IO, \"pm8001_task_exec failed[%d]!\\n\", rc);\n\t}\n\n\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\n\treturn rc;\n}\n\n \nvoid pm8001_ccb_task_free(struct pm8001_hba_info *pm8001_ha,\n\t\t\t  struct pm8001_ccb_info *ccb)\n{\n\tstruct sas_task *task = ccb->task;\n\tstruct ata_queued_cmd *qc;\n\tstruct pm8001_device *pm8001_dev;\n\n\tif (!task)\n\t\treturn;\n\n\tif (!sas_protocol_ata(task->task_proto) && ccb->n_elem)\n\t\tdma_unmap_sg(pm8001_ha->dev, task->scatter,\n\t\t\t     task->num_scatter, task->data_dir);\n\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SMP:\n\t\tdma_unmap_sg(pm8001_ha->dev, &task->smp_task.smp_resp, 1,\n\t\t\tDMA_FROM_DEVICE);\n\t\tdma_unmap_sg(pm8001_ha->dev, &task->smp_task.smp_req, 1,\n\t\t\tDMA_TO_DEVICE);\n\t\tbreak;\n\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\tcase SAS_PROTOCOL_SSP:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (sas_protocol_ata(task->task_proto)) {\n\t\t \n\t\tqc = task->uldd_task;\n\t\tpm8001_dev = ccb->device;\n\t\ttrace_pm80xx_request_complete(pm8001_ha->id,\n\t\t\tpm8001_dev ? pm8001_dev->attached_phy : PM8001_MAX_PHYS,\n\t\t\tccb->ccb_tag, 0  ,\n\t\t\tqc ? qc->tf.command : 0, \n\t\t\tpm8001_dev ? atomic_read(&pm8001_dev->running_req) : -1);\n\t}\n\n\ttask->lldd_task = NULL;\n\tpm8001_ccb_free(pm8001_ha, ccb);\n}\n\n \nstatic struct pm8001_device *pm8001_alloc_dev(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32 dev;\n\tfor (dev = 0; dev < PM8001_MAX_DEVICES; dev++) {\n\t\tif (pm8001_ha->devices[dev].dev_type == SAS_PHY_UNUSED) {\n\t\t\tpm8001_ha->devices[dev].id = dev;\n\t\t\treturn &pm8001_ha->devices[dev];\n\t\t}\n\t}\n\tif (dev == PM8001_MAX_DEVICES) {\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"max support %d devices, ignore ..\\n\",\n\t\t\t   PM8001_MAX_DEVICES);\n\t}\n\treturn NULL;\n}\n \nstruct pm8001_device *pm8001_find_dev(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\tu32 device_id)\n{\n\tu32 dev;\n\tfor (dev = 0; dev < PM8001_MAX_DEVICES; dev++) {\n\t\tif (pm8001_ha->devices[dev].device_id == device_id)\n\t\t\treturn &pm8001_ha->devices[dev];\n\t}\n\tif (dev == PM8001_MAX_DEVICES) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"NO MATCHING DEVICE FOUND !!!\\n\");\n\t}\n\treturn NULL;\n}\n\nvoid pm8001_free_dev(struct pm8001_device *pm8001_dev)\n{\n\tu32 id = pm8001_dev->id;\n\tmemset(pm8001_dev, 0, sizeof(*pm8001_dev));\n\tpm8001_dev->id = id;\n\tpm8001_dev->dev_type = SAS_PHY_UNUSED;\n\tpm8001_dev->device_id = PM8001_MAX_DEVICES;\n\tpm8001_dev->sas_device = NULL;\n}\n\n \nstatic int pm8001_dev_found_notify(struct domain_device *dev)\n{\n\tunsigned long flags = 0;\n\tint res = 0;\n\tstruct pm8001_hba_info *pm8001_ha = NULL;\n\tstruct domain_device *parent_dev = dev->parent;\n\tstruct pm8001_device *pm8001_device;\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tu32 flag = 0;\n\tpm8001_ha = pm8001_find_ha_by_dev(dev);\n\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\n\tpm8001_device = pm8001_alloc_dev(pm8001_ha);\n\tif (!pm8001_device) {\n\t\tres = -1;\n\t\tgoto found_out;\n\t}\n\tpm8001_device->sas_device = dev;\n\tdev->lldd_dev = pm8001_device;\n\tpm8001_device->dev_type = dev->dev_type;\n\tpm8001_device->dcompletion = &completion;\n\tif (parent_dev && dev_is_expander(parent_dev->dev_type)) {\n\t\tint phy_id;\n\n\t\tphy_id = sas_find_attached_phy_id(&parent_dev->ex_dev, dev);\n\t\tif (phy_id < 0) {\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"Error: no attached dev:%016llx at ex:%016llx.\\n\",\n\t\t\t\t   SAS_ADDR(dev->sas_addr),\n\t\t\t\t   SAS_ADDR(parent_dev->sas_addr));\n\t\t\tres = phy_id;\n\t\t} else {\n\t\t\tpm8001_device->attached_phy = phy_id;\n\t\t}\n\t} else {\n\t\tif (dev->dev_type == SAS_SATA_DEV) {\n\t\t\tpm8001_device->attached_phy =\n\t\t\t\tdev->rphy->identify.phy_identifier;\n\t\t\tflag = 1;  \n\t\t}\n\t}  \n\tpm8001_dbg(pm8001_ha, DISC, \"Found device\\n\");\n\tPM8001_CHIP_DISP->reg_dev_req(pm8001_ha, pm8001_device, flag);\n\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\twait_for_completion(&completion);\n\tif (dev->dev_type == SAS_END_DEVICE)\n\t\tmsleep(50);\n\tpm8001_ha->flags = PM8001F_RUN_TIME;\n\treturn 0;\nfound_out:\n\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\treturn res;\n}\n\nint pm8001_dev_found(struct domain_device *dev)\n{\n\treturn pm8001_dev_found_notify(dev);\n}\n\n#define PM8001_TASK_TIMEOUT 20\n\n \nstatic void pm8001_dev_gone_notify(struct domain_device *dev)\n{\n\tunsigned long flags = 0;\n\tstruct pm8001_hba_info *pm8001_ha;\n\tstruct pm8001_device *pm8001_dev = dev->lldd_dev;\n\n\tpm8001_ha = pm8001_find_ha_by_dev(dev);\n\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\tif (pm8001_dev) {\n\t\tu32 device_id = pm8001_dev->device_id;\n\n\t\tpm8001_dbg(pm8001_ha, DISC, \"found dev[%d:%x] is gone.\\n\",\n\t\t\t   pm8001_dev->device_id, pm8001_dev->dev_type);\n\t\tif (atomic_read(&pm8001_dev->running_req)) {\n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\tsas_execute_internal_abort_dev(dev, 0, NULL);\n\t\t\twhile (atomic_read(&pm8001_dev->running_req))\n\t\t\t\tmsleep(20);\n\t\t\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\t\t}\n\t\tPM8001_CHIP_DISP->dereg_dev_req(pm8001_ha, device_id);\n\t\tpm8001_free_dev(pm8001_dev);\n\t} else {\n\t\tpm8001_dbg(pm8001_ha, DISC, \"Found dev has gone.\\n\");\n\t}\n\tdev->lldd_dev = NULL;\n\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n}\n\nvoid pm8001_dev_gone(struct domain_device *dev)\n{\n\tpm8001_dev_gone_notify(dev);\n}\n\n \nvoid pm8001_open_reject_retry(\n\tstruct pm8001_hba_info *pm8001_ha,\n\tstruct sas_task *task_to_close,\n\tstruct pm8001_device *device_to_close)\n{\n\tint i;\n\tunsigned long flags;\n\n\tif (pm8001_ha == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\n\tfor (i = 0; i < PM8001_MAX_CCB; i++) {\n\t\tstruct sas_task *task;\n\t\tstruct task_status_struct *ts;\n\t\tstruct pm8001_device *pm8001_dev;\n\t\tunsigned long flags1;\n\t\tstruct pm8001_ccb_info *ccb = &pm8001_ha->ccb_info[i];\n\n\t\tif (ccb->ccb_tag == PM8001_INVALID_TAG)\n\t\t\tcontinue;\n\n\t\tpm8001_dev = ccb->device;\n\t\tif (!pm8001_dev || (pm8001_dev->dev_type == SAS_PHY_UNUSED))\n\t\t\tcontinue;\n\t\tif (!device_to_close) {\n\t\t\tuintptr_t d = (uintptr_t)pm8001_dev\n\t\t\t\t\t- (uintptr_t)&pm8001_ha->devices;\n\t\t\tif (((d % sizeof(*pm8001_dev)) != 0)\n\t\t\t || ((d / sizeof(*pm8001_dev)) >= PM8001_MAX_DEVICES))\n\t\t\t\tcontinue;\n\t\t} else if (pm8001_dev != device_to_close)\n\t\t\tcontinue;\n\t\ttask = ccb->task;\n\t\tif (!task || !task->task_done)\n\t\t\tcontinue;\n\t\tif (task_to_close && (task != task_to_close))\n\t\t\tcontinue;\n\t\tts = &task->task_status;\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\t \n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tspin_lock_irqsave(&task->task_state_lock, flags1);\n\t\ttask->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\t\ttask->task_state_flags |= SAS_TASK_STATE_DONE;\n\t\tif (unlikely((task->task_state_flags\n\t\t\t\t& SAS_TASK_STATE_ABORTED))) {\n\t\t\tspin_unlock_irqrestore(&task->task_state_lock,\n\t\t\t\tflags1);\n\t\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&task->task_state_lock,\n\t\t\t\tflags1);\n\t\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t\t\tmb(); \n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\ttask->task_done(task);\n\t\t\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n}\n\n \nint pm8001_I_T_nexus_reset(struct domain_device *dev)\n{\n\tint rc = TMF_RESP_FUNC_FAILED;\n\tstruct pm8001_device *pm8001_dev;\n\tstruct pm8001_hba_info *pm8001_ha;\n\tstruct sas_phy *phy;\n\n\tif (!dev || !dev->lldd_dev)\n\t\treturn -ENODEV;\n\n\tpm8001_dev = dev->lldd_dev;\n\tpm8001_ha = pm8001_find_ha_by_dev(dev);\n\tphy = sas_get_local_phy(dev);\n\n\tif (dev_is_sata(dev)) {\n\t\tif (scsi_is_sas_phy_local(phy)) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t\trc = sas_phy_reset(phy, 1);\n\t\tif (rc) {\n\t\t\tpm8001_dbg(pm8001_ha, EH,\n\t\t\t\t   \"phy reset failed for device %x\\n\"\n\t\t\t\t   \"with rc %d\\n\", pm8001_dev->device_id, rc);\n\t\t\trc = TMF_RESP_FUNC_FAILED;\n\t\t\tgoto out;\n\t\t}\n\t\tmsleep(2000);\n\t\trc = sas_execute_internal_abort_dev(dev, 0, NULL);\n\t\tif (rc) {\n\t\t\tpm8001_dbg(pm8001_ha, EH, \"task abort failed %x\\n\"\n\t\t\t\t   \"with rc %d\\n\", pm8001_dev->device_id, rc);\n\t\t\trc = TMF_RESP_FUNC_FAILED;\n\t\t}\n\t} else {\n\t\trc = sas_phy_reset(phy, 1);\n\t\tmsleep(2000);\n\t}\n\tpm8001_dbg(pm8001_ha, EH, \" for device[%x]:rc=%d\\n\",\n\t\t   pm8001_dev->device_id, rc);\n out:\n\tsas_put_local_phy(phy);\n\treturn rc;\n}\n\n \nint pm8001_I_T_nexus_event_handler(struct domain_device *dev)\n{\n\tint rc = TMF_RESP_FUNC_FAILED;\n\tstruct pm8001_device *pm8001_dev;\n\tstruct pm8001_hba_info *pm8001_ha;\n\tstruct sas_phy *phy;\n\n\tif (!dev || !dev->lldd_dev)\n\t\treturn -1;\n\n\tpm8001_dev = dev->lldd_dev;\n\tpm8001_ha = pm8001_find_ha_by_dev(dev);\n\n\tpm8001_dbg(pm8001_ha, EH, \"I_T_Nexus handler invoked !!\\n\");\n\n\tphy = sas_get_local_phy(dev);\n\n\tif (dev_is_sata(dev)) {\n\t\tDECLARE_COMPLETION_ONSTACK(completion_setstate);\n\t\tif (scsi_is_sas_phy_local(phy)) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tsas_execute_internal_abort_dev(dev, 0, NULL);\n\t\tmsleep(100);\n\n\t\t \n\t\tpm8001_dev_gone_notify(dev);\n\t\tmsleep(200);\n\n\t\t \n\t\trc = sas_phy_reset(phy, 1);\n\t\tmsleep(2000);\n\t\tpm8001_dev->setds_completion = &completion_setstate;\n\n\t\twait_for_completion(&completion_setstate);\n\t} else {\n\t\t \n\t\tsas_execute_internal_abort_dev(dev, 0, NULL);\n\t\tmsleep(100);\n\n\t\t \n\t\tpm8001_dev_gone_notify(dev);\n\t\tmsleep(200);\n\n\t\t \n\t\trc = sas_phy_reset(phy, 1);\n\t\tmsleep(2000);\n\t}\n\tpm8001_dbg(pm8001_ha, EH, \" for device[%x]:rc=%d\\n\",\n\t\t   pm8001_dev->device_id, rc);\nout:\n\tsas_put_local_phy(phy);\n\n\treturn rc;\n}\n \nint pm8001_lu_reset(struct domain_device *dev, u8 *lun)\n{\n\tint rc = TMF_RESP_FUNC_FAILED;\n\tstruct pm8001_device *pm8001_dev = dev->lldd_dev;\n\tstruct pm8001_hba_info *pm8001_ha = pm8001_find_ha_by_dev(dev);\n\tDECLARE_COMPLETION_ONSTACK(completion_setstate);\n\n\tif (PM8001_CHIP_DISP->fatal_errors(pm8001_ha)) {\n\t\t \n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"LUN reset failed due to fatal errors\\n\");\n\t\treturn rc;\n\t}\n\n\tif (dev_is_sata(dev)) {\n\t\tstruct sas_phy *phy = sas_get_local_phy(dev);\n\t\tsas_execute_internal_abort_dev(dev, 0, NULL);\n\t\trc = sas_phy_reset(phy, 1);\n\t\tsas_put_local_phy(phy);\n\t\tpm8001_dev->setds_completion = &completion_setstate;\n\t\trc = PM8001_CHIP_DISP->set_dev_state_req(pm8001_ha,\n\t\t\tpm8001_dev, DS_OPERATIONAL);\n\t\twait_for_completion(&completion_setstate);\n\t} else {\n\t\trc = sas_lu_reset(dev, lun);\n\t}\n\t \n\tpm8001_dbg(pm8001_ha, EH, \"for device[%x]:rc=%d\\n\",\n\t\t   pm8001_dev->device_id, rc);\n\treturn rc;\n}\n\n \nint pm8001_query_task(struct sas_task *task)\n{\n\tu32 tag = 0xdeadbeef;\n\tint rc = TMF_RESP_FUNC_FAILED;\n\tif (unlikely(!task || !task->lldd_task || !task->dev))\n\t\treturn rc;\n\n\tif (task->task_proto & SAS_PROTOCOL_SSP) {\n\t\tstruct scsi_cmnd *cmnd = task->uldd_task;\n\t\tstruct domain_device *dev = task->dev;\n\t\tstruct pm8001_hba_info *pm8001_ha =\n\t\t\tpm8001_find_ha_by_dev(dev);\n\n\t\trc = pm8001_find_tag(task, &tag);\n\t\tif (rc == 0) {\n\t\t\trc = TMF_RESP_FUNC_FAILED;\n\t\t\treturn rc;\n\t\t}\n\t\tpm8001_dbg(pm8001_ha, EH, \"Query:[%16ph]\\n\", cmnd->cmnd);\n\n\t\trc = sas_query_task(task, tag);\n\t\tswitch (rc) {\n\t\t \n\t\tcase TMF_RESP_FUNC_SUCC:\n\t\t\tpm8001_dbg(pm8001_ha, EH,\n\t\t\t\t   \"The task is still in Lun\\n\");\n\t\t\tbreak;\n\t\t \n\t\tcase TMF_RESP_FUNC_FAILED:\n\t\tcase TMF_RESP_FUNC_COMPLETE:\n\t\t\tpm8001_dbg(pm8001_ha, EH,\n\t\t\t\t   \"The task is not in Lun or failed, reset the phy\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tpr_err(\"pm80xx: rc= %d\\n\", rc);\n\treturn rc;\n}\n\n \nint pm8001_abort_task(struct sas_task *task)\n{\n\tstruct pm8001_ccb_info *ccb = task->lldd_task;\n\tunsigned long flags;\n\tu32 tag;\n\tstruct domain_device *dev ;\n\tstruct pm8001_hba_info *pm8001_ha;\n\tstruct pm8001_device *pm8001_dev;\n\tint rc = TMF_RESP_FUNC_FAILED, ret;\n\tu32 phy_id, port_id;\n\tstruct sas_task_slow slow_task;\n\n\tif (!task->lldd_task || !task->dev)\n\t\treturn TMF_RESP_FUNC_FAILED;\n\n\tdev = task->dev;\n\tpm8001_dev = dev->lldd_dev;\n\tpm8001_ha = pm8001_find_ha_by_dev(dev);\n\tphy_id = pm8001_dev->attached_phy;\n\n\tif (PM8001_CHIP_DISP->fatal_errors(pm8001_ha)) {\n\t\t \n\t\t \n\t\treturn TMF_RESP_FUNC_FAILED;\n\t}\n\n\tret = pm8001_find_tag(task, &tag);\n\tif (ret == 0) {\n\t\tpm8001_info(pm8001_ha, \"no tag for task:%p\\n\", task);\n\t\treturn TMF_RESP_FUNC_FAILED;\n\t}\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (task->task_state_flags & SAS_TASK_STATE_DONE) {\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\treturn TMF_RESP_FUNC_COMPLETE;\n\t}\n\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tif (task->slow_task == NULL) {\n\t\tinit_completion(&slow_task.completion);\n\t\ttask->slow_task = &slow_task;\n\t}\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tif (task->task_proto & SAS_PROTOCOL_SSP) {\n\t\trc = sas_abort_task(task, tag);\n\t\tsas_execute_internal_abort_single(dev, tag, 0, NULL);\n\t} else if (task->task_proto & SAS_PROTOCOL_SATA ||\n\t\ttask->task_proto & SAS_PROTOCOL_STP) {\n\t\tif (pm8001_ha->chip_id == chip_8006) {\n\t\t\tDECLARE_COMPLETION_ONSTACK(completion_reset);\n\t\t\tDECLARE_COMPLETION_ONSTACK(completion);\n\t\t\tstruct pm8001_phy *phy = pm8001_ha->phy + phy_id;\n\t\t\tport_id = phy->port->port_id;\n\n\t\t\t \n\t\t\tpm8001_dev->setds_completion = &completion;\n\t\t\tPM8001_CHIP_DISP->set_dev_state_req(pm8001_ha,\n\t\t\t\tpm8001_dev, DS_IN_RECOVERY);\n\t\t\twait_for_completion(&completion);\n\n\t\t\t \n\t\t\treinit_completion(&completion);\n\t\t\tphy->port_reset_status = PORT_RESET_TMO;\n\t\t\tphy->reset_success = false;\n\t\t\tphy->enable_completion = &completion;\n\t\t\tphy->reset_completion = &completion_reset;\n\t\t\tret = PM8001_CHIP_DISP->phy_ctl_req(pm8001_ha, phy_id,\n\t\t\t\tPHY_HARD_RESET);\n\t\t\tif (ret) {\n\t\t\t\tphy->enable_completion = NULL;\n\t\t\t\tphy->reset_completion = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t\t   \"Waiting for local phy ctl\\n\");\n\t\t\tret = wait_for_completion_timeout(&completion,\n\t\t\t\t\tPM8001_TASK_TIMEOUT * HZ);\n\t\t\tif (!ret || !phy->reset_success) {\n\t\t\t\tphy->enable_completion = NULL;\n\t\t\t\tphy->reset_completion = NULL;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t\t\t   \"Waiting for Port reset\\n\");\n\t\t\t\tret = wait_for_completion_timeout(\n\t\t\t\t\t&completion_reset,\n\t\t\t\t\tPM8001_TASK_TIMEOUT * HZ);\n\t\t\t\tif (!ret)\n\t\t\t\t\tphy->reset_completion = NULL;\n\t\t\t\tWARN_ON(phy->port_reset_status ==\n\t\t\t\t\t\tPORT_RESET_TMO);\n\t\t\t\tif (phy->port_reset_status == PORT_RESET_TMO) {\n\t\t\t\t\tpm8001_dev_gone_notify(dev);\n\t\t\t\t\tPM8001_CHIP_DISP->hw_event_ack_req(\n\t\t\t\t\t\tpm8001_ha, 0,\n\t\t\t\t\t\t0x07,  \n\t\t\t\t\t\tport_id, phy_id, 0, 0);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tret = sas_execute_internal_abort_dev(dev, 0, NULL);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tret = wait_for_completion_timeout(\n\t\t\t\t&task->slow_task->completion,\n\t\t\t\tPM8001_TASK_TIMEOUT * HZ);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\treinit_completion(&completion);\n\t\t\tpm8001_dev->setds_completion = &completion;\n\t\t\tPM8001_CHIP_DISP->set_dev_state_req(pm8001_ha,\n\t\t\t\tpm8001_dev, DS_OPERATIONAL);\n\t\t\twait_for_completion(&completion);\n\t\t} else {\n\t\t\t \n\t\t\tccb->task = NULL;\n\t\t\tret = sas_execute_internal_abort_single(dev, tag, 0, NULL);\n\t\t}\n\t\trc = TMF_RESP_FUNC_COMPLETE;\n\t} else if (task->task_proto & SAS_PROTOCOL_SMP) {\n\t\t \n\t\trc = sas_execute_internal_abort_single(dev, tag, 0, NULL);\n\n\t}\nout:\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (task->slow_task == &slow_task)\n\t\ttask->slow_task = NULL;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tif (rc != TMF_RESP_FUNC_COMPLETE)\n\t\tpm8001_info(pm8001_ha, \"rc= %d\\n\", rc);\n\treturn rc;\n}\n\nint pm8001_clear_task_set(struct domain_device *dev, u8 *lun)\n{\n\tstruct pm8001_device *pm8001_dev = dev->lldd_dev;\n\tstruct pm8001_hba_info *pm8001_ha = pm8001_find_ha_by_dev(dev);\n\n\tpm8001_dbg(pm8001_ha, EH, \"I_T_L_Q clear task set[%x]\\n\",\n\t\t   pm8001_dev->device_id);\n\treturn sas_clear_task_set(dev, lun);\n}\n\nvoid pm8001_port_formed(struct asd_sas_phy *sas_phy)\n{\n\tstruct sas_ha_struct *sas_ha = sas_phy->ha;\n\tstruct pm8001_hba_info *pm8001_ha = sas_ha->lldd_ha;\n\tstruct pm8001_phy *phy = sas_phy->lldd_phy;\n\tstruct asd_sas_port *sas_port = sas_phy->port;\n\tstruct pm8001_port *port = phy->port;\n\n\tif (!sas_port) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"Received null port\\n\");\n\t\treturn;\n\t}\n\tsas_port->lldd_port = port;\n}\n\nvoid pm8001_setds_completion(struct domain_device *dev)\n{\n\tstruct pm8001_hba_info *pm8001_ha = pm8001_find_ha_by_dev(dev);\n\tstruct pm8001_device *pm8001_dev = dev->lldd_dev;\n\tDECLARE_COMPLETION_ONSTACK(completion_setstate);\n\n\tif (pm8001_ha->chip_id != chip_8001) {\n\t\tpm8001_dev->setds_completion = &completion_setstate;\n\t\tPM8001_CHIP_DISP->set_dev_state_req(pm8001_ha,\n\t\t\tpm8001_dev, DS_OPERATIONAL);\n\t\twait_for_completion(&completion_setstate);\n\t}\n}\n\nvoid pm8001_tmf_aborted(struct sas_task *task)\n{\n\tstruct pm8001_ccb_info *ccb = task->lldd_task;\n\n\tif (ccb)\n\t\tccb->task = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}