{
  "module_name": "pm8001_hwi.c",
  "hash_id": "4cc059f74a856d51d75d19e6c2471d1dce85073cf4aa881bfbf5c2442b8c4bad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/pm8001/pm8001_hwi.c",
  "human_readable_source": " \n #include <linux/slab.h>\n #include \"pm8001_sas.h\"\n #include \"pm8001_hwi.h\"\n #include \"pm8001_chips.h\"\n #include \"pm8001_ctl.h\"\n #include \"pm80xx_tracepoints.h\"\n\n \nstatic void read_main_config_table(struct pm8001_hba_info *pm8001_ha)\n{\n\tvoid __iomem *address = pm8001_ha->main_cfg_tbl_addr;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.signature\t=\n\t\t\t\tpm8001_mr32(address, 0x00);\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.interface_rev =\n\t\t\t\tpm8001_mr32(address, 0x04);\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.firmware_rev\t=\n\t\t\t\tpm8001_mr32(address, 0x08);\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.max_out_io\t=\n\t\t\t\tpm8001_mr32(address, 0x0C);\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.max_sgl\t=\n\t\t\t\tpm8001_mr32(address, 0x10);\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.ctrl_cap_flag =\n\t\t\t\tpm8001_mr32(address, 0x14);\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.gst_offset\t=\n\t\t\t\tpm8001_mr32(address, 0x18);\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.inbound_queue_offset =\n\t\tpm8001_mr32(address, MAIN_IBQ_OFFSET);\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_queue_offset =\n\t\tpm8001_mr32(address, MAIN_OBQ_OFFSET);\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.hda_mode_flag\t=\n\t\tpm8001_mr32(address, MAIN_HDA_FLAGS_OFFSET);\n\n\t \n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.anolog_setup_table_offset =\n\t\tpm8001_mr32(address, MAIN_ANALOG_SETUP_OFFSET);\n\n\t \n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.fatal_err_dump_offset0 =\n\t\tpm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP0_OFFSET);\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.fatal_err_dump_length0 =\n\t\tpm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP0_LENGTH);\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.fatal_err_dump_offset1 =\n\t\tpm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP1_OFFSET);\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.fatal_err_dump_length1 =\n\t\tpm8001_mr32(address, MAIN_FATAL_ERROR_RDUMP1_LENGTH);\n}\n\n \nstatic void read_general_status_table(struct pm8001_hba_info *pm8001_ha)\n{\n\tvoid __iomem *address = pm8001_ha->general_stat_tbl_addr;\n\tpm8001_ha->gs_tbl.pm8001_tbl.gst_len_mpistate\t=\n\t\t\t\tpm8001_mr32(address, 0x00);\n\tpm8001_ha->gs_tbl.pm8001_tbl.iq_freeze_state0\t=\n\t\t\t\tpm8001_mr32(address, 0x04);\n\tpm8001_ha->gs_tbl.pm8001_tbl.iq_freeze_state1\t=\n\t\t\t\tpm8001_mr32(address, 0x08);\n\tpm8001_ha->gs_tbl.pm8001_tbl.msgu_tcnt\t\t=\n\t\t\t\tpm8001_mr32(address, 0x0C);\n\tpm8001_ha->gs_tbl.pm8001_tbl.iop_tcnt\t\t=\n\t\t\t\tpm8001_mr32(address, 0x10);\n\tpm8001_ha->gs_tbl.pm8001_tbl.rsvd\t\t=\n\t\t\t\tpm8001_mr32(address, 0x14);\n\tpm8001_ha->gs_tbl.pm8001_tbl.phy_state[0]\t=\n\t\t\t\tpm8001_mr32(address, 0x18);\n\tpm8001_ha->gs_tbl.pm8001_tbl.phy_state[1]\t=\n\t\t\t\tpm8001_mr32(address, 0x1C);\n\tpm8001_ha->gs_tbl.pm8001_tbl.phy_state[2]\t=\n\t\t\t\tpm8001_mr32(address, 0x20);\n\tpm8001_ha->gs_tbl.pm8001_tbl.phy_state[3]\t=\n\t\t\t\tpm8001_mr32(address, 0x24);\n\tpm8001_ha->gs_tbl.pm8001_tbl.phy_state[4]\t=\n\t\t\t\tpm8001_mr32(address, 0x28);\n\tpm8001_ha->gs_tbl.pm8001_tbl.phy_state[5]\t=\n\t\t\t\tpm8001_mr32(address, 0x2C);\n\tpm8001_ha->gs_tbl.pm8001_tbl.phy_state[6]\t=\n\t\t\t\tpm8001_mr32(address, 0x30);\n\tpm8001_ha->gs_tbl.pm8001_tbl.phy_state[7]\t=\n\t\t\t\tpm8001_mr32(address, 0x34);\n\tpm8001_ha->gs_tbl.pm8001_tbl.gpio_input_val\t=\n\t\t\t\tpm8001_mr32(address, 0x38);\n\tpm8001_ha->gs_tbl.pm8001_tbl.rsvd1[0]\t\t=\n\t\t\t\tpm8001_mr32(address, 0x3C);\n\tpm8001_ha->gs_tbl.pm8001_tbl.rsvd1[1]\t\t=\n\t\t\t\tpm8001_mr32(address, 0x40);\n\tpm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[0]\t=\n\t\t\t\tpm8001_mr32(address, 0x44);\n\tpm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[1]\t=\n\t\t\t\tpm8001_mr32(address, 0x48);\n\tpm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[2]\t=\n\t\t\t\tpm8001_mr32(address, 0x4C);\n\tpm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[3]\t=\n\t\t\t\tpm8001_mr32(address, 0x50);\n\tpm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[4]\t=\n\t\t\t\tpm8001_mr32(address, 0x54);\n\tpm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[5]\t=\n\t\t\t\tpm8001_mr32(address, 0x58);\n\tpm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[6]\t=\n\t\t\t\tpm8001_mr32(address, 0x5C);\n\tpm8001_ha->gs_tbl.pm8001_tbl.recover_err_info[7]\t=\n\t\t\t\tpm8001_mr32(address, 0x60);\n}\n\n \nstatic void read_inbnd_queue_table(struct pm8001_hba_info *pm8001_ha)\n{\n\tint i;\n\tvoid __iomem *address = pm8001_ha->inbnd_q_tbl_addr;\n\tfor (i = 0; i < PM8001_MAX_INB_NUM; i++) {\n\t\tu32 offset = i * 0x20;\n\t\tpm8001_ha->inbnd_q_tbl[i].pi_pci_bar =\n\t\t      get_pci_bar_index(pm8001_mr32(address, (offset + 0x14)));\n\t\tpm8001_ha->inbnd_q_tbl[i].pi_offset =\n\t\t\tpm8001_mr32(address, (offset + 0x18));\n\t}\n}\n\n \nstatic void read_outbnd_queue_table(struct pm8001_hba_info *pm8001_ha)\n{\n\tint i;\n\tvoid __iomem *address = pm8001_ha->outbnd_q_tbl_addr;\n\tfor (i = 0; i < PM8001_MAX_OUTB_NUM; i++) {\n\t\tu32 offset = i * 0x24;\n\t\tpm8001_ha->outbnd_q_tbl[i].ci_pci_bar =\n\t\t      get_pci_bar_index(pm8001_mr32(address, (offset + 0x14)));\n\t\tpm8001_ha->outbnd_q_tbl[i].ci_offset =\n\t\t\tpm8001_mr32(address, (offset + 0x18));\n\t}\n}\n\n \nstatic void init_default_table_values(struct pm8001_hba_info *pm8001_ha)\n{\n\tint i;\n\tu32 offsetib, offsetob;\n\tvoid __iomem *addressib = pm8001_ha->inbnd_q_tbl_addr;\n\tvoid __iomem *addressob = pm8001_ha->outbnd_q_tbl_addr;\n\tu32 ib_offset = pm8001_ha->ib_offset;\n\tu32 ob_offset = pm8001_ha->ob_offset;\n\tu32 ci_offset = pm8001_ha->ci_offset;\n\tu32 pi_offset = pm8001_ha->pi_offset;\n\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.inbound_q_nppd_hppd\t\t= 0;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_hw_event_pid0_3\t= 0;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_hw_event_pid4_7\t= 0;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_ncq_event_pid0_3\t= 0;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_ncq_event_pid4_7\t= 0;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_tgt_ITNexus_event_pid0_3 =\n\t\t\t\t\t\t\t\t\t 0;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_tgt_ITNexus_event_pid4_7 =\n\t\t\t\t\t\t\t\t\t 0;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_tgt_ssp_event_pid0_3 = 0;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_tgt_ssp_event_pid4_7 = 0;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_tgt_smp_event_pid0_3 = 0;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_tgt_smp_event_pid4_7 = 0;\n\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.upper_event_log_addr\t\t=\n\t\tpm8001_ha->memoryMap.region[AAP1].phys_addr_hi;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.lower_event_log_addr\t\t=\n\t\tpm8001_ha->memoryMap.region[AAP1].phys_addr_lo;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.event_log_size\t\t=\n\t\tPM8001_EVENT_LOG_SIZE;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.event_log_option\t\t= 0x01;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.upper_iop_event_log_addr\t=\n\t\tpm8001_ha->memoryMap.region[IOP].phys_addr_hi;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.lower_iop_event_log_addr\t=\n\t\tpm8001_ha->memoryMap.region[IOP].phys_addr_lo;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.iop_event_log_size\t\t=\n\t\tPM8001_EVENT_LOG_SIZE;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.iop_event_log_option\t\t= 0x01;\n\tpm8001_ha->main_cfg_tbl.pm8001_tbl.fatal_err_interrupt\t\t= 0x01;\n\tfor (i = 0; i < pm8001_ha->max_q_num; i++) {\n\t\tpm8001_ha->inbnd_q_tbl[i].element_pri_size_cnt\t=\n\t\t\tPM8001_MPI_QUEUE | (pm8001_ha->iomb_size << 16) | (0x00<<30);\n\t\tpm8001_ha->inbnd_q_tbl[i].upper_base_addr\t=\n\t\t\tpm8001_ha->memoryMap.region[ib_offset + i].phys_addr_hi;\n\t\tpm8001_ha->inbnd_q_tbl[i].lower_base_addr\t=\n\t\tpm8001_ha->memoryMap.region[ib_offset + i].phys_addr_lo;\n\t\tpm8001_ha->inbnd_q_tbl[i].base_virt\t\t=\n\t\t  (u8 *)pm8001_ha->memoryMap.region[ib_offset + i].virt_ptr;\n\t\tpm8001_ha->inbnd_q_tbl[i].total_length\t\t=\n\t\t\tpm8001_ha->memoryMap.region[ib_offset + i].total_len;\n\t\tpm8001_ha->inbnd_q_tbl[i].ci_upper_base_addr\t=\n\t\t\tpm8001_ha->memoryMap.region[ci_offset + i].phys_addr_hi;\n\t\tpm8001_ha->inbnd_q_tbl[i].ci_lower_base_addr\t=\n\t\t\tpm8001_ha->memoryMap.region[ci_offset + i].phys_addr_lo;\n\t\tpm8001_ha->inbnd_q_tbl[i].ci_virt\t\t=\n\t\t\tpm8001_ha->memoryMap.region[ci_offset + i].virt_ptr;\n\t\tpm8001_write_32(pm8001_ha->inbnd_q_tbl[i].ci_virt, 0, 0);\n\t\toffsetib = i * 0x20;\n\t\tpm8001_ha->inbnd_q_tbl[i].pi_pci_bar\t\t=\n\t\t\tget_pci_bar_index(pm8001_mr32(addressib,\n\t\t\t\t(offsetib + 0x14)));\n\t\tpm8001_ha->inbnd_q_tbl[i].pi_offset\t\t=\n\t\t\tpm8001_mr32(addressib, (offsetib + 0x18));\n\t\tpm8001_ha->inbnd_q_tbl[i].producer_idx\t\t= 0;\n\t\tpm8001_ha->inbnd_q_tbl[i].consumer_index\t= 0;\n\t}\n\tfor (i = 0; i < pm8001_ha->max_q_num; i++) {\n\t\tpm8001_ha->outbnd_q_tbl[i].element_size_cnt\t=\n\t\t\tPM8001_MPI_QUEUE | (pm8001_ha->iomb_size << 16) | (0x01<<30);\n\t\tpm8001_ha->outbnd_q_tbl[i].upper_base_addr\t=\n\t\t\tpm8001_ha->memoryMap.region[ob_offset + i].phys_addr_hi;\n\t\tpm8001_ha->outbnd_q_tbl[i].lower_base_addr\t=\n\t\t\tpm8001_ha->memoryMap.region[ob_offset + i].phys_addr_lo;\n\t\tpm8001_ha->outbnd_q_tbl[i].base_virt\t\t=\n\t\t  (u8 *)pm8001_ha->memoryMap.region[ob_offset + i].virt_ptr;\n\t\tpm8001_ha->outbnd_q_tbl[i].total_length\t\t=\n\t\t\tpm8001_ha->memoryMap.region[ob_offset + i].total_len;\n\t\tpm8001_ha->outbnd_q_tbl[i].pi_upper_base_addr\t=\n\t\t\tpm8001_ha->memoryMap.region[pi_offset + i].phys_addr_hi;\n\t\tpm8001_ha->outbnd_q_tbl[i].pi_lower_base_addr\t=\n\t\t\tpm8001_ha->memoryMap.region[pi_offset + i].phys_addr_lo;\n\t\tpm8001_ha->outbnd_q_tbl[i].interrup_vec_cnt_delay\t=\n\t\t\t0 | (10 << 16) | (i << 24);\n\t\tpm8001_ha->outbnd_q_tbl[i].pi_virt\t\t=\n\t\t\tpm8001_ha->memoryMap.region[pi_offset + i].virt_ptr;\n\t\tpm8001_write_32(pm8001_ha->outbnd_q_tbl[i].pi_virt, 0, 0);\n\t\toffsetob = i * 0x24;\n\t\tpm8001_ha->outbnd_q_tbl[i].ci_pci_bar\t\t=\n\t\t\tget_pci_bar_index(pm8001_mr32(addressob,\n\t\t\toffsetob + 0x14));\n\t\tpm8001_ha->outbnd_q_tbl[i].ci_offset\t\t=\n\t\t\tpm8001_mr32(addressob, (offsetob + 0x18));\n\t\tpm8001_ha->outbnd_q_tbl[i].consumer_idx\t\t= 0;\n\t\tpm8001_ha->outbnd_q_tbl[i].producer_index\t= 0;\n\t}\n}\n\n \nstatic void update_main_config_table(struct pm8001_hba_info *pm8001_ha)\n{\n\tvoid __iomem *address = pm8001_ha->main_cfg_tbl_addr;\n\tpm8001_mw32(address, 0x24,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.inbound_q_nppd_hppd);\n\tpm8001_mw32(address, 0x28,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_hw_event_pid0_3);\n\tpm8001_mw32(address, 0x2C,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_hw_event_pid4_7);\n\tpm8001_mw32(address, 0x30,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_ncq_event_pid0_3);\n\tpm8001_mw32(address, 0x34,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.outbound_ncq_event_pid4_7);\n\tpm8001_mw32(address, 0x38,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.\n\t\t\t\t\toutbound_tgt_ITNexus_event_pid0_3);\n\tpm8001_mw32(address, 0x3C,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.\n\t\t\t\t\toutbound_tgt_ITNexus_event_pid4_7);\n\tpm8001_mw32(address, 0x40,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.\n\t\t\t\t\toutbound_tgt_ssp_event_pid0_3);\n\tpm8001_mw32(address, 0x44,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.\n\t\t\t\t\toutbound_tgt_ssp_event_pid4_7);\n\tpm8001_mw32(address, 0x48,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.\n\t\t\t\t\toutbound_tgt_smp_event_pid0_3);\n\tpm8001_mw32(address, 0x4C,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.\n\t\t\t\t\toutbound_tgt_smp_event_pid4_7);\n\tpm8001_mw32(address, 0x50,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.upper_event_log_addr);\n\tpm8001_mw32(address, 0x54,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.lower_event_log_addr);\n\tpm8001_mw32(address, 0x58,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.event_log_size);\n\tpm8001_mw32(address, 0x5C,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.event_log_option);\n\tpm8001_mw32(address, 0x60,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.upper_iop_event_log_addr);\n\tpm8001_mw32(address, 0x64,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.lower_iop_event_log_addr);\n\tpm8001_mw32(address, 0x68,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.iop_event_log_size);\n\tpm8001_mw32(address, 0x6C,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.iop_event_log_option);\n\tpm8001_mw32(address, 0x70,\n\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.fatal_err_interrupt);\n}\n\n \nstatic void update_inbnd_queue_table(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t     int number)\n{\n\tvoid __iomem *address = pm8001_ha->inbnd_q_tbl_addr;\n\tu16 offset = number * 0x20;\n\tpm8001_mw32(address, offset + 0x00,\n\t\tpm8001_ha->inbnd_q_tbl[number].element_pri_size_cnt);\n\tpm8001_mw32(address, offset + 0x04,\n\t\tpm8001_ha->inbnd_q_tbl[number].upper_base_addr);\n\tpm8001_mw32(address, offset + 0x08,\n\t\tpm8001_ha->inbnd_q_tbl[number].lower_base_addr);\n\tpm8001_mw32(address, offset + 0x0C,\n\t\tpm8001_ha->inbnd_q_tbl[number].ci_upper_base_addr);\n\tpm8001_mw32(address, offset + 0x10,\n\t\tpm8001_ha->inbnd_q_tbl[number].ci_lower_base_addr);\n}\n\n \nstatic void update_outbnd_queue_table(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t      int number)\n{\n\tvoid __iomem *address = pm8001_ha->outbnd_q_tbl_addr;\n\tu16 offset = number * 0x24;\n\tpm8001_mw32(address, offset + 0x00,\n\t\tpm8001_ha->outbnd_q_tbl[number].element_size_cnt);\n\tpm8001_mw32(address, offset + 0x04,\n\t\tpm8001_ha->outbnd_q_tbl[number].upper_base_addr);\n\tpm8001_mw32(address, offset + 0x08,\n\t\tpm8001_ha->outbnd_q_tbl[number].lower_base_addr);\n\tpm8001_mw32(address, offset + 0x0C,\n\t\tpm8001_ha->outbnd_q_tbl[number].pi_upper_base_addr);\n\tpm8001_mw32(address, offset + 0x10,\n\t\tpm8001_ha->outbnd_q_tbl[number].pi_lower_base_addr);\n\tpm8001_mw32(address, offset + 0x1C,\n\t\tpm8001_ha->outbnd_q_tbl[number].interrup_vec_cnt_delay);\n}\n\n \nint pm8001_bar4_shift(struct pm8001_hba_info *pm8001_ha, u32 shiftValue)\n{\n\tu32 regVal;\n\tunsigned long start;\n\n\t \n\tpm8001_cw32(pm8001_ha, 1, SPC_IBW_AXI_TRANSLATION_LOW, shiftValue);\n\n\t \n\tstart = jiffies + HZ;  \n\tdo {\n\t\tregVal = pm8001_cr32(pm8001_ha, 1, SPC_IBW_AXI_TRANSLATION_LOW);\n\t} while ((regVal != shiftValue) && time_before(jiffies, start));\n\n\tif (regVal != shiftValue) {\n\t\tpm8001_dbg(pm8001_ha, INIT,\n\t\t\t   \"TIMEOUT:SPC_IBW_AXI_TRANSLATION_LOW = 0x%x\\n\",\n\t\t\t   regVal);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic void mpi_set_phys_g3_with_ssc(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t     u32 SSCbit)\n{\n\tu32 offset, i;\n\tunsigned long flags;\n\n#define SAS2_SETTINGS_LOCAL_PHY_0_3_SHIFT_ADDR 0x00030000\n#define SAS2_SETTINGS_LOCAL_PHY_4_7_SHIFT_ADDR 0x00040000\n#define SAS2_SETTINGS_LOCAL_PHY_0_3_OFFSET 0x1074\n#define SAS2_SETTINGS_LOCAL_PHY_4_7_OFFSET 0x1074\n#define PHY_G3_WITHOUT_SSC_BIT_SHIFT 12\n#define PHY_G3_WITH_SSC_BIT_SHIFT 13\n#define SNW3_PHY_CAPABILITIES_PARITY 31\n\n    \n\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\tif (-1 == pm8001_bar4_shift(pm8001_ha,\n\t\t\t\tSAS2_SETTINGS_LOCAL_PHY_0_3_SHIFT_ADDR)) {\n\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\toffset = SAS2_SETTINGS_LOCAL_PHY_0_3_OFFSET + 0x4000 * i;\n\t\tpm8001_cw32(pm8001_ha, 2, offset, 0x80001501);\n\t}\n\t \n\tif (-1 == pm8001_bar4_shift(pm8001_ha,\n\t\t\t\tSAS2_SETTINGS_LOCAL_PHY_4_7_SHIFT_ADDR)) {\n\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\treturn;\n\t}\n\tfor (i = 4; i < 8; i++) {\n\t\toffset = SAS2_SETTINGS_LOCAL_PHY_4_7_OFFSET + 0x4000 * (i-4);\n\t\tpm8001_cw32(pm8001_ha, 2, offset, 0x80001501);\n\t}\n\t \n\tpm8001_cr32(pm8001_ha, 2, 0xd8);\n\tpm8001_cw32(pm8001_ha, 2, 0xd8, 0x8000C016);\n\n\t \n\tpm8001_bar4_shift(pm8001_ha, 0x0);\n\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\treturn;\n}\n\n \nstatic void mpi_set_open_retry_interval_reg(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\t    u32 interval)\n{\n\tu32 offset;\n\tu32 value;\n\tu32 i;\n\tunsigned long flags;\n\n#define OPEN_RETRY_INTERVAL_PHY_0_3_SHIFT_ADDR 0x00030000\n#define OPEN_RETRY_INTERVAL_PHY_4_7_SHIFT_ADDR 0x00040000\n#define OPEN_RETRY_INTERVAL_PHY_0_3_OFFSET 0x30B4\n#define OPEN_RETRY_INTERVAL_PHY_4_7_OFFSET 0x30B4\n#define OPEN_RETRY_INTERVAL_REG_MASK 0x0000FFFF\n\n\tvalue = interval & OPEN_RETRY_INTERVAL_REG_MASK;\n\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\t \n\tif (-1 == pm8001_bar4_shift(pm8001_ha,\n\t\t\t     OPEN_RETRY_INTERVAL_PHY_0_3_SHIFT_ADDR)) {\n\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\treturn;\n\t}\n\tfor (i = 0; i < 4; i++) {\n\t\toffset = OPEN_RETRY_INTERVAL_PHY_0_3_OFFSET + 0x4000 * i;\n\t\tpm8001_cw32(pm8001_ha, 2, offset, value);\n\t}\n\n\tif (-1 == pm8001_bar4_shift(pm8001_ha,\n\t\t\t     OPEN_RETRY_INTERVAL_PHY_4_7_SHIFT_ADDR)) {\n\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\treturn;\n\t}\n\tfor (i = 4; i < 8; i++) {\n\t\toffset = OPEN_RETRY_INTERVAL_PHY_4_7_OFFSET + 0x4000 * (i-4);\n\t\tpm8001_cw32(pm8001_ha, 2, offset, value);\n\t}\n\t \n\tpm8001_bar4_shift(pm8001_ha, 0x0);\n\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\treturn;\n}\n\n \nstatic int mpi_init_check(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32 max_wait_count;\n\tu32 value;\n\tu32 gst_len_mpistate;\n\t \n\tpm8001_cw32(pm8001_ha, 0, MSGU_IBDB_SET, SPC_MSGU_CFG_TABLE_UPDATE);\n\t \n\tmax_wait_count = 1 * 1000 * 1000; \n\tdo {\n\t\tudelay(1);\n\t\tvalue = pm8001_cr32(pm8001_ha, 0, MSGU_IBDB_SET);\n\t\tvalue &= SPC_MSGU_CFG_TABLE_UPDATE;\n\t} while ((value != 0) && (--max_wait_count));\n\n\tif (!max_wait_count)\n\t\treturn -1;\n\t \n\tgst_len_mpistate =\n\t\tpm8001_mr32(pm8001_ha->general_stat_tbl_addr,\n\t\tGST_GSTLEN_MPIS_OFFSET);\n\tif (GST_MPI_STATE_INIT != (gst_len_mpistate & GST_MPI_STATE_MASK))\n\t\treturn -1;\n\t \n\tgst_len_mpistate = gst_len_mpistate >> 16;\n\tif (0x0000 != gst_len_mpistate)\n\t\treturn -1;\n\treturn 0;\n}\n\n \nstatic int check_fw_ready(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32 value, value1;\n\tu32 max_wait_count;\n\t \n\tvalue = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\n\tvalue1 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_2);\n\t \n\tif (SCRATCH_PAD1_ERR == (value & SCRATCH_PAD_STATE_MASK)) {\n\t\t \n\t\tvalue = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_0);\n\t\treturn -1;\n\t}\n\n\t \n\tif (SCRATCH_PAD2_ERR == (value1 & SCRATCH_PAD_STATE_MASK)) {\n\t\t \n\t\tvalue1 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_3);\n\t\treturn -1;\n\t}\n\n\t \n\tif (value & SCRATCH_PAD1_STATE_MASK) {\n\t\t \n\t\tpm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_0);\n\t\treturn -1;\n\t}\n\n\t \n\tif (value1 & SCRATCH_PAD2_STATE_MASK) {\n\t\t \n\t\treturn -1;\n\t}\n\n\tmax_wait_count = 1 * 1000 * 1000; \n\n\t \n\tdo {\n\t\tudelay(1);\n\t\tvalue = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1)\n\t\t\t& SCRATCH_PAD1_RDY;\n\t\tvalue1 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_2)\n\t\t\t& SCRATCH_PAD2_RDY;\n\t\tif ((--max_wait_count) == 0)\n\t\t\treturn -1;\n\t} while ((value != SCRATCH_PAD1_RDY) || (value1 != SCRATCH_PAD2_RDY));\n\treturn 0;\n}\n\nstatic void init_pci_device_addresses(struct pm8001_hba_info *pm8001_ha)\n{\n\tvoid __iomem *base_addr;\n\tu32\tvalue;\n\tu32\toffset;\n\tu32\tpcibar;\n\tu32\tpcilogic;\n\n\tvalue = pm8001_cr32(pm8001_ha, 0, 0x44);\n\toffset = value & 0x03FFFFFF;\n\tpm8001_dbg(pm8001_ha, INIT, \"Scratchpad 0 Offset: %x\\n\", offset);\n\tpcilogic = (value & 0xFC000000) >> 26;\n\tpcibar = get_pci_bar_index(pcilogic);\n\tpm8001_dbg(pm8001_ha, INIT, \"Scratchpad 0 PCI BAR: %d\\n\", pcibar);\n\tpm8001_ha->main_cfg_tbl_addr = base_addr =\n\t\tpm8001_ha->io_mem[pcibar].memvirtaddr + offset;\n\tpm8001_ha->general_stat_tbl_addr =\n\t\tbase_addr + pm8001_cr32(pm8001_ha, pcibar, offset + 0x18);\n\tpm8001_ha->inbnd_q_tbl_addr =\n\t\tbase_addr + pm8001_cr32(pm8001_ha, pcibar, offset + 0x1C);\n\tpm8001_ha->outbnd_q_tbl_addr =\n\t\tbase_addr + pm8001_cr32(pm8001_ha, pcibar, offset + 0x20);\n}\n\n \nstatic int pm8001_chip_init(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32 i = 0;\n\tu16 deviceid;\n\tpci_read_config_word(pm8001_ha->pdev, PCI_DEVICE_ID, &deviceid);\n\t \n\tif (deviceid == 0x8081 || deviceid == 0x0042) {\n\t\tif (-1 == pm8001_bar4_shift(pm8001_ha, GSM_SM_BASE)) {\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"Shift Bar4 to 0x%x failed\\n\",\n\t\t\t\t   GSM_SM_BASE);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t \n\tif (-1 == check_fw_ready(pm8001_ha)) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"Firmware is not ready!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tinit_pci_device_addresses(pm8001_ha);\n\tinit_default_table_values(pm8001_ha);\n\tread_main_config_table(pm8001_ha);\n\tread_general_status_table(pm8001_ha);\n\tread_inbnd_queue_table(pm8001_ha);\n\tread_outbnd_queue_table(pm8001_ha);\n\t \n\tupdate_main_config_table(pm8001_ha);\n\tfor (i = 0; i < pm8001_ha->max_q_num; i++)\n\t\tupdate_inbnd_queue_table(pm8001_ha, i);\n\tfor (i = 0; i < pm8001_ha->max_q_num; i++)\n\t\tupdate_outbnd_queue_table(pm8001_ha, i);\n\t \n\tif (deviceid != 0x8081 && deviceid != 0x0042) {\n\t\tmpi_set_phys_g3_with_ssc(pm8001_ha, 0);\n\t\t \n\t\tmpi_set_open_retry_interval_reg(pm8001_ha, 119);\n\t}\n\t \n\tif (0 == mpi_init_check(pm8001_ha)) {\n\t\tpm8001_dbg(pm8001_ha, INIT, \"MPI initialize successful!\\n\");\n\t} else\n\t\treturn -EBUSY;\n\t \n\tpm8001_cw32(pm8001_ha, 1, 0x0033c0, 0x1);\n\tpm8001_cw32(pm8001_ha, 1, 0x0033c4, 0x0);\n\treturn 0;\n}\n\nstatic void pm8001_chip_post_init(struct pm8001_hba_info *pm8001_ha)\n{\n}\n\nstatic int mpi_uninit_check(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32 max_wait_count;\n\tu32 value;\n\tu32 gst_len_mpistate;\n\tu16 deviceid;\n\tpci_read_config_word(pm8001_ha->pdev, PCI_DEVICE_ID, &deviceid);\n\tif (deviceid == 0x8081 || deviceid == 0x0042) {\n\t\tif (-1 == pm8001_bar4_shift(pm8001_ha, GSM_SM_BASE)) {\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"Shift Bar4 to 0x%x failed\\n\",\n\t\t\t\t   GSM_SM_BASE);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tinit_pci_device_addresses(pm8001_ha);\n\t \n\tpm8001_cw32(pm8001_ha, 0, MSGU_IBDB_SET, SPC_MSGU_CFG_TABLE_RESET);\n\n\t \n\tmax_wait_count = 1 * 1000 * 1000; \n\tdo {\n\t\tudelay(1);\n\t\tvalue = pm8001_cr32(pm8001_ha, 0, MSGU_IBDB_SET);\n\t\tvalue &= SPC_MSGU_CFG_TABLE_RESET;\n\t} while ((value != 0) && (--max_wait_count));\n\n\tif (!max_wait_count) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"TIMEOUT:IBDB value/=0x%x\\n\",\n\t\t\t   value);\n\t\treturn -1;\n\t}\n\n\t \n\t \n\tmax_wait_count = 1 * 1000 * 1000;   \n\tdo {\n\t\tudelay(1);\n\t\tgst_len_mpistate =\n\t\t\tpm8001_mr32(pm8001_ha->general_stat_tbl_addr,\n\t\t\tGST_GSTLEN_MPIS_OFFSET);\n\t\tif (GST_MPI_STATE_UNINIT ==\n\t\t\t(gst_len_mpistate & GST_MPI_STATE_MASK))\n\t\t\tbreak;\n\t} while (--max_wait_count);\n\tif (!max_wait_count) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \" TIME OUT MPI State = 0x%x\\n\",\n\t\t\t   gst_len_mpistate & GST_MPI_STATE_MASK);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic u32 soft_reset_ready_check(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32 regVal, regVal1, regVal2;\n\tif (mpi_uninit_check(pm8001_ha) != 0) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"MPI state is not ready\\n\");\n\t\treturn -1;\n\t}\n\t \n\tregVal = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_2)\n\t\t& SCRATCH_PAD2_FWRDY_RST;\n\tif (regVal == SCRATCH_PAD2_FWRDY_RST) {\n\t\tpm8001_dbg(pm8001_ha, INIT, \"Firmware is ready for reset.\\n\");\n\t} else {\n\t\tunsigned long flags;\n\t\t \n\t\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\t\tif (-1 == pm8001_bar4_shift(pm8001_ha, RB6_ACCESS_REG)) {\n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"Shift Bar4 to 0x%x failed\\n\",\n\t\t\t\t   RB6_ACCESS_REG);\n\t\t\treturn -1;\n\t\t}\n\t\tpm8001_cw32(pm8001_ha, 2, SPC_RB6_OFFSET,\n\t\t\tRB6_MAGIC_NUMBER_RST);\n\t\tpm8001_cw32(pm8001_ha, 2, SPC_RB6_OFFSET, RB6_MAGIC_NUMBER_RST);\n\t\t \n\t\tmdelay(100);\n\t\tregVal = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_2) &\n\t\t\tSCRATCH_PAD2_FWRDY_RST;\n\t\tif (regVal != SCRATCH_PAD2_FWRDY_RST) {\n\t\t\tregVal1 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\n\t\t\tregVal2 = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_2);\n\t\t\tpm8001_dbg(pm8001_ha, FAIL, \"TIMEOUT:MSGU_SCRATCH_PAD1=0x%x, MSGU_SCRATCH_PAD2=0x%x\\n\",\n\t\t\t\t   regVal1, regVal2);\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"SCRATCH_PAD0 value = 0x%x\\n\",\n\t\t\t\t   pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_0));\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"SCRATCH_PAD3 value = 0x%x\\n\",\n\t\t\t\t   pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_3));\n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\treturn -1;\n\t\t}\n\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t}\n\treturn 0;\n}\n\n \nstatic int\npm8001_chip_soft_rst(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32\tregVal, toggleVal;\n\tu32\tmax_wait_count;\n\tu32\tregVal1, regVal2, regVal3;\n\tu32\tsignature = 0x252acbcd;  \n\tunsigned long flags;\n\n\t \n\tif (soft_reset_ready_check(pm8001_ha) != 0) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"FW is not ready\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\t \n\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\tif (-1 == pm8001_bar4_shift(pm8001_ha, MBIC_AAP1_ADDR_BASE)) {\n\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"Shift Bar4 to 0x%x failed\\n\",\n\t\t\t   MBIC_AAP1_ADDR_BASE);\n\t\treturn -1;\n\t}\n\tregVal = pm8001_cr32(pm8001_ha, 2, MBIC_NMI_ENABLE_VPE0_IOP);\n\tpm8001_dbg(pm8001_ha, INIT, \"MBIC - NMI Enable VPE0 (IOP)= 0x%x\\n\",\n\t\t   regVal);\n\tpm8001_cw32(pm8001_ha, 2, MBIC_NMI_ENABLE_VPE0_IOP, 0x0);\n\t \n\tif (-1 == pm8001_bar4_shift(pm8001_ha, MBIC_IOP_ADDR_BASE)) {\n\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"Shift Bar4 to 0x%x failed\\n\",\n\t\t\t   MBIC_IOP_ADDR_BASE);\n\t\treturn -1;\n\t}\n\tregVal = pm8001_cr32(pm8001_ha, 2, MBIC_NMI_ENABLE_VPE0_AAP1);\n\tpm8001_dbg(pm8001_ha, INIT, \"MBIC - NMI Enable VPE0 (AAP1)= 0x%x\\n\",\n\t\t   regVal);\n\tpm8001_cw32(pm8001_ha, 2, MBIC_NMI_ENABLE_VPE0_AAP1, 0x0);\n\n\tregVal = pm8001_cr32(pm8001_ha, 1, PCIE_EVENT_INTERRUPT_ENABLE);\n\tpm8001_dbg(pm8001_ha, INIT, \"PCIE -Event Interrupt Enable = 0x%x\\n\",\n\t\t   regVal);\n\tpm8001_cw32(pm8001_ha, 1, PCIE_EVENT_INTERRUPT_ENABLE, 0x0);\n\n\tregVal = pm8001_cr32(pm8001_ha, 1, PCIE_EVENT_INTERRUPT);\n\tpm8001_dbg(pm8001_ha, INIT, \"PCIE - Event Interrupt  = 0x%x\\n\",\n\t\t   regVal);\n\tpm8001_cw32(pm8001_ha, 1, PCIE_EVENT_INTERRUPT, regVal);\n\n\tregVal = pm8001_cr32(pm8001_ha, 1, PCIE_ERROR_INTERRUPT_ENABLE);\n\tpm8001_dbg(pm8001_ha, INIT, \"PCIE -Error Interrupt Enable = 0x%x\\n\",\n\t\t   regVal);\n\tpm8001_cw32(pm8001_ha, 1, PCIE_ERROR_INTERRUPT_ENABLE, 0x0);\n\n\tregVal = pm8001_cr32(pm8001_ha, 1, PCIE_ERROR_INTERRUPT);\n\tpm8001_dbg(pm8001_ha, INIT, \"PCIE - Error Interrupt = 0x%x\\n\", regVal);\n\tpm8001_cw32(pm8001_ha, 1, PCIE_ERROR_INTERRUPT, regVal);\n\n\t \n\tregVal = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1)\n\t\t& SCRATCH_PAD1_RST;\n\ttoggleVal = regVal ^ SCRATCH_PAD1_RST;\n\n\t \n\tpm8001_cw32(pm8001_ha, 0, MSGU_HOST_SCRATCH_PAD_0, signature);\n\n\t \n\t \n\tif (-1 == pm8001_bar4_shift(pm8001_ha, GSM_ADDR_BASE)) {\n\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"Shift Bar4 to 0x%x failed\\n\",\n\t\t\t   GSM_ADDR_BASE);\n\t\treturn -1;\n\t}\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"GSM 0x0(0x00007b88)-GSM Configuration and Reset = 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 2, GSM_CONFIG_RESET));\n\n\t \n\tregVal = pm8001_cr32(pm8001_ha, 2, GSM_CONFIG_RESET);\n\t \n\t \n\tregVal &= ~(0x00003b00);\n\t \n\tpm8001_cw32(pm8001_ha, 2, GSM_CONFIG_RESET, regVal);\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"GSM 0x0 (0x00007b88 ==> 0x00004088) - GSM Configuration and Reset is set to = 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 2, GSM_CONFIG_RESET));\n\n\t \n\t \n\tregVal1 = pm8001_cr32(pm8001_ha, 2, GSM_READ_ADDR_PARITY_CHECK);\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"GSM 0x700038 - Read Address Parity Check Enable = 0x%x\\n\",\n\t\t   regVal1);\n\tpm8001_cw32(pm8001_ha, 2, GSM_READ_ADDR_PARITY_CHECK, 0x0);\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"GSM 0x700038 - Read Address Parity Check Enable is set to = 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 2, GSM_READ_ADDR_PARITY_CHECK));\n\n\t \n\tregVal2 = pm8001_cr32(pm8001_ha, 2, GSM_WRITE_ADDR_PARITY_CHECK);\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"GSM 0x700040 - Write Address Parity Check Enable = 0x%x\\n\",\n\t\t   regVal2);\n\tpm8001_cw32(pm8001_ha, 2, GSM_WRITE_ADDR_PARITY_CHECK, 0x0);\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"GSM 0x700040 - Write Address Parity Check Enable is set to = 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 2, GSM_WRITE_ADDR_PARITY_CHECK));\n\n\t \n\tregVal3 = pm8001_cr32(pm8001_ha, 2, GSM_WRITE_DATA_PARITY_CHECK);\n\tpm8001_dbg(pm8001_ha, INIT, \"GSM 0x300048 - Write Data Parity Check Enable = 0x%x\\n\",\n\t\t   regVal3);\n\tpm8001_cw32(pm8001_ha, 2, GSM_WRITE_DATA_PARITY_CHECK, 0x0);\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"GSM 0x300048 - Write Data Parity Check Enable is set to = 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 2, GSM_WRITE_DATA_PARITY_CHECK));\n\n\t \n\tudelay(10);\n\t \n\tif (-1 == pm8001_bar4_shift(pm8001_ha, GPIO_ADDR_BASE)) {\n\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\tpm8001_dbg(pm8001_ha, INIT, \"Shift Bar4 to 0x%x failed\\n\",\n\t\t\t   GPIO_ADDR_BASE);\n\t\treturn -1;\n\t}\n\tregVal = pm8001_cr32(pm8001_ha, 2, GPIO_GPIO_0_0UTPUT_CTL_OFFSET);\n\tpm8001_dbg(pm8001_ha, INIT, \"GPIO Output Control Register: = 0x%x\\n\",\n\t\t   regVal);\n\t \n\tregVal &= 0xFFFFFFFC;\n\tpm8001_cw32(pm8001_ha, 2, GPIO_GPIO_0_0UTPUT_CTL_OFFSET, regVal);\n\n\t \n\t \n\tif (-1 == pm8001_bar4_shift(pm8001_ha, SPC_TOP_LEVEL_ADDR_BASE)) {\n\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"SPC Shift Bar4 to 0x%x failed\\n\",\n\t\t\t   SPC_TOP_LEVEL_ADDR_BASE);\n\t\treturn -1;\n\t}\n\tregVal = pm8001_cr32(pm8001_ha, 2, SPC_REG_RESET);\n\tpm8001_dbg(pm8001_ha, INIT, \"Top Register before resetting IOP/AAP1:= 0x%x\\n\",\n\t\t   regVal);\n\tregVal &= ~(SPC_REG_RESET_PCS_IOP_SS | SPC_REG_RESET_PCS_AAP1_SS);\n\tpm8001_cw32(pm8001_ha, 2, SPC_REG_RESET, regVal);\n\n\t \n\tregVal = pm8001_cr32(pm8001_ha, 2, SPC_REG_RESET);\n\tpm8001_dbg(pm8001_ha, INIT, \"Top Register before resetting BDMA/OSSP: = 0x%x\\n\",\n\t\t   regVal);\n\tregVal &= ~(SPC_REG_RESET_BDMA_CORE | SPC_REG_RESET_OSSP);\n\tpm8001_cw32(pm8001_ha, 2, SPC_REG_RESET, regVal);\n\n\t \n\tudelay(10);\n\n\t \n\tregVal = pm8001_cr32(pm8001_ha, 2, SPC_REG_RESET);\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"Top Register before bringing up BDMA/OSSP:= 0x%x\\n\",\n\t\t   regVal);\n\tregVal |= (SPC_REG_RESET_BDMA_CORE | SPC_REG_RESET_OSSP);\n\tpm8001_cw32(pm8001_ha, 2, SPC_REG_RESET, regVal);\n\n\t \n\tudelay(10);\n\n\t \n\t \n\tif (-1 == pm8001_bar4_shift(pm8001_ha, GSM_ADDR_BASE)) {\n\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"SPC Shift Bar4 to 0x%x failed\\n\",\n\t\t\t   GSM_ADDR_BASE);\n\t\treturn -1;\n\t}\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"GSM 0x0 (0x00007b88)-GSM Configuration and Reset = 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 2, GSM_CONFIG_RESET));\n\tregVal = pm8001_cr32(pm8001_ha, 2, GSM_CONFIG_RESET);\n\t \n\t \n\tregVal |= (GSM_CONFIG_RESET_VALUE);\n\tpm8001_cw32(pm8001_ha, 2, GSM_CONFIG_RESET, regVal);\n\tpm8001_dbg(pm8001_ha, INIT, \"GSM (0x00004088 ==> 0x00007b88) - GSM Configuration and Reset is set to = 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 2, GSM_CONFIG_RESET));\n\n\t \n\tregVal = pm8001_cr32(pm8001_ha, 2, GSM_READ_ADDR_PARITY_CHECK);\n\t \n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"GSM 0x700038 - Read Address Parity Check Enable = 0x%x\\n\",\n\t\t   regVal);\n\tpm8001_cw32(pm8001_ha, 2, GSM_READ_ADDR_PARITY_CHECK, regVal1);\n\tpm8001_dbg(pm8001_ha, INIT, \"GSM 0x700038 - Read Address Parity Check Enable is set to = 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 2, GSM_READ_ADDR_PARITY_CHECK));\n\t \n\tregVal = pm8001_cr32(pm8001_ha, 2, GSM_WRITE_ADDR_PARITY_CHECK);\n\tpm8001_cw32(pm8001_ha, 2, GSM_WRITE_ADDR_PARITY_CHECK, regVal2);\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"GSM 0x700040 - Write Address Parity Check Enable is set to = 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 2, GSM_WRITE_ADDR_PARITY_CHECK));\n\t \n\tregVal = pm8001_cr32(pm8001_ha, 2, GSM_WRITE_DATA_PARITY_CHECK);\n\tpm8001_cw32(pm8001_ha, 2, GSM_WRITE_DATA_PARITY_CHECK, regVal3);\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"GSM 0x700048 - Write Data Parity Check Enable is set to = 0x%x\\n\",\n\t\t   pm8001_cr32(pm8001_ha, 2, GSM_WRITE_DATA_PARITY_CHECK));\n\n\t \n\t \n\tif (-1 == pm8001_bar4_shift(pm8001_ha, SPC_TOP_LEVEL_ADDR_BASE)) {\n\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"Shift Bar4 to 0x%x failed\\n\",\n\t\t\t   SPC_TOP_LEVEL_ADDR_BASE);\n\t\treturn -1;\n\t}\n\tregVal = pm8001_cr32(pm8001_ha, 2, SPC_REG_RESET);\n\tregVal |= (SPC_REG_RESET_PCS_IOP_SS | SPC_REG_RESET_PCS_AAP1_SS);\n\tpm8001_cw32(pm8001_ha, 2, SPC_REG_RESET, regVal);\n\n\t \n\tudelay(10);\n\t \n\tif (signature == SPC_SOFT_RESET_SIGNATURE) {\n\t\t \n\t\tmax_wait_count = 2 * 1000 * 1000; \n\t\tdo {\n\t\t\tudelay(1);\n\t\t\tregVal = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1) &\n\t\t\t\tSCRATCH_PAD1_RST;\n\t\t} while ((regVal != toggleVal) && (--max_wait_count));\n\n\t\tif (!max_wait_count) {\n\t\t\tregVal = pm8001_cr32(pm8001_ha, 0,\n\t\t\t\tMSGU_SCRATCH_PAD_1);\n\t\t\tpm8001_dbg(pm8001_ha, FAIL, \"TIMEOUT : ToggleVal 0x%x,MSGU_SCRATCH_PAD1 = 0x%x\\n\",\n\t\t\t\t   toggleVal, regVal);\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"SCRATCH_PAD0 value = 0x%x\\n\",\n\t\t\t\t   pm8001_cr32(pm8001_ha, 0,\n\t\t\t\t\t       MSGU_SCRATCH_PAD_0));\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"SCRATCH_PAD2 value = 0x%x\\n\",\n\t\t\t\t   pm8001_cr32(pm8001_ha, 0,\n\t\t\t\t\t       MSGU_SCRATCH_PAD_2));\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"SCRATCH_PAD3 value = 0x%x\\n\",\n\t\t\t\t   pm8001_cr32(pm8001_ha, 0,\n\t\t\t\t\t       MSGU_SCRATCH_PAD_3));\n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tpm8001_cw32(pm8001_ha, 0, MSGU_ODCR, ODCR_CLEAR_ALL);\n\t\tpm8001_cw32(pm8001_ha, 0, MSGU_ODMR, ODMR_CLEAR_ALL);\n\n\t\t \n\t\t \n\t\tif (check_fw_ready(pm8001_ha) == -1) {\n\t\t\tregVal = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_1);\n\t\t\t \n\t\t\tpm8001_dbg(pm8001_ha, INIT,\n\t\t\t\t   \"FW not ready SCRATCH_PAD1 = 0x%x\\n\",\n\t\t\t\t   regVal);\n\t\t\tregVal = pm8001_cr32(pm8001_ha, 0, MSGU_SCRATCH_PAD_2);\n\t\t\t \n\t\t\tpm8001_dbg(pm8001_ha, INIT,\n\t\t\t\t   \"FW not ready SCRATCH_PAD2 = 0x%x\\n\",\n\t\t\t\t   regVal);\n\t\t\tpm8001_dbg(pm8001_ha, INIT,\n\t\t\t\t   \"SCRATCH_PAD0 value = 0x%x\\n\",\n\t\t\t\t   pm8001_cr32(pm8001_ha, 0,\n\t\t\t\t\t       MSGU_SCRATCH_PAD_0));\n\t\t\tpm8001_dbg(pm8001_ha, INIT,\n\t\t\t\t   \"SCRATCH_PAD3 value = 0x%x\\n\",\n\t\t\t\t   pm8001_cr32(pm8001_ha, 0,\n\t\t\t\t\t       MSGU_SCRATCH_PAD_3));\n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tpm8001_bar4_shift(pm8001_ha, 0);\n\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\n\tpm8001_dbg(pm8001_ha, INIT, \"SPC soft reset Complete\\n\");\n\treturn 0;\n}\n\nstatic void pm8001_hw_chip_rst(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32 i;\n\tu32 regVal;\n\tpm8001_dbg(pm8001_ha, INIT, \"chip reset start\\n\");\n\n\t \n\tregVal = pm8001_cr32(pm8001_ha, 1, SPC_REG_RESET);\n\tregVal &= ~(SPC_REG_RESET_DEVICE);\n\tpm8001_cw32(pm8001_ha, 1, SPC_REG_RESET, regVal);\n\n\t \n\tudelay(10);\n\n\t \n\tregVal = pm8001_cr32(pm8001_ha, 1, SPC_REG_RESET);\n\tregVal |= SPC_REG_RESET_DEVICE;\n\tpm8001_cw32(pm8001_ha, 1, SPC_REG_RESET, regVal);\n\n\t \n\tudelay(10);\n\n\t \n\ti = 20;\n\tdo {\n\t\tmdelay(1);\n\t} while ((--i) != 0);\n\n\tpm8001_dbg(pm8001_ha, INIT, \"chip reset finished\\n\");\n}\n\n \nvoid pm8001_chip_iounmap(struct pm8001_hba_info *pm8001_ha)\n{\n\ts8 bar, logical = 0;\n\tfor (bar = 0; bar < PCI_STD_NUM_BARS; bar++) {\n\t\t \n\t\tif ((bar == 1) || (bar == 3))\n\t\t\tcontinue;\n\t\tif (pm8001_ha->io_mem[logical].memvirtaddr) {\n\t\t\tiounmap(pm8001_ha->io_mem[logical].memvirtaddr);\n\t\t\tlogical++;\n\t\t}\n\t}\n}\n\n#ifndef PM8001_USE_MSIX\n \nstatic void\npm8001_chip_intx_interrupt_enable(struct pm8001_hba_info *pm8001_ha)\n{\n\tpm8001_cw32(pm8001_ha, 0, MSGU_ODMR, ODMR_CLEAR_ALL);\n\tpm8001_cw32(pm8001_ha, 0, MSGU_ODCR, ODCR_CLEAR_ALL);\n}\n\n \nstatic void\npm8001_chip_intx_interrupt_disable(struct pm8001_hba_info *pm8001_ha)\n{\n\tpm8001_cw32(pm8001_ha, 0, MSGU_ODMR, ODMR_MASK_ALL);\n}\n\n#else\n\n \nstatic void\npm8001_chip_msix_interrupt_enable(struct pm8001_hba_info *pm8001_ha,\n\tu32 int_vec_idx)\n{\n\tu32 msi_index;\n\tu32 value;\n\tmsi_index = int_vec_idx * MSIX_TABLE_ELEMENT_SIZE;\n\tmsi_index += MSIX_TABLE_BASE;\n\tpm8001_cw32(pm8001_ha, 0, msi_index, MSIX_INTERRUPT_ENABLE);\n\tvalue = (1 << int_vec_idx);\n\tpm8001_cw32(pm8001_ha, 0,  MSGU_ODCR, value);\n\n}\n\n \nstatic void\npm8001_chip_msix_interrupt_disable(struct pm8001_hba_info *pm8001_ha,\n\tu32 int_vec_idx)\n{\n\tu32 msi_index;\n\tmsi_index = int_vec_idx * MSIX_TABLE_ELEMENT_SIZE;\n\tmsi_index += MSIX_TABLE_BASE;\n\tpm8001_cw32(pm8001_ha, 0,  msi_index, MSIX_INTERRUPT_DISABLE);\n}\n#endif\n\n \nstatic void\npm8001_chip_interrupt_enable(struct pm8001_hba_info *pm8001_ha, u8 vec)\n{\n#ifdef PM8001_USE_MSIX\n\tpm8001_chip_msix_interrupt_enable(pm8001_ha, 0);\n#else\n\tpm8001_chip_intx_interrupt_enable(pm8001_ha);\n#endif\n}\n\n \nstatic void\npm8001_chip_interrupt_disable(struct pm8001_hba_info *pm8001_ha, u8 vec)\n{\n#ifdef PM8001_USE_MSIX\n\tpm8001_chip_msix_interrupt_disable(pm8001_ha, 0);\n#else\n\tpm8001_chip_intx_interrupt_disable(pm8001_ha);\n#endif\n}\n\n \nint pm8001_mpi_msg_free_get(struct inbound_queue_table *circularQ,\n\t\t\t    u16 messageSize, void **messagePtr)\n{\n\tu32 offset, consumer_index;\n\tstruct mpi_msg_hdr *msgHeader;\n\tu8 bcCount = 1;  \n\n\t \n\tif (messageSize > IOMB_SIZE_SPCV) {\n\t\t*messagePtr = NULL;\n\t\treturn -1;\n\t}\n\n\t \n\tconsumer_index = pm8001_read_32(circularQ->ci_virt);\n\tcircularQ->consumer_index = cpu_to_le32(consumer_index);\n\tif (((circularQ->producer_idx + bcCount) % PM8001_MPI_QUEUE) ==\n\t\tle32_to_cpu(circularQ->consumer_index)) {\n\t\t*messagePtr = NULL;\n\t\treturn -1;\n\t}\n\t \n\toffset = circularQ->producer_idx * messageSize;\n\t \n\tcircularQ->producer_idx = (circularQ->producer_idx + bcCount)\n\t\t\t\t% PM8001_MPI_QUEUE;\n\t \n\tmsgHeader = (struct mpi_msg_hdr *)(circularQ->base_virt\t+ offset);\n\t*messagePtr = ((void *)msgHeader) + sizeof(struct mpi_msg_hdr);\n\treturn 0;\n}\n\n \nint pm8001_mpi_build_cmd(struct pm8001_hba_info *pm8001_ha,\n\t\t\t u32 q_index, u32 opCode, void *payload, size_t nb,\n\t\t\t u32 responseQueue)\n{\n\tu32 Header = 0, hpriority = 0, bc = 1, category = 0x02;\n\tvoid *pMessage;\n\tunsigned long flags;\n\tstruct inbound_queue_table *circularQ = &pm8001_ha->inbnd_q_tbl[q_index];\n\tint rv;\n\tu32 htag = le32_to_cpu(*(__le32 *)payload);\n\n\ttrace_pm80xx_mpi_build_cmd(pm8001_ha->id, opCode, htag, q_index,\n\t\tcircularQ->producer_idx, le32_to_cpu(circularQ->consumer_index));\n\n\tif (WARN_ON(q_index >= pm8001_ha->max_q_num))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&circularQ->iq_lock, flags);\n\trv = pm8001_mpi_msg_free_get(circularQ, pm8001_ha->iomb_size,\n\t\t\t&pMessage);\n\tif (rv < 0) {\n\t\tpm8001_dbg(pm8001_ha, IO, \"No free mpi buffer\\n\");\n\t\trv = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tif (nb > (pm8001_ha->iomb_size - sizeof(struct mpi_msg_hdr)))\n\t\tnb = pm8001_ha->iomb_size - sizeof(struct mpi_msg_hdr);\n\tmemcpy(pMessage, payload, nb);\n\tif (nb + sizeof(struct mpi_msg_hdr) < pm8001_ha->iomb_size)\n\t\tmemset(pMessage + nb, 0, pm8001_ha->iomb_size -\n\t\t\t\t(nb + sizeof(struct mpi_msg_hdr)));\n\n\t \n\tHeader = ((1 << 31) | (hpriority << 30) | ((bc & 0x1f) << 24)\n\t\t| ((responseQueue & 0x3F) << 16)\n\t\t| ((category & 0xF) << 12) | (opCode & 0xFFF));\n\n\tpm8001_write_32((pMessage - 4), 0, cpu_to_le32(Header));\n\t \n\tpm8001_cw32(pm8001_ha, circularQ->pi_pci_bar,\n\t\tcircularQ->pi_offset, circularQ->producer_idx);\n\tpm8001_dbg(pm8001_ha, DEVIO,\n\t\t   \"INB Q %x OPCODE:%x , UPDATED PI=%d CI=%d\\n\",\n\t\t   responseQueue, opCode, circularQ->producer_idx,\n\t\t   circularQ->consumer_index);\ndone:\n\tspin_unlock_irqrestore(&circularQ->iq_lock, flags);\n\treturn rv;\n}\n\nu32 pm8001_mpi_msg_free_set(struct pm8001_hba_info *pm8001_ha, void *pMsg,\n\t\t\t    struct outbound_queue_table *circularQ, u8 bc)\n{\n\tu32 producer_index;\n\tstruct mpi_msg_hdr *msgHeader;\n\tstruct mpi_msg_hdr *pOutBoundMsgHeader;\n\n\tmsgHeader = (struct mpi_msg_hdr *)(pMsg - sizeof(struct mpi_msg_hdr));\n\tpOutBoundMsgHeader = (struct mpi_msg_hdr *)(circularQ->base_virt +\n\t\t\t\tcircularQ->consumer_idx * pm8001_ha->iomb_size);\n\tif (pOutBoundMsgHeader != msgHeader) {\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"consumer_idx = %d msgHeader = %p\\n\",\n\t\t\t   circularQ->consumer_idx, msgHeader);\n\n\t\t \n\t\tproducer_index = pm8001_read_32(circularQ->pi_virt);\n\t\tcircularQ->producer_index = cpu_to_le32(producer_index);\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"consumer_idx = %d producer_index = %dmsgHeader = %p\\n\",\n\t\t\t   circularQ->consumer_idx,\n\t\t\t   circularQ->producer_index, msgHeader);\n\t\treturn 0;\n\t}\n\t \n\tcircularQ->consumer_idx = (circularQ->consumer_idx + bc)\n\t\t\t\t% PM8001_MPI_QUEUE;\n\t \n\tpm8001_cw32(pm8001_ha, circularQ->ci_pci_bar, circularQ->ci_offset,\n\t\tcircularQ->consumer_idx);\n\t \n\tproducer_index = pm8001_read_32(circularQ->pi_virt);\n\tcircularQ->producer_index = cpu_to_le32(producer_index);\n\tpm8001_dbg(pm8001_ha, IO, \" CI=%d PI=%d\\n\",\n\t\t   circularQ->consumer_idx, circularQ->producer_index);\n\treturn 0;\n}\n\n \nu32 pm8001_mpi_msg_consume(struct pm8001_hba_info *pm8001_ha,\n\t\t\t   struct outbound_queue_table *circularQ,\n\t\t\t   void **messagePtr1, u8 *pBC)\n{\n\tstruct mpi_msg_hdr\t*msgHeader;\n\t__le32\tmsgHeader_tmp;\n\tu32 header_tmp;\n\tdo {\n\t\t \n\t\tif (le32_to_cpu(circularQ->producer_index)\n\t\t\t!= circularQ->consumer_idx) {\n\t\t\t \n\t\t\tmsgHeader = (struct mpi_msg_hdr *)\n\t\t\t\t(circularQ->base_virt +\n\t\t\t\tcircularQ->consumer_idx * pm8001_ha->iomb_size);\n\t\t\t \n\t\t\theader_tmp = pm8001_read_32(msgHeader);\n\t\t\tmsgHeader_tmp = cpu_to_le32(header_tmp);\n\t\t\tpm8001_dbg(pm8001_ha, DEVIO,\n\t\t\t\t   \"outbound opcode msgheader:%x ci=%d pi=%d\\n\",\n\t\t\t\t   msgHeader_tmp, circularQ->consumer_idx,\n\t\t\t\t   circularQ->producer_index);\n\t\t\tif (0 != (le32_to_cpu(msgHeader_tmp) & 0x80000000)) {\n\t\t\t\tif (OPC_OUB_SKIP_ENTRY !=\n\t\t\t\t\t(le32_to_cpu(msgHeader_tmp) & 0xfff)) {\n\t\t\t\t\t*messagePtr1 =\n\t\t\t\t\t\t((u8 *)msgHeader) +\n\t\t\t\t\t\tsizeof(struct mpi_msg_hdr);\n\t\t\t\t\t*pBC = (u8)((le32_to_cpu(msgHeader_tmp)\n\t\t\t\t\t\t>> 24) & 0x1f);\n\t\t\t\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t\t\t\t   \": CI=%d PI=%d msgHeader=%x\\n\",\n\t\t\t\t\t\t   circularQ->consumer_idx,\n\t\t\t\t\t\t   circularQ->producer_index,\n\t\t\t\t\t\t   msgHeader_tmp);\n\t\t\t\t\treturn MPI_IO_STATUS_SUCCESS;\n\t\t\t\t} else {\n\t\t\t\t\tcircularQ->consumer_idx =\n\t\t\t\t\t\t(circularQ->consumer_idx +\n\t\t\t\t\t\t((le32_to_cpu(msgHeader_tmp)\n\t\t\t\t\t\t >> 24) & 0x1f))\n\t\t\t\t\t\t\t% PM8001_MPI_QUEUE;\n\t\t\t\t\tmsgHeader_tmp = 0;\n\t\t\t\t\tpm8001_write_32(msgHeader, 0, 0);\n\t\t\t\t\t \n\t\t\t\t\tpm8001_cw32(pm8001_ha,\n\t\t\t\t\t\tcircularQ->ci_pci_bar,\n\t\t\t\t\t\tcircularQ->ci_offset,\n\t\t\t\t\t\tcircularQ->consumer_idx);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcircularQ->consumer_idx =\n\t\t\t\t\t(circularQ->consumer_idx +\n\t\t\t\t\t((le32_to_cpu(msgHeader_tmp) >> 24) &\n\t\t\t\t\t0x1f)) % PM8001_MPI_QUEUE;\n\t\t\t\tmsgHeader_tmp = 0;\n\t\t\t\tpm8001_write_32(msgHeader, 0, 0);\n\t\t\t\t \n\t\t\t\tpm8001_cw32(pm8001_ha, circularQ->ci_pci_bar,\n\t\t\t\t\tcircularQ->ci_offset,\n\t\t\t\t\tcircularQ->consumer_idx);\n\t\t\t\treturn MPI_IO_STATUS_FAIL;\n\t\t\t}\n\t\t} else {\n\t\t\tu32 producer_index;\n\t\t\tvoid *pi_virt = circularQ->pi_virt;\n\t\t\t \n\t\t\tif (!pi_virt)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tproducer_index = pm8001_read_32(pi_virt);\n\t\t\tcircularQ->producer_index = cpu_to_le32(producer_index);\n\t\t}\n\t} while (le32_to_cpu(circularQ->producer_index) !=\n\t\tcircularQ->consumer_idx);\n\t \n\t \n\treturn MPI_IO_STATUS_BUSY;\n}\n\nvoid pm8001_work_fn(struct work_struct *work)\n{\n\tstruct pm8001_work *pw = container_of(work, struct pm8001_work, work);\n\tstruct pm8001_device *pm8001_dev;\n\tstruct domain_device *dev;\n\n\t \n\tif (pw->handler != IO_FATAL_ERROR) {\n\t\tpm8001_dev = pw->data;  \n\t\tif ((pm8001_dev == NULL)\n\t\t || ((pw->handler != IO_XFER_ERROR_BREAK)\n\t\t\t && (pm8001_dev->dev_type == SAS_PHY_UNUSED))) {\n\t\t\tkfree(pw);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tswitch (pw->handler) {\n\tcase IO_XFER_ERROR_BREAK:\n\t{\t \n\t\tstruct sas_task *t = (struct sas_task *)pm8001_dev;\n\t\tstruct pm8001_ccb_info *ccb;\n\t\tstruct pm8001_hba_info *pm8001_ha = pw->pm8001_ha;\n\t\tunsigned long flags, flags1;\n\t\tstruct task_status_struct *ts;\n\t\tint i;\n\n\t\tif (pm8001_query_task(t) == TMF_RESP_FUNC_SUCC)\n\t\t\tbreak;  \n\t\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\n\t\tspin_lock_irqsave(&t->task_state_lock, flags1);\n\t\tif (unlikely((t->task_state_flags & SAS_TASK_STATE_DONE))) {\n\t\t\tspin_unlock_irqrestore(&t->task_state_lock, flags1);\n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\tbreak;  \n\t\t}\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags1);\n\n\t\t \n\t\tfor (i = 0; ccb = NULL, i < PM8001_MAX_CCB; i++) {\n\t\t\tccb = &pm8001_ha->ccb_info[i];\n\t\t\tif ((ccb->ccb_tag != PM8001_INVALID_TAG) &&\n\t\t\t    (ccb->task == t))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!ccb) {\n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\tbreak;  \n\t\t}\n\t\tts = &t->task_status;\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\t \n\t\tts->stat = SAS_QUEUE_FULL;\n\t\tpm8001_dev = ccb->device;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tspin_lock_irqsave(&t->task_state_lock, flags1);\n\t\tt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\t\tt->task_state_flags |= SAS_TASK_STATE_DONE;\n\t\tif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\n\t\t\tspin_unlock_irqrestore(&t->task_state_lock, flags1);\n\t\t\tpm8001_dbg(pm8001_ha, FAIL, \"task 0x%p done with event 0x%x resp 0x%x stat 0x%x but aborted by upper layer!\\n\",\n\t\t\t\t   t, pw->handler, ts->resp, ts->stat);\n\t\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&t->task_state_lock, flags1);\n\t\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t\t\tmb(); \n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\tt->task_done(t);\n\t\t}\n\t}\tbreak;\n\tcase IO_XFER_OPEN_RETRY_TIMEOUT:\n\t{\t \n\t\tstruct sas_task *t = (struct sas_task *)pm8001_dev;\n\t\tstruct pm8001_ccb_info *ccb;\n\t\tstruct pm8001_hba_info *pm8001_ha = pw->pm8001_ha;\n\t\tunsigned long flags, flags1;\n\t\tint i, ret = 0;\n\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_OPEN_RETRY_TIMEOUT\\n\");\n\n\t\tret = pm8001_query_task(t);\n\n\t\tif (ret == TMF_RESP_FUNC_SUCC)\n\t\t\tpm8001_dbg(pm8001_ha, IO, \"...Task on lu\\n\");\n\t\telse if (ret == TMF_RESP_FUNC_COMPLETE)\n\t\t\tpm8001_dbg(pm8001_ha, IO, \"...Task NOT on lu\\n\");\n\t\telse\n\t\t\tpm8001_dbg(pm8001_ha, DEVIO, \"...query task failed!!!\\n\");\n\n\t\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\n\t\tspin_lock_irqsave(&t->task_state_lock, flags1);\n\n\t\tif (unlikely((t->task_state_flags & SAS_TASK_STATE_DONE))) {\n\t\t\tspin_unlock_irqrestore(&t->task_state_lock, flags1);\n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\tif (ret == TMF_RESP_FUNC_SUCC)  \n\t\t\t\t(void)pm8001_abort_task(t);\n\t\t\tbreak;  \n\t\t}\n\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags1);\n\n\t\t \n\t\tfor (i = 0; ccb = NULL, i < PM8001_MAX_CCB; i++) {\n\t\t\tccb = &pm8001_ha->ccb_info[i];\n\t\t\tif ((ccb->ccb_tag != PM8001_INVALID_TAG) &&\n\t\t\t    (ccb->task == t))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!ccb) {\n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\tif (ret == TMF_RESP_FUNC_SUCC)  \n\t\t\t\t(void)pm8001_abort_task(t);\n\t\t\tbreak;  \n\t\t}\n\n\t\tpm8001_dev = ccb->device;\n\t\tdev = pm8001_dev->sas_device;\n\n\t\tswitch (ret) {\n\t\tcase TMF_RESP_FUNC_SUCC:  \n\t\t\tccb->open_retry = 1;  \n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\tret = pm8001_abort_task(t);\n\t\t\tccb->open_retry = 0;\n\t\t\tswitch (ret) {\n\t\t\tcase TMF_RESP_FUNC_SUCC:\n\t\t\tcase TMF_RESP_FUNC_COMPLETE:\n\t\t\t\tbreak;\n\t\t\tdefault:  \n\t\t\t\tret = TMF_RESP_FUNC_FAILED;\n\t\t\t\tpm8001_dbg(pm8001_ha, IO, \"...Reset phy\\n\");\n\t\t\t\tpm8001_I_T_nexus_reset(dev);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TMF_RESP_FUNC_COMPLETE:  \n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:  \n\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\tret = TMF_RESP_FUNC_FAILED;\n\t\t\tpm8001_dbg(pm8001_ha, IO, \"...Reset phy\\n\");\n\t\t\tpm8001_I_T_nexus_reset(dev);\n\t\t}\n\n\t\tif (ret == TMF_RESP_FUNC_FAILED)\n\t\t\tt = NULL;\n\t\tpm8001_open_reject_retry(pm8001_ha, t, pm8001_dev);\n\t\tpm8001_dbg(pm8001_ha, IO, \"...Complete\\n\");\n\t}\tbreak;\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\n\t\tdev = pm8001_dev->sas_device;\n\t\tpm8001_I_T_nexus_event_handler(dev);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_STP_RESOURCES_BUSY:\n\t\tdev = pm8001_dev->sas_device;\n\t\tpm8001_I_T_nexus_reset(dev);\n\t\tbreak;\n\tcase IO_DS_IN_ERROR:\n\t\tdev = pm8001_dev->sas_device;\n\t\tpm8001_I_T_nexus_reset(dev);\n\t\tbreak;\n\tcase IO_DS_NON_OPERATIONAL:\n\t\tdev = pm8001_dev->sas_device;\n\t\tpm8001_I_T_nexus_reset(dev);\n\t\tbreak;\n\tcase IO_FATAL_ERROR:\n\t{\n\t\tstruct pm8001_hba_info *pm8001_ha = pw->pm8001_ha;\n\t\tstruct pm8001_ccb_info *ccb;\n\t\tstruct task_status_struct *ts;\n\t\tstruct sas_task *task;\n\t\tint i;\n\t\tu32 device_id;\n\n\t\tfor (i = 0; ccb = NULL, i < PM8001_MAX_CCB; i++) {\n\t\t\tccb = &pm8001_ha->ccb_info[i];\n\t\t\ttask = ccb->task;\n\t\t\tts = &task->task_status;\n\n\t\t\tif (task != NULL) {\n\t\t\t\tdev = task->dev;\n\t\t\t\tif (!dev) {\n\t\t\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t\t\t\"dev is NULL\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t\t\t\tts->resp = SAS_TASK_COMPLETE;\n\t\t\t\ttask->task_done(task);\n\t\t\t} else if (ccb->ccb_tag != PM8001_INVALID_TAG) {\n\t\t\t\t \n\t\t\t\tpm8001_dev = ccb->device;\n\t\t\t\tif (pm8001_dev->dcompletion) {\n\t\t\t\t\tcomplete(pm8001_dev->dcompletion);\n\t\t\t\t\tpm8001_dev->dcompletion = NULL;\n\t\t\t\t}\n\t\t\t\tcomplete(pm8001_ha->nvmd_completion);\n\t\t\t\tpm8001_ccb_free(pm8001_ha, ccb);\n\t\t\t}\n\t\t}\n\t\t \n\t\tfor (i = 0; i < PM8001_MAX_DEVICES; i++) {\n\t\t\tpm8001_dev = &pm8001_ha->devices[i];\n\t\t\tdevice_id = pm8001_dev->device_id;\n\t\t\tif (device_id) {\n\t\t\t\tPM8001_CHIP_DISP->dereg_dev_req(pm8001_ha, device_id);\n\t\t\t\tpm8001_free_dev(pm8001_dev);\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase IO_XFER_ERROR_ABORTED_NCQ_MODE:\n\t{\n\t\tdev = pm8001_dev->sas_device;\n\t\tsas_ata_device_link_abort(dev, false);\n\t}\n\tbreak;\n\t}\n\tkfree(pw);\n}\n\nint pm8001_handle_event(struct pm8001_hba_info *pm8001_ha, void *data,\n\t\t\t       int handler)\n{\n\tstruct pm8001_work *pw;\n\tint ret = 0;\n\n\tpw = kmalloc(sizeof(struct pm8001_work), GFP_ATOMIC);\n\tif (pw) {\n\t\tpw->pm8001_ha = pm8001_ha;\n\t\tpw->data = data;\n\t\tpw->handler = handler;\n\t\tINIT_WORK(&pw->work, pm8001_work_fn);\n\t\tqueue_work(pm8001_wq, &pw->work);\n\t} else\n\t\tret = -ENOMEM;\n\n\treturn ret;\n}\n\n \nstatic void\nmpi_ssp_completion(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct sas_task *t;\n\tstruct pm8001_ccb_info *ccb;\n\tunsigned long flags;\n\tu32 status;\n\tu32 param;\n\tu32 tag;\n\tstruct ssp_completion_resp *psspPayload;\n\tstruct task_status_struct *ts;\n\tstruct ssp_response_iu *iu;\n\tstruct pm8001_device *pm8001_dev;\n\tpsspPayload = (struct ssp_completion_resp *)(piomb + 4);\n\tstatus = le32_to_cpu(psspPayload->status);\n\ttag = le32_to_cpu(psspPayload->tag);\n\tccb = &pm8001_ha->ccb_info[tag];\n\tif ((status == IO_ABORTED) && ccb->open_retry) {\n\t\t \n\t\tccb->open_retry = 0;\n\t\treturn;\n\t}\n\tpm8001_dev = ccb->device;\n\tparam = le32_to_cpu(psspPayload->param);\n\n\tt = ccb->task;\n\n\tif (status && status != IO_UNDERFLOW)\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"sas IO status 0x%x\\n\", status);\n\tif (unlikely(!t || !t->lldd_task || !t->dev))\n\t\treturn;\n\tts = &t->task_status;\n\t \n\tif ((status != IO_SUCCESS) && (status != IO_OVERFLOW) &&\n\t\t(status != IO_UNDERFLOW))\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"SAS Address of IO Failure Drive:%016llx\\n\",\n\t\t\t   SAS_ADDR(t->dev->sas_addr));\n\n\tif (status)\n\t\tpm8001_dbg(pm8001_ha, IOERR,\n\t\t\t   \"status:0x%x, tag:0x%x, task:0x%p\\n\",\n\t\t\t   status, tag, t);\n\n\tswitch (status) {\n\tcase IO_SUCCESS:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_SUCCESS,param = %d\\n\",\n\t\t\t   param);\n\t\tif (param == 0) {\n\t\t\tts->resp = SAS_TASK_COMPLETE;\n\t\t\tts->stat = SAS_SAM_STAT_GOOD;\n\t\t} else {\n\t\t\tts->resp = SAS_TASK_COMPLETE;\n\t\t\tts->stat = SAS_PROTO_RESPONSE;\n\t\t\tts->residual = param;\n\t\t\tiu = &psspPayload->ssp_resp_iu;\n\t\t\tsas_ssp_task_response(pm8001_ha->dev, t, iu);\n\t\t}\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_ABORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_ABORTED IOMB Tag\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_ABORTED_TASK;\n\t\tbreak;\n\tcase IO_UNDERFLOW:\n\t\t \n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_UNDERFLOW,param = %d\\n\",\n\t\t\t   param);\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_UNDERRUN;\n\t\tts->residual = param;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_NO_DEVICE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_NO_DEVICE\\n\");\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_PHY_DOWN;\n\t\tbreak;\n\tcase IO_XFER_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\t \n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_XFER_ERROR_PHY_NOT_READY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_PHY_NOT_READY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_EPROTO;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_ZONE_VIOLATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tif (!t->uldd_task)\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_BAD_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_BAD_DEST;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_CONN_RATE;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_WRONG_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_WRONG_DEST;\n\t\tbreak;\n\tcase IO_XFER_ERROR_NAK_RECEIVED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_NAK_RECEIVED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_XFER_ERROR_ACK_NAK_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_ACK_NAK_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_NAK_R_ERR;\n\t\tbreak;\n\tcase IO_XFER_ERROR_DMA:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_DMA\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tbreak;\n\tcase IO_XFER_OPEN_RETRY_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_OPEN_RETRY_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_XFER_ERROR_OFFSET_MISMATCH:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_OFFSET_MISMATCH\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tbreak;\n\tcase IO_PORT_IN_RESET:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_PORT_IN_RESET\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tbreak;\n\tcase IO_DS_NON_OPERATIONAL:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_DS_NON_OPERATIONAL\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tif (!t->uldd_task)\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_DS_NON_OPERATIONAL);\n\t\tbreak;\n\tcase IO_DS_IN_RECOVERY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_DS_IN_RECOVERY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tbreak;\n\tcase IO_TM_TAG_NOT_FOUND:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_TM_TAG_NOT_FOUND\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tbreak;\n\tcase IO_SSP_EXT_IU_ZERO_LEN_ERROR:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_SSP_EXT_IU_ZERO_LEN_ERROR\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO, \"Unknown status 0x%x\\n\", status);\n\t\t \n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tbreak;\n\t}\n\tpm8001_dbg(pm8001_ha, IO, \"scsi_status = %x\\n\",\n\t\t   psspPayload->ssp_resp_iu.status);\n\tspin_lock_irqsave(&t->task_state_lock, flags);\n\tt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\tt->task_state_flags |= SAS_TASK_STATE_DONE;\n\tif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"task 0x%p done with io_status 0x%x resp 0x%x stat 0x%x but aborted by upper layer!\\n\",\n\t\t\t   t, status, ts->resp, ts->stat);\n\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t} else {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t\tmb(); \n\t\tt->task_done(t);\n\t}\n}\n\n \nstatic void mpi_ssp_event(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct sas_task *t;\n\tunsigned long flags;\n\tstruct task_status_struct *ts;\n\tstruct pm8001_ccb_info *ccb;\n\tstruct pm8001_device *pm8001_dev;\n\tstruct ssp_event_resp *psspPayload =\n\t\t(struct ssp_event_resp *)(piomb + 4);\n\tu32 event = le32_to_cpu(psspPayload->event);\n\tu32 tag = le32_to_cpu(psspPayload->tag);\n\tu32 port_id = le32_to_cpu(psspPayload->port_id);\n\tu32 dev_id = le32_to_cpu(psspPayload->device_id);\n\n\tccb = &pm8001_ha->ccb_info[tag];\n\tt = ccb->task;\n\tpm8001_dev = ccb->device;\n\tif (event)\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"sas IO status 0x%x\\n\", event);\n\tif (unlikely(!t || !t->lldd_task || !t->dev))\n\t\treturn;\n\tts = &t->task_status;\n\tpm8001_dbg(pm8001_ha, DEVIO, \"port_id = %x,device_id = %x\\n\",\n\t\t   port_id, dev_id);\n\tswitch (event) {\n\tcase IO_OVERFLOW:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_UNDERFLOW\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tts->residual = 0;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_BREAK\\n\");\n\t\tpm8001_handle_event(pm8001_ha, t, IO_XFER_ERROR_BREAK);\n\t\treturn;\n\tcase IO_XFER_ERROR_PHY_NOT_READY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_PHY_NOT_READY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_EPROTO;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_ZONE_VIOLATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tif (!t->uldd_task)\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_BAD_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_BAD_DEST;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_CONN_RATE;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_WRONG_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_WRONG_DEST;\n\t\tbreak;\n\tcase IO_XFER_ERROR_NAK_RECEIVED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_NAK_RECEIVED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_XFER_ERROR_ACK_NAK_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_ACK_NAK_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_NAK_R_ERR;\n\t\tbreak;\n\tcase IO_XFER_OPEN_RETRY_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_OPEN_RETRY_TIMEOUT\\n\");\n\t\tpm8001_handle_event(pm8001_ha, t, IO_XFER_OPEN_RETRY_TIMEOUT);\n\t\treturn;\n\tcase IO_XFER_ERROR_UNEXPECTED_PHASE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_UNEXPECTED_PHASE\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tbreak;\n\tcase IO_XFER_ERROR_XFER_RDY_OVERRUN:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_XFER_RDY_OVERRUN\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tbreak;\n\tcase IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tbreak;\n\tcase IO_XFER_ERROR_CMD_ISSUE_ACK_NAK_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_XFER_ERROR_CMD_ISSUE_ACK_NAK_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tbreak;\n\tcase IO_XFER_ERROR_OFFSET_MISMATCH:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_OFFSET_MISMATCH\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tbreak;\n\tcase IO_XFER_ERROR_XFER_ZERO_DATA_LEN:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_XFER_ERROR_XFER_ZERO_DATA_LEN\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tbreak;\n\tcase IO_XFER_CMD_FRAME_ISSUED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_CMD_FRAME_ISSUED\\n\");\n\t\treturn;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO, \"Unknown status 0x%x\\n\", event);\n\t\t \n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tbreak;\n\t}\n\tspin_lock_irqsave(&t->task_state_lock, flags);\n\tt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\tt->task_state_flags |= SAS_TASK_STATE_DONE;\n\tif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"task 0x%p done with event 0x%x resp 0x%x stat 0x%x but aborted by upper layer!\\n\",\n\t\t\t   t, event, ts->resp, ts->stat);\n\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t} else {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t\tmb(); \n\t\tt->task_done(t);\n\t}\n}\n\n \nstatic void\nmpi_sata_completion(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct sas_task *t;\n\tstruct pm8001_ccb_info *ccb;\n\tu32 param;\n\tu32 status;\n\tu32 tag;\n\tint i, j;\n\tu8 sata_addr_low[4];\n\tu32 temp_sata_addr_low;\n\tu8 sata_addr_hi[4];\n\tu32 temp_sata_addr_hi;\n\tstruct sata_completion_resp *psataPayload;\n\tstruct task_status_struct *ts;\n\tstruct ata_task_resp *resp ;\n\tu32 *sata_resp;\n\tstruct pm8001_device *pm8001_dev;\n\tunsigned long flags;\n\n\tpsataPayload = (struct sata_completion_resp *)(piomb + 4);\n\tstatus = le32_to_cpu(psataPayload->status);\n\tparam = le32_to_cpu(psataPayload->param);\n\ttag = le32_to_cpu(psataPayload->tag);\n\n\tccb = &pm8001_ha->ccb_info[tag];\n\tt = ccb->task;\n\tpm8001_dev = ccb->device;\n\n\tif (t) {\n\t\tif (t->dev && (t->dev->lldd_dev))\n\t\t\tpm8001_dev = t->dev->lldd_dev;\n\t} else {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"task null, freeing CCB tag %d\\n\",\n\t\t\t   ccb->ccb_tag);\n\t\tpm8001_ccb_free(pm8001_ha, ccb);\n\t\treturn;\n\t}\n\n\tif (pm8001_dev && unlikely(!t || !t->lldd_task || !t->dev)) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"task or dev null\\n\");\n\t\treturn;\n\t}\n\n\tts = &t->task_status;\n\n\tif (status)\n\t\tpm8001_dbg(pm8001_ha, IOERR,\n\t\t\t   \"status:0x%x, tag:0x%x, task::0x%p\\n\",\n\t\t\t   status, tag, t);\n\n\t \n\tif ((status != IO_SUCCESS) && (status != IO_OVERFLOW) &&\n\t\t(status != IO_UNDERFLOW)) {\n\t\tif (!((t->dev->parent) &&\n\t\t\t(dev_is_expander(t->dev->parent->dev_type)))) {\n\t\t\tfor (i = 0, j = 4; j <= 7 && i <= 3; i++, j++)\n\t\t\t\tsata_addr_low[i] = pm8001_ha->sas_addr[j];\n\t\t\tfor (i = 0, j = 0; j <= 3 && i <= 3; i++, j++)\n\t\t\t\tsata_addr_hi[i] = pm8001_ha->sas_addr[j];\n\t\t\tmemcpy(&temp_sata_addr_low, sata_addr_low,\n\t\t\t\tsizeof(sata_addr_low));\n\t\t\tmemcpy(&temp_sata_addr_hi, sata_addr_hi,\n\t\t\t\tsizeof(sata_addr_hi));\n\t\t\ttemp_sata_addr_hi = (((temp_sata_addr_hi >> 24) & 0xff)\n\t\t\t\t\t\t|((temp_sata_addr_hi << 8) &\n\t\t\t\t\t\t0xff0000) |\n\t\t\t\t\t\t((temp_sata_addr_hi >> 8)\n\t\t\t\t\t\t& 0xff00) |\n\t\t\t\t\t\t((temp_sata_addr_hi << 24) &\n\t\t\t\t\t\t0xff000000));\n\t\t\ttemp_sata_addr_low = ((((temp_sata_addr_low >> 24)\n\t\t\t\t\t\t& 0xff) |\n\t\t\t\t\t\t((temp_sata_addr_low << 8)\n\t\t\t\t\t\t& 0xff0000) |\n\t\t\t\t\t\t((temp_sata_addr_low >> 8)\n\t\t\t\t\t\t& 0xff00) |\n\t\t\t\t\t\t((temp_sata_addr_low << 24)\n\t\t\t\t\t\t& 0xff000000)) +\n\t\t\t\t\t\tpm8001_dev->attached_phy +\n\t\t\t\t\t\t0x10);\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"SAS Address of IO Failure Drive:%08x%08x\\n\",\n\t\t\t\t   temp_sata_addr_hi,\n\t\t\t\t   temp_sata_addr_low);\n\t\t} else {\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"SAS Address of IO Failure Drive:%016llx\\n\",\n\t\t\t\t   SAS_ADDR(t->dev->sas_addr));\n\t\t}\n\t}\n\tswitch (status) {\n\tcase IO_SUCCESS:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_SUCCESS\\n\");\n\t\tif (param == 0) {\n\t\t\tts->resp = SAS_TASK_COMPLETE;\n\t\t\tts->stat = SAS_SAM_STAT_GOOD;\n\t\t} else {\n\t\t\tu8 len;\n\t\t\tts->resp = SAS_TASK_COMPLETE;\n\t\t\tts->stat = SAS_PROTO_RESPONSE;\n\t\t\tts->residual = param;\n\t\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t\t   \"SAS_PROTO_RESPONSE len = %d\\n\",\n\t\t\t\t   param);\n\t\t\tsata_resp = &psataPayload->sata_resp[0];\n\t\t\tresp = (struct ata_task_resp *)ts->buf;\n\t\t\tif (t->ata_task.dma_xfer == 0 &&\n\t\t\t    t->data_dir == DMA_FROM_DEVICE) {\n\t\t\t\tlen = sizeof(struct pio_setup_fis);\n\t\t\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t\t\t   \"PIO read len = %d\\n\", len);\n\t\t\t} else if (t->ata_task.use_ncq &&\n\t\t\t\t   t->data_dir != DMA_NONE) {\n\t\t\t\tlen = sizeof(struct set_dev_bits_fis);\n\t\t\t\tpm8001_dbg(pm8001_ha, IO, \"FPDMA len = %d\\n\",\n\t\t\t\t\t   len);\n\t\t\t} else {\n\t\t\t\tlen = sizeof(struct dev_to_host_fis);\n\t\t\t\tpm8001_dbg(pm8001_ha, IO, \"other len = %d\\n\",\n\t\t\t\t\t   len);\n\t\t\t}\n\t\t\tif (SAS_STATUS_BUF_SIZE >= sizeof(*resp)) {\n\t\t\t\tresp->frame_len = len;\n\t\t\t\tmemcpy(&resp->ending_fis[0], sata_resp, len);\n\t\t\t\tts->buf_valid_size = sizeof(*resp);\n\t\t\t} else\n\t\t\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t\t\t   \"response too large\\n\");\n\t\t}\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_ABORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_ABORTED IOMB Tag\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_ABORTED_TASK;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\t\t \n\tcase IO_UNDERFLOW:\n\t\t \n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_UNDERFLOW param = %d\\n\", param);\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_UNDERRUN;\n\t\tts->residual =  param;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_NO_DEVICE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_NO_DEVICE\\n\");\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_PHY_DOWN;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_INTERRUPTED;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_PHY_NOT_READY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_PHY_NOT_READY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_EPROTO;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_ZONE_VIOLATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_CONT0;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (!t->uldd_task) {\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\n\t\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\t\tts->stat = SAS_QUEUE_FULL;\n\t\t\tpm8001_ccb_task_free_done(pm8001_ha, ccb);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_BAD_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_BAD_DEST;\n\t\tif (!t->uldd_task) {\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\n\t\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\t\tts->stat = SAS_QUEUE_FULL;\n\t\t\tpm8001_ccb_task_free_done(pm8001_ha, ccb);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_CONN_RATE;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_STP_RESOURCES_BUSY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_STP_RESOURCES_BUSY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (!t->uldd_task) {\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_OPEN_CNX_ERROR_STP_RESOURCES_BUSY);\n\t\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\t\tts->stat = SAS_QUEUE_FULL;\n\t\t\tpm8001_ccb_task_free_done(pm8001_ha, ccb);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_WRONG_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_WRONG_DEST;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_NAK_RECEIVED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_NAK_RECEIVED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_NAK_R_ERR;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_ACK_NAK_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_ACK_NAK_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_NAK_R_ERR;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_DMA:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_DMA\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_ABORTED_TASK;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_SATA_LINK_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_SATA_LINK_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_ERROR_REJECTED_NCQ_MODE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_REJECTED_NCQ_MODE\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_UNDERRUN;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_XFER_OPEN_RETRY_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_OPEN_RETRY_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_PORT_IN_RESET:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_PORT_IN_RESET\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_DS_NON_OPERATIONAL:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_DS_NON_OPERATIONAL\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (!t->uldd_task) {\n\t\t\tpm8001_handle_event(pm8001_ha, pm8001_dev,\n\t\t\t\t    IO_DS_NON_OPERATIONAL);\n\t\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\t\tts->stat = SAS_QUEUE_FULL;\n\t\t\tpm8001_ccb_task_free_done(pm8001_ha, ccb);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase IO_DS_IN_RECOVERY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"  IO_DS_IN_RECOVERY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_DS_IN_ERROR:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_DS_IN_ERROR\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (!t->uldd_task) {\n\t\t\tpm8001_handle_event(pm8001_ha, pm8001_dev,\n\t\t\t\t    IO_DS_IN_ERROR);\n\t\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\t\tts->stat = SAS_QUEUE_FULL;\n\t\t\tpm8001_ccb_task_free_done(pm8001_ha, ccb);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO, \"Unknown status 0x%x\\n\", status);\n\t\t \n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\t}\n\tspin_lock_irqsave(&t->task_state_lock, flags);\n\tt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\tt->task_state_flags |= SAS_TASK_STATE_DONE;\n\tif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"task 0x%p done with io_status 0x%x resp 0x%x stat 0x%x but aborted by upper layer!\\n\",\n\t\t\t   t, status, ts->resp, ts->stat);\n\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t} else {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tpm8001_ccb_task_free_done(pm8001_ha, ccb);\n\t}\n}\n\n \nstatic void mpi_sata_event(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct sas_task *t;\n\tstruct task_status_struct *ts;\n\tstruct pm8001_ccb_info *ccb;\n\tstruct pm8001_device *pm8001_dev;\n\tstruct sata_event_resp *psataPayload =\n\t\t(struct sata_event_resp *)(piomb + 4);\n\tu32 event = le32_to_cpu(psataPayload->event);\n\tu32 tag = le32_to_cpu(psataPayload->tag);\n\tu32 port_id = le32_to_cpu(psataPayload->port_id);\n\tu32 dev_id = le32_to_cpu(psataPayload->device_id);\n\n\tif (event)\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"SATA EVENT 0x%x\\n\", event);\n\n\t \n\tif (event == IO_XFER_ERROR_ABORTED_NCQ_MODE) {\n\t\t \n\t\tpm8001_dev = pm8001_find_dev(pm8001_ha, dev_id);\n\t\tif (pm8001_dev)\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_XFER_ERROR_ABORTED_NCQ_MODE);\n\t\treturn;\n\t}\n\n\tccb = &pm8001_ha->ccb_info[tag];\n\tt = ccb->task;\n\tpm8001_dev = ccb->device;\n\tif (event)\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"sata IO status 0x%x\\n\", event);\n\n\tif (unlikely(!t)) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"task null, freeing CCB tag %d\\n\",\n\t\t\t   ccb->ccb_tag);\n\t\tpm8001_ccb_free(pm8001_ha, ccb);\n\t\treturn;\n\t}\n\n\tif (unlikely(!t->lldd_task || !t->dev))\n\t\treturn;\n\n\tts = &t->task_status;\n\tpm8001_dbg(pm8001_ha, DEVIO,\n\t\t   \"port_id:0x%x, device_id:0x%x, tag:0x%x, event:0x%x\\n\",\n\t\t   port_id, dev_id, tag, event);\n\tswitch (event) {\n\tcase IO_OVERFLOW:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_UNDERFLOW\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tts->residual = 0;\n\t\tbreak;\n\tcase IO_XFER_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_INTERRUPTED;\n\t\tbreak;\n\tcase IO_XFER_ERROR_PHY_NOT_READY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_PHY_NOT_READY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_EPROTO;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_ZONE_VIOLATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_CONT0;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\\n\");\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tif (!t->uldd_task) {\n\t\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\n\t\t\tts->resp = SAS_TASK_COMPLETE;\n\t\t\tts->stat = SAS_QUEUE_FULL;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_BAD_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_BAD_DEST;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_CONN_RATE;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_WRONG_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_WRONG_DEST;\n\t\tbreak;\n\tcase IO_XFER_ERROR_NAK_RECEIVED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_NAK_RECEIVED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_NAK_R_ERR;\n\t\tbreak;\n\tcase IO_XFER_ERROR_PEER_ABORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_PEER_ABORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_NAK_R_ERR;\n\t\tbreak;\n\tcase IO_XFER_ERROR_REJECTED_NCQ_MODE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_REJECTED_NCQ_MODE\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_UNDERRUN;\n\t\tbreak;\n\tcase IO_XFER_OPEN_RETRY_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_OPEN_RETRY_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tcase IO_XFER_ERROR_UNEXPECTED_PHASE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_UNEXPECTED_PHASE\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tcase IO_XFER_ERROR_XFER_RDY_OVERRUN:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_XFER_RDY_OVERRUN\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tcase IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_XFER_ERROR_XFER_RDY_NOT_EXPECTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tcase IO_XFER_ERROR_OFFSET_MISMATCH:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_OFFSET_MISMATCH\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tcase IO_XFER_ERROR_XFER_ZERO_DATA_LEN:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_XFER_ERROR_XFER_ZERO_DATA_LEN\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tcase IO_XFER_CMD_FRAME_ISSUED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_CMD_FRAME_ISSUED\\n\");\n\t\tbreak;\n\tcase IO_XFER_PIO_SETUP_ERROR:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_PIO_SETUP_ERROR\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO, \"Unknown status 0x%x\\n\", event);\n\t\t \n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nmpi_smp_completion(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct sas_task *t;\n\tstruct pm8001_ccb_info *ccb;\n\tunsigned long flags;\n\tu32 status;\n\tu32 tag;\n\tstruct smp_completion_resp *psmpPayload;\n\tstruct task_status_struct *ts;\n\tstruct pm8001_device *pm8001_dev;\n\n\tpsmpPayload = (struct smp_completion_resp *)(piomb + 4);\n\tstatus = le32_to_cpu(psmpPayload->status);\n\ttag = le32_to_cpu(psmpPayload->tag);\n\n\tccb = &pm8001_ha->ccb_info[tag];\n\tt = ccb->task;\n\tts = &t->task_status;\n\tpm8001_dev = ccb->device;\n\tif (status) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"smp IO status 0x%x\\n\", status);\n\t\tpm8001_dbg(pm8001_ha, IOERR,\n\t\t\t   \"status:0x%x, tag:0x%x, task:0x%p\\n\",\n\t\t\t   status, tag, t);\n\t}\n\tif (unlikely(!t || !t->lldd_task || !t->dev))\n\t\treturn;\n\n\tswitch (status) {\n\tcase IO_SUCCESS:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_SUCCESS\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_SAM_STAT_GOOD;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_ABORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_ABORTED IOMB\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_ABORTED_TASK;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_OVERFLOW:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_UNDERFLOW\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tts->residual = 0;\n\t\tif (pm8001_dev)\n\t\t\tatomic_dec(&pm8001_dev->running_req);\n\t\tbreak;\n\tcase IO_NO_DEVICE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_NO_DEVICE\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_PHY_DOWN;\n\t\tbreak;\n\tcase IO_ERROR_HW_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_ERROR_HW_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_SAM_STAT_BUSY;\n\t\tbreak;\n\tcase IO_XFER_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_SAM_STAT_BUSY;\n\t\tbreak;\n\tcase IO_XFER_ERROR_PHY_NOT_READY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_PHY_NOT_READY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_SAM_STAT_BUSY;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_PROTOCOL_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_ZONE_VIOLATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_ZONE_VIOLATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BREAK:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_BREAK\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_CONT0;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_IT_NEXUS_LOSS\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tpm8001_handle_event(pm8001_ha,\n\t\t\t\tpm8001_dev,\n\t\t\t\tIO_OPEN_CNX_ERROR_IT_NEXUS_LOSS);\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_BAD_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_BAD_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_BAD_DEST;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_OPEN_CNX_ERROR_CONNECTION_RATE_NOT_SUPPORTED\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_CONN_RATE;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_WRONG_DESTINATION:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_WRONG_DESTINATION\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_WRONG_DEST;\n\t\tbreak;\n\tcase IO_XFER_ERROR_RX_FRAME:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_ERROR_RX_FRAME\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tbreak;\n\tcase IO_XFER_OPEN_RETRY_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_XFER_OPEN_RETRY_TIMEOUT\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_ERROR_INTERNAL_SMP_RESOURCE:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_ERROR_INTERNAL_SMP_RESOURCE\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_QUEUE_FULL;\n\t\tbreak;\n\tcase IO_PORT_IN_RESET:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_PORT_IN_RESET\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_DS_NON_OPERATIONAL:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_DS_NON_OPERATIONAL\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tbreak;\n\tcase IO_DS_IN_RECOVERY:\n\t\tpm8001_dbg(pm8001_ha, IO, \"IO_DS_IN_RECOVERY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tcase IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY:\n\t\tpm8001_dbg(pm8001_ha, IO,\n\t\t\t   \"IO_OPEN_CNX_ERROR_HW_RESOURCE_BUSY\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tts->open_rej_reason = SAS_OREJ_RSVD_RETRY;\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO, \"Unknown status 0x%x\\n\", status);\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\t \n\t\tbreak;\n\t}\n\tspin_lock_irqsave(&t->task_state_lock, flags);\n\tt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\tt->task_state_flags |= SAS_TASK_STATE_DONE;\n\tif (unlikely((t->task_state_flags & SAS_TASK_STATE_ABORTED))) {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"task 0x%p done with io_status 0x%x resp 0x%x stat 0x%x but aborted by upper layer!\\n\",\n\t\t\t   t, status, ts->resp, ts->stat);\n\t\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\t} else {\n\t\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\t\tpm8001_ccb_task_free_done(pm8001_ha, ccb);\n\t}\n}\n\nvoid pm8001_mpi_set_dev_state_resp(struct pm8001_hba_info *pm8001_ha,\n\t\tvoid *piomb)\n{\n\tstruct set_dev_state_resp *pPayload =\n\t\t(struct set_dev_state_resp *)(piomb + 4);\n\tu32 tag = le32_to_cpu(pPayload->tag);\n\tstruct pm8001_ccb_info *ccb = &pm8001_ha->ccb_info[tag];\n\tstruct pm8001_device *pm8001_dev = ccb->device;\n\tu32 status = le32_to_cpu(pPayload->status);\n\tu32 device_id = le32_to_cpu(pPayload->device_id);\n\tu8 pds = le32_to_cpu(pPayload->pds_nds) & PDS_BITS;\n\tu8 nds = le32_to_cpu(pPayload->pds_nds) & NDS_BITS;\n\n\tpm8001_dbg(pm8001_ha, MSG,\n\t\t   \"Set device id = 0x%x state from 0x%x to 0x%x status = 0x%x!\\n\",\n\t\t   device_id, pds, nds, status);\n\tcomplete(pm8001_dev->setds_completion);\n\tpm8001_ccb_free(pm8001_ha, ccb);\n}\n\nvoid pm8001_mpi_set_nvmd_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct get_nvm_data_resp *pPayload =\n\t\t(struct get_nvm_data_resp *)(piomb + 4);\n\tu32 tag = le32_to_cpu(pPayload->tag);\n\tstruct pm8001_ccb_info *ccb = &pm8001_ha->ccb_info[tag];\n\tu32 dlen_status = le32_to_cpu(pPayload->dlen_status);\n\n\tcomplete(pm8001_ha->nvmd_completion);\n\tpm8001_dbg(pm8001_ha, MSG, \"Set nvm data complete!\\n\");\n\tif ((dlen_status & NVMD_STAT) != 0) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"Set nvm data error %x\\n\",\n\t\t\t\tdlen_status);\n\t}\n\tpm8001_ccb_free(pm8001_ha, ccb);\n}\n\nvoid\npm8001_mpi_get_nvmd_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct fw_control_ex    *fw_control_context;\n\tstruct get_nvm_data_resp *pPayload =\n\t\t(struct get_nvm_data_resp *)(piomb + 4);\n\tu32 tag = le32_to_cpu(pPayload->tag);\n\tstruct pm8001_ccb_info *ccb = &pm8001_ha->ccb_info[tag];\n\tu32 dlen_status = le32_to_cpu(pPayload->dlen_status);\n\tu32 ir_tds_bn_dps_das_nvm =\n\t\tle32_to_cpu(pPayload->ir_tda_bn_dps_das_nvm);\n\tvoid *virt_addr = pm8001_ha->memoryMap.region[NVMD].virt_ptr;\n\tfw_control_context = ccb->fw_control_context;\n\n\tpm8001_dbg(pm8001_ha, MSG, \"Get nvm data complete!\\n\");\n\tif ((dlen_status & NVMD_STAT) != 0) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"Get nvm data error %x\\n\",\n\t\t\t\tdlen_status);\n\t\tcomplete(pm8001_ha->nvmd_completion);\n\t\t \n\t\tpm8001_ccb_free(pm8001_ha, ccb);\n\t\treturn;\n\t}\n\tif (ir_tds_bn_dps_das_nvm & IPMode) {\n\t\t \n\t\tpm8001_dbg(pm8001_ha, MSG, \"Get NVMD success, IR=1\\n\");\n\t\tif ((ir_tds_bn_dps_das_nvm & NVMD_TYPE) == TWI_DEVICE) {\n\t\t\tif (ir_tds_bn_dps_das_nvm == 0x80a80200) {\n\t\t\t\tmemcpy(pm8001_ha->sas_addr,\n\t\t\t\t      ((u8 *)virt_addr + 4),\n\t\t\t\t       SAS_ADDR_SIZE);\n\t\t\t\tpm8001_dbg(pm8001_ha, MSG, \"Get SAS address from VPD successfully!\\n\");\n\t\t\t}\n\t\t} else if (((ir_tds_bn_dps_das_nvm & NVMD_TYPE) == C_SEEPROM)\n\t\t\t|| ((ir_tds_bn_dps_das_nvm & NVMD_TYPE) == VPD_FLASH) ||\n\t\t\t((ir_tds_bn_dps_das_nvm & NVMD_TYPE) == EXPAN_ROM)) {\n\t\t\t\t;\n\t\t} else if (((ir_tds_bn_dps_das_nvm & NVMD_TYPE) == AAP1_RDUMP)\n\t\t\t|| ((ir_tds_bn_dps_das_nvm & NVMD_TYPE) == IOP_RDUMP)) {\n\t\t\t;\n\t\t} else {\n\t\t\t \n\t\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t\t   \"(IR=1)Wrong Device type 0x%x\\n\",\n\t\t\t\t   ir_tds_bn_dps_das_nvm);\n\t\t}\n\t} else  {\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"Get NVMD success, IR=0, dataLen=%d\\n\",\n\t\t\t   (dlen_status & NVMD_LEN) >> 24);\n\t}\n\t \n\tmemcpy(fw_control_context->usrAddr,\n\t\tpm8001_ha->memoryMap.region[NVMD].virt_ptr,\n\t\tfw_control_context->len);\n\tkfree(ccb->fw_control_context);\n\t \n\tcomplete(pm8001_ha->nvmd_completion);\n\tpm8001_dbg(pm8001_ha, MSG, \"Get nvmd data complete!\\n\");\n\tpm8001_ccb_free(pm8001_ha, ccb);\n}\n\nint pm8001_mpi_local_phy_ctl(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tu32 tag;\n\tstruct local_phy_ctl_resp *pPayload =\n\t\t(struct local_phy_ctl_resp *)(piomb + 4);\n\tu32 status = le32_to_cpu(pPayload->status);\n\tu32 phy_id = le32_to_cpu(pPayload->phyop_phyid) & ID_BITS;\n\tu32 phy_op = le32_to_cpu(pPayload->phyop_phyid) & OP_BITS;\n\ttag = le32_to_cpu(pPayload->tag);\n\tif (status != 0) {\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"%x phy execute %x phy op failed!\\n\",\n\t\t\t   phy_id, phy_op);\n\t} else {\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"%x phy execute %x phy op success!\\n\",\n\t\t\t   phy_id, phy_op);\n\t\tpm8001_ha->phy[phy_id].reset_success = true;\n\t}\n\tif (pm8001_ha->phy[phy_id].enable_completion) {\n\t\tcomplete(pm8001_ha->phy[phy_id].enable_completion);\n\t\tpm8001_ha->phy[phy_id].enable_completion = NULL;\n\t}\n\tpm8001_tag_free(pm8001_ha, tag);\n\treturn 0;\n}\n\n \nvoid pm8001_bytes_dmaed(struct pm8001_hba_info *pm8001_ha, int i)\n{\n\tstruct pm8001_phy *phy = &pm8001_ha->phy[i];\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tif (!phy->phy_attached)\n\t\treturn;\n\n\tif (phy->phy_type & PORT_TYPE_SAS) {\n\t\tstruct sas_identify_frame *id;\n\t\tid = (struct sas_identify_frame *)phy->frame_rcvd;\n\t\tid->dev_type = phy->identify.device_type;\n\t\tid->initiator_bits = SAS_PROTOCOL_ALL;\n\t\tid->target_bits = phy->identify.target_port_protocols;\n\t} else if (phy->phy_type & PORT_TYPE_SATA) {\n\t\t \n\t}\n\tpm8001_dbg(pm8001_ha, MSG, \"phy %d byte dmaded.\\n\", i);\n\n\tsas_phy->frame_rcvd_size = phy->frame_rcvd_size;\n\tsas_notify_port_event(sas_phy, PORTE_BYTES_DMAED, GFP_ATOMIC);\n}\n\n \nvoid pm8001_get_lrate_mode(struct pm8001_phy *phy, u8 link_rate)\n{\n\tstruct sas_phy *sas_phy = phy->sas_phy.phy;\n\n\tswitch (link_rate) {\n\tcase PHY_SPEED_120:\n\t\tphy->sas_phy.linkrate = SAS_LINK_RATE_12_0_GBPS;\n\t\tbreak;\n\tcase PHY_SPEED_60:\n\t\tphy->sas_phy.linkrate = SAS_LINK_RATE_6_0_GBPS;\n\t\tbreak;\n\tcase PHY_SPEED_30:\n\t\tphy->sas_phy.linkrate = SAS_LINK_RATE_3_0_GBPS;\n\t\tbreak;\n\tcase PHY_SPEED_15:\n\t\tphy->sas_phy.linkrate = SAS_LINK_RATE_1_5_GBPS;\n\t\tbreak;\n\t}\n\tsas_phy->negotiated_linkrate = phy->sas_phy.linkrate;\n\tsas_phy->maximum_linkrate_hw = phy->maximum_linkrate;\n\tsas_phy->minimum_linkrate_hw = SAS_LINK_RATE_1_5_GBPS;\n\tsas_phy->maximum_linkrate = phy->maximum_linkrate;\n\tsas_phy->minimum_linkrate = phy->minimum_linkrate;\n}\n\n \nvoid pm8001_get_attached_sas_addr(struct pm8001_phy *phy,\n\tu8 *sas_addr)\n{\n\tif (phy->sas_phy.frame_rcvd[0] == 0x34\n\t\t&& phy->sas_phy.oob_mode == SATA_OOB_MODE) {\n\t\tstruct pm8001_hba_info *pm8001_ha = phy->sas_phy.ha->lldd_ha;\n\t\t \n\t\tu64 addr = be64_to_cpu(*(__be64 *)pm8001_ha->sas_addr);\n\t\taddr += phy->sas_phy.id;\n\t\t*(__be64 *)sas_addr = cpu_to_be64(addr);\n\t} else {\n\t\tstruct sas_identify_frame *idframe =\n\t\t\t(void *) phy->sas_phy.frame_rcvd;\n\t\tmemcpy(sas_addr, idframe->sas_addr, SAS_ADDR_SIZE);\n\t}\n}\n\n \nstatic void pm8001_hw_event_ack_req(struct pm8001_hba_info *pm8001_ha,\n\tu32 Qnum, u32 SEA, u32 port_id, u32 phyId, u32 param0, u32 param1)\n{\n\tstruct hw_event_ack_req\t payload;\n\tu32 opc = OPC_INB_SAS_HW_EVENT_ACK;\n\n\tmemset((u8 *)&payload, 0, sizeof(payload));\n\tpayload.tag = cpu_to_le32(1);\n\tpayload.sea_phyid_portid = cpu_to_le32(((SEA & 0xFFFF) << 8) |\n\t\t((phyId & 0x0F) << 4) | (port_id & 0x0F));\n\tpayload.param0 = cpu_to_le32(param0);\n\tpayload.param1 = cpu_to_le32(param1);\n\n\tpm8001_mpi_build_cmd(pm8001_ha, Qnum, opc, &payload, sizeof(payload), 0);\n}\n\nstatic int pm8001_chip_phy_ctl_req(struct pm8001_hba_info *pm8001_ha,\n\tu32 phyId, u32 phy_op);\n\n \nstatic void\nhw_event_sas_phy_up(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct hw_event_resp *pPayload =\n\t\t(struct hw_event_resp *)(piomb + 4);\n\tu32 lr_evt_status_phyid_portid =\n\t\tle32_to_cpu(pPayload->lr_evt_status_phyid_portid);\n\tu8 link_rate =\n\t\t(u8)((lr_evt_status_phyid_portid & 0xF0000000) >> 28);\n\tu8 port_id = (u8)(lr_evt_status_phyid_portid & 0x0000000F);\n\tu8 phy_id =\n\t\t(u8)((lr_evt_status_phyid_portid & 0x000000F0) >> 4);\n\tu32 npip_portstate = le32_to_cpu(pPayload->npip_portstate);\n\tu8 portstate = (u8)(npip_portstate & 0x0000000F);\n\tstruct pm8001_port *port = &pm8001_ha->port[port_id];\n\tstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\n\tunsigned long flags;\n\tu8 deviceType = pPayload->sas_identify.dev_type;\n\tphy->port = port;\n\tport->port_id = port_id;\n\tport->port_state =  portstate;\n\tphy->phy_state = PHY_STATE_LINK_UP_SPC;\n\tpm8001_dbg(pm8001_ha, MSG,\n\t\t   \"HW_EVENT_SAS_PHY_UP port id = %d, phy id = %d\\n\",\n\t\t   port_id, phy_id);\n\n\tswitch (deviceType) {\n\tcase SAS_PHY_UNUSED:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"device type no device.\\n\");\n\t\tbreak;\n\tcase SAS_END_DEVICE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"end device.\\n\");\n\t\tpm8001_chip_phy_ctl_req(pm8001_ha, phy_id,\n\t\t\tPHY_NOTIFY_ENABLE_SPINUP);\n\t\tport->port_attached = 1;\n\t\tpm8001_get_lrate_mode(phy, link_rate);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"expander device.\\n\");\n\t\tport->port_attached = 1;\n\t\tpm8001_get_lrate_mode(phy, link_rate);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"fanout expander device.\\n\");\n\t\tport->port_attached = 1;\n\t\tpm8001_get_lrate_mode(phy, link_rate);\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO, \"unknown device type(%x)\\n\",\n\t\t\t   deviceType);\n\t\tbreak;\n\t}\n\tphy->phy_type |= PORT_TYPE_SAS;\n\tphy->identify.device_type = deviceType;\n\tphy->phy_attached = 1;\n\tif (phy->identify.device_type == SAS_END_DEVICE)\n\t\tphy->identify.target_port_protocols = SAS_PROTOCOL_SSP;\n\telse if (phy->identify.device_type != SAS_PHY_UNUSED)\n\t\tphy->identify.target_port_protocols = SAS_PROTOCOL_SMP;\n\tphy->sas_phy.oob_mode = SAS_OOB_MODE;\n\tsas_notify_phy_event(&phy->sas_phy, PHYE_OOB_DONE, GFP_ATOMIC);\n\tspin_lock_irqsave(&phy->sas_phy.frame_rcvd_lock, flags);\n\tmemcpy(phy->frame_rcvd, &pPayload->sas_identify,\n\t\tsizeof(struct sas_identify_frame)-4);\n\tphy->frame_rcvd_size = sizeof(struct sas_identify_frame) - 4;\n\tpm8001_get_attached_sas_addr(phy, phy->sas_phy.attached_sas_addr);\n\tspin_unlock_irqrestore(&phy->sas_phy.frame_rcvd_lock, flags);\n\tif (pm8001_ha->flags == PM8001F_RUN_TIME)\n\t\tmdelay(200); \n\tpm8001_bytes_dmaed(pm8001_ha, phy_id);\n}\n\n \nstatic void\nhw_event_sata_phy_up(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct hw_event_resp *pPayload =\n\t\t(struct hw_event_resp *)(piomb + 4);\n\tu32 lr_evt_status_phyid_portid =\n\t\tle32_to_cpu(pPayload->lr_evt_status_phyid_portid);\n\tu8 link_rate =\n\t\t(u8)((lr_evt_status_phyid_portid & 0xF0000000) >> 28);\n\tu8 port_id = (u8)(lr_evt_status_phyid_portid & 0x0000000F);\n\tu8 phy_id =\n\t\t(u8)((lr_evt_status_phyid_portid & 0x000000F0) >> 4);\n\tu32 npip_portstate = le32_to_cpu(pPayload->npip_portstate);\n\tu8 portstate = (u8)(npip_portstate & 0x0000000F);\n\tstruct pm8001_port *port = &pm8001_ha->port[port_id];\n\tstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\n\tunsigned long flags;\n\tpm8001_dbg(pm8001_ha, DEVIO, \"HW_EVENT_SATA_PHY_UP port id = %d, phy id = %d\\n\",\n\t\t   port_id, phy_id);\n\tphy->port = port;\n\tport->port_id = port_id;\n\tport->port_state =  portstate;\n\tphy->phy_state = PHY_STATE_LINK_UP_SPC;\n\tport->port_attached = 1;\n\tpm8001_get_lrate_mode(phy, link_rate);\n\tphy->phy_type |= PORT_TYPE_SATA;\n\tphy->phy_attached = 1;\n\tphy->sas_phy.oob_mode = SATA_OOB_MODE;\n\tsas_notify_phy_event(&phy->sas_phy, PHYE_OOB_DONE, GFP_ATOMIC);\n\tspin_lock_irqsave(&phy->sas_phy.frame_rcvd_lock, flags);\n\tmemcpy(phy->frame_rcvd, ((u8 *)&pPayload->sata_fis - 4),\n\t\tsizeof(struct dev_to_host_fis));\n\tphy->frame_rcvd_size = sizeof(struct dev_to_host_fis);\n\tphy->identify.target_port_protocols = SAS_PROTOCOL_SATA;\n\tphy->identify.device_type = SAS_SATA_DEV;\n\tpm8001_get_attached_sas_addr(phy, phy->sas_phy.attached_sas_addr);\n\tspin_unlock_irqrestore(&phy->sas_phy.frame_rcvd_lock, flags);\n\tpm8001_bytes_dmaed(pm8001_ha, phy_id);\n}\n\n \nstatic void\nhw_event_phy_down(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct hw_event_resp *pPayload =\n\t\t(struct hw_event_resp *)(piomb + 4);\n\tu32 lr_evt_status_phyid_portid =\n\t\tle32_to_cpu(pPayload->lr_evt_status_phyid_portid);\n\tu8 port_id = (u8)(lr_evt_status_phyid_portid & 0x0000000F);\n\tu8 phy_id =\n\t\t(u8)((lr_evt_status_phyid_portid & 0x000000F0) >> 4);\n\tu32 npip_portstate = le32_to_cpu(pPayload->npip_portstate);\n\tu8 portstate = (u8)(npip_portstate & 0x0000000F);\n\tstruct pm8001_port *port = &pm8001_ha->port[port_id];\n\tstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\n\tport->port_state =  portstate;\n\tphy->phy_type = 0;\n\tphy->identify.device_type = 0;\n\tphy->phy_attached = 0;\n\tmemset(&phy->dev_sas_addr, 0, SAS_ADDR_SIZE);\n\tswitch (portstate) {\n\tcase PORT_VALID:\n\t\tbreak;\n\tcase PORT_INVALID:\n\t\tpm8001_dbg(pm8001_ha, MSG, \" PortInvalid portID %d\\n\",\n\t\t\t   port_id);\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \" Last phy Down and port invalid\\n\");\n\t\tport->port_attached = 0;\n\t\tpm8001_hw_event_ack_req(pm8001_ha, 0, HW_EVENT_PHY_DOWN,\n\t\t\tport_id, phy_id, 0, 0);\n\t\tbreak;\n\tcase PORT_IN_RESET:\n\t\tpm8001_dbg(pm8001_ha, MSG, \" Port In Reset portID %d\\n\",\n\t\t\t   port_id);\n\t\tbreak;\n\tcase PORT_NOT_ESTABLISHED:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \" phy Down and PORT_NOT_ESTABLISHED\\n\");\n\t\tport->port_attached = 0;\n\t\tbreak;\n\tcase PORT_LOSTCOMM:\n\t\tpm8001_dbg(pm8001_ha, MSG, \" phy Down and PORT_LOSTCOMM\\n\");\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \" Last phy Down and port invalid\\n\");\n\t\tport->port_attached = 0;\n\t\tpm8001_hw_event_ack_req(pm8001_ha, 0, HW_EVENT_PHY_DOWN,\n\t\t\tport_id, phy_id, 0, 0);\n\t\tbreak;\n\tdefault:\n\t\tport->port_attached = 0;\n\t\tpm8001_dbg(pm8001_ha, DEVIO, \" phy Down and(default) = %x\\n\",\n\t\t\t   portstate);\n\t\tbreak;\n\n\t}\n}\n\n \nint pm8001_mpi_reg_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tu32 status;\n\tu32 device_id;\n\tu32 htag;\n\tstruct pm8001_ccb_info *ccb;\n\tstruct pm8001_device *pm8001_dev;\n\tstruct dev_reg_resp *registerRespPayload =\n\t\t(struct dev_reg_resp *)(piomb + 4);\n\n\thtag = le32_to_cpu(registerRespPayload->tag);\n\tccb = &pm8001_ha->ccb_info[htag];\n\tpm8001_dev = ccb->device;\n\tstatus = le32_to_cpu(registerRespPayload->status);\n\tdevice_id = le32_to_cpu(registerRespPayload->device_id);\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"register device status %d phy_id 0x%x device_id %d\\n\",\n\t\t   status, pm8001_dev->attached_phy, device_id);\n\tswitch (status) {\n\tcase DEVREG_SUCCESS:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"DEVREG_SUCCESS\\n\");\n\t\tpm8001_dev->device_id = device_id;\n\t\tbreak;\n\tcase DEVREG_FAILURE_OUT_OF_RESOURCE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"DEVREG_FAILURE_OUT_OF_RESOURCE\\n\");\n\t\tbreak;\n\tcase DEVREG_FAILURE_DEVICE_ALREADY_REGISTERED:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"DEVREG_FAILURE_DEVICE_ALREADY_REGISTERED\\n\");\n\t\tbreak;\n\tcase DEVREG_FAILURE_INVALID_PHY_ID:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"DEVREG_FAILURE_INVALID_PHY_ID\\n\");\n\t\tbreak;\n\tcase DEVREG_FAILURE_PHY_ID_ALREADY_REGISTERED:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"DEVREG_FAILURE_PHY_ID_ALREADY_REGISTERED\\n\");\n\t\tbreak;\n\tcase DEVREG_FAILURE_PORT_ID_OUT_OF_RANGE:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"DEVREG_FAILURE_PORT_ID_OUT_OF_RANGE\\n\");\n\t\tbreak;\n\tcase DEVREG_FAILURE_PORT_NOT_VALID_STATE:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"DEVREG_FAILURE_PORT_NOT_VALID_STATE\\n\");\n\t\tbreak;\n\tcase DEVREG_FAILURE_DEVICE_TYPE_NOT_VALID:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"DEVREG_FAILURE_DEVICE_TYPE_NOT_VALID\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"DEVREG_FAILURE_DEVICE_TYPE_NOT_SUPPORTED\\n\");\n\t\tbreak;\n\t}\n\tcomplete(pm8001_dev->dcompletion);\n\tpm8001_ccb_free(pm8001_ha, ccb);\n\treturn 0;\n}\n\nint pm8001_mpi_dereg_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tu32 status;\n\tu32 device_id;\n\tstruct dev_reg_resp *registerRespPayload =\n\t\t(struct dev_reg_resp *)(piomb + 4);\n\n\tstatus = le32_to_cpu(registerRespPayload->status);\n\tdevice_id = le32_to_cpu(registerRespPayload->device_id);\n\tif (status != 0)\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \" deregister device failed ,status = %x, device_id = %x\\n\",\n\t\t\t   status, device_id);\n\treturn 0;\n}\n\n \nint pm8001_mpi_fw_flash_update_resp(struct pm8001_hba_info *pm8001_ha,\n\t\tvoid *piomb)\n{\n\tu32 status;\n\tstruct fw_flash_Update_resp *ppayload =\n\t\t(struct fw_flash_Update_resp *)(piomb + 4);\n\tu32 tag = le32_to_cpu(ppayload->tag);\n\tstruct pm8001_ccb_info *ccb = &pm8001_ha->ccb_info[tag];\n\n\tstatus = le32_to_cpu(ppayload->status);\n\tswitch (status) {\n\tcase FLASH_UPDATE_COMPLETE_PENDING_REBOOT:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \": FLASH_UPDATE_COMPLETE_PENDING_REBOOT\\n\");\n\t\tbreak;\n\tcase FLASH_UPDATE_IN_PROGRESS:\n\t\tpm8001_dbg(pm8001_ha, MSG, \": FLASH_UPDATE_IN_PROGRESS\\n\");\n\t\tbreak;\n\tcase FLASH_UPDATE_HDR_ERR:\n\t\tpm8001_dbg(pm8001_ha, MSG, \": FLASH_UPDATE_HDR_ERR\\n\");\n\t\tbreak;\n\tcase FLASH_UPDATE_OFFSET_ERR:\n\t\tpm8001_dbg(pm8001_ha, MSG, \": FLASH_UPDATE_OFFSET_ERR\\n\");\n\t\tbreak;\n\tcase FLASH_UPDATE_CRC_ERR:\n\t\tpm8001_dbg(pm8001_ha, MSG, \": FLASH_UPDATE_CRC_ERR\\n\");\n\t\tbreak;\n\tcase FLASH_UPDATE_LENGTH_ERR:\n\t\tpm8001_dbg(pm8001_ha, MSG, \": FLASH_UPDATE_LENGTH_ERR\\n\");\n\t\tbreak;\n\tcase FLASH_UPDATE_HW_ERR:\n\t\tpm8001_dbg(pm8001_ha, MSG, \": FLASH_UPDATE_HW_ERR\\n\");\n\t\tbreak;\n\tcase FLASH_UPDATE_DNLD_NOT_SUPPORTED:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \": FLASH_UPDATE_DNLD_NOT_SUPPORTED\\n\");\n\t\tbreak;\n\tcase FLASH_UPDATE_DISABLED:\n\t\tpm8001_dbg(pm8001_ha, MSG, \": FLASH_UPDATE_DISABLED\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO, \"No matched status = %d\\n\",\n\t\t\t   status);\n\t\tbreak;\n\t}\n\tkfree(ccb->fw_control_context);\n\tpm8001_ccb_free(pm8001_ha, ccb);\n\tcomplete(pm8001_ha->nvmd_completion);\n\treturn 0;\n}\n\nint pm8001_mpi_general_event(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tu32 status;\n\tint i;\n\tstruct general_event_resp *pPayload =\n\t\t(struct general_event_resp *)(piomb + 4);\n\tstatus = le32_to_cpu(pPayload->status);\n\tpm8001_dbg(pm8001_ha, MSG, \" status = 0x%x\\n\", status);\n\tfor (i = 0; i < GENERAL_EVENT_PAYLOAD; i++)\n\t\tpm8001_dbg(pm8001_ha, MSG, \"inb_IOMB_payload[0x%x] 0x%x,\\n\",\n\t\t\t   i,\n\t\t\t   pPayload->inb_IOMB_payload[i]);\n\treturn 0;\n}\n\nint pm8001_mpi_task_abort_resp(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tstruct sas_task *t;\n\tstruct pm8001_ccb_info *ccb;\n\tunsigned long flags;\n\tu32 status ;\n\tu32 tag, scp;\n\tstruct task_status_struct *ts;\n\tstruct pm8001_device *pm8001_dev;\n\n\tstruct task_abort_resp *pPayload =\n\t\t(struct task_abort_resp *)(piomb + 4);\n\n\tstatus = le32_to_cpu(pPayload->status);\n\ttag = le32_to_cpu(pPayload->tag);\n\n\tscp = le32_to_cpu(pPayload->scp);\n\tccb = &pm8001_ha->ccb_info[tag];\n\tt = ccb->task;\n\tpm8001_dev = ccb->device;  \n\n\tif (!t)\t{\n\t\tpm8001_dbg(pm8001_ha, FAIL, \" TASK NULL. RETURNING !!!\\n\");\n\t\treturn -1;\n\t}\n\n\tif (t->task_proto == SAS_PROTOCOL_INTERNAL_ABORT)\n\t\tatomic_dec(&pm8001_dev->running_req);\n\n\tts = &t->task_status;\n\tif (status != 0)\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"task abort failed status 0x%x ,tag = 0x%x, scp= 0x%x\\n\",\n\t\t\t   status, tag, scp);\n\tswitch (status) {\n\tcase IO_SUCCESS:\n\t\tpm8001_dbg(pm8001_ha, EH, \"IO_SUCCESS\\n\");\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_SAM_STAT_GOOD;\n\t\tbreak;\n\tcase IO_NOT_VALID:\n\t\tpm8001_dbg(pm8001_ha, EH, \"IO_NOT_VALID\\n\");\n\t\tts->resp = TMF_RESP_FUNC_FAILED;\n\t\tbreak;\n\t}\n\tspin_lock_irqsave(&t->task_state_lock, flags);\n\tt->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\tt->task_state_flags |= SAS_TASK_STATE_DONE;\n\tspin_unlock_irqrestore(&t->task_state_lock, flags);\n\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\tmb();\n\n\tt->task_done(t);\n\n\treturn 0;\n}\n\n \nstatic int mpi_hw_event(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\tunsigned long flags;\n\tstruct hw_event_resp *pPayload =\n\t\t(struct hw_event_resp *)(piomb + 4);\n\tu32 lr_evt_status_phyid_portid =\n\t\tle32_to_cpu(pPayload->lr_evt_status_phyid_portid);\n\tu8 port_id = (u8)(lr_evt_status_phyid_portid & 0x0000000F);\n\tu8 phy_id =\n\t\t(u8)((lr_evt_status_phyid_portid & 0x000000F0) >> 4);\n\tu16 eventType =\n\t\t(u16)((lr_evt_status_phyid_portid & 0x00FFFF00) >> 8);\n\tu8 status =\n\t\t(u8)((lr_evt_status_phyid_portid & 0x0F000000) >> 24);\n\tstruct sas_ha_struct *sas_ha = pm8001_ha->sas;\n\tstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\n\tstruct asd_sas_phy *sas_phy = sas_ha->sas_phy[phy_id];\n\tpm8001_dbg(pm8001_ha, DEVIO,\n\t\t   \"SPC HW event for portid:%d, phyid:%d, event:%x, status:%x\\n\",\n\t\t   port_id, phy_id, eventType, status);\n\tswitch (eventType) {\n\tcase HW_EVENT_PHY_START_STATUS:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_PHY_START_STATUS status = %x\\n\",\n\t\t\t   status);\n\t\tif (status == 0)\n\t\t\tphy->phy_state = 1;\n\n\t\tif (pm8001_ha->flags == PM8001F_RUN_TIME &&\n\t\t\t\tphy->enable_completion != NULL) {\n\t\t\tcomplete(phy->enable_completion);\n\t\t\tphy->enable_completion = NULL;\n\t\t}\n\t\tbreak;\n\tcase HW_EVENT_SAS_PHY_UP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_PHY_START_STATUS\\n\");\n\t\thw_event_sas_phy_up(pm8001_ha, piomb);\n\t\tbreak;\n\tcase HW_EVENT_SATA_PHY_UP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_SATA_PHY_UP\\n\");\n\t\thw_event_sata_phy_up(pm8001_ha, piomb);\n\t\tbreak;\n\tcase HW_EVENT_PHY_STOP_STATUS:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_PHY_STOP_STATUS status = %x\\n\",\n\t\t\t   status);\n\t\tif (status == 0)\n\t\t\tphy->phy_state = 0;\n\t\tbreak;\n\tcase HW_EVENT_SATA_SPINUP_HOLD:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_SATA_SPINUP_HOLD\\n\");\n\t\tsas_notify_phy_event(&phy->sas_phy, PHYE_SPINUP_HOLD,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_PHY_DOWN:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_PHY_DOWN\\n\");\n\t\tsas_notify_phy_event(&phy->sas_phy, PHYE_LOSS_OF_SIGNAL,\n\t\t\tGFP_ATOMIC);\n\t\tphy->phy_attached = 0;\n\t\tphy->phy_state = 0;\n\t\thw_event_phy_down(pm8001_ha, piomb);\n\t\tbreak;\n\tcase HW_EVENT_PORT_INVALID:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_PORT_INVALID\\n\");\n\t\tsas_phy_disconnected(sas_phy);\n\t\tphy->phy_attached = 0;\n\t\tsas_notify_port_event(sas_phy, PORTE_LINK_RESET_ERR,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\t \n\tcase HW_EVENT_BROADCAST_CHANGE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_BROADCAST_CHANGE\\n\");\n\t\tpm8001_hw_event_ack_req(pm8001_ha, 0, HW_EVENT_BROADCAST_CHANGE,\n\t\t\tport_id, phy_id, 1, 0);\n\t\tspin_lock_irqsave(&sas_phy->sas_prim_lock, flags);\n\t\tsas_phy->sas_prim = HW_EVENT_BROADCAST_CHANGE;\n\t\tspin_unlock_irqrestore(&sas_phy->sas_prim_lock, flags);\n\t\tsas_notify_port_event(sas_phy, PORTE_BROADCAST_RCVD,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_PHY_ERROR:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_PHY_ERROR\\n\");\n\t\tsas_phy_disconnected(&phy->sas_phy);\n\t\tphy->phy_attached = 0;\n\t\tsas_notify_phy_event(&phy->sas_phy, PHYE_OOB_ERROR, GFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_BROADCAST_EXP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_BROADCAST_EXP\\n\");\n\t\tspin_lock_irqsave(&sas_phy->sas_prim_lock, flags);\n\t\tsas_phy->sas_prim = HW_EVENT_BROADCAST_EXP;\n\t\tspin_unlock_irqrestore(&sas_phy->sas_prim_lock, flags);\n\t\tsas_notify_port_event(sas_phy, PORTE_BROADCAST_RCVD,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_LINK_ERR_INVALID_DWORD:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"HW_EVENT_LINK_ERR_INVALID_DWORD\\n\");\n\t\tpm8001_hw_event_ack_req(pm8001_ha, 0,\n\t\t\tHW_EVENT_LINK_ERR_INVALID_DWORD, port_id, phy_id, 0, 0);\n\t\tsas_phy_disconnected(sas_phy);\n\t\tphy->phy_attached = 0;\n\t\tsas_notify_port_event(sas_phy, PORTE_LINK_RESET_ERR,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_LINK_ERR_DISPARITY_ERROR:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"HW_EVENT_LINK_ERR_DISPARITY_ERROR\\n\");\n\t\tpm8001_hw_event_ack_req(pm8001_ha, 0,\n\t\t\tHW_EVENT_LINK_ERR_DISPARITY_ERROR,\n\t\t\tport_id, phy_id, 0, 0);\n\t\tsas_phy_disconnected(sas_phy);\n\t\tphy->phy_attached = 0;\n\t\tsas_notify_port_event(sas_phy, PORTE_LINK_RESET_ERR,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_LINK_ERR_CODE_VIOLATION:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"HW_EVENT_LINK_ERR_CODE_VIOLATION\\n\");\n\t\tpm8001_hw_event_ack_req(pm8001_ha, 0,\n\t\t\tHW_EVENT_LINK_ERR_CODE_VIOLATION,\n\t\t\tport_id, phy_id, 0, 0);\n\t\tsas_phy_disconnected(sas_phy);\n\t\tphy->phy_attached = 0;\n\t\tsas_notify_port_event(sas_phy, PORTE_LINK_RESET_ERR,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_LINK_ERR_LOSS_OF_DWORD_SYNCH:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"HW_EVENT_LINK_ERR_LOSS_OF_DWORD_SYNCH\\n\");\n\t\tpm8001_hw_event_ack_req(pm8001_ha, 0,\n\t\t\tHW_EVENT_LINK_ERR_LOSS_OF_DWORD_SYNCH,\n\t\t\tport_id, phy_id, 0, 0);\n\t\tsas_phy_disconnected(sas_phy);\n\t\tphy->phy_attached = 0;\n\t\tsas_notify_port_event(sas_phy, PORTE_LINK_RESET_ERR,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_MALFUNCTION:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_MALFUNCTION\\n\");\n\t\tbreak;\n\tcase HW_EVENT_BROADCAST_SES:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_BROADCAST_SES\\n\");\n\t\tspin_lock_irqsave(&sas_phy->sas_prim_lock, flags);\n\t\tsas_phy->sas_prim = HW_EVENT_BROADCAST_SES;\n\t\tspin_unlock_irqrestore(&sas_phy->sas_prim_lock, flags);\n\t\tsas_notify_port_event(sas_phy, PORTE_BROADCAST_RCVD,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_INBOUND_CRC_ERROR:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_INBOUND_CRC_ERROR\\n\");\n\t\tpm8001_hw_event_ack_req(pm8001_ha, 0,\n\t\t\tHW_EVENT_INBOUND_CRC_ERROR,\n\t\t\tport_id, phy_id, 0, 0);\n\t\tbreak;\n\tcase HW_EVENT_HARD_RESET_RECEIVED:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_HARD_RESET_RECEIVED\\n\");\n\t\tsas_notify_port_event(sas_phy, PORTE_HARD_RESET, GFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_ID_FRAME_TIMEOUT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_ID_FRAME_TIMEOUT\\n\");\n\t\tsas_phy_disconnected(sas_phy);\n\t\tphy->phy_attached = 0;\n\t\tsas_notify_port_event(sas_phy, PORTE_LINK_RESET_ERR,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_LINK_ERR_PHY_RESET_FAILED:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"HW_EVENT_LINK_ERR_PHY_RESET_FAILED\\n\");\n\t\tpm8001_hw_event_ack_req(pm8001_ha, 0,\n\t\t\tHW_EVENT_LINK_ERR_PHY_RESET_FAILED,\n\t\t\tport_id, phy_id, 0, 0);\n\t\tsas_phy_disconnected(sas_phy);\n\t\tphy->phy_attached = 0;\n\t\tsas_notify_port_event(sas_phy, PORTE_LINK_RESET_ERR,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_PORT_RESET_TIMER_TMO:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_PORT_RESET_TIMER_TMO\\n\");\n\t\tsas_phy_disconnected(sas_phy);\n\t\tphy->phy_attached = 0;\n\t\tsas_notify_port_event(sas_phy, PORTE_LINK_RESET_ERR,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_PORT_RECOVERY_TIMER_TMO:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"HW_EVENT_PORT_RECOVERY_TIMER_TMO\\n\");\n\t\tsas_phy_disconnected(sas_phy);\n\t\tphy->phy_attached = 0;\n\t\tsas_notify_port_event(sas_phy, PORTE_LINK_RESET_ERR,\n\t\t\tGFP_ATOMIC);\n\t\tbreak;\n\tcase HW_EVENT_PORT_RECOVER:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_PORT_RECOVER\\n\");\n\t\tbreak;\n\tcase HW_EVENT_PORT_RESET_COMPLETE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"HW_EVENT_PORT_RESET_COMPLETE\\n\");\n\t\tbreak;\n\tcase EVENT_BROADCAST_ASYNCH_EVENT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"EVENT_BROADCAST_ASYNCH_EVENT\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO, \"Unknown event type = %x\\n\",\n\t\t\t   eventType);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic void process_one_iomb(struct pm8001_hba_info *pm8001_ha, void *piomb)\n{\n\t__le32 pHeader = *(__le32 *)piomb;\n\tu8 opc = (u8)((le32_to_cpu(pHeader)) & 0xFFF);\n\n\tpm8001_dbg(pm8001_ha, MSG, \"process_one_iomb:\\n\");\n\n\tswitch (opc) {\n\tcase OPC_OUB_ECHO:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_ECHO\\n\");\n\t\tbreak;\n\tcase OPC_OUB_HW_EVENT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_HW_EVENT\\n\");\n\t\tmpi_hw_event(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SSP_COMP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SSP_COMP\\n\");\n\t\tmpi_ssp_completion(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SMP_COMP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SMP_COMP\\n\");\n\t\tmpi_smp_completion(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_LOCAL_PHY_CNTRL:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_LOCAL_PHY_CNTRL\\n\");\n\t\tpm8001_mpi_local_phy_ctl(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_DEV_REGIST:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_DEV_REGIST\\n\");\n\t\tpm8001_mpi_reg_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_DEREG_DEV:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"unregister the device\\n\");\n\t\tpm8001_mpi_dereg_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_GET_DEV_HANDLE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_GET_DEV_HANDLE\\n\");\n\t\tbreak;\n\tcase OPC_OUB_SATA_COMP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SATA_COMP\\n\");\n\t\tmpi_sata_completion(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SATA_EVENT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SATA_EVENT\\n\");\n\t\tmpi_sata_event(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SSP_EVENT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SSP_EVENT\\n\");\n\t\tmpi_ssp_event(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_DEV_HANDLE_ARRIV:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_DEV_HANDLE_ARRIV\\n\");\n\t\t \n\t\tbreak;\n\tcase OPC_OUB_SSP_RECV_EVENT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SSP_RECV_EVENT\\n\");\n\t\t \n\t\tbreak;\n\tcase OPC_OUB_DEV_INFO:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_DEV_INFO\\n\");\n\t\tbreak;\n\tcase OPC_OUB_FW_FLASH_UPDATE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_FW_FLASH_UPDATE\\n\");\n\t\tpm8001_mpi_fw_flash_update_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_GPIO_RESPONSE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_GPIO_RESPONSE\\n\");\n\t\tbreak;\n\tcase OPC_OUB_GPIO_EVENT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_GPIO_EVENT\\n\");\n\t\tbreak;\n\tcase OPC_OUB_GENERAL_EVENT:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_GENERAL_EVENT\\n\");\n\t\tpm8001_mpi_general_event(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SSP_ABORT_RSP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SSP_ABORT_RSP\\n\");\n\t\tpm8001_mpi_task_abort_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SATA_ABORT_RSP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SATA_ABORT_RSP\\n\");\n\t\tpm8001_mpi_task_abort_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SAS_DIAG_MODE_START_END:\n\t\tpm8001_dbg(pm8001_ha, MSG,\n\t\t\t   \"OPC_OUB_SAS_DIAG_MODE_START_END\\n\");\n\t\tbreak;\n\tcase OPC_OUB_SAS_DIAG_EXECUTE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SAS_DIAG_EXECUTE\\n\");\n\t\tbreak;\n\tcase OPC_OUB_GET_TIME_STAMP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_GET_TIME_STAMP\\n\");\n\t\tbreak;\n\tcase OPC_OUB_SAS_HW_EVENT_ACK:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SAS_HW_EVENT_ACK\\n\");\n\t\tbreak;\n\tcase OPC_OUB_PORT_CONTROL:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_PORT_CONTROL\\n\");\n\t\tbreak;\n\tcase OPC_OUB_SMP_ABORT_RSP:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SMP_ABORT_RSP\\n\");\n\t\tpm8001_mpi_task_abort_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_GET_NVMD_DATA:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_GET_NVMD_DATA\\n\");\n\t\tpm8001_mpi_get_nvmd_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_SET_NVMD_DATA:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SET_NVMD_DATA\\n\");\n\t\tpm8001_mpi_set_nvmd_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_DEVICE_HANDLE_REMOVAL:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_DEVICE_HANDLE_REMOVAL\\n\");\n\t\tbreak;\n\tcase OPC_OUB_SET_DEVICE_STATE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SET_DEVICE_STATE\\n\");\n\t\tpm8001_mpi_set_dev_state_resp(pm8001_ha, piomb);\n\t\tbreak;\n\tcase OPC_OUB_GET_DEVICE_STATE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_GET_DEVICE_STATE\\n\");\n\t\tbreak;\n\tcase OPC_OUB_SET_DEV_INFO:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SET_DEV_INFO\\n\");\n\t\tbreak;\n\tcase OPC_OUB_SAS_RE_INITIALIZE:\n\t\tpm8001_dbg(pm8001_ha, MSG, \"OPC_OUB_SAS_RE_INITIALIZE\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO,\n\t\t\t   \"Unknown outbound Queue IOMB OPC = %x\\n\",\n\t\t\t   opc);\n\t\tbreak;\n\t}\n}\n\nstatic int process_oq(struct pm8001_hba_info *pm8001_ha, u8 vec)\n{\n\tstruct outbound_queue_table *circularQ;\n\tvoid *pMsg1 = NULL;\n\tu8 bc;\n\tu32 ret = MPI_IO_STATUS_FAIL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\tcircularQ = &pm8001_ha->outbnd_q_tbl[vec];\n\tdo {\n\t\tret = pm8001_mpi_msg_consume(pm8001_ha, circularQ, &pMsg1, &bc);\n\t\tif (MPI_IO_STATUS_SUCCESS == ret) {\n\t\t\t \n\t\t\tprocess_one_iomb(pm8001_ha, (void *)(pMsg1 - 4));\n\t\t\t \n\t\t\tpm8001_mpi_msg_free_set(pm8001_ha, pMsg1,\n\t\t\t\t\t\t\tcircularQ, bc);\n\t\t}\n\t\tif (MPI_IO_STATUS_BUSY == ret) {\n\t\t\t \n\t\t\tcircularQ->producer_index =\n\t\t\t\tcpu_to_le32(pm8001_read_32(circularQ->pi_virt));\n\t\t\tif (le32_to_cpu(circularQ->producer_index) ==\n\t\t\t\tcircularQ->consumer_idx)\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t}\n\t} while (1);\n\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\treturn ret;\n}\n\n \nstatic const u8 data_dir_flags[] = {\n\t[DMA_BIDIRECTIONAL]\t= DATA_DIR_BYRECIPIENT,\t \n\t[DMA_TO_DEVICE]\t\t= DATA_DIR_OUT,\t\t \n\t[DMA_FROM_DEVICE]\t= DATA_DIR_IN,\t\t \n\t[DMA_NONE]\t\t= DATA_DIR_NONE,\t \n};\nvoid\npm8001_chip_make_sg(struct scatterlist *scatter, int nr, void *prd)\n{\n\tint i;\n\tstruct scatterlist *sg;\n\tstruct pm8001_prd *buf_prd = prd;\n\n\tfor_each_sg(scatter, sg, nr, i) {\n\t\tbuf_prd->addr = cpu_to_le64(sg_dma_address(sg));\n\t\tbuf_prd->im_len.len = cpu_to_le32(sg_dma_len(sg));\n\t\tbuf_prd->im_len.e = 0;\n\t\tbuf_prd++;\n\t}\n}\n\nstatic void build_smp_cmd(u32 deviceID, __le32 hTag, struct smp_req *psmp_cmd)\n{\n\tpsmp_cmd->tag = hTag;\n\tpsmp_cmd->device_id = cpu_to_le32(deviceID);\n\tpsmp_cmd->len_ip_ir = cpu_to_le32(1|(1 << 1));\n}\n\n \nstatic int pm8001_chip_smp_req(struct pm8001_hba_info *pm8001_ha,\n\tstruct pm8001_ccb_info *ccb)\n{\n\tint elem, rc;\n\tstruct sas_task *task = ccb->task;\n\tstruct domain_device *dev = task->dev;\n\tstruct pm8001_device *pm8001_dev = dev->lldd_dev;\n\tstruct scatterlist *sg_req, *sg_resp;\n\tu32 req_len, resp_len;\n\tstruct smp_req smp_cmd;\n\tu32 opc;\n\n\tmemset(&smp_cmd, 0, sizeof(smp_cmd));\n\t \n\tsg_req = &task->smp_task.smp_req;\n\telem = dma_map_sg(pm8001_ha->dev, sg_req, 1, DMA_TO_DEVICE);\n\tif (!elem)\n\t\treturn -ENOMEM;\n\treq_len = sg_dma_len(sg_req);\n\n\tsg_resp = &task->smp_task.smp_resp;\n\telem = dma_map_sg(pm8001_ha->dev, sg_resp, 1, DMA_FROM_DEVICE);\n\tif (!elem) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tresp_len = sg_dma_len(sg_resp);\n\t \n\tif ((req_len & 0x3) || (resp_len & 0x3)) {\n\t\trc = -EINVAL;\n\t\tgoto err_out_2;\n\t}\n\n\topc = OPC_INB_SMP_REQUEST;\n\tsmp_cmd.tag = cpu_to_le32(ccb->ccb_tag);\n\tsmp_cmd.long_smp_req.long_req_addr =\n\t\tcpu_to_le64((u64)sg_dma_address(&task->smp_task.smp_req));\n\tsmp_cmd.long_smp_req.long_req_size =\n\t\tcpu_to_le32((u32)sg_dma_len(&task->smp_task.smp_req)-4);\n\tsmp_cmd.long_smp_req.long_resp_addr =\n\t\tcpu_to_le64((u64)sg_dma_address(&task->smp_task.smp_resp));\n\tsmp_cmd.long_smp_req.long_resp_size =\n\t\tcpu_to_le32((u32)sg_dma_len(&task->smp_task.smp_resp)-4);\n\tbuild_smp_cmd(pm8001_dev->device_id, smp_cmd.tag, &smp_cmd);\n\trc = pm8001_mpi_build_cmd(pm8001_ha, 0, opc,\n\t\t\t\t  &smp_cmd, sizeof(smp_cmd), 0);\n\tif (rc)\n\t\tgoto err_out_2;\n\n\treturn 0;\n\nerr_out_2:\n\tdma_unmap_sg(pm8001_ha->dev, &ccb->task->smp_task.smp_resp, 1,\n\t\t\tDMA_FROM_DEVICE);\nerr_out:\n\tdma_unmap_sg(pm8001_ha->dev, &ccb->task->smp_task.smp_req, 1,\n\t\t\tDMA_TO_DEVICE);\n\treturn rc;\n}\n\n \nstatic int pm8001_chip_ssp_io_req(struct pm8001_hba_info *pm8001_ha,\n\tstruct pm8001_ccb_info *ccb)\n{\n\tstruct sas_task *task = ccb->task;\n\tstruct domain_device *dev = task->dev;\n\tstruct pm8001_device *pm8001_dev = dev->lldd_dev;\n\tstruct ssp_ini_io_start_req ssp_cmd;\n\tu32 tag = ccb->ccb_tag;\n\tu64 phys_addr;\n\tu32 opc = OPC_INB_SSPINIIOSTART;\n\tmemset(&ssp_cmd, 0, sizeof(ssp_cmd));\n\tmemcpy(ssp_cmd.ssp_iu.lun, task->ssp_task.LUN, 8);\n\tssp_cmd.dir_m_tlr =\n\t\tcpu_to_le32(data_dir_flags[task->data_dir] << 8 | 0x0); \n\tssp_cmd.data_len = cpu_to_le32(task->total_xfer_len);\n\tssp_cmd.device_id = cpu_to_le32(pm8001_dev->device_id);\n\tssp_cmd.tag = cpu_to_le32(tag);\n\tssp_cmd.ssp_iu.efb_prio_attr |= (task->ssp_task.task_attr & 7);\n\tmemcpy(ssp_cmd.ssp_iu.cdb, task->ssp_task.cmd->cmnd,\n\t       task->ssp_task.cmd->cmd_len);\n\n\t \n\tif (task->num_scatter > 1) {\n\t\tpm8001_chip_make_sg(task->scatter, ccb->n_elem, ccb->buf_prd);\n\t\tphys_addr = ccb->ccb_dma_handle;\n\t\tssp_cmd.addr_low = cpu_to_le32(lower_32_bits(phys_addr));\n\t\tssp_cmd.addr_high = cpu_to_le32(upper_32_bits(phys_addr));\n\t\tssp_cmd.esgl = cpu_to_le32(1<<31);\n\t} else if (task->num_scatter == 1) {\n\t\tu64 dma_addr = sg_dma_address(task->scatter);\n\t\tssp_cmd.addr_low = cpu_to_le32(lower_32_bits(dma_addr));\n\t\tssp_cmd.addr_high = cpu_to_le32(upper_32_bits(dma_addr));\n\t\tssp_cmd.len = cpu_to_le32(task->total_xfer_len);\n\t\tssp_cmd.esgl = 0;\n\t} else if (task->num_scatter == 0) {\n\t\tssp_cmd.addr_low = 0;\n\t\tssp_cmd.addr_high = 0;\n\t\tssp_cmd.len = cpu_to_le32(task->total_xfer_len);\n\t\tssp_cmd.esgl = 0;\n\t}\n\n\treturn pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &ssp_cmd,\n\t\t\t\t    sizeof(ssp_cmd), 0);\n}\n\nstatic int pm8001_chip_sata_req(struct pm8001_hba_info *pm8001_ha,\n\tstruct pm8001_ccb_info *ccb)\n{\n\tstruct sas_task *task = ccb->task;\n\tstruct domain_device *dev = task->dev;\n\tstruct pm8001_device *pm8001_ha_dev = dev->lldd_dev;\n\tu32 tag = ccb->ccb_tag;\n\tstruct sata_start_req sata_cmd;\n\tu32 hdr_tag, ncg_tag = 0;\n\tu64 phys_addr;\n\tu32 ATAP = 0x0;\n\tu32 dir, retfis = 0;\n\tu32  opc = OPC_INB_SATA_HOST_OPSTART;\n\n\tmemset(&sata_cmd, 0, sizeof(sata_cmd));\n\n\tif (task->data_dir == DMA_NONE && !task->ata_task.use_ncq) {\n\t\tATAP = 0x04;   \n\t\tpm8001_dbg(pm8001_ha, IO, \"no data\\n\");\n\t} else if (likely(!task->ata_task.device_control_reg_update)) {\n\t\tif (task->ata_task.use_ncq &&\n\t\t    dev->sata_dev.class != ATA_DEV_ATAPI) {\n\t\t\tATAP = 0x07;  \n\t\t\tpm8001_dbg(pm8001_ha, IO, \"FPDMA\\n\");\n\t\t} else if (task->ata_task.dma_xfer) {\n\t\t\tATAP = 0x06;  \n\t\t\tpm8001_dbg(pm8001_ha, IO, \"DMA\\n\");\n\t\t} else {\n\t\t\tATAP = 0x05;  \n\t\t\tpm8001_dbg(pm8001_ha, IO, \"PIO\\n\");\n\t\t}\n\t}\n\tif (task->ata_task.use_ncq && pm8001_get_ncq_tag(task, &hdr_tag)) {\n\t\ttask->ata_task.fis.sector_count |= (u8) (hdr_tag << 3);\n\t\tncg_tag = hdr_tag;\n\t}\n\tdir = data_dir_flags[task->data_dir] << 8;\n\tsata_cmd.tag = cpu_to_le32(tag);\n\tsata_cmd.device_id = cpu_to_le32(pm8001_ha_dev->device_id);\n\tsata_cmd.data_len = cpu_to_le32(task->total_xfer_len);\n\tif (task->ata_task.return_fis_on_success)\n\t\tretfis = 1;\n\tsata_cmd.retfis_ncqtag_atap_dir_m =\n\t\tcpu_to_le32((retfis << 24) | ((ncg_tag & 0xff) << 16) |\n\t\t\t    ((ATAP & 0x3f) << 10) | dir);\n\tsata_cmd.sata_fis = task->ata_task.fis;\n\tif (likely(!task->ata_task.device_control_reg_update))\n\t\tsata_cmd.sata_fis.flags |= 0x80; \n\tsata_cmd.sata_fis.flags &= 0xF0; \n\t \n\tif (task->num_scatter > 1) {\n\t\tpm8001_chip_make_sg(task->scatter, ccb->n_elem, ccb->buf_prd);\n\t\tphys_addr = ccb->ccb_dma_handle;\n\t\tsata_cmd.addr_low = lower_32_bits(phys_addr);\n\t\tsata_cmd.addr_high = upper_32_bits(phys_addr);\n\t\tsata_cmd.esgl = cpu_to_le32(1 << 31);\n\t} else if (task->num_scatter == 1) {\n\t\tu64 dma_addr = sg_dma_address(task->scatter);\n\t\tsata_cmd.addr_low = lower_32_bits(dma_addr);\n\t\tsata_cmd.addr_high = upper_32_bits(dma_addr);\n\t\tsata_cmd.len = cpu_to_le32(task->total_xfer_len);\n\t\tsata_cmd.esgl = 0;\n\t} else if (task->num_scatter == 0) {\n\t\tsata_cmd.addr_low = 0;\n\t\tsata_cmd.addr_high = 0;\n\t\tsata_cmd.len = cpu_to_le32(task->total_xfer_len);\n\t\tsata_cmd.esgl = 0;\n\t}\n\n\treturn pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &sata_cmd,\n\t\t\t\t    sizeof(sata_cmd), 0);\n}\n\n \nstatic int\npm8001_chip_phy_start_req(struct pm8001_hba_info *pm8001_ha, u8 phy_id)\n{\n\tstruct phy_start_req payload;\n\tu32 tag = 0x01;\n\tu32 opcode = OPC_INB_PHYSTART;\n\n\tmemset(&payload, 0, sizeof(payload));\n\tpayload.tag = cpu_to_le32(tag);\n\t \n\tpayload.ase_sh_lm_slr_phyid = cpu_to_le32(SPINHOLD_DISABLE |\n\t\tLINKMODE_AUTO |\tLINKRATE_15 |\n\t\tLINKRATE_30 | LINKRATE_60 | phy_id);\n\tpayload.sas_identify.dev_type = SAS_END_DEVICE;\n\tpayload.sas_identify.initiator_bits = SAS_PROTOCOL_ALL;\n\tmemcpy(payload.sas_identify.sas_addr,\n\t\t&pm8001_ha->phy[phy_id].dev_sas_addr, SAS_ADDR_SIZE);\n\tpayload.sas_identify.phy_id = phy_id;\n\n\treturn pm8001_mpi_build_cmd(pm8001_ha, 0, opcode, &payload,\n\t\t\t\t    sizeof(payload), 0);\n}\n\n \nstatic int pm8001_chip_phy_stop_req(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t    u8 phy_id)\n{\n\tstruct phy_stop_req payload;\n\tu32 tag = 0x01;\n\tu32 opcode = OPC_INB_PHYSTOP;\n\n\tmemset(&payload, 0, sizeof(payload));\n\tpayload.tag = cpu_to_le32(tag);\n\tpayload.phy_id = cpu_to_le32(phy_id);\n\n\treturn pm8001_mpi_build_cmd(pm8001_ha, 0, opcode, &payload,\n\t\t\t\t    sizeof(payload), 0);\n}\n\n \nstatic int pm8001_chip_reg_dev_req(struct pm8001_hba_info *pm8001_ha,\n\tstruct pm8001_device *pm8001_dev, u32 flag)\n{\n\tstruct reg_dev_req payload;\n\tu32\topc;\n\tu32 stp_sspsmp_sata = 0x4;\n\tu32 linkrate, phy_id;\n\tint rc;\n\tstruct pm8001_ccb_info *ccb;\n\tu8 retryFlag = 0x1;\n\tu16 firstBurstSize = 0;\n\tu16 ITNT = 2000;\n\tstruct domain_device *dev = pm8001_dev->sas_device;\n\tstruct domain_device *parent_dev = dev->parent;\n\tstruct pm8001_port *port = dev->port->lldd_port;\n\n\tmemset(&payload, 0, sizeof(payload));\n\tccb = pm8001_ccb_alloc(pm8001_ha, pm8001_dev, NULL);\n\tif (!ccb)\n\t\treturn -SAS_QUEUE_FULL;\n\n\tpayload.tag = cpu_to_le32(ccb->ccb_tag);\n\tif (flag == 1)\n\t\tstp_sspsmp_sata = 0x02;  \n\telse {\n\t\tif (pm8001_dev->dev_type == SAS_SATA_DEV)\n\t\t\tstp_sspsmp_sata = 0x00;  \n\t\telse if (pm8001_dev->dev_type == SAS_END_DEVICE ||\n\t\t\tdev_is_expander(pm8001_dev->dev_type))\n\t\t\tstp_sspsmp_sata = 0x01;  \n\t}\n\tif (parent_dev && dev_is_expander(parent_dev->dev_type))\n\t\tphy_id = parent_dev->ex_dev.ex_phy->phy_id;\n\telse\n\t\tphy_id = pm8001_dev->attached_phy;\n\topc = OPC_INB_REG_DEV;\n\tlinkrate = (pm8001_dev->sas_device->linkrate < dev->port->linkrate) ?\n\t\t\tpm8001_dev->sas_device->linkrate : dev->port->linkrate;\n\tpayload.phyid_portid =\n\t\tcpu_to_le32(((port->port_id) & 0x0F) |\n\t\t((phy_id & 0x0F) << 4));\n\tpayload.dtype_dlr_retry = cpu_to_le32((retryFlag & 0x01) |\n\t\t((linkrate & 0x0F) * 0x1000000) |\n\t\t((stp_sspsmp_sata & 0x03) * 0x10000000));\n\tpayload.firstburstsize_ITNexustimeout =\n\t\tcpu_to_le32(ITNT | (firstBurstSize * 0x10000));\n\tmemcpy(payload.sas_addr, pm8001_dev->sas_device->sas_addr,\n\t\tSAS_ADDR_SIZE);\n\n\trc = pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &payload,\n\t\t\t\t  sizeof(payload), 0);\n\tif (rc)\n\t\tpm8001_ccb_free(pm8001_ha, ccb);\n\n\treturn rc;\n}\n\n \nint pm8001_chip_dereg_dev_req(struct pm8001_hba_info *pm8001_ha,\n\tu32 device_id)\n{\n\tstruct dereg_dev_req payload;\n\tu32 opc = OPC_INB_DEREG_DEV_HANDLE;\n\n\tmemset(&payload, 0, sizeof(payload));\n\tpayload.tag = cpu_to_le32(1);\n\tpayload.device_id = cpu_to_le32(device_id);\n\tpm8001_dbg(pm8001_ha, INIT, \"unregister device device_id %d\\n\",\n\t\t   device_id);\n\n\treturn pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &payload,\n\t\t\t\t    sizeof(payload), 0);\n}\n\n \nstatic int pm8001_chip_phy_ctl_req(struct pm8001_hba_info *pm8001_ha,\n\tu32 phyId, u32 phy_op)\n{\n\tstruct local_phy_ctl_req payload;\n\tu32 opc = OPC_INB_LOCAL_PHY_CONTROL;\n\n\tmemset(&payload, 0, sizeof(payload));\n\tpayload.tag = cpu_to_le32(1);\n\tpayload.phyop_phyid =\n\t\tcpu_to_le32(((phy_op & 0xff) << 8) | (phyId & 0x0F));\n\n\treturn pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &payload,\n\t\t\t\t    sizeof(payload), 0);\n}\n\nstatic u32 pm8001_chip_is_our_interrupt(struct pm8001_hba_info *pm8001_ha)\n{\n#ifdef PM8001_USE_MSIX\n\treturn 1;\n#else\n\tu32 value;\n\n\tvalue = pm8001_cr32(pm8001_ha, 0, MSGU_ODR);\n\tif (value)\n\t\treturn 1;\n\treturn 0;\n#endif\n}\n\n \nstatic irqreturn_t\npm8001_chip_isr(struct pm8001_hba_info *pm8001_ha, u8 vec)\n{\n\tpm8001_chip_interrupt_disable(pm8001_ha, vec);\n\tpm8001_dbg(pm8001_ha, DEVIO,\n\t\t   \"irq vec %d, ODMR:0x%x\\n\",\n\t\t   vec, pm8001_cr32(pm8001_ha, 0, 0x30));\n\tprocess_oq(pm8001_ha, vec);\n\tpm8001_chip_interrupt_enable(pm8001_ha, vec);\n\treturn IRQ_HANDLED;\n}\n\nstatic int send_task_abort(struct pm8001_hba_info *pm8001_ha, u32 opc,\n\tu32 dev_id, enum sas_internal_abort type, u32 task_tag, u32 cmd_tag)\n{\n\tstruct task_abort_req task_abort;\n\n\tmemset(&task_abort, 0, sizeof(task_abort));\n\tif (type == SAS_INTERNAL_ABORT_SINGLE) {\n\t\ttask_abort.abort_all = 0;\n\t\ttask_abort.device_id = cpu_to_le32(dev_id);\n\t\ttask_abort.tag_to_abort = cpu_to_le32(task_tag);\n\t} else if (type == SAS_INTERNAL_ABORT_DEV) {\n\t\ttask_abort.abort_all = cpu_to_le32(1);\n\t\ttask_abort.device_id = cpu_to_le32(dev_id);\n\t} else {\n\t\tpm8001_dbg(pm8001_ha, EH, \"unknown type (%d)\\n\", type);\n\t\treturn -EIO;\n\t}\n\n\ttask_abort.tag = cpu_to_le32(cmd_tag);\n\n\treturn pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &task_abort,\n\t\t\t\t    sizeof(task_abort), 0);\n}\n\n \nint pm8001_chip_abort_task(struct pm8001_hba_info *pm8001_ha,\n\tstruct pm8001_ccb_info *ccb)\n{\n\tstruct sas_task *task = ccb->task;\n\tstruct sas_internal_abort_task *abort = &task->abort_task;\n\tstruct pm8001_device *pm8001_dev = ccb->device;\n\tint rc = TMF_RESP_FUNC_FAILED;\n\tu32 opc, device_id;\n\n\tpm8001_dbg(pm8001_ha, EH, \"cmd_tag = %x, abort task tag = 0x%x\\n\",\n\t\t   ccb->ccb_tag, abort->tag);\n\tif (pm8001_dev->dev_type == SAS_END_DEVICE)\n\t\topc = OPC_INB_SSP_ABORT;\n\telse if (pm8001_dev->dev_type == SAS_SATA_DEV)\n\t\topc = OPC_INB_SATA_ABORT;\n\telse\n\t\topc = OPC_INB_SMP_ABORT; \n\tdevice_id = pm8001_dev->device_id;\n\trc = send_task_abort(pm8001_ha, opc, device_id, abort->type,\n\t\t\t     abort->tag, ccb->ccb_tag);\n\tif (rc != TMF_RESP_FUNC_COMPLETE)\n\t\tpm8001_dbg(pm8001_ha, EH, \"rc= %d\\n\", rc);\n\treturn rc;\n}\n\n \nint pm8001_chip_ssp_tm_req(struct pm8001_hba_info *pm8001_ha,\n\tstruct pm8001_ccb_info *ccb, struct sas_tmf_task *tmf)\n{\n\tstruct sas_task *task = ccb->task;\n\tstruct domain_device *dev = task->dev;\n\tstruct pm8001_device *pm8001_dev = dev->lldd_dev;\n\tu32 opc = OPC_INB_SSPINITMSTART;\n\tstruct ssp_ini_tm_start_req sspTMCmd;\n\n\tmemset(&sspTMCmd, 0, sizeof(sspTMCmd));\n\tsspTMCmd.device_id = cpu_to_le32(pm8001_dev->device_id);\n\tsspTMCmd.relate_tag = cpu_to_le32((u32)tmf->tag_of_task_to_be_managed);\n\tsspTMCmd.tmf = cpu_to_le32(tmf->tmf);\n\tmemcpy(sspTMCmd.lun, task->ssp_task.LUN, 8);\n\tsspTMCmd.tag = cpu_to_le32(ccb->ccb_tag);\n\tif (pm8001_ha->chip_id != chip_8001)\n\t\tsspTMCmd.ds_ads_m = cpu_to_le32(0x08);\n\n\treturn pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &sspTMCmd,\n\t\t\t\t    sizeof(sspTMCmd), 0);\n}\n\nint pm8001_chip_get_nvmd_req(struct pm8001_hba_info *pm8001_ha,\n\tvoid *payload)\n{\n\tu32 opc = OPC_INB_GET_NVMD_DATA;\n\tu32 nvmd_type;\n\tint rc;\n\tstruct pm8001_ccb_info *ccb;\n\tstruct get_nvm_data_req nvmd_req;\n\tstruct fw_control_ex *fw_control_context;\n\tstruct pm8001_ioctl_payload *ioctl_payload = payload;\n\n\tnvmd_type = ioctl_payload->minor_function;\n\tfw_control_context = kzalloc(sizeof(struct fw_control_ex), GFP_KERNEL);\n\tif (!fw_control_context)\n\t\treturn -ENOMEM;\n\tfw_control_context->usrAddr = (u8 *)ioctl_payload->func_specific;\n\tfw_control_context->len = ioctl_payload->rd_length;\n\tmemset(&nvmd_req, 0, sizeof(nvmd_req));\n\n\tccb = pm8001_ccb_alloc(pm8001_ha, NULL, NULL);\n\tif (!ccb) {\n\t\tkfree(fw_control_context);\n\t\treturn -SAS_QUEUE_FULL;\n\t}\n\tccb->fw_control_context = fw_control_context;\n\n\tnvmd_req.tag = cpu_to_le32(ccb->ccb_tag);\n\n\tswitch (nvmd_type) {\n\tcase TWI_DEVICE: {\n\t\tu32 twi_addr, twi_page_size;\n\t\ttwi_addr = 0xa8;\n\t\ttwi_page_size = 2;\n\n\t\tnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | twi_addr << 16 |\n\t\t\ttwi_page_size << 8 | TWI_DEVICE);\n\t\tnvmd_req.resp_len = cpu_to_le32(ioctl_payload->rd_length);\n\t\tnvmd_req.resp_addr_hi =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\n\t\tnvmd_req.resp_addr_lo =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\n\t\tbreak;\n\t}\n\tcase C_SEEPROM: {\n\t\tnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | C_SEEPROM);\n\t\tnvmd_req.resp_len = cpu_to_le32(ioctl_payload->rd_length);\n\t\tnvmd_req.resp_addr_hi =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\n\t\tnvmd_req.resp_addr_lo =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\n\t\tbreak;\n\t}\n\tcase VPD_FLASH: {\n\t\tnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | VPD_FLASH);\n\t\tnvmd_req.resp_len = cpu_to_le32(ioctl_payload->rd_length);\n\t\tnvmd_req.resp_addr_hi =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\n\t\tnvmd_req.resp_addr_lo =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\n\t\tbreak;\n\t}\n\tcase EXPAN_ROM: {\n\t\tnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | EXPAN_ROM);\n\t\tnvmd_req.resp_len = cpu_to_le32(ioctl_payload->rd_length);\n\t\tnvmd_req.resp_addr_hi =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\n\t\tnvmd_req.resp_addr_lo =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\n\t\tbreak;\n\t}\n\tcase IOP_RDUMP: {\n\t\tnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | IOP_RDUMP);\n\t\tnvmd_req.resp_len = cpu_to_le32(ioctl_payload->rd_length);\n\t\tnvmd_req.vpd_offset = cpu_to_le32(ioctl_payload->offset);\n\t\tnvmd_req.resp_addr_hi =\n\t\tcpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\n\t\tnvmd_req.resp_addr_lo =\n\t\tcpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\trc = pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &nvmd_req,\n\t\t\t\t  sizeof(nvmd_req), 0);\n\tif (rc) {\n\t\tkfree(fw_control_context);\n\t\tpm8001_ccb_free(pm8001_ha, ccb);\n\t}\n\treturn rc;\n}\n\nint pm8001_chip_set_nvmd_req(struct pm8001_hba_info *pm8001_ha,\n\tvoid *payload)\n{\n\tu32 opc = OPC_INB_SET_NVMD_DATA;\n\tu32 nvmd_type;\n\tint rc;\n\tstruct pm8001_ccb_info *ccb;\n\tstruct set_nvm_data_req nvmd_req;\n\tstruct fw_control_ex *fw_control_context;\n\tstruct pm8001_ioctl_payload *ioctl_payload = payload;\n\n\tnvmd_type = ioctl_payload->minor_function;\n\tfw_control_context = kzalloc(sizeof(struct fw_control_ex), GFP_KERNEL);\n\tif (!fw_control_context)\n\t\treturn -ENOMEM;\n\n\tmemcpy(pm8001_ha->memoryMap.region[NVMD].virt_ptr,\n\t\t&ioctl_payload->func_specific,\n\t\tioctl_payload->wr_length);\n\tmemset(&nvmd_req, 0, sizeof(nvmd_req));\n\n\tccb = pm8001_ccb_alloc(pm8001_ha, NULL, NULL);\n\tif (!ccb) {\n\t\tkfree(fw_control_context);\n\t\treturn -SAS_QUEUE_FULL;\n\t}\n\tccb->fw_control_context = fw_control_context;\n\n\tnvmd_req.tag = cpu_to_le32(ccb->ccb_tag);\n\tswitch (nvmd_type) {\n\tcase TWI_DEVICE: {\n\t\tu32 twi_addr, twi_page_size;\n\t\ttwi_addr = 0xa8;\n\t\ttwi_page_size = 2;\n\t\tnvmd_req.reserved[0] = cpu_to_le32(0xFEDCBA98);\n\t\tnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | twi_addr << 16 |\n\t\t\ttwi_page_size << 8 | TWI_DEVICE);\n\t\tnvmd_req.resp_len = cpu_to_le32(ioctl_payload->wr_length);\n\t\tnvmd_req.resp_addr_hi =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\n\t\tnvmd_req.resp_addr_lo =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\n\t\tbreak;\n\t}\n\tcase C_SEEPROM:\n\t\tnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | C_SEEPROM);\n\t\tnvmd_req.resp_len = cpu_to_le32(ioctl_payload->wr_length);\n\t\tnvmd_req.reserved[0] = cpu_to_le32(0xFEDCBA98);\n\t\tnvmd_req.resp_addr_hi =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\n\t\tnvmd_req.resp_addr_lo =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\n\t\tbreak;\n\tcase VPD_FLASH:\n\t\tnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | VPD_FLASH);\n\t\tnvmd_req.resp_len = cpu_to_le32(ioctl_payload->wr_length);\n\t\tnvmd_req.reserved[0] = cpu_to_le32(0xFEDCBA98);\n\t\tnvmd_req.resp_addr_hi =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\n\t\tnvmd_req.resp_addr_lo =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\n\t\tbreak;\n\tcase EXPAN_ROM:\n\t\tnvmd_req.len_ir_vpdd = cpu_to_le32(IPMode | EXPAN_ROM);\n\t\tnvmd_req.resp_len = cpu_to_le32(ioctl_payload->wr_length);\n\t\tnvmd_req.reserved[0] = cpu_to_le32(0xFEDCBA98);\n\t\tnvmd_req.resp_addr_hi =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_hi);\n\t\tnvmd_req.resp_addr_lo =\n\t\t    cpu_to_le32(pm8001_ha->memoryMap.region[NVMD].phys_addr_lo);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\trc = pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &nvmd_req,\n\t\t\tsizeof(nvmd_req), 0);\n\tif (rc) {\n\t\tkfree(fw_control_context);\n\t\tpm8001_ccb_free(pm8001_ha, ccb);\n\t}\n\treturn rc;\n}\n\n \nint\npm8001_chip_fw_flash_update_build(struct pm8001_hba_info *pm8001_ha,\n\tvoid *fw_flash_updata_info, u32 tag)\n{\n\tstruct fw_flash_Update_req payload;\n\tstruct fw_flash_updata_info *info;\n\tu32 opc = OPC_INB_FW_FLASH_UPDATE;\n\n\tmemset(&payload, 0, sizeof(struct fw_flash_Update_req));\n\tinfo = fw_flash_updata_info;\n\tpayload.tag = cpu_to_le32(tag);\n\tpayload.cur_image_len = cpu_to_le32(info->cur_image_len);\n\tpayload.cur_image_offset = cpu_to_le32(info->cur_image_offset);\n\tpayload.total_image_len = cpu_to_le32(info->total_image_len);\n\tpayload.len = info->sgl.im_len.len ;\n\tpayload.sgl_addr_lo =\n\t\tcpu_to_le32(lower_32_bits(le64_to_cpu(info->sgl.addr)));\n\tpayload.sgl_addr_hi =\n\t\tcpu_to_le32(upper_32_bits(le64_to_cpu(info->sgl.addr)));\n\n\treturn pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &payload,\n\t\t\t\t    sizeof(payload), 0);\n}\n\nint\npm8001_chip_fw_flash_update_req(struct pm8001_hba_info *pm8001_ha,\n\tvoid *payload)\n{\n\tstruct fw_flash_updata_info flash_update_info;\n\tstruct fw_control_info *fw_control;\n\tstruct fw_control_ex *fw_control_context;\n\tint rc;\n\tstruct pm8001_ccb_info *ccb;\n\tvoid *buffer = pm8001_ha->memoryMap.region[FW_FLASH].virt_ptr;\n\tdma_addr_t phys_addr = pm8001_ha->memoryMap.region[FW_FLASH].phys_addr;\n\tstruct pm8001_ioctl_payload *ioctl_payload = payload;\n\n\tfw_control_context = kzalloc(sizeof(struct fw_control_ex), GFP_KERNEL);\n\tif (!fw_control_context)\n\t\treturn -ENOMEM;\n\tfw_control = (struct fw_control_info *)&ioctl_payload->func_specific;\n\tpm8001_dbg(pm8001_ha, DEVIO,\n\t\t   \"dma fw_control context input length :%x\\n\",\n\t\t   fw_control->len);\n\tmemcpy(buffer, fw_control->buffer, fw_control->len);\n\tflash_update_info.sgl.addr = cpu_to_le64(phys_addr);\n\tflash_update_info.sgl.im_len.len = cpu_to_le32(fw_control->len);\n\tflash_update_info.sgl.im_len.e = 0;\n\tflash_update_info.cur_image_offset = fw_control->offset;\n\tflash_update_info.cur_image_len = fw_control->len;\n\tflash_update_info.total_image_len = fw_control->size;\n\tfw_control_context->fw_control = fw_control;\n\tfw_control_context->virtAddr = buffer;\n\tfw_control_context->phys_addr = phys_addr;\n\tfw_control_context->len = fw_control->len;\n\n\tccb = pm8001_ccb_alloc(pm8001_ha, NULL, NULL);\n\tif (!ccb) {\n\t\tkfree(fw_control_context);\n\t\treturn -SAS_QUEUE_FULL;\n\t}\n\tccb->fw_control_context = fw_control_context;\n\n\trc = pm8001_chip_fw_flash_update_build(pm8001_ha, &flash_update_info,\n\t\t\t\t\t       ccb->ccb_tag);\n\tif (rc) {\n\t\tkfree(fw_control_context);\n\t\tpm8001_ccb_free(pm8001_ha, ccb);\n\t}\n\n\treturn rc;\n}\n\nssize_t\npm8001_get_gsm_dump(struct device *cdev, u32 length, char *buf)\n{\n\tu32 value, rem, offset = 0, bar = 0;\n\tu32 index, work_offset, dw_length;\n\tu32 shift_value, gsm_base, gsm_dump_offset;\n\tchar *direct_data;\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\n\tdirect_data = buf;\n\tgsm_dump_offset = pm8001_ha->fatal_forensic_shift_offset;\n\n\t \n\tif ((length > 0x100000) || (gsm_dump_offset & 3) ||\n\t\t((gsm_dump_offset + length) > 0x1000000))\n\t\t\treturn -EINVAL;\n\n\tif (pm8001_ha->chip_id == chip_8001)\n\t\tbar = 2;\n\telse\n\t\tbar = 1;\n\n\twork_offset = gsm_dump_offset & 0xFFFF0000;\n\toffset = gsm_dump_offset & 0x0000FFFF;\n\tgsm_dump_offset = work_offset;\n\t \n\trem = length & 3;\n\tdw_length = length >> 2;\n\n\tfor (index = 0; index < dw_length; index++) {\n\t\tif ((work_offset + offset) & 0xFFFF0000) {\n\t\t\tif (pm8001_ha->chip_id == chip_8001)\n\t\t\t\tshift_value = ((gsm_dump_offset + offset) &\n\t\t\t\t\t\tSHIFT_REG_64K_MASK);\n\t\t\telse\n\t\t\t\tshift_value = (((gsm_dump_offset + offset) &\n\t\t\t\t\t\tSHIFT_REG_64K_MASK) >>\n\t\t\t\t\t\tSHIFT_REG_BIT_SHIFT);\n\n\t\t\tif (pm8001_ha->chip_id == chip_8001) {\n\t\t\t\tgsm_base = GSM_BASE;\n\t\t\t\tif (-1 == pm8001_bar4_shift(pm8001_ha,\n\t\t\t\t\t\t(gsm_base + shift_value)))\n\t\t\t\t\treturn -EIO;\n\t\t\t} else {\n\t\t\t\tgsm_base = 0;\n\t\t\t\tif (-1 == pm80xx_bar4_shift(pm8001_ha,\n\t\t\t\t\t\t(gsm_base + shift_value)))\n\t\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tgsm_dump_offset = (gsm_dump_offset + offset) &\n\t\t\t\t\t\t0xFFFF0000;\n\t\t\twork_offset = 0;\n\t\t\toffset = offset & 0x0000FFFF;\n\t\t}\n\t\tvalue = pm8001_cr32(pm8001_ha, bar, (work_offset + offset) &\n\t\t\t\t\t\t0x0000FFFF);\n\t\tdirect_data += sprintf(direct_data, \"%08x \", value);\n\t\toffset += 4;\n\t}\n\tif (rem != 0) {\n\t\tvalue = pm8001_cr32(pm8001_ha, bar, (work_offset + offset) &\n\t\t\t\t\t\t0x0000FFFF);\n\t\t \n\t\tdirect_data += sprintf(direct_data, \"%08x \", value);\n\t}\n\t \n\tif (-1 == pm8001_bar4_shift(pm8001_ha, 0))\n\t\t\treturn -EIO;\n\tpm8001_ha->fatal_forensic_shift_offset += 1024;\n\n\tif (pm8001_ha->fatal_forensic_shift_offset >= 0x100000)\n\t\tpm8001_ha->fatal_forensic_shift_offset = 0;\n\treturn direct_data - buf;\n}\n\nint\npm8001_chip_set_dev_state_req(struct pm8001_hba_info *pm8001_ha,\n\tstruct pm8001_device *pm8001_dev, u32 state)\n{\n\tstruct set_dev_state_req payload;\n\tstruct pm8001_ccb_info *ccb;\n\tint rc;\n\tu32 opc = OPC_INB_SET_DEVICE_STATE;\n\n\tmemset(&payload, 0, sizeof(payload));\n\n\tccb = pm8001_ccb_alloc(pm8001_ha, pm8001_dev, NULL);\n\tif (!ccb)\n\t\treturn -SAS_QUEUE_FULL;\n\n\tpayload.tag = cpu_to_le32(ccb->ccb_tag);\n\tpayload.device_id = cpu_to_le32(pm8001_dev->device_id);\n\tpayload.nds = cpu_to_le32(state);\n\n\trc = pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &payload,\n\t\t\t\t  sizeof(payload), 0);\n\tif (rc)\n\t\tpm8001_ccb_free(pm8001_ha, ccb);\n\n\treturn rc;\n}\n\nstatic int\npm8001_chip_sas_re_initialization(struct pm8001_hba_info *pm8001_ha)\n{\n\tstruct sas_re_initialization_req payload;\n\tstruct pm8001_ccb_info *ccb;\n\tint rc;\n\tu32 opc = OPC_INB_SAS_RE_INITIALIZE;\n\n\tmemset(&payload, 0, sizeof(payload));\n\n\tccb = pm8001_ccb_alloc(pm8001_ha, NULL, NULL);\n\tif (!ccb)\n\t\treturn -SAS_QUEUE_FULL;\n\n\tpayload.tag = cpu_to_le32(ccb->ccb_tag);\n\tpayload.SSAHOLT = cpu_to_le32(0xd << 25);\n\tpayload.sata_hol_tmo = cpu_to_le32(80);\n\tpayload.open_reject_cmdretries_data_retries = cpu_to_le32(0xff00ff);\n\n\trc = pm8001_mpi_build_cmd(pm8001_ha, 0, opc, &payload,\n\t\t\t\t  sizeof(payload), 0);\n\tif (rc)\n\t\tpm8001_ccb_free(pm8001_ha, ccb);\n\n\treturn rc;\n}\n\nconst struct pm8001_dispatch pm8001_8001_dispatch = {\n\t.name\t\t\t= \"pmc8001\",\n\t.chip_init\t\t= pm8001_chip_init,\n\t.chip_post_init\t\t= pm8001_chip_post_init,\n\t.chip_soft_rst\t\t= pm8001_chip_soft_rst,\n\t.chip_rst\t\t= pm8001_hw_chip_rst,\n\t.chip_iounmap\t\t= pm8001_chip_iounmap,\n\t.isr\t\t\t= pm8001_chip_isr,\n\t.is_our_interrupt\t= pm8001_chip_is_our_interrupt,\n\t.isr_process_oq\t\t= process_oq,\n\t.interrupt_enable \t= pm8001_chip_interrupt_enable,\n\t.interrupt_disable\t= pm8001_chip_interrupt_disable,\n\t.make_prd\t\t= pm8001_chip_make_sg,\n\t.smp_req\t\t= pm8001_chip_smp_req,\n\t.ssp_io_req\t\t= pm8001_chip_ssp_io_req,\n\t.sata_req\t\t= pm8001_chip_sata_req,\n\t.phy_start_req\t\t= pm8001_chip_phy_start_req,\n\t.phy_stop_req\t\t= pm8001_chip_phy_stop_req,\n\t.reg_dev_req\t\t= pm8001_chip_reg_dev_req,\n\t.dereg_dev_req\t\t= pm8001_chip_dereg_dev_req,\n\t.phy_ctl_req\t\t= pm8001_chip_phy_ctl_req,\n\t.task_abort\t\t= pm8001_chip_abort_task,\n\t.ssp_tm_req\t\t= pm8001_chip_ssp_tm_req,\n\t.get_nvmd_req\t\t= pm8001_chip_get_nvmd_req,\n\t.set_nvmd_req\t\t= pm8001_chip_set_nvmd_req,\n\t.fw_flash_update_req\t= pm8001_chip_fw_flash_update_req,\n\t.set_dev_state_req\t= pm8001_chip_set_dev_state_req,\n\t.sas_re_init_req\t= pm8001_chip_sas_re_initialization,\n\t.fatal_errors\t\t= pm80xx_fatal_errors,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}