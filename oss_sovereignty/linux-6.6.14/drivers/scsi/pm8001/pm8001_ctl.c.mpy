{
  "module_name": "pm8001_ctl.c",
  "hash_id": "c341674d49abeb55be12f1c1c255a2d629bac9338c908cdb4de813481b5bde43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/pm8001/pm8001_ctl.c",
  "human_readable_source": " \n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include \"pm8001_sas.h\"\n#include \"pm8001_ctl.h\"\n#include \"pm8001_chips.h\"\n\n \n\n \nstatic ssize_t pm8001_ctl_mpi_interface_rev_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\n\tif (pm8001_ha->chip_id == chip_8001) {\n\t\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.interface_rev);\n\t} else {\n\t\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.interface_rev);\n\t}\n}\nstatic\nDEVICE_ATTR(interface_rev, S_IRUGO, pm8001_ctl_mpi_interface_rev_show, NULL);\n\n \nstatic ssize_t controller_fatal_error_show(struct device *cdev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\tpm8001_ha->controller_fatal_error);\n}\nstatic DEVICE_ATTR_RO(controller_fatal_error);\n\n \nstatic ssize_t pm8001_ctl_fw_version_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\n\tif (pm8001_ha->chip_id == chip_8001) {\n\t\treturn sysfs_emit(buf, \"%02x.%02x.%02x.%02x\\n\",\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm8001_tbl.firmware_rev >> 24),\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm8001_tbl.firmware_rev >> 16),\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm8001_tbl.firmware_rev >> 8),\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm8001_tbl.firmware_rev));\n\t} else {\n\t\treturn sysfs_emit(buf, \"%02x.%02x.%02x.%02x\\n\",\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.firmware_rev >> 24),\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.firmware_rev >> 16),\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.firmware_rev >> 8),\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.firmware_rev));\n\t}\n}\nstatic DEVICE_ATTR(fw_version, S_IRUGO, pm8001_ctl_fw_version_show, NULL);\n\n \nstatic ssize_t pm8001_ctl_ila_version_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\n\tif (pm8001_ha->chip_id != chip_8001) {\n\t\treturn sysfs_emit(buf, \"%02x.%02x.%02x.%02x\\n\",\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.ila_version >> 24),\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.ila_version >> 16),\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.ila_version >> 8),\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.ila_version));\n\t}\n\treturn 0;\n}\nstatic DEVICE_ATTR(ila_version, 0444, pm8001_ctl_ila_version_show, NULL);\n\n \nstatic ssize_t pm8001_ctl_inactive_fw_version_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\n\tif (pm8001_ha->chip_id != chip_8001) {\n\t\treturn sysfs_emit(buf, \"%02x.%02x.%02x.%02x\\n\",\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.inc_fw_version >> 24),\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.inc_fw_version >> 16),\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.inc_fw_version >> 8),\n\t\t(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.inc_fw_version));\n\t}\n\treturn 0;\n}\nstatic\nDEVICE_ATTR(inc_fw_ver, 0444, pm8001_ctl_inactive_fw_version_show, NULL);\n\n \nstatic ssize_t pm8001_ctl_max_out_io_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\n\tif (pm8001_ha->chip_id == chip_8001) {\n\t\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.max_out_io);\n\t} else {\n\t\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.max_out_io);\n\t}\n}\nstatic DEVICE_ATTR(max_out_io, S_IRUGO, pm8001_ctl_max_out_io_show, NULL);\n \nstatic ssize_t pm8001_ctl_max_devices_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\n\tif (pm8001_ha->chip_id == chip_8001) {\n\t\treturn sysfs_emit(buf, \"%04d\\n\",\n\t\t\t(u16)(pm8001_ha->main_cfg_tbl.pm8001_tbl.max_sgl >> 16));\n\t} else {\n\t\treturn sysfs_emit(buf, \"%04d\\n\",\n\t\t\t(u16)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.max_sgl >> 16));\n\t}\n}\nstatic DEVICE_ATTR(max_devices, S_IRUGO, pm8001_ctl_max_devices_show, NULL);\n \nstatic ssize_t pm8001_ctl_max_sg_list_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\n\tif (pm8001_ha->chip_id == chip_8001) {\n\t\treturn sysfs_emit(buf, \"%04d\\n\",\n\t\t\tpm8001_ha->main_cfg_tbl.pm8001_tbl.max_sgl & 0x0000FFFF);\n\t} else {\n\t\treturn sysfs_emit(buf, \"%04d\\n\",\n\t\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.max_sgl & 0x0000FFFF);\n\t}\n}\nstatic DEVICE_ATTR(max_sg_list, S_IRUGO, pm8001_ctl_max_sg_list_show, NULL);\n\n#define SAS_1_0 0x1\n#define SAS_1_1 0x2\n#define SAS_2_0 0x4\n\nstatic ssize_t\nshow_sas_spec_support_status(unsigned int mode, char *buf)\n{\n\tssize_t len = 0;\n\n\tif (mode & SAS_1_1)\n\t\tlen = sprintf(buf, \"%s\", \"SAS1.1\");\n\tif (mode & SAS_2_0)\n\t\tlen += sprintf(buf + len, \"%s%s\", len ? \", \" : \"\", \"SAS2.0\");\n\tlen += sprintf(buf + len, \"\\n\");\n\n\treturn len;\n}\n\n \nstatic ssize_t pm8001_ctl_sas_spec_support_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tunsigned int mode;\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\t \n\tif (pm8001_ha->chip_id == chip_8001)\n\t\tmode = (pm8001_ha->main_cfg_tbl.pm8001_tbl.ctrl_cap_flag &\n\t\t\t\t\t\t\t0xfe000000)>>25;\n\telse\n\t\t \n\t\tmode = (pm8001_ha->main_cfg_tbl.pm80xx_tbl.ctrl_cap_flag &\n\t\t\t\t\t\t\t0xfe000000)>>25;\n\treturn show_sas_spec_support_status(mode, buf);\n}\nstatic DEVICE_ATTR(sas_spec_support, S_IRUGO,\n\t\t   pm8001_ctl_sas_spec_support_show, NULL);\n\n \nstatic ssize_t pm8001_ctl_host_sas_address_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\treturn sysfs_emit(buf, \"0x%016llx\\n\",\n\t\t\tbe64_to_cpu(*(__be64 *)pm8001_ha->sas_addr));\n}\nstatic DEVICE_ATTR(host_sas_address, S_IRUGO,\n\t\t   pm8001_ctl_host_sas_address_show, NULL);\n\n \nstatic ssize_t pm8001_ctl_logging_level_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\n\treturn sysfs_emit(buf, \"%08xh\\n\", pm8001_ha->logging_level);\n}\n\nstatic ssize_t pm8001_ctl_logging_level_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tint val = 0;\n\n\tif (sscanf(buf, \"%x\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tpm8001_ha->logging_level = val;\n\treturn strlen(buf);\n}\n\nstatic DEVICE_ATTR(logging_level, S_IRUGO | S_IWUSR,\n\tpm8001_ctl_logging_level_show, pm8001_ctl_logging_level_store);\n \nstatic ssize_t pm8001_ctl_aap_log_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tu8 *ptr = (u8 *)pm8001_ha->memoryMap.region[AAP1].virt_ptr;\n\tint i;\n\n\tchar *str = buf;\n\tint max = 2;\n\tfor (i = 0; i < max; i++) {\n\t\tstr += sprintf(str, \"0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\"\n\t\t\t       \"0x%08x 0x%08x\\n\",\n\t\t\t       pm8001_ctl_aap1_memmap(ptr, i, 0),\n\t\t\t       pm8001_ctl_aap1_memmap(ptr, i, 4),\n\t\t\t       pm8001_ctl_aap1_memmap(ptr, i, 8),\n\t\t\t       pm8001_ctl_aap1_memmap(ptr, i, 12),\n\t\t\t       pm8001_ctl_aap1_memmap(ptr, i, 16),\n\t\t\t       pm8001_ctl_aap1_memmap(ptr, i, 20),\n\t\t\t       pm8001_ctl_aap1_memmap(ptr, i, 24),\n\t\t\t       pm8001_ctl_aap1_memmap(ptr, i, 28));\n\t}\n\n\treturn str - buf;\n}\nstatic DEVICE_ATTR(aap_log, S_IRUGO, pm8001_ctl_aap_log_show, NULL);\n \nstatic ssize_t pm8001_ctl_ib_queue_log_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tint offset;\n\tchar *str = buf;\n\tint start = 0;\n\tu32 ib_offset = pm8001_ha->ib_offset;\n\tu32 queue_size = pm8001_ha->max_q_num * PM8001_MPI_QUEUE * 128;\n#define IB_MEMMAP(c)\t\\\n\t\t(*(u32 *)((u8 *)pm8001_ha->\t\\\n\t\tmemoryMap.region[ib_offset].virt_ptr +\t\\\n\t\tpm8001_ha->evtlog_ib_offset + (c)))\n\n\tfor (offset = 0; offset < IB_OB_READ_TIMES; offset++) {\n\t\tstr += sprintf(str, \"0x%08x\\n\", IB_MEMMAP(start));\n\t\tstart = start + 4;\n\t}\n\tpm8001_ha->evtlog_ib_offset += SYSFS_OFFSET;\n\tif (((pm8001_ha->evtlog_ib_offset) % queue_size) == 0)\n\t\tpm8001_ha->evtlog_ib_offset = 0;\n\n\treturn str - buf;\n}\n\nstatic DEVICE_ATTR(ib_log, S_IRUGO, pm8001_ctl_ib_queue_log_show, NULL);\n \n\nstatic ssize_t pm8001_ctl_ob_queue_log_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tint offset;\n\tchar *str = buf;\n\tint start = 0;\n\tu32 ob_offset = pm8001_ha->ob_offset;\n\tu32 queue_size = pm8001_ha->max_q_num * PM8001_MPI_QUEUE * 128;\n#define OB_MEMMAP(c)\t\\\n\t\t(*(u32 *)((u8 *)pm8001_ha->\t\\\n\t\tmemoryMap.region[ob_offset].virt_ptr +\t\\\n\t\tpm8001_ha->evtlog_ob_offset + (c)))\n\n\tfor (offset = 0; offset < IB_OB_READ_TIMES; offset++) {\n\t\tstr += sprintf(str, \"0x%08x\\n\", OB_MEMMAP(start));\n\t\tstart = start + 4;\n\t}\n\tpm8001_ha->evtlog_ob_offset += SYSFS_OFFSET;\n\tif (((pm8001_ha->evtlog_ob_offset) % queue_size) == 0)\n\t\tpm8001_ha->evtlog_ob_offset = 0;\n\n\treturn str - buf;\n}\nstatic DEVICE_ATTR(ob_log, S_IRUGO, pm8001_ctl_ob_queue_log_show, NULL);\n \nstatic ssize_t pm8001_ctl_bios_version_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tchar *str = buf;\n\tint bios_index;\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tstruct pm8001_ioctl_payload payload;\n\n\tpm8001_ha->nvmd_completion = &completion;\n\tpayload.minor_function = 7;\n\tpayload.offset = 0;\n\tpayload.rd_length = 4096;\n\tpayload.func_specific = kzalloc(4096, GFP_KERNEL);\n\tif (!payload.func_specific)\n\t\treturn -ENOMEM;\n\tif (PM8001_CHIP_DISP->get_nvmd_req(pm8001_ha, &payload)) {\n\t\tkfree(payload.func_specific);\n\t\treturn -ENOMEM;\n\t}\n\twait_for_completion(&completion);\n\tfor (bios_index = BIOSOFFSET; bios_index < BIOS_OFFSET_LIMIT;\n\t\tbios_index++)\n\t\tstr += sprintf(str, \"%c\",\n\t\t\t*(payload.func_specific+bios_index));\n\tkfree(payload.func_specific);\n\treturn str - buf;\n}\nstatic DEVICE_ATTR(bios_version, S_IRUGO, pm8001_ctl_bios_version_show, NULL);\n \nstatic ssize_t event_log_size_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.event_log_size);\n}\nstatic DEVICE_ATTR_RO(event_log_size);\n \nstatic ssize_t pm8001_ctl_iop_log_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tchar *str = buf;\n\tu32 read_size =\n\t\tpm8001_ha->main_cfg_tbl.pm80xx_tbl.event_log_size / 1024;\n\tstatic u32 start, end, count;\n\tu32 max_read_times = 32;\n\tu32 max_count = (read_size * 1024) / (max_read_times * 4);\n\tu32 *temp = (u32 *)pm8001_ha->memoryMap.region[IOP].virt_ptr;\n\n\tif ((count % max_count) == 0) {\n\t\tstart = 0;\n\t\tend = max_read_times;\n\t\tcount = 0;\n\t} else {\n\t\tstart = end;\n\t\tend = end + max_read_times;\n\t}\n\n\tfor (; start < end; start++)\n\t\tstr += sprintf(str, \"%08x \", *(temp+start));\n\tcount++;\n\treturn str - buf;\n}\nstatic DEVICE_ATTR(iop_log, S_IRUGO, pm8001_ctl_iop_log_show, NULL);\n\n \n\nstatic ssize_t pm8001_ctl_fatal_log_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tssize_t count;\n\n\tcount = pm80xx_get_fatal_dump(cdev, attr, buf);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(fatal_log, S_IRUGO, pm8001_ctl_fatal_log_show, NULL);\n\n \nstatic ssize_t non_fatal_log_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tu32 count;\n\n\tcount = pm80xx_get_non_fatal_dump(cdev, attr, buf);\n\treturn count;\n}\nstatic DEVICE_ATTR_RO(non_fatal_log);\n\nstatic ssize_t non_fatal_count_show(struct device *cdev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\n\treturn sysfs_emit(buf, \"%08x\\n\",\n\t\t\tpm8001_ha->non_fatal_count);\n}\n\nstatic ssize_t non_fatal_count_store(struct device *cdev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tint val = 0;\n\n\tif (kstrtoint(buf, 16, &val) != 0)\n\t\treturn -EINVAL;\n\n\tpm8001_ha->non_fatal_count = val;\n\treturn strlen(buf);\n}\nstatic DEVICE_ATTR_RW(non_fatal_count);\n\n \nstatic ssize_t pm8001_ctl_gsm_log_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tssize_t count;\n\n\tcount = pm8001_get_gsm_dump(cdev, SYSFS_OFFSET, buf);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(gsm_log, S_IRUGO, pm8001_ctl_gsm_log_show, NULL);\n\n#define FLASH_CMD_NONE      0x00\n#define FLASH_CMD_UPDATE    0x01\n#define FLASH_CMD_SET_NVMD    0x02\n\nstruct flash_command {\n     u8      command[8];\n     int     code;\n};\n\nstatic const struct flash_command flash_command_table[] = {\n     {\"set_nvmd\",    FLASH_CMD_SET_NVMD},\n     {\"update\",      FLASH_CMD_UPDATE},\n     {\"\",            FLASH_CMD_NONE}  \n};\n\nstruct error_fw {\n     char    *reason;\n     int     err_code;\n};\n\nstatic const struct error_fw flash_error_table[] = {\n     {\"Failed to open fw image file\",\tFAIL_OPEN_BIOS_FILE},\n     {\"image header mismatch\",\t\tFLASH_UPDATE_HDR_ERR},\n     {\"image offset mismatch\",\t\tFLASH_UPDATE_OFFSET_ERR},\n     {\"image CRC Error\",\t\tFLASH_UPDATE_CRC_ERR},\n     {\"image length Error.\",\t\tFLASH_UPDATE_LENGTH_ERR},\n     {\"Failed to program flash chip\",\tFLASH_UPDATE_HW_ERR},\n     {\"Flash chip not supported.\",\tFLASH_UPDATE_DNLD_NOT_SUPPORTED},\n     {\"Flash update disabled.\",\t\tFLASH_UPDATE_DISABLED},\n     {\"Flash in progress\",\t\tFLASH_IN_PROGRESS},\n     {\"Image file size Error\",\t\tFAIL_FILE_SIZE},\n     {\"Input parameter error\",\t\tFAIL_PARAMETERS},\n     {\"Out of memory\",\t\t\tFAIL_OUT_MEMORY},\n     {\"OK\", 0}\t \n};\n\nstatic int pm8001_set_nvmd(struct pm8001_hba_info *pm8001_ha)\n{\n\tstruct pm8001_ioctl_payload\t*payload;\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tu8\t\t*ioctlbuffer;\n\tu32\t\tret;\n\tu32\t\tlength = 1024 * 5 + sizeof(*payload) - 1;\n\n\tif (pm8001_ha->fw_image->size > 4096) {\n\t\tpm8001_ha->fw_status = FAIL_FILE_SIZE;\n\t\treturn -EFAULT;\n\t}\n\n\tioctlbuffer = kzalloc(length, GFP_KERNEL);\n\tif (!ioctlbuffer) {\n\t\tpm8001_ha->fw_status = FAIL_OUT_MEMORY;\n\t\treturn -ENOMEM;\n\t}\n\tpayload = (struct pm8001_ioctl_payload *)ioctlbuffer;\n\tmemcpy((u8 *)&payload->func_specific, (u8 *)pm8001_ha->fw_image->data,\n\t\t\t\tpm8001_ha->fw_image->size);\n\tpayload->wr_length = pm8001_ha->fw_image->size;\n\tpayload->id = 0;\n\tpayload->minor_function = 0x1;\n\tpm8001_ha->nvmd_completion = &completion;\n\tret = PM8001_CHIP_DISP->set_nvmd_req(pm8001_ha, payload);\n\tif (ret) {\n\t\tpm8001_ha->fw_status = FAIL_OUT_MEMORY;\n\t\tgoto out;\n\t}\n\twait_for_completion(&completion);\nout:\n\tkfree(ioctlbuffer);\n\treturn ret;\n}\n\nstatic int pm8001_update_flash(struct pm8001_hba_info *pm8001_ha)\n{\n\tstruct pm8001_ioctl_payload\t*payload;\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tu8\t\t*ioctlbuffer;\n\tstruct fw_control_info\t*fwControl;\n\t__be32\t\tpartitionSizeTmp;\n\tu32\t\tpartitionSize;\n\tu32\t\tloopNumber, loopcount;\n\tstruct pm8001_fw_image_header *image_hdr;\n\tu32\t\tsizeRead = 0;\n\tu32\t\tret = 0;\n\tu32\t\tlength = 1024 * 16 + sizeof(*payload) - 1;\n\tu32\t\tfc_len;\n\tu8\t\t*read_buf;\n\n\tif (pm8001_ha->fw_image->size < 28) {\n\t\tpm8001_ha->fw_status = FAIL_FILE_SIZE;\n\t\treturn -EFAULT;\n\t}\n\tioctlbuffer = kzalloc(length, GFP_KERNEL);\n\tif (!ioctlbuffer) {\n\t\tpm8001_ha->fw_status = FAIL_OUT_MEMORY;\n\t\treturn -ENOMEM;\n\t}\n\timage_hdr = (struct pm8001_fw_image_header *)pm8001_ha->fw_image->data;\n\twhile (sizeRead < pm8001_ha->fw_image->size) {\n\t\tpartitionSizeTmp =\n\t\t\t*(__be32 *)((u8 *)&image_hdr->image_length + sizeRead);\n\t\tpartitionSize = be32_to_cpu(partitionSizeTmp);\n\t\tloopcount = DIV_ROUND_UP(partitionSize + HEADER_LEN,\n\t\t\t\t\tIOCTL_BUF_SIZE);\n\t\tfor (loopNumber = 0; loopNumber < loopcount; loopNumber++) {\n\t\t\tpayload = (struct pm8001_ioctl_payload *)ioctlbuffer;\n\t\t\tpayload->wr_length = 1024*16;\n\t\t\tpayload->id = 0;\n\t\t\tfwControl =\n\t\t\t      (struct fw_control_info *)&payload->func_specific;\n\t\t\tfwControl->len = IOCTL_BUF_SIZE;    \n\t\t\tfwControl->size = partitionSize + HEADER_LEN; \n\t\t\tfwControl->retcode = 0; \n\t\t\tfwControl->offset = loopNumber * IOCTL_BUF_SIZE; \n\n\t\t\t \n\n\t\t\tread_buf  = (u8 *)pm8001_ha->fw_image->data + sizeRead;\n\t\t\tfc_len = (partitionSize + HEADER_LEN) % IOCTL_BUF_SIZE;\n\n\t\t\tif (loopcount - loopNumber == 1 && fc_len) {\n\t\t\t\tfwControl->len = fc_len;\n\t\t\t\tmemcpy((u8 *)fwControl->buffer, read_buf, fc_len);\n\t\t\t\tsizeRead += fc_len;\n\t\t\t} else {\n\t\t\t\tmemcpy((u8 *)fwControl->buffer, read_buf, IOCTL_BUF_SIZE);\n\t\t\t\tsizeRead += IOCTL_BUF_SIZE;\n\t\t\t}\n\n\t\t\tpm8001_ha->nvmd_completion = &completion;\n\t\t\tret = PM8001_CHIP_DISP->fw_flash_update_req(pm8001_ha, payload);\n\t\t\tif (ret) {\n\t\t\t\tpm8001_ha->fw_status = FAIL_OUT_MEMORY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\twait_for_completion(&completion);\n\t\t\tif (fwControl->retcode > FLASH_UPDATE_IN_PROGRESS) {\n\t\t\t\tpm8001_ha->fw_status = fwControl->retcode;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tkfree(ioctlbuffer);\n\treturn ret;\n}\nstatic ssize_t pm8001_store_update_fw(struct device *cdev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tchar *cmd_ptr, *filename_ptr;\n\tint res, i;\n\tint flash_command = FLASH_CMD_NONE;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\t \n\tif (pm8001_ha->fw_status == FLASH_IN_PROGRESS)\n\t\treturn -EINPROGRESS;\n\tpm8001_ha->fw_status = FLASH_IN_PROGRESS;\n\n\tcmd_ptr = kcalloc(count, 2, GFP_KERNEL);\n\tif (!cmd_ptr) {\n\t\tpm8001_ha->fw_status = FAIL_OUT_MEMORY;\n\t\treturn -ENOMEM;\n\t}\n\n\tfilename_ptr = cmd_ptr + count;\n\tres = sscanf(buf, \"%s %s\", cmd_ptr, filename_ptr);\n\tif (res != 2) {\n\t\tpm8001_ha->fw_status = FAIL_PARAMETERS;\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; flash_command_table[i].code != FLASH_CMD_NONE; i++) {\n\t\tif (!memcmp(flash_command_table[i].command,\n\t\t\t\t cmd_ptr, strlen(cmd_ptr))) {\n\t\t\tflash_command = flash_command_table[i].code;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flash_command == FLASH_CMD_NONE) {\n\t\tpm8001_ha->fw_status = FAIL_PARAMETERS;\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = request_firmware(&pm8001_ha->fw_image,\n\t\t\t       filename_ptr,\n\t\t\t       pm8001_ha->dev);\n\n\tif (ret) {\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"Failed to load firmware image file %s, error %d\\n\",\n\t\t\t   filename_ptr, ret);\n\t\tpm8001_ha->fw_status = FAIL_OPEN_BIOS_FILE;\n\t\tgoto out;\n\t}\n\n\tif (FLASH_CMD_UPDATE == flash_command)\n\t\tret = pm8001_update_flash(pm8001_ha);\n\telse\n\t\tret = pm8001_set_nvmd(pm8001_ha);\n\n\trelease_firmware(pm8001_ha->fw_image);\nout:\n\tkfree(cmd_ptr);\n\n\tif (ret)\n\t\treturn ret;\n\n\tpm8001_ha->fw_status = FLASH_OK;\n\treturn count;\n}\n\nstatic ssize_t pm8001_show_update_fw(struct device *cdev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint i;\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\n\tfor (i = 0; flash_error_table[i].err_code != 0; i++) {\n\t\tif (flash_error_table[i].err_code == pm8001_ha->fw_status)\n\t\t\tbreak;\n\t}\n\tif (pm8001_ha->fw_status != FLASH_IN_PROGRESS)\n\t\tpm8001_ha->fw_status = FLASH_OK;\n\n\treturn snprintf(buf, PAGE_SIZE, \"status=%x %s\\n\",\n\t\t\tflash_error_table[i].err_code,\n\t\t\tflash_error_table[i].reason);\n}\nstatic DEVICE_ATTR(update_fw, S_IRUGO|S_IWUSR|S_IWGRP,\n\tpm8001_show_update_fw, pm8001_store_update_fw);\n\nstatic const char *const mpiStateText[] = {\n\t\"MPI is not initialized\",\n\t\"MPI is successfully initialized\",\n\t\"MPI termination is in progress\",\n\t\"MPI initialization failed with error in [31:16]\"\n};\n\n \nstatic ssize_t ctl_mpi_state_show(struct device *cdev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tunsigned int mpidw0;\n\n\tmpidw0 = pm8001_mr32(pm8001_ha->general_stat_tbl_addr, 0);\n\treturn sysfs_emit(buf, \"%s\\n\", mpiStateText[mpidw0 & 0x0003]);\n}\nstatic DEVICE_ATTR_RO(ctl_mpi_state);\n\n \nstatic ssize_t ctl_hmi_error_show(struct device *cdev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tunsigned int mpidw0;\n\n\tmpidw0 = pm8001_mr32(pm8001_ha->general_stat_tbl_addr, 0);\n\treturn sysfs_emit(buf, \"0x%08x\\n\", (mpidw0 >> 16));\n}\nstatic DEVICE_ATTR_RO(ctl_hmi_error);\n\n \nstatic ssize_t ctl_raae_count_show(struct device *cdev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tunsigned int raaecnt;\n\n\traaecnt = pm8001_mr32(pm8001_ha->general_stat_tbl_addr, 12);\n\treturn sysfs_emit(buf, \"0x%08x\\n\", raaecnt);\n}\nstatic DEVICE_ATTR_RO(ctl_raae_count);\n\n \nstatic ssize_t ctl_iop0_count_show(struct device *cdev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tunsigned int iop0cnt;\n\n\tiop0cnt = pm8001_mr32(pm8001_ha->general_stat_tbl_addr, 16);\n\treturn sysfs_emit(buf, \"0x%08x\\n\", iop0cnt);\n}\nstatic DEVICE_ATTR_RO(ctl_iop0_count);\n\n \nstatic ssize_t ctl_iop1_count_show(struct device *cdev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tunsigned int iop1cnt;\n\n\tiop1cnt = pm8001_mr32(pm8001_ha->general_stat_tbl_addr, 20);\n\treturn sysfs_emit(buf, \"0x%08x\\n\", iop1cnt);\n\n}\nstatic DEVICE_ATTR_RO(ctl_iop1_count);\n\nstatic struct attribute *pm8001_host_attrs[] = {\n\t&dev_attr_interface_rev.attr,\n\t&dev_attr_controller_fatal_error.attr,\n\t&dev_attr_fw_version.attr,\n\t&dev_attr_update_fw.attr,\n\t&dev_attr_aap_log.attr,\n\t&dev_attr_iop_log.attr,\n\t&dev_attr_fatal_log.attr,\n\t&dev_attr_non_fatal_log.attr,\n\t&dev_attr_non_fatal_count.attr,\n\t&dev_attr_gsm_log.attr,\n\t&dev_attr_max_out_io.attr,\n\t&dev_attr_max_devices.attr,\n\t&dev_attr_max_sg_list.attr,\n\t&dev_attr_sas_spec_support.attr,\n\t&dev_attr_logging_level.attr,\n\t&dev_attr_event_log_size.attr,\n\t&dev_attr_host_sas_address.attr,\n\t&dev_attr_bios_version.attr,\n\t&dev_attr_ib_log.attr,\n\t&dev_attr_ob_log.attr,\n\t&dev_attr_ila_version.attr,\n\t&dev_attr_inc_fw_ver.attr,\n\t&dev_attr_ctl_mpi_state.attr,\n\t&dev_attr_ctl_hmi_error.attr,\n\t&dev_attr_ctl_raae_count.attr,\n\t&dev_attr_ctl_iop0_count.attr,\n\t&dev_attr_ctl_iop1_count.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group pm8001_host_attr_group = {\n\t.attrs = pm8001_host_attrs\n};\n\nconst struct attribute_group *pm8001_host_groups[] = {\n\t&pm8001_host_attr_group,\n\tNULL\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}