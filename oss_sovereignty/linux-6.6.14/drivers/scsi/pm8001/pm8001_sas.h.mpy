{
  "module_name": "pm8001_sas.h",
  "hash_id": "554c1aeb3c3b6fe2819df555f42d4c855378ba505d6c4ef38892d0d48d36484d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/pm8001/pm8001_sas.h",
  "human_readable_source": " \n\n#ifndef _PM8001_SAS_H_\n#define _PM8001_SAS_H_\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n#include <linux/dma-mapping.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <scsi/libsas.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/sas_ata.h>\n#include <linux/atomic.h>\n#include <linux/blk-mq.h>\n#include <linux/blk-mq-pci.h>\n#include \"pm8001_defs.h\"\n\n#define DRV_NAME\t\t\"pm80xx\"\n#define DRV_VERSION\t\t\"0.1.40\"\n#define PM8001_FAIL_LOGGING\t0x01  \n#define PM8001_INIT_LOGGING\t0x02  \n#define PM8001_DISC_LOGGING\t0x04  \n#define PM8001_IO_LOGGING\t0x08  \n#define PM8001_EH_LOGGING\t0x10  \n#define PM8001_IOCTL_LOGGING\t0x20  \n#define PM8001_MSG_LOGGING\t0x40  \n#define PM8001_DEV_LOGGING\t0x80  \n#define PM8001_DEVIO_LOGGING\t0x100  \n#define PM8001_IOERR_LOGGING\t0x200  \n#define PM8001_EVENT_LOGGING\t0x400  \n\n#define pm8001_info(HBA, fmt, ...)\t\t\t\t\t\\\n\tpr_info(\"%s:: %s %d: \" fmt,\t\t\t\t\t\\\n\t\t(HBA)->name, __func__, __LINE__, ##__VA_ARGS__)\n\n#define pm8001_dbg(HBA, level, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely((HBA)->logging_level & PM8001_##level##_LOGGING))\t\\\n\t\tpm8001_info(HBA, fmt, ##__VA_ARGS__);\t\t\t\\\n} while (0)\n\n#define PM8001_USE_TASKLET\n#define PM8001_USE_MSIX\n#define PM8001_READ_VPD\n\n\n#define IS_SPCV_12G(dev)\t((dev->device == 0X8074)\t\t\\\n\t\t\t\t|| (dev->device == 0X8076)\t\t\\\n\t\t\t\t|| (dev->device == 0X8077)\t\t\\\n\t\t\t\t|| (dev->device == 0X8070)\t\t\\\n\t\t\t\t|| (dev->device == 0X8072))\n\n#define PM8001_NAME_LENGTH\t\t32 \nextern struct list_head hba_list;\nextern const struct pm8001_dispatch pm8001_8001_dispatch;\nextern const struct pm8001_dispatch pm8001_80xx_dispatch;\n\nstruct pm8001_hba_info;\nstruct pm8001_ccb_info;\nstruct pm8001_device;\n\nstruct pm8001_ioctl_payload {\n\tu32\tsignature;\n\tu16\tmajor_function;\n\tu16\tminor_function;\n\tu16\tstatus;\n\tu16\toffset;\n\tu16\tid;\n\tu32\twr_length;\n\tu32\trd_length;\n\tu8\t*func_specific;\n};\n\n#define MPI_FATAL_ERROR_TABLE_OFFSET_MASK 0xFFFFFF\n#define MPI_FATAL_ERROR_TABLE_SIZE(value) ((0xFF000000 & value) >> SHIFT24)\n#define MPI_FATAL_EDUMP_TABLE_LO_OFFSET            0x00      \n#define MPI_FATAL_EDUMP_TABLE_HI_OFFSET            0x04      \n#define MPI_FATAL_EDUMP_TABLE_LENGTH               0x08      \n#define MPI_FATAL_EDUMP_TABLE_HANDSHAKE            0x0C      \n#define MPI_FATAL_EDUMP_TABLE_STATUS               0x10      \n#define MPI_FATAL_EDUMP_TABLE_ACCUM_LEN            0x14      \n#define MPI_FATAL_EDUMP_TABLE_TOTAL_LEN\t\t   0x18\t     \n#define MPI_FATAL_EDUMP_TABLE_SIGNATURE\t\t   0x1C      \n#define MPI_FATAL_EDUMP_HANDSHAKE_RDY              0x1\n#define MPI_FATAL_EDUMP_HANDSHAKE_BUSY             0x0\n#define MPI_FATAL_EDUMP_TABLE_STAT_RSVD                 0x0\n#define MPI_FATAL_EDUMP_TABLE_STAT_DMA_FAILED           0x1\n#define MPI_FATAL_EDUMP_TABLE_STAT_NF_SUCCESS_MORE_DATA 0x2\n#define MPI_FATAL_EDUMP_TABLE_STAT_NF_SUCCESS_DONE      0x3\n#define TYPE_GSM_SPACE        1\n#define TYPE_QUEUE            2\n#define TYPE_FATAL            3\n#define TYPE_NON_FATAL        4\n#define TYPE_INBOUND          1\n#define TYPE_OUTBOUND         2\nstruct forensic_data {\n\tu32  data_type;\n\tunion {\n\t\tstruct {\n\t\t\tu32  direct_len;\n\t\t\tu32  direct_offset;\n\t\t\tvoid  *direct_data;\n\t\t} gsm_buf;\n\t\tstruct {\n\t\t\tu16  queue_type;\n\t\t\tu16  queue_index;\n\t\t\tu32  direct_len;\n\t\t\tvoid  *direct_data;\n\t\t} queue_buf;\n\t\tstruct {\n\t\t\tu32  direct_len;\n\t\t\tu32  direct_offset;\n\t\t\tu32  read_len;\n\t\t\tvoid  *direct_data;\n\t\t} data_buf;\n\t};\n};\n\n \n#define SCRATCH_PAD0_BAR_MASK                    0xFC000000\n \n#define SCRATCH_PAD0_OFFSET_MASK                 0x03FFFFFF\n \n#define SCRATCH_PAD0_AAPERR_MASK                 0xFFFFFFFF\n \n#define SPCv_MSGU_CFG_TABLE_NONFATAL_DUMP\t 0x80\n \n#define SPCV_MSGU_CFG_TABLE_TRANSFER_DEBUG_INFO  0x80\n#define MAIN_MERRDCTO_MERRDCES\t\t         0xA0 \n\nstruct pm8001_dispatch {\n\tchar *name;\n\tint (*chip_init)(struct pm8001_hba_info *pm8001_ha);\n\tvoid (*chip_post_init)(struct pm8001_hba_info *pm8001_ha);\n\tint (*chip_soft_rst)(struct pm8001_hba_info *pm8001_ha);\n\tvoid (*chip_rst)(struct pm8001_hba_info *pm8001_ha);\n\tint (*chip_ioremap)(struct pm8001_hba_info *pm8001_ha);\n\tvoid (*chip_iounmap)(struct pm8001_hba_info *pm8001_ha);\n\tirqreturn_t (*isr)(struct pm8001_hba_info *pm8001_ha, u8 vec);\n\tu32 (*is_our_interrupt)(struct pm8001_hba_info *pm8001_ha);\n\tint (*isr_process_oq)(struct pm8001_hba_info *pm8001_ha, u8 vec);\n\tvoid (*interrupt_enable)(struct pm8001_hba_info *pm8001_ha, u8 vec);\n\tvoid (*interrupt_disable)(struct pm8001_hba_info *pm8001_ha, u8 vec);\n\tvoid (*make_prd)(struct scatterlist *scatter, int nr, void *prd);\n\tint (*smp_req)(struct pm8001_hba_info *pm8001_ha,\n\t\tstruct pm8001_ccb_info *ccb);\n\tint (*ssp_io_req)(struct pm8001_hba_info *pm8001_ha,\n\t\tstruct pm8001_ccb_info *ccb);\n\tint (*sata_req)(struct pm8001_hba_info *pm8001_ha,\n\t\tstruct pm8001_ccb_info *ccb);\n\tint (*phy_start_req)(struct pm8001_hba_info *pm8001_ha,\tu8 phy_id);\n\tint (*phy_stop_req)(struct pm8001_hba_info *pm8001_ha, u8 phy_id);\n\tint (*reg_dev_req)(struct pm8001_hba_info *pm8001_ha,\n\t\tstruct pm8001_device *pm8001_dev, u32 flag);\n\tint (*dereg_dev_req)(struct pm8001_hba_info *pm8001_ha, u32 device_id);\n\tint (*phy_ctl_req)(struct pm8001_hba_info *pm8001_ha,\n\t\tu32 phy_id, u32 phy_op);\n\tint (*task_abort)(struct pm8001_hba_info *pm8001_ha,\n\t\tstruct pm8001_ccb_info *ccb);\n\tint (*ssp_tm_req)(struct pm8001_hba_info *pm8001_ha,\n\t\tstruct pm8001_ccb_info *ccb, struct sas_tmf_task *tmf);\n\tint (*get_nvmd_req)(struct pm8001_hba_info *pm8001_ha, void *payload);\n\tint (*set_nvmd_req)(struct pm8001_hba_info *pm8001_ha, void *payload);\n\tint (*fw_flash_update_req)(struct pm8001_hba_info *pm8001_ha,\n\t\tvoid *payload);\n\tint (*set_dev_state_req)(struct pm8001_hba_info *pm8001_ha,\n\t\tstruct pm8001_device *pm8001_dev, u32 state);\n\tint (*sas_diag_start_end_req)(struct pm8001_hba_info *pm8001_ha,\n\t\tu32 state);\n\tint (*sas_diag_execute_req)(struct pm8001_hba_info *pm8001_ha,\n\t\tu32 state);\n\tint (*sas_re_init_req)(struct pm8001_hba_info *pm8001_ha);\n\tint (*fatal_errors)(struct pm8001_hba_info *pm8001_ha);\n\tvoid (*hw_event_ack_req)(struct pm8001_hba_info *pm8001_ha,\n\t\tu32 Qnum, u32 SEA, u32 port_id, u32 phyId, u32 param0,\n\t\tu32 param1);\n};\n\nstruct pm8001_chip_info {\n\tu32     encrypt;\n\tu32\tn_phy;\n\tconst struct pm8001_dispatch\t*dispatch;\n};\n#define PM8001_CHIP_DISP\t(pm8001_ha->chip->dispatch)\n\nstruct pm8001_port {\n\tstruct asd_sas_port\tsas_port;\n\tu8\t\t\tport_attached;\n\tu16\t\t\twide_port_phymap;\n\tu8\t\t\tport_state;\n\tu8\t\t\tport_id;\n\tstruct list_head\tlist;\n};\n\nstruct pm8001_phy {\n\tstruct pm8001_hba_info\t*pm8001_ha;\n\tstruct pm8001_port\t*port;\n\tstruct asd_sas_phy\tsas_phy;\n\tstruct sas_identify\tidentify;\n\tstruct scsi_device\t*sdev;\n\tu64\t\t\tdev_sas_addr;\n\tu32\t\t\tphy_type;\n\tstruct completion\t*enable_completion;\n\tu32\t\t\tframe_rcvd_size;\n\tu8\t\t\tframe_rcvd[32];\n\tu8\t\t\tphy_attached;\n\tu8\t\t\tphy_state;\n\tenum sas_linkrate\tminimum_linkrate;\n\tenum sas_linkrate\tmaximum_linkrate;\n\tstruct completion\t*reset_completion;\n\tbool\t\t\tport_reset_status;\n\tbool\t\t\treset_success;\n};\n\n \n#define PORT_RESET_SUCCESS\t0x00\n#define PORT_RESET_TMO\t\t0x01\n\nstruct pm8001_device {\n\tenum sas_device_type\tdev_type;\n\tstruct domain_device\t*sas_device;\n\tu32\t\t\tattached_phy;\n\tu32\t\t\tid;\n\tstruct completion\t*dcompletion;\n\tstruct completion\t*setds_completion;\n\tu32\t\t\tdevice_id;\n\tatomic_t\t\trunning_req;\n};\n\nstruct pm8001_prd_imt {\n\t__le32\t\t\tlen;\n\t__le32\t\t\te;\n};\n\nstruct pm8001_prd {\n\t__le64\t\t\taddr;\t\t \n\tstruct pm8001_prd_imt\tim_len;\t\t \n} __attribute__ ((packed));\n \nstruct pm8001_ccb_info {\n\tstruct sas_task\t\t*task;\n\tu32\t\t\tn_elem;\n\tu32\t\t\tccb_tag;\n\tdma_addr_t\t\tccb_dma_handle;\n\tstruct pm8001_device\t*device;\n\tstruct pm8001_prd\t*buf_prd;\n\tstruct fw_control_ex\t*fw_control_context;\n\tu8\t\t\topen_retry;\n};\n\nstruct mpi_mem {\n\tvoid\t\t\t*virt_ptr;\n\tdma_addr_t\t\tphys_addr;\n\tu32\t\t\tphys_addr_hi;\n\tu32\t\t\tphys_addr_lo;\n\tu32\t\t\ttotal_len;\n\tu32\t\t\tnum_elements;\n\tu32\t\t\telement_size;\n\tu32\t\t\talignment;\n};\n\nstruct mpi_mem_req {\n\t \n\tu32\t\t\tcount;\n\t \n\tstruct mpi_mem\t\tregion[USI_MAX_MEMCNT];\n};\n\nstruct encrypt {\n\tu32\tcipher_mode;\n\tu32\tsec_mode;\n\tu32\tstatus;\n\tu32\tflag;\n};\n\nstruct sas_phy_attribute_table {\n\tu32\tphystart1_16[16];\n\tu32\toutbound_hw_event_pid1_16[16];\n};\n\nunion main_cfg_table {\n\tstruct {\n\tu32\t\t\tsignature;\n\tu32\t\t\tinterface_rev;\n\tu32\t\t\tfirmware_rev;\n\tu32\t\t\tmax_out_io;\n\tu32\t\t\tmax_sgl;\n\tu32\t\t\tctrl_cap_flag;\n\tu32\t\t\tgst_offset;\n\tu32\t\t\tinbound_queue_offset;\n\tu32\t\t\toutbound_queue_offset;\n\tu32\t\t\tinbound_q_nppd_hppd;\n\tu32\t\t\toutbound_hw_event_pid0_3;\n\tu32\t\t\toutbound_hw_event_pid4_7;\n\tu32\t\t\toutbound_ncq_event_pid0_3;\n\tu32\t\t\toutbound_ncq_event_pid4_7;\n\tu32\t\t\toutbound_tgt_ITNexus_event_pid0_3;\n\tu32\t\t\toutbound_tgt_ITNexus_event_pid4_7;\n\tu32\t\t\toutbound_tgt_ssp_event_pid0_3;\n\tu32\t\t\toutbound_tgt_ssp_event_pid4_7;\n\tu32\t\t\toutbound_tgt_smp_event_pid0_3;\n\tu32\t\t\toutbound_tgt_smp_event_pid4_7;\n\tu32\t\t\tupper_event_log_addr;\n\tu32\t\t\tlower_event_log_addr;\n\tu32\t\t\tevent_log_size;\n\tu32\t\t\tevent_log_option;\n\tu32\t\t\tupper_iop_event_log_addr;\n\tu32\t\t\tlower_iop_event_log_addr;\n\tu32\t\t\tiop_event_log_size;\n\tu32\t\t\tiop_event_log_option;\n\tu32\t\t\tfatal_err_interrupt;\n\tu32\t\t\tfatal_err_dump_offset0;\n\tu32\t\t\tfatal_err_dump_length0;\n\tu32\t\t\tfatal_err_dump_offset1;\n\tu32\t\t\tfatal_err_dump_length1;\n\tu32\t\t\thda_mode_flag;\n\tu32\t\t\tanolog_setup_table_offset;\n\tu32\t\t\trsvd[4];\n\t} pm8001_tbl;\n\n\tstruct {\n\tu32\t\t\tsignature;\n\tu32\t\t\tinterface_rev;\n\tu32\t\t\tfirmware_rev;\n\tu32\t\t\tmax_out_io;\n\tu32\t\t\tmax_sgl;\n\tu32\t\t\tctrl_cap_flag;\n\tu32\t\t\tgst_offset;\n\tu32\t\t\tinbound_queue_offset;\n\tu32\t\t\toutbound_queue_offset;\n\tu32\t\t\tinbound_q_nppd_hppd;\n\tu32\t\t\trsvd[8];\n\tu32\t\t\tcrc_core_dump;\n\tu32\t\t\trsvd1;\n\tu32\t\t\tupper_event_log_addr;\n\tu32\t\t\tlower_event_log_addr;\n\tu32\t\t\tevent_log_size;\n\tu32\t\t\tevent_log_severity;\n\tu32\t\t\tupper_pcs_event_log_addr;\n\tu32\t\t\tlower_pcs_event_log_addr;\n\tu32\t\t\tpcs_event_log_size;\n\tu32\t\t\tpcs_event_log_severity;\n\tu32\t\t\tfatal_err_interrupt;\n\tu32\t\t\tfatal_err_dump_offset0;\n\tu32\t\t\tfatal_err_dump_length0;\n\tu32\t\t\tfatal_err_dump_offset1;\n\tu32\t\t\tfatal_err_dump_length1;\n\tu32\t\t\tgpio_led_mapping;\n\tu32\t\t\tanalog_setup_table_offset;\n\tu32\t\t\tint_vec_table_offset;\n\tu32\t\t\tphy_attr_table_offset;\n\tu32\t\t\tport_recovery_timer;\n\tu32\t\t\tinterrupt_reassertion_delay;\n\tu32\t\t\tfatal_n_non_fatal_dump;\t         \n\tu32\t\t\tila_version;\n\tu32\t\t\tinc_fw_version;\n\t} pm80xx_tbl;\n};\n\nunion general_status_table {\n\tstruct {\n\tu32\t\t\tgst_len_mpistate;\n\tu32\t\t\tiq_freeze_state0;\n\tu32\t\t\tiq_freeze_state1;\n\tu32\t\t\tmsgu_tcnt;\n\tu32\t\t\tiop_tcnt;\n\tu32\t\t\trsvd;\n\tu32\t\t\tphy_state[8];\n\tu32\t\t\tgpio_input_val;\n\tu32\t\t\trsvd1[2];\n\tu32\t\t\trecover_err_info[8];\n\t} pm8001_tbl;\n\tstruct {\n\tu32\t\t\tgst_len_mpistate;\n\tu32\t\t\tiq_freeze_state0;\n\tu32\t\t\tiq_freeze_state1;\n\tu32\t\t\tmsgu_tcnt;\n\tu32\t\t\tiop_tcnt;\n\tu32\t\t\trsvd[9];\n\tu32\t\t\tgpio_input_val;\n\tu32\t\t\trsvd1[2];\n\tu32\t\t\trecover_err_info[8];\n\t} pm80xx_tbl;\n};\nstruct inbound_queue_table {\n\tu32\t\t\telement_pri_size_cnt;\n\tu32\t\t\tupper_base_addr;\n\tu32\t\t\tlower_base_addr;\n\tu32\t\t\tci_upper_base_addr;\n\tu32\t\t\tci_lower_base_addr;\n\tu32\t\t\tpi_pci_bar;\n\tu32\t\t\tpi_offset;\n\tu32\t\t\ttotal_length;\n\tvoid\t\t\t*base_virt;\n\tvoid\t\t\t*ci_virt;\n\tu32\t\t\treserved;\n\t__le32\t\t\tconsumer_index;\n\tu32\t\t\tproducer_idx;\n\tspinlock_t\t\tiq_lock;\n};\nstruct outbound_queue_table {\n\tu32\t\t\telement_size_cnt;\n\tu32\t\t\tupper_base_addr;\n\tu32\t\t\tlower_base_addr;\n\tvoid\t\t\t*base_virt;\n\tu32\t\t\tpi_upper_base_addr;\n\tu32\t\t\tpi_lower_base_addr;\n\tu32\t\t\tci_pci_bar;\n\tu32\t\t\tci_offset;\n\tu32\t\t\ttotal_length;\n\tvoid\t\t\t*pi_virt;\n\tu32\t\t\tinterrup_vec_cnt_delay;\n\tu32\t\t\tdinterrup_to_pci_offset;\n\t__le32\t\t\tproducer_index;\n\tu32\t\t\tconsumer_idx;\n\tspinlock_t\t\toq_lock;\n\tunsigned long\t\tlock_flags;\n};\nstruct pm8001_hba_memspace {\n\tvoid __iomem  \t\t*memvirtaddr;\n\tu64\t\t\tmembase;\n\tu32\t\t\tmemsize;\n};\nstruct isr_param {\n\tstruct pm8001_hba_info *drv_inst;\n\tu32 irq_id;\n};\nstruct pm8001_hba_info {\n\tchar\t\t\tname[PM8001_NAME_LENGTH];\n\tstruct list_head\tlist;\n\tunsigned long\t\tflags;\n\tspinlock_t\t\tlock; \n\tspinlock_t\t\tbitmap_lock;\n\tstruct pci_dev\t\t*pdev; \n\tstruct device\t\t*dev;\n\tstruct pm8001_hba_memspace io_mem[6];\n\tstruct mpi_mem_req\tmemoryMap;\n\tstruct encrypt\t\tencrypt_info;  \n\tstruct forensic_data\tforensic_info;\n\tu32\t\t\tfatal_bar_loc;\n\tu32\t\t\tforensic_last_offset;\n\tu32\t\t\tfatal_forensic_shift_offset;\n\tu32\t\t\tforensic_fatal_step;\n\tu32\t\t\tforensic_preserved_accumulated_transfer;\n\tu32\t\t\tevtlog_ib_offset;\n\tu32\t\t\tevtlog_ob_offset;\n\tvoid __iomem\t*msg_unit_tbl_addr; \n\tvoid __iomem\t*main_cfg_tbl_addr; \n\tvoid __iomem\t*general_stat_tbl_addr; \n\tvoid __iomem\t*inbnd_q_tbl_addr; \n\tvoid __iomem\t*outbnd_q_tbl_addr; \n\tvoid __iomem\t*pspa_q_tbl_addr;\n\t\t\t \n\tvoid __iomem\t*ivt_tbl_addr;  \n\tvoid __iomem\t*fatal_tbl_addr;  \n\tunion main_cfg_table\tmain_cfg_tbl;\n\tunion general_status_table\tgs_tbl;\n\tstruct inbound_queue_table\tinbnd_q_tbl[PM8001_MAX_INB_NUM];\n\tstruct outbound_queue_table\toutbnd_q_tbl[PM8001_MAX_OUTB_NUM];\n\tstruct sas_phy_attribute_table\tphy_attr_table;\n\t\t\t\t\t \n\tu8\t\t\tsas_addr[SAS_ADDR_SIZE];\n\tstruct sas_ha_struct\t*sas; \n\tstruct Scsi_Host\t*shost;\n\tu32\t\t\tchip_id;\n\tconst struct pm8001_chip_info\t*chip;\n\tstruct completion\t*nvmd_completion;\n\tunsigned long\t\t*rsvd_tags;\n\tstruct pm8001_phy\tphy[PM8001_MAX_PHYS];\n\tstruct pm8001_port\tport[PM8001_MAX_PHYS];\n\tu32\t\t\tid;\n\tu32\t\t\tirq;\n\tu32\t\t\tiomb_size;  \n\tstruct pm8001_device\t*devices;\n\tstruct pm8001_ccb_info\t*ccb_info;\n\tu32\t\t\tccb_count;\n#ifdef PM8001_USE_MSIX\n\tint\t\t\tnumber_of_intr; \n\tchar\t\t\tintr_drvname[PM8001_MAX_MSIX_VEC]\n\t\t\t\t[PM8001_NAME_LENGTH+1+3+1];\n#endif\n#ifdef PM8001_USE_TASKLET\n\tstruct tasklet_struct\ttasklet[PM8001_MAX_MSIX_VEC];\n#endif\n\tu32\t\t\tlogging_level;\n\tu32\t\t\tlink_rate;\n\tu32\t\t\tfw_status;\n\tu32\t\t\tsmp_exp_mode;\n\tbool\t\t\tcontroller_fatal_error;\n\tconst struct firmware \t*fw_image;\n\tstruct isr_param irq_vector[PM8001_MAX_MSIX_VEC];\n\tu32\t\t\tnon_fatal_count;\n\tu32\t\t\tnon_fatal_read_length;\n\tu32 max_q_num;\n\tu32 ib_offset;\n\tu32 ob_offset;\n\tu32 ci_offset;\n\tu32 pi_offset;\n\tu32 max_memcnt;\n};\n\nstruct pm8001_work {\n\tstruct work_struct work;\n\tstruct pm8001_hba_info *pm8001_ha;\n\tvoid *data;\n\tint handler;\n};\n\nstruct pm8001_fw_image_header {\n\tu8 vender_id[8];\n\tu8 product_id;\n\tu8 hardware_rev;\n\tu8 dest_partition;\n\tu8 reserved;\n\tu8 fw_rev[4];\n\t__be32  image_length;\n\t__be32 image_crc;\n\t__be32 startup_entry;\n} __attribute__((packed, aligned(4)));\n\n\n \n#define FLASH_UPDATE_COMPLETE_PENDING_REBOOT\t0x00\n#define FLASH_UPDATE_IN_PROGRESS\t\t0x01\n#define FLASH_UPDATE_HDR_ERR\t\t\t0x02\n#define FLASH_UPDATE_OFFSET_ERR\t\t\t0x03\n#define FLASH_UPDATE_CRC_ERR\t\t\t0x04\n#define FLASH_UPDATE_LENGTH_ERR\t\t\t0x05\n#define FLASH_UPDATE_HW_ERR\t\t\t0x06\n#define FLASH_UPDATE_DNLD_NOT_SUPPORTED\t\t0x10\n#define FLASH_UPDATE_DISABLED\t\t\t0x11\n\n \n#define DS_OPERATIONAL\t\t\t\t0x01\n#define DS_PORT_IN_RESET\t\t\t0x02\n#define DS_IN_RECOVERY\t\t\t\t0x03\n#define DS_IN_ERROR\t\t\t\t0x04\n#define DS_NON_OPERATIONAL\t\t\t0x07\n\n \nstruct fw_flash_updata_info {\n\tu32\t\t\tcur_image_offset;\n\tu32\t\t\tcur_image_len;\n\tu32\t\t\ttotal_image_len;\n\tstruct pm8001_prd\tsgl;\n};\n\nstruct fw_control_info {\n\tu32\t\t\tretcode; \n\tu32\t\t\tphase; \n\tu32\t\t\tphaseCmplt; \n\tu32\t\t\tversion; \n\tu32\t\t\toffset; \n\tu32\t\t\tlen;  \n\tu32\t\t\tsize; \n\tu32\t\t\treserved; \n\tu8\t\t\tbuffer[]; \n};\nstruct fw_control_ex {\n\tstruct fw_control_info *fw_control;\n\tvoid\t\t\t*buffer; \n\tvoid\t\t\t*virtAddr; \n\tvoid\t\t\t*usrAddr; \n\tdma_addr_t\t\tphys_addr;\n\tu32\t\t\tlen;  \n\tvoid\t\t\t*payload;  \n\tu8\t\t\tinProgress; \n\tvoid\t\t\t*param1;\n\tvoid\t\t\t*param2;\n\tvoid\t\t\t*param3;\n};\n\n \nextern struct workqueue_struct *pm8001_wq;\n\n \nint pm8001_tag_alloc(struct pm8001_hba_info *pm8001_ha, u32 *tag_out);\nu32 pm8001_get_ncq_tag(struct sas_task *task, u32 *tag);\nvoid pm8001_ccb_task_free(struct pm8001_hba_info *pm8001_ha,\n\t\t\t  struct pm8001_ccb_info *ccb);\nint pm8001_phy_control(struct asd_sas_phy *sas_phy, enum phy_func func,\n\tvoid *funcdata);\nvoid pm8001_scan_start(struct Scsi_Host *shost);\nint pm8001_scan_finished(struct Scsi_Host *shost, unsigned long time);\nint pm8001_queue_command(struct sas_task *task, gfp_t gfp_flags);\nint pm8001_abort_task(struct sas_task *task);\nint pm8001_clear_task_set(struct domain_device *dev, u8 *lun);\nint pm8001_dev_found(struct domain_device *dev);\nvoid pm8001_dev_gone(struct domain_device *dev);\nint pm8001_lu_reset(struct domain_device *dev, u8 *lun);\nint pm8001_I_T_nexus_reset(struct domain_device *dev);\nint pm8001_I_T_nexus_event_handler(struct domain_device *dev);\nint pm8001_query_task(struct sas_task *task);\nvoid pm8001_port_formed(struct asd_sas_phy *sas_phy);\nvoid pm8001_open_reject_retry(\n\tstruct pm8001_hba_info *pm8001_ha,\n\tstruct sas_task *task_to_close,\n\tstruct pm8001_device *device_to_close);\nint pm8001_mem_alloc(struct pci_dev *pdev, void **virt_addr,\n\tdma_addr_t *pphys_addr, u32 *pphys_addr_hi, u32 *pphys_addr_lo,\n\tu32 mem_size, u32 align);\n\nvoid pm8001_chip_iounmap(struct pm8001_hba_info *pm8001_ha);\nint pm8001_mpi_build_cmd(struct pm8001_hba_info *pm8001_ha,\n\t\t\tu32 q_index, u32 opCode, void *payload, size_t nb,\n\t\t\tu32 responseQueue);\nint pm8001_mpi_msg_free_get(struct inbound_queue_table *circularQ,\n\t\t\t\tu16 messageSize, void **messagePtr);\nu32 pm8001_mpi_msg_free_set(struct pm8001_hba_info *pm8001_ha, void *pMsg,\n\t\t\tstruct outbound_queue_table *circularQ, u8 bc);\nu32 pm8001_mpi_msg_consume(struct pm8001_hba_info *pm8001_ha,\n\t\t\tstruct outbound_queue_table *circularQ,\n\t\t\tvoid **messagePtr1, u8 *pBC);\nint pm8001_chip_set_dev_state_req(struct pm8001_hba_info *pm8001_ha,\n\t\t\tstruct pm8001_device *pm8001_dev, u32 state);\nint pm8001_chip_fw_flash_update_req(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\tvoid *payload);\nint pm8001_chip_fw_flash_update_build(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\tvoid *fw_flash_updata_info, u32 tag);\nint pm8001_chip_set_nvmd_req(struct pm8001_hba_info *pm8001_ha, void *payload);\nint pm8001_chip_get_nvmd_req(struct pm8001_hba_info *pm8001_ha, void *payload);\nint pm8001_chip_ssp_tm_req(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\tstruct pm8001_ccb_info *ccb,\n\t\t\t\tstruct sas_tmf_task *tmf);\nint pm8001_chip_abort_task(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\tstruct pm8001_ccb_info *ccb);\nint pm8001_chip_dereg_dev_req(struct pm8001_hba_info *pm8001_ha, u32 device_id);\nvoid pm8001_chip_make_sg(struct scatterlist *scatter, int nr, void *prd);\nvoid pm8001_work_fn(struct work_struct *work);\nint pm8001_handle_event(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\tvoid *data, int handler);\nvoid pm8001_mpi_set_dev_state_resp(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\t\t\tvoid *piomb);\nvoid pm8001_mpi_set_nvmd_resp(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\t\t\tvoid *piomb);\nvoid pm8001_mpi_get_nvmd_resp(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\t\t\tvoid *piomb);\nint pm8001_mpi_local_phy_ctl(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\t\t\tvoid *piomb);\nvoid pm8001_get_lrate_mode(struct pm8001_phy *phy, u8 link_rate);\nvoid pm8001_get_attached_sas_addr(struct pm8001_phy *phy, u8 *sas_addr);\nvoid pm8001_bytes_dmaed(struct pm8001_hba_info *pm8001_ha, int i);\nint pm8001_mpi_reg_resp(struct pm8001_hba_info *pm8001_ha, void *piomb);\nint pm8001_mpi_dereg_resp(struct pm8001_hba_info *pm8001_ha, void *piomb);\nint pm8001_mpi_fw_flash_update_resp(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\t\t\tvoid *piomb);\nint pm8001_mpi_general_event(struct pm8001_hba_info *pm8001_ha, void *piomb);\nint pm8001_mpi_task_abort_resp(struct pm8001_hba_info *pm8001_ha, void *piomb);\nvoid pm8001_tag_free(struct pm8001_hba_info *pm8001_ha, u32 tag);\nstruct pm8001_device *pm8001_find_dev(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\tu32 device_id);\nint pm80xx_set_thermal_config(struct pm8001_hba_info *pm8001_ha);\n\nint pm8001_bar4_shift(struct pm8001_hba_info *pm8001_ha, u32 shiftValue);\nvoid pm8001_set_phy_profile(struct pm8001_hba_info *pm8001_ha,\n\tu32 length, u8 *buf);\nvoid pm8001_set_phy_profile_single(struct pm8001_hba_info *pm8001_ha,\n\t\tu32 phy, u32 length, u32 *buf);\nint pm80xx_bar4_shift(struct pm8001_hba_info *pm8001_ha, u32 shiftValue);\nssize_t pm80xx_get_fatal_dump(struct device *cdev,\n\t\tstruct device_attribute *attr, char *buf);\nssize_t pm80xx_get_non_fatal_dump(struct device *cdev,\n\t\tstruct device_attribute *attr, char *buf);\nssize_t pm8001_get_gsm_dump(struct device *cdev, u32, char *buf);\nint pm80xx_fatal_errors(struct pm8001_hba_info *pm8001_ha);\nvoid pm8001_free_dev(struct pm8001_device *pm8001_dev);\n \nextern const struct attribute_group *pm8001_host_groups[];\n\n#define PM8001_INVALID_TAG\t((u32)-1)\n\n \nstatic inline struct pm8001_ccb_info *\npm8001_ccb_alloc(struct pm8001_hba_info *pm8001_ha,\n\t\t struct pm8001_device *dev, struct sas_task *task)\n{\n\tstruct pm8001_ccb_info *ccb;\n\tstruct request *rq = NULL;\n\tu32 tag;\n\n\tif (task)\n\t\trq = sas_task_find_rq(task);\n\n\tif (rq) {\n\t\ttag = rq->tag + PM8001_RESERVE_SLOT;\n\t} else if (pm8001_tag_alloc(pm8001_ha, &tag)) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"Failed to allocate a tag\\n\");\n\t\treturn NULL;\n\t}\n\n\tccb = &pm8001_ha->ccb_info[tag];\n\tccb->task = task;\n\tccb->n_elem = 0;\n\tccb->ccb_tag = tag;\n\tccb->device = dev;\n\tccb->fw_control_context = NULL;\n\tccb->open_retry = 0;\n\n\treturn ccb;\n}\n\n \nstatic inline void pm8001_ccb_free(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t   struct pm8001_ccb_info *ccb)\n{\n\tu32 tag = ccb->ccb_tag;\n\n\t \n\tccb->task = NULL;\n\tccb->ccb_tag = PM8001_INVALID_TAG;\n\tccb->device = NULL;\n\tccb->fw_control_context = NULL;\n\n\tpm8001_tag_free(pm8001_ha, tag);\n}\n\nstatic inline void pm8001_ccb_task_free_done(struct pm8001_hba_info *pm8001_ha,\n\t\t\t\t\t     struct pm8001_ccb_info *ccb)\n{\n\tstruct sas_task *task = ccb->task;\n\n\tpm8001_ccb_task_free(pm8001_ha, ccb);\n\tsmp_mb();  \n\ttask->task_done(task);\n}\nvoid pm8001_setds_completion(struct domain_device *dev);\nvoid pm8001_tmf_aborted(struct sas_task *task);\n\n#endif\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}