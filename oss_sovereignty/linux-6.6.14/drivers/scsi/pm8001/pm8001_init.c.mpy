{
  "module_name": "pm8001_init.c",
  "hash_id": "52591315d292759aa844d49037f26aeb0a9d7bebcd3228cf8c6cb74e894549df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/pm8001/pm8001_init.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include \"pm8001_sas.h\"\n#include \"pm8001_chips.h\"\n#include \"pm80xx_hwi.h\"\n\nstatic ulong logging_level = PM8001_FAIL_LOGGING | PM8001_IOERR_LOGGING |\n\t\t\t\tPM8001_EVENT_LOGGING | PM8001_INIT_LOGGING;\nmodule_param(logging_level, ulong, 0644);\nMODULE_PARM_DESC(logging_level, \" bits for enabling logging info.\");\n\nstatic ulong link_rate = LINKRATE_15 | LINKRATE_30 | LINKRATE_60 | LINKRATE_120;\nmodule_param(link_rate, ulong, 0644);\nMODULE_PARM_DESC(link_rate, \"Enable link rate.\\n\"\n\t\t\" 1: Link rate 1.5G\\n\"\n\t\t\" 2: Link rate 3.0G\\n\"\n\t\t\" 4: Link rate 6.0G\\n\"\n\t\t\" 8: Link rate 12.0G\\n\");\n\nstatic struct scsi_transport_template *pm8001_stt;\nstatic int pm8001_init_ccb_tag(struct pm8001_hba_info *);\n\n \nstatic const struct pm8001_chip_info pm8001_chips[] = {\n\t[chip_8001] = {0,  8, &pm8001_8001_dispatch,},\n\t[chip_8008] = {0,  8, &pm8001_80xx_dispatch,},\n\t[chip_8009] = {1,  8, &pm8001_80xx_dispatch,},\n\t[chip_8018] = {0,  16, &pm8001_80xx_dispatch,},\n\t[chip_8019] = {1,  16, &pm8001_80xx_dispatch,},\n\t[chip_8074] = {0,  8, &pm8001_80xx_dispatch,},\n\t[chip_8076] = {0,  16, &pm8001_80xx_dispatch,},\n\t[chip_8077] = {0,  16, &pm8001_80xx_dispatch,},\n\t[chip_8006] = {0,  16, &pm8001_80xx_dispatch,},\n\t[chip_8070] = {0,  8, &pm8001_80xx_dispatch,},\n\t[chip_8072] = {0,  16, &pm8001_80xx_dispatch,},\n};\nstatic int pm8001_id;\n\nLIST_HEAD(hba_list);\n\nstruct workqueue_struct *pm8001_wq;\n\nstatic void pm8001_map_queues(struct Scsi_Host *shost)\n{\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tstruct blk_mq_queue_map *qmap = &shost->tag_set.map[HCTX_TYPE_DEFAULT];\n\n\tif (pm8001_ha->number_of_intr > 1)\n\t\tblk_mq_pci_map_queues(qmap, pm8001_ha->pdev, 1);\n\n\treturn blk_mq_map_queues(qmap);\n}\n\n \nstatic const struct scsi_host_template pm8001_sht = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= DRV_NAME,\n\t.proc_name\t\t= DRV_NAME,\n\t.queuecommand\t\t= sas_queuecommand,\n\t.dma_need_drain\t\t= ata_scsi_dma_need_drain,\n\t.target_alloc\t\t= sas_target_alloc,\n\t.slave_configure\t= sas_slave_configure,\n\t.scan_finished\t\t= pm8001_scan_finished,\n\t.scan_start\t\t= pm8001_scan_start,\n\t.change_queue_depth\t= sas_change_queue_depth,\n\t.bios_param\t\t= sas_bios_param,\n\t.can_queue\t\t= 1,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= PM8001_MAX_DMA_SG,\n\t.max_sectors\t\t= SCSI_DEFAULT_MAX_SECTORS,\n\t.eh_device_reset_handler = sas_eh_device_reset_handler,\n\t.eh_target_reset_handler = sas_eh_target_reset_handler,\n\t.slave_alloc\t\t= sas_slave_alloc,\n\t.target_destroy\t\t= sas_target_destroy,\n\t.ioctl\t\t\t= sas_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= sas_ioctl,\n#endif\n\t.shost_groups\t\t= pm8001_host_groups,\n\t.track_queue_depth\t= 1,\n\t.cmd_per_lun\t\t= 32,\n\t.map_queues\t\t= pm8001_map_queues,\n};\n\n \nstatic struct sas_domain_function_template pm8001_transport_ops = {\n\t.lldd_dev_found\t\t= pm8001_dev_found,\n\t.lldd_dev_gone\t\t= pm8001_dev_gone,\n\n\t.lldd_execute_task\t= pm8001_queue_command,\n\t.lldd_control_phy\t= pm8001_phy_control,\n\n\t.lldd_abort_task\t= pm8001_abort_task,\n\t.lldd_abort_task_set\t= sas_abort_task_set,\n\t.lldd_clear_task_set\t= pm8001_clear_task_set,\n\t.lldd_I_T_nexus_reset   = pm8001_I_T_nexus_reset,\n\t.lldd_lu_reset\t\t= pm8001_lu_reset,\n\t.lldd_query_task\t= pm8001_query_task,\n\t.lldd_port_formed\t= pm8001_port_formed,\n\t.lldd_tmf_exec_complete = pm8001_setds_completion,\n\t.lldd_tmf_aborted\t= pm8001_tmf_aborted,\n};\n\n \nstatic void pm8001_phy_init(struct pm8001_hba_info *pm8001_ha, int phy_id)\n{\n\tstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tphy->phy_state = PHY_LINK_DISABLE;\n\tphy->pm8001_ha = pm8001_ha;\n\tphy->minimum_linkrate = SAS_LINK_RATE_1_5_GBPS;\n\tphy->maximum_linkrate = SAS_LINK_RATE_6_0_GBPS;\n\tsas_phy->enabled = (phy_id < pm8001_ha->chip->n_phy) ? 1 : 0;\n\tsas_phy->iproto = SAS_PROTOCOL_ALL;\n\tsas_phy->tproto = 0;\n\tsas_phy->role = PHY_ROLE_INITIATOR;\n\tsas_phy->oob_mode = OOB_NOT_CONNECTED;\n\tsas_phy->linkrate = SAS_LINK_RATE_UNKNOWN;\n\tsas_phy->id = phy_id;\n\tsas_phy->sas_addr = (u8 *)&phy->dev_sas_addr;\n\tsas_phy->frame_rcvd = &phy->frame_rcvd[0];\n\tsas_phy->ha = (struct sas_ha_struct *)pm8001_ha->shost->hostdata;\n\tsas_phy->lldd_phy = phy;\n}\n\n \nstatic void pm8001_free(struct pm8001_hba_info *pm8001_ha)\n{\n\tint i;\n\n\tif (!pm8001_ha)\n\t\treturn;\n\n\tfor (i = 0; i < USI_MAX_MEMCNT; i++) {\n\t\tif (pm8001_ha->memoryMap.region[i].virt_ptr != NULL) {\n\t\t\tdma_free_coherent(&pm8001_ha->pdev->dev,\n\t\t\t\t(pm8001_ha->memoryMap.region[i].total_len +\n\t\t\t\tpm8001_ha->memoryMap.region[i].alignment),\n\t\t\t\tpm8001_ha->memoryMap.region[i].virt_ptr,\n\t\t\t\tpm8001_ha->memoryMap.region[i].phys_addr);\n\t\t\t}\n\t}\n\tPM8001_CHIP_DISP->chip_iounmap(pm8001_ha);\n\tflush_workqueue(pm8001_wq);\n\tbitmap_free(pm8001_ha->rsvd_tags);\n\tkfree(pm8001_ha);\n}\n\n#ifdef PM8001_USE_TASKLET\n\n \nstatic void pm8001_tasklet(unsigned long opaque)\n{\n\tstruct pm8001_hba_info *pm8001_ha;\n\tstruct isr_param *irq_vector;\n\n\tirq_vector = (struct isr_param *)opaque;\n\tpm8001_ha = irq_vector->drv_inst;\n\tif (unlikely(!pm8001_ha))\n\t\tBUG_ON(1);\n\tPM8001_CHIP_DISP->isr(pm8001_ha, irq_vector->irq_id);\n}\n#endif\n\n \nstatic irqreturn_t pm8001_interrupt_handler_msix(int irq, void *opaque)\n{\n\tstruct isr_param *irq_vector;\n\tstruct pm8001_hba_info *pm8001_ha;\n\tirqreturn_t ret = IRQ_HANDLED;\n\tirq_vector = (struct isr_param *)opaque;\n\tpm8001_ha = irq_vector->drv_inst;\n\n\tif (unlikely(!pm8001_ha))\n\t\treturn IRQ_NONE;\n\tif (!PM8001_CHIP_DISP->is_our_interrupt(pm8001_ha))\n\t\treturn IRQ_NONE;\n#ifdef PM8001_USE_TASKLET\n\ttasklet_schedule(&pm8001_ha->tasklet[irq_vector->irq_id]);\n#else\n\tret = PM8001_CHIP_DISP->isr(pm8001_ha, irq_vector->irq_id);\n#endif\n\treturn ret;\n}\n\n \n\nstatic irqreturn_t pm8001_interrupt_handler_intx(int irq, void *dev_id)\n{\n\tstruct pm8001_hba_info *pm8001_ha;\n\tirqreturn_t ret = IRQ_HANDLED;\n\tstruct sas_ha_struct *sha = dev_id;\n\tpm8001_ha = sha->lldd_ha;\n\tif (unlikely(!pm8001_ha))\n\t\treturn IRQ_NONE;\n\tif (!PM8001_CHIP_DISP->is_our_interrupt(pm8001_ha))\n\t\treturn IRQ_NONE;\n\n#ifdef PM8001_USE_TASKLET\n\ttasklet_schedule(&pm8001_ha->tasklet[0]);\n#else\n\tret = PM8001_CHIP_DISP->isr(pm8001_ha, 0);\n#endif\n\treturn ret;\n}\n\nstatic u32 pm8001_request_irq(struct pm8001_hba_info *pm8001_ha);\n\n \nstatic int pm8001_alloc(struct pm8001_hba_info *pm8001_ha,\n\t\t\tconst struct pci_device_id *ent)\n{\n\tint i, count = 0, rc = 0;\n\tu32 ci_offset, ib_offset, ob_offset, pi_offset;\n\tstruct inbound_queue_table *ibq;\n\tstruct outbound_queue_table *obq;\n\n\tspin_lock_init(&pm8001_ha->lock);\n\tspin_lock_init(&pm8001_ha->bitmap_lock);\n\tpm8001_dbg(pm8001_ha, INIT, \"pm8001_alloc: PHY:%x\\n\",\n\t\t   pm8001_ha->chip->n_phy);\n\n\t \n\trc = pm8001_request_irq(pm8001_ha);\n\tif (rc)\n\t\tgoto err_out;\n\n\tcount = pm8001_ha->max_q_num;\n\t \n\tib_offset = pm8001_ha->ib_offset  = USI_MAX_MEMCNT_BASE;\n\tci_offset = pm8001_ha->ci_offset  = ib_offset + count;\n\tob_offset = pm8001_ha->ob_offset  = ci_offset + count;\n\tpi_offset = pm8001_ha->pi_offset  = ob_offset + count;\n\tpm8001_ha->max_memcnt = pi_offset + count;\n\n\tfor (i = 0; i < pm8001_ha->chip->n_phy; i++) {\n\t\tpm8001_phy_init(pm8001_ha, i);\n\t\tpm8001_ha->port[i].wide_port_phymap = 0;\n\t\tpm8001_ha->port[i].port_attached = 0;\n\t\tpm8001_ha->port[i].port_state = 0;\n\t\tINIT_LIST_HEAD(&pm8001_ha->port[i].list);\n\t}\n\n\t \n\tpm8001_ha->memoryMap.region[AAP1].num_elements = 1;\n\tpm8001_ha->memoryMap.region[AAP1].element_size = PM8001_EVENT_LOG_SIZE;\n\tpm8001_ha->memoryMap.region[AAP1].total_len = PM8001_EVENT_LOG_SIZE;\n\tpm8001_ha->memoryMap.region[AAP1].alignment = 32;\n\n\t \n\tpm8001_ha->memoryMap.region[IOP].num_elements = 1;\n\tpm8001_ha->memoryMap.region[IOP].element_size = PM8001_EVENT_LOG_SIZE;\n\tpm8001_ha->memoryMap.region[IOP].total_len = PM8001_EVENT_LOG_SIZE;\n\tpm8001_ha->memoryMap.region[IOP].alignment = 32;\n\n\tfor (i = 0; i < count; i++) {\n\t\tibq = &pm8001_ha->inbnd_q_tbl[i];\n\t\tspin_lock_init(&ibq->iq_lock);\n\t\t \n\t\tpm8001_ha->memoryMap.region[ci_offset+i].num_elements = 1;\n\t\tpm8001_ha->memoryMap.region[ci_offset+i].element_size = 4;\n\t\tpm8001_ha->memoryMap.region[ci_offset+i].total_len = 4;\n\t\tpm8001_ha->memoryMap.region[ci_offset+i].alignment = 4;\n\n\t\tif ((ent->driver_data) != chip_8001) {\n\t\t\t \n\t\t\tpm8001_ha->memoryMap.region[ib_offset+i].num_elements =\n\t\t\t\t\t\tPM8001_MPI_QUEUE;\n\t\t\tpm8001_ha->memoryMap.region[ib_offset+i].element_size\n\t\t\t\t\t\t\t\t= 128;\n\t\t\tpm8001_ha->memoryMap.region[ib_offset+i].total_len =\n\t\t\t\t\t\tPM8001_MPI_QUEUE * 128;\n\t\t\tpm8001_ha->memoryMap.region[ib_offset+i].alignment\n\t\t\t\t\t\t\t\t= 128;\n\t\t} else {\n\t\t\tpm8001_ha->memoryMap.region[ib_offset+i].num_elements =\n\t\t\t\t\t\tPM8001_MPI_QUEUE;\n\t\t\tpm8001_ha->memoryMap.region[ib_offset+i].element_size\n\t\t\t\t\t\t\t\t= 64;\n\t\t\tpm8001_ha->memoryMap.region[ib_offset+i].total_len =\n\t\t\t\t\t\tPM8001_MPI_QUEUE * 64;\n\t\t\tpm8001_ha->memoryMap.region[ib_offset+i].alignment = 64;\n\t\t}\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tobq = &pm8001_ha->outbnd_q_tbl[i];\n\t\tspin_lock_init(&obq->oq_lock);\n\t\t \n\t\tpm8001_ha->memoryMap.region[pi_offset+i].num_elements = 1;\n\t\tpm8001_ha->memoryMap.region[pi_offset+i].element_size = 4;\n\t\tpm8001_ha->memoryMap.region[pi_offset+i].total_len = 4;\n\t\tpm8001_ha->memoryMap.region[pi_offset+i].alignment = 4;\n\n\t\tif (ent->driver_data != chip_8001) {\n\t\t\t \n\t\t\tpm8001_ha->memoryMap.region[ob_offset+i].num_elements =\n\t\t\t\t\t\tPM8001_MPI_QUEUE;\n\t\t\tpm8001_ha->memoryMap.region[ob_offset+i].element_size\n\t\t\t\t\t\t\t\t= 128;\n\t\t\tpm8001_ha->memoryMap.region[ob_offset+i].total_len =\n\t\t\t\t\t\tPM8001_MPI_QUEUE * 128;\n\t\t\tpm8001_ha->memoryMap.region[ob_offset+i].alignment\n\t\t\t\t\t\t\t\t= 128;\n\t\t} else {\n\t\t\t \n\t\t\tpm8001_ha->memoryMap.region[ob_offset+i].num_elements =\n\t\t\t\t\t\tPM8001_MPI_QUEUE;\n\t\t\tpm8001_ha->memoryMap.region[ob_offset+i].element_size\n\t\t\t\t\t\t\t\t= 64;\n\t\t\tpm8001_ha->memoryMap.region[ob_offset+i].total_len =\n\t\t\t\t\t\tPM8001_MPI_QUEUE * 64;\n\t\t\tpm8001_ha->memoryMap.region[ob_offset+i].alignment = 64;\n\t\t}\n\n\t}\n\t \n\tpm8001_ha->memoryMap.region[NVMD].num_elements = 1;\n\tpm8001_ha->memoryMap.region[NVMD].element_size = 4096;\n\tpm8001_ha->memoryMap.region[NVMD].total_len = 4096;\n\n\t \n\tpm8001_ha->memoryMap.region[FW_FLASH].total_len = 4096;\n\n\tpm8001_ha->memoryMap.region[FORENSIC_MEM].num_elements = 1;\n\tpm8001_ha->memoryMap.region[FORENSIC_MEM].total_len = 0x10000;\n\tpm8001_ha->memoryMap.region[FORENSIC_MEM].element_size = 0x10000;\n\tpm8001_ha->memoryMap.region[FORENSIC_MEM].alignment = 0x10000;\n\tfor (i = 0; i < pm8001_ha->max_memcnt; i++) {\n\t\tstruct mpi_mem *region = &pm8001_ha->memoryMap.region[i];\n\n\t\tif (pm8001_mem_alloc(pm8001_ha->pdev,\n\t\t\t\t     &region->virt_ptr,\n\t\t\t\t     &region->phys_addr,\n\t\t\t\t     &region->phys_addr_hi,\n\t\t\t\t     &region->phys_addr_lo,\n\t\t\t\t     region->total_len,\n\t\t\t\t     region->alignment) != 0) {\n\t\t\tpm8001_dbg(pm8001_ha, FAIL, \"Mem%d alloc failed\\n\", i);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\t \n\tpm8001_ha->devices = kzalloc(PM8001_MAX_DEVICES\n\t\t\t\t* sizeof(struct pm8001_device), GFP_KERNEL);\n\tif (!pm8001_ha->devices) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_nodev;\n\t}\n\tfor (i = 0; i < PM8001_MAX_DEVICES; i++) {\n\t\tpm8001_ha->devices[i].dev_type = SAS_PHY_UNUSED;\n\t\tpm8001_ha->devices[i].id = i;\n\t\tpm8001_ha->devices[i].device_id = PM8001_MAX_DEVICES;\n\t\tatomic_set(&pm8001_ha->devices[i].running_req, 0);\n\t}\n\tpm8001_ha->flags = PM8001F_INIT_TIME;\n\treturn 0;\n\nerr_out_nodev:\n\tfor (i = 0; i < pm8001_ha->max_memcnt; i++) {\n\t\tif (pm8001_ha->memoryMap.region[i].virt_ptr != NULL) {\n\t\t\tdma_free_coherent(&pm8001_ha->pdev->dev,\n\t\t\t\t(pm8001_ha->memoryMap.region[i].total_len +\n\t\t\t\tpm8001_ha->memoryMap.region[i].alignment),\n\t\t\t\tpm8001_ha->memoryMap.region[i].virt_ptr,\n\t\t\t\tpm8001_ha->memoryMap.region[i].phys_addr);\n\t\t}\n\t}\nerr_out:\n\treturn 1;\n}\n\n \nstatic int pm8001_ioremap(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32 bar;\n\tu32 logicalBar = 0;\n\tstruct pci_dev *pdev;\n\n\tpdev = pm8001_ha->pdev;\n\t \n\tfor (bar = 0; bar < PCI_STD_NUM_BARS; bar++) {\n\t\t \n\t\tif ((bar == 1) || (bar == 3))\n\t\t\tcontinue;\n\t\tif (pci_resource_flags(pdev, bar) & IORESOURCE_MEM) {\n\t\t\tpm8001_ha->io_mem[logicalBar].membase =\n\t\t\t\tpci_resource_start(pdev, bar);\n\t\t\tpm8001_ha->io_mem[logicalBar].memsize =\n\t\t\t\tpci_resource_len(pdev, bar);\n\t\t\tpm8001_ha->io_mem[logicalBar].memvirtaddr =\n\t\t\t\tioremap(pm8001_ha->io_mem[logicalBar].membase,\n\t\t\t\tpm8001_ha->io_mem[logicalBar].memsize);\n\t\t\tif (!pm8001_ha->io_mem[logicalBar].memvirtaddr) {\n\t\t\t\tpm8001_dbg(pm8001_ha, INIT,\n\t\t\t\t\t\"Failed to ioremap bar %d, logicalBar %d\",\n\t\t\t\t   bar, logicalBar);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tpm8001_dbg(pm8001_ha, INIT,\n\t\t\t\t   \"base addr %llx virt_addr=%llx len=%d\\n\",\n\t\t\t\t   (u64)pm8001_ha->io_mem[logicalBar].membase,\n\t\t\t\t   (u64)(unsigned long)\n\t\t\t\t   pm8001_ha->io_mem[logicalBar].memvirtaddr,\n\t\t\t\t   pm8001_ha->io_mem[logicalBar].memsize);\n\t\t} else {\n\t\t\tpm8001_ha->io_mem[logicalBar].membase\t= 0;\n\t\t\tpm8001_ha->io_mem[logicalBar].memsize\t= 0;\n\t\t\tpm8001_ha->io_mem[logicalBar].memvirtaddr = NULL;\n\t\t}\n\t\tlogicalBar++;\n\t}\n\treturn 0;\n}\n\n \nstatic struct pm8001_hba_info *pm8001_pci_alloc(struct pci_dev *pdev,\n\t\t\t\t const struct pci_device_id *ent,\n\t\t\t\tstruct Scsi_Host *shost)\n\n{\n\tstruct pm8001_hba_info *pm8001_ha;\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tint j;\n\n\tpm8001_ha = sha->lldd_ha;\n\tif (!pm8001_ha)\n\t\treturn NULL;\n\n\tpm8001_ha->pdev = pdev;\n\tpm8001_ha->dev = &pdev->dev;\n\tpm8001_ha->chip_id = ent->driver_data;\n\tpm8001_ha->chip = &pm8001_chips[pm8001_ha->chip_id];\n\tpm8001_ha->irq = pdev->irq;\n\tpm8001_ha->sas = sha;\n\tpm8001_ha->shost = shost;\n\tpm8001_ha->id = pm8001_id++;\n\tpm8001_ha->logging_level = logging_level;\n\tpm8001_ha->non_fatal_count = 0;\n\tif (link_rate >= 1 && link_rate <= 15)\n\t\tpm8001_ha->link_rate = (link_rate << 8);\n\telse {\n\t\tpm8001_ha->link_rate = LINKRATE_15 | LINKRATE_30 |\n\t\t\tLINKRATE_60 | LINKRATE_120;\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"Setting link rate to default value\\n\");\n\t}\n\tsprintf(pm8001_ha->name, \"%s%d\", DRV_NAME, pm8001_ha->id);\n\t \n\tif (pm8001_ha->chip_id != chip_8001)\n\t\tpm8001_ha->iomb_size = IOMB_SIZE_SPCV;\n\telse\n\t\tpm8001_ha->iomb_size = IOMB_SIZE_SPC;\n\n#ifdef PM8001_USE_TASKLET\n\t \n\tif ((!pdev->msix_cap || !pci_msi_enabled())\n\t    || (pm8001_ha->chip_id == chip_8001))\n\t\ttasklet_init(&pm8001_ha->tasklet[0], pm8001_tasklet,\n\t\t\t(unsigned long)&(pm8001_ha->irq_vector[0]));\n\telse\n\t\tfor (j = 0; j < PM8001_MAX_MSIX_VEC; j++)\n\t\t\ttasklet_init(&pm8001_ha->tasklet[j], pm8001_tasklet,\n\t\t\t\t(unsigned long)&(pm8001_ha->irq_vector[j]));\n#endif\n\tif (pm8001_ioremap(pm8001_ha))\n\t\tgoto failed_pci_alloc;\n\tif (!pm8001_alloc(pm8001_ha, ent))\n\t\treturn pm8001_ha;\nfailed_pci_alloc:\n\tpm8001_free(pm8001_ha);\n\treturn NULL;\n}\n\n \nstatic int pci_go_44(struct pci_dev *pdev)\n{\n\tint rc;\n\n\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(44));\n\tif (rc) {\n\t\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (rc)\n\t\t\tdev_printk(KERN_ERR, &pdev->dev,\n\t\t\t\t\"32-bit DMA enable failed\\n\");\n\t}\n\treturn rc;\n}\n\n \nstatic int pm8001_prep_sas_ha_init(struct Scsi_Host *shost,\n\t\t\t\t   const struct pm8001_chip_info *chip_info)\n{\n\tint phy_nr, port_nr;\n\tstruct asd_sas_phy **arr_phy;\n\tstruct asd_sas_port **arr_port;\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\n\tphy_nr = chip_info->n_phy;\n\tport_nr = phy_nr;\n\tmemset(sha, 0x00, sizeof(*sha));\n\tarr_phy = kcalloc(phy_nr, sizeof(void *), GFP_KERNEL);\n\tif (!arr_phy)\n\t\tgoto exit;\n\tarr_port = kcalloc(port_nr, sizeof(void *), GFP_KERNEL);\n\tif (!arr_port)\n\t\tgoto exit_free2;\n\n\tsha->sas_phy = arr_phy;\n\tsha->sas_port = arr_port;\n\tsha->lldd_ha = kzalloc(sizeof(struct pm8001_hba_info), GFP_KERNEL);\n\tif (!sha->lldd_ha)\n\t\tgoto exit_free1;\n\n\tshost->transportt = pm8001_stt;\n\tshost->max_id = PM8001_MAX_DEVICES;\n\tshost->unique_id = pm8001_id;\n\tshost->max_cmd_len = 16;\n\treturn 0;\nexit_free1:\n\tkfree(arr_port);\nexit_free2:\n\tkfree(arr_phy);\nexit:\n\treturn -1;\n}\n\n \nstatic void  pm8001_post_sas_ha_init(struct Scsi_Host *shost,\n\t\t\t\t     const struct pm8001_chip_info *chip_info)\n{\n\tint i = 0;\n\tstruct pm8001_hba_info *pm8001_ha;\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\n\tpm8001_ha = sha->lldd_ha;\n\tfor (i = 0; i < chip_info->n_phy; i++) {\n\t\tsha->sas_phy[i] = &pm8001_ha->phy[i].sas_phy;\n\t\tsha->sas_port[i] = &pm8001_ha->port[i].sas_port;\n\t\tsha->sas_phy[i]->sas_addr =\n\t\t\t(u8 *)&pm8001_ha->phy[i].dev_sas_addr;\n\t}\n\tsha->sas_ha_name = DRV_NAME;\n\tsha->dev = pm8001_ha->dev;\n\tsha->strict_wide_ports = 1;\n\tsha->sas_addr = &pm8001_ha->sas_addr[0];\n\tsha->num_phys = chip_info->n_phy;\n\tsha->shost = shost;\n}\n\n \nstatic int pm8001_init_sas_add(struct pm8001_hba_info *pm8001_ha)\n{\n\tu8 i, j;\n\tu8 sas_add[8];\n#ifdef PM8001_READ_VPD\n\t \n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tstruct pm8001_ioctl_payload payload;\n\tu16 deviceid;\n\tint rc;\n\tunsigned long time_remaining;\n\n\tif (PM8001_CHIP_DISP->fatal_errors(pm8001_ha)) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"controller is in fatal error state\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpci_read_config_word(pm8001_ha->pdev, PCI_DEVICE_ID, &deviceid);\n\tpm8001_ha->nvmd_completion = &completion;\n\n\tif (pm8001_ha->chip_id == chip_8001) {\n\t\tif (deviceid == 0x8081 || deviceid == 0x0042) {\n\t\t\tpayload.minor_function = 4;\n\t\t\tpayload.rd_length = 4096;\n\t\t} else {\n\t\t\tpayload.minor_function = 0;\n\t\t\tpayload.rd_length = 128;\n\t\t}\n\t} else if ((pm8001_ha->chip_id == chip_8070 ||\n\t\t\tpm8001_ha->chip_id == chip_8072) &&\n\t\t\tpm8001_ha->pdev->subsystem_vendor == PCI_VENDOR_ID_ATTO) {\n\t\tpayload.minor_function = 4;\n\t\tpayload.rd_length = 4096;\n\t} else {\n\t\tpayload.minor_function = 1;\n\t\tpayload.rd_length = 4096;\n\t}\n\tpayload.offset = 0;\n\tpayload.func_specific = kzalloc(payload.rd_length, GFP_KERNEL);\n\tif (!payload.func_specific) {\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"mem alloc fail\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trc = PM8001_CHIP_DISP->get_nvmd_req(pm8001_ha, &payload);\n\tif (rc) {\n\t\tkfree(payload.func_specific);\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"nvmd failed\\n\");\n\t\treturn -EIO;\n\t}\n\ttime_remaining = wait_for_completion_timeout(&completion,\n\t\t\t\tmsecs_to_jiffies(60*1000)); \n\tif (!time_remaining) {\n\t\tkfree(payload.func_specific);\n\t\tpm8001_dbg(pm8001_ha, FAIL, \"get_nvmd_req timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\n\tfor (i = 0, j = 0; i <= 7; i++, j++) {\n\t\tif (pm8001_ha->chip_id == chip_8001) {\n\t\t\tif (deviceid == 0x8081)\n\t\t\t\tpm8001_ha->sas_addr[j] =\n\t\t\t\t\tpayload.func_specific[0x704 + i];\n\t\t\telse if (deviceid == 0x0042)\n\t\t\t\tpm8001_ha->sas_addr[j] =\n\t\t\t\t\tpayload.func_specific[0x010 + i];\n\t\t} else if ((pm8001_ha->chip_id == chip_8070 ||\n\t\t\t\tpm8001_ha->chip_id == chip_8072) &&\n\t\t\t\tpm8001_ha->pdev->subsystem_vendor == PCI_VENDOR_ID_ATTO) {\n\t\t\tpm8001_ha->sas_addr[j] =\n\t\t\t\t\tpayload.func_specific[0x010 + i];\n\t\t} else\n\t\t\tpm8001_ha->sas_addr[j] =\n\t\t\t\t\tpayload.func_specific[0x804 + i];\n\t}\n\tmemcpy(sas_add, pm8001_ha->sas_addr, SAS_ADDR_SIZE);\n\tfor (i = 0; i < pm8001_ha->chip->n_phy; i++) {\n\t\tif (i && ((i % 4) == 0))\n\t\t\tsas_add[7] = sas_add[7] + 4;\n\t\tmemcpy(&pm8001_ha->phy[i].dev_sas_addr,\n\t\t\tsas_add, SAS_ADDR_SIZE);\n\t\tpm8001_dbg(pm8001_ha, INIT, \"phy %d sas_addr = %016llx\\n\", i,\n\t\t\t   pm8001_ha->phy[i].dev_sas_addr);\n\t}\n\tkfree(payload.func_specific);\n#else\n\tfor (i = 0; i < pm8001_ha->chip->n_phy; i++) {\n\t\tpm8001_ha->phy[i].dev_sas_addr = 0x50010c600047f9d0ULL;\n\t\tpm8001_ha->phy[i].dev_sas_addr =\n\t\t\tcpu_to_be64((u64)\n\t\t\t\t(*(u64 *)&pm8001_ha->phy[i].dev_sas_addr));\n\t}\n\tmemcpy(pm8001_ha->sas_addr, &pm8001_ha->phy[0].dev_sas_addr,\n\t\tSAS_ADDR_SIZE);\n#endif\n\treturn 0;\n}\n\n \nstatic int pm8001_get_phy_settings_info(struct pm8001_hba_info *pm8001_ha)\n{\n\n#ifdef PM8001_READ_VPD\n\t \n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tstruct pm8001_ioctl_payload payload;\n\tint rc;\n\n\tpm8001_ha->nvmd_completion = &completion;\n\t \n\tpayload.minor_function = 6;\n\tpayload.offset = 0;\n\tpayload.rd_length = 4096;\n\tpayload.func_specific = kzalloc(4096, GFP_KERNEL);\n\tif (!payload.func_specific)\n\t\treturn -ENOMEM;\n\t \n\trc = PM8001_CHIP_DISP->get_nvmd_req(pm8001_ha, &payload);\n\tif (rc) {\n\t\tkfree(payload.func_specific);\n\t\tpm8001_dbg(pm8001_ha, INIT, \"nvmd failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\twait_for_completion(&completion);\n\tpm8001_set_phy_profile(pm8001_ha, sizeof(u8), payload.func_specific);\n\tkfree(payload.func_specific);\n#endif\n\treturn 0;\n}\n\nstruct pm8001_mpi3_phy_pg_trx_config {\n\tu32 LaneLosCfg;\n\tu32 LanePgaCfg1;\n\tu32 LanePisoCfg1;\n\tu32 LanePisoCfg2;\n\tu32 LanePisoCfg3;\n\tu32 LanePisoCfg4;\n\tu32 LanePisoCfg5;\n\tu32 LanePisoCfg6;\n\tu32 LaneBctCtrl;\n};\n\n \nstatic\nvoid pm8001_get_internal_phy_settings(struct pm8001_hba_info *pm8001_ha,\n\t\tstruct pm8001_mpi3_phy_pg_trx_config *phycfg)\n{\n\tphycfg->LaneLosCfg   = 0x00000132;\n\tphycfg->LanePgaCfg1  = 0x00203949;\n\tphycfg->LanePisoCfg1 = 0x000000FF;\n\tphycfg->LanePisoCfg2 = 0xFF000001;\n\tphycfg->LanePisoCfg3 = 0xE7011300;\n\tphycfg->LanePisoCfg4 = 0x631C40C0;\n\tphycfg->LanePisoCfg5 = 0xF8102036;\n\tphycfg->LanePisoCfg6 = 0xF74A1000;\n\tphycfg->LaneBctCtrl  = 0x00FB33F8;\n}\n\n \nstatic\nvoid pm8001_get_external_phy_settings(struct pm8001_hba_info *pm8001_ha,\n\t\tstruct pm8001_mpi3_phy_pg_trx_config *phycfg)\n{\n\tphycfg->LaneLosCfg   = 0x00000132;\n\tphycfg->LanePgaCfg1  = 0x00203949;\n\tphycfg->LanePisoCfg1 = 0x000000FF;\n\tphycfg->LanePisoCfg2 = 0xFF000001;\n\tphycfg->LanePisoCfg3 = 0xE7011300;\n\tphycfg->LanePisoCfg4 = 0x63349140;\n\tphycfg->LanePisoCfg5 = 0xF8102036;\n\tphycfg->LanePisoCfg6 = 0xF80D9300;\n\tphycfg->LaneBctCtrl  = 0x00FB33F8;\n}\n\n \nstatic\nvoid pm8001_get_phy_mask(struct pm8001_hba_info *pm8001_ha, int *phymask)\n{\n\tswitch (pm8001_ha->pdev->subsystem_device) {\n\tcase 0x0070:  \n\tcase 0x0072:  \n\t\t*phymask = 0x0000;\n\t\tbreak;\n\n\tcase 0x0071:  \n\tcase 0x0073:  \n\t\t*phymask = 0xFFFF;\n\t\tbreak;\n\n\tcase 0x0080:  \n\t\t*phymask = 0x00F0;\n\t\tbreak;\n\n\tcase 0x0081:  \n\t\t*phymask = 0x0FF0;\n\t\tbreak;\n\n\tcase 0x0082:  \n\t\t*phymask = 0xFF00;\n\t\tbreak;\n\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, INIT,\n\t\t\t   \"Unknown subsystem device=0x%.04x\\n\",\n\t\t\t   pm8001_ha->pdev->subsystem_device);\n\t}\n}\n\n \nstatic\nint pm8001_set_phy_settings_ven_117c_12G(struct pm8001_hba_info *pm8001_ha)\n{\n\tstruct pm8001_mpi3_phy_pg_trx_config phycfg_int;\n\tstruct pm8001_mpi3_phy_pg_trx_config phycfg_ext;\n\tint phymask = 0;\n\tint i = 0;\n\n\tmemset(&phycfg_int, 0, sizeof(phycfg_int));\n\tmemset(&phycfg_ext, 0, sizeof(phycfg_ext));\n\n\tpm8001_get_internal_phy_settings(pm8001_ha, &phycfg_int);\n\tpm8001_get_external_phy_settings(pm8001_ha, &phycfg_ext);\n\tpm8001_get_phy_mask(pm8001_ha, &phymask);\n\n\tfor (i = 0; i < pm8001_ha->chip->n_phy; i++) {\n\t\tif (phymask & (1 << i)) { \n\t\t\tpm8001_set_phy_profile_single(pm8001_ha, i,\n\t\t\t\t\tsizeof(phycfg_int) / sizeof(u32),\n\t\t\t\t\t(u32 *)&phycfg_int);\n\n\t\t} else {  \n\t\t\tpm8001_set_phy_profile_single(pm8001_ha, i,\n\t\t\t\t\tsizeof(phycfg_ext) / sizeof(u32),\n\t\t\t\t\t(u32 *)&phycfg_ext);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pm8001_configure_phy_settings(struct pm8001_hba_info *pm8001_ha)\n{\n\tswitch (pm8001_ha->pdev->subsystem_vendor) {\n\tcase PCI_VENDOR_ID_ATTO:\n\t\tif (pm8001_ha->pdev->device == 0x0042)  \n\t\t\treturn 0;\n\t\telse\n\t\t\treturn pm8001_set_phy_settings_ven_117c_12G(pm8001_ha);\n\n\tcase PCI_VENDOR_ID_ADAPTEC2:\n\tcase 0:\n\t\treturn 0;\n\n\tdefault:\n\t\treturn pm8001_get_phy_settings_info(pm8001_ha);\n\t}\n}\n\n#ifdef PM8001_USE_MSIX\n \nstatic u32 pm8001_setup_msix(struct pm8001_hba_info *pm8001_ha)\n{\n\tunsigned int allocated_irq_vectors;\n\tint rc;\n\n\t \n\tif (pm8001_ha->chip_id == chip_8001) {\n\t\trc = pci_alloc_irq_vectors(pm8001_ha->pdev, 1, 1,\n\t\t\t\t\t   PCI_IRQ_MSIX);\n\t} else {\n\t\t \n\t\tstruct irq_affinity desc = {\n\t\t\t.pre_vectors = 1,\n\t\t};\n\t\trc = pci_alloc_irq_vectors_affinity(\n\t\t\t\tpm8001_ha->pdev, 2, PM8001_MAX_MSIX_VEC,\n\t\t\t\tPCI_IRQ_MSIX | PCI_IRQ_AFFINITY, &desc);\n\t}\n\n\tallocated_irq_vectors = rc;\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tpm8001_ha->number_of_intr = allocated_irq_vectors;\n\n\t \n\tpm8001_ha->max_q_num = allocated_irq_vectors;\n\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"pci_alloc_irq_vectors request ret:%d no of intr %d\\n\",\n\t\t   rc, pm8001_ha->number_of_intr);\n\treturn 0;\n}\n\nstatic u32 pm8001_request_msix(struct pm8001_hba_info *pm8001_ha)\n{\n\tu32 i = 0, j = 0;\n\tint flag = 0, rc = 0;\n\tint nr_irqs = pm8001_ha->number_of_intr;\n\n\tif (pm8001_ha->chip_id != chip_8001)\n\t\tflag &= ~IRQF_SHARED;\n\n\tpm8001_dbg(pm8001_ha, INIT,\n\t\t   \"pci_enable_msix request number of intr %d\\n\",\n\t\t   pm8001_ha->number_of_intr);\n\n\tif (nr_irqs > ARRAY_SIZE(pm8001_ha->intr_drvname))\n\t\tnr_irqs = ARRAY_SIZE(pm8001_ha->intr_drvname);\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tsnprintf(pm8001_ha->intr_drvname[i],\n\t\t\tsizeof(pm8001_ha->intr_drvname[0]),\n\t\t\t\"%s-%d\", pm8001_ha->name, i);\n\t\tpm8001_ha->irq_vector[i].irq_id = i;\n\t\tpm8001_ha->irq_vector[i].drv_inst = pm8001_ha;\n\n\t\trc = request_irq(pci_irq_vector(pm8001_ha->pdev, i),\n\t\t\tpm8001_interrupt_handler_msix, flag,\n\t\t\tpm8001_ha->intr_drvname[i],\n\t\t\t&(pm8001_ha->irq_vector[i]));\n\t\tif (rc) {\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tfree_irq(pci_irq_vector(pm8001_ha->pdev, i),\n\t\t\t\t\t&(pm8001_ha->irq_vector[i]));\n\t\t\t}\n\t\t\tpci_free_irq_vectors(pm8001_ha->pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}\n#endif\n\n \nstatic u32 pm8001_request_irq(struct pm8001_hba_info *pm8001_ha)\n{\n\tstruct pci_dev *pdev = pm8001_ha->pdev;\n#ifdef PM8001_USE_MSIX\n\tint rc;\n\n\tif (pci_find_capability(pdev, PCI_CAP_ID_MSIX)) {\n\t\trc = pm8001_setup_msix(pm8001_ha);\n\t\tif (rc) {\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"pm8001_setup_irq failed [ret: %d]\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (pdev->msix_cap && pci_msi_enabled())\n\t\t\treturn pm8001_request_msix(pm8001_ha);\n\t}\n\n\tpm8001_dbg(pm8001_ha, INIT, \"MSIX not supported!!!\\n\");\n#endif\n\n\t \n\tpm8001_ha->irq_vector[0].irq_id = 0;\n\tpm8001_ha->irq_vector[0].drv_inst = pm8001_ha;\n\n\treturn request_irq(pdev->irq, pm8001_interrupt_handler_intx,\n\t\t\t   IRQF_SHARED, pm8001_ha->name,\n\t\t\t   SHOST_TO_SAS_HA(pm8001_ha->shost));\n}\n\n \nstatic int pm8001_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tunsigned int rc;\n\tu32\tpci_reg;\n\tu8\ti = 0;\n\tstruct pm8001_hba_info *pm8001_ha;\n\tstruct Scsi_Host *shost = NULL;\n\tconst struct pm8001_chip_info *chip;\n\tstruct sas_ha_struct *sha;\n\n\tdev_printk(KERN_INFO, &pdev->dev,\n\t\t\"pm80xx: driver version %s\\n\", DRV_VERSION);\n\trc = pci_enable_device(pdev);\n\tif (rc)\n\t\tgoto err_out_enable;\n\tpci_set_master(pdev);\n\t \n\n\tpci_read_config_dword(pdev, PCI_COMMAND, &pci_reg);\n\tpci_reg |= 0x157;\n\tpci_write_config_dword(pdev, PCI_COMMAND, pci_reg);\n\trc = pci_request_regions(pdev, DRV_NAME);\n\tif (rc)\n\t\tgoto err_out_disable;\n\trc = pci_go_44(pdev);\n\tif (rc)\n\t\tgoto err_out_regions;\n\n\tshost = scsi_host_alloc(&pm8001_sht, sizeof(void *));\n\tif (!shost) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_regions;\n\t}\n\tchip = &pm8001_chips[ent->driver_data];\n\tsha = kzalloc(sizeof(struct sas_ha_struct), GFP_KERNEL);\n\tif (!sha) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_free_host;\n\t}\n\tSHOST_TO_SAS_HA(shost) = sha;\n\n\trc = pm8001_prep_sas_ha_init(shost, chip);\n\tif (rc) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_free;\n\t}\n\tpci_set_drvdata(pdev, SHOST_TO_SAS_HA(shost));\n\t \n\tpm8001_ha = pm8001_pci_alloc(pdev, ent, shost);\n\tif (!pm8001_ha) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_free;\n\t}\n\n\tPM8001_CHIP_DISP->chip_soft_rst(pm8001_ha);\n\trc = PM8001_CHIP_DISP->chip_init(pm8001_ha);\n\tif (rc) {\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"chip_init failed [ret: %d]\\n\", rc);\n\t\tgoto err_out_ha_free;\n\t}\n\n\trc = pm8001_init_ccb_tag(pm8001_ha);\n\tif (rc)\n\t\tgoto err_out_enable;\n\n\n\tPM8001_CHIP_DISP->chip_post_init(pm8001_ha);\n\n\tif (pm8001_ha->number_of_intr > 1) {\n\t\tshost->nr_hw_queues = pm8001_ha->number_of_intr - 1;\n\t\t \n\t\tshost->host_tagset = 1;\n\t}\n\n\trc = scsi_add_host(shost, &pdev->dev);\n\tif (rc)\n\t\tgoto err_out_ha_free;\n\n\tPM8001_CHIP_DISP->interrupt_enable(pm8001_ha, 0);\n\tif (pm8001_ha->chip_id != chip_8001) {\n\t\tfor (i = 1; i < pm8001_ha->number_of_intr; i++)\n\t\t\tPM8001_CHIP_DISP->interrupt_enable(pm8001_ha, i);\n\t\t \n\t\tpm80xx_set_thermal_config(pm8001_ha);\n\t}\n\n\trc = pm8001_init_sas_add(pm8001_ha);\n\tif (rc)\n\t\tgoto err_out_shost;\n\t \n\trc = pm8001_configure_phy_settings(pm8001_ha);\n\tif (rc)\n\t\tgoto err_out_shost;\n\n\tpm8001_post_sas_ha_init(shost, chip);\n\trc = sas_register_ha(SHOST_TO_SAS_HA(shost));\n\tif (rc) {\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"sas_register_ha failed [ret: %d]\\n\", rc);\n\t\tgoto err_out_shost;\n\t}\n\tlist_add_tail(&pm8001_ha->list, &hba_list);\n\tpm8001_ha->flags = PM8001F_RUN_TIME;\n\tscsi_scan_host(pm8001_ha->shost);\n\treturn 0;\n\nerr_out_shost:\n\tscsi_remove_host(pm8001_ha->shost);\nerr_out_ha_free:\n\tpm8001_free(pm8001_ha);\nerr_out_free:\n\tkfree(sha);\nerr_out_free_host:\n\tscsi_host_put(shost);\nerr_out_regions:\n\tpci_release_regions(pdev);\nerr_out_disable:\n\tpci_disable_device(pdev);\nerr_out_enable:\n\treturn rc;\n}\n\n \nstatic int pm8001_init_ccb_tag(struct pm8001_hba_info *pm8001_ha)\n{\n\tstruct Scsi_Host *shost = pm8001_ha->shost;\n\tstruct device *dev = pm8001_ha->dev;\n\tu32 max_out_io, ccb_count;\n\tint i;\n\n\tmax_out_io = pm8001_ha->main_cfg_tbl.pm80xx_tbl.max_out_io;\n\tccb_count = min_t(int, PM8001_MAX_CCB, max_out_io);\n\n\tshost->can_queue = ccb_count - PM8001_RESERVE_SLOT;\n\n\tpm8001_ha->rsvd_tags = bitmap_zalloc(PM8001_RESERVE_SLOT, GFP_KERNEL);\n\tif (!pm8001_ha->rsvd_tags)\n\t\tgoto err_out;\n\n\t \n\tpm8001_ha->ccb_count = ccb_count;\n\tpm8001_ha->ccb_info =\n\t\tkcalloc(ccb_count, sizeof(struct pm8001_ccb_info), GFP_KERNEL);\n\tif (!pm8001_ha->ccb_info) {\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"Unable to allocate memory for ccb\\n\");\n\t\tgoto err_out_noccb;\n\t}\n\tfor (i = 0; i < ccb_count; i++) {\n\t\tpm8001_ha->ccb_info[i].buf_prd = dma_alloc_coherent(dev,\n\t\t\t\tsizeof(struct pm8001_prd) * PM8001_MAX_DMA_SG,\n\t\t\t\t&pm8001_ha->ccb_info[i].ccb_dma_handle,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!pm8001_ha->ccb_info[i].buf_prd) {\n\t\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t\t   \"ccb prd memory allocation error\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tpm8001_ha->ccb_info[i].task = NULL;\n\t\tpm8001_ha->ccb_info[i].ccb_tag = PM8001_INVALID_TAG;\n\t\tpm8001_ha->ccb_info[i].device = NULL;\n\t}\n\n\treturn 0;\n\nerr_out_noccb:\n\tkfree(pm8001_ha->devices);\nerr_out:\n\treturn -ENOMEM;\n}\n\nstatic void pm8001_pci_remove(struct pci_dev *pdev)\n{\n\tstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\n\tstruct pm8001_hba_info *pm8001_ha;\n\tint i, j;\n\tpm8001_ha = sha->lldd_ha;\n\tsas_unregister_ha(sha);\n\tsas_remove_host(pm8001_ha->shost);\n\tlist_del(&pm8001_ha->list);\n\tPM8001_CHIP_DISP->interrupt_disable(pm8001_ha, 0xFF);\n\tPM8001_CHIP_DISP->chip_soft_rst(pm8001_ha);\n\n#ifdef PM8001_USE_MSIX\n\tfor (i = 0; i < pm8001_ha->number_of_intr; i++)\n\t\tsynchronize_irq(pci_irq_vector(pdev, i));\n\tfor (i = 0; i < pm8001_ha->number_of_intr; i++)\n\t\tfree_irq(pci_irq_vector(pdev, i), &pm8001_ha->irq_vector[i]);\n\tpci_free_irq_vectors(pdev);\n#else\n\tfree_irq(pm8001_ha->irq, sha);\n#endif\n#ifdef PM8001_USE_TASKLET\n\t \n\tif ((!pdev->msix_cap || !pci_msi_enabled()) ||\n\t    (pm8001_ha->chip_id == chip_8001))\n\t\ttasklet_kill(&pm8001_ha->tasklet[0]);\n\telse\n\t\tfor (j = 0; j < PM8001_MAX_MSIX_VEC; j++)\n\t\t\ttasklet_kill(&pm8001_ha->tasklet[j]);\n#endif\n\tscsi_host_put(pm8001_ha->shost);\n\n\tfor (i = 0; i < pm8001_ha->ccb_count; i++) {\n\t\tdma_free_coherent(&pm8001_ha->pdev->dev,\n\t\t\tsizeof(struct pm8001_prd) * PM8001_MAX_DMA_SG,\n\t\t\tpm8001_ha->ccb_info[i].buf_prd,\n\t\t\tpm8001_ha->ccb_info[i].ccb_dma_handle);\n\t}\n\tkfree(pm8001_ha->ccb_info);\n\tkfree(pm8001_ha->devices);\n\n\tpm8001_free(pm8001_ha);\n\tkfree(sha->sas_phy);\n\tkfree(sha->sas_port);\n\tkfree(sha);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\n \nstatic int __maybe_unused pm8001_pci_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\n\tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\n\tint  i, j;\n\tsas_suspend_ha(sha);\n\tflush_workqueue(pm8001_wq);\n\tscsi_block_requests(pm8001_ha->shost);\n\tif (!pdev->pm_cap) {\n\t\tdev_err(dev, \" PCI PM not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\tPM8001_CHIP_DISP->interrupt_disable(pm8001_ha, 0xFF);\n\tPM8001_CHIP_DISP->chip_soft_rst(pm8001_ha);\n#ifdef PM8001_USE_MSIX\n\tfor (i = 0; i < pm8001_ha->number_of_intr; i++)\n\t\tsynchronize_irq(pci_irq_vector(pdev, i));\n\tfor (i = 0; i < pm8001_ha->number_of_intr; i++)\n\t\tfree_irq(pci_irq_vector(pdev, i), &pm8001_ha->irq_vector[i]);\n\tpci_free_irq_vectors(pdev);\n#else\n\tfree_irq(pm8001_ha->irq, sha);\n#endif\n#ifdef PM8001_USE_TASKLET\n\t \n\tif ((!pdev->msix_cap || !pci_msi_enabled()) ||\n\t    (pm8001_ha->chip_id == chip_8001))\n\t\ttasklet_kill(&pm8001_ha->tasklet[0]);\n\telse\n\t\tfor (j = 0; j < PM8001_MAX_MSIX_VEC; j++)\n\t\t\ttasklet_kill(&pm8001_ha->tasklet[j]);\n#endif\n\tpm8001_info(pm8001_ha, \"pdev=0x%p, slot=%s, entering \"\n\t\t      \"suspended state\\n\", pdev,\n\t\t      pm8001_ha->name);\n\treturn 0;\n}\n\n \nstatic int __maybe_unused pm8001_pci_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\n\tstruct pm8001_hba_info *pm8001_ha;\n\tint rc;\n\tu8 i = 0, j;\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\n\tpm8001_ha = sha->lldd_ha;\n\n\tpm8001_info(pm8001_ha,\n\t\t    \"pdev=0x%p, slot=%s, resuming from previous operating state [D%d]\\n\",\n\t\t    pdev, pm8001_ha->name, pdev->current_state);\n\n\trc = pci_go_44(pdev);\n\tif (rc)\n\t\tgoto err_out_disable;\n\tsas_prep_resume_ha(sha);\n\t \n\tif (pm8001_ha->chip_id == chip_8001) {\n\t\tPM8001_CHIP_DISP->chip_soft_rst(pm8001_ha);\n\t\tpm8001_dbg(pm8001_ha, INIT, \"chip soft reset successful\\n\");\n\t}\n\trc = PM8001_CHIP_DISP->chip_init(pm8001_ha);\n\tif (rc)\n\t\tgoto err_out_disable;\n\n\t \n\tPM8001_CHIP_DISP->interrupt_disable(pm8001_ha, 0xFF);\n\n\trc = pm8001_request_irq(pm8001_ha);\n\tif (rc)\n\t\tgoto err_out_disable;\n#ifdef PM8001_USE_TASKLET\n\t \n\tif ((!pdev->msix_cap || !pci_msi_enabled()) ||\n\t    (pm8001_ha->chip_id == chip_8001))\n\t\ttasklet_init(&pm8001_ha->tasklet[0], pm8001_tasklet,\n\t\t\t(unsigned long)&(pm8001_ha->irq_vector[0]));\n\telse\n\t\tfor (j = 0; j < PM8001_MAX_MSIX_VEC; j++)\n\t\t\ttasklet_init(&pm8001_ha->tasklet[j], pm8001_tasklet,\n\t\t\t\t(unsigned long)&(pm8001_ha->irq_vector[j]));\n#endif\n\tPM8001_CHIP_DISP->interrupt_enable(pm8001_ha, 0);\n\tif (pm8001_ha->chip_id != chip_8001) {\n\t\tfor (i = 1; i < pm8001_ha->number_of_intr; i++)\n\t\t\tPM8001_CHIP_DISP->interrupt_enable(pm8001_ha, i);\n\t}\n\n\t \n\t \n\t \n\t \n\n\tif (pm8001_ha->chip_id == chip_8070 ||\n\t\tpm8001_ha->chip_id == chip_8072) {\n\t\tmdelay(500);\n\t}\n\n\t \n\n\tpm8001_ha->flags = PM8001F_RUN_TIME;\n\tfor (i = 0; i < pm8001_ha->chip->n_phy; i++) {\n\t\tpm8001_ha->phy[i].enable_completion = &completion;\n\t\tPM8001_CHIP_DISP->phy_start_req(pm8001_ha, i);\n\t\twait_for_completion(&completion);\n\t}\n\tsas_resume_ha(sha);\n\treturn 0;\n\nerr_out_disable:\n\tscsi_remove_host(pm8001_ha->shost);\n\n\treturn rc;\n}\n\n \nstatic struct pci_device_id pm8001_pci_table[] = {\n\t{ PCI_VDEVICE(PMC_Sierra, 0x8001), chip_8001 },\n\t{ PCI_VDEVICE(PMC_Sierra, 0x8006), chip_8006 },\n\t{ PCI_VDEVICE(ADAPTEC2, 0x8006), chip_8006 },\n\t{ PCI_VDEVICE(ATTO, 0x0042), chip_8001 },\n\t \n\t{ PCI_VDEVICE(ADAPTEC2, 0x8001), chip_8001 },\n\t{ PCI_VDEVICE(PMC_Sierra, 0x8008), chip_8008 },\n\t{ PCI_VDEVICE(ADAPTEC2, 0x8008), chip_8008 },\n\t{ PCI_VDEVICE(PMC_Sierra, 0x8018), chip_8018 },\n\t{ PCI_VDEVICE(ADAPTEC2, 0x8018), chip_8018 },\n\t{ PCI_VDEVICE(PMC_Sierra, 0x8009), chip_8009 },\n\t{ PCI_VDEVICE(ADAPTEC2, 0x8009), chip_8009 },\n\t{ PCI_VDEVICE(PMC_Sierra, 0x8019), chip_8019 },\n\t{ PCI_VDEVICE(ADAPTEC2, 0x8019), chip_8019 },\n\t{ PCI_VDEVICE(PMC_Sierra, 0x8074), chip_8074 },\n\t{ PCI_VDEVICE(ADAPTEC2, 0x8074), chip_8074 },\n\t{ PCI_VDEVICE(PMC_Sierra, 0x8076), chip_8076 },\n\t{ PCI_VDEVICE(ADAPTEC2, 0x8076), chip_8076 },\n\t{ PCI_VDEVICE(PMC_Sierra, 0x8077), chip_8077 },\n\t{ PCI_VDEVICE(ADAPTEC2, 0x8077), chip_8077 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8081,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x0400, 0, 0, chip_8001 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8081,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x0800, 0, 0, chip_8001 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8088,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x0008, 0, 0, chip_8008 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8088,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x0800, 0, 0, chip_8008 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8089,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x0008, 0, 0, chip_8009 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8089,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x0800, 0, 0, chip_8009 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8088,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x0016, 0, 0, chip_8018 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8088,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x1600, 0, 0, chip_8018 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8089,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x0016, 0, 0, chip_8019 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8089,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x1600, 0, 0, chip_8019 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8074,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x0800, 0, 0, chip_8074 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8076,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x1600, 0, 0, chip_8076 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8077,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x1600, 0, 0, chip_8077 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8074,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x0008, 0, 0, chip_8074 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8076,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x0016, 0, 0, chip_8076 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8077,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x0016, 0, 0, chip_8077 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8076,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x0808, 0, 0, chip_8076 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8077,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x0808, 0, 0, chip_8077 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, 0x8074,\n\t\tPCI_VENDOR_ID_ADAPTEC2, 0x0404, 0, 0, chip_8074 },\n\t{ PCI_VENDOR_ID_ATTO, 0x8070,\n\t\tPCI_VENDOR_ID_ATTO, 0x0070, 0, 0, chip_8070 },\n\t{ PCI_VENDOR_ID_ATTO, 0x8070,\n\t\tPCI_VENDOR_ID_ATTO, 0x0071, 0, 0, chip_8070 },\n\t{ PCI_VENDOR_ID_ATTO, 0x8072,\n\t\tPCI_VENDOR_ID_ATTO, 0x0072, 0, 0, chip_8072 },\n\t{ PCI_VENDOR_ID_ATTO, 0x8072,\n\t\tPCI_VENDOR_ID_ATTO, 0x0073, 0, 0, chip_8072 },\n\t{ PCI_VENDOR_ID_ATTO, 0x8070,\n\t\tPCI_VENDOR_ID_ATTO, 0x0080, 0, 0, chip_8070 },\n\t{ PCI_VENDOR_ID_ATTO, 0x8072,\n\t\tPCI_VENDOR_ID_ATTO, 0x0081, 0, 0, chip_8072 },\n\t{ PCI_VENDOR_ID_ATTO, 0x8072,\n\t\tPCI_VENDOR_ID_ATTO, 0x0082, 0, 0, chip_8072 },\n\t{}  \n};\n\nstatic SIMPLE_DEV_PM_OPS(pm8001_pci_pm_ops,\n\t\t\t pm8001_pci_suspend,\n\t\t\t pm8001_pci_resume);\n\nstatic struct pci_driver pm8001_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= pm8001_pci_table,\n\t.probe\t\t= pm8001_pci_probe,\n\t.remove\t\t= pm8001_pci_remove,\n\t.driver.pm\t= &pm8001_pci_pm_ops,\n};\n\n \nstatic int __init pm8001_init(void)\n{\n\tint rc = -ENOMEM;\n\n\tpm8001_wq = alloc_workqueue(\"pm80xx\", 0, 0);\n\tif (!pm8001_wq)\n\t\tgoto err;\n\n\tpm8001_id = 0;\n\tpm8001_stt = sas_domain_attach_transport(&pm8001_transport_ops);\n\tif (!pm8001_stt)\n\t\tgoto err_wq;\n\trc = pci_register_driver(&pm8001_pci_driver);\n\tif (rc)\n\t\tgoto err_tp;\n\treturn 0;\n\nerr_tp:\n\tsas_release_transport(pm8001_stt);\nerr_wq:\n\tdestroy_workqueue(pm8001_wq);\nerr:\n\treturn rc;\n}\n\nstatic void __exit pm8001_exit(void)\n{\n\tpci_unregister_driver(&pm8001_pci_driver);\n\tsas_release_transport(pm8001_stt);\n\tdestroy_workqueue(pm8001_wq);\n}\n\nmodule_init(pm8001_init);\nmodule_exit(pm8001_exit);\n\nMODULE_AUTHOR(\"Jack Wang <jack_wang@usish.com>\");\nMODULE_AUTHOR(\"Anand Kumar Santhanam <AnandKumar.Santhanam@pmcs.com>\");\nMODULE_AUTHOR(\"Sangeetha Gnanasekaran <Sangeetha.Gnanasekaran@pmcs.com>\");\nMODULE_AUTHOR(\"Nikith Ganigarakoppal <Nikith.Ganigarakoppal@pmcs.com>\");\nMODULE_DESCRIPTION(\n\t\t\"PMC-Sierra PM8001/8006/8081/8088/8089/8074/8076/8077/8070/8072 \"\n\t\t\"SAS/SATA controller driver\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, pm8001_pci_table);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}