{
  "module_name": "sd.c",
  "hash_id": "fbf6de1d7906bd4bdde3f5f1e95a56d23cda42320bb4dd893b78741ee90a0b19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/hdreg.h>\n#include <linux/errno.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/blkpg.h>\n#include <linux/blk-pm.h>\n#include <linux/delay.h>\n#include <linux/major.h>\n#include <linux/mutex.h>\n#include <linux/string_helpers.h>\n#include <linux/slab.h>\n#include <linux/sed-opal.h>\n#include <linux/pm_runtime.h>\n#include <linux/pr.h>\n#include <linux/t10-pi.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_driver.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_ioctl.h>\n#include <scsi/scsicam.h>\n#include <scsi/scsi_common.h>\n\n#include \"sd.h\"\n#include \"scsi_priv.h\"\n#include \"scsi_logging.h\"\n\nMODULE_AUTHOR(\"Eric Youngdale\");\nMODULE_DESCRIPTION(\"SCSI disk (sd) driver\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK0_MAJOR);\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK1_MAJOR);\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK2_MAJOR);\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK3_MAJOR);\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK4_MAJOR);\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK5_MAJOR);\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK6_MAJOR);\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK7_MAJOR);\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK8_MAJOR);\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK9_MAJOR);\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK10_MAJOR);\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK11_MAJOR);\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK12_MAJOR);\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK13_MAJOR);\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK14_MAJOR);\nMODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK15_MAJOR);\nMODULE_ALIAS_SCSI_DEVICE(TYPE_DISK);\nMODULE_ALIAS_SCSI_DEVICE(TYPE_MOD);\nMODULE_ALIAS_SCSI_DEVICE(TYPE_RBC);\nMODULE_ALIAS_SCSI_DEVICE(TYPE_ZBC);\n\n#define SD_MINORS\t16\n\nstatic void sd_config_discard(struct scsi_disk *, unsigned int);\nstatic void sd_config_write_same(struct scsi_disk *);\nstatic int  sd_revalidate_disk(struct gendisk *);\nstatic void sd_unlock_native_capacity(struct gendisk *disk);\nstatic void sd_shutdown(struct device *);\nstatic void sd_read_capacity(struct scsi_disk *sdkp, unsigned char *buffer);\nstatic void scsi_disk_release(struct device *cdev);\n\nstatic DEFINE_IDA(sd_index_ida);\n\nstatic mempool_t *sd_page_pool;\nstatic struct lock_class_key sd_bio_compl_lkclass;\n\nstatic const char *sd_cache_types[] = {\n\t\"write through\", \"none\", \"write back\",\n\t\"write back, no read (daft)\"\n};\n\nstatic void sd_set_flush_flag(struct scsi_disk *sdkp)\n{\n\tbool wc = false, fua = false;\n\n\tif (sdkp->WCE) {\n\t\twc = true;\n\t\tif (sdkp->DPOFUA)\n\t\t\tfua = true;\n\t}\n\n\tblk_queue_write_cache(sdkp->disk->queue, wc, fua);\n}\n\nstatic ssize_t\ncache_type_store(struct device *dev, struct device_attribute *attr,\n\t\t const char *buf, size_t count)\n{\n\tint ct, rcd, wce, sp;\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tstruct scsi_device *sdp = sdkp->device;\n\tchar buffer[64];\n\tchar *buffer_data;\n\tstruct scsi_mode_data data;\n\tstruct scsi_sense_hdr sshdr;\n\tstatic const char temp[] = \"temporary \";\n\tint len;\n\n\tif (sdp->type != TYPE_DISK && sdp->type != TYPE_ZBC)\n\t\t \n\t\treturn -EINVAL;\n\n\tif (strncmp(buf, temp, sizeof(temp) - 1) == 0) {\n\t\tbuf += sizeof(temp) - 1;\n\t\tsdkp->cache_override = 1;\n\t} else {\n\t\tsdkp->cache_override = 0;\n\t}\n\n\tct = sysfs_match_string(sd_cache_types, buf);\n\tif (ct < 0)\n\t\treturn -EINVAL;\n\n\trcd = ct & 0x01 ? 1 : 0;\n\twce = (ct & 0x02) && !sdkp->write_prot ? 1 : 0;\n\n\tif (sdkp->cache_override) {\n\t\tsdkp->WCE = wce;\n\t\tsdkp->RCD = rcd;\n\t\tsd_set_flush_flag(sdkp);\n\t\treturn count;\n\t}\n\n\tif (scsi_mode_sense(sdp, 0x08, 8, 0, buffer, sizeof(buffer), SD_TIMEOUT,\n\t\t\t    sdkp->max_retries, &data, NULL))\n\t\treturn -EINVAL;\n\tlen = min_t(size_t, sizeof(buffer), data.length - data.header_length -\n\t\t  data.block_descriptor_length);\n\tbuffer_data = buffer + data.header_length +\n\t\tdata.block_descriptor_length;\n\tbuffer_data[2] &= ~0x05;\n\tbuffer_data[2] |= wce << 2 | rcd;\n\tsp = buffer_data[0] & 0x80 ? 1 : 0;\n\tbuffer_data[0] &= ~0x80;\n\n\t \n\tdata.device_specific = 0;\n\n\tif (scsi_mode_select(sdp, 1, sp, buffer_data, len, SD_TIMEOUT,\n\t\t\t     sdkp->max_retries, &data, &sshdr)) {\n\t\tif (scsi_sense_valid(&sshdr))\n\t\t\tsd_print_sense_hdr(sdkp, &sshdr);\n\t\treturn -EINVAL;\n\t}\n\tsd_revalidate_disk(sdkp->disk);\n\treturn count;\n}\n\nstatic ssize_t\nmanage_start_stop_show(struct device *dev,\n\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tstruct scsi_device *sdp = sdkp->device;\n\n\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\t  sdp->manage_system_start_stop &&\n\t\t\t  sdp->manage_runtime_start_stop &&\n\t\t\t  sdp->manage_shutdown);\n}\nstatic DEVICE_ATTR_RO(manage_start_stop);\n\nstatic ssize_t\nmanage_system_start_stop_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tstruct scsi_device *sdp = sdkp->device;\n\n\treturn sysfs_emit(buf, \"%u\\n\", sdp->manage_system_start_stop);\n}\n\nstatic ssize_t\nmanage_system_start_stop_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tstruct scsi_device *sdp = sdkp->device;\n\tbool v;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (kstrtobool(buf, &v))\n\t\treturn -EINVAL;\n\n\tsdp->manage_system_start_stop = v;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(manage_system_start_stop);\n\nstatic ssize_t\nmanage_runtime_start_stop_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tstruct scsi_device *sdp = sdkp->device;\n\n\treturn sysfs_emit(buf, \"%u\\n\", sdp->manage_runtime_start_stop);\n}\n\nstatic ssize_t\nmanage_runtime_start_stop_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tstruct scsi_device *sdp = sdkp->device;\n\tbool v;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (kstrtobool(buf, &v))\n\t\treturn -EINVAL;\n\n\tsdp->manage_runtime_start_stop = v;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(manage_runtime_start_stop);\n\nstatic ssize_t manage_shutdown_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tstruct scsi_device *sdp = sdkp->device;\n\n\treturn sysfs_emit(buf, \"%u\\n\", sdp->manage_shutdown);\n}\n\nstatic ssize_t manage_shutdown_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tstruct scsi_device *sdp = sdkp->device;\n\tbool v;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (kstrtobool(buf, &v))\n\t\treturn -EINVAL;\n\n\tsdp->manage_shutdown = v;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(manage_shutdown);\n\nstatic ssize_t\nallow_restart_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\n\treturn sprintf(buf, \"%u\\n\", sdkp->device->allow_restart);\n}\n\nstatic ssize_t\nallow_restart_store(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tbool v;\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tstruct scsi_device *sdp = sdkp->device;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (sdp->type != TYPE_DISK && sdp->type != TYPE_ZBC)\n\t\treturn -EINVAL;\n\n\tif (kstrtobool(buf, &v))\n\t\treturn -EINVAL;\n\n\tsdp->allow_restart = v;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(allow_restart);\n\nstatic ssize_t\ncache_type_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tint ct = sdkp->RCD + 2*sdkp->WCE;\n\n\treturn sprintf(buf, \"%s\\n\", sd_cache_types[ct]);\n}\nstatic DEVICE_ATTR_RW(cache_type);\n\nstatic ssize_t\nFUA_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\n\treturn sprintf(buf, \"%u\\n\", sdkp->DPOFUA);\n}\nstatic DEVICE_ATTR_RO(FUA);\n\nstatic ssize_t\nprotection_type_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\n\treturn sprintf(buf, \"%u\\n\", sdkp->protection_type);\n}\n\nstatic ssize_t\nprotection_type_store(struct device *dev, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tunsigned int val;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\terr = kstrtouint(buf, 10, &val);\n\n\tif (err)\n\t\treturn err;\n\n\tif (val <= T10_PI_TYPE3_PROTECTION)\n\t\tsdkp->protection_type = val;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(protection_type);\n\nstatic ssize_t\nprotection_mode_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tstruct scsi_device *sdp = sdkp->device;\n\tunsigned int dif, dix;\n\n\tdif = scsi_host_dif_capable(sdp->host, sdkp->protection_type);\n\tdix = scsi_host_dix_capable(sdp->host, sdkp->protection_type);\n\n\tif (!dix && scsi_host_dix_capable(sdp->host, T10_PI_TYPE0_PROTECTION)) {\n\t\tdif = 0;\n\t\tdix = 1;\n\t}\n\n\tif (!dif && !dix)\n\t\treturn sprintf(buf, \"none\\n\");\n\n\treturn sprintf(buf, \"%s%u\\n\", dix ? \"dix\" : \"dif\", dif);\n}\nstatic DEVICE_ATTR_RO(protection_mode);\n\nstatic ssize_t\napp_tag_own_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\n\treturn sprintf(buf, \"%u\\n\", sdkp->ATO);\n}\nstatic DEVICE_ATTR_RO(app_tag_own);\n\nstatic ssize_t\nthin_provisioning_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\n\treturn sprintf(buf, \"%u\\n\", sdkp->lbpme);\n}\nstatic DEVICE_ATTR_RO(thin_provisioning);\n\n \nstatic const char *lbp_mode[] = {\n\t[SD_LBP_FULL]\t\t= \"full\",\n\t[SD_LBP_UNMAP]\t\t= \"unmap\",\n\t[SD_LBP_WS16]\t\t= \"writesame_16\",\n\t[SD_LBP_WS10]\t\t= \"writesame_10\",\n\t[SD_LBP_ZERO]\t\t= \"writesame_zero\",\n\t[SD_LBP_DISABLE]\t= \"disabled\",\n};\n\nstatic ssize_t\nprovisioning_mode_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\n\treturn sprintf(buf, \"%s\\n\", lbp_mode[sdkp->provisioning_mode]);\n}\n\nstatic ssize_t\nprovisioning_mode_store(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tstruct scsi_device *sdp = sdkp->device;\n\tint mode;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (sd_is_zoned(sdkp)) {\n\t\tsd_config_discard(sdkp, SD_LBP_DISABLE);\n\t\treturn count;\n\t}\n\n\tif (sdp->type != TYPE_DISK)\n\t\treturn -EINVAL;\n\n\tmode = sysfs_match_string(lbp_mode, buf);\n\tif (mode < 0)\n\t\treturn -EINVAL;\n\n\tsd_config_discard(sdkp, mode);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(provisioning_mode);\n\n \nstatic const char *zeroing_mode[] = {\n\t[SD_ZERO_WRITE]\t\t= \"write\",\n\t[SD_ZERO_WS]\t\t= \"writesame\",\n\t[SD_ZERO_WS16_UNMAP]\t= \"writesame_16_unmap\",\n\t[SD_ZERO_WS10_UNMAP]\t= \"writesame_10_unmap\",\n};\n\nstatic ssize_t\nzeroing_mode_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\n\treturn sprintf(buf, \"%s\\n\", zeroing_mode[sdkp->zeroing_mode]);\n}\n\nstatic ssize_t\nzeroing_mode_store(struct device *dev, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tint mode;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tmode = sysfs_match_string(zeroing_mode, buf);\n\tif (mode < 0)\n\t\treturn -EINVAL;\n\n\tsdkp->zeroing_mode = mode;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(zeroing_mode);\n\nstatic ssize_t\nmax_medium_access_timeouts_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\n\treturn sprintf(buf, \"%u\\n\", sdkp->max_medium_access_timeouts);\n}\n\nstatic ssize_t\nmax_medium_access_timeouts_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr, const char *buf,\n\t\t\t\t size_t count)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\terr = kstrtouint(buf, 10, &sdkp->max_medium_access_timeouts);\n\n\treturn err ? err : count;\n}\nstatic DEVICE_ATTR_RW(max_medium_access_timeouts);\n\nstatic ssize_t\nmax_write_same_blocks_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\n\treturn sprintf(buf, \"%u\\n\", sdkp->max_ws_blocks);\n}\n\nstatic ssize_t\nmax_write_same_blocks_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tstruct scsi_device *sdp = sdkp->device;\n\tunsigned long max;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (sdp->type != TYPE_DISK && sdp->type != TYPE_ZBC)\n\t\treturn -EINVAL;\n\n\terr = kstrtoul(buf, 10, &max);\n\n\tif (err)\n\t\treturn err;\n\n\tif (max == 0)\n\t\tsdp->no_write_same = 1;\n\telse if (max <= SD_MAX_WS16_BLOCKS) {\n\t\tsdp->no_write_same = 0;\n\t\tsdkp->max_ws_blocks = max;\n\t}\n\n\tsd_config_write_same(sdkp);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(max_write_same_blocks);\n\nstatic ssize_t\nzoned_cap_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\n\tif (sdkp->device->type == TYPE_ZBC)\n\t\treturn sprintf(buf, \"host-managed\\n\");\n\tif (sdkp->zoned == 1)\n\t\treturn sprintf(buf, \"host-aware\\n\");\n\tif (sdkp->zoned == 2)\n\t\treturn sprintf(buf, \"drive-managed\\n\");\n\treturn sprintf(buf, \"none\\n\");\n}\nstatic DEVICE_ATTR_RO(zoned_cap);\n\nstatic ssize_t\nmax_retries_store(struct device *dev, struct device_attribute *attr,\n\t\t  const char *buf, size_t count)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\tstruct scsi_device *sdev = sdkp->device;\n\tint retries, err;\n\n\terr = kstrtoint(buf, 10, &retries);\n\tif (err)\n\t\treturn err;\n\n\tif (retries == SCSI_CMD_RETRIES_NO_LIMIT || retries <= SD_MAX_RETRIES) {\n\t\tsdkp->max_retries = retries;\n\t\treturn count;\n\t}\n\n\tsdev_printk(KERN_ERR, sdev, \"max_retries must be between -1 and %d\\n\",\n\t\t    SD_MAX_RETRIES);\n\treturn -EINVAL;\n}\n\nstatic ssize_t\nmax_retries_show(struct device *dev, struct device_attribute *attr,\n\t\t char *buf)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", sdkp->max_retries);\n}\n\nstatic DEVICE_ATTR_RW(max_retries);\n\nstatic struct attribute *sd_disk_attrs[] = {\n\t&dev_attr_cache_type.attr,\n\t&dev_attr_FUA.attr,\n\t&dev_attr_allow_restart.attr,\n\t&dev_attr_manage_start_stop.attr,\n\t&dev_attr_manage_system_start_stop.attr,\n\t&dev_attr_manage_runtime_start_stop.attr,\n\t&dev_attr_manage_shutdown.attr,\n\t&dev_attr_protection_type.attr,\n\t&dev_attr_protection_mode.attr,\n\t&dev_attr_app_tag_own.attr,\n\t&dev_attr_thin_provisioning.attr,\n\t&dev_attr_provisioning_mode.attr,\n\t&dev_attr_zeroing_mode.attr,\n\t&dev_attr_max_write_same_blocks.attr,\n\t&dev_attr_max_medium_access_timeouts.attr,\n\t&dev_attr_zoned_cap.attr,\n\t&dev_attr_max_retries.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(sd_disk);\n\nstatic struct class sd_disk_class = {\n\t.name\t\t= \"scsi_disk\",\n\t.dev_release\t= scsi_disk_release,\n\t.dev_groups\t= sd_disk_groups,\n};\n\n \nstatic void sd_default_probe(dev_t devt)\n{\n}\n\n \nstatic int sd_major(int major_idx)\n{\n\tswitch (major_idx) {\n\tcase 0:\n\t\treturn SCSI_DISK0_MAJOR;\n\tcase 1 ... 7:\n\t\treturn SCSI_DISK1_MAJOR + major_idx - 1;\n\tcase 8 ... 15:\n\t\treturn SCSI_DISK8_MAJOR + major_idx - 8;\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\t \n\t}\n}\n\n#ifdef CONFIG_BLK_SED_OPAL\nstatic int sd_sec_submit(void *data, u16 spsp, u8 secp, void *buffer,\n\t\tsize_t len, bool send)\n{\n\tstruct scsi_disk *sdkp = data;\n\tstruct scsi_device *sdev = sdkp->device;\n\tu8 cdb[12] = { 0, };\n\tconst struct scsi_exec_args exec_args = {\n\t\t.req_flags = BLK_MQ_REQ_PM,\n\t};\n\tint ret;\n\n\tcdb[0] = send ? SECURITY_PROTOCOL_OUT : SECURITY_PROTOCOL_IN;\n\tcdb[1] = secp;\n\tput_unaligned_be16(spsp, &cdb[2]);\n\tput_unaligned_be32(len, &cdb[6]);\n\n\tret = scsi_execute_cmd(sdev, cdb, send ? REQ_OP_DRV_OUT : REQ_OP_DRV_IN,\n\t\t\t       buffer, len, SD_TIMEOUT, sdkp->max_retries,\n\t\t\t       &exec_args);\n\treturn ret <= 0 ? ret : -EIO;\n}\n#endif  \n\n \nstatic unsigned int sd_prot_op(bool write, bool dix, bool dif)\n{\n\t \n\tstatic const unsigned int ops[] = {\t \n\t\tSCSI_PROT_NORMAL,\t\t \n\t\tSCSI_PROT_READ_STRIP,\t\t \n\t\tSCSI_PROT_READ_INSERT,\t\t \n\t\tSCSI_PROT_READ_PASS,\t\t \n\t\tSCSI_PROT_NORMAL,\t\t \n\t\tSCSI_PROT_WRITE_INSERT,\t\t \n\t\tSCSI_PROT_WRITE_STRIP,\t\t \n\t\tSCSI_PROT_WRITE_PASS,\t\t \n\t};\n\n\treturn ops[write << 2 | dix << 1 | dif];\n}\n\n \nstatic unsigned int sd_prot_flag_mask(unsigned int prot_op)\n{\n\tstatic const unsigned int flag_mask[] = {\n\t\t[SCSI_PROT_NORMAL]\t\t= 0,\n\n\t\t[SCSI_PROT_READ_STRIP]\t\t= SCSI_PROT_TRANSFER_PI |\n\t\t\t\t\t\t  SCSI_PROT_GUARD_CHECK |\n\t\t\t\t\t\t  SCSI_PROT_REF_CHECK |\n\t\t\t\t\t\t  SCSI_PROT_REF_INCREMENT,\n\n\t\t[SCSI_PROT_READ_INSERT]\t\t= SCSI_PROT_REF_INCREMENT |\n\t\t\t\t\t\t  SCSI_PROT_IP_CHECKSUM,\n\n\t\t[SCSI_PROT_READ_PASS]\t\t= SCSI_PROT_TRANSFER_PI |\n\t\t\t\t\t\t  SCSI_PROT_GUARD_CHECK |\n\t\t\t\t\t\t  SCSI_PROT_REF_CHECK |\n\t\t\t\t\t\t  SCSI_PROT_REF_INCREMENT |\n\t\t\t\t\t\t  SCSI_PROT_IP_CHECKSUM,\n\n\t\t[SCSI_PROT_WRITE_INSERT]\t= SCSI_PROT_TRANSFER_PI |\n\t\t\t\t\t\t  SCSI_PROT_REF_INCREMENT,\n\n\t\t[SCSI_PROT_WRITE_STRIP]\t\t= SCSI_PROT_GUARD_CHECK |\n\t\t\t\t\t\t  SCSI_PROT_REF_CHECK |\n\t\t\t\t\t\t  SCSI_PROT_REF_INCREMENT |\n\t\t\t\t\t\t  SCSI_PROT_IP_CHECKSUM,\n\n\t\t[SCSI_PROT_WRITE_PASS]\t\t= SCSI_PROT_TRANSFER_PI |\n\t\t\t\t\t\t  SCSI_PROT_GUARD_CHECK |\n\t\t\t\t\t\t  SCSI_PROT_REF_CHECK |\n\t\t\t\t\t\t  SCSI_PROT_REF_INCREMENT |\n\t\t\t\t\t\t  SCSI_PROT_IP_CHECKSUM,\n\t};\n\n\treturn flag_mask[prot_op];\n}\n\nstatic unsigned char sd_setup_protect_cmnd(struct scsi_cmnd *scmd,\n\t\t\t\t\t   unsigned int dix, unsigned int dif)\n{\n\tstruct request *rq = scsi_cmd_to_rq(scmd);\n\tstruct bio *bio = rq->bio;\n\tunsigned int prot_op = sd_prot_op(rq_data_dir(rq), dix, dif);\n\tunsigned int protect = 0;\n\n\tif (dix) {\t\t\t\t \n\t\tif (bio_integrity_flagged(bio, BIP_IP_CHECKSUM))\n\t\t\tscmd->prot_flags |= SCSI_PROT_IP_CHECKSUM;\n\n\t\tif (bio_integrity_flagged(bio, BIP_CTRL_NOCHECK) == false)\n\t\t\tscmd->prot_flags |= SCSI_PROT_GUARD_CHECK;\n\t}\n\n\tif (dif != T10_PI_TYPE3_PROTECTION) {\t \n\t\tscmd->prot_flags |= SCSI_PROT_REF_INCREMENT;\n\n\t\tif (bio_integrity_flagged(bio, BIP_CTRL_NOCHECK) == false)\n\t\t\tscmd->prot_flags |= SCSI_PROT_REF_CHECK;\n\t}\n\n\tif (dif) {\t\t\t\t \n\t\tscmd->prot_flags |= SCSI_PROT_TRANSFER_PI;\n\n\t\tif (bio_integrity_flagged(bio, BIP_DISK_NOCHECK))\n\t\t\tprotect = 3 << 5;\t \n\t\telse\n\t\t\tprotect = 1 << 5;\t \n\t}\n\n\tscsi_set_prot_op(scmd, prot_op);\n\tscsi_set_prot_type(scmd, dif);\n\tscmd->prot_flags &= sd_prot_flag_mask(prot_op);\n\n\treturn protect;\n}\n\nstatic void sd_config_discard(struct scsi_disk *sdkp, unsigned int mode)\n{\n\tstruct request_queue *q = sdkp->disk->queue;\n\tunsigned int logical_block_size = sdkp->device->sector_size;\n\tunsigned int max_blocks = 0;\n\n\tq->limits.discard_alignment =\n\t\tsdkp->unmap_alignment * logical_block_size;\n\tq->limits.discard_granularity =\n\t\tmax(sdkp->physical_block_size,\n\t\t    sdkp->unmap_granularity * logical_block_size);\n\tsdkp->provisioning_mode = mode;\n\n\tswitch (mode) {\n\n\tcase SD_LBP_FULL:\n\tcase SD_LBP_DISABLE:\n\t\tblk_queue_max_discard_sectors(q, 0);\n\t\treturn;\n\n\tcase SD_LBP_UNMAP:\n\t\tmax_blocks = min_not_zero(sdkp->max_unmap_blocks,\n\t\t\t\t\t  (u32)SD_MAX_WS16_BLOCKS);\n\t\tbreak;\n\n\tcase SD_LBP_WS16:\n\t\tif (sdkp->device->unmap_limit_for_ws)\n\t\t\tmax_blocks = sdkp->max_unmap_blocks;\n\t\telse\n\t\t\tmax_blocks = sdkp->max_ws_blocks;\n\n\t\tmax_blocks = min_not_zero(max_blocks, (u32)SD_MAX_WS16_BLOCKS);\n\t\tbreak;\n\n\tcase SD_LBP_WS10:\n\t\tif (sdkp->device->unmap_limit_for_ws)\n\t\t\tmax_blocks = sdkp->max_unmap_blocks;\n\t\telse\n\t\t\tmax_blocks = sdkp->max_ws_blocks;\n\n\t\tmax_blocks = min_not_zero(max_blocks, (u32)SD_MAX_WS10_BLOCKS);\n\t\tbreak;\n\n\tcase SD_LBP_ZERO:\n\t\tmax_blocks = min_not_zero(sdkp->max_ws_blocks,\n\t\t\t\t\t  (u32)SD_MAX_WS10_BLOCKS);\n\t\tbreak;\n\t}\n\n\tblk_queue_max_discard_sectors(q, max_blocks * (logical_block_size >> 9));\n}\n\nstatic void *sd_set_special_bvec(struct request *rq, unsigned int data_len)\n{\n\tstruct page *page;\n\n\tpage = mempool_alloc(sd_page_pool, GFP_ATOMIC);\n\tif (!page)\n\t\treturn NULL;\n\tclear_highpage(page);\n\tbvec_set_page(&rq->special_vec, page, data_len, 0);\n\trq->rq_flags |= RQF_SPECIAL_PAYLOAD;\n\treturn bvec_virt(&rq->special_vec);\n}\n\nstatic blk_status_t sd_setup_unmap_cmnd(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_device *sdp = cmd->device;\n\tstruct request *rq = scsi_cmd_to_rq(cmd);\n\tstruct scsi_disk *sdkp = scsi_disk(rq->q->disk);\n\tu64 lba = sectors_to_logical(sdp, blk_rq_pos(rq));\n\tu32 nr_blocks = sectors_to_logical(sdp, blk_rq_sectors(rq));\n\tunsigned int data_len = 24;\n\tchar *buf;\n\n\tbuf = sd_set_special_bvec(rq, data_len);\n\tif (!buf)\n\t\treturn BLK_STS_RESOURCE;\n\n\tcmd->cmd_len = 10;\n\tcmd->cmnd[0] = UNMAP;\n\tcmd->cmnd[8] = 24;\n\n\tput_unaligned_be16(6 + 16, &buf[0]);\n\tput_unaligned_be16(16, &buf[2]);\n\tput_unaligned_be64(lba, &buf[8]);\n\tput_unaligned_be32(nr_blocks, &buf[16]);\n\n\tcmd->allowed = sdkp->max_retries;\n\tcmd->transfersize = data_len;\n\trq->timeout = SD_TIMEOUT;\n\n\treturn scsi_alloc_sgtables(cmd);\n}\n\nstatic blk_status_t sd_setup_write_same16_cmnd(struct scsi_cmnd *cmd,\n\t\tbool unmap)\n{\n\tstruct scsi_device *sdp = cmd->device;\n\tstruct request *rq = scsi_cmd_to_rq(cmd);\n\tstruct scsi_disk *sdkp = scsi_disk(rq->q->disk);\n\tu64 lba = sectors_to_logical(sdp, blk_rq_pos(rq));\n\tu32 nr_blocks = sectors_to_logical(sdp, blk_rq_sectors(rq));\n\tu32 data_len = sdp->sector_size;\n\n\tif (!sd_set_special_bvec(rq, data_len))\n\t\treturn BLK_STS_RESOURCE;\n\n\tcmd->cmd_len = 16;\n\tcmd->cmnd[0] = WRITE_SAME_16;\n\tif (unmap)\n\t\tcmd->cmnd[1] = 0x8;  \n\tput_unaligned_be64(lba, &cmd->cmnd[2]);\n\tput_unaligned_be32(nr_blocks, &cmd->cmnd[10]);\n\n\tcmd->allowed = sdkp->max_retries;\n\tcmd->transfersize = data_len;\n\trq->timeout = unmap ? SD_TIMEOUT : SD_WRITE_SAME_TIMEOUT;\n\n\treturn scsi_alloc_sgtables(cmd);\n}\n\nstatic blk_status_t sd_setup_write_same10_cmnd(struct scsi_cmnd *cmd,\n\t\tbool unmap)\n{\n\tstruct scsi_device *sdp = cmd->device;\n\tstruct request *rq = scsi_cmd_to_rq(cmd);\n\tstruct scsi_disk *sdkp = scsi_disk(rq->q->disk);\n\tu64 lba = sectors_to_logical(sdp, blk_rq_pos(rq));\n\tu32 nr_blocks = sectors_to_logical(sdp, blk_rq_sectors(rq));\n\tu32 data_len = sdp->sector_size;\n\n\tif (!sd_set_special_bvec(rq, data_len))\n\t\treturn BLK_STS_RESOURCE;\n\n\tcmd->cmd_len = 10;\n\tcmd->cmnd[0] = WRITE_SAME;\n\tif (unmap)\n\t\tcmd->cmnd[1] = 0x8;  \n\tput_unaligned_be32(lba, &cmd->cmnd[2]);\n\tput_unaligned_be16(nr_blocks, &cmd->cmnd[7]);\n\n\tcmd->allowed = sdkp->max_retries;\n\tcmd->transfersize = data_len;\n\trq->timeout = unmap ? SD_TIMEOUT : SD_WRITE_SAME_TIMEOUT;\n\n\treturn scsi_alloc_sgtables(cmd);\n}\n\nstatic blk_status_t sd_setup_write_zeroes_cmnd(struct scsi_cmnd *cmd)\n{\n\tstruct request *rq = scsi_cmd_to_rq(cmd);\n\tstruct scsi_device *sdp = cmd->device;\n\tstruct scsi_disk *sdkp = scsi_disk(rq->q->disk);\n\tu64 lba = sectors_to_logical(sdp, blk_rq_pos(rq));\n\tu32 nr_blocks = sectors_to_logical(sdp, blk_rq_sectors(rq));\n\n\tif (!(rq->cmd_flags & REQ_NOUNMAP)) {\n\t\tswitch (sdkp->zeroing_mode) {\n\t\tcase SD_ZERO_WS16_UNMAP:\n\t\t\treturn sd_setup_write_same16_cmnd(cmd, true);\n\t\tcase SD_ZERO_WS10_UNMAP:\n\t\t\treturn sd_setup_write_same10_cmnd(cmd, true);\n\t\t}\n\t}\n\n\tif (sdp->no_write_same) {\n\t\trq->rq_flags |= RQF_QUIET;\n\t\treturn BLK_STS_TARGET;\n\t}\n\n\tif (sdkp->ws16 || lba > 0xffffffff || nr_blocks > 0xffff)\n\t\treturn sd_setup_write_same16_cmnd(cmd, false);\n\n\treturn sd_setup_write_same10_cmnd(cmd, false);\n}\n\nstatic void sd_config_write_same(struct scsi_disk *sdkp)\n{\n\tstruct request_queue *q = sdkp->disk->queue;\n\tunsigned int logical_block_size = sdkp->device->sector_size;\n\n\tif (sdkp->device->no_write_same) {\n\t\tsdkp->max_ws_blocks = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sdkp->max_ws_blocks > SD_MAX_WS10_BLOCKS)\n\t\tsdkp->max_ws_blocks = min_not_zero(sdkp->max_ws_blocks,\n\t\t\t\t\t\t   (u32)SD_MAX_WS16_BLOCKS);\n\telse if (sdkp->ws16 || sdkp->ws10 || sdkp->device->no_report_opcodes)\n\t\tsdkp->max_ws_blocks = min_not_zero(sdkp->max_ws_blocks,\n\t\t\t\t\t\t   (u32)SD_MAX_WS10_BLOCKS);\n\telse {\n\t\tsdkp->device->no_write_same = 1;\n\t\tsdkp->max_ws_blocks = 0;\n\t}\n\n\tif (sdkp->lbprz && sdkp->lbpws)\n\t\tsdkp->zeroing_mode = SD_ZERO_WS16_UNMAP;\n\telse if (sdkp->lbprz && sdkp->lbpws10)\n\t\tsdkp->zeroing_mode = SD_ZERO_WS10_UNMAP;\n\telse if (sdkp->max_ws_blocks)\n\t\tsdkp->zeroing_mode = SD_ZERO_WS;\n\telse\n\t\tsdkp->zeroing_mode = SD_ZERO_WRITE;\n\n\tif (sdkp->max_ws_blocks &&\n\t    sdkp->physical_block_size > logical_block_size) {\n\t\t \n\t\tsdkp->max_ws_blocks =\n\t\t\tround_down(sdkp->max_ws_blocks,\n\t\t\t\t   bytes_to_logical(sdkp->device,\n\t\t\t\t\t\t    sdkp->physical_block_size));\n\t}\n\nout:\n\tblk_queue_max_write_zeroes_sectors(q, sdkp->max_ws_blocks *\n\t\t\t\t\t (logical_block_size >> 9));\n}\n\nstatic blk_status_t sd_setup_flush_cmnd(struct scsi_cmnd *cmd)\n{\n\tstruct request *rq = scsi_cmd_to_rq(cmd);\n\tstruct scsi_disk *sdkp = scsi_disk(rq->q->disk);\n\n\t \n\tmemset(&cmd->sdb, 0, sizeof(cmd->sdb));\n\n\tif (cmd->device->use_16_for_sync) {\n\t\tcmd->cmnd[0] = SYNCHRONIZE_CACHE_16;\n\t\tcmd->cmd_len = 16;\n\t} else {\n\t\tcmd->cmnd[0] = SYNCHRONIZE_CACHE;\n\t\tcmd->cmd_len = 10;\n\t}\n\tcmd->transfersize = 0;\n\tcmd->allowed = sdkp->max_retries;\n\n\trq->timeout = rq->q->rq_timeout * SD_FLUSH_TIMEOUT_MULTIPLIER;\n\treturn BLK_STS_OK;\n}\n\nstatic blk_status_t sd_setup_rw32_cmnd(struct scsi_cmnd *cmd, bool write,\n\t\t\t\t       sector_t lba, unsigned int nr_blocks,\n\t\t\t\t       unsigned char flags, unsigned int dld)\n{\n\tcmd->cmd_len = SD_EXT_CDB_SIZE;\n\tcmd->cmnd[0]  = VARIABLE_LENGTH_CMD;\n\tcmd->cmnd[7]  = 0x18;  \n\tcmd->cmnd[9]  = write ? WRITE_32 : READ_32;\n\tcmd->cmnd[10] = flags;\n\tcmd->cmnd[11] = dld & 0x07;\n\tput_unaligned_be64(lba, &cmd->cmnd[12]);\n\tput_unaligned_be32(lba, &cmd->cmnd[20]);  \n\tput_unaligned_be32(nr_blocks, &cmd->cmnd[28]);\n\n\treturn BLK_STS_OK;\n}\n\nstatic blk_status_t sd_setup_rw16_cmnd(struct scsi_cmnd *cmd, bool write,\n\t\t\t\t       sector_t lba, unsigned int nr_blocks,\n\t\t\t\t       unsigned char flags, unsigned int dld)\n{\n\tcmd->cmd_len  = 16;\n\tcmd->cmnd[0]  = write ? WRITE_16 : READ_16;\n\tcmd->cmnd[1]  = flags | ((dld >> 2) & 0x01);\n\tcmd->cmnd[14] = (dld & 0x03) << 6;\n\tcmd->cmnd[15] = 0;\n\tput_unaligned_be64(lba, &cmd->cmnd[2]);\n\tput_unaligned_be32(nr_blocks, &cmd->cmnd[10]);\n\n\treturn BLK_STS_OK;\n}\n\nstatic blk_status_t sd_setup_rw10_cmnd(struct scsi_cmnd *cmd, bool write,\n\t\t\t\t       sector_t lba, unsigned int nr_blocks,\n\t\t\t\t       unsigned char flags)\n{\n\tcmd->cmd_len = 10;\n\tcmd->cmnd[0] = write ? WRITE_10 : READ_10;\n\tcmd->cmnd[1] = flags;\n\tcmd->cmnd[6] = 0;\n\tcmd->cmnd[9] = 0;\n\tput_unaligned_be32(lba, &cmd->cmnd[2]);\n\tput_unaligned_be16(nr_blocks, &cmd->cmnd[7]);\n\n\treturn BLK_STS_OK;\n}\n\nstatic blk_status_t sd_setup_rw6_cmnd(struct scsi_cmnd *cmd, bool write,\n\t\t\t\t      sector_t lba, unsigned int nr_blocks,\n\t\t\t\t      unsigned char flags)\n{\n\t \n\tif (WARN_ON_ONCE(nr_blocks == 0))\n\t\treturn BLK_STS_IOERR;\n\n\tif (unlikely(flags & 0x8)) {\n\t\t \n\t\tscmd_printk(KERN_ERR, cmd, \"FUA write on READ/WRITE(6) drive\\n\");\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\tcmd->cmd_len = 6;\n\tcmd->cmnd[0] = write ? WRITE_6 : READ_6;\n\tcmd->cmnd[1] = (lba >> 16) & 0x1f;\n\tcmd->cmnd[2] = (lba >> 8) & 0xff;\n\tcmd->cmnd[3] = lba & 0xff;\n\tcmd->cmnd[4] = nr_blocks;\n\tcmd->cmnd[5] = 0;\n\n\treturn BLK_STS_OK;\n}\n\n \nstatic int sd_cdl_dld(struct scsi_disk *sdkp, struct scsi_cmnd *scmd)\n{\n\tstruct scsi_device *sdp = sdkp->device;\n\tint hint;\n\n\tif (!sdp->cdl_supported || !sdp->cdl_enable)\n\t\treturn 0;\n\n\t \n\thint = IOPRIO_PRIO_HINT(req_get_ioprio(scsi_cmd_to_rq(scmd)));\n\tif (hint < IOPRIO_HINT_DEV_DURATION_LIMIT_1 ||\n\t    hint > IOPRIO_HINT_DEV_DURATION_LIMIT_7)\n\t\treturn 0;\n\n\treturn (hint - IOPRIO_HINT_DEV_DURATION_LIMIT_1) + 1;\n}\n\nstatic blk_status_t sd_setup_read_write_cmnd(struct scsi_cmnd *cmd)\n{\n\tstruct request *rq = scsi_cmd_to_rq(cmd);\n\tstruct scsi_device *sdp = cmd->device;\n\tstruct scsi_disk *sdkp = scsi_disk(rq->q->disk);\n\tsector_t lba = sectors_to_logical(sdp, blk_rq_pos(rq));\n\tsector_t threshold;\n\tunsigned int nr_blocks = sectors_to_logical(sdp, blk_rq_sectors(rq));\n\tunsigned int mask = logical_to_sectors(sdp, 1) - 1;\n\tbool write = rq_data_dir(rq) == WRITE;\n\tunsigned char protect, fua;\n\tunsigned int dld;\n\tblk_status_t ret;\n\tunsigned int dif;\n\tbool dix;\n\n\tret = scsi_alloc_sgtables(cmd);\n\tif (ret != BLK_STS_OK)\n\t\treturn ret;\n\n\tret = BLK_STS_IOERR;\n\tif (!scsi_device_online(sdp) || sdp->changed) {\n\t\tscmd_printk(KERN_ERR, cmd, \"device offline or changed\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (blk_rq_pos(rq) + blk_rq_sectors(rq) > get_capacity(rq->q->disk)) {\n\t\tscmd_printk(KERN_ERR, cmd, \"access beyond end of device\\n\");\n\t\tgoto fail;\n\t}\n\n\tif ((blk_rq_pos(rq) & mask) || (blk_rq_sectors(rq) & mask)) {\n\t\tscmd_printk(KERN_ERR, cmd, \"request not aligned to the logical block size\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tthreshold = sdkp->capacity - SD_LAST_BUGGY_SECTORS;\n\n\tif (unlikely(sdp->last_sector_bug && lba + nr_blocks > threshold)) {\n\t\tif (lba < threshold) {\n\t\t\t \n\t\t\tnr_blocks = threshold - lba;\n\t\t} else {\n\t\t\t \n\t\t\tnr_blocks = 1;\n\t\t}\n\t}\n\n\tif (req_op(rq) == REQ_OP_ZONE_APPEND) {\n\t\tret = sd_zbc_prepare_zone_append(cmd, &lba, nr_blocks);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\tfua = rq->cmd_flags & REQ_FUA ? 0x8 : 0;\n\tdix = scsi_prot_sg_count(cmd);\n\tdif = scsi_host_dif_capable(cmd->device->host, sdkp->protection_type);\n\tdld = sd_cdl_dld(sdkp, cmd);\n\n\tif (dif || dix)\n\t\tprotect = sd_setup_protect_cmnd(cmd, dix, dif);\n\telse\n\t\tprotect = 0;\n\n\tif (protect && sdkp->protection_type == T10_PI_TYPE2_PROTECTION) {\n\t\tret = sd_setup_rw32_cmnd(cmd, write, lba, nr_blocks,\n\t\t\t\t\t protect | fua, dld);\n\t} else if (sdp->use_16_for_rw || (nr_blocks > 0xffff)) {\n\t\tret = sd_setup_rw16_cmnd(cmd, write, lba, nr_blocks,\n\t\t\t\t\t protect | fua, dld);\n\t} else if ((nr_blocks > 0xff) || (lba > 0x1fffff) ||\n\t\t   sdp->use_10_for_rw || protect) {\n\t\tret = sd_setup_rw10_cmnd(cmd, write, lba, nr_blocks,\n\t\t\t\t\t protect | fua);\n\t} else {\n\t\tret = sd_setup_rw6_cmnd(cmd, write, lba, nr_blocks,\n\t\t\t\t\tprotect | fua);\n\t}\n\n\tif (unlikely(ret != BLK_STS_OK))\n\t\tgoto fail;\n\n\t \n\tcmd->transfersize = sdp->sector_size;\n\tcmd->underflow = nr_blocks << 9;\n\tcmd->allowed = sdkp->max_retries;\n\tcmd->sdb.length = nr_blocks * sdp->sector_size;\n\n\tSCSI_LOG_HLQUEUE(1,\n\t\t\t scmd_printk(KERN_INFO, cmd,\n\t\t\t\t     \"%s: block=%llu, count=%d\\n\", __func__,\n\t\t\t\t     (unsigned long long)blk_rq_pos(rq),\n\t\t\t\t     blk_rq_sectors(rq)));\n\tSCSI_LOG_HLQUEUE(2,\n\t\t\t scmd_printk(KERN_INFO, cmd,\n\t\t\t\t     \"%s %d/%u 512 byte blocks.\\n\",\n\t\t\t\t     write ? \"writing\" : \"reading\", nr_blocks,\n\t\t\t\t     blk_rq_sectors(rq)));\n\n\t \n\treturn BLK_STS_OK;\nfail:\n\tscsi_free_sgtables(cmd);\n\treturn ret;\n}\n\nstatic blk_status_t sd_init_command(struct scsi_cmnd *cmd)\n{\n\tstruct request *rq = scsi_cmd_to_rq(cmd);\n\n\tswitch (req_op(rq)) {\n\tcase REQ_OP_DISCARD:\n\t\tswitch (scsi_disk(rq->q->disk)->provisioning_mode) {\n\t\tcase SD_LBP_UNMAP:\n\t\t\treturn sd_setup_unmap_cmnd(cmd);\n\t\tcase SD_LBP_WS16:\n\t\t\treturn sd_setup_write_same16_cmnd(cmd, true);\n\t\tcase SD_LBP_WS10:\n\t\t\treturn sd_setup_write_same10_cmnd(cmd, true);\n\t\tcase SD_LBP_ZERO:\n\t\t\treturn sd_setup_write_same10_cmnd(cmd, false);\n\t\tdefault:\n\t\t\treturn BLK_STS_TARGET;\n\t\t}\n\tcase REQ_OP_WRITE_ZEROES:\n\t\treturn sd_setup_write_zeroes_cmnd(cmd);\n\tcase REQ_OP_FLUSH:\n\t\treturn sd_setup_flush_cmnd(cmd);\n\tcase REQ_OP_READ:\n\tcase REQ_OP_WRITE:\n\tcase REQ_OP_ZONE_APPEND:\n\t\treturn sd_setup_read_write_cmnd(cmd);\n\tcase REQ_OP_ZONE_RESET:\n\t\treturn sd_zbc_setup_zone_mgmt_cmnd(cmd, ZO_RESET_WRITE_POINTER,\n\t\t\t\t\t\t   false);\n\tcase REQ_OP_ZONE_RESET_ALL:\n\t\treturn sd_zbc_setup_zone_mgmt_cmnd(cmd, ZO_RESET_WRITE_POINTER,\n\t\t\t\t\t\t   true);\n\tcase REQ_OP_ZONE_OPEN:\n\t\treturn sd_zbc_setup_zone_mgmt_cmnd(cmd, ZO_OPEN_ZONE, false);\n\tcase REQ_OP_ZONE_CLOSE:\n\t\treturn sd_zbc_setup_zone_mgmt_cmnd(cmd, ZO_CLOSE_ZONE, false);\n\tcase REQ_OP_ZONE_FINISH:\n\t\treturn sd_zbc_setup_zone_mgmt_cmnd(cmd, ZO_FINISH_ZONE, false);\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn BLK_STS_NOTSUPP;\n\t}\n}\n\nstatic void sd_uninit_command(struct scsi_cmnd *SCpnt)\n{\n\tstruct request *rq = scsi_cmd_to_rq(SCpnt);\n\n\tif (rq->rq_flags & RQF_SPECIAL_PAYLOAD)\n\t\tmempool_free(rq->special_vec.bv_page, sd_page_pool);\n}\n\nstatic bool sd_need_revalidate(struct gendisk *disk, struct scsi_disk *sdkp)\n{\n\tif (sdkp->device->removable || sdkp->write_prot) {\n\t\tif (disk_check_media_change(disk))\n\t\t\treturn true;\n\t}\n\n\t \n\treturn test_bit(GD_NEED_PART_SCAN, &disk->state);\n}\n\n \nstatic int sd_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tstruct scsi_disk *sdkp = scsi_disk(disk);\n\tstruct scsi_device *sdev = sdkp->device;\n\tint retval;\n\n\tif (scsi_device_get(sdev))\n\t\treturn -ENXIO;\n\n\tSCSI_LOG_HLQUEUE(3, sd_printk(KERN_INFO, sdkp, \"sd_open\\n\"));\n\n\t \n\tretval = -ENXIO;\n\tif (!scsi_block_when_processing_errors(sdev))\n\t\tgoto error_out;\n\n\tif (sd_need_revalidate(disk, sdkp))\n\t\tsd_revalidate_disk(disk);\n\n\t \n\tretval = -ENOMEDIUM;\n\tif (sdev->removable && !sdkp->media_present &&\n\t    !(mode & BLK_OPEN_NDELAY))\n\t\tgoto error_out;\n\n\t \n\tretval = -EROFS;\n\tif (sdkp->write_prot && (mode & BLK_OPEN_WRITE))\n\t\tgoto error_out;\n\n\t \n\tretval = -ENXIO;\n\tif (!scsi_device_online(sdev))\n\t\tgoto error_out;\n\n\tif ((atomic_inc_return(&sdkp->openers) == 1) && sdev->removable) {\n\t\tif (scsi_block_when_processing_errors(sdev))\n\t\t\tscsi_set_medium_removal(sdev, SCSI_REMOVAL_PREVENT);\n\t}\n\n\treturn 0;\n\nerror_out:\n\tscsi_device_put(sdev);\n\treturn retval;\t\n}\n\n \nstatic void sd_release(struct gendisk *disk)\n{\n\tstruct scsi_disk *sdkp = scsi_disk(disk);\n\tstruct scsi_device *sdev = sdkp->device;\n\n\tSCSI_LOG_HLQUEUE(3, sd_printk(KERN_INFO, sdkp, \"sd_release\\n\"));\n\n\tif (atomic_dec_return(&sdkp->openers) == 0 && sdev->removable) {\n\t\tif (scsi_block_when_processing_errors(sdev))\n\t\t\tscsi_set_medium_removal(sdev, SCSI_REMOVAL_ALLOW);\n\t}\n\n\tscsi_device_put(sdev);\n}\n\nstatic int sd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tstruct scsi_disk *sdkp = scsi_disk(bdev->bd_disk);\n\tstruct scsi_device *sdp = sdkp->device;\n\tstruct Scsi_Host *host = sdp->host;\n\tsector_t capacity = logical_to_sectors(sdp, sdkp->capacity);\n\tint diskinfo[4];\n\n\t \n\tdiskinfo[0] = 0x40;\t \n\tdiskinfo[1] = 0x20;\t \n\tdiskinfo[2] = capacity >> 11;\n\n\t \n\tif (host->hostt->bios_param)\n\t\thost->hostt->bios_param(sdp, bdev, capacity, diskinfo);\n\telse\n\t\tscsicam_bios_param(bdev, capacity, diskinfo);\n\n\tgeo->heads = diskinfo[0];\n\tgeo->sectors = diskinfo[1];\n\tgeo->cylinders = diskinfo[2];\n\treturn 0;\n}\n\n \nstatic int sd_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\t    unsigned int cmd, unsigned long arg)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct scsi_disk *sdkp = scsi_disk(disk);\n\tstruct scsi_device *sdp = sdkp->device;\n\tvoid __user *p = (void __user *)arg;\n\tint error;\n    \n\tSCSI_LOG_IOCTL(1, sd_printk(KERN_INFO, sdkp, \"sd_ioctl: disk=%s, \"\n\t\t\t\t    \"cmd=0x%x\\n\", disk->disk_name, cmd));\n\n\tif (bdev_is_partition(bdev) && !capable(CAP_SYS_RAWIO))\n\t\treturn -ENOIOCTLCMD;\n\n\t \n\terror = scsi_ioctl_block_when_processing_errors(sdp, cmd,\n\t\t\t(mode & BLK_OPEN_NDELAY));\n\tif (error)\n\t\treturn error;\n\n\tif (is_sed_ioctl(cmd))\n\t\treturn sed_ioctl(sdkp->opal_dev, cmd, p);\n\treturn scsi_ioctl(sdp, mode & BLK_OPEN_WRITE, cmd, p);\n}\n\nstatic void set_media_not_present(struct scsi_disk *sdkp)\n{\n\tif (sdkp->media_present)\n\t\tsdkp->device->changed = 1;\n\n\tif (sdkp->device->removable) {\n\t\tsdkp->media_present = 0;\n\t\tsdkp->capacity = 0;\n\t}\n}\n\nstatic int media_not_present(struct scsi_disk *sdkp,\n\t\t\t     struct scsi_sense_hdr *sshdr)\n{\n\tif (!scsi_sense_valid(sshdr))\n\t\treturn 0;\n\n\t \n\tswitch (sshdr->sense_key) {\n\tcase UNIT_ATTENTION:\n\tcase NOT_READY:\n\t\t \n\t\tif (sshdr->asc == 0x3A) {\n\t\t\tset_media_not_present(sdkp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic unsigned int sd_check_events(struct gendisk *disk, unsigned int clearing)\n{\n\tstruct scsi_disk *sdkp = disk->private_data;\n\tstruct scsi_device *sdp;\n\tint retval;\n\tbool disk_changed;\n\n\tif (!sdkp)\n\t\treturn 0;\n\n\tsdp = sdkp->device;\n\tSCSI_LOG_HLQUEUE(3, sd_printk(KERN_INFO, sdkp, \"sd_check_events\\n\"));\n\n\t \n\tif (!scsi_device_online(sdp)) {\n\t\tset_media_not_present(sdkp);\n\t\tgoto out;\n\t}\n\n\t \n\tif (scsi_block_when_processing_errors(sdp)) {\n\t\tstruct scsi_sense_hdr sshdr = { 0, };\n\n\t\tretval = scsi_test_unit_ready(sdp, SD_TIMEOUT, sdkp->max_retries,\n\t\t\t\t\t      &sshdr);\n\n\t\t \n\t\tif (retval < 0 || host_byte(retval)) {\n\t\t\tset_media_not_present(sdkp);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (media_not_present(sdkp, &sshdr))\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (!sdkp->media_present)\n\t\tsdp->changed = 1;\n\tsdkp->media_present = 1;\nout:\n\t \n\tdisk_changed = sdp->changed;\n\tsdp->changed = 0;\n\treturn disk_changed ? DISK_EVENT_MEDIA_CHANGE : 0;\n}\n\nstatic int sd_sync_cache(struct scsi_disk *sdkp)\n{\n\tint retries, res;\n\tstruct scsi_device *sdp = sdkp->device;\n\tconst int timeout = sdp->request_queue->rq_timeout\n\t\t* SD_FLUSH_TIMEOUT_MULTIPLIER;\n\tstruct scsi_sense_hdr sshdr;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.req_flags = BLK_MQ_REQ_PM,\n\t\t.sshdr = &sshdr,\n\t};\n\n\tif (!scsi_device_online(sdp))\n\t\treturn -ENODEV;\n\n\tfor (retries = 3; retries > 0; --retries) {\n\t\tunsigned char cmd[16] = { 0 };\n\n\t\tif (sdp->use_16_for_sync)\n\t\t\tcmd[0] = SYNCHRONIZE_CACHE_16;\n\t\telse\n\t\t\tcmd[0] = SYNCHRONIZE_CACHE;\n\t\t \n\t\tres = scsi_execute_cmd(sdp, cmd, REQ_OP_DRV_IN, NULL, 0,\n\t\t\t\t       timeout, sdkp->max_retries, &exec_args);\n\t\tif (res == 0)\n\t\t\tbreak;\n\t}\n\n\tif (res) {\n\t\tsd_print_result(sdkp, \"Synchronize Cache(10) failed\", res);\n\n\t\tif (res < 0)\n\t\t\treturn res;\n\n\t\tif (scsi_status_is_check_condition(res) &&\n\t\t    scsi_sense_valid(&sshdr)) {\n\t\t\tsd_print_sense_hdr(sdkp, &sshdr);\n\n\t\t\t \n\t\t\tif (sshdr.asc == 0x3a ||\t \n\t\t\t    sshdr.asc == 0x20 ||\t \n\t\t\t    (sshdr.asc == 0x74 && sshdr.ascq == 0x71))\t \n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t \n\t\t\tif (sshdr.sense_key == ILLEGAL_REQUEST)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tswitch (host_byte(res)) {\n\t\t \n\t\tcase DID_BAD_TARGET:\n\t\tcase DID_NO_CONNECT:\n\t\t\treturn 0;\n\t\t \n\t\tcase DID_BUS_BUSY:\n\t\tcase DID_IMM_RETRY:\n\t\tcase DID_REQUEUE:\n\t\tcase DID_SOFT_ERROR:\n\t\t\treturn -EBUSY;\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void sd_rescan(struct device *dev)\n{\n\tstruct scsi_disk *sdkp = dev_get_drvdata(dev);\n\n\tsd_revalidate_disk(sdkp->disk);\n}\n\nstatic int sd_get_unique_id(struct gendisk *disk, u8 id[16],\n\t\tenum blk_unique_id type)\n{\n\tstruct scsi_device *sdev = scsi_disk(disk)->device;\n\tconst struct scsi_vpd *vpd;\n\tconst unsigned char *d;\n\tint ret = -ENXIO, len;\n\n\trcu_read_lock();\n\tvpd = rcu_dereference(sdev->vpd_pg83);\n\tif (!vpd)\n\t\tgoto out_unlock;\n\n\tret = -EINVAL;\n\tfor (d = vpd->data + 4; d < vpd->data + vpd->len; d += d[3] + 4) {\n\t\t \n\t\tif (((d[1] >> 4) & 0x3) != 0x00)\n\t\t\tcontinue;\n\t\tif ((d[1] & 0xf) != type)\n\t\t\tcontinue;\n\n\t\t \n\t\tlen = d[3];\n\t\tif (len != 8 && len != 12 && len != 16)\n\t\t\tcontinue;\n\t\tret = len;\n\t\tmemcpy(id, d + 4, len);\n\t\tif (len == 16)\n\t\t\tbreak;\n\t}\nout_unlock:\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int sd_scsi_to_pr_err(struct scsi_sense_hdr *sshdr, int result)\n{\n\tswitch (host_byte(result)) {\n\tcase DID_TRANSPORT_MARGINAL:\n\tcase DID_TRANSPORT_DISRUPTED:\n\tcase DID_BUS_BUSY:\n\t\treturn PR_STS_RETRY_PATH_FAILURE;\n\tcase DID_NO_CONNECT:\n\t\treturn PR_STS_PATH_FAILED;\n\tcase DID_TRANSPORT_FAILFAST:\n\t\treturn PR_STS_PATH_FAST_FAILED;\n\t}\n\n\tswitch (status_byte(result)) {\n\tcase SAM_STAT_RESERVATION_CONFLICT:\n\t\treturn PR_STS_RESERVATION_CONFLICT;\n\tcase SAM_STAT_CHECK_CONDITION:\n\t\tif (!scsi_sense_valid(sshdr))\n\t\t\treturn PR_STS_IOERR;\n\n\t\tif (sshdr->sense_key == ILLEGAL_REQUEST &&\n\t\t    (sshdr->asc == 0x26 || sshdr->asc == 0x24))\n\t\t\treturn -EINVAL;\n\n\t\tfallthrough;\n\tdefault:\n\t\treturn PR_STS_IOERR;\n\t}\n}\n\nstatic int sd_pr_in_command(struct block_device *bdev, u8 sa,\n\t\t\t    unsigned char *data, int data_len)\n{\n\tstruct scsi_disk *sdkp = scsi_disk(bdev->bd_disk);\n\tstruct scsi_device *sdev = sdkp->device;\n\tstruct scsi_sense_hdr sshdr;\n\tu8 cmd[10] = { PERSISTENT_RESERVE_IN, sa };\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\tint result;\n\n\tput_unaligned_be16(data_len, &cmd[7]);\n\n\tresult = scsi_execute_cmd(sdev, cmd, REQ_OP_DRV_IN, data, data_len,\n\t\t\t\t  SD_TIMEOUT, sdkp->max_retries, &exec_args);\n\tif (scsi_status_is_check_condition(result) &&\n\t    scsi_sense_valid(&sshdr)) {\n\t\tsdev_printk(KERN_INFO, sdev, \"PR command failed: %d\\n\", result);\n\t\tscsi_print_sense_hdr(sdev, NULL, &sshdr);\n\t}\n\n\tif (result <= 0)\n\t\treturn result;\n\n\treturn sd_scsi_to_pr_err(&sshdr, result);\n}\n\nstatic int sd_pr_read_keys(struct block_device *bdev, struct pr_keys *keys_info)\n{\n\tint result, i, data_offset, num_copy_keys;\n\tu32 num_keys = keys_info->num_keys;\n\tint data_len = num_keys * 8 + 8;\n\tu8 *data;\n\n\tdata = kzalloc(data_len, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tresult = sd_pr_in_command(bdev, READ_KEYS, data, data_len);\n\tif (result)\n\t\tgoto free_data;\n\n\tkeys_info->generation = get_unaligned_be32(&data[0]);\n\tkeys_info->num_keys = get_unaligned_be32(&data[4]) / 8;\n\n\tdata_offset = 8;\n\tnum_copy_keys = min(num_keys, keys_info->num_keys);\n\n\tfor (i = 0; i < num_copy_keys; i++) {\n\t\tkeys_info->keys[i] = get_unaligned_be64(&data[data_offset]);\n\t\tdata_offset += 8;\n\t}\n\nfree_data:\n\tkfree(data);\n\treturn result;\n}\n\nstatic int sd_pr_read_reservation(struct block_device *bdev,\n\t\t\t\t  struct pr_held_reservation *rsv)\n{\n\tstruct scsi_disk *sdkp = scsi_disk(bdev->bd_disk);\n\tstruct scsi_device *sdev = sdkp->device;\n\tu8 data[24] = { };\n\tint result, len;\n\n\tresult = sd_pr_in_command(bdev, READ_RESERVATION, data, sizeof(data));\n\tif (result)\n\t\treturn result;\n\n\tlen = get_unaligned_be32(&data[4]);\n\tif (!len)\n\t\treturn 0;\n\n\t \n\tif (len < 14) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"READ RESERVATION failed due to short return buffer of %d bytes\\n\",\n\t\t\t    len);\n\t\treturn -EINVAL;\n\t}\n\n\trsv->generation = get_unaligned_be32(&data[0]);\n\trsv->key = get_unaligned_be64(&data[8]);\n\trsv->type = scsi_pr_type_to_block(data[21] & 0x0f);\n\treturn 0;\n}\n\nstatic int sd_pr_out_command(struct block_device *bdev, u8 sa, u64 key,\n\t\t\t     u64 sa_key, enum scsi_pr_type type, u8 flags)\n{\n\tstruct scsi_disk *sdkp = scsi_disk(bdev->bd_disk);\n\tstruct scsi_device *sdev = sdkp->device;\n\tstruct scsi_sense_hdr sshdr;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\tint result;\n\tu8 cmd[16] = { 0, };\n\tu8 data[24] = { 0, };\n\n\tcmd[0] = PERSISTENT_RESERVE_OUT;\n\tcmd[1] = sa;\n\tcmd[2] = type;\n\tput_unaligned_be32(sizeof(data), &cmd[5]);\n\n\tput_unaligned_be64(key, &data[0]);\n\tput_unaligned_be64(sa_key, &data[8]);\n\tdata[20] = flags;\n\n\tresult = scsi_execute_cmd(sdev, cmd, REQ_OP_DRV_OUT, &data,\n\t\t\t\t  sizeof(data), SD_TIMEOUT, sdkp->max_retries,\n\t\t\t\t  &exec_args);\n\n\tif (scsi_status_is_check_condition(result) &&\n\t    scsi_sense_valid(&sshdr)) {\n\t\tsdev_printk(KERN_INFO, sdev, \"PR command failed: %d\\n\", result);\n\t\tscsi_print_sense_hdr(sdev, NULL, &sshdr);\n\t}\n\n\tif (result <= 0)\n\t\treturn result;\n\n\treturn sd_scsi_to_pr_err(&sshdr, result);\n}\n\nstatic int sd_pr_register(struct block_device *bdev, u64 old_key, u64 new_key,\n\t\tu32 flags)\n{\n\tif (flags & ~PR_FL_IGNORE_KEY)\n\t\treturn -EOPNOTSUPP;\n\treturn sd_pr_out_command(bdev, (flags & PR_FL_IGNORE_KEY) ? 0x06 : 0x00,\n\t\t\told_key, new_key, 0,\n\t\t\t(1 << 0)  );\n}\n\nstatic int sd_pr_reserve(struct block_device *bdev, u64 key, enum pr_type type,\n\t\tu32 flags)\n{\n\tif (flags)\n\t\treturn -EOPNOTSUPP;\n\treturn sd_pr_out_command(bdev, 0x01, key, 0,\n\t\t\t\t block_pr_type_to_scsi(type), 0);\n}\n\nstatic int sd_pr_release(struct block_device *bdev, u64 key, enum pr_type type)\n{\n\treturn sd_pr_out_command(bdev, 0x02, key, 0,\n\t\t\t\t block_pr_type_to_scsi(type), 0);\n}\n\nstatic int sd_pr_preempt(struct block_device *bdev, u64 old_key, u64 new_key,\n\t\tenum pr_type type, bool abort)\n{\n\treturn sd_pr_out_command(bdev, abort ? 0x05 : 0x04, old_key, new_key,\n\t\t\t\t block_pr_type_to_scsi(type), 0);\n}\n\nstatic int sd_pr_clear(struct block_device *bdev, u64 key)\n{\n\treturn sd_pr_out_command(bdev, 0x03, key, 0, 0, 0);\n}\n\nstatic const struct pr_ops sd_pr_ops = {\n\t.pr_register\t= sd_pr_register,\n\t.pr_reserve\t= sd_pr_reserve,\n\t.pr_release\t= sd_pr_release,\n\t.pr_preempt\t= sd_pr_preempt,\n\t.pr_clear\t= sd_pr_clear,\n\t.pr_read_keys\t= sd_pr_read_keys,\n\t.pr_read_reservation = sd_pr_read_reservation,\n};\n\nstatic void scsi_disk_free_disk(struct gendisk *disk)\n{\n\tstruct scsi_disk *sdkp = scsi_disk(disk);\n\n\tput_device(&sdkp->disk_dev);\n}\n\nstatic const struct block_device_operations sd_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= sd_open,\n\t.release\t\t= sd_release,\n\t.ioctl\t\t\t= sd_ioctl,\n\t.getgeo\t\t\t= sd_getgeo,\n\t.compat_ioctl\t\t= blkdev_compat_ptr_ioctl,\n\t.check_events\t\t= sd_check_events,\n\t.unlock_native_capacity\t= sd_unlock_native_capacity,\n\t.report_zones\t\t= sd_zbc_report_zones,\n\t.get_unique_id\t\t= sd_get_unique_id,\n\t.free_disk\t\t= scsi_disk_free_disk,\n\t.pr_ops\t\t\t= &sd_pr_ops,\n};\n\n \nstatic void sd_eh_reset(struct scsi_cmnd *scmd)\n{\n\tstruct scsi_disk *sdkp = scsi_disk(scsi_cmd_to_rq(scmd)->q->disk);\n\n\t \n\tsdkp->ignore_medium_access_errors = false;\n}\n\n \nstatic int sd_eh_action(struct scsi_cmnd *scmd, int eh_disp)\n{\n\tstruct scsi_disk *sdkp = scsi_disk(scsi_cmd_to_rq(scmd)->q->disk);\n\tstruct scsi_device *sdev = scmd->device;\n\n\tif (!scsi_device_online(sdev) ||\n\t    !scsi_medium_access_command(scmd) ||\n\t    host_byte(scmd->result) != DID_TIME_OUT ||\n\t    eh_disp != SUCCESS)\n\t\treturn eh_disp;\n\n\t \n\tif (!sdkp->ignore_medium_access_errors) {\n\t\tsdkp->medium_access_timed_out++;\n\t\tsdkp->ignore_medium_access_errors = true;\n\t}\n\n\t \n\tif (sdkp->medium_access_timed_out >= sdkp->max_medium_access_timeouts) {\n\t\tscmd_printk(KERN_ERR, scmd,\n\t\t\t    \"Medium access timeout failure. Offlining disk!\\n\");\n\t\tmutex_lock(&sdev->state_mutex);\n\t\tscsi_device_set_state(sdev, SDEV_OFFLINE);\n\t\tmutex_unlock(&sdev->state_mutex);\n\n\t\treturn SUCCESS;\n\t}\n\n\treturn eh_disp;\n}\n\nstatic unsigned int sd_completed_bytes(struct scsi_cmnd *scmd)\n{\n\tstruct request *req = scsi_cmd_to_rq(scmd);\n\tstruct scsi_device *sdev = scmd->device;\n\tunsigned int transferred, good_bytes;\n\tu64 start_lba, end_lba, bad_lba;\n\n\t \n\tif (scsi_bufflen(scmd) <= sdev->sector_size)\n\t\treturn 0;\n\n\t \n\tif (!scsi_get_sense_info_fld(scmd->sense_buffer,\n\t\t\t\t     SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t     &bad_lba))\n\t\treturn 0;\n\n\t \n\tstart_lba = sectors_to_logical(sdev, blk_rq_pos(req));\n\tend_lba = start_lba + bytes_to_logical(sdev, scsi_bufflen(scmd));\n\tif (bad_lba < start_lba || bad_lba >= end_lba)\n\t\treturn 0;\n\n\t \n\ttransferred = scsi_bufflen(scmd) - scsi_get_resid(scmd);\n\n\t \n\tgood_bytes = logical_to_bytes(sdev, bad_lba - start_lba);\n\n\treturn min(good_bytes, transferred);\n}\n\n \nstatic int sd_done(struct scsi_cmnd *SCpnt)\n{\n\tint result = SCpnt->result;\n\tunsigned int good_bytes = result ? 0 : scsi_bufflen(SCpnt);\n\tunsigned int sector_size = SCpnt->device->sector_size;\n\tunsigned int resid;\n\tstruct scsi_sense_hdr sshdr;\n\tstruct request *req = scsi_cmd_to_rq(SCpnt);\n\tstruct scsi_disk *sdkp = scsi_disk(req->q->disk);\n\tint sense_valid = 0;\n\tint sense_deferred = 0;\n\n\tswitch (req_op(req)) {\n\tcase REQ_OP_DISCARD:\n\tcase REQ_OP_WRITE_ZEROES:\n\tcase REQ_OP_ZONE_RESET:\n\tcase REQ_OP_ZONE_RESET_ALL:\n\tcase REQ_OP_ZONE_OPEN:\n\tcase REQ_OP_ZONE_CLOSE:\n\tcase REQ_OP_ZONE_FINISH:\n\t\tif (!result) {\n\t\t\tgood_bytes = blk_rq_bytes(req);\n\t\t\tscsi_set_resid(SCpnt, 0);\n\t\t} else {\n\t\t\tgood_bytes = 0;\n\t\t\tscsi_set_resid(SCpnt, blk_rq_bytes(req));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tresid = scsi_get_resid(SCpnt);\n\t\tif (resid & (sector_size - 1)) {\n\t\t\tsd_printk(KERN_INFO, sdkp,\n\t\t\t\t\"Unaligned partial completion (resid=%u, sector_sz=%u)\\n\",\n\t\t\t\tresid, sector_size);\n\t\t\tscsi_print_command(SCpnt);\n\t\t\tresid = min(scsi_bufflen(SCpnt),\n\t\t\t\t    round_up(resid, sector_size));\n\t\t\tscsi_set_resid(SCpnt, resid);\n\t\t}\n\t}\n\n\tif (result) {\n\t\tsense_valid = scsi_command_normalize_sense(SCpnt, &sshdr);\n\t\tif (sense_valid)\n\t\t\tsense_deferred = scsi_sense_is_deferred(&sshdr);\n\t}\n\tsdkp->medium_access_timed_out = 0;\n\n\tif (!scsi_status_is_check_condition(result) &&\n\t    (!sense_valid || sense_deferred))\n\t\tgoto out;\n\n\tswitch (sshdr.sense_key) {\n\tcase HARDWARE_ERROR:\n\tcase MEDIUM_ERROR:\n\t\tgood_bytes = sd_completed_bytes(SCpnt);\n\t\tbreak;\n\tcase RECOVERED_ERROR:\n\t\tgood_bytes = scsi_bufflen(SCpnt);\n\t\tbreak;\n\tcase NO_SENSE:\n\t\t \n\t\tSCpnt->result = 0;\n\t\tmemset(SCpnt->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\n\t\tbreak;\n\tcase ABORTED_COMMAND:\n\t\tif (sshdr.asc == 0x10)   \n\t\t\tgood_bytes = sd_completed_bytes(SCpnt);\n\t\tbreak;\n\tcase ILLEGAL_REQUEST:\n\t\tswitch (sshdr.asc) {\n\t\tcase 0x10:\t \n\t\t\tgood_bytes = sd_completed_bytes(SCpnt);\n\t\t\tbreak;\n\t\tcase 0x20:\t \n\t\tcase 0x24:\t \n\t\t\tswitch (SCpnt->cmnd[0]) {\n\t\t\tcase UNMAP:\n\t\t\t\tsd_config_discard(sdkp, SD_LBP_DISABLE);\n\t\t\t\tbreak;\n\t\t\tcase WRITE_SAME_16:\n\t\t\tcase WRITE_SAME:\n\t\t\t\tif (SCpnt->cmnd[1] & 8) {  \n\t\t\t\t\tsd_config_discard(sdkp, SD_LBP_DISABLE);\n\t\t\t\t} else {\n\t\t\t\t\tsdkp->device->no_write_same = 1;\n\t\t\t\t\tsd_config_write_same(sdkp);\n\t\t\t\t\treq->rq_flags |= RQF_QUIET;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n out:\n\tif (sd_is_zoned(sdkp))\n\t\tgood_bytes = sd_zbc_complete(SCpnt, good_bytes, &sshdr);\n\n\tSCSI_LOG_HLCOMPLETE(1, scmd_printk(KERN_INFO, SCpnt,\n\t\t\t\t\t   \"sd_done: completed %d of %d bytes\\n\",\n\t\t\t\t\t   good_bytes, scsi_bufflen(SCpnt)));\n\n\treturn good_bytes;\n}\n\n \nstatic void\nsd_spinup_disk(struct scsi_disk *sdkp)\n{\n\tunsigned char cmd[10];\n\tunsigned long spintime_expire = 0;\n\tint retries, spintime;\n\tunsigned int the_result;\n\tstruct scsi_sense_hdr sshdr;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\tint sense_valid = 0;\n\n\tspintime = 0;\n\n\t \n\t \n\tdo {\n\t\tretries = 0;\n\n\t\tdo {\n\t\t\tbool media_was_present = sdkp->media_present;\n\n\t\t\tcmd[0] = TEST_UNIT_READY;\n\t\t\tmemset((void *) &cmd[1], 0, 9);\n\n\t\t\tthe_result = scsi_execute_cmd(sdkp->device, cmd,\n\t\t\t\t\t\t      REQ_OP_DRV_IN, NULL, 0,\n\t\t\t\t\t\t      SD_TIMEOUT,\n\t\t\t\t\t\t      sdkp->max_retries,\n\t\t\t\t\t\t      &exec_args);\n\n\t\t\t \n\t\t\tif (media_not_present(sdkp, &sshdr)) {\n\t\t\t\tif (media_was_present)\n\t\t\t\t\tsd_printk(KERN_NOTICE, sdkp, \"Media removed, stopped polling\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (the_result)\n\t\t\t\tsense_valid = scsi_sense_valid(&sshdr);\n\t\t\tretries++;\n\t\t} while (retries < 3 &&\n\t\t\t (!scsi_status_is_good(the_result) ||\n\t\t\t  (scsi_status_is_check_condition(the_result) &&\n\t\t\t  sense_valid && sshdr.sense_key == UNIT_ATTENTION)));\n\n\t\tif (!scsi_status_is_check_condition(the_result)) {\n\t\t\t \n\t\t\tif(!spintime && !scsi_status_is_good(the_result)) {\n\t\t\t\tsd_print_result(sdkp, \"Test Unit Ready failed\",\n\t\t\t\t\t\tthe_result);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (sdkp->device->no_start_on_add)\n\t\t\tbreak;\n\n\t\tif (sense_valid && sshdr.sense_key == NOT_READY) {\n\t\t\tif (sshdr.asc == 4 && sshdr.ascq == 3)\n\t\t\t\tbreak;\t \n\t\t\tif (sshdr.asc == 4 && sshdr.ascq == 0xb)\n\t\t\t\tbreak;\t \n\t\t\tif (sshdr.asc == 4 && sshdr.ascq == 0xc)\n\t\t\t\tbreak;\t \n\t\t\tif (sshdr.asc == 4 && sshdr.ascq == 0x1b)\n\t\t\t\tbreak;\t \n\t\t\t \n\t\t\tif (!spintime) {\n\t\t\t\tsd_printk(KERN_NOTICE, sdkp, \"Spinning up disk...\");\n\t\t\t\tcmd[0] = START_STOP;\n\t\t\t\tcmd[1] = 1;\t \n\t\t\t\tmemset((void *) &cmd[2], 0, 8);\n\t\t\t\tcmd[4] = 1;\t \n\t\t\t\tif (sdkp->device->start_stop_pwr_cond)\n\t\t\t\t\tcmd[4] |= 1 << 4;\n\t\t\t\tscsi_execute_cmd(sdkp->device, cmd,\n\t\t\t\t\t\t REQ_OP_DRV_IN, NULL, 0,\n\t\t\t\t\t\t SD_TIMEOUT, sdkp->max_retries,\n\t\t\t\t\t\t &exec_args);\n\t\t\t\tspintime_expire = jiffies + 100 * HZ;\n\t\t\t\tspintime = 1;\n\t\t\t}\n\t\t\t \n\t\t\tmsleep(1000);\n\t\t\tprintk(KERN_CONT \".\");\n\n\t\t \n\t\t} else if (sense_valid &&\n\t\t\t\tsshdr.sense_key == UNIT_ATTENTION &&\n\t\t\t\tsshdr.asc == 0x28) {\n\t\t\tif (!spintime) {\n\t\t\t\tspintime_expire = jiffies + 5 * HZ;\n\t\t\t\tspintime = 1;\n\t\t\t}\n\t\t\t \n\t\t\tmsleep(1000);\n\t\t} else {\n\t\t\t \n\t\t\tif(!spintime) {\n\t\t\t\tsd_printk(KERN_NOTICE, sdkp, \"Unit Not Ready\\n\");\n\t\t\t\tsd_print_sense_hdr(sdkp, &sshdr);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\t\t\n\t} while (spintime && time_before_eq(jiffies, spintime_expire));\n\n\tif (spintime) {\n\t\tif (scsi_status_is_good(the_result))\n\t\t\tprintk(KERN_CONT \"ready\\n\");\n\t\telse\n\t\t\tprintk(KERN_CONT \"not responding...\\n\");\n\t}\n}\n\n \nstatic int sd_read_protection_type(struct scsi_disk *sdkp, unsigned char *buffer)\n{\n\tstruct scsi_device *sdp = sdkp->device;\n\tu8 type;\n\n\tif (scsi_device_protection(sdp) == 0 || (buffer[12] & 1) == 0) {\n\t\tsdkp->protection_type = 0;\n\t\treturn 0;\n\t}\n\n\ttype = ((buffer[12] >> 1) & 7) + 1;  \n\n\tif (type > T10_PI_TYPE3_PROTECTION) {\n\t\tsd_printk(KERN_ERR, sdkp, \"formatted with unsupported\"\t\\\n\t\t\t  \" protection type %u. Disabling disk!\\n\",\n\t\t\t  type);\n\t\tsdkp->protection_type = 0;\n\t\treturn -ENODEV;\n\t}\n\n\tsdkp->protection_type = type;\n\n\treturn 0;\n}\n\nstatic void sd_config_protection(struct scsi_disk *sdkp)\n{\n\tstruct scsi_device *sdp = sdkp->device;\n\n\tsd_dif_config_host(sdkp);\n\n\tif (!sdkp->protection_type)\n\t\treturn;\n\n\tif (!scsi_host_dif_capable(sdp->host, sdkp->protection_type)) {\n\t\tsd_first_printk(KERN_NOTICE, sdkp,\n\t\t\t\t\"Disabling DIF Type %u protection\\n\",\n\t\t\t\tsdkp->protection_type);\n\t\tsdkp->protection_type = 0;\n\t}\n\n\tsd_first_printk(KERN_NOTICE, sdkp, \"Enabling DIF Type %u protection\\n\",\n\t\t\tsdkp->protection_type);\n}\n\nstatic void read_capacity_error(struct scsi_disk *sdkp, struct scsi_device *sdp,\n\t\t\tstruct scsi_sense_hdr *sshdr, int sense_valid,\n\t\t\tint the_result)\n{\n\tif (sense_valid)\n\t\tsd_print_sense_hdr(sdkp, sshdr);\n\telse\n\t\tsd_printk(KERN_NOTICE, sdkp, \"Sense not available.\\n\");\n\n\t \n\tif (sdp->removable &&\n\t    sense_valid && sshdr->sense_key == NOT_READY)\n\t\tset_media_not_present(sdkp);\n\n\t \n\tsdkp->capacity = 0;  \n}\n\n#define RC16_LEN 32\n#if RC16_LEN > SD_BUF_SIZE\n#error RC16_LEN must not be more than SD_BUF_SIZE\n#endif\n\n#define READ_CAPACITY_RETRIES_ON_RESET\t10\n\nstatic int read_capacity_16(struct scsi_disk *sdkp, struct scsi_device *sdp,\n\t\t\t\t\t\tunsigned char *buffer)\n{\n\tunsigned char cmd[16];\n\tstruct scsi_sense_hdr sshdr;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\tint sense_valid = 0;\n\tint the_result;\n\tint retries = 3, reset_retries = READ_CAPACITY_RETRIES_ON_RESET;\n\tunsigned int alignment;\n\tunsigned long long lba;\n\tunsigned sector_size;\n\n\tif (sdp->no_read_capacity_16)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tmemset(cmd, 0, 16);\n\t\tcmd[0] = SERVICE_ACTION_IN_16;\n\t\tcmd[1] = SAI_READ_CAPACITY_16;\n\t\tcmd[13] = RC16_LEN;\n\t\tmemset(buffer, 0, RC16_LEN);\n\n\t\tthe_result = scsi_execute_cmd(sdp, cmd, REQ_OP_DRV_IN,\n\t\t\t\t\t      buffer, RC16_LEN, SD_TIMEOUT,\n\t\t\t\t\t      sdkp->max_retries, &exec_args);\n\n\t\tif (media_not_present(sdkp, &sshdr))\n\t\t\treturn -ENODEV;\n\n\t\tif (the_result > 0) {\n\t\t\tsense_valid = scsi_sense_valid(&sshdr);\n\t\t\tif (sense_valid &&\n\t\t\t    sshdr.sense_key == ILLEGAL_REQUEST &&\n\t\t\t    (sshdr.asc == 0x20 || sshdr.asc == 0x24) &&\n\t\t\t    sshdr.ascq == 0x00)\n\t\t\t\t \n\t\t\t\treturn -EINVAL;\n\t\t\tif (sense_valid &&\n\t\t\t    sshdr.sense_key == UNIT_ATTENTION &&\n\t\t\t    sshdr.asc == 0x29 && sshdr.ascq == 0x00)\n\t\t\t\t \n\t\t\t\tif (--reset_retries > 0)\n\t\t\t\t\tcontinue;\n\t\t}\n\t\tretries--;\n\n\t} while (the_result && retries);\n\n\tif (the_result) {\n\t\tsd_print_result(sdkp, \"Read Capacity(16) failed\", the_result);\n\t\tread_capacity_error(sdkp, sdp, &sshdr, sense_valid, the_result);\n\t\treturn -EINVAL;\n\t}\n\n\tsector_size = get_unaligned_be32(&buffer[8]);\n\tlba = get_unaligned_be64(&buffer[0]);\n\n\tif (sd_read_protection_type(sdkp, buffer) < 0) {\n\t\tsdkp->capacity = 0;\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsdkp->physical_block_size = (1 << (buffer[13] & 0xf)) * sector_size;\n\n\t \n\tsdkp->rc_basis = (buffer[12] >> 4) & 0x3;\n\n\t \n\talignment = ((buffer[14] & 0x3f) << 8 | buffer[15]) * sector_size;\n\tblk_queue_alignment_offset(sdp->request_queue, alignment);\n\tif (alignment && sdkp->first_scan)\n\t\tsd_printk(KERN_NOTICE, sdkp,\n\t\t\t  \"physical block alignment offset: %u\\n\", alignment);\n\n\tif (buffer[14] & 0x80) {  \n\t\tsdkp->lbpme = 1;\n\n\t\tif (buffer[14] & 0x40)  \n\t\t\tsdkp->lbprz = 1;\n\n\t\tsd_config_discard(sdkp, SD_LBP_WS16);\n\t}\n\n\tsdkp->capacity = lba + 1;\n\treturn sector_size;\n}\n\nstatic int read_capacity_10(struct scsi_disk *sdkp, struct scsi_device *sdp,\n\t\t\t\t\t\tunsigned char *buffer)\n{\n\tunsigned char cmd[16];\n\tstruct scsi_sense_hdr sshdr;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\tint sense_valid = 0;\n\tint the_result;\n\tint retries = 3, reset_retries = READ_CAPACITY_RETRIES_ON_RESET;\n\tsector_t lba;\n\tunsigned sector_size;\n\n\tdo {\n\t\tcmd[0] = READ_CAPACITY;\n\t\tmemset(&cmd[1], 0, 9);\n\t\tmemset(buffer, 0, 8);\n\n\t\tthe_result = scsi_execute_cmd(sdp, cmd, REQ_OP_DRV_IN, buffer,\n\t\t\t\t\t      8, SD_TIMEOUT, sdkp->max_retries,\n\t\t\t\t\t      &exec_args);\n\n\t\tif (media_not_present(sdkp, &sshdr))\n\t\t\treturn -ENODEV;\n\n\t\tif (the_result > 0) {\n\t\t\tsense_valid = scsi_sense_valid(&sshdr);\n\t\t\tif (sense_valid &&\n\t\t\t    sshdr.sense_key == UNIT_ATTENTION &&\n\t\t\t    sshdr.asc == 0x29 && sshdr.ascq == 0x00)\n\t\t\t\t \n\t\t\t\tif (--reset_retries > 0)\n\t\t\t\t\tcontinue;\n\t\t}\n\t\tretries--;\n\n\t} while (the_result && retries);\n\n\tif (the_result) {\n\t\tsd_print_result(sdkp, \"Read Capacity(10) failed\", the_result);\n\t\tread_capacity_error(sdkp, sdp, &sshdr, sense_valid, the_result);\n\t\treturn -EINVAL;\n\t}\n\n\tsector_size = get_unaligned_be32(&buffer[4]);\n\tlba = get_unaligned_be32(&buffer[0]);\n\n\tif (sdp->no_read_capacity_16 && (lba == 0xffffffff)) {\n\t\t \n\t\tsdkp->capacity = 0;\n\t\tsdkp->physical_block_size = sector_size;\n\t\treturn sector_size;\n\t}\n\n\tsdkp->capacity = lba + 1;\n\tsdkp->physical_block_size = sector_size;\n\treturn sector_size;\n}\n\nstatic int sd_try_rc16_first(struct scsi_device *sdp)\n{\n\tif (sdp->host->max_cmd_len < 16)\n\t\treturn 0;\n\tif (sdp->try_rc_10_first)\n\t\treturn 0;\n\tif (sdp->scsi_level > SCSI_SPC_2)\n\t\treturn 1;\n\tif (scsi_device_protection(sdp))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic void\nsd_read_capacity(struct scsi_disk *sdkp, unsigned char *buffer)\n{\n\tint sector_size;\n\tstruct scsi_device *sdp = sdkp->device;\n\n\tif (sd_try_rc16_first(sdp)) {\n\t\tsector_size = read_capacity_16(sdkp, sdp, buffer);\n\t\tif (sector_size == -EOVERFLOW)\n\t\t\tgoto got_data;\n\t\tif (sector_size == -ENODEV)\n\t\t\treturn;\n\t\tif (sector_size < 0)\n\t\t\tsector_size = read_capacity_10(sdkp, sdp, buffer);\n\t\tif (sector_size < 0)\n\t\t\treturn;\n\t} else {\n\t\tsector_size = read_capacity_10(sdkp, sdp, buffer);\n\t\tif (sector_size == -EOVERFLOW)\n\t\t\tgoto got_data;\n\t\tif (sector_size < 0)\n\t\t\treturn;\n\t\tif ((sizeof(sdkp->capacity) > 4) &&\n\t\t    (sdkp->capacity > 0xffffffffULL)) {\n\t\t\tint old_sector_size = sector_size;\n\t\t\tsd_printk(KERN_NOTICE, sdkp, \"Very big device. \"\n\t\t\t\t\t\"Trying to use READ CAPACITY(16).\\n\");\n\t\t\tsector_size = read_capacity_16(sdkp, sdp, buffer);\n\t\t\tif (sector_size < 0) {\n\t\t\t\tsd_printk(KERN_NOTICE, sdkp,\n\t\t\t\t\t\"Using 0xffffffff as device size\\n\");\n\t\t\t\tsdkp->capacity = 1 + (sector_t) 0xffffffff;\n\t\t\t\tsector_size = old_sector_size;\n\t\t\t\tgoto got_data;\n\t\t\t}\n\t\t\t \n\t\t\tsdp->try_rc_10_first = 0;\n\t\t}\n\t}\n\n\t \n\tif (sdp->fix_capacity ||\n\t    (sdp->guess_capacity && (sdkp->capacity & 0x01))) {\n\t\tsd_printk(KERN_INFO, sdkp, \"Adjusting the sector count \"\n\t\t\t\t\"from its reported value: %llu\\n\",\n\t\t\t\t(unsigned long long) sdkp->capacity);\n\t\t--sdkp->capacity;\n\t}\n\ngot_data:\n\tif (sector_size == 0) {\n\t\tsector_size = 512;\n\t\tsd_printk(KERN_NOTICE, sdkp, \"Sector size 0 reported, \"\n\t\t\t  \"assuming 512.\\n\");\n\t}\n\n\tif (sector_size != 512 &&\n\t    sector_size != 1024 &&\n\t    sector_size != 2048 &&\n\t    sector_size != 4096) {\n\t\tsd_printk(KERN_NOTICE, sdkp, \"Unsupported sector size %d.\\n\",\n\t\t\t  sector_size);\n\t\t \n\t\tsdkp->capacity = 0;\n\t\t \n\t\tsector_size = 512;\n\t}\n\tblk_queue_logical_block_size(sdp->request_queue, sector_size);\n\tblk_queue_physical_block_size(sdp->request_queue,\n\t\t\t\t      sdkp->physical_block_size);\n\tsdkp->device->sector_size = sector_size;\n\n\tif (sdkp->capacity > 0xffffffff)\n\t\tsdp->use_16_for_rw = 1;\n\n}\n\n \nstatic void\nsd_print_capacity(struct scsi_disk *sdkp,\n\t\t  sector_t old_capacity)\n{\n\tint sector_size = sdkp->device->sector_size;\n\tchar cap_str_2[10], cap_str_10[10];\n\n\tif (!sdkp->first_scan && old_capacity == sdkp->capacity)\n\t\treturn;\n\n\tstring_get_size(sdkp->capacity, sector_size,\n\t\t\tSTRING_UNITS_2, cap_str_2, sizeof(cap_str_2));\n\tstring_get_size(sdkp->capacity, sector_size,\n\t\t\tSTRING_UNITS_10, cap_str_10, sizeof(cap_str_10));\n\n\tsd_printk(KERN_NOTICE, sdkp,\n\t\t  \"%llu %d-byte logical blocks: (%s/%s)\\n\",\n\t\t  (unsigned long long)sdkp->capacity,\n\t\t  sector_size, cap_str_10, cap_str_2);\n\n\tif (sdkp->physical_block_size != sector_size)\n\t\tsd_printk(KERN_NOTICE, sdkp,\n\t\t\t  \"%u-byte physical blocks\\n\",\n\t\t\t  sdkp->physical_block_size);\n}\n\n \nstatic inline int\nsd_do_mode_sense(struct scsi_disk *sdkp, int dbd, int modepage,\n\t\t unsigned char *buffer, int len, struct scsi_mode_data *data,\n\t\t struct scsi_sense_hdr *sshdr)\n{\n\t \n\tif (sdkp->device->use_10_for_ms && len < 8)\n\t\tlen = 8;\n\n\treturn scsi_mode_sense(sdkp->device, dbd, modepage, 0, buffer, len,\n\t\t\t       SD_TIMEOUT, sdkp->max_retries, data, sshdr);\n}\n\n \nstatic void\nsd_read_write_protect_flag(struct scsi_disk *sdkp, unsigned char *buffer)\n{\n\tint res;\n\tstruct scsi_device *sdp = sdkp->device;\n\tstruct scsi_mode_data data;\n\tint old_wp = sdkp->write_prot;\n\n\tset_disk_ro(sdkp->disk, 0);\n\tif (sdp->skip_ms_page_3f) {\n\t\tsd_first_printk(KERN_NOTICE, sdkp, \"Assuming Write Enabled\\n\");\n\t\treturn;\n\t}\n\n\tif (sdp->use_192_bytes_for_3f) {\n\t\tres = sd_do_mode_sense(sdkp, 0, 0x3F, buffer, 192, &data, NULL);\n\t} else {\n\t\t \n\t\tres = sd_do_mode_sense(sdkp, 0, 0x3F, buffer, 4, &data, NULL);\n\n\t\t \n\t\tif (res < 0)\n\t\t\tres = sd_do_mode_sense(sdkp, 0, 0, buffer, 4, &data, NULL);\n\n\t\t \n\t\tif (res < 0)\n\t\t\tres = sd_do_mode_sense(sdkp, 0, 0x3F, buffer, 255,\n\t\t\t\t\t       &data, NULL);\n\t}\n\n\tif (res < 0) {\n\t\tsd_first_printk(KERN_WARNING, sdkp,\n\t\t\t  \"Test WP failed, assume Write Enabled\\n\");\n\t} else {\n\t\tsdkp->write_prot = ((data.device_specific & 0x80) != 0);\n\t\tset_disk_ro(sdkp->disk, sdkp->write_prot);\n\t\tif (sdkp->first_scan || old_wp != sdkp->write_prot) {\n\t\t\tsd_printk(KERN_NOTICE, sdkp, \"Write Protect is %s\\n\",\n\t\t\t\t  sdkp->write_prot ? \"on\" : \"off\");\n\t\t\tsd_printk(KERN_DEBUG, sdkp, \"Mode Sense: %4ph\\n\", buffer);\n\t\t}\n\t}\n}\n\n \nstatic void\nsd_read_cache_type(struct scsi_disk *sdkp, unsigned char *buffer)\n{\n\tint len = 0, res;\n\tstruct scsi_device *sdp = sdkp->device;\n\n\tint dbd;\n\tint modepage;\n\tint first_len;\n\tstruct scsi_mode_data data;\n\tstruct scsi_sense_hdr sshdr;\n\tint old_wce = sdkp->WCE;\n\tint old_rcd = sdkp->RCD;\n\tint old_dpofua = sdkp->DPOFUA;\n\n\n\tif (sdkp->cache_override)\n\t\treturn;\n\n\tfirst_len = 4;\n\tif (sdp->skip_ms_page_8) {\n\t\tif (sdp->type == TYPE_RBC)\n\t\t\tgoto defaults;\n\t\telse {\n\t\t\tif (sdp->skip_ms_page_3f)\n\t\t\t\tgoto defaults;\n\t\t\tmodepage = 0x3F;\n\t\t\tif (sdp->use_192_bytes_for_3f)\n\t\t\t\tfirst_len = 192;\n\t\t\tdbd = 0;\n\t\t}\n\t} else if (sdp->type == TYPE_RBC) {\n\t\tmodepage = 6;\n\t\tdbd = 8;\n\t} else {\n\t\tmodepage = 8;\n\t\tdbd = 0;\n\t}\n\n\t \n\tres = sd_do_mode_sense(sdkp, dbd, modepage, buffer, first_len,\n\t\t\t&data, &sshdr);\n\n\tif (res < 0)\n\t\tgoto bad_sense;\n\n\tif (!data.header_length) {\n\t\tmodepage = 6;\n\t\tfirst_len = 0;\n\t\tsd_first_printk(KERN_ERR, sdkp,\n\t\t\t\t\"Missing header in MODE_SENSE response\\n\");\n\t}\n\n\t \n\tlen = data.length;\n\n\t \n\tif (len < 3)\n\t\tgoto bad_sense;\n\telse if (len > SD_BUF_SIZE) {\n\t\tsd_first_printk(KERN_NOTICE, sdkp, \"Truncating mode parameter \"\n\t\t\t  \"data from %d to %d bytes\\n\", len, SD_BUF_SIZE);\n\t\tlen = SD_BUF_SIZE;\n\t}\n\tif (modepage == 0x3F && sdp->use_192_bytes_for_3f)\n\t\tlen = 192;\n\n\t \n\tif (len > first_len)\n\t\tres = sd_do_mode_sense(sdkp, dbd, modepage, buffer, len,\n\t\t\t\t&data, &sshdr);\n\n\tif (!res) {\n\t\tint offset = data.header_length + data.block_descriptor_length;\n\n\t\twhile (offset < len) {\n\t\t\tu8 page_code = buffer[offset] & 0x3F;\n\t\t\tu8 spf       = buffer[offset] & 0x40;\n\n\t\t\tif (page_code == 8 || page_code == 6) {\n\t\t\t\t \n\t\t\t\tif (len - offset <= 2) {\n\t\t\t\t\tsd_first_printk(KERN_ERR, sdkp,\n\t\t\t\t\t\t\"Incomplete mode parameter \"\n\t\t\t\t\t\t\t\"data\\n\");\n\t\t\t\t\tgoto defaults;\n\t\t\t\t} else {\n\t\t\t\t\tmodepage = page_code;\n\t\t\t\t\tgoto Page_found;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (spf && len - offset > 3)\n\t\t\t\t\toffset += 4 + (buffer[offset+2] << 8) +\n\t\t\t\t\t\tbuffer[offset+3];\n\t\t\t\telse if (!spf && len - offset > 1)\n\t\t\t\t\toffset += 2 + buffer[offset+1];\n\t\t\t\telse {\n\t\t\t\t\tsd_first_printk(KERN_ERR, sdkp,\n\t\t\t\t\t\t\t\"Incomplete mode \"\n\t\t\t\t\t\t\t\"parameter data\\n\");\n\t\t\t\t\tgoto defaults;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsd_first_printk(KERN_WARNING, sdkp,\n\t\t\t\t\"No Caching mode page found\\n\");\n\t\tgoto defaults;\n\n\tPage_found:\n\t\tif (modepage == 8) {\n\t\t\tsdkp->WCE = ((buffer[offset + 2] & 0x04) != 0);\n\t\t\tsdkp->RCD = ((buffer[offset + 2] & 0x01) != 0);\n\t\t} else {\n\t\t\tsdkp->WCE = ((buffer[offset + 2] & 0x01) == 0);\n\t\t\tsdkp->RCD = 0;\n\t\t}\n\n\t\tsdkp->DPOFUA = (data.device_specific & 0x10) != 0;\n\t\tif (sdp->broken_fua) {\n\t\t\tsd_first_printk(KERN_NOTICE, sdkp, \"Disabling FUA\\n\");\n\t\t\tsdkp->DPOFUA = 0;\n\t\t} else if (sdkp->DPOFUA && !sdkp->device->use_10_for_rw &&\n\t\t\t   !sdkp->device->use_16_for_rw) {\n\t\t\tsd_first_printk(KERN_NOTICE, sdkp,\n\t\t\t\t  \"Uses READ/WRITE(6), disabling FUA\\n\");\n\t\t\tsdkp->DPOFUA = 0;\n\t\t}\n\n\t\t \n\t\tif (sdkp->WCE && sdkp->write_prot)\n\t\t\tsdkp->WCE = 0;\n\n\t\tif (sdkp->first_scan || old_wce != sdkp->WCE ||\n\t\t    old_rcd != sdkp->RCD || old_dpofua != sdkp->DPOFUA)\n\t\t\tsd_printk(KERN_NOTICE, sdkp,\n\t\t\t\t  \"Write cache: %s, read cache: %s, %s\\n\",\n\t\t\t\t  sdkp->WCE ? \"enabled\" : \"disabled\",\n\t\t\t\t  sdkp->RCD ? \"disabled\" : \"enabled\",\n\t\t\t\t  sdkp->DPOFUA ? \"supports DPO and FUA\"\n\t\t\t\t  : \"doesn't support DPO or FUA\");\n\n\t\treturn;\n\t}\n\nbad_sense:\n\tif (scsi_sense_valid(&sshdr) &&\n\t    sshdr.sense_key == ILLEGAL_REQUEST &&\n\t    sshdr.asc == 0x24 && sshdr.ascq == 0x0)\n\t\t \n\t\tsd_first_printk(KERN_NOTICE, sdkp, \"Cache data unavailable\\n\");\n\telse\n\t\tsd_first_printk(KERN_ERR, sdkp,\n\t\t\t\t\"Asking for cache data failed\\n\");\n\ndefaults:\n\tif (sdp->wce_default_on) {\n\t\tsd_first_printk(KERN_NOTICE, sdkp,\n\t\t\t\t\"Assuming drive cache: write back\\n\");\n\t\tsdkp->WCE = 1;\n\t} else {\n\t\tsd_first_printk(KERN_WARNING, sdkp,\n\t\t\t\t\"Assuming drive cache: write through\\n\");\n\t\tsdkp->WCE = 0;\n\t}\n\tsdkp->RCD = 0;\n\tsdkp->DPOFUA = 0;\n}\n\n \nstatic void sd_read_app_tag_own(struct scsi_disk *sdkp, unsigned char *buffer)\n{\n\tint res, offset;\n\tstruct scsi_device *sdp = sdkp->device;\n\tstruct scsi_mode_data data;\n\tstruct scsi_sense_hdr sshdr;\n\n\tif (sdp->type != TYPE_DISK && sdp->type != TYPE_ZBC)\n\t\treturn;\n\n\tif (sdkp->protection_type == 0)\n\t\treturn;\n\n\tres = scsi_mode_sense(sdp, 1, 0x0a, 0, buffer, 36, SD_TIMEOUT,\n\t\t\t      sdkp->max_retries, &data, &sshdr);\n\n\tif (res < 0 || !data.header_length ||\n\t    data.length < 6) {\n\t\tsd_first_printk(KERN_WARNING, sdkp,\n\t\t\t  \"getting Control mode page failed, assume no ATO\\n\");\n\n\t\tif (scsi_sense_valid(&sshdr))\n\t\t\tsd_print_sense_hdr(sdkp, &sshdr);\n\n\t\treturn;\n\t}\n\n\toffset = data.header_length + data.block_descriptor_length;\n\n\tif ((buffer[offset] & 0x3f) != 0x0a) {\n\t\tsd_first_printk(KERN_ERR, sdkp, \"ATO Got wrong page\\n\");\n\t\treturn;\n\t}\n\n\tif ((buffer[offset + 5] & 0x80) == 0)\n\t\treturn;\n\n\tsdkp->ATO = 1;\n\n\treturn;\n}\n\n \nstatic void sd_read_block_limits(struct scsi_disk *sdkp)\n{\n\tstruct scsi_vpd *vpd;\n\n\trcu_read_lock();\n\n\tvpd = rcu_dereference(sdkp->device->vpd_pgb0);\n\tif (!vpd || vpd->len < 16)\n\t\tgoto out;\n\n\tsdkp->min_xfer_blocks = get_unaligned_be16(&vpd->data[6]);\n\tsdkp->max_xfer_blocks = get_unaligned_be32(&vpd->data[8]);\n\tsdkp->opt_xfer_blocks = get_unaligned_be32(&vpd->data[12]);\n\n\tif (vpd->len >= 64) {\n\t\tunsigned int lba_count, desc_count;\n\n\t\tsdkp->max_ws_blocks = (u32)get_unaligned_be64(&vpd->data[36]);\n\n\t\tif (!sdkp->lbpme)\n\t\t\tgoto out;\n\n\t\tlba_count = get_unaligned_be32(&vpd->data[20]);\n\t\tdesc_count = get_unaligned_be32(&vpd->data[24]);\n\n\t\tif (lba_count && desc_count)\n\t\t\tsdkp->max_unmap_blocks = lba_count;\n\n\t\tsdkp->unmap_granularity = get_unaligned_be32(&vpd->data[28]);\n\n\t\tif (vpd->data[32] & 0x80)\n\t\t\tsdkp->unmap_alignment =\n\t\t\t\tget_unaligned_be32(&vpd->data[32]) & ~(1 << 31);\n\n\t\tif (!sdkp->lbpvpd) {  \n\n\t\t\tif (sdkp->max_unmap_blocks)\n\t\t\t\tsd_config_discard(sdkp, SD_LBP_UNMAP);\n\t\t\telse\n\t\t\t\tsd_config_discard(sdkp, SD_LBP_WS16);\n\n\t\t} else {\t \n\t\t\tif (sdkp->lbpu && sdkp->max_unmap_blocks)\n\t\t\t\tsd_config_discard(sdkp, SD_LBP_UNMAP);\n\t\t\telse if (sdkp->lbpws)\n\t\t\t\tsd_config_discard(sdkp, SD_LBP_WS16);\n\t\t\telse if (sdkp->lbpws10)\n\t\t\t\tsd_config_discard(sdkp, SD_LBP_WS10);\n\t\t\telse\n\t\t\t\tsd_config_discard(sdkp, SD_LBP_DISABLE);\n\t\t}\n\t}\n\n out:\n\trcu_read_unlock();\n}\n\n \nstatic void sd_read_block_characteristics(struct scsi_disk *sdkp)\n{\n\tstruct request_queue *q = sdkp->disk->queue;\n\tstruct scsi_vpd *vpd;\n\tu16 rot;\n\tu8 zoned;\n\n\trcu_read_lock();\n\tvpd = rcu_dereference(sdkp->device->vpd_pgb1);\n\n\tif (!vpd || vpd->len < 8) {\n\t\trcu_read_unlock();\n\t        return;\n\t}\n\n\trot = get_unaligned_be16(&vpd->data[4]);\n\tzoned = (vpd->data[8] >> 4) & 3;\n\trcu_read_unlock();\n\n\tif (rot == 1) {\n\t\tblk_queue_flag_set(QUEUE_FLAG_NONROT, q);\n\t\tblk_queue_flag_clear(QUEUE_FLAG_ADD_RANDOM, q);\n\t}\n\n\tif (sdkp->device->type == TYPE_ZBC) {\n\t\t \n\t\tdisk_set_zoned(sdkp->disk, BLK_ZONED_HM);\n\t\tblk_queue_zone_write_granularity(q, sdkp->physical_block_size);\n\t} else {\n\t\tsdkp->zoned = zoned;\n\t\tif (sdkp->zoned == 1) {\n\t\t\t \n\t\t\tdisk_set_zoned(sdkp->disk, BLK_ZONED_HA);\n\t\t} else {\n\t\t\t \n\t\t\tdisk_set_zoned(sdkp->disk, BLK_ZONED_NONE);\n\t\t}\n\t}\n\n\tif (!sdkp->first_scan)\n\t\treturn;\n\n\tif (blk_queue_is_zoned(q)) {\n\t\tsd_printk(KERN_NOTICE, sdkp, \"Host-%s zoned block device\\n\",\n\t\t      q->limits.zoned == BLK_ZONED_HM ? \"managed\" : \"aware\");\n\t} else {\n\t\tif (sdkp->zoned == 1)\n\t\t\tsd_printk(KERN_NOTICE, sdkp,\n\t\t\t\t  \"Host-aware SMR disk used as regular disk\\n\");\n\t\telse if (sdkp->zoned == 2)\n\t\t\tsd_printk(KERN_NOTICE, sdkp,\n\t\t\t\t  \"Drive-managed SMR disk\\n\");\n\t}\n}\n\n \nstatic void sd_read_block_provisioning(struct scsi_disk *sdkp)\n{\n\tstruct scsi_vpd *vpd;\n\n\tif (sdkp->lbpme == 0)\n\t\treturn;\n\n\trcu_read_lock();\n\tvpd = rcu_dereference(sdkp->device->vpd_pgb2);\n\n\tif (!vpd || vpd->len < 8) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tsdkp->lbpvpd\t= 1;\n\tsdkp->lbpu\t= (vpd->data[5] >> 7) & 1;  \n\tsdkp->lbpws\t= (vpd->data[5] >> 6) & 1;  \n\tsdkp->lbpws10\t= (vpd->data[5] >> 5) & 1;  \n\trcu_read_unlock();\n}\n\nstatic void sd_read_write_same(struct scsi_disk *sdkp, unsigned char *buffer)\n{\n\tstruct scsi_device *sdev = sdkp->device;\n\n\tif (sdev->host->no_write_same) {\n\t\tsdev->no_write_same = 1;\n\n\t\treturn;\n\t}\n\n\tif (scsi_report_opcode(sdev, buffer, SD_BUF_SIZE, INQUIRY, 0) < 0) {\n\t\tstruct scsi_vpd *vpd;\n\n\t\tsdev->no_report_opcodes = 1;\n\n\t\t \n\t\trcu_read_lock();\n\t\tvpd = rcu_dereference(sdev->vpd_pg89);\n\t\tif (vpd)\n\t\t\tsdev->no_write_same = 1;\n\t\trcu_read_unlock();\n\t}\n\n\tif (scsi_report_opcode(sdev, buffer, SD_BUF_SIZE, WRITE_SAME_16, 0) == 1)\n\t\tsdkp->ws16 = 1;\n\n\tif (scsi_report_opcode(sdev, buffer, SD_BUF_SIZE, WRITE_SAME, 0) == 1)\n\t\tsdkp->ws10 = 1;\n}\n\nstatic void sd_read_security(struct scsi_disk *sdkp, unsigned char *buffer)\n{\n\tstruct scsi_device *sdev = sdkp->device;\n\n\tif (!sdev->security_supported)\n\t\treturn;\n\n\tif (scsi_report_opcode(sdev, buffer, SD_BUF_SIZE,\n\t\t\tSECURITY_PROTOCOL_IN, 0) == 1 &&\n\t    scsi_report_opcode(sdev, buffer, SD_BUF_SIZE,\n\t\t\tSECURITY_PROTOCOL_OUT, 0) == 1)\n\t\tsdkp->security = 1;\n}\n\nstatic inline sector_t sd64_to_sectors(struct scsi_disk *sdkp, u8 *buf)\n{\n\treturn logical_to_sectors(sdkp->device, get_unaligned_be64(buf));\n}\n\n \nstatic void sd_read_cpr(struct scsi_disk *sdkp)\n{\n\tstruct blk_independent_access_ranges *iars = NULL;\n\tunsigned char *buffer = NULL;\n\tunsigned int nr_cpr = 0;\n\tint i, vpd_len, buf_len = SD_BUF_SIZE;\n\tu8 *desc;\n\n\t \n\tif (sdkp->first_scan)\n\t\treturn;\n\n\tif (!sdkp->capacity)\n\t\tgoto out;\n\n\t \n\tbuf_len = 64 + 256*32;\n\tbuffer = kmalloc(buf_len, GFP_KERNEL);\n\tif (!buffer || scsi_get_vpd_page(sdkp->device, 0xb9, buffer, buf_len))\n\t\tgoto out;\n\n\t \n\tvpd_len = get_unaligned_be16(&buffer[2]) + 4;\n\tif (vpd_len > buf_len || vpd_len < 64 + 32 || (vpd_len & 31)) {\n\t\tsd_printk(KERN_ERR, sdkp,\n\t\t\t  \"Invalid Concurrent Positioning Ranges VPD page\\n\");\n\t\tgoto out;\n\t}\n\n\tnr_cpr = (vpd_len - 64) / 32;\n\tif (nr_cpr == 1) {\n\t\tnr_cpr = 0;\n\t\tgoto out;\n\t}\n\n\tiars = disk_alloc_independent_access_ranges(sdkp->disk, nr_cpr);\n\tif (!iars) {\n\t\tnr_cpr = 0;\n\t\tgoto out;\n\t}\n\n\tdesc = &buffer[64];\n\tfor (i = 0; i < nr_cpr; i++, desc += 32) {\n\t\tif (desc[0] != i) {\n\t\t\tsd_printk(KERN_ERR, sdkp,\n\t\t\t\t\"Invalid Concurrent Positioning Range number\\n\");\n\t\t\tnr_cpr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tiars->ia_range[i].sector = sd64_to_sectors(sdkp, desc + 8);\n\t\tiars->ia_range[i].nr_sectors = sd64_to_sectors(sdkp, desc + 16);\n\t}\n\nout:\n\tdisk_set_independent_access_ranges(sdkp->disk, iars);\n\tif (nr_cpr && sdkp->nr_actuators != nr_cpr) {\n\t\tsd_printk(KERN_NOTICE, sdkp,\n\t\t\t  \"%u concurrent positioning ranges\\n\", nr_cpr);\n\t\tsdkp->nr_actuators = nr_cpr;\n\t}\n\n\tkfree(buffer);\n}\n\nstatic bool sd_validate_min_xfer_size(struct scsi_disk *sdkp)\n{\n\tstruct scsi_device *sdp = sdkp->device;\n\tunsigned int min_xfer_bytes =\n\t\tlogical_to_bytes(sdp, sdkp->min_xfer_blocks);\n\n\tif (sdkp->min_xfer_blocks == 0)\n\t\treturn false;\n\n\tif (min_xfer_bytes & (sdkp->physical_block_size - 1)) {\n\t\tsd_first_printk(KERN_WARNING, sdkp,\n\t\t\t\t\"Preferred minimum I/O size %u bytes not a \" \\\n\t\t\t\t\"multiple of physical block size (%u bytes)\\n\",\n\t\t\t\tmin_xfer_bytes, sdkp->physical_block_size);\n\t\tsdkp->min_xfer_blocks = 0;\n\t\treturn false;\n\t}\n\n\tsd_first_printk(KERN_INFO, sdkp, \"Preferred minimum I/O size %u bytes\\n\",\n\t\t\tmin_xfer_bytes);\n\treturn true;\n}\n\n \nstatic bool sd_validate_opt_xfer_size(struct scsi_disk *sdkp,\n\t\t\t\t      unsigned int dev_max)\n{\n\tstruct scsi_device *sdp = sdkp->device;\n\tunsigned int opt_xfer_bytes =\n\t\tlogical_to_bytes(sdp, sdkp->opt_xfer_blocks);\n\tunsigned int min_xfer_bytes =\n\t\tlogical_to_bytes(sdp, sdkp->min_xfer_blocks);\n\n\tif (sdkp->opt_xfer_blocks == 0)\n\t\treturn false;\n\n\tif (sdkp->opt_xfer_blocks > dev_max) {\n\t\tsd_first_printk(KERN_WARNING, sdkp,\n\t\t\t\t\"Optimal transfer size %u logical blocks \" \\\n\t\t\t\t\"> dev_max (%u logical blocks)\\n\",\n\t\t\t\tsdkp->opt_xfer_blocks, dev_max);\n\t\treturn false;\n\t}\n\n\tif (sdkp->opt_xfer_blocks > SD_DEF_XFER_BLOCKS) {\n\t\tsd_first_printk(KERN_WARNING, sdkp,\n\t\t\t\t\"Optimal transfer size %u logical blocks \" \\\n\t\t\t\t\"> sd driver limit (%u logical blocks)\\n\",\n\t\t\t\tsdkp->opt_xfer_blocks, SD_DEF_XFER_BLOCKS);\n\t\treturn false;\n\t}\n\n\tif (opt_xfer_bytes < PAGE_SIZE) {\n\t\tsd_first_printk(KERN_WARNING, sdkp,\n\t\t\t\t\"Optimal transfer size %u bytes < \" \\\n\t\t\t\t\"PAGE_SIZE (%u bytes)\\n\",\n\t\t\t\topt_xfer_bytes, (unsigned int)PAGE_SIZE);\n\t\treturn false;\n\t}\n\n\tif (min_xfer_bytes && opt_xfer_bytes % min_xfer_bytes) {\n\t\tsd_first_printk(KERN_WARNING, sdkp,\n\t\t\t\t\"Optimal transfer size %u bytes not a \" \\\n\t\t\t\t\"multiple of preferred minimum block \" \\\n\t\t\t\t\"size (%u bytes)\\n\",\n\t\t\t\topt_xfer_bytes, min_xfer_bytes);\n\t\treturn false;\n\t}\n\n\tif (opt_xfer_bytes & (sdkp->physical_block_size - 1)) {\n\t\tsd_first_printk(KERN_WARNING, sdkp,\n\t\t\t\t\"Optimal transfer size %u bytes not a \" \\\n\t\t\t\t\"multiple of physical block size (%u bytes)\\n\",\n\t\t\t\topt_xfer_bytes, sdkp->physical_block_size);\n\t\treturn false;\n\t}\n\n\tsd_first_printk(KERN_INFO, sdkp, \"Optimal transfer size %u bytes\\n\",\n\t\t\topt_xfer_bytes);\n\treturn true;\n}\n\n \nstatic int sd_revalidate_disk(struct gendisk *disk)\n{\n\tstruct scsi_disk *sdkp = scsi_disk(disk);\n\tstruct scsi_device *sdp = sdkp->device;\n\tstruct request_queue *q = sdkp->disk->queue;\n\tsector_t old_capacity = sdkp->capacity;\n\tunsigned char *buffer;\n\tunsigned int dev_max, rw_max;\n\n\tSCSI_LOG_HLQUEUE(3, sd_printk(KERN_INFO, sdkp,\n\t\t\t\t      \"sd_revalidate_disk\\n\"));\n\n\t \n\tif (!scsi_device_online(sdp))\n\t\tgoto out;\n\n\tbuffer = kmalloc(SD_BUF_SIZE, GFP_KERNEL);\n\tif (!buffer) {\n\t\tsd_printk(KERN_WARNING, sdkp, \"sd_revalidate_disk: Memory \"\n\t\t\t  \"allocation failure.\\n\");\n\t\tgoto out;\n\t}\n\n\tsd_spinup_disk(sdkp);\n\n\t \n\tif (sdkp->media_present) {\n\t\tsd_read_capacity(sdkp, buffer);\n\n\t\t \n\t\tblk_queue_flag_clear(QUEUE_FLAG_NONROT, q);\n\t\tblk_queue_flag_set(QUEUE_FLAG_ADD_RANDOM, q);\n\n\t\tif (scsi_device_supports_vpd(sdp)) {\n\t\t\tsd_read_block_provisioning(sdkp);\n\t\t\tsd_read_block_limits(sdkp);\n\t\t\tsd_read_block_characteristics(sdkp);\n\t\t\tsd_zbc_read_zones(sdkp, buffer);\n\t\t\tsd_read_cpr(sdkp);\n\t\t}\n\n\t\tsd_print_capacity(sdkp, old_capacity);\n\n\t\tsd_read_write_protect_flag(sdkp, buffer);\n\t\tsd_read_cache_type(sdkp, buffer);\n\t\tsd_read_app_tag_own(sdkp, buffer);\n\t\tsd_read_write_same(sdkp, buffer);\n\t\tsd_read_security(sdkp, buffer);\n\t\tsd_config_protection(sdkp);\n\t}\n\n\t \n\tsd_set_flush_flag(sdkp);\n\n\t \n\tdev_max = sdp->use_16_for_rw ? SD_MAX_XFER_BLOCKS : SD_DEF_XFER_BLOCKS;\n\n\t \n\tdev_max = min_not_zero(dev_max, sdkp->max_xfer_blocks);\n\tq->limits.max_dev_sectors = logical_to_sectors(sdp, dev_max);\n\n\tif (sd_validate_min_xfer_size(sdkp))\n\t\tblk_queue_io_min(sdkp->disk->queue,\n\t\t\t\t logical_to_bytes(sdp, sdkp->min_xfer_blocks));\n\telse\n\t\tblk_queue_io_min(sdkp->disk->queue, 0);\n\n\tif (sd_validate_opt_xfer_size(sdkp, dev_max)) {\n\t\tq->limits.io_opt = logical_to_bytes(sdp, sdkp->opt_xfer_blocks);\n\t\trw_max = logical_to_sectors(sdp, sdkp->opt_xfer_blocks);\n\t} else {\n\t\tq->limits.io_opt = 0;\n\t\trw_max = min_not_zero(logical_to_sectors(sdp, dev_max),\n\t\t\t\t      (sector_t)BLK_DEF_MAX_SECTORS);\n\t}\n\n\t \n\trw_max = min_not_zero(rw_max, sdp->host->opt_sectors);\n\n\t \n\trw_max = min(rw_max, queue_max_hw_sectors(q));\n\n\t \n\tif (sdkp->first_scan ||\n\t    q->limits.max_sectors > q->limits.max_dev_sectors ||\n\t    q->limits.max_sectors > q->limits.max_hw_sectors)\n\t\tq->limits.max_sectors = rw_max;\n\n\tsdkp->first_scan = 0;\n\n\tset_capacity_and_notify(disk, logical_to_sectors(sdp, sdkp->capacity));\n\tsd_config_write_same(sdkp);\n\tkfree(buffer);\n\n\t \n\tif (sd_zbc_revalidate_zones(sdkp))\n\t\tset_capacity_and_notify(disk, 0);\n\n out:\n\treturn 0;\n}\n\n \nstatic void sd_unlock_native_capacity(struct gendisk *disk)\n{\n\tstruct scsi_device *sdev = scsi_disk(disk)->device;\n\n\tif (sdev->host->hostt->unlock_native_capacity)\n\t\tsdev->host->hostt->unlock_native_capacity(sdev);\n}\n\n \nstatic int sd_format_disk_name(char *prefix, int index, char *buf, int buflen)\n{\n\tconst int base = 'z' - 'a' + 1;\n\tchar *begin = buf + strlen(prefix);\n\tchar *end = buf + buflen;\n\tchar *p;\n\tint unit;\n\n\tp = end - 1;\n\t*p = '\\0';\n\tunit = base;\n\tdo {\n\t\tif (p == begin)\n\t\t\treturn -EINVAL;\n\t\t*--p = 'a' + (index % unit);\n\t\tindex = (index / unit) - 1;\n\t} while (index >= 0);\n\n\tmemmove(begin, p, end - p);\n\tmemcpy(buf, prefix, strlen(prefix));\n\n\treturn 0;\n}\n\n \nstatic int sd_probe(struct device *dev)\n{\n\tstruct scsi_device *sdp = to_scsi_device(dev);\n\tstruct scsi_disk *sdkp;\n\tstruct gendisk *gd;\n\tint index;\n\tint error;\n\n\tscsi_autopm_get_device(sdp);\n\terror = -ENODEV;\n\tif (sdp->type != TYPE_DISK &&\n\t    sdp->type != TYPE_ZBC &&\n\t    sdp->type != TYPE_MOD &&\n\t    sdp->type != TYPE_RBC)\n\t\tgoto out;\n\n\tif (!IS_ENABLED(CONFIG_BLK_DEV_ZONED) && sdp->type == TYPE_ZBC) {\n\t\tsdev_printk(KERN_WARNING, sdp,\n\t\t\t    \"Unsupported ZBC host-managed device.\\n\");\n\t\tgoto out;\n\t}\n\n\tSCSI_LOG_HLQUEUE(3, sdev_printk(KERN_INFO, sdp,\n\t\t\t\t\t\"sd_probe\\n\"));\n\n\terror = -ENOMEM;\n\tsdkp = kzalloc(sizeof(*sdkp), GFP_KERNEL);\n\tif (!sdkp)\n\t\tgoto out;\n\n\tgd = blk_mq_alloc_disk_for_queue(sdp->request_queue,\n\t\t\t\t\t &sd_bio_compl_lkclass);\n\tif (!gd)\n\t\tgoto out_free;\n\n\tindex = ida_alloc(&sd_index_ida, GFP_KERNEL);\n\tif (index < 0) {\n\t\tsdev_printk(KERN_WARNING, sdp, \"sd_probe: memory exhausted.\\n\");\n\t\tgoto out_put;\n\t}\n\n\terror = sd_format_disk_name(\"sd\", index, gd->disk_name, DISK_NAME_LEN);\n\tif (error) {\n\t\tsdev_printk(KERN_WARNING, sdp, \"SCSI disk (sd) name length exceeded.\\n\");\n\t\tgoto out_free_index;\n\t}\n\n\tsdkp->device = sdp;\n\tsdkp->disk = gd;\n\tsdkp->index = index;\n\tsdkp->max_retries = SD_MAX_RETRIES;\n\tatomic_set(&sdkp->openers, 0);\n\tatomic_set(&sdkp->device->ioerr_cnt, 0);\n\n\tif (!sdp->request_queue->rq_timeout) {\n\t\tif (sdp->type != TYPE_MOD)\n\t\t\tblk_queue_rq_timeout(sdp->request_queue, SD_TIMEOUT);\n\t\telse\n\t\t\tblk_queue_rq_timeout(sdp->request_queue,\n\t\t\t\t\t     SD_MOD_TIMEOUT);\n\t}\n\n\tdevice_initialize(&sdkp->disk_dev);\n\tsdkp->disk_dev.parent = get_device(dev);\n\tsdkp->disk_dev.class = &sd_disk_class;\n\tdev_set_name(&sdkp->disk_dev, \"%s\", dev_name(dev));\n\n\terror = device_add(&sdkp->disk_dev);\n\tif (error) {\n\t\tput_device(&sdkp->disk_dev);\n\t\tgoto out;\n\t}\n\n\tdev_set_drvdata(dev, sdkp);\n\n\tgd->major = sd_major((index & 0xf0) >> 4);\n\tgd->first_minor = ((index & 0xf) << 4) | (index & 0xfff00);\n\tgd->minors = SD_MINORS;\n\n\tgd->fops = &sd_fops;\n\tgd->private_data = sdkp;\n\n\t \n\tsdp->sector_size = 512;\n\tsdkp->capacity = 0;\n\tsdkp->media_present = 1;\n\tsdkp->write_prot = 0;\n\tsdkp->cache_override = 0;\n\tsdkp->WCE = 0;\n\tsdkp->RCD = 0;\n\tsdkp->ATO = 0;\n\tsdkp->first_scan = 1;\n\tsdkp->max_medium_access_timeouts = SD_MAX_MEDIUM_TIMEOUTS;\n\n\tsd_revalidate_disk(gd);\n\n\tif (sdp->removable) {\n\t\tgd->flags |= GENHD_FL_REMOVABLE;\n\t\tgd->events |= DISK_EVENT_MEDIA_CHANGE;\n\t\tgd->event_flags = DISK_EVENT_FLAG_POLL | DISK_EVENT_FLAG_UEVENT;\n\t}\n\n\tblk_pm_runtime_init(sdp->request_queue, dev);\n\tif (sdp->rpm_autosuspend) {\n\t\tpm_runtime_set_autosuspend_delay(dev,\n\t\t\tsdp->host->hostt->rpm_autosuspend_delay);\n\t}\n\n\terror = device_add_disk(dev, gd, NULL);\n\tif (error) {\n\t\tput_device(&sdkp->disk_dev);\n\t\tput_disk(gd);\n\t\tgoto out;\n\t}\n\n\tif (sdkp->security) {\n\t\tsdkp->opal_dev = init_opal_dev(sdkp, &sd_sec_submit);\n\t\tif (sdkp->opal_dev)\n\t\t\tsd_printk(KERN_NOTICE, sdkp, \"supports TCG Opal\\n\");\n\t}\n\n\tsd_printk(KERN_NOTICE, sdkp, \"Attached SCSI %sdisk\\n\",\n\t\t  sdp->removable ? \"removable \" : \"\");\n\tscsi_autopm_put_device(sdp);\n\n\treturn 0;\n\n out_free_index:\n\tida_free(&sd_index_ida, index);\n out_put:\n\tput_disk(gd);\n out_free:\n\tkfree(sdkp);\n out:\n\tscsi_autopm_put_device(sdp);\n\treturn error;\n}\n\n \nstatic int sd_remove(struct device *dev)\n{\n\tstruct scsi_disk *sdkp = dev_get_drvdata(dev);\n\n\tscsi_autopm_get_device(sdkp->device);\n\n\tdevice_del(&sdkp->disk_dev);\n\tdel_gendisk(sdkp->disk);\n\tif (!sdkp->suspended)\n\t\tsd_shutdown(dev);\n\n\tput_disk(sdkp->disk);\n\treturn 0;\n}\n\nstatic void scsi_disk_release(struct device *dev)\n{\n\tstruct scsi_disk *sdkp = to_scsi_disk(dev);\n\n\tida_free(&sd_index_ida, sdkp->index);\n\tsd_zbc_free_zone_info(sdkp);\n\tput_device(&sdkp->device->sdev_gendev);\n\tfree_opal_dev(sdkp->opal_dev);\n\n\tkfree(sdkp);\n}\n\nstatic int sd_start_stop_device(struct scsi_disk *sdkp, int start)\n{\n\tunsigned char cmd[6] = { START_STOP };\t \n\tstruct scsi_sense_hdr sshdr;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t\t.req_flags = BLK_MQ_REQ_PM,\n\t};\n\tstruct scsi_device *sdp = sdkp->device;\n\tint res;\n\n\tif (start)\n\t\tcmd[4] |= 1;\t \n\n\tif (sdp->start_stop_pwr_cond)\n\t\tcmd[4] |= start ? 1 << 4 : 3 << 4;\t \n\n\tif (!scsi_device_online(sdp))\n\t\treturn -ENODEV;\n\n\tres = scsi_execute_cmd(sdp, cmd, REQ_OP_DRV_IN, NULL, 0, SD_TIMEOUT,\n\t\t\t       sdkp->max_retries, &exec_args);\n\tif (res) {\n\t\tsd_print_result(sdkp, \"Start/Stop Unit failed\", res);\n\t\tif (res > 0 && scsi_sense_valid(&sshdr)) {\n\t\t\tsd_print_sense_hdr(sdkp, &sshdr);\n\t\t\t \n\t\t\tif (sshdr.asc == 0x3a)\n\t\t\t\tres = 0;\n\t\t}\n\t}\n\n\t \n\tif (res)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic void sd_shutdown(struct device *dev)\n{\n\tstruct scsi_disk *sdkp = dev_get_drvdata(dev);\n\n\tif (!sdkp)\n\t\treturn;          \n\n\tif (pm_runtime_suspended(dev))\n\t\treturn;\n\n\tif (sdkp->WCE && sdkp->media_present) {\n\t\tsd_printk(KERN_NOTICE, sdkp, \"Synchronizing SCSI cache\\n\");\n\t\tsd_sync_cache(sdkp);\n\t}\n\n\tif ((system_state != SYSTEM_RESTART &&\n\t     sdkp->device->manage_system_start_stop) ||\n\t    (system_state == SYSTEM_POWER_OFF &&\n\t     sdkp->device->manage_shutdown)) {\n\t\tsd_printk(KERN_NOTICE, sdkp, \"Stopping disk\\n\");\n\t\tsd_start_stop_device(sdkp, 0);\n\t}\n}\n\nstatic inline bool sd_do_start_stop(struct scsi_device *sdev, bool runtime)\n{\n\treturn (sdev->manage_system_start_stop && !runtime) ||\n\t\t(sdev->manage_runtime_start_stop && runtime);\n}\n\nstatic int sd_suspend_common(struct device *dev, bool runtime)\n{\n\tstruct scsi_disk *sdkp = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (!sdkp)\t \n\t\treturn 0;\n\n\tif (sdkp->WCE && sdkp->media_present) {\n\t\tif (!sdkp->device->silence_suspend)\n\t\t\tsd_printk(KERN_NOTICE, sdkp, \"Synchronizing SCSI cache\\n\");\n\t\tret = sd_sync_cache(sdkp);\n\t\t \n\t\tif (ret == -ENODEV)\n\t\t\treturn 0;\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (sd_do_start_stop(sdkp->device, runtime)) {\n\t\tif (!sdkp->device->silence_suspend)\n\t\t\tsd_printk(KERN_NOTICE, sdkp, \"Stopping disk\\n\");\n\t\t \n\t\tret = sd_start_stop_device(sdkp, 0);\n\t\tif (!runtime)\n\t\t\tret = 0;\n\t}\n\n\tif (!ret)\n\t\tsdkp->suspended = true;\n\n\treturn ret;\n}\n\nstatic int sd_suspend_system(struct device *dev)\n{\n\tif (pm_runtime_suspended(dev))\n\t\treturn 0;\n\n\treturn sd_suspend_common(dev, false);\n}\n\nstatic int sd_suspend_runtime(struct device *dev)\n{\n\treturn sd_suspend_common(dev, true);\n}\n\nstatic int sd_resume(struct device *dev, bool runtime)\n{\n\tstruct scsi_disk *sdkp = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (!sdkp)\t \n\t\treturn 0;\n\n\tif (!sd_do_start_stop(sdkp->device, runtime)) {\n\t\tsdkp->suspended = false;\n\t\treturn 0;\n\t}\n\n\tif (!sdkp->device->no_start_on_resume) {\n\t\tsd_printk(KERN_NOTICE, sdkp, \"Starting disk\\n\");\n\t\tret = sd_start_stop_device(sdkp, 1);\n\t}\n\n\tif (!ret) {\n\t\topal_unlock_from_suspend(sdkp->opal_dev);\n\t\tsdkp->suspended = false;\n\t}\n\n\treturn ret;\n}\n\nstatic int sd_resume_system(struct device *dev)\n{\n\tif (pm_runtime_suspended(dev)) {\n\t\tstruct scsi_disk *sdkp = dev_get_drvdata(dev);\n\t\tstruct scsi_device *sdp = sdkp ? sdkp->device : NULL;\n\n\t\tif (sdp && sdp->force_runtime_start_on_system_start)\n\t\t\tpm_request_resume(dev);\n\n\t\treturn 0;\n\t}\n\n\treturn sd_resume(dev, false);\n}\n\nstatic int sd_resume_runtime(struct device *dev)\n{\n\tstruct scsi_disk *sdkp = dev_get_drvdata(dev);\n\tstruct scsi_device *sdp;\n\n\tif (!sdkp)\t \n\t\treturn 0;\n\n\tsdp = sdkp->device;\n\n\tif (sdp->ignore_media_change) {\n\t\t \n\t\tstatic const u8 cmd[10] = { REQUEST_SENSE };\n\t\tconst struct scsi_exec_args exec_args = {\n\t\t\t.req_flags = BLK_MQ_REQ_PM,\n\t\t};\n\n\t\tif (scsi_execute_cmd(sdp, cmd, REQ_OP_DRV_IN, NULL, 0,\n\t\t\t\t     sdp->request_queue->rq_timeout, 1,\n\t\t\t\t     &exec_args))\n\t\t\tsd_printk(KERN_NOTICE, sdkp,\n\t\t\t\t  \"Failed to clear sense data\\n\");\n\t}\n\n\treturn sd_resume(dev, true);\n}\n\nstatic const struct dev_pm_ops sd_pm_ops = {\n\t.suspend\t\t= sd_suspend_system,\n\t.resume\t\t\t= sd_resume_system,\n\t.poweroff\t\t= sd_suspend_system,\n\t.restore\t\t= sd_resume_system,\n\t.runtime_suspend\t= sd_suspend_runtime,\n\t.runtime_resume\t\t= sd_resume_runtime,\n};\n\nstatic struct scsi_driver sd_template = {\n\t.gendrv = {\n\t\t.name\t\t= \"sd\",\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.probe\t\t= sd_probe,\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.remove\t\t= sd_remove,\n\t\t.shutdown\t= sd_shutdown,\n\t\t.pm\t\t= &sd_pm_ops,\n\t},\n\t.rescan\t\t\t= sd_rescan,\n\t.init_command\t\t= sd_init_command,\n\t.uninit_command\t\t= sd_uninit_command,\n\t.done\t\t\t= sd_done,\n\t.eh_action\t\t= sd_eh_action,\n\t.eh_reset\t\t= sd_eh_reset,\n};\n\n \nstatic int __init init_sd(void)\n{\n\tint majors = 0, i, err;\n\n\tSCSI_LOG_HLQUEUE(3, printk(\"init_sd: sd driver entry point\\n\"));\n\n\tfor (i = 0; i < SD_MAJORS; i++) {\n\t\tif (__register_blkdev(sd_major(i), \"sd\", sd_default_probe))\n\t\t\tcontinue;\n\t\tmajors++;\n\t}\n\n\tif (!majors)\n\t\treturn -ENODEV;\n\n\terr = class_register(&sd_disk_class);\n\tif (err)\n\t\tgoto err_out;\n\n\tsd_page_pool = mempool_create_page_pool(SD_MEMPOOL_SIZE, 0);\n\tif (!sd_page_pool) {\n\t\tprintk(KERN_ERR \"sd: can't init discard page pool\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out_class;\n\t}\n\n\terr = scsi_register_driver(&sd_template.gendrv);\n\tif (err)\n\t\tgoto err_out_driver;\n\n\treturn 0;\n\nerr_out_driver:\n\tmempool_destroy(sd_page_pool);\nerr_out_class:\n\tclass_unregister(&sd_disk_class);\nerr_out:\n\tfor (i = 0; i < SD_MAJORS; i++)\n\t\tunregister_blkdev(sd_major(i), \"sd\");\n\treturn err;\n}\n\n \nstatic void __exit exit_sd(void)\n{\n\tint i;\n\n\tSCSI_LOG_HLQUEUE(3, printk(\"exit_sd: exiting sd driver\\n\"));\n\n\tscsi_unregister_driver(&sd_template.gendrv);\n\tmempool_destroy(sd_page_pool);\n\n\tclass_unregister(&sd_disk_class);\n\n\tfor (i = 0; i < SD_MAJORS; i++)\n\t\tunregister_blkdev(sd_major(i), \"sd\");\n}\n\nmodule_init(init_sd);\nmodule_exit(exit_sd);\n\nvoid sd_print_sense_hdr(struct scsi_disk *sdkp, struct scsi_sense_hdr *sshdr)\n{\n\tscsi_print_sense_hdr(sdkp->device,\n\t\t\t     sdkp->disk ? sdkp->disk->disk_name : NULL, sshdr);\n}\n\nvoid sd_print_result(const struct scsi_disk *sdkp, const char *msg, int result)\n{\n\tconst char *hb_string = scsi_hostbyte_string(result);\n\n\tif (hb_string)\n\t\tsd_printk(KERN_INFO, sdkp,\n\t\t\t  \"%s: Result: hostbyte=%s driverbyte=%s\\n\", msg,\n\t\t\t  hb_string ? hb_string : \"invalid\",\n\t\t\t  \"DRIVER_OK\");\n\telse\n\t\tsd_printk(KERN_INFO, sdkp,\n\t\t\t  \"%s: Result: hostbyte=0x%02x driverbyte=%s\\n\",\n\t\t\t  msg, host_byte(result), \"DRIVER_OK\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}