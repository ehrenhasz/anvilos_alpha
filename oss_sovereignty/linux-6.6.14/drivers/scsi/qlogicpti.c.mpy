{
  "module_name": "qlogicpti.c",
  "hash_id": "40a6d1aa9e2c29e5d44ff667104e390f67399cad59d099c079613715ef00d90e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qlogicpti.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/gfp.h>\n#include <linux/blkdev.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/firmware.h>\n#include <linux/pgtable.h>\n\n#include <asm/byteorder.h>\n\n#include \"qlogicpti.h\"\n\n#include <asm/dma.h>\n#include <asm/ptrace.h>\n#include <asm/oplib.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_host.h>\n\n#define MAX_TARGETS\t16\n#define MAX_LUNS\t8\t \n\n#define DEFAULT_LOOP_COUNT\t10000\n\nstatic struct qlogicpti *qptichain = NULL;\nstatic DEFINE_SPINLOCK(qptichain_lock);\n\n#define PACKB(a, b)\t\t\t(((a)<<4)|(b))\n\nstatic const u_char mbox_param[] = {\n\tPACKB(1, 1),\t \n\tPACKB(5, 5),\t \n\tPACKB(2, 0),\t \n\tPACKB(5, 5),\t \n\tPACKB(3, 3),\t \n\tPACKB(2, 3),\t \n\tPACKB(6, 6),\t \n\tPACKB(2, 3),\t \n\tPACKB(1, 3),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(1, 2),\t \n\tPACKB(0, 0),\t \n\tPACKB(5, 5),\t \n\tPACKB(6, 6),\t \n\tPACKB(4, 4),\t \n\tPACKB(2, 2),\t \n\tPACKB(1, 6),\t \n\tPACKB(4, 4),\t \n\tPACKB(2, 2),\t \n\tPACKB(3, 3),\t \n\tPACKB(2, 2),\t \n\tPACKB(2, 3),\t \n\tPACKB(2, 3),\t \n\tPACKB(2, 3),\t \n\tPACKB(2, 3),\t \n\tPACKB(2, 4),\t \n\tPACKB(0, 0),\t \n\tPACKB(1, 3),\t \n\tPACKB(1, 2),\t \n\tPACKB(1, 2),\t \n\tPACKB(1, 3),\t \n\tPACKB(1, 2),\t \n\tPACKB(1, 2),\t \n\tPACKB(1, 2),\t \n\tPACKB(1, 2),\t \n\tPACKB(1, 3),\t \n\tPACKB(2, 4),\t \n\tPACKB(2, 4),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(2, 2),\t \n\tPACKB(2, 2),\t \n\tPACKB(3, 3),\t \n\tPACKB(2, 2),\t \n\tPACKB(2, 2),\t \n\tPACKB(2, 2),\t \n\tPACKB(2, 2),\t \n\tPACKB(3, 3),\t \n\tPACKB(4, 4),\t \n\tPACKB(4, 4),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0),\t \n\tPACKB(0, 0)\t \n};\n\n#define MAX_MBOX_COMMAND\tARRAY_SIZE(mbox_param)\n\n \n#define QUEUE_DEPTH(in, out, ql)\t((in - out) & (ql))\n#define REQ_QUEUE_DEPTH(in, out)\tQUEUE_DEPTH(in, out, \t\t     \\\n\t\t\t\t\t\t    QLOGICPTI_REQ_QUEUE_LEN)\n#define RES_QUEUE_DEPTH(in, out)\tQUEUE_DEPTH(in, out, RES_QUEUE_LEN)\n\nstatic inline void qlogicpti_enable_irqs(struct qlogicpti *qpti)\n{\n\tsbus_writew(SBUS_CTRL_ERIRQ | SBUS_CTRL_GENAB,\n\t\t    qpti->qregs + SBUS_CTRL);\n}\n\nstatic inline void qlogicpti_disable_irqs(struct qlogicpti *qpti)\n{\n\tsbus_writew(0, qpti->qregs + SBUS_CTRL);\n}\n\nstatic inline void set_sbus_cfg1(struct qlogicpti *qpti)\n{\n\tu16 val;\n\tu8 bursts = qpti->bursts;\n\n#if 0\t \n\tif (sbus_can_burst64() && (bursts & DMA_BURST64)) {\n\t\tval = (SBUS_CFG1_BENAB | SBUS_CFG1_B64);\n\t} else\n#endif\n\tif (bursts & DMA_BURST32) {\n\t\tval = (SBUS_CFG1_BENAB | SBUS_CFG1_B32);\n\t} else if (bursts & DMA_BURST16) {\n\t\tval = (SBUS_CFG1_BENAB | SBUS_CFG1_B16);\n\t} else if (bursts & DMA_BURST8) {\n\t\tval = (SBUS_CFG1_BENAB | SBUS_CFG1_B8);\n\t} else {\n\t\tval = 0;  \n\t}\n\tsbus_writew(val, qpti->qregs + SBUS_CFG1);\n}\n\nstatic int qlogicpti_mbox_command(struct qlogicpti *qpti, u_short param[], int force)\n{\n\tint loop_count;\n\tu16 tmp;\n\n\tif (mbox_param[param[0]] == 0)\n\t\treturn 1;\n\n\t \n\ttmp = sbus_readw(qpti->qregs + SBUS_SEMAPHORE);\n\ttmp |= SBUS_SEMAPHORE_LCK;\n\tsbus_writew(tmp, qpti->qregs + SBUS_SEMAPHORE);\n\n\t \n\tloop_count = DEFAULT_LOOP_COUNT;\n\twhile (--loop_count && (sbus_readw(qpti->qregs + HCCTRL) & HCCTRL_HIRQ)) {\n\t\tbarrier();\n\t\tcpu_relax();\n\t}\n\tif (!loop_count)\n\t\tprintk(KERN_EMERG \"qlogicpti%d: mbox_command loop timeout #1\\n\",\n\t\t       qpti->qpti_id);\n\n\t \n\tswitch (mbox_param[param[0]] >> 4) {\n\tcase 6: sbus_writew(param[5], qpti->qregs + MBOX5);\n\t\tfallthrough;\n\tcase 5: sbus_writew(param[4], qpti->qregs + MBOX4);\n\t\tfallthrough;\n\tcase 4: sbus_writew(param[3], qpti->qregs + MBOX3);\n\t\tfallthrough;\n\tcase 3: sbus_writew(param[2], qpti->qregs + MBOX2);\n\t\tfallthrough;\n\tcase 2: sbus_writew(param[1], qpti->qregs + MBOX1);\n\t\tfallthrough;\n\tcase 1: sbus_writew(param[0], qpti->qregs + MBOX0);\n\t}\n\n\t \n\ttmp = sbus_readw(qpti->qregs + HCCTRL);\n\ttmp |= HCCTRL_CRIRQ;\n\tsbus_writew(tmp, qpti->qregs + HCCTRL);\n\n\t \n\tsbus_writew(0, qpti->qregs + SBUS_SEMAPHORE);\n\n\t \n\ttmp = sbus_readw(qpti->qregs + HCCTRL);\n\ttmp |= HCCTRL_SHIRQ;\n\tsbus_writew(tmp, qpti->qregs + HCCTRL);\n\n\t \n\tloop_count = DEFAULT_LOOP_COUNT;\n\twhile (--loop_count &&\n\t       (sbus_readw(qpti->qregs + HCCTRL) & HCCTRL_CRIRQ))\n\t\tudelay(20);\n\tif (!loop_count)\n\t\tprintk(KERN_EMERG \"qlogicpti%d: mbox_command[%04x] loop timeout #2\\n\",\n\t\t       qpti->qpti_id, param[0]);\n\n\t \n\tloop_count = DEFAULT_LOOP_COUNT;\n\twhile (--loop_count &&\n\t       !(sbus_readw(qpti->qregs + SBUS_SEMAPHORE) & SBUS_SEMAPHORE_LCK)) {\n\t\tudelay(20);\n\n\t\t \n\t\tif (sbus_readw(qpti->qregs + MBOX0) & 0x4000)\n\t\t\tbreak;\n\t}\n\tif (!loop_count)\n\t\tprintk(KERN_EMERG \"qlogicpti%d: mbox_command[%04x] loop timeout #3\\n\",\n\t\t       qpti->qpti_id, param[0]);\n\n\t \n\tloop_count = DEFAULT_LOOP_COUNT;\n\twhile (--loop_count && (sbus_readw(qpti->qregs + MBOX0) == 0x04))\n\t\tudelay(20);\n\tif (!loop_count)\n\t\tprintk(KERN_EMERG \"qlogicpti%d: mbox_command[%04x] loop timeout #4\\n\",\n\t\t       qpti->qpti_id, param[0]);\n\n\t \n\tswitch (mbox_param[param[0]] & 0xf) {\n\tcase 6: param[5] = sbus_readw(qpti->qregs + MBOX5);\n\t\tfallthrough;\n\tcase 5: param[4] = sbus_readw(qpti->qregs + MBOX4);\n\t\tfallthrough;\n\tcase 4: param[3] = sbus_readw(qpti->qregs + MBOX3);\n\t\tfallthrough;\n\tcase 3: param[2] = sbus_readw(qpti->qregs + MBOX2);\n\t\tfallthrough;\n\tcase 2: param[1] = sbus_readw(qpti->qregs + MBOX1);\n\t\tfallthrough;\n\tcase 1: param[0] = sbus_readw(qpti->qregs + MBOX0);\n\t}\n\n\t \n\ttmp = sbus_readw(qpti->qregs + HCCTRL);\n\ttmp |= HCCTRL_CRIRQ;\n\tsbus_writew(tmp, qpti->qregs + HCCTRL);\n\n\t \n\ttmp = sbus_readw(qpti->qregs + SBUS_SEMAPHORE);\n\ttmp &= ~(SBUS_SEMAPHORE_LCK);\n\tsbus_writew(tmp, qpti->qregs + SBUS_SEMAPHORE);\n\n\t \n\treturn 0;\n}\n\nstatic inline void qlogicpti_set_hostdev_defaults(struct qlogicpti *qpti)\n{\n\tint i;\n\n\tqpti->host_param.initiator_scsi_id = qpti->scsi_id;\n\tqpti->host_param.bus_reset_delay = 3;\n\tqpti->host_param.retry_count = 0;\n\tqpti->host_param.retry_delay = 5;\n\tqpti->host_param.async_data_setup_time = 3;\n\tqpti->host_param.req_ack_active_negation = 1;\n\tqpti->host_param.data_line_active_negation = 1;\n\tqpti->host_param.data_dma_burst_enable = 1;\n\tqpti->host_param.command_dma_burst_enable = 1;\n\tqpti->host_param.tag_aging = 8;\n\tqpti->host_param.selection_timeout = 250;\n\tqpti->host_param.max_queue_depth = 256;\n\n\tfor(i = 0; i < MAX_TARGETS; i++) {\n\t\t \n\t\tqpti->dev_param[i].device_flags = 0xcd;\n\t\tqpti->dev_param[i].execution_throttle = 16;\n\t\tif (qpti->ultra) {\n\t\t\tqpti->dev_param[i].synchronous_period = 12;\n\t\t\tqpti->dev_param[i].synchronous_offset = 8;\n\t\t} else {\n\t\t\tqpti->dev_param[i].synchronous_period = 25;\n\t\t\tqpti->dev_param[i].synchronous_offset = 12;\n\t\t}\n\t\tqpti->dev_param[i].device_enable = 1;\n\t}\n}\n\nstatic int qlogicpti_reset_hardware(struct Scsi_Host *host)\n{\n\tstruct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;\n\tu_short param[6];\n\tunsigned short risc_code_addr;\n\tint loop_count, i;\n\tunsigned long flags;\n\n\trisc_code_addr = 0x1000;\t \n\n\tspin_lock_irqsave(host->host_lock, flags);\n\n\tsbus_writew(HCCTRL_PAUSE, qpti->qregs + HCCTRL);\n\n\t \n\tif (sbus_readw(qpti->qregs + CPU_PCTRL) & CPU_PCTRL_BSY) {\n\t\tsbus_writew(CPU_ORIDE_RMOD, qpti->qregs + CPU_ORIDE);\n\t\tsbus_writew(CPU_CMD_BRESET, qpti->qregs + CPU_CMD);\n\t\tudelay(400);\n\t}\n\n\tsbus_writew(SBUS_CTRL_RESET, qpti->qregs + SBUS_CTRL);\n\tsbus_writew((DMA_CTRL_CCLEAR | DMA_CTRL_CIRQ), qpti->qregs + CMD_DMA_CTRL);\n\tsbus_writew((DMA_CTRL_CCLEAR | DMA_CTRL_CIRQ), qpti->qregs + DATA_DMA_CTRL);\n\n\tloop_count = DEFAULT_LOOP_COUNT;\n\twhile (--loop_count && ((sbus_readw(qpti->qregs + MBOX0) & 0xff) == 0x04))\n\t\tudelay(20);\n\tif (!loop_count)\n\t\tprintk(KERN_EMERG \"qlogicpti%d: reset_hardware loop timeout\\n\",\n\t\t       qpti->qpti_id);\n\n\tsbus_writew(HCCTRL_PAUSE, qpti->qregs + HCCTRL);\n\tset_sbus_cfg1(qpti);\n\tqlogicpti_enable_irqs(qpti);\n\n\tif (sbus_readw(qpti->qregs + RISC_PSR) & RISC_PSR_ULTRA) {\n\t\tqpti->ultra = 1;\n\t\tsbus_writew((RISC_MTREG_P0ULTRA | RISC_MTREG_P1ULTRA),\n\t\t\t    qpti->qregs + RISC_MTREG);\n\t} else {\n\t\tqpti->ultra = 0;\n\t\tsbus_writew((RISC_MTREG_P0DFLT | RISC_MTREG_P1DFLT),\n\t\t\t    qpti->qregs + RISC_MTREG);\n\t}\n\n\t \n\t \n\tqlogicpti_set_hostdev_defaults(qpti);\n\n\t \n\tsbus_writew(HCCTRL_REL, qpti->qregs + HCCTRL);\n\n\t \n\tparam[0] = MBOX_EXEC_FIRMWARE;\n\tparam[1] = risc_code_addr;\n\tif (qlogicpti_mbox_command(qpti, param, 1)) {\n\t\tprintk(KERN_EMERG \"qlogicpti%d: Cannot execute ISP firmware.\\n\",\n\t\t       qpti->qpti_id);\n\t\tspin_unlock_irqrestore(host->host_lock, flags);\n\t\treturn 1;\n\t}\n\n\t \n\tparam[0] = MBOX_SET_INIT_SCSI_ID;\n\tparam[1] = qpti->host_param.initiator_scsi_id;\n\tif (qlogicpti_mbox_command(qpti, param, 1) ||\n\t   (param[0] != MBOX_COMMAND_COMPLETE)) {\n\t\tprintk(KERN_EMERG \"qlogicpti%d: Cannot set initiator SCSI ID.\\n\",\n\t\t       qpti->qpti_id);\n\t\tspin_unlock_irqrestore(host->host_lock, flags);\n\t\treturn 1;\n\t}\n\n\t \n\tqpti->req_in_ptr = qpti->res_out_ptr = 0;\n\n\tparam[0] = MBOX_INIT_RES_QUEUE;\n\tparam[1] = RES_QUEUE_LEN + 1;\n\tparam[2] = (u_short) (qpti->res_dvma >> 16);\n\tparam[3] = (u_short) (qpti->res_dvma & 0xffff);\n\tparam[4] = param[5] = 0;\n\tif (qlogicpti_mbox_command(qpti, param, 1)) {\n\t\tprintk(KERN_EMERG \"qlogicpti%d: Cannot init response queue.\\n\",\n\t\t       qpti->qpti_id);\n\t\tspin_unlock_irqrestore(host->host_lock, flags);\n\t\treturn 1;\n\t}\n\n\tparam[0] = MBOX_INIT_REQ_QUEUE;\n\tparam[1] = QLOGICPTI_REQ_QUEUE_LEN + 1;\n\tparam[2] = (u_short) (qpti->req_dvma >> 16);\n\tparam[3] = (u_short) (qpti->req_dvma & 0xffff);\n\tparam[4] = param[5] = 0;\n\tif (qlogicpti_mbox_command(qpti, param, 1)) {\n\t\tprintk(KERN_EMERG \"qlogicpti%d: Cannot init request queue.\\n\",\n\t\t       qpti->qpti_id);\n\t\tspin_unlock_irqrestore(host->host_lock, flags);\n\t\treturn 1;\n\t}\n\n\tparam[0] = MBOX_SET_RETRY_COUNT;\n\tparam[1] = qpti->host_param.retry_count;\n\tparam[2] = qpti->host_param.retry_delay;\n\tqlogicpti_mbox_command(qpti, param, 0);\n\n\tparam[0] = MBOX_SET_TAG_AGE_LIMIT;\n\tparam[1] = qpti->host_param.tag_aging;\n\tqlogicpti_mbox_command(qpti, param, 0);\n\n\tfor (i = 0; i < MAX_TARGETS; i++) {\n\t\tparam[0] = MBOX_GET_DEV_QUEUE_PARAMS;\n\t\tparam[1] = (i << 8);\n\t\tqlogicpti_mbox_command(qpti, param, 0);\n\t}\n\n\tparam[0] = MBOX_GET_FIRMWARE_STATUS;\n\tqlogicpti_mbox_command(qpti, param, 0);\n\n\tparam[0] = MBOX_SET_SELECT_TIMEOUT;\n\tparam[1] = qpti->host_param.selection_timeout;\n\tqlogicpti_mbox_command(qpti, param, 0);\n\n\tfor (i = 0; i < MAX_TARGETS; i++) {\n\t\tparam[0] = MBOX_SET_TARGET_PARAMS;\n\t\tparam[1] = (i << 8);\n\t\tparam[2] = (qpti->dev_param[i].device_flags << 8);\n\t\t \n\t\tparam[2] |= 0xc0;\n\t\tparam[3] = 0;\t \n\t\tqlogicpti_mbox_command(qpti, param, 0);\n\t}\n\n\t \n\tparam[0] = MBOX_BUS_RESET;\n\tparam[1] = qpti->host_param.bus_reset_delay;\n\tqlogicpti_mbox_command(qpti, param, 0);\n\tqpti->send_marker = 1;\n\n\tspin_unlock_irqrestore(host->host_lock, flags);\n\treturn 0;\n}\n\n#define PTI_RESET_LIMIT 400\n\nstatic int qlogicpti_load_firmware(struct qlogicpti *qpti)\n{\n\tconst struct firmware *fw;\n\tconst char fwname[] = \"qlogic/isp1000.bin\";\n\tconst __le16 *fw_data;\n\tstruct Scsi_Host *host = qpti->qhost;\n\tunsigned short csum = 0;\n\tunsigned short param[6];\n\tunsigned short risc_code_addr, risc_code_length;\n\tint err;\n\tunsigned long flags;\n\tint i, timeout;\n\n\terr = request_firmware(&fw, fwname, &qpti->op->dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"Failed to load image \\\"%s\\\" err %d\\n\",\n\t\t       fwname, err);\n\t\treturn err;\n\t}\n\tif (fw->size % 2) {\n\t\tprintk(KERN_ERR \"Bogus length %zu in image \\\"%s\\\"\\n\",\n\t\t       fw->size, fwname);\n\t\terr = -EINVAL;\n\t\tgoto outfirm;\n\t}\n\tfw_data = (const __le16 *)&fw->data[0];\n\trisc_code_addr = 0x1000;\t \n\trisc_code_length = fw->size / 2;\n\n\tspin_lock_irqsave(host->host_lock, flags);\n\n\t \n\tfor (i = 0; i < risc_code_length; i++)\n\t\tcsum += __le16_to_cpu(fw_data[i]);\n\tif (csum) {\n\t\tprintk(KERN_EMERG \"qlogicpti%d: Aieee, firmware checksum failed!\",\n\t\t       qpti->qpti_id);\n\t\terr = 1;\n\t\tgoto out;\n\t}\n\tsbus_writew(SBUS_CTRL_RESET, qpti->qregs + SBUS_CTRL);\n\tsbus_writew((DMA_CTRL_CCLEAR | DMA_CTRL_CIRQ), qpti->qregs + CMD_DMA_CTRL);\n\tsbus_writew((DMA_CTRL_CCLEAR | DMA_CTRL_CIRQ), qpti->qregs + DATA_DMA_CTRL);\n\ttimeout = PTI_RESET_LIMIT;\n\twhile (--timeout && (sbus_readw(qpti->qregs + SBUS_CTRL) & SBUS_CTRL_RESET))\n\t\tudelay(20);\n\tif (!timeout) {\n\t\tprintk(KERN_EMERG \"qlogicpti%d: Cannot reset the ISP.\", qpti->qpti_id);\n\t\terr = 1;\n\t\tgoto out;\n\t}\n\n\tsbus_writew(HCCTRL_RESET, qpti->qregs + HCCTRL);\n\tmdelay(1);\n\n\tsbus_writew((SBUS_CTRL_GENAB | SBUS_CTRL_ERIRQ), qpti->qregs + SBUS_CTRL);\n\tset_sbus_cfg1(qpti);\n\tsbus_writew(0, qpti->qregs + SBUS_SEMAPHORE);\n\n\tif (sbus_readw(qpti->qregs + RISC_PSR) & RISC_PSR_ULTRA) {\n\t\tqpti->ultra = 1;\n\t\tsbus_writew((RISC_MTREG_P0ULTRA | RISC_MTREG_P1ULTRA),\n\t\t\t    qpti->qregs + RISC_MTREG);\n\t} else {\n\t\tqpti->ultra = 0;\n\t\tsbus_writew((RISC_MTREG_P0DFLT | RISC_MTREG_P1DFLT),\n\t\t\t    qpti->qregs + RISC_MTREG);\n\t}\n\n\tsbus_writew(HCCTRL_REL, qpti->qregs + HCCTRL);\n\n\t \n\tsbus_writew(HCCTRL_PAUSE, qpti->qregs + HCCTRL);\n\tif (sbus_readw(qpti->qregs + CPU_PDIFF) & CPU_PDIFF_MODE)\n\t\tqpti->differential = 1;\n\telse\n\t\tqpti->differential = 0;\n\tsbus_writew(HCCTRL_REL, qpti->qregs + HCCTRL);\n\n\t \n\n\tparam[0] = MBOX_STOP_FIRMWARE;\n\tparam[1] = param[2] = param[3] = param[4] = param[5] = 0;\n\tif (qlogicpti_mbox_command(qpti, param, 1)) {\n\t\tprintk(KERN_EMERG \"qlogicpti%d: Cannot stop firmware for reload.\\n\",\n\t\t       qpti->qpti_id);\n\t\terr = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < risc_code_length; i++) {\n\t\tparam[0] = MBOX_WRITE_RAM_WORD;\n\t\tparam[1] = risc_code_addr + i;\n\t\tparam[2] = __le16_to_cpu(fw_data[i]);\n\t\tif (qlogicpti_mbox_command(qpti, param, 1) ||\n\t\t    param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tprintk(\"qlogicpti%d: Firmware dload failed, I'm bolixed!\\n\",\n\t\t\t       qpti->qpti_id);\n\t\t\terr = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tsbus_writew(HCCTRL_RESET, qpti->qregs + HCCTRL);\n\tmdelay(1);\n\n\tqlogicpti_enable_irqs(qpti);\n\tsbus_writew(0, qpti->qregs + SBUS_SEMAPHORE);\n\tsbus_writew(HCCTRL_REL, qpti->qregs + HCCTRL);\n\n\t \n\tparam[0] = MBOX_VERIFY_CHECKSUM;\n\tparam[1] = risc_code_addr;\n\tif (qlogicpti_mbox_command(qpti, param, 1) ||\n\t    (param[0] != MBOX_COMMAND_COMPLETE)) {\n\t\tprintk(KERN_EMERG \"qlogicpti%d: New firmware csum failure!\\n\",\n\t\t       qpti->qpti_id);\n\t\terr = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tparam[0] = MBOX_EXEC_FIRMWARE;\n\tparam[1] = risc_code_addr;\n\tqlogicpti_mbox_command(qpti, param, 1);\n\n\tparam[0] = MBOX_ABOUT_FIRMWARE;\n\tif (qlogicpti_mbox_command(qpti, param, 1) ||\n\t    (param[0] != MBOX_COMMAND_COMPLETE)) {\n\t\tprintk(KERN_EMERG \"qlogicpti%d: AboutFirmware cmd fails.\\n\",\n\t\t       qpti->qpti_id);\n\t\terr = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tqpti->fware_majrev = param[1];\n\tqpti->fware_minrev = param[2];\n\tqpti->fware_micrev = param[3];\n\n\t \n\tparam[0] = MBOX_SET_CLOCK_RATE;\n\tparam[1] = qpti->clock;\n\tif (qlogicpti_mbox_command(qpti, param, 1) ||\n\t    (param[0] != MBOX_COMMAND_COMPLETE)) {\n\t\tprintk(KERN_EMERG \"qlogicpti%d: could not set clock rate.\\n\",\n\t\t       qpti->qpti_id);\n\t\terr = 1;\n\t\tgoto out;\n\t}\n\n\tif (qpti->is_pti != 0) {\n\t\t \n\t\tparam[0] = MBOX_WRITE_RAM_WORD;\n\t\tparam[1] = 0xff80;\n\t\tparam[2] = (unsigned short) qpti->scsi_id;\n\t\tqlogicpti_mbox_command(qpti, param, 1);\n\n\t\tparam[0] = MBOX_WRITE_RAM_WORD;\n\t\tparam[1] = 0xff00;\n\t\tparam[2] = (unsigned short) 3;\n\t\tqlogicpti_mbox_command(qpti, param, 1);\n\t}\n\nout:\n\tspin_unlock_irqrestore(host->host_lock, flags);\noutfirm:\n\trelease_firmware(fw);\n\treturn err;\n}\n\nstatic int qlogicpti_verify_tmon(struct qlogicpti *qpti)\n{\n\tint curstat = sbus_readb(qpti->sreg);\n\n\tcurstat &= 0xf0;\n\tif (!(curstat & SREG_FUSE) && (qpti->swsreg & SREG_FUSE))\n\t\tprintk(\"qlogicpti%d: Fuse returned to normal state.\\n\", qpti->qpti_id);\n\tif (!(curstat & SREG_TPOWER) && (qpti->swsreg & SREG_TPOWER))\n\t\tprintk(\"qlogicpti%d: termpwr back to normal state.\\n\", qpti->qpti_id);\n\tif (curstat != qpti->swsreg) {\n\t\tint error = 0;\n\t\tif (curstat & SREG_FUSE) {\n\t\t\terror++;\n\t\t\tprintk(\"qlogicpti%d: Fuse is open!\\n\", qpti->qpti_id);\n\t\t}\n\t\tif (curstat & SREG_TPOWER) {\n\t\t\terror++;\n\t\t\tprintk(\"qlogicpti%d: termpwr failure\\n\", qpti->qpti_id);\n\t\t}\n\t\tif (qpti->differential &&\n\t\t    (curstat & SREG_DSENSE) != SREG_DSENSE) {\n\t\t\terror++;\n\t\t\tprintk(\"qlogicpti%d: You have a single ended device on a \"\n\t\t\t       \"differential bus!  Please fix!\\n\", qpti->qpti_id);\n\t\t}\n\t\tqpti->swsreg = curstat;\n\t\treturn error;\n\t}\n\treturn 0;\n}\n\nstatic irqreturn_t qpti_intr(int irq, void *dev_id);\n\nstatic void qpti_chain_add(struct qlogicpti *qpti)\n{\n\tspin_lock_irq(&qptichain_lock);\n\tif (qptichain != NULL) {\n\t\tstruct qlogicpti *qlink = qptichain;\n\n\t\twhile(qlink->next)\n\t\t\tqlink = qlink->next;\n\t\tqlink->next = qpti;\n\t} else {\n\t\tqptichain = qpti;\n\t}\n\tqpti->next = NULL;\n\tspin_unlock_irq(&qptichain_lock);\n}\n\nstatic void qpti_chain_del(struct qlogicpti *qpti)\n{\n\tspin_lock_irq(&qptichain_lock);\n\tif (qptichain == qpti) {\n\t\tqptichain = qpti->next;\n\t} else {\n\t\tstruct qlogicpti *qlink = qptichain;\n\t\twhile(qlink->next != qpti)\n\t\t\tqlink = qlink->next;\n\t\tqlink->next = qpti->next;\n\t}\n\tqpti->next = NULL;\n\tspin_unlock_irq(&qptichain_lock);\n}\n\nstatic int qpti_map_regs(struct qlogicpti *qpti)\n{\n\tstruct platform_device *op = qpti->op;\n\n\tqpti->qregs = of_ioremap(&op->resource[0], 0,\n\t\t\t\t resource_size(&op->resource[0]),\n\t\t\t\t \"PTI Qlogic/ISP\");\n\tif (!qpti->qregs) {\n\t\tprintk(\"PTI: Qlogic/ISP registers are unmappable\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (qpti->is_pti) {\n\t\tqpti->sreg = of_ioremap(&op->resource[0], (16 * 4096),\n\t\t\t\t\tsizeof(unsigned char),\n\t\t\t\t\t\"PTI Qlogic/ISP statreg\");\n\t\tif (!qpti->sreg) {\n\t\t\tprintk(\"PTI: Qlogic/ISP status register is unmappable\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int qpti_register_irq(struct qlogicpti *qpti)\n{\n\tstruct platform_device *op = qpti->op;\n\n\tqpti->qhost->irq = qpti->irq = op->archdata.irqs[0];\n\n\t \n\tif (request_irq(qpti->irq, qpti_intr,\n\t\t\tIRQF_SHARED, \"QlogicPTI\", qpti))\n\t\tgoto fail;\n\n\tprintk(\"qlogicpti%d: IRQ %d \", qpti->qpti_id, qpti->irq);\n\n\treturn 0;\n\nfail:\n\tprintk(\"qlogicpti%d: Cannot acquire irq line\\n\", qpti->qpti_id);\n\treturn -1;\n}\n\nstatic void qpti_get_scsi_id(struct qlogicpti *qpti)\n{\n\tstruct platform_device *op = qpti->op;\n\tstruct device_node *dp;\n\n\tdp = op->dev.of_node;\n\n\tqpti->scsi_id = of_getintprop_default(dp, \"initiator-id\", -1);\n\tif (qpti->scsi_id == -1)\n\t\tqpti->scsi_id = of_getintprop_default(dp, \"scsi-initiator-id\",\n\t\t\t\t\t\t      -1);\n\tif (qpti->scsi_id == -1)\n\t\tqpti->scsi_id =\n\t\t\tof_getintprop_default(dp->parent,\n\t\t\t\t\t      \"scsi-initiator-id\", 7);\n\tqpti->qhost->this_id = qpti->scsi_id;\n\tqpti->qhost->max_sectors = 64;\n\n\tprintk(\"SCSI ID %d \", qpti->scsi_id);\n}\n\nstatic void qpti_get_bursts(struct qlogicpti *qpti)\n{\n\tstruct platform_device *op = qpti->op;\n\tu8 bursts, bmask;\n\n\tbursts = of_getintprop_default(op->dev.of_node, \"burst-sizes\", 0xff);\n\tbmask = of_getintprop_default(op->dev.of_node->parent, \"burst-sizes\", 0xff);\n\tif (bmask != 0xff)\n\t\tbursts &= bmask;\n\tif (bursts == 0xff ||\n\t    (bursts & DMA_BURST16) == 0 ||\n\t    (bursts & DMA_BURST32) == 0)\n\t\tbursts = (DMA_BURST32 - 1);\n\n\tqpti->bursts = bursts;\n}\n\nstatic void qpti_get_clock(struct qlogicpti *qpti)\n{\n\tunsigned int cfreq;\n\n\t \n\tcfreq = prom_getintdefault(qpti->prom_node,\"clock-frequency\",40000000);\n\tqpti->clock = (cfreq + 500000)/1000000;\n\tif (qpti->clock == 0)  \n\t\tqpti->clock = 40;\n}\n\n \nstatic int qpti_map_queues(struct qlogicpti *qpti)\n{\n\tstruct platform_device *op = qpti->op;\n\n#define QSIZE(entries)\t(((entries) + 1) * QUEUE_ENTRY_LEN)\n\tqpti->res_cpu = dma_alloc_coherent(&op->dev,\n\t\t\t\t\t   QSIZE(RES_QUEUE_LEN),\n\t\t\t\t\t   &qpti->res_dvma, GFP_ATOMIC);\n\tif (qpti->res_cpu == NULL ||\n\t    qpti->res_dvma == 0) {\n\t\tprintk(\"QPTI: Cannot map response queue.\\n\");\n\t\treturn -1;\n\t}\n\n\tqpti->req_cpu = dma_alloc_coherent(&op->dev,\n\t\t\t\t\t   QSIZE(QLOGICPTI_REQ_QUEUE_LEN),\n\t\t\t\t\t   &qpti->req_dvma, GFP_ATOMIC);\n\tif (qpti->req_cpu == NULL ||\n\t    qpti->req_dvma == 0) {\n\t\tdma_free_coherent(&op->dev, QSIZE(RES_QUEUE_LEN),\n\t\t\t\t  qpti->res_cpu, qpti->res_dvma);\n\t\tprintk(\"QPTI: Cannot map request queue.\\n\");\n\t\treturn -1;\n\t}\n\tmemset(qpti->res_cpu, 0, QSIZE(RES_QUEUE_LEN));\n\tmemset(qpti->req_cpu, 0, QSIZE(QLOGICPTI_REQ_QUEUE_LEN));\n\treturn 0;\n}\n\nstatic const char *qlogicpti_info(struct Scsi_Host *host)\n{\n\tstatic char buf[80];\n\tstruct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;\n\n\tsprintf(buf, \"PTI Qlogic,ISP SBUS SCSI irq %d regs at %p\",\n\t\tqpti->qhost->irq, qpti->qregs);\n\treturn buf;\n}\n\n \nstatic inline void marker_frob(struct Command_Entry *cmd)\n{\n\tstruct Marker_Entry *marker = (struct Marker_Entry *) cmd;\n\n\tmemset(marker, 0, sizeof(struct Marker_Entry));\n\tmarker->hdr.entry_cnt = 1;\n\tmarker->hdr.entry_type = ENTRY_MARKER;\n\tmarker->modifier = SYNC_ALL;\n\tmarker->rsvd = 0;\n}\n\nstatic inline void cmd_frob(struct Command_Entry *cmd, struct scsi_cmnd *Cmnd,\n\t\t\t    struct qlogicpti *qpti)\n{\n\tmemset(cmd, 0, sizeof(struct Command_Entry));\n\tcmd->hdr.entry_cnt = 1;\n\tcmd->hdr.entry_type = ENTRY_COMMAND;\n\tcmd->target_id = Cmnd->device->id;\n\tcmd->target_lun = Cmnd->device->lun;\n\tcmd->cdb_length = Cmnd->cmd_len;\n\tcmd->control_flags = 0;\n\tif (Cmnd->device->tagged_supported) {\n\t\tif (qpti->cmd_count[Cmnd->device->id] == 0)\n\t\t\tqpti->tag_ages[Cmnd->device->id] = jiffies;\n\t\tif (time_after(jiffies, qpti->tag_ages[Cmnd->device->id] + (5*HZ))) {\n\t\t\tcmd->control_flags = CFLAG_ORDERED_TAG;\n\t\t\tqpti->tag_ages[Cmnd->device->id] = jiffies;\n\t\t} else\n\t\t\tcmd->control_flags = CFLAG_SIMPLE_TAG;\n\t}\n\tif ((Cmnd->cmnd[0] == WRITE_6) ||\n\t    (Cmnd->cmnd[0] == WRITE_10) ||\n\t    (Cmnd->cmnd[0] == WRITE_12))\n\t\tcmd->control_flags |= CFLAG_WRITE;\n\telse\n\t\tcmd->control_flags |= CFLAG_READ;\n\tcmd->time_out = scsi_cmd_to_rq(Cmnd)->timeout / HZ;\n\tmemcpy(cmd->cdb, Cmnd->cmnd, Cmnd->cmd_len);\n}\n\n \nstatic inline int load_cmd(struct scsi_cmnd *Cmnd, struct Command_Entry *cmd,\n\t\t\t   struct qlogicpti *qpti, u_int in_ptr, u_int out_ptr)\n{\n\tstruct dataseg *ds;\n\tstruct scatterlist *sg, *s;\n\tint i, n;\n\n\tif (scsi_bufflen(Cmnd)) {\n\t\tint sg_count;\n\n\t\tsg = scsi_sglist(Cmnd);\n\t\tsg_count = dma_map_sg(&qpti->op->dev, sg,\n\t\t\t\t      scsi_sg_count(Cmnd),\n\t\t\t\t      Cmnd->sc_data_direction);\n\t\tif (!sg_count)\n\t\t\treturn -1;\n\t\tds = cmd->dataseg;\n\t\tcmd->segment_cnt = sg_count;\n\n\t\t \n\t\tn = sg_count;\n\t\tif (n > 4)\n\t\t\tn = 4;\n\t\tfor_each_sg(sg, s, n, i) {\n\t\t\tds[i].d_base = sg_dma_address(s);\n\t\t\tds[i].d_count = sg_dma_len(s);\n\t\t}\n\t\tsg_count -= 4;\n\t\tsg = s;\n\t\twhile (sg_count > 0) {\n\t\t\tstruct Continuation_Entry *cont;\n\n\t\t\t++cmd->hdr.entry_cnt;\n\t\t\tcont = (struct Continuation_Entry *) &qpti->req_cpu[in_ptr];\n\t\t\tin_ptr = NEXT_REQ_PTR(in_ptr);\n\t\t\tif (in_ptr == out_ptr)\n\t\t\t\treturn -1;\n\n\t\t\tcont->hdr.entry_type = ENTRY_CONTINUATION;\n\t\t\tcont->hdr.entry_cnt = 0;\n\t\t\tcont->hdr.sys_def_1 = 0;\n\t\t\tcont->hdr.flags = 0;\n\t\t\tcont->reserved = 0;\n\t\t\tds = cont->dataseg;\n\t\t\tn = sg_count;\n\t\t\tif (n > 7)\n\t\t\t\tn = 7;\n\t\t\tfor_each_sg(sg, s, n, i) {\n\t\t\t\tds[i].d_base = sg_dma_address(s);\n\t\t\t\tds[i].d_count = sg_dma_len(s);\n\t\t\t}\n\t\t\tsg_count -= n;\n\t\t\tsg = s;\n\t\t}\n\t} else {\n\t\tcmd->dataseg[0].d_base = 0;\n\t\tcmd->dataseg[0].d_count = 0;\n\t\tcmd->segment_cnt = 1;  \n\t}\n\n\t \n\tcmd->handle = in_ptr;\n\tqpti->cmd_slots[in_ptr] = Cmnd;\n\n\tqpti->cmd_count[Cmnd->device->id]++;\n\tsbus_writew(in_ptr, qpti->qregs + MBOX4);\n\tqpti->req_in_ptr = in_ptr;\n\n\treturn in_ptr;\n}\n\nstatic inline void update_can_queue(struct Scsi_Host *host, u_int in_ptr, u_int out_ptr)\n{\n\t \n\tint num_free = QLOGICPTI_REQ_QUEUE_LEN - REQ_QUEUE_DEPTH(in_ptr, out_ptr) - 64;\n\thost->can_queue = scsi_host_busy(host) + num_free;\n\thost->sg_tablesize = QLOGICPTI_MAX_SG(num_free);\n}\n\nstatic int qlogicpti_slave_configure(struct scsi_device *sdev)\n{\n\tstruct qlogicpti *qpti = shost_priv(sdev->host);\n\tint tgt = sdev->id;\n\tu_short param[6];\n\n\t \n\t \n\tif (sdev->sdtr) {\n\t\tqpti->dev_param[tgt].device_flags |= 0x10;\n\t} else {\n\t\tqpti->dev_param[tgt].synchronous_offset = 0;\n\t\tqpti->dev_param[tgt].synchronous_period = 0;\n\t}\n\t \n\tif (sdev->wdtr)\n\t\tqpti->dev_param[tgt].device_flags |= 0x20;\n\n\tparam[0] = MBOX_SET_TARGET_PARAMS;\n\tparam[1] = (tgt << 8);\n\tparam[2] = (qpti->dev_param[tgt].device_flags << 8);\n\tif (qpti->dev_param[tgt].device_flags & 0x10) {\n\t\tparam[3] = (qpti->dev_param[tgt].synchronous_offset << 8) |\n\t\t\tqpti->dev_param[tgt].synchronous_period;\n\t} else {\n\t\tparam[3] = 0;\n\t}\n\tqlogicpti_mbox_command(qpti, param, 0);\n\treturn 0;\n}\n\n \nstatic int qlogicpti_queuecommand_lck(struct scsi_cmnd *Cmnd)\n{\n\tvoid (*done)(struct scsi_cmnd *) = scsi_done;\n\tstruct Scsi_Host *host = Cmnd->device->host;\n\tstruct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;\n\tstruct Command_Entry *cmd;\n\tu_int out_ptr;\n\tint in_ptr;\n\n\tin_ptr = qpti->req_in_ptr;\n\tcmd = (struct Command_Entry *) &qpti->req_cpu[in_ptr];\n\tout_ptr = sbus_readw(qpti->qregs + MBOX4);\n\tin_ptr = NEXT_REQ_PTR(in_ptr);\n\tif (in_ptr == out_ptr)\n\t\tgoto toss_command;\n\n\tif (qpti->send_marker) {\n\t\tmarker_frob(cmd);\n\t\tqpti->send_marker = 0;\n\t\tif (NEXT_REQ_PTR(in_ptr) == out_ptr) {\n\t\t\tsbus_writew(in_ptr, qpti->qregs + MBOX4);\n\t\t\tqpti->req_in_ptr = in_ptr;\n\t\t\tgoto toss_command;\n\t\t}\n\t\tcmd = (struct Command_Entry *) &qpti->req_cpu[in_ptr];\n\t\tin_ptr = NEXT_REQ_PTR(in_ptr);\n\t}\n\tcmd_frob(cmd, Cmnd, qpti);\n\tif ((in_ptr = load_cmd(Cmnd, cmd, qpti, in_ptr, out_ptr)) == -1)\n\t\tgoto toss_command;\n\n\tupdate_can_queue(host, in_ptr, out_ptr);\n\n\treturn 0;\n\ntoss_command:\n\tprintk(KERN_EMERG \"qlogicpti%d: request queue overflow\\n\",\n\t       qpti->qpti_id);\n\n\t \n\tCmnd->result = DID_BUS_BUSY;\n\tdone(Cmnd);\n\treturn 1;\n}\n\nstatic DEF_SCSI_QCMD(qlogicpti_queuecommand)\n\nstatic int qlogicpti_return_status(struct Status_Entry *sts, int id)\n{\n\tint host_status = DID_ERROR;\n\n\tswitch (sts->completion_status) {\n\t      case CS_COMPLETE:\n\t\thost_status = DID_OK;\n\t\tbreak;\n\t      case CS_INCOMPLETE:\n\t\tif (!(sts->state_flags & SF_GOT_BUS))\n\t\t\thost_status = DID_NO_CONNECT;\n\t\telse if (!(sts->state_flags & SF_GOT_TARGET))\n\t\t\thost_status = DID_BAD_TARGET;\n\t\telse if (!(sts->state_flags & SF_SENT_CDB))\n\t\t\thost_status = DID_ERROR;\n\t\telse if (!(sts->state_flags & SF_TRANSFERRED_DATA))\n\t\t\thost_status = DID_ERROR;\n\t\telse if (!(sts->state_flags & SF_GOT_STATUS))\n\t\t\thost_status = DID_ERROR;\n\t\telse if (!(sts->state_flags & SF_GOT_SENSE))\n\t\t\thost_status = DID_ERROR;\n\t\tbreak;\n\t      case CS_DMA_ERROR:\n\t      case CS_TRANSPORT_ERROR:\n\t\thost_status = DID_ERROR;\n\t\tbreak;\n\t      case CS_RESET_OCCURRED:\n\t      case CS_BUS_RESET:\n\t\thost_status = DID_RESET;\n\t\tbreak;\n\t      case CS_ABORTED:\n\t\thost_status = DID_ABORT;\n\t\tbreak;\n\t      case CS_TIMEOUT:\n\t\thost_status = DID_TIME_OUT;\n\t\tbreak;\n\t      case CS_DATA_OVERRUN:\n\t      case CS_COMMAND_OVERRUN:\n\t      case CS_STATUS_OVERRUN:\n\t      case CS_BAD_MESSAGE:\n\t      case CS_NO_MESSAGE_OUT:\n\t      case CS_EXT_ID_FAILED:\n\t      case CS_IDE_MSG_FAILED:\n\t      case CS_ABORT_MSG_FAILED:\n\t      case CS_NOP_MSG_FAILED:\n\t      case CS_PARITY_ERROR_MSG_FAILED:\n\t      case CS_DEVICE_RESET_MSG_FAILED:\n\t      case CS_ID_MSG_FAILED:\n\t      case CS_UNEXP_BUS_FREE:\n\t\thost_status = DID_ERROR;\n\t\tbreak;\n\t      case CS_DATA_UNDERRUN:\n\t\thost_status = DID_OK;\n\t\tbreak;\n\t      default:\n\t\tprintk(KERN_EMERG \"qlogicpti%d: unknown completion status 0x%04x\\n\",\n\t\t       id, sts->completion_status);\n\t\thost_status = DID_ERROR;\n\t\tbreak;\n\t}\n\n\treturn (sts->scsi_status & STATUS_MASK) | (host_status << 16);\n}\n\nstatic struct scsi_cmnd *qlogicpti_intr_handler(struct qlogicpti *qpti)\n{\n\tstruct scsi_cmnd *Cmnd, *done_queue = NULL;\n\tstruct Status_Entry *sts;\n\tu_int in_ptr, out_ptr;\n\n\tif (!(sbus_readw(qpti->qregs + SBUS_STAT) & SBUS_STAT_RINT))\n\t\treturn NULL;\n\n\tin_ptr = sbus_readw(qpti->qregs + MBOX5);\n\tsbus_writew(HCCTRL_CRIRQ, qpti->qregs + HCCTRL);\n\tif (sbus_readw(qpti->qregs + SBUS_SEMAPHORE) & SBUS_SEMAPHORE_LCK) {\n\t\tswitch (sbus_readw(qpti->qregs + MBOX0)) {\n\t\tcase ASYNC_SCSI_BUS_RESET:\n\t\tcase EXECUTION_TIMEOUT_RESET:\n\t\t\tqpti->send_marker = 1;\n\t\t\tbreak;\n\t\tcase INVALID_COMMAND:\n\t\tcase HOST_INTERFACE_ERROR:\n\t\tcase COMMAND_ERROR:\n\t\tcase COMMAND_PARAM_ERROR:\n\t\t\tbreak;\n\t\t};\n\t\tsbus_writew(0, qpti->qregs + SBUS_SEMAPHORE);\n\t}\n\n\t \n\tout_ptr = qpti->res_out_ptr;\n\twhile (out_ptr != in_ptr) {\n\t\tu_int cmd_slot;\n\n\t\tsts = (struct Status_Entry *) &qpti->res_cpu[out_ptr];\n\t\tout_ptr = NEXT_RES_PTR(out_ptr);\n\n\t\t \n\t\tcmd_slot = sts->handle;\n\t\tCmnd = qpti->cmd_slots[cmd_slot];\n\t\tqpti->cmd_slots[cmd_slot] = NULL;\n\n\t\tif (sts->completion_status == CS_RESET_OCCURRED ||\n\t\t    sts->completion_status == CS_ABORTED ||\n\t\t    (sts->status_flags & STF_BUS_RESET))\n\t\t\tqpti->send_marker = 1;\n\n\t\tif (sts->state_flags & SF_GOT_SENSE)\n\t\t\tmemcpy(Cmnd->sense_buffer, sts->req_sense_data,\n\t\t\t       SCSI_SENSE_BUFFERSIZE);\n\n\t\tif (sts->hdr.entry_type == ENTRY_STATUS)\n\t\t\tCmnd->result =\n\t\t\t    qlogicpti_return_status(sts, qpti->qpti_id);\n\t\telse\n\t\t\tCmnd->result = DID_ERROR << 16;\n\n\t\tif (scsi_bufflen(Cmnd))\n\t\t\tdma_unmap_sg(&qpti->op->dev,\n\t\t\t\t     scsi_sglist(Cmnd), scsi_sg_count(Cmnd),\n\t\t\t\t     Cmnd->sc_data_direction);\n\n\t\tqpti->cmd_count[Cmnd->device->id]--;\n\t\tsbus_writew(out_ptr, qpti->qregs + MBOX5);\n\t\tCmnd->host_scribble = (unsigned char *) done_queue;\n\t\tdone_queue = Cmnd;\n\t}\n\tqpti->res_out_ptr = out_ptr;\n\n\treturn done_queue;\n}\n\nstatic irqreturn_t qpti_intr(int irq, void *dev_id)\n{\n\tstruct qlogicpti *qpti = dev_id;\n\tunsigned long flags;\n\tstruct scsi_cmnd *dq;\n\n\tspin_lock_irqsave(qpti->qhost->host_lock, flags);\n\tdq = qlogicpti_intr_handler(qpti);\n\n\tif (dq != NULL) {\n\t\tdo {\n\t\t\tstruct scsi_cmnd *next;\n\n\t\t\tnext = (struct scsi_cmnd *) dq->host_scribble;\n\t\t\tscsi_done(dq);\n\t\t\tdq = next;\n\t\t} while (dq != NULL);\n\t}\n\tspin_unlock_irqrestore(qpti->qhost->host_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int qlogicpti_abort(struct scsi_cmnd *Cmnd)\n{\n\tu_short param[6];\n\tstruct Scsi_Host *host = Cmnd->device->host;\n\tstruct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;\n\tint return_status = SUCCESS;\n\tu32 cmd_cookie;\n\tint i;\n\n\tprintk(KERN_WARNING \"qlogicpti%d: Aborting cmd for tgt[%d] lun[%d]\\n\",\n\t       qpti->qpti_id, (int)Cmnd->device->id, (int)Cmnd->device->lun);\n\n\tqlogicpti_disable_irqs(qpti);\n\n\t \n\tfor (i = 0; i < QLOGICPTI_REQ_QUEUE_LEN + 1; i++)\n\t\tif (qpti->cmd_slots[i] == Cmnd)\n\t\t\tbreak;\n\tcmd_cookie = i;\n\n\tparam[0] = MBOX_ABORT;\n\tparam[1] = (((u_short) Cmnd->device->id) << 8) | Cmnd->device->lun;\n\tparam[2] = cmd_cookie >> 16;\n\tparam[3] = cmd_cookie & 0xffff;\n\tif (qlogicpti_mbox_command(qpti, param, 0) ||\n\t    (param[0] != MBOX_COMMAND_COMPLETE)) {\n\t\tprintk(KERN_EMERG \"qlogicpti%d: scsi abort failure: %x\\n\",\n\t\t       qpti->qpti_id, param[0]);\n\t\treturn_status = FAILED;\n\t}\n\n\tqlogicpti_enable_irqs(qpti);\n\n\treturn return_status;\n}\n\nstatic int qlogicpti_reset(struct scsi_cmnd *Cmnd)\n{\n\tu_short param[6];\n\tstruct Scsi_Host *host = Cmnd->device->host;\n\tstruct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;\n\tint return_status = SUCCESS;\n\n\tprintk(KERN_WARNING \"qlogicpti%d: Resetting SCSI bus!\\n\",\n\t       qpti->qpti_id);\n\n\tqlogicpti_disable_irqs(qpti);\n\n\tparam[0] = MBOX_BUS_RESET;\n\tparam[1] = qpti->host_param.bus_reset_delay;\n\tif (qlogicpti_mbox_command(qpti, param, 0) ||\n\t   (param[0] != MBOX_COMMAND_COMPLETE)) {\n\t\tprintk(KERN_EMERG \"qlogicisp%d: scsi bus reset failure: %x\\n\",\n\t\t       qpti->qpti_id, param[0]);\n\t\treturn_status = FAILED;\n\t}\n\n\tqlogicpti_enable_irqs(qpti);\n\n\treturn return_status;\n}\n\nstatic const struct scsi_host_template qpti_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"qlogicpti\",\n\t.info\t\t\t= qlogicpti_info,\n\t.queuecommand\t\t= qlogicpti_queuecommand,\n\t.slave_configure\t= qlogicpti_slave_configure,\n\t.eh_abort_handler\t= qlogicpti_abort,\n\t.eh_host_reset_handler\t= qlogicpti_reset,\n\t.can_queue\t\t= QLOGICPTI_REQ_QUEUE_LEN,\n\t.this_id\t\t= 7,\n\t.sg_tablesize\t\t= QLOGICPTI_MAX_SG(QLOGICPTI_REQ_QUEUE_LEN),\n};\n\nstatic const struct of_device_id qpti_match[];\nstatic int qpti_sbus_probe(struct platform_device *op)\n{\n\tstruct device_node *dp = op->dev.of_node;\n\tstruct Scsi_Host *host;\n\tstruct qlogicpti *qpti;\n\tstatic int nqptis;\n\tconst char *fcode;\n\n\t \n\tif (op->archdata.irqs[0] == 0)\n\t\treturn -ENODEV;\n\n\thost = scsi_host_alloc(&qpti_template, sizeof(struct qlogicpti));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tqpti = shost_priv(host);\n\n\thost->max_id = MAX_TARGETS;\n\tqpti->qhost = host;\n\tqpti->op = op;\n\tqpti->qpti_id = nqptis;\n\tqpti->is_pti = !of_node_name_eq(op->dev.of_node, \"QLGC,isp\");\n\n\tif (qpti_map_regs(qpti) < 0)\n\t\tgoto fail_unlink;\n\n\tif (qpti_register_irq(qpti) < 0)\n\t\tgoto fail_unmap_regs;\n\n\tqpti_get_scsi_id(qpti);\n\tqpti_get_bursts(qpti);\n\tqpti_get_clock(qpti);\n\n\t \n\tmemset(qpti->cmd_slots, 0, sizeof(qpti->cmd_slots));\n\n\tif (qpti_map_queues(qpti) < 0)\n\t\tgoto fail_free_irq;\n\n\t \n\tif (qlogicpti_load_firmware(qpti))\n\t\tgoto fail_unmap_queues;\n\tif (qpti->is_pti) {\n\t\t \n\t\tif (qlogicpti_verify_tmon(qpti))\n\t\t\tgoto fail_unmap_queues;\n\t}\n\n\t \n\tif (qlogicpti_reset_hardware(host))\n\t\tgoto fail_unmap_queues;\n\n\tprintk(\"(Firmware v%d.%d.%d)\", qpti->fware_majrev,\n\t       qpti->fware_minrev, qpti->fware_micrev);\n\n\tfcode = of_get_property(dp, \"isp-fcode\", NULL);\n\tif (fcode && fcode[0])\n\t\tprintk(\"(FCode %s)\", fcode);\n\tqpti->differential = of_property_read_bool(dp, \"differential\");\n\n\tprintk(\"\\nqlogicpti%d: [%s Wide, using %s interface]\\n\",\n\t\tqpti->qpti_id,\n\t\t(qpti->ultra ? \"Ultra\" : \"Fast\"),\n\t\t(qpti->differential ? \"differential\" : \"single ended\"));\n\n\tif (scsi_add_host(host, &op->dev)) {\n\t\tprintk(\"qlogicpti%d: Failed scsi_add_host\\n\", qpti->qpti_id);\n\t\tgoto fail_unmap_queues;\n\t}\n\n\tdev_set_drvdata(&op->dev, qpti);\n\n\tqpti_chain_add(qpti);\n\n\tscsi_scan_host(host);\n\tnqptis++;\n\n\treturn 0;\n\nfail_unmap_queues:\n#define QSIZE(entries)\t(((entries) + 1) * QUEUE_ENTRY_LEN)\n\tdma_free_coherent(&op->dev,\n\t\t\t  QSIZE(RES_QUEUE_LEN),\n\t\t\t  qpti->res_cpu, qpti->res_dvma);\n\tdma_free_coherent(&op->dev,\n\t\t\t  QSIZE(QLOGICPTI_REQ_QUEUE_LEN),\n\t\t\t  qpti->req_cpu, qpti->req_dvma);\n#undef QSIZE\n\nfail_free_irq:\n\tfree_irq(qpti->irq, qpti);\n\nfail_unmap_regs:\n\tof_iounmap(&op->resource[0], qpti->qregs,\n\t\t   resource_size(&op->resource[0]));\n\tif (qpti->is_pti)\n\t\tof_iounmap(&op->resource[0], qpti->sreg,\n\t\t\t   sizeof(unsigned char));\n\nfail_unlink:\n\tscsi_host_put(host);\n\n\treturn -ENODEV;\n}\n\nstatic int qpti_sbus_remove(struct platform_device *op)\n{\n\tstruct qlogicpti *qpti = dev_get_drvdata(&op->dev);\n\n\tqpti_chain_del(qpti);\n\n\tscsi_remove_host(qpti->qhost);\n\n\t \n\tsbus_writew(0, qpti->qregs + SBUS_CTRL);\n\n\t \n\tfree_irq(qpti->irq, qpti);\n\n#define QSIZE(entries)\t(((entries) + 1) * QUEUE_ENTRY_LEN)\n\tdma_free_coherent(&op->dev,\n\t\t\t  QSIZE(RES_QUEUE_LEN),\n\t\t\t  qpti->res_cpu, qpti->res_dvma);\n\tdma_free_coherent(&op->dev,\n\t\t\t  QSIZE(QLOGICPTI_REQ_QUEUE_LEN),\n\t\t\t  qpti->req_cpu, qpti->req_dvma);\n#undef QSIZE\n\n\tof_iounmap(&op->resource[0], qpti->qregs,\n\t\t   resource_size(&op->resource[0]));\n\tif (qpti->is_pti)\n\t\tof_iounmap(&op->resource[0], qpti->sreg, sizeof(unsigned char));\n\n\tscsi_host_put(qpti->qhost);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qpti_match[] = {\n\t{\n\t\t.name = \"ptisp\",\n\t},\n\t{\n\t\t.name = \"PTI,ptisp\",\n\t},\n\t{\n\t\t.name = \"QLGC,isp\",\n\t},\n\t{\n\t\t.name = \"SUNW,isp\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, qpti_match);\n\nstatic struct platform_driver qpti_sbus_driver = {\n\t.driver = {\n\t\t.name = \"qpti\",\n\t\t.of_match_table = qpti_match,\n\t},\n\t.probe\t\t= qpti_sbus_probe,\n\t.remove\t\t= qpti_sbus_remove,\n};\nmodule_platform_driver(qpti_sbus_driver);\n\nMODULE_DESCRIPTION(\"QlogicISP SBUS driver\");\nMODULE_AUTHOR(\"David S. Miller (davem@davemloft.net)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"2.1\");\nMODULE_FIRMWARE(\"qlogic/isp1000.bin\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}