{
  "module_name": "aic7xxx.seq",
  "hash_id": "ad0a3ed19baed3fcad2c9c3eaebbceb59b9e1541d1a7af199df68731671183da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic7xxx.seq",
  "human_readable_source": "/*\n * Adaptec 274x/284x/294x device driver firmware for Linux and FreeBSD.\n *\n * Copyright (c) 1994-2001 Justin T. Gibbs.\n * Copyright (c) 2000-2001 Adaptec Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions, and the following disclaimer,\n *    without modification.\n * 2. Redistributions in binary form must reproduce at minimum a disclaimer\n *    substantially similar to the \"NO WARRANTY\" disclaimer below\n *    (\"Disclaimer\") and any redistribution must be conditioned upon\n *    including a substantially similar Disclaimer requirement for further\n *    binary redistribution.\n * 3. Neither the names of the above-listed copyright holders nor the names\n *    of any contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * Alternatively, this software may be distributed under the terms of the\n * GNU General Public License (\"GPL\") version 2 as published by the Free\n * Software Foundation.\n *\n * NO WARRANTY\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGES.\n *\n * $FreeBSD$\n */\n\nVERSION = \"$Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#58 $\"\nPATCH_ARG_LIST = \"struct ahc_softc *ahc\"\nPREFIX = \"ahc_\"\n\n#include \"aic7xxx.reg\"\n#include \"scsi_message.h\"\n\n/*\n * A few words on the waiting SCB list:\n * After starting the selection hardware, we check for reconnecting targets\n * as well as for our selection to complete just in case the reselection wins\n * bus arbitration.  The problem with this is that we must keep track of the\n * SCB that we've already pulled from the QINFIFO and started the selection\n * on just in case the reselection wins so that we can retry the selection at\n * a later time.  This problem cannot be resolved by holding a single entry\n * in scratch ram since a reconnecting target can request sense and this will\n * create yet another SCB waiting for selection.  The solution used here is to \n * use byte 27 of the SCB as a pseudo-next pointer and to thread a list\n * of SCBs that are awaiting selection.  Since 0-0xfe are valid SCB indexes, \n * SCB_LIST_NULL is 0xff which is out of range.  An entry is also added to\n * this list every time a request sense occurs or after completing a non-tagged\n * command for which a second SCB has been queued.  The sequencer will\n * automatically consume the entries.\n */\n\nbus_free_sel:\n\t/*\n\t * Turn off the selection hardware.  We need to reset the\n\t * selection request in order to perform a new selection.\n\t */\n\tand\tSCSISEQ, TEMODE|ENSELI|ENRSELI|ENAUTOATNP;\n\tand\tSIMODE1, ~ENBUSFREE;\npoll_for_work:\n\tcall\tclear_target_state;\n\tand\tSXFRCTL0, ~SPIOEN;\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tclr\tSCSIBUSL;\n\t}\n\ttest\tSCSISEQ, ENSELO\tjnz poll_for_selection;\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\txor\tSBLKCTL,SELBUSB;\t/* Toggle to the other bus */\n\t\ttest\tSCSISEQ, ENSELO\t\tjnz poll_for_selection;\n\t}\n\tcmp\tWAITING_SCBH,SCB_LIST_NULL jne start_waiting;\npoll_for_work_loop:\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\txor\tSBLKCTL,SELBUSB;\t/* Toggle to the other bus */\n\t}\n\ttest\tSSTAT0, SELDO|SELDI\tjnz selection;\ntest_queue:\n\t/* Has the driver posted any work for us? */\nBEGIN_CRITICAL;\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\ttest\tQOFF_CTLSTA, SCB_AVAIL jz poll_for_work_loop;\n\t} else {\n\t\tmov\tA, QINPOS;\n\t\tcmp\tKERNEL_QINPOS, A je poll_for_work_loop;\n\t}\n\tmov\tARG_1, NEXT_QUEUED_SCB;\n\n\t/*\n\t * We have at least one queued SCB now and we don't have any \n\t * SCBs in the list of SCBs awaiting selection.  Allocate a\n\t * card SCB for the host's SCB and get to work on it.\n\t */\n\tif ((ahc->flags & AHC_PAGESCBS) != 0) {\n\t\tmov\tALLZEROS\tcall\tget_free_or_disc_scb;\n\t} else {\n\t\t/* In the non-paging case, the SCBID == hardware SCB index */\n\t\tmov\tSCBPTR, ARG_1;\n\t}\n\tor\tSEQ_FLAGS2, SCB_DMA;\nEND_CRITICAL;\ndma_queued_scb:\n\t/*\n\t * DMA the SCB from host ram into the current SCB location.\n\t */\n\tmvi\tDMAPARAMS, HDMAEN|DIRECTION|FIFORESET;\n\tmov\tARG_1\tcall dma_scb;\n\t/*\n\t * Check one last time to see if this SCB was canceled\n\t * before we completed the DMA operation.  If it was,\n\t * the QINFIFO next pointer will not match our saved\n\t * value.\n\t */\n\tmov\tA, ARG_1;\nBEGIN_CRITICAL;\n\tcmp\tNEXT_QUEUED_SCB, A jne abort_qinscb;\n\tif ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {\n\t\tcmp\tSCB_TAG, A je . + 2;\n\t\tmvi\tSCB_MISMATCH call set_seqint;\n\t}\n\tmov\tNEXT_QUEUED_SCB, SCB_NEXT;\n\tmov\tSCB_NEXT,WAITING_SCBH;\n\tmov\tWAITING_SCBH, SCBPTR;\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tmov\tNONE, SNSCB_QOFF;\n\t} else {\n\t\tinc\tQINPOS;\n\t}\n\tand\tSEQ_FLAGS2, ~SCB_DMA;\nEND_CRITICAL;\nstart_waiting:\n\t/*\n\t * Start the first entry on the waiting SCB list.\n\t */\n\tmov\tSCBPTR, WAITING_SCBH;\n\tcall\tstart_selection;\n\npoll_for_selection:\n\t/*\n\t * Twin channel devices cannot handle things like SELTO\n\t * interrupts on the \"background\" channel.  So, while\n\t * selecting, keep polling the current channel until\n\t * either a selection or reselection occurs.\n\t */\n\ttest\tSSTAT0, SELDO|SELDI\tjz poll_for_selection;\n\nselection:\n\t/*\n\t * We aren't expecting a bus free, so interrupt\n\t * the kernel driver if it happens.\n\t */\n\tmvi\tCLRSINT1,CLRBUSFREE;\n\tif ((ahc->features & AHC_DT) == 0) {\n\t\tor\tSIMODE1, ENBUSFREE;\n\t}\n\n\t/*\n\t * Guard against a bus free after (re)selection\n\t * but prior to enabling the busfree interrupt.  SELDI\n\t * and SELDO will be cleared in that case.\n\t */\n\ttest\tSSTAT0, SELDI|SELDO\tjz bus_free_sel;\n\ttest\tSSTAT0,SELDO\tjnz select_out;\nselect_in:\n\tif ((ahc->flags & AHC_TARGETROLE) != 0) {\n\t\tif ((ahc->flags & AHC_INITIATORROLE) != 0) {\n\t\t\ttest\tSSTAT0, TARGET\tjz initiator_reselect;\n\t\t}\n\t\tmvi\tCLRSINT0, CLRSELDI;\n\n\t\t/*\n\t\t * We've just been selected.  Assert BSY and\n\t\t * setup the phase for receiving messages\n\t\t * from the target.\n\t\t */\n\t\tmvi\tSCSISIGO, P_MESGOUT|BSYO;\n\n\t\t/*\n\t\t * Setup the DMA for sending the identify and\n\t\t * command information.\n\t\t */\n\t\tmvi\tSEQ_FLAGS, CMDPHASE_PENDING;\n\n\t\tmov     A, TQINPOS;\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\tmvi\tDINDEX, CCHADDR;\n\t\t\tmvi\tSHARED_DATA_ADDR call set_32byte_addr;\n\t\t\tmvi\tCCSCBCTL, CCSCBRESET;\n\t\t} else {\n\t\t\tmvi\tDINDEX, HADDR;\n\t\t\tmvi\tSHARED_DATA_ADDR call set_32byte_addr;\n\t\t\tmvi\tDFCNTRL, FIFORESET;\n\t\t}\n\n\t\t/* Initiator that selected us */\n\t\tand\tSAVED_SCSIID, SELID_MASK, SELID;\n\t\t/* The Target ID we were selected at */\n\t\tif ((ahc->features & AHC_MULTI_TID) != 0) {\n\t\t\tand\tA, OID, TARGIDIN;\n\t\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tand\tA, OID, SCSIID_ULTRA2;\n\t\t} else {\n\t\t\tand\tA, OID, SCSIID;\n\t\t}\n\t\tor\tSAVED_SCSIID, A;\n\t\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\t\ttest \tSBLKCTL, SELBUSB jz . + 2;\n\t\t\tor\tSAVED_SCSIID, TWIN_CHNLB;\n\t\t}\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\tmov\tCCSCBRAM, SAVED_SCSIID;\n\t\t} else {\n\t\t\tmov\tDFDAT, SAVED_SCSIID;\n\t\t}\n\n\t\t/*\n\t\t * If ATN isn't asserted, the target isn't interested\n\t\t * in talking to us.  Go directly to bus free.\n\t\t * XXX SCSI-1 may require us to assume lun 0 if\n\t\t * ATN is false.\n\t\t */\n\t\ttest\tSCSISIGI, ATNI\tjz\ttarget_busfree;\n\n\t\t/*\n\t\t * Watch ATN closely now as we pull in messages from the\n\t\t * initiator.  We follow the guidlines from section 6.5\n\t\t * of the SCSI-2 spec for what messages are allowed when.\n\t\t */\n\t\tcall\ttarget_inb;\n\n\t\t/*\n\t\t * Our first message must be one of IDENTIFY, ABORT, or\n\t\t * BUS_DEVICE_RESET.\n\t\t */\n\t\ttest\tDINDEX, MSG_IDENTIFYFLAG jz host_target_message_loop;\n\t\t/* Store for host */\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\tmov\tCCSCBRAM, DINDEX;\n\t\t} else {\n\t\t\tmov\tDFDAT, DINDEX;\n\t\t}\n\t\tand\tSAVED_LUN, MSG_IDENTIFY_LUNMASK, DINDEX;\n\n\t\t/* Remember for disconnection decision */\n\t\ttest\tDINDEX, MSG_IDENTIFY_DISCFLAG jnz . + 2;\n\t\t/* XXX Honor per target settings too */\n\t\tor\tSEQ_FLAGS, NO_DISCONNECT;\n\n\t\ttest\tSCSISIGI, ATNI\tjz\tident_messages_done;\n\t\tcall\ttarget_inb;\n\t\t/*\n\t\t * If this is a tagged request, the tagged message must\n\t\t * immediately follow the identify.  We test for a valid\n\t\t * tag message by seeing if it is >= MSG_SIMPLE_Q_TAG and\n\t\t * < MSG_IGN_WIDE_RESIDUE.\n\t\t */\n\t\tadd\tA, -MSG_SIMPLE_Q_TAG, DINDEX;\n\t\tjnc\tident_messages_done_msg_pending;\n\t\tadd\tA, -MSG_IGN_WIDE_RESIDUE, DINDEX;\n\t\tjc\tident_messages_done_msg_pending;\n\n\t\t/* Store for host */\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\tmov\tCCSCBRAM, DINDEX;\n\t\t} else {\n\t\t\tmov\tDFDAT, DINDEX;\n\t\t}\n\t\t\n\t\t/*\n\t\t * If the initiator doesn't feel like providing a tag number,\n\t\t * we've got a failed selection and must transition to bus\n\t\t * free.\n\t\t */\n\t\ttest\tSCSISIGI, ATNI\tjz\ttarget_busfree;\n\n\t\t/*\n\t\t * Store the tag for the host.\n\t\t */\n\t\tcall\ttarget_inb;\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\tmov\tCCSCBRAM, DINDEX;\n\t\t} else {\n\t\t\tmov\tDFDAT, DINDEX;\n\t\t}\n\t\tmov\tINITIATOR_TAG, DINDEX;\n\t\tor\tSEQ_FLAGS, TARGET_CMD_IS_TAGGED;\n\nident_messages_done:\n\t\t/* Terminate the ident list */\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\tmvi\tCCSCBRAM, SCB_LIST_NULL;\n\t\t} else {\n\t\t\tmvi\tDFDAT, SCB_LIST_NULL;\n\t\t}\n\t\tor\tSEQ_FLAGS, TARG_CMD_PENDING;\n\t\ttest\tSEQ_FLAGS2, TARGET_MSG_PENDING\n\t\t\tjnz target_mesgout_pending;\n\t\ttest\tSCSISIGI, ATNI jnz target_mesgout_continue;\n\t\tjmp\ttarget_ITloop;\n\n\nident_messages_done_msg_pending:\n\t\tor\tSEQ_FLAGS2, TARGET_MSG_PENDING;\n\t\tjmp\tident_messages_done;\n\n\t\t/*\n\t\t * Pushed message loop to allow the kernel to\n\t\t * run it's own target mode message state engine.\n\t\t */\nhost_target_message_loop:\n\t\tmvi\tHOST_MSG_LOOP call set_seqint;\n\t\tcmp\tRETURN_1, EXIT_MSG_LOOP\tje target_ITloop;\n\t\ttest\tSSTAT0, SPIORDY jz .;\n\t\tjmp\thost_target_message_loop;\n\t}\n\nif ((ahc->flags & AHC_INITIATORROLE) != 0) {\n/*\n * Reselection has been initiated by a target. Make a note that we've been\n * reselected, but haven't seen an IDENTIFY message from the target yet.\n */\ninitiator_reselect:\n\t/* XXX test for and handle ONE BIT condition */\n\tor\tSXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;\n\tand\tSAVED_SCSIID, SELID_MASK, SELID;\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tand\tA, OID, SCSIID_ULTRA2;\n\t} else {\n\t\tand\tA, OID, SCSIID;\n\t}\n\tor\tSAVED_SCSIID, A;\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\ttest\tSBLKCTL, SELBUSB\tjz . + 2;\n\t\tor\tSAVED_SCSIID, TWIN_CHNLB;\n\t}\n\tmvi\tCLRSINT0, CLRSELDI;\n\tjmp\tITloop;\n}\n\nabort_qinscb:\n\tcall\tadd_scb_to_free_list;\n\tjmp\tpoll_for_work_loop;\n\nstart_selection:\n\t/*\n\t * If bus reset interrupts have been disabled (from a previous\n\t * reset), re-enable them now.  Resets are only of interest\n\t * when we have outstanding transactions, so we can safely\n\t * defer re-enabling the interrupt until, as an initiator,\n\t * we start sending out transactions again.\n\t */\n\ttest\tSIMODE1, ENSCSIRST\tjnz . + 3;\n\tmvi\tCLRSINT1, CLRSCSIRSTI;\n\tor\tSIMODE1, ENSCSIRST;\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\tand\tSINDEX,~SELBUSB,SBLKCTL;/* Clear channel select bit */\n\t\ttest\tSCB_SCSIID, TWIN_CHNLB jz . + 2;\n\t\tor\tSINDEX, SELBUSB;\n\t\tmov\tSBLKCTL,SINDEX;\t\t/* select channel */\n\t}\ninitialize_scsiid:\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmov\tSCSIID_ULTRA2, SCB_SCSIID;\n\t} else if ((ahc->features & AHC_TWIN) != 0) {\n\t\tand\tSCSIID, TWIN_TID|OID, SCB_SCSIID;\n\t} else {\n\t\tmov\tSCSIID, SCB_SCSIID;\n\t}\n\tif ((ahc->flags & AHC_TARGETROLE) != 0) {\n\t\tmov\tSINDEX, SCSISEQ_TEMPLATE;\n\t\ttest\tSCB_CONTROL, TARGET_SCB jz . + 2;\n\t\tor\tSINDEX, TEMODE;\n\t\tmov\tSCSISEQ, SINDEX ret;\n\t} else {\n\t\tmov\tSCSISEQ, SCSISEQ_TEMPLATE ret;\n\t}\n\n/*\n * Initialize transfer settings with SCB provided settings.\n */\nset_transfer_settings:\n\tif ((ahc->features & AHC_ULTRA) != 0) {\n\t\ttest\tSCB_CONTROL, ULTRAENB jz . + 2;\n\t\tor\tSXFRCTL0, FAST20;\n\t} \n\t/*\n\t * Initialize SCSIRATE with the appropriate value for this target.\n\t */\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbmov\tSCSIRATE, SCB_SCSIRATE, 2 ret;\n\t} else {\n\t\tmov\tSCSIRATE, SCB_SCSIRATE ret;\n\t}\n\nif ((ahc->flags & AHC_TARGETROLE) != 0) {\n/*\n * We carefully toggle SPIOEN to allow us to return the \n * message byte we receive so it can be checked prior to\n * driving REQ on the bus for the next byte.\n */\ntarget_inb:\n\t/*\n\t * Drive REQ on the bus by enabling SCSI PIO.\n\t */\n\tor\tSXFRCTL0, SPIOEN;\n\t/* Wait for the byte */\n\ttest\tSSTAT0, SPIORDY jz .;\n\t/* Prevent our read from triggering another REQ */\n\tand\tSXFRCTL0, ~SPIOEN;\n\t/* Save latched contents */\n\tmov\tDINDEX, SCSIDATL ret;\n}\n\n/*\n * After the selection, remove this SCB from the \"waiting SCB\"\n * list.  This is achieved by simply moving our \"next\" pointer into\n * WAITING_SCBH.  Our next pointer will be set to null the next time this\n * SCB is used, so don't bother with it now.\n */\nselect_out:\n\t/* Turn off the selection hardware */\n\tand\tSCSISEQ, TEMODE|ENSELI|ENRSELI|ENAUTOATNP, SCSISEQ;\n\tmov\tSCBPTR, WAITING_SCBH;\n\tmov\tWAITING_SCBH,SCB_NEXT;\n\tmov\tSAVED_SCSIID, SCB_SCSIID;\n\tand\tSAVED_LUN, LID, SCB_LUN;\n\tcall\tset_transfer_settings;\n\tif ((ahc->flags & AHC_TARGETROLE) != 0) {\n\t\ttest\tSSTAT0, TARGET\tjz initiator_select;\n\n\t\tor\tSXFRCTL0, CLRSTCNT|CLRCHN;\n\n\t\t/*\n\t\t * Put tag in connonical location since not\n\t\t * all connections have an SCB.\n\t\t */\n\t\tmov\tINITIATOR_TAG, SCB_TARGET_ITAG;\n\n\t\t/*\n\t\t * We've just re-selected an initiator.\n\t\t * Assert BSY and setup the phase for\n\t\t * sending our identify messages.\n\t\t */\n\t\tmvi\tP_MESGIN|BSYO call change_phase;\n\t\tmvi\tCLRSINT0, CLRSELDO;\n\n\t\t/*\n\t\t * Start out with a simple identify message.\n\t\t */\n\t\tor\tSAVED_LUN, MSG_IDENTIFYFLAG call target_outb;\n\n\t\t/*\n\t\t * If we are the result of a tagged command, send\n\t\t * a simple Q tag and the tag id.\n\t\t */\n\t\ttest\tSCB_CONTROL, TAG_ENB\tjz . + 3;\n\t\tmvi\tMSG_SIMPLE_Q_TAG call target_outb;\n\t\tmov\tSCB_TARGET_ITAG call target_outb;\ntarget_synccmd:\n\t\t/*\n\t\t * Now determine what phases the host wants us\n\t\t * to go through.\n\t\t */\n\t\tmov\tSEQ_FLAGS, SCB_TARGET_PHASES;\n\t\t\n\t\ttest\tSCB_CONTROL, MK_MESSAGE\tjz target_ITloop;\n\t\tmvi\tP_MESGIN|BSYO call change_phase;\n\t\tjmp\thost_target_message_loop;\ntarget_ITloop:\n\t\t/*\n\t\t * Start honoring ATN signals now that\n\t\t * we properly identified ourselves.\n\t\t */\n\t\ttest\tSCSISIGI, ATNI\t\t\tjnz target_mesgout;\n\t\ttest\tSEQ_FLAGS, CMDPHASE_PENDING\tjnz target_cmdphase;\n\t\ttest\tSEQ_FLAGS, DPHASE_PENDING\tjnz target_dphase;\n\t\ttest\tSEQ_FLAGS, SPHASE_PENDING\tjnz target_sphase;\n\n\t\t/*\n\t\t * No more work to do.  Either disconnect or not depending\n\t\t * on the state of NO_DISCONNECT.\n\t\t */\n\t\ttest\tSEQ_FLAGS, NO_DISCONNECT jz target_disconnect; \n\t\tmvi\tTARG_IMMEDIATE_SCB, SCB_LIST_NULL;\n\t\tcall\tcomplete_target_cmd;\n\t\tif ((ahc->flags & AHC_PAGESCBS) != 0) {\n\t\t\tmov\tALLZEROS\tcall\tget_free_or_disc_scb;\n\t\t}\n\t\tcmp\tTARG_IMMEDIATE_SCB, SCB_LIST_NULL je .;\n\t\tmvi\tDMAPARAMS, HDMAEN|DIRECTION|FIFORESET;\n\t\tmov\tTARG_IMMEDIATE_SCB call dma_scb;\n\t\tcall\tset_transfer_settings;\n\t\tor\tSXFRCTL0, CLRSTCNT|CLRCHN;\n\t\tjmp\ttarget_synccmd;\n\ntarget_mesgout:\n\t\tmvi\tSCSISIGO, P_MESGOUT|BSYO;\ntarget_mesgout_continue:\n\t\tcall\ttarget_inb;\ntarget_mesgout_pending:\n\t\tand\tSEQ_FLAGS2, ~TARGET_MSG_PENDING;\n\t\t/* Local Processing goes here... */\n\t\tjmp\thost_target_message_loop;\n\t\t\ntarget_disconnect:\n\t\tmvi\tP_MESGIN|BSYO call change_phase;\n\t\ttest\tSEQ_FLAGS, DPHASE\tjz . + 2;\n\t\tmvi\tMSG_SAVEDATAPOINTER call target_outb;\n\t\tmvi\tMSG_DISCONNECT call target_outb;\n\ntarget_busfree_wait:\n\t\t/* Wait for preceding I/O session to complete. */\n\t\ttest\tSCSISIGI, ACKI jnz .;\ntarget_busfree:\n\t\tand\tSIMODE1, ~ENBUSFREE;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tclr\tSCSIBUSL;\n\t\t}\n\t\tclr\tSCSISIGO;\n\t\tmvi\tLASTPHASE, P_BUSFREE;\n\t\tcall\tcomplete_target_cmd;\n\t\tjmp\tpoll_for_work;\n\ntarget_cmdphase:\n\t\t/*\n\t\t * The target has dropped ATN (doesn't want to abort or BDR)\n\t\t * and we believe this selection to be valid.  If the ring\n\t\t * buffer for new commands is full, return busy or queue full.\n\t\t */\n\t\tif ((ahc->features & AHC_HS_MAILBOX) != 0) {\n\t\t\tand\tA, HOST_TQINPOS, HS_MAILBOX;\n\t\t} else {\n\t\t\tmov\tA, KERNEL_TQINPOS;\n\t\t}\n\t\tcmp\tTQINPOS, A jne tqinfifo_has_space;\n\t\tmvi\tP_STATUS|BSYO call change_phase;\n\t\ttest\tSEQ_FLAGS, TARGET_CMD_IS_TAGGED jz . + 3;\n\t\tmvi\tSTATUS_QUEUE_FULL call target_outb;\n\t\tjmp\ttarget_busfree_wait;\n\t\tmvi\tSTATUS_BUSY call target_outb;\n\t\tjmp\ttarget_busfree_wait;\ntqinfifo_has_space:\t\n\t\tmvi\tP_COMMAND|BSYO call change_phase;\n\t\tcall\ttarget_inb;\n\t\tmov\tA, DINDEX;\n\t\t/* Store for host */\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\tmov\tCCSCBRAM, A;\n\t\t} else {\n\t\t\tmov\tDFDAT, A;\n\t\t}\n\n\t\t/*\n\t\t * Determine the number of bytes to read\n\t\t * based on the command group code via table lookup.\n\t\t * We reuse the first 8 bytes of the TARG_SCSIRATE\n\t\t * BIOS array for this table. Count is one less than\n\t\t * the total for the command since we've already fetched\n\t\t * the first byte.\n\t\t */\n\t\tshr\tA, CMD_GROUP_CODE_SHIFT;\n\t\tadd\tSINDEX, CMDSIZE_TABLE, A;\n\t\tmov\tA, SINDIR;\n\n\t\ttest\tA, 0xFF jz command_phase_done;\n\t\tor\tSXFRCTL0, SPIOEN;\ncommand_loop:\n\t\ttest\tSSTAT0, SPIORDY jz .;\n\t\tcmp\tA, 1 jne . + 2;\n\t\tand\tSXFRCTL0, ~SPIOEN;\t/* Last Byte */\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\tmov\tCCSCBRAM, SCSIDATL;\n\t\t} else {\n\t\t\tmov\tDFDAT, SCSIDATL;\n\t\t}\n\t\tdec\tA;\n\t\ttest\tA, 0xFF jnz command_loop;\n\ncommand_phase_done:\n\t\tand\tSEQ_FLAGS, ~CMDPHASE_PENDING;\n\t\tjmp\ttarget_ITloop;\n\ntarget_dphase:\n\t\t/*\n\t\t * Data phases on the bus are from the\n\t\t * perspective of the initiator.  The dma\n\t\t * code looks at LASTPHASE to determine the\n\t\t * data direction of the DMA.  Toggle it for\n\t\t * target transfers.\n\t\t */\n\t\txor\tLASTPHASE, IOI, SCB_TARGET_DATA_DIR;\n\t\tor\tSCB_TARGET_DATA_DIR, BSYO call change_phase;\n\t\tjmp\tp_data;\n\ntarget_sphase:\n\t\tmvi\tP_STATUS|BSYO call change_phase;\n\t\tmvi\tLASTPHASE, P_STATUS;\n\t\tmov\tSCB_SCSI_STATUS call target_outb;\n\t\t/* XXX Watch for ATN or parity errors??? */\n\t\tmvi\tSCSISIGO, P_MESGIN|BSYO;\n\t\t/* MSG_CMDCMPLT is 0, but we can't do an immediate of 0 */\n\t\tmov\tALLZEROS call target_outb;\n\t\tjmp\ttarget_busfree_wait;\n\t\ncomplete_target_cmd:\n\t\ttest\tSEQ_FLAGS, TARG_CMD_PENDING\tjnz . + 2;\n\t\tmov\tSCB_TAG jmp complete_post;\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\t/* Set the valid byte */\n\t\t\tmvi\tCCSCBADDR, 24;\n\t\t\tmov\tCCSCBRAM, ALLONES;\n\t\t\tmvi\tCCHCNT, 28;\n\t\t\tor\tCCSCBCTL, CCSCBEN|CCSCBRESET;\n\t\t\ttest\tCCSCBCTL, CCSCBDONE jz .;\n\t\t\tclr\tCCSCBCTL;\n\t\t} else {\n\t\t\t/* Set the valid byte */\n\t\t\tor\tDFCNTRL, FIFORESET;\n\t\t\tmvi\tDFWADDR, 3; /* Third 64bit word or byte 24 */\n\t\t\tmov\tDFDAT, ALLONES;\n\t\t\tmvi\t28\tcall set_hcnt;\n\t\t\tor\tDFCNTRL, HDMAEN|FIFOFLUSH;\n\t\t\tcall\tdma_finish;\n\t\t}\n\t\tinc\tTQINPOS;\n\t\tmvi\tINTSTAT,CMDCMPLT ret;\n\t}\n\nif ((ahc->flags & AHC_INITIATORROLE) != 0) {\ninitiator_select:\n\tor\tSXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;\n\t/*\n\t * As soon as we get a successful selection, the target\n\t * should go into the message out phase since we have ATN\n\t * asserted.\n\t */\n\tmvi\tMSG_OUT, MSG_IDENTIFYFLAG;\n\tmvi\tSEQ_FLAGS, NO_CDB_SENT;\n\tmvi\tCLRSINT0, CLRSELDO;\n\n\t/*\n\t * Main loop for information transfer phases.  Wait for the\n\t * target to assert REQ before checking MSG, C/D and I/O for\n\t * the bus phase.\n\t */\nmesgin_phasemis:\nITloop:\n\tcall\tphase_lock;\n\n\tmov\tA, LASTPHASE;\n\n\ttest\tA, ~P_DATAIN\tjz p_data;\n\tcmp\tA,P_COMMAND\tje p_command;\n\tcmp\tA,P_MESGOUT\tje p_mesgout;\n\tcmp\tA,P_STATUS\tje p_status;\n\tcmp\tA,P_MESGIN\tje p_mesgin;\n\n\tmvi\tBAD_PHASE call set_seqint;\n\tjmp\tITloop;\t\t\t/* Try reading the bus again. */\n\nawait_busfree:\n\tand\tSIMODE1, ~ENBUSFREE;\n\tmov\tNONE, SCSIDATL;\t\t/* Ack the last byte */\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tclr\tSCSIBUSL;\t/* Prevent bit leakage durint SELTO */\n\t}\n\tand\tSXFRCTL0, ~SPIOEN;\n\tmvi\tSEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT;\n\ttest\tSSTAT1,REQINIT|BUSFREE\tjz .;\n\ttest\tSSTAT1, BUSFREE jnz poll_for_work;\n\tmvi\tMISSED_BUSFREE call set_seqint;\n}\n\t\nclear_target_state:\n\t/*\n\t * We assume that the kernel driver may reset us\n\t * at any time, even in the middle of a DMA, so\n\t * clear DFCNTRL too.\n\t */\n\tclr\tDFCNTRL;\n\tor\tSXFRCTL0, CLRSTCNT|CLRCHN;\n\n\t/*\n\t * We don't know the target we will connect to,\n\t * so default to narrow transfers to avoid\n\t * parity problems.\n\t */\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbmov\tSCSIRATE, ALLZEROS, 2;\n\t} else {\n\t\tclr\tSCSIRATE;\n\t\tif ((ahc->features & AHC_ULTRA) != 0) {\n\t\t\tand\tSXFRCTL0, ~(FAST20);\n\t\t}\n\t}\n\tmvi\tLASTPHASE, P_BUSFREE;\n\t/* clear target specific flags */\n\tmvi\tSEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT ret;\n\nsg_advance:\n\tclr\tA;\t\t\t/* add sizeof(struct scatter) */\n\tadd\tSCB_RESIDUAL_SGPTR[0],SG_SIZEOF;\n\tadc\tSCB_RESIDUAL_SGPTR[1],A;\n\tadc\tSCB_RESIDUAL_SGPTR[2],A;\n\tadc\tSCB_RESIDUAL_SGPTR[3],A ret;\n\nif ((ahc->features & AHC_CMD_CHAN) != 0) {\ndisable_ccsgen:\n\ttest\tCCSGCTL, CCSGEN jz return;\n\ttest\tCCSGCTL, CCSGDONE jz .;\ndisable_ccsgen_fetch_done:\n\tclr\tCCSGCTL;\n\ttest\tCCSGCTL, CCSGEN jnz .;\n\tret;\nidle_loop:\n\t/*\n\t * Do we need any more segments for this transfer?\n\t */\n\ttest\tSCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jnz return;\n\n\t/* Did we just finish fetching segs? */\n\tcmp\tCCSGCTL, CCSGEN|CCSGDONE je idle_sgfetch_complete;\n\n\t/* Are we actively fetching segments? */\n\ttest\tCCSGCTL, CCSGEN jnz return;\n\n\t/*\n\t * Do we have any prefetch left???\n\t */\n\tcmp\tCCSGADDR, SG_PREFETCH_CNT jne idle_sg_avail;\n\n\t/*\n\t * Need to fetch segments, but we can only do that\n\t * if the command channel is completely idle.  Make\n\t * sure we don't have an SCB prefetch going on.\n\t */\n\ttest\tCCSCBCTL, CCSCBEN jnz return;\n\n\t/*\n\t * We fetch a \"cacheline aligned\" and sized amount of data\n\t * so we don't end up referencing a non-existent page.\n\t * Cacheline aligned is in quotes because the kernel will\n\t * set the prefetch amount to a reasonable level if the\n\t * cacheline size is unknown.\n\t */\n\tmvi\tCCHCNT, SG_PREFETCH_CNT;\n\tand\tCCHADDR[0], SG_PREFETCH_ALIGN_MASK, SCB_RESIDUAL_SGPTR;\n\tbmov\tCCHADDR[1], SCB_RESIDUAL_SGPTR[1], 3;\n\tmvi\tCCSGCTL, CCSGEN|CCSGRESET ret;\nidle_sgfetch_complete:\n\tcall\tdisable_ccsgen_fetch_done;\n\tand\tCCSGADDR, SG_PREFETCH_ADDR_MASK, SCB_RESIDUAL_SGPTR;\nidle_sg_avail:\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t/* Does the hardware have space for another SG entry? */\n\t\ttest\tDFSTATUS, PRELOAD_AVAIL jz return;\n\t\tbmov \tHADDR, CCSGRAM, 7;\n\t\tbmov\tSCB_RESIDUAL_DATACNT[3], CCSGRAM, 1;\n\t\tif ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {\n\t\t\tmov\tSCB_RESIDUAL_DATACNT[3] call set_hhaddr;\n\t\t}\n\t\tcall\tsg_advance;\n\t\tmov\tSINDEX, SCB_RESIDUAL_SGPTR[0];\n\t\ttest\tSCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;\n\t\tor\tSINDEX, LAST_SEG;\n\t\tmov\tSG_CACHE_PRE, SINDEX;\n\t\t/* Load the segment */\n\t\tor\tDFCNTRL, PRELOADEN;\n\t}\n\tret;\n}\n\nif ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {\n/*\n * Calculate the trailing portion of this S/G segment that cannot\n * be transferred using memory write and invalidate PCI transactions.  \n * XXX Can we optimize this for PCI writes only???\n */\ncalc_mwi_residual:\n\t/*\n\t * If the ending address is on a cacheline boundary,\n\t * there is no need for an extra segment.\n\t */\n\tmov\tA, HCNT[0];\n\tadd\tA, A, HADDR[0];\n\tand\tA, CACHESIZE_MASK;\n\ttest\tA, 0xFF jz return;\n\n\t/*\n\t * If the transfer is less than a cachline,\n\t * there is no need for an extra segment.\n\t */\n\ttest\tHCNT[1], 0xFF\tjnz calc_mwi_residual_final;\n\ttest\tHCNT[2], 0xFF\tjnz calc_mwi_residual_final;\n\tadd\tNONE, INVERTED_CACHESIZE_MASK, HCNT[0];\n\tjnc\treturn;\n\ncalc_mwi_residual_final:\n\tmov\tMWI_RESIDUAL, A;\n\tnot\tA;\n\tinc\tA;\n\tadd\tHCNT[0], A;\n\tadc\tHCNT[1], -1;\n\tadc\tHCNT[2], -1 ret;\n}\n\np_data:\n\ttest\tSEQ_FLAGS,NOT_IDENTIFIED|NO_CDB_SENT jz p_data_allowed;\n\tmvi\tPROTO_VIOLATION call set_seqint;\np_data_allowed:\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmvi\tDMAPARAMS, PRELOADEN|SCSIEN|HDMAEN;\n\t} else {\n\t\tmvi\tDMAPARAMS, WIDEODD|SCSIEN|SDMAEN|HDMAEN|FIFORESET;\n\t}\n\ttest\tLASTPHASE, IOI jnz . + 2;\n\tor\tDMAPARAMS, DIRECTION;\n\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t/* We don't have any valid S/G elements */\n\t\tmvi\tCCSGADDR, SG_PREFETCH_CNT;\n\t}\n\ttest\tSEQ_FLAGS, DPHASE\tjz data_phase_initialize;\n\n\t/*\n\t * If we re-enter the data phase after going through another\n\t * phase, our transfer location has almost certainly been\n\t * corrupted by the interveining, non-data, transfers.  Ask\n\t * the host driver to fix us up based on the transfer residual.\n\t */\n\tmvi\tPDATA_REINIT\tcall set_seqint;\n\tjmp\tdata_phase_loop;\n\ndata_phase_initialize:\n\t/* We have seen a data phase for the first time */\n\tor\tSEQ_FLAGS, DPHASE;\n\n\t/*\n\t * Initialize the DMA address and counter from the SCB.\n\t * Also set SCB_RESIDUAL_SGPTR, including the LAST_SEG\n\t * flag in the highest byte of the data count.  We cannot\n\t * modify the saved values in the SCB until we see a save\n\t * data pointers message.\n\t */\n\tif ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {\n\t\t/* The lowest address byte must be loaded last. */\n\t\tmov\tSCB_DATACNT[3] call set_hhaddr;\n\t}\n\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\tbmov\tHADDR, SCB_DATAPTR, 7;\n\t\tbmov\tSCB_RESIDUAL_DATACNT[3], SCB_DATACNT[3], 5;\n\t} else {\n\t\tmvi\tDINDEX, HADDR;\n\t\tmvi\tSCB_DATAPTR\tcall bcopy_7;\n\t\tmvi\tDINDEX, SCB_RESIDUAL_DATACNT + 3;\n\t\tmvi\tSCB_DATACNT + 3 call bcopy_5;\n\t}\n\tif ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {\n\t\tcall\tcalc_mwi_residual;\n\t}\n\tand\tSCB_RESIDUAL_SGPTR[0], ~SG_FULL_RESID;\n\n\tif ((ahc->features & AHC_ULTRA2) == 0) {\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\tbmov\tSTCNT, HCNT, 3;\n\t\t} else {\n\t\t\tcall\tset_stcnt_from_hcnt;\n\t\t}\n\t}\n\ndata_phase_loop:\n\t/* Guard against overruns */\n\ttest\tSCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz data_phase_inbounds;\n\n\t/*\n\t * Turn on `Bit Bucket' mode, wait until the target takes\n\t * us to another phase, and then notify the host.\n\t */\n\tand\tDMAPARAMS, DIRECTION;\n\tmov\tDFCNTRL, DMAPARAMS;\n\tor\tSXFRCTL1,BITBUCKET;\n\tif ((ahc->features & AHC_DT) == 0) {\n\t\ttest\tSSTAT1,PHASEMIS\tjz .;\n\t} else {\n\t\ttest\tSCSIPHASE, DATA_PHASE_MASK jnz .;\n\t}\n\tand\tSXFRCTL1, ~BITBUCKET;\n\tmvi\tDATA_OVERRUN call set_seqint;\n\tjmp\tITloop;\n\ndata_phase_inbounds:\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmov\tSINDEX, SCB_RESIDUAL_SGPTR[0];\n\t\ttest\tSCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;\n\t\tor\tSINDEX, LAST_SEG;\n\t\tmov\tSG_CACHE_PRE, SINDEX;\n\t\tmov\tDFCNTRL, DMAPARAMS;\nultra2_dma_loop:\n\t\tcall\tidle_loop;\n\t\t/*\n\t\t * The transfer is complete if either the last segment\n\t\t * completes or the target changes phase.\n\t\t */\n\t\ttest\tSG_CACHE_SHADOW, LAST_SEG_DONE jnz ultra2_dmafinish;\n\t\tif ((ahc->features & AHC_DT) == 0) {\n\t\t\tif ((ahc->flags & AHC_TARGETROLE) != 0) {\n\t\t\t\t /*\n\t\t\t\t  * As a target, we control the phases,\n\t\t\t\t  * so ignore PHASEMIS.\n\t\t\t\t  */\n\t\t\t\ttest\tSSTAT0, TARGET jnz ultra2_dma_loop;\n\t\t\t}\n\t\t\tif ((ahc->flags & AHC_INITIATORROLE) != 0) {\n\t\t\t\ttest\tSSTAT1,PHASEMIS\tjz ultra2_dma_loop;\n\t\t\t}\n\t\t} else {\n\t\t\ttest\tDFCNTRL, SCSIEN jnz ultra2_dma_loop;\n\t\t}\n\nultra2_dmafinish:\n\t\t/*\n\t\t * The transfer has terminated either due to a phase\n\t\t * change, and/or the completion of the last segment.\n\t\t * We have two goals here.  Do as much other work\n\t\t * as possible while the data fifo drains on a read\n\t\t * and respond as quickly as possible to the standard\n\t\t * messages (save data pointers/disconnect and command\n\t\t * complete) that usually follow a data phase.\n\t\t */\n\t\tif ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {\n\t\t\t/*\n\t\t\t * On chips with broken auto-flush, start\n\t\t\t * the flushing process now.  We'll poke\n\t\t\t * the chip from time to time to keep the\n\t\t\t * flush process going as we complete the\n\t\t\t * data phase.\n\t\t\t */\n\t\t\tor\tDFCNTRL, FIFOFLUSH;\n\t\t}\n\t\t/*\n\t\t * We assume that, even though data may still be\n\t\t * transferring to the host, that the SCSI side of\n\t\t * the DMA engine is now in a static state.  This\n\t\t * allows us to update our notion of where we are\n\t\t * in this transfer.\n\t\t *\n\t\t * If, by chance, we stopped before being able\n\t\t * to fetch additional segments for this transfer,\n\t\t * yet the last S/G was completely exhausted,\n\t\t * call our idle loop until it is able to load\n\t\t * another segment.  This will allow us to immediately\n\t\t * pickup on the next segment on the next data phase.\n\t\t *\n\t\t * If we happened to stop on the last segment, then\n\t\t * our residual information is still correct from\n\t\t * the idle loop and there is no need to perform\n\t\t * any fixups.\n\t\t */\nultra2_ensure_sg:\n\t\ttest\tSG_CACHE_SHADOW, LAST_SEG jz ultra2_shvalid;\n\t\t/* Record if we've consumed all S/G entries */\n\t\ttest\tSSTAT2, SHVALID\tjnz residuals_correct;\n\t\tor\tSCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;\n\t\tjmp\tresiduals_correct;\n\nultra2_shvalid:\n\t\ttest\tSSTAT2, SHVALID\tjnz sgptr_fixup;\n\t\tcall\tidle_loop;\n\t\tjmp\tultra2_ensure_sg;\n\nsgptr_fixup:\n\t\t/*\n\t\t * Fixup the residual next S/G pointer.  The S/G preload\n\t\t * feature of the chip allows us to load two elements\n\t\t * in addition to the currently active element.  We\n\t\t * store the bottom byte of the next S/G pointer in\n\t\t * the SG_CACEPTR register so we can restore the\n\t\t * correct value when the DMA completes.  If the next\n\t\t * sg ptr value has advanced to the point where higher\n\t\t * bytes in the address have been affected, fix them\n\t\t * too.\n\t\t */\n\t\ttest\tSG_CACHE_SHADOW, 0x80 jz sgptr_fixup_done;\n\t\ttest\tSCB_RESIDUAL_SGPTR[0], 0x80 jnz sgptr_fixup_done;\n\t\tadd\tSCB_RESIDUAL_SGPTR[1], -1;\n\t\tadc\tSCB_RESIDUAL_SGPTR[2], -1; \n\t\tadc\tSCB_RESIDUAL_SGPTR[3], -1;\nsgptr_fixup_done:\n\t\tand\tSCB_RESIDUAL_SGPTR[0], SG_ADDR_MASK, SG_CACHE_SHADOW;\n\t\t/* We are not the last seg */\n\t\tand\tSCB_RESIDUAL_DATACNT[3], ~SG_LAST_SEG;\nresiduals_correct:\n\t\t/*\n\t\t * Go ahead and shut down the DMA engine now.\n\t\t * In the future, we'll want to handle end of\n\t\t * transfer messages prior to doing this, but this\n\t\t * requires similar restructuring for pre-ULTRA2\n\t\t * controllers.\n\t\t */\n\t\ttest\tDMAPARAMS, DIRECTION jnz ultra2_fifoempty;\nultra2_fifoflush:\n\t\tif ((ahc->features & AHC_DT) == 0) {\n\t\t\tif ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {\n\t\t\t\t/*\n\t\t\t\t * On Rev A of the aic7890, the autoflush\n\t\t\t\t * feature doesn't function correctly.\n\t\t\t\t * Perform an explicit manual flush.  During\n\t\t\t\t * a manual flush, the FIFOEMP bit becomes\n\t\t\t\t * true every time the PCI FIFO empties\n\t\t\t\t * regardless of the state of the SCSI FIFO.\n\t\t\t\t * It can take up to 4 clock cycles for the\n\t\t\t\t * SCSI FIFO to get data into the PCI FIFO\n\t\t\t\t * and for FIFOEMP to de-assert.  Here we\n\t\t\t\t * guard against this condition by making\n\t\t\t\t * sure the FIFOEMP bit stays on for 5 full\n\t\t\t\t * clock cycles.\n\t\t\t\t */\n\t\t\t\tor\tDFCNTRL, FIFOFLUSH;\n\t\t\t\ttest\tDFSTATUS, FIFOEMP jz ultra2_fifoflush;\n\t\t\t\ttest\tDFSTATUS, FIFOEMP jz ultra2_fifoflush;\n\t\t\t\ttest\tDFSTATUS, FIFOEMP jz ultra2_fifoflush;\n\t\t\t\ttest\tDFSTATUS, FIFOEMP jz ultra2_fifoflush;\n\t\t\t}\n\t\t\ttest\tDFSTATUS, FIFOEMP jz ultra2_fifoflush;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We enable the auto-ack feature on DT capable\n\t\t\t * controllers.  This means that the controller may\n\t\t\t * have already transferred some overrun bytes into\n\t\t\t * the data FIFO and acked them on the bus.  The only\n\t\t\t * way to detect this situation is to wait for\n\t\t\t * LAST_SEG_DONE to come true on a completed transfer\n\t\t\t * and then test to see if the data FIFO is non-empty.\n\t\t\t */\n\t\t\ttest\tSCB_RESIDUAL_SGPTR[0], SG_LIST_NULL\n\t\t\t\tjz ultra2_wait_fifoemp;\n\t\t\ttest\tSG_CACHE_SHADOW, LAST_SEG_DONE jz .;\n\t\t\t/*\n\t\t\t * FIFOEMP can lag LAST_SEG_DONE.  Wait a few\n\t\t\t * clocks before calling this an overrun.\n\t\t\t */\n\t\t\ttest\tDFSTATUS, FIFOEMP jnz ultra2_fifoempty;\n\t\t\ttest\tDFSTATUS, FIFOEMP jnz ultra2_fifoempty;\n\t\t\ttest\tDFSTATUS, FIFOEMP jnz ultra2_fifoempty;\n\t\t\t/* Overrun */\n\t\t\tjmp\tdata_phase_loop;\nultra2_wait_fifoemp:\n\t\t\ttest\tDFSTATUS, FIFOEMP jz .;\n\t\t}\nultra2_fifoempty:\n\t\t/* Don't clobber an inprogress host data transfer */\n\t\ttest\tDFSTATUS, MREQPEND\tjnz ultra2_fifoempty;\nultra2_dmahalt:\n\t\tand     DFCNTRL, ~(SCSIEN|HDMAEN);\n\t\ttest\tDFCNTRL, SCSIEN|HDMAEN jnz .;\n\t\tif ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {\n\t\t\t/*\n\t\t\t * Keep HHADDR cleared for future, 32bit addressed\n\t\t\t * only, DMA operations.\n\t\t\t *\n\t\t\t * Due to bayonette style S/G handling, our residual\n\t\t\t * data must be \"fixed up\" once the transfer is halted.\n\t\t\t * Here we fixup the HSHADDR stored in the high byte\n\t\t\t * of the residual data cnt.  By postponing the fixup,\n\t\t\t * we can batch the clearing of HADDR with the fixup.\n\t\t\t * If we halted on the last segment, the residual is\n\t\t\t * already correct.   If we are not on the last\n\t\t\t * segment, copy the high address directly from HSHADDR.\n\t\t\t * We don't need to worry about maintaining the\n\t\t\t * SG_LAST_SEG flag as it will always be false in the\n\t\t\t * case where an update is required.\n\t\t\t */\n\t\t\tor\tDSCOMMAND1, HADDLDSEL0;\n\t\t\ttest\tSG_CACHE_SHADOW, LAST_SEG jnz . + 2;\n\t\t\tmov\tSCB_RESIDUAL_DATACNT[3], SHADDR;\n\t\t\tclr\tHADDR;\n\t\t\tand\tDSCOMMAND1, ~HADDLDSEL0;\n\t\t}\n\t} else {\n\t\t/* If we are the last SG block, tell the hardware. */\n\t\tif ((ahc->bugs & AHC_PCI_MWI_BUG) != 0\n\t\t  && ahc->pci_cachesize != 0) {\n\t\t\ttest\tMWI_RESIDUAL, 0xFF jnz dma_mid_sg;\n\t\t}\n\t\ttest\tSCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz dma_mid_sg;\n\t\tif ((ahc->flags & AHC_TARGETROLE) != 0) {\n\t\t\ttest\tSSTAT0, TARGET jz dma_last_sg;\n\t\t\tif ((ahc->bugs & AHC_TMODE_WIDEODD_BUG) != 0) {\n\t\t\t\ttest\tDMAPARAMS, DIRECTION jz dma_mid_sg;\n\t\t\t}\n\t\t}\ndma_last_sg:\n\t\tand\tDMAPARAMS, ~WIDEODD;\ndma_mid_sg:\n\t\t/* Start DMA data transfer. */\n\t\tmov\tDFCNTRL, DMAPARAMS;\ndma_loop:\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\tcall\tidle_loop;\n\t\t}\n\t\ttest\tSSTAT0,DMADONE\tjnz dma_dmadone;\n\t\ttest\tSSTAT1,PHASEMIS\tjz dma_loop;\t/* ie. underrun */\ndma_phasemis:\n\t\t/*\n\t\t * We will be \"done\" DMAing when the transfer count goes to\n\t\t * zero, or the target changes the phase (in light of this,\n\t\t * it makes sense that the DMA circuitry doesn't ACK when\n\t\t * PHASEMIS is active).  If we are doing a SCSI->Host transfer,\n\t\t * the data FIFO should be flushed auto-magically on STCNT=0\n\t\t * or a phase change, so just wait for FIFO empty status.\n\t\t */\ndma_checkfifo:\n\t\ttest\tDFCNTRL,DIRECTION\tjnz dma_fifoempty;\ndma_fifoflush:\n\t\ttest\tDFSTATUS,FIFOEMP\tjz dma_fifoflush;\ndma_fifoempty:\n\t\t/* Don't clobber an inprogress host data transfer */\n\t\ttest\tDFSTATUS, MREQPEND\tjnz dma_fifoempty;\n\n\t\t/*\n\t\t * Now shut off the DMA and make sure that the DMA\n\t\t * hardware has actually stopped.  Touching the DMA\n\t\t * counters, etc. while a DMA is active will result\n\t\t * in an ILLSADDR exception.\n\t\t */\ndma_dmadone:\n\t\tand\tDFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);\ndma_halt:\n\t\t/*\n\t\t * Some revisions of the aic78XX have a problem where, if the\n\t\t * data fifo is full, but the PCI input latch is not empty, \n\t\t * HDMAEN cannot be cleared.  The fix used here is to drain\n\t\t * the prefetched but unused data from the data fifo until\n\t\t * there is space for the input latch to drain.\n\t\t */\n\t\tif ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {\n\t\t\tmov\tNONE, DFDAT;\n\t\t}\n\t\ttest\tDFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz dma_halt;\n\n\t\t/* See if we have completed this last segment */\n\t\ttest\tSTCNT[0], 0xff\tjnz data_phase_finish;\n\t\ttest\tSTCNT[1], 0xff\tjnz data_phase_finish;\n\t\ttest\tSTCNT[2], 0xff\tjnz data_phase_finish;\n\n\t\t/*\n\t\t * Advance the scatter-gather pointers if needed \n\t\t */\n\t\tif ((ahc->bugs & AHC_PCI_MWI_BUG) != 0\n\t\t  && ahc->pci_cachesize != 0) {\n\t\t\ttest\tMWI_RESIDUAL, 0xFF jz no_mwi_resid;\n\t\t\t/*\n\t\t\t * Reload HADDR from SHADDR and setup the\n\t\t\t * count to be the size of our residual.\n\t\t\t */\n\t\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\t\tbmov\tHADDR, SHADDR, 4;\n\t\t\t\tmov\tHCNT, MWI_RESIDUAL;\n\t\t\t\tbmov\tHCNT[1], ALLZEROS, 2;\n\t\t\t} else {\n\t\t\t\tmvi\tDINDEX, HADDR;\n\t\t\t\tmvi\tSHADDR call bcopy_4;\n\t\t\t\tmov\tMWI_RESIDUAL call set_hcnt;\n\t\t\t}\n\t\t\tclr\tMWI_RESIDUAL;\n\t\t\tjmp\tsg_load_done;\nno_mwi_resid:\n\t\t}\n\t\ttest\tSCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz sg_load;\n\t\tor\tSCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;\n\t\tjmp\tdata_phase_finish;\nsg_load:\n\t\t/*\n\t\t * Load the next SG element's data address and length\n\t\t * into the DMA engine.  If we don't have hardware\n\t\t * to perform a prefetch, we'll have to fetch the\n\t\t * segment from host memory first.\n\t\t */\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\t/* Wait for the idle loop to complete */\n\t\t\ttest\tCCSGCTL, CCSGEN jz . + 3;\n\t\t\tcall\tidle_loop;\n\t\t\ttest\tCCSGCTL, CCSGEN jnz . - 1;\n\t\t\tbmov \tHADDR, CCSGRAM, 7;\n\t\t\t/*\n\t\t\t * Workaround for flaky external SCB RAM\n\t\t\t * on certain aic7895 setups.  It seems\n\t\t\t * unable to handle direct transfers from\n\t\t\t * S/G ram to certain SCB locations.\n\t\t\t */\n\t\t\tmov\tSINDEX, CCSGRAM;\n\t\t\tmov\tSCB_RESIDUAL_DATACNT[3], SINDEX;\n\t\t} else {\n\t\t\tif ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {\n\t\t\t\tmov\tALLZEROS call set_hhaddr;\n\t\t\t}\n\t\t\tmvi\tDINDEX, HADDR;\n\t\t\tmvi\tSCB_RESIDUAL_SGPTR\tcall bcopy_4;\n\n\t\t\tmvi\tSG_SIZEOF\tcall set_hcnt;\n\n\t\t\tor\tDFCNTRL, HDMAEN|DIRECTION|FIFORESET;\n\n\t\t\tcall\tdma_finish;\n\n\t\t\tmvi\tDINDEX, HADDR;\n\t\t\tcall\tdfdat_in_7;\n\t\t\tmov\tSCB_RESIDUAL_DATACNT[3], DFDAT;\n\t\t}\n\n\t\tif ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {\n\t\t\tmov\tSCB_RESIDUAL_DATACNT[3] call set_hhaddr;\n\n\t\t\t/*\n\t\t\t * The lowest address byte must be loaded\n\t\t\t * last as it triggers the computation of\n\t\t\t * some items in the PCI block.  The ULTRA2\n\t\t\t * chips do this on PRELOAD.\n\t\t\t */\n\t\t\tmov\tHADDR, HADDR;\n\t\t}\n\t\tif ((ahc->bugs & AHC_PCI_MWI_BUG) != 0\n\t\t  && ahc->pci_cachesize != 0) {\n\t\t\tcall calc_mwi_residual;\n\t\t}\n\n\t\t/* Point to the new next sg in memory */\n\t\tcall\tsg_advance;\n\nsg_load_done:\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\tbmov\tSTCNT, HCNT, 3;\n\t\t} else {\n\t\t\tcall\tset_stcnt_from_hcnt;\n\t\t}\n\n\t\tif ((ahc->flags & AHC_TARGETROLE) != 0) {\n\t\t\ttest\tSSTAT0, TARGET jnz data_phase_loop;\n\t\t}\n\t}\ndata_phase_finish:\n\t/*\n\t * If the target has left us in data phase, loop through\n\t * the dma code again.  In the case of ULTRA2 adapters,\n\t * we should only loop if there is a data overrun.  For\n\t * all other adapters, we'll loop after each S/G element\n\t * is loaded as well as if there is an overrun.\n\t */\n\tif ((ahc->flags & AHC_TARGETROLE) != 0) {\n\t\ttest\tSSTAT0, TARGET jnz data_phase_done;\n\t}\n\tif ((ahc->flags & AHC_INITIATORROLE) != 0) {\n\t\ttest\tSSTAT1, REQINIT jz .;\n\t\tif ((ahc->features & AHC_DT) == 0) {\n\t\t\ttest\tSSTAT1,PHASEMIS\tjz data_phase_loop;\n\t\t} else {\n\t\t\ttest\tSCSIPHASE, DATA_PHASE_MASK jnz data_phase_loop;\n\t\t}\n\t}\n\ndata_phase_done:\n\t/*\n\t * After a DMA finishes, save the SG and STCNT residuals back into\n\t * the SCB.  We use STCNT instead of HCNT, since it's a reflection\n\t * of how many bytes were transferred on the SCSI (as opposed to the\n\t * host) bus.\n\t */\n\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t/* Kill off any pending prefetch */\n\t\tcall\tdisable_ccsgen;\n\t}\n\n\tif ((ahc->features & AHC_ULTRA2) == 0) {\n\t\t/*\n\t\t * Clear the high address byte so that all other DMA\n\t\t * operations, which use 32bit addressing, can assume\n\t\t * HHADDR is 0.\n\t\t */\n\t\tif ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {\n\t\t\tmov\tALLZEROS call set_hhaddr;\n\t\t}\n\t}\n\n\t/*\n\t * Update our residual information before the information is\n\t * lost by some other type of SCSI I/O (e.g. PIO).  If we have\n\t * transferred all data, no update is needed.\n\t *\n\t */\n\ttest\tSCB_RESIDUAL_SGPTR, SG_LIST_NULL jnz residual_update_done;\n\tif ((ahc->bugs & AHC_PCI_MWI_BUG) != 0\n\t  && ahc->pci_cachesize != 0) {\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\ttest\tMWI_RESIDUAL, 0xFF jz bmov_resid;\n\t\t}\n\t\tmov\tA, MWI_RESIDUAL;\n\t\tadd\tSCB_RESIDUAL_DATACNT[0], A, STCNT[0];\n\t\tclr\tA;\n\t\tadc\tSCB_RESIDUAL_DATACNT[1], A, STCNT[1];\n\t\tadc\tSCB_RESIDUAL_DATACNT[2], A, STCNT[2];\n\t\tclr\tMWI_RESIDUAL;\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\tjmp\t. + 2;\nbmov_resid:\n\t\t\tbmov\tSCB_RESIDUAL_DATACNT, STCNT, 3;\n\t\t}\n\t} else if ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\tbmov\tSCB_RESIDUAL_DATACNT, STCNT, 3;\n\t} else {\n\t\tmov\tSCB_RESIDUAL_DATACNT[0], STCNT[0];\n\t\tmov\tSCB_RESIDUAL_DATACNT[1], STCNT[1];\n\t\tmov\tSCB_RESIDUAL_DATACNT[2], STCNT[2];\n\t}\nresidual_update_done:\n\t/*\n\t * Since we've been through a data phase, the SCB_RESID* fields\n\t * are now initialized.  Clear the full residual flag.\n\t */\n\tand\tSCB_SGPTR[0], ~SG_FULL_RESID;\n\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t/* Clear the channel in case we return to data phase later */\n\t\tor\tSXFRCTL0, CLRSTCNT|CLRCHN;\n\t\tor\tSXFRCTL0, CLRSTCNT|CLRCHN;\n\t}\n\n\tif ((ahc->flags & AHC_TARGETROLE) != 0) {\n\t\ttest\tSEQ_FLAGS, DPHASE_PENDING jz ITloop;\n\t\tand\tSEQ_FLAGS, ~DPHASE_PENDING;\n\t\t/*\n\t\t * For data-in phases, wait for any pending acks from the\n\t\t * initiator before changing phase.  We only need to\n\t\t * send Ignore Wide Residue messages for data-in phases.\n\t\t */\n\t\ttest\tDFCNTRL, DIRECTION jz target_ITloop;\n\t\ttest\tSSTAT1, REQINIT\tjnz .;\n\t\ttest\tSCB_LUN, SCB_XFERLEN_ODD jz target_ITloop;\n\t\ttest\tSCSIRATE, WIDEXFER jz target_ITloop;\n\t\t/*\n\t\t * Issue an Ignore Wide Residue Message.\n\t\t */\n\t\tmvi\tP_MESGIN|BSYO call change_phase;\n\t\tmvi\tMSG_IGN_WIDE_RESIDUE call target_outb;\n\t\tmvi\t1 call target_outb;\n\t\tjmp\ttarget_ITloop;\n\t} else {\n\t\tjmp\tITloop;\n\t}\n\nif ((ahc->flags & AHC_INITIATORROLE) != 0) {\n/*\n * Command phase.  Set up the DMA registers and let 'er rip.\n */\np_command:\n\ttest\tSEQ_FLAGS, NOT_IDENTIFIED jz p_command_okay;\n\tmvi\tPROTO_VIOLATION call set_seqint;\np_command_okay:\n\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbmov\tHCNT[0], SCB_CDB_LEN,  1;\n\t\tbmov\tHCNT[1], ALLZEROS, 2;\n\t\tmvi\tSG_CACHE_PRE, LAST_SEG;\n\t} else if ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\tbmov\tSTCNT[0], SCB_CDB_LEN, 1;\n\t\tbmov\tSTCNT[1], ALLZEROS, 2;\n\t} else {\n\t\tmov\tSTCNT[0], SCB_CDB_LEN;\n\t\tclr\tSTCNT[1];\n\t\tclr\tSTCNT[2];\n\t}\n\tadd\tNONE, -13, SCB_CDB_LEN;\n\tmvi\tSCB_CDB_STORE jnc p_command_embedded;\np_command_from_host:\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbmov\tHADDR[0], SCB_CDB_PTR, 4;\n\t\tmvi\tDFCNTRL, (PRELOADEN|SCSIEN|HDMAEN|DIRECTION);\n\t} else {\n\t\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t\tbmov\tHADDR[0], SCB_CDB_PTR, 4;\n\t\t\tbmov\tHCNT, STCNT, 3;\n\t\t} else {\n\t\t\tmvi\tDINDEX, HADDR;\n\t\t\tmvi\tSCB_CDB_PTR call bcopy_4;\n\t\t\tmov\tSCB_CDB_LEN call set_hcnt;\n\t\t}\n\t\tmvi\tDFCNTRL, (SCSIEN|SDMAEN|HDMAEN|DIRECTION|FIFORESET);\n\t}\n\tjmp\tp_command_xfer;\np_command_embedded:\n\t/*\n\t * The data fifo seems to require 4 byte aligned\n\t * transfers from the sequencer.  Force this to\n\t * be the case by clearing HADDR[0] even though\n\t * we aren't going to touch host memory.\n\t */\n\tclr\tHADDR[0];\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmvi\tDFCNTRL, (PRELOADEN|SCSIEN|DIRECTION);\n\t\tbmov\tDFDAT, SCB_CDB_STORE, 12; \n\t} else if ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\tif ((ahc->flags & AHC_SCB_BTT) != 0) {\n\t\t\t/*\n\t\t\t * On the 7895 the data FIFO will\n\t\t\t * get corrupted if you try to dump\n\t\t\t * data from external SCB memory into\n\t\t\t * the FIFO while it is enabled.  So,\n\t\t\t * fill the fifo and then enable SCSI\n\t\t\t * transfers.\n\t\t\t */\n\t\t\tmvi\tDFCNTRL, (DIRECTION|FIFORESET);\n\t\t} else {\n\t\t\tmvi\tDFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFORESET);\n\t\t}\n\t\tbmov\tDFDAT, SCB_CDB_STORE, 12; \n\t\tif ((ahc->flags & AHC_SCB_BTT) != 0) {\n\t\t\tmvi\tDFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFOFLUSH);\n\t\t} else {\n\t\t\tor\tDFCNTRL, FIFOFLUSH;\n\t\t}\n\t} else {\n\t\tmvi\tDFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFORESET);\n\t\tcall\tcopy_to_fifo_6;\n\t\tcall\tcopy_to_fifo_6;\n\t\tor\tDFCNTRL, FIFOFLUSH;\n\t}\np_command_xfer:\n\tand\tSEQ_FLAGS, ~NO_CDB_SENT;\n\tif ((ahc->features & AHC_DT) == 0) {\n\t\ttest\tSSTAT0, SDONE jnz . + 2;\n\t\ttest    SSTAT1, PHASEMIS jz . - 1;\n\t\t/*\n\t\t * Wait for our ACK to go-away on it's own\n\t\t * instead of being killed by SCSIEN getting cleared.\n\t\t */\n\t\ttest\tSCSISIGI, ACKI jnz .;\n\t} else {\n\t\ttest\tDFCNTRL, SCSIEN jnz .;\n\t}\n\ttest\tSSTAT0, SDONE jnz p_command_successful;\n\t/*\n\t * Don't allow a data phase if the command\n\t * was not fully transferred.\n\t */\n\tor\tSEQ_FLAGS, NO_CDB_SENT;\np_command_successful:\n\tand\tDFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);\n\ttest\tDFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz .;\n\tjmp\tITloop;\n\n/*\n * Status phase.  Wait for the data byte to appear, then read it\n * and store it into the SCB.\n */\np_status:\n\ttest\tSEQ_FLAGS, NOT_IDENTIFIED jnz mesgin_proto_violation;\np_status_okay:\n\tmov\tSCB_SCSI_STATUS, SCSIDATL;\n\tor\tSCB_CONTROL, STATUS_RCVD;\n\tjmp\tITloop;\n\n/*\n * Message out phase.  If MSG_OUT is MSG_IDENTIFYFLAG, build a full\n * indentify message sequence and send it to the target.  The host may\n * override this behavior by setting the MK_MESSAGE bit in the SCB\n * control byte.  This will cause us to interrupt the host and allow\n * it to handle the message phase completely on its own.  If the bit\n * associated with this target is set, we will also interrupt the host,\n * thereby allowing it to send a message on the next selection regardless\n * of the transaction being sent.\n * \n * If MSG_OUT is == HOST_MSG, also interrupt the host and take a message.\n * This is done to allow the host to send messages outside of an identify\n * sequence while protecting the seqencer from testing the MK_MESSAGE bit\n * on an SCB that might not be for the current nexus. (For example, a\n * BDR message in response to a bad reselection would leave us pointed to\n * an SCB that doesn't have anything to do with the current target).\n *\n * Otherwise, treat MSG_OUT as a 1 byte message to send (abort, abort tag,\n * bus device reset).\n *\n * When there are no messages to send, MSG_OUT should be set to MSG_NOOP,\n * in case the target decides to put us in this phase for some strange\n * reason.\n */\np_mesgout_retry:\n\t/* Turn on ATN for the retry */\n\tif ((ahc->features & AHC_DT) == 0) {\n\t\tor\tSCSISIGO, ATNO, LASTPHASE;\n\t} else {\n\t\tmvi\tSCSISIGO, ATNO;\n\t}\np_mesgout:\n\tmov\tSINDEX, MSG_OUT;\n\tcmp\tSINDEX, MSG_IDENTIFYFLAG jne p_mesgout_from_host;\n\ttest\tSCB_CONTROL,MK_MESSAGE\tjnz host_message_loop;\np_mesgout_identify:\n\tor\tSINDEX, MSG_IDENTIFYFLAG|DISCENB, SAVED_LUN;\n\ttest\tSCB_CONTROL, DISCENB jnz . + 2;\n\tand\tSINDEX, ~DISCENB;\n/*\n * Send a tag message if TAG_ENB is set in the SCB control block.\n * Use SCB_TAG (the position in the kernel's SCB array) as the tag value.\n */\np_mesgout_tag:\n\ttest\tSCB_CONTROL,TAG_ENB jz  p_mesgout_onebyte;\n\tmov\tSCSIDATL, SINDEX;\t/* Send the identify message */\n\tcall\tphase_lock;\n\tcmp\tLASTPHASE, P_MESGOUT\tjne p_mesgout_done;\n\tand\tSCSIDATL,TAG_ENB|SCB_TAG_TYPE,SCB_CONTROL;\n\tcall\tphase_lock;\n\tcmp\tLASTPHASE, P_MESGOUT\tjne p_mesgout_done;\n\tmov\tSCB_TAG\tjmp p_mesgout_onebyte;\n/*\n * Interrupt the driver, and allow it to handle this message\n * phase and any required retries.\n */\np_mesgout_from_host:\n\tcmp\tSINDEX, HOST_MSG\tjne p_mesgout_onebyte;\n\tjmp\thost_message_loop;\n\np_mesgout_onebyte:\n\tmvi\tCLRSINT1, CLRATNO;\n\tmov\tSCSIDATL, SINDEX;\n\n/*\n * If the next bus phase after ATN drops is message out, it means\n * that the target is requesting that the last message(s) be resent.\n */\n\tcall\tphase_lock;\n\tcmp\tLASTPHASE, P_MESGOUT\tje p_mesgout_retry;\n\np_mesgout_done:\n\tmvi\tCLRSINT1,CLRATNO;\t/* Be sure to turn ATNO off */\n\tmov\tLAST_MSG, MSG_OUT;\n\tmvi\tMSG_OUT, MSG_NOOP;\t/* No message left */\n\tjmp\tITloop;\n\n/*\n * Message in phase.  Bytes are read using Automatic PIO mode.\n */\np_mesgin:\n\tmvi\tACCUM\t\tcall inb_first;\t/* read the 1st message byte */\n\n\ttest\tA,MSG_IDENTIFYFLAG\tjnz mesgin_identify;\n\tcmp\tA,MSG_DISCONNECT\tje mesgin_disconnect;\n\tcmp\tA,MSG_SAVEDATAPOINTER\tje mesgin_sdptrs;\n\tcmp\tALLZEROS,A\t\tje mesgin_complete;\n\tcmp\tA,MSG_RESTOREPOINTERS\tje mesgin_rdptrs;\n\tcmp\tA,MSG_IGN_WIDE_RESIDUE\tje mesgin_ign_wide_residue;\n\tcmp\tA,MSG_NOOP\t\tje mesgin_done;\n\n/*\n * Pushed message loop to allow the kernel to\n * run it's own message state engine.  To avoid an\n * extra nop instruction after signaling the kernel,\n * we perform the phase_lock before checking to see\n * if we should exit the loop and skip the phase_lock\n * in the ITloop.  Performing back to back phase_locks\n * shouldn't hurt, but why do it twice...\n */\nhost_message_loop:\n\tmvi\tHOST_MSG_LOOP call set_seqint;\n\tcall\tphase_lock;\n\tcmp\tRETURN_1, EXIT_MSG_LOOP\tje ITloop + 1;\n\tjmp\thost_message_loop;\n\nmesgin_ign_wide_residue:\nif ((ahc->features & AHC_WIDE) != 0) {\n\ttest\tSCSIRATE, WIDEXFER jz mesgin_reject;\n\t/* Pull the residue byte */\n\tmvi\tARG_1\tcall inb_next;\n\tcmp\tARG_1, 0x01 jne mesgin_reject;\n\ttest\tSCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 2;\n\ttest\tSCB_LUN, SCB_XFERLEN_ODD jnz mesgin_done;\n\tmvi\tIGN_WIDE_RES call set_seqint;\n\tjmp\tmesgin_done;\n}\n\nmesgin_proto_violation:\n\tmvi\tPROTO_VIOLATION call set_seqint;\n\tjmp\tmesgin_done;\nmesgin_reject:\n\tmvi\tMSG_MESSAGE_REJECT\tcall mk_mesg;\nmesgin_done:\n\tmov\tNONE,SCSIDATL;\t\t/*dummy read from latch to ACK*/\n\tjmp\tITloop;\n\n/*\n * We received a \"command complete\" message.  Put the SCB_TAG into the QOUTFIFO,\n * and trigger a completion interrupt.  Before doing so, check to see if there\n * is a residual or the status byte is something other than STATUS_GOOD (0).\n * In either of these conditions, we upload the SCB back to the host so it can\n * process this information.  In the case of a non zero status byte, we \n * additionally interrupt the kernel driver synchronously, allowing it to\n * decide if sense should be retrieved.  If the kernel driver wishes to request\n * sense, it will fill the kernel SCB with a request sense command, requeue\n * it to the QINFIFO and tell us not to post to the QOUTFIFO by setting \n * RETURN_1 to SEND_SENSE.\n */\nmesgin_complete:\n\n\t/*\n\t * If ATN is raised, we still want to give the target a message.\n\t * Perhaps there was a parity error on this last message byte.\n\t * Either way, the target should take us to message out phase\n\t * and then attempt to complete the command again.  We should use a\n\t * critical section here to guard against a timeout triggering\n\t * for this command and setting ATN while we are still processing\n\t * the completion.\n\ttest\tSCSISIGI, ATNI jnz mesgin_done;\n\t */\n\n\t/*\n\t * If we are identified and have successfully sent the CDB,\n\t * any status will do.  Optimize this fast path.\n\t */\n\ttest\tSCB_CONTROL, STATUS_RCVD jz mesgin_proto_violation;\n\ttest\tSEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT jz complete_accepted; \n\n\t/*\n\t * If the target never sent an identify message but instead went\n\t * to mesgin to give an invalid message, let the host abort us.\n\t */\n\ttest\tSEQ_FLAGS, NOT_IDENTIFIED jnz mesgin_proto_violation;\n\n\t/*\n\t * If we recevied good status but never successfully sent the\n\t * cdb, abort the command.\n\t */\n\ttest\tSCB_SCSI_STATUS,0xff\tjnz complete_accepted;\n\ttest\tSEQ_FLAGS, NO_CDB_SENT jnz mesgin_proto_violation;\n\ncomplete_accepted:\n\t/*\n\t * See if we attempted to deliver a message but the target ingnored us.\n\t */\n\ttest\tSCB_CONTROL, MK_MESSAGE jz . + 2;\n\tmvi\tMKMSG_FAILED call set_seqint;\n\n\t/*\n\t * Check for residuals\n\t */\n\ttest\tSCB_SGPTR, SG_LIST_NULL jnz check_status;/* No xfer */\n\ttest\tSCB_SGPTR, SG_FULL_RESID jnz upload_scb;/* Never xfered */\n\ttest\tSCB_RESIDUAL_SGPTR, SG_LIST_NULL jz upload_scb;\ncheck_status:\n\ttest\tSCB_SCSI_STATUS,0xff\tjz complete;\t/* Good Status? */\nupload_scb:\n\tor\tSCB_SGPTR, SG_RESID_VALID;\n\tmvi\tDMAPARAMS, FIFORESET;\n\tmov\tSCB_TAG\t\tcall dma_scb;\n\ttest\tSCB_SCSI_STATUS, 0xff\tjz complete;\t/* Just a residual? */\n\tmvi\tBAD_STATUS call set_seqint;\t\t/* let driver know */\n\tcmp\tRETURN_1, SEND_SENSE\tjne complete;\n\tcall\tadd_scb_to_free_list;\n\tjmp\tawait_busfree;\ncomplete:\n\tmov\tSCB_TAG call complete_post;\n\tjmp\tawait_busfree;\n}\n\ncomplete_post:\n\t/* Post the SCBID in SINDEX and issue an interrupt */\n\tcall\tadd_scb_to_free_list;\n\tmov\tARG_1, SINDEX;\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tmov\tA, SDSCB_QOFF;\n\t} else {\n\t\tmov\tA, QOUTPOS;\n\t}\n\tmvi\tQOUTFIFO_OFFSET call post_byte_setup;\n\tmov\tARG_1 call post_byte;\n\tif ((ahc->features & AHC_QUEUE_REGS) == 0) {\n\t\tinc \tQOUTPOS;\n\t}\n\tmvi\tINTSTAT,CMDCMPLT ret;\n\nif ((ahc->flags & AHC_INITIATORROLE) != 0) {\n/*\n * Is it a disconnect message?  Set a flag in the SCB to remind us\n * and await the bus going free.  If this is an untagged transaction\n * store the SCB id for it in our untagged target table for lookup on\n * a reselection.\n */\nmesgin_disconnect:\n\t/*\n\t * If ATN is raised, we still want to give the target a message.\n\t * Perhaps there was a parity error on this last message byte\n\t * or we want to abort this command.  Either way, the target\n\t * should take us to message out phase and then attempt to\n\t * disconnect again.\n\t * XXX - Wait for more testing.\n\ttest\tSCSISIGI, ATNI jnz mesgin_done;\n\t */\n\ttest\tSEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT\n\t\tjnz mesgin_proto_violation;\n\tor\tSCB_CONTROL,DISCONNECTED;\n\tif ((ahc->flags & AHC_PAGESCBS) != 0) {\n\t\tcall\tadd_scb_to_disc_list;\n\t}\n\ttest\tSCB_CONTROL, TAG_ENB jnz await_busfree;\n\tmov\tARG_1, SCB_TAG;\n\tand\tSAVED_LUN, LID, SCB_LUN;\n\tmov\tSCB_SCSIID\tcall set_busy_target;\n\tjmp\tawait_busfree;\n\n/*\n * Save data pointers message:\n * Copying RAM values back to SCB, for Save Data Pointers message, but\n * only if we've actually been into a data phase to change them.  This\n * protects against bogus data in scratch ram and the residual counts\n * since they are only initialized when we go into data_in or data_out.\n * Ack the message as soon as possible.  For chips without S/G pipelining,\n * we can only ack the message after SHADDR has been saved.  On these\n * chips, SHADDR increments with every bus transaction, even PIO.\n */\nmesgin_sdptrs:\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmov\tNONE,SCSIDATL;\t\t/*dummy read from latch to ACK*/\n\t\ttest\tSEQ_FLAGS, DPHASE\tjz ITloop;\n\t} else {\n\t\ttest\tSEQ_FLAGS, DPHASE\tjz mesgin_done;\n\t}\n\n\t/*\n\t * If we are asked to save our position at the end of the\n\t * transfer, just mark us at the end rather than perform a\n\t * full save.\n\t */\n\ttest\tSCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz mesgin_sdptrs_full;\n\tor\tSCB_SGPTR, SG_LIST_NULL;\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tjmp\tITloop;\n\t} else {\n\t\tjmp\tmesgin_done;\n\t}\n\nmesgin_sdptrs_full:\n\n\t/*\n\t * The SCB_SGPTR becomes the next one we'll download,\n\t * and the SCB_DATAPTR becomes the current SHADDR.\n\t * Use the residual number since STCNT is corrupted by\n\t * any message transfer.\n\t */\n\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\tbmov\tSCB_DATAPTR, SHADDR, 4;\n\t\tif ((ahc->features & AHC_ULTRA2) == 0) {\n\t\t\tmov\tNONE,SCSIDATL;\t/*dummy read from latch to ACK*/\n\t\t}\n\t\tbmov\tSCB_DATACNT, SCB_RESIDUAL_DATACNT, 8;\n\t} else {\n\t\tmvi\tDINDEX, SCB_DATAPTR;\n\t\tmvi\tSHADDR call bcopy_4;\n\t\tmov\tNONE,SCSIDATL;\t/*dummy read from latch to ACK*/\n\t\tmvi\tSCB_RESIDUAL_DATACNT call bcopy_8;\n\t}\n\tjmp\tITloop;\n\n/*\n * Restore pointers message?  Data pointers are recopied from the\n * SCB anytime we enter a data phase for the first time, so all\n * we need to do is clear the DPHASE flag and let the data phase\n * code do the rest.  We also reset/reallocate the FIFO to make\n * sure we have a clean start for the next data or command phase.\n */\nmesgin_rdptrs:\n\tand\tSEQ_FLAGS, ~DPHASE;\t\t/*\n\t\t\t\t\t\t * We'll reload them\n\t\t\t\t\t\t * the next time through\n\t\t\t\t\t\t * the dataphase.\n\t\t\t\t\t\t */\n\tor\tSXFRCTL0, CLRSTCNT|CLRCHN;\n\tjmp\tmesgin_done;\n\n/*\n * Index into our Busy Target table.  SINDEX and DINDEX are modified\n * upon return.  SCBPTR may be modified by this action.\n */\nset_busy_target:\n\tshr\tDINDEX, 4, SINDEX;\n\tif ((ahc->flags & AHC_SCB_BTT) != 0) {\n\t\tmov\tSCBPTR, SAVED_LUN;\n\t\tadd\tDINDEX, SCB_64_BTT;\n\t} else {\n\t\tadd\tDINDEX, BUSY_TARGETS;\n\t}\n\tmov\tDINDIR, ARG_1 ret;\n\n/*\n * Identify message?  For a reconnecting target, this tells us the lun\n * that the reconnection is for - find the correct SCB and switch to it,\n * clearing the \"disconnected\" bit so we don't \"find\" it by accident later.\n */\nmesgin_identify:\n\t/*\n\t * Determine whether a target is using tagged or non-tagged\n\t * transactions by first looking at the transaction stored in\n\t * the busy target array.  If there is no untagged transaction\n\t * for this target or the transaction is for a different lun, then\n\t * this must be a tagged transaction.\n\t */\n\tshr\tSINDEX, 4, SAVED_SCSIID;\n\tand\tSAVED_LUN, MSG_IDENTIFY_LUNMASK, A;\n\tif ((ahc->flags & AHC_SCB_BTT) != 0) {\n\t\tadd\tSINDEX, SCB_64_BTT;\n\t\tmov\tSCBPTR, SAVED_LUN;\n\t\tif ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {\n\t\t\tadd\tNONE, -SCB_64_BTT, SINDEX;\n\t\t\tjc\t. + 2;\n\t\t\tmvi\tINTSTAT, OUT_OF_RANGE;\n\t\t\tnop;\n\t\t\tadd\tNONE, -(SCB_64_BTT + 16), SINDEX;\n\t\t\tjnc\t. + 2;\n\t\t\tmvi\tINTSTAT, OUT_OF_RANGE;\n\t\t\tnop;\n\t\t}\n\t} else {\n\t\tadd\tSINDEX, BUSY_TARGETS;\n\t\tif ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {\n\t\t\tadd\tNONE, -BUSY_TARGETS, SINDEX;\n\t\t\tjc\t. + 2;\n\t\t\tmvi\tINTSTAT, OUT_OF_RANGE;\n\t\t\tnop;\n\t\t\tadd\tNONE, -(BUSY_TARGETS + 16), SINDEX;\n\t\t\tjnc\t. + 2;\n\t\t\tmvi\tINTSTAT, OUT_OF_RANGE;\n\t\t\tnop;\n\t\t}\n\t}\n\tmov\tARG_1, SINDIR;\n\tcmp\tARG_1, SCB_LIST_NULL\tje snoop_tag;\n\tif ((ahc->flags & AHC_PAGESCBS) != 0) {\n\t\tmov\tARG_1 call findSCB;\n\t} else {\n\t\tmov\tSCBPTR, ARG_1;\n\t}\n\tif ((ahc->flags & AHC_SCB_BTT) != 0) {\n\t\tjmp setup_SCB_id_lun_okay;\n\t} else {\n\t\t/*\n\t\t * We only allow one untagged command per-target\n\t\t * at a time.  So, if the lun doesn't match, look\n\t\t * for a tag message.\n\t\t */\n\t\tand\tA, LID, SCB_LUN;\n\t\tcmp\tSAVED_LUN, A\tje setup_SCB_id_lun_okay;\n\t\tif ((ahc->flags & AHC_PAGESCBS) != 0) {\n\t\t\t/*\n\t\t\t * findSCB removes the SCB from the\n\t\t\t * disconnected list, so we must replace\n\t\t\t * it there should this SCB be for another\n\t\t\t * lun.\n\t\t\t */\n\t\t\tcall\tcleanup_scb;\n\t\t}\n\t}\n\n/*\n * Here we \"snoop\" the bus looking for a SIMPLE QUEUE TAG message.\n * If we get one, we use the tag returned to find the proper\n * SCB.  With SCB paging, we must search for non-tagged\n * transactions since the SCB may exist in any slot.  If we're not\n * using SCB paging, we can use the tag as the direct index to the\n * SCB.\n */\nsnoop_tag:\n\tif ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {\n\t\tor\tSEQ_FLAGS, 0x80;\n\t}\n\tmov\tNONE,SCSIDATL;\t\t/* ACK Identify MSG */\n\tcall\tphase_lock;\n\tif ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {\n\t\tor\tSEQ_FLAGS, 0x1;\n\t}\n\tcmp\tLASTPHASE, P_MESGIN\tjne not_found;\n\tif ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {\n\t\tor\tSEQ_FLAGS, 0x2;\n\t}\n\tcmp\tSCSIBUSL,MSG_SIMPLE_Q_TAG jne not_found;\nget_tag:\n\tif ((ahc->flags & AHC_PAGESCBS) != 0) {\n\t\tmvi\tARG_1\tcall inb_next;\t/* tag value */\n\t\tmov\tARG_1\tcall findSCB;\n\t} else {\n\t\tmvi\tARG_1\tcall inb_next;\t/* tag value */\n\t\tmov\tSCBPTR, ARG_1;\n\t}\n\n/*\n * Ensure that the SCB the tag points to is for\n * an SCB transaction to the reconnecting target.\n */\nsetup_SCB:\n\tif ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {\n\t\tor\tSEQ_FLAGS, 0x4;\n\t}\n\tmov\tA, SCB_SCSIID;\n\tcmp\tSAVED_SCSIID, A\tjne not_found_cleanup_scb;\n\tif ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {\n\t\tor\tSEQ_FLAGS, 0x8;\n\t}\nsetup_SCB_id_okay:\n\tand\tA, LID, SCB_LUN;\n\tcmp\tSAVED_LUN, A\tjne not_found_cleanup_scb;\nsetup_SCB_id_lun_okay:\n\tif ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {\n\t\tor\tSEQ_FLAGS, 0x10;\n\t}\n\ttest\tSCB_CONTROL,DISCONNECTED jz not_found_cleanup_scb;\n\tand\tSCB_CONTROL,~DISCONNECTED;\n\ttest\tSCB_CONTROL, TAG_ENB\tjnz setup_SCB_tagged;\n\tif ((ahc->flags & AHC_SCB_BTT) != 0) {\n\t\tmov\tA, SCBPTR;\n\t}\n\tmvi\tARG_1, SCB_LIST_NULL;\n\tmov\tSAVED_SCSIID\tcall\tset_busy_target;\n\tif ((ahc->flags & AHC_SCB_BTT) != 0) {\n\t\tmov\tSCBPTR, A;\n\t}\nsetup_SCB_tagged:\n\tclr\tSEQ_FLAGS;\t/* make note of IDENTIFY */\n\tcall\tset_transfer_settings;\n\t/* See if the host wants to send a message upon reconnection */\n\ttest\tSCB_CONTROL, MK_MESSAGE jz mesgin_done;\n\tmvi\tHOST_MSG\tcall mk_mesg;\n\tjmp\tmesgin_done;\n\nnot_found_cleanup_scb:\n\tif ((ahc->flags & AHC_PAGESCBS) != 0) {\n\t\tcall\tcleanup_scb;\n\t}\nnot_found:\n\tmvi\tNO_MATCH call set_seqint;\n\tjmp\tmesgin_done;\n\nmk_mesg:\n\tif ((ahc->features & AHC_DT) == 0) {\n\t\tor\tSCSISIGO, ATNO, LASTPHASE;\n\t} else {\n\t\tmvi\tSCSISIGO, ATNO;\n\t}\n\tmov\tMSG_OUT,SINDEX ret;\n\n/*\n * Functions to read data in Automatic PIO mode.\n *\n * According to Adaptec's documentation, an ACK is not sent on input from\n * the target until SCSIDATL is read from.  So we wait until SCSIDATL is\n * latched (the usual way), then read the data byte directly off the bus\n * using SCSIBUSL.  When we have pulled the ATN line, or we just want to\n * acknowledge the byte, then we do a dummy read from SCISDATL.  The SCSI\n * spec guarantees that the target will hold the data byte on the bus until\n * we send our ACK.\n *\n * The assumption here is that these are called in a particular sequence,\n * and that REQ is already set when inb_first is called.  inb_{first,next}\n * use the same calling convention as inb.\n */\ninb_next_wait_perr:\n\tmvi\tPERR_DETECTED call set_seqint;\n\tjmp\tinb_next_wait;\ninb_next:\n\tmov\tNONE,SCSIDATL;\t\t/*dummy read from latch to ACK*/\ninb_next_wait:\n\t/*\n\t * If there is a parity error, wait for the kernel to\n\t * see the interrupt and prepare our message response\n\t * before continuing.\n\t */\n\ttest\tSSTAT1, REQINIT\tjz inb_next_wait;\n\ttest\tSSTAT1, SCSIPERR jnz inb_next_wait_perr;\ninb_next_check_phase:\n\tand\tLASTPHASE, PHASE_MASK, SCSISIGI;\n\tcmp\tLASTPHASE, P_MESGIN jne mesgin_phasemis;\ninb_first:\n\tmov\tDINDEX,SINDEX;\n\tmov\tDINDIR,SCSIBUSL\tret;\t\t/*read byte directly from bus*/\ninb_last:\n\tmov\tNONE,SCSIDATL ret;\t\t/*dummy read from latch to ACK*/\n}\n\nif ((ahc->flags & AHC_TARGETROLE) != 0) {\n/*\n * Change to a new phase.  If we are changing the state of the I/O signal,\n * from out to in, wait an additional data release delay before continuing.\n */\nchange_phase:\n\t/* Wait for preceding I/O session to complete. */\n\ttest\tSCSISIGI, ACKI jnz .;\n\n\t/* Change the phase */\n\tand\tDINDEX, IOI, SCSISIGI;\n\tmov\tSCSISIGO, SINDEX;\n\tand\tA, IOI, SINDEX;\n\n\t/*\n\t * If the data direction has changed, from\n\t * out (initiator driving) to in (target driving),\n\t * we must wait at least a data release delay plus\n\t * the normal bus settle delay. [SCSI III SPI 10.11.0]\n\t */\n\tcmp \tDINDEX, A je change_phase_wait;\n\ttest\tSINDEX, IOI jz change_phase_wait;\n\tcall\tchange_phase_wait;\nchange_phase_wait:\n\tnop;\n\tnop;\n\tnop;\n\tnop ret;\n\n/*\n * Send a byte to an initiator in Automatic PIO mode.\n */\ntarget_outb:\n\tor\tSXFRCTL0, SPIOEN;\n\ttest\tSSTAT0, SPIORDY\tjz .;\n\tmov\tSCSIDATL, SINDEX;\n\ttest\tSSTAT0, SPIORDY\tjz .;\n\tand\tSXFRCTL0, ~SPIOEN ret;\n}\n\t\n/*\n * Locate a disconnected SCB by SCBID.  Upon return, SCBPTR and SINDEX will\n * be set to the position of the SCB.  If the SCB cannot be found locally,\n * it will be paged in from host memory.  RETURN_2 stores the address of the\n * preceding SCB in the disconnected list which can be used to speed up\n * removal of the found SCB from the disconnected list.\n */\nif ((ahc->flags & AHC_PAGESCBS) != 0) {\nBEGIN_CRITICAL;\nfindSCB:\n\tmov\tA, SINDEX;\t\t\t/* Tag passed in SINDEX */\n\tcmp\tDISCONNECTED_SCBH, SCB_LIST_NULL je findSCB_notFound;\n\tmov\tSCBPTR, DISCONNECTED_SCBH;\t/* Initialize SCBPTR */\n\tmvi\tARG_2, SCB_LIST_NULL;\t\t/* Head of list */\n\tjmp\tfindSCB_loop;\nfindSCB_next:\n\tcmp\tSCB_NEXT, SCB_LIST_NULL je findSCB_notFound;\n\tmov\tARG_2, SCBPTR;\n\tmov\tSCBPTR,SCB_NEXT;\nfindSCB_loop:\n\tcmp\tSCB_TAG, A\tjne findSCB_next;\nrem_scb_from_disc_list:\n\tcmp\tARG_2, SCB_LIST_NULL\tje rHead;\n\tmov\tDINDEX, SCB_NEXT;\n\tmov\tSINDEX, SCBPTR;\n\tmov\tSCBPTR, ARG_2;\n\tmov\tSCB_NEXT, DINDEX;\n\tmov\tSCBPTR, SINDEX ret;\nrHead:\n\tmov\tDISCONNECTED_SCBH,SCB_NEXT ret;\nEND_CRITICAL;\nfindSCB_notFound:\n\t/*\n\t * We didn't find it.  Page in the SCB.\n\t */\n\tmov\tARG_1, A; /* Save tag */\n\tmov\tALLZEROS call get_free_or_disc_scb;\n\tmvi\tDMAPARAMS, HDMAEN|DIRECTION|FIFORESET;\n\tmov\tARG_1\tjmp dma_scb;\n}\n\n/*\n * Prepare the hardware to post a byte to host memory given an\n * index of (A + (256 * SINDEX)) and a base address of SHARED_DATA_ADDR.\n */\npost_byte_setup:\n\tmov\tARG_2, SINDEX;\n\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\tmvi\tDINDEX, CCHADDR;\n\t\tmvi\tSHARED_DATA_ADDR call\tset_1byte_addr;\n\t\tmvi\tCCHCNT, 1;\n\t\tmvi\tCCSCBCTL, CCSCBRESET ret;\n\t} else {\n\t\tmvi\tDINDEX, HADDR;\n\t\tmvi\tSHARED_DATA_ADDR call\tset_1byte_addr;\n\t\tmvi\t1\tcall set_hcnt;\n\t\tmvi\tDFCNTRL, FIFORESET ret;\n\t}\n\npost_byte:\n\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\tbmov\tCCSCBRAM, SINDEX, 1;\n\t\tor\tCCSCBCTL, CCSCBEN|CCSCBRESET;\n\t\ttest\tCCSCBCTL, CCSCBDONE jz .;\n\t\tclr\tCCSCBCTL ret;\n\t} else {\n\t\tmov\tDFDAT, SINDEX;\n\t\tor\tDFCNTRL, HDMAEN|FIFOFLUSH;\n\t\tjmp\tdma_finish;\n\t}\n\nphase_lock_perr:\n\tmvi\tPERR_DETECTED call set_seqint;\nphase_lock:     \n\t/*\n\t * If there is a parity error, wait for the kernel to\n\t * see the interrupt and prepare our message response\n\t * before continuing.\n\t */\n\ttest\tSSTAT1, REQINIT jz phase_lock;\n\ttest\tSSTAT1, SCSIPERR jnz phase_lock_perr;\nphase_lock_latch_phase:\n\tif ((ahc->features & AHC_DT) == 0) {\n\t\tand\tSCSISIGO, PHASE_MASK, SCSISIGI;\n\t}\n\tand\tLASTPHASE, PHASE_MASK, SCSISIGI ret;\n\nif ((ahc->features & AHC_CMD_CHAN) == 0) {\nset_hcnt:\n\tmov\tHCNT[0], SINDEX;\nclear_hcnt:\n\tclr\tHCNT[1];\n\tclr\tHCNT[2] ret;\n\nset_stcnt_from_hcnt:\n\tmov\tSTCNT[0], HCNT[0];\n\tmov\tSTCNT[1], HCNT[1];\n\tmov\tSTCNT[2], HCNT[2] ret;\n\nbcopy_8:\n\tmov\tDINDIR, SINDIR;\nbcopy_7:\n\tmov\tDINDIR, SINDIR;\n\tmov\tDINDIR, SINDIR;\nbcopy_5:\n\tmov\tDINDIR, SINDIR;\nbcopy_4:\n\tmov\tDINDIR, SINDIR;\nbcopy_3:\n\tmov\tDINDIR, SINDIR;\n\tmov\tDINDIR, SINDIR;\n\tmov\tDINDIR, SINDIR ret;\n}\n\nif ((ahc->flags & AHC_TARGETROLE) != 0) {\n/*\n * Setup addr assuming that A is an index into\n * an array of 32byte objects, SINDEX contains\n * the base address of that array, and DINDEX\n * contains the base address of the location\n * to store the indexed address.\n */\nset_32byte_addr:\n\tshr\tARG_2, 3, A;\n\tshl\tA, 5;\n\tjmp\tset_1byte_addr;\n}\n\n/*\n * Setup addr assuming that A is an index into\n * an array of 64byte objects, SINDEX contains\n * the base address of that array, and DINDEX\n * contains the base address of the location\n * to store the indexed address.\n */\nset_64byte_addr:\n\tshr\tARG_2, 2, A;\n\tshl\tA, 6;\n\n/*\n * Setup addr assuming that A + (ARG_2 * 256) is an\n * index into an array of 1byte objects, SINDEX contains\n * the base address of that array, and DINDEX contains\n * the base address of the location to store the computed\n * address.\n */\nset_1byte_addr:\n\tadd     DINDIR, A, SINDIR;\n\tmov     A, ARG_2;\n\tadc\tDINDIR, A, SINDIR;\n\tclr\tA;\n\tadc\tDINDIR, A, SINDIR;\n\tadc\tDINDIR, A, SINDIR ret;\n\n/*\n * Either post or fetch an SCB from host memory based on the\n * DIRECTION bit in DMAPARAMS. The host SCB index is in SINDEX.\n */\ndma_scb:\n\tmov\tA, SINDEX;\n\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\tmvi\tDINDEX, CCHADDR;\n\t\tmvi\tHSCB_ADDR call set_64byte_addr;\n\t\tmov\tCCSCBPTR, SCBPTR;\n\t\ttest\tDMAPARAMS, DIRECTION jz dma_scb_tohost;\n\t\tif ((ahc->flags & AHC_SCB_BTT) != 0) {\n\t\t\tmvi\tCCHCNT, SCB_DOWNLOAD_SIZE_64;\n\t\t} else {\n\t\t\tmvi\tCCHCNT, SCB_DOWNLOAD_SIZE;\n\t\t}\n\t\tmvi\tCCSCBCTL, CCARREN|CCSCBEN|CCSCBDIR|CCSCBRESET;\n\t\tcmp\tCCSCBCTL, CCSCBDONE|ARRDONE|CCARREN|CCSCBEN|CCSCBDIR jne .;\n\t\tjmp\tdma_scb_finish;\ndma_scb_tohost:\n\t\tmvi\tCCHCNT, SCB_UPLOAD_SIZE;\n\t\tif ((ahc->features & AHC_ULTRA2) == 0) {\n\t\t\tmvi\tCCSCBCTL, CCSCBRESET;\n\t\t\tbmov\tCCSCBRAM, SCB_BASE, SCB_UPLOAD_SIZE;\n\t\t\tor\tCCSCBCTL, CCSCBEN|CCSCBRESET;\n\t\t\ttest\tCCSCBCTL, CCSCBDONE jz .;\n\t\t} else if ((ahc->bugs & AHC_SCBCHAN_UPLOAD_BUG) != 0) {\n\t\t\tmvi\tCCSCBCTL, CCARREN|CCSCBRESET;\n\t\t\tcmp\tCCSCBCTL, ARRDONE|CCARREN jne .;\n\t\t\tmvi\tCCHCNT, SCB_UPLOAD_SIZE;\n\t\t\tmvi\tCCSCBCTL, CCSCBEN|CCSCBRESET;\n\t\t\tcmp\tCCSCBCTL, CCSCBDONE|CCSCBEN jne .;\n\t\t} else {\n\t\t\tmvi\tCCSCBCTL, CCARREN|CCSCBEN|CCSCBRESET;\n\t\t\tcmp\tCCSCBCTL, CCSCBDONE|ARRDONE|CCARREN|CCSCBEN jne .;\n\t\t}\ndma_scb_finish:\n\t\tclr\tCCSCBCTL;\n\t\ttest\tCCSCBCTL, CCARREN|CCSCBEN jnz .;\n\t\tret;\n\t} else {\n\t\tmvi\tDINDEX, HADDR;\n\t\tmvi\tHSCB_ADDR call set_64byte_addr;\n\t\tmvi\tSCB_DOWNLOAD_SIZE call set_hcnt;\n\t\tmov\tDFCNTRL, DMAPARAMS;\n\t\ttest\tDMAPARAMS, DIRECTION\tjnz dma_scb_fromhost;\n\t\t/* Fill it with the SCB data */\ncopy_scb_tofifo:\n\t\tmvi\tSINDEX, SCB_BASE;\n\t\tadd\tA, SCB_DOWNLOAD_SIZE, SINDEX;\ncopy_scb_tofifo_loop:\n\t\tcall\tcopy_to_fifo_8;\n\t\tcmp\tSINDEX, A jne copy_scb_tofifo_loop;\n\t\tor\tDFCNTRL, HDMAEN|FIFOFLUSH;\n\t\tjmp\tdma_finish;\ndma_scb_fromhost:\n\t\tmvi\tDINDEX, SCB_BASE;\n\t\tif ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {\n\t\t\t/*\n\t\t\t * The PCI module will only issue a PCI\n\t\t\t * retry if the data FIFO is empty.  If the\n\t\t\t * host disconnects in the middle of a\n\t\t\t * transfer, we must empty the fifo of all\n\t\t\t * available data to force the chip to\n\t\t\t * continue the transfer.  This does not\n\t\t\t * happen for SCSI transfers as the SCSI module\n\t\t\t * will drain the FIFO as data are made available.\n\t\t\t * When the hang occurs, we know that a multiple\n\t\t\t * of 8 bytes is in the FIFO because the PCI\n\t\t\t * module has an 8 byte input latch that only\n\t\t\t * dumps to the FIFO when HCNT == 0 or the\n\t\t\t * latch is full.\n\t\t\t */\n\t\t\tclr\tA;\n\t\t\t/* Wait for at least 8 bytes of data to arrive. */\ndma_scb_hang_fifo:\n\t\t\ttest\tDFSTATUS, FIFOQWDEMP jnz dma_scb_hang_fifo;\ndma_scb_hang_wait:\n\t\t\ttest\tDFSTATUS, MREQPEND jnz dma_scb_hang_wait;\n\t\t\ttest\tDFSTATUS, HDONE\tjnz dma_scb_hang_dma_done;\n\t\t\ttest\tDFSTATUS, HDONE\tjnz dma_scb_hang_dma_done;\n\t\t\ttest\tDFSTATUS, HDONE\tjnz dma_scb_hang_dma_done;\n\t\t\t/*\n\t\t\t * The PCI module no longer intends to perform\n\t\t\t * a PCI transaction.  Drain the fifo.\n\t\t\t */\ndma_scb_hang_dma_drain_fifo:\n\t\t\tnot\tA, HCNT;\n\t\t\tadd\tA, SCB_DOWNLOAD_SIZE+SCB_BASE+1;\n\t\t\tand\tA, ~0x7;\n\t\t\tmov\tDINDIR,DFDAT;\n\t\t\tcmp\tDINDEX, A jne . - 1;\n\t\t\tcmp\tDINDEX, SCB_DOWNLOAD_SIZE+SCB_BASE\n\t\t\t\tje\tdma_finish_nowait;\n\t\t\t/* Restore A as the lines left to transfer. */\n\t\t\tadd\tA, -SCB_BASE, DINDEX;\n\t\t\tshr\tA, 3;\n\t\t\tjmp\tdma_scb_hang_fifo;\ndma_scb_hang_dma_done:\n\t\t\tand\tDFCNTRL, ~HDMAEN;\n\t\t\ttest\tDFCNTRL, HDMAEN jnz .;\n\t\t\tadd\tSEQADDR0, A;\n\t\t} else {\n\t\t\tcall\tdma_finish;\n\t\t}\n\t\tcall\tdfdat_in_8;\n\t\tcall\tdfdat_in_8;\n\t\tcall\tdfdat_in_8;\ndfdat_in_8:\n\t\tmov\tDINDIR,DFDAT;\ndfdat_in_7:\n\t\tmov\tDINDIR,DFDAT;\n\t\tmov\tDINDIR,DFDAT;\n\t\tmov\tDINDIR,DFDAT;\n\t\tmov\tDINDIR,DFDAT;\n\t\tmov\tDINDIR,DFDAT;\ndfdat_in_2:\n\t\tmov\tDINDIR,DFDAT;\n\t\tmov\tDINDIR,DFDAT ret;\n\t}\n\ncopy_to_fifo_8:\n\tmov\tDFDAT,SINDIR;\n\tmov\tDFDAT,SINDIR;\ncopy_to_fifo_6:\n\tmov\tDFDAT,SINDIR;\ncopy_to_fifo_5:\n\tmov\tDFDAT,SINDIR;\ncopy_to_fifo_4:\n\tmov\tDFDAT,SINDIR;\n\tmov\tDFDAT,SINDIR;\n\tmov\tDFDAT,SINDIR;\n\tmov\tDFDAT,SINDIR ret;\n\n/*\n * Wait for DMA from host memory to data FIFO to complete, then disable\n * DMA and wait for it to acknowledge that it's off.\n */\ndma_finish:\n\ttest\tDFSTATUS,HDONE\tjz dma_finish;\ndma_finish_nowait:\n\t/* Turn off DMA */\n\tand\tDFCNTRL, ~HDMAEN;\n\ttest\tDFCNTRL, HDMAEN jnz .;\n\tret;\n\n/*\n * Restore an SCB that failed to match an incoming reselection\n * to the correct/safe state.  If the SCB is for a disconnected\n * transaction, it must be returned to the disconnected list.\n * If it is not in the disconnected state, it must be free.\n */\ncleanup_scb:\n\tif ((ahc->flags & AHC_PAGESCBS) != 0) {\n\t\ttest\tSCB_CONTROL,DISCONNECTED jnz add_scb_to_disc_list;\n\t}\nadd_scb_to_free_list:\n\tif ((ahc->flags & AHC_PAGESCBS) != 0) {\nBEGIN_CRITICAL;\n\t\tmov\tSCB_NEXT, FREE_SCBH;\n\t\tmvi\tSCB_TAG, SCB_LIST_NULL;\n\t\tmov\tFREE_SCBH, SCBPTR ret;\nEND_CRITICAL;\n\t} else {\n\t\tmvi\tSCB_TAG, SCB_LIST_NULL ret;\n\t}\n\nif ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {\nset_hhaddr:\n\tor\tDSCOMMAND1, HADDLDSEL0;\n\tand\tHADDR, SG_HIGH_ADDR_BITS, SINDEX;\n\tand\tDSCOMMAND1, ~HADDLDSEL0 ret;\n}\n\nif ((ahc->flags & AHC_PAGESCBS) != 0) {\nget_free_or_disc_scb:\nBEGIN_CRITICAL;\n\tcmp\tFREE_SCBH, SCB_LIST_NULL jne dequeue_free_scb;\n\tcmp\tDISCONNECTED_SCBH, SCB_LIST_NULL jne dequeue_disc_scb;\nreturn_error:\n\tmvi\tNO_FREE_SCB call set_seqint;\n\tmvi\tSINDEX, SCB_LIST_NULL\tret;\ndequeue_disc_scb:\n\tmov\tSCBPTR, DISCONNECTED_SCBH;\n\tmov\tDISCONNECTED_SCBH, SCB_NEXT;\nEND_CRITICAL;\n\tmvi\tDMAPARAMS, FIFORESET;\n\tmov\tSCB_TAG\tjmp dma_scb;\nBEGIN_CRITICAL;\ndequeue_free_scb:\n\tmov\tSCBPTR, FREE_SCBH;\n\tmov\tFREE_SCBH, SCB_NEXT ret;\nEND_CRITICAL;\n\nadd_scb_to_disc_list:\n/*\n * Link this SCB into the DISCONNECTED list.  This list holds the\n * candidates for paging out an SCB if one is needed for a new command.\n * Modifying the disconnected list is a critical(pause dissabled) section.\n */\nBEGIN_CRITICAL;\n\tmov\tSCB_NEXT, DISCONNECTED_SCBH;\n\tmov\tDISCONNECTED_SCBH, SCBPTR ret;\nEND_CRITICAL;\n}\nset_seqint:\n\tmov\tINTSTAT, SINDEX;\n\tnop;\nreturn:\n\tret;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}