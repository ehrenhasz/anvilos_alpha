{
  "module_name": "aic79xx.h",
  "hash_id": "48bd13af1b4bc0f4e43f2fb1e0349fdcd43d23fbc4475221163a4681894a5bd5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic79xx.h",
  "human_readable_source": " \n\n#ifndef _AIC79XX_H_\n#define _AIC79XX_H_\n\n \n#include \"aic79xx_reg.h\"\n\n \nstruct ahd_platform_data;\nstruct scb_platform_data;\n\n \n#ifndef TRUE\n#define TRUE 1\n#endif\n#ifndef FALSE\n#define FALSE 0\n#endif\n\n#define ALL_CHANNELS '\\0'\n#define ALL_TARGETS_MASK 0xFFFF\n#define INITIATOR_WILDCARD\t(~0)\n#define\tSCB_LIST_NULL\t\t0xFF00\n#define\tSCB_LIST_NULL_LE\t(ahd_htole16(SCB_LIST_NULL))\n#define QOUTFIFO_ENTRY_VALID 0x80\n#define SCBID_IS_NULL(scbid) (((scbid) & 0xFF00 ) == SCB_LIST_NULL)\n\n#define SCSIID_TARGET(ahd, scsiid)\t\\\n\t(((scsiid) & TID) >> TID_SHIFT)\n#define SCSIID_OUR_ID(scsiid)\t\t\\\n\t((scsiid) & OID)\n#define SCSIID_CHANNEL(ahd, scsiid) ('A')\n#define\tSCB_IS_SCSIBUS_B(ahd, scb) (0)\n#define\tSCB_GET_OUR_ID(scb) \\\n\tSCSIID_OUR_ID((scb)->hscb->scsiid)\n#define\tSCB_GET_TARGET(ahd, scb) \\\n\tSCSIID_TARGET((ahd), (scb)->hscb->scsiid)\n#define\tSCB_GET_CHANNEL(ahd, scb) \\\n\tSCSIID_CHANNEL(ahd, (scb)->hscb->scsiid)\n#define\tSCB_GET_LUN(scb) \\\n\t((scb)->hscb->lun)\n#define SCB_GET_TARGET_OFFSET(ahd, scb)\t\\\n\tSCB_GET_TARGET(ahd, scb)\n#define SCB_GET_TARGET_MASK(ahd, scb) \\\n\t(0x01 << (SCB_GET_TARGET_OFFSET(ahd, scb)))\n#ifdef AHD_DEBUG\n#define SCB_IS_SILENT(scb)\t\t\t\t\t\\\n\t((ahd_debug & AHD_SHOW_MASKED_ERRORS) == 0\t\t\\\n      && (((scb)->flags & SCB_SILENT) != 0))\n#else\n#define SCB_IS_SILENT(scb)\t\t\t\t\t\\\n\t(((scb)->flags & SCB_SILENT) != 0)\n#endif\n \n#define TCL_TARGET_OFFSET(tcl) \\\n\t((((tcl) >> 4) & TID) >> 4)\n#define TCL_LUN(tcl) \\\n\t(tcl & (AHD_NUM_LUNS - 1))\n#define BUILD_TCL(scsiid, lun) \\\n\t((lun) | (((scsiid) & TID) << 4))\n#define BUILD_TCL_RAW(target, channel, lun) \\\n\t((lun) | ((target) << 8))\n\n#define SCB_GET_TAG(scb) \\\n\tahd_le16toh(scb->hscb->tag)\n\n#ifndef\tAHD_TARGET_MODE\n#undef\tAHD_TMODE_ENABLE\n#define\tAHD_TMODE_ENABLE 0\n#endif\n\n#define AHD_BUILD_COL_IDX(target, lun)\t\t\t\t\\\n\t((((u8)lun) << 4) | target)\n\n#define AHD_GET_SCB_COL_IDX(ahd, scb)\t\t\t\t\\\n\t((SCB_GET_LUN(scb) << 4) | SCB_GET_TARGET(ahd, scb))\n\n#define AHD_SET_SCB_COL_IDX(scb, col_idx)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t(scb)->hscb->scsiid = ((col_idx) << TID_SHIFT) & TID;\t\t\\\n\t(scb)->hscb->lun = ((col_idx) >> 4) & (AHD_NUM_LUNS_NONPKT-1);\t\\\n} while (0)\n\n#define AHD_COPY_SCB_COL_IDX(dst, src)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tdst->hscb->scsiid = src->hscb->scsiid;\t\t\t\\\n\tdst->hscb->lun = src->hscb->lun;\t\t\t\\\n} while (0)\n\n#define\tAHD_NEVER_COL_IDX 0xFFFF\n\n \n \n#define AHD_NUM_TARGETS 16\n\n \n#define AHD_NUM_LUNS_NONPKT 64\n#define AHD_NUM_LUNS 256\n\n \n#define AHD_MAXTRANSFER_SIZE\t 0x00ffffff\t \n\n \n#define AHD_SCB_MAX\t512\n\n \n#define AHD_MAX_QUEUE\tAHD_SCB_MAX\n\n \n#define\tAHD_QIN_SIZE\tAHD_MAX_QUEUE\n#define\tAHD_QOUT_SIZE\tAHD_MAX_QUEUE\n\n#define AHD_QIN_WRAP(x) ((x) & (AHD_QIN_SIZE-1))\n \n#define AHD_SCB_MAX_ALLOC AHD_MAX_QUEUE\n\n \n#define AHD_TMODE_CMDS\t256\n\n \n#define AHD_BUSRESET_DELAY\t25\n\n \n \ntypedef enum {\n\tAHD_NONE\t= 0x0000,\n\tAHD_CHIPID_MASK\t= 0x00FF,\n\tAHD_AIC7901\t= 0x0001,\n\tAHD_AIC7902\t= 0x0002,\n\tAHD_AIC7901A\t= 0x0003,\n\tAHD_PCI\t\t= 0x0100,\t \n\tAHD_PCIX\t= 0x0200,\t \n\tAHD_BUS_MASK\t= 0x0F00\n} ahd_chip;\n\n \ntypedef enum {\n\tAHD_FENONE\t\t= 0x00000,\n\tAHD_WIDE\t\t= 0x00001, \n\tAHD_AIC79XXB_SLOWCRC    = 0x00002, \n\tAHD_MULTI_FUNC\t\t= 0x00100, \n\tAHD_TARGETMODE\t\t= 0x01000, \n\tAHD_MULTIROLE\t\t= 0x02000, \n\tAHD_RTI\t\t\t= 0x04000, \n\tAHD_NEW_IOCELL_OPTS\t= 0x08000, \n\tAHD_NEW_DFCNTRL_OPTS\t= 0x10000, \n\tAHD_FAST_CDB_DELIVERY\t= 0x20000, \n\tAHD_REMOVABLE\t\t= 0x00000, \n\tAHD_AIC7901_FE\t\t= AHD_FENONE,\n\tAHD_AIC7901A_FE\t\t= AHD_FENONE,\n\tAHD_AIC7902_FE\t\t= AHD_MULTI_FUNC\n} ahd_feature;\n\n \ntypedef enum {\n\tAHD_BUGNONE\t\t= 0x0000,\n\t \n\tAHD_SENT_SCB_UPDATE_BUG\t= 0x0001,\n\t \n\tAHD_ABORT_LQI_BUG\t= 0x0002,\n\t \n\tAHD_PKT_BITBUCKET_BUG\t= 0x0004,\n\t \n\tAHD_LONG_SETIMO_BUG\t= 0x0008,\n\t \n\tAHD_NLQICRC_DELAYED_BUG\t= 0x0010,\n\t \n\tAHD_SCSIRST_BUG\t\t= 0x0020,\n\t \n\tAHD_PCIX_CHIPRST_BUG\t= 0x0040,\n\t \n\tAHD_PCIX_MMAPIO_BUG\t= 0x0080,\n\t \n\tAHD_PCIX_SCBRAM_RD_BUG  = 0x0100,\n\t \n\tAHD_PCIX_BUG_MASK\t= AHD_PCIX_CHIPRST_BUG\n\t\t\t\t| AHD_PCIX_MMAPIO_BUG\n\t\t\t\t| AHD_PCIX_SCBRAM_RD_BUG,\n\t \n\tAHD_LQO_ATNO_BUG\t= 0x0200,\n\t \n\tAHD_AUTOFLUSH_BUG\t= 0x0400,\n\t \n\tAHD_CLRLQO_AUTOCLR_BUG\t= 0x0800,\n\t \n\tAHD_PKTIZED_STATUS_BUG  = 0x1000,\n\t \n\tAHD_PKT_LUN_BUG\t\t= 0x2000,\n\t \n\tAHD_NONPACKFIFO_BUG\t= 0x4000,\n\t \n\tAHD_MDFF_WSCBPTR_BUG\t= 0x8000,\n\t \n\tAHD_REG_SLOW_SETTLE_BUG\t= 0x10000,\n\t \n\tAHD_SET_MODE_BUG\t= 0x20000,\n\t \n\tAHD_BUSFREEREV_BUG\t= 0x40000,\n\t \n\tAHD_PACED_NEGTABLE_BUG\t= 0x80000,\n\t \n\tAHD_LQOOVERRUN_BUG\t= 0x100000,\n\t \n\tAHD_INTCOLLISION_BUG\t= 0x200000,\n\t \n\tAHD_EARLY_REQ_BUG\t= 0x400000,\n\t \n\tAHD_FAINT_LED_BUG\t= 0x800000\n} ahd_bug;\n\n \ntypedef enum {\n\tAHD_FNONE\t      = 0x00000,\n\tAHD_BOOT_CHANNEL      = 0x00001, \n\tAHD_USEDEFAULTS\t      = 0x00004, \n\tAHD_SEQUENCER_DEBUG   = 0x00008,\n\tAHD_RESET_BUS_A\t      = 0x00010,\n\tAHD_EXTENDED_TRANS_A  = 0x00020,\n\tAHD_TERM_ENB_A\t      = 0x00040,\n\tAHD_SPCHK_ENB_A\t      = 0x00080,\n\tAHD_STPWLEVEL_A\t      = 0x00100,\n\tAHD_INITIATORROLE     = 0x00200, \n\tAHD_TARGETROLE\t      = 0x00400, \n\tAHD_RESOURCE_SHORTAGE = 0x00800,\n\tAHD_TQINFIFO_BLOCKED  = 0x01000, \n\tAHD_INT50_SPEEDFLEX   = 0x02000, \n\tAHD_BIOS_ENABLED      = 0x04000,\n\tAHD_ALL_INTERRUPTS    = 0x08000,\n\tAHD_39BIT_ADDRESSING  = 0x10000, \n\tAHD_64BIT_ADDRESSING  = 0x20000, \n\tAHD_CURRENT_SENSING   = 0x40000,\n\tAHD_SCB_CONFIG_USED   = 0x80000, \n\tAHD_HP_BOARD\t      = 0x100000,\n\tAHD_BUS_RESET_ACTIVE  = 0x200000,\n\tAHD_UPDATE_PEND_CMDS  = 0x400000,\n\tAHD_RUNNING_QOUTFIFO  = 0x800000,\n\tAHD_HAD_FIRST_SEL     = 0x1000000\n} ahd_flag;\n\n \n\n \n\n \nstruct initiator_status {\n\tuint32_t residual_datacnt;\t \n\tuint32_t residual_sgptr;\t \n\tuint8_t\t scsi_status;\t\t \n};\n\nstruct target_status {\n\tuint32_t residual_datacnt;\t \n\tuint32_t residual_sgptr;\t \n\tuint8_t  scsi_status;\t\t \n\tuint8_t  target_phases;\t\t \n\tuint8_t  data_phase;\t\t \n\tuint8_t  initiator_tag;\t\t \n};\n\n \ntypedef uint32_t sense_addr_t;\n#define MAX_CDB_LEN 16\n#define MAX_CDB_LEN_WITH_SENSE_ADDR (MAX_CDB_LEN - sizeof(sense_addr_t))\nunion initiator_data {\n\tstruct {\n\t\tuint64_t cdbptr;\n\t\tuint8_t  cdblen;\n\t} cdb_from_host;\n\tuint8_t\t cdb[MAX_CDB_LEN];\n\tstruct {\n\t\tuint8_t\t cdb[MAX_CDB_LEN_WITH_SENSE_ADDR];\n\t\tsense_addr_t sense_addr;\n\t} cdb_plus_saddr;\n};\n\n \nstruct target_data {\n\tuint32_t spare[2];\n\tuint8_t  scsi_status;\t\t \n\tuint8_t  target_phases;\t\t \n\tuint8_t  data_phase;\t\t \n\tuint8_t  initiator_tag;\t\t \n};\n\nstruct hardware_scb {\n \tunion {\n\t\tunion\tinitiator_data idata;\n\t\tstruct\ttarget_data tdata;\n\t\tstruct\tinitiator_status istatus;\n\t\tstruct\ttarget_status tstatus;\n\t} shared_data;\n  \n#define SG_PTR_MASK\t0xFFFFFFF8\n \tuint16_t tag;\t\t \n \tuint8_t  control;\t \n \tuint8_t\t scsiid;\t \n \tuint8_t  lun;\n \tuint8_t  task_attribute;\n \tuint8_t  cdb_len;\n \tuint8_t  task_management;\n \tuint64_t dataptr;\n \tuint32_t datacnt;\t \n \tuint32_t sgptr;\n \tuint32_t hscb_busaddr;\n \tuint32_t next_hscb_busaddr;\n \n   uint8_t\t pkt_long_lun[8];\n \n   uint8_t\t spare[8];\n};\n\n \n \n\n \nstruct ahd_dma_seg {\n\tuint32_t\taddr;\n\tuint32_t\tlen;\n#define\tAHD_DMA_LAST_SEG\t0x80000000\n#define\tAHD_SG_HIGH_ADDR_MASK\t0x7F000000\n#define\tAHD_SG_LEN_MASK\t\t0x00FFFFFF\n};\n\nstruct ahd_dma64_seg {\n\tuint64_t\taddr;\n\tuint32_t\tlen;\n\tuint32_t\tpad;\n};\n\nstruct map_node {\n\tbus_dmamap_t\t\t dmamap;\n\tdma_addr_t\t\t physaddr;\n\tuint8_t\t\t\t*vaddr;\n\tSLIST_ENTRY(map_node)\t links;\n};\n\n \ntypedef enum {\n\tSCB_FLAG_NONE\t\t= 0x00000,\n\tSCB_TRANSMISSION_ERROR\t= 0x00001, \n\tSCB_OTHERTCL_TIMEOUT\t= 0x00002, \n\tSCB_DEVICE_RESET\t= 0x00004,\n\tSCB_SENSE\t\t= 0x00008,\n\tSCB_CDB32_PTR\t\t= 0x00010,\n\tSCB_RECOVERY_SCB\t= 0x00020,\n\tSCB_AUTO_NEGOTIATE\t= 0x00040, \n\tSCB_NEGOTIATE\t\t= 0x00080, \n\tSCB_ABORT\t\t= 0x00100,\n\tSCB_ACTIVE\t\t= 0x00200,\n\tSCB_TARGET_IMMEDIATE\t= 0x00400,\n\tSCB_PACKETIZED\t\t= 0x00800,\n\tSCB_EXPECT_PPR_BUSFREE\t= 0x01000,\n\tSCB_PKT_SENSE\t\t= 0x02000,\n\tSCB_EXTERNAL_RESET\t= 0x04000, \n\tSCB_ON_COL_LIST\t\t= 0x08000,\n\tSCB_SILENT\t\t= 0x10000  \n} scb_flag;\n\nstruct scb {\n\tstruct\thardware_scb\t *hscb;\n\tunion {\n\t\tSLIST_ENTRY(scb)  sle;\n\t\tLIST_ENTRY(scb)\t  le;\n\t\tTAILQ_ENTRY(scb)  tqe;\n\t} links;\n\tunion {\n\t\tSLIST_ENTRY(scb)  sle;\n\t\tLIST_ENTRY(scb)\t  le;\n\t\tTAILQ_ENTRY(scb)  tqe;\n\t} links2;\n#define pending_links links2.le\n#define collision_links links2.le\n\tstruct scb\t\t *col_scb;\n\tahd_io_ctx_t\t\t  io_ctx;\n\tstruct ahd_softc\t *ahd_softc;\n\tscb_flag\t\t  flags;\n\tstruct scb_platform_data *platform_data;\n\tstruct map_node\t\t *hscb_map;\n\tstruct map_node\t\t *sg_map;\n\tstruct map_node\t\t *sense_map;\n\tvoid\t\t\t *sg_list;\n\tuint8_t\t\t\t *sense_data;\n\tdma_addr_t\t\t  sg_list_busaddr;\n\tdma_addr_t\t\t  sense_busaddr;\n\tu_int\t\t\t  sg_count; \n#define\tAHD_MAX_LQ_CRC_ERRORS 5\n\tu_int\t\t\t  crc_retry_count;\n};\n\nTAILQ_HEAD(scb_tailq, scb);\nBSD_LIST_HEAD(scb_list, scb);\n\nstruct scb_data {\n\t \n\tstruct scb_tailq free_scbs;\n\n\t \n\tstruct scb_list free_scb_lists[AHD_NUM_TARGETS * AHD_NUM_LUNS_NONPKT];\n\n\t \n\tstruct scb_list any_dev_free_scb_list;\n\n\t \n\tstruct\tscb *scbindex[AHD_SCB_MAX];\n\n\t \n\tbus_dma_tag_t\t hscb_dmat;\t \n\tbus_dma_tag_t\t sg_dmat;\t \n\tbus_dma_tag_t\t sense_dmat;\t \n\tSLIST_HEAD(, map_node) hscb_maps;\n\tSLIST_HEAD(, map_node) sg_maps;\n\tSLIST_HEAD(, map_node) sense_maps;\n\tint\t\t scbs_left;\t \n\tint\t\t sgs_left;\t \n\tint\t\t sense_left;\t \n\tuint16_t\t numscbs;\n\tuint16_t\t maxhscbs;\t \n\tuint8_t\t\t init_level;\t \n};\n\n \n\n \nstruct target_cmd {\n\tuint8_t scsiid;\t\t \n\tuint8_t identify;\t \n\tuint8_t bytes[22];\t \n\tuint8_t cmd_valid;\t \n\tuint8_t pad[7];\n};\n\n \n#define AHD_TMODE_EVENT_BUFFER_SIZE 8\nstruct ahd_tmode_event {\n\tuint8_t initiator_id;\n\tuint8_t event_type;\t \n#define\tEVENT_TYPE_BUS_RESET 0xFF\n\tuint8_t event_arg;\n};\n\n \n#ifdef AHD_TARGET_MODE\nstruct ahd_tmode_lstate {\n\tstruct cam_path *path;\n\tstruct ccb_hdr_slist accept_tios;\n\tstruct ccb_hdr_slist immed_notifies;\n\tstruct ahd_tmode_event event_buffer[AHD_TMODE_EVENT_BUFFER_SIZE];\n\tuint8_t event_r_idx;\n\tuint8_t event_w_idx;\n};\n#else\nstruct ahd_tmode_lstate;\n#endif\n\n \n#define AHD_TRANS_CUR\t\t0x01\t \n#define AHD_TRANS_ACTIVE\t0x03\t \n#define AHD_TRANS_GOAL\t\t0x04\t \n#define AHD_TRANS_USER\t\t0x08\t \n#define AHD_PERIOD_10MHz\t0x19\n\n#define AHD_WIDTH_UNKNOWN\t0xFF\n#define AHD_PERIOD_UNKNOWN\t0xFF\n#define AHD_OFFSET_UNKNOWN\t0xFF\n#define AHD_PPR_OPTS_UNKNOWN\t0xFF\n\n \nstruct ahd_transinfo {\n\tuint8_t protocol_version;\t \n\tuint8_t transport_version;\t \n\tuint8_t width;\t\t\t \n\tuint8_t period;\t\t\t \n\tuint8_t offset;\t\t\t \n\tuint8_t ppr_options;\t\t \n};\n\n \nstruct ahd_initiator_tinfo {\n\tstruct ahd_transinfo curr;\n\tstruct ahd_transinfo goal;\n\tstruct ahd_transinfo user;\n};\n\n \nstruct ahd_tmode_tstate {\n\tstruct ahd_tmode_lstate*\tenabled_luns[AHD_NUM_LUNS];\n\tstruct ahd_initiator_tinfo\ttransinfo[AHD_NUM_TARGETS];\n\n\t \n\tuint16_t\t auto_negotiate; \n\tuint16_t\t discenable;\t \n\tuint16_t\t tagenable;\t \n};\n\n \n#define AHD_SYNCRATE_160\t0x8\n#define AHD_SYNCRATE_PACED\t0x8\n#define AHD_SYNCRATE_DT\t\t0x9\n#define AHD_SYNCRATE_ULTRA2\t0xa\n#define AHD_SYNCRATE_ULTRA\t0xc\n#define AHD_SYNCRATE_FAST\t0x19\n#define AHD_SYNCRATE_MIN_DT\tAHD_SYNCRATE_FAST\n#define AHD_SYNCRATE_SYNC\t0x32\n#define AHD_SYNCRATE_MIN\t0x60\n#define\tAHD_SYNCRATE_ASYNC\t0xFF\n#define AHD_SYNCRATE_MAX\tAHD_SYNCRATE_160\n\n \n#define\tAHD_ASYNC_XFER_PERIOD\t0x44\n\n \n#define AHD_SYNCRATE_REVA_120\t0x8\n#define AHD_SYNCRATE_REVA_160\t0x7\n\n \n \nstruct ahd_phase_table_entry {\n\tuint8_t phase;\n\tuint8_t mesg_out;  \n\tconst char *phasemsg;\n};\n\n \n\nstruct seeprom_config {\n \n\tuint16_t device_flags[16];\t \n#define\t\tCFXFER\t\t0x003F\t \n#define\t\t\tCFXFER_ASYNC\t0x3F\n#define\t\tCFQAS\t\t0x0040\t \n#define\t\tCFPACKETIZED\t0x0080\t \n#define\t\tCFSTART\t\t0x0100\t \n#define\t\tCFINCBIOS\t0x0200\t \n#define\t\tCFDISC\t\t0x0400\t \n#define\t\tCFMULTILUNDEV\t0x0800\t \n#define\t\tCFWIDEB\t\t0x1000\t \n#define\t\tCFHOSTMANAGED\t0x8000\t \n\n \n\tuint16_t bios_control;\t\t \n#define\t\tCFSUPREM\t0x0001\t \n#define\t\tCFSUPREMB\t0x0002\t \n#define\t\tCFBIOSSTATE\t0x000C\t \n#define\t\t    CFBS_DISABLED\t0x00\n#define\t\t    CFBS_ENABLED\t0x04\n#define\t\t    CFBS_DISABLED_SCAN\t0x08\n#define\t\tCFENABLEDV\t0x0010\t \n#define\t\tCFCTRL_A\t0x0020\t \n#define\t\tCFSPARITY\t0x0040\t \n#define\t\tCFEXTEND\t0x0080\t \n#define\t\tCFBOOTCD\t0x0100   \n#define\t\tCFMSG_LEVEL\t0x0600\t \n#define\t\t\tCFMSG_VERBOSE\t0x0000\n#define\t\t\tCFMSG_SILENT\t0x0200\n#define\t\t\tCFMSG_DIAG\t0x0400\n#define\t\tCFRESETB\t0x0800\t \n \n\n \n\tuint16_t adapter_control;\t \n#define\t\tCFAUTOTERM\t0x0001\t \n#define\t\tCFSTERM\t\t0x0002\t \n#define\t\tCFWSTERM\t0x0004\t \n#define\t\tCFSEAUTOTERM\t0x0008\t \n#define\t\tCFSELOWTERM\t0x0010\t \n#define\t\tCFSEHIGHTERM\t0x0020\t \n#define\t\tCFSTPWLEVEL\t0x0040\t \n#define\t\tCFBIOSAUTOTERM\t0x0080\t \n#define\t\tCFTERM_MENU\t0x0100\t \n#define\t\tCFCLUSTERENB\t0x8000\t \n\n \n\tuint16_t brtime_id;\t\t \n#define\t\tCFSCSIID\t0x000f\t \n \n#define\t\tCFBRTIME\t0xff00\t \n\n \n\tuint16_t max_targets;\t\t \n#define\t\tCFMAXTARG\t0x00ff\t \n#define\t\tCFBOOTLUN\t0x0f00\t \n#define\t\tCFBOOTID\t0xf000\t \n\tuint16_t res_1[10];\t\t \n\tuint16_t signature;\t\t \n#define\t\tCFSIGNATURE\t0x400\n\tuint16_t checksum;\t\t \n};\n\n \nstruct vpd_config {\n\tuint8_t  bios_flags;\n#define\t\tVPDMASTERBIOS\t0x0001\n#define\t\tVPDBOOTHOST\t0x0002\n\tuint8_t  reserved_1[21];\n\tuint8_t  resource_type;\n\tuint8_t  resource_len[2];\n\tuint8_t  resource_data[8];\n\tuint8_t  vpd_tag;\n\tuint16_t vpd_len;\n\tuint8_t  vpd_keyword[2];\n\tuint8_t  length;\n\tuint8_t  revision;\n\tuint8_t  device_flags;\n\tuint8_t  termination_menus[2];\n\tuint8_t  fifo_threshold;\n\tuint8_t  end_tag;\n\tuint8_t  vpd_checksum;\n\tuint16_t default_target_flags;\n\tuint16_t default_bios_flags;\n\tuint16_t default_ctrl_flags;\n\tuint8_t  default_irq;\n\tuint8_t  pci_lattime;\n\tuint8_t  max_target;\n\tuint8_t  boot_lun;\n\tuint16_t signature;\n\tuint8_t  reserved_2;\n\tuint8_t  checksum;\n\tuint8_t\t reserved_3[4];\n};\n\n \n#define FLXADDR_TERMCTL\t\t\t0x0\n#define\t\tFLX_TERMCTL_ENSECHIGH\t0x8\n#define\t\tFLX_TERMCTL_ENSECLOW\t0x4\n#define\t\tFLX_TERMCTL_ENPRIHIGH\t0x2\n#define\t\tFLX_TERMCTL_ENPRILOW\t0x1\n#define FLXADDR_ROMSTAT_CURSENSECTL\t0x1\n#define\t\tFLX_ROMSTAT_SEECFG\t0xF0\n#define\t\tFLX_ROMSTAT_EECFG\t0x0F\n#define\t\tFLX_ROMSTAT_SEE_93C66\t0x00\n#define\t\tFLX_ROMSTAT_SEE_NONE\t0xF0\n#define\t\tFLX_ROMSTAT_EE_512x8\t0x0\n#define\t\tFLX_ROMSTAT_EE_1MBx8\t0x1\n#define\t\tFLX_ROMSTAT_EE_2MBx8\t0x2\n#define\t\tFLX_ROMSTAT_EE_4MBx8\t0x3\n#define\t\tFLX_ROMSTAT_EE_16MBx8\t0x4\n#define\t\t\tCURSENSE_ENB\t0x1\n#define\tFLXADDR_FLEXSTAT\t\t0x2\n#define\t\tFLX_FSTAT_BUSY\t\t0x1\n#define FLXADDR_CURRENT_STAT\t\t0x4\n#define\t\tFLX_CSTAT_SEC_HIGH\t0xC0\n#define\t\tFLX_CSTAT_SEC_LOW\t0x30\n#define\t\tFLX_CSTAT_PRI_HIGH\t0x0C\n#define\t\tFLX_CSTAT_PRI_LOW\t0x03\n#define\t\tFLX_CSTAT_MASK\t\t0x03\n#define\t\tFLX_CSTAT_SHIFT\t\t2\n#define\t\tFLX_CSTAT_OKAY\t\t0x0\n#define\t\tFLX_CSTAT_OVER\t\t0x1\n#define\t\tFLX_CSTAT_UNDER\t\t0x2\n#define\t\tFLX_CSTAT_INVALID\t0x3\n\nint\t\tahd_read_seeprom(struct ahd_softc *ahd, uint16_t *buf,\n\t\t\t\t u_int start_addr, u_int count, int bstream);\n\nint\t\tahd_write_seeprom(struct ahd_softc *ahd, uint16_t *buf,\n\t\t\t\t  u_int start_addr, u_int count);\nint\t\tahd_verify_cksum(struct seeprom_config *sc);\nint\t\tahd_acquire_seeprom(struct ahd_softc *ahd);\nvoid\t\tahd_release_seeprom(struct ahd_softc *ahd);\n\n \ntypedef enum {\n\tMSG_FLAG_NONE\t\t\t= 0x00,\n\tMSG_FLAG_EXPECT_PPR_BUSFREE\t= 0x01,\n\tMSG_FLAG_IU_REQ_CHANGED\t\t= 0x02,\n\tMSG_FLAG_EXPECT_IDE_BUSFREE\t= 0x04,\n\tMSG_FLAG_EXPECT_QASREJ_BUSFREE\t= 0x08,\n\tMSG_FLAG_PACKETIZED\t\t= 0x10\n} ahd_msg_flags;\n\ntypedef enum {\n\tMSG_TYPE_NONE\t\t\t= 0x00,\n\tMSG_TYPE_INITIATOR_MSGOUT\t= 0x01,\n\tMSG_TYPE_INITIATOR_MSGIN\t= 0x02,\n\tMSG_TYPE_TARGET_MSGOUT\t\t= 0x03,\n\tMSG_TYPE_TARGET_MSGIN\t\t= 0x04\n} ahd_msg_type;\n\ntypedef enum {\n\tMSGLOOP_IN_PROG,\n\tMSGLOOP_MSGCOMPLETE,\n\tMSGLOOP_TERMINATED\n} msg_loop_stat;\n\n \nstruct ahd_suspend_channel_state {\n\tuint8_t\tscsiseq;\n\tuint8_t\tsxfrctl0;\n\tuint8_t\tsxfrctl1;\n\tuint8_t\tsimode0;\n\tuint8_t\tsimode1;\n\tuint8_t\tseltimer;\n\tuint8_t\tseqctl;\n};\n\nstruct ahd_suspend_pci_state {\n\tuint32_t  devconfig;\n\tuint8_t   command;\n\tuint8_t   csize_lattime;\n};\n\nstruct ahd_suspend_state {\n\tstruct\tahd_suspend_channel_state channel[2];\n\tstruct  ahd_suspend_pci_state pci_state;\n\tuint8_t\toptionmode;\n\tuint8_t\tdscommand0;\n\tuint8_t\tdspcistatus;\n\t \n\tuint8_t\tcrccontrol1;\n\tuint8_t\tscbbaddr;\n\t \n\tuint8_t\tdff_thrsh;\n\tuint8_t\t*scratch_ram;\n\tuint8_t\t*btt;\n};\n\ntypedef void (*ahd_bus_intr_t)(struct ahd_softc *);\n\ntypedef enum {\n\tAHD_MODE_DFF0,\n\tAHD_MODE_DFF1,\n\tAHD_MODE_CCHAN,\n\tAHD_MODE_SCSI,\n\tAHD_MODE_CFG,\n\tAHD_MODE_UNKNOWN\n} ahd_mode;\n\n#define AHD_MK_MSK(x) (0x01 << (x))\n#define AHD_MODE_DFF0_MSK\tAHD_MK_MSK(AHD_MODE_DFF0)\n#define AHD_MODE_DFF1_MSK\tAHD_MK_MSK(AHD_MODE_DFF1)\n#define AHD_MODE_CCHAN_MSK\tAHD_MK_MSK(AHD_MODE_CCHAN)\n#define AHD_MODE_SCSI_MSK\tAHD_MK_MSK(AHD_MODE_SCSI)\n#define AHD_MODE_CFG_MSK\tAHD_MK_MSK(AHD_MODE_CFG)\n#define AHD_MODE_UNKNOWN_MSK\tAHD_MK_MSK(AHD_MODE_UNKNOWN)\n#define AHD_MODE_ANY_MSK (~0)\n\ntypedef uint8_t ahd_mode_state;\n\nstruct ahd_completion\n{\n\tuint16_t\ttag;\n\tuint8_t\t\tsg_status;\n\tuint8_t\t\tvalid_tag;\n};\n\nstruct ahd_softc {\n\tbus_space_tag_t\t\t  tags[2];\n\tbus_space_handle_t\t  bshs[2];\n\tstruct scb_data\t\t  scb_data;\n\n\tstruct hardware_scb\t *next_queued_hscb;\n\tstruct map_node\t\t *next_queued_hscb_map;\n\n\t \n\tBSD_LIST_HEAD(, scb)\t  pending_scbs;\n\n\t \n\tahd_mode\t\t  dst_mode;\n\tahd_mode\t\t  src_mode;\n\n\t \n\tahd_mode\t\t  saved_dst_mode;\n\tahd_mode\t\t  saved_src_mode;\n\n\t \n\tstruct ahd_platform_data *platform_data;\n\n\t \n\tahd_dev_softc_t\t\t  dev_softc;\n\n\t \n\tahd_bus_intr_t\t\t  bus_intr;\n\n\t \n\tstruct ahd_tmode_tstate  *enabled_targets[AHD_NUM_TARGETS];\n\n\t \n\tstruct ahd_tmode_lstate  *black_hole;\n\n\t \n\tstruct ahd_tmode_lstate  *pending_device;\n\n\t \n\tstruct timer_list\tstat_timer;\n\n\t \n#define\tAHD_STAT_UPDATE_US\t250000  \n#define\tAHD_STAT_BUCKETS\t4\n\tu_int\t\t\t  cmdcmplt_bucket;\n\tuint32_t\t\t  cmdcmplt_counts[AHD_STAT_BUCKETS];\n\tuint32_t\t\t  cmdcmplt_total;\n\n\t \n\tahd_chip\t\t  chip;\n\tahd_feature\t\t  features;\n\tahd_bug\t\t\t  bugs;\n\tahd_flag\t\t  flags;\n\tstruct seeprom_config\t *seep_config;\n\n\t \n\tstruct ahd_completion\t  *qoutfifo;\n\tuint16_t\t\t  qoutfifonext;\n\tuint16_t\t\t  qoutfifonext_valid_tag;\n\tuint16_t\t\t  qinfifonext;\n\tuint16_t\t\t  qinfifo[AHD_SCB_MAX];\n\n\t \n\tuint16_t\t\t  qfreeze_cnt;\n\n\t \n\tuint8_t\t\t\t  unpause;\n\tuint8_t\t\t\t  pause;\n\n\t \n\tstruct cs\t\t *critical_sections;\n\tu_int\t\t\t  num_critical_sections;\n\n\t \n\tuint8_t\t\t\t *overrun_buf;\n\n\t \n\tTAILQ_ENTRY(ahd_softc)\t  links;\n\n\t \n\tchar\t\t\t  channel;\n\n\t \n\tuint8_t\t\t\t  our_id;\n\n\t \n\tstruct target_cmd\t *targetcmds;\n\tuint8_t\t\t\t  tqinfifonext;\n\n\t \n\tuint8_t\t\t\t  hs_mailbox;\n\n\t \n\tuint8_t\t\t\t  send_msg_perror;\n\tahd_msg_flags\t\t  msg_flags;\n\tahd_msg_type\t\t  msg_type;\n\tuint8_t\t\t\t  msgout_buf[12]; \n\tuint8_t\t\t\t  msgin_buf[12]; \n\tu_int\t\t\t  msgout_len;\t \n\tu_int\t\t\t  msgout_index;\t \n\tu_int\t\t\t  msgin_index;\t \n\n\t \n\tbus_dma_tag_t\t\t  parent_dmat;\n\tbus_dma_tag_t\t\t  shared_data_dmat;\n\tstruct map_node\t\t  shared_data_map;\n\n\t \n\tstruct ahd_suspend_state  suspend_state;\n\n\t \n\tu_int\t\t\t  enabled_luns;\n\n\t \n\tu_int\t\t\t  init_level;\n\n\t \n\tu_int\t\t\t  pci_cachesize;\n\n\t \n\tuint8_t\t\t\t  iocell_opts[AHD_NUM_PER_DEV_ANNEXCOLS];\n\n\tu_int\t\t\t  stack_size;\n\tuint16_t\t\t *saved_stack;\n\n\t \n\tconst char\t\t *description;\n\tconst char\t\t *bus_description;\n\tchar\t\t\t *name;\n\tint\t\t\t  unit;\n\n\t \n\tint\t\t\t  seltime;\n\n\t \n#define\tAHD_INT_COALESCING_TIMER_DEFAULT\t\t250  \n#define\tAHD_INT_COALESCING_MAXCMDS_DEFAULT\t\t10\n#define\tAHD_INT_COALESCING_MAXCMDS_MAX\t\t\t127\n#define\tAHD_INT_COALESCING_MINCMDS_DEFAULT\t\t5\n#define\tAHD_INT_COALESCING_MINCMDS_MAX\t\t\t127\n#define\tAHD_INT_COALESCING_THRESHOLD_DEFAULT\t\t2000\n#define\tAHD_INT_COALESCING_STOP_THRESHOLD_DEFAULT\t1000\n\tu_int\t\t\t  int_coalescing_timer;\n\tu_int\t\t\t  int_coalescing_maxcmds;\n\tu_int\t\t\t  int_coalescing_mincmds;\n\tu_int\t\t\t  int_coalescing_threshold;\n\tu_int\t\t\t  int_coalescing_stop_threshold;\n\n\tuint16_t\t\t  user_discenable; \n\tuint16_t\t\t  user_tagenable; \n};\n\n \n#define\tAHD_PRECOMP_SLEW_INDEX\t\t\t\t\t\t\\\n    (AHD_ANNEXCOL_PRECOMP_SLEW - AHD_ANNEXCOL_PER_DEV0)\n\n#define\tAHD_AMPLITUDE_INDEX\t\t\t\t\t\t\\\n    (AHD_ANNEXCOL_AMPLITUDE - AHD_ANNEXCOL_PER_DEV0)\n\n#define AHD_SET_SLEWRATE(ahd, new_slew)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n    (ahd)->iocell_opts[AHD_PRECOMP_SLEW_INDEX] &= ~AHD_SLEWRATE_MASK;\t\\\n    (ahd)->iocell_opts[AHD_PRECOMP_SLEW_INDEX] |=\t\t\t\\\n\t(((new_slew) << AHD_SLEWRATE_SHIFT) & AHD_SLEWRATE_MASK);\t\\\n} while (0)\n\n#define AHD_SET_PRECOMP(ahd, new_pcomp)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n    (ahd)->iocell_opts[AHD_PRECOMP_SLEW_INDEX] &= ~AHD_PRECOMP_MASK;\t\\\n    (ahd)->iocell_opts[AHD_PRECOMP_SLEW_INDEX] |=\t\t\t\\\n\t(((new_pcomp) << AHD_PRECOMP_SHIFT) & AHD_PRECOMP_MASK);\t\\\n} while (0)\n\n#define AHD_SET_AMPLITUDE(ahd, new_amp)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n    (ahd)->iocell_opts[AHD_AMPLITUDE_INDEX] &= ~AHD_AMPLITUDE_MASK;\t\\\n    (ahd)->iocell_opts[AHD_AMPLITUDE_INDEX] |=\t\t\t\t\\\n\t(((new_amp) << AHD_AMPLITUDE_SHIFT) & AHD_AMPLITUDE_MASK);\t\\\n} while (0)\n\n \ntypedef enum {\n\tROLE_UNKNOWN,\n\tROLE_INITIATOR,\n\tROLE_TARGET\n} role_t;\n\nstruct ahd_devinfo {\n\tint\t our_scsiid;\n\tint\t target_offset;\n\tuint16_t target_mask;\n\tu_int\t target;\n\tu_int\t lun;\n\tchar\t channel;\n\trole_t\t role;\t\t \n};\n\n \n#define AHD_PCI_IOADDR0\tPCIR_BAR(0)\t \n#define AHD_PCI_MEMADDR\tPCIR_BAR(1)\t \n#define AHD_PCI_IOADDR1\tPCIR_BAR(3)\t \n\ntypedef int (ahd_device_setup_t)(struct ahd_softc *);\n\nstruct ahd_pci_identity {\n\tuint64_t\t\t full_id;\n\tuint64_t\t\t id_mask;\n\tconst char\t\t*name;\n\tahd_device_setup_t\t*setup;\n};\n\n \nstruct aic7770_identity {\n\tuint32_t\t\t full_id;\n\tuint32_t\t\t id_mask;\n\tconst char\t\t*name;\n\tahd_device_setup_t\t*setup;\n};\nextern struct aic7770_identity aic7770_ident_table [];\nextern const int ahd_num_aic7770_devs;\n\n#define AHD_EISA_SLOT_OFFSET\t0xc00\n#define AHD_EISA_IOSIZE\t\t0x100\n\n \n \n\n \nconst struct\tahd_pci_identity *ahd_find_pci_device(ahd_dev_softc_t);\nint\t\t\t  ahd_pci_config(struct ahd_softc *,\n\t\t\t\t\t const struct ahd_pci_identity *);\nint\tahd_pci_test_register_access(struct ahd_softc *);\nvoid __maybe_unused\tahd_pci_suspend(struct ahd_softc *);\nvoid __maybe_unused\tahd_pci_resume(struct ahd_softc *);\n\n \nvoid\t\tahd_qinfifo_requeue_tail(struct ahd_softc *ahd,\n\t\t\t\t\t struct scb *scb);\n\n \nstruct ahd_softc\t*ahd_alloc(void *platform_arg, char *name);\nint\t\t\t ahd_softc_init(struct ahd_softc *);\nvoid\t\t\t ahd_controller_info(struct ahd_softc *ahd, char *buf);\nint\t\t\t ahd_init(struct ahd_softc *ahd);\nint __maybe_unused\t ahd_suspend(struct ahd_softc *ahd);\nvoid __maybe_unused\t ahd_resume(struct ahd_softc *ahd);\nint\t\t\t ahd_default_config(struct ahd_softc *ahd);\nint\t\t\t ahd_parse_vpddata(struct ahd_softc *ahd,\n\t\t\t\t\t   struct vpd_config *vpd);\nint\t\t\t ahd_parse_cfgdata(struct ahd_softc *ahd,\n\t\t\t\t\t   struct seeprom_config *sc);\nvoid\t\t\t ahd_intr_enable(struct ahd_softc *ahd, int enable);\nvoid\t\t\t ahd_pause_and_flushwork(struct ahd_softc *ahd);\nvoid\t\t\t ahd_set_unit(struct ahd_softc *, int);\nvoid\t\t\t ahd_set_name(struct ahd_softc *, char *);\nstruct scb\t\t*ahd_get_scb(struct ahd_softc *ahd, u_int col_idx);\nvoid\t\t\t ahd_free_scb(struct ahd_softc *ahd, struct scb *scb);\nvoid\t\t\t ahd_free(struct ahd_softc *ahd);\nint\t\t\t ahd_reset(struct ahd_softc *ahd, int reinit);\nint\t\t\t ahd_write_flexport(struct ahd_softc *ahd,\n\t\t\t\t\t    u_int addr, u_int value);\nint\t\t\t ahd_read_flexport(struct ahd_softc *ahd, u_int addr,\n\t\t\t\t\t   uint8_t *value);\n\n \ntypedef enum {\n\tSEARCH_COMPLETE,\n\tSEARCH_COUNT,\n\tSEARCH_REMOVE,\n\tSEARCH_PRINT\n} ahd_search_action;\nint\t\t\tahd_search_qinfifo(struct ahd_softc *ahd, int target,\n\t\t\t\t\t   char channel, int lun, u_int tag,\n\t\t\t\t\t   role_t role, uint32_t status,\n\t\t\t\t\t   ahd_search_action action);\nint\t\t\tahd_search_disc_list(struct ahd_softc *ahd, int target,\n\t\t\t\t\t     char channel, int lun, u_int tag,\n\t\t\t\t\t     int stop_on_first, int remove,\n\t\t\t\t\t     int save_state);\nint\t\t\tahd_reset_channel(struct ahd_softc *ahd, char channel,\n\t\t\t\t\t  int initiate_reset);\n \nvoid\t\t\tahd_compile_devinfo(struct ahd_devinfo *devinfo,\n\t\t\t\t\t    u_int our_id, u_int target,\n\t\t\t\t\t    u_int lun, char channel,\n\t\t\t\t\t    role_t role);\n \nvoid\t\t\tahd_find_syncrate(struct ahd_softc *ahd, u_int *period,\n\t\t\t\t\t  u_int *ppr_options, u_int maxsync);\n \ntypedef enum {\n\tAHD_NEG_TO_GOAL,\t \n\tAHD_NEG_IF_NON_ASYNC,\t \n\tAHD_NEG_ALWAYS\t\t \n} ahd_neg_type;\nint\t\t\tahd_update_neg_request(struct ahd_softc*,\n\t\t\t\t\t       struct ahd_devinfo*,\n\t\t\t\t\t       struct ahd_tmode_tstate*,\n\t\t\t\t\t       struct ahd_initiator_tinfo*,\n\t\t\t\t\t       ahd_neg_type);\nvoid\t\t\tahd_set_width(struct ahd_softc *ahd,\n\t\t\t\t      struct ahd_devinfo *devinfo,\n\t\t\t\t      u_int width, u_int type, int paused);\nvoid\t\t\tahd_set_syncrate(struct ahd_softc *ahd,\n\t\t\t\t\t struct ahd_devinfo *devinfo,\n\t\t\t\t\t u_int period, u_int offset,\n\t\t\t\t\t u_int ppr_options,\n\t\t\t\t\t u_int type, int paused);\ntypedef enum {\n\tAHD_QUEUE_NONE,\n\tAHD_QUEUE_BASIC,\n\tAHD_QUEUE_TAGGED\n} ahd_queue_alg;\n\n \n#ifdef AHD_TARGET_MODE\nvoid\t\tahd_send_lstate_events(struct ahd_softc *,\n\t\t\t\t       struct ahd_tmode_lstate *);\nvoid\t\tahd_handle_en_lun(struct ahd_softc *ahd,\n\t\t\t\t  struct cam_sim *sim, union ccb *ccb);\ncam_status\tahd_find_tmode_devs(struct ahd_softc *ahd,\n\t\t\t\t    struct cam_sim *sim, union ccb *ccb,\n\t\t\t\t    struct ahd_tmode_tstate **tstate,\n\t\t\t\t    struct ahd_tmode_lstate **lstate,\n\t\t\t\t    int notfound_failure);\n#ifndef AHD_TMODE_ENABLE\n#define AHD_TMODE_ENABLE 0\n#endif\n#endif\n \n#ifdef AHD_DEBUG\nextern uint32_t ahd_debug;\n#define AHD_SHOW_MISC\t\t0x00001\n#define AHD_SHOW_SENSE\t\t0x00002\n#define AHD_SHOW_RECOVERY\t0x00004\n#define AHD_DUMP_SEEPROM\t0x00008\n#define AHD_SHOW_TERMCTL\t0x00010\n#define AHD_SHOW_MEMORY\t\t0x00020\n#define AHD_SHOW_MESSAGES\t0x00040\n#define AHD_SHOW_MODEPTR\t0x00080\n#define AHD_SHOW_SELTO\t\t0x00100\n#define AHD_SHOW_FIFOS\t\t0x00200\n#define AHD_SHOW_QFULL\t\t0x00400\n#define\tAHD_SHOW_DV\t\t0x00800\n#define AHD_SHOW_MASKED_ERRORS\t0x01000\n#define AHD_SHOW_QUEUE\t\t0x02000\n#define AHD_SHOW_TQIN\t\t0x04000\n#define AHD_SHOW_SG\t\t0x08000\n#define AHD_SHOW_INT_COALESCING\t0x10000\n#define AHD_DEBUG_SEQUENCER\t0x20000\n#endif\nvoid\t\t\tahd_print_devinfo(struct ahd_softc *ahd,\n\t\t\t\t\t  struct ahd_devinfo *devinfo);\nvoid\t\t\tahd_dump_card_state(struct ahd_softc *ahd);\nint\t\t\tahd_print_register(const ahd_reg_parse_entry_t *table,\n\t\t\t\t\t   u_int num_entries,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   u_int address,\n\t\t\t\t\t   u_int value,\n\t\t\t\t\t   u_int *cur_column,\n\t\t\t\t\t   u_int wrap_point);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}