{
  "module_name": "aic7xxx_core.c",
  "hash_id": "e2af336a43db933f88c7d062d0153c09792795cf08e05797ca6fbeb45936ea2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic7xxx_core.c",
  "human_readable_source": " \n\n#include \"aic7xxx_osm.h\"\n#include \"aic7xxx_inline.h\"\n#include \"aicasm/aicasm_insformat.h\"\n\n \nstatic const char *const ahc_chip_names[] = {\n\t\"NONE\",\n\t\"aic7770\",\n\t\"aic7850\",\n\t\"aic7855\",\n\t\"aic7859\",\n\t\"aic7860\",\n\t\"aic7870\",\n\t\"aic7880\",\n\t\"aic7895\",\n\t\"aic7895C\",\n\t\"aic7890/91\",\n\t\"aic7896/97\",\n\t\"aic7892\",\n\t\"aic7899\"\n};\n\n \nstruct ahc_hard_error_entry {\n\tuint8_t errno;\n\tconst char *errmesg;\n};\n\nstatic const struct ahc_hard_error_entry ahc_hard_errors[] = {\n\t{ ILLHADDR,\t\"Illegal Host Access\" },\n\t{ ILLSADDR,\t\"Illegal Sequencer Address referenced\" },\n\t{ ILLOPCODE,\t\"Illegal Opcode in sequencer program\" },\n\t{ SQPARERR,\t\"Sequencer Parity Error\" },\n\t{ DPARERR,\t\"Data-path Parity Error\" },\n\t{ MPARERR,\t\"Scratch or SCB Memory Parity Error\" },\n\t{ PCIERRSTAT,\t\"PCI Error detected\" },\n\t{ CIOPARERR,\t\"CIOBUS Parity Error\" },\n};\nstatic const u_int num_errors = ARRAY_SIZE(ahc_hard_errors);\n\nstatic const struct ahc_phase_table_entry ahc_phase_table[] =\n{\n\t{ P_DATAOUT,\tNOP,\t\t\t\"in Data-out phase\"\t},\n\t{ P_DATAIN,\tINITIATOR_ERROR,\t\"in Data-in phase\"\t},\n\t{ P_DATAOUT_DT,\tNOP,\t\t\t\"in DT Data-out phase\"\t},\n\t{ P_DATAIN_DT,\tINITIATOR_ERROR,\t\"in DT Data-in phase\"\t},\n\t{ P_COMMAND,\tNOP,\t\t\t\"in Command phase\"\t},\n\t{ P_MESGOUT,\tNOP,\t\t\t\"in Message-out phase\"\t},\n\t{ P_STATUS,\tINITIATOR_ERROR,\t\"in Status phase\"\t},\n\t{ P_MESGIN,\tMSG_PARITY_ERROR,\t\"in Message-in phase\"\t},\n\t{ P_BUSFREE,\tNOP,\t\t\t\"while idle\"\t\t},\n\t{ 0,\t\tNOP,\t\t\t\"in unknown phase\"\t}\n};\n\n \nstatic const u_int num_phases = ARRAY_SIZE(ahc_phase_table) - 1;\n\n \nstatic const struct ahc_syncrate ahc_syncrates[] =\n{\n       \n\t{ 0x42,      0x000,      9,      \"80.0\" },\n\t{ 0x03,      0x000,     10,      \"40.0\" },\n\t{ 0x04,      0x000,     11,      \"33.0\" },\n\t{ 0x05,      0x100,     12,      \"20.0\" },\n\t{ 0x06,      0x110,     15,      \"16.0\" },\n\t{ 0x07,      0x120,     18,      \"13.4\" },\n\t{ 0x08,      0x000,     25,      \"10.0\" },\n\t{ 0x19,      0x010,     31,      \"8.0\"  },\n\t{ 0x1a,      0x020,     37,      \"6.67\" },\n\t{ 0x1b,      0x030,     43,      \"5.7\"  },\n\t{ 0x1c,      0x040,     50,      \"5.0\"  },\n\t{ 0x00,      0x050,     56,      \"4.4\"  },\n\t{ 0x00,      0x060,     62,      \"4.0\"  },\n\t{ 0x00,      0x070,     68,      \"3.6\"  },\n\t{ 0x00,      0x000,      0,      NULL   }\n};\n\n \n#include \"aic7xxx_seq.h\"\n\n \nstatic void\t\tahc_force_renegotiation(struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo);\nstatic struct ahc_tmode_tstate*\n\t\t\tahc_alloc_tstate(struct ahc_softc *ahc,\n\t\t\t\t\t u_int scsi_id, char channel);\n#ifdef AHC_TARGET_MODE\nstatic void\t\tahc_free_tstate(struct ahc_softc *ahc,\n\t\t\t\t\tu_int scsi_id, char channel, int force);\n#endif\nstatic const struct ahc_syncrate*\n\t\t\tahc_devlimited_syncrate(struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_initiator_tinfo *,\n\t\t\t\t\t\tu_int *period,\n\t\t\t\t\t\tu_int *ppr_options,\n\t\t\t\t\t\trole_t role);\nstatic void\t\tahc_update_pending_scbs(struct ahc_softc *ahc);\nstatic void\t\tahc_fetch_devinfo(struct ahc_softc *ahc,\n\t\t\t\t\t  struct ahc_devinfo *devinfo);\nstatic void\t\tahc_scb_devinfo(struct ahc_softc *ahc,\n\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\tstruct scb *scb);\nstatic void\t\tahc_assert_atn(struct ahc_softc *ahc);\nstatic void\t\tahc_setup_initiator_msgout(struct ahc_softc *ahc,\n\t\t\t\t\t\t   struct ahc_devinfo *devinfo,\n\t\t\t\t\t\t   struct scb *scb);\nstatic void\t\tahc_build_transfer_msg(struct ahc_softc *ahc,\n\t\t\t\t\t       struct ahc_devinfo *devinfo);\nstatic void\t\tahc_construct_sdtr(struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo,\n\t\t\t\t\t   u_int period, u_int offset);\nstatic void\t\tahc_construct_wdtr(struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo,\n\t\t\t\t\t   u_int bus_width);\nstatic void\t\tahc_construct_ppr(struct ahc_softc *ahc,\n\t\t\t\t\t  struct ahc_devinfo *devinfo,\n\t\t\t\t\t  u_int period, u_int offset,\n\t\t\t\t\t  u_int bus_width, u_int ppr_options);\nstatic void\t\tahc_clear_msg_state(struct ahc_softc *ahc);\nstatic void\t\tahc_handle_proto_violation(struct ahc_softc *ahc);\nstatic void\t\tahc_handle_message_phase(struct ahc_softc *ahc);\ntypedef enum {\n\tAHCMSG_1B,\n\tAHCMSG_2B,\n\tAHCMSG_EXT\n} ahc_msgtype;\nstatic int\t\tahc_sent_msg(struct ahc_softc *ahc, ahc_msgtype type,\n\t\t\t\t     u_int msgval, int full);\nstatic int\t\tahc_parse_msg(struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo);\nstatic int\t\tahc_handle_msg_reject(struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo);\nstatic void\t\tahc_handle_ign_wide_residue(struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo);\nstatic void\t\tahc_reinitialize_dataptrs(struct ahc_softc *ahc);\nstatic void\t\tahc_handle_devreset(struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo,\n\t\t\t\t\t    cam_status status, char *message,\n\t\t\t\t\t    int verbose_level);\n#ifdef AHC_TARGET_MODE\nstatic void\t\tahc_setup_target_msgin(struct ahc_softc *ahc,\n\t\t\t\t\t       struct ahc_devinfo *devinfo,\n\t\t\t\t\t       struct scb *scb);\n#endif\n\nstatic bus_dmamap_callback_t\tahc_dmamap_cb;\nstatic void\t\tahc_build_free_scb_list(struct ahc_softc *ahc);\nstatic int\t\tahc_init_scbdata(struct ahc_softc *ahc);\nstatic void\t\tahc_fini_scbdata(struct ahc_softc *ahc);\nstatic void\t\tahc_qinfifo_requeue(struct ahc_softc *ahc,\n\t\t\t\t\t    struct scb *prev_scb,\n\t\t\t\t\t    struct scb *scb);\nstatic int\t\tahc_qinfifo_count(struct ahc_softc *ahc);\nstatic u_int\t\tahc_rem_scb_from_disc_list(struct ahc_softc *ahc,\n\t\t\t\t\t\t   u_int prev, u_int scbptr);\nstatic void\t\tahc_add_curscb_to_free_list(struct ahc_softc *ahc);\nstatic u_int\t\tahc_rem_wscb(struct ahc_softc *ahc,\n\t\t\t\t     u_int scbpos, u_int prev);\nstatic void\t\tahc_reset_current_bus(struct ahc_softc *ahc);\n#ifdef AHC_DUMP_SEQ\nstatic void\t\tahc_dumpseq(struct ahc_softc *ahc);\n#endif\nstatic int\t\tahc_loadseq(struct ahc_softc *ahc);\nstatic int\t\tahc_check_patch(struct ahc_softc *ahc,\n\t\t\t\t\tconst struct patch **start_patch,\n\t\t\t\t\tu_int start_instr, u_int *skip_addr);\nstatic void\t\tahc_download_instr(struct ahc_softc *ahc,\n\t\t\t\t\t   u_int instrptr, uint8_t *dconsts);\n#ifdef AHC_TARGET_MODE\nstatic void\t\tahc_queue_lstate_event(struct ahc_softc *ahc,\n\t\t\t\t\t       struct ahc_tmode_lstate *lstate,\n\t\t\t\t\t       u_int initiator_id,\n\t\t\t\t\t       u_int event_type,\n\t\t\t\t\t       u_int event_arg);\nstatic void\t\tahc_update_scsiid(struct ahc_softc *ahc,\n\t\t\t\t\t  u_int targid_mask);\nstatic int\t\tahc_handle_target_cmd(struct ahc_softc *ahc,\n\t\t\t\t\t      struct target_cmd *cmd);\n#endif\n\nstatic u_int\t\tahc_index_busy_tcl(struct ahc_softc *ahc, u_int tcl);\nstatic void\t\tahc_unbusy_tcl(struct ahc_softc *ahc, u_int tcl);\nstatic void\t\tahc_busy_tcl(struct ahc_softc *ahc,\n\t\t\t\t     u_int tcl, u_int busyid);\n\n \nstatic void\t\tahc_run_untagged_queues(struct ahc_softc *ahc);\nstatic void\t\tahc_run_untagged_queue(struct ahc_softc *ahc,\n\t\t\t\t\t       struct scb_tailq *queue);\n\n \nstatic void\t\t ahc_alloc_scbs(struct ahc_softc *ahc);\nstatic void\t\t ahc_shutdown(void *arg);\n\n \nstatic void\t\tahc_clear_intstat(struct ahc_softc *ahc);\nstatic void\t\tahc_run_qoutfifo(struct ahc_softc *ahc);\n#ifdef AHC_TARGET_MODE\nstatic void\t\tahc_run_tqinfifo(struct ahc_softc *ahc, int paused);\n#endif\nstatic void\t\tahc_handle_brkadrint(struct ahc_softc *ahc);\nstatic void\t\tahc_handle_seqint(struct ahc_softc *ahc, u_int intstat);\nstatic void\t\tahc_handle_scsiint(struct ahc_softc *ahc,\n\t\t\t\t\t   u_int intstat);\nstatic void\t\tahc_clear_critical_section(struct ahc_softc *ahc);\n\n \nstatic void\t\tahc_freeze_devq(struct ahc_softc *ahc, struct scb *scb);\nstatic int\t\tahc_abort_scbs(struct ahc_softc *ahc, int target,\n\t\t\t\t       char channel, int lun, u_int tag,\n\t\t\t\t       role_t role, uint32_t status);\nstatic void\t\tahc_calc_residual(struct ahc_softc *ahc,\n\t\t\t\t\t  struct scb *scb);\n\n \nstatic inline void\tahc_freeze_untagged_queues(struct ahc_softc *ahc);\nstatic inline void\tahc_release_untagged_queues(struct ahc_softc *ahc);\n\n \nstatic inline void\nahc_freeze_untagged_queues(struct ahc_softc *ahc)\n{\n\tif ((ahc->flags & AHC_SCB_BTT) == 0)\n\t\tahc->untagged_queue_lock++;\n}\n\n \nstatic inline void\nahc_release_untagged_queues(struct ahc_softc *ahc)\n{\n\tif ((ahc->flags & AHC_SCB_BTT) == 0) {\n\t\tahc->untagged_queue_lock--;\n\t\tif (ahc->untagged_queue_lock == 0)\n\t\t\tahc_run_untagged_queues(ahc);\n\t}\n}\n\n \n \nstatic void\nahc_pause_bug_fix(struct ahc_softc *ahc)\n{\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\t(void)ahc_inb(ahc, CCSCBCTL);\n}\n\n \nint\nahc_is_paused(struct ahc_softc *ahc)\n{\n\treturn ((ahc_inb(ahc, HCNTRL) & PAUSE) != 0);\n}\n\n \nvoid\nahc_pause(struct ahc_softc *ahc)\n{\n\tahc_outb(ahc, HCNTRL, ahc->pause);\n\n\t \n\twhile (ahc_is_paused(ahc) == 0)\n\t\t;\n\n\tahc_pause_bug_fix(ahc);\n}\n\n \nvoid\nahc_unpause(struct ahc_softc *ahc)\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}\n\n \nstatic struct ahc_dma_seg *\nahc_sg_bus_to_virt(struct scb *scb, uint32_t sg_busaddr)\n{\n\tint sg_index;\n\n\tsg_index = (sg_busaddr - scb->sg_list_phys)/sizeof(struct ahc_dma_seg);\n\t \n\tsg_index++;\n\n\treturn (&scb->sg_list[sg_index]);\n}\n\nstatic uint32_t\nahc_sg_virt_to_bus(struct scb *scb, struct ahc_dma_seg *sg)\n{\n\tint sg_index;\n\n\t \n\tsg_index = sg - &scb->sg_list[1];\n\n\treturn (scb->sg_list_phys + (sg_index * sizeof(*scb->sg_list)));\n}\n\nstatic uint32_t\nahc_hscb_busaddr(struct ahc_softc *ahc, u_int index)\n{\n\treturn (ahc->scb_data->hscb_busaddr\n\t\t+ (sizeof(struct hardware_scb) * index));\n}\n\nstatic void\nahc_sync_scb(struct ahc_softc *ahc, struct scb *scb, int op)\n{\n\tahc_dmamap_sync(ahc, ahc->scb_data->hscb_dmat,\n\t\t\tahc->scb_data->hscb_dmamap,\n\t\t\t (scb->hscb - ahc->hscbs) * sizeof(*scb->hscb),\n\t\t\t sizeof(*scb->hscb), op);\n}\n\nvoid\nahc_sync_sglist(struct ahc_softc *ahc, struct scb *scb, int op)\n{\n\tif (scb->sg_count == 0)\n\t\treturn;\n\n\tahc_dmamap_sync(ahc, ahc->scb_data->sg_dmat, scb->sg_map->sg_dmamap,\n\t\t\t (scb->sg_list - scb->sg_map->sg_vaddr)\n\t\t\t\t* sizeof(struct ahc_dma_seg),\n\t\t\t sizeof(struct ahc_dma_seg) * scb->sg_count, op);\n}\n\n#ifdef AHC_TARGET_MODE\nstatic uint32_t\nahc_targetcmd_offset(struct ahc_softc *ahc, u_int index)\n{\n\treturn (((uint8_t *)&ahc->targetcmds[index]) - ahc->qoutfifo);\n}\n#endif\n\n \n \nstatic void\nahc_update_residual(struct ahc_softc *ahc, struct scb *scb)\n{\n\tuint32_t sgptr;\n\n\tsgptr = ahc_le32toh(scb->hscb->sgptr);\n\tif ((sgptr & SG_RESID_VALID) != 0)\n\t\tahc_calc_residual(ahc, scb);\n}\n\n \nstruct ahc_initiator_tinfo *\nahc_fetch_transinfo(struct ahc_softc *ahc, char channel, u_int our_id,\n\t\t    u_int remote_id, struct ahc_tmode_tstate **tstate)\n{\n\t \n\tif (channel == 'B')\n\t\tour_id += 8;\n\t*tstate = ahc->enabled_targets[our_id];\n\treturn (&(*tstate)->transinfo[remote_id]);\n}\n\nuint16_t\nahc_inw(struct ahc_softc *ahc, u_int port)\n{\n\tuint16_t r = ahc_inb(ahc, port+1) << 8;\n\treturn r | ahc_inb(ahc, port);\n}\n\nvoid\nahc_outw(struct ahc_softc *ahc, u_int port, u_int value)\n{\n\tahc_outb(ahc, port, value & 0xFF);\n\tahc_outb(ahc, port+1, (value >> 8) & 0xFF);\n}\n\nuint32_t\nahc_inl(struct ahc_softc *ahc, u_int port)\n{\n\treturn ((ahc_inb(ahc, port))\n\t      | (ahc_inb(ahc, port+1) << 8)\n\t      | (ahc_inb(ahc, port+2) << 16)\n\t      | (ahc_inb(ahc, port+3) << 24));\n}\n\nvoid\nahc_outl(struct ahc_softc *ahc, u_int port, uint32_t value)\n{\n\tahc_outb(ahc, port, (value) & 0xFF);\n\tahc_outb(ahc, port+1, ((value) >> 8) & 0xFF);\n\tahc_outb(ahc, port+2, ((value) >> 16) & 0xFF);\n\tahc_outb(ahc, port+3, ((value) >> 24) & 0xFF);\n}\n\nuint64_t\nahc_inq(struct ahc_softc *ahc, u_int port)\n{\n\treturn ((ahc_inb(ahc, port))\n\t      | (ahc_inb(ahc, port+1) << 8)\n\t      | (ahc_inb(ahc, port+2) << 16)\n\t      | (((uint64_t)ahc_inb(ahc, port+3)) << 24)\n\t      | (((uint64_t)ahc_inb(ahc, port+4)) << 32)\n\t      | (((uint64_t)ahc_inb(ahc, port+5)) << 40)\n\t      | (((uint64_t)ahc_inb(ahc, port+6)) << 48)\n\t      | (((uint64_t)ahc_inb(ahc, port+7)) << 56));\n}\n\nvoid\nahc_outq(struct ahc_softc *ahc, u_int port, uint64_t value)\n{\n\tahc_outb(ahc, port, value & 0xFF);\n\tahc_outb(ahc, port+1, (value >> 8) & 0xFF);\n\tahc_outb(ahc, port+2, (value >> 16) & 0xFF);\n\tahc_outb(ahc, port+3, (value >> 24) & 0xFF);\n\tahc_outb(ahc, port+4, (value >> 32) & 0xFF);\n\tahc_outb(ahc, port+5, (value >> 40) & 0xFF);\n\tahc_outb(ahc, port+6, (value >> 48) & 0xFF);\n\tahc_outb(ahc, port+7, (value >> 56) & 0xFF);\n}\n\n \nstruct scb *\nahc_get_scb(struct ahc_softc *ahc)\n{\n\tstruct scb *scb;\n\n\tif ((scb = SLIST_FIRST(&ahc->scb_data->free_scbs)) == NULL) {\n\t\tahc_alloc_scbs(ahc);\n\t\tscb = SLIST_FIRST(&ahc->scb_data->free_scbs);\n\t\tif (scb == NULL)\n\t\t\treturn (NULL);\n\t}\n\tSLIST_REMOVE_HEAD(&ahc->scb_data->free_scbs, links.sle);\n\treturn (scb);\n}\n\n \nvoid\nahc_free_scb(struct ahc_softc *ahc, struct scb *scb)\n{\n\tstruct hardware_scb *hscb;\n\n\thscb = scb->hscb;\n\t \n\tahc->scb_data->scbindex[hscb->tag] = NULL;\n\tscb->flags = SCB_FREE;\n\thscb->control = 0;\n\n\tSLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, scb, links.sle);\n\n\t \n\tahc_platform_scb_free(ahc, scb);\n}\n\nstruct scb *\nahc_lookup_scb(struct ahc_softc *ahc, u_int tag)\n{\n\tstruct scb* scb;\n\n\tscb = ahc->scb_data->scbindex[tag];\n\tif (scb != NULL)\n\t\tahc_sync_scb(ahc, scb,\n\t\t\t     BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);\n\treturn (scb);\n}\n\nstatic void\nahc_swap_with_next_hscb(struct ahc_softc *ahc, struct scb *scb)\n{\n\tstruct hardware_scb *q_hscb;\n\tu_int  saved_tag;\n\n\t \n\tq_hscb = ahc->next_queued_scb->hscb;\n\tsaved_tag = q_hscb->tag;\n\tmemcpy(q_hscb, scb->hscb, sizeof(*scb->hscb));\n\tif ((scb->flags & SCB_CDB32_PTR) != 0) {\n\t\tq_hscb->shared_data.cdb_ptr =\n\t\t    ahc_htole32(ahc_hscb_busaddr(ahc, q_hscb->tag)\n\t\t\t      + offsetof(struct hardware_scb, cdb32));\n\t}\n\tq_hscb->tag = saved_tag;\n\tq_hscb->next = scb->hscb->tag;\n\n\t \n\tahc->next_queued_scb->hscb = scb->hscb;\n\tscb->hscb = q_hscb;\n\n\t \n\tahc->scb_data->scbindex[scb->hscb->tag] = scb;\n}\n\n \nvoid\nahc_queue_scb(struct ahc_softc *ahc, struct scb *scb)\n{\n\tahc_swap_with_next_hscb(ahc, scb);\n\n\tif (scb->hscb->tag == SCB_LIST_NULL\n\t || scb->hscb->next == SCB_LIST_NULL)\n\t\tpanic(\"Attempt to queue invalid SCB tag %x:%x\\n\",\n\t\t      scb->hscb->tag, scb->hscb->next);\n\n\t \n\tscb->hscb->lun &= LID;\n\tif (ahc_get_transfer_length(scb) & 0x1)\n\t\tscb->hscb->lun |= SCB_XFERLEN_ODD;\n\n\t \n\tahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;\n\n\t \n\tahc_sync_scb(ahc, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\n\n\t \n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t} else {\n\t\tif ((ahc->features & AHC_AUTOPAUSE) == 0)\n\t\t\tahc_pause(ahc);\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t\tif ((ahc->features & AHC_AUTOPAUSE) == 0)\n\t\t\tahc_unpause(ahc);\n\t}\n}\n\nstruct scsi_sense_data *\nahc_get_sense_buf(struct ahc_softc *ahc, struct scb *scb)\n{\n\tint offset;\n\n\toffset = scb - ahc->scb_data->scbarray;\n\treturn (&ahc->scb_data->sense[offset]);\n}\n\nstatic uint32_t\nahc_get_sense_bufaddr(struct ahc_softc *ahc, struct scb *scb)\n{\n\tint offset;\n\n\toffset = scb - ahc->scb_data->scbarray;\n\treturn (ahc->scb_data->sense_busaddr\n\t      + (offset * sizeof(struct scsi_sense_data)));\n}\n\n \nstatic void\nahc_sync_qoutfifo(struct ahc_softc *ahc, int op)\n{\n\tahc_dmamap_sync(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,\n\t\t\t 0,  256, op);\n}\n\nstatic void\nahc_sync_tqinfifo(struct ahc_softc *ahc, int op)\n{\n#ifdef AHC_TARGET_MODE\n\tif ((ahc->flags & AHC_TARGETROLE) != 0) {\n\t\tahc_dmamap_sync(ahc, ahc->shared_data_dmat,\n\t\t\t\tahc->shared_data_dmamap,\n\t\t\t\tahc_targetcmd_offset(ahc, 0),\n\t\t\t\tsizeof(struct target_cmd) * AHC_TMODE_CMDS,\n\t\t\t\top);\n\t}\n#endif\n}\n\n \n#define AHC_RUN_QOUTFIFO 0x1\n#define AHC_RUN_TQINFIFO 0x2\nstatic u_int\nahc_check_cmdcmpltqueues(struct ahc_softc *ahc)\n{\n\tu_int retval;\n\n\tretval = 0;\n\tahc_dmamap_sync(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,\n\t\t\t ahc->qoutfifonext,  1,\n\t\t\tBUS_DMASYNC_POSTREAD);\n\tif (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL)\n\t\tretval |= AHC_RUN_QOUTFIFO;\n#ifdef AHC_TARGET_MODE\n\tif ((ahc->flags & AHC_TARGETROLE) != 0\n\t && (ahc->flags & AHC_TQINFIFO_BLOCKED) == 0) {\n\t\tahc_dmamap_sync(ahc, ahc->shared_data_dmat,\n\t\t\t\tahc->shared_data_dmamap,\n\t\t\t\tahc_targetcmd_offset(ahc, ahc->tqinfifofnext),\n\t\t\t\t sizeof(struct target_cmd),\n\t\t\t\tBUS_DMASYNC_POSTREAD);\n\t\tif (ahc->targetcmds[ahc->tqinfifonext].cmd_valid != 0)\n\t\t\tretval |= AHC_RUN_TQINFIFO;\n\t}\n#endif\n\treturn (retval);\n}\n\n \nint\nahc_intr(struct ahc_softc *ahc)\n{\n\tu_int\tintstat;\n\n\tif ((ahc->pause & INTEN) == 0) {\n\t\t \n\t\treturn (0);\n\t}\n\t \n\tif ((ahc->flags & (AHC_ALL_INTERRUPTS|AHC_EDGE_INTERRUPT)) == 0\n\t && (ahc_check_cmdcmpltqueues(ahc) != 0))\n\t\tintstat = CMDCMPLT;\n\telse {\n\t\tintstat = ahc_inb(ahc, INTSTAT);\n\t}\n\n\tif ((intstat & INT_PEND) == 0) {\n#if AHC_PCI_CONFIG > 0\n\t\tif (ahc->unsolicited_ints > 500) {\n\t\t\tahc->unsolicited_ints = 0;\n\t\t\tif ((ahc->chip & AHC_PCI) != 0\n\t\t\t && (ahc_inb(ahc, ERROR) & PCIERRSTAT) != 0)\n\t\t\t\tahc->bus_intr(ahc);\n\t\t}\n#endif\n\t\tahc->unsolicited_ints++;\n\t\treturn (0);\n\t}\n\tahc->unsolicited_ints = 0;\n\n\tif (intstat & CMDCMPLT) {\n\t\tahc_outb(ahc, CLRINT, CLRCMDINT);\n\n\t\t \n\t\tahc_flush_device_writes(ahc);\n\t\tahc_run_qoutfifo(ahc);\n#ifdef AHC_TARGET_MODE\n\t\tif ((ahc->flags & AHC_TARGETROLE) != 0)\n\t\t\tahc_run_tqinfifo(ahc,  FALSE);\n#endif\n\t}\n\n\t \n\tif (intstat == 0xFF && (ahc->features & AHC_REMOVABLE) != 0) {\n\t\t \n\t} else if (intstat & BRKADRINT) {\n\t\tahc_handle_brkadrint(ahc);\n\t} else if ((intstat & (SEQINT|SCSIINT)) != 0) {\n\n\t\tahc_pause_bug_fix(ahc);\n\n\t\tif ((intstat & SEQINT) != 0)\n\t\t\tahc_handle_seqint(ahc, intstat);\n\n\t\tif ((intstat & SCSIINT) != 0)\n\t\t\tahc_handle_scsiint(ahc, intstat);\n\t}\n\treturn (1);\n}\n\n \n \nstatic void\nahc_restart(struct ahc_softc *ahc)\n{\n\tuint8_t\tsblkctl;\n\n\tahc_pause(ahc);\n\n\t \n\tahc_clear_msg_state(ahc);\n\n\tahc_outb(ahc, SCSISIGO, 0);\t\t \n\tahc_outb(ahc, MSG_OUT, NOP);\t \n\tahc_outb(ahc, SXFRCTL1, ahc_inb(ahc, SXFRCTL1) & ~BITBUCKET);\n\tahc_outb(ahc, LASTPHASE, P_BUSFREE);\n\tahc_outb(ahc, SAVED_SCSIID, 0xFF);\n\tahc_outb(ahc, SAVED_LUN, 0xFF);\n\n\t \n\tahc_outb(ahc, TQINPOS, ahc->tqinfifonext);\n\n\t \n\tahc_outb(ahc, SCSISEQ,\n\t\t ahc_inb(ahc, SCSISEQ_TEMPLATE) & (ENSELI|ENRSELI|ENAUTOATNP));\n\tif ((ahc->features & AHC_CMD_CHAN) != 0) {\n\t\t \n\t\tahc_outb(ahc, CCSCBCNT, 0);\n\t\tahc_outb(ahc, CCSGCTL, 0);\n\t\tahc_outb(ahc, CCSCBCTL, 0);\n\t}\n\t \n\tif ((ahc_inb(ahc, SEQ_FLAGS2) & SCB_DMA) != 0) {\n\t\tahc_add_curscb_to_free_list(ahc);\n\t\tahc_outb(ahc, SEQ_FLAGS2,\n\t\t\t ahc_inb(ahc, SEQ_FLAGS2) & ~SCB_DMA);\n\t}\n\n\t \n\tahc_outb(ahc, CLRINT, CLRSEQINT);\n\n\tahc_outb(ahc, MWI_RESIDUAL, 0);\n\tahc_outb(ahc, SEQCTL, ahc->seqctl);\n\tahc_outb(ahc, SEQADDR0, 0);\n\tahc_outb(ahc, SEQADDR1, 0);\n\n\t \n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tahc_outb(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));\n\n\tahc_unpause(ahc);\n}\n\n \nstatic void\nahc_run_qoutfifo(struct ahc_softc *ahc)\n{\n\tstruct scb *scb;\n\tu_int  scb_index;\n\n\tahc_sync_qoutfifo(ahc, BUS_DMASYNC_POSTREAD);\n\twhile (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL) {\n\n\t\tscb_index = ahc->qoutfifo[ahc->qoutfifonext];\n\t\tif ((ahc->qoutfifonext & 0x03) == 0x03) {\n\t\t\tu_int modnext;\n\n\t\t\t \n\t\t\tmodnext = ahc->qoutfifonext & ~0x3;\n\t\t\t*((uint32_t *)(&ahc->qoutfifo[modnext])) = 0xFFFFFFFFUL;\n\t\t\tahc_dmamap_sync(ahc, ahc->shared_data_dmat,\n\t\t\t\t\tahc->shared_data_dmamap,\n\t\t\t\t\t modnext,  4,\n\t\t\t\t\tBUS_DMASYNC_PREREAD);\n\t\t}\n\t\tahc->qoutfifonext++;\n\n\t\tscb = ahc_lookup_scb(ahc, scb_index);\n\t\tif (scb == NULL) {\n\t\t\tprintk(\"%s: WARNING no command for scb %d \"\n\t\t\t       \"(cmdcmplt)\\nQOUTPOS = %d\\n\",\n\t\t\t       ahc_name(ahc), scb_index,\n\t\t\t       (ahc->qoutfifonext - 1) & 0xFF);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tahc_update_residual(ahc, scb);\n\t\tahc_done(ahc, scb);\n\t}\n}\n\nstatic void\nahc_run_untagged_queues(struct ahc_softc *ahc)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tahc_run_untagged_queue(ahc, &ahc->untagged_queues[i]);\n}\n\nstatic void\nahc_run_untagged_queue(struct ahc_softc *ahc, struct scb_tailq *queue)\n{\n\tstruct scb *scb;\n\n\tif (ahc->untagged_queue_lock != 0)\n\t\treturn;\n\n\tif ((scb = TAILQ_FIRST(queue)) != NULL\n\t && (scb->flags & SCB_ACTIVE) == 0) {\n\t\tscb->flags |= SCB_ACTIVE;\n\t\tahc_queue_scb(ahc, scb);\n\t}\n}\n\n \nstatic void\nahc_handle_brkadrint(struct ahc_softc *ahc)\n{\n\t \n\tint i;\n\tint error;\n\n\terror = ahc_inb(ahc, ERROR);\n\tfor (i = 0; error != 1 && i < num_errors; i++)\n\t\terror >>= 1;\n\tprintk(\"%s: brkadrint, %s at seqaddr = 0x%x\\n\",\n\t       ahc_name(ahc), ahc_hard_errors[i].errmesg,\n\t       ahc_inb(ahc, SEQADDR0) |\n\t       (ahc_inb(ahc, SEQADDR1) << 8));\n\n\tahc_dump_card_state(ahc);\n\n\t \n\tahc_abort_scbs(ahc, CAM_TARGET_WILDCARD, ALL_CHANNELS,\n\t\t       CAM_LUN_WILDCARD, SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t       CAM_NO_HBA);\n\n\t \n\tahc_shutdown(ahc);\n}\n\nstatic void\nahc_handle_seqint(struct ahc_softc *ahc, u_int intstat)\n{\n\tstruct scb *scb;\n\tstruct ahc_devinfo devinfo;\n\n\tahc_fetch_devinfo(ahc, &devinfo);\n\n\t \n\tahc_outb(ahc, CLRINT, CLRSEQINT);\n\tswitch (intstat & SEQINT_MASK) {\n\tcase BAD_STATUS:\n\t{\n\t\tu_int  scb_index;\n\t\tstruct hardware_scb *hscb;\n\n\t\t \n\t\tahc_outb(ahc, RETURN_1, 0);\n\n\t\t \n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\tscb = ahc_lookup_scb(ahc, scb_index);\n\t\tif (scb == NULL) {\n\t\t\tahc_print_devinfo(ahc, &devinfo);\n\t\t\tprintk(\"ahc_intr - referenced scb \"\n\t\t\t       \"not valid during seqint 0x%x scb(%d)\\n\",\n\t\t\t       intstat, scb_index);\n\t\t\tahc_dump_card_state(ahc);\n\t\t\tpanic(\"for safety\");\n\t\t\tgoto unpause;\n\t\t}\n\n\t\thscb = scb->hscb;\n\n\t\t \n\t\tif ((scb->flags & SCB_SENSE) != 0) {\n\t\t\t \n\t\t\tscb->flags &= ~SCB_SENSE;\n\t\t\tahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);\n\t\t\tbreak;\n\t\t}\n\t\tahc_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);\n\t\t \n\t\tahc_freeze_devq(ahc, scb);\n\t\tahc_freeze_scb(scb);\n\t\tahc_set_scsi_status(scb, hscb->shared_data.status.scsi_status);\n\t\tswitch (hscb->shared_data.status.scsi_status) {\n\t\tcase SAM_STAT_GOOD:\n\t\t\tprintk(\"%s: Interrupted for status of 0???\\n\",\n\t\t\t       ahc_name(ahc));\n\t\t\tbreak;\n\t\tcase SAM_STAT_COMMAND_TERMINATED:\n\t\tcase SAM_STAT_CHECK_CONDITION:\n\t\t{\n\t\t\tstruct ahc_dma_seg *sg;\n\t\t\tstruct scsi_sense *sc;\n\t\t\tstruct ahc_initiator_tinfo *targ_info;\n\t\t\tstruct ahc_tmode_tstate *tstate;\n\t\t\tstruct ahc_transinfo *tinfo;\n#ifdef AHC_DEBUG\n\t\t\tif (ahc_debug & AHC_SHOW_SENSE) {\n\t\t\t\tahc_print_path(ahc, scb);\n\t\t\t\tprintk(\"SCB %d: requests Check Status\\n\",\n\t\t\t\t       scb->hscb->tag);\n\t\t\t}\n#endif\n\n\t\t\tif (ahc_perform_autosense(scb) == 0)\n\t\t\t\tbreak;\n\n\t\t\ttarg_info = ahc_fetch_transinfo(ahc,\n\t\t\t\t\t\t\tdevinfo.channel,\n\t\t\t\t\t\t\tdevinfo.our_scsiid,\n\t\t\t\t\t\t\tdevinfo.target,\n\t\t\t\t\t\t\t&tstate);\n\t\t\ttinfo = &targ_info->curr;\n\t\t\tsg = scb->sg_list;\n\t\t\tsc = (struct scsi_sense *)(&hscb->shared_data.cdb);\n\t\t\t \n\t\t\tahc_update_residual(ahc, scb);\n#ifdef AHC_DEBUG\n\t\t\tif (ahc_debug & AHC_SHOW_SENSE) {\n\t\t\t\tahc_print_path(ahc, scb);\n\t\t\t\tprintk(\"Sending Sense\\n\");\n\t\t\t}\n#endif\n\t\t\tsg->addr = ahc_get_sense_bufaddr(ahc, scb);\n\t\t\tsg->len = ahc_get_sense_bufsize(ahc, scb);\n\t\t\tsg->len |= AHC_DMA_LAST_SEG;\n\n\t\t\t \n\t\t\tsg->addr = ahc_htole32(sg->addr);\n\t\t\tsg->len = ahc_htole32(sg->len);\n\n\t\t\tsc->opcode = REQUEST_SENSE;\n\t\t\tsc->byte2 = 0;\n\t\t\tif (tinfo->protocol_version <= SCSI_REV_2\n\t\t\t && SCB_GET_LUN(scb) < 8)\n\t\t\t\tsc->byte2 = SCB_GET_LUN(scb) << 5;\n\t\t\tsc->unused[0] = 0;\n\t\t\tsc->unused[1] = 0;\n\t\t\tsc->length = sg->len;\n\t\t\tsc->control = 0;\n\n\t\t\t \n\t\t\thscb->control = 0;\n\n\t\t\t \n\t\t\tif (ahc_get_residual(scb)\n\t\t\t    == ahc_get_transfer_length(scb)) {\n\t\t\t\tahc_update_neg_request(ahc, &devinfo,\n\t\t\t\t\t\t       tstate, targ_info,\n\t\t\t\t\t\t       AHC_NEG_IF_NON_ASYNC);\n\t\t\t}\n\t\t\tif (tstate->auto_negotiate & devinfo.target_mask) {\n\t\t\t\thscb->control |= MK_MESSAGE;\n\t\t\t\tscb->flags &= ~SCB_NEGOTIATE;\n\t\t\t\tscb->flags |= SCB_AUTO_NEGOTIATE;\n\t\t\t}\n\t\t\thscb->cdb_len = sizeof(*sc);\n\t\t\thscb->dataptr = sg->addr;\n\t\t\thscb->datacnt = sg->len;\n\t\t\thscb->sgptr = scb->sg_list_phys | SG_FULL_RESID;\n\t\t\thscb->sgptr = ahc_htole32(hscb->sgptr);\n\t\t\tscb->sg_count = 1;\n\t\t\tscb->flags |= SCB_SENSE;\n\t\t\tahc_qinfifo_requeue_tail(ahc, scb);\n\t\t\tahc_outb(ahc, RETURN_1, SEND_SENSE);\n\t\t\t \n\t\t\tahc_scb_timer_reset(scb, 5 * 1000000);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase NO_MATCH:\n\t{\n\t\t \n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\n\t\tprintk(\"%s:%c:%d: no active SCB for reconnecting \"\n\t\t       \"target - issuing BUS DEVICE RESET\\n\",\n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target);\n\t\tprintk(\"SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, \"\n\t\t       \"ARG_1 == 0x%x ACCUM = 0x%x\\n\",\n\t\t       ahc_inb(ahc, SAVED_SCSIID), ahc_inb(ahc, SAVED_LUN),\n\t\t       ahc_inb(ahc, ARG_1), ahc_inb(ahc, ACCUM));\n\t\tprintk(\"SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, \"\n\t\t       \"SINDEX == 0x%x\\n\",\n\t\t       ahc_inb(ahc, SEQ_FLAGS), ahc_inb(ahc, SCBPTR),\n\t\t       ahc_index_busy_tcl(ahc,\n\t\t\t    BUILD_TCL(ahc_inb(ahc, SAVED_SCSIID),\n\t\t\t\t      ahc_inb(ahc, SAVED_LUN))),\n\t\t       ahc_inb(ahc, SINDEX));\n\t\tprintk(\"SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, \"\n\t\t       \"SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\\n\",\n\t\t       ahc_inb(ahc, SCSIID), ahc_inb(ahc, SCB_SCSIID),\n\t\t       ahc_inb(ahc, SCB_LUN), ahc_inb(ahc, SCB_TAG),\n\t\t       ahc_inb(ahc, SCB_CONTROL));\n\t\tprintk(\"SCSIBUSL == 0x%x, SCSISIGI == 0x%x\\n\",\n\t\t       ahc_inb(ahc, SCSIBUSL), ahc_inb(ahc, SCSISIGI));\n\t\tprintk(\"SXFRCTL0 == 0x%x\\n\", ahc_inb(ahc, SXFRCTL0));\n\t\tprintk(\"SEQCTL == 0x%x\\n\", ahc_inb(ahc, SEQCTL));\n\t\tahc_dump_card_state(ahc);\n\t\tahc->msgout_buf[0] = TARGET_RESET;\n\t\tahc->msgout_len = 1;\n\t\tahc->msgout_index = 0;\n\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\tahc_outb(ahc, MSG_OUT, HOST_MSG);\n\t\tahc_assert_atn(ahc);\n\t\tbreak;\n\t}\n\tcase SEND_REJECT:\n\t{\n\t\tu_int rejbyte = ahc_inb(ahc, ACCUM);\n\t\tprintk(\"%s:%c:%d: Warning - unknown message received from \"\n\t\t       \"target (0x%x).  Rejecting\\n\",\n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);\n\t\tbreak;\n\t}\n\tcase PROTO_VIOLATION:\n\t{\n\t\tahc_handle_proto_violation(ahc);\n\t\tbreak;\n\t}\n\tcase IGN_WIDE_RES:\n\t\tahc_handle_ign_wide_residue(ahc, &devinfo);\n\t\tbreak;\n\tcase PDATA_REINIT:\n\t\tahc_reinitialize_dataptrs(ahc);\n\t\tbreak;\n\tcase BAD_PHASE:\n\t{\n\t\tu_int lastphase;\n\n\t\tlastphase = ahc_inb(ahc, LASTPHASE);\n\t\tprintk(\"%s:%c:%d: unknown scsi bus phase %x, \"\n\t\t       \"lastphase = 0x%x.  Attempting to continue\\n\",\n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target,\n\t\t       lastphase, ahc_inb(ahc, SCSISIGI));\n\t\tbreak;\n\t}\n\tcase MISSED_BUSFREE:\n\t{\n\t\tu_int lastphase;\n\n\t\tlastphase = ahc_inb(ahc, LASTPHASE);\n\t\tprintk(\"%s:%c:%d: Missed busfree. \"\n\t\t       \"Lastphase = 0x%x, Curphase = 0x%x\\n\",\n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target,\n\t\t       lastphase, ahc_inb(ahc, SCSISIGI));\n\t\tahc_restart(ahc);\n\t\treturn;\n\t}\n\tcase HOST_MSG_LOOP:\n\t{\n\t\t \n\t\tif (ahc->msg_type == MSG_TYPE_NONE) {\n\t\t\tstruct scb *scb;\n\t\t\tu_int scb_index;\n\t\t\tu_int bus_phase;\n\n\t\t\tbus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\t\t\tif (bus_phase != P_MESGIN\n\t\t\t && bus_phase != P_MESGOUT) {\n\t\t\t\tprintk(\"ahc_intr: HOST_MSG_LOOP bad \"\n\t\t\t\t       \"phase 0x%x\\n\",\n\t\t\t\t      bus_phase);\n\t\t\t\t \n\t\t\t\tahc_clear_intstat(ahc);\n\t\t\t\tahc_restart(ahc);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\tscb = ahc_lookup_scb(ahc, scb_index);\n\t\t\tif (devinfo.role == ROLE_INITIATOR) {\n\t\t\t\tif (bus_phase == P_MESGOUT) {\n\t\t\t\t\tif (scb == NULL)\n\t\t\t\t\t\tpanic(\"HOST_MSG_LOOP with \"\n\t\t\t\t\t\t      \"invalid SCB %x\\n\",\n\t\t\t\t\t\t      scb_index);\n\n\t\t\t\t\tahc_setup_initiator_msgout(ahc,\n\t\t\t\t\t\t\t\t   &devinfo,\n\t\t\t\t\t\t\t\t   scb);\n\t\t\t\t} else {\n\t\t\t\t\tahc->msg_type =\n\t\t\t\t\t    MSG_TYPE_INITIATOR_MSGIN;\n\t\t\t\t\tahc->msgin_index = 0;\n\t\t\t\t}\n\t\t\t}\n#ifdef AHC_TARGET_MODE\n\t\t\telse {\n\t\t\t\tif (bus_phase == P_MESGOUT) {\n\t\t\t\t\tahc->msg_type =\n\t\t\t\t\t    MSG_TYPE_TARGET_MSGOUT;\n\t\t\t\t\tahc->msgin_index = 0;\n\t\t\t\t} else\n\t\t\t\t\tahc_setup_target_msgin(ahc,\n\t\t\t\t\t\t\t       &devinfo,\n\t\t\t\t\t\t\t       scb);\n\t\t\t}\n#endif\n\t\t}\n\n\t\tahc_handle_message_phase(ahc);\n\t\tbreak;\n\t}\n\tcase PERR_DETECTED:\n\t{\n\t\t \n\t\tif ((intstat & SCSIINT) == 0\n\t\t && (ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0) {\n\n\t\t\tif ((ahc->features & AHC_DT) == 0) {\n\t\t\t\tu_int curphase;\n\n\t\t\t\t \n\t\t\t\tcurphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\t\t\t\tahc_outb(ahc, LASTPHASE, curphase);\n\t\t\t\tahc_outb(ahc, SCSISIGO, curphase);\n\t\t\t}\n\t\t\tif ((ahc_inb(ahc, SCSISIGI) & (CDI|MSGI)) == 0) {\n\t\t\t\tint wait;\n\n\t\t\t\t \n\t\t\t\tahc_outb(ahc, SXFRCTL1,\n\t\t\t\t\t ahc_inb(ahc, SXFRCTL1) | BITBUCKET);\n\t\t\t\twait = 5000;\n\t\t\t\twhile (--wait != 0) {\n\t\t\t\t\tif ((ahc_inb(ahc, SCSISIGI)\n\t\t\t\t\t  & (CDI|MSGI)) != 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tahc_delay(100);\n\t\t\t\t}\n\t\t\t\tahc_outb(ahc, SXFRCTL1,\n\t\t\t\t\t ahc_inb(ahc, SXFRCTL1) & ~BITBUCKET);\n\t\t\t\tif (wait == 0) {\n\t\t\t\t\tstruct\tscb *scb;\n\t\t\t\t\tu_int\tscb_index;\n\n\t\t\t\t\tahc_print_devinfo(ahc, &devinfo);\n\t\t\t\t\tprintk(\"Unable to clear parity error.  \"\n\t\t\t\t\t       \"Resetting bus.\\n\");\n\t\t\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\t\t\tscb = ahc_lookup_scb(ahc, scb_index);\n\t\t\t\t\tif (scb != NULL)\n\t\t\t\t\t\tahc_set_transaction_status(scb,\n\t\t\t\t\t\t    CAM_UNCOR_PARITY);\n\t\t\t\t\tahc_reset_channel(ahc, devinfo.channel,\n\t\t\t\t\t\t\t   TRUE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tahc_inb(ahc, SCSIDATL);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase DATA_OVERRUN:\n\t{\n\t\t \n\t\tu_int scbindex = ahc_inb(ahc, SCB_TAG);\n\t\tu_int lastphase = ahc_inb(ahc, LASTPHASE);\n\t\tu_int i;\n\n\t\tscb = ahc_lookup_scb(ahc, scbindex);\n\t\tfor (i = 0; i < num_phases; i++) {\n\t\t\tif (lastphase == ahc_phase_table[i].phase)\n\t\t\t\tbreak;\n\t\t}\n\t\tahc_print_path(ahc, scb);\n\t\tprintk(\"data overrun detected %s.\"\n\t\t       \"  Tag == 0x%x.\\n\",\n\t\t       ahc_phase_table[i].phasemsg,\n\t\t       scb->hscb->tag);\n\t\tahc_print_path(ahc, scb);\n\t\tprintk(\"%s seen Data Phase.  Length = %ld.  NumSGs = %d.\\n\",\n\t\t       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? \"Have\" : \"Haven't\",\n\t\t       ahc_get_transfer_length(scb), scb->sg_count);\n\t\tif (scb->sg_count > 0) {\n\t\t\tfor (i = 0; i < scb->sg_count; i++) {\n\n\t\t\t\tprintk(\"sg[%d] - Addr 0x%x%x : Length %d\\n\",\n\t\t\t\t       i,\n\t\t\t\t       (ahc_le32toh(scb->sg_list[i].len) >> 24\n\t\t\t\t\t& SG_HIGH_ADDR_BITS),\n\t\t\t\t       ahc_le32toh(scb->sg_list[i].addr),\n\t\t\t\t       ahc_le32toh(scb->sg_list[i].len)\n\t\t\t\t       & AHC_SG_LEN_MASK);\n\t\t\t}\n\t\t}\n\t\t \n\t\tahc_freeze_devq(ahc, scb);\n\t\tif ((scb->flags & SCB_SENSE) == 0) {\n\t\t\tahc_set_transaction_status(scb, CAM_DATA_RUN_ERR);\n\t\t} else {\n\t\t\tscb->flags &= ~SCB_SENSE;\n\t\t\tahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);\n\t\t}\n\t\tahc_freeze_scb(scb);\n\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\t \n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) | CLRSTCNT|CLRCHN);\n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) | CLRSTCNT|CLRCHN);\n\t\t}\n\t\tif ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {\n\t\t\tu_int dscommand1;\n\n\t\t\t \n\t\t\tdscommand1 = ahc_inb(ahc, DSCOMMAND1);\n\t\t\tahc_outb(ahc, DSCOMMAND1, dscommand1 | HADDLDSEL0);\n\t\t\tahc_outb(ahc, HADDR, 0);\n\t\t\tahc_outb(ahc, DSCOMMAND1, dscommand1);\n\t\t}\n\t\tbreak;\n\t}\n\tcase MKMSG_FAILED:\n\t{\n\t\tu_int scbindex;\n\n\t\tprintk(\"%s:%c:%d:%d: Attempt to issue message failed\\n\",\n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target,\n\t\t       devinfo.lun);\n\t\tscbindex = ahc_inb(ahc, SCB_TAG);\n\t\tscb = ahc_lookup_scb(ahc, scbindex);\n\t\tif (scb != NULL\n\t\t && (scb->flags & SCB_RECOVERY_SCB) != 0)\n\t\t\t \n\t\t\tahc_search_qinfifo(ahc, SCB_GET_TARGET(ahc, scb),\n\t\t\t\t\t   SCB_GET_CHANNEL(ahc, scb),\n\t\t\t\t\t   SCB_GET_LUN(scb), scb->hscb->tag,\n\t\t\t\t\t   ROLE_INITIATOR,  0,\n\t\t\t\t\t   SEARCH_REMOVE);\n\t\tbreak;\n\t}\n\tcase NO_FREE_SCB:\n\t{\n\t\tprintk(\"%s: No free or disconnected SCBs\\n\", ahc_name(ahc));\n\t\tahc_dump_card_state(ahc);\n\t\tpanic(\"for safety\");\n\t\tbreak;\n\t}\n\tcase SCB_MISMATCH:\n\t{\n\t\tu_int scbptr;\n\n\t\tscbptr = ahc_inb(ahc, SCBPTR);\n\t\tprintk(\"Bogus TAG after DMA.  SCBPTR %d, tag %d, our tag %d\\n\",\n\t\t       scbptr, ahc_inb(ahc, ARG_1),\n\t\t       ahc->scb_data->hscbs[scbptr].tag);\n\t\tahc_dump_card_state(ahc);\n\t\tpanic(\"for safety\");\n\t\tbreak;\n\t}\n\tcase OUT_OF_RANGE:\n\t{\n\t\tprintk(\"%s: BTT calculation out of range\\n\", ahc_name(ahc));\n\t\tprintk(\"SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, \"\n\t\t       \"ARG_1 == 0x%x ACCUM = 0x%x\\n\",\n\t\t       ahc_inb(ahc, SAVED_SCSIID), ahc_inb(ahc, SAVED_LUN),\n\t\t       ahc_inb(ahc, ARG_1), ahc_inb(ahc, ACCUM));\n\t\tprintk(\"SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, \"\n\t\t       \"SINDEX == 0x%x\\n, A == 0x%x\\n\",\n\t\t       ahc_inb(ahc, SEQ_FLAGS), ahc_inb(ahc, SCBPTR),\n\t\t       ahc_index_busy_tcl(ahc,\n\t\t\t    BUILD_TCL(ahc_inb(ahc, SAVED_SCSIID),\n\t\t\t\t      ahc_inb(ahc, SAVED_LUN))),\n\t\t       ahc_inb(ahc, SINDEX),\n\t\t       ahc_inb(ahc, ACCUM));\n\t\tprintk(\"SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, \"\n\t\t       \"SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\\n\",\n\t\t       ahc_inb(ahc, SCSIID), ahc_inb(ahc, SCB_SCSIID),\n\t\t       ahc_inb(ahc, SCB_LUN), ahc_inb(ahc, SCB_TAG),\n\t\t       ahc_inb(ahc, SCB_CONTROL));\n\t\tprintk(\"SCSIBUSL == 0x%x, SCSISIGI == 0x%x\\n\",\n\t\t       ahc_inb(ahc, SCSIBUSL), ahc_inb(ahc, SCSISIGI));\n\t\tahc_dump_card_state(ahc);\n\t\tpanic(\"for safety\");\n\t\tbreak;\n\t}\n\tdefault:\n\t\tprintk(\"ahc_intr: seqint, \"\n\t\t       \"intstat == 0x%x, scsisigi = 0x%x\\n\",\n\t\t       intstat, ahc_inb(ahc, SCSISIGI));\n\t\tbreak;\n\t}\nunpause:\n\t \n\tahc_unpause(ahc);\n}\n\nstatic void\nahc_handle_scsiint(struct ahc_softc *ahc, u_int intstat)\n{\n\tu_int\tscb_index;\n\tu_int\tstatus0;\n\tu_int\tstatus;\n\tstruct\tscb *scb;\n\tchar\tcur_channel;\n\tchar\tintr_channel;\n\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))\n\t\tcur_channel = 'B';\n\telse\n\t\tcur_channel = 'A';\n\tintr_channel = cur_channel;\n\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tstatus0 = ahc_inb(ahc, SSTAT0) & IOERR;\n\telse\n\t\tstatus0 = 0;\n\tstatus = ahc_inb(ahc, SSTAT1) & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);\n\tif (status == 0 && status0 == 0) {\n\t\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\t\t \n\t\t\tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);\n\t\t\tstatus = ahc_inb(ahc, SSTAT1)\n\t\t\t       & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);\n\t\t\tintr_channel = (cur_channel == 'A') ? 'B' : 'A';\n\t\t}\n\t\tif (status == 0) {\n\t\t\tprintk(\"%s: Spurious SCSI interrupt\\n\", ahc_name(ahc));\n\t\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\t\tahc_unpause(ahc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tahc_clear_critical_section(ahc);\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tscb = ahc_lookup_scb(ahc, scb_index);\n\tif (scb != NULL\n\t && (ahc_inb(ahc, SEQ_FLAGS) & NOT_IDENTIFIED) != 0)\n\t\tscb = NULL;\n\n\tif ((ahc->features & AHC_ULTRA2) != 0\n\t && (status0 & IOERR) != 0) {\n\t\tint now_lvd;\n\n\t\tnow_lvd = ahc_inb(ahc, SBLKCTL) & ENAB40;\n\t\tprintk(\"%s: Transceiver State Has Changed to %s mode\\n\",\n\t\t       ahc_name(ahc), now_lvd ? \"LVD\" : \"SE\");\n\t\tahc_outb(ahc, CLRSINT0, CLRIOERR);\n\t\t \n\t\tahc_reset_channel(ahc, intr_channel,\n\t\t\t\t  now_lvd == 0);\n\t} else if ((status & SCSIRSTI) != 0) {\n\t\tprintk(\"%s: Someone reset channel %c\\n\",\n\t\t\tahc_name(ahc), intr_channel);\n\t\tif (intr_channel != cur_channel)\n\t\t\tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);\n\t\tahc_reset_channel(ahc, intr_channel,  FALSE);\n\t} else if ((status & SCSIPERR) != 0) {\n\t\t \n\t\tstruct\tahc_devinfo devinfo;\n\t\tu_int\tmesg_out;\n\t\tu_int\tcurphase;\n\t\tu_int\terrorphase;\n\t\tu_int\tlastphase;\n\t\tu_int\tscsirate;\n\t\tu_int\ti;\n\t\tu_int\tsstat2;\n\t\tint\tsilent;\n\n\t\tlastphase = ahc_inb(ahc, LASTPHASE);\n\t\tcurphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\t\tsstat2 = ahc_inb(ahc, SSTAT2);\n\t\tahc_outb(ahc, CLRSINT1, CLRSCSIPERR);\n\t\t \n\t\tif ((ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0\n\t\t || curphase == P_DATAIN || curphase == P_DATAIN_DT)\n\t\t\terrorphase = curphase;\n\t\telse\n\t\t\terrorphase = lastphase;\n\n\t\tfor (i = 0; i < num_phases; i++) {\n\t\t\tif (errorphase == ahc_phase_table[i].phase)\n\t\t\t\tbreak;\n\t\t}\n\t\tmesg_out = ahc_phase_table[i].mesg_out;\n\t\tsilent = FALSE;\n\t\tif (scb != NULL) {\n\t\t\tif (SCB_IS_SILENT(scb))\n\t\t\t\tsilent = TRUE;\n\t\t\telse\n\t\t\t\tahc_print_path(ahc, scb);\n\t\t\tscb->flags |= SCB_TRANSMISSION_ERROR;\n\t\t} else\n\t\t\tprintk(\"%s:%c:%d: \", ahc_name(ahc), intr_channel,\n\t\t\t       SCSIID_TARGET(ahc, ahc_inb(ahc, SAVED_SCSIID)));\n\t\tscsirate = ahc_inb(ahc, SCSIRATE);\n\t\tif (silent == FALSE) {\n\t\t\tprintk(\"parity error detected %s. \"\n\t\t\t       \"SEQADDR(0x%x) SCSIRATE(0x%x)\\n\",\n\t\t\t       ahc_phase_table[i].phasemsg,\n\t\t\t       ahc_inw(ahc, SEQADDR0),\n\t\t\t       scsirate);\n\t\t\tif ((ahc->features & AHC_DT) != 0) {\n\t\t\t\tif ((sstat2 & CRCVALERR) != 0)\n\t\t\t\t\tprintk(\"\\tCRC Value Mismatch\\n\");\n\t\t\t\tif ((sstat2 & CRCENDERR) != 0)\n\t\t\t\t\tprintk(\"\\tNo terminal CRC packet \"\n\t\t\t\t\t       \"received\\n\");\n\t\t\t\tif ((sstat2 & CRCREQERR) != 0)\n\t\t\t\t\tprintk(\"\\tIllegal CRC packet \"\n\t\t\t\t\t       \"request\\n\");\n\t\t\t\tif ((sstat2 & DUAL_EDGE_ERR) != 0)\n\t\t\t\t\tprintk(\"\\tUnexpected %sDT Data Phase\\n\",\n\t\t\t\t\t       (scsirate & SINGLE_EDGE)\n\t\t\t\t\t     ? \"\" : \"non-\");\n\t\t\t}\n\t\t}\n\n\t\tif ((ahc->features & AHC_DT) != 0\n\t\t && (sstat2 & DUAL_EDGE_ERR) != 0) {\n\t\t\t \n\t\t\tmesg_out = INITIATOR_ERROR;\n\t\t}\n\n\t\t \n\t\tif (mesg_out != NOP) {\n\t\t\tif (ahc->msg_type != MSG_TYPE_NONE)\n\t\t\t\tahc->send_msg_perror = TRUE;\n\t\t\telse\n\t\t\t\tahc_outb(ahc, MSG_OUT, mesg_out);\n\t\t}\n\t\t \n\t\tahc_fetch_devinfo(ahc, &devinfo);\n\t\tahc_force_renegotiation(ahc, &devinfo);\n\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\tahc_unpause(ahc);\n\t} else if ((status & SELTO) != 0) {\n\t\tu_int\tscbptr;\n\n\t\t \n\t\tahc_outb(ahc, SCSISEQ, 0);\n\n\t\t \n\t\tahc_clear_msg_state(ahc);\n\n\t\t \n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);\n\n\t\t \n\t\tahc_outb(ahc, CLRSINT0, CLRSELINGO);\n\n\t\tscbptr = ahc_inb(ahc, WAITING_SCBH);\n\t\tahc_outb(ahc, SCBPTR, scbptr);\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\n\t\tscb = ahc_lookup_scb(ahc, scb_index);\n\t\tif (scb == NULL) {\n\t\t\tprintk(\"%s: ahc_intr - referenced scb not \"\n\t\t\t       \"valid during SELTO scb(%d, %d)\\n\",\n\t\t\t       ahc_name(ahc), scbptr, scb_index);\n\t\t\tahc_dump_card_state(ahc);\n\t\t} else {\n\t\t\tstruct ahc_devinfo devinfo;\n#ifdef AHC_DEBUG\n\t\t\tif ((ahc_debug & AHC_SHOW_SELTO) != 0) {\n\t\t\t\tahc_print_path(ahc, scb);\n\t\t\t\tprintk(\"Saw Selection Timeout for SCB 0x%x\\n\",\n\t\t\t\t       scb_index);\n\t\t\t}\n#endif\n\t\t\tahc_scb_devinfo(ahc, &devinfo, scb);\n\t\t\tahc_set_transaction_status(scb, CAM_SEL_TIMEOUT);\n\t\t\tahc_freeze_devq(ahc, scb);\n\n\t\t\t \n\t\t\tahc_handle_devreset(ahc, &devinfo,\n\t\t\t\t\t    CAM_SEL_TIMEOUT,\n\t\t\t\t\t    \"Selection Timeout\",\n\t\t\t\t\t     1);\n\t\t}\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\tahc_restart(ahc);\n\t} else if ((status & BUSFREE) != 0\n\t\t&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {\n\t\tstruct\tahc_devinfo devinfo;\n\t\tu_int\tlastphase;\n\t\tu_int\tsaved_scsiid;\n\t\tu_int\tsaved_lun;\n\t\tu_int\ttarget;\n\t\tu_int\tinitiator_role_id;\n\t\tchar\tchannel;\n\t\tint\tprinterror;\n\n\t\t \n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\n\t\t \n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, CLRSINT1, CLRBUSFREE|CLRSCSIPERR);\n\n\t\t \n\t\tlastphase = ahc_inb(ahc, LASTPHASE);\n\t\tsaved_scsiid = ahc_inb(ahc, SAVED_SCSIID);\n\t\tsaved_lun = ahc_inb(ahc, SAVED_LUN);\n\t\ttarget = SCSIID_TARGET(ahc, saved_scsiid);\n\t\tinitiator_role_id = SCSIID_OUR_ID(saved_scsiid);\n\t\tchannel = SCSIID_CHANNEL(ahc, saved_scsiid);\n\t\tahc_compile_devinfo(&devinfo, initiator_role_id,\n\t\t\t\t    target, saved_lun, channel, ROLE_INITIATOR);\n\t\tprinterror = 1;\n\n\t\tif (lastphase == P_MESGOUT) {\n\t\t\tu_int tag;\n\n\t\t\ttag = SCB_LIST_NULL;\n\t\t\tif (ahc_sent_msg(ahc, AHCMSG_1B, ABORT_TASK, TRUE)\n\t\t\t || ahc_sent_msg(ahc, AHCMSG_1B, ABORT_TASK_SET, TRUE)) {\n\t\t\t\tif (ahc->msgout_buf[ahc->msgout_index - 1]\n\t\t\t\t == ABORT_TASK)\n\t\t\t\t\ttag = scb->hscb->tag;\n\t\t\t\tahc_print_path(ahc, scb);\n\t\t\t\tprintk(\"SCB %d - Abort%s Completed.\\n\",\n\t\t\t\t       scb->hscb->tag, tag == SCB_LIST_NULL ?\n\t\t\t\t       \"\" : \" Tag\");\n\t\t\t\tahc_abort_scbs(ahc, target, channel,\n\t\t\t\t\t       saved_lun, tag,\n\t\t\t\t\t       ROLE_INITIATOR,\n\t\t\t\t\t       CAM_REQ_ABORTED);\n\t\t\t\tprinterror = 0;\n\t\t\t} else if (ahc_sent_msg(ahc, AHCMSG_1B,\n\t\t\t\t\t\tTARGET_RESET, TRUE)) {\n\t\t\t\tahc_compile_devinfo(&devinfo,\n\t\t\t\t\t\t    initiator_role_id,\n\t\t\t\t\t\t    target,\n\t\t\t\t\t\t    CAM_LUN_WILDCARD,\n\t\t\t\t\t\t    channel,\n\t\t\t\t\t\t    ROLE_INITIATOR);\n\t\t\t\tahc_handle_devreset(ahc, &devinfo,\n\t\t\t\t\t\t    CAM_BDR_SENT,\n\t\t\t\t\t\t    \"Bus Device Reset\",\n\t\t\t\t\t\t     0);\n\t\t\t\tprinterror = 0;\n\t\t\t} else if (ahc_sent_msg(ahc, AHCMSG_EXT,\n\t\t\t\t\t\tEXTENDED_PPR, FALSE)) {\n\t\t\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\t\t\tstruct ahc_tmode_tstate *tstate;\n\n\t\t\t\t \n\t\t\t\ttinfo = ahc_fetch_transinfo(ahc,\n\t\t\t\t\t\t\t    devinfo.channel,\n\t\t\t\t\t\t\t    devinfo.our_scsiid,\n\t\t\t\t\t\t\t    devinfo.target,\n\t\t\t\t\t\t\t    &tstate);\n\t\t\t\ttinfo->curr.transport_version = 2;\n\t\t\t\ttinfo->goal.transport_version = 2;\n\t\t\t\ttinfo->goal.ppr_options = 0;\n\t\t\t\tahc_qinfifo_requeue_tail(ahc, scb);\n\t\t\t\tprinterror = 0;\n\t\t\t} else if (ahc_sent_msg(ahc, AHCMSG_EXT,\n\t\t\t\t\t\tEXTENDED_WDTR, FALSE)) {\n\t\t\t\t \n\t\t\t\tahc_set_width(ahc, &devinfo,\n\t\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t\t      AHC_TRANS_CUR|AHC_TRANS_GOAL,\n\t\t\t\t\t       TRUE);\n\t\t\t\tahc_qinfifo_requeue_tail(ahc, scb);\n\t\t\t\tprinterror = 0;\n\t\t\t} else if (ahc_sent_msg(ahc, AHCMSG_EXT,\n\t\t\t\t\t\tEXTENDED_SDTR, FALSE)) {\n\t\t\t\t \n\t\t\t\tahc_set_syncrate(ahc, &devinfo,\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t 0,  0,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\tAHC_TRANS_CUR|AHC_TRANS_GOAL,\n\t\t\t\t\t\t TRUE);\n\t\t\t\tahc_qinfifo_requeue_tail(ahc, scb);\n\t\t\t\tprinterror = 0;\n\t\t\t}\n\t\t}\n\t\tif (printerror != 0) {\n\t\t\tu_int i;\n\n\t\t\tif (scb != NULL) {\n\t\t\t\tu_int tag;\n\n\t\t\t\tif ((scb->hscb->control & TAG_ENB) != 0)\n\t\t\t\t\ttag = scb->hscb->tag;\n\t\t\t\telse\n\t\t\t\t\ttag = SCB_LIST_NULL;\n\t\t\t\tahc_print_path(ahc, scb);\n\t\t\t\tahc_abort_scbs(ahc, target, channel,\n\t\t\t\t\t       SCB_GET_LUN(scb), tag,\n\t\t\t\t\t       ROLE_INITIATOR,\n\t\t\t\t\t       CAM_UNEXP_BUSFREE);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tprintk(\"%s: \", ahc_name(ahc));\n\t\t\t}\n\t\t\tfor (i = 0; i < num_phases; i++) {\n\t\t\t\tif (lastphase == ahc_phase_table[i].phase)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (lastphase != P_BUSFREE) {\n\t\t\t\t \n\t\t\t\tahc_force_renegotiation(ahc, &devinfo);\n\t\t\t}\n\t\t\tprintk(\"Unexpected busfree %s\\n\"\n\t\t\t       \"SEQADDR == 0x%x\\n\",\n\t\t\t       ahc_phase_table[i].phasemsg,\n\t\t\t       ahc_inb(ahc, SEQADDR0)\n\t\t\t\t| (ahc_inb(ahc, SEQADDR1) << 8));\n\t\t}\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\tahc_restart(ahc);\n\t} else {\n\t\tprintk(\"%s: Missing case in ahc_handle_scsiint. status = %x\\n\",\n\t\t       ahc_name(ahc), status);\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t}\n}\n\n \nstatic void\nahc_force_renegotiation(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\n{\n\tstruct\tahc_initiator_tinfo *targ_info;\n\tstruct\tahc_tmode_tstate *tstate;\n\n\ttarg_info = ahc_fetch_transinfo(ahc,\n\t\t\t\t\tdevinfo->channel,\n\t\t\t\t\tdevinfo->our_scsiid,\n\t\t\t\t\tdevinfo->target,\n\t\t\t\t\t&tstate);\n\tahc_update_neg_request(ahc, devinfo, tstate,\n\t\t\t       targ_info, AHC_NEG_IF_NON_ASYNC);\n}\n\n#define AHC_MAX_STEPS 2000\nstatic void\nahc_clear_critical_section(struct ahc_softc *ahc)\n{\n\tint\tstepping;\n\tint\tsteps;\n\tu_int\tsimode0;\n\tu_int\tsimode1;\n\n\tif (ahc->num_critical_sections == 0)\n\t\treturn;\n\n\tstepping = FALSE;\n\tsteps = 0;\n\tsimode0 = 0;\n\tsimode1 = 0;\n\tfor (;;) {\n\t\tstruct\tcs *cs;\n\t\tu_int\tseqaddr;\n\t\tu_int\ti;\n\n\t\tseqaddr = ahc_inb(ahc, SEQADDR0)\n\t\t\t| (ahc_inb(ahc, SEQADDR1) << 8);\n\n\t\t \n\t\tif (seqaddr != 0)\n\t\t\tseqaddr -= 1;\n\t\tcs = ahc->critical_sections;\n\t\tfor (i = 0; i < ahc->num_critical_sections; i++, cs++) {\n\t\t\tif (cs->begin < seqaddr && cs->end >= seqaddr)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == ahc->num_critical_sections)\n\t\t\tbreak;\n\n\t\tif (steps > AHC_MAX_STEPS) {\n\t\t\tprintk(\"%s: Infinite loop in critical section\\n\",\n\t\t\t       ahc_name(ahc));\n\t\t\tahc_dump_card_state(ahc);\n\t\t\tpanic(\"critical section loop\");\n\t\t}\n\n\t\tsteps++;\n\t\tif (stepping == FALSE) {\n\n\t\t\t \n\t\t\tsimode0 = ahc_inb(ahc, SIMODE0);\n\t\t\tahc_outb(ahc, SIMODE0, 0);\n\t\t\tsimode1 = ahc_inb(ahc, SIMODE1);\n\t\t\tif ((ahc->features & AHC_DT) != 0)\n\t\t\t\t \n\t\t\t\tahc_outb(ahc, SIMODE1, simode1 & ENBUSFREE);\n\t\t\telse\n\t\t\t\tahc_outb(ahc, SIMODE1, 0);\n\t\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\t\tahc_outb(ahc, SEQCTL, ahc->seqctl | STEP);\n\t\t\tstepping = TRUE;\n\t\t}\n\t\tif ((ahc->features & AHC_DT) != 0) {\n\t\t\tahc_outb(ahc, CLRSINT1, CLRBUSFREE);\n\t\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\t}\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n\t\twhile (!ahc_is_paused(ahc))\n\t\t\tahc_delay(200);\n\t}\n\tif (stepping) {\n\t\tahc_outb(ahc, SIMODE0, simode0);\n\t\tahc_outb(ahc, SIMODE1, simode1);\n\t\tahc_outb(ahc, SEQCTL, ahc->seqctl);\n\t}\n}\n\n \nstatic void\nahc_clear_intstat(struct ahc_softc *ahc)\n{\n\t \n\tahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI\n\t\t\t\t|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|\n\t\t\t\tCLRREQINIT);\n\tahc_flush_device_writes(ahc);\n\tahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);\n\tahc_flush_device_writes(ahc);\n\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\tahc_flush_device_writes(ahc);\n}\n\n \n#ifdef AHC_DEBUG\nuint32_t ahc_debug = AHC_DEBUG_OPTS;\n#endif\n\n#if 0  \nstatic void\nahc_print_scb(struct scb *scb)\n{\n\tint i;\n\n\tstruct hardware_scb *hscb = scb->hscb;\n\n\tprintk(\"scb:%p control:0x%x scsiid:0x%x lun:%d cdb_len:%d\\n\",\n\t       (void *)scb,\n\t       hscb->control,\n\t       hscb->scsiid,\n\t       hscb->lun,\n\t       hscb->cdb_len);\n\tprintk(\"Shared Data: \");\n\tfor (i = 0; i < sizeof(hscb->shared_data.cdb); i++)\n\t\tprintk(\"%#02x\", hscb->shared_data.cdb[i]);\n\tprintk(\"        dataptr:%#x datacnt:%#x sgptr:%#x tag:%#x\\n\",\n\t\tahc_le32toh(hscb->dataptr),\n\t\tahc_le32toh(hscb->datacnt),\n\t\tahc_le32toh(hscb->sgptr),\n\t\thscb->tag);\n\tif (scb->sg_count > 0) {\n\t\tfor (i = 0; i < scb->sg_count; i++) {\n\t\t\tprintk(\"sg[%d] - Addr 0x%x%x : Length %d\\n\",\n\t\t\t       i,\n\t\t\t       (ahc_le32toh(scb->sg_list[i].len) >> 24\n\t\t\t\t& SG_HIGH_ADDR_BITS),\n\t\t\t       ahc_le32toh(scb->sg_list[i].addr),\n\t\t\t       ahc_le32toh(scb->sg_list[i].len));\n\t\t}\n\t}\n}\n#endif\n\n \n \nstatic struct ahc_tmode_tstate *\nahc_alloc_tstate(struct ahc_softc *ahc, u_int scsi_id, char channel)\n{\n\tstruct ahc_tmode_tstate *master_tstate;\n\tstruct ahc_tmode_tstate *tstate;\n\tint i;\n\n\tmaster_tstate = ahc->enabled_targets[ahc->our_id];\n\tif (channel == 'B') {\n\t\tscsi_id += 8;\n\t\tmaster_tstate = ahc->enabled_targets[ahc->our_id_b + 8];\n\t}\n\tif (ahc->enabled_targets[scsi_id] != NULL\n\t && ahc->enabled_targets[scsi_id] != master_tstate)\n\t\tpanic(\"%s: ahc_alloc_tstate - Target already allocated\",\n\t\t      ahc_name(ahc));\n\ttstate = kmalloc(sizeof(*tstate), GFP_ATOMIC);\n\tif (tstate == NULL)\n\t\treturn (NULL);\n\n\t \n\tif (master_tstate != NULL) {\n\t\tmemcpy(tstate, master_tstate, sizeof(*tstate));\n\t\tmemset(tstate->enabled_luns, 0, sizeof(tstate->enabled_luns));\n\t\ttstate->ultraenb = 0;\n\t\tfor (i = 0; i < AHC_NUM_TARGETS; i++) {\n\t\t\tmemset(&tstate->transinfo[i].curr, 0,\n\t\t\t      sizeof(tstate->transinfo[i].curr));\n\t\t\tmemset(&tstate->transinfo[i].goal, 0,\n\t\t\t      sizeof(tstate->transinfo[i].goal));\n\t\t}\n\t} else\n\t\tmemset(tstate, 0, sizeof(*tstate));\n\tahc->enabled_targets[scsi_id] = tstate;\n\treturn (tstate);\n}\n\n#ifdef AHC_TARGET_MODE\n \nstatic void\nahc_free_tstate(struct ahc_softc *ahc, u_int scsi_id, char channel, int force)\n{\n\tstruct ahc_tmode_tstate *tstate;\n\n\t \n\tif (((channel == 'B' && scsi_id == ahc->our_id_b)\n\t  || (channel == 'A' && scsi_id == ahc->our_id))\n\t && force == FALSE)\n\t\treturn;\n\n\tif (channel == 'B')\n\t\tscsi_id += 8;\n\ttstate = ahc->enabled_targets[scsi_id];\n\tkfree(tstate);\n\tahc->enabled_targets[scsi_id] = NULL;\n}\n#endif\n\n \nstatic const struct ahc_syncrate *\nahc_devlimited_syncrate(struct ahc_softc *ahc,\n\t\t\tstruct ahc_initiator_tinfo *tinfo,\n\t\t\tu_int *period, u_int *ppr_options, role_t role)\n{\n\tstruct\tahc_transinfo *transinfo;\n\tu_int\tmaxsync;\n\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tif ((ahc_inb(ahc, SBLKCTL) & ENAB40) != 0\n\t\t && (ahc_inb(ahc, SSTAT2) & EXP_ACTIVE) == 0) {\n\t\t\tmaxsync = AHC_SYNCRATE_DT;\n\t\t} else {\n\t\t\tmaxsync = AHC_SYNCRATE_ULTRA;\n\t\t\t \n\t\t\t*ppr_options &= ~MSG_EXT_PPR_DT_REQ;\n\t\t}\n\t} else if ((ahc->features & AHC_ULTRA) != 0) {\n\t\tmaxsync = AHC_SYNCRATE_ULTRA;\n\t} else {\n\t\tmaxsync = AHC_SYNCRATE_FAST;\n\t}\n\t \n\tif (role == ROLE_TARGET)\n\t\ttransinfo = &tinfo->user;\n\telse\n\t\ttransinfo = &tinfo->goal;\n\t*ppr_options &= transinfo->ppr_options;\n\tif (transinfo->width == MSG_EXT_WDTR_BUS_8_BIT) {\n\t\tmaxsync = max(maxsync, (u_int)AHC_SYNCRATE_ULTRA2);\n\t\t*ppr_options &= ~MSG_EXT_PPR_DT_REQ;\n\t}\n\tif (transinfo->period == 0) {\n\t\t*period = 0;\n\t\t*ppr_options = 0;\n\t\treturn (NULL);\n\t}\n\t*period = max(*period, (u_int)transinfo->period);\n\treturn (ahc_find_syncrate(ahc, period, ppr_options, maxsync));\n}\n\n \nconst struct ahc_syncrate *\nahc_find_syncrate(struct ahc_softc *ahc, u_int *period,\n\t\t  u_int *ppr_options, u_int maxsync)\n{\n\tconst struct ahc_syncrate *syncrate;\n\n\tif ((ahc->features & AHC_DT) == 0)\n\t\t*ppr_options &= ~MSG_EXT_PPR_DT_REQ;\n\n\t \n\tif ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0\n\t && maxsync < AHC_SYNCRATE_ULTRA2)\n\t\tmaxsync = AHC_SYNCRATE_ULTRA2;\n\n\t \n\tif ((ahc->features & (AHC_DT | AHC_ULTRA2)) == 0\n\t    && maxsync < AHC_SYNCRATE_ULTRA)\n\t\tmaxsync = AHC_SYNCRATE_ULTRA;\n\tif ((ahc->features & (AHC_DT | AHC_ULTRA2 | AHC_ULTRA)) == 0\n\t    && maxsync < AHC_SYNCRATE_FAST)\n\t\tmaxsync = AHC_SYNCRATE_FAST;\n\n\tfor (syncrate = &ahc_syncrates[maxsync];\n\t     syncrate->rate != NULL;\n\t     syncrate++) {\n\n\t\t \n\t\tif ((ahc->features & AHC_ULTRA2) != 0\n\t\t && (syncrate->sxfr_u2 == 0))\n\t\t\tbreak;\n\n\t\tif (*period <= syncrate->period) {\n\t\t\t \n\t\t\tif (syncrate == &ahc_syncrates[maxsync])\n\t\t\t\t*period = syncrate->period;\n\n\t\t\t \n\t\t\tif ((syncrate->sxfr_u2 & ST_SXFR) != 0)\n\t\t\t\t*ppr_options &= ~MSG_EXT_PPR_DT_REQ;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((*period == 0)\n\t || (syncrate->rate == NULL)\n\t || ((ahc->features & AHC_ULTRA2) != 0\n\t  && (syncrate->sxfr_u2 == 0))) {\n\t\t \n\t\t*period = 0;\n\t\tsyncrate = NULL;\n\t\t*ppr_options &= ~MSG_EXT_PPR_DT_REQ;\n\t}\n\treturn (syncrate);\n}\n\n \nu_int\nahc_find_period(struct ahc_softc *ahc, u_int scsirate, u_int maxsync)\n{\n\tconst struct ahc_syncrate *syncrate;\n\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tscsirate &= SXFR_ULTRA2;\n\telse\n\t\tscsirate &= SXFR;\n\n\t \n\tif ((ahc->features & AHC_DT) == 0 && maxsync < AHC_SYNCRATE_ULTRA2)\n\t\tmaxsync = AHC_SYNCRATE_ULTRA2;\n\tif ((ahc->features & (AHC_DT | AHC_ULTRA2)) == 0\n\t    && maxsync < AHC_SYNCRATE_ULTRA)\n\t\tmaxsync = AHC_SYNCRATE_ULTRA;\n\tif ((ahc->features & (AHC_DT | AHC_ULTRA2 | AHC_ULTRA)) == 0\n\t    && maxsync < AHC_SYNCRATE_FAST)\n\t\tmaxsync = AHC_SYNCRATE_FAST;\n\n\n\tsyncrate = &ahc_syncrates[maxsync];\n\twhile (syncrate->rate != NULL) {\n\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tif (syncrate->sxfr_u2 == 0)\n\t\t\t\tbreak;\n\t\t\telse if (scsirate == (syncrate->sxfr_u2 & SXFR_ULTRA2))\n\t\t\t\treturn (syncrate->period);\n\t\t} else if (scsirate == (syncrate->sxfr & SXFR)) {\n\t\t\t\treturn (syncrate->period);\n\t\t}\n\t\tsyncrate++;\n\t}\n\treturn (0);  \n}\n\n \nstatic void\nahc_validate_offset(struct ahc_softc *ahc,\n\t\t    struct ahc_initiator_tinfo *tinfo,\n\t\t    const struct ahc_syncrate *syncrate,\n\t\t    u_int *offset, int wide, role_t role)\n{\n\tu_int maxoffset;\n\n\t \n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = min(*offset, maxoffset);\n\tif (tinfo != NULL) {\n\t\tif (role == ROLE_TARGET)\n\t\t\t*offset = min(*offset, (u_int)tinfo->user.offset);\n\t\telse\n\t\t\t*offset = min(*offset, (u_int)tinfo->goal.offset);\n\t}\n}\n\n \nstatic void\nahc_validate_width(struct ahc_softc *ahc, struct ahc_initiator_tinfo *tinfo,\n\t\t   u_int *bus_width, role_t role)\n{\n\tswitch (*bus_width) {\n\tdefault:\n\t\tif (ahc->features & AHC_WIDE) {\n\t\t\t \n\t\t\t*bus_width = MSG_EXT_WDTR_BUS_16_BIT;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase MSG_EXT_WDTR_BUS_8_BIT:\n\t\t*bus_width = MSG_EXT_WDTR_BUS_8_BIT;\n\t\tbreak;\n\t}\n\tif (tinfo != NULL) {\n\t\tif (role == ROLE_TARGET)\n\t\t\t*bus_width = min((u_int)tinfo->user.width, *bus_width);\n\t\telse\n\t\t\t*bus_width = min((u_int)tinfo->goal.width, *bus_width);\n\t}\n}\n\n \nint\nahc_update_neg_request(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\n\t\t       struct ahc_tmode_tstate *tstate,\n\t\t       struct ahc_initiator_tinfo *tinfo, ahc_neg_type neg_type)\n{\n\tu_int auto_negotiate_orig;\n\n\tauto_negotiate_orig = tstate->auto_negotiate;\n\tif (neg_type == AHC_NEG_ALWAYS) {\n\t\t \n\t\tif ((ahc->features & AHC_WIDE) != 0)\n\t\t\ttinfo->curr.width = AHC_WIDTH_UNKNOWN;\n\t\ttinfo->curr.period = AHC_PERIOD_UNKNOWN;\n\t\ttinfo->curr.offset = AHC_OFFSET_UNKNOWN;\n\t}\n\tif (tinfo->curr.period != tinfo->goal.period\n\t || tinfo->curr.width != tinfo->goal.width\n\t || tinfo->curr.offset != tinfo->goal.offset\n\t || tinfo->curr.ppr_options != tinfo->goal.ppr_options\n\t || (neg_type == AHC_NEG_IF_NON_ASYNC\n\t  && (tinfo->goal.offset != 0\n\t   || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT\n\t   || tinfo->goal.ppr_options != 0)))\n\t\ttstate->auto_negotiate |= devinfo->target_mask;\n\telse\n\t\ttstate->auto_negotiate &= ~devinfo->target_mask;\n\n\treturn (auto_negotiate_orig != tstate->auto_negotiate);\n}\n\n \nvoid\nahc_set_syncrate(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\n\t\t const struct ahc_syncrate *syncrate, u_int period,\n\t\t u_int offset, u_int ppr_options, u_int type, int paused)\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\tahc_tmode_tstate *tstate;\n\tu_int\told_period;\n\tu_int\told_offset;\n\tu_int\told_ppr;\n\tint\tactive;\n\tint\tupdate_needed;\n\n\tactive = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\tupdate_needed = 0;\n\n\tif (syncrate == NULL) {\n\t\tperiod = 0;\n\t\toffset = 0;\n\t}\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\n\tif ((type & AHC_TRANS_USER) != 0) {\n\t\ttinfo->user.period = period;\n\t\ttinfo->user.offset = offset;\n\t\ttinfo->user.ppr_options = ppr_options;\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0) {\n\t\ttinfo->goal.period = period;\n\t\ttinfo->goal.offset = offset;\n\t\ttinfo->goal.ppr_options = ppr_options;\n\t}\n\n\told_period = tinfo->curr.period;\n\told_offset = tinfo->curr.offset;\n\told_ppr\t   = tinfo->curr.ppr_options;\n\n\tif ((type & AHC_TRANS_CUR) != 0\n\t && (old_period != period\n\t  || old_offset != offset\n\t  || old_ppr != ppr_options)) {\n\t\tu_int\tscsirate;\n\n\t\tupdate_needed++;\n\t\tscsirate = tinfo->scsirate;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\n\t\t\tscsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);\n\t\t\tif (syncrate != NULL) {\n\t\t\t\tscsirate |= syncrate->sxfr_u2;\n\t\t\t\tif ((ppr_options & MSG_EXT_PPR_DT_REQ) != 0)\n\t\t\t\t\tscsirate |= ENABLE_CRC;\n\t\t\t\telse\n\t\t\t\t\tscsirate |= SINGLE_EDGE;\n\t\t\t}\n\t\t} else {\n\n\t\t\tscsirate &= ~(SXFR|SOFS);\n\t\t\t \n\t\t\ttstate->ultraenb &= ~devinfo->target_mask;\n\t\t\tif (syncrate != NULL) {\n\t\t\t\tif (syncrate->sxfr & ULTRA_SXFR) {\n\t\t\t\t\ttstate->ultraenb |=\n\t\t\t\t\t\tdevinfo->target_mask;\n\t\t\t\t}\n\t\t\t\tscsirate |= syncrate->sxfr & SXFR;\n\t\t\t\tscsirate |= offset & SOFS;\n\t\t\t}\n\t\t\tif (active) {\n\t\t\t\tu_int sxfrctl0;\n\n\t\t\t\tsxfrctl0 = ahc_inb(ahc, SXFRCTL0);\n\t\t\t\tsxfrctl0 &= ~FAST20;\n\t\t\t\tif (tstate->ultraenb & devinfo->target_mask)\n\t\t\t\t\tsxfrctl0 |= FAST20;\n\t\t\t\tahc_outb(ahc, SXFRCTL0, sxfrctl0);\n\t\t\t}\n\t\t}\n\t\tif (active) {\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\t\t\tahc_outb(ahc, SCSIOFFSET, offset);\n\t\t}\n\n\t\ttinfo->scsirate = scsirate;\n\t\ttinfo->curr.period = period;\n\t\ttinfo->curr.offset = offset;\n\t\ttinfo->curr.ppr_options = ppr_options;\n\n\t\tahc_send_async(ahc, devinfo->channel, devinfo->target,\n\t\t\t       CAM_LUN_WILDCARD, AC_TRANSFER_NEG);\n\t\tif (bootverbose) {\n\t\t\tif (offset != 0) {\n\t\t\t\tprintk(\"%s: target %d synchronous at %sMHz%s, \"\n\t\t\t\t       \"offset = 0x%x\\n\", ahc_name(ahc),\n\t\t\t\t       devinfo->target, syncrate->rate,\n\t\t\t\t       (ppr_options & MSG_EXT_PPR_DT_REQ)\n\t\t\t\t       ? \" DT\" : \"\", offset);\n\t\t\t} else {\n\t\t\t\tprintk(\"%s: target %d using \"\n\t\t\t\t       \"asynchronous transfers\\n\",\n\t\t\t\t       ahc_name(ahc), devinfo->target);\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate_needed += ahc_update_neg_request(ahc, devinfo, tstate,\n\t\t\t\t\t\ttinfo, AHC_NEG_TO_GOAL);\n\n\tif (update_needed)\n\t\tahc_update_pending_scbs(ahc);\n}\n\n \nvoid\nahc_set_width(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\n\t      u_int width, u_int type, int paused)\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\tahc_tmode_tstate *tstate;\n\tu_int\toldwidth;\n\tint\tactive;\n\tint\tupdate_needed;\n\n\tactive = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\tupdate_needed = 0;\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\n\tif ((type & AHC_TRANS_USER) != 0)\n\t\ttinfo->user.width = width;\n\n\tif ((type & AHC_TRANS_GOAL) != 0)\n\t\ttinfo->goal.width = width;\n\n\toldwidth = tinfo->curr.width;\n\tif ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {\n\t\tu_int\tscsirate;\n\n\t\tupdate_needed++;\n\t\tscsirate =  tinfo->scsirate;\n\t\tscsirate &= ~WIDEXFER;\n\t\tif (width == MSG_EXT_WDTR_BUS_16_BIT)\n\t\t\tscsirate |= WIDEXFER;\n\n\t\ttinfo->scsirate = scsirate;\n\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->curr.width = width;\n\n\t\tahc_send_async(ahc, devinfo->channel, devinfo->target,\n\t\t\t       CAM_LUN_WILDCARD, AC_TRANSFER_NEG);\n\t\tif (bootverbose) {\n\t\t\tprintk(\"%s: target %d using %dbit transfers\\n\",\n\t\t\t       ahc_name(ahc), devinfo->target,\n\t\t\t       8 * (0x01 << width));\n\t\t}\n\t}\n\n\tupdate_needed += ahc_update_neg_request(ahc, devinfo, tstate,\n\t\t\t\t\t\ttinfo, AHC_NEG_TO_GOAL);\n\tif (update_needed)\n\t\tahc_update_pending_scbs(ahc);\n}\n\n \nstatic void\nahc_set_tags(struct ahc_softc *ahc, struct scsi_cmnd *cmd,\n\t     struct ahc_devinfo *devinfo, ahc_queue_alg alg)\n{\n\tstruct scsi_device *sdev = cmd->device;\n\n\tahc_platform_set_tags(ahc, sdev, devinfo, alg);\n\tahc_send_async(ahc, devinfo->channel, devinfo->target,\n\t\t       devinfo->lun, AC_TRANSFER_NEG);\n}\n\n \nstatic void\nahc_update_pending_scbs(struct ahc_softc *ahc)\n{\n\tstruct\tscb *pending_scb;\n\tint\tpending_scb_count;\n\tint\ti;\n\tint\tpaused;\n\tu_int\tsaved_scbptr;\n\n\t \n\tpending_scb_count = 0;\n\tLIST_FOREACH(pending_scb, &ahc->pending_scbs, pending_links) {\n\t\tstruct ahc_devinfo devinfo;\n\t\tstruct hardware_scb *pending_hscb;\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct ahc_tmode_tstate *tstate;\n\n\t\tahc_scb_devinfo(ahc, &devinfo, pending_scb);\n\t\ttinfo = ahc_fetch_transinfo(ahc, devinfo.channel,\n\t\t\t\t\t    devinfo.our_scsiid,\n\t\t\t\t\t    devinfo.target, &tstate);\n\t\tpending_hscb = pending_scb->hscb;\n\t\tpending_hscb->control &= ~ULTRAENB;\n\t\tif ((tstate->ultraenb & devinfo.target_mask) != 0)\n\t\t\tpending_hscb->control |= ULTRAENB;\n\t\tpending_hscb->scsirate = tinfo->scsirate;\n\t\tpending_hscb->scsioffset = tinfo->curr.offset;\n\t\tif ((tstate->auto_negotiate & devinfo.target_mask) == 0\n\t\t && (pending_scb->flags & SCB_AUTO_NEGOTIATE) != 0) {\n\t\t\tpending_scb->flags &= ~SCB_AUTO_NEGOTIATE;\n\t\t\tpending_hscb->control &= ~MK_MESSAGE;\n\t\t}\n\t\tahc_sync_scb(ahc, pending_scb,\n\t\t\t     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\n\t\tpending_scb_count++;\n\t}\n\n\tif (pending_scb_count == 0)\n\t\treturn;\n\n\tif (ahc_is_paused(ahc)) {\n\t\tpaused = 1;\n\t} else {\n\t\tpaused = 0;\n\t\tahc_pause(ahc);\n\t}\n\n\tsaved_scbptr = ahc_inb(ahc, SCBPTR);\n\t \n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tstruct\thardware_scb *pending_hscb;\n\t\tu_int\tcontrol;\n\t\tu_int\tscb_tag;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscb_tag = ahc_inb(ahc, SCB_TAG);\n\t\tpending_scb = ahc_lookup_scb(ahc, scb_tag);\n\t\tif (pending_scb == NULL)\n\t\t\tcontinue;\n\n\t\tpending_hscb = pending_scb->hscb;\n\t\tcontrol = ahc_inb(ahc, SCB_CONTROL);\n\t\tcontrol &= ~(ULTRAENB|MK_MESSAGE);\n\t\tcontrol |= pending_hscb->control & (ULTRAENB|MK_MESSAGE);\n\t\tahc_outb(ahc, SCB_CONTROL, control);\n\t\tahc_outb(ahc, SCB_SCSIRATE, pending_hscb->scsirate);\n\t\tahc_outb(ahc, SCB_SCSIOFFSET, pending_hscb->scsioffset);\n\t}\n\tahc_outb(ahc, SCBPTR, saved_scbptr);\n\n\tif (paused == 0)\n\t\tahc_unpause(ahc);\n}\n\n \nstatic void\nahc_fetch_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\n{\n\tu_int\tsaved_scsiid;\n\trole_t\trole;\n\tint\tour_id;\n\n\tif (ahc_inb(ahc, SSTAT0) & TARGET)\n\t\trole = ROLE_TARGET;\n\telse\n\t\trole = ROLE_INITIATOR;\n\n\tif (role == ROLE_TARGET\n\t    && (ahc->features & AHC_MULTI_TID) != 0\n\t    && (ahc_inb(ahc, SEQ_FLAGS)\n\t     & (CMDPHASE_PENDING|TARG_CMD_PENDING|NO_DISCONNECT)) != 0) {\n\t\t \n\t\tour_id = ahc_inb(ahc, TARGIDIN) & OID;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0)\n\t\tour_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;\n\telse\n\t\tour_id = ahc_inb(ahc, SCSIID) & OID;\n\n\tsaved_scsiid = ahc_inb(ahc, SAVED_SCSIID);\n\tahc_compile_devinfo(devinfo,\n\t\t\t    our_id,\n\t\t\t    SCSIID_TARGET(ahc, saved_scsiid),\n\t\t\t    ahc_inb(ahc, SAVED_LUN),\n\t\t\t    SCSIID_CHANNEL(ahc, saved_scsiid),\n\t\t\t    role);\n}\n\nstatic const struct ahc_phase_table_entry*\nahc_lookup_phase_entry(int phase)\n{\n\tconst struct ahc_phase_table_entry *entry;\n\tconst struct ahc_phase_table_entry *last_entry;\n\n\t \n\tlast_entry = &ahc_phase_table[num_phases];\n\tfor (entry = ahc_phase_table; entry < last_entry; entry++) {\n\t\tif (phase == entry->phase)\n\t\t\tbreak;\n\t}\n\treturn (entry);\n}\n\nvoid\nahc_compile_devinfo(struct ahc_devinfo *devinfo, u_int our_id, u_int target,\n\t\t    u_int lun, char channel, role_t role)\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}\n\nvoid\nahc_print_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\n{\n\tprintk(\"%s:%c:%d:%d: \", ahc_name(ahc), devinfo->channel,\n\t       devinfo->target, devinfo->lun);\n}\n\nstatic void\nahc_scb_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\n\t\tstruct scb *scb)\n{\n\trole_t\trole;\n\tint\tour_id;\n\n\tour_id = SCSIID_OUR_ID(scb->hscb->scsiid);\n\trole = ROLE_INITIATOR;\n\tif ((scb->flags & SCB_TARGET_SCB) != 0)\n\t\trole = ROLE_TARGET;\n\tahc_compile_devinfo(devinfo, our_id, SCB_GET_TARGET(ahc, scb),\n\t\t\t    SCB_GET_LUN(scb), SCB_GET_CHANNEL(ahc, scb), role);\n}\n\n\n \nstatic void\nahc_assert_atn(struct ahc_softc *ahc)\n{\n\tu_int scsisigo;\n\n\tscsisigo = ATNO;\n\tif ((ahc->features & AHC_DT) == 0)\n\t\tscsisigo |= ahc_inb(ahc, SCSISIGI);\n\tahc_outb(ahc, SCSISIGO, scsisigo);\n}\n\n \nstatic void\nahc_setup_initiator_msgout(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\n\t\t\t   struct scb *scb)\n{\n\t \n\tahc->msgout_index = 0;\n\tahc->msgout_len = 0;\n\n\tif ((scb->flags & SCB_DEVICE_RESET) == 0\n\t && ahc_inb(ahc, MSG_OUT) == MSG_IDENTIFYFLAG) {\n\t\tu_int identify_msg;\n\n\t\tidentify_msg = MSG_IDENTIFYFLAG | SCB_GET_LUN(scb);\n\t\tif ((scb->hscb->control & DISCENB) != 0)\n\t\t\tidentify_msg |= MSG_IDENTIFY_DISCFLAG;\n\t\tahc->msgout_buf[ahc->msgout_index++] = identify_msg;\n\t\tahc->msgout_len++;\n\n\t\tif ((scb->hscb->control & TAG_ENB) != 0) {\n\t\t\tahc->msgout_buf[ahc->msgout_index++] =\n\t\t\t    scb->hscb->control & (TAG_ENB|SCB_TAG_TYPE);\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = scb->hscb->tag;\n\t\t\tahc->msgout_len += 2;\n\t\t}\n\t}\n\n\tif (scb->flags & SCB_DEVICE_RESET) {\n\t\tahc->msgout_buf[ahc->msgout_index++] = TARGET_RESET;\n\t\tahc->msgout_len++;\n\t\tahc_print_path(ahc, scb);\n\t\tprintk(\"Bus Device Reset Message Sent\\n\");\n\t\t \n\t\tahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));\n\t} else if ((scb->flags & SCB_ABORT) != 0) {\n\t\tif ((scb->hscb->control & TAG_ENB) != 0)\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = ABORT_TASK;\n\t\telse\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = ABORT_TASK_SET;\n\t\tahc->msgout_len++;\n\t\tahc_print_path(ahc, scb);\n\t\tprintk(\"Abort%s Message Sent\\n\",\n\t\t       (scb->hscb->control & TAG_ENB) != 0 ? \" Tag\" : \"\");\n\t\t \n\t\tahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));\n\t} else if ((scb->flags & (SCB_AUTO_NEGOTIATE|SCB_NEGOTIATE)) != 0) {\n\t\tahc_build_transfer_msg(ahc, devinfo);\n\t} else {\n\t\tprintk(\"ahc_intr: AWAITING_MSG for an SCB that \"\n\t\t       \"does not have a waiting message\\n\");\n\t\tprintk(\"SCSIID = %x, target_mask = %x\\n\", scb->hscb->scsiid,\n\t\t       devinfo->target_mask);\n\t\tpanic(\"SCB = %d, SCB Control = %x, MSG_OUT = %x \"\n\t\t      \"SCB flags = %x\", scb->hscb->tag, scb->hscb->control,\n\t\t      ahc_inb(ahc, MSG_OUT), scb->flags);\n\t}\n\n\t \n\tahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE);\n\tscb->hscb->control &= ~MK_MESSAGE;\n\tahc->msgout_index = 0;\n\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n}\n\n \nstatic void\nahc_build_transfer_msg(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\n{\n\t \n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\tahc_tmode_tstate *tstate;\n\tconst struct ahc_syncrate *rate;\n\tint\tdowide;\n\tint\tdosync;\n\tint\tdoppr;\n\tu_int\tperiod;\n\tu_int\tppr_options;\n\tu_int\toffset;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\t \n\tperiod = tinfo->goal.period;\n\toffset = tinfo->goal.offset;\n\tppr_options = tinfo->goal.ppr_options;\n\t \n\tif (devinfo->role == ROLE_TARGET)\n\t\tppr_options = 0;\n\trate = ahc_devlimited_syncrate(ahc, tinfo, &period,\n\t\t\t\t       &ppr_options, devinfo->role);\n\tdowide = tinfo->curr.width != tinfo->goal.width;\n\tdosync = tinfo->curr.offset != offset || tinfo->curr.period != period;\n\t \n\tdoppr = ppr_options != 0;\n\n\tif (!dowide && !dosync && !doppr) {\n\t\tdowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;\n\t\tdosync = tinfo->goal.offset != 0;\n\t}\n\n\tif (!dowide && !dosync && !doppr) {\n\t\t \n\t\tif ((ahc->features & AHC_WIDE) != 0)\n\t\t\tdowide = 1;\n\t\telse\n\t\t\tdosync = 1;\n\n\t\tif (bootverbose) {\n\t\t\tahc_print_devinfo(ahc, devinfo);\n\t\t\tprintk(\"Ensuring async\\n\");\n\t\t}\n\t}\n\n\t \n\tif (devinfo->role == ROLE_TARGET)\n\t\tdoppr = 0;\n\n\t \n\tif (doppr || (dosync && !dowide)) {\n\n\t\toffset = tinfo->goal.offset;\n\t\tahc_validate_offset(ahc, tinfo, rate, &offset,\n\t\t\t\t    doppr ? tinfo->goal.width\n\t\t\t\t\t  : tinfo->curr.width,\n\t\t\t\t    devinfo->role);\n\t\tif (doppr) {\n\t\t\tahc_construct_ppr(ahc, devinfo, period, offset,\n\t\t\t\t\t  tinfo->goal.width, ppr_options);\n\t\t} else {\n\t\t\tahc_construct_sdtr(ahc, devinfo, period, offset);\n\t\t}\n\t} else {\n\t\tahc_construct_wdtr(ahc, devinfo, tinfo->goal.width);\n\t}\n}\n\n \nstatic void\nahc_construct_sdtr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\n\t\t   u_int period, u_int offset)\n{\n\tif (offset == 0)\n\t\tperiod = AHC_ASYNC_XFER_PERIOD;\n\tahc->msgout_index += spi_populate_sync_msg(\n\t\t\tahc->msgout_buf + ahc->msgout_index, period, offset);\n\tahc->msgout_len += 5;\n\tif (bootverbose) {\n\t\tprintk(\"(%s:%c:%d:%d): Sending SDTR period %x, offset %x\\n\",\n\t\t       ahc_name(ahc), devinfo->channel, devinfo->target,\n\t\t       devinfo->lun, period, offset);\n\t}\n}\n\n \nstatic void\nahc_construct_wdtr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\n\t\t   u_int bus_width)\n{\n\tahc->msgout_index += spi_populate_width_msg(\n\t\t\tahc->msgout_buf + ahc->msgout_index, bus_width);\n\tahc->msgout_len += 4;\n\tif (bootverbose) {\n\t\tprintk(\"(%s:%c:%d:%d): Sending WDTR %x\\n\",\n\t\t       ahc_name(ahc), devinfo->channel, devinfo->target,\n\t\t       devinfo->lun, bus_width);\n\t}\n}\n\n \nstatic void\nahc_construct_ppr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\n\t\t  u_int period, u_int offset, u_int bus_width,\n\t\t  u_int ppr_options)\n{\n\tif (offset == 0)\n\t\tperiod = AHC_ASYNC_XFER_PERIOD;\n\tahc->msgout_index += spi_populate_ppr_msg(\n\t\t\tahc->msgout_buf + ahc->msgout_index, period, offset,\n\t\t\tbus_width, ppr_options);\n\tahc->msgout_len += 8;\n\tif (bootverbose) {\n\t\tprintk(\"(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, \"\n\t\t       \"offset %x, ppr_options %x\\n\", ahc_name(ahc),\n\t\t       devinfo->channel, devinfo->target, devinfo->lun,\n\t\t       bus_width, period, offset, ppr_options);\n\t}\n}\n\n \nstatic void\nahc_clear_msg_state(struct ahc_softc *ahc)\n{\n\tahc->msgout_len = 0;\n\tahc->msgin_index = 0;\n\tahc->msg_type = MSG_TYPE_NONE;\n\tif ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0) {\n\t\t \n\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t}\n\tahc_outb(ahc, MSG_OUT, NOP);\n\tahc_outb(ahc, SEQ_FLAGS2,\n\t\t ahc_inb(ahc, SEQ_FLAGS2) & ~TARGET_MSG_PENDING);\n}\n\nstatic void\nahc_handle_proto_violation(struct ahc_softc *ahc)\n{\n\tstruct\tahc_devinfo devinfo;\n\tstruct\tscb *scb;\n\tu_int\tscbid;\n\tu_int\tseq_flags;\n\tu_int\tcurphase;\n\tu_int\tlastphase;\n\tint\tfound;\n\n\tahc_fetch_devinfo(ahc, &devinfo);\n\tscbid = ahc_inb(ahc, SCB_TAG);\n\tscb = ahc_lookup_scb(ahc, scbid);\n\tseq_flags = ahc_inb(ahc, SEQ_FLAGS);\n\tcurphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\tlastphase = ahc_inb(ahc, LASTPHASE);\n\tif ((seq_flags & NOT_IDENTIFIED) != 0) {\n\n\t\t \n\t\tahc_print_devinfo(ahc, &devinfo);\n\t\tprintk(\"Target did not send an IDENTIFY message. \"\n\t\t       \"LASTPHASE = 0x%x.\\n\", lastphase);\n\t\tscb = NULL;\n\t} else if (scb == NULL) {\n\t\t \n\t\tahc_print_devinfo(ahc, &devinfo);\n\t\tprintk(\"No SCB found during protocol violation\\n\");\n\t\tgoto proto_violation_reset;\n\t} else {\n\t\tahc_set_transaction_status(scb, CAM_SEQUENCE_FAIL);\n\t\tif ((seq_flags & NO_CDB_SENT) != 0) {\n\t\t\tahc_print_path(ahc, scb);\n\t\t\tprintk(\"No or incomplete CDB sent to device.\\n\");\n\t\t} else if ((ahc_inb(ahc, SCB_CONTROL) & STATUS_RCVD) == 0) {\n\t\t\t \n\t\t\tahc_print_path(ahc, scb);\n\t\t\tprintk(\"Completed command without status.\\n\");\n\t\t} else {\n\t\t\tahc_print_path(ahc, scb);\n\t\t\tprintk(\"Unknown protocol violation.\\n\");\n\t\t\tahc_dump_card_state(ahc);\n\t\t}\n\t}\n\tif ((lastphase & ~P_DATAIN_DT) == 0\n\t || lastphase == P_COMMAND) {\nproto_violation_reset:\n\t\t \n\t\tfound = ahc_reset_channel(ahc, 'A', TRUE);\n\t\tprintk(\"%s: Issued Channel %c Bus Reset. \"\n\t\t       \"%d SCBs aborted\\n\", ahc_name(ahc), 'A', found);\n\t} else {\n\t\t \n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & ~ENSELO);\n\t\tahc_assert_atn(ahc);\n\t\tahc_outb(ahc, MSG_OUT, HOST_MSG);\n\t\tif (scb == NULL) {\n\t\t\tahc_print_devinfo(ahc, &devinfo);\n\t\t\tahc->msgout_buf[0] = ABORT_TASK;\n\t\t\tahc->msgout_len = 1;\n\t\t\tahc->msgout_index = 0;\n\t\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\t} else {\n\t\t\tahc_print_path(ahc, scb);\n\t\t\tscb->flags |= SCB_ABORT;\n\t\t}\n\t\tprintk(\"Protocol violation %s.  Attempting to abort.\\n\",\n\t\t       ahc_lookup_phase_entry(curphase)->phasemsg);\n\t}\n}\n\n \nstatic void\nahc_handle_message_phase(struct ahc_softc *ahc)\n{\n\tstruct\tahc_devinfo devinfo;\n\tu_int\tbus_phase;\n\tint\tend_session;\n\n\tahc_fetch_devinfo(ahc, &devinfo);\n\tend_session = FALSE;\n\tbus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\nreswitch:\n\tswitch (ahc->msg_type) {\n\tcase MSG_TYPE_INITIATOR_MSGOUT:\n\t{\n\t\tint lastbyte;\n\t\tint phasemis;\n\t\tint msgdone;\n\n\t\tif (ahc->msgout_len == 0)\n\t\t\tpanic(\"HOST_MSG_LOOP interrupt with no active message\");\n\n#ifdef AHC_DEBUG\n\t\tif ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {\n\t\t\tahc_print_devinfo(ahc, &devinfo);\n\t\t\tprintk(\"INITIATOR_MSG_OUT\");\n\t\t}\n#endif\n\t\tphasemis = bus_phase != P_MESGOUT;\n\t\tif (phasemis) {\n#ifdef AHC_DEBUG\n\t\t\tif ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {\n\t\t\t\tprintk(\" PHASEMIS %s\\n\",\n\t\t\t\t       ahc_lookup_phase_entry(bus_phase)\n\t\t\t\t\t\t\t     ->phasemsg);\n\t\t\t}\n#endif\n\t\t\tif (bus_phase == P_MESGIN) {\n\t\t\t\t \n\t\t\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t\t\t\tahc->send_msg_perror = FALSE;\n\t\t\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGIN;\n\t\t\t\tahc->msgin_index = 0;\n\t\t\t\tgoto reswitch;\n\t\t\t}\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ahc->send_msg_perror) {\n\t\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t\t\tahc_outb(ahc, CLRSINT1, CLRREQINIT);\n#ifdef AHC_DEBUG\n\t\t\tif ((ahc_debug & AHC_SHOW_MESSAGES) != 0)\n\t\t\t\tprintk(\" byte 0x%x\\n\", ahc->send_msg_perror);\n#endif\n\t\t\tahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsgdone\t= ahc->msgout_index == ahc->msgout_len;\n\t\tif (msgdone) {\n\t\t\t \n\t\t\tahc->msgout_index = 0;\n\t\t\tahc_assert_atn(ahc);\n\t\t}\n\n\t\tlastbyte = ahc->msgout_index == (ahc->msgout_len - 1);\n\t\tif (lastbyte) {\n\t\t\t \n\t\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t\t}\n\n\t\t \n\t\tahc_outb(ahc, CLRSINT1, CLRREQINIT);\n#ifdef AHC_DEBUG\n\t\tif ((ahc_debug & AHC_SHOW_MESSAGES) != 0)\n\t\t\tprintk(\" byte 0x%x\\n\",\n\t\t\t       ahc->msgout_buf[ahc->msgout_index]);\n#endif\n\t\tahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_INITIATOR_MSGIN:\n\t{\n\t\tint phasemis;\n\t\tint message_done;\n\n#ifdef AHC_DEBUG\n\t\tif ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {\n\t\t\tahc_print_devinfo(ahc, &devinfo);\n\t\t\tprintk(\"INITIATOR_MSG_IN\");\n\t\t}\n#endif\n\t\tphasemis = bus_phase != P_MESGIN;\n\t\tif (phasemis) {\n#ifdef AHC_DEBUG\n\t\t\tif ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {\n\t\t\t\tprintk(\" PHASEMIS %s\\n\",\n\t\t\t\t       ahc_lookup_phase_entry(bus_phase)\n\t\t\t\t\t\t\t     ->phasemsg);\n\t\t\t}\n#endif\n\t\t\tahc->msgin_index = 0;\n\t\t\tif (bus_phase == P_MESGOUT\n\t\t\t && (ahc->send_msg_perror == TRUE\n\t\t\t  || (ahc->msgout_len != 0\n\t\t\t   && ahc->msgout_index == 0))) {\n\t\t\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\t\t\tgoto reswitch;\n\t\t\t}\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);\n#ifdef AHC_DEBUG\n\t\tif ((ahc_debug & AHC_SHOW_MESSAGES) != 0)\n\t\t\tprintk(\" byte 0x%x\\n\",\n\t\t\t       ahc->msgin_buf[ahc->msgin_index]);\n#endif\n\n\t\tmessage_done = ahc_parse_msg(ahc, &devinfo);\n\n\t\tif (message_done) {\n\t\t\t \n\t\t\tahc->msgin_index = 0;\n\n\t\t\t \n\t\t\tif (ahc->msgout_len != 0) {\n#ifdef AHC_DEBUG\n\t\t\t\tif ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {\n\t\t\t\t\tahc_print_devinfo(ahc, &devinfo);\n\t\t\t\t\tprintk(\"Asserting ATN for response\\n\");\n\t\t\t\t}\n#endif\n\t\t\t\tahc_assert_atn(ahc);\n\t\t\t}\n\t\t} else\n\t\t\tahc->msgin_index++;\n\n\t\tif (message_done == MSGLOOP_TERMINATED) {\n\t\t\tend_session = TRUE;\n\t\t} else {\n\t\t\t \n\t\t\tahc_outb(ahc, CLRSINT1, CLRREQINIT);\n\t\t\tahc_inb(ahc, SCSIDATL);\n\t\t}\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_TARGET_MSGIN:\n\t{\n\t\tint msgdone;\n\t\tint msgout_request;\n\n\t\tif (ahc->msgout_len == 0)\n\t\t\tpanic(\"Target MSGIN with no active message\");\n\n\t\t \n\t\tif ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0\n\t\t && ahc->msgout_index > 0)\n\t\t\tmsgout_request = TRUE;\n\t\telse\n\t\t\tmsgout_request = FALSE;\n\n\t\tif (msgout_request) {\n\n\t\t\t \n\t\t\tahc->msg_type = MSG_TYPE_TARGET_MSGOUT;\n\t\t\tahc_outb(ahc, SCSISIGO, P_MESGOUT | BSYO);\n\t\t\tahc->msgin_index = 0;\n\t\t\t \n\t\t\tahc_inb(ahc, SCSIDATL);\n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsgdone = ahc->msgout_index == ahc->msgout_len;\n\t\tif (msgdone) {\n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\tahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_TARGET_MSGOUT:\n\t{\n\t\tint lastbyte;\n\t\tint msgdone;\n\n\t\t \n\t\tlastbyte = (ahc_inb(ahc, SCSISIGI) & ATNI) == 0;\n\n\t\t \n\t\tahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);\n\t\tahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIDATL);\n\t\tmsgdone = ahc_parse_msg(ahc, &devinfo);\n\t\tif (msgdone == MSGLOOP_TERMINATED) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\tahc->msgin_index++;\n\n\t\t \n\t\tif (msgdone == MSGLOOP_MSGCOMPLETE) {\n\t\t\tahc->msgin_index = 0;\n\n\t\t\t \n\t\t\tif (ahc->msgout_len != 0) {\n\t\t\t\tahc_outb(ahc, SCSISIGO, P_MESGIN | BSYO);\n\t\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t\t ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\t\t\tahc->msg_type = MSG_TYPE_TARGET_MSGIN;\n\t\t\t\tahc->msgin_index = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (lastbyte)\n\t\t\tend_session = TRUE;\n\t\telse {\n\t\t\t \n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\t}\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpanic(\"Unknown REQINIT message type\");\n\t}\n\n\tif (end_session) {\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, RETURN_1, EXIT_MSG_LOOP);\n\t} else\n\t\tahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);\n}\n\n \nstatic int\nahc_sent_msg(struct ahc_softc *ahc, ahc_msgtype type, u_int msgval, int full)\n{\n\tint found;\n\tu_int index;\n\n\tfound = FALSE;\n\tindex = 0;\n\n\twhile (index < ahc->msgout_len) {\n\t\tif (ahc->msgout_buf[index] == EXTENDED_MESSAGE) {\n\t\t\tu_int end_index;\n\n\t\t\tend_index = index + 1 + ahc->msgout_buf[index + 1];\n\t\t\tif (ahc->msgout_buf[index+2] == msgval\n\t\t\t && type == AHCMSG_EXT) {\n\n\t\t\t\tif (full) {\n\t\t\t\t\tif (ahc->msgout_index > end_index)\n\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t} else if (ahc->msgout_index > index)\n\t\t\t\t\tfound = TRUE;\n\t\t\t}\n\t\t\tindex = end_index;\n\t\t} else if (ahc->msgout_buf[index] >= SIMPLE_QUEUE_TAG\n\t\t\t&& ahc->msgout_buf[index] <= IGNORE_WIDE_RESIDUE) {\n\n\t\t\t \n\t\t\tindex += 2;\n\t\t} else {\n\t\t\t \n\t\t\tif (type == AHCMSG_1B\n\t\t\t && ahc->msgout_buf[index] == msgval\n\t\t\t && ahc->msgout_index > index)\n\t\t\t\tfound = TRUE;\n\t\t\tindex++;\n\t\t}\n\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\treturn (found);\n}\n\n \nstatic int\nahc_parse_msg(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\tahc_tmode_tstate *tstate;\n\tint\treject;\n\tint\tdone;\n\tint\tresponse;\n\tu_int\ttarg_scsirate;\n\n\tdone = MSGLOOP_IN_PROG;\n\tresponse = FALSE;\n\treject = FALSE;\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\ttarg_scsirate = tinfo->scsirate;\n\n\t \n\tswitch (ahc->msgin_buf[0]) {\n\tcase DISCONNECT:\n\tcase SAVE_POINTERS:\n\tcase COMMAND_COMPLETE:\n\tcase RESTORE_POINTERS:\n\tcase IGNORE_WIDE_RESIDUE:\n\t\t \n\t\tdone = MSGLOOP_TERMINATED;\n\t\tbreak;\n\tcase MESSAGE_REJECT:\n\t\tresponse = ahc_handle_msg_reject(ahc, devinfo);\n\t\tfallthrough;\n\tcase NOP:\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\tbreak;\n\tcase EXTENDED_MESSAGE:\n\t{\n\t\t \n\t\tif (ahc->msgin_index < 2)\n\t\t\tbreak;\n\t\tswitch (ahc->msgin_buf[2]) {\n\t\tcase EXTENDED_SDTR:\n\t\t{\n\t\t\tconst struct ahc_syncrate *syncrate;\n\t\t\tu_int\t period;\n\t\t\tu_int\t ppr_options;\n\t\t\tu_int\t offset;\n\t\t\tu_int\t saved_offset;\n\n\t\t\tif (ahc->msgin_buf[1] != MSG_EXT_SDTR_LEN) {\n\t\t\t\treject = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ahc->msgin_index < (MSG_EXT_SDTR_LEN + 1))\n\t\t\t\tbreak;\n\n\t\t\tperiod = ahc->msgin_buf[3];\n\t\t\tppr_options = 0;\n\t\t\tsaved_offset = offset = ahc->msgin_buf[4];\n\t\t\tsyncrate = ahc_devlimited_syncrate(ahc, tinfo, &period,\n\t\t\t\t\t\t\t   &ppr_options,\n\t\t\t\t\t\t\t   devinfo->role);\n\t\t\tahc_validate_offset(ahc, tinfo, syncrate, &offset,\n\t\t\t\t\t    targ_scsirate & WIDEXFER,\n\t\t\t\t\t    devinfo->role);\n\t\t\tif (bootverbose) {\n\t\t\t\tprintk(\"(%s:%c:%d:%d): Received \"\n\t\t\t\t       \"SDTR period %x, offset %x\\n\\t\"\n\t\t\t\t       \"Filtered to period %x, offset %x\\n\",\n\t\t\t\t       ahc_name(ahc), devinfo->channel,\n\t\t\t\t       devinfo->target, devinfo->lun,\n\t\t\t\t       ahc->msgin_buf[3], saved_offset,\n\t\t\t\t       period, offset);\n\t\t\t}\n\t\t\tahc_set_syncrate(ahc, devinfo,\n\t\t\t\t\t syncrate, period,\n\t\t\t\t\t offset, ppr_options,\n\t\t\t\t\t AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t\t  TRUE);\n\n\t\t\t \n\t\t\tif (ahc_sent_msg(ahc, AHCMSG_EXT, EXTENDED_SDTR, TRUE)) {\n\t\t\t\t \n\t\t\t\tif (saved_offset != offset) {\n\t\t\t\t\t \n\t\t\t\t\treject = TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (bootverbose\n\t\t\t\t && devinfo->role == ROLE_INITIATOR) {\n\t\t\t\t\tprintk(\"(%s:%c:%d:%d): Target \"\n\t\t\t\t\t       \"Initiated SDTR\\n\",\n\t\t\t\t\t       ahc_name(ahc), devinfo->channel,\n\t\t\t\t\t       devinfo->target, devinfo->lun);\n\t\t\t\t}\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tahc->msgout_len = 0;\n\t\t\t\tahc_construct_sdtr(ahc, devinfo,\n\t\t\t\t\t\t   period, offset);\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t}\n\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\tcase EXTENDED_WDTR:\n\t\t{\n\t\t\tu_int bus_width;\n\t\t\tu_int saved_width;\n\t\t\tu_int sending_reply;\n\n\t\t\tsending_reply = FALSE;\n\t\t\tif (ahc->msgin_buf[1] != MSG_EXT_WDTR_LEN) {\n\t\t\t\treject = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ahc->msgin_index < (MSG_EXT_WDTR_LEN + 1))\n\t\t\t\tbreak;\n\n\t\t\tbus_width = ahc->msgin_buf[3];\n\t\t\tsaved_width = bus_width;\n\t\t\tahc_validate_width(ahc, tinfo, &bus_width,\n\t\t\t\t\t   devinfo->role);\n\t\t\tif (bootverbose) {\n\t\t\t\tprintk(\"(%s:%c:%d:%d): Received WDTR \"\n\t\t\t\t       \"%x filtered to %x\\n\",\n\t\t\t\t       ahc_name(ahc), devinfo->channel,\n\t\t\t\t       devinfo->target, devinfo->lun,\n\t\t\t\t       saved_width, bus_width);\n\t\t\t}\n\n\t\t\tif (ahc_sent_msg(ahc, AHCMSG_EXT, EXTENDED_WDTR, TRUE)) {\n\t\t\t\t \n\t\t\t\tif (saved_width > bus_width) {\n\t\t\t\t\treject = TRUE;\n\t\t\t\t\tprintk(\"(%s:%c:%d:%d): requested %dBit \"\n\t\t\t\t\t       \"transfers.  Rejecting...\\n\",\n\t\t\t\t\t       ahc_name(ahc), devinfo->channel,\n\t\t\t\t\t       devinfo->target, devinfo->lun,\n\t\t\t\t\t       8 * (0x01 << bus_width));\n\t\t\t\t\tbus_width = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (bootverbose\n\t\t\t\t && devinfo->role == ROLE_INITIATOR) {\n\t\t\t\t\tprintk(\"(%s:%c:%d:%d): Target \"\n\t\t\t\t\t       \"Initiated WDTR\\n\",\n\t\t\t\t\t       ahc_name(ahc), devinfo->channel,\n\t\t\t\t\t       devinfo->target, devinfo->lun);\n\t\t\t\t}\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tahc->msgout_len = 0;\n\t\t\t\tahc_construct_wdtr(ahc, devinfo, bus_width);\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t\tsending_reply = TRUE;\n\t\t\t}\n\t\t\t \n\t\t\tahc_update_neg_request(ahc, devinfo, tstate,\n\t\t\t\t\t       tinfo, AHC_NEG_ALWAYS);\n\t\t\tahc_set_width(ahc, devinfo, bus_width,\n\t\t\t\t      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t       TRUE);\n\t\t\tif (sending_reply == FALSE && reject == FALSE) {\n\n\t\t\t\t \n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tahc->msgout_len = 0;\n\t\t\t\tahc_build_transfer_msg(ahc, devinfo);\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t}\n\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\tcase EXTENDED_PPR:\n\t\t{\n\t\t\tconst struct ahc_syncrate *syncrate;\n\t\t\tu_int\tperiod;\n\t\t\tu_int\toffset;\n\t\t\tu_int\tbus_width;\n\t\t\tu_int\tppr_options;\n\t\t\tu_int\tsaved_width;\n\t\t\tu_int\tsaved_offset;\n\t\t\tu_int\tsaved_ppr_options;\n\n\t\t\tif (ahc->msgin_buf[1] != MSG_EXT_PPR_LEN) {\n\t\t\t\treject = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ahc->msgin_index < (MSG_EXT_PPR_LEN + 1))\n\t\t\t\tbreak;\n\n\t\t\tperiod = ahc->msgin_buf[3];\n\t\t\toffset = ahc->msgin_buf[5];\n\t\t\tbus_width = ahc->msgin_buf[6];\n\t\t\tsaved_width = bus_width;\n\t\t\tppr_options = ahc->msgin_buf[7];\n\t\t\t \n\t\t\tif ((ppr_options & MSG_EXT_PPR_DT_REQ) == 0\n\t\t\t && period == 9)\n\t\t\t\toffset = 0;\n\t\t\tsaved_ppr_options = ppr_options;\n\t\t\tsaved_offset = offset;\n\n\t\t\t \n\t\t\tppr_options &= MSG_EXT_PPR_DT_REQ;\n\t\t\tif (bus_width == 0)\n\t\t\t\tppr_options = 0;\n\n\t\t\tahc_validate_width(ahc, tinfo, &bus_width,\n\t\t\t\t\t   devinfo->role);\n\t\t\tsyncrate = ahc_devlimited_syncrate(ahc, tinfo, &period,\n\t\t\t\t\t\t\t   &ppr_options,\n\t\t\t\t\t\t\t   devinfo->role);\n\t\t\tahc_validate_offset(ahc, tinfo, syncrate,\n\t\t\t\t\t    &offset, bus_width,\n\t\t\t\t\t    devinfo->role);\n\n\t\t\tif (ahc_sent_msg(ahc, AHCMSG_EXT, EXTENDED_PPR, TRUE)) {\n\t\t\t\t \n\t\t\t\tif (saved_width > bus_width\n\t\t\t\t || saved_offset != offset\n\t\t\t\t || saved_ppr_options != ppr_options) {\n\t\t\t\t\treject = TRUE;\n\t\t\t\t\tperiod = 0;\n\t\t\t\t\toffset = 0;\n\t\t\t\t\tbus_width = 0;\n\t\t\t\t\tppr_options = 0;\n\t\t\t\t\tsyncrate = NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (devinfo->role != ROLE_TARGET)\n\t\t\t\t\tprintk(\"(%s:%c:%d:%d): Target \"\n\t\t\t\t\t       \"Initiated PPR\\n\",\n\t\t\t\t\t       ahc_name(ahc), devinfo->channel,\n\t\t\t\t\t       devinfo->target, devinfo->lun);\n\t\t\t\telse\n\t\t\t\t\tprintk(\"(%s:%c:%d:%d): Initiator \"\n\t\t\t\t\t       \"Initiated PPR\\n\",\n\t\t\t\t\t       ahc_name(ahc), devinfo->channel,\n\t\t\t\t\t       devinfo->target, devinfo->lun);\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tahc->msgout_len = 0;\n\t\t\t\tahc_construct_ppr(ahc, devinfo, period, offset,\n\t\t\t\t\t\t  bus_width, ppr_options);\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t}\n\t\t\tif (bootverbose) {\n\t\t\t\tprintk(\"(%s:%c:%d:%d): Received PPR width %x, \"\n\t\t\t\t       \"period %x, offset %x,options %x\\n\"\n\t\t\t\t       \"\\tFiltered to width %x, period %x, \"\n\t\t\t\t       \"offset %x, options %x\\n\",\n\t\t\t\t       ahc_name(ahc), devinfo->channel,\n\t\t\t\t       devinfo->target, devinfo->lun,\n\t\t\t\t       saved_width, ahc->msgin_buf[3],\n\t\t\t\t       saved_offset, saved_ppr_options,\n\t\t\t\t       bus_width, period, offset, ppr_options);\n\t\t\t}\n\t\t\tahc_set_width(ahc, devinfo, bus_width,\n\t\t\t\t      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t       TRUE);\n\t\t\tahc_set_syncrate(ahc, devinfo,\n\t\t\t\t\t syncrate, period,\n\t\t\t\t\t offset, ppr_options,\n\t\t\t\t\t AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t\t  TRUE);\n\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\t \n\t\t\treject = TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n#ifdef AHC_TARGET_MODE\n\tcase TARGET_RESET:\n\t\tahc_handle_devreset(ahc, devinfo,\n\t\t\t\t    CAM_BDR_SENT,\n\t\t\t\t    \"Bus Device Reset Received\",\n\t\t\t\t     0);\n\t\tahc_restart(ahc);\n\t\tdone = MSGLOOP_TERMINATED;\n\t\tbreak;\n\tcase ABORT_TASK:\n\tcase ABORT_TASK_SET:\n\tcase CLEAR_QUEUE_TASK_SET:\n\t{\n\t\tint tag;\n\n\t\t \n\t\tif (devinfo->role != ROLE_TARGET) {\n\t\t\treject = TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ttag = SCB_LIST_NULL;\n\t\tif (ahc->msgin_buf[0] == ABORT_TASK)\n\t\t\ttag = ahc_inb(ahc, INITIATOR_TAG);\n\t\tahc_abort_scbs(ahc, devinfo->target, devinfo->channel,\n\t\t\t       devinfo->lun, tag, ROLE_TARGET,\n\t\t\t       CAM_REQ_ABORTED);\n\n\t\ttstate = ahc->enabled_targets[devinfo->our_scsiid];\n\t\tif (tstate != NULL) {\n\t\t\tstruct ahc_tmode_lstate* lstate;\n\n\t\t\tlstate = tstate->enabled_luns[devinfo->lun];\n\t\t\tif (lstate != NULL) {\n\t\t\t\tahc_queue_lstate_event(ahc, lstate,\n\t\t\t\t\t\t       devinfo->our_scsiid,\n\t\t\t\t\t\t       ahc->msgin_buf[0],\n\t\t\t\t\t\t        tag);\n\t\t\t\tahc_send_lstate_events(ahc, lstate);\n\t\t\t}\n\t\t}\n\t\tahc_restart(ahc);\n\t\tdone = MSGLOOP_TERMINATED;\n\t\tbreak;\n\t}\n#endif\n\tcase TERMINATE_IO_PROC:\n\tdefault:\n\t\treject = TRUE;\n\t\tbreak;\n\t}\n\n\tif (reject) {\n\t\t \n\t\tahc->msgout_index = 0;\n\t\tahc->msgout_len = 1;\n\t\tahc->msgout_buf[0] = MESSAGE_REJECT;\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\tresponse = TRUE;\n\t}\n\n\tif (done != MSGLOOP_IN_PROG && !response)\n\t\t \n\t\tahc->msgout_len = 0;\n\n\treturn (done);\n}\n\n \nstatic int\nahc_handle_msg_reject(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\n{\n\t \n\tstruct scb *scb;\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct ahc_tmode_tstate *tstate;\n\tu_int scb_index;\n\tu_int last_msg;\n\tint   response = 0;\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tscb = ahc_lookup_scb(ahc, scb_index);\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\t \n\tlast_msg = ahc_inb(ahc, LAST_MSG);\n\n\tif (ahc_sent_msg(ahc, AHCMSG_EXT, EXTENDED_PPR,  FALSE)) {\n\t\t \n\t\tif (bootverbose) {\n\t\t\tprintk(\"(%s:%c:%d:%d): PPR Rejected. \"\n\t\t\t       \"Trying WDTR/SDTR\\n\",\n\t\t\t       ahc_name(ahc), devinfo->channel,\n\t\t\t       devinfo->target, devinfo->lun);\n\t\t}\n\t\ttinfo->goal.ppr_options = 0;\n\t\ttinfo->curr.transport_version = 2;\n\t\ttinfo->goal.transport_version = 2;\n\t\tahc->msgout_index = 0;\n\t\tahc->msgout_len = 0;\n\t\tahc_build_transfer_msg(ahc, devinfo);\n\t\tahc->msgout_index = 0;\n\t\tresponse = 1;\n\t} else if (ahc_sent_msg(ahc, AHCMSG_EXT, EXTENDED_WDTR,  FALSE)) {\n\n\t\t \n\t\tprintk(\"(%s:%c:%d:%d): refuses WIDE negotiation.  Using \"\n\t\t       \"8bit transfers\\n\", ahc_name(ahc),\n\t\t       devinfo->channel, devinfo->target, devinfo->lun);\n\t\tahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t       TRUE);\n\t\t \n\t\tif (tinfo->goal.offset != tinfo->curr.offset) {\n\n\t\t\t \n\t\t\tahc->msgout_index = 0;\n\t\t\tahc->msgout_len = 0;\n\t\t\tahc_build_transfer_msg(ahc, devinfo);\n\t\t\tahc->msgout_index = 0;\n\t\t\tresponse = 1;\n\t\t}\n\t} else if (ahc_sent_msg(ahc, AHCMSG_EXT, EXTENDED_SDTR,  FALSE)) {\n\t\t \n\t\tahc_set_syncrate(ahc, devinfo,  NULL,  0,\n\t\t\t\t  0,  0,\n\t\t\t\t AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t  TRUE);\n\t\tprintk(\"(%s:%c:%d:%d): refuses synchronous negotiation. \"\n\t\t       \"Using asynchronous transfers\\n\",\n\t\t       ahc_name(ahc), devinfo->channel,\n\t\t       devinfo->target, devinfo->lun);\n\t} else if ((scb->hscb->control & SIMPLE_QUEUE_TAG) != 0) {\n\t\tint tag_type;\n\t\tint mask;\n\n\t\ttag_type = (scb->hscb->control & SIMPLE_QUEUE_TAG);\n\n\t\tif (tag_type == SIMPLE_QUEUE_TAG) {\n\t\t\tprintk(\"(%s:%c:%d:%d): refuses tagged commands.  \"\n\t\t\t       \"Performing non-tagged I/O\\n\", ahc_name(ahc),\n\t\t\t       devinfo->channel, devinfo->target, devinfo->lun);\n\t\t\tahc_set_tags(ahc, scb->io_ctx, devinfo, AHC_QUEUE_NONE);\n\t\t\tmask = ~0x23;\n\t\t} else {\n\t\t\tprintk(\"(%s:%c:%d:%d): refuses %s tagged commands.  \"\n\t\t\t       \"Performing simple queue tagged I/O only\\n\",\n\t\t\t       ahc_name(ahc), devinfo->channel, devinfo->target,\n\t\t\t       devinfo->lun, tag_type == ORDERED_QUEUE_TAG\n\t\t\t       ? \"ordered\" : \"head of queue\");\n\t\t\tahc_set_tags(ahc, scb->io_ctx, devinfo, AHC_QUEUE_BASIC);\n\t\t\tmask = ~0x03;\n\t\t}\n\n\t\t \n\t\tahc_outb(ahc, SCB_CONTROL,\n\t\t\t ahc_inb(ahc, SCB_CONTROL) & mask);\n\t\tscb->hscb->control &= mask;\n\t\tahc_set_transaction_tag(scb,  FALSE,\n\t\t\t\t\t SIMPLE_QUEUE_TAG);\n\t\tahc_outb(ahc, MSG_OUT, MSG_IDENTIFYFLAG);\n\t\tahc_assert_atn(ahc);\n\n\t\t \n\t\tif ((ahc->flags & AHC_SCB_BTT) == 0) {\n\t\t\tstruct scb_tailq *untagged_q;\n\n\t\t\tuntagged_q =\n\t\t\t    &(ahc->untagged_queues[devinfo->target_offset]);\n\t\t\tTAILQ_INSERT_HEAD(untagged_q, scb, links.tqe);\n\t\t\tscb->flags |= SCB_UNTAGGEDQ;\n\t\t}\n\t\tahc_busy_tcl(ahc, BUILD_TCL(scb->hscb->scsiid, devinfo->lun),\n\t\t\t     scb->hscb->tag);\n\n\t\t \n\t\tahc_search_qinfifo(ahc, SCB_GET_TARGET(ahc, scb),\n\t\t\t\t   SCB_GET_CHANNEL(ahc, scb),\n\t\t\t\t   SCB_GET_LUN(scb),  SCB_LIST_NULL,\n\t\t\t\t   ROLE_INITIATOR, CAM_REQUEUE_REQ,\n\t\t\t\t   SEARCH_COMPLETE);\n\t} else {\n\t\t \n\t\tprintk(\"%s:%c:%d: Message reject for %x -- ignored\\n\",\n\t\t       ahc_name(ahc), devinfo->channel, devinfo->target,\n\t\t       last_msg);\n\t}\n\treturn (response);\n}\n\n \nstatic void\nahc_handle_ign_wide_residue(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\n{\n\tu_int scb_index;\n\tstruct scb *scb;\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tscb = ahc_lookup_scb(ahc, scb_index);\n\t \n\tif ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0\n\t || ahc_get_transfer_dir(scb) != CAM_DIR_IN) {\n\t\t \n\t} else {\n\t\t \n\t\tuint32_t sgptr;\n\n\t\tsgptr = ahc_inb(ahc, SCB_RESIDUAL_SGPTR);\n\t\tif ((sgptr & SG_LIST_NULL) != 0\n\t\t && (ahc_inb(ahc, SCB_LUN) & SCB_XFERLEN_ODD) != 0) {\n\t\t\t \n\t\t} else {\n\t\t\tstruct ahc_dma_seg *sg;\n\t\t\tuint32_t data_cnt;\n\t\t\tuint32_t data_addr;\n\t\t\tuint32_t sglen;\n\n\t\t\t \n\t\t\tsgptr = ahc_inl(ahc, SCB_RESIDUAL_SGPTR);\n\t\t\tdata_cnt = ahc_inl(ahc, SCB_RESIDUAL_DATACNT);\n\n\t\t\tif ((sgptr & SG_LIST_NULL) != 0) {\n\t\t\t\t \n\t\t\t\tdata_cnt &= ~AHC_SG_LEN_MASK;\n\t\t\t}\n\n\t\t\tdata_addr = ahc_inl(ahc, SHADDR);\n\n\t\t\tdata_cnt += 1;\n\t\t\tdata_addr -= 1;\n\t\t\tsgptr &= SG_PTR_MASK;\n\n\t\t\tsg = ahc_sg_bus_to_virt(scb, sgptr);\n\n\t\t\t \n\t\t\tsg--;\n\t\t\tsglen = ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;\n\t\t\tif (sg != scb->sg_list\n\t\t\t && sglen < (data_cnt & AHC_SG_LEN_MASK)) {\n\n\t\t\t\tsg--;\n\t\t\t\tsglen = ahc_le32toh(sg->len);\n\t\t\t\t \n\t\t\t\tdata_cnt = 1 | (sglen & (~AHC_SG_LEN_MASK));\n\t\t\t\tdata_addr = ahc_le32toh(sg->addr)\n\t\t\t\t\t  + (sglen & AHC_SG_LEN_MASK) - 1;\n\n\t\t\t\t \n\t\t\t\tsg++;\n\t\t\t\tsgptr = ahc_sg_virt_to_bus(scb, sg);\n\t\t\t}\n\t\t\tahc_outl(ahc, SCB_RESIDUAL_SGPTR, sgptr);\n\t\t\tahc_outl(ahc, SCB_RESIDUAL_DATACNT, data_cnt);\n\t\t\t \n\t\t\tahc_outb(ahc, SCB_LUN,\n\t\t\t\t ahc_inb(ahc, SCB_LUN) ^ SCB_XFERLEN_ODD);\n\t\t}\n\t}\n}\n\n\n \nstatic void\nahc_reinitialize_dataptrs(struct ahc_softc *ahc)\n{\n\tstruct\t scb *scb;\n\tstruct\t ahc_dma_seg *sg;\n\tu_int\t scb_index;\n\tuint32_t sgptr;\n\tuint32_t resid;\n\tuint32_t dataptr;\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tscb = ahc_lookup_scb(ahc, scb_index);\n\tsgptr = (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 3) << 24)\n\t      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 2) << 16)\n\t      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 1) << 8)\n\t      |\tahc_inb(ahc, SCB_RESIDUAL_SGPTR);\n\n\tsgptr &= SG_PTR_MASK;\n\tsg = ahc_sg_bus_to_virt(scb, sgptr);\n\n\t \n\tsg--;\n\n\tresid = (ahc_inb(ahc, SCB_RESIDUAL_DATACNT + 2) << 16)\n\t      | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT + 1) << 8)\n\t      | ahc_inb(ahc, SCB_RESIDUAL_DATACNT);\n\n\tdataptr = ahc_le32toh(sg->addr)\n\t\t+ (ahc_le32toh(sg->len) & AHC_SG_LEN_MASK)\n\t\t- resid;\n\tif ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {\n\t\tu_int dscommand1;\n\n\t\tdscommand1 = ahc_inb(ahc, DSCOMMAND1);\n\t\tahc_outb(ahc, DSCOMMAND1, dscommand1 | HADDLDSEL0);\n\t\tahc_outb(ahc, HADDR,\n\t\t\t (ahc_le32toh(sg->len) >> 24) & SG_HIGH_ADDR_BITS);\n\t\tahc_outb(ahc, DSCOMMAND1, dscommand1);\n\t}\n\tahc_outb(ahc, HADDR + 3, dataptr >> 24);\n\tahc_outb(ahc, HADDR + 2, dataptr >> 16);\n\tahc_outb(ahc, HADDR + 1, dataptr >> 8);\n\tahc_outb(ahc, HADDR, dataptr);\n\tahc_outb(ahc, HCNT + 2, resid >> 16);\n\tahc_outb(ahc, HCNT + 1, resid >> 8);\n\tahc_outb(ahc, HCNT, resid);\n\tif ((ahc->features & AHC_ULTRA2) == 0) {\n\t\tahc_outb(ahc, STCNT + 2, resid >> 16);\n\t\tahc_outb(ahc, STCNT + 1, resid >> 8);\n\t\tahc_outb(ahc, STCNT, resid);\n\t}\n}\n\n \nstatic void\nahc_handle_devreset(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\n\t\t    cam_status status, char *message, int verbose_level)\n{\n#ifdef AHC_TARGET_MODE\n\tstruct ahc_tmode_tstate* tstate;\n\tu_int lun;\n#endif\n\tint found;\n\n\tfound = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,\n\t\t\t       CAM_LUN_WILDCARD, SCB_LIST_NULL, devinfo->role,\n\t\t\t       status);\n\n#ifdef AHC_TARGET_MODE\n\t \n\ttstate = ahc->enabled_targets[devinfo->our_scsiid];\n\tif (tstate != NULL) {\n\t\tfor (lun = 0; lun < AHC_NUM_LUNS; lun++) {\n\t\t\tstruct ahc_tmode_lstate* lstate;\n\n\t\t\tlstate = tstate->enabled_luns[lun];\n\t\t\tif (lstate == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tahc_queue_lstate_event(ahc, lstate, devinfo->our_scsiid,\n\t\t\t\t\t       TARGET_RESET,  0);\n\t\t\tahc_send_lstate_events(ahc, lstate);\n\t\t}\n\t}\n#endif\n\n\t \n\tahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t      AHC_TRANS_CUR,  TRUE);\n\tahc_set_syncrate(ahc, devinfo,  NULL,\n\t\t\t  0,  0,  0,\n\t\t\t AHC_TRANS_CUR,  TRUE);\n\n\tif (status != CAM_SEL_TIMEOUT)\n\t\tahc_send_async(ahc, devinfo->channel, devinfo->target,\n\t\t\t       CAM_LUN_WILDCARD, AC_SENT_BDR);\n\n\tif (message != NULL\n\t && (verbose_level <= bootverbose))\n\t\tprintk(\"%s: %s on %c:%d. %d SCBs aborted\\n\", ahc_name(ahc),\n\t\t       message, devinfo->channel, devinfo->target, found);\n}\n\n#ifdef AHC_TARGET_MODE\nstatic void\nahc_setup_target_msgin(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\n\t\t       struct scb *scb)\n{\n\n\t \n\tahc->msgout_index = 0;\n\tahc->msgout_len = 0;\n\n\tif (scb != NULL && (scb->flags & SCB_AUTO_NEGOTIATE) != 0)\n\t\tahc_build_transfer_msg(ahc, devinfo);\n\telse\n\t\tpanic(\"ahc_intr: AWAITING target message with no message\");\n\n\tahc->msgout_index = 0;\n\tahc->msg_type = MSG_TYPE_TARGET_MSGIN;\n}\n#endif\n \n \nstruct ahc_softc *\nahc_alloc(void *platform_arg, char *name)\n{\n\tstruct  ahc_softc *ahc;\n\tint\ti;\n\n\tahc = kzalloc(sizeof(*ahc), GFP_ATOMIC);\n\tif (!ahc) {\n\t\tprintk(\"aic7xxx: cannot malloc softc!\\n\");\n\t\tkfree(name);\n\t\treturn NULL;\n\t}\n\n\tahc->seep_config = kmalloc(sizeof(*ahc->seep_config), GFP_ATOMIC);\n\tif (ahc->seep_config == NULL) {\n\t\tkfree(ahc);\n\t\tkfree(name);\n\t\treturn (NULL);\n\t}\n\tLIST_INIT(&ahc->pending_scbs);\n\t \n\tahc->name = name;\n\tahc->unit = -1;\n\tahc->description = NULL;\n\tahc->channel = 'A';\n\tahc->channel_b = 'B';\n\tahc->chip = AHC_NONE;\n\tahc->features = AHC_FENONE;\n\tahc->bugs = AHC_BUGNONE;\n\tahc->flags = AHC_FNONE;\n\t \n\tahc->seqctl = FASTMODE;\n\n\tfor (i = 0; i < AHC_NUM_TARGETS; i++)\n\t\tTAILQ_INIT(&ahc->untagged_queues[i]);\n\tif (ahc_platform_alloc(ahc, platform_arg) != 0) {\n\t\tahc_free(ahc);\n\t\tahc = NULL;\n\t}\n\treturn (ahc);\n}\n\nint\nahc_softc_init(struct ahc_softc *ahc)\n{\n\n\t \n\tif ((ahc->chip & AHC_PCI) == 0)\n\t\tahc->unpause = ahc_inb(ahc, HCNTRL) & IRQMS;\n\telse\n\t\tahc->unpause = 0;\n\tahc->pause = ahc->unpause | PAUSE;\n\t \n\tif (ahc->scb_data == NULL) {\n\t\tahc->scb_data = kzalloc(sizeof(*ahc->scb_data), GFP_ATOMIC);\n\t\tif (ahc->scb_data == NULL)\n\t\t\treturn (ENOMEM);\n\t}\n\n\treturn (0);\n}\n\nvoid\nahc_set_unit(struct ahc_softc *ahc, int unit)\n{\n\tahc->unit = unit;\n}\n\nvoid\nahc_set_name(struct ahc_softc *ahc, char *name)\n{\n\tkfree(ahc->name);\n\tahc->name = name;\n}\n\nvoid\nahc_free(struct ahc_softc *ahc)\n{\n\tint i;\n\n\tswitch (ahc->init_level) {\n\tdefault:\n\tcase 5:\n\t\tahc_shutdown(ahc);\n\t\tfallthrough;\n\tcase 4:\n\t\tahc_dmamap_unload(ahc, ahc->shared_data_dmat,\n\t\t\t\t  ahc->shared_data_dmamap);\n\t\tfallthrough;\n\tcase 3:\n\t\tahc_dmamem_free(ahc, ahc->shared_data_dmat, ahc->qoutfifo,\n\t\t\t\tahc->shared_data_dmamap);\n\t\tahc_dmamap_destroy(ahc, ahc->shared_data_dmat,\n\t\t\t\t   ahc->shared_data_dmamap);\n\t\tfallthrough;\n\tcase 2:\n\t\tahc_dma_tag_destroy(ahc, ahc->shared_data_dmat);\n\t\tfallthrough;\n\tcase 1:\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\t}\n\n\tahc_platform_free(ahc);\n\tahc_fini_scbdata(ahc);\n\tfor (i = 0; i < AHC_NUM_TARGETS; i++) {\n\t\tstruct ahc_tmode_tstate *tstate;\n\n\t\ttstate = ahc->enabled_targets[i];\n\t\tif (tstate != NULL) {\n#ifdef AHC_TARGET_MODE\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < AHC_NUM_LUNS; j++) {\n\t\t\t\tstruct ahc_tmode_lstate *lstate;\n\n\t\t\t\tlstate = tstate->enabled_luns[j];\n\t\t\t\tif (lstate != NULL) {\n\t\t\t\t\txpt_free_path(lstate->path);\n\t\t\t\t\tkfree(lstate);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tkfree(tstate);\n\t\t}\n\t}\n#ifdef AHC_TARGET_MODE\n\tif (ahc->black_hole != NULL) {\n\t\txpt_free_path(ahc->black_hole->path);\n\t\tkfree(ahc->black_hole);\n\t}\n#endif\n\tkfree(ahc->name);\n\tkfree(ahc->seep_config);\n\tkfree(ahc);\n\treturn;\n}\n\nstatic void\nahc_shutdown(void *arg)\n{\n\tstruct\tahc_softc *ahc;\n\tint\ti;\n\n\tahc = (struct ahc_softc *)arg;\n\n\t \n\tahc_reset(ahc,  FALSE);\n\tahc_outb(ahc, SCSISEQ, 0);\n\tahc_outb(ahc, SXFRCTL0, 0);\n\tahc_outb(ahc, DSPCISTATUS, 0);\n\n\tfor (i = TARG_SCSIRATE; i < SCSICONF; i++)\n\t\tahc_outb(ahc, i, 0);\n}\n\n \nint\nahc_reset(struct ahc_softc *ahc, int reinit)\n{\n\tu_int\tsblkctl;\n\tu_int\tsxfrctl1_a, sxfrctl1_b;\n\tint\terror;\n\tint\twait;\n\n\t \n\tahc_pause(ahc);\n\tsxfrctl1_b = 0;\n\tif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7770) {\n\t\tu_int sblkctl;\n\n\t\t \n\t\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);\n\t\tsxfrctl1_b = ahc_inb(ahc, SXFRCTL1);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);\n\t}\n\tsxfrctl1_a = ahc_inb(ahc, SXFRCTL1);\n\n\tahc_outb(ahc, HCNTRL, CHIPRST | ahc->pause);\n\n\t \n\twait = 1000;\n\tdo {\n\t\tahc_delay(1000);\n\t} while (--wait && !(ahc_inb(ahc, HCNTRL) & CHIPRSTACK));\n\n\tif (wait == 0) {\n\t\tprintk(\"%s: WARNING - Failed chip reset!  \"\n\t\t       \"Trying to initialize anyway.\\n\", ahc_name(ahc));\n\t}\n\tahc_outb(ahc, HCNTRL, ahc->pause);\n\n\t \n\tsblkctl = ahc_inb(ahc, SBLKCTL) & (SELBUSB|SELWIDE);\n\t \n\tif ((ahc->chip & AHC_PCI) != 0)\n\t\tsblkctl &= ~SELBUSB;\n\tswitch (sblkctl) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tahc->features |= AHC_WIDE;\n\t\tbreak;\n\tcase 8:\n\t\t \n\t\tahc->features |= AHC_TWIN;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\" Unsupported adapter type.  Ignoring\\n\");\n\t\treturn(-1);\n\t}\n\n\t \n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\tu_int sblkctl;\n\n\t\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);\n\t\tahc_outb(ahc, SXFRCTL1, sxfrctl1_b);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);\n\t}\n\tahc_outb(ahc, SXFRCTL1, sxfrctl1_a);\n\n\terror = 0;\n\tif (reinit != 0)\n\t\t \n\t\terror = ahc->bus_chip_init(ahc);\n#ifdef AHC_DUMP_SEQ\n\telse\n\t\tahc_dumpseq(ahc);\n#endif\n\n\treturn (error);\n}\n\n \nint\nahc_probe_scbs(struct ahc_softc *ahc) {\n\tint i;\n\n\tfor (i = 0; i < AHC_SCB_MAX; i++) {\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tahc_outb(ahc, SCB_BASE, i);\n\t\tif (ahc_inb(ahc, SCB_BASE) != i)\n\t\t\tbreak;\n\t\tahc_outb(ahc, SCBPTR, 0);\n\t\tif (ahc_inb(ahc, SCB_BASE) != 0)\n\t\t\tbreak;\n\t}\n\treturn (i);\n}\n\nstatic void\nahc_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error) \n{\n\tdma_addr_t *baddr;\n\n\tbaddr = (dma_addr_t *)arg;\n\t*baddr = segs->ds_addr;\n}\n\nstatic void\nahc_build_free_scb_list(struct ahc_softc *ahc)\n{\n\tint scbsize;\n\tint i;\n\n\tscbsize = 32;\n\tif ((ahc->flags & AHC_LSCBS_ENABLED) != 0)\n\t\tscbsize = 64;\n\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tint j;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\n\t\t \n\t\tfor (j = 0; j < scbsize; j++)\n\t\t\tahc_outb(ahc, SCB_BASE+j, 0xFF);\n\n\t\t \n\t\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\t\t \n\t\tif ((ahc->flags & AHC_PAGESCBS) != 0)\n\t\t\tahc_outb(ahc, SCB_NEXT, i+1);\n\t\telse\n\t\t\tahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);\n\n\t\t \n\t\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\t\tahc_outb(ahc, SCB_SCSIID, 0xFF);\n\t\tahc_outb(ahc, SCB_LUN, 0xFF);\n\t}\n\n\tif ((ahc->flags & AHC_PAGESCBS) != 0) {\n\t\t \n\t\tahc_outb(ahc, FREE_SCBH, 0);\n\t} else {\n\t\t \n\t\tahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\n\t}\n\n\t \n\tahc_outb(ahc, SCBPTR, i-1);\n\tahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);\n}\n\nstatic int\nahc_init_scbdata(struct ahc_softc *ahc)\n{\n\tstruct scb_data *scb_data;\n\n\tscb_data = ahc->scb_data;\n\tSLIST_INIT(&scb_data->free_scbs);\n\tSLIST_INIT(&scb_data->sg_maps);\n\n\t \n\tscb_data->scbarray = kcalloc(AHC_SCB_MAX_ALLOC, sizeof(struct scb),\n\t\t\t\t     GFP_ATOMIC);\n\tif (scb_data->scbarray == NULL)\n\t\treturn (ENOMEM);\n\n\t \n\n\tscb_data->maxhscbs = ahc_probe_scbs(ahc);\n\tif (ahc->scb_data->maxhscbs == 0) {\n\t\tprintk(\"%s: No SCB space found\\n\", ahc_name(ahc));\n\t\treturn (ENXIO);\n\t}\n\n\t \n\n\t \n\tif (ahc_dma_tag_create(ahc, ahc->parent_dmat,  1,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT + 1,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT,\n\t\t\t        BUS_SPACE_MAXADDR,\n\t\t\t        NULL,  NULL,\n\t\t\t       AHC_SCB_MAX_ALLOC * sizeof(struct hardware_scb),\n\t\t\t        1,\n\t\t\t        BUS_SPACE_MAXSIZE_32BIT,\n\t\t\t        0, &scb_data->hscb_dmat) != 0) {\n\t\tgoto error_exit;\n\t}\n\n\tscb_data->init_level++;\n\n\t \n\tif (ahc_dmamem_alloc(ahc, scb_data->hscb_dmat,\n\t\t\t     (void **)&scb_data->hscbs,\n\t\t\t     BUS_DMA_NOWAIT, &scb_data->hscb_dmamap) != 0) {\n\t\tgoto error_exit;\n\t}\n\n\tscb_data->init_level++;\n\n\t \n\tahc_dmamap_load(ahc, scb_data->hscb_dmat, scb_data->hscb_dmamap,\n\t\t\tscb_data->hscbs,\n\t\t\tAHC_SCB_MAX_ALLOC * sizeof(struct hardware_scb),\n\t\t\tahc_dmamap_cb, &scb_data->hscb_busaddr,  0);\n\n\tscb_data->init_level++;\n\n\t \n\tif (ahc_dma_tag_create(ahc, ahc->parent_dmat,  1,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT + 1,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT,\n\t\t\t        BUS_SPACE_MAXADDR,\n\t\t\t        NULL,  NULL,\n\t\t\t       AHC_SCB_MAX_ALLOC * sizeof(struct scsi_sense_data),\n\t\t\t        1,\n\t\t\t        BUS_SPACE_MAXSIZE_32BIT,\n\t\t\t        0, &scb_data->sense_dmat) != 0) {\n\t\tgoto error_exit;\n\t}\n\n\tscb_data->init_level++;\n\n\t \n\tif (ahc_dmamem_alloc(ahc, scb_data->sense_dmat,\n\t\t\t     (void **)&scb_data->sense,\n\t\t\t     BUS_DMA_NOWAIT, &scb_data->sense_dmamap) != 0) {\n\t\tgoto error_exit;\n\t}\n\n\tscb_data->init_level++;\n\n\t \n\tahc_dmamap_load(ahc, scb_data->sense_dmat, scb_data->sense_dmamap,\n\t\t\tscb_data->sense,\n\t\t\tAHC_SCB_MAX_ALLOC * sizeof(struct scsi_sense_data),\n\t\t\tahc_dmamap_cb, &scb_data->sense_busaddr,  0);\n\n\tscb_data->init_level++;\n\n\t \n\tif (ahc_dma_tag_create(ahc, ahc->parent_dmat,  8,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT + 1,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT,\n\t\t\t        BUS_SPACE_MAXADDR,\n\t\t\t        NULL,  NULL,\n\t\t\t       PAGE_SIZE,  1,\n\t\t\t        BUS_SPACE_MAXSIZE_32BIT,\n\t\t\t        0, &scb_data->sg_dmat) != 0) {\n\t\tgoto error_exit;\n\t}\n\n\tscb_data->init_level++;\n\n\t \n\tmemset(scb_data->hscbs, 0,\n\t       AHC_SCB_MAX_ALLOC * sizeof(struct hardware_scb));\n\tahc_alloc_scbs(ahc);\n\n\tif (scb_data->numscbs == 0) {\n\t\tprintk(\"%s: ahc_init_scbdata - \"\n\t\t       \"Unable to allocate initial scbs\\n\",\n\t\t       ahc_name(ahc));\n\t\tgoto error_exit;\n\t}\n\n\t \n\tahc->next_queued_scb = ahc_get_scb(ahc);\n\n\t \n\treturn (0);\n\nerror_exit:\n\n\treturn (ENOMEM);\n}\n\nstatic void\nahc_fini_scbdata(struct ahc_softc *ahc)\n{\n\tstruct scb_data *scb_data;\n\n\tscb_data = ahc->scb_data;\n\tif (scb_data == NULL)\n\t\treturn;\n\n\tswitch (scb_data->init_level) {\n\tdefault:\n\tcase 7:\n\t{\n\t\tstruct sg_map_node *sg_map;\n\n\t\twhile ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {\n\t\t\tSLIST_REMOVE_HEAD(&scb_data->sg_maps, links);\n\t\t\tahc_dmamap_unload(ahc, scb_data->sg_dmat,\n\t\t\t\t\t  sg_map->sg_dmamap);\n\t\t\tahc_dmamem_free(ahc, scb_data->sg_dmat,\n\t\t\t\t\tsg_map->sg_vaddr,\n\t\t\t\t\tsg_map->sg_dmamap);\n\t\t\tkfree(sg_map);\n\t\t}\n\t\tahc_dma_tag_destroy(ahc, scb_data->sg_dmat);\n\t}\n\t\tfallthrough;\n\tcase 6:\n\t\tahc_dmamap_unload(ahc, scb_data->sense_dmat,\n\t\t\t\t  scb_data->sense_dmamap);\n\t\tfallthrough;\n\tcase 5:\n\t\tahc_dmamem_free(ahc, scb_data->sense_dmat, scb_data->sense,\n\t\t\t\tscb_data->sense_dmamap);\n\t\tahc_dmamap_destroy(ahc, scb_data->sense_dmat,\n\t\t\t\t   scb_data->sense_dmamap);\n\t\tfallthrough;\n\tcase 4:\n\t\tahc_dma_tag_destroy(ahc, scb_data->sense_dmat);\n\t\tfallthrough;\n\tcase 3:\n\t\tahc_dmamap_unload(ahc, scb_data->hscb_dmat,\n\t\t\t\t  scb_data->hscb_dmamap);\n\t\tfallthrough;\n\tcase 2:\n\t\tahc_dmamem_free(ahc, scb_data->hscb_dmat, scb_data->hscbs,\n\t\t\t\tscb_data->hscb_dmamap);\n\t\tahc_dmamap_destroy(ahc, scb_data->hscb_dmat,\n\t\t\t\t   scb_data->hscb_dmamap);\n\t\tfallthrough;\n\tcase 1:\n\t\tahc_dma_tag_destroy(ahc, scb_data->hscb_dmat);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\t}\n\tkfree(scb_data->scbarray);\n}\n\nstatic void\nahc_alloc_scbs(struct ahc_softc *ahc)\n{\n\tstruct scb_data *scb_data;\n\tstruct scb *next_scb;\n\tstruct sg_map_node *sg_map;\n\tdma_addr_t physaddr;\n\tstruct ahc_dma_seg *segs;\n\tint newcount;\n\tint i;\n\n\tscb_data = ahc->scb_data;\n\tif (scb_data->numscbs >= AHC_SCB_MAX_ALLOC)\n\t\t \n\t\treturn;\n\n\tnext_scb = &scb_data->scbarray[scb_data->numscbs];\n\n\tsg_map = kmalloc(sizeof(*sg_map), GFP_ATOMIC);\n\n\tif (sg_map == NULL)\n\t\treturn;\n\n\t \n\tif (ahc_dmamem_alloc(ahc, scb_data->sg_dmat,\n\t\t\t     (void **)&sg_map->sg_vaddr,\n\t\t\t     BUS_DMA_NOWAIT, &sg_map->sg_dmamap) != 0) {\n\t\tkfree(sg_map);\n\t\treturn;\n\t}\n\n\tSLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);\n\n\tahc_dmamap_load(ahc, scb_data->sg_dmat, sg_map->sg_dmamap,\n\t\t\tsg_map->sg_vaddr, PAGE_SIZE, ahc_dmamap_cb,\n\t\t\t&sg_map->sg_physaddr,  0);\n\n\tsegs = sg_map->sg_vaddr;\n\tphysaddr = sg_map->sg_physaddr;\n\n\tnewcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));\n\tnewcount = min(newcount, (AHC_SCB_MAX_ALLOC - scb_data->numscbs));\n\tfor (i = 0; i < newcount; i++) {\n\t\tstruct scb_platform_data *pdata;\n\n\t\tpdata = kmalloc(sizeof(*pdata), GFP_ATOMIC);\n\t\tif (pdata == NULL)\n\t\t\tbreak;\n\t\tnext_scb->platform_data = pdata;\n\t\tnext_scb->sg_map = sg_map;\n\t\tnext_scb->sg_list = segs;\n\t\t \n\t\tnext_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);\n\t\tnext_scb->ahc_softc = ahc;\n\t\tnext_scb->flags = SCB_FREE;\n\t\tnext_scb->hscb = &scb_data->hscbs[scb_data->numscbs];\n\t\tnext_scb->hscb->tag = ahc->scb_data->numscbs;\n\t\tSLIST_INSERT_HEAD(&ahc->scb_data->free_scbs,\n\t\t\t\t  next_scb, links.sle);\n\t\tsegs += AHC_NSEG;\n\t\tphysaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));\n\t\tnext_scb++;\n\t\tahc->scb_data->numscbs++;\n\t}\n}\n\nvoid\nahc_controller_info(struct ahc_softc *ahc, char *buf)\n{\n\tint len;\n\n\tlen = sprintf(buf, \"%s: \", ahc_chip_names[ahc->chip & AHC_CHIPID_MASK]);\n\tbuf += len;\n\tif ((ahc->features & AHC_TWIN) != 0)\n\t\tlen = sprintf(buf, \"Twin Channel, A SCSI Id=%d, \"\n\t\t\t      \"B SCSI Id=%d, primary %c, \",\n\t\t\t      ahc->our_id, ahc->our_id_b,\n\t\t\t      (ahc->flags & AHC_PRIMARY_CHANNEL) + 'A');\n\telse {\n\t\tconst char *speed;\n\t\tconst char *type;\n\n\t\tspeed = \"\";\n\t\tif ((ahc->features & AHC_ULTRA) != 0) {\n\t\t\tspeed = \"Ultra \";\n\t\t} else if ((ahc->features & AHC_DT) != 0) {\n\t\t\tspeed = \"Ultra160 \";\n\t\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tspeed = \"Ultra2 \";\n\t\t}\n\t\tif ((ahc->features & AHC_WIDE) != 0) {\n\t\t\ttype = \"Wide\";\n\t\t} else {\n\t\t\ttype = \"Single\";\n\t\t}\n\t\tlen = sprintf(buf, \"%s%s Channel %c, SCSI Id=%d, \",\n\t\t\t      speed, type, ahc->channel, ahc->our_id);\n\t}\n\tbuf += len;\n\n\tif ((ahc->flags & AHC_PAGESCBS) != 0)\n\t\tsprintf(buf, \"%d/%d SCBs\",\n\t\t\tahc->scb_data->maxhscbs, AHC_MAX_QUEUE);\n\telse\n\t\tsprintf(buf, \"%d SCBs\", ahc->scb_data->maxhscbs);\n}\n\nint\nahc_chip_init(struct ahc_softc *ahc)\n{\n\tint\t term;\n\tint\t error;\n\tu_int\t i;\n\tu_int\t scsi_conf;\n\tu_int\t scsiseq_template;\n\tuint32_t physaddr;\n\n\tahc_outb(ahc, SEQ_FLAGS, 0);\n\tahc_outb(ahc, SEQ_FLAGS2, 0);\n\n\t \n\tif (ahc->features & AHC_TWIN) {\n\n\t\t \n\t\tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);\n\t\tterm = (ahc->flags & AHC_TERM_ENB_B) != 0 ? STPWEN : 0;\n\t\tahc_outb(ahc, SCSIID, ahc->our_id_b);\n\t\tscsi_conf = ahc_inb(ahc, SCSICONF + 1);\n\t\tahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t\t|term|ahc->seltime_b|ENSTIMER|ACTNEGEN);\n\t\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\t\tahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);\n\t\tahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\n\t\tahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\n\n\t\t \n\t\tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);\n\t}\n\tterm = (ahc->flags & AHC_TERM_ENB_A) != 0 ? STPWEN : 0;\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);\n\telse\n\t\tahc_outb(ahc, SCSIID, ahc->our_id);\n\tscsi_conf = ahc_inb(ahc, SCSICONF);\n\tahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t|term|ahc->seltime\n\t\t\t\t|ENSTIMER|ACTNEGEN);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);\n\tahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\n\tahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\n\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, 0));\n\t\tif ((ahc->flags & AHC_SCB_BTT) != 0) {\n\t\t\tint lun;\n\n\t\t\t \n\t\t\tfor (lun = 1; lun < AHC_NUM_LUNS; lun++)\n\t\t\t\tahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, lun));\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 256; i++)\n\t\tahc->qoutfifo[i] = SCB_LIST_NULL;\n\tahc_sync_qoutfifo(ahc, BUS_DMASYNC_PREREAD);\n\n\tfor (i = 0; i < 256; i++)\n\t\tahc->qinfifo[i] = SCB_LIST_NULL;\n\n\tif ((ahc->features & AHC_MULTI_TID) != 0) {\n\t\tahc_outb(ahc, TARGID, 0);\n\t\tahc_outb(ahc, TARGID + 1, 0);\n\t}\n\n\t \n\tphysaddr = ahc->scb_data->hscb_busaddr;\n\tahc_outb(ahc, HSCB_ADDR, physaddr & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 3, (physaddr >> 24) & 0xFF);\n\n\tphysaddr = ahc->shared_data_busaddr;\n\tahc_outb(ahc, SHARED_DATA_ADDR, physaddr & 0xFF);\n\tahc_outb(ahc, SHARED_DATA_ADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, SHARED_DATA_ADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, SHARED_DATA_ADDR + 3, (physaddr >> 24) & 0xFF);\n\n\t \n\tahc_outb(ahc, CMDSIZE_TABLE, 5);\n\tahc_outb(ahc, CMDSIZE_TABLE + 1, 9);\n\tahc_outb(ahc, CMDSIZE_TABLE + 2, 9);\n\tahc_outb(ahc, CMDSIZE_TABLE + 3, 0);\n\tahc_outb(ahc, CMDSIZE_TABLE + 4, 15);\n\tahc_outb(ahc, CMDSIZE_TABLE + 5, 11);\n\tahc_outb(ahc, CMDSIZE_TABLE + 6, 0);\n\tahc_outb(ahc, CMDSIZE_TABLE + 7, 0);\n\n\tif ((ahc->features & AHC_HS_MAILBOX) != 0)\n\t\tahc_outb(ahc, HS_MAILBOX, 0);\n\n\t \n\tif ((ahc->features & AHC_TARGETMODE) != 0) {\n\t\tahc->tqinfifonext = 1;\n\t\tahc_outb(ahc, KERNEL_TQINPOS, ahc->tqinfifonext - 1);\n\t\tahc_outb(ahc, TQINPOS, ahc->tqinfifonext);\n\t}\n\tahc->qinfifonext = 0;\n\tahc->qoutfifonext = 0;\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, QOFF_CTLSTA, SCB_QSIZE_256);\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t\tahc_outb(ahc, SNSCB_QOFF, ahc->qinfifonext);\n\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t} else {\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t\tahc_outb(ahc, QINPOS, ahc->qinfifonext);\n\t\tahc_outb(ahc, QOUTPOS, ahc->qoutfifonext);\n\t}\n\n\t \n\tahc_outb(ahc, WAITING_SCBH, SCB_LIST_NULL);\n\n\t \n\tahc_outb(ahc, DISCONNECTED_SCBH, SCB_LIST_NULL);\n\n\t \n\tahc_outb(ahc, MSG_OUT, NOP);\n\n\t \n\tscsiseq_template = ENSELO|ENAUTOATNO|ENAUTOATNP;\n\tif ((ahc->flags & AHC_INITIATORROLE) != 0)\n\t\tscsiseq_template |= ENRSELI;\n\tahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq_template);\n\n\t \n\tahc_build_free_scb_list(ahc);\n\n\t \n\tahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);\n\n\t \n\tif (bootverbose)\n\t\tprintk(\"%s: Downloading Sequencer Program...\",\n\t\t       ahc_name(ahc));\n\n\terror = ahc_loadseq(ahc);\n\tif (error != 0)\n\t\treturn (error);\n\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tint wait;\n\n\t\t \n\t\tfor (wait = 5000;\n\t\t     (ahc_inb(ahc, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;\n\t\t     wait--)\n\t\t\tahc_delay(100);\n\t}\n\tahc_restart(ahc);\n\treturn (0);\n}\n\n \nint\nahc_init(struct ahc_softc *ahc)\n{\n\tint\t max_targ;\n\tu_int\t i;\n\tu_int\t scsi_conf;\n\tu_int\t ultraenb;\n\tu_int\t discenable;\n\tu_int\t tagenable;\n\tsize_t\t driver_data_size;\n\n#ifdef AHC_DEBUG\n\tif ((ahc_debug & AHC_DEBUG_SEQUENCER) != 0)\n\t\tahc->flags |= AHC_SEQUENCER_DEBUG;\n#endif\n\n#ifdef AHC_PRINT_SRAM\n\tprintk(\"Scratch Ram:\");\n\tfor (i = 0x20; i < 0x5f; i++) {\n\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\tprintk (\"\\n              \");\n\t\t}\n\t\tprintk (\" 0x%x\", ahc_inb(ahc, i));\n\t}\n\tif ((ahc->features & AHC_MORE_SRAM) != 0) {\n\t\tfor (i = 0x70; i < 0x7f; i++) {\n\t\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\t\tprintk (\"\\n              \");\n\t\t\t}\n\t\t\tprintk (\" 0x%x\", ahc_inb(ahc, i));\n\t\t}\n\t}\n\tprintk (\"\\n\");\n\t \n\tahc_outb(ahc, CLRINT, CLRPARERR);\n\tahc_outb(ahc, CLRINT, CLRBRKADRINT);\n#endif\n\tmax_targ = 15;\n\n\t \n\tif ((ahc->flags & AHC_USEDEFAULTS) != 0)\n\t\tahc->our_id = ahc->our_id_b = 7;\n\n\t \n\tahc->flags |= AHC_INITIATORROLE;\n\n\t \n\tif ((AHC_TMODE_ENABLE & (0x1 << ahc->unit)) == 0)\n\t\tahc->features &= ~AHC_TARGETMODE;\n\n\tahc->init_level++;\n\n\t \n\tdriver_data_size = 2 * 256 * sizeof(uint8_t);\n\tif ((ahc->features & AHC_TARGETMODE) != 0)\n\t\tdriver_data_size += AHC_TMODE_CMDS * sizeof(struct target_cmd)\n\t\t\t\t +  1;\n\tif (ahc_dma_tag_create(ahc, ahc->parent_dmat,  1,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT + 1,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT,\n\t\t\t        BUS_SPACE_MAXADDR,\n\t\t\t        NULL,  NULL,\n\t\t\t       driver_data_size,\n\t\t\t        1,\n\t\t\t        BUS_SPACE_MAXSIZE_32BIT,\n\t\t\t        0, &ahc->shared_data_dmat) != 0) {\n\t\treturn (ENOMEM);\n\t}\n\n\tahc->init_level++;\n\n\t \n\tif (ahc_dmamem_alloc(ahc, ahc->shared_data_dmat,\n\t\t\t     (void **)&ahc->qoutfifo,\n\t\t\t     BUS_DMA_NOWAIT, &ahc->shared_data_dmamap) != 0) {\n\t\treturn (ENOMEM);\n\t}\n\n\tahc->init_level++;\n\n\t \n\tahc_dmamap_load(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,\n\t\t\tahc->qoutfifo, driver_data_size, ahc_dmamap_cb,\n\t\t\t&ahc->shared_data_busaddr,  0);\n\n\tif ((ahc->features & AHC_TARGETMODE) != 0) {\n\t\tahc->targetcmds = (struct target_cmd *)ahc->qoutfifo;\n\t\tahc->qoutfifo = (uint8_t *)&ahc->targetcmds[AHC_TMODE_CMDS];\n\t\tahc->dma_bug_buf = ahc->shared_data_busaddr\n\t\t\t\t + driver_data_size - 1;\n\t\t \n\t\tfor (i = 0; i < AHC_TMODE_CMDS; i++)\n\t\t\tahc->targetcmds[i].cmd_valid = 0;\n\t\tahc_sync_tqinfifo(ahc, BUS_DMASYNC_PREREAD);\n\t\tahc->qoutfifo = (uint8_t *)&ahc->targetcmds[256];\n\t}\n\tahc->qinfifo = &ahc->qoutfifo[256];\n\n\tahc->init_level++;\n\n\t \n\tif (ahc->scb_data->maxhscbs == 0)\n\t\tif (ahc_init_scbdata(ahc) != 0)\n\t\t\treturn (ENOMEM);\n\n\t \n\tif (ahc_alloc_tstate(ahc, ahc->our_id, 'A') == NULL) {\n\t\tprintk(\"%s: unable to allocate ahc_tmode_tstate.  \"\n\t\t       \"Failing attach\\n\", ahc_name(ahc));\n\t\treturn (ENOMEM);\n\t}\n\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\tif (ahc_alloc_tstate(ahc, ahc->our_id_b, 'B') == NULL) {\n\t\t\tprintk(\"%s: unable to allocate ahc_tmode_tstate.  \"\n\t\t\t       \"Failing attach\\n\", ahc_name(ahc));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t}\n\n\tif (ahc->scb_data->maxhscbs < AHC_SCB_MAX_ALLOC) {\n\t\tahc->flags |= AHC_PAGESCBS;\n\t} else {\n\t\tahc->flags &= ~AHC_PAGESCBS;\n\t}\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOW_MISC) {\n\t\tprintk(\"%s: hardware scb %u bytes; kernel scb %u bytes; \"\n\t\t       \"ahc_dma %u bytes\\n\",\n\t\t\tahc_name(ahc),\n\t\t\t(u_int)sizeof(struct hardware_scb),\n\t\t\t(u_int)sizeof(struct scb),\n\t\t\t(u_int)sizeof(struct ahc_dma_seg));\n\t}\n#endif  \n\n\t \n\tif (ahc->features & AHC_TWIN) {\n\t\tscsi_conf = ahc_inb(ahc, SCSICONF + 1);\n\t\tif ((scsi_conf & RESET_SCSI) != 0\n\t\t && (ahc->flags & AHC_INITIATORROLE) != 0)\n\t\t\tahc->flags |= AHC_RESET_BUS_B;\n\t}\n\n\tscsi_conf = ahc_inb(ahc, SCSICONF);\n\tif ((scsi_conf & RESET_SCSI) != 0\n\t && (ahc->flags & AHC_INITIATORROLE) != 0)\n\t\tahc->flags |= AHC_RESET_BUS_A;\n\n\tultraenb = 0;\n\ttagenable = ALL_TARGETS_MASK;\n\n\t \n\tif ((ahc->flags & AHC_USEDEFAULTS) != 0) {\n\t\tprintk(\"%s: Host Adapter Bios disabled.  Using default SCSI \"\n\t\t\t\"device parameters\\n\", ahc_name(ahc));\n\t\tahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B|\n\t\t\t      AHC_TERM_ENB_A|AHC_TERM_ENB_B;\n\t\tdiscenable = ALL_TARGETS_MASK;\n\t\tif ((ahc->features & AHC_ULTRA) != 0)\n\t\t\tultraenb = ALL_TARGETS_MASK;\n\t} else {\n\t\tdiscenable = ~((ahc_inb(ahc, DISC_DSB + 1) << 8)\n\t\t\t   | ahc_inb(ahc, DISC_DSB));\n\t\tif ((ahc->features & (AHC_ULTRA|AHC_ULTRA2)) != 0)\n\t\t\tultraenb = (ahc_inb(ahc, ULTRA_ENB + 1) << 8)\n\t\t\t\t      | ahc_inb(ahc, ULTRA_ENB);\n\t}\n\n\tif ((ahc->features & (AHC_WIDE|AHC_TWIN)) == 0)\n\t\tmax_targ = 7;\n\n\tfor (i = 0; i <= max_targ; i++) {\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct ahc_tmode_tstate *tstate;\n\t\tu_int our_id;\n\t\tu_int target_id;\n\t\tchar channel;\n\n\t\tchannel = 'A';\n\t\tour_id = ahc->our_id;\n\t\ttarget_id = i;\n\t\tif (i > 7 && (ahc->features & AHC_TWIN) != 0) {\n\t\t\tchannel = 'B';\n\t\t\tour_id = ahc->our_id_b;\n\t\t\ttarget_id = i % 8;\n\t\t}\n\t\ttinfo = ahc_fetch_transinfo(ahc, channel, our_id,\n\t\t\t\t\t    target_id, &tstate);\n\t\t \n\t\tmemset(tinfo, 0, sizeof(*tinfo));\n\t\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\t\tif ((ahc->features & AHC_WIDE) != 0)\n\t\t\t\ttinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\n\n\t\t\t \n\t\t\ttinfo->user.period = ahc_syncrates->period;\n\t\t\ttinfo->user.offset = MAX_OFFSET;\n\t\t} else {\n\t\t\tu_int scsirate;\n\t\t\tuint16_t mask;\n\n\t\t\t \n\t\t\tscsirate = ahc_inb(ahc, TARG_SCSIRATE + i);\n\t\t\tmask = (0x01 << i);\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\t\tu_int offset;\n\t\t\t\tu_int maxsync;\n\n\t\t\t\tif ((scsirate & SOFS) == 0x0F) {\n\t\t\t\t\t \n\t\t\t\t\tscsirate = (scsirate & SXFR) >> 4\n\t\t\t\t\t\t | (ultraenb & mask)\n\t\t\t\t\t\t  ? 0x08 : 0x0\n\t\t\t\t\t\t | (scsirate & WIDEXFER);\n\t\t\t\t\toffset = MAX_OFFSET_ULTRA2;\n\t\t\t\t} else\n\t\t\t\t\toffset = ahc_inb(ahc, TARG_OFFSET + i);\n\t\t\t\tif ((scsirate & ~WIDEXFER) == 0 && offset != 0)\n\t\t\t\t\t \n\t\t\t\t\tscsirate |= 0x1c;\n\t\t\t\tmaxsync = AHC_SYNCRATE_ULTRA2;\n\t\t\t\tif ((ahc->features & AHC_DT) != 0)\n\t\t\t\t\tmaxsync = AHC_SYNCRATE_DT;\n\t\t\t\ttinfo->user.period =\n\t\t\t\t    ahc_find_period(ahc, scsirate, maxsync);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\ttinfo->user.period = 0;\n\t\t\t\telse\n\t\t\t\t\ttinfo->user.offset = MAX_OFFSET;\n\t\t\t\tif ((scsirate & SXFR_ULTRA2) <= 8 \n\t\t\t\t && (ahc->features & AHC_DT) != 0)\n\t\t\t\t\ttinfo->user.ppr_options =\n\t\t\t\t\t    MSG_EXT_PPR_DT_REQ;\n\t\t\t} else if ((scsirate & SOFS) != 0) {\n\t\t\t\tif ((scsirate & SXFR) == 0x40\n\t\t\t\t && (ultraenb & mask) != 0) {\n\t\t\t\t\t \n\t\t\t\t\tscsirate &= ~SXFR;\n\t\t\t\t\tultraenb &= ~mask;\n\t\t\t\t}\n\t\t\t\ttinfo->user.period =\n\t\t\t\t    ahc_find_period(ahc, scsirate,\n\t\t\t\t\t\t    (ultraenb & mask)\n\t\t\t\t\t\t   ? AHC_SYNCRATE_ULTRA\n\t\t\t\t\t\t   : AHC_SYNCRATE_FAST);\n\t\t\t\tif (tinfo->user.period != 0)\n\t\t\t\t\ttinfo->user.offset = MAX_OFFSET;\n\t\t\t}\n\t\t\tif (tinfo->user.period == 0)\n\t\t\t\ttinfo->user.offset = 0;\n\t\t\tif ((scsirate & WIDEXFER) != 0\n\t\t\t && (ahc->features & AHC_WIDE) != 0)\n\t\t\t\ttinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\n\t\t\ttinfo->user.protocol_version = 4;\n\t\t\tif ((ahc->features & AHC_DT) != 0)\n\t\t\t\ttinfo->user.transport_version = 3;\n\t\t\telse\n\t\t\t\ttinfo->user.transport_version = 2;\n\t\t\ttinfo->goal.protocol_version = 2;\n\t\t\ttinfo->goal.transport_version = 2;\n\t\t\ttinfo->curr.protocol_version = 2;\n\t\t\ttinfo->curr.transport_version = 2;\n\t\t}\n\t\ttstate->ultraenb = 0;\n\t}\n\tahc->user_discenable = discenable;\n\tahc->user_tagenable = tagenable;\n\n\treturn (ahc->bus_chip_init(ahc));\n}\n\nvoid\nahc_intr_enable(struct ahc_softc *ahc, int enable)\n{\n\tu_int hcntrl;\n\n\thcntrl = ahc_inb(ahc, HCNTRL);\n\thcntrl &= ~INTEN;\n\tahc->pause &= ~INTEN;\n\tahc->unpause &= ~INTEN;\n\tif (enable) {\n\t\thcntrl |= INTEN;\n\t\tahc->pause |= INTEN;\n\t\tahc->unpause |= INTEN;\n\t}\n\tahc_outb(ahc, HCNTRL, hcntrl);\n}\n\n \nvoid\nahc_pause_and_flushwork(struct ahc_softc *ahc)\n{\n\tint intstat;\n\tint maxloops;\n\tint paused;\n\n\tmaxloops = 1000;\n\tahc->flags |= AHC_ALL_INTERRUPTS;\n\tpaused = FALSE;\n\tdo {\n\t\tif (paused) {\n\t\t\tahc_unpause(ahc);\n\t\t\t \n\t\t\tahc_delay(500);\n\t\t}\n\t\tahc_intr(ahc);\n\t\tahc_pause(ahc);\n\t\tpaused = TRUE;\n\t\tahc_outb(ahc, SCSISEQ, ahc_inb(ahc, SCSISEQ) & ~ENSELO);\n\t\tintstat = ahc_inb(ahc, INTSTAT);\n\t\tif ((intstat & INT_PEND) == 0) {\n\t\t\tahc_clear_critical_section(ahc);\n\t\t\tintstat = ahc_inb(ahc, INTSTAT);\n\t\t}\n\t} while (--maxloops\n\t      && (intstat != 0xFF || (ahc->features & AHC_REMOVABLE) == 0)\n\t      && ((intstat & INT_PEND) != 0\n\t       || (ahc_inb(ahc, SSTAT0) & (SELDO|SELINGO)) != 0));\n\tif (maxloops == 0) {\n\t\tprintk(\"Infinite interrupt loop, INTSTAT = %x\",\n\t\t       ahc_inb(ahc, INTSTAT));\n\t}\n\tahc_platform_flushwork(ahc);\n\tahc->flags &= ~AHC_ALL_INTERRUPTS;\n}\n\nint __maybe_unused\nahc_suspend(struct ahc_softc *ahc)\n{\n\n\tahc_pause_and_flushwork(ahc);\n\n\tif (LIST_FIRST(&ahc->pending_scbs) != NULL) {\n\t\tahc_unpause(ahc);\n\t\treturn (EBUSY);\n\t}\n\n#ifdef AHC_TARGET_MODE\n\t \n\tif (ahc->pending_device != NULL) {\n\t\tahc_unpause(ahc);\n\t\treturn (EBUSY);\n\t}\n#endif\n\tahc_shutdown(ahc);\n\treturn (0);\n}\n\nint __maybe_unused\nahc_resume(struct ahc_softc *ahc)\n{\n\n\tahc_reset(ahc,  TRUE);\n\tahc_intr_enable(ahc, TRUE);\n\tahc_restart(ahc);\n\treturn (0);\n}\n \n \nstatic u_int\nahc_index_busy_tcl(struct ahc_softc *ahc, u_int tcl)\n{\n\tu_int scbid;\n\tu_int target_offset;\n\n\tif ((ahc->flags & AHC_SCB_BTT) != 0) {\n\t\tu_int saved_scbptr;\n\n\t\tsaved_scbptr = ahc_inb(ahc, SCBPTR);\n\t\tahc_outb(ahc, SCBPTR, TCL_LUN(tcl));\n\t\tscbid = ahc_inb(ahc, SCB_64_BTT + TCL_TARGET_OFFSET(tcl));\n\t\tahc_outb(ahc, SCBPTR, saved_scbptr);\n\t} else {\n\t\ttarget_offset = TCL_TARGET_OFFSET(tcl);\n\t\tscbid = ahc_inb(ahc, BUSY_TARGETS + target_offset);\n\t}\n\n\treturn (scbid);\n}\n\nstatic void\nahc_unbusy_tcl(struct ahc_softc *ahc, u_int tcl)\n{\n\tu_int target_offset;\n\n\tif ((ahc->flags & AHC_SCB_BTT) != 0) {\n\t\tu_int saved_scbptr;\n\n\t\tsaved_scbptr = ahc_inb(ahc, SCBPTR);\n\t\tahc_outb(ahc, SCBPTR, TCL_LUN(tcl));\n\t\tahc_outb(ahc, SCB_64_BTT+TCL_TARGET_OFFSET(tcl), SCB_LIST_NULL);\n\t\tahc_outb(ahc, SCBPTR, saved_scbptr);\n\t} else {\n\t\ttarget_offset = TCL_TARGET_OFFSET(tcl);\n\t\tahc_outb(ahc, BUSY_TARGETS + target_offset, SCB_LIST_NULL);\n\t}\n}\n\nstatic void\nahc_busy_tcl(struct ahc_softc *ahc, u_int tcl, u_int scbid)\n{\n\tu_int target_offset;\n\n\tif ((ahc->flags & AHC_SCB_BTT) != 0) {\n\t\tu_int saved_scbptr;\n\n\t\tsaved_scbptr = ahc_inb(ahc, SCBPTR);\n\t\tahc_outb(ahc, SCBPTR, TCL_LUN(tcl));\n\t\tahc_outb(ahc, SCB_64_BTT + TCL_TARGET_OFFSET(tcl), scbid);\n\t\tahc_outb(ahc, SCBPTR, saved_scbptr);\n\t} else {\n\t\ttarget_offset = TCL_TARGET_OFFSET(tcl);\n\t\tahc_outb(ahc, BUSY_TARGETS + target_offset, scbid);\n\t}\n}\n\n \nint\nahc_match_scb(struct ahc_softc *ahc, struct scb *scb, int target,\n\t      char channel, int lun, u_int tag, role_t role)\n{\n\tint targ = SCB_GET_TARGET(ahc, scb);\n\tchar chan = SCB_GET_CHANNEL(ahc, scb);\n\tint slun = SCB_GET_LUN(scb);\n\tint match;\n\n\tmatch = ((chan == channel) || (channel == ALL_CHANNELS));\n\tif (match != 0)\n\t\tmatch = ((targ == target) || (target == CAM_TARGET_WILDCARD));\n\tif (match != 0)\n\t\tmatch = ((lun == slun) || (lun == CAM_LUN_WILDCARD));\n\tif (match != 0) {\n#ifdef AHC_TARGET_MODE\n\t\tint group;\n\n\t\tgroup = XPT_FC_GROUP(scb->io_ctx->ccb_h.func_code);\n\t\tif (role == ROLE_INITIATOR) {\n\t\t\tmatch = (group != XPT_FC_GROUP_TMODE)\n\t\t\t      && ((tag == scb->hscb->tag)\n\t\t\t       || (tag == SCB_LIST_NULL));\n\t\t} else if (role == ROLE_TARGET) {\n\t\t\tmatch = (group == XPT_FC_GROUP_TMODE)\n\t\t\t      && ((tag == scb->io_ctx->csio.tag_id)\n\t\t\t       || (tag == SCB_LIST_NULL));\n\t\t}\n#else  \n\t\tmatch = ((tag == scb->hscb->tag) || (tag == SCB_LIST_NULL));\n#endif  \n\t}\n\n\treturn match;\n}\n\nstatic void\nahc_freeze_devq(struct ahc_softc *ahc, struct scb *scb)\n{\n\tint\ttarget;\n\tchar\tchannel;\n\tint\tlun;\n\n\ttarget = SCB_GET_TARGET(ahc, scb);\n\tlun = SCB_GET_LUN(scb);\n\tchannel = SCB_GET_CHANNEL(ahc, scb);\n\n\tahc_search_qinfifo(ahc, target, channel, lun,\n\t\t\t    SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t   CAM_REQUEUE_REQ, SEARCH_COMPLETE);\n\n\tahc_platform_freeze_devq(ahc, scb);\n}\n\nvoid\nahc_qinfifo_requeue_tail(struct ahc_softc *ahc, struct scb *scb)\n{\n\tstruct scb *prev_scb;\n\n\tprev_scb = NULL;\n\tif (ahc_qinfifo_count(ahc) != 0) {\n\t\tu_int prev_tag;\n\t\tuint8_t prev_pos;\n\n\t\tprev_pos = ahc->qinfifonext - 1;\n\t\tprev_tag = ahc->qinfifo[prev_pos];\n\t\tprev_scb = ahc_lookup_scb(ahc, prev_tag);\n\t}\n\tahc_qinfifo_requeue(ahc, prev_scb, scb);\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t} else {\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t}\n}\n\nstatic void\nahc_qinfifo_requeue(struct ahc_softc *ahc, struct scb *prev_scb,\n\t\t    struct scb *scb)\n{\n\tif (prev_scb == NULL) {\n\t\tahc_outb(ahc, NEXT_QUEUED_SCB, scb->hscb->tag);\n\t} else {\n\t\tprev_scb->hscb->next = scb->hscb->tag;\n\t\tahc_sync_scb(ahc, prev_scb,\n\t\t\t     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\n\t}\n\tahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;\n\tscb->hscb->next = ahc->next_queued_scb->hscb->tag;\n\tahc_sync_scb(ahc, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\n}\n\nstatic int\nahc_qinfifo_count(struct ahc_softc *ahc)\n{\n\tuint8_t qinpos;\n\tuint8_t diff;\n\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tqinpos = ahc_inb(ahc, SNSCB_QOFF);\n\t\tahc_outb(ahc, SNSCB_QOFF, qinpos);\n\t} else\n\t\tqinpos = ahc_inb(ahc, QINPOS);\n\tdiff = ahc->qinfifonext - qinpos;\n\treturn (diff);\n}\n\nint\nahc_search_qinfifo(struct ahc_softc *ahc, int target, char channel,\n\t\t   int lun, u_int tag, role_t role, uint32_t status,\n\t\t   ahc_search_action action)\n{\n\tstruct\tscb *scb;\n\tstruct\tscb *prev_scb;\n\tuint8_t qinstart;\n\tuint8_t qinpos;\n\tuint8_t qintail;\n\tuint8_t next;\n\tuint8_t prev;\n\tuint8_t curscbptr;\n\tint\tfound;\n\tint\thave_qregs;\n\n\tqintail = ahc->qinfifonext;\n\thave_qregs = (ahc->features & AHC_QUEUE_REGS) != 0;\n\tif (have_qregs) {\n\t\tqinstart = ahc_inb(ahc, SNSCB_QOFF);\n\t\tahc_outb(ahc, SNSCB_QOFF, qinstart);\n\t} else\n\t\tqinstart = ahc_inb(ahc, QINPOS);\n\tqinpos = qinstart;\n\tfound = 0;\n\tprev_scb = NULL;\n\n\tif (action == SEARCH_COMPLETE) {\n\t\t \n\t\tahc_freeze_untagged_queues(ahc);\n\t}\n\n\t \n\tahc->qinfifonext = qinpos;\n\tahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);\n\n\twhile (qinpos != qintail) {\n\t\tscb = ahc_lookup_scb(ahc, ahc->qinfifo[qinpos]);\n\t\tif (scb == NULL) {\n\t\t\tprintk(\"qinpos = %d, SCB index = %d\\n\",\n\t\t\t\tqinpos, ahc->qinfifo[qinpos]);\n\t\t\tpanic(\"Loop 1\\n\");\n\t\t}\n\n\t\tif (ahc_match_scb(ahc, scb, target, channel, lun, tag, role)) {\n\t\t\t \n\t\t\tfound++;\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t{\n\t\t\t\tcam_status ostat;\n\t\t\t\tcam_status cstat;\n\n\t\t\t\tostat = ahc_get_transaction_status(scb);\n\t\t\t\tif (ostat == CAM_REQ_INPROG)\n\t\t\t\t\tahc_set_transaction_status(scb, status);\n\t\t\t\tcstat = ahc_get_transaction_status(scb);\n\t\t\t\tif (cstat != CAM_REQ_CMP)\n\t\t\t\t\tahc_freeze_scb(scb);\n\t\t\t\tif ((scb->flags & SCB_ACTIVE) == 0)\n\t\t\t\t\tprintk(\"Inactive SCB in qinfifo\\n\");\n\t\t\t\tahc_done(ahc, scb);\n\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tahc_qinfifo_requeue(ahc, prev_scb, scb);\n\t\t\t\tprev_scb = scb;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tahc_qinfifo_requeue(ahc, prev_scb, scb);\n\t\t\tprev_scb = scb;\n\t\t}\n\t\tqinpos++;\n\t}\n\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t} else {\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t}\n\n\tif (action != SEARCH_COUNT\n\t && (found != 0)\n\t && (qinstart != ahc->qinfifonext)) {\n\t\t \n\t\tscb = ahc_lookup_scb(ahc, ahc->qinfifo[qinstart]);\n\n\t\tif (scb == NULL) {\n\t\t\tprintk(\"found = %d, qinstart = %d, qinfifionext = %d\\n\",\n\t\t\t\tfound, qinstart, ahc->qinfifonext);\n\t\t\tpanic(\"First/Second Qinfifo fixup\\n\");\n\t\t}\n\t\t \n\t\tnext = scb->hscb->next;\n\t\tahc->scb_data->scbindex[scb->hscb->tag] = NULL;\n\t\tahc_swap_with_next_hscb(ahc, scb);\n\t\tscb->hscb->next = next;\n\t\tahc->qinfifo[qinstart] = scb->hscb->tag;\n\n\t\t \n\t\tahc_outb(ahc, NEXT_QUEUED_SCB, scb->hscb->tag);\n\n\t\t \n\t\tqintail = ahc->qinfifonext - 1;\n\t\tscb = ahc_lookup_scb(ahc, ahc->qinfifo[qintail]);\n\t\tscb->hscb->next = ahc->next_queued_scb->hscb->tag;\n\t}\n\n\t \n\tcurscbptr = ahc_inb(ahc, SCBPTR);\n\tnext = ahc_inb(ahc, WAITING_SCBH);   \n\tprev = SCB_LIST_NULL;\n\n\twhile (next != SCB_LIST_NULL) {\n\t\tuint8_t scb_index;\n\n\t\tahc_outb(ahc, SCBPTR, next);\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\tprintk(\"Waiting List inconsistency. \"\n\t\t\t       \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t       scb_index, ahc->scb_data->numscbs);\n\t\t\tahc_dump_card_state(ahc);\n\t\t\tpanic(\"for safety\");\n\t\t}\n\t\tscb = ahc_lookup_scb(ahc, scb_index);\n\t\tif (scb == NULL) {\n\t\t\tprintk(\"scb_index = %d, next = %d\\n\",\n\t\t\t\tscb_index, next);\n\t\t\tpanic(\"Waiting List traversal\\n\");\n\t\t}\n\t\tif (ahc_match_scb(ahc, scb, target, channel,\n\t\t\t\t  lun, SCB_LIST_NULL, role)) {\n\t\t\t \n\t\t\tfound++;\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t{\n\t\t\t\tcam_status ostat;\n\t\t\t\tcam_status cstat;\n\n\t\t\t\tostat = ahc_get_transaction_status(scb);\n\t\t\t\tif (ostat == CAM_REQ_INPROG)\n\t\t\t\t\tahc_set_transaction_status(scb,\n\t\t\t\t\t\t\t\t   status);\n\t\t\t\tcstat = ahc_get_transaction_status(scb);\n\t\t\t\tif (cstat != CAM_REQ_CMP)\n\t\t\t\t\tahc_freeze_scb(scb);\n\t\t\t\tif ((scb->flags & SCB_ACTIVE) == 0)\n\t\t\t\t\tprintk(\"Inactive SCB in Waiting List\\n\");\n\t\t\t\tahc_done(ahc, scb);\n\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tnext = ahc_rem_wscb(ahc, next, prev);\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tprev = next;\n\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, curscbptr);\n\n\tfound += ahc_search_untagged_queues(ahc,  NULL, target,\n\t\t\t\t\t    channel, lun, status, action);\n\n\tif (action == SEARCH_COMPLETE)\n\t\tahc_release_untagged_queues(ahc);\n\treturn (found);\n}\n\nint\nahc_search_untagged_queues(struct ahc_softc *ahc, ahc_io_ctx_t ctx,\n\t\t\t   int target, char channel, int lun, uint32_t status,\n\t\t\t   ahc_search_action action)\n{\n\tstruct\tscb *scb;\n\tint\tmaxtarget;\n\tint\tfound;\n\tint\ti;\n\n\tif (action == SEARCH_COMPLETE) {\n\t\t \n\t\tahc_freeze_untagged_queues(ahc);\n\t}\n\n\tfound = 0;\n\ti = 0;\n\tif ((ahc->flags & AHC_SCB_BTT) == 0) {\n\n\t\tmaxtarget = 16;\n\t\tif (target != CAM_TARGET_WILDCARD) {\n\n\t\t\ti = target;\n\t\t\tif (channel == 'B')\n\t\t\t\ti += 8;\n\t\t\tmaxtarget = i + 1;\n\t\t}\n\t} else {\n\t\tmaxtarget = 0;\n\t}\n\n\tfor (; i < maxtarget; i++) {\n\t\tstruct scb_tailq *untagged_q;\n\t\tstruct scb *next_scb;\n\n\t\tuntagged_q = &(ahc->untagged_queues[i]);\n\t\tnext_scb = TAILQ_FIRST(untagged_q);\n\t\twhile (next_scb != NULL) {\n\n\t\t\tscb = next_scb;\n\t\t\tnext_scb = TAILQ_NEXT(scb, links.tqe);\n\n\t\t\t \n\t\t\tif ((scb->flags & SCB_ACTIVE) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (ahc_match_scb(ahc, scb, target, channel, lun,\n\t\t\t\t\t  SCB_LIST_NULL, ROLE_INITIATOR) == 0\n\t\t\t || (ctx != NULL && ctx != scb->io_ctx))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tfound++;\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t{\n\t\t\t\tcam_status ostat;\n\t\t\t\tcam_status cstat;\n\n\t\t\t\tostat = ahc_get_transaction_status(scb);\n\t\t\t\tif (ostat == CAM_REQ_INPROG)\n\t\t\t\t\tahc_set_transaction_status(scb, status);\n\t\t\t\tcstat = ahc_get_transaction_status(scb);\n\t\t\t\tif (cstat != CAM_REQ_CMP)\n\t\t\t\t\tahc_freeze_scb(scb);\n\t\t\t\tif ((scb->flags & SCB_ACTIVE) == 0)\n\t\t\t\t\tprintk(\"Inactive SCB in untaggedQ\\n\");\n\t\t\t\tahc_done(ahc, scb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tscb->flags &= ~SCB_UNTAGGEDQ;\n\t\t\t\tTAILQ_REMOVE(untagged_q, scb, links.tqe);\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (action == SEARCH_COMPLETE)\n\t\tahc_release_untagged_queues(ahc);\n\treturn (found);\n}\n\nint\nahc_search_disc_list(struct ahc_softc *ahc, int target, char channel,\n\t\t     int lun, u_int tag, int stop_on_first, int remove,\n\t\t     int save_state)\n{\n\tstruct\tscb *scbp;\n\tu_int\tnext;\n\tu_int\tprev;\n\tu_int\tcount;\n\tu_int\tactive_scb;\n\n\tcount = 0;\n\tnext = ahc_inb(ahc, DISCONNECTED_SCBH);\n\tprev = SCB_LIST_NULL;\n\n\tif (save_state) {\n\t\t \n\t\tactive_scb = ahc_inb(ahc, SCBPTR);\n\t} else\n\t\t \n\t\tactive_scb = SCB_LIST_NULL;\n\n\twhile (next != SCB_LIST_NULL) {\n\t\tu_int scb_index;\n\n\t\tahc_outb(ahc, SCBPTR, next);\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\tprintk(\"Disconnected List inconsistency. \"\n\t\t\t       \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t       scb_index, ahc->scb_data->numscbs);\n\t\t\tahc_dump_card_state(ahc);\n\t\t\tpanic(\"for safety\");\n\t\t}\n\n\t\tif (next == prev) {\n\t\t\tpanic(\"Disconnected List Loop. \"\n\t\t\t      \"cur SCBPTR == %x, prev SCBPTR == %x.\",\n\t\t\t      next, prev);\n\t\t}\n\t\tscbp = ahc_lookup_scb(ahc, scb_index);\n\t\tif (ahc_match_scb(ahc, scbp, target, channel, lun,\n\t\t\t\t  tag, ROLE_INITIATOR)) {\n\t\t\tcount++;\n\t\t\tif (remove) {\n\t\t\t\tnext =\n\t\t\t\t    ahc_rem_scb_from_disc_list(ahc, prev, next);\n\t\t\t} else {\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t\tif (stop_on_first)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprev = next;\n\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t}\n\t}\n\tif (save_state)\n\t\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn (count);\n}\n\n \nstatic u_int\nahc_rem_scb_from_disc_list(struct ahc_softc *ahc, u_int prev, u_int scbptr)\n{\n\tu_int next;\n\n\tahc_outb(ahc, SCBPTR, scbptr);\n\tnext = ahc_inb(ahc, SCB_NEXT);\n\n\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\tahc_add_curscb_to_free_list(ahc);\n\n\tif (prev != SCB_LIST_NULL) {\n\t\tahc_outb(ahc, SCBPTR, prev);\n\t\tahc_outb(ahc, SCB_NEXT, next);\n\t} else\n\t\tahc_outb(ahc, DISCONNECTED_SCBH, next);\n\n\treturn (next);\n}\n\n \nstatic void\nahc_add_curscb_to_free_list(struct ahc_softc *ahc)\n{\n\t \n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tif ((ahc->flags & AHC_PAGESCBS) != 0) {\n\t\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\t\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n\t}\n}\n\n \nstatic u_int\nahc_rem_wscb(struct ahc_softc *ahc, u_int scbpos, u_int prev)\n{\n\tu_int curscb, next;\n\n\t \n\tcurscb = ahc_inb(ahc, SCBPTR);\n\tahc_outb(ahc, SCBPTR, scbpos);\n\tnext = ahc_inb(ahc, SCB_NEXT);\n\n\t \n\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\tahc_add_curscb_to_free_list(ahc);\n\n\t \n\tif (prev == SCB_LIST_NULL) {\n\t\t \n\t\tahc_outb(ahc, WAITING_SCBH, next);\n\n\t\t \n\t\tahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));\n\t} else {\n\t\t \n\t\tahc_outb(ahc, SCBPTR, prev);\n\t\tahc_outb(ahc, SCB_NEXT, next);\n\t}\n\n\t \n\tahc_outb(ahc, SCBPTR, curscb);\n\treturn next;\n}\n\n \n \nstatic int\nahc_abort_scbs(struct ahc_softc *ahc, int target, char channel,\n\t       int lun, u_int tag, role_t role, uint32_t status)\n{\n\tstruct\tscb *scbp;\n\tstruct\tscb *scbp_next;\n\tu_int\tactive_scb;\n\tint\ti, j;\n\tint\tmaxtarget;\n\tint\tminlun;\n\tint\tmaxlun;\n\n\tint\tfound;\n\n\t \n\tahc_freeze_untagged_queues(ahc);\n\n\t \n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\n\tfound = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,\n\t\t\t\t   role, CAM_REQUEUE_REQ, SEARCH_COMPLETE);\n\n\t \n\ti = 0;\n\tmaxtarget = 16;\n\tif (target != CAM_TARGET_WILDCARD) {\n\t\ti = target;\n\t\tif (channel == 'B')\n\t\t\ti += 8;\n\t\tmaxtarget = i + 1;\n\t}\n\n\tif (lun == CAM_LUN_WILDCARD) {\n\n\t\t \n\t\tminlun = 0;\n\t\tmaxlun = 1;\n\t\tif ((ahc->flags & AHC_SCB_BTT) != 0)\n\t\t\tmaxlun = AHC_NUM_LUNS;\n\t} else {\n\t\tminlun = lun;\n\t\tmaxlun = lun + 1;\n\t}\n\n\tif (role != ROLE_TARGET) {\n\t\tfor (;i < maxtarget; i++) {\n\t\t\tfor (j = minlun;j < maxlun; j++) {\n\t\t\t\tu_int scbid;\n\t\t\t\tu_int tcl;\n\n\t\t\t\ttcl = BUILD_TCL(i << 4, j);\n\t\t\t\tscbid = ahc_index_busy_tcl(ahc, tcl);\n\t\t\t\tscbp = ahc_lookup_scb(ahc, scbid);\n\t\t\t\tif (scbp == NULL\n\t\t\t\t || ahc_match_scb(ahc, scbp, target, channel,\n\t\t\t\t\t\t  lun, tag, role) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, j));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tahc_search_disc_list(ahc, target, channel, lun, tag,\n\t\t\t\t      FALSE,  TRUE,\n\t\t\t\t      FALSE);\n\t}\n\n\t \n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scbid;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscbid = ahc_inb(ahc, SCB_TAG);\n\t\tscbp = ahc_lookup_scb(ahc, scbid);\n\t\tif ((scbp == NULL && scbid != SCB_LIST_NULL)\n\t\t || (scbp != NULL\n\t\t  && ahc_match_scb(ahc, scbp, target, channel, lun, tag, role)))\n\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\n\t \n\tscbp_next = LIST_FIRST(&ahc->pending_scbs);\n\twhile (scbp_next != NULL) {\n\t\tscbp = scbp_next;\n\t\tscbp_next = LIST_NEXT(scbp, pending_links);\n\t\tif (ahc_match_scb(ahc, scbp, target, channel, lun, tag, role)) {\n\t\t\tcam_status ostat;\n\n\t\t\tostat = ahc_get_transaction_status(scbp);\n\t\t\tif (ostat == CAM_REQ_INPROG)\n\t\t\t\tahc_set_transaction_status(scbp, status);\n\t\t\tif (ahc_get_transaction_status(scbp) != CAM_REQ_CMP)\n\t\t\t\tahc_freeze_scb(scbp);\n\t\t\tif ((scbp->flags & SCB_ACTIVE) == 0)\n\t\t\t\tprintk(\"Inactive SCB on pending list\\n\");\n\t\t\tahc_done(ahc, scbp);\n\t\t\tfound++;\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, active_scb);\n\tahc_platform_abort_scbs(ahc, target, channel, lun, tag, role, status);\n\tahc_release_untagged_queues(ahc);\n\treturn found;\n}\n\nstatic void\nahc_reset_current_bus(struct ahc_softc *ahc)\n{\n\tuint8_t scsiseq;\n\n\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENSCSIRST);\n\tscsiseq = ahc_inb(ahc, SCSISEQ);\n\tahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);\n\tahc_flush_device_writes(ahc);\n\tahc_delay(AHC_BUSRESET_DELAY);\n\t \n\tahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);\n\n\tahc_clear_intstat(ahc);\n\n\t \n\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) | ENSCSIRST);\n}\n\nint\nahc_reset_channel(struct ahc_softc *ahc, char channel, int initiate_reset)\n{\n\tstruct\tahc_devinfo devinfo;\n\tu_int\tinitiator, target, max_scsiid;\n\tu_int\tsblkctl;\n\tu_int\tscsiseq;\n\tu_int\tsimode1;\n\tint\tfound;\n\tint\trestart_needed;\n\tchar\tcur_channel;\n\n\tahc->pending_device = NULL;\n\n\tahc_compile_devinfo(&devinfo,\n\t\t\t    CAM_TARGET_WILDCARD,\n\t\t\t    CAM_TARGET_WILDCARD,\n\t\t\t    CAM_LUN_WILDCARD,\n\t\t\t    channel, ROLE_UNKNOWN);\n\tahc_pause(ahc);\n\n\t \n\tahc_clear_critical_section(ahc);\n\n\t \n\tahc_run_qoutfifo(ahc);\n#ifdef AHC_TARGET_MODE\n\t \n\tif ((ahc->flags & AHC_TARGETROLE) != 0) {\n\t\tahc_run_tqinfifo(ahc,  TRUE);\n\t}\n#endif\n\n\t \n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tcur_channel = 'A';\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((sblkctl & SELBUSB) != 0))\n\t    cur_channel = 'B';\n\tscsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);\n\tif (cur_channel != channel) {\n\t\t \n\t\tahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\n\t\tsimode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);\n#ifdef AHC_TARGET_MODE\n\t\t \n\t\tif ((ahc->flags & AHC_TARGETROLE) != 0)\n\t\t\tsimode1 |= ENSCSIRST;\n#endif\n\t\tahc_outb(ahc, SIMODE1, simode1);\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SCSISEQ, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\trestart_needed = FALSE;\n\t} else {\n\t\t \n\t\tsimode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);\n#ifdef AHC_TARGET_MODE\n\t\t \n\t\tif ((ahc->flags & AHC_TARGETROLE) != 0)\n\t\t\tsimode1 |= ENSCSIRST;\n#endif\n\t\tahc_outb(ahc, SIMODE1, simode1);\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SCSISEQ, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\trestart_needed = TRUE;\n\t}\n\n\t \n\tfound = ahc_abort_scbs(ahc, CAM_TARGET_WILDCARD, channel,\n\t\t\t       CAM_LUN_WILDCARD, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, CAM_SCSI_BUS_RESET);\n\n\tmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\n\n#ifdef AHC_TARGET_MODE\n\t \n\tfor (target = 0; target <= max_scsiid; target++) {\n\t\tstruct ahc_tmode_tstate* tstate;\n\t\tu_int lun;\n\n\t\ttstate = ahc->enabled_targets[target];\n\t\tif (tstate == NULL)\n\t\t\tcontinue;\n\t\tfor (lun = 0; lun < AHC_NUM_LUNS; lun++) {\n\t\t\tstruct ahc_tmode_lstate* lstate;\n\n\t\t\tlstate = tstate->enabled_luns[lun];\n\t\t\tif (lstate == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tahc_queue_lstate_event(ahc, lstate, CAM_TARGET_WILDCARD,\n\t\t\t\t\t       EVENT_TYPE_BUS_RESET,  0);\n\t\t\tahc_send_lstate_events(ahc, lstate);\n\t\t}\n\t}\n#endif\n\t \n\tahc_send_async(ahc, devinfo.channel, CAM_TARGET_WILDCARD,\n\t\t       CAM_LUN_WILDCARD, AC_BUS_RESET);\n\n\t \n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahc->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\tahc_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    CAM_LUN_WILDCARD,\n\t\t\t\t\t    channel, ROLE_UNKNOWN);\n\t\t\tahc_set_width(ahc, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHC_TRANS_CUR,  TRUE);\n\t\t\tahc_set_syncrate(ahc, &devinfo,  NULL,\n\t\t\t\t\t  0,  0,\n\t\t\t\t\t  0, AHC_TRANS_CUR,\n\t\t\t\t\t  TRUE);\n\t\t}\n\t}\n\n\tif (restart_needed)\n\t\tahc_restart(ahc);\n\telse\n\t\tahc_unpause(ahc);\n\treturn found;\n}\n\n\n \n \nstatic void\nahc_calc_residual(struct ahc_softc *ahc, struct scb *scb)\n{\n\tstruct hardware_scb *hscb;\n\tstruct status_pkt *spkt;\n\tuint32_t sgptr;\n\tuint32_t resid_sgptr;\n\tuint32_t resid;\n\n\t \n\n\thscb = scb->hscb;\n\tsgptr = ahc_le32toh(hscb->sgptr);\n\tif ((sgptr & SG_RESID_VALID) == 0)\n\t\t \n\t\treturn;\n\tsgptr &= ~SG_RESID_VALID;\n\n\tif ((sgptr & SG_LIST_NULL) != 0)\n\t\t \n\t\treturn;\n\n\tspkt = &hscb->shared_data.status;\n\tresid_sgptr = ahc_le32toh(spkt->residual_sg_ptr);\n\tif ((sgptr & SG_FULL_RESID) != 0) {\n\t\t \n\t\tresid = ahc_get_transfer_length(scb);\n\t} else if ((resid_sgptr & SG_LIST_NULL) != 0) {\n\t\t \n\t\treturn;\n\t} else if ((resid_sgptr & ~SG_PTR_MASK) != 0) {\n\t\tpanic(\"Bogus resid sgptr value 0x%x\\n\", resid_sgptr);\n\t} else {\n\t\tstruct ahc_dma_seg *sg;\n\n\t\t \n\t\tresid = ahc_le32toh(spkt->residual_datacnt) & AHC_SG_LEN_MASK;\n\t\tsg = ahc_sg_bus_to_virt(scb, resid_sgptr & SG_PTR_MASK);\n\n\t\t \n\t\tsg--;\n\n\t\t \n\t\twhile ((ahc_le32toh(sg->len) & AHC_DMA_LAST_SEG) == 0) {\n\t\t\tsg++;\n\t\t\tresid += ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;\n\t\t}\n\t}\n\tif ((scb->flags & SCB_SENSE) == 0)\n\t\tahc_set_residual(scb, resid);\n\telse\n\t\tahc_set_sense_residual(scb, resid);\n\n#ifdef AHC_DEBUG\n\tif ((ahc_debug & AHC_SHOW_MISC) != 0) {\n\t\tahc_print_path(ahc, scb);\n\t\tprintk(\"Handled %sResidual of %d bytes\\n\",\n\t\t       (scb->flags & SCB_SENSE) ? \"Sense \" : \"\", resid);\n\t}\n#endif\n}\n\n \n#ifdef AHC_TARGET_MODE\n \nstatic void\nahc_queue_lstate_event(struct ahc_softc *ahc, struct ahc_tmode_lstate *lstate,\n\t\t       u_int initiator_id, u_int event_type, u_int event_arg)\n{\n\tstruct ahc_tmode_event *event;\n\tint pending;\n\n\txpt_freeze_devq(lstate->path,  1);\n\tif (lstate->event_w_idx >= lstate->event_r_idx)\n\t\tpending = lstate->event_w_idx - lstate->event_r_idx;\n\telse\n\t\tpending = AHC_TMODE_EVENT_BUFFER_SIZE + 1\n\t\t\t- (lstate->event_r_idx - lstate->event_w_idx);\n\n\tif (event_type == EVENT_TYPE_BUS_RESET\n\t || event_type == TARGET_RESET) {\n\t\t \n\t\tlstate->event_r_idx = 0;\n\t\tlstate->event_w_idx = 0;\n\t\txpt_release_devq(lstate->path, pending,  FALSE);\n\t}\n\n\tif (pending == AHC_TMODE_EVENT_BUFFER_SIZE) {\n\t\txpt_print_path(lstate->path);\n\t\tprintk(\"immediate event %x:%x lost\\n\",\n\t\t       lstate->event_buffer[lstate->event_r_idx].event_type,\n\t\t       lstate->event_buffer[lstate->event_r_idx].event_arg);\n\t\tlstate->event_r_idx++;\n\t\tif (lstate->event_r_idx == AHC_TMODE_EVENT_BUFFER_SIZE)\n\t\t\tlstate->event_r_idx = 0;\n\t\txpt_release_devq(lstate->path,  1,  FALSE);\n\t}\n\n\tevent = &lstate->event_buffer[lstate->event_w_idx];\n\tevent->initiator_id = initiator_id;\n\tevent->event_type = event_type;\n\tevent->event_arg = event_arg;\n\tlstate->event_w_idx++;\n\tif (lstate->event_w_idx == AHC_TMODE_EVENT_BUFFER_SIZE)\n\t\tlstate->event_w_idx = 0;\n}\n\n \nvoid\nahc_send_lstate_events(struct ahc_softc *ahc, struct ahc_tmode_lstate *lstate)\n{\n\tstruct ccb_hdr *ccbh;\n\tstruct ccb_immed_notify *inot;\n\n\twhile (lstate->event_r_idx != lstate->event_w_idx\n\t    && (ccbh = SLIST_FIRST(&lstate->immed_notifies)) != NULL) {\n\t\tstruct ahc_tmode_event *event;\n\n\t\tevent = &lstate->event_buffer[lstate->event_r_idx];\n\t\tSLIST_REMOVE_HEAD(&lstate->immed_notifies, sim_links.sle);\n\t\tinot = (struct ccb_immed_notify *)ccbh;\n\t\tswitch (event->event_type) {\n\t\tcase EVENT_TYPE_BUS_RESET:\n\t\t\tccbh->status = CAM_SCSI_BUS_RESET|CAM_DEV_QFRZN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tccbh->status = CAM_MESSAGE_RECV|CAM_DEV_QFRZN;\n\t\t\tinot->message_args[0] = event->event_type;\n\t\t\tinot->message_args[1] = event->event_arg;\n\t\t\tbreak;\n\t\t}\n\t\tinot->initiator_id = event->initiator_id;\n\t\tinot->sense_len = 0;\n\t\txpt_done((union ccb *)inot);\n\t\tlstate->event_r_idx++;\n\t\tif (lstate->event_r_idx == AHC_TMODE_EVENT_BUFFER_SIZE)\n\t\t\tlstate->event_r_idx = 0;\n\t}\n}\n#endif\n\n \n\n#ifdef AHC_DUMP_SEQ\nvoid\nahc_dumpseq(struct ahc_softc* ahc)\n{\n\tint i;\n\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\n\tahc_outb(ahc, SEQADDR0, 0);\n\tahc_outb(ahc, SEQADDR1, 0);\n\tfor (i = 0; i < ahc->instruction_ram_size; i++) {\n\t\tuint8_t ins_bytes[4];\n\n\t\tahc_insb(ahc, SEQRAM, ins_bytes, 4);\n\t\tprintk(\"0x%08x\\n\", ins_bytes[0] << 24\n\t\t\t\t | ins_bytes[1] << 16\n\t\t\t\t | ins_bytes[2] << 8\n\t\t\t\t | ins_bytes[3]);\n\t}\n}\n#endif\n\nstatic int\nahc_loadseq(struct ahc_softc *ahc)\n{\n\tstruct\tcs cs_table[NUM_CRITICAL_SECTIONS];\n\tu_int\tbegin_set[NUM_CRITICAL_SECTIONS];\n\tu_int\tend_set[NUM_CRITICAL_SECTIONS];\n\tconst struct patch *cur_patch;\n\tu_int\tcs_count;\n\tu_int\tcur_cs;\n\tu_int\ti;\n\tu_int\tskip_addr;\n\tu_int\tsg_prefetch_cnt;\n\tint\tdownloaded;\n\tuint8_t\tdownload_consts[7];\n\n\t \n\tcs_count = 0;\n\tcur_cs = 0;\n\tmemset(begin_set, 0, sizeof(begin_set));\n\tmemset(end_set, 0, sizeof(end_set));\n\n\t \n\tdownload_consts[QOUTFIFO_OFFSET] = 0;\n\tif (ahc->targetcmds != NULL)\n\t\tdownload_consts[QOUTFIFO_OFFSET] += 32;\n\tdownload_consts[QINFIFO_OFFSET] = download_consts[QOUTFIFO_OFFSET] + 1;\n\tdownload_consts[CACHESIZE_MASK] = ahc->pci_cachesize - 1;\n\tdownload_consts[INVERTED_CACHESIZE_MASK] = ~(ahc->pci_cachesize - 1);\n\tsg_prefetch_cnt = ahc->pci_cachesize;\n\tif (sg_prefetch_cnt < (2 * sizeof(struct ahc_dma_seg)))\n\t\tsg_prefetch_cnt = 2 * sizeof(struct ahc_dma_seg);\n\tdownload_consts[SG_PREFETCH_CNT] = sg_prefetch_cnt;\n\tdownload_consts[SG_PREFETCH_ALIGN_MASK] = ~(sg_prefetch_cnt - 1);\n\tdownload_consts[SG_PREFETCH_ADDR_MASK] = (sg_prefetch_cnt - 1);\n\n\tcur_patch = patches;\n\tdownloaded = 0;\n\tskip_addr = 0;\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\n\tahc_outb(ahc, SEQADDR0, 0);\n\tahc_outb(ahc, SEQADDR1, 0);\n\n\tfor (i = 0; i < sizeof(seqprog)/4; i++) {\n\t\tif (ahc_check_patch(ahc, &cur_patch, i, &skip_addr) == 0) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (downloaded == ahc->instruction_ram_size) {\n\t\t\t \n\t\t\tprintk(\"\\n%s: Program too large for instruction memory \"\n\t\t\t       \"size of %d!\\n\", ahc_name(ahc),\n\t\t\t       ahc->instruction_ram_size);\n\t\t\treturn (ENOMEM);\n\t\t}\n\n\t\t \n\t\tfor (; cur_cs < NUM_CRITICAL_SECTIONS; cur_cs++) {\n\t\t\tif (critical_sections[cur_cs].end <= i) {\n\t\t\t\tif (begin_set[cs_count] == TRUE\n\t\t\t\t && end_set[cs_count] == FALSE) {\n\t\t\t\t\tcs_table[cs_count].end = downloaded;\n\t\t\t\t\tend_set[cs_count] = TRUE;\n\t\t\t\t\tcs_count++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (critical_sections[cur_cs].begin <= i\n\t\t\t && begin_set[cs_count] == FALSE) {\n\t\t\t\tcs_table[cs_count].begin = downloaded;\n\t\t\t\tbegin_set[cs_count] = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tahc_download_instr(ahc, i, download_consts);\n\t\tdownloaded++;\n\t}\n\n\tahc->num_critical_sections = cs_count;\n\tif (cs_count != 0) {\n\n\t\tcs_count *= sizeof(struct cs);\n\t\tahc->critical_sections = kmemdup(cs_table, cs_count, GFP_ATOMIC);\n\t\tif (ahc->critical_sections == NULL)\n\t\t\tpanic(\"ahc_loadseq: Could not malloc\");\n\t}\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);\n\n\tif (bootverbose) {\n\t\tprintk(\" %d instructions downloaded\\n\", downloaded);\n\t\tprintk(\"%s: Features 0x%x, Bugs 0x%x, Flags 0x%x\\n\",\n\t\t       ahc_name(ahc), ahc->features, ahc->bugs, ahc->flags);\n\t}\n\treturn (0);\n}\n\nstatic int\nahc_check_patch(struct ahc_softc *ahc, const struct patch **start_patch,\n\t\tu_int start_instr, u_int *skip_addr)\n{\n\tconst struct patch *cur_patch;\n\tconst struct patch *last_patch;\n\tu_int\tnum_patches;\n\n\tnum_patches = ARRAY_SIZE(patches);\n\tlast_patch = &patches[num_patches];\n\tcur_patch = *start_patch;\n\n\twhile (cur_patch < last_patch && start_instr == cur_patch->begin) {\n\n\t\tif (cur_patch->patch_func(ahc) == 0) {\n\n\t\t\t \n\t\t\t*skip_addr = start_instr + cur_patch->skip_instr;\n\t\t\tcur_patch += cur_patch->skip_patch;\n\t\t} else {\n\t\t\t \n\t\t\tcur_patch++;\n\t\t}\n\t}\n\n\t*start_patch = cur_patch;\n\tif (start_instr < *skip_addr)\n\t\t \n\t\treturn (0);\n\n\treturn (1);\n}\n\nstatic void\nahc_download_instr(struct ahc_softc *ahc, u_int instrptr, uint8_t *dconsts)\n{\n\tunion\tins_formats instr;\n\tstruct\tins_format1 *fmt1_ins;\n\tstruct\tins_format3 *fmt3_ins;\n\tu_int\topcode;\n\n\t \n\tinstr.integer = ahc_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);\n\n\tfmt1_ins = &instr.format1;\n\tfmt3_ins = NULL;\n\n\t \n\topcode = instr.format1.opcode;\n\tswitch (opcode) {\n\tcase AIC_OP_JMP:\n\tcase AIC_OP_JC:\n\tcase AIC_OP_JNC:\n\tcase AIC_OP_CALL:\n\tcase AIC_OP_JNE:\n\tcase AIC_OP_JNZ:\n\tcase AIC_OP_JE:\n\tcase AIC_OP_JZ:\n\t{\n\t\tconst struct patch *cur_patch;\n\t\tint address_offset;\n\t\tu_int address;\n\t\tu_int skip_addr;\n\t\tu_int i;\n\n\t\tfmt3_ins = &instr.format3;\n\t\taddress_offset = 0;\n\t\taddress = fmt3_ins->address;\n\t\tcur_patch = patches;\n\t\tskip_addr = 0;\n\n\t\tfor (i = 0; i < address;) {\n\n\t\t\tahc_check_patch(ahc, &cur_patch, i, &skip_addr);\n\n\t\t\tif (skip_addr > i) {\n\t\t\t\tint end_addr;\n\n\t\t\t\tend_addr = min(address, skip_addr);\n\t\t\t\taddress_offset += end_addr - i;\n\t\t\t\ti = skip_addr;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\taddress -= address_offset;\n\t\tfmt3_ins->address = address;\n\t}\n\t\tfallthrough;\n\tcase AIC_OP_OR:\n\tcase AIC_OP_AND:\n\tcase AIC_OP_XOR:\n\tcase AIC_OP_ADD:\n\tcase AIC_OP_ADC:\n\tcase AIC_OP_BMOV:\n\t\tif (fmt1_ins->parity != 0) {\n\t\t\tfmt1_ins->immediate = dconsts[fmt1_ins->immediate];\n\t\t}\n\t\tfmt1_ins->parity = 0;\n\t\tif ((ahc->features & AHC_CMD_CHAN) == 0\n\t\t && opcode == AIC_OP_BMOV) {\n\t\t\t \n\t\t\tif (fmt1_ins->immediate != 1)\n\t\t\t\tpanic(\"%s: BMOV not supported\\n\",\n\t\t\t\t      ahc_name(ahc));\n\t\t\tfmt1_ins->opcode = AIC_OP_AND;\n\t\t\tfmt1_ins->immediate = 0xff;\n\t\t}\n\t\tfallthrough;\n\tcase AIC_OP_ROL:\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tint i, count;\n\n\t\t\t \n\t\t\tfor (i = 0, count = 0; i < 31; i++) {\n\t\t\t\tuint32_t mask;\n\n\t\t\t\tmask = 0x01 << i;\n\t\t\t\tif ((instr.integer & mask) != 0)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif ((count & 0x01) == 0)\n\t\t\t\tinstr.format1.parity = 1;\n\t\t} else {\n\t\t\t \n\t\t\tif (fmt3_ins != NULL) {\n\t\t\t\tinstr.integer =\n\t\t\t\t\tfmt3_ins->immediate\n\t\t\t\t      | (fmt3_ins->source << 8)\n\t\t\t\t      | (fmt3_ins->address << 16)\n\t\t\t\t      |\t(fmt3_ins->opcode << 25);\n\t\t\t} else {\n\t\t\t\tinstr.integer =\n\t\t\t\t\tfmt1_ins->immediate\n\t\t\t\t      | (fmt1_ins->source << 8)\n\t\t\t\t      | (fmt1_ins->destination << 16)\n\t\t\t\t      |\t(fmt1_ins->ret << 24)\n\t\t\t\t      |\t(fmt1_ins->opcode << 25);\n\t\t\t}\n\t\t}\n\t\t \n\t\tinstr.integer = ahc_htole32(instr.integer);\n\t\tahc_outsb(ahc, SEQRAM, instr.bytes, 4);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"Unknown opcode encountered in seq program\");\n\t\tbreak;\n\t}\n}\n\nint\nahc_print_register(const ahc_reg_parse_entry_t *table, u_int num_entries,\n\t\t   const char *name, u_int address, u_int value,\n\t\t   u_int *cur_column, u_int wrap_point)\n{\n\tint\tprinted;\n\tu_int\tprinted_mask;\n\n\tif (cur_column != NULL && *cur_column >= wrap_point) {\n\t\tprintk(\"\\n\");\n\t\t*cur_column = 0;\n\t}\n\tprinted  = printk(\"%s[0x%x]\", name, value);\n\tif (table == NULL) {\n\t\tprinted += printk(\" \");\n\t\t*cur_column += printed;\n\t\treturn (printed);\n\t}\n\tprinted_mask = 0;\n\twhile (printed_mask != 0xFF) {\n\t\tint entry;\n\n\t\tfor (entry = 0; entry < num_entries; entry++) {\n\t\t\tif (((value & table[entry].mask)\n\t\t\t  != table[entry].value)\n\t\t\t || ((printed_mask & table[entry].mask)\n\t\t\t  == table[entry].mask))\n\t\t\t\tcontinue;\n\n\t\t\tprinted += printk(\"%s%s\",\n\t\t\t\t\t  printed_mask == 0 ? \":(\" : \"|\",\n\t\t\t\t\t  table[entry].name);\n\t\t\tprinted_mask |= table[entry].mask;\n\t\t\tbreak;\n\t\t}\n\t\tif (entry >= num_entries)\n\t\t\tbreak;\n\t}\n\tif (printed_mask != 0)\n\t\tprinted += printk(\") \");\n\telse\n\t\tprinted += printk(\" \");\n\tif (cur_column != NULL)\n\t\t*cur_column += printed;\n\treturn (printed);\n}\n\nvoid\nahc_dump_card_state(struct ahc_softc *ahc)\n{\n\tstruct\tscb *scb;\n\tstruct\tscb_tailq *untagged_q;\n\tu_int\tcur_col;\n\tint\tpaused;\n\tint\ttarget;\n\tint\tmaxtarget;\n\tint\ti;\n\tuint8_t last_phase;\n\tuint8_t qinpos;\n\tuint8_t qintail;\n\tuint8_t qoutpos;\n\tuint8_t scb_index;\n\tuint8_t saved_scbptr;\n\n\tif (ahc_is_paused(ahc)) {\n\t\tpaused = 1;\n\t} else {\n\t\tpaused = 0;\n\t\tahc_pause(ahc);\n\t}\n\n\tsaved_scbptr = ahc_inb(ahc, SCBPTR);\n\tlast_phase = ahc_inb(ahc, LASTPHASE);\n\tprintk(\">>>>>>>>>>>>>>>>>> Dump Card State Begins <<<<<<<<<<<<<<<<<\\n\"\n\t       \"%s: Dumping Card State %s, at SEQADDR 0x%x\\n\",\n\t       ahc_name(ahc), ahc_lookup_phase_entry(last_phase)->phasemsg,\n\t       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));\n\tif (paused)\n\t\tprintk(\"Card was paused\\n\");\n\tprintk(\"ACCUM = 0x%x, SINDEX = 0x%x, DINDEX = 0x%x, ARG_2 = 0x%x\\n\",\n\t       ahc_inb(ahc, ACCUM), ahc_inb(ahc, SINDEX), ahc_inb(ahc, DINDEX),\n\t       ahc_inb(ahc, ARG_2));\n\tprintk(\"HCNT = 0x%x SCBPTR = 0x%x\\n\", ahc_inb(ahc, HCNT),\n\t       ahc_inb(ahc, SCBPTR));\n\tcur_col = 0;\n\tif ((ahc->features & AHC_DT) != 0)\n\t\tahc_scsiphase_print(ahc_inb(ahc, SCSIPHASE), &cur_col, 50);\n\tahc_scsisigi_print(ahc_inb(ahc, SCSISIGI), &cur_col, 50);\n\tahc_error_print(ahc_inb(ahc, ERROR), &cur_col, 50);\n\tahc_scsibusl_print(ahc_inb(ahc, SCSIBUSL), &cur_col, 50);\n\tahc_lastphase_print(ahc_inb(ahc, LASTPHASE), &cur_col, 50);\n\tahc_scsiseq_print(ahc_inb(ahc, SCSISEQ), &cur_col, 50);\n\tahc_sblkctl_print(ahc_inb(ahc, SBLKCTL), &cur_col, 50);\n\tahc_scsirate_print(ahc_inb(ahc, SCSIRATE), &cur_col, 50);\n\tahc_seqctl_print(ahc_inb(ahc, SEQCTL), &cur_col, 50);\n\tahc_seq_flags_print(ahc_inb(ahc, SEQ_FLAGS), &cur_col, 50);\n\tahc_sstat0_print(ahc_inb(ahc, SSTAT0), &cur_col, 50);\n\tahc_sstat1_print(ahc_inb(ahc, SSTAT1), &cur_col, 50);\n\tahc_sstat2_print(ahc_inb(ahc, SSTAT2), &cur_col, 50);\n\tahc_sstat3_print(ahc_inb(ahc, SSTAT3), &cur_col, 50);\n\tahc_simode0_print(ahc_inb(ahc, SIMODE0), &cur_col, 50);\n\tahc_simode1_print(ahc_inb(ahc, SIMODE1), &cur_col, 50);\n\tahc_sxfrctl0_print(ahc_inb(ahc, SXFRCTL0), &cur_col, 50);\n\tahc_dfcntrl_print(ahc_inb(ahc, DFCNTRL), &cur_col, 50);\n\tahc_dfstatus_print(ahc_inb(ahc, DFSTATUS), &cur_col, 50);\n\tif (cur_col != 0)\n\t\tprintk(\"\\n\");\n\tprintk(\"STACK:\");\n\tfor (i = 0; i < STACK_SIZE; i++)\n\t\tprintk(\" 0x%x\", ahc_inb(ahc, STACK)|(ahc_inb(ahc, STACK) << 8));\n\tprintk(\"\\nSCB count = %d\\n\", ahc->scb_data->numscbs);\n\tprintk(\"Kernel NEXTQSCB = %d\\n\", ahc->next_queued_scb->hscb->tag);\n\tprintk(\"Card NEXTQSCB = %d\\n\", ahc_inb(ahc, NEXT_QUEUED_SCB));\n\t \n\tprintk(\"QINFIFO entries: \");\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tqinpos = ahc_inb(ahc, SNSCB_QOFF);\n\t\tahc_outb(ahc, SNSCB_QOFF, qinpos);\n\t} else\n\t\tqinpos = ahc_inb(ahc, QINPOS);\n\tqintail = ahc->qinfifonext;\n\twhile (qinpos != qintail) {\n\t\tprintk(\"%d \", ahc->qinfifo[qinpos]);\n\t\tqinpos++;\n\t}\n\tprintk(\"\\n\");\n\n\tprintk(\"Waiting Queue entries: \");\n\tscb_index = ahc_inb(ahc, WAITING_SCBH);\n\ti = 0;\n\twhile (scb_index != SCB_LIST_NULL && i++ < 256) {\n\t\tahc_outb(ahc, SCBPTR, scb_index);\n\t\tprintk(\"%d:%d \", scb_index, ahc_inb(ahc, SCB_TAG));\n\t\tscb_index = ahc_inb(ahc, SCB_NEXT);\n\t}\n\tprintk(\"\\n\");\n\n\tprintk(\"Disconnected Queue entries: \");\n\tscb_index = ahc_inb(ahc, DISCONNECTED_SCBH);\n\ti = 0;\n\twhile (scb_index != SCB_LIST_NULL && i++ < 256) {\n\t\tahc_outb(ahc, SCBPTR, scb_index);\n\t\tprintk(\"%d:%d \", scb_index, ahc_inb(ahc, SCB_TAG));\n\t\tscb_index = ahc_inb(ahc, SCB_NEXT);\n\t}\n\tprintk(\"\\n\");\n\n\tahc_sync_qoutfifo(ahc, BUS_DMASYNC_POSTREAD);\n\tprintk(\"QOUTFIFO entries: \");\n\tqoutpos = ahc->qoutfifonext;\n\ti = 0;\n\twhile (ahc->qoutfifo[qoutpos] != SCB_LIST_NULL && i++ < 256) {\n\t\tprintk(\"%d \", ahc->qoutfifo[qoutpos]);\n\t\tqoutpos++;\n\t}\n\tprintk(\"\\n\");\n\n\tprintk(\"Sequencer Free SCB List: \");\n\tscb_index = ahc_inb(ahc, FREE_SCBH);\n\ti = 0;\n\twhile (scb_index != SCB_LIST_NULL && i++ < 256) {\n\t\tahc_outb(ahc, SCBPTR, scb_index);\n\t\tprintk(\"%d \", scb_index);\n\t\tscb_index = ahc_inb(ahc, SCB_NEXT);\n\t}\n\tprintk(\"\\n\");\n\n\tprintk(\"Sequencer SCB Info: \");\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tcur_col  = printk(\"\\n%3d \", i);\n\n\t\tahc_scb_control_print(ahc_inb(ahc, SCB_CONTROL), &cur_col, 60);\n\t\tahc_scb_scsiid_print(ahc_inb(ahc, SCB_SCSIID), &cur_col, 60);\n\t\tahc_scb_lun_print(ahc_inb(ahc, SCB_LUN), &cur_col, 60);\n\t\tahc_scb_tag_print(ahc_inb(ahc, SCB_TAG), &cur_col, 60);\n\t}\n\tprintk(\"\\n\");\n\n\tprintk(\"Pending list: \");\n\ti = 0;\n\tLIST_FOREACH(scb, &ahc->pending_scbs, pending_links) {\n\t\tif (i++ > 256)\n\t\t\tbreak;\n\t\tcur_col  = printk(\"\\n%3d \", scb->hscb->tag);\n\t\tahc_scb_control_print(scb->hscb->control, &cur_col, 60);\n\t\tahc_scb_scsiid_print(scb->hscb->scsiid, &cur_col, 60);\n\t\tahc_scb_lun_print(scb->hscb->lun, &cur_col, 60);\n\t\tif ((ahc->flags & AHC_PAGESCBS) == 0) {\n\t\t\tahc_outb(ahc, SCBPTR, scb->hscb->tag);\n\t\t\tprintk(\"(\");\n\t\t\tahc_scb_control_print(ahc_inb(ahc, SCB_CONTROL),\n\t\t\t\t\t      &cur_col, 60);\n\t\t\tahc_scb_tag_print(ahc_inb(ahc, SCB_TAG), &cur_col, 60);\n\t\t\tprintk(\")\");\n\t\t}\n\t}\n\tprintk(\"\\n\");\n\n\tprintk(\"Kernel Free SCB list: \");\n\ti = 0;\n\tSLIST_FOREACH(scb, &ahc->scb_data->free_scbs, links.sle) {\n\t\tif (i++ > 256)\n\t\t\tbreak;\n\t\tprintk(\"%d \", scb->hscb->tag);\n\t}\n\tprintk(\"\\n\");\n\n\tmaxtarget = (ahc->features & (AHC_WIDE|AHC_TWIN)) ? 15 : 7;\n\tfor (target = 0; target <= maxtarget; target++) {\n\t\tuntagged_q = &ahc->untagged_queues[target];\n\t\tif (TAILQ_FIRST(untagged_q) == NULL)\n\t\t\tcontinue;\n\t\tprintk(\"Untagged Q(%d): \", target);\n\t\ti = 0;\n\t\tTAILQ_FOREACH(scb, untagged_q, links.tqe) {\n\t\t\tif (i++ > 256)\n\t\t\t\tbreak;\n\t\t\tprintk(\"%d \", scb->hscb->tag);\n\t\t}\n\t\tprintk(\"\\n\");\n\t}\n\n\tprintk(\"\\n<<<<<<<<<<<<<<<<< Dump Card State Ends >>>>>>>>>>>>>>>>>>\\n\");\n\tahc_outb(ahc, SCBPTR, saved_scbptr);\n\tif (paused == 0)\n\t\tahc_unpause(ahc);\n}\n\n \n#ifdef AHC_TARGET_MODE\ncam_status\nahc_find_tmode_devs(struct ahc_softc *ahc, struct cam_sim *sim, union ccb *ccb,\n\t\t    struct ahc_tmode_tstate **tstate,\n\t\t    struct ahc_tmode_lstate **lstate,\n\t\t    int notfound_failure)\n{\n\n\tif ((ahc->features & AHC_TARGETMODE) == 0)\n\t\treturn (CAM_REQ_INVALID);\n\n\t \n\tif (ccb->ccb_h.target_id == CAM_TARGET_WILDCARD\n\t && ccb->ccb_h.target_lun == CAM_LUN_WILDCARD) {\n\t\t*tstate = NULL;\n\t\t*lstate = ahc->black_hole;\n\t} else {\n\t\tu_int max_id;\n\n\t\tmax_id = (ahc->features & AHC_WIDE) ? 16 : 8;\n\t\tif (ccb->ccb_h.target_id >= max_id)\n\t\t\treturn (CAM_TID_INVALID);\n\n\t\tif (ccb->ccb_h.target_lun >= AHC_NUM_LUNS)\n\t\t\treturn (CAM_LUN_INVALID);\n\n\t\t*tstate = ahc->enabled_targets[ccb->ccb_h.target_id];\n\t\t*lstate = NULL;\n\t\tif (*tstate != NULL)\n\t\t\t*lstate =\n\t\t\t    (*tstate)->enabled_luns[ccb->ccb_h.target_lun];\n\t}\n\n\tif (notfound_failure != 0 && *lstate == NULL)\n\t\treturn (CAM_PATH_INVALID);\n\n\treturn (CAM_REQ_CMP);\n}\n\nvoid\nahc_handle_en_lun(struct ahc_softc *ahc, struct cam_sim *sim, union ccb *ccb)\n{\n\tstruct\t   ahc_tmode_tstate *tstate;\n\tstruct\t   ahc_tmode_lstate *lstate;\n\tstruct\t   ccb_en_lun *cel;\n\tcam_status status;\n\tu_long\t   s;\n\tu_int\t   target;\n\tu_int\t   lun;\n\tu_int\t   target_mask;\n\tu_int\t   our_id;\n\tint\t   error;\n\tchar\t   channel;\n\n\tstatus = ahc_find_tmode_devs(ahc, sim, ccb, &tstate, &lstate,\n\t\t\t\t      FALSE);\n\n\tif (status != CAM_REQ_CMP) {\n\t\tccb->ccb_h.status = status;\n\t\treturn;\n\t}\n\n\tif (cam_sim_bus(sim) == 0)\n\t\tour_id = ahc->our_id;\n\telse\n\t\tour_id = ahc->our_id_b;\n\n\tif (ccb->ccb_h.target_id != our_id) {\n\t\t \n\t\tif ((ahc->features & AHC_MULTIROLE) != 0) {\n\n\t\t\tif ((ahc->features & AHC_MULTI_TID) != 0\n\t\t\t && (ahc->flags & AHC_INITIATORROLE) != 0) {\n\t\t\t\t \n\t\t\t\tstatus = CAM_TID_INVALID;\n\t\t\t} else if ((ahc->flags & AHC_INITIATORROLE) != 0\n\t\t\t\t|| ahc->enabled_luns > 0) {\n\t\t\t\t \n\t\t\t\tstatus = CAM_TID_INVALID;\n\t\t\t}\n\t\t} else if ((ahc->features & AHC_MULTI_TID) == 0\n\t\t\t&& ahc->enabled_luns > 0) {\n\n\t\t\tstatus = CAM_TID_INVALID;\n\t\t}\n\t}\n\n\tif (status != CAM_REQ_CMP) {\n\t\tccb->ccb_h.status = status;\n\t\treturn;\n\t}\n\n\t \n\tif ((ahc->flags & AHC_TARGETROLE) == 0\n\t && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {\n\t\tu_long\t s;\n\t\tahc_flag saved_flags;\n\n\t\tprintk(\"Configuring Target Mode\\n\");\n\t\tahc_lock(ahc, &s);\n\t\tif (LIST_FIRST(&ahc->pending_scbs) != NULL) {\n\t\t\tccb->ccb_h.status = CAM_BUSY;\n\t\t\tahc_unlock(ahc, &s);\n\t\t\treturn;\n\t\t}\n\t\tsaved_flags = ahc->flags;\n\t\tahc->flags |= AHC_TARGETROLE;\n\t\tif ((ahc->features & AHC_MULTIROLE) == 0)\n\t\t\tahc->flags &= ~AHC_INITIATORROLE;\n\t\tahc_pause(ahc);\n\t\terror = ahc_loadseq(ahc);\n\t\tif (error != 0) {\n\t\t\t \n\t\t\tahc->flags = saved_flags;\n\t\t\t(void)ahc_loadseq(ahc);\n\t\t\tahc_restart(ahc);\n\t\t\tahc_unlock(ahc, &s);\n\t\t\tccb->ccb_h.status = CAM_FUNC_NOTAVAIL;\n\t\t\treturn;\n\t\t}\n\t\tahc_restart(ahc);\n\t\tahc_unlock(ahc, &s);\n\t}\n\tcel = &ccb->cel;\n\ttarget = ccb->ccb_h.target_id;\n\tlun = ccb->ccb_h.target_lun;\n\tchannel = SIM_CHANNEL(ahc, sim);\n\ttarget_mask = 0x01 << target;\n\tif (channel == 'B')\n\t\ttarget_mask <<= 8;\n\n\tif (cel->enable != 0) {\n\t\tu_int scsiseq;\n\n\t\t \n\t\tif (lstate != NULL) {\n\t\t\txpt_print_path(ccb->ccb_h.path);\n\t\t\tprintk(\"Lun already enabled\\n\");\n\t\t\tccb->ccb_h.status = CAM_LUN_ALRDY_ENA;\n\t\t\treturn;\n\t\t}\n\n\t\tif (cel->grp6_len != 0\n\t\t || cel->grp7_len != 0) {\n\t\t\t \n\t\t\tccb->ccb_h.status = CAM_REQ_INVALID;\n\t\t\tprintk(\"Non-zero Group Codes\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (target != CAM_TARGET_WILDCARD && tstate == NULL) {\n\t\t\ttstate = ahc_alloc_tstate(ahc, target, channel);\n\t\t\tif (tstate == NULL) {\n\t\t\t\txpt_print_path(ccb->ccb_h.path);\n\t\t\t\tprintk(\"Couldn't allocate tstate\\n\");\n\t\t\t\tccb->ccb_h.status = CAM_RESRC_UNAVAIL;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tlstate = kzalloc(sizeof(*lstate), GFP_ATOMIC);\n\t\tif (lstate == NULL) {\n\t\t\txpt_print_path(ccb->ccb_h.path);\n\t\t\tprintk(\"Couldn't allocate lstate\\n\");\n\t\t\tccb->ccb_h.status = CAM_RESRC_UNAVAIL;\n\t\t\treturn;\n\t\t}\n\t\tstatus = xpt_create_path(&lstate->path,  NULL,\n\t\t\t\t\t xpt_path_path_id(ccb->ccb_h.path),\n\t\t\t\t\t xpt_path_target_id(ccb->ccb_h.path),\n\t\t\t\t\t xpt_path_lun_id(ccb->ccb_h.path));\n\t\tif (status != CAM_REQ_CMP) {\n\t\t\tkfree(lstate);\n\t\t\txpt_print_path(ccb->ccb_h.path);\n\t\t\tprintk(\"Couldn't allocate path\\n\");\n\t\t\tccb->ccb_h.status = CAM_RESRC_UNAVAIL;\n\t\t\treturn;\n\t\t}\n\t\tSLIST_INIT(&lstate->accept_tios);\n\t\tSLIST_INIT(&lstate->immed_notifies);\n\t\tahc_lock(ahc, &s);\n\t\tahc_pause(ahc);\n\t\tif (target != CAM_TARGET_WILDCARD) {\n\t\t\ttstate->enabled_luns[lun] = lstate;\n\t\t\tahc->enabled_luns++;\n\n\t\t\tif ((ahc->features & AHC_MULTI_TID) != 0) {\n\t\t\t\tu_int targid_mask;\n\n\t\t\t\ttargid_mask = ahc_inb(ahc, TARGID)\n\t\t\t\t\t    | (ahc_inb(ahc, TARGID + 1) << 8);\n\n\t\t\t\ttargid_mask |= target_mask;\n\t\t\t\tahc_outb(ahc, TARGID, targid_mask);\n\t\t\t\tahc_outb(ahc, TARGID+1, (targid_mask >> 8));\n\t\t\t\tahc_update_scsiid(ahc, targid_mask);\n\t\t\t} else {\n\t\t\t\tu_int our_id;\n\t\t\t\tchar  channel;\n\n\t\t\t\tchannel = SIM_CHANNEL(ahc, sim);\n\t\t\t\tour_id = SIM_SCSI_ID(ahc, sim);\n\n\t\t\t\t \n\t\t\t\tif (target != our_id) {\n\t\t\t\t\tu_int sblkctl;\n\t\t\t\t\tchar  cur_channel;\n\t\t\t\t\tint   swap;\n\n\t\t\t\t\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\t\t\t\t\tcur_channel = (sblkctl & SELBUSB)\n\t\t\t\t\t\t    ? 'B' : 'A';\n\t\t\t\t\tif ((ahc->features & AHC_TWIN) == 0)\n\t\t\t\t\t\tcur_channel = 'A';\n\t\t\t\t\tswap = cur_channel != channel;\n\t\t\t\t\tif (channel == 'A')\n\t\t\t\t\t\tahc->our_id = target;\n\t\t\t\t\telse\n\t\t\t\t\t\tahc->our_id_b = target;\n\n\t\t\t\t\tif (swap)\n\t\t\t\t\t\tahc_outb(ahc, SBLKCTL,\n\t\t\t\t\t\t\t sblkctl ^ SELBUSB);\n\n\t\t\t\t\tahc_outb(ahc, SCSIID, target);\n\n\t\t\t\t\tif (swap)\n\t\t\t\t\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tahc->black_hole = lstate;\n\t\t \n\t\tif (ahc->black_hole != NULL && ahc->enabled_luns > 0) {\n\t\t\tscsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);\n\t\t\tscsiseq |= ENSELI;\n\t\t\tahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq);\n\t\t\tscsiseq = ahc_inb(ahc, SCSISEQ);\n\t\t\tscsiseq |= ENSELI;\n\t\t\tahc_outb(ahc, SCSISEQ, scsiseq);\n\t\t}\n\t\tahc_unpause(ahc);\n\t\tahc_unlock(ahc, &s);\n\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\txpt_print_path(ccb->ccb_h.path);\n\t\tprintk(\"Lun now enabled for target mode\\n\");\n\t} else {\n\t\tstruct scb *scb;\n\t\tint i, empty;\n\n\t\tif (lstate == NULL) {\n\t\t\tccb->ccb_h.status = CAM_LUN_INVALID;\n\t\t\treturn;\n\t\t}\n\n\t\tahc_lock(ahc, &s);\n\n\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\tLIST_FOREACH(scb, &ahc->pending_scbs, pending_links) {\n\t\t\tstruct ccb_hdr *ccbh;\n\n\t\t\tccbh = &scb->io_ctx->ccb_h;\n\t\t\tif (ccbh->func_code == XPT_CONT_TARGET_IO\n\t\t\t && !xpt_path_comp(ccbh->path, ccb->ccb_h.path)){\n\t\t\t\tprintk(\"CTIO pending\\n\");\n\t\t\t\tccb->ccb_h.status = CAM_REQ_INVALID;\n\t\t\t\tahc_unlock(ahc, &s);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (SLIST_FIRST(&lstate->accept_tios) != NULL) {\n\t\t\tprintk(\"ATIOs pending\\n\");\n\t\t\tccb->ccb_h.status = CAM_REQ_INVALID;\n\t\t}\n\n\t\tif (SLIST_FIRST(&lstate->immed_notifies) != NULL) {\n\t\t\tprintk(\"INOTs pending\\n\");\n\t\t\tccb->ccb_h.status = CAM_REQ_INVALID;\n\t\t}\n\n\t\tif (ccb->ccb_h.status != CAM_REQ_CMP) {\n\t\t\tahc_unlock(ahc, &s);\n\t\t\treturn;\n\t\t}\n\n\t\txpt_print_path(ccb->ccb_h.path);\n\t\tprintk(\"Target mode disabled\\n\");\n\t\txpt_free_path(lstate->path);\n\t\tkfree(lstate);\n\n\t\tahc_pause(ahc);\n\t\t \n\t\tif (target != CAM_TARGET_WILDCARD) {\n\t\t\ttstate->enabled_luns[lun] = NULL;\n\t\t\tahc->enabled_luns--;\n\t\t\tfor (empty = 1, i = 0; i < 8; i++)\n\t\t\t\tif (tstate->enabled_luns[i] != NULL) {\n\t\t\t\t\tempty = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tif (empty) {\n\t\t\t\tahc_free_tstate(ahc, target, channel,\n\t\t\t\t\t\t FALSE);\n\t\t\t\tif (ahc->features & AHC_MULTI_TID) {\n\t\t\t\t\tu_int targid_mask;\n\n\t\t\t\t\ttargid_mask = ahc_inb(ahc, TARGID)\n\t\t\t\t\t\t    | (ahc_inb(ahc, TARGID + 1)\n\t\t\t\t\t\t       << 8);\n\n\t\t\t\t\ttargid_mask &= ~target_mask;\n\t\t\t\t\tahc_outb(ahc, TARGID, targid_mask);\n\t\t\t\t\tahc_outb(ahc, TARGID+1,\n\t\t\t\t\t\t (targid_mask >> 8));\n\t\t\t\t\tahc_update_scsiid(ahc, targid_mask);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\n\t\t\tahc->black_hole = NULL;\n\n\t\t\t \n\t\t\tempty = TRUE;\n\t\t}\n\t\tif (ahc->enabled_luns == 0) {\n\t\t\t \n\t\t\tu_int scsiseq;\n\n\t\t\tscsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);\n\t\t\tscsiseq &= ~ENSELI;\n\t\t\tahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq);\n\t\t\tscsiseq = ahc_inb(ahc, SCSISEQ);\n\t\t\tscsiseq &= ~ENSELI;\n\t\t\tahc_outb(ahc, SCSISEQ, scsiseq);\n\n\t\t\tif ((ahc->features & AHC_MULTIROLE) == 0) {\n\t\t\t\tprintk(\"Configuring Initiator Mode\\n\");\n\t\t\t\tahc->flags &= ~AHC_TARGETROLE;\n\t\t\t\tahc->flags |= AHC_INITIATORROLE;\n\t\t\t\t \n\t\t\t\t(void)ahc_loadseq(ahc);\n\t\t\t\tahc_restart(ahc);\n\t\t\t\t \n\t\t\t}\n\t\t}\n\t\tahc_unpause(ahc);\n\t\tahc_unlock(ahc, &s);\n\t}\n}\n\nstatic void\nahc_update_scsiid(struct ahc_softc *ahc, u_int targid_mask)\n{\n\tu_int scsiid_mask;\n\tu_int scsiid;\n\n\tif ((ahc->features & AHC_MULTI_TID) == 0)\n\t\tpanic(\"ahc_update_scsiid called on non-multitid unit\\n\");\n\n\t \n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tscsiid = ahc_inb(ahc, SCSIID_ULTRA2);\n\telse\n\t\tscsiid = ahc_inb(ahc, SCSIID);\n\tscsiid_mask = 0x1 << (scsiid & OID);\n\tif ((targid_mask & scsiid_mask) == 0) {\n\t\tu_int our_id;\n\n\t\t \n\t\tour_id = ffs(targid_mask);\n\t\tif (our_id == 0)\n\t\t\tour_id = ahc->our_id;\n\t\telse\n\t\t\tour_id--;\n\t\tscsiid &= TID;\n\t\tscsiid |= our_id;\n\t}\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tahc_outb(ahc, SCSIID_ULTRA2, scsiid);\n\telse\n\t\tahc_outb(ahc, SCSIID, scsiid);\n}\n\nstatic void\nahc_run_tqinfifo(struct ahc_softc *ahc, int paused)\n{\n\tstruct target_cmd *cmd;\n\n\t \n\tif ((ahc->features & AHC_AUTOPAUSE) != 0)\n\t\tpaused = TRUE;\n\n\tahc_sync_tqinfifo(ahc, BUS_DMASYNC_POSTREAD);\n\twhile ((cmd = &ahc->targetcmds[ahc->tqinfifonext])->cmd_valid != 0) {\n\n\t\t \n\t\tif (ahc_handle_target_cmd(ahc, cmd) != 0)\n\t\t\tbreak;\n\n\t\tcmd->cmd_valid = 0;\n\t\tahc_dmamap_sync(ahc, ahc->shared_data_dmat,\n\t\t\t\tahc->shared_data_dmamap,\n\t\t\t\tahc_targetcmd_offset(ahc, ahc->tqinfifonext),\n\t\t\t\tsizeof(struct target_cmd),\n\t\t\t\tBUS_DMASYNC_PREREAD);\n\t\tahc->tqinfifonext++;\n\n\t\t \n\t\tif ((ahc->tqinfifonext & (HOST_TQINPOS - 1)) == 1) {\n\t\t\tif ((ahc->features & AHC_HS_MAILBOX) != 0) {\n\t\t\t\tu_int hs_mailbox;\n\n\t\t\t\ths_mailbox = ahc_inb(ahc, HS_MAILBOX);\n\t\t\t\ths_mailbox &= ~HOST_TQINPOS;\n\t\t\t\ths_mailbox |= ahc->tqinfifonext & HOST_TQINPOS;\n\t\t\t\tahc_outb(ahc, HS_MAILBOX, hs_mailbox);\n\t\t\t} else {\n\t\t\t\tif (!paused)\n\t\t\t\t\tahc_pause(ahc);\n\t\t\t\tahc_outb(ahc, KERNEL_TQINPOS,\n\t\t\t\t\t ahc->tqinfifonext & HOST_TQINPOS);\n\t\t\t\tif (!paused)\n\t\t\t\t\tahc_unpause(ahc);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int\nahc_handle_target_cmd(struct ahc_softc *ahc, struct target_cmd *cmd)\n{\n\tstruct\t  ahc_tmode_tstate *tstate;\n\tstruct\t  ahc_tmode_lstate *lstate;\n\tstruct\t  ccb_accept_tio *atio;\n\tuint8_t *byte;\n\tint\t  initiator;\n\tint\t  target;\n\tint\t  lun;\n\n\tinitiator = SCSIID_TARGET(ahc, cmd->scsiid);\n\ttarget = SCSIID_OUR_ID(cmd->scsiid);\n\tlun    = (cmd->identify & MSG_IDENTIFY_LUNMASK);\n\n\tbyte = cmd->bytes;\n\ttstate = ahc->enabled_targets[target];\n\tlstate = NULL;\n\tif (tstate != NULL)\n\t\tlstate = tstate->enabled_luns[lun];\n\n\t \n\tif (lstate == NULL)\n\t\tlstate = ahc->black_hole;\n\n\tatio = (struct ccb_accept_tio*)SLIST_FIRST(&lstate->accept_tios);\n\tif (atio == NULL) {\n\t\tahc->flags |= AHC_TQINFIFO_BLOCKED;\n\t\t \n\t\tif (bootverbose)\n\t\t\tprintk(\"%s: ATIOs exhausted\\n\", ahc_name(ahc));\n\t\treturn (1);\n\t} else\n\t\tahc->flags &= ~AHC_TQINFIFO_BLOCKED;\n#if 0\n\tprintk(\"Incoming command from %d for %d:%d%s\\n\",\n\t       initiator, target, lun,\n\t       lstate == ahc->black_hole ? \"(Black Holed)\" : \"\");\n#endif\n\tSLIST_REMOVE_HEAD(&lstate->accept_tios, sim_links.sle);\n\n\tif (lstate == ahc->black_hole) {\n\t\t \n\t\tatio->ccb_h.target_id = target;\n\t\tatio->ccb_h.target_lun = lun;\n\t}\n\n\t \n\tatio->sense_len = 0;\n\tatio->init_id = initiator;\n\tif (byte[0] != 0xFF) {\n\t\t \n\t\tatio->tag_action = *byte++;\n\t\tatio->tag_id = *byte++;\n\t\tatio->ccb_h.flags = CAM_TAG_ACTION_VALID;\n\t} else {\n\t\tatio->ccb_h.flags = 0;\n\t}\n\tbyte++;\n\n\t \n\tswitch (*byte >> CMD_GROUP_CODE_SHIFT) {\n\tcase 0:\n\t\tatio->cdb_len = 6;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\t\tatio->cdb_len = 10;\n\t\tbreak;\n\tcase 4:\n\t\tatio->cdb_len = 16;\n\t\tbreak;\n\tcase 5:\n\t\tatio->cdb_len = 12;\n\t\tbreak;\n\tcase 3:\n\tdefault:\n\t\t \n\t\tatio->cdb_len = 1;\n\t\tprintk(\"Reserved or VU command code type encountered\\n\");\n\t\tbreak;\n\t}\n\n\tmemcpy(atio->cdb_io.cdb_bytes, byte, atio->cdb_len);\n\n\tatio->ccb_h.status |= CAM_CDB_RECVD;\n\n\tif ((cmd->identify & MSG_IDENTIFY_DISCFLAG) == 0) {\n\t\t \n#if 0\n\t\tprintk(\"Received Immediate Command %d:%d:%d - %p\\n\",\n\t\t       initiator, target, lun, ahc->pending_device);\n#endif\n\t\tahc->pending_device = lstate;\n\t\tahc_freeze_ccb((union ccb *)atio);\n\t\tatio->ccb_h.flags |= CAM_DIS_DISCONNECT;\n\t}\n\txpt_done((union ccb*)atio);\n\treturn (0);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}