{
  "module_name": "aic79xx.reg",
  "hash_id": "f0f43dd4752a9b95ff751d8d88f9797a8eca32fc8c4f6cb95009ca29bc697bc9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic79xx.reg",
  "human_readable_source": "/*\n * Aic79xx register and scratch ram definitions.\n *\n * Copyright (c) 1994-2001, 2004 Justin T. Gibbs.\n * Copyright (c) 2000-2002 Adaptec Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions, and the following disclaimer,\n *    without modification.\n * 2. Redistributions in binary form must reproduce at minimum a disclaimer\n *    substantially similar to the \"NO WARRANTY\" disclaimer below\n *    (\"Disclaimer\") and any redistribution must be conditioned upon\n *    including a substantially similar Disclaimer requirement for further\n *    binary redistribution.\n * 3. Neither the names of the above-listed copyright holders nor the names\n *    of any contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * Alternatively, this software may be distributed under the terms of the\n * GNU General Public License (\"GPL\") version 2 as published by the Free\n * Software Foundation.\n *\n * NO WARRANTY\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGES.\n *\n * $FreeBSD$\n */\nVERSION = \"$Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#77 $\"\n\n/*\n * This file is processed by the aic7xxx_asm utility for use in assembling\n * firmware for the aic79xx family of SCSI host adapters as well as to generate\n * a C header file for use in the kernel portion of the Aic79xx driver.\n */\n\n/* Register window Modes */\n#define M_DFF0\t\t0\n#define M_DFF1\t\t1\n#define M_CCHAN\t\t2\n#define M_SCSI\t\t3\n#define M_CFG\t\t4\n#define M_DST_SHIFT\t4\n\n#define MK_MODE(src, dst) ((src) | ((dst) << M_DST_SHIFT))\n#define SET_MODE(src, dst)\t\t\t\t\t\t\\\n\tSET_SRC_MODE\tsrc;\t\t\t\t\t\t\\\n\tSET_DST_MODE\tdst;\t\t\t\t\t\t\\\n\tif ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {\t\t\t\\\n\t\tmvi\tMK_MODE(src, dst) call set_mode_work_around;\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tmvi\tMODE_PTR, MK_MODE(src, dst);\t\t\t\\\n\t}\n\n#define RESTORE_MODE(mode)\t\t\t\t\t\t\\\n\tif ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {\t\t\t\\\n\t\tmov\tmode call set_mode_work_around;\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tmov\tMODE_PTR, mode;\t\t\t\t\t\\\n\t}\n\n#define SET_SEQINTCODE(code)\t\t\t\t\t\t\\\n\tif ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {\t\t\t\\\n\t\tmvi\tcode call set_seqint_work_around;\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tmvi\tSEQINTCODE, code;\t\t\t\t\\\n\t}\n\n/*\n * Registers marked \"dont_generate_debug_code\" are not (yet) referenced\n * from the driver code, and this keyword inhibit generation\n * of debug code for them.\n *\n * REG_PRETTY_PRINT config will complain if dont_generate_debug_code\n * is added to the register which is referenced in the driver.\n * Unreferenced register with no dont_generate_debug_code will result\n * in dead code. No warning is issued.\n */\n\n/*\n * Mode Pointer\n * Controls which of the 5, 512byte, address spaces should be used\n * as the source and destination of any register accesses in our\n * register window.\n */\nregister MODE_PTR {\n\taddress\t\t\t0x000\n\taccess_mode\tRW\n\tfield\tDST_MODE\t0x70\n\tfield\tSRC_MODE\t0x07\n\tmode_pointer\n\tdont_generate_debug_code\n}\n\nconst SRC_MODE_SHIFT\t0\nconst DST_MODE_SHIFT\t4\n\n/*\n * Host Interrupt Status\n */\nregister INTSTAT {\n\taddress\t\t\t0x001\n\taccess_mode\tRW\n\tfield\tHWERRINT\t0x80\n\tfield\tBRKADRINT\t0x40\n\tfield\tSWTMINT\t\t0x20\n\tfield\tPCIINT\t\t0x10\n\tfield\tSCSIINT\t\t0x08\n\tfield\tSEQINT\t\t0x04\n\tfield\tCMDCMPLT\t0x02\n\tfield\tSPLTINT\t\t0x01\n\tmask\tINT_PEND 0xFF\n}\n\n/*\n * Sequencer Interrupt Code\n */\nregister SEQINTCODE {\n\taddress\t\t\t0x002\n\taccess_mode\tRW\n\tfield {\n\t\tNO_SEQINT,\t\t\t/* No seqint pending. */\n\t\tBAD_PHASE,\t\t\t/* unknown scsi bus phase */\n\t\tSEND_REJECT,\t\t\t/* sending a message reject */\n\t\tPROTO_VIOLATION, \t\t/* Protocol Violation */\n\t\tNO_MATCH,\t\t\t/* no cmd match for reconnect */\n\t\tIGN_WIDE_RES,\t\t\t/* Complex IGN Wide Res Msg */\n\t\tPDATA_REINIT,\t\t\t/*\n\t\t\t\t\t\t * Returned to data phase\n\t\t\t\t\t\t * that requires data\n\t\t\t\t\t\t * transfer pointers to be\n\t\t\t\t\t\t * recalculated from the\n\t\t\t\t\t\t * transfer residual.\n\t\t\t\t\t\t */\n\t\tHOST_MSG_LOOP,\t\t\t/*\n\t\t\t\t\t\t * The bus is ready for the\n\t\t\t\t\t\t * host to perform another\n\t\t\t\t\t\t * message transaction.  This\n\t\t\t\t\t\t * mechanism is used for things\n\t\t\t\t\t\t * like sync/wide negotiation\n\t\t\t\t\t\t * that require a kernel based\n\t\t\t\t\t\t * message state engine.\n\t\t\t\t\t\t */\n\t\tBAD_STATUS,\t\t\t/* Bad status from target */\n\t\tDATA_OVERRUN,\t\t\t/*\n\t\t\t\t\t\t * Target attempted to write\n\t\t\t\t\t\t * beyond the bounds of its\n\t\t\t\t\t\t * command.\n\t\t\t\t\t\t */\n\t\tMKMSG_FAILED,\t\t\t/*\n\t\t\t\t\t\t * Target completed command\n\t\t\t\t\t\t * without honoring our ATN\n\t\t\t\t\t\t * request to issue a message. \n\t\t\t\t\t\t */\n\t\tMISSED_BUSFREE,\t\t\t/*\n\t\t\t\t\t\t * The sequencer never saw\n\t\t\t\t\t\t * the bus go free after\n\t\t\t\t\t\t * either a command complete\n\t\t\t\t\t\t * or disconnect message.\n\t\t\t\t\t\t */\n\t\tDUMP_CARD_STATE,\n\t\tILLEGAL_PHASE,\n\t\tINVALID_SEQINT,\n\t\tCFG4ISTAT_INTR,\n\t\tSTATUS_OVERRUN,\n\t\tCFG4OVERRUN,\n\t\tENTERING_NONPACK,\n\t\tTASKMGMT_FUNC_COMPLETE,\t\t/*\n\t\t\t\t\t\t * Task management function\n\t\t\t\t\t\t * request completed with\n\t\t\t\t\t\t * an expected busfree.\n\t\t\t\t\t\t */\n\t\tTASKMGMT_CMD_CMPLT_OKAY,\t/*\n\t\t\t\t\t\t * A command with a non-zero\n\t\t\t\t\t\t * task management function\n\t\t\t\t\t\t * has completed via the normal\n\t\t\t\t\t\t * command completion method\n\t\t\t\t\t\t * for commands with a zero\n\t\t\t\t\t\t * task management function.\n\t\t\t\t\t\t * This happens when an attempt\n\t\t\t\t\t\t * to abort a command loses\n\t\t\t\t\t\t * the race for the command to\n\t\t\t\t\t\t * complete normally.\n\t\t\t\t\t\t */\n\t\tTRACEPOINT0,\n\t\tTRACEPOINT1,\n\t\tTRACEPOINT2,\n\t\tTRACEPOINT3,\n\t\tSAW_HWERR,\n\t\tBAD_SCB_STATUS\n\t}\n\tdont_generate_debug_code\n}\n\n/*\n * Clear Host Interrupt\n */\nregister CLRINT {\n\taddress\t\t\t0x003\n\taccess_mode\tWO\n\tcount\t\t19\n\tfield\tCLRHWERRINT\t0x80 /* Rev B or greater */\n\tfield\tCLRBRKADRINT\t0x40\n\tfield\tCLRSWTMINT\t0x20\n\tfield\tCLRPCIINT\t0x10\n\tfield\tCLRSCSIINT\t0x08\n\tfield\tCLRSEQINT\t0x04\n\tfield\tCLRCMDINT\t0x02\n\tfield\tCLRSPLTINT\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * Error Register\n */\nregister ERROR {\n\taddress\t\t\t0x004\n\taccess_mode\tRO\n\tfield\tCIOPARERR\t0x80\n\tfield\tCIOACCESFAIL\t0x40 /* Rev B or greater */\n\tfield\tMPARERR\t\t0x20\n\tfield\tDPARERR\t\t0x10\n\tfield\tSQPARERR\t0x08\n\tfield\tILLOPCODE\t0x04\n\tfield\tDSCTMOUT\t0x02\n\tdont_generate_debug_code\n}\n\n/*\n * Clear Error\n */\nregister CLRERR {\n\taddress\t\t\t0x004\n\taccess_mode \tWO\n\tfield\tCLRCIOPARERR\t0x80\n\tfield\tCLRCIOACCESFAIL\t0x40 /* Rev B or greater */\n\tfield\tCLRMPARERR\t0x20\n\tfield\tCLRDPARERR\t0x10\n\tfield\tCLRSQPARERR\t0x08\n\tfield\tCLRILLOPCODE\t0x04\n\tfield\tCLRDSCTMOUT\t0x02\n}\n\n/*\n * Host Control Register\n * Overall host control of the device.\n */\nregister HCNTRL {\n\taddress\t\t\t0x005\n\taccess_mode\tRW\n\tcount\t\t12\n\tfield\tSEQ_RESET\t0x80 /* Rev B or greater */\n\tfield\tPOWRDN\t\t0x40\n\tfield\tSWINT\t\t0x10\n\tfield\tSWTIMER_START_B\t0x08 /* Rev B or greater */\n\tfield\tPAUSE\t\t0x04\n\tfield\tINTEN\t\t0x02\n\tfield\tCHIPRST\t\t0x01\n\tfield\tCHIPRSTACK\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * Host New SCB Queue Offset\n */\nregister HNSCB_QOFF {\n\taddress\t\t\t0x006\n\taccess_mode\tRW\n\tsize\t\t2\n\tcount\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * Host Empty SCB Queue Offset\n */\nregister HESCB_QOFF {\n\taddress\t\t\t0x008\n\taccess_mode\tRW\n\tcount\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * Host Mailbox\n */\nregister HS_MAILBOX {\n\taddress\t\t\t0x00B\n\taccess_mode\tRW\n\tmask\tHOST_TQINPOS\t0x80\t/* Boundary at either 0 or 128 */\n\tmask\tENINT_COALESCE\t0x40\t/* Perform interrupt coalescing */\n}\n\n/*\n * Sequencer Interrupt Status\n */\nregister SEQINTSTAT {\n\taddress\t\t\t0x00C\n\tcount\t\t1\n\taccess_mode\tRO\n\tfield\tSEQ_SWTMRTO\t0x10\n\tfield\tSEQ_SEQINT\t0x08\n\tfield\tSEQ_SCSIINT\t0x04\n\tfield\tSEQ_PCIINT\t0x02\n\tfield\tSEQ_SPLTINT\t0x01\n}\n\n/*\n * Clear SEQ Interrupt\n */\nregister CLRSEQINTSTAT {\n\taddress\t\t\t0x00C\n\taccess_mode\tWO\n\tfield\tCLRSEQ_SWTMRTO\t0x10\n\tfield\tCLRSEQ_SEQINT\t0x08\n\tfield\tCLRSEQ_SCSIINT\t0x04\n\tfield\tCLRSEQ_PCIINT\t0x02\n\tfield\tCLRSEQ_SPLTINT\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * Software Timer\n */\nregister SWTIMER {\n\taddress\t\t\t0x00E\n\taccess_mode\tRW\n\tsize\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * SEQ New SCB Queue Offset\n */\nregister SNSCB_QOFF {\n\taddress\t\t\t0x010\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_CCHAN\n\tdont_generate_debug_code\n}\n\n/*\n * SEQ Empty SCB Queue Offset\n */\nregister SESCB_QOFF {\n\taddress\t\t\t0x012\n\tcount\t\t2\n\taccess_mode\tRW\n\tmodes\t\tM_CCHAN\n\tdont_generate_debug_code\n}\n\n/*\n * SEQ Done SCB Queue Offset\n */\nregister SDSCB_QOFF {\n\taddress\t\t\t0x014\n\taccess_mode\tRW\n\tmodes\t\tM_CCHAN\n\tsize\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * Queue Offset Control & Status\n */\nregister QOFF_CTLSTA {\n\taddress\t\t\t0x016\n\taccess_mode\tRW\n\tmodes\t\tM_CCHAN\n\tfield\tEMPTY_SCB_AVAIL\t0x80\n\tfield\tNEW_SCB_AVAIL\t0x40\n\tfield\tSDSCB_ROLLOVR\t0x20\n\tfield\tHS_MAILBOX_ACT\t0x10\n\tfield\tSCB_QSIZE\t0x0F {\n\t\tSCB_QSIZE_4,\n\t\tSCB_QSIZE_8,\n\t\tSCB_QSIZE_16,\n\t\tSCB_QSIZE_32,\n\t\tSCB_QSIZE_64,\n\t\tSCB_QSIZE_128,\n\t\tSCB_QSIZE_256,\n\t\tSCB_QSIZE_512,\n\t\tSCB_QSIZE_1024,\n\t\tSCB_QSIZE_2048,\n\t\tSCB_QSIZE_4096,\n\t\tSCB_QSIZE_8192,\n\t\tSCB_QSIZE_16384\n\t}\n\tdont_generate_debug_code\n}\n\n/*\n * Interrupt Control\n */\nregister INTCTL {\n\taddress\t\t\t0x018\n\taccess_mode\tRW\n\tfield\tSWTMINTMASK\t0x80\n\tfield\tSWTMINTEN\t0x40\n\tfield\tSWTIMER_START\t0x20\n\tfield\tAUTOCLRCMDINT\t0x10\n\tfield\tPCIINTEN\t0x08\n\tfield\tSCSIINTEN\t0x04\n\tfield\tSEQINTEN\t0x02\n\tfield\tSPLTINTEN\t0x01\n}\n\n/*\n * Data FIFO Control\n */\nregister DFCNTRL {\n\taddress\t\t\t0x019\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1\n\tcount\t\t11\n\tfield\tPRELOADEN\t0x80\n\tfield\tSCSIENWRDIS\t0x40\t/* Rev B only. */\n\tfield\tSCSIEN\t\t0x20\n\tfield\tSCSIENACK\t0x20\n\tfield\tHDMAEN\t\t0x08\n\tfield\tHDMAENACK\t0x08\n\tfield\tDIRECTION\t0x04\n\tfield\tDIRECTIONACK\t0x04\n\tfield\tFIFOFLUSH\t0x02\n\tfield\tFIFOFLUSHACK\t0x02\n\tfield\tDIRECTIONEN\t0x01\n}\n\n/*\n * Device Space Command 0\n */\nregister DSCOMMAND0 {\n\taddress\t\t\t0x019\n\tcount\t\t1\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tCACHETHEN\t0x80\t/* Cache Threshold enable */\n\tfield\tDPARCKEN\t0x40\t/* Data Parity Check Enable */\n\tfield\tMPARCKEN\t0x20\t/* Memory Parity Check Enable */\n\tfield\tEXTREQLCK\t0x10\t/* External Request Lock */\n\tfield\tDISABLE_TWATE\t0x02\t/* Rev B or greater */\n\tfield\tCIOPARCKEN\t0x01\t/* Internal bus parity error enable */\n\tdont_generate_debug_code\n}\n\n/*\n * Data FIFO Status\n */\nregister DFSTATUS {\n\taddress\t\t\t0x01A\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tPRELOAD_AVAIL\t\t0x80\n\tfield\tPKT_PRELOAD_AVAIL\t0x40\n\tfield\tMREQPEND\t\t0x10\n\tfield\tHDONE\t\t\t0x08\n\tfield\tDFTHRESH\t\t0x04\n\tfield\tFIFOFULL\t\t0x02\n\tfield\tFIFOEMP\t\t\t0x01\n}\n\n/*\n * S/G Cache Pointer\n */\nregister SG_CACHE_PRE {\n\taddress\t\t\t0x01B\n\taccess_mode\tWO\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tSG_ADDR_MASK\t0xf8\n\tfield\tODD_SEG\t\t0x04\n\tfield\tLAST_SEG\t0x02\n\tdont_generate_debug_code\n}\n\nregister SG_CACHE_SHADOW {\n\taddress\t\t\t0x01B\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tSG_ADDR_MASK\t0xf8\n\tfield\tODD_SEG\t\t0x04\n\tfield\tLAST_SEG\t0x02\n\tfield\tLAST_SEG_DONE\t0x01\n}\n\n/*\n * Arbiter Control\n */\nregister ARBCTL {\n\taddress\t\t\t0x01B\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tRESET_HARB\t0x80\n\tfield\tRETRY_SWEN\t0x08\n\tfield\tUSE_TIME\t0x07\n}\n\n/*\n * Data Channel Host Address\n */\nregister HADDR {\n\taddress\t\t\t0x070\n\taccess_mode\tRW\n\tsize\t\t8\n\tmodes\t\tM_DFF0, M_DFF1\n\tdont_generate_debug_code\n}\n\n/*\n * Host Overlay DMA Address\n */\nregister HODMAADR {\n\taddress\t\t\t0x070\n\taccess_mode\tRW\n\tsize\t\t8\n\tmodes\t\tM_SCSI\n}\n\n/*\n * PCI PLL Delay.\n */\nregister PLLDELAY {\n\taddress\t\t\t0x070\n\taccess_mode\tRW\n\tsize\t\t1\n\tmodes\t\tM_CFG\n\tfield\tSPLIT_DROP_REQ\t0x80\n}\n\n/*\n * Data Channel Host Count\n */\nregister HCNT {\n\taddress\t\t\t0x078\n\taccess_mode\tRW\n\tsize\t\t3\n\tmodes\t\tM_DFF0, M_DFF1\n\tdont_generate_debug_code\n}\n\n/*\n * Host Overlay DMA Count\n */\nregister HODMACNT {\n\taddress\t\t\t0x078\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_SCSI\n}\n\n/*\n * Host Overlay DMA Enable\n */\nregister HODMAEN {\n\taddress\t\t\t0x07A\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n}\n\n/*\n * Scatter/Gather Host Address\n */\nregister SGHADDR {\n\taddress\t\t\t0x07C\n\taccess_mode\tRW\n\tsize\t\t8\n\tmodes\t\tM_DFF0, M_DFF1\n\tdont_generate_debug_code\n}\n\n/*\n * SCB Host Address\n */\nregister SCBHADDR {\n\taddress\t\t\t0x07C\n\taccess_mode\tRW\n\tsize\t\t8\n\tmodes\t\tM_CCHAN\n\tdont_generate_debug_code\n}\n\n/*\n * Scatter/Gather Host Count\n */\nregister SGHCNT {\n\taddress\t\t\t0x084\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1\n\tdont_generate_debug_code\n}\n\n/*\n * SCB Host Count\n */\nregister SCBHCNT {\n\taddress\t\t\t0x084\n\taccess_mode\tRW\n\tmodes\t\tM_CCHAN\n\tdont_generate_debug_code\n}\n\n/*\n * Data FIFO Threshold\n */\nregister DFF_THRSH {\n\taddress\t\t\t0x088\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tfield\tWR_DFTHRSH\t0x70 {\n\t\tWR_DFTHRSH_MIN,\n\t\tWR_DFTHRSH_25,\n\t\tWR_DFTHRSH_50,\n\t\tWR_DFTHRSH_63,\n\t\tWR_DFTHRSH_75,\n\t\tWR_DFTHRSH_85,\n\t\tWR_DFTHRSH_90,\n\t\tWR_DFTHRSH_MAX\n\t}\n\tfield\tRD_DFTHRSH\t0x07 {\n\t\tRD_DFTHRSH_MIN,\n\t\tRD_DFTHRSH_25,\n\t\tRD_DFTHRSH_50,\n\t\tRD_DFTHRSH_63,\n\t\tRD_DFTHRSH_75,\n\t\tRD_DFTHRSH_85,\n\t\tRD_DFTHRSH_90,\n\t\tRD_DFTHRSH_MAX\n\t}\n\tdont_generate_debug_code\n}\n\n/*\n * ROM Address\n */\nregister ROMADDR {\n\taddress\t\t\t0x08A\n\taccess_mode\tRW\n\tsize\t\t3\n}\n\n/*\n * ROM Control\n */\nregister ROMCNTRL {\n\taddress\t\t\t0x08D\n\taccess_mode\tRW\n\tfield\tROMOP\t\t0xE0\n\tfield\tROMSPD\t\t0x18\n\tfield\tREPEAT\t\t0x02\n\tfield\tRDY\t\t0x01\n}\n\n/*\n * ROM Data\n */\nregister ROMDATA {\n\taddress\t\t\t0x08E\n\taccess_mode\tRW\n}\n\n/*\n * Data Channel Receive Message 0\n */\nregister DCHRXMSG0 {\n\taddress\t\t\t0x090\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\t\tCDNUM\t0xF8\n\tfield\t\tCFNUM\t0x07\n}\n\n/*\n * CMC Receive Message 0\n */\nregister CMCRXMSG0 {\n\taddress\t\t\t0x090\n\taccess_mode\tRO\n\tmodes\t\tM_CCHAN\n\tfield\t\tCDNUM\t0xF8\n\tfield\t\tCFNUM\t0x07\n}\n\n/*\n * Overlay Receive Message 0\n */\nregister OVLYRXMSG0 {\n\taddress\t\t\t0x090\n\taccess_mode\tRO\n\tmodes\t\tM_SCSI\n\tfield\t\tCDNUM\t0xF8\n\tfield\t\tCFNUM\t0x07\n}\n\n/*\n * Relaxed Order Enable\n */\nregister ROENABLE {\n\taddress\t\t\t0x090\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tMSIROEN\t\t0x20\n\tfield\tOVLYROEN\t0x10\n\tfield\tCMCROEN\t\t0x08\n\tfield\tSGROEN\t\t0x04\n\tfield\tDCH1ROEN\t0x02\n\tfield\tDCH0ROEN\t0x01\n}\n\n/*\n * Data Channel Receive Message 1\n */\nregister DCHRXMSG1 {\n\taddress\t\t\t0x091\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tCBNUM\t\t0xFF\n}\n\n/*\n * CMC Receive Message 1\n */\nregister CMCRXMSG1 {\n\taddress\t\t\t0x091\n\taccess_mode\tRO\n\tmodes\t\tM_CCHAN\n\tfield\tCBNUM\t\t0xFF\n}\n\n/*\n * Overlay Receive Message 1\n */\nregister OVLYRXMSG1 {\n\taddress\t\t\t0x091\n\taccess_mode\tRO\n\tmodes\t\tM_SCSI\n\tfield\tCBNUM\t\t0xFF\n}\n\n/*\n * No Snoop Enable\n */\nregister NSENABLE {\n\taddress\t\t\t0x091\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tMSINSEN\t\t0x20\n\tfield\tOVLYNSEN\t0x10\n\tfield\tCMCNSEN\t\t0x08\n\tfield\tSGNSEN\t\t0x04\n\tfield\tDCH1NSEN\t0x02\n\tfield\tDCH0NSEN\t0x01\n}\n\n/*\n * Data Channel Receive Message 2\n */\nregister DCHRXMSG2 {\n\taddress\t\t\t0x092\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tMINDEX\t\t0xFF\n}\n\n/*\n * CMC Receive Message 2\n */\nregister CMCRXMSG2 {\n\taddress\t\t\t0x092\n\taccess_mode\tRO\n\tmodes\t\tM_CCHAN\n\tfield\tMINDEX\t\t0xFF\n}\n\n/*\n * Overlay Receive Message 2\n */\nregister OVLYRXMSG2 {\n\taddress\t\t\t0x092\n\taccess_mode\tRO\n\tmodes\t\tM_SCSI\n\tfield\tMINDEX\t\t0xFF\n}\n\n/*\n * Outstanding Split Transactions\n */\nregister OST {\n\taddress\t\t\t0x092\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n}\n\n/*\n * Data Channel Receive Message 3\n */\nregister DCHRXMSG3 {\n\taddress\t\t\t0x093\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tMCLASS\t\t0x0F\n}\n\n/*\n * CMC Receive Message 3\n */\nregister CMCRXMSG3 {\n\taddress\t\t\t0x093\n\taccess_mode\tRO\n\tmodes\t\tM_CCHAN\n\tfield\tMCLASS\t\t0x0F\n}\n\n/*\n * Overlay Receive Message 3\n */\nregister OVLYRXMSG3 {\n\taddress\t\t\t0x093\n\taccess_mode\tRO\n\tmodes\t\tM_SCSI\n\tfield\tMCLASS\t\t0x0F\n}\n\n/*\n * PCI-X Control\n */\nregister PCIXCTL {\n\taddress\t\t\t0x093\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tfield\tSERRPULSE\t0x80\n\tfield\tUNEXPSCIEN\t0x20\n\tfield\tSPLTSMADIS\t0x10\n\tfield\tSPLTSTADIS\t0x08\n\tfield\tSRSPDPEEN\t0x04\n\tfield\tTSCSERREN\t0x02\n\tfield\tCMPABCDIS\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * CMC Sequencer Byte Count\n */\nregister CMCSEQBCNT {\n\taddress\t\t\t0x094\n\taccess_mode\tRO\n\tmodes\t\tM_CCHAN\n}\n\n/*\n * Overlay Sequencer Byte Count\n */\nregister OVLYSEQBCNT {\n\taddress\t\t\t0x094\n\taccess_mode\tRO\n\tmodes\t\tM_SCSI\n}\n\n/*\n * Data Channel Sequencer Byte Count\n */\nregister DCHSEQBCNT {\n\taddress\t\t\t0x094\n\taccess_mode\tRO\n\tsize\t\t2\n\tmodes\t\tM_DFF0, M_DFF1\n}\n\n/*\n * Data Channel Split Status 0\n */\nregister DCHSPLTSTAT0 {\n\taddress\t\t\t0x096\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1\n\tcount\t\t2\n\tfield\tSTAETERM\t0x80\n\tfield\tSCBCERR\t\t0x40\n\tfield\tSCADERR\t\t0x20\n\tfield\tSCDATBUCKET\t0x10\n\tfield\tCNTNOTCMPLT\t0x08\n\tfield\tRXOVRUN\t\t0x04\n\tfield\tRXSCEMSG\t0x02\n\tfield\tRXSPLTRSP\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * CMC Split Status 0\n */\nregister CMCSPLTSTAT0 {\n\taddress\t\t\t0x096\n\taccess_mode\tRW\n\tmodes\t\tM_CCHAN\n\tfield\tSTAETERM\t0x80\n\tfield\tSCBCERR\t\t0x40\n\tfield\tSCADERR\t\t0x20\n\tfield\tSCDATBUCKET\t0x10\n\tfield\tCNTNOTCMPLT\t0x08\n\tfield\tRXOVRUN\t\t0x04\n\tfield\tRXSCEMSG\t0x02\n\tfield\tRXSPLTRSP\t0x01\n}\n\n/*\n * Overlay Split Status 0\n */\nregister OVLYSPLTSTAT0 {\n\taddress\t\t\t0x096\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tfield\tSTAETERM\t0x80\n\tfield\tSCBCERR\t\t0x40\n\tfield\tSCADERR\t\t0x20\n\tfield\tSCDATBUCKET\t0x10\n\tfield\tCNTNOTCMPLT\t0x08\n\tfield\tRXOVRUN\t\t0x04\n\tfield\tRXSCEMSG\t0x02\n\tfield\tRXSPLTRSP\t0x01\n}\n\n/*\n * Data Channel Split Status 1\n */\nregister DCHSPLTSTAT1 {\n\taddress\t\t\t0x097\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1\n\tcount\t\t2\n\tfield\tRXDATABUCKET\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * CMC Split Status 1\n */\nregister CMCSPLTSTAT1 {\n\taddress\t\t\t0x097\n\taccess_mode\tRW\n\tmodes\t\tM_CCHAN\n\tfield\tRXDATABUCKET\t0x01\n}\n\n/*\n * Overlay Split Status 1\n */\nregister OVLYSPLTSTAT1 {\n\taddress\t\t\t0x097\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tfield\tRXDATABUCKET\t0x01\n}\n\n/*\n * S/G Receive Message 0\n */\nregister SGRXMSG0 {\n\taddress\t\t\t0x098\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\t\tCDNUM\t0xF8\n\tfield\t\tCFNUM\t0x07\n}\n\n/*\n * S/G Receive Message 1\n */\nregister SGRXMSG1 {\n\taddress\t\t\t0x099\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tCBNUM\t\t0xFF\n}\n\n/*\n * S/G Receive Message 2\n */\nregister SGRXMSG2 {\n\taddress\t\t\t0x09A\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tMINDEX\t\t0xFF\n}\n\n/*\n * S/G Receive Message 3\n */\nregister SGRXMSG3 {\n\taddress\t\t\t0x09B\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tMCLASS\t\t0x0F\n}\n\n/*\n * Slave Split Out Address 0\n */\nregister SLVSPLTOUTADR0 {\n\taddress\t\t\t0x098\n\taccess_mode\tRO\n\tmodes\t\tM_SCSI\n\tfield\tLOWER_ADDR\t0x7F\n}\n\n/*\n * Slave Split Out Address 1\n */\nregister SLVSPLTOUTADR1 {\n\taddress\t\t\t0x099\n\taccess_mode\tRO\n\tmodes\t\tM_SCSI\n\tfield\tREQ_DNUM\t0xF8\n\tfield\tREQ_FNUM\t0x07\n}\n\n/*\n * Slave Split Out Address 2\n */\nregister SLVSPLTOUTADR2 {\n\taddress\t\t\t0x09A\n\taccess_mode\tRO\n\tmodes\t\tM_SCSI\n\tfield\tREQ_BNUM\t0xFF\n}\n\n/*\n * Slave Split Out Address 3\n */\nregister SLVSPLTOUTADR3 {\n\taddress\t\t\t0x09B\n\taccess_mode\tRO\n\tmodes\t\tM_SCSI\n\tfield\tRLXORD\t\t020\n\tfield\tTAG_NUM\t\t0x1F\n}\n\n/*\n * SG Sequencer Byte Count\n */\nregister SGSEQBCNT {\n\taddress\t\t\t0x09C\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1\n}\n\n/*\n * Slave Split Out Attribute 0\n */\nregister SLVSPLTOUTATTR0 {\n\taddress\t\t\t0x09C\n\taccess_mode\tRO\n\tmodes\t\tM_SCSI\n\tfield\tLOWER_BCNT\t0xFF\n}\n\n/*\n * Slave Split Out Attribute 1\n */\nregister SLVSPLTOUTATTR1 {\n\taddress\t\t\t0x09D\n\taccess_mode\tRO\n\tmodes\t\tM_SCSI\n\tfield\tCMPLT_DNUM\t0xF8\n\tfield\tCMPLT_FNUM\t0x07\n}\n\n/*\n * Slave Split Out Attribute 2\n */\nregister SLVSPLTOUTATTR2 {\n\taddress\t\t\t0x09E\n\taccess_mode\tRO\n\tsize\t\t2\n\tmodes\t\tM_SCSI\n\tfield\tCMPLT_BNUM\t0xFF\n}\n/*\n * S/G Split Status 0\n */\nregister SGSPLTSTAT0 {\n\taddress\t\t\t0x09E\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1\n\tcount\t\t2\n\tfield\tSTAETERM\t0x80\n\tfield\tSCBCERR\t\t0x40\n\tfield\tSCADERR\t\t0x20\n\tfield\tSCDATBUCKET\t0x10\n\tfield\tCNTNOTCMPLT\t0x08\n\tfield\tRXOVRUN\t\t0x04\n\tfield\tRXSCEMSG\t0x02\n\tfield\tRXSPLTRSP\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * S/G Split Status 1\n */\nregister SGSPLTSTAT1 {\n\taddress\t\t\t0x09F\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1\n\tcount\t\t2\n\tfield\tRXDATABUCKET\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * Special Function\n */\nregister SFUNCT {\n\taddress\t\t\t0x09f\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tTEST_GROUP\t0xF0\n\tfield\tTEST_NUM\t0x0F\n\tdont_generate_debug_code\n}\n\n/*\n * Data FIFO 0 PCI Status \n */\nregister DF0PCISTAT {\n\taddress\t\t\t0x0A0\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tfield\tDPE\t\t0x80\n\tfield\tSSE\t\t0x40\n\tfield\tRMA\t\t0x20\n\tfield\tRTA\t\t0x10\n\tfield\tSCAAPERR\t0x08\n\tfield\tRDPERR\t\t0x04\n\tfield\tTWATERR\t\t0x02\n\tfield\tDPR\t\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * Data FIFO 1 PCI Status \n */\nregister DF1PCISTAT {\n\taddress\t\t\t0x0A1\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tDPE\t\t0x80\n\tfield\tSSE\t\t0x40\n\tfield\tRMA\t\t0x20\n\tfield\tRTA\t\t0x10\n\tfield\tSCAAPERR\t0x08\n\tfield\tRDPERR\t\t0x04\n\tfield\tTWATERR\t\t0x02\n\tfield\tDPR\t\t0x01\n}\n\n/*\n * S/G PCI Status \n */\nregister SGPCISTAT {\n\taddress\t\t\t0x0A2\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tDPE\t\t0x80\n\tfield\tSSE\t\t0x40\n\tfield\tRMA\t\t0x20\n\tfield\tRTA\t\t0x10\n\tfield\tSCAAPERR\t0x08\n\tfield\tRDPERR\t\t0x04\n\tfield\tDPR\t\t0x01\n}\n\n/*\n * CMC PCI Status \n */\nregister CMCPCISTAT {\n\taddress\t\t\t0x0A3\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tDPE\t\t0x80\n\tfield\tSSE\t\t0x40\n\tfield\tRMA\t\t0x20\n\tfield\tRTA\t\t0x10\n\tfield\tSCAAPERR\t0x08\n\tfield\tRDPERR\t\t0x04\n\tfield\tTWATERR\t\t0x02\n\tfield\tDPR\t\t0x01\n}\n\n/*\n * Overlay PCI Status \n */\nregister OVLYPCISTAT {\n\taddress\t\t\t0x0A4\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tDPE\t\t0x80\n\tfield\tSSE\t\t0x40\n\tfield\tRMA\t\t0x20\n\tfield\tRTA\t\t0x10\n\tfield\tSCAAPERR\t0x08\n\tfield\tRDPERR\t\t0x04\n\tfield\tDPR\t\t0x01\n}\n\n/*\n * PCI Status for MSI Master DMA Transfer\n */\nregister MSIPCISTAT {\n\taddress\t\t\t0x0A6\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tSSE\t\t0x40\n\tfield\tRMA\t\t0x20\n\tfield\tRTA\t\t0x10\n\tfield\tCLRPENDMSI\t0x08\n\tfield\tTWATERR\t\t0x02\n\tfield\tDPR\t\t0x01\n}\n\n/*\n * PCI Status for Target\n */\nregister TARGPCISTAT {\n\taddress\t\t\t0x0A7\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t5\n\tfield\tDPE\t\t0x80\n\tfield\tSSE\t\t0x40\n\tfield\tSTA\t\t0x08\n\tfield\tTWATERR\t\t0x02\n\tdont_generate_debug_code\n}\n\n/*\n * LQ Packet In\n * The last LQ Packet received\n */\nregister LQIN {\n\taddress\t\t\t0x020\n\taccess_mode\tRW\n\tsize\t\t20\n\tcount\t\t2\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tdont_generate_debug_code\n}\n\n/*\n * SCB Type Pointer\n * SCB offset for Target Mode SCB type information\n */\nregister TYPEPTR {\n\taddress\t\t\t0x020\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n}\n\n/*\n * Queue Tag Pointer\n * SCB offset to the Two Byte tag identifier used for target mode.\n */\nregister TAGPTR {\n\taddress\t\t\t0x021\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n}\n\n/*\n * Logical Unit Number Pointer\n * SCB offset to the LSB (little endian) of the lun field.\n */\nregister LUNPTR {\n\taddress\t\t\t0x022\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * Data Length Pointer\n * SCB offset for the 4 byte data length field in target mode.\n */\nregister DATALENPTR {\n\taddress\t\t\t0x023\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n}\n\n/*\n * Status Length Pointer\n * SCB offset to the two byte status field in target SCBs.\n */\nregister STATLENPTR {\n\taddress\t\t\t0x024\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n}\n\n/*\n * Command Length Pointer\n * Scb offset for the CDB length field in initiator SCBs.\n */\nregister CMDLENPTR {\n\taddress\t\t\t0x025\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tdont_generate_debug_code\n}\n\n/*\n * Task Attribute Pointer\n * Scb offset for the byte field specifying the attribute byte\n * to be used in command packets.\n */ \nregister ATTRPTR {\n\taddress\t\t\t0x026\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tdont_generate_debug_code\n}\n\n/*\n * Task Management Flags Pointer\n * Scb offset for the byte field specifying the attribute flags\n * byte to be used in command packets.\n */ \nregister FLAGPTR {\n\taddress\t\t\t0x027\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tdont_generate_debug_code\n}\n\n/*\n * Command Pointer\n * Scb offset for the first byte in the CDB for initiator SCBs.\n */\nregister CMDPTR {\n\taddress\t\t\t0x028\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tdont_generate_debug_code\n}\n\n/*\n * Queue Next Pointer\n * Scb offset for the 2 byte \"next scb link\".\n */\nregister QNEXTPTR {\n\taddress\t\t\t0x029\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI ID Pointer\n * Scb offset to the value to place in the SCSIID register\n * during target mode connections.\n */\nregister IDPTR {\n\taddress\t\t\t0x02A\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n}\n\n/*\n * Command Aborted Byte Pointer\n * Offset to the SCB flags field that includes the\n * \"SCB aborted\" status bit.\n */\nregister ABRTBYTEPTR {\n\taddress\t\t\t0x02B\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tdont_generate_debug_code\n}\n\n/*\n * Command Aborted Bit Pointer\n * Bit offset in the SCB flags field for \"SCB aborted\" status.\n */\nregister ABRTBITPTR {\n\taddress\t\t\t0x02C\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tdont_generate_debug_code\n}\n\n/*\n * Rev B or greater.\n */\nregister MAXCMDBYTES {\n\taddress\t\t\t0x02D\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n}\n\n/*\n * Rev B or greater.\n */\nregister MAXCMD2RCV {\n\taddress\t\t\t0x02E\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n}\n\n/*\n * Rev B or greater.\n */\nregister SHORTTHRESH {\n\taddress\t\t\t0x02F\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n}\n\n/*\n * Logical Unit Number Length\n * The length, in bytes, of the SCB lun field.\n */\nregister LUNLEN {\n\taddress\t\t\t0x030\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t2\n\tmask\t\tILUNLEN\t0x0F\n\tmask\t\tTLUNLEN\t0xF0\n\tdont_generate_debug_code\n}\nconst LUNLEN_SINGLE_LEVEL_LUN 0xF\n\n/*\n * CDB Limit\n * The size, in bytes, of the embedded CDB field in initator SCBs.\n */\nregister CDBLIMIT {\n\taddress\t\t\t0x031\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tdont_generate_debug_code\n}\n\n/*\n * Maximum Commands\n * The maximum number of commands to issue during a\n * single packetized connection.\n */\nregister MAXCMD {\n\taddress\t\t\t0x032\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t9\n\tdont_generate_debug_code\n}\n\n/*\n * Maximum Command Counter\n * The number of commands already sent during this connection\n */\nregister MAXCMDCNT {\n\taddress\t\t\t0x033\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tdont_generate_debug_code\n}\n\n/*\n * LQ Packet Reserved Bytes\n * The bytes to be sent in the currently reserved fileds\n * of all LQ packets.\n */\nregister LQRSVD01 {\n\taddress\t\t\t0x034\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n}\nregister LQRSVD16 {\n\taddress\t\t\t0x035\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n}\nregister LQRSVD17 {\n\taddress\t\t\t0x036\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n}\n\n/*\n * Command Reserved 0\n * The byte to be sent for the reserved byte 0 of\n * outgoing command packets.\n */\nregister CMDRSVD0 {\n\taddress\t\t\t0x037\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n}\n\n/*\n * LQ Manager Control 0\n */\nregister LQCTL0 {\n\taddress\t\t\t0x038\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tLQITARGCLT\t0xC0\n\tfield\tLQIINITGCLT\t0x30\n\tfield\tLQ0TARGCLT\t0x0C\n\tfield\tLQ0INITGCLT\t0x03\n}\n\n/*\n * LQ Manager Control 1\n */\nregister LQCTL1 {\n\taddress\t\t\t0x038\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tcount\t\t2\n\tfield\tPCI2PCI\t\t0x04\n\tfield\tSINGLECMD\t0x02\n\tfield\tABORTPENDING\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * LQ Manager Control 2\n */\nregister LQCTL2 {\n\taddress\t\t\t0x039\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tcount\t\t5\n\tfield\tLQIRETRY\t0x80\n\tfield\tLQICONTINUE\t0x40\n\tfield\tLQITOIDLE\t0x20\n\tfield\tLQIPAUSE\t0x10\n\tfield\tLQORETRY\t0x08\n\tfield\tLQOCONTINUE\t0x04\n\tfield\tLQOTOIDLE\t0x02\n\tfield\tLQOPAUSE\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI RAM BIST0\n */\nregister SCSBIST0 {\n\taddress\t\t\t0x039\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tGSBISTERR\t0x40\n\tfield\tGSBISTDONE\t0x20\n\tfield\tGSBISTRUN\t0x10\n\tfield\tOSBISTERR\t0x04\n\tfield\tOSBISTDONE\t0x02\n\tfield\tOSBISTRUN\t0x01\n}\n\n/*\n * SCSI Sequence Control0\n */\nregister SCSISEQ0 {\n\taddress\t\t\t0x03A\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tTEMODEO\t\t0x80\n\tfield\tENSELO\t\t0x40\n\tfield\tENARBO\t\t0x20\n\tfield\tFORCEBUSFREE\t0x10\n\tfield\tSCSIRSTO\t0x01\n}\n\n/*\n * SCSI RAM BIST 1\n */\nregister SCSBIST1 {\n\taddress\t\t\t0x03A\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tNTBISTERR\t0x04\n\tfield\tNTBISTDONE\t0x02\n\tfield\tNTBISTRUN\t0x01\n}\n\n/*\n * SCSI Sequence Control 1\n */\nregister SCSISEQ1 {\n\taddress\t\t\t0x03B\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tcount\t\t8\n\tfield\tMANUALCTL\t0x40\n\tfield\tENSELI\t\t0x20\n\tfield\tENRSELI\t\t0x10\n\tfield\tMANUALP\t\t0x0C\n\tfield\tENAUTOATNP\t0x02\n\tfield\tALTSTIM\t\t0x01\n}\n\n/*\n * SCSI Transfer Control 0\n */\nregister SXFRCTL0 {\n\taddress\t\t\t0x03C\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tfield\tDFON\t\t0x80\n\tfield\tDFPEXP\t\t0x40\n\tfield\tBIOSCANCELEN\t0x10\n\tfield\tSPIOEN\t\t0x08\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Transfer Control 1\n */\nregister SXFRCTL1 {\n\taddress\t\t\t0x03D\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tfield\tBITBUCKET\t0x80\n\tfield\tENSACHK\t\t0x40\n\tfield\tENSPCHK\t\t0x20\n\tfield\tSTIMESEL\t0x18\n\tfield\tENSTIMER\t0x04\n\tfield\tACTNEGEN\t0x02\n\tfield\tSTPWEN\t\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Transfer Control 2\n */\nregister SXFRCTL2 {\n\taddress\t\t\t0x03E\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tfield\tAUTORSTDIS\t0x10\n\tfield\tCMDDMAEN\t0x08\n\tfield\tASU\t\t0x07\n}\n\n/*\n * SCSI Bus Initiator IDs\n * Bitmask of observed initiators on the bus.\n */\nregister BUSINITID {\n\taddress\t\t\t0x03C\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tsize\t\t2\n}\n\n/*\n * Data Length Counters\n * Packet byte counter.\n */\nregister DLCOUNT {\n\taddress\t\t\t0x03C\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1\n\tsize\t\t3\n}\n\n/*\n * Data FIFO Status\n */\nregister DFFSTAT {\n\taddress\t\t\t0x03F\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tfield\tFIFO1FREE\t0x20\n\tfield\tFIFO0FREE\t0x10\n\t/*\n\t * On the B, this enum only works\n\t * in the read direction.  For writes,\n\t * you must use the B version of the\n\t * CURRFIFO_0 definition which is defined\n\t * as a constant outside of this register\n\t * definition to avoid confusing the\n\t * register pretty printing code.\n\t */\n\tenum\tCURRFIFO\t0x03 {\n\t\tCURRFIFO_0,\n\t\tCURRFIFO_1,\n\t\tCURRFIFO_NONE\t0x3\n\t}\n}\n\nconst B_CURRFIFO_0 0x2\n\n/*\n * SCSI Bus Target IDs\n * Bitmask of observed targets on the bus.\n */\nregister BUSTARGID {\n\taddress\t\t\t0x03E\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tsize\t\t2\n}\n\n/*\n * SCSI Control Signal Out\n */\nregister SCSISIGO {\n\taddress\t\t\t0x040\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tCDO\t\t0x80\n\tfield\tIOO\t\t0x40\n\tfield\tMSGO\t\t0x20\n\tfield\tATNO\t\t0x10\n\tfield\tSELO\t\t0x08\n\tfield\tBSYO\t\t0x04\n\tfield\tREQO\t\t0x02\n\tfield\tACKO\t\t0x01\n/*\n * Possible phases to write into SCSISIG0\n */\n\tenum\tPHASE_MASK  CDO|IOO|MSGO {\n\t\tP_DATAOUT\t0x0,\n\t\tP_DATAIN\tIOO,\n\t\tP_DATAOUT_DT\tP_DATAOUT|MSGO,\n\t\tP_DATAIN_DT\tP_DATAIN|MSGO,\n\t\tP_COMMAND\tCDO,\n\t\tP_MESGOUT\tCDO|MSGO,\n\t\tP_STATUS\tCDO|IOO,\n\t\tP_MESGIN\tCDO|IOO|MSGO\n\t}\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Control Signal In\n */\nregister SCSISIGI {\n\taddress\t\t\t0x041\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tCDI\t\t0x80\n\tfield\tIOI\t\t0x40\n\tfield\tMSGI\t\t0x20\n\tfield\tATNI\t\t0x10\n\tfield\tSELI\t\t0x08\n\tfield\tBSYI\t\t0x04\n\tfield\tREQI\t\t0x02\n\tfield\tACKI\t\t0x01\n/*\n * Possible phases in SCSISIGI\n */\n\tenum\tPHASE_MASK  CDO|IOO|MSGO {\n\t\tP_DATAOUT\t0x0,\n\t\tP_DATAIN\tIOO,\n\t\tP_DATAOUT_DT\tP_DATAOUT|MSGO,\n\t\tP_DATAIN_DT\tP_DATAIN|MSGO,\n\t\tP_COMMAND\tCDO,\n\t\tP_MESGOUT\tCDO|MSGO,\n\t\tP_STATUS\tCDO|IOO,\n\t\tP_MESGIN\tCDO|IOO|MSGO\n\t}\n}\n\n/*\n * Multiple Target IDs\n * Bitmask of ids to respond as a target.\n */\nregister MULTARGID {\n\taddress\t\t\t0x040\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tsize\t\t2\n\tcount\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Phase\n */\nregister SCSIPHASE {\n\taddress\t\t\t0x042\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tSTATUS_PHASE\t0x20\n\tfield\tCOMMAND_PHASE\t0x10\n\tfield\tMSG_IN_PHASE\t0x08\n\tfield\tMSG_OUT_PHASE\t0x04\n\tfield\tDATA_PHASE_MASK\t0x03 {\n\t\tDATA_OUT_PHASE\t0x01,\n\t\tDATA_IN_PHASE\t0x02\n\t}\n}\n\n/*\n * SCSI Data 0 Image\n */\nregister SCSIDAT0_IMG {\n\taddress\t\t\t0x043\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n}\n\n/*\n * SCSI Latched Data\n */\nregister SCSIDAT {\n\taddress\t\t\t0x044\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tsize\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Data Bus\n */\nregister SCSIBUS {\n\taddress\t\t\t0x046\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tsize\t\t2\n}\n\n/*\n * Target ID In\n */\nregister TARGIDIN {\n\taddress\t\t\t0x048\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tcount\t\t2\n\tfield\tCLKOUT\t\t0x80\n\tfield\tTARGID\t\t0x0F\n\tdont_generate_debug_code\n}\n\n/*\n * Selection/Reselection ID\n * Upper four bits are the device id.  The ONEBIT is set when the re/selecting\n * device did not set its own ID.\n */\nregister SELID {\n\taddress\t\t\t0x049\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tSELID_MASK\t0xf0\n\tfield\tONEBIT\t\t0x08\n}\n\n/*\n * SCSI Block Control\n * Controls Bus type and channel selection.  SELWIDE allows for the\n * coexistence of 8bit and 16bit devices on a wide bus.\n */\nregister SBLKCTL {\n\taddress\t\t\t0x04A\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tDIAGLEDEN\t0x80\n\tfield\tDIAGLEDON\t0x40\n\tfield\tENAB40\t\t0x08\t/* LVD transceiver active */\n\tfield\tENAB20\t\t0x04\t/* SE/HVD transceiver active */\n\tfield\tSELWIDE\t\t0x02\n\tdont_generate_debug_code\n}\n\n/*\n * Option Mode\n */\nregister OPTIONMODE {\n\taddress\t\t\t0x04A\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t4\n\tfield\tBIOSCANCTL\t\t0x80\n\tfield\tAUTOACKEN\t\t0x40\n\tfield\tBIASCANCTL\t\t0x20\n\tfield\tBUSFREEREV\t\t0x10\n\tfield\tENDGFORMCHK\t\t0x04\n\tfield\tAUTO_MSGOUT_DE\t\t0x02\n\tmask\tOPTIONMODE_DEFAULTS\tAUTO_MSGOUT_DE\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Status 0\n */\nregister SSTAT0\t{\n\taddress\t\t\t0x04B\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tTARGET\t\t0x80\t/* Board acting as target */\n\tfield\tSELDO\t\t0x40\t/* Selection Done */\n\tfield\tSELDI\t\t0x20\t/* Board has been selected */\n\tfield\tSELINGO\t\t0x10\t/* Selection In Progress */\n\tfield\tIOERR\t\t0x08\t/* LVD Tranceiver mode changed */\n\tfield\tOVERRUN\t\t0x04\t/* SCSI Offset overrun detected */\n\tfield\tSPIORDY\t\t0x02\t/* SCSI PIO Ready */\n\tfield\tARBDO\t\t0x01\t/* Arbitration Done Out */\n}\n\n/*\n * Clear SCSI Interrupt 0\n * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT0.\n */\nregister CLRSINT0 {\n\taddress\t\t\t0x04B\n\taccess_mode\tWO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tCLRSELDO\t0x40\n\tfield\tCLRSELDI\t0x20\n\tfield\tCLRSELINGO\t0x10\n\tfield\tCLRIOERR\t0x08\n\tfield\tCLROVERRUN\t0x04\n\tfield\tCLRSPIORDY\t0x02\n\tfield\tCLRARBDO\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Interrupt Mode 0\n * Setting any bit will enable the corresponding function\n * in SIMODE0 to interrupt via the IRQ pin.\n */\nregister SIMODE0 {\n\taddress\t\t\t0x04B\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t8\n\tfield\tENSELDO\t\t0x40\n\tfield\tENSELDI\t\t0x20\n\tfield\tENSELINGO\t0x10\n\tfield\tENIOERR\t\t0x08\n\tfield\tENOVERRUN\t0x04\n\tfield\tENSPIORDY\t0x02\n\tfield\tENARBDO\t\t0x01\n}\n\n/*\n * SCSI Status 1\n */\nregister SSTAT1 {\n\taddress\t\t\t0x04C\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tSELTO\t\t0x80\n\tfield\tATNTARG \t0x40\n\tfield\tSCSIRSTI\t0x20\n\tfield\tPHASEMIS\t0x10\n\tfield\tBUSFREE\t\t0x08\n\tfield\tSCSIPERR\t0x04\n\tfield\tSTRB2FAST\t0x02\n\tfield\tREQINIT\t\t0x01\n}\n\n/*\n * Clear SCSI Interrupt 1\n * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT1.\n */\nregister CLRSINT1 {\n\taddress\t\t\t0x04C\n\taccess_mode\tWO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tCLRSELTIMEO\t0x80\n\tfield\tCLRATNO\t\t0x40\n\tfield\tCLRSCSIRSTI\t0x20\n\tfield\tCLRBUSFREE\t0x08\n\tfield\tCLRSCSIPERR\t0x04\n\tfield\tCLRSTRB2FAST\t0x02\n\tfield\tCLRREQINIT\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Status 2\n */\nregister SSTAT2 {\n\taddress\t\t\t0x04d\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tBUSFREETIME\t0xc0 {\n\t\tBUSFREE_LQO\t0x40,\n\t\tBUSFREE_DFF0\t0x80,\n\t\tBUSFREE_DFF1\t0xC0\n\t}\n\tfield\tNONPACKREQ\t0x20\n\tfield\tEXP_ACTIVE\t0x10\t/* SCSI Expander Active */\n\tfield\tBSYX\t\t0x08\t/* Busy Expander */\n\tfield\tWIDE_RES\t0x04\t/* Modes 0 and 1 only */\n\tfield\tSDONE\t\t0x02\t/* Modes 0 and 1 only */\n\tfield\tDMADONE\t\t0x01\t/* Modes 0 and 1 only */\n}\n\n/*\n * Clear SCSI Interrupt 2\n */\nregister CLRSINT2 {\n\taddress\t\t\t0x04D\n\taccess_mode\tWO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tCLRNONPACKREQ\t0x20\n\tfield\tCLRWIDE_RES\t0x04\t/* Modes 0 and 1 only */\n\tfield\tCLRSDONE\t0x02\t/* Modes 0 and 1 only */\n\tfield\tCLRDMADONE\t0x01\t/* Modes 0 and 1 only */\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Interrupt Mode 2\n */\nregister SIMODE2 {\n\taddress\t\t\t0x04D\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tENWIDE_RES\t0x04\n\tfield\tENSDONE\t\t0x02\n\tfield\tENDMADONE\t0x01\n}\n\n/*\n * Physical Error Diagnosis\n */\nregister PERRDIAG {\n\taddress\t\t\t0x04E\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tcount\t\t3\n\tfield\tHIZERO\t\t0x80\n\tfield\tHIPERR\t\t0x40\n\tfield\tPREVPHASE\t0x20\n\tfield\tPARITYERR\t0x10\n\tfield\tAIPERR\t\t0x08\n\tfield\tCRCERR\t\t0x04\n\tfield\tDGFORMERR\t0x02\n\tfield\tDTERR\t\t0x01\n}\n\n/*\n * LQI Manager Current State\n */\nregister LQISTATE {\n\taddress\t\t\t0x04E\n\taccess_mode\tRO\n\tmodes\t\tM_CFG\n\tcount\t\t6\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Offset Count\n */\nregister SOFFCNT {\n\taddress\t\t\t0x04F\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tcount\t\t1\n}\n\n/*\n * LQO Manager Current State\n */\nregister LQOSTATE {\n\taddress\t\t\t0x04F\n\taccess_mode\tRO\n\tmodes\t\tM_CFG\n\tcount\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * LQI Manager Status\n */\nregister LQISTAT0 {\n\taddress\t\t\t0x050\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tcount\t\t2\n\tfield\tLQIATNQAS\t0x20\n\tfield\tLQICRCT1\t0x10\n\tfield\tLQICRCT2\t0x08\n\tfield\tLQIBADLQT\t0x04\n\tfield\tLQIATNLQ\t0x02\n\tfield\tLQIATNCMD\t0x01\n}\n\n/*\n * Clear LQI Interrupts 0\n */\nregister CLRLQIINT0 {\n\taddress\t\t\t0x050\n\taccess_mode\tWO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tcount\t\t1\n\tfield\tCLRLQIATNQAS\t0x20\n\tfield\tCLRLQICRCT1\t0x10\n\tfield\tCLRLQICRCT2\t0x08\n\tfield\tCLRLQIBADLQT\t0x04\n\tfield\tCLRLQIATNLQ\t0x02\n\tfield\tCLRLQIATNCMD\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * LQI Manager Interrupt Mode 0\n */\nregister LQIMODE0 {\n\taddress\t\t\t0x050\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t3\n\tfield\tENLQIATNQASK\t0x20\n\tfield\tENLQICRCT1\t0x10\n\tfield\tENLQICRCT2\t0x08\n\tfield\tENLQIBADLQT\t0x04\n\tfield\tENLQIATNLQ\t0x02\n\tfield\tENLQIATNCMD\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * LQI Manager Status 1\n */\nregister LQISTAT1 {\n\taddress\t\t\t0x051\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tcount\t\t3\n\tfield\tLQIPHASE_LQ\t0x80\n\tfield\tLQIPHASE_NLQ\t0x40\n\tfield\tLQIABORT\t0x20\n\tfield\tLQICRCI_LQ\t0x10\n\tfield\tLQICRCI_NLQ\t0x08\n\tfield\tLQIBADLQI\t0x04\n\tfield\tLQIOVERI_LQ\t0x02\n\tfield\tLQIOVERI_NLQ\t0x01\n}\n\n/*\n * Clear LQI Manager Interrupts1\n */\nregister CLRLQIINT1 {\n\taddress\t\t\t0x051\n\taccess_mode\tWO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tcount\t\t4\n\tfield\tCLRLQIPHASE_LQ\t0x80\n\tfield\tCLRLQIPHASE_NLQ\t0x40\n\tfield\tCLRLIQABORT\t0x20\n\tfield\tCLRLQICRCI_LQ\t0x10\n\tfield\tCLRLQICRCI_NLQ\t0x08\n\tfield\tCLRLQIBADLQI\t0x04\n\tfield\tCLRLQIOVERI_LQ\t0x02\n\tfield\tCLRLQIOVERI_NLQ\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * LQI Manager Interrupt Mode 1\n */\nregister LQIMODE1 {\n\taddress\t\t\t0x051\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t4\n\tfield\tENLQIPHASE_LQ\t0x80\t/* LQIPHASE1 */\n\tfield\tENLQIPHASE_NLQ\t0x40\t/* LQIPHASE2 */\n\tfield\tENLIQABORT\t0x20\n\tfield\tENLQICRCI_LQ\t0x10\t/* LQICRCI1 */\n\tfield\tENLQICRCI_NLQ\t0x08\t/* LQICRCI2 */\n\tfield\tENLQIBADLQI\t0x04\n\tfield\tENLQIOVERI_LQ\t0x02\t/* LQIOVERI1 */\n\tfield\tENLQIOVERI_NLQ\t0x01\t/* LQIOVERI2 */\n\tdont_generate_debug_code\n}\n\n/*\n * LQI Manager Status 2\n */\nregister LQISTAT2 {\n\taddress\t\t\t0x052\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tPACKETIZED\t0x80\n\tfield\tLQIPHASE_OUTPKT\t0x40\n\tfield\tLQIWORKONLQ\t0x20\n\tfield\tLQIWAITFIFO\t0x10\n\tfield\tLQISTOPPKT\t0x08\n\tfield\tLQISTOPLQ\t0x04\n\tfield\tLQISTOPCMD\t0x02\n\tfield\tLQIGSAVAIL\t0x01\n}\n\n/*\n * SCSI Status 3\n */\nregister SSTAT3 {\n\taddress\t\t\t0x053\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tcount\t\t3\n\tfield\tNTRAMPERR\t0x02\n\tfield\tOSRAMPERR\t0x01\n}\n\n/*\n * Clear SCSI Status 3\n */\nregister CLRSINT3 {\n\taddress\t\t\t0x053\n\taccess_mode\tWO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tcount\t\t3\n\tfield\tCLRNTRAMPERR\t0x02\n\tfield\tCLROSRAMPERR\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Interrupt Mode 3\n */\nregister SIMODE3 {\n\taddress\t\t\t0x053\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t4\n\tfield\tENNTRAMPERR\t0x02\n\tfield\tENOSRAMPERR\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * LQO Manager Status 0\n */\nregister LQOSTAT0 {\n\taddress\t\t\t0x054\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tcount\t\t2\n\tfield\tLQOTARGSCBPERR\t0x10\n\tfield\tLQOSTOPT2\t0x08\n\tfield\tLQOATNLQ\t0x04\n\tfield\tLQOATNPKT\t0x02\n\tfield\tLQOTCRC\t\t0x01\n}\n\n/*\n * Clear LQO Manager interrupt 0\n */\nregister CLRLQOINT0 {\n\taddress\t\t\t0x054\n\taccess_mode\tWO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tcount\t\t3\n\tfield\tCLRLQOTARGSCBPERR\t0x10\n\tfield\tCLRLQOSTOPT2\t\t0x08\n\tfield\tCLRLQOATNLQ\t\t0x04\n\tfield\tCLRLQOATNPKT\t\t0x02\n\tfield\tCLRLQOTCRC\t\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * LQO Manager Interrupt Mode 0\n */\nregister LQOMODE0 {\n\taddress\t\t\t0x054\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t4\n\tfield\tENLQOTARGSCBPERR\t0x10\n\tfield\tENLQOSTOPT2\t\t0x08\n\tfield\tENLQOATNLQ\t\t0x04\n\tfield\tENLQOATNPKT\t\t0x02\n\tfield\tENLQOTCRC\t\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * LQO Manager Status 1\n */\nregister LQOSTAT1 {\n\taddress\t\t\t0x055\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tLQOINITSCBPERR\t0x10\n\tfield\tLQOSTOPI2\t0x08\n\tfield\tLQOBADQAS\t0x04\n\tfield\tLQOBUSFREE\t0x02\n\tfield\tLQOPHACHGINPKT\t0x01\n}\n\n/*\n * Clear LOQ Interrupt 1\n */\nregister CLRLQOINT1 {\n\taddress\t\t\t0x055\n\taccess_mode\tWO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tcount\t\t7\n\tfield\tCLRLQOINITSCBPERR\t0x10\n\tfield\tCLRLQOSTOPI2\t\t0x08\n\tfield\tCLRLQOBADQAS\t\t0x04\n\tfield\tCLRLQOBUSFREE\t\t0x02\n\tfield\tCLRLQOPHACHGINPKT\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * LQO Manager Interrupt Mode 1\n */\nregister LQOMODE1 {\n\taddress\t\t\t0x055\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t4\n\tfield\tENLQOINITSCBPERR\t0x10\n\tfield\tENLQOSTOPI2\t\t0x08\n\tfield\tENLQOBADQAS\t\t0x04\n\tfield\tENLQOBUSFREE\t\t0x02\n\tfield\tENLQOPHACHGINPKT\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * LQO Manager Status 2\n */\nregister LQOSTAT2 {\n\taddress\t\t\t0x056\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tLQOPKT\t\t0xE0\n\tfield\tLQOWAITFIFO\t0x10\n\tfield\tLQOPHACHGOUTPKT\t0x02\t/* outside of packet boundaries. */\n\tfield\tLQOSTOP0\t0x01\t/* Stopped after sending all packets */\n}\n\n/*\n * Output Synchronizer Space Count\n */\nregister OS_SPACE_CNT {\n\taddress\t\t\t0x056\n\taccess_mode\tRO\n\tmodes\t\tM_CFG\n\tcount\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Interrupt Mode 1\n * Setting any bit will enable the corresponding function\n * in SIMODE1 to interrupt via the IRQ pin.\n */\nregister SIMODE1 {\n\taddress\t\t\t0x057\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tfield\tENSELTIMO\t0x80\n\tfield\tENATNTARG\t0x40\n\tfield\tENSCSIRST\t0x20\n\tfield\tENPHASEMIS\t0x10\n\tfield\tENBUSFREE\t0x08\n\tfield\tENSCSIPERR\t0x04\n\tfield\tENSTRB2FAST\t0x02\n\tfield\tENREQINIT\t0x01\n}\n\n/*\n * Good Status FIFO\n */\nregister GSFIFO {\n\taddress\t\t\t0x058\n\taccess_mode\tRO\n\tsize\t\t2\n\tmodes\t\tM_DFF0, M_DFF1, M_SCSI\n\tdont_generate_debug_code\n}\n\n/*\n * Data FIFO SCSI Transfer Control\n */\nregister DFFSXFRCTL {\n\taddress\t\t\t0x05A\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tDFFBITBUCKET\t0x08\n\tfield\tCLRSHCNT\t0x04\n\tfield\tCLRCHN\t\t0x02\n\tfield\tRSTCHN\t\t0x01\n}\n\n/*\n * Next SCSI Control Block\n */\nregister NEXTSCB {\n\taddress\t\t\t0x05A\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_SCSI\n\tdont_generate_debug_code\n}\n\n/*\n * LQO SCSI Control\n * (Rev B only.)\n */\nregister LQOSCSCTL {\n\taddress\t\t\t0x05A\n\taccess_mode\tRW\n\tsize\t\t1\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tfield\t\tLQOH2A_VERSION\t0x80\n\tfield\t\tLQOBUSETDLY\t0x40\n\tfield\t\tLQONOHOLDLACK\t0x02\n\tfield\t\tLQONOCHKOVER\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * SEQ Interrupts\n */\nregister SEQINTSRC {\n\taddress\t\t\t0x05B\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tCTXTDONE\t0x40\n\tfield\tSAVEPTRS\t0x20\n\tfield\tCFG4DATA\t0x10\n\tfield\tCFG4ISTAT\t0x08\n\tfield\tCFG4TSTAT\t0x04\n\tfield\tCFG4ICMD\t0x02\n\tfield\tCFG4TCMD\t0x01\n}\n\n/*\n * Clear Arp Interrupts\n */\nregister CLRSEQINTSRC {\n\taddress\t\t\t0x05B\n\taccess_mode\tWO\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tCLRCTXTDONE\t0x40\n\tfield\tCLRSAVEPTRS\t0x20\n\tfield\tCLRCFG4DATA\t0x10\n\tfield\tCLRCFG4ISTAT\t0x08\n\tfield\tCLRCFG4TSTAT\t0x04\n\tfield\tCLRCFG4ICMD\t0x02\n\tfield\tCLRCFG4TCMD\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * SEQ Interrupt Enabled (Shared)\n */\nregister SEQIMODE {\n\taddress\t\t\t0x05C\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tENCTXTDONE\t0x40\n\tfield\tENSAVEPTRS\t0x20\n\tfield\tENCFG4DATA\t0x10\n\tfield\tENCFG4ISTAT\t0x08\n\tfield\tENCFG4TSTAT\t0x04\n\tfield\tENCFG4ICMD\t0x02\n\tfield\tENCFG4TCMD\t0x01\n}\n\n/*\n * Current SCSI Control Block\n */\nregister CURRSCB {\n\taddress\t\t\t0x05C\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_SCSI\n\tdont_generate_debug_code\n}\n\n/*\n * Data FIFO Status\n */\nregister MDFFSTAT {\n\taddress\t\t\t0x05D\n\taccess_mode\tRO\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tSHCNTNEGATIVE\t0x40 /* Rev B or higher */\n\tfield\tSHCNTMINUS1\t0x20 /* Rev B or higher */\n\tfield\tLASTSDONE\t0x10\n\tfield\tSHVALID\t\t0x08\n\tfield\tDLZERO\t\t0x04 /* FIFO data ends on packet boundary. */\n\tfield\tDATAINFIFO\t0x02\n\tfield\tFIFOFREE\t0x01\n}\n\n/*\n * CRC Control\n */\nregister CRCCONTROL {\n\taddress\t\t\t0x05d\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tCRCVALCHKEN\t\t0x40\n}\n\n/*\n * SCSI Test Control\n */\nregister SCSITEST {\n\taddress\t\t\t0x05E\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tCNTRTEST\t0x08\n\tfield\tSEL_TXPLL_DEBUG\t0x04\n}\n\n/*\n * Data FIFO Queue Tag\n */\nregister DFFTAG {\n\taddress\t\t\t0x05E\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_DFF0, M_DFF1\n}\n\n/*\n * Last SCSI Control Block\n */\nregister LASTSCB {\n\taddress\t\t\t0x05E\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_SCSI\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI I/O Cell Power-down Control\n */\nregister IOPDNCTL {\n\taddress\t\t\t0x05F\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tDISABLE_OE\t0x80\n\tfield\tPDN_IDIST\t0x04\n\tfield\tPDN_DIFFSENSE\t0x01\n}\n\n/*\n * Shadow Host Address.\n */\nregister SHADDR {\n\taddress\t\t\t0x060\n\taccess_mode\tRO\n\tsize\t\t8\n\tmodes\t\tM_DFF0, M_DFF1\n\tdont_generate_debug_code\n}\n\n/*\n * Data Group CRC Interval.\n */\nregister DGRPCRCI {\n\taddress\t\t\t0x060\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_CFG\n}\n\n/*\n * Data Transfer Negotiation Address\n */\nregister NEGOADDR {\n\taddress\t\t\t0x060\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tdont_generate_debug_code\n}\n\n/*\n * Data Transfer Negotiation Data - Period Byte\n */\nregister NEGPERIOD {\n\taddress\t\t\t0x061\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tcount\t\t1\n\tdont_generate_debug_code\n}\n\n/*\n * Packetized CRC Interval\n */\nregister PACKCRCI {\n\taddress\t\t\t0x062\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_CFG\n}\n\n/*\n * Data Transfer Negotiation Data - Offset Byte\n */\nregister NEGOFFSET {\n\taddress\t\t\t0x062\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tcount\t\t1\n\tdont_generate_debug_code\n}\n\n/*\n * Data Transfer Negotiation Data - PPR Options\n */\nregister NEGPPROPTS {\n\taddress\t\t\t0x063\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tcount\t\t1\n\tfield\tPPROPT_PACE\t0x08\n\tfield\tPPROPT_QAS\t0x04\n\tfield\tPPROPT_DT\t0x02\n\tfield\tPPROPT_IUT\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * Data Transfer Negotiation Data -  Connection Options\n */\nregister NEGCONOPTS {\n\taddress\t\t\t0x064\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tfield\tENSNAPSHOT\t0x40\n\tfield\tRTI_WRTDIS\t0x20\n\tfield\tRTI_OVRDTRN\t0x10\n\tfield\tENSLOWCRC\t0x08\n\tfield\tENAUTOATNI\t0x04\n\tfield\tENAUTOATNO\t0x02\n\tfield\tWIDEXFER\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * Negotiation Table Annex Column Index.\n */\nregister ANNEXCOL {\n\taddress\t\t\t0x065\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tcount\t\t7\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Check\n * (Rev. B only)\n */\nregister SCSCHKN {\n\taddress\t\t\t0x066\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tfield\tBIDICHKDIS\t0x80\n\tfield\tSTSELSKIDDIS\t0x40\n\tfield\tCURRFIFODEF\t0x20\n\tfield\tWIDERESEN\t0x10\n\tfield\tSDONEMSKDIS\t0x08\n\tfield\tDFFACTCLR\t0x04\n\tfield\tSHVALIDSTDIS\t0x02\n\tfield\tLSTSGCLRDIS\t0x01\n\tdont_generate_debug_code\n}\n\nconst AHD_ANNEXCOL_PER_DEV0\t4\nconst AHD_NUM_PER_DEV_ANNEXCOLS\t4\nconst AHD_ANNEXCOL_PRECOMP_SLEW\t4\nconst\tAHD_PRECOMP_MASK\t0x07\nconst\tAHD_PRECOMP_SHIFT\t0\nconst\tAHD_PRECOMP_CUTBACK_17\t0x04\nconst\tAHD_PRECOMP_CUTBACK_29\t0x06\nconst\tAHD_PRECOMP_CUTBACK_37\t0x07\nconst\tAHD_SLEWRATE_MASK\t0x78\nconst\tAHD_SLEWRATE_SHIFT\t3\n/*\n * Rev A has only a single bit (high bit of field) of slew adjustment.\n * Rev B has 4 bits.  The current default happens to be the same for both.\n */\nconst\tAHD_SLEWRATE_DEF_REVA\t0x08\nconst\tAHD_SLEWRATE_DEF_REVB\t0x08\n\n/* Rev A does not have any amplitude setting. */\nconst AHD_ANNEXCOL_AMPLITUDE\t6\nconst\tAHD_AMPLITUDE_MASK\t0x7\nconst\tAHD_AMPLITUDE_SHIFT\t0\nconst\tAHD_AMPLITUDE_DEF\t0x7\n\n/*\n * Negotiation Table Annex Data Port.\n */\nregister ANNEXDAT {\n\taddress\t\t\t0x066\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tcount\t\t3\n\tdont_generate_debug_code\n}\n\n/*\n * Initiator's Own Id.\n * The SCSI ID to use for Selection Out and seen during a reselection..\n */\nregister IOWNID {\n\taddress\t\t\t0x067\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tdont_generate_debug_code\n}\n\n/*\n * 960MHz Phase-Locked Loop Control 0\n */\nregister PLL960CTL0 {\n\taddress\t\t\t0x068\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tPLL_VCOSEL\t0x80\n\tfield\tPLL_PWDN\t0x40\n\tfield\tPLL_NS\t\t0x30\n\tfield\tPLL_ENLUD\t0x08\n\tfield\tPLL_ENLPF\t0x04\n\tfield\tPLL_DLPF\t0x02\n\tfield\tPLL_ENFBM\t0x01\n}\n\n/*\n * Target Own Id\n */\nregister TOWNID {\n\taddress\t\t\t0x069\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tcount\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * 960MHz Phase-Locked Loop Control 1\n */\nregister PLL960CTL1 {\n\taddress\t\t\t0x069\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tPLL_CNTEN\t0x80\n\tfield\tPLL_CNTCLR\t0x40\n\tfield\tPLL_RST\t\t0x01\n}\n\n/*\n * Expander Signature\n */\nregister XSIG {\n\taddress\t\t\t0x06A\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n}\n\n/*\n * Shadow Byte Count\n */\nregister SHCNT {\n\taddress\t\t\t0x068\n\taccess_mode\tRW\n\tsize\t\t3\n\tmodes\t\tM_DFF0, M_DFF1\n\tdont_generate_debug_code\n}\n\n/*\n * Selection Out ID\n */\nregister SELOID {\n\taddress\t\t\t0x06B\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n}\n\n/*\n * 960-MHz Phase-Locked Loop Test Count\n */\nregister PLL960CNT0 {\n\taddress\t\t\t0x06A\n\taccess_mode\tRO\n\tsize\t\t2\n\tmodes\t\tM_CFG\n}\n\n/*\n * 400-MHz Phase-Locked Loop Control 0\n */\nregister PLL400CTL0 {\n\taddress\t\t\t0x06C\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tPLL_VCOSEL\t0x80\n\tfield\tPLL_PWDN\t0x40\n\tfield\tPLL_NS\t\t0x30\n\tfield\tPLL_ENLUD\t0x08\n\tfield\tPLL_ENLPF\t0x04\n\tfield\tPLL_DLPF\t0x02\n\tfield\tPLL_ENFBM\t0x01\n}\n\n/*\n * Arbitration Fairness\n */\nregister FAIRNESS {\n\taddress\t\t\t0x06C\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_SCSI\n}\n\n/*\n * 400-MHz Phase-Locked Loop Control 1\n */\nregister PLL400CTL1 {\n\taddress\t\t\t0x06D\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tPLL_CNTEN\t0x80\n\tfield\tPLL_CNTCLR\t0x40\n\tfield\tPLL_RST\t\t0x01\n}\n\n/*\n * Arbitration Unfairness\n */\nregister UNFAIRNESS {\n\taddress\t\t\t0x06E\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_SCSI\n}\n\n/*\n * 400-MHz Phase-Locked Loop Test Count\n */\nregister PLL400CNT0 {\n\taddress\t\t\t0x06E\n\taccess_mode\tRO\n\tsize\t\t2\n\tmodes\t\tM_CFG\n}\n\n/*\n * SCB Page Pointer\n */\nregister SCBPTR {\n\taddress\t\t\t0x0A8\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_DFF0, M_DFF1, M_CCHAN, M_SCSI\n\tdont_generate_debug_code\n}\n\n/*\n * CMC SCB Array Count\n * Number of bytes to transfer between CMC SCB memory and SCBRAM.\n * Transfers must be 8byte aligned and sized.\n */\nregister CCSCBACNT {\n\taddress\t\t\t0x0AB\n\taccess_mode\tRW\n\tmodes\t\tM_CCHAN\n}\n\n/*\n * SCB Autopointer\n * SCB-Next Address Snooping logic.  When an SCB is transferred to\n * the card, the next SCB address to be used by the CMC array can\n * be autoloaded from that transfer.\n */\nregister SCBAUTOPTR {\n\taddress\t\t\t0x0AB\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tfield\tAUSCBPTR_EN\t0x80\n\tfield\tSCBPTR_ADDR\t0x38\n\tfield\tSCBPTR_OFF\t0x07\n\tdont_generate_debug_code\n}\n\n/*\n * CMC SG Ram Address Pointer\n */\nregister CCSGADDR {\n\taddress\t\t\t0x0AC\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1\n\tdont_generate_debug_code\n}\n\n/*\n * CMC SCB RAM Address Pointer\n */\nregister CCSCBADDR {\n\taddress\t\t\t0x0AC\n\taccess_mode\tRW\n\tmodes\t\tM_CCHAN\n\tdont_generate_debug_code\n}\n\n/*\n * CMC SCB Ram Back-up Address Pointer\n * Indicates the true stop location of transfers halted prior\n * to SCBHCNT going to 0.\n */\nregister CCSCBADR_BK {\n\taddress\t\t\t0x0AC\n\taccess_mode\tRO\n\tmodes\t\tM_CFG\n}\n\n/*\n * CMC SG Control\n */\nregister CCSGCTL {\n\taddress\t\t\t0x0AD\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tCCSGDONE\t0x80\n\tfield\tSG_CACHE_AVAIL\t0x10\n\tfield\tCCSGENACK\t0x08\n\tmask\tCCSGEN\t\t0x0C\n\tfield\tSG_FETCH_REQ\t0x02\n\tfield\tCCSGRESET\t0x01\n}\n\n/*\n * CMD SCB Control\n */\nregister CCSCBCTL {\n\taddress\t\t\t0x0AD\n\taccess_mode\tRW\n\tmodes\t\tM_CCHAN\n\tfield\tCCSCBDONE\t0x80\n\tfield\tARRDONE\t\t0x40\n\tfield\tCCARREN\t\t0x10\n\tfield\tCCSCBEN\t\t0x08\n\tfield\tCCSCBDIR\t0x04\n\tfield\tCCSCBRESET\t0x01\n}\n\n/*\n * CMC Ram BIST\n */\nregister CMC_RAMBIST {\n\taddress\t\t\t0x0AD\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tSG_ELEMENT_SIZE\t\t0x80\n\tfield\tSCBRAMBIST_FAIL\t\t0x40\n\tfield\tSG_BIST_FAIL\t\t0x20\n\tfield\tSG_BIST_EN\t\t0x10\n\tfield\tCMC_BUFFER_BIST_FAIL\t0x02\n\tfield\tCMC_BUFFER_BIST_EN\t0x01\n}\n\n/*\n * CMC SG RAM Data Port\n */\nregister CCSGRAM {\n\taddress\t\t\t0x0B0\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1\n\tdont_generate_debug_code\n}\n\n/*\n * CMC SCB RAM Data Port\n */\nregister CCSCBRAM {\n\taddress\t\t\t0x0B0\n\taccess_mode\tRW\n\tmodes\t\tM_CCHAN\n\tdont_generate_debug_code\n}\n\n/*\n * Flex DMA Address.\n */\nregister FLEXADR {\n\taddress\t\t\t0x0B0\n\taccess_mode\tRW\n\tsize\t\t3\n\tmodes\t\tM_SCSI\n}\n\n/*\n * Flex DMA Byte Count\n */\nregister FLEXCNT {\n\taddress\t\t\t0x0B3\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_SCSI\n}\n\n/*\n * Flex DMA Status\n */\nregister FLEXDMASTAT {\n\taddress\t\t\t0x0B5\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tfield\tFLEXDMAERR\t0x02\n\tfield\tFLEXDMADONE\t0x01\n}\n\n/*\n * Flex DMA Data Port\n */\nregister FLEXDATA {\n\taddress\t\t\t0x0B6\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n}\n\n/*\n * Board Data\n */\nregister BRDDAT {\n\taddress\t\t\t0x0B8\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tcount\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * Board Control\n */\nregister BRDCTL {\n\taddress\t\t\t0x0B9\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tcount\t\t7\n\tfield\tFLXARBACK\t0x80\n\tfield\tFLXARBREQ\t0x40\n\tfield\tBRDADDR\t\t0x38\n\tfield\tBRDEN\t\t0x04\n\tfield\tBRDRW\t\t0x02\n\tfield\tBRDSTB\t\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * Serial EEPROM Address\n */\nregister SEEADR {\n\taddress\t\t\t0x0BA\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tcount\t\t4\n\tdont_generate_debug_code\n}\n\n/*\n * Serial EEPROM Data\n */\nregister SEEDAT {\n\taddress\t\t\t0x0BC\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_SCSI\n\tcount\t\t4\n\tdont_generate_debug_code\n}\n\n/*\n * Serial EEPROM Status\n */\nregister SEESTAT {\n\taddress\t\t\t0x0BE\n\taccess_mode\tRO\n\tmodes\t\tM_SCSI\n\tcount\t\t1\n\tfield\tINIT_DONE\t0x80\n\tfield\tSEEOPCODE\t0x70\n\tfield\tLDALTID_L\t0x08\n\tfield\tSEEARBACK\t0x04\n\tfield\tSEEBUSY\t\t0x02\n\tfield\tSEESTART\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * Serial EEPROM Control\n */\nregister SEECTL {\n\taddress\t\t\t0x0BE\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tcount\t\t4\n\tfield\tSEEOPCODE\t0x70 {\n\t\tSEEOP_ERASE\t0x70,\n\t\tSEEOP_READ\t0x60,\n\t\tSEEOP_WRITE\t0x50,\n\t/*\n\t * The following four commands use special\n\t * addresses for differentiation.\n\t */\n\t\tSEEOP_ERAL\t0x40\n\t}\n\tmask\tSEEOP_EWEN\t0x40\n\tmask\tSEEOP_WALL\t0x40\n\tmask\tSEEOP_EWDS\t0x40\n\tfield\tSEERST\t\t0x02\n\tfield\tSEESTART\t0x01\n\tdont_generate_debug_code\n}\n\nconst SEEOP_ERAL_ADDR\t0x80\nconst SEEOP_EWEN_ADDR\t0xC0\nconst SEEOP_WRAL_ADDR\t0x40\nconst SEEOP_EWDS_ADDR\t0x00\n\n/*\n * SCB Counter\n */\nregister SCBCNT {\n\taddress\t\t\t0x0BF\n\taccess_mode\tRW\n\tmodes\t\tM_SCSI\n\tdont_generate_debug_code\n}\n\n/*\n * Data FIFO Write Address\n * Pointer to the next QWD location to be written to the data FIFO.\n */\nregister DFWADDR {\n\taddress\t\t\t0x0C0\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_DFF0, M_DFF1\n\tdont_generate_debug_code\n}\n\n/*\n * DSP Filter Control\n */\nregister DSPFLTRCTL {\n\taddress\t\t\t0x0C0\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tFLTRDISABLE\t0x20\n\tfield\tEDGESENSE\t0x10\n\tfield\tDSPFCNTSEL\t0x0F\n}\n\n/*\n * DSP Data Channel Control\n */\nregister DSPDATACTL {\n\taddress\t\t\t0x0C1\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t3\n\tfield\tBYPASSENAB\t0x80\n\tfield\tDESQDIS\t\t0x10\n\tfield\tRCVROFFSTDIS\t0x04\n\tfield\tXMITOFFSTDIS\t0x02\n\tdont_generate_debug_code\n}\n\n/*\n * Data FIFO Read Address\n * Pointer to the next QWD location to be read from the data FIFO.\n */\nregister DFRADDR {\n\taddress\t\t\t0x0C2\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_DFF0, M_DFF1\n}\n\n/*\n * DSP REQ Control\n */\nregister DSPREQCTL {\n\taddress\t\t\t0x0C2\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tMANREQCTL\t0xC0\n\tfield\tMANREQDLY\t0x3F\n}\n\n/*\n * DSP ACK Control\n */\nregister DSPACKCTL {\n\taddress\t\t\t0x0C3\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tfield\tMANACKCTL\t0xC0\n\tfield\tMANACKDLY\t0x3F\n}\n\n/*\n * Data FIFO Data\n * Read/Write byte port into the data FIFO.  The read and write\n * FIFO pointers increment with each read and write respectively\n * to this port.\n */\nregister DFDAT {\n\taddress\t\t\t0x0C4\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1\n\tdont_generate_debug_code\n}\n\n/*\n * DSP Channel Select\n */\nregister DSPSELECT {\n\taddress\t\t\t0x0C4\n\taccess_mode\tRW\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tfield\tAUTOINCEN\t0x80\n\tfield\tDSPSEL\t\t0x1F\n\tdont_generate_debug_code\n}\n\nconst NUMDSPS 0x14\n\n/*\n * Write Bias Control\n */\nregister WRTBIASCTL {\n\taddress\t\t\t0x0C5\n\taccess_mode\tWO\n\tmodes\t\tM_CFG\n\tcount\t\t3\n\tfield\tAUTOXBCDIS\t0x80\n\tfield\tXMITMANVAL\t0x3F\n\tdont_generate_debug_code\n}\n\n/*\n * Currently the WRTBIASCTL is the same as the default.\n */\nconst WRTBIASCTL_HP_DEFAULT 0x0\n\n/*\n * Receiver Bias Control\n */\nregister RCVRBIOSCTL {\n\taddress\t\t\t0x0C6\n\taccess_mode\tWO\n\tmodes\t\tM_CFG\n\tfield\tAUTORBCDIS\t0x80\n\tfield\tRCVRMANVAL\t0x3F\n}\n\n/*\n * Write Bias Calculator\n */\nregister WRTBIASCALC {\n\taddress\t\t\t0x0C7\n\taccess_mode\tRO\n\tmodes\t\tM_CFG\n}\n\n/*\n * Data FIFO Pointers\n * Contains the byte offset from DFWADDR and DWRADDR to the current\n * FIFO write/read locations.\n */\nregister DFPTRS {\n\taddress\t\t\t0x0C8\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1\n}\n\n/*\n * Receiver Bias Calculator\n */\nregister RCVRBIASCALC {\n\taddress\t\t\t0x0C8\n\taccess_mode\tRO\n\tmodes\t\tM_CFG\n}\n\n/*\n * Data FIFO Backup Read Pointer\n * Contains the data FIFO address to be restored if the last\n * data accessed from the data FIFO was not transferred successfully.\n */\nregister DFBKPTR {\n\taddress\t\t\t0x0C9\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_DFF0, M_DFF1\n}\n\n/*\n * Skew Calculator\n */\nregister SKEWCALC {\n\taddress\t\t\t0x0C9\n\taccess_mode\tRO\n\tmodes\t\tM_CFG\n}\n\n/*\n * Data FIFO Debug Control\n */\nregister DFDBCTL {\n\taddress\t\t\t\t0x0CB\n\taccess_mode\tRW\n\tmodes\t\tM_DFF0, M_DFF1\n\tfield\tDFF_CIO_WR_RDY\t\t0x20\n\tfield\tDFF_CIO_RD_RDY\t\t0x10\n\tfield\tDFF_DIR_ERR\t\t0x08\n\tfield\tDFF_RAMBIST_FAIL\t0x04\n\tfield\tDFF_RAMBIST_DONE\t0x02\n\tfield\tDFF_RAMBIST_EN\t\t0x01\n}\n\n/*\n * Data FIFO Space Count\n * Number of FIFO locations that are free.\n */\nregister DFSCNT {\n\taddress\t\t\t0x0CC\n\taccess_mode\tRO\n\tsize\t\t2\n\tmodes\t\tM_DFF0, M_DFF1\n}\n\n/*\n * Data FIFO Byte Count\n * Number of filled FIFO locations.\n */\nregister DFBCNT {\n\taddress\t\t\t0x0CE\n\taccess_mode\tRO\n\tsize\t\t2\n\tmodes\t\tM_DFF0, M_DFF1\n}\n\n/*\n * Sequencer Program Overlay Address.\n * Low address must be written prior to high address.\n */\nregister OVLYADDR {\n\taddress\t\t\t0x0D4\n\tmodes\t\tM_SCSI\n\tsize\t\t2\n\taccess_mode\tRW\n}\n\n/*\n * Sequencer Control 0\n * Error detection mode, speed configuration,\n * single step, breakpoints and program load.\n */\nregister SEQCTL0 {\n\taddress\t\t\t0x0D6\n\taccess_mode\tRW\n\tcount\t\t11\n\tfield\tPERRORDIS\t0x80\n\tfield\tPAUSEDIS\t0x40\n\tfield\tFAILDIS\t\t0x20\n\tfield\tFASTMODE\t0x10\n\tfield\tBRKADRINTEN\t0x08\n\tfield\tSTEP\t\t0x04\n\tfield\tSEQRESET\t0x02\n\tfield\tLOADRAM\t\t0x01\n}\n\n/*\n * Sequencer Control 1\n * Instruction RAM Diagnostics\n */\nregister SEQCTL1 {\n\taddress\t\t\t0x0D7\n\taccess_mode RW\n\tfield\tOVRLAY_DATA_CHK\t0x08\n\tfield\tRAMBIST_DONE\t0x04\n\tfield\tRAMBIST_FAIL\t0x02\n\tfield\tRAMBIST_EN\t0x01\n}\n\n/*\n * Sequencer Flags\n * Zero and Carry state of the ALU.\n */\nregister FLAGS {\n\taddress\t\t\t0x0D8\n\taccess_mode \tRO\n\tcount\t\t23\n\tfield\tZERO\t\t0x02\n\tfield\tCARRY\t\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * Sequencer Interrupt Control\n */ \nregister SEQINTCTL {\n\taddress\t\t\t0x0D9\n\taccess_mode RW\n\tfield\tINTVEC1DSL\t0x80\n\tfield\tINT1_CONTEXT\t0x20\n\tfield\tSCS_SEQ_INT1M1\t0x10\n\tfield\tSCS_SEQ_INT1M0\t0x08\n\tfield\tINTMASK2\t0x04\n\tfield\tINTMASK1\t0x02\n\tfield\tIRET\t\t0x01\n}\n\n/*\n * Sequencer RAM Data Port\n * Single byte window into the Sequencer Instruction Ram area starting\n * at the address specified by OVLYADDR.  To write a full instruction word,\n * simply write four bytes in succession.  OVLYADDR will increment after the\n * most significant instrution byte (the byte with the parity bit) is written.\n */\nregister SEQRAM {\n\taddress\t\t\t0x0DA\n\taccess_mode \tRW\n\tcount\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * Sequencer Program Counter\n * Low byte must be written prior to high byte.\n */\nregister PRGMCNT {\n\taddress\t\t\t0x0DE\n\taccess_mode\tRW\n\tsize\t\t2\n\tcount\t\t5\n\tdont_generate_debug_code\n}\n\n/*\n * Accumulator\n */\nregister ACCUM {\n\taddress\t\t\t0x0E0\n\taccess_mode \tRW\n\taccumulator\n\tdont_generate_debug_code\n}\n\n/*\n * Source Index Register\n * Incrementing index for reads of SINDIR and the destination (low byte only)\n * for any immediate operands passed in jmp, jc, jnc, call instructions.\n * Example:\n *\t\tmvi\t0xFF\tcall some_routine;\n *\n *  Will set SINDEX[0] to 0xFF and call the routine \"some_routine.\n */\nregister SINDEX\t{\n\taddress\t\t\t0x0E2\n\taccess_mode\tRW\n\tsize\t\t2\n\tsindex\n\tdont_generate_debug_code\n}\n\n/*\n * Destination Index Register\n * Incrementing index for writes to DINDIR.  Can be used as a scratch register.\n */\nregister DINDEX {\n\taddress\t\t\t0x0E4\n\taccess_mode\tRW\n\tsize\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * Break Address\n * Sequencer instruction breakpoint address address.\n */\nregister BRKADDR0 {\n\taddress\t\t\t0x0E6\n\taccess_mode\tRW\n}\n\nregister BRKADDR1 {\n\taddress\t\t\t0x0E6\n\taccess_mode\tRW\n\tfield\tBRKDIS\t\t0x80\t/* Disable Breakpoint */\n}\n\n/*\n * All Ones\n * All reads to this register return the value 0xFF.\n */\nregister ALLONES {\n\taddress\t\t\t0x0E8\n\taccess_mode RO\n\tallones\n\tdont_generate_debug_code\n}\n\n/*\n * All Zeros\n * All reads to this register return the value 0.\n */\nregister ALLZEROS {\n\taddress\t\t\t0x0EA\n\taccess_mode RO\n\tallzeros\n\tdont_generate_debug_code\n}\n\n/*\n * No Destination\n * Writes to this register have no effect.\n */\nregister NONE {\n\taddress\t\t\t0x0EA\n\taccess_mode WO\n\tnone\n\tdont_generate_debug_code\n}\n\n/*\n * Source Index Indirect\n * Reading this register is equivalent to reading (register_base + SINDEX) and\n * incrementing SINDEX by 1.\n */\nregister SINDIR\t{\n\taddress\t\t\t0x0EC\n\taccess_mode RO\n\tdont_generate_debug_code\n}\n\n/*\n * Destination Index Indirect\n * Writing this register is equivalent to writing to (register_base + DINDEX)\n * and incrementing DINDEX by 1.\n */\nregister DINDIR\t {\n\taddress\t\t\t0x0ED\n\taccess_mode WO\n\tdont_generate_debug_code\n}\n\n/*\n * Function One\n * 2's complement to bit value conversion.  Write the 2's complement value\n * (0-7 only) to the top nibble and retrieve the bit indexed by that value\n * on the next read of this register. \n * Example:\n *\tWrite\t0x60\n *\tRead\t0x40\n */\nregister FUNCTION1 {\n\taddress\t\t\t0x0F0\n\taccess_mode RW\n}\n\n/*\n * Stack\n * Window into the stack.  Each stack location is 10 bits wide reported\n * low byte followed by high byte.  There are 8 stack locations.\n */\nregister STACK {\n\taddress\t\t\t0x0F2\n\taccess_mode RW\n\tdont_generate_debug_code\n}\n\n/*\n * Interrupt Vector 1 Address\n * Interrupt branch address for SCS SEQ_INT1 mode 0 and 1 interrupts.\n */\nregister INTVEC1_ADDR {\n\taddress\t\t\t0x0F4\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tdont_generate_debug_code\n}\n\n/*\n * Current Address\n * Address of the SEQRAM instruction currently executing instruction.\n */\nregister CURADDR {\n\taddress\t\t\t0x0F4\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_SCSI\n\tcount\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * Interrupt Vector 2 Address\n * Interrupt branch address for HST_SEQ_INT2 interrupts.\n */\nregister INTVEC2_ADDR {\n\taddress\t\t\t0x0F6\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_CFG\n\tcount\t\t1\n\tdont_generate_debug_code\n}\n\n/*\n * Last Address\n * Address of the SEQRAM instruction executed prior to the current instruction.\n */\nregister LASTADDR {\n\taddress\t\t\t0x0F6\n\taccess_mode\tRW\n\tsize\t\t2\n\tmodes\t\tM_SCSI\n}\n\nregister AHD_PCI_CONFIG_BASE {\n\taddress\t\t\t0x100\n\taccess_mode\tRW\n\tsize\t\t256\n\tmodes\t\tM_CFG\n}\n\n/* ---------------------- Scratch RAM Offsets ------------------------- */\nscratch_ram {\n\t/* Mode Specific */\n\taddress\t\t\t0x0A0\n\tsize\t8\n\tmodes\t0, 1, 2, 3\n\tREG0 {\n\t\tsize\t\t2\n\t\tdont_generate_debug_code\n\t}\n\tREG1 {\n\t\tsize\t\t2\n\t}\n\tREG_ISR {\n\t\tsize\t\t2\n\t\tdont_generate_debug_code\n\t}\n\tSG_STATE {\n\t\tsize\t\t1\n\t\tfield\tSEGS_AVAIL\t0x01\n\t\tfield\tLOADING_NEEDED\t0x02\n\t\tfield\tFETCH_INPROG\t0x04\n\t}\n\t/*\n\t * Track whether the transfer byte count for\n\t * the current data phase is odd.\n\t */\n\tDATA_COUNT_ODD {\n\t\tsize\t\t1\n\t}\n}\n\nscratch_ram {\n\t/* Mode Specific */\n\taddress\t\t\t0x0F8\n\tsize\t8\n\tmodes\t0, 1, 2, 3\n\tLONGJMP_ADDR {\n\t\tsize\t\t2\n\t\tdont_generate_debug_code\n\t}\n\tACCUM_SAVE {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n}\n\n\nscratch_ram {\n\taddress\t\t\t0x100\n\tsize\t128\n\tmodes\t0, 1, 2, 3\n\t/*\n\t * Per \"other-id\" execution queues.  We use an array of\n\t * tail pointers into lists of SCBs sorted by \"other-id\".\n\t * The execution head pointer threads the head SCBs for\n\t * each list.\n\t */\n\tWAITING_SCB_TAILS {\n\t\tsize\t\t32\n\t\tdont_generate_debug_code\n\t}\n\tWAITING_TID_HEAD {\n\t\tsize\t\t2\n\t\tdont_generate_debug_code\n\t}\n\tWAITING_TID_TAIL {\n\t\tsize\t\t2\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * SCBID of the next SCB in the new SCB queue.\n\t */\n\tNEXT_QUEUED_SCB_ADDR {\n\t\tsize\t\t4\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * head of list of SCBs that have\n\t * completed but have not been\n\t * put into the qoutfifo.\n\t */\n\tCOMPLETE_SCB_HEAD {\n\t\tsize\t\t2\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * The list of completed SCBs in\n\t * the active DMA.\n\t */\n\tCOMPLETE_SCB_DMAINPROG_HEAD {\n\t\tsize\t\t2\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * head of list of SCBs that have\n\t * completed but need to be uploaded\n\t * to the host prior to being completed.\n\t */\n\tCOMPLETE_DMA_SCB_HEAD {\n\t\tsize\t\t2\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * tail of list of SCBs that have\n\t * completed but need to be uploaded\n\t * to the host prior to being completed.\n\t */\n\tCOMPLETE_DMA_SCB_TAIL {\n\t\tsize\t\t2\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * head of list of SCBs that have\n\t * been uploaded to the host, but cannot\n\t * be completed until the QFREEZE is in\n\t * full effect (i.e. no selections pending).\n\t */\n\tCOMPLETE_ON_QFREEZE_HEAD {\n\t\tsize\t\t2\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * Counting semaphore to prevent new select-outs\n\t * The queue is frozen so long as the sequencer\n\t * and kernel freeze counts differ.\n\t */\n\tQFREEZE_COUNT {\n\t\tsize\t\t2\n\t}\n\tKERNEL_QFREEZE_COUNT {\n\t\tsize\t\t2\n\t}\n\t/*\n\t * Mode to restore on legacy idle loop exit.\n\t */\n\tSAVED_MODE {\n\t\tsize\t\t1\n\t}\n\t/*\n\t * Single byte buffer used to designate the type or message\n\t * to send to a target.\n\t */\n\tMSG_OUT {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\t/* Parameters for DMA Logic */\n\tDMAPARAMS {\n\t\tsize\t\t1\n\t\tcount\t\t8\n\t\tfield\tPRELOADEN\t0x80\n\t\tfield\tWIDEODD\t\t0x40\n\t\tfield\tSCSIEN\t\t0x20\n\t\tfield\tSDMAEN\t\t0x10\n\t\tfield\tSDMAENACK\t0x10\n\t\tfield\tHDMAEN\t\t0x08\n\t\tfield\tHDMAENACK\t0x08\n\t\tfield\tDIRECTION\t0x04\t/* Set indicates PCI->SCSI */\n\t\tfield\tFIFOFLUSH\t0x02\n\t\tfield\tFIFORESET\t0x01\n\t\tdont_generate_debug_code\n\t}\n\tSEQ_FLAGS {\n\t\tsize\t\t1\n\t\tfield\tNOT_IDENTIFIED\t\t0x80\n\t\tfield\tNO_CDB_SENT\t\t0x40\n\t\tfield\tTARGET_CMD_IS_TAGGED\t0x40\n\t\tfield\tDPHASE\t\t\t0x20\n\t\t/* Target flags */\n\t\tfield\tTARG_CMD_PENDING\t0x10\n\t\tfield\tCMDPHASE_PENDING\t0x08\n\t\tfield\tDPHASE_PENDING\t\t0x04\n\t\tfield\tSPHASE_PENDING\t\t0x02\n\t\tfield\tNO_DISCONNECT\t\t0x01\n\t}\n\t/*\n\t * Temporary storage for the\n\t * target/channel/lun of a\n\t * reconnecting target\n\t */\n\tSAVED_SCSIID {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\tSAVED_LUN {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * The last bus phase as seen by the sequencer. \n\t */\n\tLASTPHASE {\n\t\tsize\t\t1\n\t\tfield\tCDI\t\t0x80\n\t\tfield\tIOI\t\t0x40\n\t\tfield\tMSGI\t\t0x20\n\t\tfield\tP_BUSFREE\t0x01\n\t\tenum\tPHASE_MASK  CDO|IOO|MSGO {\n\t\t\tP_DATAOUT\t0x0,\n\t\t\tP_DATAIN\tIOO,\n\t\t\tP_DATAOUT_DT\tP_DATAOUT|MSGO,\n\t\t\tP_DATAIN_DT\tP_DATAIN|MSGO,\n\t\t\tP_COMMAND\tCDO,\n\t\t\tP_MESGOUT\tCDO|MSGO,\n\t\t\tP_STATUS\tCDO|IOO,\n\t\t\tP_MESGIN\tCDO|IOO|MSGO\n\t\t}\n\t}\n\t/*\n\t * Value to \"or\" into the SCBPTR[1] value to\n\t * indicate that an entry in the QINFIFO is valid.\n\t */\n\tQOUTFIFO_ENTRY_VALID_TAG {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * Kernel and sequencer offsets into the queue of\n\t * incoming target mode command descriptors.  The\n\t * queue is full when the KERNEL_TQINPOS == TQINPOS.\n\t */\n\tKERNEL_TQINPOS {\n\t\tsize\t\t1\n\t\tcount\t\t1\n\t\tdont_generate_debug_code\n\t}\n\tTQINPOS {\n\t\tsize\t\t1\n\t\tcount\t\t8\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * Base address of our shared data with the kernel driver in host\n\t * memory.  This includes the qoutfifo and target mode\n\t * incoming command queue.\n\t */\n\tSHARED_DATA_ADDR {\n\t\tsize\t\t4\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * Pointer to location in host memory for next\n\t * position in the qoutfifo.\n\t */\n\tQOUTFIFO_NEXT_ADDR {\n\t\tsize\t\t4\n\t\tdont_generate_debug_code\n\t}\n\tARG_1 {\n\t\tsize\t\t1\n\t\tmask\tSEND_MSG\t\t0x80\n\t\tmask\tSEND_SENSE\t\t0x40\n\t\tmask\tSEND_REJ\t\t0x20\n\t\tmask\tMSGOUT_PHASEMIS\t\t0x10\n\t\tmask\tEXIT_MSG_LOOP\t\t0x08\n\t\tmask\tCONT_MSG_LOOP_WRITE\t0x04\n\t\tmask\tCONT_MSG_LOOP_READ\t0x03\n\t\tmask\tCONT_MSG_LOOP_TARG\t0x02\n\t\talias\tRETURN_1\n\t\tdont_generate_debug_code\n\t}\n\tARG_2 {\n\t\tsize\t\t1\n\t\tcount\t\t1\n\t\talias\tRETURN_2\n\t\tdont_generate_debug_code\n\t}\n\n\t/*\n\t * Snapshot of MSG_OUT taken after each message is sent.\n\t */\n\tLAST_MSG {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\n\t/*\n\t * Sequences the kernel driver has okayed for us.  This allows\n\t * the driver to do things like prevent initiator or target\n\t * operations.\n\t */\n\tSCSISEQ_TEMPLATE {\n\t\tsize\t\t1\n\t\tcount\t\t7\n\t\tfield\tMANUALCTL\t0x40\n\t\tfield\tENSELI\t\t0x20\n\t\tfield\tENRSELI\t\t0x10\n\t\tfield\tMANUALP\t\t0x0C\n\t\tfield\tENAUTOATNP\t0x02\n\t\tfield\tALTSTIM\t\t0x01\n\t\tdont_generate_debug_code\n\t}\n\n\t/*\n\t * The initiator specified tag for this target mode transaction.\n\t */\n\tINITIATOR_TAG {\n\t\tsize\t\t1\n\t\tcount\t\t1\n\t\tdont_generate_debug_code\n\t}\n\n\tSEQ_FLAGS2 {\n\t\tsize\t\t1\n\t\tfield\tPENDING_MK_MESSAGE\t0x01\n\t\tfield\tTARGET_MSG_PENDING\t0x02\n\t\tfield\tSELECTOUT_QFROZEN\t0x04\n\t}\n\n\tALLOCFIFO_SCBPTR {\n\t\tsize\t\t2\n\t\tdont_generate_debug_code\n\t}\n\n\t/*\n\t * The maximum amount of time to wait, when interrupt coalescing\n\t * is enabled, before issuing a CMDCMPLT interrupt for a completed\n\t * command.\n\t */\n\tINT_COALESCING_TIMER {\n\t\tsize\t\t2\n\t\tdont_generate_debug_code\n\t}\n\n\t/*\n\t * The maximum number of commands to coalesce into a single interrupt.\n\t * Actually the 2's complement of that value to simplify sequencer\n\t * code.\n\t */\n\tINT_COALESCING_MAXCMDS {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\n\t/*\n\t * The minimum number of commands still outstanding required\n\t * to continue coalescing (2's complement of value).\n\t */\n\tINT_COALESCING_MINCMDS {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\n\t/*\n\t * Number of commands \"in-flight\".\n\t */\n\tCMDS_PENDING {\n\t\tsize\t\t2\n\t\tdont_generate_debug_code\n\t}\n\n\t/*\n\t * The count of commands that have been coalesced.\n\t */\n\tINT_COALESCING_CMDCOUNT {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\n\t/*\n\t * Since the HS_MAIBOX is self clearing, copy its contents to\n\t * this position in scratch ram every time it changes.\n\t */\n\tLOCAL_HS_MAILBOX {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * Target-mode CDB type to CDB length table used\n\t * in non-packetized operation.\n\t */\n\tCMDSIZE_TABLE {\n\t\tsize\t\t8\n\t\tcount\t\t8\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * When an SCB with the MK_MESSAGE flag is\n\t * queued to the controller, it cannot enter\n\t * the waiting for selection list until the\n\t * selections for any previously queued\n\t * commands to that target complete.  During\n\t * the wait, the MK_MESSAGE SCB is queued\n\t * here.\n\t */\n\tMK_MESSAGE_SCB {\n\t\tsize\t\t2\n\t}\n\t/*\n\t * Saved SCSIID of MK_MESSAGE_SCB to avoid\n\t * an extra SCBPTR operation when deciding\n\t * if the MK_MESSAGE_SCB can be run.\n\t */\n\tMK_MESSAGE_SCSIID {\n\t\tsize\t\t1\n\t}\n}\n\n/************************* Hardware SCB Definition ****************************/\nscb {\n\taddress\t\t\t0x180\n\tsize\t\t64\n\tmodes\t\t0, 1, 2, 3\n\tSCB_RESIDUAL_DATACNT {\n\t\tsize\t4\n\t\talias\tSCB_CDB_STORE\n\t\talias\tSCB_HOST_CDB_PTR\n\t\tdont_generate_debug_code\n\t}\n\tSCB_RESIDUAL_SGPTR {\n\t\tsize\t4\n\t\tfield\tSG_ADDR_MASK\t\t0xf8\t/* In the last byte */\n\t\tfield\tSG_OVERRUN_RESID\t0x02\t/* In the first byte */\n\t\tfield\tSG_LIST_NULL\t\t0x01\t/* In the first byte */\n\t\tdont_generate_debug_code\n\t}\n\tSCB_SCSI_STATUS {\n\t\tsize\t1\n\t\talias\tSCB_HOST_CDB_LEN\n\t\tdont_generate_debug_code\n\t}\n\tSCB_TARGET_PHASES {\n\t\tsize\t1\n\t\tdont_generate_debug_code\n\t}\n\tSCB_TARGET_DATA_DIR {\n\t\tsize\t1\n\t\tdont_generate_debug_code\n\t}\n\tSCB_TARGET_ITAG {\n\t\tsize\t1\n\t\tdont_generate_debug_code\n\t}\n\tSCB_SENSE_BUSADDR {\n\t\t/*\n\t\t * Only valid if CDB length is less than 13 bytes or\n\t\t * we are using a CDB pointer.  Otherwise contains\n\t\t * the last 4 bytes of embedded cdb information.\n\t\t */\n\t\tsize\t4\n\t\talias\tSCB_NEXT_COMPLETE\n\t\tdont_generate_debug_code\n\t}\n\tSCB_TAG {\n\t\talias\tSCB_FIFO_USE_COUNT\n\t\tsize\t2\n\t\tdont_generate_debug_code\n\t}\n\tSCB_CONTROL {\n\t\tsize\t1\n\t\tfield\tTARGET_SCB\t0x80\n\t\tfield\tDISCENB\t\t0x40\n\t\tfield\tTAG_ENB\t\t0x20\n\t\tfield\tMK_MESSAGE\t0x10\n\t\tfield\tSTATUS_RCVD\t0x08\n\t\tfield\tDISCONNECTED\t0x04\n\t\tfield\tSCB_TAG_TYPE\t0x03\n\t}\n\tSCB_SCSIID {\n\t\tsize\t1\n\t\tfield\tTID\t0xF0\n\t\tfield\tOID\t0x0F\n\t}\n\tSCB_LUN {\n\t\tsize\t1\n\t\tfield\tLID\t0xff\n\t\tdont_generate_debug_code\n\t}\n\tSCB_TASK_ATTRIBUTE {\n\t\tsize\t1\n\t\t/*\n\t\t * Overloaded field for non-packetized \n\t\t * ignore wide residue message handling.\n\t\t */\n\t\tfield\tSCB_XFERLEN_ODD\t0x01\n\t\tdont_generate_debug_code\n\t}\n\tSCB_CDB_LEN {\n\t\tsize\t1\n\t\tfield\tSCB_CDB_LEN_PTR\t0x80\t/* CDB in host memory */\n\t\tdont_generate_debug_code\n\t}\n\tSCB_TASK_MANAGEMENT {\n\t\tsize\t1\n\t\tdont_generate_debug_code\n\t}\n\tSCB_DATAPTR {\n\t\tsize\t8\n\t\tdont_generate_debug_code\n\t}\n\tSCB_DATACNT {\n\t\t/*\n\t\t * The last byte is really the high address bits for\n\t\t * the data address.\n\t\t */\n\t\tsize\t4\n\t\tfield\tSG_LAST_SEG\t\t0x80\t/* In the fourth byte */\n\t\tfield\tSG_HIGH_ADDR_BITS\t0x7F\t/* In the fourth byte */\n\t\tdont_generate_debug_code\n\t}\n\tSCB_SGPTR {\n\t\tsize\t4\n\t\tfield\tSG_STATUS_VALID\t0x04\t/* In the first byte */\n\t\tfield\tSG_FULL_RESID\t0x02\t/* In the first byte */\n\t\tfield\tSG_LIST_NULL\t0x01\t/* In the first byte */\n\t\tdont_generate_debug_code\n\t}\n\tSCB_BUSADDR {\n\t\tsize\t4\n\t\tdont_generate_debug_code\n\t}\n\tSCB_NEXT {\n\t\talias\tSCB_NEXT_SCB_BUSADDR\n\t\tsize\t2\n\t\tdont_generate_debug_code\n\t}\n\tSCB_NEXT2 {\n\t\tsize\t2\n\t\tdont_generate_debug_code\n\t}\n\tSCB_SPARE {\n\t\tsize\t8\n\t\talias\tSCB_PKT_LUN\n\t}\n\tSCB_DISCONNECTED_LISTS {\n\t\tsize\t8\n\t\tdont_generate_debug_code\n\t}\n}\n\n/*********************************** Constants ********************************/\nconst MK_MESSAGE_BIT_OFFSET\t4\nconst TID_SHIFT\t\t4\nconst TARGET_CMD_CMPLT\t0xfe\nconst INVALID_ADDR\t0x80\n#define SCB_LIST_NULL\t0xff\n#define QOUTFIFO_ENTRY_VALID_TOGGLE\t0x80\n\nconst CCSGADDR_MAX\t0x80\nconst CCSCBADDR_MAX\t0x80\nconst CCSGRAM_MAXSEGS\t16\n\n/* Selection Timeout Timer Constants */\nconst STIMESEL_SHIFT\t3\nconst STIMESEL_MIN\t0x18\nconst STIMESEL_BUG_ADJ\t0x8\n\n/* WDTR Message values */\nconst BUS_8_BIT\t\t\t0x00\nconst BUS_16_BIT\t\t0x01\nconst BUS_32_BIT\t\t0x02\n\n/* Offset maximums */\nconst MAX_OFFSET\t\t0xfe\nconst MAX_OFFSET_PACED\t\t0xfe\nconst MAX_OFFSET_PACED_BUG\t0x7f\n/*\n * Some 160 devices incorrectly accept 0xfe as a\n * sync offset, but will overrun this value.  Limit\n * to 0x7f for speed lower than U320 which will\n * avoid the persistent sync offset overruns.\n */\nconst MAX_OFFSET_NON_PACED\t0x7f\nconst HOST_MSG\t\t\t0xff\n\n/*\n * The size of our sense buffers.\n * Sense buffer mapping can be handled in either of two ways.\n * The first is to allocate a dmamap for each transaction.\n * Depending on the architecture, dmamaps can be costly. The\n * alternative is to statically map the buffers in much the same\n * way we handle our scatter gather lists.  The driver implements\n * the later.\n */\nconst AHD_SENSE_BUFSIZE\t\t256\n\n/* Target mode command processing constants */\nconst CMD_GROUP_CODE_SHIFT\t0x05\n\nconst STATUS_BUSY\t\t0x08\nconst STATUS_QUEUE_FULL\t\t0x28\nconst STATUS_PKT_SENSE\t\t0xFF\nconst TARGET_DATA_IN\t\t1\n\nconst SCB_TRANSFER_SIZE_FULL_LUN\t56\nconst SCB_TRANSFER_SIZE_1BYTE_LUN\t48\n/* PKT_OVERRUN_BUFSIZE must be a multiple of 256 less than 64K */\nconst PKT_OVERRUN_BUFSIZE\t512\n\n/*\n * Timer parameters.\n */\nconst AHD_TIMER_US_PER_TICK\t25\nconst AHD_TIMER_MAX_TICKS\t0xFFFF\nconst AHD_TIMER_MAX_US\t\t(AHD_TIMER_MAX_TICKS * AHD_TIMER_US_PER_TICK)\n\n/*\n * Downloaded (kernel inserted) constants\n */\nconst SG_PREFETCH_CNT download\nconst SG_PREFETCH_CNT_LIMIT download\nconst SG_PREFETCH_ALIGN_MASK download\nconst SG_PREFETCH_ADDR_MASK download\nconst SG_SIZEOF download\nconst PKT_OVERRUN_BUFOFFSET download\nconst SCB_TRANSFER_SIZE\tdownload\nconst CACHELINE_MASK download\n\n/*\n * BIOS SCB offsets\n */\nconst NVRAM_SCB_OFFSET\t0x2C\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}