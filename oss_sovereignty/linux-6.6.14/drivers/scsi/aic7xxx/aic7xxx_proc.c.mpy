{
  "module_name": "aic7xxx_proc.c",
  "hash_id": "cfde60d525b5306b5652a0bd49d0c96cfaa8973f49ad09aa4bac92559307380a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic7xxx_proc.c",
  "human_readable_source": " \n#include \"aic7xxx_osm.h\"\n#include \"aic7xxx_inline.h\"\n#include \"aic7xxx_93cx6.h\"\n\nstatic void\tahc_dump_target_state(struct ahc_softc *ahc,\n\t\t\t\t      struct seq_file *m,\n\t\t\t\t      u_int our_id, char channel,\n\t\t\t\t      u_int target_id, u_int target_offset);\nstatic void\tahc_dump_device_state(struct seq_file *m,\n\t\t\t\t      struct scsi_device *dev);\n\n \nstatic const struct {\n\tu_int period_factor;\n\tu_int period;\t \n} scsi_syncrates[] = {\n\t{ 0x08, 625 },\t \n\t{ 0x09, 1250 },\t \n\t{ 0x0a, 2500 },\t \n\t{ 0x0b, 3030 },\t \n\t{ 0x0c, 5000 }\t \n};\n\n \nstatic u_int\nahc_calc_syncsrate(u_int period_factor)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(scsi_syncrates); i++) {\n\n\t\tif (period_factor == scsi_syncrates[i].period_factor) {\n\t\t\t \n\t\t\treturn (100000000 / scsi_syncrates[i].period);\n\t\t}\n\t}\n\n\t \n\treturn (10000000 / (period_factor * 4 * 10));\n}\n\nstatic void\nahc_format_transinfo(struct seq_file *m, struct ahc_transinfo *tinfo)\n{\n\tu_int speed;\n\tu_int freq;\n\tu_int mb;\n\n\tspeed = 3300;\n\tfreq = 0;\n\tif (tinfo->offset != 0) {\n\t\tfreq = ahc_calc_syncsrate(tinfo->period);\n\t\tspeed = freq;\n\t}\n\tspeed *= (0x01 << tinfo->width);\n\tmb = speed / 1000;\n\tif (mb > 0)\n\t\tseq_printf(m, \"%d.%03dMB/s transfers\", mb, speed % 1000);\n\telse\n\t\tseq_printf(m, \"%dKB/s transfers\", speed);\n\n\tif (freq != 0) {\n\t\tseq_printf(m, \" (%d.%03dMHz%s, offset %d\",\n\t\t\t freq / 1000, freq % 1000,\n\t\t\t (tinfo->ppr_options & MSG_EXT_PPR_DT_REQ) != 0\n\t\t\t ? \" DT\" : \"\", tinfo->offset);\n\t}\n\n\tif (tinfo->width > 0) {\n\t\tif (freq != 0) {\n\t\t\tseq_puts(m, \", \");\n\t\t} else {\n\t\t\tseq_puts(m, \" (\");\n\t\t}\n\t\tseq_printf(m, \"%dbit)\", 8 * (0x01 << tinfo->width));\n\t} else if (freq != 0) {\n\t\tseq_putc(m, ')');\n\t}\n\tseq_putc(m, '\\n');\n}\n\nstatic void\nahc_dump_target_state(struct ahc_softc *ahc, struct seq_file *m,\n\t\t      u_int our_id, char channel, u_int target_id,\n\t\t      u_int target_offset)\n{\n\tstruct\tscsi_target *starget;\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\tahc_tmode_tstate *tstate;\n\tint\tlun;\n\n\ttinfo = ahc_fetch_transinfo(ahc, channel, our_id,\n\t\t\t\t    target_id, &tstate);\n\tif ((ahc->features & AHC_TWIN) != 0)\n\t\tseq_printf(m, \"Channel %c \", channel);\n\tseq_printf(m, \"Target %d Negotiation Settings\\n\", target_id);\n\tseq_puts(m, \"\\tUser: \");\n\tahc_format_transinfo(m, &tinfo->user);\n\tstarget = ahc->platform_data->starget[target_offset];\n\tif (!starget)\n\t\treturn;\n\n\tseq_puts(m, \"\\tGoal: \");\n\tahc_format_transinfo(m, &tinfo->goal);\n\tseq_puts(m, \"\\tCurr: \");\n\tahc_format_transinfo(m, &tinfo->curr);\n\n\tfor (lun = 0; lun < AHC_NUM_LUNS; lun++) {\n\t\tstruct scsi_device *sdev;\n\n\t\tsdev = scsi_device_lookup_by_target(starget, lun);\n\n\t\tif (sdev == NULL)\n\t\t\tcontinue;\n\n\t\tahc_dump_device_state(m, sdev);\n\t}\n}\n\nstatic void\nahc_dump_device_state(struct seq_file *m, struct scsi_device *sdev)\n{\n\tstruct ahc_linux_device *dev = scsi_transport_device_data(sdev);\n\n\tseq_printf(m, \"\\tChannel %c Target %d Lun %d Settings\\n\",\n\t\t  sdev->sdev_target->channel + 'A',\n\t\t   sdev->sdev_target->id, (u8)sdev->lun);\n\n\tseq_printf(m, \"\\t\\tCommands Queued %ld\\n\", dev->commands_issued);\n\tseq_printf(m, \"\\t\\tCommands Active %d\\n\", dev->active);\n\tseq_printf(m, \"\\t\\tCommand Openings %d\\n\", dev->openings);\n\tseq_printf(m, \"\\t\\tMax Tagged Openings %d\\n\", dev->maxtags);\n\tseq_printf(m, \"\\t\\tDevice Queue Frozen Count %d\\n\", dev->qfrozen);\n}\n\nint\nahc_proc_write_seeprom(struct Scsi_Host *shost, char *buffer, int length)\n{\n\tstruct\tahc_softc *ahc = *(struct ahc_softc **)shost->hostdata;\n\tstruct seeprom_descriptor sd;\n\tint have_seeprom;\n\tu_long s;\n\tint paused;\n\tint written;\n\n\t \n\twritten = -EINVAL;\n\tahc_lock(ahc, &s);\n\tpaused = ahc_is_paused(ahc);\n\tif (!paused)\n\t\tahc_pause(ahc);\n\n\tif (length != sizeof(struct seeprom_config)) {\n\t\tprintk(\"ahc_proc_write_seeprom: incorrect buffer size\\n\");\n\t\tgoto done;\n\t}\n\n\thave_seeprom = ahc_verify_cksum((struct seeprom_config*)buffer);\n\tif (have_seeprom == 0) {\n\t\tprintk(\"ahc_proc_write_seeprom: cksum verification failed\\n\");\n\t\tgoto done;\n\t}\n\n\tsd.sd_ahc = ahc;\n#if AHC_PCI_CONFIG > 0\n\tif ((ahc->chip & AHC_PCI) != 0) {\n\t\tsd.sd_control_offset = SEECTL;\n\t\tsd.sd_status_offset = SEECTL;\n\t\tsd.sd_dataout_offset = SEECTL;\n\t\tif (ahc->flags & AHC_LARGE_SEEPROM)\n\t\t\tsd.sd_chip = C56_66;\n\t\telse\n\t\t\tsd.sd_chip = C46;\n\t\tsd.sd_MS = SEEMS;\n\t\tsd.sd_RDY = SEERDY;\n\t\tsd.sd_CS = SEECS;\n\t\tsd.sd_CK = SEECK;\n\t\tsd.sd_DO = SEEDO;\n\t\tsd.sd_DI = SEEDI;\n\t\thave_seeprom = ahc_acquire_seeprom(ahc, &sd);\n\t} else\n#endif\n\tif ((ahc->chip & AHC_VL) != 0) {\n\t\tsd.sd_control_offset = SEECTL_2840;\n\t\tsd.sd_status_offset = STATUS_2840;\n\t\tsd.sd_dataout_offset = STATUS_2840;\n\t\tsd.sd_chip = C46;\n\t\tsd.sd_MS = 0;\n\t\tsd.sd_RDY = EEPROM_TF;\n\t\tsd.sd_CS = CS_2840;\n\t\tsd.sd_CK = CK_2840;\n\t\tsd.sd_DO = DO_2840;\n\t\tsd.sd_DI = DI_2840;\n\t\thave_seeprom = TRUE;\n\t} else {\n\t\tprintk(\"ahc_proc_write_seeprom: unsupported adapter type\\n\");\n\t\tgoto done;\n\t}\n\n\tif (!have_seeprom) {\n\t\tprintk(\"ahc_proc_write_seeprom: No Serial EEPROM\\n\");\n\t\tgoto done;\n\t} else {\n\t\tu_int start_addr;\n\n\t\tif (ahc->seep_config == NULL) {\n\t\t\tahc->seep_config = kmalloc(sizeof(*ahc->seep_config),\n\t\t\t\t\t\t   GFP_ATOMIC);\n\t\t\tif (ahc->seep_config == NULL) {\n\t\t\t\tprintk(\"aic7xxx: Unable to allocate serial \"\n\t\t\t\t       \"eeprom buffer.  Write failing\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tprintk(\"aic7xxx: Writing Serial EEPROM\\n\");\n\t\tstart_addr = 32 * (ahc->channel - 'A');\n\t\tahc_write_seeprom(&sd, (u_int16_t *)buffer, start_addr,\n\t\t\t\t  sizeof(struct seeprom_config)/2);\n\t\tahc_read_seeprom(&sd, (uint16_t *)ahc->seep_config,\n\t\t\t\t start_addr, sizeof(struct seeprom_config)/2);\n#if AHC_PCI_CONFIG > 0\n\t\tif ((ahc->chip & AHC_VL) == 0)\n\t\t\tahc_release_seeprom(&sd);\n#endif\n\t\twritten = length;\n\t}\n\ndone:\n\tif (!paused)\n\t\tahc_unpause(ahc);\n\tahc_unlock(ahc, &s);\n\treturn (written);\n}\n\n \nint\nahc_linux_show_info(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct\tahc_softc *ahc = *(struct ahc_softc **)shost->hostdata;\n\tchar\tahc_info[256];\n\tu_int\tmax_targ;\n\tu_int\ti;\n\n\tseq_printf(m, \"Adaptec AIC7xxx driver version: %s\\n\",\n\t\t  AIC7XXX_DRIVER_VERSION);\n\tseq_printf(m, \"%s\\n\", ahc->description);\n\tahc_controller_info(ahc, ahc_info);\n\tseq_printf(m, \"%s\\n\", ahc_info);\n\tseq_printf(m, \"Allocated SCBs: %d, SG List Length: %d\\n\\n\",\n\t\t  ahc->scb_data->numscbs, AHC_NSEG);\n\n\n\tif (ahc->seep_config == NULL)\n\t\tseq_puts(m, \"No Serial EEPROM\\n\");\n\telse {\n\t\tseq_puts(m, \"Serial EEPROM:\\n\");\n\t\tfor (i = 0; i < sizeof(*ahc->seep_config)/2; i++) {\n\t\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\t\tseq_putc(m, '\\n');\n\t\t\t}\n\t\t\tseq_printf(m, \"0x%.4x \",\n\t\t\t\t  ((uint16_t*)ahc->seep_config)[i]);\n\t\t}\n\t\tseq_putc(m, '\\n');\n\t}\n\tseq_putc(m, '\\n');\n\n\tmax_targ = 16;\n\tif ((ahc->features & (AHC_WIDE|AHC_TWIN)) == 0)\n\t\tmax_targ = 8;\n\n\tfor (i = 0; i < max_targ; i++) {\n\t\tu_int our_id;\n\t\tu_int target_id;\n\t\tchar channel;\n\n\t\tchannel = 'A';\n\t\tour_id = ahc->our_id;\n\t\ttarget_id = i;\n\t\tif (i > 7 && (ahc->features & AHC_TWIN) != 0) {\n\t\t\tchannel = 'B';\n\t\t\tour_id = ahc->our_id_b;\n\t\t\ttarget_id = i % 8;\n\t\t}\n\n\t\tahc_dump_target_state(ahc, m, our_id,\n\t\t\t\t      channel, target_id, i);\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}