{
  "module_name": "aic79xx_inline.h",
  "hash_id": "d119e7402a7d11434ae684240a8d4c39c00e352ec5b29162331e8946d527ea6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic79xx_inline.h",
  "human_readable_source": " \n\n#ifndef _AIC79XX_INLINE_H_\n#define _AIC79XX_INLINE_H_\n\n \nstatic inline char *ahd_name(struct ahd_softc *ahd);\n\nstatic inline char *ahd_name(struct ahd_softc *ahd)\n{\n\treturn (ahd->name);\n}\n\n \nstatic inline void ahd_known_modes(struct ahd_softc *ahd,\n\t\t\t\t     ahd_mode src, ahd_mode dst);\nstatic inline ahd_mode_state ahd_build_mode_state(struct ahd_softc *ahd,\n\t\t\t\t\t\t    ahd_mode src,\n\t\t\t\t\t\t    ahd_mode dst);\nstatic inline void ahd_extract_mode_state(struct ahd_softc *ahd,\n\t\t\t\t\t    ahd_mode_state state,\n\t\t\t\t\t    ahd_mode *src, ahd_mode *dst);\n\nvoid ahd_set_modes(struct ahd_softc *ahd, ahd_mode src,\n\t\t   ahd_mode dst);\nahd_mode_state ahd_save_modes(struct ahd_softc *ahd);\nvoid ahd_restore_modes(struct ahd_softc *ahd,\n\t\t       ahd_mode_state state);\nint  ahd_is_paused(struct ahd_softc *ahd);\nvoid ahd_pause(struct ahd_softc *ahd);\nvoid ahd_unpause(struct ahd_softc *ahd);\n\nstatic inline void\nahd_known_modes(struct ahd_softc *ahd, ahd_mode src, ahd_mode dst)\n{\n\tahd->src_mode = src;\n\tahd->dst_mode = dst;\n\tahd->saved_src_mode = src;\n\tahd->saved_dst_mode = dst;\n}\n\nstatic inline ahd_mode_state\nahd_build_mode_state(struct ahd_softc *ahd, ahd_mode src, ahd_mode dst)\n{\n\treturn ((src << SRC_MODE_SHIFT) | (dst << DST_MODE_SHIFT));\n}\n\nstatic inline void\nahd_extract_mode_state(struct ahd_softc *ahd, ahd_mode_state state,\n\t\t       ahd_mode *src, ahd_mode *dst)\n{\n\t*src = (state & SRC_MODE) >> SRC_MODE_SHIFT;\n\t*dst = (state & DST_MODE) >> DST_MODE_SHIFT;\n}\n\n \nvoid\t*ahd_sg_setup(struct ahd_softc *ahd, struct scb *scb,\n\t\t      void *sgptr, dma_addr_t addr,\n\t\t      bus_size_t len, int last);\n\n \nstatic inline size_t\tahd_sg_size(struct ahd_softc *ahd);\n\nvoid\tahd_sync_sglist(struct ahd_softc *ahd,\n\t\t\tstruct scb *scb, int op);\n\nstatic inline size_t ahd_sg_size(struct ahd_softc *ahd)\n{\n\tif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)\n\t\treturn (sizeof(struct ahd_dma64_seg));\n\treturn (sizeof(struct ahd_dma_seg));\n}\n\n \nstruct ahd_initiator_tinfo *\n\tahd_fetch_transinfo(struct ahd_softc *ahd,\n\t\t\t    char channel, u_int our_id,\n\t\t\t    u_int remote_id,\n\t\t\t    struct ahd_tmode_tstate **tstate);\nuint16_t\n\tahd_inw(struct ahd_softc *ahd, u_int port);\nvoid\tahd_outw(struct ahd_softc *ahd, u_int port,\n\t\t u_int value);\nuint32_t\n\tahd_inl(struct ahd_softc *ahd, u_int port);\nvoid\tahd_outl(struct ahd_softc *ahd, u_int port,\n\t\t uint32_t value);\nuint64_t\n\tahd_inq(struct ahd_softc *ahd, u_int port);\nvoid\tahd_outq(struct ahd_softc *ahd, u_int port,\n\t\t uint64_t value);\nu_int\tahd_get_scbptr(struct ahd_softc *ahd);\nvoid\tahd_set_scbptr(struct ahd_softc *ahd, u_int scbptr);\nu_int\tahd_inb_scbram(struct ahd_softc *ahd, u_int offset);\nu_int\tahd_inw_scbram(struct ahd_softc *ahd, u_int offset);\nstruct scb *\n\tahd_lookup_scb(struct ahd_softc *ahd, u_int tag);\nvoid\tahd_queue_scb(struct ahd_softc *ahd, struct scb *scb);\n\nstatic inline uint8_t *ahd_get_sense_buf(struct ahd_softc *ahd,\n\t\t\t\t\t  struct scb *scb);\nstatic inline uint32_t ahd_get_sense_bufaddr(struct ahd_softc *ahd,\n\t\t\t\t\t      struct scb *scb);\n\n#if 0  \n\n#define AHD_COPY_COL_IDX(dst, src)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tdst->hscb->scsiid = src->hscb->scsiid;\t\t\t\\\n\tdst->hscb->lun = src->hscb->lun;\t\t\t\\\n} while (0)\n\n#endif\n\nstatic inline uint8_t *\nahd_get_sense_buf(struct ahd_softc *ahd, struct scb *scb)\n{\n\treturn (scb->sense_data);\n}\n\nstatic inline uint32_t\nahd_get_sense_bufaddr(struct ahd_softc *ahd, struct scb *scb)\n{\n\treturn (scb->sense_busaddr);\n}\n\n \nint\tahd_intr(struct ahd_softc *ahd);\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}