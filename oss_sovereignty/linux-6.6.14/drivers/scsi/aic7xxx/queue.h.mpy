{
  "module_name": "queue.h",
  "hash_id": "bf5fc3f35efaaed2482fd9f240ee4cbdda112df2e27d7e13533c80df8b7db6ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/queue.h",
  "human_readable_source": " \n\n#ifndef _SYS_QUEUE_H_\n#define\t_SYS_QUEUE_H_\n\n \n\n \n#define\tSLIST_HEAD(name, type)\t\t\t\t\t\t\\\nstruct name {\t\t\t\t\t\t\t\t\\\n\tstruct type *slh_first;\t \t\t\t\\\n}\n\n#define\tSLIST_HEAD_INITIALIZER(head)\t\t\t\t\t\\\n\t{ NULL }\n \n#define\tSLIST_ENTRY(type)\t\t\t\t\t\t\\\nstruct {\t\t\t\t\t\t\t\t\\\n\tstruct type *sle_next;\t \t\t\t\\\n}\n \n \n#define\tSLIST_EMPTY(head)\t((head)->slh_first == NULL)\n\n#define\tSLIST_FIRST(head)\t((head)->slh_first)\n\n#define\tSLIST_FOREACH(var, head, field)\t\t\t\t\t\\\n\tfor ((var) = SLIST_FIRST((head));\t\t\t\t\\\n\t    (var);\t\t\t\t\t\t\t\\\n\t    (var) = SLIST_NEXT((var), field))\n\n#define\tSLIST_INIT(head) do {\t\t\t\t\t\t\\\n\tSLIST_FIRST((head)) = NULL;\t\t\t\t\t\\\n} while (0)\n\n#define\tSLIST_INSERT_AFTER(slistelm, elm, field) do {\t\t\t\\\n\tSLIST_NEXT((elm), field) = SLIST_NEXT((slistelm), field);\t\\\n\tSLIST_NEXT((slistelm), field) = (elm);\t\t\t\t\\\n} while (0)\n\n#define\tSLIST_INSERT_HEAD(head, elm, field) do {\t\t\t\\\n\tSLIST_NEXT((elm), field) = SLIST_FIRST((head));\t\t\t\\\n\tSLIST_FIRST((head)) = (elm);\t\t\t\t\t\\\n} while (0)\n\n#define\tSLIST_NEXT(elm, field)\t((elm)->field.sle_next)\n\n#define\tSLIST_REMOVE(head, elm, type, field) do {\t\t\t\\\n\tif (SLIST_FIRST((head)) == (elm)) {\t\t\t\t\\\n\t\tSLIST_REMOVE_HEAD((head), field);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\telse {\t\t\t\t\t\t\t\t\\\n\t\tstruct type *curelm = SLIST_FIRST((head));\t\t\\\n\t\twhile (SLIST_NEXT(curelm, field) != (elm))\t\t\\\n\t\t\tcurelm = SLIST_NEXT(curelm, field);\t\t\\\n\t\tSLIST_NEXT(curelm, field) =\t\t\t\t\\\n\t\t    SLIST_NEXT(SLIST_NEXT(curelm, field), field);\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define\tSLIST_REMOVE_HEAD(head, field) do {\t\t\t\t\\\n\tSLIST_FIRST((head)) = SLIST_NEXT(SLIST_FIRST((head)), field);\t\\\n} while (0)\n\n \n#define\tSTAILQ_HEAD(name, type)\t\t\t\t\t\t\\\nstruct name {\t\t\t\t\t\t\t\t\\\n\tstruct type *stqh_first; \t\t\t\\\n\tstruct type **stqh_last; \t\t\\\n}\n\n#define\tSTAILQ_HEAD_INITIALIZER(head)\t\t\t\t\t\\\n\t{ NULL, &(head).stqh_first }\n\n#define\tSTAILQ_ENTRY(type)\t\t\t\t\t\t\\\nstruct {\t\t\t\t\t\t\t\t\\\n\tstruct type *stqe_next;\t \t\t\t\\\n}\n\n \n#define\tSTAILQ_EMPTY(head)\t((head)->stqh_first == NULL)\n\n#define\tSTAILQ_FIRST(head)\t((head)->stqh_first)\n\n#define\tSTAILQ_FOREACH(var, head, field)\t\t\t\t\\\n\tfor((var) = STAILQ_FIRST((head));\t\t\t\t\\\n\t   (var);\t\t\t\t\t\t\t\\\n\t   (var) = STAILQ_NEXT((var), field))\n\n#define\tSTAILQ_INIT(head) do {\t\t\t\t\t\t\\\n\tSTAILQ_FIRST((head)) = NULL;\t\t\t\t\t\\\n\t(head)->stqh_last = &STAILQ_FIRST((head));\t\t\t\\\n} while (0)\n\n#define\tSTAILQ_INSERT_AFTER(head, tqelm, elm, field) do {\t\t\\\n\tif ((STAILQ_NEXT((elm), field) = STAILQ_NEXT((tqelm), field)) == NULL)\\\n\t\t(head)->stqh_last = &STAILQ_NEXT((elm), field);\t\t\\\n\tSTAILQ_NEXT((tqelm), field) = (elm);\t\t\t\t\\\n} while (0)\n\n#define\tSTAILQ_INSERT_HEAD(head, elm, field) do {\t\t\t\\\n\tif ((STAILQ_NEXT((elm), field) = STAILQ_FIRST((head))) == NULL)\t\\\n\t\t(head)->stqh_last = &STAILQ_NEXT((elm), field);\t\t\\\n\tSTAILQ_FIRST((head)) = (elm);\t\t\t\t\t\\\n} while (0)\n\n#define\tSTAILQ_INSERT_TAIL(head, elm, field) do {\t\t\t\\\n\tSTAILQ_NEXT((elm), field) = NULL;\t\t\t\t\\\n\tSTAILQ_LAST((head)) = (elm);\t\t\t\t\t\\\n\t(head)->stqh_last = &STAILQ_NEXT((elm), field);\t\t\t\\\n} while (0)\n\n#define\tSTAILQ_LAST(head)\t(*(head)->stqh_last)\n\n#define\tSTAILQ_NEXT(elm, field)\t((elm)->field.stqe_next)\n\n#define\tSTAILQ_REMOVE(head, elm, type, field) do {\t\t\t\\\n\tif (STAILQ_FIRST((head)) == (elm)) {\t\t\t\t\\\n\t\tSTAILQ_REMOVE_HEAD(head, field);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\telse {\t\t\t\t\t\t\t\t\\\n\t\tstruct type *curelm = STAILQ_FIRST((head));\t\t\\\n\t\twhile (STAILQ_NEXT(curelm, field) != (elm))\t\t\\\n\t\t\tcurelm = STAILQ_NEXT(curelm, field);\t\t\\\n\t\tif ((STAILQ_NEXT(curelm, field) =\t\t\t\\\n\t\t     STAILQ_NEXT(STAILQ_NEXT(curelm, field), field)) == NULL)\\\n\t\t\t(head)->stqh_last = &STAILQ_NEXT((curelm), field);\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define\tSTAILQ_REMOVE_HEAD(head, field) do {\t\t\t\t\\\n\tif ((STAILQ_FIRST((head)) =\t\t\t\t\t\\\n\t     STAILQ_NEXT(STAILQ_FIRST((head)), field)) == NULL)\t\t\\\n\t\t(head)->stqh_last = &STAILQ_FIRST((head));\t\t\\\n} while (0)\n\n#define\tSTAILQ_REMOVE_HEAD_UNTIL(head, elm, field) do {\t\t\t\\\n\tif ((STAILQ_FIRST((head)) = STAILQ_NEXT((elm), field)) == NULL)\t\\\n\t\t(head)->stqh_last = &STAILQ_FIRST((head));\t\t\\\n} while (0)\n\n \n#define\tBSD_LIST_HEAD(name, type)\t\t\t\t\t\\\nstruct name {\t\t\t\t\t\t\t\t\\\n\tstruct type *lh_first;\t \t\t\t\\\n}\n\n#define\tLIST_HEAD_INITIALIZER(head)\t\t\t\t\t\\\n\t{ NULL }\n\n#define\tLIST_ENTRY(type)\t\t\t\t\t\t\\\nstruct {\t\t\t\t\t\t\t\t\\\n\tstruct type *le_next;\t \t\t\t\\\n\tstruct type **le_prev;\t \t\\\n}\n\n \n\n#define\tLIST_EMPTY(head)\t((head)->lh_first == NULL)\n\n#define\tLIST_FIRST(head)\t((head)->lh_first)\n\n#define\tLIST_FOREACH(var, head, field)\t\t\t\t\t\\\n\tfor ((var) = LIST_FIRST((head));\t\t\t\t\\\n\t    (var);\t\t\t\t\t\t\t\\\n\t    (var) = LIST_NEXT((var), field))\n\n#define\tLIST_INIT(head) do {\t\t\t\t\t\t\\\n\tLIST_FIRST((head)) = NULL;\t\t\t\t\t\\\n} while (0)\n\n#define\tLIST_INSERT_AFTER(listelm, elm, field) do {\t\t\t\\\n\tif ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL)\\\n\t\tLIST_NEXT((listelm), field)->field.le_prev =\t\t\\\n\t\t    &LIST_NEXT((elm), field);\t\t\t\t\\\n\tLIST_NEXT((listelm), field) = (elm);\t\t\t\t\\\n\t(elm)->field.le_prev = &LIST_NEXT((listelm), field);\t\t\\\n} while (0)\n\n#define\tLIST_INSERT_BEFORE(listelm, elm, field) do {\t\t\t\\\n\t(elm)->field.le_prev = (listelm)->field.le_prev;\t\t\\\n\tLIST_NEXT((elm), field) = (listelm);\t\t\t\t\\\n\t*(listelm)->field.le_prev = (elm);\t\t\t\t\\\n\t(listelm)->field.le_prev = &LIST_NEXT((elm), field);\t\t\\\n} while (0)\n\n#define\tLIST_INSERT_HEAD(head, elm, field) do {\t\t\t\t\\\n\tif ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL)\t\\\n\t\tLIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field);\\\n\tLIST_FIRST((head)) = (elm);\t\t\t\t\t\\\n\t(elm)->field.le_prev = &LIST_FIRST((head));\t\t\t\\\n} while (0)\n\n#define\tLIST_NEXT(elm, field)\t((elm)->field.le_next)\n\n#define\tLIST_REMOVE(elm, field) do {\t\t\t\t\t\\\n\tif (LIST_NEXT((elm), field) != NULL)\t\t\t\t\\\n\t\tLIST_NEXT((elm), field)->field.le_prev = \t\t\\\n\t\t    (elm)->field.le_prev;\t\t\t\t\\\n\t*(elm)->field.le_prev = LIST_NEXT((elm), field);\t\t\\\n} while (0)\n\n \n#define\tTAILQ_HEAD(name, type)\t\t\t\t\t\t\\\nstruct name {\t\t\t\t\t\t\t\t\\\n\tstruct type *tqh_first;\t \t\t\t\\\n\tstruct type **tqh_last;\t \t\t\\\n}\n\n#define\tTAILQ_HEAD_INITIALIZER(head)\t\t\t\t\t\\\n\t{ NULL, &(head).tqh_first }\n\n#define\tTAILQ_ENTRY(type)\t\t\t\t\t\t\\\nstruct {\t\t\t\t\t\t\t\t\\\n\tstruct type *tqe_next;\t \t\t\t\\\n\tstruct type **tqe_prev;\t \t\\\n}\n\n \n#define\tTAILQ_EMPTY(head)\t((head)->tqh_first == NULL)\n\n#define\tTAILQ_FIRST(head)\t((head)->tqh_first)\n\n#define\tTAILQ_FOREACH(var, head, field)\t\t\t\t\t\\\n\tfor ((var) = TAILQ_FIRST((head));\t\t\t\t\\\n\t    (var);\t\t\t\t\t\t\t\\\n\t    (var) = TAILQ_NEXT((var), field))\n\n#define\tTAILQ_FOREACH_REVERSE(var, head, headname, field)\t\t\\\n\tfor ((var) = TAILQ_LAST((head), headname);\t\t\t\\\n\t    (var);\t\t\t\t\t\t\t\\\n\t    (var) = TAILQ_PREV((var), headname, field))\n\n#define\tTAILQ_INIT(head) do {\t\t\t\t\t\t\\\n\tTAILQ_FIRST((head)) = NULL;\t\t\t\t\t\\\n\t(head)->tqh_last = &TAILQ_FIRST((head));\t\t\t\\\n} while (0)\n\n#define\tTAILQ_INSERT_AFTER(head, listelm, elm, field) do {\t\t\\\n\tif ((TAILQ_NEXT((elm), field) = TAILQ_NEXT((listelm), field)) != NULL)\\\n\t\tTAILQ_NEXT((elm), field)->field.tqe_prev = \t\t\\\n\t\t    &TAILQ_NEXT((elm), field);\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t(head)->tqh_last = &TAILQ_NEXT((elm), field);\t\t\\\n\tTAILQ_NEXT((listelm), field) = (elm);\t\t\t\t\\\n\t(elm)->field.tqe_prev = &TAILQ_NEXT((listelm), field);\t\t\\\n} while (0)\n\n#define\tTAILQ_INSERT_BEFORE(listelm, elm, field) do {\t\t\t\\\n\t(elm)->field.tqe_prev = (listelm)->field.tqe_prev;\t\t\\\n\tTAILQ_NEXT((elm), field) = (listelm);\t\t\t\t\\\n\t*(listelm)->field.tqe_prev = (elm);\t\t\t\t\\\n\t(listelm)->field.tqe_prev = &TAILQ_NEXT((elm), field);\t\t\\\n} while (0)\n\n#define\tTAILQ_INSERT_HEAD(head, elm, field) do {\t\t\t\\\n\tif ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL)\t\\\n\t\tTAILQ_FIRST((head))->field.tqe_prev =\t\t\t\\\n\t\t    &TAILQ_NEXT((elm), field);\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t(head)->tqh_last = &TAILQ_NEXT((elm), field);\t\t\\\n\tTAILQ_FIRST((head)) = (elm);\t\t\t\t\t\\\n\t(elm)->field.tqe_prev = &TAILQ_FIRST((head));\t\t\t\\\n} while (0)\n\n#define\tTAILQ_INSERT_TAIL(head, elm, field) do {\t\t\t\\\n\tTAILQ_NEXT((elm), field) = NULL;\t\t\t\t\\\n\t(elm)->field.tqe_prev = (head)->tqh_last;\t\t\t\\\n\t*(head)->tqh_last = (elm);\t\t\t\t\t\\\n\t(head)->tqh_last = &TAILQ_NEXT((elm), field);\t\t\t\\\n} while (0)\n\n#define\tTAILQ_LAST(head, headname)\t\t\t\t\t\\\n\t(*(((struct headname *)((head)->tqh_last))->tqh_last))\n\n#define\tTAILQ_NEXT(elm, field) ((elm)->field.tqe_next)\n\n#define\tTAILQ_PREV(elm, headname, field)\t\t\t\t\\\n\t(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))\n\n#define\tTAILQ_REMOVE(head, elm, field) do {\t\t\t\t\\\n\tif ((TAILQ_NEXT((elm), field)) != NULL)\t\t\t\t\\\n\t\tTAILQ_NEXT((elm), field)->field.tqe_prev = \t\t\\\n\t\t    (elm)->field.tqe_prev;\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t(head)->tqh_last = (elm)->field.tqe_prev;\t\t\\\n\t*(elm)->field.tqe_prev = TAILQ_NEXT((elm), field);\t\t\\\n} while (0)\n\n \n#define\tCIRCLEQ_HEAD(name, type)\t\t\t\t\t\\\nstruct name {\t\t\t\t\t\t\t\t\\\n\tstruct type *cqh_first;\t\t \t\t\\\n\tstruct type *cqh_last;\t\t \t\t\\\n}\n\n#define\tCIRCLEQ_HEAD_INITIALIZER(head)\t\t\t\t\t\\\n\t{ (void *)&(head), (void *)&(head) }\n\n#define\tCIRCLEQ_ENTRY(type)\t\t\t\t\t\t\\\nstruct {\t\t\t\t\t\t\t\t\\\n\tstruct type *cqe_next;\t\t \t\t\\\n\tstruct type *cqe_prev;\t\t \t\t\\\n}\n\n \n#define\tCIRCLEQ_EMPTY(head)\t((head)->cqh_first == (void *)(head))\n\n#define\tCIRCLEQ_FIRST(head)\t((head)->cqh_first)\n\n#define\tCIRCLEQ_FOREACH(var, head, field)\t\t\t\t\\\n\tfor ((var) = CIRCLEQ_FIRST((head));\t\t\t\t\\\n\t    (var) != (void *)(head);\t\t\t\t\t\\\n\t    (var) = CIRCLEQ_NEXT((var), field))\n\n#define\tCIRCLEQ_FOREACH_REVERSE(var, head, field)\t\t\t\\\n\tfor ((var) = CIRCLEQ_LAST((head));\t\t\t\t\\\n\t    (var) != (void *)(head);\t\t\t\t\t\\\n\t    (var) = CIRCLEQ_PREV((var), field))\n\n#define\tCIRCLEQ_INIT(head) do {\t\t\t\t\t\t\\\n\tCIRCLEQ_FIRST((head)) = (void *)(head);\t\t\t\t\\\n\tCIRCLEQ_LAST((head)) = (void *)(head);\t\t\t\t\\\n} while (0)\n\n#define\tCIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do {\t\t\\\n\tCIRCLEQ_NEXT((elm), field) = CIRCLEQ_NEXT((listelm), field);\t\\\n\tCIRCLEQ_PREV((elm), field) = (listelm);\t\t\t\t\\\n\tif (CIRCLEQ_NEXT((listelm), field) == (void *)(head))\t\t\\\n\t\tCIRCLEQ_LAST((head)) = (elm);\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tCIRCLEQ_PREV(CIRCLEQ_NEXT((listelm), field), field) = (elm);\\\n\tCIRCLEQ_NEXT((listelm), field) = (elm);\t\t\t\t\\\n} while (0)\n\n#define\tCIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do {\t\t\\\n\tCIRCLEQ_NEXT((elm), field) = (listelm);\t\t\t\t\\\n\tCIRCLEQ_PREV((elm), field) = CIRCLEQ_PREV((listelm), field);\t\\\n\tif (CIRCLEQ_PREV((listelm), field) == (void *)(head))\t\t\\\n\t\tCIRCLEQ_FIRST((head)) = (elm);\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tCIRCLEQ_NEXT(CIRCLEQ_PREV((listelm), field), field) = (elm);\\\n\tCIRCLEQ_PREV((listelm), field) = (elm);\t\t\t\t\\\n} while (0)\n\n#define\tCIRCLEQ_INSERT_HEAD(head, elm, field) do {\t\t\t\\\n\tCIRCLEQ_NEXT((elm), field) = CIRCLEQ_FIRST((head));\t\t\\\n\tCIRCLEQ_PREV((elm), field) = (void *)(head);\t\t\t\\\n\tif (CIRCLEQ_LAST((head)) == (void *)(head))\t\t\t\\\n\t\tCIRCLEQ_LAST((head)) = (elm);\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tCIRCLEQ_PREV(CIRCLEQ_FIRST((head)), field) = (elm);\t\\\n\tCIRCLEQ_FIRST((head)) = (elm);\t\t\t\t\t\\\n} while (0)\n\n#define\tCIRCLEQ_INSERT_TAIL(head, elm, field) do {\t\t\t\\\n\tCIRCLEQ_NEXT((elm), field) = (void *)(head);\t\t\t\\\n\tCIRCLEQ_PREV((elm), field) = CIRCLEQ_LAST((head));\t\t\\\n\tif (CIRCLEQ_FIRST((head)) == (void *)(head))\t\t\t\\\n\t\tCIRCLEQ_FIRST((head)) = (elm);\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tCIRCLEQ_NEXT(CIRCLEQ_LAST((head)), field) = (elm);\t\\\n\tCIRCLEQ_LAST((head)) = (elm);\t\t\t\t\t\\\n} while (0)\n\n#define\tCIRCLEQ_LAST(head)\t((head)->cqh_last)\n\n#define\tCIRCLEQ_NEXT(elm,field)\t((elm)->field.cqe_next)\n\n#define\tCIRCLEQ_PREV(elm,field)\t((elm)->field.cqe_prev)\n\n#define\tCIRCLEQ_REMOVE(head, elm, field) do {\t\t\t\t\\\n\tif (CIRCLEQ_NEXT((elm), field) == (void *)(head))\t\t\\\n\t\tCIRCLEQ_LAST((head)) = CIRCLEQ_PREV((elm), field);\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tCIRCLEQ_PREV(CIRCLEQ_NEXT((elm), field), field) =\t\\\n\t\t    CIRCLEQ_PREV((elm), field);\t\t\t\t\\\n\tif (CIRCLEQ_PREV((elm), field) == (void *)(head))\t\t\\\n\t\tCIRCLEQ_FIRST((head)) = CIRCLEQ_NEXT((elm), field);\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tCIRCLEQ_NEXT(CIRCLEQ_PREV((elm), field), field) =\t\\\n\t\t    CIRCLEQ_NEXT((elm), field);\t\t\t\t\\\n} while (0)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}