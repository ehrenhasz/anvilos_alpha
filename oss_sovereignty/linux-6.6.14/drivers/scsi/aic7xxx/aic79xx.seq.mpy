{
  "module_name": "aic79xx.seq",
  "hash_id": "5ce8e0fe58f4d9e639d80da30b5285a3503b9273f47bc1a19d44e3d43cece434",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic79xx.seq",
  "human_readable_source": "/*\n * Adaptec U320 device driver firmware for Linux and FreeBSD.\n *\n * Copyright (c) 1994-2001, 2004 Justin T. Gibbs.\n * Copyright (c) 2000-2002 Adaptec Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions, and the following disclaimer,\n *    without modification.\n * 2. Redistributions in binary form must reproduce at minimum a disclaimer\n *    substantially similar to the \"NO WARRANTY\" disclaimer below\n *    (\"Disclaimer\") and any redistribution must be conditioned upon\n *    including a substantially similar Disclaimer requirement for further\n *    binary redistribution.\n * 3. Neither the names of the above-listed copyright holders nor the names\n *    of any contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * Alternatively, this software may be distributed under the terms of the\n * GNU General Public License (\"GPL\") version 2 as published by the Free\n * Software Foundation.\n *\n * NO WARRANTY\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGES.\n *\n * $FreeBSD$\n */\n\nVERSION = \"$Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#120 $\"\nPATCH_ARG_LIST = \"struct ahd_softc *ahd\"\nPREFIX = \"ahd_\"\n\n#include \"aic79xx.reg\"\n#include \"scsi_message.h\"\n\nrestart:\nif ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {\n\ttest\tSEQINTCODE, 0xFF jz idle_loop;\n\tSET_SEQINTCODE(NO_SEQINT)\n}\n\nidle_loop:\n\n\tif ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {\n\t\t/*\n\t\t * Convert ERROR status into a sequencer\n\t\t * interrupt to handle the case of an\n\t\t * interrupt collision on the hardware\n\t\t * setting of HWERR.\n\t\t */\n\t\ttest\tERROR, 0xFF jz no_error_set;\n\t\tSET_SEQINTCODE(SAW_HWERR)\nno_error_set:\n\t}\n\tSET_MODE(M_SCSI, M_SCSI)\n\ttest\tSCSISEQ0, ENSELO|ENARBO jnz idle_loop_checkbus;\n\ttest\tSEQ_FLAGS2, SELECTOUT_QFROZEN jz check_waiting_list;\n\t/*\n\t * If the kernel has caught up with us, thaw the queue.\n\t */\n\tmov\tA, KERNEL_QFREEZE_COUNT;\n\tcmp\tQFREEZE_COUNT, A jne check_frozen_completions;\n\tmov\tA, KERNEL_QFREEZE_COUNT[1];\n\tcmp\tQFREEZE_COUNT[1], A jne check_frozen_completions;\n\tand\tSEQ_FLAGS2, ~SELECTOUT_QFROZEN;\n\tjmp\tcheck_waiting_list;\ncheck_frozen_completions:\n\ttest\tSSTAT0, SELDO|SELINGO jnz idle_loop_checkbus;\nBEGIN_CRITICAL;\n\t/*\n\t * If we have completions stalled waiting for the qfreeze\n\t * to take effect, move them over to the complete_scb list\n\t * now that no selections are pending.\n\t */\n\tcmp\tCOMPLETE_ON_QFREEZE_HEAD[1],SCB_LIST_NULL je idle_loop_checkbus;\n\t/*\n\t * Find the end of the qfreeze list.  The first element has\n\t * to be treated specially.\n\t */\n\tbmov\tSCBPTR, COMPLETE_ON_QFREEZE_HEAD, 2;\n\tcmp \tSCB_NEXT_COMPLETE[1], SCB_LIST_NULL je join_lists;\n\t/*\n\t * Now the normal loop.\n\t */\n\tbmov\tSCBPTR, SCB_NEXT_COMPLETE, 2;\n\tcmp \tSCB_NEXT_COMPLETE[1], SCB_LIST_NULL jne . - 1;\njoin_lists:\n\tbmov\tSCB_NEXT_COMPLETE, COMPLETE_SCB_HEAD, 2;\n\tbmov\tCOMPLETE_SCB_HEAD, COMPLETE_ON_QFREEZE_HEAD, 2;\n\tmvi\tCOMPLETE_ON_QFREEZE_HEAD[1], SCB_LIST_NULL;\n\tjmp\tidle_loop_checkbus;\ncheck_waiting_list:\n\tcmp\tWAITING_TID_HEAD[1], SCB_LIST_NULL je idle_loop_checkbus;\n\t/*\n\t * ENSELO is cleared by a SELDO, so we must test for SELDO\n\t * one last time.\n\t */\n\ttest\tSSTAT0, SELDO jnz select_out;\n\tcall\tstart_selection;\nidle_loop_checkbus:\n\ttest\tSSTAT0, SELDO jnz select_out;\nEND_CRITICAL;\n\ttest\tSSTAT0, SELDI jnz select_in;\n\ttest\tSCSIPHASE, ~DATA_PHASE_MASK jz idle_loop_check_nonpackreq;\n\ttest\tSCSISIGO, ATNO jz idle_loop_check_nonpackreq;\n\tcall\tunexpected_nonpkt_phase_find_ctxt;\nidle_loop_check_nonpackreq:\n\ttest\tSSTAT2, NONPACKREQ jz . + 2;\n\tcall\tunexpected_nonpkt_phase_find_ctxt;\n\tif ((ahd->bugs & AHD_FAINT_LED_BUG) != 0) {\n\t\t/*\n\t\t * On Rev A. hardware, the busy LED is only\n\t\t * turned on automaically during selections\n\t\t * and re-selections.  Make the LED status\n\t\t * more useful by forcing it to be on so\n\t\t * long as one of our data FIFOs is active.\n\t\t */\n\t\tand\tA, FIFO0FREE|FIFO1FREE, DFFSTAT;\n\t\tcmp\tA, FIFO0FREE|FIFO1FREE jne . + 3;\n\t\tand\tSBLKCTL, ~DIAGLEDEN|DIAGLEDON;\n\t\tjmp\t. + 2;\n\t\tor\tSBLKCTL, DIAGLEDEN|DIAGLEDON;\n\t}\n\tcall\tidle_loop_gsfifo_in_scsi_mode;\n\tcall\tidle_loop_service_fifos;\n\tcall\tidle_loop_cchan;\n\tjmp\tidle_loop;\n\nidle_loop_gsfifo:\n\tSET_MODE(M_SCSI, M_SCSI)\nBEGIN_CRITICAL;\nidle_loop_gsfifo_in_scsi_mode:\n\ttest\tLQISTAT2, LQIGSAVAIL jz return;\n\t/*\n\t * We have received good status for this transaction.  There may\n\t * still be data in our FIFOs draining to the host.  Complete\n\t * the SCB only if all data has transferred to the host.\n\t */\ngood_status_IU_done:\n\tbmov\tSCBPTR, GSFIFO, 2;\n\tclr\tSCB_SCSI_STATUS;\n\t/*\n\t * If a command completed before an attempted task management\n\t * function completed, notify the host after disabling any\n\t * pending select-outs.\n\t */\n\ttest\tSCB_TASK_MANAGEMENT, 0xFF jz gsfifo_complete_normally;\n\ttest\tSSTAT0, SELDO|SELINGO jnz . + 2;\n\tand\tSCSISEQ0, ~ENSELO;\n\tSET_SEQINTCODE(TASKMGMT_CMD_CMPLT_OKAY)\ngsfifo_complete_normally:\n\tor\tSCB_CONTROL, STATUS_RCVD;\n\n\t/*\n\t * Since this status did not consume a FIFO, we have to\n\t * be a bit more dilligent in how we check for FIFOs pertaining\n\t * to this transaction.  There are two states that a FIFO still\n\t * transferring data may be in.\n\t *\n\t * 1) Configured and draining to the host, with a FIFO handler.\n\t * 2) Pending cfg4data, fifo not empty.\n\t *\n\t * Case 1 can be detected by noticing a non-zero FIFO active\n\t * count in the SCB.  In this case, we allow the routine servicing\n\t * the FIFO to complete the SCB.\n\t * \n\t * Case 2 implies either a pending or yet to occur save data\n\t * pointers for this same context in the other FIFO.  So, if\n\t * we detect case 1, we will properly defer the post of the SCB\n\t * and achieve the desired result.  The pending cfg4data will\n\t * notice that status has been received and complete the SCB.\n\t */\n\ttest\tSCB_FIFO_USE_COUNT, 0xFF jnz idle_loop_gsfifo_in_scsi_mode;\n\tcall\tcomplete;\nEND_CRITICAL;\n\tjmp\tidle_loop_gsfifo_in_scsi_mode;\n\nidle_loop_service_fifos:\n\tSET_MODE(M_DFF0, M_DFF0)\nBEGIN_CRITICAL;\n\ttest\tLONGJMP_ADDR[1], INVALID_ADDR jnz idle_loop_next_fifo;\n\tcall\tlongjmp;\nEND_CRITICAL;\nidle_loop_next_fifo:\n\tSET_MODE(M_DFF1, M_DFF1)\nBEGIN_CRITICAL;\n\ttest\tLONGJMP_ADDR[1], INVALID_ADDR jz longjmp;\nEND_CRITICAL;\nreturn:\n\tret;\n\nidle_loop_cchan:\n\tSET_MODE(M_CCHAN, M_CCHAN)\n\ttest\tQOFF_CTLSTA, HS_MAILBOX_ACT jz\ths_mailbox_empty;\n\tor\tQOFF_CTLSTA, HS_MAILBOX_ACT;\n\tmov\tLOCAL_HS_MAILBOX, HS_MAILBOX;\nhs_mailbox_empty:\nBEGIN_CRITICAL;\n\ttest\tCCSCBCTL, CCARREN|CCSCBEN jz scbdma_idle;\n\ttest\tCCSCBCTL, CCSCBDIR jnz fetch_new_scb_inprog;\n\ttest\tCCSCBCTL, CCSCBDONE jz return;\n\t/* FALLTHROUGH */\nscbdma_tohost_done:\n\ttest\tCCSCBCTL, CCARREN jz fill_qoutfifo_dmadone;\n\t/*\n\t * An SCB has been successfully uploaded to the host.\n\t * If the SCB was uploaded for some reason other than\n\t * bad SCSI status (currently only for underruns), we\n\t * queue the SCB for normal completion.  Otherwise, we\n\t * wait until any select-out activity has halted, and\n\t * then queue the completion.\n\t */\n\tand\tCCSCBCTL, ~(CCARREN|CCSCBEN);\n\tbmov\tCOMPLETE_DMA_SCB_HEAD, SCB_NEXT_COMPLETE, 2;\n\tcmp\tSCB_NEXT_COMPLETE[1], SCB_LIST_NULL jne . + 2;\n\tmvi\tCOMPLETE_DMA_SCB_TAIL[1], SCB_LIST_NULL;\n\ttest\tSCB_SCSI_STATUS, 0xff jz scbdma_queue_completion;\n\tbmov\tSCB_NEXT_COMPLETE, COMPLETE_ON_QFREEZE_HEAD, 2;\n\tbmov\tCOMPLETE_ON_QFREEZE_HEAD, SCBPTR, 2 ret;\nscbdma_queue_completion:\n\tbmov\tSCB_NEXT_COMPLETE, COMPLETE_SCB_HEAD, 2;\n\tbmov\tCOMPLETE_SCB_HEAD, SCBPTR, 2 ret;\nfill_qoutfifo_dmadone:\n\tand\tCCSCBCTL, ~(CCARREN|CCSCBEN);\n\tcall\tqoutfifo_updated;\n\tmvi\tCOMPLETE_SCB_DMAINPROG_HEAD[1], SCB_LIST_NULL;\n\tbmov\tQOUTFIFO_NEXT_ADDR, SCBHADDR, 4;\n\ttest\tQOFF_CTLSTA, SDSCB_ROLLOVR jz return;\n\tbmov\tQOUTFIFO_NEXT_ADDR, SHARED_DATA_ADDR, 4;\n\txor\tQOUTFIFO_ENTRY_VALID_TAG, QOUTFIFO_ENTRY_VALID_TOGGLE ret;\nEND_CRITICAL;\n\nqoutfifo_updated:\n\t/*\n\t * If there are more commands waiting to be dma'ed\n\t * to the host, always coalesce.  Otherwise honor the\n\t * host's wishes.\n\t */\n\tcmp\tCOMPLETE_DMA_SCB_HEAD[1], SCB_LIST_NULL jne coalesce_by_count;\n\tcmp\tCOMPLETE_SCB_HEAD[1], SCB_LIST_NULL jne coalesce_by_count;\n\ttest\tLOCAL_HS_MAILBOX, ENINT_COALESCE jz issue_cmdcmplt;\n\n\t/*\n\t * If we have relatively few commands outstanding, don't\n\t * bother waiting for another command to complete.\n\t */\n\ttest\tCMDS_PENDING[1], 0xFF jnz coalesce_by_count;\n\t/* Add -1 so that jnc means <= not just < */\n\tadd\tA, -1, INT_COALESCING_MINCMDS;\n\tadd\tNONE, A, CMDS_PENDING;\n\tjnc\tissue_cmdcmplt;\n\t\n\t/*\n\t * If coalescing, only coalesce up to the limit\n\t * provided by the host driver.\n\t */\ncoalesce_by_count:\n\tmov\tA, INT_COALESCING_MAXCMDS;\n\tadd\tNONE, A, INT_COALESCING_CMDCOUNT;\n\tjc\tissue_cmdcmplt;\n\t/*\n\t * If the timer is not currently active,\n\t * fire it up.\n\t */\n\ttest\tINTCTL, SWTMINTMASK jz return;\n\tbmov\tSWTIMER, INT_COALESCING_TIMER, 2;\n\tmvi\tCLRSEQINTSTAT, CLRSEQ_SWTMRTO;\n\tor\tINTCTL, SWTMINTEN|SWTIMER_START;\n\tand\tINTCTL, ~SWTMINTMASK ret;\n\nissue_cmdcmplt:\n\tmvi\tINTSTAT, CMDCMPLT;\n\tclr\tINT_COALESCING_CMDCOUNT;\n\tor\tINTCTL, SWTMINTMASK ret;\n\nBEGIN_CRITICAL;\nfetch_new_scb_inprog:\n\ttest\tCCSCBCTL, ARRDONE jz return;\nfetch_new_scb_done:\n\tand\tCCSCBCTL, ~(CCARREN|CCSCBEN);\n\tclr\tA;\n\tadd\tCMDS_PENDING, 1;\n\tadc\tCMDS_PENDING[1], A;\n\tif ((ahd->bugs & AHD_PKT_LUN_BUG) != 0) {\n\t\t/*\n\t\t * \"Short Luns\" are not placed into outgoing LQ\n\t\t * packets in the correct byte order.  Use a full\n\t\t * sized lun field instead and fill it with the\n\t\t * one byte of lun information we support.\n\t\t */\n\t\tmov\tSCB_PKT_LUN[6], SCB_LUN;\n\t}\n\t/*\n\t * The FIFO use count field is shared with the\n\t * tag set by the host so that our SCB dma engine\n\t * knows the correct location to store the SCB.\n\t * Set it to zero before processing the SCB.\n\t */\n\tclr\tSCB_FIFO_USE_COUNT;\n\t/* Update the next SCB address to download. */\n\tbmov\tNEXT_QUEUED_SCB_ADDR, SCB_NEXT_SCB_BUSADDR, 4;\n\t/*\n\t * NULL out the SCB links since these fields\n\t * occupy the same location as SCB_NEXT_SCB_BUSADDR.\n\t */\n\tmvi\tSCB_NEXT[1], SCB_LIST_NULL;\n\tmvi\tSCB_NEXT2[1], SCB_LIST_NULL;\n\t/* Increment our position in the QINFIFO. */\n\tmov\tNONE, SNSCB_QOFF;\n\n\t/*\n\t * Save SCBID of this SCB in REG0 since\n\t * SCBPTR will be clobbered during target\n\t * list updates.  We also record the SCB's\n\t * flags so that we can refer to them even\n\t * after SCBPTR has been changed.\n\t */\n\tbmov\tREG0, SCBPTR, 2;\n\tmov\tA, SCB_CONTROL;\n\n\t/*\n\t * Find the tail SCB of the execution queue\n\t * for this target.\n\t */\n\tshr\tSINDEX, 3, SCB_SCSIID;\n\tand\tSINDEX, ~0x1;\n\tmvi\tSINDEX[1], (WAITING_SCB_TAILS >> 8);\n\tbmov\tDINDEX, SINDEX, 2;\n\tbmov\tSCBPTR, SINDIR, 2;\n\n\t/*\n\t * Update the tail to point to the new SCB.\n\t */\n\tbmov\tDINDIR, REG0, 2;\n\n\t/*\n\t * If the queue was empty, queue this SCB as\n\t * the first for this target.\n\t */\n\tcmp\tSCBPTR[1], SCB_LIST_NULL je first_new_target_scb;\n\n\t/*\n\t * SCBs that want to send messages must always be\n\t * at the head of their per-target queue so that\n\t * ATN can be asserted even if the current\n\t * negotiation agreement is packetized.  If the\n\t * target queue is empty, the SCB can be queued\n\t * immediately.  If the queue is not empty, we must\n\t * wait for it to empty before entering this SCB\n\t * into the waiting for selection queue.  Otherwise\n\t * our batching and round-robin selection scheme \n\t * could allow commands to be queued out of order.\n\t * To simplify the implementation, we stop pulling\n\t * new commands from the host until the MK_MESSAGE\n\t * SCB can be queued to the waiting for selection\n\t * list.\n\t */\n\ttest\tA, MK_MESSAGE jz batch_scb; \n\n\t/*\n\t * If the last SCB is also a MK_MESSAGE SCB, then\n\t * order is preserved even if we batch.\n\t */\n\ttest\tSCB_CONTROL, MK_MESSAGE jz batch_scb; \n\n\t/*\n\t * Defer this SCB and stop fetching new SCBs until\n\t * it can be queued.  Since the SCB_SCSIID of the\n\t * tail SCB must be the same as that of the newly\n\t * queued SCB, there is no need to restore the SCBID\n\t * here.\n\t */\n\tor\tSEQ_FLAGS2, PENDING_MK_MESSAGE;\n\tbmov\tMK_MESSAGE_SCB, REG0, 2;\n\tmov\tMK_MESSAGE_SCSIID, SCB_SCSIID ret;\n\nbatch_scb:\n\t/*\n\t * Otherwise just update the previous tail SCB to\n\t * point to the new tail.\n\t */\n\tbmov\tSCB_NEXT, REG0, 2 ret;\n\nfirst_new_target_scb:\n\t/*\n\t * Append SCB to the tail of the waiting for\n\t * selection list.\n\t */\n\tcmp\tWAITING_TID_HEAD[1], SCB_LIST_NULL je first_new_scb;\n\tbmov\tSCBPTR, WAITING_TID_TAIL, 2;\n\tbmov\tSCB_NEXT2, REG0, 2;\n\tbmov\tWAITING_TID_TAIL, REG0, 2 ret;\nfirst_new_scb:\n\t/*\n\t * Whole list is empty, so the head of\n\t * the list must be initialized too.\n\t */\n\tbmov\tWAITING_TID_HEAD, REG0, 2;\n\tbmov\tWAITING_TID_TAIL, REG0, 2 ret;\nEND_CRITICAL;\n\nscbdma_idle:\n\t/*\n\t * Don't bother downloading new SCBs to execute\n\t * if select-outs are currently frozen or we have\n\t * a MK_MESSAGE SCB waiting to enter the queue.\n\t */\n\ttest\tSEQ_FLAGS2, SELECTOUT_QFROZEN|PENDING_MK_MESSAGE\n\t\tjnz scbdma_no_new_scbs;\nBEGIN_CRITICAL;\n\ttest\tQOFF_CTLSTA, NEW_SCB_AVAIL jnz fetch_new_scb;\nscbdma_no_new_scbs:\n\tcmp\tCOMPLETE_DMA_SCB_HEAD[1], SCB_LIST_NULL jne dma_complete_scb;\n\tcmp\tCOMPLETE_SCB_HEAD[1], SCB_LIST_NULL je return;\n\t/* FALLTHROUGH */\nfill_qoutfifo:\n\t/*\n\t * Keep track of the SCBs we are dmaing just\n\t * in case the DMA fails or is aborted.\n\t */\n\tbmov\tCOMPLETE_SCB_DMAINPROG_HEAD, COMPLETE_SCB_HEAD, 2;\n\tmvi\tCCSCBCTL, CCSCBRESET;\n\tbmov\tSCBHADDR, QOUTFIFO_NEXT_ADDR, 4;\n\tmov\tA, QOUTFIFO_NEXT_ADDR;\n\tbmov\tSCBPTR, COMPLETE_SCB_HEAD, 2;\nfill_qoutfifo_loop:\n\tbmov\tCCSCBRAM, SCBPTR, 2;\n\tmov\tCCSCBRAM, SCB_SGPTR[0];\n\tmov\tCCSCBRAM, QOUTFIFO_ENTRY_VALID_TAG;\n\tmov\tNONE, SDSCB_QOFF;\n\tinc\tINT_COALESCING_CMDCOUNT;\n\tadd\tCMDS_PENDING, -1;\n\tadc\tCMDS_PENDING[1], -1;\n\tcmp\tSCB_NEXT_COMPLETE[1], SCB_LIST_NULL je fill_qoutfifo_done;\n\tcmp\tCCSCBADDR, CCSCBADDR_MAX je fill_qoutfifo_done;\n\ttest\tQOFF_CTLSTA, SDSCB_ROLLOVR jnz fill_qoutfifo_done;\n\t/*\n\t * Don't cross an ADB or Cachline boundary when DMA'ing\n\t * completion entries.  In PCI mode, at least in 32/33\n\t * configurations, the SCB DMA engine may lose its place\n\t * in the data-stream should the target force a retry on\n\t * something other than an 8byte aligned boundary. In\n\t * PCI-X mode, we do this to avoid split transactions since\n\t * many chipsets seem to be unable to format proper split\n\t * completions to continue the data transfer.\n\t */\n\tadd\tSINDEX, A, CCSCBADDR;\n\ttest\tSINDEX, CACHELINE_MASK jz fill_qoutfifo_done;\n\tbmov\tSCBPTR, SCB_NEXT_COMPLETE, 2;\n\tjmp\tfill_qoutfifo_loop;\nfill_qoutfifo_done:\n\tmov\tSCBHCNT, CCSCBADDR;\n\tmvi\tCCSCBCTL, CCSCBEN|CCSCBRESET;\n\tbmov\tCOMPLETE_SCB_HEAD, SCB_NEXT_COMPLETE, 2;\n\tmvi\tSCB_NEXT_COMPLETE[1], SCB_LIST_NULL ret;\n\nfetch_new_scb:\n\tbmov\tSCBHADDR, NEXT_QUEUED_SCB_ADDR, 4;\n\tmvi\tCCARREN|CCSCBEN|CCSCBDIR|CCSCBRESET jmp dma_scb;\ndma_complete_scb:\n\tbmov\tSCBPTR, COMPLETE_DMA_SCB_HEAD, 2;\n\tbmov\tSCBHADDR, SCB_BUSADDR, 4;\n\tmvi\tCCARREN|CCSCBEN|CCSCBRESET jmp dma_scb;\n\n/*\n * Either post or fetch an SCB from host memory.  The caller\n * is responsible for polling for transfer completion.\n *\n * Prerequisits: Mode == M_CCHAN\n *\t\t SINDEX contains CCSCBCTL flags\n *\t\t SCBHADDR set to Host SCB address\n *\t\t SCBPTR set to SCB src location on \"push\" operations\n */\nSET_SRC_MODE\tM_CCHAN;\nSET_DST_MODE\tM_CCHAN;\ndma_scb:\n\tmvi\tSCBHCNT, SCB_TRANSFER_SIZE;\n\tmov\tCCSCBCTL, SINDEX ret;\n\nsetjmp:\n\t/*\n\t * At least on the A, a return in the same\n\t * instruction as the bmov results in a return\n\t * to the caller, not to the new address at the\n\t * top of the stack.  Since we want the latter\n\t * (we use setjmp to register a handler from an\n\t * interrupt context but not invoke that handler\n\t * until we return to our idle loop), use a\n\t * separate ret instruction.\n\t */\n\tbmov\tLONGJMP_ADDR, STACK, 2;\n\tret;\nsetjmp_inline:\n\tbmov\tLONGJMP_ADDR, STACK, 2;\nlongjmp:\n\tbmov\tSTACK, LONGJMP_ADDR, 2 ret;\nEND_CRITICAL;\n\n/*************************** Chip Bug Work Arounds ****************************/\n/*\n * Must disable interrupts when setting the mode pointer\n * register as an interrupt occurring mid update will\n * fail to store the new mode value for restoration on\n * an iret.\n */\nif ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {\nset_mode_work_around:\n\tmvi\tSEQINTCTL, INTVEC1DSL;\n\tmov\tMODE_PTR, SINDEX;\n\tclr\tSEQINTCTL ret;\n}\n\n\nif ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {\nset_seqint_work_around:\n\tmov\tSEQINTCODE, SINDEX;\n\tmvi\tSEQINTCODE, NO_SEQINT ret;\n}\n\n/************************ Packetized LongJmp Routines *************************/\nSET_SRC_MODE\tM_SCSI;\nSET_DST_MODE\tM_SCSI;\nstart_selection:\nBEGIN_CRITICAL;\n\tif ((ahd->bugs & AHD_SENT_SCB_UPDATE_BUG) != 0) {\n\t\t/*\n\t\t * Razor #494\n\t\t * Rev A hardware fails to update LAST/CURR/NEXTSCB\n\t\t * correctly after a packetized selection in several\n\t\t * situations:\n\t\t *\n\t\t * 1) If only one command existed in the queue, the\n\t\t *    LAST/CURR/NEXTSCB are unchanged.\n\t\t *\n\t\t * 2) In a non QAS, protocol allowed phase change,\n\t\t *    the queue is shifted 1 too far.  LASTSCB is\n\t\t *    the last SCB that was correctly processed.\n\t\t * \n\t\t * 3) In the QAS case, if the full list of commands\n\t\t *    was successfully sent, NEXTSCB is NULL and neither\n\t\t *    CURRSCB nor LASTSCB can be trusted.  We must\n\t\t *    manually walk the list counting MAXCMDCNT elements\n\t\t *    to find the last SCB that was sent correctly.\n\t\t *\n\t\t * To simplify the workaround for this bug in SELDO\n\t\t * handling, we initialize LASTSCB prior to enabling\n\t\t * selection so we can rely on it even for case #1 above.\n\t\t */\n\t\tbmov\tLASTSCB, WAITING_TID_HEAD, 2;\n\t}\n\tbmov\tCURRSCB, WAITING_TID_HEAD, 2;\n\tbmov\tSCBPTR, WAITING_TID_HEAD, 2;\n\tshr\tSELOID, 4, SCB_SCSIID;\n\t/*\n\t * If we want to send a message to the device, ensure\n\t * we are selecting with atn regardless of our packetized\n\t * agreement.  Since SPI4 only allows target reset or PPR\n\t * messages if this is a packetized connection, the change\n\t * to our negotiation table entry for this selection will\n\t * be cleared when the message is acted on.\n\t */\n\ttest\tSCB_CONTROL, MK_MESSAGE jz . + 3;\n\tmov\tNEGOADDR, SELOID;\n\tor\tNEGCONOPTS, ENAUTOATNO;\n\tor\tSCSISEQ0, ENSELO ret;\nEND_CRITICAL;\n\n/*\n * Allocate a FIFO for a non-packetized transaction.\n * In RevA hardware, both FIFOs must be free before we\n * can allocate a FIFO for a non-packetized transaction.\n */\nallocate_fifo_loop:\n\t/*\n\t * Do whatever work is required to free a FIFO.\n\t */\n\tcall\tidle_loop_service_fifos;\n\tSET_MODE(M_SCSI, M_SCSI)\nallocate_fifo:\n\tif ((ahd->bugs & AHD_NONPACKFIFO_BUG) != 0) {\n\t\tand\tA, FIFO0FREE|FIFO1FREE, DFFSTAT;\n\t\tcmp\tA, FIFO0FREE|FIFO1FREE jne allocate_fifo_loop;\n\t} else {\n\t\ttest\tDFFSTAT, FIFO1FREE jnz allocate_fifo1;\n\t\ttest\tDFFSTAT, FIFO0FREE jz allocate_fifo_loop;\n\t\tmvi\tDFFSTAT, B_CURRFIFO_0;\n\t\tSET_MODE(M_DFF0, M_DFF0)\n\t\tbmov\tSCBPTR, ALLOCFIFO_SCBPTR, 2 ret;\n\t}\nSET_SRC_MODE\tM_SCSI;\nSET_DST_MODE\tM_SCSI;\nallocate_fifo1:\n\tmvi\tDFFSTAT, CURRFIFO_1;\n\tSET_MODE(M_DFF1, M_DFF1)\n\tbmov\tSCBPTR, ALLOCFIFO_SCBPTR, 2 ret;\n\n/*\n * We have been reselected as an initiator\n * or selected as a target.\n */\nSET_SRC_MODE\tM_SCSI;\nSET_DST_MODE\tM_SCSI;\nselect_in:\n\tif ((ahd->bugs & AHD_FAINT_LED_BUG) != 0) {\n\t\t/*\n\t\t * On Rev A. hardware, the busy LED is only\n\t\t * turned on automaically during selections\n\t\t * and re-selections.  Make the LED status\n\t\t * more useful by forcing it to be on from\n\t\t * the point of selection until our idle\n\t\t * loop determines that neither of our FIFOs\n\t\t * are busy.  This handles the non-packetized\n\t\t * case nicely as we will not return to the\n\t\t * idle loop until the busfree at the end of\n\t\t * each transaction.\n\t\t */\n\t\tor\tSBLKCTL, DIAGLEDEN|DIAGLEDON;\n\t}\n\tif ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0) {\n\t\t/*\n\t\t * Test to ensure that the bus has not\n\t\t * already gone free prior to clearing\n\t\t * any stale busfree status.  This avoids\n\t\t * a window whereby a busfree just after\n\t\t * a selection could be missed.\n\t\t */\n\t\ttest\tSCSISIGI, BSYI jz . + 2;\n\t\tmvi\tCLRSINT1,CLRBUSFREE;\n\t\tor\tSIMODE1, ENBUSFREE;\n\t}\n\tor\tSXFRCTL0, SPIOEN;\n\tand\tSAVED_SCSIID, SELID_MASK, SELID;\n\tand\tA, OID, IOWNID;\n\tor\tSAVED_SCSIID, A;\n\tmvi\tCLRSINT0, CLRSELDI;\n\tjmp\tITloop;\n\n/*\n * We have successfully selected out.\n *\n * Clear SELDO.\n * Dequeue all SCBs sent from the waiting queue\n * Requeue all SCBs *not* sent to the tail of the waiting queue\n * Take Razor #494 into account for above.\n *\n * In Packetized Mode:\n *\tReturn to the idle loop.  Our interrupt handler will take\n *\tcare of any incoming L_Qs.\n *\n * In Non-Packetize Mode:\n *\tContinue to our normal state machine.\n */\nSET_SRC_MODE\tM_SCSI;\nSET_DST_MODE\tM_SCSI;\nselect_out:\nBEGIN_CRITICAL;\n\tif ((ahd->bugs & AHD_FAINT_LED_BUG) != 0) {\n\t\t/*\n\t\t * On Rev A. hardware, the busy LED is only\n\t\t * turned on automaically during selections\n\t\t * and re-selections.  Make the LED status\n\t\t * more useful by forcing it to be on from\n\t\t * the point of re-selection until our idle\n\t\t * loop determines that neither of our FIFOs\n\t\t * are busy.  This handles the non-packetized\n\t\t * case nicely as we will not return to the\n\t\t * idle loop until the busfree at the end of\n\t\t * each transaction.\n\t\t */\n\t\tor\tSBLKCTL, DIAGLEDEN|DIAGLEDON;\n\t}\n\t/* Clear out all SCBs that have been successfully sent. */\n\tif ((ahd->bugs & AHD_SENT_SCB_UPDATE_BUG) != 0) {\n\t\t/*\n\t\t * For packetized, the LQO manager clears ENSELO on\n\t\t * the assertion of SELDO.  If we are non-packetized,\n\t\t * LASTSCB and CURRSCB are accurate.\n\t\t */\n\t\ttest\tSCSISEQ0, ENSELO jnz use_lastscb;\n\n\t\t/*\n\t\t * The update is correct for LQOSTAT1 errors.  All\n\t\t * but LQOBUSFREE are handled by kernel interrupts.\n\t\t * If we see LQOBUSFREE, return to the idle loop.\n\t\t * Once we are out of the select_out critical section,\n\t\t * the kernel will cleanup the LQOBUSFREE and we will\n\t\t * eventually restart the selection if appropriate.\n\t\t */\n\t\ttest\tLQOSTAT1, LQOBUSFREE jnz idle_loop;\n\n\t\t/*\n\t\t * On a phase change oustside of packet boundaries,\n\t\t * LASTSCB points to the currently active SCB context\n\t\t * on the bus.\n\t\t */\n\t\ttest\tLQOSTAT2, LQOPHACHGOUTPKT jnz use_lastscb;\n\n\t\t/*\n\t\t * If the hardware has traversed the whole list, NEXTSCB\n\t\t * will be NULL, CURRSCB and LASTSCB cannot be trusted,\n\t\t * but MAXCMDCNT is accurate.  If we stop part way through\n\t\t * the list or only had one command to issue, NEXTSCB[1] is\n\t\t * not NULL and LASTSCB is the last command to go out.\n\t\t */\n\t\tcmp\tNEXTSCB[1], SCB_LIST_NULL jne use_lastscb;\n\n\t\t/*\n\t\t * Brute force walk.\n\t\t */\n\t\tbmov\tSCBPTR, WAITING_TID_HEAD, 2;\n\t\tmvi\tSEQINTCTL, INTVEC1DSL;\n\t\tmvi\tMODE_PTR, MK_MODE(M_CFG, M_CFG);\n\t\tmov\tA, MAXCMDCNT;\n\t\tmvi\tMODE_PTR, MK_MODE(M_SCSI, M_SCSI);\n\t\tclr\tSEQINTCTL;\nfind_lastscb_loop:\n\t\tdec\tA;\n\t\ttest\tA, 0xFF jz found_last_sent_scb;\n\t\tbmov\tSCBPTR, SCB_NEXT, 2;\n\t\tjmp\tfind_lastscb_loop;\nuse_lastscb:\n\t\tbmov\tSCBPTR, LASTSCB, 2;\nfound_last_sent_scb:\n\t\tbmov\tCURRSCB, SCBPTR, 2;\ncurscb_ww_done:\n\t} else {\n\t\tbmov\tSCBPTR, CURRSCB, 2;\n\t}\n\n\t/*\n\t * The whole list made it.  Clear our tail pointer to indicate\n\t * that the per-target selection queue is now empty.\n\t */\n\tcmp\tSCB_NEXT[1], SCB_LIST_NULL je select_out_clear_tail;\n\n\t/*\n\t * Requeue any SCBs not sent, to the tail of the waiting Q.\n\t * We know that neither the per-TID list nor the list of\n\t * TIDs is empty.  Use this knowledge to our advantage and\n\t * queue the remainder to the tail of the global execution\n\t * queue.\n\t */\n\tbmov\tREG0, SCB_NEXT, 2;\nselect_out_queue_remainder:\n\tbmov\tSCBPTR, WAITING_TID_TAIL, 2;\n\tbmov\tSCB_NEXT2, REG0, 2;\n\tbmov\tWAITING_TID_TAIL, REG0, 2;\n\tjmp\tselect_out_inc_tid_q;\n\nselect_out_clear_tail:\n\t/*\n\t * Queue any pending MK_MESSAGE SCB for this target now\n\t * that the queue is empty.\n\t */\n\ttest\tSEQ_FLAGS2, PENDING_MK_MESSAGE jz select_out_no_mk_message_scb;\n\tmov\tA, MK_MESSAGE_SCSIID;\n\tcmp\tSCB_SCSIID, A jne select_out_no_mk_message_scb;\n\tand\tSEQ_FLAGS2, ~PENDING_MK_MESSAGE;\n\tbmov\tREG0, MK_MESSAGE_SCB, 2;\n\tjmp select_out_queue_remainder;\n\nselect_out_no_mk_message_scb:\n\t/*\n\t * Clear this target's execution tail and increment the queue.\n\t */\n\tshr\tDINDEX, 3, SCB_SCSIID;\n\tor\tDINDEX, 1;\t/* Want only the second byte */\n\tmvi\tDINDEX[1], ((WAITING_SCB_TAILS) >> 8);\n\tmvi\tDINDIR, SCB_LIST_NULL;\nselect_out_inc_tid_q:\n\tbmov\tSCBPTR, WAITING_TID_HEAD, 2;\n\tbmov\tWAITING_TID_HEAD, SCB_NEXT2, 2;\n\tcmp\tWAITING_TID_HEAD[1], SCB_LIST_NULL jne . + 2;\n\tmvi\tWAITING_TID_TAIL[1], SCB_LIST_NULL;\n\tbmov\tSCBPTR, CURRSCB, 2;\n\tmvi\tCLRSINT0, CLRSELDO;\n\ttest\tLQOSTAT2, LQOPHACHGOUTPKT jnz unexpected_nonpkt_mode_cleared;\n\ttest\tLQOSTAT1, LQOPHACHGINPKT jnz unexpected_nonpkt_mode_cleared;\n\n\t/*\n\t * If this is a packetized connection, return to our\n\t * idle_loop and let our interrupt handler deal with\n\t * any connection setup/teardown issues.  The only\n\t * exceptions are the case of MK_MESSAGE and task management\n\t * SCBs.\n\t */\n\tif ((ahd->bugs & AHD_LQO_ATNO_BUG) != 0) {\n\t\t/*\n\t\t * In the A, the LQO manager transitions to LQOSTOP0 even if\n\t\t * we have selected out with ATN asserted and the target\n\t\t * REQs in a non-packet phase.\n\t\t */\n\t\ttest \tSCB_CONTROL, MK_MESSAGE jz select_out_no_message;\n\t\ttest\tSCSISIGO, ATNO jnz select_out_non_packetized;\nselect_out_no_message:\n\t}\n\ttest\tLQOSTAT2, LQOSTOP0 jz select_out_non_packetized;\n\ttest\tSCB_TASK_MANAGEMENT, 0xFF jz idle_loop;\n\tSET_SEQINTCODE(TASKMGMT_FUNC_COMPLETE)\n\tjmp\tidle_loop;\n\nselect_out_non_packetized:\n\t/* Non packetized request. */\n\tand     SCSISEQ0, ~ENSELO;\n\tif ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0) {\n\t\t/*\n\t\t * Test to ensure that the bus has not\n\t\t * already gone free prior to clearing\n\t\t * any stale busfree status.  This avoids\n\t\t * a window whereby a busfree just after\n\t\t * a selection could be missed.\n\t\t */\n\t\ttest\tSCSISIGI, BSYI jz . + 2;\n\t\tmvi\tCLRSINT1,CLRBUSFREE;\n\t\tor\tSIMODE1, ENBUSFREE;\n\t}\n\tmov\tSAVED_SCSIID, SCB_SCSIID;\n\tmov\tSAVED_LUN, SCB_LUN;\n\tmvi\tSEQ_FLAGS, NO_CDB_SENT;\nEND_CRITICAL;\n\tor\tSXFRCTL0, SPIOEN;\n\n\t/*\n\t * As soon as we get a successful selection, the target\n\t * should go into the message out phase since we have ATN\n\t * asserted.\n\t */\n\tmvi\tMSG_OUT, MSG_IDENTIFYFLAG;\n\n\t/*\n\t * Main loop for information transfer phases.  Wait for the\n\t * target to assert REQ before checking MSG, C/D and I/O for\n\t * the bus phase.\n\t */\nmesgin_phasemis:\nITloop:\n\tcall\tphase_lock;\n\n\tmov\tA, LASTPHASE;\n\n\ttest\tA, ~P_DATAIN_DT\tjz p_data;\n\tcmp\tA,P_COMMAND\tje p_command;\n\tcmp\tA,P_MESGOUT\tje p_mesgout;\n\tcmp\tA,P_STATUS\tje p_status;\n\tcmp\tA,P_MESGIN\tje p_mesgin;\n\n\tSET_SEQINTCODE(BAD_PHASE)\n\tjmp\tITloop;\t\t\t/* Try reading the bus again. */\n\n/*\n * Command phase.  Set up the DMA registers and let 'er rip.\n */\np_command:\n\ttest\tSEQ_FLAGS, NOT_IDENTIFIED jz p_command_okay;\n\tSET_SEQINTCODE(PROTO_VIOLATION)\np_command_okay:\n\ttest\tMODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1))\n\t\tjnz p_command_allocate_fifo;\n\t/*\n\t * Command retry.  Free our current FIFO and\n\t * re-allocate a FIFO so transfer state is\n\t * reset.\n\t */\nSET_SRC_MODE\tM_DFF1;\nSET_DST_MODE\tM_DFF1;\n\tmvi\tDFFSXFRCTL, RSTCHN|CLRSHCNT;\n\tSET_MODE(M_SCSI, M_SCSI)\np_command_allocate_fifo:\n\tbmov\tALLOCFIFO_SCBPTR, SCBPTR, 2;\n\tcall\tallocate_fifo;\nSET_SRC_MODE\tM_DFF1;\nSET_DST_MODE\tM_DFF1;\n\tadd\tNONE, -17, SCB_CDB_LEN;\n\tjnc\tp_command_embedded;\np_command_from_host:\n\tbmov\tHADDR[0], SCB_HOST_CDB_PTR, 9;\n\tmvi\tSG_CACHE_PRE, LAST_SEG;\n\tmvi\tDFCNTRL, (PRELOADEN|SCSIEN|HDMAEN);\n\tjmp\tp_command_xfer;\np_command_embedded:\n\tbmov\tSHCNT[0], SCB_CDB_LEN,  1;\n\tbmov\tDFDAT, SCB_CDB_STORE, 16; \n\tmvi\tDFCNTRL, SCSIEN;\np_command_xfer:\n\tand\tSEQ_FLAGS, ~NO_CDB_SENT;\n\tif ((ahd->features & AHD_FAST_CDB_DELIVERY) != 0) {\n\t\t/*\n\t\t * To speed up CDB delivery in Rev B, all CDB acks\n\t\t * are \"released\" to the output sync as soon as the\n\t\t * command phase starts.  There is only one problem\n\t\t * with this approach.  If the target changes phase\n\t\t * before all data are sent, we have left over acks\n\t\t * that can go out on the bus in a data phase.  Due\n\t\t * to other chip contraints, this only happens if\n\t\t * the target goes to data-in, but if the acks go\n\t\t * out before we can test SDONE, we'll think that\n\t\t * the transfer has completed successfully.  Work\n\t\t * around this by taking advantage of the 400ns or\n\t\t * 800ns dead time between command phase and the REQ\n\t\t * of the new phase.  If the transfer has completed\n\t\t * successfully, SCSIEN should fall *long* before we\n\t\t * see a phase change.  We thus treat any phasemiss\n\t\t * that occurs before SCSIEN falls as an incomplete\n\t\t * transfer.\n\t\t */\n\t\ttest\tSSTAT1, PHASEMIS jnz p_command_xfer_failed;\n\t\ttest\tDFCNTRL, SCSIEN jnz . - 1;\n\t} else {\n\t\ttest\tDFCNTRL, SCSIEN jnz .;\n\t}\n\t/*\n\t * DMA Channel automatically disabled.\n\t * Don't allow a data phase if the command\n\t * was not fully transferred.\n\t */\n\ttest\tSSTAT2, SDONE jnz ITloop;\np_command_xfer_failed:\n\tor\tSEQ_FLAGS, NO_CDB_SENT;\n\tjmp\tITloop;\n\n\n/*\n * Status phase.  Wait for the data byte to appear, then read it\n * and store it into the SCB.\n */\nSET_SRC_MODE\tM_SCSI;\nSET_DST_MODE\tM_SCSI;\np_status:\n\ttest\tSEQ_FLAGS,NOT_IDENTIFIED jnz mesgin_proto_violation;\np_status_okay:\n\tmov\tSCB_SCSI_STATUS, SCSIDAT;\n\tor\tSCB_CONTROL, STATUS_RCVD;\n\tjmp\tITloop;\n\n/*\n * Message out phase.  If MSG_OUT is MSG_IDENTIFYFLAG, build a full\n * indentify message sequence and send it to the target.  The host may\n * override this behavior by setting the MK_MESSAGE bit in the SCB\n * control byte.  This will cause us to interrupt the host and allow\n * it to handle the message phase completely on its own.  If the bit\n * associated with this target is set, we will also interrupt the host,\n * thereby allowing it to send a message on the next selection regardless\n * of the transaction being sent.\n * \n * If MSG_OUT is == HOST_MSG, also interrupt the host and take a message.\n * This is done to allow the host to send messages outside of an identify\n * sequence while protecting the seqencer from testing the MK_MESSAGE bit\n * on an SCB that might not be for the current nexus. (For example, a\n * BDR message in response to a bad reselection would leave us pointed to\n * an SCB that doesn't have anything to do with the current target).\n *\n * Otherwise, treat MSG_OUT as a 1 byte message to send (abort, abort tag,\n * bus device reset).\n *\n * When there are no messages to send, MSG_OUT should be set to MSG_NOOP,\n * in case the target decides to put us in this phase for some strange\n * reason.\n */\np_mesgout_retry:\n\t/* Turn on ATN for the retry */\n\tmvi\tSCSISIGO, ATNO;\np_mesgout:\n\tmov\tSINDEX, MSG_OUT;\n\tcmp\tSINDEX, MSG_IDENTIFYFLAG jne p_mesgout_from_host;\n\ttest\tSCB_CONTROL,MK_MESSAGE\tjnz host_message_loop;\np_mesgout_identify:\n\tor\tSINDEX, MSG_IDENTIFYFLAG|DISCENB, SCB_LUN;\n\ttest\tSCB_CONTROL, DISCENB jnz . + 2;\n\tand\tSINDEX, ~DISCENB;\n/*\n * Send a tag message if TAG_ENB is set in the SCB control block.\n * Use SCB_NONPACKET_TAG as the tag value.\n */\np_mesgout_tag:\n\ttest\tSCB_CONTROL,TAG_ENB jz  p_mesgout_onebyte;\n\tmov\tSCSIDAT, SINDEX;\t/* Send the identify message */\n\tcall\tphase_lock;\n\tcmp\tLASTPHASE, P_MESGOUT\tjne p_mesgout_done;\n\tand\tSCSIDAT,TAG_ENB|SCB_TAG_TYPE,SCB_CONTROL;\n\tcall\tphase_lock;\n\tcmp\tLASTPHASE, P_MESGOUT\tjne p_mesgout_done;\n\tmov\tSCBPTR jmp p_mesgout_onebyte;\n/*\n * Interrupt the driver, and allow it to handle this message\n * phase and any required retries.\n */\np_mesgout_from_host:\n\tcmp\tSINDEX, HOST_MSG\tjne p_mesgout_onebyte;\n\tjmp\thost_message_loop;\n\np_mesgout_onebyte:\n\tmvi\tCLRSINT1, CLRATNO;\n\tmov\tSCSIDAT, SINDEX;\n\n/*\n * If the next bus phase after ATN drops is message out, it means\n * that the target is requesting that the last message(s) be resent.\n */\n\tcall\tphase_lock;\n\tcmp\tLASTPHASE, P_MESGOUT\tje p_mesgout_retry;\n\np_mesgout_done:\n\tmvi\tCLRSINT1,CLRATNO;\t/* Be sure to turn ATNO off */\n\tmov\tLAST_MSG, MSG_OUT;\n\tmvi\tMSG_OUT, MSG_NOOP;\t/* No message left */\n\tjmp\tITloop;\n\n/*\n * Message in phase.  Bytes are read using Automatic PIO mode.\n */\np_mesgin:\n\t/* read the 1st message byte */\n\tmvi\tACCUM\t\tcall inb_first;\n\n\ttest\tA,MSG_IDENTIFYFLAG\tjnz mesgin_identify;\n\tcmp\tA,MSG_DISCONNECT\tje mesgin_disconnect;\n\tcmp\tA,MSG_SAVEDATAPOINTER\tje mesgin_sdptrs;\n\tcmp\tALLZEROS,A\t\tje mesgin_complete;\n\tcmp\tA,MSG_RESTOREPOINTERS\tje mesgin_rdptrs;\n\tcmp\tA,MSG_IGN_WIDE_RESIDUE\tje mesgin_ign_wide_residue;\n\tcmp\tA,MSG_NOOP\t\tje mesgin_done;\n\n/*\n * Pushed message loop to allow the kernel to\n * run it's own message state engine.  To avoid an\n * extra nop instruction after signaling the kernel,\n * we perform the phase_lock before checking to see\n * if we should exit the loop and skip the phase_lock\n * in the ITloop.  Performing back to back phase_locks\n * shouldn't hurt, but why do it twice...\n */\nhost_message_loop:\n\tcall\tphase_lock;\t/* Benign the first time through. */\n\tSET_SEQINTCODE(HOST_MSG_LOOP)\n\tcmp\tRETURN_1, EXIT_MSG_LOOP\tje ITloop;\n\tcmp\tRETURN_1, CONT_MSG_LOOP_WRITE\tjne . + 3;\n\tmov\tSCSIDAT, RETURN_2;\n\tjmp\thost_message_loop;\n\t/* Must be CONT_MSG_LOOP_READ */\n\tmov\tNONE, SCSIDAT;\t/* ACK Byte */\n\tjmp\thost_message_loop;\n\nmesgin_ign_wide_residue:\n\tmov\tSAVED_MODE, MODE_PTR;\n\tSET_MODE(M_SCSI, M_SCSI)\n\tshr\tNEGOADDR, 4, SAVED_SCSIID;\n\tmov\tA, NEGCONOPTS;\n\tRESTORE_MODE(SAVED_MODE)\n\ttest\tA, WIDEXFER jz mesgin_reject;\n\t/* Pull the residue byte */\n\tmvi\tREG0\tcall inb_next;\n\tcmp\tREG0, 0x01 jne mesgin_reject;\n\ttest\tSCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 2;\n\ttest\tSCB_TASK_ATTRIBUTE, SCB_XFERLEN_ODD jnz mesgin_done;\n\tSET_SEQINTCODE(IGN_WIDE_RES)\n\tjmp\tmesgin_done;\n\nmesgin_proto_violation:\n\tSET_SEQINTCODE(PROTO_VIOLATION)\n\tjmp\tmesgin_done;\nmesgin_reject:\n\tmvi\tMSG_MESSAGE_REJECT\tcall mk_mesg;\nmesgin_done:\n\tmov\tNONE,SCSIDAT;\t\t/*dummy read from latch to ACK*/\n\tjmp\tITloop;\n\n#define INDEX_DISC_LIST(scsiid, lun)\t\t\t\t\t\\\n\tand\tA, 0xC0, scsiid;\t\t\t\t\t\\\n\tor\tSCBPTR, A, lun;\t\t\t\t\t\t\\\n\tclr\tSCBPTR[1];\t\t\t\t\t\t\\\n\tand\tSINDEX, 0x30, scsiid;\t\t\t\t\t\\\n\tshr\tSINDEX, 3;\t/* Multiply by 2 */\t\t\t\\\n\tadd\tSINDEX, (SCB_DISCONNECTED_LISTS & 0xFF);\t\t\\\n\tmvi\tSINDEX[1], ((SCB_DISCONNECTED_LISTS >> 8) & 0xFF)\n\nmesgin_identify:\n\t/*\n\t * Determine whether a target is using tagged or non-tagged\n\t * transactions by first looking at the transaction stored in\n\t * the per-device, disconnected array.  If there is no untagged\n\t * transaction for this target, this must be a tagged transaction.\n\t */\n\tand\tSAVED_LUN, MSG_IDENTIFY_LUNMASK, A;\n\tINDEX_DISC_LIST(SAVED_SCSIID, SAVED_LUN);\n\tbmov\tDINDEX, SINDEX, 2;\n\tbmov\tREG0, SINDIR, 2;\n\tcmp\tREG0[1], SCB_LIST_NULL je snoop_tag;\n\t/* Untagged.  Clear the busy table entry and setup the SCB. */\n\tbmov\tDINDIR, ALLONES, 2;\n\tbmov\tSCBPTR, REG0, 2;\n\tjmp\tsetup_SCB;\n\n/*\n * Here we \"snoop\" the bus looking for a SIMPLE QUEUE TAG message.\n * If we get one, we use the tag returned to find the proper\n * SCB.  After receiving the tag, look for the SCB at SCB locations tag and\n * tag + 256.\n */\nsnoop_tag:\n\tif ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {\n\t\tor\tSEQ_FLAGS, 0x80;\n\t}\n\tmov\tNONE, SCSIDAT;\t\t/* ACK Identify MSG */\n\tcall\tphase_lock;\n\tif ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {\n\t\tor\tSEQ_FLAGS, 0x1;\n\t}\n\tcmp\tLASTPHASE, P_MESGIN\tjne not_found_ITloop;\n\tif ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {\n\t\tor\tSEQ_FLAGS, 0x2;\n\t}\n\tcmp\tSCSIBUS, MSG_SIMPLE_Q_TAG jne not_found;\nget_tag:\n\tclr\tSCBPTR[1];\n\tmvi\tSCBPTR\tcall inb_next;\t/* tag value */\nverify_scb:\n\ttest\tSCB_CONTROL,DISCONNECTED jz verify_other_scb;\n\tmov\tA, SAVED_SCSIID;\n\tcmp\tSCB_SCSIID, A jne verify_other_scb;\n\tmov\tA, SAVED_LUN;\n\tcmp\tSCB_LUN, A je setup_SCB_disconnected;\nverify_other_scb:\n\txor\tSCBPTR[1], 1;\n\ttest\tSCBPTR[1], 0xFF jnz verify_scb;\n\tjmp\tnot_found;\n\n/*\n * Ensure that the SCB the tag points to is for\n * an SCB transaction to the reconnecting target.\n */\nsetup_SCB:\n\tif ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {\n\t\tor\tSEQ_FLAGS, 0x10;\n\t}\n\ttest\tSCB_CONTROL,DISCONNECTED jz not_found;\nsetup_SCB_disconnected:\n\tand\tSCB_CONTROL,~DISCONNECTED;\n\tclr\tSEQ_FLAGS;\t/* make note of IDENTIFY */\n\ttest\tSCB_SGPTR, SG_LIST_NULL jnz . + 3;\n\tbmov\tALLOCFIFO_SCBPTR, SCBPTR, 2;\n\tcall\tallocate_fifo;\n\t/* See if the host wants to send a message upon reconnection */\n\ttest\tSCB_CONTROL, MK_MESSAGE jz mesgin_done;\n\tmvi\tHOST_MSG\tcall mk_mesg;\n\tjmp\tmesgin_done;\n\nnot_found:\n\tSET_SEQINTCODE(NO_MATCH)\n\tjmp\tmesgin_done;\n\nnot_found_ITloop:\n\tSET_SEQINTCODE(NO_MATCH)\n\tjmp\tITloop;\n\n/*\n * We received a \"command complete\" message.  Put the SCB on the complete\n * queue and trigger a completion interrupt via the idle loop.  Before doing\n * so, check to see if there is a residual or the status byte is something\n * other than STATUS_GOOD (0).  In either of these conditions, we upload the\n * SCB back to the host so it can process this information.\n */\nmesgin_complete:\n\n\t/*\n\t * If ATN is raised, we still want to give the target a message.\n\t * Perhaps there was a parity error on this last message byte.\n\t * Either way, the target should take us to message out phase\n\t * and then attempt to complete the command again.  We should use a\n\t * critical section here to guard against a timeout triggering\n\t * for this command and setting ATN while we are still processing\n\t * the completion.\n\ttest\tSCSISIGI, ATNI jnz mesgin_done;\n\t */\n\n\t/*\n\t * If we are identified and have successfully sent the CDB,\n\t * any status will do.  Optimize this fast path.\n\t */\n\ttest\tSCB_CONTROL, STATUS_RCVD jz mesgin_proto_violation;\n\ttest\tSEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT jz complete_accepted;\n\n\t/*\n\t * If the target never sent an identify message but instead went\n\t * to mesgin to give an invalid message, let the host abort us.\n\t */\n\ttest\tSEQ_FLAGS, NOT_IDENTIFIED jnz mesgin_proto_violation;\n\n\t/*\n\t * If we recevied good status but never successfully sent the\n\t * cdb, abort the command.\n\t */\n\ttest\tSCB_SCSI_STATUS,0xff\tjnz complete_accepted;\n\ttest\tSEQ_FLAGS, NO_CDB_SENT jnz mesgin_proto_violation;\ncomplete_accepted:\n\n\t/*\n\t * See if we attempted to deliver a message but the target ingnored us.\n\t */\n\ttest\tSCB_CONTROL, MK_MESSAGE jz complete_nomsg;\n\tSET_SEQINTCODE(MKMSG_FAILED)\ncomplete_nomsg:\n\tcall\tqueue_scb_completion;\n\tjmp\tawait_busfree;\n\nBEGIN_CRITICAL;\nfreeze_queue:\n\t/* Cancel any pending select-out. */\n\ttest\tSSTAT0, SELDO|SELINGO jnz . + 2;\n\tand\tSCSISEQ0, ~ENSELO;\n\tmov\tACCUM_SAVE, A;\n\tclr\tA;\n\tadd\tQFREEZE_COUNT, 1;\n\tadc\tQFREEZE_COUNT[1], A;\n\tor\tSEQ_FLAGS2, SELECTOUT_QFROZEN;\n\tmov\tA, ACCUM_SAVE ret;\nEND_CRITICAL;\n\n/*\n * Complete the current FIFO's SCB if data for this same\n * SCB is not transferring in the other FIFO.\n */\nSET_SRC_MODE\tM_DFF1;\nSET_DST_MODE\tM_DFF1;\npkt_complete_scb_if_fifos_idle:\n\tbmov\tARG_1, SCBPTR, 2;\n\tmvi\tDFFSXFRCTL, CLRCHN;\n\tSET_MODE(M_SCSI, M_SCSI)\n\tbmov\tSCBPTR, ARG_1, 2;\n\ttest\tSCB_FIFO_USE_COUNT, 0xFF jnz return;\nqueue_scb_completion:\n\ttest\tSCB_SCSI_STATUS,0xff\tjnz bad_status;\n\t/*\n\t * Check for residuals\n\t */\n\ttest\tSCB_SGPTR, SG_LIST_NULL jnz complete;\t/* No xfer */\n\ttest\tSCB_SGPTR, SG_FULL_RESID jnz upload_scb;/* Never xfered */\n\ttest\tSCB_RESIDUAL_SGPTR, SG_LIST_NULL jz upload_scb;\ncomplete:\nBEGIN_CRITICAL;\n\tbmov\tSCB_NEXT_COMPLETE, COMPLETE_SCB_HEAD, 2;\n\tbmov\tCOMPLETE_SCB_HEAD, SCBPTR, 2 ret;\nEND_CRITICAL;\nbad_status:\n\tcmp\tSCB_SCSI_STATUS, STATUS_PKT_SENSE je upload_scb;\n\tcall\tfreeze_queue;\nupload_scb:\n\t/*\n\t * Restore SCB TAG since we reuse this field\n\t * in the sequencer.  We don't want to corrupt\n\t * it on the host.\n\t */\n\tbmov\tSCB_TAG, SCBPTR, 2;\nBEGIN_CRITICAL;\n\tor\tSCB_SGPTR, SG_STATUS_VALID;\n\tmvi\tSCB_NEXT_COMPLETE[1], SCB_LIST_NULL;\n\tcmp\tCOMPLETE_DMA_SCB_HEAD[1], SCB_LIST_NULL jne add_dma_scb_tail;\n\tbmov\tCOMPLETE_DMA_SCB_HEAD, SCBPTR, 2;\n\tbmov\tCOMPLETE_DMA_SCB_TAIL, SCBPTR, 2 ret;\nadd_dma_scb_tail:\n\tbmov\tREG0, SCBPTR, 2;\n\tbmov\tSCBPTR, COMPLETE_DMA_SCB_TAIL, 2;\n\tbmov\tSCB_NEXT_COMPLETE, REG0, 2;\n\tbmov\tCOMPLETE_DMA_SCB_TAIL, REG0, 2 ret;\nEND_CRITICAL;\n\n/*\n * Is it a disconnect message?  Set a flag in the SCB to remind us\n * and await the bus going free.  If this is an untagged transaction\n * store the SCB id for it in our untagged target table for lookup on\n * a reselection.\n */\nmesgin_disconnect:\n\t/*\n\t * If ATN is raised, we still want to give the target a message.\n\t * Perhaps there was a parity error on this last message byte\n\t * or we want to abort this command.  Either way, the target\n\t * should take us to message out phase and then attempt to\n\t * disconnect again.\n\t * XXX - Wait for more testing.\n\ttest\tSCSISIGI, ATNI jnz mesgin_done;\n\t */\n\ttest\tSEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT\n\t\tjnz mesgin_proto_violation;\n\tor\tSCB_CONTROL,DISCONNECTED;\n\ttest\tSCB_CONTROL, TAG_ENB jnz await_busfree;\nqueue_disc_scb:\n\tbmov\tREG0, SCBPTR, 2;\n\tINDEX_DISC_LIST(SAVED_SCSIID, SAVED_LUN);\n\tbmov\tDINDEX, SINDEX, 2;\n\tbmov\tDINDIR, REG0, 2;\n\tbmov\tSCBPTR, REG0, 2;\n\t/* FALLTHROUGH */\nawait_busfree:\n\tand\tSIMODE1, ~ENBUSFREE;\n\tif ((ahd->bugs & AHD_BUSFREEREV_BUG) == 0) {\n\t\t/*\n\t\t * In the BUSFREEREV_BUG case, the\n\t\t * busfree status was cleared at the\n\t\t * beginning of the connection.\n\t\t */\n\t\tmvi\tCLRSINT1,CLRBUSFREE;\n\t}\n\tmov\tNONE, SCSIDAT;\t\t/* Ack the last byte */\n\ttest\tMODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1))\n\t\tjnz await_busfree_not_m_dff;\nSET_SRC_MODE\tM_DFF1;\nSET_DST_MODE\tM_DFF1;\nawait_busfree_clrchn:\n\tmvi\tDFFSXFRCTL, CLRCHN;\nawait_busfree_not_m_dff:\n\t/* clear target specific flags */\n\tmvi\tSEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT;\n\ttest\tSSTAT1,REQINIT|BUSFREE\tjz .;\n\t/*\n\t * We only set BUSFREE status once either a new\n\t * phase has been detected or we are really\n\t * BUSFREE.  This allows the driver to know\n\t * that we are active on the bus even though\n\t * no identified transaction exists should a\n\t * timeout occur while awaiting busfree.\n\t */\n\tmvi\tLASTPHASE, P_BUSFREE;\n\ttest\tSSTAT1, BUSFREE jnz idle_loop;\n\tSET_SEQINTCODE(MISSED_BUSFREE)\n\n\n/*\n * Save data pointers message:\n * Copying RAM values back to SCB, for Save Data Pointers message, but\n * only if we've actually been into a data phase to change them.  This\n * protects against bogus data in scratch ram and the residual counts\n * since they are only initialized when we go into data_in or data_out.\n * Ack the message as soon as possible.\n */\nSET_SRC_MODE\tM_DFF1;\nSET_DST_MODE\tM_DFF1;\nmesgin_sdptrs:\n\tmov\tNONE,SCSIDAT;\t\t/*dummy read from latch to ACK*/\n\ttest\tSEQ_FLAGS, DPHASE\tjz ITloop;\n\tcall\tsave_pointers;\n\tjmp\tITloop;\n\nsave_pointers:\n\t/*\n\t * If we are asked to save our position at the end of the\n\t * transfer, just mark us at the end rather than perform a\n\t * full save.\n\t */\n\ttest\tSCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz save_pointers_full;\n\tor\tSCB_SGPTR, SG_LIST_NULL ret;\n\nsave_pointers_full:\n\t/*\n\t * The SCB_DATAPTR becomes the current SHADDR.\n\t * All other information comes directly from our residual\n\t * state.\n\t */\n\tbmov\tSCB_DATAPTR, SHADDR, 8;\n\tbmov\tSCB_DATACNT, SCB_RESIDUAL_DATACNT, 8 ret;\n\n/*\n * Restore pointers message?  Data pointers are recopied from the\n * SCB anytime we enter a data phase for the first time, so all\n * we need to do is clear the DPHASE flag and let the data phase\n * code do the rest.  We also reset/reallocate the FIFO to make\n * sure we have a clean start for the next data or command phase.\n */\nmesgin_rdptrs:\n\tand\tSEQ_FLAGS, ~DPHASE;\n\ttest\tMODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1)) jnz msgin_rdptrs_get_fifo;\n\tmvi\tDFFSXFRCTL, RSTCHN|CLRSHCNT;\n\tSET_MODE(M_SCSI, M_SCSI)\nmsgin_rdptrs_get_fifo:\n\tcall\tallocate_fifo;\n\tjmp\tmesgin_done;\n\nphase_lock:     \n\tif ((ahd->bugs & AHD_EARLY_REQ_BUG) != 0) {\n\t\t/*\n\t\t * Don't ignore persistent REQ assertions just because\n\t\t * they were asserted within the bus settle delay window.\n\t\t * This allows us to tolerate devices like the GEM318\n\t\t * that violate the SCSI spec.  We are careful not to\n\t\t * count REQ while we are waiting for it to fall during\n\t\t * an async phase due to our asserted ACK.  Each\n\t\t * sequencer instruction takes ~25ns, so the REQ must\n\t\t * last at least 100ns in order to be counted as a true\n\t\t * REQ.\n\t\t */\n\t\ttest\tSCSIPHASE, 0xFF jnz phase_locked;\n\t\ttest\tSCSISIGI, ACKI jnz phase_lock;\n\t\ttest\tSCSISIGI, REQI jz phase_lock;\n\t\ttest\tSCSIPHASE, 0xFF jnz phase_locked;\n\t\ttest\tSCSISIGI, ACKI jnz phase_lock;\n\t\ttest\tSCSISIGI, REQI jz phase_lock;\nphase_locked:\n\t} else {\n\t\ttest\tSCSIPHASE, 0xFF jz .;\n\t}\n\ttest\tSSTAT1, SCSIPERR jnz phase_lock;\nphase_lock_latch_phase:\n\tand\tLASTPHASE, PHASE_MASK, SCSISIGI ret;\n\n/*\n * Functions to read data in Automatic PIO mode.\n *\n * An ACK is not sent on input from the target until SCSIDATL is read from.\n * So we wait until SCSIDATL is latched (the usual way), then read the data\n * byte directly off the bus using SCSIBUSL.  When we have pulled the ATN\n * line, or we just want to acknowledge the byte, then we do a dummy read\n * from SCISDATL.  The SCSI spec guarantees that the target will hold the\n * data byte on the bus until we send our ACK.\n *\n * The assumption here is that these are called in a particular sequence,\n * and that REQ is already set when inb_first is called.  inb_{first,next}\n * use the same calling convention as inb.\n */\ninb_next:\n\tmov\tNONE,SCSIDAT;\t\t/*dummy read from latch to ACK*/\ninb_next_wait:\n\t/*\n\t * If there is a parity error, wait for the kernel to\n\t * see the interrupt and prepare our message response\n\t * before continuing.\n\t */\n\ttest\tSCSIPHASE, 0xFF jz .;\n\ttest\tSSTAT1, SCSIPERR jnz inb_next_wait;\ninb_next_check_phase:\n\tand\tLASTPHASE, PHASE_MASK, SCSISIGI;\n\tcmp\tLASTPHASE, P_MESGIN jne mesgin_phasemis;\ninb_first:\n\tclr\tDINDEX[1];\n\tmov\tDINDEX,SINDEX;\n\tmov\tDINDIR,SCSIBUS\tret;\t\t/*read byte directly from bus*/\ninb_last:\n\tmov\tNONE,SCSIDAT ret;\t\t/*dummy read from latch to ACK*/\n\nmk_mesg:\n\tmvi\tSCSISIGO, ATNO;\n\tmov\tMSG_OUT,SINDEX ret;\n\nSET_SRC_MODE\tM_DFF1;\nSET_DST_MODE\tM_DFF1;\ndisable_ccsgen:\n\ttest\tSG_STATE, FETCH_INPROG jz disable_ccsgen_fetch_done;\n\tclr\tCCSGCTL;\ndisable_ccsgen_fetch_done:\n\tclr\tSG_STATE ret;\n\nservice_fifo:\n\t/*\n\t * Do we have any prefetch left???\n\t */\n\ttest\tSG_STATE, SEGS_AVAIL jnz idle_sg_avail;\n\n\t/*\n\t * Can this FIFO have access to the S/G cache yet?\n\t */\n\ttest\tCCSGCTL, SG_CACHE_AVAIL jz return;\n\n\t/* Did we just finish fetching segs? */\n\ttest\tCCSGCTL, CCSGDONE jnz idle_sgfetch_complete;\n\n\t/* Are we actively fetching segments? */\n\ttest\tCCSGCTL, CCSGENACK jnz return;\n\n\t/*\n\t * Should the other FIFO get the S/G cache first?  If\n\t * both FIFOs have been allocated since we last checked\n\t * any FIFO, it is important that we service a FIFO\n\t * that is not actively on the bus first.  This guarantees\n\t * that a FIFO will be freed to handle snapshot requests for\n\t * any FIFO that is still on the bus.  Chips with RTI do not\n\t * perform snapshots, so don't bother with this test there.\n\t */\n\tif ((ahd->features & AHD_RTI) == 0) {\n\t\t/*\n\t\t * If we're not still receiving SCSI data,\n\t\t * it is safe to allocate the S/G cache to\n\t\t * this FIFO.\n\t\t */\n\t\ttest\tDFCNTRL, SCSIEN jz idle_sgfetch_start;\n\n\t\t/*\n\t\t * Switch to the other FIFO.  Non-RTI chips\n\t\t * also have the \"set mode\" bug, so we must\n\t\t * disable interrupts during the switch.\n\t\t */\n\t\tmvi\tSEQINTCTL, INTVEC1DSL;\n\t\txor\tMODE_PTR, MK_MODE(M_DFF1, M_DFF1);\n\n\t\t/*\n\t\t * If the other FIFO needs loading, then it\n\t\t * must not have claimed the S/G cache yet\n\t\t * (SG_CACHE_AVAIL would have been cleared in\n\t\t * the original FIFO mode and we test this above).\n\t\t * Return to the idle loop so we can process the\n\t\t * FIFO not currently on the bus first.\n\t\t */\n\t\ttest\tSG_STATE, LOADING_NEEDED jz idle_sgfetch_okay;\n\t\tclr\tSEQINTCTL ret;\nidle_sgfetch_okay:\n\t\txor\tMODE_PTR, MK_MODE(M_DFF1, M_DFF1);\n\t\tclr\tSEQINTCTL;\n\t}\n\nidle_sgfetch_start:\n\t/*\n\t * We fetch a \"cacheline aligned\" and sized amount of data\n\t * so we don't end up referencing a non-existent page.\n\t * Cacheline aligned is in quotes because the kernel will\n\t * set the prefetch amount to a reasonable level if the\n\t * cacheline size is unknown.\n\t */\n\tbmov\tSGHADDR, SCB_RESIDUAL_SGPTR, 4;\n\tmvi\tSGHCNT, SG_PREFETCH_CNT;\n\tif ((ahd->bugs & AHD_REG_SLOW_SETTLE_BUG) != 0) {\n\t\t/*\n\t\t * Need two instructions between \"touches\" of SGHADDR.\n\t\t */\n\t\tnop;\n\t}\n\tand\tSGHADDR[0], SG_PREFETCH_ALIGN_MASK, SCB_RESIDUAL_SGPTR;\n\tmvi\tCCSGCTL, CCSGEN|CCSGRESET;\n\tor\tSG_STATE, FETCH_INPROG ret;\nidle_sgfetch_complete:\n\t/*\n\t * Guard against SG_CACHE_AVAIL activating during sg fetch\n\t * request in the other FIFO.\n\t */\n\ttest\tSG_STATE, FETCH_INPROG jz return;\n\tclr\tCCSGCTL;\n\tand\tCCSGADDR, SG_PREFETCH_ADDR_MASK, SCB_RESIDUAL_SGPTR;\n\tmvi\tSG_STATE, SEGS_AVAIL|LOADING_NEEDED;\nidle_sg_avail:\n\t/* Does the hardware have space for another SG entry? */\n\ttest\tDFSTATUS, PRELOAD_AVAIL jz return;\n\t/*\n\t * On the A, preloading a segment before HDMAENACK\n\t * comes true can clobber the shadow address of the\n\t * first segment in the S/G FIFO.  Wait until it is\n\t * safe to proceed.\n\t */\n\tif ((ahd->features & AHD_NEW_DFCNTRL_OPTS) == 0) {\n\t\ttest\tDFCNTRL, HDMAENACK jz return;\n\t}\n\tif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {\n\t\tbmov\tHADDR, CCSGRAM, 8;\n\t} else {\n\t\tbmov \tHADDR, CCSGRAM, 4;\n\t}\n\tbmov\tHCNT, CCSGRAM, 3;\n\tbmov\tSCB_RESIDUAL_DATACNT[3], CCSGRAM, 1;\n\tif ((ahd->flags & AHD_39BIT_ADDRESSING) != 0) {\n\t\tand\tHADDR[4], SG_HIGH_ADDR_BITS, SCB_RESIDUAL_DATACNT[3];\n\t}\n\tif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {\n\t\t/* Skip 4 bytes of pad. */\n\t\tadd\tCCSGADDR, 4;\n\t}\nsg_advance:\n\tclr\tA;\t\t\t/* add sizeof(struct scatter) */\n\tadd\tSCB_RESIDUAL_SGPTR[0],SG_SIZEOF;\n\tadc\tSCB_RESIDUAL_SGPTR[1],A;\n\tadc\tSCB_RESIDUAL_SGPTR[2],A;\n\tadc\tSCB_RESIDUAL_SGPTR[3],A;\n\tmov\tSINDEX, SCB_RESIDUAL_SGPTR[0];\n\ttest\tSCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 3;\n\tor\tSINDEX, LAST_SEG;\n\tclr\tSG_STATE;\n\tmov\tSG_CACHE_PRE, SINDEX;\n\tif ((ahd->features & AHD_NEW_DFCNTRL_OPTS) != 0) {\n\t\t/*\n\t\t * Use SCSIENWRDIS so that SCSIEN is never\n\t\t * modified by this operation.\n\t\t */\n\t\tor\tDFCNTRL, PRELOADEN|HDMAEN|SCSIENWRDIS;\n\t} else {\n\t\tor\tDFCNTRL, PRELOADEN|HDMAEN;\n\t}\n\t/*\n\t * Do we have another segment in the cache?\n\t */\n\tadd\tNONE, SG_PREFETCH_CNT_LIMIT, CCSGADDR;\n\tjnc\treturn;\n\tand\tSG_STATE, ~SEGS_AVAIL ret;\n\n/*\n * Initialize the DMA address and counter from the SCB.\n */\nload_first_seg:\n\tbmov\tHADDR, SCB_DATAPTR, 11;\n\tand\tREG_ISR, ~SG_FULL_RESID, SCB_SGPTR[0];\n\ttest\tSCB_DATACNT[3], SG_LAST_SEG jz . + 2;\n\tor\tREG_ISR, LAST_SEG;\n\tmov\tSG_CACHE_PRE, REG_ISR;\n\tmvi\tDFCNTRL, (PRELOADEN|SCSIEN|HDMAEN);\n\t/*\n\t * Since we've are entering a data phase, we will\n\t * rely on the SCB_RESID* fields.  Initialize the\n\t * residual and clear the full residual flag.\n\t */\n\tand\tSCB_SGPTR[0], ~SG_FULL_RESID;\n\tbmov\tSCB_RESIDUAL_DATACNT[3], SCB_DATACNT[3], 5;\n\t/* If we need more S/G elements, tell the idle loop */\n\ttest\tSCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jnz . + 2;\n\tmvi\tSG_STATE, LOADING_NEEDED ret;\n\tclr\tSG_STATE ret;\n\np_data_handle_xfer:\n\tcall\tsetjmp;\n\ttest\tSG_STATE, LOADING_NEEDED jnz service_fifo;\np_data_clear_handler:\n\tor\tLONGJMP_ADDR[1], INVALID_ADDR ret;\n\np_data:\n\ttest\tSEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT\tjz p_data_allowed;\n\tSET_SEQINTCODE(PROTO_VIOLATION)\np_data_allowed:\n \n\ttest\tSEQ_FLAGS, DPHASE\tjz data_phase_initialize;\n\n\t/*\n\t * If we re-enter the data phase after going through another\n\t * phase, our transfer location has almost certainly been\n\t * corrupted by the interveining, non-data, transfers.  Ask\n\t * the host driver to fix us up based on the transfer residual\n\t * unless we already know that we should be bitbucketing.\n\t */\n\ttest\tSCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jnz p_data_bitbucket;\n\tSET_SEQINTCODE(PDATA_REINIT)\n\tjmp\tdata_phase_inbounds;\n\np_data_bitbucket:\n\t/*\n\t * Turn on `Bit Bucket' mode, wait until the target takes\n\t * us to another phase, and then notify the host.\n\t */\n\tmov\tSAVED_MODE, MODE_PTR;\n\ttest\tMODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1))\n\t\tjnz bitbucket_not_m_dff;\n\t/*\n\t * Ensure that any FIFO contents are cleared out and the\n\t * FIFO free'd prior to starting the BITBUCKET.  BITBUCKET\n\t * doesn't discard data already in the FIFO.\n\t */\n\tmvi\tDFFSXFRCTL, RSTCHN|CLRSHCNT;\n\tSET_MODE(M_SCSI, M_SCSI)\nbitbucket_not_m_dff:\n\tor\tSXFRCTL1,BITBUCKET;\n\t/* Wait for non-data phase. */\n\ttest\tSCSIPHASE, ~DATA_PHASE_MASK jz .;\n\tand\tSXFRCTL1, ~BITBUCKET;\n\tRESTORE_MODE(SAVED_MODE)\nSET_SRC_MODE\tM_DFF1;\nSET_DST_MODE\tM_DFF1;\n\tSET_SEQINTCODE(DATA_OVERRUN)\n\tjmp\tITloop;\n\ndata_phase_initialize:\n\ttest\tSCB_SGPTR[0], SG_LIST_NULL jnz p_data_bitbucket;\n\tcall\tload_first_seg;\ndata_phase_inbounds:\n\t/* We have seen a data phase at least once. */\n\tor\tSEQ_FLAGS, DPHASE;\n\tmov\tSAVED_MODE, MODE_PTR;\n\ttest\tSG_STATE, LOADING_NEEDED jz data_group_dma_loop;\n\tcall\tp_data_handle_xfer;\ndata_group_dma_loop:\n\t/*\n\t * The transfer is complete if either the last segment\n\t * completes or the target changes phase.  Both conditions\n\t * will clear SCSIEN.\n\t */\n\tcall\tidle_loop_service_fifos;\n\tcall\tidle_loop_cchan;\n\tcall\tidle_loop_gsfifo;\n\tRESTORE_MODE(SAVED_MODE)\n\ttest\tDFCNTRL, SCSIEN jnz data_group_dma_loop;\n\ndata_group_dmafinish:\n\t/*\n\t * The transfer has terminated either due to a phase\n\t * change, and/or the completion of the last segment.\n\t * We have two goals here.  Do as much other work\n\t * as possible while the data fifo drains on a read\n\t * and respond as quickly as possible to the standard\n\t * messages (save data pointers/disconnect and command\n\t * complete) that usually follow a data phase.\n\t */\n\tcall\tcalc_residual;\n\n\t/*\n\t * Go ahead and shut down the DMA engine now.\n\t */\n\ttest\tDFCNTRL, DIRECTION jnz data_phase_finish;\ndata_group_fifoflush:\n\tif ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0) {\n\t\tor\tDFCNTRL, FIFOFLUSH;\n\t}\n\t/*\n\t * We have enabled the auto-ack feature.  This means\n\t * that the controller may have already transferred\n\t * some overrun bytes into the data FIFO and acked them\n\t * on the bus.  The only way to detect this situation is\n\t * to wait for LAST_SEG_DONE to come true on a completed\n\t * transfer and then test to see if the data FIFO is\n\t * non-empty.  We know there is more data yet to transfer\n\t * if SG_LIST_NULL is not yet set, thus there cannot be\n\t * an overrun.\n\t */\n\ttest\tSCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz data_phase_finish;\n\ttest\tSG_CACHE_SHADOW, LAST_SEG_DONE jz .;\n\ttest\tDFSTATUS, FIFOEMP jnz data_phase_finish;\n\t/* Overrun */\n\tjmp\tp_data;\ndata_phase_finish:\n\t/*\n\t * If the target has left us in data phase, loop through\n\t * the dma code again.  We will only loop if there is a\n\t * data overrun.  \n\t */\n\tif ((ahd->flags & AHD_TARGETROLE) != 0) {\n\t\ttest\tSSTAT0, TARGET jnz data_phase_done;\n\t}\n\tif ((ahd->flags & AHD_INITIATORROLE) != 0) {\n\t\ttest\tSSTAT1, REQINIT jz .;\n\t\ttest\tSCSIPHASE, DATA_PHASE_MASK jnz p_data;\n\t}\n\ndata_phase_done:\n\t/* Kill off any pending prefetch */\n\tcall\tdisable_ccsgen;\n\tor \tLONGJMP_ADDR[1], INVALID_ADDR;\n\n\tif ((ahd->flags & AHD_TARGETROLE) != 0) {\n\t\ttest\tSEQ_FLAGS, DPHASE_PENDING jz ITloop;\n\t\t/*\n\t\tand\tSEQ_FLAGS, ~DPHASE_PENDING;\n\t\t * For data-in phases, wait for any pending acks from the\n\t\t * initiator before changing phase.  We only need to\n\t\t * send Ignore Wide Residue messages for data-in phases.\n\t\ttest\tDFCNTRL, DIRECTION jz target_ITloop;\n\t\ttest\tSSTAT1, REQINIT\tjnz .;\n\t\ttest\tSCB_TASK_ATTRIBUTE, SCB_XFERLEN_ODD jz target_ITloop;\n\t\tSET_MODE(M_SCSI, M_SCSI)\n\t\ttest\tNEGCONOPTS, WIDEXFER jz target_ITloop;\n\t\t */\n\t\t/*\n\t\t * Issue an Ignore Wide Residue Message.\n\t\tmvi\tP_MESGIN|BSYO call change_phase;\n\t\tmvi\tMSG_IGN_WIDE_RESIDUE call target_outb;\n\t\tmvi\t1 call target_outb;\n\t\tjmp\ttarget_ITloop;\n\t\t */\n\t} else {\n\t\tjmp\tITloop;\n\t}\n\n/*\n * We assume that, even though data may still be\n * transferring to the host, that the SCSI side of\n * the DMA engine is now in a static state.  This\n * allows us to update our notion of where we are\n * in this transfer.\n *\n * If, by chance, we stopped before being able\n * to fetch additional segments for this transfer,\n * yet the last S/G was completely exhausted,\n * call our idle loop until it is able to load\n * another segment.  This will allow us to immediately\n * pickup on the next segment on the next data phase.\n *\n * If we happened to stop on the last segment, then\n * our residual information is still correct from\n * the idle loop and there is no need to perform\n * any fixups.\n */\nresidual_before_last_seg:\n\ttest    MDFFSTAT, SHVALID\tjnz sgptr_fixup;\n\t/*\n\t * Can never happen from an interrupt as the packetized\n\t * hardware will only interrupt us once SHVALID or\n\t * LAST_SEG_DONE.\n\t */\n\tcall\tidle_loop_service_fifos;\n\tRESTORE_MODE(SAVED_MODE)\n\t/* FALLTHROUGH */\ncalc_residual:\n\ttest\tSG_CACHE_SHADOW, LAST_SEG jz residual_before_last_seg;\n\t/* Record if we've consumed all S/G entries */\n\ttest\tMDFFSTAT, SHVALID\tjz . + 2;\n\tbmov\tSCB_RESIDUAL_DATACNT, SHCNT, 3 ret;\n\tor\tSCB_RESIDUAL_SGPTR[0], SG_LIST_NULL ret;\n\nsgptr_fixup:\n\t/*\n\t * Fixup the residual next S/G pointer.  The S/G preload\n\t * feature of the chip allows us to load two elements\n\t * in addition to the currently active element.  We\n\t * store the bottom byte of the next S/G pointer in\n\t * the SG_CACHE_PTR register so we can restore the\n\t * correct value when the DMA completes.  If the next\n\t * sg ptr value has advanced to the point where higher\n\t * bytes in the address have been affected, fix them\n\t * too.\n\t */\n\ttest\tSG_CACHE_SHADOW, 0x80 jz sgptr_fixup_done;\n\ttest\tSCB_RESIDUAL_SGPTR[0], 0x80 jnz sgptr_fixup_done;\n\tadd\tSCB_RESIDUAL_SGPTR[1], -1;\n\tadc\tSCB_RESIDUAL_SGPTR[2], -1; \n\tadc\tSCB_RESIDUAL_SGPTR[3], -1;\nsgptr_fixup_done:\n\tand\tSCB_RESIDUAL_SGPTR[0], SG_ADDR_MASK, SG_CACHE_SHADOW;\n\tclr\tSCB_RESIDUAL_DATACNT[3]; /* We are not the last seg */\n\tbmov\tSCB_RESIDUAL_DATACNT, SHCNT, 3 ret;\n\nexport timer_isr:\n\tcall\tissue_cmdcmplt;\n\tmvi\tCLRSEQINTSTAT, CLRSEQ_SWTMRTO;\n\tif ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {\n\t\t/*\n\t\t * In H2A4, the mode pointer is not saved\n\t\t * for intvec2, but is restored on iret.\n\t\t * This can lead to the restoration of a\n\t\t * bogus mode ptr.  Manually clear the\n\t\t * intmask bits and do a normal return\n\t\t * to compensate.\n\t\t */\n\t\tand\tSEQINTCTL, ~(INTMASK2|INTMASK1) ret;\n\t} else {\n\t\tor\tSEQINTCTL, IRET ret;\n\t}\n\nexport seq_isr:\n\tif ((ahd->features & AHD_RTI) == 0) {\n\t\t/*\n\t\t * On RevA Silicon, if the target returns us to data-out\n\t\t * after we have already trained for data-out, it is\n\t\t * possible for us to transition the free running clock to\n\t\t * data-valid before the required 100ns P1 setup time (8 P1\n\t\t * assertions in fast-160 mode).  This will only happen if\n\t\t * this L-Q is a continuation of a data transfer for which\n\t\t * we have already prefetched data into our FIFO (LQ/Data\n\t\t * followed by LQ/Data for the same write transaction).\n\t\t * This can cause some target implementations to miss the\n\t\t * first few data transfers on the bus.  We detect this\n\t\t * situation by noticing that this is the first data transfer\n\t\t * after an LQ (LQIWORKONLQ true), that the data transfer is\n\t\t * a continuation of a transfer already setup in our FIFO\n\t\t * (SAVEPTRS interrupt), and that the transaction is a write\n\t\t * (DIRECTION set in DFCNTRL). The delay is performed by\n\t\t * disabling SCSIEN until we see the first REQ from the\n\t\t * target.\n\t\t * \n\t\t * First instruction in an ISR cannot be a branch on\n\t\t * Rev A.  Snapshot LQISTAT2 so the status is not missed\n\t\t * and deffer the test by one instruction.\n\t\t */\n\t\tmov\tREG_ISR, LQISTAT2;\n\t\ttest\tREG_ISR, LQIWORKONLQ jz main_isr;\n\t\ttest\tSEQINTSRC, SAVEPTRS  jz main_isr;\n\t\ttest\tLONGJMP_ADDR[1], INVALID_ADDR jz saveptr_active_fifo;\n\t\t/*\n\t\t * Switch to the active FIFO after clearing the snapshot\n\t\t * savepointer in the current FIFO.  We do this so that\n\t\t * a pending CTXTDONE or SAVEPTR is visible in the active\n\t\t * FIFO.  This status is the only way we can detect if we\n\t\t * have lost the race (e.g. host paused us) and our attempts\n\t\t * to disable the channel occurred after all REQs were\n\t\t * already seen and acked (REQINIT never comes true).\n\t\t */\n\t\tmvi\tDFFSXFRCTL, CLRCHN;\n\t\txor\tMODE_PTR, MK_MODE(M_DFF1, M_DFF1);\n\t\ttest\tDFCNTRL, DIRECTION jz interrupt_return;\n\t\tand\tDFCNTRL, ~SCSIEN;\nsnapshot_wait_data_valid:\n\t\ttest\tSEQINTSRC, (CTXTDONE|SAVEPTRS) jnz interrupt_return;\n\t\ttest\tSSTAT1, REQINIT\tjz snapshot_wait_data_valid;\nsnapshot_data_valid:\n\t\tor\tDFCNTRL, SCSIEN;\n\t\tor\tSEQINTCTL, IRET ret;\nsnapshot_saveptr:\n\t\tmvi\tDFFSXFRCTL, CLRCHN;\n\t\tor\tSEQINTCTL, IRET ret;\nmain_isr:\n\t}\n\ttest\tSEQINTSRC, CFG4DATA\tjnz cfg4data_intr;\n\ttest\tSEQINTSRC, CFG4ISTAT\tjnz cfg4istat_intr;\n\ttest\tSEQINTSRC, SAVEPTRS\tjnz saveptr_intr;\n\ttest\tSEQINTSRC, CFG4ICMD\tjnz cfg4icmd_intr;\n\tSET_SEQINTCODE(INVALID_SEQINT)\n\n/*\n * There are two types of save pointers interrupts:\n * The first is a snapshot save pointers where the current FIFO is not\n * active and contains a snapshot of the current poniter information.\n * This happens between packets in a stream for a single L_Q.  Since we\n * are not performing a pointer save, we can safely clear the channel\n * so it can be used for other transactions.  On RTI capable controllers,\n * where snapshots can, and are, disabled, the code to handle this type\n * of snapshot is not active.\n *\n * The second case is a save pointers on an active FIFO which occurs\n * if the target changes to a new L_Q or busfrees/QASes and the transfer\n * has a residual.  This should occur coincident with a ctxtdone.  We\n * disable the interrupt and allow our active routine to handle the\n * save.\n */\nsaveptr_intr:\n\tif ((ahd->features & AHD_RTI) == 0) {\n\t\ttest\tLONGJMP_ADDR[1], INVALID_ADDR jnz snapshot_saveptr;\n\t}\nsaveptr_active_fifo:\n\tand\tSEQIMODE, ~ENSAVEPTRS;\n\tor\tSEQINTCTL, IRET ret;\n\ncfg4data_intr:\n\ttest\tSCB_SGPTR[0], SG_LIST_NULL jnz pkt_handle_overrun_inc_use_count;\n\tcall\tload_first_seg;\n\tcall\tpkt_handle_xfer;\n\tinc\tSCB_FIFO_USE_COUNT;\ninterrupt_return:\n\tor\tSEQINTCTL, IRET ret;\n\ncfg4istat_intr:\n\tcall\tfreeze_queue;\n\tadd\tNONE, -13, SCB_CDB_LEN;\n\tjnc\tcfg4istat_have_sense_addr;\n\ttest\tSCB_CDB_LEN, SCB_CDB_LEN_PTR jnz cfg4istat_have_sense_addr;\n\t/*\n\t * Host sets up address/count and enables transfer.\n\t */\n\tSET_SEQINTCODE(CFG4ISTAT_INTR)\n\tjmp\tcfg4istat_setup_handler;\ncfg4istat_have_sense_addr:\n\tbmov\tHADDR, SCB_SENSE_BUSADDR, 4;\n\tmvi\tHCNT[1], (AHD_SENSE_BUFSIZE >> 8);\n\tmvi\tSG_CACHE_PRE, LAST_SEG;\n\tmvi\tDFCNTRL, PRELOADEN|SCSIEN|HDMAEN;\ncfg4istat_setup_handler:\n\t/*\n\t * Status pkt is transferring to host.\n\t * Wait in idle loop for transfer to complete.\n\t * If a command completed before an attempted\n\t * task management function completed, notify the host.\n\t */\n\ttest\tSCB_TASK_MANAGEMENT, 0xFF jz cfg4istat_no_taskmgmt_func;\n\tSET_SEQINTCODE(TASKMGMT_CMD_CMPLT_OKAY)\ncfg4istat_no_taskmgmt_func:\n\tcall\tpkt_handle_status;\n\tor\tSEQINTCTL, IRET ret;\n\ncfg4icmd_intr:\n\t/*\n\t * In the case of DMAing a CDB from the host, the normal\n\t * CDB buffer is formatted with an 8 byte address followed\n\t * by a 1 byte count.\n\t */\n\tbmov\tHADDR[0], SCB_HOST_CDB_PTR, 9;\n\tmvi\tSG_CACHE_PRE, LAST_SEG;\n\tmvi\tDFCNTRL, (PRELOADEN|SCSIEN|HDMAEN);\n\tcall\tpkt_handle_cdb;\n\tor\tSEQINTCTL, IRET ret;\n\n/*\n * See if the target has gone on in this context creating an\n * overrun condition.  For the write case, the hardware cannot\n * ack bytes until data are provided.  So, if the target begins\n * another  packet without changing contexts, implying we are\n * not sitting on a packet boundary, we are in an overrun\n * situation.  For the read case, the hardware will continue to\n * ack bytes into the FIFO, and may even ack the last overrun packet\n * into the FIFO.   If the FIFO should become non-empty, we are in\n * a read overrun case.\n */\n#define check_overrun\t\t\t\t\t\t\t\\\n\t/* Not on a packet boundary. */\t\t\t\t\t\\\n\ttest \tMDFFSTAT, DLZERO jz pkt_handle_overrun;\t\t\t\\\n\ttest\tDFSTATUS, FIFOEMP jz pkt_handle_overrun\n\npkt_handle_xfer:\n\ttest\tSG_STATE, LOADING_NEEDED jz pkt_last_seg;\n\tcall\tsetjmp;\n\ttest\tSEQINTSRC, SAVEPTRS jnz pkt_saveptrs;\n\ttest\tSCSIPHASE, ~DATA_PHASE_MASK jz . + 2;\n\ttest\tSCSISIGO, ATNO jnz . + 2;\n\ttest\tSSTAT2, NONPACKREQ jz pkt_service_fifo;\n\t/*\n\t * Defer handling of this NONPACKREQ until we\n\t * can be sure it pertains to this FIFO.  SAVEPTRS\n\t * will not be asserted if the NONPACKREQ is for us,\n\t * so we must simulate it if shadow is valid.  If\n\t * shadow is not valid, keep running this FIFO until we\n\t * have satisfied the transfer by loading segments and\n\t * waiting for either shadow valid or last_seg_done.\n\t */\n\ttest\tMDFFSTAT, SHVALID jnz pkt_saveptrs;\npkt_service_fifo:\n\ttest\tSG_STATE, LOADING_NEEDED jnz service_fifo;\npkt_last_seg:\n\tcall\tsetjmp;\n\ttest\tSEQINTSRC, SAVEPTRS jnz pkt_saveptrs;\n\ttest\tSG_CACHE_SHADOW, LAST_SEG_DONE jnz pkt_last_seg_done;\n\ttest\tSCSIPHASE, ~DATA_PHASE_MASK jz . + 2;\n\ttest\tSCSISIGO, ATNO jnz . + 2;\n\ttest\tSSTAT2, NONPACKREQ jz return;\n\ttest\tMDFFSTAT, SHVALID jz return;\n\t/* FALLTHROUGH */\n\n/*\n * Either a SAVEPTRS interrupt condition is pending for this FIFO\n * or we have a pending NONPACKREQ for this FIFO.  We differentiate\n * between the two by capturing the state of the SAVEPTRS interrupt\n * prior to clearing this status and executing the common code for\n * these two cases.\n */\npkt_saveptrs:\nBEGIN_CRITICAL;\n\tif ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0) {\n\t\tor\tDFCNTRL, FIFOFLUSH;\n\t}\n\tmov\tREG0, SEQINTSRC;\n\tcall\tcalc_residual;\n\tcall\tsave_pointers;\n\tmvi\tCLRSEQINTSRC, CLRSAVEPTRS;\n\tcall\tdisable_ccsgen;\n\tor\tSEQIMODE, ENSAVEPTRS;\n\ttest\tDFCNTRL, DIRECTION jnz pkt_saveptrs_check_status;\n\ttest\tDFSTATUS, FIFOEMP jnz pkt_saveptrs_check_status;\n\t/*\n\t * Keep a handler around for this FIFO until it drains\n\t * to the host to guarantee that we don't complete the\n\t * command to the host before the data arrives.\n\t */\npkt_saveptrs_wait_fifoemp:\n\tcall\tsetjmp;\n\ttest\tDFSTATUS, FIFOEMP jz return;\npkt_saveptrs_check_status:\n\tor\tLONGJMP_ADDR[1], INVALID_ADDR;\n\ttest\tREG0, SAVEPTRS jz unexpected_nonpkt_phase;\n\tdec\tSCB_FIFO_USE_COUNT;\n\ttest\tSCB_CONTROL, STATUS_RCVD jnz pkt_complete_scb_if_fifos_idle;\n\tmvi\tDFFSXFRCTL, CLRCHN ret;\n\n/*\n * LAST_SEG_DONE status has been seen in the current FIFO.\n * This indicates that all of the allowed data for this\n * command has transferred across the SCSI and host buses.\n * Check for overrun and see if we can complete this command.\n */\npkt_last_seg_done:\n\t/*\n\t * Mark transfer as completed.\n\t */\n\tor\tSCB_SGPTR, SG_LIST_NULL;\n\n\t/*\n\t * Wait for the current context to finish to verify that\n\t * no overrun condition has occurred.\n\t */\n\ttest\tSEQINTSRC, CTXTDONE jnz pkt_ctxt_done;\n\tcall\tsetjmp;\npkt_wait_ctxt_done_loop:\n\ttest\tSEQINTSRC, CTXTDONE jnz pkt_ctxt_done;\n\t/*\n\t * A sufficiently large overrun or a NONPACKREQ may\n\t * prevent CTXTDONE from ever asserting, so we must\n\t * poll for these statuses too.\n\t */\n\tcheck_overrun;\n\ttest\tSSTAT2, NONPACKREQ jz return;\n\ttest\tSEQINTSRC, CTXTDONE jz unexpected_nonpkt_phase;\n\t/* FALLTHROUGH */\n\npkt_ctxt_done:\n\tcheck_overrun;\n\tor\tLONGJMP_ADDR[1], INVALID_ADDR;\n\t/*\n\t * If status has been received, it is safe to skip\n\t * the check to see if another FIFO is active because\n\t * LAST_SEG_DONE has been observed.  However, we check\n\t * the FIFO anyway since it costs us only one extra\n\t * instruction to leverage common code to perform the\n\t * SCB completion.\n\t */\n\tdec\tSCB_FIFO_USE_COUNT;\n\ttest\tSCB_CONTROL, STATUS_RCVD jnz pkt_complete_scb_if_fifos_idle;\n\tmvi\tDFFSXFRCTL, CLRCHN ret;\nEND_CRITICAL;\n\n/*\n * Must wait until CDB xfer is over before issuing the\n * clear channel.\n */\npkt_handle_cdb:\n\tcall\tsetjmp;\n\ttest\tSG_CACHE_SHADOW, LAST_SEG_DONE jz return;\n\tor\tLONGJMP_ADDR[1], INVALID_ADDR;\n\tmvi\tDFFSXFRCTL, CLRCHN ret;\n\n/*\n * Watch over the status transfer.  Our host sense buffer is\n * large enough to take the maximum allowed status packet.\n * None-the-less, we must still catch and report overruns to\n * the host.  Additionally, properly catch unexpected non-packet\n * phases that are typically caused by CRC errors in status packet\n * transmission.\n */\npkt_handle_status:\n\tcall\tsetjmp;\n\ttest\tSG_CACHE_SHADOW, LAST_SEG_DONE jnz pkt_status_check_overrun;\n\ttest\tSEQINTSRC, CTXTDONE jz pkt_status_check_nonpackreq;\n\ttest\tSG_CACHE_SHADOW, LAST_SEG_DONE jnz pkt_status_check_overrun;\npkt_status_IU_done:\n\tif ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0) {\n\t\tor\tDFCNTRL, FIFOFLUSH;\n\t}\n\ttest\tDFSTATUS, FIFOEMP jz return;\nBEGIN_CRITICAL;\n\tor\tLONGJMP_ADDR[1], INVALID_ADDR;\n\tmvi\tSCB_SCSI_STATUS, STATUS_PKT_SENSE;\n\tor\tSCB_CONTROL, STATUS_RCVD;\n\tjmp\tpkt_complete_scb_if_fifos_idle;\nEND_CRITICAL;\npkt_status_check_overrun:\n\t/*\n\t * Status PKT overruns are uncerimoniously recovered with a\n\t * bus reset.  If we've overrun, let the host know so that\n\t * recovery can be performed.\n\t *\n\t * LAST_SEG_DONE has been observed.  If either CTXTDONE or\n\t * a NONPACKREQ phase change have occurred and the FIFO is\n\t * empty, there is no overrun.\n\t */\n\ttest\tDFSTATUS, FIFOEMP jz pkt_status_report_overrun;\n\ttest\tSEQINTSRC, CTXTDONE jz . + 2;\n\ttest\tDFSTATUS, FIFOEMP jnz pkt_status_IU_done;\n\ttest\tSCSIPHASE, ~DATA_PHASE_MASK jz return;\n\ttest\tDFSTATUS, FIFOEMP jnz pkt_status_check_nonpackreq;\npkt_status_report_overrun:\n\tSET_SEQINTCODE(STATUS_OVERRUN)\n\t/* SEQUENCER RESTARTED */\npkt_status_check_nonpackreq:\n\t/*\n\t * CTXTDONE may be held off if a NONPACKREQ is associated with\n\t * the current context.  If a NONPACKREQ is observed, decide\n\t * if it is for the current context.  If it is for the current\n\t * context, we must defer NONPACKREQ processing until all data\n\t * has transferred to the host.\n\t */\n\ttest\tSCSIPHASE, ~DATA_PHASE_MASK jz return;\n\ttest\tSCSISIGO, ATNO jnz . + 2;\n\ttest\tSSTAT2, NONPACKREQ jz return;\n\ttest\tSEQINTSRC, CTXTDONE jnz pkt_status_IU_done;\n\ttest\tDFSTATUS, FIFOEMP jz return;\n\t/*\n\t * The unexpected nonpkt phase handler assumes that any\n\t * data channel use will have a FIFO reference count.  It\n\t * turns out that the status handler doesn't need a references\n\t * count since the status received flag, and thus completion\n\t * processing, cannot be set until the handler is finished.\n\t * We increment the count here to make the nonpkt handler\n\t * happy.\n\t */\n\tinc\tSCB_FIFO_USE_COUNT;\n\t/* FALLTHROUGH */\n\n/*\n * Nonpackreq is a polled status.  It can come true in three situations:\n * we have received an L_Q, we have sent one or more L_Qs, or there is no\n * L_Q context associated with this REQ (REQ occurs immediately after a\n * (re)selection).  Routines that know that the context responsible for this\n * nonpackreq call directly into unexpected_nonpkt_phase.  In the case of the\n * top level idle loop, we exhaust all active contexts prior to determining that\n * we simply do not have the full I_T_L_Q for this phase.\n */\nunexpected_nonpkt_phase_find_ctxt:\n\t/*\n\t * This nonpackreq is most likely associated with one of the tags\n\t * in a FIFO or an outgoing LQ.  Only treat it as an I_T only\n\t * nonpackreq if we've cleared out the FIFOs and handled any\n\t * pending SELDO.\n\t */\nSET_SRC_MODE\tM_SCSI;\nSET_DST_MODE\tM_SCSI;\n\tand\tA, FIFO1FREE|FIFO0FREE, DFFSTAT;\n\tcmp\tA, FIFO1FREE|FIFO0FREE jne return;\n\ttest\tSSTAT0, SELDO jnz return;\n\tmvi\tSCBPTR[1], SCB_LIST_NULL;\nunexpected_nonpkt_phase:\n\ttest\tMODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1))\n\t\tjnz unexpected_nonpkt_mode_cleared;\nSET_SRC_MODE\tM_DFF0;\nSET_DST_MODE\tM_DFF0;\n\tor\tLONGJMP_ADDR[1], INVALID_ADDR;\n\tdec\tSCB_FIFO_USE_COUNT;\n\tmvi\tDFFSXFRCTL, CLRCHN;\nunexpected_nonpkt_mode_cleared:\n\tmvi\tCLRSINT2, CLRNONPACKREQ;\n\tif ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0) {\n\t\t/*\n\t\t * Test to ensure that the bus has not\n\t\t * already gone free prior to clearing\n\t\t * any stale busfree status.  This avoids\n\t\t * a window whereby a busfree just after\n\t\t * a selection could be missed.\n\t\t */\n\t\ttest\tSCSISIGI, BSYI jz . + 2;\n\t\tmvi\tCLRSINT1,CLRBUSFREE;\n\t\tor\tSIMODE1, ENBUSFREE;\n\t}\n\ttest\tSCSIPHASE, ~(MSG_IN_PHASE|MSG_OUT_PHASE) jnz illegal_phase;\n\tSET_SEQINTCODE(ENTERING_NONPACK)\n\tjmp\tITloop;\n\nillegal_phase:\n\tSET_SEQINTCODE(ILLEGAL_PHASE)\n\tjmp\tITloop;\n\n/*\n * We have entered an overrun situation.  If we have working\n * BITBUCKET, flip that on and let the hardware eat any overrun\n * data.  Otherwise use an overrun buffer in the host to simulate\n * BITBUCKET.\n */\npkt_handle_overrun_inc_use_count:\n\tinc\tSCB_FIFO_USE_COUNT;\npkt_handle_overrun:\n\tSET_SEQINTCODE(CFG4OVERRUN)\n\tcall\tfreeze_queue;\n\tif ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) == 0) {\n\t\tor\tDFFSXFRCTL, DFFBITBUCKET;\nSET_SRC_MODE\tM_DFF1;\nSET_DST_MODE\tM_DFF1;\n\t} else {\n\t\tcall\tload_overrun_buf;\n\t\tmvi\tDFCNTRL, (HDMAEN|SCSIEN|PRELOADEN);\n\t}\n\tcall\tsetjmp;\n\tif ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0) {\n\t\ttest\tDFSTATUS, PRELOAD_AVAIL jz overrun_load_done;\n\t\tcall\tload_overrun_buf;\n\t\tor\tDFCNTRL, PRELOADEN;\noverrun_load_done:\n\t\ttest\tSEQINTSRC, CTXTDONE jnz pkt_overrun_end;\n\t} else {\n\t\ttest\tDFFSXFRCTL, DFFBITBUCKET jz pkt_overrun_end;\n\t}\n\ttest\tSSTAT2, NONPACKREQ jz return;\npkt_overrun_end:\n\tor\tSCB_RESIDUAL_SGPTR, SG_OVERRUN_RESID;\n\ttest\tSEQINTSRC, CTXTDONE jz unexpected_nonpkt_phase;\n\tdec\tSCB_FIFO_USE_COUNT;\n\tor\tLONGJMP_ADDR[1], INVALID_ADDR;\n\ttest\tSCB_CONTROL, STATUS_RCVD jnz pkt_complete_scb_if_fifos_idle;\n\tmvi\tDFFSXFRCTL, CLRCHN ret;\n\nif ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0) {\nload_overrun_buf:\n\t/*\n\t * Load a dummy segment if preload space is available.\n\t */\n\tmov \tHADDR[0], SHARED_DATA_ADDR;\n\tadd\tHADDR[1], PKT_OVERRUN_BUFOFFSET, SHARED_DATA_ADDR[1];\n\tmov\tACCUM_SAVE, A;\n\tclr\tA;\n\tadc\tHADDR[2], A, SHARED_DATA_ADDR[2];\n\tadc\tHADDR[3], A, SHARED_DATA_ADDR[3];\n\tmov\tA, ACCUM_SAVE;\n\tbmov\tHADDR[4], ALLZEROS, 4;\n\t/* PKT_OVERRUN_BUFSIZE is a multiple of 256 */\n\tclr\tHCNT[0];\n\tmvi\tHCNT[1], ((PKT_OVERRUN_BUFSIZE >> 8) & 0xFF);\n\tclr\tHCNT[2] ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}