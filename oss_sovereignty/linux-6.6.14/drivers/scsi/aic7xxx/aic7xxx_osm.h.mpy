{
  "module_name": "aic7xxx_osm.h",
  "hash_id": "83a0e501c59de77793a77b0747d671c73bcab9e37a1219a2f8b450174ed176b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic7xxx_osm.h",
  "human_readable_source": " \n#ifndef _AIC7XXX_LINUX_H_\n#define _AIC7XXX_LINUX_H_\n\n#include <linux/types.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <asm/byteorder.h>\n#include <asm/io.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_spi.h>\n\n \n#define AIC_LIB_PREFIX ahc\n\n#include \"cam.h\"\n#include \"queue.h\"\n#include \"scsi_message.h\"\n#include \"aiclib.h\"\n\n \n#ifdef CONFIG_AIC7XXX_DEBUG_ENABLE\n#ifdef CONFIG_AIC7XXX_DEBUG_MASK\n#define AHC_DEBUG 1\n#define AHC_DEBUG_OPTS CONFIG_AIC7XXX_DEBUG_MASK\n#else\n \n#define AHC_DEBUG 1\n#endif\n \n#endif\n\n \nstruct ahc_softc;\ntypedef struct pci_dev *ahc_dev_softc_t;\ntypedef struct scsi_cmnd      *ahc_io_ctx_t;\n\n \n#define ahc_htobe16(x)\tcpu_to_be16(x)\n#define ahc_htobe32(x)\tcpu_to_be32(x)\n#define ahc_htobe64(x)\tcpu_to_be64(x)\n#define ahc_htole16(x)\tcpu_to_le16(x)\n#define ahc_htole32(x)\tcpu_to_le32(x)\n#define ahc_htole64(x)\tcpu_to_le64(x)\n\n#define ahc_be16toh(x)\tbe16_to_cpu(x)\n#define ahc_be32toh(x)\tbe32_to_cpu(x)\n#define ahc_be64toh(x)\tbe64_to_cpu(x)\n#define ahc_le16toh(x)\tle16_to_cpu(x)\n#define ahc_le32toh(x)\tle32_to_cpu(x)\n#define ahc_le64toh(x)\tle64_to_cpu(x)\n\n \nextern u_int aic7xxx_no_probe;\nextern u_int aic7xxx_allow_memio;\nextern struct scsi_host_template aic7xxx_driver_template;\n\n \n\ntypedef uint32_t bus_size_t;\n\ntypedef enum {\n\tBUS_SPACE_MEMIO,\n\tBUS_SPACE_PIO\n} bus_space_tag_t;\n\ntypedef union {\n\tu_long\t\t  ioport;\n\tvolatile uint8_t __iomem *maddr;\n} bus_space_handle_t;\n\ntypedef struct bus_dma_segment\n{\n\tdma_addr_t\tds_addr;\n\tbus_size_t\tds_len;\n} bus_dma_segment_t;\n\nstruct ahc_linux_dma_tag\n{\n\tbus_size_t\talignment;\n\tbus_size_t\tboundary;\n\tbus_size_t\tmaxsize;\n};\ntypedef struct ahc_linux_dma_tag* bus_dma_tag_t;\n\ntypedef dma_addr_t bus_dmamap_t;\n\ntypedef int bus_dma_filter_t(void*, dma_addr_t);\ntypedef void bus_dmamap_callback_t(void *, bus_dma_segment_t *, int, int);\n\n#define BUS_DMA_WAITOK\t\t0x0\n#define BUS_DMA_NOWAIT\t\t0x1\n#define BUS_DMA_ALLOCNOW\t0x2\n#define BUS_DMA_LOAD_SEGS\t0x4\t \n\n#define BUS_SPACE_MAXADDR\t0xFFFFFFFF\n#define BUS_SPACE_MAXADDR_32BIT\t0xFFFFFFFF\n#define BUS_SPACE_MAXSIZE_32BIT\t0xFFFFFFFF\n\nint\tahc_dma_tag_create(struct ahc_softc *, bus_dma_tag_t  ,\n\t\t\t   bus_size_t  , bus_size_t  ,\n\t\t\t   dma_addr_t  , dma_addr_t  ,\n\t\t\t   bus_dma_filter_t* , void * ,\n\t\t\t   bus_size_t  , int  ,\n\t\t\t   bus_size_t  , int  ,\n\t\t\t   bus_dma_tag_t * );\n\nvoid\tahc_dma_tag_destroy(struct ahc_softc *, bus_dma_tag_t  );\n\nint\tahc_dmamem_alloc(struct ahc_softc *, bus_dma_tag_t  ,\n\t\t\t void**  , int  ,\n\t\t\t bus_dmamap_t*  );\n\nvoid\tahc_dmamem_free(struct ahc_softc *, bus_dma_tag_t  ,\n\t\t\tvoid*  , bus_dmamap_t  );\n\nvoid\tahc_dmamap_destroy(struct ahc_softc *, bus_dma_tag_t  ,\n\t\t\t   bus_dmamap_t  );\n\nint\tahc_dmamap_load(struct ahc_softc *ahc, bus_dma_tag_t  ,\n\t\t\tbus_dmamap_t  , void *  ,\n\t\t\tbus_size_t  , bus_dmamap_callback_t *,\n\t\t\tvoid * , int  );\n\nint\tahc_dmamap_unload(struct ahc_softc *, bus_dma_tag_t, bus_dmamap_t);\n\n \n#define BUS_DMASYNC_PREREAD\t0x01\t \n#define BUS_DMASYNC_POSTREAD\t0x02\t \n#define BUS_DMASYNC_PREWRITE\t0x04\t \n#define BUS_DMASYNC_POSTWRITE\t0x08\t \n\n \n#define ahc_dmamap_sync(ahc, dma_tag, dmamap, offset, len, op)\n\n \n#ifdef CONFIG_AIC7XXX_REG_PRETTY_PRINT\n#define AIC_DEBUG_REGISTERS 1\n#else\n#define AIC_DEBUG_REGISTERS 0\n#endif\n#include \"aic7xxx.h\"\n\n \nstatic inline void\nahc_scb_timer_reset(struct scb *scb, u_int usec)\n{\n}\n\n \n#include <linux/spinlock.h>\n\n#define AIC7XXX_DRIVER_VERSION \"7.0\"\n\n \n \ntypedef enum {\n\tAHC_DEV_FREEZE_TIL_EMPTY = 0x02,  \n\tAHC_DEV_Q_BASIC\t\t = 0x10,  \n\tAHC_DEV_Q_TAGGED\t = 0x20,  \n\tAHC_DEV_PERIODIC_OTAG\t = 0x40,  \n} ahc_linux_dev_flags;\n\nstruct ahc_linux_device {\n\t \n\tint\t\t\tactive;\n\n\t \n\tint\t\t\topenings;\n\n\t \n\tu_int\t\t\tqfrozen;\n\n\t \n\tu_long\t\t\tcommands_issued;\n\n\t \n\tu_int\t\t\ttag_success_count;\n#define AHC_TAG_SUCCESS_INTERVAL 50\n\n\tahc_linux_dev_flags\tflags;\n\n\t \n\tu_int\t\t\tmaxtags;\n\n\t \n\tu_int\t\t\ttags_on_last_queuefull;\n\n\t \n\tu_int\t\t\tlast_queuefull_same_count;\n#define AHC_LOCK_TAGS_COUNT 50\n\n\t \n\tu_int\t\t\tcommands_since_idle_or_otag;\n#define AHC_OTAG_THRESH\t500\n};\n\n \n \n#define\tAHC_NSEG 128\n\n \nstruct scb_platform_data {\n\tstruct ahc_linux_device\t*dev;\n\tdma_addr_t\t\t buf_busaddr;\n\tuint32_t\t\t xfer_len;\n\tuint32_t\t\t sense_resid;\t \n};\n\n \nstruct ahc_platform_data {\n\t \n\tstruct scsi_target *starget[AHC_NUM_TARGETS];\n\n\tspinlock_t\t\t spin_lock;\n\tu_int\t\t\t qfrozen;\n\tstruct completion\t*eh_done;\n\tstruct Scsi_Host\t*host;\t\t \n#define AHC_LINUX_NOIRQ\t((uint32_t)~0)\n\tuint32_t\t\t irq;\t\t \n\tuint32_t\t\t bios_address;\n\tresource_size_t\t\t mem_busaddr;\t \n};\n\nvoid ahc_delay(long);\n\n\n \nuint8_t ahc_inb(struct ahc_softc * ahc, long port);\nvoid ahc_outb(struct ahc_softc * ahc, long port, uint8_t val);\nvoid ahc_outsb(struct ahc_softc * ahc, long port,\n\t       uint8_t *, int count);\nvoid ahc_insb(struct ahc_softc * ahc, long port,\n\t       uint8_t *, int count);\n\n \nint\t\tahc_linux_register_host(struct ahc_softc *,\n\t\t\t\t\tstruct scsi_host_template *);\n\n \n \n\nstatic inline void\nahc_lockinit(struct ahc_softc *ahc)\n{\n\tspin_lock_init(&ahc->platform_data->spin_lock);\n}\n\nstatic inline void\nahc_lock(struct ahc_softc *ahc, unsigned long *flags)\n{\n\tspin_lock_irqsave(&ahc->platform_data->spin_lock, *flags);\n}\n\nstatic inline void\nahc_unlock(struct ahc_softc *ahc, unsigned long *flags)\n{\n\tspin_unlock_irqrestore(&ahc->platform_data->spin_lock, *flags);\n}\n\n \n \n#define PCIR_DEVVENDOR\t\t0x00\n#define PCIR_VENDOR\t\t0x00\n#define PCIR_DEVICE\t\t0x02\n#define PCIR_COMMAND\t\t0x04\n#define PCIM_CMD_PORTEN\t\t0x0001\n#define PCIM_CMD_MEMEN\t\t0x0002\n#define PCIM_CMD_BUSMASTEREN\t0x0004\n#define PCIM_CMD_MWRICEN\t0x0010\n#define PCIM_CMD_PERRESPEN\t0x0040\n#define\tPCIM_CMD_SERRESPEN\t0x0100\n#define PCIR_STATUS\t\t0x06\n#define PCIR_REVID\t\t0x08\n#define PCIR_PROGIF\t\t0x09\n#define PCIR_SUBCLASS\t\t0x0a\n#define PCIR_CLASS\t\t0x0b\n#define PCIR_CACHELNSZ\t\t0x0c\n#define PCIR_LATTIMER\t\t0x0d\n#define PCIR_HEADERTYPE\t\t0x0e\n#define PCIM_MFDEV\t\t0x80\n#define PCIR_BIST\t\t0x0f\n#define PCIR_CAP_PTR\t\t0x34\n\n \n#define PCIR_MAPS\t0x10\n\ntypedef enum\n{\n\tAHC_POWER_STATE_D0,\n\tAHC_POWER_STATE_D1,\n\tAHC_POWER_STATE_D2,\n\tAHC_POWER_STATE_D3\n} ahc_power_state;\n\n \n#ifdef CONFIG_EISA\nint\t\t\t ahc_linux_eisa_init(void);\nvoid\t\t\t ahc_linux_eisa_exit(void);\nint\t\t\t aic7770_map_registers(struct ahc_softc *ahc,\n\t\t\t\t\t       u_int port);\nint\t\t\t aic7770_map_int(struct ahc_softc *ahc, u_int irq);\n#else\nstatic inline int\tahc_linux_eisa_init(void) {\n\treturn -ENODEV;\n}\nstatic inline void\tahc_linux_eisa_exit(void) {\n}\n#endif\n\n \n#ifdef CONFIG_PCI\nint\t\t\t ahc_linux_pci_init(void);\nvoid\t\t\t ahc_linux_pci_exit(void);\nint\t\t\t ahc_pci_map_registers(struct ahc_softc *ahc);\nint\t\t\t ahc_pci_map_int(struct ahc_softc *ahc);\n\nuint32_t\t\t ahc_pci_read_config(ahc_dev_softc_t pci,\n\t\t\t\t\t     int reg, int width);\n\nvoid\t\t\t ahc_pci_write_config(ahc_dev_softc_t pci,\n\t\t\t\t\t      int reg, uint32_t value,\n\t\t\t\t\t      int width);\n\nstatic inline int ahc_get_pci_function(ahc_dev_softc_t);\nstatic inline int\nahc_get_pci_function(ahc_dev_softc_t pci)\n{\n\treturn (PCI_FUNC(pci->devfn));\n}\n\nstatic inline int ahc_get_pci_slot(ahc_dev_softc_t);\nstatic inline int\nahc_get_pci_slot(ahc_dev_softc_t pci)\n{\n\treturn (PCI_SLOT(pci->devfn));\n}\n\nstatic inline int ahc_get_pci_bus(ahc_dev_softc_t);\nstatic inline int\nahc_get_pci_bus(ahc_dev_softc_t pci)\n{\n\treturn (pci->bus->number);\n}\n#else\nstatic inline int ahc_linux_pci_init(void) {\n\treturn 0;\n}\nstatic inline void ahc_linux_pci_exit(void) {\n}\n#endif\n\nstatic inline void ahc_flush_device_writes(struct ahc_softc *);\nstatic inline void\nahc_flush_device_writes(struct ahc_softc *ahc)\n{\n\t \n\tahc_inb(ahc, INTSTAT);\n}\n\n \nint\tahc_proc_write_seeprom(struct Scsi_Host *, char *, int);\nint\tahc_linux_show_info(struct seq_file *, struct Scsi_Host *);\n\n \n \n\nstatic inline\nvoid ahc_cmd_set_transaction_status(struct scsi_cmnd *cmd, uint32_t status)\n{\n\tcmd->result &= ~(CAM_STATUS_MASK << 16);\n\tcmd->result |= status << 16;\n}\n\nstatic inline\nvoid ahc_set_transaction_status(struct scb *scb, uint32_t status)\n{\n\tahc_cmd_set_transaction_status(scb->io_ctx,status);\n}\n\nstatic inline\nvoid ahc_cmd_set_scsi_status(struct scsi_cmnd *cmd, uint32_t status)\n{\n\tcmd->result &= ~0xFFFF;\n\tcmd->result |= status;\n}\n\nstatic inline\nvoid ahc_set_scsi_status(struct scb *scb, uint32_t status)\n{\n\tahc_cmd_set_scsi_status(scb->io_ctx, status);\n}\n\nstatic inline\nuint32_t ahc_cmd_get_transaction_status(struct scsi_cmnd *cmd)\n{\n\treturn ((cmd->result >> 16) & CAM_STATUS_MASK);\n}\n\nstatic inline\nuint32_t ahc_get_transaction_status(struct scb *scb)\n{\n\treturn (ahc_cmd_get_transaction_status(scb->io_ctx));\n}\n\nstatic inline\nuint32_t ahc_cmd_get_scsi_status(struct scsi_cmnd *cmd)\n{\n\treturn (cmd->result & 0xFFFF);\n}\n\nstatic inline\nuint32_t ahc_get_scsi_status(struct scb *scb)\n{\n\treturn (ahc_cmd_get_scsi_status(scb->io_ctx));\n}\n\nstatic inline\nvoid ahc_set_transaction_tag(struct scb *scb, int enabled, u_int type)\n{\n\t \n}\n\nstatic inline\nu_long ahc_get_transfer_length(struct scb *scb)\n{\n\treturn (scb->platform_data->xfer_len);\n}\n\nstatic inline\nint ahc_get_transfer_dir(struct scb *scb)\n{\n\treturn (scb->io_ctx->sc_data_direction);\n}\n\nstatic inline\nvoid ahc_set_residual(struct scb *scb, u_long resid)\n{\n\tscsi_set_resid(scb->io_ctx, resid);\n}\n\nstatic inline\nvoid ahc_set_sense_residual(struct scb *scb, u_long resid)\n{\n\tscb->platform_data->sense_resid = resid;\n}\n\nstatic inline\nu_long ahc_get_residual(struct scb *scb)\n{\n\treturn scsi_get_resid(scb->io_ctx);\n}\n\nstatic inline\nu_long ahc_get_sense_residual(struct scb *scb)\n{\n\treturn (scb->platform_data->sense_resid);\n}\n\nstatic inline\nint ahc_perform_autosense(struct scb *scb)\n{\n\t \n\treturn (1);\n}\n\nstatic inline uint32_t\nahc_get_sense_bufsize(struct ahc_softc *ahc, struct scb *scb)\n{\n\treturn (sizeof(struct scsi_sense_data));\n}\n\nstatic inline void\nahc_notify_xfer_settings_change(struct ahc_softc *ahc,\n\t\t\t\tstruct ahc_devinfo *devinfo)\n{\n\t \n}\n\nstatic inline void\nahc_platform_scb_free(struct ahc_softc *ahc, struct scb *scb)\n{\n}\n\nint\tahc_platform_alloc(struct ahc_softc *ahc, void *platform_arg);\nvoid\tahc_platform_free(struct ahc_softc *ahc);\nvoid\tahc_platform_freeze_devq(struct ahc_softc *ahc, struct scb *scb);\n\nstatic inline void\nahc_freeze_scb(struct scb *scb)\n{\n\tif ((scb->io_ctx->result & (CAM_DEV_QFRZN << 16)) == 0) {\n\t\tscb->io_ctx->result |= CAM_DEV_QFRZN << 16;\n\t\tscb->platform_data->dev->qfrozen++;\n\t}\n}\n\nvoid\tahc_platform_set_tags(struct ahc_softc *ahc, struct scsi_device *sdev,\n\t\t\t      struct ahc_devinfo *devinfo, ahc_queue_alg);\nint\tahc_platform_abort_scbs(struct ahc_softc *ahc, int target,\n\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\trole_t role, uint32_t status);\nirqreturn_t\n\tahc_linux_isr(int irq, void *dev_id);\nvoid\tahc_platform_flushwork(struct ahc_softc *ahc);\nvoid\tahc_done(struct ahc_softc*, struct scb*);\nvoid\tahc_send_async(struct ahc_softc *, char channel,\n\t\t       u_int target, u_int lun, ac_code);\nvoid\tahc_print_path(struct ahc_softc *, struct scb *);\n\n#ifdef CONFIG_PCI\n#define AHC_PCI_CONFIG 1\n#else\n#define AHC_PCI_CONFIG 0\n#endif\n#define bootverbose aic7xxx_verbose\nextern u_int aic7xxx_verbose;\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}