{
  "module_name": "aic7xxx_osm_pci.c",
  "hash_id": "dafdefd6bd9697eef84c1966308feaf4fd00cc509c415aa47eda91ebe0195bcd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c",
  "human_readable_source": " \n\n#include \"aic7xxx_osm.h\"\n#include \"aic7xxx_pci.h\"\n\n \n#define ID(x)\tID_C(x, PCI_CLASS_STORAGE_SCSI)\n\nstatic const struct pci_device_id ahc_linux_pci_id_table[] = {\n\t \n\tID(ID_AHA_2902_04_10_15_20C_30C),\n\t \n\tID(ID_AHA_2930CU),\n\tID(ID_AHA_1480A & ID_DEV_VENDOR_MASK),\n\tID(ID_AHA_2940AU_0 & ID_DEV_VENDOR_MASK),\n\tID(ID_AHA_2940AU_CN & ID_DEV_VENDOR_MASK),\n\tID(ID_AHA_2930C_VAR & ID_DEV_VENDOR_MASK),\n\t \n\tID(ID_AHA_2940),\n\tID(ID_AHA_3940),\n\tID(ID_AHA_398X),\n\tID(ID_AHA_2944),\n\tID(ID_AHA_3944),\n\tID(ID_AHA_4944),\n\t \n\tID(ID_AHA_2940U & ID_DEV_VENDOR_MASK),\n\tID(ID_AHA_3940U & ID_DEV_VENDOR_MASK),\n\tID(ID_AHA_2944U & ID_DEV_VENDOR_MASK),\n\tID(ID_AHA_3944U & ID_DEV_VENDOR_MASK),\n\tID(ID_AHA_398XU & ID_DEV_VENDOR_MASK),\n\tID(ID_AHA_4944U & ID_DEV_VENDOR_MASK),\n\tID(ID_AHA_2930U & ID_DEV_VENDOR_MASK),\n\tID(ID_AHA_2940U_PRO & ID_DEV_VENDOR_MASK),\n\tID(ID_AHA_2940U_CN & ID_DEV_VENDOR_MASK),\n\t \n\tID(ID_AHA_2930U2),\n\tID(ID_AHA_2940U2B),\n\tID(ID_AHA_2940U2_OEM),\n\tID(ID_AHA_2940U2),\n\tID(ID_AHA_2950U2B),\n\tID16(ID_AIC7890_ARO & ID_AIC7895_ARO_MASK),\n\tID(ID_AAA_131U2),\n\t \n\tID(ID_AHA_29160),\n\tID(ID_AHA_29160_CPQ),\n\tID(ID_AHA_29160N),\n\tID(ID_AHA_29160C),\n\tID(ID_AHA_29160B),\n\tID(ID_AHA_19160B),\n\tID(ID_AIC7892_ARO),\n\t \n\tID(ID_AHA_2940U_DUAL),\n\tID(ID_AHA_3940AU),\n\tID(ID_AHA_3944AU),\n\tID(ID_AIC7895_ARO),\n\tID(ID_AHA_3950U2B_0),\n\tID(ID_AHA_3950U2B_1),\n\tID(ID_AHA_3950U2D_0),\n\tID(ID_AHA_3950U2D_1),\n\tID(ID_AIC7896_ARO),\n\t \n\tID(ID_AHA_3960D),\n\tID(ID_AHA_3960D_CPQ),\n\tID(ID_AIC7899_ARO),\n\t \n\tID(ID_AIC7850 & ID_DEV_VENDOR_MASK),\n\tID(ID_AIC7855 & ID_DEV_VENDOR_MASK),\n\tID(ID_AIC7859 & ID_DEV_VENDOR_MASK),\n\tID(ID_AIC7860 & ID_DEV_VENDOR_MASK),\n\tID(ID_AIC7870 & ID_DEV_VENDOR_MASK),\n\tID(ID_AIC7880 & ID_DEV_VENDOR_MASK),\n \tID16(ID_AIC7890 & ID_9005_GENERIC_MASK),\n \tID16(ID_AIC7892 & ID_9005_GENERIC_MASK),\n\tID(ID_AIC7895 & ID_DEV_VENDOR_MASK),\n\tID16(ID_AIC7896 & ID_9005_GENERIC_MASK),\n\tID16(ID_AIC7899 & ID_9005_GENERIC_MASK),\n\tID(ID_AIC7810 & ID_DEV_VENDOR_MASK),\n\tID(ID_AIC7815 & ID_DEV_VENDOR_MASK),\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(pci, ahc_linux_pci_id_table);\n\nstatic int __maybe_unused\nahc_linux_pci_dev_suspend(struct device *dev)\n{\n\tstruct ahc_softc *ahc = dev_get_drvdata(dev);\n\n\treturn ahc_suspend(ahc);\n}\n\nstatic int __maybe_unused\nahc_linux_pci_dev_resume(struct device *dev)\n{\n\tstruct ahc_softc *ahc = dev_get_drvdata(dev);\n\n\tahc_pci_resume(ahc);\n\n\treturn (ahc_resume(ahc));\n}\n\nstatic void\nahc_linux_pci_dev_remove(struct pci_dev *pdev)\n{\n\tstruct ahc_softc *ahc = pci_get_drvdata(pdev);\n\tu_long s;\n\n\tif (ahc->platform_data && ahc->platform_data->host)\n\t\t\tscsi_remove_host(ahc->platform_data->host);\n\n\tahc_lock(ahc, &s);\n\tahc_intr_enable(ahc, FALSE);\n\tahc_unlock(ahc, &s);\n\tahc_free(ahc);\n}\n\nstatic void\nahc_linux_pci_inherit_flags(struct ahc_softc *ahc)\n{\n\tstruct pci_dev *pdev = ahc->dev_softc, *master_pdev;\n\tunsigned int master_devfn = PCI_DEVFN(PCI_SLOT(pdev->devfn), 0);\n\n\tmaster_pdev = pci_get_slot(pdev->bus, master_devfn);\n\tif (master_pdev) {\n\t\tstruct ahc_softc *master = pci_get_drvdata(master_pdev);\n\t\tif (master) {\n\t\t\tahc->flags &= ~AHC_BIOS_ENABLED; \n\t\t\tahc->flags |= master->flags & AHC_BIOS_ENABLED;\n\n\t\t\tahc->flags &= ~AHC_PRIMARY_CHANNEL; \n\t\t\tahc->flags |= master->flags & AHC_PRIMARY_CHANNEL;\n\t\t} else\n\t\t\tprintk(KERN_ERR \"aic7xxx: no multichannel peer found!\\n\");\n\t\tpci_dev_put(master_pdev);\n\t} \n}\n\nstatic int\nahc_linux_pci_dev_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tchar\t\t buf[80];\n\tconst uint64_t\t mask_39bit = 0x7FFFFFFFFFULL;\n\tstruct\t\t ahc_softc *ahc;\n\tahc_dev_softc_t\t pci;\n\tconst struct ahc_pci_identity *entry;\n\tchar\t\t*name;\n\tint\t\t error;\n\tstruct device\t*dev = &pdev->dev;\n\n\tpci = pdev;\n\tentry = ahc_find_pci_device(pci);\n\tif (entry == NULL)\n\t\treturn (-ENODEV);\n\n\t \n\tsprintf(buf, \"ahc_pci:%d:%d:%d\",\n\t\tahc_get_pci_bus(pci),\n\t\tahc_get_pci_slot(pci),\n\t\tahc_get_pci_function(pci));\n\tname = kstrdup(buf, GFP_ATOMIC);\n\tif (name == NULL)\n\t\treturn (-ENOMEM);\n\tahc = ahc_alloc(NULL, name);\n\tif (ahc == NULL)\n\t\treturn (-ENOMEM);\n\tif (pci_enable_device(pdev)) {\n\t\tahc_free(ahc);\n\t\treturn (-ENODEV);\n\t}\n\tpci_set_master(pdev);\n\n\tif (sizeof(dma_addr_t) > 4\n\t    && ahc->features & AHC_LARGE_SCBS\n\t    && dma_set_mask(dev, mask_39bit) == 0\n\t    && dma_get_required_mask(dev) > DMA_BIT_MASK(32)) {\n\t\tahc->flags |= AHC_39BIT_ADDRESSING;\n\t} else {\n\t\tif (dma_set_mask(dev, DMA_BIT_MASK(32))) {\n\t\t\tahc_free(ahc);\n\t\t\tprintk(KERN_WARNING \"aic7xxx: No suitable DMA available.\\n\");\n                \treturn (-ENODEV);\n\t\t}\n\t}\n\tahc->dev_softc = pci;\n\tahc->dev = &pci->dev;\n\terror = ahc_pci_config(ahc, entry);\n\tif (error != 0) {\n\t\tahc_free(ahc);\n\t\treturn (-error);\n\t}\n\n\t \n\tif ((ahc->features & AHC_MULTI_FUNC) && PCI_FUNC(pdev->devfn) != 0)\n\t\tahc_linux_pci_inherit_flags(ahc);\n\n\tpci_set_drvdata(pdev, ahc);\n\tahc_linux_register_host(ahc, &aic7xxx_driver_template);\n\treturn (0);\n}\n\n \nuint32_t\nahc_pci_read_config(ahc_dev_softc_t pci, int reg, int width)\n{\n\tswitch (width) {\n\tcase 1:\n\t{\n\t\tuint8_t retval;\n\n\t\tpci_read_config_byte(pci, reg, &retval);\n\t\treturn (retval);\n\t}\n\tcase 2:\n\t{\n\t\tuint16_t retval;\n\t\tpci_read_config_word(pci, reg, &retval);\n\t\treturn (retval);\n\t}\n\tcase 4:\n\t{\n\t\tuint32_t retval;\n\t\tpci_read_config_dword(pci, reg, &retval);\n\t\treturn (retval);\n\t}\n\tdefault:\n\t\tpanic(\"ahc_pci_read_config: Read size too big\");\n\t\t \n\t\treturn (0);\n\t}\n}\n\nvoid\nahc_pci_write_config(ahc_dev_softc_t pci, int reg, uint32_t value, int width)\n{\n\tswitch (width) {\n\tcase 1:\n\t\tpci_write_config_byte(pci, reg, value);\n\t\tbreak;\n\tcase 2:\n\t\tpci_write_config_word(pci, reg, value);\n\t\tbreak;\n\tcase 4:\n\t\tpci_write_config_dword(pci, reg, value);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"ahc_pci_write_config: Write size too big\");\n\t\t \n\t}\n}\n\nstatic SIMPLE_DEV_PM_OPS(ahc_linux_pci_dev_pm_ops,\n\t\t\t ahc_linux_pci_dev_suspend,\n\t\t\t ahc_linux_pci_dev_resume);\n\nstatic struct pci_driver aic7xxx_pci_driver = {\n\t.name\t\t= \"aic7xxx\",\n\t.probe\t\t= ahc_linux_pci_dev_probe,\n\t.driver.pm\t= &ahc_linux_pci_dev_pm_ops,\n\t.remove\t\t= ahc_linux_pci_dev_remove,\n\t.id_table\t= ahc_linux_pci_id_table\n};\n\nint\nahc_linux_pci_init(void)\n{\n\treturn pci_register_driver(&aic7xxx_pci_driver);\n}\n\nvoid\nahc_linux_pci_exit(void)\n{\n\tpci_unregister_driver(&aic7xxx_pci_driver);\n}\n\nstatic int\nahc_linux_pci_reserve_io_region(struct ahc_softc *ahc, resource_size_t *base)\n{\n\tif (aic7xxx_allow_memio == 0)\n\t\treturn (ENOMEM);\n\n\t*base = pci_resource_start(ahc->dev_softc, 0);\n\tif (*base == 0)\n\t\treturn (ENOMEM);\n\tif (!request_region(*base, 256, \"aic7xxx\"))\n\t\treturn (ENOMEM);\n\treturn (0);\n}\n\nstatic int\nahc_linux_pci_reserve_mem_region(struct ahc_softc *ahc,\n\t\t\t\t resource_size_t *bus_addr,\n\t\t\t\t uint8_t __iomem **maddr)\n{\n\tresource_size_t\tstart;\n\tint\terror;\n\n\terror = 0;\n\tstart = pci_resource_start(ahc->dev_softc, 1);\n\tif (start != 0) {\n\t\t*bus_addr = start;\n\t\tif (!request_mem_region(start, 0x1000, \"aic7xxx\"))\n\t\t\terror = ENOMEM;\n\t\tif (error == 0) {\n\t\t\t*maddr = ioremap(start, 256);\n\t\t\tif (*maddr == NULL) {\n\t\t\t\terror = ENOMEM;\n\t\t\t\trelease_mem_region(start, 0x1000);\n\t\t\t}\n\t\t}\n\t} else\n\t\terror = ENOMEM;\n\treturn (error);\n}\n\nint\nahc_pci_map_registers(struct ahc_softc *ahc)\n{\n\tuint32_t command;\n\tresource_size_t\tbase;\n\tuint8_t\t__iomem *maddr;\n\tint\t error;\n\n\t \n\tcommand = ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND, 4);\n\tcommand &= ~(PCIM_CMD_PORTEN|PCIM_CMD_MEMEN);\n\tbase = 0;\n\tmaddr = NULL;\n\terror = ahc_linux_pci_reserve_mem_region(ahc, &base, &maddr);\n\tif (error == 0) {\n\t\tahc->platform_data->mem_busaddr = base;\n\t\tahc->tag = BUS_SPACE_MEMIO;\n\t\tahc->bsh.maddr = maddr;\n\t\tahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND,\n\t\t\t\t     command | PCIM_CMD_MEMEN, 4);\n\n\t\t \n\t\tif (ahc_pci_test_register_access(ahc) != 0) {\n\n\t\t\tprintk(\"aic7xxx: PCI Device %d:%d:%d \"\n\t\t\t       \"failed memory mapped test.  Using PIO.\\n\",\n\t\t\t       ahc_get_pci_bus(ahc->dev_softc),\n\t\t\t       ahc_get_pci_slot(ahc->dev_softc),\n\t\t\t       ahc_get_pci_function(ahc->dev_softc));\n\t\t\tiounmap(maddr);\n\t\t\trelease_mem_region(ahc->platform_data->mem_busaddr,\n\t\t\t\t\t   0x1000);\n\t\t\tahc->bsh.maddr = NULL;\n\t\t\tmaddr = NULL;\n\t\t} else\n\t\t\tcommand |= PCIM_CMD_MEMEN;\n\t} else {\n\t\tprintk(\"aic7xxx: PCI%d:%d:%d MEM region 0x%llx \"\n\t\t       \"unavailable. Cannot memory map device.\\n\",\n\t\t       ahc_get_pci_bus(ahc->dev_softc),\n\t\t       ahc_get_pci_slot(ahc->dev_softc),\n\t\t       ahc_get_pci_function(ahc->dev_softc),\n\t\t       (unsigned long long)base);\n\t}\n\n\t \n\tif (maddr == NULL) {\n\n\t\terror = ahc_linux_pci_reserve_io_region(ahc, &base);\n\t\tif (error == 0) {\n\t\t\tahc->tag = BUS_SPACE_PIO;\n\t\t\tahc->bsh.ioport = (u_long)base;\n\t\t\tcommand |= PCIM_CMD_PORTEN;\n\t\t} else {\n\t\t\tprintk(\"aic7xxx: PCI%d:%d:%d IO region 0x%llx[0..255] \"\n\t\t\t       \"unavailable. Cannot map device.\\n\",\n\t\t\t       ahc_get_pci_bus(ahc->dev_softc),\n\t\t\t       ahc_get_pci_slot(ahc->dev_softc),\n\t\t\t       ahc_get_pci_function(ahc->dev_softc),\n\t\t\t       (unsigned long long)base);\n\t\t}\n\t}\n\tahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, command, 4);\n\treturn (error);\n}\n\nint\nahc_pci_map_int(struct ahc_softc *ahc)\n{\n\tint error;\n\n\terror = request_irq(ahc->dev_softc->irq, ahc_linux_isr,\n\t\t\t    IRQF_SHARED, \"aic7xxx\", ahc);\n\tif (error == 0)\n\t\tahc->platform_data->irq = ahc->dev_softc->irq;\n\t\n\treturn (-error);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}