{
  "module_name": "aic7xxx_93cx6.c",
  "hash_id": "ccf4503bd4095474c7a66e0d2c30af43eee182c21f33672ac0232d966f9d67b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic7xxx_93cx6.c",
  "human_readable_source": " \n\n \n\n#include \"aic7xxx_osm.h\"\n#include \"aic7xxx_inline.h\"\n#include \"aic7xxx_93cx6.h\"\n\n \nstruct seeprom_cmd {\n\tuint8_t len;\n\tuint8_t bits[11];\n};\n\n \nstatic const struct seeprom_cmd seeprom_ewen = {9, {1, 0, 0, 1, 1, 0, 0, 0, 0}};\nstatic const struct seeprom_cmd seeprom_ewds = {9, {1, 0, 0, 0, 0, 0, 0, 0, 0}};\n\n \nstatic const struct seeprom_cmd seeprom_long_ewen = {11, {1, 0, 0, 1, 1, 0, 0, 0, 0}};\nstatic const struct seeprom_cmd seeprom_long_ewds = {11, {1, 0, 0, 0, 0, 0, 0, 0, 0}};\n\n \nstatic const struct seeprom_cmd seeprom_write = {3, {1, 0, 1}};\nstatic const struct seeprom_cmd seeprom_read  = {3, {1, 1, 0}};\n\n \n#define CLOCK_PULSE(sd, rdy)\t\t\t\t\\\n\twhile ((SEEPROM_STATUS_INB(sd) & rdy) == 0) {\t\\\n\t\t;   \t\t\t\\\n\t}\t\t\t\t\t\t\\\n\t(void)SEEPROM_INB(sd);\t \n\n \nstatic void\nsend_seeprom_cmd(struct seeprom_descriptor *sd, const struct seeprom_cmd *cmd)\n{\n\tuint8_t temp;\n\tint i = 0;\n\n\t \n\ttemp = sd->sd_MS ^ sd->sd_CS;\n\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\tCLOCK_PULSE(sd, sd->sd_RDY);\n\n\tfor (i = 0; i < cmd->len; i++) {\n\t\tif (cmd->bits[i] != 0)\n\t\t\ttemp ^= sd->sd_DO;\n\t\tSEEPROM_OUTB(sd, temp);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\tif (cmd->bits[i] != 0)\n\t\t\ttemp ^= sd->sd_DO;\n\t}\n}\n\n \nstatic void\nreset_seeprom(struct seeprom_descriptor *sd)\n{\n\tuint8_t temp;\n\n\ttemp = sd->sd_MS;\n\tSEEPROM_OUTB(sd, temp);\n\tCLOCK_PULSE(sd, sd->sd_RDY);\n\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\tCLOCK_PULSE(sd, sd->sd_RDY);\n\tSEEPROM_OUTB(sd, temp);\n\tCLOCK_PULSE(sd, sd->sd_RDY);\n}\n\n \nint\nahc_read_seeprom(struct seeprom_descriptor *sd, uint16_t *buf,\n\t\t u_int start_addr, u_int count)\n{\n\tint i = 0;\n\tu_int k = 0;\n\tuint16_t v;\n\tuint8_t temp;\n\n\t \n\tfor (k = start_addr; k < count + start_addr; k++) {\n\t\t \n\t\tsend_seeprom_cmd(sd, &seeprom_read);\n\n\t\t \n\t\ttemp = sd->sd_MS ^ sd->sd_CS;\n\t\tfor (i = (sd->sd_chip - 1); i >= 0; i--) {\n\t\t\tif ((k & (1 << i)) != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tif ((k & (1 << i)) != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t}\n\n\t\t \n\t\tv = 0;\n\t\tfor (i = 16; i >= 0; i--) {\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tv <<= 1;\n\t\t\tif (SEEPROM_DATA_INB(sd) & sd->sd_DI)\n\t\t\t\tv |= 1;\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t}\n\n\t\tbuf[k - start_addr] = v;\n\n\t\t \n\t\treset_seeprom(sd);\n\t}\n#ifdef AHC_DUMP_EEPROM\n\tprintk(\"\\nSerial EEPROM:\\n\\t\");\n\tfor (k = 0; k < count; k = k + 1) {\n\t\tif (((k % 8) == 0) && (k != 0)) {\n\t\t\tprintk(KERN_CONT \"\\n\\t\");\n\t\t}\n\t\tprintk(KERN_CONT \" 0x%x\", buf[k]);\n\t}\n\tprintk(KERN_CONT \"\\n\");\n#endif\n\treturn (1);\n}\n\n \nint\nahc_write_seeprom(struct seeprom_descriptor *sd, uint16_t *buf,\n\t\t  u_int start_addr, u_int count)\n{\n\tconst struct seeprom_cmd *ewen, *ewds;\n\tuint16_t v;\n\tuint8_t temp;\n\tint i, k;\n\n\t \n\tif (sd->sd_chip == C46) {\n\t\tewen = &seeprom_ewen;\n\t\tewds = &seeprom_ewds;\n\t} else if (sd->sd_chip == C56_66) {\n\t\tewen = &seeprom_long_ewen;\n\t\tewds = &seeprom_long_ewds;\n\t} else {\n\t\tprintk(\"ahc_write_seeprom: unsupported seeprom type %d\\n\",\n\t\t       sd->sd_chip);\n\t\treturn (0);\n\t}\n\n\tsend_seeprom_cmd(sd, ewen);\n\treset_seeprom(sd);\n\n\t \n\ttemp = sd->sd_MS ^ sd->sd_CS;\n\tfor (k = start_addr; k < count + start_addr; k++) {\n\t\t \n\t\tsend_seeprom_cmd(sd, &seeprom_write);\n\n\t\t \n\t\tfor (i = (sd->sd_chip - 1); i >= 0; i--) {\n\t\t\tif ((k & (1 << i)) != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tif ((k & (1 << i)) != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t}\n\n\t\t \n\t\tv = buf[k - start_addr];\n\t\tfor (i = 15; i >= 0; i--) {\n\t\t\tif ((v & (1 << i)) != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tif ((v & (1 << i)) != 0)\n\t\t\t\ttemp ^= sd->sd_DO;\n\t\t}\n\n\t\t \n\t\ttemp = sd->sd_MS;\n\t\tSEEPROM_OUTB(sd, temp);\n\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\ttemp = sd->sd_MS ^ sd->sd_CS;\n\t\tdo {\n\t\t\tSEEPROM_OUTB(sd, temp);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t\tSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\n\t\t\tCLOCK_PULSE(sd, sd->sd_RDY);\n\t\t} while ((SEEPROM_DATA_INB(sd) & sd->sd_DI) == 0);\n\n\t\treset_seeprom(sd);\n\t}\n\n\t \n\tsend_seeprom_cmd(sd, ewds);\n\treset_seeprom(sd);\n\n\treturn (1);\n}\n\nint\nahc_verify_cksum(struct seeprom_config *sc)\n{\n\tint i;\n\tint maxaddr;\n\tuint32_t checksum;\n\tuint16_t *scarray;\n\n\tmaxaddr = (sizeof(*sc)/2) - 1;\n\tchecksum = 0;\n\tscarray = (uint16_t *)sc;\n\n\tfor (i = 0; i < maxaddr; i++)\n\t\tchecksum = checksum + scarray[i];\n\tif (checksum == 0\n\t || (checksum & 0xFFFF) != sc->checksum) {\n\t\treturn (0);\n\t} else {\n\t\treturn(1);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}