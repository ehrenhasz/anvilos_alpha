{
  "module_name": "aic79xx_osm_pci.c",
  "hash_id": "f5fa5d5ee03fc8e6babe0401a296ae1c7d31c9a2a9b9c85b0ef0605603354c85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic79xx_osm_pci.c",
  "human_readable_source": " \n\n#include \"aic79xx_osm.h\"\n#include \"aic79xx_inline.h\"\n#include \"aic79xx_pci.h\"\n\n \n#define ID(x)\t\t \\\n\tID2C(x),\t \\\n\tID2C(IDIROC(x))\n\nstatic const struct pci_device_id ahd_linux_pci_id_table[] = {\n\t \n\tID(ID_AHA_29320A),\n\tID(ID_AHA_29320ALP),\n\tID(ID_AHA_29320LPE),\n\t \n\tID(ID_AHA_29320),\n\tID(ID_AHA_29320B),\n\tID(ID_AHA_29320LP),\n\tID(ID_AHA_39320),\n\tID(ID_AHA_39320_B),\n\tID(ID_AHA_39320A),\n\tID(ID_AHA_39320D),\n\tID(ID_AHA_39320D_HP),\n\tID(ID_AHA_39320D_B),\n\tID(ID_AHA_39320D_B_HP),\n\t \n\tID16(ID_AIC7901 & ID_9005_GENERIC_MASK),\n\tID(ID_AIC7901A & ID_DEV_VENDOR_MASK),\n\tID16(ID_AIC7902 & ID_9005_GENERIC_MASK),\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(pci, ahd_linux_pci_id_table);\n\nstatic int __maybe_unused\nahd_linux_pci_dev_suspend(struct device *dev)\n{\n\tstruct ahd_softc *ahd = dev_get_drvdata(dev);\n\tint rc;\n\n\tif ((rc = ahd_suspend(ahd)))\n\t\treturn rc;\n\n\tahd_pci_suspend(ahd);\n\n\treturn rc;\n}\n\nstatic int __maybe_unused\nahd_linux_pci_dev_resume(struct device *dev)\n{\n\tstruct ahd_softc *ahd = dev_get_drvdata(dev);\n\n\tahd_pci_resume(ahd);\n\n\tahd_resume(ahd);\n\n\treturn 0;\n}\n\nstatic void\nahd_linux_pci_dev_remove(struct pci_dev *pdev)\n{\n\tstruct ahd_softc *ahd = pci_get_drvdata(pdev);\n\tu_long s;\n\n\tif (ahd->platform_data && ahd->platform_data->host)\n\t\t\tscsi_remove_host(ahd->platform_data->host);\n\n\tahd_lock(ahd, &s);\n\tahd_intr_enable(ahd, FALSE);\n\tahd_unlock(ahd, &s);\n\tahd_free(ahd);\n}\n\nstatic void\nahd_linux_pci_inherit_flags(struct ahd_softc *ahd)\n{\n\tstruct pci_dev *pdev = ahd->dev_softc, *master_pdev;\n\tunsigned int master_devfn = PCI_DEVFN(PCI_SLOT(pdev->devfn), 0);\n\n\tmaster_pdev = pci_get_slot(pdev->bus, master_devfn);\n\tif (master_pdev) {\n\t\tstruct ahd_softc *master = pci_get_drvdata(master_pdev);\n\t\tif (master) {\n\t\t\tahd->flags &= ~AHD_BIOS_ENABLED;\n\t\t\tahd->flags |= master->flags & AHD_BIOS_ENABLED;\n\t\t} else\n\t\t\tprintk(KERN_ERR \"aic79xx: no multichannel peer found!\\n\");\n\t\tpci_dev_put(master_pdev);\n\t}\n}\n\nstatic int\nahd_linux_pci_dev_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tchar\t\t buf[80];\n\tstruct\t\t ahd_softc *ahd;\n\tahd_dev_softc_t\t pci;\n\tconst struct ahd_pci_identity *entry;\n\tchar\t\t*name;\n\tint\t\t error;\n\tstruct device\t*dev = &pdev->dev;\n\n\tpci = pdev;\n\tentry = ahd_find_pci_device(pci);\n\tif (entry == NULL)\n\t\treturn (-ENODEV);\n\n\t \n\tsprintf(buf, \"ahd_pci:%d:%d:%d\",\n\t\tahd_get_pci_bus(pci),\n\t\tahd_get_pci_slot(pci),\n\t\tahd_get_pci_function(pci));\n\tname = kstrdup(buf, GFP_ATOMIC);\n\tif (name == NULL)\n\t\treturn (-ENOMEM);\n\tahd = ahd_alloc(NULL, name);\n\tif (ahd == NULL)\n\t\treturn (-ENOMEM);\n\tif (pci_enable_device(pdev)) {\n\t\tahd_free(ahd);\n\t\treturn (-ENODEV);\n\t}\n\tpci_set_master(pdev);\n\n\tif (sizeof(dma_addr_t) > 4) {\n\t\tconst u64 required_mask = dma_get_required_mask(dev);\n\n\t\tif (required_mask > DMA_BIT_MASK(39) &&\n\t\t    dma_set_mask(dev, DMA_BIT_MASK(64)) == 0)\n\t\t\tahd->flags |= AHD_64BIT_ADDRESSING;\n\t\telse if (required_mask > DMA_BIT_MASK(32) &&\n\t\t\t dma_set_mask(dev, DMA_BIT_MASK(39)) == 0)\n\t\t\tahd->flags |= AHD_39BIT_ADDRESSING;\n\t\telse\n\t\t\tdma_set_mask(dev, DMA_BIT_MASK(32));\n\t} else {\n\t\tdma_set_mask(dev, DMA_BIT_MASK(32));\n\t}\n\tahd->dev_softc = pci;\n\terror = ahd_pci_config(ahd, entry);\n\tif (error != 0) {\n\t\tahd_free(ahd);\n\t\treturn (-error);\n\t}\n\n\t \n\tif ((ahd->features & AHD_MULTI_FUNC) && PCI_FUNC(pdev->devfn) != 0)\n\t\tahd_linux_pci_inherit_flags(ahd);\n\n\tpci_set_drvdata(pdev, ahd);\n\n\tahd_linux_register_host(ahd, &aic79xx_driver_template);\n\treturn (0);\n}\n\nstatic SIMPLE_DEV_PM_OPS(ahd_linux_pci_dev_pm_ops,\n\t\t\t ahd_linux_pci_dev_suspend,\n\t\t\t ahd_linux_pci_dev_resume);\n\nstatic struct pci_driver aic79xx_pci_driver = {\n\t.name\t\t= \"aic79xx\",\n\t.probe\t\t= ahd_linux_pci_dev_probe,\n\t.driver.pm\t= &ahd_linux_pci_dev_pm_ops,\n\t.remove\t\t= ahd_linux_pci_dev_remove,\n\t.id_table\t= ahd_linux_pci_id_table\n};\n\nint\nahd_linux_pci_init(void)\n{\n\treturn pci_register_driver(&aic79xx_pci_driver);\n}\n\nvoid\nahd_linux_pci_exit(void)\n{\n\tpci_unregister_driver(&aic79xx_pci_driver);\n}\n\nstatic int\nahd_linux_pci_reserve_io_regions(struct ahd_softc *ahd, resource_size_t *base,\n\t\t\t\t resource_size_t *base2)\n{\n\t*base = pci_resource_start(ahd->dev_softc, 0);\n\t \n\t*base2 = pci_resource_start(ahd->dev_softc, 3);\n\tif (*base == 0 || *base2 == 0)\n\t\treturn (ENOMEM);\n\tif (!request_region(*base, 256, \"aic79xx\"))\n\t\treturn (ENOMEM);\n\tif (!request_region(*base2, 256, \"aic79xx\")) {\n\t\trelease_region(*base, 256);\n\t\treturn (ENOMEM);\n\t}\n\treturn (0);\n}\n\nstatic int\nahd_linux_pci_reserve_mem_region(struct ahd_softc *ahd,\n\t\t\t\t resource_size_t *bus_addr,\n\t\t\t\t uint8_t __iomem **maddr)\n{\n\tresource_size_t\tstart;\n\tresource_size_t\tbase_page;\n\tu_long\tbase_offset;\n\tint\terror = 0;\n\n\tif (aic79xx_allow_memio == 0)\n\t\treturn (ENOMEM);\n\n\tif ((ahd->bugs & AHD_PCIX_MMAPIO_BUG) != 0)\n\t\treturn (ENOMEM);\n\n\tstart = pci_resource_start(ahd->dev_softc, 1);\n\tbase_page = start & PAGE_MASK;\n\tbase_offset = start - base_page;\n\tif (start != 0) {\n\t\t*bus_addr = start;\n\t\tif (!request_mem_region(start, 0x1000, \"aic79xx\"))\n\t\t\terror = ENOMEM;\n\t\tif (!error) {\n\t\t\t*maddr = ioremap(base_page, base_offset + 512);\n\t\t\tif (*maddr == NULL) {\n\t\t\t\terror = ENOMEM;\n\t\t\t\trelease_mem_region(start, 0x1000);\n\t\t\t} else\n\t\t\t\t*maddr += base_offset;\n\t\t}\n\t} else\n\t\terror = ENOMEM;\n\treturn (error);\n}\n\nint\nahd_pci_map_registers(struct ahd_softc *ahd)\n{\n\tuint32_t command;\n\tresource_size_t base;\n\tuint8_t\t__iomem *maddr;\n\tint\t error;\n\n\t \n\tcommand = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, 4);\n\tcommand &= ~(PCIM_CMD_PORTEN|PCIM_CMD_MEMEN);\n\tbase = 0;\n\tmaddr = NULL;\n\terror = ahd_linux_pci_reserve_mem_region(ahd, &base, &maddr);\n\tif (error == 0) {\n\t\tahd->platform_data->mem_busaddr = base;\n\t\tahd->tags[0] = BUS_SPACE_MEMIO;\n\t\tahd->bshs[0].maddr = maddr;\n\t\tahd->tags[1] = BUS_SPACE_MEMIO;\n\t\tahd->bshs[1].maddr = maddr + 0x100;\n\t\tahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,\n\t\t\t\t     command | PCIM_CMD_MEMEN, 4);\n\n\t\tif (ahd_pci_test_register_access(ahd) != 0) {\n\n\t\t\tprintk(\"aic79xx: PCI Device %d:%d:%d \"\n\t\t\t       \"failed memory mapped test.  Using PIO.\\n\",\n\t\t\t       ahd_get_pci_bus(ahd->dev_softc),\n\t\t\t       ahd_get_pci_slot(ahd->dev_softc),\n\t\t\t       ahd_get_pci_function(ahd->dev_softc));\n\t\t\tiounmap(maddr);\n\t\t\trelease_mem_region(ahd->platform_data->mem_busaddr,\n\t\t\t\t\t   0x1000);\n\t\t\tahd->bshs[0].maddr = NULL;\n\t\t\tmaddr = NULL;\n\t\t} else\n\t\t\tcommand |= PCIM_CMD_MEMEN;\n\t} else if (bootverbose) {\n\t\tprintk(\"aic79xx: PCI%d:%d:%d MEM region 0x%llx \"\n\t\t       \"unavailable. Cannot memory map device.\\n\",\n\t\t       ahd_get_pci_bus(ahd->dev_softc),\n\t\t       ahd_get_pci_slot(ahd->dev_softc),\n\t\t       ahd_get_pci_function(ahd->dev_softc),\n\t\t       (unsigned long long)base);\n\t}\n\n\tif (maddr == NULL) {\n\t\tresource_size_t base2;\n\n\t\terror = ahd_linux_pci_reserve_io_regions(ahd, &base, &base2);\n\t\tif (error == 0) {\n\t\t\tahd->tags[0] = BUS_SPACE_PIO;\n\t\t\tahd->tags[1] = BUS_SPACE_PIO;\n\t\t\tahd->bshs[0].ioport = (u_long)base;\n\t\t\tahd->bshs[1].ioport = (u_long)base2;\n\t\t\tcommand |= PCIM_CMD_PORTEN;\n\t\t} else {\n\t\t\tprintk(\"aic79xx: PCI%d:%d:%d IO regions 0x%llx and \"\n\t\t\t       \"0x%llx unavailable. Cannot map device.\\n\",\n\t\t\t       ahd_get_pci_bus(ahd->dev_softc),\n\t\t\t       ahd_get_pci_slot(ahd->dev_softc),\n\t\t\t       ahd_get_pci_function(ahd->dev_softc),\n\t\t\t       (unsigned long long)base,\n\t\t\t       (unsigned long long)base2);\n\t\t}\n\t}\n\tahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, command, 4);\n\treturn (error);\n}\n\nint\nahd_pci_map_int(struct ahd_softc *ahd)\n{\n\tint error;\n\n\terror = request_irq(ahd->dev_softc->irq, ahd_linux_isr,\n\t\t\t    IRQF_SHARED, \"aic79xx\", ahd);\n\tif (!error)\n\t\tahd->platform_data->irq = ahd->dev_softc->irq;\n\n\treturn (-error);\n}\n\nvoid\nahd_power_state_change(struct ahd_softc *ahd, ahd_power_state new_state)\n{\n\tpci_set_power_state(ahd->dev_softc, new_state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}