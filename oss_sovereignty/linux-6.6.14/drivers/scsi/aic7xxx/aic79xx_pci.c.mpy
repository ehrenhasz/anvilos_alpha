{
  "module_name": "aic79xx_pci.c",
  "hash_id": "019e8ec0d3059f32601ef7c9db1e01c7d073d6d95d761aba832da84df0aa6598",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic79xx_pci.c",
  "human_readable_source": " \n\n#include \"aic79xx_osm.h\"\n#include \"aic79xx_inline.h\"\n#include \"aic79xx_pci.h\"\n\nstatic inline uint64_t\nahd_compose_id(u_int device, u_int vendor, u_int subdevice, u_int subvendor)\n{\n\tuint64_t id;\n\n\tid = subvendor\n\t   | (subdevice << 16)\n\t   | ((uint64_t)vendor << 32)\n\t   | ((uint64_t)device << 48);\n\n\treturn (id);\n}\n\n#define ID_AIC7902_PCI_REV_A4\t\t0x3\n#define ID_AIC7902_PCI_REV_B0\t\t0x10\n#define SUBID_HP\t\t\t0x0E11\n\n#define DEVID_9005_HOSTRAID(id) ((id) & 0x80)\n\n#define DEVID_9005_TYPE(id) ((id) & 0xF)\n#define\t\tDEVID_9005_TYPE_HBA\t\t0x0\t \n#define\t\tDEVID_9005_TYPE_HBA_2EXT\t0x1\t \n#define\t\tDEVID_9005_TYPE_IROC\t\t0x8\t \n#define\t\tDEVID_9005_TYPE_MB\t\t0xF\t \n\n#define DEVID_9005_MFUNC(id) ((id) & 0x10)\n\n#define DEVID_9005_PACKETIZED(id) ((id) & 0x8000)\n\n#define SUBID_9005_TYPE(id) ((id) & 0xF)\n#define\t\tSUBID_9005_TYPE_HBA\t\t0x0\t \n#define\t\tSUBID_9005_TYPE_MB\t\t0xF\t \n\n#define SUBID_9005_AUTOTERM(id)\t(((id) & 0x10) == 0)\n\n#define SUBID_9005_LEGACYCONN_FUNC(id) ((id) & 0x20)\n\n#define SUBID_9005_SEEPTYPE(id) (((id) & 0x0C0) >> 6)\n#define\t\tSUBID_9005_SEEPTYPE_NONE\t0x0\n#define\t\tSUBID_9005_SEEPTYPE_4K\t\t0x1\n\nstatic ahd_device_setup_t ahd_aic7901_setup;\nstatic ahd_device_setup_t ahd_aic7901A_setup;\nstatic ahd_device_setup_t ahd_aic7902_setup;\nstatic ahd_device_setup_t ahd_aic790X_setup;\n\nstatic const struct ahd_pci_identity ahd_pci_ident_table[] =\n{\n\t \n\t{\n\t\tID_AHA_29320A,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 29320A Ultra320 SCSI adapter\",\n\t\tahd_aic7901_setup\n\t},\n\t{\n\t\tID_AHA_29320ALP,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 29320ALP PCIx Ultra320 SCSI adapter\",\n\t\tahd_aic7901_setup\n\t},\n\t{\n\t\tID_AHA_29320LPE,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 29320LPE PCIe Ultra320 SCSI adapter\",\n\t\tahd_aic7901_setup\n\t},\n\t \n\t{\n\t\tID_AHA_29320LP,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 29320LP Ultra320 SCSI adapter\",\n\t\tahd_aic7901A_setup\n\t},\n\t \t\n\t{\n\t\tID_AHA_29320,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 29320 Ultra320 SCSI adapter\",\n\t\tahd_aic7902_setup\n\t},\n\t{\n\t\tID_AHA_29320B,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 29320B Ultra320 SCSI adapter\",\n\t\tahd_aic7902_setup\n\t},\n\t{\n\t\tID_AHA_39320,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 39320 Ultra320 SCSI adapter\",\n\t\tahd_aic7902_setup\n\t},\n\t{\n\t\tID_AHA_39320_B,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 39320 Ultra320 SCSI adapter\",\n\t\tahd_aic7902_setup\n\t},\n\t{\n\t\tID_AHA_39320_B_DELL,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec (Dell OEM) 39320 Ultra320 SCSI adapter\",\n\t\tahd_aic7902_setup\n\t},\n\t{\n\t\tID_AHA_39320A,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 39320A Ultra320 SCSI adapter\",\n\t\tahd_aic7902_setup\n\t},\n\t{\n\t\tID_AHA_39320D,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 39320D Ultra320 SCSI adapter\",\n\t\tahd_aic7902_setup\n\t},\n\t{\n\t\tID_AHA_39320D_HP,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec (HP OEM) 39320D Ultra320 SCSI adapter\",\n\t\tahd_aic7902_setup\n\t},\n\t{\n\t\tID_AHA_39320D_B,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 39320D Ultra320 SCSI adapter\",\n\t\tahd_aic7902_setup\n\t},\n\t{\n\t\tID_AHA_39320D_B_HP,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec (HP OEM) 39320D Ultra320 SCSI adapter\",\n\t\tahd_aic7902_setup\n\t},\n\t \n\t{\n\t\tID_AIC7901 & ID_9005_GENERIC_MASK,\n\t\tID_9005_GENERIC_MASK,\n\t\t\"Adaptec AIC7901 Ultra320 SCSI adapter\",\n\t\tahd_aic7901_setup\n\t},\n\t{\n\t\tID_AIC7901A & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec AIC7901A Ultra320 SCSI adapter\",\n\t\tahd_aic7901A_setup\n\t},\n\t{\n\t\tID_AIC7902 & ID_9005_GENERIC_MASK,\n\t\tID_9005_GENERIC_MASK,\n\t\t\"Adaptec AIC7902 Ultra320 SCSI adapter\",\n\t\tahd_aic7902_setup\n\t}\n};\n\nstatic const u_int ahd_num_pci_devs = ARRAY_SIZE(ahd_pci_ident_table);\n\t\t\n#define\tDEVCONFIG\t\t0x40\n#define\t\tPCIXINITPAT\t0x0000E000ul\n#define\t\t\tPCIXINIT_PCI33_66\t0x0000E000ul\n#define\t\t\tPCIXINIT_PCIX50_66\t0x0000C000ul\n#define\t\t\tPCIXINIT_PCIX66_100\t0x0000A000ul\n#define\t\t\tPCIXINIT_PCIX100_133\t0x00008000ul\n#define\tPCI_BUS_MODES_INDEX(devconfig)\t\\\n\t(((devconfig) & PCIXINITPAT) >> 13)\nstatic const char *pci_bus_modes[] =\n{\n\t\"PCI bus mode unknown\",\n\t\"PCI bus mode unknown\",\n\t\"PCI bus mode unknown\",\n\t\"PCI bus mode unknown\",\n\t\"PCI-X 101-133MHz\",\n\t\"PCI-X 67-100MHz\",\n\t\"PCI-X 50-66MHz\",\n\t\"PCI 33 or 66MHz\"\n};\n\n#define\t\tTESTMODE\t0x00000800ul\n#define\t\tIRDY_RST\t0x00000200ul\n#define\t\tFRAME_RST\t0x00000100ul\n#define\t\tPCI64BIT\t0x00000080ul\n#define\t\tMRDCEN\t\t0x00000040ul\n#define\t\tENDIANSEL\t0x00000020ul\n#define\t\tMIXQWENDIANEN\t0x00000008ul\n#define\t\tDACEN\t\t0x00000004ul\n#define\t\tSTPWLEVEL\t0x00000002ul\n#define\t\tQWENDIANSEL\t0x00000001ul\n\n#define\tDEVCONFIG1\t\t0x44\n#define\t\tPREQDIS\t\t0x01\n\n#define\tCSIZE_LATTIME\t\t0x0c\n#define\t\tCACHESIZE\t0x000000fful\n#define\t\tLATTIME\t\t0x0000ff00ul\n\nstatic int\tahd_check_extport(struct ahd_softc *ahd);\nstatic void\tahd_configure_termination(struct ahd_softc *ahd,\n\t\t\t\t\t  u_int adapter_control);\nstatic void\tahd_pci_split_intr(struct ahd_softc *ahd, u_int intstat);\nstatic void\tahd_pci_intr(struct ahd_softc *ahd);\n\nconst struct ahd_pci_identity *\nahd_find_pci_device(ahd_dev_softc_t pci)\n{\n\tuint64_t  full_id;\n\tuint16_t  device;\n\tuint16_t  vendor;\n\tuint16_t  subdevice;\n\tuint16_t  subvendor;\n\tconst struct ahd_pci_identity *entry;\n\tu_int\t  i;\n\n\tvendor = ahd_pci_read_config(pci, PCIR_DEVVENDOR,  2);\n\tdevice = ahd_pci_read_config(pci, PCIR_DEVICE,  2);\n\tsubvendor = ahd_pci_read_config(pci, PCI_SUBSYSTEM_VENDOR_ID,  2);\n\tsubdevice = ahd_pci_read_config(pci, PCI_SUBSYSTEM_ID,  2);\n\tfull_id = ahd_compose_id(device,\n\t\t\t\t vendor,\n\t\t\t\t subdevice,\n\t\t\t\t subvendor);\n\n\t \n\t\n\tfull_id &= ID_ALL_IROC_MASK;\n\n\tfor (i = 0; i < ahd_num_pci_devs; i++) {\n\t\tentry = &ahd_pci_ident_table[i];\n\t\tif (entry->full_id == (full_id & entry->id_mask)) {\n\t\t\t \n\t\t\tif (entry->name == NULL)\n\t\t\t\treturn (NULL);\n\t\t\treturn (entry);\n\t\t}\n\t}\n\treturn (NULL);\n}\n\nint\nahd_pci_config(struct ahd_softc *ahd, const struct ahd_pci_identity *entry)\n{\n\tu_int\t\t command;\n\tuint32_t\t devconfig;\n\tuint16_t\t subvendor; \n\tint\t\t error;\n\n\tahd->description = entry->name;\n\t \n\tsubvendor = ahd_pci_read_config(ahd->dev_softc,\n\t\t\t\t\tPCI_SUBSYSTEM_VENDOR_ID,  2);\n\tif (subvendor == SUBID_HP)\n\t\tahd->flags |= AHD_HP_BOARD;\n\n\terror = entry->setup(ahd);\n\tif (error != 0)\n\t\treturn (error);\n\t\n\tdevconfig = ahd_pci_read_config(ahd->dev_softc, DEVCONFIG,  4);\n\tif ((devconfig & PCIXINITPAT) == PCIXINIT_PCI33_66) {\n\t\tahd->chip |= AHD_PCI;\n\t\t \n\t\tahd->bugs &= ~AHD_PCIX_BUG_MASK;\n\t} else {\n\t\tahd->chip |= AHD_PCIX;\n\t}\n\tahd->bus_description = pci_bus_modes[PCI_BUS_MODES_INDEX(devconfig)];\n\n\tahd_power_state_change(ahd, AHD_POWER_STATE_D0);\n\n\terror = ahd_pci_map_registers(ahd);\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\tif ((ahd->flags & (AHD_39BIT_ADDRESSING|AHD_64BIT_ADDRESSING)) != 0) {\n\t\tif (bootverbose)\n\t\t\tprintk(\"%s: Enabling 39Bit Addressing\\n\",\n\t\t\t       ahd_name(ahd));\n\t\tdevconfig = ahd_pci_read_config(ahd->dev_softc,\n\t\t\t\t\t\tDEVCONFIG,  4);\n\t\tdevconfig |= DACEN;\n\t\tahd_pci_write_config(ahd->dev_softc, DEVCONFIG,\n\t\t\t\t     devconfig,  4);\n\t}\n\t\n\t \n\tcommand = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND,  2);\n\tcommand |= PCIM_CMD_BUSMASTEREN;\n\tahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, command,  2);\n\n\terror = ahd_softc_init(ahd);\n\tif (error != 0)\n\t\treturn (error);\n\n\tahd->bus_intr = ahd_pci_intr;\n\n\terror = ahd_reset(ahd,  FALSE);\n\tif (error != 0)\n\t\treturn (ENXIO);\n\n\tahd->pci_cachesize =\n\t    ahd_pci_read_config(ahd->dev_softc, CSIZE_LATTIME,\n\t\t\t\t 1) & CACHESIZE;\n\tahd->pci_cachesize *= 4;\n\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\t \n\terror = ahd_check_extport(ahd);\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\terror = ahd_init(ahd);\n\tif (error != 0)\n\t\treturn (error);\n\tahd->init_level++;\n\n\t \n\treturn ahd_pci_map_int(ahd);\n}\n\nvoid __maybe_unused\nahd_pci_suspend(struct ahd_softc *ahd)\n{\n\t \n\tahd->suspend_state.pci_state.devconfig =\n\t    ahd_pci_read_config(ahd->dev_softc, DEVCONFIG,  4);\n\tahd->suspend_state.pci_state.command =\n\t    ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND,  1);\n\tahd->suspend_state.pci_state.csize_lattime =\n\t    ahd_pci_read_config(ahd->dev_softc, CSIZE_LATTIME,  1);\n\n}\n\nvoid __maybe_unused\nahd_pci_resume(struct ahd_softc *ahd)\n{\n\tahd_pci_write_config(ahd->dev_softc, DEVCONFIG,\n\t\t\t     ahd->suspend_state.pci_state.devconfig,  4);\n\tahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,\n\t\t\t     ahd->suspend_state.pci_state.command,  1);\n\tahd_pci_write_config(ahd->dev_softc, CSIZE_LATTIME,\n\t\t\t     ahd->suspend_state.pci_state.csize_lattime,  1);\n}\n\n \nint\nahd_pci_test_register_access(struct ahd_softc *ahd)\n{\n\tuint32_t cmd;\n\tu_int\t targpcistat;\n\tu_int\t pci_status1;\n\tint\t error;\n\tuint8_t\t hcntrl;\n\n\terror = EIO;\n\n\t \n\tcmd = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND,  2);\n\tahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,\n\t\t\t     cmd & ~PCIM_CMD_SERRESPEN,  2);\n\n\t \n\thcntrl = ahd_inb(ahd, HCNTRL);\n\tif (hcntrl == 0xFF)\n\t\tgoto fail;\n\n\t \n\thcntrl &= ~CHIPRST;\n\tahd_outb(ahd, HCNTRL, hcntrl|PAUSE);\n\twhile (ahd_is_paused(ahd) == 0)\n\t\t;\n\n\t \n\tahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\n\ttargpcistat = ahd_inb(ahd, TARGPCISTAT);\n\tahd_outb(ahd, TARGPCISTAT, targpcistat);\n\tpci_status1 = ahd_pci_read_config(ahd->dev_softc,\n\t\t\t\t\t  PCIR_STATUS + 1,  1);\n\tahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,\n\t\t\t     pci_status1,  1);\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\tahd_outb(ahd, CLRINT, CLRPCIINT);\n\n\tahd_outb(ahd, SEQCTL0, PERRORDIS);\n\tahd_outl(ahd, SRAM_BASE, 0x5aa555aa);\n\tif (ahd_inl(ahd, SRAM_BASE) != 0x5aa555aa)\n\t\tgoto fail;\n\n\tif ((ahd_inb(ahd, INTSTAT) & PCIINT) != 0) {\n\t\tahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\n\t\ttargpcistat = ahd_inb(ahd, TARGPCISTAT);\n\t\tif ((targpcistat & STA) != 0)\n\t\t\tgoto fail;\n\t}\n\n\terror = 0;\n\nfail:\n\tif ((ahd_inb(ahd, INTSTAT) & PCIINT) != 0) {\n\n\t\tahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\n\t\ttargpcistat = ahd_inb(ahd, TARGPCISTAT);\n\n\t\t \n\t\tahd_outb(ahd, TARGPCISTAT, targpcistat);\n\t\tpci_status1 = ahd_pci_read_config(ahd->dev_softc,\n\t\t\t\t\t\t  PCIR_STATUS + 1,  1);\n\t\tahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,\n\t\t\t\t     pci_status1,  1);\n\t\tahd_outb(ahd, CLRINT, CLRPCIINT);\n\t}\n\tahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS);\n\tahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, cmd,  2);\n\treturn (error);\n}\n\n \nstatic int\nahd_check_extport(struct ahd_softc *ahd)\n{\n\tstruct\tvpd_config vpd;\n\tstruct\tseeprom_config *sc;\n\tu_int\tadapter_control;\n\tint\thave_seeprom;\n\tint\terror;\n\n\tsc = ahd->seep_config;\n\thave_seeprom = ahd_acquire_seeprom(ahd);\n\tif (have_seeprom) {\n\t\tu_int start_addr;\n\n\t\t \n\t\tif (bootverbose) \n\t\t\tprintk(\"%s: Reading VPD from SEEPROM...\",\n\t\t\t       ahd_name(ahd));\n\n\t\t \n\t\tstart_addr = ((2 * sizeof(*sc))\n\t\t\t    + (sizeof(vpd) * (ahd->channel - 'A'))) / 2;\n\n\t\terror = ahd_read_seeprom(ahd, (uint16_t *)&vpd,\n\t\t\t\t\t start_addr, sizeof(vpd)/2,\n\t\t\t\t\t  TRUE);\n\t\tif (error == 0)\n\t\t\terror = ahd_parse_vpddata(ahd, &vpd);\n\t\tif (bootverbose) \n\t\t\tprintk(\"%s: VPD parsing %s\\n\",\n\t\t\t       ahd_name(ahd),\n\t\t\t       error == 0 ? \"successful\" : \"failed\");\n\n\t\tif (bootverbose) \n\t\t\tprintk(\"%s: Reading SEEPROM...\", ahd_name(ahd));\n\n\t\t \n\t\tstart_addr = (sizeof(*sc) / 2) * (ahd->channel - 'A');\n\n\t\terror = ahd_read_seeprom(ahd, (uint16_t *)sc,\n\t\t\t\t\t start_addr, sizeof(*sc)/2,\n\t\t\t\t\t  FALSE);\n\n\t\tif (error != 0) {\n\t\t\tprintk(\"Unable to read SEEPROM\\n\");\n\t\t\thave_seeprom = 0;\n\t\t} else {\n\t\t\thave_seeprom = ahd_verify_cksum(sc);\n\n\t\t\tif (bootverbose) {\n\t\t\t\tif (have_seeprom == 0)\n\t\t\t\t\tprintk (\"checksum error\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintk (\"done.\\n\");\n\t\t\t}\n\t\t}\n\t\tahd_release_seeprom(ahd);\n\t}\n\n\tif (!have_seeprom) {\n\t\tu_int\t  nvram_scb;\n\n\t\t \n\t\tahd_set_scbptr(ahd, 0xFF);\n\t\tnvram_scb = ahd_inb_scbram(ahd, SCB_BASE + NVRAM_SCB_OFFSET);\n\t\tif (nvram_scb != 0xFF\n\t\t && ((ahd_inb_scbram(ahd, SCB_BASE + 0) == 'A'\n\t\t   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'D'\n\t\t   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'P'\n\t\t   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'T')\n\t\t  || (ahd_inb_scbram(ahd, SCB_BASE + 0) == 'B'\n\t\t   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'I'\n\t\t   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'O'\n\t\t   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'S')\n\t\t  || (ahd_inb_scbram(ahd, SCB_BASE + 0) == 'A'\n\t\t   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'S'\n\t\t   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'P'\n\t\t   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'I'))) {\n\t\t\tuint16_t *sc_data;\n\t\t\tint\t  i;\n\n\t\t\tahd_set_scbptr(ahd, nvram_scb);\n\t\t\tsc_data = (uint16_t *)sc;\n\t\t\tfor (i = 0; i < 64; i += 2)\n\t\t\t\t*sc_data++ = ahd_inw_scbram(ahd, SCB_BASE+i);\n\t\t\thave_seeprom = ahd_verify_cksum(sc);\n\t\t\tif (have_seeprom)\n\t\t\t\tahd->flags |= AHD_SCB_CONFIG_USED;\n\t\t}\n\t}\n\n#ifdef AHD_DEBUG\n\tif (have_seeprom != 0\n\t && (ahd_debug & AHD_DUMP_SEEPROM) != 0) {\n\t\tuint16_t *sc_data;\n\t\tint\t  i;\n\n\t\tprintk(\"%s: Seeprom Contents:\", ahd_name(ahd));\n\t\tsc_data = (uint16_t *)sc;\n\t\tfor (i = 0; i < (sizeof(*sc)); i += 2)\n\t\t\tprintk(\"\\n\\t0x%.4x\", sc_data[i]);\n\t\tprintk(\"\\n\");\n\t}\n#endif\n\n\tif (!have_seeprom) {\n\t\tif (bootverbose)\n\t\t\tprintk(\"%s: No SEEPROM available.\\n\", ahd_name(ahd));\n\t\tahd->flags |= AHD_USEDEFAULTS;\n\t\terror = ahd_default_config(ahd);\n\t\tadapter_control = CFAUTOTERM|CFSEAUTOTERM;\n\t\tkfree(ahd->seep_config);\n\t\tahd->seep_config = NULL;\n\t} else {\n\t\terror = ahd_parse_cfgdata(ahd, sc);\n\t\tadapter_control = sc->adapter_control;\n\t}\n\tif (error != 0)\n\t\treturn (error);\n\n\tahd_configure_termination(ahd, adapter_control);\n\n\treturn (0);\n}\n\nstatic void\nahd_configure_termination(struct ahd_softc *ahd, u_int adapter_control)\n{\n\tint\t error;\n\tu_int\t sxfrctl1;\n\tuint8_t\t termctl;\n\tuint32_t devconfig;\n\n\tdevconfig = ahd_pci_read_config(ahd->dev_softc, DEVCONFIG,  4);\n\tdevconfig &= ~STPWLEVEL;\n\tif ((ahd->flags & AHD_STPWLEVEL_A) != 0)\n\t\tdevconfig |= STPWLEVEL;\n\tif (bootverbose)\n\t\tprintk(\"%s: STPWLEVEL is %s\\n\",\n\t\t       ahd_name(ahd), (devconfig & STPWLEVEL) ? \"on\" : \"off\");\n\tahd_pci_write_config(ahd->dev_softc, DEVCONFIG, devconfig,  4);\n \n\t \n\tif ((ahd->flags & AHD_CURRENT_SENSING) != 0) {\n\t\t(void)ahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, 0);\n\t}\n\n\t \n\terror = ahd_read_flexport(ahd, FLXADDR_TERMCTL, &termctl);\n\tif ((adapter_control & CFAUTOTERM) == 0) {\n\t\tif (bootverbose)\n\t\t\tprintk(\"%s: Manual Primary Termination\\n\",\n\t\t\t       ahd_name(ahd));\n\t\ttermctl &= ~(FLX_TERMCTL_ENPRILOW|FLX_TERMCTL_ENPRIHIGH);\n\t\tif ((adapter_control & CFSTERM) != 0)\n\t\t\ttermctl |= FLX_TERMCTL_ENPRILOW;\n\t\tif ((adapter_control & CFWSTERM) != 0)\n\t\t\ttermctl |= FLX_TERMCTL_ENPRIHIGH;\n\t} else if (error != 0) {\n\t\tprintk(\"%s: Primary Auto-Term Sensing failed! \"\n\t\t       \"Using Defaults.\\n\", ahd_name(ahd));\n\t\ttermctl = FLX_TERMCTL_ENPRILOW|FLX_TERMCTL_ENPRIHIGH;\n\t}\n\n\tif ((adapter_control & CFSEAUTOTERM) == 0) {\n\t\tif (bootverbose)\n\t\t\tprintk(\"%s: Manual Secondary Termination\\n\",\n\t\t\t       ahd_name(ahd));\n\t\ttermctl &= ~(FLX_TERMCTL_ENSECLOW|FLX_TERMCTL_ENSECHIGH);\n\t\tif ((adapter_control & CFSELOWTERM) != 0)\n\t\t\ttermctl |= FLX_TERMCTL_ENSECLOW;\n\t\tif ((adapter_control & CFSEHIGHTERM) != 0)\n\t\t\ttermctl |= FLX_TERMCTL_ENSECHIGH;\n\t} else if (error != 0) {\n\t\tprintk(\"%s: Secondary Auto-Term Sensing failed! \"\n\t\t       \"Using Defaults.\\n\", ahd_name(ahd));\n\t\ttermctl |= FLX_TERMCTL_ENSECLOW|FLX_TERMCTL_ENSECHIGH;\n\t}\n\n\t \n\tsxfrctl1 = ahd_inb(ahd, SXFRCTL1) & ~STPWEN;\n\tahd->flags &= ~AHD_TERM_ENB_A;\n\tif ((termctl & FLX_TERMCTL_ENPRILOW) != 0) {\n\t\tahd->flags |= AHD_TERM_ENB_A;\n\t\tsxfrctl1 |= STPWEN;\n\t}\n\t \n\tahd_outb(ahd, SXFRCTL1, sxfrctl1|STPWEN);\n\tahd_outb(ahd, SXFRCTL1, sxfrctl1);\n\n\terror = ahd_write_flexport(ahd, FLXADDR_TERMCTL, termctl);\n\tif (error != 0) {\n\t\tprintk(\"%s: Unable to set termination settings!\\n\",\n\t\t       ahd_name(ahd));\n\t} else if (bootverbose) {\n\t\tprintk(\"%s: Primary High byte termination %sabled\\n\",\n\t\t       ahd_name(ahd),\n\t\t       (termctl & FLX_TERMCTL_ENPRIHIGH) ? \"En\" : \"Dis\");\n\n\t\tprintk(\"%s: Primary Low byte termination %sabled\\n\",\n\t\t       ahd_name(ahd),\n\t\t       (termctl & FLX_TERMCTL_ENPRILOW) ? \"En\" : \"Dis\");\n\n\t\tprintk(\"%s: Secondary High byte termination %sabled\\n\",\n\t\t       ahd_name(ahd),\n\t\t       (termctl & FLX_TERMCTL_ENSECHIGH) ? \"En\" : \"Dis\");\n\n\t\tprintk(\"%s: Secondary Low byte termination %sabled\\n\",\n\t\t       ahd_name(ahd),\n\t\t       (termctl & FLX_TERMCTL_ENSECLOW) ? \"En\" : \"Dis\");\n\t}\n\treturn;\n}\n\n#define\tDPE\t0x80\n#define SSE\t0x40\n#define\tRMA\t0x20\n#define\tRTA\t0x10\n#define STA\t0x08\n#define DPR\t0x01\n\nstatic const char *split_status_source[] =\n{\n\t\"DFF0\",\n\t\"DFF1\",\n\t\"OVLY\",\n\t\"CMC\",\n};\n\nstatic const char *pci_status_source[] =\n{\n\t\"DFF0\",\n\t\"DFF1\",\n\t\"SG\",\n\t\"CMC\",\n\t\"OVLY\",\n\t\"NONE\",\n\t\"MSI\",\n\t\"TARG\"\n};\n\nstatic const char *split_status_strings[] =\n{\n\t\"%s: Received split response in %s.\\n\",\n\t\"%s: Received split completion error message in %s\\n\",\n\t\"%s: Receive overrun in %s\\n\",\n\t\"%s: Count not complete in %s\\n\",\n\t\"%s: Split completion data bucket in %s\\n\",\n\t\"%s: Split completion address error in %s\\n\",\n\t\"%s: Split completion byte count error in %s\\n\",\n\t\"%s: Signaled Target-abort to early terminate a split in %s\\n\"\n};\n\nstatic const char *pci_status_strings[] =\n{\n\t\"%s: Data Parity Error has been reported via PERR# in %s\\n\",\n\t\"%s: Target initial wait state error in %s\\n\",\n\t\"%s: Split completion read data parity error in %s\\n\",\n\t\"%s: Split completion address attribute parity error in %s\\n\",\n\t\"%s: Received a Target Abort in %s\\n\",\n\t\"%s: Received a Master Abort in %s\\n\",\n\t\"%s: Signal System Error Detected in %s\\n\",\n\t\"%s: Address or Write Phase Parity Error Detected in %s.\\n\"\n};\n\nstatic void\nahd_pci_intr(struct ahd_softc *ahd)\n{\n\tuint8_t\t\tpci_status[8];\n\tahd_mode_state\tsaved_modes;\n\tu_int\t\tpci_status1;\n\tu_int\t\tintstat;\n\tu_int\t\ti;\n\tu_int\t\treg;\n\t\n\tintstat = ahd_inb(ahd, INTSTAT);\n\n\tif ((intstat & SPLTINT) != 0)\n\t\tahd_pci_split_intr(ahd, intstat);\n\n\tif ((intstat & PCIINT) == 0)\n\t\treturn;\n\n\tprintk(\"%s: PCI error Interrupt\\n\", ahd_name(ahd));\n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_dump_card_state(ahd);\n\tahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\n\tfor (i = 0, reg = DF0PCISTAT; i < 8; i++, reg++) {\n\n\t\tif (i == 5)\n\t\t\tcontinue;\n\t\tpci_status[i] = ahd_inb(ahd, reg);\n\t\t \n\t\tahd_outb(ahd, reg, pci_status[i]);\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tu_int bit;\n\t\n\t\tif (i == 5)\n\t\t\tcontinue;\n\n\t\tfor (bit = 0; bit < 8; bit++) {\n\n\t\t\tif ((pci_status[i] & (0x1 << bit)) != 0) {\n\t\t\t\tconst char *s;\n\n\t\t\t\ts = pci_status_strings[bit];\n\t\t\t\tif (i == 7  && bit == 3)\n\t\t\t\t\ts = \"%s: Signaled Target Abort\\n\";\n\t\t\t\tprintk(s, ahd_name(ahd), pci_status_source[i]);\n\t\t\t}\n\t\t}\t\n\t}\n\tpci_status1 = ahd_pci_read_config(ahd->dev_softc,\n\t\t\t\t\t  PCIR_STATUS + 1,  1);\n\tahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,\n\t\t\t     pci_status1,  1);\n\tahd_restore_modes(ahd, saved_modes);\n\tahd_outb(ahd, CLRINT, CLRPCIINT);\n\tahd_unpause(ahd);\n}\n\nstatic void\nahd_pci_split_intr(struct ahd_softc *ahd, u_int intstat)\n{\n\tuint8_t\t\tsplit_status[4];\n\tuint8_t\t\tsplit_status1[4];\n\tuint8_t\t\tsg_split_status[2];\n\tuint8_t\t\tsg_split_status1[2];\n\tahd_mode_state\tsaved_modes;\n\tu_int\t\ti;\n\tuint16_t\tpcix_status;\n\n\t \n\tpcix_status = ahd_pci_read_config(ahd->dev_softc, PCIXR_STATUS,\n\t\t\t\t\t   2);\n\tprintk(\"%s: PCI Split Interrupt - PCI-X status = 0x%x\\n\",\n\t       ahd_name(ahd), pcix_status);\n\tsaved_modes = ahd_save_modes(ahd);\n\tfor (i = 0; i < 4; i++) {\n\t\tahd_set_modes(ahd, i, i);\n\n\t\tsplit_status[i] = ahd_inb(ahd, DCHSPLTSTAT0);\n\t\tsplit_status1[i] = ahd_inb(ahd, DCHSPLTSTAT1);\n\t\t \n\t\tahd_outb(ahd, DCHSPLTSTAT0, split_status[i]);\n\t\tahd_outb(ahd, DCHSPLTSTAT1, split_status1[i]);\n\t\tif (i > 1)\n\t\t\tcontinue;\n\t\tsg_split_status[i] = ahd_inb(ahd, SGSPLTSTAT0);\n\t\tsg_split_status1[i] = ahd_inb(ahd, SGSPLTSTAT1);\n\t\t \n\t\tahd_outb(ahd, SGSPLTSTAT0, sg_split_status[i]);\n\t\tahd_outb(ahd, SGSPLTSTAT1, sg_split_status1[i]);\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tu_int bit;\n\n\t\tfor (bit = 0; bit < 8; bit++) {\n\n\t\t\tif ((split_status[i] & (0x1 << bit)) != 0)\n\t\t\t\tprintk(split_status_strings[bit], ahd_name(ahd),\n\t\t\t\t       split_status_source[i]);\n\n\t\t\tif (i > 1)\n\t\t\t\tcontinue;\n\n\t\t\tif ((sg_split_status[i] & (0x1 << bit)) != 0)\n\t\t\t\tprintk(split_status_strings[bit], ahd_name(ahd), \"SG\");\n\t\t}\n\t}\n\t \n\tahd_pci_write_config(ahd->dev_softc, PCIXR_STATUS,\n\t\t\t     pcix_status,  2);\n\tahd_outb(ahd, CLRINT, CLRSPLTINT);\n\tahd_restore_modes(ahd, saved_modes);\n}\n\nstatic int\nahd_aic7901_setup(struct ahd_softc *ahd)\n{\n\n\tahd->chip = AHD_AIC7901;\n\tahd->features = AHD_AIC7901_FE;\n\treturn (ahd_aic790X_setup(ahd));\n}\n\nstatic int\nahd_aic7901A_setup(struct ahd_softc *ahd)\n{\n\n\tahd->chip = AHD_AIC7901A;\n\tahd->features = AHD_AIC7901A_FE;\n\treturn (ahd_aic790X_setup(ahd));\n}\n\nstatic int\nahd_aic7902_setup(struct ahd_softc *ahd)\n{\n\tahd->chip = AHD_AIC7902;\n\tahd->features = AHD_AIC7902_FE;\n\treturn (ahd_aic790X_setup(ahd));\n}\n\nstatic int\nahd_aic790X_setup(struct ahd_softc *ahd)\n{\n\tahd_dev_softc_t pci;\n\tu_int rev;\n\n\tpci = ahd->dev_softc;\n\trev = ahd_pci_read_config(pci, PCIR_REVID,  1);\n\tif (rev < ID_AIC7902_PCI_REV_A4) {\n\t\tprintk(\"%s: Unable to attach to unsupported chip revision %d\\n\",\n\t\t       ahd_name(ahd), rev);\n\t\tahd_pci_write_config(pci, PCIR_COMMAND, 0,  2);\n\t\treturn (ENXIO);\n\t}\n\tahd->channel = ahd_get_pci_function(pci) + 'A';\n\tif (rev < ID_AIC7902_PCI_REV_B0) {\n\t\t \n\t\tahd->bugs |= AHD_SENT_SCB_UPDATE_BUG|AHD_ABORT_LQI_BUG\n\t\t\t  |  AHD_PKT_BITBUCKET_BUG|AHD_LONG_SETIMO_BUG\n\t\t\t  |  AHD_NLQICRC_DELAYED_BUG|AHD_SCSIRST_BUG\n\t\t\t  |  AHD_LQO_ATNO_BUG|AHD_AUTOFLUSH_BUG\n\t\t\t  |  AHD_CLRLQO_AUTOCLR_BUG|AHD_PCIX_MMAPIO_BUG\n\t\t\t  |  AHD_PCIX_CHIPRST_BUG|AHD_PCIX_SCBRAM_RD_BUG\n\t\t\t  |  AHD_PKTIZED_STATUS_BUG|AHD_PKT_LUN_BUG\n\t\t\t  |  AHD_MDFF_WSCBPTR_BUG|AHD_REG_SLOW_SETTLE_BUG\n\t\t\t  |  AHD_SET_MODE_BUG|AHD_BUSFREEREV_BUG\n\t\t\t  |  AHD_NONPACKFIFO_BUG|AHD_PACED_NEGTABLE_BUG\n\t\t\t  |  AHD_FAINT_LED_BUG;\n\n\t\t \n\t\tAHD_SET_PRECOMP(ahd, AHD_PRECOMP_CUTBACK_29);\n\n\t\tif ((ahd->flags & AHD_HP_BOARD) == 0)\n\t\t\tAHD_SET_SLEWRATE(ahd, AHD_SLEWRATE_DEF_REVA);\n\t} else {\n\t\t \n\t\textern uint32_t aic79xx_slowcrc;\n\t\tu_int devconfig1;\n\n\t\tahd->features |= AHD_RTI|AHD_NEW_IOCELL_OPTS\n\t\t\t      |  AHD_NEW_DFCNTRL_OPTS|AHD_FAST_CDB_DELIVERY\n\t\t\t      |  AHD_BUSFREEREV_BUG;\n\t\tahd->bugs |= AHD_LQOOVERRUN_BUG|AHD_EARLY_REQ_BUG;\n\n\t\t \n\t\tif (aic79xx_slowcrc)\n\t\t\tahd->features |= AHD_AIC79XXB_SLOWCRC;\n\n\t\t \n\t\tif ((ahd->features & AHD_MULTI_FUNC) != 0)\n\t\t\tahd->bugs |= AHD_INTCOLLISION_BUG|AHD_ABORT_LQI_BUG;\n\n\t\t \n\t\tAHD_SET_PRECOMP(ahd, AHD_PRECOMP_CUTBACK_29);\n\t\tAHD_SET_SLEWRATE(ahd, AHD_SLEWRATE_DEF_REVB);\n\t\tAHD_SET_AMPLITUDE(ahd, AHD_AMPLITUDE_DEF);\n\n\t\t \n\t\tdevconfig1 = ahd_pci_read_config(pci, DEVCONFIG1,  1);\n\t\tahd_pci_write_config(pci, DEVCONFIG1,\n\t\t\t\t     devconfig1|PREQDIS,  1);\n\t\tdevconfig1 = ahd_pci_read_config(pci, DEVCONFIG1,  1);\n\t}\n\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}