{
  "module_name": "aic79xx_core.c",
  "hash_id": "6c077984f964327c794a45af660d10257342fde965683d9566ad0cc0c94b4cdb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic79xx_core.c",
  "human_readable_source": " \n\n#include \"aic79xx_osm.h\"\n#include \"aic79xx_inline.h\"\n#include \"aicasm/aicasm_insformat.h\"\n\n \nstatic const char *const ahd_chip_names[] =\n{\n\t\"NONE\",\n\t\"aic7901\",\n\t\"aic7902\",\n\t\"aic7901A\"\n};\n\n \nstruct ahd_hard_error_entry {\n\tuint8_t errno;\n\tconst char *errmesg;\n};\n\nstatic const struct ahd_hard_error_entry ahd_hard_errors[] = {\n\t{ DSCTMOUT,\t\"Discard Timer has timed out\" },\n\t{ ILLOPCODE,\t\"Illegal Opcode in sequencer program\" },\n\t{ SQPARERR,\t\"Sequencer Parity Error\" },\n\t{ DPARERR,\t\"Data-path Parity Error\" },\n\t{ MPARERR,\t\"Scratch or SCB Memory Parity Error\" },\n\t{ CIOPARERR,\t\"CIOBUS Parity Error\" },\n};\nstatic const u_int num_errors = ARRAY_SIZE(ahd_hard_errors);\n\nstatic const struct ahd_phase_table_entry ahd_phase_table[] =\n{\n\t{ P_DATAOUT,\tNOP,\t\t\t\"in Data-out phase\"\t},\n\t{ P_DATAIN,\tINITIATOR_ERROR,\t\"in Data-in phase\"\t},\n\t{ P_DATAOUT_DT,\tNOP,\t\t\t\"in DT Data-out phase\"\t},\n\t{ P_DATAIN_DT,\tINITIATOR_ERROR,\t\"in DT Data-in phase\"\t},\n\t{ P_COMMAND,\tNOP,\t\t\t\"in Command phase\"\t},\n\t{ P_MESGOUT,\tNOP,\t\t\t\"in Message-out phase\"\t},\n\t{ P_STATUS,\tINITIATOR_ERROR,\t\"in Status phase\"\t},\n\t{ P_MESGIN,\tMSG_PARITY_ERROR,\t\"in Message-in phase\"\t},\n\t{ P_BUSFREE,\tNOP,\t\t\t\"while idle\"\t\t},\n\t{ 0,\t\tNOP,\t\t\t\"in unknown phase\"\t}\n};\n\n \nstatic const u_int num_phases = ARRAY_SIZE(ahd_phase_table) - 1;\n\n \n#include \"aic79xx_seq.h\"\n\n \nstatic void\t\tahd_handle_transmission_error(struct ahd_softc *ahd);\nstatic void\t\tahd_handle_lqiphase_error(struct ahd_softc *ahd,\n\t\t\t\t\t\t  u_int lqistat1);\nstatic int\t\tahd_handle_pkt_busfree(struct ahd_softc *ahd,\n\t\t\t\t\t       u_int busfreetime);\nstatic int\t\tahd_handle_nonpkt_busfree(struct ahd_softc *ahd);\nstatic void\t\tahd_handle_proto_violation(struct ahd_softc *ahd);\nstatic void\t\tahd_force_renegotiation(struct ahd_softc *ahd,\n\t\t\t\t\t\tstruct ahd_devinfo *devinfo);\n\nstatic struct ahd_tmode_tstate*\n\t\t\tahd_alloc_tstate(struct ahd_softc *ahd,\n\t\t\t\t\t u_int scsi_id, char channel);\n#ifdef AHD_TARGET_MODE\nstatic void\t\tahd_free_tstate(struct ahd_softc *ahd,\n\t\t\t\t\tu_int scsi_id, char channel, int force);\n#endif\nstatic void\t\tahd_devlimited_syncrate(struct ahd_softc *ahd,\n\t\t\t\t\t\tstruct ahd_initiator_tinfo *,\n\t\t\t\t\t\tu_int *period,\n\t\t\t\t\t\tu_int *ppr_options,\n\t\t\t\t\t\trole_t role);\nstatic void\t\tahd_update_neg_table(struct ahd_softc *ahd,\n\t\t\t\t\t     struct ahd_devinfo *devinfo,\n\t\t\t\t\t     struct ahd_transinfo *tinfo);\nstatic void\t\tahd_update_pending_scbs(struct ahd_softc *ahd);\nstatic void\t\tahd_fetch_devinfo(struct ahd_softc *ahd,\n\t\t\t\t\t  struct ahd_devinfo *devinfo);\nstatic void\t\tahd_scb_devinfo(struct ahd_softc *ahd,\n\t\t\t\t\tstruct ahd_devinfo *devinfo,\n\t\t\t\t\tstruct scb *scb);\nstatic void\t\tahd_setup_initiator_msgout(struct ahd_softc *ahd,\n\t\t\t\t\t\t   struct ahd_devinfo *devinfo,\n\t\t\t\t\t\t   struct scb *scb);\nstatic void\t\tahd_build_transfer_msg(struct ahd_softc *ahd,\n\t\t\t\t\t       struct ahd_devinfo *devinfo);\nstatic void\t\tahd_construct_sdtr(struct ahd_softc *ahd,\n\t\t\t\t\t   struct ahd_devinfo *devinfo,\n\t\t\t\t\t   u_int period, u_int offset);\nstatic void\t\tahd_construct_wdtr(struct ahd_softc *ahd,\n\t\t\t\t\t   struct ahd_devinfo *devinfo,\n\t\t\t\t\t   u_int bus_width);\nstatic void\t\tahd_construct_ppr(struct ahd_softc *ahd,\n\t\t\t\t\t  struct ahd_devinfo *devinfo,\n\t\t\t\t\t  u_int period, u_int offset,\n\t\t\t\t\t  u_int bus_width, u_int ppr_options);\nstatic void\t\tahd_clear_msg_state(struct ahd_softc *ahd);\nstatic void\t\tahd_handle_message_phase(struct ahd_softc *ahd);\ntypedef enum {\n\tAHDMSG_1B,\n\tAHDMSG_2B,\n\tAHDMSG_EXT\n} ahd_msgtype;\nstatic int\t\tahd_sent_msg(struct ahd_softc *ahd, ahd_msgtype type,\n\t\t\t\t     u_int msgval, int full);\nstatic int\t\tahd_parse_msg(struct ahd_softc *ahd,\n\t\t\t\t      struct ahd_devinfo *devinfo);\nstatic int\t\tahd_handle_msg_reject(struct ahd_softc *ahd,\n\t\t\t\t\t      struct ahd_devinfo *devinfo);\nstatic void\t\tahd_handle_ign_wide_residue(struct ahd_softc *ahd,\n\t\t\t\t\t\tstruct ahd_devinfo *devinfo);\nstatic void\t\tahd_reinitialize_dataptrs(struct ahd_softc *ahd);\nstatic void\t\tahd_handle_devreset(struct ahd_softc *ahd,\n\t\t\t\t\t    struct ahd_devinfo *devinfo,\n\t\t\t\t\t    u_int lun, cam_status status,\n\t\t\t\t\t    char *message, int verbose_level);\n#ifdef AHD_TARGET_MODE\nstatic void\t\tahd_setup_target_msgin(struct ahd_softc *ahd,\n\t\t\t\t\t       struct ahd_devinfo *devinfo,\n\t\t\t\t\t       struct scb *scb);\n#endif\n\nstatic u_int\t\tahd_sglist_size(struct ahd_softc *ahd);\nstatic u_int\t\tahd_sglist_allocsize(struct ahd_softc *ahd);\nstatic bus_dmamap_callback_t\n\t\t\tahd_dmamap_cb;\nstatic void\t\tahd_initialize_hscbs(struct ahd_softc *ahd);\nstatic int\t\tahd_init_scbdata(struct ahd_softc *ahd);\nstatic void\t\tahd_fini_scbdata(struct ahd_softc *ahd);\nstatic void\t\tahd_setup_iocell_workaround(struct ahd_softc *ahd);\nstatic void\t\tahd_iocell_first_selection(struct ahd_softc *ahd);\nstatic void\t\tahd_add_col_list(struct ahd_softc *ahd,\n\t\t\t\t\t struct scb *scb, u_int col_idx);\nstatic void\t\tahd_rem_col_list(struct ahd_softc *ahd,\n\t\t\t\t\t struct scb *scb);\nstatic void\t\tahd_chip_init(struct ahd_softc *ahd);\nstatic void\t\tahd_qinfifo_requeue(struct ahd_softc *ahd,\n\t\t\t\t\t    struct scb *prev_scb,\n\t\t\t\t\t    struct scb *scb);\nstatic int\t\tahd_qinfifo_count(struct ahd_softc *ahd);\nstatic int\t\tahd_search_scb_list(struct ahd_softc *ahd, int target,\n\t\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t\t    role_t role, uint32_t status,\n\t\t\t\t\t    ahd_search_action action,\n\t\t\t\t\t    u_int *list_head, u_int *list_tail,\n\t\t\t\t\t    u_int tid);\nstatic void\t\tahd_stitch_tid_list(struct ahd_softc *ahd,\n\t\t\t\t\t    u_int tid_prev, u_int tid_cur,\n\t\t\t\t\t    u_int tid_next);\nstatic void\t\tahd_add_scb_to_free_list(struct ahd_softc *ahd,\n\t\t\t\t\t\t u_int scbid);\nstatic u_int\t\tahd_rem_wscb(struct ahd_softc *ahd, u_int scbid,\n\t\t\t\t     u_int prev, u_int next, u_int tid);\nstatic void\t\tahd_reset_current_bus(struct ahd_softc *ahd);\nstatic void\t\tahd_stat_timer(struct timer_list *t);\n#ifdef AHD_DUMP_SEQ\nstatic void\t\tahd_dumpseq(struct ahd_softc *ahd);\n#endif\nstatic void\t\tahd_loadseq(struct ahd_softc *ahd);\nstatic int\t\tahd_check_patch(struct ahd_softc *ahd,\n\t\t\t\t\tconst struct patch **start_patch,\n\t\t\t\t\tu_int start_instr, u_int *skip_addr);\nstatic u_int\t\tahd_resolve_seqaddr(struct ahd_softc *ahd,\n\t\t\t\t\t    u_int address);\nstatic void\t\tahd_download_instr(struct ahd_softc *ahd,\n\t\t\t\t\t   u_int instrptr, uint8_t *dconsts);\nstatic int\t\tahd_probe_stack_size(struct ahd_softc *ahd);\nstatic int\t\tahd_scb_active_in_fifo(struct ahd_softc *ahd,\n\t\t\t\t\t       struct scb *scb);\nstatic void\t\tahd_run_data_fifo(struct ahd_softc *ahd,\n\t\t\t\t\t  struct scb *scb);\n\n#ifdef AHD_TARGET_MODE\nstatic void\t\tahd_queue_lstate_event(struct ahd_softc *ahd,\n\t\t\t\t\t       struct ahd_tmode_lstate *lstate,\n\t\t\t\t\t       u_int initiator_id,\n\t\t\t\t\t       u_int event_type,\n\t\t\t\t\t       u_int event_arg);\nstatic void\t\tahd_update_scsiid(struct ahd_softc *ahd,\n\t\t\t\t\t  u_int targid_mask);\nstatic int\t\tahd_handle_target_cmd(struct ahd_softc *ahd,\n\t\t\t\t\t      struct target_cmd *cmd);\n#endif\n\nstatic int\t\tahd_abort_scbs(struct ahd_softc *ahd, int target,\n\t\t\t\t       char channel, int lun, u_int tag,\n\t\t\t\t       role_t role, uint32_t status);\nstatic void\t\tahd_alloc_scbs(struct ahd_softc *ahd);\nstatic void\t\tahd_busy_tcl(struct ahd_softc *ahd, u_int tcl,\n\t\t\t\t     u_int scbid);\nstatic void\t\tahd_calc_residual(struct ahd_softc *ahd,\n\t\t\t\t\t  struct scb *scb);\nstatic void\t\tahd_clear_critical_section(struct ahd_softc *ahd);\nstatic void\t\tahd_clear_intstat(struct ahd_softc *ahd);\nstatic void\t\tahd_enable_coalescing(struct ahd_softc *ahd,\n\t\t\t\t\t      int enable);\nstatic u_int\t\tahd_find_busy_tcl(struct ahd_softc *ahd, u_int tcl);\nstatic void\t\tahd_freeze_devq(struct ahd_softc *ahd,\n\t\t\t\t\tstruct scb *scb);\nstatic void\t\tahd_handle_scb_status(struct ahd_softc *ahd,\n\t\t\t\t\t      struct scb *scb);\nstatic const struct ahd_phase_table_entry* ahd_lookup_phase_entry(int phase);\nstatic void\t\tahd_shutdown(void *arg);\nstatic void\t\tahd_update_coalescing_values(struct ahd_softc *ahd,\n\t\t\t\t\t\t     u_int timer,\n\t\t\t\t\t\t     u_int maxcmds,\n\t\t\t\t\t\t     u_int mincmds);\nstatic int\t\tahd_verify_vpd_cksum(struct vpd_config *vpd);\nstatic int\t\tahd_wait_seeprom(struct ahd_softc *ahd);\nstatic int\t\tahd_match_scb(struct ahd_softc *ahd, struct scb *scb,\n\t\t\t\t      int target, char channel, int lun,\n\t\t\t\t      u_int tag, role_t role);\n\nstatic void\t\tahd_reset_cmds_pending(struct ahd_softc *ahd);\n\n \nstatic void\t\tahd_run_qoutfifo(struct ahd_softc *ahd);\n#ifdef AHD_TARGET_MODE\nstatic void\t\tahd_run_tqinfifo(struct ahd_softc *ahd, int paused);\n#endif\nstatic void\t\tahd_handle_hwerrint(struct ahd_softc *ahd);\nstatic void\t\tahd_handle_seqint(struct ahd_softc *ahd, u_int intstat);\nstatic void\t\tahd_handle_scsiint(struct ahd_softc *ahd,\n\t\t\t\t\t   u_int intstat);\n\n \nvoid\nahd_set_modes(struct ahd_softc *ahd, ahd_mode src, ahd_mode dst)\n{\n\tif (ahd->src_mode == src && ahd->dst_mode == dst)\n\t\treturn;\n#ifdef AHD_DEBUG\n\tif (ahd->src_mode == AHD_MODE_UNKNOWN\n\t || ahd->dst_mode == AHD_MODE_UNKNOWN)\n\t\tpanic(\"Setting mode prior to saving it.\\n\");\n\tif ((ahd_debug & AHD_SHOW_MODEPTR) != 0)\n\t\tprintk(\"%s: Setting mode 0x%x\\n\", ahd_name(ahd),\n\t\t       ahd_build_mode_state(ahd, src, dst));\n#endif\n\tahd_outb(ahd, MODE_PTR, ahd_build_mode_state(ahd, src, dst));\n\tahd->src_mode = src;\n\tahd->dst_mode = dst;\n}\n\nstatic void\nahd_update_modes(struct ahd_softc *ahd)\n{\n\tahd_mode_state mode_ptr;\n\tahd_mode src;\n\tahd_mode dst;\n\n\tmode_ptr = ahd_inb(ahd, MODE_PTR);\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_MODEPTR) != 0)\n\t\tprintk(\"Reading mode 0x%x\\n\", mode_ptr);\n#endif\n\tahd_extract_mode_state(ahd, mode_ptr, &src, &dst);\n\tahd_known_modes(ahd, src, dst);\n}\n\nstatic void\nahd_assert_modes(struct ahd_softc *ahd, ahd_mode srcmode,\n\t\t ahd_mode dstmode, const char *file, int line)\n{\n#ifdef AHD_DEBUG\n\tif ((srcmode & AHD_MK_MSK(ahd->src_mode)) == 0\n\t || (dstmode & AHD_MK_MSK(ahd->dst_mode)) == 0) {\n\t\tpanic(\"%s:%s:%d: Mode assertion failed.\\n\",\n\t\t       ahd_name(ahd), file, line);\n\t}\n#endif\n}\n\n#define AHD_ASSERT_MODES(ahd, source, dest) \\\n\tahd_assert_modes(ahd, source, dest, __FILE__, __LINE__);\n\nahd_mode_state\nahd_save_modes(struct ahd_softc *ahd)\n{\n\tif (ahd->src_mode == AHD_MODE_UNKNOWN\n\t || ahd->dst_mode == AHD_MODE_UNKNOWN)\n\t\tahd_update_modes(ahd);\n\n\treturn (ahd_build_mode_state(ahd, ahd->src_mode, ahd->dst_mode));\n}\n\nvoid\nahd_restore_modes(struct ahd_softc *ahd, ahd_mode_state state)\n{\n\tahd_mode src;\n\tahd_mode dst;\n\n\tahd_extract_mode_state(ahd, state, &src, &dst);\n\tahd_set_modes(ahd, src, dst);\n}\n\n \nint\nahd_is_paused(struct ahd_softc *ahd)\n{\n\treturn ((ahd_inb(ahd, HCNTRL) & PAUSE) != 0);\n}\n\n \nvoid\nahd_pause(struct ahd_softc *ahd)\n{\n\tahd_outb(ahd, HCNTRL, ahd->pause);\n\n\t \n\twhile (ahd_is_paused(ahd) == 0)\n\t\t;\n}\n\n \nvoid\nahd_unpause(struct ahd_softc *ahd)\n{\n\t \n\tif (ahd->saved_src_mode != AHD_MODE_UNKNOWN\n\t && ahd->saved_dst_mode != AHD_MODE_UNKNOWN) {\n\t\tif ((ahd->flags & AHD_UPDATE_PEND_CMDS) != 0)\n\t\t\tahd_reset_cmds_pending(ahd);\n\t\tahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);\n\t}\n\n\tif ((ahd_inb(ahd, INTSTAT) & ~CMDCMPLT) == 0)\n\t\tahd_outb(ahd, HCNTRL, ahd->unpause);\n\n\tahd_known_modes(ahd, AHD_MODE_UNKNOWN, AHD_MODE_UNKNOWN);\n}\n\n \nvoid *\nahd_sg_setup(struct ahd_softc *ahd, struct scb *scb,\n\t     void *sgptr, dma_addr_t addr, bus_size_t len, int last)\n{\n\tscb->sg_count++;\n\tif (sizeof(dma_addr_t) > 4\n\t && (ahd->flags & AHD_64BIT_ADDRESSING) != 0) {\n\t\tstruct ahd_dma64_seg *sg;\n\n\t\tsg = (struct ahd_dma64_seg *)sgptr;\n\t\tsg->addr = ahd_htole64(addr);\n\t\tsg->len = ahd_htole32(len | (last ? AHD_DMA_LAST_SEG : 0));\n\t\treturn (sg + 1);\n\t} else {\n\t\tstruct ahd_dma_seg *sg;\n\n\t\tsg = (struct ahd_dma_seg *)sgptr;\n\t\tsg->addr = ahd_htole32(addr & 0xFFFFFFFF);\n\t\tsg->len = ahd_htole32(len | ((addr >> 8) & 0x7F000000)\n\t\t\t\t    | (last ? AHD_DMA_LAST_SEG : 0));\n\t\treturn (sg + 1);\n\t}\n}\n\nstatic void\nahd_setup_scb_common(struct ahd_softc *ahd, struct scb *scb)\n{\n\t \n\tscb->crc_retry_count = 0;\n\tif ((scb->flags & SCB_PACKETIZED) != 0) {\n\t\t \n\t\tscb->hscb->task_attribute = scb->hscb->control & SCB_TAG_TYPE;\n\t} else {\n\t\tif (ahd_get_transfer_length(scb) & 0x01)\n\t\t\tscb->hscb->task_attribute = SCB_XFERLEN_ODD;\n\t\telse\n\t\t\tscb->hscb->task_attribute = 0;\n\t}\n\n\tif (scb->hscb->cdb_len <= MAX_CDB_LEN_WITH_SENSE_ADDR\n\t || (scb->hscb->cdb_len & SCB_CDB_LEN_PTR) != 0)\n\t\tscb->hscb->shared_data.idata.cdb_plus_saddr.sense_addr =\n\t\t    ahd_htole32(scb->sense_busaddr);\n}\n\nstatic void\nahd_setup_data_scb(struct ahd_softc *ahd, struct scb *scb)\n{\n\t \n\tif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {\n\t\tstruct ahd_dma64_seg *sg;\n\n\t\tsg = (struct ahd_dma64_seg *)scb->sg_list;\n\t\tscb->hscb->dataptr = sg->addr;\n\t\tscb->hscb->datacnt = sg->len;\n\t} else {\n\t\tstruct ahd_dma_seg *sg;\n\t\tuint32_t *dataptr_words;\n\n\t\tsg = (struct ahd_dma_seg *)scb->sg_list;\n\t\tdataptr_words = (uint32_t*)&scb->hscb->dataptr;\n\t\tdataptr_words[0] = sg->addr;\n\t\tdataptr_words[1] = 0;\n\t\tif ((ahd->flags & AHD_39BIT_ADDRESSING) != 0) {\n\t\t\tuint64_t high_addr;\n\n\t\t\thigh_addr = ahd_le32toh(sg->len) & 0x7F000000;\n\t\t\tscb->hscb->dataptr |= ahd_htole64(high_addr << 8);\n\t\t}\n\t\tscb->hscb->datacnt = sg->len;\n\t}\n\t \n\tscb->hscb->sgptr = ahd_htole32(scb->sg_list_busaddr|SG_FULL_RESID);\n}\n\nstatic void\nahd_setup_noxfer_scb(struct ahd_softc *ahd, struct scb *scb)\n{\n\tscb->hscb->sgptr = ahd_htole32(SG_LIST_NULL);\n\tscb->hscb->dataptr = 0;\n\tscb->hscb->datacnt = 0;\n}\n\n \nstatic void *\nahd_sg_bus_to_virt(struct ahd_softc *ahd, struct scb *scb, uint32_t sg_busaddr)\n{\n\tdma_addr_t sg_offset;\n\n\t \n\tsg_offset = sg_busaddr - (scb->sg_list_busaddr - ahd_sg_size(ahd));\n\treturn ((uint8_t *)scb->sg_list + sg_offset);\n}\n\nstatic uint32_t\nahd_sg_virt_to_bus(struct ahd_softc *ahd, struct scb *scb, void *sg)\n{\n\tdma_addr_t sg_offset;\n\n\t \n\tsg_offset = ((uint8_t *)sg - (uint8_t *)scb->sg_list)\n\t\t  - ahd_sg_size(ahd);\n\n\treturn (scb->sg_list_busaddr + sg_offset);\n}\n\nstatic void\nahd_sync_scb(struct ahd_softc *ahd, struct scb *scb, int op)\n{\n\tahd_dmamap_sync(ahd, ahd->scb_data.hscb_dmat,\n\t\t\tscb->hscb_map->dmamap,\n\t\t\t (uint8_t*)scb->hscb - scb->hscb_map->vaddr,\n\t\t\t sizeof(*scb->hscb), op);\n}\n\nvoid\nahd_sync_sglist(struct ahd_softc *ahd, struct scb *scb, int op)\n{\n\tif (scb->sg_count == 0)\n\t\treturn;\n\n\tahd_dmamap_sync(ahd, ahd->scb_data.sg_dmat,\n\t\t\tscb->sg_map->dmamap,\n\t\t\t scb->sg_list_busaddr - ahd_sg_size(ahd),\n\t\t\t ahd_sg_size(ahd) * scb->sg_count, op);\n}\n\nstatic void\nahd_sync_sense(struct ahd_softc *ahd, struct scb *scb, int op)\n{\n\tahd_dmamap_sync(ahd, ahd->scb_data.sense_dmat,\n\t\t\tscb->sense_map->dmamap,\n\t\t\t scb->sense_busaddr,\n\t\t\t AHD_SENSE_BUFSIZE, op);\n}\n\n#ifdef AHD_TARGET_MODE\nstatic uint32_t\nahd_targetcmd_offset(struct ahd_softc *ahd, u_int index)\n{\n\treturn (((uint8_t *)&ahd->targetcmds[index])\n\t       - (uint8_t *)ahd->qoutfifo);\n}\n#endif\n\n \n \nstruct ahd_initiator_tinfo *\nahd_fetch_transinfo(struct ahd_softc *ahd, char channel, u_int our_id,\n\t\t    u_int remote_id, struct ahd_tmode_tstate **tstate)\n{\n\t \n\tif (channel == 'B')\n\t\tour_id += 8;\n\t*tstate = ahd->enabled_targets[our_id];\n\treturn (&(*tstate)->transinfo[remote_id]);\n}\n\nuint16_t\nahd_inw(struct ahd_softc *ahd, u_int port)\n{\n\t \n\tuint16_t r = ahd_inb(ahd, port+1) << 8;\n\treturn r | ahd_inb(ahd, port);\n}\n\nvoid\nahd_outw(struct ahd_softc *ahd, u_int port, u_int value)\n{\n\t \n\tahd_outb(ahd, port, value & 0xFF);\n\tahd_outb(ahd, port+1, (value >> 8) & 0xFF);\n}\n\nuint32_t\nahd_inl(struct ahd_softc *ahd, u_int port)\n{\n\treturn ((ahd_inb(ahd, port))\n\t      | (ahd_inb(ahd, port+1) << 8)\n\t      | (ahd_inb(ahd, port+2) << 16)\n\t      | (ahd_inb(ahd, port+3) << 24));\n}\n\nvoid\nahd_outl(struct ahd_softc *ahd, u_int port, uint32_t value)\n{\n\tahd_outb(ahd, port, (value) & 0xFF);\n\tahd_outb(ahd, port+1, ((value) >> 8) & 0xFF);\n\tahd_outb(ahd, port+2, ((value) >> 16) & 0xFF);\n\tahd_outb(ahd, port+3, ((value) >> 24) & 0xFF);\n}\n\nuint64_t\nahd_inq(struct ahd_softc *ahd, u_int port)\n{\n\treturn ((ahd_inb(ahd, port))\n\t      | (ahd_inb(ahd, port+1) << 8)\n\t      | (ahd_inb(ahd, port+2) << 16)\n\t      | (ahd_inb(ahd, port+3) << 24)\n\t      | (((uint64_t)ahd_inb(ahd, port+4)) << 32)\n\t      | (((uint64_t)ahd_inb(ahd, port+5)) << 40)\n\t      | (((uint64_t)ahd_inb(ahd, port+6)) << 48)\n\t      | (((uint64_t)ahd_inb(ahd, port+7)) << 56));\n}\n\nvoid\nahd_outq(struct ahd_softc *ahd, u_int port, uint64_t value)\n{\n\tahd_outb(ahd, port, value & 0xFF);\n\tahd_outb(ahd, port+1, (value >> 8) & 0xFF);\n\tahd_outb(ahd, port+2, (value >> 16) & 0xFF);\n\tahd_outb(ahd, port+3, (value >> 24) & 0xFF);\n\tahd_outb(ahd, port+4, (value >> 32) & 0xFF);\n\tahd_outb(ahd, port+5, (value >> 40) & 0xFF);\n\tahd_outb(ahd, port+6, (value >> 48) & 0xFF);\n\tahd_outb(ahd, port+7, (value >> 56) & 0xFF);\n}\n\nu_int\nahd_get_scbptr(struct ahd_softc *ahd)\n{\n\tAHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),\n\t\t\t ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));\n\treturn (ahd_inb(ahd, SCBPTR) | (ahd_inb(ahd, SCBPTR + 1) << 8));\n}\n\nvoid\nahd_set_scbptr(struct ahd_softc *ahd, u_int scbptr)\n{\n\tAHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),\n\t\t\t ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));\n\tahd_outb(ahd, SCBPTR, scbptr & 0xFF);\n\tahd_outb(ahd, SCBPTR+1, (scbptr >> 8) & 0xFF);\n}\n\n#if 0  \nstatic u_int\nahd_get_hnscb_qoff(struct ahd_softc *ahd)\n{\n\treturn (ahd_inw_atomic(ahd, HNSCB_QOFF));\n}\n#endif\n\nstatic void\nahd_set_hnscb_qoff(struct ahd_softc *ahd, u_int value)\n{\n\tahd_outw_atomic(ahd, HNSCB_QOFF, value);\n}\n\n#if 0  \nstatic u_int\nahd_get_hescb_qoff(struct ahd_softc *ahd)\n{\n\treturn (ahd_inb(ahd, HESCB_QOFF));\n}\n#endif\n\nstatic void\nahd_set_hescb_qoff(struct ahd_softc *ahd, u_int value)\n{\n\tahd_outb(ahd, HESCB_QOFF, value);\n}\n\nstatic u_int\nahd_get_snscb_qoff(struct ahd_softc *ahd)\n{\n\tu_int oldvalue;\n\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);\n\toldvalue = ahd_inw(ahd, SNSCB_QOFF);\n\tahd_outw(ahd, SNSCB_QOFF, oldvalue);\n\treturn (oldvalue);\n}\n\nstatic void\nahd_set_snscb_qoff(struct ahd_softc *ahd, u_int value)\n{\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);\n\tahd_outw(ahd, SNSCB_QOFF, value);\n}\n\n#if 0  \nstatic u_int\nahd_get_sescb_qoff(struct ahd_softc *ahd)\n{\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);\n\treturn (ahd_inb(ahd, SESCB_QOFF));\n}\n#endif\n\nstatic void\nahd_set_sescb_qoff(struct ahd_softc *ahd, u_int value)\n{\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);\n\tahd_outb(ahd, SESCB_QOFF, value);\n}\n\n#if 0  \nstatic u_int\nahd_get_sdscb_qoff(struct ahd_softc *ahd)\n{\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);\n\treturn (ahd_inb(ahd, SDSCB_QOFF) | (ahd_inb(ahd, SDSCB_QOFF + 1) << 8));\n}\n#endif\n\nstatic void\nahd_set_sdscb_qoff(struct ahd_softc *ahd, u_int value)\n{\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);\n\tahd_outb(ahd, SDSCB_QOFF, value & 0xFF);\n\tahd_outb(ahd, SDSCB_QOFF+1, (value >> 8) & 0xFF);\n}\n\nu_int\nahd_inb_scbram(struct ahd_softc *ahd, u_int offset)\n{\n\tu_int value;\n\n\t \n\tvalue = ahd_inb(ahd, offset);\n\tif ((ahd->bugs & AHD_PCIX_SCBRAM_RD_BUG) != 0)\n\t\tahd_inb(ahd, MODE_PTR);\n\treturn (value);\n}\n\nu_int\nahd_inw_scbram(struct ahd_softc *ahd, u_int offset)\n{\n\treturn (ahd_inb_scbram(ahd, offset)\n\t      | (ahd_inb_scbram(ahd, offset+1) << 8));\n}\n\nstatic uint32_t\nahd_inl_scbram(struct ahd_softc *ahd, u_int offset)\n{\n\treturn (ahd_inw_scbram(ahd, offset)\n\t      | (ahd_inw_scbram(ahd, offset+2) << 16));\n}\n\nstatic uint64_t\nahd_inq_scbram(struct ahd_softc *ahd, u_int offset)\n{\n\treturn (ahd_inl_scbram(ahd, offset)\n\t      | ((uint64_t)ahd_inl_scbram(ahd, offset+4)) << 32);\n}\n\nstruct scb *\nahd_lookup_scb(struct ahd_softc *ahd, u_int tag)\n{\n\tstruct scb* scb;\n\n\tif (tag >= AHD_SCB_MAX)\n\t\treturn (NULL);\n\tscb = ahd->scb_data.scbindex[tag];\n\tif (scb != NULL)\n\t\tahd_sync_scb(ahd, scb,\n\t\t\t     BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);\n\treturn (scb);\n}\n\nstatic void\nahd_swap_with_next_hscb(struct ahd_softc *ahd, struct scb *scb)\n{\n\tstruct\t hardware_scb *q_hscb;\n\tstruct\t map_node *q_hscb_map;\n\tuint32_t saved_hscb_busaddr;\n\n\t \n\tq_hscb = ahd->next_queued_hscb;\n\tq_hscb_map = ahd->next_queued_hscb_map;\n\tsaved_hscb_busaddr = q_hscb->hscb_busaddr;\n\tmemcpy(q_hscb, scb->hscb, sizeof(*scb->hscb));\n\tq_hscb->hscb_busaddr = saved_hscb_busaddr;\n\tq_hscb->next_hscb_busaddr = scb->hscb->hscb_busaddr;\n\n\t \n\tahd->next_queued_hscb = scb->hscb;\n\tahd->next_queued_hscb_map = scb->hscb_map;\n\tscb->hscb = q_hscb;\n\tscb->hscb_map = q_hscb_map;\n\n\t \n\tahd->scb_data.scbindex[SCB_GET_TAG(scb)] = scb;\n}\n\n \nvoid\nahd_queue_scb(struct ahd_softc *ahd, struct scb *scb)\n{\n\tahd_swap_with_next_hscb(ahd, scb);\n\n\tif (SCBID_IS_NULL(SCB_GET_TAG(scb)))\n\t\tpanic(\"Attempt to queue invalid SCB tag %x\\n\",\n\t\t      SCB_GET_TAG(scb));\n\n\t \n\tahd->qinfifo[AHD_QIN_WRAP(ahd->qinfifonext)] = SCB_GET_TAG(scb);\n\tahd->qinfifonext++;\n\n\tif (scb->sg_count != 0)\n\t\tahd_setup_data_scb(ahd, scb);\n\telse\n\t\tahd_setup_noxfer_scb(ahd, scb);\n\tahd_setup_scb_common(ahd, scb);\n\n\t \n\tahd_sync_scb(ahd, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_QUEUE) != 0) {\n\t\tuint64_t host_dataptr;\n\n\t\thost_dataptr = ahd_le64toh(scb->hscb->dataptr);\n\t\tprintk(\"%s: Queueing SCB %d:0x%x bus addr 0x%x - 0x%x%x/0x%x\\n\",\n\t\t       ahd_name(ahd),\n\t\t       SCB_GET_TAG(scb), scb->hscb->scsiid,\n\t\t       ahd_le32toh(scb->hscb->hscb_busaddr),\n\t\t       (u_int)((host_dataptr >> 32) & 0xFFFFFFFF),\n\t\t       (u_int)(host_dataptr & 0xFFFFFFFF),\n\t\t       ahd_le32toh(scb->hscb->datacnt));\n\t}\n#endif\n\t \n\tahd_set_hnscb_qoff(ahd, ahd->qinfifonext);\n}\n\n \nstatic void\nahd_sync_qoutfifo(struct ahd_softc *ahd, int op)\n{\n\tahd_dmamap_sync(ahd, ahd->shared_data_dmat, ahd->shared_data_map.dmamap,\n\t\t\t 0,\n\t\t\t AHD_SCB_MAX * sizeof(struct ahd_completion), op);\n}\n\nstatic void\nahd_sync_tqinfifo(struct ahd_softc *ahd, int op)\n{\n#ifdef AHD_TARGET_MODE\n\tif ((ahd->flags & AHD_TARGETROLE) != 0) {\n\t\tahd_dmamap_sync(ahd, ahd->shared_data_dmat,\n\t\t\t\tahd->shared_data_map.dmamap,\n\t\t\t\tahd_targetcmd_offset(ahd, 0),\n\t\t\t\tsizeof(struct target_cmd) * AHD_TMODE_CMDS,\n\t\t\t\top);\n\t}\n#endif\n}\n\n \n#define AHD_RUN_QOUTFIFO 0x1\n#define AHD_RUN_TQINFIFO 0x2\nstatic u_int\nahd_check_cmdcmpltqueues(struct ahd_softc *ahd)\n{\n\tu_int retval;\n\n\tretval = 0;\n\tahd_dmamap_sync(ahd, ahd->shared_data_dmat, ahd->shared_data_map.dmamap,\n\t\t\t ahd->qoutfifonext * sizeof(*ahd->qoutfifo),\n\t\t\t sizeof(*ahd->qoutfifo), BUS_DMASYNC_POSTREAD);\n\tif (ahd->qoutfifo[ahd->qoutfifonext].valid_tag\n\t  == ahd->qoutfifonext_valid_tag)\n\t\tretval |= AHD_RUN_QOUTFIFO;\n#ifdef AHD_TARGET_MODE\n\tif ((ahd->flags & AHD_TARGETROLE) != 0\n\t && (ahd->flags & AHD_TQINFIFO_BLOCKED) == 0) {\n\t\tahd_dmamap_sync(ahd, ahd->shared_data_dmat,\n\t\t\t\tahd->shared_data_map.dmamap,\n\t\t\t\tahd_targetcmd_offset(ahd, ahd->tqinfifofnext),\n\t\t\t\t sizeof(struct target_cmd),\n\t\t\t\tBUS_DMASYNC_POSTREAD);\n\t\tif (ahd->targetcmds[ahd->tqinfifonext].cmd_valid != 0)\n\t\t\tretval |= AHD_RUN_TQINFIFO;\n\t}\n#endif\n\treturn (retval);\n}\n\n \nint\nahd_intr(struct ahd_softc *ahd)\n{\n\tu_int\tintstat;\n\n\tif ((ahd->pause & INTEN) == 0) {\n\t\t \n\t\treturn (0);\n\t}\n\n\t \n\tif ((ahd->flags & AHD_ALL_INTERRUPTS) == 0\n\t && (ahd_check_cmdcmpltqueues(ahd) != 0))\n\t\tintstat = CMDCMPLT;\n\telse\n\t\tintstat = ahd_inb(ahd, INTSTAT);\n\n\tif ((intstat & INT_PEND) == 0)\n\t\treturn (0);\n\n\tif (intstat & CMDCMPLT) {\n\t\tahd_outb(ahd, CLRINT, CLRCMDINT);\n\n\t\t \n\t\tif ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {\n\t\t\tif (ahd_is_paused(ahd)) {\n\t\t\t\t \n\t\t\t\tif (ahd_inb(ahd, SEQINTCODE) != NO_SEQINT)\n\t\t\t\t\tintstat |= SEQINT;\n\t\t\t}\n\t\t} else {\n\t\t\tahd_flush_device_writes(ahd);\n\t\t}\n\t\tahd_run_qoutfifo(ahd);\n\t\tahd->cmdcmplt_counts[ahd->cmdcmplt_bucket]++;\n\t\tahd->cmdcmplt_total++;\n#ifdef AHD_TARGET_MODE\n\t\tif ((ahd->flags & AHD_TARGETROLE) != 0)\n\t\t\tahd_run_tqinfifo(ahd,  FALSE);\n#endif\n\t}\n\n\t \n\tif (intstat == 0xFF && (ahd->features & AHD_REMOVABLE) != 0) {\n\t\t \n\t} else if (intstat & HWERRINT) {\n\t\tahd_handle_hwerrint(ahd);\n\t} else if ((intstat & (PCIINT|SPLTINT)) != 0) {\n\t\tahd->bus_intr(ahd);\n\t} else {\n\n\t\tif ((intstat & SEQINT) != 0)\n\t\t\tahd_handle_seqint(ahd, intstat);\n\n\t\tif ((intstat & SCSIINT) != 0)\n\t\t\tahd_handle_scsiint(ahd, intstat);\n\t}\n\treturn (1);\n}\n\n \nstatic inline void\nahd_assert_atn(struct ahd_softc *ahd)\n{\n\tahd_outb(ahd, SCSISIGO, ATNO);\n}\n\n \nstatic int\nahd_currently_packetized(struct ahd_softc *ahd)\n{\n\tahd_mode_state\t saved_modes;\n\tint\t\t packetized;\n\n\tsaved_modes = ahd_save_modes(ahd);\n\tif ((ahd->bugs & AHD_PKTIZED_STATUS_BUG) != 0) {\n\t\t \n\t\tahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\n\t\tpacketized = ahd_inb(ahd, LQISTATE) != 0;\n\t} else {\n\t\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\t\tpacketized = ahd_inb(ahd, LQISTAT2) & PACKETIZED;\n\t}\n\tahd_restore_modes(ahd, saved_modes);\n\treturn (packetized);\n}\n\nstatic inline int\nahd_set_active_fifo(struct ahd_softc *ahd)\n{\n\tu_int active_fifo;\n\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\n\tactive_fifo = ahd_inb(ahd, DFFSTAT) & CURRFIFO;\n\tswitch (active_fifo) {\n\tcase 0:\n\tcase 1:\n\t\tahd_set_modes(ahd, active_fifo, active_fifo);\n\t\treturn (1);\n\tdefault:\n\t\treturn (0);\n\t}\n}\n\nstatic inline void\nahd_unbusy_tcl(struct ahd_softc *ahd, u_int tcl)\n{\n\tahd_busy_tcl(ahd, tcl, SCB_LIST_NULL);\n}\n\n \nstatic inline void\nahd_update_residual(struct ahd_softc *ahd, struct scb *scb)\n{\n\tuint32_t sgptr;\n\n\tsgptr = ahd_le32toh(scb->hscb->sgptr);\n\tif ((sgptr & SG_STATUS_VALID) != 0)\n\t\tahd_calc_residual(ahd, scb);\n}\n\nstatic inline void\nahd_complete_scb(struct ahd_softc *ahd, struct scb *scb)\n{\n\tuint32_t sgptr;\n\n\tsgptr = ahd_le32toh(scb->hscb->sgptr);\n\tif ((sgptr & SG_STATUS_VALID) != 0)\n\t\tahd_handle_scb_status(ahd, scb);\n\telse\n\t\tahd_done(ahd, scb);\n}\n\n\n \n \nstatic void\nahd_restart(struct ahd_softc *ahd)\n{\n\n\tahd_pause(ahd);\n\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\n\t \n\tahd_clear_msg_state(ahd);\n\tahd_outb(ahd, SCSISIGO, 0);\t\t \n\tahd_outb(ahd, MSG_OUT, NOP);\t \n\tahd_outb(ahd, SXFRCTL1, ahd_inb(ahd, SXFRCTL1) & ~BITBUCKET);\n\tahd_outb(ahd, SEQINTCTL, 0);\n\tahd_outb(ahd, LASTPHASE, P_BUSFREE);\n\tahd_outb(ahd, SEQ_FLAGS, 0);\n\tahd_outb(ahd, SAVED_SCSIID, 0xFF);\n\tahd_outb(ahd, SAVED_LUN, 0xFF);\n\n\t \n\tahd_outb(ahd, TQINPOS, ahd->tqinfifonext);\n\n\t \n\tahd_outb(ahd, SCSISEQ1,\n\t\t ahd_inb(ahd, SCSISEQ_TEMPLATE) & (ENSELI|ENRSELI|ENAUTOATNP));\n\tahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);\n\n\t \n\tahd_outb(ahd, CLRINT, CLRSEQINT);\n\n\tahd_outb(ahd, SEQCTL0, FASTMODE|SEQRESET);\n\tahd_unpause(ahd);\n}\n\nstatic void\nahd_clear_fifo(struct ahd_softc *ahd, u_int fifo)\n{\n\tahd_mode_state\t saved_modes;\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_FIFOS) != 0)\n\t\tprintk(\"%s: Clearing FIFO %d\\n\", ahd_name(ahd), fifo);\n#endif\n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, fifo, fifo);\n\tahd_outb(ahd, DFFSXFRCTL, RSTCHN|CLRSHCNT);\n\tif ((ahd_inb(ahd, SG_STATE) & FETCH_INPROG) != 0)\n\t\tahd_outb(ahd, CCSGCTL, CCSGRESET);\n\tahd_outb(ahd, LONGJMP_ADDR + 1, INVALID_ADDR);\n\tahd_outb(ahd, SG_STATE, 0);\n\tahd_restore_modes(ahd, saved_modes);\n}\n\n \n \nstatic void\nahd_flush_qoutfifo(struct ahd_softc *ahd)\n{\n\tstruct\t\tscb *scb;\n\tahd_mode_state\tsaved_modes;\n\tu_int\t\tsaved_scbptr;\n\tu_int\t\tccscbctl;\n\tu_int\t\tscbid;\n\tu_int\t\tnext_scbid;\n\n\tsaved_modes = ahd_save_modes(ahd);\n\n\t \n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\tsaved_scbptr = ahd_get_scbptr(ahd);\n\twhile ((ahd_inb(ahd, LQISTAT2) & LQIGSAVAIL) != 0) {\n\t\tu_int fifo_mode;\n\t\tu_int i;\n\n\t\tscbid = ahd_inw(ahd, GSFIFO);\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tif (scb == NULL) {\n\t\t\tprintk(\"%s: Warning - GSFIFO SCB %d invalid\\n\",\n\t\t\t       ahd_name(ahd), scbid);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tfifo_mode = 0;\nrescan_fifos:\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\t \n\t\t\tfifo_mode ^= 1;\n\t\t\tahd_set_modes(ahd, fifo_mode, fifo_mode);\n\n\t\t\tif (ahd_scb_active_in_fifo(ahd, scb) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tahd_run_data_fifo(ahd, scb);\n\n\t\t\t \n\t\t\tahd_delay(200);\n\t\t\tgoto rescan_fifos;\n\t\t}\n\t\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\t\tahd_set_scbptr(ahd, scbid);\n\t\tif ((ahd_inb_scbram(ahd, SCB_SGPTR) & SG_LIST_NULL) == 0\n\t\t && ((ahd_inb_scbram(ahd, SCB_SGPTR) & SG_FULL_RESID) != 0\n\t\t  || (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR)\n\t\t      & SG_LIST_NULL) != 0)) {\n\t\t\tu_int comp_head;\n\n\t\t\t \n\t\t\tahd_outb(ahd, SCB_SCSI_STATUS, 0);\n\t\t\tahd_outb(ahd, SCB_SGPTR,\n\t\t\t\t ahd_inb_scbram(ahd, SCB_SGPTR)\n\t\t\t\t | SG_STATUS_VALID);\n\t\t\tahd_outw(ahd, SCB_TAG, scbid);\n\t\t\tahd_outw(ahd, SCB_NEXT_COMPLETE, SCB_LIST_NULL);\n\t\t\tcomp_head = ahd_inw(ahd, COMPLETE_DMA_SCB_HEAD);\n\t\t\tif (SCBID_IS_NULL(comp_head)) {\n\t\t\t\tahd_outw(ahd, COMPLETE_DMA_SCB_HEAD, scbid);\n\t\t\t\tahd_outw(ahd, COMPLETE_DMA_SCB_TAIL, scbid);\n\t\t\t} else {\n\t\t\t\tu_int tail;\n\n\t\t\t\ttail = ahd_inw(ahd, COMPLETE_DMA_SCB_TAIL);\n\t\t\t\tahd_set_scbptr(ahd, tail);\n\t\t\t\tahd_outw(ahd, SCB_NEXT_COMPLETE, scbid);\n\t\t\t\tahd_outw(ahd, COMPLETE_DMA_SCB_TAIL, scbid);\n\t\t\t\tahd_set_scbptr(ahd, scbid);\n\t\t\t}\n\t\t} else\n\t\t\tahd_complete_scb(ahd, scb);\n\t}\n\tahd_set_scbptr(ahd, saved_scbptr);\n\n\t \n\tahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);\n\n\t \n\twhile (((ccscbctl = ahd_inb(ahd, CCSCBCTL)) & (CCARREN|CCSCBEN)) != 0) {\n\n\t\tif ((ccscbctl & (CCSCBDIR|CCARREN)) == (CCSCBDIR|CCARREN)) {\n\t\t\tif ((ccscbctl & ARRDONE) != 0)\n\t\t\t\tbreak;\n\t\t} else if ((ccscbctl & CCSCBDONE) != 0)\n\t\t\tbreak;\n\t\tahd_delay(200);\n\t}\n\t \n\tif ((ccscbctl & CCSCBDIR) != 0 || (ccscbctl & ARRDONE) != 0)\n\t\tahd_outb(ahd, CCSCBCTL, ccscbctl & ~(CCARREN|CCSCBEN));\n\n\t \n\tahd_run_qoutfifo(ahd);\n\n\tsaved_scbptr = ahd_get_scbptr(ahd);\n\t \n\tscbid = ahd_inw(ahd, COMPLETE_DMA_SCB_HEAD);\n\twhile (!SCBID_IS_NULL(scbid)) {\n\t\tuint8_t *hscb_ptr;\n\t\tu_int\t i;\n\n\t\tahd_set_scbptr(ahd, scbid);\n\t\tnext_scbid = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tif (scb == NULL) {\n\t\t\tprintk(\"%s: Warning - DMA-up and complete \"\n\t\t\t       \"SCB %d invalid\\n\", ahd_name(ahd), scbid);\n\t\t\tcontinue;\n\t\t}\n\t\thscb_ptr = (uint8_t *)scb->hscb;\n\t\tfor (i = 0; i < sizeof(struct hardware_scb); i++)\n\t\t\t*hscb_ptr++ = ahd_inb_scbram(ahd, SCB_BASE + i);\n\n\t\tahd_complete_scb(ahd, scb);\n\t\tscbid = next_scbid;\n\t}\n\tahd_outw(ahd, COMPLETE_DMA_SCB_HEAD, SCB_LIST_NULL);\n\tahd_outw(ahd, COMPLETE_DMA_SCB_TAIL, SCB_LIST_NULL);\n\n\tscbid = ahd_inw(ahd, COMPLETE_ON_QFREEZE_HEAD);\n\twhile (!SCBID_IS_NULL(scbid)) {\n\n\t\tahd_set_scbptr(ahd, scbid);\n\t\tnext_scbid = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tif (scb == NULL) {\n\t\t\tprintk(\"%s: Warning - Complete Qfrz SCB %d invalid\\n\",\n\t\t\t       ahd_name(ahd), scbid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tahd_complete_scb(ahd, scb);\n\t\tscbid = next_scbid;\n\t}\n\tahd_outw(ahd, COMPLETE_ON_QFREEZE_HEAD, SCB_LIST_NULL);\n\n\tscbid = ahd_inw(ahd, COMPLETE_SCB_HEAD);\n\twhile (!SCBID_IS_NULL(scbid)) {\n\n\t\tahd_set_scbptr(ahd, scbid);\n\t\tnext_scbid = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tif (scb == NULL) {\n\t\t\tprintk(\"%s: Warning - Complete SCB %d invalid\\n\",\n\t\t\t       ahd_name(ahd), scbid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tahd_complete_scb(ahd, scb);\n\t\tscbid = next_scbid;\n\t}\n\tahd_outw(ahd, COMPLETE_SCB_HEAD, SCB_LIST_NULL);\n\n\t \n\tahd_set_scbptr(ahd, saved_scbptr);\n\tahd_restore_modes(ahd, saved_modes);\n\tahd->flags |= AHD_UPDATE_PEND_CMDS;\n}\n\n \nstatic int\nahd_scb_active_in_fifo(struct ahd_softc *ahd, struct scb *scb)\n{\n\n\t \n\tif (ahd_get_scbptr(ahd) != SCB_GET_TAG(scb)\n\t || ((ahd_inb(ahd, LONGJMP_ADDR+1) & INVALID_ADDR) != 0\n\t  && (ahd_inb(ahd, SEQINTSRC) & (CFG4DATA|SAVEPTRS)) == 0))\n\t\treturn (0);\n\n\treturn (1);\n}\n\n \nstatic void\nahd_run_data_fifo(struct ahd_softc *ahd, struct scb *scb)\n{\n\tu_int seqintsrc;\n\n\tseqintsrc = ahd_inb(ahd, SEQINTSRC);\n\tif ((seqintsrc & CFG4DATA) != 0) {\n\t\tuint32_t datacnt;\n\t\tuint32_t sgptr;\n\n\t\t \n\t\tsgptr = ahd_inl_scbram(ahd, SCB_SGPTR) & ~SG_FULL_RESID;\n\t\tahd_outb(ahd, SCB_SGPTR, sgptr);\n\n\t\t \n\t\tdatacnt = ahd_inl_scbram(ahd, SCB_DATACNT);\n\t\tif ((datacnt & AHD_DMA_LAST_SEG) != 0) {\n\t\t\tsgptr |= LAST_SEG;\n\t\t\tahd_outb(ahd, SG_STATE, 0);\n\t\t} else\n\t\t\tahd_outb(ahd, SG_STATE, LOADING_NEEDED);\n\t\tahd_outq(ahd, HADDR, ahd_inq_scbram(ahd, SCB_DATAPTR));\n\t\tahd_outl(ahd, HCNT, datacnt & AHD_SG_LEN_MASK);\n\t\tahd_outb(ahd, SG_CACHE_PRE, sgptr);\n\t\tahd_outb(ahd, DFCNTRL, PRELOADEN|SCSIEN|HDMAEN);\n\n\t\t \n\t\tahd_outb(ahd, SCB_RESIDUAL_DATACNT+3, datacnt >> 24);\n\t\tahd_outl(ahd, SCB_RESIDUAL_SGPTR, sgptr & SG_PTR_MASK);\n\n\t\t \n\t\tahd_outb(ahd, SCB_FIFO_USE_COUNT,\n\t\t\t ahd_inb_scbram(ahd, SCB_FIFO_USE_COUNT) + 1);\n\n\t\t \n\t\tahd_outw(ahd, LONGJMP_ADDR, 0);\n\n\t\t \n\t\tahd_outb(ahd, CLRSEQINTSRC, CLRCFG4DATA);\n\t} else if ((seqintsrc & SAVEPTRS) != 0) {\n\t\tuint32_t sgptr;\n\t\tuint32_t resid;\n\n\t\tif ((ahd_inb(ahd, LONGJMP_ADDR+1)&INVALID_ADDR) != 0) {\n\t\t\t \n\t\t\tgoto clrchn;\n\t\t}\n\n\t\t \n\t\tif ((ahd_inb(ahd, SG_STATE) & FETCH_INPROG) != 0)\n\t\t\tahd_outb(ahd, CCSGCTL, 0);\n\t\tahd_outb(ahd, SG_STATE, 0);\n\n\t\t \n\t\tahd_outb(ahd, DFCNTRL, ahd_inb(ahd, DFCNTRL) | FIFOFLUSH);\n\n\t\t \n\t\tsgptr = ahd_inl_scbram(ahd, SCB_RESIDUAL_SGPTR);\n\t\tresid = ahd_inl(ahd, SHCNT);\n\t\tresid |= ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT+3) << 24;\n\t\tahd_outl(ahd, SCB_RESIDUAL_DATACNT, resid);\n\t\tif ((ahd_inb(ahd, SG_CACHE_SHADOW) & LAST_SEG) == 0) {\n\t\t\t \n\t\t\tif ((ahd_inb(ahd, SG_CACHE_SHADOW) & 0x80) != 0\n\t\t\t && (sgptr & 0x80) == 0)\n\t\t\t\tsgptr -= 0x100;\n\t\t\tsgptr &= ~0xFF;\n\t\t\tsgptr |= ahd_inb(ahd, SG_CACHE_SHADOW)\n\t\t\t       & SG_ADDR_MASK;\n\t\t\tahd_outl(ahd, SCB_RESIDUAL_SGPTR, sgptr);\n\t\t\tahd_outb(ahd, SCB_RESIDUAL_DATACNT + 3, 0);\n\t\t} else if ((resid & AHD_SG_LEN_MASK) == 0) {\n\t\t\tahd_outb(ahd, SCB_RESIDUAL_SGPTR,\n\t\t\t\t sgptr | SG_LIST_NULL);\n\t\t}\n\t\t \n\t\tahd_outq(ahd, SCB_DATAPTR, ahd_inq(ahd, SHADDR));\n\t\tahd_outl(ahd, SCB_DATACNT, resid);\n\t\tahd_outl(ahd, SCB_SGPTR, sgptr);\n\t\tahd_outb(ahd, CLRSEQINTSRC, CLRSAVEPTRS);\n\t\tahd_outb(ahd, SEQIMODE,\n\t\t\t ahd_inb(ahd, SEQIMODE) | ENSAVEPTRS);\n\t\t \n\t\tif ((ahd_inb(ahd, DFCNTRL) & DIRECTION) != 0)\n\t\t\tgoto clrchn;\n\t} else if ((ahd_inb(ahd, SG_STATE) & LOADING_NEEDED) != 0) {\n\t\tuint32_t sgptr;\n\t\tuint64_t data_addr;\n\t\tuint32_t data_len;\n\t\tu_int\t dfcntrl;\n\n\t\t \n\t\tif ((ahd_inb(ahd, SG_STATE) & FETCH_INPROG) != 0) {\n\t\t\tahd_outb(ahd, CCSGCTL, 0);\n\t\t\tahd_outb(ahd, SG_STATE, LOADING_NEEDED);\n\t\t}\n\n\t\t \n\t\tif ((ahd_inb(ahd, DFSTATUS) & PRELOAD_AVAIL) != 0\n\t\t && (ahd_inb(ahd, DFCNTRL) & HDMAENACK) != 0) {\n\n\t\t\t \n\t\t\tsgptr = ahd_inl_scbram(ahd, SCB_RESIDUAL_SGPTR);\n\t\t\tsgptr &= SG_PTR_MASK;\n\t\t\tif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {\n\t\t\t\tstruct ahd_dma64_seg *sg;\n\n\t\t\t\tsg = ahd_sg_bus_to_virt(ahd, scb, sgptr);\n\t\t\t\tdata_addr = sg->addr;\n\t\t\t\tdata_len = sg->len;\n\t\t\t\tsgptr += sizeof(*sg);\n\t\t\t} else {\n\t\t\t\tstruct\tahd_dma_seg *sg;\n\n\t\t\t\tsg = ahd_sg_bus_to_virt(ahd, scb, sgptr);\n\t\t\t\tdata_addr = sg->len & AHD_SG_HIGH_ADDR_MASK;\n\t\t\t\tdata_addr <<= 8;\n\t\t\t\tdata_addr |= sg->addr;\n\t\t\t\tdata_len = sg->len;\n\t\t\t\tsgptr += sizeof(*sg);\n\t\t\t}\n\n\t\t\t \n\t\t\tahd_outb(ahd, SCB_RESIDUAL_DATACNT+3, data_len >> 24);\n\t\t\tahd_outl(ahd, SCB_RESIDUAL_SGPTR, sgptr);\n\n\t\t\t \n\t\t\tif (data_len & AHD_DMA_LAST_SEG) {\n\t\t\t\tsgptr |= LAST_SEG;\n\t\t\t\tahd_outb(ahd, SG_STATE, 0);\n\t\t\t}\n\t\t\tahd_outq(ahd, HADDR, data_addr);\n\t\t\tahd_outl(ahd, HCNT, data_len & AHD_SG_LEN_MASK);\n\t\t\tahd_outb(ahd, SG_CACHE_PRE, sgptr & 0xFF);\n\n\t\t\t \n\t\t\tdfcntrl = ahd_inb(ahd, DFCNTRL)|PRELOADEN|HDMAEN;\n\t\t\tif ((ahd->features & AHD_NEW_DFCNTRL_OPTS) != 0) {\n\t\t\t\t \n\t\t\t\tdfcntrl |= SCSIENWRDIS;\n\t\t\t}\n\t\t\tahd_outb(ahd, DFCNTRL, dfcntrl);\n\t\t}\n\t} else if ((ahd_inb(ahd, SG_CACHE_SHADOW) & LAST_SEG_DONE) != 0) {\n\n\t\t \n\t\tahd_outb(ahd, SCB_SGPTR,\n\t\t\t ahd_inb_scbram(ahd, SCB_SGPTR) | SG_LIST_NULL);\n\t\tgoto clrchn;\n\t} else if ((ahd_inb(ahd, DFSTATUS) & FIFOEMP) != 0) {\nclrchn:\n\t\t \n\t\tahd_outb(ahd, LONGJMP_ADDR + 1, INVALID_ADDR);\n\t\tahd_outb(ahd, SCB_FIFO_USE_COUNT,\n\t\t\t ahd_inb_scbram(ahd, SCB_FIFO_USE_COUNT) - 1);\n\t\tahd_outb(ahd, DFFSXFRCTL, CLRCHN);\n\t}\n}\n\n \nstatic void\nahd_run_qoutfifo(struct ahd_softc *ahd)\n{\n\tstruct ahd_completion *completion;\n\tstruct scb *scb;\n\tu_int  scb_index;\n\n\tif ((ahd->flags & AHD_RUNNING_QOUTFIFO) != 0)\n\t\tpanic(\"ahd_run_qoutfifo recursion\");\n\tahd->flags |= AHD_RUNNING_QOUTFIFO;\n\tahd_sync_qoutfifo(ahd, BUS_DMASYNC_POSTREAD);\n\tfor (;;) {\n\t\tcompletion = &ahd->qoutfifo[ahd->qoutfifonext];\n\n\t\tif (completion->valid_tag != ahd->qoutfifonext_valid_tag)\n\t\t\tbreak;\n\n\t\tscb_index = ahd_le16toh(completion->tag);\n\t\tscb = ahd_lookup_scb(ahd, scb_index);\n\t\tif (scb == NULL) {\n\t\t\tprintk(\"%s: WARNING no command for scb %d \"\n\t\t\t       \"(cmdcmplt)\\nQOUTPOS = %d\\n\",\n\t\t\t       ahd_name(ahd), scb_index,\n\t\t\t       ahd->qoutfifonext);\n\t\t\tahd_dump_card_state(ahd);\n\t\t} else if ((completion->sg_status & SG_STATUS_VALID) != 0) {\n\t\t\tahd_handle_scb_status(ahd, scb);\n\t\t} else {\n\t\t\tahd_done(ahd, scb);\n\t\t}\n\n\t\tahd->qoutfifonext = (ahd->qoutfifonext+1) & (AHD_QOUT_SIZE-1);\n\t\tif (ahd->qoutfifonext == 0)\n\t\t\tahd->qoutfifonext_valid_tag ^= QOUTFIFO_ENTRY_VALID;\n\t}\n\tahd->flags &= ~AHD_RUNNING_QOUTFIFO;\n}\n\n \nstatic void\nahd_handle_hwerrint(struct ahd_softc *ahd)\n{\n\t \n\tint i;\n\tint error;\n\n\terror = ahd_inb(ahd, ERROR);\n\tfor (i = 0; i < num_errors; i++) {\n\t\tif ((error & ahd_hard_errors[i].errno) != 0)\n\t\t\tprintk(\"%s: hwerrint, %s\\n\",\n\t\t\t       ahd_name(ahd), ahd_hard_errors[i].errmesg);\n\t}\n\n\tahd_dump_card_state(ahd);\n\tpanic(\"BRKADRINT\");\n\n\t \n\tahd_abort_scbs(ahd, CAM_TARGET_WILDCARD, ALL_CHANNELS,\n\t\t       CAM_LUN_WILDCARD, SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t       CAM_NO_HBA);\n\n\t \n\tahd_free(ahd);\n}\n\n#ifdef AHD_DEBUG\nstatic void\nahd_dump_sglist(struct scb *scb)\n{\n\tint i;\n\n\tif (scb->sg_count > 0) {\n\t\tif ((scb->ahd_softc->flags & AHD_64BIT_ADDRESSING) != 0) {\n\t\t\tstruct ahd_dma64_seg *sg_list;\n\n\t\t\tsg_list = (struct ahd_dma64_seg*)scb->sg_list;\n\t\t\tfor (i = 0; i < scb->sg_count; i++) {\n\t\t\t\tuint64_t addr;\n\n\t\t\t\taddr = ahd_le64toh(sg_list[i].addr);\n\t\t\t\tprintk(\"sg[%d] - Addr 0x%x%x : Length %d%s\\n\",\n\t\t\t\t       i,\n\t\t\t\t       (uint32_t)((addr >> 32) & 0xFFFFFFFF),\n\t\t\t\t       (uint32_t)(addr & 0xFFFFFFFF),\n\t\t\t\t       sg_list[i].len & AHD_SG_LEN_MASK,\n\t\t\t\t       (sg_list[i].len & AHD_DMA_LAST_SEG)\n\t\t\t\t     ? \" Last\" : \"\");\n\t\t\t}\n\t\t} else {\n\t\t\tstruct ahd_dma_seg *sg_list;\n\n\t\t\tsg_list = (struct ahd_dma_seg*)scb->sg_list;\n\t\t\tfor (i = 0; i < scb->sg_count; i++) {\n\t\t\t\tuint32_t len;\n\n\t\t\t\tlen = ahd_le32toh(sg_list[i].len);\n\t\t\t\tprintk(\"sg[%d] - Addr 0x%x%x : Length %d%s\\n\",\n\t\t\t\t       i,\n\t\t\t\t       (len & AHD_SG_HIGH_ADDR_MASK) >> 24,\n\t\t\t\t       ahd_le32toh(sg_list[i].addr),\n\t\t\t\t       len & AHD_SG_LEN_MASK,\n\t\t\t\t       len & AHD_DMA_LAST_SEG ? \" Last\" : \"\");\n\t\t\t}\n\t\t}\n\t}\n}\n#endif   \n\nstatic void\nahd_handle_seqint(struct ahd_softc *ahd, u_int intstat)\n{\n\tu_int seqintcode;\n\n\t \n\tseqintcode = ahd_inb(ahd, SEQINTCODE);\n\tahd_outb(ahd, CLRINT, CLRSEQINT);\n\tif ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {\n\t\t \n\t\tahd_unpause(ahd);\n\t\twhile (!ahd_is_paused(ahd))\n\t\t\t;\n\t\tahd_outb(ahd, CLRINT, CLRSEQINT);\n\t}\n\tahd_update_modes(ahd);\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_MISC) != 0)\n\t\tprintk(\"%s: Handle Seqint Called for code %d\\n\",\n\t\t       ahd_name(ahd), seqintcode);\n#endif\n\tswitch (seqintcode) {\n\tcase ENTERING_NONPACK:\n\t{\n\t\tstruct\tscb *scb;\n\t\tu_int\tscbid;\n\n\t\tAHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),\n\t\t\t\t ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));\n\t\tscbid = ahd_get_scbptr(ahd);\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tif (scb == NULL) {\n\t\t\t \n\t\t} else {\n\t\t\tahd_outb(ahd, SAVED_SCSIID, scb->hscb->scsiid);\n\t\t\tahd_outb(ahd, SAVED_LUN, scb->hscb->lun);\n\t\t\tahd_outb(ahd, SEQ_FLAGS, 0x0);\n\t\t}\n\t\tif ((ahd_inb(ahd, LQISTAT2) & LQIPHASE_OUTPKT) != 0\n\t\t && (ahd_inb(ahd, SCSISIGO) & ATNO) != 0) {\n\t\t\t \n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_RECOVERY) != 0)\n\t\t\t\tprintk(\"%s: Assuming LQIPHASE_NLQ with \"\n\t\t\t\t       \"P0 assertion\\n\", ahd_name(ahd));\n#endif\n\t\t}\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_RECOVERY) != 0)\n\t\t\tprintk(\"%s: Entering NONPACK\\n\", ahd_name(ahd));\n#endif\n\t\tbreak;\n\t}\n\tcase INVALID_SEQINT:\n\t\tprintk(\"%s: Invalid Sequencer interrupt occurred, \"\n\t\t       \"resetting channel.\\n\",\n\t\t       ahd_name(ahd));\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_RECOVERY) != 0)\n\t\t\tahd_dump_card_state(ahd);\n#endif\n\t\tahd_reset_channel(ahd, 'A',  TRUE);\n\t\tbreak;\n\tcase STATUS_OVERRUN:\n\t{\n\t\tstruct\tscb *scb;\n\t\tu_int\tscbid;\n\n\t\tscbid = ahd_get_scbptr(ahd);\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tif (scb != NULL)\n\t\t\tahd_print_path(ahd, scb);\n\t\telse\n\t\t\tprintk(\"%s: \", ahd_name(ahd));\n\t\tprintk(\"SCB %d Packetized Status Overrun\", scbid);\n\t\tahd_dump_card_state(ahd);\n\t\tahd_reset_channel(ahd, 'A',  TRUE);\n\t\tbreak;\n\t}\n\tcase CFG4ISTAT_INTR:\n\t{\n\t\tstruct\tscb *scb;\n\t\tu_int\tscbid;\n\n\t\tscbid = ahd_get_scbptr(ahd);\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tif (scb == NULL) {\n\t\t\tahd_dump_card_state(ahd);\n\t\t\tprintk(\"CFG4ISTAT: Free SCB %d referenced\", scbid);\n\t\t\tpanic(\"For safety\");\n\t\t}\n\t\tahd_outq(ahd, HADDR, scb->sense_busaddr);\n\t\tahd_outw(ahd, HCNT, AHD_SENSE_BUFSIZE);\n\t\tahd_outb(ahd, HCNT + 2, 0);\n\t\tahd_outb(ahd, SG_CACHE_PRE, SG_LAST_SEG);\n\t\tahd_outb(ahd, DFCNTRL, PRELOADEN|SCSIEN|HDMAEN);\n\t\tbreak;\n\t}\n\tcase ILLEGAL_PHASE:\n\t{\n\t\tu_int bus_phase;\n\n\t\tbus_phase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;\n\t\tprintk(\"%s: ILLEGAL_PHASE 0x%x\\n\",\n\t\t       ahd_name(ahd), bus_phase);\n\n\t\tswitch (bus_phase) {\n\t\tcase P_DATAOUT:\n\t\tcase P_DATAIN:\n\t\tcase P_DATAOUT_DT:\n\t\tcase P_DATAIN_DT:\n\t\tcase P_MESGOUT:\n\t\tcase P_STATUS:\n\t\tcase P_MESGIN:\n\t\t\tahd_reset_channel(ahd, 'A',  TRUE);\n\t\t\tprintk(\"%s: Issued Bus Reset.\\n\", ahd_name(ahd));\n\t\t\tbreak;\n\t\tcase P_COMMAND:\n\t\t{\n\t\t\tstruct\tahd_devinfo devinfo;\n\t\t\tstruct\tscb *scb;\n\t\t\tu_int\tscbid;\n\n\t\t\t \n\t\t\tscbid = ahd_get_scbptr(ahd);\n\t\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\t\tif (scb == NULL) {\n\t\t\t\tprintk(\"Invalid phase with no valid SCB.  \"\n\t\t\t\t       \"Resetting bus.\\n\");\n\t\t\t\tahd_reset_channel(ahd, 'A',\n\t\t\t\t\t\t   TRUE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tahd_compile_devinfo(&devinfo, SCB_GET_OUR_ID(scb),\n\t\t\t\t\t    SCB_GET_TARGET(ahd, scb),\n\t\t\t\t\t    SCB_GET_LUN(scb),\n\t\t\t\t\t    SCB_GET_CHANNEL(ahd, scb),\n\t\t\t\t\t    ROLE_INITIATOR);\n\t\t\tahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHD_TRANS_ACTIVE,  TRUE);\n\t\t\tahd_set_syncrate(ahd, &devinfo,  0,\n\t\t\t\t\t  0,  0,\n\t\t\t\t\t AHD_TRANS_ACTIVE,  TRUE);\n\t\t\t \n\t\t\tahd_outb(ahd, SCB_CDB_STORE, 0);\n\t\t\tahd_outb(ahd, SCB_CDB_STORE+1, 0);\n\t\t\tahd_outb(ahd, SCB_CDB_STORE+2, 0);\n\t\t\tahd_outb(ahd, SCB_CDB_STORE+3, 0);\n\t\t\tahd_outb(ahd, SCB_CDB_STORE+4, 0);\n\t\t\tahd_outb(ahd, SCB_CDB_STORE+5, 0);\n\t\t\tahd_outb(ahd, SCB_CDB_LEN, 6);\n\t\t\tscb->hscb->control &= ~(TAG_ENB|SCB_TAG_TYPE);\n\t\t\tscb->hscb->control |= MK_MESSAGE;\n\t\t\tahd_outb(ahd, SCB_CONTROL, scb->hscb->control);\n\t\t\tahd_outb(ahd, MSG_OUT, HOST_MSG);\n\t\t\tahd_outb(ahd, SAVED_SCSIID, scb->hscb->scsiid);\n\t\t\t \n\t\t\tahd_outb(ahd, SAVED_LUN, 0);\n\t\t\tahd_outb(ahd, SEQ_FLAGS, 0);\n\t\t\tahd_assert_atn(ahd);\n\t\t\tscb->flags &= ~SCB_PACKETIZED;\n\t\t\tscb->flags |= SCB_ABORT|SCB_EXTERNAL_RESET;\n\t\t\tahd_freeze_devq(ahd, scb);\n\t\t\tahd_set_transaction_status(scb, CAM_REQUEUE_REQ);\n\t\t\tahd_freeze_scb(scb);\n\n\t\t\t \n\t\t\tahd_send_async(ahd, devinfo.channel, devinfo.target,\n\t\t\t\t       CAM_LUN_WILDCARD, AC_SENT_BDR);\n\n\t\t\t \n\t\t\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\t\t\tahd_outb(ahd, CLRLQOINT1, CLRLQOPHACHGINPKT);\n\t\t\tif ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0) {\n\t\t\t\tahd_outb(ahd, CLRLQOINT1, 0);\n\t\t\t}\n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {\n\t\t\t\tahd_print_path(ahd, scb);\n\t\t\t\tprintk(\"Unexpected command phase from \"\n\t\t\t\t       \"packetized target\\n\");\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase CFG4OVERRUN:\n\t{\n\t\tstruct\tscb *scb;\n\t\tu_int\tscb_index;\n\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {\n\t\t\tprintk(\"%s: CFG4OVERRUN mode = %x\\n\", ahd_name(ahd),\n\t\t\t       ahd_inb(ahd, MODE_PTR));\n\t\t}\n#endif\n\t\tscb_index = ahd_get_scbptr(ahd);\n\t\tscb = ahd_lookup_scb(ahd, scb_index);\n\t\tif (scb == NULL) {\n\t\t\t \n\t\t\tahd_assert_atn(ahd);\n\t\t\tahd_outb(ahd, MSG_OUT, HOST_MSG);\n\t\t\tahd->msgout_buf[0] = ABORT_TASK;\n\t\t\tahd->msgout_len = 1;\n\t\t\tahd->msgout_index = 0;\n\t\t\tahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\t\t \n\t\t\tahd_outb(ahd, SCB_CONTROL,\n\t\t\t\t ahd_inb_scbram(ahd, SCB_CONTROL)\n\t\t\t\t & ~STATUS_RCVD);\n\t\t}\n\t\tbreak;\n\t}\n\tcase DUMP_CARD_STATE:\n\t{\n\t\tahd_dump_card_state(ahd);\n\t\tbreak;\n\t}\n\tcase PDATA_REINIT:\n\t{\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {\n\t\t\tprintk(\"%s: PDATA_REINIT - DFCNTRL = 0x%x \"\n\t\t\t       \"SG_CACHE_SHADOW = 0x%x\\n\",\n\t\t\t       ahd_name(ahd), ahd_inb(ahd, DFCNTRL),\n\t\t\t       ahd_inb(ahd, SG_CACHE_SHADOW));\n\t\t}\n#endif\n\t\tahd_reinitialize_dataptrs(ahd);\n\t\tbreak;\n\t}\n\tcase HOST_MSG_LOOP:\n\t{\n\t\tstruct ahd_devinfo devinfo;\n\n\t\t \n\t\tahd_fetch_devinfo(ahd, &devinfo);\n\t\tif (ahd->msg_type == MSG_TYPE_NONE) {\n\t\t\tstruct scb *scb;\n\t\t\tu_int scb_index;\n\t\t\tu_int bus_phase;\n\n\t\t\tbus_phase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;\n\t\t\tif (bus_phase != P_MESGIN\n\t\t\t && bus_phase != P_MESGOUT) {\n\t\t\t\tprintk(\"ahd_intr: HOST_MSG_LOOP bad \"\n\t\t\t\t       \"phase 0x%x\\n\", bus_phase);\n\t\t\t\t \n\t\t\t\tahd_dump_card_state(ahd);\n\t\t\t\tahd_clear_intstat(ahd);\n\t\t\t\tahd_restart(ahd);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tscb_index = ahd_get_scbptr(ahd);\n\t\t\tscb = ahd_lookup_scb(ahd, scb_index);\n\t\t\tif (devinfo.role == ROLE_INITIATOR) {\n\t\t\t\tif (bus_phase == P_MESGOUT)\n\t\t\t\t\tahd_setup_initiator_msgout(ahd,\n\t\t\t\t\t\t\t\t   &devinfo,\n\t\t\t\t\t\t\t\t   scb);\n\t\t\t\telse {\n\t\t\t\t\tahd->msg_type =\n\t\t\t\t\t    MSG_TYPE_INITIATOR_MSGIN;\n\t\t\t\t\tahd->msgin_index = 0;\n\t\t\t\t}\n\t\t\t}\n#ifdef AHD_TARGET_MODE\n\t\t\telse {\n\t\t\t\tif (bus_phase == P_MESGOUT) {\n\t\t\t\t\tahd->msg_type =\n\t\t\t\t\t    MSG_TYPE_TARGET_MSGOUT;\n\t\t\t\t\tahd->msgin_index = 0;\n\t\t\t\t} else\n\t\t\t\t\tahd_setup_target_msgin(ahd,\n\t\t\t\t\t\t\t       &devinfo,\n\t\t\t\t\t\t\t       scb);\n\t\t\t}\n#endif\n\t\t}\n\n\t\tahd_handle_message_phase(ahd);\n\t\tbreak;\n\t}\n\tcase NO_MATCH:\n\t{\n\t\t \n\t\tAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\n\t\tahd_outb(ahd, SCSISEQ0, ahd_inb(ahd, SCSISEQ0) & ~ENSELO);\n\n\t\tprintk(\"%s:%c:%d: no active SCB for reconnecting \"\n\t\t       \"target - issuing BUS DEVICE RESET\\n\",\n\t\t       ahd_name(ahd), 'A', ahd_inb(ahd, SELID) >> 4);\n\t\tprintk(\"SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, \"\n\t\t       \"REG0 == 0x%x ACCUM = 0x%x\\n\",\n\t\t       ahd_inb(ahd, SAVED_SCSIID), ahd_inb(ahd, SAVED_LUN),\n\t\t       ahd_inw(ahd, REG0), ahd_inb(ahd, ACCUM));\n\t\tprintk(\"SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, \"\n\t\t       \"SINDEX == 0x%x\\n\",\n\t\t       ahd_inb(ahd, SEQ_FLAGS), ahd_get_scbptr(ahd),\n\t\t       ahd_find_busy_tcl(ahd,\n\t\t\t\t\t BUILD_TCL(ahd_inb(ahd, SAVED_SCSIID),\n\t\t\t\t\t\t   ahd_inb(ahd, SAVED_LUN))),\n\t\t       ahd_inw(ahd, SINDEX));\n\t\tprintk(\"SELID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, \"\n\t\t       \"SCB_CONTROL == 0x%x\\n\",\n\t\t       ahd_inb(ahd, SELID), ahd_inb_scbram(ahd, SCB_SCSIID),\n\t\t       ahd_inb_scbram(ahd, SCB_LUN),\n\t\t       ahd_inb_scbram(ahd, SCB_CONTROL));\n\t\tprintk(\"SCSIBUS[0] == 0x%x, SCSISIGI == 0x%x\\n\",\n\t\t       ahd_inb(ahd, SCSIBUS), ahd_inb(ahd, SCSISIGI));\n\t\tprintk(\"SXFRCTL0 == 0x%x\\n\", ahd_inb(ahd, SXFRCTL0));\n\t\tprintk(\"SEQCTL0 == 0x%x\\n\", ahd_inb(ahd, SEQCTL0));\n\t\tahd_dump_card_state(ahd);\n\t\tahd->msgout_buf[0] = TARGET_RESET;\n\t\tahd->msgout_len = 1;\n\t\tahd->msgout_index = 0;\n\t\tahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\tahd_outb(ahd, MSG_OUT, HOST_MSG);\n\t\tahd_assert_atn(ahd);\n\t\tbreak;\n\t}\n\tcase PROTO_VIOLATION:\n\t{\n\t\tahd_handle_proto_violation(ahd);\n\t\tbreak;\n\t}\n\tcase IGN_WIDE_RES:\n\t{\n\t\tstruct ahd_devinfo devinfo;\n\n\t\tahd_fetch_devinfo(ahd, &devinfo);\n\t\tahd_handle_ign_wide_residue(ahd, &devinfo);\n\t\tbreak;\n\t}\n\tcase BAD_PHASE:\n\t{\n\t\tu_int lastphase;\n\n\t\tlastphase = ahd_inb(ahd, LASTPHASE);\n\t\tprintk(\"%s:%c:%d: unknown scsi bus phase %x, \"\n\t\t       \"lastphase = 0x%x.  Attempting to continue\\n\",\n\t\t       ahd_name(ahd), 'A',\n\t\t       SCSIID_TARGET(ahd, ahd_inb(ahd, SAVED_SCSIID)),\n\t\t       lastphase, ahd_inb(ahd, SCSISIGI));\n\t\tbreak;\n\t}\n\tcase MISSED_BUSFREE:\n\t{\n\t\tu_int lastphase;\n\n\t\tlastphase = ahd_inb(ahd, LASTPHASE);\n\t\tprintk(\"%s:%c:%d: Missed busfree. \"\n\t\t       \"Lastphase = 0x%x, Curphase = 0x%x\\n\",\n\t\t       ahd_name(ahd), 'A',\n\t\t       SCSIID_TARGET(ahd, ahd_inb(ahd, SAVED_SCSIID)),\n\t\t       lastphase, ahd_inb(ahd, SCSISIGI));\n\t\tahd_restart(ahd);\n\t\treturn;\n\t}\n\tcase DATA_OVERRUN:\n\t{\n\t\t \n\t\tstruct\tscb *scb;\n\t\tu_int\tscbindex;\n#ifdef AHD_DEBUG\n\t\tu_int\tlastphase;\n#endif\n\n\t\tscbindex = ahd_get_scbptr(ahd);\n\t\tscb = ahd_lookup_scb(ahd, scbindex);\n#ifdef AHD_DEBUG\n\t\tlastphase = ahd_inb(ahd, LASTPHASE);\n\t\tif ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {\n\t\t\tahd_print_path(ahd, scb);\n\t\t\tprintk(\"data overrun detected %s.  Tag == 0x%x.\\n\",\n\t\t\t       ahd_lookup_phase_entry(lastphase)->phasemsg,\n\t\t\t       SCB_GET_TAG(scb));\n\t\t\tahd_print_path(ahd, scb);\n\t\t\tprintk(\"%s seen Data Phase.  Length = %ld.  \"\n\t\t\t       \"NumSGs = %d.\\n\",\n\t\t\t       ahd_inb(ahd, SEQ_FLAGS) & DPHASE\n\t\t\t       ? \"Have\" : \"Haven't\",\n\t\t\t       ahd_get_transfer_length(scb), scb->sg_count);\n\t\t\tahd_dump_sglist(scb);\n\t\t}\n#endif\n\n\t\t \n\t\tahd_freeze_devq(ahd, scb);\n\t\tahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);\n\t\tahd_freeze_scb(scb);\n\t\tbreak;\n\t}\n\tcase MKMSG_FAILED:\n\t{\n\t\tstruct ahd_devinfo devinfo;\n\t\tstruct scb *scb;\n\t\tu_int scbid;\n\n\t\tahd_fetch_devinfo(ahd, &devinfo);\n\t\tprintk(\"%s:%c:%d:%d: Attempt to issue message failed\\n\",\n\t\t       ahd_name(ahd), devinfo.channel, devinfo.target,\n\t\t       devinfo.lun);\n\t\tscbid = ahd_get_scbptr(ahd);\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tif (scb != NULL\n\t\t && (scb->flags & SCB_RECOVERY_SCB) != 0)\n\t\t\t \n\t\t\tahd_search_qinfifo(ahd, SCB_GET_TARGET(ahd, scb),\n\t\t\t\t\t   SCB_GET_CHANNEL(ahd, scb),\n\t\t\t\t\t   SCB_GET_LUN(scb), SCB_GET_TAG(scb),\n\t\t\t\t\t   ROLE_INITIATOR,  0,\n\t\t\t\t\t   SEARCH_REMOVE);\n\t\tahd_outb(ahd, SCB_CONTROL,\n\t\t\t ahd_inb_scbram(ahd, SCB_CONTROL) & ~MK_MESSAGE);\n\t\tbreak;\n\t}\n\tcase TASKMGMT_FUNC_COMPLETE:\n\t{\n\t\tu_int\tscbid;\n\t\tstruct\tscb *scb;\n\n\t\tscbid = ahd_get_scbptr(ahd);\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tif (scb != NULL) {\n\t\t\tu_int\t   lun;\n\t\t\tu_int\t   tag;\n\t\t\tcam_status error;\n\n\t\t\tahd_print_path(ahd, scb);\n\t\t\tprintk(\"Task Management Func 0x%x Complete\\n\",\n\t\t\t       scb->hscb->task_management);\n\t\t\tlun = CAM_LUN_WILDCARD;\n\t\t\ttag = SCB_LIST_NULL;\n\n\t\t\tswitch (scb->hscb->task_management) {\n\t\t\tcase SIU_TASKMGMT_ABORT_TASK:\n\t\t\t\ttag = SCB_GET_TAG(scb);\n\t\t\t\tfallthrough;\n\t\t\tcase SIU_TASKMGMT_ABORT_TASK_SET:\n\t\t\tcase SIU_TASKMGMT_CLEAR_TASK_SET:\n\t\t\t\tlun = scb->hscb->lun;\n\t\t\t\terror = CAM_REQ_ABORTED;\n\t\t\t\tahd_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),\n\t\t\t\t\t       'A', lun, tag, ROLE_INITIATOR,\n\t\t\t\t\t       error);\n\t\t\t\tbreak;\n\t\t\tcase SIU_TASKMGMT_LUN_RESET:\n\t\t\t\tlun = scb->hscb->lun;\n\t\t\t\tfallthrough;\n\t\t\tcase SIU_TASKMGMT_TARGET_RESET:\n\t\t\t{\n\t\t\t\tstruct ahd_devinfo devinfo;\n\n\t\t\t\tahd_scb_devinfo(ahd, &devinfo, scb);\n\t\t\t\terror = CAM_BDR_SENT;\n\t\t\t\tahd_handle_devreset(ahd, &devinfo, lun,\n\t\t\t\t\t\t    CAM_BDR_SENT,\n\t\t\t\t\t\t    lun != CAM_LUN_WILDCARD\n\t\t\t\t\t\t    ? \"Lun Reset\"\n\t\t\t\t\t\t    : \"Target Reset\",\n\t\t\t\t\t\t     0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tpanic(\"Unexpected TaskMgmt Func\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase TASKMGMT_CMD_CMPLT_OKAY:\n\t{\n\t\tu_int\tscbid;\n\t\tstruct\tscb *scb;\n\n\t\t \n\t\tscbid = ahd_get_scbptr(ahd);\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tif (scb != NULL) {\n\t\t\t \n\t\t\tahd_print_path(ahd, scb);\n\t\t\tprintk(\"SCB completes before TMF\\n\");\n\t\t\t \n\t\t\twhile ((ahd_inb(ahd, SCSISEQ0) & ENSELO) != 0\n\t\t\t    && (ahd_inb(ahd, SSTAT0) & SELDO) == 0\n\t\t\t    && (ahd_inb(ahd, SSTAT1) & SELTO) == 0)\n\t\t\t\t;\n\t\t\tahd_outb(ahd, SCB_TASK_MANAGEMENT, 0);\n\t\t\tahd_search_qinfifo(ahd, SCB_GET_TARGET(ahd, scb),\n\t\t\t\t\t   SCB_GET_CHANNEL(ahd, scb),\n\t\t\t\t\t   SCB_GET_LUN(scb), SCB_GET_TAG(scb),\n\t\t\t\t\t   ROLE_INITIATOR,  0,\n\t\t\t\t\t   SEARCH_REMOVE);\n\t\t}\n\t\tbreak;\n\t}\n\tcase TRACEPOINT0:\n\tcase TRACEPOINT1:\n\tcase TRACEPOINT2:\n\tcase TRACEPOINT3:\n\t\tprintk(\"%s: Tracepoint %d\\n\", ahd_name(ahd),\n\t\t       seqintcode - TRACEPOINT0);\n\t\tbreak;\n\tcase NO_SEQINT:\n\t\tbreak;\n\tcase SAW_HWERR:\n\t\tahd_handle_hwerrint(ahd);\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"%s: Unexpected SEQINTCODE %d\\n\", ahd_name(ahd),\n\t\t       seqintcode);\n\t\tbreak;\n\t}\n\t \n\tahd_unpause(ahd);\n}\n\nstatic void\nahd_handle_scsiint(struct ahd_softc *ahd, u_int intstat)\n{\n\tstruct scb\t*scb;\n\tu_int\t\t status0;\n\tu_int\t\t status3;\n\tu_int\t\t status;\n\tu_int\t\t lqistat1;\n\tu_int\t\t lqostat0;\n\tu_int\t\t scbid;\n\tu_int\t\t busfreetime;\n\n\tahd_update_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\n\tstatus3 = ahd_inb(ahd, SSTAT3) & (NTRAMPERR|OSRAMPERR);\n\tstatus0 = ahd_inb(ahd, SSTAT0) & (IOERR|OVERRUN|SELDI|SELDO);\n\tstatus = ahd_inb(ahd, SSTAT1) & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);\n\tlqistat1 = ahd_inb(ahd, LQISTAT1);\n\tlqostat0 = ahd_inb(ahd, LQOSTAT0);\n\tbusfreetime = ahd_inb(ahd, SSTAT2) & BUSFREETIME;\n\n\t \n\tif (((status & SCSIRSTI) != 0) && (ahd->flags & AHD_BUS_RESET_ACTIVE)) {\n\t\tahd_outb(ahd, CLRSINT1, CLRSCSIRSTI);\n\t\treturn;\n\t}\n\n\t \n\tahd->flags &= ~AHD_BUS_RESET_ACTIVE;\n\n\tif ((status0 & (SELDI|SELDO)) != 0) {\n\t\tu_int simode0;\n\n\t\tahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\n\t\tsimode0 = ahd_inb(ahd, SIMODE0);\n\t\tstatus0 &= simode0 & (IOERR|OVERRUN|SELDI|SELDO);\n\t\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\t}\n\tscbid = ahd_get_scbptr(ahd);\n\tscb = ahd_lookup_scb(ahd, scbid);\n\tif (scb != NULL\n\t && (ahd_inb(ahd, SEQ_FLAGS) & NOT_IDENTIFIED) != 0)\n\t\tscb = NULL;\n\n\tif ((status0 & IOERR) != 0) {\n\t\tu_int now_lvd;\n\n\t\tnow_lvd = ahd_inb(ahd, SBLKCTL) & ENAB40;\n\t\tprintk(\"%s: Transceiver State Has Changed to %s mode\\n\",\n\t\t       ahd_name(ahd), now_lvd ? \"LVD\" : \"SE\");\n\t\tahd_outb(ahd, CLRSINT0, CLRIOERR);\n\t\t \n\t\tahd_reset_channel(ahd, 'A',  TRUE);\n\t\tahd_pause(ahd);\n\t\tahd_setup_iocell_workaround(ahd);\n\t\tahd_unpause(ahd);\n\t} else if ((status0 & OVERRUN) != 0) {\n\n\t\tprintk(\"%s: SCSI offset overrun detected.  Resetting bus.\\n\",\n\t\t       ahd_name(ahd));\n\t\tahd_reset_channel(ahd, 'A',  TRUE);\n\t} else if ((status & SCSIRSTI) != 0) {\n\n\t\tprintk(\"%s: Someone reset channel A\\n\", ahd_name(ahd));\n\t\tahd_reset_channel(ahd, 'A',  FALSE);\n\t} else if ((status & SCSIPERR) != 0) {\n\n\t\t \n\t\tahd_clear_critical_section(ahd);\n\n\t\tahd_handle_transmission_error(ahd);\n\t} else if (lqostat0 != 0) {\n\n\t\tprintk(\"%s: lqostat0 == 0x%x!\\n\", ahd_name(ahd), lqostat0);\n\t\tahd_outb(ahd, CLRLQOINT0, lqostat0);\n\t\tif ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0)\n\t\t\tahd_outb(ahd, CLRLQOINT1, 0);\n\t} else if ((status & SELTO) != 0) {\n\t\t \n\t\tahd_outb(ahd, SCSISEQ0, 0);\n\n\t\t \n\t\tahd_clear_critical_section(ahd);\n\n\t\t \n\t\tahd_clear_msg_state(ahd);\n\n\t\t \n\t\tahd_outb(ahd, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);\n\n\t\t \n\t\tahd_outb(ahd, CLRSINT0, CLRSELINGO);\n\n\t\tscbid = ahd_inw(ahd, WAITING_TID_HEAD);\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tif (scb == NULL) {\n\t\t\tprintk(\"%s: ahd_intr - referenced scb not \"\n\t\t\t       \"valid during SELTO scb(0x%x)\\n\",\n\t\t\t       ahd_name(ahd), scbid);\n\t\t\tahd_dump_card_state(ahd);\n\t\t} else {\n\t\t\tstruct ahd_devinfo devinfo;\n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_SELTO) != 0) {\n\t\t\t\tahd_print_path(ahd, scb);\n\t\t\t\tprintk(\"Saw Selection Timeout for SCB 0x%x\\n\",\n\t\t\t\t       scbid);\n\t\t\t}\n#endif\n\t\t\tahd_scb_devinfo(ahd, &devinfo, scb);\n\t\t\tahd_set_transaction_status(scb, CAM_SEL_TIMEOUT);\n\t\t\tahd_freeze_devq(ahd, scb);\n\n\t\t\t \n\t\t\tahd_handle_devreset(ahd, &devinfo,\n\t\t\t\t\t    CAM_LUN_WILDCARD,\n\t\t\t\t\t    CAM_SEL_TIMEOUT,\n\t\t\t\t\t    \"Selection Timeout\",\n\t\t\t\t\t     1);\n\t\t}\n\t\tahd_outb(ahd, CLRINT, CLRSCSIINT);\n\t\tahd_iocell_first_selection(ahd);\n\t\tahd_unpause(ahd);\n\t} else if ((status0 & (SELDI|SELDO)) != 0) {\n\n\t\tahd_iocell_first_selection(ahd);\n\t\tahd_unpause(ahd);\n\t} else if (status3 != 0) {\n\t\tprintk(\"%s: SCSI Cell parity error SSTAT3 == 0x%x\\n\",\n\t\t       ahd_name(ahd), status3);\n\t\tahd_outb(ahd, CLRSINT3, status3);\n\t} else if ((lqistat1 & (LQIPHASE_LQ|LQIPHASE_NLQ)) != 0) {\n\n\t\t \n\t\tahd_clear_critical_section(ahd);\n\n\t\tahd_handle_lqiphase_error(ahd, lqistat1);\n\t} else if ((lqistat1 & LQICRCI_NLQ) != 0) {\n\t\t \n\t\tahd_outb(ahd, CLRLQIINT1, CLRLQICRCI_NLQ);\n\t} else if ((status & BUSFREE) != 0\n\t\t|| (lqistat1 & LQOBUSFREE) != 0) {\n\t\tu_int lqostat1;\n\t\tint   restart;\n\t\tint   clear_fifo;\n\t\tint   packetized;\n\t\tu_int mode;\n\n\t\t \n\t\tahd_outb(ahd, SCSISEQ0, 0);\n\n\t\t \n\t\tahd_clear_critical_section(ahd);\n\n\t\t \n\t\tmode = AHD_MODE_SCSI;\n\t\tbusfreetime = ahd_inb(ahd, SSTAT2) & BUSFREETIME;\n\t\tlqostat1 = ahd_inb(ahd, LQOSTAT1);\n\t\tswitch (busfreetime) {\n\t\tcase BUSFREE_DFF0:\n\t\tcase BUSFREE_DFF1:\n\t\t{\n\t\t\tmode = busfreetime == BUSFREE_DFF0\n\t\t\t     ? AHD_MODE_DFF0 : AHD_MODE_DFF1;\n\t\t\tahd_set_modes(ahd, mode, mode);\n\t\t\tscbid = ahd_get_scbptr(ahd);\n\t\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\t\tif (scb == NULL) {\n\t\t\t\tprintk(\"%s: Invalid SCB %d in DFF%d \"\n\t\t\t\t       \"during unexpected busfree\\n\",\n\t\t\t\t       ahd_name(ahd), scbid, mode);\n\t\t\t\tpacketized = 0;\n\t\t\t} else\n\t\t\t\tpacketized = (scb->flags & SCB_PACKETIZED) != 0;\n\t\t\tclear_fifo = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase BUSFREE_LQO:\n\t\t\tclear_fifo = 0;\n\t\t\tpacketized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclear_fifo = 0;\n\t\t\tpacketized =  (lqostat1 & LQOBUSFREE) != 0;\n\t\t\tif (!packetized\n\t\t\t && ahd_inb(ahd, LASTPHASE) == P_BUSFREE\n\t\t\t && (ahd_inb(ahd, SSTAT0) & SELDI) == 0\n\t\t\t && ((ahd_inb(ahd, SSTAT0) & SELDO) == 0\n\t\t\t  || (ahd_inb(ahd, SCSISEQ0) & ENSELO) == 0))\n\t\t\t\t \n\t\t\t\tpacketized = 1;\n\t\t\tbreak;\n\t\t}\n\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_MISC) != 0)\n\t\t\tprintk(\"Saw Busfree.  Busfreetime = 0x%x.\\n\",\n\t\t\t       busfreetime);\n#endif\n\t\t \n\t\tif (packetized && ahd_inb(ahd, LASTPHASE) == P_BUSFREE) {\n\t\t\trestart = ahd_handle_pkt_busfree(ahd, busfreetime);\n\t\t} else {\n\t\t\tpacketized = 0;\n\t\t\trestart = ahd_handle_nonpkt_busfree(ahd);\n\t\t}\n\t\t \n\t\tahd_outb(ahd, CLRSINT1, CLRBUSFREE);\n\t\tif (packetized == 0\n\t\t && (ahd->bugs & AHD_BUSFREEREV_BUG) != 0)\n\t\t\tahd_outb(ahd, SIMODE1,\n\t\t\t\t ahd_inb(ahd, SIMODE1) & ~ENBUSFREE);\n\n\t\tif (clear_fifo)\n\t\t\tahd_clear_fifo(ahd, mode);\n\n\t\tahd_clear_msg_state(ahd);\n\t\tahd_outb(ahd, CLRINT, CLRSCSIINT);\n\t\tif (restart) {\n\t\t\tahd_restart(ahd);\n\t\t} else {\n\t\t\tahd_unpause(ahd);\n\t\t}\n\t} else {\n\t\tprintk(\"%s: Missing case in ahd_handle_scsiint. status = %x\\n\",\n\t\t       ahd_name(ahd), status);\n\t\tahd_dump_card_state(ahd);\n\t\tahd_clear_intstat(ahd);\n\t\tahd_unpause(ahd);\n\t}\n}\n\nstatic void\nahd_handle_transmission_error(struct ahd_softc *ahd)\n{\n\tstruct\tscb *scb;\n\tu_int\tscbid;\n\tu_int\tlqistat1;\n\tu_int\tmsg_out;\n\tu_int\tcurphase;\n\tu_int\tlastphase;\n\tu_int\tperrdiag;\n\tu_int\tcur_col;\n\tint\tsilent;\n\n\tscb = NULL;\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\tlqistat1 = ahd_inb(ahd, LQISTAT1) & ~(LQIPHASE_LQ|LQIPHASE_NLQ);\n\tahd_inb(ahd, LQISTAT2);\n\tif ((lqistat1 & (LQICRCI_NLQ|LQICRCI_LQ)) == 0\n\t && (ahd->bugs & AHD_NLQICRC_DELAYED_BUG) != 0) {\n\t\tu_int lqistate;\n\n\t\tahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\n\t\tlqistate = ahd_inb(ahd, LQISTATE);\n\t\tif ((lqistate >= 0x1E && lqistate <= 0x24)\n\t\t || (lqistate == 0x29)) {\n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {\n\t\t\t\tprintk(\"%s: NLQCRC found via LQISTATE\\n\",\n\t\t\t\t       ahd_name(ahd));\n\t\t\t}\n#endif\n\t\t\tlqistat1 |= LQICRCI_NLQ;\n\t\t}\n\t\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\t}\n\n\tahd_outb(ahd, CLRLQIINT1, lqistat1);\n\tlastphase = ahd_inb(ahd, LASTPHASE);\n\tcurphase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;\n\tperrdiag = ahd_inb(ahd, PERRDIAG);\n\tmsg_out = INITIATOR_ERROR;\n\tahd_outb(ahd, CLRSINT1, CLRSCSIPERR);\n\n\t \n\tsilent = FALSE;\n\tif (lqistat1 == 0\n\t || (lqistat1 & LQICRCI_NLQ) != 0) {\n\t\tif ((lqistat1 & (LQICRCI_NLQ|LQIOVERI_NLQ)) != 0)\n\t\t\tahd_set_active_fifo(ahd);\n\t\tscbid = ahd_get_scbptr(ahd);\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tif (scb != NULL && SCB_IS_SILENT(scb))\n\t\t\tsilent = TRUE;\n\t}\n\n\tcur_col = 0;\n\tif (silent == FALSE) {\n\t\tprintk(\"%s: Transmission error detected\\n\", ahd_name(ahd));\n\t\tahd_lqistat1_print(lqistat1, &cur_col, 50);\n\t\tahd_lastphase_print(lastphase, &cur_col, 50);\n\t\tahd_scsisigi_print(curphase, &cur_col, 50);\n\t\tahd_perrdiag_print(perrdiag, &cur_col, 50);\n\t\tprintk(\"\\n\");\n\t\tahd_dump_card_state(ahd);\n\t}\n\n\tif ((lqistat1 & (LQIOVERI_LQ|LQIOVERI_NLQ)) != 0) {\n\t\tif (silent == FALSE) {\n\t\t\tprintk(\"%s: Gross protocol error during incoming \"\n\t\t\t       \"packet.  lqistat1 == 0x%x.  Resetting bus.\\n\",\n\t\t\t       ahd_name(ahd), lqistat1);\n\t\t}\n\t\tahd_reset_channel(ahd, 'A',  TRUE);\n\t\treturn;\n\t} else if ((lqistat1 & LQICRCI_LQ) != 0) {\n\t\t \n\t\tahd_outb(ahd, LQCTL2, LQIRETRY);\n\t\tprintk(\"LQIRetry for LQICRCI_LQ to release ACK\\n\");\n\t} else if ((lqistat1 & LQICRCI_NLQ) != 0) {\n\t\t \n\t\tif (silent == FALSE)\n\t\t\tprintk(\"LQICRC_NLQ\\n\");\n\t\tif (scb == NULL) {\n\t\t\tprintk(\"%s: No SCB valid for LQICRC_NLQ.  \"\n\t\t\t       \"Resetting bus\\n\", ahd_name(ahd));\n\t\t\tahd_reset_channel(ahd, 'A',  TRUE);\n\t\t\treturn;\n\t\t}\n\t} else if ((lqistat1 & LQIBADLQI) != 0) {\n\t\tprintk(\"Need to handle BADLQI!\\n\");\n\t\tahd_reset_channel(ahd, 'A',  TRUE);\n\t\treturn;\n\t} else if ((perrdiag & (PARITYERR|PREVPHASE)) == PARITYERR) {\n\t\tif ((curphase & ~P_DATAIN_DT) != 0) {\n\t\t\t \n\t\t\tif (silent == FALSE)\n\t\t\t\tprintk(\"Acking %s to clear perror\\n\",\n\t\t\t\t    ahd_lookup_phase_entry(curphase)->phasemsg);\n\t\t\tahd_inb(ahd, SCSIDAT);\n\t\t}\n\n\t\tif (curphase == P_MESGIN)\n\t\t\tmsg_out = MSG_PARITY_ERROR;\n\t}\n\n\t \n\tahd->send_msg_perror = msg_out;\n\tif (scb != NULL && msg_out == INITIATOR_ERROR)\n\t\tscb->flags |= SCB_TRANSMISSION_ERROR;\n\tahd_outb(ahd, MSG_OUT, HOST_MSG);\n\tahd_outb(ahd, CLRINT, CLRSCSIINT);\n\tahd_unpause(ahd);\n}\n\nstatic void\nahd_handle_lqiphase_error(struct ahd_softc *ahd, u_int lqistat1)\n{\n\t \n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\tahd_outb(ahd, CLRLQIINT1, lqistat1);\n\n\t \n\tahd_set_active_fifo(ahd);\n\tif ((ahd_inb(ahd, SCSISIGO) & ATNO) != 0\n\t && (ahd_inb(ahd, MDFFSTAT) & DLZERO) != 0) {\n\t\tif ((lqistat1 & LQIPHASE_LQ) != 0) {\n\t\t\tprintk(\"LQIRETRY for LQIPHASE_LQ\\n\");\n\t\t\tahd_outb(ahd, LQCTL2, LQIRETRY);\n\t\t} else if ((lqistat1 & LQIPHASE_NLQ) != 0) {\n\t\t\tprintk(\"LQIRETRY for LQIPHASE_NLQ\\n\");\n\t\t\tahd_outb(ahd, LQCTL2, LQIRETRY);\n\t\t} else\n\t\t\tpanic(\"ahd_handle_lqiphase_error: No phase errors\\n\");\n\t\tahd_dump_card_state(ahd);\n\t\tahd_outb(ahd, CLRINT, CLRSCSIINT);\n\t\tahd_unpause(ahd);\n\t} else {\n\t\tprintk(\"Resetting Channel for LQI Phase error\\n\");\n\t\tahd_dump_card_state(ahd);\n\t\tahd_reset_channel(ahd, 'A',  TRUE);\n\t}\n}\n\n \nstatic int\nahd_handle_pkt_busfree(struct ahd_softc *ahd, u_int busfreetime)\n{\n\tu_int lqostat1;\n\n\tAHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),\n\t\t\t ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));\n\tlqostat1 = ahd_inb(ahd, LQOSTAT1);\n\tif ((lqostat1 & LQOBUSFREE) != 0) {\n\t\tstruct scb *scb;\n\t\tu_int scbid;\n\t\tu_int saved_scbptr;\n\t\tu_int waiting_h;\n\t\tu_int waiting_t;\n\t\tu_int next;\n\n\t\t \n\t\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\t\tscbid = ahd_inw(ahd, CURRSCB);\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tif (scb == NULL)\n\t\t       panic(\"SCB not valid during LQOBUSFREE\");\n\t\t \n\t\tahd_outb(ahd, CLRLQOINT1, CLRLQOBUSFREE);\n\t\tif ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0)\n\t\t\tahd_outb(ahd, CLRLQOINT1, 0);\n\t\tahd_outb(ahd, SCSISEQ0, ahd_inb(ahd, SCSISEQ0) & ~ENSELO);\n\t\tahd_flush_device_writes(ahd);\n\t\tahd_outb(ahd, CLRSINT0, CLRSELDO);\n\n\t\t \n\t\tahd_outb(ahd, LQCTL2, ahd_inb(ahd, LQCTL2) | LQOTOIDLE);\n\n\t\t \n\t\twaiting_h = ahd_inw(ahd, WAITING_TID_HEAD);\n\t\tsaved_scbptr = ahd_get_scbptr(ahd);\n\t\tif (waiting_h != scbid) {\n\n\t\t\tahd_outw(ahd, WAITING_TID_HEAD, scbid);\n\t\t\twaiting_t = ahd_inw(ahd, WAITING_TID_TAIL);\n\t\t\tif (waiting_t == waiting_h) {\n\t\t\t\tahd_outw(ahd, WAITING_TID_TAIL, scbid);\n\t\t\t\tnext = SCB_LIST_NULL;\n\t\t\t} else {\n\t\t\t\tahd_set_scbptr(ahd, waiting_h);\n\t\t\t\tnext = ahd_inw_scbram(ahd, SCB_NEXT2);\n\t\t\t}\n\t\t\tahd_set_scbptr(ahd, scbid);\n\t\t\tahd_outw(ahd, SCB_NEXT2, next);\n\t\t}\n\t\tahd_set_scbptr(ahd, saved_scbptr);\n\t\tif (scb->crc_retry_count < AHD_MAX_LQ_CRC_ERRORS) {\n\t\t\tif (SCB_IS_SILENT(scb) == FALSE) {\n\t\t\t\tahd_print_path(ahd, scb);\n\t\t\t\tprintk(\"Probable outgoing LQ CRC error.  \"\n\t\t\t\t       \"Retrying command\\n\");\n\t\t\t}\n\t\t\tscb->crc_retry_count++;\n\t\t} else {\n\t\t\tahd_set_transaction_status(scb, CAM_UNCOR_PARITY);\n\t\t\tahd_freeze_scb(scb);\n\t\t\tahd_freeze_devq(ahd, scb);\n\t\t}\n\t\t \n\t\treturn (0);\n\t} else if ((ahd_inb(ahd, PERRDIAG) & PARITYERR) != 0) {\n\t\t \n\t\tahd_outb(ahd, CLRSINT1, CLRSCSIPERR|CLRBUSFREE);\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_MASKED_ERRORS) != 0)\n\t\t\tprintk(\"%s: Parity on last REQ detected \"\n\t\t\t       \"during busfree phase.\\n\",\n\t\t\t       ahd_name(ahd));\n#endif\n\t\t \n\t\treturn (0);\n\t}\n\tif (ahd->src_mode != AHD_MODE_SCSI) {\n\t\tu_int\tscbid;\n\t\tstruct\tscb *scb;\n\n\t\tscbid = ahd_get_scbptr(ahd);\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tahd_print_path(ahd, scb);\n\t\tprintk(\"Unexpected PKT busfree condition\\n\");\n\t\tahd_dump_card_state(ahd);\n\t\tahd_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb), 'A',\n\t\t\t       SCB_GET_LUN(scb), SCB_GET_TAG(scb),\n\t\t\t       ROLE_INITIATOR, CAM_UNEXP_BUSFREE);\n\n\t\t \n\t\treturn (1);\n\t}\n\tprintk(\"%s: Unexpected PKT busfree condition\\n\", ahd_name(ahd));\n\tahd_dump_card_state(ahd);\n\t \n\treturn (1);\n}\n\n \nstatic int\nahd_handle_nonpkt_busfree(struct ahd_softc *ahd)\n{\n\tstruct\tahd_devinfo devinfo;\n\tstruct\tscb *scb;\n\tu_int\tlastphase;\n\tu_int\tsaved_scsiid;\n\tu_int\tsaved_lun;\n\tu_int\ttarget;\n\tu_int\tinitiator_role_id;\n\tu_int\tscbid;\n\tu_int\tppr_busfree;\n\tint\tprinterror;\n\n\t \n\tlastphase = ahd_inb(ahd, LASTPHASE);\n\tsaved_scsiid = ahd_inb(ahd, SAVED_SCSIID);\n\tsaved_lun = ahd_inb(ahd, SAVED_LUN);\n\ttarget = SCSIID_TARGET(ahd, saved_scsiid);\n\tinitiator_role_id = SCSIID_OUR_ID(saved_scsiid);\n\tahd_compile_devinfo(&devinfo, initiator_role_id,\n\t\t\t    target, saved_lun, 'A', ROLE_INITIATOR);\n\tprinterror = 1;\n\n\tscbid = ahd_get_scbptr(ahd);\n\tscb = ahd_lookup_scb(ahd, scbid);\n\tif (scb != NULL\n\t && (ahd_inb(ahd, SEQ_FLAGS) & NOT_IDENTIFIED) != 0)\n\t\tscb = NULL;\n\n\tppr_busfree = (ahd->msg_flags & MSG_FLAG_EXPECT_PPR_BUSFREE) != 0;\n\tif (lastphase == P_MESGOUT) {\n\t\tu_int tag;\n\n\t\ttag = SCB_LIST_NULL;\n\t\tif (ahd_sent_msg(ahd, AHDMSG_1B, ABORT_TASK, TRUE)\n\t\t || ahd_sent_msg(ahd, AHDMSG_1B, ABORT_TASK_SET, TRUE)) {\n\t\t\tint found;\n\t\t\tint sent_msg;\n\n\t\t\tif (scb == NULL) {\n\t\t\t\tahd_print_devinfo(ahd, &devinfo);\n\t\t\t\tprintk(\"Abort for unidentified \"\n\t\t\t\t       \"connection completed.\\n\");\n\t\t\t\t \n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tsent_msg = ahd->msgout_buf[ahd->msgout_index - 1];\n\t\t\tahd_print_path(ahd, scb);\n\t\t\tprintk(\"SCB %d - Abort%s Completed.\\n\",\n\t\t\t       SCB_GET_TAG(scb),\n\t\t\t       sent_msg == ABORT_TASK ? \"\" : \" Tag\");\n\n\t\t\tif (sent_msg == ABORT_TASK)\n\t\t\t\ttag = SCB_GET_TAG(scb);\n\n\t\t\tif ((scb->flags & SCB_EXTERNAL_RESET) != 0) {\n\t\t\t\t \n\t\t\t\ttag = SCB_GET_TAG(scb);\n\t\t\t\tsaved_lun = scb->hscb->lun;\n\t\t\t}\n\t\t\tfound = ahd_abort_scbs(ahd, target, 'A', saved_lun,\n\t\t\t\t\t       tag, ROLE_INITIATOR,\n\t\t\t\t\t       CAM_REQ_ABORTED);\n\t\t\tprintk(\"found == 0x%x\\n\", found);\n\t\t\tprinterror = 0;\n\t\t} else if (ahd_sent_msg(ahd, AHDMSG_1B,\n\t\t\t\t\tTARGET_RESET, TRUE)) {\n\t\t\tahd_handle_devreset(ahd, &devinfo, CAM_LUN_WILDCARD,\n\t\t\t\t\t    CAM_BDR_SENT, \"Bus Device Reset\",\n\t\t\t\t\t     0);\n\t\t\tprinterror = 0;\n\t\t} else if (ahd_sent_msg(ahd, AHDMSG_EXT, EXTENDED_PPR, FALSE)\n\t\t\t&& ppr_busfree == 0) {\n\t\t\tstruct ahd_initiator_tinfo *tinfo;\n\t\t\tstruct ahd_tmode_tstate *tstate;\n\n\t\t\t \n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\n\t\t\t\tprintk(\"PPR negotiation rejected busfree.\\n\");\n#endif\n\t\t\ttinfo = ahd_fetch_transinfo(ahd, devinfo.channel,\n\t\t\t\t\t\t    devinfo.our_scsiid,\n\t\t\t\t\t\t    devinfo.target, &tstate);\n\t\t\tif ((tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ)!=0) {\n\t\t\t\tahd_set_width(ahd, &devinfo,\n\t\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t\t      AHD_TRANS_CUR,\n\t\t\t\t\t       TRUE);\n\t\t\t\tahd_set_syncrate(ahd, &devinfo,\n\t\t\t\t\t\t 0,  0,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\tAHD_TRANS_CUR,\n\t\t\t\t\t\t TRUE);\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\ttinfo->curr.transport_version = 2;\n\t\t\t\ttinfo->goal.transport_version = 2;\n\t\t\t\ttinfo->goal.ppr_options = 0;\n\t\t\t\tif (scb != NULL) {\n\t\t\t\t\t \n\t\t\t\t\tahd_freeze_devq(ahd, scb);\n\t\t\t\t\tahd_qinfifo_requeue_tail(ahd, scb);\n\t\t\t\t}\n\t\t\t\tprinterror = 0;\n\t\t\t}\n\t\t} else if (ahd_sent_msg(ahd, AHDMSG_EXT, EXTENDED_WDTR, FALSE)\n\t\t\t&& ppr_busfree == 0) {\n\t\t\t \n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\n\t\t\t\tprintk(\"WDTR negotiation rejected busfree.\\n\");\n#endif\n\t\t\tahd_set_width(ahd, &devinfo,\n\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHD_TRANS_CUR|AHD_TRANS_GOAL,\n\t\t\t\t       TRUE);\n\t\t\tif (scb != NULL) {\n\t\t\t\t \n\t\t\t\tahd_freeze_devq(ahd, scb);\n\t\t\t\tahd_qinfifo_requeue_tail(ahd, scb);\n\t\t\t}\n\t\t\tprinterror = 0;\n\t\t} else if (ahd_sent_msg(ahd, AHDMSG_EXT, EXTENDED_SDTR, FALSE)\n\t\t\t&& ppr_busfree == 0) {\n\t\t\t \n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\n\t\t\t\tprintk(\"SDTR negotiation rejected busfree.\\n\");\n#endif\n\t\t\tahd_set_syncrate(ahd, &devinfo,\n\t\t\t\t\t 0,  0,\n\t\t\t\t\t 0,\n\t\t\t\t\tAHD_TRANS_CUR|AHD_TRANS_GOAL,\n\t\t\t\t\t TRUE);\n\t\t\tif (scb != NULL) {\n\t\t\t\t \n\t\t\t\tahd_freeze_devq(ahd, scb);\n\t\t\t\tahd_qinfifo_requeue_tail(ahd, scb);\n\t\t\t}\n\t\t\tprinterror = 0;\n\t\t} else if ((ahd->msg_flags & MSG_FLAG_EXPECT_IDE_BUSFREE) != 0\n\t\t\t&& ahd_sent_msg(ahd, AHDMSG_1B,\n\t\t\t\t\t INITIATOR_ERROR, TRUE)) {\n\n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\n\t\t\t\tprintk(\"Expected IDE Busfree\\n\");\n#endif\n\t\t\tprinterror = 0;\n\t\t} else if ((ahd->msg_flags & MSG_FLAG_EXPECT_QASREJ_BUSFREE)\n\t\t\t&& ahd_sent_msg(ahd, AHDMSG_1B,\n\t\t\t\t\tMESSAGE_REJECT, TRUE)) {\n\n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\n\t\t\t\tprintk(\"Expected QAS Reject Busfree\\n\");\n#endif\n\t\t\tprinterror = 0;\n\t\t}\n\t}\n\n\t \n\tif (scb != NULL && printerror != 0\n\t && (lastphase == P_MESGIN || lastphase == P_MESGOUT)\n\t && ((ahd->msg_flags & MSG_FLAG_EXPECT_PPR_BUSFREE) != 0)) {\n\n\t\tahd_freeze_devq(ahd, scb);\n\t\tahd_set_transaction_status(scb, CAM_REQUEUE_REQ);\n\t\tahd_freeze_scb(scb);\n\t\tif ((ahd->msg_flags & MSG_FLAG_IU_REQ_CHANGED) != 0) {\n\t\t\tahd_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),\n\t\t\t\t       SCB_GET_CHANNEL(ahd, scb),\n\t\t\t\t       SCB_GET_LUN(scb), SCB_LIST_NULL,\n\t\t\t\t       ROLE_INITIATOR, CAM_REQ_ABORTED);\n\t\t} else {\n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\n\t\t\t\tprintk(\"PPR Negotiation Busfree.\\n\");\n#endif\n\t\t\tahd_done(ahd, scb);\n\t\t}\n\t\tprinterror = 0;\n\t}\n\tif (printerror != 0) {\n\t\tint aborted;\n\n\t\taborted = 0;\n\t\tif (scb != NULL) {\n\t\t\tu_int tag;\n\n\t\t\tif ((scb->hscb->control & TAG_ENB) != 0)\n\t\t\t\ttag = SCB_GET_TAG(scb);\n\t\t\telse\n\t\t\t\ttag = SCB_LIST_NULL;\n\t\t\tahd_print_path(ahd, scb);\n\t\t\taborted = ahd_abort_scbs(ahd, target, 'A',\n\t\t\t\t       SCB_GET_LUN(scb), tag,\n\t\t\t\t       ROLE_INITIATOR,\n\t\t\t\t       CAM_UNEXP_BUSFREE);\n\t\t} else {\n\t\t\t \n\t\t\tprintk(\"%s: \", ahd_name(ahd));\n\t\t}\n\t\tprintk(\"Unexpected busfree %s, %d SCBs aborted, \"\n\t\t       \"PRGMCNT == 0x%x\\n\",\n\t\t       ahd_lookup_phase_entry(lastphase)->phasemsg,\n\t\t       aborted,\n\t\t       ahd_inw(ahd, PRGMCNT));\n\t\tahd_dump_card_state(ahd);\n\t\tif (lastphase != P_BUSFREE)\n\t\t\tahd_force_renegotiation(ahd, &devinfo);\n\t}\n\t \n\treturn (1);\n}\n\nstatic void\nahd_handle_proto_violation(struct ahd_softc *ahd)\n{\n\tstruct\tahd_devinfo devinfo;\n\tstruct\tscb *scb;\n\tu_int\tscbid;\n\tu_int\tseq_flags;\n\tu_int\tcurphase;\n\tu_int\tlastphase;\n\tint\tfound;\n\n\tahd_fetch_devinfo(ahd, &devinfo);\n\tscbid = ahd_get_scbptr(ahd);\n\tscb = ahd_lookup_scb(ahd, scbid);\n\tseq_flags = ahd_inb(ahd, SEQ_FLAGS);\n\tcurphase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;\n\tlastphase = ahd_inb(ahd, LASTPHASE);\n\tif ((seq_flags & NOT_IDENTIFIED) != 0) {\n\n\t\t \n\t\tahd_print_devinfo(ahd, &devinfo);\n\t\tprintk(\"Target did not send an IDENTIFY message. \"\n\t\t       \"LASTPHASE = 0x%x.\\n\", lastphase);\n\t\tscb = NULL;\n\t} else if (scb == NULL) {\n\t\t \n\t\tahd_print_devinfo(ahd, &devinfo);\n\t\tprintk(\"No SCB found during protocol violation\\n\");\n\t\tgoto proto_violation_reset;\n\t} else {\n\t\tahd_set_transaction_status(scb, CAM_SEQUENCE_FAIL);\n\t\tif ((seq_flags & NO_CDB_SENT) != 0) {\n\t\t\tahd_print_path(ahd, scb);\n\t\t\tprintk(\"No or incomplete CDB sent to device.\\n\");\n\t\t} else if ((ahd_inb_scbram(ahd, SCB_CONTROL)\n\t\t\t  & STATUS_RCVD) == 0) {\n\t\t\t \n\t\t\tahd_print_path(ahd, scb);\n\t\t\tprintk(\"Completed command without status.\\n\");\n\t\t} else {\n\t\t\tahd_print_path(ahd, scb);\n\t\t\tprintk(\"Unknown protocol violation.\\n\");\n\t\t\tahd_dump_card_state(ahd);\n\t\t}\n\t}\n\tif ((lastphase & ~P_DATAIN_DT) == 0\n\t || lastphase == P_COMMAND) {\nproto_violation_reset:\n\t\t \n\t\tfound = ahd_reset_channel(ahd, 'A', TRUE);\n\t\tprintk(\"%s: Issued Channel %c Bus Reset. \"\n\t\t       \"%d SCBs aborted\\n\", ahd_name(ahd), 'A', found);\n\t} else {\n\t\t \n\t\tahd_outb(ahd, SCSISEQ0,\n\t\t\t ahd_inb(ahd, SCSISEQ0) & ~ENSELO);\n\t\tahd_assert_atn(ahd);\n\t\tahd_outb(ahd, MSG_OUT, HOST_MSG);\n\t\tif (scb == NULL) {\n\t\t\tahd_print_devinfo(ahd, &devinfo);\n\t\t\tahd->msgout_buf[0] = ABORT_TASK;\n\t\t\tahd->msgout_len = 1;\n\t\t\tahd->msgout_index = 0;\n\t\t\tahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\t} else {\n\t\t\tahd_print_path(ahd, scb);\n\t\t\tscb->flags |= SCB_ABORT;\n\t\t}\n\t\tprintk(\"Protocol violation %s.  Attempting to abort.\\n\",\n\t\t       ahd_lookup_phase_entry(curphase)->phasemsg);\n\t}\n}\n\n \nstatic void\nahd_force_renegotiation(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\n{\n\tstruct\tahd_initiator_tinfo *targ_info;\n\tstruct\tahd_tmode_tstate *tstate;\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {\n\t\tahd_print_devinfo(ahd, devinfo);\n\t\tprintk(\"Forcing renegotiation\\n\");\n\t}\n#endif\n\ttarg_info = ahd_fetch_transinfo(ahd,\n\t\t\t\t\tdevinfo->channel,\n\t\t\t\t\tdevinfo->our_scsiid,\n\t\t\t\t\tdevinfo->target,\n\t\t\t\t\t&tstate);\n\tahd_update_neg_request(ahd, devinfo, tstate,\n\t\t\t       targ_info, AHD_NEG_IF_NON_ASYNC);\n}\n\n#define AHD_MAX_STEPS 2000\nstatic void\nahd_clear_critical_section(struct ahd_softc *ahd)\n{\n\tahd_mode_state\tsaved_modes;\n\tint\t\tstepping;\n\tint\t\tsteps;\n\tint\t\tfirst_instr;\n\tu_int\t\tsimode0;\n\tu_int\t\tsimode1;\n\tu_int\t\tsimode3;\n\tu_int\t\tlqimode0;\n\tu_int\t\tlqimode1;\n\tu_int\t\tlqomode0;\n\tu_int\t\tlqomode1;\n\n\tif (ahd->num_critical_sections == 0)\n\t\treturn;\n\n\tstepping = FALSE;\n\tsteps = 0;\n\tfirst_instr = 0;\n\tsimode0 = 0;\n\tsimode1 = 0;\n\tsimode3 = 0;\n\tlqimode0 = 0;\n\tlqimode1 = 0;\n\tlqomode0 = 0;\n\tlqomode1 = 0;\n\tsaved_modes = ahd_save_modes(ahd);\n\tfor (;;) {\n\t\tstruct\tcs *cs;\n\t\tu_int\tseqaddr;\n\t\tu_int\ti;\n\n\t\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\t\tseqaddr = ahd_inw(ahd, CURADDR);\n\n\t\tcs = ahd->critical_sections;\n\t\tfor (i = 0; i < ahd->num_critical_sections; i++, cs++) {\n\t\t\tif (cs->begin < seqaddr && cs->end >= seqaddr)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == ahd->num_critical_sections)\n\t\t\tbreak;\n\n\t\tif (steps > AHD_MAX_STEPS) {\n\t\t\tprintk(\"%s: Infinite loop in critical section\\n\"\n\t\t\t       \"%s: First Instruction 0x%x now 0x%x\\n\",\n\t\t\t       ahd_name(ahd), ahd_name(ahd), first_instr,\n\t\t\t       seqaddr);\n\t\t\tahd_dump_card_state(ahd);\n\t\t\tpanic(\"critical section loop\");\n\t\t}\n\n\t\tsteps++;\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_MISC) != 0)\n\t\t\tprintk(\"%s: Single stepping at 0x%x\\n\", ahd_name(ahd),\n\t\t\t       seqaddr);\n#endif\n\t\tif (stepping == FALSE) {\n\n\t\t\tfirst_instr = seqaddr;\n\t\t\tahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\n\t\t\tsimode0 = ahd_inb(ahd, SIMODE0);\n\t\t\tsimode3 = ahd_inb(ahd, SIMODE3);\n\t\t\tlqimode0 = ahd_inb(ahd, LQIMODE0);\n\t\t\tlqimode1 = ahd_inb(ahd, LQIMODE1);\n\t\t\tlqomode0 = ahd_inb(ahd, LQOMODE0);\n\t\t\tlqomode1 = ahd_inb(ahd, LQOMODE1);\n\t\t\tahd_outb(ahd, SIMODE0, 0);\n\t\t\tahd_outb(ahd, SIMODE3, 0);\n\t\t\tahd_outb(ahd, LQIMODE0, 0);\n\t\t\tahd_outb(ahd, LQIMODE1, 0);\n\t\t\tahd_outb(ahd, LQOMODE0, 0);\n\t\t\tahd_outb(ahd, LQOMODE1, 0);\n\t\t\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\t\t\tsimode1 = ahd_inb(ahd, SIMODE1);\n\t\t\t \n\t\t\tahd_outb(ahd, SIMODE1, simode1 & ENBUSFREE);\n\t\t\tahd_outb(ahd, SEQCTL0, ahd_inb(ahd, SEQCTL0) | STEP);\n\t\t\tstepping = TRUE;\n\t\t}\n\t\tahd_outb(ahd, CLRSINT1, CLRBUSFREE);\n\t\tahd_outb(ahd, CLRINT, CLRSCSIINT);\n\t\tahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);\n\t\tahd_outb(ahd, HCNTRL, ahd->unpause);\n\t\twhile (!ahd_is_paused(ahd))\n\t\t\tahd_delay(200);\n\t\tahd_update_modes(ahd);\n\t}\n\tif (stepping) {\n\t\tahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\n\t\tahd_outb(ahd, SIMODE0, simode0);\n\t\tahd_outb(ahd, SIMODE3, simode3);\n\t\tahd_outb(ahd, LQIMODE0, lqimode0);\n\t\tahd_outb(ahd, LQIMODE1, lqimode1);\n\t\tahd_outb(ahd, LQOMODE0, lqomode0);\n\t\tahd_outb(ahd, LQOMODE1, lqomode1);\n\t\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\t\tahd_outb(ahd, SEQCTL0, ahd_inb(ahd, SEQCTL0) & ~STEP);\n\t\tahd_outb(ahd, SIMODE1, simode1);\n\t\t \n\t\tahd_outb(ahd, CLRINT, CLRSCSIINT);\n\t}\n\tahd_restore_modes(ahd, saved_modes);\n}\n\n \nstatic void\nahd_clear_intstat(struct ahd_softc *ahd)\n{\n\tAHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),\n\t\t\t ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));\n\t \n\tahd_outb(ahd, CLRLQIINT0, CLRLQIATNQAS|CLRLQICRCT1|CLRLQICRCT2\n\t\t\t\t |CLRLQIBADLQT|CLRLQIATNLQ|CLRLQIATNCMD);\n\tahd_outb(ahd, CLRLQIINT1, CLRLQIPHASE_LQ|CLRLQIPHASE_NLQ|CLRLIQABORT\n\t\t\t\t |CLRLQICRCI_LQ|CLRLQICRCI_NLQ|CLRLQIBADLQI\n\t\t\t\t |CLRLQIOVERI_LQ|CLRLQIOVERI_NLQ|CLRNONPACKREQ);\n\tahd_outb(ahd, CLRLQOINT0, CLRLQOTARGSCBPERR|CLRLQOSTOPT2|CLRLQOATNLQ\n\t\t\t\t |CLRLQOATNPKT|CLRLQOTCRC);\n\tahd_outb(ahd, CLRLQOINT1, CLRLQOINITSCBPERR|CLRLQOSTOPI2|CLRLQOBADQAS\n\t\t\t\t |CLRLQOBUSFREE|CLRLQOPHACHGINPKT);\n\tif ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0) {\n\t\tahd_outb(ahd, CLRLQOINT0, 0);\n\t\tahd_outb(ahd, CLRLQOINT1, 0);\n\t}\n\tahd_outb(ahd, CLRSINT3, CLRNTRAMPERR|CLROSRAMPERR);\n\tahd_outb(ahd, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI\n\t\t\t\t|CLRBUSFREE|CLRSCSIPERR|CLRREQINIT);\n\tahd_outb(ahd, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO\n\t\t\t\t|CLRIOERR|CLROVERRUN);\n\tahd_outb(ahd, CLRINT, CLRSCSIINT);\n}\n\n \n#ifdef AHD_DEBUG\nuint32_t ahd_debug = AHD_DEBUG_OPTS;\n#endif\n\n#if 0\nvoid\nahd_print_scb(struct scb *scb)\n{\n\tstruct hardware_scb *hscb;\n\tint i;\n\n\thscb = scb->hscb;\n\tprintk(\"scb:%p control:0x%x scsiid:0x%x lun:%d cdb_len:%d\\n\",\n\t       (void *)scb,\n\t       hscb->control,\n\t       hscb->scsiid,\n\t       hscb->lun,\n\t       hscb->cdb_len);\n\tprintk(\"Shared Data: \");\n\tfor (i = 0; i < sizeof(hscb->shared_data.idata.cdb); i++)\n\t\tprintk(\"%#02x\", hscb->shared_data.idata.cdb[i]);\n\tprintk(\"        dataptr:%#x%x datacnt:%#x sgptr:%#x tag:%#x\\n\",\n\t       (uint32_t)((ahd_le64toh(hscb->dataptr) >> 32) & 0xFFFFFFFF),\n\t       (uint32_t)(ahd_le64toh(hscb->dataptr) & 0xFFFFFFFF),\n\t       ahd_le32toh(hscb->datacnt),\n\t       ahd_le32toh(hscb->sgptr),\n\t       SCB_GET_TAG(scb));\n\tahd_dump_sglist(scb);\n}\n#endif   \n\n \n \nstatic struct ahd_tmode_tstate *\nahd_alloc_tstate(struct ahd_softc *ahd, u_int scsi_id, char channel)\n{\n\tstruct ahd_tmode_tstate *master_tstate;\n\tstruct ahd_tmode_tstate *tstate;\n\tint i;\n\n\tmaster_tstate = ahd->enabled_targets[ahd->our_id];\n\tif (ahd->enabled_targets[scsi_id] != NULL\n\t && ahd->enabled_targets[scsi_id] != master_tstate)\n\t\tpanic(\"%s: ahd_alloc_tstate - Target already allocated\",\n\t\t      ahd_name(ahd));\n\ttstate = kmalloc(sizeof(*tstate), GFP_ATOMIC);\n\tif (tstate == NULL)\n\t\treturn (NULL);\n\n\t \n\tif (master_tstate != NULL) {\n\t\tmemcpy(tstate, master_tstate, sizeof(*tstate));\n\t\tmemset(tstate->enabled_luns, 0, sizeof(tstate->enabled_luns));\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tmemset(&tstate->transinfo[i].curr, 0,\n\t\t\t      sizeof(tstate->transinfo[i].curr));\n\t\t\tmemset(&tstate->transinfo[i].goal, 0,\n\t\t\t      sizeof(tstate->transinfo[i].goal));\n\t\t}\n\t} else\n\t\tmemset(tstate, 0, sizeof(*tstate));\n\tahd->enabled_targets[scsi_id] = tstate;\n\treturn (tstate);\n}\n\n#ifdef AHD_TARGET_MODE\n \nstatic void\nahd_free_tstate(struct ahd_softc *ahd, u_int scsi_id, char channel, int force)\n{\n\tstruct ahd_tmode_tstate *tstate;\n\n\t \n\tif (scsi_id == ahd->our_id\n\t && force == FALSE)\n\t\treturn;\n\n\ttstate = ahd->enabled_targets[scsi_id];\n\tkfree(tstate);\n\tahd->enabled_targets[scsi_id] = NULL;\n}\n#endif\n\n \nstatic void\nahd_devlimited_syncrate(struct ahd_softc *ahd,\n\t\t\tstruct ahd_initiator_tinfo *tinfo,\n\t\t\tu_int *period, u_int *ppr_options, role_t role)\n{\n\tstruct\tahd_transinfo *transinfo;\n\tu_int\tmaxsync;\n\n\tif ((ahd_inb(ahd, SBLKCTL) & ENAB40) != 0\n\t && (ahd_inb(ahd, SSTAT2) & EXP_ACTIVE) == 0) {\n\t\tmaxsync = AHD_SYNCRATE_PACED;\n\t} else {\n\t\tmaxsync = AHD_SYNCRATE_ULTRA;\n\t\t \n\t\t*ppr_options &= MSG_EXT_PPR_QAS_REQ;\n\t}\n\t \n\tif (role == ROLE_TARGET)\n\t\ttransinfo = &tinfo->user;\n\telse\n\t\ttransinfo = &tinfo->goal;\n\t*ppr_options &= (transinfo->ppr_options|MSG_EXT_PPR_PCOMP_EN);\n\tif (transinfo->width == MSG_EXT_WDTR_BUS_8_BIT) {\n\t\tmaxsync = max(maxsync, (u_int)AHD_SYNCRATE_ULTRA2);\n\t\t*ppr_options &= ~MSG_EXT_PPR_DT_REQ;\n\t}\n\tif (transinfo->period == 0) {\n\t\t*period = 0;\n\t\t*ppr_options = 0;\n\t} else {\n\t\t*period = max(*period, (u_int)transinfo->period);\n\t\tahd_find_syncrate(ahd, period, ppr_options, maxsync);\n\t}\n}\n\n \nvoid\nahd_find_syncrate(struct ahd_softc *ahd, u_int *period,\n\t\t  u_int *ppr_options, u_int maxsync)\n{\n\tif (*period < maxsync)\n\t\t*period = maxsync;\n\n\tif ((*ppr_options & MSG_EXT_PPR_DT_REQ) != 0\n\t && *period > AHD_SYNCRATE_MIN_DT)\n\t\t*ppr_options &= ~MSG_EXT_PPR_DT_REQ;\n\n\tif (*period > AHD_SYNCRATE_MIN)\n\t\t*period = 0;\n\n\t \n\tif (*period > AHD_SYNCRATE_PACED)\n\t\t*ppr_options &= ~MSG_EXT_PPR_RTI;\n\n\tif ((*ppr_options & MSG_EXT_PPR_IU_REQ) == 0)\n\t\t*ppr_options &= (MSG_EXT_PPR_DT_REQ|MSG_EXT_PPR_QAS_REQ);\n\n\tif ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0)\n\t\t*ppr_options &= MSG_EXT_PPR_QAS_REQ;\n\n\t \n\tif ((*ppr_options & MSG_EXT_PPR_IU_REQ) == 0\n\t && *period < AHD_SYNCRATE_DT)\n\t\t*period = AHD_SYNCRATE_DT;\n\n\t \n\tif ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0\n\t && *period < AHD_SYNCRATE_ULTRA2)\n\t\t*period = AHD_SYNCRATE_ULTRA2;\n}\n\n \nstatic void\nahd_validate_offset(struct ahd_softc *ahd,\n\t\t    struct ahd_initiator_tinfo *tinfo,\n\t\t    u_int period, u_int *offset, int wide,\n\t\t    role_t role)\n{\n\tu_int maxoffset;\n\n\t \n\tif (period == 0)\n\t\tmaxoffset = 0;\n\telse if (period <= AHD_SYNCRATE_PACED) {\n\t\tif ((ahd->bugs & AHD_PACED_NEGTABLE_BUG) != 0)\n\t\t\tmaxoffset = MAX_OFFSET_PACED_BUG;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_PACED;\n\t} else\n\t\tmaxoffset = MAX_OFFSET_NON_PACED;\n\t*offset = min(*offset, maxoffset);\n\tif (tinfo != NULL) {\n\t\tif (role == ROLE_TARGET)\n\t\t\t*offset = min(*offset, (u_int)tinfo->user.offset);\n\t\telse\n\t\t\t*offset = min(*offset, (u_int)tinfo->goal.offset);\n\t}\n}\n\n \nstatic void\nahd_validate_width(struct ahd_softc *ahd, struct ahd_initiator_tinfo *tinfo,\n\t\t   u_int *bus_width, role_t role)\n{\n\tswitch (*bus_width) {\n\tdefault:\n\t\tif (ahd->features & AHD_WIDE) {\n\t\t\t \n\t\t\t*bus_width = MSG_EXT_WDTR_BUS_16_BIT;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase MSG_EXT_WDTR_BUS_8_BIT:\n\t\t*bus_width = MSG_EXT_WDTR_BUS_8_BIT;\n\t\tbreak;\n\t}\n\tif (tinfo != NULL) {\n\t\tif (role == ROLE_TARGET)\n\t\t\t*bus_width = min((u_int)tinfo->user.width, *bus_width);\n\t\telse\n\t\t\t*bus_width = min((u_int)tinfo->goal.width, *bus_width);\n\t}\n}\n\n \nint\nahd_update_neg_request(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\n\t\t       struct ahd_tmode_tstate *tstate,\n\t\t       struct ahd_initiator_tinfo *tinfo, ahd_neg_type neg_type)\n{\n\tu_int auto_negotiate_orig;\n\n\tauto_negotiate_orig = tstate->auto_negotiate;\n\tif (neg_type == AHD_NEG_ALWAYS) {\n\t\t \n\t\tif ((ahd->features & AHD_WIDE) != 0)\n\t\t\ttinfo->curr.width = AHD_WIDTH_UNKNOWN;\n\t\ttinfo->curr.period = AHD_PERIOD_UNKNOWN;\n\t\ttinfo->curr.offset = AHD_OFFSET_UNKNOWN;\n\t}\n\tif (tinfo->curr.period != tinfo->goal.period\n\t || tinfo->curr.width != tinfo->goal.width\n\t || tinfo->curr.offset != tinfo->goal.offset\n\t || tinfo->curr.ppr_options != tinfo->goal.ppr_options\n\t || (neg_type == AHD_NEG_IF_NON_ASYNC\n\t  && (tinfo->goal.offset != 0\n\t   || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT\n\t   || tinfo->goal.ppr_options != 0)))\n\t\ttstate->auto_negotiate |= devinfo->target_mask;\n\telse\n\t\ttstate->auto_negotiate &= ~devinfo->target_mask;\n\n\treturn (auto_negotiate_orig != tstate->auto_negotiate);\n}\n\n \nvoid\nahd_set_syncrate(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\n\t\t u_int period, u_int offset, u_int ppr_options,\n\t\t u_int type, int paused)\n{\n\tstruct\tahd_initiator_tinfo *tinfo;\n\tstruct\tahd_tmode_tstate *tstate;\n\tu_int\told_period;\n\tu_int\told_offset;\n\tu_int\told_ppr;\n\tint\tactive;\n\tint\tupdate_needed;\n\n\tactive = (type & AHD_TRANS_ACTIVE) == AHD_TRANS_ACTIVE;\n\tupdate_needed = 0;\n\n\tif (period == 0 || offset == 0) {\n\t\tperiod = 0;\n\t\toffset = 0;\n\t}\n\n\ttinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\n\tif ((type & AHD_TRANS_USER) != 0) {\n\t\ttinfo->user.period = period;\n\t\ttinfo->user.offset = offset;\n\t\ttinfo->user.ppr_options = ppr_options;\n\t}\n\n\tif ((type & AHD_TRANS_GOAL) != 0) {\n\t\ttinfo->goal.period = period;\n\t\ttinfo->goal.offset = offset;\n\t\ttinfo->goal.ppr_options = ppr_options;\n\t}\n\n\told_period = tinfo->curr.period;\n\told_offset = tinfo->curr.offset;\n\told_ppr\t   = tinfo->curr.ppr_options;\n\n\tif ((type & AHD_TRANS_CUR) != 0\n\t && (old_period != period\n\t  || old_offset != offset\n\t  || old_ppr != ppr_options)) {\n\n\t\tupdate_needed++;\n\n\t\ttinfo->curr.period = period;\n\t\ttinfo->curr.offset = offset;\n\t\ttinfo->curr.ppr_options = ppr_options;\n\n\t\tahd_send_async(ahd, devinfo->channel, devinfo->target,\n\t\t\t       CAM_LUN_WILDCARD, AC_TRANSFER_NEG);\n\t\tif (bootverbose) {\n\t\t\tif (offset != 0) {\n\t\t\t\tint options;\n\n\t\t\t\tprintk(\"%s: target %d synchronous with \"\n\t\t\t\t       \"period = 0x%x, offset = 0x%x\",\n\t\t\t\t       ahd_name(ahd), devinfo->target,\n\t\t\t\t       period, offset);\n\t\t\t\toptions = 0;\n\t\t\t\tif ((ppr_options & MSG_EXT_PPR_RD_STRM) != 0) {\n\t\t\t\t\tprintk(\"(RDSTRM\");\n\t\t\t\t\toptions++;\n\t\t\t\t}\n\t\t\t\tif ((ppr_options & MSG_EXT_PPR_DT_REQ) != 0) {\n\t\t\t\t\tprintk(\"%s\", options ? \"|DT\" : \"(DT\");\n\t\t\t\t\toptions++;\n\t\t\t\t}\n\t\t\t\tif ((ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {\n\t\t\t\t\tprintk(\"%s\", options ? \"|IU\" : \"(IU\");\n\t\t\t\t\toptions++;\n\t\t\t\t}\n\t\t\t\tif ((ppr_options & MSG_EXT_PPR_RTI) != 0) {\n\t\t\t\t\tprintk(\"%s\", options ? \"|RTI\" : \"(RTI\");\n\t\t\t\t\toptions++;\n\t\t\t\t}\n\t\t\t\tif ((ppr_options & MSG_EXT_PPR_QAS_REQ) != 0) {\n\t\t\t\t\tprintk(\"%s\", options ? \"|QAS\" : \"(QAS\");\n\t\t\t\t\toptions++;\n\t\t\t\t}\n\t\t\t\tif (options != 0)\n\t\t\t\t\tprintk(\")\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintk(\"\\n\");\n\t\t\t} else {\n\t\t\t\tprintk(\"%s: target %d using \"\n\t\t\t\t       \"asynchronous transfers%s\\n\",\n\t\t\t\t       ahd_name(ahd), devinfo->target,\n\t\t\t\t       (ppr_options & MSG_EXT_PPR_QAS_REQ) != 0\n\t\t\t\t     ?  \"(QAS)\" : \"\");\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif ((type & AHD_TRANS_CUR) != 0) {\n\t\tif (!paused)\n\t\t\tahd_pause(ahd);\n\t\tahd_update_neg_table(ahd, devinfo, &tinfo->curr);\n\t\tif (!paused)\n\t\t\tahd_unpause(ahd);\n\t\tif (ahd->msg_type != MSG_TYPE_NONE) {\n\t\t\tif ((old_ppr & MSG_EXT_PPR_IU_REQ)\n\t\t\t != (ppr_options & MSG_EXT_PPR_IU_REQ)) {\n#ifdef AHD_DEBUG\n\t\t\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {\n\t\t\t\t\tahd_print_devinfo(ahd, devinfo);\n\t\t\t\t\tprintk(\"Expecting IU Change busfree\\n\");\n\t\t\t\t}\n#endif\n\t\t\t\tahd->msg_flags |= MSG_FLAG_EXPECT_PPR_BUSFREE\n\t\t\t\t\t       |  MSG_FLAG_IU_REQ_CHANGED;\n\t\t\t}\n\t\t\tif ((old_ppr & MSG_EXT_PPR_IU_REQ) != 0) {\n#ifdef AHD_DEBUG\n\t\t\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\n\t\t\t\t\tprintk(\"PPR with IU_REQ outstanding\\n\");\n#endif\n\t\t\t\tahd->msg_flags |= MSG_FLAG_EXPECT_PPR_BUSFREE;\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate_needed += ahd_update_neg_request(ahd, devinfo, tstate,\n\t\t\t\t\t\ttinfo, AHD_NEG_TO_GOAL);\n\n\tif (update_needed && active)\n\t\tahd_update_pending_scbs(ahd);\n}\n\n \nvoid\nahd_set_width(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\n\t      u_int width, u_int type, int paused)\n{\n\tstruct\tahd_initiator_tinfo *tinfo;\n\tstruct\tahd_tmode_tstate *tstate;\n\tu_int\toldwidth;\n\tint\tactive;\n\tint\tupdate_needed;\n\n\tactive = (type & AHD_TRANS_ACTIVE) == AHD_TRANS_ACTIVE;\n\tupdate_needed = 0;\n\ttinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\n\tif ((type & AHD_TRANS_USER) != 0)\n\t\ttinfo->user.width = width;\n\n\tif ((type & AHD_TRANS_GOAL) != 0)\n\t\ttinfo->goal.width = width;\n\n\toldwidth = tinfo->curr.width;\n\tif ((type & AHD_TRANS_CUR) != 0 && oldwidth != width) {\n\n\t\tupdate_needed++;\n\n\t\ttinfo->curr.width = width;\n\t\tahd_send_async(ahd, devinfo->channel, devinfo->target,\n\t\t\t       CAM_LUN_WILDCARD, AC_TRANSFER_NEG);\n\t\tif (bootverbose) {\n\t\t\tprintk(\"%s: target %d using %dbit transfers\\n\",\n\t\t\t       ahd_name(ahd), devinfo->target,\n\t\t\t       8 * (0x01 << width));\n\t\t}\n\t}\n\n\tif ((type & AHD_TRANS_CUR) != 0) {\n\t\tif (!paused)\n\t\t\tahd_pause(ahd);\n\t\tahd_update_neg_table(ahd, devinfo, &tinfo->curr);\n\t\tif (!paused)\n\t\t\tahd_unpause(ahd);\n\t}\n\n\tupdate_needed += ahd_update_neg_request(ahd, devinfo, tstate,\n\t\t\t\t\t\ttinfo, AHD_NEG_TO_GOAL);\n\tif (update_needed && active)\n\t\tahd_update_pending_scbs(ahd);\n\n}\n\n \nstatic void\nahd_set_tags(struct ahd_softc *ahd, struct scsi_cmnd *cmd,\n\t     struct ahd_devinfo *devinfo, ahd_queue_alg alg)\n{\n\tstruct scsi_device *sdev = cmd->device;\n\n\tahd_platform_set_tags(ahd, sdev, devinfo, alg);\n\tahd_send_async(ahd, devinfo->channel, devinfo->target,\n\t\t       devinfo->lun, AC_TRANSFER_NEG);\n}\n\nstatic void\nahd_update_neg_table(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\n\t\t     struct ahd_transinfo *tinfo)\n{\n\tahd_mode_state\tsaved_modes;\n\tu_int\t\tperiod;\n\tu_int\t\tppr_opts;\n\tu_int\t\tcon_opts;\n\tu_int\t\toffset;\n\tu_int\t\tsaved_negoaddr;\n\tuint8_t\t\tiocell_opts[sizeof(ahd->iocell_opts)];\n\n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\n\tsaved_negoaddr = ahd_inb(ahd, NEGOADDR);\n\tahd_outb(ahd, NEGOADDR, devinfo->target);\n\tperiod = tinfo->period;\n\toffset = tinfo->offset;\n\tmemcpy(iocell_opts, ahd->iocell_opts, sizeof(ahd->iocell_opts));\n\tppr_opts = tinfo->ppr_options & (MSG_EXT_PPR_QAS_REQ|MSG_EXT_PPR_DT_REQ\n\t\t\t\t\t|MSG_EXT_PPR_IU_REQ|MSG_EXT_PPR_RTI);\n\tcon_opts = 0;\n\tif (period == 0)\n\t\tperiod = AHD_SYNCRATE_ASYNC;\n\tif (period == AHD_SYNCRATE_160) {\n\n\t\tif ((ahd->bugs & AHD_PACED_NEGTABLE_BUG) != 0) {\n\t\t\t \n\t\t\tppr_opts |= PPROPT_PACE;\n\t\t\toffset *= 2;\n\n\t\t\t \n\t\t\tperiod = AHD_SYNCRATE_REVA_160;\n\t\t}\n\t\tif ((tinfo->ppr_options & MSG_EXT_PPR_PCOMP_EN) == 0)\n\t\t\tiocell_opts[AHD_PRECOMP_SLEW_INDEX] &=\n\t\t\t    ~AHD_PRECOMP_MASK;\n\t} else {\n\t\t \n\t\tiocell_opts[AHD_PRECOMP_SLEW_INDEX] &= ~AHD_PRECOMP_MASK;\n\n\t\tif ((ahd->features & AHD_NEW_IOCELL_OPTS) != 0\n\t\t && (ppr_opts & MSG_EXT_PPR_DT_REQ) != 0\n\t\t && (ppr_opts & MSG_EXT_PPR_IU_REQ) == 0) {\n\t\t\t \n\t\t\tcon_opts |= ENSLOWCRC;\n\t\t}\n\n\t\tif ((ahd->bugs & AHD_PACED_NEGTABLE_BUG) != 0) {\n\t\t\t \n\t\t\tiocell_opts[AHD_PRECOMP_SLEW_INDEX] &=\n\t\t\t    ~AHD_SLEWRATE_MASK;\n\t\t}\n\t}\n\n\tahd_outb(ahd, ANNEXCOL, AHD_ANNEXCOL_PRECOMP_SLEW);\n\tahd_outb(ahd, ANNEXDAT, iocell_opts[AHD_PRECOMP_SLEW_INDEX]);\n\tahd_outb(ahd, ANNEXCOL, AHD_ANNEXCOL_AMPLITUDE);\n\tahd_outb(ahd, ANNEXDAT, iocell_opts[AHD_AMPLITUDE_INDEX]);\n\n\tahd_outb(ahd, NEGPERIOD, period);\n\tahd_outb(ahd, NEGPPROPTS, ppr_opts);\n\tahd_outb(ahd, NEGOFFSET, offset);\n\n\tif (tinfo->width == MSG_EXT_WDTR_BUS_16_BIT)\n\t\tcon_opts |= WIDEXFER;\n\n\t \n\tif (ahd->features & AHD_AIC79XXB_SLOWCRC) {\n\t\tcon_opts |= ENSLOWCRC;\n\t}\n\n\t \n\tif ((tinfo->ppr_options & MSG_EXT_PPR_IU_REQ) == 0)\n\t\tcon_opts |= ENAUTOATNO;\n\tahd_outb(ahd, NEGCONOPTS, con_opts);\n\tahd_outb(ahd, NEGOADDR, saved_negoaddr);\n\tahd_restore_modes(ahd, saved_modes);\n}\n\n \nstatic void\nahd_update_pending_scbs(struct ahd_softc *ahd)\n{\n\tstruct\t\tscb *pending_scb;\n\tint\t\tpending_scb_count;\n\tint\t\tpaused;\n\tu_int\t\tsaved_scbptr;\n\tahd_mode_state\tsaved_modes;\n\n\t \n\tpending_scb_count = 0;\n\tLIST_FOREACH(pending_scb, &ahd->pending_scbs, pending_links) {\n\t\tstruct ahd_devinfo devinfo;\n\t\tstruct ahd_tmode_tstate *tstate;\n\n\t\tahd_scb_devinfo(ahd, &devinfo, pending_scb);\n\t\tahd_fetch_transinfo(ahd, devinfo.channel, devinfo.our_scsiid,\n\t\t\t\t    devinfo.target, &tstate);\n\t\tif ((tstate->auto_negotiate & devinfo.target_mask) == 0\n\t\t && (pending_scb->flags & SCB_AUTO_NEGOTIATE) != 0) {\n\t\t\tpending_scb->flags &= ~SCB_AUTO_NEGOTIATE;\n\t\t\tpending_scb->hscb->control &= ~MK_MESSAGE;\n\t\t}\n\t\tahd_sync_scb(ahd, pending_scb,\n\t\t\t     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\n\t\tpending_scb_count++;\n\t}\n\n\tif (pending_scb_count == 0)\n\t\treturn;\n\n\tif (ahd_is_paused(ahd)) {\n\t\tpaused = 1;\n\t} else {\n\t\tpaused = 0;\n\t\tahd_pause(ahd);\n\t}\n\n\t \n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\tif ((ahd_inb(ahd, SCSISIGI) & BSYI) != 0\n\t && (ahd_inb(ahd, SSTAT0) & (SELDO|SELINGO)) == 0)\n\t\tahd_outb(ahd, SCSISEQ0, ahd_inb(ahd, SCSISEQ0) & ~ENSELO);\n\tsaved_scbptr = ahd_get_scbptr(ahd);\n\t \n\tLIST_FOREACH(pending_scb, &ahd->pending_scbs, pending_links) {\n\t\tu_int\tscb_tag;\n\t\tu_int\tcontrol;\n\n\t\tscb_tag = SCB_GET_TAG(pending_scb);\n\t\tahd_set_scbptr(ahd, scb_tag);\n\t\tcontrol = ahd_inb_scbram(ahd, SCB_CONTROL);\n\t\tcontrol &= ~MK_MESSAGE;\n\t\tcontrol |= pending_scb->hscb->control & MK_MESSAGE;\n\t\tahd_outb(ahd, SCB_CONTROL, control);\n\t}\n\tahd_set_scbptr(ahd, saved_scbptr);\n\tahd_restore_modes(ahd, saved_modes);\n\n\tif (paused == 0)\n\t\tahd_unpause(ahd);\n}\n\n \nstatic void\nahd_fetch_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\n{\n\tahd_mode_state\tsaved_modes;\n\tu_int\t\tsaved_scsiid;\n\trole_t\t\trole;\n\tint\t\tour_id;\n\n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\n\tif (ahd_inb(ahd, SSTAT0) & TARGET)\n\t\trole = ROLE_TARGET;\n\telse\n\t\trole = ROLE_INITIATOR;\n\n\tif (role == ROLE_TARGET\n\t && (ahd_inb(ahd, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {\n\t\t \n\t\tour_id = ahd_inb(ahd, TARGIDIN) & OID;\n\t} else if (role == ROLE_TARGET)\n\t\tour_id = ahd_inb(ahd, TOWNID);\n\telse\n\t\tour_id = ahd_inb(ahd, IOWNID);\n\n\tsaved_scsiid = ahd_inb(ahd, SAVED_SCSIID);\n\tahd_compile_devinfo(devinfo,\n\t\t\t    our_id,\n\t\t\t    SCSIID_TARGET(ahd, saved_scsiid),\n\t\t\t    ahd_inb(ahd, SAVED_LUN),\n\t\t\t    SCSIID_CHANNEL(ahd, saved_scsiid),\n\t\t\t    role);\n\tahd_restore_modes(ahd, saved_modes);\n}\n\nvoid\nahd_print_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\n{\n\tprintk(\"%s:%c:%d:%d: \", ahd_name(ahd), 'A',\n\t       devinfo->target, devinfo->lun);\n}\n\nstatic const struct ahd_phase_table_entry*\nahd_lookup_phase_entry(int phase)\n{\n\tconst struct ahd_phase_table_entry *entry;\n\tconst struct ahd_phase_table_entry *last_entry;\n\n\t \n\tlast_entry = &ahd_phase_table[num_phases];\n\tfor (entry = ahd_phase_table; entry < last_entry; entry++) {\n\t\tif (phase == entry->phase)\n\t\t\tbreak;\n\t}\n\treturn (entry);\n}\n\nvoid\nahd_compile_devinfo(struct ahd_devinfo *devinfo, u_int our_id, u_int target,\n\t\t    u_int lun, char channel, role_t role)\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}\n\nstatic void\nahd_scb_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\n\t\tstruct scb *scb)\n{\n\trole_t\trole;\n\tint\tour_id;\n\n\tour_id = SCSIID_OUR_ID(scb->hscb->scsiid);\n\trole = ROLE_INITIATOR;\n\tif ((scb->hscb->control & TARGET_SCB) != 0)\n\t\trole = ROLE_TARGET;\n\tahd_compile_devinfo(devinfo, our_id, SCB_GET_TARGET(ahd, scb),\n\t\t\t    SCB_GET_LUN(scb), SCB_GET_CHANNEL(ahd, scb), role);\n}\n\n\n \n \nstatic void\nahd_setup_initiator_msgout(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\n\t\t\t   struct scb *scb)\n{\n\t \n\tahd->msgout_index = 0;\n\tahd->msgout_len = 0;\n\n\tif (ahd_currently_packetized(ahd))\n\t\tahd->msg_flags |= MSG_FLAG_PACKETIZED;\n\n\tif (ahd->send_msg_perror\n\t && ahd_inb(ahd, MSG_OUT) == HOST_MSG) {\n\t\tahd->msgout_buf[ahd->msgout_index++] = ahd->send_msg_perror;\n\t\tahd->msgout_len++;\n\t\tahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\n\t\t\tprintk(\"Setting up for Parity Error delivery\\n\");\n#endif\n\t\treturn;\n\t} else if (scb == NULL) {\n\t\tprintk(\"%s: WARNING. No pending message for \"\n\t\t       \"I_T msgin.  Issuing NO-OP\\n\", ahd_name(ahd));\n\t\tahd->msgout_buf[ahd->msgout_index++] = NOP;\n\t\tahd->msgout_len++;\n\t\tahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\treturn;\n\t}\n\n\tif ((scb->flags & SCB_DEVICE_RESET) == 0\n\t && (scb->flags & SCB_PACKETIZED) == 0\n\t && ahd_inb(ahd, MSG_OUT) == MSG_IDENTIFYFLAG) {\n\t\tu_int identify_msg;\n\n\t\tidentify_msg = MSG_IDENTIFYFLAG | SCB_GET_LUN(scb);\n\t\tif ((scb->hscb->control & DISCENB) != 0)\n\t\t\tidentify_msg |= MSG_IDENTIFY_DISCFLAG;\n\t\tahd->msgout_buf[ahd->msgout_index++] = identify_msg;\n\t\tahd->msgout_len++;\n\n\t\tif ((scb->hscb->control & TAG_ENB) != 0) {\n\t\t\tahd->msgout_buf[ahd->msgout_index++] =\n\t\t\t    scb->hscb->control & (TAG_ENB|SCB_TAG_TYPE);\n\t\t\tahd->msgout_buf[ahd->msgout_index++] = SCB_GET_TAG(scb);\n\t\t\tahd->msgout_len += 2;\n\t\t}\n\t}\n\n\tif (scb->flags & SCB_DEVICE_RESET) {\n\t\tahd->msgout_buf[ahd->msgout_index++] = TARGET_RESET;\n\t\tahd->msgout_len++;\n\t\tahd_print_path(ahd, scb);\n\t\tprintk(\"Bus Device Reset Message Sent\\n\");\n\t\t \n\t\tahd_outb(ahd, SCSISEQ0, 0);\n\t} else if ((scb->flags & SCB_ABORT) != 0) {\n\n\t\tif ((scb->hscb->control & TAG_ENB) != 0) {\n\t\t\tahd->msgout_buf[ahd->msgout_index++] = ABORT_TASK;\n\t\t} else {\n\t\t\tahd->msgout_buf[ahd->msgout_index++] = ABORT_TASK_SET;\n\t\t}\n\t\tahd->msgout_len++;\n\t\tahd_print_path(ahd, scb);\n\t\tprintk(\"Abort%s Message Sent\\n\",\n\t\t       (scb->hscb->control & TAG_ENB) != 0 ? \" Tag\" : \"\");\n\t\t \n\t\tahd_outb(ahd, SCSISEQ0, 0);\n\t} else if ((scb->flags & (SCB_AUTO_NEGOTIATE|SCB_NEGOTIATE)) != 0) {\n\t\tahd_build_transfer_msg(ahd, devinfo);\n\t\t \n\t\tahd_outb(ahd, SCSISEQ0, 0);\n\t} else {\n\t\tprintk(\"ahd_intr: AWAITING_MSG for an SCB that \"\n\t\t       \"does not have a waiting message\\n\");\n\t\tprintk(\"SCSIID = %x, target_mask = %x\\n\", scb->hscb->scsiid,\n\t\t       devinfo->target_mask);\n\t\tpanic(\"SCB = %d, SCB Control = %x:%x, MSG_OUT = %x \"\n\t\t      \"SCB flags = %x\", SCB_GET_TAG(scb), scb->hscb->control,\n\t\t      ahd_inb_scbram(ahd, SCB_CONTROL), ahd_inb(ahd, MSG_OUT),\n\t\t      scb->flags);\n\t}\n\n\t \n\tahd_outb(ahd, SCB_CONTROL,\n\t\t ahd_inb_scbram(ahd, SCB_CONTROL) & ~MK_MESSAGE);\n\tscb->hscb->control &= ~MK_MESSAGE;\n\tahd->msgout_index = 0;\n\tahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n}\n\n \nstatic void\nahd_build_transfer_msg(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\n{\n\t \n\tstruct\tahd_initiator_tinfo *tinfo;\n\tstruct\tahd_tmode_tstate *tstate;\n\tint\tdowide;\n\tint\tdosync;\n\tint\tdoppr;\n\tu_int\tperiod;\n\tu_int\tppr_options;\n\tu_int\toffset;\n\n\ttinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\t \n\tperiod = tinfo->goal.period;\n\toffset = tinfo->goal.offset;\n\tppr_options = tinfo->goal.ppr_options;\n\t \n\tif (devinfo->role == ROLE_TARGET)\n\t\tppr_options = 0;\n\tahd_devlimited_syncrate(ahd, tinfo, &period,\n\t\t\t\t&ppr_options, devinfo->role);\n\tdowide = tinfo->curr.width != tinfo->goal.width;\n\tdosync = tinfo->curr.offset != offset || tinfo->curr.period != period;\n\t \n\tdoppr = ppr_options != 0;\n\n\tif (!dowide && !dosync && !doppr) {\n\t\tdowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;\n\t\tdosync = tinfo->goal.offset != 0;\n\t}\n\n\tif (!dowide && !dosync && !doppr) {\n\t\t \n\t\tif ((ahd->features & AHD_WIDE) != 0)\n\t\t\tdowide = 1;\n\t\telse\n\t\t\tdosync = 1;\n\n\t\tif (bootverbose) {\n\t\t\tahd_print_devinfo(ahd, devinfo);\n\t\t\tprintk(\"Ensuring async\\n\");\n\t\t}\n\t}\n\t \n\tif (devinfo->role == ROLE_TARGET)\n\t\tdoppr = 0;\n\n\t \n\tif (doppr || (dosync && !dowide)) {\n\n\t\toffset = tinfo->goal.offset;\n\t\tahd_validate_offset(ahd, tinfo, period, &offset,\n\t\t\t\t    doppr ? tinfo->goal.width\n\t\t\t\t\t  : tinfo->curr.width,\n\t\t\t\t    devinfo->role);\n\t\tif (doppr) {\n\t\t\tahd_construct_ppr(ahd, devinfo, period, offset,\n\t\t\t\t\t  tinfo->goal.width, ppr_options);\n\t\t} else {\n\t\t\tahd_construct_sdtr(ahd, devinfo, period, offset);\n\t\t}\n\t} else {\n\t\tahd_construct_wdtr(ahd, devinfo, tinfo->goal.width);\n\t}\n}\n\n \nstatic void\nahd_construct_sdtr(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\n\t\t   u_int period, u_int offset)\n{\n\tif (offset == 0)\n\t\tperiod = AHD_ASYNC_XFER_PERIOD;\n\tahd->msgout_index += spi_populate_sync_msg(\n\t\t\tahd->msgout_buf + ahd->msgout_index, period, offset);\n\tahd->msgout_len += 5;\n\tif (bootverbose) {\n\t\tprintk(\"(%s:%c:%d:%d): Sending SDTR period %x, offset %x\\n\",\n\t\t       ahd_name(ahd), devinfo->channel, devinfo->target,\n\t\t       devinfo->lun, period, offset);\n\t}\n}\n\n \nstatic void\nahd_construct_wdtr(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\n\t\t   u_int bus_width)\n{\n\tahd->msgout_index += spi_populate_width_msg(\n\t\t\tahd->msgout_buf + ahd->msgout_index, bus_width);\n\tahd->msgout_len += 4;\n\tif (bootverbose) {\n\t\tprintk(\"(%s:%c:%d:%d): Sending WDTR %x\\n\",\n\t\t       ahd_name(ahd), devinfo->channel, devinfo->target,\n\t\t       devinfo->lun, bus_width);\n\t}\n}\n\n \nstatic void\nahd_construct_ppr(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\n\t\t  u_int period, u_int offset, u_int bus_width,\n\t\t  u_int ppr_options)\n{\n\t \n\tif (period <= AHD_SYNCRATE_PACED)\n\t\tppr_options |= MSG_EXT_PPR_PCOMP_EN;\n\tif (offset == 0)\n\t\tperiod = AHD_ASYNC_XFER_PERIOD;\n\tahd->msgout_index += spi_populate_ppr_msg(\n\t\t\tahd->msgout_buf + ahd->msgout_index, period, offset,\n\t\t\tbus_width, ppr_options);\n\tahd->msgout_len += 8;\n\tif (bootverbose) {\n\t\tprintk(\"(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, \"\n\t\t       \"offset %x, ppr_options %x\\n\", ahd_name(ahd),\n\t\t       devinfo->channel, devinfo->target, devinfo->lun,\n\t\t       bus_width, period, offset, ppr_options);\n\t}\n}\n\n \nstatic void\nahd_clear_msg_state(struct ahd_softc *ahd)\n{\n\tahd_mode_state saved_modes;\n\n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\tahd->send_msg_perror = 0;\n\tahd->msg_flags = MSG_FLAG_NONE;\n\tahd->msgout_len = 0;\n\tahd->msgin_index = 0;\n\tahd->msg_type = MSG_TYPE_NONE;\n\tif ((ahd_inb(ahd, SCSISIGO) & ATNO) != 0) {\n\t\t \n\t\tahd_outb(ahd, CLRSINT1, CLRATNO);\n\t}\n\tahd_outb(ahd, MSG_OUT, NOP);\n\tahd_outb(ahd, SEQ_FLAGS2,\n\t\t ahd_inb(ahd, SEQ_FLAGS2) & ~TARGET_MSG_PENDING);\n\tahd_restore_modes(ahd, saved_modes);\n}\n\n \nstatic void\nahd_handle_message_phase(struct ahd_softc *ahd)\n{\n\tstruct\tahd_devinfo devinfo;\n\tu_int\tbus_phase;\n\tint\tend_session;\n\n\tahd_fetch_devinfo(ahd, &devinfo);\n\tend_session = FALSE;\n\tbus_phase = ahd_inb(ahd, LASTPHASE);\n\n\tif ((ahd_inb(ahd, LQISTAT2) & LQIPHASE_OUTPKT) != 0) {\n\t\tprintk(\"LQIRETRY for LQIPHASE_OUTPKT\\n\");\n\t\tahd_outb(ahd, LQCTL2, LQIRETRY);\n\t}\nreswitch:\n\tswitch (ahd->msg_type) {\n\tcase MSG_TYPE_INITIATOR_MSGOUT:\n\t{\n\t\tint lastbyte;\n\t\tint phasemis;\n\t\tint msgdone;\n\n\t\tif (ahd->msgout_len == 0 && ahd->send_msg_perror == 0)\n\t\t\tpanic(\"HOST_MSG_LOOP interrupt with no active message\");\n\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {\n\t\t\tahd_print_devinfo(ahd, &devinfo);\n\t\t\tprintk(\"INITIATOR_MSG_OUT\");\n\t\t}\n#endif\n\t\tphasemis = bus_phase != P_MESGOUT;\n\t\tif (phasemis) {\n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {\n\t\t\t\tprintk(\" PHASEMIS %s\\n\",\n\t\t\t\t       ahd_lookup_phase_entry(bus_phase)\n\t\t\t\t\t\t\t     ->phasemsg);\n\t\t\t}\n#endif\n\t\t\tif (bus_phase == P_MESGIN) {\n\t\t\t\t \n\t\t\t\tahd_outb(ahd, CLRSINT1, CLRATNO);\n\t\t\t\tahd->send_msg_perror = 0;\n\t\t\t\tahd->msg_type = MSG_TYPE_INITIATOR_MSGIN;\n\t\t\t\tahd->msgin_index = 0;\n\t\t\t\tgoto reswitch;\n\t\t\t}\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ahd->send_msg_perror) {\n\t\t\tahd_outb(ahd, CLRSINT1, CLRATNO);\n\t\t\tahd_outb(ahd, CLRSINT1, CLRREQINIT);\n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\n\t\t\t\tprintk(\" byte 0x%x\\n\", ahd->send_msg_perror);\n#endif\n\t\t\t \n\t\t\tif ((ahd->msg_flags & MSG_FLAG_PACKETIZED) != 0\n\t\t\t && ahd->send_msg_perror == INITIATOR_ERROR)\n\t\t\t\tahd->msg_flags |= MSG_FLAG_EXPECT_IDE_BUSFREE;\n\n\t\t\tahd_outb(ahd, RETURN_2, ahd->send_msg_perror);\n\t\t\tahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_WRITE);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsgdone\t= ahd->msgout_index == ahd->msgout_len;\n\t\tif (msgdone) {\n\t\t\t \n\t\t\tahd->msgout_index = 0;\n\t\t\tahd_assert_atn(ahd);\n\t\t}\n\n\t\tlastbyte = ahd->msgout_index == (ahd->msgout_len - 1);\n\t\tif (lastbyte) {\n\t\t\t \n\t\t\tahd_outb(ahd, CLRSINT1, CLRATNO);\n\t\t}\n\n\t\t \n\t\tahd_outb(ahd, CLRSINT1, CLRREQINIT);\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\n\t\t\tprintk(\" byte 0x%x\\n\",\n\t\t\t       ahd->msgout_buf[ahd->msgout_index]);\n#endif\n\t\tahd_outb(ahd, RETURN_2, ahd->msgout_buf[ahd->msgout_index++]);\n\t\tahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_WRITE);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_INITIATOR_MSGIN:\n\t{\n\t\tint phasemis;\n\t\tint message_done;\n\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {\n\t\t\tahd_print_devinfo(ahd, &devinfo);\n\t\t\tprintk(\"INITIATOR_MSG_IN\");\n\t\t}\n#endif\n\t\tphasemis = bus_phase != P_MESGIN;\n\t\tif (phasemis) {\n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {\n\t\t\t\tprintk(\" PHASEMIS %s\\n\",\n\t\t\t\t       ahd_lookup_phase_entry(bus_phase)\n\t\t\t\t\t\t\t     ->phasemsg);\n\t\t\t}\n#endif\n\t\t\tahd->msgin_index = 0;\n\t\t\tif (bus_phase == P_MESGOUT\n\t\t\t && (ahd->send_msg_perror != 0\n\t\t\t  || (ahd->msgout_len != 0\n\t\t\t   && ahd->msgout_index == 0))) {\n\t\t\t\tahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\t\t\tgoto reswitch;\n\t\t\t}\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tahd->msgin_buf[ahd->msgin_index] = ahd_inb(ahd, SCSIBUS);\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\n\t\t\tprintk(\" byte 0x%x\\n\",\n\t\t\t       ahd->msgin_buf[ahd->msgin_index]);\n#endif\n\n\t\tmessage_done = ahd_parse_msg(ahd, &devinfo);\n\n\t\tif (message_done) {\n\t\t\t \n\t\t\tahd->msgin_index = 0;\n\n\t\t\t \n\t\t\tif (ahd->msgout_len != 0) {\n#ifdef AHD_DEBUG\n\t\t\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {\n\t\t\t\t\tahd_print_devinfo(ahd, &devinfo);\n\t\t\t\t\tprintk(\"Asserting ATN for response\\n\");\n\t\t\t\t}\n#endif\n\t\t\t\tahd_assert_atn(ahd);\n\t\t\t}\n\t\t} else\n\t\t\tahd->msgin_index++;\n\n\t\tif (message_done == MSGLOOP_TERMINATED) {\n\t\t\tend_session = TRUE;\n\t\t} else {\n\t\t\t \n\t\t\tahd_outb(ahd, CLRSINT1, CLRREQINIT);\n\t\t\tahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_READ);\n\t\t}\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_TARGET_MSGIN:\n\t{\n\t\tint msgdone;\n\t\tint msgout_request;\n\n\t\t \n\t\tahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_TARG);\n\n\t\tif (ahd->msgout_len == 0)\n\t\t\tpanic(\"Target MSGIN with no active message\");\n\n\t\t \n\t\tif ((ahd_inb(ahd, SCSISIGI) & ATNI) != 0\n\t\t && ahd->msgout_index > 0)\n\t\t\tmsgout_request = TRUE;\n\t\telse\n\t\t\tmsgout_request = FALSE;\n\n\t\tif (msgout_request) {\n\n\t\t\t \n\t\t\tahd->msg_type = MSG_TYPE_TARGET_MSGOUT;\n\t\t\tahd_outb(ahd, SCSISIGO, P_MESGOUT | BSYO);\n\t\t\tahd->msgin_index = 0;\n\t\t\t \n\t\t\tahd_inb(ahd, SCSIDAT);\n\t\t\tahd_outb(ahd, SXFRCTL0,\n\t\t\t\t ahd_inb(ahd, SXFRCTL0) | SPIOEN);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsgdone = ahd->msgout_index == ahd->msgout_len;\n\t\tif (msgdone) {\n\t\t\tahd_outb(ahd, SXFRCTL0,\n\t\t\t\t ahd_inb(ahd, SXFRCTL0) & ~SPIOEN);\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tahd_outb(ahd, SXFRCTL0, ahd_inb(ahd, SXFRCTL0) | SPIOEN);\n\t\tahd_outb(ahd, SCSIDAT, ahd->msgout_buf[ahd->msgout_index++]);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_TARGET_MSGOUT:\n\t{\n\t\tint lastbyte;\n\t\tint msgdone;\n\n\t\t \n\t\tahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_TARG);\n\n\t\t \n\t\tlastbyte = (ahd_inb(ahd, SCSISIGI) & ATNI) == 0;\n\n\t\t \n\t\tahd_outb(ahd, SXFRCTL0, ahd_inb(ahd, SXFRCTL0) & ~SPIOEN);\n\t\tahd->msgin_buf[ahd->msgin_index] = ahd_inb(ahd, SCSIDAT);\n\t\tmsgdone = ahd_parse_msg(ahd, &devinfo);\n\t\tif (msgdone == MSGLOOP_TERMINATED) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\tahd->msgin_index++;\n\n\t\t \n\t\tif (msgdone == MSGLOOP_MSGCOMPLETE) {\n\t\t\tahd->msgin_index = 0;\n\n\t\t\t \n\t\t\tif (ahd->msgout_len != 0) {\n\t\t\t\tahd_outb(ahd, SCSISIGO, P_MESGIN | BSYO);\n\t\t\t\tahd_outb(ahd, SXFRCTL0,\n\t\t\t\t\t ahd_inb(ahd, SXFRCTL0) | SPIOEN);\n\t\t\t\tahd->msg_type = MSG_TYPE_TARGET_MSGIN;\n\t\t\t\tahd->msgin_index = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (lastbyte)\n\t\t\tend_session = TRUE;\n\t\telse {\n\t\t\t \n\t\t\tahd_outb(ahd, SXFRCTL0,\n\t\t\t\t ahd_inb(ahd, SXFRCTL0) | SPIOEN);\n\t\t}\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpanic(\"Unknown REQINIT message type\");\n\t}\n\n\tif (end_session) {\n\t\tif ((ahd->msg_flags & MSG_FLAG_PACKETIZED) != 0) {\n\t\t\tprintk(\"%s: Returning to Idle Loop\\n\",\n\t\t\t       ahd_name(ahd));\n\t\t\tahd_clear_msg_state(ahd);\n\n\t\t\t \n\t\t\tahd_outb(ahd, LASTPHASE, P_BUSFREE);\n\t\t\tahd_outb(ahd, SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT);\n\t\t\tahd_outb(ahd, SEQCTL0, FASTMODE|SEQRESET);\n\t\t} else {\n\t\t\tahd_clear_msg_state(ahd);\n\t\t\tahd_outb(ahd, RETURN_1, EXIT_MSG_LOOP);\n\t\t}\n\t}\n}\n\n \nstatic int\nahd_sent_msg(struct ahd_softc *ahd, ahd_msgtype type, u_int msgval, int full)\n{\n\tint found;\n\tu_int index;\n\n\tfound = FALSE;\n\tindex = 0;\n\n\twhile (index < ahd->msgout_len) {\n\t\tif (ahd->msgout_buf[index] == EXTENDED_MESSAGE) {\n\t\t\tu_int end_index;\n\n\t\t\tend_index = index + 1 + ahd->msgout_buf[index + 1];\n\t\t\tif (ahd->msgout_buf[index+2] == msgval\n\t\t\t && type == AHDMSG_EXT) {\n\n\t\t\t\tif (full) {\n\t\t\t\t\tif (ahd->msgout_index > end_index)\n\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t} else if (ahd->msgout_index > index)\n\t\t\t\t\tfound = TRUE;\n\t\t\t}\n\t\t\tindex = end_index;\n\t\t} else if (ahd->msgout_buf[index] >= SIMPLE_QUEUE_TAG\n\t\t\t&& ahd->msgout_buf[index] <= IGNORE_WIDE_RESIDUE) {\n\n\t\t\t \n\t\t\tindex += 2;\n\t\t} else {\n\t\t\t \n\t\t\tif (type == AHDMSG_1B\n\t\t\t && ahd->msgout_index > index\n\t\t\t && (ahd->msgout_buf[index] == msgval\n\t\t\t  || ((ahd->msgout_buf[index] & MSG_IDENTIFYFLAG) != 0\n\t\t\t   && msgval == MSG_IDENTIFYFLAG)))\n\t\t\t\tfound = TRUE;\n\t\t\tindex++;\n\t\t}\n\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\treturn (found);\n}\n\n \nstatic int\nahd_parse_msg(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\n{\n\tstruct\tahd_initiator_tinfo *tinfo;\n\tstruct\tahd_tmode_tstate *tstate;\n\tint\treject;\n\tint\tdone;\n\tint\tresponse;\n\n\tdone = MSGLOOP_IN_PROG;\n\tresponse = FALSE;\n\treject = FALSE;\n\ttinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\n\t \n\tswitch (ahd->msgin_buf[0]) {\n\tcase DISCONNECT:\n\tcase SAVE_POINTERS:\n\tcase COMMAND_COMPLETE:\n\tcase RESTORE_POINTERS:\n\tcase IGNORE_WIDE_RESIDUE:\n\t\t \n\t\tdone = MSGLOOP_TERMINATED;\n\t\tbreak;\n\tcase MESSAGE_REJECT:\n\t\tresponse = ahd_handle_msg_reject(ahd, devinfo);\n\t\tfallthrough;\n\tcase NOP:\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\tbreak;\n\tcase EXTENDED_MESSAGE:\n\t{\n\t\t \n\t\tif (ahd->msgin_index < 2)\n\t\t\tbreak;\n\t\tswitch (ahd->msgin_buf[2]) {\n\t\tcase EXTENDED_SDTR:\n\t\t{\n\t\t\tu_int\t period;\n\t\t\tu_int\t ppr_options;\n\t\t\tu_int\t offset;\n\t\t\tu_int\t saved_offset;\n\n\t\t\tif (ahd->msgin_buf[1] != MSG_EXT_SDTR_LEN) {\n\t\t\t\treject = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ahd->msgin_index < (MSG_EXT_SDTR_LEN + 1))\n\t\t\t\tbreak;\n\n\t\t\tperiod = ahd->msgin_buf[3];\n\t\t\tppr_options = 0;\n\t\t\tsaved_offset = offset = ahd->msgin_buf[4];\n\t\t\tahd_devlimited_syncrate(ahd, tinfo, &period,\n\t\t\t\t\t\t&ppr_options, devinfo->role);\n\t\t\tahd_validate_offset(ahd, tinfo, period, &offset,\n\t\t\t\t\t    tinfo->curr.width, devinfo->role);\n\t\t\tif (bootverbose) {\n\t\t\t\tprintk(\"(%s:%c:%d:%d): Received \"\n\t\t\t\t       \"SDTR period %x, offset %x\\n\\t\"\n\t\t\t\t       \"Filtered to period %x, offset %x\\n\",\n\t\t\t\t       ahd_name(ahd), devinfo->channel,\n\t\t\t\t       devinfo->target, devinfo->lun,\n\t\t\t\t       ahd->msgin_buf[3], saved_offset,\n\t\t\t\t       period, offset);\n\t\t\t}\n\t\t\tahd_set_syncrate(ahd, devinfo, period,\n\t\t\t\t\t offset, ppr_options,\n\t\t\t\t\t AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,\n\t\t\t\t\t  TRUE);\n\n\t\t\t \n\t\t\tif (ahd_sent_msg(ahd, AHDMSG_EXT, EXTENDED_SDTR, TRUE)) {\n\t\t\t\t \n\t\t\t\tif (saved_offset != offset) {\n\t\t\t\t\t \n\t\t\t\t\treject = TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (bootverbose\n\t\t\t\t && devinfo->role == ROLE_INITIATOR) {\n\t\t\t\t\tprintk(\"(%s:%c:%d:%d): Target \"\n\t\t\t\t\t       \"Initiated SDTR\\n\",\n\t\t\t\t\t       ahd_name(ahd), devinfo->channel,\n\t\t\t\t\t       devinfo->target, devinfo->lun);\n\t\t\t\t}\n\t\t\t\tahd->msgout_index = 0;\n\t\t\t\tahd->msgout_len = 0;\n\t\t\t\tahd_construct_sdtr(ahd, devinfo,\n\t\t\t\t\t\t   period, offset);\n\t\t\t\tahd->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t}\n\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\tcase EXTENDED_WDTR:\n\t\t{\n\t\t\tu_int bus_width;\n\t\t\tu_int saved_width;\n\t\t\tu_int sending_reply;\n\n\t\t\tsending_reply = FALSE;\n\t\t\tif (ahd->msgin_buf[1] != MSG_EXT_WDTR_LEN) {\n\t\t\t\treject = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ahd->msgin_index < (MSG_EXT_WDTR_LEN + 1))\n\t\t\t\tbreak;\n\n\t\t\tbus_width = ahd->msgin_buf[3];\n\t\t\tsaved_width = bus_width;\n\t\t\tahd_validate_width(ahd, tinfo, &bus_width,\n\t\t\t\t\t   devinfo->role);\n\t\t\tif (bootverbose) {\n\t\t\t\tprintk(\"(%s:%c:%d:%d): Received WDTR \"\n\t\t\t\t       \"%x filtered to %x\\n\",\n\t\t\t\t       ahd_name(ahd), devinfo->channel,\n\t\t\t\t       devinfo->target, devinfo->lun,\n\t\t\t\t       saved_width, bus_width);\n\t\t\t}\n\n\t\t\tif (ahd_sent_msg(ahd, AHDMSG_EXT, EXTENDED_WDTR, TRUE)) {\n\t\t\t\t \n\t\t\t\tif (saved_width > bus_width) {\n\t\t\t\t\treject = TRUE;\n\t\t\t\t\tprintk(\"(%s:%c:%d:%d): requested %dBit \"\n\t\t\t\t\t       \"transfers.  Rejecting...\\n\",\n\t\t\t\t\t       ahd_name(ahd), devinfo->channel,\n\t\t\t\t\t       devinfo->target, devinfo->lun,\n\t\t\t\t\t       8 * (0x01 << bus_width));\n\t\t\t\t\tbus_width = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (bootverbose\n\t\t\t\t && devinfo->role == ROLE_INITIATOR) {\n\t\t\t\t\tprintk(\"(%s:%c:%d:%d): Target \"\n\t\t\t\t\t       \"Initiated WDTR\\n\",\n\t\t\t\t\t       ahd_name(ahd), devinfo->channel,\n\t\t\t\t\t       devinfo->target, devinfo->lun);\n\t\t\t\t}\n\t\t\t\tahd->msgout_index = 0;\n\t\t\t\tahd->msgout_len = 0;\n\t\t\t\tahd_construct_wdtr(ahd, devinfo, bus_width);\n\t\t\t\tahd->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t\tsending_reply = TRUE;\n\t\t\t}\n\t\t\t \n\t\t\tahd_update_neg_request(ahd, devinfo, tstate,\n\t\t\t\t\t       tinfo, AHD_NEG_ALWAYS);\n\t\t\tahd_set_width(ahd, devinfo, bus_width,\n\t\t\t\t      AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,\n\t\t\t\t       TRUE);\n\t\t\tif (sending_reply == FALSE && reject == FALSE) {\n\n\t\t\t\t \n\t\t\t\tahd->msgout_index = 0;\n\t\t\t\tahd->msgout_len = 0;\n\t\t\t\tahd_build_transfer_msg(ahd, devinfo);\n\t\t\t\tahd->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t}\n\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\tcase EXTENDED_PPR:\n\t\t{\n\t\t\tu_int\tperiod;\n\t\t\tu_int\toffset;\n\t\t\tu_int\tbus_width;\n\t\t\tu_int\tppr_options;\n\t\t\tu_int\tsaved_width;\n\t\t\tu_int\tsaved_offset;\n\t\t\tu_int\tsaved_ppr_options;\n\n\t\t\tif (ahd->msgin_buf[1] != MSG_EXT_PPR_LEN) {\n\t\t\t\treject = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ahd->msgin_index < (MSG_EXT_PPR_LEN + 1))\n\t\t\t\tbreak;\n\n\t\t\tperiod = ahd->msgin_buf[3];\n\t\t\toffset = ahd->msgin_buf[5];\n\t\t\tbus_width = ahd->msgin_buf[6];\n\t\t\tsaved_width = bus_width;\n\t\t\tppr_options = ahd->msgin_buf[7];\n\t\t\t \n\t\t\tif ((ppr_options & MSG_EXT_PPR_DT_REQ) == 0\n\t\t\t && period <= 9)\n\t\t\t\toffset = 0;\n\t\t\tsaved_ppr_options = ppr_options;\n\t\t\tsaved_offset = offset;\n\n\t\t\t \n\t\t\tif (bus_width == 0)\n\t\t\t\tppr_options &= MSG_EXT_PPR_QAS_REQ;\n\n\t\t\tahd_validate_width(ahd, tinfo, &bus_width,\n\t\t\t\t\t   devinfo->role);\n\t\t\tahd_devlimited_syncrate(ahd, tinfo, &period,\n\t\t\t\t\t\t&ppr_options, devinfo->role);\n\t\t\tahd_validate_offset(ahd, tinfo, period, &offset,\n\t\t\t\t\t    bus_width, devinfo->role);\n\n\t\t\tif (ahd_sent_msg(ahd, AHDMSG_EXT, EXTENDED_PPR, TRUE)) {\n\t\t\t\t \n\t\t\t\tif (saved_width > bus_width\n\t\t\t\t || saved_offset != offset\n\t\t\t\t || saved_ppr_options != ppr_options) {\n\t\t\t\t\treject = TRUE;\n\t\t\t\t\tperiod = 0;\n\t\t\t\t\toffset = 0;\n\t\t\t\t\tbus_width = 0;\n\t\t\t\t\tppr_options = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (devinfo->role != ROLE_TARGET)\n\t\t\t\t\tprintk(\"(%s:%c:%d:%d): Target \"\n\t\t\t\t\t       \"Initiated PPR\\n\",\n\t\t\t\t\t       ahd_name(ahd), devinfo->channel,\n\t\t\t\t\t       devinfo->target, devinfo->lun);\n\t\t\t\telse\n\t\t\t\t\tprintk(\"(%s:%c:%d:%d): Initiator \"\n\t\t\t\t\t       \"Initiated PPR\\n\",\n\t\t\t\t\t       ahd_name(ahd), devinfo->channel,\n\t\t\t\t\t       devinfo->target, devinfo->lun);\n\t\t\t\tahd->msgout_index = 0;\n\t\t\t\tahd->msgout_len = 0;\n\t\t\t\tahd_construct_ppr(ahd, devinfo, period, offset,\n\t\t\t\t\t\t  bus_width, ppr_options);\n\t\t\t\tahd->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t}\n\t\t\tif (bootverbose) {\n\t\t\t\tprintk(\"(%s:%c:%d:%d): Received PPR width %x, \"\n\t\t\t\t       \"period %x, offset %x,options %x\\n\"\n\t\t\t\t       \"\\tFiltered to width %x, period %x, \"\n\t\t\t\t       \"offset %x, options %x\\n\",\n\t\t\t\t       ahd_name(ahd), devinfo->channel,\n\t\t\t\t       devinfo->target, devinfo->lun,\n\t\t\t\t       saved_width, ahd->msgin_buf[3],\n\t\t\t\t       saved_offset, saved_ppr_options,\n\t\t\t\t       bus_width, period, offset, ppr_options);\n\t\t\t}\n\t\t\tahd_set_width(ahd, devinfo, bus_width,\n\t\t\t\t      AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,\n\t\t\t\t       TRUE);\n\t\t\tahd_set_syncrate(ahd, devinfo, period,\n\t\t\t\t\t offset, ppr_options,\n\t\t\t\t\t AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,\n\t\t\t\t\t  TRUE);\n\n\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\t \n\t\t\treject = TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n#ifdef AHD_TARGET_MODE\n\tcase TARGET_RESET:\n\t\tahd_handle_devreset(ahd, devinfo, CAM_LUN_WILDCARD,\n\t\t\t\t    CAM_BDR_SENT,\n\t\t\t\t    \"Bus Device Reset Received\",\n\t\t\t\t     0);\n\t\tahd_restart(ahd);\n\t\tdone = MSGLOOP_TERMINATED;\n\t\tbreak;\n\tcase ABORT_TASK:\n\tcase ABORT_TASK_SET:\n\tcase CLEAR_TASK_SET:\n\t{\n\t\tint tag;\n\n\t\t \n\t\tif (devinfo->role != ROLE_TARGET) {\n\t\t\treject = TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ttag = SCB_LIST_NULL;\n\t\tif (ahd->msgin_buf[0] == ABORT_TASK)\n\t\t\ttag = ahd_inb(ahd, INITIATOR_TAG);\n\t\tahd_abort_scbs(ahd, devinfo->target, devinfo->channel,\n\t\t\t       devinfo->lun, tag, ROLE_TARGET,\n\t\t\t       CAM_REQ_ABORTED);\n\n\t\ttstate = ahd->enabled_targets[devinfo->our_scsiid];\n\t\tif (tstate != NULL) {\n\t\t\tstruct ahd_tmode_lstate* lstate;\n\n\t\t\tlstate = tstate->enabled_luns[devinfo->lun];\n\t\t\tif (lstate != NULL) {\n\t\t\t\tahd_queue_lstate_event(ahd, lstate,\n\t\t\t\t\t\t       devinfo->our_scsiid,\n\t\t\t\t\t\t       ahd->msgin_buf[0],\n\t\t\t\t\t\t        tag);\n\t\t\t\tahd_send_lstate_events(ahd, lstate);\n\t\t\t}\n\t\t}\n\t\tahd_restart(ahd);\n\t\tdone = MSGLOOP_TERMINATED;\n\t\tbreak;\n\t}\n#endif\n\tcase QAS_REQUEST:\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\n\t\t\tprintk(\"%s: QAS request.  SCSISIGI == 0x%x\\n\",\n\t\t\t       ahd_name(ahd), ahd_inb(ahd, SCSISIGI));\n#endif\n\t\tahd->msg_flags |= MSG_FLAG_EXPECT_QASREJ_BUSFREE;\n\t\tfallthrough;\n\tcase TERMINATE_IO_PROC:\n\tdefault:\n\t\treject = TRUE;\n\t\tbreak;\n\t}\n\n\tif (reject) {\n\t\t \n\t\tahd->msgout_index = 0;\n\t\tahd->msgout_len = 1;\n\t\tahd->msgout_buf[0] = MESSAGE_REJECT;\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\tresponse = TRUE;\n\t}\n\n\tif (done != MSGLOOP_IN_PROG && !response)\n\t\t \n\t\tahd->msgout_len = 0;\n\n\treturn (done);\n}\n\n \nstatic int\nahd_handle_msg_reject(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\n{\n\t \n\tstruct scb *scb;\n\tstruct ahd_initiator_tinfo *tinfo;\n\tstruct ahd_tmode_tstate *tstate;\n\tu_int scb_index;\n\tu_int last_msg;\n\tint   response = 0;\n\n\tscb_index = ahd_get_scbptr(ahd);\n\tscb = ahd_lookup_scb(ahd, scb_index);\n\ttinfo = ahd_fetch_transinfo(ahd, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\t \n\tlast_msg = ahd_inb(ahd, LAST_MSG);\n\n\tif (ahd_sent_msg(ahd, AHDMSG_EXT, EXTENDED_PPR,  FALSE)) {\n\t\tif (ahd_sent_msg(ahd, AHDMSG_EXT, EXTENDED_PPR,  TRUE)\n\t\t && tinfo->goal.period <= AHD_SYNCRATE_PACED) {\n\t\t\t \n\t\t\tif (bootverbose) {\n\t\t\t\tprintk(\"(%s:%c:%d:%d): PPR Rejected. \"\n\t\t\t\t       \"Trying simple U160 PPR\\n\",\n\t\t\t\t       ahd_name(ahd), devinfo->channel,\n\t\t\t\t       devinfo->target, devinfo->lun);\n\t\t\t}\n\t\t\ttinfo->goal.period = AHD_SYNCRATE_DT;\n\t\t\ttinfo->goal.ppr_options &= MSG_EXT_PPR_IU_REQ\n\t\t\t\t\t\t|  MSG_EXT_PPR_QAS_REQ\n\t\t\t\t\t\t|  MSG_EXT_PPR_DT_REQ;\n\t\t} else {\n\t\t\t \n\t\t\tif (bootverbose) {\n\t\t\t\tprintk(\"(%s:%c:%d:%d): PPR Rejected. \"\n\t\t\t\t       \"Trying WDTR/SDTR\\n\",\n\t\t\t\t       ahd_name(ahd), devinfo->channel,\n\t\t\t\t       devinfo->target, devinfo->lun);\n\t\t\t}\n\t\t\ttinfo->goal.ppr_options = 0;\n\t\t\ttinfo->curr.transport_version = 2;\n\t\t\ttinfo->goal.transport_version = 2;\n\t\t}\n\t\tahd->msgout_index = 0;\n\t\tahd->msgout_len = 0;\n\t\tahd_build_transfer_msg(ahd, devinfo);\n\t\tahd->msgout_index = 0;\n\t\tresponse = 1;\n\t} else if (ahd_sent_msg(ahd, AHDMSG_EXT, EXTENDED_WDTR,  FALSE)) {\n\n\t\t \n\t\tprintk(\"(%s:%c:%d:%d): refuses WIDE negotiation.  Using \"\n\t\t       \"8bit transfers\\n\", ahd_name(ahd),\n\t\t       devinfo->channel, devinfo->target, devinfo->lun);\n\t\tahd_set_width(ahd, devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t      AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,\n\t\t\t       TRUE);\n\t\t \n\t\tif (tinfo->goal.offset != tinfo->curr.offset) {\n\n\t\t\t \n\t\t\tahd->msgout_index = 0;\n\t\t\tahd->msgout_len = 0;\n\t\t\tahd_build_transfer_msg(ahd, devinfo);\n\t\t\tahd->msgout_index = 0;\n\t\t\tresponse = 1;\n\t\t}\n\t} else if (ahd_sent_msg(ahd, AHDMSG_EXT, EXTENDED_SDTR,  FALSE)) {\n\t\t \n\t\tahd_set_syncrate(ahd, devinfo,  0,\n\t\t\t\t  0,  0,\n\t\t\t\t AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,\n\t\t\t\t  TRUE);\n\t\tprintk(\"(%s:%c:%d:%d): refuses synchronous negotiation. \"\n\t\t       \"Using asynchronous transfers\\n\",\n\t\t       ahd_name(ahd), devinfo->channel,\n\t\t       devinfo->target, devinfo->lun);\n\t} else if ((scb->hscb->control & SIMPLE_QUEUE_TAG) != 0) {\n\t\tint tag_type;\n\t\tint mask;\n\n\t\ttag_type = (scb->hscb->control & SIMPLE_QUEUE_TAG);\n\n\t\tif (tag_type == SIMPLE_QUEUE_TAG) {\n\t\t\tprintk(\"(%s:%c:%d:%d): refuses tagged commands.  \"\n\t\t\t       \"Performing non-tagged I/O\\n\", ahd_name(ahd),\n\t\t\t       devinfo->channel, devinfo->target, devinfo->lun);\n\t\t\tahd_set_tags(ahd, scb->io_ctx, devinfo, AHD_QUEUE_NONE);\n\t\t\tmask = ~0x23;\n\t\t} else {\n\t\t\tprintk(\"(%s:%c:%d:%d): refuses %s tagged commands.  \"\n\t\t\t       \"Performing simple queue tagged I/O only\\n\",\n\t\t\t       ahd_name(ahd), devinfo->channel, devinfo->target,\n\t\t\t       devinfo->lun, tag_type == ORDERED_QUEUE_TAG\n\t\t\t       ? \"ordered\" : \"head of queue\");\n\t\t\tahd_set_tags(ahd, scb->io_ctx, devinfo, AHD_QUEUE_BASIC);\n\t\t\tmask = ~0x03;\n\t\t}\n\n\t\t \n\t\tahd_outb(ahd, SCB_CONTROL,\n\t\t\t ahd_inb_scbram(ahd, SCB_CONTROL) & mask);\n\t\tscb->hscb->control &= mask;\n\t\tahd_set_transaction_tag(scb,  FALSE,\n\t\t\t\t\t SIMPLE_QUEUE_TAG);\n\t\tahd_outb(ahd, MSG_OUT, MSG_IDENTIFYFLAG);\n\t\tahd_assert_atn(ahd);\n\t\tahd_busy_tcl(ahd, BUILD_TCL(scb->hscb->scsiid, devinfo->lun),\n\t\t\t     SCB_GET_TAG(scb));\n\n\t\t \n\t\tahd_search_qinfifo(ahd, SCB_GET_TARGET(ahd, scb),\n\t\t\t\t   SCB_GET_CHANNEL(ahd, scb),\n\t\t\t\t   SCB_GET_LUN(scb),  SCB_LIST_NULL,\n\t\t\t\t   ROLE_INITIATOR, CAM_REQUEUE_REQ,\n\t\t\t\t   SEARCH_COMPLETE);\n\t} else if (ahd_sent_msg(ahd, AHDMSG_1B, MSG_IDENTIFYFLAG, TRUE)) {\n\t\t \n\t\tahd->msg_flags |= MSG_FLAG_EXPECT_PPR_BUSFREE\n\t\t\t       |  MSG_FLAG_IU_REQ_CHANGED;\n\n\t\tahd_force_renegotiation(ahd, devinfo);\n\t\tahd->msgout_index = 0;\n\t\tahd->msgout_len = 0;\n\t\tahd_build_transfer_msg(ahd, devinfo);\n\t\tahd->msgout_index = 0;\n\t\tresponse = 1;\n\t} else {\n\t\t \n\t\tprintk(\"%s:%c:%d: Message reject for %x -- ignored\\n\",\n\t\t       ahd_name(ahd), devinfo->channel, devinfo->target,\n\t\t       last_msg);\n\t}\n\treturn (response);\n}\n\n \nstatic void\nahd_handle_ign_wide_residue(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\n{\n\tu_int scb_index;\n\tstruct scb *scb;\n\n\tscb_index = ahd_get_scbptr(ahd);\n\tscb = ahd_lookup_scb(ahd, scb_index);\n\t \n\tif ((ahd_inb(ahd, SEQ_FLAGS) & DPHASE) == 0\n\t || ahd_get_transfer_dir(scb) != CAM_DIR_IN) {\n\t\t \n\t} else {\n\t\t \n\t\tuint32_t sgptr;\n\n\t\tsgptr = ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR);\n\t\tif ((sgptr & SG_LIST_NULL) != 0\n\t\t && (ahd_inb_scbram(ahd, SCB_TASK_ATTRIBUTE)\n\t\t     & SCB_XFERLEN_ODD) != 0) {\n\t\t\t \n\t\t} else {\n\t\t\tuint32_t data_cnt;\n\t\t\tuint64_t data_addr;\n\t\t\tuint32_t sglen;\n\n\t\t\t \n\t\t\tsgptr = ahd_inl_scbram(ahd, SCB_RESIDUAL_SGPTR);\n\t\t\tdata_cnt = ahd_inl_scbram(ahd, SCB_RESIDUAL_DATACNT);\n\t\t\tif ((sgptr & SG_LIST_NULL) != 0) {\n\t\t\t\t \n\t\t\t\tdata_cnt &= ~AHD_SG_LEN_MASK;\n\t\t\t}\n\t\t\tdata_addr = ahd_inq(ahd, SHADDR);\n\t\t\tdata_cnt += 1;\n\t\t\tdata_addr -= 1;\n\t\t\tsgptr &= SG_PTR_MASK;\n\t\t\tif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {\n\t\t\t\tstruct ahd_dma64_seg *sg;\n\n\t\t\t\tsg = ahd_sg_bus_to_virt(ahd, scb, sgptr);\n\n\t\t\t\t \n\t\t\t\tsg--;\n\t\t\t\tsglen = ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;\n\t\t\t\tif (sg != scb->sg_list\n\t\t\t\t && sglen < (data_cnt & AHD_SG_LEN_MASK)) {\n\n\t\t\t\t\tsg--;\n\t\t\t\t\tsglen = ahd_le32toh(sg->len);\n\t\t\t\t\t \n\t\t\t\t\tdata_cnt = 1|(sglen&(~AHD_SG_LEN_MASK));\n\t\t\t\t\tdata_addr = ahd_le64toh(sg->addr)\n\t\t\t\t\t\t  + (sglen & AHD_SG_LEN_MASK)\n\t\t\t\t\t\t  - 1;\n\n\t\t\t\t\t \n\t\t\t\t\tsg++;\n\t\t\t\t\tsgptr = ahd_sg_virt_to_bus(ahd, scb,\n\t\t\t\t\t\t\t\t   sg);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct ahd_dma_seg *sg;\n\n\t\t\t\tsg = ahd_sg_bus_to_virt(ahd, scb, sgptr);\n\n\t\t\t\t \n\t\t\t\tsg--;\n\t\t\t\tsglen = ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;\n\t\t\t\tif (sg != scb->sg_list\n\t\t\t\t && sglen < (data_cnt & AHD_SG_LEN_MASK)) {\n\n\t\t\t\t\tsg--;\n\t\t\t\t\tsglen = ahd_le32toh(sg->len);\n\t\t\t\t\t \n\t\t\t\t\tdata_cnt = 1|(sglen&(~AHD_SG_LEN_MASK));\n\t\t\t\t\tdata_addr = ahd_le32toh(sg->addr)\n\t\t\t\t\t\t  + (sglen & AHD_SG_LEN_MASK)\n\t\t\t\t\t\t  - 1;\n\n\t\t\t\t\t \n\t\t\t\t\tsg++;\n\t\t\t\t\tsgptr = ahd_sg_virt_to_bus(ahd, scb,\n\t\t\t\t\t\t\t\t  sg);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tahd_outb(ahd, SCB_TASK_ATTRIBUTE,\n\t\t\t    ahd_inb_scbram(ahd, SCB_TASK_ATTRIBUTE)\n\t\t\t    ^ SCB_XFERLEN_ODD);\n\n\t\t\tahd_outl(ahd, SCB_RESIDUAL_SGPTR, sgptr);\n\t\t\tahd_outl(ahd, SCB_RESIDUAL_DATACNT, data_cnt);\n\t\t\t \n\t\t}\n\t}\n}\n\n\n \nstatic void\nahd_reinitialize_dataptrs(struct ahd_softc *ahd)\n{\n\tstruct\t\t scb *scb;\n\tahd_mode_state\t saved_modes;\n\tu_int\t\t scb_index;\n\tu_int\t\t wait;\n\tuint32_t\t sgptr;\n\tuint32_t\t resid;\n\tuint64_t\t dataptr;\n\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_DFF0_MSK|AHD_MODE_DFF1_MSK,\n\t\t\t AHD_MODE_DFF0_MSK|AHD_MODE_DFF1_MSK);\n\n\tscb_index = ahd_get_scbptr(ahd);\n\tscb = ahd_lookup_scb(ahd, scb_index);\n\n\t \n\tahd_outb(ahd, DFFSXFRCTL, CLRCHN);\n\twait = 1000;\n\twhile (--wait && !(ahd_inb(ahd, MDFFSTAT) & FIFOFREE))\n\t\tahd_delay(100);\n\tif (wait == 0) {\n\t\tahd_print_path(ahd, scb);\n\t\tprintk(\"ahd_reinitialize_dataptrs: Forcing FIFO free.\\n\");\n\t\tahd_outb(ahd, DFFSXFRCTL, RSTCHN|CLRSHCNT);\n\t}\n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\tahd_outb(ahd, DFFSTAT,\n\t\t ahd_inb(ahd, DFFSTAT)\n\t\t| (saved_modes == 0x11 ? CURRFIFO_1 : CURRFIFO_0));\n\n\t \n\tsgptr = ahd_inl_scbram(ahd, SCB_RESIDUAL_SGPTR);\n\tsgptr &= SG_PTR_MASK;\n\n\tresid = (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT + 2) << 16)\n\t      | (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT + 1) << 8)\n\t      | ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT);\n\n\tif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {\n\t\tstruct ahd_dma64_seg *sg;\n\n\t\tsg = ahd_sg_bus_to_virt(ahd, scb, sgptr);\n\n\t\t \n\t\tsg--;\n\n\t\tdataptr = ahd_le64toh(sg->addr)\n\t\t\t+ (ahd_le32toh(sg->len) & AHD_SG_LEN_MASK)\n\t\t\t- resid;\n\t\tahd_outl(ahd, HADDR + 4, dataptr >> 32);\n\t} else {\n\t\tstruct\t ahd_dma_seg *sg;\n\n\t\tsg = ahd_sg_bus_to_virt(ahd, scb, sgptr);\n\n\t\t \n\t\tsg--;\n\n\t\tdataptr = ahd_le32toh(sg->addr)\n\t\t\t+ (ahd_le32toh(sg->len) & AHD_SG_LEN_MASK)\n\t\t\t- resid;\n\t\tahd_outb(ahd, HADDR + 4,\n\t\t\t (ahd_le32toh(sg->len) & ~AHD_SG_LEN_MASK) >> 24);\n\t}\n\tahd_outl(ahd, HADDR, dataptr);\n\tahd_outb(ahd, HCNT + 2, resid >> 16);\n\tahd_outb(ahd, HCNT + 1, resid >> 8);\n\tahd_outb(ahd, HCNT, resid);\n}\n\n \nstatic void\nahd_handle_devreset(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\n\t\t    u_int lun, cam_status status, char *message,\n\t\t    int verbose_level)\n{\n#ifdef AHD_TARGET_MODE\n\tstruct ahd_tmode_tstate* tstate;\n#endif\n\tint found;\n\n\tfound = ahd_abort_scbs(ahd, devinfo->target, devinfo->channel,\n\t\t\t       lun, SCB_LIST_NULL, devinfo->role,\n\t\t\t       status);\n\n#ifdef AHD_TARGET_MODE\n\t \n\ttstate = ahd->enabled_targets[devinfo->our_scsiid];\n\tif (tstate != NULL) {\n\t\tu_int cur_lun;\n\t\tu_int max_lun;\n\n\t\tif (lun != CAM_LUN_WILDCARD) {\n\t\t\tcur_lun = 0;\n\t\t\tmax_lun = AHD_NUM_LUNS - 1;\n\t\t} else {\n\t\t\tcur_lun = lun;\n\t\t\tmax_lun = lun;\n\t\t}\n\t\tfor (;cur_lun <= max_lun; cur_lun++) {\n\t\t\tstruct ahd_tmode_lstate* lstate;\n\n\t\t\tlstate = tstate->enabled_luns[cur_lun];\n\t\t\tif (lstate == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tahd_queue_lstate_event(ahd, lstate, devinfo->our_scsiid,\n\t\t\t\t\t       TARGET_RESET,  0);\n\t\t\tahd_send_lstate_events(ahd, lstate);\n\t\t}\n\t}\n#endif\n\n\t \n\tahd_set_width(ahd, devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t      AHD_TRANS_CUR,  TRUE);\n\tahd_set_syncrate(ahd, devinfo,  0,  0,\n\t\t\t  0, AHD_TRANS_CUR,\n\t\t\t  TRUE);\n\n\tif (status != CAM_SEL_TIMEOUT)\n\t\tahd_send_async(ahd, devinfo->channel, devinfo->target,\n\t\t\t       CAM_LUN_WILDCARD, AC_SENT_BDR);\n\n\tif (message != NULL && bootverbose)\n\t\tprintk(\"%s: %s on %c:%d. %d SCBs aborted\\n\", ahd_name(ahd),\n\t\t       message, devinfo->channel, devinfo->target, found);\n}\n\n#ifdef AHD_TARGET_MODE\nstatic void\nahd_setup_target_msgin(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\n\t\t       struct scb *scb)\n{\n\n\t \n\tahd->msgout_index = 0;\n\tahd->msgout_len = 0;\n\n\tif (scb != NULL && (scb->flags & SCB_AUTO_NEGOTIATE) != 0)\n\t\tahd_build_transfer_msg(ahd, devinfo);\n\telse\n\t\tpanic(\"ahd_intr: AWAITING target message with no message\");\n\n\tahd->msgout_index = 0;\n\tahd->msg_type = MSG_TYPE_TARGET_MSGIN;\n}\n#endif\n \nstatic u_int\nahd_sglist_size(struct ahd_softc *ahd)\n{\n\tbus_size_t list_size;\n\n\tlist_size = sizeof(struct ahd_dma_seg) * AHD_NSEG;\n\tif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)\n\t\tlist_size = sizeof(struct ahd_dma64_seg) * AHD_NSEG;\n\treturn (list_size);\n}\n\n \nstatic u_int\nahd_sglist_allocsize(struct ahd_softc *ahd)\n{\n\tbus_size_t sg_list_increment;\n\tbus_size_t sg_list_size;\n\tbus_size_t max_list_size;\n\tbus_size_t best_list_size;\n\n\t \n\tsg_list_increment = ahd_sglist_size(ahd);\n\tsg_list_size = sg_list_increment;\n\n\t \n\twhile ((sg_list_size + sg_list_increment) <= PAGE_SIZE)\n\t\tsg_list_size += sg_list_increment;\n\n\t \n\tbest_list_size = sg_list_size;\n\tmax_list_size = roundup(sg_list_increment, PAGE_SIZE);\n\tif (max_list_size < 4 * PAGE_SIZE)\n\t\tmax_list_size = 4 * PAGE_SIZE;\n\tif (max_list_size > (AHD_SCB_MAX_ALLOC * sg_list_increment))\n\t\tmax_list_size = (AHD_SCB_MAX_ALLOC * sg_list_increment);\n\twhile ((sg_list_size + sg_list_increment) <= max_list_size\n\t   &&  (sg_list_size % PAGE_SIZE) != 0) {\n\t\tbus_size_t new_mod;\n\t\tbus_size_t best_mod;\n\n\t\tsg_list_size += sg_list_increment;\n\t\tnew_mod = sg_list_size % PAGE_SIZE;\n\t\tbest_mod = best_list_size % PAGE_SIZE;\n\t\tif (new_mod > best_mod || new_mod == 0) {\n\t\t\tbest_list_size = sg_list_size;\n\t\t}\n\t}\n\treturn (best_list_size);\n}\n\n \nstruct ahd_softc *\nahd_alloc(void *platform_arg, char *name)\n{\n\tstruct  ahd_softc *ahd;\n\n\tahd = kzalloc(sizeof(*ahd), GFP_ATOMIC);\n\tif (!ahd) {\n\t\tprintk(\"aic7xxx: cannot malloc softc!\\n\");\n\t\tkfree(name);\n\t\treturn NULL;\n\t}\n\n\tahd->seep_config = kmalloc(sizeof(*ahd->seep_config), GFP_ATOMIC);\n\tif (ahd->seep_config == NULL) {\n\t\tkfree(ahd);\n\t\tkfree(name);\n\t\treturn (NULL);\n\t}\n\tLIST_INIT(&ahd->pending_scbs);\n\t \n\tahd->name = name;\n\tahd->unit = -1;\n\tahd->description = NULL;\n\tahd->bus_description = NULL;\n\tahd->channel = 'A';\n\tahd->chip = AHD_NONE;\n\tahd->features = AHD_FENONE;\n\tahd->bugs = AHD_BUGNONE;\n\tahd->flags = AHD_SPCHK_ENB_A|AHD_RESET_BUS_A|AHD_TERM_ENB_A\n\t\t   | AHD_EXTENDED_TRANS_A|AHD_STPWLEVEL_A;\n\ttimer_setup(&ahd->stat_timer, ahd_stat_timer, 0);\n\tahd->int_coalescing_timer = AHD_INT_COALESCING_TIMER_DEFAULT;\n\tahd->int_coalescing_maxcmds = AHD_INT_COALESCING_MAXCMDS_DEFAULT;\n\tahd->int_coalescing_mincmds = AHD_INT_COALESCING_MINCMDS_DEFAULT;\n\tahd->int_coalescing_threshold = AHD_INT_COALESCING_THRESHOLD_DEFAULT;\n\tahd->int_coalescing_stop_threshold =\n\t    AHD_INT_COALESCING_STOP_THRESHOLD_DEFAULT;\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_MEMORY) != 0) {\n\t\tprintk(\"%s: scb size = 0x%x, hscb size = 0x%x\\n\",\n\t\t       ahd_name(ahd), (u_int)sizeof(struct scb),\n\t\t       (u_int)sizeof(struct hardware_scb));\n\t}\n#endif\n\tif (ahd_platform_alloc(ahd, platform_arg) != 0) {\n\t\tahd_free(ahd);\n\t\tahd = NULL;\n\t}\n\treturn (ahd);\n}\n\nint\nahd_softc_init(struct ahd_softc *ahd)\n{\n\n\tahd->unpause = 0;\n\tahd->pause = PAUSE;\n\treturn (0);\n}\n\nvoid\nahd_set_unit(struct ahd_softc *ahd, int unit)\n{\n\tahd->unit = unit;\n}\n\nvoid\nahd_set_name(struct ahd_softc *ahd, char *name)\n{\n\tkfree(ahd->name);\n\tahd->name = name;\n}\n\nvoid\nahd_free(struct ahd_softc *ahd)\n{\n\tint i;\n\n\tswitch (ahd->init_level) {\n\tdefault:\n\tcase 5:\n\t\tahd_shutdown(ahd);\n\t\tfallthrough;\n\tcase 4:\n\t\tahd_dmamap_unload(ahd, ahd->shared_data_dmat,\n\t\t\t\t  ahd->shared_data_map.dmamap);\n\t\tfallthrough;\n\tcase 3:\n\t\tahd_dmamem_free(ahd, ahd->shared_data_dmat, ahd->qoutfifo,\n\t\t\t\tahd->shared_data_map.dmamap);\n\t\tahd_dmamap_destroy(ahd, ahd->shared_data_dmat,\n\t\t\t\t   ahd->shared_data_map.dmamap);\n\t\tfallthrough;\n\tcase 2:\n\t\tahd_dma_tag_destroy(ahd, ahd->shared_data_dmat);\n\t\tbreak;\n\tcase 1:\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\t}\n\n\tahd_platform_free(ahd);\n\tahd_fini_scbdata(ahd);\n\tfor (i = 0; i < AHD_NUM_TARGETS; i++) {\n\t\tstruct ahd_tmode_tstate *tstate;\n\n\t\ttstate = ahd->enabled_targets[i];\n\t\tif (tstate != NULL) {\n#ifdef AHD_TARGET_MODE\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < AHD_NUM_LUNS; j++) {\n\t\t\t\tstruct ahd_tmode_lstate *lstate;\n\n\t\t\t\tlstate = tstate->enabled_luns[j];\n\t\t\t\tif (lstate != NULL) {\n\t\t\t\t\txpt_free_path(lstate->path);\n\t\t\t\t\tkfree(lstate);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tkfree(tstate);\n\t\t}\n\t}\n#ifdef AHD_TARGET_MODE\n\tif (ahd->black_hole != NULL) {\n\t\txpt_free_path(ahd->black_hole->path);\n\t\tkfree(ahd->black_hole);\n\t}\n#endif\n\tkfree(ahd->name);\n\tkfree(ahd->seep_config);\n\tkfree(ahd->saved_stack);\n\tkfree(ahd);\n\treturn;\n}\n\nstatic void\nahd_shutdown(void *arg)\n{\n\tstruct\tahd_softc *ahd;\n\n\tahd = (struct ahd_softc *)arg;\n\n\t \n\tdel_timer_sync(&ahd->stat_timer);\n\n\t \n\tahd_reset(ahd,  FALSE);\n}\n\n \nint\nahd_reset(struct ahd_softc *ahd, int reinit)\n{\n\tu_int\t sxfrctl1;\n\tint\t wait;\n\tuint32_t cmd;\n\n\t \n\tahd_pause(ahd);\n\tahd_update_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\tsxfrctl1 = ahd_inb(ahd, SXFRCTL1);\n\n\tcmd = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND,  2);\n\tif ((ahd->bugs & AHD_PCIX_CHIPRST_BUG) != 0) {\n\t\tuint32_t mod_cmd;\n\n\t\t \n\t\tmod_cmd = cmd & ~(PCIM_CMD_PERRESPEN|PCIM_CMD_SERRESPEN);\n\t\tahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,\n\t\t\t\t     mod_cmd,  2);\n\t}\n\tahd_outb(ahd, HCNTRL, CHIPRST | ahd->pause);\n\n\t \n\twait = 1000;\n\tdo {\n\t\tahd_delay(1000);\n\t} while (--wait && !(ahd_inb(ahd, HCNTRL) & CHIPRSTACK));\n\n\tif (wait == 0) {\n\t\tprintk(\"%s: WARNING - Failed chip reset!  \"\n\t\t       \"Trying to initialize anyway.\\n\", ahd_name(ahd));\n\t}\n\tahd_outb(ahd, HCNTRL, ahd->pause);\n\n\tif ((ahd->bugs & AHD_PCIX_CHIPRST_BUG) != 0) {\n\t\t \n\t\tahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,\n\t\t\t\t     0xFF,  1);\n\t\tahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,\n\t\t\t\t     cmd,  2);\n\t}\n\n\t \n\tahd_known_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\tahd_outb(ahd, MODE_PTR,\n\t\t ahd_build_mode_state(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI));\n\n\t \n\tahd_outb(ahd, SXFRCTL1, sxfrctl1|STPWEN);\n\tahd_outb(ahd, SXFRCTL1, sxfrctl1);\n\n\t \n\tahd->features &= ~AHD_WIDE;\n\tif ((ahd_inb(ahd, SBLKCTL) & SELWIDE) != 0)\n\t\tahd->features |= AHD_WIDE;\n\n\t \n\tif (reinit != 0)\n\t\tahd_chip_init(ahd);\n\n\treturn (0);\n}\n\n \nstatic int\nahd_probe_scbs(struct ahd_softc *ahd) {\n\tint i;\n\n\tAHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),\n\t\t\t ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));\n\tfor (i = 0; i < AHD_SCB_MAX; i++) {\n\t\tint j;\n\n\t\tahd_set_scbptr(ahd, i);\n\t\tahd_outw(ahd, SCB_BASE, i);\n\t\tfor (j = 2; j < 64; j++)\n\t\t\tahd_outb(ahd, SCB_BASE+j, 0);\n\t\t \n\t\tahd_outb(ahd, SCB_CONTROL, MK_MESSAGE);\n\t\tif (ahd_inw_scbram(ahd, SCB_BASE) != i)\n\t\t\tbreak;\n\t\tahd_set_scbptr(ahd, 0);\n\t\tif (ahd_inw_scbram(ahd, SCB_BASE) != 0)\n\t\t\tbreak;\n\t}\n\treturn (i);\n}\n\nstatic void\nahd_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error) \n{\n\tdma_addr_t *baddr;\n\n\tbaddr = (dma_addr_t *)arg;\n\t*baddr = segs->ds_addr;\n}\n\nstatic void\nahd_initialize_hscbs(struct ahd_softc *ahd)\n{\n\tint i;\n\n\tfor (i = 0; i < ahd->scb_data.maxhscbs; i++) {\n\t\tahd_set_scbptr(ahd, i);\n\n\t\t \n\t\tahd_outb(ahd, SCB_CONTROL, 0);\n\n\t\t \n\t\tahd_outw(ahd, SCB_NEXT, SCB_LIST_NULL);\n\t}\n}\n\nstatic int\nahd_init_scbdata(struct ahd_softc *ahd)\n{\n\tstruct\tscb_data *scb_data;\n\tint\ti;\n\n\tscb_data = &ahd->scb_data;\n\tTAILQ_INIT(&scb_data->free_scbs);\n\tfor (i = 0; i < AHD_NUM_TARGETS * AHD_NUM_LUNS_NONPKT; i++)\n\t\tLIST_INIT(&scb_data->free_scb_lists[i]);\n\tLIST_INIT(&scb_data->any_dev_free_scb_list);\n\tSLIST_INIT(&scb_data->hscb_maps);\n\tSLIST_INIT(&scb_data->sg_maps);\n\tSLIST_INIT(&scb_data->sense_maps);\n\n\t \n\tscb_data->maxhscbs = ahd_probe_scbs(ahd);\n\tif (scb_data->maxhscbs == 0) {\n\t\tprintk(\"%s: No SCB space found\\n\", ahd_name(ahd));\n\t\treturn (ENXIO);\n\t}\n\n\tahd_initialize_hscbs(ahd);\n\n\t \n\n\t \n\tif (ahd_dma_tag_create(ahd, ahd->parent_dmat,  1,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT + 1,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT,\n\t\t\t        BUS_SPACE_MAXADDR,\n\t\t\t        NULL,  NULL,\n\t\t\t       PAGE_SIZE,  1,\n\t\t\t        BUS_SPACE_MAXSIZE_32BIT,\n\t\t\t        0, &scb_data->hscb_dmat) != 0) {\n\t\tgoto error_exit;\n\t}\n\n\tscb_data->init_level++;\n\n\t \n\tif (ahd_dma_tag_create(ahd, ahd->parent_dmat,  8,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT + 1,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT,\n\t\t\t        BUS_SPACE_MAXADDR,\n\t\t\t        NULL,  NULL,\n\t\t\t       ahd_sglist_allocsize(ahd),  1,\n\t\t\t        BUS_SPACE_MAXSIZE_32BIT,\n\t\t\t        0, &scb_data->sg_dmat) != 0) {\n\t\tgoto error_exit;\n\t}\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_MEMORY) != 0)\n\t\tprintk(\"%s: ahd_sglist_allocsize = 0x%x\\n\", ahd_name(ahd),\n\t\t       ahd_sglist_allocsize(ahd));\n#endif\n\n\tscb_data->init_level++;\n\n\t \n\tif (ahd_dma_tag_create(ahd, ahd->parent_dmat,  1,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT + 1,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT,\n\t\t\t        BUS_SPACE_MAXADDR,\n\t\t\t        NULL,  NULL,\n\t\t\t       PAGE_SIZE,  1,\n\t\t\t        BUS_SPACE_MAXSIZE_32BIT,\n\t\t\t        0, &scb_data->sense_dmat) != 0) {\n\t\tgoto error_exit;\n\t}\n\n\tscb_data->init_level++;\n\n\t \n\tahd_alloc_scbs(ahd);\n\n\tif (scb_data->numscbs == 0) {\n\t\tprintk(\"%s: ahd_init_scbdata - \"\n\t\t       \"Unable to allocate initial scbs\\n\",\n\t\t       ahd_name(ahd));\n\t\tgoto error_exit;\n\t}\n\n\t \n\treturn (0);\n\nerror_exit:\n\n\treturn (ENOMEM);\n}\n\nstatic struct scb *\nahd_find_scb_by_tag(struct ahd_softc *ahd, u_int tag)\n{\n\tstruct scb *scb;\n\n\t \n\tLIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {\n\t\tif (SCB_GET_TAG(scb) == tag)\n\t\t\treturn (scb);\n\t}\n\n\t \n\tTAILQ_FOREACH(scb, &ahd->scb_data.free_scbs, links.tqe) {\n\t\tstruct scb *list_scb;\n\n\t\tlist_scb = scb;\n\t\tdo {\n\t\t\tif (SCB_GET_TAG(list_scb) == tag)\n\t\t\t\treturn (list_scb);\n\t\t\tlist_scb = LIST_NEXT(list_scb, collision_links);\n\t\t} while (list_scb);\n\t}\n\n\t \n\tLIST_FOREACH(scb, &ahd->scb_data.any_dev_free_scb_list, links.le) {\n\t\tif (SCB_GET_TAG(scb) == tag)\n\t\t\treturn (scb);\n\t}\n\n\treturn (NULL);\n}\n\nstatic void\nahd_fini_scbdata(struct ahd_softc *ahd)\n{\n\tstruct scb_data *scb_data;\n\n\tscb_data = &ahd->scb_data;\n\tif (scb_data == NULL)\n\t\treturn;\n\n\tswitch (scb_data->init_level) {\n\tdefault:\n\tcase 7:\n\t{\n\t\tstruct map_node *sns_map;\n\n\t\twhile ((sns_map = SLIST_FIRST(&scb_data->sense_maps)) != NULL) {\n\t\t\tSLIST_REMOVE_HEAD(&scb_data->sense_maps, links);\n\t\t\tahd_dmamap_unload(ahd, scb_data->sense_dmat,\n\t\t\t\t\t  sns_map->dmamap);\n\t\t\tahd_dmamem_free(ahd, scb_data->sense_dmat,\n\t\t\t\t\tsns_map->vaddr, sns_map->dmamap);\n\t\t\tkfree(sns_map);\n\t\t}\n\t\tahd_dma_tag_destroy(ahd, scb_data->sense_dmat);\n\t}\n\t\tfallthrough;\n\tcase 6:\n\t{\n\t\tstruct map_node *sg_map;\n\n\t\twhile ((sg_map = SLIST_FIRST(&scb_data->sg_maps)) != NULL) {\n\t\t\tSLIST_REMOVE_HEAD(&scb_data->sg_maps, links);\n\t\t\tahd_dmamap_unload(ahd, scb_data->sg_dmat,\n\t\t\t\t\t  sg_map->dmamap);\n\t\t\tahd_dmamem_free(ahd, scb_data->sg_dmat,\n\t\t\t\t\tsg_map->vaddr, sg_map->dmamap);\n\t\t\tkfree(sg_map);\n\t\t}\n\t\tahd_dma_tag_destroy(ahd, scb_data->sg_dmat);\n\t}\n\t\tfallthrough;\n\tcase 5:\n\t{\n\t\tstruct map_node *hscb_map;\n\n\t\twhile ((hscb_map = SLIST_FIRST(&scb_data->hscb_maps)) != NULL) {\n\t\t\tSLIST_REMOVE_HEAD(&scb_data->hscb_maps, links);\n\t\t\tahd_dmamap_unload(ahd, scb_data->hscb_dmat,\n\t\t\t\t\t  hscb_map->dmamap);\n\t\t\tahd_dmamem_free(ahd, scb_data->hscb_dmat,\n\t\t\t\t\thscb_map->vaddr, hscb_map->dmamap);\n\t\t\tkfree(hscb_map);\n\t\t}\n\t\tahd_dma_tag_destroy(ahd, scb_data->hscb_dmat);\n\t}\n\t\tfallthrough;\n\tcase 4:\n\tcase 3:\n\tcase 2:\n\tcase 1:\n\tcase 0:\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nahd_setup_iocell_workaround(struct ahd_softc *ahd)\n{\n\tahd_mode_state saved_modes;\n\n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\n\tahd_outb(ahd, DSPDATACTL, ahd_inb(ahd, DSPDATACTL)\n\t       | BYPASSENAB | RCVROFFSTDIS | XMITOFFSTDIS);\n\tahd_outb(ahd, SIMODE0, ahd_inb(ahd, SIMODE0) | (ENSELDO|ENSELDI));\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_MISC) != 0)\n\t\tprintk(\"%s: Setting up iocell workaround\\n\", ahd_name(ahd));\n#endif\n\tahd_restore_modes(ahd, saved_modes);\n\tahd->flags &= ~AHD_HAD_FIRST_SEL;\n}\n\nstatic void\nahd_iocell_first_selection(struct ahd_softc *ahd)\n{\n\tahd_mode_state\tsaved_modes;\n\tu_int\t\tsblkctl;\n\n\tif ((ahd->flags & AHD_HAD_FIRST_SEL) != 0)\n\t\treturn;\n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\tsblkctl = ahd_inb(ahd, SBLKCTL);\n\tahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_MISC) != 0)\n\t\tprintk(\"%s: iocell first selection\\n\", ahd_name(ahd));\n#endif\n\tif ((sblkctl & ENAB40) != 0) {\n\t\tahd_outb(ahd, DSPDATACTL,\n\t\t\t ahd_inb(ahd, DSPDATACTL) & ~BYPASSENAB);\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_MISC) != 0)\n\t\t\tprintk(\"%s: BYPASS now disabled\\n\", ahd_name(ahd));\n#endif\n\t}\n\tahd_outb(ahd, SIMODE0, ahd_inb(ahd, SIMODE0) & ~(ENSELDO|ENSELDI));\n\tahd_outb(ahd, CLRINT, CLRSCSIINT);\n\tahd_restore_modes(ahd, saved_modes);\n\tahd->flags |= AHD_HAD_FIRST_SEL;\n}\n\n \nstatic void\nahd_add_col_list(struct ahd_softc *ahd, struct scb *scb, u_int col_idx)\n{\n\tstruct\tscb_list *free_list;\n\tstruct\tscb_tailq *free_tailq;\n\tstruct\tscb *first_scb;\n\n\tscb->flags |= SCB_ON_COL_LIST;\n\tAHD_SET_SCB_COL_IDX(scb, col_idx);\n\tfree_list = &ahd->scb_data.free_scb_lists[col_idx];\n\tfree_tailq = &ahd->scb_data.free_scbs;\n\tfirst_scb = LIST_FIRST(free_list);\n\tif (first_scb != NULL) {\n\t\tLIST_INSERT_AFTER(first_scb, scb, collision_links);\n\t} else {\n\t\tLIST_INSERT_HEAD(free_list, scb, collision_links);\n\t\tTAILQ_INSERT_TAIL(free_tailq, scb, links.tqe);\n\t}\n}\n\nstatic void\nahd_rem_col_list(struct ahd_softc *ahd, struct scb *scb)\n{\n\tstruct\tscb_list *free_list;\n\tstruct\tscb_tailq *free_tailq;\n\tstruct\tscb *first_scb;\n\tu_int\tcol_idx;\n\n\tscb->flags &= ~SCB_ON_COL_LIST;\n\tcol_idx = AHD_GET_SCB_COL_IDX(ahd, scb);\n\tfree_list = &ahd->scb_data.free_scb_lists[col_idx];\n\tfree_tailq = &ahd->scb_data.free_scbs;\n\tfirst_scb = LIST_FIRST(free_list);\n\tif (first_scb == scb) {\n\t\tstruct scb *next_scb;\n\n\t\t \n\t\tnext_scb = LIST_NEXT(scb, collision_links);\n\t\tif (next_scb != NULL) {\n\t\t\tTAILQ_INSERT_AFTER(free_tailq, scb,\n\t\t\t\t\t   next_scb, links.tqe);\n\t\t}\n\t\tTAILQ_REMOVE(free_tailq, scb, links.tqe);\n\t}\n\tLIST_REMOVE(scb, collision_links);\n}\n\n \nstruct scb *\nahd_get_scb(struct ahd_softc *ahd, u_int col_idx)\n{\n\tstruct scb *scb;\n\tint tries;\n\n\ttries = 0;\nlook_again:\n\tTAILQ_FOREACH(scb, &ahd->scb_data.free_scbs, links.tqe) {\n\t\tif (AHD_GET_SCB_COL_IDX(ahd, scb) != col_idx) {\n\t\t\tahd_rem_col_list(ahd, scb);\n\t\t\tgoto found;\n\t\t}\n\t}\n\tif ((scb = LIST_FIRST(&ahd->scb_data.any_dev_free_scb_list)) == NULL) {\n\n\t\tif (tries++ != 0)\n\t\t\treturn (NULL);\n\t\tahd_alloc_scbs(ahd);\n\t\tgoto look_again;\n\t}\n\tLIST_REMOVE(scb, links.le);\n\tif (col_idx != AHD_NEVER_COL_IDX\n\t && (scb->col_scb != NULL)\n\t && (scb->col_scb->flags & SCB_ACTIVE) == 0) {\n\t\tLIST_REMOVE(scb->col_scb, links.le);\n\t\tahd_add_col_list(ahd, scb->col_scb, col_idx);\n\t}\nfound:\n\tscb->flags |= SCB_ACTIVE;\n\treturn (scb);\n}\n\n \nvoid\nahd_free_scb(struct ahd_softc *ahd, struct scb *scb)\n{\n\t \n\tscb->flags = SCB_FLAG_NONE;\n\tscb->hscb->control = 0;\n\tahd->scb_data.scbindex[SCB_GET_TAG(scb)] = NULL;\n\n\tif (scb->col_scb == NULL) {\n\n\t\t \n\t\tLIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,\n\t\t\t\t scb, links.le);\n\t} else if ((scb->col_scb->flags & SCB_ON_COL_LIST) != 0) {\n\n\t\t \n\t\tahd_rem_col_list(ahd, scb->col_scb);\n\t\tLIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,\n\t\t\t\t scb, links.le);\n\t\tLIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,\n\t\t\t\t scb->col_scb, links.le);\n\t} else if ((scb->col_scb->flags\n\t\t  & (SCB_PACKETIZED|SCB_ACTIVE)) == SCB_ACTIVE\n\t\t&& (scb->col_scb->hscb->control & TAG_ENB) != 0) {\n\n\t\t \n\t\tahd_add_col_list(ahd, scb,\n\t\t\t\t AHD_GET_SCB_COL_IDX(ahd, scb->col_scb));\n\t} else {\n\t\t \n\t\tLIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,\n\t\t\t\t scb, links.le);\n\t}\n\n\tahd_platform_scb_free(ahd, scb);\n}\n\nstatic void\nahd_alloc_scbs(struct ahd_softc *ahd)\n{\n\tstruct scb_data *scb_data;\n\tstruct scb\t*next_scb;\n\tstruct hardware_scb *hscb;\n\tstruct map_node *hscb_map;\n\tstruct map_node *sg_map;\n\tstruct map_node *sense_map;\n\tuint8_t\t\t*segs;\n\tuint8_t\t\t*sense_data;\n\tdma_addr_t\t hscb_busaddr;\n\tdma_addr_t\t sg_busaddr;\n\tdma_addr_t\t sense_busaddr;\n\tint\t\t newcount;\n\tint\t\t i;\n\n\tscb_data = &ahd->scb_data;\n\tif (scb_data->numscbs >= AHD_SCB_MAX_ALLOC)\n\t\t \n\t\treturn;\n\n\tif (scb_data->scbs_left != 0) {\n\t\tint offset;\n\n\t\toffset = (PAGE_SIZE / sizeof(*hscb)) - scb_data->scbs_left;\n\t\thscb_map = SLIST_FIRST(&scb_data->hscb_maps);\n\t\thscb = &((struct hardware_scb *)hscb_map->vaddr)[offset];\n\t\thscb_busaddr = hscb_map->physaddr + (offset * sizeof(*hscb));\n\t} else {\n\t\thscb_map = kmalloc(sizeof(*hscb_map), GFP_ATOMIC);\n\n\t\tif (hscb_map == NULL)\n\t\t\treturn;\n\n\t\t \n\t\tif (ahd_dmamem_alloc(ahd, scb_data->hscb_dmat,\n\t\t\t\t     (void **)&hscb_map->vaddr,\n\t\t\t\t     BUS_DMA_NOWAIT, &hscb_map->dmamap) != 0) {\n\t\t\tkfree(hscb_map);\n\t\t\treturn;\n\t\t}\n\n\t\tSLIST_INSERT_HEAD(&scb_data->hscb_maps, hscb_map, links);\n\n\t\tahd_dmamap_load(ahd, scb_data->hscb_dmat, hscb_map->dmamap,\n\t\t\t\thscb_map->vaddr, PAGE_SIZE, ahd_dmamap_cb,\n\t\t\t\t&hscb_map->physaddr,  0);\n\n\t\thscb = (struct hardware_scb *)hscb_map->vaddr;\n\t\thscb_busaddr = hscb_map->physaddr;\n\t\tscb_data->scbs_left = PAGE_SIZE / sizeof(*hscb);\n\t}\n\n\tif (scb_data->sgs_left != 0) {\n\t\tint offset;\n\n\t\toffset = ((ahd_sglist_allocsize(ahd) / ahd_sglist_size(ahd))\n\t\t       - scb_data->sgs_left) * ahd_sglist_size(ahd);\n\t\tsg_map = SLIST_FIRST(&scb_data->sg_maps);\n\t\tsegs = sg_map->vaddr + offset;\n\t\tsg_busaddr = sg_map->physaddr + offset;\n\t} else {\n\t\tsg_map = kmalloc(sizeof(*sg_map), GFP_ATOMIC);\n\n\t\tif (sg_map == NULL)\n\t\t\treturn;\n\n\t\t \n\t\tif (ahd_dmamem_alloc(ahd, scb_data->sg_dmat,\n\t\t\t\t     (void **)&sg_map->vaddr,\n\t\t\t\t     BUS_DMA_NOWAIT, &sg_map->dmamap) != 0) {\n\t\t\tkfree(sg_map);\n\t\t\treturn;\n\t\t}\n\n\t\tSLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);\n\n\t\tahd_dmamap_load(ahd, scb_data->sg_dmat, sg_map->dmamap,\n\t\t\t\tsg_map->vaddr, ahd_sglist_allocsize(ahd),\n\t\t\t\tahd_dmamap_cb, &sg_map->physaddr,  0);\n\n\t\tsegs = sg_map->vaddr;\n\t\tsg_busaddr = sg_map->physaddr;\n\t\tscb_data->sgs_left =\n\t\t    ahd_sglist_allocsize(ahd) / ahd_sglist_size(ahd);\n#ifdef AHD_DEBUG\n\t\tif (ahd_debug & AHD_SHOW_MEMORY)\n\t\t\tprintk(\"Mapped SG data\\n\");\n#endif\n\t}\n\n\tif (scb_data->sense_left != 0) {\n\t\tint offset;\n\n\t\toffset = PAGE_SIZE - (AHD_SENSE_BUFSIZE * scb_data->sense_left);\n\t\tsense_map = SLIST_FIRST(&scb_data->sense_maps);\n\t\tsense_data = sense_map->vaddr + offset;\n\t\tsense_busaddr = sense_map->physaddr + offset;\n\t} else {\n\t\tsense_map = kmalloc(sizeof(*sense_map), GFP_ATOMIC);\n\n\t\tif (sense_map == NULL)\n\t\t\treturn;\n\n\t\t \n\t\tif (ahd_dmamem_alloc(ahd, scb_data->sense_dmat,\n\t\t\t\t     (void **)&sense_map->vaddr,\n\t\t\t\t     BUS_DMA_NOWAIT, &sense_map->dmamap) != 0) {\n\t\t\tkfree(sense_map);\n\t\t\treturn;\n\t\t}\n\n\t\tSLIST_INSERT_HEAD(&scb_data->sense_maps, sense_map, links);\n\n\t\tahd_dmamap_load(ahd, scb_data->sense_dmat, sense_map->dmamap,\n\t\t\t\tsense_map->vaddr, PAGE_SIZE, ahd_dmamap_cb,\n\t\t\t\t&sense_map->physaddr,  0);\n\n\t\tsense_data = sense_map->vaddr;\n\t\tsense_busaddr = sense_map->physaddr;\n\t\tscb_data->sense_left = PAGE_SIZE / AHD_SENSE_BUFSIZE;\n#ifdef AHD_DEBUG\n\t\tif (ahd_debug & AHD_SHOW_MEMORY)\n\t\t\tprintk(\"Mapped sense data\\n\");\n#endif\n\t}\n\n\tnewcount = min(scb_data->sense_left, scb_data->scbs_left);\n\tnewcount = min(newcount, scb_data->sgs_left);\n\tnewcount = min(newcount, (AHD_SCB_MAX_ALLOC - scb_data->numscbs));\n\tfor (i = 0; i < newcount; i++) {\n\t\tstruct scb_platform_data *pdata;\n\t\tu_int col_tag;\n\n\t\tnext_scb = kmalloc(sizeof(*next_scb), GFP_ATOMIC);\n\t\tif (next_scb == NULL)\n\t\t\tbreak;\n\n\t\tpdata = kmalloc(sizeof(*pdata), GFP_ATOMIC);\n\t\tif (pdata == NULL) {\n\t\t\tkfree(next_scb);\n\t\t\tbreak;\n\t\t}\n\t\tnext_scb->platform_data = pdata;\n\t\tnext_scb->hscb_map = hscb_map;\n\t\tnext_scb->sg_map = sg_map;\n\t\tnext_scb->sense_map = sense_map;\n\t\tnext_scb->sg_list = segs;\n\t\tnext_scb->sense_data = sense_data;\n\t\tnext_scb->sense_busaddr = sense_busaddr;\n\t\tmemset(hscb, 0, sizeof(*hscb));\n\t\tnext_scb->hscb = hscb;\n\t\thscb->hscb_busaddr = ahd_htole32(hscb_busaddr);\n\n\t\t \n\t\tnext_scb->sg_list_busaddr = sg_busaddr;\n\t\tif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)\n\t\t\tnext_scb->sg_list_busaddr\n\t\t\t    += sizeof(struct ahd_dma64_seg);\n\t\telse\n\t\t\tnext_scb->sg_list_busaddr += sizeof(struct ahd_dma_seg);\n\t\tnext_scb->ahd_softc = ahd;\n\t\tnext_scb->flags = SCB_FLAG_NONE;\n\t\tnext_scb->hscb->tag = ahd_htole16(scb_data->numscbs);\n\t\tcol_tag = scb_data->numscbs ^ 0x100;\n\t\tnext_scb->col_scb = ahd_find_scb_by_tag(ahd, col_tag);\n\t\tif (next_scb->col_scb != NULL)\n\t\t\tnext_scb->col_scb->col_scb = next_scb;\n\t\tahd_free_scb(ahd, next_scb);\n\t\thscb++;\n\t\thscb_busaddr += sizeof(*hscb);\n\t\tsegs += ahd_sglist_size(ahd);\n\t\tsg_busaddr += ahd_sglist_size(ahd);\n\t\tsense_data += AHD_SENSE_BUFSIZE;\n\t\tsense_busaddr += AHD_SENSE_BUFSIZE;\n\t\tscb_data->numscbs++;\n\t\tscb_data->sense_left--;\n\t\tscb_data->scbs_left--;\n\t\tscb_data->sgs_left--;\n\t}\n}\n\nvoid\nahd_controller_info(struct ahd_softc *ahd, char *buf)\n{\n\tconst char *speed;\n\tconst char *type;\n\tint len;\n\n\tlen = sprintf(buf, \"%s: \", ahd_chip_names[ahd->chip & AHD_CHIPID_MASK]);\n\tbuf += len;\n\n\tspeed = \"Ultra320 \";\n\tif ((ahd->features & AHD_WIDE) != 0) {\n\t\ttype = \"Wide \";\n\t} else {\n\t\ttype = \"Single \";\n\t}\n\tlen = sprintf(buf, \"%s%sChannel %c, SCSI Id=%d, \",\n\t\t      speed, type, ahd->channel, ahd->our_id);\n\tbuf += len;\n\n\tsprintf(buf, \"%s, %d SCBs\", ahd->bus_description,\n\t\tahd->scb_data.maxhscbs);\n}\n\nstatic const char *channel_strings[] = {\n\t\"Primary Low\",\n\t\"Primary High\",\n\t\"Secondary Low\",\n\t\"Secondary High\"\n};\n\nstatic const char *termstat_strings[] = {\n\t\"Terminated Correctly\",\n\t\"Over Terminated\",\n\t\"Under Terminated\",\n\t\"Not Configured\"\n};\n\n \nstatic void\nahd_timer_reset(struct timer_list *timer, int usec)\n{\n\tdel_timer(timer);\n\ttimer->expires = jiffies + (usec * HZ)/1000000;\n\tadd_timer(timer);\n}\n\n \nint\nahd_init(struct ahd_softc *ahd)\n{\n\tuint8_t\t\t*next_vaddr;\n\tdma_addr_t\t next_baddr;\n\tsize_t\t\t driver_data_size;\n\tint\t\t i;\n\tint\t\t error;\n\tu_int\t\t warn_user;\n\tuint8_t\t\t current_sensing;\n\tuint8_t\t\t fstat;\n\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\n\n\tahd->stack_size = ahd_probe_stack_size(ahd);\n\tahd->saved_stack = kmalloc_array(ahd->stack_size, sizeof(uint16_t),\n\t\t\t\t\t GFP_ATOMIC);\n\tif (ahd->saved_stack == NULL)\n\t\treturn (ENOMEM);\n\n\t \n\tif (sizeof(struct hardware_scb) != 64)\n\t\tpanic(\"Hardware SCB size is incorrect\");\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_DEBUG_SEQUENCER) != 0)\n\t\tahd->flags |= AHD_SEQUENCER_DEBUG;\n#endif\n\n\t \n\tahd->flags |= AHD_INITIATORROLE;\n\n\t \n\tif ((AHD_TMODE_ENABLE & (0x1 << ahd->unit)) == 0)\n\t\tahd->features &= ~AHD_TARGETMODE;\n\n\tahd->init_level++;\n\n\t \n\tdriver_data_size = AHD_SCB_MAX * sizeof(*ahd->qoutfifo)\n\t\t\t + sizeof(struct hardware_scb);\n\tif ((ahd->features & AHD_TARGETMODE) != 0)\n\t\tdriver_data_size += AHD_TMODE_CMDS * sizeof(struct target_cmd);\n\tif ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0)\n\t\tdriver_data_size += PKT_OVERRUN_BUFSIZE;\n\tif (ahd_dma_tag_create(ahd, ahd->parent_dmat,  1,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT + 1,\n\t\t\t        BUS_SPACE_MAXADDR_32BIT,\n\t\t\t        BUS_SPACE_MAXADDR,\n\t\t\t        NULL,  NULL,\n\t\t\t       driver_data_size,\n\t\t\t        1,\n\t\t\t        BUS_SPACE_MAXSIZE_32BIT,\n\t\t\t        0, &ahd->shared_data_dmat) != 0) {\n\t\treturn (ENOMEM);\n\t}\n\n\tahd->init_level++;\n\n\t \n\tif (ahd_dmamem_alloc(ahd, ahd->shared_data_dmat,\n\t\t\t     (void **)&ahd->shared_data_map.vaddr,\n\t\t\t     BUS_DMA_NOWAIT,\n\t\t\t     &ahd->shared_data_map.dmamap) != 0) {\n\t\treturn (ENOMEM);\n\t}\n\n\tahd->init_level++;\n\n\t \n\tahd_dmamap_load(ahd, ahd->shared_data_dmat, ahd->shared_data_map.dmamap,\n\t\t\tahd->shared_data_map.vaddr, driver_data_size,\n\t\t\tahd_dmamap_cb, &ahd->shared_data_map.physaddr,\n\t\t\t 0);\n\tahd->qoutfifo = (struct ahd_completion *)ahd->shared_data_map.vaddr;\n\tnext_vaddr = (uint8_t *)&ahd->qoutfifo[AHD_QOUT_SIZE];\n\tnext_baddr = ahd->shared_data_map.physaddr\n\t\t   + AHD_QOUT_SIZE*sizeof(struct ahd_completion);\n\tif ((ahd->features & AHD_TARGETMODE) != 0) {\n\t\tahd->targetcmds = (struct target_cmd *)next_vaddr;\n\t\tnext_vaddr += AHD_TMODE_CMDS * sizeof(struct target_cmd);\n\t\tnext_baddr += AHD_TMODE_CMDS * sizeof(struct target_cmd);\n\t}\n\n\tif ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0) {\n\t\tahd->overrun_buf = next_vaddr;\n\t\tnext_vaddr += PKT_OVERRUN_BUFSIZE;\n\t\tnext_baddr += PKT_OVERRUN_BUFSIZE;\n\t}\n\n\t \n\tahd->next_queued_hscb = (struct hardware_scb *)next_vaddr;\n\tahd->next_queued_hscb_map = &ahd->shared_data_map;\n\tahd->next_queued_hscb->hscb_busaddr = ahd_htole32(next_baddr);\n\n\tahd->init_level++;\n\n\t \n\tif (ahd_init_scbdata(ahd) != 0)\n\t\treturn (ENOMEM);\n\n\tif ((ahd->flags & AHD_INITIATORROLE) == 0)\n\t\tahd->flags &= ~AHD_RESET_BUS_A;\n\n\t \n\tahd_platform_init(ahd);\n\n\t \n\tahd_chip_init(ahd);\n\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\n\n\tif ((ahd->flags & AHD_CURRENT_SENSING) == 0)\n\t\tgoto init_done;\n\n\t \n\terror = ahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL,\n\t\t\t\t   CURSENSE_ENB);\n\tif (error != 0) {\n\t\tprintk(\"%s: current sensing timeout 1\\n\", ahd_name(ahd));\n\t\tgoto init_done;\n\t}\n\tfor (i = 20, fstat = FLX_FSTAT_BUSY;\n\t     (fstat & FLX_FSTAT_BUSY) != 0 && i; i--) {\n\t\terror = ahd_read_flexport(ahd, FLXADDR_FLEXSTAT, &fstat);\n\t\tif (error != 0) {\n\t\t\tprintk(\"%s: current sensing timeout 2\\n\",\n\t\t\t       ahd_name(ahd));\n\t\t\tgoto init_done;\n\t\t}\n\t}\n\tif (i == 0) {\n\t\tprintk(\"%s: Timedout during current-sensing test\\n\",\n\t\t       ahd_name(ahd));\n\t\tgoto init_done;\n\t}\n\n\t \n\terror = ahd_read_flexport(ahd, FLXADDR_CURRENT_STAT, &current_sensing);\n\tif (error != 0) {\n\t\tprintk(\"%s: current sensing timeout 3\\n\", ahd_name(ahd));\n\t\tgoto init_done;\n\t}\n\n\t \n\tahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, 0);\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_TERMCTL) != 0) {\n\t\tprintk(\"%s: current_sensing == 0x%x\\n\",\n\t\t       ahd_name(ahd), current_sensing);\n\t}\n#endif\n\twarn_user = 0;\n\tfor (i = 0; i < 4; i++, current_sensing >>= FLX_CSTAT_SHIFT) {\n\t\tu_int term_stat;\n\n\t\tterm_stat = (current_sensing & FLX_CSTAT_MASK);\n\t\tswitch (term_stat) {\n\t\tcase FLX_CSTAT_OVER:\n\t\tcase FLX_CSTAT_UNDER:\n\t\t\twarn_user++;\n\t\t\tfallthrough;\n\t\tcase FLX_CSTAT_INVALID:\n\t\tcase FLX_CSTAT_OKAY:\n\t\t\tif (warn_user == 0 && bootverbose == 0)\n\t\t\t\tbreak;\n\t\t\tprintk(\"%s: %s Channel %s\\n\", ahd_name(ahd),\n\t\t\t       channel_strings[i], termstat_strings[term_stat]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (warn_user) {\n\t\tprintk(\"%s: WARNING. Termination is not configured correctly.\\n\"\n\t\t       \"%s: WARNING. SCSI bus operations may FAIL.\\n\",\n\t\t       ahd_name(ahd), ahd_name(ahd));\n\t}\ninit_done:\n\tahd_restart(ahd);\n\tahd_timer_reset(&ahd->stat_timer, AHD_STAT_UPDATE_US);\n\treturn (0);\n}\n\n \nstatic void\nahd_chip_init(struct ahd_softc *ahd)\n{\n\tuint32_t busaddr;\n\tu_int\t sxfrctl1;\n\tu_int\t scsiseq_template;\n\tu_int\t wait;\n\tu_int\t i;\n\tu_int\t target;\n\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\t \n\tahd_outb(ahd, SBLKCTL, ahd_inb(ahd, SBLKCTL) & ~(DIAGLEDEN|DIAGLEDON));\n\n\t \n\tahd->hs_mailbox = 0;\n\tahd_outb(ahd, HS_MAILBOX, 0);\n\n\t \n\tahd_outb(ahd, IOWNID, ahd->our_id);\n\tahd_outb(ahd, TOWNID, ahd->our_id);\n\tsxfrctl1 = (ahd->flags & AHD_TERM_ENB_A) != 0 ? STPWEN : 0;\n\tsxfrctl1 |= (ahd->flags & AHD_SPCHK_ENB_A) != 0 ? ENSPCHK : 0;\n\tif ((ahd->bugs & AHD_LONG_SETIMO_BUG)\n\t && (ahd->seltime != STIMESEL_MIN)) {\n\t\t \n\t\tsxfrctl1 |= ahd->seltime + STIMESEL_BUG_ADJ;\n\t} else {\n\t\tsxfrctl1 |= ahd->seltime;\n\t}\n\n\tahd_outb(ahd, SXFRCTL0, DFON);\n\tahd_outb(ahd, SXFRCTL1, sxfrctl1|ahd->seltime|ENSTIMER|ACTNEGEN);\n\tahd_outb(ahd, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\n\n\t \n\tfor (wait = 10000;\n\t     (ahd_inb(ahd, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;\n\t     wait--)\n\t\tahd_delay(100);\n\n\t \n\tahd_outb(ahd, CLRSINT1, CLRSCSIRSTI);\n\tahd_outb(ahd, CLRINT, CLRSCSIINT);\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tahd_set_modes(ahd, AHD_MODE_DFF0 + i, AHD_MODE_DFF0 + i);\n\t\tahd_outb(ahd, LONGJMP_ADDR + 1, INVALID_ADDR);\n\t\tahd_outb(ahd, SG_STATE, 0);\n\t\tahd_outb(ahd, CLRSEQINTSRC, 0xFF);\n\t\tahd_outb(ahd, SEQIMODE,\n\t\t\t ENSAVEPTRS|ENCFG4DATA|ENCFG4ISTAT\n\t\t\t|ENCFG4TSTAT|ENCFG4ICMD|ENCFG4TCMD);\n\t}\n\n\tahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\n\tahd_outb(ahd, DSCOMMAND0, ahd_inb(ahd, DSCOMMAND0)|MPARCKEN|CACHETHEN);\n\tahd_outb(ahd, DFF_THRSH, RD_DFTHRSH_75|WR_DFTHRSH_75);\n\tahd_outb(ahd, SIMODE0, ENIOERR|ENOVERRUN);\n\tahd_outb(ahd, SIMODE3, ENNTRAMPERR|ENOSRAMPERR);\n\tif ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0) {\n\t\tahd_outb(ahd, OPTIONMODE, AUTOACKEN|AUTO_MSGOUT_DE);\n\t} else {\n\t\tahd_outb(ahd, OPTIONMODE, AUTOACKEN|BUSFREEREV|AUTO_MSGOUT_DE);\n\t}\n\tahd_outb(ahd, SCSCHKN, CURRFIFODEF|WIDERESEN|SHVALIDSTDIS);\n\tif ((ahd->chip & AHD_BUS_MASK) == AHD_PCIX)\n\t\t \n\t\tahd_outb(ahd, PCIXCTL, ahd_inb(ahd, PCIXCTL) | SPLTSTADIS);\n\n\tif ((ahd->bugs & AHD_LQOOVERRUN_BUG) != 0)\n\t\tahd_outb(ahd, LQOSCSCTL, LQONOCHKOVER);\n\n\t \n\tif ((ahd->flags & AHD_HP_BOARD) != 0) {\n\t\tfor (i = 0; i < NUMDSPS; i++) {\n\t\t\tahd_outb(ahd, DSPSELECT, i);\n\t\t\tahd_outb(ahd, WRTBIASCTL, WRTBIASCTL_HP_DEFAULT);\n\t\t}\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_MISC) != 0)\n\t\t\tprintk(\"%s: WRTBIASCTL now 0x%x\\n\", ahd_name(ahd),\n\t\t\t       WRTBIASCTL_HP_DEFAULT);\n#endif\n\t}\n\tahd_setup_iocell_workaround(ahd);\n\n\t \n\tahd_outb(ahd, LQIMODE1, ENLQIPHASE_LQ|ENLQIPHASE_NLQ|ENLIQABORT\n\t\t\t      | ENLQICRCI_LQ|ENLQICRCI_NLQ|ENLQIBADLQI\n\t\t\t      | ENLQIOVERI_LQ|ENLQIOVERI_NLQ);\n\tahd_outb(ahd, LQOMODE0, ENLQOATNLQ|ENLQOATNPKT|ENLQOTCRC);\n\t \n\tahd_outb(ahd, LQOMODE1, ENLQOBUSFREE);\n\n\t \n\tahd_outw(ahd, INTVEC1_ADDR, ahd_resolve_seqaddr(ahd, LABEL_seq_isr));\n\tahd_outw(ahd, INTVEC2_ADDR, ahd_resolve_seqaddr(ahd, LABEL_timer_isr));\n\n\t \n\tif ((ahd->bugs & AHD_PKT_LUN_BUG) != 0) {\n\t\tahd_outb(ahd, LUNPTR, offsetof(struct hardware_scb,\n\t\t\t pkt_long_lun));\n\t} else {\n\t\tahd_outb(ahd, LUNPTR, offsetof(struct hardware_scb, lun));\n\t}\n\tahd_outb(ahd, CMDLENPTR, offsetof(struct hardware_scb, cdb_len));\n\tahd_outb(ahd, ATTRPTR, offsetof(struct hardware_scb, task_attribute));\n\tahd_outb(ahd, FLAGPTR, offsetof(struct hardware_scb, task_management));\n\tahd_outb(ahd, CMDPTR, offsetof(struct hardware_scb,\n\t\t\t\t       shared_data.idata.cdb));\n\tahd_outb(ahd, QNEXTPTR,\n\t\t offsetof(struct hardware_scb, next_hscb_busaddr));\n\tahd_outb(ahd, ABRTBITPTR, MK_MESSAGE_BIT_OFFSET);\n\tahd_outb(ahd, ABRTBYTEPTR, offsetof(struct hardware_scb, control));\n\tif ((ahd->bugs & AHD_PKT_LUN_BUG) != 0) {\n\t\tahd_outb(ahd, LUNLEN,\n\t\t\t sizeof(ahd->next_queued_hscb->pkt_long_lun) - 1);\n\t} else {\n\t\tahd_outb(ahd, LUNLEN, LUNLEN_SINGLE_LEVEL_LUN);\n\t}\n\tahd_outb(ahd, CDBLIMIT, SCB_CDB_LEN_PTR - 1);\n\tahd_outb(ahd, MAXCMD, 0xFF);\n\tahd_outb(ahd, SCBAUTOPTR,\n\t\t AUSCBPTR_EN | offsetof(struct hardware_scb, tag));\n\n\t \n\tahd_outb(ahd, MULTARGID, 0);\n\tahd_outb(ahd, MULTARGID + 1, 0);\n\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\t \n\tif ((ahd->features & AHD_NEW_IOCELL_OPTS) == 0) {\n\t\t \n\t\tfor (target = 0; target < AHD_NUM_TARGETS; target++) {\n\t\t\tahd_outb(ahd, NEGOADDR, target);\n\t\t\tahd_outb(ahd, ANNEXCOL, AHD_ANNEXCOL_PER_DEV0);\n\t\t\tfor (i = 0; i < AHD_NUM_PER_DEV_ANNEXCOLS; i++)\n\t\t\t\tahd_outb(ahd, ANNEXDAT, 0);\n\t\t}\n\t}\n\tfor (target = 0; target < AHD_NUM_TARGETS; target++) {\n\t\tstruct\t ahd_devinfo devinfo;\n\t\tstruct\t ahd_initiator_tinfo *tinfo;\n\t\tstruct\t ahd_tmode_tstate *tstate;\n\n\t\ttinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,\n\t\t\t\t\t    target, &tstate);\n\t\tahd_compile_devinfo(&devinfo, ahd->our_id,\n\t\t\t\t    target, CAM_LUN_WILDCARD,\n\t\t\t\t    'A', ROLE_INITIATOR);\n\t\tahd_update_neg_table(ahd, &devinfo, &tinfo->curr);\n\t}\n\n\tahd_outb(ahd, CLRSINT3, NTRAMPERR|OSRAMPERR);\n\tahd_outb(ahd, CLRINT, CLRSCSIINT);\n\n#ifdef NEEDS_MORE_TESTING\n\t \n\tif ((ahd->bugs & AHD_ABORT_LQI_BUG) == 0)\n\t\tahd_outb(ahd, LQCTL1, ABORTPENDING);\n\telse\n#endif\n\t\tahd_outb(ahd, LQCTL1, 0);\n\n\t \n\tahd->qoutfifonext = 0;\n\tahd->qoutfifonext_valid_tag = QOUTFIFO_ENTRY_VALID;\n\tahd_outb(ahd, QOUTFIFO_ENTRY_VALID_TAG, QOUTFIFO_ENTRY_VALID);\n\tfor (i = 0; i < AHD_QOUT_SIZE; i++)\n\t\tahd->qoutfifo[i].valid_tag = 0;\n\tahd_sync_qoutfifo(ahd, BUS_DMASYNC_PREREAD);\n\n\tahd->qinfifonext = 0;\n\tfor (i = 0; i < AHD_QIN_SIZE; i++)\n\t\tahd->qinfifo[i] = SCB_LIST_NULL;\n\n\tif ((ahd->features & AHD_TARGETMODE) != 0) {\n\t\t \n\t\tfor (i = 0; i < AHD_TMODE_CMDS; i++)\n\t\t\tahd->targetcmds[i].cmd_valid = 0;\n\t\tahd_sync_tqinfifo(ahd, BUS_DMASYNC_PREREAD);\n\t\tahd->tqinfifonext = 1;\n\t\tahd_outb(ahd, KERNEL_TQINPOS, ahd->tqinfifonext - 1);\n\t\tahd_outb(ahd, TQINPOS, ahd->tqinfifonext);\n\t}\n\n\t \n\tahd_outb(ahd, SEQ_FLAGS, 0);\n\tahd_outb(ahd, SEQ_FLAGS2, 0);\n\n\t \n\tahd_outw(ahd, WAITING_TID_HEAD, SCB_LIST_NULL);\n\tahd_outw(ahd, WAITING_TID_TAIL, SCB_LIST_NULL);\n\tahd_outw(ahd, MK_MESSAGE_SCB, SCB_LIST_NULL);\n\tahd_outw(ahd, MK_MESSAGE_SCSIID, 0xFF);\n\tfor (i = 0; i < AHD_NUM_TARGETS; i++)\n\t\tahd_outw(ahd, WAITING_SCB_TAILS + (2 * i), SCB_LIST_NULL);\n\n\t \n\tahd_outw(ahd, COMPLETE_SCB_HEAD, SCB_LIST_NULL);\n\tahd_outw(ahd, COMPLETE_SCB_DMAINPROG_HEAD, SCB_LIST_NULL);\n\tahd_outw(ahd, COMPLETE_DMA_SCB_HEAD, SCB_LIST_NULL);\n\tahd_outw(ahd, COMPLETE_DMA_SCB_TAIL, SCB_LIST_NULL);\n\tahd_outw(ahd, COMPLETE_ON_QFREEZE_HEAD, SCB_LIST_NULL);\n\n\t \n\tahd->qfreeze_cnt = 0;\n\tahd_outw(ahd, QFREEZE_COUNT, 0);\n\tahd_outw(ahd, KERNEL_QFREEZE_COUNT, 0);\n\n\t \n\tbusaddr = ahd->shared_data_map.physaddr;\n\tahd_outl(ahd, SHARED_DATA_ADDR, busaddr);\n\tahd_outl(ahd, QOUTFIFO_NEXT_ADDR, busaddr);\n\n\t \n\tscsiseq_template = ENAUTOATNP;\n\tif ((ahd->flags & AHD_INITIATORROLE) != 0)\n\t\tscsiseq_template |= ENRSELI;\n\tahd_outb(ahd, SCSISEQ_TEMPLATE, scsiseq_template);\n\n\t \n\tfor (target = 0; target < AHD_NUM_TARGETS; target++) {\n\t\tint lun;\n\n\t\tfor (lun = 0; lun < AHD_NUM_LUNS_NONPKT; lun++)\n\t\t\tahd_unbusy_tcl(ahd, BUILD_TCL_RAW(target, 'A', lun));\n\t}\n\n\t \n\tahd_outb(ahd, CMDSIZE_TABLE, 5);\n\tahd_outb(ahd, CMDSIZE_TABLE + 1, 9);\n\tahd_outb(ahd, CMDSIZE_TABLE + 2, 9);\n\tahd_outb(ahd, CMDSIZE_TABLE + 3, 0);\n\tahd_outb(ahd, CMDSIZE_TABLE + 4, 15);\n\tahd_outb(ahd, CMDSIZE_TABLE + 5, 11);\n\tahd_outb(ahd, CMDSIZE_TABLE + 6, 0);\n\tahd_outb(ahd, CMDSIZE_TABLE + 7, 0);\n\n\t \n\tahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);\n\tahd_outb(ahd, QOFF_CTLSTA, SCB_QSIZE_512);\n\tahd->qinfifonext = 0;\n\tahd_set_hnscb_qoff(ahd, ahd->qinfifonext);\n\tahd_set_hescb_qoff(ahd, 0);\n\tahd_set_snscb_qoff(ahd, 0);\n\tahd_set_sescb_qoff(ahd, 0);\n\tahd_set_sdscb_qoff(ahd, 0);\n\n\t \n\tbusaddr = ahd_le32toh(ahd->next_queued_hscb->hscb_busaddr);\n\tahd_outl(ahd, NEXT_QUEUED_SCB_ADDR, busaddr);\n\n\t \n\tahd_outw(ahd, INT_COALESCING_CMDCOUNT, 0);\n\tahd_outw(ahd, CMDS_PENDING, 0);\n\tahd_update_coalescing_values(ahd, ahd->int_coalescing_timer,\n\t\t\t\t     ahd->int_coalescing_maxcmds,\n\t\t\t\t     ahd->int_coalescing_mincmds);\n\tahd_enable_coalescing(ahd, FALSE);\n\n\tahd_loadseq(ahd);\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\n\tif (ahd->features & AHD_AIC79XXB_SLOWCRC) {\n\t\tu_int negodat3 = ahd_inb(ahd, NEGCONOPTS);\n\n\t\tnegodat3 |= ENSLOWCRC;\n\t\tahd_outb(ahd, NEGCONOPTS, negodat3);\n\t\tnegodat3 = ahd_inb(ahd, NEGCONOPTS);\n\t\tif (!(negodat3 & ENSLOWCRC))\n\t\t\tprintk(\"aic79xx: failed to set the SLOWCRC bit\\n\");\n\t\telse\n\t\t\tprintk(\"aic79xx: SLOWCRC bit set\\n\");\n\t}\n}\n\n \nint\nahd_default_config(struct ahd_softc *ahd)\n{\n\tint\ttarg;\n\n\tahd->our_id = 7;\n\n\t \n\tif (ahd_alloc_tstate(ahd, ahd->our_id, 'A') == NULL) {\n\t\tprintk(\"%s: unable to allocate ahd_tmode_tstate.  \"\n\t\t       \"Failing attach\\n\", ahd_name(ahd));\n\t\treturn (ENOMEM);\n\t}\n\n\tfor (targ = 0; targ < AHD_NUM_TARGETS; targ++) {\n\t\tstruct\t ahd_devinfo devinfo;\n\t\tstruct\t ahd_initiator_tinfo *tinfo;\n\t\tstruct\t ahd_tmode_tstate *tstate;\n\t\tuint16_t target_mask;\n\n\t\ttinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,\n\t\t\t\t\t    targ, &tstate);\n\t\t \n\t\ttinfo->user.protocol_version = 4;\n\t\ttinfo->user.transport_version = 4;\n\n\t\ttarget_mask = 0x01 << targ;\n\t\tahd->user_discenable |= target_mask;\n\t\ttstate->discenable |= target_mask;\n\t\tahd->user_tagenable |= target_mask;\n#ifdef AHD_FORCE_160\n\t\ttinfo->user.period = AHD_SYNCRATE_DT;\n#else\n\t\ttinfo->user.period = AHD_SYNCRATE_160;\n#endif\n\t\ttinfo->user.offset = MAX_OFFSET;\n\t\ttinfo->user.ppr_options = MSG_EXT_PPR_RD_STRM\n\t\t\t\t\t| MSG_EXT_PPR_WR_FLOW\n\t\t\t\t\t| MSG_EXT_PPR_HOLD_MCS\n\t\t\t\t\t| MSG_EXT_PPR_IU_REQ\n\t\t\t\t\t| MSG_EXT_PPR_QAS_REQ\n\t\t\t\t\t| MSG_EXT_PPR_DT_REQ;\n\t\tif ((ahd->features & AHD_RTI) != 0)\n\t\t\ttinfo->user.ppr_options |= MSG_EXT_PPR_RTI;\n\n\t\ttinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\n\n\t\t \n\t\ttinfo->goal.protocol_version = 2;\n\t\ttinfo->goal.transport_version = 2;\n\t\ttinfo->curr.protocol_version = 2;\n\t\ttinfo->curr.transport_version = 2;\n\t\tahd_compile_devinfo(&devinfo, ahd->our_id,\n\t\t\t\t    targ, CAM_LUN_WILDCARD,\n\t\t\t\t    'A', ROLE_INITIATOR);\n\t\ttstate->tagenable &= ~target_mask;\n\t\tahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t      AHD_TRANS_CUR|AHD_TRANS_GOAL,  TRUE);\n\t\tahd_set_syncrate(ahd, &devinfo,  0,  0,\n\t\t\t\t  0, AHD_TRANS_CUR|AHD_TRANS_GOAL,\n\t\t\t\t  TRUE);\n\t}\n\treturn (0);\n}\n\n \nint\nahd_parse_cfgdata(struct ahd_softc *ahd, struct seeprom_config *sc)\n{\n\tint targ;\n\tint max_targ;\n\n\tmax_targ = sc->max_targets & CFMAXTARG;\n\tahd->our_id = sc->brtime_id & CFSCSIID;\n\n\t \n\tif (ahd_alloc_tstate(ahd, ahd->our_id, 'A') == NULL) {\n\t\tprintk(\"%s: unable to allocate ahd_tmode_tstate.  \"\n\t\t       \"Failing attach\\n\", ahd_name(ahd));\n\t\treturn (ENOMEM);\n\t}\n\n\tfor (targ = 0; targ < max_targ; targ++) {\n\t\tstruct\t ahd_devinfo devinfo;\n\t\tstruct\t ahd_initiator_tinfo *tinfo;\n\t\tstruct\t ahd_transinfo *user_tinfo;\n\t\tstruct\t ahd_tmode_tstate *tstate;\n\t\tuint16_t target_mask;\n\n\t\ttinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,\n\t\t\t\t\t    targ, &tstate);\n\t\tuser_tinfo = &tinfo->user;\n\n\t\t \n\t\ttinfo->user.protocol_version = 4;\n\t\ttinfo->user.transport_version = 4;\n\n\t\ttarget_mask = 0x01 << targ;\n\t\tahd->user_discenable &= ~target_mask;\n\t\ttstate->discenable &= ~target_mask;\n\t\tahd->user_tagenable &= ~target_mask;\n\t\tif (sc->device_flags[targ] & CFDISC) {\n\t\t\ttstate->discenable |= target_mask;\n\t\t\tahd->user_discenable |= target_mask;\n\t\t\tahd->user_tagenable |= target_mask;\n\t\t} else {\n\t\t\t \n\t\t\tsc->device_flags[targ] &= ~CFPACKETIZED;\n\t\t}\n\n\t\tuser_tinfo->ppr_options = 0;\n\t\tuser_tinfo->period = (sc->device_flags[targ] & CFXFER);\n\t\tif (user_tinfo->period < CFXFER_ASYNC) {\n\t\t\tif (user_tinfo->period <= AHD_PERIOD_10MHz)\n\t\t\t\tuser_tinfo->ppr_options |= MSG_EXT_PPR_DT_REQ;\n\t\t\tuser_tinfo->offset = MAX_OFFSET;\n\t\t} else  {\n\t\t\tuser_tinfo->offset = 0;\n\t\t\tuser_tinfo->period = AHD_ASYNC_XFER_PERIOD;\n\t\t}\n#ifdef AHD_FORCE_160\n\t\tif (user_tinfo->period <= AHD_SYNCRATE_160)\n\t\t\tuser_tinfo->period = AHD_SYNCRATE_DT;\n#endif\n\n\t\tif ((sc->device_flags[targ] & CFPACKETIZED) != 0) {\n\t\t\tuser_tinfo->ppr_options |= MSG_EXT_PPR_RD_STRM\n\t\t\t\t\t\t|  MSG_EXT_PPR_WR_FLOW\n\t\t\t\t\t\t|  MSG_EXT_PPR_HOLD_MCS\n\t\t\t\t\t\t|  MSG_EXT_PPR_IU_REQ;\n\t\t\tif ((ahd->features & AHD_RTI) != 0)\n\t\t\t\tuser_tinfo->ppr_options |= MSG_EXT_PPR_RTI;\n\t\t}\n\n\t\tif ((sc->device_flags[targ] & CFQAS) != 0)\n\t\t\tuser_tinfo->ppr_options |= MSG_EXT_PPR_QAS_REQ;\n\n\t\tif ((sc->device_flags[targ] & CFWIDEB) != 0)\n\t\t\tuser_tinfo->width = MSG_EXT_WDTR_BUS_16_BIT;\n\t\telse\n\t\t\tuser_tinfo->width = MSG_EXT_WDTR_BUS_8_BIT;\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_MISC) != 0)\n\t\t\tprintk(\"(%d): %x:%x:%x:%x\\n\", targ, user_tinfo->width,\n\t\t\t       user_tinfo->period, user_tinfo->offset,\n\t\t\t       user_tinfo->ppr_options);\n#endif\n\t\t \n\t\ttstate->tagenable &= ~target_mask;\n\t\ttinfo->goal.protocol_version = 2;\n\t\ttinfo->goal.transport_version = 2;\n\t\ttinfo->curr.protocol_version = 2;\n\t\ttinfo->curr.transport_version = 2;\n\t\tahd_compile_devinfo(&devinfo, ahd->our_id,\n\t\t\t\t    targ, CAM_LUN_WILDCARD,\n\t\t\t\t    'A', ROLE_INITIATOR);\n\t\tahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t      AHD_TRANS_CUR|AHD_TRANS_GOAL,  TRUE);\n\t\tahd_set_syncrate(ahd, &devinfo,  0,  0,\n\t\t\t\t  0, AHD_TRANS_CUR|AHD_TRANS_GOAL,\n\t\t\t\t  TRUE);\n\t}\n\n\tahd->flags &= ~AHD_SPCHK_ENB_A;\n\tif (sc->bios_control & CFSPARITY)\n\t\tahd->flags |= AHD_SPCHK_ENB_A;\n\n\tahd->flags &= ~AHD_RESET_BUS_A;\n\tif (sc->bios_control & CFRESETB)\n\t\tahd->flags |= AHD_RESET_BUS_A;\n\n\tahd->flags &= ~AHD_EXTENDED_TRANS_A;\n\tif (sc->bios_control & CFEXTEND)\n\t\tahd->flags |= AHD_EXTENDED_TRANS_A;\n\n\tahd->flags &= ~AHD_BIOS_ENABLED;\n\tif ((sc->bios_control & CFBIOSSTATE) == CFBS_ENABLED)\n\t\tahd->flags |= AHD_BIOS_ENABLED;\n\n\tahd->flags &= ~AHD_STPWLEVEL_A;\n\tif ((sc->adapter_control & CFSTPWLEVEL) != 0)\n\t\tahd->flags |= AHD_STPWLEVEL_A;\n\n\treturn (0);\n}\n\n \nint\nahd_parse_vpddata(struct ahd_softc *ahd, struct vpd_config *vpd)\n{\n\tint error;\n\n\terror = ahd_verify_vpd_cksum(vpd);\n\tif (error == 0)\n\t\treturn (EINVAL);\n\tif ((vpd->bios_flags & VPDBOOTHOST) != 0)\n\t\tahd->flags |= AHD_BOOT_CHANNEL;\n\treturn (0);\n}\n\nvoid\nahd_intr_enable(struct ahd_softc *ahd, int enable)\n{\n\tu_int hcntrl;\n\n\thcntrl = ahd_inb(ahd, HCNTRL);\n\thcntrl &= ~INTEN;\n\tahd->pause &= ~INTEN;\n\tahd->unpause &= ~INTEN;\n\tif (enable) {\n\t\thcntrl |= INTEN;\n\t\tahd->pause |= INTEN;\n\t\tahd->unpause |= INTEN;\n\t}\n\tahd_outb(ahd, HCNTRL, hcntrl);\n}\n\nstatic void\nahd_update_coalescing_values(struct ahd_softc *ahd, u_int timer, u_int maxcmds,\n\t\t\t     u_int mincmds)\n{\n\tif (timer > AHD_TIMER_MAX_US)\n\t\ttimer = AHD_TIMER_MAX_US;\n\tahd->int_coalescing_timer = timer;\n\n\tif (maxcmds > AHD_INT_COALESCING_MAXCMDS_MAX)\n\t\tmaxcmds = AHD_INT_COALESCING_MAXCMDS_MAX;\n\tif (mincmds > AHD_INT_COALESCING_MINCMDS_MAX)\n\t\tmincmds = AHD_INT_COALESCING_MINCMDS_MAX;\n\tahd->int_coalescing_maxcmds = maxcmds;\n\tahd_outw(ahd, INT_COALESCING_TIMER, timer / AHD_TIMER_US_PER_TICK);\n\tahd_outb(ahd, INT_COALESCING_MAXCMDS, -maxcmds);\n\tahd_outb(ahd, INT_COALESCING_MINCMDS, -mincmds);\n}\n\nstatic void\nahd_enable_coalescing(struct ahd_softc *ahd, int enable)\n{\n\n\tahd->hs_mailbox &= ~ENINT_COALESCE;\n\tif (enable)\n\t\tahd->hs_mailbox |= ENINT_COALESCE;\n\tahd_outb(ahd, HS_MAILBOX, ahd->hs_mailbox);\n\tahd_flush_device_writes(ahd);\n\tahd_run_qoutfifo(ahd);\n}\n\n \nvoid\nahd_pause_and_flushwork(struct ahd_softc *ahd)\n{\n\tu_int intstat;\n\tu_int maxloops;\n\n\tmaxloops = 1000;\n\tahd->flags |= AHD_ALL_INTERRUPTS;\n\tahd_pause(ahd);\n\t \n\tahd->qfreeze_cnt--;\n\tahd_outw(ahd, KERNEL_QFREEZE_COUNT, ahd->qfreeze_cnt);\n\tahd_outb(ahd, SEQ_FLAGS2, ahd_inb(ahd, SEQ_FLAGS2) | SELECTOUT_QFROZEN);\n\tdo {\n\n\t\tahd_unpause(ahd);\n\t\t \n\t\tahd_delay(500);\n\n\t\tahd_intr(ahd);\n\t\tahd_pause(ahd);\n\t\tintstat = ahd_inb(ahd, INTSTAT);\n\t\tif ((intstat & INT_PEND) == 0) {\n\t\t\tahd_clear_critical_section(ahd);\n\t\t\tintstat = ahd_inb(ahd, INTSTAT);\n\t\t}\n\t} while (--maxloops\n\t      && (intstat != 0xFF || (ahd->features & AHD_REMOVABLE) == 0)\n\t      && ((intstat & INT_PEND) != 0\n\t       || (ahd_inb(ahd, SCSISEQ0) & ENSELO) != 0\n\t       || (ahd_inb(ahd, SSTAT0) & (SELDO|SELINGO)) != 0));\n\n\tif (maxloops == 0) {\n\t\tprintk(\"Infinite interrupt loop, INTSTAT = %x\",\n\t\t      ahd_inb(ahd, INTSTAT));\n\t}\n\tahd->qfreeze_cnt++;\n\tahd_outw(ahd, KERNEL_QFREEZE_COUNT, ahd->qfreeze_cnt);\n\n\tahd_flush_qoutfifo(ahd);\n\n\tahd->flags &= ~AHD_ALL_INTERRUPTS;\n}\n\nint __maybe_unused\nahd_suspend(struct ahd_softc *ahd)\n{\n\tahd_pause_and_flushwork(ahd);\n\n\tif (LIST_FIRST(&ahd->pending_scbs) != NULL) {\n\t\tahd_unpause(ahd);\n\t\treturn (EBUSY);\n\t}\n\tahd_shutdown(ahd);\n\treturn (0);\n}\n\nvoid __maybe_unused\nahd_resume(struct ahd_softc *ahd)\n{\n\tahd_reset(ahd,  TRUE);\n\tahd_intr_enable(ahd, TRUE);\n\tahd_restart(ahd);\n}\n\n \n \nstatic inline u_int\nahd_index_busy_tcl(struct ahd_softc *ahd, u_int *saved_scbid, u_int tcl)\n{\n\t \n\tAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\n\t*saved_scbid = ahd_get_scbptr(ahd);\n\tahd_set_scbptr(ahd, TCL_LUN(tcl)\n\t\t     | ((TCL_TARGET_OFFSET(tcl) & 0xC) << 4));\n\n\t \n\treturn (((TCL_TARGET_OFFSET(tcl) & 0x3) << 1) + SCB_DISCONNECTED_LISTS);\n}\n\n \nstatic u_int\nahd_find_busy_tcl(struct ahd_softc *ahd, u_int tcl)\n{\n\tu_int scbid;\n\tu_int scb_offset;\n\tu_int saved_scbptr;\n\n\tscb_offset = ahd_index_busy_tcl(ahd, &saved_scbptr, tcl);\n\tscbid = ahd_inw_scbram(ahd, scb_offset);\n\tahd_set_scbptr(ahd, saved_scbptr);\n\treturn (scbid);\n}\n\nstatic void\nahd_busy_tcl(struct ahd_softc *ahd, u_int tcl, u_int scbid)\n{\n\tu_int scb_offset;\n\tu_int saved_scbptr;\n\n\tscb_offset = ahd_index_busy_tcl(ahd, &saved_scbptr, tcl);\n\tahd_outw(ahd, scb_offset, scbid);\n\tahd_set_scbptr(ahd, saved_scbptr);\n}\n\n \nstatic int\nahd_match_scb(struct ahd_softc *ahd, struct scb *scb, int target,\n\t      char channel, int lun, u_int tag, role_t role)\n{\n\tint targ = SCB_GET_TARGET(ahd, scb);\n\tchar chan = SCB_GET_CHANNEL(ahd, scb);\n\tint slun = SCB_GET_LUN(scb);\n\tint match;\n\n\tmatch = ((chan == channel) || (channel == ALL_CHANNELS));\n\tif (match != 0)\n\t\tmatch = ((targ == target) || (target == CAM_TARGET_WILDCARD));\n\tif (match != 0)\n\t\tmatch = ((lun == slun) || (lun == CAM_LUN_WILDCARD));\n\tif (match != 0) {\n#ifdef AHD_TARGET_MODE\n\t\tint group;\n\n\t\tgroup = XPT_FC_GROUP(scb->io_ctx->ccb_h.func_code);\n\t\tif (role == ROLE_INITIATOR) {\n\t\t\tmatch = (group != XPT_FC_GROUP_TMODE)\n\t\t\t      && ((tag == SCB_GET_TAG(scb))\n\t\t\t       || (tag == SCB_LIST_NULL));\n\t\t} else if (role == ROLE_TARGET) {\n\t\t\tmatch = (group == XPT_FC_GROUP_TMODE)\n\t\t\t      && ((tag == scb->io_ctx->csio.tag_id)\n\t\t\t       || (tag == SCB_LIST_NULL));\n\t\t}\n#else  \n\t\tmatch = ((tag == SCB_GET_TAG(scb)) || (tag == SCB_LIST_NULL));\n#endif  \n\t}\n\n\treturn match;\n}\n\nstatic void\nahd_freeze_devq(struct ahd_softc *ahd, struct scb *scb)\n{\n\tint\ttarget;\n\tchar\tchannel;\n\tint\tlun;\n\n\ttarget = SCB_GET_TARGET(ahd, scb);\n\tlun = SCB_GET_LUN(scb);\n\tchannel = SCB_GET_CHANNEL(ahd, scb);\n\n\tahd_search_qinfifo(ahd, target, channel, lun,\n\t\t\t    SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t   CAM_REQUEUE_REQ, SEARCH_COMPLETE);\n\n\tahd_platform_freeze_devq(ahd, scb);\n}\n\nvoid\nahd_qinfifo_requeue_tail(struct ahd_softc *ahd, struct scb *scb)\n{\n\tstruct scb\t*prev_scb;\n\tahd_mode_state\t saved_modes;\n\n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);\n\tprev_scb = NULL;\n\tif (ahd_qinfifo_count(ahd) != 0) {\n\t\tu_int prev_tag;\n\t\tu_int prev_pos;\n\n\t\tprev_pos = AHD_QIN_WRAP(ahd->qinfifonext - 1);\n\t\tprev_tag = ahd->qinfifo[prev_pos];\n\t\tprev_scb = ahd_lookup_scb(ahd, prev_tag);\n\t}\n\tahd_qinfifo_requeue(ahd, prev_scb, scb);\n\tahd_set_hnscb_qoff(ahd, ahd->qinfifonext);\n\tahd_restore_modes(ahd, saved_modes);\n}\n\nstatic void\nahd_qinfifo_requeue(struct ahd_softc *ahd, struct scb *prev_scb,\n\t\t    struct scb *scb)\n{\n\tif (prev_scb == NULL) {\n\t\tuint32_t busaddr;\n\n\t\tbusaddr = ahd_le32toh(scb->hscb->hscb_busaddr);\n\t\tahd_outl(ahd, NEXT_QUEUED_SCB_ADDR, busaddr);\n\t} else {\n\t\tprev_scb->hscb->next_hscb_busaddr = scb->hscb->hscb_busaddr;\n\t\tahd_sync_scb(ahd, prev_scb,\n\t\t\t     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\n\t}\n\tahd->qinfifo[AHD_QIN_WRAP(ahd->qinfifonext)] = SCB_GET_TAG(scb);\n\tahd->qinfifonext++;\n\tscb->hscb->next_hscb_busaddr = ahd->next_queued_hscb->hscb_busaddr;\n\tahd_sync_scb(ahd, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\n}\n\nstatic int\nahd_qinfifo_count(struct ahd_softc *ahd)\n{\n\tu_int qinpos;\n\tu_int wrap_qinpos;\n\tu_int wrap_qinfifonext;\n\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);\n\tqinpos = ahd_get_snscb_qoff(ahd);\n\twrap_qinpos = AHD_QIN_WRAP(qinpos);\n\twrap_qinfifonext = AHD_QIN_WRAP(ahd->qinfifonext);\n\tif (wrap_qinfifonext >= wrap_qinpos)\n\t\treturn (wrap_qinfifonext - wrap_qinpos);\n\telse\n\t\treturn (wrap_qinfifonext\n\t\t      + ARRAY_SIZE(ahd->qinfifo) - wrap_qinpos);\n}\n\nstatic void\nahd_reset_cmds_pending(struct ahd_softc *ahd)\n{\n\tstruct\t\tscb *scb;\n\tahd_mode_state\tsaved_modes;\n\tu_int\t\tpending_cmds;\n\n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);\n\n\t \n\tahd_flush_qoutfifo(ahd);\n\n\tpending_cmds = 0;\n\tLIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {\n\t\tpending_cmds++;\n\t}\n\tahd_outw(ahd, CMDS_PENDING, pending_cmds - ahd_qinfifo_count(ahd));\n\tahd_restore_modes(ahd, saved_modes);\n\tahd->flags &= ~AHD_UPDATE_PEND_CMDS;\n}\n\nstatic void\nahd_done_with_status(struct ahd_softc *ahd, struct scb *scb, uint32_t status)\n{\n\tcam_status ostat;\n\tcam_status cstat;\n\n\tostat = ahd_get_transaction_status(scb);\n\tif (ostat == CAM_REQ_INPROG)\n\t\tahd_set_transaction_status(scb, status);\n\tcstat = ahd_get_transaction_status(scb);\n\tif (cstat != CAM_REQ_CMP)\n\t\tahd_freeze_scb(scb);\n\tahd_done(ahd, scb);\n}\n\nint\nahd_search_qinfifo(struct ahd_softc *ahd, int target, char channel,\n\t\t   int lun, u_int tag, role_t role, uint32_t status,\n\t\t   ahd_search_action action)\n{\n\tstruct scb\t*scb;\n\tstruct scb\t*mk_msg_scb;\n\tstruct scb\t*prev_scb;\n\tahd_mode_state\t saved_modes;\n\tu_int\t\t qinstart;\n\tu_int\t\t qinpos;\n\tu_int\t\t qintail;\n\tu_int\t\t tid_next;\n\tu_int\t\t tid_prev;\n\tu_int\t\t scbid;\n\tu_int\t\t seq_flags2;\n\tu_int\t\t savedscbptr;\n\tuint32_t\t busaddr;\n\tint\t\t found;\n\tint\t\t targets;\n\n\t \n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);\n\n\t \n\tif ((ahd_inb(ahd, CCSCBCTL) & (CCARREN|CCSCBEN|CCSCBDIR))\n\t == (CCARREN|CCSCBEN|CCSCBDIR)) {\n\t\tahd_outb(ahd, CCSCBCTL,\n\t\t\t ahd_inb(ahd, CCSCBCTL) & ~(CCARREN|CCSCBEN));\n\t\twhile ((ahd_inb(ahd, CCSCBCTL) & (CCARREN|CCSCBEN)) != 0)\n\t\t\t;\n\t}\n\t \n\tqintail = AHD_QIN_WRAP(ahd->qinfifonext);\n\tqinstart = ahd_get_snscb_qoff(ahd);\n\tqinpos = AHD_QIN_WRAP(qinstart);\n\tfound = 0;\n\tprev_scb = NULL;\n\n\tif (action == SEARCH_PRINT) {\n\t\tprintk(\"qinstart = %d qinfifonext = %d\\nQINFIFO:\",\n\t\t       qinstart, ahd->qinfifonext);\n\t}\n\n\t \n\tahd->qinfifonext = qinstart;\n\tbusaddr = ahd_le32toh(ahd->next_queued_hscb->hscb_busaddr);\n\tahd_outl(ahd, NEXT_QUEUED_SCB_ADDR, busaddr);\n\n\twhile (qinpos != qintail) {\n\t\tscb = ahd_lookup_scb(ahd, ahd->qinfifo[qinpos]);\n\t\tif (scb == NULL) {\n\t\t\tprintk(\"qinpos = %d, SCB index = %d\\n\",\n\t\t\t\tqinpos, ahd->qinfifo[qinpos]);\n\t\t\tpanic(\"Loop 1\\n\");\n\t\t}\n\n\t\tif (ahd_match_scb(ahd, scb, target, channel, lun, tag, role)) {\n\t\t\t \n\t\t\tfound++;\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t\tif ((scb->flags & SCB_ACTIVE) == 0)\n\t\t\t\t\tprintk(\"Inactive SCB in qinfifo\\n\");\n\t\t\t\tahd_done_with_status(ahd, scb, status);\n\t\t\t\tfallthrough;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_PRINT:\n\t\t\t\tprintk(\" 0x%x\", ahd->qinfifo[qinpos]);\n\t\t\t\tfallthrough;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tahd_qinfifo_requeue(ahd, prev_scb, scb);\n\t\t\t\tprev_scb = scb;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tahd_qinfifo_requeue(ahd, prev_scb, scb);\n\t\t\tprev_scb = scb;\n\t\t}\n\t\tqinpos = AHD_QIN_WRAP(qinpos+1);\n\t}\n\n\tahd_set_hnscb_qoff(ahd, ahd->qinfifonext);\n\n\tif (action == SEARCH_PRINT)\n\t\tprintk(\"\\nWAITING_TID_QUEUES:\\n\");\n\n\t \n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\tseq_flags2 = ahd_inb(ahd, SEQ_FLAGS2);\n\tif ((seq_flags2 & PENDING_MK_MESSAGE) != 0) {\n\t\tscbid = ahd_inw(ahd, MK_MESSAGE_SCB);\n\t\tmk_msg_scb = ahd_lookup_scb(ahd, scbid);\n\t} else\n\t\tmk_msg_scb = NULL;\n\tsavedscbptr = ahd_get_scbptr(ahd);\n\ttid_next = ahd_inw(ahd, WAITING_TID_HEAD);\n\ttid_prev = SCB_LIST_NULL;\n\ttargets = 0;\n\tfor (scbid = tid_next; !SCBID_IS_NULL(scbid); scbid = tid_next) {\n\t\tu_int tid_head;\n\t\tu_int tid_tail;\n\n\t\ttargets++;\n\t\tif (targets > AHD_NUM_TARGETS)\n\t\t\tpanic(\"TID LIST LOOP\");\n\n\t\tif (scbid >= ahd->scb_data.numscbs) {\n\t\t\tprintk(\"%s: Waiting TID List inconsistency. \"\n\t\t\t       \"SCB index == 0x%x, yet numscbs == 0x%x.\",\n\t\t\t       ahd_name(ahd), scbid, ahd->scb_data.numscbs);\n\t\t\tahd_dump_card_state(ahd);\n\t\t\tpanic(\"for safety\");\n\t\t}\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tif (scb == NULL) {\n\t\t\tprintk(\"%s: SCB = 0x%x Not Active!\\n\",\n\t\t\t       ahd_name(ahd), scbid);\n\t\t\tpanic(\"Waiting TID List traversal\\n\");\n\t\t}\n\t\tahd_set_scbptr(ahd, scbid);\n\t\ttid_next = ahd_inw_scbram(ahd, SCB_NEXT2);\n\t\tif (ahd_match_scb(ahd, scb, target, channel, CAM_LUN_WILDCARD,\n\t\t\t\t  SCB_LIST_NULL, ROLE_UNKNOWN) == 0) {\n\t\t\ttid_prev = scbid;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (action == SEARCH_PRINT)\n\t\t\tprintk(\"       %d ( \", SCB_GET_TARGET(ahd, scb));\n\t\ttid_head = scbid;\n\t\tfound += ahd_search_scb_list(ahd, target, channel,\n\t\t\t\t\t     lun, tag, role, status,\n\t\t\t\t\t     action, &tid_head, &tid_tail,\n\t\t\t\t\t     SCB_GET_TARGET(ahd, scb));\n\t\t \n\t\tif (mk_msg_scb != NULL\n\t\t && ahd_match_scb(ahd, mk_msg_scb, target, channel,\n\t\t\t\t  lun, tag, role)) {\n\n\t\t\t \n\t\t\tfound++;\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t\tif ((mk_msg_scb->flags & SCB_ACTIVE) == 0)\n\t\t\t\t\tprintk(\"Inactive SCB pending MK_MSG\\n\");\n\t\t\t\tahd_done_with_status(ahd, mk_msg_scb, status);\n\t\t\t\tfallthrough;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t{\n\t\t\t\tu_int tail_offset;\n\n\t\t\t\tprintk(\"Removing MK_MSG scb\\n\");\n\n\t\t\t\t \n\t\t\t\ttail_offset = WAITING_SCB_TAILS\n\t\t\t\t    + (2 * SCB_GET_TARGET(ahd, mk_msg_scb));\n\t\t\t\tahd_outw(ahd, tail_offset, tid_tail);\n\n\t\t\t\tseq_flags2 &= ~PENDING_MK_MESSAGE;\n\t\t\t\tahd_outb(ahd, SEQ_FLAGS2, seq_flags2);\n\t\t\t\tahd_outw(ahd, CMDS_PENDING,\n\t\t\t\t\t ahd_inw(ahd, CMDS_PENDING)-1);\n\t\t\t\tmk_msg_scb = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase SEARCH_PRINT:\n\t\t\t\tprintk(\" 0x%x\", SCB_GET_TAG(scb));\n\t\t\t\tfallthrough;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (mk_msg_scb != NULL\n\t\t && SCBID_IS_NULL(tid_head)\n\t\t && ahd_match_scb(ahd, scb, target, channel, CAM_LUN_WILDCARD,\n\t\t\t\t  SCB_LIST_NULL, ROLE_UNKNOWN)) {\n\n\t\t\t \n\t\t\tprintk(\"Queueing mk_msg_scb\\n\");\n\t\t\ttid_head = ahd_inw(ahd, MK_MESSAGE_SCB);\n\t\t\tseq_flags2 &= ~PENDING_MK_MESSAGE;\n\t\t\tahd_outb(ahd, SEQ_FLAGS2, seq_flags2);\n\t\t\tmk_msg_scb = NULL;\n\t\t}\n\t\tif (tid_head != scbid)\n\t\t\tahd_stitch_tid_list(ahd, tid_prev, tid_head, tid_next);\n\t\tif (!SCBID_IS_NULL(tid_head))\n\t\t\ttid_prev = tid_head;\n\t\tif (action == SEARCH_PRINT)\n\t\t\tprintk(\")\\n\");\n\t}\n\n\t \n\tahd_set_scbptr(ahd, savedscbptr);\n\tahd_restore_modes(ahd, saved_modes);\n\treturn (found);\n}\n\nstatic int\nahd_search_scb_list(struct ahd_softc *ahd, int target, char channel,\n\t\t    int lun, u_int tag, role_t role, uint32_t status,\n\t\t    ahd_search_action action, u_int *list_head,\n\t\t    u_int *list_tail, u_int tid)\n{\n\tstruct\tscb *scb;\n\tu_int\tscbid;\n\tu_int\tnext;\n\tu_int\tprev;\n\tint\tfound;\n\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\n\tfound = 0;\n\tprev = SCB_LIST_NULL;\n\tnext = *list_head;\n\t*list_tail = SCB_LIST_NULL;\n\tfor (scbid = next; !SCBID_IS_NULL(scbid); scbid = next) {\n\t\tif (scbid >= ahd->scb_data.numscbs) {\n\t\t\tprintk(\"%s:SCB List inconsistency. \"\n\t\t\t       \"SCB == 0x%x, yet numscbs == 0x%x.\",\n\t\t\t       ahd_name(ahd), scbid, ahd->scb_data.numscbs);\n\t\t\tahd_dump_card_state(ahd);\n\t\t\tpanic(\"for safety\");\n\t\t}\n\t\tscb = ahd_lookup_scb(ahd, scbid);\n\t\tif (scb == NULL) {\n\t\t\tprintk(\"%s: SCB = %d Not Active!\\n\",\n\t\t\t       ahd_name(ahd), scbid);\n\t\t\tpanic(\"Waiting List traversal\\n\");\n\t\t}\n\t\tahd_set_scbptr(ahd, scbid);\n\t\t*list_tail = scbid;\n\t\tnext = ahd_inw_scbram(ahd, SCB_NEXT);\n\t\tif (ahd_match_scb(ahd, scb, target, channel,\n\t\t\t\t  lun, SCB_LIST_NULL, role) == 0) {\n\t\t\tprev = scbid;\n\t\t\tcontinue;\n\t\t}\n\t\tfound++;\n\t\tswitch (action) {\n\t\tcase SEARCH_COMPLETE:\n\t\t\tif ((scb->flags & SCB_ACTIVE) == 0)\n\t\t\t\tprintk(\"Inactive SCB in Waiting List\\n\");\n\t\t\tahd_done_with_status(ahd, scb, status);\n\t\t\tfallthrough;\n\t\tcase SEARCH_REMOVE:\n\t\t\tahd_rem_wscb(ahd, scbid, prev, next, tid);\n\t\t\t*list_tail = prev;\n\t\t\tif (SCBID_IS_NULL(prev))\n\t\t\t\t*list_head = next;\n\t\t\tbreak;\n\t\tcase SEARCH_PRINT:\n\t\t\tprintk(\"0x%x \", scbid);\n\t\t\tfallthrough;\n\t\tcase SEARCH_COUNT:\n\t\t\tprev = scbid;\n\t\t\tbreak;\n\t\t}\n\t\tif (found > AHD_SCB_MAX)\n\t\t\tpanic(\"SCB LIST LOOP\");\n\t}\n\tif (action == SEARCH_COMPLETE\n\t || action == SEARCH_REMOVE)\n\t\tahd_outw(ahd, CMDS_PENDING, ahd_inw(ahd, CMDS_PENDING) - found);\n\treturn (found);\n}\n\nstatic void\nahd_stitch_tid_list(struct ahd_softc *ahd, u_int tid_prev,\n\t\t    u_int tid_cur, u_int tid_next)\n{\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\n\n\tif (SCBID_IS_NULL(tid_cur)) {\n\n\t\t \n\t\tif (SCBID_IS_NULL(tid_prev)) {\n\t\t\tahd_outw(ahd, WAITING_TID_HEAD, tid_next);\n\t\t} else {\n\t\t\tahd_set_scbptr(ahd, tid_prev);\n\t\t\tahd_outw(ahd, SCB_NEXT2, tid_next);\n\t\t}\n\t\tif (SCBID_IS_NULL(tid_next))\n\t\t\tahd_outw(ahd, WAITING_TID_TAIL, tid_prev);\n\t} else {\n\n\t\t \n\t\tif (SCBID_IS_NULL(tid_prev)) {\n\t\t\tahd_outw(ahd, WAITING_TID_HEAD, tid_cur);\n\t\t} else {\n\t\t\tahd_set_scbptr(ahd, tid_prev);\n\t\t\tahd_outw(ahd, SCB_NEXT2, tid_cur);\n\t\t}\n\t\tahd_set_scbptr(ahd, tid_cur);\n\t\tahd_outw(ahd, SCB_NEXT2, tid_next);\n\n\t\tif (SCBID_IS_NULL(tid_next))\n\t\t\tahd_outw(ahd, WAITING_TID_TAIL, tid_cur);\n\t}\n}\n\n \nstatic u_int\nahd_rem_wscb(struct ahd_softc *ahd, u_int scbid,\n\t     u_int prev, u_int next, u_int tid)\n{\n\tu_int tail_offset;\n\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\n\tif (!SCBID_IS_NULL(prev)) {\n\t\tahd_set_scbptr(ahd, prev);\n\t\tahd_outw(ahd, SCB_NEXT, next);\n\t}\n\n\t \n\ttail_offset = WAITING_SCB_TAILS + (2 * tid);\n\tif (SCBID_IS_NULL(next)\n\t && ahd_inw(ahd, tail_offset) == scbid)\n\t\tahd_outw(ahd, tail_offset, prev);\n\n\tahd_add_scb_to_free_list(ahd, scbid);\n\treturn (next);\n}\n\n \nstatic void\nahd_add_scb_to_free_list(struct ahd_softc *ahd, u_int scbid)\n{\n \n\t \n}\n\n \n \nstatic int\nahd_abort_scbs(struct ahd_softc *ahd, int target, char channel,\n\t       int lun, u_int tag, role_t role, uint32_t status)\n{\n\tstruct\t\tscb *scbp;\n\tstruct\t\tscb *scbp_next;\n\tu_int\t\ti, j;\n\tu_int\t\tmaxtarget;\n\tu_int\t\tminlun;\n\tu_int\t\tmaxlun;\n\tint\t\tfound;\n\tahd_mode_state\tsaved_modes;\n\n\t \n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\n\tfound = ahd_search_qinfifo(ahd, target, channel, lun, SCB_LIST_NULL,\n\t\t\t\t   role, CAM_REQUEUE_REQ, SEARCH_COMPLETE);\n\n\t \n\ti = 0;\n\tmaxtarget = 16;\n\tif (target != CAM_TARGET_WILDCARD) {\n\t\ti = target;\n\t\tif (channel == 'B')\n\t\t\ti += 8;\n\t\tmaxtarget = i + 1;\n\t}\n\n\tif (lun == CAM_LUN_WILDCARD) {\n\t\tminlun = 0;\n\t\tmaxlun = AHD_NUM_LUNS_NONPKT;\n\t} else if (lun >= AHD_NUM_LUNS_NONPKT) {\n\t\tminlun = maxlun = 0;\n\t} else {\n\t\tminlun = lun;\n\t\tmaxlun = lun + 1;\n\t}\n\n\tif (role != ROLE_TARGET) {\n\t\tfor (;i < maxtarget; i++) {\n\t\t\tfor (j = minlun;j < maxlun; j++) {\n\t\t\t\tu_int scbid;\n\t\t\t\tu_int tcl;\n\n\t\t\t\ttcl = BUILD_TCL_RAW(i, 'A', j);\n\t\t\t\tscbid = ahd_find_busy_tcl(ahd, tcl);\n\t\t\t\tscbp = ahd_lookup_scb(ahd, scbid);\n\t\t\t\tif (scbp == NULL\n\t\t\t\t || ahd_match_scb(ahd, scbp, target, channel,\n\t\t\t\t\t\t  lun, tag, role) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tahd_unbusy_tcl(ahd, BUILD_TCL_RAW(i, 'A', j));\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tahd_flush_qoutfifo(ahd);\n\n\t \n\tscbp_next = LIST_FIRST(&ahd->pending_scbs);\n\twhile (scbp_next != NULL) {\n\t\tscbp = scbp_next;\n\t\tscbp_next = LIST_NEXT(scbp, pending_links);\n\t\tif (ahd_match_scb(ahd, scbp, target, channel, lun, tag, role)) {\n\t\t\tcam_status ostat;\n\n\t\t\tostat = ahd_get_transaction_status(scbp);\n\t\t\tif (ostat == CAM_REQ_INPROG)\n\t\t\t\tahd_set_transaction_status(scbp, status);\n\t\t\tif (ahd_get_transaction_status(scbp) != CAM_REQ_CMP)\n\t\t\t\tahd_freeze_scb(scbp);\n\t\t\tif ((scbp->flags & SCB_ACTIVE) == 0)\n\t\t\t\tprintk(\"Inactive SCB on pending list\\n\");\n\t\t\tahd_done(ahd, scbp);\n\t\t\tfound++;\n\t\t}\n\t}\n\tahd_restore_modes(ahd, saved_modes);\n\tahd_platform_abort_scbs(ahd, target, channel, lun, tag, role, status);\n\tahd->flags |= AHD_UPDATE_PEND_CMDS;\n\treturn found;\n}\n\nstatic void\nahd_reset_current_bus(struct ahd_softc *ahd)\n{\n\tuint8_t scsiseq;\n\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\n\tahd_outb(ahd, SIMODE1, ahd_inb(ahd, SIMODE1) & ~ENSCSIRST);\n\tscsiseq = ahd_inb(ahd, SCSISEQ0) & ~(ENSELO|ENARBO|SCSIRSTO);\n\tahd_outb(ahd, SCSISEQ0, scsiseq | SCSIRSTO);\n\tahd_flush_device_writes(ahd);\n\tahd_delay(AHD_BUSRESET_DELAY);\n\t \n\tahd_outb(ahd, SCSISEQ0, scsiseq);\n\tahd_flush_device_writes(ahd);\n\tahd_delay(AHD_BUSRESET_DELAY);\n\tif ((ahd->bugs & AHD_SCSIRST_BUG) != 0) {\n\t\t \n\t\tahd_reset(ahd,  TRUE);\n\t\tahd_intr_enable(ahd,  TRUE);\n\t\tAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\n\t}\n\n\tahd_clear_intstat(ahd);\n}\n\nint\nahd_reset_channel(struct ahd_softc *ahd, char channel, int initiate_reset)\n{\n\tstruct\tahd_devinfo caminfo;\n\tu_int\tinitiator;\n\tu_int\ttarget;\n\tu_int\tmax_scsiid;\n\tint\tfound;\n\tu_int\tfifo;\n\tu_int\tnext_fifo;\n\tuint8_t scsiseq;\n\n\t \n\tif (ahd->flags & AHD_BUS_RESET_ACTIVE) {\n\t\tprintk(\"%s: bus reset still active\\n\",\n\t\t       ahd_name(ahd));\n\t\treturn 0;\n\t}\n\tahd->flags |= AHD_BUS_RESET_ACTIVE;\n\n\tahd->pending_device = NULL;\n\n\tahd_compile_devinfo(&caminfo,\n\t\t\t    CAM_TARGET_WILDCARD,\n\t\t\t    CAM_TARGET_WILDCARD,\n\t\t\t    CAM_LUN_WILDCARD,\n\t\t\t    channel, ROLE_UNKNOWN);\n\tahd_pause(ahd);\n\n\t \n\tahd_clear_critical_section(ahd);\n\n\t \n\tahd_run_qoutfifo(ahd);\n#ifdef AHD_TARGET_MODE\n\tif ((ahd->flags & AHD_TARGETROLE) != 0) {\n\t\tahd_run_tqinfifo(ahd,  TRUE);\n\t}\n#endif\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\n\t \n\tahd_outb(ahd, SCSISEQ0, 0);\n\tahd_outb(ahd, SCSISEQ1, 0);\n\n\t \n\tnext_fifo = fifo = ahd_inb(ahd, DFFSTAT) & CURRFIFO;\n\tif (next_fifo > CURRFIFO_1)\n\t\t \n\t\tnext_fifo = fifo = 0;\n\tdo {\n\t\tnext_fifo ^= CURRFIFO_1;\n\t\tahd_set_modes(ahd, next_fifo, next_fifo);\n\t\tahd_outb(ahd, DFCNTRL,\n\t\t\t ahd_inb(ahd, DFCNTRL) & ~(SCSIEN|HDMAEN));\n\t\twhile ((ahd_inb(ahd, DFCNTRL) & HDMAENACK) != 0)\n\t\t\tahd_delay(10);\n\t\t \n\t\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\t\tahd_outb(ahd, DFFSTAT, next_fifo);\n\t} while (next_fifo != fifo);\n\n\t \n\tahd_clear_msg_state(ahd);\n\tahd_outb(ahd, SIMODE1,\n\t\t ahd_inb(ahd, SIMODE1) & ~(ENBUSFREE|ENSCSIRST));\n\n\tif (initiate_reset)\n\t\tahd_reset_current_bus(ahd);\n\n\tahd_clear_intstat(ahd);\n\n\t \n\tfound = ahd_abort_scbs(ahd, CAM_TARGET_WILDCARD, channel,\n\t\t\t       CAM_LUN_WILDCARD, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, CAM_SCSI_BUS_RESET);\n\n\t \n\tahd_clear_fifo(ahd, 0);\n\tahd_clear_fifo(ahd, 1);\n\n\t \n\tahd_outb(ahd, CLRSINT1, CLRSCSIRSTI);\n\n\t \n\tahd_outb(ahd, SIMODE1, ahd_inb(ahd, SIMODE1) | ENSCSIRST);\n\tscsiseq = ahd_inb(ahd, SCSISEQ_TEMPLATE);\n\tahd_outb(ahd, SCSISEQ1, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));\n\n\tmax_scsiid = (ahd->features & AHD_WIDE) ? 15 : 7;\n#ifdef AHD_TARGET_MODE\n\t \n\tfor (target = 0; target <= max_scsiid; target++) {\n\t\tstruct ahd_tmode_tstate* tstate;\n\t\tu_int lun;\n\n\t\ttstate = ahd->enabled_targets[target];\n\t\tif (tstate == NULL)\n\t\t\tcontinue;\n\t\tfor (lun = 0; lun < AHD_NUM_LUNS; lun++) {\n\t\t\tstruct ahd_tmode_lstate* lstate;\n\n\t\t\tlstate = tstate->enabled_luns[lun];\n\t\t\tif (lstate == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tahd_queue_lstate_event(ahd, lstate, CAM_TARGET_WILDCARD,\n\t\t\t\t\t       EVENT_TYPE_BUS_RESET,  0);\n\t\t\tahd_send_lstate_events(ahd, lstate);\n\t\t}\n\t}\n#endif\n\t \n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahd->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahd_devinfo devinfo;\n\n\t\t\tahd_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    CAM_LUN_WILDCARD,\n\t\t\t\t\t    'A', ROLE_UNKNOWN);\n\t\t\tahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHD_TRANS_CUR,  TRUE);\n\t\t\tahd_set_syncrate(ahd, &devinfo,  0,\n\t\t\t\t\t  0,  0,\n\t\t\t\t\t AHD_TRANS_CUR,  TRUE);\n\t\t}\n\t}\n\n\t \n\tahd_send_async(ahd, caminfo.channel, CAM_TARGET_WILDCARD,\n\t\t       CAM_LUN_WILDCARD, AC_BUS_RESET);\n\n\tahd_restart(ahd);\n\n\treturn (found);\n}\n\n \nstatic void\nahd_stat_timer(struct timer_list *t)\n{\n\tstruct\tahd_softc *ahd = from_timer(ahd, t, stat_timer);\n\tu_long\ts;\n\tint\tenint_coal;\n\n\tahd_lock(ahd, &s);\n\n\tenint_coal = ahd->hs_mailbox & ENINT_COALESCE;\n\tif (ahd->cmdcmplt_total > ahd->int_coalescing_threshold)\n\t\tenint_coal |= ENINT_COALESCE;\n\telse if (ahd->cmdcmplt_total < ahd->int_coalescing_stop_threshold)\n\t\tenint_coal &= ~ENINT_COALESCE;\n\n\tif (enint_coal != (ahd->hs_mailbox & ENINT_COALESCE)) {\n\t\tahd_enable_coalescing(ahd, enint_coal);\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_INT_COALESCING) != 0)\n\t\t\tprintk(\"%s: Interrupt coalescing \"\n\t\t\t       \"now %sabled. Cmds %d\\n\",\n\t\t\t       ahd_name(ahd),\n\t\t\t       (enint_coal & ENINT_COALESCE) ? \"en\" : \"dis\",\n\t\t\t       ahd->cmdcmplt_total);\n#endif\n\t}\n\n\tahd->cmdcmplt_bucket = (ahd->cmdcmplt_bucket+1) & (AHD_STAT_BUCKETS-1);\n\tahd->cmdcmplt_total -= ahd->cmdcmplt_counts[ahd->cmdcmplt_bucket];\n\tahd->cmdcmplt_counts[ahd->cmdcmplt_bucket] = 0;\n\tahd_timer_reset(&ahd->stat_timer, AHD_STAT_UPDATE_US);\n\tahd_unlock(ahd, &s);\n}\n\n \n\nstatic void\nahd_handle_scsi_status(struct ahd_softc *ahd, struct scb *scb)\n{\n\tstruct\thardware_scb *hscb;\n\tint\tpaused;\n\n\t \n\thscb = scb->hscb;\n\n\tif (ahd_is_paused(ahd)) {\n\t\tpaused = 1;\n\t} else {\n\t\tpaused = 0;\n\t\tahd_pause(ahd);\n\t}\n\n\t \n\tahd_freeze_devq(ahd, scb);\n\tahd_freeze_scb(scb);\n\tahd->qfreeze_cnt++;\n\tahd_outw(ahd, KERNEL_QFREEZE_COUNT, ahd->qfreeze_cnt);\n\n\tif (paused == 0)\n\t\tahd_unpause(ahd);\n\n\t \n\tif ((scb->flags & SCB_SENSE) != 0) {\n\t\t \n\t\tscb->flags &= ~SCB_SENSE;\n\t\tahd_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);\n\t\tahd_done(ahd, scb);\n\t\treturn;\n\t}\n\tahd_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);\n\tahd_set_scsi_status(scb, hscb->shared_data.istatus.scsi_status);\n\tswitch (hscb->shared_data.istatus.scsi_status) {\n\tcase STATUS_PKT_SENSE:\n\t{\n\t\tstruct scsi_status_iu_header *siu;\n\n\t\tahd_sync_sense(ahd, scb, BUS_DMASYNC_POSTREAD);\n\t\tsiu = (struct scsi_status_iu_header *)scb->sense_data;\n\t\tahd_set_scsi_status(scb, siu->status);\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_SENSE) != 0) {\n\t\t\tahd_print_path(ahd, scb);\n\t\t\tprintk(\"SCB 0x%x Received PKT Status of 0x%x\\n\",\n\t\t\t       SCB_GET_TAG(scb), siu->status);\n\t\t\tprintk(\"\\tflags = 0x%x, sense len = 0x%x, \"\n\t\t\t       \"pktfail = 0x%x\\n\",\n\t\t\t       siu->flags, scsi_4btoul(siu->sense_length),\n\t\t\t       scsi_4btoul(siu->pkt_failures_length));\n\t\t}\n#endif\n\t\tif ((siu->flags & SIU_RSPVALID) != 0) {\n\t\t\tahd_print_path(ahd, scb);\n\t\t\tif (scsi_4btoul(siu->pkt_failures_length) < 4) {\n\t\t\t\tprintk(\"Unable to parse pkt_failures\\n\");\n\t\t\t} else {\n\n\t\t\t\tswitch (SIU_PKTFAIL_CODE(siu)) {\n\t\t\t\tcase SIU_PFC_NONE:\n\t\t\t\t\tprintk(\"No packet failure found\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase SIU_PFC_CIU_FIELDS_INVALID:\n\t\t\t\t\tprintk(\"Invalid Command IU Field\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase SIU_PFC_TMF_NOT_SUPPORTED:\n\t\t\t\t\tprintk(\"TMF not supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase SIU_PFC_TMF_FAILED:\n\t\t\t\t\tprintk(\"TMF failed\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase SIU_PFC_INVALID_TYPE_CODE:\n\t\t\t\t\tprintk(\"Invalid L_Q Type code\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase SIU_PFC_ILLEGAL_REQUEST:\n\t\t\t\t\tprintk(\"Illegal request\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (siu->status == SAM_STAT_GOOD)\n\t\t\t\tahd_set_transaction_status(scb,\n\t\t\t\t\t\t\t   CAM_REQ_CMP_ERR);\n\t\t}\n\t\tif ((siu->flags & SIU_SNSVALID) != 0) {\n\t\t\tscb->flags |= SCB_PKT_SENSE;\n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_SENSE) != 0)\n\t\t\t\tprintk(\"Sense data available\\n\");\n#endif\n\t\t}\n\t\tahd_done(ahd, scb);\n\t\tbreak;\n\t}\n\tcase SAM_STAT_COMMAND_TERMINATED:\n\tcase SAM_STAT_CHECK_CONDITION:\n\t{\n\t\tstruct ahd_devinfo devinfo;\n\t\tstruct ahd_dma_seg *sg;\n\t\tstruct scsi_sense *sc;\n\t\tstruct ahd_initiator_tinfo *targ_info;\n\t\tstruct ahd_tmode_tstate *tstate;\n\t\tstruct ahd_transinfo *tinfo;\n#ifdef AHD_DEBUG\n\t\tif (ahd_debug & AHD_SHOW_SENSE) {\n\t\t\tahd_print_path(ahd, scb);\n\t\t\tprintk(\"SCB %d: requests Check Status\\n\",\n\t\t\t       SCB_GET_TAG(scb));\n\t\t}\n#endif\n\n\t\tif (ahd_perform_autosense(scb) == 0)\n\t\t\tbreak;\n\n\t\tahd_compile_devinfo(&devinfo, SCB_GET_OUR_ID(scb),\n\t\t\t\t    SCB_GET_TARGET(ahd, scb),\n\t\t\t\t    SCB_GET_LUN(scb),\n\t\t\t\t    SCB_GET_CHANNEL(ahd, scb),\n\t\t\t\t    ROLE_INITIATOR);\n\t\ttarg_info = ahd_fetch_transinfo(ahd,\n\t\t\t\t\t\tdevinfo.channel,\n\t\t\t\t\t\tdevinfo.our_scsiid,\n\t\t\t\t\t\tdevinfo.target,\n\t\t\t\t\t\t&tstate);\n\t\ttinfo = &targ_info->curr;\n\t\tsg = scb->sg_list;\n\t\tsc = (struct scsi_sense *)hscb->shared_data.idata.cdb;\n\t\t \n\t\tahd_update_residual(ahd, scb);\n#ifdef AHD_DEBUG\n\t\tif (ahd_debug & AHD_SHOW_SENSE) {\n\t\t\tahd_print_path(ahd, scb);\n\t\t\tprintk(\"Sending Sense\\n\");\n\t\t}\n#endif\n\t\tscb->sg_count = 0;\n\t\tsg = ahd_sg_setup(ahd, scb, sg, ahd_get_sense_bufaddr(ahd, scb),\n\t\t\t\t  ahd_get_sense_bufsize(ahd, scb),\n\t\t\t\t   TRUE);\n\t\tsc->opcode = REQUEST_SENSE;\n\t\tsc->byte2 = 0;\n\t\tif (tinfo->protocol_version <= SCSI_REV_2\n\t\t && SCB_GET_LUN(scb) < 8)\n\t\t\tsc->byte2 = SCB_GET_LUN(scb) << 5;\n\t\tsc->unused[0] = 0;\n\t\tsc->unused[1] = 0;\n\t\tsc->length = ahd_get_sense_bufsize(ahd, scb);\n\t\tsc->control = 0;\n\n\t\t \n\t\thscb->control = 0;\n\n\t\t \n\t\tif (ahd_get_residual(scb) == ahd_get_transfer_length(scb)) {\n\t\t\tahd_update_neg_request(ahd, &devinfo,\n\t\t\t\t\t       tstate, targ_info,\n\t\t\t\t\t       AHD_NEG_IF_NON_ASYNC);\n\t\t}\n\t\tif (tstate->auto_negotiate & devinfo.target_mask) {\n\t\t\thscb->control |= MK_MESSAGE;\n\t\t\tscb->flags &=\n\t\t\t    ~(SCB_NEGOTIATE|SCB_ABORT|SCB_DEVICE_RESET);\n\t\t\tscb->flags |= SCB_AUTO_NEGOTIATE;\n\t\t}\n\t\thscb->cdb_len = sizeof(*sc);\n\t\tahd_setup_data_scb(ahd, scb);\n\t\tscb->flags |= SCB_SENSE;\n\t\tahd_queue_scb(ahd, scb);\n\t\tbreak;\n\t}\n\tcase SAM_STAT_GOOD:\n\t\tprintk(\"%s: Interrupted for status of 0???\\n\",\n\t\t       ahd_name(ahd));\n\t\tfallthrough;\n\tdefault:\n\t\tahd_done(ahd, scb);\n\t\tbreak;\n\t}\n}\n\nstatic void\nahd_handle_scb_status(struct ahd_softc *ahd, struct scb *scb)\n{\n\tif (scb->hscb->shared_data.istatus.scsi_status != 0) {\n\t\tahd_handle_scsi_status(ahd, scb);\n\t} else {\n\t\tahd_calc_residual(ahd, scb);\n\t\tahd_done(ahd, scb);\n\t}\n}\n\n \nstatic void\nahd_calc_residual(struct ahd_softc *ahd, struct scb *scb)\n{\n\tstruct hardware_scb *hscb;\n\tstruct initiator_status *spkt;\n\tuint32_t sgptr;\n\tuint32_t resid_sgptr;\n\tuint32_t resid;\n\n\t \n\n\thscb = scb->hscb;\n\tsgptr = ahd_le32toh(hscb->sgptr);\n\tif ((sgptr & SG_STATUS_VALID) == 0)\n\t\t \n\t\treturn;\n\tsgptr &= ~SG_STATUS_VALID;\n\n\tif ((sgptr & SG_LIST_NULL) != 0)\n\t\t \n\t\treturn;\n\n\t \n\tspkt = &hscb->shared_data.istatus;\n\tresid_sgptr = ahd_le32toh(spkt->residual_sgptr);\n\tif ((sgptr & SG_FULL_RESID) != 0) {\n\t\t \n\t\tresid = ahd_get_transfer_length(scb);\n\t} else if ((resid_sgptr & SG_LIST_NULL) != 0) {\n\t\t \n\t\treturn;\n\t} else if ((resid_sgptr & SG_OVERRUN_RESID) != 0) {\n\t\tahd_print_path(ahd, scb);\n\t\tprintk(\"data overrun detected Tag == 0x%x.\\n\",\n\t\t       SCB_GET_TAG(scb));\n\t\tahd_freeze_devq(ahd, scb);\n\t\tahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);\n\t\tahd_freeze_scb(scb);\n\t\treturn;\n\t} else if ((resid_sgptr & ~SG_PTR_MASK) != 0) {\n\t\tpanic(\"Bogus resid sgptr value 0x%x\\n\", resid_sgptr);\n\t\t \n\t} else {\n\t\tstruct ahd_dma_seg *sg;\n\n\t\t \n\t\tresid = ahd_le32toh(spkt->residual_datacnt) & AHD_SG_LEN_MASK;\n\t\tsg = ahd_sg_bus_to_virt(ahd, scb, resid_sgptr & SG_PTR_MASK);\n\n\t\t \n\t\tsg--;\n\n\t\t \n\t\twhile ((ahd_le32toh(sg->len) & AHD_DMA_LAST_SEG) == 0) {\n\t\t\tsg++;\n\t\t\tresid += ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;\n\t\t}\n\t}\n\tif ((scb->flags & SCB_SENSE) == 0)\n\t\tahd_set_residual(scb, resid);\n\telse\n\t\tahd_set_sense_residual(scb, resid);\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_MISC) != 0) {\n\t\tahd_print_path(ahd, scb);\n\t\tprintk(\"Handled %sResidual of %d bytes\\n\",\n\t\t       (scb->flags & SCB_SENSE) ? \"Sense \" : \"\", resid);\n\t}\n#endif\n}\n\n \n#ifdef AHD_TARGET_MODE\n \nstatic void\nahd_queue_lstate_event(struct ahd_softc *ahd, struct ahd_tmode_lstate *lstate,\n\t\t       u_int initiator_id, u_int event_type, u_int event_arg)\n{\n\tstruct ahd_tmode_event *event;\n\tint pending;\n\n\txpt_freeze_devq(lstate->path,  1);\n\tif (lstate->event_w_idx >= lstate->event_r_idx)\n\t\tpending = lstate->event_w_idx - lstate->event_r_idx;\n\telse\n\t\tpending = AHD_TMODE_EVENT_BUFFER_SIZE + 1\n\t\t\t- (lstate->event_r_idx - lstate->event_w_idx);\n\n\tif (event_type == EVENT_TYPE_BUS_RESET\n\t || event_type == TARGET_RESET) {\n\t\t \n\t\tlstate->event_r_idx = 0;\n\t\tlstate->event_w_idx = 0;\n\t\txpt_release_devq(lstate->path, pending,  FALSE);\n\t}\n\n\tif (pending == AHD_TMODE_EVENT_BUFFER_SIZE) {\n\t\txpt_print_path(lstate->path);\n\t\tprintk(\"immediate event %x:%x lost\\n\",\n\t\t       lstate->event_buffer[lstate->event_r_idx].event_type,\n\t\t       lstate->event_buffer[lstate->event_r_idx].event_arg);\n\t\tlstate->event_r_idx++;\n\t\tif (lstate->event_r_idx == AHD_TMODE_EVENT_BUFFER_SIZE)\n\t\t\tlstate->event_r_idx = 0;\n\t\txpt_release_devq(lstate->path,  1,  FALSE);\n\t}\n\n\tevent = &lstate->event_buffer[lstate->event_w_idx];\n\tevent->initiator_id = initiator_id;\n\tevent->event_type = event_type;\n\tevent->event_arg = event_arg;\n\tlstate->event_w_idx++;\n\tif (lstate->event_w_idx == AHD_TMODE_EVENT_BUFFER_SIZE)\n\t\tlstate->event_w_idx = 0;\n}\n\n \nvoid\nahd_send_lstate_events(struct ahd_softc *ahd, struct ahd_tmode_lstate *lstate)\n{\n\tstruct ccb_hdr *ccbh;\n\tstruct ccb_immed_notify *inot;\n\n\twhile (lstate->event_r_idx != lstate->event_w_idx\n\t    && (ccbh = SLIST_FIRST(&lstate->immed_notifies)) != NULL) {\n\t\tstruct ahd_tmode_event *event;\n\n\t\tevent = &lstate->event_buffer[lstate->event_r_idx];\n\t\tSLIST_REMOVE_HEAD(&lstate->immed_notifies, sim_links.sle);\n\t\tinot = (struct ccb_immed_notify *)ccbh;\n\t\tswitch (event->event_type) {\n\t\tcase EVENT_TYPE_BUS_RESET:\n\t\t\tccbh->status = CAM_SCSI_BUS_RESET|CAM_DEV_QFRZN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tccbh->status = CAM_MESSAGE_RECV|CAM_DEV_QFRZN;\n\t\t\tinot->message_args[0] = event->event_type;\n\t\t\tinot->message_args[1] = event->event_arg;\n\t\t\tbreak;\n\t\t}\n\t\tinot->initiator_id = event->initiator_id;\n\t\tinot->sense_len = 0;\n\t\txpt_done((union ccb *)inot);\n\t\tlstate->event_r_idx++;\n\t\tif (lstate->event_r_idx == AHD_TMODE_EVENT_BUFFER_SIZE)\n\t\t\tlstate->event_r_idx = 0;\n\t}\n}\n#endif\n\n \n\n#ifdef AHD_DUMP_SEQ\nvoid\nahd_dumpseq(struct ahd_softc* ahd)\n{\n\tint i;\n\tint max_prog;\n\n\tmax_prog = 2048;\n\n\tahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\n\tahd_outw(ahd, PRGMCNT, 0);\n\tfor (i = 0; i < max_prog; i++) {\n\t\tuint8_t ins_bytes[4];\n\n\t\tahd_insb(ahd, SEQRAM, ins_bytes, 4);\n\t\tprintk(\"0x%08x\\n\", ins_bytes[0] << 24\n\t\t\t\t | ins_bytes[1] << 16\n\t\t\t\t | ins_bytes[2] << 8\n\t\t\t\t | ins_bytes[3]);\n\t}\n}\n#endif\n\nstatic void\nahd_loadseq(struct ahd_softc *ahd)\n{\n\tstruct\tcs cs_table[NUM_CRITICAL_SECTIONS];\n\tu_int\tbegin_set[NUM_CRITICAL_SECTIONS];\n\tu_int\tend_set[NUM_CRITICAL_SECTIONS];\n\tconst struct patch *cur_patch;\n\tu_int\tcs_count;\n\tu_int\tcur_cs;\n\tu_int\ti;\n\tint\tdownloaded;\n\tu_int\tskip_addr;\n\tu_int\tsg_prefetch_cnt;\n\tu_int\tsg_prefetch_cnt_limit;\n\tu_int\tsg_prefetch_align;\n\tu_int\tsg_size;\n\tu_int\tcacheline_mask;\n\tuint8_t\tdownload_consts[DOWNLOAD_CONST_COUNT];\n\n\tif (bootverbose)\n\t\tprintk(\"%s: Downloading Sequencer Program...\",\n\t\t       ahd_name(ahd));\n\n#if DOWNLOAD_CONST_COUNT != 8\n#error \"Download Const Mismatch\"\n#endif\n\t \n\tcs_count = 0;\n\tcur_cs = 0;\n\tmemset(begin_set, 0, sizeof(begin_set));\n\tmemset(end_set, 0, sizeof(end_set));\n\n\t \n\t \n\tsg_prefetch_align = ahd->pci_cachesize;\n\tif (sg_prefetch_align == 0)\n\t\tsg_prefetch_align = 8;\n\t \n\twhile (powerof2(sg_prefetch_align) == 0)\n\t\tsg_prefetch_align--;\n\n\tcacheline_mask = sg_prefetch_align - 1;\n\n\t \n\tif (sg_prefetch_align > CCSGADDR_MAX/2)\n\t\tsg_prefetch_align = CCSGADDR_MAX/2;\n\t \n\tsg_prefetch_cnt = sg_prefetch_align;\n\t \n\tsg_size = sizeof(struct ahd_dma_seg);\n\tif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)\n\t\tsg_size = sizeof(struct ahd_dma64_seg);\n\twhile (sg_prefetch_cnt < sg_size)\n\t\tsg_prefetch_cnt += sg_prefetch_align;\n\t \n\tif ((sg_prefetch_align % sg_size) != 0\n\t && (sg_prefetch_cnt < CCSGADDR_MAX))\n\t\tsg_prefetch_cnt += sg_prefetch_align;\n\t \n\tsg_prefetch_cnt_limit = -(sg_prefetch_cnt - sg_size + 1);\n\tdownload_consts[SG_PREFETCH_CNT] = sg_prefetch_cnt;\n\tdownload_consts[SG_PREFETCH_CNT_LIMIT] = sg_prefetch_cnt_limit;\n\tdownload_consts[SG_PREFETCH_ALIGN_MASK] = ~(sg_prefetch_align - 1);\n\tdownload_consts[SG_PREFETCH_ADDR_MASK] = (sg_prefetch_align - 1);\n\tdownload_consts[SG_SIZEOF] = sg_size;\n\tdownload_consts[PKT_OVERRUN_BUFOFFSET] =\n\t\t(ahd->overrun_buf - (uint8_t *)ahd->qoutfifo) / 256;\n\tdownload_consts[SCB_TRANSFER_SIZE] = SCB_TRANSFER_SIZE_1BYTE_LUN;\n\tdownload_consts[CACHELINE_MASK] = cacheline_mask;\n\tcur_patch = patches;\n\tdownloaded = 0;\n\tskip_addr = 0;\n\tahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\n\tahd_outw(ahd, PRGMCNT, 0);\n\n\tfor (i = 0; i < sizeof(seqprog)/4; i++) {\n\t\tif (ahd_check_patch(ahd, &cur_patch, i, &skip_addr) == 0) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tfor (; cur_cs < NUM_CRITICAL_SECTIONS; cur_cs++) {\n\t\t\tif (critical_sections[cur_cs].end <= i) {\n\t\t\t\tif (begin_set[cs_count] == TRUE\n\t\t\t\t && end_set[cs_count] == FALSE) {\n\t\t\t\t\tcs_table[cs_count].end = downloaded;\n\t\t\t\t\tend_set[cs_count] = TRUE;\n\t\t\t\t\tcs_count++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (critical_sections[cur_cs].begin <= i\n\t\t\t && begin_set[cs_count] == FALSE) {\n\t\t\t\tcs_table[cs_count].begin = downloaded;\n\t\t\t\tbegin_set[cs_count] = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tahd_download_instr(ahd, i, download_consts);\n\t\tdownloaded++;\n\t}\n\n\tahd->num_critical_sections = cs_count;\n\tif (cs_count != 0) {\n\n\t\tcs_count *= sizeof(struct cs);\n\t\tahd->critical_sections = kmemdup(cs_table, cs_count, GFP_ATOMIC);\n\t\tif (ahd->critical_sections == NULL)\n\t\t\tpanic(\"ahd_loadseq: Could not malloc\");\n\t}\n\tahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE);\n\n\tif (bootverbose) {\n\t\tprintk(\" %d instructions downloaded\\n\", downloaded);\n\t\tprintk(\"%s: Features 0x%x, Bugs 0x%x, Flags 0x%x\\n\",\n\t\t       ahd_name(ahd), ahd->features, ahd->bugs, ahd->flags);\n\t}\n}\n\nstatic int\nahd_check_patch(struct ahd_softc *ahd, const struct patch **start_patch,\n\t\tu_int start_instr, u_int *skip_addr)\n{\n\tconst struct patch *cur_patch;\n\tconst struct patch *last_patch;\n\tu_int\tnum_patches;\n\n\tnum_patches = ARRAY_SIZE(patches);\n\tlast_patch = &patches[num_patches];\n\tcur_patch = *start_patch;\n\n\twhile (cur_patch < last_patch && start_instr == cur_patch->begin) {\n\n\t\tif (cur_patch->patch_func(ahd) == 0) {\n\n\t\t\t \n\t\t\t*skip_addr = start_instr + cur_patch->skip_instr;\n\t\t\tcur_patch += cur_patch->skip_patch;\n\t\t} else {\n\t\t\t \n\t\t\tcur_patch++;\n\t\t}\n\t}\n\n\t*start_patch = cur_patch;\n\tif (start_instr < *skip_addr)\n\t\t \n\t\treturn (0);\n\n\treturn (1);\n}\n\nstatic u_int\nahd_resolve_seqaddr(struct ahd_softc *ahd, u_int address)\n{\n\tconst struct patch *cur_patch;\n\tint address_offset;\n\tu_int skip_addr;\n\tu_int i;\n\n\taddress_offset = 0;\n\tcur_patch = patches;\n\tskip_addr = 0;\n\n\tfor (i = 0; i < address;) {\n\n\t\tahd_check_patch(ahd, &cur_patch, i, &skip_addr);\n\n\t\tif (skip_addr > i) {\n\t\t\tint end_addr;\n\n\t\t\tend_addr = min(address, skip_addr);\n\t\t\taddress_offset += end_addr - i;\n\t\t\ti = skip_addr;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn (address - address_offset);\n}\n\nstatic void\nahd_download_instr(struct ahd_softc *ahd, u_int instrptr, uint8_t *dconsts)\n{\n\tunion\tins_formats instr;\n\tstruct\tins_format1 *fmt1_ins;\n\tstruct\tins_format3 *fmt3_ins;\n\tu_int\topcode;\n\n\t \n\tinstr.integer = ahd_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);\n\n\tfmt1_ins = &instr.format1;\n\tfmt3_ins = NULL;\n\n\t \n\topcode = instr.format1.opcode;\n\tswitch (opcode) {\n\tcase AIC_OP_JMP:\n\tcase AIC_OP_JC:\n\tcase AIC_OP_JNC:\n\tcase AIC_OP_CALL:\n\tcase AIC_OP_JNE:\n\tcase AIC_OP_JNZ:\n\tcase AIC_OP_JE:\n\tcase AIC_OP_JZ:\n\t{\n\t\tfmt3_ins = &instr.format3;\n\t\tfmt3_ins->address = ahd_resolve_seqaddr(ahd, fmt3_ins->address);\n\t}\n\t\tfallthrough;\n\tcase AIC_OP_OR:\n\tcase AIC_OP_AND:\n\tcase AIC_OP_XOR:\n\tcase AIC_OP_ADD:\n\tcase AIC_OP_ADC:\n\tcase AIC_OP_BMOV:\n\t\tif (fmt1_ins->parity != 0) {\n\t\t\tfmt1_ins->immediate = dconsts[fmt1_ins->immediate];\n\t\t}\n\t\tfmt1_ins->parity = 0;\n\t\tfallthrough;\n\tcase AIC_OP_ROL:\n\t{\n\t\tint i, count;\n\n\t\t \n\t\tfor (i = 0, count = 0; i < 31; i++) {\n\t\t\tuint32_t mask;\n\n\t\t\tmask = 0x01 << i;\n\t\t\tif ((instr.integer & mask) != 0)\n\t\t\t\tcount++;\n\t\t}\n\t\tif ((count & 0x01) == 0)\n\t\t\tinstr.format1.parity = 1;\n\n\t\t \n\t\tinstr.integer = ahd_htole32(instr.integer);\n\t\tahd_outsb(ahd, SEQRAM, instr.bytes, 4);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpanic(\"Unknown opcode encountered in seq program\");\n\t\tbreak;\n\t}\n}\n\nstatic int\nahd_probe_stack_size(struct ahd_softc *ahd)\n{\n\tint last_probe;\n\n\tlast_probe = 0;\n\twhile (1) {\n\t\tint i;\n\n\t\t \n\t\tfor (i = 1; i <= last_probe+1; i++) {\n\t\t       ahd_outb(ahd, STACK, i & 0xFF);\n\t\t       ahd_outb(ahd, STACK, (i >> 8) & 0xFF);\n\t\t}\n\n\t\t \n\t\tfor (i = last_probe+1; i > 0; i--) {\n\t\t\tu_int stack_entry;\n\n\t\t\tstack_entry = ahd_inb(ahd, STACK)\n\t\t\t\t    |(ahd_inb(ahd, STACK) << 8);\n\t\t\tif (stack_entry != i)\n\t\t\t\tgoto sized;\n\t\t}\n\t\tlast_probe++;\n\t}\nsized:\n\treturn (last_probe);\n}\n\nint\nahd_print_register(const ahd_reg_parse_entry_t *table, u_int num_entries,\n\t\t   const char *name, u_int address, u_int value,\n\t\t   u_int *cur_column, u_int wrap_point)\n{\n\tint\tprinted;\n\tu_int\tprinted_mask;\n\n\tif (cur_column != NULL && *cur_column >= wrap_point) {\n\t\tprintk(\"\\n\");\n\t\t*cur_column = 0;\n\t}\n\tprinted = printk(\"%s[0x%x]\", name, value);\n\tif (table == NULL) {\n\t\tprinted += printk(\" \");\n\t\t*cur_column += printed;\n\t\treturn (printed);\n\t}\n\tprinted_mask = 0;\n\twhile (printed_mask != 0xFF) {\n\t\tint entry;\n\n\t\tfor (entry = 0; entry < num_entries; entry++) {\n\t\t\tif (((value & table[entry].mask)\n\t\t\t  != table[entry].value)\n\t\t\t || ((printed_mask & table[entry].mask)\n\t\t\t  == table[entry].mask))\n\t\t\t\tcontinue;\n\n\t\t\tprinted += printk(\"%s%s\",\n\t\t\t\t\t  printed_mask == 0 ? \":(\" : \"|\",\n\t\t\t\t\t  table[entry].name);\n\t\t\tprinted_mask |= table[entry].mask;\n\n\t\t\tbreak;\n\t\t}\n\t\tif (entry >= num_entries)\n\t\t\tbreak;\n\t}\n\tif (printed_mask != 0)\n\t\tprinted += printk(\") \");\n\telse\n\t\tprinted += printk(\" \");\n\tif (cur_column != NULL)\n\t\t*cur_column += printed;\n\treturn (printed);\n}\n\nvoid\nahd_dump_card_state(struct ahd_softc *ahd)\n{\n\tstruct scb\t*scb;\n\tahd_mode_state\t saved_modes;\n\tu_int\t\t dffstat;\n\tint\t\t paused;\n\tu_int\t\t scb_index;\n\tu_int\t\t saved_scb_index;\n\tu_int\t\t cur_col;\n\tint\t\t i;\n\n\tif (ahd_is_paused(ahd)) {\n\t\tpaused = 1;\n\t} else {\n\t\tpaused = 0;\n\t\tahd_pause(ahd);\n\t}\n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\tprintk(\">>>>>>>>>>>>>>>>>> Dump Card State Begins <<<<<<<<<<<<<<<<<\\n\"\n\t       \"%s: Dumping Card State at program address 0x%x Mode 0x%x\\n\",\n\t       ahd_name(ahd),\n\t       ahd_inw(ahd, CURADDR),\n\t       ahd_build_mode_state(ahd, ahd->saved_src_mode,\n\t\t\t\t    ahd->saved_dst_mode));\n\tif (paused)\n\t\tprintk(\"Card was paused\\n\");\n\n\tif (ahd_check_cmdcmpltqueues(ahd))\n\t\tprintk(\"Completions are pending\\n\");\n\n\t \n\tcur_col = 0;\n\tahd_intstat_print(ahd_inb(ahd, INTSTAT), &cur_col, 50);\n\tahd_seloid_print(ahd_inb(ahd, SELOID), &cur_col, 50);\n\tahd_selid_print(ahd_inb(ahd, SELID), &cur_col, 50);\n\tahd_hs_mailbox_print(ahd_inb(ahd, LOCAL_HS_MAILBOX), &cur_col, 50);\n\tahd_intctl_print(ahd_inb(ahd, INTCTL), &cur_col, 50);\n\tahd_seqintstat_print(ahd_inb(ahd, SEQINTSTAT), &cur_col, 50);\n\tahd_saved_mode_print(ahd_inb(ahd, SAVED_MODE), &cur_col, 50);\n\tahd_dffstat_print(ahd_inb(ahd, DFFSTAT), &cur_col, 50);\n\tahd_scsisigi_print(ahd_inb(ahd, SCSISIGI), &cur_col, 50);\n\tahd_scsiphase_print(ahd_inb(ahd, SCSIPHASE), &cur_col, 50);\n\tahd_scsibus_print(ahd_inb(ahd, SCSIBUS), &cur_col, 50);\n\tahd_lastphase_print(ahd_inb(ahd, LASTPHASE), &cur_col, 50);\n\tahd_scsiseq0_print(ahd_inb(ahd, SCSISEQ0), &cur_col, 50);\n\tahd_scsiseq1_print(ahd_inb(ahd, SCSISEQ1), &cur_col, 50);\n\tahd_seqctl0_print(ahd_inb(ahd, SEQCTL0), &cur_col, 50);\n\tahd_seqintctl_print(ahd_inb(ahd, SEQINTCTL), &cur_col, 50);\n\tahd_seq_flags_print(ahd_inb(ahd, SEQ_FLAGS), &cur_col, 50);\n\tahd_seq_flags2_print(ahd_inb(ahd, SEQ_FLAGS2), &cur_col, 50);\n\tahd_qfreeze_count_print(ahd_inw(ahd, QFREEZE_COUNT), &cur_col, 50);\n\tahd_kernel_qfreeze_count_print(ahd_inw(ahd, KERNEL_QFREEZE_COUNT),\n\t\t\t\t       &cur_col, 50);\n\tahd_mk_message_scb_print(ahd_inw(ahd, MK_MESSAGE_SCB), &cur_col, 50);\n\tahd_mk_message_scsiid_print(ahd_inb(ahd, MK_MESSAGE_SCSIID),\n\t\t\t\t    &cur_col, 50);\n\tahd_sstat0_print(ahd_inb(ahd, SSTAT0), &cur_col, 50);\n\tahd_sstat1_print(ahd_inb(ahd, SSTAT1), &cur_col, 50);\n\tahd_sstat2_print(ahd_inb(ahd, SSTAT2), &cur_col, 50);\n\tahd_sstat3_print(ahd_inb(ahd, SSTAT3), &cur_col, 50);\n\tahd_perrdiag_print(ahd_inb(ahd, PERRDIAG), &cur_col, 50);\n\tahd_simode1_print(ahd_inb(ahd, SIMODE1), &cur_col, 50);\n\tahd_lqistat0_print(ahd_inb(ahd, LQISTAT0), &cur_col, 50);\n\tahd_lqistat1_print(ahd_inb(ahd, LQISTAT1), &cur_col, 50);\n\tahd_lqistat2_print(ahd_inb(ahd, LQISTAT2), &cur_col, 50);\n\tahd_lqostat0_print(ahd_inb(ahd, LQOSTAT0), &cur_col, 50);\n\tahd_lqostat1_print(ahd_inb(ahd, LQOSTAT1), &cur_col, 50);\n\tahd_lqostat2_print(ahd_inb(ahd, LQOSTAT2), &cur_col, 50);\n\tprintk(\"\\n\");\n\tprintk(\"\\nSCB Count = %d CMDS_PENDING = %d LASTSCB 0x%x \"\n\t       \"CURRSCB 0x%x NEXTSCB 0x%x\\n\",\n\t       ahd->scb_data.numscbs, ahd_inw(ahd, CMDS_PENDING),\n\t       ahd_inw(ahd, LASTSCB), ahd_inw(ahd, CURRSCB),\n\t       ahd_inw(ahd, NEXTSCB));\n\tcur_col = 0;\n\t \n\tahd_search_qinfifo(ahd, CAM_TARGET_WILDCARD, ALL_CHANNELS,\n\t\t\t   CAM_LUN_WILDCARD, SCB_LIST_NULL,\n\t\t\t   ROLE_UNKNOWN,  0, SEARCH_PRINT);\n\tsaved_scb_index = ahd_get_scbptr(ahd);\n\tprintk(\"Pending list:\");\n\ti = 0;\n\tLIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {\n\t\tif (i++ > AHD_SCB_MAX)\n\t\t\tbreak;\n\t\tcur_col = printk(\"\\n%3d FIFO_USE[0x%x] \", SCB_GET_TAG(scb),\n\t\t\t\t ahd_inb_scbram(ahd, SCB_FIFO_USE_COUNT));\n\t\tahd_set_scbptr(ahd, SCB_GET_TAG(scb));\n\t\tahd_scb_control_print(ahd_inb_scbram(ahd, SCB_CONTROL),\n\t\t\t\t      &cur_col, 60);\n\t\tahd_scb_scsiid_print(ahd_inb_scbram(ahd, SCB_SCSIID),\n\t\t\t\t     &cur_col, 60);\n\t}\n\tprintk(\"\\nTotal %d\\n\", i);\n\n\tprintk(\"Kernel Free SCB list: \");\n\ti = 0;\n\tTAILQ_FOREACH(scb, &ahd->scb_data.free_scbs, links.tqe) {\n\t\tstruct scb *list_scb;\n\n\t\tlist_scb = scb;\n\t\tdo {\n\t\t\tprintk(\"%d \", SCB_GET_TAG(list_scb));\n\t\t\tlist_scb = LIST_NEXT(list_scb, collision_links);\n\t\t} while (list_scb && i++ < AHD_SCB_MAX);\n\t}\n\n\tLIST_FOREACH(scb, &ahd->scb_data.any_dev_free_scb_list, links.le) {\n\t\tif (i++ > AHD_SCB_MAX)\n\t\t\tbreak;\n\t\tprintk(\"%d \", SCB_GET_TAG(scb));\n\t}\n\tprintk(\"\\n\");\n\n\tprintk(\"Sequencer Complete DMA-inprog list: \");\n\tscb_index = ahd_inw(ahd, COMPLETE_SCB_DMAINPROG_HEAD);\n\ti = 0;\n\twhile (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {\n\t\tahd_set_scbptr(ahd, scb_index);\n\t\tprintk(\"%d \", scb_index);\n\t\tscb_index = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);\n\t}\n\tprintk(\"\\n\");\n\n\tprintk(\"Sequencer Complete list: \");\n\tscb_index = ahd_inw(ahd, COMPLETE_SCB_HEAD);\n\ti = 0;\n\twhile (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {\n\t\tahd_set_scbptr(ahd, scb_index);\n\t\tprintk(\"%d \", scb_index);\n\t\tscb_index = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);\n\t}\n\tprintk(\"\\n\");\n\n\tprintk(\"Sequencer DMA-Up and Complete list: \");\n\tscb_index = ahd_inw(ahd, COMPLETE_DMA_SCB_HEAD);\n\ti = 0;\n\twhile (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {\n\t\tahd_set_scbptr(ahd, scb_index);\n\t\tprintk(\"%d \", scb_index);\n\t\tscb_index = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);\n\t}\n\tprintk(\"\\n\");\n\tprintk(\"Sequencer On QFreeze and Complete list: \");\n\tscb_index = ahd_inw(ahd, COMPLETE_ON_QFREEZE_HEAD);\n\ti = 0;\n\twhile (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {\n\t\tahd_set_scbptr(ahd, scb_index);\n\t\tprintk(\"%d \", scb_index);\n\t\tscb_index = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);\n\t}\n\tprintk(\"\\n\");\n\tahd_set_scbptr(ahd, saved_scb_index);\n\tdffstat = ahd_inb(ahd, DFFSTAT);\n\tfor (i = 0; i < 2; i++) {\n#ifdef AHD_DEBUG\n\t\tstruct scb *fifo_scb;\n#endif\n\t\tu_int\t    fifo_scbptr;\n\n\t\tahd_set_modes(ahd, AHD_MODE_DFF0 + i, AHD_MODE_DFF0 + i);\n\t\tfifo_scbptr = ahd_get_scbptr(ahd);\n\t\tprintk(\"\\n\\n%s: FIFO%d %s, LONGJMP == 0x%x, SCB 0x%x\\n\",\n\t\t       ahd_name(ahd), i,\n\t\t       (dffstat & (FIFO0FREE << i)) ? \"Free\" : \"Active\",\n\t\t       ahd_inw(ahd, LONGJMP_ADDR), fifo_scbptr);\n\t\tcur_col = 0;\n\t\tahd_seqimode_print(ahd_inb(ahd, SEQIMODE), &cur_col, 50);\n\t\tahd_seqintsrc_print(ahd_inb(ahd, SEQINTSRC), &cur_col, 50);\n\t\tahd_dfcntrl_print(ahd_inb(ahd, DFCNTRL), &cur_col, 50);\n\t\tahd_dfstatus_print(ahd_inb(ahd, DFSTATUS), &cur_col, 50);\n\t\tahd_sg_cache_shadow_print(ahd_inb(ahd, SG_CACHE_SHADOW),\n\t\t\t\t\t  &cur_col, 50);\n\t\tahd_sg_state_print(ahd_inb(ahd, SG_STATE), &cur_col, 50);\n\t\tahd_dffsxfrctl_print(ahd_inb(ahd, DFFSXFRCTL), &cur_col, 50);\n\t\tahd_soffcnt_print(ahd_inb(ahd, SOFFCNT), &cur_col, 50);\n\t\tahd_mdffstat_print(ahd_inb(ahd, MDFFSTAT), &cur_col, 50);\n\t\tif (cur_col > 50) {\n\t\t\tprintk(\"\\n\");\n\t\t\tcur_col = 0;\n\t\t}\n\t\tcur_col += printk(\"SHADDR = 0x%x%x, SHCNT = 0x%x \",\n\t\t\t\t  ahd_inl(ahd, SHADDR+4),\n\t\t\t\t  ahd_inl(ahd, SHADDR),\n\t\t\t\t  (ahd_inb(ahd, SHCNT)\n\t\t\t\t| (ahd_inb(ahd, SHCNT + 1) << 8)\n\t\t\t\t| (ahd_inb(ahd, SHCNT + 2) << 16)));\n\t\tif (cur_col > 50) {\n\t\t\tprintk(\"\\n\");\n\t\t\tcur_col = 0;\n\t\t}\n\t\tcur_col += printk(\"HADDR = 0x%x%x, HCNT = 0x%x \",\n\t\t\t\t  ahd_inl(ahd, HADDR+4),\n\t\t\t\t  ahd_inl(ahd, HADDR),\n\t\t\t\t  (ahd_inb(ahd, HCNT)\n\t\t\t\t| (ahd_inb(ahd, HCNT + 1) << 8)\n\t\t\t\t| (ahd_inb(ahd, HCNT + 2) << 16)));\n\t\tahd_ccsgctl_print(ahd_inb(ahd, CCSGCTL), &cur_col, 50);\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_SG) != 0) {\n\t\t\tfifo_scb = ahd_lookup_scb(ahd, fifo_scbptr);\n\t\t\tif (fifo_scb != NULL)\n\t\t\t\tahd_dump_sglist(fifo_scb);\n\t\t}\n#endif\n\t}\n\tprintk(\"\\nLQIN: \");\n\tfor (i = 0; i < 20; i++)\n\t\tprintk(\"0x%x \", ahd_inb(ahd, LQIN + i));\n\tprintk(\"\\n\");\n\tahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\n\tprintk(\"%s: LQISTATE = 0x%x, LQOSTATE = 0x%x, OPTIONMODE = 0x%x\\n\",\n\t       ahd_name(ahd), ahd_inb(ahd, LQISTATE), ahd_inb(ahd, LQOSTATE),\n\t       ahd_inb(ahd, OPTIONMODE));\n\tprintk(\"%s: OS_SPACE_CNT = 0x%x MAXCMDCNT = 0x%x\\n\",\n\t       ahd_name(ahd), ahd_inb(ahd, OS_SPACE_CNT),\n\t       ahd_inb(ahd, MAXCMDCNT));\n\tprintk(\"%s: SAVED_SCSIID = 0x%x SAVED_LUN = 0x%x\\n\",\n\t       ahd_name(ahd), ahd_inb(ahd, SAVED_SCSIID),\n\t       ahd_inb(ahd, SAVED_LUN));\n\tahd_simode0_print(ahd_inb(ahd, SIMODE0), &cur_col, 50);\n\tprintk(\"\\n\");\n\tahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);\n\tcur_col = 0;\n\tahd_ccscbctl_print(ahd_inb(ahd, CCSCBCTL), &cur_col, 50);\n\tprintk(\"\\n\");\n\tahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);\n\tprintk(\"%s: REG0 == 0x%x, SINDEX = 0x%x, DINDEX = 0x%x\\n\",\n\t       ahd_name(ahd), ahd_inw(ahd, REG0), ahd_inw(ahd, SINDEX),\n\t       ahd_inw(ahd, DINDEX));\n\tprintk(\"%s: SCBPTR == 0x%x, SCB_NEXT == 0x%x, SCB_NEXT2 == 0x%x\\n\",\n\t       ahd_name(ahd), ahd_get_scbptr(ahd),\n\t       ahd_inw_scbram(ahd, SCB_NEXT),\n\t       ahd_inw_scbram(ahd, SCB_NEXT2));\n\tprintk(\"CDB %x %x %x %x %x %x\\n\",\n\t       ahd_inb_scbram(ahd, SCB_CDB_STORE),\n\t       ahd_inb_scbram(ahd, SCB_CDB_STORE+1),\n\t       ahd_inb_scbram(ahd, SCB_CDB_STORE+2),\n\t       ahd_inb_scbram(ahd, SCB_CDB_STORE+3),\n\t       ahd_inb_scbram(ahd, SCB_CDB_STORE+4),\n\t       ahd_inb_scbram(ahd, SCB_CDB_STORE+5));\n\tprintk(\"STACK:\");\n\tfor (i = 0; i < ahd->stack_size; i++) {\n\t\tahd->saved_stack[i] =\n\t\t    ahd_inb(ahd, STACK)|(ahd_inb(ahd, STACK) << 8);\n\t\tprintk(\" 0x%x\", ahd->saved_stack[i]);\n\t}\n\tfor (i = ahd->stack_size-1; i >= 0; i--) {\n\t\tahd_outb(ahd, STACK, ahd->saved_stack[i] & 0xFF);\n\t\tahd_outb(ahd, STACK, (ahd->saved_stack[i] >> 8) & 0xFF);\n\t}\n\tprintk(\"\\n<<<<<<<<<<<<<<<<< Dump Card State Ends >>>>>>>>>>>>>>>>>>\\n\");\n\tahd_restore_modes(ahd, saved_modes);\n\tif (paused == 0)\n\t\tahd_unpause(ahd);\n}\n\n#if 0\nvoid\nahd_dump_scbs(struct ahd_softc *ahd)\n{\n\tahd_mode_state saved_modes;\n\tu_int\t       saved_scb_index;\n\tint\t       i;\n\n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\tsaved_scb_index = ahd_get_scbptr(ahd);\n\tfor (i = 0; i < AHD_SCB_MAX; i++) {\n\t\tahd_set_scbptr(ahd, i);\n\t\tprintk(\"%3d\", i);\n\t\tprintk(\"(CTRL 0x%x ID 0x%x N 0x%x N2 0x%x SG 0x%x, RSG 0x%x)\\n\",\n\t\t       ahd_inb_scbram(ahd, SCB_CONTROL),\n\t\t       ahd_inb_scbram(ahd, SCB_SCSIID),\n\t\t       ahd_inw_scbram(ahd, SCB_NEXT),\n\t\t       ahd_inw_scbram(ahd, SCB_NEXT2),\n\t\t       ahd_inl_scbram(ahd, SCB_SGPTR),\n\t\t       ahd_inl_scbram(ahd, SCB_RESIDUAL_SGPTR));\n\t}\n\tprintk(\"\\n\");\n\tahd_set_scbptr(ahd, saved_scb_index);\n\tahd_restore_modes(ahd, saved_modes);\n}\n#endif   \n\n \n \nint\nahd_read_seeprom(struct ahd_softc *ahd, uint16_t *buf,\n\t\t u_int start_addr, u_int count, int bytestream)\n{\n\tu_int cur_addr;\n\tu_int end_addr;\n\tint   error;\n\n\t \n\terror = EINVAL;\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\n\tend_addr = start_addr + count;\n\tfor (cur_addr = start_addr; cur_addr < end_addr; cur_addr++) {\n\n\t\tahd_outb(ahd, SEEADR, cur_addr);\n\t\tahd_outb(ahd, SEECTL, SEEOP_READ | SEESTART);\n\n\t\terror = ahd_wait_seeprom(ahd);\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (bytestream != 0) {\n\t\t\tuint8_t *bytestream_ptr;\n\n\t\t\tbytestream_ptr = (uint8_t *)buf;\n\t\t\t*bytestream_ptr++ = ahd_inb(ahd, SEEDAT);\n\t\t\t*bytestream_ptr = ahd_inb(ahd, SEEDAT+1);\n\t\t} else {\n\t\t\t \n\t\t\t*buf = ahd_inw(ahd, SEEDAT);\n\t\t}\n\t\tbuf++;\n\t}\n\treturn (error);\n}\n\n \nint\nahd_write_seeprom(struct ahd_softc *ahd, uint16_t *buf,\n\t\t  u_int start_addr, u_int count)\n{\n\tu_int cur_addr;\n\tu_int end_addr;\n\tint   error;\n\tint   retval;\n\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\n\terror = ENOENT;\n\n\t \n\tahd_outb(ahd, SEEADR, SEEOP_EWEN_ADDR);\n\tahd_outb(ahd, SEECTL, SEEOP_EWEN | SEESTART);\n\terror = ahd_wait_seeprom(ahd);\n\tif (error)\n\t\treturn (error);\n\n\t \n\tretval = EINVAL;\n\tend_addr = start_addr + count;\n\tfor (cur_addr = start_addr; cur_addr < end_addr; cur_addr++) {\n\t\tahd_outw(ahd, SEEDAT, *buf++);\n\t\tahd_outb(ahd, SEEADR, cur_addr);\n\t\tahd_outb(ahd, SEECTL, SEEOP_WRITE | SEESTART);\n\n\t\tretval = ahd_wait_seeprom(ahd);\n\t\tif (retval)\n\t\t\tbreak;\n\t}\n\n\t \n\tahd_outb(ahd, SEEADR, SEEOP_EWDS_ADDR);\n\tahd_outb(ahd, SEECTL, SEEOP_EWDS | SEESTART);\n\terror = ahd_wait_seeprom(ahd);\n\tif (error)\n\t\treturn (error);\n\treturn (retval);\n}\n\n \nstatic int\nahd_wait_seeprom(struct ahd_softc *ahd)\n{\n\tint cnt;\n\n\tcnt = 5000;\n\twhile ((ahd_inb(ahd, SEESTAT) & (SEEARBACK|SEEBUSY)) != 0 && --cnt)\n\t\tahd_delay(5);\n\n\tif (cnt == 0)\n\t\treturn (ETIMEDOUT);\n\treturn (0);\n}\n\n \nstatic int\nahd_verify_vpd_cksum(struct vpd_config *vpd)\n{\n\tint i;\n\tint maxaddr;\n\tuint32_t checksum;\n\tuint8_t *vpdarray;\n\n\tvpdarray = (uint8_t *)vpd;\n\tmaxaddr = offsetof(struct vpd_config, vpd_checksum);\n\tchecksum = 0;\n\tfor (i = offsetof(struct vpd_config, resource_type); i < maxaddr; i++)\n\t\tchecksum = checksum + vpdarray[i];\n\tif (checksum == 0\n\t || (-checksum & 0xFF) != vpd->vpd_checksum)\n\t\treturn (0);\n\n\tchecksum = 0;\n\tmaxaddr = offsetof(struct vpd_config, checksum);\n\tfor (i = offsetof(struct vpd_config, default_target_flags);\n\t     i < maxaddr; i++)\n\t\tchecksum = checksum + vpdarray[i];\n\tif (checksum == 0\n\t || (-checksum & 0xFF) != vpd->checksum)\n\t\treturn (0);\n\treturn (1);\n}\n\nint\nahd_verify_cksum(struct seeprom_config *sc)\n{\n\tint i;\n\tint maxaddr;\n\tuint32_t checksum;\n\tuint16_t *scarray;\n\n\tmaxaddr = (sizeof(*sc)/2) - 1;\n\tchecksum = 0;\n\tscarray = (uint16_t *)sc;\n\n\tfor (i = 0; i < maxaddr; i++)\n\t\tchecksum = checksum + scarray[i];\n\tif (checksum == 0\n\t || (checksum & 0xFFFF) != sc->checksum) {\n\t\treturn (0);\n\t} else {\n\t\treturn (1);\n\t}\n}\n\nint\nahd_acquire_seeprom(struct ahd_softc *ahd)\n{\n\t \n\treturn (1);\n#if 0\n\tuint8_t\tseetype;\n\tint\terror;\n\n\terror = ahd_read_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, &seetype);\n\tif (error != 0\n\t    || ((seetype & FLX_ROMSTAT_SEECFG) == FLX_ROMSTAT_SEE_NONE))\n\t\treturn (0);\n\treturn (1);\n#endif\n}\n\nvoid\nahd_release_seeprom(struct ahd_softc *ahd)\n{\n\t \n}\n\n \nstatic int\nahd_wait_flexport(struct ahd_softc *ahd)\n{\n\tint cnt;\n\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\n\tcnt = 1000000 * 2 / 5;\n\twhile ((ahd_inb(ahd, BRDCTL) & FLXARBACK) == 0 && --cnt)\n\t\tahd_delay(5);\n\n\tif (cnt == 0)\n\t\treturn (ETIMEDOUT);\n\treturn (0);\n}\n\nint\nahd_write_flexport(struct ahd_softc *ahd, u_int addr, u_int value)\n{\n\tint error;\n\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\n\tif (addr > 7)\n\t\tpanic(\"ahd_write_flexport: address out of range\");\n\tahd_outb(ahd, BRDCTL, BRDEN|(addr << 3));\n\terror = ahd_wait_flexport(ahd);\n\tif (error != 0)\n\t\treturn (error);\n\tahd_outb(ahd, BRDDAT, value);\n\tahd_flush_device_writes(ahd);\n\tahd_outb(ahd, BRDCTL, BRDSTB|BRDEN|(addr << 3));\n\tahd_flush_device_writes(ahd);\n\tahd_outb(ahd, BRDCTL, BRDEN|(addr << 3));\n\tahd_flush_device_writes(ahd);\n\tahd_outb(ahd, BRDCTL, 0);\n\tahd_flush_device_writes(ahd);\n\treturn (0);\n}\n\nint\nahd_read_flexport(struct ahd_softc *ahd, u_int addr, uint8_t *value)\n{\n\tint\terror;\n\n\tAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\n\tif (addr > 7)\n\t\tpanic(\"ahd_read_flexport: address out of range\");\n\tahd_outb(ahd, BRDCTL, BRDRW|BRDEN|(addr << 3));\n\terror = ahd_wait_flexport(ahd);\n\tif (error != 0)\n\t\treturn (error);\n\t*value = ahd_inb(ahd, BRDDAT);\n\tahd_outb(ahd, BRDCTL, 0);\n\tahd_flush_device_writes(ahd);\n\treturn (0);\n}\n\n \n#ifdef AHD_TARGET_MODE\ncam_status\nahd_find_tmode_devs(struct ahd_softc *ahd, struct cam_sim *sim, union ccb *ccb,\n\t\t    struct ahd_tmode_tstate **tstate,\n\t\t    struct ahd_tmode_lstate **lstate,\n\t\t    int notfound_failure)\n{\n\n\tif ((ahd->features & AHD_TARGETMODE) == 0)\n\t\treturn (CAM_REQ_INVALID);\n\n\t \n\tif (ccb->ccb_h.target_id == CAM_TARGET_WILDCARD\n\t && ccb->ccb_h.target_lun == CAM_LUN_WILDCARD) {\n\t\t*tstate = NULL;\n\t\t*lstate = ahd->black_hole;\n\t} else {\n\t\tu_int max_id;\n\n\t\tmax_id = (ahd->features & AHD_WIDE) ? 16 : 8;\n\t\tif (ccb->ccb_h.target_id >= max_id)\n\t\t\treturn (CAM_TID_INVALID);\n\n\t\tif (ccb->ccb_h.target_lun >= AHD_NUM_LUNS)\n\t\t\treturn (CAM_LUN_INVALID);\n\n\t\t*tstate = ahd->enabled_targets[ccb->ccb_h.target_id];\n\t\t*lstate = NULL;\n\t\tif (*tstate != NULL)\n\t\t\t*lstate =\n\t\t\t    (*tstate)->enabled_luns[ccb->ccb_h.target_lun];\n\t}\n\n\tif (notfound_failure != 0 && *lstate == NULL)\n\t\treturn (CAM_PATH_INVALID);\n\n\treturn (CAM_REQ_CMP);\n}\n\nvoid\nahd_handle_en_lun(struct ahd_softc *ahd, struct cam_sim *sim, union ccb *ccb)\n{\n#if NOT_YET\n\tstruct\t   ahd_tmode_tstate *tstate;\n\tstruct\t   ahd_tmode_lstate *lstate;\n\tstruct\t   ccb_en_lun *cel;\n\tcam_status status;\n\tu_int\t   target;\n\tu_int\t   lun;\n\tu_int\t   target_mask;\n\tu_long\t   s;\n\tchar\t   channel;\n\n\tstatus = ahd_find_tmode_devs(ahd, sim, ccb, &tstate, &lstate,\n\t\t\t\t      FALSE);\n\n\tif (status != CAM_REQ_CMP) {\n\t\tccb->ccb_h.status = status;\n\t\treturn;\n\t}\n\n\tif ((ahd->features & AHD_MULTIROLE) != 0) {\n\t\tu_int\t   our_id;\n\n\t\tour_id = ahd->our_id;\n\t\tif (ccb->ccb_h.target_id != our_id) {\n\t\t\tif ((ahd->features & AHD_MULTI_TID) != 0\n\t\t\t && (ahd->flags & AHD_INITIATORROLE) != 0) {\n\t\t\t\t \n\t\t\t\tstatus = CAM_TID_INVALID;\n\t\t\t} else if ((ahd->flags & AHD_INITIATORROLE) != 0\n\t\t\t\t|| ahd->enabled_luns > 0) {\n\t\t\t\t \n\t\t\t\tstatus = CAM_TID_INVALID;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (status != CAM_REQ_CMP) {\n\t\tccb->ccb_h.status = status;\n\t\treturn;\n\t}\n\n\t \n\tif ((ahd->flags & AHD_TARGETROLE) == 0\n\t && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {\n\t\tu_long\ts;\n\n\t\tprintk(\"Configuring Target Mode\\n\");\n\t\tahd_lock(ahd, &s);\n\t\tif (LIST_FIRST(&ahd->pending_scbs) != NULL) {\n\t\t\tccb->ccb_h.status = CAM_BUSY;\n\t\t\tahd_unlock(ahd, &s);\n\t\t\treturn;\n\t\t}\n\t\tahd->flags |= AHD_TARGETROLE;\n\t\tif ((ahd->features & AHD_MULTIROLE) == 0)\n\t\t\tahd->flags &= ~AHD_INITIATORROLE;\n\t\tahd_pause(ahd);\n\t\tahd_loadseq(ahd);\n\t\tahd_restart(ahd);\n\t\tahd_unlock(ahd, &s);\n\t}\n\tcel = &ccb->cel;\n\ttarget = ccb->ccb_h.target_id;\n\tlun = ccb->ccb_h.target_lun;\n\tchannel = SIM_CHANNEL(ahd, sim);\n\ttarget_mask = 0x01 << target;\n\tif (channel == 'B')\n\t\ttarget_mask <<= 8;\n\n\tif (cel->enable != 0) {\n\t\tu_int scsiseq1;\n\n\t\t \n\t\tif (lstate != NULL) {\n\t\t\txpt_print_path(ccb->ccb_h.path);\n\t\t\tprintk(\"Lun already enabled\\n\");\n\t\t\tccb->ccb_h.status = CAM_LUN_ALRDY_ENA;\n\t\t\treturn;\n\t\t}\n\n\t\tif (cel->grp6_len != 0\n\t\t || cel->grp7_len != 0) {\n\t\t\t \n\t\t\tccb->ccb_h.status = CAM_REQ_INVALID;\n\t\t\tprintk(\"Non-zero Group Codes\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (target != CAM_TARGET_WILDCARD && tstate == NULL) {\n\t\t\ttstate = ahd_alloc_tstate(ahd, target, channel);\n\t\t\tif (tstate == NULL) {\n\t\t\t\txpt_print_path(ccb->ccb_h.path);\n\t\t\t\tprintk(\"Couldn't allocate tstate\\n\");\n\t\t\t\tccb->ccb_h.status = CAM_RESRC_UNAVAIL;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tlstate = kzalloc(sizeof(*lstate), GFP_ATOMIC);\n\t\tif (lstate == NULL) {\n\t\t\txpt_print_path(ccb->ccb_h.path);\n\t\t\tprintk(\"Couldn't allocate lstate\\n\");\n\t\t\tccb->ccb_h.status = CAM_RESRC_UNAVAIL;\n\t\t\treturn;\n\t\t}\n\t\tstatus = xpt_create_path(&lstate->path,  NULL,\n\t\t\t\t\t xpt_path_path_id(ccb->ccb_h.path),\n\t\t\t\t\t xpt_path_target_id(ccb->ccb_h.path),\n\t\t\t\t\t xpt_path_lun_id(ccb->ccb_h.path));\n\t\tif (status != CAM_REQ_CMP) {\n\t\t\tkfree(lstate);\n\t\t\txpt_print_path(ccb->ccb_h.path);\n\t\t\tprintk(\"Couldn't allocate path\\n\");\n\t\t\tccb->ccb_h.status = CAM_RESRC_UNAVAIL;\n\t\t\treturn;\n\t\t}\n\t\tSLIST_INIT(&lstate->accept_tios);\n\t\tSLIST_INIT(&lstate->immed_notifies);\n\t\tahd_lock(ahd, &s);\n\t\tahd_pause(ahd);\n\t\tif (target != CAM_TARGET_WILDCARD) {\n\t\t\ttstate->enabled_luns[lun] = lstate;\n\t\t\tahd->enabled_luns++;\n\n\t\t\tif ((ahd->features & AHD_MULTI_TID) != 0) {\n\t\t\t\tu_int targid_mask;\n\n\t\t\t\ttargid_mask = ahd_inw(ahd, TARGID);\n\t\t\t\ttargid_mask |= target_mask;\n\t\t\t\tahd_outw(ahd, TARGID, targid_mask);\n\t\t\t\tahd_update_scsiid(ahd, targid_mask);\n\t\t\t} else {\n\t\t\t\tu_int our_id;\n\t\t\t\tchar  channel;\n\n\t\t\t\tchannel = SIM_CHANNEL(ahd, sim);\n\t\t\t\tour_id = SIM_SCSI_ID(ahd, sim);\n\n\t\t\t\t \n\t\t\t\tif (target != our_id) {\n\t\t\t\t\tu_int sblkctl;\n\t\t\t\t\tchar  cur_channel;\n\t\t\t\t\tint   swap;\n\n\t\t\t\t\tsblkctl = ahd_inb(ahd, SBLKCTL);\n\t\t\t\t\tcur_channel = (sblkctl & SELBUSB)\n\t\t\t\t\t\t    ? 'B' : 'A';\n\t\t\t\t\tif ((ahd->features & AHD_TWIN) == 0)\n\t\t\t\t\t\tcur_channel = 'A';\n\t\t\t\t\tswap = cur_channel != channel;\n\t\t\t\t\tahd->our_id = target;\n\n\t\t\t\t\tif (swap)\n\t\t\t\t\t\tahd_outb(ahd, SBLKCTL,\n\t\t\t\t\t\t\t sblkctl ^ SELBUSB);\n\n\t\t\t\t\tahd_outb(ahd, SCSIID, target);\n\n\t\t\t\t\tif (swap)\n\t\t\t\t\t\tahd_outb(ahd, SBLKCTL, sblkctl);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tahd->black_hole = lstate;\n\t\t \n\t\tif (ahd->black_hole != NULL && ahd->enabled_luns > 0) {\n\t\t\tscsiseq1 = ahd_inb(ahd, SCSISEQ_TEMPLATE);\n\t\t\tscsiseq1 |= ENSELI;\n\t\t\tahd_outb(ahd, SCSISEQ_TEMPLATE, scsiseq1);\n\t\t\tscsiseq1 = ahd_inb(ahd, SCSISEQ1);\n\t\t\tscsiseq1 |= ENSELI;\n\t\t\tahd_outb(ahd, SCSISEQ1, scsiseq1);\n\t\t}\n\t\tahd_unpause(ahd);\n\t\tahd_unlock(ahd, &s);\n\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\txpt_print_path(ccb->ccb_h.path);\n\t\tprintk(\"Lun now enabled for target mode\\n\");\n\t} else {\n\t\tstruct scb *scb;\n\t\tint i, empty;\n\n\t\tif (lstate == NULL) {\n\t\t\tccb->ccb_h.status = CAM_LUN_INVALID;\n\t\t\treturn;\n\t\t}\n\n\t\tahd_lock(ahd, &s);\n\n\t\tccb->ccb_h.status = CAM_REQ_CMP;\n\t\tLIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {\n\t\t\tstruct ccb_hdr *ccbh;\n\n\t\t\tccbh = &scb->io_ctx->ccb_h;\n\t\t\tif (ccbh->func_code == XPT_CONT_TARGET_IO\n\t\t\t && !xpt_path_comp(ccbh->path, ccb->ccb_h.path)){\n\t\t\t\tprintk(\"CTIO pending\\n\");\n\t\t\t\tccb->ccb_h.status = CAM_REQ_INVALID;\n\t\t\t\tahd_unlock(ahd, &s);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (SLIST_FIRST(&lstate->accept_tios) != NULL) {\n\t\t\tprintk(\"ATIOs pending\\n\");\n\t\t\tccb->ccb_h.status = CAM_REQ_INVALID;\n\t\t}\n\n\t\tif (SLIST_FIRST(&lstate->immed_notifies) != NULL) {\n\t\t\tprintk(\"INOTs pending\\n\");\n\t\t\tccb->ccb_h.status = CAM_REQ_INVALID;\n\t\t}\n\n\t\tif (ccb->ccb_h.status != CAM_REQ_CMP) {\n\t\t\tahd_unlock(ahd, &s);\n\t\t\treturn;\n\t\t}\n\n\t\txpt_print_path(ccb->ccb_h.path);\n\t\tprintk(\"Target mode disabled\\n\");\n\t\txpt_free_path(lstate->path);\n\t\tkfree(lstate);\n\n\t\tahd_pause(ahd);\n\t\t \n\t\tif (target != CAM_TARGET_WILDCARD) {\n\t\t\ttstate->enabled_luns[lun] = NULL;\n\t\t\tahd->enabled_luns--;\n\t\t\tfor (empty = 1, i = 0; i < 8; i++)\n\t\t\t\tif (tstate->enabled_luns[i] != NULL) {\n\t\t\t\t\tempty = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tif (empty) {\n\t\t\t\tahd_free_tstate(ahd, target, channel,\n\t\t\t\t\t\t FALSE);\n\t\t\t\tif (ahd->features & AHD_MULTI_TID) {\n\t\t\t\t\tu_int targid_mask;\n\n\t\t\t\t\ttargid_mask = ahd_inw(ahd, TARGID);\n\t\t\t\t\ttargid_mask &= ~target_mask;\n\t\t\t\t\tahd_outw(ahd, TARGID, targid_mask);\n\t\t\t\t\tahd_update_scsiid(ahd, targid_mask);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\n\t\t\tahd->black_hole = NULL;\n\n\t\t\t \n\t\t\tempty = TRUE;\n\t\t}\n\t\tif (ahd->enabled_luns == 0) {\n\t\t\t \n\t\t\tu_int scsiseq1;\n\n\t\t\tscsiseq1 = ahd_inb(ahd, SCSISEQ_TEMPLATE);\n\t\t\tscsiseq1 &= ~ENSELI;\n\t\t\tahd_outb(ahd, SCSISEQ_TEMPLATE, scsiseq1);\n\t\t\tscsiseq1 = ahd_inb(ahd, SCSISEQ1);\n\t\t\tscsiseq1 &= ~ENSELI;\n\t\t\tahd_outb(ahd, SCSISEQ1, scsiseq1);\n\n\t\t\tif ((ahd->features & AHD_MULTIROLE) == 0) {\n\t\t\t\tprintk(\"Configuring Initiator Mode\\n\");\n\t\t\t\tahd->flags &= ~AHD_TARGETROLE;\n\t\t\t\tahd->flags |= AHD_INITIATORROLE;\n\t\t\t\tahd_pause(ahd);\n\t\t\t\tahd_loadseq(ahd);\n\t\t\t\tahd_restart(ahd);\n\t\t\t\t \n\t\t\t}\n\t\t}\n\t\tahd_unpause(ahd);\n\t\tahd_unlock(ahd, &s);\n\t}\n#endif\n}\n\nstatic void\nahd_update_scsiid(struct ahd_softc *ahd, u_int targid_mask)\n{\n#if NOT_YET\n\tu_int scsiid_mask;\n\tu_int scsiid;\n\n\tif ((ahd->features & AHD_MULTI_TID) == 0)\n\t\tpanic(\"ahd_update_scsiid called on non-multitid unit\\n\");\n\n\t \n\tif ((ahd->features & AHD_ULTRA2) != 0)\n\t\tscsiid = ahd_inb(ahd, SCSIID_ULTRA2);\n\telse\n\t\tscsiid = ahd_inb(ahd, SCSIID);\n\tscsiid_mask = 0x1 << (scsiid & OID);\n\tif ((targid_mask & scsiid_mask) == 0) {\n\t\tu_int our_id;\n\n\t\t \n\t\tour_id = ffs(targid_mask);\n\t\tif (our_id == 0)\n\t\t\tour_id = ahd->our_id;\n\t\telse\n\t\t\tour_id--;\n\t\tscsiid &= TID;\n\t\tscsiid |= our_id;\n\t}\n\tif ((ahd->features & AHD_ULTRA2) != 0)\n\t\tahd_outb(ahd, SCSIID_ULTRA2, scsiid);\n\telse\n\t\tahd_outb(ahd, SCSIID, scsiid);\n#endif\n}\n\nstatic void\nahd_run_tqinfifo(struct ahd_softc *ahd, int paused)\n{\n\tstruct target_cmd *cmd;\n\n\tahd_sync_tqinfifo(ahd, BUS_DMASYNC_POSTREAD);\n\twhile ((cmd = &ahd->targetcmds[ahd->tqinfifonext])->cmd_valid != 0) {\n\n\t\t \n\t\tif (ahd_handle_target_cmd(ahd, cmd) != 0)\n\t\t\tbreak;\n\n\t\tcmd->cmd_valid = 0;\n\t\tahd_dmamap_sync(ahd, ahd->shared_data_dmat,\n\t\t\t\tahd->shared_data_map.dmamap,\n\t\t\t\tahd_targetcmd_offset(ahd, ahd->tqinfifonext),\n\t\t\t\tsizeof(struct target_cmd),\n\t\t\t\tBUS_DMASYNC_PREREAD);\n\t\tahd->tqinfifonext++;\n\n\t\t \n\t\tif ((ahd->tqinfifonext & (HOST_TQINPOS - 1)) == 1) {\n\t\t\tu_int hs_mailbox;\n\n\t\t\ths_mailbox = ahd_inb(ahd, HS_MAILBOX);\n\t\t\ths_mailbox &= ~HOST_TQINPOS;\n\t\t\ths_mailbox |= ahd->tqinfifonext & HOST_TQINPOS;\n\t\t\tahd_outb(ahd, HS_MAILBOX, hs_mailbox);\n\t\t}\n\t}\n}\n\nstatic int\nahd_handle_target_cmd(struct ahd_softc *ahd, struct target_cmd *cmd)\n{\n\tstruct\t  ahd_tmode_tstate *tstate;\n\tstruct\t  ahd_tmode_lstate *lstate;\n\tstruct\t  ccb_accept_tio *atio;\n\tuint8_t *byte;\n\tint\t  initiator;\n\tint\t  target;\n\tint\t  lun;\n\n\tinitiator = SCSIID_TARGET(ahd, cmd->scsiid);\n\ttarget = SCSIID_OUR_ID(cmd->scsiid);\n\tlun    = (cmd->identify & MSG_IDENTIFY_LUNMASK);\n\n\tbyte = cmd->bytes;\n\ttstate = ahd->enabled_targets[target];\n\tlstate = NULL;\n\tif (tstate != NULL)\n\t\tlstate = tstate->enabled_luns[lun];\n\n\t \n\tif (lstate == NULL)\n\t\tlstate = ahd->black_hole;\n\n\tatio = (struct ccb_accept_tio*)SLIST_FIRST(&lstate->accept_tios);\n\tif (atio == NULL) {\n\t\tahd->flags |= AHD_TQINFIFO_BLOCKED;\n\t\t \n\t\treturn (1);\n\t} else\n\t\tahd->flags &= ~AHD_TQINFIFO_BLOCKED;\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_TQIN) != 0)\n\t\tprintk(\"Incoming command from %d for %d:%d%s\\n\",\n\t\t       initiator, target, lun,\n\t\t       lstate == ahd->black_hole ? \"(Black Holed)\" : \"\");\n#endif\n\tSLIST_REMOVE_HEAD(&lstate->accept_tios, sim_links.sle);\n\n\tif (lstate == ahd->black_hole) {\n\t\t \n\t\tatio->ccb_h.target_id = target;\n\t\tatio->ccb_h.target_lun = lun;\n\t}\n\n\t \n\tatio->sense_len = 0;\n\tatio->init_id = initiator;\n\tif (byte[0] != 0xFF) {\n\t\t \n\t\tatio->tag_action = *byte++;\n\t\tatio->tag_id = *byte++;\n\t\tatio->ccb_h.flags = CAM_TAG_ACTION_VALID;\n\t} else {\n\t\tatio->ccb_h.flags = 0;\n\t}\n\tbyte++;\n\n\t \n\tswitch (*byte >> CMD_GROUP_CODE_SHIFT) {\n\tcase 0:\n\t\tatio->cdb_len = 6;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\t\tatio->cdb_len = 10;\n\t\tbreak;\n\tcase 4:\n\t\tatio->cdb_len = 16;\n\t\tbreak;\n\tcase 5:\n\t\tatio->cdb_len = 12;\n\t\tbreak;\n\tcase 3:\n\tdefault:\n\t\t \n\t\tatio->cdb_len = 1;\n\t\tprintk(\"Reserved or VU command code type encountered\\n\");\n\t\tbreak;\n\t}\n\n\tmemcpy(atio->cdb_io.cdb_bytes, byte, atio->cdb_len);\n\n\tatio->ccb_h.status |= CAM_CDB_RECVD;\n\n\tif ((cmd->identify & MSG_IDENTIFY_DISCFLAG) == 0) {\n\t\t \n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_TQIN) != 0)\n\t\t\tprintk(\"Received Immediate Command %d:%d:%d - %p\\n\",\n\t\t\t       initiator, target, lun, ahd->pending_device);\n#endif\n\t\tahd->pending_device = lstate;\n\t\tahd_freeze_ccb((union ccb *)atio);\n\t\tatio->ccb_h.flags |= CAM_DIS_DISCONNECT;\n\t}\n\txpt_done((union ccb*)atio);\n\treturn (0);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}