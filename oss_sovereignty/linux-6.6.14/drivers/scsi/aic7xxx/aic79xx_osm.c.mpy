{
  "module_name": "aic79xx_osm.c",
  "hash_id": "f0abcc1a399460b01df2036475189b782041a4b56675f5a55eab56a7c47863ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic79xx_osm.c",
  "human_readable_source": " \n\n#include \"aic79xx_osm.h\"\n#include \"aic79xx_inline.h\"\n#include <scsi/scsicam.h>\n\nstatic struct scsi_transport_template *ahd_linux_transport_template = NULL;\n\n#include <linux/init.h>\t\t \n#include <linux/mm.h>\t\t \n#include <linux/blkdev.h>\t\t \n#include <linux/delay.h>\t \n#include <linux/device.h>\n#include <linux/slab.h>\n\n \n#define AHD_LINUX_ERR_THRESH\t1000\n\n \n#ifdef CONFIG_AIC79XX_RESET_DELAY_MS\n#define AIC79XX_RESET_DELAY CONFIG_AIC79XX_RESET_DELAY_MS\n#else\n#define AIC79XX_RESET_DELAY 5000\n#endif\n\n \ntypedef struct {\n\tuint16_t tag_commands[16];\t \n} adapter_tag_info_t;\n\n \n\n \n\n#ifdef CONFIG_AIC79XX_CMDS_PER_DEVICE\n#define AIC79XX_CMDS_PER_DEVICE CONFIG_AIC79XX_CMDS_PER_DEVICE\n#else\n#define AIC79XX_CMDS_PER_DEVICE AHD_MAX_QUEUE\n#endif\n\n#define AIC79XX_CONFIGED_TAG_COMMANDS {\t\t\t\t\t\\\n\tAIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,\t\t\\\n\tAIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,\t\t\\\n\tAIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,\t\t\\\n\tAIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,\t\t\\\n\tAIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,\t\t\\\n\tAIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,\t\t\\\n\tAIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,\t\t\\\n\tAIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE\t\t\\\n}\n\n \nstatic adapter_tag_info_t aic79xx_tag_info[] =\n{\n\t{AIC79XX_CONFIGED_TAG_COMMANDS},\n\t{AIC79XX_CONFIGED_TAG_COMMANDS},\n\t{AIC79XX_CONFIGED_TAG_COMMANDS},\n\t{AIC79XX_CONFIGED_TAG_COMMANDS},\n\t{AIC79XX_CONFIGED_TAG_COMMANDS},\n\t{AIC79XX_CONFIGED_TAG_COMMANDS},\n\t{AIC79XX_CONFIGED_TAG_COMMANDS},\n\t{AIC79XX_CONFIGED_TAG_COMMANDS},\n\t{AIC79XX_CONFIGED_TAG_COMMANDS},\n\t{AIC79XX_CONFIGED_TAG_COMMANDS},\n\t{AIC79XX_CONFIGED_TAG_COMMANDS},\n\t{AIC79XX_CONFIGED_TAG_COMMANDS},\n\t{AIC79XX_CONFIGED_TAG_COMMANDS},\n\t{AIC79XX_CONFIGED_TAG_COMMANDS},\n\t{AIC79XX_CONFIGED_TAG_COMMANDS},\n\t{AIC79XX_CONFIGED_TAG_COMMANDS}\n};\n\n \nstruct ahd_linux_iocell_opts\n{\n\tuint8_t\tprecomp;\n\tuint8_t\tslewrate;\n\tuint8_t amplitude;\n};\n#define AIC79XX_DEFAULT_PRECOMP\t\t0xFF\n#define AIC79XX_DEFAULT_SLEWRATE\t0xFF\n#define AIC79XX_DEFAULT_AMPLITUDE\t0xFF\n#define AIC79XX_DEFAULT_IOOPTS\t\t\t\\\n{\t\t\t\t\t\t\\\n\tAIC79XX_DEFAULT_PRECOMP,\t\t\\\n\tAIC79XX_DEFAULT_SLEWRATE,\t\t\\\n\tAIC79XX_DEFAULT_AMPLITUDE\t\t\\\n}\n#define AIC79XX_PRECOMP_INDEX\t0\n#define AIC79XX_SLEWRATE_INDEX\t1\n#define AIC79XX_AMPLITUDE_INDEX\t2\nstatic struct ahd_linux_iocell_opts aic79xx_iocell_info[] __ro_after_init =\n{\n\tAIC79XX_DEFAULT_IOOPTS,\n\tAIC79XX_DEFAULT_IOOPTS,\n\tAIC79XX_DEFAULT_IOOPTS,\n\tAIC79XX_DEFAULT_IOOPTS,\n\tAIC79XX_DEFAULT_IOOPTS,\n\tAIC79XX_DEFAULT_IOOPTS,\n\tAIC79XX_DEFAULT_IOOPTS,\n\tAIC79XX_DEFAULT_IOOPTS,\n\tAIC79XX_DEFAULT_IOOPTS,\n\tAIC79XX_DEFAULT_IOOPTS,\n\tAIC79XX_DEFAULT_IOOPTS,\n\tAIC79XX_DEFAULT_IOOPTS,\n\tAIC79XX_DEFAULT_IOOPTS,\n\tAIC79XX_DEFAULT_IOOPTS,\n\tAIC79XX_DEFAULT_IOOPTS,\n\tAIC79XX_DEFAULT_IOOPTS\n};\n\n \n#define DID_UNDERFLOW   DID_ERROR\n\nvoid\nahd_print_path(struct ahd_softc *ahd, struct scb *scb)\n{\n\tprintk(\"(scsi%d:%c:%d:%d): \",\n\t       ahd->platform_data->host->host_no,\n\t       scb != NULL ? SCB_GET_CHANNEL(ahd, scb) : 'X',\n\t       scb != NULL ? SCB_GET_TARGET(ahd, scb) : -1,\n\t       scb != NULL ? SCB_GET_LUN(scb) : -1);\n}\n\n \n\n \nstatic uint32_t aic79xx_no_reset;\n\n \nstatic uint32_t aic79xx_extended;\n\n \nstatic uint32_t aic79xx_pci_parity = ~0;\n\n \nuint32_t aic79xx_allow_memio = ~0;\n\n \nstatic uint32_t aic79xx_seltime;\n\n \nstatic uint32_t aic79xx_periodic_otag;\n\n \nuint32_t aic79xx_slowcrc;\n\n \nstatic char *aic79xx = NULL;\n\nMODULE_AUTHOR(\"Maintainer: Hannes Reinecke <hare@suse.de>\");\nMODULE_DESCRIPTION(\"Adaptec AIC790X U320 SCSI Host Bus Adapter driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_VERSION(AIC79XX_DRIVER_VERSION);\nmodule_param(aic79xx, charp, 0444);\nMODULE_PARM_DESC(aic79xx,\n\"period-delimited options string:\\n\"\n\"\tverbose\t\t\tEnable verbose/diagnostic logging\\n\"\n\"\tallow_memio\t\tAllow device registers to be memory mapped\\n\"\n\"\tdebug\t\t\tBitmask of debug values to enable\\n\"\n\"\tno_reset\t\tSuppress initial bus resets\\n\"\n\"\textended\t\tEnable extended geometry on all controllers\\n\"\n\"\tperiodic_otag\t\tSend an ordered tagged transaction\\n\"\n\"\t\t\t\tperiodically to prevent tag starvation.\\n\"\n\"\t\t\t\tThis may be required by some older disk\\n\"\n\"\t\t\t\tor drives/RAID arrays.\\n\"\n\"\ttag_info:<tag_str>\tSet per-target tag depth\\n\"\n\"\tglobal_tag_depth:<int>\tGlobal tag depth for all targets on all buses\\n\"\n\"\tslewrate:<slewrate_list>Set the signal slew rate (0-15).\\n\"\n\"\tprecomp:<pcomp_list>\tSet the signal precompensation (0-7).\\n\"\n\"\tamplitude:<int>\t\tSet the signal amplitude (0-7).\\n\"\n\"\tseltime:<int>\t\tSelection Timeout:\\n\"\n\"\t\t\t\t(0/256ms,1/128ms,2/64ms,3/32ms)\\n\"\n\"\tslowcrc\t\t\tTurn on the SLOWCRC bit (Rev B only)\\n\"\t\t \n\"\\n\"\n\"\tSample modprobe configuration file:\\n\"\n\"\t#\tEnable verbose logging\\n\"\n\"\t#\tSet tag depth on Controller 2/Target 2 to 10 tags\\n\"\n\"\t#\tShorten the selection timeout to 128ms\\n\"\n\"\\n\"\n\"\toptions aic79xx 'aic79xx=verbose.tag_info:{{}.{}.{..10}}.seltime:1'\\n\"\n);\n\nstatic void ahd_linux_handle_scsi_status(struct ahd_softc *,\n\t\t\t\t\t struct scsi_device *,\n\t\t\t\t\t struct scb *);\nstatic void ahd_linux_queue_cmd_complete(struct ahd_softc *ahd,\n\t\t\t\t\t struct scsi_cmnd *cmd);\nstatic int ahd_linux_queue_abort_cmd(struct scsi_cmnd *cmd);\nstatic void ahd_linux_initialize_scsi_bus(struct ahd_softc *ahd);\nstatic u_int ahd_linux_user_tagdepth(struct ahd_softc *ahd,\n\t\t\t\t     struct ahd_devinfo *devinfo);\nstatic void ahd_linux_device_queue_depth(struct scsi_device *);\nstatic int ahd_linux_run_command(struct ahd_softc*,\n\t\t\t\t struct ahd_linux_device *,\n\t\t\t\t struct scsi_cmnd *);\nstatic void ahd_linux_setup_tag_info_global(char *p);\nstatic int  aic79xx_setup(char *c);\nstatic void ahd_freeze_simq(struct ahd_softc *ahd);\nstatic void ahd_release_simq(struct ahd_softc *ahd);\n\nstatic int ahd_linux_unit;\n\n\n \nvoid ahd_delay(long);\nvoid\nahd_delay(long usec)\n{\n\t \n\twhile (usec > 0) {\n\t\tudelay(usec % 1024);\n\t\tusec -= 1024;\n\t}\n}\n\n\n \nuint8_t ahd_inb(struct ahd_softc * ahd, long port);\nvoid ahd_outb(struct ahd_softc * ahd, long port, uint8_t val);\nvoid ahd_outw_atomic(struct ahd_softc * ahd,\n\t\t\t\t     long port, uint16_t val);\nvoid ahd_outsb(struct ahd_softc * ahd, long port,\n\t\t\t       uint8_t *, int count);\nvoid ahd_insb(struct ahd_softc * ahd, long port,\n\t\t\t       uint8_t *, int count);\n\nuint8_t\nahd_inb(struct ahd_softc * ahd, long port)\n{\n\tuint8_t x;\n\n\tif (ahd->tags[0] == BUS_SPACE_MEMIO) {\n\t\tx = readb(ahd->bshs[0].maddr + port);\n\t} else {\n\t\tx = inb(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));\n\t}\n\tmb();\n\treturn (x);\n}\n\n#if 0  \nstatic uint16_t\nahd_inw_atomic(struct ahd_softc * ahd, long port)\n{\n\tuint8_t x;\n\n\tif (ahd->tags[0] == BUS_SPACE_MEMIO) {\n\t\tx = readw(ahd->bshs[0].maddr + port);\n\t} else {\n\t\tx = inw(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));\n\t}\n\tmb();\n\treturn (x);\n}\n#endif\n\nvoid\nahd_outb(struct ahd_softc * ahd, long port, uint8_t val)\n{\n\tif (ahd->tags[0] == BUS_SPACE_MEMIO) {\n\t\twriteb(val, ahd->bshs[0].maddr + port);\n\t} else {\n\t\toutb(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));\n\t}\n\tmb();\n}\n\nvoid\nahd_outw_atomic(struct ahd_softc * ahd, long port, uint16_t val)\n{\n\tif (ahd->tags[0] == BUS_SPACE_MEMIO) {\n\t\twritew(val, ahd->bshs[0].maddr + port);\n\t} else {\n\t\toutw(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));\n\t}\n\tmb();\n}\n\nvoid\nahd_outsb(struct ahd_softc * ahd, long port, uint8_t *array, int count)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < count; i++)\n\t\tahd_outb(ahd, port, *array++);\n}\n\nvoid\nahd_insb(struct ahd_softc * ahd, long port, uint8_t *array, int count)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < count; i++)\n\t\t*array++ = ahd_inb(ahd, port);\n}\n\n \nuint32_t\nahd_pci_read_config(ahd_dev_softc_t pci, int reg, int width)\n{\n\tswitch (width) {\n\tcase 1:\n\t{\n\t\tuint8_t retval;\n\n\t\tpci_read_config_byte(pci, reg, &retval);\n\t\treturn (retval);\n\t}\n\tcase 2:\n\t{\n\t\tuint16_t retval;\n\t\tpci_read_config_word(pci, reg, &retval);\n\t\treturn (retval);\n\t}\n\tcase 4:\n\t{\n\t\tuint32_t retval;\n\t\tpci_read_config_dword(pci, reg, &retval);\n\t\treturn (retval);\n\t}\n\tdefault:\n\t\tpanic(\"ahd_pci_read_config: Read size too big\");\n\t\t \n\t\treturn (0);\n\t}\n}\n\nvoid\nahd_pci_write_config(ahd_dev_softc_t pci, int reg, uint32_t value, int width)\n{\n\tswitch (width) {\n\tcase 1:\n\t\tpci_write_config_byte(pci, reg, value);\n\t\tbreak;\n\tcase 2:\n\t\tpci_write_config_word(pci, reg, value);\n\t\tbreak;\n\tcase 4:\n\t\tpci_write_config_dword(pci, reg, value);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"ahd_pci_write_config: Write size too big\");\n\t\t \n\t}\n}\n\n \nstatic void ahd_linux_unmap_scb(struct ahd_softc*, struct scb*);\n\nstatic void\nahd_linux_unmap_scb(struct ahd_softc *ahd, struct scb *scb)\n{\n\tstruct scsi_cmnd *cmd;\n\n\tcmd = scb->io_ctx;\n\tahd_sync_sglist(ahd, scb, BUS_DMASYNC_POSTWRITE);\n\tscsi_dma_unmap(cmd);\n}\n\n \n#define BUILD_SCSIID(ahd, cmd)\t\t\t\t\t\t\\\n\t(((scmd_id(cmd) << TID_SHIFT) & TID) | (ahd)->our_id)\n\n \nstatic const char *\nahd_linux_info(struct Scsi_Host *host)\n{\n\tstatic char buffer[512];\n\tchar\tahd_info[256];\n\tchar   *bp;\n\tstruct ahd_softc *ahd;\n\n\tbp = &buffer[0];\n\tahd = *(struct ahd_softc **)host->hostdata;\n\tmemset(bp, 0, sizeof(buffer));\n\tstrcpy(bp, \"Adaptec AIC79XX PCI-X SCSI HBA DRIVER, Rev \" AIC79XX_DRIVER_VERSION \"\\n\"\n\t\t\t\"        <\");\n\tstrcat(bp, ahd->description);\n\tstrcat(bp, \">\\n\"\n\t\t\t\"        \");\n\tahd_controller_info(ahd, ahd_info);\n\tstrcat(bp, ahd_info);\n\n\treturn (bp);\n}\n\n \nstatic int ahd_linux_queue_lck(struct scsi_cmnd *cmd)\n{\n\tstruct\t ahd_softc *ahd;\n\tstruct\t ahd_linux_device *dev = scsi_transport_device_data(cmd->device);\n\tint rtn = SCSI_MLQUEUE_HOST_BUSY;\n\n\tahd = *(struct ahd_softc **)cmd->device->host->hostdata;\n\n\tcmd->result = CAM_REQ_INPROG << 16;\n\trtn = ahd_linux_run_command(ahd, dev, cmd);\n\n\treturn rtn;\n}\n\nstatic DEF_SCSI_QCMD(ahd_linux_queue)\n\nstatic struct scsi_target **\nahd_linux_target_in_softc(struct scsi_target *starget)\n{\n\tstruct\tahd_softc *ahd =\n\t\t*((struct ahd_softc **)dev_to_shost(&starget->dev)->hostdata);\n\tunsigned int target_offset;\n\n\ttarget_offset = starget->id;\n\tif (starget->channel != 0)\n\t\ttarget_offset += 8;\n\n\treturn &ahd->platform_data->starget[target_offset];\n}\n\nstatic int\nahd_linux_target_alloc(struct scsi_target *starget)\n{\n\tstruct\tahd_softc *ahd =\n\t\t*((struct ahd_softc **)dev_to_shost(&starget->dev)->hostdata);\n\tstruct seeprom_config *sc = ahd->seep_config;\n\tunsigned long flags;\n\tstruct scsi_target **ahd_targp = ahd_linux_target_in_softc(starget);\n\tstruct ahd_devinfo devinfo;\n\tstruct ahd_initiator_tinfo *tinfo;\n\tstruct ahd_tmode_tstate *tstate;\n\tchar channel = starget->channel + 'A';\n\n\tahd_lock(ahd, &flags);\n\n\tBUG_ON(*ahd_targp != NULL);\n\n\t*ahd_targp = starget;\n\n\tif (sc) {\n\t\tint flags = sc->device_flags[starget->id];\n\n\t\ttinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,\n\t\t\t\t\t    starget->id, &tstate);\n\n\t\tif ((flags  & CFPACKETIZED) == 0) {\n\t\t\t \n\t\t\tspi_max_iu(starget) = 0;\n\t\t} else {\n\t\t\tif ((ahd->features & AHD_RTI) == 0)\n\t\t\t\tspi_rti(starget) = 0;\n\t\t}\n\n\t\tif ((flags & CFQAS) == 0)\n\t\t\tspi_max_qas(starget) = 0;\n\n\t\t \n\t\tspi_max_width(starget) = (flags & CFWIDEB) ? 1 : 0;\n\t\tspi_min_period(starget) = tinfo->user.period;\n\t\tspi_max_offset(starget) = tinfo->user.offset;\n\t}\n\n\ttinfo = ahd_fetch_transinfo(ahd, channel, ahd->our_id,\n\t\t\t\t    starget->id, &tstate);\n\tahd_compile_devinfo(&devinfo, ahd->our_id, starget->id,\n\t\t\t    CAM_LUN_WILDCARD, channel,\n\t\t\t    ROLE_INITIATOR);\n\tahd_set_syncrate(ahd, &devinfo, 0, 0, 0,\n\t\t\t AHD_TRANS_GOAL,  FALSE);\n\tahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t      AHD_TRANS_GOAL,  FALSE);\n\tahd_unlock(ahd, &flags);\n\n\treturn 0;\n}\n\nstatic void\nahd_linux_target_destroy(struct scsi_target *starget)\n{\n\tstruct scsi_target **ahd_targp = ahd_linux_target_in_softc(starget);\n\n\t*ahd_targp = NULL;\n}\n\nstatic int\nahd_linux_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct\tahd_softc *ahd =\n\t\t*((struct ahd_softc **)sdev->host->hostdata);\n\tstruct ahd_linux_device *dev;\n\n\tif (bootverbose)\n\t\tprintk(\"%s: Slave Alloc %d\\n\", ahd_name(ahd), sdev->id);\n\n\tdev = scsi_transport_device_data(sdev);\n\tmemset(dev, 0, sizeof(*dev));\n\n\t \n\tdev->openings = 1;\n\n\t \n\tdev->maxtags = 0;\n\t\n\treturn (0);\n}\n\nstatic int\nahd_linux_slave_configure(struct scsi_device *sdev)\n{\n\tif (bootverbose)\n\t\tsdev_printk(KERN_INFO, sdev, \"Slave Configure\\n\");\n\n\tahd_linux_device_queue_depth(sdev);\n\n\t \n\tif (!spi_initial_dv(sdev->sdev_target))\n\t\tspi_dv_device(sdev);\n\n\treturn 0;\n}\n\n#if defined(__i386__)\n \nstatic int\nahd_linux_biosparam(struct scsi_device *sdev, struct block_device *bdev,\n\t\t    sector_t capacity, int geom[])\n{\n\tint\t heads;\n\tint\t sectors;\n\tint\t cylinders;\n\tint\t extended;\n\tstruct\t ahd_softc *ahd;\n\n\tahd = *((struct ahd_softc **)sdev->host->hostdata);\n\n\tif (scsi_partsize(bdev, capacity, geom))\n\t\treturn 0;\n\n\theads = 64;\n\tsectors = 32;\n\tcylinders = aic_sector_div(capacity, heads, sectors);\n\n\tif (aic79xx_extended != 0)\n\t\textended = 1;\n\telse\n\t\textended = (ahd->flags & AHD_EXTENDED_TRANS_A) != 0;\n\tif (extended && cylinders >= 1024) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\tcylinders = aic_sector_div(capacity, heads, sectors);\n\t}\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\treturn (0);\n}\n#endif\n\n \nstatic int\nahd_linux_abort(struct scsi_cmnd *cmd)\n{\n\treturn ahd_linux_queue_abort_cmd(cmd);\n}\n\n \nstatic int\nahd_linux_dev_reset(struct scsi_cmnd *cmd)\n{\n\tstruct ahd_softc *ahd;\n\tstruct ahd_linux_device *dev;\n\tstruct scb *reset_scb;\n\tu_int  cdb_byte;\n\tint    retval = SUCCESS;\n\tstruct\tahd_initiator_tinfo *tinfo;\n\tstruct\tahd_tmode_tstate *tstate;\n\tunsigned long flags;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\treset_scb = NULL;\n\n\tahd = *(struct ahd_softc **)cmd->device->host->hostdata;\n\n\tscmd_printk(KERN_INFO, cmd,\n\t\t    \"Attempting to queue a TARGET RESET message:\");\n\n\tprintk(\"CDB:\");\n\tfor (cdb_byte = 0; cdb_byte < cmd->cmd_len; cdb_byte++)\n\t\tprintk(\" 0x%x\", cmd->cmnd[cdb_byte]);\n\tprintk(\"\\n\");\n\n\t \n\tdev = scsi_transport_device_data(cmd->device);\n\n\tif (dev == NULL) {\n\t\t \n\t\tscmd_printk(KERN_INFO, cmd, \"Is not an active device\\n\");\n\t\treturn SUCCESS;\n\t}\n\n\t \n\treset_scb = ahd_get_scb(ahd, AHD_NEVER_COL_IDX);\n\tif (!reset_scb) {\n\t\tscmd_printk(KERN_INFO, cmd, \"No SCB available\\n\");\n\t\treturn FAILED;\n\t}\n\n\ttinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,\n\t\t\t\t    cmd->device->id, &tstate);\n\treset_scb->io_ctx = cmd;\n\treset_scb->platform_data->dev = dev;\n\treset_scb->sg_count = 0;\n\tahd_set_residual(reset_scb, 0);\n\tahd_set_sense_residual(reset_scb, 0);\n\treset_scb->platform_data->xfer_len = 0;\n\treset_scb->hscb->control = 0;\n\treset_scb->hscb->scsiid = BUILD_SCSIID(ahd,cmd);\n\treset_scb->hscb->lun = cmd->device->lun;\n\treset_scb->hscb->cdb_len = 0;\n\treset_scb->hscb->task_management = SIU_TASKMGMT_LUN_RESET;\n\treset_scb->flags |= SCB_DEVICE_RESET|SCB_RECOVERY_SCB|SCB_ACTIVE;\n\tif ((tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {\n\t\treset_scb->flags |= SCB_PACKETIZED;\n\t} else {\n\t\treset_scb->hscb->control |= MK_MESSAGE;\n\t}\n\tdev->openings--;\n\tdev->active++;\n\tdev->commands_issued++;\n\n\tahd_lock(ahd, &flags);\n\n\tLIST_INSERT_HEAD(&ahd->pending_scbs, reset_scb, pending_links);\n\tahd_queue_scb(ahd, reset_scb);\n\n\tahd->platform_data->eh_done = &done;\n\tahd_unlock(ahd, &flags);\n\n\tprintk(\"%s: Device reset code sleeping\\n\", ahd_name(ahd));\n\tif (!wait_for_completion_timeout(&done, 5 * HZ)) {\n\t\tahd_lock(ahd, &flags);\n\t\tahd->platform_data->eh_done = NULL;\n\t\tahd_unlock(ahd, &flags);\n\t\tprintk(\"%s: Device reset timer expired (active %d)\\n\",\n\t\t       ahd_name(ahd), dev->active);\n\t\tretval = FAILED;\n\t}\n\tprintk(\"%s: Device reset returning 0x%x\\n\", ahd_name(ahd), retval);\n\n\treturn (retval);\n}\n\n \nstatic int\nahd_linux_bus_reset(struct scsi_cmnd *cmd)\n{\n\tstruct ahd_softc *ahd;\n\tint    found;\n\tunsigned long flags;\n\n\tahd = *(struct ahd_softc **)cmd->device->host->hostdata;\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_RECOVERY) != 0)\n\t\tprintk(\"%s: Bus reset called for cmd %p\\n\",\n\t\t       ahd_name(ahd), cmd);\n#endif\n\tahd_lock(ahd, &flags);\n\n\tfound = ahd_reset_channel(ahd, scmd_channel(cmd) + 'A',\n\t\t\t\t   TRUE);\n\tahd_unlock(ahd, &flags);\n\n\tif (bootverbose)\n\t\tprintk(\"%s: SCSI bus reset delivered. \"\n\t\t       \"%d SCBs aborted.\\n\", ahd_name(ahd), found);\n\n\treturn (SUCCESS);\n}\n\nstruct scsi_host_template aic79xx_driver_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"aic79xx\",\n\t.proc_name\t\t= \"aic79xx\",\n\t.show_info\t\t= ahd_linux_show_info,\n\t.write_info\t \t= ahd_proc_write_seeprom,\n\t.info\t\t\t= ahd_linux_info,\n\t.queuecommand\t\t= ahd_linux_queue,\n\t.eh_abort_handler\t= ahd_linux_abort,\n\t.eh_device_reset_handler = ahd_linux_dev_reset,\n\t.eh_bus_reset_handler\t= ahd_linux_bus_reset,\n#if defined(__i386__)\n\t.bios_param\t\t= ahd_linux_biosparam,\n#endif\n\t.can_queue\t\t= AHD_MAX_QUEUE,\n\t.this_id\t\t= -1,\n\t.max_sectors\t\t= 8192,\n\t.cmd_per_lun\t\t= 2,\n\t.slave_alloc\t\t= ahd_linux_slave_alloc,\n\t.slave_configure\t= ahd_linux_slave_configure,\n\t.target_alloc\t\t= ahd_linux_target_alloc,\n\t.target_destroy\t\t= ahd_linux_target_destroy,\n};\n\n \nint\nahd_dma_tag_create(struct ahd_softc *ahd, bus_dma_tag_t parent,\n\t\t   bus_size_t alignment, bus_size_t boundary,\n\t\t   dma_addr_t lowaddr, dma_addr_t highaddr,\n\t\t   bus_dma_filter_t *filter, void *filterarg,\n\t\t   bus_size_t maxsize, int nsegments,\n\t\t   bus_size_t maxsegsz, int flags, bus_dma_tag_t *ret_tag)\n{\n\tbus_dma_tag_t dmat;\n\n\tdmat = kmalloc(sizeof(*dmat), GFP_ATOMIC);\n\tif (dmat == NULL)\n\t\treturn (ENOMEM);\n\n\t \n\tdmat->alignment = alignment;\n\tdmat->boundary = boundary;\n\tdmat->maxsize = maxsize;\n\t*ret_tag = dmat;\n\treturn (0);\n}\n\nvoid\nahd_dma_tag_destroy(struct ahd_softc *ahd, bus_dma_tag_t dmat)\n{\n\tkfree(dmat);\n}\n\nint\nahd_dmamem_alloc(struct ahd_softc *ahd, bus_dma_tag_t dmat, void** vaddr,\n\t\t int flags, bus_dmamap_t *mapp)\n{\n\t*vaddr = dma_alloc_coherent(&ahd->dev_softc->dev, dmat->maxsize, mapp,\n\t\t\t\t    GFP_ATOMIC);\n\tif (*vaddr == NULL)\n\t\treturn (ENOMEM);\n\treturn(0);\n}\n\nvoid\nahd_dmamem_free(struct ahd_softc *ahd, bus_dma_tag_t dmat,\n\t\tvoid* vaddr, bus_dmamap_t map)\n{\n\tdma_free_coherent(&ahd->dev_softc->dev, dmat->maxsize, vaddr, map);\n}\n\nint\nahd_dmamap_load(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map,\n\t\tvoid *buf, bus_size_t buflen, bus_dmamap_callback_t *cb,\n\t\tvoid *cb_arg, int flags)\n{\n\t \n\tbus_dma_segment_t stack_sg;\n\n\tstack_sg.ds_addr = map;\n\tstack_sg.ds_len = dmat->maxsize;\n\tcb(cb_arg, &stack_sg,  1,  0);\n\treturn (0);\n}\n\nvoid\nahd_dmamap_destroy(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map)\n{\n}\n\nint\nahd_dmamap_unload(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map)\n{\n\t \n\treturn (0);\n}\n\n \nstatic void\nahd_linux_setup_iocell_info(u_long index, int instance, int targ, int32_t value)\n{\n\n\tif ((instance >= 0)\n\t && (instance < ARRAY_SIZE(aic79xx_iocell_info))) {\n\t\tuint8_t *iocell_info;\n\n\t\tiocell_info = (uint8_t*)&aic79xx_iocell_info[instance];\n\t\tiocell_info[index] = value & 0xFFFF;\n\t\tif (bootverbose)\n\t\t\tprintk(\"iocell[%d:%ld] = %d\\n\", instance, index, value);\n\t}\n}\n\nstatic void\nahd_linux_setup_tag_info_global(char *p)\n{\n\tint tags, i, j;\n\n\ttags = simple_strtoul(p + 1, NULL, 0) & 0xff;\n\tprintk(\"Setting Global Tags= %d\\n\", tags);\n\n\tfor (i = 0; i < ARRAY_SIZE(aic79xx_tag_info); i++) {\n\t\tfor (j = 0; j < AHD_NUM_TARGETS; j++) {\n\t\t\taic79xx_tag_info[i].tag_commands[j] = tags;\n\t\t}\n\t}\n}\n\nstatic void\nahd_linux_setup_tag_info(u_long arg, int instance, int targ, int32_t value)\n{\n\n\tif ((instance >= 0) && (targ >= 0)\n\t && (instance < ARRAY_SIZE(aic79xx_tag_info))\n\t && (targ < AHD_NUM_TARGETS)) {\n\t\taic79xx_tag_info[instance].tag_commands[targ] = value & 0x1FF;\n\t\tif (bootverbose)\n\t\t\tprintk(\"tag_info[%d:%d] = %d\\n\", instance, targ, value);\n\t}\n}\n\nstatic char *\nahd_parse_brace_option(char *opt_name, char *opt_arg, char *end, int depth,\n\t\t       void (*callback)(u_long, int, int, int32_t),\n\t\t       u_long callback_arg)\n{\n\tchar\t*tok_end;\n\tchar\t*tok_end2;\n\tint      i;\n\tint      instance;\n\tint\t targ;\n\tint\t done;\n\tchar\t tok_list[] = {'.', ',', '{', '}', '\\0'};\n\n\t \n\tif (*opt_arg != ':')\n\t\treturn (opt_arg);\n\topt_arg++;\n\tinstance = -1;\n\ttarg = -1;\n\tdone = FALSE;\n\t \n\ttok_end = strchr(opt_arg, '\\0');\n\tif (tok_end < end)\n\t\t*tok_end = ',';\n\twhile (!done) {\n\t\tswitch (*opt_arg) {\n\t\tcase '{':\n\t\t\tif (instance == -1) {\n\t\t\t\tinstance = 0;\n\t\t\t} else {\n\t\t\t\tif (depth > 1) {\n\t\t\t\t\tif (targ == -1)\n\t\t\t\t\t\ttarg = 0;\n\t\t\t\t} else {\n\t\t\t\t\tprintk(\"Malformed Option %s\\n\",\n\t\t\t\t\t       opt_name);\n\t\t\t\t\tdone = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\topt_arg++;\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tif (targ != -1)\n\t\t\t\ttarg = -1;\n\t\t\telse if (instance != -1)\n\t\t\t\tinstance = -1;\n\t\t\topt_arg++;\n\t\t\tbreak;\n\t\tcase ',':\n\t\tcase '.':\n\t\t\tif (instance == -1)\n\t\t\t\tdone = TRUE;\n\t\t\telse if (targ >= 0)\n\t\t\t\ttarg++;\n\t\t\telse if (instance >= 0)\n\t\t\t\tinstance++;\n\t\t\topt_arg++;\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\tdone = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttok_end = end;\n\t\t\tfor (i = 0; tok_list[i]; i++) {\n\t\t\t\ttok_end2 = strchr(opt_arg, tok_list[i]);\n\t\t\t\tif ((tok_end2) && (tok_end2 < tok_end))\n\t\t\t\t\ttok_end = tok_end2;\n\t\t\t}\n\t\t\tcallback(callback_arg, instance, targ,\n\t\t\t\t simple_strtol(opt_arg, NULL, 0));\n\t\t\topt_arg = tok_end;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (opt_arg);\n}\n\n \nstatic int\naic79xx_setup(char *s)\n{\n\tint\ti, n;\n\tchar   *p;\n\tchar   *end;\n\n\tstatic const struct {\n\t\tconst char *name;\n\t\tuint32_t *flag;\n\t} options[] = {\n\t\t{ \"extended\", &aic79xx_extended },\n\t\t{ \"no_reset\", &aic79xx_no_reset },\n\t\t{ \"verbose\", &aic79xx_verbose },\n\t\t{ \"allow_memio\", &aic79xx_allow_memio},\n#ifdef AHD_DEBUG\n\t\t{ \"debug\", &ahd_debug },\n#endif\n\t\t{ \"periodic_otag\", &aic79xx_periodic_otag },\n\t\t{ \"pci_parity\", &aic79xx_pci_parity },\n\t\t{ \"seltime\", &aic79xx_seltime },\n\t\t{ \"tag_info\", NULL },\n\t\t{ \"global_tag_depth\", NULL},\n\t\t{ \"slewrate\", NULL },\n\t\t{ \"precomp\", NULL },\n\t\t{ \"amplitude\", NULL },\n\t\t{ \"slowcrc\", &aic79xx_slowcrc },\n\t};\n\n\tend = strchr(s, '\\0');\n\n\t \n\tn = 0;\n\n\twhile ((p = strsep(&s, \",.\")) != NULL) {\n\t\tif (*p == '\\0')\n\t\t\tcontinue;\n\t\tfor (i = 0; i < ARRAY_SIZE(options); i++) {\n\n\t\t\tn = strlen(options[i].name);\n\t\t\tif (strncmp(options[i].name, p, n) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ARRAY_SIZE(options))\n\t\t\tcontinue;\n\n\t\tif (strncmp(p, \"global_tag_depth\", n) == 0) {\n\t\t\tahd_linux_setup_tag_info_global(p + n);\n\t\t} else if (strncmp(p, \"tag_info\", n) == 0) {\n\t\t\ts = ahd_parse_brace_option(\"tag_info\", p + n, end,\n\t\t\t    2, ahd_linux_setup_tag_info, 0);\n\t\t} else if (strncmp(p, \"slewrate\", n) == 0) {\n\t\t\ts = ahd_parse_brace_option(\"slewrate\",\n\t\t\t    p + n, end, 1, ahd_linux_setup_iocell_info,\n\t\t\t    AIC79XX_SLEWRATE_INDEX);\n\t\t} else if (strncmp(p, \"precomp\", n) == 0) {\n\t\t\ts = ahd_parse_brace_option(\"precomp\",\n\t\t\t    p + n, end, 1, ahd_linux_setup_iocell_info,\n\t\t\t    AIC79XX_PRECOMP_INDEX);\n\t\t} else if (strncmp(p, \"amplitude\", n) == 0) {\n\t\t\ts = ahd_parse_brace_option(\"amplitude\",\n\t\t\t    p + n, end, 1, ahd_linux_setup_iocell_info,\n\t\t\t    AIC79XX_AMPLITUDE_INDEX);\n\t\t} else if (p[n] == ':') {\n\t\t\t*(options[i].flag) = simple_strtoul(p + n + 1, NULL, 0);\n\t\t} else if (!strncmp(p, \"verbose\", n)) {\n\t\t\t*(options[i].flag) = 1;\n\t\t} else {\n\t\t\t*(options[i].flag) ^= 0xFFFFFFFF;\n\t\t}\n\t}\n\treturn 1;\n}\n\n__setup(\"aic79xx=\", aic79xx_setup);\n\nuint32_t aic79xx_verbose;\n\nint\nahd_linux_register_host(struct ahd_softc *ahd, struct scsi_host_template *template)\n{\n\tchar\tbuf[80];\n\tstruct\tScsi_Host *host;\n\tchar\t*new_name;\n\tu_long\ts;\n\tint\tretval;\n\n\ttemplate->name = ahd->description;\n\thost = scsi_host_alloc(template, sizeof(struct ahd_softc *));\n\tif (host == NULL)\n\t\treturn (ENOMEM);\n\n\t*((struct ahd_softc **)host->hostdata) = ahd;\n\tahd->platform_data->host = host;\n\thost->can_queue = AHD_MAX_QUEUE;\n\thost->cmd_per_lun = 2;\n\thost->sg_tablesize = AHD_NSEG;\n\thost->this_id = ahd->our_id;\n\thost->irq = ahd->platform_data->irq;\n\thost->max_id = (ahd->features & AHD_WIDE) ? 16 : 8;\n\thost->max_lun = AHD_NUM_LUNS;\n\thost->max_channel = 0;\n\thost->sg_tablesize = AHD_NSEG;\n\tahd_lock(ahd, &s);\n\tahd_set_unit(ahd, ahd_linux_unit++);\n\tahd_unlock(ahd, &s);\n\tsprintf(buf, \"scsi%d\", host->host_no);\n\tnew_name = kmalloc(strlen(buf) + 1, GFP_ATOMIC);\n\tif (new_name != NULL) {\n\t\tstrcpy(new_name, buf);\n\t\tahd_set_name(ahd, new_name);\n\t}\n\thost->unique_id = ahd->unit;\n\tahd_linux_initialize_scsi_bus(ahd);\n\tahd_intr_enable(ahd, TRUE);\n\n\thost->transportt = ahd_linux_transport_template;\n\n\tretval = scsi_add_host(host, &ahd->dev_softc->dev);\n\tif (retval) {\n\t\tprintk(KERN_WARNING \"aic79xx: scsi_add_host failed\\n\");\n\t\tscsi_host_put(host);\n\t\treturn retval;\n\t}\n\n\tscsi_scan_host(host);\n\treturn 0;\n}\n\n \nstatic void\nahd_linux_initialize_scsi_bus(struct ahd_softc *ahd)\n{\n\tu_int target_id;\n\tu_int numtarg;\n\tunsigned long s;\n\n\ttarget_id = 0;\n\tnumtarg = 0;\n\n\tif (aic79xx_no_reset != 0)\n\t\tahd->flags &= ~AHD_RESET_BUS_A;\n\n\tif ((ahd->flags & AHD_RESET_BUS_A) != 0)\n\t\tahd_reset_channel(ahd, 'A',  TRUE);\n\telse\n\t\tnumtarg = (ahd->features & AHD_WIDE) ? 16 : 8;\n\n\tahd_lock(ahd, &s);\n\n\t \n\tfor (; target_id < numtarg; target_id++) {\n\t\tstruct ahd_devinfo devinfo;\n\t\tstruct ahd_initiator_tinfo *tinfo;\n\t\tstruct ahd_tmode_tstate *tstate;\n\n\t\ttinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,\n\t\t\t\t\t    target_id, &tstate);\n\t\tahd_compile_devinfo(&devinfo, ahd->our_id, target_id,\n\t\t\t\t    CAM_LUN_WILDCARD, 'A', ROLE_INITIATOR);\n\t\tahd_update_neg_request(ahd, &devinfo, tstate,\n\t\t\t\t       tinfo, AHD_NEG_ALWAYS);\n\t}\n\tahd_unlock(ahd, &s);\n\t \n\tif ((ahd->flags & AHD_RESET_BUS_A) != 0) {\n\t\tahd_freeze_simq(ahd);\n\t\tmsleep(AIC79XX_RESET_DELAY);\n\t\tahd_release_simq(ahd);\n\t}\n}\n\nint\nahd_platform_alloc(struct ahd_softc *ahd, void *platform_arg)\n{\n\tahd->platform_data =\n\t    kzalloc(sizeof(struct ahd_platform_data), GFP_ATOMIC);\n\tif (ahd->platform_data == NULL)\n\t\treturn (ENOMEM);\n\tahd->platform_data->irq = AHD_LINUX_NOIRQ;\n\tahd_lockinit(ahd);\n\tahd->seltime = (aic79xx_seltime & 0x3) << 4;\n\treturn (0);\n}\n\nvoid\nahd_platform_free(struct ahd_softc *ahd)\n{\n\tstruct scsi_target *starget;\n\tint i;\n\n\tif (ahd->platform_data != NULL) {\n\t\t \n\t\tfor (i = 0; i < AHD_NUM_TARGETS; i++) {\n\t\t\tstarget = ahd->platform_data->starget[i];\n\t\t\tif (starget != NULL) {\n\t\t\t\tahd->platform_data->starget[i] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (ahd->platform_data->irq != AHD_LINUX_NOIRQ)\n\t\t\tfree_irq(ahd->platform_data->irq, ahd);\n\t\tif (ahd->tags[0] == BUS_SPACE_PIO\n\t\t && ahd->bshs[0].ioport != 0)\n\t\t\trelease_region(ahd->bshs[0].ioport, 256);\n\t\tif (ahd->tags[1] == BUS_SPACE_PIO\n\t\t && ahd->bshs[1].ioport != 0)\n\t\t\trelease_region(ahd->bshs[1].ioport, 256);\n\t\tif (ahd->tags[0] == BUS_SPACE_MEMIO\n\t\t && ahd->bshs[0].maddr != NULL) {\n\t\t\tiounmap(ahd->bshs[0].maddr);\n\t\t\trelease_mem_region(ahd->platform_data->mem_busaddr,\n\t\t\t\t\t   0x1000);\n\t\t}\n\t\tif (ahd->platform_data->host)\n\t\t\tscsi_host_put(ahd->platform_data->host);\n\n\t\tkfree(ahd->platform_data);\n\t}\n}\n\nvoid\nahd_platform_init(struct ahd_softc *ahd)\n{\n\t \n\tif (ahd->unit < ARRAY_SIZE(aic79xx_iocell_info)) {\n\t\tconst struct ahd_linux_iocell_opts *iocell_opts;\n\n\t\tiocell_opts = &aic79xx_iocell_info[ahd->unit];\n\t\tif (iocell_opts->precomp != AIC79XX_DEFAULT_PRECOMP)\n\t\t\tAHD_SET_PRECOMP(ahd, iocell_opts->precomp);\n\t\tif (iocell_opts->slewrate != AIC79XX_DEFAULT_SLEWRATE)\n\t\t\tAHD_SET_SLEWRATE(ahd, iocell_opts->slewrate);\n\t\tif (iocell_opts->amplitude != AIC79XX_DEFAULT_AMPLITUDE)\n\t\t\tAHD_SET_AMPLITUDE(ahd, iocell_opts->amplitude);\n\t}\n\n}\n\nvoid\nahd_platform_freeze_devq(struct ahd_softc *ahd, struct scb *scb)\n{\n\tahd_platform_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),\n\t\t\t\tSCB_GET_CHANNEL(ahd, scb),\n\t\t\t\tSCB_GET_LUN(scb), SCB_LIST_NULL,\n\t\t\t\tROLE_UNKNOWN, CAM_REQUEUE_REQ);\n}\n\nvoid\nahd_platform_set_tags(struct ahd_softc *ahd, struct scsi_device *sdev,\n\t\t      struct ahd_devinfo *devinfo, ahd_queue_alg alg)\n{\n\tstruct ahd_linux_device *dev;\n\tint was_queuing;\n\tint now_queuing;\n\n\tif (sdev == NULL)\n\t\treturn;\n\n\tdev = scsi_transport_device_data(sdev);\n\n\tif (dev == NULL)\n\t\treturn;\n\twas_queuing = dev->flags & (AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED);\n\tswitch (alg) {\n\tdefault:\n\tcase AHD_QUEUE_NONE:\n\t\tnow_queuing = 0;\n\t\tbreak; \n\tcase AHD_QUEUE_BASIC:\n\t\tnow_queuing = AHD_DEV_Q_BASIC;\n\t\tbreak;\n\tcase AHD_QUEUE_TAGGED:\n\t\tnow_queuing = AHD_DEV_Q_TAGGED;\n\t\tbreak;\n\t}\n\tif ((dev->flags & AHD_DEV_FREEZE_TIL_EMPTY) == 0\n\t && (was_queuing != now_queuing)\n\t && (dev->active != 0)) {\n\t\tdev->flags |= AHD_DEV_FREEZE_TIL_EMPTY;\n\t\tdev->qfrozen++;\n\t}\n\n\tdev->flags &= ~(AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED|AHD_DEV_PERIODIC_OTAG);\n\tif (now_queuing) {\n\t\tu_int usertags;\n\n\t\tusertags = ahd_linux_user_tagdepth(ahd, devinfo);\n\t\tif (!was_queuing) {\n\t\t\t \n\t\t\tdev->maxtags = usertags;\n\t\t\tdev->openings = dev->maxtags - dev->active;\n\t\t}\n\t\tif (dev->maxtags == 0) {\n\t\t\t \n\t\t\tdev->openings = 1;\n\t\t} else if (alg == AHD_QUEUE_TAGGED) {\n\t\t\tdev->flags |= AHD_DEV_Q_TAGGED;\n\t\t\tif (aic79xx_periodic_otag != 0)\n\t\t\t\tdev->flags |= AHD_DEV_PERIODIC_OTAG;\n\t\t} else\n\t\t\tdev->flags |= AHD_DEV_Q_BASIC;\n\t} else {\n\t\t \n\t\tdev->maxtags = 0;\n\t\tdev->openings =  1 - dev->active;\n\t}\n\n\tswitch ((dev->flags & (AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED))) {\n\tcase AHD_DEV_Q_BASIC:\n\tcase AHD_DEV_Q_TAGGED:\n\t\tscsi_change_queue_depth(sdev,\n\t\t\t\tdev->openings + dev->active);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tscsi_change_queue_depth(sdev, 1);\n\t\tbreak;\n\t}\n}\n\nint\nahd_platform_abort_scbs(struct ahd_softc *ahd, int target, char channel,\n\t\t\tint lun, u_int tag, role_t role, uint32_t status)\n{\n\treturn 0;\n}\n\nstatic u_int\nahd_linux_user_tagdepth(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\n{\n\tstatic int warned_user;\n\tu_int tags;\n\n\ttags = 0;\n\tif ((ahd->user_discenable & devinfo->target_mask) != 0) {\n\t\tif (ahd->unit >= ARRAY_SIZE(aic79xx_tag_info)) {\n\n\t\t\tif (warned_user == 0) {\n\t\t\t\tprintk(KERN_WARNING\n\"aic79xx: WARNING: Insufficient tag_info instances\\n\"\n\"aic79xx: for installed controllers.  Using defaults\\n\"\n\"aic79xx: Please update the aic79xx_tag_info array in\\n\"\n\"aic79xx: the aic79xx_osm.c source file.\\n\");\n\t\t\t\twarned_user++;\n\t\t\t}\n\t\t\ttags = AHD_MAX_QUEUE;\n\t\t} else {\n\t\t\tadapter_tag_info_t *tag_info;\n\n\t\t\ttag_info = &aic79xx_tag_info[ahd->unit];\n\t\t\ttags = tag_info->tag_commands[devinfo->target_offset];\n\t\t\tif (tags > AHD_MAX_QUEUE)\n\t\t\t\ttags = AHD_MAX_QUEUE;\n\t\t}\n\t}\n\treturn (tags);\n}\n\n \nstatic void\nahd_linux_device_queue_depth(struct scsi_device *sdev)\n{\n\tstruct\tahd_devinfo devinfo;\n\tu_int\ttags;\n\tstruct ahd_softc *ahd = *((struct ahd_softc **)sdev->host->hostdata);\n\n\tahd_compile_devinfo(&devinfo,\n\t\t\t    ahd->our_id,\n\t\t\t    sdev->sdev_target->id, sdev->lun,\n\t\t\t    sdev->sdev_target->channel == 0 ? 'A' : 'B',\n\t\t\t    ROLE_INITIATOR);\n\ttags = ahd_linux_user_tagdepth(ahd, &devinfo);\n\tif (tags != 0 && sdev->tagged_supported != 0) {\n\n\t\tahd_platform_set_tags(ahd, sdev, &devinfo, AHD_QUEUE_TAGGED);\n\t\tahd_send_async(ahd, devinfo.channel, devinfo.target,\n\t\t\t       devinfo.lun, AC_TRANSFER_NEG);\n\t\tahd_print_devinfo(ahd, &devinfo);\n\t\tprintk(\"Tagged Queuing enabled.  Depth %d\\n\", tags);\n\t} else {\n\t\tahd_platform_set_tags(ahd, sdev, &devinfo, AHD_QUEUE_NONE);\n\t\tahd_send_async(ahd, devinfo.channel, devinfo.target,\n\t\t\t       devinfo.lun, AC_TRANSFER_NEG);\n\t}\n}\n\nstatic int\nahd_linux_run_command(struct ahd_softc *ahd, struct ahd_linux_device *dev,\n\t\t      struct scsi_cmnd *cmd)\n{\n\tstruct\t scb *scb;\n\tstruct\t hardware_scb *hscb;\n\tstruct\t ahd_initiator_tinfo *tinfo;\n\tstruct\t ahd_tmode_tstate *tstate;\n\tu_int\t col_idx;\n\tuint16_t mask;\n\tunsigned long flags;\n\tint nseg;\n\n\tnseg = scsi_dma_map(cmd);\n\tif (nseg < 0)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tahd_lock(ahd, &flags);\n\n\t \n\ttinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,\n\t\t\t\t    cmd->device->id, &tstate);\n\tif ((dev->flags & (AHD_DEV_Q_TAGGED|AHD_DEV_Q_BASIC)) == 0\n\t || (tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {\n\t\tcol_idx = AHD_NEVER_COL_IDX;\n\t} else {\n\t\tcol_idx = AHD_BUILD_COL_IDX(cmd->device->id,\n\t\t\t\t\t    cmd->device->lun);\n\t}\n\tif ((scb = ahd_get_scb(ahd, col_idx)) == NULL) {\n\t\tahd->flags |= AHD_RESOURCE_SHORTAGE;\n\t\tahd_unlock(ahd, &flags);\n\t\tscsi_dma_unmap(cmd);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tscb->io_ctx = cmd;\n\tscb->platform_data->dev = dev;\n\thscb = scb->hscb;\n\tcmd->host_scribble = (char *)scb;\n\n\t \n\thscb->control = 0;\n\thscb->scsiid = BUILD_SCSIID(ahd, cmd);\n\thscb->lun = cmd->device->lun;\n\tscb->hscb->task_management = 0;\n\tmask = SCB_GET_TARGET_MASK(ahd, scb);\n\n\tif ((ahd->user_discenable & mask) != 0)\n\t\thscb->control |= DISCENB;\n\n\tif ((tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0)\n\t\tscb->flags |= SCB_PACKETIZED;\n\n\tif ((tstate->auto_negotiate & mask) != 0) {\n\t\tscb->flags |= SCB_AUTO_NEGOTIATE;\n\t\tscb->hscb->control |= MK_MESSAGE;\n\t}\n\n\tif ((dev->flags & (AHD_DEV_Q_TAGGED|AHD_DEV_Q_BASIC)) != 0) {\n\t\tif (dev->commands_since_idle_or_otag == AHD_OTAG_THRESH\n\t\t && (dev->flags & AHD_DEV_Q_TAGGED) != 0) {\n\t\t\thscb->control |= ORDERED_QUEUE_TAG;\n\t\t\tdev->commands_since_idle_or_otag = 0;\n\t\t} else {\n\t\t\thscb->control |= SIMPLE_QUEUE_TAG;\n\t\t}\n\t}\n\n\thscb->cdb_len = cmd->cmd_len;\n\tmemcpy(hscb->shared_data.idata.cdb, cmd->cmnd, hscb->cdb_len);\n\n\tscb->platform_data->xfer_len = 0;\n\tahd_set_residual(scb, 0);\n\tahd_set_sense_residual(scb, 0);\n\tscb->sg_count = 0;\n\n\tif (nseg > 0) {\n\t\tvoid *sg = scb->sg_list;\n\t\tstruct scatterlist *cur_seg;\n\t\tint i;\n\n\t\tscb->platform_data->xfer_len = 0;\n\n\t\tscsi_for_each_sg(cmd, cur_seg, nseg, i) {\n\t\t\tdma_addr_t addr;\n\t\t\tbus_size_t len;\n\n\t\t\taddr = sg_dma_address(cur_seg);\n\t\t\tlen = sg_dma_len(cur_seg);\n\t\t\tscb->platform_data->xfer_len += len;\n\t\t\tsg = ahd_sg_setup(ahd, scb, sg, addr, len,\n\t\t\t\t\t  i == (nseg - 1));\n\t\t}\n\t}\n\n\tLIST_INSERT_HEAD(&ahd->pending_scbs, scb, pending_links);\n\tdev->openings--;\n\tdev->active++;\n\tdev->commands_issued++;\n\n\tif ((dev->flags & AHD_DEV_PERIODIC_OTAG) != 0)\n\t\tdev->commands_since_idle_or_otag++;\n\tscb->flags |= SCB_ACTIVE;\n\tahd_queue_scb(ahd, scb);\n\n\tahd_unlock(ahd, &flags);\n\n\treturn 0;\n}\n\n \nirqreturn_t\nahd_linux_isr(int irq, void *dev_id)\n{\n\tstruct\tahd_softc *ahd;\n\tu_long\tflags;\n\tint\tours;\n\n\tahd = (struct ahd_softc *) dev_id;\n\tahd_lock(ahd, &flags); \n\tours = ahd_intr(ahd);\n\tahd_unlock(ahd, &flags);\n\treturn IRQ_RETVAL(ours);\n}\n\nvoid\nahd_send_async(struct ahd_softc *ahd, char channel,\n\t       u_int target, u_int lun, ac_code code)\n{\n\tswitch (code) {\n\tcase AC_TRANSFER_NEG:\n\t{\n\t\tstruct  scsi_target *starget;\n\t\tstruct\tahd_initiator_tinfo *tinfo;\n\t\tstruct\tahd_tmode_tstate *tstate;\n\t\tunsigned int target_ppr_options;\n\n\t\tBUG_ON(target == CAM_TARGET_WILDCARD);\n\n\t\ttinfo = ahd_fetch_transinfo(ahd, channel, ahd->our_id,\n\t\t\t\t\t    target, &tstate);\n\n\t\t \n\t\tif (tinfo->curr.period != tinfo->goal.period\n\t\t || tinfo->curr.width != tinfo->goal.width\n\t\t || tinfo->curr.offset != tinfo->goal.offset\n\t\t || tinfo->curr.ppr_options != tinfo->goal.ppr_options)\n\t\t\tif (bootverbose == 0)\n\t\t\t\tbreak;\n\n\t\t \n\t\tstarget = ahd->platform_data->starget[target];\n\t\tif (starget == NULL)\n\t\t\tbreak;\n\n\t\ttarget_ppr_options =\n\t\t\t(spi_dt(starget) ? MSG_EXT_PPR_DT_REQ : 0)\n\t\t\t+ (spi_qas(starget) ? MSG_EXT_PPR_QAS_REQ : 0)\n\t\t\t+ (spi_iu(starget) ?  MSG_EXT_PPR_IU_REQ : 0)\n\t\t\t+ (spi_rd_strm(starget) ? MSG_EXT_PPR_RD_STRM : 0)\n\t\t\t+ (spi_pcomp_en(starget) ? MSG_EXT_PPR_PCOMP_EN : 0)\n\t\t\t+ (spi_rti(starget) ? MSG_EXT_PPR_RTI : 0)\n\t\t\t+ (spi_wr_flow(starget) ? MSG_EXT_PPR_WR_FLOW : 0)\n\t\t\t+ (spi_hold_mcs(starget) ? MSG_EXT_PPR_HOLD_MCS : 0);\n\n\t\tif (tinfo->curr.period == spi_period(starget)\n\t\t    && tinfo->curr.width == spi_width(starget)\n\t\t    && tinfo->curr.offset == spi_offset(starget)\n\t\t && tinfo->curr.ppr_options == target_ppr_options)\n\t\t\tif (bootverbose == 0)\n\t\t\t\tbreak;\n\n\t\tspi_period(starget) = tinfo->curr.period;\n\t\tspi_width(starget) = tinfo->curr.width;\n\t\tspi_offset(starget) = tinfo->curr.offset;\n\t\tspi_dt(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_DT_REQ ? 1 : 0;\n\t\tspi_qas(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_QAS_REQ ? 1 : 0;\n\t\tspi_iu(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ ? 1 : 0;\n\t\tspi_rd_strm(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_RD_STRM ? 1 : 0;\n\t\tspi_pcomp_en(starget) =  tinfo->curr.ppr_options & MSG_EXT_PPR_PCOMP_EN ? 1 : 0;\n\t\tspi_rti(starget) =  tinfo->curr.ppr_options &  MSG_EXT_PPR_RTI ? 1 : 0;\n\t\tspi_wr_flow(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_WR_FLOW ? 1 : 0;\n\t\tspi_hold_mcs(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_HOLD_MCS ? 1 : 0;\n\t\tspi_display_xfer_agreement(starget);\n\t\tbreak;\n\t}\n        case AC_SENT_BDR:\n\t{\n\t\tWARN_ON(lun != CAM_LUN_WILDCARD);\n\t\tscsi_report_device_reset(ahd->platform_data->host,\n\t\t\t\t\t channel - 'A', target);\n\t\tbreak;\n\t}\n        case AC_BUS_RESET:\n\t\tif (ahd->platform_data->host != NULL) {\n\t\t\tscsi_report_bus_reset(ahd->platform_data->host,\n\t\t\t\t\t      channel - 'A');\n\t\t}\n                break;\n        default:\n                panic(\"ahd_send_async: Unexpected async event\");\n        }\n}\n\n \nvoid\nahd_done(struct ahd_softc *ahd, struct scb *scb)\n{\n\tstruct scsi_cmnd *cmd;\n\tstruct\t  ahd_linux_device *dev;\n\n\tif ((scb->flags & SCB_ACTIVE) == 0) {\n\t\tprintk(\"SCB %d done'd twice\\n\", SCB_GET_TAG(scb));\n\t\tahd_dump_card_state(ahd);\n\t\tpanic(\"Stopping for safety\");\n\t}\n\tLIST_REMOVE(scb, pending_links);\n\tcmd = scb->io_ctx;\n\tdev = scb->platform_data->dev;\n\tdev->active--;\n\tdev->openings++;\n\tif ((cmd->result & (CAM_DEV_QFRZN << 16)) != 0) {\n\t\tcmd->result &= ~(CAM_DEV_QFRZN << 16);\n\t\tdev->qfrozen--;\n\t}\n\tahd_linux_unmap_scb(ahd, scb);\n\n\t \n\tcmd->sense_buffer[0] = 0;\n\tif (ahd_get_transaction_status(scb) == CAM_REQ_INPROG) {\n#ifdef AHD_REPORT_UNDERFLOWS\n\t\tuint32_t amount_xferred;\n\n\t\tamount_xferred =\n\t\t    ahd_get_transfer_length(scb) - ahd_get_residual(scb);\n#endif\n\t\tif ((scb->flags & SCB_TRANSMISSION_ERROR) != 0) {\n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_MISC) != 0) {\n\t\t\t\tahd_print_path(ahd, scb);\n\t\t\t\tprintk(\"Set CAM_UNCOR_PARITY\\n\");\n\t\t\t}\n#endif\n\t\t\tahd_set_transaction_status(scb, CAM_UNCOR_PARITY);\n#ifdef AHD_REPORT_UNDERFLOWS\n\t\t \n\t\t} else if (amount_xferred < scb->io_ctx->underflow) {\n\t\t\tu_int i;\n\n\t\t\tahd_print_path(ahd, scb);\n\t\t\tprintk(\"CDB:\");\n\t\t\tfor (i = 0; i < scb->io_ctx->cmd_len; i++)\n\t\t\t\tprintk(\" 0x%x\", scb->io_ctx->cmnd[i]);\n\t\t\tprintk(\"\\n\");\n\t\t\tahd_print_path(ahd, scb);\n\t\t\tprintk(\"Saw underflow (%ld of %ld bytes). \"\n\t\t\t       \"Treated as error\\n\",\n\t\t\t\tahd_get_residual(scb),\n\t\t\t\tahd_get_transfer_length(scb));\n\t\t\tahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);\n#endif\n\t\t} else {\n\t\t\tahd_set_transaction_status(scb, CAM_REQ_CMP);\n\t\t}\n\t} else if (ahd_get_transaction_status(scb) == CAM_SCSI_STATUS_ERROR) {\n\t\tahd_linux_handle_scsi_status(ahd, cmd->device, scb);\n\t}\n\n\tif (dev->openings == 1\n\t && ahd_get_transaction_status(scb) == CAM_REQ_CMP\n\t && ahd_get_scsi_status(scb) != SAM_STAT_TASK_SET_FULL)\n\t\tdev->tag_success_count++;\n\t \n\tif ((dev->openings + dev->active) < dev->maxtags\n\t && dev->tag_success_count > AHD_TAG_SUCCESS_INTERVAL) {\n\t\tdev->tag_success_count = 0;\n\t\tdev->openings++;\n\t}\n\n\tif (dev->active == 0)\n\t\tdev->commands_since_idle_or_otag = 0;\n\n\tif ((scb->flags & SCB_RECOVERY_SCB) != 0) {\n\t\tprintk(\"Recovery SCB completes\\n\");\n\t\tif (ahd_get_transaction_status(scb) == CAM_BDR_SENT\n\t\t || ahd_get_transaction_status(scb) == CAM_REQ_ABORTED)\n\t\t\tahd_set_transaction_status(scb, CAM_CMD_TIMEOUT);\n\n\t\tif (ahd->platform_data->eh_done)\n\t\t\tcomplete(ahd->platform_data->eh_done);\n\t}\n\n\tahd_free_scb(ahd, scb);\n\tahd_linux_queue_cmd_complete(ahd, cmd);\n}\n\nstatic void\nahd_linux_handle_scsi_status(struct ahd_softc *ahd,\n\t\t\t     struct scsi_device *sdev, struct scb *scb)\n{\n\tstruct\tahd_devinfo devinfo;\n\tstruct ahd_linux_device *dev = scsi_transport_device_data(sdev);\n\n\tahd_compile_devinfo(&devinfo,\n\t\t\t    ahd->our_id,\n\t\t\t    sdev->sdev_target->id, sdev->lun,\n\t\t\t    sdev->sdev_target->channel == 0 ? 'A' : 'B',\n\t\t\t    ROLE_INITIATOR);\n\t\n\t \n\tswitch (ahd_get_scsi_status(scb)) {\n\tdefault:\n\t\tbreak;\n\tcase SAM_STAT_CHECK_CONDITION:\n\tcase SAM_STAT_COMMAND_TERMINATED:\n\t{\n\t\tstruct scsi_cmnd *cmd;\n\n\t\t \n\t\tcmd = scb->io_ctx;\n\t\tif ((scb->flags & (SCB_SENSE|SCB_PKT_SENSE)) != 0) {\n\t\t\tstruct scsi_status_iu_header *siu;\n\t\t\tu_int sense_size;\n\t\t\tu_int sense_offset;\n\n\t\t\tif (scb->flags & SCB_SENSE) {\n\t\t\t\tsense_size = min(sizeof(struct scsi_sense_data)\n\t\t\t\t\t       - ahd_get_sense_residual(scb),\n\t\t\t\t\t\t (u_long)SCSI_SENSE_BUFFERSIZE);\n\t\t\t\tsense_offset = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsiu = (struct scsi_status_iu_header *)\n\t\t\t\t    scb->sense_data;\n\t\t\t\tsense_size = min_t(size_t,\n\t\t\t\t\t\tscsi_4btoul(siu->sense_length),\n\t\t\t\t\t\tSCSI_SENSE_BUFFERSIZE);\n\t\t\t\tsense_offset = SIU_SENSE_OFFSET(siu);\n\t\t\t}\n\n\t\t\tmemset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\n\t\t\tmemcpy(cmd->sense_buffer,\n\t\t\t       ahd_get_sense_buf(ahd, scb)\n\t\t\t       + sense_offset, sense_size);\n\t\t\tset_status_byte(cmd, SAM_STAT_CHECK_CONDITION);\n\n#ifdef AHD_DEBUG\n\t\t\tif (ahd_debug & AHD_SHOW_SENSE) {\n\t\t\t\tint i;\n\n\t\t\t\tprintk(\"Copied %d bytes of sense data at %d:\",\n\t\t\t\t       sense_size, sense_offset);\n\t\t\t\tfor (i = 0; i < sense_size; i++) {\n\t\t\t\t\tif ((i & 0xF) == 0)\n\t\t\t\t\t\tprintk(\"\\n\");\n\t\t\t\t\tprintk(\"0x%x \", cmd->sense_buffer[i]);\n\t\t\t\t}\n\t\t\t\tprintk(\"\\n\");\n\t\t\t}\n#endif\n\t\t}\n\t\tbreak;\n\t}\n\tcase SAM_STAT_TASK_SET_FULL:\n\t\t \n\t\tdev->tag_success_count = 0;\n\t\tif (dev->active != 0) {\n\t\t\t \n\t\t\tdev->openings = 0;\n#ifdef AHD_DEBUG\n\t\t\tif ((ahd_debug & AHD_SHOW_QFULL) != 0) {\n\t\t\t\tahd_print_path(ahd, scb);\n\t\t\t\tprintk(\"Dropping tag count to %d\\n\",\n\t\t\t\t       dev->active);\n\t\t\t}\n#endif\n\t\t\tif (dev->active == dev->tags_on_last_queuefull) {\n\n\t\t\t\tdev->last_queuefull_same_count++;\n\t\t\t\t \n\t\t\t\tif (dev->last_queuefull_same_count\n\t\t\t\t == AHD_LOCK_TAGS_COUNT) {\n\t\t\t\t\tdev->maxtags = dev->active;\n\t\t\t\t\tahd_print_path(ahd, scb);\n\t\t\t\t\tprintk(\"Locking max tag count at %d\\n\",\n\t\t\t\t\t       dev->active);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdev->tags_on_last_queuefull = dev->active;\n\t\t\t\tdev->last_queuefull_same_count = 0;\n\t\t\t}\n\t\t\tahd_set_transaction_status(scb, CAM_REQUEUE_REQ);\n\t\t\tahd_set_scsi_status(scb, SAM_STAT_GOOD);\n\t\t\tahd_platform_set_tags(ahd, sdev, &devinfo,\n\t\t\t\t     (dev->flags & AHD_DEV_Q_BASIC)\n\t\t\t\t   ? AHD_QUEUE_BASIC : AHD_QUEUE_TAGGED);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tdev->openings = 1;\n\t\tahd_platform_set_tags(ahd, sdev, &devinfo,\n\t\t\t     (dev->flags & AHD_DEV_Q_BASIC)\n\t\t\t   ? AHD_QUEUE_BASIC : AHD_QUEUE_TAGGED);\n\t\tahd_set_scsi_status(scb, SAM_STAT_BUSY);\n\t}\n}\n\nstatic void\nahd_linux_queue_cmd_complete(struct ahd_softc *ahd, struct scsi_cmnd *cmd)\n{\n\tint status;\n\tint new_status = DID_OK;\n\tint do_fallback = 0;\n\tint scsi_status;\n\tstruct scsi_sense_data *sense;\n\n\t \n\n\tstatus = ahd_cmd_get_transaction_status(cmd);\n\tswitch (status) {\n\tcase CAM_REQ_INPROG:\n\tcase CAM_REQ_CMP:\n\t\tnew_status = DID_OK;\n\t\tbreak;\n\tcase CAM_AUTOSENSE_FAIL:\n\t\tnew_status = DID_ERROR;\n\t\tfallthrough;\n\tcase CAM_SCSI_STATUS_ERROR:\n\t\tscsi_status = ahd_cmd_get_scsi_status(cmd);\n\n\t\tswitch(scsi_status) {\n\t\tcase SAM_STAT_COMMAND_TERMINATED:\n\t\tcase SAM_STAT_CHECK_CONDITION:\n\t\t\tsense = (struct scsi_sense_data *)\n\t\t\t\tcmd->sense_buffer;\n\t\t\tif (sense->extra_len >= 5 &&\n\t\t\t    (sense->add_sense_code == 0x47\n\t\t\t     || sense->add_sense_code == 0x48))\n\t\t\t\tdo_fallback = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CAM_REQ_ABORTED:\n\t\tnew_status = DID_ABORT;\n\t\tbreak;\n\tcase CAM_BUSY:\n\t\tnew_status = DID_BUS_BUSY;\n\t\tbreak;\n\tcase CAM_REQ_INVALID:\n\tcase CAM_PATH_INVALID:\n\t\tnew_status = DID_BAD_TARGET;\n\t\tbreak;\n\tcase CAM_SEL_TIMEOUT:\n\t\tnew_status = DID_NO_CONNECT;\n\t\tbreak;\n\tcase CAM_SCSI_BUS_RESET:\n\tcase CAM_BDR_SENT:\n\t\tnew_status = DID_RESET;\n\t\tbreak;\n\tcase CAM_UNCOR_PARITY:\n\t\tnew_status = DID_PARITY;\n\t\tdo_fallback = 1;\n\t\tbreak;\n\tcase CAM_CMD_TIMEOUT:\n\t\tnew_status = DID_TIME_OUT;\n\t\tdo_fallback = 1;\n\t\tbreak;\n\tcase CAM_REQ_CMP_ERR:\n\tcase CAM_UNEXP_BUSFREE:\n\tcase CAM_DATA_RUN_ERR:\n\t\tnew_status = DID_ERROR;\n\t\tdo_fallback = 1;\n\t\tbreak;\n\tcase CAM_UA_ABORT:\n\tcase CAM_NO_HBA:\n\tcase CAM_SEQUENCE_FAIL:\n\tcase CAM_CCB_LEN_ERR:\n\tcase CAM_PROVIDE_FAIL:\n\tcase CAM_REQ_TERMIO:\n\tcase CAM_UNREC_HBA_ERROR:\n\tcase CAM_REQ_TOO_BIG:\n\t\tnew_status = DID_ERROR;\n\t\tbreak;\n\tcase CAM_REQUEUE_REQ:\n\t\tnew_status = DID_REQUEUE;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tnew_status = DID_ERROR;\n\t\tbreak;\n\t}\n\n\tif (do_fallback) {\n\t\tprintk(\"%s: device overrun (status %x) on %d:%d:%d\\n\",\n\t\t       ahd_name(ahd), status, cmd->device->channel,\n\t\t       cmd->device->id, (u8)cmd->device->lun);\n\t}\n\n\tahd_cmd_set_transaction_status(cmd, new_status);\n\n\tscsi_done(cmd);\n}\n\nstatic void\nahd_freeze_simq(struct ahd_softc *ahd)\n{\n\tscsi_block_requests(ahd->platform_data->host);\n}\n\nstatic void\nahd_release_simq(struct ahd_softc *ahd)\n{\n\tscsi_unblock_requests(ahd->platform_data->host);\n}\n\nstatic int\nahd_linux_queue_abort_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct ahd_softc *ahd;\n\tstruct ahd_linux_device *dev;\n\tstruct scb *pending_scb;\n\tu_int  saved_scbptr;\n\tu_int  active_scbptr;\n\tu_int  last_phase;\n\tu_int  cdb_byte;\n\tint    retval = SUCCESS;\n\tint    was_paused;\n\tint    paused;\n\tint    wait;\n\tint    disconnected;\n\tahd_mode_state saved_modes;\n\tunsigned long flags;\n\n\tpending_scb = NULL;\n\tpaused = FALSE;\n\twait = FALSE;\n\tahd = *(struct ahd_softc **)cmd->device->host->hostdata;\n\n\tscmd_printk(KERN_INFO, cmd,\n\t\t    \"Attempting to queue an ABORT message:\");\n\n\tprintk(\"CDB:\");\n\tfor (cdb_byte = 0; cdb_byte < cmd->cmd_len; cdb_byte++)\n\t\tprintk(\" 0x%x\", cmd->cmnd[cdb_byte]);\n\tprintk(\"\\n\");\n\n\tahd_lock(ahd, &flags);\n\n\t \n\tdev = scsi_transport_device_data(cmd->device);\n\n\tif (dev == NULL) {\n\t\t \n\t\tscmd_printk(KERN_INFO, cmd, \"Is not an active device\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tLIST_FOREACH(pending_scb, &ahd->pending_scbs, pending_links) {\n\t\tif (pending_scb->io_ctx == cmd)\n\t\t\tbreak;\n\t}\n\n\tif (pending_scb == NULL) {\n\t\tscmd_printk(KERN_INFO, cmd, \"Command not found\\n\");\n\t\tgoto done;\n\t}\n\n\tif ((pending_scb->flags & SCB_RECOVERY_SCB) != 0) {\n\t\t \n\t\tretval = FAILED;\n\t\tgoto done;\n\t}\n\n\t \n\twas_paused = ahd_is_paused(ahd);\n\tahd_pause_and_flushwork(ahd);\n\tpaused = TRUE;\n\n\tif ((pending_scb->flags & SCB_ACTIVE) == 0) {\n\t\tscmd_printk(KERN_INFO, cmd, \"Command already completed\\n\");\n\t\tgoto done;\n\t}\n\n\tprintk(\"%s: At time of recovery, card was %spaused\\n\",\n\t       ahd_name(ahd), was_paused ? \"\" : \"not \");\n\tahd_dump_card_state(ahd);\n\n\tdisconnected = TRUE;\n\tif (ahd_search_qinfifo(ahd, cmd->device->id, \n\t\t\t       cmd->device->channel + 'A',\n\t\t\t       cmd->device->lun,\n\t\t\t       pending_scb->hscb->tag,\n\t\t\t       ROLE_INITIATOR, CAM_REQ_ABORTED,\n\t\t\t       SEARCH_COMPLETE) > 0) {\n\t\tprintk(\"%s:%d:%d:%d: Cmd aborted from QINFIFO\\n\",\n\t\t       ahd_name(ahd), cmd->device->channel, \n\t\t       cmd->device->id, (u8)cmd->device->lun);\n\t\tgoto done;\n\t}\n\n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\tlast_phase = ahd_inb(ahd, LASTPHASE);\n\tsaved_scbptr = ahd_get_scbptr(ahd);\n\tactive_scbptr = saved_scbptr;\n\tif (disconnected && (ahd_inb(ahd, SEQ_FLAGS) & NOT_IDENTIFIED) == 0) {\n\t\tstruct scb *bus_scb;\n\n\t\tbus_scb = ahd_lookup_scb(ahd, active_scbptr);\n\t\tif (bus_scb == pending_scb)\n\t\t\tdisconnected = FALSE;\n\t}\n\n\t \n\tahd_inb(ahd, SAVED_SCSIID);\n\tif (last_phase != P_BUSFREE\n\t    && SCB_GET_TAG(pending_scb) == active_scbptr) {\n\n\t\t \n\t\tpending_scb = ahd_lookup_scb(ahd, active_scbptr);\n\t\tpending_scb->flags |= SCB_RECOVERY_SCB|SCB_ABORT;\n\t\tahd_outb(ahd, MSG_OUT, HOST_MSG);\n\t\tahd_outb(ahd, SCSISIGO, last_phase|ATNO);\n\t\tscmd_printk(KERN_INFO, cmd, \"Device is active, asserting ATN\\n\");\n\t\twait = TRUE;\n\t} else if (disconnected) {\n\n\t\t \n\t\tpending_scb->flags |= SCB_RECOVERY_SCB|SCB_ABORT;\n\t\tahd_set_scbptr(ahd, SCB_GET_TAG(pending_scb));\n\t\tpending_scb->hscb->cdb_len = 0;\n\t\tpending_scb->hscb->task_attribute = 0;\n\t\tpending_scb->hscb->task_management = SIU_TASKMGMT_ABORT_TASK;\n\n\t\tif ((pending_scb->flags & SCB_PACKETIZED) != 0) {\n\t\t\t \n\t\t\tahd_outb(ahd, SCB_TASK_MANAGEMENT,\n\t\t\t\t pending_scb->hscb->task_management);\n\t\t} else {\n\t\t\t \n\t\t\tpending_scb->hscb->control |= MK_MESSAGE|DISCONNECTED;\n\n\t\t\t \n\t\t\tahd_outb(ahd, SCB_CONTROL,\n\t\t\t\t ahd_inb(ahd, SCB_CONTROL)|MK_MESSAGE);\n\t\t}\n\n\t\t \n\t\tahd_search_qinfifo(ahd, cmd->device->id,\n\t\t\t\t   cmd->device->channel + 'A', cmd->device->lun,\n\t\t\t\t   SCB_LIST_NULL, ROLE_INITIATOR,\n\t\t\t\t   CAM_REQUEUE_REQ, SEARCH_COMPLETE);\n\t\tahd_qinfifo_requeue_tail(ahd, pending_scb);\n\t\tahd_set_scbptr(ahd, saved_scbptr);\n\t\tahd_print_path(ahd, pending_scb);\n\t\tprintk(\"Device is disconnected, re-queuing SCB\\n\");\n\t\twait = TRUE;\n\t} else {\n\t\tscmd_printk(KERN_INFO, cmd, \"Unable to deliver message\\n\");\n\t\tretval = FAILED;\n\t}\n\n\n\tahd_restore_modes(ahd, saved_modes);\ndone:\n\tif (paused)\n\t\tahd_unpause(ahd);\n\tif (wait) {\n\t\tDECLARE_COMPLETION_ONSTACK(done);\n\n\t\tahd->platform_data->eh_done = &done;\n\t\tahd_unlock(ahd, &flags);\n\n\t\tprintk(\"%s: Recovery code sleeping\\n\", ahd_name(ahd));\n\t\tif (!wait_for_completion_timeout(&done, 5 * HZ)) {\n\t\t\tahd_lock(ahd, &flags);\n\t\t\tahd->platform_data->eh_done = NULL;\n\t\t\tahd_unlock(ahd, &flags);\n\t\t\tprintk(\"%s: Timer Expired (active %d)\\n\",\n\t\t\t       ahd_name(ahd), dev->active);\n\t\t\tretval = FAILED;\n\t\t}\n\t\tprintk(\"Recovery code awake\\n\");\n\t} else\n\t\tahd_unlock(ahd, &flags);\n\n\tif (retval != SUCCESS)\n\t\tprintk(\"%s: Command abort returning 0x%x\\n\",\n\t\t       ahd_name(ahd), retval);\n\n\treturn retval;\n}\n\nstatic void ahd_linux_set_width(struct scsi_target *starget, int width)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\n\tstruct ahd_devinfo devinfo;\n\tunsigned long flags;\n\n\tahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\tahd_lock(ahd, &flags);\n\tahd_set_width(ahd, &devinfo, width, AHD_TRANS_GOAL, FALSE);\n\tahd_unlock(ahd, &flags);\n}\n\nstatic void ahd_linux_set_period(struct scsi_target *starget, int period)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\n\tstruct ahd_tmode_tstate *tstate;\n\tstruct ahd_initiator_tinfo *tinfo \n\t\t= ahd_fetch_transinfo(ahd,\n\t\t\t\t      starget->channel + 'A',\n\t\t\t\t      shost->this_id, starget->id, &tstate);\n\tstruct ahd_devinfo devinfo;\n\tunsigned int ppr_options = tinfo->goal.ppr_options;\n\tunsigned int dt;\n\tunsigned long flags;\n\tunsigned long offset = tinfo->goal.offset;\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_DV) != 0)\n\t\tprintk(\"%s: set period to %d\\n\", ahd_name(ahd), period);\n#endif\n\tif (offset == 0)\n\t\toffset = MAX_OFFSET;\n\n\tif (period < 8)\n\t\tperiod = 8;\n\tif (period < 10) {\n\t\tif (spi_max_width(starget)) {\n\t\t\tppr_options |= MSG_EXT_PPR_DT_REQ;\n\t\t\tif (period == 8)\n\t\t\t\tppr_options |= MSG_EXT_PPR_IU_REQ;\n\t\t} else\n\t\t\tperiod = 10;\n\t}\n\n\tdt = ppr_options & MSG_EXT_PPR_DT_REQ;\n\n\tahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\n\t \n\tif (ppr_options & ~MSG_EXT_PPR_QAS_REQ) {\n\t\tif (spi_width(starget) == 0)\n\t\t\tppr_options &= MSG_EXT_PPR_QAS_REQ;\n\t}\n\n\tahd_find_syncrate(ahd, &period, &ppr_options,\n\t\t\t  dt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\n\n\tahd_lock(ahd, &flags);\n\tahd_set_syncrate(ahd, &devinfo, period, offset,\n\t\t\t ppr_options, AHD_TRANS_GOAL, FALSE);\n\tahd_unlock(ahd, &flags);\n}\n\nstatic void ahd_linux_set_offset(struct scsi_target *starget, int offset)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\n\tstruct ahd_tmode_tstate *tstate;\n\tstruct ahd_initiator_tinfo *tinfo \n\t\t= ahd_fetch_transinfo(ahd,\n\t\t\t\t      starget->channel + 'A',\n\t\t\t\t      shost->this_id, starget->id, &tstate);\n\tstruct ahd_devinfo devinfo;\n\tunsigned int ppr_options = 0;\n\tunsigned int period = 0;\n\tunsigned int dt = ppr_options & MSG_EXT_PPR_DT_REQ;\n\tunsigned long flags;\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_DV) != 0)\n\t\tprintk(\"%s: set offset to %d\\n\", ahd_name(ahd), offset);\n#endif\n\n\tahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\tif (offset != 0) {\n\t\tperiod = tinfo->goal.period;\n\t\tppr_options = tinfo->goal.ppr_options;\n\t\tahd_find_syncrate(ahd, &period, &ppr_options, \n\t\t\t\t  dt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\n\t}\n\n\tahd_lock(ahd, &flags);\n\tahd_set_syncrate(ahd, &devinfo, period, offset, ppr_options,\n\t\t\t AHD_TRANS_GOAL, FALSE);\n\tahd_unlock(ahd, &flags);\n}\n\nstatic void ahd_linux_set_dt(struct scsi_target *starget, int dt)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\n\tstruct ahd_tmode_tstate *tstate;\n\tstruct ahd_initiator_tinfo *tinfo \n\t\t= ahd_fetch_transinfo(ahd,\n\t\t\t\t      starget->channel + 'A',\n\t\t\t\t      shost->this_id, starget->id, &tstate);\n\tstruct ahd_devinfo devinfo;\n\tunsigned int ppr_options = tinfo->goal.ppr_options\n\t\t& ~MSG_EXT_PPR_DT_REQ;\n\tunsigned int period = tinfo->goal.period;\n\tunsigned int width = tinfo->goal.width;\n\tunsigned long flags;\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_DV) != 0)\n\t\tprintk(\"%s: %s DT\\n\", ahd_name(ahd),\n\t\t       dt ? \"enabling\" : \"disabling\");\n#endif\n\tif (dt && spi_max_width(starget)) {\n\t\tppr_options |= MSG_EXT_PPR_DT_REQ;\n\t\tif (!width)\n\t\t\tahd_linux_set_width(starget, 1);\n\t} else {\n\t\tif (period <= 9)\n\t\t\tperiod = 10;  \n\t\t \n\t\tppr_options &= ~MSG_EXT_PPR_IU_REQ;\n\t}\n\tahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\tahd_find_syncrate(ahd, &period, &ppr_options,\n\t\t\t  dt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\n\n\tahd_lock(ahd, &flags);\n\tahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\n\t\t\t ppr_options, AHD_TRANS_GOAL, FALSE);\n\tahd_unlock(ahd, &flags);\n}\n\nstatic void ahd_linux_set_qas(struct scsi_target *starget, int qas)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\n\tstruct ahd_tmode_tstate *tstate;\n\tstruct ahd_initiator_tinfo *tinfo \n\t\t= ahd_fetch_transinfo(ahd,\n\t\t\t\t      starget->channel + 'A',\n\t\t\t\t      shost->this_id, starget->id, &tstate);\n\tstruct ahd_devinfo devinfo;\n\tunsigned int ppr_options = tinfo->goal.ppr_options\n\t\t& ~MSG_EXT_PPR_QAS_REQ;\n\tunsigned int period = tinfo->goal.period;\n\tunsigned int dt;\n\tunsigned long flags;\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_DV) != 0)\n\t\tprintk(\"%s: %s QAS\\n\", ahd_name(ahd),\n\t\t       qas ? \"enabling\" : \"disabling\");\n#endif\n\n\tif (qas) {\n\t\tppr_options |= MSG_EXT_PPR_QAS_REQ; \n\t}\n\n\tdt = ppr_options & MSG_EXT_PPR_DT_REQ;\n\n\tahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\tahd_find_syncrate(ahd, &period, &ppr_options,\n\t\t\t  dt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\n\n\tahd_lock(ahd, &flags);\n\tahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\n\t\t\t ppr_options, AHD_TRANS_GOAL, FALSE);\n\tahd_unlock(ahd, &flags);\n}\n\nstatic void ahd_linux_set_iu(struct scsi_target *starget, int iu)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\n\tstruct ahd_tmode_tstate *tstate;\n\tstruct ahd_initiator_tinfo *tinfo \n\t\t= ahd_fetch_transinfo(ahd,\n\t\t\t\t      starget->channel + 'A',\n\t\t\t\t      shost->this_id, starget->id, &tstate);\n\tstruct ahd_devinfo devinfo;\n\tunsigned int ppr_options = tinfo->goal.ppr_options\n\t\t& ~MSG_EXT_PPR_IU_REQ;\n\tunsigned int period = tinfo->goal.period;\n\tunsigned int dt;\n\tunsigned long flags;\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_DV) != 0)\n\t\tprintk(\"%s: %s IU\\n\", ahd_name(ahd),\n\t\t       iu ? \"enabling\" : \"disabling\");\n#endif\n\n\tif (iu && spi_max_width(starget)) {\n\t\tppr_options |= MSG_EXT_PPR_IU_REQ;\n\t\tppr_options |= MSG_EXT_PPR_DT_REQ;  \n\t}\n\n\tdt = ppr_options & MSG_EXT_PPR_DT_REQ;\n\n\tahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\tahd_find_syncrate(ahd, &period, &ppr_options,\n\t\t\t  dt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\n\n\tahd_lock(ahd, &flags);\n\tahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\n\t\t\t ppr_options, AHD_TRANS_GOAL, FALSE);\n\tahd_unlock(ahd, &flags);\n}\n\nstatic void ahd_linux_set_rd_strm(struct scsi_target *starget, int rdstrm)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\n\tstruct ahd_tmode_tstate *tstate;\n\tstruct ahd_initiator_tinfo *tinfo \n\t\t= ahd_fetch_transinfo(ahd,\n\t\t\t\t      starget->channel + 'A',\n\t\t\t\t      shost->this_id, starget->id, &tstate);\n\tstruct ahd_devinfo devinfo;\n\tunsigned int ppr_options = tinfo->goal.ppr_options\n\t\t& ~MSG_EXT_PPR_RD_STRM;\n\tunsigned int period = tinfo->goal.period;\n\tunsigned int dt = ppr_options & MSG_EXT_PPR_DT_REQ;\n\tunsigned long flags;\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_DV) != 0)\n\t\tprintk(\"%s: %s Read Streaming\\n\", ahd_name(ahd),\n\t\t       rdstrm  ? \"enabling\" : \"disabling\");\n#endif\n\n\tif (rdstrm && spi_max_width(starget))\n\t\tppr_options |= MSG_EXT_PPR_RD_STRM;\n\n\tahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\tahd_find_syncrate(ahd, &period, &ppr_options,\n\t\t\t  dt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\n\n\tahd_lock(ahd, &flags);\n\tahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\n\t\t\t ppr_options, AHD_TRANS_GOAL, FALSE);\n\tahd_unlock(ahd, &flags);\n}\n\nstatic void ahd_linux_set_wr_flow(struct scsi_target *starget, int wrflow)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\n\tstruct ahd_tmode_tstate *tstate;\n\tstruct ahd_initiator_tinfo *tinfo \n\t\t= ahd_fetch_transinfo(ahd,\n\t\t\t\t      starget->channel + 'A',\n\t\t\t\t      shost->this_id, starget->id, &tstate);\n\tstruct ahd_devinfo devinfo;\n\tunsigned int ppr_options = tinfo->goal.ppr_options\n\t\t& ~MSG_EXT_PPR_WR_FLOW;\n\tunsigned int period = tinfo->goal.period;\n\tunsigned int dt = ppr_options & MSG_EXT_PPR_DT_REQ;\n\tunsigned long flags;\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_DV) != 0)\n\t\tprintk(\"%s: %s Write Flow Control\\n\", ahd_name(ahd),\n\t\t       wrflow ? \"enabling\" : \"disabling\");\n#endif\n\n\tif (wrflow && spi_max_width(starget))\n\t\tppr_options |= MSG_EXT_PPR_WR_FLOW;\n\n\tahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\tahd_find_syncrate(ahd, &period, &ppr_options,\n\t\t\t  dt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\n\n\tahd_lock(ahd, &flags);\n\tahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\n\t\t\t ppr_options, AHD_TRANS_GOAL, FALSE);\n\tahd_unlock(ahd, &flags);\n}\n\nstatic void ahd_linux_set_rti(struct scsi_target *starget, int rti)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\n\tstruct ahd_tmode_tstate *tstate;\n\tstruct ahd_initiator_tinfo *tinfo \n\t\t= ahd_fetch_transinfo(ahd,\n\t\t\t\t      starget->channel + 'A',\n\t\t\t\t      shost->this_id, starget->id, &tstate);\n\tstruct ahd_devinfo devinfo;\n\tunsigned int ppr_options = tinfo->goal.ppr_options\n\t\t& ~MSG_EXT_PPR_RTI;\n\tunsigned int period = tinfo->goal.period;\n\tunsigned int dt = ppr_options & MSG_EXT_PPR_DT_REQ;\n\tunsigned long flags;\n\n\tif ((ahd->features & AHD_RTI) == 0) {\n#ifdef AHD_DEBUG\n\t\tif ((ahd_debug & AHD_SHOW_DV) != 0)\n\t\t\tprintk(\"%s: RTI not available\\n\", ahd_name(ahd));\n#endif\n\t\treturn;\n\t}\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_DV) != 0)\n\t\tprintk(\"%s: %s RTI\\n\", ahd_name(ahd),\n\t\t       rti ? \"enabling\" : \"disabling\");\n#endif\n\n\tif (rti && spi_max_width(starget))\n\t\tppr_options |= MSG_EXT_PPR_RTI;\n\n\tahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\tahd_find_syncrate(ahd, &period, &ppr_options,\n\t\t\t  dt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\n\n\tahd_lock(ahd, &flags);\n\tahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\n\t\t\t ppr_options, AHD_TRANS_GOAL, FALSE);\n\tahd_unlock(ahd, &flags);\n}\n\nstatic void ahd_linux_set_pcomp_en(struct scsi_target *starget, int pcomp)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\n\tstruct ahd_tmode_tstate *tstate;\n\tstruct ahd_initiator_tinfo *tinfo \n\t\t= ahd_fetch_transinfo(ahd,\n\t\t\t\t      starget->channel + 'A',\n\t\t\t\t      shost->this_id, starget->id, &tstate);\n\tstruct ahd_devinfo devinfo;\n\tunsigned int ppr_options = tinfo->goal.ppr_options\n\t\t& ~MSG_EXT_PPR_PCOMP_EN;\n\tunsigned int period = tinfo->goal.period;\n\tunsigned int dt = ppr_options & MSG_EXT_PPR_DT_REQ;\n\tunsigned long flags;\n\n#ifdef AHD_DEBUG\n\tif ((ahd_debug & AHD_SHOW_DV) != 0)\n\t\tprintk(\"%s: %s Precompensation\\n\", ahd_name(ahd),\n\t\t       pcomp ? \"Enable\" : \"Disable\");\n#endif\n\n\tif (pcomp && spi_max_width(starget)) {\n\t\tuint8_t precomp;\n\n\t\tif (ahd->unit < ARRAY_SIZE(aic79xx_iocell_info)) {\n\t\t\tconst struct ahd_linux_iocell_opts *iocell_opts;\n\n\t\t\tiocell_opts = &aic79xx_iocell_info[ahd->unit];\n\t\t\tprecomp = iocell_opts->precomp;\n\t\t} else {\n\t\t\tprecomp = AIC79XX_DEFAULT_PRECOMP;\n\t\t}\n\t\tppr_options |= MSG_EXT_PPR_PCOMP_EN;\n\t\tAHD_SET_PRECOMP(ahd, precomp);\n\t} else {\n\t\tAHD_SET_PRECOMP(ahd, 0);\n\t}\n\n\tahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\tahd_find_syncrate(ahd, &period, &ppr_options,\n\t\t\t  dt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\n\n\tahd_lock(ahd, &flags);\n\tahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\n\t\t\t ppr_options, AHD_TRANS_GOAL, FALSE);\n\tahd_unlock(ahd, &flags);\n}\n\nstatic void ahd_linux_set_hold_mcs(struct scsi_target *starget, int hold)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\n\tstruct ahd_tmode_tstate *tstate;\n\tstruct ahd_initiator_tinfo *tinfo \n\t\t= ahd_fetch_transinfo(ahd,\n\t\t\t\t      starget->channel + 'A',\n\t\t\t\t      shost->this_id, starget->id, &tstate);\n\tstruct ahd_devinfo devinfo;\n\tunsigned int ppr_options = tinfo->goal.ppr_options\n\t\t& ~MSG_EXT_PPR_HOLD_MCS;\n\tunsigned int period = tinfo->goal.period;\n\tunsigned int dt = ppr_options & MSG_EXT_PPR_DT_REQ;\n\tunsigned long flags;\n\n\tif (hold && spi_max_width(starget))\n\t\tppr_options |= MSG_EXT_PPR_HOLD_MCS;\n\n\tahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\tahd_find_syncrate(ahd, &period, &ppr_options,\n\t\t\t  dt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\n\n\tahd_lock(ahd, &flags);\n\tahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\n\t\t\t ppr_options, AHD_TRANS_GOAL, FALSE);\n\tahd_unlock(ahd, &flags);\n}\n\nstatic void ahd_linux_get_signalling(struct Scsi_Host *shost)\n{\n\tstruct ahd_softc *ahd = *(struct ahd_softc **)shost->hostdata;\n\tunsigned long flags;\n\tu8 mode;\n\n\tahd_lock(ahd, &flags);\n\tahd_pause(ahd);\n\tmode = ahd_inb(ahd, SBLKCTL);\n\tahd_unpause(ahd);\n\tahd_unlock(ahd, &flags);\n\n\tif (mode & ENAB40)\n\t\tspi_signalling(shost) = SPI_SIGNAL_LVD;\n\telse if (mode & ENAB20)\n\t\tspi_signalling(shost) = SPI_SIGNAL_SE;\n\telse\n\t\tspi_signalling(shost) = SPI_SIGNAL_UNKNOWN;\n}\n\nstatic struct spi_function_template ahd_linux_transport_functions = {\n\t.set_offset\t= ahd_linux_set_offset,\n\t.show_offset\t= 1,\n\t.set_period\t= ahd_linux_set_period,\n\t.show_period\t= 1,\n\t.set_width\t= ahd_linux_set_width,\n\t.show_width\t= 1,\n\t.set_dt\t\t= ahd_linux_set_dt,\n\t.show_dt\t= 1,\n\t.set_iu\t\t= ahd_linux_set_iu,\n\t.show_iu\t= 1,\n\t.set_qas\t= ahd_linux_set_qas,\n\t.show_qas\t= 1,\n\t.set_rd_strm\t= ahd_linux_set_rd_strm,\n\t.show_rd_strm\t= 1,\n\t.set_wr_flow\t= ahd_linux_set_wr_flow,\n\t.show_wr_flow\t= 1,\n\t.set_rti\t= ahd_linux_set_rti,\n\t.show_rti\t= 1,\n\t.set_pcomp_en\t= ahd_linux_set_pcomp_en,\n\t.show_pcomp_en\t= 1,\n\t.set_hold_mcs\t= ahd_linux_set_hold_mcs,\n\t.show_hold_mcs\t= 1,\n\t.get_signalling = ahd_linux_get_signalling,\n};\n\nstatic int __init\nahd_linux_init(void)\n{\n\tint\terror = 0;\n\n\t \n\tif (aic79xx)\n\t\taic79xx_setup(aic79xx);\n\n\tahd_linux_transport_template =\n\t\tspi_attach_transport(&ahd_linux_transport_functions);\n\tif (!ahd_linux_transport_template)\n\t\treturn -ENODEV;\n\n\tscsi_transport_reserve_device(ahd_linux_transport_template,\n\t\t\t\t      sizeof(struct ahd_linux_device));\n\n\terror = ahd_linux_pci_init();\n\tif (error)\n\t\tspi_release_transport(ahd_linux_transport_template);\n\treturn error;\n}\n\nstatic void __exit\nahd_linux_exit(void)\n{\n\tahd_linux_pci_exit();\n\tspi_release_transport(ahd_linux_transport_template);\n}\n\nmodule_init(ahd_linux_init);\nmodule_exit(ahd_linux_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}