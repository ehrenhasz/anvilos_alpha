{
  "module_name": "aic7xxx.h",
  "hash_id": "8ca2255d5e2920b20d2ef784b7b3a863a3aa48dc995005c79b9296fc935c0f84",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic7xxx.h",
  "human_readable_source": " \n\n#ifndef _AIC7XXX_H_\n#define _AIC7XXX_H_\n\n \n#include \"aic7xxx_reg.h\"\n\n \nstruct ahc_platform_data;\nstruct scb_platform_data;\nstruct seeprom_descriptor;\n\n \n#ifndef TRUE\n#define TRUE 1\n#endif\n#ifndef FALSE\n#define FALSE 0\n#endif\n\n#define ALL_CHANNELS '\\0'\n#define ALL_TARGETS_MASK 0xFFFF\n#define INITIATOR_WILDCARD\t(~0)\n\n#define SCSIID_TARGET(ahc, scsiid) \\\n\t(((scsiid) & ((((ahc)->features & AHC_TWIN) != 0) ? TWIN_TID : TID)) \\\n\t>> TID_SHIFT)\n#define SCSIID_OUR_ID(scsiid) \\\n\t((scsiid) & OID)\n#define SCSIID_CHANNEL(ahc, scsiid) \\\n\t((((ahc)->features & AHC_TWIN) != 0) \\\n        ? ((((scsiid) & TWIN_CHNLB) != 0) ? 'B' : 'A') \\\n       : 'A')\n#define\tSCB_IS_SCSIBUS_B(ahc, scb) \\\n\t(SCSIID_CHANNEL(ahc, (scb)->hscb->scsiid) == 'B')\n#define\tSCB_GET_OUR_ID(scb) \\\n\tSCSIID_OUR_ID((scb)->hscb->scsiid)\n#define\tSCB_GET_TARGET(ahc, scb) \\\n\tSCSIID_TARGET((ahc), (scb)->hscb->scsiid)\n#define\tSCB_GET_CHANNEL(ahc, scb) \\\n\tSCSIID_CHANNEL(ahc, (scb)->hscb->scsiid)\n#define\tSCB_GET_LUN(scb) \\\n\t((scb)->hscb->lun & LID)\n#define SCB_GET_TARGET_OFFSET(ahc, scb)\t\\\n\t(SCB_GET_TARGET(ahc, scb) + (SCB_IS_SCSIBUS_B(ahc, scb) ? 8 : 0))\n#define SCB_GET_TARGET_MASK(ahc, scb) \\\n\t(0x01 << (SCB_GET_TARGET_OFFSET(ahc, scb)))\n#ifdef AHC_DEBUG\n#define SCB_IS_SILENT(scb)\t\t\t\t\t\\\n\t((ahc_debug & AHC_SHOW_MASKED_ERRORS) == 0\t\t\\\n      && (((scb)->flags & SCB_SILENT) != 0))\n#else\n#define SCB_IS_SILENT(scb)\t\t\t\t\t\\\n\t(((scb)->flags & SCB_SILENT) != 0)\n#endif\n#define TCL_TARGET_OFFSET(tcl) \\\n\t((((tcl) >> 4) & TID) >> 4)\n#define TCL_LUN(tcl) \\\n\t(tcl & (AHC_NUM_LUNS - 1))\n#define BUILD_TCL(scsiid, lun) \\\n\t((lun) | (((scsiid) & TID) << 4))\n\n#ifndef\tAHC_TARGET_MODE\n#undef\tAHC_TMODE_ENABLE\n#define\tAHC_TMODE_ENABLE 0\n#endif\n\n \n \n#define AHC_NUM_TARGETS 16\n\n \n#define AHC_NUM_LUNS 64\n\n \n#define AHC_MAXTRANSFER_SIZE\t 0x00ffffff\t \n\n \n#define AHC_SCB_MAX\t255\n\n \n#define AHC_MAX_QUEUE\t253\n\n \n#define AHC_SCB_MAX_ALLOC (AHC_MAX_QUEUE+1)\n\n \n#define AHC_TMODE_CMDS\t256\n\n \n#define AHC_BUSRESET_DELAY\t25\n\n \n \ntypedef enum {\n\tAHC_NONE\t= 0x0000,\n\tAHC_CHIPID_MASK\t= 0x00FF,\n\tAHC_AIC7770\t= 0x0001,\n\tAHC_AIC7850\t= 0x0002,\n\tAHC_AIC7855\t= 0x0003,\n\tAHC_AIC7859\t= 0x0004,\n\tAHC_AIC7860\t= 0x0005,\n\tAHC_AIC7870\t= 0x0006,\n\tAHC_AIC7880\t= 0x0007,\n\tAHC_AIC7895\t= 0x0008,\n\tAHC_AIC7895C\t= 0x0009,\n\tAHC_AIC7890\t= 0x000a,\n\tAHC_AIC7896\t= 0x000b,\n\tAHC_AIC7892\t= 0x000c,\n\tAHC_AIC7899\t= 0x000d,\n\tAHC_VL\t\t= 0x0100,\t \n\tAHC_EISA\t= 0x0200,\t \n\tAHC_PCI\t\t= 0x0400,\t \n\tAHC_BUS_MASK\t= 0x0F00\n} ahc_chip;\n\n \ntypedef enum {\n\tAHC_FENONE\t= 0x00000,\n\tAHC_ULTRA\t= 0x00001,\t \n\tAHC_ULTRA2\t= 0x00002,\t \n\tAHC_WIDE  \t= 0x00004,\t \n\tAHC_TWIN\t= 0x00008,\t \n\tAHC_MORE_SRAM\t= 0x00010,\t \n\tAHC_CMD_CHAN\t= 0x00020,\t \n\tAHC_QUEUE_REGS\t= 0x00040,\t \n\tAHC_SG_PRELOAD\t= 0x00080,\t \n\tAHC_SPIOCAP\t= 0x00100,\t \n\tAHC_MULTI_TID\t= 0x00200,\t \n\tAHC_HS_MAILBOX\t= 0x00400,\t \n\tAHC_DT\t\t= 0x00800,\t \n\tAHC_NEW_TERMCTL\t= 0x01000,\t \n\tAHC_MULTI_FUNC\t= 0x02000,\t \n\tAHC_LARGE_SCBS\t= 0x04000,\t \n\tAHC_AUTORATE\t= 0x08000,\t \n\tAHC_AUTOPAUSE\t= 0x10000,\t \n\tAHC_TARGETMODE\t= 0x20000,\t \n\tAHC_MULTIROLE\t= 0x40000,\t \n\tAHC_REMOVABLE\t= 0x80000,\t \n\tAHC_HVD\t\t= 0x100000,\t \n\tAHC_AIC7770_FE\t= AHC_FENONE,\n\t \n\tAHC_AIC7850_FE\t= AHC_SPIOCAP|AHC_AUTOPAUSE|AHC_TARGETMODE|AHC_ULTRA,\n\tAHC_AIC7860_FE\t= AHC_AIC7850_FE,\n\tAHC_AIC7870_FE\t= AHC_TARGETMODE|AHC_AUTOPAUSE,\n\tAHC_AIC7880_FE\t= AHC_AIC7870_FE|AHC_ULTRA,\n\t \n\tAHC_AIC7890_FE\t= AHC_MORE_SRAM|AHC_CMD_CHAN|AHC_ULTRA2\n\t\t\t  |AHC_QUEUE_REGS|AHC_SG_PRELOAD|AHC_MULTI_TID\n\t\t\t  |AHC_HS_MAILBOX|AHC_NEW_TERMCTL|AHC_LARGE_SCBS\n\t\t\t  |AHC_TARGETMODE,\n\tAHC_AIC7892_FE\t= AHC_AIC7890_FE|AHC_DT|AHC_AUTORATE|AHC_AUTOPAUSE,\n\tAHC_AIC7895_FE\t= AHC_AIC7880_FE|AHC_MORE_SRAM|AHC_AUTOPAUSE\n\t\t\t  |AHC_CMD_CHAN|AHC_MULTI_FUNC|AHC_LARGE_SCBS,\n\tAHC_AIC7895C_FE\t= AHC_AIC7895_FE|AHC_MULTI_TID,\n\tAHC_AIC7896_FE\t= AHC_AIC7890_FE|AHC_MULTI_FUNC,\n\tAHC_AIC7899_FE\t= AHC_AIC7892_FE|AHC_MULTI_FUNC\n} ahc_feature;\n\n \ntypedef enum {\n\tAHC_BUGNONE\t\t= 0x00,\n\t \n\tAHC_TMODE_WIDEODD_BUG\t= 0x01,\n\t \n\tAHC_AUTOFLUSH_BUG\t= 0x02,\n\t \n\tAHC_CACHETHEN_BUG\t= 0x04,\n\t \n\tAHC_CACHETHEN_DIS_BUG\t= 0x08,\n\t \n\tAHC_PCI_2_1_RETRY_BUG\t= 0x10,\n\t \n\tAHC_PCI_MWI_BUG\t\t= 0x20,\n\t \n\tAHC_SCBCHAN_UPLOAD_BUG\t= 0x40\n} ahc_bug;\n\n \ntypedef enum {\n\tAHC_FNONE\t      = 0x000,\n\tAHC_PRIMARY_CHANNEL   = 0x003,   \n\tAHC_USEDEFAULTS\t      = 0x004,   \n\tAHC_SEQUENCER_DEBUG   = 0x008,\n\tAHC_SHARED_SRAM\t      = 0x010,\n\tAHC_LARGE_SEEPROM     = 0x020,   \n\tAHC_RESET_BUS_A\t      = 0x040,\n\tAHC_RESET_BUS_B\t      = 0x080,\n\tAHC_EXTENDED_TRANS_A  = 0x100,\n\tAHC_EXTENDED_TRANS_B  = 0x200,\n\tAHC_TERM_ENB_A\t      = 0x400,\n\tAHC_TERM_ENB_B\t      = 0x800,\n\tAHC_INITIATORROLE     = 0x1000,   \n\tAHC_TARGETROLE\t      = 0x2000,   \n\tAHC_NEWEEPROM_FMT     = 0x4000,\n\tAHC_TQINFIFO_BLOCKED  = 0x10000,   \n\tAHC_INT50_SPEEDFLEX   = 0x20000,   \n\tAHC_SCB_BTT\t      = 0x40000,   \n\tAHC_BIOS_ENABLED      = 0x80000,\n\tAHC_ALL_INTERRUPTS    = 0x100000,\n\tAHC_PAGESCBS\t      = 0x400000,   \n\tAHC_EDGE_INTERRUPT    = 0x800000,   \n\tAHC_39BIT_ADDRESSING  = 0x1000000,  \n\tAHC_LSCBS_ENABLED     = 0x2000000,  \n\tAHC_SCB_CONFIG_USED   = 0x4000000,  \n\tAHC_NO_BIOS_INIT      = 0x8000000,  \n\tAHC_DISABLE_PCI_PERR  = 0x10000000,\n\tAHC_HAS_TERM_LOGIC    = 0x20000000\n} ahc_flag;\n\n \n\n \n\n \nstruct status_pkt {\n\tuint32_t residual_datacnt;\t \n\tuint32_t residual_sg_ptr;\t \n\tuint8_t\t scsi_status;\t\t \n};\n\n \nstruct target_data {\n\tuint32_t residual_datacnt;\t \n\tuint32_t residual_sg_ptr;\t \n\tuint8_t  scsi_status;\t\t \n\tuint8_t  target_phases;\t\t \n\tuint8_t  data_phase;\t\t \n\tuint8_t  initiator_tag;\t\t \n};\n\nstruct hardware_scb {\n \tunion {\n\t\t \n\t\tuint8_t\t cdb[12];\n\t\tuint32_t cdb_ptr;\n\t\tstruct\t status_pkt status;\n\t\tstruct\t target_data tdata;\n\t} shared_data;\n  \n \tuint32_t dataptr;\n \tuint32_t datacnt;\t\t \n \tuint32_t sgptr;\n#define SG_PTR_MASK\t0xFFFFFFF8\n \tuint8_t  control;\t \n \tuint8_t  scsiid;\t \n \tuint8_t  lun;\n \tuint8_t  tag;\t\t\t \n \tuint8_t  cdb_len;\n \tuint8_t  scsirate;\t\t \n \tuint8_t  scsioffset;\t\t \n \tuint8_t  next;\t\t\t \n \tuint8_t  cdb32[32];\t\t \n};\n\n \n \n\n \nstruct ahc_dma_seg {\n\tuint32_t\taddr;\n\tuint32_t\tlen;\n#define\tAHC_DMA_LAST_SEG\t0x80000000\n#define\tAHC_SG_HIGH_ADDR_MASK\t0x7F000000\n#define\tAHC_SG_LEN_MASK\t\t0x00FFFFFF\n};\n\nstruct sg_map_node {\n\tbus_dmamap_t\t\t sg_dmamap;\n\tdma_addr_t\t\t sg_physaddr;\n\tstruct ahc_dma_seg*\t sg_vaddr;\n\tSLIST_ENTRY(sg_map_node) links;\n};\n\n \ntypedef enum {\n\tSCB_FREE\t\t= 0x0000,\n\tSCB_OTHERTCL_TIMEOUT\t= 0x0002, \n\tSCB_DEVICE_RESET\t= 0x0004,\n\tSCB_SENSE\t\t= 0x0008,\n\tSCB_CDB32_PTR\t\t= 0x0010,\n\tSCB_RECOVERY_SCB\t= 0x0020,\n\tSCB_AUTO_NEGOTIATE\t= 0x0040, \n\tSCB_NEGOTIATE\t\t= 0x0080, \n\tSCB_ABORT\t\t= 0x0100,\n\tSCB_UNTAGGEDQ\t\t= 0x0200,\n\tSCB_ACTIVE\t\t= 0x0400,\n\tSCB_TARGET_IMMEDIATE\t= 0x0800,\n\tSCB_TRANSMISSION_ERROR\t= 0x1000, \n\tSCB_TARGET_SCB\t\t= 0x2000,\n\tSCB_SILENT\t\t= 0x4000  \n} scb_flag;\n\nstruct scb {\n\tstruct\thardware_scb\t *hscb;\n\tunion {\n\t\tSLIST_ENTRY(scb)  sle;\n\t\tTAILQ_ENTRY(scb)  tqe;\n\t} links;\n\tLIST_ENTRY(scb)\t\t  pending_links;\n\tahc_io_ctx_t\t\t  io_ctx;\n\tstruct ahc_softc\t *ahc_softc;\n\tscb_flag\t\t  flags;\n\tstruct scb_platform_data *platform_data;\n\tstruct sg_map_node\t *sg_map;\n\tstruct ahc_dma_seg \t *sg_list;\n\tdma_addr_t\t\t  sg_list_phys;\n\tu_int\t\t\t  sg_count; \n};\n\nstruct scb_data {\n\tSLIST_HEAD(, scb) free_scbs;\t \n\tstruct\tscb *scbindex[256];\t \n\tstruct\thardware_scb\t*hscbs;\t \n\tstruct\tscb *scbarray;\t\t \n\tstruct\tscsi_sense_data *sense;  \n\n\t \n\tbus_dma_tag_t\t hscb_dmat;\t \n\tbus_dmamap_t\t hscb_dmamap;\n\tdma_addr_t\t hscb_busaddr;\n\tbus_dma_tag_t\t sense_dmat;\n\tbus_dmamap_t\t sense_dmamap;\n\tdma_addr_t\t sense_busaddr;\n\tbus_dma_tag_t\t sg_dmat;\t \n\tSLIST_HEAD(, sg_map_node) sg_maps;\n\tuint8_t\tnumscbs;\n\tuint8_t\tmaxhscbs;\t\t \n\tuint8_t\tinit_level;\t\t \n};\n\n \n\n \nstruct target_cmd {\n\tuint8_t scsiid;\t\t \n\tuint8_t identify;\t \n\tuint8_t bytes[22];\t \n\tuint8_t cmd_valid;\t \n\tuint8_t pad[7];\n};\n\n \n#define AHC_TMODE_EVENT_BUFFER_SIZE 8\nstruct ahc_tmode_event {\n\tuint8_t initiator_id;\n\tuint8_t event_type;\t \n#define\tEVENT_TYPE_BUS_RESET 0xFF\n\tuint8_t event_arg;\n};\n\n \n#ifdef AHC_TARGET_MODE \nstruct ahc_tmode_lstate {\n\tstruct cam_path *path;\n\tstruct ccb_hdr_slist accept_tios;\n\tstruct ccb_hdr_slist immed_notifies;\n\tstruct ahc_tmode_event event_buffer[AHC_TMODE_EVENT_BUFFER_SIZE];\n\tuint8_t event_r_idx;\n\tuint8_t event_w_idx;\n};\n#else\nstruct ahc_tmode_lstate;\n#endif\n\n \n#define AHC_TRANS_CUR\t\t0x01\t \n#define AHC_TRANS_ACTIVE\t0x03\t \n#define AHC_TRANS_GOAL\t\t0x04\t \n#define AHC_TRANS_USER\t\t0x08\t \n\n#define AHC_WIDTH_UNKNOWN\t0xFF\n#define AHC_PERIOD_UNKNOWN\t0xFF\n#define AHC_OFFSET_UNKNOWN\t0xFF\n#define AHC_PPR_OPTS_UNKNOWN\t0xFF\n\n \nstruct ahc_transinfo {\n\tuint8_t protocol_version;\t \n\tuint8_t transport_version;\t \n\tuint8_t width;\t\t\t \n\tuint8_t period;\t\t\t \n\tuint8_t offset;\t\t\t \n\tuint8_t ppr_options;\t\t \n};\n\n \nstruct ahc_initiator_tinfo {\n\tuint8_t scsirate;\t\t \n\tstruct ahc_transinfo curr;\n\tstruct ahc_transinfo goal;\n\tstruct ahc_transinfo user;\n};\n\n \nstruct ahc_tmode_tstate {\n\tstruct ahc_tmode_lstate*\tenabled_luns[AHC_NUM_LUNS];\n\tstruct ahc_initiator_tinfo\ttransinfo[AHC_NUM_TARGETS];\n\n\t \n\tuint16_t\t auto_negotiate; \n\tuint16_t\t ultraenb;\t \n\tuint16_t\t discenable;\t \n\tuint16_t\t tagenable;\t \n};\n\n \nstruct ahc_syncrate {\n\tu_int sxfr_u2;\t \n\tu_int sxfr;\t \n#define\t\tULTRA_SXFR 0x100\t \n#define\t\tST_SXFR\t   0x010\t \n#define\t\tDT_SXFR\t   0x040\t \n\tuint8_t period;  \n\tconst char *rate;\n};\n\n \n#define\tAHC_ASYNC_XFER_PERIOD 0x45\n#define\tAHC_ULTRA2_XFER_PERIOD 0x0a\n\n \n#define AHC_SYNCRATE_DT\t\t0\n#define AHC_SYNCRATE_ULTRA2\t1\n#define AHC_SYNCRATE_ULTRA\t3\n#define AHC_SYNCRATE_FAST\t6\n#define AHC_SYNCRATE_MAX\tAHC_SYNCRATE_DT\n#define\tAHC_SYNCRATE_MIN\t13\n\n \n \nstruct ahc_phase_table_entry {\n        uint8_t phase;\n        uint8_t mesg_out;  \n\tchar *phasemsg;\n};\n\n \n\nstruct seeprom_config {\n \n\tuint16_t device_flags[16];\t \n#define\t\tCFXFER\t\t0x0007\t \n#define\t\tCFSYNCH\t\t0x0008\t \n#define\t\tCFDISC\t\t0x0010\t \n#define\t\tCFWIDEB\t\t0x0020\t \n#define\t\tCFSYNCHISULTRA\t0x0040\t \n#define\t\tCFSYNCSINGLE\t0x0080\t \n#define\t\tCFSTART\t\t0x0100\t \n#define\t\tCFINCBIOS\t0x0200\t \n#define\t\tCFRNFOUND\t0x0400\t \n#define\t\tCFMULTILUNDEV\t0x0800\t \n#define\t\tCFWBCACHEENB\t0x4000\t \n#define\t\tCFWBCACHENOP\t0xc000\t \n\n \n\tuint16_t bios_control;\t\t \n#define\t\tCFSUPREM\t0x0001\t \n#define\t\tCFSUPREMB\t0x0002\t \n#define\t\tCFBIOSEN\t0x0004\t \n#define\t\tCFBIOS_BUSSCAN\t0x0008\t \n#define\t\tCFSM2DRV\t0x0010\t \n#define\t\tCFSTPWLEVEL\t0x0010\t \n#define\t\tCF284XEXTEND\t0x0020\t \t\n#define\t\tCFCTRL_A\t0x0020\t \t\n#define\t\tCFTERM_MENU\t0x0040\t \t\n#define\t\tCFEXTEND\t0x0080\t \n#define\t\tCFSCAMEN\t0x0100\t \n#define\t\tCFMSG_LEVEL\t0x0600\t \n#define\t\t\tCFMSG_VERBOSE\t0x0000\n#define\t\t\tCFMSG_SILENT\t0x0200\n#define\t\t\tCFMSG_DIAG\t0x0400\n#define\t\tCFBOOTCD\t0x0800   \n \n\n \n\tuint16_t adapter_control;\t \t\n#define\t\tCFAUTOTERM\t0x0001\t \n#define\t\tCFULTRAEN\t0x0002\t \n#define\t\tCF284XSELTO     0x0003\t \n#define\t\tCF284XFIFO      0x000C\t \n#define\t\tCFSTERM\t\t0x0004\t \n#define\t\tCFWSTERM\t0x0008\t \n#define\t\tCFSPARITY\t0x0010\t \n#define\t\tCF284XSTERM     0x0020\t \t\n#define\t\tCFMULTILUN\t0x0020\n#define\t\tCFRESETB\t0x0040\t \n#define\t\tCFCLUSTERENB\t0x0080\t \n#define\t\tCFBOOTCHAN\t0x0300\t \n#define\t\tCFBOOTCHANSHIFT 8\n#define\t\tCFSEAUTOTERM\t0x0400\t \n#define\t\tCFSELOWTERM\t0x0800\t \n#define\t\tCFSEHIGHTERM\t0x1000\t \n#define\t\tCFENABLEDV\t0x4000\t \n\n \n\tuint16_t brtime_id;\t\t \n#define\t\tCFSCSIID\t0x000f\t \n \n#define\t\tCFBRTIME\t0xff00\t \n\n \n\tuint16_t max_targets;\t\t \t\n#define\t\tCFMAXTARG\t0x00ff\t \n#define\t\tCFBOOTLUN\t0x0f00\t \n#define\t\tCFBOOTID\t0xf000\t \n\tuint16_t res_1[10];\t\t \n\tuint16_t signature;\t\t \n#define\t\tCFSIGNATURE\t0x250\n#define\t\tCFSIGNATURE2\t0x300\n\tuint16_t checksum;\t\t \n};\n\n \ntypedef enum {\n\tMSG_TYPE_NONE\t\t\t= 0x00,\n\tMSG_TYPE_INITIATOR_MSGOUT\t= 0x01,\n\tMSG_TYPE_INITIATOR_MSGIN\t= 0x02,\n\tMSG_TYPE_TARGET_MSGOUT\t\t= 0x03,\n\tMSG_TYPE_TARGET_MSGIN\t\t= 0x04\n} ahc_msg_type;\n\ntypedef enum {\n\tMSGLOOP_IN_PROG,\n\tMSGLOOP_MSGCOMPLETE,\n\tMSGLOOP_TERMINATED\n} msg_loop_stat;\n\n \nTAILQ_HEAD(scb_tailq, scb);\n\nstruct ahc_aic7770_softc {\n\t \n\tuint8_t busspd;\n\tuint8_t bustime;\n};\n\nstruct ahc_pci_softc {\n\t \n\tuint32_t  devconfig;\n\tuint16_t  targcrccnt;\n\tuint8_t   command;\n\tuint8_t   csize_lattime;\n\tuint8_t   optionmode;\n\tuint8_t   crccontrol1;\n\tuint8_t   dscommand0;\n\tuint8_t   dspcistatus;\n\tuint8_t   scbbaddr;\n\tuint8_t   dff_thrsh;\n};\n\nunion ahc_bus_softc {\n\tstruct ahc_aic7770_softc aic7770_softc;\n\tstruct ahc_pci_softc pci_softc;\n};\n\ntypedef void (*ahc_bus_intr_t)(struct ahc_softc *);\ntypedef int (*ahc_bus_chip_init_t)(struct ahc_softc *);\ntypedef void ahc_callback_t (void *);\n\nstruct ahc_softc {\n\tbus_space_tag_t           tag;\n\tbus_space_handle_t        bsh;\n\tstruct scb_data\t\t *scb_data;\n\n\tstruct scb\t\t *next_queued_scb;\n\n\t \n\tBSD_LIST_HEAD(, scb)\t  pending_scbs;\n\n\t \n\tu_int\t\t\t  untagged_queue_lock;\n\n\t \n\tstruct scb_tailq\t  untagged_queues[AHC_NUM_TARGETS];\n\n\t \n\tunion ahc_bus_softc\t  bus_softc;\n\n\t \n\tstruct ahc_platform_data *platform_data;\n\n\t \n\tahc_dev_softc_t\t\t  dev_softc;\n\tstruct device\t\t  *dev;\n\n\t \n\tahc_bus_intr_t\t\t  bus_intr;\n\n\t \n\tahc_bus_chip_init_t\t  bus_chip_init;\n\n\t \n\tstruct ahc_tmode_tstate  *enabled_targets[AHC_NUM_TARGETS];\n\n\t \n\tstruct ahc_tmode_lstate  *black_hole;\n\n\t \n\tstruct ahc_tmode_lstate  *pending_device;\n\n\t \n\tahc_chip\t\t  chip;\n\tahc_feature\t\t  features;\n\tahc_bug\t\t\t  bugs;\n\tahc_flag\t\t  flags;\n\tstruct seeprom_config\t *seep_config;\n\n\t \n\tuint8_t\t\t\t  unpause;\n\tuint8_t\t\t\t  pause;\n\n\t \n\tuint8_t\t\t\t  qoutfifonext;\n\tuint8_t\t\t\t  qinfifonext;\n\tuint8_t\t\t\t *qoutfifo;\n\tuint8_t\t\t\t *qinfifo;\n\n\t \n\tstruct cs\t\t *critical_sections;\n\tu_int\t\t\t  num_critical_sections;\n\n\t \n\tchar\t\t\t  channel;\n\tchar\t\t\t  channel_b;\n\n\t \n\tuint8_t\t\t\t  our_id;\n\tuint8_t\t\t\t  our_id_b;\n\n\t \n\tint\t\t\t  unsolicited_ints;\n\n\t \n\tstruct target_cmd\t *targetcmds;\n\tuint8_t\t\t\t  tqinfifonext;\n\n\t \n\tuint8_t\t\t\t  seqctl;\n\n\t \n\tuint8_t\t\t\t  send_msg_perror;\n\tahc_msg_type\t\t  msg_type;\n\tuint8_t\t\t\t  msgout_buf[12]; \n\tuint8_t\t\t\t  msgin_buf[12]; \n\tu_int\t\t\t  msgout_len;\t \n\tu_int\t\t\t  msgout_index;\t \n\tu_int\t\t\t  msgin_index;\t \n\n\t \n\tbus_dma_tag_t\t\t  parent_dmat;\n\tbus_dma_tag_t\t\t  shared_data_dmat;\n\tbus_dmamap_t\t\t  shared_data_dmamap;\n\tdma_addr_t\t\t  shared_data_busaddr;\n\n\t \n\tdma_addr_t\t\t  dma_bug_buf;\n\n\t \n\tu_int\t\t\t  enabled_luns;\n\n\t \n\tu_int\t\t\t  init_level;\n\n\t \n\tu_int\t\t\t  pci_cachesize;\n\n\t \n\tu_int\t\t\t  pci_target_perr_count;\n#define\t\tAHC_PCI_TARGET_PERR_THRESH\t10\n\n\t \n\tu_int\t\t\t  instruction_ram_size;\n\n\t \n\tconst char\t\t *description;\n\tchar\t\t\t *name;\n\tint\t\t\t  unit;\n\n\t \n\tint\t\t\t  seltime;\n\tint\t\t\t  seltime_b;\n\n\tuint16_t\t \t  user_discenable; \n\tuint16_t\t\t  user_tagenable; \n};\n\n \ntypedef enum {\n\tROLE_UNKNOWN,\n\tROLE_INITIATOR,\n\tROLE_TARGET\n} role_t;\n\nstruct ahc_devinfo {\n\tint\t our_scsiid;\n\tint\t target_offset;\n\tuint16_t target_mask;\n\tu_int\t target;\n\tu_int\t lun;\n\tchar\t channel;\n\trole_t\t role;\t\t \n};\n\n \ntypedef int (ahc_device_setup_t)(struct ahc_softc *);\n\nstruct ahc_pci_identity {\n\tuint64_t\t\t full_id;\n\tuint64_t\t\t id_mask;\n\tconst char\t\t*name;\n\tahc_device_setup_t\t*setup;\n};\n\n \nstruct aic7770_identity {\n\tuint32_t\t\t full_id;\n\tuint32_t\t\t id_mask;\n\tconst char\t\t*name;\n\tahc_device_setup_t\t*setup;\n};\nextern struct aic7770_identity aic7770_ident_table[];\nextern const int ahc_num_aic7770_devs;\n\n#define AHC_EISA_SLOT_OFFSET\t0xc00\n#define AHC_EISA_IOSIZE\t\t0x100\n\n \n \n\n \nconst struct ahc_pci_identity\t*ahc_find_pci_device(ahc_dev_softc_t);\nint\t\t\t ahc_pci_config(struct ahc_softc *,\n\t\t\t\t\tconst struct ahc_pci_identity *);\nint\t\t\t ahc_pci_test_register_access(struct ahc_softc *);\nvoid __maybe_unused\t ahc_pci_resume(struct ahc_softc *ahc);\n\n \nstruct aic7770_identity *aic7770_find_device(uint32_t);\nint\t\t\t aic7770_config(struct ahc_softc *ahc,\n\t\t\t\t\tstruct aic7770_identity *,\n\t\t\t\t\tu_int port);\n\n \nint\t\tahc_probe_scbs(struct ahc_softc *);\nvoid\t\tahc_qinfifo_requeue_tail(struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb);\nint\t\tahc_match_scb(struct ahc_softc *ahc, struct scb *scb,\n\t\t\t      int target, char channel, int lun,\n\t\t\t      u_int tag, role_t role);\n\n \nstruct ahc_softc\t*ahc_alloc(void *platform_arg, char *name);\nint\t\t\t ahc_softc_init(struct ahc_softc *);\nvoid\t\t\t ahc_controller_info(struct ahc_softc *ahc, char *buf);\nint\t\t\t ahc_chip_init(struct ahc_softc *ahc);\nint\t\t\t ahc_init(struct ahc_softc *ahc);\nvoid\t\t\t ahc_intr_enable(struct ahc_softc *ahc, int enable);\nvoid\t\t\t ahc_pause_and_flushwork(struct ahc_softc *ahc);\nint __maybe_unused\t ahc_suspend(struct ahc_softc *ahc);\nint __maybe_unused\t ahc_resume(struct ahc_softc *ahc);\nvoid\t\t\t ahc_set_unit(struct ahc_softc *, int);\nvoid\t\t\t ahc_set_name(struct ahc_softc *, char *);\nvoid\t\t\t ahc_free(struct ahc_softc *ahc);\nint\t\t\t ahc_reset(struct ahc_softc *ahc, int reinit);\n\n \ntypedef enum {\n\tSEARCH_COMPLETE,\n\tSEARCH_COUNT,\n\tSEARCH_REMOVE\n} ahc_search_action;\nint\t\t\tahc_search_qinfifo(struct ahc_softc *ahc, int target,\n\t\t\t\t\t   char channel, int lun, u_int tag,\n\t\t\t\t\t   role_t role, uint32_t status,\n\t\t\t\t\t   ahc_search_action action);\nint\t\t\tahc_search_untagged_queues(struct ahc_softc *ahc,\n\t\t\t\t\t\t   ahc_io_ctx_t ctx,\n\t\t\t\t\t\t   int target, char channel,\n\t\t\t\t\t\t   int lun, uint32_t status,\n\t\t\t\t\t\t   ahc_search_action action);\nint\t\t\tahc_search_disc_list(struct ahc_softc *ahc, int target,\n\t\t\t\t\t     char channel, int lun, u_int tag,\n\t\t\t\t\t     int stop_on_first, int remove,\n\t\t\t\t\t     int save_state);\nint\t\t\tahc_reset_channel(struct ahc_softc *ahc, char channel,\n\t\t\t\t\t  int initiate_reset);\n\n \nvoid\t\t\tahc_compile_devinfo(struct ahc_devinfo *devinfo,\n\t\t\t\t\t    u_int our_id, u_int target,\n\t\t\t\t\t    u_int lun, char channel,\n\t\t\t\t\t    role_t role);\n \nconst struct ahc_syncrate*\tahc_find_syncrate(struct ahc_softc *ahc, u_int *period,\n\t\t\t\t\t  u_int *ppr_options, u_int maxsync);\nu_int\t\t\tahc_find_period(struct ahc_softc *ahc,\n\t\t\t\t\tu_int scsirate, u_int maxsync);\n \ntypedef enum {\n\tAHC_NEG_TO_GOAL,\t \n\tAHC_NEG_IF_NON_ASYNC,\t \n\tAHC_NEG_ALWAYS\t\t \n} ahc_neg_type;\nint\t\t\tahc_update_neg_request(struct ahc_softc*,\n\t\t\t\t\t       struct ahc_devinfo*,\n\t\t\t\t\t       struct ahc_tmode_tstate*,\n\t\t\t\t\t       struct ahc_initiator_tinfo*,\n\t\t\t\t\t       ahc_neg_type);\nvoid\t\t\tahc_set_width(struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      u_int width, u_int type, int paused);\nvoid\t\t\tahc_set_syncrate(struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_devinfo *devinfo,\n\t\t\t\t\t const struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int period, u_int offset,\n\t\t\t\t\t u_int ppr_options,\n\t\t\t\t\t u_int type, int paused);\ntypedef enum {\n\tAHC_QUEUE_NONE,\n\tAHC_QUEUE_BASIC,\n\tAHC_QUEUE_TAGGED\n} ahc_queue_alg;\n\n \n#ifdef AHC_TARGET_MODE\nvoid\t\tahc_send_lstate_events(struct ahc_softc *,\n\t\t\t\t       struct ahc_tmode_lstate *);\nvoid\t\tahc_handle_en_lun(struct ahc_softc *ahc,\n\t\t\t\t  struct cam_sim *sim, union ccb *ccb);\ncam_status\tahc_find_tmode_devs(struct ahc_softc *ahc,\n\t\t\t\t    struct cam_sim *sim, union ccb *ccb,\n\t\t\t\t    struct ahc_tmode_tstate **tstate,\n\t\t\t\t    struct ahc_tmode_lstate **lstate,\n\t\t\t\t    int notfound_failure);\n#ifndef AHC_TMODE_ENABLE\n#define AHC_TMODE_ENABLE 0\n#endif\n#endif\n \n#ifdef AHC_DEBUG\nextern uint32_t ahc_debug;\n#define\tAHC_SHOW_MISC\t\t0x0001\n#define\tAHC_SHOW_SENSE\t\t0x0002\n#define AHC_DUMP_SEEPROM\t0x0004\n#define AHC_SHOW_TERMCTL\t0x0008\n#define AHC_SHOW_MEMORY\t\t0x0010\n#define AHC_SHOW_MESSAGES\t0x0020\n#define\tAHC_SHOW_DV\t\t0x0040\n#define AHC_SHOW_SELTO\t\t0x0080\n#define AHC_SHOW_QFULL\t\t0x0200\n#define AHC_SHOW_QUEUE\t\t0x0400\n#define AHC_SHOW_TQIN\t\t0x0800\n#define AHC_SHOW_MASKED_ERRORS\t0x1000\n#define AHC_DEBUG_SEQUENCER\t0x2000\n#endif\nvoid\t\t\tahc_print_devinfo(struct ahc_softc *ahc,\n\t\t\t\t\t  struct ahc_devinfo *dev);\nvoid\t\t\tahc_dump_card_state(struct ahc_softc *ahc);\nint\t\t\tahc_print_register(const ahc_reg_parse_entry_t *table,\n\t\t\t\t\t   u_int num_entries,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   u_int address,\n\t\t\t\t\t   u_int value,\n\t\t\t\t\t   u_int *cur_column,\n\t\t\t\t\t   u_int wrap_point);\n \nint\t\tahc_acquire_seeprom(struct ahc_softc *ahc,\n\t\t\t\t    struct seeprom_descriptor *sd);\nvoid\t\tahc_release_seeprom(struct seeprom_descriptor *sd);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}