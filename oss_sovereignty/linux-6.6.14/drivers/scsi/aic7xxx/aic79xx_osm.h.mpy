{
  "module_name": "aic79xx_osm.h",
  "hash_id": "43eba44bcfd7b779bba061345e0d25f7157cf46d77ca251c29a4a9d29591dbc1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic79xx_osm.h",
  "human_readable_source": " \n#ifndef _AIC79XX_LINUX_H_\n#define _AIC79XX_LINUX_H_\n\n#include <linux/types.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <asm/byteorder.h>\n#include <asm/io.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_spi.h>\n\n \n#define AIC_LIB_PREFIX ahd\n\n#include \"cam.h\"\n#include \"queue.h\"\n#include \"scsi_message.h\"\n#include \"scsi_iu.h\"\n#include \"aiclib.h\"\n\n \n#ifdef CONFIG_AIC79XX_DEBUG_ENABLE\n#ifdef CONFIG_AIC79XX_DEBUG_MASK\n#define AHD_DEBUG 1\n#define AHD_DEBUG_OPTS CONFIG_AIC79XX_DEBUG_MASK\n#else\n \n#define AHD_DEBUG 1\n#define AHD_DEBUG_OPTS 0\n#endif\n \n#endif\n\n \n#define\tpowerof2(x)\t((((x)-1)&(x))==0)\n\n \nstruct ahd_softc;\ntypedef struct pci_dev *ahd_dev_softc_t;\ntypedef struct scsi_cmnd      *ahd_io_ctx_t;\n\n \n#define ahd_htobe16(x)\tcpu_to_be16(x)\n#define ahd_htobe32(x)\tcpu_to_be32(x)\n#define ahd_htobe64(x)\tcpu_to_be64(x)\n#define ahd_htole16(x)\tcpu_to_le16(x)\n#define ahd_htole32(x)\tcpu_to_le32(x)\n#define ahd_htole64(x)\tcpu_to_le64(x)\n\n#define ahd_be16toh(x)\tbe16_to_cpu(x)\n#define ahd_be32toh(x)\tbe32_to_cpu(x)\n#define ahd_be64toh(x)\tbe64_to_cpu(x)\n#define ahd_le16toh(x)\tle16_to_cpu(x)\n#define ahd_le32toh(x)\tle32_to_cpu(x)\n#define ahd_le64toh(x)\tle64_to_cpu(x)\n\n \nextern uint32_t aic79xx_allow_memio;\nextern struct scsi_host_template aic79xx_driver_template;\n\n \n\ntypedef uint32_t bus_size_t;\n\ntypedef enum {\n\tBUS_SPACE_MEMIO,\n\tBUS_SPACE_PIO\n} bus_space_tag_t;\n\ntypedef union {\n\tu_long\t\t  ioport;\n\tvolatile uint8_t __iomem *maddr;\n} bus_space_handle_t;\n\ntypedef struct bus_dma_segment\n{\n\tdma_addr_t\tds_addr;\n\tbus_size_t\tds_len;\n} bus_dma_segment_t;\n\nstruct ahd_linux_dma_tag\n{\n\tbus_size_t\talignment;\n\tbus_size_t\tboundary;\n\tbus_size_t\tmaxsize;\n};\ntypedef struct ahd_linux_dma_tag* bus_dma_tag_t;\n\ntypedef dma_addr_t bus_dmamap_t;\n\ntypedef int bus_dma_filter_t(void*, dma_addr_t);\ntypedef void bus_dmamap_callback_t(void *, bus_dma_segment_t *, int, int);\n\n#define BUS_DMA_WAITOK\t\t0x0\n#define BUS_DMA_NOWAIT\t\t0x1\n#define BUS_DMA_ALLOCNOW\t0x2\n#define BUS_DMA_LOAD_SEGS\t0x4\t \n\n#define BUS_SPACE_MAXADDR\t0xFFFFFFFF\n#define BUS_SPACE_MAXADDR_32BIT\t0xFFFFFFFF\n#define BUS_SPACE_MAXSIZE_32BIT\t0xFFFFFFFF\n\nint\tahd_dma_tag_create(struct ahd_softc *, bus_dma_tag_t  ,\n\t\t\t   bus_size_t  , bus_size_t  ,\n\t\t\t   dma_addr_t  , dma_addr_t  ,\n\t\t\t   bus_dma_filter_t* , void * ,\n\t\t\t   bus_size_t  , int  ,\n\t\t\t   bus_size_t  , int  ,\n\t\t\t   bus_dma_tag_t * );\n\nvoid\tahd_dma_tag_destroy(struct ahd_softc *, bus_dma_tag_t  );\n\nint\tahd_dmamem_alloc(struct ahd_softc *, bus_dma_tag_t  ,\n\t\t\t void**  , int  ,\n\t\t\t bus_dmamap_t*  );\n\nvoid\tahd_dmamem_free(struct ahd_softc *, bus_dma_tag_t  ,\n\t\t\tvoid*  , bus_dmamap_t  );\n\nvoid\tahd_dmamap_destroy(struct ahd_softc *, bus_dma_tag_t  ,\n\t\t\t   bus_dmamap_t  );\n\nint\tahd_dmamap_load(struct ahd_softc *ahd, bus_dma_tag_t  ,\n\t\t\tbus_dmamap_t  , void *  ,\n\t\t\tbus_size_t  , bus_dmamap_callback_t *,\n\t\t\tvoid * , int  );\n\nint\tahd_dmamap_unload(struct ahd_softc *, bus_dma_tag_t, bus_dmamap_t);\n\n \n#define BUS_DMASYNC_PREREAD\t0x01\t \n#define BUS_DMASYNC_POSTREAD\t0x02\t \n#define BUS_DMASYNC_PREWRITE\t0x04\t \n#define BUS_DMASYNC_POSTWRITE\t0x08\t \n\n \n#define ahd_dmamap_sync(ahd, dma_tag, dmamap, offset, len, op)\n\n \n#ifdef CONFIG_AIC79XX_REG_PRETTY_PRINT\n#define AIC_DEBUG_REGISTERS 1\n#else\n#define AIC_DEBUG_REGISTERS 0\n#endif\n#include \"aic79xx.h\"\n\n \n#include <linux/spinlock.h>\n\n#define AIC79XX_DRIVER_VERSION \"3.0\"\n\n \n \n\ntypedef enum {\n\tAHD_DEV_FREEZE_TIL_EMPTY = 0x02,  \n\tAHD_DEV_Q_BASIC\t\t = 0x10,  \n\tAHD_DEV_Q_TAGGED\t = 0x20,  \n\tAHD_DEV_PERIODIC_OTAG\t = 0x40,  \n} ahd_linux_dev_flags;\n\nstruct ahd_linux_device {\n\tTAILQ_ENTRY(ahd_linux_device) links;\n\n\t \n\tint\t\t\tactive;\n\n\t \n\tint\t\t\topenings;\n\n\t \n\tu_int\t\t\tqfrozen;\n\n\t \n\tu_long\t\t\tcommands_issued;\n\n\t \n\tu_int\t\t\ttag_success_count;\n#define AHD_TAG_SUCCESS_INTERVAL 50\n\n\tahd_linux_dev_flags\tflags;\n\n\t \n\tstruct timer_list\ttimer;\n\n\t \n\tu_int\t\t\tmaxtags;\n\n\t \n\tu_int\t\t\ttags_on_last_queuefull;\n\n\t \n\tu_int\t\t\tlast_queuefull_same_count;\n#define AHD_LOCK_TAGS_COUNT 50\n\n\t \n\tu_int\t\t\tcommands_since_idle_or_otag;\n#define AHD_OTAG_THRESH\t500\n};\n\n \n \n#define\tAHD_NSEG 128\n\n \nstruct scb_platform_data {\n\tstruct ahd_linux_device\t*dev;\n\tdma_addr_t\t\t buf_busaddr;\n\tuint32_t\t\t xfer_len;\n\tuint32_t\t\t sense_resid;\t \n};\n\n \nstruct ahd_platform_data {\n\t \n\tstruct scsi_target *starget[AHD_NUM_TARGETS];\n\n\tspinlock_t\t\t spin_lock;\n\tstruct completion\t*eh_done;\n\tstruct Scsi_Host\t*host;\t\t \n#define AHD_LINUX_NOIRQ\t((uint32_t)~0)\n\tuint32_t\t\t irq;\t\t \n\tuint32_t\t\t bios_address;\n\tresource_size_t\t\t mem_busaddr;\t \n};\n\nvoid ahd_delay(long);\n\n \nuint8_t ahd_inb(struct ahd_softc * ahd, long port);\nvoid ahd_outb(struct ahd_softc * ahd, long port, uint8_t val);\nvoid ahd_outw_atomic(struct ahd_softc * ahd,\n\t\t\t\t     long port, uint16_t val);\nvoid ahd_outsb(struct ahd_softc * ahd, long port,\n\t\t\t       uint8_t *, int count);\nvoid ahd_insb(struct ahd_softc * ahd, long port,\n\t\t\t       uint8_t *, int count);\n\n \nint\t\tahd_linux_register_host(struct ahd_softc *,\n\t\t\t\t\tstruct scsi_host_template *);\n\n \nstatic inline void\nahd_lockinit(struct ahd_softc *ahd)\n{\n\tspin_lock_init(&ahd->platform_data->spin_lock);\n}\n\nstatic inline void\nahd_lock(struct ahd_softc *ahd, unsigned long *flags)\n{\n\tspin_lock_irqsave(&ahd->platform_data->spin_lock, *flags);\n}\n\nstatic inline void\nahd_unlock(struct ahd_softc *ahd, unsigned long *flags)\n{\n\tspin_unlock_irqrestore(&ahd->platform_data->spin_lock, *flags);\n}\n\n \n \n#define PCIR_DEVVENDOR\t\t0x00\n#define PCIR_VENDOR\t\t0x00\n#define PCIR_DEVICE\t\t0x02\n#define PCIR_COMMAND\t\t0x04\n#define PCIM_CMD_PORTEN\t\t0x0001\n#define PCIM_CMD_MEMEN\t\t0x0002\n#define PCIM_CMD_BUSMASTEREN\t0x0004\n#define PCIM_CMD_MWRICEN\t0x0010\n#define PCIM_CMD_PERRESPEN\t0x0040\n#define\tPCIM_CMD_SERRESPEN\t0x0100\n#define PCIR_STATUS\t\t0x06\n#define PCIR_REVID\t\t0x08\n#define PCIR_PROGIF\t\t0x09\n#define PCIR_SUBCLASS\t\t0x0a\n#define PCIR_CLASS\t\t0x0b\n#define PCIR_CACHELNSZ\t\t0x0c\n#define PCIR_LATTIMER\t\t0x0d\n#define PCIR_HEADERTYPE\t\t0x0e\n#define PCIM_MFDEV\t\t0x80\n#define PCIR_BIST\t\t0x0f\n#define PCIR_CAP_PTR\t\t0x34\n\n \n#define PCIR_MAPS\t0x10\n\n \n#define PCIXR_COMMAND\t0x96\n#define PCIXR_DEVADDR\t0x98\n#define PCIXM_DEVADDR_FNUM\t0x0003\t \n#define PCIXM_DEVADDR_DNUM\t0x00F8\t \n#define PCIXM_DEVADDR_BNUM\t0xFF00\t \n#define PCIXR_STATUS\t0x9A\n#define PCIXM_STATUS_64BIT\t0x0001\t \n#define PCIXM_STATUS_133CAP\t0x0002\t \n#define PCIXM_STATUS_SCDISC\t0x0004\t \n#define PCIXM_STATUS_UNEXPSC\t0x0008\t \n#define PCIXM_STATUS_CMPLEXDEV\t0x0010\t \n#define PCIXM_STATUS_MAXMRDBC\t0x0060\t \n#define PCIXM_STATUS_MAXSPLITS\t0x0380\t \n#define PCIXM_STATUS_MAXCRDS\t0x1C00\t \n#define PCIXM_STATUS_RCVDSCEM\t0x2000\t \n\ntypedef enum\n{\n\tAHD_POWER_STATE_D0,\n\tAHD_POWER_STATE_D1,\n\tAHD_POWER_STATE_D2,\n\tAHD_POWER_STATE_D3\n} ahd_power_state;\n\nvoid ahd_power_state_change(struct ahd_softc *ahd,\n\t\t\t    ahd_power_state new_state);\n\n \nint\t\t\t ahd_linux_pci_init(void);\nvoid\t\t\t ahd_linux_pci_exit(void);\nint\t\t\t ahd_pci_map_registers(struct ahd_softc *ahd);\nint\t\t\t ahd_pci_map_int(struct ahd_softc *ahd);\n\nuint32_t\t\t ahd_pci_read_config(ahd_dev_softc_t pci,\n\t\t\t\t\t     int reg, int width);\nvoid\t\t\t ahd_pci_write_config(ahd_dev_softc_t pci,\n\t\t\t\t\t  int reg, uint32_t value,\n\t\t\t\t\t  int width);\n\nstatic inline int ahd_get_pci_function(ahd_dev_softc_t);\nstatic inline int\nahd_get_pci_function(ahd_dev_softc_t pci)\n{\n\treturn (PCI_FUNC(pci->devfn));\n}\n\nstatic inline int ahd_get_pci_slot(ahd_dev_softc_t);\nstatic inline int\nahd_get_pci_slot(ahd_dev_softc_t pci)\n{\n\treturn (PCI_SLOT(pci->devfn));\n}\n\nstatic inline int ahd_get_pci_bus(ahd_dev_softc_t);\nstatic inline int\nahd_get_pci_bus(ahd_dev_softc_t pci)\n{\n\treturn (pci->bus->number);\n}\n\nstatic inline void ahd_flush_device_writes(struct ahd_softc *);\nstatic inline void\nahd_flush_device_writes(struct ahd_softc *ahd)\n{\n\t \n\tahd_inb(ahd, INTSTAT);\n}\n\n \nint\tahd_proc_write_seeprom(struct Scsi_Host *, char *, int);\nint\tahd_linux_show_info(struct seq_file *,struct Scsi_Host *);\n\n \n\nstatic inline\nvoid ahd_cmd_set_transaction_status(struct scsi_cmnd *cmd, uint32_t status)\n{\n\tcmd->result &= ~(CAM_STATUS_MASK << 16);\n\tcmd->result |= status << 16;\n}\n\nstatic inline\nvoid ahd_set_transaction_status(struct scb *scb, uint32_t status)\n{\n\tahd_cmd_set_transaction_status(scb->io_ctx,status);\n}\n\nstatic inline\nvoid ahd_cmd_set_scsi_status(struct scsi_cmnd *cmd, uint32_t status)\n{\n\tcmd->result &= ~0xFFFF;\n\tcmd->result |= status;\n}\n\nstatic inline\nvoid ahd_set_scsi_status(struct scb *scb, uint32_t status)\n{\n\tahd_cmd_set_scsi_status(scb->io_ctx, status);\n}\n\nstatic inline\nuint32_t ahd_cmd_get_transaction_status(struct scsi_cmnd *cmd)\n{\n\treturn ((cmd->result >> 16) & CAM_STATUS_MASK);\n}\n\nstatic inline\nuint32_t ahd_get_transaction_status(struct scb *scb)\n{\n\treturn (ahd_cmd_get_transaction_status(scb->io_ctx));\n}\n\nstatic inline\nuint32_t ahd_cmd_get_scsi_status(struct scsi_cmnd *cmd)\n{\n\treturn (cmd->result & 0xFFFF);\n}\n\nstatic inline\nuint32_t ahd_get_scsi_status(struct scb *scb)\n{\n\treturn (ahd_cmd_get_scsi_status(scb->io_ctx));\n}\n\nstatic inline\nvoid ahd_set_transaction_tag(struct scb *scb, int enabled, u_int type)\n{\n\t \n}\n\nstatic inline\nu_long ahd_get_transfer_length(struct scb *scb)\n{\n\treturn (scb->platform_data->xfer_len);\n}\n\nstatic inline\nint ahd_get_transfer_dir(struct scb *scb)\n{\n\treturn (scb->io_ctx->sc_data_direction);\n}\n\nstatic inline\nvoid ahd_set_residual(struct scb *scb, u_long resid)\n{\n\tscsi_set_resid(scb->io_ctx, resid);\n}\n\nstatic inline\nvoid ahd_set_sense_residual(struct scb *scb, u_long resid)\n{\n\tscb->platform_data->sense_resid = resid;\n}\n\nstatic inline\nu_long ahd_get_residual(struct scb *scb)\n{\n\treturn scsi_get_resid(scb->io_ctx);\n}\n\nstatic inline\nu_long ahd_get_sense_residual(struct scb *scb)\n{\n\treturn (scb->platform_data->sense_resid);\n}\n\nstatic inline\nint ahd_perform_autosense(struct scb *scb)\n{\n\t \n\treturn (1);\n}\n\nstatic inline uint32_t\nahd_get_sense_bufsize(struct ahd_softc *ahd, struct scb *scb)\n{\n\treturn (sizeof(struct scsi_sense_data));\n}\n\nstatic inline void\nahd_notify_xfer_settings_change(struct ahd_softc *ahd,\n\t\t\t\tstruct ahd_devinfo *devinfo)\n{\n\t \n}\n\nstatic inline void\nahd_platform_scb_free(struct ahd_softc *ahd, struct scb *scb)\n{\n\tahd->flags &= ~AHD_RESOURCE_SHORTAGE;\n}\n\nint\tahd_platform_alloc(struct ahd_softc *ahd, void *platform_arg);\nvoid\tahd_platform_free(struct ahd_softc *ahd);\nvoid\tahd_platform_init(struct ahd_softc *ahd);\nvoid\tahd_platform_freeze_devq(struct ahd_softc *ahd, struct scb *scb);\n\nstatic inline void\nahd_freeze_scb(struct scb *scb)\n{\n\tif ((scb->io_ctx->result & (CAM_DEV_QFRZN << 16)) == 0) {\n\t\tscb->io_ctx->result |= CAM_DEV_QFRZN << 16;\n\t\tscb->platform_data->dev->qfrozen++;\n\t}\n}\n\nvoid\tahd_platform_set_tags(struct ahd_softc *ahd, struct scsi_device *sdev,\n\t\t\t      struct ahd_devinfo *devinfo, ahd_queue_alg);\nint\tahd_platform_abort_scbs(struct ahd_softc *ahd, int target,\n\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\trole_t role, uint32_t status);\nirqreturn_t\n\tahd_linux_isr(int irq, void *dev_id);\nvoid\tahd_done(struct ahd_softc*, struct scb*);\nvoid\tahd_send_async(struct ahd_softc *, char channel,\n\t\t       u_int target, u_int lun, ac_code);\nvoid\tahd_print_path(struct ahd_softc *, struct scb *);\n\n#ifdef CONFIG_PCI\n#define AHD_PCI_CONFIG 1\n#else\n#define AHD_PCI_CONFIG 0\n#endif\n#define bootverbose aic79xx_verbose\nextern uint32_t aic79xx_verbose;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}