{
  "module_name": "aicasm_symbol.h",
  "hash_id": "4859a0877750de1fe5eb0fa44d5b9de2ba2c4ea8e3a58c08f3be627e79e3f00d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h",
  "human_readable_source": " \n\n#include \"../queue.h\"\n\ntypedef enum {\n\tUNINITIALIZED,\n\tREGISTER,\n\tALIAS,\n\tSCBLOC,\n\tSRAMLOC,\n\tENUM_ENTRY,\n\tFIELD,\n\tMASK,\n\tENUM,\n\tCONST,\n\tDOWNLOAD_CONST,\n\tLABEL,\n\tCONDITIONAL,\n\tMACRO\n} symtype;\n\ntypedef enum {\n\tRO = 0x01,\n\tWO = 0x02,\n\tRW = 0x03\n}amode_t;\n\ntypedef SLIST_HEAD(symlist, symbol_node) symlist_t;\n\nstruct reg_info {\n\tu_int\t  address;\n\tint\t  size;\n\tamode_t\t  mode;\n\tsymlist_t fields;\n\tuint8_t\t  valid_bitmask;\n\tuint8_t\t  modes;\n\tint\t  typecheck_masks;\n};\n\nstruct field_info {\n\tsymlist_t symrefs;\n\tuint8_t\t  value;\n\tuint8_t\t  mask;\n};\n\nstruct const_info {\n\tu_int\tvalue;\n\tint\tdefine;\n};\n\nstruct alias_info {\n\tstruct symbol *parent;\n};\n\nstruct label_info {\n\tint\taddress;\n\tint\texported;\n};\n\nstruct cond_info {\n\tint\tfunc_num;\n};\n\nstruct macro_arg {\n\tSTAILQ_ENTRY(macro_arg)\tlinks;\n\tregex_t\targ_regex;\n\tchar   *replacement_text;\n};\nSTAILQ_HEAD(macro_arg_list, macro_arg);\n\nstruct macro_info {\n\tstruct macro_arg_list args;\n\tint   narg;\n\tconst char* body;\n};\n\ntypedef struct expression_info {\n        symlist_t       referenced_syms;\n        int             value;\n} expression_t;\n\ntypedef struct symbol {\n\tchar\t*name;\n\tsymtype\ttype;\n\tint\tcount;\n\tunion\t{\n\t\tstruct reg_info\t  *rinfo;\n\t\tstruct field_info *finfo;\n\t\tstruct const_info *cinfo;\n\t\tstruct alias_info *ainfo;\n\t\tstruct label_info *linfo;\n\t\tstruct cond_info  *condinfo;\n\t\tstruct macro_info *macroinfo;\n\t} info;\n\tint\tdont_generate_debug_code;\n} symbol_t;\n\ntypedef struct symbol_ref {\n\tsymbol_t *symbol;\n\tint\t offset;\n} symbol_ref_t;\n\ntypedef struct symbol_node {\n\tSLIST_ENTRY(symbol_node) links;\n\tsymbol_t *symbol;\n} symbol_node_t;\n\ntypedef struct critical_section {\n\tTAILQ_ENTRY(critical_section) links;\n\tint begin_addr;\n\tint end_addr;\n} critical_section_t;\n\ntypedef enum {\n\tSCOPE_ROOT,\n\tSCOPE_IF,\n\tSCOPE_ELSE_IF,\n\tSCOPE_ELSE\n} scope_type;\n\ntypedef struct patch_info {\n\tint skip_patch;\n\tint skip_instr;\n} patch_info_t;\n\ntypedef struct scope {\n\tSLIST_ENTRY(scope) scope_stack_links;\n\tTAILQ_ENTRY(scope) scope_links;\n\tTAILQ_HEAD(, scope) inner_scope;\n\tscope_type type;\n\tint inner_scope_patches;\n\tint begin_addr;\n        int end_addr;\n\tpatch_info_t patches[2];\n\tint func_num;\n} scope_t;\n\nTAILQ_HEAD(cs_tailq, critical_section);\nSLIST_HEAD(scope_list, scope);\nTAILQ_HEAD(scope_tailq, scope);\n\nvoid\tsymbol_delete(symbol_t *symbol);\n\nvoid\tsymtable_open(void);\n\nvoid\tsymtable_close(void);\n\nsymbol_t *\n\tsymtable_get(char *name);\n\nsymbol_node_t *\n\tsymlist_search(symlist_t *symlist, char *symname);\n\nvoid\n\tsymlist_add(symlist_t *symlist, symbol_t *symbol, int how);\n#define SYMLIST_INSERT_HEAD\t0x00\n#define SYMLIST_SORT\t\t0x01\n\nvoid\tsymlist_free(symlist_t *symlist);\n\nvoid\tsymlist_merge(symlist_t *symlist_dest, symlist_t *symlist_src1,\n\t\t      symlist_t *symlist_src2);\nvoid\tsymtable_dump(FILE *ofile, FILE *dfile);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}