{
  "module_name": "aicasm_symbol.c",
  "hash_id": "06e61fdd8aafcbeb582d72ba637dbd27f6ea94c1bc0c369113834b39f9f4b03d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c",
  "human_readable_source": " \n\n#include <sys/types.h>\n\n#include \"aicdb.h\"\n#include <fcntl.h>\n#include <inttypes.h>\n#include <regex.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sysexits.h>\n#include <ctype.h>\n\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n\nstatic DB *symtable;\n\nsymbol_t *\nsymbol_create(char *name)\n{\n\tsymbol_t *new_symbol;\n\n\tnew_symbol = (symbol_t *)malloc(sizeof(symbol_t));\n\tif (new_symbol == NULL) {\n\t\tperror(\"Unable to create new symbol\");\n\t\texit(EX_SOFTWARE);\n\t}\n\tmemset(new_symbol, 0, sizeof(*new_symbol));\n\tnew_symbol->name = strdup(name);\n\tif (new_symbol->name == NULL)\n\t\t stop(\"Unable to strdup symbol name\", EX_SOFTWARE);\n\tnew_symbol->type = UNINITIALIZED;\n\tnew_symbol->count = 1;\n\treturn (new_symbol);\n}\n\nvoid\nsymbol_delete(symbol_t *symbol)\n{\n\tif (symtable != NULL) {\n\t\tDBT\t key;\n\n\t\tkey.data = symbol->name;\n\t\tkey.size = strlen(symbol->name);\n\t\tsymtable->del(symtable, &key,  0);\n\t}\n\tswitch(symbol->type) {\n\tcase SCBLOC:\n\tcase SRAMLOC:\n\tcase REGISTER:\n\t\tif (symbol->info.rinfo != NULL)\n\t\t\tfree(symbol->info.rinfo);\n\t\tbreak;\n\tcase ALIAS:\n\t\tif (symbol->info.ainfo != NULL)\n\t\t\tfree(symbol->info.ainfo);\n\t\tbreak;\n\tcase MASK:\n\tcase FIELD:\n\tcase ENUM:\n\tcase ENUM_ENTRY:\n\t\tif (symbol->info.finfo != NULL) {\n\t\t\tsymlist_free(&symbol->info.finfo->symrefs);\n\t\t\tfree(symbol->info.finfo);\n\t\t}\n\t\tbreak;\n\tcase DOWNLOAD_CONST:\n\tcase CONST:\n\t\tif (symbol->info.cinfo != NULL)\n\t\t\tfree(symbol->info.cinfo);\n\t\tbreak;\n\tcase LABEL:\n\t\tif (symbol->info.linfo != NULL)\n\t\t\tfree(symbol->info.linfo);\n\t\tbreak;\n\tcase UNINITIALIZED:\n\tdefault:\n\t\tbreak;\n\t}\n\tfree(symbol->name);\n\tfree(symbol);\n}\n\nvoid\nsymtable_open()\n{\n\tsymtable = dbopen( NULL,\n\t\t\t  O_CREAT | O_NONBLOCK | O_RDWR,  0, DB_HASH,\n\t\t\t   NULL);\n\n\tif (symtable == NULL) {\n\t\tperror(\"Symbol table creation failed\");\n\t\texit(EX_SOFTWARE);\n\t\t \n\t}\n}\n\nvoid\nsymtable_close()\n{\n\tif (symtable != NULL) {\n\t\tDBT\t key;\n\t\tDBT\t data;\n\n\t\twhile (symtable->seq(symtable, &key, &data, R_FIRST) == 0) {\n\t\t\tsymbol_t *stored_ptr;\n\n\t\t\tmemcpy(&stored_ptr, data.data, sizeof(stored_ptr));\n\t\t\tsymbol_delete(stored_ptr);\n\t\t}\n\t\tsymtable->close(symtable);\n\t}\n}\n\n \nsymbol_t *\nsymtable_get(char *name)\n{\n\tsymbol_t *stored_ptr;\n\tDBT\t  key;\n\tDBT\t  data;\n\tint\t  retval;\n\n\tkey.data = (void *)name;\n\tkey.size = strlen(name);\n\n\tif ((retval = symtable->get(symtable, &key, &data,  0)) != 0) {\n\t\tif (retval == -1) {\n\t\t\tperror(\"Symbol table get operation failed\");\n\t\t\texit(EX_SOFTWARE);\n\t\t\t \n\t\t} else if (retval == 1) {\n\t\t\t \n\t\t\tsymbol_t *new_symbol;\n\n\t\t\tnew_symbol = symbol_create(name);\n\t\t\tdata.data = &new_symbol;\n\t\t\tdata.size = sizeof(new_symbol);\n\t\t\tif (symtable->put(symtable, &key, &data,\n\t\t\t\t\t   0) !=0) {\n\t\t\t\tperror(\"Symtable put failed\");\n\t\t\t\texit(EX_SOFTWARE);\n\t\t\t}\n\t\t\treturn (new_symbol);\n\t\t} else {\n\t\t\tperror(\"Unexpected return value from db get routine\");\n\t\t\texit(EX_SOFTWARE);\n\t\t\t \n\t\t}\n\t}\n\tmemcpy(&stored_ptr, data.data, sizeof(stored_ptr));\n\tstored_ptr->count++;\n\tdata.data = &stored_ptr;\n\tif (symtable->put(symtable, &key, &data,  0) !=0) {\n\t\tperror(\"Symtable put failed\");\n\t\texit(EX_SOFTWARE);\n\t}\n\treturn (stored_ptr);\n}\n\nsymbol_node_t *\nsymlist_search(symlist_t *symlist, char *symname)\n{\n\tsymbol_node_t *curnode;\n\n\tcurnode = SLIST_FIRST(symlist);\n\twhile(curnode != NULL) {\n\t\tif (strcmp(symname, curnode->symbol->name) == 0)\n\t\t\tbreak;\n\t\tcurnode = SLIST_NEXT(curnode, links);\n\t}\n\treturn (curnode);\n}\n\nvoid\nsymlist_add(symlist_t *symlist, symbol_t *symbol, int how)\n{\n\tsymbol_node_t *newnode;\n\n\tnewnode = (symbol_node_t *)malloc(sizeof(symbol_node_t));\n\tif (newnode == NULL) {\n\t\tstop(\"symlist_add: Unable to malloc symbol_node\", EX_SOFTWARE);\n\t\t \n\t}\n\tnewnode->symbol = symbol;\n\tif (how == SYMLIST_SORT) {\n\t\tsymbol_node_t *curnode;\n\t\tint field;\n\n\t\tfield = FALSE;\n\t\tswitch(symbol->type) {\n\t\tcase REGISTER:\n\t\tcase SCBLOC:\n\t\tcase SRAMLOC:\n\t\t\tbreak;\n\t\tcase FIELD:\n\t\tcase MASK:\n\t\tcase ENUM:\n\t\tcase ENUM_ENTRY:\n\t\t\tfield = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstop(\"symlist_add: Invalid symbol type for sorting\",\n\t\t\t     EX_SOFTWARE);\n\t\t\t \n\t\t}\n\n\t\tcurnode = SLIST_FIRST(symlist);\n\t\tif (curnode == NULL\n\t\t || (field\n\t\t  && (curnode->symbol->type > newnode->symbol->type\n\t\t   || (curnode->symbol->type == newnode->symbol->type\n\t\t    && (curnode->symbol->info.finfo->value >\n\t\t\tnewnode->symbol->info.finfo->value))))\n\t\t || (!field && (curnode->symbol->info.rinfo->address >\n\t\t\t\tnewnode->symbol->info.rinfo->address))) {\n\t\t\tSLIST_INSERT_HEAD(symlist, newnode, links);\n\t\t\treturn;\n\t\t}\n\n\t\twhile (1) {\n\t\t\tif (SLIST_NEXT(curnode, links) == NULL) {\n\t\t\t\tSLIST_INSERT_AFTER(curnode, newnode,\n\t\t\t\t\t\t   links);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tsymbol_t *cursymbol;\n\n\t\t\t\tcursymbol = SLIST_NEXT(curnode, links)->symbol;\n\t\t\t\tif ((field\n\t\t\t\t  && (cursymbol->type > symbol->type\n\t\t\t\t   || (cursymbol->type == symbol->type\n\t\t\t\t    && (cursymbol->info.finfo->value >\n\t\t\t\t\tsymbol->info.finfo->value))))\n\t\t\t\t || (!field\n\t\t\t\t   && (cursymbol->info.rinfo->address >\n\t\t\t\t       symbol->info.rinfo->address))) {\n\t\t\t\t\tSLIST_INSERT_AFTER(curnode, newnode,\n\t\t\t\t\t\t\t   links);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurnode = SLIST_NEXT(curnode, links);\n\t\t}\n\t} else {\n\t\tSLIST_INSERT_HEAD(symlist, newnode, links);\n\t}\n}\n\nvoid\nsymlist_free(symlist_t *symlist)\n{\n\tsymbol_node_t *node1, *node2;\n\n\tnode1 = SLIST_FIRST(symlist);\n\twhile (node1 != NULL) {\n\t\tnode2 = SLIST_NEXT(node1, links);\n\t\tfree(node1);\n\t\tnode1 = node2;\n\t}\n\tSLIST_INIT(symlist);\n}\n\nvoid\nsymlist_merge(symlist_t *symlist_dest, symlist_t *symlist_src1,\n\t      symlist_t *symlist_src2)\n{\n\tsymbol_node_t *node;\n\n\t*symlist_dest = *symlist_src1;\n\twhile((node = SLIST_FIRST(symlist_src2)) != NULL) {\n\t\tSLIST_REMOVE_HEAD(symlist_src2, links);\n\t\tSLIST_INSERT_HEAD(symlist_dest, node, links);\n\t}\n\n\t \n\tSLIST_INIT(symlist_src1);\n\tSLIST_INIT(symlist_src2);\n}\n\nvoid\naic_print_file_prologue(FILE *ofile)\n{\n\n\tif (ofile == NULL)\n\t\treturn;\n\n\tfprintf(ofile,\n\"/*\\n\"\n\" * DO NOT EDIT - This file is automatically generated\\n\"\n\" *\t\t from the following source files:\\n\"\n\" *\\n\"\n\"%s */\\n\",\n\t\tversions);\n}\n\nvoid\naic_print_include(FILE *dfile, char *include_file)\n{\n\n\tif (dfile == NULL)\n\t\treturn;\n\tfprintf(dfile, \"\\n#include \\\"%s\\\"\\n\\n\", include_file);\n}\n\nvoid\naic_print_reg_dump_types(FILE *ofile)\n{\n\tif (ofile == NULL)\n\t\treturn;\n\n\tfprintf(ofile,\n\"typedef int (%sreg_print_t)(u_int, u_int *, u_int);\\n\"\n\"typedef struct %sreg_parse_entry {\\n\"\n\"\tchar\t*name;\\n\"\n\"\tuint8_t\t value;\\n\"\n\"\tuint8_t\t mask;\\n\"\n\"} %sreg_parse_entry_t;\\n\"\n\"\\n\",\n\t\tprefix, prefix, prefix);\n}\n\nstatic void\naic_print_reg_dump_start(FILE *dfile, symbol_node_t *regnode)\n{\n\tif (dfile == NULL)\n\t\treturn;\n\n\tfprintf(dfile,\n\"static const %sreg_parse_entry_t %s_parse_table[] = {\\n\",\n\t\tprefix,\n\t\tregnode->symbol->name);\n}\n\nstatic void\naic_print_reg_dump_end(FILE *ofile, FILE *dfile,\n\t\t       symbol_node_t *regnode, u_int num_entries)\n{\n\tchar *lower_name;\n\tchar *letter;\n\n\tlower_name = strdup(regnode->symbol->name);\n\tif (lower_name == NULL)\n\t\t stop(\"Unable to strdup symbol name\", EX_SOFTWARE);\n\n\tfor (letter = lower_name; *letter != '\\0'; letter++)\n\t\t*letter = tolower(*letter);\n\n\tif (dfile != NULL) {\n\t\tif (num_entries != 0)\n\t\t\tfprintf(dfile,\n\"\\n\"\n\"};\\n\"\n\"\\n\");\n\n\t\tfprintf(dfile,\n\"int\\n\"\n\"%s%s_print(u_int regvalue, u_int *cur_col, u_int wrap)\\n\"\n\"{\\n\"\n\"\treturn (%sprint_register(%s%s, %d, \\\"%s\\\",\\n\"\n\"\t    0x%02x, regvalue, cur_col, wrap));\\n\"\n\"}\\n\"\n\"\\n\",\n\t\t\tprefix,\n\t\t\tlower_name,\n\t\t\tprefix,\n\t\t\tnum_entries != 0 ? regnode->symbol->name : \"NULL\",\n\t\t\tnum_entries != 0 ? \"_parse_table\" : \"\",\n\t\t\tnum_entries,\n\t\t\tregnode->symbol->name,\n\t\t\tregnode->symbol->info.rinfo->address);\n\t}\n\n\tfprintf(ofile,\n\"#if AIC_DEBUG_REGISTERS\\n\"\n\"%sreg_print_t %s%s_print;\\n\"\n\"#else\\n\"\n\"#define %s%s_print(regvalue, cur_col, wrap) \\\\\\n\"\n\"    %sprint_register(NULL, 0, \\\"%s\\\", 0x%02x, regvalue, cur_col, wrap)\\n\"\n\"#endif\\n\"\n\"\\n\",\n\t\tprefix,\n\t\tprefix,\n\t\tlower_name,\n\t\tprefix,\n\t\tlower_name,\n\t\tprefix,\n\t\tregnode->symbol->name,\n\t\tregnode->symbol->info.rinfo->address);\n}\n\nstatic void\naic_print_reg_dump_entry(FILE *dfile, symbol_node_t *curnode)\n{\n\tint num_tabs;\n\n\tif (dfile == NULL)\n\t\treturn;\n\n\tfprintf(dfile,\n\"\t{ \\\"%s\\\",\",\n\t\tcurnode->symbol->name);\n\n\tnum_tabs = 3 - (strlen(curnode->symbol->name) + 5) / 8;\n\n\twhile (num_tabs-- > 0)\n\t\tfputc('\\t', dfile);\n\tfprintf(dfile, \"0x%02x, 0x%02x }\",\n\t\tcurnode->symbol->info.finfo->value,\n\t\tcurnode->symbol->info.finfo->mask);\n}\n\nvoid\nsymtable_dump(FILE *ofile, FILE *dfile)\n{\n\t \n\tsymlist_t\t registers;\n\tsymlist_t\t masks;\n\tsymlist_t\t constants;\n\tsymlist_t\t download_constants;\n\tsymlist_t\t aliases;\n\tsymlist_t\t exported_labels;\n\tsymbol_node_t\t*curnode;\n\tsymbol_node_t\t*regnode;\n\tDBT\t\t key;\n\tDBT\t\t data;\n\tint\t\t flag;\n\tint\t\t reg_count = 0, reg_used = 0;\n\tu_int\t\t i;\n\n\tif (symtable == NULL)\n\t\treturn;\n\n\tSLIST_INIT(&registers);\n\tSLIST_INIT(&masks);\n\tSLIST_INIT(&constants);\n\tSLIST_INIT(&download_constants);\n\tSLIST_INIT(&aliases);\n\tSLIST_INIT(&exported_labels);\n\tflag = R_FIRST;\n\twhile (symtable->seq(symtable, &key, &data, flag) == 0) {\n\t\tsymbol_t *cursym;\n\n\t\tmemcpy(&cursym, data.data, sizeof(cursym));\n\t\tswitch(cursym->type) {\n\t\tcase REGISTER:\n\t\tcase SCBLOC:\n\t\tcase SRAMLOC:\n\t\t\tsymlist_add(&registers, cursym, SYMLIST_SORT);\n\t\t\tbreak;\n\t\tcase MASK:\n\t\tcase FIELD:\n\t\tcase ENUM:\n\t\tcase ENUM_ENTRY:\n\t\t\tsymlist_add(&masks, cursym, SYMLIST_SORT);\n\t\t\tbreak;\n\t\tcase CONST:\n\t\t\tsymlist_add(&constants, cursym,\n\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\tbreak;\n\t\tcase DOWNLOAD_CONST:\n\t\t\tsymlist_add(&download_constants, cursym,\n\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\tbreak;\n\t\tcase ALIAS:\n\t\t\tsymlist_add(&aliases, cursym,\n\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\tbreak;\n\t\tcase LABEL:\n\t\t\tif (cursym->info.linfo->exported == 0)\n\t\t\t\tbreak;\n\t\t\tsymlist_add(&exported_labels, cursym,\n\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tflag = R_NEXT;\n\t}\n\n\t \n\taic_print_file_prologue(ofile);\n\taic_print_reg_dump_types(ofile);\n\taic_print_file_prologue(dfile);\n\taic_print_include(dfile, stock_include_file);\n\tSLIST_FOREACH(curnode, &registers, links) {\n\n\t\tif (curnode->symbol->dont_generate_debug_code)\n\t\t\tcontinue;\n\n\t\tswitch(curnode->symbol->type) {\n\t\tcase REGISTER:\n\t\tcase SCBLOC:\n\t\tcase SRAMLOC:\n\t\t{\n\t\t\tsymlist_t\t*fields;\n\t\t\tsymbol_node_t\t*fieldnode;\n\t\t\tint\t\t num_entries;\n\n\t\t\tnum_entries = 0;\n\t\t\treg_count++;\n\t\t\tif (curnode->symbol->count == 1)\n\t\t\t\tbreak;\n\t\t\tfields = &curnode->symbol->info.rinfo->fields;\n\t\t\tSLIST_FOREACH(fieldnode, fields, links) {\n\t\t\t\tif (num_entries == 0)\n\t\t\t\t\taic_print_reg_dump_start(dfile,\n\t\t\t\t\t\t\t\t curnode);\n\t\t\t\telse if (dfile != NULL)\n\t\t\t\t\tfputs(\",\\n\", dfile);\n\t\t\t\tnum_entries++;\n\t\t\t\taic_print_reg_dump_entry(dfile, fieldnode);\n\t\t\t}\n\t\t\taic_print_reg_dump_end(ofile, dfile,\n\t\t\t\t\t       curnode, num_entries);\n\t\t\treg_used++;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tfprintf(stderr, \"%s: %d of %d register definitions used\\n\", appname,\n\t\treg_used, reg_count);\n\n\t \n\twhile (SLIST_FIRST(&masks) != NULL) {\n\t\tchar *regname;\n\n\t\tcurnode = SLIST_FIRST(&masks);\n\t\tSLIST_REMOVE_HEAD(&masks, links);\n\n\t\tregnode = SLIST_FIRST(&curnode->symbol->info.finfo->symrefs);\n\t\tregname = regnode->symbol->name;\n\t\tregnode = symlist_search(&registers, regname);\n\t\tSLIST_INSERT_AFTER(regnode, curnode, links);\n\t}\n\n\t \n\twhile (SLIST_FIRST(&aliases) != NULL) {\n\t\tchar *regname;\n\n\t\tcurnode = SLIST_FIRST(&aliases);\n\t\tSLIST_REMOVE_HEAD(&aliases, links);\n\n\t\tregname = curnode->symbol->info.ainfo->parent->name;\n\t\tregnode = symlist_search(&registers, regname);\n\t\tSLIST_INSERT_AFTER(regnode, curnode, links);\n\t}\n\n\t \n\twhile (SLIST_FIRST(&registers) != NULL) {\n\t\tsymbol_node_t *curnode;\n\t\tu_int value;\n\t\tchar *tab_str;\n\t\tchar *tab_str2;\n\n\t\tcurnode = SLIST_FIRST(&registers);\n\t\tSLIST_REMOVE_HEAD(&registers, links);\n\t\tswitch(curnode->symbol->type) {\n\t\tcase REGISTER:\n\t\tcase SCBLOC:\n\t\tcase SRAMLOC:\n\t\t\tfprintf(ofile, \"\\n\");\n\t\t\tvalue = curnode->symbol->info.rinfo->address;\n\t\t\ttab_str = \"\\t\";\n\t\t\ttab_str2 = \"\\t\\t\";\n\t\t\tbreak;\n\t\tcase ALIAS:\n\t\t{\n\t\t\tsymbol_t *parent;\n\n\t\t\tparent = curnode->symbol->info.ainfo->parent;\n\t\t\tvalue = parent->info.rinfo->address;\n\t\t\ttab_str = \"\\t\";\n\t\t\ttab_str2 = \"\\t\\t\";\n\t\t\tbreak;\n\t\t}\n\t\tcase MASK:\n\t\tcase FIELD:\n\t\tcase ENUM:\n\t\tcase ENUM_ENTRY:\n\t\t\tvalue = curnode->symbol->info.finfo->value;\n\t\t\ttab_str = \"\\t\\t\";\n\t\t\ttab_str2 = \"\\t\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvalue = 0;  \n\t\t\ttab_str = NULL;\n\t\t\ttab_str2 = NULL;\n\t\t\tstop(\"symtable_dump: Invalid symbol type \"\n\t\t\t     \"encountered\", EX_SOFTWARE);\n\t\t\tbreak;\n\t\t}\n\t\tfprintf(ofile, \"#define%s%-16s%s0x%02x\\n\",\n\t\t\ttab_str, curnode->symbol->name, tab_str2,\n\t\t\tvalue);\n\t\tfree(curnode);\n\t}\n\tfprintf(ofile, \"\\n\\n\");\n\n\twhile (SLIST_FIRST(&constants) != NULL) {\n\t\tsymbol_node_t *curnode;\n\n\t\tcurnode = SLIST_FIRST(&constants);\n\t\tSLIST_REMOVE_HEAD(&constants, links);\n\t\tfprintf(ofile, \"#define\\t%-8s\\t0x%02x\\n\",\n\t\t\tcurnode->symbol->name,\n\t\t\tcurnode->symbol->info.cinfo->value);\n\t\tfree(curnode);\n\t}\n\n\tfprintf(ofile, \"\\n\\n/* Downloaded Constant Definitions */\\n\");\n\n\tfor (i = 0; SLIST_FIRST(&download_constants) != NULL; i++) {\n\t\tsymbol_node_t *curnode;\n\n\t\tcurnode = SLIST_FIRST(&download_constants);\n\t\tSLIST_REMOVE_HEAD(&download_constants, links);\n\t\tfprintf(ofile, \"#define\\t%-8s\\t0x%02x\\n\",\n\t\t\tcurnode->symbol->name,\n\t\t\tcurnode->symbol->info.cinfo->value);\n\t\tfree(curnode);\n\t}\n\tfprintf(ofile, \"#define\\tDOWNLOAD_CONST_COUNT\\t0x%02x\\n\", i);\n\n\tfprintf(ofile, \"\\n\\n/* Exported Labels */\\n\");\n\n\twhile (SLIST_FIRST(&exported_labels) != NULL) {\n\t\tsymbol_node_t *curnode;\n\n\t\tcurnode = SLIST_FIRST(&exported_labels);\n\t\tSLIST_REMOVE_HEAD(&exported_labels, links);\n\t\tfprintf(ofile, \"#define\\tLABEL_%-8s\\t0x%02x\\n\",\n\t\t\tcurnode->symbol->name,\n\t\t\tcurnode->symbol->info.linfo->address);\n\t\tfree(curnode);\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}