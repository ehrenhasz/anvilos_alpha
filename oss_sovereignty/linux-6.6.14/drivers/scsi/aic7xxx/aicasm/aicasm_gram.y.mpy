{
  "module_name": "aicasm_gram.y",
  "hash_id": "0b40a9d77974d6b66e2d65eefd43039a8c50449a49a8b612df40a63db0f60a50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y",
  "human_readable_source": "%{\n/*\n * Parser for the Aic7xxx SCSI Host adapter sequencer assembler.\n *\n * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.\n * Copyright (c) 2001, 2002 Adaptec Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions, and the following disclaimer,\n *    without modification.\n * 2. Redistributions in binary form must reproduce at minimum a disclaimer\n *    substantially similar to the \"NO WARRANTY\" disclaimer below\n *    (\"Disclaimer\") and any redistribution must be conditioned upon\n *    including a substantially similar Disclaimer requirement for further\n *    binary redistribution.\n * 3. Neither the names of the above-listed copyright holders nor the names\n *    of any contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * Alternatively, this software may be distributed under the terms of the\n * GNU General Public License (\"GPL\") version 2 as published by the Free\n * Software Foundation.\n *\n * NO WARRANTY\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGES.\n *\n * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#30 $\n *\n * $FreeBSD$\n */\n\n#include <sys/types.h>\n\n#include <inttypes.h>\n#include <regex.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sysexits.h>\n\n#include \"../queue.h\"\n\n#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm_insformat.h\"\n\nchar *yyfilename;\nchar stock_prefix[] = \"aic_\";\nchar *prefix = stock_prefix;\nchar *patch_arg_list;\nchar *versions;\nstatic char errbuf[255];\nstatic char regex_pattern[255];\nstatic symbol_t *cur_symbol;\nstatic symbol_t *field_symbol;\nstatic symbol_t *scb_or_sram_symbol;\nstatic symtype cur_symtype;\nstatic symbol_ref_t accumulator;\nstatic symbol_ref_t mode_ptr;\nstatic symbol_ref_t allones;\nstatic symbol_ref_t allzeros;\nstatic symbol_ref_t none;\nstatic symbol_ref_t sindex;\nstatic int instruction_ptr;\nstatic int num_srams;\nstatic int sram_or_scb_offset;\nstatic int download_constant_count;\nstatic int in_critical_section;\nstatic u_int enum_increment;\nstatic u_int enum_next_value;\n\nstatic void process_field(int field_type, symbol_t *sym, int mask);\nstatic void initialize_symbol(symbol_t *symbol);\nstatic void add_macro_arg(const char *argtext, int position);\nstatic void add_macro_body(const char *bodytext);\nstatic void process_register(symbol_t **p_symbol);\nstatic void format_1_instr(int opcode, symbol_ref_t *dest,\n\t\t\t   expression_t *immed, symbol_ref_t *src, int ret);\nstatic void format_2_instr(int opcode, symbol_ref_t *dest,\n\t\t\t   expression_t *places, symbol_ref_t *src, int ret);\nstatic void format_3_instr(int opcode, symbol_ref_t *src,\n\t\t\t   expression_t *immed, symbol_ref_t *address);\nstatic void test_readable_symbol(symbol_t *symbol);\nstatic void test_writable_symbol(symbol_t *symbol);\nstatic void type_check(symbol_ref_t *sym, expression_t *expression, int and_op);\nstatic void make_expression(expression_t *immed, int value);\nstatic void add_conditional(symbol_t *symbol);\nstatic void add_version(const char *verstring);\nstatic int  is_download_const(expression_t *immed);\nstatic int  is_location_address(symbol_t *symbol);\nvoid yyerror(const char *string);\n\n#define SRAM_SYMNAME \"SRAM_BASE\"\n#define SCB_SYMNAME \"SCB_BASE\"\n%}\n\n%union {\n\tu_int\t\tvalue;\n\tchar\t\t*str;\n\tsymbol_t\t*sym;\n\tsymbol_ref_t\tsym_ref;\n\texpression_t\texpression;\n}\n\n%token T_REGISTER\n\n%token <value> T_CONST\n\n%token T_EXPORT\n\n%token T_DOWNLOAD\n\n%token T_SCB\n\n%token T_SRAM\n\n%token T_ALIAS\n\n%token T_SIZE\n\n%token T_EXPR_LSHIFT\n\n%token T_EXPR_RSHIFT\n\n%token <value> T_ADDRESS\n\n%token T_COUNT\n\n%token T_ACCESS_MODE\n\n%token T_DONT_GENERATE_DEBUG_CODE\n\n%token T_MODES\n\n%token T_DEFINE\n\n%token T_SET_SRC_MODE\n\n%token T_SET_DST_MODE\n\n%token <value> T_MODE\n\n%token T_BEGIN_CS\n\n%token T_END_CS\n\n%token T_PAD_PAGE\n\n%token T_FIELD\n\n%token T_ENUM\n\n%token T_MASK\n\n%token <value> T_NUMBER\n\n%token <str> T_PATH T_STRING T_ARG T_MACROBODY\n\n%token <sym> T_CEXPR\n\n%token T_EOF T_INCLUDE T_VERSION T_PREFIX T_PATCH_ARG_LIST\n\n%token <value> T_SHR T_SHL T_ROR T_ROL\n\n%token <value> T_MVI T_MOV T_CLR T_BMOV\n\n%token <value> T_JMP T_JC T_JNC T_JE T_JNE T_JNZ T_JZ T_CALL\n\n%token <value> T_ADD T_ADC\n\n%token <value> T_INC T_DEC\n\n%token <value> T_STC T_CLC\n\n%token <value> T_CMP T_NOT T_XOR\n\n%token <value> T_TEST T_AND\n\n%token <value> T_OR\n\n/* 16 bit extensions, not implemented\n * %token <value> T_OR16 T_AND16 T_XOR16 T_ADD16\n * %token <value> T_ADC16 T_MVI16 T_TEST16 T_CMP16 T_CMPXCHG\n */\n%token T_RET\n\n%token T_NOP\n\n%token T_ACCUM T_ALLONES T_ALLZEROS T_NONE T_SINDEX T_MODE_PTR\n\n%token T_A\n\n%token <sym> T_SYMBOL\n\n%token T_NL\n\n%token T_IF T_ELSE T_ELSE_IF T_ENDIF\n\n%type <sym_ref> reg_symbol address destination source opt_source\n\n%type <expression> expression immediate immediate_or_a\n\n%type <value> export ret f1_opcode f2_opcode jmp_jc_jnc_call jz_jnz je_jne\n\n%type <value> mode_value mode_list macro_arglist\n\n%left '|'\n%left '&'\n%left T_EXPR_LSHIFT T_EXPR_RSHIFT\n%left '+' '-'\n%left '*' '/'\n%right '~'\n%nonassoc UMINUS\n%%\n\nprogram:\n\tinclude\n|\tprogram include\n|\tprefix\n|\tprogram prefix\n|\tpatch_arg_list\n|\tprogram patch_arg_list\n|\tversion\n|\tprogram version\n|\tregister\n|\tprogram register\n|\tconstant\n|\tprogram constant\n|\tmacrodefn\n|\tprogram macrodefn\n|\tscratch_ram\n|\tprogram scratch_ram\n|\tscb\n|\tprogram scb\n|\tlabel\n|\tprogram label\n|\tset_src_mode\n|\tprogram set_src_mode\n|\tset_dst_mode\n|\tprogram set_dst_mode\n|\tcritical_section_start\n|\tprogram critical_section_start\n|\tcritical_section_end\n|\tprogram critical_section_end\n|\tconditional\n|\tprogram conditional\n|\tcode\n|\tprogram code\n;\n\ninclude:\n\tT_INCLUDE '<' T_PATH '>'\n\t{\n\t\tinclude_file($3, BRACKETED_INCLUDE);\n\t}\n|\tT_INCLUDE '\"' T_PATH '\"'\n\t{\n\t\tinclude_file($3, QUOTED_INCLUDE);\n\t}\n;\n\nprefix:\n\tT_PREFIX '=' T_STRING\n\t{\n\t\tif (prefix != stock_prefix)\n\t\t\tstop(\"Prefix multiply defined\",\n\t\t\t     EX_DATAERR);\n\t\tprefix = strdup($3);\n\t\tif (prefix == NULL)\n\t\t\tstop(\"Unable to record prefix\", EX_SOFTWARE);\n\t}\n;\n\npatch_arg_list:\n\tT_PATCH_ARG_LIST '=' T_STRING\n\t{\n\t\tif (patch_arg_list != NULL)\n\t\t\tstop(\"Patch argument list multiply defined\",\n\t\t\t     EX_DATAERR);\n\t\tpatch_arg_list = strdup($3);\n\t\tif (patch_arg_list == NULL)\n\t\t\tstop(\"Unable to record patch arg list\", EX_SOFTWARE);\n\t}\n;\n\nversion:\n\tT_VERSION '=' T_STRING\n\t{ add_version($3); }\n;\n\nregister:\n\tT_REGISTER { cur_symtype = REGISTER; } reg_definition\n;\n\nreg_definition:\n\tT_SYMBOL '{'\n\t\t{\n\t\t\tif ($1->type != UNINITIALIZED) {\n\t\t\t\tstop(\"Register multiply defined\", EX_DATAERR);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tcur_symbol = $1;\n\t\t\tcur_symbol->type = cur_symtype;\n\t\t\tinitialize_symbol(cur_symbol);\n\t\t}\n\t\treg_attribute_list\n\t'}'\n\t\t{\n\t\t\t/*\n\t\t\t * Default to allowing everything in for registers\n\t\t\t * with no bit or mask definitions.\n\t\t\t */\n\t\t\tif (cur_symbol->info.rinfo->valid_bitmask == 0)\n\t\t\t\tcur_symbol->info.rinfo->valid_bitmask = 0xFF;\n\n\t\t\tif (cur_symbol->info.rinfo->size == 0)\n\t\t\t\tcur_symbol->info.rinfo->size = 1;\n\n\t\t\t/*\n\t\t\t * This might be useful for registers too.\n\t\t\t */\n\t\t\tif (cur_symbol->type != REGISTER) {\n\t\t\t\tif (cur_symbol->info.rinfo->address == 0)\n\t\t\t\t\tcur_symbol->info.rinfo->address =\n\t\t\t\t\t    sram_or_scb_offset;\n\t\t\t\tsram_or_scb_offset +=\n\t\t\t\t    cur_symbol->info.rinfo->size;\n\t\t\t}\n\t\t\tcur_symbol = NULL;\n\t\t}\n;\n\nreg_attribute_list:\n\treg_attribute\n|\treg_attribute_list reg_attribute\n;\n\nreg_attribute:\n\treg_address\n|\tsize\n|\tcount\n|\taccess_mode\n|\tdont_generate_debug_code\n|\tmodes\n|\tfield_defn\n|\tenum_defn\n|\tmask_defn\n|\talias\n|\taccumulator\n|\tmode_pointer\n|\tallones\n|\tallzeros\n|\tnone\n|\tsindex\n;\n\nreg_address:\n\tT_ADDRESS T_NUMBER\n\t{\n\t\tcur_symbol->info.rinfo->address = $2;\n\t}\n;\n\nsize:\n\tT_SIZE T_NUMBER\n\t{\n\t\tcur_symbol->info.rinfo->size = $2;\n\t\tif (scb_or_sram_symbol != NULL) {\n\t\t\tu_int max_addr;\n\t\t\tu_int sym_max_addr;\n\n\t\t\tmax_addr = scb_or_sram_symbol->info.rinfo->address\n\t\t\t\t + scb_or_sram_symbol->info.rinfo->size;\n\t\t\tsym_max_addr = cur_symbol->info.rinfo->address\n\t\t\t\t     + cur_symbol->info.rinfo->size;\n\n\t\t\tif (sym_max_addr > max_addr)\n\t\t\t\tstop(\"SCB or SRAM space exhausted\", EX_DATAERR);\n\t\t}\n\t}\n;\n\ncount:\n\tT_COUNT T_NUMBER\n\t{\n\t\tcur_symbol->count += $2;\n\t}\n;\n\naccess_mode:\n\tT_ACCESS_MODE T_MODE\n\t{\n\t\tcur_symbol->info.rinfo->mode = $2;\n\t}\n;\n\ndont_generate_debug_code:\n\tT_DONT_GENERATE_DEBUG_CODE\n\t{\n\t\tcur_symbol->dont_generate_debug_code = 1;\n\t}\n;\n\nmodes:\n\tT_MODES mode_list\n\t{\n\t\tcur_symbol->info.rinfo->modes = $2;\n\t}\n;\n\nmode_list:\n\tmode_value\n\t{\n\t\t$$ = $1;\n\t}\n|\tmode_list ',' mode_value\n\t{\n\t\t$$ = $1 | $3;\n\t}\n;\n\nmode_value:\n\tT_NUMBER\n\t{\n\t\tif ($1 > 4) {\n\t\t\tstop(\"Valid register modes range between 0 and 4.\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n\t\t$$ = (0x1 << $1);\n\t}\n|\tT_SYMBOL\n\t{\n\t\tsymbol_t *symbol;\n\n\t\tsymbol = $1;\n\t\tif (symbol->type != CONST) {\n\t\t\tstop(\"Only \\\"const\\\" symbols allowed in \"\n\t\t\t     \"mode definitions.\", EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tif (symbol->info.cinfo->value > 4) {\n\t\t\tstop(\"Valid register modes range between 0 and 4.\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\t$$ = (0x1 << symbol->info.cinfo->value);\n\t}\n;\n\nfield_defn:\n\tT_FIELD\n\t\t{\n\t\t\tfield_symbol = NULL;\n\t\t\tenum_next_value = 0;\n\t\t\tenum_increment = 1;\n\t\t}\n\t'{' enum_entry_list '}'\n|\tT_FIELD T_SYMBOL expression\n\t\t{\n\t\t\tprocess_field(FIELD, $2, $3.value);\n\t\t\tfield_symbol = $2;\n\t\t\tenum_next_value = 0;\n\t\t\tenum_increment = 0x01 << (ffs($3.value) - 1);\n\t\t}\n\t'{' enum_entry_list '}'\n|\tT_FIELD T_SYMBOL expression\n\t{\n\t\tprocess_field(FIELD, $2, $3.value);\n\t}\n;\n\nenum_defn:\n\tT_ENUM\n\t\t{\n\t\t\tfield_symbol = NULL;\n\t\t\tenum_next_value = 0;\n\t\t\tenum_increment = 1;\n\t\t}\n\t'{' enum_entry_list '}'\n|\tT_ENUM T_SYMBOL expression\n\t\t{\n\t\t\tprocess_field(ENUM, $2, $3.value);\n\t\t\tfield_symbol = $2;\n\t\t\tenum_next_value = 0;\n\t\t\tenum_increment = 0x01 << (ffs($3.value) - 1);\n\t\t}\n\t'{' enum_entry_list '}'\n;\n\nenum_entry_list:\n\tenum_entry\n|\tenum_entry_list ',' enum_entry\n;\n\nenum_entry:\n\tT_SYMBOL\n\t{\n\t\tprocess_field(ENUM_ENTRY, $1, enum_next_value);\n\t\tenum_next_value += enum_increment;\n\t}\n|\tT_SYMBOL expression\n\t{\n\t\tprocess_field(ENUM_ENTRY, $1, $2.value);\n\t\tenum_next_value = $2.value + enum_increment;\n\t}\n;\n\nmask_defn:\n\tT_MASK T_SYMBOL expression\n\t{\n\t\tprocess_field(MASK, $2, $3.value);\n\t}\n;\n\nalias:\n\tT_ALIAS\tT_SYMBOL\n\t{\n\t\tif ($2->type != UNINITIALIZED) {\n\t\t\tstop(\"Re-definition of register alias\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\t$2->type = ALIAS;\n\t\tinitialize_symbol($2);\n\t\t$2->info.ainfo->parent = cur_symbol;\n\t}\n;\n\naccumulator:\n\tT_ACCUM\n\t{\n\t\tif (accumulator.symbol != NULL) {\n\t\t\tstop(\"Only one accumulator definition allowed\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\taccumulator.symbol = cur_symbol;\n\t}\n;\n\nmode_pointer:\n\tT_MODE_PTR\n\t{\n\t\tif (mode_ptr.symbol != NULL) {\n\t\t\tstop(\"Only one mode pointer definition allowed\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tmode_ptr.symbol = cur_symbol;\n\t}\n;\n\nallones:\n\tT_ALLONES\n\t{\n\t\tif (allones.symbol != NULL) {\n\t\t\tstop(\"Only one definition of allones allowed\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tallones.symbol = cur_symbol;\n\t}\n;\n\nallzeros:\n\tT_ALLZEROS\n\t{\n\t\tif (allzeros.symbol != NULL) {\n\t\t\tstop(\"Only one definition of allzeros allowed\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tallzeros.symbol = cur_symbol;\n\t}\n;\n\nnone:\n\tT_NONE\n\t{\n\t\tif (none.symbol != NULL) {\n\t\t\tstop(\"Only one definition of none allowed\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tnone.symbol = cur_symbol;\n\t}\n;\n\nsindex:\n\tT_SINDEX\n\t{\n\t\tif (sindex.symbol != NULL) {\n\t\t\tstop(\"Only one definition of sindex allowed\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tsindex.symbol = cur_symbol;\n\t}\n;\n\nexpression:\n\texpression '|' expression\n\t{\n\t\t $$.value = $1.value | $3.value;\n\t\t symlist_merge(&$$.referenced_syms,\n\t\t\t       &$1.referenced_syms,\n\t\t\t       &$3.referenced_syms);\n\t}\n|\texpression '&' expression\n\t{\n\t\t$$.value = $1.value & $3.value;\n\t\tsymlist_merge(&$$.referenced_syms,\n\t\t\t       &$1.referenced_syms,\n\t\t\t       &$3.referenced_syms);\n\t}\n|\texpression '+' expression\n\t{\n\t\t$$.value = $1.value + $3.value;\n\t\tsymlist_merge(&$$.referenced_syms,\n\t\t\t       &$1.referenced_syms,\n\t\t\t       &$3.referenced_syms);\n\t}\n|\texpression '-' expression\n\t{\n\t\t$$.value = $1.value - $3.value;\n\t\tsymlist_merge(&($$.referenced_syms),\n\t\t\t       &($1.referenced_syms),\n\t\t\t       &($3.referenced_syms));\n\t}\n|\texpression '*' expression\n\t{\n\t\t$$.value = $1.value * $3.value;\n\t\tsymlist_merge(&($$.referenced_syms),\n\t\t\t       &($1.referenced_syms),\n\t\t\t       &($3.referenced_syms));\n\t}\n|\texpression '/' expression\n\t{\n\t\t$$.value = $1.value / $3.value;\n\t\tsymlist_merge(&($$.referenced_syms),\n\t\t\t       &($1.referenced_syms),\n\t\t\t       &($3.referenced_syms));\n\t}\n|\texpression T_EXPR_LSHIFT expression\n\t{\n\t\t$$.value = $1.value << $3.value;\n\t\tsymlist_merge(&$$.referenced_syms,\n\t\t\t       &$1.referenced_syms,\n\t\t\t       &$3.referenced_syms);\n\t}\n|\texpression T_EXPR_RSHIFT expression\n\t{\n\t\t$$.value = $1.value >> $3.value;\n\t\tsymlist_merge(&$$.referenced_syms,\n\t\t\t       &$1.referenced_syms,\n\t\t\t       &$3.referenced_syms);\n\t}\n|\t'(' expression ')'\n\t{\n\t\t$$ = $2;\n\t}\n|\t'~' expression\n\t{\n\t\t$$ = $2;\n\t\t$$.value = (~$$.value) & 0xFF;\n\t}\n|\t'-' expression %prec UMINUS\n\t{\n\t\t$$ = $2;\n\t\t$$.value = -$$.value;\n\t}\n|\tT_NUMBER\n\t{\n\t\t$$.value = $1;\n\t\tSLIST_INIT(&$$.referenced_syms);\n\t}\n|\tT_SYMBOL\n\t{\n\t\tsymbol_t *symbol;\n\n\t\tsymbol = $1;\n\t\tswitch (symbol->type) {\n\t\tcase ALIAS:\n\t\t\tsymbol = $1->info.ainfo->parent;\n\t\tcase REGISTER:\n\t\tcase SCBLOC:\n\t\tcase SRAMLOC:\n\t\t\t$$.value = symbol->info.rinfo->address;\n\t\t\tbreak;\n\t\tcase MASK:\n\t\tcase FIELD:\n\t\tcase ENUM:\n\t\tcase ENUM_ENTRY:\n\t\t\t$$.value = symbol->info.finfo->value;\n\t\t\tbreak;\n\t\tcase DOWNLOAD_CONST:\n\t\tcase CONST:\n\t\t\t$$.value = symbol->info.cinfo->value;\n\t\t\tbreak;\n\t\tcase UNINITIALIZED:\n\t\tdefault:\n\t\t{\n\t\t\tsnprintf(errbuf, sizeof(errbuf),\n\t\t\t\t \"Undefined symbol %s referenced\",\n\t\t\t\t symbol->name);\n\t\t\tstop(errbuf, EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tSLIST_INIT(&$$.referenced_syms);\n\t\tsymlist_add(&$$.referenced_syms, symbol, SYMLIST_INSERT_HEAD);\n\t}\n;\n\nconstant:\n\tT_CONST T_SYMBOL expression\n\t{\n\t\tif ($2->type != UNINITIALIZED) {\n\t\t\tstop(\"Re-definition of symbol as a constant\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\t$2->type = CONST;\n\t\tinitialize_symbol($2);\n\t\t$2->info.cinfo->value = $3.value;\n\t}\n|\tT_CONST T_SYMBOL T_DOWNLOAD\n\t{\n\t\tif ($1) {\n\t\t\tstop(\"Invalid downloaded constant declaration\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tif ($2->type != UNINITIALIZED) {\n\t\t\tstop(\"Re-definition of symbol as a downloaded constant\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\t$2->type = DOWNLOAD_CONST;\n\t\tinitialize_symbol($2);\n\t\t$2->info.cinfo->value = download_constant_count++;\n\t}\n;\n\nmacrodefn_prologue:\n\tT_DEFINE T_SYMBOL\n\t{\n\t\tif ($2->type != UNINITIALIZED) {\n\t\t\tstop(\"Re-definition of symbol as a macro\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tcur_symbol = $2;\n\t\tcur_symbol->type = MACRO;\n\t\tinitialize_symbol(cur_symbol);\n\t}\n;\n\nmacrodefn:\n\tmacrodefn_prologue T_MACROBODY\n\t{\n\t\tadd_macro_body($2);\n\t}\n|\tmacrodefn_prologue '(' macro_arglist ')' T_MACROBODY\n\t{\n\t\tadd_macro_body($5);\n\t\tcur_symbol->info.macroinfo->narg = $3;\n\t}\n;\n\nmacro_arglist:\n\t{\n\t\t/* Macros can take no arguments */\n\t\t$$ = 0;\n\t}\n|\tT_ARG\n\t{\n\t\t$$ = 1;\n\t\tadd_macro_arg($1, 0);\n\t}\n|\tmacro_arglist ',' T_ARG\n\t{\n\t\tif ($1 == 0) {\n\t\t\tstop(\"Comma without preceding argument in arg list\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\t$$ = $1 + 1;\n\t\tadd_macro_arg($3, $1);\n\t}\n;\n\nscratch_ram:\n\tT_SRAM '{'\n\t\t{\n\t\t\tsnprintf(errbuf, sizeof(errbuf), \"%s%d\", SRAM_SYMNAME,\n\t\t\t\t num_srams);\n\t\t\tcur_symbol = symtable_get(SRAM_SYMNAME);\n\t\t\tcur_symtype = SRAMLOC;\n\t\t\tcur_symbol->type = SRAMLOC;\n\t\t\tinitialize_symbol(cur_symbol);\n\t\t\tcur_symbol->count += 1;\n\t\t}\n\t\treg_address\n\t\t{\n\t\t\tsram_or_scb_offset = cur_symbol->info.rinfo->address;\n\t\t}\n\t\tsize\n\t\t{\n\t\t\tscb_or_sram_symbol = cur_symbol;\n\t\t}\n\t\tscb_or_sram_attributes\n\t'}'\n\t\t{\n\t\t\tcur_symbol = NULL;\n\t\t\tscb_or_sram_symbol = NULL;\n\t\t}\n;\n\nscb:\n\tT_SCB '{'\n\t\t{\n\t\t\tcur_symbol = symtable_get(SCB_SYMNAME);\n\t\t\tcur_symtype = SCBLOC;\n\t\t\tif (cur_symbol->type != UNINITIALIZED) {\n\t\t\t\tstop(\"Only one SRAM definition allowed\",\n\t\t\t\t     EX_SOFTWARE);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tcur_symbol->type = SCBLOC;\n\t\t\tinitialize_symbol(cur_symbol);\n\t\t\t/* 64 bytes of SCB space */\n\t\t\tcur_symbol->info.rinfo->size = 64;\n\t\t\tcur_symbol->count += 1;\n\t\t}\n\t\treg_address\n\t\t{\n\t\t\tsram_or_scb_offset = cur_symbol->info.rinfo->address;\n\t\t}\n\t\tsize\n\t\t{\n\t\t\tscb_or_sram_symbol = cur_symbol;\n\t\t}\n\t\tscb_or_sram_attributes\n\t'}'\n\t\t{\n\t\t\tcur_symbol = NULL;\n\t\t\tscb_or_sram_symbol = NULL;\n\t\t}\n;\n\nscb_or_sram_attributes:\n\t/* NULL definition is okay */\n|\tmodes\n|\tscb_or_sram_reg_list\n|\tmodes scb_or_sram_reg_list\n;\n\nscb_or_sram_reg_list:\n\treg_definition\n|\tscb_or_sram_reg_list reg_definition\n;\n\nreg_symbol:\n\tT_SYMBOL\n\t{\n\t\tprocess_register(&$1);\n\t\t$$.symbol = $1;\n\t\t$$.offset = 0;\n\t}\n|\tT_SYMBOL '[' T_SYMBOL ']'\n\t{\n\t\tprocess_register(&$1);\n\t\tif ($3->type != CONST) {\n\t\t\tstop(\"register offset must be a constant\", EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tif (($3->info.cinfo->value + 1) > $1->info.rinfo->size) {\n\t\t\tstop(\"Accessing offset beyond range of register\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\t$$.symbol = $1;\n\t\t$$.offset = $3->info.cinfo->value;\n\t}\n|\tT_SYMBOL '[' T_NUMBER ']'\n\t{\n\t\tprocess_register(&$1);\n\t\tif (($3 + 1) > $1->info.rinfo->size) {\n\t\t\tstop(\"Accessing offset beyond range of register\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\t$$.symbol = $1;\n\t\t$$.offset = $3;\n\t}\n|\tT_A\n\t{\n\t\tif (accumulator.symbol == NULL) {\n\t\t\tstop(\"No accumulator has been defined\", EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\t$$.symbol = accumulator.symbol;\n\t\t$$.offset = 0;\n\t}\n;\n\ndestination:\n\treg_symbol\n\t{\n\t\ttest_writable_symbol($1.symbol);\n\t\t$$ = $1;\n\t}\n;\n\nimmediate:\n\texpression\n\t{ $$ = $1; }\n;\n\nimmediate_or_a:\n\texpression\n\t{\n\t\tif ($1.value == 0 && is_download_const(&$1) == 0) {\n\t\t\tsnprintf(errbuf, sizeof(errbuf),\n\t\t\t\t \"\\nExpression evaluates to 0 and thus \"\n\t\t\t\t \"references the accumulator.\\n \"\n\t\t\t\t \"If this is the desired effect, use 'A' \"\n\t\t\t\t \"instead.\\n\");\n\t\t\tstop(errbuf, EX_DATAERR);\n\t\t}\n\t\t$$ = $1;\n\t}\n|\tT_A\n\t{\n\t\tSLIST_INIT(&$$.referenced_syms);\n\t\tsymlist_add(&$$.referenced_syms, accumulator.symbol,\n\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t$$.value = 0;\n\t}\n;\n\nsource:\n\treg_symbol\n\t{\n\t\ttest_readable_symbol($1.symbol);\n\t\t$$ = $1;\n\t}\n;\n\nopt_source:\n\t{\n\t\t$$.symbol = NULL;\n\t\t$$.offset = 0;\n\t}\n|\t',' source\n\t{ $$ = $2; }\n;\n\nret:\n\t{ $$ = 0; }\n|\tT_RET\n\t{ $$ = 1; }\n;\n\nset_src_mode:\n\tT_SET_SRC_MODE T_NUMBER ';'\n\t{\n\t\tsrc_mode = $2;\n\t}\n;\n\nset_dst_mode:\n\tT_SET_DST_MODE T_NUMBER ';'\n\t{\n\t\tdst_mode = $2;\n\t}\n;\n\ncritical_section_start:\n\tT_BEGIN_CS ';'\n\t{\n\t\tcritical_section_t *cs;\n\n\t\tif (in_critical_section != FALSE) {\n\t\t\tstop(\"Critical Section within Critical Section\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tcs = cs_alloc();\n\t\tcs->begin_addr = instruction_ptr;\n\t\tin_critical_section = TRUE;\n\t}\n;\n\ncritical_section_end:\n\tT_END_CS ';'\n\t{\n\t\tcritical_section_t *cs;\n\n\t\tif (in_critical_section == FALSE) {\n\t\t\tstop(\"Unballanced 'end_cs'\", EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tcs = TAILQ_LAST(&cs_tailq, cs_tailq);\n\t\tcs->end_addr = instruction_ptr;\n\t\tin_critical_section = FALSE;\n\t}\n;\n\nexport:\n\t{ $$ = 0; }\n|\tT_EXPORT\n\t{ $$ = 1; }\n;\n\nlabel:\n\texport T_SYMBOL ':'\n\t{\n\t\tif ($2->type != UNINITIALIZED) {\n\t\t\tstop(\"Program label multiply defined\", EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\t$2->type = LABEL;\n\t\tinitialize_symbol($2);\n\t\t$2->info.linfo->address = instruction_ptr;\n\t\t$2->info.linfo->exported = $1;\n\t}\n;\n\naddress:\n\tT_SYMBOL\n\t{\n\t\t$$.symbol = $1;\n\t\t$$.offset = 0;\n\t}\n|\tT_SYMBOL '+' T_NUMBER\n\t{\n\t\t$$.symbol = $1;\n\t\t$$.offset = $3;\n\t}\n|\tT_SYMBOL '-' T_NUMBER\n\t{\n\t\t$$.symbol = $1;\n\t\t$$.offset = -$3;\n\t}\n|\t'.'\n\t{\n\t\t$$.symbol = NULL;\n\t\t$$.offset = 0;\n\t}\n|\t'.' '+' T_NUMBER\n\t{\n\t\t$$.symbol = NULL;\n\t\t$$.offset = $3;\n\t}\n|\t'.' '-' T_NUMBER\n\t{\n\t\t$$.symbol = NULL;\n\t\t$$.offset = -$3;\n\t}\n;\n\nconditional:\n\tT_IF T_CEXPR '{'\n\t{\n\t\tscope_t *new_scope;\n\n\t\tadd_conditional($2);\n\t\tnew_scope = scope_alloc();\n\t\tnew_scope->type = SCOPE_IF;\n\t\tnew_scope->begin_addr = instruction_ptr;\n\t\tnew_scope->func_num = $2->info.condinfo->func_num;\n\t}\n|\tT_ELSE T_IF T_CEXPR '{'\n\t{\n\t\tscope_t *new_scope;\n\t\tscope_t *scope_context;\n\t\tscope_t *last_scope;\n\n\t\t/*\n\t\t * Ensure that the previous scope is either an\n\t\t * if or and else if.\n\t\t */\n\t\tscope_context = SLIST_FIRST(&scope_stack);\n\t\tlast_scope = TAILQ_LAST(&scope_context->inner_scope,\n\t\t\t\t\tscope_tailq);\n\t\tif (last_scope == NULL\n\t\t || last_scope->type == T_ELSE) {\n\n\t\t\tstop(\"'else if' without leading 'if'\", EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tadd_conditional($3);\n\t\tnew_scope = scope_alloc();\n\t\tnew_scope->type = SCOPE_ELSE_IF;\n\t\tnew_scope->begin_addr = instruction_ptr;\n\t\tnew_scope->func_num = $3->info.condinfo->func_num;\n\t}\n|\tT_ELSE '{'\n\t{\n\t\tscope_t *new_scope;\n\t\tscope_t *scope_context;\n\t\tscope_t *last_scope;\n\n\t\t/*\n\t\t * Ensure that the previous scope is either an\n\t\t * if or and else if.\n\t\t */\n\t\tscope_context = SLIST_FIRST(&scope_stack);\n\t\tlast_scope = TAILQ_LAST(&scope_context->inner_scope,\n\t\t\t\t\tscope_tailq);\n\t\tif (last_scope == NULL\n\t\t || last_scope->type == SCOPE_ELSE) {\n\n\t\t\tstop(\"'else' without leading 'if'\", EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tnew_scope = scope_alloc();\n\t\tnew_scope->type = SCOPE_ELSE;\n\t\tnew_scope->begin_addr = instruction_ptr;\n\t}\n;\n\nconditional:\n\t'}'\n\t{\n\t\tscope_t *scope_context;\n\n\t\tscope_context = SLIST_FIRST(&scope_stack);\n\t\tif (scope_context->type == SCOPE_ROOT) {\n\t\t\tstop(\"Unexpected '}' encountered\", EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n\t\tscope_context->end_addr = instruction_ptr;\n\n\t\t/* Pop the scope */\n\t\tSLIST_REMOVE_HEAD(&scope_stack, scope_stack_links);\n\n\t\tprocess_scope(scope_context);\n\n\t\tif (SLIST_FIRST(&scope_stack) == NULL) {\n\t\t\tstop(\"Unexpected '}' encountered\", EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n;\n\nf1_opcode:\n\tT_AND { $$ = AIC_OP_AND; }\n|\tT_XOR { $$ = AIC_OP_XOR; }\n|\tT_ADD { $$ = AIC_OP_ADD; }\n|\tT_ADC { $$ = AIC_OP_ADC; }\n;\n\ncode:\n\tf1_opcode destination ',' immediate_or_a opt_source ret ';'\n\t{\n\t\tformat_1_instr($1, &$2, &$4, &$5, $6);\n\t}\n;\n\ncode:\n\tT_OR reg_symbol ',' immediate_or_a opt_source ret ';'\n\t{\n\t\tformat_1_instr(AIC_OP_OR, &$2, &$4, &$5, $6);\n\t}\n;\n\ncode:\n\tT_INC destination opt_source ret ';'\n\t{\n\t\texpression_t immed;\n\n\t\tmake_expression(&immed, 1);\n\t\tformat_1_instr(AIC_OP_ADD, &$2, &immed, &$3, $4);\n\t}\n;\n\ncode:\n\tT_DEC destination opt_source ret ';'\n\t{\n\t\texpression_t immed;\n\n\t\tmake_expression(&immed, -1);\n\t\tformat_1_instr(AIC_OP_ADD, &$2, &immed, &$3, $4);\n\t}\n;\n\ncode:\n\tT_CLC ret ';'\n\t{\n\t\texpression_t immed;\n\n\t\tmake_expression(&immed, -1);\n\t\tformat_1_instr(AIC_OP_ADD, &none, &immed, &allzeros, $2);\n\t}\n|\tT_CLC T_MVI destination ',' immediate_or_a ret ';'\n\t{\n\t\tformat_1_instr(AIC_OP_ADD, &$3, &$5, &allzeros, $6);\n\t}\n;\n\ncode:\n\tT_STC ret ';'\n\t{\n\t\texpression_t immed;\n\n\t\tmake_expression(&immed, 1);\n\t\tformat_1_instr(AIC_OP_ADD, &none, &immed, &allones, $2);\n\t}\n|\tT_STC destination ret ';'\n\t{\n\t\texpression_t immed;\n\n\t\tmake_expression(&immed, 1);\n\t\tformat_1_instr(AIC_OP_ADD, &$2, &immed, &allones, $3);\n\t}\n;\n\ncode:\n\tT_BMOV destination ',' source ',' immediate ret ';'\n\t{\n\t\tformat_1_instr(AIC_OP_BMOV, &$2, &$6, &$4, $7);\n\t}\n;\n\ncode:\n\tT_MOV destination ',' source ret ';'\n\t{\n\t\texpression_t immed;\n\n\t\tmake_expression(&immed, 1);\n\t\tformat_1_instr(AIC_OP_BMOV, &$2, &immed, &$4, $5);\n\t}\n;\n\ncode:\n\tT_MVI destination ',' immediate ret ';'\n\t{\n\t\tif ($4.value == 0\n\t\t && is_download_const(&$4) == 0) {\n\t\t\texpression_t immed;\n\n\t\t\t/*\n\t\t\t * Allow move immediates of 0 so that macros,\n\t\t\t * that can't know the immediate's value and\n\t\t\t * otherwise compensate, still work.\n\t\t\t */\n\t\t\tmake_expression(&immed, 1);\n\t\t\tformat_1_instr(AIC_OP_BMOV, &$2, &immed, &allzeros, $5);\n\t\t} else {\n\t\t\tformat_1_instr(AIC_OP_OR, &$2, &$4, &allzeros, $5);\n\t\t}\n\t}\n;\n\ncode:\n\tT_NOT destination opt_source ret ';'\n\t{\n\t\texpression_t immed;\n\n\t\tmake_expression(&immed, 0xff);\n\t\tformat_1_instr(AIC_OP_XOR, &$2, &immed, &$3, $4);\n\t}\n;\n\ncode:\n\tT_CLR destination ret ';'\n\t{\n\t\texpression_t immed;\n\n\t\tmake_expression(&immed, 0xff);\n\t\tformat_1_instr(AIC_OP_AND, &$2, &immed, &allzeros, $3);\n\t}\n;\n\ncode:\n\tT_NOP ret ';'\n\t{\n\t\texpression_t immed;\n\n\t\tmake_expression(&immed, 0xff);\n\t\tformat_1_instr(AIC_OP_AND, &none, &immed, &allzeros, $2);\n\t}\n;\n\ncode:\n\tT_RET ';'\n\t{\n\t\texpression_t immed;\n\n\t\tmake_expression(&immed, 0xff);\n\t\tformat_1_instr(AIC_OP_AND, &none, &immed, &allzeros, TRUE);\n\t}\n;\n\n\t/*\n\t * This grammar differs from the one in the aic7xxx\n\t * reference manual since the grammar listed there is\n\t * ambiguous and causes a shift/reduce conflict.\n\t * It also seems more logical as the \"immediate\"\n\t * argument is listed as the second arg like the\n\t * other formats.\n\t */\n\nf2_opcode:\n\tT_SHL { $$ = AIC_OP_SHL; }\n|\tT_SHR { $$ = AIC_OP_SHR; }\n|\tT_ROL { $$ = AIC_OP_ROL; }\n|\tT_ROR { $$ = AIC_OP_ROR; }\n;\n\n/*\n * 16bit opcodes, not used\n *\n *f4_opcode:\n *\tT_OR16\t{ $$ = AIC_OP_OR16; }\n *|\tT_AND16 { $$ = AIC_OP_AND16; }\n *|\tT_XOR16 { $$ = AIC_OP_XOR16; }\n *|\tT_ADD16 { $$ = AIC_OP_ADD16; }\n *|\tT_ADC16 { $$ = AIC_OP_ADC16; }\n *|\tT_MVI16 { $$ = AIC_OP_MVI16; }\n *;\n */\n\ncode:\n\tf2_opcode destination ',' expression opt_source ret ';'\n\t{\n\t\tformat_2_instr($1, &$2, &$4, &$5, $6);\n\t}\n;\n\njmp_jc_jnc_call:\n\tT_JMP\t{ $$ = AIC_OP_JMP; }\n|\tT_JC\t{ $$ = AIC_OP_JC; }\n|\tT_JNC\t{ $$ = AIC_OP_JNC; }\n|\tT_CALL\t{ $$ = AIC_OP_CALL; }\n;\n\njz_jnz:\n\tT_JZ\t{ $$ = AIC_OP_JZ; }\n|\tT_JNZ\t{ $$ = AIC_OP_JNZ; }\n;\n\nje_jne:\n\tT_JE\t{ $$ = AIC_OP_JE; }\n|\tT_JNE\t{ $$ = AIC_OP_JNE; }\n;\n\ncode:\n\tjmp_jc_jnc_call address ';'\n\t{\n\t\texpression_t immed;\n\n\t\tmake_expression(&immed, 0);\n\t\tformat_3_instr($1, &sindex, &immed, &$2);\n\t}\n;\n\ncode:\n\tT_OR reg_symbol ',' immediate jmp_jc_jnc_call address ';'\n\t{\n\t\ttype_check(&$2, &$4, AIC_OP_OR);\n\t\tformat_3_instr($5, &$2, &$4, &$6);\n\t}\n;\n\ncode:\n\tT_TEST source ',' immediate_or_a jz_jnz address ';'\n\t{\n\t\tformat_3_instr($5, &$2, &$4, &$6);\n\t}\n;\n\ncode:\n\tT_CMP source ',' immediate_or_a je_jne address ';'\n\t{\n\t\tformat_3_instr($5, &$2, &$4, &$6);\n\t}\n;\n\ncode:\n\tT_MOV source jmp_jc_jnc_call address ';'\n\t{\n\t\texpression_t immed;\n\n\t\tmake_expression(&immed, 0);\n\t\tformat_3_instr($3, &$2, &immed, &$4);\n\t}\n;\n\ncode:\n\tT_MVI immediate jmp_jc_jnc_call address ';'\n\t{\n\t\tformat_3_instr($3, &allzeros, &$2, &$4);\n\t}\n;\n\n%%\n\nstatic void\nprocess_field(int field_type, symbol_t *sym, int value)\n{\n\t/*\n\t * Add the current register to its\n\t * symbol list, if it already exists,\n\t * warn if we are setting it to a\n\t * different value, or in the bit to\n\t * the \"allowed bits\" of this register.\n\t */\n\tif (sym->type == UNINITIALIZED) {\n\t\tsym->type = field_type;\n\t\tinitialize_symbol(sym);\n\t\tsym->info.finfo->value = value;\n\t\tif (field_type != ENUM_ENTRY) {\n\t\t\tif (field_type != MASK && value == 0) {\n\t\t\t\tstop(\"Empty Field, or Enum\", EX_DATAERR);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tsym->info.finfo->value = value;\n\t\t\tsym->info.finfo->mask = value;\n\t\t} else if (field_symbol != NULL) {\n\t\t\tsym->info.finfo->mask = field_symbol->info.finfo->value;\n\t\t} else {\n\t\t\tsym->info.finfo->mask = 0xFF;\n\t\t}\n\t} else if (sym->type != field_type) {\n\t\tstop(\"Field definition mirrors a definition of the same \"\n\t\t     \" name, but a different type\", EX_DATAERR);\n\t\t/* NOTREACHED */\n\t} else if (value != sym->info.finfo->value) {\n\t\tstop(\"Field redefined with a conflicting value\", EX_DATAERR);\n\t\t/* NOTREACHED */\n\t}\n\t/* Fail if this symbol is already listed */\n\tif (symlist_search(&(sym->info.finfo->symrefs),\n\t\t\t   cur_symbol->name) != NULL) {\n\t\tstop(\"Field defined multiple times for register\", EX_DATAERR);\n\t\t/* NOTREACHED */\n\t}\n\tsymlist_add(&(sym->info.finfo->symrefs), cur_symbol,\n\t\t    SYMLIST_INSERT_HEAD);\n\tcur_symbol->info.rinfo->valid_bitmask |= sym->info.finfo->mask;\n\tcur_symbol->info.rinfo->typecheck_masks = TRUE;\n\tsymlist_add(&(cur_symbol->info.rinfo->fields), sym, SYMLIST_SORT);\n}\n\nstatic void\ninitialize_symbol(symbol_t *symbol)\n{\n\tswitch (symbol->type) {\n\tcase UNINITIALIZED:\n\t\tstop(\"Call to initialize_symbol with type field unset\",\n\t\t     EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t\tbreak;\n\tcase REGISTER:\n\tcase SRAMLOC:\n\tcase SCBLOC:\n\t\tsymbol->info.rinfo =\n\t\t    (struct reg_info *)malloc(sizeof(struct reg_info));\n\t\tif (symbol->info.rinfo == NULL) {\n\t\t\tstop(\"Can't create register info\", EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tmemset(symbol->info.rinfo, 0,\n\t\t       sizeof(struct reg_info));\n\t\tSLIST_INIT(&(symbol->info.rinfo->fields));\n\t\t/*\n\t\t * Default to allowing access in all register modes\n\t\t * or to the mode specified by the SCB or SRAM space\n\t\t * we are in.\n\t\t */\n\t\tif (scb_or_sram_symbol != NULL)\n\t\t\tsymbol->info.rinfo->modes =\n\t\t\t    scb_or_sram_symbol->info.rinfo->modes;\n\t\telse\n\t\t\tsymbol->info.rinfo->modes = ~0;\n\t\tbreak;\n\tcase ALIAS:\n\t\tsymbol->info.ainfo =\n\t\t    (struct alias_info *)malloc(sizeof(struct alias_info));\n\t\tif (symbol->info.ainfo == NULL) {\n\t\t\tstop(\"Can't create alias info\", EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tmemset(symbol->info.ainfo, 0,\n\t\t       sizeof(struct alias_info));\n\t\tbreak;\n\tcase MASK:\n\tcase FIELD:\n\tcase ENUM:\n\tcase ENUM_ENTRY:\n\t\tsymbol->info.finfo =\n\t\t    (struct field_info *)malloc(sizeof(struct field_info));\n\t\tif (symbol->info.finfo == NULL) {\n\t\t\tstop(\"Can't create field info\", EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tmemset(symbol->info.finfo, 0, sizeof(struct field_info));\n\t\tSLIST_INIT(&(symbol->info.finfo->symrefs));\n\t\tbreak;\n\tcase CONST:\n\tcase DOWNLOAD_CONST:\n\t\tsymbol->info.cinfo =\n\t\t    (struct const_info *)malloc(sizeof(struct const_info));\n\t\tif (symbol->info.cinfo == NULL) {\n\t\t\tstop(\"Can't create alias info\", EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tmemset(symbol->info.cinfo, 0,\n\t\t       sizeof(struct const_info));\n\t\tbreak;\n\tcase LABEL:\n\t\tsymbol->info.linfo =\n\t\t    (struct label_info *)malloc(sizeof(struct label_info));\n\t\tif (symbol->info.linfo == NULL) {\n\t\t\tstop(\"Can't create label info\", EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tmemset(symbol->info.linfo, 0,\n\t\t       sizeof(struct label_info));\n\t\tbreak;\n\tcase CONDITIONAL:\n\t\tsymbol->info.condinfo =\n\t\t    (struct cond_info *)malloc(sizeof(struct cond_info));\n\t\tif (symbol->info.condinfo == NULL) {\n\t\t\tstop(\"Can't create conditional info\", EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tmemset(symbol->info.condinfo, 0,\n\t\t       sizeof(struct cond_info));\n\t\tbreak;\n\tcase MACRO:\n\t\tsymbol->info.macroinfo =\n\t\t    (struct macro_info *)malloc(sizeof(struct macro_info));\n\t\tif (symbol->info.macroinfo == NULL) {\n\t\t\tstop(\"Can't create macro info\", EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tmemset(symbol->info.macroinfo, 0,\n\t\t       sizeof(struct macro_info));\n\t\tSTAILQ_INIT(&symbol->info.macroinfo->args);\n\t\tbreak;\n\tdefault:\n\t\tstop(\"Call to initialize_symbol with invalid symbol type\",\n\t\t     EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t\tbreak;\n\t}\n}\n\nstatic void\nadd_macro_arg(const char *argtext, int argnum)\n{\n\tstruct macro_arg *marg;\n\tint i;\n\tint retval;\n\n\tif (cur_symbol == NULL || cur_symbol->type != MACRO) {\n\t\tstop(\"Invalid current symbol for adding macro arg\",\n\t\t     EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t}\n\n\tmarg = (struct macro_arg *)malloc(sizeof(*marg));\n\tif (marg == NULL) {\n\t\tstop(\"Can't create macro_arg structure\", EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t}\n\tmarg->replacement_text = NULL;\n\tretval = snprintf(regex_pattern, sizeof(regex_pattern),\n\t\t\t  \"[^-/A-Za-z0-9_](%s)([^-/A-Za-z0-9_]|$)\",\n\t\t\t  argtext);\n\tif (retval >= sizeof(regex_pattern)) {\n\t\tstop(\"Regex text buffer too small for arg\",\n\t\t     EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t}\n\tretval = regcomp(&marg->arg_regex, regex_pattern, REG_EXTENDED);\n\tif (retval != 0) {\n\t\tstop(\"Regex compilation failed\", EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t}\n\tSTAILQ_INSERT_TAIL(&cur_symbol->info.macroinfo->args, marg, links);\n}\n\nstatic void\nadd_macro_body(const char *bodytext)\n{\n\tif (cur_symbol == NULL || cur_symbol->type != MACRO) {\n\t\tstop(\"Invalid current symbol for adding macro arg\",\n\t\t     EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t}\n\tcur_symbol->info.macroinfo->body = strdup(bodytext);\n\tif (cur_symbol->info.macroinfo->body == NULL) {\n\t\tstop(\"Can't duplicate macro body text\", EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t}\n}\n\nstatic void\nprocess_register(symbol_t **p_symbol)\n{\n\tsymbol_t *symbol = *p_symbol;\n\n\tif (symbol->type == UNINITIALIZED) {\n\t\tsnprintf(errbuf, sizeof(errbuf), \"Undefined register %s\",\n\t\t\t symbol->name);\n\t\tstop(errbuf, EX_DATAERR);\n\t\t/* NOTREACHED */\n\t} else if (symbol->type == ALIAS) {\n\t\t*p_symbol = symbol->info.ainfo->parent;\n\t} else if ((symbol->type != REGISTER)\n\t\t&& (symbol->type != SCBLOC)\n\t\t&& (symbol->type != SRAMLOC)) {\n\t\tsnprintf(errbuf, sizeof(errbuf),\n\t\t\t \"Specified symbol %s is not a register\",\n\t\t\t symbol->name);\n\t\tstop(errbuf, EX_DATAERR);\n\t}\n}\n\nstatic void\nformat_1_instr(int opcode, symbol_ref_t *dest, expression_t *immed,\n\t       symbol_ref_t *src, int ret)\n{\n\tstruct instruction *instr;\n\tstruct ins_format1 *f1_instr;\n\n\tif (src->symbol == NULL)\n\t\tsrc = dest;\n\n\t/* Test register permissions */\n\ttest_writable_symbol(dest->symbol);\n\ttest_readable_symbol(src->symbol);\n\n\tif (!is_location_address(dest->symbol)) {\n\t\t/* Ensure that immediate makes sense for this destination */\n\t\ttype_check(dest, immed, opcode);\n\t}\n\n\t/* Allocate sequencer space for the instruction and fill it out */\n\tinstr = seq_alloc();\n\tf1_instr = &instr->format.format1;\n\tf1_instr->ret = ret ? 1 : 0;\n\tf1_instr->opcode = opcode;\n\tf1_instr->destination = dest->symbol->info.rinfo->address\n\t\t\t      + dest->offset;\n\tf1_instr->source = src->symbol->info.rinfo->address\n\t\t\t + src->offset;\n\tf1_instr->immediate = immed->value;\n\n\tif (is_download_const(immed))\n\t\tf1_instr->parity = 1;\n\telse if (dest->symbol == mode_ptr.symbol) {\n\t\tu_int src_value;\n\t\tu_int dst_value;\n\n\t\t/*\n\t\t * Attempt to update mode information if\n\t\t * we are operating on the mode register.\n\t\t */\n\t\tif (src->symbol == allones.symbol)\n\t\t\tsrc_value = 0xFF;\n\t\telse if (src->symbol == allzeros.symbol)\n\t\t\tsrc_value = 0;\n\t\telse if (src->symbol == mode_ptr.symbol)\n\t\t\tsrc_value = (dst_mode << 4) | src_mode;\n\t\telse\n\t\t\tgoto cant_update;\n\n\t\tswitch (opcode) {\n\t\tcase AIC_OP_AND:\n\t\t\tdst_value = src_value & immed->value;\n\t\t\tbreak;\n\t\tcase AIC_OP_XOR:\n\t\t\tdst_value = src_value ^ immed->value;\n\t\t\tbreak;\n\t\tcase AIC_OP_ADD:\n\t\t\tdst_value = (src_value + immed->value) & 0xFF;\n\t\t\tbreak;\n\t\tcase AIC_OP_OR:\n\t\t\tdst_value = src_value | immed->value;\n\t\t\tbreak;\n\t\tcase AIC_OP_BMOV:\n\t\t\tdst_value = src_value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto cant_update;\n\t\t}\n\t\tsrc_mode = dst_value & 0xF;\n\t\tdst_mode = (dst_value >> 4) & 0xF;\n\t}\n\ncant_update:\n\tsymlist_free(&immed->referenced_syms);\n\tinstruction_ptr++;\n}\n\nstatic void\nformat_2_instr(int opcode, symbol_ref_t *dest, expression_t *places,\n\t       symbol_ref_t *src, int ret)\n{\n\tstruct instruction *instr;\n\tstruct ins_format2 *f2_instr;\n\tuint8_t shift_control;\n\n\tif (src->symbol == NULL)\n\t\tsrc = dest;\n\n\t/* Test register permissions */\n\ttest_writable_symbol(dest->symbol);\n\ttest_readable_symbol(src->symbol);\n\n\t/* Allocate sequencer space for the instruction and fill it out */\n\tinstr = seq_alloc();\n\tf2_instr = &instr->format.format2;\n\tf2_instr->ret = ret ? 1 : 0;\n\tf2_instr->opcode = AIC_OP_ROL;\n\tf2_instr->destination = dest->symbol->info.rinfo->address\n\t\t\t      + dest->offset;\n\tf2_instr->source = src->symbol->info.rinfo->address\n\t\t\t + src->offset;\n\tif (places->value > 8 || places->value <= 0) {\n\t\tstop(\"illegal shift value\", EX_DATAERR);\n\t\t/* NOTREACHED */\n\t}\n\tswitch (opcode) {\n\tcase AIC_OP_SHL:\n\t\tif (places->value == 8)\n\t\t\tshift_control = 0xf0;\n\t\telse\n\t\t\tshift_control = (places->value << 4) | places->value;\n\t\tbreak;\n\tcase AIC_OP_SHR:\n\t\tif (places->value == 8) {\n\t\t\tshift_control = 0xf8;\n\t\t} else {\n\t\t\tshift_control = (places->value << 4)\n\t\t\t\t      | (8 - places->value)\n\t\t\t\t      | 0x08;\n\t\t}\n\t\tbreak;\n\tcase AIC_OP_ROL:\n\t\tshift_control = places->value & 0x7;\n\t\tbreak;\n\tcase AIC_OP_ROR:\n\t\tshift_control = (8 - places->value) | 0x08;\n\t\tbreak;\n\tdefault:\n\t\tshift_control = 0; /* Quiet Compiler */\n\t\tstop(\"Invalid shift operation specified\", EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t\tbreak;\n\t};\n\tf2_instr->shift_control = shift_control;\n\tsymlist_free(&places->referenced_syms);\n\tinstruction_ptr++;\n}\n\nstatic void\nformat_3_instr(int opcode, symbol_ref_t *src,\n\t       expression_t *immed, symbol_ref_t *address)\n{\n\tstruct instruction *instr;\n\tstruct ins_format3 *f3_instr;\n\tint addr;\n\n\t/* Test register permissions */\n\ttest_readable_symbol(src->symbol);\n\n\t/* Allocate sequencer space for the instruction and fill it out */\n\tinstr = seq_alloc();\n\tf3_instr = &instr->format.format3;\n\tif (address->symbol == NULL) {\n\t\t/* 'dot' reference.  Use the current instruction pointer */\n\t\taddr = instruction_ptr + address->offset;\n\t} else if (address->symbol->type == UNINITIALIZED) {\n\t\t/* forward reference */\n\t\taddr = address->offset;\n\t\tinstr->patch_label = address->symbol;\n\t} else\n\t\taddr = address->symbol->info.linfo->address + address->offset;\n\tf3_instr->opcode = opcode;\n\tf3_instr->address = addr;\n\tf3_instr->source = src->symbol->info.rinfo->address\n\t\t\t + src->offset;\n\tf3_instr->immediate = immed->value;\n\n\tif (is_download_const(immed))\n\t\tf3_instr->parity = 1;\n\n\tsymlist_free(&immed->referenced_syms);\n\tinstruction_ptr++;\n}\n\nstatic void\ntest_readable_symbol(symbol_t *symbol)\n{\n\tif ((symbol->info.rinfo->modes & (0x1 << src_mode)) == 0) {\n\t\tsnprintf(errbuf, sizeof(errbuf),\n\t\t\t\"Register %s unavailable in source reg mode %d\",\n\t\t\tsymbol->name, src_mode);\n\t\tstop(errbuf, EX_DATAERR);\n\t}\n\n\tif (symbol->info.rinfo->mode == WO) {\n\t\tstop(\"Write Only register specified as source\",\n\t\t     EX_DATAERR);\n\t\t/* NOTREACHED */\n\t}\n}\n\nstatic void\ntest_writable_symbol(symbol_t *symbol)\n{\n\tif ((symbol->info.rinfo->modes & (0x1 << dst_mode)) == 0) {\n\t\tsnprintf(errbuf, sizeof(errbuf),\n\t\t\t\"Register %s unavailable in destination reg mode %d\",\n\t\t\tsymbol->name, dst_mode);\n\t\tstop(errbuf, EX_DATAERR);\n\t}\n\n\tif (symbol->info.rinfo->mode == RO) {\n\t\tstop(\"Read Only register specified as destination\",\n\t\t     EX_DATAERR);\n\t\t/* NOTREACHED */\n\t}\n}\n\nstatic void\ntype_check(symbol_ref_t *sym, expression_t *expression, int opcode)\n{\n\tsymbol_t *symbol = sym->symbol;\n\tsymbol_node_t *node;\n\tint and_op;\n\tint8_t value, mask;\n\n\tand_op = FALSE;\n\t/*\n\t * Make sure that we aren't attempting to write something\n\t * that hasn't been defined.  If this is an and operation,\n\t * this is a mask, so \"undefined\" bits are okay.\n\t */\n\tif (opcode == AIC_OP_AND || opcode == AIC_OP_JNZ ||\n\t    opcode == AIC_OP_JZ  || opcode == AIC_OP_JNE ||\n\t    opcode == AIC_OP_BMOV)\n\t\tand_op = TRUE;\n\n\t/*\n\t * Defaulting to 8 bit logic\n\t */\n\tmask = (int8_t)~symbol->info.rinfo->valid_bitmask;\n\tvalue = (int8_t)expression->value;\n\n\tif (and_op == FALSE && (mask & value) != 0 ) {\n\t\tsnprintf(errbuf, sizeof(errbuf),\n\t\t\t \"Invalid bit(s) 0x%x in immediate written to %s\",\n\t\t\t (mask & value),\n\t\t\t symbol->name);\n\t\tstop(errbuf, EX_DATAERR);\n\t\t/* NOTREACHED */\n\t}\n\n\t/*\n\t * Now make sure that all of the symbols referenced by the\n\t * expression are defined for this register.\n\t */\n\tif (symbol->info.rinfo->typecheck_masks != FALSE) {\n\t\tfor(node = expression->referenced_syms.slh_first;\n\t\t    node != NULL;\n\t\t    node = node->links.sle_next) {\n\t\t\tif ((node->symbol->type == MASK\n\t\t\t  || node->symbol->type == FIELD\n\t\t\t  || node->symbol->type == ENUM\n\t\t\t  || node->symbol->type == ENUM_ENTRY)\n\t\t\t && symlist_search(&node->symbol->info.finfo->symrefs,\n\t\t\t\t\t   symbol->name) == NULL) {\n\t\t\t\tsnprintf(errbuf, sizeof(errbuf),\n\t\t\t\t\t \"Invalid field or mask %s \"\n\t\t\t\t\t \"for register %s\",\n\t\t\t\t\t node->symbol->name, symbol->name);\n\t\t\t\tstop(errbuf, EX_DATAERR);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nmake_expression(expression_t *immed, int value)\n{\n\tSLIST_INIT(&immed->referenced_syms);\n\timmed->value = value & 0xff;\n}\n\nstatic void\nadd_conditional(symbol_t *symbol)\n{\n\tstatic int numfuncs;\n\n\tif (numfuncs == 0) {\n\t\t/* add a special conditional, \"0\" */\n\t\tsymbol_t *false_func;\n\n\t\tfalse_func = symtable_get(\"0\");\n\t\tif (false_func->type != UNINITIALIZED) {\n\t\t\tstop(\"Conditional expression '0' \"\n\t\t\t     \"conflicts with a symbol\", EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tfalse_func->type = CONDITIONAL;\n\t\tinitialize_symbol(false_func);\n\t\tfalse_func->info.condinfo->func_num = numfuncs++;\n\t\tsymlist_add(&patch_functions, false_func, SYMLIST_INSERT_HEAD);\n\t}\n\n\t/* This condition has occurred before */\n\tif (symbol->type == CONDITIONAL)\n\t\treturn;\n\n\tif (symbol->type != UNINITIALIZED) {\n\t\tstop(\"Conditional expression conflicts with a symbol\",\n\t\t     EX_DATAERR);\n\t\t/* NOTREACHED */\n\t}\n\n\tsymbol->type = CONDITIONAL;\n\tinitialize_symbol(symbol);\n\tsymbol->info.condinfo->func_num = numfuncs++;\n\tsymlist_add(&patch_functions, symbol, SYMLIST_INSERT_HEAD);\n}\n\nstatic void\nadd_version(const char *verstring)\n{\n\tconst char prefix[] = \" * \";\n\tint newlen;\n\tint oldlen;\n\n\tnewlen = strlen(verstring) + strlen(prefix);\n\toldlen = 0;\n\tif (versions != NULL)\n\t\toldlen = strlen(versions);\n\tversions = realloc(versions, newlen + oldlen + 2);\n\tif (versions == NULL)\n\t\tstop(\"Can't allocate version string\", EX_SOFTWARE);\n\tstrcpy(&versions[oldlen], prefix);\n\tstrcpy(&versions[oldlen + strlen(prefix)], verstring);\n\tversions[newlen + oldlen] = '\\n';\n\tversions[newlen + oldlen + 1] = '\\0';\n}\n\nvoid\nyyerror(const char *string)\n{\n\tstop(string, EX_DATAERR);\n}\n\nstatic int\nis_download_const(expression_t *immed)\n{\n\tif ((immed->referenced_syms.slh_first != NULL)\n\t && (immed->referenced_syms.slh_first->symbol->type == DOWNLOAD_CONST))\n\t\treturn (TRUE);\n\n\treturn (FALSE);\n}\n\nstatic int\nis_location_address(symbol_t *sym)\n{\n\tif (sym->type == SCBLOC ||\n\t    sym->type == SRAMLOC)\n\t\treturn (TRUE);\n\treturn (FALSE);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}