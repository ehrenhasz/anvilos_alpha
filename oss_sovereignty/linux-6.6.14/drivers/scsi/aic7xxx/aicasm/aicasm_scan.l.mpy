{
  "module_name": "aicasm_scan.l",
  "hash_id": "5edc7b8a0d2d6889f094a165eb214b490c94b208d4b5329a227b7abb93c879a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l",
  "human_readable_source": "%{\n/*\n * Lexical Analyzer for the Aic7xxx SCSI Host adapter sequencer assembler.\n *\n * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.\n * Copyright (c) 2001, 2002 Adaptec Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions, and the following disclaimer,\n *    without modification.\n * 2. Redistributions in binary form must reproduce at minimum a disclaimer\n *    substantially similar to the \"NO WARRANTY\" disclaimer below\n *    (\"Disclaimer\") and any redistribution must be conditioned upon\n *    including a substantially similar Disclaimer requirement for further\n *    binary redistribution.\n * 3. Neither the names of the above-listed copyright holders nor the names\n *    of any contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * Alternatively, this software may be distributed under the terms of the\n * GNU General Public License (\"GPL\") version 2 as published by the Free\n * Software Foundation.\n *\n * NO WARRANTY\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGES.\n *\n * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#20 $\n *\n * $FreeBSD$\n */\n\n#include <sys/types.h>\n\n#include <inttypes.h>\n#include <limits.h>\n#include <regex.h>\n#include <stdio.h>\n#include <string.h>\n#include <sysexits.h>\n#include \"../queue.h\"\n\n#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm_gram.h\"\n\n/* This is used for macro body capture too, so err on the large size. */\n#define MAX_STR_CONST 4096\nstatic char string_buf[MAX_STR_CONST];\nstatic char *string_buf_ptr;\nstatic int  parren_count;\nstatic int  quote_count;\nstatic char buf[255];\n%}\n\nPATH\t\t([/]*[-A-Za-z0-9_.])+\nWORD\t\t[A-Za-z_][-A-Za-z_0-9]*\nSPACE\t\t[ \\t]+\nMCARG\t\t[^(), \\t]+\nMBODY\t\t((\\\\[^\\n])*[^\\n\\\\]*)+\n\n%x COMMENT\n%x CEXPR\n%x INCLUDE\n%x STRING\n%x MACRODEF\n%x MACROARGLIST\n%x MACROCALLARGS\n%x MACROBODY\n\n%%\n\\n\t\t\t{ ++yylineno; }\n\\r\t\t\t;\n\"/*\"\t\t\t{ BEGIN COMMENT;  /* Enter comment eating state */ }\n<COMMENT>\"/*\"\t\t{ fprintf(stderr, \"Warning! Comment within comment.\"); }\n<COMMENT>\\n\t\t{ ++yylineno; }\n<COMMENT>[^*/\\n]*\t;\n<COMMENT>\"*\"+[^*/\\n]*\t;\n<COMMENT>\"/\"+[^*/\\n]*\t;\n<COMMENT>\"*\"+\"/\"\t{ BEGIN INITIAL; }\nif[ \\t]*\\(\t\t{\n\t\t\t\tstring_buf_ptr = string_buf;\n\t\t\t\tparren_count = 1;\n\t\t\t\tBEGIN CEXPR;\n\t\t\t\treturn T_IF;\n\t\t\t}\n<CEXPR>\\(\t\t{\t*string_buf_ptr++ = '('; parren_count++; }\n<CEXPR>\\)\t\t{\n\t\t\t\tparren_count--;\n\t\t\t\tif (parren_count == 0) {\n\t\t\t\t\t/* All done */\n\t\t\t\t\tBEGIN INITIAL;\n\t\t\t\t\t*string_buf_ptr = '\\0';\n\t\t\t\t\tyylval.sym = symtable_get(string_buf);\n\t\t\t\t\treturn T_CEXPR;\n\t\t\t\t} else {\n\t\t\t\t\t*string_buf_ptr++ = ')';\n\t\t\t\t}\n\t\t\t}\n<CEXPR>\\n\t\t{ ++yylineno; }\n<CEXPR>\\r\t\t;\n<CEXPR>[^()\\n]+\t{\n\t\t\t\tchar *yptr;\n\n\t\t\t\typtr = yytext;\n\t\t\t\twhile (*yptr != '\\0') {\n\t\t\t\t\t/* Remove duplicate spaces */\n\t\t\t\t\tif (*yptr == '\\t')\n\t\t\t\t\t\t*yptr = ' ';\n\t\t\t\t\tif (*yptr == ' '\n\t\t\t\t\t && string_buf_ptr != string_buf\n\t\t\t\t\t && string_buf_ptr[-1] == ' ')\n\t\t\t\t\t\typtr++;\n\t\t\t\t\telse \n\t\t\t\t\t\t*string_buf_ptr++ = *yptr++;\n\t\t\t\t}\n\t\t\t}\nelse\t\t\t{ return T_ELSE; }\nVERSION\t\t\t{ return T_VERSION; }\nPREFIX\t\t\t{ return T_PREFIX; }\nPATCH_ARG_LIST\t\t{ return T_PATCH_ARG_LIST; }\n\\\"\t\t\t{\n\t\t\t\tstring_buf_ptr = string_buf;\n\t\t\t\tBEGIN STRING;\n\t\t\t}\n<STRING>[^\"]+\t\t{\n\t\t\t\tchar *yptr;\n\n\t\t\t\typtr = yytext;\n\t\t\t\twhile (*yptr)\n\t\t\t\t\t*string_buf_ptr++ = *yptr++;\n\t\t\t}\n<STRING>\\\"\t\t{\n\t\t\t\t/* All done */\n\t\t\t\tBEGIN INITIAL;\n\t\t\t\t*string_buf_ptr = '\\0';\n\t\t\t\tyylval.str = string_buf;\n\t\t\t\treturn T_STRING;\n\t\t\t}\n{SPACE}\t\t\t ;\n\n\t/* Register/SCB/SRAM definition keywords */\nexport\t\t\t{ return T_EXPORT; }\nregister\t\t{ return T_REGISTER; }\nconst\t\t\t{ yylval.value = FALSE; return T_CONST; }\ndownload\t\t{ return T_DOWNLOAD; }\naddress\t\t\t{ return T_ADDRESS; }\ncount\t\t\t{ return T_COUNT; }\naccess_mode\t\t{ return T_ACCESS_MODE; }\ndont_generate_debug_code { return T_DONT_GENERATE_DEBUG_CODE; }\nmodes\t\t\t{ return T_MODES; }\nRW|RO|WO\t\t{\n\t\t\t\t if (strcmp(yytext, \"RW\") == 0)\n\t\t\t\t\tyylval.value = RW;\n\t\t\t\t else if (strcmp(yytext, \"RO\") == 0)\n\t\t\t\t\tyylval.value = RO;\n\t\t\t\t else\n\t\t\t\t\tyylval.value = WO;\n\t\t\t\t return T_MODE;\n\t\t\t}\nfield\t\t\t{ return T_FIELD; }\nenum\t\t\t{ return T_ENUM; }\nmask\t\t\t{ return T_MASK; }\nalias\t\t\t{ return T_ALIAS; }\nsize\t\t\t{ return T_SIZE; }\nscb\t\t\t{ return T_SCB; }\nscratch_ram\t\t{ return T_SRAM; }\naccumulator\t\t{ return T_ACCUM; }\nmode_pointer\t\t{ return T_MODE_PTR; }\nallones\t\t\t{ return T_ALLONES; }\nallzeros\t\t{ return T_ALLZEROS; }\nnone\t\t\t{ return T_NONE; }\nsindex\t\t\t{ return T_SINDEX; }\nA\t\t\t{ return T_A; }\n\n\t/* Instruction Formatting */\nPAD_PAGE\t\t{ return T_PAD_PAGE; }\nBEGIN_CRITICAL\t\t{ return T_BEGIN_CS; }\nEND_CRITICAL\t\t{ return T_END_CS; }\nSET_SRC_MODE\t\t{ return T_SET_SRC_MODE; }\nSET_DST_MODE\t\t{ return T_SET_DST_MODE; }\n\n\t/* Opcodes */\nshl\t\t\t{ return T_SHL; }\nshr\t\t\t{ return T_SHR; }\nror\t\t\t{ return T_ROR; }\nrol\t\t\t{ return T_ROL; }\nmvi\t\t\t{ return T_MVI; }\nmov\t\t\t{ return T_MOV; }\nclr\t\t\t{ return T_CLR; }\njmp\t\t\t{ return T_JMP; }\njc\t\t\t{ return T_JC;\t}\njnc\t\t\t{ return T_JNC;\t}\nje\t\t\t{ return T_JE;\t}\njne\t\t\t{ return T_JNE;\t}\njz\t\t\t{ return T_JZ;\t}\njnz\t\t\t{ return T_JNZ;\t}\ncall\t\t\t{ return T_CALL; }\nadd\t\t\t{ return T_ADD; }\nadc\t\t\t{ return T_ADC; }\nbmov\t\t\t{ return T_BMOV; }\ninc\t\t\t{ return T_INC; }\ndec\t\t\t{ return T_DEC; }\nstc\t\t\t{ return T_STC;\t}\nclc\t\t\t{ return T_CLC; }\ncmp\t\t\t{ return T_CMP;\t}\nnot\t\t\t{ return T_NOT;\t}\nxor\t\t\t{ return T_XOR;\t}\ntest\t\t\t{ return T_TEST;}\nand\t\t\t{ return T_AND;\t}\nor\t\t\t{ return T_OR;\t}\nret\t\t\t{ return T_RET; }\nnop\t\t\t{ return T_NOP; }\n\n\t/* ARP2 16bit extensions */\n\t/* or16\t\t\t{ return T_OR16; } */\n\t/* and16\t\t\t{ return T_AND16; }*/\n\t/* xor16\t\t\t{ return T_XOR16; }*/\n\t/* add16\t\t\t{ return T_ADD16; }*/\n\t/* adc16\t\t\t{ return T_ADC16; }*/\n\t/* mvi16\t\t\t{ return T_MVI16; }*/\n\t/* test16\t\t\t{ return T_TEST16; }*/\n\t/* cmp16\t\t\t{ return T_CMP16; }*/\n\t/* cmpxchg\t\t\t{ return T_CMPXCHG; }*/\n\n\t/* Allowed Symbols */\n\\<\\<\t\t\t{ return T_EXPR_LSHIFT; }\n\\>\\>\t\t\t{ return T_EXPR_RSHIFT; }\n[-+,:()~|&.\"{};<>[\\]/*!=] { return yytext[0]; }\n\n\t/* Number processing */\n0[0-7]*\t\t\t{\n\t\t\t\tyylval.value = strtol(yytext, NULL, 8);\n\t\t\t\treturn T_NUMBER;\n\t\t\t}\n\n0[xX][0-9a-fA-F]+\t{\n\t\t\t\tyylval.value = strtoul(yytext + 2, NULL, 16);\n\t\t\t\treturn T_NUMBER;\n\t\t\t}\n\n[1-9][0-9]*\t\t{\n\t\t\t\tyylval.value = strtol(yytext, NULL, 10);\n\t\t\t\treturn T_NUMBER;\n\t\t\t}\n\t/* Include Files */\n#include{SPACE}\t\t{\n\t\t\t\tBEGIN INCLUDE;\n\t\t\t\tquote_count = 0;\n\t\t\t\treturn T_INCLUDE;\n\t\t\t}\n<INCLUDE>[<]\t\t{ return yytext[0]; }\n<INCLUDE>[>]\t\t{ BEGIN INITIAL; return yytext[0]; }\n<INCLUDE>[\\\"]\t\t{\n\t\t\t\tif (quote_count != 0)\n\t\t\t\t\tBEGIN INITIAL;\n\t\t\t\tquote_count++;\n\t\t\t\treturn yytext[0];\n\t\t\t}\n<INCLUDE>{PATH}\t\t{\n\t\t\t\tchar *yptr;\n\n\t\t\t\typtr = yytext;\n\t\t\t\tstring_buf_ptr = string_buf;\n\t\t\t\twhile (*yptr)\n\t\t\t\t\t*string_buf_ptr++ = *yptr++;\n\t\t\t\tyylval.str = string_buf;\n\t\t\t\t*string_buf_ptr = '\\0';\n\t\t\t\treturn T_PATH;\n\t\t\t}\n<INCLUDE>.\t\t{ stop(\"Invalid include line\", EX_DATAERR); }\n#define{SPACE}\t\t{\n\t\t\t\tBEGIN MACRODEF;\n\t\t\t\treturn T_DEFINE;\n\t\t\t}\n<MACRODEF>{WORD}{SPACE}\t{ \n\t\t\t\tchar *yptr;\n\n\t\t\t\t/* Strip space and return as a normal symbol */\n\t\t\t\typtr = yytext;\n\t\t\t\twhile (*yptr != ' ' && *yptr != '\\t')\n\t\t\t\t\typtr++;\n\t\t\t\t*yptr = '\\0';\n\t\t\t\tyylval.sym = symtable_get(yytext);\n\t\t\t\tstring_buf_ptr = string_buf;\n\t\t\t\tBEGIN MACROBODY;\n\t\t\t\treturn T_SYMBOL;\n\t\t\t}\n<MACRODEF>{WORD}\\(\t{\n\t\t\t\t/*\n\t\t\t\t * We store the symbol with its opening\n\t\t\t\t * parren so we can differentiate macros\n\t\t\t\t * that take args from macros with the\n\t\t\t\t * same name that do not take args as\n\t\t\t\t * is allowed in C.\n\t\t\t\t */\n\t\t\t\tBEGIN MACROARGLIST;\n\t\t\t\tyylval.sym = symtable_get(yytext);\n\t\t\t\tunput('(');\n\t\t\t\treturn T_SYMBOL;\n\t\t\t}\n<MACROARGLIST>{WORD}\t{\n\t\t\t\tyylval.str = yytext;\n\t\t\t\treturn T_ARG;\n\t\t\t}\n<MACROARGLIST>{SPACE}   ;\n<MACROARGLIST>[(,]\t{\n\t\t\t\treturn yytext[0];\n\t\t\t}\n<MACROARGLIST>[)]\t{\n\t\t\t\tstring_buf_ptr = string_buf;\n\t\t\t\tBEGIN MACROBODY;\n\t\t\t\treturn ')';\n\t\t\t}\n<MACROARGLIST>.\t\t{\n\t\t\t\tsnprintf(buf, sizeof(buf), \"Invalid character \"\n\t\t\t\t\t \"'%c' in macro argument list\",\n\t\t\t\t\t yytext[0]);\n\t\t\t\tstop(buf, EX_DATAERR);\n\t\t\t}\n<MACROCALLARGS>{SPACE}  ;\n<MACROCALLARGS>\\(\t{\n\t\t\t\tparren_count++;\n\t\t\t\tif (parren_count == 1)\n\t\t\t\t\treturn ('(');\n\t\t\t\t*string_buf_ptr++ = '(';\n\t\t\t}\n<MACROCALLARGS>\\)\t{\n\t\t\t\tparren_count--;\n\t\t\t\tif (parren_count == 0) {\n\t\t\t\t\tBEGIN INITIAL;\n\t\t\t\t\treturn (')');\n\t\t\t\t}\n\t\t\t\t*string_buf_ptr++ = ')';\n\t\t\t}\n<MACROCALLARGS>{MCARG}\t{\n\t\t\t\tchar *yptr;\n\n\t\t\t\typtr = yytext;\n\t\t\t\twhile (*yptr)\n\t\t\t\t\t*string_buf_ptr++ = *yptr++;\n\t\t\t}\n<MACROCALLARGS>\\,\t{\n\t\t\t\tif (string_buf_ptr != string_buf) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Return an argument and\n\t\t\t\t\t * rescan this comma so we\n\t\t\t\t\t * can return it as well.\n\t\t\t\t\t */\n\t\t\t\t\t*string_buf_ptr = '\\0';\n\t\t\t\t\tyylval.str = string_buf;\n\t\t\t\t\tstring_buf_ptr = string_buf;\n\t\t\t\t\tunput(',');\n\t\t\t\t\treturn T_ARG;\n\t\t\t\t}\n\t\t\t\treturn ',';\n\t\t\t}\n<MACROBODY>\\\\\\n\t\t{\n\t\t\t\t/* Eat escaped newlines. */\n\t\t\t\t++yylineno;\n\t\t\t}\n<MACROBODY>\\r\t\t;\n<MACROBODY>\\n\t\t{\n\t\t\t\t/* Macros end on the first unescaped newline. */\n\t\t\t\tBEGIN INITIAL;\n\t\t\t\t*string_buf_ptr = '\\0';\n\t\t\t\tyylval.str = string_buf;\n\t\t\t\t++yylineno;\n\t\t\t\treturn T_MACROBODY;\n\t\t\t}\n<MACROBODY>{MBODY}\t{\n\t\t\t\tchar *yptr;\n\t\t\t\tchar c;\n\n\t\t\t\typtr = yytext;\n\t\t\t\twhile (c = *yptr++) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Strip carriage returns.\n\t\t\t\t\t */\n\t\t\t\t\tif (c == '\\r')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t*string_buf_ptr++ = c;\n\t\t\t\t}\n\t\t\t}\n{WORD}\\(\t\t{\n\t\t\t\tchar *yptr;\n\t\t\t\tchar *ycopy;\n\n\t\t\t\t/* May be a symbol or a macro invocation. */\n\t\t\t\tyylval.sym = symtable_get(yytext);\n\t\t\t\tif (yylval.sym->type == MACRO) {\n\t\t\t\t\tYY_BUFFER_STATE old_state;\n\t\t\t\t\tYY_BUFFER_STATE temp_state;\n\n\t\t\t\t\tycopy = strdup(yytext);\n\t\t\t\t\typtr = ycopy + yyleng;\n\t\t\t\t\twhile (yptr > ycopy)\n\t\t\t\t\t\tunput(*--yptr);\n\t\t\t\t\told_state = YY_CURRENT_BUFFER;\n\t\t\t\t\ttemp_state =\n\t\t\t\t\t    yy_create_buffer(stdin,\n\t\t\t\t\t\t\t     YY_BUF_SIZE);\n\t\t\t\t\tyy_switch_to_buffer(temp_state);\n\t\t\t\t\tmm_switch_to_buffer(old_state);\n\t\t\t\t\tmmparse();\n\t\t\t\t\tmm_switch_to_buffer(temp_state);\n\t\t\t\t\tyy_switch_to_buffer(old_state);\n\t\t\t\t\tmm_delete_buffer(temp_state);\n\t\t\t\t\texpand_macro(yylval.sym);\n\t\t\t\t} else {\n\t\t\t\t\tif (yylval.sym->type == UNINITIALIZED) {\n\t\t\t\t\t\t/* Try without the '(' */\n\t\t\t\t\t\tsymbol_delete(yylval.sym);\n\t\t\t\t\t\tyytext[yyleng-1] = '\\0';\n\t\t\t\t\t\tyylval.sym =\n\t\t\t\t\t\t    symtable_get(yytext);\n\t\t\t\t\t}\n\t\t\t\t\tunput('(');\n\t\t\t\t\treturn T_SYMBOL;\n\t\t\t\t}\n\t\t\t}\n{WORD}\t\t\t{\n\t\t\t\tyylval.sym = symtable_get(yytext);\n\t\t\t\tif (yylval.sym->type == MACRO) {\n\t\t\t\t\texpand_macro(yylval.sym);\n\t\t\t\t} else {\n\t\t\t\t\treturn T_SYMBOL;\n\t\t\t\t}\n\t\t\t}\n.\t\t\t{ \n\t\t\t\tsnprintf(buf, sizeof(buf), \"Invalid character \"\n\t\t\t\t\t \"'%c'\", yytext[0]);\n\t\t\t\tstop(buf, EX_DATAERR);\n\t\t\t}\n%%\n\ntypedef struct include {\n        YY_BUFFER_STATE  buffer;\n        int              lineno;\n        char            *filename;\n\tSLIST_ENTRY(include) links;\n}include_t;\n\nSLIST_HEAD(, include) include_stack;\n\nvoid\ninclude_file(char *file_name, include_type type)\n{\n\tFILE *newfile;\n\tinclude_t *include;\n\n\tnewfile = NULL;\n\t/* Try the current directory first */\n\tif (includes_search_curdir != 0 || type == SOURCE_FILE)\n\t\tnewfile = fopen(file_name, \"r\");\n\n\tif (newfile == NULL && type != SOURCE_FILE) {\n                path_entry_t include_dir;\n                for (include_dir = search_path.slh_first;\n                     include_dir != NULL;                \n                     include_dir = include_dir->links.sle_next) {\n\t\t\tchar fullname[PATH_MAX];\n\n\t\t\tif ((include_dir->quoted_includes_only == TRUE)\n\t\t\t && (type != QUOTED_INCLUDE))\n\t\t\t\tcontinue;\n\n\t\t\tsnprintf(fullname, sizeof(fullname),\n\t\t\t\t \"%s/%s\", include_dir->directory, file_name);\n\n\t\t\tif ((newfile = fopen(fullname, \"r\")) != NULL)\n\t\t\t\tbreak;\n                }\n        }\n\n\tif (newfile == NULL) {\n\t\tperror(file_name);\n\t\tstop(\"Unable to open input file\", EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t}\n\n\tif (type != SOURCE_FILE) {\n\t\tinclude = (include_t *)malloc(sizeof(include_t));\n\t\tif (include == NULL) {\n\t\t\tstop(\"Unable to allocate include stack entry\",\n\t\t\t     EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\t\tinclude->buffer = YY_CURRENT_BUFFER;\n\t\tinclude->lineno = yylineno;\n\t\tinclude->filename = yyfilename;\n\t\tSLIST_INSERT_HEAD(&include_stack, include, links);\n\t}\n\tyy_switch_to_buffer(yy_create_buffer(newfile, YY_BUF_SIZE));\n\tyylineno = 1;\n\tyyfilename = strdup(file_name);\n}\n\nstatic void next_substitution(struct symbol *mac_symbol, const char *body_pos,\n\t\t\t      const char **next_match,\n\t\t\t      struct macro_arg **match_marg, regmatch_t *match);\n\nvoid\nexpand_macro(struct symbol *macro_symbol)\n{\n\tstruct macro_arg *marg;\n\tstruct macro_arg *match_marg;\n\tconst char *body_head;\n\tconst char *body_pos;\n\tconst char *next_match;\n\n\t/*\n\t * Due to the nature of unput, we must work\n\t * backwards through the macro body performing\n\t * any expansions.\n\t */\n\tbody_head = macro_symbol->info.macroinfo->body;\n\tbody_pos = body_head + strlen(body_head);\n\twhile (body_pos > body_head) {\n\t\tregmatch_t match;\n\n\t\tnext_match = body_head;\n\t\tmatch_marg = NULL;\n\t\tnext_substitution(macro_symbol, body_pos, &next_match,\n\t\t\t\t  &match_marg, &match);\n\n\t\t/* Put back everything up until the replacement. */\n\t\twhile (body_pos > next_match)\n\t\t\tunput(*--body_pos);\n\n\t\t/* Perform the replacement. */\n\t\tif (match_marg != NULL) {\n\t\t\tconst char *strp;\n\n\t\t\tnext_match = match_marg->replacement_text;\n\t\t\tstrp = next_match + strlen(next_match);\n\t\t\twhile (strp > next_match)\n\t\t\t\tunput(*--strp);\n\n\t\t\t/* Skip past the unexpanded macro arg. */\n\t\t\tbody_pos -= match.rm_eo - match.rm_so;\n\t\t}\n\t}\n\n\t/* Cleanup replacement text. */\n\tSTAILQ_FOREACH(marg, &macro_symbol->info.macroinfo->args, links) {\n\t\tfree(marg->replacement_text);\n\t}\n}\n\n/*\n * Find the next substitution in the macro working backwards from\n * body_pos until the beginning of the macro buffer.  next_match\n * should be initialized to the beginning of the macro buffer prior\n * to calling this routine.\n */\nstatic void\nnext_substitution(struct symbol *mac_symbol, const char *body_pos,\n\t\t  const char **next_match, struct macro_arg **match_marg,\n\t\t  regmatch_t *match)\n{\n\tregmatch_t\t  matches[2];\n\tstruct macro_arg *marg;\n\tconst char\t *search_pos;\n\tint\t\t  retval;\n\n\tdo {\n\t\tsearch_pos = *next_match;\n\n\t\tSTAILQ_FOREACH(marg, &mac_symbol->info.macroinfo->args, links) {\n\n\t\t\tretval = regexec(&marg->arg_regex, search_pos, 2,\n\t\t\t\t\t matches, 0);\n\t\t\tif (retval == 0\n\t\t\t && (matches[1].rm_eo + search_pos) <= body_pos\n\t\t\t && (matches[1].rm_eo + search_pos) > *next_match) {\n\t\t\t\t*match = matches[1];\n\t\t\t\t*next_match = match->rm_eo + search_pos;\n\t\t\t\t*match_marg = marg;\n\t\t\t}\n\t\t}\n\t} while (search_pos != *next_match);\n}\n\nint\nyywrap()\n{\n\tinclude_t *include;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER);\n\t(void)fclose(yyin);\n\tif (yyfilename != NULL)\n\t\tfree(yyfilename);\n\tyyfilename = NULL;\n\tinclude = include_stack.slh_first;\n\tif (include != NULL) {\n\t\tyy_switch_to_buffer(include->buffer);\n\t\tyylineno = include->lineno;\n\t\tyyfilename = include->filename;\n\t\tSLIST_REMOVE_HEAD(&include_stack, links);\n\t\tfree(include);\n\t\treturn (0);\n\t}\n\treturn (1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}