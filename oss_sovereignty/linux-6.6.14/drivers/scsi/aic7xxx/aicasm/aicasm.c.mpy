{
  "module_name": "aicasm.c",
  "hash_id": "488ac7a0733af7902e75a8b45ffa4b45bff957d4afb4b31fff4b648e3163210b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aicasm/aicasm.c",
  "human_readable_source": " \n#include <sys/types.h>\n#include <sys/mman.h>\n\n#include <ctype.h>\n#include <inttypes.h>\n#include <regex.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sysexits.h>\n#include <unistd.h>\n\n#if linux\n#include <endian.h>\n#else\n#include <machine/endian.h>\n#endif\n\n#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm_insformat.h\"\n\ntypedef struct patch {\n\tSTAILQ_ENTRY(patch) links;\n\tint\t\tpatch_func;\n\tu_int\t\tbegin;\n\tu_int\t\tskip_instr;\n\tu_int\t\tskip_patch;\n} patch_t;\n\nSTAILQ_HEAD(patch_list, patch) patches;\n\nstatic void usage(void);\nstatic void back_patch(void);\nstatic void output_code(void);\nstatic void output_listing(char *ifilename);\nstatic void dump_scope(scope_t *scope);\nstatic void emit_patch(scope_t *scope, int patch);\nstatic int check_patch(patch_t **start_patch, int start_instr,\n\t\t       int *skip_addr, int *func_vals);\n\nstruct path_list search_path;\nint includes_search_curdir;\nchar *appname;\nchar *stock_include_file;\nFILE *ofile;\nchar *ofilename;\nchar *regfilename;\nFILE *regfile;\nchar *listfilename;\nFILE *listfile;\nchar *regdiagfilename;\nFILE *regdiagfile;\nint   src_mode;\nint   dst_mode;\n\nstatic STAILQ_HEAD(,instruction) seq_program;\nstruct cs_tailq cs_tailq;\nstruct scope_list scope_stack;\nsymlist_t patch_functions;\n\n#if DEBUG\nextern int yy_flex_debug;\nextern int mm_flex_debug;\nextern int yydebug;\nextern int mmdebug;\n#endif\nextern FILE *yyin;\nextern int yyparse(void);\n\nint main(int argc, char *argv[]);\n\nint\nmain(int argc, char *argv[])\n{\n\textern char *optarg;\n\textern int optind;\n\tint  ch;\n\tint  retval;\n\tchar *inputfilename;\n\tscope_t *sentinal;\n\n\tSTAILQ_INIT(&patches);\n\tSLIST_INIT(&search_path);\n\tSTAILQ_INIT(&seq_program);\n\tTAILQ_INIT(&cs_tailq);\n\tSLIST_INIT(&scope_stack);\n\n\t \n\tsentinal = scope_alloc();\n\tsentinal->type = SCOPE_ROOT;\n\t\n\tincludes_search_curdir = 1;\n\tappname = *argv;\n\tregfile = NULL;\n\tlistfile = NULL;\n#if DEBUG\n\tyy_flex_debug = 0;\n\tmm_flex_debug = 0;\n\tyydebug = 0;\n\tmmdebug = 0;\n#endif\n\twhile ((ch = getopt(argc, argv, \"d:i:l:n:o:p:r:I:\")) != -1) {\n\t\tswitch(ch) {\n\t\tcase 'd':\n#if DEBUG\n\t\t\tif (strcmp(optarg, \"s\") == 0) {\n\t\t\t\tyy_flex_debug = 1;\n\t\t\t\tmm_flex_debug = 1;\n\t\t\t} else if (strcmp(optarg, \"p\") == 0) {\n\t\t\t\tyydebug = 1;\n\t\t\t\tmmdebug = 1;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: -d Requires either an \"\n\t\t\t\t\t\"'s' or 'p' argument\\n\", appname);\n\t\t\t\tusage();\n\t\t\t}\n#else\n\t\t\tstop(\"-d: Assembler not built with debugging \"\n\t\t\t     \"information\", EX_SOFTWARE);\n#endif\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tstock_include_file = optarg;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t \n\t\t\tif ((listfile = fopen(optarg, \"w\")) == NULL) {\n\t\t\t\tperror(optarg);\n\t\t\t\tstop(NULL, EX_CANTCREAT);\n\t\t\t}\n\t\t\tlistfilename = optarg;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\t \n\t\t\tif (strcmp(optarg, \"ostdinc\")) {\n\t\t\t\tfprintf(stderr, \"%s: Unknown option -%c%s\\n\",\n\t\t\t\t\tappname, ch, optarg);\n\t\t\t\tusage();\n\t\t\t\t \n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif ((ofile = fopen(optarg, \"w\")) == NULL) {\n\t\t\t\tperror(optarg);\n\t\t\t\tstop(NULL, EX_CANTCREAT);\n\t\t\t}\n\t\t\tofilename = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\t \n\t\t\tif ((regdiagfile = fopen(optarg, \"w\")) == NULL) {\n\t\t\t\tperror(optarg);\n\t\t\t\tstop(NULL, EX_CANTCREAT);\n\t\t\t}\n\t\t\tregdiagfilename = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif ((regfile = fopen(optarg, \"w\")) == NULL) {\n\t\t\t\tperror(optarg);\n\t\t\t\tstop(NULL, EX_CANTCREAT);\n\t\t\t}\n\t\t\tregfilename = optarg;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t{\n\t\t\tpath_entry_t include_dir;\n\n\t\t\tif (strcmp(optarg, \"-\") == 0) {\n\t\t\t\tif (includes_search_curdir == 0) {\n\t\t\t\t\tfprintf(stderr, \"%s: Warning - '-I-' \"\n\t\t\t\t\t\t\t\"specified multiple \"\n\t\t\t\t\t\t\t\"times\\n\", appname);\n\t\t\t\t}\n\t\t\t\tincludes_search_curdir = 0;\n\t\t\t\tfor (include_dir = SLIST_FIRST(&search_path);\n\t\t\t\t     include_dir != NULL;\n\t\t\t\t     include_dir = SLIST_NEXT(include_dir,\n\t\t\t\t\t\t\t      links))\n\t\t\t\t\t \n\t\t\t\t\tinclude_dir->quoted_includes_only = 1;\n\t\t\t} else {\n\t\t\t\tinclude_dir =\n\t\t\t\t    (path_entry_t)malloc(sizeof(*include_dir));\n\t\t\t\tif (include_dir == NULL) {\n\t\t\t\t\tperror(optarg);\n\t\t\t\t\tstop(NULL, EX_OSERR);\n\t\t\t\t}\n\t\t\t\tinclude_dir->directory = strdup(optarg);\n\t\t\t\tif (include_dir->directory == NULL) {\n\t\t\t\t\tperror(optarg);\n\t\t\t\t\tstop(NULL, EX_OSERR);\n\t\t\t\t}\n\t\t\t\tinclude_dir->quoted_includes_only = 0;\n\t\t\t\tSLIST_INSERT_HEAD(&search_path, include_dir,\n\t\t\t\t\t\t  links);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage();\n\t\t\t \n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (argc != 1) {\n\t\tfprintf(stderr, \"%s: No input file specified\\n\", appname);\n\t\tusage();\n\t\t \n\t}\n\n\tif (regdiagfile != NULL\n\t && (regfile == NULL || stock_include_file == NULL)) {\n\t\tfprintf(stderr,\n\t\t\t\"%s: The -p option requires the -r and -i options.\\n\",\n\t\t\tappname);\n\t\tusage();\n\t\t \n\t}\n\tsymtable_open();\n\tinputfilename = *argv;\n\tinclude_file(*argv, SOURCE_FILE);\n\tretval = yyparse();\n\tif (retval == 0) {\n\t\tif (SLIST_FIRST(&scope_stack) == NULL\n\t\t || SLIST_FIRST(&scope_stack)->type != SCOPE_ROOT) {\n\t\t\tstop(\"Unterminated conditional expression\", EX_DATAERR);\n\t\t\t \n\t\t}\n\n\t\t \n\t\tprocess_scope(SLIST_FIRST(&scope_stack));\n\t\t \n\t\t \n\t\tdump_scope(SLIST_FIRST(&scope_stack));\n\n\t\t \n\t\tback_patch();\n\n\t\tif (ofile != NULL)\n\t\t\toutput_code();\n\t\tif (regfile != NULL)\n\t\t\tsymtable_dump(regfile, regdiagfile);\n\t\tif (listfile != NULL)\n\t\t\toutput_listing(inputfilename);\n\t}\n\n\tstop(NULL, 0);\n\t \n\treturn (0);\n}\n\nstatic void\nusage()\n{\n\n\t(void)fprintf(stderr,\n\"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]\\n\"\n\"\t[-r register_output_file [-p register_diag_file -i includefile]]\\n\"\n\"\t[-l program_list_file]\\n\"\n\"\tinput_file\\n\", appname);\n\texit(EX_USAGE);\n}\n\nstatic void\nback_patch()\n{\n\tstruct instruction *cur_instr;\n\n\tfor (cur_instr = STAILQ_FIRST(&seq_program);\n\t     cur_instr != NULL;\n\t     cur_instr = STAILQ_NEXT(cur_instr, links)) {\n\t\tif (cur_instr->patch_label != NULL) {\n\t\t\tstruct ins_format3 *f3_instr;\n\t\t\tu_int address;\n\n\t\t\tif (cur_instr->patch_label->type != LABEL) {\n\t\t\t\tchar buf[255];\n\n\t\t\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t\t \"Undefined label %s\",\n\t\t\t\t\t cur_instr->patch_label->name);\n\t\t\t\tstop(buf, EX_DATAERR);\n\t\t\t\t \n\t\t\t}\n\t\t\tf3_instr = &cur_instr->format.format3;\n\t\t\taddress = f3_instr->address;\n\t\t\taddress += cur_instr->patch_label->info.linfo->address;\n\t\t\tf3_instr->address = address;\n\t\t}\n\t}\n}\n\nstatic void\noutput_code()\n{\n\tstruct instruction *cur_instr;\n\tpatch_t *cur_patch;\n\tcritical_section_t *cs;\n\tsymbol_node_t *cur_node;\n\tint instrcount;\n\n\tinstrcount = 0;\n\tfprintf(ofile,\n\"/*\\n\"\n\" * DO NOT EDIT - This file is automatically generated\\n\"\n\" *\t\t from the following source files:\\n\"\n\" *\\n\"\n\"%s */\\n\", versions);\n\n\tfprintf(ofile, \"static const uint8_t seqprog[] = {\\n\");\n\tfor (cur_instr = STAILQ_FIRST(&seq_program);\n\t     cur_instr != NULL;\n\t     cur_instr = STAILQ_NEXT(cur_instr, links)) {\n\n\t\tfprintf(ofile, \"%s\\t0x%02x, 0x%02x, 0x%02x, 0x%02x\",\n\t\t\tcur_instr == STAILQ_FIRST(&seq_program) ? \"\" : \",\\n\",\n#ifdef __LITTLE_ENDIAN\n\t\t\tcur_instr->format.bytes[0],\n\t\t\tcur_instr->format.bytes[1],\n\t\t\tcur_instr->format.bytes[2],\n\t\t\tcur_instr->format.bytes[3]);\n#else\n\t\t\tcur_instr->format.bytes[3],\n\t\t\tcur_instr->format.bytes[2],\n\t\t\tcur_instr->format.bytes[1],\n\t\t\tcur_instr->format.bytes[0]);\n#endif\n\t\tinstrcount++;\n\t}\n\tfprintf(ofile, \"\\n};\\n\\n\");\n\n\tif (patch_arg_list == NULL)\n\t\tstop(\"Patch argument list not defined\",\n\t\t     EX_DATAERR);\n\n\t \n\tfprintf(ofile,\n\"typedef int %spatch_func_t (%s);\\n\", prefix, patch_arg_list);\n\n\tfor (cur_node = SLIST_FIRST(&patch_functions);\n\t     cur_node != NULL;\n\t     cur_node = SLIST_NEXT(cur_node,links)) {\n\t\tfprintf(ofile,\n\"static %spatch_func_t %spatch%d_func;\\n\"\n\"\\n\"\n\"static int\\n\"\n\"%spatch%d_func(%s)\\n\"\n\"{\\n\"\n\"\treturn (%s);\\n\"\n\"}\\n\\n\",\n\t\t\tprefix,\n\t\t\tprefix,\n\t\t\tcur_node->symbol->info.condinfo->func_num,\n\t\t\tprefix,\n\t\t\tcur_node->symbol->info.condinfo->func_num,\n\t\t\tpatch_arg_list,\n\t\t\tcur_node->symbol->name);\n\t}\n\n\tfprintf(ofile,\n\"static const struct patch {\\n\"\n\"\t%spatch_func_t\t\t*patch_func;\\n\"\n\"\tuint32_t\t\t begin\t\t:10,\\n\"\n\"\t\t\t\t skip_instr\t:10,\\n\"\n\"\t\t\t\t skip_patch\t:12;\\n\"\n\"} patches[] = {\\n\", prefix);\n\n\tfor (cur_patch = STAILQ_FIRST(&patches);\n\t     cur_patch != NULL;\n\t     cur_patch = STAILQ_NEXT(cur_patch,links)) {\n\t\tfprintf(ofile, \"%s\\t{ %spatch%d_func, %d, %d, %d }\",\n\t\t\tcur_patch == STAILQ_FIRST(&patches) ? \"\" : \",\\n\",\n\t\t\tprefix,\n\t\t\tcur_patch->patch_func, cur_patch->begin,\n\t\t\tcur_patch->skip_instr, cur_patch->skip_patch);\n\t}\n\n\tfprintf(ofile, \"\\n};\\n\\n\");\n\n\tfprintf(ofile,\n\"static const struct cs {\\n\"\n\"\tuint16_t\tbegin;\\n\"\n\"\tuint16_t\tend;\\n\"\n\"} critical_sections[] = {\\n\");\n\n\tfor (cs = TAILQ_FIRST(&cs_tailq);\n\t     cs != NULL;\n\t     cs = TAILQ_NEXT(cs, links)) {\n\t\tfprintf(ofile, \"%s\\t{ %d, %d }\",\n\t\t\tcs == TAILQ_FIRST(&cs_tailq) ? \"\" : \",\\n\",\n\t\t\tcs->begin_addr, cs->end_addr);\n\t}\n\n\tfprintf(ofile, \"\\n};\\n\\n\");\n\n\tfprintf(ofile,\n\t\"#define NUM_CRITICAL_SECTIONS ARRAY_SIZE(critical_sections)\\n\");\n\n\tfprintf(stderr, \"%s: %d instructions used\\n\", appname, instrcount);\n}\n\nstatic void\ndump_scope(scope_t *scope)\n{\n\tscope_t *cur_scope;\n\n\t \n\temit_patch(scope, 0);\n\n\t \n\tcur_scope = TAILQ_FIRST(&scope->inner_scope);\n\n\twhile (cur_scope != NULL) {\n\n\t\tdump_scope(cur_scope);\n\n\t\tcur_scope = TAILQ_NEXT(cur_scope, scope_links);\n\t}\n\n\t \n\temit_patch(scope, 1);\n}\n\nvoid\nemit_patch(scope_t *scope, int patch)\n{\n\tpatch_info_t *pinfo;\n\tpatch_t *new_patch;\n\n\tpinfo = &scope->patches[patch];\n\n\tif (pinfo->skip_instr == 0)\n\t\t \n\t\treturn;\n\n\tnew_patch = (patch_t *)malloc(sizeof(*new_patch));\n\n\tif (new_patch == NULL)\n\t\tstop(\"Could not malloc patch structure\", EX_OSERR);\n\n\tmemset(new_patch, 0, sizeof(*new_patch));\n\n\tif (patch == 0) {\n\t\tnew_patch->patch_func = scope->func_num;\n\t\tnew_patch->begin = scope->begin_addr;\n\t} else {\n\t\tnew_patch->patch_func = 0;\n\t\tnew_patch->begin = scope->end_addr;\n\t}\n\tnew_patch->skip_instr = pinfo->skip_instr;\n\tnew_patch->skip_patch = pinfo->skip_patch;\n\tSTAILQ_INSERT_TAIL(&patches, new_patch, links);\n}\n\nvoid\noutput_listing(char *ifilename)\n{\n\tchar buf[1024];\n\tFILE *ifile;\n\tstruct instruction *cur_instr;\n\tpatch_t *cur_patch;\n\tsymbol_node_t *cur_func;\n\tint *func_values;\n\tint instrcount;\n\tint instrptr;\n\tint line;\n\tint func_count;\n\tint skip_addr;\n\n\tinstrcount = 0;\n\tinstrptr = 0;\n\tline = 1;\n\tskip_addr = 0;\n\tif ((ifile = fopen(ifilename, \"r\")) == NULL) {\n\t\tperror(ifilename);\n\t\tstop(NULL, EX_DATAERR);\n\t}\n\n\t \n\tfor (func_count = 0, cur_func = SLIST_FIRST(&patch_functions);\n\t    cur_func != NULL;\n\t    cur_func = SLIST_NEXT(cur_func, links))\n\t\tfunc_count++;\n\n\tfunc_values = NULL;\n\tif (func_count != 0) {\n\t\tfunc_values = (int *)malloc(func_count * sizeof(int));\n\n\t\tif (func_values == NULL)\n\t\t\tstop(\"Could not malloc\", EX_OSERR);\n\t\t\n\t\tfunc_values[0] = 0;  \n\t\tfunc_count--;\n\n\t\t \n\t\t\n\t\t\n\t\tfor (cur_func = SLIST_FIRST(&patch_functions);\n\t\t     cur_func != NULL && SLIST_NEXT(cur_func, links) != NULL;\n\t\t     cur_func = SLIST_NEXT(cur_func, links), func_count--) {\n\t\t\tint input;\n\t\t\t\n\t\t\tfprintf(stdout, \"\\n(%s)\\n\", cur_func->symbol->name);\n\t\t\tfprintf(stdout,\n\t\t\t\t\"Enter the return value for \"\n\t\t\t\t\"this expression[T/F]:\");\n\n\t\t\twhile (1) {\n\n\t\t\t\tinput = getchar();\n\t\t\t\tinput = toupper(input);\n\n\t\t\t\tif (input == 'T') {\n\t\t\t\t\tfunc_values[func_count] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (input == 'F') {\n\t\t\t\t\tfunc_values[func_count] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isatty(fileno(stdin)) == 0)\n\t\t\t\tputchar(input);\n\t\t}\n\t\tfprintf(stdout, \"\\nThanks!\\n\");\n\t}\n\n\t \n\tcur_patch = STAILQ_FIRST(&patches);\n\tfor (cur_instr = STAILQ_FIRST(&seq_program);\n\t     cur_instr != NULL;\n\t     cur_instr = STAILQ_NEXT(cur_instr, links), instrcount++) {\n\n\t\tif (check_patch(&cur_patch, instrcount,\n\t\t\t\t&skip_addr, func_values) == 0) {\n\t\t\t \n                        continue;\n\t\t}\n\n\t\twhile (line < cur_instr->srcline) {\n\t\t\tfgets(buf, sizeof(buf), ifile);\n\t\t\t\tfprintf(listfile, \"             \\t%s\", buf);\n\t\t\t\tline++;\n\t\t}\n\t\tfprintf(listfile, \"%04x %02x%02x%02x%02x\", instrptr,\n#ifdef __LITTLE_ENDIAN\n\t\t\tcur_instr->format.bytes[0],\n\t\t\tcur_instr->format.bytes[1],\n\t\t\tcur_instr->format.bytes[2],\n\t\t\tcur_instr->format.bytes[3]);\n#else\n\t\t\tcur_instr->format.bytes[3],\n\t\t\tcur_instr->format.bytes[2],\n\t\t\tcur_instr->format.bytes[1],\n\t\t\tcur_instr->format.bytes[0]);\n#endif\n\t\t \n\t\tif (line == cur_instr->srcline) {\n\t\t\tfgets(buf, sizeof(buf), ifile);\n\t\t\tfprintf(listfile, \"\\t%s\", buf);\n\t\t\tline++;\n\t\t} else {\n\t\t\tfprintf(listfile, \"\\n\");\n\t\t}\n\t\tinstrptr++;\n\t}\n\t \n\twhile(fgets(buf, sizeof(buf), ifile) != NULL)\n\t\tfprintf(listfile, \"             %s\", buf);\n\n\tfclose(ifile);\n}\n\nstatic int\ncheck_patch(patch_t **start_patch, int start_instr,\n\t    int *skip_addr, int *func_vals)\n{\n\tpatch_t *cur_patch;\n\n\tcur_patch = *start_patch;\n\n\twhile (cur_patch != NULL && start_instr == cur_patch->begin) {\n\t\tif (func_vals[cur_patch->patch_func] == 0) {\n\t\t\tint skip;\n\n\t\t\t \n\t\t\t*skip_addr = start_instr + cur_patch->skip_instr;\n\t\t\tfor (skip = cur_patch->skip_patch;\n\t\t\t     skip > 0 && cur_patch != NULL;\n\t\t\t     skip--)\n\t\t\t\tcur_patch = STAILQ_NEXT(cur_patch, links);\n\t\t} else {\n\t\t\t \n\t\t\tcur_patch = STAILQ_NEXT(cur_patch, links);\n\t\t}\n\t}\n\n\t*start_patch = cur_patch;\n\tif (start_instr < *skip_addr)\n\t\t \n\t\treturn (0);\n\n\treturn (1);\n}\n\n \nvoid\nstop(const char *string, int err_code)\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}\n\nstruct instruction *\nseq_alloc()\n{\n\tstruct instruction *new_instr;\n\n\tnew_instr = (struct instruction *)malloc(sizeof(struct instruction));\n\tif (new_instr == NULL)\n\t\tstop(\"Unable to malloc instruction object\", EX_SOFTWARE);\n\tmemset(new_instr, 0, sizeof(*new_instr));\n\tSTAILQ_INSERT_TAIL(&seq_program, new_instr, links);\n\tnew_instr->srcline = yylineno;\n\treturn new_instr;\n}\n\ncritical_section_t *\ncs_alloc()\n{\n\tcritical_section_t *new_cs;\n\n\tnew_cs= (critical_section_t *)malloc(sizeof(critical_section_t));\n\tif (new_cs == NULL)\n\t\tstop(\"Unable to malloc critical_section object\", EX_SOFTWARE);\n\tmemset(new_cs, 0, sizeof(*new_cs));\n\t\n\tTAILQ_INSERT_TAIL(&cs_tailq, new_cs, links);\n\treturn new_cs;\n}\n\nscope_t *\nscope_alloc()\n{\n\tscope_t *new_scope;\n\n\tnew_scope = (scope_t *)malloc(sizeof(scope_t));\n\tif (new_scope == NULL)\n\t\tstop(\"Unable to malloc scope object\", EX_SOFTWARE);\n\tmemset(new_scope, 0, sizeof(*new_scope));\n\tTAILQ_INIT(&new_scope->inner_scope);\n\t\n\tif (SLIST_FIRST(&scope_stack) != NULL) {\n\t\tTAILQ_INSERT_TAIL(&SLIST_FIRST(&scope_stack)->inner_scope,\n\t\t\t\t  new_scope, scope_links);\n\t}\n\t \n\tSLIST_INSERT_HEAD(&scope_stack, new_scope, scope_stack_links);\n\treturn new_scope;\n}\n\nvoid\nprocess_scope(scope_t *scope)\n{\n\t \n\tscope_t *cur_scope;\n\tu_int skip_patch_count;\n\tu_int skip_instr_count;\n\n\tcur_scope = TAILQ_LAST(&scope->inner_scope, scope_tailq);\n\tskip_patch_count = 0;\n\tskip_instr_count = 0;\n\twhile (cur_scope != NULL) {\n\t\tu_int patch0_patch_skip;\n\n\t\tpatch0_patch_skip = 0;\n\t\tswitch (cur_scope->type) {\n\t\tcase SCOPE_IF:\n\t\tcase SCOPE_ELSE_IF:\n\t\t\tif (skip_instr_count != 0) {\n\t\t\t\t \n\t\t\t\tpatch0_patch_skip++;\n\t\t\t\tcur_scope->patches[1].skip_patch =\n\t\t\t\t    skip_patch_count + 1;\n\t\t\t\tcur_scope->patches[1].skip_instr =\n\t\t\t\t    skip_instr_count;\n\t\t\t}\n\n\t\t\t \n\t\t\tpatch0_patch_skip++;\n\n\t\t\t \n\t\t\tpatch0_patch_skip += cur_scope->inner_scope_patches;\n\n\t\t\tcur_scope->patches[0].skip_patch = patch0_patch_skip;\n\t\t\tcur_scope->patches[0].skip_instr =\n\t\t\t    cur_scope->end_addr - cur_scope->begin_addr;\n\n\t\t\tskip_instr_count += cur_scope->patches[0].skip_instr;\n\n\t\t\tskip_patch_count += patch0_patch_skip;\n\t\t\tif (cur_scope->type == SCOPE_IF) {\n\t\t\t\tscope->inner_scope_patches += skip_patch_count;\n\t\t\t\tskip_patch_count = 0;\n\t\t\t        skip_instr_count = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SCOPE_ELSE:\n\t\t\t \n\t\t\tskip_patch_count += cur_scope->inner_scope_patches;\n\n\t\t\tskip_instr_count += cur_scope->end_addr\n\t\t\t\t\t  - cur_scope->begin_addr;\n\t\t\tbreak;\n\t\tcase SCOPE_ROOT:\n\t\t\tstop(\"Unexpected scope type encountered\", EX_SOFTWARE);\n\t\t\t \n\t\t}\n\n\t\tcur_scope = TAILQ_PREV(cur_scope, scope_tailq, scope_links);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}