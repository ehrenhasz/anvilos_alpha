{
  "module_name": "aic7xxx.reg",
  "hash_id": "6c64d509ebaeba9694e3bf45bdb9501f910fa7c217fd23ff6d02de1cee4fb255",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic7xxx.reg",
  "human_readable_source": "/*\n * Aic7xxx register and scratch ram definitions.\n *\n * Copyright (c) 1994-2001 Justin T. Gibbs.\n * Copyright (c) 2000-2001 Adaptec Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions, and the following disclaimer,\n *    without modification.\n * 2. Redistributions in binary form must reproduce at minimum a disclaimer\n *    substantially similar to the \"NO WARRANTY\" disclaimer below\n *    (\"Disclaimer\") and any redistribution must be conditioned upon\n *    including a substantially similar Disclaimer requirement for further\n *    binary redistribution.\n * 3. Neither the names of the above-listed copyright holders nor the names\n *    of any contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * Alternatively, this software may be distributed under the terms of the\n * GNU General Public License (\"GPL\") version 2 as published by the Free\n * Software Foundation.\n *\n * NO WARRANTY\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGES.\n *\n * $FreeBSD$\n */\nVERSION = \"$Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#40 $\"\n\n/*\n * This file is processed by the aic7xxx_asm utility for use in assembling\n * firmware for the aic7xxx family of SCSI host adapters as well as to generate\n * a C header file for use in the kernel portion of the Aic7xxx driver.\n *\n * All page numbers refer to the Adaptec AIC-7770 Data Book available from\n * Adaptec's Technical Documents Department 1-800-934-2766\n */\n\n/*\n * Registers marked \"dont_generate_debug_code\" are not (yet) referenced\n * from the driver code, and this keyword inhibit generation\n * of debug code for them.\n *\n * REG_PRETTY_PRINT config will complain if dont_generate_debug_code\n * is added to the register which is referenced in the driver.\n * Unreferenced register with no dont_generate_debug_code will result\n * in dead code. No warning is issued.\n */\n\n/*\n * SCSI Sequence Control (p. 3-11).\n * Each bit, when set starts a specific SCSI sequence on the bus\n */\nregister SCSISEQ {\n\taddress\t\t\t0x000\n\taccess_mode RW\n\tfield\tTEMODE\t\t0x80\n\tfield\tENSELO\t\t0x40\n\tfield\tENSELI\t\t0x20\n\tfield\tENRSELI\t\t0x10\n\tfield\tENAUTOATNO\t0x08\n\tfield\tENAUTOATNI\t0x04\n\tfield\tENAUTOATNP\t0x02\n\tfield\tSCSIRSTO\t0x01\n}\n\n/*\n * SCSI Transfer Control 0 Register (pp. 3-13).\n * Controls the SCSI module data path.\n */\nregister SXFRCTL0 {\n\taddress\t\t\t0x001\n\taccess_mode RW\n\tfield\tDFON\t\t0x80\n\tfield\tDFPEXP\t\t0x40\n\tfield\tFAST20\t\t0x20\n\tfield\tCLRSTCNT\t0x10\n\tfield\tSPIOEN\t\t0x08\n\tfield\tSCAMEN\t\t0x04\n\tfield\tCLRCHN\t\t0x02\n}\n\n/*\n * SCSI Transfer Control 1 Register (pp. 3-14,15).\n * Controls the SCSI module data path.\n */\nregister SXFRCTL1 {\n\taddress\t\t\t0x002\n\taccess_mode RW\n\tfield\tBITBUCKET\t0x80\n\tfield\tSWRAPEN\t\t0x40\n\tfield\tENSPCHK\t\t0x20\n\tmask\tSTIMESEL\t0x18\n\tfield\tENSTIMER\t0x04\n\tfield\tACTNEGEN\t0x02\n\tfield\tSTPWEN\t\t0x01\t/* Powered Termination */\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Control Signal Read Register (p. 3-15).\n * Reads the actual state of the SCSI bus pins\n */\nregister SCSISIGI {\n\taddress\t\t\t0x003\n\taccess_mode RO\n\tfield\tCDI\t\t0x80\n\tfield\tIOI\t\t0x40\n\tfield\tMSGI\t\t0x20\n\tfield\tATNI\t\t0x10\n\tfield\tSELI\t\t0x08\n\tfield\tBSYI\t\t0x04\n\tfield\tREQI\t\t0x02\n\tfield\tACKI\t\t0x01\n/*\n * Possible phases in SCSISIGI\n */\n\tmask\tPHASE_MASK\tCDI|IOI|MSGI\n\tmask\tP_DATAOUT\t0x00\n\tmask\tP_DATAIN\tIOI\n\tmask\tP_DATAOUT_DT\tP_DATAOUT|MSGI\n\tmask\tP_DATAIN_DT\tP_DATAIN|MSGI\n\tmask\tP_COMMAND\tCDI\n\tmask\tP_MESGOUT\tCDI|MSGI\n\tmask\tP_STATUS\tCDI|IOI\n\tmask\tP_MESGIN\tCDI|IOI|MSGI\n}\n\n/*\n * SCSI Control Signal Write Register (p. 3-16).\n * Writing to this register modifies the control signals on the bus.  Only\n * those signals that are allowed in the current mode (Initiator/Target) are\n * asserted.\n */\nregister SCSISIGO {\n\taddress\t\t\t0x003\n\taccess_mode WO\n\tfield\tCDO\t\t0x80\n\tfield\tIOO\t\t0x40\n\tfield\tMSGO\t\t0x20\n\tfield\tATNO\t\t0x10\n\tfield\tSELO\t\t0x08\n\tfield\tBSYO\t\t0x04\n\tfield\tREQO\t\t0x02\n\tfield\tACKO\t\t0x01\n/*\n * Possible phases to write into SCSISIG0\n */\n\tmask\tPHASE_MASK\tCDI|IOI|MSGI\n\tmask\tP_DATAOUT\t0x00\n\tmask\tP_DATAIN\tIOI\n\tmask\tP_COMMAND\tCDI\n\tmask\tP_MESGOUT\tCDI|MSGI\n\tmask\tP_STATUS\tCDI|IOI\n\tmask\tP_MESGIN\tCDI|IOI|MSGI\n\tdont_generate_debug_code\n}\n\n/* \n * SCSI Rate Control (p. 3-17).\n * Contents of this register determine the Synchronous SCSI data transfer\n * rate and the maximum synchronous Req/Ack offset.  An offset of 0 in the\n * SOFS (3:0) bits disables synchronous data transfers.  Any offset value\n * greater than 0 enables synchronous transfers.\n */\nregister SCSIRATE {\n\taddress\t\t\t0x004\n\taccess_mode RW\n\tfield\tWIDEXFER\t0x80\t\t/* Wide transfer control */\n\tfield\tENABLE_CRC\t0x40\t\t/* CRC for D-Phases */\n\tfield\tSINGLE_EDGE\t0x10\t\t/* Disable DT Transfers */\n\tmask\tSXFR\t\t0x70\t\t/* Sync transfer rate */\n\tmask\tSXFR_ULTRA2\t0x0f\t\t/* Sync transfer rate */\n\tmask\tSOFS\t\t0x0f\t\t/* Sync offset */\n}\n\n/*\n * SCSI ID (p. 3-18).\n * Contains the ID of the board and the current target on the\n * selected channel.\n */\nregister SCSIID\t{\n\taddress\t\t\t0x005\n\taccess_mode RW\n\tmask\tTID\t\t0xf0\t\t/* Target ID mask */\n\tmask\tTWIN_TID\t0x70\n\tfield\tTWIN_CHNLB\t0x80\n\tmask\tOID\t\t0x0f\t\t/* Our ID mask */\n\t/*\n\t * SCSI Maximum Offset (p. 4-61 aic7890/91 Data Book)\n\t * The aic7890/91 allow an offset of up to 127 transfers in both wide\n\t * and narrow mode.\n\t */\n\talias\tSCSIOFFSET\n\tmask\tSOFS_ULTRA2\t0x7f\t\t/* Sync offset U2 chips */\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Latched Data (p. 3-19).\n * Read/Write latches used to transfer data on the SCSI bus during\n * Automatic or Manual PIO mode.  SCSIDATH can be used for the\n * upper byte of a 16bit wide asynchronouse data phase transfer.\n */\nregister SCSIDATL {\n\taddress\t\t\t0x006\n\taccess_mode RW\n\tdont_generate_debug_code\n}\n\nregister SCSIDATH {\n\taddress\t\t\t0x007\n\taccess_mode RW\n}\n\n/*\n * SCSI Transfer Count (pp. 3-19,20)\n * These registers count down the number of bytes transferred\n * across the SCSI bus.  The counter is decremented only once\n * the data has been safely transferred.  SDONE in SSTAT0 is\n * set when STCNT goes to 0\n */ \nregister STCNT {\n\taddress\t\t\t0x008\n\tsize\t3\n\taccess_mode RW\n\tdont_generate_debug_code\n}\n\n/* ALT_MODE registers (Ultra2 and Ultra160 chips) */\nregister SXFRCTL2 {\n\taddress\t\t\t0x013\n\taccess_mode RW\n\tfield\tAUTORSTDIS\t0x10\n\tfield\tCMDDMAEN\t0x08\n\tmask\tASYNC_SETUP\t0x07\n}\n\n/* ALT_MODE register on Ultra160 chips */\nregister OPTIONMODE {\n\taddress\t\t\t0x008\n\taccess_mode RW\n\tcount\t\t2\n\tfield\tAUTORATEEN\t\t0x80\n\tfield\tAUTOACKEN\t\t0x40\n\tfield\tATNMGMNTEN\t\t0x20\n\tfield\tBUSFREEREV\t\t0x10\n\tfield\tEXPPHASEDIS\t\t0x08\n\tfield\tSCSIDATL_IMGEN\t\t0x04\n\tfield\tAUTO_MSGOUT_DE\t\t0x02\n\tfield\tDIS_MSGIN_DUALEDGE\t0x01\n\tmask\tOPTIONMODE_DEFAULTS\tAUTO_MSGOUT_DE|DIS_MSGIN_DUALEDGE\n\tdont_generate_debug_code\n}\n\n/* ALT_MODE register on Ultra160 chips */\nregister TARGCRCCNT {\n\taddress\t\t\t0x00a\n\tsize\t2\n\taccess_mode RW\n\tcount\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * Clear SCSI Interrupt 0 (p. 3-20)\n * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT0.\n */\nregister CLRSINT0 {\n\taddress\t\t\t0x00b\n\taccess_mode WO\n\tfield\tCLRSELDO\t0x40\n\tfield\tCLRSELDI\t0x20\n\tfield\tCLRSELINGO\t0x10\n\tfield\tCLRSWRAP\t0x08\n\tfield\tCLRIOERR\t0x08\t/* Ultra2 Only */\n\tfield\tCLRSPIORDY\t0x02\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Status 0 (p. 3-21)\n * Contains one set of SCSI Interrupt codes\n * These are most likely of interest to the sequencer\n */\nregister SSTAT0\t{\n\taddress\t\t\t0x00b\n\taccess_mode RO\n\tfield\tTARGET\t\t0x80\t/* Board acting as target */\n\tfield\tSELDO\t\t0x40\t/* Selection Done */\n\tfield\tSELDI\t\t0x20\t/* Board has been selected */\n\tfield\tSELINGO\t\t0x10\t/* Selection In Progress */\n\tfield\tSWRAP\t\t0x08\t/* 24bit counter wrap */\n\tfield\tIOERR\t\t0x08\t/* LVD Tranceiver mode changed */\n\tfield\tSDONE\t\t0x04\t/* STCNT = 0x000000 */\n\tfield\tSPIORDY\t\t0x02\t/* SCSI PIO Ready */\n\tfield\tDMADONE\t\t0x01\t/* DMA transfer completed */\n}\n\n/*\n * Clear SCSI Interrupt 1 (p. 3-23)\n * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT1.\n */\nregister CLRSINT1 {\n\taddress\t\t\t0x00c\n\taccess_mode WO\n\tfield\tCLRSELTIMEO\t0x80\n\tfield\tCLRATNO\t\t0x40\n\tfield\tCLRSCSIRSTI\t0x20\n\tfield\tCLRBUSFREE\t0x08\n\tfield\tCLRSCSIPERR\t0x04\n\tfield\tCLRPHASECHG\t0x02\n\tfield\tCLRREQINIT\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Status 1 (p. 3-24)\n */\nregister SSTAT1\t{\n\taddress\t\t\t0x00c\n\taccess_mode RO\n\tfield\tSELTO\t\t0x80\n\tfield\tATNTARG \t0x40\n\tfield\tSCSIRSTI\t0x20\n\tfield\tPHASEMIS\t0x10\n\tfield\tBUSFREE\t\t0x08\n\tfield\tSCSIPERR\t0x04\n\tfield\tPHASECHG\t0x02\n\tfield\tREQINIT\t\t0x01\n}\n\n/*\n * SCSI Status 2 (pp. 3-25,26)\n */\nregister SSTAT2 {\n\taddress\t\t\t0x00d\n\taccess_mode RO\n\tfield\tOVERRUN\t\t0x80\n\tfield\tSHVALID\t\t0x40\t/* Shadow Layer non-zero */\n\tfield\tEXP_ACTIVE\t0x10\t/* SCSI Expander Active */\n\tfield\tCRCVALERR\t0x08\t/* CRC doesn't match (U3 only) */\n\tfield\tCRCENDERR\t0x04\t/* No terminal CRC packet (U3 only) */\n\tfield\tCRCREQERR\t0x02\t/* Illegal CRC packet req (U3 only) */\n\tfield\tDUAL_EDGE_ERR\t0x01\t/* Incorrect data phase (U3 only) */\n\tmask\tSFCNT\t\t0x1f\n}\n\n/*\n * SCSI Status 3 (p. 3-26)\n */\nregister SSTAT3 {\n\taddress\t\t\t0x00e\n\taccess_mode RO\n\tcount\t\t2\n\tmask\tSCSICNT\t\t0xf0\n\tmask\tOFFCNT\t\t0x0f\n\tmask\tU2OFFCNT\t0x7f\n}\n\n/*\n * SCSI ID for the aic7890/91 chips\n */\nregister SCSIID_ULTRA2 {\n\taddress\t\t\t0x00f\n\taccess_mode RW\n\tmask\tTID\t\t0xf0\t\t/* Target ID mask */\n\tmask\tOID\t\t0x0f\t\t/* Our ID mask */\n\tdont_generate_debug_code\n}\n\n/*\n * SCSI Interrupt Mode 1 (p. 3-28)\n * Setting any bit will enable the corresponding function\n * in SIMODE0 to interrupt via the IRQ pin.\n */\nregister SIMODE0 {\n\taddress\t\t\t0x010\n\taccess_mode RW\n\tcount\t\t2\n\tfield\tENSELDO\t\t0x40\n\tfield\tENSELDI\t\t0x20\n\tfield\tENSELINGO\t0x10\n\tfield\tENSWRAP\t\t0x08\n\tfield\tENIOERR\t\t0x08\t/* LVD Tranceiver mode changes */\n\tfield\tENSDONE\t\t0x04\n\tfield\tENSPIORDY\t0x02\n\tfield\tENDMADONE\t0x01\n}\n\n/*\n * SCSI Interrupt Mode 1 (pp. 3-28,29)\n * Setting any bit will enable the corresponding function\n * in SIMODE1 to interrupt via the IRQ pin.\n */\nregister SIMODE1 {\n\taddress\t\t\t0x011\n\taccess_mode RW\n\tfield\tENSELTIMO\t0x80\n\tfield\tENATNTARG\t0x40\n\tfield\tENSCSIRST\t0x20\n\tfield\tENPHASEMIS\t0x10\n\tfield\tENBUSFREE\t0x08\n\tfield\tENSCSIPERR\t0x04\n\tfield\tENPHASECHG\t0x02\n\tfield\tENREQINIT\t0x01\n}\n\n/*\n * SCSI Data Bus (High) (p. 3-29)\n * This register reads data on the SCSI Data bus directly.\n */\nregister SCSIBUSL {\n\taddress\t\t\t0x012\n\taccess_mode RW\n}\n\nregister SCSIBUSH {\n\taddress\t\t\t0x013\n\taccess_mode RW\n}\n\n/*\n * SCSI/Host Address (p. 3-30)\n * These registers hold the host address for the byte about to be\n * transferred on the SCSI bus.  They are counted up in the same\n * manner as STCNT is counted down.  SHADDR should always be used\n * to determine the address of the last byte transferred since HADDR\n * can be skewed by write ahead.\n */\nregister SHADDR {\n\taddress\t\t\t0x014\n\tsize\t4\n\taccess_mode RO\n\tdont_generate_debug_code\n}\n\n/*\n * Selection Timeout Timer (p. 3-30)\n */\nregister SELTIMER {\n\taddress\t\t\t0x018\n\taccess_mode RW\n\tcount\t\t1\n\tfield\tSTAGE6\t\t0x20\n\tfield\tSTAGE5\t\t0x10\n\tfield\tSTAGE4\t\t0x08\n\tfield\tSTAGE3\t\t0x04\n\tfield\tSTAGE2\t\t0x02\n\tfield\tSTAGE1\t\t0x01\n\talias\tTARGIDIN\n\tdont_generate_debug_code\n}\n\n/*\n * Selection/Reselection ID (p. 3-31)\n * Upper four bits are the device id.  The ONEBIT is set when the re/selecting\n * device did not set its own ID.\n */\nregister SELID {\n\taddress\t\t\t0x019\n\taccess_mode RW\n\tmask\tSELID_MASK\t0xf0\n\tfield\tONEBIT\t\t0x08\n\tdont_generate_debug_code\n}\n\nregister SCAMCTL {\n\taddress\t\t\t0x01a\n\taccess_mode RW\n\tfield\tENSCAMSELO\t0x80\n\tfield\tCLRSCAMSELID\t0x40\n\tfield\tALTSTIM\t\t0x20\n\tfield\tDFLTTID\t\t0x10\n\tmask\tSCAMLVL\t\t0x03\n}\n\n/*\n * Target Mode Selecting in ID bitmask (aic7890/91/96/97)\n */\nregister TARGID {\n\taddress\t\t\t0x01b\n\tsize\t\t\t2\n\taccess_mode RW\n\tcount\t\t14\n\tdont_generate_debug_code\n}\n\n/*\n * Serial Port I/O Cabability register (p. 4-95 aic7860 Data Book)\n * Indicates if external logic has been attached to the chip to\n * perform the tasks of accessing a serial eeprom, testing termination\n * strength, and performing cable detection.  On the aic7860, most of\n * these features are handled on chip, but on the aic7855 an attached\n * aic3800 does the grunt work.\n */\nregister SPIOCAP {\n\taddress\t\t\t0x01b\n\taccess_mode RW\n\tcount\t\t10\n\tfield\tSOFT1\t\t0x80\n\tfield\tSOFT0\t\t0x40\n\tfield\tSOFTCMDEN\t0x20\t\n\tfield\tEXT_BRDCTL\t0x10\t/* External Board control */\n\tfield\tSEEPROM\t\t0x08\t/* External serial eeprom logic */\n\tfield\tEEPROM\t\t0x04\t/* Writable external BIOS ROM */\n\tfield\tROM\t\t0x02\t/* Logic for accessing external ROM */\n\tfield\tSSPIOCPS\t0x01\t/* Termination and cable detection */\n\tdont_generate_debug_code\n}\n\nregister BRDCTL\t{\n\taddress\t\t\t0x01d\n\tcount\t\t11\n\tfield\tBRDDAT7\t\t0x80\n\tfield\tBRDDAT6\t\t0x40\n\tfield\tBRDDAT5\t\t0x20\n\tfield\tBRDSTB\t\t0x10\n\tfield\tBRDCS\t\t0x08\n\tfield\tBRDRW\t\t0x04\n\tfield\tBRDCTL1\t\t0x02\n\tfield\tBRDCTL0\t\t0x01\n\t/* 7890 Definitions */\n\tfield\tBRDDAT4\t\t0x10\n\tfield\tBRDDAT3\t\t0x08\n\tfield\tBRDDAT2\t\t0x04\n\tfield\tBRDRW_ULTRA2\t0x02\n\tfield\tBRDSTB_ULTRA2\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * Serial EEPROM Control (p. 4-92 in 7870 Databook)\n * Controls the reading and writing of an external serial 1-bit\n * EEPROM Device.  In order to access the serial EEPROM, you must\n * first set the SEEMS bit that generates a request to the memory\n * port for access to the serial EEPROM device.  When the memory\n * port is not busy servicing another request, it reconfigures\n * to allow access to the serial EEPROM.  When this happens, SEERDY\n * gets set high to verify that the memory port access has been\n * granted.  \n *\n * After successful arbitration for the memory port, the SEECS bit of \n * the SEECTL register is connected to the chip select.  The SEECK, \n * SEEDO, and SEEDI are connected to the clock, data out, and data in \n * lines respectively.  The SEERDY bit of SEECTL is useful in that it \n * gives us an 800 nsec timer.  After a write to the SEECTL register, \n * the SEERDY goes high 800 nsec later.  The one exception to this is \n * when we first request access to the memory port.  The SEERDY goes \n * high to signify that access has been granted and, for this case, has \n * no implied timing.\n *\n * See 93cx6.c for detailed information on the protocol necessary to \n * read the serial EEPROM.\n */\nregister SEECTL {\n\taddress\t\t\t0x01e\n\tcount\t\t11\n\tfield\tEXTARBACK\t0x80\n\tfield\tEXTARBREQ\t0x40\n\tfield\tSEEMS\t\t0x20\n\tfield\tSEERDY\t\t0x10\n\tfield\tSEECS\t\t0x08\n\tfield\tSEECK\t\t0x04\n\tfield\tSEEDO\t\t0x02\n\tfield\tSEEDI\t\t0x01\n\tdont_generate_debug_code\n}\n/*\n * SCSI Block Control (p. 3-32)\n * Controls Bus type and channel selection.  In a twin channel configuration\n * addresses 0x00-0x1e are gated to the appropriate channel based on this\n * register.  SELWIDE allows for the coexistence of 8bit and 16bit devices\n * on a wide bus.\n */\nregister SBLKCTL {\n\taddress\t\t\t0x01f\n\taccess_mode RW\n\tfield\tDIAGLEDEN\t0x80\t/* Aic78X0 only */\n\tfield\tDIAGLEDON\t0x40\t/* Aic78X0 only */\n\tfield\tAUTOFLUSHDIS\t0x20\n\tfield\tSELBUSB\t\t0x08\n\tfield\tENAB40\t\t0x08\t/* LVD transceiver active */\n\tfield\tENAB20\t\t0x04\t/* SE/HVD transceiver active */\n\tfield\tSELWIDE\t\t0x02\n\tfield\tXCVR\t\t0x01\t/* External transceiver active */\n}\n\n/*\n * Sequencer Control (p. 3-33)\n * Error detection mode and speed configuration\n */\nregister SEQCTL {\n\taddress\t\t\t0x060\n\taccess_mode RW\n\tcount\t\t15\n\tfield\tPERRORDIS\t0x80\n\tfield\tPAUSEDIS\t0x40\n\tfield\tFAILDIS\t\t0x20\n\tfield\tFASTMODE\t0x10\n\tfield\tBRKADRINTEN\t0x08\n\tfield\tSTEP\t\t0x04\n\tfield\tSEQRESET\t0x02\n\tfield\tLOADRAM\t\t0x01\n}\n\n/*\n * Sequencer RAM Data (p. 3-34)\n * Single byte window into the Scratch Ram area starting at the address\n * specified by SEQADDR0 and SEQADDR1.  To write a full word, simply write\n * four bytes in succession.  The SEQADDRs will increment after the most\n * significant byte is written\n */\nregister SEQRAM {\n\taddress\t\t\t0x061\n\taccess_mode RW\n\tcount\t\t2\n\tdont_generate_debug_code\n}\n\n/*\n * Sequencer Address Registers (p. 3-35)\n * Only the first bit of SEQADDR1 holds addressing information\n */\nregister SEQADDR0 {\n\taddress\t\t\t0x062\n\taccess_mode RW\n\tdont_generate_debug_code\n}\n\nregister SEQADDR1 {\n\taddress\t\t\t0x063\n\taccess_mode RW\n\tcount\t\t8\n\tmask\tSEQADDR1_MASK\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * Accumulator\n * We cheat by passing arguments in the Accumulator up to the kernel driver\n */\nregister ACCUM {\n\taddress\t\t\t0x064\n\taccess_mode RW\n\taccumulator\n\tdont_generate_debug_code\n}\n\nregister SINDEX\t{\n\taddress\t\t\t0x065\n\taccess_mode RW\n\tsindex\n\tdont_generate_debug_code\n}\n\nregister DINDEX {\n\taddress\t\t\t0x066\n\taccess_mode RW\n\tdont_generate_debug_code\n}\n\nregister ALLONES {\n\taddress\t\t\t0x069\n\taccess_mode RO\n\tallones\n\tdont_generate_debug_code\n}\n\nregister ALLZEROS {\n\taddress\t\t\t0x06a\n\taccess_mode RO\n\tallzeros\n\tdont_generate_debug_code\n}\n\nregister NONE {\n\taddress\t\t\t0x06a\n\taccess_mode WO\n\tnone\n\tdont_generate_debug_code\n}\n\nregister FLAGS {\n\taddress\t\t\t0x06b\n\taccess_mode RO\n\tcount\t\t18\n\tfield\tZERO\t\t0x02\n\tfield\tCARRY\t\t0x01\n\tdont_generate_debug_code\n}\n\nregister SINDIR\t{\n\taddress\t\t\t0x06c\n\taccess_mode RO\n\tdont_generate_debug_code\n}\n\nregister DINDIR\t {\n\taddress\t\t\t0x06d\n\taccess_mode WO\n\tdont_generate_debug_code\n}\n\nregister FUNCTION1 {\n\taddress\t\t\t0x06e\n\taccess_mode RW\n}\n\nregister STACK {\n\taddress\t\t\t0x06f\n\taccess_mode RO\n\tcount\t\t5\n\tdont_generate_debug_code\n}\n\nconst\tSTACK_SIZE\t4\n\n/*\n * Board Control (p. 3-43)\n */\nregister BCTL {\n\taddress\t\t\t0x084\n\taccess_mode RW\n\tfield\tACE\t\t0x08\n\tfield\tENABLE\t\t0x01\n}\n\n/*\n * On the aic78X0 chips, Board Control is replaced by the DSCommand\n * register (p. 4-64)\n */\nregister DSCOMMAND0 {\n\taddress\t\t\t0x084\n\taccess_mode RW\n\tcount\t\t7\n\tfield\tCACHETHEN\t0x80\t/* Cache Threshold enable */\n\tfield\tDPARCKEN\t0x40\t/* Data Parity Check Enable */\n\tfield\tMPARCKEN\t0x20\t/* Memory Parity Check Enable */\n\tfield\tEXTREQLCK\t0x10\t/* External Request Lock */\n\t/* aic7890/91/96/97 only */\n\tfield\tINTSCBRAMSEL\t0x08\t/* Internal SCB RAM Select */\n\tfield\tRAMPS\t\t0x04\t/* External SCB RAM Present */\n\tfield\tUSCBSIZE32\t0x02\t/* Use 32byte SCB Page Size */\n\tfield\tCIOPARCKEN\t0x01\t/* Internal bus parity error enable */\n\tdont_generate_debug_code\n}\n\nregister DSCOMMAND1 {\n\taddress\t\t\t0x085\n\taccess_mode RW\n\tmask\tDSLATT\t\t0xfc\t/* PCI latency timer (non-ultra2) */\n\tfield\tHADDLDSEL1\t0x02\t/* Host Address Load Select Bits */\n\tfield\tHADDLDSEL0\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * Bus On/Off Time (p. 3-44) aic7770 only\n */\nregister BUSTIME {\n\taddress\t\t\t0x085\n\taccess_mode RW\n\tcount\t\t2\n\tmask\tBOFF\t\t0xf0\n\tmask\tBON\t\t0x0f\n\tdont_generate_debug_code\n}\n\n/*\n * Bus Speed (p. 3-45) aic7770 only\n */\nregister BUSSPD {\n\taddress\t\t\t0x086\n\taccess_mode RW\n\tcount\t\t2\n\tmask\tDFTHRSH\t\t0xc0\n\tmask\tSTBOFF\t\t0x38\n\tmask\tSTBON\t\t0x07\n\tmask\tDFTHRSH_100\t0xc0\n\tmask\tDFTHRSH_75\t0x80\n\tdont_generate_debug_code\n}\n\n/* aic7850/55/60/70/80/95 only */\nregister DSPCISTATUS {\n\taddress\t\t\t0x086\n\tcount\t\t4\n\tmask\tDFTHRSH_100\t0xc0\n\tdont_generate_debug_code\n}\n\n/* aic7890/91/96/97 only */\nregister HS_MAILBOX {\n\taddress\t\t\t0x086\n\tmask\tHOST_MAILBOX\t0xF0\n\tmask\tSEQ_MAILBOX\t0x0F\n\tmask\tHOST_TQINPOS\t0x80\t/* Boundary at either 0 or 128 */\n\tdont_generate_debug_code\n}\n\nconst\tHOST_MAILBOX_SHIFT\t4\nconst\tSEQ_MAILBOX_SHIFT\t0\n\n/*\n * Host Control (p. 3-47) R/W\n * Overall host control of the device.\n */\nregister HCNTRL {\n\taddress\t\t\t0x087\n\taccess_mode RW\n\tcount\t\t14\n\tfield\tPOWRDN\t\t0x40\n\tfield\tSWINT\t\t0x10\n\tfield\tIRQMS\t\t0x08\n\tfield\tPAUSE\t\t0x04\n\tfield\tINTEN\t\t0x02\n\tfield\tCHIPRST\t\t0x01\n\tfield\tCHIPRSTACK\t0x01\n\tdont_generate_debug_code\n}\n\n/*\n * Host Address (p. 3-48)\n * This register contains the address of the byte about\n * to be transferred across the host bus.\n */\nregister HADDR {\n\taddress\t\t\t0x088\n\tsize\t4\n\taccess_mode RW\n\tdont_generate_debug_code\n}\n\nregister HCNT {\n\taddress\t\t\t0x08c\n\tsize\t3\n\taccess_mode RW\n\tdont_generate_debug_code\n}\n\n/*\n * SCB Pointer (p. 3-49)\n * Gate one of the SCBs into the SCBARRAY window.\n */\nregister SCBPTR {\n\taddress\t\t\t0x090\n\taccess_mode RW\n\tdont_generate_debug_code\n}\n\n/*\n * Interrupt Status (p. 3-50)\n * Status for system interrupts\n */\nregister INTSTAT {\n\taddress\t\t\t0x091\n\taccess_mode RW\n\tfield\tBRKADRINT 0x08\n\tfield\tSCSIINT\t  0x04\n\tfield\tCMDCMPLT  0x02\n\tfield\tSEQINT    0x01\n\tmask\tBAD_PHASE\tSEQINT\t\t/* unknown scsi bus phase */\n\tmask\tSEND_REJECT\t0x10|SEQINT\t/* sending a message reject */\n\tmask\tPROTO_VIOLATION\t0x20|SEQINT\t/* SCSI protocol violation */ \n\tmask\tNO_MATCH\t0x30|SEQINT\t/* no cmd match for reconnect */\n\tmask\tIGN_WIDE_RES\t0x40|SEQINT\t/* Complex IGN Wide Res Msg */\n\tmask\tPDATA_REINIT\t0x50|SEQINT\t/*\n\t\t\t\t\t\t * Returned to data phase\n\t\t\t\t\t\t * that requires data\n\t\t\t\t\t\t * transfer pointers to be\n\t\t\t\t\t\t * recalculated from the\n\t\t\t\t\t\t * transfer residual.\n\t\t\t\t\t\t */\n\tmask\tHOST_MSG_LOOP\t0x60|SEQINT\t/*\n\t\t\t\t\t\t * The bus is ready for the\n\t\t\t\t\t\t * host to perform another\n\t\t\t\t\t\t * message transaction.  This\n\t\t\t\t\t\t * mechanism is used for things\n\t\t\t\t\t\t * like sync/wide negotiation\n\t\t\t\t\t\t * that require a kernel based\n\t\t\t\t\t\t * message state engine.\n\t\t\t\t\t\t */\n\tmask\tBAD_STATUS\t0x70|SEQINT\t/* Bad status from target */\n\tmask\tPERR_DETECTED\t0x80|SEQINT\t/*\n\t\t\t\t\t\t * Either the phase_lock\n\t\t\t\t\t\t * or inb_next routine has\n\t\t\t\t\t\t * noticed a parity error.\n\t\t\t\t\t\t */\n\tmask\tDATA_OVERRUN\t0x90|SEQINT\t/*\n\t\t\t\t\t\t * Target attempted to write\n\t\t\t\t\t\t * beyond the bounds of its\n\t\t\t\t\t\t * command.\n\t\t\t\t\t\t */\n\tmask\tMKMSG_FAILED\t0xa0|SEQINT\t/*\n\t\t\t\t\t\t * Target completed command\n\t\t\t\t\t\t * without honoring our ATN\n\t\t\t\t\t\t * request to issue a message. \n\t\t\t\t\t\t */\n\tmask\tMISSED_BUSFREE\t0xb0|SEQINT\t/*\n\t\t\t\t\t\t * The sequencer never saw\n\t\t\t\t\t\t * the bus go free after\n\t\t\t\t\t\t * either a command complete\n\t\t\t\t\t\t * or disconnect message.\n\t\t\t\t\t\t */\n\tmask\tSCB_MISMATCH\t0xc0|SEQINT\t/*\n\t\t\t\t\t\t * Downloaded SCB's tag does\n\t\t\t\t\t\t * not match the entry we\n\t\t\t\t\t\t * intended to download.\n\t\t\t\t\t\t */\n\tmask\tNO_FREE_SCB\t0xd0|SEQINT\t/*\n\t\t\t\t\t\t * get_free_or_disc_scb failed.\n\t\t\t\t\t\t */\n\tmask\tOUT_OF_RANGE\t0xe0|SEQINT\n\n\tmask\tSEQINT_MASK\t0xf0|SEQINT\t/* SEQINT Status Codes */\n\tmask\tINT_PEND  (BRKADRINT|SEQINT|SCSIINT|CMDCMPLT)\n\tdont_generate_debug_code\n}\n\n/*\n * Hard Error (p. 3-53)\n * Reporting of catastrophic errors.  You usually cannot recover from\n * these without a full board reset.\n */\nregister ERROR {\n\taddress\t\t\t0x092\n\taccess_mode RO\n\tcount\t\t26\n\tfield\tCIOPARERR\t0x80\t/* Ultra2 only */\n\tfield\tPCIERRSTAT\t0x40\t/* PCI only */\n\tfield\tMPARERR\t\t0x20\t/* PCI only */\n\tfield\tDPARERR\t\t0x10\t/* PCI only */\n\tfield\tSQPARERR\t0x08\n\tfield\tILLOPCODE\t0x04\n\tfield\tILLSADDR\t0x02\n\tfield\tILLHADDR\t0x01\n}\n\n/*\n * Clear Interrupt Status (p. 3-52)\n */\nregister CLRINT {\n\taddress\t\t\t0x092\n\taccess_mode WO\n\tcount\t\t24\n\tfield\tCLRPARERR\t0x10\t/* PCI only */\n\tfield\tCLRBRKADRINT\t0x08\n\tfield\tCLRSCSIINT      0x04\n\tfield\tCLRCMDINT \t0x02\n\tfield\tCLRSEQINT \t0x01\n\tdont_generate_debug_code\n}\n\nregister DFCNTRL {\n\taddress\t\t\t0x093\n\taccess_mode RW\n\tfield\tPRELOADEN\t0x80\t/* aic7890 only */\n\tfield\tWIDEODD\t\t0x40\n\tfield\tSCSIEN\t\t0x20\n\tfield\tSDMAEN\t\t0x10\n\tfield\tSDMAENACK\t0x10\n\tfield\tHDMAEN\t\t0x08\n\tfield\tHDMAENACK\t0x08\n\tfield\tDIRECTION\t0x04\n\tfield\tFIFOFLUSH\t0x02\n\tfield\tFIFORESET\t0x01\n}\n\nregister DFSTATUS {\n\taddress\t\t\t0x094\n\taccess_mode RO\n\tfield\tPRELOAD_AVAIL\t0x80\n\tfield\tDFCACHETH\t0x40\n\tfield\tFIFOQWDEMP\t0x20\n\tfield\tMREQPEND\t0x10\n\tfield\tHDONE\t\t0x08\n\tfield\tDFTHRESH\t0x04\n\tfield\tFIFOFULL\t0x02\n\tfield\tFIFOEMP\t\t0x01\n}\n\nregister DFWADDR {\n\taddress\t\t\t0x95\n\taccess_mode RW\n\tdont_generate_debug_code\n}\n\nregister DFRADDR {\n\taddress\t\t\t0x97\n\taccess_mode RW\n}\n\nregister DFDAT {\n\taddress\t\t\t0x099\n\taccess_mode RW\n\tdont_generate_debug_code\n}\n\n/*\n * SCB Auto Increment (p. 3-59)\n * Byte offset into the SCB Array and an optional bit to allow auto\n * incrementing of the address during download and upload operations\n */\nregister SCBCNT {\n\taddress\t\t\t0x09a\n\taccess_mode RW\n\tcount\t\t1\n\tfield\tSCBAUTO\t\t0x80\n\tmask\tSCBCNT_MASK\t0x1f\n\tdont_generate_debug_code\n}\n\n/*\n * Queue In FIFO (p. 3-60)\n * Input queue for queued SCBs (commands that the seqencer has yet to start)\n */\nregister QINFIFO {\n\taddress\t\t\t0x09b\n\taccess_mode RW\n\tcount\t\t12\n\tdont_generate_debug_code\n}\n\n/*\n * Queue In Count (p. 3-60)\n * Number of queued SCBs\n */\nregister QINCNT\t{\n\taddress\t\t\t0x09c\n\taccess_mode RO\n}\n\n/*\n * Queue Out FIFO (p. 3-61)\n * Queue of SCBs that have completed and await the host\n */\nregister QOUTFIFO {\n\taddress\t\t\t0x09d\n\taccess_mode WO\n\tcount\t\t7\n\tdont_generate_debug_code\n}\n\nregister CRCCONTROL1 {\n\taddress\t\t\t0x09d\n\taccess_mode RW\n\tcount\t\t3\n\tfield\tCRCONSEEN\t\t0x80\n\tfield\tCRCVALCHKEN\t\t0x40\n\tfield\tCRCENDCHKEN\t\t0x20\n\tfield\tCRCREQCHKEN\t\t0x10\n\tfield\tTARGCRCENDEN\t\t0x08\n\tfield\tTARGCRCCNTEN\t\t0x04\n\tdont_generate_debug_code\n}\n\n\n/*\n * Queue Out Count (p. 3-61)\n * Number of queued SCBs in the Out FIFO\n */\nregister QOUTCNT {\n\taddress\t\t\t0x09e\n\taccess_mode RO\n}\n\nregister SCSIPHASE {\n\taddress\t\t\t0x09e\n\taccess_mode RO\n\tfield\tSTATUS_PHASE\t0x20\n\tfield\tCOMMAND_PHASE\t0x10\n\tfield\tMSG_IN_PHASE\t0x08\n\tfield\tMSG_OUT_PHASE\t0x04\n\tfield\tDATA_IN_PHASE\t0x02\n\tfield\tDATA_OUT_PHASE\t0x01\n\tmask\tDATA_PHASE_MASK\t0x03\n}\n\n/*\n * Special Function\n */\nregister SFUNCT {\n\taddress\t\t\t0x09f\n\taccess_mode RW\n\tcount\t    4\n\tfield\tALT_MODE\t0x80\n\tdont_generate_debug_code\n}\n\n/*\n * SCB Definition (p. 5-4)\n */\nscb {\n\taddress\t\t0x0a0\n\tsize\t\t64\n\n\tSCB_CDB_PTR {\n\t\tsize\t4\n\t\talias\tSCB_RESIDUAL_DATACNT\n\t\talias\tSCB_CDB_STORE\n\t\tdont_generate_debug_code\n\t}\n\tSCB_RESIDUAL_SGPTR {\n\t\tsize\t4\n\t\tdont_generate_debug_code\n\t}\n\tSCB_SCSI_STATUS {\n\t\tsize\t1\n\t\tdont_generate_debug_code\n\t}\n\tSCB_TARGET_PHASES {\n\t\tsize\t1\n\t\tdont_generate_debug_code\n\t}\n\tSCB_TARGET_DATA_DIR {\n\t\tsize\t1\n\t\tdont_generate_debug_code\n\t}\n\tSCB_TARGET_ITAG {\n\t\tsize\t1\n\t\tdont_generate_debug_code\n\t}\n\tSCB_DATAPTR {\n\t\tsize\t4\n\t\tdont_generate_debug_code\n\t}\n\tSCB_DATACNT {\n\t\t/*\n\t\t * The last byte is really the high address bits for\n\t\t * the data address.\n\t\t */\n\t\tsize\t4\n\t\tfield\tSG_LAST_SEG\t\t0x80\t/* In the fourth byte */\n\t\tmask\tSG_HIGH_ADDR_BITS\t0x7F\t/* In the fourth byte */\n\t\tdont_generate_debug_code\n\t}\n\tSCB_SGPTR {\n\t\tsize\t4\n\t\tfield\tSG_RESID_VALID\t0x04\t/* In the first byte */\n\t\tfield\tSG_FULL_RESID\t0x02\t/* In the first byte */\n\t\tfield\tSG_LIST_NULL\t0x01\t/* In the first byte */\n\t\tdont_generate_debug_code\n\t}\n\tSCB_CONTROL {\n\t\tsize\t1\n\t\tfield\tTARGET_SCB\t\t\t0x80\n\t\tfield\tSTATUS_RCVD\t\t\t0x80\n\t\tfield\tDISCENB\t\t\t\t0x40\n\t\tfield\tTAG_ENB\t\t\t\t0x20\n\t\tfield\tMK_MESSAGE\t\t\t0x10\n\t\tfield\tULTRAENB\t\t\t0x08\n\t\tfield\tDISCONNECTED\t\t\t0x04\n\t\tmask\tSCB_TAG_TYPE\t\t\t0x03\n\t}\n\tSCB_SCSIID {\n\t\tsize\t1\n\t\tfield\tTWIN_CHNLB\t\t\t0x80\n\t\tmask\tTWIN_TID\t\t\t0x70\n\t\tmask\tTID\t\t\t\t0xf0\n\t\tmask\tOID\t\t\t\t0x0f\n\t}\n\tSCB_LUN {\n\t\tfield\tSCB_XFERLEN_ODD\t\t\t0x80\n\t\tmask\tLID\t\t\t\t0x3f\n\t\tsize\t1\n\t}\n\tSCB_TAG {\n\t\tsize\t1\n\t}\n\tSCB_CDB_LEN {\n\t\tsize\t1\n\t\tdont_generate_debug_code\n\t}\n\tSCB_SCSIRATE {\n\t\tsize\t1\n\t\tdont_generate_debug_code\n\t}\n\tSCB_SCSIOFFSET {\n\t\tsize\t1\n\t\tcount\t1\n\t\tdont_generate_debug_code\n\t}\n\tSCB_NEXT {\n\t\tsize\t1\n\t\tdont_generate_debug_code\n\t}\n\tSCB_64_SPARE {\n\t\tsize\t16\n\t}\n\tSCB_64_BTT {\n\t\tsize\t16\n\t\tdont_generate_debug_code\n\t}\n}\n\nconst\tSCB_UPLOAD_SIZE\t\t32\nconst\tSCB_DOWNLOAD_SIZE\t32\nconst\tSCB_DOWNLOAD_SIZE_64\t48\n\nconst\tSG_SIZEOF\t0x08\t\t/* sizeof(struct ahc_dma) */\n\n/* --------------------- AHA-2840-only definitions -------------------- */\n\nregister SEECTL_2840 {\n\taddress\t\t\t0x0c0\n\taccess_mode RW\n\tcount\t\t2\n\tfield\tCS_2840\t\t0x04\n\tfield\tCK_2840\t\t0x02\n\tfield\tDO_2840\t\t0x01\n\tdont_generate_debug_code\n}\n\nregister STATUS_2840 {\n\taddress\t\t\t0x0c1\n\taccess_mode RW\n\tcount\t\t4\n\tfield\tEEPROM_TF\t0x80\n\tmask\tBIOS_SEL\t0x60\n\tmask\tADSEL\t\t0x1e\n\tfield\tDI_2840\t\t0x01\n\tdont_generate_debug_code\n}\n\n/* --------------------- AIC-7870-only definitions -------------------- */\n\nregister CCHADDR {\n\taddress\t\t\t0x0E0\n\tsize 8\n\tdont_generate_debug_code\n}\n\nregister CCHCNT {\n\taddress\t\t\t0x0E8\n\tdont_generate_debug_code\n}\n\nregister CCSGRAM {\n\taddress\t\t\t0x0E9\n\tdont_generate_debug_code\n}\n\nregister CCSGADDR {\n\taddress\t\t\t0x0EA\n\tdont_generate_debug_code\n}\n\nregister CCSGCTL {\n\taddress\t\t\t0x0EB\n\tfield\tCCSGDONE\t0x80\n\tfield\tCCSGEN\t\t0x08\n\tfield\tSG_FETCH_NEEDED 0x02\t/* Bit used for software state */\n\tfield\tCCSGRESET\t0x01\n\tdont_generate_debug_code\n}\n\nregister CCSCBCNT {\n\taddress\t\t\t0xEF\n\tcount\t\t1\n\tdont_generate_debug_code\n}\n\nregister CCSCBCTL {\n\taddress\t\t\t0x0EE\n\tfield\tCCSCBDONE\t0x80\n\tfield\tARRDONE\t\t0x40\t/* SCB Array prefetch done */\n\tfield\tCCARREN\t\t0x10\n\tfield\tCCSCBEN\t\t0x08\n\tfield\tCCSCBDIR\t0x04\n\tfield\tCCSCBRESET\t0x01\n\tdont_generate_debug_code\n}\n\nregister CCSCBADDR {\n\taddress\t\t\t0x0ED\n\tdont_generate_debug_code\n}\n\nregister CCSCBRAM {\n\taddress\t\t\t0xEC\n\tdont_generate_debug_code\n}\n\n/*\n * SCB bank address (7895/7896/97 only)\n */\nregister SCBBADDR {\n\taddress\t\t\t0x0F0\n\taccess_mode RW\n\tcount\t\t3\n\tdont_generate_debug_code\n}\n\nregister CCSCBPTR {\n\taddress\t\t\t0x0F1\n\tdont_generate_debug_code\n}\n\nregister HNSCB_QOFF {\n\taddress\t\t\t0x0F4\n\tcount\t\t4\n\tdont_generate_debug_code\n}\n\nregister SNSCB_QOFF {\n\taddress\t\t\t0x0F6\n\tdont_generate_debug_code\n}\n\nregister SDSCB_QOFF {\n\taddress\t\t\t0x0F8\n\tdont_generate_debug_code\n}\n\nregister QOFF_CTLSTA {\n\taddress\t\t\t0x0FA\n\tfield\tSCB_AVAIL\t0x40\n\tfield\tSNSCB_ROLLOVER\t0x20\n\tfield\tSDSCB_ROLLOVER\t0x10\n\tmask\tSCB_QSIZE\t0x07\n\tmask\tSCB_QSIZE_256\t0x06\n\tdont_generate_debug_code\n}\n\nregister DFF_THRSH {\n\taddress\t\t\t0x0FB\n\tmask\tWR_DFTHRSH\t0x70\n\tmask\tRD_DFTHRSH\t0x07\n\tmask\tRD_DFTHRSH_MIN\t0x00\n\tmask\tRD_DFTHRSH_25\t0x01\n\tmask\tRD_DFTHRSH_50\t0x02\n\tmask\tRD_DFTHRSH_63\t0x03\n\tmask\tRD_DFTHRSH_75\t0x04\n\tmask\tRD_DFTHRSH_85\t0x05\n\tmask\tRD_DFTHRSH_90\t0x06\n\tmask\tRD_DFTHRSH_MAX\t0x07\n\tmask\tWR_DFTHRSH_MIN\t0x00\n\tmask\tWR_DFTHRSH_25\t0x10\n\tmask\tWR_DFTHRSH_50\t0x20\n\tmask\tWR_DFTHRSH_63\t0x30\n\tmask\tWR_DFTHRSH_75\t0x40\n\tmask\tWR_DFTHRSH_85\t0x50\n\tmask\tWR_DFTHRSH_90\t0x60\n\tmask\tWR_DFTHRSH_MAX\t0x70\n\tcount\t4\n\tdont_generate_debug_code\n}\n\nregister SG_CACHE_PRE {\n\taccess_mode WO\n\taddress\t\t\t0x0fc\n\tmask\tSG_ADDR_MASK\t0xf8\n\tfield\tLAST_SEG\t0x02\n\tfield\tLAST_SEG_DONE\t0x01\n\tdont_generate_debug_code\n}\n\nregister SG_CACHE_SHADOW {\n\taccess_mode RO\n\taddress\t\t\t0x0fc\n\tmask\tSG_ADDR_MASK\t0xf8\n\tfield\tLAST_SEG\t0x02\n\tfield\tLAST_SEG_DONE\t0x01\n\tdont_generate_debug_code\n}\n/* ---------------------- Scratch RAM Offsets ------------------------- */\n/* These offsets are either to values that are initialized by the board's\n * BIOS or are specified by the sequencer code.\n *\n * The host adapter card (at least the BIOS) uses 20-2f for SCSI\n * device information, 32-33 and 5a-5f as well. As it turns out, the\n * BIOS trashes 20-2f, writing the synchronous negotiation results\n * on top of the BIOS values, so we re-use those for our per-target\n * scratchspace (actually a value that can be copied directly into\n * SCSIRATE).  The kernel driver will enable synchronous negotiation\n * for all targets that have a value other than 0 in the lower four\n * bits of the target scratch space.  This should work regardless of\n * whether the bios has been installed.\n */\n\nscratch_ram {\n\taddress\t\t0x020\n\tsize\t\t58\n\n\t/*\n\t * 1 byte per target starting at this address for configuration values\n\t */\n\tBUSY_TARGETS {\n\t\talias\t\tTARG_SCSIRATE\n\t\tsize\t\t16\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * Bit vector of targets that have ULTRA enabled as set by\n\t * the BIOS.  The Sequencer relies on a per-SCB field to\n\t * control whether to enable Ultra transfers or not.  During\n\t * initialization, we read this field and reuse it for 2\n\t * entries in the busy target table.\n\t */\n\tULTRA_ENB {\n\t\talias\t\tCMDSIZE_TABLE\n\t\tsize\t\t2\n\t\tcount\t\t2\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * Bit vector of targets that have disconnection disabled as set by\n\t * the BIOS.  The Sequencer relies in a per-SCB field to control the\n\t * disconnect priveldge.  During initialization, we read this field\n\t * and reuse it for 2 entries in the busy target table.\n\t */\n\tDISC_DSB {\n\t\tsize\t\t2\n\t\tcount\t\t6\n\t\tdont_generate_debug_code\n\t}\n\tCMDSIZE_TABLE_TAIL {\n\t\tsize\t\t4\n\t}\n\t/*\n\t * Partial transfer past cacheline end to be\n\t * transferred using an extra S/G.\n\t */\n\tMWI_RESIDUAL {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * SCBID of the next SCB to be started by the controller.\n\t */\n\tNEXT_QUEUED_SCB {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * Single byte buffer used to designate the type or message\n\t * to send to a target.\n\t */\n\tMSG_OUT {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\t/* Parameters for DMA Logic */\n\tDMAPARAMS {\n\t\tsize\t\t1\n\t\tcount\t\t12\n\t\tfield\tPRELOADEN\t0x80\n\t\tfield\tWIDEODD\t\t0x40\n\t\tfield\tSCSIEN\t\t0x20\n\t\tfield\tSDMAEN\t\t0x10\n\t\tfield\tSDMAENACK\t0x10\n\t\tfield\tHDMAEN\t\t0x08\n\t\tfield\tHDMAENACK\t0x08\n\t\tfield\tDIRECTION\t0x04\t/* Set indicates PCI->SCSI */\n\t\tfield\tFIFOFLUSH\t0x02\n\t\tfield\tFIFORESET\t0x01\n\t\tdont_generate_debug_code\n\t}\n\tSEQ_FLAGS {\n\t\tsize\t\t1\n\t\tfield\tNOT_IDENTIFIED\t\t0x80\n\t\tfield\tNO_CDB_SENT\t\t0x40\n\t\tfield\tTARGET_CMD_IS_TAGGED\t0x40\n\t\tfield\tDPHASE\t\t\t0x20\n\t\t/* Target flags */\n\t\tfield\tTARG_CMD_PENDING\t0x10\n\t\tfield\tCMDPHASE_PENDING\t0x08\n\t\tfield\tDPHASE_PENDING\t\t0x04\n\t\tfield\tSPHASE_PENDING\t\t0x02\n\t\tfield\tNO_DISCONNECT\t\t0x01\n\t}\n\t/*\n\t * Temporary storage for the\n\t * target/channel/lun of a\n\t * reconnecting target\n\t */\n\tSAVED_SCSIID {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\tSAVED_LUN {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * The last bus phase as seen by the sequencer. \n\t */\n\tLASTPHASE {\n\t\tsize\t\t1\n\t\tfield\tCDI\t\t0x80\n\t\tfield\tIOI\t\t0x40\n\t\tfield\tMSGI\t\t0x20\n\t\tmask\tPHASE_MASK\tCDI|IOI|MSGI\n\t\tmask\tP_DATAOUT\t0x00\n\t\tmask\tP_DATAIN\tIOI\n\t\tmask\tP_COMMAND\tCDI\n\t\tmask\tP_MESGOUT\tCDI|MSGI\n\t\tmask\tP_STATUS\tCDI|IOI\n\t\tmask\tP_MESGIN\tCDI|IOI|MSGI\n\t\tmask\tP_BUSFREE\t0x01\n\t}\n\t/*\n\t * head of list of SCBs awaiting\n\t * selection\n\t */\n\tWAITING_SCBH {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * head of list of SCBs that are\n\t * disconnected.  Used for SCB\n\t * paging.\n\t */\n\tDISCONNECTED_SCBH {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * head of list of SCBs that are\n\t * not in use.  Used for SCB paging.\n\t */\n\tFREE_SCBH {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * head of list of SCBs that have\n\t * completed but have not been\n\t * put into the qoutfifo.\n\t */\n\tCOMPLETE_SCBH {\n\t\tsize\t\t1\n\t}\n\t/*\n\t * Address of the hardware scb array in the host.\n\t */\n\tHSCB_ADDR {\n\t\tsize\t\t4\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * Base address of our shared data with the kernel driver in host\n\t * memory.  This includes the qoutfifo and target mode\n\t * incoming command queue.\n\t */\n\tSHARED_DATA_ADDR {\n\t\tsize\t\t4\n\t\tdont_generate_debug_code\n\t}\n\tKERNEL_QINPOS {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\tQINPOS {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\tQOUTPOS {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\t/*\n\t * Kernel and sequencer offsets into the queue of\n\t * incoming target mode command descriptors.  The\n\t * queue is full when the KERNEL_TQINPOS == TQINPOS.\n\t */\n\tKERNEL_TQINPOS {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\tTQINPOS {\n\t\tsize\t\t1\n\t\tdont_generate_debug_code\n\t}\n\tARG_1 {\n\t\tsize\t\t1\n\t\tcount\t\t1\n\t\tmask\tSEND_MSG\t\t0x80\n\t\tmask\tSEND_SENSE\t\t0x40\n\t\tmask\tSEND_REJ\t\t0x20\n\t\tmask\tMSGOUT_PHASEMIS\t\t0x10\n\t\tmask\tEXIT_MSG_LOOP\t\t0x08\n\t\tmask\tCONT_MSG_LOOP\t\t0x04\n\t\tmask\tCONT_TARG_SESSION\t0x02\n\t\talias\tRETURN_1\n\t\tdont_generate_debug_code\n\t}\n\tARG_2 {\n\t\tsize\t\t1\n\t\talias\tRETURN_2\n\t\tdont_generate_debug_code\n\t}\n\n\t/*\n\t * Snapshot of MSG_OUT taken after each message is sent.\n\t */\n\tLAST_MSG {\n\t\tsize\t\t1\n\t\talias\tTARG_IMMEDIATE_SCB\n\t\tdont_generate_debug_code\n\t}\n\n\t/*\n\t * Sequences the kernel driver has okayed for us.  This allows\n\t * the driver to do things like prevent initiator or target\n\t * operations.\n\t */\n\tSCSISEQ_TEMPLATE {\n\t\tsize\t\t1\n\t\tfield\tENSELO\t\t0x40\n\t\tfield\tENSELI\t\t0x20\n\t\tfield\tENRSELI\t\t0x10\n\t\tfield\tENAUTOATNO\t0x08\n\t\tfield\tENAUTOATNI\t0x04\n\t\tfield\tENAUTOATNP\t0x02\n\t\tdont_generate_debug_code\n\t}\n}\n\nscratch_ram {\n\taddress\t\t0x056\n\tsize\t\t4\n\t/*\n\t * These scratch ram locations are initialized by the 274X BIOS.\n\t * We reuse them after capturing the BIOS settings during\n\t * initialization.\n\t */\n\n\t/*\n\t * The initiator specified tag for this target mode transaction.\n\t */\n\tHA_274_BIOSGLOBAL {\n\t\tsize\t1\n\t\tfield\tHA_274_EXTENDED_TRANS\t0x01\n\t\talias\tINITIATOR_TAG\n\t\tcount\t\t1\n\t\tdont_generate_debug_code\n\t}\n\n\tSEQ_FLAGS2 {\n\t\tsize\t1\n\t\tfield\tSCB_DMA\t\t\t0x01\n\t\tfield\tTARGET_MSG_PENDING\t0x02\n\t\tdont_generate_debug_code\n\t}\n}\n\nscratch_ram {\n\taddress\t\t0x05a\n\tsize\t\t6\n\t/*\n\t * These are reserved registers in the card's scratch ram on the 2742.\n\t * The EISA configuration chip is mapped here.  On Rev E. of the\n\t * aic7770, the sequencer can use this area for scratch, but the\n\t * host cannot directly access these registers.  On later chips, this\n\t * area can be read and written by both the host and the sequencer.\n\t * Even on later chips, many of these locations are initialized by\n\t * the BIOS.\n\t */\n\tSCSICONF {\n\t\tsize\t\t1\n\t\tcount\t\t12\n\t\tfield\tTERM_ENB\t0x80\n\t\tfield\tRESET_SCSI\t0x40\n\t\tfield\tENSPCHK\t\t0x20\n\t\tmask\tHSCSIID\t\t0x07\t/* our SCSI ID */\n\t\tmask\tHWSCSIID\t0x0f\t/* our SCSI ID if Wide Bus */\n\t\tdont_generate_debug_code\n\t}\n\tINTDEF {\n\t\taddress\t\t0x05c\n\t\tsize\t\t1\n\t\tcount\t\t1\n\t\tfield\tEDGE_TRIG\t0x80\n\t\tmask\tVECTOR\t\t0x0f\n\t\tdont_generate_debug_code\n\t}\n\tHOSTCONF {\n\t\taddress\t\t0x05d\n\t\tsize\t\t1\n\t\tcount\t\t1\n\t\tdont_generate_debug_code\n\t}\n\tHA_274_BIOSCTRL\t{\n\t\taddress\t\t0x05f\n\t\tsize\t\t1\n\t\tcount\t\t1\n\t\tmask\tBIOSMODE\t\t0x30\n\t\tmask\tBIOSDISABLED\t\t0x30\t\n\t\tfield\tCHANNEL_B_PRIMARY\t0x08\n\t\tdont_generate_debug_code\n\t}\n}\n\nscratch_ram {\n\taddress\t\t0x070\n\tsize\t\t16\n\n\t/*\n\t * Per target SCSI offset values for Ultra2 controllers.\n\t */\n\tTARG_OFFSET {\n\t\tsize\t\t16\n\t\tcount\t\t1\n\t\tdont_generate_debug_code\n\t}\n}\n\nconst TID_SHIFT\t\t4\nconst SCB_LIST_NULL\t0xff\nconst TARGET_CMD_CMPLT\t0xfe\n\nconst CCSGADDR_MAX\t0x80\nconst CCSGRAM_MAXSEGS\t16\n\n/* WDTR Message values */\nconst BUS_8_BIT\t\t\t0x00\nconst BUS_16_BIT\t\t0x01\nconst BUS_32_BIT\t\t0x02\n\n/* Offset maximums */\nconst MAX_OFFSET_8BIT\t\t0x0f\nconst MAX_OFFSET_16BIT\t\t0x08\nconst MAX_OFFSET_ULTRA2\t\t0x7f\nconst MAX_OFFSET\t\t0x7f\nconst HOST_MSG\t\t\t0xff\n\n/* Target mode command processing constants */\nconst CMD_GROUP_CODE_SHIFT\t0x05\n\nconst STATUS_BUSY\t\t0x08\nconst STATUS_QUEUE_FULL\t0x28\nconst TARGET_DATA_IN\t\t1\n\n/*\n * Downloaded (kernel inserted) constants\n */\n/* Offsets into the SCBID array where different data is stored */\nconst QOUTFIFO_OFFSET download\nconst QINFIFO_OFFSET download\nconst CACHESIZE_MASK download\nconst INVERTED_CACHESIZE_MASK download\nconst SG_PREFETCH_CNT download\nconst SG_PREFETCH_ALIGN_MASK download\nconst SG_PREFETCH_ADDR_MASK download\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}