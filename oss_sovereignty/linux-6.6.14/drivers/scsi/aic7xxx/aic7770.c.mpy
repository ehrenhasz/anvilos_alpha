{
  "module_name": "aic7770.c",
  "hash_id": "16138c64e853ec58d2d1e15bd67445ebce613ebe2a6d868b19f5515f23804292",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic7770.c",
  "human_readable_source": " \n\n#include \"aic7xxx_osm.h\"\n#include \"aic7xxx_inline.h\"\n#include \"aic7xxx_93cx6.h\"\n\n#define ID_AIC7770\t0x04907770\n#define ID_AHA_274x\t0x04907771\n#define ID_AHA_284xB\t0x04907756  \n#define ID_AHA_284x\t0x04907757  \n#define\tID_OLV_274x\t0x04907782  \n#define\tID_OLV_274xD\t0x04907783  \n\nstatic int aic7770_chip_init(struct ahc_softc *ahc);\nstatic int aha2840_load_seeprom(struct ahc_softc *ahc);\nstatic ahc_device_setup_t ahc_aic7770_VL_setup;\nstatic ahc_device_setup_t ahc_aic7770_EISA_setup;\nstatic ahc_device_setup_t ahc_aic7770_setup;\n\nstruct aic7770_identity aic7770_ident_table[] =\n{\n\t{\n\t\tID_AHA_274x,\n\t\t0xFFFFFFFF,\n\t\t\"Adaptec 274X SCSI adapter\",\n\t\tahc_aic7770_EISA_setup\n\t},\n\t{\n\t\tID_AHA_284xB,\n\t\t0xFFFFFFFE,\n\t\t\"Adaptec 284X SCSI adapter\",\n\t\tahc_aic7770_VL_setup\n\t},\n\t{\n\t\tID_AHA_284x,\n\t\t0xFFFFFFFE,\n\t\t\"Adaptec 284X SCSI adapter (BIOS Disabled)\",\n\t\tahc_aic7770_VL_setup\n\t},\n\t{\n\t\tID_OLV_274x,\n\t\t0xFFFFFFFF,\n\t\t\"Adaptec (Olivetti OEM) 274X SCSI adapter\",\n\t\tahc_aic7770_EISA_setup\n\t},\n\t{\n\t\tID_OLV_274xD,\n\t\t0xFFFFFFFF,\n\t\t\"Adaptec (Olivetti OEM) 274X Differential SCSI adapter\",\n\t\tahc_aic7770_EISA_setup\n\t},\n\t \n\t{\n\t\tID_AIC7770,\n\t\t0xFFFFFFFF,\n\t\t\"Adaptec aic7770 SCSI adapter\",\n\t\tahc_aic7770_EISA_setup\n\t}\n};\nconst int ahc_num_aic7770_devs = ARRAY_SIZE(aic7770_ident_table);\n\nstruct aic7770_identity *\naic7770_find_device(uint32_t id)\n{\n\tstruct\taic7770_identity *entry;\n\tint\ti;\n\n\tfor (i = 0; i < ahc_num_aic7770_devs; i++) {\n\t\tentry = &aic7770_ident_table[i];\n\t\tif (entry->full_id == (id & entry->id_mask))\n\t\t\treturn (entry);\n\t}\n\treturn (NULL);\n}\n\nint\naic7770_config(struct ahc_softc *ahc, struct aic7770_identity *entry, u_int io)\n{\n\tint\terror;\n\tint\thave_seeprom;\n\tu_int\thostconf;\n\tu_int   irq;\n\tu_int\tintdef;\n\n\terror = entry->setup(ahc);\n\thave_seeprom = 0;\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = aic7770_map_registers(ahc, io);\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\tahc_intr_enable(ahc, FALSE);\n\n\tahc->description = entry->name;\n\terror = ahc_softc_init(ahc);\n\tif (error != 0)\n\t\treturn (error);\n\n\tahc->bus_chip_init = aic7770_chip_init;\n\n\terror = ahc_reset(ahc,  FALSE);\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\tintdef = ahc_inb(ahc, INTDEF);\n\tirq = intdef & VECTOR;\n\tswitch (irq) {\n\tcase 9:\n\tcase 10:\n\tcase 11:\n\tcase 12:\n\tcase 14:\n\tcase 15:\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"aic7770_config: invalid irq setting %d\\n\", intdef);\n\t\treturn (ENXIO);\n\t}\n\n\tif ((intdef & EDGE_TRIG) != 0)\n\t\tahc->flags |= AHC_EDGE_INTERRUPT;\n\n\tswitch (ahc->chip & (AHC_EISA|AHC_VL)) {\n\tcase AHC_EISA:\n\t{\n\t\tu_int biosctrl;\n\t\tu_int scsiconf;\n\t\tu_int scsiconf1;\n\n\t\tbiosctrl = ahc_inb(ahc, HA_274_BIOSCTRL);\n\t\tscsiconf = ahc_inb(ahc, SCSICONF);\n\t\tscsiconf1 = ahc_inb(ahc, SCSICONF + 1);\n\n\t\t \n\t\tif ((biosctrl & CHANNEL_B_PRIMARY) != 0)\n\t\t\tahc->flags |= 1;\n\n\t\tif ((biosctrl & BIOSMODE) == BIOSDISABLED) {\n\t\t\tahc->flags |= AHC_USEDEFAULTS;\n\t\t} else {\n\t\t\tif ((ahc->features & AHC_WIDE) != 0) {\n\t\t\t\tahc->our_id = scsiconf1 & HWSCSIID;\n\t\t\t\tif (scsiconf & TERM_ENB)\n\t\t\t\t\tahc->flags |= AHC_TERM_ENB_A;\n\t\t\t} else {\n\t\t\t\tahc->our_id = scsiconf & HSCSIID;\n\t\t\t\tahc->our_id_b = scsiconf1 & HSCSIID;\n\t\t\t\tif (scsiconf & TERM_ENB)\n\t\t\t\t\tahc->flags |= AHC_TERM_ENB_A;\n\t\t\t\tif (scsiconf1 & TERM_ENB)\n\t\t\t\t\tahc->flags |= AHC_TERM_ENB_B;\n\t\t\t}\n\t\t}\n\t\tif ((ahc_inb(ahc, HA_274_BIOSGLOBAL) & HA_274_EXTENDED_TRANS))\n\t\t\tahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B;\n\t\tbreak;\n\t}\n\tcase AHC_VL:\n\t{\n\t\thave_seeprom = aha2840_load_seeprom(ahc);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tif (have_seeprom == 0) {\n\t\tkfree(ahc->seep_config);\n\t\tahc->seep_config = NULL;\n\t}\n\n\t \n\tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~AUTOFLUSHDIS);\n\n\t \n\thostconf = ahc_inb(ahc, HOSTCONF);\n\tahc_outb(ahc, BUSSPD, hostconf & DFTHRSH);\n\tahc_outb(ahc, BUSTIME, (hostconf << 2) & BOFF);\n\n\tahc->bus_softc.aic7770_softc.busspd = hostconf & DFTHRSH;\n\tahc->bus_softc.aic7770_softc.bustime = (hostconf << 2) & BOFF;\n\n\t \n\terror = ahc_init(ahc);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = aic7770_map_int(ahc, irq);\n\tif (error != 0)\n\t\treturn (error);\n\n\tahc->init_level++;\n\n\t \n\tahc_outb(ahc, BCTL, ENABLE);\n\treturn (0);\n}\n\nstatic int\naic7770_chip_init(struct ahc_softc *ahc)\n{\n\tahc_outb(ahc, BUSSPD, ahc->bus_softc.aic7770_softc.busspd);\n\tahc_outb(ahc, BUSTIME, ahc->bus_softc.aic7770_softc.bustime);\n\tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~AUTOFLUSHDIS);\n\tahc_outb(ahc, BCTL, ENABLE);\n\treturn (ahc_chip_init(ahc));\n}\n\n \nstatic int\naha2840_load_seeprom(struct ahc_softc *ahc)\n{\n\tstruct\tseeprom_descriptor sd;\n\tstruct\tseeprom_config *sc;\n\tint\thave_seeprom;\n\tuint8_t scsi_conf;\n\n\tsd.sd_ahc = ahc;\n\tsd.sd_control_offset = SEECTL_2840;\n\tsd.sd_status_offset = STATUS_2840;\n\tsd.sd_dataout_offset = STATUS_2840;\t\t\n\tsd.sd_chip = C46;\n\tsd.sd_MS = 0;\n\tsd.sd_RDY = EEPROM_TF;\n\tsd.sd_CS = CS_2840;\n\tsd.sd_CK = CK_2840;\n\tsd.sd_DO = DO_2840;\n\tsd.sd_DI = DI_2840;\n\tsc = ahc->seep_config;\n\n\tif (bootverbose)\n\t\tprintk(\"%s: Reading SEEPROM...\", ahc_name(ahc));\n\thave_seeprom = ahc_read_seeprom(&sd, (uint16_t *)sc,\n\t\t\t\t\t 0, sizeof(*sc)/2);\n\n\tif (have_seeprom) {\n\n\t\tif (ahc_verify_cksum(sc) == 0) {\n\t\t\tif(bootverbose)\n\t\t\t\tprintk (\"checksum error\\n\");\n\t\t\thave_seeprom = 0;\n\t\t} else if (bootverbose) {\n\t\t\tprintk(\"done.\\n\");\n\t\t}\n\t}\n\n\tif (!have_seeprom) {\n\t\tif (bootverbose)\n\t\t\tprintk(\"%s: No SEEPROM available\\n\", ahc_name(ahc));\n\t\tahc->flags |= AHC_USEDEFAULTS;\n\t} else {\n\t\t \n\t\tint\t i;\n\t\tint\t max_targ;\n\t\tuint16_t discenable;\n\n\t\tmax_targ = (ahc->features & AHC_WIDE) != 0 ? 16 : 8;\n\t\tdiscenable = 0;\n\t\tfor (i = 0; i < max_targ; i++){\n\t\t\tuint8_t target_settings;\n\n\t\t\ttarget_settings = (sc->device_flags[i] & CFXFER) << 4;\n\t\t\tif (sc->device_flags[i] & CFSYNCH)\n\t\t\t\ttarget_settings |= SOFS;\n\t\t\tif (sc->device_flags[i] & CFWIDEB)\n\t\t\t\ttarget_settings |= WIDEXFER;\n\t\t\tif (sc->device_flags[i] & CFDISC)\n\t\t\t\tdiscenable |= (0x01 << i);\n\t\t\tahc_outb(ahc, TARG_SCSIRATE + i, target_settings);\n\t\t}\n\t\tahc_outb(ahc, DISC_DSB, ~(discenable & 0xff));\n\t\tahc_outb(ahc, DISC_DSB + 1, ~((discenable >> 8) & 0xff));\n\n\t\tahc->our_id = sc->brtime_id & CFSCSIID;\n\n\t\tscsi_conf = (ahc->our_id & 0x7);\n\t\tif (sc->adapter_control & CFSPARITY)\n\t\t\tscsi_conf |= ENSPCHK;\n\t\tif (sc->adapter_control & CFRESETB)\n\t\t\tscsi_conf |= RESET_SCSI;\n\n\t\tif (sc->bios_control & CF284XEXTEND)\t\t\n\t\t\tahc->flags |= AHC_EXTENDED_TRANS_A;\n\t\t \n\t\tahc_outb(ahc, SCSICONF, scsi_conf);\n\n\t\tif (sc->adapter_control & CF284XSTERM)\n\t\t\tahc->flags |= AHC_TERM_ENB_A;\n\t}\n\treturn (have_seeprom);\n}\n\nstatic int\nahc_aic7770_VL_setup(struct ahc_softc *ahc)\n{\n\tint error;\n\n\terror = ahc_aic7770_setup(ahc);\n\tahc->chip |= AHC_VL;\n\treturn (error);\n}\n\nstatic int\nahc_aic7770_EISA_setup(struct ahc_softc *ahc)\n{\n\tint error;\n\n\terror = ahc_aic7770_setup(ahc);\n\tahc->chip |= AHC_EISA;\n\treturn (error);\n}\n\nstatic int\nahc_aic7770_setup(struct ahc_softc *ahc)\n{\n\tahc->channel = 'A';\n\tahc->channel_b = 'B';\n\tahc->chip = AHC_AIC7770;\n\tahc->features = AHC_AIC7770_FE;\n\tahc->bugs |= AHC_TMODE_WIDEODD_BUG;\n\tahc->flags |= AHC_PAGESCBS;\n\tahc->instruction_ram_size = 448;\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}