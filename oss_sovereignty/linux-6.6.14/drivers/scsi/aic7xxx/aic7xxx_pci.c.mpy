{
  "module_name": "aic7xxx_pci.c",
  "hash_id": "da8f54d0427796309b7b8074af6da8cbee49700eff60bbcd0258010a7d7317c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic7xxx_pci.c",
  "human_readable_source": " \n\n#include \"aic7xxx_osm.h\"\n#include \"aic7xxx_inline.h\"\n#include \"aic7xxx_93cx6.h\"\n#include \"aic7xxx_pci.h\"\n\nstatic inline uint64_t\nahc_compose_id(u_int device, u_int vendor, u_int subdevice, u_int subvendor)\n{\n\tuint64_t id;\n\n\tid = subvendor\n\t   | (subdevice << 16)\n\t   | ((uint64_t)vendor << 32)\n\t   | ((uint64_t)device << 48);\n\n\treturn (id);\n}\n\n#define AHC_PCI_IOADDR\tPCIR_MAPS\t \n#define AHC_PCI_MEMADDR\t(PCIR_MAPS + 4)\t \n\n#define DEVID_9005_TYPE(id) ((id) & 0xF)\n#define\t\tDEVID_9005_TYPE_HBA\t\t0x0\t \n#define\t\tDEVID_9005_TYPE_AAA\t\t0x3\t \n#define\t\tDEVID_9005_TYPE_SISL\t\t0x5\t \n#define\t\tDEVID_9005_TYPE_MB\t\t0xF\t \n\n#define DEVID_9005_MAXRATE(id) (((id) & 0x30) >> 4)\n#define\t\tDEVID_9005_MAXRATE_U160\t\t0x0\n#define\t\tDEVID_9005_MAXRATE_ULTRA2\t0x1\n#define\t\tDEVID_9005_MAXRATE_ULTRA\t0x2\n#define\t\tDEVID_9005_MAXRATE_FAST\t\t0x3\n\n#define DEVID_9005_MFUNC(id) (((id) & 0x40) >> 6)\n\n#define DEVID_9005_CLASS(id) (((id) & 0xFF00) >> 8)\n#define\t\tDEVID_9005_CLASS_SPI\t\t0x0\t \n\n#define SUBID_9005_TYPE(id) ((id) & 0xF)\n#define\t\tSUBID_9005_TYPE_MB\t\t0xF\t \n#define\t\tSUBID_9005_TYPE_CARD\t\t0x0\t \n#define\t\tSUBID_9005_TYPE_LCCARD\t\t0x1\t \n#define\t\tSUBID_9005_TYPE_RAID\t\t0x3\t \n\n#define SUBID_9005_TYPE_KNOWN(id)\t\t\t\\\n\t  ((((id) & 0xF) == SUBID_9005_TYPE_MB)\t\t\\\n\t|| (((id) & 0xF) == SUBID_9005_TYPE_CARD)\t\\\n\t|| (((id) & 0xF) == SUBID_9005_TYPE_LCCARD)\t\\\n\t|| (((id) & 0xF) == SUBID_9005_TYPE_RAID))\n\n#define SUBID_9005_MAXRATE(id) (((id) & 0x30) >> 4)\n#define\t\tSUBID_9005_MAXRATE_ULTRA2\t0x0\n#define\t\tSUBID_9005_MAXRATE_ULTRA\t0x1\n#define\t\tSUBID_9005_MAXRATE_U160\t\t0x2\n#define\t\tSUBID_9005_MAXRATE_RESERVED\t0x3\n\n#define SUBID_9005_SEEPTYPE(id)\t\t\t\t\t\t\\\n\t((SUBID_9005_TYPE(id) == SUBID_9005_TYPE_MB)\t\t\t\\\n\t ? ((id) & 0xC0) >> 6\t\t\t\t\t\t\\\n\t : ((id) & 0x300) >> 8)\n#define\t\tSUBID_9005_SEEPTYPE_NONE\t0x0\n#define\t\tSUBID_9005_SEEPTYPE_1K\t\t0x1\n#define\t\tSUBID_9005_SEEPTYPE_2K_4K\t0x2\n#define\t\tSUBID_9005_SEEPTYPE_RESERVED\t0x3\n#define SUBID_9005_AUTOTERM(id)\t\t\t\t\t\t\\\n\t((SUBID_9005_TYPE(id) == SUBID_9005_TYPE_MB)\t\t\t\\\n\t ? (((id) & 0x400) >> 10) == 0\t\t\t\t\t\\\n\t : (((id) & 0x40) >> 6) == 0)\n\n#define SUBID_9005_NUMCHAN(id)\t\t\t\t\t\t\\\n\t((SUBID_9005_TYPE(id) == SUBID_9005_TYPE_MB)\t\t\t\\\n\t ? ((id) & 0x300) >> 8\t\t\t\t\t\t\\\n\t : ((id) & 0xC00) >> 10)\n\n#define SUBID_9005_LEGACYCONN(id)\t\t\t\t\t\\\n\t((SUBID_9005_TYPE(id) == SUBID_9005_TYPE_MB)\t\t\t\\\n\t ? 0\t\t\t\t\t\t\t\t\\\n\t : ((id) & 0x80) >> 7)\n\n#define SUBID_9005_MFUNCENB(id)\t\t\t\t\t\t\\\n\t((SUBID_9005_TYPE(id) == SUBID_9005_TYPE_MB)\t\t\t\\\n\t ? ((id) & 0x800) >> 11\t\t\t\t\t\t\\\n\t : ((id) & 0x1000) >> 12)\n \n#define SUBID_9005_CARD_SCSIWIDTH_MASK\t0x2000\n#define SUBID_9005_CARD_PCIWIDTH_MASK\t0x4000\n#define SUBID_9005_CARD_SEDIFF_MASK\t0x8000\n\nstatic ahc_device_setup_t ahc_aic785X_setup;\nstatic ahc_device_setup_t ahc_aic7860_setup;\nstatic ahc_device_setup_t ahc_apa1480_setup;\nstatic ahc_device_setup_t ahc_aic7870_setup;\nstatic ahc_device_setup_t ahc_aic7870h_setup;\nstatic ahc_device_setup_t ahc_aha394X_setup;\nstatic ahc_device_setup_t ahc_aha394Xh_setup;\nstatic ahc_device_setup_t ahc_aha494X_setup;\nstatic ahc_device_setup_t ahc_aha494Xh_setup;\nstatic ahc_device_setup_t ahc_aha398X_setup;\nstatic ahc_device_setup_t ahc_aic7880_setup;\nstatic ahc_device_setup_t ahc_aic7880h_setup;\nstatic ahc_device_setup_t ahc_aha2940Pro_setup;\nstatic ahc_device_setup_t ahc_aha394XU_setup;\nstatic ahc_device_setup_t ahc_aha394XUh_setup;\nstatic ahc_device_setup_t ahc_aha398XU_setup;\nstatic ahc_device_setup_t ahc_aic7890_setup;\nstatic ahc_device_setup_t ahc_aic7892_setup;\nstatic ahc_device_setup_t ahc_aic7895_setup;\nstatic ahc_device_setup_t ahc_aic7895h_setup;\nstatic ahc_device_setup_t ahc_aic7896_setup;\nstatic ahc_device_setup_t ahc_aic7899_setup;\nstatic ahc_device_setup_t ahc_aha29160C_setup;\nstatic ahc_device_setup_t ahc_raid_setup;\nstatic ahc_device_setup_t ahc_aha394XX_setup;\nstatic ahc_device_setup_t ahc_aha494XX_setup;\nstatic ahc_device_setup_t ahc_aha398XX_setup;\n\nstatic const struct ahc_pci_identity ahc_pci_ident_table[] = {\n\t \n\t{\n\t\tID_AHA_2902_04_10_15_20C_30C,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 2902/04/10/15/20C/30C SCSI adapter\",\n\t\tahc_aic785X_setup\n\t},\n\t \n\t{\n\t\tID_AHA_2930CU,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 2930CU SCSI adapter\",\n\t\tahc_aic7860_setup\n\t},\n\t{\n\t\tID_AHA_1480A & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec 1480A Ultra SCSI adapter\",\n\t\tahc_apa1480_setup\n\t},\n\t{\n\t\tID_AHA_2940AU_0 & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec 2940A Ultra SCSI adapter\",\n\t\tahc_aic7860_setup\n\t},\n\t{\n\t\tID_AHA_2940AU_CN & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec 2940A/CN Ultra SCSI adapter\",\n\t\tahc_aic7860_setup\n\t},\n\t{\n\t\tID_AHA_2930C_VAR & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec 2930C Ultra SCSI adapter (VAR)\",\n\t\tahc_aic7860_setup\n\t},\n\t \n\t{\n\t\tID_AHA_2940,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 2940 SCSI adapter\",\n\t\tahc_aic7870_setup\n\t},\n\t{\n\t\tID_AHA_3940,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 3940 SCSI adapter\",\n\t\tahc_aha394X_setup\n\t},\n\t{\n\t\tID_AHA_398X,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 398X SCSI RAID adapter\",\n\t\tahc_aha398X_setup\n\t},\n\t{\n\t\tID_AHA_2944,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 2944 SCSI adapter\",\n\t\tahc_aic7870h_setup\n\t},\n\t{\n\t\tID_AHA_3944,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 3944 SCSI adapter\",\n\t\tahc_aha394Xh_setup\n\t},\n\t{\n\t\tID_AHA_4944,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 4944 SCSI adapter\",\n\t\tahc_aha494Xh_setup\n\t},\n\t \n\t{\n\t\tID_AHA_2940U & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec 2940 Ultra SCSI adapter\",\n\t\tahc_aic7880_setup\n\t},\n\t{\n\t\tID_AHA_3940U & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec 3940 Ultra SCSI adapter\",\n\t\tahc_aha394XU_setup\n\t},\n\t{\n\t\tID_AHA_2944U & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec 2944 Ultra SCSI adapter\",\n\t\tahc_aic7880h_setup\n\t},\n\t{\n\t\tID_AHA_3944U & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec 3944 Ultra SCSI adapter\",\n\t\tahc_aha394XUh_setup\n\t},\n\t{\n\t\tID_AHA_398XU & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec 398X Ultra SCSI RAID adapter\",\n\t\tahc_aha398XU_setup\n\t},\n\t{\n\t\t \n\t\tID_AHA_4944U & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec 4944 Ultra SCSI adapter\",\n\t\tahc_aic7880h_setup\n\t},\n\t{\n\t\tID_AHA_2930U & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec 2930 Ultra SCSI adapter\",\n\t\tahc_aic7880_setup\n\t},\n\t{\n\t\tID_AHA_2940U_PRO & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec 2940 Pro Ultra SCSI adapter\",\n\t\tahc_aha2940Pro_setup\n\t},\n\t{\n\t\tID_AHA_2940U_CN & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec 2940/CN Ultra SCSI adapter\",\n\t\tahc_aic7880_setup\n\t},\n\t \n\t{\n\t\tID_9005_SISL_ID,\n\t\tID_9005_SISL_MASK,\n\t\tNULL,\n\t\tNULL\n\t},\n\t \n\t{\n\t\tID_AHA_2930U2,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 2930 Ultra2 SCSI adapter\",\n\t\tahc_aic7890_setup\n\t},\n\t{\n\t\tID_AHA_2940U2B,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 2940B Ultra2 SCSI adapter\",\n\t\tahc_aic7890_setup\n\t},\n\t{\n\t\tID_AHA_2940U2_OEM,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 2940 Ultra2 SCSI adapter (OEM)\",\n\t\tahc_aic7890_setup\n\t},\n\t{\n\t\tID_AHA_2940U2,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 2940 Ultra2 SCSI adapter\",\n\t\tahc_aic7890_setup\n\t},\n\t{\n\t\tID_AHA_2950U2B,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 2950 Ultra2 SCSI adapter\",\n\t\tahc_aic7890_setup\n\t},\n\t{\n\t\tID_AIC7890_ARO,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec aic7890/91 Ultra2 SCSI adapter (ARO)\",\n\t\tahc_aic7890_setup\n\t},\n\t{\n\t\tID_AAA_131U2,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec AAA-131 Ultra2 RAID adapter\",\n\t\tahc_aic7890_setup\n\t},\n\t \n\t{\n\t\tID_AHA_29160,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 29160 Ultra160 SCSI adapter\",\n\t\tahc_aic7892_setup\n\t},\n\t{\n\t\tID_AHA_29160_CPQ,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec (Compaq OEM) 29160 Ultra160 SCSI adapter\",\n\t\tahc_aic7892_setup\n\t},\n\t{\n\t\tID_AHA_29160N,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 29160N Ultra160 SCSI adapter\",\n\t\tahc_aic7892_setup\n\t},\n\t{\n\t\tID_AHA_29160C,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 29160C Ultra160 SCSI adapter\",\n\t\tahc_aha29160C_setup\n\t},\n\t{\n\t\tID_AHA_29160B,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 29160B Ultra160 SCSI adapter\",\n\t\tahc_aic7892_setup\n\t},\n\t{\n\t\tID_AHA_19160B,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 19160B Ultra160 SCSI adapter\",\n\t\tahc_aic7892_setup\n\t},\n\t{\n\t\tID_AIC7892_ARO,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec aic7892 Ultra160 SCSI adapter (ARO)\",\n\t\tahc_aic7892_setup\n\t},\n\t{\n\t\tID_AHA_2915_30LP,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 2915/30LP Ultra160 SCSI adapter\",\n\t\tahc_aic7892_setup\n\t},\n\t \t\n\t{\n\t\tID_AHA_2940U_DUAL,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 2940/DUAL Ultra SCSI adapter\",\n\t\tahc_aic7895_setup\n\t},\n\t{\n\t\tID_AHA_3940AU,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 3940A Ultra SCSI adapter\",\n\t\tahc_aic7895_setup\n\t},\n\t{\n\t\tID_AHA_3944AU,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 3944A Ultra SCSI adapter\",\n\t\tahc_aic7895h_setup\n\t},\n\t{\n\t\tID_AIC7895_ARO,\n\t\tID_AIC7895_ARO_MASK,\n\t\t\"Adaptec aic7895 Ultra SCSI adapter (ARO)\",\n\t\tahc_aic7895_setup\n\t},\n\t \t\n\t{\n\t\tID_AHA_3950U2B_0,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 3950B Ultra2 SCSI adapter\",\n\t\tahc_aic7896_setup\n\t},\n\t{\n\t\tID_AHA_3950U2B_1,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 3950B Ultra2 SCSI adapter\",\n\t\tahc_aic7896_setup\n\t},\n\t{\n\t\tID_AHA_3950U2D_0,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 3950D Ultra2 SCSI adapter\",\n\t\tahc_aic7896_setup\n\t},\n\t{\n\t\tID_AHA_3950U2D_1,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 3950D Ultra2 SCSI adapter\",\n\t\tahc_aic7896_setup\n\t},\n\t{\n\t\tID_AIC7896_ARO,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec aic7896/97 Ultra2 SCSI adapter (ARO)\",\n\t\tahc_aic7896_setup\n\t},\n\t \t\n\t{\n\t\tID_AHA_3960D,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec 3960D Ultra160 SCSI adapter\",\n\t\tahc_aic7899_setup\n\t},\n\t{\n\t\tID_AHA_3960D_CPQ,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec (Compaq OEM) 3960D Ultra160 SCSI adapter\",\n\t\tahc_aic7899_setup\n\t},\n\t{\n\t\tID_AIC7899_ARO,\n\t\tID_ALL_MASK,\n\t\t\"Adaptec aic7899 Ultra160 SCSI adapter (ARO)\",\n\t\tahc_aic7899_setup\n\t},\n\t \n\t{\n\t\tID_AIC7850 & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec aic7850 SCSI adapter\",\n\t\tahc_aic785X_setup\n\t},\n\t{\n\t\tID_AIC7855 & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec aic7855 SCSI adapter\",\n\t\tahc_aic785X_setup\n\t},\n\t{\n\t\tID_AIC7859 & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec aic7859 SCSI adapter\",\n\t\tahc_aic7860_setup\n\t},\n\t{\n\t\tID_AIC7860 & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec aic7860 Ultra SCSI adapter\",\n\t\tahc_aic7860_setup\n\t},\n\t{\n\t\tID_AIC7870 & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec aic7870 SCSI adapter\",\n\t\tahc_aic7870_setup\n\t},\n\t{\n\t\tID_AIC7880 & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec aic7880 Ultra SCSI adapter\",\n\t\tahc_aic7880_setup\n\t},\n\t{\n\t\tID_AIC7890 & ID_9005_GENERIC_MASK,\n\t\tID_9005_GENERIC_MASK,\n\t\t\"Adaptec aic7890/91 Ultra2 SCSI adapter\",\n\t\tahc_aic7890_setup\n\t},\n\t{\n\t\tID_AIC7892 & ID_9005_GENERIC_MASK,\n\t\tID_9005_GENERIC_MASK,\n\t\t\"Adaptec aic7892 Ultra160 SCSI adapter\",\n\t\tahc_aic7892_setup\n\t},\n\t{\n\t\tID_AIC7895 & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec aic7895 Ultra SCSI adapter\",\n\t\tahc_aic7895_setup\n\t},\n\t{\n\t\tID_AIC7896 & ID_9005_GENERIC_MASK,\n\t\tID_9005_GENERIC_MASK,\n\t\t\"Adaptec aic7896/97 Ultra2 SCSI adapter\",\n\t\tahc_aic7896_setup\n\t},\n\t{\n\t\tID_AIC7899 & ID_9005_GENERIC_MASK,\n\t\tID_9005_GENERIC_MASK,\n\t\t\"Adaptec aic7899 Ultra160 SCSI adapter\",\n\t\tahc_aic7899_setup\n\t},\n\t{\n\t\tID_AIC7810 & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec aic7810 RAID memory controller\",\n\t\tahc_raid_setup\n\t},\n\t{\n\t\tID_AIC7815 & ID_DEV_VENDOR_MASK,\n\t\tID_DEV_VENDOR_MASK,\n\t\t\"Adaptec aic7815 RAID memory controller\",\n\t\tahc_raid_setup\n\t}\n};\n\nstatic const u_int ahc_num_pci_devs = ARRAY_SIZE(ahc_pci_ident_table);\n\t\t\n#define AHC_394X_SLOT_CHANNEL_A\t4\n#define AHC_394X_SLOT_CHANNEL_B\t5\n\n#define AHC_398X_SLOT_CHANNEL_A\t4\n#define AHC_398X_SLOT_CHANNEL_B\t8\n#define AHC_398X_SLOT_CHANNEL_C\t12\n\n#define AHC_494X_SLOT_CHANNEL_A\t4\n#define AHC_494X_SLOT_CHANNEL_B\t5\n#define AHC_494X_SLOT_CHANNEL_C\t6\n#define AHC_494X_SLOT_CHANNEL_D\t7\n\n#define\tDEVCONFIG\t\t0x40\n#define\t\tPCIERRGENDIS\t0x80000000ul\n#define\t\tSCBSIZE32\t0x00010000ul\t \n#define\t\tREXTVALID\t0x00001000ul\t \n#define\t\tMPORTMODE\t0x00000400ul\t \n#define\t\tRAMPSM\t\t0x00000200ul\t \n#define\t\tVOLSENSE\t0x00000100ul\n#define\t\tPCI64BIT\t0x00000080ul\t \n#define\t\tSCBRAMSEL\t0x00000080ul\n#define\t\tMRDCEN\t\t0x00000040ul\n#define\t\tEXTSCBTIME\t0x00000020ul\t \n#define\t\tEXTSCBPEN\t0x00000010ul\t \n#define\t\tBERREN\t\t0x00000008ul\n#define\t\tDACEN\t\t0x00000004ul\n#define\t\tSTPWLEVEL\t0x00000002ul\n#define\t\tDIFACTNEGEN\t0x00000001ul\t \n\n#define\tCSIZE_LATTIME\t\t0x0c\n#define\t\tCACHESIZE\t0x0000003ful\t \n#define\t\tLATTIME\t\t0x0000ff00ul\n\n \n#define\tDPE\t0x80\n#define SSE\t0x40\n#define\tRMA\t0x20\n#define\tRTA\t0x10\n#define STA\t0x08\n#define DPR\t0x01\n\nstatic int ahc_9005_subdevinfo_valid(uint16_t device, uint16_t vendor,\n\t\t\t\t     uint16_t subdevice, uint16_t subvendor);\nstatic int ahc_ext_scbram_present(struct ahc_softc *ahc);\nstatic void ahc_scbram_config(struct ahc_softc *ahc, int enable,\n\t\t\t\t  int pcheck, int fast, int large);\nstatic void ahc_probe_ext_scbram(struct ahc_softc *ahc);\nstatic void check_extport(struct ahc_softc *ahc, u_int *sxfrctl1);\nstatic void ahc_parse_pci_eeprom(struct ahc_softc *ahc,\n\t\t\t\t struct seeprom_config *sc);\nstatic void configure_termination(struct ahc_softc *ahc,\n\t\t\t\t  struct seeprom_descriptor *sd,\n\t\t\t\t  u_int adapter_control,\n\t \t\t\t  u_int *sxfrctl1);\n\nstatic void ahc_new_term_detect(struct ahc_softc *ahc,\n\t\t\t\tint *enableSEC_low,\n\t\t\t\tint *enableSEC_high,\n\t\t\t\tint *enablePRI_low,\n\t\t\t\tint *enablePRI_high,\n\t\t\t\tint *eeprom_present);\nstatic void aic787X_cable_detect(struct ahc_softc *ahc, int *internal50_present,\n\t\t\t\t int *internal68_present,\n\t\t\t\t int *externalcable_present,\n\t\t\t\t int *eeprom_present);\nstatic void aic785X_cable_detect(struct ahc_softc *ahc, int *internal50_present,\n\t\t\t\t int *externalcable_present,\n\t\t\t\t int *eeprom_present);\nstatic void    write_brdctl(struct ahc_softc *ahc, uint8_t value);\nstatic uint8_t read_brdctl(struct ahc_softc *ahc);\nstatic void ahc_pci_intr(struct ahc_softc *ahc);\nstatic int  ahc_pci_chip_init(struct ahc_softc *ahc);\n\nstatic int\nahc_9005_subdevinfo_valid(uint16_t device, uint16_t vendor,\n\t\t\t  uint16_t subdevice, uint16_t subvendor)\n{\n\tint result;\n\n\t \n\tresult = 0;\n\tif (vendor == 0x9005\n\t && subvendor == 0x9005\n         && subdevice != device\n         && SUBID_9005_TYPE_KNOWN(subdevice) != 0) {\n\n\t\tswitch (SUBID_9005_TYPE(subdevice)) {\n\t\tcase SUBID_9005_TYPE_MB:\n\t\t\tbreak;\n\t\tcase SUBID_9005_TYPE_CARD:\n\t\tcase SUBID_9005_TYPE_LCCARD:\n\t\t\t \n\t\t\tif (DEVID_9005_TYPE(device) == DEVID_9005_TYPE_HBA)\n\t\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase SUBID_9005_TYPE_RAID:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (result);\n}\n\nconst struct ahc_pci_identity *\nahc_find_pci_device(ahc_dev_softc_t pci)\n{\n\tuint64_t  full_id;\n\tuint16_t  device;\n\tuint16_t  vendor;\n\tuint16_t  subdevice;\n\tuint16_t  subvendor;\n\tconst struct ahc_pci_identity *entry;\n\tu_int\t  i;\n\n\tvendor = ahc_pci_read_config(pci, PCIR_DEVVENDOR,  2);\n\tdevice = ahc_pci_read_config(pci, PCIR_DEVICE,  2);\n\tsubvendor = ahc_pci_read_config(pci, PCI_SUBSYSTEM_VENDOR_ID,  2);\n\tsubdevice = ahc_pci_read_config(pci, PCI_SUBSYSTEM_ID,  2);\n\tfull_id = ahc_compose_id(device, vendor, subdevice, subvendor);\n\n\t \n\tif (ahc_get_pci_function(pci) > 0\n\t && ahc_9005_subdevinfo_valid(device, vendor, subdevice, subvendor)\n\t && SUBID_9005_MFUNCENB(subdevice) == 0)\n\t\treturn (NULL);\n\n\tfor (i = 0; i < ahc_num_pci_devs; i++) {\n\t\tentry = &ahc_pci_ident_table[i];\n\t\tif (entry->full_id == (full_id & entry->id_mask)) {\n\t\t\t \n\t\t\tif (entry->name == NULL)\n\t\t\t\treturn (NULL);\n\t\t\treturn (entry);\n\t\t}\n\t}\n\treturn (NULL);\n}\n\nint\nahc_pci_config(struct ahc_softc *ahc, const struct ahc_pci_identity *entry)\n{\n\tu_int\t command;\n\tu_int\t our_id;\n\tu_int\t sxfrctl1;\n\tu_int\t scsiseq;\n\tu_int\t dscommand0;\n\tuint32_t devconfig;\n\tint\t error;\n\tuint8_t\t sblkctl;\n\n\tour_id = 0;\n\terror = entry->setup(ahc);\n\tif (error != 0)\n\t\treturn (error);\n\tahc->chip |= AHC_PCI;\n\tahc->description = entry->name;\n\n\tpci_set_power_state(ahc->dev_softc, AHC_POWER_STATE_D0);\n\n\terror = ahc_pci_map_registers(ahc);\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\tahc_intr_enable(ahc, FALSE);\n\n\tdevconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG,  4);\n\n\t \n\tif ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {\n\n\t\tif (bootverbose)\n\t\t\tprintk(\"%s: Enabling 39Bit Addressing\\n\",\n\t\t\t       ahc_name(ahc));\n\t\tdevconfig |= DACEN;\n\t}\n\t\n\t \n\tdevconfig |= PCIERRGENDIS;\n\n\tahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig,  4);\n\n\t \n\tcommand = ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND,  2);\n\tcommand |= PCIM_CMD_BUSMASTEREN;\n\n\tahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, command,  2);\n\n\t \n\tahc->flags |= AHC_PAGESCBS;\n\n\terror = ahc_softc_init(ahc);\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\tif ((ahc->flags & AHC_DISABLE_PCI_PERR) != 0)\n\t\tahc->seqctl |= FAILDIS;\n\n\tahc->bus_intr = ahc_pci_intr;\n\tahc->bus_chip_init = ahc_pci_chip_init;\n\n\t \n\tif ((ahc_inb(ahc, HCNTRL) & POWRDN) == 0) {\n\t\tahc_pause(ahc);\n\t\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\t\tour_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;\n\t\telse\n\t\t\tour_id = ahc_inb(ahc, SCSIID) & OID;\n\t\tsxfrctl1 = ahc_inb(ahc, SXFRCTL1) & STPWEN;\n\t\tscsiseq = ahc_inb(ahc, SCSISEQ);\n\t} else {\n\t\tsxfrctl1 = STPWEN;\n\t\tour_id = 7;\n\t\tscsiseq = 0;\n\t}\n\n\terror = ahc_reset(ahc,  FALSE);\n\tif (error != 0)\n\t\treturn (ENXIO);\n\n\tif ((ahc->features & AHC_DT) != 0) {\n\t\tu_int sfunct;\n\n\t\t \n\t\tsfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;\n\t\tahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);\n\t\tahc_outb(ahc, OPTIONMODE,\n\t\t\t OPTIONMODE_DEFAULTS|AUTOACKEN|BUSFREEREV|EXPPHASEDIS);\n\t\tahc_outb(ahc, SFUNCT, sfunct);\n\n\t\t \n\t\tahc_outb(ahc, CRCCONTROL1, CRCVALCHKEN|CRCENDCHKEN|CRCREQCHKEN\n\t\t\t\t\t  |TARGCRCENDEN);\n\t}\n\n\tdscommand0 = ahc_inb(ahc, DSCOMMAND0);\n\tdscommand0 |= MPARCKEN|CACHETHEN;\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\n\t\t \n\t\tdscommand0 &= ~DPARCKEN;\n\t}\n\n\t \n\tif ((ahc->bugs & AHC_CACHETHEN_DIS_BUG) != 0)\n\t\tdscommand0 |= CACHETHEN;\n\n\tif ((ahc->bugs & AHC_CACHETHEN_BUG) != 0)\n\t\tdscommand0 &= ~CACHETHEN;\n\n\tahc_outb(ahc, DSCOMMAND0, dscommand0);\n\n\tahc->pci_cachesize =\n\t    ahc_pci_read_config(ahc->dev_softc, CSIZE_LATTIME,\n\t\t\t\t 1) & CACHESIZE;\n\tahc->pci_cachesize *= 4;\n\n\tif ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0\n\t && ahc->pci_cachesize == 4) {\n\n\t\tahc_pci_write_config(ahc->dev_softc, CSIZE_LATTIME,\n\t\t\t\t     0,  1);\n\t\tahc->pci_cachesize = 0;\n\t}\n\n\t \n\tif ((ahc->features & AHC_ULTRA) != 0) {\n\t\tuint32_t devconfig;\n\n\t\tdevconfig = ahc_pci_read_config(ahc->dev_softc,\n\t\t\t\t\t\tDEVCONFIG,  4);\n\t\tif ((devconfig & REXTVALID) == 0)\n\t\t\tahc->features &= ~AHC_ULTRA;\n\t}\n\n\t \n\tcheck_extport(ahc, &sxfrctl1);\n\n\t \n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tahc_outb(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));\n\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tahc_outb(ahc, DFF_THRSH, RD_DFTHRSH_MAX|WR_DFTHRSH_MAX);\n\t} else {\n\t\tahc_outb(ahc, DSPCISTATUS, DFTHRSH_100);\n\t}\n\n\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\t \n\t\t \n\t\tif ((ahc->flags & AHC_NO_BIOS_INIT) == 0\n\t\t && scsiseq != 0) {\n\t\t\tprintk(\"%s: Using left over BIOS settings\\n\",\n\t\t\t\tahc_name(ahc));\n\t\t\tahc->flags &= ~AHC_USEDEFAULTS;\n\t\t\tahc->flags |= AHC_BIOS_ENABLED;\n\t\t} else {\n\t\t\t \n \t\t\tour_id = 0x07;\n\t\t\tsxfrctl1 = STPWEN;\n\t\t}\n\t\tahc_outb(ahc, SCSICONF, our_id|ENSPCHK|RESET_SCSI);\n\n\t\tahc->our_id = our_id;\n\t}\n\n\t \n\tahc_probe_ext_scbram(ahc);\n\n\t \n\tif ((sxfrctl1 & STPWEN) != 0)\n\t\tahc->flags |= AHC_TERM_ENB_A;\n\n\t \n\tahc->bus_softc.pci_softc.devconfig =\n\t    ahc_pci_read_config(ahc->dev_softc, DEVCONFIG,  4);\n\tahc->bus_softc.pci_softc.command =\n\t    ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND,  1);\n\tahc->bus_softc.pci_softc.csize_lattime =\n\t    ahc_pci_read_config(ahc->dev_softc, CSIZE_LATTIME,  1);\n\tahc->bus_softc.pci_softc.dscommand0 = ahc_inb(ahc, DSCOMMAND0);\n\tahc->bus_softc.pci_softc.dspcistatus = ahc_inb(ahc, DSPCISTATUS);\n\tif ((ahc->features & AHC_DT) != 0) {\n\t\tu_int sfunct;\n\n\t\tsfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;\n\t\tahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);\n\t\tahc->bus_softc.pci_softc.optionmode = ahc_inb(ahc, OPTIONMODE);\n\t\tahc->bus_softc.pci_softc.targcrccnt = ahc_inw(ahc, TARGCRCCNT);\n\t\tahc_outb(ahc, SFUNCT, sfunct);\n\t\tahc->bus_softc.pci_softc.crccontrol1 =\n\t\t    ahc_inb(ahc, CRCCONTROL1);\n\t}\n\tif ((ahc->features & AHC_MULTI_FUNC) != 0)\n\t\tahc->bus_softc.pci_softc.scbbaddr = ahc_inb(ahc, SCBBADDR);\n\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tahc->bus_softc.pci_softc.dff_thrsh = ahc_inb(ahc, DFF_THRSH);\n\n\t \n\terror = ahc_init(ahc);\n\tif (error != 0)\n\t\treturn (error);\n\tahc->init_level++;\n\n\t \n\treturn ahc_pci_map_int(ahc);\n}\n\n \nstatic int\nahc_ext_scbram_present(struct ahc_softc *ahc)\n{\n\tu_int chip;\n\tint ramps;\n\tint single_user;\n\tuint32_t devconfig;\n\n\tchip = ahc->chip & AHC_CHIPID_MASK;\n\tdevconfig = ahc_pci_read_config(ahc->dev_softc,\n\t\t\t\t\tDEVCONFIG,  4);\n\tsingle_user = (devconfig & MPORTMODE) != 0;\n\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tramps = (ahc_inb(ahc, DSCOMMAND0) & RAMPS) != 0;\n\telse if (chip == AHC_AIC7895 || chip == AHC_AIC7895C)\n\t\t \n\t\tramps = 0;\n\telse if (chip >= AHC_AIC7870)\n\t\tramps = (devconfig & RAMPSM) != 0;\n\telse\n\t\tramps = 0;\n\n\tif (ramps && single_user)\n\t\treturn (1);\n\treturn (0);\n}\n\n \nstatic void\nahc_scbram_config(struct ahc_softc *ahc, int enable, int pcheck,\n\t\t  int fast, int large)\n{\n\tuint32_t devconfig;\n\n\tif (ahc->features & AHC_MULTI_FUNC) {\n\t\t \n\t\tahc_outb(ahc, SCBBADDR, ahc_get_pci_function(ahc->dev_softc));\n\t}\n\n\tahc->flags &= ~AHC_LSCBS_ENABLED;\n\tif (large)\n\t\tahc->flags |= AHC_LSCBS_ENABLED;\n\tdevconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG,  4);\n\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tu_int dscommand0;\n\n\t\tdscommand0 = ahc_inb(ahc, DSCOMMAND0);\n\t\tif (enable)\n\t\t\tdscommand0 &= ~INTSCBRAMSEL;\n\t\telse\n\t\t\tdscommand0 |= INTSCBRAMSEL;\n\t\tif (large)\n\t\t\tdscommand0 &= ~USCBSIZE32;\n\t\telse\n\t\t\tdscommand0 |= USCBSIZE32;\n\t\tahc_outb(ahc, DSCOMMAND0, dscommand0);\n\t} else {\n\t\tif (fast)\n\t\t\tdevconfig &= ~EXTSCBTIME;\n\t\telse\n\t\t\tdevconfig |= EXTSCBTIME;\n\t\tif (enable)\n\t\t\tdevconfig &= ~SCBRAMSEL;\n\t\telse\n\t\t\tdevconfig |= SCBRAMSEL;\n\t\tif (large)\n\t\t\tdevconfig &= ~SCBSIZE32;\n\t\telse\n\t\t\tdevconfig |= SCBSIZE32;\n\t}\n\tif (pcheck)\n\t\tdevconfig |= EXTSCBPEN;\n\telse\n\t\tdevconfig &= ~EXTSCBPEN;\n\n\tahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig,  4);\n}\n\n \nstatic void\nahc_probe_ext_scbram(struct ahc_softc *ahc)\n{\n\tint num_scbs;\n\tint test_num_scbs;\n\tint enable;\n\tint pcheck;\n\tint fast;\n\tint large;\n\n\tenable = FALSE;\n\tpcheck = FALSE;\n\tfast = FALSE;\n\tlarge = FALSE;\n\tnum_scbs = 0;\n\t\n\tif (ahc_ext_scbram_present(ahc) == 0)\n\t\tgoto done;\n\n\t \n\tahc_scbram_config(ahc,  TRUE, pcheck, fast, large);\n\tnum_scbs = ahc_probe_scbs(ahc);\n\tif (num_scbs == 0) {\n\t\t \n\t\tgoto done;\n\t}\n\tenable = TRUE;\n\n\t \n\tahc_outb(ahc, SEQCTL, 0);\n\tahc_outb(ahc, CLRINT, CLRPARERR);\n\tahc_outb(ahc, CLRINT, CLRBRKADRINT);\n\n\t \n\tahc_scbram_config(ahc, enable,  TRUE, fast, large);\n\tnum_scbs = ahc_probe_scbs(ahc);\n\tif ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0\n\t || (ahc_inb(ahc, ERROR) & MPARERR) == 0)\n\t\tpcheck = TRUE;\n\n\t \n\tahc_outb(ahc, CLRINT, CLRPARERR);\n\tahc_outb(ahc, CLRINT, CLRBRKADRINT);\n\n\t \n\tahc_scbram_config(ahc, enable, pcheck,  TRUE, large);\n\ttest_num_scbs = ahc_probe_scbs(ahc);\n\tif (test_num_scbs == num_scbs\n\t && ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0\n\t  || (ahc_inb(ahc, ERROR) & MPARERR) == 0))\n\t\tfast = TRUE;\n\n\t \n\tif ((ahc->features & AHC_LARGE_SCBS) != 0) {\n\t\tahc_scbram_config(ahc, enable, pcheck, fast,  TRUE);\n\t\ttest_num_scbs = ahc_probe_scbs(ahc);\n\t\tif (test_num_scbs >= num_scbs) {\n\t\t\tlarge = TRUE;\n\t\t\tnum_scbs = test_num_scbs;\n\t \t\tif (num_scbs >= 64) {\n\t\t\t\t \n\t\t\t\tahc->flags |= AHC_SCB_BTT;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\t \n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS);\n\t \n\tahc_outb(ahc, CLRINT, CLRPARERR);\n\tahc_outb(ahc, CLRINT, CLRBRKADRINT);\n\tif (bootverbose && enable) {\n\t\tprintk(\"%s: External SRAM, %s access%s, %dbytes/SCB\\n\",\n\t\t       ahc_name(ahc), fast ? \"fast\" : \"slow\", \n\t\t       pcheck ? \", parity checking enabled\" : \"\",\n\t\t       large ? 64 : 32);\n\t}\n\tahc_scbram_config(ahc, enable, pcheck, fast, large);\n}\n\n \nint\nahc_pci_test_register_access(struct ahc_softc *ahc)\n{\n\tint\t error;\n\tu_int\t status1;\n\tuint32_t cmd;\n\tuint8_t\t hcntrl;\n\n\terror = EIO;\n\n\t \n\tcmd = ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND,  2);\n\tahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND,\n\t\t\t     cmd & ~PCIM_CMD_SERRESPEN,  2);\n\n\t \n\thcntrl = ahc_inb(ahc, HCNTRL);\n\n\tif (hcntrl == 0xFF)\n\t\tgoto fail;\n\n\tif ((hcntrl & CHIPRST) != 0) {\n\t\t \n\t\tahc->flags |= AHC_NO_BIOS_INIT;\n\t}\n\n\t \n\thcntrl &= ~CHIPRST;\n\tahc_outb(ahc, HCNTRL, hcntrl|PAUSE);\n\twhile (ahc_is_paused(ahc) == 0)\n\t\t;\n\n\t \n\tstatus1 = ahc_pci_read_config(ahc->dev_softc,\n\t\t\t\t      PCIR_STATUS + 1,  1);\n\tahc_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,\n\t\t\t     status1,  1);\n\tahc_outb(ahc, CLRINT, CLRPARERR);\n\n\tahc_outb(ahc, SEQCTL, PERRORDIS);\n\tahc_outb(ahc, SCBPTR, 0);\n\tahc_outl(ahc, SCB_BASE, 0x5aa555aa);\n\tif (ahc_inl(ahc, SCB_BASE) != 0x5aa555aa)\n\t\tgoto fail;\n\n\tstatus1 = ahc_pci_read_config(ahc->dev_softc,\n\t\t\t\t      PCIR_STATUS + 1,  1);\n\tif ((status1 & STA) != 0)\n\t\tgoto fail;\n\n\terror = 0;\n\nfail:\n\t \n\tstatus1 = ahc_pci_read_config(ahc->dev_softc,\n\t\t\t\t      PCIR_STATUS + 1,  1);\n\tahc_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,\n\t\t\t     status1,  1);\n\tahc_outb(ahc, CLRINT, CLRPARERR);\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS);\n\tahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, cmd,  2);\n\treturn (error);\n}\n\n \nstatic void\ncheck_extport(struct ahc_softc *ahc, u_int *sxfrctl1)\n{\n\tstruct\tseeprom_descriptor sd;\n\tstruct\tseeprom_config *sc;\n\tint\thave_seeprom;\n\tint\thave_autoterm;\n\n\tsd.sd_ahc = ahc;\n\tsd.sd_control_offset = SEECTL;\t\t\n\tsd.sd_status_offset = SEECTL;\t\t\n\tsd.sd_dataout_offset = SEECTL;\t\t\n\tsc = ahc->seep_config;\n\n\t \n\tif (ahc->flags & AHC_LARGE_SEEPROM)\n\t\tsd.sd_chip = C56_66;\n\telse\n\t\tsd.sd_chip = C46;\n\n\tsd.sd_MS = SEEMS;\n\tsd.sd_RDY = SEERDY;\n\tsd.sd_CS = SEECS;\n\tsd.sd_CK = SEECK;\n\tsd.sd_DO = SEEDO;\n\tsd.sd_DI = SEEDI;\n\n\thave_seeprom = ahc_acquire_seeprom(ahc, &sd);\n\tif (have_seeprom) {\n\n\t\tif (bootverbose) \n\t\t\tprintk(\"%s: Reading SEEPROM...\", ahc_name(ahc));\n\n\t\tfor (;;) {\n\t\t\tu_int start_addr;\n\n\t\t\tstart_addr = 32 * (ahc->channel - 'A');\n\n\t\t\thave_seeprom = ahc_read_seeprom(&sd, (uint16_t *)sc,\n\t\t\t\t\t\t\tstart_addr,\n\t\t\t\t\t\t\tsizeof(*sc)/2);\n\n\t\t\tif (have_seeprom)\n\t\t\t\thave_seeprom = ahc_verify_cksum(sc);\n\n\t\t\tif (have_seeprom != 0 || sd.sd_chip == C56_66) {\n\t\t\t\tif (bootverbose) {\n\t\t\t\t\tif (have_seeprom == 0)\n\t\t\t\t\t\tprintk (\"checksum error\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tprintk (\"done.\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsd.sd_chip = C56_66;\n\t\t}\n\t\tahc_release_seeprom(&sd);\n\n\t\t \n\t\tif (sd.sd_chip == C56_66)\n\t\t\tahc->flags |= AHC_LARGE_SEEPROM;\n\t}\n\n\tif (!have_seeprom) {\n\t\t \n\t\tahc_outb(ahc, SCBPTR, 2);\n\t\tif (ahc_inb(ahc, SCB_BASE) == 'A'\n\t\t && ahc_inb(ahc, SCB_BASE + 1) == 'D'\n\t\t && ahc_inb(ahc, SCB_BASE + 2) == 'P'\n\t\t && ahc_inb(ahc, SCB_BASE + 3) == 'T') {\n\t\t\tuint16_t *sc_data;\n\t\t\tint\t  i;\n\n\t\t\tsc_data = (uint16_t *)sc;\n\t\t\tfor (i = 0; i < 32; i++, sc_data++) {\n\t\t\t\tint\tj;\n\n\t\t\t\tj = i * 2;\n\t\t\t\t*sc_data = ahc_inb(ahc, SRAM_BASE + j)\n\t\t\t\t\t | ahc_inb(ahc, SRAM_BASE + j + 1) << 8;\n\t\t\t}\n\t\t\thave_seeprom = ahc_verify_cksum(sc);\n\t\t\tif (have_seeprom)\n\t\t\t\tahc->flags |= AHC_SCB_CONFIG_USED;\n\t\t}\n\t\t \n\t\tahc_outb(ahc, CLRINT, CLRPARERR);\n\t\tahc_outb(ahc, CLRINT, CLRBRKADRINT);\n\t}\n\n\tif (!have_seeprom) {\n\t\tif (bootverbose)\n\t\t\tprintk(\"%s: No SEEPROM available.\\n\", ahc_name(ahc));\n\t\tahc->flags |= AHC_USEDEFAULTS;\n\t\tkfree(ahc->seep_config);\n\t\tahc->seep_config = NULL;\n\t\tsc = NULL;\n\t} else {\n\t\tahc_parse_pci_eeprom(ahc, sc);\n\t}\n\n\t \n\thave_autoterm = have_seeprom;\n\n\t \n\tif ((ahc->features & AHC_SPIOCAP) != 0) {\n\t\tif ((ahc_inb(ahc, SPIOCAP) & SSPIOCPS) == 0)\n\t\t\thave_autoterm = FALSE;\n\t}\n\n\tif (have_autoterm) {\n\t\tahc->flags |= AHC_HAS_TERM_LOGIC;\n\t\tahc_acquire_seeprom(ahc, &sd);\n\t\tconfigure_termination(ahc, &sd, sc->adapter_control, sxfrctl1);\n\t\tahc_release_seeprom(&sd);\n\t} else if (have_seeprom) {\n\t\t*sxfrctl1 &= ~STPWEN;\n\t\tif ((sc->adapter_control & CFSTERM) != 0)\n\t\t\t*sxfrctl1 |= STPWEN;\n\t\tif (bootverbose)\n\t\t\tprintk(\"%s: Low byte termination %sabled\\n\",\n\t\t\t       ahc_name(ahc),\n\t\t\t       (*sxfrctl1 & STPWEN) ? \"en\" : \"dis\");\n\t}\n}\n\nstatic void\nahc_parse_pci_eeprom(struct ahc_softc *ahc, struct seeprom_config *sc)\n{\n\t \n\tint\t i;\n\tint\t max_targ = sc->max_targets & CFMAXTARG;\n\tu_int\t scsi_conf;\n\tuint16_t discenable;\n\tuint16_t ultraenb;\n\n\tdiscenable = 0;\n\tultraenb = 0;\n\tif ((sc->adapter_control & CFULTRAEN) != 0) {\n\t\t \n\t\tfor (i = 0; i < max_targ; i++) {\n\t\t\tif ((sc->device_flags[i] & CFSYNCHISULTRA) != 0) {\n\t\t\t\tahc->flags |= AHC_NEWEEPROM_FMT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < max_targ; i++) {\n\t\tu_int     scsirate;\n\t\tuint16_t target_mask;\n\n\t\ttarget_mask = 0x01 << i;\n\t\tif (sc->device_flags[i] & CFDISC)\n\t\t\tdiscenable |= target_mask;\n\t\tif ((ahc->flags & AHC_NEWEEPROM_FMT) != 0) {\n\t\t\tif ((sc->device_flags[i] & CFSYNCHISULTRA) != 0)\n\t\t\t\tultraenb |= target_mask;\n\t\t} else if ((sc->adapter_control & CFULTRAEN) != 0) {\n\t\t\tultraenb |= target_mask;\n\t\t}\n\t\tif ((sc->device_flags[i] & CFXFER) == 0x04\n\t\t && (ultraenb & target_mask) != 0) {\n\t\t\t \n\t\t\tsc->device_flags[i] &= ~CFXFER;\n\t\t \tultraenb &= ~target_mask;\n\t\t}\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tu_int offset;\n\n\t\t\tif (sc->device_flags[i] & CFSYNCH)\n\t\t\t\toffset = MAX_OFFSET_ULTRA2;\n\t\t\telse \n\t\t\t\toffset = 0;\n\t\t\tahc_outb(ahc, TARG_OFFSET + i, offset);\n\n\t\t\t \n\t\t\tscsirate = (sc->device_flags[i] & CFXFER)\n\t\t\t\t | ((ultraenb & target_mask) ? 0x8 : 0x0);\n\t\t\tif (sc->device_flags[i] & CFWIDEB)\n\t\t\t\tscsirate |= WIDEXFER;\n\t\t} else {\n\t\t\tscsirate = (sc->device_flags[i] & CFXFER) << 4;\n\t\t\tif (sc->device_flags[i] & CFSYNCH)\n\t\t\t\tscsirate |= SOFS;\n\t\t\tif (sc->device_flags[i] & CFWIDEB)\n\t\t\t\tscsirate |= WIDEXFER;\n\t\t}\n\t\tahc_outb(ahc, TARG_SCSIRATE + i, scsirate);\n\t}\n\tahc->our_id = sc->brtime_id & CFSCSIID;\n\n\tscsi_conf = (ahc->our_id & 0x7);\n\tif (sc->adapter_control & CFSPARITY)\n\t\tscsi_conf |= ENSPCHK;\n\tif (sc->adapter_control & CFRESETB)\n\t\tscsi_conf |= RESET_SCSI;\n\n\tahc->flags |= (sc->adapter_control & CFBOOTCHAN) >> CFBOOTCHANSHIFT;\n\n\tif (sc->bios_control & CFEXTEND)\n\t\tahc->flags |= AHC_EXTENDED_TRANS_A;\n\n\tif (sc->bios_control & CFBIOSEN)\n\t\tahc->flags |= AHC_BIOS_ENABLED;\n\tif (ahc->features & AHC_ULTRA\n\t && (ahc->flags & AHC_NEWEEPROM_FMT) == 0) {\n\t\t \n\t\tif (!(sc->adapter_control & CFULTRAEN))\n\t\t\t \n\t\t\tultraenb = 0;\n\t}\n\n\tif (sc->signature == CFSIGNATURE\n\t || sc->signature == CFSIGNATURE2) {\n\t\tuint32_t devconfig;\n\n\t\t \n\t\tdevconfig = ahc_pci_read_config(ahc->dev_softc,\n\t\t\t\t\t\tDEVCONFIG,  4);\n\t\tdevconfig &= ~STPWLEVEL;\n\t\tif ((sc->bios_control & CFSTPWLEVEL) != 0)\n\t\t\tdevconfig |= STPWLEVEL;\n\t\tahc_pci_write_config(ahc->dev_softc, DEVCONFIG,\n\t\t\t\t     devconfig,  4);\n\t}\n\t \n\tahc_outb(ahc, SCSICONF, scsi_conf);\n\tahc_outb(ahc, DISC_DSB, ~(discenable & 0xff));\n\tahc_outb(ahc, DISC_DSB + 1, ~((discenable >> 8) & 0xff));\n\tahc_outb(ahc, ULTRA_ENB, ultraenb & 0xff);\n\tahc_outb(ahc, ULTRA_ENB + 1, (ultraenb >> 8) & 0xff);\n}\n\nstatic void\nconfigure_termination(struct ahc_softc *ahc,\n\t\t      struct seeprom_descriptor *sd,\n\t\t      u_int adapter_control,\n\t\t      u_int *sxfrctl1)\n{\n\tuint8_t brddat;\n\t\n\tbrddat = 0;\n\n\t \n\t*sxfrctl1 = 0;\n\t\n\t \n\tSEEPROM_OUTB(sd, sd->sd_MS | sd->sd_CS);\n\tif ((adapter_control & CFAUTOTERM) != 0\n\t || (ahc->features & AHC_NEW_TERMCTL) != 0) {\n\t\tint internal50_present;\n\t\tint internal68_present;\n\t\tint externalcable_present;\n\t\tint eeprom_present;\n\t\tint enableSEC_low;\n\t\tint enableSEC_high;\n\t\tint enablePRI_low;\n\t\tint enablePRI_high;\n\t\tint sum;\n\n\t\tenableSEC_low = 0;\n\t\tenableSEC_high = 0;\n\t\tenablePRI_low = 0;\n\t\tenablePRI_high = 0;\n\t\tif ((ahc->features & AHC_NEW_TERMCTL) != 0) {\n\t\t\tahc_new_term_detect(ahc, &enableSEC_low,\n\t\t\t\t\t    &enableSEC_high,\n\t\t\t\t\t    &enablePRI_low,\n\t\t\t\t\t    &enablePRI_high,\n\t\t\t\t\t    &eeprom_present);\n\t\t\tif ((adapter_control & CFSEAUTOTERM) == 0) {\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintk(\"%s: Manual SE Termination\\n\",\n\t\t\t\t\t       ahc_name(ahc));\n\t\t\t\tenableSEC_low = (adapter_control & CFSELOWTERM);\n\t\t\t\tenableSEC_high =\n\t\t\t\t    (adapter_control & CFSEHIGHTERM);\n\t\t\t}\n\t\t\tif ((adapter_control & CFAUTOTERM) == 0) {\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintk(\"%s: Manual LVD Termination\\n\",\n\t\t\t\t\t       ahc_name(ahc));\n\t\t\t\tenablePRI_low = (adapter_control & CFSTERM);\n\t\t\t\tenablePRI_high = (adapter_control & CFWSTERM);\n\t\t\t}\n\t\t\t \n\t\t\tinternal50_present = 0;\n\t\t\tinternal68_present = 1;\n\t\t\texternalcable_present = 1;\n\t\t} else if ((ahc->features & AHC_SPIOCAP) != 0) {\n\t\t\taic785X_cable_detect(ahc, &internal50_present,\n\t\t\t\t\t     &externalcable_present,\n\t\t\t\t\t     &eeprom_present);\n\t\t\t \n\t\t\tinternal68_present = 0;\n\t\t} else {\n\t\t\taic787X_cable_detect(ahc, &internal50_present,\n\t\t\t\t\t     &internal68_present,\n\t\t\t\t\t     &externalcable_present,\n\t\t\t\t\t     &eeprom_present);\n\t\t}\n\n\t\tif ((ahc->features & AHC_WIDE) == 0)\n\t\t\tinternal68_present = 0;\n\n\t\tif (bootverbose\n\t\t && (ahc->features & AHC_ULTRA2) == 0) {\n\t\t\tprintk(\"%s: internal 50 cable %s present\",\n\t\t\t       ahc_name(ahc),\n\t\t\t       internal50_present ? \"is\":\"not\");\n\n\t\t\tif ((ahc->features & AHC_WIDE) != 0)\n\t\t\t\tprintk(\", internal 68 cable %s present\",\n\t\t\t\t       internal68_present ? \"is\":\"not\");\n\t\t\tprintk(\"\\n%s: external cable %s present\\n\",\n\t\t\t       ahc_name(ahc),\n\t\t\t       externalcable_present ? \"is\":\"not\");\n\t\t}\n\t\tif (bootverbose)\n\t\t\tprintk(\"%s: BIOS eeprom %s present\\n\",\n\t\t\t       ahc_name(ahc), eeprom_present ? \"is\" : \"not\");\n\n\t\tif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0) {\n\t\t\t \n\t\t\tinternal50_present = 0;\n\t\t}\n\n\t\t \n\t\tif ((ahc->features & AHC_ULTRA2) == 0\n\t\t && (internal50_present != 0)\n\t\t && (internal68_present != 0)\n\t\t && (externalcable_present != 0)) {\n\t\t\tprintk(\"%s: Illegal cable configuration!!. \"\n\t\t\t       \"Only two connectors on the \"\n\t\t\t       \"adapter may be used at a \"\n\t\t\t       \"time!\\n\", ahc_name(ahc));\n\n\t\t\t \n\t\t \tinternal50_present = 0;\n\t\t\tinternal68_present = 0;\n\t\t\texternalcable_present = 0;\n\t\t}\n\n\t\tif ((ahc->features & AHC_WIDE) != 0\n\t\t && ((externalcable_present == 0)\n\t\t  || (internal68_present == 0)\n\t\t  || (enableSEC_high != 0))) {\n\t\t\tbrddat |= BRDDAT6;\n\t\t\tif (bootverbose) {\n\t\t\t\tif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)\n\t\t\t\t\tprintk(\"%s: 68 pin termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc));\n\t\t\t\telse\n\t\t\t\t\tprintk(\"%s: %sHigh byte termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc),\n\t\t\t\t\t       enableSEC_high ? \"Secondary \"\n\t\t\t\t\t\t\t      : \"\");\n\t\t\t}\n\t\t}\n\n\t\tsum = internal50_present + internal68_present\n\t\t    + externalcable_present;\n\t\tif (sum < 2 || (enableSEC_low != 0)) {\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\t\t\tbrddat |= BRDDAT5;\n\t\t\telse\n\t\t\t\t*sxfrctl1 |= STPWEN;\n\t\t\tif (bootverbose) {\n\t\t\t\tif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)\n\t\t\t\t\tprintk(\"%s: 50 pin termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc));\n\t\t\t\telse\n\t\t\t\t\tprintk(\"%s: %sLow byte termination \"\n\t\t\t\t\t       \"Enabled\\n\", ahc_name(ahc),\n\t\t\t\t\t       enableSEC_low ? \"Secondary \"\n\t\t\t\t\t\t\t     : \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (enablePRI_low != 0) {\n\t\t\t*sxfrctl1 |= STPWEN;\n\t\t\tif (bootverbose)\n\t\t\t\tprintk(\"%s: Primary Low Byte termination \"\n\t\t\t\t       \"Enabled\\n\", ahc_name(ahc));\n\t\t}\n\n\t\t \n\t\tahc_outb(ahc, SXFRCTL1, *sxfrctl1);\n\n\t\tif (enablePRI_high != 0) {\n\t\t\tbrddat |= BRDDAT4;\n\t\t\tif (bootverbose)\n\t\t\t\tprintk(\"%s: Primary High Byte \"\n\t\t\t\t       \"termination Enabled\\n\",\n\t\t\t\t       ahc_name(ahc));\n\t\t}\n\t\t\n\t\twrite_brdctl(ahc, brddat);\n\n\t} else {\n\t\tif ((adapter_control & CFSTERM) != 0) {\n\t\t\t*sxfrctl1 |= STPWEN;\n\n\t\t\tif (bootverbose)\n\t\t\t\tprintk(\"%s: %sLow byte termination Enabled\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       (ahc->features & AHC_ULTRA2) ? \"Primary \"\n\t\t\t\t\t\t\t\t    : \"\");\n\t\t}\n\n\t\tif ((adapter_control & CFWSTERM) != 0\n\t\t && (ahc->features & AHC_WIDE) != 0) {\n\t\t\tbrddat |= BRDDAT6;\n\t\t\tif (bootverbose)\n\t\t\t\tprintk(\"%s: %sHigh byte termination Enabled\\n\",\n\t\t\t\t       ahc_name(ahc),\n\t\t\t\t       (ahc->features & AHC_ULTRA2)\n\t\t\t\t     ? \"Secondary \" : \"\");\n\t\t}\n\n\t\t \n\t\tahc_outb(ahc, SXFRCTL1, *sxfrctl1);\n\n\t\tif ((ahc->features & AHC_WIDE) != 0)\n\t\t\twrite_brdctl(ahc, brddat);\n\t}\n\tSEEPROM_OUTB(sd, sd->sd_MS);  \n}\n\nstatic void\nahc_new_term_detect(struct ahc_softc *ahc, int *enableSEC_low,\n\t\t    int *enableSEC_high, int *enablePRI_low,\n\t\t    int *enablePRI_high, int *eeprom_present)\n{\n\tuint8_t brdctl;\n\n\t \n\tbrdctl = read_brdctl(ahc);\n\t*eeprom_present = brdctl & BRDDAT7;\n\t*enableSEC_high = (brdctl & BRDDAT6);\n\t*enableSEC_low = (brdctl & BRDDAT5);\n\t*enablePRI_high = (brdctl & BRDDAT4);\n\t*enablePRI_low = (brdctl & BRDDAT3);\n}\n\nstatic void\naic787X_cable_detect(struct ahc_softc *ahc, int *internal50_present,\n\t\t     int *internal68_present, int *externalcable_present,\n\t\t     int *eeprom_present)\n{\n\tuint8_t brdctl;\n\n\t \n\twrite_brdctl(ahc, 0);\n\n\t \n\tbrdctl = read_brdctl(ahc);\n\t*internal50_present = (brdctl & BRDDAT6) ? 0 : 1;\n\t*internal68_present = (brdctl & BRDDAT7) ? 0 : 1;\n\n\t \n\twrite_brdctl(ahc, BRDDAT5);\n\n\t \n\tbrdctl = read_brdctl(ahc);\n\t*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;\n\t*eeprom_present = (brdctl & BRDDAT7) ? 1 : 0;\n}\n\nstatic void\naic785X_cable_detect(struct ahc_softc *ahc, int *internal50_present,\n\t\t     int *externalcable_present, int *eeprom_present)\n{\n\tuint8_t brdctl;\n\tuint8_t spiocap;\n\n\tspiocap = ahc_inb(ahc, SPIOCAP);\n\tspiocap &= ~SOFTCMDEN;\n\tspiocap |= EXT_BRDCTL;\n\tahc_outb(ahc, SPIOCAP, spiocap);\n\tahc_outb(ahc, BRDCTL, BRDRW|BRDCS);\n\tahc_flush_device_writes(ahc);\n\tahc_delay(500);\n\tahc_outb(ahc, BRDCTL, 0);\n\tahc_flush_device_writes(ahc);\n\tahc_delay(500);\n\tbrdctl = ahc_inb(ahc, BRDCTL);\n\t*internal50_present = (brdctl & BRDDAT5) ? 0 : 1;\n\t*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;\n\t*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) ? 1 : 0;\n}\n\t\nint\nahc_acquire_seeprom(struct ahc_softc *ahc, struct seeprom_descriptor *sd)\n{\n\tint wait;\n\n\tif ((ahc->features & AHC_SPIOCAP) != 0\n\t && (ahc_inb(ahc, SPIOCAP) & SEEPROM) == 0)\n\t\treturn (0);\n\n\t \n\tSEEPROM_OUTB(sd, sd->sd_MS);\n\twait = 1000;   \n\twhile (--wait && ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0)) {\n\t\tahc_delay(1000);   \n\t}\n\tif ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0) {\n\t\tSEEPROM_OUTB(sd, 0); \n\t\treturn (0);\n\t}\n\treturn(1);\n}\n\nvoid\nahc_release_seeprom(struct seeprom_descriptor *sd)\n{\n\t \n\tSEEPROM_OUTB(sd, 0);\n}\n\nstatic void\nwrite_brdctl(struct ahc_softc *ahc, uint8_t value)\n{\n\tuint8_t brdctl;\n\n\tif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\n\t\tbrdctl = BRDSTB;\n\t \tif (ahc->channel == 'B')\n\t\t\tbrdctl |= BRDCS;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbrdctl = 0;\n\t} else {\n\t\tbrdctl = BRDSTB|BRDCS;\n\t}\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tahc_flush_device_writes(ahc);\n\tbrdctl |= value;\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tahc_flush_device_writes(ahc);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tbrdctl |= BRDSTB_ULTRA2;\n\telse\n\t\tbrdctl &= ~BRDSTB;\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tahc_flush_device_writes(ahc);\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tbrdctl = 0;\n\telse\n\t\tbrdctl &= ~BRDCS;\n\tahc_outb(ahc, BRDCTL, brdctl);\n}\n\nstatic uint8_t\nread_brdctl(struct ahc_softc *ahc)\n{\n\tuint8_t brdctl;\n\tuint8_t value;\n\n\tif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\n\t\tbrdctl = BRDRW;\n\t \tif (ahc->channel == 'B')\n\t\t\tbrdctl |= BRDCS;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tbrdctl = BRDRW_ULTRA2;\n\t} else {\n\t\tbrdctl = BRDRW|BRDCS;\n\t}\n\tahc_outb(ahc, BRDCTL, brdctl);\n\tahc_flush_device_writes(ahc);\n\tvalue = ahc_inb(ahc, BRDCTL);\n\tahc_outb(ahc, BRDCTL, 0);\n\treturn (value);\n}\n\nstatic void\nahc_pci_intr(struct ahc_softc *ahc)\n{\n\tu_int error;\n\tu_int status1;\n\n\terror = ahc_inb(ahc, ERROR);\n\tif ((error & PCIERRSTAT) == 0)\n\t\treturn;\n\n\tstatus1 = ahc_pci_read_config(ahc->dev_softc,\n\t\t\t\t      PCIR_STATUS + 1,  1);\n\n\tprintk(\"%s: PCI error Interrupt at seqaddr = 0x%x\\n\",\n\t      ahc_name(ahc),\n\t      ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));\n\n\tif (status1 & DPE) {\n\t\tahc->pci_target_perr_count++;\n\t\tprintk(\"%s: Data Parity Error Detected during address \"\n\t\t       \"or write data phase\\n\", ahc_name(ahc));\n\t}\n\tif (status1 & SSE) {\n\t\tprintk(\"%s: Signal System Error Detected\\n\", ahc_name(ahc));\n\t}\n\tif (status1 & RMA) {\n\t\tprintk(\"%s: Received a Master Abort\\n\", ahc_name(ahc));\n\t}\n\tif (status1 & RTA) {\n\t\tprintk(\"%s: Received a Target Abort\\n\", ahc_name(ahc));\n\t}\n\tif (status1 & STA) {\n\t\tprintk(\"%s: Signaled a Target Abort\\n\", ahc_name(ahc));\n\t}\n\tif (status1 & DPR) {\n\t\tprintk(\"%s: Data Parity Error has been reported via PERR#\\n\",\n\t\t       ahc_name(ahc));\n\t}\n\n\t \n\tahc_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,\n\t\t\t     status1,  1);\n\n\tif ((status1 & (DPE|SSE|RMA|RTA|STA|DPR)) == 0) {\n\t\tprintk(\"%s: Latched PCIERR interrupt with \"\n\t\t       \"no status bits set\\n\", ahc_name(ahc)); \n\t} else {\n\t\tahc_outb(ahc, CLRINT, CLRPARERR);\n\t}\n\n\tif (ahc->pci_target_perr_count > AHC_PCI_TARGET_PERR_THRESH) {\n\t\tprintk(\n\"%s: WARNING WARNING WARNING WARNING\\n\"\n\"%s: Too many PCI parity errors observed as a target.\\n\"\n\"%s: Some device on this bus is generating bad parity.\\n\"\n\"%s: This is an error *observed by*, not *generated by*, this controller.\\n\"\n\"%s: PCI parity error checking has been disabled.\\n\"\n\"%s: WARNING WARNING WARNING WARNING\\n\",\n\t\t       ahc_name(ahc), ahc_name(ahc), ahc_name(ahc),\n\t\t       ahc_name(ahc), ahc_name(ahc), ahc_name(ahc));\n\t\tahc->seqctl |= FAILDIS;\n\t\tahc_outb(ahc, SEQCTL, ahc->seqctl);\n\t}\n\tahc_unpause(ahc);\n}\n\nstatic int\nahc_pci_chip_init(struct ahc_softc *ahc)\n{\n\tahc_outb(ahc, DSCOMMAND0, ahc->bus_softc.pci_softc.dscommand0);\n\tahc_outb(ahc, DSPCISTATUS, ahc->bus_softc.pci_softc.dspcistatus);\n\tif ((ahc->features & AHC_DT) != 0) {\n\t\tu_int sfunct;\n\n\t\tsfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;\n\t\tahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);\n\t\tahc_outb(ahc, OPTIONMODE, ahc->bus_softc.pci_softc.optionmode);\n\t\tahc_outw(ahc, TARGCRCCNT, ahc->bus_softc.pci_softc.targcrccnt);\n\t\tahc_outb(ahc, SFUNCT, sfunct);\n\t\tahc_outb(ahc, CRCCONTROL1,\n\t\t\t ahc->bus_softc.pci_softc.crccontrol1);\n\t}\n\tif ((ahc->features & AHC_MULTI_FUNC) != 0)\n\t\tahc_outb(ahc, SCBBADDR, ahc->bus_softc.pci_softc.scbbaddr);\n\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tahc_outb(ahc, DFF_THRSH, ahc->bus_softc.pci_softc.dff_thrsh);\n\n\treturn (ahc_chip_init(ahc));\n}\n\nvoid __maybe_unused\nahc_pci_resume(struct ahc_softc *ahc)\n{\n\t \n\tahc_pci_write_config(ahc->dev_softc, DEVCONFIG,\n\t\t\t     ahc->bus_softc.pci_softc.devconfig,  4);\n\tahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND,\n\t\t\t     ahc->bus_softc.pci_softc.command,  1);\n\tahc_pci_write_config(ahc->dev_softc, CSIZE_LATTIME,\n\t\t\t     ahc->bus_softc.pci_softc.csize_lattime,  1);\n\tif ((ahc->flags & AHC_HAS_TERM_LOGIC) != 0) {\n\t\tstruct\tseeprom_descriptor sd;\n\t\tu_int\tsxfrctl1;\n\n\t\tsd.sd_ahc = ahc;\n\t\tsd.sd_control_offset = SEECTL;\t\t\n\t\tsd.sd_status_offset = SEECTL;\t\t\n\t\tsd.sd_dataout_offset = SEECTL;\t\t\n\n\t\tahc_acquire_seeprom(ahc, &sd);\n\t\tconfigure_termination(ahc, &sd,\n\t\t\t\t      ahc->seep_config->adapter_control,\n\t\t\t\t      &sxfrctl1);\n\t\tahc_release_seeprom(&sd);\n\t}\n}\n\nstatic int\nahc_aic785X_setup(struct ahc_softc *ahc)\n{\n\tahc_dev_softc_t pci;\n\tuint8_t rev;\n\n\tpci = ahc->dev_softc;\n\tahc->channel = 'A';\n\tahc->chip = AHC_AIC7850;\n\tahc->features = AHC_AIC7850_FE;\n\tahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;\n\trev = ahc_pci_read_config(pci, PCIR_REVID,  1);\n\tif (rev >= 1)\n\t\tahc->bugs |= AHC_PCI_2_1_RETRY_BUG;\n\tahc->instruction_ram_size = 512;\n\treturn (0);\n}\n\nstatic int\nahc_aic7860_setup(struct ahc_softc *ahc)\n{\n\tahc_dev_softc_t pci;\n\tuint8_t rev;\n\n\tpci = ahc->dev_softc;\n\tahc->channel = 'A';\n\tahc->chip = AHC_AIC7860;\n\tahc->features = AHC_AIC7860_FE;\n\tahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;\n\trev = ahc_pci_read_config(pci, PCIR_REVID,  1);\n\tif (rev >= 1)\n\t\tahc->bugs |= AHC_PCI_2_1_RETRY_BUG;\n\tahc->instruction_ram_size = 512;\n\treturn (0);\n}\n\nstatic int\nahc_apa1480_setup(struct ahc_softc *ahc)\n{\n\tint error;\n\n\terror = ahc_aic7860_setup(ahc);\n\tif (error != 0)\n\t\treturn (error);\n\tahc->features |= AHC_REMOVABLE;\n\treturn (0);\n}\n\nstatic int\nahc_aic7870_setup(struct ahc_softc *ahc)\n{\n\n\tahc->channel = 'A';\n\tahc->chip = AHC_AIC7870;\n\tahc->features = AHC_AIC7870_FE;\n\tahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;\n\tahc->instruction_ram_size = 512;\n\treturn (0);\n}\n\nstatic int\nahc_aic7870h_setup(struct ahc_softc *ahc)\n{\n\tint error = ahc_aic7870_setup(ahc);\n\n\tahc->features |= AHC_HVD;\n\n\treturn error;\n}\n\nstatic int\nahc_aha394X_setup(struct ahc_softc *ahc)\n{\n\tint error;\n\n\terror = ahc_aic7870_setup(ahc);\n\tif (error == 0)\n\t\terror = ahc_aha394XX_setup(ahc);\n\treturn (error);\n}\n\nstatic int\nahc_aha394Xh_setup(struct ahc_softc *ahc)\n{\n\tint error = ahc_aha394X_setup(ahc);\n\n\tahc->features |= AHC_HVD;\n\n\treturn error;\n}\n\nstatic int\nahc_aha398X_setup(struct ahc_softc *ahc)\n{\n\tint error;\n\n\terror = ahc_aic7870_setup(ahc);\n\tif (error == 0)\n\t\terror = ahc_aha398XX_setup(ahc);\n\treturn (error);\n}\n\nstatic int\nahc_aha494X_setup(struct ahc_softc *ahc)\n{\n\tint error;\n\n\terror = ahc_aic7870_setup(ahc);\n\tif (error == 0)\n\t\terror = ahc_aha494XX_setup(ahc);\n\treturn (error);\n}\n\nstatic int\nahc_aha494Xh_setup(struct ahc_softc *ahc)\n{\n\tint error = ahc_aha494X_setup(ahc);\n\n\tahc->features |= AHC_HVD;\n\n\treturn error;\n}\n\nstatic int\nahc_aic7880_setup(struct ahc_softc *ahc)\n{\n\tahc_dev_softc_t pci;\n\tuint8_t rev;\n\n\tpci = ahc->dev_softc;\n\tahc->channel = 'A';\n\tahc->chip = AHC_AIC7880;\n\tahc->features = AHC_AIC7880_FE;\n\tahc->bugs |= AHC_TMODE_WIDEODD_BUG;\n\trev = ahc_pci_read_config(pci, PCIR_REVID,  1);\n\tif (rev >= 1) {\n\t\tahc->bugs |= AHC_PCI_2_1_RETRY_BUG;\n\t} else {\n\t\tahc->bugs |= AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;\n\t}\n\tahc->instruction_ram_size = 512;\n\treturn (0);\n}\n\nstatic int\nahc_aic7880h_setup(struct ahc_softc *ahc)\n{\n\tint error = ahc_aic7880_setup(ahc);\n\n\tahc->features |= AHC_HVD;\n\n\treturn error;\n}\n\n\nstatic int\nahc_aha2940Pro_setup(struct ahc_softc *ahc)\n{\n\n\tahc->flags |= AHC_INT50_SPEEDFLEX;\n\treturn (ahc_aic7880_setup(ahc));\n}\n\nstatic int\nahc_aha394XU_setup(struct ahc_softc *ahc)\n{\n\tint error;\n\n\terror = ahc_aic7880_setup(ahc);\n\tif (error == 0)\n\t\terror = ahc_aha394XX_setup(ahc);\n\treturn (error);\n}\n\nstatic int\nahc_aha394XUh_setup(struct ahc_softc *ahc)\n{\n\tint error = ahc_aha394XU_setup(ahc);\n\n\tahc->features |= AHC_HVD;\n\n\treturn error;\n}\n\nstatic int\nahc_aha398XU_setup(struct ahc_softc *ahc)\n{\n\tint error;\n\n\terror = ahc_aic7880_setup(ahc);\n\tif (error == 0)\n\t\terror = ahc_aha398XX_setup(ahc);\n\treturn (error);\n}\n\nstatic int\nahc_aic7890_setup(struct ahc_softc *ahc)\n{\n\tahc_dev_softc_t pci;\n\tuint8_t rev;\n\n\tpci = ahc->dev_softc;\n\tahc->channel = 'A';\n\tahc->chip = AHC_AIC7890;\n\tahc->features = AHC_AIC7890_FE;\n\tahc->flags |= AHC_NEWEEPROM_FMT;\n\trev = ahc_pci_read_config(pci, PCIR_REVID,  1);\n\tif (rev == 0)\n\t\tahc->bugs |= AHC_AUTOFLUSH_BUG|AHC_CACHETHEN_BUG;\n\tahc->instruction_ram_size = 768;\n\treturn (0);\n}\n\nstatic int\nahc_aic7892_setup(struct ahc_softc *ahc)\n{\n\n\tahc->channel = 'A';\n\tahc->chip = AHC_AIC7892;\n\tahc->features = AHC_AIC7892_FE;\n\tahc->flags |= AHC_NEWEEPROM_FMT;\n\tahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;\n\tahc->instruction_ram_size = 1024;\n\treturn (0);\n}\n\nstatic int\nahc_aic7895_setup(struct ahc_softc *ahc)\n{\n\tahc_dev_softc_t pci;\n\tuint8_t rev;\n\n\tpci = ahc->dev_softc;\n\tahc->channel = ahc_get_pci_function(pci) == 1 ? 'B' : 'A';\n\t \n\trev = ahc_pci_read_config(pci, PCIR_REVID,  1);\n\tif (rev >= 4) {\n\t\tahc->chip = AHC_AIC7895C;\n\t\tahc->features = AHC_AIC7895C_FE;\n\t} else  {\n\t\tu_int command;\n\n\t\tahc->chip = AHC_AIC7895;\n\t\tahc->features = AHC_AIC7895_FE;\n\n\t\t \n\t\tcommand = ahc_pci_read_config(pci, PCIR_COMMAND,  1);\n\t\tcommand |= PCIM_CMD_MWRICEN;\n\t\tahc_pci_write_config(pci, PCIR_COMMAND, command,  1);\n\t\tahc->bugs |= AHC_PCI_MWI_BUG;\n\t}\n\t \n\tahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_PCI_2_1_RETRY_BUG\n\t\t  |  AHC_CACHETHEN_BUG;\n\n#if 0\n\tuint32_t devconfig;\n\n\t \n\tahc_pci_write_config(pci, CSIZE_LATTIME, 0,  1);\n\tdevconfig = ahc_pci_read_config(pci, DEVCONFIG,  1);\n\tdevconfig |= MRDCEN;\n\tahc_pci_write_config(pci, DEVCONFIG, devconfig,  1);\n#endif\n\tahc->flags |= AHC_NEWEEPROM_FMT;\n\tahc->instruction_ram_size = 512;\n\treturn (0);\n}\n\nstatic int\nahc_aic7895h_setup(struct ahc_softc *ahc)\n{\n\tint error = ahc_aic7895_setup(ahc);\n\n\tahc->features |= AHC_HVD;\n\n\treturn error;\n}\n\nstatic int\nahc_aic7896_setup(struct ahc_softc *ahc)\n{\n\tahc_dev_softc_t pci;\n\n\tpci = ahc->dev_softc;\n\tahc->channel = ahc_get_pci_function(pci) == 1 ? 'B' : 'A';\n\tahc->chip = AHC_AIC7896;\n\tahc->features = AHC_AIC7896_FE;\n\tahc->flags |= AHC_NEWEEPROM_FMT;\n\tahc->bugs |= AHC_CACHETHEN_DIS_BUG;\n\tahc->instruction_ram_size = 768;\n\treturn (0);\n}\n\nstatic int\nahc_aic7899_setup(struct ahc_softc *ahc)\n{\n\tahc_dev_softc_t pci;\n\n\tpci = ahc->dev_softc;\n\tahc->channel = ahc_get_pci_function(pci) == 1 ? 'B' : 'A';\n\tahc->chip = AHC_AIC7899;\n\tahc->features = AHC_AIC7899_FE;\n\tahc->flags |= AHC_NEWEEPROM_FMT;\n\tahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;\n\tahc->instruction_ram_size = 1024;\n\treturn (0);\n}\n\nstatic int\nahc_aha29160C_setup(struct ahc_softc *ahc)\n{\n\tint error;\n\n\terror = ahc_aic7899_setup(ahc);\n\tif (error != 0)\n\t\treturn (error);\n\tahc->features |= AHC_REMOVABLE;\n\treturn (0);\n}\n\nstatic int\nahc_raid_setup(struct ahc_softc *ahc)\n{\n\tprintk(\"RAID functionality unsupported\\n\");\n\treturn (ENXIO);\n}\n\nstatic int\nahc_aha394XX_setup(struct ahc_softc *ahc)\n{\n\tahc_dev_softc_t pci;\n\n\tpci = ahc->dev_softc;\n\tswitch (ahc_get_pci_slot(pci)) {\n\tcase AHC_394X_SLOT_CHANNEL_A:\n\t\tahc->channel = 'A';\n\t\tbreak;\n\tcase AHC_394X_SLOT_CHANNEL_B:\n\t\tahc->channel = 'B';\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"adapter at unexpected slot %d\\n\"\n\t\t       \"unable to map to a channel\\n\",\n\t\t       ahc_get_pci_slot(pci));\n\t\tahc->channel = 'A';\n\t}\n\treturn (0);\n}\n\nstatic int\nahc_aha398XX_setup(struct ahc_softc *ahc)\n{\n\tahc_dev_softc_t pci;\n\n\tpci = ahc->dev_softc;\n\tswitch (ahc_get_pci_slot(pci)) {\n\tcase AHC_398X_SLOT_CHANNEL_A:\n\t\tahc->channel = 'A';\n\t\tbreak;\n\tcase AHC_398X_SLOT_CHANNEL_B:\n\t\tahc->channel = 'B';\n\t\tbreak;\n\tcase AHC_398X_SLOT_CHANNEL_C:\n\t\tahc->channel = 'C';\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"adapter at unexpected slot %d\\n\"\n\t\t       \"unable to map to a channel\\n\",\n\t\t       ahc_get_pci_slot(pci));\n\t\tahc->channel = 'A';\n\t\tbreak;\n\t}\n\tahc->flags |= AHC_LARGE_SEEPROM;\n\treturn (0);\n}\n\nstatic int\nahc_aha494XX_setup(struct ahc_softc *ahc)\n{\n\tahc_dev_softc_t pci;\n\n\tpci = ahc->dev_softc;\n\tswitch (ahc_get_pci_slot(pci)) {\n\tcase AHC_494X_SLOT_CHANNEL_A:\n\t\tahc->channel = 'A';\n\t\tbreak;\n\tcase AHC_494X_SLOT_CHANNEL_B:\n\t\tahc->channel = 'B';\n\t\tbreak;\n\tcase AHC_494X_SLOT_CHANNEL_C:\n\t\tahc->channel = 'C';\n\t\tbreak;\n\tcase AHC_494X_SLOT_CHANNEL_D:\n\t\tahc->channel = 'D';\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"adapter at unexpected slot %d\\n\"\n\t\t       \"unable to map to a channel\\n\",\n\t\t       ahc_get_pci_slot(pci));\n\t\tahc->channel = 'A';\n\t}\n\tahc->flags |= AHC_LARGE_SEEPROM;\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}