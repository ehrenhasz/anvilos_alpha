{
  "module_name": "aic7xxx_osm.c",
  "hash_id": "f3a3ce6494b845ac9cc614b34d9346ab60e313be834cc48a6e1243be782f9b64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic7xxx_osm.c",
  "human_readable_source": "\n \n\n \n\n#include \"aic7xxx_osm.h\"\n#include \"aic7xxx_inline.h\"\n#include <scsi/scsicam.h>\n\nstatic struct scsi_transport_template *ahc_linux_transport_template = NULL;\n\n#include <linux/init.h>\t\t \n#include <linux/mm.h>\t\t \n#include <linux/blkdev.h>\t\t \n#include <linux/delay.h>\t \n#include <linux/slab.h>\n\n\n \n#ifdef CONFIG_AIC7XXX_RESET_DELAY_MS\n#define AIC7XXX_RESET_DELAY CONFIG_AIC7XXX_RESET_DELAY_MS\n#else\n#define AIC7XXX_RESET_DELAY 5000\n#endif\n\n \ntypedef struct {\n\tuint8_t tag_commands[16];\t \n} adapter_tag_info_t;\n\n \n\n \n\n#ifdef CONFIG_AIC7XXX_CMDS_PER_DEVICE\n#define AIC7XXX_CMDS_PER_DEVICE CONFIG_AIC7XXX_CMDS_PER_DEVICE\n#else\n#define AIC7XXX_CMDS_PER_DEVICE AHC_MAX_QUEUE\n#endif\n\n#define AIC7XXX_CONFIGED_TAG_COMMANDS {\t\t\t\t\t\\\n\tAIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,\t\t\\\n\tAIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,\t\t\\\n\tAIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,\t\t\\\n\tAIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,\t\t\\\n\tAIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,\t\t\\\n\tAIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,\t\t\\\n\tAIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,\t\t\\\n\tAIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE\t\t\\\n}\n\n \nstatic adapter_tag_info_t aic7xxx_tag_info[] =\n{\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS},\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS},\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS},\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS},\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS},\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS},\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS},\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS},\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS},\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS},\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS},\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS},\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS},\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS},\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS},\n\t{AIC7XXX_CONFIGED_TAG_COMMANDS}\n};\n\n \n#define DID_UNDERFLOW   DID_ERROR\n\nvoid\nahc_print_path(struct ahc_softc *ahc, struct scb *scb)\n{\n\tprintk(\"(scsi%d:%c:%d:%d): \",\n\t       ahc->platform_data->host->host_no,\n\t       scb != NULL ? SCB_GET_CHANNEL(ahc, scb) : 'X',\n\t       scb != NULL ? SCB_GET_TARGET(ahc, scb) : -1,\n\t       scb != NULL ? SCB_GET_LUN(scb) : -1);\n}\n\n \n\n \nstatic uint32_t aic7xxx_no_reset;\n\n \nstatic uint32_t aic7xxx_extended;\n\n \nstatic uint32_t aic7xxx_pci_parity = ~0;\n\n \nuint32_t aic7xxx_allow_memio = ~0;\n\n \nstatic uint32_t aic7xxx_seltime;\n\n \nstatic uint32_t aic7xxx_periodic_otag;\n\n \nstatic char *aic7xxx = NULL;\n\nMODULE_AUTHOR(\"Maintainer: Hannes Reinecke <hare@suse.de>\");\nMODULE_DESCRIPTION(\"Adaptec AIC77XX/78XX SCSI Host Bus Adapter driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_VERSION(AIC7XXX_DRIVER_VERSION);\nmodule_param(aic7xxx, charp, 0444);\nMODULE_PARM_DESC(aic7xxx,\n\"period-delimited options string:\\n\"\n\"\tverbose\t\t\tEnable verbose/diagnostic logging\\n\"\n\"\tallow_memio\t\tAllow device registers to be memory mapped\\n\"\n\"\tdebug\t\t\tBitmask of debug values to enable\\n\"\n\"\tno_probe\t\tToggle EISA/VLB controller probing\\n\"\n\"\tprobe_eisa_vl\t\tToggle EISA/VLB controller probing\\n\"\n\"\tno_reset\t\tSuppress initial bus resets\\n\"\n\"\textended\t\tEnable extended geometry on all controllers\\n\"\n\"\tperiodic_otag\t\tSend an ordered tagged transaction\\n\"\n\"\t\t\t\tperiodically to prevent tag starvation.\\n\"\n\"\t\t\t\tThis may be required by some older disk\\n\"\n\"\t\t\t\tdrives or RAID arrays.\\n\"\n\"\ttag_info:<tag_str>\tSet per-target tag depth\\n\"\n\"\tglobal_tag_depth:<int>\tGlobal tag depth for every target\\n\"\n\"\t\t\t\ton every bus\\n\"\n\"\tseltime:<int>\t\tSelection Timeout\\n\"\n\"\t\t\t\t(0/256ms,1/128ms,2/64ms,3/32ms)\\n\"\n\"\\n\"\n\"\tSample modprobe configuration file:\\n\"\n\"\t#\tToggle EISA/VLB probing\\n\"\n\"\t#\tSet tag depth on Controller 1/Target 1 to 10 tags\\n\"\n\"\t#\tShorten the selection timeout to 128ms\\n\"\n\"\\n\"\n\"\toptions aic7xxx 'aic7xxx=probe_eisa_vl.tag_info:{{}.{.10}}.seltime:1'\\n\"\n);\n\nstatic void ahc_linux_handle_scsi_status(struct ahc_softc *,\n\t\t\t\t\t struct scsi_device *,\n\t\t\t\t\t struct scb *);\nstatic void ahc_linux_queue_cmd_complete(struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_cmnd *cmd);\nstatic void ahc_linux_freeze_simq(struct ahc_softc *ahc);\nstatic void ahc_linux_release_simq(struct ahc_softc *ahc);\nstatic int  ahc_linux_queue_recovery_cmd(struct scsi_cmnd *cmd, scb_flag flag);\nstatic void ahc_linux_initialize_scsi_bus(struct ahc_softc *ahc);\nstatic u_int ahc_linux_user_tagdepth(struct ahc_softc *ahc,\n\t\t\t\t     struct ahc_devinfo *devinfo);\nstatic void ahc_linux_device_queue_depth(struct scsi_device *);\nstatic int ahc_linux_run_command(struct ahc_softc*,\n\t\t\t\t struct ahc_linux_device *,\n\t\t\t\t struct scsi_cmnd *);\nstatic void ahc_linux_setup_tag_info_global(char *p);\nstatic int  aic7xxx_setup(char *s);\n\nstatic int ahc_linux_unit;\n\n\n \nvoid\nahc_delay(long usec)\n{\n\t \n\twhile (usec > 0) {\n\t\tudelay(usec % 1024);\n\t\tusec -= 1024;\n\t}\n}\n\n \nuint8_t\nahc_inb(struct ahc_softc * ahc, long port)\n{\n\tuint8_t x;\n\n\tif (ahc->tag == BUS_SPACE_MEMIO) {\n\t\tx = readb(ahc->bsh.maddr + port);\n\t} else {\n\t\tx = inb(ahc->bsh.ioport + port);\n\t}\n\tmb();\n\treturn (x);\n}\n\nvoid\nahc_outb(struct ahc_softc * ahc, long port, uint8_t val)\n{\n\tif (ahc->tag == BUS_SPACE_MEMIO) {\n\t\twriteb(val, ahc->bsh.maddr + port);\n\t} else {\n\t\toutb(val, ahc->bsh.ioport + port);\n\t}\n\tmb();\n}\n\nvoid\nahc_outsb(struct ahc_softc * ahc, long port, uint8_t *array, int count)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < count; i++)\n\t\tahc_outb(ahc, port, *array++);\n}\n\nvoid\nahc_insb(struct ahc_softc * ahc, long port, uint8_t *array, int count)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < count; i++)\n\t\t*array++ = ahc_inb(ahc, port);\n}\n\n \nstatic void ahc_linux_unmap_scb(struct ahc_softc*, struct scb*);\n\nstatic int ahc_linux_map_seg(struct ahc_softc *ahc, struct scb *scb,\n\t\t\t\t      struct ahc_dma_seg *sg,\n\t\t\t\t      dma_addr_t addr, bus_size_t len);\n\nstatic void\nahc_linux_unmap_scb(struct ahc_softc *ahc, struct scb *scb)\n{\n\tstruct scsi_cmnd *cmd;\n\n\tcmd = scb->io_ctx;\n\tahc_sync_sglist(ahc, scb, BUS_DMASYNC_POSTWRITE);\n\n\tscsi_dma_unmap(cmd);\n}\n\nstatic int\nahc_linux_map_seg(struct ahc_softc *ahc, struct scb *scb,\n\t\t  struct ahc_dma_seg *sg, dma_addr_t addr, bus_size_t len)\n{\n\tint\t consumed;\n\n\tif ((scb->sg_count + 1) > AHC_NSEG)\n\t\tpanic(\"Too few segs for dma mapping.  \"\n\t\t      \"Increase AHC_NSEG\\n\");\n\n\tconsumed = 1;\n\tsg->addr = ahc_htole32(addr & 0xFFFFFFFF);\n\tscb->platform_data->xfer_len += len;\n\n\tif (sizeof(dma_addr_t) > 4\n\t && (ahc->flags & AHC_39BIT_ADDRESSING) != 0)\n\t\tlen |= (addr >> 8) & AHC_SG_HIGH_ADDR_MASK;\n\n\tsg->len = ahc_htole32(len);\n\treturn (consumed);\n}\n\n \nstatic const char *\nahc_linux_info(struct Scsi_Host *host)\n{\n\tstatic char buffer[512];\n\tchar\tahc_info[256];\n\tchar   *bp;\n\tstruct ahc_softc *ahc;\n\n\tbp = &buffer[0];\n\tahc = *(struct ahc_softc **)host->hostdata;\n\tmemset(bp, 0, sizeof(buffer));\n\tstrcpy(bp, \"Adaptec AIC7XXX EISA/VLB/PCI SCSI HBA DRIVER, Rev \" AIC7XXX_DRIVER_VERSION \"\\n\"\n\t\t\t\"        <\");\n\tstrcat(bp, ahc->description);\n\tstrcat(bp, \">\\n\"\n\t\t\t\"        \");\n\tahc_controller_info(ahc, ahc_info);\n\tstrcat(bp, ahc_info);\n\tstrcat(bp, \"\\n\");\n\n\treturn (bp);\n}\n\n \nstatic int ahc_linux_queue_lck(struct scsi_cmnd *cmd)\n{\n\tstruct\t ahc_softc *ahc;\n\tstruct\t ahc_linux_device *dev = scsi_transport_device_data(cmd->device);\n\tint rtn = SCSI_MLQUEUE_HOST_BUSY;\n\tunsigned long flags;\n\n\tahc = *(struct ahc_softc **)cmd->device->host->hostdata;\n\n\tahc_lock(ahc, &flags);\n\tif (ahc->platform_data->qfrozen == 0) {\n\t\tcmd->result = CAM_REQ_INPROG << 16;\n\t\trtn = ahc_linux_run_command(ahc, dev, cmd);\n\t}\n\tahc_unlock(ahc, &flags);\n\n\treturn rtn;\n}\n\nstatic DEF_SCSI_QCMD(ahc_linux_queue)\n\nstatic inline struct scsi_target **\nahc_linux_target_in_softc(struct scsi_target *starget)\n{\n\tstruct\tahc_softc *ahc =\n\t\t*((struct ahc_softc **)dev_to_shost(&starget->dev)->hostdata);\n\tunsigned int target_offset;\n\n\ttarget_offset = starget->id;\n\tif (starget->channel != 0)\n\t\ttarget_offset += 8;\n\n\treturn &ahc->platform_data->starget[target_offset];\n}\n\nstatic int\nahc_linux_target_alloc(struct scsi_target *starget)\n{\n\tstruct\tahc_softc *ahc =\n\t\t*((struct ahc_softc **)dev_to_shost(&starget->dev)->hostdata);\n\tstruct seeprom_config *sc = ahc->seep_config;\n\tunsigned long flags;\n\tstruct scsi_target **ahc_targp = ahc_linux_target_in_softc(starget);\n\tunsigned short scsirate;\n\tstruct ahc_devinfo devinfo;\n\tchar channel = starget->channel + 'A';\n\tunsigned int our_id = ahc->our_id;\n\tunsigned int target_offset;\n\n\ttarget_offset = starget->id;\n\tif (starget->channel != 0)\n\t\ttarget_offset += 8;\n\n\tif (starget->channel)\n\t\tour_id = ahc->our_id_b;\n\n\tahc_lock(ahc, &flags);\n\n\tBUG_ON(*ahc_targp != NULL);\n\n\t*ahc_targp = starget;\n\n\tif (sc) {\n\t\tint maxsync = AHC_SYNCRATE_DT;\n\t\tint ultra = 0;\n\t\tint flags = sc->device_flags[target_offset];\n\n\t\tif (ahc->flags & AHC_NEWEEPROM_FMT) {\n\t\t    if (flags & CFSYNCHISULTRA)\n\t\t\tultra = 1;\n\t\t} else if (flags & CFULTRAEN)\n\t\t\tultra = 1;\n\t\t \n\t\tif(ultra && (flags & CFXFER) == 0x04) {\n\t\t\tultra = 0;\n\t\t\tflags &= ~CFXFER;\n\t\t}\n\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tscsirate = (flags & CFXFER) | (ultra ? 0x8 : 0);\n\t\t} else {\n\t\t\tscsirate = (flags & CFXFER) << 4;\n\t\t\tmaxsync = ultra ? AHC_SYNCRATE_ULTRA :\n\t\t\t\tAHC_SYNCRATE_FAST;\n\t\t}\n\t\tspi_max_width(starget) = (flags & CFWIDEB) ? 1 : 0;\n\t\tif (!(flags & CFSYNCH))\n\t\t\tspi_max_offset(starget) = 0;\n\t\tspi_min_period(starget) =\n\t\t\tahc_find_period(ahc, scsirate, maxsync);\n\t}\n\tahc_compile_devinfo(&devinfo, our_id, starget->id,\n\t\t\t    CAM_LUN_WILDCARD, channel,\n\t\t\t    ROLE_INITIATOR);\n\tahc_set_syncrate(ahc, &devinfo, NULL, 0, 0, 0,\n\t\t\t AHC_TRANS_GOAL,  FALSE);\n\tahc_set_width(ahc, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t      AHC_TRANS_GOAL,  FALSE);\n\tahc_unlock(ahc, &flags);\n\n\treturn 0;\n}\n\nstatic void\nahc_linux_target_destroy(struct scsi_target *starget)\n{\n\tstruct scsi_target **ahc_targp = ahc_linux_target_in_softc(starget);\n\n\t*ahc_targp = NULL;\n}\n\nstatic int\nahc_linux_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct\tahc_softc *ahc =\n\t\t*((struct ahc_softc **)sdev->host->hostdata);\n\tstruct scsi_target *starget = sdev->sdev_target;\n\tstruct ahc_linux_device *dev;\n\n\tif (bootverbose)\n\t\tprintk(\"%s: Slave Alloc %d\\n\", ahc_name(ahc), sdev->id);\n\n\tdev = scsi_transport_device_data(sdev);\n\tmemset(dev, 0, sizeof(*dev));\n\n\t \n\tdev->openings = 1;\n\n\t \n\tdev->maxtags = 0;\n\n\tspi_period(starget) = 0;\n\n\treturn 0;\n}\n\nstatic int\nahc_linux_slave_configure(struct scsi_device *sdev)\n{\n\tif (bootverbose)\n\t\tsdev_printk(KERN_INFO, sdev, \"Slave Configure\\n\");\n\n\tahc_linux_device_queue_depth(sdev);\n\n\t \n\tif (!spi_initial_dv(sdev->sdev_target))\n\t\tspi_dv_device(sdev);\n\n\treturn 0;\n}\n\n#if defined(__i386__)\n \nstatic int\nahc_linux_biosparam(struct scsi_device *sdev, struct block_device *bdev,\n\t\t    sector_t capacity, int geom[])\n{\n\tint\t heads;\n\tint\t sectors;\n\tint\t cylinders;\n\tint\t extended;\n\tstruct\t ahc_softc *ahc;\n\tu_int\t channel;\n\n\tahc = *((struct ahc_softc **)sdev->host->hostdata);\n\tchannel = sdev_channel(sdev);\n\n\tif (scsi_partsize(bdev, capacity, geom))\n\t\treturn 0;\n\n\theads = 64;\n\tsectors = 32;\n\tcylinders = aic_sector_div(capacity, heads, sectors);\n\n\tif (aic7xxx_extended != 0)\n\t\textended = 1;\n\telse if (channel == 0)\n\t\textended = (ahc->flags & AHC_EXTENDED_TRANS_A) != 0;\n\telse\n\t\textended = (ahc->flags & AHC_EXTENDED_TRANS_B) != 0;\n\tif (extended && cylinders >= 1024) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\tcylinders = aic_sector_div(capacity, heads, sectors);\n\t}\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\treturn (0);\n}\n#endif\n\n \nstatic int\nahc_linux_abort(struct scsi_cmnd *cmd)\n{\n\tint error;\n\n\terror = ahc_linux_queue_recovery_cmd(cmd, SCB_ABORT);\n\tif (error != SUCCESS)\n\t\tprintk(\"aic7xxx_abort returns 0x%x\\n\", error);\n\treturn (error);\n}\n\n \nstatic int\nahc_linux_dev_reset(struct scsi_cmnd *cmd)\n{\n\tint error;\n\n\terror = ahc_linux_queue_recovery_cmd(cmd, SCB_DEVICE_RESET);\n\tif (error != SUCCESS)\n\t\tprintk(\"aic7xxx_dev_reset returns 0x%x\\n\", error);\n\treturn (error);\n}\n\n \nstatic int\nahc_linux_bus_reset(struct scsi_cmnd *cmd)\n{\n\tstruct ahc_softc *ahc;\n\tint    found;\n\tunsigned long flags;\n\n\tahc = *(struct ahc_softc **)cmd->device->host->hostdata;\n\n\tahc_lock(ahc, &flags);\n\tfound = ahc_reset_channel(ahc, scmd_channel(cmd) + 'A',\n\t\t\t\t   TRUE);\n\tahc_unlock(ahc, &flags);\n\n\tif (bootverbose)\n\t\tprintk(\"%s: SCSI bus reset delivered. \"\n\t\t       \"%d SCBs aborted.\\n\", ahc_name(ahc), found);\n\n\treturn SUCCESS;\n}\n\nstruct scsi_host_template aic7xxx_driver_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"aic7xxx\",\n\t.proc_name\t\t= \"aic7xxx\",\n\t.show_info\t\t= ahc_linux_show_info,\n\t.write_info\t\t= ahc_proc_write_seeprom,\n\t.info\t\t\t= ahc_linux_info,\n\t.queuecommand\t\t= ahc_linux_queue,\n\t.eh_abort_handler\t= ahc_linux_abort,\n\t.eh_device_reset_handler = ahc_linux_dev_reset,\n\t.eh_bus_reset_handler\t= ahc_linux_bus_reset,\n#if defined(__i386__)\n\t.bios_param\t\t= ahc_linux_biosparam,\n#endif\n\t.can_queue\t\t= AHC_MAX_QUEUE,\n\t.this_id\t\t= -1,\n\t.max_sectors\t\t= 8192,\n\t.cmd_per_lun\t\t= 2,\n\t.slave_alloc\t\t= ahc_linux_slave_alloc,\n\t.slave_configure\t= ahc_linux_slave_configure,\n\t.target_alloc\t\t= ahc_linux_target_alloc,\n\t.target_destroy\t\t= ahc_linux_target_destroy,\n};\n\n \n\n \n#define BUILD_SCSIID(ahc, cmd)\t\t\t\t\t\t    \\\n\t((((cmd)->device->id << TID_SHIFT) & TID)\t\t\t    \\\n\t| (((cmd)->device->channel == 0) ? (ahc)->our_id : (ahc)->our_id_b) \\\n\t| (((cmd)->device->channel == 0) ? 0 : TWIN_CHNLB))\n\n \nint\nahc_dma_tag_create(struct ahc_softc *ahc, bus_dma_tag_t parent,\n\t\t   bus_size_t alignment, bus_size_t boundary,\n\t\t   dma_addr_t lowaddr, dma_addr_t highaddr,\n\t\t   bus_dma_filter_t *filter, void *filterarg,\n\t\t   bus_size_t maxsize, int nsegments,\n\t\t   bus_size_t maxsegsz, int flags, bus_dma_tag_t *ret_tag)\n{\n\tbus_dma_tag_t dmat;\n\n\tdmat = kmalloc(sizeof(*dmat), GFP_ATOMIC);\n\tif (dmat == NULL)\n\t\treturn (ENOMEM);\n\n\t \n\tdmat->alignment = alignment;\n\tdmat->boundary = boundary;\n\tdmat->maxsize = maxsize;\n\t*ret_tag = dmat;\n\treturn (0);\n}\n\nvoid\nahc_dma_tag_destroy(struct ahc_softc *ahc, bus_dma_tag_t dmat)\n{\n\tkfree(dmat);\n}\n\nint\nahc_dmamem_alloc(struct ahc_softc *ahc, bus_dma_tag_t dmat, void** vaddr,\n\t\t int flags, bus_dmamap_t *mapp)\n{\n\t \n\t*vaddr = dma_alloc_coherent(ahc->dev, dmat->maxsize, mapp, GFP_ATOMIC);\n\tif (*vaddr == NULL)\n\t\treturn ENOMEM;\n\treturn 0;\n}\n\nvoid\nahc_dmamem_free(struct ahc_softc *ahc, bus_dma_tag_t dmat,\n\t\tvoid* vaddr, bus_dmamap_t map)\n{\n\tdma_free_coherent(ahc->dev, dmat->maxsize, vaddr, map);\n}\n\nint\nahc_dmamap_load(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map,\n\t\tvoid *buf, bus_size_t buflen, bus_dmamap_callback_t *cb,\n\t\tvoid *cb_arg, int flags)\n{\n\t \n\tbus_dma_segment_t stack_sg;\n\n\tstack_sg.ds_addr = map;\n\tstack_sg.ds_len = dmat->maxsize;\n\tcb(cb_arg, &stack_sg,  1,  0);\n\treturn (0);\n}\n\nvoid\nahc_dmamap_destroy(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map)\n{\n}\n\nint\nahc_dmamap_unload(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map)\n{\n\t \n\treturn (0);\n}\n\nstatic void\nahc_linux_setup_tag_info_global(char *p)\n{\n\tint tags, i, j;\n\n\ttags = simple_strtoul(p + 1, NULL, 0) & 0xff;\n\tprintk(\"Setting Global Tags= %d\\n\", tags);\n\n\tfor (i = 0; i < ARRAY_SIZE(aic7xxx_tag_info); i++) {\n\t\tfor (j = 0; j < AHC_NUM_TARGETS; j++) {\n\t\t\taic7xxx_tag_info[i].tag_commands[j] = tags;\n\t\t}\n\t}\n}\n\nstatic void\nahc_linux_setup_tag_info(u_long arg, int instance, int targ, int32_t value)\n{\n\n\tif ((instance >= 0) && (targ >= 0)\n\t && (instance < ARRAY_SIZE(aic7xxx_tag_info))\n\t && (targ < AHC_NUM_TARGETS)) {\n\t\taic7xxx_tag_info[instance].tag_commands[targ] = value & 0xff;\n\t\tif (bootverbose)\n\t\t\tprintk(\"tag_info[%d:%d] = %d\\n\", instance, targ, value);\n\t}\n}\n\nstatic char *\nahc_parse_brace_option(char *opt_name, char *opt_arg, char *end, int depth,\n\t\t       void (*callback)(u_long, int, int, int32_t),\n\t\t       u_long callback_arg)\n{\n\tchar\t*tok_end;\n\tchar\t*tok_end2;\n\tint      i;\n\tint      instance;\n\tint\t targ;\n\tint\t done;\n\tchar\t tok_list[] = {'.', ',', '{', '}', '\\0'};\n\n\t \n\tif (*opt_arg != ':')\n\t\treturn (opt_arg);\n\topt_arg++;\n\tinstance = -1;\n\ttarg = -1;\n\tdone = FALSE;\n\t \n\ttok_end = strchr(opt_arg, '\\0');\n\tif (tok_end < end)\n\t\t*tok_end = ',';\n\twhile (!done) {\n\t\tswitch (*opt_arg) {\n\t\tcase '{':\n\t\t\tif (instance == -1) {\n\t\t\t\tinstance = 0;\n\t\t\t} else {\n\t\t\t\tif (depth > 1) {\n\t\t\t\t\tif (targ == -1)\n\t\t\t\t\t\ttarg = 0;\n\t\t\t\t} else {\n\t\t\t\t\tprintk(\"Malformed Option %s\\n\",\n\t\t\t\t\t       opt_name);\n\t\t\t\t\tdone = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\topt_arg++;\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tif (targ != -1)\n\t\t\t\ttarg = -1;\n\t\t\telse if (instance != -1)\n\t\t\t\tinstance = -1;\n\t\t\topt_arg++;\n\t\t\tbreak;\n\t\tcase ',':\n\t\tcase '.':\n\t\t\tif (instance == -1)\n\t\t\t\tdone = TRUE;\n\t\t\telse if (targ >= 0)\n\t\t\t\ttarg++;\n\t\t\telse if (instance >= 0)\n\t\t\t\tinstance++;\n\t\t\topt_arg++;\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\tdone = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttok_end = end;\n\t\t\tfor (i = 0; tok_list[i]; i++) {\n\t\t\t\ttok_end2 = strchr(opt_arg, tok_list[i]);\n\t\t\t\tif ((tok_end2) && (tok_end2 < tok_end))\n\t\t\t\t\ttok_end = tok_end2;\n\t\t\t}\n\t\t\tcallback(callback_arg, instance, targ,\n\t\t\t\t simple_strtol(opt_arg, NULL, 0));\n\t\t\topt_arg = tok_end;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (opt_arg);\n}\n\n \nstatic int\naic7xxx_setup(char *s)\n{\n\tint\ti, n;\n\tchar   *p;\n\tchar   *end;\n\n\tstatic const struct {\n\t\tconst char *name;\n\t\tuint32_t *flag;\n\t} options[] = {\n\t\t{ \"extended\", &aic7xxx_extended },\n\t\t{ \"no_reset\", &aic7xxx_no_reset },\n\t\t{ \"verbose\", &aic7xxx_verbose },\n\t\t{ \"allow_memio\", &aic7xxx_allow_memio},\n#ifdef AHC_DEBUG\n\t\t{ \"debug\", &ahc_debug },\n#endif\n\t\t{ \"periodic_otag\", &aic7xxx_periodic_otag },\n\t\t{ \"pci_parity\", &aic7xxx_pci_parity },\n\t\t{ \"seltime\", &aic7xxx_seltime },\n\t\t{ \"tag_info\", NULL },\n\t\t{ \"global_tag_depth\", NULL },\n\t\t{ \"dv\", NULL }\n\t};\n\n\tend = strchr(s, '\\0');\n\n\t \n\tn = 0;\n\n\twhile ((p = strsep(&s, \",.\")) != NULL) {\n\t\tif (*p == '\\0')\n\t\t\tcontinue;\n\t\tfor (i = 0; i < ARRAY_SIZE(options); i++) {\n\n\t\t\tn = strlen(options[i].name);\n\t\t\tif (strncmp(options[i].name, p, n) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ARRAY_SIZE(options))\n\t\t\tcontinue;\n\n\t\tif (strncmp(p, \"global_tag_depth\", n) == 0) {\n\t\t\tahc_linux_setup_tag_info_global(p + n);\n\t\t} else if (strncmp(p, \"tag_info\", n) == 0) {\n\t\t\ts = ahc_parse_brace_option(\"tag_info\", p + n, end,\n\t\t\t    2, ahc_linux_setup_tag_info, 0);\n\t\t} else if (p[n] == ':') {\n\t\t\t*(options[i].flag) = simple_strtoul(p + n + 1, NULL, 0);\n\t\t} else if (strncmp(p, \"verbose\", n) == 0) {\n\t\t\t*(options[i].flag) = 1;\n\t\t} else {\n\t\t\t*(options[i].flag) ^= 0xFFFFFFFF;\n\t\t}\n\t}\n\treturn 1;\n}\n\n__setup(\"aic7xxx=\", aic7xxx_setup);\n\nuint32_t aic7xxx_verbose;\n\nint\nahc_linux_register_host(struct ahc_softc *ahc, struct scsi_host_template *template)\n{\n\tchar\tbuf[80];\n\tstruct\tScsi_Host *host;\n\tchar\t*new_name;\n\tu_long\ts;\n\tint\tretval;\n\n\ttemplate->name = ahc->description;\n\thost = scsi_host_alloc(template, sizeof(struct ahc_softc *));\n\tif (host == NULL)\n\t\treturn (ENOMEM);\n\n\t*((struct ahc_softc **)host->hostdata) = ahc;\n\tahc->platform_data->host = host;\n\thost->can_queue = AHC_MAX_QUEUE;\n\thost->cmd_per_lun = 2;\n\t \n\thost->this_id = ahc->our_id;\n\thost->irq = ahc->platform_data->irq;\n\thost->max_id = (ahc->features & AHC_WIDE) ? 16 : 8;\n\thost->max_lun = AHC_NUM_LUNS;\n\thost->max_channel = (ahc->features & AHC_TWIN) ? 1 : 0;\n\thost->sg_tablesize = AHC_NSEG;\n\tahc_lock(ahc, &s);\n\tahc_set_unit(ahc, ahc_linux_unit++);\n\tahc_unlock(ahc, &s);\n\tsprintf(buf, \"scsi%d\", host->host_no);\n\tnew_name = kmalloc(strlen(buf) + 1, GFP_ATOMIC);\n\tif (new_name != NULL) {\n\t\tstrcpy(new_name, buf);\n\t\tahc_set_name(ahc, new_name);\n\t}\n\thost->unique_id = ahc->unit;\n\tahc_linux_initialize_scsi_bus(ahc);\n\tahc_intr_enable(ahc, TRUE);\n\n\thost->transportt = ahc_linux_transport_template;\n\n\tretval = scsi_add_host(host, ahc->dev);\n\tif (retval) {\n\t\tprintk(KERN_WARNING \"aic7xxx: scsi_add_host failed\\n\");\n\t\tscsi_host_put(host);\n\t\treturn retval;\n\t}\n\n\tscsi_scan_host(host);\n\treturn 0;\n}\n\n \nstatic void\nahc_linux_initialize_scsi_bus(struct ahc_softc *ahc)\n{\n\tint i;\n\tint numtarg;\n\tunsigned long s;\n\n\ti = 0;\n\tnumtarg = 0;\n\n\tahc_lock(ahc, &s);\n\n\tif (aic7xxx_no_reset != 0)\n\t\tahc->flags &= ~(AHC_RESET_BUS_A|AHC_RESET_BUS_B);\n\n\tif ((ahc->flags & AHC_RESET_BUS_A) != 0)\n\t\tahc_reset_channel(ahc, 'A',  TRUE);\n\telse\n\t\tnumtarg = (ahc->features & AHC_WIDE) ? 16 : 8;\n\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\n\t\tif ((ahc->flags & AHC_RESET_BUS_B) != 0) {\n\t\t\tahc_reset_channel(ahc, 'B',  TRUE);\n\t\t} else {\n\t\t\tif (numtarg == 0)\n\t\t\t\ti = 8;\n\t\t\tnumtarg += 8;\n\t\t}\n\t}\n\n\t \n\tfor (; i < numtarg; i++) {\n\t\tstruct ahc_devinfo devinfo;\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct ahc_tmode_tstate *tstate;\n\t\tu_int our_id;\n\t\tu_int target_id;\n\t\tchar channel;\n\n\t\tchannel = 'A';\n\t\tour_id = ahc->our_id;\n\t\ttarget_id = i;\n\t\tif (i > 7 && (ahc->features & AHC_TWIN) != 0) {\n\t\t\tchannel = 'B';\n\t\t\tour_id = ahc->our_id_b;\n\t\t\ttarget_id = i % 8;\n\t\t}\n\t\ttinfo = ahc_fetch_transinfo(ahc, channel, our_id,\n\t\t\t\t\t    target_id, &tstate);\n\t\tahc_compile_devinfo(&devinfo, our_id, target_id,\n\t\t\t\t    CAM_LUN_WILDCARD, channel, ROLE_INITIATOR);\n\t\tahc_update_neg_request(ahc, &devinfo, tstate,\n\t\t\t\t       tinfo, AHC_NEG_ALWAYS);\n\t}\n\tahc_unlock(ahc, &s);\n\t \n\tif ((ahc->flags & (AHC_RESET_BUS_A|AHC_RESET_BUS_B)) != 0) {\n\t\tahc_linux_freeze_simq(ahc);\n\t\tmsleep(AIC7XXX_RESET_DELAY);\n\t\tahc_linux_release_simq(ahc);\n\t}\n}\n\nint\nahc_platform_alloc(struct ahc_softc *ahc, void *platform_arg)\n{\n\n\tahc->platform_data =\n\t    kzalloc(sizeof(struct ahc_platform_data), GFP_ATOMIC);\n\tif (ahc->platform_data == NULL)\n\t\treturn (ENOMEM);\n\tahc->platform_data->irq = AHC_LINUX_NOIRQ;\n\tahc_lockinit(ahc);\n\tahc->seltime = (aic7xxx_seltime & 0x3) << 4;\n\tahc->seltime_b = (aic7xxx_seltime & 0x3) << 4;\n\tif (aic7xxx_pci_parity == 0)\n\t\tahc->flags |= AHC_DISABLE_PCI_PERR;\n\n\treturn (0);\n}\n\nvoid\nahc_platform_free(struct ahc_softc *ahc)\n{\n\tstruct scsi_target *starget;\n\tint i;\n\n\tif (ahc->platform_data != NULL) {\n\t\t \n\t\tfor (i = 0; i < AHC_NUM_TARGETS; i++) {\n\t\t\tstarget = ahc->platform_data->starget[i];\n\t\t\tif (starget != NULL) {\n\t\t\t\tahc->platform_data->starget[i] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (ahc->platform_data->irq != AHC_LINUX_NOIRQ)\n\t\t\tfree_irq(ahc->platform_data->irq, ahc);\n\t\tif (ahc->tag == BUS_SPACE_PIO\n\t\t && ahc->bsh.ioport != 0)\n\t\t\trelease_region(ahc->bsh.ioport, 256);\n\t\tif (ahc->tag == BUS_SPACE_MEMIO\n\t\t && ahc->bsh.maddr != NULL) {\n\t\t\tiounmap(ahc->bsh.maddr);\n\t\t\trelease_mem_region(ahc->platform_data->mem_busaddr,\n\t\t\t\t\t   0x1000);\n\t\t}\n\n\t\tif (ahc->platform_data->host)\n\t\t\tscsi_host_put(ahc->platform_data->host);\n\n\t\tkfree(ahc->platform_data);\n\t}\n}\n\nvoid\nahc_platform_freeze_devq(struct ahc_softc *ahc, struct scb *scb)\n{\n\tahc_platform_abort_scbs(ahc, SCB_GET_TARGET(ahc, scb),\n\t\t\t\tSCB_GET_CHANNEL(ahc, scb),\n\t\t\t\tSCB_GET_LUN(scb), SCB_LIST_NULL,\n\t\t\t\tROLE_UNKNOWN, CAM_REQUEUE_REQ);\n}\n\nvoid\nahc_platform_set_tags(struct ahc_softc *ahc, struct scsi_device *sdev,\n\t\t      struct ahc_devinfo *devinfo, ahc_queue_alg alg)\n{\n\tstruct ahc_linux_device *dev;\n\tint was_queuing;\n\tint now_queuing;\n\n\tif (sdev == NULL)\n\t\treturn;\n\tdev = scsi_transport_device_data(sdev);\n\n\twas_queuing = dev->flags & (AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED);\n\tswitch (alg) {\n\tdefault:\n\tcase AHC_QUEUE_NONE:\n\t\tnow_queuing = 0;\n\t\tbreak;\n\tcase AHC_QUEUE_BASIC:\n\t\tnow_queuing = AHC_DEV_Q_BASIC;\n\t\tbreak;\n\tcase AHC_QUEUE_TAGGED:\n\t\tnow_queuing = AHC_DEV_Q_TAGGED;\n\t\tbreak;\n\t}\n\tif ((dev->flags & AHC_DEV_FREEZE_TIL_EMPTY) == 0\n\t && (was_queuing != now_queuing)\n\t && (dev->active != 0)) {\n\t\tdev->flags |= AHC_DEV_FREEZE_TIL_EMPTY;\n\t\tdev->qfrozen++;\n\t}\n\n\tdev->flags &= ~(AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED|AHC_DEV_PERIODIC_OTAG);\n\tif (now_queuing) {\n\t\tu_int usertags;\n\n\t\tusertags = ahc_linux_user_tagdepth(ahc, devinfo);\n\t\tif (!was_queuing) {\n\t\t\t \n\t\t\tdev->maxtags = usertags;\n\t\t\tdev->openings = dev->maxtags - dev->active;\n\t\t}\n\t\tif (dev->maxtags == 0) {\n\t\t\t \n\t\t\tdev->openings = 1;\n\t\t} else if (alg == AHC_QUEUE_TAGGED) {\n\t\t\tdev->flags |= AHC_DEV_Q_TAGGED;\n\t\t\tif (aic7xxx_periodic_otag != 0)\n\t\t\t\tdev->flags |= AHC_DEV_PERIODIC_OTAG;\n\t\t} else\n\t\t\tdev->flags |= AHC_DEV_Q_BASIC;\n\t} else {\n\t\t \n\t\tdev->maxtags = 0;\n\t\tdev->openings =  1 - dev->active;\n\t}\n\tswitch ((dev->flags & (AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED))) {\n\tcase AHC_DEV_Q_BASIC:\n\tcase AHC_DEV_Q_TAGGED:\n\t\tscsi_change_queue_depth(sdev,\n\t\t\t\tdev->openings + dev->active);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tscsi_change_queue_depth(sdev, 2);\n\t\tbreak;\n\t}\n}\n\nint\nahc_platform_abort_scbs(struct ahc_softc *ahc, int target, char channel,\n\t\t\tint lun, u_int tag, role_t role, uint32_t status)\n{\n\treturn 0;\n}\n\nstatic u_int\nahc_linux_user_tagdepth(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\n{\n\tstatic int warned_user;\n\tu_int tags;\n\n\ttags = 0;\n\tif ((ahc->user_discenable & devinfo->target_mask) != 0) {\n\t\tif (ahc->unit >= ARRAY_SIZE(aic7xxx_tag_info)) {\n\t\t\tif (warned_user == 0) {\n\n\t\t\t\tprintk(KERN_WARNING\n\"aic7xxx: WARNING: Insufficient tag_info instances\\n\"\n\"aic7xxx: for installed controllers. Using defaults\\n\"\n\"aic7xxx: Please update the aic7xxx_tag_info array in\\n\"\n\"aic7xxx: the aic7xxx_osm..c source file.\\n\");\n\t\t\t\twarned_user++;\n\t\t\t}\n\t\t\ttags = AHC_MAX_QUEUE;\n\t\t} else {\n\t\t\tadapter_tag_info_t *tag_info;\n\n\t\t\ttag_info = &aic7xxx_tag_info[ahc->unit];\n\t\t\ttags = tag_info->tag_commands[devinfo->target_offset];\n\t\t\tif (tags > AHC_MAX_QUEUE)\n\t\t\t\ttags = AHC_MAX_QUEUE;\n\t\t}\n\t}\n\treturn (tags);\n}\n\n \nstatic void\nahc_linux_device_queue_depth(struct scsi_device *sdev)\n{\n\tstruct\tahc_devinfo devinfo;\n\tu_int\ttags;\n\tstruct ahc_softc *ahc = *((struct ahc_softc **)sdev->host->hostdata);\n\n\tahc_compile_devinfo(&devinfo,\n\t\t\t    sdev->sdev_target->channel == 0\n\t\t\t  ? ahc->our_id : ahc->our_id_b,\n\t\t\t    sdev->sdev_target->id, sdev->lun,\n\t\t\t    sdev->sdev_target->channel == 0 ? 'A' : 'B',\n\t\t\t    ROLE_INITIATOR);\n\ttags = ahc_linux_user_tagdepth(ahc, &devinfo);\n\tif (tags != 0 && sdev->tagged_supported != 0) {\n\n\t\tahc_platform_set_tags(ahc, sdev, &devinfo, AHC_QUEUE_TAGGED);\n\t\tahc_send_async(ahc, devinfo.channel, devinfo.target,\n\t\t\t       devinfo.lun, AC_TRANSFER_NEG);\n\t\tahc_print_devinfo(ahc, &devinfo);\n\t\tprintk(\"Tagged Queuing enabled.  Depth %d\\n\", tags);\n\t} else {\n\t\tahc_platform_set_tags(ahc, sdev, &devinfo, AHC_QUEUE_NONE);\n\t\tahc_send_async(ahc, devinfo.channel, devinfo.target,\n\t\t\t       devinfo.lun, AC_TRANSFER_NEG);\n\t}\n}\n\nstatic int\nahc_linux_run_command(struct ahc_softc *ahc, struct ahc_linux_device *dev,\n\t\t      struct scsi_cmnd *cmd)\n{\n\tstruct\t scb *scb;\n\tstruct\t hardware_scb *hscb;\n\tstruct\t ahc_initiator_tinfo *tinfo;\n\tstruct\t ahc_tmode_tstate *tstate;\n\tuint16_t mask;\n\tstruct scb_tailq *untagged_q = NULL;\n\tint nseg;\n\n\t \n\tif (ahc->platform_data->qfrozen != 0)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\t \n\tif (!(cmd->flags & SCMD_TAGGED)\n\t    && (ahc->features & AHC_SCB_BTT) == 0) {\n\t\tint target_offset;\n\n\t\ttarget_offset = cmd->device->id + cmd->device->channel * 8;\n\t\tuntagged_q = &(ahc->untagged_queues[target_offset]);\n\t\tif (!TAILQ_EMPTY(untagged_q))\n\t\t\t \n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t}\n\n\tnseg = scsi_dma_map(cmd);\n\tif (nseg < 0)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\t \n\tscb = ahc_get_scb(ahc);\n\tif (!scb) {\n\t\tscsi_dma_unmap(cmd);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tscb->io_ctx = cmd;\n\tscb->platform_data->dev = dev;\n\thscb = scb->hscb;\n\tcmd->host_scribble = (char *)scb;\n\n\t \n\thscb->control = 0;\n\thscb->scsiid = BUILD_SCSIID(ahc, cmd);\n\thscb->lun = cmd->device->lun;\n\tmask = SCB_GET_TARGET_MASK(ahc, scb);\n\ttinfo = ahc_fetch_transinfo(ahc, SCB_GET_CHANNEL(ahc, scb),\n\t\t\t\t    SCB_GET_OUR_ID(scb),\n\t\t\t\t    SCB_GET_TARGET(ahc, scb), &tstate);\n\thscb->scsirate = tinfo->scsirate;\n\thscb->scsioffset = tinfo->curr.offset;\n\tif ((tstate->ultraenb & mask) != 0)\n\t\thscb->control |= ULTRAENB;\n\n\tif ((ahc->user_discenable & mask) != 0)\n\t\thscb->control |= DISCENB;\n\n\tif ((tstate->auto_negotiate & mask) != 0) {\n\t\tscb->flags |= SCB_AUTO_NEGOTIATE;\n\t\tscb->hscb->control |= MK_MESSAGE;\n\t}\n\n\tif ((dev->flags & (AHC_DEV_Q_TAGGED|AHC_DEV_Q_BASIC)) != 0) {\n\t\tif (dev->commands_since_idle_or_otag == AHC_OTAG_THRESH\n\t\t\t\t&& (dev->flags & AHC_DEV_Q_TAGGED) != 0) {\n\t\t\thscb->control |= ORDERED_QUEUE_TAG;\n\t\t\tdev->commands_since_idle_or_otag = 0;\n\t\t} else {\n\t\t\thscb->control |= SIMPLE_QUEUE_TAG;\n\t\t}\n\t}\n\n\thscb->cdb_len = cmd->cmd_len;\n\tif (hscb->cdb_len <= 12) {\n\t\tmemcpy(hscb->shared_data.cdb, cmd->cmnd, hscb->cdb_len);\n\t} else {\n\t\tmemcpy(hscb->cdb32, cmd->cmnd, hscb->cdb_len);\n\t\tscb->flags |= SCB_CDB32_PTR;\n\t}\n\n\tscb->platform_data->xfer_len = 0;\n\tahc_set_residual(scb, 0);\n\tahc_set_sense_residual(scb, 0);\n\tscb->sg_count = 0;\n\n\tif (nseg > 0) {\n\t\tstruct\tahc_dma_seg *sg;\n\t\tstruct\tscatterlist *cur_seg;\n\t\tint i;\n\n\t\t \n\t\tsg = scb->sg_list;\n\t\t \n\t\tscsi_for_each_sg(cmd, cur_seg, nseg, i) {\n\t\t\tdma_addr_t addr;\n\t\t\tbus_size_t len;\n\t\t\tint consumed;\n\n\t\t\taddr = sg_dma_address(cur_seg);\n\t\t\tlen = sg_dma_len(cur_seg);\n\t\t\tconsumed = ahc_linux_map_seg(ahc, scb,\n\t\t\t\t\t\t     sg, addr, len);\n\t\t\tsg += consumed;\n\t\t\tscb->sg_count += consumed;\n\t\t}\n\t\tsg--;\n\t\tsg->len |= ahc_htole32(AHC_DMA_LAST_SEG);\n\n\t\t \n\t\tscb->hscb->sgptr =\n\t\t\tahc_htole32(scb->sg_list_phys | SG_FULL_RESID);\n\n\t\t \n\t\tscb->hscb->dataptr = scb->sg_list->addr;\n\t\tscb->hscb->datacnt = scb->sg_list->len;\n\t} else {\n\t\tscb->hscb->sgptr = ahc_htole32(SG_LIST_NULL);\n\t\tscb->hscb->dataptr = 0;\n\t\tscb->hscb->datacnt = 0;\n\t\tscb->sg_count = 0;\n\t}\n\n\tLIST_INSERT_HEAD(&ahc->pending_scbs, scb, pending_links);\n\tdev->openings--;\n\tdev->active++;\n\tdev->commands_issued++;\n\tif ((dev->flags & AHC_DEV_PERIODIC_OTAG) != 0)\n\t\tdev->commands_since_idle_or_otag++;\n\n\tscb->flags |= SCB_ACTIVE;\n\tif (untagged_q) {\n\t\tTAILQ_INSERT_TAIL(untagged_q, scb, links.tqe);\n\t\tscb->flags |= SCB_UNTAGGEDQ;\n\t}\n\tahc_queue_scb(ahc, scb);\n\treturn 0;\n}\n\n \nirqreturn_t\nahc_linux_isr(int irq, void *dev_id)\n{\n\tstruct\tahc_softc *ahc;\n\tu_long\tflags;\n\tint\tours;\n\n\tahc = (struct ahc_softc *) dev_id;\n\tahc_lock(ahc, &flags);\n\tours = ahc_intr(ahc);\n\tahc_unlock(ahc, &flags);\n\treturn IRQ_RETVAL(ours);\n}\n\nvoid\nahc_platform_flushwork(struct ahc_softc *ahc)\n{\n\n}\n\nvoid\nahc_send_async(struct ahc_softc *ahc, char channel,\n\t       u_int target, u_int lun, ac_code code)\n{\n\tswitch (code) {\n\tcase AC_TRANSFER_NEG:\n\t{\n\t\tstruct\tscsi_target *starget;\n\t\tstruct\tahc_initiator_tinfo *tinfo;\n\t\tstruct\tahc_tmode_tstate *tstate;\n\t\tint\ttarget_offset;\n\t\tunsigned int target_ppr_options;\n\n\t\tBUG_ON(target == CAM_TARGET_WILDCARD);\n\n\t\ttinfo = ahc_fetch_transinfo(ahc, channel,\n\t\t\t\t\t\tchannel == 'A' ? ahc->our_id\n\t\t\t\t\t\t\t       : ahc->our_id_b,\n\t\t\t\t\t\ttarget, &tstate);\n\n\t\t \n\t\tif (tinfo->curr.period != tinfo->goal.period\n\t\t || tinfo->curr.width != tinfo->goal.width\n\t\t || tinfo->curr.offset != tinfo->goal.offset\n\t\t || tinfo->curr.ppr_options != tinfo->goal.ppr_options)\n\t\t\tif (bootverbose == 0)\n\t\t\t\tbreak;\n\n\t\t \n\t\ttarget_offset = target;\n\t\tif (channel == 'B')\n\t\t\ttarget_offset += 8;\n\t\tstarget = ahc->platform_data->starget[target_offset];\n\t\tif (starget == NULL)\n\t\t\tbreak;\n\n\t\ttarget_ppr_options =\n\t\t\t(spi_dt(starget) ? MSG_EXT_PPR_DT_REQ : 0)\n\t\t\t+ (spi_qas(starget) ? MSG_EXT_PPR_QAS_REQ : 0)\n\t\t\t+ (spi_iu(starget) ?  MSG_EXT_PPR_IU_REQ : 0);\n\n\t\tif (tinfo->curr.period == spi_period(starget)\n\t\t    && tinfo->curr.width == spi_width(starget)\n\t\t    && tinfo->curr.offset == spi_offset(starget)\n\t\t && tinfo->curr.ppr_options == target_ppr_options)\n\t\t\tif (bootverbose == 0)\n\t\t\t\tbreak;\n\n\t\tspi_period(starget) = tinfo->curr.period;\n\t\tspi_width(starget) = tinfo->curr.width;\n\t\tspi_offset(starget) = tinfo->curr.offset;\n\t\tspi_dt(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_DT_REQ ? 1 : 0;\n\t\tspi_qas(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_QAS_REQ ? 1 : 0;\n\t\tspi_iu(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ ? 1 : 0;\n\t\tspi_display_xfer_agreement(starget);\n\t\tbreak;\n\t}\n\tcase AC_SENT_BDR:\n\t{\n\t\tWARN_ON(lun != CAM_LUN_WILDCARD);\n\t\tscsi_report_device_reset(ahc->platform_data->host,\n\t\t\t\t\t channel - 'A', target);\n\t\tbreak;\n\t}\n\tcase AC_BUS_RESET:\n\t\tif (ahc->platform_data->host != NULL) {\n\t\t\tscsi_report_bus_reset(ahc->platform_data->host,\n\t\t\t\t\t      channel - 'A');\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"ahc_send_async: Unexpected async event\");\n\t}\n}\n\n \nvoid\nahc_done(struct ahc_softc *ahc, struct scb *scb)\n{\n\tstruct scsi_cmnd *cmd;\n\tstruct\t   ahc_linux_device *dev;\n\n\tLIST_REMOVE(scb, pending_links);\n\tif ((scb->flags & SCB_UNTAGGEDQ) != 0) {\n\t\tstruct scb_tailq *untagged_q;\n\t\tint target_offset;\n\n\t\ttarget_offset = SCB_GET_TARGET_OFFSET(ahc, scb);\n\t\tuntagged_q = &(ahc->untagged_queues[target_offset]);\n\t\tTAILQ_REMOVE(untagged_q, scb, links.tqe);\n\t\tBUG_ON(!TAILQ_EMPTY(untagged_q));\n\t} else if ((scb->flags & SCB_ACTIVE) == 0) {\n\t\t \n\t\tprintk(\"SCB %d done'd twice\\n\", scb->hscb->tag);\n\t\tahc_dump_card_state(ahc);\n\t\tpanic(\"Stopping for safety\");\n\t}\n\tcmd = scb->io_ctx;\n\tdev = scb->platform_data->dev;\n\tdev->active--;\n\tdev->openings++;\n\tif ((cmd->result & (CAM_DEV_QFRZN << 16)) != 0) {\n\t\tcmd->result &= ~(CAM_DEV_QFRZN << 16);\n\t\tdev->qfrozen--;\n\t}\n\tahc_linux_unmap_scb(ahc, scb);\n\n\t \n\tcmd->sense_buffer[0] = 0;\n\tif (ahc_get_transaction_status(scb) == CAM_REQ_INPROG) {\n#ifdef AHC_REPORT_UNDERFLOWS\n\t\tuint32_t amount_xferred;\n\n\t\tamount_xferred =\n\t\t    ahc_get_transfer_length(scb) - ahc_get_residual(scb);\n#endif\n\t\tif ((scb->flags & SCB_TRANSMISSION_ERROR) != 0) {\n#ifdef AHC_DEBUG\n\t\t\tif ((ahc_debug & AHC_SHOW_MISC) != 0) {\n\t\t\t\tahc_print_path(ahc, scb);\n\t\t\t\tprintk(\"Set CAM_UNCOR_PARITY\\n\");\n\t\t\t}\n#endif\n\t\t\tahc_set_transaction_status(scb, CAM_UNCOR_PARITY);\n#ifdef AHC_REPORT_UNDERFLOWS\n\t\t \n\t\t} else if (amount_xferred < scb->io_ctx->underflow) {\n\t\t\tu_int i;\n\n\t\t\tahc_print_path(ahc, scb);\n\t\t\tprintk(\"CDB:\");\n\t\t\tfor (i = 0; i < scb->io_ctx->cmd_len; i++)\n\t\t\t\tprintk(\" 0x%x\", scb->io_ctx->cmnd[i]);\n\t\t\tprintk(\"\\n\");\n\t\t\tahc_print_path(ahc, scb);\n\t\t\tprintk(\"Saw underflow (%ld of %ld bytes). \"\n\t\t\t       \"Treated as error\\n\",\n\t\t\t\tahc_get_residual(scb),\n\t\t\t\tahc_get_transfer_length(scb));\n\t\t\tahc_set_transaction_status(scb, CAM_DATA_RUN_ERR);\n#endif\n\t\t} else {\n\t\t\tahc_set_transaction_status(scb, CAM_REQ_CMP);\n\t\t}\n\t} else if (ahc_get_transaction_status(scb) == CAM_SCSI_STATUS_ERROR) {\n\t\tahc_linux_handle_scsi_status(ahc, cmd->device, scb);\n\t}\n\n\tif (dev->openings == 1\n\t && ahc_get_transaction_status(scb) == CAM_REQ_CMP\n\t && ahc_get_scsi_status(scb) != SAM_STAT_TASK_SET_FULL)\n\t\tdev->tag_success_count++;\n\t \n\tif ((dev->openings + dev->active) < dev->maxtags\n\t && dev->tag_success_count > AHC_TAG_SUCCESS_INTERVAL) {\n\t\tdev->tag_success_count = 0;\n\t\tdev->openings++;\n\t}\n\n\tif (dev->active == 0)\n\t\tdev->commands_since_idle_or_otag = 0;\n\n\tif ((scb->flags & SCB_RECOVERY_SCB) != 0) {\n\t\tprintk(\"Recovery SCB completes\\n\");\n\t\tif (ahc_get_transaction_status(scb) == CAM_BDR_SENT\n\t\t || ahc_get_transaction_status(scb) == CAM_REQ_ABORTED)\n\t\t\tahc_set_transaction_status(scb, CAM_CMD_TIMEOUT);\n\n\t\tif (ahc->platform_data->eh_done)\n\t\t\tcomplete(ahc->platform_data->eh_done);\n\t}\n\n\tahc_free_scb(ahc, scb);\n\tahc_linux_queue_cmd_complete(ahc, cmd);\n}\n\nstatic void\nahc_linux_handle_scsi_status(struct ahc_softc *ahc,\n\t\t\t     struct scsi_device *sdev, struct scb *scb)\n{\n\tstruct\tahc_devinfo devinfo;\n\tstruct ahc_linux_device *dev = scsi_transport_device_data(sdev);\n\n\tahc_compile_devinfo(&devinfo,\n\t\t\t    ahc->our_id,\n\t\t\t    sdev->sdev_target->id, sdev->lun,\n\t\t\t    sdev->sdev_target->channel == 0 ? 'A' : 'B',\n\t\t\t    ROLE_INITIATOR);\n\n\t \n\tswitch (ahc_get_scsi_status(scb)) {\n\tdefault:\n\t\tbreak;\n\tcase SAM_STAT_CHECK_CONDITION:\n\tcase SAM_STAT_COMMAND_TERMINATED:\n\t{\n\t\tstruct scsi_cmnd *cmd;\n\n\t\t \n\t\tcmd = scb->io_ctx;\n\t\tif (scb->flags & SCB_SENSE) {\n\t\t\tu_int sense_size;\n\n\t\t\tsense_size = min(sizeof(struct scsi_sense_data)\n\t\t\t\t       - ahc_get_sense_residual(scb),\n\t\t\t\t\t (u_long)SCSI_SENSE_BUFFERSIZE);\n\t\t\tmemcpy(cmd->sense_buffer,\n\t\t\t       ahc_get_sense_buf(ahc, scb), sense_size);\n\t\t\tif (sense_size < SCSI_SENSE_BUFFERSIZE)\n\t\t\t\tmemset(&cmd->sense_buffer[sense_size], 0,\n\t\t\t\t       SCSI_SENSE_BUFFERSIZE - sense_size);\n#ifdef AHC_DEBUG\n\t\t\tif (ahc_debug & AHC_SHOW_SENSE) {\n\t\t\t\tint i;\n\n\t\t\t\tprintk(\"Copied %d bytes of sense data:\",\n\t\t\t\t       sense_size);\n\t\t\t\tfor (i = 0; i < sense_size; i++) {\n\t\t\t\t\tif ((i & 0xF) == 0)\n\t\t\t\t\t\tprintk(\"\\n\");\n\t\t\t\t\tprintk(\"0x%x \", cmd->sense_buffer[i]);\n\t\t\t\t}\n\t\t\t\tprintk(\"\\n\");\n\t\t\t}\n#endif\n\t\t}\n\t\tbreak;\n\t}\n\tcase SAM_STAT_TASK_SET_FULL:\n\t{\n\t\t \n\t\tdev->tag_success_count = 0;\n\t\tif (dev->active != 0) {\n\t\t\t \n\t\t\tdev->openings = 0;\n \n\t\t\tif (dev->active == dev->tags_on_last_queuefull) {\n\n\t\t\t\tdev->last_queuefull_same_count++;\n\t\t\t\t \n\t\t\t\tif (dev->last_queuefull_same_count\n\t\t\t\t == AHC_LOCK_TAGS_COUNT) {\n\t\t\t\t\tdev->maxtags = dev->active;\n\t\t\t\t\tahc_print_path(ahc, scb);\n\t\t\t\t\tprintk(\"Locking max tag count at %d\\n\",\n\t\t\t\t\t       dev->active);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdev->tags_on_last_queuefull = dev->active;\n\t\t\t\tdev->last_queuefull_same_count = 0;\n\t\t\t}\n\t\t\tahc_set_transaction_status(scb, CAM_REQUEUE_REQ);\n\t\t\tahc_set_scsi_status(scb, SAM_STAT_GOOD);\n\t\t\tahc_platform_set_tags(ahc, sdev, &devinfo,\n\t\t\t\t     (dev->flags & AHC_DEV_Q_BASIC)\n\t\t\t\t   ? AHC_QUEUE_BASIC : AHC_QUEUE_TAGGED);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tdev->openings = 1;\n\t\tahc_set_scsi_status(scb, SAM_STAT_BUSY);\n\t\tahc_platform_set_tags(ahc, sdev, &devinfo,\n\t\t\t     (dev->flags & AHC_DEV_Q_BASIC)\n\t\t\t   ? AHC_QUEUE_BASIC : AHC_QUEUE_TAGGED);\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic void\nahc_linux_queue_cmd_complete(struct ahc_softc *ahc, struct scsi_cmnd *cmd)\n{\n\t \n\t{\n\t\tu_int new_status;\n\n\t\tswitch (ahc_cmd_get_transaction_status(cmd)) {\n\t\tcase CAM_REQ_INPROG:\n\t\tcase CAM_REQ_CMP:\n\t\tcase CAM_SCSI_STATUS_ERROR:\n\t\t\tnew_status = DID_OK;\n\t\t\tbreak;\n\t\tcase CAM_REQ_ABORTED:\n\t\t\tnew_status = DID_ABORT;\n\t\t\tbreak;\n\t\tcase CAM_BUSY:\n\t\t\tnew_status = DID_BUS_BUSY;\n\t\t\tbreak;\n\t\tcase CAM_REQ_INVALID:\n\t\tcase CAM_PATH_INVALID:\n\t\t\tnew_status = DID_BAD_TARGET;\n\t\t\tbreak;\n\t\tcase CAM_SEL_TIMEOUT:\n\t\t\tnew_status = DID_NO_CONNECT;\n\t\t\tbreak;\n\t\tcase CAM_SCSI_BUS_RESET:\n\t\tcase CAM_BDR_SENT:\n\t\t\tnew_status = DID_RESET;\n\t\t\tbreak;\n\t\tcase CAM_UNCOR_PARITY:\n\t\t\tnew_status = DID_PARITY;\n\t\t\tbreak;\n\t\tcase CAM_CMD_TIMEOUT:\n\t\t\tnew_status = DID_TIME_OUT;\n\t\t\tbreak;\n\t\tcase CAM_UA_ABORT:\n\t\tcase CAM_REQ_CMP_ERR:\n\t\tcase CAM_AUTOSENSE_FAIL:\n\t\tcase CAM_NO_HBA:\n\t\tcase CAM_DATA_RUN_ERR:\n\t\tcase CAM_UNEXP_BUSFREE:\n\t\tcase CAM_SEQUENCE_FAIL:\n\t\tcase CAM_CCB_LEN_ERR:\n\t\tcase CAM_PROVIDE_FAIL:\n\t\tcase CAM_REQ_TERMIO:\n\t\tcase CAM_UNREC_HBA_ERROR:\n\t\tcase CAM_REQ_TOO_BIG:\n\t\t\tnew_status = DID_ERROR;\n\t\t\tbreak;\n\t\tcase CAM_REQUEUE_REQ:\n\t\t\tnew_status = DID_REQUEUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tnew_status = DID_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tahc_cmd_set_transaction_status(cmd, new_status);\n\t}\n\n\tscsi_done(cmd);\n}\n\nstatic void\nahc_linux_freeze_simq(struct ahc_softc *ahc)\n{\n\tunsigned long s;\n\n\tahc_lock(ahc, &s);\n\tahc->platform_data->qfrozen++;\n\tif (ahc->platform_data->qfrozen == 1) {\n\t\tscsi_block_requests(ahc->platform_data->host);\n\n\t\t \n\t\tahc_platform_abort_scbs(ahc, CAM_TARGET_WILDCARD, ALL_CHANNELS,\n\t\t\t\t\tCAM_LUN_WILDCARD, SCB_LIST_NULL,\n\t\t\t\t\tROLE_INITIATOR, CAM_REQUEUE_REQ);\n\t}\n\tahc_unlock(ahc, &s);\n}\n\nstatic void\nahc_linux_release_simq(struct ahc_softc *ahc)\n{\n\tu_long s;\n\tint    unblock_reqs;\n\n\tunblock_reqs = 0;\n\tahc_lock(ahc, &s);\n\tif (ahc->platform_data->qfrozen > 0)\n\t\tahc->platform_data->qfrozen--;\n\tif (ahc->platform_data->qfrozen == 0)\n\t\tunblock_reqs = 1;\n\tahc_unlock(ahc, &s);\n\t \n\tif (unblock_reqs)\n\t\tscsi_unblock_requests(ahc->platform_data->host);\n}\n\nstatic int\nahc_linux_queue_recovery_cmd(struct scsi_cmnd *cmd, scb_flag flag)\n{\n\tstruct ahc_softc *ahc;\n\tstruct ahc_linux_device *dev;\n\tstruct scb *pending_scb;\n\tu_int  saved_scbptr;\n\tu_int  active_scb_index;\n\tu_int  last_phase;\n\tu_int  saved_scsiid;\n\tu_int  cdb_byte;\n\tint    retval;\n\tint    was_paused;\n\tint    paused;\n\tint    wait;\n\tint    disconnected;\n\tunsigned long flags;\n\n\tpending_scb = NULL;\n\tpaused = FALSE;\n\twait = FALSE;\n\tahc = *(struct ahc_softc **)cmd->device->host->hostdata;\n\n\tscmd_printk(KERN_INFO, cmd, \"Attempting to queue a%s message\\n\",\n\t       flag == SCB_ABORT ? \"n ABORT\" : \" TARGET RESET\");\n\n\tprintk(\"CDB:\");\n\tfor (cdb_byte = 0; cdb_byte < cmd->cmd_len; cdb_byte++)\n\t\tprintk(\" 0x%x\", cmd->cmnd[cdb_byte]);\n\tprintk(\"\\n\");\n\n\tahc_lock(ahc, &flags);\n\n\t \n\tdev = scsi_transport_device_data(cmd->device);\n\n\tif (dev == NULL) {\n\t\t \n\t\tprintk(\"%s:%d:%d:%d: Is not an active device\\n\",\n\t\t       ahc_name(ahc), cmd->device->channel, cmd->device->id,\n\t\t       (u8)cmd->device->lun);\n\t\tretval = SUCCESS;\n\t\tgoto no_cmd;\n\t}\n\n\tif ((dev->flags & (AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED)) == 0\n\t && ahc_search_untagged_queues(ahc, cmd, cmd->device->id,\n\t\t\t\t       cmd->device->channel + 'A',\n\t\t\t\t       (u8)cmd->device->lun,\n\t\t\t\t       CAM_REQ_ABORTED, SEARCH_COMPLETE) != 0) {\n\t\tprintk(\"%s:%d:%d:%d: Command found on untagged queue\\n\",\n\t\t       ahc_name(ahc), cmd->device->channel, cmd->device->id,\n\t\t       (u8)cmd->device->lun);\n\t\tretval = SUCCESS;\n\t\tgoto done;\n\t}\n\n\t \n\tLIST_FOREACH(pending_scb, &ahc->pending_scbs, pending_links) {\n\t\tif (pending_scb->io_ctx == cmd)\n\t\t\tbreak;\n\t}\n\n\tif (pending_scb == NULL && flag == SCB_DEVICE_RESET) {\n\n\t\t \n\t\tLIST_FOREACH(pending_scb, &ahc->pending_scbs, pending_links) {\n\t\t\tif (ahc_match_scb(ahc, pending_scb, scmd_id(cmd),\n\t\t\t\t\t  scmd_channel(cmd) + 'A',\n\t\t\t\t\t  CAM_LUN_WILDCARD,\n\t\t\t\t\t  SCB_LIST_NULL, ROLE_INITIATOR))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pending_scb == NULL) {\n\t\tscmd_printk(KERN_INFO, cmd, \"Command not found\\n\");\n\t\tgoto no_cmd;\n\t}\n\n\tif ((pending_scb->flags & SCB_RECOVERY_SCB) != 0) {\n\t\t \n\t\tretval = FAILED;\n\t\tgoto  done;\n\t}\n\n\t \n\twas_paused = ahc_is_paused(ahc);\n\tahc_pause_and_flushwork(ahc);\n\tpaused = TRUE;\n\n\tif ((pending_scb->flags & SCB_ACTIVE) == 0) {\n\t\tscmd_printk(KERN_INFO, cmd, \"Command already completed\\n\");\n\t\tgoto no_cmd;\n\t}\n\n\tprintk(\"%s: At time of recovery, card was %spaused\\n\",\n\t       ahc_name(ahc), was_paused ? \"\" : \"not \");\n\tahc_dump_card_state(ahc);\n\n\tdisconnected = TRUE;\n\tif (flag == SCB_ABORT) {\n\t\tif (ahc_search_qinfifo(ahc, cmd->device->id,\n\t\t\t\t       cmd->device->channel + 'A',\n\t\t\t\t       cmd->device->lun,\n\t\t\t\t       pending_scb->hscb->tag,\n\t\t\t\t       ROLE_INITIATOR, CAM_REQ_ABORTED,\n\t\t\t\t       SEARCH_COMPLETE) > 0) {\n\t\t\tprintk(\"%s:%d:%d:%d: Cmd aborted from QINFIFO\\n\",\n\t\t\t       ahc_name(ahc), cmd->device->channel,\n\t\t\t       cmd->device->id, (u8)cmd->device->lun);\n\t\t\tretval = SUCCESS;\n\t\t\tgoto done;\n\t\t}\n\t} else if (ahc_search_qinfifo(ahc, cmd->device->id,\n\t\t\t\t      cmd->device->channel + 'A',\n\t\t\t\t      cmd->device->lun,\n\t\t\t\t      pending_scb->hscb->tag,\n\t\t\t\t      ROLE_INITIATOR,  0,\n\t\t\t\t      SEARCH_COUNT) > 0) {\n\t\tdisconnected = FALSE;\n\t}\n\n\tif (disconnected && (ahc_inb(ahc, SEQ_FLAGS) & NOT_IDENTIFIED) == 0) {\n\t\tstruct scb *bus_scb;\n\n\t\tbus_scb = ahc_lookup_scb(ahc, ahc_inb(ahc, SCB_TAG));\n\t\tif (bus_scb == pending_scb)\n\t\t\tdisconnected = FALSE;\n\t\telse if (flag != SCB_ABORT\n\t\t      && ahc_inb(ahc, SAVED_SCSIID) == pending_scb->hscb->scsiid\n\t\t      && ahc_inb(ahc, SAVED_LUN) == SCB_GET_LUN(pending_scb))\n\t\t\tdisconnected = FALSE;\n\t}\n\n\t \n\tlast_phase = ahc_inb(ahc, LASTPHASE);\n\tsaved_scbptr = ahc_inb(ahc, SCBPTR);\n\tactive_scb_index = ahc_inb(ahc, SCB_TAG);\n\tsaved_scsiid = ahc_inb(ahc, SAVED_SCSIID);\n\tif (last_phase != P_BUSFREE\n\t && (pending_scb->hscb->tag == active_scb_index\n\t  || (flag == SCB_DEVICE_RESET\n\t   && SCSIID_TARGET(ahc, saved_scsiid) == scmd_id(cmd)))) {\n\n\t\t \n\t\tpending_scb = ahc_lookup_scb(ahc, active_scb_index);\n\t\tpending_scb->flags |= SCB_RECOVERY_SCB|flag;\n\t\tahc_outb(ahc, MSG_OUT, HOST_MSG);\n\t\tahc_outb(ahc, SCSISIGO, last_phase|ATNO);\n\t\tscmd_printk(KERN_INFO, cmd, \"Device is active, asserting ATN\\n\");\n\t\twait = TRUE;\n\t} else if (disconnected) {\n\n\t\t \n\t\tpending_scb->hscb->control |= MK_MESSAGE|DISCONNECTED;\n\t\tpending_scb->flags |= SCB_RECOVERY_SCB|flag;\n\n\t\t \n\t\tahc_search_disc_list(ahc, cmd->device->id,\n\t\t\t\t     cmd->device->channel + 'A',\n\t\t\t\t     cmd->device->lun, pending_scb->hscb->tag,\n\t\t\t\t      TRUE,\n\t\t\t\t      TRUE,\n\t\t\t\t      FALSE);\n\n\t\t \n\t\tif ((ahc->flags & AHC_PAGESCBS) == 0) {\n\t\t\tahc_outb(ahc, SCBPTR, pending_scb->hscb->tag);\n\t\t\tahc_outb(ahc, SCB_CONTROL,\n\t\t\t\t ahc_inb(ahc, SCB_CONTROL)|MK_MESSAGE);\n\t\t}\n\n\t\t \n\t\tahc_search_qinfifo(ahc, cmd->device->id,\n\t\t\t\t   cmd->device->channel + 'A',\n\t\t\t\t   cmd->device->lun, SCB_LIST_NULL,\n\t\t\t\t   ROLE_INITIATOR, CAM_REQUEUE_REQ,\n\t\t\t\t   SEARCH_COMPLETE);\n\t\tahc_qinfifo_requeue_tail(ahc, pending_scb);\n\t\tahc_outb(ahc, SCBPTR, saved_scbptr);\n\t\tahc_print_path(ahc, pending_scb);\n\t\tprintk(\"Device is disconnected, re-queuing SCB\\n\");\n\t\twait = TRUE;\n\t} else {\n\t\tscmd_printk(KERN_INFO, cmd, \"Unable to deliver message\\n\");\n\t\tretval = FAILED;\n\t\tgoto done;\n\t}\n\nno_cmd:\n\t \n\tretval = SUCCESS;\ndone:\n\tif (paused)\n\t\tahc_unpause(ahc);\n\tif (wait) {\n\t\tDECLARE_COMPLETION_ONSTACK(done);\n\n\t\tahc->platform_data->eh_done = &done;\n\t\tahc_unlock(ahc, &flags);\n\n\t\tprintk(\"Recovery code sleeping\\n\");\n\t\tif (!wait_for_completion_timeout(&done, 5 * HZ)) {\n\t\t\tahc_lock(ahc, &flags);\n\t\t\tahc->platform_data->eh_done = NULL;\n\t\t\tahc_unlock(ahc, &flags);\n\n\t\t\tprintk(\"Timer Expired\\n\");\n\t\t\tretval = FAILED;\n\t\t}\n\t\tprintk(\"Recovery code awake\\n\");\n\t} else\n\t\tahc_unlock(ahc, &flags);\n\treturn (retval);\n}\n\nstatic void ahc_linux_set_width(struct scsi_target *starget, int width)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);\n\tstruct ahc_devinfo devinfo;\n\tunsigned long flags;\n\n\tahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\tahc_lock(ahc, &flags);\n\tahc_set_width(ahc, &devinfo, width, AHC_TRANS_GOAL, FALSE);\n\tahc_unlock(ahc, &flags);\n}\n\nstatic void ahc_linux_set_period(struct scsi_target *starget, int period)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);\n\tstruct ahc_tmode_tstate *tstate;\n\tstruct ahc_initiator_tinfo *tinfo\n\t\t= ahc_fetch_transinfo(ahc,\n\t\t\t\t      starget->channel + 'A',\n\t\t\t\t      shost->this_id, starget->id, &tstate);\n\tstruct ahc_devinfo devinfo;\n\tunsigned int ppr_options = tinfo->goal.ppr_options;\n\tunsigned long flags;\n\tunsigned long offset = tinfo->goal.offset;\n\tconst struct ahc_syncrate *syncrate;\n\n\tif (offset == 0)\n\t\toffset = MAX_OFFSET;\n\n\tif (period < 9)\n\t\tperiod = 9;\t \n\tif (period == 9) {\n\t\tif (spi_max_width(starget))\n\t\t\tppr_options |= MSG_EXT_PPR_DT_REQ;\n\t\telse\n\t\t\t \n\t\t\tperiod = 10;\n\t}\n\n\tahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\n\t \n\tif (ppr_options & ~MSG_EXT_PPR_QAS_REQ) {\n\t\tif (spi_width(starget) == 0)\n\t\t\tppr_options &= MSG_EXT_PPR_QAS_REQ;\n\t}\n\n\tsyncrate = ahc_find_syncrate(ahc, &period, &ppr_options,\n\t\t\t\t     AHC_SYNCRATE_DT);\n\tahc_lock(ahc, &flags);\n\tahc_set_syncrate(ahc, &devinfo, syncrate, period, offset,\n\t\t\t ppr_options, AHC_TRANS_GOAL, FALSE);\n\tahc_unlock(ahc, &flags);\n}\n\nstatic void ahc_linux_set_offset(struct scsi_target *starget, int offset)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);\n\tstruct ahc_tmode_tstate *tstate;\n\tstruct ahc_initiator_tinfo *tinfo\n\t\t= ahc_fetch_transinfo(ahc,\n\t\t\t\t      starget->channel + 'A',\n\t\t\t\t      shost->this_id, starget->id, &tstate);\n\tstruct ahc_devinfo devinfo;\n\tunsigned int ppr_options = 0;\n\tunsigned int period = 0;\n\tunsigned long flags;\n\tconst struct ahc_syncrate *syncrate = NULL;\n\n\tahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\tif (offset != 0) {\n\t\tsyncrate = ahc_find_syncrate(ahc, &period, &ppr_options,\n\t\t\t\t\t     AHC_SYNCRATE_DT);\n\t\tperiod = tinfo->goal.period;\n\t\tppr_options = tinfo->goal.ppr_options;\n\t}\n\tahc_lock(ahc, &flags);\n\tahc_set_syncrate(ahc, &devinfo, syncrate, period, offset,\n\t\t\t ppr_options, AHC_TRANS_GOAL, FALSE);\n\tahc_unlock(ahc, &flags);\n}\n\nstatic void ahc_linux_set_dt(struct scsi_target *starget, int dt)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);\n\tstruct ahc_tmode_tstate *tstate;\n\tstruct ahc_initiator_tinfo *tinfo\n\t\t= ahc_fetch_transinfo(ahc,\n\t\t\t\t      starget->channel + 'A',\n\t\t\t\t      shost->this_id, starget->id, &tstate);\n\tstruct ahc_devinfo devinfo;\n\tunsigned int ppr_options = tinfo->goal.ppr_options\n\t\t& ~MSG_EXT_PPR_DT_REQ;\n\tunsigned int period = tinfo->goal.period;\n\tunsigned int width = tinfo->goal.width;\n\tunsigned long flags;\n\tconst struct ahc_syncrate *syncrate;\n\n\tif (dt && spi_max_width(starget)) {\n\t\tppr_options |= MSG_EXT_PPR_DT_REQ;\n\t\tif (!width)\n\t\t\tahc_linux_set_width(starget, 1);\n\t} else if (period == 9)\n\t\tperiod = 10;\t \n\n\tahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\tsyncrate = ahc_find_syncrate(ahc, &period, &ppr_options,\n\t\t\t\t     AHC_SYNCRATE_DT);\n\tahc_lock(ahc, &flags);\n\tahc_set_syncrate(ahc, &devinfo, syncrate, period, tinfo->goal.offset,\n\t\t\t ppr_options, AHC_TRANS_GOAL, FALSE);\n\tahc_unlock(ahc, &flags);\n}\n\n#if 0\n \nstatic void ahc_linux_set_qas(struct scsi_target *starget, int qas)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);\n\tstruct ahc_tmode_tstate *tstate;\n\tstruct ahc_initiator_tinfo *tinfo\n\t\t= ahc_fetch_transinfo(ahc,\n\t\t\t\t      starget->channel + 'A',\n\t\t\t\t      shost->this_id, starget->id, &tstate);\n\tstruct ahc_devinfo devinfo;\n\tunsigned int ppr_options = tinfo->goal.ppr_options\n\t\t& ~MSG_EXT_PPR_QAS_REQ;\n\tunsigned int period = tinfo->goal.period;\n\tunsigned long flags;\n\tstruct ahc_syncrate *syncrate;\n\n\tif (qas)\n\t\tppr_options |= MSG_EXT_PPR_QAS_REQ;\n\n\tahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\tsyncrate = ahc_find_syncrate(ahc, &period, &ppr_options,\n\t\t\t\t     AHC_SYNCRATE_DT);\n\tahc_lock(ahc, &flags);\n\tahc_set_syncrate(ahc, &devinfo, syncrate, period, tinfo->goal.offset,\n\t\t\t ppr_options, AHC_TRANS_GOAL, FALSE);\n\tahc_unlock(ahc, &flags);\n}\n\nstatic void ahc_linux_set_iu(struct scsi_target *starget, int iu)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);\n\tstruct ahc_tmode_tstate *tstate;\n\tstruct ahc_initiator_tinfo *tinfo\n\t\t= ahc_fetch_transinfo(ahc,\n\t\t\t\t      starget->channel + 'A',\n\t\t\t\t      shost->this_id, starget->id, &tstate);\n\tstruct ahc_devinfo devinfo;\n\tunsigned int ppr_options = tinfo->goal.ppr_options\n\t\t& ~MSG_EXT_PPR_IU_REQ;\n\tunsigned int period = tinfo->goal.period;\n\tunsigned long flags;\n\tstruct ahc_syncrate *syncrate;\n\n\tif (iu)\n\t\tppr_options |= MSG_EXT_PPR_IU_REQ;\n\n\tahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\n\t\t\t    starget->channel + 'A', ROLE_INITIATOR);\n\tsyncrate = ahc_find_syncrate(ahc, &period, &ppr_options,\n\t\t\t\t     AHC_SYNCRATE_DT);\n\tahc_lock(ahc, &flags);\n\tahc_set_syncrate(ahc, &devinfo, syncrate, period, tinfo->goal.offset,\n\t\t\t ppr_options, AHC_TRANS_GOAL, FALSE);\n\tahc_unlock(ahc, &flags);\n}\n#endif\n\nstatic void ahc_linux_get_signalling(struct Scsi_Host *shost)\n{\n\tstruct ahc_softc *ahc = *(struct ahc_softc **)shost->hostdata;\n\tunsigned long flags;\n\tu8 mode;\n\n\tif (!(ahc->features & AHC_ULTRA2)) {\n\t\t \n\t\tspi_signalling(shost) =\n\t\t\tahc->features & AHC_HVD ?\n\t\t\tSPI_SIGNAL_HVD :\n\t\t\tSPI_SIGNAL_SE;\n\t\treturn;\n\t}\n\n\tahc_lock(ahc, &flags);\n\tahc_pause(ahc);\n\tmode = ahc_inb(ahc, SBLKCTL);\n\tahc_unpause(ahc);\n\tahc_unlock(ahc, &flags);\n\n\tif (mode & ENAB40)\n\t\tspi_signalling(shost) = SPI_SIGNAL_LVD;\n\telse if (mode & ENAB20)\n\t\tspi_signalling(shost) = SPI_SIGNAL_SE;\n\telse\n\t\tspi_signalling(shost) = SPI_SIGNAL_UNKNOWN;\n}\n\nstatic struct spi_function_template ahc_linux_transport_functions = {\n\t.set_offset\t= ahc_linux_set_offset,\n\t.show_offset\t= 1,\n\t.set_period\t= ahc_linux_set_period,\n\t.show_period\t= 1,\n\t.set_width\t= ahc_linux_set_width,\n\t.show_width\t= 1,\n\t.set_dt\t\t= ahc_linux_set_dt,\n\t.show_dt\t= 1,\n#if 0\n\t.set_iu\t\t= ahc_linux_set_iu,\n\t.show_iu\t= 1,\n\t.set_qas\t= ahc_linux_set_qas,\n\t.show_qas\t= 1,\n#endif\n\t.get_signalling\t= ahc_linux_get_signalling,\n};\n\n\n\nstatic int __init\nahc_linux_init(void)\n{\n\t \n\tif (aic7xxx)\n\t\taic7xxx_setup(aic7xxx);\n\n\tahc_linux_transport_template =\n\t\tspi_attach_transport(&ahc_linux_transport_functions);\n\tif (!ahc_linux_transport_template)\n\t\treturn -ENODEV;\n\n\tscsi_transport_reserve_device(ahc_linux_transport_template,\n\t\t\t\t      sizeof(struct ahc_linux_device));\n\n\tahc_linux_pci_init();\n\tahc_linux_eisa_init();\n\treturn 0;\n}\n\nstatic void\nahc_linux_exit(void)\n{\n\tahc_linux_pci_exit();\n\tahc_linux_eisa_exit();\n\tspi_release_transport(ahc_linux_transport_template);\n}\n\nmodule_init(ahc_linux_init);\nmodule_exit(ahc_linux_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}