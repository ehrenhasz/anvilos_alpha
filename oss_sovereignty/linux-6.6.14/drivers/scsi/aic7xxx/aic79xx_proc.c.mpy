{
  "module_name": "aic79xx_proc.c",
  "hash_id": "f399797c685d3491afce5baead1985dc9f127e5f6414454bfe03e58c391ff30c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic7xxx/aic79xx_proc.c",
  "human_readable_source": " \n#include \"aic79xx_osm.h\"\n#include \"aic79xx_inline.h\"\n\nstatic void\tahd_dump_target_state(struct ahd_softc *ahd,\n\t\t\t\t      struct seq_file *m,\n\t\t\t\t      u_int our_id, char channel,\n\t\t\t\t      u_int target_id);\nstatic void\tahd_dump_device_state(struct seq_file *m,\n\t\t\t\t      struct scsi_device *sdev);\n\n \nstatic const struct {\n\tu_int period_factor;\n\tu_int period;\t \n} scsi_syncrates[] = {\n\t{ 0x08, 625 },\t \n\t{ 0x09, 1250 },\t \n\t{ 0x0a, 2500 },\t \n\t{ 0x0b, 3030 },\t \n\t{ 0x0c, 5000 }\t \n};\n\n \nstatic u_int\nahd_calc_syncsrate(u_int period_factor)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(scsi_syncrates); i++) {\n\n\t\tif (period_factor == scsi_syncrates[i].period_factor) {\n\t\t\t \n\t\t\treturn (100000000 / scsi_syncrates[i].period);\n\t\t}\n\t}\n\n\t \n\treturn (10000000 / (period_factor * 4 * 10));\n}\n\nstatic void\nahd_format_transinfo(struct seq_file *m, struct ahd_transinfo *tinfo)\n{\n\tu_int speed;\n\tu_int freq;\n\tu_int mb;\n\n\tif (tinfo->period == AHD_PERIOD_UNKNOWN) {\n\t\tseq_puts(m, \"Renegotiation Pending\\n\");\n\t\treturn;\n\t}\n\tspeed = 3300;\n\tfreq = 0;\n\tif (tinfo->offset != 0) {\n\t\tfreq = ahd_calc_syncsrate(tinfo->period);\n\t\tspeed = freq;\n\t}\n\tspeed *= (0x01 << tinfo->width);\n\tmb = speed / 1000;\n\tif (mb > 0)\n\t\tseq_printf(m, \"%d.%03dMB/s transfers\", mb, speed % 1000);\n\telse\n\t\tseq_printf(m, \"%dKB/s transfers\", speed);\n\n\tif (freq != 0) {\n\t\tint\tprinted_options;\n\n\t\tprinted_options = 0;\n\t\tseq_printf(m, \" (%d.%03dMHz\", freq / 1000, freq % 1000);\n\t\tif ((tinfo->ppr_options & MSG_EXT_PPR_RD_STRM) != 0) {\n\t\t\tseq_puts(m, \" RDSTRM\");\n\t\t\tprinted_options++;\n\t\t}\n\t\tif ((tinfo->ppr_options & MSG_EXT_PPR_DT_REQ) != 0) {\n\t\t\tseq_puts(m, printed_options ? \"|DT\" : \" DT\");\n\t\t\tprinted_options++;\n\t\t}\n\t\tif ((tinfo->ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {\n\t\t\tseq_puts(m, printed_options ? \"|IU\" : \" IU\");\n\t\t\tprinted_options++;\n\t\t}\n\t\tif ((tinfo->ppr_options & MSG_EXT_PPR_RTI) != 0) {\n\t\t\tseq_puts(m, printed_options ? \"|RTI\" : \" RTI\");\n\t\t\tprinted_options++;\n\t\t}\n\t\tif ((tinfo->ppr_options & MSG_EXT_PPR_QAS_REQ) != 0) {\n\t\t\tseq_puts(m, printed_options ? \"|QAS\" : \" QAS\");\n\t\t\tprinted_options++;\n\t\t}\n\t}\n\n\tif (tinfo->width > 0) {\n\t\tif (freq != 0) {\n\t\t\tseq_puts(m, \", \");\n\t\t} else {\n\t\t\tseq_puts(m, \" (\");\n\t\t}\n\t\tseq_printf(m, \"%dbit)\", 8 * (0x01 << tinfo->width));\n\t} else if (freq != 0) {\n\t\tseq_putc(m, ')');\n\t}\n\tseq_putc(m, '\\n');\n}\n\nstatic void\nahd_dump_target_state(struct ahd_softc *ahd, struct seq_file *m,\n\t\t      u_int our_id, char channel, u_int target_id)\n{\n\tstruct  scsi_target *starget;\n\tstruct\tahd_initiator_tinfo *tinfo;\n\tstruct\tahd_tmode_tstate *tstate;\n\tint\tlun;\n\n\ttinfo = ahd_fetch_transinfo(ahd, channel, our_id,\n\t\t\t\t    target_id, &tstate);\n\tseq_printf(m, \"Target %d Negotiation Settings\\n\", target_id);\n\tseq_puts(m, \"\\tUser: \");\n\tahd_format_transinfo(m, &tinfo->user);\n\tstarget = ahd->platform_data->starget[target_id];\n\tif (starget == NULL)\n\t\treturn;\n\n\tseq_puts(m, \"\\tGoal: \");\n\tahd_format_transinfo(m, &tinfo->goal);\n\tseq_puts(m, \"\\tCurr: \");\n\tahd_format_transinfo(m, &tinfo->curr);\n\n\tfor (lun = 0; lun < AHD_NUM_LUNS; lun++) {\n\t\tstruct scsi_device *dev;\n\n\t\tdev = scsi_device_lookup_by_target(starget, lun);\n\n\t\tif (dev == NULL)\n\t\t\tcontinue;\n\n\t\tahd_dump_device_state(m, dev);\n\t}\n}\n\nstatic void\nahd_dump_device_state(struct seq_file *m, struct scsi_device *sdev)\n{\n\tstruct ahd_linux_device *dev = scsi_transport_device_data(sdev);\n\n\tseq_printf(m, \"\\tChannel %c Target %d Lun %d Settings\\n\",\n\t\t  sdev->sdev_target->channel + 'A',\n\t\t   sdev->sdev_target->id, (u8)sdev->lun);\n\n\tseq_printf(m, \"\\t\\tCommands Queued %ld\\n\", dev->commands_issued);\n\tseq_printf(m, \"\\t\\tCommands Active %d\\n\", dev->active);\n\tseq_printf(m, \"\\t\\tCommand Openings %d\\n\", dev->openings);\n\tseq_printf(m, \"\\t\\tMax Tagged Openings %d\\n\", dev->maxtags);\n\tseq_printf(m, \"\\t\\tDevice Queue Frozen Count %d\\n\", dev->qfrozen);\n}\n\nint\nahd_proc_write_seeprom(struct Scsi_Host *shost, char *buffer, int length)\n{\n\tstruct\tahd_softc *ahd = *(struct ahd_softc **)shost->hostdata;\n\tahd_mode_state saved_modes;\n\tint have_seeprom;\n\tu_long s;\n\tint paused;\n\tint written;\n\n\t \n\twritten = -EINVAL;\n\tahd_lock(ahd, &s);\n\tpaused = ahd_is_paused(ahd);\n\tif (!paused)\n\t\tahd_pause(ahd);\n\n\tsaved_modes = ahd_save_modes(ahd);\n\tahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\n\tif (length != sizeof(struct seeprom_config)) {\n\t\tprintk(\"ahd_proc_write_seeprom: incorrect buffer size\\n\");\n\t\tgoto done;\n\t}\n\n\thave_seeprom = ahd_verify_cksum((struct seeprom_config*)buffer);\n\tif (have_seeprom == 0) {\n\t\tprintk(\"ahd_proc_write_seeprom: cksum verification failed\\n\");\n\t\tgoto done;\n\t}\n\n\thave_seeprom = ahd_acquire_seeprom(ahd);\n\tif (!have_seeprom) {\n\t\tprintk(\"ahd_proc_write_seeprom: No Serial EEPROM\\n\");\n\t\tgoto done;\n\t} else {\n\t\tu_int start_addr;\n\n\t\tif (ahd->seep_config == NULL) {\n\t\t\tahd->seep_config = kmalloc(sizeof(*ahd->seep_config),\n\t\t\t\t\t\t   GFP_ATOMIC);\n\t\t\tif (ahd->seep_config == NULL) {\n\t\t\t\tprintk(\"aic79xx: Unable to allocate serial \"\n\t\t\t\t       \"eeprom buffer.  Write failing\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tprintk(\"aic79xx: Writing Serial EEPROM\\n\");\n\t\tstart_addr = 32 * (ahd->channel - 'A');\n\t\tahd_write_seeprom(ahd, (u_int16_t *)buffer, start_addr,\n\t\t\t\t  sizeof(struct seeprom_config)/2);\n\t\tahd_read_seeprom(ahd, (uint16_t *)ahd->seep_config,\n\t\t\t\t start_addr, sizeof(struct seeprom_config)/2,\n\t\t\t\t  FALSE);\n\t\tahd_release_seeprom(ahd);\n\t\twritten = length;\n\t}\n\ndone:\n\tahd_restore_modes(ahd, saved_modes);\n\tif (!paused)\n\t\tahd_unpause(ahd);\n\tahd_unlock(ahd, &s);\n\treturn (written);\n}\n \nint\nahd_linux_show_info(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct\tahd_softc *ahd = *(struct ahd_softc **)shost->hostdata;\n\tchar\tahd_info[256];\n\tu_int\tmax_targ;\n\tu_int\ti;\n\n\tseq_printf(m, \"Adaptec AIC79xx driver version: %s\\n\",\n\t\t  AIC79XX_DRIVER_VERSION);\n\tseq_printf(m, \"%s\\n\", ahd->description);\n\tahd_controller_info(ahd, ahd_info);\n\tseq_printf(m, \"%s\\n\", ahd_info);\n\tseq_printf(m, \"Allocated SCBs: %d, SG List Length: %d\\n\\n\",\n\t\t  ahd->scb_data.numscbs, AHD_NSEG);\n\n\tmax_targ = 16;\n\n\tif (ahd->seep_config == NULL)\n\t\tseq_puts(m, \"No Serial EEPROM\\n\");\n\telse {\n\t\tseq_puts(m, \"Serial EEPROM:\\n\");\n\t\tfor (i = 0; i < sizeof(*ahd->seep_config)/2; i++) {\n\t\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\t\tseq_putc(m, '\\n');\n\t\t\t}\n\t\t\tseq_printf(m, \"0x%.4x \",\n\t\t\t\t  ((uint16_t*)ahd->seep_config)[i]);\n\t\t}\n\t\tseq_putc(m, '\\n');\n\t}\n\tseq_putc(m, '\\n');\n\n\tif ((ahd->features & AHD_WIDE) == 0)\n\t\tmax_targ = 8;\n\n\tfor (i = 0; i < max_targ; i++) {\n\n\t\tahd_dump_target_state(ahd, m, ahd->our_id, 'A',\n\t\t\t\t       i);\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}