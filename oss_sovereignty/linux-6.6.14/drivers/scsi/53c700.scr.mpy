{
  "module_name": "53c700.scr",
  "hash_id": "e35ec1dc059bae84749699b4f49c0b610cd4ffe13ce3ccd426c92835054488aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/53c700.scr",
  "human_readable_source": "; Script for the NCR (or symbios) 53c700 and 53c700-66 chip\n;\n; Copyright (C) 2001 James.Bottomley@HansenPartnership.com\n;;-----------------------------------------------------------------------------\n;;  \n;;  This program is free software; you can redistribute it and/or modify\n;;  it under the terms of the GNU General Public License as published by\n;;  the Free Software Foundation; either version 2 of the License, or\n;;  (at your option) any later version.\n;;\n;;  This program is distributed in the hope that it will be useful,\n;;  but WITHOUT ANY WARRANTY; without even the implied warranty of\n;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;;  GNU General Public License for more details.\n;;\n;;  You should have received a copy of the GNU General Public License\n;;  along with this program; if not, write to the Free Software\n;;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n;;\n;;-----------------------------------------------------------------------------\n;\n; This script is designed to be modified for the particular command in\n; operation.  The particular variables pertaining to the commands are:\n;\nABSOLUTE\tDevice_ID = 0\t\t; ID of target for command\nABSOLUTE\tMessageCount = 0\t; Number of bytes in message\nABSOLUTE\tMessageLocation = 0\t; Addr of message\nABSOLUTE\tCommandCount = 0\t; Number of bytes in command\nABSOLUTE\tCommandAddress = 0\t; Addr of Command\nABSOLUTE\tStatusAddress = 0\t; Addr to receive status return\nABSOLUTE\tReceiveMsgAddress = 0\t; Addr to receive msg\n;\n; This is the magic component for handling scatter-gather.  Each of the\n; SG components is preceded by a script fragment which moves the\n; necessary amount of data and jumps to the next SG segment.  The final\n; SG segment jumps back to .  However, this address is the first SG script\n; segment.\n;\nABSOLUTE\tSGScriptStartAddress = 0\n\n; The following represent status interrupts we use 3 hex digits for\n; this: 0xPRS where \n\n; P:\nABSOLUTE\tAFTER_SELECTION \t= 0x100\nABSOLUTE\tBEFORE_CMD \t\t= 0x200\nABSOLUTE\tAFTER_CMD \t\t= 0x300\nABSOLUTE\tAFTER_STATUS \t\t= 0x400\nABSOLUTE\tAFTER_DATA_IN\t\t= 0x500\nABSOLUTE\tAFTER_DATA_OUT\t\t= 0x600\nABSOLUTE\tDURING_DATA_IN\t\t= 0x700\n\n; R:\nABSOLUTE\tNOT_MSG_OUT \t\t= 0x10\nABSOLUTE\tUNEXPECTED_PHASE \t= 0x20\nABSOLUTE\tNOT_MSG_IN \t\t= 0x30\nABSOLUTE\tUNEXPECTED_MSG\t\t= 0x40\nABSOLUTE\tMSG_IN\t\t\t= 0x50\nABSOLUTE\tSDTR_MSG_R\t\t= 0x60\nABSOLUTE\tREJECT_MSG_R\t\t= 0x70\nABSOLUTE\tDISCONNECT\t\t= 0x80\nABSOLUTE\tMSG_OUT\t\t\t= 0x90\nABSOLUTE\tWDTR_MSG_R\t\t= 0xA0\n\n; S:\nABSOLUTE\tGOOD_STATUS \t\t= 0x1\n\n; Combinations, since the script assembler can't process |\nABSOLUTE\tNOT_MSG_OUT_AFTER_SELECTION = 0x110\nABSOLUTE\tUNEXPECTED_PHASE_BEFORE_CMD = 0x220\nABSOLUTE\tUNEXPECTED_PHASE_AFTER_CMD = 0x320\nABSOLUTE\tNOT_MSG_IN_AFTER_STATUS = 0x430\nABSOLUTE\tGOOD_STATUS_AFTER_STATUS = 0x401\nABSOLUTE\tUNEXPECTED_PHASE_AFTER_DATA_IN = 0x520\nABSOLUTE\tUNEXPECTED_PHASE_AFTER_DATA_OUT = 0x620\nABSOLUTE\tUNEXPECTED_MSG_BEFORE_CMD = 0x240\nABSOLUTE\tMSG_IN_BEFORE_CMD = 0x250\nABSOLUTE\tMSG_IN_AFTER_CMD = 0x350\nABSOLUTE\tSDTR_MSG_BEFORE_CMD = 0x260\nABSOLUTE\tREJECT_MSG_BEFORE_CMD = 0x270\nABSOLUTE\tDISCONNECT_AFTER_CMD = 0x380\nABSOLUTE\tSDTR_MSG_AFTER_CMD = 0x360\nABSOLUTE\tWDTR_MSG_AFTER_CMD = 0x3A0\nABSOLUTE\tMSG_IN_AFTER_STATUS = 0x440\nABSOLUTE\tDISCONNECT_AFTER_DATA = 0x580\nABSOLUTE\tMSG_IN_AFTER_DATA_IN = 0x550\nABSOLUTE\tMSG_IN_AFTER_DATA_OUT = 0x650\nABSOLUTE\tMSG_OUT_AFTER_DATA_IN = 0x590\nABSOLUTE\tDATA_IN_AFTER_DATA_IN = 0x5a0\nABSOLUTE\tMSG_IN_DURING_DATA_IN = 0x750\nABSOLUTE\tDISCONNECT_DURING_DATA = 0x780\n\n;\n; Other interrupt conditions\n; \nABSOLUTE\tRESELECTED_DURING_SELECTION = 0x1000\nABSOLUTE\tCOMPLETED_SELECTION_AS_TARGET = 0x1001\nABSOLUTE\tRESELECTION_IDENTIFIED = 0x1003\n;\n; Fatal interrupt conditions.  If you add to this, also add to the\n; array of corresponding messages\n;\nABSOLUTE\tFATAL = 0x2000\nABSOLUTE\tFATAL_UNEXPECTED_RESELECTION_MSG = 0x2000\nABSOLUTE\tFATAL_SEND_MSG = 0x2001\nABSOLUTE\tFATAL_NOT_MSG_IN_AFTER_SELECTION = 0x2002\nABSOLUTE\tFATAL_ILLEGAL_MSG_LENGTH = 0x2003\n\nABSOLUTE\tDEBUG_INTERRUPT\t= 0x3000\nABSOLUTE\tDEBUG_INTERRUPT1 = 0x3001\nABSOLUTE\tDEBUG_INTERRUPT2 = 0x3002\nABSOLUTE\tDEBUG_INTERRUPT3 = 0x3003\nABSOLUTE\tDEBUG_INTERRUPT4 = 0x3004\nABSOLUTE\tDEBUG_INTERRUPT5 = 0x3005\nABSOLUTE\tDEBUG_INTERRUPT6 = 0x3006\n\n\n;\n; SCSI Messages we interpret in the script\n;\nABSOLUTE\tCOMMAND_COMPLETE_MSG\t= 0x00\nABSOLUTE\tEXTENDED_MSG\t\t= 0x01\nABSOLUTE\tSDTR_MSG\t\t= 0x01\nABSOLUTE\tSAVE_DATA_PTRS_MSG\t= 0x02\nABSOLUTE\tRESTORE_DATA_PTRS_MSG\t= 0x03\nABSOLUTE\tWDTR_MSG\t\t= 0x03\nABSOLUTE\tDISCONNECT_MSG\t\t= 0x04\nABSOLUTE\tREJECT_MSG\t\t= 0x07\nABSOLUTE\tPARITY_ERROR_MSG\t= 0x09\nABSOLUTE\tSIMPLE_TAG_MSG\t\t= 0x20\nABSOLUTE\tIDENTIFY_MSG\t\t= 0x80\nABSOLUTE\tIDENTIFY_MSG_MASK\t= 0x7F\nABSOLUTE\tTWO_BYTE_MSG\t\t= 0x20\nABSOLUTE\tTWO_BYTE_MSG_MASK\t= 0x0F\n\n; This is where the script begins\n\nENTRY\tStartUp\n\nStartUp:\n\tSELECT\tATN Device_ID, Reselect\n\tJUMP\tFinish, WHEN STATUS\n\tJUMP\tSendIdentifyMsg, IF MSG_OUT\n\tINT\tNOT_MSG_OUT_AFTER_SELECTION\n\nReselect:\n\tWAIT\tRESELECT SelectedAsTarget\n\tINT\tRESELECTED_DURING_SELECTION, WHEN MSG_IN\n\tINT\tFATAL_NOT_MSG_IN_AFTER_SELECTION\n\n\tENTRY\tGetReselectionData\nGetReselectionData:\n\tMOVE\t1, ReceiveMsgAddress, WHEN MSG_IN\n\tINT\tRESELECTION_IDENTIFIED\n\n\tENTRY\tGetReselectionWithTag\nGetReselectionWithTag:\n\tMOVE\t3, ReceiveMsgAddress, WHEN MSG_IN\n\tINT\tRESELECTION_IDENTIFIED\n\t\n\tENTRY\tSelectedAsTarget\nSelectedAsTarget:\n; Basically tell the selecting device that there's nothing here\n\tSET\tTARGET\n\tDISCONNECT\n\tCLEAR\tTARGET\n\tINT\tCOMPLETED_SELECTION_AS_TARGET\n;\n; These are the messaging entries\n;\n; Send a message.  Message count should be correctly patched\n\tENTRY\tSendMessage\nSendMessage:\n\tMOVE\tMessageCount, MessageLocation, WHEN MSG_OUT\nResumeSendMessage:\n\tRETURN,\tWHEN NOT MSG_OUT\n\tINT\tFATAL_SEND_MSG\n\n\tENTRY\tSendMessagePhaseMismatch\nSendMessagePhaseMismatch:\n\tCLEAR\tACK\n\tJUMP\tResumeSendMessage\n;\n; Receive a message.  Need to identify the message to\n; receive it correctly\n\tENTRY\tReceiveMessage\nReceiveMessage:\n\tMOVE\t1, ReceiveMsgAddress, WHEN MSG_IN\n;\n; Use this entry if we've just tried to look at the first byte\n; of the message and want to process it further\nProcessReceiveMessage:\n\tJUMP\tReceiveExtendedMessage, IF EXTENDED_MSG\n\tRETURN,\tIF NOT TWO_BYTE_MSG, AND MASK TWO_BYTE_MSG_MASK\n\tCLEAR\tACK\n\tMOVE\t1, ReceiveMsgAddress + 1, WHEN MSG_IN\n\tRETURN\nReceiveExtendedMessage:\n\tCLEAR\tACK\n\tMOVE\t1, ReceiveMsgAddress + 1, WHEN MSG_IN\n\tJUMP\tReceive1Byte, IF 0x01\n\tJUMP\tReceive2Byte, IF 0x02\n\tJUMP\tReceive3Byte, IF 0x03\n\tJUMP\tReceive4Byte, IF 0x04\n\tJUMP\tReceive5Byte, IF 0x05\n\tINT\tFATAL_ILLEGAL_MSG_LENGTH\nReceive1Byte:\n\tCLEAR\tACK\n\tMOVE\t1, ReceiveMsgAddress + 2, WHEN MSG_IN\n\tRETURN\nReceive2Byte:\n\tCLEAR\tACK\n\tMOVE\t2, ReceiveMsgAddress + 2, WHEN MSG_IN\n\tRETURN\nReceive3Byte:\n\tCLEAR\tACK\n\tMOVE\t3, ReceiveMsgAddress + 2, WHEN MSG_IN\n\tRETURN\nReceive4Byte:\n\tCLEAR\tACK\n\tMOVE\t4, ReceiveMsgAddress + 2, WHEN MSG_IN\n\tRETURN\nReceive5Byte:\n\tCLEAR\tACK\n\tMOVE\t5, ReceiveMsgAddress + 2, WHEN MSG_IN\n\tRETURN\n;\n; Come here from the message processor to ignore the message\n;\n\tENTRY\tIgnoreMessage\nIgnoreMessage:\n\tCLEAR\tACK\n\tRETURN\n;\n; Come here to send a reply to a message\n;\n\tENTRY\tSendMessageWithATN\nSendMessageWithATN:\n\tSET\tATN\n\tCLEAR\tACK\n\tJUMP\tSendMessage\n\nSendIdentifyMsg:\n\tCALL\tSendMessage\n\tCLEAR\tATN\n\nIgnoreMsgBeforeCommand:\n\tCLEAR\tACK\n\tENTRY\tSendCommand\nSendCommand:\n\tJUMP\tFinish, WHEN STATUS\n\tJUMP\tMsgInBeforeCommand, IF MSG_IN\n\tINT\tUNEXPECTED_PHASE_BEFORE_CMD, IF NOT CMD\n\tMOVE\tCommandCount, CommandAddress, WHEN CMD\nResumeSendCommand:\n\tJUMP\tFinish, WHEN STATUS\n\tJUMP\tMsgInAfterCmd, IF MSG_IN\n\tJUMP\tDataIn, IF DATA_IN\n\tJUMP\tDataOut, IF DATA_OUT\n\tINT\tUNEXPECTED_PHASE_AFTER_CMD\n\nIgnoreMsgDuringData:\n\tCLEAR\tACK\n\t; fall through to MsgInDuringData\n\nEntry MsgInDuringData\nMsgInDuringData:\n;\n; Could be we have nothing more to transfer\n;\n\tJUMP\tFinish, WHEN STATUS\n\tMOVE\t1, ReceiveMsgAddress, WHEN MSG_IN\n\tJUMP\tDisconnectDuringDataIn, IF DISCONNECT_MSG\n\tJUMP\tIgnoreMsgDuringData, IF SAVE_DATA_PTRS_MSG\n\tJUMP\tIgnoreMsgDuringData, IF RESTORE_DATA_PTRS_MSG\n\tINT\tMSG_IN_DURING_DATA_IN\n\nMsgInAfterCmd:\n\tMOVE\t1, ReceiveMsgAddress, WHEN MSG_IN\n\tJUMP\tDisconnectAfterCmd, IF DISCONNECT_MSG\n\tJUMP\tIgnoreMsgInAfterCmd, IF SAVE_DATA_PTRS_MSG\n\tJUMP\tIgnoreMsgInAfterCmd, IF RESTORE_DATA_PTRS_MSG\n\tCALL\tProcessReceiveMessage\n\tINT\tMSG_IN_AFTER_CMD\n\tCLEAR\tACK\n\tJUMP\tResumeSendCommand\n\nIgnoreMsgInAfterCmd:\n\tCLEAR\tACK\n\tJUMP\tResumeSendCommand\n\nDisconnectAfterCmd:\n\tCLEAR\tACK\n\tWAIT\tDISCONNECT\n\tENTRY\tDisconnect1\nDisconnect1:\n\tINT\tDISCONNECT_AFTER_CMD\n\tENTRY\tDisconnect2\nDisconnect2:\n; We return here after a reselection\n\tCLEAR\tACK\n\tJUMP\tResumeSendCommand\n\nMsgInBeforeCommand:\n\tMOVE\t1, ReceiveMsgAddress, WHEN MSG_IN\n\tJUMP\tIgnoreMsgBeforeCommand, IF SAVE_DATA_PTRS_MSG\n\tJUMP\tIgnoreMsgBeforeCommand, IF RESTORE_DATA_PTRS_MSG\n\tCALL\tProcessReceiveMessage\n\tINT\tMSG_IN_BEFORE_CMD\n\tCLEAR\tACK\n\tJUMP\tSendCommand\n\nDataIn:\n\tCALL\tSGScriptStartAddress\nResumeDataIn:\n\tJUMP\tFinish, WHEN STATUS\n\tJUMP\tMsgInAfterDataIn, IF MSG_IN\n\tJUMP\tDataInAfterDataIn, if DATA_IN\n\tINT\tMSG_OUT_AFTER_DATA_IN, if MSG_OUT\n\tINT\tUNEXPECTED_PHASE_AFTER_DATA_IN\n\nDataInAfterDataIn:\n\tINT\tDATA_IN_AFTER_DATA_IN\n\tJUMP\tResumeDataIn\n\nDataOut:\n\tCALL\tSGScriptStartAddress\nResumeDataOut:\n\tJUMP\tFinish, WHEN STATUS\n\tJUMP\tMsgInAfterDataOut, IF MSG_IN\n\tINT\tUNEXPECTED_PHASE_AFTER_DATA_OUT\n\nMsgInAfterDataIn:\n\tMOVE\t1, ReceiveMsgAddress, WHEN MSG_IN\n\tJUMP\tDisconnectAfterDataIn, IF DISCONNECT_MSG\n\tJUMP\tIgnoreMsgAfterData, IF SAVE_DATA_PTRS_MSG\n\tJUMP\tIgnoreMsgAfterData, IF RESTORE_DATA_PTRS_MSG\n\tCALL\tProcessReceiveMessage\n\tINT\tMSG_IN_AFTER_DATA_IN\n\tCLEAR\tACK\n\tJUMP\tResumeDataIn\n\nDisconnectDuringDataIn:\n\tCLEAR\tACK\n\tWAIT\tDISCONNECT\n\tENTRY\tDisconnect3\nDisconnect3:\n\tINT\tDISCONNECT_DURING_DATA\n\tENTRY\tDisconnect4\nDisconnect4:\n; we return here after a reselection\n\tCLEAR\tACK\n\tJUMP\tResumeSendCommand\n\n\nDisconnectAfterDataIn:\n\tCLEAR\tACK\n\tWAIT\tDISCONNECT\n\tENTRY\tDisconnect5\nDisconnect5:\n\tINT\tDISCONNECT_AFTER_DATA\n\tENTRY\tDisconnect6\nDisconnect6:\n; we return here after a reselection\n\tCLEAR\tACK\n\tJUMP\tResumeDataIn\n\nMsgInAfterDataOut:\n\tMOVE\t1, ReceiveMsgAddress, WHEN MSG_IN\n\tJUMP\tDisconnectAfterDataOut, if DISCONNECT_MSG\n\tJUMP\tIgnoreMsgAfterData, IF SAVE_DATA_PTRS_MSG\n\tJUMP\tIgnoreMsgAfterData, IF RESTORE_DATA_PTRS_MSG\n\tCALL\tProcessReceiveMessage\n\tINT\tMSG_IN_AFTER_DATA_OUT\n\tCLEAR\tACK\n\tJUMP\tResumeDataOut\n\nIgnoreMsgAfterData:\n\tCLEAR\tACK\n; Data in and out do the same thing on resume, so pick one\n\tJUMP\tResumeDataIn\n\nDisconnectAfterDataOut:\n\tCLEAR\tACK\n\tWAIT\tDISCONNECT\n\tENTRY\tDisconnect7\nDisconnect7:\n\tINT\tDISCONNECT_AFTER_DATA\n\tENTRY\tDisconnect8\nDisconnect8:\n; we return here after a reselection\n\tCLEAR\tACK\n\tJUMP\tResumeDataOut\n\nFinish:\n\tMOVE\t1, StatusAddress, WHEN STATUS\n\tINT\tNOT_MSG_IN_AFTER_STATUS, WHEN NOT MSG_IN\n\tMOVE\t1, ReceiveMsgAddress, WHEN MSG_IN\n\tJUMP\tFinishCommandComplete, IF COMMAND_COMPLETE_MSG\n\tCALL\tProcessReceiveMessage\n\tINT\tMSG_IN_AFTER_STATUS\n\tENTRY\tFinishCommandComplete\nFinishCommandComplete:\n\tCLEAR\tACK\n\tWAIT\tDISCONNECT\n\tENTRY\tFinish1\nFinish1:\n\tINT\tGOOD_STATUS_AFTER_STATUS\n\tENTRY\tFinish2\nFinish2:\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}