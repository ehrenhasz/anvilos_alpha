{
  "module_name": "imx-iim.c",
  "hash_id": "2cd28dcfa901fa31fcd71e69e095891cb572dee17b24497fdc44d43acd596e2d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/imx-iim.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n\n#define IIM_BANK_BASE(n)\t(0x800 + 0x400 * (n))\n\nstruct imx_iim_drvdata {\n\tunsigned int nregs;\n};\n\nstruct iim_priv {\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\nstatic int imx_iim_read(void *context, unsigned int offset,\n\t\t\t  void *buf, size_t bytes)\n{\n\tstruct iim_priv *iim = context;\n\tint i, ret;\n\tu8 *buf8 = buf;\n\n\tret = clk_prepare_enable(iim->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = offset; i < offset + bytes; i++) {\n\t\tint bank = i >> 5;\n\t\tint reg = i & 0x1f;\n\n\t\t*buf8++ = readl(iim->base + IIM_BANK_BASE(bank) + reg * 4);\n\t}\n\n\tclk_disable_unprepare(iim->clk);\n\n\treturn 0;\n}\n\nstatic struct imx_iim_drvdata imx27_drvdata = {\n\t.nregs = 2 * 32,\n};\n\nstatic struct imx_iim_drvdata imx25_imx31_imx35_drvdata = {\n\t.nregs = 3 * 32,\n};\n\nstatic struct imx_iim_drvdata imx51_drvdata = {\n\t.nregs = 4 * 32,\n};\n\nstatic struct imx_iim_drvdata imx53_drvdata = {\n\t.nregs = 4 * 32 + 16,\n};\n\nstatic const struct of_device_id imx_iim_dt_ids[] = {\n\t{\n\t\t.compatible = \"fsl,imx25-iim\",\n\t\t.data = &imx25_imx31_imx35_drvdata,\n\t}, {\n\t\t.compatible = \"fsl,imx27-iim\",\n\t\t.data = &imx27_drvdata,\n\t}, {\n\t\t.compatible = \"fsl,imx31-iim\",\n\t\t.data = &imx25_imx31_imx35_drvdata,\n\t}, {\n\t\t.compatible = \"fsl,imx35-iim\",\n\t\t.data = &imx25_imx31_imx35_drvdata,\n\t}, {\n\t\t.compatible = \"fsl,imx51-iim\",\n\t\t.data = &imx51_drvdata,\n\t}, {\n\t\t.compatible = \"fsl,imx53-iim\",\n\t\t.data = &imx53_drvdata,\n\t}, {\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(of, imx_iim_dt_ids);\n\nstatic int imx_iim_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iim_priv *iim;\n\tstruct nvmem_device *nvmem;\n\tstruct nvmem_config cfg = {};\n\tconst struct imx_iim_drvdata *drvdata = NULL;\n\n\tiim = devm_kzalloc(dev, sizeof(*iim), GFP_KERNEL);\n\tif (!iim)\n\t\treturn -ENOMEM;\n\n\tiim->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(iim->base))\n\t\treturn PTR_ERR(iim->base);\n\n\tdrvdata = of_device_get_match_data(&pdev->dev);\n\n\tiim->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(iim->clk))\n\t\treturn PTR_ERR(iim->clk);\n\n\tcfg.name = \"imx-iim\",\n\tcfg.read_only = true,\n\tcfg.word_size = 1,\n\tcfg.stride = 1,\n\tcfg.reg_read = imx_iim_read,\n\tcfg.dev = dev;\n\tcfg.size = drvdata->nregs;\n\tcfg.priv = iim;\n\n\tnvmem = devm_nvmem_register(dev, &cfg);\n\n\treturn PTR_ERR_OR_ZERO(nvmem);\n}\n\nstatic struct platform_driver imx_iim_driver = {\n\t.probe\t= imx_iim_probe,\n\t.driver = {\n\t\t.name\t= \"imx-iim\",\n\t\t.of_match_table = imx_iim_dt_ids,\n\t},\n};\nmodule_platform_driver(imx_iim_driver);\n\nMODULE_AUTHOR(\"Michael Grzeschik <m.grzeschik@pengutronix.de>\");\nMODULE_DESCRIPTION(\"i.MX IIM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}