{
  "module_name": "rave-sp-eeprom.c",
  "hash_id": "ab5ce6b3c9a828a5e2e11bad7c8e635498d39b829e397fc77c5ce42c0e57a77c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/rave-sp-eeprom.c",
  "human_readable_source": "\n\n \n#include <linux/kernel.h>\n#include <linux/mfd/rave-sp.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/sizes.h>\n\n \nenum rave_sp_eeprom_access_type {\n\tRAVE_SP_EEPROM_WRITE = 0,\n\tRAVE_SP_EEPROM_READ  = 1,\n};\n\n \nenum rave_sp_eeprom_header_size {\n\tRAVE_SP_EEPROM_HEADER_SMALL = 4U,\n\tRAVE_SP_EEPROM_HEADER_BIG   = 5U,\n};\n#define RAVE_SP_EEPROM_HEADER_MAX\tRAVE_SP_EEPROM_HEADER_BIG\n\n#define\tRAVE_SP_EEPROM_PAGE_SIZE\t32U\n\n \nstruct rave_sp_eeprom_page {\n\tu8  type;\n\tu8  success;\n\tu8  data[RAVE_SP_EEPROM_PAGE_SIZE];\n} __packed;\n\n \nstruct rave_sp_eeprom {\n\tstruct rave_sp *sp;\n\tstruct mutex mutex;\n\tu8 address;\n\tunsigned int header_size;\n\tstruct device *dev;\n};\n\n \nstatic int rave_sp_eeprom_io(struct rave_sp_eeprom *eeprom,\n\t\t\t     enum rave_sp_eeprom_access_type type,\n\t\t\t     u16 idx,\n\t\t\t     struct rave_sp_eeprom_page *page)\n{\n\tconst bool is_write = type == RAVE_SP_EEPROM_WRITE;\n\tconst unsigned int data_size = is_write ? sizeof(page->data) : 0;\n\tconst unsigned int cmd_size = eeprom->header_size + data_size;\n\tconst unsigned int rsp_size =\n\t\tis_write ? sizeof(*page) - sizeof(page->data) : sizeof(*page);\n\tunsigned int offset = 0;\n\tu8 cmd[RAVE_SP_EEPROM_HEADER_MAX + sizeof(page->data)];\n\tint ret;\n\n\tif (WARN_ON(cmd_size > sizeof(cmd)))\n\t\treturn -EINVAL;\n\n\tcmd[offset++] = eeprom->address;\n\tcmd[offset++] = 0;\n\tcmd[offset++] = type;\n\tcmd[offset++] = idx;\n\n\t \n\tif (offset < eeprom->header_size)\n\t\tcmd[offset++] = idx >> 8;\n\t \n\tmemcpy(&cmd[offset], page->data, data_size);\n\n\tret = rave_sp_exec(eeprom->sp, cmd, cmd_size, page, rsp_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (page->type != type)\n\t\treturn -EPROTO;\n\n\tif (!page->success)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int\nrave_sp_eeprom_page_access(struct rave_sp_eeprom *eeprom,\n\t\t\t   enum rave_sp_eeprom_access_type type,\n\t\t\t   unsigned int offset, u8 *data,\n\t\t\t   size_t data_len)\n{\n\tconst unsigned int page_offset = offset % RAVE_SP_EEPROM_PAGE_SIZE;\n\tconst unsigned int page_nr     = offset / RAVE_SP_EEPROM_PAGE_SIZE;\n\tstruct rave_sp_eeprom_page page;\n\tint ret;\n\n\t \n\tif (WARN_ON(data_len > sizeof(page.data) - page_offset))\n\t\treturn -EINVAL;\n\n\tif (type == RAVE_SP_EEPROM_WRITE) {\n\t\t \n\t\tif (data_len < RAVE_SP_EEPROM_PAGE_SIZE) {\n\t\t\tret = rave_sp_eeprom_io(eeprom, RAVE_SP_EEPROM_READ,\n\t\t\t\t\t\tpage_nr, &page);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tmemcpy(&page.data[page_offset], data, data_len);\n\t}\n\n\tret = rave_sp_eeprom_io(eeprom, type, page_nr, &page);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (type == RAVE_SP_EEPROM_READ)\n\t\tmemcpy(data, &page.data[page_offset], data_len);\n\n\treturn 0;\n}\n\n \nstatic int rave_sp_eeprom_access(struct rave_sp_eeprom *eeprom,\n\t\t\t\t enum rave_sp_eeprom_access_type type,\n\t\t\t\t unsigned int offset, u8 *data,\n\t\t\t\t unsigned int data_len)\n{\n\tunsigned int residue;\n\tunsigned int chunk;\n\tunsigned int head;\n\tint ret;\n\n\tmutex_lock(&eeprom->mutex);\n\n\thead    = offset % RAVE_SP_EEPROM_PAGE_SIZE;\n\tresidue = data_len;\n\n\tdo {\n\t\t \n\t\tif (unlikely(head)) {\n\t\t\tchunk = RAVE_SP_EEPROM_PAGE_SIZE - head;\n\t\t\t \n\t\t\thead  = 0;\n\t\t} else {\n\t\t\tchunk = RAVE_SP_EEPROM_PAGE_SIZE;\n\t\t}\n\n\t\t \n\t\tchunk = min(chunk, residue);\n\t\tret = rave_sp_eeprom_page_access(eeprom, type, offset,\n\t\t\t\t\t\t data, chunk);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tresidue -= chunk;\n\t\toffset  += chunk;\n\t\tdata    += chunk;\n\t} while (residue);\nout:\n\tmutex_unlock(&eeprom->mutex);\n\treturn ret;\n}\n\nstatic int rave_sp_eeprom_reg_read(void *eeprom, unsigned int offset,\n\t\t\t\t   void *val, size_t bytes)\n{\n\treturn rave_sp_eeprom_access(eeprom, RAVE_SP_EEPROM_READ,\n\t\t\t\t     offset, val, bytes);\n}\n\nstatic int rave_sp_eeprom_reg_write(void *eeprom, unsigned int offset,\n\t\t\t\t    void *val, size_t bytes)\n{\n\treturn rave_sp_eeprom_access(eeprom, RAVE_SP_EEPROM_WRITE,\n\t\t\t\t     offset, val, bytes);\n}\n\nstatic int rave_sp_eeprom_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rave_sp *sp = dev_get_drvdata(dev->parent);\n\tstruct device_node *np = dev->of_node;\n\tstruct nvmem_config config = { 0 };\n\tstruct rave_sp_eeprom *eeprom;\n\tstruct nvmem_device *nvmem;\n\tu32 reg[2], size;\n\n\tif (of_property_read_u32_array(np, \"reg\", reg, ARRAY_SIZE(reg))) {\n\t\tdev_err(dev, \"Failed to parse \\\"reg\\\" property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsize = reg[1];\n\t \n\tif (size > U16_MAX * RAVE_SP_EEPROM_PAGE_SIZE) {\n\t\tdev_err(dev, \"Specified size is too big\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\teeprom = devm_kzalloc(dev, sizeof(*eeprom), GFP_KERNEL);\n\tif (!eeprom)\n\t\treturn -ENOMEM;\n\n\teeprom->address = reg[0];\n\teeprom->sp      = sp;\n\teeprom->dev     = dev;\n\n\tif (size > SZ_8K)\n\t\teeprom->header_size = RAVE_SP_EEPROM_HEADER_BIG;\n\telse\n\t\teeprom->header_size = RAVE_SP_EEPROM_HEADER_SMALL;\n\n\tmutex_init(&eeprom->mutex);\n\n\tconfig.id\t\t= -1;\n\tof_property_read_string(np, \"zii,eeprom-name\", &config.name);\n\tconfig.priv\t\t= eeprom;\n\tconfig.dev\t\t= dev;\n\tconfig.size\t\t= size;\n\tconfig.reg_read\t\t= rave_sp_eeprom_reg_read;\n\tconfig.reg_write\t= rave_sp_eeprom_reg_write;\n\tconfig.word_size\t= 1;\n\tconfig.stride\t\t= 1;\n\n\tnvmem = devm_nvmem_register(dev, &config);\n\n\treturn PTR_ERR_OR_ZERO(nvmem);\n}\n\nstatic const struct of_device_id rave_sp_eeprom_of_match[] = {\n\t{ .compatible = \"zii,rave-sp-eeprom\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rave_sp_eeprom_of_match);\n\nstatic struct platform_driver rave_sp_eeprom_driver = {\n\t.probe = rave_sp_eeprom_probe,\n\t.driver\t= {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = rave_sp_eeprom_of_match,\n\t},\n};\nmodule_platform_driver(rave_sp_eeprom_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Andrey Vostrikov <andrey.vostrikov@cogentembedded.com>\");\nMODULE_AUTHOR(\"Nikita Yushchenko <nikita.yoush@cogentembedded.com>\");\nMODULE_AUTHOR(\"Andrey Smirnov <andrew.smirnov@gmail.com>\");\nMODULE_DESCRIPTION(\"RAVE SP EEPROM driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}