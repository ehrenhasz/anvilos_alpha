{
  "module_name": "layerscape-sfp.c",
  "hash_id": "b60bb88b68f217993e92b0007023373a1a869c429d8c08d7a6a7409be308427c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/layerscape-sfp.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n\n#define LAYERSCAPE_SFP_OTP_OFFSET\t0x0200\n\nstruct layerscape_sfp_priv {\n\tstruct regmap *regmap;\n};\n\nstruct layerscape_sfp_data {\n\tint size;\n\tenum regmap_endian endian;\n};\n\nstatic int layerscape_sfp_read(void *context, unsigned int offset, void *val,\n\t\t\t       size_t bytes)\n{\n\tstruct layerscape_sfp_priv *priv = context;\n\n\treturn regmap_bulk_read(priv->regmap,\n\t\t\t\tLAYERSCAPE_SFP_OTP_OFFSET + offset, val,\n\t\t\t\tbytes / 4);\n}\n\nstatic struct nvmem_config layerscape_sfp_nvmem_config = {\n\t.name = \"fsl-sfp\",\n\t.reg_read = layerscape_sfp_read,\n\t.word_size = 4,\n\t.stride = 4,\n};\n\nstatic int layerscape_sfp_probe(struct platform_device *pdev)\n{\n\tconst struct layerscape_sfp_data *data;\n\tstruct layerscape_sfp_priv *priv;\n\tstruct nvmem_device *nvmem;\n\tstruct regmap_config config = { 0 };\n\tvoid __iomem *base;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tdata = device_get_match_data(&pdev->dev);\n\tconfig.reg_bits = 32;\n\tconfig.reg_stride = 4;\n\tconfig.val_bits = 32;\n\tconfig.val_format_endian = data->endian;\n\tconfig.max_register = LAYERSCAPE_SFP_OTP_OFFSET + data->size - 4;\n\tpriv->regmap = devm_regmap_init_mmio(&pdev->dev, base, &config);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tlayerscape_sfp_nvmem_config.size = data->size;\n\tlayerscape_sfp_nvmem_config.dev = &pdev->dev;\n\tlayerscape_sfp_nvmem_config.priv = priv;\n\n\tnvmem = devm_nvmem_register(&pdev->dev, &layerscape_sfp_nvmem_config);\n\n\treturn PTR_ERR_OR_ZERO(nvmem);\n}\n\nstatic const struct layerscape_sfp_data ls1021a_data = {\n\t.size = 0x88,\n\t.endian = REGMAP_ENDIAN_BIG,\n};\n\nstatic const struct layerscape_sfp_data ls1028a_data = {\n\t.size = 0x88,\n\t.endian = REGMAP_ENDIAN_LITTLE,\n};\n\nstatic const struct of_device_id layerscape_sfp_dt_ids[] = {\n\t{ .compatible = \"fsl,ls1021a-sfp\", .data = &ls1021a_data },\n\t{ .compatible = \"fsl,ls1028a-sfp\", .data = &ls1028a_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, layerscape_sfp_dt_ids);\n\nstatic struct platform_driver layerscape_sfp_driver = {\n\t.probe\t= layerscape_sfp_probe,\n\t.driver = {\n\t\t.name\t= \"layerscape_sfp\",\n\t\t.of_match_table = layerscape_sfp_dt_ids,\n\t},\n};\nmodule_platform_driver(layerscape_sfp_driver);\n\nMODULE_AUTHOR(\"Michael Walle <michael@walle.cc>\");\nMODULE_DESCRIPTION(\"Layerscape Security Fuse Processor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}