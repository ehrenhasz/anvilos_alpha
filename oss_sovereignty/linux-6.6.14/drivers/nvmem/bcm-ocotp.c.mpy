{
  "module_name": "bcm-ocotp.c",
  "hash_id": "976b5f2c47a0f70d411d8006a9a47a552e1ab653ed29695d53e0884fbbb265d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/bcm-ocotp.c",
  "human_readable_source": "\n\n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n \n#define OTPC_RETRIES                 5000\n\n \n#define OTPC_PROG_EN_SEQ             { 0xf, 0x4, 0x8, 0xd }\n\n \n#define OTPC_CMD_READ                0x0\n#define OTPC_CMD_OTP_PROG_ENABLE     0x2\n#define OTPC_CMD_OTP_PROG_DISABLE    0x3\n#define OTPC_CMD_PROGRAM             0x8\n\n \n#define OTPC_STAT_CMD_DONE           BIT(1)\n#define OTPC_STAT_PROG_OK            BIT(2)\n\n \n#define OTPC_MODE_REG_OFFSET         0x0\n#define OTPC_MODE_REG_OTPC_MODE      0\n#define OTPC_COMMAND_OFFSET          0x4\n#define OTPC_COMMAND_COMMAND_WIDTH   6\n#define OTPC_CMD_START_OFFSET        0x8\n#define OTPC_CMD_START_START         0\n#define OTPC_CPU_STATUS_OFFSET       0xc\n#define OTPC_CPUADDR_REG_OFFSET      0x28\n#define OTPC_CPUADDR_REG_OTPC_CPU_ADDRESS_WIDTH 16\n#define OTPC_CPU_WRITE_REG_OFFSET    0x2c\n\n#define OTPC_CMD_MASK  (BIT(OTPC_COMMAND_COMMAND_WIDTH) - 1)\n#define OTPC_ADDR_MASK (BIT(OTPC_CPUADDR_REG_OTPC_CPU_ADDRESS_WIDTH) - 1)\n\n\nstruct otpc_map {\n\t \n\tu32 otpc_row_size;\n\t \n\tu16 data_r_offset[4];\n\t \n\tu16 data_w_offset[4];\n};\n\nstatic struct otpc_map otp_map = {\n\t.otpc_row_size = 1,\n\t.data_r_offset = {0x10},\n\t.data_w_offset = {0x2c},\n};\n\nstatic struct otpc_map otp_map_v2 = {\n\t.otpc_row_size = 2,\n\t.data_r_offset = {0x10, 0x5c},\n\t.data_w_offset = {0x2c, 0x64},\n};\n\nstruct otpc_priv {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tconst struct otpc_map *map;\n\tstruct nvmem_config *config;\n};\n\nstatic inline void set_command(void __iomem *base, u32 command)\n{\n\twritel(command & OTPC_CMD_MASK, base + OTPC_COMMAND_OFFSET);\n}\n\nstatic inline void set_cpu_address(void __iomem *base, u32 addr)\n{\n\twritel(addr & OTPC_ADDR_MASK, base + OTPC_CPUADDR_REG_OFFSET);\n}\n\nstatic inline void set_start_bit(void __iomem *base)\n{\n\twritel(1 << OTPC_CMD_START_START, base + OTPC_CMD_START_OFFSET);\n}\n\nstatic inline void reset_start_bit(void __iomem *base)\n{\n\twritel(0, base + OTPC_CMD_START_OFFSET);\n}\n\nstatic inline void write_cpu_data(void __iomem *base, u32 value)\n{\n\twritel(value, base + OTPC_CPU_WRITE_REG_OFFSET);\n}\n\nstatic int poll_cpu_status(void __iomem *base, u32 value)\n{\n\tu32 status;\n\tu32 retries;\n\n\tfor (retries = 0; retries < OTPC_RETRIES; retries++) {\n\t\tstatus = readl(base + OTPC_CPU_STATUS_OFFSET);\n\t\tif (status & value)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (retries == OTPC_RETRIES)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int enable_ocotp_program(void __iomem *base)\n{\n\tstatic const u32 vals[] = OTPC_PROG_EN_SEQ;\n\tint i;\n\tint ret;\n\n\t \n\tset_command(base, OTPC_CMD_OTP_PROG_ENABLE);\n\tfor (i = 0; i < ARRAY_SIZE(vals); i++) {\n\t\twrite_cpu_data(base, vals[i]);\n\t\tset_start_bit(base);\n\t\tret = poll_cpu_status(base, OTPC_STAT_CMD_DONE);\n\t\treset_start_bit(base);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn poll_cpu_status(base, OTPC_STAT_PROG_OK);\n}\n\nstatic int disable_ocotp_program(void __iomem *base)\n{\n\tint ret;\n\n\tset_command(base, OTPC_CMD_OTP_PROG_DISABLE);\n\tset_start_bit(base);\n\tret = poll_cpu_status(base, OTPC_STAT_PROG_OK);\n\treset_start_bit(base);\n\n\treturn ret;\n}\n\nstatic int bcm_otpc_read(void *context, unsigned int offset, void *val,\n\tsize_t bytes)\n{\n\tstruct otpc_priv *priv = context;\n\tu32 *buf = val;\n\tu32 bytes_read;\n\tu32 address = offset / priv->config->word_size;\n\tint i, ret;\n\n\tfor (bytes_read = 0; bytes_read < bytes;) {\n\t\tset_command(priv->base, OTPC_CMD_READ);\n\t\tset_cpu_address(priv->base, address++);\n\t\tset_start_bit(priv->base);\n\t\tret = poll_cpu_status(priv->base, OTPC_STAT_CMD_DONE);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"otp read error: 0x%x\", ret);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tfor (i = 0; i < priv->map->otpc_row_size; i++) {\n\t\t\t*buf++ = readl(priv->base +\n\t\t\t\t\tpriv->map->data_r_offset[i]);\n\t\t\tbytes_read += sizeof(*buf);\n\t\t}\n\n\t\treset_start_bit(priv->base);\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm_otpc_write(void *context, unsigned int offset, void *val,\n\tsize_t bytes)\n{\n\tstruct otpc_priv *priv = context;\n\tu32 *buf = val;\n\tu32 bytes_written;\n\tu32 address = offset / priv->config->word_size;\n\tint i, ret;\n\n\tif (offset % priv->config->word_size)\n\t\treturn -EINVAL;\n\n\tret = enable_ocotp_program(priv->base);\n\tif (ret)\n\t\treturn -EIO;\n\n\tfor (bytes_written = 0; bytes_written < bytes;) {\n\t\tset_command(priv->base, OTPC_CMD_PROGRAM);\n\t\tset_cpu_address(priv->base, address++);\n\t\tfor (i = 0; i < priv->map->otpc_row_size; i++) {\n\t\t\twritel(*buf, priv->base + priv->map->data_w_offset[i]);\n\t\t\tbuf++;\n\t\t\tbytes_written += sizeof(*buf);\n\t\t}\n\t\tset_start_bit(priv->base);\n\t\tret = poll_cpu_status(priv->base, OTPC_STAT_CMD_DONE);\n\t\treset_start_bit(priv->base);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"otp write error: 0x%x\", ret);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tdisable_ocotp_program(priv->base);\n\n\treturn 0;\n}\n\nstatic struct nvmem_config bcm_otpc_nvmem_config = {\n\t.name = \"bcm-ocotp\",\n\t.read_only = false,\n\t.word_size = 4,\n\t.stride = 4,\n\t.reg_read = bcm_otpc_read,\n\t.reg_write = bcm_otpc_write,\n};\n\nstatic const struct of_device_id bcm_otpc_dt_ids[] = {\n\t{ .compatible = \"brcm,ocotp\", .data = &otp_map },\n\t{ .compatible = \"brcm,ocotp-v2\", .data = &otp_map_v2 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bcm_otpc_dt_ids);\n\nstatic const struct acpi_device_id bcm_otpc_acpi_ids[] __maybe_unused = {\n\t{ .id = \"BRCM0700\", .driver_data = (kernel_ulong_t)&otp_map },\n\t{ .id = \"BRCM0701\", .driver_data = (kernel_ulong_t)&otp_map_v2 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(acpi, bcm_otpc_acpi_ids);\n\nstatic int bcm_otpc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct otpc_priv *priv;\n\tstruct nvmem_device *nvmem;\n\tint err;\n\tu32 num_words;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->map = device_get_match_data(dev);\n\tif (!priv->map)\n\t\treturn -ENODEV;\n\n\t \n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base)) {\n\t\tdev_err(dev, \"unable to map I/O memory\\n\");\n\t\treturn PTR_ERR(priv->base);\n\t}\n\n\t \n\twritel(readl(priv->base + OTPC_MODE_REG_OFFSET) |\n\t\tBIT(OTPC_MODE_REG_OTPC_MODE),\n\t\tpriv->base + OTPC_MODE_REG_OFFSET);\n\treset_start_bit(priv->base);\n\n\t \n\terr = device_property_read_u32(dev, \"brcm,ocotp-size\", &num_words);\n\tif (err) {\n\t\tdev_err(dev, \"size parameter not specified\\n\");\n\t\treturn -EINVAL;\n\t} else if (num_words == 0) {\n\t\tdev_err(dev, \"size must be > 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbcm_otpc_nvmem_config.size = 4 * num_words;\n\tbcm_otpc_nvmem_config.dev = dev;\n\tbcm_otpc_nvmem_config.priv = priv;\n\n\tif (priv->map == &otp_map_v2) {\n\t\tbcm_otpc_nvmem_config.word_size = 8;\n\t\tbcm_otpc_nvmem_config.stride = 8;\n\t}\n\n\tpriv->config = &bcm_otpc_nvmem_config;\n\n\tnvmem = devm_nvmem_register(dev, &bcm_otpc_nvmem_config);\n\tif (IS_ERR(nvmem)) {\n\t\tdev_err(dev, \"error registering nvmem config\\n\");\n\t\treturn PTR_ERR(nvmem);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver bcm_otpc_driver = {\n\t.probe\t= bcm_otpc_probe,\n\t.driver = {\n\t\t.name\t= \"brcm-otpc\",\n\t\t.of_match_table = bcm_otpc_dt_ids,\n\t\t.acpi_match_table = ACPI_PTR(bcm_otpc_acpi_ids),\n\t},\n};\nmodule_platform_driver(bcm_otpc_driver);\n\nMODULE_DESCRIPTION(\"Broadcom OTPC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}