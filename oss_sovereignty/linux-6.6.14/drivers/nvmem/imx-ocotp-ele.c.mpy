{
  "module_name": "imx-ocotp-ele.c",
  "hash_id": "8ee7d51e67f976f8586726d9410566eba50a54824fc6a05b20eeb1317d30bc69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/imx-ocotp-ele.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\nenum fuse_type {\n\tFUSE_FSB = 1,\n\tFUSE_ELE = 2,\n\tFUSE_INVALID = -1\n};\n\nstruct ocotp_map_entry {\n\tu32 start;  \n\tu32 num;  \n\tenum fuse_type type;\n};\n\nstruct ocotp_devtype_data {\n\tu32 reg_off;\n\tchar *name;\n\tu32 size;\n\tu32 num_entry;\n\tu32 flag;\n\tnvmem_reg_read_t reg_read;\n\tstruct ocotp_map_entry entry[];\n};\n\nstruct imx_ocotp_priv {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct nvmem_config config;\n\tstruct mutex lock;\n\tconst struct ocotp_devtype_data *data;\n};\n\nstatic enum fuse_type imx_ocotp_fuse_type(void *context, u32 index)\n{\n\tstruct imx_ocotp_priv *priv = context;\n\tconst struct ocotp_devtype_data *data = priv->data;\n\tu32 start, end;\n\tint i;\n\n\tfor (i = 0; i < data->num_entry; i++) {\n\t\tstart = data->entry[i].start;\n\t\tend = data->entry[i].start + data->entry[i].num;\n\n\t\tif (index >= start && index < end)\n\t\t\treturn data->entry[i].type;\n\t}\n\n\treturn FUSE_INVALID;\n}\n\nstatic int imx_ocotp_reg_read(void *context, unsigned int offset, void *val, size_t bytes)\n{\n\tstruct imx_ocotp_priv *priv = context;\n\tvoid __iomem *reg = priv->base + priv->data->reg_off;\n\tu32 count, index, num_bytes;\n\tenum fuse_type type;\n\tu32 *buf;\n\tvoid *p;\n\tint i;\n\n\tindex = offset;\n\tnum_bytes = round_up(bytes, 4);\n\tcount = num_bytes >> 2;\n\n\tif (count > ((priv->data->size >> 2) - index))\n\t\tcount = (priv->data->size >> 2) - index;\n\n\tp = kzalloc(num_bytes, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&priv->lock);\n\n\tbuf = p;\n\n\tfor (i = index; i < (index + count); i++) {\n\t\ttype = imx_ocotp_fuse_type(context, i);\n\t\tif (type == FUSE_INVALID || type == FUSE_ELE) {\n\t\t\t*buf++ = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t*buf++ = readl_relaxed(reg + (i << 2));\n\t}\n\n\tmemcpy(val, (u8 *)p, bytes);\n\n\tmutex_unlock(&priv->lock);\n\n\tkfree(p);\n\n\treturn 0;\n};\n\nstatic int imx_ele_ocotp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct imx_ocotp_priv *priv;\n\tstruct nvmem_device *nvmem;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->data = of_device_get_match_data(dev);\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->config.dev = dev;\n\tpriv->config.name = \"ELE-OCOTP\";\n\tpriv->config.id = NVMEM_DEVID_AUTO;\n\tpriv->config.owner = THIS_MODULE;\n\tpriv->config.size = priv->data->size;\n\tpriv->config.reg_read = priv->data->reg_read;\n\tpriv->config.word_size = 4;\n\tpriv->config.stride = 1;\n\tpriv->config.priv = priv;\n\tpriv->config.read_only = true;\n\tmutex_init(&priv->lock);\n\n\tnvmem = devm_nvmem_register(dev, &priv->config);\n\tif (IS_ERR(nvmem))\n\t\treturn PTR_ERR(nvmem);\n\n\treturn 0;\n}\n\nstatic const struct ocotp_devtype_data imx93_ocotp_data = {\n\t.reg_off = 0x8000,\n\t.reg_read = imx_ocotp_reg_read,\n\t.size = 2048,\n\t.num_entry = 6,\n\t.entry = {\n\t\t{ 0, 52, FUSE_FSB },\n\t\t{ 63, 1, FUSE_ELE},\n\t\t{ 128, 16, FUSE_ELE },\n\t\t{ 182, 1, FUSE_ELE },\n\t\t{ 188, 1, FUSE_ELE },\n\t\t{ 312, 200, FUSE_FSB }\n\t},\n};\n\nstatic const struct of_device_id imx_ele_ocotp_dt_ids[] = {\n\t{ .compatible = \"fsl,imx93-ocotp\", .data = &imx93_ocotp_data, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, imx_ele_ocotp_dt_ids);\n\nstatic struct platform_driver imx_ele_ocotp_driver = {\n\t.driver = {\n\t\t.name = \"imx_ele_ocotp\",\n\t\t.of_match_table = imx_ele_ocotp_dt_ids,\n\t},\n\t.probe = imx_ele_ocotp_probe,\n};\nmodule_platform_driver(imx_ele_ocotp_driver);\n\nMODULE_DESCRIPTION(\"i.MX OCOTP/ELE driver\");\nMODULE_AUTHOR(\"Peng Fan <peng.fan@nxp.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}