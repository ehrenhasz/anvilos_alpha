{
  "module_name": "meson-mx-efuse.c",
  "hash_id": "35351b7698b409dda06b437a2e74e0ffd8b20f624e3f5f214446a0830ba6813e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/meson-mx-efuse.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n\n#define MESON_MX_EFUSE_CNTL1\t\t\t\t\t0x04\n#define MESON_MX_EFUSE_CNTL1_PD_ENABLE\t\t\t\tBIT(27)\n#define MESON_MX_EFUSE_CNTL1_AUTO_RD_BUSY\t\t\tBIT(26)\n#define MESON_MX_EFUSE_CNTL1_AUTO_RD_START\t\t\tBIT(25)\n#define MESON_MX_EFUSE_CNTL1_AUTO_RD_ENABLE\t\t\tBIT(24)\n#define MESON_MX_EFUSE_CNTL1_BYTE_WR_DATA\t\t\tGENMASK(23, 16)\n#define MESON_MX_EFUSE_CNTL1_AUTO_WR_BUSY\t\t\tBIT(14)\n#define MESON_MX_EFUSE_CNTL1_AUTO_WR_START\t\t\tBIT(13)\n#define MESON_MX_EFUSE_CNTL1_AUTO_WR_ENABLE\t\t\tBIT(12)\n#define MESON_MX_EFUSE_CNTL1_BYTE_ADDR_SET\t\t\tBIT(11)\n#define MESON_MX_EFUSE_CNTL1_BYTE_ADDR_MASK\t\t\tGENMASK(10, 0)\n\n#define MESON_MX_EFUSE_CNTL2\t\t\t\t\t0x08\n\n#define MESON_MX_EFUSE_CNTL4\t\t\t\t\t0x10\n#define MESON_MX_EFUSE_CNTL4_ENCRYPT_ENABLE\t\t\tBIT(10)\n\nstruct meson_mx_efuse_platform_data {\n\tconst char *name;\n\tunsigned int word_size;\n};\n\nstruct meson_mx_efuse {\n\tvoid __iomem *base;\n\tstruct clk *core_clk;\n\tstruct nvmem_device *nvmem;\n\tstruct nvmem_config config;\n};\n\nstatic void meson_mx_efuse_mask_bits(struct meson_mx_efuse *efuse, u32 reg,\n\t\t\t\t     u32 mask, u32 set)\n{\n\tu32 data;\n\n\tdata = readl(efuse->base + reg);\n\tdata &= ~mask;\n\tdata |= (set & mask);\n\n\twritel(data, efuse->base + reg);\n}\n\nstatic int meson_mx_efuse_hw_enable(struct meson_mx_efuse *efuse)\n{\n\tint err;\n\n\terr = clk_prepare_enable(efuse->core_clk);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmeson_mx_efuse_mask_bits(efuse, MESON_MX_EFUSE_CNTL1,\n\t\t\t\t MESON_MX_EFUSE_CNTL1_PD_ENABLE, 0);\n\n\tmeson_mx_efuse_mask_bits(efuse, MESON_MX_EFUSE_CNTL4,\n\t\t\t\t MESON_MX_EFUSE_CNTL4_ENCRYPT_ENABLE, 0);\n\n\treturn 0;\n}\n\nstatic void meson_mx_efuse_hw_disable(struct meson_mx_efuse *efuse)\n{\n\tmeson_mx_efuse_mask_bits(efuse, MESON_MX_EFUSE_CNTL1,\n\t\t\t\t MESON_MX_EFUSE_CNTL1_PD_ENABLE,\n\t\t\t\t MESON_MX_EFUSE_CNTL1_PD_ENABLE);\n\n\tclk_disable_unprepare(efuse->core_clk);\n}\n\nstatic int meson_mx_efuse_read_addr(struct meson_mx_efuse *efuse,\n\t\t\t\t    unsigned int addr, u32 *value)\n{\n\tint err;\n\tu32 regval;\n\n\t \n\tregval = FIELD_PREP(MESON_MX_EFUSE_CNTL1_BYTE_ADDR_MASK, addr);\n\tmeson_mx_efuse_mask_bits(efuse, MESON_MX_EFUSE_CNTL1,\n\t\t\t\t MESON_MX_EFUSE_CNTL1_BYTE_ADDR_MASK, regval);\n\n\t \n\tmeson_mx_efuse_mask_bits(efuse, MESON_MX_EFUSE_CNTL1,\n\t\t\t\t MESON_MX_EFUSE_CNTL1_BYTE_ADDR_SET,\n\t\t\t\t MESON_MX_EFUSE_CNTL1_BYTE_ADDR_SET);\n\tmeson_mx_efuse_mask_bits(efuse, MESON_MX_EFUSE_CNTL1,\n\t\t\t\t MESON_MX_EFUSE_CNTL1_BYTE_ADDR_SET, 0);\n\n\t \n\tmeson_mx_efuse_mask_bits(efuse, MESON_MX_EFUSE_CNTL1,\n\t\t\t\t MESON_MX_EFUSE_CNTL1_AUTO_RD_START,\n\t\t\t\t MESON_MX_EFUSE_CNTL1_AUTO_RD_START);\n\tmeson_mx_efuse_mask_bits(efuse, MESON_MX_EFUSE_CNTL1,\n\t\t\t\t MESON_MX_EFUSE_CNTL1_AUTO_RD_START, 0);\n\n\t \n\treadl(efuse->base + MESON_MX_EFUSE_CNTL1);\n\n\terr = readl_poll_timeout_atomic(efuse->base + MESON_MX_EFUSE_CNTL1,\n\t\t\tregval,\n\t\t\t(!(regval & MESON_MX_EFUSE_CNTL1_AUTO_RD_BUSY)),\n\t\t\t1, 1000);\n\tif (err) {\n\t\tdev_err(efuse->config.dev,\n\t\t\t\"Timeout while reading efuse address %u\\n\", addr);\n\t\treturn err;\n\t}\n\n\t*value = readl(efuse->base + MESON_MX_EFUSE_CNTL2);\n\n\treturn 0;\n}\n\nstatic int meson_mx_efuse_read(void *context, unsigned int offset,\n\t\t\t       void *buf, size_t bytes)\n{\n\tstruct meson_mx_efuse *efuse = context;\n\tu32 tmp;\n\tint err, i, addr;\n\n\terr = meson_mx_efuse_hw_enable(efuse);\n\tif (err)\n\t\treturn err;\n\n\tmeson_mx_efuse_mask_bits(efuse, MESON_MX_EFUSE_CNTL1,\n\t\t\t\t MESON_MX_EFUSE_CNTL1_AUTO_RD_ENABLE,\n\t\t\t\t MESON_MX_EFUSE_CNTL1_AUTO_RD_ENABLE);\n\n\tfor (i = 0; i < bytes; i += efuse->config.word_size) {\n\t\taddr = (offset + i) / efuse->config.word_size;\n\n\t\terr = meson_mx_efuse_read_addr(efuse, addr, &tmp);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tmemcpy(buf + i, &tmp,\n\t\t       min_t(size_t, bytes - i, efuse->config.word_size));\n\t}\n\n\tmeson_mx_efuse_mask_bits(efuse, MESON_MX_EFUSE_CNTL1,\n\t\t\t\t MESON_MX_EFUSE_CNTL1_AUTO_RD_ENABLE, 0);\n\n\tmeson_mx_efuse_hw_disable(efuse);\n\n\treturn err;\n}\n\nstatic const struct meson_mx_efuse_platform_data meson6_efuse_data = {\n\t.name = \"meson6-efuse\",\n\t.word_size = 1,\n};\n\nstatic const struct meson_mx_efuse_platform_data meson8_efuse_data = {\n\t.name = \"meson8-efuse\",\n\t.word_size = 4,\n};\n\nstatic const struct meson_mx_efuse_platform_data meson8b_efuse_data = {\n\t.name = \"meson8b-efuse\",\n\t.word_size = 4,\n};\n\nstatic const struct of_device_id meson_mx_efuse_match[] = {\n\t{ .compatible = \"amlogic,meson6-efuse\", .data = &meson6_efuse_data },\n\t{ .compatible = \"amlogic,meson8-efuse\", .data = &meson8_efuse_data },\n\t{ .compatible = \"amlogic,meson8b-efuse\", .data = &meson8b_efuse_data },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, meson_mx_efuse_match);\n\nstatic int meson_mx_efuse_probe(struct platform_device *pdev)\n{\n\tconst struct meson_mx_efuse_platform_data *drvdata;\n\tstruct meson_mx_efuse *efuse;\n\n\tdrvdata = of_device_get_match_data(&pdev->dev);\n\tif (!drvdata)\n\t\treturn -EINVAL;\n\n\tefuse = devm_kzalloc(&pdev->dev, sizeof(*efuse), GFP_KERNEL);\n\tif (!efuse)\n\t\treturn -ENOMEM;\n\n\tefuse->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(efuse->base))\n\t\treturn PTR_ERR(efuse->base);\n\n\tefuse->config.name = drvdata->name;\n\tefuse->config.owner = THIS_MODULE;\n\tefuse->config.dev = &pdev->dev;\n\tefuse->config.priv = efuse;\n\tefuse->config.stride = drvdata->word_size;\n\tefuse->config.word_size = drvdata->word_size;\n\tefuse->config.size = SZ_512;\n\tefuse->config.read_only = true;\n\tefuse->config.reg_read = meson_mx_efuse_read;\n\n\tefuse->core_clk = devm_clk_get(&pdev->dev, \"core\");\n\tif (IS_ERR(efuse->core_clk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get core clock\\n\");\n\t\treturn PTR_ERR(efuse->core_clk);\n\t}\n\n\tefuse->nvmem = devm_nvmem_register(&pdev->dev, &efuse->config);\n\n\treturn PTR_ERR_OR_ZERO(efuse->nvmem);\n}\n\nstatic struct platform_driver meson_mx_efuse_driver = {\n\t.probe = meson_mx_efuse_probe,\n\t.driver = {\n\t\t.name = \"meson-mx-efuse\",\n\t\t.of_match_table = meson_mx_efuse_match,\n\t},\n};\n\nmodule_platform_driver(meson_mx_efuse_driver);\n\nMODULE_AUTHOR(\"Martin Blumenstingl <martin.blumenstingl@googlemail.com>\");\nMODULE_DESCRIPTION(\"Amlogic Meson MX eFuse NVMEM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}