{
  "module_name": "qcom-spmi-sdam.c",
  "hash_id": "c3d30c7cd0c10b7a36623d0ae6f81cc185f91c95a320b2c8abac7caa47c8992a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/qcom-spmi-sdam.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/nvmem-provider.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define SDAM_MEM_START\t\t\t0x40\n#define REGISTER_MAP_ID\t\t\t0x40\n#define REGISTER_MAP_VERSION\t\t0x41\n#define SDAM_SIZE\t\t\t0x44\n#define SDAM_PBS_TRIG_SET\t\t0xE5\n#define SDAM_PBS_TRIG_CLR\t\t0xE6\n\nstruct sdam_chip {\n\tstruct regmap\t\t\t*regmap;\n\tstruct nvmem_config\t\tsdam_config;\n\tunsigned int\t\t\tbase;\n\tunsigned int\t\t\tsize;\n};\n\n \nstatic const u8 sdam_ro_map[] = {\n\tREGISTER_MAP_ID,\n\tREGISTER_MAP_VERSION,\n\tSDAM_SIZE\n};\n\nstatic bool sdam_is_valid(struct sdam_chip *sdam, unsigned int offset,\n\t\t\t\tsize_t len)\n{\n\tunsigned int sdam_mem_end = SDAM_MEM_START + sdam->size - 1;\n\n\tif (!len)\n\t\treturn false;\n\n\tif (offset >= SDAM_MEM_START && offset <= sdam_mem_end\n\t\t\t\t&& (offset + len - 1) <= sdam_mem_end)\n\t\treturn true;\n\telse if ((offset == SDAM_PBS_TRIG_SET || offset == SDAM_PBS_TRIG_CLR)\n\t\t\t\t&& (len == 1))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool sdam_is_ro(unsigned int offset, size_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sdam_ro_map); i++)\n\t\tif (offset <= sdam_ro_map[i] && (offset + len) > sdam_ro_map[i])\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int sdam_read(void *priv, unsigned int offset, void *val,\n\t\t\t\tsize_t bytes)\n{\n\tstruct sdam_chip *sdam = priv;\n\tstruct device *dev = sdam->sdam_config.dev;\n\tint rc;\n\n\tif (!sdam_is_valid(sdam, offset, bytes)) {\n\t\tdev_err(dev, \"Invalid SDAM offset %#x len=%zd\\n\",\n\t\t\toffset, bytes);\n\t\treturn -EINVAL;\n\t}\n\n\trc = regmap_bulk_read(sdam->regmap, sdam->base + offset, val, bytes);\n\tif (rc < 0)\n\t\tdev_err(dev, \"Failed to read SDAM offset %#x len=%zd, rc=%d\\n\",\n\t\t\t\t\t\toffset, bytes, rc);\n\n\treturn rc;\n}\n\nstatic int sdam_write(void *priv, unsigned int offset, void *val,\n\t\t\t\tsize_t bytes)\n{\n\tstruct sdam_chip *sdam = priv;\n\tstruct device *dev = sdam->sdam_config.dev;\n\tint rc;\n\n\tif (!sdam_is_valid(sdam, offset, bytes)) {\n\t\tdev_err(dev, \"Invalid SDAM offset %#x len=%zd\\n\",\n\t\t\toffset, bytes);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sdam_is_ro(offset, bytes)) {\n\t\tdev_err(dev, \"Invalid write offset %#x len=%zd\\n\",\n\t\t\toffset, bytes);\n\t\treturn -EINVAL;\n\t}\n\n\trc = regmap_bulk_write(sdam->regmap, sdam->base + offset, val, bytes);\n\tif (rc < 0)\n\t\tdev_err(dev, \"Failed to write SDAM offset %#x len=%zd, rc=%d\\n\",\n\t\t\t\t\t\toffset, bytes, rc);\n\n\treturn rc;\n}\n\nstatic int sdam_probe(struct platform_device *pdev)\n{\n\tstruct sdam_chip *sdam;\n\tstruct nvmem_device *nvmem;\n\tunsigned int val;\n\tint rc;\n\n\tsdam = devm_kzalloc(&pdev->dev, sizeof(*sdam), GFP_KERNEL);\n\tif (!sdam)\n\t\treturn -ENOMEM;\n\n\tsdam->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!sdam->regmap) {\n\t\tdev_err(&pdev->dev, \"Failed to get regmap handle\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\trc = of_property_read_u32(pdev->dev.of_node, \"reg\", &sdam->base);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get SDAM base, rc=%d\\n\", rc);\n\t\treturn -EINVAL;\n\t}\n\n\trc = regmap_read(sdam->regmap, sdam->base + SDAM_SIZE, &val);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to read SDAM_SIZE rc=%d\\n\", rc);\n\t\treturn -EINVAL;\n\t}\n\tsdam->size = val * 32;\n\n\tsdam->sdam_config.dev = &pdev->dev;\n\tsdam->sdam_config.name = \"spmi_sdam\";\n\tsdam->sdam_config.id = NVMEM_DEVID_AUTO;\n\tsdam->sdam_config.owner = THIS_MODULE;\n\tsdam->sdam_config.stride = 1;\n\tsdam->sdam_config.word_size = 1;\n\tsdam->sdam_config.reg_read = sdam_read;\n\tsdam->sdam_config.reg_write = sdam_write;\n\tsdam->sdam_config.priv = sdam;\n\n\tnvmem = devm_nvmem_register(&pdev->dev, &sdam->sdam_config);\n\tif (IS_ERR(nvmem)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register SDAM nvmem device rc=%ld\\n\",\n\t\t\tPTR_ERR(nvmem));\n\t\treturn -ENXIO;\n\t}\n\tdev_dbg(&pdev->dev,\n\t\t\"SDAM base=%#x size=%u registered successfully\\n\",\n\t\tsdam->base, sdam->size);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sdam_match_table[] = {\n\t{ .compatible = \"qcom,spmi-sdam\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sdam_match_table);\n\nstatic struct platform_driver sdam_driver = {\n\t.driver = {\n\t\t.name = \"qcom,spmi-sdam\",\n\t\t.of_match_table = sdam_match_table,\n\t},\n\t.probe\t\t= sdam_probe,\n};\nmodule_platform_driver(sdam_driver);\n\nMODULE_DESCRIPTION(\"QCOM SPMI SDAM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}