{
  "module_name": "qfprom.c",
  "hash_id": "d0752a1557d39e21fa27e4ee5ad6ec44bdaab3e79c7bc4886d41b3561163a3a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/qfprom.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/nvmem-provider.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n\n \n#define QFPROM_BLOW_TIMER_OFFSET 0x03c\n\n \n#define QFPROM_FUSE_BLOW_POLL_US\t100\n#define QFPROM_FUSE_BLOW_TIMEOUT_US\t10000\n\n#define QFPROM_BLOW_STATUS_OFFSET\t0x048\n#define QFPROM_BLOW_STATUS_BUSY\t\t0x1\n#define QFPROM_BLOW_STATUS_READY\t0x0\n\n#define QFPROM_ACCEL_OFFSET\t\t0x044\n\n#define QFPROM_VERSION_OFFSET\t\t0x0\n#define QFPROM_MAJOR_VERSION_SHIFT\t28\n#define QFPROM_MAJOR_VERSION_MASK\tGENMASK(31, QFPROM_MAJOR_VERSION_SHIFT)\n#define QFPROM_MINOR_VERSION_SHIFT\t16\n#define QFPROM_MINOR_VERSION_MASK\tGENMASK(27, QFPROM_MINOR_VERSION_SHIFT)\n\nstatic bool read_raw_data;\nmodule_param(read_raw_data, bool, 0644);\nMODULE_PARM_DESC(read_raw_data, \"Read raw instead of corrected data\");\n\n \nstruct qfprom_soc_data {\n\tu32 accel_value;\n\tu32 qfprom_blow_timer_value;\n\tu32 qfprom_blow_set_freq;\n\tint qfprom_blow_uV;\n};\n\n \nstruct qfprom_priv {\n\tvoid __iomem *qfpraw;\n\tvoid __iomem *qfpconf;\n\tvoid __iomem *qfpcorrected;\n\tvoid __iomem *qfpsecurity;\n\tstruct device *dev;\n\tstruct clk *secclk;\n\tstruct regulator *vcc;\n\tconst struct qfprom_soc_data *soc_data;\n};\n\n \nstruct qfprom_touched_values {\n\tunsigned long clk_rate;\n\tu32 accel_val;\n\tu32 timer_val;\n};\n\n \nstruct qfprom_soc_compatible_data {\n\tconst struct nvmem_keepout *keepout;\n\tunsigned int nkeepout;\n};\n\nstatic const struct nvmem_keepout sc7180_qfprom_keepout[] = {\n\t{.start = 0x128, .end = 0x148},\n\t{.start = 0x220, .end = 0x228}\n};\n\nstatic const struct qfprom_soc_compatible_data sc7180_qfprom = {\n\t.keepout = sc7180_qfprom_keepout,\n\t.nkeepout = ARRAY_SIZE(sc7180_qfprom_keepout)\n};\n\nstatic const struct nvmem_keepout sc7280_qfprom_keepout[] = {\n\t{.start = 0x128, .end = 0x148},\n\t{.start = 0x238, .end = 0x248}\n};\n\nstatic const struct qfprom_soc_compatible_data sc7280_qfprom = {\n\t.keepout = sc7280_qfprom_keepout,\n\t.nkeepout = ARRAY_SIZE(sc7280_qfprom_keepout)\n};\n\n \nstatic void qfprom_disable_fuse_blowing(const struct qfprom_priv *priv,\n\t\t\t\t\tconst struct qfprom_touched_values *old)\n{\n\tint ret;\n\n\twritel(old->timer_val, priv->qfpconf + QFPROM_BLOW_TIMER_OFFSET);\n\twritel(old->accel_val, priv->qfpconf + QFPROM_ACCEL_OFFSET);\n\n\tdev_pm_genpd_set_performance_state(priv->dev, 0);\n\tpm_runtime_put(priv->dev);\n\n\t \n\tret = regulator_set_voltage(priv->vcc, 0, INT_MAX);\n\tif (ret)\n\t\tdev_warn(priv->dev, \"Failed to set 0 voltage (ignoring)\\n\");\n\n\tret = regulator_disable(priv->vcc);\n\tif (ret)\n\t\tdev_warn(priv->dev, \"Failed to disable regulator (ignoring)\\n\");\n\n\tret = clk_set_rate(priv->secclk, old->clk_rate);\n\tif (ret)\n\t\tdev_warn(priv->dev,\n\t\t\t \"Failed to set clock rate for disable (ignoring)\\n\");\n\n\tclk_disable_unprepare(priv->secclk);\n}\n\n \nstatic int qfprom_enable_fuse_blowing(const struct qfprom_priv *priv,\n\t\t\t\t      struct qfprom_touched_values *old)\n{\n\tint ret;\n\tint qfprom_blow_uV = priv->soc_data->qfprom_blow_uV;\n\n\tret = clk_prepare_enable(priv->secclk);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\told->clk_rate = clk_get_rate(priv->secclk);\n\tret = clk_set_rate(priv->secclk, priv->soc_data->qfprom_blow_set_freq);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to set clock rate for enable\\n\");\n\t\tgoto err_clk_prepared;\n\t}\n\n\t \n\tret = regulator_set_voltage(priv->vcc, qfprom_blow_uV, INT_MAX);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to set %duV\\n\", qfprom_blow_uV);\n\t\tgoto err_clk_rate_set;\n\t}\n\n\tret = regulator_enable(priv->vcc);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to enable regulator\\n\");\n\t\tgoto err_clk_rate_set;\n\t}\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"Failed to enable power-domain\\n\");\n\t\tgoto err_reg_enable;\n\t}\n\tdev_pm_genpd_set_performance_state(priv->dev, INT_MAX);\n\n\told->timer_val = readl(priv->qfpconf + QFPROM_BLOW_TIMER_OFFSET);\n\told->accel_val = readl(priv->qfpconf + QFPROM_ACCEL_OFFSET);\n\twritel(priv->soc_data->qfprom_blow_timer_value,\n\t       priv->qfpconf + QFPROM_BLOW_TIMER_OFFSET);\n\twritel(priv->soc_data->accel_value,\n\t       priv->qfpconf + QFPROM_ACCEL_OFFSET);\n\n\treturn 0;\n\nerr_reg_enable:\n\tregulator_disable(priv->vcc);\nerr_clk_rate_set:\n\tclk_set_rate(priv->secclk, old->clk_rate);\nerr_clk_prepared:\n\tclk_disable_unprepare(priv->secclk);\n\treturn ret;\n}\n\n \nstatic int qfprom_reg_write(void *context, unsigned int reg, void *_val,\n\t\t\t    size_t bytes)\n{\n\tstruct qfprom_priv *priv = context;\n\tstruct qfprom_touched_values old;\n\tint words = bytes / 4;\n\tu32 *value = _val;\n\tu32 blow_status;\n\tint ret;\n\tint i;\n\n\tdev_dbg(priv->dev,\n\t\t\"Writing to raw qfprom region : %#010x of size: %zu\\n\",\n\t\treg, bytes);\n\n\t \n\tif (bytes % 4) {\n\t\tdev_err(priv->dev,\n\t\t\t\"%zu is not an integral number of words\\n\", bytes);\n\t\treturn -EINVAL;\n\t}\n\tif (reg % 4) {\n\t\tdev_err(priv->dev,\n\t\t\t\"Invalid offset: %#x.  Must be word aligned\\n\", reg);\n\t\treturn -EINVAL;\n\t}\n\n\tret = qfprom_enable_fuse_blowing(priv, &old);\n\tif (ret)\n\t\treturn ret;\n\n\tret = readl_relaxed_poll_timeout(\n\t\tpriv->qfpconf + QFPROM_BLOW_STATUS_OFFSET,\n\t\tblow_status, blow_status == QFPROM_BLOW_STATUS_READY,\n\t\tQFPROM_FUSE_BLOW_POLL_US, QFPROM_FUSE_BLOW_TIMEOUT_US);\n\n\tif (ret) {\n\t\tdev_err(priv->dev,\n\t\t\t\"Timeout waiting for initial ready; aborting.\\n\");\n\t\tgoto exit_enabled_fuse_blowing;\n\t}\n\n\tfor (i = 0; i < words; i++)\n\t\twritel(value[i], priv->qfpraw + reg + (i * 4));\n\n\tret = readl_relaxed_poll_timeout(\n\t\tpriv->qfpconf + QFPROM_BLOW_STATUS_OFFSET,\n\t\tblow_status, blow_status == QFPROM_BLOW_STATUS_READY,\n\t\tQFPROM_FUSE_BLOW_POLL_US, QFPROM_FUSE_BLOW_TIMEOUT_US);\n\n\t \n\tif (ret)\n\t\tdev_err(priv->dev, \"Timeout waiting for finish.\\n\");\n\nexit_enabled_fuse_blowing:\n\tqfprom_disable_fuse_blowing(priv, &old);\n\n\treturn ret;\n}\n\nstatic int qfprom_reg_read(void *context,\n\t\t\tunsigned int reg, void *_val, size_t bytes)\n{\n\tstruct qfprom_priv *priv = context;\n\tu8 *val = _val;\n\tint i = 0, words = bytes;\n\tvoid __iomem *base = priv->qfpcorrected;\n\n\tif (read_raw_data && priv->qfpraw)\n\t\tbase = priv->qfpraw;\n\n\twhile (words--)\n\t\t*val++ = readb(base + reg + i++);\n\n\treturn 0;\n}\n\nstatic void qfprom_runtime_disable(void *data)\n{\n\tpm_runtime_disable(data);\n}\n\nstatic const struct qfprom_soc_data qfprom_7_8_data = {\n\t.accel_value = 0xD10,\n\t.qfprom_blow_timer_value = 25,\n\t.qfprom_blow_set_freq = 4800000,\n\t.qfprom_blow_uV = 1800000,\n};\n\nstatic const struct qfprom_soc_data qfprom_7_15_data = {\n\t.accel_value = 0xD08,\n\t.qfprom_blow_timer_value = 24,\n\t.qfprom_blow_set_freq = 4800000,\n\t.qfprom_blow_uV = 1900000,\n};\n\nstatic int qfprom_probe(struct platform_device *pdev)\n{\n\tstruct nvmem_config econfig = {\n\t\t.name = \"qfprom\",\n\t\t.stride = 1,\n\t\t.word_size = 1,\n\t\t.id = NVMEM_DEVID_AUTO,\n\t\t.reg_read = qfprom_reg_read,\n\t};\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tstruct nvmem_device *nvmem;\n\tconst struct qfprom_soc_compatible_data *soc_data;\n\tstruct qfprom_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tpriv->qfpcorrected = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(priv->qfpcorrected))\n\t\treturn PTR_ERR(priv->qfpcorrected);\n\n\teconfig.size = resource_size(res);\n\teconfig.dev = dev;\n\teconfig.priv = priv;\n\n\tpriv->dev = dev;\n\tsoc_data = device_get_match_data(dev);\n\tif (soc_data) {\n\t\teconfig.keepout = soc_data->keepout;\n\t\teconfig.nkeepout = soc_data->nkeepout;\n\t}\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (res) {\n\t\tu32 version;\n\t\tint major_version, minor_version;\n\n\t\tpriv->qfpraw = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(priv->qfpraw))\n\t\t\treturn PTR_ERR(priv->qfpraw);\n\t\tpriv->qfpconf = devm_platform_ioremap_resource(pdev, 2);\n\t\tif (IS_ERR(priv->qfpconf))\n\t\t\treturn PTR_ERR(priv->qfpconf);\n\t\tpriv->qfpsecurity = devm_platform_ioremap_resource(pdev, 3);\n\t\tif (IS_ERR(priv->qfpsecurity))\n\t\t\treturn PTR_ERR(priv->qfpsecurity);\n\n\t\tversion = readl(priv->qfpsecurity + QFPROM_VERSION_OFFSET);\n\t\tmajor_version = (version & QFPROM_MAJOR_VERSION_MASK) >>\n\t\t\t\tQFPROM_MAJOR_VERSION_SHIFT;\n\t\tminor_version = (version & QFPROM_MINOR_VERSION_MASK) >>\n\t\t\t\tQFPROM_MINOR_VERSION_SHIFT;\n\n\t\tif (major_version == 7 && minor_version == 8)\n\t\t\tpriv->soc_data = &qfprom_7_8_data;\n\t\telse if (major_version == 7 && minor_version == 15)\n\t\t\tpriv->soc_data = &qfprom_7_15_data;\n\n\t\tpriv->vcc = devm_regulator_get(&pdev->dev, \"vcc\");\n\t\tif (IS_ERR(priv->vcc))\n\t\t\treturn PTR_ERR(priv->vcc);\n\n\t\tpriv->secclk = devm_clk_get(dev, \"core\");\n\t\tif (IS_ERR(priv->secclk))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(priv->secclk), \"Error getting clock\\n\");\n\n\t\t \n\t\tif (priv->soc_data)\n\t\t\teconfig.reg_write = qfprom_reg_write;\n\t}\n\n\tpm_runtime_enable(dev);\n\tret = devm_add_action_or_reset(dev, qfprom_runtime_disable, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tnvmem = devm_nvmem_register(dev, &econfig);\n\n\treturn PTR_ERR_OR_ZERO(nvmem);\n}\n\nstatic const struct of_device_id qfprom_of_match[] = {\n\t{ .compatible = \"qcom,qfprom\",},\n\t{ .compatible = \"qcom,sc7180-qfprom\", .data = &sc7180_qfprom},\n\t{ .compatible = \"qcom,sc7280-qfprom\", .data = &sc7280_qfprom},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, qfprom_of_match);\n\nstatic struct platform_driver qfprom_driver = {\n\t.probe = qfprom_probe,\n\t.driver = {\n\t\t.name = \"qcom,qfprom\",\n\t\t.of_match_table = qfprom_of_match,\n\t},\n};\nmodule_platform_driver(qfprom_driver);\nMODULE_AUTHOR(\"Srinivas Kandagatla <srinivas.kandagatla@linaro.org>\");\nMODULE_DESCRIPTION(\"Qualcomm QFPROM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}