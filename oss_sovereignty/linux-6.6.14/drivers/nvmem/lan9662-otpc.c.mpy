{
  "module_name": "lan9662-otpc.c",
  "hash_id": "cbc657b840235191ce3654997b6b42801356b5b63f847501513ce7267a7420e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/lan9662-otpc.c",
  "human_readable_source": "\n\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#define OTP_OTP_PWR_DN(t)\t\t\t(t + 0x00)\n#define OTP_OTP_PWR_DN_OTP_PWRDN_N\t\tBIT(0)\n#define OTP_OTP_ADDR_HI(t)\t\t\t(t + 0x04)\n#define OTP_OTP_ADDR_LO(t)\t\t\t(t + 0x08)\n#define OTP_OTP_PRGM_DATA(t)\t\t\t(t + 0x10)\n#define OTP_OTP_PRGM_MODE(t)\t\t\t(t + 0x14)\n#define OTP_OTP_PRGM_MODE_OTP_PGM_MODE_BYTE\tBIT(0)\n#define OTP_OTP_RD_DATA(t)\t\t\t(t + 0x18)\n#define OTP_OTP_FUNC_CMD(t)\t\t\t(t + 0x20)\n#define OTP_OTP_FUNC_CMD_OTP_PROGRAM\t\tBIT(1)\n#define OTP_OTP_FUNC_CMD_OTP_READ\t\tBIT(0)\n#define OTP_OTP_CMD_GO(t)\t\t\t(t + 0x28)\n#define OTP_OTP_CMD_GO_OTP_GO\t\t\tBIT(0)\n#define OTP_OTP_PASS_FAIL(t)\t\t\t(t + 0x2c)\n#define OTP_OTP_PASS_FAIL_OTP_READ_PROHIBITED\tBIT(3)\n#define OTP_OTP_PASS_FAIL_OTP_WRITE_PROHIBITED\tBIT(2)\n#define OTP_OTP_PASS_FAIL_OTP_FAIL\t\tBIT(0)\n#define OTP_OTP_STATUS(t)\t\t\t(t + 0x30)\n#define OTP_OTP_STATUS_OTP_CPUMPEN\t\tBIT(1)\n#define OTP_OTP_STATUS_OTP_BUSY\t\t\tBIT(0)\n\n#define OTP_MEM_SIZE 8192\n#define OTP_SLEEP_US 10\n#define OTP_TIMEOUT_US 500000\n\nstruct lan9662_otp {\n\tstruct device *dev;\n\tvoid __iomem *base;\n};\n\nstatic int lan9662_otp_wait_flag_clear(void __iomem *reg, u32 flag)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout(reg, val, !(val & flag),\n\t\t\t\t  OTP_SLEEP_US, OTP_TIMEOUT_US);\n}\n\nstatic int lan9662_otp_power(struct lan9662_otp *otp, bool up)\n{\n\tvoid __iomem *pwrdn = OTP_OTP_PWR_DN(otp->base);\n\n\tif (up) {\n\t\twritel(readl(pwrdn) & ~OTP_OTP_PWR_DN_OTP_PWRDN_N, pwrdn);\n\t\tif (lan9662_otp_wait_flag_clear(OTP_OTP_STATUS(otp->base),\n\t\t\t\t\t\tOTP_OTP_STATUS_OTP_CPUMPEN))\n\t\t\treturn -ETIMEDOUT;\n\t} else {\n\t\twritel(readl(pwrdn) | OTP_OTP_PWR_DN_OTP_PWRDN_N, pwrdn);\n\t}\n\n\treturn 0;\n}\n\nstatic int lan9662_otp_execute(struct lan9662_otp *otp)\n{\n\tif (lan9662_otp_wait_flag_clear(OTP_OTP_CMD_GO(otp->base),\n\t\t\t\t\tOTP_OTP_CMD_GO_OTP_GO))\n\t\treturn -ETIMEDOUT;\n\n\tif (lan9662_otp_wait_flag_clear(OTP_OTP_STATUS(otp->base),\n\t\t\t\t\tOTP_OTP_STATUS_OTP_BUSY))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic void lan9662_otp_set_address(struct lan9662_otp *otp, u32 offset)\n{\n\twritel(0xff & (offset >> 8), OTP_OTP_ADDR_HI(otp->base));\n\twritel(0xff & offset, OTP_OTP_ADDR_LO(otp->base));\n}\n\nstatic int lan9662_otp_read_byte(struct lan9662_otp *otp, u32 offset, u8 *dst)\n{\n\tu32 pass;\n\tint rc;\n\n\tlan9662_otp_set_address(otp, offset);\n\twritel(OTP_OTP_FUNC_CMD_OTP_READ, OTP_OTP_FUNC_CMD(otp->base));\n\twritel(OTP_OTP_CMD_GO_OTP_GO, OTP_OTP_CMD_GO(otp->base));\n\trc = lan9662_otp_execute(otp);\n\tif (!rc) {\n\t\tpass = readl(OTP_OTP_PASS_FAIL(otp->base));\n\t\tif (pass & OTP_OTP_PASS_FAIL_OTP_READ_PROHIBITED)\n\t\t\treturn -EACCES;\n\t\t*dst = (u8) readl(OTP_OTP_RD_DATA(otp->base));\n\t}\n\treturn rc;\n}\n\nstatic int lan9662_otp_write_byte(struct lan9662_otp *otp, u32 offset, u8 data)\n{\n\tu32 pass;\n\tint rc;\n\n\tlan9662_otp_set_address(otp, offset);\n\twritel(OTP_OTP_PRGM_MODE_OTP_PGM_MODE_BYTE, OTP_OTP_PRGM_MODE(otp->base));\n\twritel(data, OTP_OTP_PRGM_DATA(otp->base));\n\twritel(OTP_OTP_FUNC_CMD_OTP_PROGRAM, OTP_OTP_FUNC_CMD(otp->base));\n\twritel(OTP_OTP_CMD_GO_OTP_GO, OTP_OTP_CMD_GO(otp->base));\n\n\trc = lan9662_otp_execute(otp);\n\tif (!rc) {\n\t\tpass = readl(OTP_OTP_PASS_FAIL(otp->base));\n\t\tif (pass & OTP_OTP_PASS_FAIL_OTP_WRITE_PROHIBITED)\n\t\t\treturn -EACCES;\n\t\tif (pass & OTP_OTP_PASS_FAIL_OTP_FAIL)\n\t\t\treturn -EIO;\n\t}\n\treturn rc;\n}\n\nstatic int lan9662_otp_read(void *context, unsigned int offset,\n\t\t\t    void *_val, size_t bytes)\n{\n\tstruct lan9662_otp *otp = context;\n\tu8 *val = _val;\n\tuint8_t data;\n\tint i, rc = 0;\n\n\tlan9662_otp_power(otp, true);\n\tfor (i = 0; i < bytes; i++) {\n\t\trc = lan9662_otp_read_byte(otp, offset + i, &data);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\t*val++ = data;\n\t}\n\tlan9662_otp_power(otp, false);\n\n\treturn rc;\n}\n\nstatic int lan9662_otp_write(void *context, unsigned int offset,\n\t\t\t     void *_val, size_t bytes)\n{\n\tstruct lan9662_otp *otp = context;\n\tu8 *val = _val;\n\tu8 data, newdata;\n\tint i, rc = 0;\n\n\tlan9662_otp_power(otp, true);\n\tfor (i = 0; i < bytes; i++) {\n\t\t \n\t\tif (val[i]) {\n\t\t\trc = lan9662_otp_read_byte(otp, offset + i, &data);\n\t\t\tif (rc < 0)\n\t\t\t\tbreak;\n\n\t\t\tnewdata = data | val[i];\n\t\t\tif (newdata == data)\n\t\t\t\tcontinue;\n\n\t\t\trc = lan9662_otp_write_byte(otp, offset + i,\n\t\t\t\t\t\t      newdata);\n\t\t\tif (rc < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tlan9662_otp_power(otp, false);\n\n\treturn rc;\n}\n\nstatic struct nvmem_config otp_config = {\n\t.name = \"lan9662-otp\",\n\t.stride = 1,\n\t.word_size = 1,\n\t.reg_read = lan9662_otp_read,\n\t.reg_write = lan9662_otp_write,\n\t.size = OTP_MEM_SIZE,\n};\n\nstatic int lan9662_otp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct nvmem_device *nvmem;\n\tstruct lan9662_otp *otp;\n\n\totp = devm_kzalloc(&pdev->dev, sizeof(*otp), GFP_KERNEL);\n\tif (!otp)\n\t\treturn -ENOMEM;\n\n\totp->dev = dev;\n\totp->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(otp->base))\n\t\treturn PTR_ERR(otp->base);\n\n\totp_config.priv = otp;\n\totp_config.dev = dev;\n\n\tnvmem = devm_nvmem_register(dev, &otp_config);\n\n\treturn PTR_ERR_OR_ZERO(nvmem);\n}\n\nstatic const struct of_device_id lan9662_otp_match[] = {\n\t{ .compatible = \"microchip,lan9662-otpc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, lan9662_otp_match);\n\nstatic struct platform_driver lan9662_otp_driver = {\n\t.probe = lan9662_otp_probe,\n\t.driver = {\n\t\t.name = \"lan9662-otp\",\n\t\t.of_match_table = lan9662_otp_match,\n\t},\n};\nmodule_platform_driver(lan9662_otp_driver);\n\nMODULE_AUTHOR(\"Horatiu Vultur <horatiu.vultur@microchip.com>\");\nMODULE_DESCRIPTION(\"lan9662 OTP driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}