{
  "module_name": "stm32-romem.c",
  "hash_id": "86cf9f9ac50eeefccbe4983d45c50c497da732b539d30c5fd025d2f86dcf3e1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/stm32-romem.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of_device.h>\n#include <linux/tee_drv.h>\n\n#include \"stm32-bsec-optee-ta.h\"\n\n \n#define STM32_SMC_BSEC\t\t\t0x82001003\n#define STM32_SMC_READ_SHADOW\t\t0x01\n#define STM32_SMC_PROG_OTP\t\t0x02\n#define STM32_SMC_WRITE_SHADOW\t\t0x03\n#define STM32_SMC_READ_OTP\t\t0x04\n\n \n#define STM32MP15_BSEC_DATA0\t\t0x200\n\nstruct stm32_romem_cfg {\n\tint size;\n\tu8 lower;\n\tbool ta;\n};\n\nstruct stm32_romem_priv {\n\tvoid __iomem *base;\n\tstruct nvmem_config cfg;\n\tu8 lower;\n\tstruct tee_context *ctx;\n};\n\nstatic int stm32_romem_read(void *context, unsigned int offset, void *buf,\n\t\t\t    size_t bytes)\n{\n\tstruct stm32_romem_priv *priv = context;\n\tu8 *buf8 = buf;\n\tint i;\n\n\tfor (i = offset; i < offset + bytes; i++)\n\t\t*buf8++ = readb_relaxed(priv->base + i);\n\n\treturn 0;\n}\n\nstatic int stm32_bsec_smc(u8 op, u32 otp, u32 data, u32 *result)\n{\n#if IS_ENABLED(CONFIG_HAVE_ARM_SMCCC)\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_smc(STM32_SMC_BSEC, op, otp, data, 0, 0, 0, 0, &res);\n\tif (res.a0)\n\t\treturn -EIO;\n\n\tif (result)\n\t\t*result = (u32)res.a1;\n\n\treturn 0;\n#else\n\treturn -ENXIO;\n#endif\n}\n\nstatic int stm32_bsec_read(void *context, unsigned int offset, void *buf,\n\t\t\t   size_t bytes)\n{\n\tstruct stm32_romem_priv *priv = context;\n\tstruct device *dev = priv->cfg.dev;\n\tu32 roffset, rbytes, val;\n\tu8 *buf8 = buf, *val8 = (u8 *)&val;\n\tint i, j = 0, ret, skip_bytes, size;\n\n\t \n\troffset = rounddown(offset, 4);\n\tskip_bytes = offset & 0x3;\n\trbytes = roundup(bytes + skip_bytes, 4);\n\n\tif (roffset + rbytes > priv->cfg.size)\n\t\treturn -EINVAL;\n\n\tfor (i = roffset; (i < roffset + rbytes); i += 4) {\n\t\tu32 otp = i >> 2;\n\n\t\tif (otp < priv->lower) {\n\t\t\t \n\t\t\tval = readl_relaxed(\n\t\t\t\tpriv->base + STM32MP15_BSEC_DATA0 + i);\n\t\t} else {\n\t\t\tret = stm32_bsec_smc(STM32_SMC_READ_SHADOW, otp, 0,\n\t\t\t\t\t     &val);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Can't read data%d (%d)\\n\", otp,\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (skip_bytes)\n\t\t\tsize = min(bytes, (size_t)(4 - skip_bytes));\n\t\telse\n\t\t\tsize = min(bytes, (size_t)4);\n\t\tmemcpy(&buf8[j], &val8[skip_bytes], size);\n\t\tbytes -= size;\n\t\tj += size;\n\t\tskip_bytes = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_bsec_write(void *context, unsigned int offset, void *buf,\n\t\t\t    size_t bytes)\n{\n\tstruct stm32_romem_priv *priv = context;\n\tstruct device *dev = priv->cfg.dev;\n\tu32 *buf32 = buf;\n\tint ret, i;\n\n\t \n\tif ((bytes % 4) || (offset % 4))\n\t\treturn -EINVAL;\n\n\tfor (i = offset; i < offset + bytes; i += 4) {\n\t\tret = stm32_bsec_smc(STM32_SMC_PROG_OTP, i >> 2, *buf32++,\n\t\t\t\t     NULL);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Can't write data%d (%d)\\n\", i >> 2, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (offset + bytes >= priv->lower * 4)\n\t\tdev_warn(dev, \"Update of upper OTPs with ECC protection (word programming, only once)\\n\");\n\n\treturn 0;\n}\n\nstatic int stm32_bsec_pta_read(void *context, unsigned int offset, void *buf,\n\t\t\t       size_t bytes)\n{\n\tstruct stm32_romem_priv *priv = context;\n\n\treturn stm32_bsec_optee_ta_read(priv->ctx, offset, buf, bytes);\n}\n\nstatic int stm32_bsec_pta_write(void *context, unsigned int offset, void *buf,\n\t\t\t\tsize_t bytes)\n{\n\tstruct stm32_romem_priv *priv = context;\n\n\treturn stm32_bsec_optee_ta_write(priv->ctx, priv->lower, offset, buf, bytes);\n}\n\nstatic bool stm32_bsec_smc_check(void)\n{\n\tu32 val;\n\tint ret;\n\n\t \n\tret = stm32_bsec_smc(STM32_SMC_READ_SHADOW, 0, 0, &val);\n\n\treturn !ret;\n}\n\nstatic bool optee_presence_check(void)\n{\n\tstruct device_node *np;\n\tbool tee_detected = false;\n\n\t \n\tnp = of_find_compatible_node(NULL, NULL, \"linaro,optee-tz\");\n\tif (np && of_device_is_available(np))\n\t\ttee_detected = true;\n\tof_node_put(np);\n\n\treturn tee_detected;\n}\n\nstatic int stm32_romem_probe(struct platform_device *pdev)\n{\n\tconst struct stm32_romem_cfg *cfg;\n\tstruct device *dev = &pdev->dev;\n\tstruct stm32_romem_priv *priv;\n\tstruct resource *res;\n\tint rc;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->cfg.name = \"stm32-romem\";\n\tpriv->cfg.word_size = 1;\n\tpriv->cfg.stride = 1;\n\tpriv->cfg.dev = dev;\n\tpriv->cfg.priv = priv;\n\tpriv->cfg.owner = THIS_MODULE;\n\tpriv->cfg.type = NVMEM_TYPE_OTP;\n\n\tpriv->lower = 0;\n\n\tcfg = (const struct stm32_romem_cfg *)\n\t\tof_match_device(dev->driver->of_match_table, dev)->data;\n\tif (!cfg) {\n\t\tpriv->cfg.read_only = true;\n\t\tpriv->cfg.size = resource_size(res);\n\t\tpriv->cfg.reg_read = stm32_romem_read;\n\t} else {\n\t\tpriv->cfg.size = cfg->size;\n\t\tpriv->lower = cfg->lower;\n\t\tif (cfg->ta || optee_presence_check()) {\n\t\t\trc = stm32_bsec_optee_ta_open(&priv->ctx);\n\t\t\tif (rc) {\n\t\t\t\t \n\t\t\t\tif (rc == -EPROBE_DEFER)\n\t\t\t\t\treturn -EPROBE_DEFER;\n\t\t\t\t \n\t\t\t\tif (cfg->ta || !stm32_bsec_smc_check())\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\tif (priv->ctx) {\n\t\t\trc = devm_add_action_or_reset(dev, stm32_bsec_optee_ta_close, priv->ctx);\n\t\t\tif (rc) {\n\t\t\t\tdev_err(dev, \"devm_add_action_or_reset() failed (%d)\\n\", rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tpriv->cfg.reg_read = stm32_bsec_pta_read;\n\t\t\tpriv->cfg.reg_write = stm32_bsec_pta_write;\n\t\t} else {\n\t\t\tpriv->cfg.reg_read = stm32_bsec_read;\n\t\t\tpriv->cfg.reg_write = stm32_bsec_write;\n\t\t}\n\t}\n\n\treturn PTR_ERR_OR_ZERO(devm_nvmem_register(dev, &priv->cfg));\n}\n\n \nstatic const struct stm32_romem_cfg stm32mp15_bsec_cfg = {\n\t.size = 384,\n\t.lower = 32,\n\t.ta = false,\n};\n\nstatic const struct stm32_romem_cfg stm32mp13_bsec_cfg = {\n\t.size = 384,\n\t.lower = 32,\n\t.ta = true,\n};\n\nstatic const struct of_device_id stm32_romem_of_match[] __maybe_unused = {\n\t{ .compatible = \"st,stm32f4-otp\", }, {\n\t\t.compatible = \"st,stm32mp15-bsec\",\n\t\t.data = (void *)&stm32mp15_bsec_cfg,\n\t}, {\n\t\t.compatible = \"st,stm32mp13-bsec\",\n\t\t.data = (void *)&stm32mp13_bsec_cfg,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, stm32_romem_of_match);\n\nstatic struct platform_driver stm32_romem_driver = {\n\t.probe = stm32_romem_probe,\n\t.driver = {\n\t\t.name = \"stm32-romem\",\n\t\t.of_match_table = of_match_ptr(stm32_romem_of_match),\n\t},\n};\nmodule_platform_driver(stm32_romem_driver);\n\nMODULE_AUTHOR(\"Fabrice Gasnier <fabrice.gasnier@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 RO-MEM\");\nMODULE_ALIAS(\"platform:nvmem-stm32-romem\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}