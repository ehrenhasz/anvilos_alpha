{
  "module_name": "sprd-efuse.c",
  "hash_id": "e698dad46492d278acfecb2b0748ffc2489a0f6ab98503a76fa61e3e44ea107f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/sprd-efuse.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/hwspinlock.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#define SPRD_EFUSE_ENABLE\t\t0x20\n#define SPRD_EFUSE_ERR_FLAG\t\t0x24\n#define SPRD_EFUSE_ERR_CLR\t\t0x28\n#define SPRD_EFUSE_MAGIC_NUM\t\t0x2c\n#define SPRD_EFUSE_FW_CFG\t\t0x50\n#define SPRD_EFUSE_PW_SWT\t\t0x54\n#define SPRD_EFUSE_MEM(val)\t\t(0x1000 + ((val) << 2))\n\n#define SPRD_EFUSE_VDD_EN\t\tBIT(0)\n#define SPRD_EFUSE_AUTO_CHECK_EN\tBIT(1)\n#define SPRD_EFUSE_DOUBLE_EN\t\tBIT(2)\n#define SPRD_EFUSE_MARGIN_RD_EN\t\tBIT(3)\n#define SPRD_EFUSE_LOCK_WR_EN\t\tBIT(4)\n\n#define SPRD_EFUSE_ERR_CLR_MASK\t\tGENMASK(13, 0)\n\n#define SPRD_EFUSE_ENK1_ON\t\tBIT(0)\n#define SPRD_EFUSE_ENK2_ON\t\tBIT(1)\n#define SPRD_EFUSE_PROG_EN\t\tBIT(2)\n\n#define SPRD_EFUSE_MAGIC_NUMBER\t\t0x8810\n\n \n#define SPRD_EFUSE_BLOCK_WIDTH\t\t4\n\n \n#define SPRD_EFUSE_NORMAL_BLOCK_NUMS\t24\n#define SPRD_EFUSE_NORMAL_BLOCK_OFFSET\t72\n\n \n#define SPRD_EFUSE_HWLOCK_TIMEOUT\t5000\n\n \nstruct sprd_efuse_variant_data {\n\tu32 blk_nums;\n\tu32 blk_offset;\n\tbool blk_double;\n};\n\nstruct sprd_efuse {\n\tstruct device *dev;\n\tstruct clk *clk;\n\tstruct hwspinlock *hwlock;\n\tstruct mutex mutex;\n\tvoid __iomem *base;\n\tconst struct sprd_efuse_variant_data *data;\n};\n\nstatic const struct sprd_efuse_variant_data ums312_data = {\n\t.blk_nums = SPRD_EFUSE_NORMAL_BLOCK_NUMS,\n\t.blk_offset = SPRD_EFUSE_NORMAL_BLOCK_OFFSET,\n\t.blk_double = false,\n};\n\n \nstatic int sprd_efuse_lock(struct sprd_efuse *efuse)\n{\n\tint ret;\n\n\tmutex_lock(&efuse->mutex);\n\n\tret = hwspin_lock_timeout_raw(efuse->hwlock,\n\t\t\t\t      SPRD_EFUSE_HWLOCK_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(efuse->dev, \"timeout get the hwspinlock\\n\");\n\t\tmutex_unlock(&efuse->mutex);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void sprd_efuse_unlock(struct sprd_efuse *efuse)\n{\n\thwspin_unlock_raw(efuse->hwlock);\n\tmutex_unlock(&efuse->mutex);\n}\n\nstatic void sprd_efuse_set_prog_power(struct sprd_efuse *efuse, bool en)\n{\n\tu32 val = readl(efuse->base + SPRD_EFUSE_PW_SWT);\n\n\tif (en)\n\t\tval &= ~SPRD_EFUSE_ENK2_ON;\n\telse\n\t\tval &= ~SPRD_EFUSE_ENK1_ON;\n\n\twritel(val, efuse->base + SPRD_EFUSE_PW_SWT);\n\n\t \n\tusleep_range(1000, 1200);\n\n\tif (en)\n\t\tval |= SPRD_EFUSE_ENK1_ON;\n\telse\n\t\tval |= SPRD_EFUSE_ENK2_ON;\n\n\twritel(val, efuse->base + SPRD_EFUSE_PW_SWT);\n\n\t \n\tusleep_range(1000, 1200);\n}\n\nstatic void sprd_efuse_set_read_power(struct sprd_efuse *efuse, bool en)\n{\n\tu32 val = readl(efuse->base + SPRD_EFUSE_ENABLE);\n\n\tif (en)\n\t\tval |= SPRD_EFUSE_VDD_EN;\n\telse\n\t\tval &= ~SPRD_EFUSE_VDD_EN;\n\n\twritel(val, efuse->base + SPRD_EFUSE_ENABLE);\n\n\t \n\tusleep_range(1000, 1200);\n}\n\nstatic void sprd_efuse_set_prog_lock(struct sprd_efuse *efuse, bool en)\n{\n\tu32 val = readl(efuse->base + SPRD_EFUSE_ENABLE);\n\n\tif (en)\n\t\tval |= SPRD_EFUSE_LOCK_WR_EN;\n\telse\n\t\tval &= ~SPRD_EFUSE_LOCK_WR_EN;\n\n\twritel(val, efuse->base + SPRD_EFUSE_ENABLE);\n}\n\nstatic void sprd_efuse_set_auto_check(struct sprd_efuse *efuse, bool en)\n{\n\tu32 val = readl(efuse->base + SPRD_EFUSE_ENABLE);\n\n\tif (en)\n\t\tval |= SPRD_EFUSE_AUTO_CHECK_EN;\n\telse\n\t\tval &= ~SPRD_EFUSE_AUTO_CHECK_EN;\n\n\twritel(val, efuse->base + SPRD_EFUSE_ENABLE);\n}\n\nstatic void sprd_efuse_set_data_double(struct sprd_efuse *efuse, bool en)\n{\n\tu32 val = readl(efuse->base + SPRD_EFUSE_ENABLE);\n\n\tif (en)\n\t\tval |= SPRD_EFUSE_DOUBLE_EN;\n\telse\n\t\tval &= ~SPRD_EFUSE_DOUBLE_EN;\n\n\twritel(val, efuse->base + SPRD_EFUSE_ENABLE);\n}\n\nstatic void sprd_efuse_set_prog_en(struct sprd_efuse *efuse, bool en)\n{\n\tu32 val = readl(efuse->base + SPRD_EFUSE_PW_SWT);\n\n\tif (en)\n\t\tval |= SPRD_EFUSE_PROG_EN;\n\telse\n\t\tval &= ~SPRD_EFUSE_PROG_EN;\n\n\twritel(val, efuse->base + SPRD_EFUSE_PW_SWT);\n}\n\nstatic int sprd_efuse_raw_prog(struct sprd_efuse *efuse, u32 blk, bool doub,\n\t\t\t       bool lock, u32 *data)\n{\n\tu32 status;\n\tint ret = 0;\n\n\t \n\twritel(SPRD_EFUSE_MAGIC_NUMBER,\n\t       efuse->base + SPRD_EFUSE_MAGIC_NUM);\n\n\t \n\tsprd_efuse_set_prog_power(efuse, true);\n\tsprd_efuse_set_prog_en(efuse, true);\n\tsprd_efuse_set_data_double(efuse, doub);\n\n\t \n\tif (lock)\n\t\tsprd_efuse_set_auto_check(efuse, true);\n\n\twritel(*data, efuse->base + SPRD_EFUSE_MEM(blk));\n\n\t \n\tif (lock)\n\t\tsprd_efuse_set_auto_check(efuse, false);\n\tsprd_efuse_set_data_double(efuse, false);\n\n\t \n\tstatus = readl(efuse->base + SPRD_EFUSE_ERR_FLAG);\n\tif (status) {\n\t\tdev_err(efuse->dev,\n\t\t\t\"write error status %u of block %d\\n\", status, blk);\n\n\t\twritel(SPRD_EFUSE_ERR_CLR_MASK,\n\t\t       efuse->base + SPRD_EFUSE_ERR_CLR);\n\t\tret = -EBUSY;\n\t} else if (lock) {\n\t\tsprd_efuse_set_prog_lock(efuse, lock);\n\t\twritel(0, efuse->base + SPRD_EFUSE_MEM(blk));\n\t\tsprd_efuse_set_prog_lock(efuse, false);\n\t}\n\n\tsprd_efuse_set_prog_power(efuse, false);\n\twritel(0, efuse->base + SPRD_EFUSE_MAGIC_NUM);\n\n\treturn ret;\n}\n\nstatic int sprd_efuse_raw_read(struct sprd_efuse *efuse, int blk, u32 *val,\n\t\t\t       bool doub)\n{\n\tu32 status;\n\n\t \n\tsprd_efuse_set_read_power(efuse, true);\n\n\t \n\tsprd_efuse_set_data_double(efuse, doub);\n\n\t \n\t*val = readl(efuse->base + SPRD_EFUSE_MEM(blk));\n\n\t \n\tsprd_efuse_set_data_double(efuse, false);\n\n\t \n\tsprd_efuse_set_read_power(efuse, false);\n\n\t \n\tstatus = readl(efuse->base + SPRD_EFUSE_ERR_FLAG);\n\tif (status) {\n\t\tdev_err(efuse->dev,\n\t\t\t\"read error status %d of block %d\\n\", status, blk);\n\n\t\twritel(SPRD_EFUSE_ERR_CLR_MASK,\n\t\t       efuse->base + SPRD_EFUSE_ERR_CLR);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int sprd_efuse_read(void *context, u32 offset, void *val, size_t bytes)\n{\n\tstruct sprd_efuse *efuse = context;\n\tbool blk_double = efuse->data->blk_double;\n\tu32 index = offset / SPRD_EFUSE_BLOCK_WIDTH + efuse->data->blk_offset;\n\tu32 blk_offset = (offset % SPRD_EFUSE_BLOCK_WIDTH) * BITS_PER_BYTE;\n\tu32 data;\n\tint ret;\n\n\tret = sprd_efuse_lock(efuse);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(efuse->clk);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = sprd_efuse_raw_read(efuse, index, &data, blk_double);\n\tif (!ret) {\n\t\tdata >>= blk_offset;\n\t\tmemcpy(val, &data, bytes);\n\t}\n\n\tclk_disable_unprepare(efuse->clk);\n\nunlock:\n\tsprd_efuse_unlock(efuse);\n\treturn ret;\n}\n\nstatic int sprd_efuse_write(void *context, u32 offset, void *val, size_t bytes)\n{\n\tstruct sprd_efuse *efuse = context;\n\tbool blk_double = efuse->data->blk_double;\n\tbool lock;\n\tint ret;\n\n\tret = sprd_efuse_lock(efuse);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(efuse->clk);\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tif (bytes < SPRD_EFUSE_BLOCK_WIDTH)\n\t\tlock = false;\n\telse\n\t\tlock = true;\n\n\tret = sprd_efuse_raw_prog(efuse, offset, blk_double, lock, val);\n\n\tclk_disable_unprepare(efuse->clk);\n\nunlock:\n\tsprd_efuse_unlock(efuse);\n\treturn ret;\n}\n\nstatic int sprd_efuse_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct nvmem_device *nvmem;\n\tstruct nvmem_config econfig = { };\n\tstruct sprd_efuse *efuse;\n\tconst struct sprd_efuse_variant_data *pdata;\n\tint ret;\n\n\tpdata = of_device_get_match_data(&pdev->dev);\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"No matching driver data found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tefuse = devm_kzalloc(&pdev->dev, sizeof(*efuse), GFP_KERNEL);\n\tif (!efuse)\n\t\treturn -ENOMEM;\n\n\tefuse->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(efuse->base))\n\t\treturn PTR_ERR(efuse->base);\n\n\tret = of_hwspin_lock_get_id(np, 0);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get hwlock id\\n\");\n\t\treturn ret;\n\t}\n\n\tefuse->hwlock = devm_hwspin_lock_request_specific(&pdev->dev, ret);\n\tif (!efuse->hwlock) {\n\t\tdev_err(&pdev->dev, \"failed to request hwlock\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tefuse->clk = devm_clk_get(&pdev->dev, \"enable\");\n\tif (IS_ERR(efuse->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get enable clock\\n\");\n\t\treturn PTR_ERR(efuse->clk);\n\t}\n\n\tmutex_init(&efuse->mutex);\n\tefuse->dev = &pdev->dev;\n\tefuse->data = pdata;\n\n\teconfig.stride = 1;\n\teconfig.word_size = 1;\n\teconfig.read_only = false;\n\teconfig.name = \"sprd-efuse\";\n\teconfig.size = efuse->data->blk_nums * SPRD_EFUSE_BLOCK_WIDTH;\n\teconfig.reg_read = sprd_efuse_read;\n\teconfig.reg_write = sprd_efuse_write;\n\teconfig.priv = efuse;\n\teconfig.dev = &pdev->dev;\n\tnvmem = devm_nvmem_register(&pdev->dev, &econfig);\n\tif (IS_ERR(nvmem)) {\n\t\tdev_err(&pdev->dev, \"failed to register nvmem\\n\");\n\t\treturn PTR_ERR(nvmem);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sprd_efuse_of_match[] = {\n\t{ .compatible = \"sprd,ums312-efuse\", .data = &ums312_data },\n\t{ }\n};\n\nstatic struct platform_driver sprd_efuse_driver = {\n\t.probe = sprd_efuse_probe,\n\t.driver = {\n\t\t.name = \"sprd-efuse\",\n\t\t.of_match_table = sprd_efuse_of_match,\n\t},\n};\n\nmodule_platform_driver(sprd_efuse_driver);\n\nMODULE_AUTHOR(\"Freeman Liu <freeman.liu@spreadtrum.com>\");\nMODULE_DESCRIPTION(\"Spreadtrum AP efuse driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}