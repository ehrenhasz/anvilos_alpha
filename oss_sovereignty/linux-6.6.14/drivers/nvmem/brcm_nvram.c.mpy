{
  "module_name": "brcm_nvram.c",
  "hash_id": "807741552023a210e59f3dc14e1485544a4fbdc6e070159eae875ce82fda6fdd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/brcm_nvram.c",
  "human_readable_source": "\n \n\n#include <linux/bcm47xx_nvram.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define NVRAM_MAGIC\t\t\t\"FLSH\"\n\n \nstruct brcm_nvram {\n\tstruct device *dev;\n\tsize_t nvmem_size;\n\tuint8_t *data;\n\tsize_t data_len;\n\tuint8_t padding_byte;\n\tstruct nvmem_cell_info *cells;\n\tint ncells;\n};\n\nstruct brcm_nvram_header {\n\tchar magic[4];\n\t__le32 len;\n\t__le32 crc_ver_init;\t \n\t__le32 config_refresh;\t \n\t__le32 config_ncdl;\t \n};\n\nstatic int brcm_nvram_read(void *context, unsigned int offset, void *val,\n\t\t\t   size_t bytes)\n{\n\tstruct brcm_nvram *priv = context;\n\tsize_t to_copy;\n\n\tif (offset + bytes > priv->data_len)\n\t\tto_copy = max_t(ssize_t, (ssize_t)priv->data_len - offset, 0);\n\telse\n\t\tto_copy = bytes;\n\n\tmemcpy(val, priv->data + offset, to_copy);\n\n\tmemset((uint8_t *)val + to_copy, priv->padding_byte, bytes - to_copy);\n\n\treturn 0;\n}\n\nstatic int brcm_nvram_copy_data(struct brcm_nvram *priv, struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tvoid __iomem *base;\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->nvmem_size = resource_size(res);\n\n\tpriv->padding_byte = readb(base + priv->nvmem_size - 1);\n\tfor (priv->data_len = priv->nvmem_size;\n\t     priv->data_len;\n\t     priv->data_len--) {\n\t\tif (readb(base + priv->data_len - 1) != priv->padding_byte)\n\t\t\tbreak;\n\t}\n\tWARN(priv->data_len > SZ_128K, \"Unexpected (big) NVRAM size: %zu B\\n\", priv->data_len);\n\n\tpriv->data = devm_kzalloc(priv->dev, priv->data_len, GFP_KERNEL);\n\tif (!priv->data)\n\t\treturn -ENOMEM;\n\n\tmemcpy_fromio(priv->data, base, priv->data_len);\n\n\tbcm47xx_nvram_init_from_iomem(base, priv->data_len);\n\n\treturn 0;\n}\n\nstatic int brcm_nvram_read_post_process_macaddr(void *context, const char *id, int index,\n\t\t\t\t\t\tunsigned int offset, void *buf, size_t bytes)\n{\n\tu8 mac[ETH_ALEN];\n\n\tif (bytes != 3 * ETH_ALEN - 1)\n\t\treturn -EINVAL;\n\n\tif (!mac_pton(buf, mac))\n\t\treturn -EINVAL;\n\n\tif (index)\n\t\teth_addr_add(mac, index);\n\n\tether_addr_copy(buf, mac);\n\n\treturn 0;\n}\n\nstatic int brcm_nvram_add_cells(struct brcm_nvram *priv, uint8_t *data,\n\t\t\t\tsize_t len)\n{\n\tstruct device *dev = priv->dev;\n\tchar *var, *value;\n\tuint8_t tmp;\n\tint idx;\n\tint err = 0;\n\n\ttmp = priv->data[len - 1];\n\tpriv->data[len - 1] = '\\0';\n\n\tpriv->ncells = 0;\n\tfor (var = data + sizeof(struct brcm_nvram_header);\n\t     var < (char *)data + len && *var;\n\t     var += strlen(var) + 1) {\n\t\tpriv->ncells++;\n\t}\n\n\tpriv->cells = devm_kcalloc(dev, priv->ncells, sizeof(*priv->cells), GFP_KERNEL);\n\tif (!priv->cells) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (var = data + sizeof(struct brcm_nvram_header), idx = 0;\n\t     var < (char *)data + len && *var;\n\t     var = value + strlen(value) + 1, idx++) {\n\t\tchar *eq, *name;\n\n\t\teq = strchr(var, '=');\n\t\tif (!eq)\n\t\t\tbreak;\n\t\t*eq = '\\0';\n\t\tname = devm_kstrdup(dev, var, GFP_KERNEL);\n\t\t*eq = '=';\n\t\tif (!name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tvalue = eq + 1;\n\n\t\tpriv->cells[idx].name = name;\n\t\tpriv->cells[idx].offset = value - (char *)data;\n\t\tpriv->cells[idx].bytes = strlen(value);\n\t\tpriv->cells[idx].np = of_get_child_by_name(dev->of_node, priv->cells[idx].name);\n\t\tif (!strcmp(name, \"et0macaddr\") ||\n\t\t    !strcmp(name, \"et1macaddr\") ||\n\t\t    !strcmp(name, \"et2macaddr\")) {\n\t\t\tpriv->cells[idx].raw_len = strlen(value);\n\t\t\tpriv->cells[idx].bytes = ETH_ALEN;\n\t\t\tpriv->cells[idx].read_post_process = brcm_nvram_read_post_process_macaddr;\n\t\t}\n\t}\n\nout:\n\tpriv->data[len - 1] = tmp;\n\treturn err;\n}\n\nstatic int brcm_nvram_parse(struct brcm_nvram *priv)\n{\n\tstruct brcm_nvram_header *header = (struct brcm_nvram_header *)priv->data;\n\tstruct device *dev = priv->dev;\n\tsize_t len;\n\tint err;\n\n\tif (memcmp(header->magic, NVRAM_MAGIC, 4)) {\n\t\tdev_err(dev, \"Invalid NVRAM magic\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlen = le32_to_cpu(header->len);\n\tif (len > priv->nvmem_size) {\n\t\tdev_err(dev, \"NVRAM length (%zd) exceeds mapped size (%zd)\\n\", len,\n\t\t\tpriv->nvmem_size);\n\t\treturn -EINVAL;\n\t}\n\n\terr = brcm_nvram_add_cells(priv, priv->data, len);\n\tif (err)\n\t\tdev_err(dev, \"Failed to add cells: %d\\n\", err);\n\n\treturn 0;\n}\n\nstatic int brcm_nvram_probe(struct platform_device *pdev)\n{\n\tstruct nvmem_config config = {\n\t\t.name = \"brcm-nvram\",\n\t\t.reg_read = brcm_nvram_read,\n\t};\n\tstruct device *dev = &pdev->dev;\n\tstruct brcm_nvram *priv;\n\tint err;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->dev = dev;\n\n\terr = brcm_nvram_copy_data(priv, pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = brcm_nvram_parse(priv);\n\tif (err)\n\t\treturn err;\n\n\tconfig.dev = dev;\n\tconfig.cells = priv->cells;\n\tconfig.ncells = priv->ncells;\n\tconfig.priv = priv;\n\tconfig.size = priv->nvmem_size;\n\n\treturn PTR_ERR_OR_ZERO(devm_nvmem_register(dev, &config));\n}\n\nstatic const struct of_device_id brcm_nvram_of_match_table[] = {\n\t{ .compatible = \"brcm,nvram\", },\n\t{},\n};\n\nstatic struct platform_driver brcm_nvram_driver = {\n\t.probe = brcm_nvram_probe,\n\t.driver = {\n\t\t.name = \"brcm_nvram\",\n\t\t.of_match_table = brcm_nvram_of_match_table,\n\t},\n};\n\nstatic int __init brcm_nvram_init(void)\n{\n\treturn platform_driver_register(&brcm_nvram_driver);\n}\n\nsubsys_initcall_sync(brcm_nvram_init);\n\nMODULE_AUTHOR(\"Rafa\u0142 Mi\u0142ecki\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(of, brcm_nvram_of_match_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}