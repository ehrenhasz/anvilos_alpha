{
  "module_name": "rockchip-efuse.c",
  "hash_id": "558ff855f6b2ea37f466b6a7a6a81d807380cd8361c1c9ebabf536d006f40cb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/rockchip-efuse.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#define RK3288_A_SHIFT\t\t6\n#define RK3288_A_MASK\t\t0x3ff\n#define RK3288_PGENB\t\tBIT(3)\n#define RK3288_LOAD\t\tBIT(2)\n#define RK3288_STROBE\t\tBIT(1)\n#define RK3288_CSB\t\tBIT(0)\n\n#define RK3328_SECURE_SIZES\t96\n#define RK3328_INT_STATUS\t0x0018\n#define RK3328_DOUT\t\t0x0020\n#define RK3328_AUTO_CTRL\t0x0024\n#define RK3328_INT_FINISH\tBIT(0)\n#define RK3328_AUTO_ENB\t\tBIT(0)\n#define RK3328_AUTO_RD\t\tBIT(1)\n\n#define RK3399_A_SHIFT\t\t16\n#define RK3399_A_MASK\t\t0x3ff\n#define RK3399_NBYTES\t\t4\n#define RK3399_STROBSFTSEL\tBIT(9)\n#define RK3399_RSB\t\tBIT(7)\n#define RK3399_PD\t\tBIT(5)\n#define RK3399_PGENB\t\tBIT(3)\n#define RK3399_LOAD\t\tBIT(2)\n#define RK3399_STROBE\t\tBIT(1)\n#define RK3399_CSB\t\tBIT(0)\n\n#define REG_EFUSE_CTRL\t\t0x0000\n#define REG_EFUSE_DOUT\t\t0x0004\n\nstruct rockchip_efuse_chip {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\nstatic int rockchip_rk3288_efuse_read(void *context, unsigned int offset,\n\t\t\t\t      void *val, size_t bytes)\n{\n\tstruct rockchip_efuse_chip *efuse = context;\n\tu8 *buf = val;\n\tint ret;\n\n\tret = clk_prepare_enable(efuse->clk);\n\tif (ret < 0) {\n\t\tdev_err(efuse->dev, \"failed to prepare/enable efuse clk\\n\");\n\t\treturn ret;\n\t}\n\n\twritel(RK3288_LOAD | RK3288_PGENB, efuse->base + REG_EFUSE_CTRL);\n\tudelay(1);\n\twhile (bytes--) {\n\t\twritel(readl(efuse->base + REG_EFUSE_CTRL) &\n\t\t\t     (~(RK3288_A_MASK << RK3288_A_SHIFT)),\n\t\t\t     efuse->base + REG_EFUSE_CTRL);\n\t\twritel(readl(efuse->base + REG_EFUSE_CTRL) |\n\t\t\t     ((offset++ & RK3288_A_MASK) << RK3288_A_SHIFT),\n\t\t\t     efuse->base + REG_EFUSE_CTRL);\n\t\tudelay(1);\n\t\twritel(readl(efuse->base + REG_EFUSE_CTRL) |\n\t\t\t     RK3288_STROBE, efuse->base + REG_EFUSE_CTRL);\n\t\tudelay(1);\n\t\t*buf++ = readb(efuse->base + REG_EFUSE_DOUT);\n\t\twritel(readl(efuse->base + REG_EFUSE_CTRL) &\n\t\t       (~RK3288_STROBE), efuse->base + REG_EFUSE_CTRL);\n\t\tudelay(1);\n\t}\n\n\t \n\twritel(RK3288_PGENB | RK3288_CSB, efuse->base + REG_EFUSE_CTRL);\n\n\tclk_disable_unprepare(efuse->clk);\n\n\treturn 0;\n}\n\nstatic int rockchip_rk3328_efuse_read(void *context, unsigned int offset,\n\t\t\t\t      void *val, size_t bytes)\n{\n\tstruct rockchip_efuse_chip *efuse = context;\n\tunsigned int addr_start, addr_end, addr_offset, addr_len;\n\tu32 out_value, status;\n\tu8 *buf;\n\tint ret, i = 0;\n\n\tret = clk_prepare_enable(efuse->clk);\n\tif (ret < 0) {\n\t\tdev_err(efuse->dev, \"failed to prepare/enable efuse clk\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\toffset += RK3328_SECURE_SIZES;\n\taddr_start = rounddown(offset, RK3399_NBYTES) / RK3399_NBYTES;\n\taddr_end = roundup(offset + bytes, RK3399_NBYTES) / RK3399_NBYTES;\n\taddr_offset = offset % RK3399_NBYTES;\n\taddr_len = addr_end - addr_start;\n\n\tbuf = kzalloc(array3_size(addr_len, RK3399_NBYTES, sizeof(*buf)),\n\t\t      GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto nomem;\n\t}\n\n\twhile (addr_len--) {\n\t\twritel(RK3328_AUTO_RD | RK3328_AUTO_ENB |\n\t\t       ((addr_start++ & RK3399_A_MASK) << RK3399_A_SHIFT),\n\t\t       efuse->base + RK3328_AUTO_CTRL);\n\t\tudelay(4);\n\t\tstatus = readl(efuse->base + RK3328_INT_STATUS);\n\t\tif (!(status & RK3328_INT_FINISH)) {\n\t\t\tret = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tout_value = readl(efuse->base + RK3328_DOUT);\n\t\twritel(RK3328_INT_FINISH, efuse->base + RK3328_INT_STATUS);\n\n\t\tmemcpy(&buf[i], &out_value, RK3399_NBYTES);\n\t\ti += RK3399_NBYTES;\n\t}\n\n\tmemcpy(val, buf + addr_offset, bytes);\nerr:\n\tkfree(buf);\nnomem:\n\tclk_disable_unprepare(efuse->clk);\n\n\treturn ret;\n}\n\nstatic int rockchip_rk3399_efuse_read(void *context, unsigned int offset,\n\t\t\t\t      void *val, size_t bytes)\n{\n\tstruct rockchip_efuse_chip *efuse = context;\n\tunsigned int addr_start, addr_end, addr_offset, addr_len;\n\tu32 out_value;\n\tu8 *buf;\n\tint ret, i = 0;\n\n\tret = clk_prepare_enable(efuse->clk);\n\tif (ret < 0) {\n\t\tdev_err(efuse->dev, \"failed to prepare/enable efuse clk\\n\");\n\t\treturn ret;\n\t}\n\n\taddr_start = rounddown(offset, RK3399_NBYTES) / RK3399_NBYTES;\n\taddr_end = roundup(offset + bytes, RK3399_NBYTES) / RK3399_NBYTES;\n\taddr_offset = offset % RK3399_NBYTES;\n\taddr_len = addr_end - addr_start;\n\n\tbuf = kzalloc(array3_size(addr_len, RK3399_NBYTES, sizeof(*buf)),\n\t\t      GFP_KERNEL);\n\tif (!buf) {\n\t\tclk_disable_unprepare(efuse->clk);\n\t\treturn -ENOMEM;\n\t}\n\n\twritel(RK3399_LOAD | RK3399_PGENB | RK3399_STROBSFTSEL | RK3399_RSB,\n\t       efuse->base + REG_EFUSE_CTRL);\n\tudelay(1);\n\twhile (addr_len--) {\n\t\twritel(readl(efuse->base + REG_EFUSE_CTRL) | RK3399_STROBE |\n\t\t       ((addr_start++ & RK3399_A_MASK) << RK3399_A_SHIFT),\n\t\t       efuse->base + REG_EFUSE_CTRL);\n\t\tudelay(1);\n\t\tout_value = readl(efuse->base + REG_EFUSE_DOUT);\n\t\twritel(readl(efuse->base + REG_EFUSE_CTRL) & (~RK3399_STROBE),\n\t\t       efuse->base + REG_EFUSE_CTRL);\n\t\tudelay(1);\n\n\t\tmemcpy(&buf[i], &out_value, RK3399_NBYTES);\n\t\ti += RK3399_NBYTES;\n\t}\n\n\t \n\twritel(RK3399_PD | RK3399_CSB, efuse->base + REG_EFUSE_CTRL);\n\n\tmemcpy(val, buf + addr_offset, bytes);\n\n\tkfree(buf);\n\n\tclk_disable_unprepare(efuse->clk);\n\n\treturn 0;\n}\n\nstatic struct nvmem_config econfig = {\n\t.name = \"rockchip-efuse\",\n\t.stride = 1,\n\t.word_size = 1,\n\t.read_only = true,\n};\n\nstatic const struct of_device_id rockchip_efuse_match[] = {\n\t \n\t{\n\t\t.compatible = \"rockchip,rockchip-efuse\",\n\t\t.data = (void *)&rockchip_rk3288_efuse_read,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3066a-efuse\",\n\t\t.data = (void *)&rockchip_rk3288_efuse_read,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3188-efuse\",\n\t\t.data = (void *)&rockchip_rk3288_efuse_read,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3228-efuse\",\n\t\t.data = (void *)&rockchip_rk3288_efuse_read,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3288-efuse\",\n\t\t.data = (void *)&rockchip_rk3288_efuse_read,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3368-efuse\",\n\t\t.data = (void *)&rockchip_rk3288_efuse_read,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3328-efuse\",\n\t\t.data = (void *)&rockchip_rk3328_efuse_read,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3399-efuse\",\n\t\t.data = (void *)&rockchip_rk3399_efuse_read,\n\t},\n\t{  },\n};\nMODULE_DEVICE_TABLE(of, rockchip_efuse_match);\n\nstatic int rockchip_efuse_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct nvmem_device *nvmem;\n\tstruct rockchip_efuse_chip *efuse;\n\tconst void *data;\n\tstruct device *dev = &pdev->dev;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data) {\n\t\tdev_err(dev, \"failed to get match data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tefuse = devm_kzalloc(dev, sizeof(struct rockchip_efuse_chip),\n\t\t\t     GFP_KERNEL);\n\tif (!efuse)\n\t\treturn -ENOMEM;\n\n\tefuse->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(efuse->base))\n\t\treturn PTR_ERR(efuse->base);\n\n\tefuse->clk = devm_clk_get(dev, \"pclk_efuse\");\n\tif (IS_ERR(efuse->clk))\n\t\treturn PTR_ERR(efuse->clk);\n\n\tefuse->dev = dev;\n\tif (of_property_read_u32(dev->of_node, \"rockchip,efuse-size\",\n\t\t\t\t &econfig.size))\n\t\teconfig.size = resource_size(res);\n\teconfig.reg_read = data;\n\teconfig.priv = efuse;\n\teconfig.dev = efuse->dev;\n\tnvmem = devm_nvmem_register(dev, &econfig);\n\n\treturn PTR_ERR_OR_ZERO(nvmem);\n}\n\nstatic struct platform_driver rockchip_efuse_driver = {\n\t.probe = rockchip_efuse_probe,\n\t.driver = {\n\t\t.name = \"rockchip-efuse\",\n\t\t.of_match_table = rockchip_efuse_match,\n\t},\n};\n\nmodule_platform_driver(rockchip_efuse_driver);\nMODULE_DESCRIPTION(\"rockchip_efuse driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}