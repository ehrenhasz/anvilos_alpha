{
  "module_name": "stm32-bsec-optee-ta.c",
  "hash_id": "e4c2c38021df3b07beb5273fdff43466fd325042df39bca0edca09bdd670e47f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/stm32-bsec-optee-ta.c",
  "human_readable_source": "\n \n\n#include <linux/tee_drv.h>\n\n#include \"stm32-bsec-optee-ta.h\"\n\n \n#define PTA_BSEC_READ_MEM\t\t0x0\n\n \n#define PTA_BSEC_WRITE_MEM\t\t0x1\n\n \n#define SHADOW_ACCESS\t0\n#define FUSE_ACCESS\t1\n#define LOCK_ACCESS\t2\n\n \n#define LOCK_PERM\t\t\tBIT(30)\n\n \nstatic const uuid_t stm32mp_bsec_ta_uuid =\n\tUUID_INIT(0x94cf71ad, 0x80e6, 0x40b5,\n\t\t  0xa7, 0xc6, 0x3d, 0xc5, 0x01, 0xeb, 0x28, 0x03);\n\n \nstatic int stm32_bsec_optee_ta_match(struct tee_ioctl_version_data *ver,\n\t\t\t\t     const void *data)\n{\n\t \n\tif ((ver->impl_id == TEE_IMPL_ID_OPTEE) &&\n\t\t(ver->gen_caps & TEE_GEN_CAP_GP))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic int stm32_bsec_ta_open_session(struct tee_context *ctx, u32 *id)\n{\n\tstruct tee_ioctl_open_session_arg sess_arg;\n\tint rc;\n\n\tmemset(&sess_arg, 0, sizeof(sess_arg));\n\texport_uuid(sess_arg.uuid, &stm32mp_bsec_ta_uuid);\n\tsess_arg.clnt_login = TEE_IOCTL_LOGIN_REE_KERNEL;\n\tsess_arg.num_params = 0;\n\n\trc = tee_client_open_session(ctx, &sess_arg, NULL);\n\tif ((rc < 0) || (sess_arg.ret != 0)) {\n\t\tpr_err(\"%s: tee_client_open_session failed err:%#x, ret:%#x\\n\",\n\t\t       __func__, sess_arg.ret, rc);\n\t\tif (!rc)\n\t\t\trc = -EINVAL;\n\t} else {\n\t\t*id = sess_arg.session;\n\t}\n\n\treturn rc;\n}\n\n \nstatic void stm32_bsec_ta_close_session(void *ctx, u32 id)\n{\n\ttee_client_close_session(ctx, id);\n}\n\n \nint stm32_bsec_optee_ta_open(struct tee_context **ctx)\n{\n\tstruct tee_context *tee_ctx;\n\tu32 session_id;\n\tint rc;\n\n\t \n\ttee_ctx = tee_client_open_context(NULL, stm32_bsec_optee_ta_match, NULL, NULL);\n\tif (IS_ERR(tee_ctx)) {\n\t\trc = PTR_ERR(tee_ctx);\n\t\tif (rc == -ENOENT)\n\t\t\treturn -EPROBE_DEFER;\n\t\tpr_err(\"%s: tee_client_open_context failed (%d)\\n\", __func__, rc);\n\n\t\treturn rc;\n\t}\n\n\t \n\trc = stm32_bsec_ta_open_session(tee_ctx, &session_id);\n\tif (rc) {\n\t\ttee_client_close_context(tee_ctx);\n\t\treturn rc;\n\t}\n\n\tstm32_bsec_ta_close_session(tee_ctx, session_id);\n\n\t*ctx = tee_ctx;\n\n\treturn 0;\n}\n\n \nvoid stm32_bsec_optee_ta_close(void *ctx)\n{\n\ttee_client_close_context(ctx);\n}\n\n \nint stm32_bsec_optee_ta_read(struct tee_context *ctx, unsigned int offset,\n\t\t\t     void *buf, size_t bytes)\n{\n\tstruct tee_shm *shm;\n\tstruct tee_ioctl_invoke_arg arg;\n\tstruct tee_param param[2];\n\tu8 *shm_buf;\n\tu32 start, num_bytes;\n\tint ret;\n\tu32 session_id;\n\n\tret = stm32_bsec_ta_open_session(ctx, &session_id);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&arg, 0, sizeof(arg));\n\tmemset(&param, 0, sizeof(param));\n\n\targ.func = PTA_BSEC_READ_MEM;\n\targ.session = session_id;\n\targ.num_params = 2;\n\n\t \n\tstart = ALIGN_DOWN(offset, 4);\n\tnum_bytes = round_up(offset + bytes - start, 4);\n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;\n\tparam[0].u.value.a = start;\n\tparam[0].u.value.b = SHADOW_ACCESS;\n\n\tshm = tee_shm_alloc_kernel_buf(ctx, num_bytes);\n\tif (IS_ERR(shm)) {\n\t\tret = PTR_ERR(shm);\n\t\tgoto out_tee_session;\n\t}\n\n\tparam[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;\n\tparam[1].u.memref.shm = shm;\n\tparam[1].u.memref.size = num_bytes;\n\n\tret = tee_client_invoke_func(ctx, &arg, param);\n\tif (ret < 0 || arg.ret != 0) {\n\t\tpr_err(\"TA_BSEC invoke failed TEE err:%#x, ret:%#x\\n\",\n\t\t\targ.ret, ret);\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t}\n\tif (!ret) {\n\t\tshm_buf = tee_shm_get_va(shm, 0);\n\t\tif (IS_ERR(shm_buf)) {\n\t\t\tret = PTR_ERR(shm_buf);\n\t\t\tpr_err(\"tee_shm_get_va failed for transmit (%d)\\n\", ret);\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(buf, &shm_buf[offset % 4], bytes);\n\t\t}\n\t}\n\n\ttee_shm_free(shm);\n\nout_tee_session:\n\tstm32_bsec_ta_close_session(ctx, session_id);\n\n\treturn ret;\n}\n\n \nint stm32_bsec_optee_ta_write(struct tee_context *ctx, unsigned int lower,\n\t\t\t      unsigned int offset, void *buf, size_t bytes)\n{\tstruct tee_shm *shm;\n\tstruct tee_ioctl_invoke_arg arg;\n\tstruct tee_param param[2];\n\tu8 *shm_buf;\n\tint ret;\n\tu32 session_id;\n\n\tret = stm32_bsec_ta_open_session(ctx, &session_id);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif ((bytes % 4) || (offset % 4))\n\t\treturn -EINVAL;\n\n\tmemset(&arg, 0, sizeof(arg));\n\tmemset(&param, 0, sizeof(param));\n\n\targ.func = PTA_BSEC_WRITE_MEM;\n\targ.session = session_id;\n\targ.num_params = 2;\n\n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;\n\tparam[0].u.value.a = offset;\n\tparam[0].u.value.b = FUSE_ACCESS;\n\n\tshm = tee_shm_alloc_kernel_buf(ctx, bytes);\n\tif (IS_ERR(shm)) {\n\t\tret = PTR_ERR(shm);\n\t\tgoto out_tee_session;\n\t}\n\n\tparam[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;\n\tparam[1].u.memref.shm = shm;\n\tparam[1].u.memref.size = bytes;\n\n\tshm_buf = tee_shm_get_va(shm, 0);\n\tif (IS_ERR(shm_buf)) {\n\t\tret = PTR_ERR(shm_buf);\n\t\tpr_err(\"tee_shm_get_va failed for transmit (%d)\\n\", ret);\n\t\ttee_shm_free(shm);\n\n\t\tgoto out_tee_session;\n\t}\n\n\tmemcpy(shm_buf, buf, bytes);\n\n\tret = tee_client_invoke_func(ctx, &arg, param);\n\tif (ret < 0 || arg.ret != 0) {\n\t\tpr_err(\"TA_BSEC invoke failed TEE err:%#x, ret:%#x\\n\", arg.ret, ret);\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t}\n\tpr_debug(\"Write OTPs %d to %zu, ret=%d\\n\", offset / 4, (offset + bytes) / 4, ret);\n\n\t \n\tif (!ret && ((offset + bytes) >= (lower * 4))) {\n\t\tu32 start, nb_lock;\n\t\tu32 *lock = (u32 *)shm_buf;\n\t\tint i;\n\n\t\t \n\t\tstart = max_t(u32, offset, lower * 4);\n\t\tnb_lock = (offset + bytes - start) / 4;\n\n\t\tparam[0].u.value.a = start;\n\t\tparam[0].u.value.b = LOCK_ACCESS;\n\t\tparam[1].u.memref.size = nb_lock * 4;\n\n\t\tfor (i = 0; i < nb_lock; i++)\n\t\t\tlock[i] = LOCK_PERM;\n\n\t\tret = tee_client_invoke_func(ctx, &arg, param);\n\t\tif (ret < 0 || arg.ret != 0) {\n\t\t\tpr_err(\"TA_BSEC invoke failed TEE err:%#x, ret:%#x\\n\", arg.ret, ret);\n\t\t\tif (!ret)\n\t\t\t\tret = -EIO;\n\t\t}\n\t\tpr_debug(\"Lock upper OTPs %d to %d, ret=%d\\n\",\n\t\t\t start / 4, start / 4 + nb_lock, ret);\n\t}\n\n\ttee_shm_free(shm);\n\nout_tee_session:\n\tstm32_bsec_ta_close_session(ctx, session_id);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}