{
  "module_name": "u-boot-env.c",
  "hash_id": "0242ab283478f5e68a142eb0c224533a97c992c25d1aa1494565cb12593afeb2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/u-boot-env.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\nenum u_boot_env_format {\n\tU_BOOT_FORMAT_SINGLE,\n\tU_BOOT_FORMAT_REDUNDANT,\n\tU_BOOT_FORMAT_BROADCOM,\n};\n\nstruct u_boot_env {\n\tstruct device *dev;\n\tenum u_boot_env_format format;\n\n\tstruct mtd_info *mtd;\n\n\t \n\tstruct nvmem_cell_info *cells;\n\tint ncells;\n};\n\nstruct u_boot_env_image_single {\n\t__le32 crc32;\n\tuint8_t data[];\n} __packed;\n\nstruct u_boot_env_image_redundant {\n\t__le32 crc32;\n\tu8 mark;\n\tuint8_t data[];\n} __packed;\n\nstruct u_boot_env_image_broadcom {\n\t__le32 magic;\n\t__le32 len;\n\t__le32 crc32;\n\tDECLARE_FLEX_ARRAY(uint8_t, data);\n} __packed;\n\nstatic int u_boot_env_read(void *context, unsigned int offset, void *val,\n\t\t\t   size_t bytes)\n{\n\tstruct u_boot_env *priv = context;\n\tstruct device *dev = priv->dev;\n\tsize_t bytes_read;\n\tint err;\n\n\terr = mtd_read(priv->mtd, offset, bytes, &bytes_read, val);\n\tif (err && !mtd_is_bitflip(err)) {\n\t\tdev_err(dev, \"Failed to read from mtd: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (bytes_read != bytes) {\n\t\tdev_err(dev, \"Failed to read %zu bytes\\n\", bytes);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int u_boot_env_read_post_process_ethaddr(void *context, const char *id, int index,\n\t\t\t\t\t\tunsigned int offset, void *buf, size_t bytes)\n{\n\tu8 mac[ETH_ALEN];\n\n\tif (bytes != 3 * ETH_ALEN - 1)\n\t\treturn -EINVAL;\n\n\tif (!mac_pton(buf, mac))\n\t\treturn -EINVAL;\n\n\tif (index)\n\t\teth_addr_add(mac, index);\n\n\tether_addr_copy(buf, mac);\n\n\treturn 0;\n}\n\nstatic int u_boot_env_add_cells(struct u_boot_env *priv, uint8_t *buf,\n\t\t\t\tsize_t data_offset, size_t data_len)\n{\n\tstruct device *dev = priv->dev;\n\tchar *data = buf + data_offset;\n\tchar *var, *value, *eq;\n\tint idx;\n\n\tpriv->ncells = 0;\n\tfor (var = data; var < data + data_len && *var; var += strlen(var) + 1)\n\t\tpriv->ncells++;\n\n\tpriv->cells = devm_kcalloc(dev, priv->ncells, sizeof(*priv->cells), GFP_KERNEL);\n\tif (!priv->cells)\n\t\treturn -ENOMEM;\n\n\tfor (var = data, idx = 0;\n\t     var < data + data_len && *var;\n\t     var = value + strlen(value) + 1, idx++) {\n\t\teq = strchr(var, '=');\n\t\tif (!eq)\n\t\t\tbreak;\n\t\t*eq = '\\0';\n\t\tvalue = eq + 1;\n\n\t\tpriv->cells[idx].name = devm_kstrdup(dev, var, GFP_KERNEL);\n\t\tif (!priv->cells[idx].name)\n\t\t\treturn -ENOMEM;\n\t\tpriv->cells[idx].offset = data_offset + value - data;\n\t\tpriv->cells[idx].bytes = strlen(value);\n\t\tpriv->cells[idx].np = of_get_child_by_name(dev->of_node, priv->cells[idx].name);\n\t\tif (!strcmp(var, \"ethaddr\")) {\n\t\t\tpriv->cells[idx].raw_len = strlen(value);\n\t\t\tpriv->cells[idx].bytes = ETH_ALEN;\n\t\t\tpriv->cells[idx].read_post_process = u_boot_env_read_post_process_ethaddr;\n\t\t}\n\t}\n\n\tif (WARN_ON(idx != priv->ncells))\n\t\tpriv->ncells = idx;\n\n\treturn 0;\n}\n\nstatic int u_boot_env_parse(struct u_boot_env *priv)\n{\n\tstruct device *dev = priv->dev;\n\tsize_t crc32_data_offset;\n\tsize_t crc32_data_len;\n\tsize_t crc32_offset;\n\tsize_t data_offset;\n\tsize_t data_len;\n\tuint32_t crc32;\n\tuint32_t calc;\n\tsize_t bytes;\n\tuint8_t *buf;\n\tint err;\n\n\tbuf = kcalloc(1, priv->mtd->size, GFP_KERNEL);\n\tif (!buf) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\terr = mtd_read(priv->mtd, 0, priv->mtd->size, &bytes, buf);\n\tif ((err && !mtd_is_bitflip(err)) || bytes != priv->mtd->size) {\n\t\tdev_err(dev, \"Failed to read from mtd: %d\\n\", err);\n\t\tgoto err_kfree;\n\t}\n\n\tswitch (priv->format) {\n\tcase U_BOOT_FORMAT_SINGLE:\n\t\tcrc32_offset = offsetof(struct u_boot_env_image_single, crc32);\n\t\tcrc32_data_offset = offsetof(struct u_boot_env_image_single, data);\n\t\tdata_offset = offsetof(struct u_boot_env_image_single, data);\n\t\tbreak;\n\tcase U_BOOT_FORMAT_REDUNDANT:\n\t\tcrc32_offset = offsetof(struct u_boot_env_image_redundant, crc32);\n\t\tcrc32_data_offset = offsetof(struct u_boot_env_image_redundant, data);\n\t\tdata_offset = offsetof(struct u_boot_env_image_redundant, data);\n\t\tbreak;\n\tcase U_BOOT_FORMAT_BROADCOM:\n\t\tcrc32_offset = offsetof(struct u_boot_env_image_broadcom, crc32);\n\t\tcrc32_data_offset = offsetof(struct u_boot_env_image_broadcom, data);\n\t\tdata_offset = offsetof(struct u_boot_env_image_broadcom, data);\n\t\tbreak;\n\t}\n\tcrc32 = le32_to_cpu(*(__le32 *)(buf + crc32_offset));\n\tcrc32_data_len = priv->mtd->size - crc32_data_offset;\n\tdata_len = priv->mtd->size - data_offset;\n\n\tcalc = crc32(~0, buf + crc32_data_offset, crc32_data_len) ^ ~0L;\n\tif (calc != crc32) {\n\t\tdev_err(dev, \"Invalid calculated CRC32: 0x%08x (expected: 0x%08x)\\n\", calc, crc32);\n\t\terr = -EINVAL;\n\t\tgoto err_kfree;\n\t}\n\n\tbuf[priv->mtd->size - 1] = '\\0';\n\terr = u_boot_env_add_cells(priv, buf, data_offset, data_len);\n\tif (err)\n\t\tdev_err(dev, \"Failed to add cells: %d\\n\", err);\n\nerr_kfree:\n\tkfree(buf);\nerr_out:\n\treturn err;\n}\n\nstatic int u_boot_env_probe(struct platform_device *pdev)\n{\n\tstruct nvmem_config config = {\n\t\t.name = \"u-boot-env\",\n\t\t.reg_read = u_boot_env_read,\n\t};\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct u_boot_env *priv;\n\tint err;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->dev = dev;\n\n\tpriv->format = (uintptr_t)of_device_get_match_data(dev);\n\n\tpriv->mtd = of_get_mtd_device_by_node(np);\n\tif (IS_ERR(priv->mtd)) {\n\t\tdev_err_probe(dev, PTR_ERR(priv->mtd), \"Failed to get %pOF MTD\\n\", np);\n\t\treturn PTR_ERR(priv->mtd);\n\t}\n\n\terr = u_boot_env_parse(priv);\n\tif (err)\n\t\treturn err;\n\n\tconfig.dev = dev;\n\tconfig.cells = priv->cells;\n\tconfig.ncells = priv->ncells;\n\tconfig.priv = priv;\n\tconfig.size = priv->mtd->size;\n\n\treturn PTR_ERR_OR_ZERO(devm_nvmem_register(dev, &config));\n}\n\nstatic const struct of_device_id u_boot_env_of_match_table[] = {\n\t{ .compatible = \"u-boot,env\", .data = (void *)U_BOOT_FORMAT_SINGLE, },\n\t{ .compatible = \"u-boot,env-redundant-bool\", .data = (void *)U_BOOT_FORMAT_REDUNDANT, },\n\t{ .compatible = \"u-boot,env-redundant-count\", .data = (void *)U_BOOT_FORMAT_REDUNDANT, },\n\t{ .compatible = \"brcm,env\", .data = (void *)U_BOOT_FORMAT_BROADCOM, },\n\t{},\n};\n\nstatic struct platform_driver u_boot_env_driver = {\n\t.probe = u_boot_env_probe,\n\t.driver = {\n\t\t.name = \"u_boot_env\",\n\t\t.of_match_table = u_boot_env_of_match_table,\n\t},\n};\nmodule_platform_driver(u_boot_env_driver);\n\nMODULE_AUTHOR(\"Rafa\u0142 Mi\u0142ecki\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(of, u_boot_env_of_match_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}