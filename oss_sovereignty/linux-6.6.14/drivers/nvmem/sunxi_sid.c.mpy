{
  "module_name": "sunxi_sid.c",
  "hash_id": "0fb7036049f7d95fdb33c328a0b9caf4a485aa8f9e1b12e3bcc25c2234e5aeab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/sunxi_sid.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n\n \n#define SUN8I_SID_PRCTL\t\t0x40\n#define SUN8I_SID_RDKEY\t\t0x60\n\n#define SUN8I_SID_OFFSET_MASK\t0x1FF\n#define SUN8I_SID_OFFSET_SHIFT\t16\n#define SUN8I_SID_OP_LOCK\t(0xAC << 8)\n#define SUN8I_SID_READ\t\tBIT(1)\n\nstruct sunxi_sid_cfg {\n\tu32\tvalue_offset;\n\tu32\tsize;\n\tbool\tneed_register_readout;\n};\n\nstruct sunxi_sid {\n\tvoid __iomem\t\t*base;\n\tu32\t\t\tvalue_offset;\n};\n\nstatic int sunxi_sid_read(void *context, unsigned int offset,\n\t\t\t  void *val, size_t bytes)\n{\n\tstruct sunxi_sid *sid = context;\n\tu32 word;\n\n\t \n\t__ioread32_copy(val, sid->base + sid->value_offset + offset, bytes / 4);\n\n\tval += round_down(bytes, 4);\n\toffset += round_down(bytes, 4);\n\tbytes = bytes % 4;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\t \n\tword = readl_relaxed(sid->base + sid->value_offset + offset);\n\tmemcpy(val, &word, bytes);\n\n\treturn 0;\n}\n\nstatic int sun8i_sid_register_readout(const struct sunxi_sid *sid,\n\t\t\t\t      const unsigned int offset,\n\t\t\t\t      u32 *out)\n{\n\tu32 reg_val;\n\tint ret;\n\n\t \n\treg_val = (offset & SUN8I_SID_OFFSET_MASK)\n\t\t  << SUN8I_SID_OFFSET_SHIFT;\n\treg_val |= SUN8I_SID_OP_LOCK | SUN8I_SID_READ;\n\twritel(reg_val, sid->base + SUN8I_SID_PRCTL);\n\n\tret = readl_poll_timeout(sid->base + SUN8I_SID_PRCTL, reg_val,\n\t\t\t\t !(reg_val & SUN8I_SID_READ), 100, 250000);\n\tif (ret)\n\t\treturn ret;\n\n\tif (out)\n\t\t*out = readl(sid->base + SUN8I_SID_RDKEY);\n\n\twritel(0, sid->base + SUN8I_SID_PRCTL);\n\n\treturn 0;\n}\n\n \nstatic int sun8i_sid_read_by_reg(void *context, unsigned int offset,\n\t\t\t\t void *val, size_t bytes)\n{\n\tstruct sunxi_sid *sid = context;\n\tu32 word;\n\tint ret;\n\n\t \n\twhile (bytes >= 4) {\n\t\tret = sun8i_sid_register_readout(sid, offset, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval += 4;\n\t\toffset += 4;\n\t\tbytes -= 4;\n\t}\n\n\tif (!bytes)\n\t\treturn 0;\n\n\t \n\tret = sun8i_sid_register_readout(sid, offset, &word);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(val, &word, bytes);\n\n\treturn 0;\n}\n\nstatic int sunxi_sid_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct nvmem_config *nvmem_cfg;\n\tstruct nvmem_device *nvmem;\n\tstruct sunxi_sid *sid;\n\tint size;\n\tchar *randomness;\n\tconst struct sunxi_sid_cfg *cfg;\n\n\tsid = devm_kzalloc(dev, sizeof(*sid), GFP_KERNEL);\n\tif (!sid)\n\t\treturn -ENOMEM;\n\n\tcfg = of_device_get_match_data(dev);\n\tif (!cfg)\n\t\treturn -EINVAL;\n\tsid->value_offset = cfg->value_offset;\n\n\tsid->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sid->base))\n\t\treturn PTR_ERR(sid->base);\n\n\tsize = cfg->size;\n\n\tnvmem_cfg = devm_kzalloc(dev, sizeof(*nvmem_cfg), GFP_KERNEL);\n\tif (!nvmem_cfg)\n\t\treturn -ENOMEM;\n\n\tnvmem_cfg->dev = dev;\n\tnvmem_cfg->name = \"sunxi-sid\";\n\tnvmem_cfg->type = NVMEM_TYPE_OTP;\n\tnvmem_cfg->read_only = true;\n\tnvmem_cfg->size = cfg->size;\n\tnvmem_cfg->word_size = 1;\n\tnvmem_cfg->stride = 4;\n\tnvmem_cfg->priv = sid;\n\tif (cfg->need_register_readout)\n\t\tnvmem_cfg->reg_read = sun8i_sid_read_by_reg;\n\telse\n\t\tnvmem_cfg->reg_read = sunxi_sid_read;\n\n\tnvmem = devm_nvmem_register(dev, nvmem_cfg);\n\tif (IS_ERR(nvmem))\n\t\treturn PTR_ERR(nvmem);\n\n\trandomness = kzalloc(size, GFP_KERNEL);\n\tif (!randomness)\n\t\treturn -ENOMEM;\n\n\tnvmem_cfg->reg_read(sid, 0, randomness, size);\n\tadd_device_randomness(randomness, size);\n\tkfree(randomness);\n\n\tplatform_set_drvdata(pdev, nvmem);\n\n\treturn 0;\n}\n\nstatic const struct sunxi_sid_cfg sun4i_a10_cfg = {\n\t.size = 0x10,\n};\n\nstatic const struct sunxi_sid_cfg sun7i_a20_cfg = {\n\t.size = 0x200,\n};\n\nstatic const struct sunxi_sid_cfg sun8i_h3_cfg = {\n\t.value_offset = 0x200,\n\t.size = 0x100,\n\t.need_register_readout = true,\n};\n\nstatic const struct sunxi_sid_cfg sun50i_a64_cfg = {\n\t.value_offset = 0x200,\n\t.size = 0x100,\n};\n\nstatic const struct sunxi_sid_cfg sun50i_h6_cfg = {\n\t.value_offset = 0x200,\n\t.size = 0x200,\n};\n\nstatic const struct of_device_id sunxi_sid_of_match[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-sid\", .data = &sun4i_a10_cfg },\n\t{ .compatible = \"allwinner,sun7i-a20-sid\", .data = &sun7i_a20_cfg },\n\t{ .compatible = \"allwinner,sun8i-a83t-sid\", .data = &sun50i_a64_cfg },\n\t{ .compatible = \"allwinner,sun8i-h3-sid\", .data = &sun8i_h3_cfg },\n\t{ .compatible = \"allwinner,sun20i-d1-sid\", .data = &sun50i_a64_cfg },\n\t{ .compatible = \"allwinner,sun50i-a64-sid\", .data = &sun50i_a64_cfg },\n\t{ .compatible = \"allwinner,sun50i-h5-sid\", .data = &sun50i_a64_cfg },\n\t{ .compatible = \"allwinner,sun50i-h6-sid\", .data = &sun50i_h6_cfg },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sunxi_sid_of_match);\n\nstatic struct platform_driver sunxi_sid_driver = {\n\t.probe = sunxi_sid_probe,\n\t.driver = {\n\t\t.name = \"eeprom-sunxi-sid\",\n\t\t.of_match_table = sunxi_sid_of_match,\n\t},\n};\nmodule_platform_driver(sunxi_sid_driver);\n\nMODULE_AUTHOR(\"Oliver Schinagl <oliver@schinagl.nl>\");\nMODULE_DESCRIPTION(\"Allwinner sunxi security id driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}