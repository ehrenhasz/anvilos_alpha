{
  "module_name": "sc27xx-efuse.c",
  "hash_id": "e5ebf39089c3a33f6a79f966832fdc30a33547dfdb6c4317905fa6641e1a9b3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/sc27xx-efuse.c",
  "human_readable_source": "\n\n\n#include <linux/hwspinlock.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/nvmem-provider.h>\n\n \n#define SC27XX_MODULE_EN\t\t0xc08\n#define SC2730_MODULE_EN\t\t0x1808\n#define SC27XX_EFUSE_EN\t\t\tBIT(6)\n\n \n#define SC27XX_EFUSE_GLB_CTRL\t\t0x0\n#define SC27XX_EFUSE_DATA_RD\t\t0x4\n#define SC27XX_EFUSE_DATA_WR\t\t0x8\n#define SC27XX_EFUSE_BLOCK_INDEX\t0xc\n#define SC27XX_EFUSE_MODE_CTRL\t\t0x10\n#define SC27XX_EFUSE_STATUS\t\t0x14\n#define SC27XX_EFUSE_WR_TIMING_CTRL\t0x20\n#define SC27XX_EFUSE_RD_TIMING_CTRL\t0x24\n#define SC27XX_EFUSE_EFUSE_DEB_CTRL\t0x28\n\n \n#define SC27XX_EFUSE_BLOCK_MASK\t\tGENMASK(4, 0)\n\n \n#define SC27XX_EFUSE_PG_START\t\tBIT(0)\n#define SC27XX_EFUSE_RD_START\t\tBIT(1)\n#define SC27XX_EFUSE_CLR_RDDONE\t\tBIT(2)\n\n \n#define SC27XX_EFUSE_PGM_BUSY\t\tBIT(0)\n#define SC27XX_EFUSE_READ_BUSY\t\tBIT(1)\n#define SC27XX_EFUSE_STANDBY\t\tBIT(2)\n#define SC27XX_EFUSE_GLOBAL_PROT\tBIT(3)\n#define SC27XX_EFUSE_RD_DONE\t\tBIT(4)\n\n \n#define SC27XX_EFUSE_BLOCK_MAX\t\t32\n#define SC27XX_EFUSE_BLOCK_WIDTH\t2\n\n \n#define SC27XX_EFUSE_HWLOCK_TIMEOUT\t5000\n\n \n#define SC27XX_EFUSE_POLL_TIMEOUT\t3000000\n#define SC27XX_EFUSE_POLL_DELAY_US\t10000\n\n \nstruct sc27xx_efuse_variant_data {\n\tu32 module_en;\n};\n\nstruct sc27xx_efuse {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct hwspinlock *hwlock;\n\tstruct mutex mutex;\n\tu32 base;\n\tconst struct sc27xx_efuse_variant_data *var_data;\n};\n\nstatic const struct sc27xx_efuse_variant_data sc2731_edata = {\n\t.module_en = SC27XX_MODULE_EN,\n};\n\nstatic const struct sc27xx_efuse_variant_data sc2730_edata = {\n\t.module_en = SC2730_MODULE_EN,\n};\n\n \nstatic int sc27xx_efuse_lock(struct sc27xx_efuse *efuse)\n{\n\tint ret;\n\n\tmutex_lock(&efuse->mutex);\n\n\tret = hwspin_lock_timeout_raw(efuse->hwlock,\n\t\t\t\t      SC27XX_EFUSE_HWLOCK_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(efuse->dev, \"timeout to get the hwspinlock\\n\");\n\t\tmutex_unlock(&efuse->mutex);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void sc27xx_efuse_unlock(struct sc27xx_efuse *efuse)\n{\n\thwspin_unlock_raw(efuse->hwlock);\n\tmutex_unlock(&efuse->mutex);\n}\n\nstatic int sc27xx_efuse_poll_status(struct sc27xx_efuse *efuse, u32 bits)\n{\n\tint ret;\n\tu32 val;\n\n\tret = regmap_read_poll_timeout(efuse->regmap,\n\t\t\t\t       efuse->base + SC27XX_EFUSE_STATUS,\n\t\t\t\t       val, (val & bits),\n\t\t\t\t       SC27XX_EFUSE_POLL_DELAY_US,\n\t\t\t\t       SC27XX_EFUSE_POLL_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(efuse->dev, \"timeout to update the efuse status\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sc27xx_efuse_read(void *context, u32 offset, void *val, size_t bytes)\n{\n\tstruct sc27xx_efuse *efuse = context;\n\tu32 buf, blk_index = offset / SC27XX_EFUSE_BLOCK_WIDTH;\n\tu32 blk_offset = (offset % SC27XX_EFUSE_BLOCK_WIDTH) * BITS_PER_BYTE;\n\tint ret;\n\n\tif (blk_index > SC27XX_EFUSE_BLOCK_MAX ||\n\t    bytes > SC27XX_EFUSE_BLOCK_WIDTH)\n\t\treturn -EINVAL;\n\n\tret = sc27xx_efuse_lock(efuse);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(efuse->regmap, efuse->var_data->module_en,\n\t\t\t\t SC27XX_EFUSE_EN, SC27XX_EFUSE_EN);\n\tif (ret)\n\t\tgoto unlock_efuse;\n\n\t \n\tret = sc27xx_efuse_poll_status(efuse, SC27XX_EFUSE_STANDBY);\n\tif (ret)\n\t\tgoto disable_efuse;\n\n\t \n\tret = regmap_write(efuse->regmap,\n\t\t\t   efuse->base + SC27XX_EFUSE_BLOCK_INDEX,\n\t\t\t   blk_index & SC27XX_EFUSE_BLOCK_MASK);\n\tif (ret)\n\t\tgoto disable_efuse;\n\n\t \n\tret = regmap_update_bits(efuse->regmap,\n\t\t\t\t efuse->base + SC27XX_EFUSE_MODE_CTRL,\n\t\t\t\t SC27XX_EFUSE_RD_START,\n\t\t\t\t SC27XX_EFUSE_RD_START);\n\tif (ret)\n\t\tgoto disable_efuse;\n\n\t \n\tret = sc27xx_efuse_poll_status(efuse, SC27XX_EFUSE_RD_DONE);\n\tif (ret)\n\t\tgoto disable_efuse;\n\n\t \n\tret = regmap_read(efuse->regmap, efuse->base + SC27XX_EFUSE_DATA_RD,\n\t\t\t  &buf);\n\tif (ret)\n\t\tgoto disable_efuse;\n\n\t \n\tret = regmap_update_bits(efuse->regmap,\n\t\t\t\t efuse->base + SC27XX_EFUSE_MODE_CTRL,\n\t\t\t\t SC27XX_EFUSE_CLR_RDDONE,\n\t\t\t\t SC27XX_EFUSE_CLR_RDDONE);\n\ndisable_efuse:\n\t \n\tregmap_update_bits(efuse->regmap, efuse->var_data->module_en, SC27XX_EFUSE_EN, 0);\nunlock_efuse:\n\tsc27xx_efuse_unlock(efuse);\n\n\tif (!ret) {\n\t\tbuf >>= blk_offset;\n\t\tmemcpy(val, &buf, bytes);\n\t}\n\n\treturn ret;\n}\n\nstatic int sc27xx_efuse_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct nvmem_config econfig = { };\n\tstruct nvmem_device *nvmem;\n\tstruct sc27xx_efuse *efuse;\n\tint ret;\n\n\tefuse = devm_kzalloc(&pdev->dev, sizeof(*efuse), GFP_KERNEL);\n\tif (!efuse)\n\t\treturn -ENOMEM;\n\n\tefuse->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!efuse->regmap) {\n\t\tdev_err(&pdev->dev, \"failed to get efuse regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_property_read_u32(np, \"reg\", &efuse->base);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to get efuse base address\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_hwspin_lock_get_id(np, 0);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get hwspinlock id\\n\");\n\t\treturn ret;\n\t}\n\n\tefuse->hwlock = devm_hwspin_lock_request_specific(&pdev->dev, ret);\n\tif (!efuse->hwlock) {\n\t\tdev_err(&pdev->dev, \"failed to request hwspinlock\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tmutex_init(&efuse->mutex);\n\tefuse->dev = &pdev->dev;\n\tefuse->var_data = of_device_get_match_data(&pdev->dev);\n\n\teconfig.stride = 1;\n\teconfig.word_size = 1;\n\teconfig.read_only = true;\n\teconfig.name = \"sc27xx-efuse\";\n\teconfig.size = SC27XX_EFUSE_BLOCK_MAX * SC27XX_EFUSE_BLOCK_WIDTH;\n\teconfig.reg_read = sc27xx_efuse_read;\n\teconfig.priv = efuse;\n\teconfig.dev = &pdev->dev;\n\tnvmem = devm_nvmem_register(&pdev->dev, &econfig);\n\tif (IS_ERR(nvmem)) {\n\t\tdev_err(&pdev->dev, \"failed to register nvmem config\\n\");\n\t\treturn PTR_ERR(nvmem);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sc27xx_efuse_of_match[] = {\n\t{ .compatible = \"sprd,sc2731-efuse\", .data = &sc2731_edata},\n\t{ .compatible = \"sprd,sc2730-efuse\", .data = &sc2730_edata},\n\t{ }\n};\n\nstatic struct platform_driver sc27xx_efuse_driver = {\n\t.probe = sc27xx_efuse_probe,\n\t.driver = {\n\t\t.name = \"sc27xx-efuse\",\n\t\t.of_match_table = sc27xx_efuse_of_match,\n\t},\n};\n\nmodule_platform_driver(sc27xx_efuse_driver);\n\nMODULE_AUTHOR(\"Freeman Liu <freeman.liu@spreadtrum.com>\");\nMODULE_DESCRIPTION(\"Spreadtrum SC27xx efuse driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}