{
  "module_name": "jz4780-efuse.c",
  "hash_id": "1ba923339b0ddd84c6380712db1f1e4917e5420d46982df290c00c2291693eb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/jz4780-efuse.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/timer.h>\n\n#define JZ_EFUCTRL\t\t(0x0)\t \n#define JZ_EFUCFG\t\t(0x4)\t \n#define JZ_EFUSTATE\t\t(0x8)\t \n#define JZ_EFUDATA(n)\t\t(0xC + (n) * 4)\n\n \n#define JZ_EFU_READ_SIZE 32\n\n#define EFUCTRL_ADDR_MASK\t0x3FF\n#define EFUCTRL_ADDR_SHIFT\t21\n#define EFUCTRL_LEN_MASK\t0x1F\n#define EFUCTRL_LEN_SHIFT\t16\n#define EFUCTRL_PG_EN\t\tBIT(15)\n#define EFUCTRL_WR_EN\t\tBIT(1)\n#define EFUCTRL_RD_EN\t\tBIT(0)\n\n#define EFUCFG_INT_EN\t\tBIT(31)\n#define EFUCFG_RD_ADJ_MASK\t0xF\n#define EFUCFG_RD_ADJ_SHIFT\t20\n#define EFUCFG_RD_STR_MASK\t0xF\n#define EFUCFG_RD_STR_SHIFT\t16\n#define EFUCFG_WR_ADJ_MASK\t0xF\n#define EFUCFG_WR_ADJ_SHIFT\t12\n#define EFUCFG_WR_STR_MASK\t0xFFF\n#define EFUCFG_WR_STR_SHIFT\t0\n\n#define EFUSTATE_WR_DONE\tBIT(1)\n#define EFUSTATE_RD_DONE\tBIT(0)\n\nstruct jz4780_efuse {\n\tstruct device *dev;\n\tstruct regmap *map;\n\tstruct clk *clk;\n};\n\n \nstatic int jz4780_efuse_read(void *context, unsigned int offset,\n\t\t\t     void *val, size_t bytes)\n{\n\tstruct jz4780_efuse *efuse = context;\n\n\twhile (bytes > 0) {\n\t\tsize_t start = offset & ~(JZ_EFU_READ_SIZE - 1);\n\t\tsize_t chunk = min(bytes, (start + JZ_EFU_READ_SIZE)\n\t\t\t\t    - offset);\n\t\tchar buf[JZ_EFU_READ_SIZE];\n\t\tunsigned int tmp;\n\t\tu32 ctrl;\n\t\tint ret;\n\n\t\tctrl = (start << EFUCTRL_ADDR_SHIFT)\n\t\t\t| ((JZ_EFU_READ_SIZE - 1) << EFUCTRL_LEN_SHIFT)\n\t\t\t| EFUCTRL_RD_EN;\n\n\t\tregmap_update_bits(efuse->map, JZ_EFUCTRL,\n\t\t\t\t   (EFUCTRL_ADDR_MASK << EFUCTRL_ADDR_SHIFT) |\n\t\t\t\t   (EFUCTRL_LEN_MASK << EFUCTRL_LEN_SHIFT) |\n\t\t\t\t   EFUCTRL_PG_EN | EFUCTRL_WR_EN |\n\t\t\t\t   EFUCTRL_RD_EN,\n\t\t\t\t   ctrl);\n\n\t\tret = regmap_read_poll_timeout(efuse->map, JZ_EFUSTATE,\n\t\t\t\t\t       tmp, tmp & EFUSTATE_RD_DONE,\n\t\t\t\t\t       1 * MSEC_PER_SEC,\n\t\t\t\t\t       50 * MSEC_PER_SEC);\n\t\tif (ret < 0) {\n\t\t\tdev_err(efuse->dev, \"Time out while reading efuse data\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_bulk_read(efuse->map, JZ_EFUDATA(0),\n\t\t\t\t       buf, JZ_EFU_READ_SIZE / sizeof(u32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmemcpy(val, &buf[offset - start], chunk);\n\n\t\tval += chunk;\n\t\toffset += chunk;\n\t\tbytes -= chunk;\n\t}\n\n\treturn 0;\n}\n\nstatic struct nvmem_config jz4780_efuse_nvmem_config = {\n\t.name = \"jz4780-efuse\",\n\t.size = 1024,\n\t.word_size = 1,\n\t.stride = 1,\n\t.owner = THIS_MODULE,\n\t.reg_read = jz4780_efuse_read,\n};\n\nstatic const struct regmap_config jz4780_efuse_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = JZ_EFUDATA(7),\n};\n\nstatic void clk_disable_unprepare_helper(void *clock)\n{\n\tclk_disable_unprepare(clock);\n}\n\nstatic int jz4780_efuse_probe(struct platform_device *pdev)\n{\n\tstruct nvmem_device *nvmem;\n\tstruct jz4780_efuse *efuse;\n\tstruct nvmem_config cfg;\n\tunsigned long clk_rate;\n\tunsigned long rd_adj;\n\tunsigned long rd_strobe;\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *regs;\n\tint ret;\n\n\tefuse = devm_kzalloc(dev, sizeof(*efuse), GFP_KERNEL);\n\tif (!efuse)\n\t\treturn -ENOMEM;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tefuse->map = devm_regmap_init_mmio(dev, regs,\n\t\t\t\t\t   &jz4780_efuse_regmap_config);\n\tif (IS_ERR(efuse->map))\n\t\treturn PTR_ERR(efuse->map);\n\n\tefuse->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(efuse->clk))\n\t\treturn PTR_ERR(efuse->clk);\n\n\tret = clk_prepare_enable(efuse->clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t       clk_disable_unprepare_helper,\n\t\t\t\t       efuse->clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tclk_rate = clk_get_rate(efuse->clk);\n\n\tefuse->dev = dev;\n\n\t \n\n\trd_adj = clk_rate / 153846154;\n\trd_strobe = clk_rate / 28571429 - 5 - rd_adj + 1;\n\n\tif (rd_adj > EFUCFG_RD_ADJ_MASK ||\n\t    rd_strobe > EFUCFG_RD_STR_MASK) {\n\t\tdev_err(&pdev->dev, \"Cannot set clock configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(efuse->map, JZ_EFUCFG,\n\t\t\t   (EFUCFG_RD_ADJ_MASK << EFUCFG_RD_ADJ_SHIFT) |\n\t\t\t   (EFUCFG_RD_STR_MASK << EFUCFG_RD_STR_SHIFT),\n\t\t\t   (rd_adj << EFUCFG_RD_ADJ_SHIFT) |\n\t\t\t   (rd_strobe << EFUCFG_RD_STR_SHIFT));\n\n\tcfg = jz4780_efuse_nvmem_config;\n\tcfg.dev = &pdev->dev;\n\tcfg.priv = efuse;\n\n\tnvmem = devm_nvmem_register(dev, &cfg);\n\n\treturn PTR_ERR_OR_ZERO(nvmem);\n}\n\nstatic const struct of_device_id jz4780_efuse_match[] = {\n\t{ .compatible = \"ingenic,jz4780-efuse\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, jz4780_efuse_match);\n\nstatic struct platform_driver jz4780_efuse_driver = {\n\t.probe  = jz4780_efuse_probe,\n\t.driver = {\n\t\t.name = \"jz4780-efuse\",\n\t\t.of_match_table = jz4780_efuse_match,\n\t},\n};\nmodule_platform_driver(jz4780_efuse_driver);\n\nMODULE_AUTHOR(\"PrasannaKumar Muralidharan <prasannatsmkumar@gmail.com>\");\nMODULE_AUTHOR(\"H. Nikolaus Schaller <hns@goldelico.com>\");\nMODULE_AUTHOR(\"Paul Cercueil <paul@crapouillou.net>\");\nMODULE_DESCRIPTION(\"Ingenic JZ4780 efuse driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}