{
  "module_name": "sunplus-ocotp.c",
  "hash_id": "9617bbb9a2d822480baadaa6b74947bc80b341d894e9e631166c9a771a82ecd0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/sunplus-ocotp.c",
  "human_readable_source": "\n\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/nvmem-provider.h>\n#include <linux/platform_device.h>\n\n \n\n#define OTP_WORDS_PER_BANK\t\t4\n#define OTP_WORD_SIZE\t\t\tsizeof(u32)\n#define OTP_BIT_ADDR_OF_BANK\t\t(8 * OTP_WORD_SIZE * OTP_WORDS_PER_BANK)\n#define QAC628_OTP_NUM_BANKS\t\t8\n#define QAC628_OTP_SIZE\t\t\t(QAC628_OTP_NUM_BANKS * OTP_WORDS_PER_BANK * OTP_WORD_SIZE)\n#define OTP_READ_TIMEOUT_US\t\t200000\n\n \n#define ADDRESS_8_DATA\t\t\t0x20\n\n \n#define OTP_CONTROL_2\t\t\t0x48\n#define OTP_RD_PERIOD\t\t\tGENMASK(15, 8)\n#define OTP_RD_PERIOD_MASK\t\t~GENMASK(15, 8)\n#define CPU_CLOCK\t\t\tFIELD_PREP(OTP_RD_PERIOD, 30)\n#define SEL_BAK_KEY2\t\t\tBIT(5)\n#define SEL_BAK_KEY2_MASK\t\t~BIT(5)\n#define SW_TRIM_EN\t\t\tBIT(4)\n#define SW_TRIM_EN_MASK\t\t\t~BIT(4)\n#define SEL_BAK_KEY\t\t\tBIT(3)\n#define SEL_BAK_KEY_MASK\t\t~BIT(3)\n#define OTP_READ\t\t\tBIT(2)\n#define OTP_LOAD_SECURE_DATA\t\tBIT(1)\n#define OTP_LOAD_SECURE_DATA_MASK\t~BIT(1)\n#define OTP_DO_CRC\t\t\tBIT(0)\n#define OTP_DO_CRC_MASK\t\t\t~BIT(0)\n#define OTP_STATUS\t\t\t0x4c\n#define OTP_READ_DONE\t\t\tBIT(4)\n#define OTP_READ_DONE_MASK\t\t~BIT(4)\n#define OTP_LOAD_SECURE_DONE_MASK\t~BIT(2)\n#define OTP_READ_ADDRESS\t\t0x50\n\nenum base_type {\n\tHB_GPIO,\n\tOTPRX,\n\tBASEMAX,\n};\n\nstruct sp_ocotp_priv {\n\tstruct device *dev;\n\tvoid __iomem *base[BASEMAX];\n\tstruct clk *clk;\n};\n\nstruct sp_ocotp_data {\n\tint size;\n};\n\nstatic const struct sp_ocotp_data sp_otp_v0 = {\n\t.size = QAC628_OTP_SIZE,\n};\n\nstatic int sp_otp_read_real(struct sp_ocotp_priv *otp, int addr, char *value)\n{\n\tunsigned int addr_data;\n\tunsigned int byte_shift;\n\tunsigned int status;\n\tint ret;\n\n\taddr_data = addr % (OTP_WORD_SIZE * OTP_WORDS_PER_BANK);\n\taddr_data = addr_data / OTP_WORD_SIZE;\n\n\tbyte_shift = addr % (OTP_WORD_SIZE * OTP_WORDS_PER_BANK);\n\tbyte_shift = byte_shift % OTP_WORD_SIZE;\n\n\taddr = addr / (OTP_WORD_SIZE * OTP_WORDS_PER_BANK);\n\taddr = addr * OTP_BIT_ADDR_OF_BANK;\n\n\twritel(readl(otp->base[OTPRX] + OTP_STATUS) & OTP_READ_DONE_MASK &\n\t       OTP_LOAD_SECURE_DONE_MASK, otp->base[OTPRX] + OTP_STATUS);\n\twritel(addr, otp->base[OTPRX] + OTP_READ_ADDRESS);\n\twritel(readl(otp->base[OTPRX] + OTP_CONTROL_2) | OTP_READ,\n\t       otp->base[OTPRX] + OTP_CONTROL_2);\n\twritel(readl(otp->base[OTPRX] + OTP_CONTROL_2) & SEL_BAK_KEY2_MASK & SW_TRIM_EN_MASK\n\t       & SEL_BAK_KEY_MASK & OTP_LOAD_SECURE_DATA_MASK & OTP_DO_CRC_MASK,\n\t       otp->base[OTPRX] + OTP_CONTROL_2);\n\twritel((readl(otp->base[OTPRX] + OTP_CONTROL_2) & OTP_RD_PERIOD_MASK) | CPU_CLOCK,\n\t       otp->base[OTPRX] + OTP_CONTROL_2);\n\n\tret = readl_poll_timeout(otp->base[OTPRX] + OTP_STATUS, status,\n\t\t\t\t status & OTP_READ_DONE, 10, OTP_READ_TIMEOUT_US);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*value = (readl(otp->base[HB_GPIO] + ADDRESS_8_DATA + addr_data * OTP_WORD_SIZE)\n\t\t  >> (8 * byte_shift)) & 0xff;\n\n\treturn ret;\n}\n\nstatic int sp_ocotp_read(void *priv, unsigned int offset, void *value, size_t bytes)\n{\n\tstruct sp_ocotp_priv *otp = priv;\n\tunsigned int addr;\n\tchar *buf = value;\n\tchar val[4];\n\tint ret;\n\n\tret = clk_enable(otp->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t*buf = 0;\n\tfor (addr = offset; addr < (offset + bytes); addr++) {\n\t\tret = sp_otp_read_real(otp, addr, val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(otp->dev, \"OTP read fail:%d at %d\", ret, addr);\n\t\t\tgoto disable_clk;\n\t\t}\n\n\t\t*buf++ = *val;\n\t}\n\ndisable_clk:\n\tclk_disable(otp->clk);\n\n\treturn ret;\n}\n\nstatic struct nvmem_config sp_ocotp_nvmem_config = {\n\t.name = \"sp-ocotp\",\n\t.read_only = true,\n\t.word_size = 1,\n\t.size = QAC628_OTP_SIZE,\n\t.stride = 1,\n\t.reg_read = sp_ocotp_read,\n\t.owner = THIS_MODULE,\n};\n\nstatic int sp_ocotp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct nvmem_device *nvmem;\n\tstruct sp_ocotp_priv *otp;\n\tstruct resource *res;\n\tint ret;\n\n\totp = devm_kzalloc(dev, sizeof(*otp), GFP_KERNEL);\n\tif (!otp)\n\t\treturn -ENOMEM;\n\n\totp->dev = dev;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"hb_gpio\");\n\totp->base[HB_GPIO] = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(otp->base[HB_GPIO]))\n\t\treturn PTR_ERR(otp->base[HB_GPIO]);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"otprx\");\n\totp->base[OTPRX] = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(otp->base[OTPRX]))\n\t\treturn PTR_ERR(otp->base[OTPRX]);\n\n\totp->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(otp->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(otp->clk),\n\t\t\t\t\t\t\"devm_clk_get fail\\n\");\n\n\tret = clk_prepare(otp->clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to prepare clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsp_ocotp_nvmem_config.priv = otp;\n\tsp_ocotp_nvmem_config.dev = dev;\n\n\tnvmem = devm_nvmem_register(dev, &sp_ocotp_nvmem_config);\n\tif (IS_ERR(nvmem)) {\n\t\tret = dev_err_probe(&pdev->dev, PTR_ERR(nvmem),\n\t\t\t\t\t\t\"register nvmem device fail\\n\");\n\t\tgoto err;\n\t}\n\n\tplatform_set_drvdata(pdev, nvmem);\n\n\tdev_dbg(dev, \"banks:%d x wpb:%d x wsize:%d = %d\",\n\t\t(int)QAC628_OTP_NUM_BANKS, (int)OTP_WORDS_PER_BANK,\n\t\t(int)OTP_WORD_SIZE, (int)QAC628_OTP_SIZE);\n\n\treturn 0;\nerr:\n\tclk_unprepare(otp->clk);\n\treturn ret;\n}\n\nstatic const struct of_device_id sp_ocotp_dt_ids[] = {\n\t{ .compatible = \"sunplus,sp7021-ocotp\", .data = &sp_otp_v0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sp_ocotp_dt_ids);\n\nstatic struct platform_driver sp_otp_driver = {\n\t.probe     = sp_ocotp_probe,\n\t.driver    = {\n\t\t.name           = \"sunplus,sp7021-ocotp\",\n\t\t.of_match_table = sp_ocotp_dt_ids,\n\t}\n};\nmodule_platform_driver(sp_otp_driver);\n\nMODULE_AUTHOR(\"Vincent Shih <vincent.sunplus@gmail.com>\");\nMODULE_DESCRIPTION(\"Sunplus On-Chip OTP driver\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}