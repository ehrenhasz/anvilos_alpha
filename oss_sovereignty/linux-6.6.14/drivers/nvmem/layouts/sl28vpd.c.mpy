{
  "module_name": "sl28vpd.c",
  "hash_id": "d8601e63788f3031b6820ac6c3eccfc39710645330e83fa196ac7b39dec909a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/layouts/sl28vpd.c",
  "human_readable_source": "\n\n#include <linux/crc8.h>\n#include <linux/etherdevice.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <uapi/linux/if_ether.h>\n\n#define SL28VPD_MAGIC 'V'\n\nstruct sl28vpd_header {\n\tu8 magic;\n\tu8 version;\n} __packed;\n\nstruct sl28vpd_v1 {\n\tstruct sl28vpd_header header;\n\tchar serial_number[15];\n\tu8 base_mac_address[ETH_ALEN];\n\tu8 crc8;\n} __packed;\n\nstatic int sl28vpd_mac_address_pp(void *priv, const char *id, int index,\n\t\t\t\t  unsigned int offset, void *buf,\n\t\t\t\t  size_t bytes)\n{\n\tif (bytes != ETH_ALEN)\n\t\treturn -EINVAL;\n\n\tif (index < 0)\n\t\treturn -EINVAL;\n\n\tif (!is_valid_ether_addr(buf))\n\t\treturn -EINVAL;\n\n\teth_addr_add(buf, index);\n\n\treturn 0;\n}\n\nstatic const struct nvmem_cell_info sl28vpd_v1_entries[] = {\n\t{\n\t\t.name = \"serial-number\",\n\t\t.offset = offsetof(struct sl28vpd_v1, serial_number),\n\t\t.bytes = sizeof_field(struct sl28vpd_v1, serial_number),\n\t},\n\t{\n\t\t.name = \"base-mac-address\",\n\t\t.offset = offsetof(struct sl28vpd_v1, base_mac_address),\n\t\t.bytes = sizeof_field(struct sl28vpd_v1, base_mac_address),\n\t\t.read_post_process = sl28vpd_mac_address_pp,\n\t},\n};\n\nstatic int sl28vpd_v1_check_crc(struct device *dev, struct nvmem_device *nvmem)\n{\n\tstruct sl28vpd_v1 data_v1;\n\tu8 table[CRC8_TABLE_SIZE];\n\tint ret;\n\tu8 crc;\n\n\tcrc8_populate_msb(table, 0x07);\n\n\tret = nvmem_device_read(nvmem, 0, sizeof(data_v1), &data_v1);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != sizeof(data_v1))\n\t\treturn -EIO;\n\n\tcrc = crc8(table, (void *)&data_v1, sizeof(data_v1) - 1, 0);\n\n\tif (crc != data_v1.crc8) {\n\t\tdev_err(dev,\n\t\t\t\"Checksum is invalid (got %02x, expected %02x).\\n\",\n\t\t\tcrc, data_v1.crc8);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sl28vpd_add_cells(struct device *dev, struct nvmem_device *nvmem,\n\t\t\t     struct nvmem_layout *layout)\n{\n\tconst struct nvmem_cell_info *pinfo;\n\tstruct nvmem_cell_info info = {0};\n\tstruct device_node *layout_np;\n\tstruct sl28vpd_header hdr;\n\tint ret, i;\n\n\t \n\tret = nvmem_device_read(nvmem, 0, sizeof(hdr), &hdr);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != sizeof(hdr))\n\t\treturn -EIO;\n\n\tif (hdr.magic != SL28VPD_MAGIC) {\n\t\tdev_err(dev, \"Invalid magic value (%02x)\\n\", hdr.magic);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr.version != 1) {\n\t\tdev_err(dev, \"Version %d is unsupported.\\n\", hdr.version);\n\t\treturn -EINVAL;\n\t}\n\n\tret = sl28vpd_v1_check_crc(dev, nvmem);\n\tif (ret)\n\t\treturn ret;\n\n\tlayout_np = of_nvmem_layout_get_container(nvmem);\n\tif (!layout_np)\n\t\treturn -ENOENT;\n\n\tfor (i = 0; i < ARRAY_SIZE(sl28vpd_v1_entries); i++) {\n\t\tpinfo = &sl28vpd_v1_entries[i];\n\n\t\tinfo.name = pinfo->name;\n\t\tinfo.offset = pinfo->offset;\n\t\tinfo.bytes = pinfo->bytes;\n\t\tinfo.read_post_process = pinfo->read_post_process;\n\t\tinfo.np = of_get_child_by_name(layout_np, pinfo->name);\n\n\t\tret = nvmem_add_one_cell(nvmem, &info);\n\t\tif (ret) {\n\t\t\tof_node_put(layout_np);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tof_node_put(layout_np);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sl28vpd_of_match_table[] = {\n\t{ .compatible = \"kontron,sl28-vpd\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sl28vpd_of_match_table);\n\nstatic struct nvmem_layout sl28vpd_layout = {\n\t.name = \"sl28-vpd\",\n\t.of_match_table = sl28vpd_of_match_table,\n\t.add_cells = sl28vpd_add_cells,\n};\nmodule_nvmem_layout_driver(sl28vpd_layout);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Michael Walle <michael@walle.cc>\");\nMODULE_DESCRIPTION(\"NVMEM layout driver for the VPD of Kontron sl28 boards\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}