{
  "module_name": "onie-tlv.c",
  "hash_id": "cfb4eabfc309f4fcabf06d93cb57d3a75a875a9d10d12104b89a4e5ad93c2a21",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/layouts/onie-tlv.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include <linux/etherdevice.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n\n#define ONIE_TLV_MAX_LEN 2048\n#define ONIE_TLV_CRC_FIELD_SZ 6\n#define ONIE_TLV_CRC_SZ 4\n#define ONIE_TLV_HDR_ID\t\"TlvInfo\"\n\nstruct onie_tlv_hdr {\n\tu8 id[8];\n\tu8 version;\n\t__be16 data_len;\n} __packed;\n\nstruct onie_tlv {\n\tu8 type;\n\tu8 len;\n} __packed;\n\nstatic const char *onie_tlv_cell_name(u8 type)\n{\n\tswitch (type) {\n\tcase 0x21:\n\t\treturn \"product-name\";\n\tcase 0x22:\n\t\treturn \"part-number\";\n\tcase 0x23:\n\t\treturn \"serial-number\";\n\tcase 0x24:\n\t\treturn \"mac-address\";\n\tcase 0x25:\n\t\treturn \"manufacture-date\";\n\tcase 0x26:\n\t\treturn \"device-version\";\n\tcase 0x27:\n\t\treturn \"label-revision\";\n\tcase 0x28:\n\t\treturn \"platform-name\";\n\tcase 0x29:\n\t\treturn \"onie-version\";\n\tcase 0x2A:\n\t\treturn \"num-macs\";\n\tcase 0x2B:\n\t\treturn \"manufacturer\";\n\tcase 0x2C:\n\t\treturn \"country-code\";\n\tcase 0x2D:\n\t\treturn \"vendor\";\n\tcase 0x2E:\n\t\treturn \"diag-version\";\n\tcase 0x2F:\n\t\treturn \"service-tag\";\n\tcase 0xFD:\n\t\treturn \"vendor-extension\";\n\tcase 0xFE:\n\t\treturn \"crc32\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\nstatic int onie_tlv_mac_read_cb(void *priv, const char *id, int index,\n\t\t\t\tunsigned int offset, void *buf,\n\t\t\t\tsize_t bytes)\n{\n\teth_addr_add(buf, index);\n\n\treturn 0;\n}\n\nstatic nvmem_cell_post_process_t onie_tlv_read_cb(u8 type, u8 *buf)\n{\n\tswitch (type) {\n\tcase 0x24:\n\t\treturn &onie_tlv_mac_read_cb;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\nstatic int onie_tlv_add_cells(struct device *dev, struct nvmem_device *nvmem,\n\t\t\t      size_t data_len, u8 *data)\n{\n\tstruct nvmem_cell_info cell = {};\n\tstruct device_node *layout;\n\tstruct onie_tlv tlv;\n\tunsigned int hdr_len = sizeof(struct onie_tlv_hdr);\n\tunsigned int offset = 0;\n\tint ret;\n\n\tlayout = of_nvmem_layout_get_container(nvmem);\n\tif (!layout)\n\t\treturn -ENOENT;\n\n\twhile (offset < data_len) {\n\t\tmemcpy(&tlv, data + offset, sizeof(tlv));\n\t\tif (offset + tlv.len >= data_len) {\n\t\t\tdev_err(dev, \"Out of bounds field (0x%x bytes at 0x%x)\\n\",\n\t\t\t\ttlv.len, hdr_len + offset);\n\t\t\tbreak;\n\t\t}\n\n\t\tcell.name = onie_tlv_cell_name(tlv.type);\n\t\tif (!cell.name)\n\t\t\tcontinue;\n\n\t\tcell.offset = hdr_len + offset + sizeof(tlv.type) + sizeof(tlv.len);\n\t\tcell.bytes = tlv.len;\n\t\tcell.np = of_get_child_by_name(layout, cell.name);\n\t\tcell.read_post_process = onie_tlv_read_cb(tlv.type, data + offset + sizeof(tlv));\n\n\t\tret = nvmem_add_one_cell(nvmem, &cell);\n\t\tif (ret) {\n\t\t\tof_node_put(layout);\n\t\t\treturn ret;\n\t\t}\n\n\t\toffset += sizeof(tlv) + tlv.len;\n\t}\n\n\tof_node_put(layout);\n\n\treturn 0;\n}\n\nstatic bool onie_tlv_hdr_is_valid(struct device *dev, struct onie_tlv_hdr *hdr)\n{\n\tif (memcmp(hdr->id, ONIE_TLV_HDR_ID, sizeof(hdr->id))) {\n\t\tdev_err(dev, \"Invalid header\\n\");\n\t\treturn false;\n\t}\n\n\tif (hdr->version != 0x1) {\n\t\tdev_err(dev, \"Invalid version number\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool onie_tlv_crc_is_valid(struct device *dev, size_t table_len, u8 *table)\n{\n\tstruct onie_tlv crc_hdr;\n\tu32 read_crc, calc_crc;\n\t__be32 crc_be;\n\n\tmemcpy(&crc_hdr, table + table_len - ONIE_TLV_CRC_FIELD_SZ, sizeof(crc_hdr));\n\tif (crc_hdr.type != 0xfe || crc_hdr.len != ONIE_TLV_CRC_SZ) {\n\t\tdev_err(dev, \"Invalid CRC field\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tmemcpy(&crc_be, table + table_len - ONIE_TLV_CRC_SZ, ONIE_TLV_CRC_SZ);\n\tread_crc = be32_to_cpu(crc_be);\n\tcalc_crc = crc32(~0, table, table_len - ONIE_TLV_CRC_SZ) ^ 0xFFFFFFFF;\n\tif (read_crc != calc_crc) {\n\t\tdev_err(dev, \"Invalid CRC read: 0x%08x, expected: 0x%08x\\n\",\n\t\t\tread_crc, calc_crc);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int onie_tlv_parse_table(struct device *dev, struct nvmem_device *nvmem,\n\t\t\t\tstruct nvmem_layout *layout)\n{\n\tstruct onie_tlv_hdr hdr;\n\tsize_t table_len, data_len, hdr_len;\n\tu8 *table, *data;\n\tint ret;\n\n\tret = nvmem_device_read(nvmem, 0, sizeof(hdr), &hdr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!onie_tlv_hdr_is_valid(dev, &hdr)) {\n\t\tdev_err(dev, \"Invalid ONIE TLV header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr_len = sizeof(hdr.id) + sizeof(hdr.version) + sizeof(hdr.data_len);\n\tdata_len = be16_to_cpu(hdr.data_len);\n\ttable_len = hdr_len + data_len;\n\tif (table_len > ONIE_TLV_MAX_LEN) {\n\t\tdev_err(dev, \"Invalid ONIE TLV data length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttable = devm_kmalloc(dev, table_len, GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\tret = nvmem_device_read(nvmem, 0, table_len, table);\n\tif (ret != table_len)\n\t\treturn ret;\n\n\tif (!onie_tlv_crc_is_valid(dev, table_len, table))\n\t\treturn -EINVAL;\n\n\tdata = table + hdr_len;\n\tret = onie_tlv_add_cells(dev, nvmem, data_len, data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id onie_tlv_of_match_table[] = {\n\t{ .compatible = \"onie,tlv-layout\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, onie_tlv_of_match_table);\n\nstatic struct nvmem_layout onie_tlv_layout = {\n\t.name = \"ONIE tlv layout\",\n\t.of_match_table = onie_tlv_of_match_table,\n\t.add_cells = onie_tlv_parse_table,\n};\nmodule_nvmem_layout_driver(onie_tlv_layout);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Miquel Raynal <miquel.raynal@bootlin.com>\");\nMODULE_DESCRIPTION(\"NVMEM layout driver for Onie TLV table parsing\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}