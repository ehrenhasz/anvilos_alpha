{
  "module_name": "meson-efuse.c",
  "hash_id": "6ec731d108c2e5a8029a07695adf47aaaf422b477710b442adb8dc8f6685122e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/meson-efuse.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <linux/firmware/meson/meson_sm.h>\n\nstatic int meson_efuse_read(void *context, unsigned int offset,\n\t\t\t    void *val, size_t bytes)\n{\n\tstruct meson_sm_firmware *fw = context;\n\n\treturn meson_sm_call_read(fw, (u8 *)val, bytes, SM_EFUSE_READ, offset,\n\t\t\t\t  bytes, 0, 0, 0);\n}\n\nstatic int meson_efuse_write(void *context, unsigned int offset,\n\t\t\t     void *val, size_t bytes)\n{\n\tstruct meson_sm_firmware *fw = context;\n\n\treturn meson_sm_call_write(fw, (u8 *)val, bytes, SM_EFUSE_WRITE, offset,\n\t\t\t\t   bytes, 0, 0, 0);\n}\n\nstatic const struct of_device_id meson_efuse_match[] = {\n\t{ .compatible = \"amlogic,meson-gxbb-efuse\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, meson_efuse_match);\n\nstatic int meson_efuse_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct meson_sm_firmware *fw;\n\tstruct device_node *sm_np;\n\tstruct nvmem_device *nvmem;\n\tstruct nvmem_config *econfig;\n\tstruct clk *clk;\n\tunsigned int size;\n\tint ret;\n\n\tsm_np = of_parse_phandle(pdev->dev.of_node, \"secure-monitor\", 0);\n\tif (!sm_np) {\n\t\tdev_err(&pdev->dev, \"no secure-monitor node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfw = meson_sm_get(sm_np);\n\tof_node_put(sm_np);\n\tif (!fw)\n\t\treturn -EPROBE_DEFER;\n\n\tclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"failed to get efuse gate\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable gate\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev,\n\t\t\t\t       (void(*)(void *))clk_disable_unprepare,\n\t\t\t\t       clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add disable callback\");\n\t\treturn ret;\n\t}\n\n\tif (meson_sm_call(fw, SM_EFUSE_USER_MAX, &size, 0, 0, 0, 0, 0) < 0) {\n\t\tdev_err(dev, \"failed to get max user\");\n\t\treturn -EINVAL;\n\t}\n\n\teconfig = devm_kzalloc(dev, sizeof(*econfig), GFP_KERNEL);\n\tif (!econfig)\n\t\treturn -ENOMEM;\n\n\teconfig->dev = dev;\n\teconfig->name = dev_name(dev);\n\teconfig->stride = 1;\n\teconfig->word_size = 1;\n\teconfig->reg_read = meson_efuse_read;\n\teconfig->reg_write = meson_efuse_write;\n\teconfig->size = size;\n\teconfig->priv = fw;\n\n\tnvmem = devm_nvmem_register(&pdev->dev, econfig);\n\n\treturn PTR_ERR_OR_ZERO(nvmem);\n}\n\nstatic struct platform_driver meson_efuse_driver = {\n\t.probe = meson_efuse_probe,\n\t.driver = {\n\t\t.name = \"meson-efuse\",\n\t\t.of_match_table = meson_efuse_match,\n\t},\n};\n\nmodule_platform_driver(meson_efuse_driver);\n\nMODULE_AUTHOR(\"Carlo Caione <carlo@endlessm.com>\");\nMODULE_DESCRIPTION(\"Amlogic Meson GX NVMEM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}