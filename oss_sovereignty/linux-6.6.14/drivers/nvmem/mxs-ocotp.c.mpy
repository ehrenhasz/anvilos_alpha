{
  "module_name": "mxs-ocotp.c",
  "hash_id": "d59f7762be29e87da66eba3d1464d886dcb977c59776925054b455398d536df2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/mxs-ocotp.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/stmp_device.h>\n\n \n\n#define BM_OCOTP_CTRL_RD_BANK_OPEN\tBIT(12)\n#define BM_OCOTP_CTRL_ERROR\t\tBIT(9)\n#define BM_OCOTP_CTRL_BUSY\t\tBIT(8)\n\n#define OCOTP_TIMEOUT\t\t10000\n#define OCOTP_DATA_OFFSET\t0x20\n\nstruct mxs_ocotp {\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tstruct nvmem_device *nvmem;\n};\n\nstatic int mxs_ocotp_wait(struct mxs_ocotp *otp)\n{\n\tint timeout = OCOTP_TIMEOUT;\n\tunsigned int status = 0;\n\n\twhile (timeout--) {\n\t\tstatus = readl(otp->base);\n\n\t\tif (!(status & (BM_OCOTP_CTRL_BUSY | BM_OCOTP_CTRL_ERROR)))\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tif (status & BM_OCOTP_CTRL_BUSY)\n\t\treturn -EBUSY;\n\telse if (status & BM_OCOTP_CTRL_ERROR)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int mxs_ocotp_read(void *context, unsigned int offset,\n\t\t\t  void *val, size_t bytes)\n{\n\tstruct mxs_ocotp *otp = context;\n\tu32 *buf = val;\n\tint ret;\n\n\tret = clk_enable(otp->clk);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(BM_OCOTP_CTRL_ERROR, otp->base + STMP_OFFSET_REG_CLR);\n\n\tret = mxs_ocotp_wait(otp);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\t \n\twritel(BM_OCOTP_CTRL_RD_BANK_OPEN, otp->base + STMP_OFFSET_REG_SET);\n\n\t \n\tudelay(1);\n\n\tret = mxs_ocotp_wait(otp);\n\tif (ret)\n\t\tgoto close_banks;\n\n\twhile (bytes) {\n\t\tif ((offset < OCOTP_DATA_OFFSET) || (offset % 16)) {\n\t\t\t \n\t\t\t*buf++ = 0;\n\t\t} else {\n\t\t\t*buf++ = readl(otp->base + offset);\n\t\t}\n\n\t\tbytes -= 4;\n\t\toffset += 4;\n\t}\n\nclose_banks:\n\t \n\twritel(BM_OCOTP_CTRL_RD_BANK_OPEN, otp->base + STMP_OFFSET_REG_CLR);\n\ndisable_clk:\n\tclk_disable(otp->clk);\n\n\treturn ret;\n}\n\nstatic struct nvmem_config ocotp_config = {\n\t.name = \"mxs-ocotp\",\n\t.stride = 16,\n\t.word_size = 4,\n\t.reg_read = mxs_ocotp_read,\n};\n\nstruct mxs_data {\n\tint size;\n};\n\nstatic const struct mxs_data imx23_data = {\n\t.size = 0x220,\n};\n\nstatic const struct mxs_data imx28_data = {\n\t.size = 0x2a0,\n};\n\nstatic const struct of_device_id mxs_ocotp_match[] = {\n\t{ .compatible = \"fsl,imx23-ocotp\", .data = &imx23_data },\n\t{ .compatible = \"fsl,imx28-ocotp\", .data = &imx28_data },\n\t{  },\n};\nMODULE_DEVICE_TABLE(of, mxs_ocotp_match);\n\nstatic void mxs_ocotp_action(void *data)\n{\n\tclk_unprepare(data);\n}\n\nstatic int mxs_ocotp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct mxs_data *data;\n\tstruct mxs_ocotp *otp;\n\tconst struct of_device_id *match;\n\tint ret;\n\n\tmatch = of_match_device(dev->driver->of_match_table, dev);\n\tif (!match || !match->data)\n\t\treturn -EINVAL;\n\n\totp = devm_kzalloc(dev, sizeof(*otp), GFP_KERNEL);\n\tif (!otp)\n\t\treturn -ENOMEM;\n\n\totp->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(otp->base))\n\t\treturn PTR_ERR(otp->base);\n\n\totp->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(otp->clk))\n\t\treturn PTR_ERR(otp->clk);\n\n\tret = clk_prepare(otp->clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to prepare clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&pdev->dev, mxs_ocotp_action, otp->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = match->data;\n\n\tocotp_config.size = data->size;\n\tocotp_config.priv = otp;\n\tocotp_config.dev = dev;\n\totp->nvmem = devm_nvmem_register(dev, &ocotp_config);\n\tif (IS_ERR(otp->nvmem))\n\t\treturn PTR_ERR(otp->nvmem);\n\n\tplatform_set_drvdata(pdev, otp);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mxs_ocotp_driver = {\n\t.probe = mxs_ocotp_probe,\n\t.driver = {\n\t\t.name = \"mxs-ocotp\",\n\t\t.of_match_table = mxs_ocotp_match,\n\t},\n};\n\nmodule_platform_driver(mxs_ocotp_driver);\nMODULE_AUTHOR(\"Stefan Wahren <wahrenst@gmx.net\");\nMODULE_DESCRIPTION(\"driver for OCOTP in i.MX23/i.MX28\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}