{
  "module_name": "imx-ocotp-scu.c",
  "hash_id": "dfb5585361cfb3f903f41eb9148315dfc70c70f62fb90596ca1ba0ace113053a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/imx-ocotp-scu.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/firmware/imx/sci.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define IMX_SIP_OTP_WRITE\t\t0xc200000B\n\nenum ocotp_devtype {\n\tIMX8QXP,\n\tIMX8QM,\n};\n\n#define ECC_REGION\tBIT(0)\n#define HOLE_REGION\tBIT(1)\n\nstruct ocotp_region {\n\tu32 start;\n\tu32 end;\n\tu32 flag;\n};\n\nstruct ocotp_devtype_data {\n\tint devtype;\n\tint nregs;\n\tu32 num_region;\n\tstruct ocotp_region region[];\n};\n\nstruct ocotp_priv {\n\tstruct device *dev;\n\tconst struct ocotp_devtype_data *data;\n\tstruct imx_sc_ipc *nvmem_ipc;\n};\n\nstruct imx_sc_msg_misc_fuse_read {\n\tstruct imx_sc_rpc_msg hdr;\n\tu32 word;\n} __packed;\n\nstatic DEFINE_MUTEX(scu_ocotp_mutex);\n\nstatic struct ocotp_devtype_data imx8qxp_data = {\n\t.devtype = IMX8QXP,\n\t.nregs = 800,\n\t.num_region = 3,\n\t.region = {\n\t\t{0x10, 0x10f, ECC_REGION},\n\t\t{0x110, 0x21F, HOLE_REGION},\n\t\t{0x220, 0x31F, ECC_REGION},\n\t},\n};\n\nstatic struct ocotp_devtype_data imx8qm_data = {\n\t.devtype = IMX8QM,\n\t.nregs = 800,\n\t.num_region = 2,\n\t.region = {\n\t\t{0x10, 0x10f, ECC_REGION},\n\t\t{0x1a0, 0x1ff, ECC_REGION},\n\t},\n};\n\nstatic bool in_hole(void *context, u32 index)\n{\n\tstruct ocotp_priv *priv = context;\n\tconst struct ocotp_devtype_data *data = priv->data;\n\tint i;\n\n\tfor (i = 0; i < data->num_region; i++) {\n\t\tif (data->region[i].flag & HOLE_REGION) {\n\t\t\tif ((index >= data->region[i].start) &&\n\t\t\t    (index <= data->region[i].end))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool in_ecc(void *context, u32 index)\n{\n\tstruct ocotp_priv *priv = context;\n\tconst struct ocotp_devtype_data *data = priv->data;\n\tint i;\n\n\tfor (i = 0; i < data->num_region; i++) {\n\t\tif (data->region[i].flag & ECC_REGION) {\n\t\t\tif ((index >= data->region[i].start) &&\n\t\t\t    (index <= data->region[i].end))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int imx_sc_misc_otp_fuse_read(struct imx_sc_ipc *ipc, u32 word,\n\t\t\t\t     u32 *val)\n{\n\tstruct imx_sc_msg_misc_fuse_read msg;\n\tstruct imx_sc_rpc_msg *hdr = &msg.hdr;\n\tint ret;\n\n\thdr->ver = IMX_SC_RPC_VERSION;\n\thdr->svc = IMX_SC_RPC_SVC_MISC;\n\thdr->func = IMX_SC_MISC_FUNC_OTP_FUSE_READ;\n\thdr->size = 2;\n\n\tmsg.word = word;\n\n\tret = imx_scu_call_rpc(ipc, &msg, true);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = msg.word;\n\n\treturn 0;\n}\n\nstatic int imx_scu_ocotp_read(void *context, unsigned int offset,\n\t\t\t      void *val, size_t bytes)\n{\n\tstruct ocotp_priv *priv = context;\n\tu32 count, index, num_bytes;\n\tu32 *buf;\n\tvoid *p;\n\tint i, ret;\n\n\tindex = offset;\n\tnum_bytes = round_up(bytes, 4);\n\tcount = num_bytes >> 2;\n\n\tif (count > (priv->data->nregs - index))\n\t\tcount = priv->data->nregs - index;\n\n\tp = kzalloc(num_bytes, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&scu_ocotp_mutex);\n\n\tbuf = p;\n\n\tfor (i = index; i < (index + count); i++) {\n\t\tif (in_hole(context, i)) {\n\t\t\t*buf++ = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = imx_sc_misc_otp_fuse_read(priv->nvmem_ipc, i, buf);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&scu_ocotp_mutex);\n\t\t\tkfree(p);\n\t\t\treturn ret;\n\t\t}\n\t\tbuf++;\n\t}\n\n\tmemcpy(val, (u8 *)p, bytes);\n\n\tmutex_unlock(&scu_ocotp_mutex);\n\n\tkfree(p);\n\n\treturn 0;\n}\n\nstatic int imx_scu_ocotp_write(void *context, unsigned int offset,\n\t\t\t       void *val, size_t bytes)\n{\n\tstruct ocotp_priv *priv = context;\n\tstruct arm_smccc_res res;\n\tu32 *buf = val;\n\tu32 tmp;\n\tu32 index;\n\tint ret;\n\n\t \n\tif (bytes != 4)\n\t\treturn -EINVAL;\n\n\tindex = offset;\n\n\tif (in_hole(context, index))\n\t\treturn -EINVAL;\n\n\tif (in_ecc(context, index)) {\n\t\tpr_warn(\"ECC region, only program once\\n\");\n\t\tmutex_lock(&scu_ocotp_mutex);\n\t\tret = imx_sc_misc_otp_fuse_read(priv->nvmem_ipc, index, &tmp);\n\t\tmutex_unlock(&scu_ocotp_mutex);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (tmp) {\n\t\t\tpr_warn(\"ECC region, already has value: %x\\n\", tmp);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tmutex_lock(&scu_ocotp_mutex);\n\n\tarm_smccc_smc(IMX_SIP_OTP_WRITE, index, *buf, 0, 0, 0, 0, 0, &res);\n\n\tmutex_unlock(&scu_ocotp_mutex);\n\n\treturn res.a0;\n}\n\nstatic struct nvmem_config imx_scu_ocotp_nvmem_config = {\n\t.name = \"imx-scu-ocotp\",\n\t.read_only = false,\n\t.word_size = 4,\n\t.stride = 1,\n\t.owner = THIS_MODULE,\n\t.reg_read = imx_scu_ocotp_read,\n\t.reg_write = imx_scu_ocotp_write,\n};\n\nstatic const struct of_device_id imx_scu_ocotp_dt_ids[] = {\n\t{ .compatible = \"fsl,imx8qxp-scu-ocotp\", (void *)&imx8qxp_data },\n\t{ .compatible = \"fsl,imx8qm-scu-ocotp\", (void *)&imx8qm_data },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, imx_scu_ocotp_dt_ids);\n\nstatic int imx_scu_ocotp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ocotp_priv *priv;\n\tstruct nvmem_device *nvmem;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tret = imx_scu_get_handle(&priv->nvmem_ipc);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->data = of_device_get_match_data(dev);\n\tpriv->dev = dev;\n\timx_scu_ocotp_nvmem_config.size = 4 * priv->data->nregs;\n\timx_scu_ocotp_nvmem_config.dev = dev;\n\timx_scu_ocotp_nvmem_config.priv = priv;\n\tnvmem = devm_nvmem_register(dev, &imx_scu_ocotp_nvmem_config);\n\n\treturn PTR_ERR_OR_ZERO(nvmem);\n}\n\nstatic struct platform_driver imx_scu_ocotp_driver = {\n\t.probe\t= imx_scu_ocotp_probe,\n\t.driver = {\n\t\t.name\t= \"imx_scu_ocotp\",\n\t\t.of_match_table = imx_scu_ocotp_dt_ids,\n\t},\n};\nmodule_platform_driver(imx_scu_ocotp_driver);\n\nMODULE_AUTHOR(\"Peng Fan <peng.fan@nxp.com>\");\nMODULE_DESCRIPTION(\"i.MX8 SCU OCOTP fuse box driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}