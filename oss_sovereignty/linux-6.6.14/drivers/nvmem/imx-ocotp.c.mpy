{
  "module_name": "imx-ocotp.c",
  "hash_id": "0e3d25ccc1a8254625c38deced4cd0d29581c77e880f86074b18787b2037c7e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/imx-ocotp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n\n#define IMX_OCOTP_OFFSET_B0W0\t\t0x400  \n#define IMX_OCOTP_OFFSET_PER_WORD\t0x10   \n\n#define IMX_OCOTP_ADDR_CTRL\t\t0x0000\n#define IMX_OCOTP_ADDR_CTRL_SET\t\t0x0004\n#define IMX_OCOTP_ADDR_CTRL_CLR\t\t0x0008\n#define IMX_OCOTP_ADDR_TIMING\t\t0x0010\n#define IMX_OCOTP_ADDR_DATA0\t\t0x0020\n#define IMX_OCOTP_ADDR_DATA1\t\t0x0030\n#define IMX_OCOTP_ADDR_DATA2\t\t0x0040\n#define IMX_OCOTP_ADDR_DATA3\t\t0x0050\n\n#define IMX_OCOTP_BM_CTRL_ADDR\t\t0x000000FF\n#define IMX_OCOTP_BM_CTRL_BUSY\t\t0x00000100\n#define IMX_OCOTP_BM_CTRL_ERROR\t\t0x00000200\n#define IMX_OCOTP_BM_CTRL_REL_SHADOWS\t0x00000400\n\n#define IMX_OCOTP_BM_CTRL_ADDR_8MP\t\t0x000001FF\n#define IMX_OCOTP_BM_CTRL_BUSY_8MP\t\t0x00000200\n#define IMX_OCOTP_BM_CTRL_ERROR_8MP\t\t0x00000400\n#define IMX_OCOTP_BM_CTRL_REL_SHADOWS_8MP\t0x00000800\n\n#define IMX_OCOTP_BM_CTRL_DEFAULT\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.bm_addr = IMX_OCOTP_BM_CTRL_ADDR,\t\t\\\n\t\t.bm_busy = IMX_OCOTP_BM_CTRL_BUSY,\t\t\\\n\t\t.bm_error = IMX_OCOTP_BM_CTRL_ERROR,\t\t\\\n\t\t.bm_rel_shadows = IMX_OCOTP_BM_CTRL_REL_SHADOWS,\\\n\t}\n\n#define IMX_OCOTP_BM_CTRL_8MP\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.bm_addr = IMX_OCOTP_BM_CTRL_ADDR_8MP,\t\t\\\n\t\t.bm_busy = IMX_OCOTP_BM_CTRL_BUSY_8MP,\t\t\\\n\t\t.bm_error = IMX_OCOTP_BM_CTRL_ERROR_8MP,\t\\\n\t\t.bm_rel_shadows = IMX_OCOTP_BM_CTRL_REL_SHADOWS_8MP,\\\n\t}\n\n#define TIMING_STROBE_PROG_US\t\t10\t \n#define TIMING_STROBE_READ_NS\t\t37\t \n#define TIMING_RELAX_NS\t\t\t17\n#define DEF_FSOURCE\t\t\t1001\t \n#define DEF_STROBE_PROG\t\t\t10000\t \n#define IMX_OCOTP_WR_UNLOCK\t\t0x3E770000\n#define IMX_OCOTP_READ_LOCKED_VAL\t0xBADABADA\n\nstatic DEFINE_MUTEX(ocotp_mutex);\n\nstruct ocotp_priv {\n\tstruct device *dev;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tconst struct ocotp_params *params;\n\tstruct nvmem_config *config;\n};\n\nstruct ocotp_ctrl_reg {\n\tu32 bm_addr;\n\tu32 bm_busy;\n\tu32 bm_error;\n\tu32 bm_rel_shadows;\n};\n\nstruct ocotp_params {\n\tunsigned int nregs;\n\tunsigned int bank_address_words;\n\tvoid (*set_timing)(struct ocotp_priv *priv);\n\tstruct ocotp_ctrl_reg ctrl;\n};\n\nstatic int imx_ocotp_wait_for_busy(struct ocotp_priv *priv, u32 flags)\n{\n\tint count;\n\tu32 c, mask;\n\tu32 bm_ctrl_busy, bm_ctrl_error;\n\tvoid __iomem *base = priv->base;\n\n\tbm_ctrl_busy = priv->params->ctrl.bm_busy;\n\tbm_ctrl_error = priv->params->ctrl.bm_error;\n\n\tmask = bm_ctrl_busy | bm_ctrl_error | flags;\n\n\tfor (count = 10000; count >= 0; count--) {\n\t\tc = readl(base + IMX_OCOTP_ADDR_CTRL);\n\t\tif (!(c & mask))\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\n\tif (count < 0) {\n\t\t \n\t\tif (c & bm_ctrl_error)\n\t\t\treturn -EPERM;\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void imx_ocotp_clr_err_if_set(struct ocotp_priv *priv)\n{\n\tu32 c, bm_ctrl_error;\n\tvoid __iomem *base = priv->base;\n\n\tbm_ctrl_error = priv->params->ctrl.bm_error;\n\n\tc = readl(base + IMX_OCOTP_ADDR_CTRL);\n\tif (!(c & bm_ctrl_error))\n\t\treturn;\n\n\twritel(bm_ctrl_error, base + IMX_OCOTP_ADDR_CTRL_CLR);\n}\n\nstatic int imx_ocotp_read(void *context, unsigned int offset,\n\t\t\t  void *val, size_t bytes)\n{\n\tstruct ocotp_priv *priv = context;\n\tunsigned int count;\n\tu8 *buf, *p;\n\tint i, ret;\n\tu32 index, num_bytes;\n\n\tindex = offset >> 2;\n\tnum_bytes = round_up((offset % 4) + bytes, 4);\n\tcount = num_bytes >> 2;\n\n\tif (count > (priv->params->nregs - index))\n\t\tcount = priv->params->nregs - index;\n\n\tp = kzalloc(num_bytes, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ocotp_mutex);\n\n\tbuf = p;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret < 0) {\n\t\tmutex_unlock(&ocotp_mutex);\n\t\tdev_err(priv->dev, \"failed to prepare/enable ocotp clk\\n\");\n\t\tkfree(p);\n\t\treturn ret;\n\t}\n\n\tret = imx_ocotp_wait_for_busy(priv, 0);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"timeout during read setup\\n\");\n\t\tgoto read_end;\n\t}\n\n\tfor (i = index; i < (index + count); i++) {\n\t\t*(u32 *)buf = readl(priv->base + IMX_OCOTP_OFFSET_B0W0 +\n\t\t\t       i * IMX_OCOTP_OFFSET_PER_WORD);\n\n\t\t \n\t\tif (*((u32 *)buf) == IMX_OCOTP_READ_LOCKED_VAL)\n\t\t\timx_ocotp_clr_err_if_set(priv);\n\n\t\tbuf += 4;\n\t}\n\n\tindex = offset % 4;\n\tmemcpy(val, &p[index], bytes);\n\nread_end:\n\tclk_disable_unprepare(priv->clk);\n\tmutex_unlock(&ocotp_mutex);\n\n\tkfree(p);\n\n\treturn ret;\n}\n\nstatic int imx_ocotp_cell_pp(void *context, const char *id, int index,\n\t\t\t     unsigned int offset, void *data, size_t bytes)\n{\n\tu8 *buf = data;\n\tint i;\n\n\t \n\tif (id && !strcmp(id, \"mac-address\"))\n\t\tfor (i = 0; i < bytes / 2; i++)\n\t\t\tswap(buf[i], buf[bytes - i - 1]);\n\n\treturn 0;\n}\n\nstatic void imx_ocotp_set_imx6_timing(struct ocotp_priv *priv)\n{\n\tunsigned long clk_rate;\n\tunsigned long strobe_read, relax, strobe_prog;\n\tu32 timing;\n\n\t \n\tclk_rate = clk_get_rate(priv->clk);\n\n\trelax = DIV_ROUND_UP(clk_rate * TIMING_RELAX_NS, 1000000000) - 1;\n\tstrobe_read = DIV_ROUND_UP(clk_rate * TIMING_STROBE_READ_NS,\n\t\t\t\t   1000000000);\n\tstrobe_read += 2 * (relax + 1) - 1;\n\tstrobe_prog = DIV_ROUND_CLOSEST(clk_rate * TIMING_STROBE_PROG_US,\n\t\t\t\t\t1000000);\n\tstrobe_prog += 2 * (relax + 1) - 1;\n\n\ttiming = readl(priv->base + IMX_OCOTP_ADDR_TIMING) & 0x0FC00000;\n\ttiming |= strobe_prog & 0x00000FFF;\n\ttiming |= (relax       << 12) & 0x0000F000;\n\ttiming |= (strobe_read << 16) & 0x003F0000;\n\n\twritel(timing, priv->base + IMX_OCOTP_ADDR_TIMING);\n}\n\nstatic void imx_ocotp_set_imx7_timing(struct ocotp_priv *priv)\n{\n\tunsigned long clk_rate;\n\tu64 fsource, strobe_prog;\n\tu32 timing;\n\n\t \n\tclk_rate = clk_get_rate(priv->clk);\n\tfsource = DIV_ROUND_UP_ULL((u64)clk_rate * DEF_FSOURCE,\n\t\t\t\t   NSEC_PER_SEC) + 1;\n\tstrobe_prog = DIV_ROUND_CLOSEST_ULL((u64)clk_rate * DEF_STROBE_PROG,\n\t\t\t\t\t    NSEC_PER_SEC) + 1;\n\n\ttiming = strobe_prog & 0x00000FFF;\n\ttiming |= (fsource << 12) & 0x000FF000;\n\n\twritel(timing, priv->base + IMX_OCOTP_ADDR_TIMING);\n}\n\nstatic int imx_ocotp_write(void *context, unsigned int offset, void *val,\n\t\t\t   size_t bytes)\n{\n\tstruct ocotp_priv *priv = context;\n\tu32 *buf = val;\n\tint ret;\n\n\tu32 ctrl;\n\tu8 waddr;\n\tu8 word = 0;\n\n\t \n\tif ((bytes != priv->config->word_size) ||\n\t    (offset % priv->config->word_size))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ocotp_mutex);\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret < 0) {\n\t\tmutex_unlock(&ocotp_mutex);\n\t\tdev_err(priv->dev, \"failed to prepare/enable ocotp clk\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tpriv->params->set_timing(priv);\n\n\t \n\tret = imx_ocotp_wait_for_busy(priv, 0);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"timeout during timing setup\\n\");\n\t\tgoto write_end;\n\t}\n\n\t \n\tif (priv->params->bank_address_words != 0) {\n\t\t \n\t\toffset = offset / priv->config->word_size;\n\t\twaddr = offset / priv->params->bank_address_words;\n\t\tword  = offset & (priv->params->bank_address_words - 1);\n\t} else {\n\t\t \n\t\twaddr = offset / 4;\n\t}\n\n\tctrl = readl(priv->base + IMX_OCOTP_ADDR_CTRL);\n\tctrl &= ~priv->params->ctrl.bm_addr;\n\tctrl |= waddr & priv->params->ctrl.bm_addr;\n\tctrl |= IMX_OCOTP_WR_UNLOCK;\n\n\twritel(ctrl, priv->base + IMX_OCOTP_ADDR_CTRL);\n\n\t \n\tif (priv->params->bank_address_words != 0) {\n\t\t \n\t\tswitch (word) {\n\t\tcase 0:\n\t\t\twritel(0, priv->base + IMX_OCOTP_ADDR_DATA1);\n\t\t\twritel(0, priv->base + IMX_OCOTP_ADDR_DATA2);\n\t\t\twritel(0, priv->base + IMX_OCOTP_ADDR_DATA3);\n\t\t\twritel(*buf, priv->base + IMX_OCOTP_ADDR_DATA0);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\twritel(*buf, priv->base + IMX_OCOTP_ADDR_DATA1);\n\t\t\twritel(0, priv->base + IMX_OCOTP_ADDR_DATA2);\n\t\t\twritel(0, priv->base + IMX_OCOTP_ADDR_DATA3);\n\t\t\twritel(0, priv->base + IMX_OCOTP_ADDR_DATA0);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\twritel(0, priv->base + IMX_OCOTP_ADDR_DATA1);\n\t\t\twritel(*buf, priv->base + IMX_OCOTP_ADDR_DATA2);\n\t\t\twritel(0, priv->base + IMX_OCOTP_ADDR_DATA3);\n\t\t\twritel(0, priv->base + IMX_OCOTP_ADDR_DATA0);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\twritel(0, priv->base + IMX_OCOTP_ADDR_DATA1);\n\t\t\twritel(0, priv->base + IMX_OCOTP_ADDR_DATA2);\n\t\t\twritel(*buf, priv->base + IMX_OCOTP_ADDR_DATA3);\n\t\t\twritel(0, priv->base + IMX_OCOTP_ADDR_DATA0);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\twritel(*buf, priv->base + IMX_OCOTP_ADDR_DATA0);\n\t}\n\n\t \n\tret = imx_ocotp_wait_for_busy(priv, 0);\n\tif (ret < 0) {\n\t\tif (ret == -EPERM) {\n\t\t\tdev_err(priv->dev, \"failed write to locked region\");\n\t\t\timx_ocotp_clr_err_if_set(priv);\n\t\t} else {\n\t\t\tdev_err(priv->dev, \"timeout during data write\\n\");\n\t\t}\n\t\tgoto write_end;\n\t}\n\n\t \n\tudelay(2);\n\n\t \n\twritel(priv->params->ctrl.bm_rel_shadows,\n\t       priv->base + IMX_OCOTP_ADDR_CTRL_SET);\n\tret = imx_ocotp_wait_for_busy(priv,\n\t\t\t\t      priv->params->ctrl.bm_rel_shadows);\n\tif (ret < 0)\n\t\tdev_err(priv->dev, \"timeout during shadow register reload\\n\");\n\nwrite_end:\n\tclk_disable_unprepare(priv->clk);\n\tmutex_unlock(&ocotp_mutex);\n\treturn ret < 0 ? ret : bytes;\n}\n\nstatic struct nvmem_config imx_ocotp_nvmem_config = {\n\t.name = \"imx-ocotp\",\n\t.read_only = false,\n\t.word_size = 4,\n\t.stride = 1,\n\t.reg_read = imx_ocotp_read,\n\t.reg_write = imx_ocotp_write,\n};\n\nstatic const struct ocotp_params imx6q_params = {\n\t.nregs = 128,\n\t.bank_address_words = 0,\n\t.set_timing = imx_ocotp_set_imx6_timing,\n\t.ctrl = IMX_OCOTP_BM_CTRL_DEFAULT,\n};\n\nstatic const struct ocotp_params imx6sl_params = {\n\t.nregs = 64,\n\t.bank_address_words = 0,\n\t.set_timing = imx_ocotp_set_imx6_timing,\n\t.ctrl = IMX_OCOTP_BM_CTRL_DEFAULT,\n};\n\nstatic const struct ocotp_params imx6sll_params = {\n\t.nregs = 80,\n\t.bank_address_words = 0,\n\t.set_timing = imx_ocotp_set_imx6_timing,\n\t.ctrl = IMX_OCOTP_BM_CTRL_DEFAULT,\n};\n\nstatic const struct ocotp_params imx6sx_params = {\n\t.nregs = 128,\n\t.bank_address_words = 0,\n\t.set_timing = imx_ocotp_set_imx6_timing,\n\t.ctrl = IMX_OCOTP_BM_CTRL_DEFAULT,\n};\n\nstatic const struct ocotp_params imx6ul_params = {\n\t.nregs = 144,\n\t.bank_address_words = 0,\n\t.set_timing = imx_ocotp_set_imx6_timing,\n\t.ctrl = IMX_OCOTP_BM_CTRL_DEFAULT,\n};\n\nstatic const struct ocotp_params imx6ull_params = {\n\t.nregs = 80,\n\t.bank_address_words = 0,\n\t.set_timing = imx_ocotp_set_imx6_timing,\n\t.ctrl = IMX_OCOTP_BM_CTRL_DEFAULT,\n};\n\nstatic const struct ocotp_params imx7d_params = {\n\t.nregs = 64,\n\t.bank_address_words = 4,\n\t.set_timing = imx_ocotp_set_imx7_timing,\n\t.ctrl = IMX_OCOTP_BM_CTRL_DEFAULT,\n};\n\nstatic const struct ocotp_params imx7ulp_params = {\n\t.nregs = 256,\n\t.bank_address_words = 0,\n\t.ctrl = IMX_OCOTP_BM_CTRL_DEFAULT,\n};\n\nstatic const struct ocotp_params imx8mq_params = {\n\t.nregs = 256,\n\t.bank_address_words = 0,\n\t.set_timing = imx_ocotp_set_imx6_timing,\n\t.ctrl = IMX_OCOTP_BM_CTRL_DEFAULT,\n};\n\nstatic const struct ocotp_params imx8mm_params = {\n\t.nregs = 256,\n\t.bank_address_words = 0,\n\t.set_timing = imx_ocotp_set_imx6_timing,\n\t.ctrl = IMX_OCOTP_BM_CTRL_DEFAULT,\n};\n\nstatic const struct ocotp_params imx8mn_params = {\n\t.nregs = 256,\n\t.bank_address_words = 0,\n\t.set_timing = imx_ocotp_set_imx6_timing,\n\t.ctrl = IMX_OCOTP_BM_CTRL_DEFAULT,\n};\n\nstatic const struct ocotp_params imx8mp_params = {\n\t.nregs = 384,\n\t.bank_address_words = 0,\n\t.set_timing = imx_ocotp_set_imx6_timing,\n\t.ctrl = IMX_OCOTP_BM_CTRL_8MP,\n};\n\nstatic const struct of_device_id imx_ocotp_dt_ids[] = {\n\t{ .compatible = \"fsl,imx6q-ocotp\",  .data = &imx6q_params },\n\t{ .compatible = \"fsl,imx6sl-ocotp\", .data = &imx6sl_params },\n\t{ .compatible = \"fsl,imx6sx-ocotp\", .data = &imx6sx_params },\n\t{ .compatible = \"fsl,imx6ul-ocotp\", .data = &imx6ul_params },\n\t{ .compatible = \"fsl,imx6ull-ocotp\", .data = &imx6ull_params },\n\t{ .compatible = \"fsl,imx7d-ocotp\",  .data = &imx7d_params },\n\t{ .compatible = \"fsl,imx6sll-ocotp\", .data = &imx6sll_params },\n\t{ .compatible = \"fsl,imx7ulp-ocotp\", .data = &imx7ulp_params },\n\t{ .compatible = \"fsl,imx8mq-ocotp\", .data = &imx8mq_params },\n\t{ .compatible = \"fsl,imx8mm-ocotp\", .data = &imx8mm_params },\n\t{ .compatible = \"fsl,imx8mn-ocotp\", .data = &imx8mn_params },\n\t{ .compatible = \"fsl,imx8mp-ocotp\", .data = &imx8mp_params },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, imx_ocotp_dt_ids);\n\nstatic void imx_ocotp_fixup_cell_info(struct nvmem_device *nvmem,\n\t\t\t\t      struct nvmem_layout *layout,\n\t\t\t\t      struct nvmem_cell_info *cell)\n{\n\tcell->read_post_process = imx_ocotp_cell_pp;\n}\n\nstatic struct nvmem_layout imx_ocotp_layout = {\n\t.fixup_cell_info = imx_ocotp_fixup_cell_info,\n};\n\nstatic int imx_ocotp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ocotp_priv *priv;\n\tstruct nvmem_device *nvmem;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\tpriv->params = of_device_get_match_data(&pdev->dev);\n\timx_ocotp_nvmem_config.size = 4 * priv->params->nregs;\n\timx_ocotp_nvmem_config.dev = dev;\n\timx_ocotp_nvmem_config.priv = priv;\n\timx_ocotp_nvmem_config.layout = &imx_ocotp_layout;\n\n\tpriv->config = &imx_ocotp_nvmem_config;\n\n\tclk_prepare_enable(priv->clk);\n\timx_ocotp_clr_err_if_set(priv);\n\tclk_disable_unprepare(priv->clk);\n\n\tnvmem = devm_nvmem_register(dev, &imx_ocotp_nvmem_config);\n\n\treturn PTR_ERR_OR_ZERO(nvmem);\n}\n\nstatic struct platform_driver imx_ocotp_driver = {\n\t.probe\t= imx_ocotp_probe,\n\t.driver = {\n\t\t.name\t= \"imx_ocotp\",\n\t\t.of_match_table = imx_ocotp_dt_ids,\n\t},\n};\nmodule_platform_driver(imx_ocotp_driver);\n\nMODULE_AUTHOR(\"Philipp Zabel <p.zabel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"i.MX6/i.MX7 OCOTP fuse box driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}