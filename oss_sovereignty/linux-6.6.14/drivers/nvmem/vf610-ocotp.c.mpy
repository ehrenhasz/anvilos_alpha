{
  "module_name": "vf610-ocotp.c",
  "hash_id": "4f3503f54dc1878cf9a22f4c0354dc7d916071f562f1127f381da02d32ee88af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/vf610-ocotp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n \n#define OCOTP_CTRL_REG\t\t\t\t0x00\n#define OCOTP_CTRL_SET\t\t\t\t0x04\n#define OCOTP_CTRL_CLR\t\t\t\t0x08\n#define OCOTP_TIMING\t\t\t\t0x10\n#define OCOTP_DATA\t\t\t\t0x20\n#define OCOTP_READ_CTRL_REG\t\t\t0x30\n#define OCOTP_READ_FUSE_DATA\t\t\t0x40\n\n \n#define OCOTP_CTRL_WR_UNLOCK\t\t\t16\n#define OCOTP_CTRL_WR_UNLOCK_KEY\t\t0x3E77\n#define OCOTP_CTRL_WR_UNLOCK_MASK\t\tGENMASK(31, 16)\n#define OCOTP_CTRL_ADDR\t\t\t\t0\n#define OCOTP_CTRL_ADDR_MASK\t\t\tGENMASK(6, 0)\n#define OCOTP_CTRL_RELOAD_SHADOWS\t\tBIT(10)\n#define OCOTP_CTRL_ERR\t\t\t\tBIT(9)\n#define OCOTP_CTRL_BUSY\t\t\t\tBIT(8)\n\n#define OCOTP_TIMING_STROBE_READ\t\t16\n#define OCOTP_TIMING_STROBE_READ_MASK\t\tGENMASK(21, 16)\n#define OCOTP_TIMING_RELAX\t\t\t12\n#define OCOTP_TIMING_RELAX_MASK\t\t\tGENMASK(15, 12)\n#define OCOTP_TIMING_STROBE_PROG\t\t0\n#define OCOTP_TIMING_STROBE_PROG_MASK\t\tGENMASK(11, 0)\n\n#define OCOTP_READ_CTRL_READ_FUSE\t\t0x1\n\n#define VF610_OCOTP_TIMEOUT\t\t\t100000\n\n#define BF(value, field)\t\t(((value) << field) & field##_MASK)\n\n#define DEF_RELAX\t\t\t\t20\n\nstatic const int base_to_fuse_addr_mappings[][2] = {\n\t{0x400, 0x00},\n\t{0x410, 0x01},\n\t{0x420, 0x02},\n\t{0x450, 0x05},\n\t{0x4F0, 0x0F},\n\t{0x600, 0x20},\n\t{0x610, 0x21},\n\t{0x620, 0x22},\n\t{0x630, 0x23},\n\t{0x640, 0x24},\n\t{0x650, 0x25},\n\t{0x660, 0x26},\n\t{0x670, 0x27},\n\t{0x6F0, 0x2F},\n\t{0x880, 0x38},\n\t{0x890, 0x39},\n\t{0x8A0, 0x3A},\n\t{0x8B0, 0x3B},\n\t{0x8C0, 0x3C},\n\t{0x8D0, 0x3D},\n\t{0x8E0, 0x3E},\n\t{0x8F0, 0x3F},\n\t{0xC80, 0x78},\n\t{0xC90, 0x79},\n\t{0xCA0, 0x7A},\n\t{0xCB0, 0x7B},\n\t{0xCC0, 0x7C},\n\t{0xCD0, 0x7D},\n\t{0xCE0, 0x7E},\n\t{0xCF0, 0x7F},\n};\n\nstruct vf610_ocotp {\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct device *dev;\n\tstruct nvmem_device *nvmem;\n\tint timing;\n};\n\nstatic int vf610_ocotp_wait_busy(void __iomem *base)\n{\n\tint timeout = VF610_OCOTP_TIMEOUT;\n\n\twhile ((readl(base) & OCOTP_CTRL_BUSY) && --timeout)\n\t\tudelay(10);\n\n\tif (!timeout) {\n\t\twritel(OCOTP_CTRL_ERR, base + OCOTP_CTRL_CLR);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tudelay(10);\n\n\treturn 0;\n}\n\nstatic int vf610_ocotp_calculate_timing(struct vf610_ocotp *ocotp_dev)\n{\n\tu32 clk_rate;\n\tu32 relax, strobe_read, strobe_prog;\n\tu32 timing;\n\n\tclk_rate = clk_get_rate(ocotp_dev->clk);\n\n\t \n\trelax = clk_rate / (1000000000 / DEF_RELAX) - 1;\n\tstrobe_prog = clk_rate / (1000000000 / 10000) + 2 * (DEF_RELAX + 1) - 1;\n\tstrobe_read = clk_rate / (1000000000 / 40) + 2 * (DEF_RELAX + 1) - 1;\n\n\ttiming = BF(relax, OCOTP_TIMING_RELAX);\n\ttiming |= BF(strobe_read, OCOTP_TIMING_STROBE_READ);\n\ttiming |= BF(strobe_prog, OCOTP_TIMING_STROBE_PROG);\n\n\treturn timing;\n}\n\nstatic int vf610_get_fuse_address(int base_addr_offset)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(base_to_fuse_addr_mappings); i++) {\n\t\tif (base_to_fuse_addr_mappings[i][0] == base_addr_offset)\n\t\t\treturn base_to_fuse_addr_mappings[i][1];\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int vf610_ocotp_read(void *context, unsigned int offset,\n\t\t\tvoid *val, size_t bytes)\n{\n\tstruct vf610_ocotp *ocotp = context;\n\tvoid __iomem *base = ocotp->base;\n\tu32 reg, *buf = val;\n\tint fuse_addr;\n\tint ret;\n\n\twhile (bytes > 0) {\n\t\tfuse_addr = vf610_get_fuse_address(offset);\n\t\tif (fuse_addr > 0) {\n\t\t\twritel(ocotp->timing, base + OCOTP_TIMING);\n\t\t\tret = vf610_ocotp_wait_busy(base + OCOTP_CTRL_REG);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\treg = readl(base + OCOTP_CTRL_REG);\n\t\t\treg &= ~OCOTP_CTRL_ADDR_MASK;\n\t\t\treg &= ~OCOTP_CTRL_WR_UNLOCK_MASK;\n\t\t\treg |= BF(fuse_addr, OCOTP_CTRL_ADDR);\n\t\t\twritel(reg, base + OCOTP_CTRL_REG);\n\n\t\t\twritel(OCOTP_READ_CTRL_READ_FUSE,\n\t\t\t\tbase + OCOTP_READ_CTRL_REG);\n\t\t\tret = vf610_ocotp_wait_busy(base + OCOTP_CTRL_REG);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (readl(base) & OCOTP_CTRL_ERR) {\n\t\t\t\tdev_dbg(ocotp->dev, \"Error reading from fuse address %x\\n\",\n\t\t\t\t\tfuse_addr);\n\t\t\t\twritel(OCOTP_CTRL_ERR, base + OCOTP_CTRL_CLR);\n\t\t\t}\n\n\t\t\t \n\t\t\t*buf = readl(base + OCOTP_READ_FUSE_DATA);\n\t\t} else {\n\t\t\t*buf = 0;\n\t\t}\n\n\t\tbuf++;\n\t\tbytes -= 4;\n\t\toffset += 4;\n\t}\n\n\treturn 0;\n}\n\nstatic struct nvmem_config ocotp_config = {\n\t.name = \"ocotp\",\n\t.stride = 4,\n\t.word_size = 4,\n\t.reg_read = vf610_ocotp_read,\n};\n\nstatic const struct of_device_id ocotp_of_match[] = {\n\t{ .compatible = \"fsl,vf610-ocotp\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ocotp_of_match);\n\nstatic int vf610_ocotp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tstruct vf610_ocotp *ocotp_dev;\n\n\tocotp_dev = devm_kzalloc(dev, sizeof(struct vf610_ocotp), GFP_KERNEL);\n\tif (!ocotp_dev)\n\t\treturn -ENOMEM;\n\n\tocotp_dev->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(ocotp_dev->base))\n\t\treturn PTR_ERR(ocotp_dev->base);\n\n\tocotp_dev->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(ocotp_dev->clk)) {\n\t\tdev_err(dev, \"failed getting clock, err = %ld\\n\",\n\t\t\tPTR_ERR(ocotp_dev->clk));\n\t\treturn PTR_ERR(ocotp_dev->clk);\n\t}\n\tocotp_dev->dev = dev;\n\tocotp_dev->timing = vf610_ocotp_calculate_timing(ocotp_dev);\n\n\tocotp_config.size = resource_size(res);\n\tocotp_config.priv = ocotp_dev;\n\tocotp_config.dev = dev;\n\n\tocotp_dev->nvmem = devm_nvmem_register(dev, &ocotp_config);\n\n\treturn PTR_ERR_OR_ZERO(ocotp_dev->nvmem);\n}\n\nstatic struct platform_driver vf610_ocotp_driver = {\n\t.probe = vf610_ocotp_probe,\n\t.driver = {\n\t\t.name = \"vf610-ocotp\",\n\t\t.of_match_table = ocotp_of_match,\n\t},\n};\nmodule_platform_driver(vf610_ocotp_driver);\nMODULE_AUTHOR(\"Sanchayan Maity <sanchayan.maity@toradex.com>\");\nMODULE_DESCRIPTION(\"Vybrid OCOTP driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}