{
  "module_name": "rockchip-otp.c",
  "hash_id": "8243329c587597e2f4b8c52eb138616532be0f61a8d6675e09c99b13f23344a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/rockchip-otp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n \n#define OTPC_SBPI_CTRL\t\t\t0x0020\n#define OTPC_SBPI_CMD_VALID_PRE\t\t0x0024\n#define OTPC_SBPI_CS_VALID_PRE\t\t0x0028\n#define OTPC_SBPI_STATUS\t\t0x002C\n#define OTPC_USER_CTRL\t\t\t0x0100\n#define OTPC_USER_ADDR\t\t\t0x0104\n#define OTPC_USER_ENABLE\t\t0x0108\n#define OTPC_USER_Q\t\t\t0x0124\n#define OTPC_INT_STATUS\t\t\t0x0304\n#define OTPC_SBPI_CMD0_OFFSET\t\t0x1000\n#define OTPC_SBPI_CMD1_OFFSET\t\t0x1004\n\n \n#define OTPC_USER_ADDR_MASK\t\tGENMASK(31, 16)\n#define OTPC_USE_USER\t\t\tBIT(0)\n#define OTPC_USE_USER_MASK\t\tGENMASK(16, 16)\n#define OTPC_USER_FSM_ENABLE\t\tBIT(0)\n#define OTPC_USER_FSM_ENABLE_MASK\tGENMASK(16, 16)\n#define OTPC_SBPI_DONE\t\t\tBIT(1)\n#define OTPC_USER_DONE\t\t\tBIT(2)\n\n#define SBPI_DAP_ADDR\t\t\t0x02\n#define SBPI_DAP_ADDR_SHIFT\t\t8\n#define SBPI_DAP_ADDR_MASK\t\tGENMASK(31, 24)\n#define SBPI_CMD_VALID_MASK\t\tGENMASK(31, 16)\n#define SBPI_DAP_CMD_WRF\t\t0xC0\n#define SBPI_DAP_REG_ECC\t\t0x3A\n#define SBPI_ECC_ENABLE\t\t\t0x00\n#define SBPI_ECC_DISABLE\t\t0x09\n#define SBPI_ENABLE\t\t\tBIT(0)\n#define SBPI_ENABLE_MASK\t\tGENMASK(16, 16)\n\n#define OTPC_TIMEOUT\t\t\t10000\n\n \n#define RK3588_OTPC_AUTO_CTRL\t\t0x04\n#define RK3588_OTPC_AUTO_EN\t\t0x08\n#define RK3588_OTPC_INT_ST\t\t0x84\n#define RK3588_OTPC_DOUT0\t\t0x20\n#define RK3588_NO_SECURE_OFFSET\t\t0x300\n#define RK3588_NBYTES\t\t\t4\n#define RK3588_BURST_NUM\t\t1\n#define RK3588_BURST_SHIFT\t\t8\n#define RK3588_ADDR_SHIFT\t\t16\n#define RK3588_AUTO_EN\t\t\tBIT(0)\n#define RK3588_RD_DONE\t\t\tBIT(1)\n\nstruct rockchip_data {\n\tint size;\n\tconst char * const *clks;\n\tint num_clks;\n\tnvmem_reg_read_t reg_read;\n};\n\nstruct rockchip_otp {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct clk_bulk_data *clks;\n\tstruct reset_control *rst;\n\tconst struct rockchip_data *data;\n};\n\nstatic int rockchip_otp_reset(struct rockchip_otp *otp)\n{\n\tint ret;\n\n\tret = reset_control_assert(otp->rst);\n\tif (ret) {\n\t\tdev_err(otp->dev, \"failed to assert otp phy %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tudelay(2);\n\n\tret = reset_control_deassert(otp->rst);\n\tif (ret) {\n\t\tdev_err(otp->dev, \"failed to deassert otp phy %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_otp_wait_status(struct rockchip_otp *otp,\n\t\t\t\t    unsigned int reg, u32 flag)\n{\n\tu32 status = 0;\n\tint ret;\n\n\tret = readl_poll_timeout_atomic(otp->base + reg, status,\n\t\t\t\t\t(status & flag), 1, OTPC_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(flag, otp->base + reg);\n\n\treturn 0;\n}\n\nstatic int rockchip_otp_ecc_enable(struct rockchip_otp *otp, bool enable)\n{\n\tint ret = 0;\n\n\twritel(SBPI_DAP_ADDR_MASK | (SBPI_DAP_ADDR << SBPI_DAP_ADDR_SHIFT),\n\t       otp->base + OTPC_SBPI_CTRL);\n\n\twritel(SBPI_CMD_VALID_MASK | 0x1, otp->base + OTPC_SBPI_CMD_VALID_PRE);\n\twritel(SBPI_DAP_CMD_WRF | SBPI_DAP_REG_ECC,\n\t       otp->base + OTPC_SBPI_CMD0_OFFSET);\n\tif (enable)\n\t\twritel(SBPI_ECC_ENABLE, otp->base + OTPC_SBPI_CMD1_OFFSET);\n\telse\n\t\twritel(SBPI_ECC_DISABLE, otp->base + OTPC_SBPI_CMD1_OFFSET);\n\n\twritel(SBPI_ENABLE_MASK | SBPI_ENABLE, otp->base + OTPC_SBPI_CTRL);\n\n\tret = rockchip_otp_wait_status(otp, OTPC_INT_STATUS, OTPC_SBPI_DONE);\n\tif (ret < 0)\n\t\tdev_err(otp->dev, \"timeout during ecc_enable\\n\");\n\n\treturn ret;\n}\n\nstatic int px30_otp_read(void *context, unsigned int offset,\n\t\t\t void *val, size_t bytes)\n{\n\tstruct rockchip_otp *otp = context;\n\tu8 *buf = val;\n\tint ret;\n\n\tret = rockchip_otp_reset(otp);\n\tif (ret) {\n\t\tdev_err(otp->dev, \"failed to reset otp phy\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rockchip_otp_ecc_enable(otp, false);\n\tif (ret < 0) {\n\t\tdev_err(otp->dev, \"rockchip_otp_ecc_enable err\\n\");\n\t\treturn ret;\n\t}\n\n\twritel(OTPC_USE_USER | OTPC_USE_USER_MASK, otp->base + OTPC_USER_CTRL);\n\tudelay(5);\n\twhile (bytes--) {\n\t\twritel(offset++ | OTPC_USER_ADDR_MASK,\n\t\t       otp->base + OTPC_USER_ADDR);\n\t\twritel(OTPC_USER_FSM_ENABLE | OTPC_USER_FSM_ENABLE_MASK,\n\t\t       otp->base + OTPC_USER_ENABLE);\n\t\tret = rockchip_otp_wait_status(otp, OTPC_INT_STATUS, OTPC_USER_DONE);\n\t\tif (ret < 0) {\n\t\t\tdev_err(otp->dev, \"timeout during read setup\\n\");\n\t\t\tgoto read_end;\n\t\t}\n\t\t*buf++ = readb(otp->base + OTPC_USER_Q);\n\t}\n\nread_end:\n\twritel(0x0 | OTPC_USE_USER_MASK, otp->base + OTPC_USER_CTRL);\n\n\treturn ret;\n}\n\nstatic int rk3588_otp_read(void *context, unsigned int offset,\n\t\t\t   void *val, size_t bytes)\n{\n\tstruct rockchip_otp *otp = context;\n\tunsigned int addr_start, addr_end, addr_len;\n\tint ret, i = 0;\n\tu32 data;\n\tu8 *buf;\n\n\taddr_start = round_down(offset, RK3588_NBYTES) / RK3588_NBYTES;\n\taddr_end = round_up(offset + bytes, RK3588_NBYTES) / RK3588_NBYTES;\n\taddr_len = addr_end - addr_start;\n\taddr_start += RK3588_NO_SECURE_OFFSET;\n\n\tbuf = kzalloc(array_size(addr_len, RK3588_NBYTES), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile (addr_len--) {\n\t\twritel((addr_start << RK3588_ADDR_SHIFT) |\n\t\t       (RK3588_BURST_NUM << RK3588_BURST_SHIFT),\n\t\t       otp->base + RK3588_OTPC_AUTO_CTRL);\n\t\twritel(RK3588_AUTO_EN, otp->base + RK3588_OTPC_AUTO_EN);\n\n\t\tret = rockchip_otp_wait_status(otp, RK3588_OTPC_INT_ST,\n\t\t\t\t\t       RK3588_RD_DONE);\n\t\tif (ret < 0) {\n\t\t\tdev_err(otp->dev, \"timeout during read setup\\n\");\n\t\t\tgoto read_end;\n\t\t}\n\n\t\tdata = readl(otp->base + RK3588_OTPC_DOUT0);\n\t\tmemcpy(&buf[i], &data, RK3588_NBYTES);\n\n\t\ti += RK3588_NBYTES;\n\t\taddr_start++;\n\t}\n\n\tmemcpy(val, buf + offset % RK3588_NBYTES, bytes);\n\nread_end:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int rockchip_otp_read(void *context, unsigned int offset,\n\t\t\t     void *val, size_t bytes)\n{\n\tstruct rockchip_otp *otp = context;\n\tint ret;\n\n\tif (!otp->data || !otp->data->reg_read)\n\t\treturn -EINVAL;\n\n\tret = clk_bulk_prepare_enable(otp->data->num_clks, otp->clks);\n\tif (ret < 0) {\n\t\tdev_err(otp->dev, \"failed to prepare/enable clks\\n\");\n\t\treturn ret;\n\t}\n\n\tret = otp->data->reg_read(context, offset, val, bytes);\n\n\tclk_bulk_disable_unprepare(otp->data->num_clks, otp->clks);\n\n\treturn ret;\n}\n\nstatic struct nvmem_config otp_config = {\n\t.name = \"rockchip-otp\",\n\t.owner = THIS_MODULE,\n\t.read_only = true,\n\t.stride = 1,\n\t.word_size = 1,\n\t.reg_read = rockchip_otp_read,\n};\n\nstatic const char * const px30_otp_clocks[] = {\n\t\"otp\", \"apb_pclk\", \"phy\",\n};\n\nstatic const struct rockchip_data px30_data = {\n\t.size = 0x40,\n\t.clks = px30_otp_clocks,\n\t.num_clks = ARRAY_SIZE(px30_otp_clocks),\n\t.reg_read = px30_otp_read,\n};\n\nstatic const char * const rk3588_otp_clocks[] = {\n\t\"otp\", \"apb_pclk\", \"phy\", \"arb\",\n};\n\nstatic const struct rockchip_data rk3588_data = {\n\t.size = 0x400,\n\t.clks = rk3588_otp_clocks,\n\t.num_clks = ARRAY_SIZE(rk3588_otp_clocks),\n\t.reg_read = rk3588_otp_read,\n};\n\nstatic const struct of_device_id rockchip_otp_match[] = {\n\t{\n\t\t.compatible = \"rockchip,px30-otp\",\n\t\t.data = &px30_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3308-otp\",\n\t\t.data = &px30_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3588-otp\",\n\t\t.data = &rk3588_data,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, rockchip_otp_match);\n\nstatic int rockchip_otp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rockchip_otp *otp;\n\tconst struct rockchip_data *data;\n\tstruct nvmem_device *nvmem;\n\tint ret, i;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data)\n\t\treturn dev_err_probe(dev, -EINVAL, \"failed to get match data\\n\");\n\n\totp = devm_kzalloc(&pdev->dev, sizeof(struct rockchip_otp),\n\t\t\t   GFP_KERNEL);\n\tif (!otp)\n\t\treturn -ENOMEM;\n\n\totp->data = data;\n\totp->dev = dev;\n\totp->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(otp->base))\n\t\treturn dev_err_probe(dev, PTR_ERR(otp->base),\n\t\t\t\t     \"failed to ioremap resource\\n\");\n\n\totp->clks = devm_kcalloc(dev, data->num_clks, sizeof(*otp->clks),\n\t\t\t\t GFP_KERNEL);\n\tif (!otp->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < data->num_clks; ++i)\n\t\totp->clks[i].id = data->clks[i];\n\n\tret = devm_clk_bulk_get(dev, data->num_clks, otp->clks);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to get clocks\\n\");\n\n\totp->rst = devm_reset_control_array_get_exclusive(dev);\n\tif (IS_ERR(otp->rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(otp->rst),\n\t\t\t\t     \"failed to get resets\\n\");\n\n\totp_config.size = data->size;\n\totp_config.priv = otp;\n\totp_config.dev = dev;\n\n\tnvmem = devm_nvmem_register(dev, &otp_config);\n\tif (IS_ERR(nvmem))\n\t\treturn dev_err_probe(dev, PTR_ERR(nvmem),\n\t\t\t\t     \"failed to register nvmem device\\n\");\n\treturn 0;\n}\n\nstatic struct platform_driver rockchip_otp_driver = {\n\t.probe = rockchip_otp_probe,\n\t.driver = {\n\t\t.name = \"rockchip-otp\",\n\t\t.of_match_table = rockchip_otp_match,\n\t},\n};\n\nmodule_platform_driver(rockchip_otp_driver);\nMODULE_DESCRIPTION(\"Rockchip OTP driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}