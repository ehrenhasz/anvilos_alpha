{
  "module_name": "microchip-otpc.c",
  "hash_id": "ae1a68219079fb8d8186593bbcec31639cc185d2533207efbad8d5954aa560bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/microchip-otpc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#define MCHP_OTPC_CR\t\t\t(0x0)\n#define MCHP_OTPC_CR_READ\t\tBIT(6)\n#define MCHP_OTPC_MR\t\t\t(0x4)\n#define MCHP_OTPC_MR_ADDR\t\tGENMASK(31, 16)\n#define MCHP_OTPC_AR\t\t\t(0x8)\n#define MCHP_OTPC_SR\t\t\t(0xc)\n#define MCHP_OTPC_SR_READ\t\tBIT(6)\n#define MCHP_OTPC_HR\t\t\t(0x20)\n#define MCHP_OTPC_HR_SIZE\t\tGENMASK(15, 8)\n#define MCHP_OTPC_DR\t\t\t(0x24)\n\n#define MCHP_OTPC_NAME\t\t\t\"mchp-otpc\"\n#define MCHP_OTPC_SIZE\t\t\t(11 * 1024)\n\n \nstruct mchp_otpc {\n\tvoid __iomem *base;\n\tstruct device *dev;\n\tstruct list_head packets;\n\tu32 npackets;\n};\n\n \nstruct mchp_otpc_packet {\n\tstruct list_head list;\n\tu32 id;\n\tu32 offset;\n};\n\nstatic struct mchp_otpc_packet *mchp_otpc_id_to_packet(struct mchp_otpc *otpc,\n\t\t\t\t\t\t       u32 id)\n{\n\tstruct mchp_otpc_packet *packet;\n\n\tif (id >= otpc->npackets)\n\t\treturn NULL;\n\n\tlist_for_each_entry(packet, &otpc->packets, list) {\n\t\tif (packet->id == id)\n\t\t\treturn packet;\n\t}\n\n\treturn NULL;\n}\n\nstatic int mchp_otpc_prepare_read(struct mchp_otpc *otpc,\n\t\t\t\t  unsigned int offset)\n{\n\tu32 tmp;\n\n\t \n\ttmp = readl_relaxed(otpc->base + MCHP_OTPC_MR);\n\ttmp &= ~MCHP_OTPC_MR_ADDR;\n\ttmp |= FIELD_PREP(MCHP_OTPC_MR_ADDR, offset);\n\twritel_relaxed(tmp, otpc->base + MCHP_OTPC_MR);\n\n\t \n\ttmp = readl_relaxed(otpc->base + MCHP_OTPC_CR);\n\ttmp |= MCHP_OTPC_CR_READ;\n\twritel_relaxed(tmp, otpc->base + MCHP_OTPC_CR);\n\n\t \n\treturn read_poll_timeout(readl_relaxed, tmp, !(tmp & MCHP_OTPC_SR_READ),\n\t\t\t\t 10000, 2000, false, otpc->base + MCHP_OTPC_SR);\n}\n\n \nstatic int mchp_otpc_read(void *priv, unsigned int off, void *val,\n\t\t\t  size_t bytes)\n{\n\tstruct mchp_otpc *otpc = priv;\n\tstruct mchp_otpc_packet *packet;\n\tu32 *buf = val;\n\tu32 offset;\n\tsize_t len = 0;\n\tint ret, payload_size;\n\n\t \n\tpacket = mchp_otpc_id_to_packet(otpc, off / 4);\n\tif (!packet)\n\t\treturn -EINVAL;\n\toffset = packet->offset;\n\n\twhile (len < bytes) {\n\t\tret = mchp_otpc_prepare_read(otpc, offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\t*buf++ = readl_relaxed(otpc->base + MCHP_OTPC_HR);\n\t\tlen += sizeof(*buf);\n\t\toffset++;\n\t\tif (len >= bytes)\n\t\t\tbreak;\n\n\t\t \n\t\tpayload_size = FIELD_GET(MCHP_OTPC_HR_SIZE, *(buf - 1));\n\t\twritel_relaxed(0UL, otpc->base + MCHP_OTPC_AR);\n\t\tdo {\n\t\t\t*buf++ = readl_relaxed(otpc->base + MCHP_OTPC_DR);\n\t\t\tlen += sizeof(*buf);\n\t\t\toffset++;\n\t\t\tpayload_size--;\n\t\t} while (payload_size >= 0 && len < bytes);\n\t}\n\n\treturn 0;\n}\n\nstatic int mchp_otpc_init_packets_list(struct mchp_otpc *otpc, u32 *size)\n{\n\tstruct mchp_otpc_packet *packet;\n\tu32 word, word_pos = 0, id = 0, npackets = 0, payload_size;\n\tint ret;\n\n\tINIT_LIST_HEAD(&otpc->packets);\n\t*size = 0;\n\n\twhile (*size < MCHP_OTPC_SIZE) {\n\t\tret = mchp_otpc_prepare_read(otpc, word_pos);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tword = readl_relaxed(otpc->base + MCHP_OTPC_HR);\n\t\tpayload_size = FIELD_GET(MCHP_OTPC_HR_SIZE, word);\n\t\tif (!payload_size)\n\t\t\tbreak;\n\n\t\tpacket = devm_kzalloc(otpc->dev, sizeof(*packet), GFP_KERNEL);\n\t\tif (!packet)\n\t\t\treturn -ENOMEM;\n\n\t\tpacket->id = id++;\n\t\tpacket->offset = word_pos;\n\t\tINIT_LIST_HEAD(&packet->list);\n\t\tlist_add_tail(&packet->list, &otpc->packets);\n\n\t\t \n\t\t*size += 4 * (payload_size + 1);\n\t\t \n\t\tword_pos += payload_size + 2;\n\n\t\tnpackets++;\n\t}\n\n\totpc->npackets = npackets;\n\n\treturn 0;\n}\n\nstatic struct nvmem_config mchp_nvmem_config = {\n\t.name = MCHP_OTPC_NAME,\n\t.type = NVMEM_TYPE_OTP,\n\t.read_only = true,\n\t.word_size = 4,\n\t.stride = 4,\n\t.reg_read = mchp_otpc_read,\n};\n\nstatic int mchp_otpc_probe(struct platform_device *pdev)\n{\n\tstruct nvmem_device *nvmem;\n\tstruct mchp_otpc *otpc;\n\tu32 size;\n\tint ret;\n\n\totpc = devm_kzalloc(&pdev->dev, sizeof(*otpc), GFP_KERNEL);\n\tif (!otpc)\n\t\treturn -ENOMEM;\n\n\totpc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(otpc->base))\n\t\treturn PTR_ERR(otpc->base);\n\n\totpc->dev = &pdev->dev;\n\tret = mchp_otpc_init_packets_list(otpc, &size);\n\tif (ret)\n\t\treturn ret;\n\n\tmchp_nvmem_config.dev = otpc->dev;\n\tmchp_nvmem_config.size = size;\n\tmchp_nvmem_config.priv = otpc;\n\tnvmem = devm_nvmem_register(&pdev->dev, &mchp_nvmem_config);\n\n\treturn PTR_ERR_OR_ZERO(nvmem);\n}\n\nstatic const struct of_device_id __maybe_unused mchp_otpc_ids[] = {\n\t{ .compatible = \"microchip,sama7g5-otpc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mchp_otpc_ids);\n\nstatic struct platform_driver mchp_otpc_driver = {\n\t.probe = mchp_otpc_probe,\n\t.driver = {\n\t\t.name = MCHP_OTPC_NAME,\n\t\t.of_match_table = of_match_ptr(mchp_otpc_ids),\n\t},\n};\nmodule_platform_driver(mchp_otpc_driver);\n\nMODULE_AUTHOR(\"Claudiu Beznea <claudiu.beznea@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip SAMA7G5 OTPC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}