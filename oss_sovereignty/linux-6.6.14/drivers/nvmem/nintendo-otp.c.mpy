{
  "module_name": "nintendo-otp.c",
  "hash_id": "427acca33fc66405d4f332a2ce20fbf20a6cb743ca00b0ae0b17e4ea2353ed68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvmem/nintendo-otp.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n\n#define HW_OTPCMD  0\n#define HW_OTPDATA 4\n#define OTP_READ   0x80000000\n#define BANK_SIZE  128\n#define WORD_SIZE  4\n\nstruct nintendo_otp_priv {\n\tvoid __iomem *regs;\n};\n\nstruct nintendo_otp_devtype_data {\n\tconst char *name;\n\tunsigned int num_banks;\n};\n\nstatic const struct nintendo_otp_devtype_data hollywood_otp_data = {\n\t.name = \"wii-otp\",\n\t.num_banks = 1,\n};\n\nstatic const struct nintendo_otp_devtype_data latte_otp_data = {\n\t.name = \"wiiu-otp\",\n\t.num_banks = 8,\n};\n\nstatic int nintendo_otp_reg_read(void *context,\n\t\t\t\t unsigned int reg, void *_val, size_t bytes)\n{\n\tstruct nintendo_otp_priv *priv = context;\n\tu32 *val = _val;\n\tint words = bytes / WORD_SIZE;\n\tu32 bank, addr;\n\n\twhile (words--) {\n\t\tbank = (reg / BANK_SIZE) << 8;\n\t\taddr = (reg / WORD_SIZE) % (BANK_SIZE / WORD_SIZE);\n\t\tiowrite32be(OTP_READ | bank | addr, priv->regs + HW_OTPCMD);\n\t\t*val++ = ioread32be(priv->regs + HW_OTPDATA);\n\t\treg += WORD_SIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id nintendo_otp_of_table[] = {\n\t{ .compatible = \"nintendo,hollywood-otp\", .data = &hollywood_otp_data },\n\t{ .compatible = \"nintendo,latte-otp\", .data = &latte_otp_data },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, nintendo_otp_of_table);\n\nstatic int nintendo_otp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *of_id =\n\t\tof_match_device(nintendo_otp_of_table, dev);\n\tstruct nvmem_device *nvmem;\n\tstruct nintendo_otp_priv *priv;\n\n\tstruct nvmem_config config = {\n\t\t.stride = WORD_SIZE,\n\t\t.word_size = WORD_SIZE,\n\t\t.reg_read = nintendo_otp_reg_read,\n\t\t.read_only = true,\n\t\t.root_only = true,\n\t};\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->regs))\n\t\treturn PTR_ERR(priv->regs);\n\n\tif (of_id->data) {\n\t\tconst struct nintendo_otp_devtype_data *data = of_id->data;\n\t\tconfig.name = data->name;\n\t\tconfig.size = data->num_banks * BANK_SIZE;\n\t}\n\n\tconfig.dev = dev;\n\tconfig.priv = priv;\n\n\tnvmem = devm_nvmem_register(dev, &config);\n\n\treturn PTR_ERR_OR_ZERO(nvmem);\n}\n\nstatic struct platform_driver nintendo_otp_driver = {\n\t.probe = nintendo_otp_probe,\n\t.driver = {\n\t\t.name = \"nintendo-otp\",\n\t\t.of_match_table = nintendo_otp_of_table,\n\t},\n};\nmodule_platform_driver(nintendo_otp_driver);\nMODULE_AUTHOR(\"Emmanuel Gil Peyrot <linkmauve@linkmauve.fr>\");\nMODULE_DESCRIPTION(\"Nintendo Wii and Wii U OTP driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}