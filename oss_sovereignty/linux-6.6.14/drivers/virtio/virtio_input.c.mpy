{
  "module_name": "virtio_input.c",
  "hash_id": "fd2bea55595ab9a48a3e476b8db3202b99e9d9a605733870886ca97429b608e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/virtio/virtio_input.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/virtio.h>\n#include <linux/virtio_config.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n\n#include <uapi/linux/virtio_ids.h>\n#include <uapi/linux/virtio_input.h>\n#include <linux/input/mt.h>\n\nstruct virtio_input {\n\tstruct virtio_device       *vdev;\n\tstruct input_dev           *idev;\n\tchar                       name[64];\n\tchar                       serial[64];\n\tchar                       phys[64];\n\tstruct virtqueue           *evt, *sts;\n\tstruct virtio_input_event  evts[64];\n\tspinlock_t                 lock;\n\tbool                       ready;\n};\n\nstatic void virtinput_queue_evtbuf(struct virtio_input *vi,\n\t\t\t\t   struct virtio_input_event *evtbuf)\n{\n\tstruct scatterlist sg[1];\n\n\tsg_init_one(sg, evtbuf, sizeof(*evtbuf));\n\tvirtqueue_add_inbuf(vi->evt, sg, 1, evtbuf, GFP_ATOMIC);\n}\n\nstatic void virtinput_recv_events(struct virtqueue *vq)\n{\n\tstruct virtio_input *vi = vq->vdev->priv;\n\tstruct virtio_input_event *event;\n\tunsigned long flags;\n\tunsigned int len;\n\n\tspin_lock_irqsave(&vi->lock, flags);\n\tif (vi->ready) {\n\t\twhile ((event = virtqueue_get_buf(vi->evt, &len)) != NULL) {\n\t\t\tspin_unlock_irqrestore(&vi->lock, flags);\n\t\t\tinput_event(vi->idev,\n\t\t\t\t    le16_to_cpu(event->type),\n\t\t\t\t    le16_to_cpu(event->code),\n\t\t\t\t    le32_to_cpu(event->value));\n\t\t\tspin_lock_irqsave(&vi->lock, flags);\n\t\t\tvirtinput_queue_evtbuf(vi, event);\n\t\t}\n\t\tvirtqueue_kick(vq);\n\t}\n\tspin_unlock_irqrestore(&vi->lock, flags);\n}\n\n \nstatic int virtinput_send_status(struct virtio_input *vi,\n\t\t\t\t u16 type, u16 code, s32 value)\n{\n\tstruct virtio_input_event *stsbuf;\n\tstruct scatterlist sg[1];\n\tunsigned long flags;\n\tint rc;\n\n\t \n\tif (vi->idev->mt && type == EV_MSC && code == MSC_TIMESTAMP)\n\t\treturn 0;\n\n\tstsbuf = kzalloc(sizeof(*stsbuf), GFP_ATOMIC);\n\tif (!stsbuf)\n\t\treturn -ENOMEM;\n\n\tstsbuf->type  = cpu_to_le16(type);\n\tstsbuf->code  = cpu_to_le16(code);\n\tstsbuf->value = cpu_to_le32(value);\n\tsg_init_one(sg, stsbuf, sizeof(*stsbuf));\n\n\tspin_lock_irqsave(&vi->lock, flags);\n\tif (vi->ready) {\n\t\trc = virtqueue_add_outbuf(vi->sts, sg, 1, stsbuf, GFP_ATOMIC);\n\t\tvirtqueue_kick(vi->sts);\n\t} else {\n\t\trc = -ENODEV;\n\t}\n\tspin_unlock_irqrestore(&vi->lock, flags);\n\n\tif (rc != 0)\n\t\tkfree(stsbuf);\n\treturn rc;\n}\n\nstatic void virtinput_recv_status(struct virtqueue *vq)\n{\n\tstruct virtio_input *vi = vq->vdev->priv;\n\tstruct virtio_input_event *stsbuf;\n\tunsigned long flags;\n\tunsigned int len;\n\n\tspin_lock_irqsave(&vi->lock, flags);\n\twhile ((stsbuf = virtqueue_get_buf(vi->sts, &len)) != NULL)\n\t\tkfree(stsbuf);\n\tspin_unlock_irqrestore(&vi->lock, flags);\n}\n\nstatic int virtinput_status(struct input_dev *idev, unsigned int type,\n\t\t\t    unsigned int code, int value)\n{\n\tstruct virtio_input *vi = input_get_drvdata(idev);\n\n\treturn virtinput_send_status(vi, type, code, value);\n}\n\nstatic u8 virtinput_cfg_select(struct virtio_input *vi,\n\t\t\t       u8 select, u8 subsel)\n{\n\tu8 size;\n\n\tvirtio_cwrite_le(vi->vdev, struct virtio_input_config, select, &select);\n\tvirtio_cwrite_le(vi->vdev, struct virtio_input_config, subsel, &subsel);\n\tvirtio_cread_le(vi->vdev, struct virtio_input_config, size, &size);\n\treturn size;\n}\n\nstatic void virtinput_cfg_bits(struct virtio_input *vi, int select, int subsel,\n\t\t\t       unsigned long *bits, unsigned int bitcount)\n{\n\tunsigned int bit;\n\tu8 *virtio_bits;\n\tu8 bytes;\n\n\tbytes = virtinput_cfg_select(vi, select, subsel);\n\tif (!bytes)\n\t\treturn;\n\tif (bitcount > bytes * 8)\n\t\tbitcount = bytes * 8;\n\n\t \n\tvirtio_bits = kzalloc(bytes, GFP_KERNEL);\n\tif (!virtio_bits)\n\t\treturn;\n\tvirtio_cread_bytes(vi->vdev, offsetof(struct virtio_input_config,\n\t\t\t\t\t      u.bitmap),\n\t\t\t   virtio_bits, bytes);\n\tfor (bit = 0; bit < bitcount; bit++) {\n\t\tif (virtio_bits[bit / 8] & (1 << (bit % 8)))\n\t\t\t__set_bit(bit, bits);\n\t}\n\tkfree(virtio_bits);\n\n\tif (select == VIRTIO_INPUT_CFG_EV_BITS)\n\t\t__set_bit(subsel, vi->idev->evbit);\n}\n\nstatic void virtinput_cfg_abs(struct virtio_input *vi, int abs)\n{\n\tu32 mi, ma, re, fu, fl;\n\n\tvirtinput_cfg_select(vi, VIRTIO_INPUT_CFG_ABS_INFO, abs);\n\tvirtio_cread_le(vi->vdev, struct virtio_input_config, u.abs.min, &mi);\n\tvirtio_cread_le(vi->vdev, struct virtio_input_config, u.abs.max, &ma);\n\tvirtio_cread_le(vi->vdev, struct virtio_input_config, u.abs.res, &re);\n\tvirtio_cread_le(vi->vdev, struct virtio_input_config, u.abs.fuzz, &fu);\n\tvirtio_cread_le(vi->vdev, struct virtio_input_config, u.abs.flat, &fl);\n\tinput_set_abs_params(vi->idev, abs, mi, ma, fu, fl);\n\tinput_abs_set_res(vi->idev, abs, re);\n}\n\nstatic int virtinput_init_vqs(struct virtio_input *vi)\n{\n\tstruct virtqueue *vqs[2];\n\tvq_callback_t *cbs[] = { virtinput_recv_events,\n\t\t\t\t virtinput_recv_status };\n\tstatic const char * const names[] = { \"events\", \"status\" };\n\tint err;\n\n\terr = virtio_find_vqs(vi->vdev, 2, vqs, cbs, names, NULL);\n\tif (err)\n\t\treturn err;\n\tvi->evt = vqs[0];\n\tvi->sts = vqs[1];\n\n\treturn 0;\n}\n\nstatic void virtinput_fill_evt(struct virtio_input *vi)\n{\n\tunsigned long flags;\n\tint i, size;\n\n\tspin_lock_irqsave(&vi->lock, flags);\n\tsize = virtqueue_get_vring_size(vi->evt);\n\tif (size > ARRAY_SIZE(vi->evts))\n\t\tsize = ARRAY_SIZE(vi->evts);\n\tfor (i = 0; i < size; i++)\n\t\tvirtinput_queue_evtbuf(vi, &vi->evts[i]);\n\tvirtqueue_kick(vi->evt);\n\tspin_unlock_irqrestore(&vi->lock, flags);\n}\n\nstatic int virtinput_probe(struct virtio_device *vdev)\n{\n\tstruct virtio_input *vi;\n\tunsigned long flags;\n\tsize_t size;\n\tint abs, err, nslots;\n\n\tif (!virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\treturn -ENODEV;\n\n\tvi = kzalloc(sizeof(*vi), GFP_KERNEL);\n\tif (!vi)\n\t\treturn -ENOMEM;\n\n\tvdev->priv = vi;\n\tvi->vdev = vdev;\n\tspin_lock_init(&vi->lock);\n\n\terr = virtinput_init_vqs(vi);\n\tif (err)\n\t\tgoto err_init_vq;\n\n\tvi->idev = input_allocate_device();\n\tif (!vi->idev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_input_alloc;\n\t}\n\tinput_set_drvdata(vi->idev, vi);\n\n\tsize = virtinput_cfg_select(vi, VIRTIO_INPUT_CFG_ID_NAME, 0);\n\tvirtio_cread_bytes(vi->vdev, offsetof(struct virtio_input_config,\n\t\t\t\t\t      u.string),\n\t\t\t   vi->name, min(size, sizeof(vi->name)));\n\tsize = virtinput_cfg_select(vi, VIRTIO_INPUT_CFG_ID_SERIAL, 0);\n\tvirtio_cread_bytes(vi->vdev, offsetof(struct virtio_input_config,\n\t\t\t\t\t      u.string),\n\t\t\t   vi->serial, min(size, sizeof(vi->serial)));\n\tsnprintf(vi->phys, sizeof(vi->phys),\n\t\t \"virtio%d/input0\", vdev->index);\n\tvi->idev->name = vi->name;\n\tvi->idev->phys = vi->phys;\n\tvi->idev->uniq = vi->serial;\n\n\tsize = virtinput_cfg_select(vi, VIRTIO_INPUT_CFG_ID_DEVIDS, 0);\n\tif (size >= sizeof(struct virtio_input_devids)) {\n\t\tvirtio_cread_le(vi->vdev, struct virtio_input_config,\n\t\t\t\tu.ids.bustype, &vi->idev->id.bustype);\n\t\tvirtio_cread_le(vi->vdev, struct virtio_input_config,\n\t\t\t\tu.ids.vendor, &vi->idev->id.vendor);\n\t\tvirtio_cread_le(vi->vdev, struct virtio_input_config,\n\t\t\t\tu.ids.product, &vi->idev->id.product);\n\t\tvirtio_cread_le(vi->vdev, struct virtio_input_config,\n\t\t\t\tu.ids.version, &vi->idev->id.version);\n\t} else {\n\t\tvi->idev->id.bustype = BUS_VIRTUAL;\n\t}\n\n\tvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_PROP_BITS, 0,\n\t\t\t   vi->idev->propbit, INPUT_PROP_CNT);\n\tsize = virtinput_cfg_select(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_REP);\n\tif (size)\n\t\t__set_bit(EV_REP, vi->idev->evbit);\n\n\tvi->idev->dev.parent = &vdev->dev;\n\tvi->idev->event = virtinput_status;\n\n\t \n\tvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_KEY,\n\t\t\t   vi->idev->keybit, KEY_CNT);\n\tvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_REL,\n\t\t\t   vi->idev->relbit, REL_CNT);\n\tvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_ABS,\n\t\t\t   vi->idev->absbit, ABS_CNT);\n\tvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_MSC,\n\t\t\t   vi->idev->mscbit, MSC_CNT);\n\tvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_SW,\n\t\t\t   vi->idev->swbit,  SW_CNT);\n\n\t \n\tvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_LED,\n\t\t\t   vi->idev->ledbit, LED_CNT);\n\tvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_SND,\n\t\t\t   vi->idev->sndbit, SND_CNT);\n\n\tif (test_bit(EV_ABS, vi->idev->evbit)) {\n\t\tfor (abs = 0; abs < ABS_CNT; abs++) {\n\t\t\tif (!test_bit(abs, vi->idev->absbit))\n\t\t\t\tcontinue;\n\t\t\tvirtinput_cfg_abs(vi, abs);\n\t\t}\n\n\t\tif (test_bit(ABS_MT_SLOT, vi->idev->absbit)) {\n\t\t\tnslots = input_abs_get_max(vi->idev, ABS_MT_SLOT) + 1;\n\t\t\terr = input_mt_init_slots(vi->idev, nslots, 0);\n\t\t\tif (err)\n\t\t\t\tgoto err_mt_init_slots;\n\t\t}\n\t}\n\n\tvirtio_device_ready(vdev);\n\tvi->ready = true;\n\terr = input_register_device(vi->idev);\n\tif (err)\n\t\tgoto err_input_register;\n\n\tvirtinput_fill_evt(vi);\n\treturn 0;\n\nerr_input_register:\n\tspin_lock_irqsave(&vi->lock, flags);\n\tvi->ready = false;\n\tspin_unlock_irqrestore(&vi->lock, flags);\nerr_mt_init_slots:\n\tinput_free_device(vi->idev);\nerr_input_alloc:\n\tvdev->config->del_vqs(vdev);\nerr_init_vq:\n\tkfree(vi);\n\treturn err;\n}\n\nstatic void virtinput_remove(struct virtio_device *vdev)\n{\n\tstruct virtio_input *vi = vdev->priv;\n\tvoid *buf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vi->lock, flags);\n\tvi->ready = false;\n\tspin_unlock_irqrestore(&vi->lock, flags);\n\n\tinput_unregister_device(vi->idev);\n\tvirtio_reset_device(vdev);\n\twhile ((buf = virtqueue_detach_unused_buf(vi->sts)) != NULL)\n\t\tkfree(buf);\n\tvdev->config->del_vqs(vdev);\n\tkfree(vi);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int virtinput_freeze(struct virtio_device *vdev)\n{\n\tstruct virtio_input *vi = vdev->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vi->lock, flags);\n\tvi->ready = false;\n\tspin_unlock_irqrestore(&vi->lock, flags);\n\n\tvdev->config->del_vqs(vdev);\n\treturn 0;\n}\n\nstatic int virtinput_restore(struct virtio_device *vdev)\n{\n\tstruct virtio_input *vi = vdev->priv;\n\tint err;\n\n\terr = virtinput_init_vqs(vi);\n\tif (err)\n\t\treturn err;\n\n\tvirtio_device_ready(vdev);\n\tvi->ready = true;\n\tvirtinput_fill_evt(vi);\n\treturn 0;\n}\n#endif\n\nstatic unsigned int features[] = {\n\t \n};\nstatic const struct virtio_device_id id_table[] = {\n\t{ VIRTIO_ID_INPUT, VIRTIO_DEV_ANY_ID },\n\t{ 0 },\n};\n\nstatic struct virtio_driver virtio_input_driver = {\n\t.driver.name         = KBUILD_MODNAME,\n\t.driver.owner        = THIS_MODULE,\n\t.feature_table       = features,\n\t.feature_table_size  = ARRAY_SIZE(features),\n\t.id_table            = id_table,\n\t.probe               = virtinput_probe,\n\t.remove              = virtinput_remove,\n#ifdef CONFIG_PM_SLEEP\n\t.freeze\t             = virtinput_freeze,\n\t.restore             = virtinput_restore,\n#endif\n};\n\nmodule_virtio_driver(virtio_input_driver);\nMODULE_DEVICE_TABLE(virtio, id_table);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Virtio input device driver\");\nMODULE_AUTHOR(\"Gerd Hoffmann <kraxel@redhat.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}