{
  "module_name": "virtio.c",
  "hash_id": "2c083dc6d96668131f66e1b5df5d6c0895f47f3a99a0a10e697c4f896a077c9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/virtio/virtio.c",
  "human_readable_source": "\n#include <linux/virtio.h>\n#include <linux/spinlock.h>\n#include <linux/virtio_config.h>\n#include <linux/virtio_anchor.h>\n#include <linux/module.h>\n#include <linux/idr.h>\n#include <linux/of.h>\n#include <uapi/linux/virtio_ids.h>\n\n \nstatic DEFINE_IDA(virtio_index_ida);\n\nstatic ssize_t device_show(struct device *_d,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct virtio_device *dev = dev_to_virtio(_d);\n\treturn sysfs_emit(buf, \"0x%04x\\n\", dev->id.device);\n}\nstatic DEVICE_ATTR_RO(device);\n\nstatic ssize_t vendor_show(struct device *_d,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct virtio_device *dev = dev_to_virtio(_d);\n\treturn sysfs_emit(buf, \"0x%04x\\n\", dev->id.vendor);\n}\nstatic DEVICE_ATTR_RO(vendor);\n\nstatic ssize_t status_show(struct device *_d,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct virtio_device *dev = dev_to_virtio(_d);\n\treturn sysfs_emit(buf, \"0x%08x\\n\", dev->config->get_status(dev));\n}\nstatic DEVICE_ATTR_RO(status);\n\nstatic ssize_t modalias_show(struct device *_d,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct virtio_device *dev = dev_to_virtio(_d);\n\treturn sysfs_emit(buf, \"virtio:d%08Xv%08X\\n\",\n\t\t       dev->id.device, dev->id.vendor);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic ssize_t features_show(struct device *_d,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct virtio_device *dev = dev_to_virtio(_d);\n\tunsigned int i;\n\tssize_t len = 0;\n\n\t \n\tfor (i = 0; i < sizeof(dev->features)*8; i++)\n\t\tlen += sysfs_emit_at(buf, len, \"%c\",\n\t\t\t       __virtio_test_bit(dev, i) ? '1' : '0');\n\tlen += sysfs_emit_at(buf, len, \"\\n\");\n\treturn len;\n}\nstatic DEVICE_ATTR_RO(features);\n\nstatic struct attribute *virtio_dev_attrs[] = {\n\t&dev_attr_device.attr,\n\t&dev_attr_vendor.attr,\n\t&dev_attr_status.attr,\n\t&dev_attr_modalias.attr,\n\t&dev_attr_features.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(virtio_dev);\n\nstatic inline int virtio_id_match(const struct virtio_device *dev,\n\t\t\t\t  const struct virtio_device_id *id)\n{\n\tif (id->device != dev->id.device && id->device != VIRTIO_DEV_ANY_ID)\n\t\treturn 0;\n\n\treturn id->vendor == VIRTIO_DEV_ANY_ID || id->vendor == dev->id.vendor;\n}\n\n \nstatic int virtio_dev_match(struct device *_dv, struct device_driver *_dr)\n{\n\tunsigned int i;\n\tstruct virtio_device *dev = dev_to_virtio(_dv);\n\tconst struct virtio_device_id *ids;\n\n\tids = drv_to_virtio(_dr)->id_table;\n\tfor (i = 0; ids[i].device; i++)\n\t\tif (virtio_id_match(dev, &ids[i]))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int virtio_uevent(const struct device *_dv, struct kobj_uevent_env *env)\n{\n\tconst struct virtio_device *dev = dev_to_virtio(_dv);\n\n\treturn add_uevent_var(env, \"MODALIAS=virtio:d%08Xv%08X\",\n\t\t\t      dev->id.device, dev->id.vendor);\n}\n\nvoid virtio_check_driver_offered_feature(const struct virtio_device *vdev,\n\t\t\t\t\t unsigned int fbit)\n{\n\tunsigned int i;\n\tstruct virtio_driver *drv = drv_to_virtio(vdev->dev.driver);\n\n\tfor (i = 0; i < drv->feature_table_size; i++)\n\t\tif (drv->feature_table[i] == fbit)\n\t\t\treturn;\n\n\tif (drv->feature_table_legacy) {\n\t\tfor (i = 0; i < drv->feature_table_size_legacy; i++)\n\t\t\tif (drv->feature_table_legacy[i] == fbit)\n\t\t\t\treturn;\n\t}\n\n\tBUG();\n}\nEXPORT_SYMBOL_GPL(virtio_check_driver_offered_feature);\n\nstatic void __virtio_config_changed(struct virtio_device *dev)\n{\n\tstruct virtio_driver *drv = drv_to_virtio(dev->dev.driver);\n\n\tif (!dev->config_enabled)\n\t\tdev->config_change_pending = true;\n\telse if (drv && drv->config_changed)\n\t\tdrv->config_changed(dev);\n}\n\nvoid virtio_config_changed(struct virtio_device *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->config_lock, flags);\n\t__virtio_config_changed(dev);\n\tspin_unlock_irqrestore(&dev->config_lock, flags);\n}\nEXPORT_SYMBOL_GPL(virtio_config_changed);\n\nstatic void virtio_config_disable(struct virtio_device *dev)\n{\n\tspin_lock_irq(&dev->config_lock);\n\tdev->config_enabled = false;\n\tspin_unlock_irq(&dev->config_lock);\n}\n\nstatic void virtio_config_enable(struct virtio_device *dev)\n{\n\tspin_lock_irq(&dev->config_lock);\n\tdev->config_enabled = true;\n\tif (dev->config_change_pending)\n\t\t__virtio_config_changed(dev);\n\tdev->config_change_pending = false;\n\tspin_unlock_irq(&dev->config_lock);\n}\n\nvoid virtio_add_status(struct virtio_device *dev, unsigned int status)\n{\n\tmight_sleep();\n\tdev->config->set_status(dev, dev->config->get_status(dev) | status);\n}\nEXPORT_SYMBOL_GPL(virtio_add_status);\n\n \nstatic int virtio_features_ok(struct virtio_device *dev)\n{\n\tunsigned int status;\n\n\tmight_sleep();\n\n\tif (virtio_check_mem_acc_cb(dev)) {\n\t\tif (!virtio_has_feature(dev, VIRTIO_F_VERSION_1)) {\n\t\t\tdev_warn(&dev->dev,\n\t\t\t\t \"device must provide VIRTIO_F_VERSION_1\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (!virtio_has_feature(dev, VIRTIO_F_ACCESS_PLATFORM)) {\n\t\t\tdev_warn(&dev->dev,\n\t\t\t\t \"device must provide VIRTIO_F_ACCESS_PLATFORM\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (!virtio_has_feature(dev, VIRTIO_F_VERSION_1))\n\t\treturn 0;\n\n\tvirtio_add_status(dev, VIRTIO_CONFIG_S_FEATURES_OK);\n\tstatus = dev->config->get_status(dev);\n\tif (!(status & VIRTIO_CONFIG_S_FEATURES_OK)) {\n\t\tdev_err(&dev->dev, \"virtio: device refuses features: %x\\n\",\n\t\t\tstatus);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n \nvoid virtio_reset_device(struct virtio_device *dev)\n{\n#ifdef CONFIG_VIRTIO_HARDEN_NOTIFICATION\n\t \n\tvirtio_break_device(dev);\n\tvirtio_synchronize_cbs(dev);\n#endif\n\n\tdev->config->reset(dev);\n}\nEXPORT_SYMBOL_GPL(virtio_reset_device);\n\nstatic int virtio_dev_probe(struct device *_d)\n{\n\tint err, i;\n\tstruct virtio_device *dev = dev_to_virtio(_d);\n\tstruct virtio_driver *drv = drv_to_virtio(dev->dev.driver);\n\tu64 device_features;\n\tu64 driver_features;\n\tu64 driver_features_legacy;\n\n\t \n\tvirtio_add_status(dev, VIRTIO_CONFIG_S_DRIVER);\n\n\t \n\tdevice_features = dev->config->get_features(dev);\n\n\t \n\tdriver_features = 0;\n\tfor (i = 0; i < drv->feature_table_size; i++) {\n\t\tunsigned int f = drv->feature_table[i];\n\t\tBUG_ON(f >= 64);\n\t\tdriver_features |= (1ULL << f);\n\t}\n\n\t \n\tif (drv->feature_table_legacy) {\n\t\tdriver_features_legacy = 0;\n\t\tfor (i = 0; i < drv->feature_table_size_legacy; i++) {\n\t\t\tunsigned int f = drv->feature_table_legacy[i];\n\t\t\tBUG_ON(f >= 64);\n\t\t\tdriver_features_legacy |= (1ULL << f);\n\t\t}\n\t} else {\n\t\tdriver_features_legacy = driver_features;\n\t}\n\n\tif (device_features & (1ULL << VIRTIO_F_VERSION_1))\n\t\tdev->features = driver_features & device_features;\n\telse\n\t\tdev->features = driver_features_legacy & device_features;\n\n\t \n\tfor (i = VIRTIO_TRANSPORT_F_START; i < VIRTIO_TRANSPORT_F_END; i++)\n\t\tif (device_features & (1ULL << i))\n\t\t\t__virtio_set_bit(dev, i);\n\n\terr = dev->config->finalize_features(dev);\n\tif (err)\n\t\tgoto err;\n\n\tif (drv->validate) {\n\t\tu64 features = dev->features;\n\n\t\terr = drv->validate(dev);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\t \n\t\tif (features != dev->features) {\n\t\t\terr = dev->config->finalize_features(dev);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\terr = virtio_features_ok(dev);\n\tif (err)\n\t\tgoto err;\n\n\terr = drv->probe(dev);\n\tif (err)\n\t\tgoto err;\n\n\t \n\tif (!(dev->config->get_status(dev) & VIRTIO_CONFIG_S_DRIVER_OK))\n\t\tvirtio_device_ready(dev);\n\n\tif (drv->scan)\n\t\tdrv->scan(dev);\n\n\tvirtio_config_enable(dev);\n\n\treturn 0;\nerr:\n\tvirtio_add_status(dev, VIRTIO_CONFIG_S_FAILED);\n\treturn err;\n\n}\n\nstatic void virtio_dev_remove(struct device *_d)\n{\n\tstruct virtio_device *dev = dev_to_virtio(_d);\n\tstruct virtio_driver *drv = drv_to_virtio(dev->dev.driver);\n\n\tvirtio_config_disable(dev);\n\n\tdrv->remove(dev);\n\n\t \n\tWARN_ON_ONCE(dev->config->get_status(dev));\n\n\t \n\tvirtio_add_status(dev, VIRTIO_CONFIG_S_ACKNOWLEDGE);\n\n\tof_node_put(dev->dev.of_node);\n}\n\nstatic struct bus_type virtio_bus = {\n\t.name  = \"virtio\",\n\t.match = virtio_dev_match,\n\t.dev_groups = virtio_dev_groups,\n\t.uevent = virtio_uevent,\n\t.probe = virtio_dev_probe,\n\t.remove = virtio_dev_remove,\n};\n\nint register_virtio_driver(struct virtio_driver *driver)\n{\n\t \n\tBUG_ON(driver->feature_table_size && !driver->feature_table);\n\tdriver->driver.bus = &virtio_bus;\n\treturn driver_register(&driver->driver);\n}\nEXPORT_SYMBOL_GPL(register_virtio_driver);\n\nvoid unregister_virtio_driver(struct virtio_driver *driver)\n{\n\tdriver_unregister(&driver->driver);\n}\nEXPORT_SYMBOL_GPL(unregister_virtio_driver);\n\nstatic int virtio_device_of_init(struct virtio_device *dev)\n{\n\tstruct device_node *np, *pnode = dev_of_node(dev->dev.parent);\n\tchar compat[] = \"virtio,deviceXXXXXXXX\";\n\tint ret, count;\n\n\tif (!pnode)\n\t\treturn 0;\n\n\tcount = of_get_available_child_count(pnode);\n\tif (!count)\n\t\treturn 0;\n\n\t \n\tif (WARN_ON(count > 1))\n\t\treturn -EINVAL;\n\n\tnp = of_get_next_available_child(pnode, NULL);\n\tif (WARN_ON(!np))\n\t\treturn -ENODEV;\n\n\tret = snprintf(compat, sizeof(compat), \"virtio,device%x\", dev->id.device);\n\tBUG_ON(ret >= sizeof(compat));\n\n\t \n\tif (!of_device_is_compatible(np, compat)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdev->dev.of_node = np;\n\treturn 0;\n\nout:\n\tof_node_put(np);\n\treturn ret;\n}\n\n \nint register_virtio_device(struct virtio_device *dev)\n{\n\tint err;\n\n\tdev->dev.bus = &virtio_bus;\n\tdevice_initialize(&dev->dev);\n\n\t \n\terr = ida_alloc(&virtio_index_ida, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdev->index = err;\n\terr = dev_set_name(&dev->dev, \"virtio%u\", dev->index);\n\tif (err)\n\t\tgoto out_ida_remove;\n\n\terr = virtio_device_of_init(dev);\n\tif (err)\n\t\tgoto out_ida_remove;\n\n\tspin_lock_init(&dev->config_lock);\n\tdev->config_enabled = false;\n\tdev->config_change_pending = false;\n\n\tINIT_LIST_HEAD(&dev->vqs);\n\tspin_lock_init(&dev->vqs_list_lock);\n\n\t \n\tvirtio_reset_device(dev);\n\n\t \n\tvirtio_add_status(dev, VIRTIO_CONFIG_S_ACKNOWLEDGE);\n\n\t \n\terr = device_add(&dev->dev);\n\tif (err)\n\t\tgoto out_of_node_put;\n\n\treturn 0;\n\nout_of_node_put:\n\tof_node_put(dev->dev.of_node);\nout_ida_remove:\n\tida_free(&virtio_index_ida, dev->index);\nout:\n\tvirtio_add_status(dev, VIRTIO_CONFIG_S_FAILED);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(register_virtio_device);\n\nbool is_virtio_device(struct device *dev)\n{\n\treturn dev->bus == &virtio_bus;\n}\nEXPORT_SYMBOL_GPL(is_virtio_device);\n\nvoid unregister_virtio_device(struct virtio_device *dev)\n{\n\tint index = dev->index;  \n\n\tdevice_unregister(&dev->dev);\n\tida_free(&virtio_index_ida, index);\n}\nEXPORT_SYMBOL_GPL(unregister_virtio_device);\n\n#ifdef CONFIG_PM_SLEEP\nint virtio_device_freeze(struct virtio_device *dev)\n{\n\tstruct virtio_driver *drv = drv_to_virtio(dev->dev.driver);\n\n\tvirtio_config_disable(dev);\n\n\tdev->failed = dev->config->get_status(dev) & VIRTIO_CONFIG_S_FAILED;\n\n\tif (drv && drv->freeze)\n\t\treturn drv->freeze(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(virtio_device_freeze);\n\nint virtio_device_restore(struct virtio_device *dev)\n{\n\tstruct virtio_driver *drv = drv_to_virtio(dev->dev.driver);\n\tint ret;\n\n\t \n\tvirtio_reset_device(dev);\n\n\t \n\tvirtio_add_status(dev, VIRTIO_CONFIG_S_ACKNOWLEDGE);\n\n\t \n\tif (dev->failed)\n\t\tvirtio_add_status(dev, VIRTIO_CONFIG_S_FAILED);\n\n\tif (!drv)\n\t\treturn 0;\n\n\t \n\tvirtio_add_status(dev, VIRTIO_CONFIG_S_DRIVER);\n\n\tret = dev->config->finalize_features(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = virtio_features_ok(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tif (drv->restore) {\n\t\tret = drv->restore(dev);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (!(dev->config->get_status(dev) & VIRTIO_CONFIG_S_DRIVER_OK))\n\t\tvirtio_device_ready(dev);\n\n\tvirtio_config_enable(dev);\n\n\treturn 0;\n\nerr:\n\tvirtio_add_status(dev, VIRTIO_CONFIG_S_FAILED);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(virtio_device_restore);\n#endif\n\nstatic int virtio_init(void)\n{\n\tif (bus_register(&virtio_bus) != 0)\n\t\tpanic(\"virtio bus registration failed\");\n\treturn 0;\n}\n\nstatic void __exit virtio_exit(void)\n{\n\tbus_unregister(&virtio_bus);\n\tida_destroy(&virtio_index_ida);\n}\ncore_initcall(virtio_init);\nmodule_exit(virtio_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}