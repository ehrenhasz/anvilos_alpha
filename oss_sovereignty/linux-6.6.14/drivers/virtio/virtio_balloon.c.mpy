{
  "module_name": "virtio_balloon.c",
  "hash_id": "31f31a973110d305edd44014be6243350a8deb95d95cf9f0245b893cef42da5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/virtio/virtio_balloon.c",
  "human_readable_source": "\n \n\n#include <linux/virtio.h>\n#include <linux/virtio_balloon.h>\n#include <linux/swap.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/balloon_compaction.h>\n#include <linux/oom.h>\n#include <linux/wait.h>\n#include <linux/mm.h>\n#include <linux/page_reporting.h>\n\n \n#define VIRTIO_BALLOON_PAGES_PER_PAGE (unsigned int)(PAGE_SIZE >> VIRTIO_BALLOON_PFN_SHIFT)\n#define VIRTIO_BALLOON_ARRAY_PFNS_MAX 256\n \n#define VIRTIO_BALLOON_OOM_NR_PAGES 256\n#define VIRTIO_BALLOON_OOM_NOTIFY_PRIORITY 80\n\n#define VIRTIO_BALLOON_FREE_PAGE_ALLOC_FLAG (__GFP_NORETRY | __GFP_NOWARN | \\\n\t\t\t\t\t     __GFP_NOMEMALLOC)\n \n#define VIRTIO_BALLOON_HINT_BLOCK_ORDER MAX_ORDER\n \n#define VIRTIO_BALLOON_HINT_BLOCK_BYTES \\\n\t(1 << (VIRTIO_BALLOON_HINT_BLOCK_ORDER + PAGE_SHIFT))\n#define VIRTIO_BALLOON_HINT_BLOCK_PAGES (1 << VIRTIO_BALLOON_HINT_BLOCK_ORDER)\n\nenum virtio_balloon_vq {\n\tVIRTIO_BALLOON_VQ_INFLATE,\n\tVIRTIO_BALLOON_VQ_DEFLATE,\n\tVIRTIO_BALLOON_VQ_STATS,\n\tVIRTIO_BALLOON_VQ_FREE_PAGE,\n\tVIRTIO_BALLOON_VQ_REPORTING,\n\tVIRTIO_BALLOON_VQ_MAX\n};\n\nenum virtio_balloon_config_read {\n\tVIRTIO_BALLOON_CONFIG_READ_CMD_ID = 0,\n};\n\nstruct virtio_balloon {\n\tstruct virtio_device *vdev;\n\tstruct virtqueue *inflate_vq, *deflate_vq, *stats_vq, *free_page_vq;\n\n\t \n\tstruct workqueue_struct *balloon_wq;\n\t \n\tstruct work_struct report_free_page_work;\n\n\t \n\tstruct work_struct update_balloon_stats_work;\n\tstruct work_struct update_balloon_size_work;\n\n\t \n\tspinlock_t stop_update_lock;\n\tbool stop_update;\n\t \n\tunsigned long config_read_bitmap;\n\n\t \n\tstruct list_head free_page_list;\n\tspinlock_t free_page_list_lock;\n\t \n\tunsigned long num_free_page_blocks;\n\t \n\tu32 cmd_id_received_cache;\n\t \n\t__virtio32 cmd_id_active;\n\t \n\t__virtio32 cmd_id_stop;\n\n\t \n\twait_queue_head_t acked;\n\n\t \n\tunsigned int num_pages;\n\t \n\tstruct balloon_dev_info vb_dev_info;\n\n\t \n\tstruct mutex balloon_lock;\n\n\t \n\tunsigned int num_pfns;\n\t__virtio32 pfns[VIRTIO_BALLOON_ARRAY_PFNS_MAX];\n\n\t \n\tstruct virtio_balloon_stat stats[VIRTIO_BALLOON_S_NR];\n\n\t \n\tstruct shrinker shrinker;\n\n\t \n\tstruct notifier_block oom_nb;\n\n\t \n\tstruct virtqueue *reporting_vq;\n\tstruct page_reporting_dev_info pr_dev_info;\n};\n\nstatic const struct virtio_device_id id_table[] = {\n\t{ VIRTIO_ID_BALLOON, VIRTIO_DEV_ANY_ID },\n\t{ 0 },\n};\n\nstatic u32 page_to_balloon_pfn(struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\n\tBUILD_BUG_ON(PAGE_SHIFT < VIRTIO_BALLOON_PFN_SHIFT);\n\t \n\treturn pfn * VIRTIO_BALLOON_PAGES_PER_PAGE;\n}\n\nstatic void balloon_ack(struct virtqueue *vq)\n{\n\tstruct virtio_balloon *vb = vq->vdev->priv;\n\n\twake_up(&vb->acked);\n}\n\nstatic void tell_host(struct virtio_balloon *vb, struct virtqueue *vq)\n{\n\tstruct scatterlist sg;\n\tunsigned int len;\n\n\tsg_init_one(&sg, vb->pfns, sizeof(vb->pfns[0]) * vb->num_pfns);\n\n\t \n\tvirtqueue_add_outbuf(vq, &sg, 1, vb, GFP_KERNEL);\n\tvirtqueue_kick(vq);\n\n\t \n\twait_event(vb->acked, virtqueue_get_buf(vq, &len));\n\n}\n\nstatic int virtballoon_free_page_report(struct page_reporting_dev_info *pr_dev_info,\n\t\t\t\t   struct scatterlist *sg, unsigned int nents)\n{\n\tstruct virtio_balloon *vb =\n\t\tcontainer_of(pr_dev_info, struct virtio_balloon, pr_dev_info);\n\tstruct virtqueue *vq = vb->reporting_vq;\n\tunsigned int unused, err;\n\n\t \n\terr = virtqueue_add_inbuf(vq, sg, nents, vb, GFP_NOWAIT | __GFP_NOWARN);\n\n\t \n\tif (WARN_ON_ONCE(err))\n\t\treturn err;\n\n\tvirtqueue_kick(vq);\n\n\t \n\twait_event(vb->acked, virtqueue_get_buf(vq, &unused));\n\n\treturn 0;\n}\n\nstatic void set_page_pfns(struct virtio_balloon *vb,\n\t\t\t  __virtio32 pfns[], struct page *page)\n{\n\tunsigned int i;\n\n\tBUILD_BUG_ON(VIRTIO_BALLOON_PAGES_PER_PAGE > VIRTIO_BALLOON_ARRAY_PFNS_MAX);\n\n\t \n\tfor (i = 0; i < VIRTIO_BALLOON_PAGES_PER_PAGE; i++)\n\t\tpfns[i] = cpu_to_virtio32(vb->vdev,\n\t\t\t\t\t  page_to_balloon_pfn(page) + i);\n}\n\nstatic unsigned int fill_balloon(struct virtio_balloon *vb, size_t num)\n{\n\tunsigned int num_allocated_pages;\n\tunsigned int num_pfns;\n\tstruct page *page;\n\tLIST_HEAD(pages);\n\n\t \n\tnum = min(num, ARRAY_SIZE(vb->pfns));\n\n\tfor (num_pfns = 0; num_pfns < num;\n\t     num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) {\n\t\tstruct page *page = balloon_page_alloc();\n\n\t\tif (!page) {\n\t\t\tdev_info_ratelimited(&vb->vdev->dev,\n\t\t\t\t\t     \"Out of puff! Can't get %u pages\\n\",\n\t\t\t\t\t     VIRTIO_BALLOON_PAGES_PER_PAGE);\n\t\t\t \n\t\t\tmsleep(200);\n\t\t\tbreak;\n\t\t}\n\n\t\tballoon_page_push(&pages, page);\n\t}\n\n\tmutex_lock(&vb->balloon_lock);\n\n\tvb->num_pfns = 0;\n\n\twhile ((page = balloon_page_pop(&pages))) {\n\t\tballoon_page_enqueue(&vb->vb_dev_info, page);\n\n\t\tset_page_pfns(vb, vb->pfns + vb->num_pfns, page);\n\t\tvb->num_pages += VIRTIO_BALLOON_PAGES_PER_PAGE;\n\t\tif (!virtio_has_feature(vb->vdev,\n\t\t\t\t\tVIRTIO_BALLOON_F_DEFLATE_ON_OOM))\n\t\t\tadjust_managed_page_count(page, -1);\n\t\tvb->num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE;\n\t}\n\n\tnum_allocated_pages = vb->num_pfns;\n\t \n\tif (vb->num_pfns != 0)\n\t\ttell_host(vb, vb->inflate_vq);\n\tmutex_unlock(&vb->balloon_lock);\n\n\treturn num_allocated_pages;\n}\n\nstatic void release_pages_balloon(struct virtio_balloon *vb,\n\t\t\t\t struct list_head *pages)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, pages, lru) {\n\t\tif (!virtio_has_feature(vb->vdev,\n\t\t\t\t\tVIRTIO_BALLOON_F_DEFLATE_ON_OOM))\n\t\t\tadjust_managed_page_count(page, 1);\n\t\tlist_del(&page->lru);\n\t\tput_page(page);  \n\t}\n}\n\nstatic unsigned int leak_balloon(struct virtio_balloon *vb, size_t num)\n{\n\tunsigned int num_freed_pages;\n\tstruct page *page;\n\tstruct balloon_dev_info *vb_dev_info = &vb->vb_dev_info;\n\tLIST_HEAD(pages);\n\n\t \n\tnum = min(num, ARRAY_SIZE(vb->pfns));\n\n\tmutex_lock(&vb->balloon_lock);\n\t \n\tnum = min(num, (size_t)vb->num_pages);\n\tfor (vb->num_pfns = 0; vb->num_pfns < num;\n\t     vb->num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) {\n\t\tpage = balloon_page_dequeue(vb_dev_info);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tset_page_pfns(vb, vb->pfns + vb->num_pfns, page);\n\t\tlist_add(&page->lru, &pages);\n\t\tvb->num_pages -= VIRTIO_BALLOON_PAGES_PER_PAGE;\n\t}\n\n\tnum_freed_pages = vb->num_pfns;\n\t \n\tif (vb->num_pfns != 0)\n\t\ttell_host(vb, vb->deflate_vq);\n\trelease_pages_balloon(vb, &pages);\n\tmutex_unlock(&vb->balloon_lock);\n\treturn num_freed_pages;\n}\n\nstatic inline void update_stat(struct virtio_balloon *vb, int idx,\n\t\t\t       u16 tag, u64 val)\n{\n\tBUG_ON(idx >= VIRTIO_BALLOON_S_NR);\n\tvb->stats[idx].tag = cpu_to_virtio16(vb->vdev, tag);\n\tvb->stats[idx].val = cpu_to_virtio64(vb->vdev, val);\n}\n\n#define pages_to_bytes(x) ((u64)(x) << PAGE_SHIFT)\n\nstatic unsigned int update_balloon_stats(struct virtio_balloon *vb)\n{\n\tunsigned long events[NR_VM_EVENT_ITEMS];\n\tstruct sysinfo i;\n\tunsigned int idx = 0;\n\tlong available;\n\tunsigned long caches;\n\n\tall_vm_events(events);\n\tsi_meminfo(&i);\n\n\tavailable = si_mem_available();\n\tcaches = global_node_page_state(NR_FILE_PAGES);\n\n#ifdef CONFIG_VM_EVENT_COUNTERS\n\tupdate_stat(vb, idx++, VIRTIO_BALLOON_S_SWAP_IN,\n\t\t\t\tpages_to_bytes(events[PSWPIN]));\n\tupdate_stat(vb, idx++, VIRTIO_BALLOON_S_SWAP_OUT,\n\t\t\t\tpages_to_bytes(events[PSWPOUT]));\n\tupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MAJFLT, events[PGMAJFAULT]);\n\tupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MINFLT, events[PGFAULT]);\n#ifdef CONFIG_HUGETLB_PAGE\n\tupdate_stat(vb, idx++, VIRTIO_BALLOON_S_HTLB_PGALLOC,\n\t\t    events[HTLB_BUDDY_PGALLOC]);\n\tupdate_stat(vb, idx++, VIRTIO_BALLOON_S_HTLB_PGFAIL,\n\t\t    events[HTLB_BUDDY_PGALLOC_FAIL]);\n#endif\n#endif\n\tupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MEMFREE,\n\t\t\t\tpages_to_bytes(i.freeram));\n\tupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MEMTOT,\n\t\t\t\tpages_to_bytes(i.totalram));\n\tupdate_stat(vb, idx++, VIRTIO_BALLOON_S_AVAIL,\n\t\t\t\tpages_to_bytes(available));\n\tupdate_stat(vb, idx++, VIRTIO_BALLOON_S_CACHES,\n\t\t\t\tpages_to_bytes(caches));\n\n\treturn idx;\n}\n\n \nstatic void stats_request(struct virtqueue *vq)\n{\n\tstruct virtio_balloon *vb = vq->vdev->priv;\n\n\tspin_lock(&vb->stop_update_lock);\n\tif (!vb->stop_update)\n\t\tqueue_work(system_freezable_wq, &vb->update_balloon_stats_work);\n\tspin_unlock(&vb->stop_update_lock);\n}\n\nstatic void stats_handle_request(struct virtio_balloon *vb)\n{\n\tstruct virtqueue *vq;\n\tstruct scatterlist sg;\n\tunsigned int len, num_stats;\n\n\tnum_stats = update_balloon_stats(vb);\n\n\tvq = vb->stats_vq;\n\tif (!virtqueue_get_buf(vq, &len))\n\t\treturn;\n\tsg_init_one(&sg, vb->stats, sizeof(vb->stats[0]) * num_stats);\n\tvirtqueue_add_outbuf(vq, &sg, 1, vb, GFP_KERNEL);\n\tvirtqueue_kick(vq);\n}\n\nstatic inline s64 towards_target(struct virtio_balloon *vb)\n{\n\ts64 target;\n\tu32 num_pages;\n\n\t \n\tvirtio_cread_le(vb->vdev, struct virtio_balloon_config, num_pages,\n\t\t\t&num_pages);\n\n\t \n\ttarget = ALIGN(num_pages, VIRTIO_BALLOON_PAGES_PER_PAGE);\n\treturn target - vb->num_pages;\n}\n\n \nstatic unsigned long return_free_pages_to_mm(struct virtio_balloon *vb,\n\t\t\t\t\t     unsigned long num_to_return)\n{\n\tstruct page *page;\n\tunsigned long num_returned;\n\n\tspin_lock_irq(&vb->free_page_list_lock);\n\tfor (num_returned = 0; num_returned < num_to_return; num_returned++) {\n\t\tpage = balloon_page_pop(&vb->free_page_list);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tfree_pages((unsigned long)page_address(page),\n\t\t\t   VIRTIO_BALLOON_HINT_BLOCK_ORDER);\n\t}\n\tvb->num_free_page_blocks -= num_returned;\n\tspin_unlock_irq(&vb->free_page_list_lock);\n\n\treturn num_returned;\n}\n\nstatic void virtio_balloon_queue_free_page_work(struct virtio_balloon *vb)\n{\n\tif (!virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_FREE_PAGE_HINT))\n\t\treturn;\n\n\t \n\tif (test_and_set_bit(VIRTIO_BALLOON_CONFIG_READ_CMD_ID,\n\t\t\t     &vb->config_read_bitmap))\n\t\treturn;\n\n\tqueue_work(vb->balloon_wq, &vb->report_free_page_work);\n}\n\nstatic void virtballoon_changed(struct virtio_device *vdev)\n{\n\tstruct virtio_balloon *vb = vdev->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vb->stop_update_lock, flags);\n\tif (!vb->stop_update) {\n\t\tqueue_work(system_freezable_wq,\n\t\t\t   &vb->update_balloon_size_work);\n\t\tvirtio_balloon_queue_free_page_work(vb);\n\t}\n\tspin_unlock_irqrestore(&vb->stop_update_lock, flags);\n}\n\nstatic void update_balloon_size(struct virtio_balloon *vb)\n{\n\tu32 actual = vb->num_pages;\n\n\t \n\tvirtio_cwrite_le(vb->vdev, struct virtio_balloon_config, actual,\n\t\t\t &actual);\n}\n\nstatic void update_balloon_stats_func(struct work_struct *work)\n{\n\tstruct virtio_balloon *vb;\n\n\tvb = container_of(work, struct virtio_balloon,\n\t\t\t  update_balloon_stats_work);\n\tstats_handle_request(vb);\n}\n\nstatic void update_balloon_size_func(struct work_struct *work)\n{\n\tstruct virtio_balloon *vb;\n\ts64 diff;\n\n\tvb = container_of(work, struct virtio_balloon,\n\t\t\t  update_balloon_size_work);\n\tdiff = towards_target(vb);\n\n\tif (!diff)\n\t\treturn;\n\n\tif (diff > 0)\n\t\tdiff -= fill_balloon(vb, diff);\n\telse\n\t\tdiff += leak_balloon(vb, -diff);\n\tupdate_balloon_size(vb);\n\n\tif (diff)\n\t\tqueue_work(system_freezable_wq, work);\n}\n\nstatic int init_vqs(struct virtio_balloon *vb)\n{\n\tstruct virtqueue *vqs[VIRTIO_BALLOON_VQ_MAX];\n\tvq_callback_t *callbacks[VIRTIO_BALLOON_VQ_MAX];\n\tconst char *names[VIRTIO_BALLOON_VQ_MAX];\n\tint err;\n\n\t \n\tcallbacks[VIRTIO_BALLOON_VQ_INFLATE] = balloon_ack;\n\tnames[VIRTIO_BALLOON_VQ_INFLATE] = \"inflate\";\n\tcallbacks[VIRTIO_BALLOON_VQ_DEFLATE] = balloon_ack;\n\tnames[VIRTIO_BALLOON_VQ_DEFLATE] = \"deflate\";\n\tcallbacks[VIRTIO_BALLOON_VQ_STATS] = NULL;\n\tnames[VIRTIO_BALLOON_VQ_STATS] = NULL;\n\tcallbacks[VIRTIO_BALLOON_VQ_FREE_PAGE] = NULL;\n\tnames[VIRTIO_BALLOON_VQ_FREE_PAGE] = NULL;\n\tnames[VIRTIO_BALLOON_VQ_REPORTING] = NULL;\n\n\tif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_STATS_VQ)) {\n\t\tnames[VIRTIO_BALLOON_VQ_STATS] = \"stats\";\n\t\tcallbacks[VIRTIO_BALLOON_VQ_STATS] = stats_request;\n\t}\n\n\tif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_FREE_PAGE_HINT)) {\n\t\tnames[VIRTIO_BALLOON_VQ_FREE_PAGE] = \"free_page_vq\";\n\t\tcallbacks[VIRTIO_BALLOON_VQ_FREE_PAGE] = NULL;\n\t}\n\n\tif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_REPORTING)) {\n\t\tnames[VIRTIO_BALLOON_VQ_REPORTING] = \"reporting_vq\";\n\t\tcallbacks[VIRTIO_BALLOON_VQ_REPORTING] = balloon_ack;\n\t}\n\n\terr = virtio_find_vqs(vb->vdev, VIRTIO_BALLOON_VQ_MAX, vqs,\n\t\t\t      callbacks, names, NULL);\n\tif (err)\n\t\treturn err;\n\n\tvb->inflate_vq = vqs[VIRTIO_BALLOON_VQ_INFLATE];\n\tvb->deflate_vq = vqs[VIRTIO_BALLOON_VQ_DEFLATE];\n\tif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_STATS_VQ)) {\n\t\tstruct scatterlist sg;\n\t\tunsigned int num_stats;\n\t\tvb->stats_vq = vqs[VIRTIO_BALLOON_VQ_STATS];\n\n\t\t \n\t\tnum_stats = update_balloon_stats(vb);\n\n\t\tsg_init_one(&sg, vb->stats, sizeof(vb->stats[0]) * num_stats);\n\t\terr = virtqueue_add_outbuf(vb->stats_vq, &sg, 1, vb,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (err) {\n\t\t\tdev_warn(&vb->vdev->dev, \"%s: add stat_vq failed\\n\",\n\t\t\t\t __func__);\n\t\t\treturn err;\n\t\t}\n\t\tvirtqueue_kick(vb->stats_vq);\n\t}\n\n\tif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_FREE_PAGE_HINT))\n\t\tvb->free_page_vq = vqs[VIRTIO_BALLOON_VQ_FREE_PAGE];\n\n\tif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_REPORTING))\n\t\tvb->reporting_vq = vqs[VIRTIO_BALLOON_VQ_REPORTING];\n\n\treturn 0;\n}\n\nstatic u32 virtio_balloon_cmd_id_received(struct virtio_balloon *vb)\n{\n\tif (test_and_clear_bit(VIRTIO_BALLOON_CONFIG_READ_CMD_ID,\n\t\t\t       &vb->config_read_bitmap)) {\n\t\t \n\t\tvirtio_cread_le(vb->vdev, struct virtio_balloon_config,\n\t\t\t\tfree_page_hint_cmd_id,\n\t\t\t\t&vb->cmd_id_received_cache);\n\t}\n\n\treturn vb->cmd_id_received_cache;\n}\n\nstatic int send_cmd_id_start(struct virtio_balloon *vb)\n{\n\tstruct scatterlist sg;\n\tstruct virtqueue *vq = vb->free_page_vq;\n\tint err, unused;\n\n\t \n\twhile (virtqueue_get_buf(vq, &unused))\n\t\t;\n\n\tvb->cmd_id_active = cpu_to_virtio32(vb->vdev,\n\t\t\t\t\tvirtio_balloon_cmd_id_received(vb));\n\tsg_init_one(&sg, &vb->cmd_id_active, sizeof(vb->cmd_id_active));\n\terr = virtqueue_add_outbuf(vq, &sg, 1, &vb->cmd_id_active, GFP_KERNEL);\n\tif (!err)\n\t\tvirtqueue_kick(vq);\n\treturn err;\n}\n\nstatic int send_cmd_id_stop(struct virtio_balloon *vb)\n{\n\tstruct scatterlist sg;\n\tstruct virtqueue *vq = vb->free_page_vq;\n\tint err, unused;\n\n\t \n\twhile (virtqueue_get_buf(vq, &unused))\n\t\t;\n\n\tsg_init_one(&sg, &vb->cmd_id_stop, sizeof(vb->cmd_id_stop));\n\terr = virtqueue_add_outbuf(vq, &sg, 1, &vb->cmd_id_stop, GFP_KERNEL);\n\tif (!err)\n\t\tvirtqueue_kick(vq);\n\treturn err;\n}\n\nstatic int get_free_page_and_send(struct virtio_balloon *vb)\n{\n\tstruct virtqueue *vq = vb->free_page_vq;\n\tstruct page *page;\n\tstruct scatterlist sg;\n\tint err, unused;\n\tvoid *p;\n\n\t \n\twhile (virtqueue_get_buf(vq, &unused))\n\t\t;\n\n\tpage = alloc_pages(VIRTIO_BALLOON_FREE_PAGE_ALLOC_FLAG,\n\t\t\t   VIRTIO_BALLOON_HINT_BLOCK_ORDER);\n\t \n\tif (!page)\n\t\treturn -EINTR;\n\n\tp = page_address(page);\n\tsg_init_one(&sg, p, VIRTIO_BALLOON_HINT_BLOCK_BYTES);\n\t \n\tif (vq->num_free > 1) {\n\t\terr = virtqueue_add_inbuf(vq, &sg, 1, p, GFP_KERNEL);\n\t\tif (unlikely(err)) {\n\t\t\tfree_pages((unsigned long)p,\n\t\t\t\t   VIRTIO_BALLOON_HINT_BLOCK_ORDER);\n\t\t\treturn err;\n\t\t}\n\t\tvirtqueue_kick(vq);\n\t\tspin_lock_irq(&vb->free_page_list_lock);\n\t\tballoon_page_push(&vb->free_page_list, page);\n\t\tvb->num_free_page_blocks++;\n\t\tspin_unlock_irq(&vb->free_page_list_lock);\n\t} else {\n\t\t \n\t\tfree_pages((unsigned long)p, VIRTIO_BALLOON_HINT_BLOCK_ORDER);\n\t}\n\n\treturn 0;\n}\n\nstatic int send_free_pages(struct virtio_balloon *vb)\n{\n\tint err;\n\tu32 cmd_id_active;\n\n\twhile (1) {\n\t\t \n\t\tcmd_id_active = virtio32_to_cpu(vb->vdev, vb->cmd_id_active);\n\t\tif (unlikely(cmd_id_active !=\n\t\t\t     virtio_balloon_cmd_id_received(vb)))\n\t\t\tbreak;\n\n\t\t \n\t\terr = get_free_page_and_send(vb);\n\t\tif (err == -EINTR)\n\t\t\tbreak;\n\t\telse if (unlikely(err))\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void virtio_balloon_report_free_page(struct virtio_balloon *vb)\n{\n\tint err;\n\tstruct device *dev = &vb->vdev->dev;\n\n\t \n\terr = send_cmd_id_start(vb);\n\tif (unlikely(err))\n\t\tdev_err(dev, \"Failed to send a start id, err = %d\\n\", err);\n\n\terr = send_free_pages(vb);\n\tif (unlikely(err))\n\t\tdev_err(dev, \"Failed to send a free page, err = %d\\n\", err);\n\n\t \n\terr = send_cmd_id_stop(vb);\n\tif (unlikely(err))\n\t\tdev_err(dev, \"Failed to send a stop id, err = %d\\n\", err);\n}\n\nstatic void report_free_page_func(struct work_struct *work)\n{\n\tstruct virtio_balloon *vb = container_of(work, struct virtio_balloon,\n\t\t\t\t\t\t report_free_page_work);\n\tu32 cmd_id_received;\n\n\tcmd_id_received = virtio_balloon_cmd_id_received(vb);\n\tif (cmd_id_received == VIRTIO_BALLOON_CMD_ID_DONE) {\n\t\t \n\t\treturn_free_pages_to_mm(vb, ULONG_MAX);\n\t} else if (cmd_id_received != VIRTIO_BALLOON_CMD_ID_STOP &&\n\t\t   cmd_id_received !=\n\t\t   virtio32_to_cpu(vb->vdev, vb->cmd_id_active)) {\n\t\tvirtio_balloon_report_free_page(vb);\n\t}\n}\n\n#ifdef CONFIG_BALLOON_COMPACTION\n \nstatic int virtballoon_migratepage(struct balloon_dev_info *vb_dev_info,\n\t\tstruct page *newpage, struct page *page, enum migrate_mode mode)\n{\n\tstruct virtio_balloon *vb = container_of(vb_dev_info,\n\t\t\tstruct virtio_balloon, vb_dev_info);\n\tunsigned long flags;\n\n\t \n\tif (!mutex_trylock(&vb->balloon_lock))\n\t\treturn -EAGAIN;\n\n\tget_page(newpage);  \n\n\t \n\tif (!virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_DEFLATE_ON_OOM) &&\n\t    page_zone(page) != page_zone(newpage)) {\n\t\tadjust_managed_page_count(page, 1);\n\t\tadjust_managed_page_count(newpage, -1);\n\t}\n\n\t \n\tspin_lock_irqsave(&vb_dev_info->pages_lock, flags);\n\tballoon_page_insert(vb_dev_info, newpage);\n\tvb_dev_info->isolated_pages--;\n\t__count_vm_event(BALLOON_MIGRATE);\n\tspin_unlock_irqrestore(&vb_dev_info->pages_lock, flags);\n\tvb->num_pfns = VIRTIO_BALLOON_PAGES_PER_PAGE;\n\tset_page_pfns(vb, vb->pfns, newpage);\n\ttell_host(vb, vb->inflate_vq);\n\n\t \n\tspin_lock_irqsave(&vb_dev_info->pages_lock, flags);\n\tballoon_page_delete(page);\n\tspin_unlock_irqrestore(&vb_dev_info->pages_lock, flags);\n\tvb->num_pfns = VIRTIO_BALLOON_PAGES_PER_PAGE;\n\tset_page_pfns(vb, vb->pfns, page);\n\ttell_host(vb, vb->deflate_vq);\n\n\tmutex_unlock(&vb->balloon_lock);\n\n\tput_page(page);  \n\n\treturn MIGRATEPAGE_SUCCESS;\n}\n#endif  \n\nstatic unsigned long shrink_free_pages(struct virtio_balloon *vb,\n\t\t\t\t       unsigned long pages_to_free)\n{\n\tunsigned long blocks_to_free, blocks_freed;\n\n\tpages_to_free = round_up(pages_to_free,\n\t\t\t\t VIRTIO_BALLOON_HINT_BLOCK_PAGES);\n\tblocks_to_free = pages_to_free / VIRTIO_BALLOON_HINT_BLOCK_PAGES;\n\tblocks_freed = return_free_pages_to_mm(vb, blocks_to_free);\n\n\treturn blocks_freed * VIRTIO_BALLOON_HINT_BLOCK_PAGES;\n}\n\nstatic unsigned long virtio_balloon_shrinker_scan(struct shrinker *shrinker,\n\t\t\t\t\t\t  struct shrink_control *sc)\n{\n\tstruct virtio_balloon *vb = container_of(shrinker,\n\t\t\t\t\tstruct virtio_balloon, shrinker);\n\n\treturn shrink_free_pages(vb, sc->nr_to_scan);\n}\n\nstatic unsigned long virtio_balloon_shrinker_count(struct shrinker *shrinker,\n\t\t\t\t\t\t   struct shrink_control *sc)\n{\n\tstruct virtio_balloon *vb = container_of(shrinker,\n\t\t\t\t\tstruct virtio_balloon, shrinker);\n\n\treturn vb->num_free_page_blocks * VIRTIO_BALLOON_HINT_BLOCK_PAGES;\n}\n\nstatic int virtio_balloon_oom_notify(struct notifier_block *nb,\n\t\t\t\t     unsigned long dummy, void *parm)\n{\n\tstruct virtio_balloon *vb = container_of(nb,\n\t\t\t\t\t\t struct virtio_balloon, oom_nb);\n\tunsigned long *freed = parm;\n\n\t*freed += leak_balloon(vb, VIRTIO_BALLOON_OOM_NR_PAGES) /\n\t\t  VIRTIO_BALLOON_PAGES_PER_PAGE;\n\tupdate_balloon_size(vb);\n\n\treturn NOTIFY_OK;\n}\n\nstatic void virtio_balloon_unregister_shrinker(struct virtio_balloon *vb)\n{\n\tunregister_shrinker(&vb->shrinker);\n}\n\nstatic int virtio_balloon_register_shrinker(struct virtio_balloon *vb)\n{\n\tvb->shrinker.scan_objects = virtio_balloon_shrinker_scan;\n\tvb->shrinker.count_objects = virtio_balloon_shrinker_count;\n\tvb->shrinker.seeks = DEFAULT_SEEKS;\n\n\treturn register_shrinker(&vb->shrinker, \"virtio-balloon\");\n}\n\nstatic int virtballoon_probe(struct virtio_device *vdev)\n{\n\tstruct virtio_balloon *vb;\n\tint err;\n\n\tif (!vdev->config->get) {\n\t\tdev_err(&vdev->dev, \"%s failure: config access disabled\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tvdev->priv = vb = kzalloc(sizeof(*vb), GFP_KERNEL);\n\tif (!vb) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tINIT_WORK(&vb->update_balloon_stats_work, update_balloon_stats_func);\n\tINIT_WORK(&vb->update_balloon_size_work, update_balloon_size_func);\n\tspin_lock_init(&vb->stop_update_lock);\n\tmutex_init(&vb->balloon_lock);\n\tinit_waitqueue_head(&vb->acked);\n\tvb->vdev = vdev;\n\n\tballoon_devinfo_init(&vb->vb_dev_info);\n\n\terr = init_vqs(vb);\n\tif (err)\n\t\tgoto out_free_vb;\n\n#ifdef CONFIG_BALLOON_COMPACTION\n\tvb->vb_dev_info.migratepage = virtballoon_migratepage;\n#endif\n\tif (virtio_has_feature(vdev, VIRTIO_BALLOON_F_FREE_PAGE_HINT)) {\n\t\t \n\t\tif (virtqueue_get_vring_size(vb->free_page_vq) < 2) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out_del_vqs;\n\t\t}\n\t\tvb->balloon_wq = alloc_workqueue(\"balloon-wq\",\n\t\t\t\t\tWQ_FREEZABLE | WQ_CPU_INTENSIVE, 0);\n\t\tif (!vb->balloon_wq) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_del_vqs;\n\t\t}\n\t\tINIT_WORK(&vb->report_free_page_work, report_free_page_func);\n\t\tvb->cmd_id_received_cache = VIRTIO_BALLOON_CMD_ID_STOP;\n\t\tvb->cmd_id_active = cpu_to_virtio32(vb->vdev,\n\t\t\t\t\t\t  VIRTIO_BALLOON_CMD_ID_STOP);\n\t\tvb->cmd_id_stop = cpu_to_virtio32(vb->vdev,\n\t\t\t\t\t\t  VIRTIO_BALLOON_CMD_ID_STOP);\n\t\tspin_lock_init(&vb->free_page_list_lock);\n\t\tINIT_LIST_HEAD(&vb->free_page_list);\n\t\t \n\t\terr = virtio_balloon_register_shrinker(vb);\n\t\tif (err)\n\t\t\tgoto out_del_balloon_wq;\n\t}\n\n\tif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_DEFLATE_ON_OOM)) {\n\t\tvb->oom_nb.notifier_call = virtio_balloon_oom_notify;\n\t\tvb->oom_nb.priority = VIRTIO_BALLOON_OOM_NOTIFY_PRIORITY;\n\t\terr = register_oom_notifier(&vb->oom_nb);\n\t\tif (err < 0)\n\t\t\tgoto out_unregister_shrinker;\n\t}\n\n\tif (virtio_has_feature(vdev, VIRTIO_BALLOON_F_PAGE_POISON)) {\n\t\t \n\t\t__u32 poison_val = 0;\n\n\t\t \n\t\tif (!want_init_on_free())\n\t\t\tmemset(&poison_val, PAGE_POISON, sizeof(poison_val));\n\n\t\tvirtio_cwrite_le(vb->vdev, struct virtio_balloon_config,\n\t\t\t\t poison_val, &poison_val);\n\t}\n\n\tvb->pr_dev_info.report = virtballoon_free_page_report;\n\tif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_REPORTING)) {\n\t\tunsigned int capacity;\n\n\t\tcapacity = virtqueue_get_vring_size(vb->reporting_vq);\n\t\tif (capacity < PAGE_REPORTING_CAPACITY) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out_unregister_oom;\n\t\t}\n\n\t\t \n#if defined(CONFIG_ARM64) && defined(CONFIG_ARM64_64K_PAGES)\n\t\tvb->pr_dev_info.order = 5;\n#endif\n\n\t\terr = page_reporting_register(&vb->pr_dev_info);\n\t\tif (err)\n\t\t\tgoto out_unregister_oom;\n\t}\n\n\tvirtio_device_ready(vdev);\n\n\tif (towards_target(vb))\n\t\tvirtballoon_changed(vdev);\n\treturn 0;\n\nout_unregister_oom:\n\tif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_DEFLATE_ON_OOM))\n\t\tunregister_oom_notifier(&vb->oom_nb);\nout_unregister_shrinker:\n\tif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_FREE_PAGE_HINT))\n\t\tvirtio_balloon_unregister_shrinker(vb);\nout_del_balloon_wq:\n\tif (virtio_has_feature(vdev, VIRTIO_BALLOON_F_FREE_PAGE_HINT))\n\t\tdestroy_workqueue(vb->balloon_wq);\nout_del_vqs:\n\tvdev->config->del_vqs(vdev);\nout_free_vb:\n\tkfree(vb);\nout:\n\treturn err;\n}\n\nstatic void remove_common(struct virtio_balloon *vb)\n{\n\t \n\twhile (vb->num_pages)\n\t\tleak_balloon(vb, vb->num_pages);\n\tupdate_balloon_size(vb);\n\n\t \n\tif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_FREE_PAGE_HINT))\n\t\treturn_free_pages_to_mm(vb, ULONG_MAX);\n\n\t \n\tvirtio_reset_device(vb->vdev);\n\n\tvb->vdev->config->del_vqs(vb->vdev);\n}\n\nstatic void virtballoon_remove(struct virtio_device *vdev)\n{\n\tstruct virtio_balloon *vb = vdev->priv;\n\n\tif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_REPORTING))\n\t\tpage_reporting_unregister(&vb->pr_dev_info);\n\tif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_DEFLATE_ON_OOM))\n\t\tunregister_oom_notifier(&vb->oom_nb);\n\tif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_FREE_PAGE_HINT))\n\t\tvirtio_balloon_unregister_shrinker(vb);\n\tspin_lock_irq(&vb->stop_update_lock);\n\tvb->stop_update = true;\n\tspin_unlock_irq(&vb->stop_update_lock);\n\tcancel_work_sync(&vb->update_balloon_size_work);\n\tcancel_work_sync(&vb->update_balloon_stats_work);\n\n\tif (virtio_has_feature(vdev, VIRTIO_BALLOON_F_FREE_PAGE_HINT)) {\n\t\tcancel_work_sync(&vb->report_free_page_work);\n\t\tdestroy_workqueue(vb->balloon_wq);\n\t}\n\n\tremove_common(vb);\n\tkfree(vb);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int virtballoon_freeze(struct virtio_device *vdev)\n{\n\tstruct virtio_balloon *vb = vdev->priv;\n\n\t \n\tremove_common(vb);\n\treturn 0;\n}\n\nstatic int virtballoon_restore(struct virtio_device *vdev)\n{\n\tstruct virtio_balloon *vb = vdev->priv;\n\tint ret;\n\n\tret = init_vqs(vdev->priv);\n\tif (ret)\n\t\treturn ret;\n\n\tvirtio_device_ready(vdev);\n\n\tif (towards_target(vb))\n\t\tvirtballoon_changed(vdev);\n\tupdate_balloon_size(vb);\n\treturn 0;\n}\n#endif\n\nstatic int virtballoon_validate(struct virtio_device *vdev)\n{\n\t \n\tif (!want_init_on_free() && !page_poisoning_enabled_static())\n\t\t__virtio_clear_bit(vdev, VIRTIO_BALLOON_F_PAGE_POISON);\n\telse if (!virtio_has_feature(vdev, VIRTIO_BALLOON_F_PAGE_POISON))\n\t\t__virtio_clear_bit(vdev, VIRTIO_BALLOON_F_REPORTING);\n\n\t__virtio_clear_bit(vdev, VIRTIO_F_ACCESS_PLATFORM);\n\treturn 0;\n}\n\nstatic unsigned int features[] = {\n\tVIRTIO_BALLOON_F_MUST_TELL_HOST,\n\tVIRTIO_BALLOON_F_STATS_VQ,\n\tVIRTIO_BALLOON_F_DEFLATE_ON_OOM,\n\tVIRTIO_BALLOON_F_FREE_PAGE_HINT,\n\tVIRTIO_BALLOON_F_PAGE_POISON,\n\tVIRTIO_BALLOON_F_REPORTING,\n};\n\nstatic struct virtio_driver virtio_balloon_driver = {\n\t.feature_table = features,\n\t.feature_table_size = ARRAY_SIZE(features),\n\t.driver.name =\tKBUILD_MODNAME,\n\t.driver.owner =\tTHIS_MODULE,\n\t.id_table =\tid_table,\n\t.validate =\tvirtballoon_validate,\n\t.probe =\tvirtballoon_probe,\n\t.remove =\tvirtballoon_remove,\n\t.config_changed = virtballoon_changed,\n#ifdef CONFIG_PM_SLEEP\n\t.freeze\t=\tvirtballoon_freeze,\n\t.restore =\tvirtballoon_restore,\n#endif\n};\n\nmodule_virtio_driver(virtio_balloon_driver);\nMODULE_DEVICE_TABLE(virtio, id_table);\nMODULE_DESCRIPTION(\"Virtio balloon driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}