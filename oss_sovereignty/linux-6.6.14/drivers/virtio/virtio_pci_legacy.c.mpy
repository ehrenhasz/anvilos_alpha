{
  "module_name": "virtio_pci_legacy.c",
  "hash_id": "4dd7fb0ec7872f84d68cb96e6cd3e6592f0221b9112c522c3502836332157983",
  "original_prompt": "Ingested from linux-6.6.14/drivers/virtio/virtio_pci_legacy.c",
  "human_readable_source": "\n \n\n#include \"linux/virtio_pci_legacy.h\"\n#include \"virtio_pci_common.h\"\n\n \nstatic u64 vp_get_features(struct virtio_device *vdev)\n{\n\tstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\n\n\t \n\treturn vp_legacy_get_features(&vp_dev->ldev);\n}\n\n \nstatic int vp_finalize_features(struct virtio_device *vdev)\n{\n\tstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\n\n\t \n\tvring_transport_features(vdev);\n\n\t \n\tBUG_ON((u32)vdev->features != vdev->features);\n\n\t \n\tvp_legacy_set_features(&vp_dev->ldev, vdev->features);\n\n\treturn 0;\n}\n\n \nstatic void vp_get(struct virtio_device *vdev, unsigned int offset,\n\t\t   void *buf, unsigned int len)\n{\n\tstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\n\tvoid __iomem *ioaddr = vp_dev->ldev.ioaddr +\n\t\t\tVIRTIO_PCI_CONFIG_OFF(vp_dev->msix_enabled) +\n\t\t\toffset;\n\tu8 *ptr = buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tptr[i] = ioread8(ioaddr + i);\n}\n\n \nstatic void vp_set(struct virtio_device *vdev, unsigned int offset,\n\t\t   const void *buf, unsigned int len)\n{\n\tstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\n\tvoid __iomem *ioaddr = vp_dev->ldev.ioaddr +\n\t\t\tVIRTIO_PCI_CONFIG_OFF(vp_dev->msix_enabled) +\n\t\t\toffset;\n\tconst u8 *ptr = buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tiowrite8(ptr[i], ioaddr + i);\n}\n\n \nstatic u8 vp_get_status(struct virtio_device *vdev)\n{\n\tstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\n\treturn vp_legacy_get_status(&vp_dev->ldev);\n}\n\nstatic void vp_set_status(struct virtio_device *vdev, u8 status)\n{\n\tstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\n\t \n\tBUG_ON(status == 0);\n\tvp_legacy_set_status(&vp_dev->ldev, status);\n}\n\nstatic void vp_reset(struct virtio_device *vdev)\n{\n\tstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\n\t \n\tvp_legacy_set_status(&vp_dev->ldev, 0);\n\t \n\tvp_legacy_get_status(&vp_dev->ldev);\n\t \n\tvp_synchronize_vectors(vdev);\n}\n\nstatic u16 vp_config_vector(struct virtio_pci_device *vp_dev, u16 vector)\n{\n\treturn vp_legacy_config_vector(&vp_dev->ldev, vector);\n}\n\nstatic struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,\n\t\t\t\t  struct virtio_pci_vq_info *info,\n\t\t\t\t  unsigned int index,\n\t\t\t\t  void (*callback)(struct virtqueue *vq),\n\t\t\t\t  const char *name,\n\t\t\t\t  bool ctx,\n\t\t\t\t  u16 msix_vec)\n{\n\tstruct virtqueue *vq;\n\tu16 num;\n\tint err;\n\tu64 q_pfn;\n\n\t \n\tnum = vp_legacy_get_queue_size(&vp_dev->ldev, index);\n\tif (!num || vp_legacy_get_queue_enable(&vp_dev->ldev, index))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tinfo->msix_vector = msix_vec;\n\n\t \n\tvq = vring_create_virtqueue(index, num,\n\t\t\t\t    VIRTIO_PCI_VRING_ALIGN, &vp_dev->vdev,\n\t\t\t\t    true, false, ctx,\n\t\t\t\t    vp_notify, callback, name);\n\tif (!vq)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvq->num_max = num;\n\n\tq_pfn = virtqueue_get_desc_addr(vq) >> VIRTIO_PCI_QUEUE_ADDR_SHIFT;\n\tif (q_pfn >> 32) {\n\t\tdev_err(&vp_dev->pci_dev->dev,\n\t\t\t\"platform bug: legacy virtio-pci must not be used with RAM above 0x%llxGB\\n\",\n\t\t\t0x1ULL << (32 + PAGE_SHIFT - 30));\n\t\terr = -E2BIG;\n\t\tgoto out_del_vq;\n\t}\n\n\t \n\tvp_legacy_set_queue_address(&vp_dev->ldev, index, q_pfn);\n\n\tvq->priv = (void __force *)vp_dev->ldev.ioaddr + VIRTIO_PCI_QUEUE_NOTIFY;\n\n\tif (msix_vec != VIRTIO_MSI_NO_VECTOR) {\n\t\tmsix_vec = vp_legacy_queue_vector(&vp_dev->ldev, index, msix_vec);\n\t\tif (msix_vec == VIRTIO_MSI_NO_VECTOR) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto out_deactivate;\n\t\t}\n\t}\n\n\treturn vq;\n\nout_deactivate:\n\tvp_legacy_set_queue_address(&vp_dev->ldev, index, 0);\nout_del_vq:\n\tvring_del_virtqueue(vq);\n\treturn ERR_PTR(err);\n}\n\nstatic void del_vq(struct virtio_pci_vq_info *info)\n{\n\tstruct virtqueue *vq = info->vq;\n\tstruct virtio_pci_device *vp_dev = to_vp_device(vq->vdev);\n\n\tif (vp_dev->msix_enabled) {\n\t\tvp_legacy_queue_vector(&vp_dev->ldev, vq->index,\n\t\t\t\tVIRTIO_MSI_NO_VECTOR);\n\t\t \n\t\tioread8(vp_dev->ldev.ioaddr + VIRTIO_PCI_ISR);\n\t}\n\n\t \n\tvp_legacy_set_queue_address(&vp_dev->ldev, vq->index, 0);\n\n\tvring_del_virtqueue(vq);\n}\n\nstatic const struct virtio_config_ops virtio_pci_config_ops = {\n\t.get\t\t= vp_get,\n\t.set\t\t= vp_set,\n\t.get_status\t= vp_get_status,\n\t.set_status\t= vp_set_status,\n\t.reset\t\t= vp_reset,\n\t.find_vqs\t= vp_find_vqs,\n\t.del_vqs\t= vp_del_vqs,\n\t.synchronize_cbs = vp_synchronize_vectors,\n\t.get_features\t= vp_get_features,\n\t.finalize_features = vp_finalize_features,\n\t.bus_name\t= vp_bus_name,\n\t.set_vq_affinity = vp_set_vq_affinity,\n\t.get_vq_affinity = vp_get_vq_affinity,\n};\n\n \nint virtio_pci_legacy_probe(struct virtio_pci_device *vp_dev)\n{\n\tstruct virtio_pci_legacy_device *ldev = &vp_dev->ldev;\n\tstruct pci_dev *pci_dev = vp_dev->pci_dev;\n\tint rc;\n\n\tldev->pci_dev = pci_dev;\n\n\trc = vp_legacy_probe(ldev);\n\tif (rc)\n\t\treturn rc;\n\n\tvp_dev->isr = ldev->isr;\n\tvp_dev->vdev.id = ldev->id;\n\n\tvp_dev->vdev.config = &virtio_pci_config_ops;\n\n\tvp_dev->config_vector = vp_config_vector;\n\tvp_dev->setup_vq = setup_vq;\n\tvp_dev->del_vq = del_vq;\n\tvp_dev->is_legacy = true;\n\n\treturn 0;\n}\n\nvoid virtio_pci_legacy_remove(struct virtio_pci_device *vp_dev)\n{\n\tstruct virtio_pci_legacy_device *ldev = &vp_dev->ldev;\n\n\tvp_legacy_remove(ldev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}