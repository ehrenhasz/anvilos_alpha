{
  "module_name": "cdrom.c",
  "hash_id": "491b3b6b23fe71c9c2c40d811d05d97bd6adbe3965af2382db0e699d8c07bb4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cdrom/cdrom.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define REVISION \"Revision: 3.20\"\n#define VERSION \"Id: cdrom.c 3.20 2003/12/17\"\n\n \n#define CD_NOTHING      0x0\n#define CD_WARNING\t0x1\n#define CD_REG_UNREG\t0x2\n#define CD_DO_IOCTL\t0x4\n#define CD_OPEN\t\t0x8\n#define CD_CLOSE\t0x10\n#define CD_COUNT_TRACKS 0x20\n#define CD_CHANGER\t0x40\n#define CD_DVD\t\t0x80\n\n \n \n#define ERRLOGMASK CD_WARNING\n \n \n\n#include <linux/atomic.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/major.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/nospec.h>\n#include <linux/slab.h> \n#include <linux/cdrom.h>\n#include <linux/sysctl.h>\n#include <linux/proc_fs.h>\n#include <linux/blkpg.h>\n#include <linux/init.h>\n#include <linux/fcntl.h>\n#include <linux/blkdev.h>\n#include <linux/times.h>\n#include <linux/uaccess.h>\n#include <scsi/scsi_common.h>\n\n \nstatic bool debug;\n \nstatic bool autoclose=1;\nstatic bool autoeject;\nstatic bool lockdoor = 1;\n \nstatic bool check_media_type;\n \nstatic bool mrw_format_restart = 1;\nmodule_param(debug, bool, 0);\nmodule_param(autoclose, bool, 0);\nmodule_param(autoeject, bool, 0);\nmodule_param(lockdoor, bool, 0);\nmodule_param(check_media_type, bool, 0);\nmodule_param(mrw_format_restart, bool, 0);\n\nstatic DEFINE_MUTEX(cdrom_mutex);\n\nstatic const char *mrw_format_status[] = {\n\t\"not mrw\",\n\t\"bgformat inactive\",\n\t\"bgformat active\",\n\t\"mrw complete\",\n};\n\nstatic const char *mrw_address_space[] = { \"DMA\", \"GAA\" };\n\n#if (ERRLOGMASK != CD_NOTHING)\n#define cd_dbg(type, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif ((ERRLOGMASK & type) || debug == 1)\t\t\\\n\t\tpr_debug(fmt, ##__VA_ARGS__);\t\t\\\n} while (0)\n#else\n#define cd_dbg(type, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (0 && (ERRLOGMASK & type) || debug == 1)\t\\\n\t\tpr_debug(fmt, ##__VA_ARGS__);\t\t\\\n} while (0)\n#endif\n\n \n#define CDROM_CAN(type) (cdi->ops->capability & ~cdi->mask & (type))\n\n \n#define CDROM_DEF_TIMEOUT\t(7 * HZ)\n\n \n\nstatic void cdrom_sysctl_register(void);\n\nstatic LIST_HEAD(cdrom_list);\n\nstatic void signal_media_change(struct cdrom_device_info *cdi)\n{\n\tcdi->mc_flags = 0x3;  \n\tcdi->last_media_change_ms = ktime_to_ms(ktime_get());\n}\n\nint cdrom_dummy_generic_packet(struct cdrom_device_info *cdi,\n\t\t\t       struct packet_command *cgc)\n{\n\tif (cgc->sshdr) {\n\t\tcgc->sshdr->sense_key = 0x05;\n\t\tcgc->sshdr->asc = 0x20;\n\t\tcgc->sshdr->ascq = 0x00;\n\t}\n\n\tcgc->stat = -EIO;\n\treturn -EIO;\n}\nEXPORT_SYMBOL(cdrom_dummy_generic_packet);\n\nstatic int cdrom_flush_cache(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_FLUSH_CACHE;\n\n\tcgc.timeout = 5 * 60 * HZ;\n\n\treturn cdi->ops->generic_packet(cdi, &cgc);\n}\n\n \nstatic int cdrom_get_disc_info(struct cdrom_device_info *cdi,\n\t\t\t       disc_information *di)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct packet_command cgc;\n\tint ret, buflen;\n\n\t \n\tinit_cdrom_command(&cgc, di, sizeof(*di), CGC_DATA_READ);\n\tcgc.cmd[0] = GPCMD_READ_DISC_INFO;\n\tcgc.cmd[8] = cgc.buflen = 2;\n\tcgc.quiet = 1;\n\n\tret = cdo->generic_packet(cdi, &cgc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbuflen = be16_to_cpu(di->disc_information_length) +\n\t\tsizeof(di->disc_information_length);\n\n\tif (buflen > sizeof(disc_information))\n\t\tbuflen = sizeof(disc_information);\n\n\tcgc.cmd[8] = cgc.buflen = buflen;\n\tret = cdo->generic_packet(cdi, &cgc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn buflen;\n}\n\n \n#define ENSURE(cdo, call, bits)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (cdo->call == NULL)\t\t\t\t\t\\\n\t\tWARN_ON_ONCE((cdo)->capability & (bits));\t\\\n} while (0)\n\n \nstatic int cdrom_mrw_probe_pc(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\tchar buffer[16];\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.timeout = HZ;\n\tcgc.quiet = 1;\n\n\tif (!cdrom_mode_sense(cdi, &cgc, MRW_MODE_PC, 0)) {\n\t\tcdi->mrw_mode_page = MRW_MODE_PC;\n\t\treturn 0;\n\t} else if (!cdrom_mode_sense(cdi, &cgc, MRW_MODE_PC_PRE1, 0)) {\n\t\tcdi->mrw_mode_page = MRW_MODE_PC_PRE1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int cdrom_is_mrw(struct cdrom_device_info *cdi, int *write)\n{\n\tstruct packet_command cgc;\n\tstruct mrw_feature_desc *mfd;\n\tunsigned char buffer[16];\n\tint ret;\n\n\t*write = 0;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.cmd[0] = GPCMD_GET_CONFIGURATION;\n\tcgc.cmd[3] = CDF_MRW;\n\tcgc.cmd[8] = sizeof(buffer);\n\tcgc.quiet = 1;\n\n\tif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\n\t\treturn ret;\n\n\tmfd = (struct mrw_feature_desc *)&buffer[sizeof(struct feature_header)];\n\tif (be16_to_cpu(mfd->feature_code) != CDF_MRW)\n\t\treturn 1;\n\t*write = mfd->write;\n\n\tif ((ret = cdrom_mrw_probe_pc(cdi))) {\n\t\t*write = 0;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdrom_mrw_bgformat(struct cdrom_device_info *cdi, int cont)\n{\n\tstruct packet_command cgc;\n\tunsigned char buffer[12];\n\tint ret;\n\n\tpr_info(\"%sstarting format\\n\", cont ? \"Re\" : \"\");\n\n\t \n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_WRITE);\n\tcgc.cmd[0] = GPCMD_FORMAT_UNIT;\n\tcgc.cmd[1] = (1 << 4) | 1;\n\n\tcgc.timeout = 5 * 60 * HZ;\n\n\t \n\tbuffer[1] = 1 << 1;\n\tbuffer[3] = 8;\n\n\t \n\tbuffer[4] = 0xff;\n\tbuffer[5] = 0xff;\n\tbuffer[6] = 0xff;\n\tbuffer[7] = 0xff;\n\n\tbuffer[8] = 0x24 << 2;\n\tbuffer[11] = cont;\n\n\tret = cdi->ops->generic_packet(cdi, &cgc);\n\tif (ret)\n\t\tpr_info(\"bgformat failed\\n\");\n\n\treturn ret;\n}\n\nstatic int cdrom_mrw_bgformat_susp(struct cdrom_device_info *cdi, int immed)\n{\n\tstruct packet_command cgc;\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_CLOSE_TRACK;\n\n\t \n\tcgc.cmd[1] = !!immed;\n\tcgc.cmd[2] = 1 << 1;\n\n\tcgc.timeout = 5 * 60 * HZ;\n\n\treturn cdi->ops->generic_packet(cdi, &cgc);\n}\n\nstatic int cdrom_mrw_exit(struct cdrom_device_info *cdi)\n{\n\tdisc_information di;\n\tint ret;\n\n\tret = cdrom_get_disc_info(cdi, &di);\n\tif (ret < 0 || ret < (int)offsetof(typeof(di),disc_type))\n\t\treturn 1;\n\n\tret = 0;\n\tif (di.mrw_status == CDM_MRW_BGFORMAT_ACTIVE) {\n\t\tpr_info(\"issuing MRW background format suspend\\n\");\n\t\tret = cdrom_mrw_bgformat_susp(cdi, 0);\n\t}\n\n\tif (!ret && cdi->media_written)\n\t\tret = cdrom_flush_cache(cdi);\n\n\treturn ret;\n}\n\nstatic int cdrom_mrw_set_lba_space(struct cdrom_device_info *cdi, int space)\n{\n\tstruct packet_command cgc;\n\tstruct mode_page_header *mph;\n\tchar buffer[16];\n\tint ret, offset, size;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.buffer = buffer;\n\tcgc.buflen = sizeof(buffer);\n\n\tret = cdrom_mode_sense(cdi, &cgc, cdi->mrw_mode_page, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tmph = (struct mode_page_header *)buffer;\n\toffset = be16_to_cpu(mph->desc_length);\n\tsize = be16_to_cpu(mph->mode_data_length) + 2;\n\n\tbuffer[offset + 3] = space;\n\tcgc.buflen = size;\n\n\tret = cdrom_mode_select(cdi, &cgc);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"%s: mrw address space %s selected\\n\",\n\t\tcdi->name, mrw_address_space[space]);\n\treturn 0;\n}\n\nint register_cdrom(struct gendisk *disk, struct cdrom_device_info *cdi)\n{\n\tstatic char banner_printed;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tcd_dbg(CD_OPEN, \"entering register_cdrom\\n\");\n\n\tif (cdo->open == NULL || cdo->release == NULL)\n\t\treturn -EINVAL;\n\tif (!banner_printed) {\n\t\tpr_info(\"Uniform CD-ROM driver \" REVISION \"\\n\");\n\t\tbanner_printed = 1;\n\t\tcdrom_sysctl_register();\n\t}\n\n\tcdi->disk = disk;\n\tdisk->cdi = cdi;\n\n\tENSURE(cdo, drive_status, CDC_DRIVE_STATUS);\n\tif (cdo->check_events == NULL)\n\t\tWARN_ON_ONCE(cdo->capability & (CDC_MEDIA_CHANGED | CDC_SELECT_DISC));\n\tENSURE(cdo, tray_move, CDC_CLOSE_TRAY | CDC_OPEN_TRAY);\n\tENSURE(cdo, lock_door, CDC_LOCK);\n\tENSURE(cdo, select_speed, CDC_SELECT_SPEED);\n\tENSURE(cdo, get_last_session, CDC_MULTI_SESSION);\n\tENSURE(cdo, get_mcn, CDC_MCN);\n\tENSURE(cdo, reset, CDC_RESET);\n\tENSURE(cdo, generic_packet, CDC_GENERIC_PACKET);\n\tcdi->mc_flags = 0;\n\tcdi->options = CDO_USE_FFLAGS;\n\tcdi->last_media_change_ms = ktime_to_ms(ktime_get());\n\n\tif (autoclose == 1 && CDROM_CAN(CDC_CLOSE_TRAY))\n\t\tcdi->options |= (int) CDO_AUTO_CLOSE;\n\tif (autoeject == 1 && CDROM_CAN(CDC_OPEN_TRAY))\n\t\tcdi->options |= (int) CDO_AUTO_EJECT;\n\tif (lockdoor == 1)\n\t\tcdi->options |= (int) CDO_LOCK;\n\tif (check_media_type == 1)\n\t\tcdi->options |= (int) CDO_CHECK_TYPE;\n\n\tif (CDROM_CAN(CDC_MRW_W))\n\t\tcdi->exit = cdrom_mrw_exit;\n\n\tif (cdi->ops->read_cdda_bpc)\n\t\tcdi->cdda_method = CDDA_BPC_FULL;\n\telse\n\t\tcdi->cdda_method = CDDA_OLD;\n\n\tWARN_ON(!cdo->generic_packet);\n\n\tcd_dbg(CD_REG_UNREG, \"drive \\\"/dev/%s\\\" registered\\n\", cdi->name);\n\tmutex_lock(&cdrom_mutex);\n\tlist_add(&cdi->list, &cdrom_list);\n\tmutex_unlock(&cdrom_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(register_cdrom);\n#undef ENSURE\n\nvoid unregister_cdrom(struct cdrom_device_info *cdi)\n{\n\tcd_dbg(CD_OPEN, \"entering unregister_cdrom\\n\");\n\n\tmutex_lock(&cdrom_mutex);\n\tlist_del(&cdi->list);\n\tmutex_unlock(&cdrom_mutex);\n\n\tif (cdi->exit)\n\t\tcdi->exit(cdi);\n\n\tcd_dbg(CD_REG_UNREG, \"drive \\\"/dev/%s\\\" unregistered\\n\", cdi->name);\n}\nEXPORT_SYMBOL(unregister_cdrom);\n\nint cdrom_get_media_event(struct cdrom_device_info *cdi,\n\t\t\t  struct media_event_desc *med)\n{\n\tstruct packet_command cgc;\n\tunsigned char buffer[8];\n\tstruct event_header *eh = (struct event_header *)buffer;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\tcgc.cmd[0] = GPCMD_GET_EVENT_STATUS_NOTIFICATION;\n\tcgc.cmd[1] = 1;\t\t \n\tcgc.cmd[4] = 1 << 4;\t \n\tcgc.cmd[8] = sizeof(buffer);\n\tcgc.quiet = 1;\n\n\tif (cdi->ops->generic_packet(cdi, &cgc))\n\t\treturn 1;\n\n\tif (be16_to_cpu(eh->data_len) < sizeof(*med))\n\t\treturn 1;\n\n\tif (eh->nea || eh->notification_class != 0x4)\n\t\treturn 1;\n\n\tmemcpy(med, &buffer[sizeof(*eh)], sizeof(*med));\n\treturn 0;\n}\nEXPORT_SYMBOL(cdrom_get_media_event);\n\nstatic int cdrom_get_random_writable(struct cdrom_device_info *cdi,\n\t\t\t      struct rwrt_feature_desc *rfd)\n{\n\tstruct packet_command cgc;\n\tchar buffer[24];\n\tint ret;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.cmd[0] = GPCMD_GET_CONFIGURATION;\t \n\tcgc.cmd[3] = CDF_RWRT;\t\t\t \n\tcgc.cmd[8] = sizeof(buffer);\t\t \n\tcgc.quiet = 1;\n\n\tif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\n\t\treturn ret;\n\n\tmemcpy(rfd, &buffer[sizeof(struct feature_header)], sizeof (*rfd));\n\treturn 0;\n}\n\nstatic int cdrom_has_defect_mgt(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\tchar buffer[16];\n\t__be16 *feature_code;\n\tint ret;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.cmd[0] = GPCMD_GET_CONFIGURATION;\n\tcgc.cmd[3] = CDF_HWDM;\n\tcgc.cmd[8] = sizeof(buffer);\n\tcgc.quiet = 1;\n\n\tif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\n\t\treturn ret;\n\n\tfeature_code = (__be16 *) &buffer[sizeof(struct feature_header)];\n\tif (be16_to_cpu(*feature_code) == CDF_HWDM)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n\nstatic int cdrom_is_random_writable(struct cdrom_device_info *cdi, int *write)\n{\n\tstruct rwrt_feature_desc rfd;\n\tint ret;\n\n\t*write = 0;\n\n\tif ((ret = cdrom_get_random_writable(cdi, &rfd)))\n\t\treturn ret;\n\n\tif (CDF_RWRT == be16_to_cpu(rfd.feature_code))\n\t\t*write = 1;\n\n\treturn 0;\n}\n\nstatic int cdrom_media_erasable(struct cdrom_device_info *cdi)\n{\n\tdisc_information di;\n\tint ret;\n\n\tret = cdrom_get_disc_info(cdi, &di);\n\tif (ret < 0 || ret < offsetof(typeof(di), n_first_track))\n\t\treturn -1;\n\n\treturn di.erasable;\n}\n\n \nstatic int cdrom_dvdram_open_write(struct cdrom_device_info *cdi)\n{\n\tint ret = cdrom_media_erasable(cdi);\n\n\t \n\tif (!ret)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int cdrom_mrw_open_write(struct cdrom_device_info *cdi)\n{\n\tdisc_information di;\n\tint ret;\n\n\t \n\tif (cdrom_mrw_set_lba_space(cdi, MRW_LBA_DMA)) {\n\t\tpr_err(\"failed setting lba address space\\n\");\n\t\treturn 1;\n\t}\n\n\tret = cdrom_get_disc_info(cdi, &di);\n\tif (ret < 0 || ret < offsetof(typeof(di),disc_type))\n\t\treturn 1;\n\n\tif (!di.erasable)\n\t\treturn 1;\n\n\t \n\tret = 0;\n\tpr_info(\"open: mrw_status '%s'\\n\", mrw_format_status[di.mrw_status]);\n\tif (!di.mrw_status)\n\t\tret = 1;\n\telse if (di.mrw_status == CDM_MRW_BGFORMAT_INACTIVE &&\n\t\t\tmrw_format_restart)\n\t\tret = cdrom_mrw_bgformat(cdi, 1);\n\n\treturn ret;\n}\n\nstatic int mo_open_write(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\tchar buffer[255];\n\tint ret;\n\n\tinit_cdrom_command(&cgc, &buffer, 4, CGC_DATA_READ);\n\tcgc.quiet = 1;\n\n\t \n\n\tret = cdrom_mode_sense(cdi, &cgc, GPMODE_ALL_PAGES, 0);\n\tif (ret)\n\t\tret = cdrom_mode_sense(cdi, &cgc, GPMODE_VENDOR_PAGE, 0);\n\tif (ret) {\n\t\tcgc.buflen = 255;\n\t\tret = cdrom_mode_sense(cdi, &cgc, GPMODE_ALL_PAGES, 0);\n\t}\n\n\t \n\tif (ret)\n\t\treturn 0;\n\n\treturn buffer[3] & 0x80;\n}\n\nstatic int cdrom_ram_open_write(struct cdrom_device_info *cdi)\n{\n\tstruct rwrt_feature_desc rfd;\n\tint ret;\n\n\tif ((ret = cdrom_has_defect_mgt(cdi)))\n\t\treturn ret;\n\n\tif ((ret = cdrom_get_random_writable(cdi, &rfd)))\n\t\treturn ret;\n\telse if (CDF_RWRT == be16_to_cpu(rfd.feature_code))\n\t\tret = !rfd.curr;\n\n\tcd_dbg(CD_OPEN, \"can open for random write\\n\");\n\treturn ret;\n}\n\nstatic void cdrom_mmc3_profile(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\tchar buffer[32];\n\tint mmc3_profile;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.cmd[0] = GPCMD_GET_CONFIGURATION;\n\tcgc.cmd[1] = 0;\n\tcgc.cmd[2] = cgc.cmd[3] = 0;\t\t \n\tcgc.cmd[8] = sizeof(buffer);\t\t \n\tcgc.quiet = 1;\n\n\tif (cdi->ops->generic_packet(cdi, &cgc))\n\t\tmmc3_profile = 0xffff;\n\telse\n\t\tmmc3_profile = (buffer[6] << 8) | buffer[7];\n\n\tcdi->mmc3_profile = mmc3_profile;\n}\n\nstatic int cdrom_is_dvd_rw(struct cdrom_device_info *cdi)\n{\n\tswitch (cdi->mmc3_profile) {\n\tcase 0x12:\t \n\tcase 0x1A:\t \n\tcase 0x43:\t \n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\n \nstatic int cdrom_open_write(struct cdrom_device_info *cdi)\n{\n\tint mrw, mrw_write, ram_write;\n\tint ret = 1;\n\n\tmrw = 0;\n\tif (!cdrom_is_mrw(cdi, &mrw_write))\n\t\tmrw = 1;\n\n\tif (CDROM_CAN(CDC_MO_DRIVE))\n\t\tram_write = 1;\n\telse\n\t\t(void) cdrom_is_random_writable(cdi, &ram_write);\n\t\n\tif (mrw)\n\t\tcdi->mask &= ~CDC_MRW;\n\telse\n\t\tcdi->mask |= CDC_MRW;\n\n\tif (mrw_write)\n\t\tcdi->mask &= ~CDC_MRW_W;\n\telse\n\t\tcdi->mask |= CDC_MRW_W;\n\n\tif (ram_write)\n\t\tcdi->mask &= ~CDC_RAM;\n\telse\n\t\tcdi->mask |= CDC_RAM;\n\n\tif (CDROM_CAN(CDC_MRW_W))\n\t\tret = cdrom_mrw_open_write(cdi);\n\telse if (CDROM_CAN(CDC_DVD_RAM))\n\t\tret = cdrom_dvdram_open_write(cdi);\n \telse if (CDROM_CAN(CDC_RAM) &&\n \t\t !CDROM_CAN(CDC_CD_R|CDC_CD_RW|CDC_DVD|CDC_DVD_R|CDC_MRW|CDC_MO_DRIVE))\n \t\tret = cdrom_ram_open_write(cdi);\n\telse if (CDROM_CAN(CDC_MO_DRIVE))\n\t\tret = mo_open_write(cdi);\n\telse if (!cdrom_is_dvd_rw(cdi))\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic void cdrom_dvd_rw_close_write(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\n\tif (cdi->mmc3_profile != 0x1a) {\n\t\tcd_dbg(CD_CLOSE, \"%s: No DVD+RW\\n\", cdi->name);\n\t\treturn;\n\t}\n\n\tif (!cdi->media_written) {\n\t\tcd_dbg(CD_CLOSE, \"%s: DVD+RW media clean\\n\", cdi->name);\n\t\treturn;\n\t}\n\n\tpr_info(\"%s: dirty DVD+RW media, \\\"finalizing\\\"\\n\", cdi->name);\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_FLUSH_CACHE;\n\tcgc.timeout = 30*HZ;\n\tcdi->ops->generic_packet(cdi, &cgc);\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_CLOSE_TRACK;\n\tcgc.timeout = 3000*HZ;\n\tcgc.quiet = 1;\n\tcdi->ops->generic_packet(cdi, &cgc);\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_CLOSE_TRACK;\n\tcgc.cmd[2] = 2;\t  \n\tcgc.quiet = 1;\n\tcgc.timeout = 3000*HZ;\n\tcdi->ops->generic_packet(cdi, &cgc);\n\n\tcdi->media_written = 0;\n}\n\n \nstatic void cdrom_count_tracks(struct cdrom_device_info *cdi, tracktype *tracks)\n{\n\tstruct cdrom_tochdr header;\n\tstruct cdrom_tocentry entry;\n\tint ret, i;\n\ttracks->data = 0;\n\ttracks->audio = 0;\n\ttracks->cdi = 0;\n\ttracks->xa = 0;\n\ttracks->error = 0;\n\tcd_dbg(CD_COUNT_TRACKS, \"entering cdrom_count_tracks\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO)) {\n\t\ttracks->error = CDS_NO_INFO;\n\t\treturn;\n\t}\n\n\t \n\tret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCHDR, &header);\n\tif (ret) {\n\t\tif (ret == -ENOMEDIUM)\n\t\t\ttracks->error = CDS_NO_DISC;\n\t\telse\n\t\t\ttracks->error = CDS_NO_INFO;\n\t\treturn;\n\t}\n\t \n\tentry.cdte_format = CDROM_MSF;\n\tfor (i = header.cdth_trk0; i <= header.cdth_trk1; i++) {\n\t\tentry.cdte_track = i;\n\t\tif (cdi->ops->audio_ioctl(cdi, CDROMREADTOCENTRY, &entry)) {\n\t\t\ttracks->error = CDS_NO_INFO;\n\t\t\treturn;\n\t\t}\n\t\tif (entry.cdte_ctrl & CDROM_DATA_TRACK) {\n\t\t\tif (entry.cdte_format == 0x10)\n\t\t\t\ttracks->cdi++;\n\t\t\telse if (entry.cdte_format == 0x20)\n\t\t\t\ttracks->xa++;\n\t\t\telse\n\t\t\t\ttracks->data++;\n\t\t} else {\n\t\t\ttracks->audio++;\n\t\t}\n\t\tcd_dbg(CD_COUNT_TRACKS, \"track %d: format=%d, ctrl=%d\\n\",\n\t\t       i, entry.cdte_format, entry.cdte_ctrl);\n\t}\n\tcd_dbg(CD_COUNT_TRACKS, \"disc has %d tracks: %d=audio %d=data %d=Cd-I %d=XA\\n\",\n\t       header.cdth_trk1, tracks->audio, tracks->data,\n\t       tracks->cdi, tracks->xa);\n}\n\nstatic\nint open_for_data(struct cdrom_device_info *cdi)\n{\n\tint ret;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\ttracktype tracks;\n\tcd_dbg(CD_OPEN, \"entering open_for_data\\n\");\n\t \n\tif (cdo->drive_status != NULL) {\n\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\tcd_dbg(CD_OPEN, \"drive_status=%d\\n\", ret);\n\t\tif (ret == CDS_TRAY_OPEN) {\n\t\t\tcd_dbg(CD_OPEN, \"the tray is open...\\n\");\n\t\t\t \n\t\t\tif (CDROM_CAN(CDC_CLOSE_TRAY) &&\n\t\t\t    cdi->options & CDO_AUTO_CLOSE) {\n\t\t\t\tcd_dbg(CD_OPEN, \"trying to close the tray\\n\");\n\t\t\t\tret=cdo->tray_move(cdi,0);\n\t\t\t\tif (ret) {\n\t\t\t\t\tcd_dbg(CD_OPEN, \"bummer. tried to close the tray but failed.\\n\");\n\t\t\t\t\t \n\t\t\t\t\tret=-ENOMEDIUM;\n\t\t\t\t\tgoto clean_up_and_return;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. this drive can't close the tray.\\n\");\n\t\t\t\tret=-ENOMEDIUM;\n\t\t\t\tgoto clean_up_and_return;\n\t\t\t}\n\t\t\t \n\t\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\t\tif ((ret == CDS_NO_DISC) || (ret==CDS_TRAY_OPEN)) {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. the tray is still not closed.\\n\");\n\t\t\t\tcd_dbg(CD_OPEN, \"tray might not contain a medium\\n\");\n\t\t\t\tret=-ENOMEDIUM;\n\t\t\t\tgoto clean_up_and_return;\n\t\t\t}\n\t\t\tcd_dbg(CD_OPEN, \"the tray is now closed\\n\");\n\t\t}\n\t\t \n\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\tif (ret!=CDS_DISC_OK) {\n\t\t\tret = -ENOMEDIUM;\n\t\t\tgoto clean_up_and_return;\n\t\t}\n\t}\n\tcdrom_count_tracks(cdi, &tracks);\n\tif (tracks.error == CDS_NO_DISC) {\n\t\tcd_dbg(CD_OPEN, \"bummer. no disc.\\n\");\n\t\tret=-ENOMEDIUM;\n\t\tgoto clean_up_and_return;\n\t}\n\t \n\tif (tracks.data==0) {\n\t\tif (cdi->options & CDO_CHECK_TYPE) {\n\t\t     \n\t\t    cd_dbg(CD_OPEN, \"bummer. wrong media type.\\n\");\n\t\t    cd_dbg(CD_WARNING, \"pid %d must open device O_NONBLOCK!\\n\",\n\t\t\t   (unsigned int)task_pid_nr(current));\n\t\t    ret=-EMEDIUMTYPE;\n\t\t    goto clean_up_and_return;\n\t\t}\n\t\telse {\n\t\t    cd_dbg(CD_OPEN, \"wrong media type, but CDO_CHECK_TYPE not set\\n\");\n\t\t}\n\t}\n\n\tcd_dbg(CD_OPEN, \"all seems well, opening the devicen\");\n\n\t \n\tret = cdo->open(cdi, 0);  \n\tcd_dbg(CD_OPEN, \"opening the device gave me %d\\n\", ret);\n\t \n\tif (ret) {\n\t\tcd_dbg(CD_OPEN, \"open device failed\\n\");\n\t\tgoto clean_up_and_return;\n\t}\n\tif (CDROM_CAN(CDC_LOCK) && (cdi->options & CDO_LOCK)) {\n\t\t\tcdo->lock_door(cdi, 1);\n\t\t\tcd_dbg(CD_OPEN, \"door locked\\n\");\n\t}\n\tcd_dbg(CD_OPEN, \"device opened successfully\\n\");\n\treturn ret;\n\n\t  \nclean_up_and_return:\n\tcd_dbg(CD_OPEN, \"open failed\\n\");\n\tif (CDROM_CAN(CDC_LOCK) && cdi->options & CDO_LOCK) {\n\t\t\tcdo->lock_door(cdi, 0);\n\t\t\tcd_dbg(CD_OPEN, \"door unlocked\\n\");\n\t}\n\treturn ret;\n}\n\n \nint cdrom_open(struct cdrom_device_info *cdi, blk_mode_t mode)\n{\n\tint ret;\n\n\tcd_dbg(CD_OPEN, \"entering cdrom_open\\n\");\n\n\t \n\tcdi->use_count++;\n\tif ((mode & BLK_OPEN_NDELAY) && (cdi->options & CDO_USE_FFLAGS)) {\n\t\tret = cdi->ops->open(cdi, 1);\n\t} else {\n\t\tret = open_for_data(cdi);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif (CDROM_CAN(CDC_GENERIC_PACKET))\n\t\t\tcdrom_mmc3_profile(cdi);\n\t\tif (mode & BLK_OPEN_WRITE) {\n\t\t\tret = -EROFS;\n\t\t\tif (cdrom_open_write(cdi))\n\t\t\t\tgoto err_release;\n\t\t\tif (!CDROM_CAN(CDC_RAM))\n\t\t\t\tgoto err_release;\n\t\t\tret = 0;\n\t\t\tcdi->media_written = 0;\n\t\t}\n\t\tcdi->opened_for_data = true;\n\t}\n\n\tif (ret)\n\t\tgoto err;\n\n\tcd_dbg(CD_OPEN, \"Use count for \\\"/dev/%s\\\" now %d\\n\",\n\t       cdi->name, cdi->use_count);\n\treturn 0;\nerr_release:\n\tif (CDROM_CAN(CDC_LOCK) && cdi->options & CDO_LOCK) {\n\t\tcdi->ops->lock_door(cdi, 0);\n\t\tcd_dbg(CD_OPEN, \"door unlocked\\n\");\n\t}\n\tcdi->ops->release(cdi);\nerr:\n\tcdi->use_count--;\n\treturn ret;\n}\nEXPORT_SYMBOL(cdrom_open);\n\n \nstatic int check_for_audio_disc(struct cdrom_device_info *cdi,\n\t\t\t\tconst struct cdrom_device_ops *cdo)\n{\n        int ret;\n\ttracktype tracks;\n\tcd_dbg(CD_OPEN, \"entering check_for_audio_disc\\n\");\n\tif (!(cdi->options & CDO_CHECK_TYPE))\n\t\treturn 0;\n\tif (cdo->drive_status != NULL) {\n\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\tcd_dbg(CD_OPEN, \"drive_status=%d\\n\", ret);\n\t\tif (ret == CDS_TRAY_OPEN) {\n\t\t\tcd_dbg(CD_OPEN, \"the tray is open...\\n\");\n\t\t\t \n\t\t\tif (CDROM_CAN(CDC_CLOSE_TRAY) &&\n\t\t\t    cdi->options & CDO_AUTO_CLOSE) {\n\t\t\t\tcd_dbg(CD_OPEN, \"trying to close the tray\\n\");\n\t\t\t\tret=cdo->tray_move(cdi,0);\n\t\t\t\tif (ret) {\n\t\t\t\t\tcd_dbg(CD_OPEN, \"bummer. tried to close tray but failed.\\n\");\n\t\t\t\t\t \n\t\t\t\t\treturn -ENOMEDIUM;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. this driver can't close the tray.\\n\");\n\t\t\t\treturn -ENOMEDIUM;\n\t\t\t}\n\t\t\t \n\t\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\t\tif ((ret == CDS_NO_DISC) || (ret==CDS_TRAY_OPEN)) {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. the tray is still not closed.\\n\");\n\t\t\t\treturn -ENOMEDIUM;\n\t\t\t}\t\n\t\t\tif (ret!=CDS_DISC_OK) {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. disc isn't ready.\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\t\n\t\t\tcd_dbg(CD_OPEN, \"the tray is now closed\\n\");\n\t\t}\t\n\t}\n\tcdrom_count_tracks(cdi, &tracks);\n\tif (tracks.error) \n\t\treturn(tracks.error);\n\n\tif (tracks.audio==0)\n\t\treturn -EMEDIUMTYPE;\n\n\treturn 0;\n}\n\nvoid cdrom_release(struct cdrom_device_info *cdi)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tcd_dbg(CD_CLOSE, \"entering cdrom_release\\n\");\n\n\tif (cdi->use_count > 0)\n\t\tcdi->use_count--;\n\n\tif (cdi->use_count == 0) {\n\t\tcd_dbg(CD_CLOSE, \"Use count for \\\"/dev/%s\\\" now zero\\n\",\n\t\t       cdi->name);\n\t\tcdrom_dvd_rw_close_write(cdi);\n\n\t\tif ((cdo->capability & CDC_LOCK) && !cdi->keeplocked) {\n\t\t\tcd_dbg(CD_CLOSE, \"Unlocking door!\\n\");\n\t\t\tcdo->lock_door(cdi, 0);\n\t\t}\n\t}\n\n\tcdo->release(cdi);\n\n\tif (cdi->use_count == 0 && cdi->opened_for_data) {\n\t\tif (cdi->options & CDO_AUTO_EJECT && CDROM_CAN(CDC_OPEN_TRAY))\n\t\t\tcdo->tray_move(cdi, 1);\n\t\tcdi->opened_for_data = false;\n\t}\n}\nEXPORT_SYMBOL(cdrom_release);\n\nstatic int cdrom_read_mech_status(struct cdrom_device_info *cdi, \n\t\t\t\t  struct cdrom_changer_info *buf)\n{\n\tstruct packet_command cgc;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tint length;\n\n\t \n\tif (cdi->sanyo_slot) {\n\t\tbuf->hdr.nslots = 3;\n\t\tbuf->hdr.curslot = cdi->sanyo_slot == 3 ? 0 : cdi->sanyo_slot;\n\t\tfor (length = 0; length < 3; length++) {\n\t\t\tbuf->slots[length].disc_present = 1;\n\t\t\tbuf->slots[length].change = 0;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tlength = sizeof(struct cdrom_mechstat_header) +\n\t\t cdi->capacity * sizeof(struct cdrom_slot);\n\n\tinit_cdrom_command(&cgc, buf, length, CGC_DATA_READ);\n\tcgc.cmd[0] = GPCMD_MECHANISM_STATUS;\n\tcgc.cmd[8] = (length >> 8) & 0xff;\n\tcgc.cmd[9] = length & 0xff;\n\treturn cdo->generic_packet(cdi, &cgc);\n}\n\nstatic int cdrom_slot_status(struct cdrom_device_info *cdi, int slot)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\n\tcd_dbg(CD_CHANGER, \"entering cdrom_slot_status()\\n\");\n\tif (cdi->sanyo_slot)\n\t\treturn CDS_NO_INFO;\n\t\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tif ((ret = cdrom_read_mech_status(cdi, info)))\n\t\tgoto out_free;\n\n\tif (info->slots[slot].disc_present)\n\t\tret = CDS_DISC_OK;\n\telse\n\t\tret = CDS_NO_DISC;\n\nout_free:\n\tkfree(info);\n\treturn ret;\n}\n\n \nint cdrom_number_of_slots(struct cdrom_device_info *cdi) \n{\n\tint nslots = 1;\n\tstruct cdrom_changer_info *info;\n\n\tcd_dbg(CD_CHANGER, \"entering cdrom_number_of_slots()\\n\");\n\t \n\tcdi->capacity = 0; \n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tif (cdrom_read_mech_status(cdi, info) == 0)\n\t\tnslots = info->hdr.nslots;\n\n\tkfree(info);\n\treturn nslots;\n}\nEXPORT_SYMBOL(cdrom_number_of_slots);\n\n\n \nstatic int cdrom_load_unload(struct cdrom_device_info *cdi, int slot) \n{\n\tstruct packet_command cgc;\n\n\tcd_dbg(CD_CHANGER, \"entering cdrom_load_unload()\\n\");\n\tif (cdi->sanyo_slot && slot < 0)\n\t\treturn 0;\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_LOAD_UNLOAD;\n\tcgc.cmd[4] = 2 + (slot >= 0);\n\tcgc.cmd[8] = slot;\n\tcgc.timeout = 60 * HZ;\n\n\t \n\tif (cdi->sanyo_slot && -1 < slot) {\n\t\tcgc.cmd[0] = GPCMD_TEST_UNIT_READY;\n\t\tcgc.cmd[7] = slot;\n\t\tcgc.cmd[4] = cgc.cmd[8] = 0;\n\t\tcdi->sanyo_slot = slot ? slot : 3;\n\t}\n\n\treturn cdi->ops->generic_packet(cdi, &cgc);\n}\n\nstatic int cdrom_select_disc(struct cdrom_device_info *cdi, int slot)\n{\n\tstruct cdrom_changer_info *info;\n\tint curslot;\n\tint ret;\n\n\tcd_dbg(CD_CHANGER, \"entering cdrom_select_disc()\\n\");\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -EDRIVE_CANT_DO_THIS;\n\n\tif (cdi->ops->check_events)\n\t\tcdi->ops->check_events(cdi, 0, slot);\n\n\tif (slot == CDSL_NONE) {\n\t\tsignal_media_change(cdi);\n\t\treturn cdrom_load_unload(cdi, -1);\n\t}\n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tif ((ret = cdrom_read_mech_status(cdi, info))) {\n\t\tkfree(info);\n\t\treturn ret;\n\t}\n\n\tcurslot = info->hdr.curslot;\n\tkfree(info);\n\n\tif (cdi->use_count > 1 || cdi->keeplocked) {\n\t\tif (slot == CDSL_CURRENT) {\n\t    \t\treturn curslot;\n\t\t} else {\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t \n\tif (slot == CDSL_CURRENT)\n\t\tslot = curslot;\n\n\t \n\tsignal_media_change(cdi);\n\tif ((ret = cdrom_load_unload(cdi, slot)))\n\t\treturn ret;\n\n\treturn slot;\n}\n\n \nstatic void cdrom_update_events(struct cdrom_device_info *cdi,\n\t\t\t\tunsigned int clearing)\n{\n\tunsigned int events;\n\n\tevents = cdi->ops->check_events(cdi, clearing, CDSL_CURRENT);\n\tcdi->vfs_events |= events;\n\tcdi->ioctl_events |= events;\n}\n\nunsigned int cdrom_check_events(struct cdrom_device_info *cdi,\n\t\t\t\tunsigned int clearing)\n{\n\tunsigned int events;\n\n\tcdrom_update_events(cdi, clearing);\n\tevents = cdi->vfs_events;\n\tcdi->vfs_events = 0;\n\treturn events;\n}\nEXPORT_SYMBOL(cdrom_check_events);\n\n \n\nstatic\nint media_changed(struct cdrom_device_info *cdi, int queue)\n{\n\tunsigned int mask = (1 << (queue & 1));\n\tint ret = !!(cdi->mc_flags & mask);\n\tbool changed;\n\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn ret;\n\n\t \n\tBUG_ON(!queue);\t \n\tcdrom_update_events(cdi, DISK_EVENT_MEDIA_CHANGE);\n\tchanged = cdi->ioctl_events & DISK_EVENT_MEDIA_CHANGE;\n\tcdi->ioctl_events = 0;\n\n\tif (changed) {\n\t\tsignal_media_change(cdi);\n\t\tret |= 1;\n\t\tcdi->media_written = 0;\n\t}\n\n\tcdi->mc_flags &= ~mask;          \n\treturn ret;\n}\n\n \n\nstatic\nvoid sanitize_format(union cdrom_addr *addr,\n\t\t     u_char * curr, u_char requested)\n{\n\tif (*curr == requested)\n\t\treturn;                  \n\tif (requested == CDROM_LBA) {\n\t\taddr->lba = (int) addr->msf.frame +\n\t\t\t75 * (addr->msf.second - 2 + 60 * addr->msf.minute);\n\t} else {                         \n\t\tint lba = addr->lba;\n\t\taddr->msf.frame = lba % 75;\n\t\tlba /= 75;\n\t\tlba += 2;\n\t\taddr->msf.second = lba % 60;\n\t\taddr->msf.minute = lba / 60;\n\t}\n\t*curr = requested;\n}\n\nvoid init_cdrom_command(struct packet_command *cgc, void *buf, int len,\n\t\t\tint type)\n{\n\tmemset(cgc, 0, sizeof(struct packet_command));\n\tif (buf)\n\t\tmemset(buf, 0, len);\n\tcgc->buffer = (char *) buf;\n\tcgc->buflen = len;\n\tcgc->data_direction = type;\n\tcgc->timeout = CDROM_DEF_TIMEOUT;\n}\nEXPORT_SYMBOL(init_cdrom_command);\n\n \n\n#define copy_key(dest,src)\tmemcpy((dest), (src), sizeof(dvd_key))\n#define copy_chal(dest,src)\tmemcpy((dest), (src), sizeof(dvd_challenge))\n\nstatic void setup_report_key(struct packet_command *cgc, unsigned agid, unsigned type)\n{\n\tcgc->cmd[0] = GPCMD_REPORT_KEY;\n\tcgc->cmd[10] = type | (agid << 6);\n\tswitch (type) {\n\t\tcase 0: case 8: case 5: {\n\t\t\tcgc->buflen = 8;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1: {\n\t\t\tcgc->buflen = 16;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: case 4: {\n\t\t\tcgc->buflen = 12;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcgc->cmd[9] = cgc->buflen;\n\tcgc->data_direction = CGC_DATA_READ;\n}\n\nstatic void setup_send_key(struct packet_command *cgc, unsigned agid, unsigned type)\n{\n\tcgc->cmd[0] = GPCMD_SEND_KEY;\n\tcgc->cmd[10] = type | (agid << 6);\n\tswitch (type) {\n\t\tcase 1: {\n\t\t\tcgc->buflen = 16;\n\t\t\tbreak;\n\t\t}\n\t\tcase 3: {\n\t\t\tcgc->buflen = 12;\n\t\t\tbreak;\n\t\t}\n\t\tcase 6: {\n\t\t\tcgc->buflen = 8;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcgc->cmd[9] = cgc->buflen;\n\tcgc->data_direction = CGC_DATA_WRITE;\n}\n\nstatic int dvd_do_auth(struct cdrom_device_info *cdi, dvd_authinfo *ai)\n{\n\tint ret;\n\tu_char buf[20];\n\tstruct packet_command cgc;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\trpc_state_t rpc_state;\n\n\tmemset(buf, 0, sizeof(buf));\n\tinit_cdrom_command(&cgc, buf, 0, CGC_DATA_READ);\n\n\tswitch (ai->type) {\n\t \n\tcase DVD_LU_SEND_AGID:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_AGID\\n\");\n\t\tcgc.quiet = 1;\n\t\tsetup_report_key(&cgc, ai->lsa.agid, 0);\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tai->lsa.agid = buf[7] >> 6;\n\t\t \n\t\tbreak;\n\n\tcase DVD_LU_SEND_KEY1:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_KEY1\\n\");\n\t\tsetup_report_key(&cgc, ai->lsk.agid, 2);\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tcopy_key(ai->lsk.key, &buf[4]);\n\t\t \n\t\tbreak;\n\n\tcase DVD_LU_SEND_CHALLENGE:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_CHALLENGE\\n\");\n\t\tsetup_report_key(&cgc, ai->lsc.agid, 1);\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tcopy_chal(ai->lsc.chal, &buf[4]);\n\t\t \n\t\tbreak;\n\n\t \n\tcase DVD_LU_SEND_TITLE_KEY:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_TITLE_KEY\\n\");\n\t\tcgc.quiet = 1;\n\t\tsetup_report_key(&cgc, ai->lstk.agid, 4);\n\t\tcgc.cmd[5] = ai->lstk.lba;\n\t\tcgc.cmd[4] = ai->lstk.lba >> 8;\n\t\tcgc.cmd[3] = ai->lstk.lba >> 16;\n\t\tcgc.cmd[2] = ai->lstk.lba >> 24;\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tai->lstk.cpm = (buf[4] >> 7) & 1;\n\t\tai->lstk.cp_sec = (buf[4] >> 6) & 1;\n\t\tai->lstk.cgms = (buf[4] >> 4) & 3;\n\t\tcopy_key(ai->lstk.title_key, &buf[5]);\n\t\t \n\t\tbreak;\n\n\tcase DVD_LU_SEND_ASF:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_ASF\\n\");\n\t\tsetup_report_key(&cgc, ai->lsasf.agid, 5);\n\t\t\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tai->lsasf.asf = buf[7] & 1;\n\t\tbreak;\n\n\t \n\tcase DVD_HOST_SEND_CHALLENGE:\n\t\tcd_dbg(CD_DVD, \"entering DVD_HOST_SEND_CHALLENGE\\n\");\n\t\tsetup_send_key(&cgc, ai->hsc.agid, 1);\n\t\tbuf[1] = 0xe;\n\t\tcopy_chal(&buf[4], ai->hsc.chal);\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tai->type = DVD_LU_SEND_KEY1;\n\t\tbreak;\n\n\tcase DVD_HOST_SEND_KEY2:\n\t\tcd_dbg(CD_DVD, \"entering DVD_HOST_SEND_KEY2\\n\");\n\t\tsetup_send_key(&cgc, ai->hsk.agid, 3);\n\t\tbuf[1] = 0xa;\n\t\tcopy_key(&buf[4], ai->hsk.key);\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc))) {\n\t\t\tai->type = DVD_AUTH_FAILURE;\n\t\t\treturn ret;\n\t\t}\n\t\tai->type = DVD_AUTH_ESTABLISHED;\n\t\tbreak;\n\n\t \n\tcase DVD_INVALIDATE_AGID:\n\t\tcgc.quiet = 1;\n\t\tcd_dbg(CD_DVD, \"entering DVD_INVALIDATE_AGID\\n\");\n\t\tsetup_report_key(&cgc, ai->lsa.agid, 0x3f);\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\t\tbreak;\n\n\t \n\tcase DVD_LU_SEND_RPC_STATE:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_RPC_STATE\\n\");\n\t\tsetup_report_key(&cgc, 0, 8);\n\t\tmemset(&rpc_state, 0, sizeof(rpc_state_t));\n\t\tcgc.buffer = (char *) &rpc_state;\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tai->lrpcs.type = rpc_state.type_code;\n\t\tai->lrpcs.vra = rpc_state.vra;\n\t\tai->lrpcs.ucca = rpc_state.ucca;\n\t\tai->lrpcs.region_mask = rpc_state.region_mask;\n\t\tai->lrpcs.rpc_scheme = rpc_state.rpc_scheme;\n\t\tbreak;\n\n\t \n\tcase DVD_HOST_SEND_RPC_STATE:\n\t\tcd_dbg(CD_DVD, \"entering DVD_HOST_SEND_RPC_STATE\\n\");\n\t\tsetup_send_key(&cgc, 0, 6);\n\t\tbuf[1] = 6;\n\t\tbuf[4] = ai->hrpcs.pdrc;\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\t\tbreak;\n\n\tdefault:\n\t\tcd_dbg(CD_WARNING, \"Invalid DVD key ioctl (%d)\\n\", ai->type);\n\t\treturn -ENOTTY;\n\t}\n\n\treturn 0;\n}\n\nstatic int dvd_read_physical(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\t\tstruct packet_command *cgc)\n{\n\tunsigned char buf[21], *base;\n\tstruct dvd_layer *layer;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tint ret, layer_num = s->physical.layer_num;\n\n\tif (layer_num >= DVD_LAYERS)\n\t\treturn -EINVAL;\n\n\tinit_cdrom_command(cgc, buf, sizeof(buf), CGC_DATA_READ);\n\tcgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\n\tcgc->cmd[6] = layer_num;\n\tcgc->cmd[7] = s->type;\n\tcgc->cmd[9] = cgc->buflen & 0xff;\n\n\t \n\tcgc->quiet = 1;\n\n\tret = cdo->generic_packet(cdi, cgc);\n\tif (ret)\n\t\treturn ret;\n\n\tbase = &buf[4];\n\tlayer = &s->physical.layer[layer_num];\n\n\t \n\tmemset(layer, 0, sizeof(*layer));\n\tlayer->book_version = base[0] & 0xf;\n\tlayer->book_type = base[0] >> 4;\n\tlayer->min_rate = base[1] & 0xf;\n\tlayer->disc_size = base[1] >> 4;\n\tlayer->layer_type = base[2] & 0xf;\n\tlayer->track_path = (base[2] >> 4) & 1;\n\tlayer->nlayers = (base[2] >> 5) & 3;\n\tlayer->track_density = base[3] & 0xf;\n\tlayer->linear_density = base[3] >> 4;\n\tlayer->start_sector = base[5] << 16 | base[6] << 8 | base[7];\n\tlayer->end_sector = base[9] << 16 | base[10] << 8 | base[11];\n\tlayer->end_sector_l0 = base[13] << 16 | base[14] << 8 | base[15];\n\tlayer->bca = base[16] >> 7;\n\n\treturn 0;\n}\n\nstatic int dvd_read_copyright(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\t\tstruct packet_command *cgc)\n{\n\tint ret;\n\tu_char buf[8];\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tinit_cdrom_command(cgc, buf, sizeof(buf), CGC_DATA_READ);\n\tcgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\n\tcgc->cmd[6] = s->copyright.layer_num;\n\tcgc->cmd[7] = s->type;\n\tcgc->cmd[8] = cgc->buflen >> 8;\n\tcgc->cmd[9] = cgc->buflen & 0xff;\n\n\tret = cdo->generic_packet(cdi, cgc);\n\tif (ret)\n\t\treturn ret;\n\n\ts->copyright.cpst = buf[4];\n\ts->copyright.rmi = buf[5];\n\n\treturn 0;\n}\n\nstatic int dvd_read_disckey(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\t\tstruct packet_command *cgc)\n{\n\tint ret, size;\n\tu_char *buf;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tsize = sizeof(s->disckey.value) + 4;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tinit_cdrom_command(cgc, buf, size, CGC_DATA_READ);\n\tcgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\n\tcgc->cmd[7] = s->type;\n\tcgc->cmd[8] = size >> 8;\n\tcgc->cmd[9] = size & 0xff;\n\tcgc->cmd[10] = s->disckey.agid << 6;\n\n\tret = cdo->generic_packet(cdi, cgc);\n\tif (!ret)\n\t\tmemcpy(s->disckey.value, &buf[4], sizeof(s->disckey.value));\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int dvd_read_bca(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\tstruct packet_command *cgc)\n{\n\tint ret, size = 4 + 188;\n\tu_char *buf;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tinit_cdrom_command(cgc, buf, size, CGC_DATA_READ);\n\tcgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\n\tcgc->cmd[7] = s->type;\n\tcgc->cmd[9] = cgc->buflen & 0xff;\n\n\tret = cdo->generic_packet(cdi, cgc);\n\tif (ret)\n\t\tgoto out;\n\n\ts->bca.len = buf[0] << 8 | buf[1];\n\tif (s->bca.len < 12 || s->bca.len > 188) {\n\t\tcd_dbg(CD_WARNING, \"Received invalid BCA length (%d)\\n\",\n\t\t       s->bca.len);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tmemcpy(s->bca.value, &buf[4], s->bca.len);\n\tret = 0;\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int dvd_read_manufact(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\t\tstruct packet_command *cgc)\n{\n\tint ret = 0, size;\n\tu_char *buf;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tsize = sizeof(s->manufact.value) + 4;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tinit_cdrom_command(cgc, buf, size, CGC_DATA_READ);\n\tcgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\n\tcgc->cmd[7] = s->type;\n\tcgc->cmd[8] = size >> 8;\n\tcgc->cmd[9] = size & 0xff;\n\n\tret = cdo->generic_packet(cdi, cgc);\n\tif (ret)\n\t\tgoto out;\n\n\ts->manufact.len = buf[0] << 8 | buf[1];\n\tif (s->manufact.len < 0) {\n\t\tcd_dbg(CD_WARNING, \"Received invalid manufacture info length (%d)\\n\",\n\t\t       s->manufact.len);\n\t\tret = -EIO;\n\t} else {\n\t\tif (s->manufact.len > 2048) {\n\t\t\tcd_dbg(CD_WARNING, \"Received invalid manufacture info length (%d): truncating to 2048\\n\",\n\t\t\t       s->manufact.len);\n\t\t\ts->manufact.len = 2048;\n\t\t}\n\t\tmemcpy(s->manufact.value, &buf[4], s->manufact.len);\n\t}\n\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int dvd_read_struct(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\t\tstruct packet_command *cgc)\n{\n\tswitch (s->type) {\n\tcase DVD_STRUCT_PHYSICAL:\n\t\treturn dvd_read_physical(cdi, s, cgc);\n\n\tcase DVD_STRUCT_COPYRIGHT:\n\t\treturn dvd_read_copyright(cdi, s, cgc);\n\n\tcase DVD_STRUCT_DISCKEY:\n\t\treturn dvd_read_disckey(cdi, s, cgc);\n\n\tcase DVD_STRUCT_BCA:\n\t\treturn dvd_read_bca(cdi, s, cgc);\n\n\tcase DVD_STRUCT_MANUFACT:\n\t\treturn dvd_read_manufact(cdi, s, cgc);\n\t\t\n\tdefault:\n\t\tcd_dbg(CD_WARNING, \": Invalid DVD structure read requested (%d)\\n\",\n\t\t       s->type);\n\t\treturn -EINVAL;\n\t}\n}\n\nint cdrom_mode_sense(struct cdrom_device_info *cdi,\n\t\t     struct packet_command *cgc,\n\t\t     int page_code, int page_control)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tmemset(cgc->cmd, 0, sizeof(cgc->cmd));\n\n\tcgc->cmd[0] = GPCMD_MODE_SENSE_10;\n\tcgc->cmd[2] = page_code | (page_control << 6);\n\tcgc->cmd[7] = cgc->buflen >> 8;\n\tcgc->cmd[8] = cgc->buflen & 0xff;\n\tcgc->data_direction = CGC_DATA_READ;\n\treturn cdo->generic_packet(cdi, cgc);\n}\nEXPORT_SYMBOL(cdrom_mode_sense);\n\nint cdrom_mode_select(struct cdrom_device_info *cdi,\n\t\t      struct packet_command *cgc)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tmemset(cgc->cmd, 0, sizeof(cgc->cmd));\n\tmemset(cgc->buffer, 0, 2);\n\tcgc->cmd[0] = GPCMD_MODE_SELECT_10;\n\tcgc->cmd[1] = 0x10;\t\t \n\tcgc->cmd[7] = cgc->buflen >> 8;\n\tcgc->cmd[8] = cgc->buflen & 0xff;\n\tcgc->data_direction = CGC_DATA_WRITE;\n\treturn cdo->generic_packet(cdi, cgc);\n}\nEXPORT_SYMBOL(cdrom_mode_select);\n\nstatic int cdrom_read_subchannel(struct cdrom_device_info *cdi,\n\t\t\t\t struct cdrom_subchnl *subchnl, int mcn)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct packet_command cgc;\n\tchar buffer[32];\n\tint ret;\n\n\tinit_cdrom_command(&cgc, buffer, 16, CGC_DATA_READ);\n\tcgc.cmd[0] = GPCMD_READ_SUBCHANNEL;\n\tcgc.cmd[1] = subchnl->cdsc_format; \n\tcgc.cmd[2] = 0x40;   \n\tcgc.cmd[3] = mcn ? 2 : 1;\n\tcgc.cmd[8] = 16;\n\n\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\treturn ret;\n\n\tsubchnl->cdsc_audiostatus = cgc.buffer[1];\n\tsubchnl->cdsc_ctrl = cgc.buffer[5] & 0xf;\n\tsubchnl->cdsc_trk = cgc.buffer[6];\n\tsubchnl->cdsc_ind = cgc.buffer[7];\n\n\tif (subchnl->cdsc_format == CDROM_LBA) {\n\t\tsubchnl->cdsc_absaddr.lba = ((cgc.buffer[8] << 24) |\n\t\t\t\t\t\t(cgc.buffer[9] << 16) |\n\t\t\t\t\t\t(cgc.buffer[10] << 8) |\n\t\t\t\t\t\t(cgc.buffer[11]));\n\t\tsubchnl->cdsc_reladdr.lba = ((cgc.buffer[12] << 24) |\n\t\t\t\t\t\t(cgc.buffer[13] << 16) |\n\t\t\t\t\t\t(cgc.buffer[14] << 8) |\n\t\t\t\t\t\t(cgc.buffer[15]));\n\t} else {\n\t\tsubchnl->cdsc_reladdr.msf.minute = cgc.buffer[13];\n\t\tsubchnl->cdsc_reladdr.msf.second = cgc.buffer[14];\n\t\tsubchnl->cdsc_reladdr.msf.frame = cgc.buffer[15];\n\t\tsubchnl->cdsc_absaddr.msf.minute = cgc.buffer[9];\n\t\tsubchnl->cdsc_absaddr.msf.second = cgc.buffer[10];\n\t\tsubchnl->cdsc_absaddr.msf.frame = cgc.buffer[11];\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cdrom_read_cd(struct cdrom_device_info *cdi,\n\t\t\t struct packet_command *cgc, int lba,\n\t\t\t int blocksize, int nblocks)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tmemset(&cgc->cmd, 0, sizeof(cgc->cmd));\n\tcgc->cmd[0] = GPCMD_READ_10;\n\tcgc->cmd[2] = (lba >> 24) & 0xff;\n\tcgc->cmd[3] = (lba >> 16) & 0xff;\n\tcgc->cmd[4] = (lba >>  8) & 0xff;\n\tcgc->cmd[5] = lba & 0xff;\n\tcgc->cmd[6] = (nblocks >> 16) & 0xff;\n\tcgc->cmd[7] = (nblocks >>  8) & 0xff;\n\tcgc->cmd[8] = nblocks & 0xff;\n\tcgc->buflen = blocksize * nblocks;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\n \nstatic int cdrom_read_block(struct cdrom_device_info *cdi,\n\t\t\t    struct packet_command *cgc,\n\t\t\t    int lba, int nblocks, int format, int blksize)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tmemset(&cgc->cmd, 0, sizeof(cgc->cmd));\n\tcgc->cmd[0] = GPCMD_READ_CD;\n\t \n\tcgc->cmd[1] = format << 2;\n\t \n\tcgc->cmd[2] = (lba >> 24) & 0xff;\n\tcgc->cmd[3] = (lba >> 16) & 0xff;\n\tcgc->cmd[4] = (lba >>  8) & 0xff;\n\tcgc->cmd[5] = lba & 0xff;\n\t \n\tcgc->cmd[6] = (nblocks >> 16) & 0xff;\n\tcgc->cmd[7] = (nblocks >>  8) & 0xff;\n\tcgc->cmd[8] = nblocks & 0xff;\n\tcgc->buflen = blksize * nblocks;\n\t\n\t \n\tswitch (blksize) {\n\tcase CD_FRAMESIZE_RAW0\t: cgc->cmd[9] = 0x58; break;\n\tcase CD_FRAMESIZE_RAW1\t: cgc->cmd[9] = 0x78; break;\n\tcase CD_FRAMESIZE_RAW\t: cgc->cmd[9] = 0xf8; break;\n\tdefault\t\t\t: cgc->cmd[9] = 0x10;\n\t}\n\t\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic int cdrom_read_cdda_old(struct cdrom_device_info *cdi, __u8 __user *ubuf,\n\t\t\t       int lba, int nframes)\n{\n\tstruct packet_command cgc;\n\tint ret = 0;\n\tint nr;\n\n\tcdi->last_sense = 0;\n\n\tmemset(&cgc, 0, sizeof(cgc));\n\n\t \n\tnr = nframes;\n\tdo {\n\t\tcgc.buffer = kmalloc_array(nr, CD_FRAMESIZE_RAW, GFP_KERNEL);\n\t\tif (cgc.buffer)\n\t\t\tbreak;\n\n\t\tnr >>= 1;\n\t} while (nr);\n\n\tif (!nr)\n\t\treturn -ENOMEM;\n\n\tcgc.data_direction = CGC_DATA_READ;\n\twhile (nframes > 0) {\n\t\tif (nr > nframes)\n\t\t\tnr = nframes;\n\n\t\tret = cdrom_read_block(cdi, &cgc, lba, nr, 1, CD_FRAMESIZE_RAW);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (copy_to_user(ubuf, cgc.buffer, CD_FRAMESIZE_RAW * nr)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tubuf += CD_FRAMESIZE_RAW * nr;\n\t\tnframes -= nr;\n\t\tlba += nr;\n\t}\n\tkfree(cgc.buffer);\n\treturn ret;\n}\n\nstatic int cdrom_read_cdda_bpc(struct cdrom_device_info *cdi, __u8 __user *ubuf,\n\t\t\t       int lba, int nframes)\n{\n\tint max_frames = (queue_max_sectors(cdi->disk->queue) << 9) /\n\t\t\t  CD_FRAMESIZE_RAW;\n\tint nr, ret = 0;\n\n\tcdi->last_sense = 0;\n\n\twhile (nframes) {\n\t\tif (cdi->cdda_method == CDDA_BPC_SINGLE)\n\t\t\tnr = 1;\n\t\telse\n\t\t\tnr = min(nframes, max_frames);\n\n\t\tret = cdi->ops->read_cdda_bpc(cdi, ubuf, lba, nr,\n\t\t\t\t\t      &cdi->last_sense);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tnframes -= nr;\n\t\tlba += nr;\n\t\tubuf += (nr * CD_FRAMESIZE_RAW);\n\t}\n\n\treturn ret;\n}\n\nstatic int cdrom_read_cdda(struct cdrom_device_info *cdi, __u8 __user *ubuf,\n\t\t\t   int lba, int nframes)\n{\n\tint ret;\n\n\tif (cdi->cdda_method == CDDA_OLD)\n\t\treturn cdrom_read_cdda_old(cdi, ubuf, lba, nframes);\n\nretry:\n\t \n\tret = cdrom_read_cdda_bpc(cdi, ubuf, lba, nframes);\n\tif (!ret || ret != -EIO)\n\t\treturn ret;\n\n\t \n\tif (cdi->cdda_method == CDDA_BPC_FULL && nframes > 1) {\n\t\tpr_info(\"dropping to single frame dma\\n\");\n\t\tcdi->cdda_method = CDDA_BPC_SINGLE;\n\t\tgoto retry;\n\t}\n\n\t \n\tif (cdi->last_sense != 0x04 && cdi->last_sense != 0x0b)\n\t\treturn ret;\n\n\tpr_info(\"dropping to old style cdda (sense=%x)\\n\", cdi->last_sense);\n\tcdi->cdda_method = CDDA_OLD;\n\treturn cdrom_read_cdda_old(cdi, ubuf, lba, nframes);\t\n}\n\nint cdrom_multisession(struct cdrom_device_info *cdi,\n\t\tstruct cdrom_multisession *info)\n{\n\tu8 requested_format;\n\tint ret;\n\n\tif (!(cdi->ops->capability & CDC_MULTI_SESSION))\n\t\treturn -ENOSYS;\n\n\trequested_format = info->addr_format;\n\tif (requested_format != CDROM_MSF && requested_format != CDROM_LBA)\n\t\treturn -EINVAL;\n\tinfo->addr_format = CDROM_LBA;\n\n\tret = cdi->ops->get_last_session(cdi, info);\n\tif (!ret)\n\t\tsanitize_format(&info->addr, &info->addr_format,\n\t\t\t\trequested_format);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cdrom_multisession);\n\nstatic int cdrom_ioctl_multisession(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_multisession info;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMMULTISESSION\\n\");\n\n\tif (copy_from_user(&info, argp, sizeof(info)))\n\t\treturn -EFAULT;\n\tret = cdrom_multisession(cdi, &info);\n\tif (ret)\n\t\treturn ret;\n\tif (copy_to_user(argp, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tcd_dbg(CD_DO_IOCTL, \"CDROMMULTISESSION successful\\n\");\n\treturn ret;\n}\n\nstatic int cdrom_ioctl_eject(struct cdrom_device_info *cdi)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMEJECT\\n\");\n\n\tif (!CDROM_CAN(CDC_OPEN_TRAY))\n\t\treturn -ENOSYS;\n\tif (cdi->use_count != 1 || cdi->keeplocked)\n\t\treturn -EBUSY;\n\tif (CDROM_CAN(CDC_LOCK)) {\n\t\tint ret = cdi->ops->lock_door(cdi, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn cdi->ops->tray_move(cdi, 1);\n}\n\nstatic int cdrom_ioctl_closetray(struct cdrom_device_info *cdi)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMCLOSETRAY\\n\");\n\n\tif (!CDROM_CAN(CDC_CLOSE_TRAY))\n\t\treturn -ENOSYS;\n\treturn cdi->ops->tray_move(cdi, 0);\n}\n\nstatic int cdrom_ioctl_eject_sw(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMEJECT_SW\\n\");\n\n\tif (!CDROM_CAN(CDC_OPEN_TRAY))\n\t\treturn -ENOSYS;\n\tif (cdi->keeplocked)\n\t\treturn -EBUSY;\n\n\tcdi->options &= ~(CDO_AUTO_CLOSE | CDO_AUTO_EJECT);\n\tif (arg)\n\t\tcdi->options |= CDO_AUTO_CLOSE | CDO_AUTO_EJECT;\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\n\t \n\tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n\t\treturn media_changed(cdi, 1);\n\n\tif (arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\n\t \n\tbarrier_nospec();\n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}\n\n \nstatic int cdrom_ioctl_timed_media_change(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tint ret;\n\tstruct cdrom_timed_media_change_info __user *info;\n\tstruct cdrom_timed_media_change_info tmp_info;\n\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\n\tinfo = (struct cdrom_timed_media_change_info __user *)arg;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_TIMED_MEDIA_CHANGE\\n\");\n\n\tret = cdrom_ioctl_media_changed(cdi, CDSL_CURRENT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_from_user(&tmp_info, info, sizeof(tmp_info)) != 0)\n\t\treturn -EFAULT;\n\n\ttmp_info.media_flags = 0;\n\tif (tmp_info.last_media_change - cdi->last_media_change_ms < 0)\n\t\ttmp_info.media_flags |= MEDIA_CHANGED_FLAG;\n\n\ttmp_info.last_media_change = cdi->last_media_change_ms;\n\n\tif (copy_to_user(info, &tmp_info, sizeof(*info)) != 0)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_set_options(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SET_OPTIONS\\n\");\n\n\t \n\tswitch (arg) {\n\tcase CDO_USE_FFLAGS:\n\tcase CDO_CHECK_TYPE:\n\t\tbreak;\n\tcase CDO_LOCK:\n\t\tif (!CDROM_CAN(CDC_LOCK))\n\t\t\treturn -ENOSYS;\n\t\tbreak;\n\tcase 0:\n\t\treturn cdi->options;\n\t \n\tdefault:\n\t\tif (!CDROM_CAN(arg))\n\t\t\treturn -ENOSYS;\n\t}\n\tcdi->options |= (int) arg;\n\treturn cdi->options;\n}\n\nstatic int cdrom_ioctl_clear_options(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_CLEAR_OPTIONS\\n\");\n\n\tcdi->options &= ~(int) arg;\n\treturn cdi->options;\n}\n\nstatic int cdrom_ioctl_select_speed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_SPEED\\n\");\n\n\tif (!CDROM_CAN(CDC_SELECT_SPEED))\n\t\treturn -ENOSYS;\n\treturn cdi->ops->select_speed(cdi, arg);\n}\n\nstatic int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -ENOSYS;\n\n\tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif (arg >= cdi->capacity)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}\n\nstatic int cdrom_ioctl_reset(struct cdrom_device_info *cdi,\n\t\tstruct block_device *bdev)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_RESET\\n\");\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\tif (!CDROM_CAN(CDC_RESET))\n\t\treturn -ENOSYS;\n\tinvalidate_bdev(bdev);\n\treturn cdi->ops->reset(cdi);\n}\n\nstatic int cdrom_ioctl_lock_door(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"%socking door\\n\", arg ? \"L\" : \"Unl\");\n\n\tif (!CDROM_CAN(CDC_LOCK))\n\t\treturn -EDRIVE_CANT_DO_THIS;\n\n\tcdi->keeplocked = arg ? 1 : 0;\n\n\t \n\tif (cdi->use_count != 1 && !arg && !capable(CAP_SYS_ADMIN))\n\t\treturn -EBUSY;\n\treturn cdi->ops->lock_door(cdi, arg);\n}\n\nstatic int cdrom_ioctl_debug(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"%sabling debug\\n\", arg ? \"En\" : \"Dis\");\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\tdebug = arg ? 1 : 0;\n\treturn debug;\n}\n\nstatic int cdrom_ioctl_get_capability(struct cdrom_device_info *cdi)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_GET_CAPABILITY\\n\");\n\treturn (cdi->ops->capability & ~cdi->mask);\n}\n\n \nstatic int cdrom_ioctl_get_mcn(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_mcn mcn;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_GET_MCN\\n\");\n\n\tif (!(cdi->ops->capability & CDC_MCN))\n\t\treturn -ENOSYS;\n\tret = cdi->ops->get_mcn(cdi, &mcn);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &mcn, sizeof(mcn)))\n\t\treturn -EFAULT;\n\tcd_dbg(CD_DO_IOCTL, \"CDROM_GET_MCN successful\\n\");\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DRIVE_STATUS\\n\");\n\n\tif (!(cdi->ops->capability & CDC_DRIVE_STATUS))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) ||\n\t    (arg == CDSL_CURRENT || arg == CDSL_NONE))\n\t\treturn cdi->ops->drive_status(cdi, CDSL_CURRENT);\n\tif (arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\treturn cdrom_slot_status(cdi, arg);\n}\n\n \nstatic int cdrom_ioctl_disc_status(struct cdrom_device_info *cdi)\n{\n\ttracktype tracks;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DISC_STATUS\\n\");\n\n\tcdrom_count_tracks(cdi, &tracks);\n\tif (tracks.error)\n\t\treturn tracks.error;\n\n\t \n\tif (tracks.audio > 0) {\n\t\tif (!tracks.data && !tracks.cdi && !tracks.xa)\n\t\t\treturn CDS_AUDIO;\n\t\telse\n\t\t\treturn CDS_MIXED;\n\t}\n\n\tif (tracks.cdi > 0)\n\t\treturn CDS_XA_2_2;\n\tif (tracks.xa > 0)\n\t\treturn CDS_XA_2_1;\n\tif (tracks.data > 0)\n\t\treturn CDS_DATA_1;\n\t \n\n\tcd_dbg(CD_WARNING, \"This disc doesn't have any tracks I recognize!\\n\");\n\treturn CDS_NO_INFO;\n}\n\nstatic int cdrom_ioctl_changer_nslots(struct cdrom_device_info *cdi)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_CHANGER_NSLOTS\\n\");\n\treturn cdi->capacity;\n}\n\nstatic int cdrom_ioctl_get_subchnl(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_subchnl q;\n\tu8 requested, back;\n\tint ret;\n\n\t \n\n\tif (copy_from_user(&q, argp, sizeof(q)))\n\t\treturn -EFAULT;\n\n\trequested = q.cdsc_format;\n\tif (requested != CDROM_MSF && requested != CDROM_LBA)\n\t\treturn -EINVAL;\n\tq.cdsc_format = CDROM_MSF;\n\n\tret = cdi->ops->audio_ioctl(cdi, CDROMSUBCHNL, &q);\n\tif (ret)\n\t\treturn ret;\n\n\tback = q.cdsc_format;  \n\tsanitize_format(&q.cdsc_absaddr, &back, requested);\n\tsanitize_format(&q.cdsc_reladdr, &q.cdsc_format, requested);\n\n\tif (copy_to_user(argp, &q, sizeof(q)))\n\t\treturn -EFAULT;\n\t \n\treturn 0;\n}\n\nstatic int cdrom_ioctl_read_tochdr(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_tochdr header;\n\tint ret;\n\n\t \n\n\tif (copy_from_user(&header, argp, sizeof(header)))\n\t\treturn -EFAULT;\n\n\tret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCHDR, &header);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &header, sizeof(header)))\n\t\treturn -EFAULT;\n\t \n\treturn 0;\n}\n\nint cdrom_read_tocentry(struct cdrom_device_info *cdi,\n\t\tstruct cdrom_tocentry *entry)\n{\n\tu8 requested_format = entry->cdte_format;\n\tint ret;\n\n\tif (requested_format != CDROM_MSF && requested_format != CDROM_LBA)\n\t\treturn -EINVAL;\n\n\t \n\tentry->cdte_format = CDROM_MSF;\n\tret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCENTRY, entry);\n\tif (!ret)\n\t\tsanitize_format(&entry->cdte_addr, &entry->cdte_format,\n\t\t\t\trequested_format);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cdrom_read_tocentry);\n\nstatic int cdrom_ioctl_read_tocentry(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_tocentry entry;\n\tint ret;\n\n\tif (copy_from_user(&entry, argp, sizeof(entry)))\n\t\treturn -EFAULT;\n\tret = cdrom_read_tocentry(cdi, &entry);\n\tif (!ret && copy_to_user(argp, &entry, sizeof(entry)))\n\t\treturn -EFAULT;\n\treturn ret;\n}\n\nstatic int cdrom_ioctl_play_msf(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_msf msf;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPLAYMSF\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\tif (copy_from_user(&msf, argp, sizeof(msf)))\n\t\treturn -EFAULT;\n\treturn cdi->ops->audio_ioctl(cdi, CDROMPLAYMSF, &msf);\n}\n\nstatic int cdrom_ioctl_play_trkind(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_ti ti;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPLAYTRKIND\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\tif (copy_from_user(&ti, argp, sizeof(ti)))\n\t\treturn -EFAULT;\n\n\tret = check_for_audio_disc(cdi, cdi->ops);\n\tif (ret)\n\t\treturn ret;\n\treturn cdi->ops->audio_ioctl(cdi, CDROMPLAYTRKIND, &ti);\n}\nstatic int cdrom_ioctl_volctrl(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_volctrl volume;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMVOLCTRL\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\tif (copy_from_user(&volume, argp, sizeof(volume)))\n\t\treturn -EFAULT;\n\treturn cdi->ops->audio_ioctl(cdi, CDROMVOLCTRL, &volume);\n}\n\nstatic int cdrom_ioctl_volread(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_volctrl volume;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMVOLREAD\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\n\tret = cdi->ops->audio_ioctl(cdi, CDROMVOLREAD, &volume);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &volume, sizeof(volume)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_audioctl(struct cdrom_device_info *cdi,\n\t\tunsigned int cmd)\n{\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"doing audio ioctl (start/stop/pause/resume)\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\tret = check_for_audio_disc(cdi, cdi->ops);\n\tif (ret)\n\t\treturn ret;\n\treturn cdi->ops->audio_ioctl(cdi, cmd, NULL);\n}\n\n \nstatic int cdrom_switch_blocksize(struct cdrom_device_info *cdi, int size)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct packet_command cgc;\n\tstruct modesel_head mh;\n\n\tmemset(&mh, 0, sizeof(mh));\n\tmh.block_desc_length = 0x08;\n\tmh.block_length_med = (size >> 8) & 0xff;\n\tmh.block_length_lo = size & 0xff;\n\n\tmemset(&cgc, 0, sizeof(cgc));\n\tcgc.cmd[0] = 0x15;\n\tcgc.cmd[1] = 1 << 4;\n\tcgc.cmd[4] = 12;\n\tcgc.buflen = sizeof(mh);\n\tcgc.buffer = (char *) &mh;\n\tcgc.data_direction = CGC_DATA_WRITE;\n\tmh.block_desc_length = 0x08;\n\tmh.block_length_med = (size >> 8) & 0xff;\n\tmh.block_length_lo = size & 0xff;\n\n\treturn cdo->generic_packet(cdi, &cgc);\n}\n\nstatic int cdrom_get_track_info(struct cdrom_device_info *cdi,\n\t\t\t\t__u16 track, __u8 type, track_information *ti)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct packet_command cgc;\n\tint ret, buflen;\n\n\tinit_cdrom_command(&cgc, ti, 8, CGC_DATA_READ);\n\tcgc.cmd[0] = GPCMD_READ_TRACK_RZONE_INFO;\n\tcgc.cmd[1] = type & 3;\n\tcgc.cmd[4] = (track & 0xff00) >> 8;\n\tcgc.cmd[5] = track & 0xff;\n\tcgc.cmd[8] = 8;\n\tcgc.quiet = 1;\n\n\tret = cdo->generic_packet(cdi, &cgc);\n\tif (ret)\n\t\treturn ret;\n\n\tbuflen = be16_to_cpu(ti->track_information_length) +\n\t\tsizeof(ti->track_information_length);\n\n\tif (buflen > sizeof(track_information))\n\t\tbuflen = sizeof(track_information);\n\n\tcgc.cmd[8] = cgc.buflen = buflen;\n\tret = cdo->generic_packet(cdi, &cgc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn buflen;\n}\n\n \nint cdrom_get_last_written(struct cdrom_device_info *cdi, long *last_written)\n{\n\tstruct cdrom_tocentry toc;\n\tdisc_information di;\n\ttrack_information ti;\n\t__u32 last_track;\n\tint ret = -1, ti_size;\n\n\tif (!CDROM_CAN(CDC_GENERIC_PACKET))\n\t\tgoto use_toc;\n\n\tret = cdrom_get_disc_info(cdi, &di);\n\tif (ret < (int)(offsetof(typeof(di), last_track_lsb)\n\t\t\t+ sizeof(di.last_track_lsb)))\n\t\tgoto use_toc;\n\n\t \n\tlast_track = (di.last_track_msb << 8) | di.last_track_lsb;\n\tti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\n\tif (ti_size < (int)offsetof(typeof(ti), track_start))\n\t\tgoto use_toc;\n\n\t \n\tif (ti.blank) {\n\t\tif (last_track == 1)\n\t\t\tgoto use_toc;\n\t\tlast_track--;\n\t\tti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\n\t}\n\n\tif (ti_size < (int)(offsetof(typeof(ti), track_size)\n\t\t\t\t+ sizeof(ti.track_size)))\n\t\tgoto use_toc;\n\n\t \n\tif (ti.lra_v && ti_size >= (int)(offsetof(typeof(ti), last_rec_address)\n\t\t\t\t+ sizeof(ti.last_rec_address))) {\n\t\t*last_written = be32_to_cpu(ti.last_rec_address);\n\t} else {\n\t\t \n\t\t*last_written = be32_to_cpu(ti.track_start) +\n\t\t\t\tbe32_to_cpu(ti.track_size);\n\t\tif (ti.free_blocks)\n\t\t\t*last_written -= (be32_to_cpu(ti.free_blocks) + 7);\n\t}\n\treturn 0;\n\n\t \nuse_toc:\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\n\ttoc.cdte_format = CDROM_MSF;\n\ttoc.cdte_track = CDROM_LEADOUT;\n\tif ((ret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCENTRY, &toc)))\n\t\treturn ret;\n\tsanitize_format(&toc.cdte_addr, &toc.cdte_format, CDROM_LBA);\n\t*last_written = toc.cdte_addr.lba;\n\treturn 0;\n}\nEXPORT_SYMBOL(cdrom_get_last_written);\n\n \nstatic int cdrom_get_next_writable(struct cdrom_device_info *cdi,\n\t\t\t\t   long *next_writable)\n{\n\tdisc_information di;\n\ttrack_information ti;\n\t__u16 last_track;\n\tint ret, ti_size;\n\n\tif (!CDROM_CAN(CDC_GENERIC_PACKET))\n\t\tgoto use_last_written;\n\n\tret = cdrom_get_disc_info(cdi, &di);\n\tif (ret < 0 || ret < offsetof(typeof(di), last_track_lsb)\n\t\t\t\t+ sizeof(di.last_track_lsb))\n\t\tgoto use_last_written;\n\n\t \n\tlast_track = (di.last_track_msb << 8) | di.last_track_lsb;\n\tti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\n\tif (ti_size < 0 || ti_size < offsetof(typeof(ti), track_start))\n\t\tgoto use_last_written;\n\n\t \n\tif (ti.blank) {\n\t\tif (last_track == 1)\n\t\t\tgoto use_last_written;\n\t\tlast_track--;\n\t\tti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\n\t\tif (ti_size < 0)\n\t\t\tgoto use_last_written;\n\t}\n\n\t \n\tif (ti.nwa_v && ti_size >= offsetof(typeof(ti), next_writable)\n\t\t\t\t+ sizeof(ti.next_writable)) {\n\t\t*next_writable = be32_to_cpu(ti.next_writable);\n\t\treturn 0;\n\t}\n\nuse_last_written:\n\tret = cdrom_get_last_written(cdi, next_writable);\n\tif (ret) {\n\t\t*next_writable = 0;\n\t\treturn ret;\n\t} else {\n\t\t*next_writable += 7;\n\t\treturn 0;\n\t}\n}\n\nstatic noinline int mmc_ioctl_cdrom_read_data(struct cdrom_device_info *cdi,\n\t\t\t\t\t      void __user *arg,\n\t\t\t\t\t      struct packet_command *cgc,\n\t\t\t\t\t      int cmd)\n{\n\tstruct scsi_sense_hdr sshdr;\n\tstruct cdrom_msf msf;\n\tint blocksize = 0, format = 0, lba;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase CDROMREADRAW:\n\t\tblocksize = CD_FRAMESIZE_RAW;\n\t\tbreak;\n\tcase CDROMREADMODE1:\n\t\tblocksize = CD_FRAMESIZE;\n\t\tformat = 2;\n\t\tbreak;\n\tcase CDROMREADMODE2:\n\t\tblocksize = CD_FRAMESIZE_RAW0;\n\t\tbreak;\n\t}\n\tif (copy_from_user(&msf, (struct cdrom_msf __user *)arg, sizeof(msf)))\n\t\treturn -EFAULT;\n\tlba = msf_to_lba(msf.cdmsf_min0, msf.cdmsf_sec0, msf.cdmsf_frame0);\n\t \n\tif (lba < 0)\n\t\treturn -EINVAL;\n\n\tcgc->buffer = kzalloc(blocksize, GFP_KERNEL);\n\tif (cgc->buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tmemset(&sshdr, 0, sizeof(sshdr));\n\tcgc->sshdr = &sshdr;\n\tcgc->data_direction = CGC_DATA_READ;\n\tret = cdrom_read_block(cdi, cgc, lba, 1, format, blocksize);\n\tif (ret && sshdr.sense_key == 0x05 &&\n\t    sshdr.asc == 0x20 &&\n\t    sshdr.ascq == 0x00) {\n\t\t \n\t\tif (blocksize != CD_FRAMESIZE) {\n\t\t\tret = cdrom_switch_blocksize(cdi, blocksize);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\tcgc->sshdr = NULL;\n\t\tret = cdrom_read_cd(cdi, cgc, lba, blocksize, 1);\n\t\tif (blocksize != CD_FRAMESIZE)\n\t\t\tret |= cdrom_switch_blocksize(cdi, CD_FRAMESIZE);\n\t}\n\tif (!ret && copy_to_user(arg, cgc->buffer, blocksize))\n\t\tret = -EFAULT;\nout:\n\tkfree(cgc->buffer);\n\treturn ret;\n}\n\nstatic noinline int mmc_ioctl_cdrom_read_audio(struct cdrom_device_info *cdi,\n\t\t\t\t\t       void __user *arg)\n{\n\tstruct cdrom_read_audio ra;\n\tint lba;\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_cdrom_read_audio {\n\t\t\tunion cdrom_addr\taddr;\n\t\t\tu8\t\t\taddr_format;\n\t\t\tcompat_int_t\t\tnframes;\n\t\t\tcompat_caddr_t\t\tbuf;\n\t\t} ra32;\n\n\t\tif (copy_from_user(&ra32, arg, sizeof(ra32)))\n\t\t\treturn -EFAULT;\n\n\t\tra = (struct cdrom_read_audio) {\n\t\t\t.addr\t\t= ra32.addr,\n\t\t\t.addr_format\t= ra32.addr_format,\n\t\t\t.nframes\t= ra32.nframes,\n\t\t\t.buf\t\t= compat_ptr(ra32.buf),\n\t\t};\n\t} else\n#endif\n\t{\n\t\tif (copy_from_user(&ra, (struct cdrom_read_audio __user *)arg,\n\t\t\t\t   sizeof(ra)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (ra.addr_format == CDROM_MSF)\n\t\tlba = msf_to_lba(ra.addr.msf.minute,\n\t\t\t\t ra.addr.msf.second,\n\t\t\t\t ra.addr.msf.frame);\n\telse if (ra.addr_format == CDROM_LBA)\n\t\tlba = ra.addr.lba;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tif (lba < 0 || ra.nframes <= 0 || ra.nframes > CD_FRAMES)\n\t\treturn -EINVAL;\n\n\treturn cdrom_read_cdda(cdi, ra.buf, lba, ra.nframes);\n}\n\nstatic noinline int mmc_ioctl_cdrom_subchannel(struct cdrom_device_info *cdi,\n\t\t\t\t\t       void __user *arg)\n{\n\tint ret;\n\tstruct cdrom_subchnl q;\n\tu_char requested, back;\n\tif (copy_from_user(&q, (struct cdrom_subchnl __user *)arg, sizeof(q)))\n\t\treturn -EFAULT;\n\trequested = q.cdsc_format;\n\tif (!((requested == CDROM_MSF) ||\n\t      (requested == CDROM_LBA)))\n\t\treturn -EINVAL;\n\n\tret = cdrom_read_subchannel(cdi, &q, 0);\n\tif (ret)\n\t\treturn ret;\n\tback = q.cdsc_format;  \n\tsanitize_format(&q.cdsc_absaddr, &back, requested);\n\tsanitize_format(&q.cdsc_reladdr, &q.cdsc_format, requested);\n\tif (copy_to_user((struct cdrom_subchnl __user *)arg, &q, sizeof(q)))\n\t\treturn -EFAULT;\n\t \n\treturn 0;\n}\n\nstatic noinline int mmc_ioctl_cdrom_play_msf(struct cdrom_device_info *cdi,\n\t\t\t\t\t     void __user *arg,\n\t\t\t\t\t     struct packet_command *cgc)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct cdrom_msf msf;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPLAYMSF\\n\");\n\tif (copy_from_user(&msf, (struct cdrom_msf __user *)arg, sizeof(msf)))\n\t\treturn -EFAULT;\n\tcgc->cmd[0] = GPCMD_PLAY_AUDIO_MSF;\n\tcgc->cmd[3] = msf.cdmsf_min0;\n\tcgc->cmd[4] = msf.cdmsf_sec0;\n\tcgc->cmd[5] = msf.cdmsf_frame0;\n\tcgc->cmd[6] = msf.cdmsf_min1;\n\tcgc->cmd[7] = msf.cdmsf_sec1;\n\tcgc->cmd[8] = msf.cdmsf_frame1;\n\tcgc->data_direction = CGC_DATA_NONE;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic noinline int mmc_ioctl_cdrom_play_blk(struct cdrom_device_info *cdi,\n\t\t\t\t\t     void __user *arg,\n\t\t\t\t\t     struct packet_command *cgc)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct cdrom_blk blk;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPLAYBLK\\n\");\n\tif (copy_from_user(&blk, (struct cdrom_blk __user *)arg, sizeof(blk)))\n\t\treturn -EFAULT;\n\tcgc->cmd[0] = GPCMD_PLAY_AUDIO_10;\n\tcgc->cmd[2] = (blk.from >> 24) & 0xff;\n\tcgc->cmd[3] = (blk.from >> 16) & 0xff;\n\tcgc->cmd[4] = (blk.from >>  8) & 0xff;\n\tcgc->cmd[5] = blk.from & 0xff;\n\tcgc->cmd[7] = (blk.len >> 8) & 0xff;\n\tcgc->cmd[8] = blk.len & 0xff;\n\tcgc->data_direction = CGC_DATA_NONE;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic noinline int mmc_ioctl_cdrom_volume(struct cdrom_device_info *cdi,\n\t\t\t\t\t   void __user *arg,\n\t\t\t\t\t   struct packet_command *cgc,\n\t\t\t\t\t   unsigned int cmd)\n{\n\tstruct cdrom_volctrl volctrl;\n\tunsigned char buffer[32];\n\tchar mask[sizeof(buffer)];\n\tunsigned short offset;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMVOLUME\\n\");\n\n\tif (copy_from_user(&volctrl, (struct cdrom_volctrl __user *)arg,\n\t\t\t   sizeof(volctrl)))\n\t\treturn -EFAULT;\n\n\tcgc->buffer = buffer;\n\tcgc->buflen = 24;\n\tret = cdrom_mode_sense(cdi, cgc, GPMODE_AUDIO_CTL_PAGE, 0);\n\tif (ret)\n\t\treturn ret;\n\t\t\n\t \n\toffset = 8 + be16_to_cpu(*(__be16 *)(buffer + 6));\n\n\tif (offset + 16 > sizeof(buffer))\n\t\treturn -E2BIG;\n\n\tif (offset + 16 > cgc->buflen) {\n\t\tcgc->buflen = offset + 16;\n\t\tret = cdrom_mode_sense(cdi, cgc,\n\t\t\t\t       GPMODE_AUDIO_CTL_PAGE, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif ((buffer[offset] & 0x3f) != GPMODE_AUDIO_CTL_PAGE ||\n\t    buffer[offset + 1] < 14)\n\t\treturn -EINVAL;\n\n\t \n\tif (cmd == CDROMVOLREAD) {\n\t\tvolctrl.channel0 = buffer[offset+9];\n\t\tvolctrl.channel1 = buffer[offset+11];\n\t\tvolctrl.channel2 = buffer[offset+13];\n\t\tvolctrl.channel3 = buffer[offset+15];\n\t\tif (copy_to_user((struct cdrom_volctrl __user *)arg, &volctrl,\n\t\t\t\t sizeof(volctrl)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\t\t\n\t \n\tcgc->buffer = mask;\n\tret = cdrom_mode_sense(cdi, cgc, GPMODE_AUDIO_CTL_PAGE, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tbuffer[offset + 9]  = volctrl.channel0 & mask[offset + 9];\n\tbuffer[offset + 11] = volctrl.channel1 & mask[offset + 11];\n\tbuffer[offset + 13] = volctrl.channel2 & mask[offset + 13];\n\tbuffer[offset + 15] = volctrl.channel3 & mask[offset + 15];\n\n\t \n\tcgc->buffer = buffer + offset - 8;\n\tmemset(cgc->buffer, 0, 8);\n\treturn cdrom_mode_select(cdi, cgc);\n}\n\nstatic noinline int mmc_ioctl_cdrom_start_stop(struct cdrom_device_info *cdi,\n\t\t\t\t\t       struct packet_command *cgc,\n\t\t\t\t\t       int cmd)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMSTART/CDROMSTOP\\n\");\n\tcgc->cmd[0] = GPCMD_START_STOP_UNIT;\n\tcgc->cmd[1] = 1;\n\tcgc->cmd[4] = (cmd == CDROMSTART) ? 1 : 0;\n\tcgc->data_direction = CGC_DATA_NONE;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic noinline int mmc_ioctl_cdrom_pause_resume(struct cdrom_device_info *cdi,\n\t\t\t\t\t\t struct packet_command *cgc,\n\t\t\t\t\t\t int cmd)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPAUSE/CDROMRESUME\\n\");\n\tcgc->cmd[0] = GPCMD_PAUSE_RESUME;\n\tcgc->cmd[8] = (cmd == CDROMRESUME) ? 1 : 0;\n\tcgc->data_direction = CGC_DATA_NONE;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic noinline int mmc_ioctl_dvd_read_struct(struct cdrom_device_info *cdi,\n\t\t\t\t\t      void __user *arg,\n\t\t\t\t\t      struct packet_command *cgc)\n{\n\tint ret;\n\tdvd_struct *s;\n\tint size = sizeof(dvd_struct);\n\n\tif (!CDROM_CAN(CDC_DVD))\n\t\treturn -ENOSYS;\n\n\ts = memdup_user(arg, size);\n\tif (IS_ERR(s))\n\t\treturn PTR_ERR(s);\n\n\tcd_dbg(CD_DO_IOCTL, \"entering DVD_READ_STRUCT\\n\");\n\n\tret = dvd_read_struct(cdi, s, cgc);\n\tif (ret)\n\t\tgoto out;\n\n\tif (copy_to_user(arg, s, size))\n\t\tret = -EFAULT;\nout:\n\tkfree(s);\n\treturn ret;\n}\n\nstatic noinline int mmc_ioctl_dvd_auth(struct cdrom_device_info *cdi,\n\t\t\t\t       void __user *arg)\n{\n\tint ret;\n\tdvd_authinfo ai;\n\tif (!CDROM_CAN(CDC_DVD))\n\t\treturn -ENOSYS;\n\tcd_dbg(CD_DO_IOCTL, \"entering DVD_AUTH\\n\");\n\tif (copy_from_user(&ai, (dvd_authinfo __user *)arg, sizeof(ai)))\n\t\treturn -EFAULT;\n\tret = dvd_do_auth(cdi, &ai);\n\tif (ret)\n\t\treturn ret;\n\tif (copy_to_user((dvd_authinfo __user *)arg, &ai, sizeof(ai)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic noinline int mmc_ioctl_cdrom_next_writable(struct cdrom_device_info *cdi,\n\t\t\t\t\t\t  void __user *arg)\n{\n\tint ret;\n\tlong next = 0;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_NEXT_WRITABLE\\n\");\n\tret = cdrom_get_next_writable(cdi, &next);\n\tif (ret)\n\t\treturn ret;\n\tif (copy_to_user((long __user *)arg, &next, sizeof(next)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic noinline int mmc_ioctl_cdrom_last_written(struct cdrom_device_info *cdi,\n\t\t\t\t\t\t void __user *arg)\n{\n\tint ret;\n\tlong last = 0;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_LAST_WRITTEN\\n\");\n\tret = cdrom_get_last_written(cdi, &last);\n\tif (ret)\n\t\treturn ret;\n\tif (in_compat_syscall())\n\t\treturn put_user(last, (__s32 __user *)arg);\n\n\treturn put_user(last, (long __user *)arg);\n}\n\nstatic int mmc_ioctl(struct cdrom_device_info *cdi, unsigned int cmd,\n\t\t     unsigned long arg)\n{\n\tstruct packet_command cgc;\n\tvoid __user *userptr = (void __user *)arg;\n\n\tmemset(&cgc, 0, sizeof(cgc));\n\n\t \n\tswitch (cmd) {\n\tcase CDROMREADRAW:\n\tcase CDROMREADMODE1:\n\tcase CDROMREADMODE2:\n\t\treturn mmc_ioctl_cdrom_read_data(cdi, userptr, &cgc, cmd);\n\tcase CDROMREADAUDIO:\n\t\treturn mmc_ioctl_cdrom_read_audio(cdi, userptr);\n\tcase CDROMSUBCHNL:\n\t\treturn mmc_ioctl_cdrom_subchannel(cdi, userptr);\n\tcase CDROMPLAYMSF:\n\t\treturn mmc_ioctl_cdrom_play_msf(cdi, userptr, &cgc);\n\tcase CDROMPLAYBLK:\n\t\treturn mmc_ioctl_cdrom_play_blk(cdi, userptr, &cgc);\n\tcase CDROMVOLCTRL:\n\tcase CDROMVOLREAD:\n\t\treturn mmc_ioctl_cdrom_volume(cdi, userptr, &cgc, cmd);\n\tcase CDROMSTART:\n\tcase CDROMSTOP:\n\t\treturn mmc_ioctl_cdrom_start_stop(cdi, &cgc, cmd);\n\tcase CDROMPAUSE:\n\tcase CDROMRESUME:\n\t\treturn mmc_ioctl_cdrom_pause_resume(cdi, &cgc, cmd);\n\tcase DVD_READ_STRUCT:\n\t\treturn mmc_ioctl_dvd_read_struct(cdi, userptr, &cgc);\n\tcase DVD_AUTH:\n\t\treturn mmc_ioctl_dvd_auth(cdi, userptr);\n\tcase CDROM_NEXT_WRITABLE:\n\t\treturn mmc_ioctl_cdrom_next_writable(cdi, userptr);\n\tcase CDROM_LAST_WRITTEN:\n\t\treturn mmc_ioctl_cdrom_last_written(cdi, userptr);\n\t}\n\n\treturn -ENOTTY;\n}\n\n \nint cdrom_ioctl(struct cdrom_device_info *cdi, struct block_device *bdev,\n\t\tunsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase CDROMMULTISESSION:\n\t\treturn cdrom_ioctl_multisession(cdi, argp);\n\tcase CDROMEJECT:\n\t\treturn cdrom_ioctl_eject(cdi);\n\tcase CDROMCLOSETRAY:\n\t\treturn cdrom_ioctl_closetray(cdi);\n\tcase CDROMEJECT_SW:\n\t\treturn cdrom_ioctl_eject_sw(cdi, arg);\n\tcase CDROM_MEDIA_CHANGED:\n\t\treturn cdrom_ioctl_media_changed(cdi, arg);\n\tcase CDROM_TIMED_MEDIA_CHANGE:\n\t\treturn cdrom_ioctl_timed_media_change(cdi, arg);\n\tcase CDROM_SET_OPTIONS:\n\t\treturn cdrom_ioctl_set_options(cdi, arg);\n\tcase CDROM_CLEAR_OPTIONS:\n\t\treturn cdrom_ioctl_clear_options(cdi, arg);\n\tcase CDROM_SELECT_SPEED:\n\t\treturn cdrom_ioctl_select_speed(cdi, arg);\n\tcase CDROM_SELECT_DISC:\n\t\treturn cdrom_ioctl_select_disc(cdi, arg);\n\tcase CDROMRESET:\n\t\treturn cdrom_ioctl_reset(cdi, bdev);\n\tcase CDROM_LOCKDOOR:\n\t\treturn cdrom_ioctl_lock_door(cdi, arg);\n\tcase CDROM_DEBUG:\n\t\treturn cdrom_ioctl_debug(cdi, arg);\n\tcase CDROM_GET_CAPABILITY:\n\t\treturn cdrom_ioctl_get_capability(cdi);\n\tcase CDROM_GET_MCN:\n\t\treturn cdrom_ioctl_get_mcn(cdi, argp);\n\tcase CDROM_DRIVE_STATUS:\n\t\treturn cdrom_ioctl_drive_status(cdi, arg);\n\tcase CDROM_DISC_STATUS:\n\t\treturn cdrom_ioctl_disc_status(cdi);\n\tcase CDROM_CHANGER_NSLOTS:\n\t\treturn cdrom_ioctl_changer_nslots(cdi);\n\t}\n\n\t \n\tif (CDROM_CAN(CDC_GENERIC_PACKET)) {\n\t\tret = mmc_ioctl(cdi, cmd, arg);\n\t\tif (ret != -ENOTTY)\n\t\t\treturn ret;\n\t}\n\n\t \n\tswitch (cmd) {\n\tcase CDROMSUBCHNL:\n\t\treturn cdrom_ioctl_get_subchnl(cdi, argp);\n\tcase CDROMREADTOCHDR:\n\t\treturn cdrom_ioctl_read_tochdr(cdi, argp);\n\tcase CDROMREADTOCENTRY:\n\t\treturn cdrom_ioctl_read_tocentry(cdi, argp);\n\tcase CDROMPLAYMSF:\n\t\treturn cdrom_ioctl_play_msf(cdi, argp);\n\tcase CDROMPLAYTRKIND:\n\t\treturn cdrom_ioctl_play_trkind(cdi, argp);\n\tcase CDROMVOLCTRL:\n\t\treturn cdrom_ioctl_volctrl(cdi, argp);\n\tcase CDROMVOLREAD:\n\t\treturn cdrom_ioctl_volread(cdi, argp);\n\tcase CDROMSTART:\n\tcase CDROMSTOP:\n\tcase CDROMPAUSE:\n\tcase CDROMRESUME:\n\t\treturn cdrom_ioctl_audioctl(cdi, cmd);\n\t}\n\n\treturn -ENOSYS;\n}\nEXPORT_SYMBOL(cdrom_ioctl);\n\n#ifdef CONFIG_SYSCTL\n\n#define CDROM_STR_SIZE 1000\n\nstatic struct cdrom_sysctl_settings {\n\tchar\tinfo[CDROM_STR_SIZE];\t \n\tint\tautoclose;\t\t \n\tint\tautoeject;\t\t \n\tint\tdebug;\t\t\t \n\tint\tlock;\t\t\t \n\tint\tcheck;\t\t\t \n} cdrom_sysctl_settings;\n\nenum cdrom_print_option {\n\tCTL_NAME,\n\tCTL_SPEED,\n\tCTL_SLOTS,\n\tCTL_CAPABILITY\n};\n\nstatic int cdrom_print_info(const char *header, int val, char *info,\n\t\t\t\tint *pos, enum cdrom_print_option option)\n{\n\tconst int max_size = sizeof(cdrom_sysctl_settings.info);\n\tstruct cdrom_device_info *cdi;\n\tint ret;\n\n\tret = scnprintf(info + *pos, max_size - *pos, header);\n\tif (!ret)\n\t\treturn 1;\n\n\t*pos += ret;\n\n\tlist_for_each_entry(cdi, &cdrom_list, list) {\n\t\tswitch (option) {\n\t\tcase CTL_NAME:\n\t\t\tret = scnprintf(info + *pos, max_size - *pos,\n\t\t\t\t\t\"\\t%s\", cdi->name);\n\t\t\tbreak;\n\t\tcase CTL_SPEED:\n\t\t\tret = scnprintf(info + *pos, max_size - *pos,\n\t\t\t\t\t\"\\t%d\", cdi->speed);\n\t\t\tbreak;\n\t\tcase CTL_SLOTS:\n\t\t\tret = scnprintf(info + *pos, max_size - *pos,\n\t\t\t\t\t\"\\t%d\", cdi->capacity);\n\t\t\tbreak;\n\t\tcase CTL_CAPABILITY:\n\t\t\tret = scnprintf(info + *pos, max_size - *pos,\n\t\t\t\t\t\"\\t%d\", CDROM_CAN(val) != 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"invalid option%d\\n\", option);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!ret)\n\t\t\treturn 1;\n\t\t*pos += ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdrom_sysctl_info(struct ctl_table *ctl, int write,\n                           void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint pos;\n\tchar *info = cdrom_sysctl_settings.info;\n\tconst int max_size = sizeof(cdrom_sysctl_settings.info);\n\t\n\tif (!*lenp || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&cdrom_mutex);\n\n\tpos = sprintf(info, \"CD-ROM information, \" VERSION \"\\n\");\n\t\n\tif (cdrom_print_info(\"\\ndrive name:\\t\", 0, info, &pos, CTL_NAME))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\ndrive speed:\\t\", 0, info, &pos, CTL_SPEED))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\ndrive # of slots:\", 0, info, &pos, CTL_SLOTS))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan close tray:\\t\",\n\t\t\t\tCDC_CLOSE_TRAY, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan open tray:\\t\",\n\t\t\t\tCDC_OPEN_TRAY, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan lock tray:\\t\",\n\t\t\t\tCDC_LOCK, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan change speed:\",\n\t\t\t\tCDC_SELECT_SPEED, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan select disk:\",\n\t\t\t\tCDC_SELECT_DISC, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan read multisession:\",\n\t\t\t\tCDC_MULTI_SESSION, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan read MCN:\\t\",\n\t\t\t\tCDC_MCN, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nReports media changed:\",\n\t\t\t\tCDC_MEDIA_CHANGED, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan play audio:\\t\",\n\t\t\t\tCDC_PLAY_AUDIO, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write CD-R:\\t\",\n\t\t\t\tCDC_CD_R, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write CD-RW:\",\n\t\t\t\tCDC_CD_RW, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan read DVD:\\t\",\n\t\t\t\tCDC_DVD, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write DVD-R:\",\n\t\t\t\tCDC_DVD_R, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write DVD-RAM:\",\n\t\t\t\tCDC_DVD_RAM, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan read MRW:\\t\",\n\t\t\t\tCDC_MRW, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write MRW:\\t\",\n\t\t\t\tCDC_MRW_W, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write RAM:\\t\",\n\t\t\t\tCDC_RAM, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (!scnprintf(info + pos, max_size - pos, \"\\n\\n\"))\n\t\tgoto done;\ndoit:\n\tmutex_unlock(&cdrom_mutex);\n\treturn proc_dostring(ctl, write, buffer, lenp, ppos);\ndone:\n\tpr_info(\"info buffer too small\\n\");\n\tgoto doit;\n}\n\n \nstatic void cdrom_update_settings(void)\n{\n\tstruct cdrom_device_info *cdi;\n\n\tmutex_lock(&cdrom_mutex);\n\tlist_for_each_entry(cdi, &cdrom_list, list) {\n\t\tif (autoclose && CDROM_CAN(CDC_CLOSE_TRAY))\n\t\t\tcdi->options |= CDO_AUTO_CLOSE;\n\t\telse if (!autoclose)\n\t\t\tcdi->options &= ~CDO_AUTO_CLOSE;\n\t\tif (autoeject && CDROM_CAN(CDC_OPEN_TRAY))\n\t\t\tcdi->options |= CDO_AUTO_EJECT;\n\t\telse if (!autoeject)\n\t\t\tcdi->options &= ~CDO_AUTO_EJECT;\n\t\tif (lockdoor && CDROM_CAN(CDC_LOCK))\n\t\t\tcdi->options |= CDO_LOCK;\n\t\telse if (!lockdoor)\n\t\t\tcdi->options &= ~CDO_LOCK;\n\t\tif (check_media_type)\n\t\t\tcdi->options |= CDO_CHECK_TYPE;\n\t\telse\n\t\t\tcdi->options &= ~CDO_CHECK_TYPE;\n\t}\n\tmutex_unlock(&cdrom_mutex);\n}\n\nstatic int cdrom_sysctl_handler(struct ctl_table *ctl, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\t\n\tret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\n\tif (write) {\n\t\n\t\t \n\t\tautoclose        = !!cdrom_sysctl_settings.autoclose;\n\t\tautoeject        = !!cdrom_sysctl_settings.autoeject;\n\t\tdebug\t         = !!cdrom_sysctl_settings.debug;\n\t\tlockdoor         = !!cdrom_sysctl_settings.lock;\n\t\tcheck_media_type = !!cdrom_sysctl_settings.check;\n\n\t\t \n\t\tcdrom_update_settings();\n\t}\n\n        return ret;\n}\n\n \nstatic struct ctl_table cdrom_table[] = {\n\t{\n\t\t.procname\t= \"info\",\n\t\t.data\t\t= &cdrom_sysctl_settings.info, \n\t\t.maxlen\t\t= CDROM_STR_SIZE,\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= cdrom_sysctl_info,\n\t},\n\t{\n\t\t.procname\t= \"autoclose\",\n\t\t.data\t\t= &cdrom_sysctl_settings.autoclose,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= cdrom_sysctl_handler,\n\t},\n\t{\n\t\t.procname\t= \"autoeject\",\n\t\t.data\t\t= &cdrom_sysctl_settings.autoeject,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= cdrom_sysctl_handler,\n\t},\n\t{\n\t\t.procname\t= \"debug\",\n\t\t.data\t\t= &cdrom_sysctl_settings.debug,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= cdrom_sysctl_handler,\n\t},\n\t{\n\t\t.procname\t= \"lock\",\n\t\t.data\t\t= &cdrom_sysctl_settings.lock,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= cdrom_sysctl_handler,\n\t},\n\t{\n\t\t.procname\t= \"check_media\",\n\t\t.data\t\t= &cdrom_sysctl_settings.check,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= cdrom_sysctl_handler\n\t},\n\t{ }\n};\nstatic struct ctl_table_header *cdrom_sysctl_header;\n\nstatic void cdrom_sysctl_register(void)\n{\n\tstatic atomic_t initialized = ATOMIC_INIT(0);\n\n\tif (!atomic_add_unless(&initialized, 1, 1))\n\t\treturn;\n\n\tcdrom_sysctl_header = register_sysctl(\"dev/cdrom\", cdrom_table);\n\n\t \n\tcdrom_sysctl_settings.autoclose = autoclose;\n\tcdrom_sysctl_settings.autoeject = autoeject;\n\tcdrom_sysctl_settings.debug = debug;\n\tcdrom_sysctl_settings.lock = lockdoor;\n\tcdrom_sysctl_settings.check = check_media_type;\n}\n\nstatic void cdrom_sysctl_unregister(void)\n{\n\tif (cdrom_sysctl_header)\n\t\tunregister_sysctl_table(cdrom_sysctl_header);\n}\n\n#else  \n\nstatic void cdrom_sysctl_register(void)\n{\n}\n\nstatic void cdrom_sysctl_unregister(void)\n{\n}\n\n#endif  \n\nstatic int __init cdrom_init(void)\n{\n\tcdrom_sysctl_register();\n\n\treturn 0;\n}\n\nstatic void __exit cdrom_exit(void)\n{\n\tpr_info(\"Uniform CD-ROM driver unloaded\\n\");\n\tcdrom_sysctl_unregister();\n}\n\nmodule_init(cdrom_init);\nmodule_exit(cdrom_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}