{
  "module_name": "gdrom.c",
  "hash_id": "cb18cd58a92eb4bd0d0529a923e8ad68f0478b69e08a3ca2dcfe68fead8e5f91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cdrom/gdrom.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/cdrom.h>\n#include <linux/bio.h>\n#include <linux/blk-mq.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/wait.h>\n#include <linux/platform_device.h>\n#include <scsi/scsi.h>\n#include <asm/io.h>\n#include <asm/dma.h>\n#include <asm/delay.h>\n#include <mach/dma.h>\n#include <mach/sysasic.h>\n\n#define GDROM_DEV_NAME \"gdrom\"\n#define GD_SESSION_OFFSET 150\n\n \n#define GDROM_COM_SOFTRESET 0x08\n#define GDROM_COM_EXECDIAG 0x90\n#define GDROM_COM_PACKET 0xA0\n#define GDROM_COM_IDDEV 0xA1\n\n \n#define GDROM_BASE_REG\t\t\t0xA05F7000\n#define GDROM_ALTSTATUS_REG\t\t(GDROM_BASE_REG + 0x18)\n#define GDROM_DATA_REG\t\t\t(GDROM_BASE_REG + 0x80)\n#define GDROM_ERROR_REG\t\t(GDROM_BASE_REG + 0x84)\n#define GDROM_INTSEC_REG\t\t(GDROM_BASE_REG + 0x88)\n#define GDROM_SECNUM_REG\t\t(GDROM_BASE_REG + 0x8C)\n#define GDROM_BCL_REG\t\t\t(GDROM_BASE_REG + 0x90)\n#define GDROM_BCH_REG\t\t\t(GDROM_BASE_REG + 0x94)\n#define GDROM_DSEL_REG\t\t\t(GDROM_BASE_REG + 0x98)\n#define GDROM_STATUSCOMMAND_REG\t(GDROM_BASE_REG + 0x9C)\n#define GDROM_RESET_REG\t\t(GDROM_BASE_REG + 0x4E4)\n\n#define GDROM_DMA_STARTADDR_REG\t(GDROM_BASE_REG + 0x404)\n#define GDROM_DMA_LENGTH_REG\t\t(GDROM_BASE_REG + 0x408)\n#define GDROM_DMA_DIRECTION_REG\t(GDROM_BASE_REG + 0x40C)\n#define GDROM_DMA_ENABLE_REG\t\t(GDROM_BASE_REG + 0x414)\n#define GDROM_DMA_STATUS_REG\t\t(GDROM_BASE_REG + 0x418)\n#define GDROM_DMA_WAIT_REG\t\t(GDROM_BASE_REG + 0x4A0)\n#define GDROM_DMA_ACCESS_CTRL_REG\t(GDROM_BASE_REG + 0x4B8)\n\n#define GDROM_HARD_SECTOR\t2048\n#define BLOCK_LAYER_SECTOR\t512\n#define GD_TO_BLK\t\t4\n\n#define GDROM_DEFAULT_TIMEOUT\t(HZ * 7)\n\nstatic DEFINE_MUTEX(gdrom_mutex);\nstatic const struct {\n\tint sense_key;\n\tconst char * const text;\n} sense_texts[] = {\n\t{NO_SENSE, \"OK\"},\n\t{RECOVERED_ERROR, \"Recovered from error\"},\n\t{NOT_READY, \"Device not ready\"},\n\t{MEDIUM_ERROR, \"Disk not ready\"},\n\t{HARDWARE_ERROR, \"Hardware error\"},\n\t{ILLEGAL_REQUEST, \"Command has failed\"},\n\t{UNIT_ATTENTION, \"Device needs attention - disk may have been changed\"},\n\t{DATA_PROTECT, \"Data protection error\"},\n\t{ABORTED_COMMAND, \"Command aborted\"},\n};\n\nstatic struct platform_device *pd;\nstatic int gdrom_major;\nstatic DECLARE_WAIT_QUEUE_HEAD(command_queue);\nstatic DECLARE_WAIT_QUEUE_HEAD(request_queue);\n\nstruct gdromtoc {\n\tunsigned int entry[99];\n\tunsigned int first, last;\n\tunsigned int leadout;\n};\n\nstatic struct gdrom_unit {\n\tstruct gendisk *disk;\n\tstruct cdrom_device_info *cd_info;\n\tint status;\n\tint pending;\n\tint transfer;\n\tchar disk_type;\n\tstruct gdromtoc *toc;\n\tstruct request_queue *gdrom_rq;\n\tstruct blk_mq_tag_set tag_set;\n} gd;\n\nstruct gdrom_id {\n\tchar mid;\n\tchar modid;\n\tchar verid;\n\tchar padA[13];\n\tchar mname[16];\n\tchar modname[16];\n\tchar firmver[16];\n\tchar padB[16];\n};\n\nstatic int gdrom_getsense(short *bufstring);\nstatic int gdrom_packetcommand(struct cdrom_device_info *cd_info,\n\tstruct packet_command *command);\nstatic int gdrom_hardreset(struct cdrom_device_info *cd_info);\n\nstatic bool gdrom_is_busy(void)\n{\n\treturn (__raw_readb(GDROM_ALTSTATUS_REG) & 0x80) != 0;\n}\n\nstatic bool gdrom_data_request(void)\n{\n\treturn (__raw_readb(GDROM_ALTSTATUS_REG) & 0x88) == 8;\n}\n\nstatic bool gdrom_wait_clrbusy(void)\n{\n\tunsigned long timeout = jiffies + GDROM_DEFAULT_TIMEOUT;\n\twhile ((__raw_readb(GDROM_ALTSTATUS_REG) & 0x80) &&\n\t\t(time_before(jiffies, timeout)))\n\t\tcpu_relax();\n\treturn time_before(jiffies, timeout + 1);\n}\n\nstatic bool gdrom_wait_busy_sleeps(void)\n{\n\tunsigned long timeout;\n\t \n\ttimeout = jiffies + GDROM_DEFAULT_TIMEOUT;\n\twhile (!gdrom_is_busy() && time_before(jiffies, timeout))\n\t\tcpu_relax();\n\t \n\treturn gdrom_wait_clrbusy();\n}\n\nstatic void gdrom_identifydevice(void *buf)\n{\n\tint c;\n\tshort *data = buf;\n\t \n\tif (!gdrom_wait_clrbusy()) {\n\t\tgdrom_getsense(NULL);\n\t\treturn;\n\t}\n\t__raw_writeb(GDROM_COM_IDDEV, GDROM_STATUSCOMMAND_REG);\n\tif (!gdrom_wait_busy_sleeps()) {\n\t\tgdrom_getsense(NULL);\n\t\treturn;\n\t}\n\t \n\tfor (c = 0; c < 40; c++)\n\t\tdata[c] = __raw_readw(GDROM_DATA_REG);\n}\n\nstatic void gdrom_spicommand(void *spi_string, int buflen)\n{\n\tshort *cmd = spi_string;\n\tunsigned long timeout;\n\n\t \n\t__raw_writeb(0x08, GDROM_ALTSTATUS_REG);\n\t \n\t__raw_writeb(buflen & 0xFF, GDROM_BCL_REG);\n\t__raw_writeb((buflen >> 8) & 0xFF, GDROM_BCH_REG);\n\t \n\t__raw_writeb(0, GDROM_INTSEC_REG);\n\t__raw_writeb(0, GDROM_SECNUM_REG);\n\t__raw_writeb(0, GDROM_ERROR_REG);\n\t \n\tif (!gdrom_wait_clrbusy()) {\n\t\tgdrom_getsense(NULL);\n\t\treturn;\n\t}\n\ttimeout = jiffies + GDROM_DEFAULT_TIMEOUT;\n\t__raw_writeb(GDROM_COM_PACKET, GDROM_STATUSCOMMAND_REG);\n\twhile (!gdrom_data_request() && time_before(jiffies, timeout))\n\t\tcpu_relax();\n\tif (!time_before(jiffies, timeout + 1)) {\n\t\tgdrom_getsense(NULL);\n\t\treturn;\n\t}\n\toutsw(GDROM_DATA_REG, cmd, 6);\n}\n\n\n \nstatic char gdrom_execute_diagnostic(void)\n{\n\tgdrom_hardreset(gd.cd_info);\n\tif (!gdrom_wait_clrbusy())\n\t\treturn 0;\n\t__raw_writeb(GDROM_COM_EXECDIAG, GDROM_STATUSCOMMAND_REG);\n\tif (!gdrom_wait_busy_sleeps())\n\t\treturn 0;\n\treturn __raw_readb(GDROM_ERROR_REG);\n}\n\n \nstatic int gdrom_preparedisk_cmd(void)\n{\n\tstruct packet_command *spin_command;\n\tspin_command = kzalloc(sizeof(struct packet_command), GFP_KERNEL);\n\tif (!spin_command)\n\t\treturn -ENOMEM;\n\tspin_command->cmd[0] = 0x70;\n\tspin_command->cmd[2] = 0x1f;\n\tspin_command->buflen = 0;\n\tgd.pending = 1;\n\tgdrom_packetcommand(gd.cd_info, spin_command);\n\t \n\twait_event_interruptible_timeout(command_queue, gd.pending == 0,\n\t\tGDROM_DEFAULT_TIMEOUT);\n\tgd.pending = 0;\n\tkfree(spin_command);\n\tif (gd.status & 0x01) {\n\t\t \n\t\tgdrom_getsense(NULL);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nstatic int gdrom_readtoc_cmd(struct gdromtoc *toc, int session)\n{\n\tint tocsize;\n\tstruct packet_command *toc_command;\n\tint err = 0;\n\n\ttoc_command = kzalloc(sizeof(struct packet_command), GFP_KERNEL);\n\tif (!toc_command)\n\t\treturn -ENOMEM;\n\ttocsize = sizeof(struct gdromtoc);\n\ttoc_command->cmd[0] = 0x14;\n\ttoc_command->cmd[1] = session;\n\ttoc_command->cmd[3] = tocsize >> 8;\n\ttoc_command->cmd[4] = tocsize & 0xff;\n\ttoc_command->buflen = tocsize;\n\tif (gd.pending) {\n\t\terr = -EBUSY;\n\t\tgoto cleanup_readtoc_final;\n\t}\n\tgd.pending = 1;\n\tgdrom_packetcommand(gd.cd_info, toc_command);\n\twait_event_interruptible_timeout(command_queue, gd.pending == 0,\n\t\tGDROM_DEFAULT_TIMEOUT);\n\tif (gd.pending) {\n\t\terr = -EINVAL;\n\t\tgoto cleanup_readtoc;\n\t}\n\tinsw(GDROM_DATA_REG, toc, tocsize/2);\n\tif (gd.status & 0x01)\n\t\terr = -EINVAL;\n\ncleanup_readtoc:\n\tgd.pending = 0;\ncleanup_readtoc_final:\n\tkfree(toc_command);\n\treturn err;\n}\n\n \nstatic int get_entry_lba(int track)\n{\n\treturn (cpu_to_be32(track & 0xffffff00) - GD_SESSION_OFFSET);\n}\n\nstatic int get_entry_q_ctrl(int track)\n{\n\treturn (track & 0x000000f0) >> 4;\n}\n\nstatic int get_entry_track(int track)\n{\n\treturn (track & 0x0000ff00) >> 8;\n}\n\nstatic int gdrom_get_last_session(struct cdrom_device_info *cd_info,\n\tstruct cdrom_multisession *ms_info)\n{\n\tint fentry, lentry, track, data, err;\n\n\tif (!gd.toc)\n\t\treturn -ENOMEM;\n\n\t \n\terr = gdrom_readtoc_cmd(gd.toc, 1);\n\t \n\tif (err) {\n\t\terr = gdrom_readtoc_cmd(gd.toc, 0);\n\t\tif (err) {\n\t\t\tpr_info(\"Could not get CD table of contents\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tfentry = get_entry_track(gd.toc->first);\n\tlentry = get_entry_track(gd.toc->last);\n\t \n\ttrack = get_entry_track(gd.toc->last);\n\tdo {\n\t\tdata = gd.toc->entry[track - 1];\n\t\tif (get_entry_q_ctrl(data))\n\t\t\tbreak;\t \n\t\ttrack--;\n\t} while (track >= fentry);\n\n\tif ((track > 100) || (track < get_entry_track(gd.toc->first))) {\n\t\tpr_info(\"No data on the last session of the CD\\n\");\n\t\tgdrom_getsense(NULL);\n\t\treturn -ENXIO;\n\t}\n\n\tms_info->addr_format = CDROM_LBA;\n\tms_info->addr.lba = get_entry_lba(data);\n\tms_info->xa_flag = 1;\n\treturn 0;\n}\n\nstatic int gdrom_open(struct cdrom_device_info *cd_info, int purpose)\n{\n\t \n\treturn gdrom_preparedisk_cmd();\n}\n\n \nstatic void gdrom_release(struct cdrom_device_info *cd_info)\n{\n}\n\nstatic int gdrom_drivestatus(struct cdrom_device_info *cd_info, int ignore)\n{\n\t \n\tchar sense = __raw_readb(GDROM_ERROR_REG);\n\tsense &= 0xF0;\n\tif (sense == 0)\n\t\treturn CDS_DISC_OK;\n\tif (sense == 0x20)\n\t\treturn CDS_DRIVE_NOT_READY;\n\t \n\treturn CDS_NO_INFO;\n}\n\nstatic unsigned int gdrom_check_events(struct cdrom_device_info *cd_info,\n\t\t\t\t       unsigned int clearing, int ignore)\n{\n\t \n\treturn (__raw_readb(GDROM_ERROR_REG) & 0xF0) == 0x60 ?\n\t\tDISK_EVENT_MEDIA_CHANGE : 0;\n}\n\n \nstatic int gdrom_hardreset(struct cdrom_device_info *cd_info)\n{\n\tint count;\n\t__raw_writel(0x1fffff, GDROM_RESET_REG);\n\tfor (count = 0xa0000000; count < 0xa0200000; count += 4)\n\t\t__raw_readl(count);\n\treturn 0;\n}\n\n \nstatic int gdrom_packetcommand(struct cdrom_device_info *cd_info,\n\tstruct packet_command *command)\n{\n\tgdrom_spicommand(&command->cmd, command->buflen);\n\treturn 0;\n}\n\n \nstatic int gdrom_getsense(short *bufstring)\n{\n\tstruct packet_command *sense_command;\n\tshort sense[5];\n\tint sense_key;\n\tint err = -EIO;\n\n\tsense_command = kzalloc(sizeof(struct packet_command), GFP_KERNEL);\n\tif (!sense_command)\n\t\treturn -ENOMEM;\n\tsense_command->cmd[0] = 0x13;\n\tsense_command->cmd[4] = 10;\n\tsense_command->buflen = 10;\n\t \n\tif (gd.pending && !gdrom_wait_clrbusy()) {\n\t\terr = -EBUSY;\n\t\tgoto cleanup_sense_final;\n\t}\n\tgd.pending = 1;\n\tgdrom_packetcommand(gd.cd_info, sense_command);\n\twait_event_interruptible_timeout(command_queue, gd.pending == 0,\n\t\tGDROM_DEFAULT_TIMEOUT);\n\tif (gd.pending)\n\t\tgoto cleanup_sense;\n\tinsw(GDROM_DATA_REG, &sense, sense_command->buflen/2);\n\tif (sense[1] & 40) {\n\t\tpr_info(\"Drive not ready - command aborted\\n\");\n\t\tgoto cleanup_sense;\n\t}\n\tsense_key = sense[1] & 0x0F;\n\tif (sense_key < ARRAY_SIZE(sense_texts))\n\t\tpr_info(\"%s\\n\", sense_texts[sense_key].text);\n\telse\n\t\tpr_err(\"Unknown sense key: %d\\n\", sense_key);\n\tif (bufstring)  \n\t\tmemcpy(bufstring, &sense[4], 2);\n\tif (sense_key < 2)\n\t\terr = 0;\n\ncleanup_sense:\n\tgd.pending = 0;\ncleanup_sense_final:\n\tkfree(sense_command);\n\treturn err;\n}\n\nstatic int gdrom_audio_ioctl(struct cdrom_device_info *cdi, unsigned int cmd,\n\t\t\t     void *arg)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct cdrom_device_ops gdrom_ops = {\n\t.open\t\t\t= gdrom_open,\n\t.release\t\t= gdrom_release,\n\t.drive_status\t\t= gdrom_drivestatus,\n\t.check_events\t\t= gdrom_check_events,\n\t.get_last_session\t= gdrom_get_last_session,\n\t.reset\t\t\t= gdrom_hardreset,\n\t.audio_ioctl\t\t= gdrom_audio_ioctl,\n\t.generic_packet\t\t= cdrom_dummy_generic_packet,\n\t.capability\t\t= CDC_MULTI_SESSION | CDC_MEDIA_CHANGED |\n\t\t\t\t  CDC_RESET | CDC_DRIVE_STATUS | CDC_CD_R,\n};\n\nstatic int gdrom_bdops_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tint ret;\n\n\tdisk_check_media_change(disk);\n\n\tmutex_lock(&gdrom_mutex);\n\tret = cdrom_open(gd.cd_info, mode);\n\tmutex_unlock(&gdrom_mutex);\n\treturn ret;\n}\n\nstatic void gdrom_bdops_release(struct gendisk *disk)\n{\n\tmutex_lock(&gdrom_mutex);\n\tcdrom_release(gd.cd_info);\n\tmutex_unlock(&gdrom_mutex);\n}\n\nstatic unsigned int gdrom_bdops_check_events(struct gendisk *disk,\n\t\t\t\t\t     unsigned int clearing)\n{\n\treturn cdrom_check_events(gd.cd_info, clearing);\n}\n\nstatic int gdrom_bdops_ioctl(struct block_device *bdev, blk_mode_t mode,\n\tunsigned cmd, unsigned long arg)\n{\n\tint ret;\n\n\tmutex_lock(&gdrom_mutex);\n\tret = cdrom_ioctl(gd.cd_info, bdev, cmd, arg);\n\tmutex_unlock(&gdrom_mutex);\n\n\treturn ret;\n}\n\nstatic const struct block_device_operations gdrom_bdops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= gdrom_bdops_open,\n\t.release\t\t= gdrom_bdops_release,\n\t.check_events\t\t= gdrom_bdops_check_events,\n\t.ioctl\t\t\t= gdrom_bdops_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= blkdev_compat_ptr_ioctl,\n#endif\n};\n\nstatic irqreturn_t gdrom_command_interrupt(int irq, void *dev_id)\n{\n\tgd.status = __raw_readb(GDROM_STATUSCOMMAND_REG);\n\tif (gd.pending != 1)\n\t\treturn IRQ_HANDLED;\n\tgd.pending = 0;\n\twake_up_interruptible(&command_queue);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t gdrom_dma_interrupt(int irq, void *dev_id)\n{\n\tgd.status = __raw_readb(GDROM_STATUSCOMMAND_REG);\n\tif (gd.transfer != 1)\n\t\treturn IRQ_HANDLED;\n\tgd.transfer = 0;\n\twake_up_interruptible(&request_queue);\n\treturn IRQ_HANDLED;\n}\n\nstatic int gdrom_set_interrupt_handlers(void)\n{\n\tint err;\n\n\terr = request_irq(HW_EVENT_GDROM_CMD, gdrom_command_interrupt,\n\t\t0, \"gdrom_command\", &gd);\n\tif (err)\n\t\treturn err;\n\terr = request_irq(HW_EVENT_GDROM_DMA, gdrom_dma_interrupt,\n\t\t0, \"gdrom_dma\", &gd);\n\tif (err)\n\t\tfree_irq(HW_EVENT_GDROM_CMD, &gd);\n\treturn err;\n}\n\n \nstatic blk_status_t gdrom_readdisk_dma(struct request *req)\n{\n\tint block, block_cnt;\n\tblk_status_t err;\n\tstruct packet_command *read_command;\n\tunsigned long timeout;\n\n\tread_command = kzalloc(sizeof(struct packet_command), GFP_KERNEL);\n\tif (!read_command)\n\t\treturn BLK_STS_RESOURCE;\n\n\tread_command->cmd[0] = 0x30;\n\tread_command->cmd[1] = 0x20;\n\tblock = blk_rq_pos(req)/GD_TO_BLK + GD_SESSION_OFFSET;\n\tblock_cnt = blk_rq_sectors(req)/GD_TO_BLK;\n\t__raw_writel(page_to_phys(bio_page(req->bio)) + bio_offset(req->bio),\n\t\t\tGDROM_DMA_STARTADDR_REG);\n\t__raw_writel(block_cnt * GDROM_HARD_SECTOR, GDROM_DMA_LENGTH_REG);\n\t__raw_writel(1, GDROM_DMA_DIRECTION_REG);\n\t__raw_writel(1, GDROM_DMA_ENABLE_REG);\n\tread_command->cmd[2] = (block >> 16) & 0xFF;\n\tread_command->cmd[3] = (block >> 8) & 0xFF;\n\tread_command->cmd[4] = block & 0xFF;\n\tread_command->cmd[8] = (block_cnt >> 16) & 0xFF;\n\tread_command->cmd[9] = (block_cnt >> 8) & 0xFF;\n\tread_command->cmd[10] = block_cnt & 0xFF;\n\t \n\t__raw_writeb(1, GDROM_ERROR_REG);\n\t \n\t__raw_writeb(0, GDROM_SECNUM_REG);\n\t__raw_writeb(0, GDROM_BCL_REG);\n\t__raw_writeb(0, GDROM_BCH_REG);\n\t__raw_writeb(0, GDROM_DSEL_REG);\n\t__raw_writeb(0, GDROM_INTSEC_REG);\n\t \n\ttimeout = jiffies + HZ / 2;\n\twhile (gdrom_is_busy() && time_before(jiffies, timeout))\n\t\tcpu_relax();\n\t__raw_writeb(GDROM_COM_PACKET, GDROM_STATUSCOMMAND_REG);\n\ttimeout = jiffies + HZ / 2;\n\t \n\twhile (gdrom_is_busy() && time_before(jiffies, timeout))\n\t\tcpu_relax();\n\tgd.pending = 1;\n\tgd.transfer = 1;\n\toutsw(GDROM_DATA_REG, &read_command->cmd, 6);\n\ttimeout = jiffies + HZ / 2;\n\t \n\twhile (__raw_readb(GDROM_DMA_STATUS_REG) &&\n\t\ttime_before(jiffies, timeout))\n\t\tcpu_relax();\n\t \n\t__raw_writeb(1, GDROM_DMA_STATUS_REG);\n\twait_event_interruptible_timeout(request_queue,\n\t\tgd.transfer == 0, GDROM_DEFAULT_TIMEOUT);\n\terr = gd.transfer ? BLK_STS_IOERR : BLK_STS_OK;\n\tgd.transfer = 0;\n\tgd.pending = 0;\n\n\tblk_mq_end_request(req, err);\n\tkfree(read_command);\n\treturn BLK_STS_OK;\n}\n\nstatic blk_status_t gdrom_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t   const struct blk_mq_queue_data *bd)\n{\n\tblk_mq_start_request(bd->rq);\n\n\tswitch (req_op(bd->rq)) {\n\tcase REQ_OP_READ:\n\t\treturn gdrom_readdisk_dma(bd->rq);\n\tcase REQ_OP_WRITE:\n\t\tpr_notice(\"Read only device - write request ignored\\n\");\n\t\treturn BLK_STS_IOERR;\n\tdefault:\n\t\tprintk(KERN_DEBUG \"gdrom: Non-fs request ignored\\n\");\n\t\treturn BLK_STS_IOERR;\n\t}\n}\n\n \nstatic int gdrom_outputversion(void)\n{\n\tstruct gdrom_id *id;\n\tchar *model_name, *manuf_name, *firmw_ver;\n\tint err = -ENOMEM;\n\n\t \n\tid = kzalloc(sizeof(struct gdrom_id), GFP_KERNEL);\n\tif (!id)\n\t\treturn err;\n\tgdrom_identifydevice(id);\n\tmodel_name = kstrndup(id->modname, 16, GFP_KERNEL);\n\tif (!model_name)\n\t\tgoto free_id;\n\tmanuf_name = kstrndup(id->mname, 16, GFP_KERNEL);\n\tif (!manuf_name)\n\t\tgoto free_model_name;\n\tfirmw_ver = kstrndup(id->firmver, 16, GFP_KERNEL);\n\tif (!firmw_ver)\n\t\tgoto free_manuf_name;\n\tpr_info(\"%s from %s with firmware %s\\n\",\n\t\tmodel_name, manuf_name, firmw_ver);\n\terr = 0;\n\tkfree(firmw_ver);\nfree_manuf_name:\n\tkfree(manuf_name);\nfree_model_name:\n\tkfree(model_name);\nfree_id:\n\tkfree(id);\n\treturn err;\n}\n\n \nstatic int gdrom_init_dma_mode(void)\n{\n\t__raw_writeb(0x13, GDROM_ERROR_REG);\n\t__raw_writeb(0x22, GDROM_INTSEC_REG);\n\tif (!gdrom_wait_clrbusy())\n\t\treturn -EBUSY;\n\t__raw_writeb(0xEF, GDROM_STATUSCOMMAND_REG);\n\tif (!gdrom_wait_busy_sleeps())\n\t\treturn -EBUSY;\n\t \n\t__raw_writel(0x8843407F, GDROM_DMA_ACCESS_CTRL_REG);\n\t__raw_writel(9, GDROM_DMA_WAIT_REG);  \n\treturn 0;\n}\n\nstatic void probe_gdrom_setupcd(void)\n{\n\tgd.cd_info->ops = &gdrom_ops;\n\tgd.cd_info->capacity = 1;\n\tstrcpy(gd.cd_info->name, GDROM_DEV_NAME);\n\tgd.cd_info->mask = CDC_CLOSE_TRAY|CDC_OPEN_TRAY|CDC_LOCK|\n\t\tCDC_SELECT_DISC;\n}\n\nstatic void probe_gdrom_setupdisk(void)\n{\n\tgd.disk->major = gdrom_major;\n\tgd.disk->first_minor = 1;\n\tgd.disk->minors = 1;\n\tgd.disk->flags |= GENHD_FL_NO_PART;\n\tstrcpy(gd.disk->disk_name, GDROM_DEV_NAME);\n}\n\nstatic int probe_gdrom_setupqueue(void)\n{\n\tblk_queue_logical_block_size(gd.gdrom_rq, GDROM_HARD_SECTOR);\n\t \n\tblk_queue_max_segments(gd.gdrom_rq, 1);\n\t \n\tblk_queue_max_segment_size(gd.gdrom_rq, 0x40000);\n\tgd.disk->queue = gd.gdrom_rq;\n\treturn gdrom_init_dma_mode();\n}\n\nstatic const struct blk_mq_ops gdrom_mq_ops = {\n\t.queue_rq\t= gdrom_queue_rq,\n};\n\n \nstatic int probe_gdrom(struct platform_device *devptr)\n{\n\tint err;\n\n\t \n\tmemset(&gd, 0, sizeof(gd));\n\n\t \n\tif (gdrom_execute_diagnostic() != 1) {\n\t\tpr_warn(\"ATA Probe for GDROM failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\t \n\tif (gdrom_outputversion())\n\t\treturn -ENOMEM;\n\t \n\tgdrom_major = register_blkdev(0, GDROM_DEV_NAME);\n\tif (gdrom_major <= 0)\n\t\treturn gdrom_major;\n\tpr_info(\"Registered with major number %d\\n\",\n\t\tgdrom_major);\n\t \n\tgd.cd_info = kzalloc(sizeof(struct cdrom_device_info), GFP_KERNEL);\n\tif (!gd.cd_info) {\n\t\terr = -ENOMEM;\n\t\tgoto probe_fail_no_mem;\n\t}\n\tprobe_gdrom_setupcd();\n\n\terr = blk_mq_alloc_sq_tag_set(&gd.tag_set, &gdrom_mq_ops, 1,\n\t\t\t\tBLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_BLOCKING);\n\tif (err)\n\t\tgoto probe_fail_free_cd_info;\n\n\tgd.disk = blk_mq_alloc_disk(&gd.tag_set, NULL);\n\tif (IS_ERR(gd.disk)) {\n\t\terr = PTR_ERR(gd.disk);\n\t\tgoto probe_fail_free_tag_set;\n\t}\n\tgd.gdrom_rq = gd.disk->queue;\n\tprobe_gdrom_setupdisk();\n\tif (register_cdrom(gd.disk, gd.cd_info)) {\n\t\terr = -ENODEV;\n\t\tgoto probe_fail_cleanup_disk;\n\t}\n\tgd.disk->fops = &gdrom_bdops;\n\tgd.disk->events = DISK_EVENT_MEDIA_CHANGE;\n\t \n\terr = gdrom_set_interrupt_handlers();\n\tif (err)\n\t\tgoto probe_fail_cleanup_disk;\n\n\terr = probe_gdrom_setupqueue();\n\tif (err)\n\t\tgoto probe_fail_free_irqs;\n\n\tgd.toc = kzalloc(sizeof(struct gdromtoc), GFP_KERNEL);\n\tif (!gd.toc) {\n\t\terr = -ENOMEM;\n\t\tgoto probe_fail_free_irqs;\n\t}\n\terr = add_disk(gd.disk);\n\tif (err)\n\t\tgoto probe_fail_add_disk;\n\n\treturn 0;\n\nprobe_fail_add_disk:\n\tkfree(gd.toc);\nprobe_fail_free_irqs:\n\tfree_irq(HW_EVENT_GDROM_DMA, &gd);\n\tfree_irq(HW_EVENT_GDROM_CMD, &gd);\nprobe_fail_cleanup_disk:\n\tput_disk(gd.disk);\nprobe_fail_free_tag_set:\n\tblk_mq_free_tag_set(&gd.tag_set);\nprobe_fail_free_cd_info:\n\tkfree(gd.cd_info);\nprobe_fail_no_mem:\n\tunregister_blkdev(gdrom_major, GDROM_DEV_NAME);\n\tgdrom_major = 0;\n\tpr_warn(\"Probe failed - error is 0x%X\\n\", err);\n\treturn err;\n}\n\nstatic int remove_gdrom(struct platform_device *devptr)\n{\n\tblk_mq_free_tag_set(&gd.tag_set);\n\tfree_irq(HW_EVENT_GDROM_CMD, &gd);\n\tfree_irq(HW_EVENT_GDROM_DMA, &gd);\n\tdel_gendisk(gd.disk);\n\tif (gdrom_major)\n\t\tunregister_blkdev(gdrom_major, GDROM_DEV_NAME);\n\tunregister_cdrom(gd.cd_info);\n\tkfree(gd.cd_info);\n\tkfree(gd.toc);\n\n\treturn 0;\n}\n\nstatic struct platform_driver gdrom_driver = {\n\t.probe = probe_gdrom,\n\t.remove = remove_gdrom,\n\t.driver = {\n\t\t\t.name = GDROM_DEV_NAME,\n\t},\n};\n\nstatic int __init init_gdrom(void)\n{\n\tint rc;\n\n\trc = platform_driver_register(&gdrom_driver);\n\tif (rc)\n\t\treturn rc;\n\tpd = platform_device_register_simple(GDROM_DEV_NAME, -1, NULL, 0);\n\tif (IS_ERR(pd)) {\n\t\tplatform_driver_unregister(&gdrom_driver);\n\t\treturn PTR_ERR(pd);\n\t}\n\treturn 0;\n}\n\nstatic void __exit exit_gdrom(void)\n{\n\tplatform_device_unregister(pd);\n\tplatform_driver_unregister(&gdrom_driver);\n}\n\nmodule_init(init_gdrom);\nmodule_exit(exit_gdrom);\nMODULE_AUTHOR(\"Adrian McMenamin <adrian@mcmen.demon.co.uk>\");\nMODULE_DESCRIPTION(\"SEGA Dreamcast GD-ROM Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}